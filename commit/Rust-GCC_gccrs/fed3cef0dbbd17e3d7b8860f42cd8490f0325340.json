{"sha": "fed3cef0dbbd17e3d7b8860f42cd8490f0325340", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZmVkM2NlZjBkYmJkMTdlM2Q3Yjg4NjBmNDJjZDg0OTBmMDMyNTM0MA==", "commit": {"author": {"name": "Richard Kenner", "email": "kenner@vlsi1.ultra.nyu.edu", "date": "2000-02-27T21:39:40Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "2000-02-27T21:39:40Z"}, "message": "builtins.c (c_strlen): Use size_diffop and return ssizetype value.\n\n\t* builtins.c (c_strlen): Use size_diffop and return ssizetype value.\n\t(expand_builtin_strcpy): Pass correct type to size_binop.\n\t(expand_builtin_strcmp): Likewise.\n\tClean up conditional structure.\n\t* c-decl.c (init_decl_processing): Don't call set_sizetype twice.\n\t(complete_array_type): Don't use size_binop for MAXINDEX.\n\t* c-typeck.c (c_sizeof): Use size_one_node and TYPE_SIZE_UNIT.\n\t(c_sizeof_nowarn, c_size_in_bytes): Likewise.\n\t(c_alignof): Use size_one_node.\n\t(build_unary_op): Pass arg of proper type to size_binop.\n\t(really_start_incremental_init, push_init_level): Use sizetype for\n\tconstructor{,_bit,_unfilled}_index.\n\t(pop_init_label, output_init_element): Likewise.\n\t(output_pending_init_elements, process_init_element): Likewise.\n\t* calls.c (compute_argument_block_size): Field VAR is ssizetype.\n\t* expr.c (store_expr): Use size_int.\n\t(store_constructor): Use proper types for size_binop args.\n\t(get_inner_reference, expand_expr, case ARRAY_REF): Likewise.\n\t(expand_expr_unaligned): Likewise.\n\t(string_contant): Return object of sizetype.\n\t* expr.h (SUB_PARM_SIZE): Call size_diffop and pass proper types.\n\t(ARGS_SIZE_RTX): Call ARGS_SIZE_TREE.\n\t(ARGS_SIZE_TREE): Pass proper types to size_binop.\n\t* fold-const.c (int_const_binop): Refine when size_int is called.\n\t(fold_convert): Likewise.\n\t(size_int_wide): Rework to take KIND as arg, only take low order\n\tbits, handle new sizetype_tab datatype, and chain entries in\n\tsize_table.\n\t(size_int_type_wide): New function.\n\t(size_binop): Validate types of arguments.\n\t(ssize_binop): Deleted.\n\t(size_diffop): New function.\n\t(extract_muldiv): Only fold division into multiplication for sizetypes.\n\t* function.c (assign_parms): Use size_diffop and make sure\n\tVAR field is of ssizetype; also pass proper type to size_binop.\n\t(locate_and_pad_parm, pad_to_arg_alignment): Likewise.\n\t(round_down): Deleted from here.\n\t* store-layout.c (sizetype_tab): Now an array.\n\t(sizetype_set, early_root_list): New variables.\n\t(variable_size): Use size_one_node.\n\t(round_up): Pass proper type to size_binop.\n\t(round_down): Moved to here and corrected as above.\n\t(layout_record): Pass proper arg types to size_binop.\n\t(layout_type): Likewise.\n\tIf sizetype_set is zero, record the type just laid out.\n\t(make_unsigned_type): Don't call set_sizetype;\n\t(make_signed_type): Likewise; also, call fixup_signed_type.\n\t(initialize_sizetypes): New function.\n\t(set_sizetype): Make copy of types, set TYPE_IS_SIZETYPE, and\n\tset name of bitsizetype to \"bit_size_type\".\n\tFix up type of sizes of all types made before call.\n\t* tm.texi (ROUND_TYPE_SIZE_UNIT): New macro.\n\t* tree.c (fix_sizetype): Deleted.\n\t(build_common_tree_nodes): Call initialize_sizetypes.\n\t(build_common_tree_nodes_2): Don't call fix_sizetype.\n\t* tree.h (TYPE_IS_SIZETYPE): New macro.\n\t(initialize_sizetype): New declaration.\n\t(enum size_type_kind): New type.\n\t(struct sizetype_tab): Deleted.\n\t(sizetype_tab): Now array; adjust sizetype macros.\n\t(size_diffop, size_int_type_wide): New functions.\n\t(size_int_wide): Change number of args and type; access macros changed.\n\t(ssize_int, sbitsize_int): New macros.\n\t* config/i960/i960.h (ROUND_TYPE_SIZE): Use size_int.\n\t(ROUND_TYPE_SIZE_UNIT): New macro.\n\t* ch/actions.c (chill_convert_for_assignment): Don't use size_binop\n\tfor things that aren't sizes.\n\t(expand_varying_length_assignment): Likewise.\n\t* ch/convert.c (digest_array_tuple, convert): Likewise.\n\t* ch/typeck.c (build_chill_slice, smash_dummy_type): Likewise.\n\t(build_chill_slice_with_range): Likewise.\n\t(build_chill_slice_with_length): Likewise.\n\t(build_array_from_set): Adjust types for size_binop.\n\t* ch/expr.c (build_concat_expr, build_chill_repetition_op): Likewise.\n\t(build_chill_sizeof): Use TYPE_SIZE_UNIT.\n\t* ch/tree.c (build_string_type): Pass proper type to size_binop.\n\t* cp/class.c (dfs_build_vtable_offset_vtbl_entries): Don't use\n\tsize_binop on things that are not sizes; ssize_binop deleted.\n\tCall size_diffop when appropriate.\n\t(dfs_build_vcall_offset_vtbl_entries): Likewise.\n\t(build_primary_vtable, build_secondary_vtable): Likewise.\n\t(dfs_set_offset_for_unshared_vbases, dfs_modify_vtables): Likewise.\n\tVariable I is HOST_WIDE_INT.\n\t(get_vfield_offset): Pass proper types to size_binop.\n\t(size_extra_vtbl_entries, layout_virtual_bases): Likewise.\n\t(finish_struct_1): Likewise.\n\t(skip_rtti_stuff): Arg N is now pointer to signed.\n\t(layout_class_type): Use size_zero_node.\n\t* cp/cp-tree.h (skip_rtti_stuff): Arg N is pointer to signed.\n\t* cp/cvt.c (cp_convert_to_pointer): Pass proper types to size_binop.\n\t* cp/decl.c (complete_arry_type): Pass proper types to size_binop.\n\t(xref_basetypes): BINFO_OFFSET is sizetype.\n\t* cp/error.c (dump_expr): Don't use size_binop non-sizes.\n\t* cp/expr.c (cplus_expand_constant): Pass proper types to size_binop.\n\t* cp/init.c (construct_virtual_bases): Fix type error.\n\t(build_vec_delete_1): Pass proper type to size_binop and don't\n\tfold result.\n\t* cp/lex.c (cp_make_lang_type): BINFO_OFFSET is sizetype.\n\t* cp/rtti.c (get_base_offset): Pass proper type to size_binop.\n\t* cp/search.c (dfs_find_vbases): Fix type error.\n\t(expand_upcast_fixups): Arg to skip_rtti_stuff is pointer to signed.\n\t(dfs_get_vbase_types): BINFO_OFFSET is sizetype.\n\t* cp/tree.c (debug_binfo): Variable N is signed.\n\tUse HOST_WIDE_INT_PRINT_DEC.\n\t* cp/typeck.c (comptypes): sizetype is same as equivalent integer type.\n\t(c_sizeof, c_sizeof_nowarn, expr_sizeof): Use TYPE_SIZE_UNIT,\n\tsize_one_node and size_zero_node.\n\t(c_alignof): Use size_one_node.\n\t(build_component_addr): Pass proper types to size_binop.\n\t(expand_ptrmemfunc_cst): Don't use size_binop on non-sizes.\n\t* f/com.c (ffecom_arrayref_): Convert args to size_binop to proper\n\ttype.\n\t(ffecom_tree_canonize_ptr_): Don't use size_binop for non-sizes.\n\t(ffecom_tree_canonize_ref_): Likewise.\n\t(type_for_mode): Handle TImode.\n\t* f/ste.c (ffeste_io_dofio_, ffeste_io_douio_): Use TYPE_SIZE_UNIT.\n\t(ffeste_io_ciclist_): Likewise.\n\t* java/expr.c (build_java_ret): Pass proper type to size_binop.\n\nFrom-SVN: r32225", "tree": {"sha": "da73c398c9c03435ecc0d3821031b7c0fe89911d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/da73c398c9c03435ecc0d3821031b7c0fe89911d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/fed3cef0dbbd17e3d7b8860f42cd8490f0325340", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fed3cef0dbbd17e3d7b8860f42cd8490f0325340", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fed3cef0dbbd17e3d7b8860f42cd8490f0325340", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fed3cef0dbbd17e3d7b8860f42cd8490f0325340/comments", "author": null, "committer": null, "parents": [{"sha": "43931371e2321b6c50c3e0b9095d46606ec48ce1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/43931371e2321b6c50c3e0b9095d46606ec48ce1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/43931371e2321b6c50c3e0b9095d46606ec48ce1"}], "stats": {"total": 1523, "additions": 885, "deletions": 638}, "files": [{"sha": "0059eb0e8950249fa2f36a0e5be30ad32fecd5b7", "filename": "gcc/ChangeLog", "status": "modified", "additions": 68, "deletions": 0, "changes": 68, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fed3cef0dbbd17e3d7b8860f42cd8490f0325340/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fed3cef0dbbd17e3d7b8860f42cd8490f0325340/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=fed3cef0dbbd17e3d7b8860f42cd8490f0325340", "patch": "@@ -1,3 +1,71 @@\n+Sun Feb 27 16:40:33 2000  Richard Kenner  <kenner@vlsi1.ultra.nyu.edu>\n+\n+\t* builtins.c (c_strlen): Use size_diffop and return ssizetype value.\n+\t(expand_builtin_strcpy): Pass correct type to size_binop.\n+\t(expand_builtin_strcmp): Likewise.\n+\tClean up conditional structure.\n+\t* c-decl.c (init_decl_processing): Don't call set_sizetype twice.\n+\t(complete_array_type): Don't use size_binop for MAXINDEX.\n+\t* c-typeck.c (c_sizeof): Use size_one_node and TYPE_SIZE_UNIT.\n+\t(c_sizeof_nowarn, c_size_in_bytes): Likewise.\n+\t(c_alignof): Use size_one_node.\n+\t(build_unary_op): Pass arg of proper type to size_binop.\n+\t(really_start_incremental_init, push_init_level): Use sizetype for\n+\tconstructor{,_bit,_unfilled}_index.\n+\t(pop_init_label, output_init_element): Likewise.\n+\t(output_pending_init_elements, process_init_element): Likewise.\n+\t* calls.c (compute_argument_block_size): Field VAR is ssizetype.\n+\t* expr.c (store_expr): Use size_int.\n+\t(store_constructor): Use proper types for size_binop args.\n+\t(get_inner_reference, expand_expr, case ARRAY_REF): Likewise.\n+\t(expand_expr_unaligned): Likewise.\n+\t(string_contant): Return object of sizetype.\n+\t* expr.h (SUB_PARM_SIZE): Call size_diffop and pass proper types.\n+\t(ARGS_SIZE_RTX): Call ARGS_SIZE_TREE.\n+\t(ARGS_SIZE_TREE): Pass proper types to size_binop.\n+\t* fold-const.c (int_const_binop): Refine when size_int is called.\n+\t(fold_convert): Likewise.\n+\t(size_int_wide): Rework to take KIND as arg, only take low order\n+\tbits, handle new sizetype_tab datatype, and chain entries in\n+\tsize_table.\n+\t(size_int_type_wide): New function.\n+\t(size_binop): Validate types of arguments.\n+\t(ssize_binop): Deleted.\n+\t(size_diffop): New function.\n+\t(extract_muldiv): Only fold division into multiplication for sizetypes.\n+\t* function.c (assign_parms): Use size_diffop and make sure\n+\tVAR field is of ssizetype; also pass proper type to size_binop.\n+\t(locate_and_pad_parm, pad_to_arg_alignment): Likewise.\n+\t(round_down): Deleted from here.\n+\t* store-layout.c (sizetype_tab): Now an array.\n+\t(sizetype_set, early_root_list): New variables.\n+\t(variable_size): Use size_one_node.\n+\t(round_up): Pass proper type to size_binop.\n+\t(round_down): Moved to here and corrected as above.\n+\t(layout_record): Pass proper arg types to size_binop.\n+\t(layout_type): Likewise.\n+\tIf sizetype_set is zero, record the type just laid out.\n+\t(make_unsigned_type): Don't call set_sizetype;\n+\t(make_signed_type): Likewise; also, call fixup_signed_type.\n+\t(initialize_sizetypes): New function.\n+\t(set_sizetype): Make copy of types, set TYPE_IS_SIZETYPE, and\n+\tset name of bitsizetype to \"bit_size_type\".\n+\tFix up type of sizes of all types made before call.\n+\t* tm.texi (ROUND_TYPE_SIZE_UNIT): New macro.\n+\t* tree.c (fix_sizetype): Deleted.\n+\t(build_common_tree_nodes): Call initialize_sizetypes.\n+\t(build_common_tree_nodes_2): Don't call fix_sizetype.\n+\t* tree.h (TYPE_IS_SIZETYPE): New macro.\n+\t(initialize_sizetype): New declaration.\n+\t(enum size_type_kind): New type.\n+\t(struct sizetype_tab): Deleted.\n+\t(sizetype_tab): Now array; adjust sizetype macros.\n+\t(size_diffop, size_int_type_wide): New functions.\n+\t(size_int_wide): Change number of args and type; access macros changed.\n+\t(ssize_int, sbitsize_int): New macros.\n+\t* config/i960/i960.h (ROUND_TYPE_SIZE): Use size_int.\n+\t(ROUND_TYPE_SIZE_UNIT): New macro.\n+\n 2000-02-27  Zack Weinberg  <zack@wolery.cumb.org>\n \n \t* c-lex.c (putback_buffer): Make 'buffer' an unsigned char *."}, {"sha": "e32d0bddc0b64831601ee24a5b8ec3e944622f9f", "filename": "gcc/builtins.c", "status": "modified", "additions": 38, "deletions": 20, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fed3cef0dbbd17e3d7b8860f42cd8490f0325340/gcc%2Fbuiltins.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fed3cef0dbbd17e3d7b8860f42cd8490f0325340/gcc%2Fbuiltins.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbuiltins.c?ref=fed3cef0dbbd17e3d7b8860f42cd8490f0325340", "patch": "@@ -164,6 +164,8 @@ get_pointer_alignment (exp, max_align)\n    way, because it could contain a zero byte in the middle.\n    TREE_STRING_LENGTH is the size of the character array, not the string.\n \n+   The value returned is of type `ssizetype'.\n+\n    Unfortunately, string_constant can't access the values of const char\n    arrays with initializers, so neither can we do so here.  */\n \n@@ -178,25 +180,29 @@ c_strlen (src)\n   src = string_constant (src, &offset_node);\n   if (src == 0)\n     return 0;\n+\n   max = TREE_STRING_LENGTH (src);\n   ptr = TREE_STRING_POINTER (src);\n+\n   if (offset_node && TREE_CODE (offset_node) != INTEGER_CST)\n     {\n       /* If the string has an internal zero byte (e.g., \"foo\\0bar\"), we can't\n \t compute the offset to the following null if we don't know where to\n \t start searching for it.  */\n       int i;\n+\n       for (i = 0; i < max; i++)\n \tif (ptr[i] == 0)\n \t  return 0;\n+\n       /* We don't know the starting offset, but we do know that the string\n \t has no internal zero bytes.  We can assume that the offset falls\n \t within the bounds of the string; otherwise, the programmer deserves\n \t what he gets.  Subtract the offset from the length of the string,\n-\t and return that.  */\n-      /* This would perhaps not be valid if we were dealing with named\n-         arrays in addition to literal string constants.  */\n-      return size_binop (MINUS_EXPR, size_int (max), offset_node);\n+\t and return that.  This would perhaps not be valid if we were dealing\n+\t with named arrays in addition to literal string constants.  */\n+\n+      return size_diffop (size_int (max), offset_node);\n     }\n \n   /* We have a known offset into the string.  Start searching there for\n@@ -210,25 +216,28 @@ c_strlen (src)\n \treturn 0;\n       offset = TREE_INT_CST_LOW (offset_node);\n     }\n+\n   /* If the offset is known to be out of bounds, warn, and call strlen at\n      runtime.  */\n   if (offset < 0 || offset > max)\n     {\n       warning (\"offset outside bounds of constant string\");\n       return 0;\n     }\n+\n   /* Use strlen to search for the first zero byte.  Since any strings\n      constructed with build_string will have nulls appended, we win even\n      if we get handed something like (char[4])\"abcd\".\n \n      Since OFFSET is our starting index into the string, no further\n      calculation is needed.  */\n-  return size_int (strlen (ptr + offset));\n+  return ssize_int (strlen (ptr + offset));\n }\n \n /* Given TEM, a pointer to a stack frame, follow the dynamic chain COUNT\n    times to get the address of either a higher stack frame, or a return\n    address located within it (depending on FNDECL_CODE).  */\n+\n rtx\n expand_builtin_return_addr (fndecl_code, count, tem)\n      enum built_in_function fndecl_code;\n@@ -1437,6 +1446,7 @@ expand_builtin_memcpy (arglist)\n \n /* Expand expression EXP, which is a call to the strcpy builtin.  Return 0\n    if we failed the caller should emit a normal call.  */\n+\n static rtx\n expand_builtin_strcpy (exp)\n      tree exp;\n@@ -1448,7 +1458,8 @@ expand_builtin_strcpy (exp)\n       /* Arg could be non-pointer if user redeclared this fcn wrong.  */\n       || TREE_CODE (TREE_TYPE (TREE_VALUE (arglist))) != POINTER_TYPE\n       || TREE_CHAIN (arglist) == 0\n-      || TREE_CODE (TREE_TYPE (TREE_VALUE (TREE_CHAIN (arglist)))) != POINTER_TYPE)\n+      || (TREE_CODE (TREE_TYPE (TREE_VALUE (TREE_CHAIN (arglist))))\n+\t  != POINTER_TYPE))\n     return 0;\n   else\n     {\n@@ -1457,18 +1468,20 @@ expand_builtin_strcpy (exp)\n       if (len == 0)\n \treturn 0;\n \n-      len = size_binop (PLUS_EXPR, len, integer_one_node);\n-\n+      len = size_binop (PLUS_EXPR, len, ssize_int (1));\n       chainon (arglist, build_tree_list (NULL_TREE, len));\n     }\n+\n   result = expand_builtin_memcpy (arglist);\n+\n   if (! result)\n     TREE_CHAIN (TREE_CHAIN (arglist)) = 0;\n   return result;\n }\n \n /* Expand expression EXP, which is a call to the memset builtin.  Return 0\n    if we failed the caller should emit a normal call.  */\n+\n static rtx\n expand_builtin_memset (exp)\n      tree exp;\n@@ -1610,6 +1623,7 @@ expand_builtin_memcmp (exp, arglist, target)\n /* Expand expression EXP, which is a call to the strcmp builtin.  Return 0\n    if we failed the caller should emit a normal call, otherwise try to get\n    the result in TARGET, if convenient.  */\n+\n static rtx\n expand_builtin_strcmp (exp, target)\n      tree exp;\n@@ -1625,21 +1639,24 @@ expand_builtin_strcmp (exp, target)\n       /* Arg could be non-pointer if user redeclared this fcn wrong.  */\n       || TREE_CODE (TREE_TYPE (TREE_VALUE (arglist))) != POINTER_TYPE\n       || TREE_CHAIN (arglist) == 0\n-      || TREE_CODE (TREE_TYPE (TREE_VALUE (TREE_CHAIN (arglist)))) != POINTER_TYPE)\n+      || (TREE_CODE (TREE_TYPE (TREE_VALUE (TREE_CHAIN (arglist))))\n+\t  != POINTER_TYPE))\n     return 0;\n-  else if (!HAVE_cmpstrsi)\n+\n+  else if (! HAVE_cmpstrsi)\n     return 0;\n   {\n     tree arg1 = TREE_VALUE (arglist);\n     tree arg2 = TREE_VALUE (TREE_CHAIN (arglist));\n-    tree len, len2;\n+    tree len = c_strlen (arg1);\n+    tree len2 = c_strlen (arg2);\n     rtx result;\n-    len = c_strlen (arg1);\n+\n     if (len)\n-      len = size_binop (PLUS_EXPR, integer_one_node, len);\n-    len2 = c_strlen (arg2);\n+      len = size_binop (PLUS_EXPR, ssize_int (1), len);\n+\n     if (len2)\n-      len2 = size_binop (PLUS_EXPR, integer_one_node, len2);\n+      len2 = size_binop (PLUS_EXPR, ssize_int (1), len2);\n \n     /* If we don't have a constant length for the first, use the length\n        of the second, if we know it.  We don't require a constant for\n@@ -1651,30 +1668,31 @@ expand_builtin_strcmp (exp, target)\n        two fixed strings, or if the code was machine-generated.  We should\n        add some code to the `memcmp' handler below to deal with such\n        situations, someday.  */\n+\n     if (!len || TREE_CODE (len) != INTEGER_CST)\n       {\n \tif (len2)\n \t  len = len2;\n \telse if (len == 0)\n \t  return 0;\n       }\n-    else if (len2 && TREE_CODE (len2) == INTEGER_CST)\n-      {\n-\tif (tree_int_cst_lt (len2, len))\n-\t  len = len2;\n-      }\n+    else if (len2 && TREE_CODE (len2) == INTEGER_CST\n+\t     && tree_int_cst_lt (len2, len))\n+      len = len2;\n \n     chainon (arglist, build_tree_list (NULL_TREE, len));\n     result = expand_builtin_memcmp (exp, arglist, target);\n     if (! result)\n       TREE_CHAIN (TREE_CHAIN (arglist)) = 0;\n+\n     return result;\n   }\n }\n #endif\n \n /* Expand a call to __builtin_saveregs, generating the result in TARGET,\n    if that's convenient.  */\n+\n rtx\n expand_builtin_saveregs ()\n {"}, {"sha": "8308fc7e1716946d13f822ac7cc9c6691f39c789", "filename": "gcc/c-decl.c", "status": "modified", "additions": 13, "deletions": 8, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fed3cef0dbbd17e3d7b8860f42cd8490f0325340/gcc%2Fc-decl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fed3cef0dbbd17e3d7b8860f42cd8490f0325340/gcc%2Fc-decl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-decl.c?ref=fed3cef0dbbd17e3d7b8860f42cd8490f0325340", "patch": "@@ -2887,6 +2887,7 @@ init_decl_processing ()\n   tree ptr_ftype_void, ptr_ftype_ptr;\n   int wchar_type_size;\n   tree array_domain_type;\n+  tree t;\n \n   current_function_decl = NULL;\n   named_labels = NULL;\n@@ -2939,14 +2940,17 @@ init_decl_processing ()\n      Traditionally, use a signed type.\n      Note that stddef.h uses `unsigned long',\n      and this must agree, even if long and int are the same size.  */\n-  set_sizetype\n-    (TREE_TYPE (IDENTIFIER_GLOBAL_VALUE (get_identifier (SIZE_TYPE))));\n-  if (flag_traditional && TREE_UNSIGNED (sizetype))\n-    set_sizetype (signed_type (sizetype));\n+  t = TREE_TYPE (IDENTIFIER_GLOBAL_VALUE (get_identifier (SIZE_TYPE)));\n+  if (flag_traditional && TREE_UNSIGNED (t))\n+    t = signed_type (t);\n+    \n+  set_sizetype (t);\n \n   /* Create the widest literal types. */\n-  widest_integer_literal_type_node = make_signed_type (HOST_BITS_PER_WIDE_INT * 2);\n-  widest_unsigned_literal_type_node = make_unsigned_type (HOST_BITS_PER_WIDE_INT * 2);\n+  widest_integer_literal_type_node\n+    = make_signed_type (HOST_BITS_PER_WIDE_INT * 2);\n+  widest_unsigned_literal_type_node\n+    = make_unsigned_type (HOST_BITS_PER_WIDE_INT * 2);\n   pushdecl (build_decl (TYPE_DECL, NULL_TREE, \n \t\t\twidest_integer_literal_type_node));\n   pushdecl (build_decl (TYPE_DECL, NULL_TREE, \n@@ -3661,13 +3665,14 @@ complete_array_type (type, initial_value, do_default)\n       else if (TREE_CODE (initial_value) == CONSTRUCTOR)\n \t{\n \t  tree elts = CONSTRUCTOR_ELTS (initial_value);\n-\t  maxindex = size_binop (MINUS_EXPR, integer_zero_node, size_one_node);\n+\t  maxindex = build_int_2 (-1, -1);\n \t  for (; elts; elts = TREE_CHAIN (elts))\n \t    {\n \t      if (TREE_PURPOSE (elts))\n \t\tmaxindex = TREE_PURPOSE (elts);\n \t      else\n-\t\tmaxindex = size_binop (PLUS_EXPR, maxindex, size_one_node);\n+\t\tmaxindex = fold (build (PLUS_EXPR, integer_type_node,\n+\t\t\t\t\tmaxindex, integer_one_node));\n \t    }\n \t  maxindex = copy_node (maxindex);\n \t}"}, {"sha": "01446f2b8596c45802380d7fc08c0cfe36c9ef1c", "filename": "gcc/c-typeck.c", "status": "modified", "additions": 68, "deletions": 69, "changes": 137, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fed3cef0dbbd17e3d7b8860f42cd8490f0325340/gcc%2Fc-typeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fed3cef0dbbd17e3d7b8860f42cd8490f0325340/gcc%2Fc-typeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-typeck.c?ref=fed3cef0dbbd17e3d7b8860f42cd8490f0325340", "patch": "@@ -691,58 +691,51 @@ c_sizeof (type)\n      tree type;\n {\n   enum tree_code code = TREE_CODE (type);\n-  tree t;\n \n   if (code == FUNCTION_TYPE)\n     {\n       if (pedantic || warn_pointer_arith)\n \tpedwarn (\"sizeof applied to a function type\");\n-      return size_int (1);\n+      return size_one_node;\n     }\n   if (code == VOID_TYPE)\n     {\n       if (pedantic || warn_pointer_arith)\n \tpedwarn (\"sizeof applied to a void type\");\n-      return size_int (1);\n+      return size_one_node;\n     }\n+\n   if (code == ERROR_MARK)\n-    return size_int (1);\n+    return size_one_node;\n+\n   if (TYPE_SIZE (type) == 0)\n     {\n       error (\"sizeof applied to an incomplete type\");\n-      return size_int (0);\n+      return size_zero_node;\n     }\n \n   /* Convert in case a char is more than one unit.  */\n-  t = size_binop (CEIL_DIV_EXPR, TYPE_SIZE (type), \n-\t\t  size_int (TYPE_PRECISION (char_type_node)));\n-  t = convert (sizetype, t);\n-  /* size_binop does not put the constant in range, so do it now.  */\n-  if (TREE_CODE (t) == INTEGER_CST && force_fit_type (t, 0))\n-    TREE_CONSTANT_OVERFLOW (t) = TREE_OVERFLOW (t) = 1;\n-  return t;\n+  return size_binop (CEIL_DIV_EXPR, TYPE_SIZE_UNIT (type),\n+\t\t     size_int (TYPE_PRECISION (char_type_node)\n+\t\t\t       / BITS_PER_UNIT));\n }\n \n tree\n c_sizeof_nowarn (type)\n      tree type;\n {\n   enum tree_code code = TREE_CODE (type);\n-  tree t;\n \n-  if (code == FUNCTION_TYPE\n-      || code == VOID_TYPE\n-      || code == ERROR_MARK)\n-    return size_int (1);\n+  if (code == FUNCTION_TYPE || code == VOID_TYPE || code == ERROR_MARK)\n+    return size_one_node;\n+\n   if (TYPE_SIZE (type) == 0)\n-    return size_int (0);\n+    return size_zero_node;\n \n   /* Convert in case a char is more than one unit.  */\n-  t = size_binop (CEIL_DIV_EXPR, TYPE_SIZE (type), \n-\t\t  size_int (TYPE_PRECISION (char_type_node)));\n-  t = convert (sizetype, t);\n-  force_fit_type (t, 0);\n-  return t;\n+  return size_binop (CEIL_DIV_EXPR, TYPE_SIZE_UNIT (type),\n+\t\t     size_int (TYPE_PRECISION (char_type_node)\n+\t\t\t       / BITS_PER_UNIT));\n }\n \n /* Compute the size to increment a pointer by.  */\n@@ -752,26 +745,20 @@ c_size_in_bytes (type)\n      tree type;\n {\n   enum tree_code code = TREE_CODE (type);\n-  tree t;\n \n-  if (code == FUNCTION_TYPE)\n-    return size_int (1);\n-  if (code == VOID_TYPE)\n-    return size_int (1);\n-  if (code == ERROR_MARK)\n-    return size_int (1);\n+  if (code == FUNCTION_TYPE || code == VOID_TYPE || code == ERROR_MARK)\n+    return size_one_node;\n+\n   if (TYPE_SIZE (type) == 0)\n     {\n       error (\"arithmetic on pointer to an incomplete type\");\n-      return size_int (1);\n+      return size_one_node;\n     }\n \n   /* Convert in case a char is more than one unit.  */\n-  t = size_binop (CEIL_DIV_EXPR, TYPE_SIZE (type), \n-\t\t     size_int (BITS_PER_UNIT));\n-  t = convert (sizetype, t);\n-  force_fit_type (t, 0);\n-  return t;\n+  return size_binop (CEIL_DIV_EXPR, TYPE_SIZE_UNIT (type),\n+\t\t     size_int (TYPE_PRECISION (char_type_node)\n+\t\t\t       / BITS_PER_UNIT));\n }\n \n /* Implement the __alignof keyword: Return the minimum required\n@@ -787,7 +774,7 @@ c_alignof (type)\n     return size_int (FUNCTION_BOUNDARY / BITS_PER_UNIT);\n \n   if (code == VOID_TYPE || code == ERROR_MARK)\n-    return size_int (1);\n+    return size_one_node;\n \n   return size_int (TYPE_ALIGN (type) / BITS_PER_UNIT);\n }\n@@ -808,7 +795,7 @@ c_alignof_expr (expr)\n       && DECL_C_BIT_FIELD (TREE_OPERAND (expr, 1)))\n     {\n       error (\"`__alignof' applied to a bit-field\");\n-      return size_int (1);\n+      return size_one_node;\n     }\n   else if (TREE_CODE (expr) == COMPONENT_REF\n       && TREE_CODE (TREE_OPERAND (expr, 1)) == FIELD_DECL)\n@@ -3032,8 +3019,9 @@ build_unary_op (code, xarg, noconvert)\n \t      {\n \t\ttree offset\n \t\t  = size_binop (EASY_DIV_EXPR, DECL_FIELD_BITPOS (field),\n-\t\t\t\tsize_int (BITS_PER_UNIT));\n+\t\t\t\tbitsize_int (BITS_PER_UNIT));\n \t\tint flag = TREE_CONSTANT (addr);\n+\n \t\taddr = fold (build (PLUS_EXPR, argtype,\n \t\t\t\t    addr, convert (argtype, offset)));\n \t\tTREE_CONSTANT (addr) = flag;\n@@ -5038,8 +5026,7 @@ really_start_incremental_init (type)\n \t     && DECL_NAME (constructor_fields) == 0)\n \tconstructor_fields = TREE_CHAIN (constructor_fields);\n       constructor_unfilled_fields = constructor_fields;\n-      constructor_bit_index = copy_node (integer_zero_node);\n-      TREE_TYPE (constructor_bit_index) = sbitsizetype;\n+      constructor_bit_index = copy_node (size_zero_node);\n     }\n   else if (TREE_CODE (constructor_type) == ARRAY_TYPE)\n     {\n@@ -5049,10 +5036,13 @@ really_start_incremental_init (type)\n \t  constructor_max_index\n \t    = TYPE_MAX_VALUE (TYPE_DOMAIN (constructor_type));\n \t  constructor_index\n-\t    = copy_node (TYPE_MIN_VALUE (TYPE_DOMAIN (constructor_type)));\n+\t    = copy_node (convert (bitsizetype,\n+\t\t\t\t  TYPE_MIN_VALUE\n+\t\t\t\t  (TYPE_DOMAIN (constructor_type))));\n \t}\n       else\n-\tconstructor_index = copy_node (integer_zero_node);\n+\tconstructor_index = copy_node (bitsize_int (0));\n+\n       constructor_unfilled_index = copy_node (constructor_index);\n     }\n   else\n@@ -5210,8 +5200,7 @@ push_init_level (implicit)\n \t     && DECL_NAME (constructor_fields) == 0)\n \tconstructor_fields = TREE_CHAIN (constructor_fields);\n       constructor_unfilled_fields = constructor_fields;\n-      constructor_bit_index = copy_node (integer_zero_node);\n-      TREE_TYPE (constructor_bit_index) = sbitsizetype;\n+      constructor_bit_index = copy_node (size_zero_node);\n     }\n   else if (TREE_CODE (constructor_type) == ARRAY_TYPE)\n     {\n@@ -5221,10 +5210,13 @@ push_init_level (implicit)\n \t  constructor_max_index\n \t    = TYPE_MAX_VALUE (TYPE_DOMAIN (constructor_type));\n \t  constructor_index\n-\t    = copy_node (TYPE_MIN_VALUE (TYPE_DOMAIN (constructor_type)));\n+\t    = copy_node (convert (bitsizetype, \n+\t\t\t\t  TYPE_MIN_VALUE\n+\t\t\t\t  (TYPE_DOMAIN (constructor_type))));\n \t}\n       else\n-\tconstructor_index = copy_node (integer_zero_node);\n+\tconstructor_index = bitsize_int (0);\n+\n       constructor_unfilled_index = copy_node (constructor_index);\n     }\n   else\n@@ -5401,14 +5393,14 @@ pop_init_level (implicit)\n   else\n     {\n       tree filled;\n+\n       if (TREE_CODE (constructor_type) == RECORD_TYPE\n \t  || TREE_CODE (constructor_type) == UNION_TYPE)\n-\t{\n-\t  /* Find the offset of the end of that field.  */\n-\t  filled = size_binop (CEIL_DIV_EXPR,\n-\t\t\t       constructor_bit_index,\n-\t\t\t       size_int (BITS_PER_UNIT));\n-\t}\n+\t/* Find the offset of the end of that field.  */\n+\tfilled = size_binop (CEIL_DIV_EXPR,\n+\t\t\t     constructor_bit_index,\n+\t\t\t     size_int (BITS_PER_UNIT));\n+\n       else if (TREE_CODE (constructor_type) == ARRAY_TYPE)\n \t{\n \t  /* If initializing an array of unknown size,\n@@ -5417,11 +5409,9 @@ pop_init_level (implicit)\n \t      && TYPE_DOMAIN (constructor_type) == 0)\n \t    {\n \t      tree maxindex\n-\t\t= size_binop (MINUS_EXPR,\n-\t\t\t      constructor_unfilled_index,\n-\t\t\t      integer_one_node);\n+\t\t= copy_node (size_diffop (constructor_unfilled_index,\n+\t\t\t\t\t  bitsize_int (1)));\n \n-\t      maxindex = copy_node (maxindex);\n \t      TYPE_DOMAIN (constructor_type) = build_index_type (maxindex);\n \t      TREE_TYPE (maxindex) = TYPE_DOMAIN (constructor_type);\n \n@@ -5437,8 +5427,11 @@ pop_init_level (implicit)\n \t      size = int_size_in_bytes (constructor_type);\n \t    }\n \n-\t  filled = size_binop (MULT_EXPR, constructor_unfilled_index,\n-\t\t\t       size_in_bytes (TREE_TYPE (constructor_type)));\n+\t  filled\n+\t    = size_binop (MULT_EXPR, constructor_unfilled_index,\n+\t\t\t  convert (bitsizetype,\n+\t\t\t\t   TYPE_SIZE_UNIT\n+\t\t\t\t   (TREE_TYPE (constructor_type))));\n \t}\n       else\n \tfilled = 0;\n@@ -5961,7 +5954,8 @@ output_init_element (value, type, field, pending)\n       if (TREE_CODE (constructor_type) == ARRAY_TYPE)\n \t{\n \t  tree tem = size_binop (PLUS_EXPR, constructor_unfilled_index,\n-\t\t\t\t integer_one_node);\n+\t\t\t\t bitsize_int (1));\n+\n \t  TREE_INT_CST_LOW (constructor_unfilled_index)\n \t    = TREE_INT_CST_LOW (tem);\n \t  TREE_INT_CST_HIGH (constructor_unfilled_index)\n@@ -6117,12 +6111,13 @@ output_pending_init_elements (all)\n   if (constructor_incremental)\n     {\n       tree filled;\n-      tree nextpos_tree = size_int (0);\n+      tree nextpos_tree = bitsize_int (0);\n \n       if (TREE_CODE (constructor_type) == RECORD_TYPE\n \t  || TREE_CODE (constructor_type) == UNION_TYPE)\n \t{\n \t  tree tail;\n+\n \t  /* Find the last field written out, if any.  */\n \t  for (tail = TYPE_FIELDS (constructor_type); tail;\n \t       tail = TREE_CHAIN (tail))\n@@ -6135,13 +6130,13 @@ output_pending_init_elements (all)\n \t\t\t\t size_binop (PLUS_EXPR,\n \t\t\t\t\t     DECL_FIELD_BITPOS (tail),\n \t\t\t\t\t     DECL_SIZE (tail)),\n-\t\t\t\t size_int (BITS_PER_UNIT));\n+\t\t\t\t bitsize_int (BITS_PER_UNIT));\n \t  else\n-\t    filled = size_int (0);\n+\t    filled = bitsize_int (0);\n \n \t  nextpos_tree = size_binop (CEIL_DIV_EXPR,\n \t\t\t\t     DECL_FIELD_BITPOS (next),\n-\t\t\t\t     size_int (BITS_PER_UNIT));\n+\t\t\t\t     bitsize_int (BITS_PER_UNIT));\n \n \t  TREE_INT_CST_HIGH (constructor_bit_index)\n \t    = TREE_INT_CST_HIGH (DECL_FIELD_BITPOS (next));\n@@ -6151,11 +6146,15 @@ output_pending_init_elements (all)\n \t}\n       else if (TREE_CODE (constructor_type) == ARRAY_TYPE)\n \t{\n-\t  filled = size_binop (MULT_EXPR, constructor_unfilled_index,\n-\t\t\t       size_in_bytes (TREE_TYPE (constructor_type)));\n+\t  filled\n+\t    = size_binop (MULT_EXPR, constructor_unfilled_index,\n+\t\t\t  convert (bitsizetype,\n+\t\t\t\t   TYPE_SIZE_UNIT\n+\t\t\t\t   (TREE_TYPE (constructor_type))));\n \t  nextpos_tree\n \t    = size_binop (MULT_EXPR, next,\n-\t\t\t  size_in_bytes (TREE_TYPE (constructor_type)));\n+\t\t\t  convert (bitsizetype, TYPE_SIZE_UNIT\n+\t\t\t\t   (TREE_TYPE (constructor_type))));\n \t  TREE_INT_CST_LOW (constructor_unfilled_index)\n \t    = TREE_INT_CST_LOW (next);\n \t  TREE_INT_CST_HIGH (constructor_unfilled_index)\n@@ -6306,6 +6305,7 @@ process_init_element (value)\n \t      tree temp = size_binop (PLUS_EXPR,\n \t\t\t\t      DECL_FIELD_BITPOS (constructor_fields),\n \t\t\t\t      DECL_SIZE (constructor_fields));\n+\n \t      TREE_INT_CST_LOW (constructor_bit_index)\n \t\t= TREE_INT_CST_LOW (temp);\n \t      TREE_INT_CST_HIGH (constructor_bit_index)\n@@ -6444,8 +6444,7 @@ process_init_element (value)\n \t\t  RESTORE_SPELLING_DEPTH (constructor_depth);\n \t\t}\n \n-\t      tem = size_binop (PLUS_EXPR, constructor_index,\n-\t\t\t\tinteger_one_node);\n+\t      tem = size_binop (PLUS_EXPR, constructor_index, bitsize_int (1));\n \t      TREE_INT_CST_LOW (constructor_index) = TREE_INT_CST_LOW (tem);\n \t      TREE_INT_CST_HIGH (constructor_index) = TREE_INT_CST_HIGH (tem);\n "}, {"sha": "07f4c481de6986231fcb036a3612f63197c89e88", "filename": "gcc/calls.c", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fed3cef0dbbd17e3d7b8860f42cd8490f0325340/gcc%2Fcalls.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fed3cef0dbbd17e3d7b8860f42cd8490f0325340/gcc%2Fcalls.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcalls.c?ref=fed3cef0dbbd17e3d7b8860f42cd8490f0325340", "patch": "@@ -1158,9 +1158,7 @@ initialize_argument_information (num_actuals, args, args_size, n_named_args,\n \n       args[i].slot_offset.constant = -args_size->constant;\n       if (args_size->var)\n-\t{\n-\t  SUB_PARM_SIZE (args[i].slot_offset, args_size->var);\n-\t}\n+\tSUB_PARM_SIZE (args[i].slot_offset, args_size->var);\n #endif\n \n       /* Increment ARGS_SO_FAR, which has info about which arg-registers\n@@ -1205,14 +1203,14 @@ compute_argument_block_size (reg_parm_stack_space, args_size,\n \t{\n \t  args_size->var\n \t    = size_binop (MAX_EXPR, args_size->var,\n-\t\t\t  size_int (reg_parm_stack_space));\n+\t\t\t  ssize_int (reg_parm_stack_space));\n \n #ifndef OUTGOING_REG_PARM_STACK_SPACE\n \t  /* The area corresponding to register parameters is not to count in\n \t     the size of the block we need.  So make the adjustment.  */\n \t  args_size->var\n \t    = size_binop (MINUS_EXPR, args_size->var,\n-\t\t\t  size_int (reg_parm_stack_space));\n+\t\t\t  ssize_int (reg_parm_stack_space));\n #endif\n \t}\n     }"}, {"sha": "35df1bade911a2685745d8eb9988fc3f4b643bcd", "filename": "gcc/ch/ChangeLog", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fed3cef0dbbd17e3d7b8860f42cd8490f0325340/gcc%2Fch%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fed3cef0dbbd17e3d7b8860f42cd8490f0325340/gcc%2Fch%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fch%2FChangeLog?ref=fed3cef0dbbd17e3d7b8860f42cd8490f0325340", "patch": "@@ -1,3 +1,17 @@\n+Sun Feb 27 16:40:33 2000  Richard Kenner  <kenner@vlsi1.ultra.nyu.edu>\n+\n+\t* actions.c (chill_convert_for_assignment): Don't use size_binop\n+\tfor things that aren't sizes.\n+\t(expand_varying_length_assignment): Likewise.\n+\t* convert.c (digest_array_tuple, convert): Likewise.\n+\t* typeck.c (build_chill_slice, smash_dummy_type): Likewise.\n+\t(build_chill_slice_with_range): Likewise.\n+\t(build_chill_slice_with_length): Likewise.\n+\t(build_array_from_set): Adjust types for size_binop.\n+\t* expr.c (build_concat_expr, build_chill_repetition_op): Likewise.\n+\t(build_chill_sizeof): Use TYPE_SIZE_UNIT.\n+\t* tree.c (build_string_type): Pass proper type to size_binop.\n+\n Sat Feb 19 18:43:13 2000  Richard Kenner  <kenner@vlsi1.ultra.nyu.edu>\n \n \t* decl.c (layout_enum): Set DECL_SIZE_UNIT.\t"}, {"sha": "c97c1b6d2bb36be7525cc2a9ca82e4a8568b6b30", "filename": "gcc/ch/actions.c", "status": "modified", "additions": 40, "deletions": 32, "changes": 72, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fed3cef0dbbd17e3d7b8860f42cd8490f0325340/gcc%2Fch%2Factions.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fed3cef0dbbd17e3d7b8860f42cd8490f0325340/gcc%2Fch%2Factions.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fch%2Factions.c?ref=fed3cef0dbbd17e3d7b8860f42cd8490f0325340", "patch": "@@ -1,5 +1,6 @@\n /* Implement actions for CHILL.\n-   Copyright (C) 1992, 93, 94, 98, 99, 2000 Free Software Foundation, Inc.\n+   Copyright (C) 1992, 1993, 1994, 1998, 1999, 2000\n+   Free Software Foundation, Inc.\n    Authors: Per Bothner, Bill Cox, Michael Tiemann, Michael North\n \n This file is part of GNU CC.\n@@ -466,13 +467,12 @@ check_non_null (expr)\n   return expr;\n }\n \f\n-/*\n- * There are four conditions to generate a runtime check:\n- *    1) assigning a longer INT to a shorter (signs irrelevant)\n- *    2) assigning a signed to an unsigned\n- *    3) assigning an unsigned to a signed of the same size.\n- *    4) TYPE is a discrete subrange\n- */\n+/*  There are four conditions to generate a runtime check:\n+    1) assigning a longer INT to a shorter (signs irrelevant)\n+    2) assigning a signed to an unsigned\n+    3) assigning an unsigned to a signed of the same size.\n+    4) TYPE is a discrete subrange  */\n+\n tree\n chill_convert_for_assignment (type, expr, place)\n      tree type, expr;\n@@ -558,17 +558,18 @@ chill_convert_for_assignment (type, expr, place)\n     }\n   result = convert (type, expr);\n \n-  /* If the type is a array of PACK bits and the expression is an array constructor,\n-     then build a CONSTRUCTOR for a bitstring.  Bitstrings are zero based, so\n-     decrement the value of each CONSTRUCTOR element by the amount of the lower\n-     bound of the array.  */\n+  /* If the type is a array of PACK bits and the expression is an array\n+     constructor, then build a CONSTRUCTOR for a bitstring.  Bitstrings are\n+     zero based, so decrement the value of each CONSTRUCTOR element by the\n+     amount of the lower bound of the array.  */\n   if (TREE_CODE (type) == ARRAY_TYPE && TYPE_PACKED (type)\n       && TREE_CODE (result) == CONSTRUCTOR)\n     {\n       tree domain_min = TYPE_MIN_VALUE (TYPE_DOMAIN (type));\n       tree new_list = NULL_TREE;\n       long index;\n       tree element;\n+\n       for (element = TREE_OPERAND (result, 1);\n \t   element != NULL_TREE;\n \t   element = TREE_CHAIN (element))\n@@ -579,18 +580,21 @@ chill_convert_for_assignment (type, expr, place)\n \t      switch (TREE_CODE (purpose))\n \t\t{\n \t\tcase INTEGER_CST:\n-\t\t  new_list = tree_cons (NULL_TREE,\n-\t\t\t\t\tsize_binop (MINUS_EXPR, purpose, domain_min),\n-\t\t\t\t\tnew_list);\n+\t\t  new_list\n+\t\t    = tree_cons (NULL_TREE,\n+\t\t\t\t fold (build (MINUS_EXPR, TREE_TYPE (purpose),\n+\t\t\t\t\t      purpose, domain_min)),\n+\t\t\t\t new_list);\n \t\t  break;\n \t\tcase RANGE_EXPR:\n \t\t  for (index  = TREE_INT_CST_LOW (TREE_OPERAND (purpose, 0));\n \t\t       index <= TREE_INT_CST_LOW (TREE_OPERAND (purpose, 1));\n \t\t       index++)\n \t\t    new_list = tree_cons (NULL_TREE,\n-\t\t\t\t\t  size_binop (MINUS_EXPR,\n-\t\t\t\t\t\t      build_int_2 (index, 0),\n-\t\t\t\t\t\t      domain_min),\n+\t\t\t\t\t  fold (build (MINUS_EXPR,\n+\t\t\t\t\t\t       integer_type_node,\n+\t\t\t\t\t\t       build_int_2 (index, 0),\n+\t\t\t\t\t\t       domain_min)),\n \t\t\t\t\t  new_list);\n \t\t  break;\n \t\tdefault:\n@@ -1697,11 +1701,12 @@ chill_expand_assignment (lhs, modifycode, rhs)\n       tree from_pos = save_expr (TREE_OPERAND (lhs, 0));\n       tree set = TREE_OPERAND (lhs, 1);\n       tree domain = TYPE_DOMAIN (TREE_TYPE (set));\n-      tree set_length = size_binop (PLUS_EXPR,\n-\t\t\t\t    size_binop (MINUS_EXPR,\n-\t\t\t\t\t\tTYPE_MAX_VALUE (domain),\n-\t\t\t\t\t\tTYPE_MIN_VALUE (domain)),\n-\t\t\t\t    integer_one_node);\n+      tree set_length\n+\t= fold (build (PLUS_EXPR, integer_type_node,\n+\t\t       fold (build (MINUS_EXPR, integer_type_node,\n+\t\t\t\t    TYPE_MAX_VALUE (domain),\n+\t\t\t\t    TYPE_MIN_VALUE (domain))),\n+\t\t       integer_one_node));\n       tree filename = force_addr_of (get_chill_filename());\n       \n       if (TREE_CODE (TREE_TYPE (lhs)) != BOOLEAN_TYPE)\n@@ -1750,19 +1755,22 @@ chill_expand_assignment (lhs, modifycode, rhs)\n       tree numbits = TREE_OPERAND (lhs, 1);\n       tree from_pos = save_expr (TREE_OPERAND (lhs, 2));\n       tree domain = TYPE_DOMAIN (TREE_TYPE (set));\n-      tree set_length = size_binop (PLUS_EXPR,\n-\t\t\t\t    size_binop (MINUS_EXPR,\n-\t\t\t\t\t\tTYPE_MAX_VALUE (domain),\n-\t\t\t\t\t\tTYPE_MIN_VALUE (domain)),\n-\t\t\t\t    integer_one_node);\n+      tree set_length\n+\t= fold (build (PLUS_EXPR, integer_type_node,\n+\t\t       fold (build (MINUS_EXPR, integer_type_node,\n+\t\t\t\t    TYPE_MAX_VALUE (domain),\n+\t\t\t\t    TYPE_MIN_VALUE (domain))),\n+\t\t       integer_one_node));\n       tree filename = force_addr_of (get_chill_filename());\n       tree to_pos;\n+\n       switch (TREE_CODE (TREE_TYPE (rhs)))\n \t{\n \tcase SET_TYPE:\n-\t  to_pos = size_binop (MINUS_EXPR,\n-\t\t\t       size_binop (PLUS_EXPR, from_pos, numbits),\n-\t\t\t       integer_one_node);\n+\t  to_pos = fold (build (MINUS_EXPR, integer_type_node,\n+\t\t\t\tfold (build (PLUS_EXPR, integer_type_node,\n+\t\t\t\t\t     from_pos, numbits)),\n+\t\t\t\tinteger_one_node));\n \t  break;\n \tcase BOOLEAN_TYPE:\n \t  to_pos = from_pos;\n@@ -1812,7 +1820,7 @@ expand_varying_length_assignment (lhs, rhs)\n   min_domain_val = TYPE_MIN_VALUE (TYPE_DOMAIN (base_array));\n \n   lhs = build_component_ref (lhs, var_length_id);\n-  rhs = size_binop (MINUS_EXPR, rhs, min_domain_val);\n+  rhs = fold (build (MINUS_EXPR, TREE_TYPE (rhs), rhs, min_domain_val));\n \n   expand_expr_stmt (build_chill_modify_expr (lhs, rhs));\n }"}, {"sha": "dcea057f500a48d61c1693b6cec64f4a9961627f", "filename": "gcc/ch/convert.c", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fed3cef0dbbd17e3d7b8860f42cd8490f0325340/gcc%2Fch%2Fconvert.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fed3cef0dbbd17e3d7b8860f42cd8490f0325340/gcc%2Fch%2Fconvert.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fch%2Fconvert.c?ref=fed3cef0dbbd17e3d7b8860f42cd8490f0325340", "patch": "@@ -1,5 +1,6 @@\n /* Language-level data type conversion for GNU CHILL.\n-   Copyright (C) 1992, 93, 94, 98, 99, 2000 Free Software Foundation, Inc.\n+   Copyright (C) 1992, 1993, 1994, 1998, 1999, 2000\n+   Free Software Foundation, Inc.\n \n This file is part of GNU CC.\n \n@@ -858,14 +859,12 @@ digest_array_tuple (type, init, allow_missing_elements)\n \t    }\n \t  /* Calculate the last element of the gap. */\n \t  if (*ptr)\n-\t    {\n-\t      /* Actually end up with correct type. */\n-\t      last = size_binop (MINUS_EXPR,\n-\t\t\t\t CONSTRUCTOR_ELT_LO (*ptr),\n-\t\t\t\t integer_one_node);\n-\t    }\n+\t    last = fold (build (MINUS_EXPR, integer_type_node,\n+\t\t\t\tCONSTRUCTOR_ELT_LO (*ptr),\n+\t\t\t\tinteger_one_node));\n \t  else\n \t    last = domain_max;\n+\n \t  if (TREE_CODE (last) == INTEGER_CST && tree_int_cst_lt (last, first))\n \t    ; /* Empty \"gap\" - no missing elements. */\n \t  else if (default_value)\n@@ -1058,16 +1057,17 @@ convert (type, expr)\n \t{\n \t  /* Note that array_type_nelts returns 1 less than the size. */\n \t  nentries = array_type_nelts (TREE_TYPE (e));\n-\t  needed_padding = size_binop (MINUS_EXPR,\n-\t\t\t\t       array_type_nelts (target_array_type),\n-\t\t\t\t       nentries);\n+\t  needed_padding = fold (build (MINUS_EXPR, integer_type_node,\n+\t\t\t\t\tarray_type_nelts (target_array_type),\n+\t\t\t\t\tnentries));\n \t  if (TREE_CODE (needed_padding) != INTEGER_CST)\n \t    {\n \t      padding_max_size = size_in_bytes (TREE_TYPE (e));\n \t      if (TREE_CODE (padding_max_size) != INTEGER_CST)\n \t\tpadding_max_size = TYPE_ARRAY_MAX_SIZE (TREE_TYPE (e));\n \t    }\n-\t  nentries = size_binop (PLUS_EXPR, nentries, integer_one_node);\n+\t  nentries = fold (build (PLUS_EXPR, integer_type_node,\n+\t\t\t\t  nentries, integer_one_node));\n \t}\n       else if (TREE_CODE (e) == CONSTRUCTOR)\n \t{"}, {"sha": "b4bdf35aec7ba18f420cabfe42db0bcf3e685d3c", "filename": "gcc/ch/expr.c", "status": "modified", "additions": 13, "deletions": 10, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fed3cef0dbbd17e3d7b8860f42cd8490f0325340/gcc%2Fch%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fed3cef0dbbd17e3d7b8860f42cd8490f0325340/gcc%2Fch%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fch%2Fexpr.c?ref=fed3cef0dbbd17e3d7b8860f42cd8490f0325340", "patch": "@@ -1,6 +1,7 @@\n /* Convert language-specific tree expression to rtl instructions,\n    for GNU CHILL compiler.\n-   Copyright (C) 1992, 93, 94, 98, 99, 2000 Free Software Foundation, Inc.\n+   Copyright (C) 1992, 1993, 1994, 1998, 1999, 2000\n+   Free Software Foundation, Inc.\n \n This file is part of GNU CC.\n \n@@ -2264,8 +2265,9 @@ build_chill_sizeof (type)\n \t  return error_mark_node;\n \t}\n       \n-      temp = size_binop (CEIL_DIV_EXPR, TYPE_SIZE (type),\n-\t\t\t size_int (TYPE_PRECISION (char_type_node)));\n+      temp = size_binop (CEIL_DIV_EXPR, TYPE_SIZE_UNIT (type),\n+\t\t\t size_int (TYPE_PRECISION (char_type_node)\n+\t\t\t\t   / BITS_PER_UNIT));\n       if (signame != NULL_TREE)\n         {\n           /* we have a signal definition. This signal may have no\n@@ -3344,9 +3346,9 @@ build_concat_expr (op0, op1)\n \n       if (TREE_CODE (type0) == SET_TYPE)\n \t{\n-\t  result_size = size_binop (PLUS_EXPR,\n-\t\t\t\t    discrete_count (TYPE_DOMAIN (type0)),\n-\t\t\t\t    discrete_count (TYPE_DOMAIN (type1)));\n+\t  result_size = fold (build (PLUS_EXPR, integer_type_node,\n+\t\t\t\t     discrete_count (TYPE_DOMAIN (type0)),\n+\t\t\t\t     discrete_count (TYPE_DOMAIN (type1))));\n \t  result_class.mode = build_bitstring_type (result_size);\n \t}\n       else\n@@ -4250,15 +4252,16 @@ build_chill_repetition_op (count_op, string)\n \t    for (temp = vallist; temp; temp = TREE_CHAIN (temp))\n \t      {\n \t\ttree new_value\n-\t\t  = fold (size_binop (PLUS_EXPR, origin, TREE_VALUE (temp)));\n+\t\t  = fold (build (PLUS_EXPR, TREE_TYPE (origin),\n+\t\t\t\t TREE_VALUE (temp)));\n \t\ttree new_purpose = NULL_TREE;\n+\n \t\tif (! TREE_CONSTANT (TREE_VALUE (temp)))\n \t\t  tree_const = 0;\n \t\tif (TREE_PURPOSE (temp))\n \t\t  {\n-\t\t    new_purpose = fold (size_binop (PLUS_EXPR,\n-\t\t\t\t\t\t    origin,\n-\t\t\t\t\t\t    TREE_PURPOSE (temp)));\n+\t\t    new_purpose = fold (build (PLUS_EXPR, TREE_TYPE (origin),\n+\t\t\t\t\t       origin, TREE_PURPOSE (temp)));\n \t\t    if (! TREE_CONSTANT (TREE_PURPOSE (temp)))\n \t\t      tree_const = 0;\n \t\t  }"}, {"sha": "53485dbc2eb5f36b9a02ce94fed77f06e190974a", "filename": "gcc/ch/tree.c", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fed3cef0dbbd17e3d7b8860f42cd8490f0325340/gcc%2Fch%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fed3cef0dbbd17e3d7b8860f42cd8490f0325340/gcc%2Fch%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fch%2Ftree.c?ref=fed3cef0dbbd17e3d7b8860f42cd8490f0325340", "patch": "@@ -1,5 +1,6 @@\n /* Language-dependent node constructors for parse phase of GNU compiler.\n-   Copyright (C) 1992, 93, 94, 98, 99, 2000  Free Software Foundation, Inc.\n+   Copyright (C) 1992, 1993, 1994, 1998, 1999, 2000\n+   Free Software Foundation, Inc.\n \n This file is part of GNU CC.\n \n@@ -65,9 +66,9 @@ build_string_type (elt_type, length)\n   /* Subtract 1 from length to get max index value.\n      Note we cannot use size_binop for pass 1 expressions. */\n   if (TREE_CODE (length) == INTEGER_CST || pass != 1)\n-    length = size_binop (MINUS_EXPR, length, integer_one_node);\n+    length = size_binop (MINUS_EXPR, length, size_one_node);\n   else\n-    length = build (MINUS_EXPR, sizetype, length, integer_one_node);\n+    length = build (MINUS_EXPR, sizetype, length, size_one_node);\n \n   t = make_node (elt_type == boolean_type_node ? SET_TYPE : ARRAY_TYPE);\n   TREE_TYPE (t) = elt_type;\n@@ -289,7 +290,9 @@ discrete_count (t)\n      tree t;\n {\n   tree hi = convert (sizetype, TYPE_MAX_VALUE (t));\n+\n   if (TYPE_MIN_VALUE (t))\n     hi = size_binop (MINUS_EXPR, hi, convert (sizetype, TYPE_MIN_VALUE (t)));\n+\n   return size_binop (PLUS_EXPR, hi, integer_one_node);\n }"}, {"sha": "8c74896b52af5830831024f61bf54c0d941d00a6", "filename": "gcc/ch/typeck.c", "status": "modified", "additions": 29, "deletions": 25, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fed3cef0dbbd17e3d7b8860f42cd8490f0325340/gcc%2Fch%2Ftypeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fed3cef0dbbd17e3d7b8860f42cd8490f0325340/gcc%2Fch%2Ftypeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fch%2Ftypeck.c?ref=fed3cef0dbbd17e3d7b8860f42cd8490f0325340", "patch": "@@ -1,5 +1,6 @@\n /* Build expressions with type checking for CHILL compiler.\n-   Copyright (C) 1992, 93, 94, 98, 99, 2000 Free Software Foundation, Inc.\n+   Copyright (C) 1992, 1993, 1994, 1998, 1999, 2000\n+   Free Software Foundation, Inc.\n \n This file is part of GNU CC.\n \n@@ -215,17 +216,17 @@ build_chill_slice (array, min_value, length)\n      \n      The static allocation info is passed by using the parent array's\n      limits to compute a temp_size, which is passed in the lang_specific\n-     field of the slice_type.\n-   */\n+     field of the slice_type. */\n      \n   if (TREE_CODE (array_type) == ARRAY_TYPE)\n     {\n       tree domain_type = TYPE_DOMAIN (array_type);\n       tree domain_min = TYPE_MIN_VALUE (domain_type);\n-      tree domain_max = fold (build (PLUS_EXPR, domain_type,\n-\t\t\t\t     domain_min,\n-\t\t\t\t     size_binop (MINUS_EXPR,\n-\t\t\t\t\t\t length, integer_one_node)));\n+      tree domain_max\n+\t= fold (build (PLUS_EXPR, domain_type,\n+\t\t       domain_min,\n+\t\t       fold (build (MINUS_EXPR, integer_type_node,\n+\t\t\t\t    length, integer_one_node))));\n       tree index_type = build_chill_range_type (TYPE_DOMAIN (array_type),\n \t\t\t\t\t\tdomain_min,\n \t\t\t\t\t\tdomain_max);\n@@ -408,13 +409,15 @@ build_chill_slice_with_range (array, min_value, max_value)\n       && tree_int_cst_lt (max_value, min_value))\n     return build_empty_string (TREE_TYPE (TREE_TYPE (array)));\n \n-  return build_chill_slice (array, min_value,\n-\t     save_expr (size_binop (PLUS_EXPR,\n-\t       size_binop (MINUS_EXPR, max_value, min_value),\n-\t\t\t\t    integer_one_node)));\n+  return\n+    build_chill_slice\n+      (array, min_value,\n+       save_expr (fold (build (PLUS_EXPR, integer_type_node,\n+\t\t\t       fold (build (MINUS_EXPR, integer_type_node,\n+\t\t\t\t\t    max_value, min_value)),\n+\t\t\t       integer_one_node))));\n }\n \n-\n tree\n build_chill_slice_with_length (array, min_value, length)\n      tree array, min_value, length;\n@@ -450,9 +453,10 @@ build_chill_slice_with_length (array, min_value, length)\n       length = integer_one_node;\n     }\n \n-  max_index = size_binop (MINUS_EXPR, \n-\t        size_binop (PLUS_EXPR, length, min_value),\n-\t\t\t  integer_one_node);\n+  max_index = fold (build (MINUS_EXPR, integer_type_node,\n+\t\t\t   fold (build (PLUS_EXPR, integer_type_node,\n+\t\t\t\t\tlength, min_value)),\n+\t\t\t   integer_one_node));\n   max_index = convert_to_class (chill_expr_class (min_value), max_index);\n \n   min_value = valid_array_index_p (array, min_value,\n@@ -1208,22 +1212,22 @@ build_chill_cast (type, expr)\n   return expr;\n }\n \f\n-/*\n- * given a set_type, build an integer array from it that C will grok.\n- */\n+/* Given a set_type, build an integer array from it that C will grok. */\n+\n tree\n build_array_from_set (type)\n      tree type;\n {\n   tree bytespint, bit_array_size, int_array_count;\n  \n-  if (type == NULL_TREE || type == error_mark_node || TREE_CODE (type) != SET_TYPE)\n+  if (type == NULL_TREE || type == error_mark_node\n+      || TREE_CODE (type) != SET_TYPE)\n     return error_mark_node;\n \n-  bytespint = build_int_2 (HOST_BITS_PER_INT / HOST_BITS_PER_CHAR, 0);\n+  /* ??? Should this really be *HOST*??  */\n+  bytespint = size_int (HOST_BITS_PER_INT / HOST_BITS_PER_CHAR);\n   bit_array_size = size_in_bytes (type);\n-  int_array_count = fold (size_binop (TRUNC_DIV_EXPR, bit_array_size,\n-\t\t\t\t\t\t bytespint));\n+  int_array_count = size_binop (TRUNC_DIV_EXPR, bit_array_size, bytespint);\n   if (integer_zerop (int_array_count))\n     int_array_count = size_one_node;\n   type = build_array_type (integer_type_node, \n@@ -3371,9 +3375,9 @@ smash_dummy_type (type)\n \t    {\n \t      tree oldindex = TYPE_DOMAIN (origin);\n \t      new_max = check_range (new_max, new_max, NULL_TREE,\n-\t\t\t\t     size_binop (PLUS_EXPR,\n-\t\t\t\t\t\t TYPE_MAX_VALUE (oldindex),\n-\t\t\t\t\t\t integer_one_node));\n+\t\t\t\t     fold (build (PLUS_EXPR, integer_type_node,\n+\t\t\t\t\t\t  TYPE_MAX_VALUE (oldindex),\n+\t\t\t\t\t\t  integer_one_node)));\n \t      origin = build_string_type (TREE_TYPE (origin), new_max);\n \t    }\n \t  else if (TREE_CODE (origin) == ARRAY_TYPE)"}, {"sha": "8ccd758eb20e78ec20e67455fade99866f53ace0", "filename": "gcc/config/i960/i960.h", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fed3cef0dbbd17e3d7b8860f42cd8490f0325340/gcc%2Fconfig%2Fi960%2Fi960.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fed3cef0dbbd17e3d7b8860f42cd8490f0325340/gcc%2Fconfig%2Fi960%2Fi960.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi960%2Fi960.h?ref=fed3cef0dbbd17e3d7b8860f42cd8490f0325340", "patch": "@@ -493,7 +493,11 @@ extern int target_flags;\n \n #define ROUND_TYPE_SIZE(TYPE, COMPUTED, SPECIFIED)\t\t\\\n   ((TREE_CODE (TYPE) == REAL_TYPE && TYPE_MODE (TYPE) == XFmode)\t\\\n-   ? build_int_2 (128, 0) : round_up (COMPUTED, SPECIFIED))\n+   ? bitsize_int (128) : round_up (COMPUTED, SPECIFIED))\n+#define ROUND_TYPE_SIZE_UNIT(TYPE, COMPUTED, SPECIFIED)\t\t\\\n+  ((TREE_CODE (TYPE) == REAL_TYPE && TYPE_MODE (TYPE) == XFmode)\t\\\n+   ? bitsize_int (16) : round_up (COMPUTED, SPECIFIED))\n+\n \f\n /* Standard register usage.  */\n "}, {"sha": "14ba1192b98a760fb4b386a5c044eaddf90ac0eb", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fed3cef0dbbd17e3d7b8860f42cd8490f0325340/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fed3cef0dbbd17e3d7b8860f42cd8490f0325340/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=fed3cef0dbbd17e3d7b8860f42cd8490f0325340", "patch": "@@ -1,3 +1,40 @@\n+Sun Feb 27 16:40:33 2000  Richard Kenner  <kenner@vlsi1.ultra.nyu.edu>\n+\n+\t* class.c (dfs_build_vtable_offset_vtbl_entries): Don't use size_binop\n+\ton things that are not sizes; ssize_binop deleted.\n+\tCall size_diffop when appropriate.\n+\t(dfs_build_vcall_offset_vtbl_entries): Likewise.\n+\t(build_primary_vtable, build_secondary_vtable): Likewise.\n+\t(dfs_set_offset_for_unshared_vbases, dfs_modify_vtables): Likewise.\n+\tVariable I is HOST_WIDE_INT.\n+\t(get_vfield_offset): Pass proper types to size_binop.\n+\t(size_extra_vtbl_entries, layout_virtual_bases): Likewise.\n+\t(finish_struct_1): Likewise.\n+\t(skip_rtti_stuff): Arg N is now pointer to signed.\n+\t(layout_class_type): Use size_zero_node.\n+\t* cp-tree.h (skip_rtti_stuff): Arg N is pointer to signed.\n+\t* cvt.c (cp_convert_to_pointer): Pass proper types to size_binop.\n+\t* decl.c (complete_arry_type): Pass proper types to size_binop.\n+\t(xref_basetypes): BINFO_OFFSET is sizetype.\n+\t* error.c (dump_expr): Don't use size_binop non-sizes.\n+\t* expr.c (cplus_expand_constant): Pass proper types to size_binop.\n+\t* init.c (construct_virtual_bases): Fix type error.\n+\t(build_vec_delete_1): Pass proper type to size_binop and don't\n+\tfold result.\n+\t* lex.c (cp_make_lang_type): BINFO_OFFSET is sizetype.\n+\t* rtti.c (get_base_offset): Pass proper type to size_binop.\n+\t* search.c (dfs_find_vbases): Fix type error.\n+\t(expand_upcast_fixups): Arg to skip_rtti_stuff is pointer to signed.\n+\t(dfs_get_vbase_types): BINFO_OFFSET is sizetype.\n+\t* tree.c (debug_binfo): Variable N is signed.\n+\tUse HOST_WIDE_INT_PRINT_DEC.\n+\t* typeck.c (comptypes): sizetype is same as equivalent integer type.\n+\t(c_sizeof, c_sizeof_nowarn, expr_sizeof): Use TYPE_SIZE_UNIT,\n+\tsize_one_node and size_zero_node.\n+\t(c_alignof): Use size_one_node.\n+\t(build_component_addr): Pass proper types to size_binop.\n+\t(expand_ptrmemfunc_cst): Don't use size_binop on non-sizes.\n+\n 2000-02-26  Jason Merrill  <jason@casey.cygnus.com>\n \n \tImplement class scope using-declarations for functions."}, {"sha": "5b0ab16ac64283798d7addb7c463bdb6c364d05e", "filename": "gcc/cp/class.c", "status": "modified", "additions": 48, "deletions": 65, "changes": 113, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fed3cef0dbbd17e3d7b8860f42cd8490f0325340/gcc%2Fcp%2Fclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fed3cef0dbbd17e3d7b8860f42cd8490f0325340/gcc%2Fcp%2Fclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fclass.c?ref=fed3cef0dbbd17e3d7b8860f42cd8490f0325340", "patch": "@@ -274,17 +274,16 @@ dfs_build_vbase_offset_vtbl_entries (binfo, data)\n       else\n \t{\n \t  BINFO_VPTR_FIELD (vbase) = TREE_PURPOSE (TREE_VALUE (list));\n-\t  BINFO_VPTR_FIELD (vbase) = ssize_binop (MINUS_EXPR,\n-\t\t\t\t\t\t  BINFO_VPTR_FIELD (vbase),\n-\t\t\t\t\t\t  integer_one_node);\n+\t  BINFO_VPTR_FIELD (vbase)\n+\t    = fold (build (MINUS_EXPR, integer_type_node,\n+\t\t\t   BINFO_VPTR_FIELD (vbase), integer_one_node));\n \t}\n \n       /* And record the offset at which this virtual base lies in the\n \t vtable.  */\n       init = BINFO_OFFSET (binfo);\n       TREE_VALUE (list) = tree_cons (BINFO_VPTR_FIELD (vbase),\n-\t\t\t\t     init, \n-\t\t\t\t     TREE_VALUE (list));\n+\t\t\t\t     init, TREE_VALUE (list));\n     }\n \n   SET_BINFO_VTABLE_PATH_MARKED (binfo);\n@@ -338,17 +337,14 @@ build_vbase_offset_vtbl_entries (binfo, t)\n      object, and we need offsets from this BINFO.  */\n   for (init = inits; init; init = TREE_CHAIN (init))\n     {\n-      tree exp = TREE_VALUE (init);\n-\n-      exp = ssize_binop (MINUS_EXPR, exp, BINFO_OFFSET (binfo));\n-      exp = build1 (NOP_EXPR, vtable_entry_type, exp);\n-      exp = fold (exp);\n-      TREE_CONSTANT (exp) = 1;\n       /* The dfs_build_vbase_offset_vtbl_entries routine uses the\n \t TREE_PURPOSE to scribble in.  But, we need to clear it now so\n \t that the values are not perceived as labeled initializers.  */\n       TREE_PURPOSE (init) = NULL_TREE;\n-      TREE_VALUE (init) = exp;\n+      TREE_VALUE (init)\n+\t= fold (build1 (NOP_EXPR, vtable_entry_type,\n+\t\t\tsize_diffop (TREE_VALUE (init),\n+\t\t\t\t     BINFO_OFFSET (binfo))));\n     }\n \n   return inits;\n@@ -406,25 +402,19 @@ dfs_build_vcall_offset_vtbl_entries (binfo, data)\n        virtuals;\n        virtuals = TREE_CHAIN (virtuals))\n     {\n-      tree fn;\n-      tree base;\n-      tree base_binfo;\n-      tree offset;\n-\n       /* Figure out what function we're looking at.  */\n-      fn = TREE_VALUE (virtuals);\n-      base = DECL_CONTEXT (fn);\n-\n+      tree fn = TREE_VALUE (virtuals);\n+      tree base = DECL_CONTEXT (fn);\n       /* The FN comes from BASE.  So, we must caculate the adjustment\n \t from the virtual base that derived from BINFO to BASE.  */\n-      base_binfo = get_binfo (base, vod->derived, /*protect=*/0);\n-      offset = ssize_binop (MINUS_EXPR,\n-\t\t\t    BINFO_OFFSET (base_binfo),\n-\t\t\t    BINFO_OFFSET (vod->vbase));\n-      offset = build1 (NOP_EXPR, vtable_entry_type, offset);\n-      offset = fold (offset);\n-      TREE_CONSTANT (offset) = 1;\n-      binfo_inits = tree_cons (NULL_TREE, offset, binfo_inits);\n+      tree base_binfo = get_binfo (base, vod->derived, /*protect=*/0);\n+\n+      binfo_inits\n+\t= tree_cons (NULL_TREE,\n+\t\t     fold (build1 (NOP_EXPR, vtable_entry_type,\n+\t\t\t\t   size_diffop (BINFO_OFFSET (base_binfo),\n+\t\t\t\t\t\tBINFO_OFFSET (vod->vbase)))),\n+\t\t     binfo_inits);\n     }\n \n   /* Now add the initializers we've just created to the list that will\n@@ -634,11 +624,10 @@ build_vbase_path (code, type, expr, path, nonnull)\n   if (changed)\n     {\n       tree intype = TREE_TYPE (TREE_TYPE (expr));\n+\n       if (TYPE_MAIN_VARIANT (intype) != BINFO_TYPE (last))\n-\t{\n-\t  tree binfo = get_binfo (last, TYPE_MAIN_VARIANT (intype), 0);\n-\t  offset = BINFO_OFFSET (binfo);\n-\t}\n+\toffset\n+\t  = BINFO_OFFSET (get_binfo (last, TYPE_MAIN_VARIANT (intype), 0));\n     }\n   else\n     offset = BINFO_OFFSET (last);\n@@ -647,10 +636,6 @@ build_vbase_path (code, type, expr, path, nonnull)\n     {\n       /* Bash types to make the backend happy.  */\n       offset = cp_convert (type, offset);\n-#if 0\n-      /* This shouldn't be necessary.  (mrs) */\n-      expr = build1 (NOP_EXPR, type, expr);\n-#endif\n \n       /* If expr might be 0, we need to preserve that zeroness.  */\n       if (nonnull == 0)\n@@ -921,16 +906,18 @@ get_vfield_offset (binfo)\n   tree tmp\n     = size_binop (FLOOR_DIV_EXPR,\n \t\t  DECL_FIELD_BITPOS (TYPE_VFIELD (BINFO_TYPE (binfo))),\n-\t\t  size_int (BITS_PER_UNIT));\n-  tmp = convert (sizetype, tmp);\n-  return size_binop (PLUS_EXPR, tmp, BINFO_OFFSET (binfo));\n+\t\t  bitsize_int (BITS_PER_UNIT));\n+\n+  return size_binop (PLUS_EXPR, convert (sizetype, tmp),\n+\t\t     BINFO_OFFSET (binfo));\n }\n \n /* Get the offset to the start of the original binfo that we derived\n    this binfo from.  If we find TYPE first, return the offset only\n    that far.  The shortened search is useful because the this pointer\n    on method calling is expected to point to a DECL_CONTEXT (fndecl)\n-   object, and not a baseclass of it.  */\n+   object, and not a baseclass of it.   */\n+\n \n static tree\n get_derived_offset (binfo, type)\n@@ -939,14 +926,16 @@ get_derived_offset (binfo, type)\n   tree offset1 = get_vfield_offset (TYPE_BINFO (BINFO_TYPE (binfo)));\n   tree offset2;\n   int i;\n+\n   while (BINFO_BASETYPES (binfo)\n-\t && (i=CLASSTYPE_VFIELD_PARENT (BINFO_TYPE (binfo))) != -1)\n+\t && (i = CLASSTYPE_VFIELD_PARENT (BINFO_TYPE (binfo))) != -1)\n     {\n       tree binfos = BINFO_BASETYPES (binfo);\n       if (BINFO_TYPE (binfo) == type)\n \tbreak;\n       binfo = TREE_VEC_ELT (binfos, i);\n     }\n+\n   offset2 = get_vfield_offset (TYPE_BINFO (BINFO_TYPE (binfo)));\n   return size_binop (MINUS_EXPR, offset1, offset2);\n }\n@@ -1085,7 +1074,7 @@ build_primary_vtable (binfo, type)\n \n       /* Now do rtti stuff.  */\n       offset = get_derived_offset (TYPE_BINFO (type), NULL_TREE);\n-      offset = ssize_binop (MINUS_EXPR, integer_zero_node, offset);\n+      offset = size_diffop (size_zero_node, offset);\n       set_rtti_entry (virtuals, offset, type);\n     }\n   else\n@@ -1175,7 +1164,7 @@ build_secondary_vtable (binfo, for_type)\n     offset = BINFO_OFFSET (binfo);\n \n   set_rtti_entry (BINFO_VIRTUALS (binfo),\n-\t\t  ssize_binop (MINUS_EXPR, integer_zero_node, offset),\n+\t\t  size_diffop (size_zero_node, offset),\n \t\t  for_type);\n \n   /* In the new ABI, secondary vtables are laid out as part of the\n@@ -2620,12 +2609,8 @@ tree\n size_extra_vtbl_entries (binfo)\n      tree binfo;\n {\n-  tree offset;\n-\n-  offset = size_binop (EXACT_DIV_EXPR,\n-\t\t       TYPE_SIZE (vtable_entry_type),\n-\t\t       size_int (BITS_PER_UNIT));\n-  offset = size_binop (MULT_EXPR, offset, num_extra_vtbl_entries (binfo));\n+  tree offset = size_binop (MULT_EXPR, TYPE_SIZE_UNIT (vtable_entry_type),\n+\t\t\t    num_extra_vtbl_entries (binfo));\n   return fold (offset);\n }\n \n@@ -3039,7 +3024,7 @@ tree\n skip_rtti_stuff (binfo, t, n)\n      tree binfo;\n      tree t;\n-     unsigned HOST_WIDE_INT *n;\n+     HOST_WIDE_INT *n;\n {\n   tree virtuals;\n \n@@ -3121,7 +3106,7 @@ dfs_modify_vtables (binfo, data)\n \t  tree overrider;\n \t  tree vindex;\n \t  tree delta;\n-\t  int i;\n+\t  HOST_WIDE_INT i;\n \n \t  /* Find the function which originally caused this vtable\n \t     entry to be present.  */\n@@ -3151,9 +3136,7 @@ dfs_modify_vtables (binfo, data)\n \t\t\t      get_derived_offset (binfo,\n \t\t\t\t\t\t  DECL_VIRTUAL_CONTEXT (fn)),\n \t\t\t      BINFO_OFFSET (binfo));\n-\t  delta = ssize_binop (MINUS_EXPR,\n-\t\t\t       BINFO_OFFSET (TREE_VALUE (overrider)),\n-\t\t\t       delta);\n+\t  delta = size_diffop (BINFO_OFFSET (TREE_VALUE (overrider)), delta);\n \n \t  modify_vtable_entry (t, \n \t\t\t       binfo, \n@@ -4568,8 +4551,7 @@ dfs_propagate_binfo_offsets (binfo, data)\n   tree offset = (tree) data;\n \n   /* Update the BINFO_OFFSET for this base.  */\n-  BINFO_OFFSET (binfo) \n-    = size_binop (PLUS_EXPR, BINFO_OFFSET (binfo), offset);\n+  BINFO_OFFSET (binfo) = size_binop (PLUS_EXPR, BINFO_OFFSET (binfo), offset);\n \n   SET_BINFO_MARKED (binfo);\n \n@@ -4714,9 +4696,8 @@ dfs_set_offset_for_unshared_vbases (binfo, data)\n       tree offset;\n       \n       vbase = BINFO_FOR_VBASE (BINFO_TYPE (binfo), t);\n-      offset = ssize_binop (MINUS_EXPR, \n-\t\t\t    BINFO_OFFSET (vbase),\n-\t\t\t    BINFO_OFFSET (binfo));\n+      offset = size_binop (MINUS_EXPR, \n+\t\t\t   BINFO_OFFSET (vbase), BINFO_OFFSET (binfo));\n       propagate_binfo_offsets (binfo, offset);\n     }\n \n@@ -4789,9 +4770,10 @@ layout_virtual_bases (t)\n   /* Now, make sure that the total size of the type is a multiple of\n      its alignment.  */\n   dsize = CEIL (dsize, TYPE_ALIGN (t)) * TYPE_ALIGN (t);\n-  TYPE_SIZE (t) = size_int (dsize);\n-  TYPE_SIZE_UNIT (t) = size_binop (FLOOR_DIV_EXPR, TYPE_SIZE (t),\n-\t\t\t\t   size_int (BITS_PER_UNIT));\n+  TYPE_SIZE (t) = bitsize_int (dsize);\n+  TYPE_SIZE_UNIT (t) = convert (sizetype,\n+\t\t\t\tsize_binop (FLOOR_DIV_EXPR, TYPE_SIZE (t),\n+\t\t\t\t\t    bitsize_int (BITS_PER_UNIT)));\n }\n \n /* Finish the work of layout_record, now taking virtual bases into account.\n@@ -4915,7 +4897,7 @@ layout_class_type (t, empty_p, has_virtual_p,\n   if (*empty_p && flag_new_abi)\n     {\n       CLASSTYPE_SIZE (t) = bitsize_int (0);\n-      CLASSTYPE_SIZE_UNIT (t) = size_int (0);\n+      CLASSTYPE_SIZE_UNIT (t) = size_zero_node;\n     }\n   else if (flag_new_abi && TYPE_HAS_COMPLEX_INIT_REF (t)\n \t   && TYPE_HAS_COMPLEX_ASSIGN_REF (t))\n@@ -5026,13 +5008,14 @@ finish_struct_1 (t)\n       && DECL_FIELD_CONTEXT (vfield) != t)\n     {\n       tree binfo = get_binfo (DECL_FIELD_CONTEXT (vfield), t, 0);\n-      tree offset = BINFO_OFFSET (binfo);\n+      tree offset = convert (bitsizetype, BINFO_OFFSET (binfo));\n \n       vfield = copy_node (vfield);\n       copy_lang_decl (vfield);\n \n       if (! integer_zerop (offset))\n-\toffset = size_binop (MULT_EXPR, offset, size_int (BITS_PER_UNIT));\n+\toffset = size_binop (MULT_EXPR, offset, bitsize_int (BITS_PER_UNIT));\n+\n       DECL_FIELD_CONTEXT (vfield) = t;\n       DECL_FIELD_BITPOS (vfield)\n \t= size_binop (PLUS_EXPR, offset, DECL_FIELD_BITPOS (vfield));"}, {"sha": "c1ae4d283f9872979050599464b2144ad622f4b5", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fed3cef0dbbd17e3d7b8860f42cd8490f0325340/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fed3cef0dbbd17e3d7b8860f42cd8490f0325340/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=fed3cef0dbbd17e3d7b8860f42cd8490f0325340", "patch": "@@ -3618,7 +3618,8 @@ extern void push_lang_context\t\t\tPARAMS ((tree));\n extern void pop_lang_context\t\t\tPARAMS ((void));\n extern tree instantiate_type\t\t\tPARAMS ((tree, tree, int));\n extern void print_class_statistics\t\tPARAMS ((void));\n-extern tree skip_rtti_stuff\t                PARAMS ((tree, tree, unsigned HOST_WIDE_INT *));\n+extern tree skip_rtti_stuff\t                PARAMS ((tree, tree,\n+\t\t\t\t\t\t\t HOST_WIDE_INT *));\n extern void build_self_reference\t\tPARAMS ((void));\n extern void warn_hidden\t\t\t\tPARAMS ((tree));\n extern tree get_enclosing_class\t\t\tPARAMS ((tree));"}, {"sha": "9743f3753d5cf33bb1f65d05b647d92451418ad5", "filename": "gcc/cp/cvt.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fed3cef0dbbd17e3d7b8860f42cd8490f0325340/gcc%2Fcp%2Fcvt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fed3cef0dbbd17e3d7b8860f42cd8490f0325340/gcc%2Fcp%2Fcvt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcvt.c?ref=fed3cef0dbbd17e3d7b8860f42cd8490f0325340", "patch": "@@ -211,7 +211,8 @@ cp_convert_to_pointer (type, expr)\n \t    expr = cplus_expand_constant (expr);\n \n \t  if (binfo && ! TREE_VIA_VIRTUAL (binfo))\n-\t    expr = size_binop (code, expr, BINFO_OFFSET (binfo));\n+\t    expr = size_binop (code, convert (sizetype,expr),\n+\t\t\t       BINFO_OFFSET (binfo));\n \t}\n       else if (TYPE_PTRMEMFUNC_P (type))\n \t{"}, {"sha": "548aa8251d110d2a03c200e606f67b7e75ae10de", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fed3cef0dbbd17e3d7b8860f42cd8490f0325340/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fed3cef0dbbd17e3d7b8860f42cd8490f0325340/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=fed3cef0dbbd17e3d7b8860f42cd8490f0325340", "patch": "@@ -8244,13 +8244,14 @@ complete_array_type (type, initial_value, do_default)\n       else if (TREE_CODE (initial_value) == CONSTRUCTOR)\n \t{\n \t  tree elts = CONSTRUCTOR_ELTS (initial_value);\n-\t  maxindex = size_binop (MINUS_EXPR, integer_zero_node, size_one_node);\n+\n+\t  maxindex = ssize_int (-1);\n \t  for (; elts; elts = TREE_CHAIN (elts))\n \t    {\n \t      if (TREE_PURPOSE (elts))\n \t\tmaxindex = TREE_PURPOSE (elts);\n \t      else\n-\t\tmaxindex = size_binop (PLUS_EXPR, maxindex, size_one_node);\n+\t\tmaxindex = size_binop (PLUS_EXPR, maxindex, ssize_int (1));\n \t    }\n \t  maxindex = copy_node (maxindex);\n \t}\n@@ -12481,7 +12482,7 @@ xref_basetypes (code_type_node, name, ref, binfo)\n \t     the `accessibility' of that particular inheritance is.)  */\n \n \t  base_binfo\n-\t    = make_binfo (integer_zero_node, basetype,\n+\t    = make_binfo (size_zero_node, basetype,\n \t\t\t  CLASS_TYPE_P (basetype)\n \t\t\t  ? TYPE_BINFO_VTABLE (basetype) : NULL_TREE,\n \t\t\t  CLASS_TYPE_P (basetype)"}, {"sha": "ae6b5115b49a51208f974b7ee13c2fb738b7ebc6", "filename": "gcc/cp/error.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fed3cef0dbbd17e3d7b8860f42cd8490f0325340/gcc%2Fcp%2Ferror.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fed3cef0dbbd17e3d7b8860f42cd8490f0325340/gcc%2Fcp%2Ferror.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ferror.c?ref=fed3cef0dbbd17e3d7b8860f42cd8490f0325340", "patch": "@@ -2,7 +2,6 @@\n    This code is non-reentrant.\n    Copyright (C) 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000\n    Free Software Foundation, Inc.\n-\n    This file is part of GNU CC.\n \n GNU CC is free software; you can redistribute it and/or modify\n@@ -1651,8 +1650,9 @@ dump_expr (t, flags)\n \tif (TREE_CODE (type) == ARRAY_REF)\n \t  type = build_cplus_array_type\n \t    (TREE_OPERAND (type, 0),\n-\t     build_index_type (size_binop (MINUS_EXPR, TREE_OPERAND (type, 1),\n-\t\t\t\t\t   integer_one_node)));\n+\t     build_index_type (fold (build (MINUS_EXPR, integer_type_node,\n+\t\t\t\t\t    TREE_OPERAND (type, 1),\n+\t\t\t\t\t    integer_one_node))));\n \tdump_type (type, flags);\n \tif (TREE_OPERAND (t, 2))\n \t  {"}, {"sha": "05411e3f0886c4b75cb378d978dbf5b30ba063df", "filename": "gcc/cp/expr.c", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fed3cef0dbbd17e3d7b8860f42cd8490f0325340/gcc%2Fcp%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fed3cef0dbbd17e3d7b8860f42cd8490f0325340/gcc%2Fcp%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fexpr.c?ref=fed3cef0dbbd17e3d7b8860f42cd8490f0325340", "patch": "@@ -63,13 +63,12 @@ cplus_expand_constant (cst)\n \t    offset = convert (sizetype,\n \t\t\t      size_binop (EASY_DIV_EXPR,\n \t\t\t\t\t  DECL_FIELD_BITPOS (member),\n-\t\t\t\t\t  size_int (BITS_PER_UNIT)));\n+\t\t\t\t\t  bitsize_int (BITS_PER_UNIT)));\n \n \t    /* We offset all pointer to data members by 1 so that we\n \t       can distinguish between a null pointer to data member\n \t       and the first data member of a structure.  */\n-\t    offset = size_binop (PLUS_EXPR, offset, size_int (1));\n-\t\n+\t    offset = size_binop (PLUS_EXPR, offset, size_one_node);\n \t    cst = cp_convert (type, offset);\n \t  }\n \telse"}, {"sha": "1f2eff44a67e0318966bd355bb5e75782402642a", "filename": "gcc/cp/init.c", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fed3cef0dbbd17e3d7b8860f42cd8490f0325340/gcc%2Fcp%2Finit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fed3cef0dbbd17e3d7b8860f42cd8490f0325340/gcc%2Fcp%2Finit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Finit.c?ref=fed3cef0dbbd17e3d7b8860f42cd8490f0325340", "patch": "@@ -801,7 +801,7 @@ construct_virtual_bases (type, this_ref, this_ptr, init_list, flag)\n       exp = build (PLUS_EXPR,\n \t\t   TREE_TYPE (this_ptr),\n \t\t   this_ptr,\n-\t\t   BINFO_OFFSET (vbases));\n+\t\t   fold (build1 (NOP_EXPR, this_ptr, BINFO_OFFSET (vbases))));\n       exp = build1 (NOP_EXPR, \n \t\t    build_pointer_type (BINFO_TYPE (vbases)), \n \t\t    exp);\n@@ -2482,7 +2482,8 @@ build_vec_delete_1 (base, maxindex, type, auto_delete_vec, use_global_delete)\n     }\n \n   /* The below is short by BI_header_size */\n-  virtual_size = fold (size_binop (MULT_EXPR, size_exp, maxindex));\n+  virtual_size = size_binop (MULT_EXPR, size_exp,\n+\t\t\t     convert (sizetype, maxindex));\n \n   tbase = create_temporary_var (ptype);\n   tbase_init = build_modify_expr (tbase, NOP_EXPR,\n@@ -2525,7 +2526,8 @@ build_vec_delete_1 (base, maxindex, type, auto_delete_vec, use_global_delete)\n       tree base_tbd;\n \n       /* The below is short by BI_header_size */\n-      virtual_size = fold (size_binop (MULT_EXPR, size_exp, maxindex));\n+      virtual_size = size_binop (MULT_EXPR, size_exp,\n+\t\t\t\t convert (sizetype, maxindex));\n \n       if (! TYPE_VEC_NEW_USES_COOKIE (type))\n \t/* no header */"}, {"sha": "2e5a2e6b4662efaa990ded2dd32865b7125378f0", "filename": "gcc/cp/lex.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fed3cef0dbbd17e3d7b8860f42cd8490f0325340/gcc%2Fcp%2Flex.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fed3cef0dbbd17e3d7b8860f42cd8490f0325340/gcc%2Fcp%2Flex.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Flex.c?ref=fed3cef0dbbd17e3d7b8860f42cd8490f0325340", "patch": "@@ -4792,7 +4792,7 @@ cp_make_lang_type (code)\n      canonical binfo for them.  Ideally, this would be done lazily for\n      all types.  */\n   if (IS_AGGR_TYPE_CODE (code) || code == TEMPLATE_TYPE_PARM)\n-    TYPE_BINFO (t) = make_binfo (integer_zero_node, t, NULL_TREE, NULL_TREE);\n+    TYPE_BINFO (t) = make_binfo (size_zero_node, t, NULL_TREE, NULL_TREE);\n \n   return t;\n }"}, {"sha": "cd830819b98a1788e6e9e96be41d981908b7489f", "filename": "gcc/cp/rtti.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fed3cef0dbbd17e3d7b8860f42cd8490f0325340/gcc%2Fcp%2Frtti.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fed3cef0dbbd17e3d7b8860f42cd8490f0325340/gcc%2Fcp%2Frtti.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Frtti.c?ref=fed3cef0dbbd17e3d7b8860f42cd8490f0325340", "patch": "@@ -1,6 +1,6 @@\n /* RunTime Type Identification\n-   Copyright (C) 1995, 1996, 1997, 1998, \n-   1999, 2000 Free Software Foundation, Inc.\n+   Copyright (C) 1995, 1996, 1997, 1998, 1999, 2000\n+   Free Software Foundation, Inc.\n    Mostly written by Jason Merrill (jason@cygnus.com).\n \n This file is part of GNU CC.\n@@ -559,7 +559,7 @@ get_base_offset (binfo, parent)\n       field = lookup_field (parent, get_identifier (name), 0, 0);\n       offset = size_binop (FLOOR_DIV_EXPR, \n     \t\t           DECL_FIELD_BITPOS (field), \n-    \t\t           size_int (BITS_PER_UNIT));\n+    \t\t           bitsize_int (BITS_PER_UNIT));\n       offset = convert (sizetype, offset);\n     }\n   else"}, {"sha": "1a9b13fe027f171e9371ab5ce4ca6e046bd181b6", "filename": "gcc/cp/search.c", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fed3cef0dbbd17e3d7b8860f42cd8490f0325340/gcc%2Fcp%2Fsearch.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fed3cef0dbbd17e3d7b8860f42cd8490f0325340/gcc%2Fcp%2Fsearch.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsearch.c?ref=fed3cef0dbbd17e3d7b8860f42cd8490f0325340", "patch": "@@ -1,6 +1,6 @@\n /* Breadth-first and depth-first routines for\n    searching multiple-inheritance lattice for GNU C++.\n-   Copyright (C) 1987, 89, 1992, 1993, 1994, 1995, 1996, 1997, 1998,\n+   Copyright (C) 1987, 1989, 1992, 1993, 1994, 1995, 1996, 1997, 1998,\n    1999, 2000 Free Software Foundation, Inc.\n    Contributed by Michael Tiemann (tiemann@cygnus.com)\n \n@@ -2704,10 +2704,11 @@ dfs_find_vbases (binfo, data)\n \t{\n \t  tree vbase = BINFO_TYPE (base_binfo);\n \t  tree binfo = binfo_member (vbase, vi->vbase_types);\n+\t  tree ptr_type = build_pointer_type (vbase);\n \n \t  CLASSTYPE_SEARCH_SLOT (vbase)\n-\t    = build (PLUS_EXPR, build_pointer_type (vbase),\n-\t\t     vi->decl_ptr, BINFO_OFFSET (binfo));\n+\t    = build (PLUS_EXPR, ptr_type, vi->decl_ptr,\n+\t\t     convert (ptr_type, BINFO_OFFSET (binfo)));\n \t}\n     }\n   SET_BINFO_VTABLE_PATH_MARKED (binfo);\n@@ -2895,7 +2896,7 @@ expand_upcast_fixups (binfo, addr, orig_addr, vbase, vbase_addr, t,\n   tree virtuals;\n   tree vc;\n   tree delta;\n-  unsigned HOST_WIDE_INT n;\n+  HOST_WIDE_INT n;\n \n   while (BINFO_PRIMARY_MARKED_P (binfo))\n     {\n@@ -3153,7 +3154,7 @@ dfs_get_vbase_types (binfo, data)\n \n   if (TREE_VIA_VIRTUAL (binfo) && ! BINFO_VBASE_MARKED (binfo))\n     {\n-      tree new_vbase = make_binfo (integer_zero_node, \n+      tree new_vbase = make_binfo (size_zero_node, \n \t\t\t\t   BINFO_TYPE (binfo),\n \t\t\t\t   BINFO_VTABLE (binfo),\n \t\t\t\t   BINFO_VIRTUALS (binfo));"}, {"sha": "c739db7e381f50b3ebc1ed5616e46ed32488d6ee", "filename": "gcc/cp/tree.c", "status": "modified", "additions": 8, "deletions": 6, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fed3cef0dbbd17e3d7b8860f42cd8490f0325340/gcc%2Fcp%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fed3cef0dbbd17e3d7b8860f42cd8490f0325340/gcc%2Fcp%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftree.c?ref=fed3cef0dbbd17e3d7b8860f42cd8490f0325340", "patch": "@@ -910,16 +910,18 @@ void\n debug_binfo (elem)\n      tree elem;\n {\n-  unsigned HOST_WIDE_INT n;\n+  HOST_WIDE_INT n;\n   tree virtuals;\n \n-  fprintf (stderr, \"type \\\"%s\\\"; offset = %ld\\n\",\n-\t   TYPE_NAME_STRING (BINFO_TYPE (elem)),\n-\t   (long) TREE_INT_CST_LOW (BINFO_OFFSET (elem)));\n-  fprintf (stderr, \"vtable type:\\n\");\n+  fprintf (stderr, \"type \\\"%s\\\", offset = \",\n+\t   TYPE_NAME_STRING (BINFO_TYPE (elem)));\n+  fprintf (stderr, HOST_WIDE_INT_PRINT_DEC,\n+\t   TREE_INT_CST_LOW (BINFO_OFFSET (elem)));\n+  fprintf (stderr, \"\\nvtable type:\\n\");\n   debug_tree (BINFO_TYPE (elem));\n   if (BINFO_VTABLE (elem))\n-    fprintf (stderr, \"vtable decl \\\"%s\\\"\\n\", IDENTIFIER_POINTER (DECL_NAME (BINFO_VTABLE (elem))));\n+    fprintf (stderr, \"vtable decl \\\"%s\\\"\\n\",\n+\t     IDENTIFIER_POINTER (DECL_NAME (BINFO_VTABLE (elem))));\n   else\n     fprintf (stderr, \"no vtable decl yet\\n\");\n   fprintf (stderr, \"virtuals:\\n\");"}, {"sha": "bb2de7478074b5017b26290b9984e3c4dcbd833b", "filename": "gcc/cp/typeck.c", "status": "modified", "additions": 49, "deletions": 35, "changes": 84, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fed3cef0dbbd17e3d7b8860f42cd8490f0325340/gcc%2Fcp%2Ftypeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fed3cef0dbbd17e3d7b8860f42cd8490f0325340/gcc%2Fcp%2Ftypeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck.c?ref=fed3cef0dbbd17e3d7b8860f42cd8490f0325340", "patch": "@@ -934,6 +934,18 @@ comptypes (t1, t2, strict)\n   if (t2 == error_mark_node)\n     return 0;\n \n+  /* If this is a strict comparison with a sizetype, the actual types\n+     won't be the same (since we need to set TYPE_IS_SIZETYPE, so verify\n+     if they are both the same size and signedness.  */\n+  if (strict == COMPARE_STRICT\n+      && TREE_CODE (t2) == INTEGER_TYPE && TYPE_IS_SIZETYPE (t2) \n+      && TREE_CODE (t1) == INTEGER_TYPE\n+      && TREE_UNSIGNED (t1) == TREE_UNSIGNED (t2)\n+      && TYPE_MODE (t1) == TYPE_MODE (t2)\n+      && TYPE_MIN_VALUE (t1) == TYPE_MIN_VALUE (t2)\n+      && TYPE_MAX_VALUE (t1) == TYPE_MAX_VALUE (t2))\n+    return 1;\n+\n   if (strict & COMPARE_RELAXED)\n     {\n       /* Treat an enum type as the unsigned integer type of the same width.  */\n@@ -1539,7 +1551,6 @@ c_sizeof (type)\n      tree type;\n {\n   enum tree_code code = TREE_CODE (type);\n-  tree t;\n \n   if (processing_template_decl)\n     return build_min (SIZEOF_EXPR, sizetype, type);\n@@ -1548,22 +1559,22 @@ c_sizeof (type)\n     {\n       if (pedantic || warn_pointer_arith)\n \tpedwarn (\"ISO C++ forbids applying `sizeof' to a function type\");\n-      return size_int (1);\n+      return size_one_node;\n     }\n   if (code == METHOD_TYPE)\n     {\n       if (pedantic || warn_pointer_arith)\n \tpedwarn (\"ISO C++ forbids applying `sizeof' to a member function\");\n-      return size_int (1);\n+      return size_one_node;\n     }\n   if (code == VOID_TYPE)\n     {\n       if (pedantic || warn_pointer_arith)\n \tpedwarn (\"ISO C++ forbids applying `sizeof' to type `void' which is an incomplete type\");\n-      return size_int (1);\n+      return size_one_node;\n     }\n   if (code == ERROR_MARK)\n-    return size_int (1);\n+    return size_one_node;\n \n   /* ARM $5.3.2: ``When applied to a reference, the result is the size of the\n      referenced object.'' */\n@@ -1573,23 +1584,19 @@ c_sizeof (type)\n   if (code == OFFSET_TYPE)\n     {\n       cp_error (\"`sizeof' applied to non-static member\");\n-      return size_int (0);\n+      return size_zero_node;\n     }\n \n   if (TYPE_SIZE (complete_type (type)) == 0)\n     {\n       cp_error (\"`sizeof' applied to incomplete type `%T'\", type);\n-      return size_int (0);\n+      return size_zero_node;\n     }\n \n   /* Convert in case a char is more than one unit.  */\n-  t = size_binop (CEIL_DIV_EXPR, TYPE_SIZE (type), \n-\t\t  size_int (TYPE_PRECISION (char_type_node)));\n-  t = convert (sizetype, t);\n-  /* size_binop does not put the constant in range, so do it now.  */\n-  if (TREE_CODE (t) == INTEGER_CST && force_fit_type (t, 0))\n-    TREE_CONSTANT_OVERFLOW (t) = TREE_OVERFLOW (t) = 1;\n-  return t;\n+  return size_binop (CEIL_DIV_EXPR, TYPE_SIZE_UNIT (type),\n+\t\t     size_int (TYPE_PRECISION (char_type_node)\n+\t\t\t       / BITS_PER_UNIT));\n }\n \n tree\n@@ -1605,12 +1612,12 @@ expr_sizeof (e)\n   if (is_overloaded_fn (e))\n     {\n       pedwarn (\"ISO C++ forbids applying `sizeof' to an expression of function type\");\n-      return size_int (1);\n+      return size_one_node;\n     }\n   else if (type_unknown_p (e))\n     {\n       incomplete_type_error (e, TREE_TYPE (e));\n-      return size_int (1);\n+      return size_one_node;\n     }\n   /* It's illegal to say `sizeof (X::i)' for `i' a non-static data\n      member unless you're in a non-static member of X.  So hand off to\n@@ -1629,25 +1636,23 @@ c_sizeof_nowarn (type)\n      tree type;\n {\n   enum tree_code code = TREE_CODE (type);\n-  tree t;\n \n   if (code == FUNCTION_TYPE\n       || code == METHOD_TYPE\n       || code == VOID_TYPE\n       || code == ERROR_MARK)\n-    return size_int (1);\n+    return size_one_node;\n+\n   if (code == REFERENCE_TYPE)\n     type = TREE_TYPE (type);\n \n   if (TYPE_SIZE (type) == 0)\n-    return size_int (0);\n+    return size_zero_node;\n \n   /* Convert in case a char is more than one unit.  */\n-  t = size_binop (CEIL_DIV_EXPR, TYPE_SIZE (type), \n-\t\t  size_int (TYPE_PRECISION (char_type_node)));\n-  t = convert (sizetype, t);\n-  force_fit_type (t, 0);\n-  return t;\n+  return size_binop (CEIL_DIV_EXPR, TYPE_SIZE_UNIT (type),\n+\t\t     size_int (TYPE_PRECISION (char_type_node)\n+\t\t\t       / BITS_PER_UNIT));\n }\n \n /* Implement the __alignof keyword: Return the minimum required\n@@ -1667,7 +1672,7 @@ c_alignof (type)\n     return size_int (FUNCTION_BOUNDARY / BITS_PER_UNIT);\n \n   if (code == VOID_TYPE || code == ERROR_MARK)\n-    return size_int (1);\n+    return size_one_node;\n \n   /* C++: this is really correct!  */\n   if (code == REFERENCE_TYPE)\n@@ -4301,7 +4306,7 @@ build_component_addr (arg, argtype)\n   if (! integer_zerop (DECL_FIELD_BITPOS (field)))\n     {\n       tree offset = size_binop (EASY_DIV_EXPR, DECL_FIELD_BITPOS (field),\n-\t\t\t\tsize_int (BITS_PER_UNIT));\n+\t\t\t\tbitsize_int (BITS_PER_UNIT));\n       int flag = TREE_CONSTANT (rval);\n       offset = convert (sizetype, offset);\n       rval = fold (build (PLUS_EXPR, argtype,\n@@ -6287,7 +6292,11 @@ build_ptrmemfunc (type, pfn, force)\n }\n \n /* Return the DELTA, IDX, PFN, and DELTA2 values for the PTRMEM_CST\n-   given by CST.  */\n+   given by CST.\n+\n+   ??? There is no consistency as to the types returned for the above\n+   values.  Some code acts as if its a sizetype and some as if its\n+   integer_type_node.  */\n \n void\n expand_ptrmemfunc_cst (cst, delta, idx, pfn, delta2)\n@@ -6315,7 +6324,7 @@ expand_ptrmemfunc_cst (cst, delta, idx, pfn, delta2)\n   if (!DECL_VIRTUAL_P (fn))\n     {\n       if (!flag_new_abi)\n-\t*idx = size_binop (MINUS_EXPR, integer_zero_node, integer_one_node);\n+\t*idx = convert (TYPE_PTRMEMFUNC_FN_TYPE (type), build_int_2 (-1, -1));\n       else\n \t*idx = NULL_TREE;\n       *pfn = convert (TYPE_PTRMEMFUNC_FN_TYPE (type), build_addr_func (fn));\n@@ -6328,27 +6337,32 @@ expand_ptrmemfunc_cst (cst, delta, idx, pfn, delta2)\n          fn; the call will do the opposite adjustment.  */\n       tree orig_class = DECL_VIRTUAL_CONTEXT (fn);\n       tree binfo = binfo_or_else (orig_class, fn_class);\n-      *delta = size_binop (PLUS_EXPR, *delta, BINFO_OFFSET (binfo));\n+      *delta = fold (build (PLUS_EXPR, TREE_TYPE (*delta),\n+\t\t\t    *delta, BINFO_OFFSET (binfo)));\n \n       if (!flag_new_abi)\n \t{\n \t  /* Map everything down one to make room for the null PMF.  */\n-\t  *idx = size_binop (PLUS_EXPR, DECL_VINDEX (fn), integer_one_node);\n+\t  *idx = fold (build (PLUS_EXPR, integer_type_node,\n+\t\t\t      DECL_VINDEX (fn), integer_one_node));\n \t  *pfn = NULL_TREE;\n \t}\n       else\n \t{\n \t  /* Under the new ABI, we set PFN to twice the index, plus\n \t     one.  */\n \t  *idx = NULL_TREE;\n-\t  *pfn = size_binop (MULT_EXPR, DECL_VINDEX (fn), integer_two_node);\n-\t  *pfn = size_binop (PLUS_EXPR, *pfn, integer_one_node);\n-\t  *pfn = build1 (NOP_EXPR, TYPE_PTRMEMFUNC_FN_TYPE (type), *pfn);\n+\t  *pfn = fold (build (MULT_EXPR, integer_type_node,\n+\t\t\t      DECL_VINDEX (fn), integer_two_node));\n+\t  *pfn = fold (build (PLUS_EXPR, integer_type_node, *pfn,\n+\t\t\t      integer_one_node));\n+\t  *pfn = fold (build1 (NOP_EXPR, TYPE_PTRMEMFUNC_FN_TYPE (type),\n+\t\t\t       *pfn));\n \t}\n \n       /* Offset from an object of PTR_CLASS to the vptr for ORIG_CLASS.  */\n-      *delta2 = size_binop (PLUS_EXPR, *delta,\n-\t\t\t    get_vfield_offset (TYPE_BINFO (orig_class)));\n+      *delta2 = fold (build (PLUS_EXPR, integer_type_node, *delta,\n+\t\t\t     get_vfield_offset (TYPE_BINFO (orig_class))));\n     }\n }\n "}, {"sha": "ba0fa770a8313f71e63841134baf7e917f786286", "filename": "gcc/expr.c", "status": "modified", "additions": 49, "deletions": 50, "changes": 99, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fed3cef0dbbd17e3d7b8860f42cd8490f0325340/gcc%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fed3cef0dbbd17e3d7b8860f42cd8490f0325340/gcc%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.c?ref=fed3cef0dbbd17e3d7b8860f42cd8490f0325340", "patch": "@@ -3864,8 +3864,7 @@ store_expr (exp, target, want_value)\n \t      tree copy_size\n \t\t= size_binop (MIN_EXPR,\n \t\t\t      make_tree (sizetype, size),\n-\t\t\t      convert (sizetype,\n-\t\t\t\t       build_int_2 (TREE_STRING_LENGTH (exp), 0)));\n+\t\t\t      size_int (TREE_STRING_LENGTH (exp)));\n \t      rtx copy_size_rtx = expand_expr (copy_size, NULL_RTX,\n \t\t\t\t\t       VOIDmode, 0);\n \t      rtx label = 0;\n@@ -4215,11 +4214,12 @@ store_constructor (exp, target, align, cleared, size)\n \t      rtx offset_rtx;\n \n \t      if (contains_placeholder_p (offset))\n-\t\toffset = build (WITH_RECORD_EXPR, sizetype,\n+\t\toffset = build (WITH_RECORD_EXPR, bitsizetype,\n \t\t\t\toffset, make_tree (TREE_TYPE (exp), target));\n \n \t      offset = size_binop (EXACT_DIV_EXPR, offset,\n-\t\t\t\t   size_int (BITS_PER_UNIT));\n+\t\t\t\t   bitsize_int (BITS_PER_UNIT));\n+\t      offset = convert (sizetype, offset);\n \n \t      offset_rtx = expand_expr (offset, NULL_RTX, VOIDmode, 0);\n \t      if (GET_CODE (to_rtx) != MEM)\n@@ -4435,12 +4435,14 @@ store_constructor (exp, target, align, cleared, size)\n \t\t  loop = expand_start_loop (0);\n \n \t\t  /* Assign value to element index.  */\n-\t\t  position = size_binop (EXACT_DIV_EXPR, TYPE_SIZE (elttype),\n-\t\t\t\t\t size_int (BITS_PER_UNIT));\n-\t\t  position = size_binop (MULT_EXPR,\n-\t\t\t\t\t size_binop (MINUS_EXPR, index,\n-\t\t\t\t\t\t     TYPE_MIN_VALUE (domain)),\n-\t\t\t\t\t position);\n+\t\t  position\n+\t\t    = convert (ssizetype,\n+\t\t\t       fold (build (MINUS_EXPR, TREE_TYPE (index),\n+\t\t\t\t\t    index, TYPE_MIN_VALUE (domain))));\n+\t\t  position = size_binop (MULT_EXPR, position,\n+\t\t\t\t\t convert (ssizetype,\n+\t\t\t\t\t\t  TYPE_SIZE_UNIT (elttype)));\n+\n \t\t  pos_rtx = expand_expr (position, 0, VOIDmode, 0);\n \t\t  addr = gen_rtx_PLUS (Pmode, XEXP (target, 0), pos_rtx);\n \t\t  xtarget = change_address (target, mode, addr);\n@@ -4473,14 +4475,15 @@ store_constructor (exp, target, align, cleared, size)\n \t      tree position;\n \n \t      if (index == 0)\n-\t\tindex = size_int (i);\n+\t\tindex = ssize_int (1);\n \n \t      if (minelt)\n-\t\tindex = size_binop (MINUS_EXPR, index,\n-\t\t\t\t    TYPE_MIN_VALUE (domain));\n-\t      position = size_binop (EXACT_DIV_EXPR, TYPE_SIZE (elttype),\n-\t\t\t\t     size_int (BITS_PER_UNIT));\n-\t      position = size_binop (MULT_EXPR, index, position);\n+\t\tindex = convert (ssizetype,\n+\t\t\t\t fold (build (MINUS_EXPR, index,\n+\t\t\t\t\t      TYPE_MIN_VALUE (domain))));\n+\t      position = size_binop (MULT_EXPR, index,\n+\t\t\t\t     convert (ssizetype,\n+\t\t\t\t\t      TYPE_SIZE_UNIT (elttype)));\n \t      pos_rtx = expand_expr (position, 0, VOIDmode, 0);\n \t      addr = gen_rtx_PLUS (Pmode, XEXP (target, 0), pos_rtx);\n \t      xtarget = change_address (target, mode, addr);\n@@ -4528,8 +4531,8 @@ store_constructor (exp, target, align, cleared, size)\n       domain_min = convert (sizetype, TYPE_MIN_VALUE (domain));\n       domain_max = convert (sizetype, TYPE_MAX_VALUE (domain));\n       bitlength = size_binop (PLUS_EXPR,\n-\t\t\t      size_binop (MINUS_EXPR, domain_max, domain_min),\n-\t\t\t      size_one_node);\n+\t\t\t      size_diffop (domain_max, domain_min),\n+\t\t\t      ssize_int (1));\n \n       if (nbytes < 0 || TREE_CODE (bitlength) != INTEGER_CST)\n \tabort ();\n@@ -4930,7 +4933,7 @@ get_inner_reference (exp, pbitsize, pbitpos, poffset, pmode,\n   tree orig_exp = exp;\n   tree size_tree = 0;\n   enum machine_mode mode = VOIDmode;\n-  tree offset = integer_zero_node;\n+  tree offset = size_zero_node;\n   unsigned int alignment = BIGGEST_ALIGNMENT;\n \n   if (TREE_CODE (exp) == COMPONENT_REF)\n@@ -4975,7 +4978,7 @@ get_inner_reference (exp, pbitsize, pbitpos, poffset, pmode,\n \t  tree pos = (TREE_CODE (exp) == COMPONENT_REF\n \t\t      ? DECL_FIELD_BITPOS (TREE_OPERAND (exp, 1))\n \t\t      : TREE_OPERAND (exp, 2));\n-\t  tree constant = integer_zero_node, var = pos;\n+\t  tree constant = bitsize_int (0), var = pos;\n \n \t  /* If this field hasn't been filled in yet, don't go\n \t     past it.  This should only happen when folding expressions\n@@ -4989,12 +4992,14 @@ get_inner_reference (exp, pbitsize, pbitpos, poffset, pmode,\n \t      && TREE_CODE (TREE_OPERAND (pos, 1)) == INTEGER_CST)\n \t    constant = TREE_OPERAND (pos, 1), var = TREE_OPERAND (pos, 0);\n \t  else if (TREE_CODE (pos) == INTEGER_CST)\n-\t    constant = pos, var = integer_zero_node;\n+\t    constant = pos, var = bitsize_int (0);\n \n \t  *pbitpos += TREE_INT_CST_LOW (constant);\n-\t  offset = size_binop (PLUS_EXPR, offset,\n-\t\t\t       size_binop (EXACT_DIV_EXPR, var,\n-\t\t\t\t\t   size_int (BITS_PER_UNIT)));\n+\t  offset\n+\t    = size_binop (PLUS_EXPR, offset,\n+\t\t\t  convert (sizetype,\n+\t\t\t\t   size_binop (EXACT_DIV_EXPR, var,\n+\t\t\t\t\t       bitsize_int (BITS_PER_UNIT))));\n \t}\n \n       else if (TREE_CODE (exp) == ARRAY_REF)\n@@ -5051,14 +5056,16 @@ get_inner_reference (exp, pbitsize, pbitpos, poffset, pmode,\n \t\t it overflowed.  In either case, redo the multiplication\n \t\t against the size in units.  This is especially important\n \t\t in the non-constant case to avoid a division at runtime.  */\n-\t      xindex = fold (build (MULT_EXPR, ssizetype, index,\n-                                    convert (ssizetype,\n-                                         TYPE_SIZE_UNIT (TREE_TYPE (exp)))));\n+\t      xindex\n+\t\t= fold (build (MULT_EXPR, ssizetype, index,\n+\t\t\t       convert (ssizetype,\n+\t\t\t\t\tTYPE_SIZE_UNIT (TREE_TYPE (exp)))));\n \n \t      if (contains_placeholder_p (xindex))\n-\t\txindex = build (WITH_RECORD_EXPR, sizetype, xindex, exp);\n+\t\txindex = build (WITH_RECORD_EXPR, ssizetype, xindex, exp);\n \n-\t      offset = size_binop (PLUS_EXPR, offset, xindex);\n+\t      offset\n+\t\t= size_binop (PLUS_EXPR, offset, convert (sizetype, xindex));\n \t    }\n \t}\n       else if (TREE_CODE (exp) != NON_LVALUE_EXPR\n@@ -6457,8 +6464,7 @@ expand_expr (exp, target, tmode, modifier)\n \ttree array = TREE_OPERAND (exp, 0);\n \ttree domain = TYPE_DOMAIN (TREE_TYPE (array));\n \ttree low_bound = domain ? TYPE_MIN_VALUE (domain) : integer_zero_node;\n-\ttree index = TREE_OPERAND (exp, 1);\n-\ttree index_type = TREE_TYPE (index);\n+\ttree index = convert (sizetype, TREE_OPERAND (exp, 1));\n \tHOST_WIDE_INT i;\n \n \t/* Optimize the special-case of a zero lower bound.\n@@ -6467,14 +6473,10 @@ expand_expr (exp, target, tmode, modifier)\n \t   with constant folding.  (E.g. suppose the lower bound is 1,\n \t   and its mode is QI.  Without the conversion,  (ARRAY\n \t   +(INDEX-(unsigned char)1)) becomes ((ARRAY+(-(unsigned char)1))\n-\t   +INDEX), which becomes (ARRAY+255+INDEX).  Oops!)\n-\n-\t   But sizetype isn't quite right either (especially if\n-\t   the lowbound is negative).  FIXME */\n+\t   +INDEX), which becomes (ARRAY+255+INDEX).  Oops!)  */\n \n \tif (! integer_zerop (low_bound))\n-\t  index = fold (build (MINUS_EXPR, index_type, index,\n-\t\t\t       convert (sizetype, low_bound)));\n+\t  index = size_diffop (index, convert (sizetype, low_bound));\n \n \t/* Fold an expression like: \"foo\"[2].\n \t   This is not done in fold so it won't happen inside &.\n@@ -8508,8 +8510,7 @@ expand_expr_unaligned (exp, palign)\n \ttree array = TREE_OPERAND (exp, 0);\n \ttree domain = TYPE_DOMAIN (TREE_TYPE (array));\n \ttree low_bound = domain ? TYPE_MIN_VALUE (domain) : integer_zero_node;\n-\ttree index = TREE_OPERAND (exp, 1);\n-\ttree index_type = TREE_TYPE (index);\n+\ttree index = convert (sizetype, TREE_OPERAND (exp, 1));\n \tHOST_WIDE_INT i;\n \n \tif (TREE_CODE (TREE_TYPE (TREE_OPERAND (exp, 0))) != ARRAY_TYPE)\n@@ -8521,14 +8522,10 @@ expand_expr_unaligned (exp, palign)\n \t   with constant folding.  (E.g. suppose the lower bound is 1,\n \t   and its mode is QI.  Without the conversion,  (ARRAY\n \t   +(INDEX-(unsigned char)1)) becomes ((ARRAY+(-(unsigned char)1))\n-\t   +INDEX), which becomes (ARRAY+255+INDEX).  Oops!)\n-\n-\t   But sizetype isn't quite right either (especially if\n-\t   the lowbound is negative).  FIXME */\n+\t   +INDEX), which becomes (ARRAY+255+INDEX).  Oops!)  */\n \n \tif (! integer_zerop (low_bound))\n-\t  index = fold (build (MINUS_EXPR, index_type, index,\n-\t\t\t       convert (sizetype, low_bound)));\n+\t  index = size_diffop (index, convert (sizetype, low_bound));\n \n \t/* If this is a constant index into a constant array,\n \t   just get the value from the array.  Handle both the cases when\n@@ -8778,8 +8775,10 @@ expand_expr_unaligned (exp, palign)\n   return expand_expr (exp, NULL_RTX, VOIDmode, EXPAND_NORMAL);\n }\n \f\n-/* Return the tree node and offset if a given argument corresponds to\n-   a string constant.  */\n+/* Return the tree node if a ARG corresponds to a string constant or zero\n+   if it doesn't.  If we return non-zero, set *PTR_OFFSET to the offset\n+   in bytes within the string that ARG is accessing.  The type of the\n+   offset will be `sizetype'.  */\n \n tree\n string_constant (arg, ptr_offset)\n@@ -8791,7 +8790,7 @@ string_constant (arg, ptr_offset)\n   if (TREE_CODE (arg) == ADDR_EXPR\n       && TREE_CODE (TREE_OPERAND (arg, 0)) == STRING_CST)\n     {\n-      *ptr_offset = integer_zero_node;\n+      *ptr_offset = size_zero_node;\n       return TREE_OPERAND (arg, 0);\n     }\n   else if (TREE_CODE (arg) == PLUS_EXPR)\n@@ -8805,13 +8804,13 @@ string_constant (arg, ptr_offset)\n       if (TREE_CODE (arg0) == ADDR_EXPR\n \t  && TREE_CODE (TREE_OPERAND (arg0, 0)) == STRING_CST)\n \t{\n-\t  *ptr_offset = arg1;\n+\t  *ptr_offset = convert (sizetype, arg1);\n \t  return TREE_OPERAND (arg0, 0);\n \t}\n       else if (TREE_CODE (arg1) == ADDR_EXPR\n \t       && TREE_CODE (TREE_OPERAND (arg1, 0)) == STRING_CST)\n \t{\n-\t  *ptr_offset = arg0;\n+\t  *ptr_offset = convert (sizetype, arg0);\n \t  return TREE_OPERAND (arg1, 0);\n \t}\n     }"}, {"sha": "dfb7e4c9325891508b142ef7d1a4de066bbfcfe5", "filename": "gcc/expr.h", "status": "modified", "additions": 14, "deletions": 12, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fed3cef0dbbd17e3d7b8860f42cd8490f0325340/gcc%2Fexpr.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fed3cef0dbbd17e3d7b8860f42cd8490f0325340/gcc%2Fexpr.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.h?ref=fed3cef0dbbd17e3d7b8860f42cd8490f0325340", "patch": "@@ -79,7 +79,9 @@ enum memory_use_mode {MEMORY_USE_BAD = 0, MEMORY_USE_RO = 1,\n \f\n #ifdef TREE_CODE /* Don't lose if tree.h not included.  */\n /* Structure to record the size of a sequence of arguments\n-   as the sum of a tree-expression and a constant.  */\n+   as the sum of a tree-expression and a constant.  This structure is\n+   also used to store offsets from the stack, which might be negative,\n+   so the variable part must be ssizetype, not sizetype.  */\n \n struct args_size\n {\n@@ -104,21 +106,21 @@ struct args_size\n   if (TREE_CODE (dec) == INTEGER_CST)\t\t\\\n     (TO).constant -= TREE_INT_CST_LOW (dec);\t\\\n   else if ((TO).var == 0)\t\t\t\\\n-    (TO).var = size_binop (MINUS_EXPR, integer_zero_node, dec); \\\n+    (TO).var = size_binop (MINUS_EXPR, ssize_int (0), dec); \\\n   else\t\t\t\t\t\t\\\n     (TO).var = size_binop (MINUS_EXPR, (TO).var, dec); }\n \n+/* Convert the implicit sum in a `struct args_size' into a tree\n+   of type ssizetype.  */\n+#define ARGS_SIZE_TREE(SIZE)\t\t\t\t\t\\\n+((SIZE).var == 0 ? ssize_int ((SIZE).constant)\t\t\t\\\n+ : size_binop (PLUS_EXPR, (SIZE).var, ssize_int ((SIZE).constant)))\n+\n /* Convert the implicit sum in a `struct args_size' into an rtx.  */\n-#define ARGS_SIZE_RTX(SIZE)\t\t\t\t\t\t\\\n-((SIZE).var == 0 ? GEN_INT ((SIZE).constant)\t\\\n- : expand_expr (size_binop (PLUS_EXPR, (SIZE).var,\t\t\t\\\n-\t\t\t    size_int ((SIZE).constant)),\t\t\\\n-\t\tNULL_RTX, VOIDmode, EXPAND_MEMORY_USE_BAD))\n-\n-/* Convert the implicit sum in a `struct args_size' into a tree.  */\n-#define ARGS_SIZE_TREE(SIZE)\t\t\t\t\t\t\\\n-((SIZE).var == 0 ? size_int ((SIZE).constant)\t\t\t\t\\\n- : size_binop (PLUS_EXPR, (SIZE).var, size_int ((SIZE).constant)))\n+#define ARGS_SIZE_RTX(SIZE)\t\t\t\t\t\\\n+((SIZE).var == 0 ? GEN_INT ((SIZE).constant)\t\t\t\\\n+ : expand_expr (ARGS_SIZE_TREE (SIZE), NULL_RTX, VOIDmode,\t\\\n+\t\tEXPAND_MEMORY_USE_BAD))\n \n /* Supply a default definition for FUNCTION_ARG_PADDING:\n    usually pad upward, but pad short args downward on"}, {"sha": "9a4a86f9beacef1bd4971b2947ab35a2caac97e2", "filename": "gcc/f/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fed3cef0dbbd17e3d7b8860f42cd8490f0325340/gcc%2Ff%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fed3cef0dbbd17e3d7b8860f42cd8490f0325340/gcc%2Ff%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ff%2FChangeLog?ref=fed3cef0dbbd17e3d7b8860f42cd8490f0325340", "patch": "@@ -1,3 +1,12 @@\n+Sun Feb 27 16:40:33 2000  Richard Kenner  <kenner@vlsi1.ultra.nyu.edu>\n+\n+\t* com.c (ffecom_arrayref_): Convert args to size_binop to proper type.\n+\t(ffecom_tree_canonize_ptr_): Don't use size_binop for non-sizes.\n+\t(ffecom_tree_canonize_ref_): Likewise.\n+\t(type_for_mode): Handle TImode.\n+\t* ste.c (ffeste_io_dofio_, ffeste_io_douio_): Use TYPE_SIZE_UNIT.\n+\t(ffeste_io_ciclist_): Likewise.\n+\n 2000-02-23  Zack Weinberg  <zack@wolery.cumb.org>\n \n \t* com.c (ffecom_type_permanent_copy_): Delete unused function."}, {"sha": "ff2e45c8de0d2879fa0327435ea50326dde7acca", "filename": "gcc/f/com.c", "status": "modified", "additions": 25, "deletions": 20, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fed3cef0dbbd17e3d7b8860f42cd8490f0325340/gcc%2Ff%2Fcom.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fed3cef0dbbd17e3d7b8860f42cd8490f0325340/gcc%2Ff%2Fcom.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ff%2Fcom.c?ref=fed3cef0dbbd17e3d7b8860f42cd8490f0325340", "patch": "@@ -969,10 +969,10 @@ ffecom_arrayref_ (tree item, ffebld expr, int want_ptr)\n \t\t\t   item,\n \t\t\t   size_binop (MULT_EXPR,\n \t\t\t\t       size_in_bytes (TREE_TYPE (array)),\n-\t\t\t\t       fold (build (MINUS_EXPR,\n-\t\t\t\t\t\t    tree_type_x,\n-\t\t\t\t\t\t    element,\n-\t\t\t\t\t\t    min))));\n+\t\t\t\t       convert (sizetype,\n+\t\t\t\t\t\tfold (build (MINUS_EXPR,\n+\t\t\t\t\t\t\t     tree_type_x,\n+\t\t\t\t\t\t\t     element, min)))));\n \t}\n       if (! want_ptr)\n \t{\n@@ -9090,14 +9090,13 @@ ffecom_tree_canonize_ptr_ (tree *decl, tree *offset,\n       if (TREE_CODE (TREE_OPERAND (t, 1)) == INTEGER_CST)\n \t{\n \t  /* An offset into COMMON.  */\n-\t  *offset = size_binop (PLUS_EXPR,\n-\t\t\t\t*offset,\n-\t\t\t\tTREE_OPERAND (t, 1));\n+\t  *offset = fold (build (PLUS_EXPR, TREE_TYPE (*offset),\n+\t\t\t\t *offset, TREE_OPERAND (t, 1)));\n \t  /* Convert offset (presumably in bytes) into canonical units\n \t     (presumably bits).  */\n-\t  *offset = size_binop (MULT_EXPR,\n-\t\t\t\tTYPE_SIZE (TREE_TYPE (TREE_TYPE (t))),\n-\t\t\t\t*offset);\n+\t  *offset = fold (build (MULT_EXPR, TREE_TYPE (*offset),\n+\t\t\t\t TYPE_SIZE (TREE_TYPE (TREE_TYPE (t))),\n+\t\t\t\t *offset));\n \t  break;\n \t}\n       /* Not a COMMON reference, so an unrecognized pattern.  */\n@@ -9258,16 +9257,17 @@ ffecom_tree_canonize_ref_ (tree *decl, tree *offset,\n \t    || (*decl == error_mark_node))\n \t  return;\n \n-\t*offset = size_binop (MULT_EXPR,\n-\t\t\t      TYPE_SIZE (TREE_TYPE (TREE_TYPE (array))),\n-\t\t\t      size_binop (MINUS_EXPR,\n-\t\t\t\t\t  element,\n-\t\t\t\t\t  TYPE_MIN_VALUE\n-\t\t\t\t\t  (TYPE_DOMAIN\n-\t\t\t\t\t   (TREE_TYPE (array)))));\n-\n-\t*offset = size_binop (PLUS_EXPR,\n-\t\t\t      init_offset,\n+\t*offset\n+\t  = size_binop (MULT_EXPR,\n+\t\t\tTYPE_SIZE (TREE_TYPE (TREE_TYPE (array))),\n+\t\t\tconvert (sizetype,\n+\t\t\t\t fold (build (MINUS_EXPR, TREE_TYPE (element),\n+\t\t\t\t\t      element,\n+\t\t\t\t\t      TYPE_MIN_VALUE\n+\t\t\t\t\t      (TYPE_DOMAIN\n+\t\t\t\t\t       (TREE_TYPE (array)))))));;\n+\n+\t*offset = size_binop (PLUS_EXPR, convert (sizetype, init_offset),\n \t\t\t      *offset);\n \n \t*size = TYPE_SIZE (TREE_TYPE (t));\n@@ -15633,6 +15633,11 @@ type_for_mode (mode, unsignedp)\n   if (mode == TYPE_MODE (long_long_integer_type_node))\n     return unsignedp ? long_long_unsigned_type_node : long_long_integer_type_node;\n \n+#if HOST_BITS_PER_WIDE_INT >= 64\n+  if (mode == TYPE_MODE (intTI_type_node))\n+    return unsignedp ? unsigned_intTI_type_node : intTI_type_node;\n+#endif\n+\n   if (mode == TYPE_MODE (float_type_node))\n     return float_type_node;\n "}, {"sha": "f25b929d94905a71a480f6507a61b9fb1a2d094d", "filename": "gcc/f/ste.c", "status": "modified", "additions": 44, "deletions": 40, "changes": 84, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fed3cef0dbbd17e3d7b8860f42cd8490f0325340/gcc%2Ff%2Fste.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fed3cef0dbbd17e3d7b8860f42cd8490f0325340/gcc%2Ff%2Fste.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ff%2Fste.c?ref=fed3cef0dbbd17e3d7b8860f42cd8490f0325340", "patch": "@@ -1,5 +1,5 @@\n /* ste.c -- Implementation File (module.c template V1.0)\n-   Copyright (C) 1995, 1996 Free Software Foundation, Inc.\n+   Copyright (C) 1995, 1996, 2000 Free Software Foundation, Inc.\n    Contributed by James Craig Burley.\n \n This file is part of GNU Fortran.\n@@ -959,8 +959,9 @@ ffeste_io_dofio_ (ffebld expr)\n   if (size == NULL_TREE)\t/* Already filled in for CHARACTER type. */\n     {\t\t\t\t/* \"(ftnlen) sizeof(type)\" */\n       size = size_binop (CEIL_DIV_EXPR,\n-\t\t\t TYPE_SIZE (ffecom_tree_type[bt][kt]),\n-\t\t\t size_int (TYPE_PRECISION (char_type_node)));\n+\t\t\t TYPE_SIZE_UNIT (ffecom_tree_type[bt][kt]),\n+\t\t\t size_int (TYPE_PRECISION (char_type_node)\n+\t\t\t\t   / BITS_PER_UNIT));\n #if 0\t/* Assume that while it is possible that char * is wider than\n \t   ftnlen, no object in Fortran space can get big enough for its\n \t   size to be wider than ftnlen.  I really hope nobody wastes\n@@ -977,13 +978,13 @@ ffeste_io_dofio_ (ffebld expr)\n       = is_complex ? ffecom_f2c_ftnlen_two_node : ffecom_f2c_ftnlen_one_node;\n   else\n     {\n-      num_elements = size_binop (CEIL_DIV_EXPR,\n-\t\t\t\t TYPE_SIZE (TREE_TYPE (TREE_TYPE (variable))),\n-\t\t\t\t size);\n-      num_elements = size_binop (CEIL_DIV_EXPR,\n-\t\t\t\t num_elements,\n-\t\t\t\t size_int (TYPE_PRECISION\n-\t\t\t\t\t   (char_type_node)));\n+      num_elements\n+\t= size_binop (CEIL_DIV_EXPR,\n+\t\t      TYPE_SIZE_UNIT (TREE_TYPE (TREE_TYPE (variable))),\n+\t\t      convert (sizetype, size));\n+      num_elements = size_binop (CEIL_DIV_EXPR, num_elements,\n+\t\t\t\t size_int (TYPE_PRECISION (char_type_node)\n+\t\t\t\t\t   / BITS_PER_UNIT));\n       num_elements = convert (ffecom_f2c_ftnlen_type_node,\n \t\t\t      num_elements);\n     }\n@@ -1050,8 +1051,9 @@ ffeste_io_dolio_ (ffebld expr)\n   if (size == NULL_TREE)\t/* Already filled in for CHARACTER type. */\n     {\t\t\t\t/* \"(ftnlen) sizeof(type)\" */\n       size = size_binop (CEIL_DIV_EXPR,\n-\t\t\t TYPE_SIZE (ffecom_tree_type[bt][kt]),\n-\t\t\t size_int (TYPE_PRECISION (char_type_node)));\n+\t\t\t TYPE_SIZE_UNIT (ffecom_tree_type[bt][kt]),\n+\t\t\t size_int (TYPE_PRECISION (char_type_node)\n+\t\t\t\t   / BITS_PER_UNIT));\n #if 0\t/* Assume that while it is possible that char * is wider than\n \t   ftnlen, no object in Fortran space can get big enough for its\n \t   size to be wider than ftnlen.  I really hope nobody wastes\n@@ -1067,13 +1069,13 @@ ffeste_io_dolio_ (ffebld expr)\n     num_elements = ffecom_integer_one_node;\n   else\n     {\n-      num_elements = size_binop (CEIL_DIV_EXPR,\n-\t\t\t\t TYPE_SIZE (TREE_TYPE (TREE_TYPE (variable))),\n-\t\t\t\t size);\n-      num_elements = size_binop (CEIL_DIV_EXPR,\n-\t\t\t\t num_elements,\n-\t\t\t\t size_int (TYPE_PRECISION\n-\t\t\t\t\t   (char_type_node)));\n+      num_elements\n+\t= size_binop (CEIL_DIV_EXPR,\n+\t\t      TYPE_SIZE_UNIT (TREE_TYPE (TREE_TYPE (variable))),\n+\t\t      convert (sizetype, size));\n+      num_elements = size_binop (CEIL_DIV_EXPR, num_elements,\n+\t\t\t\t size_int (TYPE_PRECISION (char_type_node)\n+\t\t\t\t\t   / BITS_PER_UNIT));\n       num_elements = convert (ffecom_f2c_ftnlen_type_node,\n \t\t\t      num_elements);\n     }\n@@ -1139,8 +1141,9 @@ ffeste_io_douio_ (ffebld expr)\n   if (size == NULL_TREE)\t/* Already filled in for CHARACTER type. */\n     {\t\t\t\t/* \"(ftnlen) sizeof(type)\" */\n       size = size_binop (CEIL_DIV_EXPR,\n-\t\t\t TYPE_SIZE (ffecom_tree_type[bt][kt]),\n-\t\t\t size_int (TYPE_PRECISION (char_type_node)));\n+\t\t\t TYPE_SIZE_UNIT (ffecom_tree_type[bt][kt]),\n+\t\t\t size_int (TYPE_PRECISION (char_type_node)\n+\t\t\t\t   / BITS_PER_UNIT));\n #if 0\t/* Assume that while it is possible that char * is wider than\n \t   ftnlen, no object in Fortran space can get big enough for its\n \t   size to be wider than ftnlen.  I really hope nobody wastes\n@@ -1157,12 +1160,13 @@ ffeste_io_douio_ (ffebld expr)\n       = is_complex ? ffecom_f2c_ftnlen_two_node : ffecom_f2c_ftnlen_one_node;\n   else\n     {\n-      num_elements = size_binop (CEIL_DIV_EXPR,\n-\t\t\t\t TYPE_SIZE (TREE_TYPE (TREE_TYPE (variable))),\n-\t\t\t\t size);\n+      num_elements\n+\t= size_binop (CEIL_DIV_EXPR,\n+\t\t      TYPE_SIZE_UNIT (TREE_TYPE (TREE_TYPE (variable))),\n+\t\t      convert (sizetype, size));\n       num_elements = size_binop (CEIL_DIV_EXPR, num_elements,\n-\t\t\t\t size_int (TYPE_PRECISION\n-\t\t\t\t\t   (char_type_node)));\n+\t\t\t\t size_int (TYPE_PRECISION (char_type_node)\n+\t\t\t\t\t   / BITS_PER_UNIT));\n       num_elements = convert (ffecom_f2c_ftnlen_type_node,\n \t\t\t      num_elements);\n     }\n@@ -1759,13 +1763,13 @@ ffeste_io_icilist_ (bool have_err,\n   else if (unitexp && unitlenexp)\n     {\n       /* An array, but all the info is constant, so compute now.  */\n-      unitnuminit = size_binop (CEIL_DIV_EXPR,\n-\t\t\t\tTYPE_SIZE (TREE_TYPE (TREE_TYPE (unitexp))),\n-\t\t\t\tunitlenexp);\n-      unitnuminit = size_binop (CEIL_DIV_EXPR,\n-\t\t\t\tunitnuminit,\n-\t\t\t\tsize_int (TYPE_PRECISION\n-\t\t\t\t\t  (char_type_node)));\n+      unitnuminit\n+\t= size_binop (CEIL_DIV_EXPR,\n+\t\t      TYPE_SIZE_UNIT (TREE_TYPE (TREE_TYPE (unitexp))),\n+\t\t      convert (sizetype, unitlenexp));\n+      unitnuminit = size_binop (CEIL_DIV_EXPR, unitnuminit,\n+\t\t\t\tsize_int (TYPE_PRECISION (char_type_node)\n+\t\t\t\t\t  / BITS_PER_UNIT));\n       unitnumexp = unitnuminit;\n     }\n   else\n@@ -1874,13 +1878,13 @@ ffeste_io_icilist_ (bool have_err,\n       && unitexp != error_mark_node\n       && unitlenexp != error_mark_node)\n     {\n-      unitnumexp = size_binop (CEIL_DIV_EXPR,\n-\t\t\t       TYPE_SIZE (TREE_TYPE (TREE_TYPE (unitexp))),\n-\t\t\t       unitlenexp);\n-      unitnumexp = size_binop (CEIL_DIV_EXPR,\n-\t\t\t       unitnumexp,\n-\t\t\t       size_int (TYPE_PRECISION\n-\t\t\t\t\t (char_type_node)));\n+      unitnumexp\n+\t= size_binop (CEIL_DIV_EXPR,\n+\t\t      TYPE_SIZE_UNIT (TREE_TYPE (TREE_TYPE (unitexp))),\n+\t\t      convert (sizetype, unitlenexp));\n+      unitnumexp = size_binop (CEIL_DIV_EXPR, unitnumexp,\n+\t\t\t       size_int (TYPE_PRECISION (char_type_node)\n+\t\t\t\t\t / BITS_PER_UNIT));\n       ffeste_f2c_compile_ (unitnumfield, unitnumexp);\n     }\n "}, {"sha": "24bf6f1af4adbc0f46bcee6f426ccc3d5f22b248", "filename": "gcc/fold-const.c", "status": "modified", "additions": 83, "deletions": 51, "changes": 134, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fed3cef0dbbd17e3d7b8860f42cd8490f0325340/gcc%2Ffold-const.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fed3cef0dbbd17e3d7b8860f42cd8490f0325340/gcc%2Ffold-const.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffold-const.c?ref=fed3cef0dbbd17e3d7b8860f42cd8490f0325340", "patch": "@@ -1559,13 +1559,8 @@ int_const_binop (code, arg1, arg2, notrunc, forsize)\n       abort ();\n     }\n \n-  if (TREE_TYPE (arg1) == sizetype && hi == 0\n-      && low >= 0\n-      && (TYPE_MAX_VALUE (sizetype) == NULL\n-\t  || low <= TREE_INT_CST_LOW (TYPE_MAX_VALUE (sizetype)))\n-      && ! overflow\n-      && ! TREE_OVERFLOW (arg1) && ! TREE_OVERFLOW (arg2))\n-    t = size_int (low);\n+  if (forsize && hi == 0 && low >= 0 && low < 1000)\n+    return size_int_type_wide (low, TREE_TYPE (arg1));\n   else\n     {\n       t = build_int_2 (low, hi);\n@@ -1797,19 +1792,25 @@ const_binop (code, arg1, arg2, notrunc)\n }\n \f\n /* Return an INTEGER_CST with value whose low-order HOST_BITS_PER_WIDE_INT\n-   bits are given by NUMBER.\n+   bits are given by NUMBER and of the sizetype represented by KIND.  */\n \n-   If BIT_P is nonzero, this represents a size in bit and the type of the\n-   result will be bitsizetype, othewise it represents a size in bytes and\n-   the type of the result will be sizetype.  */\n+tree\n+size_int_wide (number, kind)\n+     HOST_WIDE_INT number;\n+     enum size_type_kind kind;\n+{\n+  return size_int_type_wide (number, sizetype_tab[(int) kind]);\n+}\n+\n+/* Likewise, but the desired type is specified explicitly.  */\n \n tree\n-size_int_wide (number, bit_p)\n+size_int_type_wide (number, type)\n      HOST_WIDE_INT number;\n-     int bit_p;\n+     tree type;\n {\n   /* Type-size nodes already made for small sizes.  */\n-  static tree size_table[2 * HOST_BITS_PER_WIDE_INT + 1][2];\n+  static tree size_table[2 * HOST_BITS_PER_WIDE_INT + 1];\n   static int init_p = 0;\n   tree t;\n   \n@@ -1826,8 +1827,10 @@ size_int_wide (number, bit_p)\n   if (number >= 0\n       && number < (int) (sizeof size_table / sizeof size_table[0]) / 2)\n     {\n-      if (size_table[number][bit_p] != 0)\n-\treturn size_table[number][bit_p];\n+      if (size_table[number] != 0)\n+\tfor (t = size_table[number]; t != 0; t = TREE_CHAIN (t))\n+\t  if (TREE_TYPE (t) == type)\n+\t    return t;\n \n       if (! ggc_p)\n \t{\n@@ -1837,30 +1840,38 @@ size_int_wide (number, bit_p)\n \t}\n \n       t = build_int_2 (number, 0);\n-      TREE_TYPE (t) = bit_p ? bitsizetype : sizetype;\n-      size_table[number][bit_p] = t;\n+      TREE_TYPE (t) = type;\n+      TREE_CHAIN (t) = size_table[number];\n+      size_table[number] = t;\n \n       if (! ggc_p)\n \tpop_obstacks ();\n \n       return t;\n     }\n \n-  t = build_int_2 (number, 0);\n-  TREE_TYPE (t) = bit_p ? bitsizetype : sizetype;\n+  t = build_int_2 (number, number < 0 ? -1 : 0);\n+  TREE_TYPE (t) = type;\n   TREE_OVERFLOW (t) = TREE_CONSTANT_OVERFLOW (t) = force_fit_type (t, 0);\n   return t;\n }\n \n-/* Combine operands OP1 and OP2 with arithmetic operation CODE.\n-   CODE is a tree code.  Data type is taken from `sizetype',\n+/* Combine operands OP1 and OP2 with arithmetic operation CODE.  CODE\n+   is a tree code.  The type of the result is taken from the operands.\n+   Both must be the same type integer type and it must be a size type.\n    If the operands are constant, so is the result.  */\n \n tree\n size_binop (code, arg0, arg1)\n      enum tree_code code;\n      tree arg0, arg1;\n {\n+  tree type = TREE_TYPE (arg0);\n+\n+  if (type != TREE_TYPE (arg1)\n+      || TREE_CODE (type) != INTEGER_TYPE || ! TYPE_IS_SIZETYPE (type))\n+    abort ();\n+\n   /* Handle the special case of two integer constants faster.  */\n   if (TREE_CODE (arg0) == INTEGER_CST && TREE_CODE (arg1) == INTEGER_CST)\n     {\n@@ -1880,41 +1891,49 @@ size_binop (code, arg0, arg1)\n   if (arg0 == error_mark_node || arg1 == error_mark_node)\n     return error_mark_node;\n \n-  return fold (build (code, sizetype, arg0, arg1));\n+  return fold (build (code, type, arg0, arg1));\n }\n \n-/* Combine operands OP1 and OP2 with arithmetic operation CODE.\n-   CODE is a tree code.  Data type is taken from `ssizetype',\n-   If the operands are constant, so is the result.  */\n+/* Given two values, either both of sizetype or both of bitsizetype,\n+   compute the difference between the two values.  Return the value\n+   in signed type corresponding to the type of the operands.  */\n \n tree\n-ssize_binop (code, arg0, arg1)\n-     enum tree_code code;\n+size_diffop (arg0, arg1)\n      tree arg0, arg1;\n {\n-  /* Handle the special case of two integer constants faster.  */\n-  if (TREE_CODE (arg0) == INTEGER_CST && TREE_CODE (arg1) == INTEGER_CST)\n-    {\n-      /* And some specific cases even faster than that.  */\n-      if (code == PLUS_EXPR && integer_zerop (arg0))\n-\treturn arg1;\n-      else if ((code == MINUS_EXPR || code == PLUS_EXPR)\n-\t       && integer_zerop (arg1))\n-\treturn arg0;\n-      else if (code == MULT_EXPR && integer_onep (arg0))\n-\treturn arg1;\n+  tree type = TREE_TYPE (arg0);\n+  tree ctype;\n \n-      /* Handle general case of two integer constants.  We convert\n-         arg0 to ssizetype because int_const_binop uses its type for the\n-\t return value.  */\n-      arg0 = convert (ssizetype, arg0);\n-      return int_const_binop (code, arg0, arg1, 0, 0);\n-    }\n-\n-  if (arg0 == error_mark_node || arg1 == error_mark_node)\n-    return error_mark_node;\n+  if (TREE_TYPE (arg1) != type || TREE_CODE (type) != INTEGER_TYPE\n+      || ! TYPE_IS_SIZETYPE (type))\n+    abort ();\n \n-  return fold (build (code, ssizetype, arg0, arg1));\n+  /* If the type is already signed, just do the simple thing.  */\n+  if (! TREE_UNSIGNED (type))\n+    return size_binop (MINUS_EXPR, arg0, arg1);\n+\n+  ctype = (type == bitsizetype || type == ubitsizetype\n+\t   ? sbitsizetype : ssizetype);\n+\n+  /* If either operand is not a constant, do the conversions to the signed\n+     type and subtract.  The hardware will do the right thing with any\n+     overflow in the subtraction.  */\n+  if (TREE_CODE (arg0) != INTEGER_CST || TREE_CODE (arg1) != INTEGER_CST)\n+    return size_binop (MINUS_EXPR, convert (ctype, arg0),\n+\t\t       convert (ctype, arg1));\n+\n+  /* If ARG0 is larger than ARG1, subtract and return the result in CTYPE.\n+     Otherwise, subtract the other way, convert to CTYPE (we know that can't\n+     overflow) and negate (which can't either).  Special-case a result\n+     of zero while we're here.  */\n+  if (tree_int_cst_equal (arg0, arg1))\n+    return convert (ctype, integer_zero_node);\n+  else if (tree_int_cst_lt (arg1, arg0))\n+    return convert (ctype, size_binop (MINUS_EXPR, arg0, arg1));\n+  else\n+    return size_binop (MINUS_EXPR, convert (ctype, integer_zero_node),\n+\t\t       convert (ctype, size_binop (MINUS_EXPR, arg1, arg0)));\n }\n \f\n /* This structure is used to communicate arguments to fold_convert_1.  */\n@@ -1959,6 +1978,14 @@ fold_convert (t, arg1)\n \t  if (TYPE_PRECISION (type) > 2 * HOST_BITS_PER_WIDE_INT)\n \t    return t;\n \n+\t  /* If we are trying to make a sizetype for a small integer, use\n+\t     size_int to pick up cached types to reduce duplicate nodes.  */\n+\t  if (TREE_CODE (type) == INTEGER_CST && TYPE_IS_SIZETYPE (type)\n+\t      && TREE_INT_CST_HIGH (arg1) == 0\n+\t      && TREE_INT_CST_LOW (arg1) >= 0\n+\t      && TREE_INT_CST_LOW (arg1) < 1000)\n+\t    return size_int_type_wide (TREE_INT_CST_LOW (arg1), type);\n+\n \t  /* Given an integer constant, make new constant with new type,\n \t     appropriately sign-extended or truncated.  */\n \t  t = build_int_2 (TREE_INT_CST_LOW (arg1),\n@@ -4471,8 +4498,13 @@ extract_muldiv (t, c, code, wide_type)\n       /* If these operations \"cancel\" each other, we have the main\n \t optimizations of this pass, which occur when either constant is a\n \t multiple of the other, in which case we replace this with either an\n-\t operation or CODE or TCODE.  */\n-      if ((code == MULT_EXPR && tcode == EXACT_DIV_EXPR)\n+\t operation or CODE or TCODE.  If we have an unsigned type that is\n+\t not a sizetype, we canot do this for division since it will change\n+\t the result if the original computation overflowed.  */\n+      if ((code == MULT_EXPR && tcode == EXACT_DIV_EXPR\n+\t   && (! TREE_UNSIGNED (ctype)\n+\t       || (TREE_CODE (ctype) == INTEGER_TYPE\n+\t\t   && TYPE_IS_SIZETYPE (ctype))))\n \t  || (tcode == MULT_EXPR\n \t      && code != TRUNC_MOD_EXPR && code != CEIL_MOD_EXPR\n \t      && code != FLOOR_MOD_EXPR && code != ROUND_MOD_EXPR))"}, {"sha": "dae6996f8ac8619d0e17bb372c0f191faf8dbf37", "filename": "gcc/function.c", "status": "modified", "additions": 15, "deletions": 28, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fed3cef0dbbd17e3d7b8860f42cd8490f0325340/gcc%2Ffunction.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fed3cef0dbbd17e3d7b8860f42cd8490f0325340/gcc%2Ffunction.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffunction.c?ref=fed3cef0dbbd17e3d7b8860f42cd8490f0325340", "patch": "@@ -4835,8 +4835,8 @@ assign_parms (fndecl)\n #ifdef ARGS_GROW_DOWNWARD\n   current_function_arg_offset_rtx\n     = (stack_args_size.var == 0 ? GEN_INT (-stack_args_size.constant)\n-       : expand_expr (size_binop (MINUS_EXPR, stack_args_size.var,\t\n-\t\t\t\t  size_int (-stack_args_size.constant)),   \n+       : expand_expr (size_diffop (stack_args_size.var,\t\n+\t\t\t\t   size_int (-stack_args_size.constant)),   \n \t\t      NULL_RTX, VOIDmode, EXPAND_MEMORY_USE_BAD));\n #else\n   current_function_arg_offset_rtx = ARGS_SIZE_RTX (stack_args_size);\n@@ -4968,7 +4968,7 @@ locate_and_pad_parm (passed_mode, type, in_regs, fndecl,\n \t    {\n \t      initial_offset_ptr->var\n \t\t= size_binop (MAX_EXPR, ARGS_SIZE_TREE (*initial_offset_ptr),\n-\t\t\t      size_int (reg_parm_stack_space));\n+\t\t\t      ssize_int (reg_parm_stack_space));\n \t      initial_offset_ptr->constant = 0;\n \t    }\n \t  else if (initial_offset_ptr->constant < reg_parm_stack_space)\n@@ -4984,7 +4984,7 @@ locate_and_pad_parm (passed_mode, type, in_regs, fndecl,\n   if (initial_offset_ptr->var)\n     {\n       offset_ptr->constant = 0;\n-      offset_ptr->var = size_binop (MINUS_EXPR, integer_zero_node,\n+      offset_ptr->var = size_binop (MINUS_EXPR, ssize_int (0),\n \t\t\t\t    initial_offset_ptr->var);\n     }\n   else\n@@ -5000,18 +5000,16 @@ locate_and_pad_parm (passed_mode, type, in_regs, fndecl,\n   if (where_pad != downward)\n     pad_to_arg_alignment (offset_ptr, boundary, alignment_pad);\n   if (initial_offset_ptr->var)\n-    {\n-      arg_size_ptr->var = size_binop (MINUS_EXPR,\n-\t\t\t\t      size_binop (MINUS_EXPR,\n-\t\t\t\t\t\t  integer_zero_node,\n-\t\t\t\t\t\t  initial_offset_ptr->var),\n-\t\t\t\t      offset_ptr->var);\n-    }\n+    arg_size_ptr->var = size_binop (MINUS_EXPR,\n+\t\t\t\t    size_binop (MINUS_EXPR,\n+\t\t\t\t\t\tssize_int (0),\n+\t\t\t\t\t\tinitial_offset_ptr->var),\n+\t\t\t\t    offset_ptr->var);\n+\n   else\n-    {\n-      arg_size_ptr->constant = (- initial_offset_ptr->constant\n-\t\t\t\t- offset_ptr->constant); \n-    }\n+    arg_size_ptr->constant = (- initial_offset_ptr->constant\n+\t\t\t      - offset_ptr->constant); \n+\n #else /* !ARGS_GROW_DOWNWARD */\n   pad_to_arg_alignment (initial_offset_ptr, boundary, alignment_pad);\n   *offset_ptr = *initial_offset_ptr;\n@@ -5075,7 +5073,8 @@ pad_to_arg_alignment (offset_ptr, boundary, alignment_pad)\n \t       boundary / BITS_PER_UNIT);\n \t  offset_ptr->constant = 0; /*?*/\n           if (boundary > PARM_BOUNDARY && boundary > STACK_BOUNDARY)\n-            alignment_pad->var = size_binop (MINUS_EXPR, offset_ptr->var, save_var);\n+            alignment_pad->var = size_binop (MINUS_EXPR, offset_ptr->var,\n+\t\t\t\t\t     save_var);\n \t}\n       else\n         {\n@@ -5120,18 +5119,6 @@ pad_below (offset_ptr, passed_mode, sizetree)\n     }\n }\n #endif\n-\n-#ifdef ARGS_GROW_DOWNWARD\n-static tree\n-round_down (value, divisor)\n-     tree value;\n-     int divisor;\n-{\n-  return size_binop (MULT_EXPR,\n-\t\t     size_binop (FLOOR_DIV_EXPR, value, size_int (divisor)),\n-\t\t     size_int (divisor));\n-}\n-#endif\n \f\n /* Walk the tree of blocks describing the binding levels within a function\n    and warn about uninitialized variables."}, {"sha": "31b6090b709f755686fcbd720946b37101fea8b4", "filename": "gcc/java/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fed3cef0dbbd17e3d7b8860f42cd8490f0325340/gcc%2Fjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fed3cef0dbbd17e3d7b8860f42cd8490f0325340/gcc%2Fjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2FChangeLog?ref=fed3cef0dbbd17e3d7b8860f42cd8490f0325340", "patch": "@@ -1,3 +1,7 @@\n+Sun Feb 27 16:40:33 2000  Richard Kenner  <kenner@vlsi1.ultra.nyu.edu>\n+\n+\t* expr.c (build_java_ret): Pass proper type to size_binop.\n+\n 2000-02-25  Anthony Green  <green@cygnus.com>\n \n \t* expr.c (build_class_init): Mark the decl to be ignored by"}, {"sha": "e32b6a9644ed0ffc7d0507eab2882c7599e4d34d", "filename": "gcc/java/expr.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fed3cef0dbbd17e3d7b8860f42cd8490f0325340/gcc%2Fjava%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fed3cef0dbbd17e3d7b8860f42cd8490f0325340/gcc%2Fjava%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fexpr.c?ref=fed3cef0dbbd17e3d7b8860f42cd8490f0325340", "patch": "@@ -579,7 +579,7 @@ build_java_ret (location)\n   size_binop (CEIL_DIV_EXPR, \t\t\t\t\t\t   \\\n \t      (DECL_FIELD_BITPOS\t\t\t\t\t   \\\n \t\t  (TREE_CHAIN (TYPE_FIELDS (TREE_TYPE (TREE_TYPE (A)))))), \\\n-              size_int (BITS_PER_UNIT))\n+              bitsize_int (BITS_PER_UNIT))\n \n tree\n decode_newarray_type (atype)"}, {"sha": "b86a42290cc2efafc70cfe2640e17a6a4cc95bed", "filename": "gcc/stor-layout.c", "status": "modified", "additions": 113, "deletions": 62, "changes": 175, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fed3cef0dbbd17e3d7b8860f42cd8490f0325340/gcc%2Fstor-layout.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fed3cef0dbbd17e3d7b8860f42cd8490f0325340/gcc%2Fstor-layout.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fstor-layout.c?ref=fed3cef0dbbd17e3d7b8860f42cd8490f0325340", "patch": "@@ -31,10 +31,16 @@ Boston, MA 02111-1307, USA.  */\n #include \"toplev.h\"\n #include \"ggc.h\"\n \n+/* Set to one when set_sizetype has been called.  */\n+static int sizetype_set;\n+\n+/* List of types created before set_sizetype has been called.  We do not\n+   make this a GGC root since we want these nodes to be reclaimed.  */\n+static tree early_type_list;\n+\n /* Data type for the expressions representing sizes of data types.\n    It is the first integer type laid out.  */\n-\n-struct sizetype_tab sizetype_tab;\n+tree sizetype_tab[(int) TYPE_KIND_LAST];\n \n /* If nonzero, this is an upper limit on alignment of structure fields.\n    The value is measured in bits.  */\n@@ -114,7 +120,7 @@ variable_size (size)\n       else\n \terror (\"variable-size type declared outside of any function\");\n \n-      return size_int (1);\n+      return size_one_node;\n     }\n \n   if (immediate_size_expand)\n@@ -214,16 +220,29 @@ int_mode_for_mode (mode)\n   return mode;\n }\n \n-/* Return the value of VALUE, rounded up to a multiple of DIVISOR.  */\n+/* Return the value of VALUE, rounded up to a multiple of DIVISOR.\n+   This can only be applied to objects of a sizetype.  */\n \n tree\n round_up (value, divisor)\n      tree value;\n      int divisor;\n {\n-  return size_binop (MULT_EXPR,\n-\t\t     size_binop (CEIL_DIV_EXPR, value, size_int (divisor)),\n-\t\t     size_int (divisor));\n+  tree arg = size_int_type (divisor, TREE_TYPE (value));\n+\n+  return size_binop (MULT_EXPR, size_binop (CEIL_DIV_EXPR, value, arg), arg);\n+}\n+\n+/* Likewise, but round down.  */\n+\n+tree\n+round_down (value, divisor)\n+     tree value;\n+     int divisor;\n+{\n+  tree arg = size_int_type (divisor, TREE_TYPE (value));\n+\n+  return size_binop (MULT_EXPR, size_binop (FLOOR_DIV_EXPR, value, arg), arg);\n }\n \f\n /* Set the size, mode and alignment of a ..._DECL node.\n@@ -632,8 +651,8 @@ layout_record (rec)\n   else\n     {\n       if (const_size)\n-\tvar_size\n-\t  = size_binop (PLUS_EXPR, var_size, bitsize_int (const_size));\n+\tvar_size = size_binop (PLUS_EXPR, var_size, bitsize_int (const_size));\n+\n       TYPE_SIZE (rec) = var_size;\n     }\n \n@@ -652,7 +671,7 @@ layout_record (rec)\n       TYPE_BINFO_SIZE_UNIT (rec)\n \t= convert (sizetype,\n \t\t   size_binop (FLOOR_DIV_EXPR, TYPE_SIZE (rec),\n-\t\t\t       size_int (BITS_PER_UNIT)));\n+\t\t\t       bitsize_int (BITS_PER_UNIT)));\n     }\n   \n   {\n@@ -964,8 +983,10 @@ layout_type (type)\n \t    /* The initial subtraction should happen in the original type so\n \t       that (possible) negative values are handled appropriately.  */\n \t    length = size_binop (PLUS_EXPR, size_one_node,\n-\t\t\t\t fold (build (MINUS_EXPR, TREE_TYPE (lb),\n-\t\t\t\t\t      ub, lb)));\n+\t\t\t\t convert (sizetype,\n+\t\t\t\t\t  fold (build (MINUS_EXPR,\n+\t\t\t\t\t\t       TREE_TYPE (lb),\n+\t\t\t\t\t\t       ub, lb))));\n \n \t    /* If neither bound is a constant and sizetype is signed, make\n \t       sure the size is never negative.  We should really do this\n@@ -990,7 +1011,8 @@ layout_type (type)\n \t\t  element_size = integer_one_node;\n \t      }\n \n-\t    TYPE_SIZE (type) = size_binop (MULT_EXPR, element_size, length);\n+\t    TYPE_SIZE (type) = size_binop (MULT_EXPR, element_size,\n+\t\t\t\t\t   convert (bitsizetype, length));\n \n \t    /* If we know the size of the element, calculate the total\n \t       size directly, rather than do some division thing below.\n@@ -1000,8 +1022,7 @@ layout_type (type)\n \t       Note that we can't do this in the case where the size of\n \t       the elements is one bit since TYPE_SIZE_UNIT cannot be\n \t       set correctly in that case.  */\n-\t    if (TYPE_SIZE_UNIT (element) != 0\n-\t\t&& element_size != integer_one_node)\n+\t    if (TYPE_SIZE_UNIT (element) != 0 && ! integer_onep (element_size))\n \t      TYPE_SIZE_UNIT (type)\n \t\t= size_binop (MULT_EXPR, TYPE_SIZE_UNIT (element), length);\n \t  }\n@@ -1254,7 +1275,7 @@ layout_type (type)\n     TYPE_SIZE_UNIT (type)\n       = convert (sizetype,\n \t\t size_binop (FLOOR_DIV_EXPR, TYPE_SIZE (type),\n-\t\t\t     size_int (BITS_PER_UNIT)));\n+\t\t\t     bitsize_int (BITS_PER_UNIT)));\n \n   /* Once again evaluate only once, either now or as soon as safe.  */\n   if (TYPE_SIZE_UNIT (type) != 0\n@@ -1286,6 +1307,14 @@ layout_type (type)\n \t\n   pop_obstacks ();\n   resume_momentary (old);\n+\n+  /* If this type is created before sizetype has been permanently set,\n+     record it so set_sizetype can fix it up.  */\n+  if (! sizetype_set)\n+    {\n+      TREE_CHAIN (type) = early_type_list;\n+      early_type_list = type;\n+    }\n }\n \f\n /* Create and return a type for signed integers of PRECISION bits.  */\n@@ -1298,35 +1327,7 @@ make_signed_type (precision)\n \n   TYPE_PRECISION (type) = precision;\n \n-  /* Create the extreme values based on the number of bits.  */\n-\n-  TYPE_MIN_VALUE (type)\n-    = build_int_2 ((precision - HOST_BITS_PER_WIDE_INT > 0\n-\t\t    ? 0 : (HOST_WIDE_INT) (-1) << (precision - 1)),\n-\t\t   (((HOST_WIDE_INT) (-1)\n-\t\t     << (precision - HOST_BITS_PER_WIDE_INT - 1 > 0\n-\t\t\t ? precision - HOST_BITS_PER_WIDE_INT - 1\n-\t\t\t : 0))));\n-  TYPE_MAX_VALUE (type)\n-    = build_int_2 ((precision - HOST_BITS_PER_WIDE_INT > 0\n-\t\t    ? -1 : ((HOST_WIDE_INT) 1 << (precision - 1)) - 1),\n-\t\t   (precision - HOST_BITS_PER_WIDE_INT - 1 > 0\n-\t\t    ? (((HOST_WIDE_INT) 1\n-\t\t\t<< (precision - HOST_BITS_PER_WIDE_INT - 1))) - 1\n-\t\t    : 0));\n-\n-  /* Give this type's extreme values this type as their type.  */\n-\n-  TREE_TYPE (TYPE_MIN_VALUE (type)) = type;\n-  TREE_TYPE (TYPE_MAX_VALUE (type)) = type;\n-\n-  /* The first type made with this or `make_unsigned_type'\n-     is the type for size values.  */\n-  if (sizetype == 0)\n-    set_sizetype (type);\n-\n-  /* Lay out the type: set its alignment, size, etc.  */\n-  layout_type (type);\n+  fixup_signed_type (type);\n   return type;\n }\n \n@@ -1340,18 +1341,40 @@ make_unsigned_type (precision)\n \n   TYPE_PRECISION (type) = precision;\n \n-  /* The first type made with this or `make_signed_type'\n-     is the type for size values.  */\n-\n-  if (sizetype == 0)\n-    {\n-      TREE_UNSIGNED (type) = 1;\n-      set_sizetype (type);\n-    }\n-\n   fixup_unsigned_type (type);\n   return type;\n }\n+\f\n+/* Initialize sizetype and bitsizetype to a reasonable and temporary\n+   value to enable integer types to be created.  */\n+\n+void\n+initialize_sizetypes ()\n+{\n+  tree t = make_node (INTEGER_TYPE);\n+\n+  /* Set this so we do something reasonable for the build_int_2 calls\n+     below.  */\n+  integer_type_node = t;\n+\n+  TYPE_MODE (t) = SImode;\n+  TYPE_ALIGN (t) = GET_MODE_ALIGNMENT (SImode);\n+  TYPE_SIZE (t) = build_int_2 (GET_MODE_BITSIZE (SImode), 0);\n+  TYPE_SIZE_UNIT (t) = build_int_2 (GET_MODE_SIZE (SImode), 0);\n+  TREE_UNSIGNED (t) = 1;\n+  TYPE_PRECISION (t) = GET_MODE_BITSIZE (SImode);\n+  TYPE_MIN_VALUE (t) = build_int_2 (0, 0);\n+\n+  /* 1000 avoids problems with possible overflow and is certainly\n+     larger than any size value we'd want to be storing.  */\n+  TYPE_MAX_VALUE (t) = build_int_2 (1000, 0);\n+\n+  /* These two must be different nodes because of the caching done in\n+     size_int_wide.  */\n+  sizetype = t;\n+  bitsizetype = copy_node (t);\n+  integer_type_node = 0;\n+}\n \n /* Set sizetype to TYPE, and initialize *sizetype accordingly.\n    Also update the type of any standard type's sizes made so far.  */\n@@ -1367,8 +1390,14 @@ set_sizetype (type)\n      precision.  */\n   int precision = MIN (oprecision + BITS_PER_UNIT_LOG + 1,\n \t\t       2 * HOST_BITS_PER_WIDE_INT);\n+  unsigned int i;\n+  tree t, next;\n+\n+  if (sizetype_set)\n+    abort ();\n \n-  sizetype = type;\n+  /* Make copies of nodes since we'll be setting TYPE_IS_SIZETYPE.  */\n+  sizetype = copy_node (type);\n   bitsizetype = make_node (INTEGER_TYPE);\n   TYPE_NAME (bitsizetype) = TYPE_NAME (type);\n   TYPE_PRECISION (bitsizetype) = precision;\n@@ -1384,22 +1413,43 @@ set_sizetype (type)\n     {\n       usizetype = sizetype;\n       ubitsizetype = bitsizetype;\n-      ssizetype = make_signed_type (oprecision);\n-      sbitsizetype = make_signed_type (precision);\n+      ssizetype = copy_node (make_signed_type (oprecision));\n+      sbitsizetype = copy_node (make_signed_type (precision));\n     }\n   else\n     {\n       ssizetype = sizetype;\n       sbitsizetype = bitsizetype;\n-      usizetype = make_unsigned_type (oprecision);\n-      ubitsizetype = make_unsigned_type (precision);\n+      usizetype = copy_node (make_unsigned_type (oprecision));\n+      ubitsizetype = copy_node (make_unsigned_type (precision));\n     }\n-  TYPE_NAME (bitsizetype) = TYPE_NAME (sizetype);\n+\n+  TYPE_NAME (bitsizetype) = get_identifier (\"bit_size_type\");\n+\n+  for (i = 0; i < sizeof sizetype_tab / sizeof sizetype_tab[0]; i++)\n+    TYPE_IS_SIZETYPE (sizetype_tab[i]) = 1;\n \n   ggc_add_tree_root ((tree *) &sizetype_tab,\n \t\t     sizeof sizetype_tab / sizeof (tree));\n-}\n \n+  /* Go down each of the types we already made and set the proper type\n+     for the sizes in them.  */\n+  for (t = early_type_list; t != 0; t = next)\n+    {\n+      next = TREE_CHAIN (t);\n+      TREE_CHAIN (t) = 0;\n+\n+      if (TREE_CODE (t) != INTEGER_TYPE)\n+\tabort ();\n+\n+      TREE_TYPE (TYPE_SIZE (t)) = bitsizetype;\n+      TREE_TYPE (TYPE_SIZE_UNIT (t)) = sizetype;\n+    }\n+\n+  early_type_list = 0;\n+  sizetype_set = 1;\n+}\n+\f\n /* Set the extreme values of TYPE based on its precision in bits,\n    then lay it out.  Used when make_signed_type won't do\n    because the tree code is not INTEGER_TYPE.\n@@ -1531,7 +1581,8 @@ get_best_mode (bitsize, bitpos, align, largest_mode, volatilep)\n /* Return the alignment of MODE. This will be bounded by 1 and\n    BIGGEST_ALIGNMENT.  */\n \n-unsigned get_mode_alignment (mode)\n+unsigned int\n+get_mode_alignment (mode)\n      enum machine_mode mode;\n {\n   unsigned alignment = GET_MODE_UNIT_SIZE (mode);"}, {"sha": "708b8d74c0eb93e04c66427623d245d4ebe0a412", "filename": "gcc/tm.texi", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fed3cef0dbbd17e3d7b8860f42cd8490f0325340/gcc%2Ftm.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fed3cef0dbbd17e3d7b8860f42cd8490f0325340/gcc%2Ftm.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftm.texi?ref=fed3cef0dbbd17e3d7b8860f42cd8490f0325340", "patch": "@@ -1,4 +1,5 @@\n-@c Copyright (C) 1988,1989,1992,1993,1994,1995,1996,1997,1998,1999,2000 Free Software Foundation, Inc.\n+@c Copyright (C) 1988,1989,1992,1993,1994,1995,1996,1997,1998,1999,2000\n+@c Free Software Foundation, Inc.\n @c This is part of the GCC manual.\n @c For copying conditions, see the file gcc.texi.\n \n@@ -1001,6 +1002,13 @@ usual way is @var{computed} and the alignment is @var{specified}.\n \n The default is to round @var{computed} up to a multiple of @var{specified}.\n \n+@findex ROUND_TYPE_SIZE_UNIT\n+@item ROUND_TYPE_SIZE_UNIT (@var{type}, @var{computed}, @var{specified})\n+Similar to @code{ROUND_TYPE_SIZE}, but sizes and alignments are\n+specified in units (bytes).  If you define @code{ROUND_TYPE_SIZE},\n+you must also define this macro and they must be defined consistently\n+with each other.\n+\n @findex ROUND_TYPE_ALIGN\n @item ROUND_TYPE_ALIGN (@var{type}, @var{computed}, @var{specified})\n Define this macro as an expression for the alignment of a type (given"}, {"sha": "99e7ee12ed3960df8571ec76b55a8dc59ebb63f8", "filename": "gcc/tree.c", "status": "modified", "additions": 3, "deletions": 40, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fed3cef0dbbd17e3d7b8860f42cd8490f0325340/gcc%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fed3cef0dbbd17e3d7b8860f42cd8490f0325340/gcc%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.c?ref=fed3cef0dbbd17e3d7b8860f42cd8490f0325340", "patch": "@@ -276,7 +276,6 @@ static void build_real_from_int_cst_1 PARAMS ((PTR));\n static void set_type_quals PARAMS ((tree, int));\n static void append_random_chars PARAMS ((char *));\n static void mark_type_hash PARAMS ((void *));\n-static void fix_sizetype PARAMS ((tree));\n \n /* If non-null, these are language-specific helper functions for\n    unsave_expr_now.  If present, LANG_UNSAVE is called before its\n@@ -5387,6 +5386,8 @@ build_common_tree_nodes (signed_char)\n   error_mark_node = make_node (ERROR_MARK);\n   TREE_TYPE (error_mark_node) = error_mark_node;\n \n+  initialize_sizetypes ();\n+\n   /* Define both `signed char' and `unsigned char'.  */\n   signed_char_type_node = make_signed_type (CHAR_TYPE_SIZE);\n   unsigned_char_type_node = make_unsigned_type (CHAR_TYPE_SIZE);\n@@ -5401,10 +5402,6 @@ build_common_tree_nodes (signed_char)\n   short_integer_type_node = make_signed_type (SHORT_TYPE_SIZE);\n   short_unsigned_type_node = make_unsigned_type (SHORT_TYPE_SIZE);\n   integer_type_node = make_signed_type (INT_TYPE_SIZE);\n-  /* Define an unsigned integer first.  make_unsigned_type and make_signed_type\n-     both call set_sizetype for the first type that we create, and we want this\n-     to be large enough to hold the sizes of various types until we switch to\n-     the real sizetype.  */\n   unsigned_type_node = make_unsigned_type (INT_TYPE_SIZE);\n   long_integer_type_node = make_signed_type (LONG_TYPE_SIZE);\n   long_unsigned_type_node = make_unsigned_type (LONG_TYPE_SIZE);\n@@ -5424,47 +5421,13 @@ build_common_tree_nodes (signed_char)\n   unsigned_intTI_type_node = make_unsigned_type (GET_MODE_BITSIZE (TImode));\n }\n \n-/* For type TYPE, fill in the proper type for TYPE_SIZE and TYPE_SIZE_UNIT.  */\n-\n-static void\n-fix_sizetype (type)\n-     tree type;\n-{\n-  TREE_TYPE (TYPE_SIZE (type)) = bitsizetype;\n-  TREE_TYPE (TYPE_SIZE_UNIT (type)) = sizetype;\n-}\n-\n /* Call this function after calling build_common_tree_nodes and set_sizetype.\n-   It will fix the previously made nodes to have proper references to\n-   sizetype, and it will create several other common tree nodes.  */\n+   It will create several other common tree nodes.  */\n \n void\n build_common_tree_nodes_2 (short_double)\n      int short_double;\n {\n-  fix_sizetype (signed_char_type_node);\n-  fix_sizetype (unsigned_char_type_node);\n-  fix_sizetype (char_type_node);\n-  fix_sizetype (short_integer_type_node);\n-  fix_sizetype (short_unsigned_type_node);\n-  fix_sizetype (integer_type_node);\n-  fix_sizetype (unsigned_type_node);\n-  fix_sizetype (long_unsigned_type_node);\n-  fix_sizetype (long_integer_type_node);\n-  fix_sizetype (long_long_integer_type_node);\n-  fix_sizetype (long_long_unsigned_type_node);\n-\n-  fix_sizetype (intQI_type_node);\n-  fix_sizetype (intHI_type_node);\n-  fix_sizetype (intSI_type_node);\n-  fix_sizetype (intDI_type_node);\n-  fix_sizetype (intTI_type_node);\n-  fix_sizetype (unsigned_intQI_type_node);\n-  fix_sizetype (unsigned_intHI_type_node);\n-  fix_sizetype (unsigned_intSI_type_node);\n-  fix_sizetype (unsigned_intDI_type_node);\n-  fix_sizetype (unsigned_intTI_type_node);\n-\n   integer_zero_node = build_int_2 (0, 0);\n   TREE_TYPE (integer_zero_node) = integer_type_node;\n   integer_one_node = build_int_2 (1, 0);"}, {"sha": "27737dcc123bd8db7efdbb59687509ae02e85d0b", "filename": "gcc/tree.h", "status": "modified", "additions": 38, "deletions": 20, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fed3cef0dbbd17e3d7b8860f42cd8490f0325340/gcc%2Ftree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fed3cef0dbbd17e3d7b8860f42cd8490f0325340/gcc%2Ftree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.h?ref=fed3cef0dbbd17e3d7b8860f42cd8490f0325340", "patch": "@@ -874,6 +874,11 @@ struct tree_block\n    its size.  */\n #define TYPE_NO_FORCE_BLK(NODE) (TYPE_CHECK (NODE)->type.no_force_blk_flag)\n \n+/* In an INTEGER_TYPE, it means the type represents a size.  We use this\n+   both for validity checking and to permit optimziations that are unsafe\n+   for other types.  */\n+#define TYPE_IS_SIZETYPE(NODE) (TYPE_CHECK (NODE)->type.no_force_blk_flag)\n+\n /* Nonzero in a type considered volatile as a whole.  */\n #define TYPE_VOLATILE(NODE) ((NODE)->common.volatile_flag)\n \n@@ -1657,6 +1662,7 @@ extern tree build_expr_wfl              PARAMS ((tree, const char *, int, int));\n \n extern tree make_signed_type\t\tPARAMS ((int));\n extern tree make_unsigned_type\t\tPARAMS ((int));\n+extern void initialize_sizetypes\tPARAMS ((void));\n extern void set_sizetype\t\tPARAMS ((tree));\n extern tree signed_or_unsigned_type \tPARAMS ((int, tree));\n extern void fixup_unsigned_type\t\tPARAMS ((tree));\n@@ -1784,12 +1790,40 @@ extern tree convert\t\t\tPARAMS ((tree, tree));\n extern unsigned int expr_align\t\tPARAMS ((tree));\n extern tree size_in_bytes\t\tPARAMS ((tree));\n extern HOST_WIDE_INT int_size_in_bytes\tPARAMS ((tree));\n+\n+/* Define data structures, macros, and functions for handling sizes\n+   and the various types used to represent sizes.  */\n+\n+enum size_type_kind\n+{\n+  SIZETYPE,\t\t/* Normal representation of sizes in bytes. */\n+  SSIZETYPE,\t\t/* Signed representation of sizes in bytes. */\n+  USIZETYPE,\t\t/* Unsigned representation of sizes in bytes.  */\n+  BITSIZETYPE,\t\t/* Normal representation of sizes in bits.  */\n+  SBITSIZETYPE,\t\t/* Signed representation of sizes in bits.  */\n+  UBITSIZETYPE,\t        /* Unsifgned representation of sizes in bits.  */\n+  TYPE_KIND_LAST};\n+\n+extern tree sizetype_tab[(int) TYPE_KIND_LAST];\n+\n+#define sizetype sizetype_tab[(int) SIZETYPE]\n+#define bitsizetype sizetype_tab[(int) BITSIZETYPE]\n+#define ssizetype sizetype_tab[(int) SSIZETYPE]\n+#define usizetype sizetype_tab[(int) USIZETYPE]\n+#define sbitsizetype sizetype_tab[(int) SBITSIZETYPE]\n+#define ubitsizetype sizetype_tab[(int) UBITSIZETYPE]\n+\n extern tree size_binop\t\t\tPARAMS ((enum tree_code, tree, tree));\n-extern tree ssize_binop\t\t\tPARAMS ((enum tree_code, tree, tree));\n-extern tree size_int_wide\t\tPARAMS ((HOST_WIDE_INT, int));\n+extern tree size_diffop\t\t\tPARAMS ((tree, tree));\n+extern tree size_int_wide\t\tPARAMS ((HOST_WIDE_INT,\n+\t\t\t\t\t\t enum size_type_kind));\n+extern tree size_int_type_wide\t\tPARAMS ((HOST_WIDE_INT, tree));\n \n-#define size_int(L) size_int_wide ((HOST_WIDE_INT) (L), 0)\n-#define bitsize_int(L) size_int_wide ((HOST_WIDE_INT) (L), 1)\n+#define size_int_type(L, T) size_int_type_wide ((HOST_WIDE_INT) (L), T)\n+#define size_int(L) size_int_wide ((HOST_WIDE_INT) (L), SIZETYPE)\n+#define ssize_int(L) size_int_wide ((HOST_WIDE_INT) (L), SSIZETYPE)\n+#define bitsize_int(L) size_int_wide ((HOST_WIDE_INT) (L), BITSIZETYPE)\n+#define sbitsize_int(L) size_int_wide ((HOST_WIDE_INT) (L), SBITSIZETYPE)\n \n extern tree round_up\t\t\tPARAMS ((tree, int));\n extern tree get_pending_sizes\t\tPARAMS ((void));\n@@ -1802,22 +1836,6 @@ extern void put_pending_sizes\t\tPARAMS ((tree));\n    + (BITS_PER_UNIT > 8) + (BITS_PER_UNIT > 16) + (BITS_PER_UNIT > 32) \\\n    + (BITS_PER_UNIT > 64) + (BITS_PER_UNIT > 128) + (BITS_PER_UNIT > 256))\n \n-struct sizetype_tab\n-{\n-  tree xsizetype, xbitsizetype;\n-  tree xssizetype, xusizetype;\n-  tree xsbitsizetype, xubitsizetype;\n-};\n-\n-extern struct sizetype_tab sizetype_tab;\n-\n-#define sizetype sizetype_tab.xsizetype\n-#define bitsizetype sizetype_tab.xbitsizetype\n-#define ssizetype sizetype_tab.xssizetype\n-#define usizetype sizetype_tab.xusizetype\n-#define sbitsizetype sizetype_tab.xsbitsizetype\n-#define ubitsizetype sizetype_tab.xubitsizetype\n-\n /* If nonzero, an upper limit on alignment of structure fields, in bits. */\n extern unsigned int maximum_field_alignment;\n "}]}