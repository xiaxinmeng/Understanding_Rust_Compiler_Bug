{"sha": "f988ec96d922819a4948c1ed96c6dc1b79a7ad22", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Zjk4OGVjOTZkOTIyODE5YTQ5NDhjMWVkOTZjNmRjMWI3OWE3YWQyMg==", "commit": {"author": {"name": "Ben Elliston", "email": "bje@au.ibm.com", "date": "2009-03-29T00:33:22Z"}, "committer": {"name": "Ben Elliston", "email": "bje@gcc.gnu.org", "date": "2009-03-29T00:33:22Z"}, "message": "decNumber.c, [...]: Upgrade to decNumber 3.61.\n\n\t* decNumber.c, decNumber.h, decNumberLocal.h, decDouble.c,\n\tdecDouble.h, decSingle.c, decContext.c, decSingle.h, decPacked.c,\n\tdecCommon.c, decContext.h, decQuad.c, decPacked.h, decQuad.h,\n\tdecDPD.h, decBasic.c: Upgrade to decNumber 3.61.\n\t* dpd/decimal128.h, dpd/decimal32.c, dpd/decimal32.h,\n\tdpd/decimal64.c, dpd/decimal128.c, dpd/decimal64.h: Likewise.\n\nFrom-SVN: r145222", "tree": {"sha": "9ce194cc5467e65c729657e8e356f5d17eef3a16", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/9ce194cc5467e65c729657e8e356f5d17eef3a16"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f988ec96d922819a4948c1ed96c6dc1b79a7ad22", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f988ec96d922819a4948c1ed96c6dc1b79a7ad22", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f988ec96d922819a4948c1ed96c6dc1b79a7ad22", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f988ec96d922819a4948c1ed96c6dc1b79a7ad22/comments", "author": null, "committer": null, "parents": [{"sha": "7cdc19725b8817483f523591ac085b8e6375a7e3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7cdc19725b8817483f523591ac085b8e6375a7e3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7cdc19725b8817483f523591ac085b8e6375a7e3"}], "stats": {"total": 3582, "additions": 1971, "deletions": 1611}, "files": [{"sha": "d49bfb5a7d5cf77b35eb31e99626fb7be1cf2118", "filename": "libdecnumber/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f988ec96d922819a4948c1ed96c6dc1b79a7ad22/libdecnumber%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f988ec96d922819a4948c1ed96c6dc1b79a7ad22/libdecnumber%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libdecnumber%2FChangeLog?ref=f988ec96d922819a4948c1ed96c6dc1b79a7ad22", "patch": "@@ -1,3 +1,12 @@\n+2009-03-29  Ben Elliston  <bje@au.ibm.com>\n+\n+\t* decNumber.c, decNumber.h, decNumberLocal.h, decDouble.c,\n+\tdecDouble.h, decSingle.c, decContext.c, decSingle.h, decPacked.c,\n+\tdecCommon.c, decContext.h, decQuad.c, decPacked.h, decQuad.h,\n+\tdecDPD.h, decBasic.c: Upgrade to decNumber 3.61.\n+\t* dpd/decimal128.h, dpd/decimal32.c, dpd/decimal32.h,\n+\tdpd/decimal64.c, dpd/decimal128.c, dpd/decimal64.h: Likewise.\n+\n 2009-02-10  Joseph Myers  <joseph@codesourcery.com>\n \n \t* Makefile.in (clean): Don't remove makedepend$(EXEEXT)."}, {"sha": "06aa8bae3209a1e5b1457d04ec0d84a25ed08637", "filename": "libdecnumber/decBasic.c", "status": "modified", "additions": 526, "deletions": 385, "changes": 911, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f988ec96d922819a4948c1ed96c6dc1b79a7ad22/libdecnumber%2FdecBasic.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f988ec96d922819a4948c1ed96c6dc1b79a7ad22/libdecnumber%2FdecBasic.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libdecnumber%2FdecBasic.c?ref=f988ec96d922819a4948c1ed96c6dc1b79a7ad22", "patch": "@@ -32,8 +32,8 @@\n /* decBasic.c -- common base code for Basic decimal types\t      */\n /* ------------------------------------------------------------------ */\n /* This module comprises code that is shared between decDouble and    */\n-/* decQuad (but not decSingle).\t The main arithmetic operations are   */\n-/* here (Add, Subtract, Multiply, FMA, and Division operators).\t      */\n+/* decQuad (but not decSingle).  The main arithmetic operations are   */\n+/* here (Add, Subtract, Multiply, FMA, and Division operators).       */\n /*\t\t\t\t\t\t\t\t      */\n /* Unlike decNumber, parameterization takes place at compile time     */\n /* rather than at runtime.  The parameters are set in the decDouble.c */\n@@ -59,7 +59,7 @@\n #define DIVIDE\t    0x80000000\t   /* Divide operations [as flags] */\n #define REMAINDER   0x40000000\t   /* .. */\n #define DIVIDEINT   0x20000000\t   /* .. */\n-#define REMNEAR\t    0x10000000\t   /* .. */\n+#define REMNEAR     0x10000000\t   /* .. */\n \n /* Private functions (local, used only by routines in this module) */\n static decFloat *decDivide(decFloat *, const decFloat *,\n@@ -81,7 +81,7 @@ static uInt\t decToInt32(const decFloat *, decContext *, enum rounding,\n /* decCanonical -- copy a decFloat, making canonical\t\t      */\n /*\t\t\t\t\t\t\t\t      */\n /*   result gets the canonicalized df\t\t\t\t      */\n-/*   df\t    is the decFloat to copy and make canonical\t\t      */\n+/*   df     is the decFloat to copy and make canonical\t\t      */\n /*   returns result\t\t\t\t\t\t      */\n /*\t\t\t\t\t\t\t\t      */\n /* This is exposed via decFloatCanonical for Double and Quad only.    */\n@@ -141,14 +141,14 @@ static decFloat * decCanonical(decFloat *result, const decFloat *df) {\n       uoff-=32;\n       dpd|=encode<<(10-uoff);\t   /* get pending bits */\n       }\n-    dpd&=0x3ff;\t\t\t   /* clear uninteresting bits */\n+    dpd&=0x3ff; \t\t   /* clear uninteresting bits */\n     if (dpd<0x16e) continue;\t   /* must be canonical */\n     canon=BIN2DPD[DPD2BIN[dpd]];   /* determine canonical declet */\n     if (canon==dpd) continue;\t   /* have canonical declet */\n     /* need to replace declet */\n     if (uoff>=10) {\t\t   /* all within current word */\n       encode&=~(0x3ff<<(uoff-10)); /* clear the 10 bits ready for replace */\n-      encode|=canon<<(uoff-10);\t   /* insert the canonical form */\n+      encode|=canon<<(uoff-10);    /* insert the canonical form */\n       DFWORD(result, inword)=encode;\t/* .. and save */\n       continue;\n       }\n@@ -167,34 +167,35 @@ static decFloat * decCanonical(decFloat *result, const decFloat *df) {\n /* decDivide -- divide operations\t\t\t\t      */\n /*\t\t\t\t\t\t\t\t      */\n /*   result gets the result of dividing dfl by dfr:\t\t      */\n-/*   dfl    is the first decFloat (lhs)\t\t\t\t      */\n+/*   dfl    is the first decFloat (lhs) \t\t\t      */\n /*   dfr    is the second decFloat (rhs)\t\t\t      */\n /*   set    is the context\t\t\t\t\t      */\n-/*   op\t    is the operation selector\t\t\t\t      */\n+/*   op     is the operation selector\t\t\t\t      */\n /*   returns result\t\t\t\t\t\t      */\n /*\t\t\t\t\t\t\t\t      */\n /* op is one of DIVIDE, REMAINDER, DIVIDEINT, or REMNEAR.\t      */\n /* ------------------------------------------------------------------ */\n #define DIVCOUNT  0\t\t   /* 1 to instrument subtractions counter */\n-#define DIVBASE\t  BILLION\t   /* the base used for divide */\n+#define DIVBASE   ((uInt)BILLION)  /* the base used for divide */\n #define DIVOPLEN  DECPMAX9\t   /* operand length ('digits' base 10**9) */\n #define DIVACCLEN (DIVOPLEN*3)\t   /* accumulator length (ditto) */\n static decFloat * decDivide(decFloat *result, const decFloat *dfl,\n \t\t\t    const decFloat *dfr, decContext *set, uInt op) {\n   decFloat quotient;\t\t   /* for remainders */\n   bcdnum num;\t\t\t   /* for final conversion */\n   uInt\t acc[DIVACCLEN];\t   /* coefficent in base-billion .. */\n-  uInt\t div[DIVOPLEN];\t\t   /* divisor in base-billion .. */\n+  uInt\t div[DIVOPLEN]; \t   /* divisor in base-billion .. */\n   uInt\t quo[DIVOPLEN+1];\t   /* quotient in base-billion .. */\n-  uByte\t bcdacc[(DIVOPLEN+1)*9+2]; /* for quotient in BCD, +1, +1 */\n+  uByte  bcdacc[(DIVOPLEN+1)*9+2]; /* for quotient in BCD, +1, +1 */\n   uInt\t *msua, *msud, *msuq;\t   /* -> msu of acc, div, and quo */\n   Int\t divunits, accunits;\t   /* lengths */\n   Int\t quodigits;\t\t   /* digits in quotient */\n   uInt\t *lsua, *lsuq;\t\t   /* -> current acc and quo lsus */\n   Int\t length, multiplier;\t   /* work */\n   uInt\t carry, sign;\t\t   /* .. */\n-  uInt\t *ua, *ud, *uq;\t\t   /* .. */\n-  uByte\t *ub;\t\t\t   /* .. */\n+  uInt\t *ua, *ud, *uq; \t   /* .. */\n+  uByte  *ub;\t\t\t   /* .. */\n+  uInt\t uiwork;\t\t   /* for macros */\n   uInt\t divtop;\t\t   /* top unit of div adjusted for estimating */\n   #if DIVCOUNT\n   static uInt maxcount=0;\t   /* worst-seen subtractions count */\n@@ -235,7 +236,7 @@ static decFloat * decDivide(decFloat *result, const decFloat *dfl,\n     if (op&(REMAINDER|REMNEAR)) return decInvalid(result, set); /* bad rem */\n     set->status|=DEC_Division_by_zero;\n     DFWORD(result, 0)=num.sign;\n-    return decInfinity(result, result);\t     /* x/0 -> signed Infinity */\n+    return decInfinity(result, result);      /* x/0 -> signed Infinity */\n     }\n   num.exponent=GETEXPUN(dfl)-GETEXPUN(dfr);  /* ideal exponent */\n   if (DFISZERO(dfl)) {\t\t\t     /* 0/x (x!=0) */\n@@ -246,7 +247,7 @@ static decFloat * decDivide(decFloat *result, const decFloat *dfl,\n       DFWORD(result, 0)|=num.sign;\t     /* add sign */\n       return result;\n       }\n-    if (!(op&DIVIDE)) {\t\t\t     /* a remainder */\n+    if (!(op&DIVIDE)) { \t\t     /* a remainder */\n       /* exponent is the minimum of the operands */\n       num.exponent=MINI(GETEXPUN(dfl), GETEXPUN(dfr));\n       /* if the result is zero the sign shall be sign of dfl */\n@@ -289,7 +290,7 @@ static decFloat * decDivide(decFloat *result, const decFloat *dfl,\n   #endif\n \n   /* set msu and lsu pointers */\n-  msua=acc+DIVACCLEN-1;\t      /* [leading zeros removed below] */\n+  msua=acc+DIVACCLEN-1;       /* [leading zeros removed below] */\n   msuq=quo+DIVOPLEN;\n   /*[loop for div will terminate because operands are non-zero] */\n   for (msud=div+DIVOPLEN-1; *msud==0;) msud--;\n@@ -298,7 +299,7 @@ static decFloat * decDivide(decFloat *result, const decFloat *dfl,\n   /* This moves one position towards the least possible for each */\n   /* iteration */\n   divunits=(Int)(msud-div+1); /* precalculate */\n-  lsua=msua-divunits+1;\t      /* initial working lsu of acc */\n+  lsua=msua-divunits+1;       /* initial working lsu of acc */\n   lsuq=msuq;\t\t      /* and of quo */\n \n   /* set up the estimator for the multiplier; this is the msu of div, */\n@@ -371,7 +372,7 @@ static decFloat * decDivide(decFloat *result, const decFloat *dfl,\n \tfor (ud=msud, ua=msua; ud>div; ud--, ua--) if (*ud!=*ua) break;\n \t/* [now at first mismatch or lsu] */\n \tif (*ud>*ua) break;\t\t\t  /* next time... */\n-\tif (*ud==*ua) {\t\t\t\t  /* all compared equal */\n+\tif (*ud==*ua) { \t\t\t  /* all compared equal */\n \t  *lsuq+=1;\t\t\t\t  /* increment result */\n \t  msua=lsua;\t\t\t\t  /* collapse acc units */\n \t  *msua=0;\t\t\t\t  /* .. to a zero */\n@@ -418,10 +419,11 @@ static decFloat * decDivide(decFloat *result, const decFloat *dfl,\n \t    }\n \t   else if (divunits==1) {\n \t    mul=(uLong)*msua * DIVBASE + *(msua-1);\n-\t    mul/=*msud;\t      /* no more to the right */\n+\t    mul/=*msud;       /* no more to the right */\n \t    }\n \t   else {\n-\t    mul=(uLong)(*msua) * (uInt)(DIVBASE<<2) + (*(msua-1)<<2);\n+\t    mul=(uLong)(*msua) * (uInt)(DIVBASE<<2)\n+\t\t+ (*(msua-1)<<2);\n \t    mul/=divtop;      /* [divtop already allows for sticky bits] */\n \t    }\n \t  multiplier=(Int)mul;\n@@ -540,10 +542,10 @@ static decFloat * decDivide(decFloat *result, const decFloat *dfl,\n   /* most significant end [offset by one into bcdacc to leave room */\n   /* for a possible carry digit if rounding for REMNEAR is needed] */\n   for (uq=msuq, ub=bcdacc+1; uq>=lsuq; uq--, ub+=9) {\n-    uInt top, mid, rem;\t\t\t/* work */\n+    uInt top, mid, rem; \t\t/* work */\n     if (*uq==0) {\t\t\t/* no split needed */\n-      UINTAT(ub)=0;\t\t\t/* clear 9 BCD8s */\n-      UINTAT(ub+4)=0;\t\t\t/* .. */\n+      UBFROMUI(ub, 0);\t\t\t/* clear 9 BCD8s */\n+      UBFROMUI(ub+4, 0);\t\t/* .. */\n       *(ub+8)=0;\t\t\t/* .. */\n       continue;\n       }\n@@ -558,11 +560,11 @@ static decFloat * decDivide(decFloat *result, const decFloat *dfl,\n     mid=rem/divsplit6;\n     rem=rem%divsplit6;\n     /* lay out the nine BCD digits (plus one unwanted byte) */\n-    UINTAT(ub)\t=UINTAT(&BIN2BCD8[top*4]);\n-    UINTAT(ub+3)=UINTAT(&BIN2BCD8[mid*4]);\n-    UINTAT(ub+6)=UINTAT(&BIN2BCD8[rem*4]);\n+    UBFROMUI(ub,   UBTOUI(&BIN2BCD8[top*4]));\n+    UBFROMUI(ub+3, UBTOUI(&BIN2BCD8[mid*4]));\n+    UBFROMUI(ub+6, UBTOUI(&BIN2BCD8[rem*4]));\n     } /* BCD conversion loop */\n-  ub--;\t\t\t\t\t/* -> lsu */\n+  ub--; \t\t\t\t/* -> lsu */\n \n   /* complete the bcdnum; quodigits is correct, so the position of */\n   /* the first non-zero is known */\n@@ -642,7 +644,7 @@ static decFloat * decDivide(decFloat *result, const decFloat *dfl,\n \tnum.msd--;\t\t\t     /* use the 0 .. */\n \tnum.lsd=num.msd;\t\t     /* .. at the new MSD place */\n \t}\n-      if (reround!=0) {\t\t\t     /* discarding non-zero */\n+      if (reround!=0) { \t\t     /* discarding non-zero */\n \tuInt bump=0;\n \t/* rounding is DEC_ROUND_HALF_EVEN always */\n \tif (reround>5) bump=1;\t\t     /* >0.5 goes up */\n@@ -651,7 +653,7 @@ static decFloat * decDivide(decFloat *result, const decFloat *dfl,\n \tif (bump!=0) {\t\t\t     /* need increment */\n \t  /* increment the coefficient; this might end up with 1000... */\n \t  ub=num.lsd;\n-\t  for (; UINTAT(ub-3)==0x09090909; ub-=4) UINTAT(ub-3)=0;\n+\t  for (; UBTOUI(ub-3)==0x09090909; ub-=4) UBFROMUI(ub-3, 0);\n \t  for (; *ub==9; ub--) *ub=0;\t     /* at most 3 more */\n \t  *ub+=1;\n \t  if (ub<num.msd) num.msd--;\t     /* carried */\n@@ -680,7 +682,7 @@ static decFloat * decDivide(decFloat *result, const decFloat *dfl,\n /*\t\t\t\t\t\t\t\t      */\n /*   num    gets the result of multiplying dfl and dfr\t\t      */\n /*   bcdacc .. with the coefficient in this array\t\t      */\n-/*   dfl    is the first decFloat (lhs)\t\t\t\t      */\n+/*   dfl    is the first decFloat (lhs) \t\t\t      */\n /*   dfr    is the second decFloat (rhs)\t\t\t      */\n /*\t\t\t\t\t\t\t\t      */\n /* This effects the multiplication of two decFloats, both known to be */\n@@ -695,7 +697,7 @@ static decFloat * decDivide(decFloat *result, const decFloat *dfl,\n /* variables (Ints and uInts) or smaller; the other uses uLongs (for */\n /* multiplication and addition only).  Both implementations cover */\n /* both arithmetic sizes (DOUBLE and QUAD) in order to allow timing */\n-/* comparisons.\t In any one compilation only one implementation for */\n+/* comparisons.  In any one compilation only one implementation for */\n /* each size can be used, and if DECUSE64 is 0 then use of the 32-bit */\n /* version is forced. */\n /* */\n@@ -704,7 +706,7 @@ static decFloat * decDivide(decFloat *result, const decFloat *dfl,\n /* during lazy carry splitting because the initial quotient estimate */\n /* (est) can exceed 32 bits. */\n \n-#define MULTBASE  BILLION\t   /* the base used for multiply */\n+#define MULTBASE  ((uInt)BILLION)  /* the base used for multiply */\n #define MULOPLEN  DECPMAX9\t   /* operand length ('digits' base 10**9) */\n #define MULACCLEN (MULOPLEN*2)\t\t    /* accumulator length (ditto) */\n #define LEADZEROS (MULACCLEN*9 - DECPMAX*2) /* leading zeros always */\n@@ -723,11 +725,12 @@ static void decFiniteMultiply(bcdnum *num, uByte *bcdacc,\n   uInt\t bufl[MULOPLEN];\t   /* left  coefficient (base-billion) */\n   uInt\t bufr[MULOPLEN];\t   /* right coefficient (base-billion) */\n   uInt\t *ui, *uj;\t\t   /* work */\n-  uByte\t *ub;\t\t\t   /* .. */\n+  uByte  *ub;\t\t\t   /* .. */\n+  uInt\t uiwork;\t\t   /* for macros */\n \n   #if DECUSE64\n-  uLong\t accl[MULACCLEN];\t   /* lazy accumulator (base-billion+) */\n-  uLong\t *pl;\t\t\t   /* work -> lazy accumulator */\n+  uLong  accl[MULACCLEN];\t   /* lazy accumulator (base-billion+) */\n+  uLong  *pl;\t\t\t   /* work -> lazy accumulator */\n   uInt\t acc[MULACCLEN];\t   /* coefficent in base-billion .. */\n   #else\n   uInt\t acc[MULACCLEN*2];\t   /* accumulator in base-billion .. */\n@@ -760,7 +763,7 @@ static void decFiniteMultiply(bcdnum *num, uByte *bcdacc,\n   /* zero the accumulator */\n   #if MULACCLEN==4\n     accl[0]=0; accl[1]=0; accl[2]=0; accl[3]=0;\n-  #else\t\t\t\t\t     /* use a loop */\n+  #else \t\t\t\t     /* use a loop */\n     /* MULACCLEN is a multiple of four, asserted above */\n     for (pl=accl; pl<accl+MULACCLEN; pl+=4) {\n       *pl=0; *(pl+1)=0; *(pl+2)=0; *(pl+3)=0;/* [reduce overhead] */\n@@ -812,8 +815,8 @@ static void decFiniteMultiply(bcdnum *num, uByte *bcdacc,\n   /* */\n   /*   Type    OPLEN   A   B\t maxX\t maxError  maxCorrection */\n   /*   --------------------------------------------------------- */\n-  /*   DOUBLE\t 2    29  32  <2*10**18\t   0.63\t      1 */\n-  /*   QUAD\t 4    30  31  <4*10**18\t   1.17\t      2 */\n+  /*   DOUBLE\t 2    29  32  <2*10**18    0.63       1 */\n+  /*   QUAD\t 4    30  31  <4*10**18    1.17       2 */\n   /* */\n   /* In the OPLEN==2 case there is most choice, but the value for B */\n   /* of 32 has a big advantage as then the calculation of the */\n@@ -840,7 +843,7 @@ static void decFiniteMultiply(bcdnum *num, uByte *bcdacc,\n   for (pl=accl, pa=acc; pl<accl+MULACCLEN; pl++, pa++) { /* each column position */\n     uInt lo, hop;\t\t\t/* work */\n     uInt est;\t\t\t\t/* cannot exceed 4E+9 */\n-    if (*pl>MULTBASE) {\n+    if (*pl>=MULTBASE) {\n       /* *pl holds a binary number which needs to be split */\n       hop=(uInt)(*pl>>MULSHIFTA);\n       est=(uInt)(((uLong)hop*MULMAGIC)>>MULSHIFTB);\n@@ -905,7 +908,7 @@ static void decFiniteMultiply(bcdnum *num, uByte *bcdacc,\n   /* quotient/remainder has to be calculated for base-billion (1E+9). */\n   /* For this, Clark & Cowlishaw's quotient estimation approach (also */\n   /* used in decNumber) is needed, because 64-bit divide is generally */\n-  /* extremely slow on 32-bit machines.\t This algorithm splits X */\n+  /* extremely slow on 32-bit machines.  This algorithm splits X */\n   /* using: */\n   /* */\n   /*   magic=2**(A+B)/1E+9;   // 'magic number' */\n@@ -927,8 +930,8 @@ static void decFiniteMultiply(bcdnum *num, uByte *bcdacc,\n   /* */\n   /*   Type    OPLEN   A   B\t maxX\t maxError  maxCorrection */\n   /*   --------------------------------------------------------- */\n-  /*   DOUBLE\t 2    29  32  <2*10**18\t   0.63\t      1 */\n-  /*   QUAD\t 4    30  31  <4*10**18\t   1.17\t      2 */\n+  /*   DOUBLE\t 2    29  32  <2*10**18    0.63       1 */\n+  /*   QUAD\t 4    30  31  <4*10**18    1.17       2 */\n   /* */\n   /* In the OPLEN==2 case there is most choice, but the value for B */\n   /* of 32 has a big advantage as then the calculation of the */\n@@ -952,15 +955,15 @@ static void decFiniteMultiply(bcdnum *num, uByte *bcdacc,\n   printf(\"\\n\");\n   #endif\n \n-  for (pa=acc;; pa++) {\t\t\t/* each low uInt */\n+  for (pa=acc;; pa++) { \t\t/* each low uInt */\n     uInt hi, lo;\t\t\t/* words of exact multiply result */\n     uInt hop, estlo;\t\t\t/* work */\n     #if QUAD\n-    uInt esthi;\t\t\t\t/* .. */\n+    uInt esthi; \t\t\t/* .. */\n     #endif\n \n     lo=*pa;\n-    hi=*(pa+MULACCLEN);\t\t\t/* top 32 bits */\n+    hi=*(pa+MULACCLEN); \t\t/* top 32 bits */\n     /* hi and lo now hold a binary number which needs to be split */\n \n     #if DOUBLE\n@@ -1032,7 +1035,7 @@ static void decFiniteMultiply(bcdnum *num, uByte *bcdacc,\n       uInt top, mid, rem;\t\t/* work */\n       /* *pa is non-zero -- split the base-billion acc digit into */\n       /* hi, mid, and low three-digits */\n-      #define mulsplit9 1000000\t\t/* divisor */\n+      #define mulsplit9 1000000 \t/* divisor */\n       #define mulsplit6 1000\t\t/* divisor */\n       /* The splitting is done by simple divides and remainders, */\n       /* assuming the compiler will optimize these where useful */\n@@ -1042,13 +1045,13 @@ static void decFiniteMultiply(bcdnum *num, uByte *bcdacc,\n       mid=rem/mulsplit6;\n       rem=rem%mulsplit6;\n       /* lay out the nine BCD digits (plus one unwanted byte) */\n-      UINTAT(ub)  =UINTAT(&BIN2BCD8[top*4]);\n-      UINTAT(ub+3)=UINTAT(&BIN2BCD8[mid*4]);\n-      UINTAT(ub+6)=UINTAT(&BIN2BCD8[rem*4]);\n+      UBFROMUI(ub,   UBTOUI(&BIN2BCD8[top*4]));\n+      UBFROMUI(ub+3, UBTOUI(&BIN2BCD8[mid*4]));\n+      UBFROMUI(ub+6, UBTOUI(&BIN2BCD8[rem*4]));\n       }\n      else {\t\t\t\t/* *pa==0 */\n-      UINTAT(ub)=0;\t\t\t/* clear 9 BCD8s */\n-      UINTAT(ub+4)=0;\t\t\t/* .. */\n+      UBFROMUI(ub, 0);\t\t\t/* clear 9 BCD8s */\n+      UBFROMUI(ub+4, 0);\t\t/* .. */\n       *(ub+8)=0;\t\t\t/* .. */\n       }\n     if (pa==acc) break;\n@@ -1068,7 +1071,7 @@ static void decFiniteMultiply(bcdnum *num, uByte *bcdacc,\n /* decFloatAbs -- absolute value, heeding NaNs, etc.\t\t      */\n /*\t\t\t\t\t\t\t\t      */\n /*   result gets the canonicalized df with sign 0\t\t      */\n-/*   df\t    is the decFloat to abs\t\t\t\t      */\n+/*   df     is the decFloat to abs\t\t\t\t      */\n /*   set    is the context\t\t\t\t\t      */\n /*   returns result\t\t\t\t\t\t      */\n /*\t\t\t\t\t\t\t\t      */\n@@ -1090,75 +1093,162 @@ decFloat * decFloatAbs(decFloat *result, const decFloat *df,\n /* decFloatAdd -- add two decFloats\t\t\t\t      */\n /*\t\t\t\t\t\t\t\t      */\n /*   result gets the result of adding dfl and dfr:\t\t      */\n-/*   dfl    is the first decFloat (lhs)\t\t\t\t      */\n+/*   dfl    is the first decFloat (lhs) \t\t\t      */\n /*   dfr    is the second decFloat (rhs)\t\t\t      */\n /*   set    is the context\t\t\t\t\t      */\n /*   returns result\t\t\t\t\t\t      */\n /*\t\t\t\t\t\t\t\t      */\n /* ------------------------------------------------------------------ */\n+#if QUAD\n+/* Table for testing MSDs for fastpath elimination; returns the MSD of */\n+/* a decDouble or decQuad (top 6 bits tested) ignoring the sign. */\n+/* Infinities return -32 and NaNs return -128 so that summing the two */\n+/* MSDs also allows rapid tests for the Specials (see code below). */\n+const Int DECTESTMSD[64]={\n+  0, 1, 2, 3, 4, 5, 6, 7, 0, 1, 2, 3, 4, 5,   6,    7,\n+  0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 8, 9, 8, 9, -32, -128,\n+  0, 1, 2, 3, 4, 5, 6, 7, 0, 1, 2, 3, 4, 5,   6,    7,\n+  0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 8, 9, 8, 9, -32, -128};\n+#else\n+/* The table for testing MSDs is shared between the modules */\n+extern const Int DECTESTMSD[64];\n+#endif\n+\n decFloat * decFloatAdd(decFloat *result,\n \t\t       const decFloat *dfl, const decFloat *dfr,\n \t\t       decContext *set) {\n   bcdnum num;\t\t\t   /* for final conversion */\n-  Int\t expl, expr;\t\t   /* left and right exponents */\n-  uInt\t *ui, *uj;\t\t   /* work */\n-  uByte\t *ub;\t\t\t   /* .. */\n+  Int\t bexpl, bexpr;\t\t   /* left and right biased exponents */\n+  uByte  *ub, *us, *ut; \t   /* work */\n+  uInt\t uiwork;\t\t   /* for macros */\n+  #if QUAD\n+  uShort uswork;\t\t   /* .. */\n+  #endif\n \n   uInt sourhil, sourhir;\t   /* top words from source decFloats */\n-\t\t\t\t   /* [valid only until specials */\n-\t\t\t\t   /* handled or exponents decoded] */\n+\t\t\t\t   /* [valid only through end of */\n+\t\t\t\t   /* fastpath code -- before swap] */\n   uInt diffsign;\t\t   /* non-zero if signs differ */\n   uInt carry;\t\t\t   /* carry: 0 or 1 before add loop */\n-  Int  overlap;\t\t\t   /* coefficient overlap (if full) */\n+  Int  overlap; \t\t   /* coefficient overlap (if full) */\n+  Int  summ;\t\t\t   /* sum of the MSDs */\n   /* the following buffers hold coefficients with various alignments */\n   /* (see commentary and diagrams below) */\n   uByte acc[4+2+DECPMAX*3+8];\n   uByte buf[4+2+DECPMAX*2];\n   uByte *umsd, *ulsd;\t\t   /* local MSD and LSD pointers */\n \n   #if DECLITEND\n-    #define CARRYPAT 0x01000000\t   /* carry=1 pattern */\n+    #define CARRYPAT 0x01000000    /* carry=1 pattern */\n   #else\n-    #define CARRYPAT 0x00000001\t   /* carry=1 pattern */\n+    #define CARRYPAT 0x00000001    /* carry=1 pattern */\n   #endif\n \n   /* Start decoding the arguments */\n-  /* the initial exponents are placed into the opposite Ints to */\n+  /* The initial exponents are placed into the opposite Ints to */\n   /* that which might be expected; there are two sets of data to */\n   /* keep track of (each decFloat and the corresponding exponent), */\n   /* and this scheme means that at the swap point (after comparing */\n   /* exponents) only one pair of words needs to be swapped */\n-  /* whichever path is taken (thereby minimising worst-case path) */\n+  /* whichever path is taken (thereby minimising worst-case path). */\n+  /* The calculated exponents will be nonsense when the arguments are */\n+  /* Special, but are not used in that path */\n   sourhil=DFWORD(dfl, 0);\t   /* LHS top word */\n-  expr=DECCOMBEXP[sourhil>>26];\t   /* get exponent high bits (in place) */\n+  summ=DECTESTMSD[sourhil>>26];    /* get first MSD for testing */\n+  bexpr=DECCOMBEXP[sourhil>>26];   /* get exponent high bits (in place) */\n+  bexpr+=GETECON(dfl);\t\t   /* .. + continuation */\n+\n   sourhir=DFWORD(dfr, 0);\t   /* RHS top word */\n-  expl=DECCOMBEXP[sourhir>>26];\n+  summ+=DECTESTMSD[sourhir>>26];   /* sum MSDs for testing */\n+  bexpl=DECCOMBEXP[sourhir>>26];\n+  bexpl+=GETECON(dfr);\n+\n+  /* here bexpr has biased exponent from lhs, and vice versa */\n \n   diffsign=(sourhil^sourhir)&DECFLOAT_Sign;\n \n-  if (EXPISSPECIAL(expl | expr)) { /* either is special? */\n-    if (DFISNAN(dfl) || DFISNAN(dfr)) return decNaNs(result, dfl, dfr, set);\n-    /* one or two infinities */\n-    /* two infinities with different signs is invalid */\n-    if (diffsign && DFISINF(dfl) && DFISINF(dfr))\n-      return decInvalid(result, set);\n-    if (DFISINF(dfl)) return decInfinity(result, dfl); /* LHS is infinite */\n-    return decInfinity(result, dfr);\t\t       /* RHS must be Infinite */\n-    }\n+  /* now determine whether to take a fast path or the full-function */\n+  /* slow path.  The slow path must be taken when: */\n+  /*   -- both numbers are finite, and: */\n+  /*\t     the exponents are different, or */\n+  /*\t     the signs are different, or */\n+  /*\t     the sum of the MSDs is >8 (hence might overflow) */\n+  /* specialness and the sum of the MSDs can be tested at once using */\n+  /* the summ value just calculated, so the test for specials is no */\n+  /* longer on the worst-case path (as of 3.60) */\n+\n+  if (summ<=8) {\t\t   /* MSD+MSD is good, or there is a special */\n+    if (summ<0) {\t\t   /* there is a special */\n+      /* Inf+Inf would give -64; Inf+finite is -32 or higher */\n+      if (summ<-64) return decNaNs(result, dfl, dfr, set);  /* one or two NaNs */\n+      /* two infinities with different signs is invalid */\n+      if (summ==-64 && diffsign) return decInvalid(result, set);\n+      if (DFISINF(dfl)) return decInfinity(result, dfl);    /* LHS is infinite */\n+      return decInfinity(result, dfr);\t\t\t    /* RHS must be Inf */\n+      }\n+    /* Here when both arguments are finite; fast path is possible */\n+    /* (currently only for aligned and same-sign) */\n+    if (bexpr==bexpl && !diffsign) {\n+      uInt tac[DECLETS+1];\t\t/* base-1000 coefficient */\n+      uInt encode;\t\t\t/* work */\n+\n+      /* Get one coefficient as base-1000 and add the other */\n+      GETCOEFFTHOU(dfl, tac);\t\t/* least-significant goes to [0] */\n+      ADDCOEFFTHOU(dfr, tac);\n+      /* here the sum of the MSDs (plus any carry) will be <10 due to */\n+      /* the fastpath test earlier */\n+\n+      /* construct the result; low word is the same for both formats */\n+      encode =BIN2DPD[tac[0]];\n+      encode|=BIN2DPD[tac[1]]<<10;\n+      encode|=BIN2DPD[tac[2]]<<20;\n+      encode|=BIN2DPD[tac[3]]<<30;\n+      DFWORD(result, (DECBYTES/4)-1)=encode;\n+\n+      /* collect next two declets (all that remains, for Double) */\n+      encode =BIN2DPD[tac[3]]>>2;\n+      encode|=BIN2DPD[tac[4]]<<8;\n \n-  /* Here when both arguments are finite */\n+      #if QUAD\n+      /* complete and lay out middling words */\n+      encode|=BIN2DPD[tac[5]]<<18;\n+      encode|=BIN2DPD[tac[6]]<<28;\n+      DFWORD(result, 2)=encode;\n+\n+      encode =BIN2DPD[tac[6]]>>4;\n+      encode|=BIN2DPD[tac[7]]<<6;\n+      encode|=BIN2DPD[tac[8]]<<16;\n+      encode|=BIN2DPD[tac[9]]<<26;\n+      DFWORD(result, 1)=encode;\n+\n+      /* and final two declets */\n+      encode =BIN2DPD[tac[9]]>>6;\n+      encode|=BIN2DPD[tac[10]]<<4;\n+      #endif\n \n-  /* complete exponent gathering (keeping swapped) */\n-  expr+=GETECON(dfl)-DECBIAS;\t   /* .. + continuation and unbias */\n-  expl+=GETECON(dfr)-DECBIAS;\n-  /* here expr has exponent from lhs, and vice versa */\n+      /* add exponent continuation and sign (from either argument) */\n+      encode|=sourhil & (ECONMASK | DECFLOAT_Sign);\n+\n+      /* create lookup index = MSD + top two bits of biased exponent <<4 */\n+      tac[DECLETS]|=(bexpl>>DECECONL)<<4;\n+      encode|=DECCOMBFROM[tac[DECLETS]]; /* add constructed combination field */\n+      DFWORD(result, 0)=encode; \t /* complete */\n+\n+      /* decFloatShow(result, \">\"); */\n+      return result;\n+      } /* fast path OK */\n+    /* drop through to slow path */\n+    } /* low sum or Special(s) */\n+\n+  /* Slow path required -- arguments are finite and might overflow,   */\n+  /* or require alignment, or might have different signs\t      */\n \n   /* now swap either exponents or argument pointers */\n-  if (expl<=expr) {\n+  if (bexpl<=bexpr) {\n     /* original left is bigger */\n-    Int expswap=expl;\n-    expl=expr;\n-    expr=expswap;\n+    Int bexpswap=bexpl;\n+    bexpl=bexpr;\n+    bexpr=bexpswap;\n     /* printf(\"left bigger\\n\"); */\n     }\n    else {\n@@ -1167,7 +1257,7 @@ decFloat * decFloatAdd(decFloat *result,\n     dfr=dfswap;\n     /* printf(\"right bigger\\n\"); */\n     }\n-  /* [here dfl and expl refer to the datum with the larger exponent, */\n+  /* [here dfl and bexpl refer to the datum with the larger exponent, */\n   /* of if the exponents are equal then the original LHS argument] */\n \n   /* if lhs is zero then result will be the rhs (now known to have */\n@@ -1209,19 +1299,19 @@ decFloat * decFloatAdd(decFloat *result,\n   #if DOUBLE\n     #define COFF 4\t\t\t/* offset into acc */\n   #elif QUAD\n-    USHORTAT(acc+4)=0;\t\t\t/* prefix 00 */\n+    UBFROMUS(acc+4, 0); \t\t/* prefix 00 */\n     #define COFF 6\t\t\t/* offset into acc */\n   #endif\n \n   GETCOEFF(dfl, acc+COFF);\t\t/* decode from decFloat */\n   ulsd=acc+COFF+DECPMAX-1;\n   umsd=acc+4;\t\t\t\t/* [having this here avoids */\n-\t\t\t\t\t/* weird GCC optimizer failure] */\n+\n   #if DECTRACE\n   {bcdnum tum;\n   tum.msd=umsd;\n   tum.lsd=ulsd;\n-  tum.exponent=expl;\n+  tum.exponent=bexpl-DECBIAS;\n   tum.sign=DFWORD(dfl, 0) & DECFLOAT_Sign;\n   decShowNum(&tum, \"dflx\");}\n   #endif\n@@ -1235,26 +1325,26 @@ decFloat * decFloatAdd(decFloat *result,\n   carry=0;\t\t\t\t/* assume no carry */\n   if (diffsign) {\n     carry=CARRYPAT;\t\t\t/* for +1 during add */\n-    UINTAT(acc+ 4)=0x09090909-UINTAT(acc+ 4);\n-    UINTAT(acc+ 8)=0x09090909-UINTAT(acc+ 8);\n-    UINTAT(acc+12)=0x09090909-UINTAT(acc+12);\n-    UINTAT(acc+16)=0x09090909-UINTAT(acc+16);\n+    UBFROMUI(acc+ 4, 0x09090909-UBTOUI(acc+ 4));\n+    UBFROMUI(acc+ 8, 0x09090909-UBTOUI(acc+ 8));\n+    UBFROMUI(acc+12, 0x09090909-UBTOUI(acc+12));\n+    UBFROMUI(acc+16, 0x09090909-UBTOUI(acc+16));\n     #if QUAD\n-    UINTAT(acc+20)=0x09090909-UINTAT(acc+20);\n-    UINTAT(acc+24)=0x09090909-UINTAT(acc+24);\n-    UINTAT(acc+28)=0x09090909-UINTAT(acc+28);\n-    UINTAT(acc+32)=0x09090909-UINTAT(acc+32);\n-    UINTAT(acc+36)=0x09090909-UINTAT(acc+36);\n+    UBFROMUI(acc+20, 0x09090909-UBTOUI(acc+20));\n+    UBFROMUI(acc+24, 0x09090909-UBTOUI(acc+24));\n+    UBFROMUI(acc+28, 0x09090909-UBTOUI(acc+28));\n+    UBFROMUI(acc+32, 0x09090909-UBTOUI(acc+32));\n+    UBFROMUI(acc+36, 0x09090909-UBTOUI(acc+36));\n     #endif\n     } /* diffsign */\n \n   /* now process the rhs coefficient; if it cannot overlap lhs then */\n   /* it can be put straight into acc (with an appropriate gap, if */\n   /* needed) because no actual addition will be needed (except */\n   /* possibly to complete ten's complement) */\n-  overlap=DECPMAX-(expl-expr);\n+  overlap=DECPMAX-(bexpl-bexpr);\n   #if DECTRACE\n-  printf(\"exps: %ld %ld\\n\", (LI)expl, (LI)expr);\n+  printf(\"exps: %ld %ld\\n\", (LI)(bexpl-DECBIAS), (LI)(bexpr-DECBIAS));\n   printf(\"Overlap=%ld carry=%08lx\\n\", (LI)overlap, (LI)carry);\n   #endif\n \n@@ -1274,13 +1364,13 @@ decFloat * decFloatAdd(decFloat *result,\n     /* safe because the lhs is non-zero]. */\n     gap=-overlap;\n     if (gap>DECPMAX) {\n-      expr+=gap-1;\n+      bexpr+=gap-1;\n       gap=DECPMAX;\n       }\n     ub=ulsd+gap+1;\t\t\t/* where MSD will go */\n     /* Fill the gap with 0s; note that there is no addition to do */\n-    ui=&UINTAT(acc+COFF+DECPMAX);\t/* start of gap */\n-    for (; ui<&UINTAT(ub); ui++) *ui=0; /* mind the gap */\n+    ut=acc+COFF+DECPMAX;\t\t/* start of gap */\n+    for (; ut<ub; ut+=4) UBFROMUI(ut, 0); /* mind the gap */\n     if (overlap<-DECPMAX) {\t\t/* gap was > DECPMAX */\n       *ub=(uByte)(!DFISZERO(dfr));\t/* make sticky digit */\n       }\n@@ -1294,63 +1384,74 @@ decFloat * decFloatAdd(decFloat *result,\n    else {\t\t\t\t/* overlap>0 */\n     /* coefficients overlap (perhaps completely, although also */\n     /* perhaps only where zeros) */\n-    ub=buf+COFF+DECPMAX-overlap;\t/* where MSD will go */\n-    /* Fill the prefix gap with 0s; 8 will cover most common */\n-    /* unalignments, so start with direct assignments (a loop is */\n-    /* then used for any remaining -- the loop (and the one in a */\n-    /* moment) is not then on the critical path because the number */\n-    /* of additions is reduced by (at least) two in this case) */\n-    UINTAT(buf+4)=0;\t\t\t/* [clears decQuad 00 too] */\n-    UINTAT(buf+8)=0;\n-    if (ub>buf+12) {\n-      ui=&UINTAT(buf+12);\t\t/* start of any remaining */\n-      for (; ui<&UINTAT(ub); ui++) *ui=0; /* fill them */\n-      }\n-    GETCOEFF(dfr, ub);\t\t\t/* decode from decFloat */\n-\n-    /* now move tail of rhs across to main acc; again use direct */\n-    /* assignment for 8 digits-worth */\n-    UINTAT(acc+COFF+DECPMAX)=UINTAT(buf+COFF+DECPMAX);\n-    UINTAT(acc+COFF+DECPMAX+4)=UINTAT(buf+COFF+DECPMAX+4);\n-    if (buf+COFF+DECPMAX+8<ub+DECPMAX) {\n-      uj=&UINTAT(buf+COFF+DECPMAX+8);\t/* source */\n-      ui=&UINTAT(acc+COFF+DECPMAX+8);\t/* target */\n-      for (; uj<&UINTAT(ub+DECPMAX); ui++, uj++) *ui=*uj;\n+    if (overlap==DECPMAX) {\t\t/* aligned */\n+      ub=buf+COFF;\t\t\t/* where msd will go */\n+      #if QUAD\n+      UBFROMUS(buf+4, 0);\t\t/* clear quad's 00 */\n+      #endif\n+      GETCOEFF(dfr, ub);\t\t/* decode from decFloat */\n       }\n+     else {\t\t\t\t/* unaligned */\n+      ub=buf+COFF+DECPMAX-overlap;\t/* where MSD will go */\n+      /* Fill the prefix gap with 0s; 8 will cover most common */\n+      /* unalignments, so start with direct assignments (a loop is */\n+      /* then used for any remaining -- the loop (and the one in a */\n+      /* moment) is not then on the critical path because the number */\n+      /* of additions is reduced by (at least) two in this case) */\n+      UBFROMUI(buf+4, 0);\t\t/* [clears decQuad 00 too] */\n+      UBFROMUI(buf+8, 0);\n+      if (ub>buf+12) {\n+\tut=buf+12;\t\t\t/* start any remaining */\n+\tfor (; ut<ub; ut+=4) UBFROMUI(ut, 0); /* fill them */\n+\t}\n+      GETCOEFF(dfr, ub);\t\t/* decode from decFloat */\n+\n+      /* now move tail of rhs across to main acc; again use direct */\n+      /* copies for 8 digits-worth */\n+      UBFROMUI(acc+COFF+DECPMAX,   UBTOUI(buf+COFF+DECPMAX));\n+      UBFROMUI(acc+COFF+DECPMAX+4, UBTOUI(buf+COFF+DECPMAX+4));\n+      if (buf+COFF+DECPMAX+8<ub+DECPMAX) {\n+\tus=buf+COFF+DECPMAX+8;\t\t/* source */\n+\tut=acc+COFF+DECPMAX+8;\t\t/* target */\n+\tfor (; us<ub+DECPMAX; us+=4, ut+=4) UBFROMUI(ut, UBTOUI(us));\n+\t}\n+      } /* unaligned */\n \n     ulsd=acc+(ub-buf+DECPMAX-1);\t/* update LSD pointer */\n \n-    /* now do the add of the non-tail; this is all nicely aligned, */\n+    /* Now do the add of the non-tail; this is all nicely aligned, */\n     /* and is over a multiple of four digits (because for Quad two */\n-    /* two 0 digits were added on the left); words in both acc and */\n+    /* zero digits were added on the left); words in both acc and */\n     /* buf (buf especially) will often be zero */\n-    /* [byte-by-byte add, here, is about 15% slower than the by-fours] */\n+    /* [byte-by-byte add, here, is about 15% slower total effect than */\n+    /* the by-fours] */\n \n     /* Now effect the add; this is harder on a little-endian */\n     /* machine as the inter-digit carry cannot use the usual BCD */\n     /* addition trick because the bytes are loaded in the wrong order */\n     /* [this loop could be unrolled, but probably scarcely worth it] */\n \n-    ui=&UINTAT(acc+COFF+DECPMAX-4);\t/* target LSW (acc) */\n-    uj=&UINTAT(buf+COFF+DECPMAX-4);\t/* source LSW (buf, to add to acc) */\n+    ut=acc+COFF+DECPMAX-4;\t\t/* target LSW (acc) */\n+    us=buf+COFF+DECPMAX-4;\t\t/* source LSW (buf, to add to acc) */\n \n     #if !DECLITEND\n-    for (; ui>=&UINTAT(acc+4); ui--, uj--) {\n+    for (; ut>=acc+4; ut-=4, us-=4) {\t/* big-endian add loop */\n       /* bcd8 add */\n-      carry+=*uj;\t\t\t/* rhs + carry */\n+      carry+=UBTOUI(us);\t\t/* rhs + carry */\n       if (carry==0) continue;\t\t/* no-op */\n-      carry+=*ui;\t\t\t/* lhs */\n+      carry+=UBTOUI(ut);\t\t/* lhs */\n       /* Big-endian BCD adjust (uses internal carry) */\n       carry+=0x76f6f6f6;\t\t/* note top nibble not all bits */\n-      *ui=(carry & 0x0f0f0f0f) - ((carry & 0x60606060)>>4); /* BCD adjust */\n+      /* apply BCD adjust and save */\n+      UBFROMUI(ut, (carry & 0x0f0f0f0f) - ((carry & 0x60606060)>>4));\n       carry>>=31;\t\t\t/* true carry was at far left */\n       } /* add loop */\n     #else\n-    for (; ui>=&UINTAT(acc+4); ui--, uj--) {\n+    for (; ut>=acc+4; ut-=4, us-=4) {\t/* little-endian add loop */\n       /* bcd8 add */\n-      carry+=*uj;\t\t\t/* rhs + carry */\n+      carry+=UBTOUI(us);\t\t/* rhs + carry */\n       if (carry==0) continue;\t\t/* no-op [common if unaligned] */\n-      carry+=*ui;\t\t\t/* lhs */\n+      carry+=UBTOUI(ut);\t\t/* lhs */\n       /* Little-endian BCD adjust; inter-digit carry must be manual */\n       /* because the lsb from the array will be in the most-significant */\n       /* byte of carry */\n@@ -1359,12 +1460,13 @@ decFloat * decFloatAdd(decFloat *result,\n       carry+=(carry & 0x00800000)>>15;\n       carry+=(carry & 0x00008000)>>15;\n       carry-=(carry & 0x60606060)>>4;\t/* BCD adjust back */\n-      *ui=carry & 0x0f0f0f0f;\t\t/* clear debris and save */\n+      UBFROMUI(ut, carry & 0x0f0f0f0f); /* clear debris and save */\n       /* here, final carry-out bit is at 0x00000080; move it ready */\n       /* for next word-add (i.e., to 0x01000000) */\n       carry=(carry & 0x00000080)<<17;\n       } /* add loop */\n     #endif\n+\n     #if DECTRACE\n     {bcdnum tum;\n     printf(\"Add done, carry=%08lx, diffsign=%ld\\n\", (LI)carry, (LI)diffsign);\n@@ -1392,36 +1494,36 @@ decFloat * decFloatAdd(decFloat *result,\n       *(ulsd+1)=0;\n       #endif\n       /* there are always at least four coefficient words */\n-      UINTAT(umsd)   =0x09090909-UINTAT(umsd);\n-      UINTAT(umsd+4) =0x09090909-UINTAT(umsd+4);\n-      UINTAT(umsd+8) =0x09090909-UINTAT(umsd+8);\n-      UINTAT(umsd+12)=0x09090909-UINTAT(umsd+12);\n+      UBFROMUI(umsd,\t0x09090909-UBTOUI(umsd));\n+      UBFROMUI(umsd+4,\t0x09090909-UBTOUI(umsd+4));\n+      UBFROMUI(umsd+8,\t0x09090909-UBTOUI(umsd+8));\n+      UBFROMUI(umsd+12, 0x09090909-UBTOUI(umsd+12));\n       #if DOUBLE\n \t#define BNEXT 16\n       #elif QUAD\n-\tUINTAT(umsd+16)=0x09090909-UINTAT(umsd+16);\n-\tUINTAT(umsd+20)=0x09090909-UINTAT(umsd+20);\n-\tUINTAT(umsd+24)=0x09090909-UINTAT(umsd+24);\n-\tUINTAT(umsd+28)=0x09090909-UINTAT(umsd+28);\n-\tUINTAT(umsd+32)=0x09090909-UINTAT(umsd+32);\n+\tUBFROMUI(umsd+16, 0x09090909-UBTOUI(umsd+16));\n+\tUBFROMUI(umsd+20, 0x09090909-UBTOUI(umsd+20));\n+\tUBFROMUI(umsd+24, 0x09090909-UBTOUI(umsd+24));\n+\tUBFROMUI(umsd+28, 0x09090909-UBTOUI(umsd+28));\n+\tUBFROMUI(umsd+32, 0x09090909-UBTOUI(umsd+32));\n \t#define BNEXT 36\n       #endif\n       if (ulsd>=umsd+BNEXT) {\t\t/* unaligned */\n \t/* eight will handle most unaligments for Double; 16 for Quad */\n-\tUINTAT(umsd+BNEXT)=0x09090909-UINTAT(umsd+BNEXT);\n-\tUINTAT(umsd+BNEXT+4)=0x09090909-UINTAT(umsd+BNEXT+4);\n+\tUBFROMUI(umsd+BNEXT,   0x09090909-UBTOUI(umsd+BNEXT));\n+\tUBFROMUI(umsd+BNEXT+4, 0x09090909-UBTOUI(umsd+BNEXT+4));\n \t#if DOUBLE\n \t#define BNEXTY (BNEXT+8)\n \t#elif QUAD\n-\tUINTAT(umsd+BNEXT+8)=0x09090909-UINTAT(umsd+BNEXT+8);\n-\tUINTAT(umsd+BNEXT+12)=0x09090909-UINTAT(umsd+BNEXT+12);\n+\tUBFROMUI(umsd+BNEXT+8,\t0x09090909-UBTOUI(umsd+BNEXT+8));\n+\tUBFROMUI(umsd+BNEXT+12, 0x09090909-UBTOUI(umsd+BNEXT+12));\n \t#define BNEXTY (BNEXT+16)\n \t#endif\n \tif (ulsd>=umsd+BNEXTY) {\t/* very unaligned */\n-\t  ui=&UINTAT(umsd+BNEXTY);\t/* -> continue */\n-\t  for (;;ui++) {\n-\t    *ui=0x09090909-*ui;\t\t/* invert four digits */\n-\t    if (ui>=&UINTAT(ulsd-3)) break; /* all done */\n+\t  ut=umsd+BNEXTY;\t\t/* -> continue */\n+\t  for (;;ut+=4) {\n+\t    UBFROMUI(ut, 0x09090909-UBTOUI(ut)); /* invert four digits */\n+\t    if (ut>=ulsd-3) break;\t/* all done */\n \t    }\n \t  }\n \t}\n@@ -1446,10 +1548,10 @@ decFloat * decFloatAdd(decFloat *result,\n \tumsd=acc+COFF+DECPMAX-1;   /* so far, so zero */\n \tif (ulsd>umsd) {\t   /* more to check */\n \t  umsd++;\t\t   /* to align after checked area */\n-\t  for (; UINTAT(umsd)==0 && umsd+3<ulsd;) umsd+=4;\n+\t  for (; UBTOUI(umsd)==0 && umsd+3<ulsd;) umsd+=4;\n \t  for (; *umsd==0 && umsd<ulsd;) umsd++;\n \t  }\n-\tif (*umsd==0) {\t\t   /* must be true zero (and diffsign) */\n+\tif (*umsd==0) { \t   /* must be true zero (and diffsign) */\n \t  num.sign=0;\t\t   /* assume + */\n \t  if (set->round==DEC_ROUND_FLOOR) num.sign=DECFLOAT_Sign;\n \t  }\n@@ -1468,9 +1570,9 @@ decFloat * decFloatAdd(decFloat *result,\n     #endif\n     } /* same sign */\n \n-  num.msd=umsd;\t\t\t   /* set MSD .. */\n-  num.lsd=ulsd;\t\t\t   /* .. and LSD */\n-  num.exponent=expr;\t\t   /* set exponent to smaller */\n+  num.msd=umsd; \t\t   /* set MSD .. */\n+  num.lsd=ulsd; \t\t   /* .. and LSD */\n+  num.exponent=bexpr-DECBIAS;\t   /* set exponent to smaller, unbiassed */\n \n   #if DECTRACE\n   decFloatShow(dfl, \"dfl\");\n@@ -1484,12 +1586,12 @@ decFloat * decFloatAdd(decFloat *result,\n /* decFloatAnd -- logical digitwise AND of two decFloats\t      */\n /*\t\t\t\t\t\t\t\t      */\n /*   result gets the result of ANDing dfl and dfr\t\t      */\n-/*   dfl    is the first decFloat (lhs)\t\t\t\t      */\n+/*   dfl    is the first decFloat (lhs) \t\t\t      */\n /*   dfr    is the second decFloat (rhs)\t\t\t      */\n /*   set    is the context\t\t\t\t\t      */\n /*   returns result, which will be canonical with sign=0\t      */\n /*\t\t\t\t\t\t\t\t      */\n-/* The operands must be positive, finite with exponent q=0, and\t      */\n+/* The operands must be positive, finite with exponent q=0, and       */\n /* comprise just zeros and ones; if not, Invalid operation results.   */\n /* ------------------------------------------------------------------ */\n decFloat * decFloatAnd(decFloat *result,\n@@ -1516,7 +1618,7 @@ decFloat * decFloatAnd(decFloat *result,\n /* decFloatCanonical -- copy a decFloat, making canonical\t      */\n /*\t\t\t\t\t\t\t\t      */\n /*   result gets the canonicalized df\t\t\t\t      */\n-/*   df\t    is the decFloat to copy and make canonical\t\t      */\n+/*   df     is the decFloat to copy and make canonical\t\t      */\n /*   returns result\t\t\t\t\t\t      */\n /*\t\t\t\t\t\t\t\t      */\n /* This works on specials, too; no error or exception is possible.    */\n@@ -1528,7 +1630,7 @@ decFloat * decFloatCanonical(decFloat *result, const decFloat *df) {\n /* ------------------------------------------------------------------ */\n /* decFloatClass -- return the class of a decFloat\t\t      */\n /*\t\t\t\t\t\t\t\t      */\n-/*   df is the decFloat to test\t\t\t\t\t      */\n+/*   df is the decFloat to test \t\t\t\t      */\n /*   returns the decClass that df falls into\t\t\t      */\n /* ------------------------------------------------------------------ */\n enum decClass decFloatClass(const decFloat *df) {\n@@ -1560,7 +1662,7 @@ enum decClass decFloatClass(const decFloat *df) {\n /* ------------------------------------------------------------------ */\n /* decFloatClassString -- return the class of a decFloat as a string  */\n /*\t\t\t\t\t\t\t\t      */\n-/*   df is the decFloat to test\t\t\t\t\t      */\n+/*   df is the decFloat to test \t\t\t\t      */\n /*   returns a constant string describing the class df falls into     */\n /* ------------------------------------------------------------------ */\n const char *decFloatClassString(const decFloat *df) {\n@@ -1579,10 +1681,10 @@ const char *decFloatClassString(const decFloat *df) {\n   } /* decFloatClassString */\n \n /* ------------------------------------------------------------------ */\n-/* decFloatCompare -- compare two decFloats; quiet NaNs allowed\t      */\n+/* decFloatCompare -- compare two decFloats; quiet NaNs allowed       */\n /*\t\t\t\t\t\t\t\t      */\n /*   result gets the result of comparing dfl and dfr\t\t      */\n-/*   dfl    is the first decFloat (lhs)\t\t\t\t      */\n+/*   dfl    is the first decFloat (lhs) \t\t\t      */\n /*   dfr    is the second decFloat (rhs)\t\t\t      */\n /*   set    is the context\t\t\t\t\t      */\n /*   returns result, which may be -1, 0, 1, or NaN (Unordered)\t      */\n@@ -1606,7 +1708,7 @@ decFloat * decFloatCompare(decFloat *result,\n /* decFloatCompareSignal -- compare two decFloats; all NaNs signal    */\n /*\t\t\t\t\t\t\t\t      */\n /*   result gets the result of comparing dfl and dfr\t\t      */\n-/*   dfl    is the first decFloat (lhs)\t\t\t\t      */\n+/*   dfl    is the first decFloat (lhs) \t\t\t      */\n /*   dfr    is the second decFloat (rhs)\t\t\t      */\n /*   set    is the context\t\t\t\t\t      */\n /*   returns result, which may be -1, 0, 1, or NaN (Unordered)\t      */\n@@ -1633,17 +1735,21 @@ decFloat * decFloatCompareSignal(decFloat *result,\n /* decFloatCompareTotal -- compare two decFloats with total ordering  */\n /*\t\t\t\t\t\t\t\t      */\n /*   result gets the result of comparing dfl and dfr\t\t      */\n-/*   dfl    is the first decFloat (lhs)\t\t\t\t      */\n+/*   dfl    is the first decFloat (lhs) \t\t\t      */\n /*   dfr    is the second decFloat (rhs)\t\t\t      */\n /*   returns result, which may be -1, 0, or 1\t\t\t      */\n /* ------------------------------------------------------------------ */\n decFloat * decFloatCompareTotal(decFloat *result,\n \t\t\t\tconst decFloat *dfl, const decFloat *dfr) {\n-  Int comp;\t\t\t\t     /* work */\n+  Int  comp;\t\t\t\t     /* work */\n+  uInt uiwork;\t\t\t\t     /* for macros */\n+  #if QUAD\n+  uShort uswork;\t\t\t     /* .. */\n+  #endif\n   if (DFISNAN(dfl) || DFISNAN(dfr)) {\n     Int nanl, nanr;\t\t\t     /* work */\n     /* morph NaNs to +/- 1 or 2, leave numbers as 0 */\n-    nanl=DFISSNAN(dfl)+DFISQNAN(dfl)*2;\t     /* quiet > signalling */\n+    nanl=DFISSNAN(dfl)+DFISQNAN(dfl)*2;      /* quiet > signalling */\n     if (DFISSIGNED(dfl)) nanl=-nanl;\n     nanr=DFISSNAN(dfr)+DFISQNAN(dfr)*2;\n     if (DFISSIGNED(dfr)) nanr=-nanr;\n@@ -1654,23 +1760,22 @@ decFloat * decFloatCompareTotal(decFloat *result,\n       uByte bufl[DECPMAX+4];\t\t     /* for LHS coefficient + foot */\n       uByte bufr[DECPMAX+4];\t\t     /* for RHS coefficient + foot */\n       uByte *ub, *uc;\t\t\t     /* work */\n-      Int sigl;\t\t\t\t     /* signum of LHS */\n+      Int sigl; \t\t\t     /* signum of LHS */\n       sigl=(DFISSIGNED(dfl) ? -1 : +1);\n \n       /* decode the coefficients */\n       /* (shift both right two if Quad to make a multiple of four) */\n       #if QUAD\n-\tub = bufl;                           /* avoid type-pun violation */\n-\tUSHORTAT(ub)=0;\n-\tuc = bufr;                           /* avoid type-pun violation */\n-\tUSHORTAT(uc)=0;\n+\tUBFROMUS(bufl, 0);\n+\tUBFROMUS(bufr, 0);\n       #endif\n       GETCOEFF(dfl, bufl+QUAD*2);\t     /* decode from decFloat */\n       GETCOEFF(dfr, bufr+QUAD*2);\t     /* .. */\n       /* all multiples of four, here */\n       comp=0;\t\t\t\t     /* assume equal */\n       for (ub=bufl, uc=bufr; ub<bufl+DECPMAX+QUAD*2; ub+=4, uc+=4) {\n-\tif (UINTAT(ub)==UINTAT(uc)) continue; /* so far so same */\n+\tuInt ui=UBTOUI(ub);\n+\tif (ui==UBTOUI(uc)) continue; /* so far so same */\n \t/* about to find a winner; go by bytes in case little-endian */\n \tfor (;; ub++, uc++) {\n \t  if (*ub==*uc) continue;\n@@ -1696,7 +1801,7 @@ decFloat * decFloatCompareTotal(decFloat *result,\n /* decFloatCompareTotalMag -- compare magnitudes with total ordering  */\n /*\t\t\t\t\t\t\t\t      */\n /*   result gets the result of comparing abs(dfl) and abs(dfr)\t      */\n-/*   dfl    is the first decFloat (lhs)\t\t\t\t      */\n+/*   dfl    is the first decFloat (lhs) \t\t\t      */\n /*   dfr    is the second decFloat (rhs)\t\t\t      */\n /*   returns result, which may be -1, 0, or 1\t\t\t      */\n /* ------------------------------------------------------------------ */\n@@ -1747,7 +1852,7 @@ decFloat * decFloatCopyAbs(decFloat *result, const decFloat *dfl) {\n /* ------------------------------------------------------------------ */\n /* decFloatCopyNegate -- copy a decFloat as-is with inverted sign bit */\n /*\t\t\t\t\t\t\t\t      */\n-/*   result gets the copy of dfl with sign bit inverted\t\t      */\n+/*   result gets the copy of dfl with sign bit inverted \t      */\n /*   dfl    is the decFloat to copy\t\t\t\t      */\n /*   returns result\t\t\t\t\t\t      */\n /*\t\t\t\t\t\t\t\t      */\n@@ -1760,10 +1865,10 @@ decFloat * decFloatCopyNegate(decFloat *result, const decFloat *dfl) {\n   } /* decFloatCopyNegate */\n \n /* ------------------------------------------------------------------ */\n-/* decFloatCopySign -- copy a decFloat with the sign of another\t      */\n+/* decFloatCopySign -- copy a decFloat with the sign of another       */\n /*\t\t\t\t\t\t\t\t      */\n-/*   result gets the result of copying dfl with the sign of dfr\t      */\n-/*   dfl    is the first decFloat (lhs)\t\t\t\t      */\n+/*   result gets the result of copying dfl with the sign of dfr       */\n+/*   dfl    is the first decFloat (lhs) \t\t\t      */\n /*   dfr    is the second decFloat (rhs)\t\t\t      */\n /*   returns result\t\t\t\t\t\t      */\n /*\t\t\t\t\t\t\t\t      */\n@@ -1795,7 +1900,7 @@ decFloat * decFloatCopySign(decFloat *result,\n /* next one is used when it is known that the declet must be */\n /* non-zero, or is the final zero declet */\n #define dpdlendun(n, form) {dpd=(form)&0x3ff;\t  \\\n-  if (dpd==0) return 1;\t\t\t\t  \\\n+  if (dpd==0) return 1; \t\t\t  \\\n   return (DECPMAX-1-3*(n))-(3-DPD2BCD8[dpd*4+3]);}\n \n uInt decFloatDigits(const decFloat *df) {\n@@ -1819,7 +1924,7 @@ uInt decFloatDigits(const decFloat *df) {\n       } /* [cannot drop through] */\n     sourlo=DFWORD(df, 1);  /* sourhi not involved now */\n     if (sourlo&0xfff00000) {\t /* in one of first two */\n-      dpdlenchk(1, sourlo>>30);\t /* very rare */\n+      dpdlenchk(1, sourlo>>30);  /* very rare */\n       dpdlendun(2, sourlo>>20);\n       } /* [cannot drop through] */\n     dpdlenchk(3, sourlo>>10);\n@@ -1850,7 +1955,7 @@ uInt decFloatDigits(const decFloat *df) {\n       } /* [cannot drop through] */\n     sourlo=DFWORD(df, 3);\n     if (sourlo&0xfff00000) {\t /* in one of first two */\n-      dpdlenchk(7, sourlo>>30);\t /* very rare */\n+      dpdlenchk(7, sourlo>>30);  /* very rare */\n       dpdlendun(8, sourlo>>20);\n       } /* [cannot drop through] */\n     dpdlenchk(9, sourlo>>10);\n@@ -1863,7 +1968,7 @@ uInt decFloatDigits(const decFloat *df) {\n /* decFloatDivide -- divide a decFloat by another\t\t      */\n /*\t\t\t\t\t\t\t\t      */\n /*   result gets the result of dividing dfl by dfr:\t\t      */\n-/*   dfl    is the first decFloat (lhs)\t\t\t\t      */\n+/*   dfl    is the first decFloat (lhs) \t\t\t      */\n /*   dfr    is the second decFloat (rhs)\t\t\t      */\n /*   set    is the context\t\t\t\t\t      */\n /*   returns result\t\t\t\t\t\t      */\n@@ -1880,7 +1985,7 @@ decFloat * decFloatDivide(decFloat *result,\n /* decFloatDivideInteger -- integer divide a decFloat by another      */\n /*\t\t\t\t\t\t\t\t      */\n /*   result gets the result of dividing dfl by dfr:\t\t      */\n-/*   dfl    is the first decFloat (lhs)\t\t\t\t      */\n+/*   dfl    is the first decFloat (lhs) \t\t\t      */\n /*   dfr    is the second decFloat (rhs)\t\t\t      */\n /*   set    is the context\t\t\t\t\t      */\n /*   returns result\t\t\t\t\t\t      */\n@@ -1896,31 +2001,33 @@ decFloat * decFloatDivideInteger(decFloat *result,\n /* decFloatFMA -- multiply and add three decFloats, fused\t      */\n /*\t\t\t\t\t\t\t\t      */\n /*   result gets the result of (dfl*dfr)+dff with a single rounding   */\n-/*   dfl    is the first decFloat (lhs)\t\t\t\t      */\n+/*   dfl    is the first decFloat (lhs) \t\t\t      */\n /*   dfr    is the second decFloat (rhs)\t\t\t      */\n-/*   dff    is the final decFloat (fhs)\t\t\t\t      */\n+/*   dff    is the final decFloat (fhs) \t\t\t      */\n /*   set    is the context\t\t\t\t\t      */\n /*   returns result\t\t\t\t\t\t      */\n /*\t\t\t\t\t\t\t\t      */\n /* ------------------------------------------------------------------ */\n decFloat * decFloatFMA(decFloat *result, const decFloat *dfl,\n \t\t       const decFloat *dfr, const decFloat *dff,\n \t\t       decContext *set) {\n+\n   /* The accumulator has the bytes needed for FiniteMultiply, plus */\n   /* one byte to the left in case of carry, plus DECPMAX+2 to the */\n   /* right for the final addition (up to full fhs + round & sticky) */\n-  #define FMALEN (1+ (DECPMAX9*18) +DECPMAX+2)\n-  uByte\t acc[FMALEN];\t\t   /* for multiplied coefficient in BCD */\n+  #define FMALEN (ROUNDUP4(1+ (DECPMAX9*18+1) +DECPMAX+2))\n+  uByte  acc[FMALEN];\t\t   /* for multiplied coefficient in BCD */\n \t\t\t\t   /* .. and for final result */\n   bcdnum mul;\t\t\t   /* for multiplication result */\n   bcdnum fin;\t\t\t   /* for final operand, expanded */\n-  uByte\t coe[DECPMAX];\t\t   /* dff coefficient in BCD */\n+  uByte  coe[ROUNDUP4(DECPMAX)];   /* dff coefficient in BCD */\n   bcdnum *hi, *lo;\t\t   /* bcdnum with higher/lower exponent */\n   uInt\t diffsign;\t\t   /* non-zero if signs differ */\n-  uInt\t hipad;\t\t\t   /* pad digit for hi if needed */\n+  uInt\t hipad; \t\t   /* pad digit for hi if needed */\n   Int\t padding;\t\t   /* excess exponent */\n-  uInt\t carry;\t\t\t   /* +1 for ten's complement and during add */\n-  uByte\t *ub, *uh, *ul;\t\t   /* work */\n+  uInt\t carry; \t\t   /* +1 for ten's complement and during add */\n+  uByte  *ub, *uh, *ul; \t   /* work */\n+  uInt\t uiwork;\t\t   /* for macros */\n \n   /* handle all the special values [any special operand leads to a */\n   /* special result] */\n@@ -1971,8 +2078,8 @@ decFloat * decFloatFMA(decFloat *result, const decFloat *dfl,\n   GETCOEFF(dff, coe);\t\t\t/* extract the coefficient */\n \n   /* now set hi and lo so that hi points to whichever of mul and fin */\n-  /* has the higher exponent and lo point to the other [don't care if */\n-  /* the same] */\n+  /* has the higher exponent and lo points to the other [don't care, */\n+  /* if the same].  One coefficient will be in acc, the other in coe. */\n   if (mul.exponent>=fin.exponent) {\n     hi=&mul;\n     lo=&fin;\n@@ -1983,41 +2090,43 @@ decFloat * decFloatFMA(decFloat *result, const decFloat *dfl,\n     }\n \n   /* remove leading zeros on both operands; this will save time later */\n-  /* and make testing for zero trivial */\n-  for (; UINTAT(hi->msd)==0 && hi->msd+3<hi->lsd;) hi->msd+=4;\n+  /* and make testing for zero trivial (tests are safe because acc */\n+  /* and coe are rounded up to uInts) */\n+  for (; UBTOUI(hi->msd)==0 && hi->msd+3<hi->lsd;) hi->msd+=4;\n   for (; *hi->msd==0 && hi->msd<hi->lsd;) hi->msd++;\n-  for (; UINTAT(lo->msd)==0 && lo->msd+3<lo->lsd;) lo->msd+=4;\n+  for (; UBTOUI(lo->msd)==0 && lo->msd+3<lo->lsd;) lo->msd+=4;\n   for (; *lo->msd==0 && lo->msd<lo->lsd;) lo->msd++;\n \n   /* if hi is zero then result will be lo (which has the smaller */\n   /* exponent), which also may need to be tested for zero for the */\n   /* weird IEEE 754 sign rules */\n-  if (*hi->msd==0 && hi->msd==hi->lsd) {     /* hi is zero */\n+  if (*hi->msd==0) {\t\t\t     /* hi is zero */\n     /* \"When the sum of two operands with opposite signs is */\n     /* exactly zero, the sign of that sum shall be '+' in all */\n     /* rounding modes except round toward -Infinity, in which */\n     /* mode that sign shall be '-'.\" */\n     if (diffsign) {\n-      if (*lo->msd==0 && lo->msd==lo->lsd) { /* lo is zero */\n+      if (*lo->msd==0) {\t\t     /* lo is zero */\n \tlo->sign=0;\n \tif (set->round==DEC_ROUND_FLOOR) lo->sign=DECFLOAT_Sign;\n \t} /* diffsign && lo=0 */\n       } /* diffsign */\n     return decFinalize(result, lo, set);     /* may need clamping */\n     } /* numfl is zero */\n   /* [here, both are minimal length and hi is non-zero] */\n+  /* (if lo is zero then padding with zeros may be needed, below) */\n \n   /* if signs differ, take the ten's complement of hi (zeros to the */\n-  /* right do not matter because the complement of zero is zero); */\n-  /* the +1 is done later, as part of the addition, inserted at the */\n+  /* right do not matter because the complement of zero is zero); the */\n+  /* +1 is done later, as part of the addition, inserted at the */\n   /* correct digit */\n   hipad=0;\n   carry=0;\n   if (diffsign) {\n     hipad=9;\n     carry=1;\n     /* exactly the correct number of digits must be inverted */\n-    for (uh=hi->msd; uh<hi->lsd-3; uh+=4) UINTAT(uh)=0x09090909-UINTAT(uh);\n+    for (uh=hi->msd; uh<hi->lsd-3; uh+=4) UBFROMUI(uh, 0x09090909-UBTOUI(uh));\n     for (; uh<=hi->lsd; uh++) *uh=(uByte)(0x09-*uh);\n     }\n \n@@ -2032,7 +2141,8 @@ decFloat * decFloatFMA(decFloat *result, const decFloat *dfl,\n   /* printf(\"FMA pad %ld\\n\", (LI)padding); */\n \n   /* the result of the addition will be built into the accumulator, */\n-  /* starting from the far right; this could be either hi or lo */\n+  /* starting from the far right; this could be either hi or lo, and */\n+  /* will be aligned */\n   ub=acc+FMALEN-1;\t\t   /* where lsd of result will go */\n   ul=lo->lsd;\t\t\t   /* lsd of rhs */\n \n@@ -2042,69 +2152,83 @@ decFloat * decFloatFMA(decFloat *result, const decFloat *dfl,\n     /* digit at the right place, as it stays clear of hi digits */\n     /* [it must be DECPMAX+2 because during a subtraction the msd */\n     /* could become 0 after a borrow from 1.000 to 0.9999...] */\n-    Int hilen=(Int)(hi->lsd-hi->msd+1); /* lengths */\n-    Int lolen=(Int)(lo->lsd-lo->msd+1); /* .. */\n-    Int newexp=MINI(hi->exponent, hi->exponent+hilen-DECPMAX)-3;\n-    Int reduce=newexp-lo->exponent;\n-    if (reduce>0) {\t\t\t/* [= case gives reduce=0 nop] */\n+\n+    Int hilen=(Int)(hi->lsd-hi->msd+1); /* length of hi */\n+    Int lolen=(Int)(lo->lsd-lo->msd+1); /* and of lo */\n+\n+    if (hilen+padding-lolen > DECPMAX+2) {   /* can reduce lo to single */\n+      /* make sure it is virtually at least DECPMAX from hi->msd, at */\n+      /* least to right of hi->lsd (in case of destructive subtract), */\n+      /* and separated by at least two digits from either of those */\n+      /* (the tricky DOUBLE case is when hi is a 1 that will become a */\n+      /* 0.9999... by subtraction: */\n+      /*   hi:\t 1\t\t\t\t     E+16 */\n+      /*   lo:\t  .................1000000000000000  E-16 */\n+      /* which for the addition pads to: */\n+      /*   hi:\t 1000000000000000000\t\t     E-16 */\n+      /*   lo:\t  .................1000000000000000  E-16 */\n+      Int newexp=MINI(hi->exponent, hi->exponent+hilen-DECPMAX)-3;\n+\n       /* printf(\"FMA reduce: %ld\\n\", (LI)reduce); */\n-      if (reduce>=lolen) {\t\t/* eating all */\n-\tlo->lsd=lo->msd;\t\t/* reduce to single digit */\n-\tlo->exponent=newexp;\t\t/* [known to be non-zero] */\n-\t}\n-       else { /* < */\n-\tuByte *up=lo->lsd;\n-\tlo->lsd=lo->lsd-reduce;\n-\tif (*lo->lsd==0)\t\t/* could need sticky bit */\n-\t for (; up>lo->lsd; up--) {\t/* search discarded digits */\n-\t  if (*up!=0) {\t\t\t/* found one... */\n-\t    *lo->lsd=1;\t\t\t/* set sticky bit */\n-\t    break;\n-\t    }\n-\t  }\n-\tlo->exponent+=reduce;\n-\t}\n-      padding=hi->exponent-lo->exponent; /* recalculate */\n-      ul=lo->lsd;\t\t\t /* .. */\n-      } /* maybe reduce */\n-    /* padding is now <= DECPMAX+2 but still > 0; tricky DOUBLE case */\n-    /* is when hi is a 1 that will become a 0.9999... by subtraction: */\n-    /*\t hi:   1\t\t\t\t   E+16 */\n-    /*\t lo:\t.................1000000000000000  E-16 */\n-    /* which for the addition pads and reduces to: */\n-    /*\t hi:   1000000000000000000\t\t   E-2 */\n-    /*\t lo:\t.................1\t\t   E-2 */\n+      lo->lsd=lo->msd;\t\t\t     /* to single digit [maybe 0] */\n+      lo->exponent=newexp;\t\t     /* new lowest exponent */\n+      padding=hi->exponent-lo->exponent;     /* recalculate */\n+      ul=lo->lsd;\t\t\t     /* .. and repoint */\n+      }\n+\n+    /* padding is still > 0, but will fit in acc (less leading carry slot) */\n     #if DECCHECK\n-      if (padding>DECPMAX+2) printf(\"FMA excess padding: %ld\\n\", (LI)padding);\n       if (padding<=0) printf(\"FMA low padding: %ld\\n\", (LI)padding);\n+      if (hilen+padding+1>FMALEN)\n+\tprintf(\"FMA excess hilen+padding: %ld+%ld \\n\", (LI)hilen, (LI)padding);\n       /* printf(\"FMA padding: %ld\\n\", (LI)padding); */\n     #endif\n+\n     /* padding digits can now be set in the result; one or more of */\n     /* these will come from lo; others will be zeros in the gap */\n+    for (; ul-3>=lo->msd && padding>3; padding-=4, ul-=4, ub-=4) {\n+      UBFROMUI(ub-3, UBTOUI(ul-3));\t     /* [cannot overlap] */\n+      }\n     for (; ul>=lo->msd && padding>0; padding--, ul--, ub--) *ub=*ul;\n     for (;padding>0; padding--, ub--) *ub=0; /* mind the gap */\n     }\n \n   /* addition now complete to the right of the rightmost digit of hi */\n   uh=hi->lsd;\n \n-  /* carry was set up depending on ten's complement above; do the add... */\n+  /* dow do the add from hi->lsd to the left */\n+  /* [bytewise, because either operand can run out at any time] */\n+  /* carry was set up depending on ten's complement above */\n+  /* first assume both operands have some digits */\n   for (;; ub--) {\n-    uInt hid, lod;\n-    if (uh<hi->msd) {\n+    if (uh<hi->msd || ul<lo->msd) break;\n+    *ub=(uByte)(carry+(*uh--)+(*ul--));\n+    carry=0;\n+    if (*ub<10) continue;\n+    *ub-=10;\n+    carry=1;\n+    } /* both loop */\n+\n+  if (ul<lo->msd) {\t      /* to left of lo */\n+    for (;; ub--) {\n+      if (uh<hi->msd) break;\n+      *ub=(uByte)(carry+(*uh--));  /* [+0] */\n+      carry=0;\n+      if (*ub<10) continue;\n+      *ub-=10;\n+      carry=1;\n+      } /* hi loop */\n+    }\n+   else {\t\t      /* to left of hi */\n+    for (;; ub--) {\n       if (ul<lo->msd) break;\n-      hid=hipad;\n-      }\n-     else hid=*uh--;\n-    if (ul<lo->msd) lod=0;\n-     else lod=*ul--;\n-    *ub=(uByte)(carry+hid+lod);\n-    if (*ub<10) carry=0;\n-     else {\n+      *ub=(uByte)(carry+hipad+(*ul--));\n+      carry=0;\n+      if (*ub<10) continue;\n       *ub-=10;\n       carry=1;\n-      }\n-    } /* addition loop */\n+      } /* lo loop */\n+    }\n \n   /* addition complete -- now handle carry, borrow, etc. */\n   /* use lo to set up the num (its exponent is already correct, and */\n@@ -2122,7 +2246,7 @@ decFloat * decFloatFMA(decFloat *result, const decFloat *dfl,\n     if (!carry) {\t\t   /* no carry out means hi<lo */\n       /* borrowed -- take ten's complement of the right digits */\n       lo->sign=hi->sign;\t   /* sign is lhs sign */\n-      for (ul=lo->msd; ul<lo->lsd-3; ul+=4) UINTAT(ul)=0x09090909-UINTAT(ul);\n+      for (ul=lo->msd; ul<lo->lsd-3; ul+=4) UBFROMUI(ul, 0x09090909-UBTOUI(ul));\n       for (; ul<=lo->lsd; ul++) *ul=(uByte)(0x09-*ul); /* [leaves ul at lsd+1] */\n       /* complete the ten's complement by adding 1 [cannot overrun] */\n       for (ul--; *ul==9; ul--) *ul=0;\n@@ -2133,7 +2257,7 @@ decFloat * decFloatFMA(decFloat *result, const decFloat *dfl,\n       /* all done except for the special IEEE 754 exact-zero-result */\n       /* rule (see above); while testing for zero, strip leading */\n       /* zeros (which will save decFinalize doing it) */\n-      for (; UINTAT(lo->msd)==0 && lo->msd+3<lo->lsd;) lo->msd+=4;\n+      for (; UBTOUI(lo->msd)==0 && lo->msd+3<lo->lsd;) lo->msd+=4;\n       for (; *lo->msd==0 && lo->msd<lo->lsd;) lo->msd++;\n       if (*lo->msd==0) {\t   /* must be true zero (and diffsign) */\n \tlo->sign=0;\t\t   /* assume + */\n@@ -2143,11 +2267,18 @@ decFloat * decFloatFMA(decFloat *result, const decFloat *dfl,\n       } /* subtraction gave positive result */\n     } /* diffsign */\n \n+  #if DECCHECK\n+  /* assert no left underrun */\n+  if (lo->msd<acc) {\n+    printf(\"FMA underrun by %ld \\n\", (LI)(acc-lo->msd));\n+    }\n+  #endif\n+\n   return decFinalize(result, lo, set);\t/* round, check, and lay out */\n   } /* decFloatFMA */\n \n /* ------------------------------------------------------------------ */\n-/* decFloatFromInt -- initialise a decFloat from an Int\t\t      */\n+/* decFloatFromInt -- initialise a decFloat from an Int \t      */\n /*\t\t\t\t\t\t\t\t      */\n /*   result gets the converted Int\t\t\t\t      */\n /*   n\t    is the Int to convert\t\t\t\t      */\n@@ -2213,7 +2344,7 @@ decFloat * decFloatFromUInt32(decFloat *result, uInt u) {\n /* decFloatInvert -- logical digitwise INVERT of a decFloat\t      */\n /*\t\t\t\t\t\t\t\t      */\n /*   result gets the result of INVERTing df\t\t\t      */\n-/*   df\t    is the decFloat to invert\t\t\t\t      */\n+/*   df     is the decFloat to invert\t\t\t\t      */\n /*   set    is the context\t\t\t\t\t      */\n /*   returns result, which will be canonical with sign=0\t      */\n /*\t\t\t\t\t\t\t\t      */\n@@ -2241,12 +2372,12 @@ decFloat * decFloatInvert(decFloat *result, const decFloat *df,\n /* ------------------------------------------------------------------ */\n /* decFloatIs -- decFloat tests (IsSigned, etc.)\t\t      */\n /*\t\t\t\t\t\t\t\t      */\n-/*   df is the decFloat to test\t\t\t\t\t      */\n-/*   returns 0 or 1 in an int32_t\t\t\t\t      */\n+/*   df is the decFloat to test \t\t\t\t      */\n+/*   returns 0 or 1 in a uInt\t\t\t\t\t      */\n /*\t\t\t\t\t\t\t\t      */\n /* Many of these could be macros, but having them as real functions   */\n-/* is a bit cleaner (and they can be referred to here by the generic  */\n-/* names)\t\t\t\t\t\t\t      */\n+/* is a little cleaner (and they can be referred to here by the       */\n+/* generic names)\t\t\t\t\t\t      */\n /* ------------------------------------------------------------------ */\n uInt decFloatIsCanonical(const decFloat *df) {\n   if (DFISSPECIAL(df)) {\n@@ -2333,10 +2464,10 @@ uInt decFloatIsZero(const decFloat *df) {\n   } /* decFloatIs... */\n \n /* ------------------------------------------------------------------ */\n-/* decFloatLogB -- return adjusted exponent, by 754r rules\t      */\n+/* decFloatLogB -- return adjusted exponent, by 754 rules\t      */\n /*\t\t\t\t\t\t\t\t      */\n /*   result gets the adjusted exponent as an integer, or a NaN etc.   */\n-/*   df\t    is the decFloat to be examined\t\t\t      */\n+/*   df     is the decFloat to be examined\t\t\t      */\n /*   set    is the context\t\t\t\t\t      */\n /*   returns result\t\t\t\t\t\t      */\n /*\t\t\t\t\t\t\t\t      */\n@@ -2353,12 +2484,12 @@ decFloat * decFloatLogB(decFloat *result, const decFloat *df,\n   if (DFISNAN(df)) return decNaNs(result, df, NULL, set);\n   if (DFISINF(df)) {\n     DFWORD(result, 0)=0;\t\t     /* need +ve */\n-    return decInfinity(result, result);\t     /* canonical +Infinity */\n+    return decInfinity(result, result);      /* canonical +Infinity */\n     }\n   if (DFISZERO(df)) {\n-    set->status|=DEC_Division_by_zero;\t     /* as per 754r */\n+    set->status|=DEC_Division_by_zero;\t     /* as per 754 */\n     DFWORD(result, 0)=DECFLOAT_Sign;\t     /* make negative */\n-    return decInfinity(result, result);\t     /* canonical -Infinity */\n+    return decInfinity(result, result);      /* canonical -Infinity */\n     }\n   ae=GETEXPUN(df)\t\t\t/* get unbiased exponent .. */\n     +decFloatDigits(df)-1;\t\t/* .. and make adjusted exponent */\n@@ -2381,10 +2512,10 @@ decFloat * decFloatLogB(decFloat *result, const decFloat *df,\n   } /* decFloatLogB */\n \n /* ------------------------------------------------------------------ */\n-/* decFloatMax -- return maxnum of two operands\t\t\t      */\n+/* decFloatMax -- return maxnum of two operands \t\t      */\n /*\t\t\t\t\t\t\t\t      */\n /*   result gets the chosen decFloat\t\t\t\t      */\n-/*   dfl    is the first decFloat (lhs)\t\t\t\t      */\n+/*   dfl    is the first decFloat (lhs) \t\t\t      */\n /*   dfr    is the second decFloat (rhs)\t\t\t      */\n /*   set    is the context\t\t\t\t\t      */\n /*   returns result\t\t\t\t\t\t      */\n@@ -2416,7 +2547,7 @@ decFloat * decFloatMax(decFloat *result,\n /* decFloatMaxMag -- return maxnummag of two operands\t\t      */\n /*\t\t\t\t\t\t\t\t      */\n /*   result gets the chosen decFloat\t\t\t\t      */\n-/*   dfl    is the first decFloat (lhs)\t\t\t\t      */\n+/*   dfl    is the first decFloat (lhs) \t\t\t      */\n /*   dfr    is the second decFloat (rhs)\t\t\t      */\n /*   set    is the context\t\t\t\t\t      */\n /*   returns result\t\t\t\t\t\t      */\n@@ -2440,10 +2571,10 @@ decFloat * decFloatMaxMag(decFloat *result,\n   } /* decFloatMaxMag */\n \n /* ------------------------------------------------------------------ */\n-/* decFloatMin -- return minnum of two operands\t\t\t      */\n+/* decFloatMin -- return minnum of two operands \t\t      */\n /*\t\t\t\t\t\t\t\t      */\n /*   result gets the chosen decFloat\t\t\t\t      */\n-/*   dfl    is the first decFloat (lhs)\t\t\t\t      */\n+/*   dfl    is the first decFloat (lhs) \t\t\t      */\n /*   dfr    is the second decFloat (rhs)\t\t\t      */\n /*   set    is the context\t\t\t\t\t      */\n /*   returns result\t\t\t\t\t\t      */\n@@ -2475,7 +2606,7 @@ decFloat * decFloatMin(decFloat *result,\n /* decFloatMinMag -- return minnummag of two operands\t\t      */\n /*\t\t\t\t\t\t\t\t      */\n /*   result gets the chosen decFloat\t\t\t\t      */\n-/*   dfl    is the first decFloat (lhs)\t\t\t\t      */\n+/*   dfl    is the first decFloat (lhs) \t\t\t      */\n /*   dfr    is the second decFloat (rhs)\t\t\t      */\n /*   set    is the context\t\t\t\t\t      */\n /*   returns result\t\t\t\t\t\t      */\n@@ -2501,8 +2632,8 @@ decFloat * decFloatMinMag(decFloat *result,\n /* ------------------------------------------------------------------ */\n /* decFloatMinus -- negate value, heeding NaNs, etc.\t\t      */\n /*\t\t\t\t\t\t\t\t      */\n-/*   result gets the canonicalized 0-df\t\t\t\t      */\n-/*   df\t    is the decFloat to minus\t\t\t\t      */\n+/*   result gets the canonicalized 0-df \t\t\t      */\n+/*   df     is the decFloat to minus\t\t\t\t      */\n /*   set    is the context\t\t\t\t\t      */\n /*   returns result\t\t\t\t\t\t      */\n /*\t\t\t\t\t\t\t\t      */\n@@ -2524,8 +2655,8 @@ decFloat * decFloatMinus(decFloat *result, const decFloat *df,\n /* ------------------------------------------------------------------ */\n /* decFloatMultiply -- multiply two decFloats\t\t\t      */\n /*\t\t\t\t\t\t\t\t      */\n-/*   result gets the result of multiplying dfl and dfr:\t\t      */\n-/*   dfl    is the first decFloat (lhs)\t\t\t\t      */\n+/*   result gets the result of multiplying dfl and dfr: \t      */\n+/*   dfl    is the first decFloat (lhs) \t\t\t      */\n /*   dfr    is the second decFloat (rhs)\t\t\t      */\n /*   set    is the context\t\t\t\t\t      */\n /*   returns result\t\t\t\t\t\t      */\n@@ -2535,7 +2666,7 @@ decFloat * decFloatMultiply(decFloat *result,\n \t\t\t    const decFloat *dfl, const decFloat *dfr,\n \t\t\t    decContext *set) {\n   bcdnum num;\t\t\t   /* for final conversion */\n-  uByte\t bcdacc[DECPMAX9*18+1];\t   /* for coefficent in BCD */\n+  uByte  bcdacc[DECPMAX9*18+1];    /* for coefficent in BCD */\n \n   if (DFISSPECIAL(dfl) || DFISSPECIAL(dfr)) { /* either is special? */\n     /* NaNs are handled as usual */\n@@ -2561,7 +2692,7 @@ decFloat * decFloatMultiply(decFloat *result,\n /*   set    is the context\t\t\t\t\t      */\n /*   returns result\t\t\t\t\t\t      */\n /*\t\t\t\t\t\t\t\t      */\n-/* This is 754r nextdown; Invalid is the only status possible (from   */\n+/* This is 754 nextdown; Invalid is the only status possible (from    */\n /* an sNaN).\t\t\t\t\t\t\t      */\n /* ------------------------------------------------------------------ */\n decFloat * decFloatNextMinus(decFloat *result, const decFloat *dfl,\n@@ -2580,19 +2711,19 @@ decFloat * decFloatNextMinus(decFloat *result, const decFloat *dfl,\n   /* here (but can be done with normal add if the sign of zero is */\n   /* treated carefully, because no Inexactitude is interesting); */\n   /* rounding to -Infinity then pushes the result to next below */\n-  decFloatZero(&delta);\t\t\t/* set up tiny delta */\n-  DFWORD(&delta, DECWORDS-1)=1;\t\t/* coefficient=1 */\n+  decFloatZero(&delta); \t\t/* set up tiny delta */\n+  DFWORD(&delta, DECWORDS-1)=1; \t/* coefficient=1 */\n   DFWORD(&delta, 0)=DECFLOAT_Sign;\t/* Sign=1 + biased exponent=0 */\n   /* set up for the directional round */\n-  saveround=set->round;\t\t\t/* save mode */\n+  saveround=set->round; \t\t/* save mode */\n   set->round=DEC_ROUND_FLOOR;\t\t/* .. round towards -Infinity */\n-  savestat=set->status;\t\t\t/* save status */\n+  savestat=set->status; \t\t/* save status */\n   decFloatAdd(result, dfl, &delta, set);\n   /* Add rules mess up the sign when going from +Ntiny to 0 */\n   if (DFISZERO(result)) DFWORD(result, 0)^=DECFLOAT_Sign; /* correct */\n   set->status&=DEC_Invalid_operation;\t/* preserve only sNaN status */\n   set->status|=savestat;\t\t/* restore pending flags */\n-  set->round=saveround;\t\t\t/* .. and mode */\n+  set->round=saveround; \t\t/* .. and mode */\n   return result;\n   } /* decFloatNextMinus */\n \n@@ -2604,7 +2735,7 @@ decFloat * decFloatNextMinus(decFloat *result, const decFloat *dfl,\n /*   set    is the context\t\t\t\t\t      */\n /*   returns result\t\t\t\t\t\t      */\n /*\t\t\t\t\t\t\t\t      */\n-/* This is 754r nextup; Invalid is the only status possible (from     */\n+/* This is 754 nextup; Invalid is the only status possible (from      */\n /* an sNaN).\t\t\t\t\t\t\t      */\n /* ------------------------------------------------------------------ */\n decFloat * decFloatNextPlus(decFloat *result, const decFloat *dfl,\n@@ -2624,19 +2755,19 @@ decFloat * decFloatNextPlus(decFloat *result, const decFloat *dfl,\n   /* here (but can be done with normal add if the sign of zero is */\n   /* treated carefully, because no Inexactitude is interesting); */\n   /* rounding to +Infinity then pushes the result to next above */\n-  decFloatZero(&delta);\t\t\t/* set up tiny delta */\n-  DFWORD(&delta, DECWORDS-1)=1;\t\t/* coefficient=1 */\n+  decFloatZero(&delta); \t\t/* set up tiny delta */\n+  DFWORD(&delta, DECWORDS-1)=1; \t/* coefficient=1 */\n   DFWORD(&delta, 0)=0;\t\t\t/* Sign=0 + biased exponent=0 */\n   /* set up for the directional round */\n-  saveround=set->round;\t\t\t/* save mode */\n-  set->round=DEC_ROUND_CEILING;\t\t/* .. round towards +Infinity */\n-  savestat=set->status;\t\t\t/* save status */\n+  saveround=set->round; \t\t/* save mode */\n+  set->round=DEC_ROUND_CEILING; \t/* .. round towards +Infinity */\n+  savestat=set->status; \t\t/* save status */\n   decFloatAdd(result, dfl, &delta, set);\n   /* Add rules mess up the sign when going from -Ntiny to -0 */\n   if (DFISZERO(result)) DFWORD(result, 0)^=DECFLOAT_Sign; /* correct */\n   set->status&=DEC_Invalid_operation;\t/* preserve only sNaN status */\n   set->status|=savestat;\t\t/* restore pending flags */\n-  set->round=saveround;\t\t\t/* .. and mode */\n+  set->round=saveround; \t\t/* .. and mode */\n   return result;\n   } /* decFloatNextPlus */\n \n@@ -2649,8 +2780,9 @@ decFloat * decFloatNextPlus(decFloat *result, const decFloat *dfl,\n /*   set    is the context\t\t\t\t\t      */\n /*   returns result\t\t\t\t\t\t      */\n /*\t\t\t\t\t\t\t\t      */\n-/* This is 754r nextafter; status may be set unless the result is a   */\n-/* normal number.\t\t\t\t\t\t      */\n+/* This is 754-1985 nextafter, as modified during revision (dropped   */\n+/* from 754-2008); status may be set unless the result is a normal    */\n+/* number.\t\t\t\t\t\t\t      */\n /* ------------------------------------------------------------------ */\n decFloat * decFloatNextToward(decFloat *result,\n \t\t\t      const decFloat *dfl, const decFloat *dfr,\n@@ -2676,44 +2808,44 @@ decFloat * decFloatNextToward(decFloat *result,\n       }\n     saveround=set->round;\t\t     /* save mode */\n     set->round=DEC_ROUND_CEILING;\t     /* .. round towards +Infinity */\n-    deltatop=0;\t\t\t\t     /* positive delta */\n+    deltatop=0; \t\t\t     /* positive delta */\n     }\n    else { /* lhs>rhs, do NextMinus, see above for commentary */\n     if (DFISINF(dfl) && !DFISSIGNED(dfl)) {  /* +Infinity special case */\n       DFSETNMAX(result);\n       return result;\n       }\n     saveround=set->round;\t\t     /* save mode */\n-    set->round=DEC_ROUND_FLOOR;\t\t     /* .. round towards -Infinity */\n+    set->round=DEC_ROUND_FLOOR; \t     /* .. round towards -Infinity */\n     deltatop=DECFLOAT_Sign;\t\t     /* negative delta */\n     }\n-  savestat=set->status;\t\t\t     /* save status */\n+  savestat=set->status; \t\t     /* save status */\n   /* Here, Inexact is needed where appropriate (and hence Underflow, */\n   /* etc.).  Therefore the tiny delta which is otherwise */\n   /* unrepresentable (see NextPlus and NextMinus) is constructed */\n   /* using the multiplication of FMA. */\n-  decFloatZero(&delta);\t\t\t/* set up tiny delta */\n-  DFWORD(&delta, DECWORDS-1)=1;\t\t/* coefficient=1 */\n+  decFloatZero(&delta); \t\t/* set up tiny delta */\n+  DFWORD(&delta, DECWORDS-1)=1; \t/* coefficient=1 */\n   DFWORD(&delta, 0)=deltatop;\t\t/* Sign + biased exponent=0 */\n   decFloatFromString(&pointone, \"1E-1\", set); /* set up multiplier */\n   decFloatFMA(result, &delta, &pointone, dfl, set);\n   /* [Delta is truly tiny, so no need to correct sign of zero] */\n   /* use new status unless the result is normal */\n   if (decFloatIsNormal(result)) set->status=savestat; /* else goes forward */\n-  set->round=saveround;\t\t\t/* restore mode */\n+  set->round=saveround; \t\t/* restore mode */\n   return result;\n   } /* decFloatNextToward */\n \n /* ------------------------------------------------------------------ */\n /* decFloatOr -- logical digitwise OR of two decFloats\t\t      */\n /*\t\t\t\t\t\t\t\t      */\n /*   result gets the result of ORing dfl and dfr\t\t      */\n-/*   dfl    is the first decFloat (lhs)\t\t\t\t      */\n+/*   dfl    is the first decFloat (lhs) \t\t\t      */\n /*   dfr    is the second decFloat (rhs)\t\t\t      */\n /*   set    is the context\t\t\t\t\t      */\n /*   returns result, which will be canonical with sign=0\t      */\n /*\t\t\t\t\t\t\t\t      */\n-/* The operands must be positive, finite with exponent q=0, and\t      */\n+/* The operands must be positive, finite with exponent q=0, and       */\n /* comprise just zeros and ones; if not, Invalid operation results.   */\n /* ------------------------------------------------------------------ */\n decFloat * decFloatOr(decFloat *result,\n@@ -2739,14 +2871,14 @@ decFloat * decFloatOr(decFloat *result,\n /* ------------------------------------------------------------------ */\n /* decFloatPlus -- add value to 0, heeding NaNs, etc.\t\t      */\n /*\t\t\t\t\t\t\t\t      */\n-/*   result gets the canonicalized 0+df\t\t\t\t      */\n-/*   df\t    is the decFloat to plus\t\t\t\t      */\n+/*   result gets the canonicalized 0+df \t\t\t      */\n+/*   df     is the decFloat to plus\t\t\t\t      */\n /*   set    is the context\t\t\t\t\t      */\n /*   returns result\t\t\t\t\t\t      */\n /*\t\t\t\t\t\t\t\t      */\n /* This has the same effect as 0+df where the exponent of the zero is */\n /* the same as that of df (if df is finite).\t\t\t      */\n-/* The effect is also the same as decFloatCopy except that NaNs\t      */\n+/* The effect is also the same as decFloatCopy except that NaNs       */\n /* are handled normally (the sign of a NaN is not affected, and an    */\n /* sNaN will signal), the result is canonical, and zero gets sign 0.  */\n /* ------------------------------------------------------------------ */\n@@ -2762,7 +2894,7 @@ decFloat * decFloatPlus(decFloat *result, const decFloat *df,\n /* decFloatQuantize -- quantize a decFloat\t\t\t      */\n /*\t\t\t\t\t\t\t\t      */\n /*   result gets the result of quantizing dfl to match dfr\t      */\n-/*   dfl    is the first decFloat (lhs)\t\t\t\t      */\n+/*   dfl    is the first decFloat (lhs) \t\t\t      */\n /*   dfr    is the second decFloat (rhs), which sets the exponent     */\n /*   set    is the context\t\t\t\t\t      */\n /*   returns result\t\t\t\t\t\t      */\n@@ -2775,16 +2907,19 @@ decFloat * decFloatQuantize(decFloat *result,\n \t\t\t    decContext *set) {\n   Int\texplb, exprb;\t      /* left and right biased exponents */\n   uByte *ulsd;\t\t      /* local LSD pointer */\n-  uInt\t*ui;\t\t      /* work */\n-  uByte *ub;\t\t      /* .. */\n+  uByte *ub, *uc;\t      /* work */\n   Int\tdrop;\t\t      /* .. */\n   uInt\tdpd;\t\t      /* .. */\n-  uInt\tencode;\t\t      /* encoding accumulator */\n+  uInt\tencode; \t      /* encoding accumulator */\n   uInt\tsourhil, sourhir;     /* top words from source decFloats */\n+  uInt\tuiwork; \t      /* for macros */\n+  #if QUAD\n+  uShort uswork;\t      /* .. */\n+  #endif\n   /* the following buffer holds the coefficient for manipulation */\n-  uByte buf[4+DECPMAX*3];     /* + space for zeros to left or right */\n+  uByte buf[4+DECPMAX*3+2*QUAD];   /* + space for zeros to left or right */\n   #if DECTRACE\n-  bcdnum num;\t\t      /* for trace displays */\n+  bcdnum num;\t\t\t   /* for trace displays */\n   #endif\n \n   /* Start decoding the arguments */\n@@ -2827,7 +2962,7 @@ decFloat * decFloatQuantize(decFloat *result,\n   decShowNum(&num, \"dfl\");\n   #endif\n \n-  if (drop>0) {\t\t\t\t/* [most common case] */\n+  if (drop>0) { \t\t\t/* [most common case] */\n     /* (this code is very similar to that in decFloatFinalize, but */\n     /* has many differences so is duplicated here -- so any changes */\n     /* may need to be made there, too) */\n@@ -2838,7 +2973,7 @@ decFloat * decFloatQuantize(decFloat *result,\n     /* there is at least one zero needed to the left, in all but one */\n     /* exceptional (all-nines) case, so place four zeros now; this is */\n     /* needed almost always and makes rounding all-nines by fours safe */\n-    UINTAT(BUFOFF-4)=0;\n+    UBFROMUI(BUFOFF-4, 0);\n \n     /* Three cases here: */\n     /*\t 1. new LSD is in coefficient (almost always) */\n@@ -2849,7 +2984,7 @@ decFloat * decFloatQuantize(decFloat *result,\n \n     /* [duplicate check-stickies code to save a test] */\n     /* [by-digit check for stickies as runs of zeros are rare] */\n-    if (drop<DECPMAX) {\t\t\t     /* NB lengths not addresses */\n+    if (drop<DECPMAX) { \t\t     /* NB lengths not addresses */\n       roundat=BUFOFF+DECPMAX-drop;\n       reround=*roundat;\n       for (ub=roundat+1; ub<BUFOFF+DECPMAX; ub++) {\n@@ -2932,7 +3067,7 @@ decFloat * decFloatQuantize(decFloat *result,\n \t/* increment the coefficient; this could give 1000... (after */\n \t/* the all nines case) */\n \tub=ulsd;\n-\tfor (; UINTAT(ub-3)==0x09090909; ub-=4) UINTAT(ub-3)=0;\n+\tfor (; UBTOUI(ub-3)==0x09090909; ub-=4) UBFROMUI(ub-3, 0);\n \t/* now at most 3 digits left to non-9 (usually just the one) */\n \tfor (; *ub==9; ub--) *ub=0;\n \t*ub+=1;\n@@ -2945,8 +3080,8 @@ decFloat * decFloatQuantize(decFloat *result,\n     /* available in the coefficent -- the first word to the left was */\n     /* cleared earlier for safe carry; now add any more needed */\n     if (drop>4) {\n-      UINTAT(BUFOFF-8)=0;\t\t     /* must be at least 5 */\n-      for (ui=&UINTAT(BUFOFF-12); ui>&UINTAT(ulsd-DECPMAX-3); ui--) *ui=0;\n+      UBFROMUI(BUFOFF-8, 0);\t\t     /* must be at least 5 */\n+      for (uc=BUFOFF-12; uc>ulsd-DECPMAX-3; uc-=4) UBFROMUI(uc, 0);\n       }\n     } /* need round (drop>0) */\n \n@@ -2967,18 +3102,21 @@ decFloat * decFloatQuantize(decFloat *result,\n       #else\n       static const uInt dmask[]={0, 0xff000000, 0xffff0000, 0xffffff00};\n       #endif\n-      for (ui=&UINTAT(BUFOFF+DECPMAX);; ui++) {\n-\t*ui=0;\n-\tif (UINTAT(&UBYTEAT(ui)-DECPMAX)!=0) { /* could be bad */\n+      /* note that here zeros to the right are added by fours, so in */\n+      /* the Quad case this could write 36 zeros if the coefficient has */\n+      /* fewer than three significant digits (hence the +2*QUAD for buf) */\n+      for (uc=BUFOFF+DECPMAX;; uc+=4) {\n+\tUBFROMUI(uc, 0);\n+\tif (UBTOUI(uc-DECPMAX)!=0) {\t\t  /* could be bad */\n \t  /* if all four digits should be zero, definitely bad */\n-\t  if (ui<=&UINTAT(BUFOFF+DECPMAX+(-drop)-4))\n+\t  if (uc<=BUFOFF+DECPMAX+(-drop)-4)\n \t    return decInvalid(result, set);\n \t  /* must be a 1- to 3-digit sequence; check more carefully */\n-\t  if ((UINTAT(&UBYTEAT(ui)-DECPMAX)&dmask[(-drop)%4])!=0)\n+\t  if ((UBTOUI(uc-DECPMAX)&dmask[(-drop)%4])!=0)\n \t    return decInvalid(result, set);\n \t  break;    /* no need for loop end test */\n \t  }\n-\tif (ui>=&UINTAT(BUFOFF+DECPMAX+(-drop)-4)) break; /* done */\n+\tif (uc>=BUFOFF+DECPMAX+(-drop)-4) break;  /* done */\n \t}\n       ulsd=BUFOFF+DECPMAX+(-drop)-1;\n       } /* pad and check leading zeros */\n@@ -3045,7 +3183,7 @@ decFloat * decFloatQuantize(decFloat *result,\n /* decFloatReduce -- reduce finite coefficient to minimum length      */\n /*\t\t\t\t\t\t\t\t      */\n /*   result gets the reduced decFloat\t\t\t\t      */\n-/*   df\t    is the source decFloat\t\t\t\t      */\n+/*   df     is the source decFloat\t\t\t\t      */\n /*   set    is the context\t\t\t\t\t      */\n /*   returns result, which will be canonical\t\t\t      */\n /*\t\t\t\t\t\t\t\t      */\n@@ -3085,7 +3223,7 @@ decFloat * decFloatReduce(decFloat *result, const decFloat *df,\n /* decFloatRemainder -- integer divide and return remainder\t      */\n /*\t\t\t\t\t\t\t\t      */\n /*   result gets the remainder of dividing dfl by dfr:\t\t      */\n-/*   dfl    is the first decFloat (lhs)\t\t\t\t      */\n+/*   dfl    is the first decFloat (lhs) \t\t\t      */\n /*   dfr    is the second decFloat (rhs)\t\t\t      */\n /*   set    is the context\t\t\t\t\t      */\n /*   returns result\t\t\t\t\t\t      */\n@@ -3101,7 +3239,7 @@ decFloat * decFloatRemainder(decFloat *result,\n /* decFloatRemainderNear -- integer divide to nearest and remainder   */\n /*\t\t\t\t\t\t\t\t      */\n /*   result gets the remainder of dividing dfl by dfr:\t\t      */\n-/*   dfl    is the first decFloat (lhs)\t\t\t\t      */\n+/*   dfl    is the first decFloat (lhs) \t\t\t      */\n /*   dfr    is the second decFloat (rhs)\t\t\t      */\n /*   set    is the context\t\t\t\t\t      */\n /*   returns result\t\t\t\t\t\t      */\n@@ -3145,7 +3283,7 @@ decFloat * decFloatRotate(decFloat *result,\n   if (DFISNAN(dfl)||DFISNAN(dfr)) return decNaNs(result, dfl, dfr, set);\n   if (!DFISINT(dfr)) return decInvalid(result, set);\n   digits=decFloatDigits(dfr);\t\t\t /* calculate digits */\n-  if (digits>2) return decInvalid(result, set);\t /* definitely out of range */\n+  if (digits>2) return decInvalid(result, set);  /* definitely out of range */\n   rotate=DPD2BIN[DFWORD(dfr, DECWORDS-1)&0x3ff]; /* is in bottom declet */\n   if (rotate>DECPMAX) return decInvalid(result, set); /* too big */\n   /* [from here on no error or status change is possible] */\n@@ -3178,16 +3316,16 @@ decFloat * decFloatRotate(decFloat *result,\n   num.lsd=num.msd+DECPMAX-1;\n   num.sign=DFWORD(dfl, 0)&DECFLOAT_Sign;\n   num.exponent=GETEXPUN(dfl);\n-  savestat=set->status;\t\t\t/* record */\n+  savestat=set->status; \t\t/* record */\n   decFinalize(result, &num, set);\n-  set->status=savestat;\t\t\t/* restore */\n+  set->status=savestat; \t\t/* restore */\n   return result;\n   } /* decFloatRotate */\n \n /* ------------------------------------------------------------------ */\n /* decFloatSameQuantum -- test decFloats for same quantum\t      */\n /*\t\t\t\t\t\t\t\t      */\n-/*   dfl    is the first decFloat (lhs)\t\t\t\t      */\n+/*   dfl    is the first decFloat (lhs) \t\t\t      */\n /*   dfr    is the second decFloat (rhs)\t\t\t      */\n /*   returns 1 if the operands have the same quantum, 0 otherwise     */\n /*\t\t\t\t\t\t\t\t      */\n@@ -3204,11 +3342,11 @@ uInt decFloatSameQuantum(const decFloat *dfl, const decFloat *dfr) {\n   } /* decFloatSameQuantum */\n \n /* ------------------------------------------------------------------ */\n-/* decFloatScaleB -- multiply by a power of 10, as per 754r\t      */\n+/* decFloatScaleB -- multiply by a power of 10, as per 754\t      */\n /*\t\t\t\t\t\t\t\t      */\n /*   result gets the result of the operation\t\t\t      */\n-/*   dfl    is the first decFloat (lhs)\t\t\t\t      */\n-/*   dfr    is the second decFloat (rhs), am integer (with q=0)\t      */\n+/*   dfl    is the first decFloat (lhs) \t\t\t      */\n+/*   dfr    is the second decFloat (rhs), am integer (with q=0)       */\n /*   set    is the context\t\t\t\t\t      */\n /*   returns result\t\t\t\t\t\t      */\n /*\t\t\t\t\t\t\t\t      */\n@@ -3229,10 +3367,10 @@ decFloat * decFloatScaleB(decFloat *result,\n   digits=decFloatDigits(dfr);\t\t     /* calculate digits */\n \n   #if DOUBLE\n-  if (digits>3) return decInvalid(result, set);\t  /* definitely out of range */\n+  if (digits>3) return decInvalid(result, set);   /* definitely out of range */\n   expr=DPD2BIN[DFWORD(dfr, 1)&0x3ff];\t\t  /* must be in bottom declet */\n   #elif QUAD\n-  if (digits>5) return decInvalid(result, set);\t  /* definitely out of range */\n+  if (digits>5) return decInvalid(result, set);   /* definitely out of range */\n   expr=DPD2BIN[DFWORD(dfr, 3)&0x3ff]\t\t  /* in bottom 2 declets .. */\n       +DPD2BIN[(DFWORD(dfr, 3)>>10)&0x3ff]*1000;  /* .. */\n   #endif\n@@ -3241,7 +3379,7 @@ decFloat * decFloatScaleB(decFloat *result,\n   if (DFISINF(dfl)) return decInfinity(result, dfl);   /* canonical */\n   if (DFISSIGNED(dfr)) expr=-expr;\n   /* dfl is finite and expr is valid */\n-  *result=*dfl;\t\t\t\t     /* copy to target */\n+  *result=*dfl; \t\t\t     /* copy to target */\n   return decFloatSetExponent(result, set, GETEXPUN(result)+expr);\n   } /* decFloatScaleB */\n \n@@ -3266,23 +3404,24 @@ decFloat * decFloatScaleB(decFloat *result,\n decFloat * decFloatShift(decFloat *result,\n \t\t\t const decFloat *dfl, const decFloat *dfr,\n \t\t\t decContext *set) {\n-  Int shift;\t\t\t\t/* dfr as an Int */\n-  uByte buf[DECPMAX*2];\t\t\t/* coefficient + padding */\n-  uInt digits, savestat;\t\t/* work */\n+  Int\t shift; \t\t\t/* dfr as an Int */\n+  uByte  buf[DECPMAX*2];\t\t/* coefficient + padding */\n+  uInt\t digits, savestat;\t\t/* work */\n   bcdnum num;\t\t\t\t/* .. */\n+  uInt\t uiwork;\t\t\t/* for macros */\n \n   if (DFISNAN(dfl)||DFISNAN(dfr)) return decNaNs(result, dfl, dfr, set);\n   if (!DFISINT(dfr)) return decInvalid(result, set);\n   digits=decFloatDigits(dfr);\t\t\t  /* calculate digits */\n-  if (digits>2) return decInvalid(result, set);\t  /* definitely out of range */\n-  shift=DPD2BIN[DFWORD(dfr, DECWORDS-1)&0x3ff];\t  /* is in bottom declet */\n+  if (digits>2) return decInvalid(result, set);   /* definitely out of range */\n+  shift=DPD2BIN[DFWORD(dfr, DECWORDS-1)&0x3ff];   /* is in bottom declet */\n   if (shift>DECPMAX) return decInvalid(result, set);   /* too big */\n   /* [from here on no error or status change is possible] */\n \n   if (DFISINF(dfl)) return decInfinity(result, dfl); /* canonical */\n   /* handle no-shift and all-shift (clear to zero) cases */\n   if (shift==0) return decCanonical(result, dfl);\n-  if (shift==DECPMAX) {\t\t\t     /* zero with sign */\n+  if (shift==DECPMAX) { \t\t     /* zero with sign */\n     uByte sign=(uByte)(DFBYTE(dfl, 0)&0x80); /* save sign bit */\n     decFloatZero(result);\t\t     /* make +0 */\n     DFBYTE(result, 0)=(uByte)(DFBYTE(result, 0)|sign); /* and set sign */\n@@ -3299,23 +3438,23 @@ decFloat * decFloatShift(decFloat *result,\n     num.lsd=buf+DECPMAX-shift-1;\n     }\n    else { /* shift left -- zero padding needed to right */\n-    UINTAT(buf+DECPMAX)=0;\t\t/* 8 will handle most cases */\n-    UINTAT(buf+DECPMAX+4)=0;\t\t/* .. */\n+    UBFROMUI(buf+DECPMAX, 0);\t\t/* 8 will handle most cases */\n+    UBFROMUI(buf+DECPMAX+4, 0); \t/* .. */\n     if (shift>8) memset(buf+DECPMAX+8, 0, 8+QUAD*18); /* all other cases */\n     num.msd+=shift;\n     num.lsd=num.msd+DECPMAX-1;\n     }\n-  savestat=set->status;\t\t\t/* record */\n+  savestat=set->status; \t\t/* record */\n   decFinalize(result, &num, set);\n-  set->status=savestat;\t\t\t/* restore */\n+  set->status=savestat; \t\t/* restore */\n   return result;\n   } /* decFloatShift */\n \n /* ------------------------------------------------------------------ */\n-/* decFloatSubtract -- subtract a decFloat from another\t\t      */\n+/* decFloatSubtract -- subtract a decFloat from another \t      */\n /*\t\t\t\t\t\t\t\t      */\n /*   result gets the result of subtracting dfr from dfl:\t      */\n-/*   dfl    is the first decFloat (lhs)\t\t\t\t      */\n+/*   dfl    is the first decFloat (lhs) \t\t\t      */\n /*   dfr    is the second decFloat (rhs)\t\t\t      */\n /*   set    is the context\t\t\t\t\t      */\n /*   returns result\t\t\t\t\t\t      */\n@@ -3333,9 +3472,9 @@ decFloat * decFloatSubtract(decFloat *result,\n   } /* decFloatSubtract */\n \n /* ------------------------------------------------------------------ */\n-/* decFloatToInt -- round to 32-bit binary integer (4 flavours)\t      */\n+/* decFloatToInt -- round to 32-bit binary integer (4 flavours)       */\n /*\t\t\t\t\t\t\t\t      */\n-/*   df\t   is the decFloat to round\t\t\t\t      */\n+/*   df    is the decFloat to round\t\t\t\t      */\n /*   set   is the context\t\t\t\t\t      */\n /*   round is the rounding mode to use\t\t\t\t      */\n /*   returns a uInt or an Int, rounded according to the name\t      */\n@@ -3361,12 +3500,12 @@ Int decFloatToInt32Exact(const decFloat *df, decContext *set,\n   return (Int)decToInt32(df, set, round, 1, 0);}\n \n /* ------------------------------------------------------------------ */\n-/* decFloatToIntegral -- round to integral value (two flavours)\t      */\n+/* decFloatToIntegral -- round to integral value (two flavours)       */\n /*\t\t\t\t\t\t\t\t      */\n /*   result gets the result\t\t\t\t\t      */\n-/*   df\t    is the decFloat to round\t\t\t\t      */\n+/*   df     is the decFloat to round\t\t\t\t      */\n /*   set    is the context\t\t\t\t\t      */\n-/*   round  is the rounding mode to use\t\t\t\t      */\n+/*   round  is the rounding mode to use \t\t\t      */\n /*   returns result\t\t\t\t\t\t      */\n /*\t\t\t\t\t\t\t\t      */\n /* No exceptions, even Inexact, are raised except for sNaN input, or  */\n@@ -3384,12 +3523,12 @@ decFloat * decFloatToIntegralExact(decFloat *result, const decFloat *df,\n /* decFloatXor -- logical digitwise XOR of two decFloats\t      */\n /*\t\t\t\t\t\t\t\t      */\n /*   result gets the result of XORing dfl and dfr\t\t      */\n-/*   dfl    is the first decFloat (lhs)\t\t\t\t      */\n+/*   dfl    is the first decFloat (lhs) \t\t\t      */\n /*   dfr    is the second decFloat (rhs)\t\t\t      */\n /*   set    is the context\t\t\t\t\t      */\n /*   returns result, which will be canonical with sign=0\t      */\n /*\t\t\t\t\t\t\t\t      */\n-/* The operands must be positive, finite with exponent q=0, and\t      */\n+/* The operands must be positive, finite with exponent q=0, and       */\n /* comprise just zeros and ones; if not, Invalid operation results.   */\n /* ------------------------------------------------------------------ */\n decFloat * decFloatXor(decFloat *result,\n@@ -3432,14 +3571,14 @@ static decFloat *decInvalid(decFloat *result, decContext *set) {\n /* decInfinity -- set canonical Infinity with sign from a decFloat    */\n /*\t\t\t\t\t\t\t\t      */\n /*   result gets a canonical Infinity\t\t\t\t      */\n-/*   df\t    is source decFloat (only the sign is used)\t\t      */\n+/*   df     is source decFloat (only the sign is used)\t\t      */\n /*   returns result\t\t\t\t\t\t      */\n /*\t\t\t\t\t\t\t\t      */\n-/* df may be the same as result\t\t\t\t\t      */\n+/* df may be the same as result \t\t\t\t      */\n /* ------------------------------------------------------------------ */\n static decFloat *decInfinity(decFloat *result, const decFloat *df) {\n   uInt sign=DFWORD(df, 0);\t   /* save source signword */\n-  decFloatZero(result);\t\t   /* clear everything */\n+  decFloatZero(result); \t   /* clear everything */\n   DFWORD(result, 0)=DECFLOAT_Inf | (sign & DECFLOAT_Sign);\n   return result;\n   } /* decInfinity */\n@@ -3449,7 +3588,7 @@ static decFloat *decInfinity(decFloat *result, const decFloat *df) {\n /*\t\t\t\t\t\t\t\t      */\n /*   result gets the result of handling dfl and dfr, one or both of   */\n /*\t    which is a NaN\t\t\t\t\t      */\n-/*   dfl    is the first decFloat (lhs)\t\t\t\t      */\n+/*   dfl    is the first decFloat (lhs) \t\t\t      */\n /*   dfr    is the second decFloat (rhs) -- may be NULL for a single- */\n /*\t    operand operation\t\t\t\t\t      */\n /*   set    is the context\t\t\t\t\t      */\n@@ -3476,19 +3615,20 @@ static decFloat *decNaNs(decFloat *result,\n   } /* decNaNs */\n \n /* ------------------------------------------------------------------ */\n-/* decNumCompare -- numeric comparison of two decFloats\t\t      */\n+/* decNumCompare -- numeric comparison of two decFloats \t      */\n /*\t\t\t\t\t\t\t\t      */\n /*   dfl    is the left-hand decFloat, which is not a NaN\t      */\n /*   dfr    is the right-hand decFloat, which is not a NaN\t      */\n /*   tot    is 1 for total order compare, 0 for simple numeric\t      */\n-/*   returns -1, 0, or +1 for dfl<dfr, dfl=dfr, dfl>dfr\t\t      */\n+/*   returns -1, 0, or +1 for dfl<dfr, dfl=dfr, dfl>dfr \t      */\n /*\t\t\t\t\t\t\t\t      */\n-/* No error is possible; status and mode are unchanged.\t\t      */\n+/* No error is possible; status and mode are unchanged. \t      */\n /* ------------------------------------------------------------------ */\n static Int decNumCompare(const decFloat *dfl, const decFloat *dfr, Flag tot) {\n   Int\tsigl, sigr;\t\t\t/* LHS and RHS non-0 signums */\n   Int\tshift;\t\t\t\t/* shift needed to align operands */\n   uByte *ub, *uc;\t\t\t/* work */\n+  uInt\tuiwork; \t\t\t/* for macros */\n   /* buffers +2 if Quad (36 digits), need double plus 4 for safe padding */\n   uByte bufl[DECPMAX*2+QUAD*2+4];\t/* for LHS coefficient + padding */\n   uByte bufr[DECPMAX*2+QUAD*2+4];\t/* for RHS coefficient + padding */\n@@ -3512,7 +3652,7 @@ static Int decNumCompare(const decFloat *dfl, const decFloat *dfr, Flag tot) {\n   sigr=-sigl;\t\t\t\t/* sign to return if abs(RHS) wins */\n \n   if (DFISINF(dfl)) {\n-    if (DFISINF(dfr)) return 0;\t\t/* both infinite & same sign */\n+    if (DFISINF(dfr)) return 0; \t/* both infinite & same sign */\n     return sigl;\t\t\t/* inf > n */\n     }\n   if (DFISINF(dfr)) return sigr;\t/* n < inf [dfl is finite] */\n@@ -3544,17 +3684,16 @@ static Int decNumCompare(const decFloat *dfl, const decFloat *dfr, Flag tot) {\n   /* decode the coefficients */\n   /* (shift both right two if Quad to make a multiple of four) */\n   #if QUAD\n-    ub=bufl;                            /* avoid type-pun violation */\n-    UINTAT(ub)=0;\n-    uc=bufr;                            /* avoid type-pun violation */\n-    UINTAT(uc)=0;\n+    UBFROMUI(bufl, 0);\n+    UBFROMUI(bufr, 0);\n   #endif\n   GETCOEFF(dfl, bufl+QUAD*2);\t\t/* decode from decFloat */\n   GETCOEFF(dfr, bufr+QUAD*2);\t\t/* .. */\n   if (shift==0) {\t\t\t/* aligned; common and easy */\n     /* all multiples of four, here */\n     for (ub=bufl, uc=bufr; ub<bufl+DECPMAX+QUAD*2; ub+=4, uc+=4) {\n-      if (UINTAT(ub)==UINTAT(uc)) continue; /* so far so same */\n+      uInt ui=UBTOUI(ub);\n+      if (ui==UBTOUI(uc)) continue;\t/* so far so same */\n       /* about to find a winner; go by bytes in case little-endian */\n       for (;; ub++, uc++) {\n \tif (*ub>*uc) return sigl;\t/* difference found */\n@@ -3565,17 +3704,17 @@ static Int decNumCompare(const decFloat *dfl, const decFloat *dfr, Flag tot) {\n    else if (shift>0) {\t\t\t/* lhs to left */\n     ub=bufl;\t\t\t\t/* RHS pointer */\n     /* pad bufl so right-aligned; most shifts will fit in 8 */\n-    UINTAT(bufl+DECPMAX+QUAD*2)=0;\t/* add eight zeros */\n-    UINTAT(bufl+DECPMAX+QUAD*2+4)=0;\t/* .. */\n+    UBFROMUI(bufl+DECPMAX+QUAD*2, 0);\t/* add eight zeros */\n+    UBFROMUI(bufl+DECPMAX+QUAD*2+4, 0); /* .. */\n     if (shift>8) {\n       /* more than eight; fill the rest, and also worth doing the */\n       /* lead-in by fours */\n-      uByte *up;\t\t\t /* work */\n+      uByte *up;\t\t\t/* work */\n       uByte *upend=bufl+DECPMAX+QUAD*2+shift;\n-      for (up=bufl+DECPMAX+QUAD*2+8; up<upend; up+=4) UINTAT(up)=0;\n+      for (up=bufl+DECPMAX+QUAD*2+8; up<upend; up+=4) UBFROMUI(up, 0);\n       /* [pads up to 36 in all for Quad] */\n       for (;; ub+=4) {\n-\tif (UINTAT(ub)!=0) return sigl;\n+\tif (UBTOUI(ub)!=0) return sigl;\n \tif (ub+4>bufl+shift-4) break;\n \t}\n       }\n@@ -3585,7 +3724,8 @@ static Int decNumCompare(const decFloat *dfl, const decFloat *dfr, Flag tot) {\n     /* comparison can go for the full length of bufr, which is a */\n     /* multiple of 4 bytes */\n     for (uc=bufr; ; uc+=4, ub+=4) {\n-      if (UINTAT(uc)!=UINTAT(ub)) {\t/* mismatch found */\n+      uInt ui=UBTOUI(ub);\n+      if (ui!=UBTOUI(uc)) {\t\t/* mismatch found */\n \tfor (;; uc++, ub++) {\t\t/* check from left [little-endian?] */\n \t  if (*ub>*uc) return sigl;\t/* difference found */\n \t  if (*ub<*uc) return sigr;\t/* .. */\n@@ -3598,17 +3738,17 @@ static Int decNumCompare(const decFloat *dfl, const decFloat *dfr, Flag tot) {\n    else { /* shift<0) .. RHS is to left of LHS; mirror shift>0 */\n     uc=bufr;\t\t\t\t/* RHS pointer */\n     /* pad bufr so right-aligned; most shifts will fit in 8 */\n-    UINTAT(bufr+DECPMAX+QUAD*2)=0;\t/* add eight zeros */\n-    UINTAT(bufr+DECPMAX+QUAD*2+4)=0;\t/* .. */\n+    UBFROMUI(bufr+DECPMAX+QUAD*2, 0);\t/* add eight zeros */\n+    UBFROMUI(bufr+DECPMAX+QUAD*2+4, 0); /* .. */\n     if (shift<-8) {\n       /* more than eight; fill the rest, and also worth doing the */\n       /* lead-in by fours */\n-      uByte *up;\t\t\t /* work */\n+      uByte *up;\t\t\t/* work */\n       uByte *upend=bufr+DECPMAX+QUAD*2-shift;\n-      for (up=bufr+DECPMAX+QUAD*2+8; up<upend; up+=4) UINTAT(up)=0;\n+      for (up=bufr+DECPMAX+QUAD*2+8; up<upend; up+=4) UBFROMUI(up, 0);\n       /* [pads up to 36 in all for Quad] */\n       for (;; uc+=4) {\n-\tif (UINTAT(uc)!=0) return sigr;\n+\tif (UBTOUI(uc)!=0) return sigr;\n \tif (uc+4>bufr-shift-4) break;\n \t}\n       }\n@@ -3618,7 +3758,8 @@ static Int decNumCompare(const decFloat *dfl, const decFloat *dfr, Flag tot) {\n     /* comparison can go for the full length of bufl, which is a */\n     /* multiple of 4 bytes */\n     for (ub=bufl; ; ub+=4, uc+=4) {\n-      if (UINTAT(ub)!=UINTAT(uc)) {\t/* mismatch found */\n+      uInt ui=UBTOUI(ub);\n+      if (ui!=UBTOUI(uc)) {\t\t/* mismatch found */\n \tfor (;; ub++, uc++) {\t\t/* check from left [little-endian?] */\n \t  if (*ub>*uc) return sigl;\t/* difference found */\n \t  if (*ub<*uc) return sigr;\t/* .. */\n@@ -3639,10 +3780,10 @@ static Int decNumCompare(const decFloat *dfl, const decFloat *dfr, Flag tot) {\n /* ------------------------------------------------------------------ */\n /* decToInt32 -- local routine to effect ToInteger conversions\t      */\n /*\t\t\t\t\t\t\t\t      */\n-/*   df\t    is the decFloat to convert\t\t\t\t      */\n+/*   df     is the decFloat to convert\t\t\t\t      */\n /*   set    is the context\t\t\t\t\t      */\n-/*   rmode  is the rounding mode to use\t\t\t\t      */\n-/*   exact  is 1 if Inexact should be signalled\t\t\t      */\n+/*   rmode  is the rounding mode to use \t\t\t      */\n+/*   exact  is 1 if Inexact should be signalled \t\t      */\n /*   unsign is 1 if the result a uInt, 0 if an Int (cast to uInt)     */\n /*   returns 32-bit result as a uInt\t\t\t\t      */\n /*\t\t\t\t\t\t\t\t      */\n@@ -3652,13 +3793,13 @@ static Int decNumCompare(const decFloat *dfl, const decFloat *dfr, Flag tot) {\n static uInt decToInt32(const decFloat *df, decContext *set,\n \t\t       enum rounding rmode, Flag exact, Flag unsign) {\n   Int  exp;\t\t\t   /* exponent */\n-  uInt sourhi, sourpen, sourlo;\t   /* top word from source decFloat .. */\n+  uInt sourhi, sourpen, sourlo;    /* top word from source decFloat .. */\n   uInt hi, lo;\t\t\t   /* .. penultimate, least, etc. */\n   decFloat zero, result;\t   /* work */\n   Int  i;\t\t\t   /* .. */\n \n   /* Start decoding the argument */\n-  sourhi=DFWORD(df, 0);\t\t\t/* top word */\n+  sourhi=DFWORD(df, 0); \t\t/* top word */\n   exp=DECCOMBEXP[sourhi>>26];\t\t/* get exponent high bits (in place) */\n   if (EXPISSPECIAL(exp)) {\t\t/* is special? */\n     set->status|=DEC_Invalid_operation; /* signal */\n@@ -3730,10 +3871,10 @@ static uInt decToInt32(const decFloat *df, decContext *set,\n /* decToIntegral -- local routine to effect ToIntegral value\t      */\n /*\t\t\t\t\t\t\t\t      */\n /*   result gets the result\t\t\t\t\t      */\n-/*   df\t    is the decFloat to round\t\t\t\t      */\n+/*   df     is the decFloat to round\t\t\t\t      */\n /*   set    is the context\t\t\t\t\t      */\n-/*   rmode  is the rounding mode to use\t\t\t\t      */\n-/*   exact  is 1 if Inexact should be signalled\t\t\t      */\n+/*   rmode  is the rounding mode to use \t\t\t      */\n+/*   exact  is 1 if Inexact should be signalled \t\t      */\n /*   returns result\t\t\t\t\t\t      */\n /* ------------------------------------------------------------------ */\n static decFloat * decToIntegral(decFloat *result, const decFloat *df,\n@@ -3746,7 +3887,7 @@ static decFloat * decToIntegral(decFloat *result, const decFloat *df,\n   decFloat zero;\t\t   /* work */\n \n   /* Start decoding the argument */\n-  sourhi=DFWORD(df, 0);\t\t   /* top word */\n+  sourhi=DFWORD(df, 0); \t   /* top word */\n   exp=DECCOMBEXP[sourhi>>26];\t   /* get exponent high bits (in place) */\n \n   if (EXPISSPECIAL(exp)) {\t   /* is special? */\n@@ -3762,12 +3903,12 @@ static decFloat * decToIntegral(decFloat *result, const decFloat *df,\n \n   if (exp>=0) return decCanonical(result, df); /* already integral */\n \n-  saveround=set->round;\t\t\t/* save rounding mode .. */\n+  saveround=set->round; \t\t/* save rounding mode .. */\n   savestatus=set->status;\t\t/* .. and status */\n   set->round=rmode;\t\t\t/* set mode */\n   decFloatZero(&zero);\t\t\t/* make 0E+0 */\n   decFloatQuantize(result, df, &zero, set); /* 'integrate'; cannot fail */\n-  set->round=saveround;\t\t\t/* restore rounding mode .. */\n+  set->round=saveround; \t\t/* restore rounding mode .. */\n   if (!exact) set->status=savestatus;\t/* .. and status, unless exact */\n   return result;\n   } /* decToIntegral */"}, {"sha": "845b9143d616f8aeb312c32c1b83405494f90c30", "filename": "libdecnumber/decCommon.c", "status": "modified", "additions": 254, "deletions": 177, "changes": 431, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f988ec96d922819a4948c1ed96c6dc1b79a7ad22/libdecnumber%2FdecCommon.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f988ec96d922819a4948c1ed96c6dc1b79a7ad22/libdecnumber%2FdecCommon.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libdecnumber%2FdecCommon.c?ref=f988ec96d922819a4948c1ed96c6dc1b79a7ad22", "patch": "@@ -104,15 +104,15 @@ static decFloat * decFinalize(decFloat *, bcdnum *, decContext *);\n static Flag decBiStr(const char *, const char *, const char *);\n \n /* Macros and private tables; those which are not format-dependent    */\n-/* are only included if decQuad is being built.\t\t\t      */\n+/* are only included if decQuad is being built. \t\t      */\n \n /* ------------------------------------------------------------------ */\n /* Combination field lookup tables (uInts to save measurable work)    */\n /*\t\t\t\t\t\t\t\t      */\n-/*   DECCOMBEXP\t - 2 most-significant-bits of exponent (00, 01, or    */\n+/*   DECCOMBEXP  - 2 most-significant-bits of exponent (00, 01, or    */\n /*\t\t   10), shifted left for format, or DECFLOAT_Inf/NaN  */\n /*   DECCOMBWEXP - The same, for the next-wider format (unless QUAD)  */\n-/*   DECCOMBMSD\t - 4-bit most-significant-digit\t\t\t      */\n+/*   DECCOMBMSD  - 4-bit most-significant-digit \t\t      */\n /*\t\t   [0 if the index is a special (Infinity or NaN)]    */\n /*   DECCOMBFROM - 5-bit combination field from EXP top bits and MSD  */\n /*\t\t   (placed in uInt so no shift is needed)\t      */\n@@ -123,7 +123,7 @@ static Flag decBiStr(const char *, const char *, const char *);\n /* DECCOMBFROM is indexed by expTopTwoBits*16 + msd\t\t      */\n /*\t\t\t\t\t\t\t\t      */\n /* DECCOMBMSD and DECCOMBFROM are not format-dependent and so are     */\n-/* only included once, when QUAD is being built\t\t\t      */\n+/* only included once, when QUAD is being built \t\t      */\n /* ------------------------------------------------------------------ */\n static const uInt DECCOMBEXP[64]={\n   0, 0, 0, 0, 0, 0, 0, 0,\n@@ -161,7 +161,7 @@ static const uInt DECCOMBWEXP[64]={\n #if QUAD\n const uInt DECCOMBMSD[64]={\n   0, 1, 2, 3, 4, 5, 6, 7, 0, 1, 2, 3, 4, 5, 6, 7,\n-  0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 8, 9, 8, 9, 0, 1,\n+  0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 8, 9, 8, 9, 0, 0,\n   0, 1, 2, 3, 4, 5, 6, 7, 0, 1, 2, 3, 4, 5, 6, 7,\n   0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 8, 9, 8, 9, 0, 0};\n \n@@ -223,7 +223,7 @@ static Flag decBiStr(const char *targ, const char *str1, const char *str2) {\n /*  returns df\t\t\t\t\t\t\t      */\n /*\t\t\t\t\t\t\t\t      */\n /* The num descriptor may point to a bcd8 string of any length; this  */\n-/* string may have leading insignificant zeros.\t If it has more than  */\n+/* string may have leading insignificant zeros.  If it has more than  */\n /* DECPMAX digits then the final digit can be a round-for-reround     */\n /* digit (i.e., it may include a sticky bit residue).\t\t      */\n /*\t\t\t\t\t\t\t\t      */\n@@ -248,8 +248,9 @@ static decFloat * decFinalize(decFloat *df, bcdnum *num,\n \t\t\t      decContext *set) {\n   uByte *ub;\t\t      /* work */\n   uInt\t dpd;\t\t      /* .. */\n-  uByte *umsd=num->msd;\t      /* local copy */\n-  uByte *ulsd=num->lsd;\t      /* .. */\n+  uInt\t uiwork;\t      /* for macros */\n+  uByte *umsd=num->msd;       /* local copy */\n+  uByte *ulsd=num->lsd;       /* .. */\n   uInt\t encode;\t      /* encoding accumulator */\n   Int\t length;\t      /* coefficient length */\n \n@@ -275,11 +276,11 @@ static decFloat * decFinalize(decFloat *df, bcdnum *num,\n   length=(uInt)(ulsd-umsd+1);\t\t     /* coefficient length */\n \n   if (!NUMISSPECIAL(num)) {\n-    Int\t  drop;\t\t\t\t     /* digits to be dropped */\n+    Int   drop; \t\t\t     /* digits to be dropped */\n     /* skip leading insignificant zeros to calculate an exact length */\n     /* [this is quite expensive] */\n     if (*umsd==0) {\n-      for (; UINTAT(umsd)==0 && umsd+3<ulsd;) umsd+=4;\n+      for (; umsd+3<ulsd && UBTOUI(umsd)==0;) umsd+=4;\n       for (; *umsd==0 && umsd<ulsd;) umsd++;\n       length=ulsd-umsd+1;\t\t     /* recalculate */\n       }\n@@ -305,12 +306,12 @@ static decFloat * decFinalize(decFloat *df, bcdnum *num,\n \troundat=umsd+length-drop;\n \treround=*roundat;\n \tfor (ub=roundat+1; ub<=ulsd; ub++) {\n-\t  if (*ub!=0) {\t\t\t     /* non-zero to be discarded */\n+\t  if (*ub!=0) { \t\t     /* non-zero to be discarded */\n \t    reround=DECSTICKYTAB[reround];   /* apply sticky bit */\n \t    break;\t\t\t     /* [remainder don't-care] */\n \t    }\n \t  } /* check stickies */\n-\tulsd=roundat-1;\t\t\t     /* new LSD */\n+\tulsd=roundat-1; \t\t     /* new LSD */\n \t}\n        else {\t\t\t\t     /* edge case */\n \tif (drop==length) {\n@@ -322,7 +323,7 @@ static decFloat * decFinalize(decFloat *df, bcdnum *num,\n \t  reround=0;\n \t  }\n \tfor (ub=roundat+1; ub<=ulsd; ub++) {\n-\t  if (*ub!=0) {\t\t\t     /* non-zero to be discarded */\n+\t  if (*ub!=0) { \t\t     /* non-zero to be discarded */\n \t    reround=DECSTICKYTAB[reround];   /* apply sticky bit */\n \t    break;\t\t\t     /* [remainder don't-care] */\n \t    }\n@@ -331,7 +332,7 @@ static decFloat * decFinalize(decFloat *df, bcdnum *num,\n \tulsd=umsd;\t\t\t     /* .. */\n \t}\n \n-      if (reround!=0) {\t\t\t     /* discarding non-zero */\n+      if (reround!=0) { \t\t     /* discarding non-zero */\n \tuInt bump=0;\n \tset->status|=DEC_Inexact;\n \t/* if adjusted exponent [exp+digits-1] is < EMIN then num is */\n@@ -342,7 +343,7 @@ static decFloat * decFinalize(decFloat *df, bcdnum *num,\n \t/* next decide whether increment of the coefficient is needed */\n \tif (set->round==DEC_ROUND_HALF_EVEN) {\t  /* fastpath slowest case */\n \t  if (reround>5) bump=1;\t\t  /* >0.5 goes up */\n-\t   else if (reround==5)\t\t\t  /* exactly 0.5000 .. */\n+\t   else if (reround==5) \t\t  /* exactly 0.5000 .. */\n \t    bump=*ulsd & 0x01;\t\t\t  /* .. up iff [new] lsd is odd */\n \t  } /* r-h-e */\n \t else switch (set->round) {\n@@ -382,13 +383,15 @@ static decFloat * decFinalize(decFloat *df, bcdnum *num,\n \t    #endif\n \t    break;}\n \t  } /* switch (not r-h-e) */\n-\t/* printf(\"ReRound: %ld\t bump: %ld\\n\", (LI)reround, (LI)bump); */\n+\t/* printf(\"ReRound: %ld  bump: %ld\\n\", (LI)reround, (LI)bump); */\n \n \tif (bump!=0) {\t\t\t     /* need increment */\n \t  /* increment the coefficient; this might end up with 1000... */\n \t  /* (after the all nines case) */\n \t  ub=ulsd;\n-\t  for(; ub-3>=umsd && UINTAT(ub-3)==0x09090909; ub-=4) UINTAT(ub-3)=0;\n+\t  for(; ub-3>=umsd && UBTOUI(ub-3)==0x09090909; ub-=4)\t{\n+\t    UBFROMUI(ub-3, 0);\t\t     /* to 00000000 */\n+\t    }\n \t  /* [note ub could now be to left of msd, and it is not safe */\n \t  /* to write to the the left of the msd] */\n \t  /* now at most 3 digits left to non-9 (usually just the one) */\n@@ -436,7 +439,7 @@ static decFloat * decFinalize(decFloat *df, bcdnum *num,\n        else if ((num->exponent+length-1)>DECEMAX) { /* > Nmax */\n \t/* Overflow -- these could go straight to encoding, here, but */\n \t/* instead num is adjusted to keep the code cleaner */\n-\tFlag needmax=0;\t\t\t/* 1 for finite result */\n+\tFlag needmax=0; \t\t/* 1 for finite result */\n \tset->status|=(DEC_Overflow | DEC_Inexact);\n \tswitch (set->round) {\n \t  case DEC_ROUND_DOWN: {\n@@ -453,12 +456,12 @@ static decFloat * decFinalize(decFloat *df, bcdnum *num,\n \t    break;} /* r-f */\n \t  default: break;\t\t/* Infinity in all other cases */\n \t  }\n-\tif (!needmax) {\t\t\t/* easy .. set Infinity */\n+\tif (!needmax) { \t\t/* easy .. set Infinity */\n \t  num->exponent=DECFLOAT_Inf;\n \t  *umsd=0;\t\t\t/* be clean: coefficient to 0 */\n \t  ulsd=umsd;\t\t\t/* .. */\n \t  }\n-\t else {\t\t\t\t/* return Nmax */\n+\t else { \t\t\t/* return Nmax */\n \t  umsd=allnines;\t\t/* use constant array */\n \t  ulsd=allnines+DECPMAX-1;\n \t  num->exponent=DECEMAX-(DECPMAX-1);\n@@ -475,8 +478,8 @@ static decFloat * decFinalize(decFloat *df, bcdnum *num,\n \t  uByte *t=buffer;\t\t/* safe target */\n \t  uByte *tlsd=buffer+(ulsd-umsd)+shift; /* target LSD */\n \t  /* printf(\"folddown shift=%ld\\n\", (LI)shift); */\n-\t  for (; s<=ulsd; s+=4, t+=4) UINTAT(t)=UINTAT(s);\n-\t  for (t=tlsd-shift+1; t<=tlsd; t+=4) UINTAT(t)=0;  /* pad */\n+\t  for (; s<=ulsd; s+=4, t+=4) UBFROMUI(t, UBTOUI(s));\n+\t  for (t=tlsd-shift+1; t<=tlsd; t+=4) UBFROMUI(t, 0);  /* pad 0s */\n \t  num->exponent-=shift;\n \t  umsd=buffer;\n \t  ulsd=tlsd;\n@@ -492,23 +495,23 @@ static decFloat * decFinalize(decFloat *df, bcdnum *num,\n   /*------------------------------------------------------------------*/\n   /* Following code does not alter coefficient (could be allnines array) */\n \n+  /* fast path possible when DECPMAX digits */\n   if (length==DECPMAX) {\n     return decFloatFromBCD(df, num->exponent, umsd, num->sign);\n-    }\n+    } /* full-length */\n \n-  /* Here when length is short */\n+  /* slower path when not a full-length number; must care about length */\n+  /* [coefficient length here will be < DECPMAX] */\n   if (!NUMISSPECIAL(num)) {\t\t/* is still finite */\n     /* encode the combination field and exponent continuation */\n     uInt uexp=(uInt)(num->exponent+DECBIAS); /* biased exponent */\n     uInt code=(uexp>>DECECONL)<<4;\t/* top two bits of exp */\n-    /* [msd=0] */\n+    /* [msd==0] */\n     /* look up the combination field and make high word */\n     encode=DECCOMBFROM[code];\t\t/* indexed by (0-2)*16+msd */\n     encode|=(uexp<<(32-6-DECECONL)) & 0x03ffffff; /* exponent continuation */\n     }\n    else encode=num->exponent;\t\t/* special [already in word] */\n-  /* [coefficient length here will be < DECPMAX] */\n-\n   encode|=num->sign;\t\t\t/* add sign */\n \n   /* private macro to extract a declet, n (where 0<=n<DECLETS and 0 */\n@@ -519,7 +522,7 @@ static decFloat * decFinalize(decFloat *df, bcdnum *num,\n   /* working pointer, uInt *ub. */\n   /* As not full-length then chances are there are many leading zeros */\n   /* [and there may be a partial triad] */\n-  #define getDPD(dpd, n) ub=ulsd-(3*(n))-2;\t\t\t      \\\n+  #define getDPDt(dpd, n) ub=ulsd-(3*(n))-2;\t\t\t      \\\n     if (ub<umsd-2) dpd=0;\t\t\t\t\t      \\\n      else if (ub>=umsd) dpd=BCD2DPD[(*ub*256)+(*(ub+1)*16)+*(ub+2)];  \\\n      else {dpd=*(ub+2); if (ub+1==umsd) dpd+=*(ub+1)*16; dpd=BCD2DPD[dpd];}\n@@ -528,48 +531,48 @@ static decFloat * decFinalize(decFloat *df, bcdnum *num,\n   /* according to endianness; in all cases complete the sign word */\n   /* first */\n   #if DECPMAX==7\n-    getDPD(dpd, 1);\n+    getDPDt(dpd, 1);\n     encode|=dpd<<10;\n-    getDPD(dpd, 0);\n+    getDPDt(dpd, 0);\n     encode|=dpd;\n     DFWORD(df, 0)=encode;     /* just the one word */\n \n   #elif DECPMAX==16\n-    getDPD(dpd, 4); encode|=dpd<<8;\n-    getDPD(dpd, 3); encode|=dpd>>2;\n+    getDPDt(dpd, 4); encode|=dpd<<8;\n+    getDPDt(dpd, 3); encode|=dpd>>2;\n     DFWORD(df, 0)=encode;\n     encode=dpd<<30;\n-    getDPD(dpd, 2); encode|=dpd<<20;\n-    getDPD(dpd, 1); encode|=dpd<<10;\n-    getDPD(dpd, 0); encode|=dpd;\n+    getDPDt(dpd, 2); encode|=dpd<<20;\n+    getDPDt(dpd, 1); encode|=dpd<<10;\n+    getDPDt(dpd, 0); encode|=dpd;\n     DFWORD(df, 1)=encode;\n \n   #elif DECPMAX==34\n-    getDPD(dpd,10); encode|=dpd<<4;\n-    getDPD(dpd, 9); encode|=dpd>>6;\n+    getDPDt(dpd,10); encode|=dpd<<4;\n+    getDPDt(dpd, 9); encode|=dpd>>6;\n     DFWORD(df, 0)=encode;\n \n     encode=dpd<<26;\n-    getDPD(dpd, 8); encode|=dpd<<16;\n-    getDPD(dpd, 7); encode|=dpd<<6;\n-    getDPD(dpd, 6); encode|=dpd>>4;\n+    getDPDt(dpd, 8); encode|=dpd<<16;\n+    getDPDt(dpd, 7); encode|=dpd<<6;\n+    getDPDt(dpd, 6); encode|=dpd>>4;\n     DFWORD(df, 1)=encode;\n \n     encode=dpd<<28;\n-    getDPD(dpd, 5); encode|=dpd<<18;\n-    getDPD(dpd, 4); encode|=dpd<<8;\n-    getDPD(dpd, 3); encode|=dpd>>2;\n+    getDPDt(dpd, 5); encode|=dpd<<18;\n+    getDPDt(dpd, 4); encode|=dpd<<8;\n+    getDPDt(dpd, 3); encode|=dpd>>2;\n     DFWORD(df, 2)=encode;\n \n     encode=dpd<<30;\n-    getDPD(dpd, 2); encode|=dpd<<20;\n-    getDPD(dpd, 1); encode|=dpd<<10;\n-    getDPD(dpd, 0); encode|=dpd;\n+    getDPDt(dpd, 2); encode|=dpd<<20;\n+    getDPDt(dpd, 1); encode|=dpd<<10;\n+    getDPDt(dpd, 0); encode|=dpd;\n     DFWORD(df, 3)=encode;\n   #endif\n \n   /* printf(\"Status: %08lx\\n\", (LI)set->status); */\n-  /* decFloatShow(df, \"final\"); */\n+  /* decFloatShow(df, \"final2\"); */\n   return df;\n   } /* decFinalize */\n \n@@ -579,12 +582,12 @@ static decFloat * decFinalize(decFloat *df, bcdnum *num,\n /*  df is the target decFloat\t\t\t\t\t      */\n /*  exp is the in-range unbiased exponent, q, or a special value in   */\n /*    the form returned by decFloatGetExponent\t\t\t      */\n-/*  bcdar holds DECPMAX digits to set the coefficient from, one\t      */\n+/*  bcdar holds DECPMAX digits to set the coefficient from, one       */\n /*    digit in each byte (BCD8 encoding); the first (MSD) is ignored  */\n /*    if df is a NaN; all are ignored if df is infinite.\t      */\n-/*    All bytes must be in 0-9; results undefined otherwise.\t      */\n+/*    All bytes must be in 0-9; results are undefined otherwise.      */\n /*  sig is DECFLOAT_Sign to set the sign bit, 0 otherwise\t      */\n-/*  returns df, which will be canonical\t\t\t\t      */\n+/*  returns df, which will be canonical \t\t\t      */\n /*\t\t\t\t\t\t\t\t      */\n /* No error is possible, and no status will be set.\t\t      */\n /* ------------------------------------------------------------------ */\n@@ -609,53 +612,53 @@ decFloat * decFloatFromBCD(decFloat *df, Int exp, const uByte *bcdar,\n   /* and put the corresponding DPD code into dpd. */\n   /* Use of a working pointer, uInt *ub, is assumed. */\n \n-  #define getDPDf(dpd, n) ub=bcdar+DECPMAX-1-(3*(n))-2;\t    \\\n+  #define getDPDb(dpd, n) ub=bcdar+DECPMAX-1-(3*(n))-2;     \\\n     dpd=BCD2DPD[(*ub*256)+(*(ub+1)*16)+*(ub+2)];\n \n   /* place the declets in the encoding words and copy to result (df), */\n   /* according to endianness; in all cases complete the sign word */\n   /* first */\n   #if DECPMAX==7\n-    getDPDf(dpd, 1);\n+    getDPDb(dpd, 1);\n     encode|=dpd<<10;\n-    getDPDf(dpd, 0);\n+    getDPDb(dpd, 0);\n     encode|=dpd;\n     DFWORD(df, 0)=encode;     /* just the one word */\n \n   #elif DECPMAX==16\n-    getDPDf(dpd, 4); encode|=dpd<<8;\n-    getDPDf(dpd, 3); encode|=dpd>>2;\n+    getDPDb(dpd, 4); encode|=dpd<<8;\n+    getDPDb(dpd, 3); encode|=dpd>>2;\n     DFWORD(df, 0)=encode;\n     encode=dpd<<30;\n-    getDPDf(dpd, 2); encode|=dpd<<20;\n-    getDPDf(dpd, 1); encode|=dpd<<10;\n-    getDPDf(dpd, 0); encode|=dpd;\n+    getDPDb(dpd, 2); encode|=dpd<<20;\n+    getDPDb(dpd, 1); encode|=dpd<<10;\n+    getDPDb(dpd, 0); encode|=dpd;\n     DFWORD(df, 1)=encode;\n \n   #elif DECPMAX==34\n-    getDPDf(dpd,10); encode|=dpd<<4;\n-    getDPDf(dpd, 9); encode|=dpd>>6;\n+    getDPDb(dpd,10); encode|=dpd<<4;\n+    getDPDb(dpd, 9); encode|=dpd>>6;\n     DFWORD(df, 0)=encode;\n \n     encode=dpd<<26;\n-    getDPDf(dpd, 8); encode|=dpd<<16;\n-    getDPDf(dpd, 7); encode|=dpd<<6;\n-    getDPDf(dpd, 6); encode|=dpd>>4;\n+    getDPDb(dpd, 8); encode|=dpd<<16;\n+    getDPDb(dpd, 7); encode|=dpd<<6;\n+    getDPDb(dpd, 6); encode|=dpd>>4;\n     DFWORD(df, 1)=encode;\n \n     encode=dpd<<28;\n-    getDPDf(dpd, 5); encode|=dpd<<18;\n-    getDPDf(dpd, 4); encode|=dpd<<8;\n-    getDPDf(dpd, 3); encode|=dpd>>2;\n+    getDPDb(dpd, 5); encode|=dpd<<18;\n+    getDPDb(dpd, 4); encode|=dpd<<8;\n+    getDPDb(dpd, 3); encode|=dpd>>2;\n     DFWORD(df, 2)=encode;\n \n     encode=dpd<<30;\n-    getDPDf(dpd, 2); encode|=dpd<<20;\n-    getDPDf(dpd, 1); encode|=dpd<<10;\n-    getDPDf(dpd, 0); encode|=dpd;\n+    getDPDb(dpd, 2); encode|=dpd<<20;\n+    getDPDb(dpd, 1); encode|=dpd<<10;\n+    getDPDb(dpd, 0); encode|=dpd;\n     DFWORD(df, 3)=encode;\n   #endif\n-  /* decFloatShow(df, \"final\"); */\n+  /* decFloatShow(df, \"fromB\"); */\n   return df;\n   } /* decFloatFromBCD */\n \n@@ -671,7 +674,7 @@ decFloat * decFloatFromBCD(decFloat *df, Int exp, const uByte *bcdar,\n /*    and QUAD the first (pad) nibble is also ignored in all cases.   */\n /*    All coefficient nibbles must be in 0-9 and sign in A-F; results */\n /*    are undefined otherwise.\t\t\t\t\t      */\n-/*  returns df, which will be canonical\t\t\t\t      */\n+/*  returns df, which will be canonical \t\t\t      */\n /*\t\t\t\t\t\t\t\t      */\n /* No error is possible, and no status will be set.\t\t      */\n /* ------------------------------------------------------------------ */\n@@ -691,7 +694,7 @@ decFloat * decFloatFromPacked(decFloat *df, Int exp, const uByte *packed) {\n     *op++=*ip>>4;\n     *op++=(uByte)(*ip&0x0f);\t\t/* [final nibble is sign] */\n     }\n-  op--;\t\t\t\t\t/* -> sign byte */\n+  op--; \t\t\t\t/* -> sign byte */\n   if (*op==DECPMINUS || *op==DECPMINUSALT) sig=DECFLOAT_Sign;\n \n   if (EXPISSPECIAL(exp)) {\t\t/* Infinity or NaN */\n@@ -702,20 +705,84 @@ decFloat * decFloatFromPacked(decFloat *df, Int exp, const uByte *packed) {\n   } /* decFloatFromPacked */\n \n /* ------------------------------------------------------------------ */\n-/* decFloatFromString -- conversion from numeric string\t\t      */\n+/* decFloatFromPackedChecked -- set from exponent and packed; checked */\n+/*\t\t\t\t\t\t\t\t      */\n+/*  df is the target decFloat\t\t\t\t\t      */\n+/*  exp is the in-range unbiased exponent, q, or a special value in   */\n+/*    the form returned by decFloatGetExponent\t\t\t      */\n+/*  packed holds DECPMAX packed decimal digits plus a sign nibble     */\n+/*    (all 6 codes are OK); the first (MSD) must be 0 if df is a NaN  */\n+/*    and all digits must be 0 if df is infinite.  For DOUBLE and     */\n+/*    QUAD the first (pad) nibble must be 0.\t\t\t      */\n+/*    All coefficient nibbles must be in 0-9 and sign in A-F.\t      */\n+/*  returns df, which will be canonical or NULL if any of the\t      */\n+/*    requirements are not met (if this case df is unchanged); that   */\n+/*    is, the input data must be as returned by decFloatToPacked,     */\n+/*    except that all six sign codes are acccepted.\t\t      */\n+/*\t\t\t\t\t\t\t\t      */\n+/* No status will be set.\t\t\t\t\t      */\n+/* ------------------------------------------------------------------ */\n+decFloat * decFloatFromPackedChecked(decFloat *df, Int exp,\n+\t\t\t\t     const uByte *packed) {\n+  uByte bcdar[DECPMAX+2];\t\t/* work [+1 for pad, +1 for sign] */\n+  const uByte *ip;\t\t\t/* .. */\n+  uByte *op;\t\t\t\t/* .. */\n+  Int\tsig=0;\t\t\t\t/* sign */\n+\n+  /* expand coefficient and sign to BCDAR */\n+  #if SINGLE\n+  op=bcdar+1;\t\t\t\t/* no pad digit */\n+  #else\n+  op=bcdar;\t\t\t\t/* first (pad) digit here */\n+  #endif\n+  for (ip=packed; ip<packed+((DECPMAX+2)/2); ip++) {\n+    *op=*ip>>4;\n+    if (*op>9) return NULL;\n+    op++;\n+    *op=(uByte)(*ip&0x0f);\t\t/* [final nibble is sign] */\n+    if (*op>9 && ip<packed+((DECPMAX+2)/2)-1) return NULL;\n+    op++;\n+    }\n+  op--; \t\t\t\t/* -> sign byte */\n+  if (*op<=9) return NULL;\t\t/* bad sign */\n+  if (*op==DECPMINUS || *op==DECPMINUSALT) sig=DECFLOAT_Sign;\n+\n+  #if !SINGLE\n+  if (bcdar[0]!=0) return NULL; \t/* bad pad nibble */\n+  #endif\n+\n+  if (EXPISNAN(exp)) {\t\t\t/* a NaN */\n+    if (bcdar[1]!=0) return NULL;\t/* bad msd */\n+    } /* NaN */\n+   else if (EXPISINF(exp)) {\t\t/* is infinite */\n+    Int i;\n+    for (i=0; i<DECPMAX; i++) {\n+      if (bcdar[i+1]!=0) return NULL;\t/* should be all zeros */\n+      }\n+    } /* infinity */\n+   else {\t\t\t\t/* finite */\n+    /* check the exponent is in range */\n+    if (exp>DECEMAX-DECPMAX+1) return NULL;\n+    if (exp<DECEMIN-DECPMAX+1) return NULL;\n+    }\n+  return decFloatFromBCD(df, exp, bcdar+1, sig);\n+  } /* decFloatFromPacked */\n+\n+/* ------------------------------------------------------------------ */\n+/* decFloatFromString -- conversion from numeric string \t      */\n /*\t\t\t\t\t\t\t\t      */\n /*  result  is the decFloat format number which gets the result of    */\n /*\t    the conversion\t\t\t\t\t      */\n /*  *string is the character string which should contain a valid      */\n /*\t    number (which may be a special value), \\0-terminated      */\n /*\t    If there are too many significant digits in the\t      */\n /*\t    coefficient it will be rounded.\t\t\t      */\n-/*  set\t    is the context\t\t\t\t\t      */\n+/*  set     is the context\t\t\t\t\t      */\n /*  returns result\t\t\t\t\t\t      */\n /*\t\t\t\t\t\t\t\t      */\n /* The length of the coefficient and the size of the exponent are     */\n /* checked by this routine, so the correct error (Underflow or\t      */\n-/* Overflow) can be reported or rounding applied, as necessary.\t      */\n+/* Overflow) can be reported or rounding applied, as necessary.       */\n /*\t\t\t\t\t\t\t\t      */\n /* There is no limit to the coefficient length for finite inputs;     */\n /* NaN payloads must be integers with no more than DECPMAX-1 digits.  */\n@@ -726,20 +793,21 @@ decFloat * decFloatFromPacked(decFloat *df, Int exp, const uByte *packed) {\n decFloat * decFloatFromString(decFloat *result, const char *string,\n \t\t\t      decContext *set) {\n   Int\t digits;\t\t   /* count of digits in coefficient */\n-  const\t char *dotchar=NULL;\t   /* where dot was found [NULL if none] */\n-  const\t char *cfirst=string;\t   /* -> first character of decimal part */\n-  const\t char *c;\t\t   /* work */\n+  const  char *dotchar=NULL;\t   /* where dot was found [NULL if none] */\n+  const  char *cfirst=string;\t   /* -> first character of decimal part */\n+  const  char *c;\t\t   /* work */\n   uByte *ub;\t\t\t   /* .. */\n+  uInt\t uiwork;\t\t   /* for macros */\n   bcdnum num;\t\t\t   /* collects data for finishing */\n   uInt\t error=DEC_Conversion_syntax;\t/* assume the worst */\n-  uByte\t buffer[ROUNDUP(DECSTRING+11, 8)]; /* room for most coefficents, */\n+  uByte  buffer[ROUNDUP(DECSTRING+11, 8)]; /* room for most coefficents, */\n \t\t\t\t   /* some common rounding, +3, & pad */\n   #if DECTRACE\n   /* printf(\"FromString %s ...\\n\", string); */\n   #endif\n \n   for(;;) {\t\t\t\t/* once-only 'loop' */\n-    num.sign=0;\t\t\t\t/* assume non-negative */\n+    num.sign=0; \t\t\t/* assume non-negative */\n     num.msd=buffer;\t\t\t/* MSD is here always */\n \n     /* detect and validate the coefficient, including any leading, */\n@@ -810,7 +878,7 @@ decFloat * decFloatFromString(decFloat *result, const char *string,\n \texp-=(Int)(clast-dotchar);\t/* adjust exponent */\n \t/* [the '.' can now be ignored] */\n \t}\n-      num.exponent=exp;\t\t\t/* exponent is good; store it */\n+      num.exponent=exp; \t\t/* exponent is good; store it */\n \n       /* Here when whole string has been inspected and syntax is good */\n       /* cfirst->first digit or dot, clast->last digit or dot */\n@@ -832,8 +900,8 @@ decFloat * decFloatFromString(decFloat *result, const char *string,\n \t    /* as usual, go by fours when safe; NB it has been asserted */\n \t    /* that a '.' does not have the same mask as a digit */\n \t    if (c<=clast-3\t\t\t       /* safe for four */\n-\t     && (UINTAT(c)&0xf0f0f0f0)==CHARMASK) {    /* test four */\n-\t      UINTAT(ub)=UINTAT(c)&0x0f0f0f0f;\t       /* to BCD8 */\n+\t     && (UBTOUI(c)&0xf0f0f0f0)==CHARMASK) {    /* test four */\n+\t      UBFROMUI(ub, UBTOUI(c)&0x0f0f0f0f);      /* to BCD8 */\n \t      ub+=4;\n \t      c+=4;\n \t      continue;\n@@ -846,7 +914,7 @@ decFloat * decFloatFromString(decFloat *result, const char *string,\n \t    }\n \t  } /* had dot */\n \t/* Now no dot; do this by fours (where safe) */\n-\tfor (; c<=clast-3; c+=4, ub+=4) UINTAT(ub)=UINTAT(c)&0x0f0f0f0f;\n+\tfor (; c<=clast-3; c+=4, ub+=4) UBFROMUI(ub, UBTOUI(c)&0x0f0f0f0f);\n \tfor (; c<=clast; c++, ub++) *ub=(uByte)(*c-'0');\n \tnum.lsd=buffer+digits-1;\t     /* record new LSD */\n \t} /* fits */\n@@ -857,7 +925,7 @@ decFloat * decFloatFromString(decFloat *result, const char *string,\n \tif (*cfirst=='.') cfirst++;\t     /* step past dot at start */\n \tif (*cfirst=='0') {\t\t     /* [cfirst always -> digit] */\n \t  for (; cfirst<clast; cfirst++) {\n-\t    if (*cfirst!='0') {\t\t     /* non-zero found */\n+\t    if (*cfirst!='0') { \t     /* non-zero found */\n \t      if (*cfirst=='.') continue;    /* [ignore] */\n \t      break;\t\t\t     /* done */\n \t      }\n@@ -871,8 +939,8 @@ decFloat * decFloatFromString(decFloat *result, const char *string,\n \tfor (c=cfirst; c<=clast && ub<=buffer+DECPMAX; c++) {\n \t  /* (see commentary just above) */\n \t  if (c<=clast-3\t\t\t  /* safe for four */\n-\t   && (UINTAT(c)&0xf0f0f0f0)==CHARMASK) { /* four digits */\n-\t    UINTAT(ub)=UINTAT(c)&0x0f0f0f0f;\t  /* to BCD8 */\n+\t   && (UBTOUI(c)&0xf0f0f0f0)==CHARMASK) { /* four digits */\n+\t    UBFROMUI(ub, UBTOUI(c)&0x0f0f0f0f);   /* to BCD8 */\n \t    ub+=4;\n \t    c+=3;\t\t\t     /* [will become 4] */\n \t    continue;\n@@ -881,7 +949,7 @@ decFloat * decFloatFromString(decFloat *result, const char *string,\n \t  *ub++=(uByte)(*c-'0');\n \t  }\n \tub--;\t\t\t\t     /* -> LSD */\n-\tfor (; c<=clast; c++) {\t\t     /* inspect remaining chars */\n+\tfor (; c<=clast; c++) { \t     /* inspect remaining chars */\n \t  if (*c!='0') {\t\t     /* sticky bit needed */\n \t    if (*c=='.') continue;\t     /* [ignore] */\n \t    *ub=DECSTICKYTAB[*ub];\t     /* update round-for-reround */\n@@ -925,7 +993,7 @@ decFloat * decFloatFromString(decFloat *result, const char *string,\n \t    *ub=(uByte)(*c-'0');\t/* good bcd8 */\n \t    }\n \t  if (*c!='\\0') break;\t\t/* not all digits, or too many */\n-\t  num.lsd=ub-1;\t\t\t/* record new LSD */\n+\t  num.lsd=ub-1; \t\t/* record new LSD */\n \t  }\n \t} /* NaN or sNaN */\n       error=0;\t\t\t\t/* syntax is OK */\n@@ -938,8 +1006,8 @@ decFloat * decFloatFromString(decFloat *result, const char *string,\n \n   if (error!=0) {\n     set->status|=error;\n-    num.exponent=DECFLOAT_qNaN;\t\t/* set up quiet NaN */\n-    num.sign=0;\t\t\t\t/* .. with 0 sign */\n+    num.exponent=DECFLOAT_qNaN; \t/* set up quiet NaN */\n+    num.sign=0; \t\t\t/* .. with 0 sign */\n     buffer[0]=0;\t\t\t/* .. and coefficient */\n     num.lsd=buffer;\t\t\t/* .. */\n     /* decShowNum(&num, \"oops\"); */\n@@ -957,7 +1025,7 @@ decFloat * decFloatFromString(decFloat *result, const char *string,\n /*  result  is the decFloat format number which gets the result of    */\n /*\t    the conversion\t\t\t\t\t      */\n /*  wider   is the decFloatWider format number which will be narrowed */\n-/*  set\t    is the context\t\t\t\t\t      */\n+/*  set     is the context\t\t\t\t\t      */\n /*  returns result\t\t\t\t\t\t      */\n /*\t\t\t\t\t\t\t\t      */\n /* Narrowing can cause rounding, overflow, etc., but not Invalid      */\n@@ -968,7 +1036,7 @@ decFloat * decFloatFromString(decFloat *result, const char *string,\n decFloat * decFloatFromWider(decFloat *result, const decFloatWider *wider,\n \t\t\t     decContext *set) {\n   bcdnum num;\t\t\t\t/* collects data for finishing */\n-  uByte\t bcdar[DECWPMAX];\t\t/* room for wider coefficient */\n+  uByte  bcdar[DECWPMAX];\t\t/* room for wider coefficient */\n   uInt\t widerhi=DFWWORD(wider, 0);\t/* top word */\n   Int\t exp;\n \n@@ -979,7 +1047,7 @@ decFloat * decFloatFromWider(decFloat *result, const decFloatWider *wider,\n   num.sign=widerhi&0x80000000;\t\t/* extract sign [DECFLOAT_Sign=Neg] */\n \n   /* decode the wider combination field to exponent */\n-  exp=DECCOMBWEXP[widerhi>>26];\t\t/* decode from wider combination field */\n+  exp=DECCOMBWEXP[widerhi>>26]; \t/* decode from wider combination field */\n   /* if it is a special there's nothing to do unless sNaN; if it's */\n   /* finite then add the (wider) exponent continuation and unbias */\n   if (EXPISSPECIAL(exp)) exp=widerhi&0x7e000000; /* include sNaN selector */\n@@ -1001,7 +1069,7 @@ decFloat * decFloatFromWider(decFloat *result, const decFloatWider *wider,\n /*  returns the sign of the coefficient (DECFLOAT_Sign if negative,   */\n /*    0 otherwise)\t\t\t\t\t\t      */\n /*\t\t\t\t\t\t\t\t      */\n-/* No error is possible, and no status will be set.  If df is a\t      */\n+/* No error is possible, and no status will be set.  If df is a       */\n /* special value the array is set to zeros (for Infinity) or to the   */\n /* payload of a qNaN or sNaN.\t\t\t\t\t      */\n /* ------------------------------------------------------------------ */\n@@ -1015,12 +1083,12 @@ Int decFloatGetCoefficient(const decFloat *df, uByte *bcdar) {\n   } /* decFloatGetCoefficient */\n \n /* ------------------------------------------------------------------ */\n-/* decFloatGetExponent -- get unbiased exponent\t\t\t      */\n+/* decFloatGetExponent -- get unbiased exponent \t\t      */\n /*\t\t\t\t\t\t\t\t      */\n /*  df is the decFloat from which to extract the exponent\t      */\n /*  returns the exponent, q.\t\t\t\t\t      */\n /*\t\t\t\t\t\t\t\t      */\n-/* No error is possible, and no status will be set.  If df is a\t      */\n+/* No error is possible, and no status will be set.  If df is a       */\n /* special value the first seven bits of the decFloat are returned,   */\n /* left adjusted and with the first (sign) bit set to 0 (followed by  */\n /* 25 0 bits).\te.g., -sNaN would return 0x7e000000 (DECFLOAT_sNaN).  */\n@@ -1034,11 +1102,11 @@ Int decFloatGetExponent(const decFloat *df) {\n /* decFloatSetCoefficient -- set coefficient from BCD8\t\t      */\n /*\t\t\t\t\t\t\t\t      */\n /*  df is the target decFloat (and source of exponent/special value)  */\n-/*  bcdar holds DECPMAX digits to set the coefficient from, one\t      */\n+/*  bcdar holds DECPMAX digits to set the coefficient from, one       */\n /*    digit in each byte (BCD8 encoding); the first (MSD) is ignored  */\n /*    if df is a NaN; all are ignored if df is infinite.\t      */\n /*  sig is DECFLOAT_Sign to set the sign bit, 0 otherwise\t      */\n-/*  returns df, which will be canonical\t\t\t\t      */\n+/*  returns df, which will be canonical \t\t\t      */\n /*\t\t\t\t\t\t\t\t      */\n /* No error is possible, and no status will be set.\t\t      */\n /* ------------------------------------------------------------------ */\n@@ -1060,18 +1128,18 @@ decFloat * decFloatSetCoefficient(decFloat *df, const uByte *bcdar,\n   } /* decFloatSetCoefficient */\n \n /* ------------------------------------------------------------------ */\n-/* decFloatSetExponent -- set exponent or special value\t\t      */\n+/* decFloatSetExponent -- set exponent or special value \t      */\n /*\t\t\t\t\t\t\t\t      */\n /*  df\tis the target decFloat (and source of coefficient/payload)    */\n /*  set is the context for reporting status\t\t\t      */\n /*  exp is the unbiased exponent, q, or a special value in the form   */\n /*    returned by decFloatGetExponent\t\t\t\t      */\n-/*  returns df, which will be canonical\t\t\t\t      */\n+/*  returns df, which will be canonical \t\t\t      */\n /*\t\t\t\t\t\t\t\t      */\n-/* No error is possible, but Overflow or Underflow might occur.\t      */\n+/* No error is possible, but Overflow or Underflow might occur.       */\n /* ------------------------------------------------------------------ */\n decFloat * decFloatSetExponent(decFloat *df, decContext *set, Int exp) {\n-  uByte\t bcdcopy[DECPMAX];\t   /* for coefficient */\n+  uByte  bcdcopy[DECPMAX];\t   /* for coefficient */\n   bcdnum num;\t\t\t   /* work */\n   num.exponent=exp;\n   num.sign=decFloatGetCoefficient(df, bcdcopy); /* extract coefficient */\n@@ -1095,15 +1163,15 @@ uInt decFloatRadix(const decFloat *df) {\n   } /* decFloatRadix */\n \n /* ------------------------------------------------------------------ */\n-/* decFloatShow -- printf a decFloat in hexadecimal and decimal\t      */\n-/*   df\t is the decFloat to show\t\t\t\t      */\n+/* decFloatShow -- printf a decFloat in hexadecimal and decimal       */\n+/*   df  is the decFloat to show\t\t\t\t      */\n /*   tag is a tag string displayed with the number\t\t      */\n /*\t\t\t\t\t\t\t\t      */\n /* This is a debug aid; the precise format of the string may change.  */\n /* ------------------------------------------------------------------ */\n void decFloatShow(const decFloat *df, const char *tag) {\n   char hexbuf[DECBYTES*2+DECBYTES/4+1]; /* NB blank after every fourth */\n-  char buff[DECSTRING];\t\t\t/* for value in decimal */\n+  char buff[DECSTRING]; \t\t/* for value in decimal */\n   Int i, j=0;\n \n   for (i=0; i<DECBYTES; i++) {\n@@ -1126,7 +1194,7 @@ void decFloatShow(const decFloat *df, const char *tag) {\n /*\t\t\t\t\t\t\t\t      */\n /*  df is the source decFloat\t\t\t\t\t      */\n /*  exp will be set to the unbiased exponent, q, or to a special      */\n-/*    value in the form returned by decFloatGetExponent\t\t      */\n+/*    value in the form returned by decFloatGetExponent \t      */\n /*  bcdar is where DECPMAX bytes will be written, one BCD digit in    */\n /*    each byte (BCD8 encoding); if df is a NaN the first byte will   */\n /*    be zero, and if it is infinite they will all be zero\t      */\n@@ -1156,7 +1224,7 @@ Int decFloatToBCD(const decFloat *df, Int *exp, uByte *bcdar) {\n /* ------------------------------------------------------------------ */\n /* decFloatToEngString -- conversion to numeric string, engineering   */\n /*\t\t\t\t\t\t\t\t      */\n-/*  df is the decFloat format number to convert\t\t\t      */\n+/*  df is the decFloat format number to convert \t\t      */\n /*  string is the string where the result will be laid out\t      */\n /*\t\t\t\t\t\t\t\t      */\n /* string must be at least DECPMAX+9 characters (the worst case is    */\n@@ -1169,11 +1237,14 @@ char * decFloatToEngString(const decFloat *df, char *string){\n   uInt msd;\t\t\t   /* coefficient MSD */\n   Int  exp;\t\t\t   /* exponent top two bits or full */\n   uInt comb;\t\t\t   /* combination field */\n-  char *cstart;\t\t\t   /* coefficient start */\n+  char *cstart; \t\t   /* coefficient start */\n   char *c;\t\t\t   /* output pointer in string */\n   char *s, *t;\t\t\t   /* .. (source, target) */\n   Int  pre, e;\t\t\t   /* work */\n   const uByte *u;\t\t   /* .. */\n+  uInt\tuiwork; \t\t   /* for macros [one compiler needs */\n+\t\t\t\t   /* volatile here to avoid bug, but */\n+\t\t\t\t   /* that doubles execution time] */\n \n   /* Source words; macro handles endianness */\n   uInt sourhi=DFWORD(df, 0);\t   /* word with sign */\n@@ -1188,12 +1259,12 @@ char * decFloatToEngString(const decFloat *df, char *string){\n   c=string;\t\t\t   /* where result will go */\n   if (((Int)sourhi)<0) *c++='-';   /* handle sign */\n   comb=sourhi>>26;\t\t   /* sign+combination field */\n-  msd=DECCOMBMSD[comb];\t\t   /* decode the combination field */\n-  exp=DECCOMBEXP[comb];\t\t   /* .. */\n+  msd=DECCOMBMSD[comb]; \t   /* decode the combination field */\n+  exp=DECCOMBEXP[comb]; \t   /* .. */\n \n   if (EXPISSPECIAL(exp)) {\t   /* special */\n     if (exp==DECFLOAT_Inf) {\t   /* infinity */\n-      strcpy(c,\t  \"Inf\");\n+      strcpy(c,   \"Inf\");\n       strcpy(c+3, \"inity\");\n       return string;\t\t   /* easy */\n       }\n@@ -1225,44 +1296,44 @@ char * decFloatToEngString(const decFloat *df, char *string){\n   /* are the three encoded BCD8 digits followed by a 1-byte length */\n   /* (significant digits, except that 000 has length 0).  This allows */\n   /* us to left-align the first declet with non-zero content, then */\n-  /* the remaining ones are full 3-char length.\t Fixed-length copies */\n+  /* the remaining ones are full 3-char length.  Fixed-length copies */\n   /* are used because variable-length memcpy causes a subroutine call */\n-  /* in at least two compilers.\t (The copies are length 4 for speed */\n+  /* in at least two compilers.  (The copies are length 4 for speed */\n   /* and are safe because the last item in the array is of length */\n   /* three and has the length byte following.) */\n   #define dpd2char(dpdin) u=&DPD2BCD8[((dpdin)&0x3ff)*4];\t \\\n-\t if (c!=cstart) {UINTAT(c)=UINTAT(u)|CHARMASK; c+=3;}\t \\\n+\t if (c!=cstart) {UBFROMUI(c, UBTOUI(u)|CHARMASK); c+=3;} \\\n \t  else if (*(u+3)) {\t\t\t\t\t \\\n-\t   UINTAT(c)=UINTAT(u+3-*(u+3))|CHARMASK; c+=*(u+3);}\n+\t   UBFROMUI(c, UBTOUI(u+3-*(u+3))|CHARMASK); c+=*(u+3);}\n \n   #if DECPMAX==7\n-  dpd2char(sourhi>>10);\t\t\t/* declet 1 */\n+  dpd2char(sourhi>>10); \t\t/* declet 1 */\n   dpd2char(sourhi);\t\t\t/* declet 2 */\n \n   #elif DECPMAX==16\n   dpd2char(sourhi>>8);\t\t\t/* declet 1 */\n   dpd2char((sourhi<<2) | (sourlo>>30)); /* declet 2 */\n-  dpd2char(sourlo>>20);\t\t\t/* declet 3 */\n-  dpd2char(sourlo>>10);\t\t\t/* declet 4 */\n+  dpd2char(sourlo>>20); \t\t/* declet 3 */\n+  dpd2char(sourlo>>10); \t\t/* declet 4 */\n   dpd2char(sourlo);\t\t\t/* declet 5 */\n \n   #elif DECPMAX==34\n   dpd2char(sourhi>>4);\t\t\t/* declet 1 */\n   dpd2char((sourhi<<6) | (sourmh>>26)); /* declet 2 */\n-  dpd2char(sourmh>>16);\t\t\t/* declet 3 */\n+  dpd2char(sourmh>>16); \t\t/* declet 3 */\n   dpd2char(sourmh>>6);\t\t\t/* declet 4 */\n   dpd2char((sourmh<<4) | (sourml>>28)); /* declet 5 */\n-  dpd2char(sourml>>18);\t\t\t/* declet 6 */\n+  dpd2char(sourml>>18); \t\t/* declet 6 */\n   dpd2char(sourml>>8);\t\t\t/* declet 7 */\n   dpd2char((sourml<<2) | (sourlo>>30)); /* declet 8 */\n-  dpd2char(sourlo>>20);\t\t\t/* declet 9 */\n-  dpd2char(sourlo>>10);\t\t\t/* declet 10 */\n+  dpd2char(sourlo>>20); \t\t/* declet 9 */\n+  dpd2char(sourlo>>10); \t\t/* declet 10 */\n   dpd2char(sourlo);\t\t\t/* declet 11 */\n   #endif\n \n   if (c==cstart) *c++='0';\t   /* all zeros, empty -- make \"0\" */\n \n-  if (exp==0) {\t\t\t   /* integer or NaN case -- easy */\n+  if (exp==0) { \t\t   /* integer or NaN case -- easy */\n     *c='\\0';\t\t\t   /* terminate */\n     return string;\n     }\n@@ -1275,7 +1346,7 @@ char * decFloatToEngString(const decFloat *df, char *string){\n   if (exp>0 || pre<-5) {\t   /* need exponential form */\n     e=pre-1;\t\t\t   /* calculate E value */\n     pre=1;\t\t\t   /* assume one digit before '.' */\n-    if (e!=0) {\t\t\t   /* engineering: may need to adjust */\n+    if (e!=0) { \t\t   /* engineering: may need to adjust */\n       Int adj;\t\t\t   /* adjustment */\n       /* The C remainder operator is undefined for negative numbers, so */\n       /* a positive remainder calculation must be used here */\n@@ -1310,8 +1381,8 @@ char * decFloatToEngString(const decFloat *df, char *string){\n       /* because there is still space for exponent */\n       s=dotat+ROUNDDOWN4(c-dotat);\t/* source */\n       t=s+1;\t\t\t\t/* target */\n-      /* open the gap */\n-      for (; s>=dotat; s-=4, t-=4) UINTAT(t)=UINTAT(s);\n+      /* open the gap [cannot use memcpy] */\n+      for (; s>=dotat; s-=4, t-=4) UBFROMUI(t, UBTOUI(s));\n       *dotat='.';\n       c++;\t\t\t\t/* length increased by one */\n       } /* need dot? */\n@@ -1321,32 +1392,32 @@ char * decFloatToEngString(const decFloat *df, char *string){\n     /* -5<=pre<=0: here for plain 0.ddd or 0.000ddd forms (may have\n        E, but only for 0.00E+3 kind of case -- with plenty of spare\n        space in this case */\n-    pre=-pre+2;\t\t\t\t/* gap width, including \"0.\" */\n+    pre=-pre+2; \t\t\t/* gap width, including \"0.\" */\n     t=cstart+ROUNDDOWN4(c-cstart)+pre;\t/* preferred first target point */\n     /* backoff if too far to the right */\n     if (t>string+DECSTRING-5) t=string+DECSTRING-5; /* adjust to fit */\n     /* now shift the entire coefficient to the right, being careful not */\n-    /* to access to the left of string */\n-    for (s=t-pre; s>=string; s-=4, t-=4) UINTAT(t)=UINTAT(s);\n+    /* to access to the left of string [cannot use memcpy] */\n+    for (s=t-pre; s>=string; s-=4, t-=4) UBFROMUI(t, UBTOUI(s));\n     /* for Quads and Singles there may be a character or two left... */\n     s+=3;\t\t\t\t/* where next would come from */\n     for(; s>=cstart; s--, t--) *(t+3)=*(s);\n     /* now have fill 0. through 0.00000; use overlaps to avoid tests */\n     if (pre>=4) {\n-      UINTAT(cstart+pre-4)=UINTAT(\"0000\");\n-      UINTAT(cstart)=UINTAT(\"0.00\");\n+      memcpy(cstart+pre-4, \"0000\", 4);\n+      memcpy(cstart, \"0.00\", 4);\n       }\n      else { /* 2 or 3 */\n       *(cstart+pre-1)='0';\n-      USHORTAT(cstart)=USHORTAT(\"0.\");\n+      memcpy(cstart, \"0.\", 2);\n       }\n     c+=pre;\t\t\t\t/* to end */\n     }\n \n   /* finally add the E-part, if needed; it will never be 0, and has */\n   /* a maximum length of 3 or 4 digits (asserted above) */\n   if (e!=0) {\n-    USHORTAT(c)=USHORTAT(\"E+\");\t\t/* starts with E, assume + */\n+    memcpy(c, \"E+\", 2); \t\t/* starts with E, assume + */\n     c++;\n     if (e<0) {\n       *c='-';\t\t\t\t/* oops, need '-' */\n@@ -1355,23 +1426,23 @@ char * decFloatToEngString(const decFloat *df, char *string){\n     c++;\n     /* Three-character exponents are easy; 4-character a little trickier */\n     #if DECEMAXD<=3\n-      u=&BIN2BCD8[e*4];\t\t\t/* -> 3 digits + length byte */\n+      u=&BIN2BCD8[e*4]; \t\t/* -> 3 digits + length byte */\n       /* copy fixed 4 characters [is safe], starting at non-zero */\n       /* and with character mask to convert BCD to char */\n-      UINTAT(c)=UINTAT(u+3-*(u+3))|CHARMASK;\n+      UBFROMUI(c, UBTOUI(u+3-*(u+3))|CHARMASK);\n       c+=*(u+3);\t\t\t/* bump pointer appropriately */\n     #elif DECEMAXD==4\n       if (e<1000) {\t\t\t/* 3 (or fewer) digits case */\n \tu=&BIN2BCD8[e*4];\t\t/* -> 3 digits + length byte */\n-\tUINTAT(c)=UINTAT(u+3-*(u+3))|CHARMASK; /* [as above] */\n+\tUBFROMUI(c, UBTOUI(u+3-*(u+3))|CHARMASK); /* [as above] */\n \tc+=*(u+3);\t\t\t/* bump pointer appropriately */\n \t}\n        else {\t\t\t\t/* 4-digits */\n \tInt thou=((e>>3)*1049)>>17;\t/* e/1000 */\n \tInt rem=e-(1000*thou);\t\t/* e%1000 */\n \t*c++=(char)('0'+(char)thou);\t/* the thousands digit */\n \tu=&BIN2BCD8[rem*4];\t\t/* -> 3 digits + length byte */\n-\tUINTAT(c)=UINTAT(u)|CHARMASK;\t/* copy fixed 3+1 characters [is safe] */\n+\tUBFROMUI(c, UBTOUI(u)|CHARMASK);/* copy fixed 3+1 characters [is safe] */\n \tc+=3;\t\t\t\t/* bump pointer, always 3 digits */\n \t}\n     #endif\n@@ -1386,7 +1457,7 @@ char * decFloatToEngString(const decFloat *df, char *string){\n /*\t\t\t\t\t\t\t\t      */\n /*  df is the source decFloat\t\t\t\t\t      */\n /*  exp will be set to the unbiased exponent, q, or to a special      */\n-/*    value in the form returned by decFloatGetExponent\t\t      */\n+/*    value in the form returned by decFloatGetExponent \t      */\n /*  packed is where DECPMAX nibbles will be written with the sign as  */\n /*    final nibble (0x0c for +, 0x0d for -); a NaN has a first nibble */\n /*    of zero, and an infinity is all zeros. decDouble and decQuad    */\n@@ -1432,7 +1503,7 @@ Int decFloatToPacked(const decFloat *df, Int *exp, uByte *packed) {\n /* ------------------------------------------------------------------ */\n /* decFloatToString -- conversion to numeric string\t\t      */\n /*\t\t\t\t\t\t\t\t      */\n-/*  df is the decFloat format number to convert\t\t\t      */\n+/*  df is the decFloat format number to convert \t\t      */\n /*  string is the string where the result will be laid out\t      */\n /*\t\t\t\t\t\t\t\t      */\n /* string must be at least DECPMAX+9 characters (the worst case is    */\n@@ -1445,11 +1516,14 @@ char * decFloatToString(const decFloat *df, char *string){\n   uInt msd;\t\t\t   /* coefficient MSD */\n   Int  exp;\t\t\t   /* exponent top two bits or full */\n   uInt comb;\t\t\t   /* combination field */\n-  char *cstart;\t\t\t   /* coefficient start */\n+  char *cstart; \t\t   /* coefficient start */\n   char *c;\t\t\t   /* output pointer in string */\n   char *s, *t;\t\t\t   /* .. (source, target) */\n   Int  pre, e;\t\t\t   /* work */\n   const uByte *u;\t\t   /* .. */\n+  uInt\tuiwork; \t\t   /* for macros [one compiler needs */\n+\t\t\t\t   /* volatile here to avoid bug, but */\n+\t\t\t\t   /* that doubles execution time] */\n \n   /* Source words; macro handles endianness */\n   uInt sourhi=DFWORD(df, 0);\t   /* word with sign */\n@@ -1464,10 +1538,14 @@ char * decFloatToString(const decFloat *df, char *string){\n   c=string;\t\t\t   /* where result will go */\n   if (((Int)sourhi)<0) *c++='-';   /* handle sign */\n   comb=sourhi>>26;\t\t   /* sign+combination field */\n-  msd=DECCOMBMSD[comb];\t\t   /* decode the combination field */\n-  exp=DECCOMBEXP[comb];\t\t   /* .. */\n+  msd=DECCOMBMSD[comb]; \t   /* decode the combination field */\n+  exp=DECCOMBEXP[comb]; \t   /* .. */\n \n-  if (EXPISSPECIAL(exp)) {\t   /* special */\n+  if (!EXPISSPECIAL(exp)) {\t   /* finite */\n+    /* complete exponent; top two bits are in place */\n+    exp+=GETECON(df)-DECBIAS;\t   /* .. + continuation and unbias */\n+    }\n+   else {\t\t\t   /* IS special */\n     if (exp==DECFLOAT_Inf) {\t   /* infinity */\n       strcpy(c, \"Infinity\");\n       return string;\t\t   /* easy */\n@@ -1487,9 +1565,6 @@ char * decFloatToString(const decFloat *df, char *string){\n     /* otherwise drop through to add integer; set correct exp etc. */\n     exp=0; msd=0;\t\t   /* setup for following code */\n     }\n-   else { /* complete exponent; top two bits are in place */\n-    exp+=GETECON(df)-DECBIAS;\t   /* .. + continuation and unbias */\n-    }\n \n   /* convert the digits of the significand to characters */\n   cstart=c;\t\t\t   /* save start of coefficient */\n@@ -1500,38 +1575,38 @@ char * decFloatToString(const decFloat *df, char *string){\n   /* are the three encoded BCD8 digits followed by a 1-byte length */\n   /* (significant digits, except that 000 has length 0).  This allows */\n   /* us to left-align the first declet with non-zero content, then */\n-  /* the remaining ones are full 3-char length.\t Fixed-length copies */\n+  /* the remaining ones are full 3-char length.  Fixed-length copies */\n   /* are used because variable-length memcpy causes a subroutine call */\n-  /* in at least two compilers.\t (The copies are length 4 for speed */\n+  /* in at least two compilers.  (The copies are length 4 for speed */\n   /* and are safe because the last item in the array is of length */\n   /* three and has the length byte following.) */\n   #define dpd2char(dpdin) u=&DPD2BCD8[((dpdin)&0x3ff)*4];\t \\\n-\t if (c!=cstart) {UINTAT(c)=UINTAT(u)|CHARMASK; c+=3;}\t \\\n+\t if (c!=cstart) {UBFROMUI(c, UBTOUI(u)|CHARMASK); c+=3;} \\\n \t  else if (*(u+3)) {\t\t\t\t\t \\\n-\t   UINTAT(c)=UINTAT(u+3-*(u+3))|CHARMASK; c+=*(u+3);}\n+\t   UBFROMUI(c, UBTOUI(u+3-*(u+3))|CHARMASK); c+=*(u+3);}\n \n   #if DECPMAX==7\n-  dpd2char(sourhi>>10);\t\t\t/* declet 1 */\n+  dpd2char(sourhi>>10); \t\t/* declet 1 */\n   dpd2char(sourhi);\t\t\t/* declet 2 */\n \n   #elif DECPMAX==16\n   dpd2char(sourhi>>8);\t\t\t/* declet 1 */\n   dpd2char((sourhi<<2) | (sourlo>>30)); /* declet 2 */\n-  dpd2char(sourlo>>20);\t\t\t/* declet 3 */\n-  dpd2char(sourlo>>10);\t\t\t/* declet 4 */\n+  dpd2char(sourlo>>20); \t\t/* declet 3 */\n+  dpd2char(sourlo>>10); \t\t/* declet 4 */\n   dpd2char(sourlo);\t\t\t/* declet 5 */\n \n   #elif DECPMAX==34\n   dpd2char(sourhi>>4);\t\t\t/* declet 1 */\n   dpd2char((sourhi<<6) | (sourmh>>26)); /* declet 2 */\n-  dpd2char(sourmh>>16);\t\t\t/* declet 3 */\n+  dpd2char(sourmh>>16); \t\t/* declet 3 */\n   dpd2char(sourmh>>6);\t\t\t/* declet 4 */\n   dpd2char((sourmh<<4) | (sourml>>28)); /* declet 5 */\n-  dpd2char(sourml>>18);\t\t\t/* declet 6 */\n+  dpd2char(sourml>>18); \t\t/* declet 6 */\n   dpd2char(sourml>>8);\t\t\t/* declet 7 */\n   dpd2char((sourml<<2) | (sourlo>>30)); /* declet 8 */\n-  dpd2char(sourlo>>20);\t\t\t/* declet 9 */\n-  dpd2char(sourlo>>10);\t\t\t/* declet 10 */\n+  dpd2char(sourlo>>20); \t\t/* declet 9 */\n+  dpd2char(sourlo>>10); \t\t/* declet 10 */\n   dpd2char(sourlo);\t\t\t/* declet 11 */\n   #endif\n \n@@ -1556,23 +1631,24 @@ char * decFloatToString(const decFloat *df, char *string){\n   if (pre>0) {\t\t\t   /* ddd.ddd (plain), perhaps with E */\n     char *dotat=cstart+pre;\n     if (dotat<c) {\t\t\t/* if embedded dot needed... */\n+      /* [memmove is a disaster, here] */\n       /* move by fours; there must be space for junk at the end */\n-      /* because there is still space for exponent */\n+      /* because exponent is still possible */\n       s=dotat+ROUNDDOWN4(c-dotat);\t/* source */\n       t=s+1;\t\t\t\t/* target */\n-      /* open the gap */\n-      for (; s>=dotat; s-=4, t-=4) UINTAT(t)=UINTAT(s);\n+      /* open the gap [cannot use memcpy] */\n+      for (; s>=dotat; s-=4, t-=4) UBFROMUI(t, UBTOUI(s));\n       *dotat='.';\n       c++;\t\t\t\t/* length increased by one */\n       } /* need dot? */\n \n     /* finally add the E-part, if needed; it will never be 0, and has */\n     /* a maximum length of 3 or 4 digits (asserted above) */\n     if (e!=0) {\n-      USHORTAT(c)=USHORTAT(\"E+\");\t/* starts with E, assume + */\n+      memcpy(c, \"E+\", 2);\t\t/* starts with E, assume + */\n       c++;\n       if (e<0) {\n-\t*c='-';\t\t\t\t/* oops, need '-' */\n+\t*c='-'; \t\t\t/* oops, need '-' */\n \te=-e;\t\t\t\t/* uInt, please */\n \t}\n       c++;\n@@ -1581,21 +1657,21 @@ char * decFloatToString(const decFloat *df, char *string){\n \tu=&BIN2BCD8[e*4];\t\t/* -> 3 digits + length byte */\n \t/* copy fixed 4 characters [is safe], starting at non-zero */\n \t/* and with character mask to convert BCD to char */\n-\tUINTAT(c)=UINTAT(u+3-*(u+3))|CHARMASK;\n+\tUBFROMUI(c, UBTOUI(u+3-*(u+3))|CHARMASK);\n \tc+=*(u+3);\t\t\t/* bump pointer appropriately */\n       #elif DECEMAXD==4\n \tif (e<1000) {\t\t\t/* 3 (or fewer) digits case */\n \t  u=&BIN2BCD8[e*4];\t\t/* -> 3 digits + length byte */\n-\t  UINTAT(c)=UINTAT(u+3-*(u+3))|CHARMASK; /* [as above] */\n+\t  UBFROMUI(c, UBTOUI(u+3-*(u+3))|CHARMASK); /* [as above] */\n \t  c+=*(u+3);\t\t\t/* bump pointer appropriately */\n \t  }\n-\t else {\t\t\t\t/* 4-digits */\n+\t else { \t\t\t/* 4-digits */\n \t  Int thou=((e>>3)*1049)>>17;\t/* e/1000 */\n \t  Int rem=e-(1000*thou);\t/* e%1000 */\n \t  *c++=(char)('0'+(char)thou);\t/* the thousands digit */\n \t  u=&BIN2BCD8[rem*4];\t\t/* -> 3 digits + length byte */\n-\t  UINTAT(c)=UINTAT(u)|CHARMASK; /* copy fixed 3+1 characters [is safe] */\n-\t  c+=3;\t\t\t\t/* bump pointer, always 3 digits */\n+\t  UBFROMUI(c, UBTOUI(u)|CHARMASK); /* copy fixed 3+1 characters [is safe] */\n+\t  c+=3; \t\t\t/* bump pointer, always 3 digits */\n \t  }\n       #endif\n       }\n@@ -1618,19 +1694,19 @@ char * decFloatToString(const decFloat *df, char *string){\n   /* backoff if too far to the right */\n   if (t>string+DECSTRING-5) t=string+DECSTRING-5; /* adjust to fit */\n   /* now shift the entire coefficient to the right, being careful not */\n-  /* to access to the left of string */\n-  for (s=t-pre; s>=string; s-=4, t-=4) UINTAT(t)=UINTAT(s);\n+  /* to access to the left of string [cannot use memcpy] */\n+  for (s=t-pre; s>=string; s-=4, t-=4) UBFROMUI(t, UBTOUI(s));\n   /* for Quads and Singles there may be a character or two left... */\n-  s+=3;\t\t\t\t\t/* where next would come from */\n+  s+=3; \t\t\t\t/* where next would come from */\n   for(; s>=cstart; s--, t--) *(t+3)=*(s);\n   /* now have fill 0. through 0.00000; use overlaps to avoid tests */\n   if (pre>=4) {\n-    UINTAT(cstart+pre-4)=UINTAT(\"0000\");\n-    UINTAT(cstart)=UINTAT(\"0.00\");\n+    memcpy(cstart+pre-4, \"0000\", 4);\n+    memcpy(cstart, \"0.00\", 4);\n     }\n    else { /* 2 or 3 */\n     *(cstart+pre-1)='0';\n-    USHORTAT(cstart)=USHORTAT(\"0.\");\n+    memcpy(cstart, \"0.\", 2);\n     }\n   *(c+pre)='\\0';\t\t\t/* terminate */\n   return string;\n@@ -1665,7 +1741,7 @@ decFloatWider * decFloatToWider(const decFloat *source, decFloatWider *wider) {\n     code|=(exp<<(32-6-DECWECONL)) & 0x03ffffff; /* add exponent continuation */\n     code|=DFWORD(source, 0)&0x80000000; /* add sign */\n     DFWWORD(wider, 0)=code;\t\t/* .. and place top word in wider */\n-    msd=GETMSD(source);\t\t\t/* get source coefficient MSD [0-9] */\n+    msd=GETMSD(source); \t\t/* get source coefficient MSD [0-9] */\n     }\n   /* Copy the coefficient and clear any 'unused' words to left */\n   #if SINGLE\n@@ -1723,6 +1799,7 @@ decFloat * decFloatZero(decFloat *df){\n   void decShowNum(const bcdnum *num, const char *tag) {\n     const char *csign=\"+\";\t\t/* sign character */\n     uByte *ub;\t\t\t\t/* work */\n+    uInt  uiwork;\t\t\t/* for macros */\n     if (num->sign==DECFLOAT_Sign) csign=\"-\";\n \n     printf(\">%s> \", tag);\n@@ -1747,15 +1824,15 @@ decFloat * decFloatZero(decFloat *df){\n      if (e==0) *c++='0';\t\t/* 0-length case */\n       else if (e<1000) {\t\t/* 3 (or fewer) digits case */\n        u=&BIN2BCD8[e*4];\t\t/* -> 3 digits + length byte */\n-       UINTAT(c)=UINTAT(u+3-*(u+3))|CHARMASK; /* [as above] */\n+       UBFROMUI(c, UBTOUI(u+3-*(u+3))|CHARMASK); /* [as above] */\n        c+=*(u+3);\t\t\t/* bump pointer appropriately */\n        }\n       else {\t\t\t\t/* 4-digits */\n        Int thou=((e>>3)*1049)>>17;\t/* e/1000 */\n        Int rem=e-(1000*thou);\t\t/* e%1000 */\n        *c++=(char)('0'+(char)thou);\t/* the thousands digit */\n        u=&BIN2BCD8[rem*4];\t\t/* -> 3 digits + length byte */\n-       UINTAT(c)=UINTAT(u)|CHARMASK;\t/* copy fixed 3+1 characters [is safe] */\n+       UBFROMUI(c, UBTOUI(u)|CHARMASK); /* copy fixed 3+1 characters [is safe] */\n        c+=3;\t\t\t\t/* bump pointer, always 3 digits */\n        }\n      *c='\\0';\t\t\t\t/* add terminator */"}, {"sha": "b1d1cc4e47b4fdd8d9139c529a395d0d82e71b96", "filename": "libdecnumber/decContext.c", "status": "modified", "additions": 51, "deletions": 32, "changes": 83, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f988ec96d922819a4948c1ed96c6dc1b79a7ad22/libdecnumber%2FdecContext.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f988ec96d922819a4948c1ed96c6dc1b79a7ad22/libdecnumber%2FdecContext.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libdecnumber%2FdecContext.c?ref=f988ec96d922819a4948c1ed96c6dc1b79a7ad22", "patch": "@@ -38,15 +38,13 @@\n #include <string.h>\t      /* for strcmp */\n #include <stdio.h>\t      /* for printf if DECCHECK */\n #include \"dconfig.h\"\t      /* for GCC definitions */\n-#include \"decContext.h\"\t      /* context and base types */\n+#include \"decContext.h\"       /* context and base types */\n #include \"decNumberLocal.h\"   /* decNumber local types, etc. */\n \n-#if DECCHECK\n /* compile-time endian tester [assumes sizeof(Int)>1] */\n static\tconst  Int mfcone=1;\t\t     /* constant 1 */\n-static\tconst  Flag *mfctop=(Flag *)&mfcone; /* -> top byte */\n+static\tconst  Flag *mfctop=(const Flag *)&mfcone; /* -> top byte */\n #define LITEND *mfctop\t\t   /* named flag; 1=little-endian */\n-#endif\n \n /* ------------------------------------------------------------------ */\n /* round-for-reround digits\t\t\t\t\t      */\n@@ -64,7 +62,7 @@ const uInt DECPOWERS[10]={1, 10, 100, 1000, 10000, 100000, 1000000,\n /*\t\t\t\t\t\t\t\t      */\n /*  context is the context structure to be queried\t\t      */\n /*  mask indicates the bits to be cleared (the status bit that\t      */\n-/*    corresponds to each 1 bit in the mask is cleared)\t\t      */\n+/*    corresponds to each 1 bit in the mask is cleared) \t      */\n /*  returns context\t\t\t\t\t\t      */\n /*\t\t\t\t\t\t\t\t      */\n /* No error is possible.\t\t\t\t\t      */\n@@ -80,9 +78,9 @@ decContext *decContextClearStatus(decContext *context, uInt mask) {\n /*  context is the structure to be initialized\t\t\t      */\n /*  kind selects the required set of default values, one of:\t      */\n /*\tDEC_INIT_BASE\t    -- select ANSI X3-274 defaults\t      */\n-/*\tDEC_INIT_DECIMAL32  -- select IEEE 754r defaults, 32-bit      */\n-/*\tDEC_INIT_DECIMAL64  -- select IEEE 754r defaults, 64-bit      */\n-/*\tDEC_INIT_DECIMAL128 -- select IEEE 754r defaults, 128-bit     */\n+/*\tDEC_INIT_DECIMAL32  -- select IEEE 754 defaults, 32-bit       */\n+/*\tDEC_INIT_DECIMAL64  -- select IEEE 754 defaults, 64-bit       */\n+/*\tDEC_INIT_DECIMAL128 -- select IEEE 754 defaults, 128-bit      */\n /*\tFor any other value a valid context is returned, but with     */\n /*\tInvalid_operation set in the status field.\t\t      */\n /*  returns a context structure with the appropriate initial values.  */\n@@ -105,11 +103,11 @@ decContext * decContextDefault(decContext *context, Int kind) {\n       break;\n     case DEC_INIT_DECIMAL32:\n       context->digits=7;\t\t     /* digits */\n-      context->emax=96;\t\t\t     /* Emax */\n+      context->emax=96; \t\t     /* Emax */\n       context->emin=-95;\t\t     /* Emin */\n       context->round=DEC_ROUND_HALF_EVEN;    /* 0.5 to nearest even */\n-      context->traps=0;\t\t\t     /* no traps set */\n-      context->clamp=1;\t\t\t     /* clamp exponents */\n+      context->traps=0; \t\t     /* no traps set */\n+      context->clamp=1; \t\t     /* clamp exponents */\n       #if DECSUBSET\n       context->extended=1;\t\t     /* set */\n       #endif\n@@ -119,8 +117,8 @@ decContext * decContextDefault(decContext *context, Int kind) {\n       context->emax=384;\t\t     /* Emax */\n       context->emin=-383;\t\t     /* Emin */\n       context->round=DEC_ROUND_HALF_EVEN;    /* 0.5 to nearest even */\n-      context->traps=0;\t\t\t     /* no traps set */\n-      context->clamp=1;\t\t\t     /* clamp exponents */\n+      context->traps=0; \t\t     /* no traps set */\n+      context->clamp=1; \t\t     /* clamp exponents */\n       #if DECSUBSET\n       context->extended=1;\t\t     /* set */\n       #endif\n@@ -130,8 +128,8 @@ decContext * decContextDefault(decContext *context, Int kind) {\n       context->emax=6144;\t\t     /* Emax */\n       context->emin=-6143;\t\t     /* Emin */\n       context->round=DEC_ROUND_HALF_EVEN;    /* 0.5 to nearest even */\n-      context->traps=0;\t\t\t     /* no traps set */\n-      context->clamp=1;\t\t\t     /* clamp exponents */\n+      context->traps=0; \t\t     /* no traps set */\n+      context->clamp=1; \t\t     /* clamp exponents */\n       #if DECSUBSET\n       context->extended=1;\t\t     /* set */\n       #endif\n@@ -142,15 +140,6 @@ decContext * decContextDefault(decContext *context, Int kind) {\n       decContextSetStatus(context, DEC_Invalid_operation); /* trap */\n     }\n \n-  #if DECCHECK\n-  if (LITEND!=DECLITEND) {\n-    const char *adj;\n-    if (LITEND) adj=\"little\";\n-\t   else adj=\"big\";\n-    printf(\"Warning: DECLITEND is set to %d, but this computer appears to be %s-endian\\n\",\n-\t   DECLITEND, adj);\n-    }\n-  #endif\n   return context;} /* decContextDefault */\n \n /* ------------------------------------------------------------------ */\n@@ -166,7 +155,7 @@ enum rounding decContextGetRounding(decContext *context) {\n   } /* decContextGetRounding */\n \n /* ------------------------------------------------------------------ */\n-/* decContextGetStatus -- return current status\t\t\t      */\n+/* decContextGetStatus -- return current status \t\t      */\n /*\t\t\t\t\t\t\t\t      */\n /*  context is the context structure to be queried\t\t      */\n /*  returns status\t\t\t\t\t\t      */\n@@ -181,8 +170,8 @@ uInt decContextGetStatus(decContext *context) {\n /* decContextRestoreStatus -- restore bits in current status\t      */\n /*\t\t\t\t\t\t\t\t      */\n /*  context is the context structure to be updated\t\t      */\n-/*  newstatus is the source for the bits to be restored\t\t      */\n-/*  mask indicates the bits to be restored (the status bit that\t      */\n+/*  newstatus is the source for the bits to be restored \t      */\n+/*  mask indicates the bits to be restored (the status bit that       */\n /*    corresponds to each 1 bit in the mask is set to the value of    */\n /*    the correspnding bit in newstatus)\t\t\t      */\n /*  returns context\t\t\t\t\t\t      */\n@@ -252,7 +241,7 @@ decContext * decContextSetStatus(decContext *context, uInt status) {\n /*\t\t\t\t\t\t\t\t      */\n /*  returns the context structure, unless the string is equal to      */\n /*    DEC_Condition_MU or is not recognized.  In these cases NULL is  */\n-/*    returned.\t\t\t\t\t\t\t      */\n+/*    returned. \t\t\t\t\t\t      */\n /* ------------------------------------------------------------------ */\n decContext * decContextSetStatusFromString(decContext *context,\n \t\t\t\t\t   const char *string) {\n@@ -303,7 +292,7 @@ decContext * decContextSetStatusFromString(decContext *context,\n /*\t\t\t\t\t\t\t\t      */\n /*  returns the context structure, unless the string is equal to      */\n /*    DEC_Condition_MU or is not recognized.  In these cases NULL is  */\n-/*    returned.\t\t\t\t\t\t\t      */\n+/*    returned. \t\t\t\t\t\t      */\n /* ------------------------------------------------------------------ */\n decContext * decContextSetStatusFromStringQuiet(decContext *context,\n \t\t\t\t\t\tconst char *string) {\n@@ -356,11 +345,11 @@ decContext * decContextSetStatusQuiet(decContext *context, uInt status) {\n   return context;} /* decContextSetStatusQuiet */\n \n /* ------------------------------------------------------------------ */\n-/* decContextStatusToString -- convert status flags to a string\t      */\n+/* decContextStatusToString -- convert status flags to a string       */\n /*\t\t\t\t\t\t\t\t      */\n /*  context is a context with valid status field\t\t      */\n /*\t\t\t\t\t\t\t\t      */\n-/*  returns a constant string describing the condition.\t If multiple  */\n+/*  returns a constant string describing the condition.  If multiple  */\n /*    (or no) flags are set, a generic constant message is returned.  */\n /* ------------------------------------------------------------------ */\n const char *decContextStatusToString(const decContext *context) {\n@@ -385,10 +374,40 @@ const char *decContextStatusToString(const decContext *context) {\n   #if DECSUBSET\n   if (status==DEC_Lost_digits\t       ) return DEC_Condition_LD;\n   #endif\n-  if (status==0\t\t\t       ) return DEC_Condition_ZE;\n+  if (status==0 \t\t       ) return DEC_Condition_ZE;\n   return DEC_Condition_MU;  /* Multiple errors */\n   } /* decContextStatusToString */\n \n+/* ------------------------------------------------------------------ */\n+/* decContextTestEndian -- test whether DECLITEND is set correctly    */\n+/*\t\t\t\t\t\t\t\t      */\n+/*  quiet is 1 to suppress message; 0 otherwise \t\t      */\n+/*  returns 0 if DECLITEND is correct\t\t\t\t      */\n+/*\t    1 if DECLITEND is incorrect and should be 1 \t      */\n+/*\t   -1 if DECLITEND is incorrect and should be 0 \t      */\n+/*\t\t\t\t\t\t\t\t      */\n+/* A message is displayed if the return value is not 0 and quiet==0.  */\n+/*\t\t\t\t\t\t\t\t      */\n+/* No error is possible.\t\t\t\t\t      */\n+/* ------------------------------------------------------------------ */\n+Int decContextTestEndian(Flag quiet) {\n+  Int res=0;\t\t      /* optimist */\n+  uInt dle=(uInt)DECLITEND;   /* unsign */\n+  if (dle>1) dle=1;\t      /* ensure 0 or 1 */\n+\n+  if (LITEND!=DECLITEND) {\n+    const char *adj;\n+    if (!quiet) {\n+      if (LITEND) adj=\"little\";\n+\t     else adj=\"big\";\n+      printf(\"Warning: DECLITEND is set to %d, but this computer appears to be %s-endian\\n\",\n+\t     DECLITEND, adj);\n+      }\n+    res=(Int)LITEND-dle;\n+    }\n+  return res;\n+  } /* decContextTestEndian */\n+\n /* ------------------------------------------------------------------ */\n /* decContextTestSavedStatus -- test bits in saved status\t      */\n /*\t\t\t\t\t\t\t\t      */"}, {"sha": "70effd8008357b0db4a5c224d7d6bd8c36d7433f", "filename": "libdecnumber/decContext.h", "status": "modified", "additions": 48, "deletions": 34, "changes": 82, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f988ec96d922819a4948c1ed96c6dc1b79a7ad22/libdecnumber%2FdecContext.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f988ec96d922819a4948c1ed96c6dc1b79a7ad22/libdecnumber%2FdecContext.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libdecnumber%2FdecContext.h?ref=f988ec96d922819a4948c1ed96c6dc1b79a7ad22", "patch": "@@ -34,7 +34,7 @@\n /*\t\t\t\t\t\t\t\t      */\n /* Context variables must always have valid values:\t\t      */\n /*\t\t\t\t\t\t\t\t      */\n-/*  status   -- [any bits may be cleared, but not set, by user]\t      */\n+/*  status   -- [any bits may be cleared, but not set, by user]       */\n /*  round    -- must be one of the enumerated rounding modes\t      */\n /*\t\t\t\t\t\t\t\t      */\n /* The following variables are implied for fixed size formats (i.e.,  */\n@@ -54,36 +54,42 @@\n   #define DECCONTEXT\n   #define DECCNAME     \"decContext\"\t\t\t/* Short name */\n   #define DECCFULLNAME \"Decimal Context Descriptor\"   /* Verbose name */\n-  #define DECCAUTHOR   \"Mike Cowlishaw\"\t\t      /* Who to blame */\n+  #define DECCAUTHOR   \"Mike Cowlishaw\" \t      /* Who to blame */\n \n-  #include \"gstdint.h\"\t\t   /* C99 standard integers\t      */\n+  #if !defined(int32_t)\n+    #include <stdint.h> \t   /* C99 standard integers\t      */\n+  #endif\n   #include <stdio.h>\t\t   /* for printf, etc.\t\t      */\n-  #include <signal.h>\t\t   /* for traps\t\t\t      */\n+  #include <signal.h>\t\t   /* for traps \t\t      */\n \n   /* Extended flags setting -- set this to 0 to use only IEEE flags   */\n+  #if !defined(DECEXTFLAG)\n   #define DECEXTFLAG 1\t\t   /* 1=enable extended flags\t      */\n+  #endif\n \n   /* Conditional code flag -- set this to 0 for best performance      */\n+  #if !defined(DECSUBSET)\n   #define DECSUBSET  0\t\t   /* 1=enable subset arithmetic      */\n+  #endif\n \n   /* Context for operations, with associated constants\t\t      */\n   enum rounding {\n     DEC_ROUND_CEILING,\t\t   /* round towards +infinity\t      */\n-    DEC_ROUND_UP,\t\t   /* round away from 0\t\t      */\n+    DEC_ROUND_UP,\t\t   /* round away from 0 \t      */\n     DEC_ROUND_HALF_UP,\t\t   /* 0.5 rounds up\t\t      */\n     DEC_ROUND_HALF_EVEN,\t   /* 0.5 rounds to nearest even      */\n     DEC_ROUND_HALF_DOWN,\t   /* 0.5 rounds down\t\t      */\n     DEC_ROUND_DOWN,\t\t   /* round towards 0 (truncate)      */\n     DEC_ROUND_FLOOR,\t\t   /* round towards -infinity\t      */\n-    DEC_ROUND_05UP,\t\t   /* round for reround\t\t      */\n+    DEC_ROUND_05UP,\t\t   /* round for reround \t      */\n     DEC_ROUND_MAX\t\t   /* enum must be less than this     */\n     };\n   #define DEC_ROUND_DEFAULT DEC_ROUND_HALF_EVEN;\n \n   typedef struct {\n-    int32_t  digits;\t\t   /* working precision\t\t      */\n-    int32_t  emax;\t\t   /* maximum positive exponent\t      */\n-    int32_t  emin;\t\t   /* minimum negative exponent\t      */\n+    int32_t  digits;\t\t   /* working precision \t      */\n+    int32_t  emax;\t\t   /* maximum positive exponent       */\n+    int32_t  emin;\t\t   /* minimum negative exponent       */\n     enum     rounding round;\t   /* rounding mode\t\t      */\n     uint32_t traps;\t\t   /* trap-enabler flags\t      */\n     uint32_t status;\t\t   /* status flags\t\t      */\n@@ -102,9 +108,9 @@\n   #define DEC_MIN_EMIN\t-999999999\n   #define DEC_MAX_MATH\t    999999 /* max emax, etc., for math funcs. */\n \n-  /* Classifications for decimal numbers, aligned with 754r (note     */\n-  /* that 'normal' and 'subnormal' are meaningful only with a\t      */\n-  /* decContext or a fixed size format).\t\t\t      */\n+  /* Classifications for decimal numbers, aligned with 754 (note that */\n+  /* 'normal' and 'subnormal' are meaningful only with a decContext   */\n+  /* or a fixed size format).\t\t\t\t\t      */\n   enum decClass {\n     DEC_CLASS_SNAN,\n     DEC_CLASS_QNAN,\n@@ -139,15 +145,15 @@\n     #define DEC_Division_impossible  0x00000004\n     #define DEC_Division_undefined   0x00000008\n     #define DEC_Insufficient_storage 0x00000010 /* [when malloc fails]\t*/\n-    #define DEC_Inexact\t\t     0x00000020\n-    #define DEC_Invalid_context\t     0x00000040\n+    #define DEC_Inexact \t     0x00000020\n+    #define DEC_Invalid_context      0x00000040\n     #define DEC_Invalid_operation    0x00000080\n     #if DECSUBSET\n     #define DEC_Lost_digits\t     0x00000100\n     #endif\n     #define DEC_Overflow\t     0x00000200\n-    #define DEC_Clamped\t\t     0x00000400\n-    #define DEC_Rounded\t\t     0x00000800\n+    #define DEC_Clamped \t     0x00000400\n+    #define DEC_Rounded \t     0x00000800\n     #define DEC_Subnormal\t     0x00001000\n     #define DEC_Underflow\t     0x00002000\n   #else\n@@ -157,43 +163,43 @@\n     #define DEC_Division_impossible  0x00000010\n     #define DEC_Division_undefined   0x00000010\n     #define DEC_Insufficient_storage 0x00000010 /* [when malloc fails]\t*/\n-    #define DEC_Inexact\t\t     0x00000001\n-    #define DEC_Invalid_context\t     0x00000010\n+    #define DEC_Inexact \t     0x00000001\n+    #define DEC_Invalid_context      0x00000010\n     #define DEC_Invalid_operation    0x00000010\n     #if DECSUBSET\n     #define DEC_Lost_digits\t     0x00000000\n     #endif\n     #define DEC_Overflow\t     0x00000008\n-    #define DEC_Clamped\t\t     0x00000000\n-    #define DEC_Rounded\t\t     0x00000000\n+    #define DEC_Clamped \t     0x00000000\n+    #define DEC_Rounded \t     0x00000000\n     #define DEC_Subnormal\t     0x00000000\n     #define DEC_Underflow\t     0x00000004\n   #endif\n \n-  /* IEEE 854 groupings for the flags\t\t\t\t      */\n+  /* IEEE 754 groupings for the flags\t\t\t\t      */\n   /* [DEC_Clamped, DEC_Lost_digits, DEC_Rounded, and DEC_Subnormal    */\n-  /* are not in IEEE 854]\t\t\t\t\t      */\n-  #define DEC_IEEE_854_Division_by_zero\t (DEC_Division_by_zero)\n+  /* are not in IEEE 754]\t\t\t\t\t      */\n+  #define DEC_IEEE_754_Division_by_zero  (DEC_Division_by_zero)\n   #if DECSUBSET\n-  #define DEC_IEEE_854_Inexact\t\t (DEC_Inexact | DEC_Lost_digits)\n+  #define DEC_IEEE_754_Inexact\t\t (DEC_Inexact | DEC_Lost_digits)\n   #else\n-  #define DEC_IEEE_854_Inexact\t\t (DEC_Inexact)\n+  #define DEC_IEEE_754_Inexact\t\t (DEC_Inexact)\n   #endif\n-  #define DEC_IEEE_854_Invalid_operation (DEC_Conversion_syntax |     \\\n+  #define DEC_IEEE_754_Invalid_operation (DEC_Conversion_syntax |     \\\n \t\t\t\t\t  DEC_Division_impossible |   \\\n \t\t\t\t\t  DEC_Division_undefined |    \\\n \t\t\t\t\t  DEC_Insufficient_storage |  \\\n-\t\t\t\t\t  DEC_Invalid_context |\t      \\\n+\t\t\t\t\t  DEC_Invalid_context |       \\\n \t\t\t\t\t  DEC_Invalid_operation)\n-  #define DEC_IEEE_854_Overflow\t\t (DEC_Overflow)\n-  #define DEC_IEEE_854_Underflow\t (DEC_Underflow)\n+  #define DEC_IEEE_754_Overflow \t (DEC_Overflow)\n+  #define DEC_IEEE_754_Underflow\t (DEC_Underflow)\n \n   /* flags which are normally errors (result is qNaN, infinite, or 0) */\n-  #define DEC_Errors (DEC_IEEE_854_Division_by_zero |\t\t      \\\n-\t\t      DEC_IEEE_854_Invalid_operation |\t\t      \\\n-\t\t      DEC_IEEE_854_Overflow | DEC_IEEE_854_Underflow)\n+  #define DEC_Errors (DEC_IEEE_754_Division_by_zero |\t\t      \\\n+\t\t      DEC_IEEE_754_Invalid_operation |\t\t      \\\n+\t\t      DEC_IEEE_754_Overflow | DEC_IEEE_754_Underflow)\n   /* flags which cause a result to become qNaN\t\t\t      */\n-  #define DEC_NaNs    DEC_IEEE_854_Invalid_operation\n+  #define DEC_NaNs    DEC_IEEE_754_Invalid_operation\n \n   /* flags which are normally for information only (finite results)   */\n   #if DECSUBSET\n@@ -203,6 +209,13 @@\n   #define DEC_Information (DEC_Clamped | DEC_Rounded | DEC_Inexact)\n   #endif\n \n+  /* IEEE 854 names (for compatibility with older decNumber versions) */\n+  #define DEC_IEEE_854_Division_by_zero  DEC_IEEE_754_Division_by_zero\n+  #define DEC_IEEE_854_Inexact\t\t DEC_IEEE_754_Inexact\n+  #define DEC_IEEE_854_Invalid_operation DEC_IEEE_754_Invalid_operation\n+  #define DEC_IEEE_854_Overflow \t DEC_IEEE_754_Overflow\n+  #define DEC_IEEE_854_Underflow\t DEC_IEEE_754_Underflow\n+\n   /* Name strings for the exceptional conditions\t\t      */\n   #define DEC_Condition_CS \"Conversion syntax\"\n   #define DEC_Condition_DZ \"Division by zero\"\n@@ -226,7 +239,7 @@\n \t\t\t\t   /* including terminator\t      */\n \n   /* Initialization descriptors, used by decContextDefault\t      */\n-  #define DEC_INIT_BASE\t\t0\n+  #define DEC_INIT_BASE \t0\n   #define DEC_INIT_DECIMAL32   32\n   #define DEC_INIT_DECIMAL64   64\n   #define DEC_INIT_DECIMAL128 128\n@@ -251,6 +264,7 @@\n   extern decContext  * decContextSetStatusFromStringQuiet(decContext *, const char *);\n   extern decContext  * decContextSetStatusQuiet(decContext *, uint32_t);\n   extern const char  * decContextStatusToString(const decContext *);\n+  extern int32_t       decContextTestEndian(uint8_t);\n   extern uint32_t      decContextTestSavedStatus(uint32_t, uint32_t);\n   extern uint32_t      decContextTestStatus(decContext *, uint32_t);\n   extern decContext  * decContextZeroStatus(decContext *);"}, {"sha": "87b35d038b82c2a076fe34dabf8a78091e602a9b", "filename": "libdecnumber/decDPD.h", "status": "modified", "additions": 22, "deletions": 23, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f988ec96d922819a4948c1ed96c6dc1b79a7ad22/libdecnumber%2FdecDPD.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f988ec96d922819a4948c1ed96c6dc1b79a7ad22/libdecnumber%2FdecDPD.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libdecnumber%2FdecDPD.h?ref=f988ec96d922819a4948c1ed96c6dc1b79a7ad22", "patch": "@@ -30,10 +30,9 @@\n \n /* ------------------------------------------------------------------------ */\n /* Binary Coded Decimal and Densely Packed Decimal conversion lookup tables */\n-/* [Automatically generated -- do not edit.  2007.05.05]\t\t    */\n+/* [Automatically generated -- do not edit.  2008.06.21]\t\t    */\n /* ------------------------------------------------------------------------ */\n-/* ------------------------------------------------------------------------ */\n-/* For details, see: http://www2.hursley.ibm.com/decimal/DPDecimal.html\t    */\n+/* For details, see DPDecimal.html on the General Decimal Arithmetic page.  */\n \n #include \"decDPDSymbols.h\"\n \n@@ -43,20 +42,20 @@\n /*   uint16_t BIN2DPD[1000];\t -- Bin -> DPD (999 => 2457)\t\t    */\n /*   uint8_t  BIN2CHAR[4001];\t -- Bin -> CHAR (999 => '\\3' '9' '9' '9')   */\n /*   uint8_t  BIN2BCD8[4000];\t -- Bin -> bytes (999 => 9 9 9 3)\t    */\n-/*   uint16_t DPD2BCD[1024];\t -- DPD -> BCD (0x3FF => 0x999)\t\t    */\n+/*   uint16_t DPD2BCD[1024];\t -- DPD -> BCD (0x3FF => 0x999) \t    */\n /*   uint16_t DPD2BIN[1024];\t -- DPD -> BIN (0x3FF => 999)\t\t    */\n-/*   uint32_t DPD2BINK[1024];\t -- DPD -> BIN * 1000 (0x3FF => 999000)\t    */\n+/*   uint32_t DPD2BINK[1024];\t -- DPD -> BIN * 1000 (0x3FF => 999000)     */\n /*   uint32_t DPD2BINM[1024];\t -- DPD -> BIN * 1E+6 (0x3FF => 999000000)  */\n /*   uint8_t  DPD2BCD8[4096];\t -- DPD -> bytes (x3FF => 9 9 9 3)\t    */\n /*\t\t\t\t\t\t\t\t\t    */\n /* In all cases the result (10 bits or 12 bits, or binary) is right-aligned */\n /* in the table entry.\tBIN2CHAR entries are a single byte length (0 for    */\n /* value 0) followed by three digit characters; a trailing terminator is    */\n /* included to allow 4-char moves always.  BIN2BCD8 and DPD2BCD8 entries    */\n-/* are similar with the three BCD8 digits followed by a one-byte length\t    */\n+/* are similar with the three BCD8 digits followed by a one-byte length     */\n /* (again, length=0 for value 0).\t\t\t\t\t    */\n /*\t\t\t\t\t\t\t\t\t    */\n-/* To use a table, its name, prefixed with DEC_, must be defined with a\t    */\n+/* To use a table, its name, prefixed with DEC_, must be defined with a     */\n /* value of 1 before this header file is included.  For example:\t    */\n /*    #define DEC_BCD2DPD 1\t\t\t\t\t\t    */\n /* This mechanism allows software to only include tables that are needed.   */\n@@ -513,7 +512,7 @@ const uint16_t DPD2BIN[1024]={\t  0,\t1,    2,    3,\t  4,\t5,    6,    7,\n #if defined(DEC_DPD2BINK) && DEC_DPD2BINK==1 && !defined(DECDPD2BINK)\n #define DECDPD2BINK\n \n-const uint32_t DPD2BINK[1024]={\t      0,   1000,   2000,   3000,   4000,   5000,\n+const uint32_t DPD2BINK[1024]={       0,   1000,   2000,   3000,   4000,   5000,\n    6000,   7000,   8000,   9000,  80000,  81000, 800000, 801000, 880000, 881000,\n   10000,  11000,  12000,  13000,  14000,  15000,  16000,  17000,  18000,  19000,\n   90000,  91000, 810000, 811000, 890000, 891000,  20000,  21000,  22000,  23000,\n@@ -621,24 +620,24 @@ const uint32_t DPD2BINK[1024]={\t      0,   1000,   2000,   3000,   4000,   5000,\n #if defined(DEC_DPD2BINM) && DEC_DPD2BINM==1 && !defined(DECDPD2BINM)\n #define DECDPD2BINM\n \n-const uint32_t DPD2BINM[1024]={0,   1000000,   2000000,\t  3000000,   4000000,\n-   5000000,   6000000,\t 7000000,   8000000,   9000000,\t 80000000,  81000000,\n- 800000000, 801000000, 880000000, 881000000,  10000000,\t 11000000,  12000000,\n-  13000000,  14000000,\t15000000,  16000000,  17000000,\t 18000000,  19000000,\n+const uint32_t DPD2BINM[1024]={0,   1000000,   2000000,   3000000,   4000000,\n+   5000000,   6000000,\t 7000000,   8000000,   9000000,  80000000,  81000000,\n+ 800000000, 801000000, 880000000, 881000000,  10000000,  11000000,  12000000,\n+  13000000,  14000000,\t15000000,  16000000,  17000000,  18000000,  19000000,\n   90000000,  91000000, 810000000, 811000000, 890000000, 891000000,  20000000,\n-  21000000,  22000000,\t23000000,  24000000,  25000000,\t 26000000,  27000000,\n+  21000000,  22000000,\t23000000,  24000000,  25000000,  26000000,  27000000,\n   28000000,  29000000,\t82000000,  83000000, 820000000, 821000000, 808000000,\n- 809000000,  30000000,\t31000000,  32000000,  33000000,\t 34000000,  35000000,\n-  36000000,  37000000,\t38000000,  39000000,  92000000,\t 93000000, 830000000,\n- 831000000, 818000000, 819000000,  40000000,  41000000,\t 42000000,  43000000,\n-  44000000,  45000000,\t46000000,  47000000,  48000000,\t 49000000,  84000000,\n-  85000000, 840000000, 841000000,  88000000,  89000000,\t 50000000,  51000000,\n-  52000000,  53000000,\t54000000,  55000000,  56000000,\t 57000000,  58000000,\n-  59000000,  94000000,\t95000000, 850000000, 851000000,\t 98000000,  99000000,\n-  60000000,  61000000,\t62000000,  63000000,  64000000,\t 65000000,  66000000,\n+ 809000000,  30000000,\t31000000,  32000000,  33000000,  34000000,  35000000,\n+  36000000,  37000000,\t38000000,  39000000,  92000000,  93000000, 830000000,\n+ 831000000, 818000000, 819000000,  40000000,  41000000,  42000000,  43000000,\n+  44000000,  45000000,\t46000000,  47000000,  48000000,  49000000,  84000000,\n+  85000000, 840000000, 841000000,  88000000,  89000000,  50000000,  51000000,\n+  52000000,  53000000,\t54000000,  55000000,  56000000,  57000000,  58000000,\n+  59000000,  94000000,\t95000000, 850000000, 851000000,  98000000,  99000000,\n+  60000000,  61000000,\t62000000,  63000000,  64000000,  65000000,  66000000,\n   67000000,  68000000,\t69000000,  86000000,  87000000, 860000000, 861000000,\n- 888000000, 889000000,\t70000000,  71000000,  72000000,\t 73000000,  74000000,\n-  75000000,  76000000,\t77000000,  78000000,  79000000,\t 96000000,  97000000,\n+ 888000000, 889000000,\t70000000,  71000000,  72000000,  73000000,  74000000,\n+  75000000,  76000000,\t77000000,  78000000,  79000000,  96000000,  97000000,\n  870000000, 871000000, 898000000, 899000000, 100000000, 101000000, 102000000,\n  103000000, 104000000, 105000000, 106000000, 107000000, 108000000, 109000000,\n  180000000, 181000000, 900000000, 901000000, 980000000, 981000000, 110000000,"}, {"sha": "030cc2b86cd00a87a652b92b2c8f23c1a2629f0b", "filename": "libdecnumber/decDouble.c", "status": "modified", "additions": 86, "deletions": 88, "changes": 174, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f988ec96d922819a4948c1ed96c6dc1b79a7ad22/libdecnumber%2FdecDouble.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f988ec96d922819a4948c1ed96c6dc1b79a7ad22/libdecnumber%2FdecDouble.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libdecnumber%2FdecDouble.c?ref=f988ec96d922819a4948c1ed96c6dc1b79a7ad22", "patch": "@@ -34,19 +34,19 @@\n /* This module comprises decDouble operations (including conversions) */\n /* ------------------------------------------------------------------ */\n \n-#include \"decContext.h\"\t      /* public includes */\n+#include \"decContext.h\"       /* public includes */\n #include \"decDouble.h\"\t      /* .. */\n \n /* Constant mappings for shared code */\n-#define DECPMAX\t    DECDOUBLE_Pmax\n-#define DECEMIN\t    DECDOUBLE_Emin\n-#define DECEMAX\t    DECDOUBLE_Emax\n+#define DECPMAX     DECDOUBLE_Pmax\n+#define DECEMIN     DECDOUBLE_Emin\n+#define DECEMAX     DECDOUBLE_Emax\n #define DECEMAXD    DECDOUBLE_EmaxD\n #define DECBYTES    DECDOUBLE_Bytes\n #define DECSTRING   DECDOUBLE_String\n #define DECECONL    DECDOUBLE_EconL\n-#define DECBIAS\t    DECDOUBLE_Bias\n-#define DECLETS\t    DECDOUBLE_Declets\n+#define DECBIAS     DECDOUBLE_Bias\n+#define DECLETS     DECDOUBLE_Declets\n #define DECQTINY    (-DECDOUBLE_Bias)\n /* parameters of next-wider format */\n #define DECWBYTES   DECQUAD_Bytes\n@@ -55,100 +55,98 @@\n #define DECWBIAS    DECQUAD_Bias\n \n /* Type and function mappings for shared code */\n-#define decFloat\t       decDouble\t  /* Type name */\n-#define decFloatWider\t       decQuad\t\t  /* Type name */\n+#define decFloat\t\t   decDouble\t  /* Type name */\n+#define decFloatWider\t\t   decQuad\t  /* Type name */\n \n /* Utilities and conversions (binary results, extractors, etc.) */\n-#define decFloatFromBCD\t\tdecDoubleFromBCD\n-#define decFloatFromInt32\tdecDoubleFromInt32\n-#define decFloatFromPacked\tdecDoubleFromPacked\n-#define decFloatFromString\tdecDoubleFromString\n-#define decFloatFromUInt32\tdecDoubleFromUInt32\n-#define decFloatFromWider\tdecDoubleFromWider\n-#define decFloatGetCoefficient\tdecDoubleGetCoefficient\n-#define decFloatGetExponent\tdecDoubleGetExponent\n-#define decFloatSetCoefficient\tdecDoubleSetCoefficient\n-#define decFloatSetExponent\tdecDoubleSetExponent\n-#define decFloatShow\t\tdecDoubleShow\n-#define decFloatToBCD\t\tdecDoubleToBCD\n-#define decFloatToEngString\tdecDoubleToEngString\n-#define decFloatToInt32\t\tdecDoubleToInt32\n-#define decFloatToInt32Exact\tdecDoubleToInt32Exact\n-#define decFloatToPacked\tdecDoubleToPacked\n-#define decFloatToString\tdecDoubleToString\n-#define decFloatToUInt32\tdecDoubleToUInt32\n-#define decFloatToUInt32Exact\tdecDoubleToUInt32Exact\n-#define decFloatToWider\t\tdecDoubleToWider\n-#define decFloatZero\t\tdecDoubleZero\n+#define decFloatFromBCD \t   decDoubleFromBCD\n+#define decFloatFromInt32\t   decDoubleFromInt32\n+#define decFloatFromPacked\t   decDoubleFromPacked\n+#define decFloatFromPackedChecked  decDoubleFromPackedChecked\n+#define decFloatFromString\t   decDoubleFromString\n+#define decFloatFromUInt32\t   decDoubleFromUInt32\n+#define decFloatFromWider\t   decDoubleFromWider\n+#define decFloatGetCoefficient\t   decDoubleGetCoefficient\n+#define decFloatGetExponent\t   decDoubleGetExponent\n+#define decFloatSetCoefficient\t   decDoubleSetCoefficient\n+#define decFloatSetExponent\t   decDoubleSetExponent\n+#define decFloatShow\t\t   decDoubleShow\n+#define decFloatToBCD\t\t   decDoubleToBCD\n+#define decFloatToEngString\t   decDoubleToEngString\n+#define decFloatToInt32 \t   decDoubleToInt32\n+#define decFloatToInt32Exact\t   decDoubleToInt32Exact\n+#define decFloatToPacked\t   decDoubleToPacked\n+#define decFloatToString\t   decDoubleToString\n+#define decFloatToUInt32\t   decDoubleToUInt32\n+#define decFloatToUInt32Exact\t   decDoubleToUInt32Exact\n+#define decFloatToWider \t   decDoubleToWider\n+#define decFloatZero\t\t   decDoubleZero\n \n /* Computational (result is a decFloat) */\n-#define decFloatAbs\t\tdecDoubleAbs\n-#define decFloatAdd\t\tdecDoubleAdd\n-#define decFloatAnd\t\tdecDoubleAnd\n-#define decFloatDivide\t\tdecDoubleDivide\n-#define decFloatDivideInteger\tdecDoubleDivideInteger\n-#define decFloatFMA\t\tdecDoubleFMA\n-#define decFloatInvert\t\tdecDoubleInvert\n-#define decFloatLogB\t\tdecDoubleLogB\n-#define decFloatMax\t\tdecDoubleMax\n-#define decFloatMaxMag\t\tdecDoubleMaxMag\n-#define decFloatMin\t\tdecDoubleMin\n-#define decFloatMinMag\t\tdecDoubleMinMag\n-#define decFloatMinus\t\tdecDoubleMinus\n-#define decFloatMultiply\tdecDoubleMultiply\n-#define decFloatNextMinus\tdecDoubleNextMinus\n-#define decFloatNextPlus\tdecDoubleNextPlus\n-#define decFloatNextToward\tdecDoubleNextToward\n-#define decFloatOr\t\tdecDoubleOr\n-#define decFloatPlus\t\tdecDoublePlus\n-#define decFloatQuantize\tdecDoubleQuantize\n-#define decFloatReduce\t\tdecDoubleReduce\n-#define decFloatRemainder\tdecDoubleRemainder\n-#define decFloatRemainderNear\tdecDoubleRemainderNear\n-#define decFloatRotate\t\tdecDoubleRotate\n-#define decFloatScaleB\t\tdecDoubleScaleB\n-#define decFloatShift\t\tdecDoubleShift\n-#define decFloatSubtract\tdecDoubleSubtract\n-#define decFloatToIntegralValue decDoubleToIntegralValue\n-#define decFloatToIntegralExact decDoubleToIntegralExact\n-#define decFloatXor\t\tdecDoubleXor\n+#define decFloatAbs\t\t   decDoubleAbs\n+#define decFloatAdd\t\t   decDoubleAdd\n+#define decFloatAnd\t\t   decDoubleAnd\n+#define decFloatDivide\t\t   decDoubleDivide\n+#define decFloatDivideInteger\t   decDoubleDivideInteger\n+#define decFloatFMA\t\t   decDoubleFMA\n+#define decFloatInvert\t\t   decDoubleInvert\n+#define decFloatLogB\t\t   decDoubleLogB\n+#define decFloatMax\t\t   decDoubleMax\n+#define decFloatMaxMag\t\t   decDoubleMaxMag\n+#define decFloatMin\t\t   decDoubleMin\n+#define decFloatMinMag\t\t   decDoubleMinMag\n+#define decFloatMinus\t\t   decDoubleMinus\n+#define decFloatMultiply\t   decDoubleMultiply\n+#define decFloatNextMinus\t   decDoubleNextMinus\n+#define decFloatNextPlus\t   decDoubleNextPlus\n+#define decFloatNextToward\t   decDoubleNextToward\n+#define decFloatOr\t\t   decDoubleOr\n+#define decFloatPlus\t\t   decDoublePlus\n+#define decFloatQuantize\t   decDoubleQuantize\n+#define decFloatReduce\t\t   decDoubleReduce\n+#define decFloatRemainder\t   decDoubleRemainder\n+#define decFloatRemainderNear\t   decDoubleRemainderNear\n+#define decFloatRotate\t\t   decDoubleRotate\n+#define decFloatScaleB\t\t   decDoubleScaleB\n+#define decFloatShift\t\t   decDoubleShift\n+#define decFloatSubtract\t   decDoubleSubtract\n+#define decFloatToIntegralValue    decDoubleToIntegralValue\n+#define decFloatToIntegralExact    decDoubleToIntegralExact\n+#define decFloatXor\t\t   decDoubleXor\n \n /* Comparisons */\n-#define decFloatCompare\t\tdecDoubleCompare\n-#define decFloatCompareSignal\tdecDoubleCompareSignal\n-#define decFloatCompareTotal\tdecDoubleCompareTotal\n-#define decFloatCompareTotalMag decDoubleCompareTotalMag\n+#define decFloatCompare \t   decDoubleCompare\n+#define decFloatCompareSignal\t   decDoubleCompareSignal\n+#define decFloatCompareTotal\t   decDoubleCompareTotal\n+#define decFloatCompareTotalMag    decDoubleCompareTotalMag\n \n /* Copies */\n-#define decFloatCanonical\tdecDoubleCanonical\n-#define decFloatCopy\t\tdecDoubleCopy\n-#define decFloatCopyAbs\t\tdecDoubleCopyAbs\n-#define decFloatCopyNegate\tdecDoubleCopyNegate\n-#define decFloatCopySign\tdecDoubleCopySign\n+#define decFloatCanonical\t   decDoubleCanonical\n+#define decFloatCopy\t\t   decDoubleCopy\n+#define decFloatCopyAbs \t   decDoubleCopyAbs\n+#define decFloatCopyNegate\t   decDoubleCopyNegate\n+#define decFloatCopySign\t   decDoubleCopySign\n \n /* Non-computational */\n-#define decFloatClass\t\tdecDoubleClass\n-#define decFloatClassString\tdecDoubleClassString\n-#define decFloatDigits\t\tdecDoubleDigits\n-#define decFloatIsCanonical\tdecDoubleIsCanonical\n-#define decFloatIsFinite\tdecDoubleIsFinite\n-#define decFloatIsInfinite\tdecDoubleIsInfinite\n-#define decFloatIsInteger\tdecDoubleIsInteger\n-#define decFloatIsNaN\t\tdecDoubleIsNaN\n-#define decFloatIsNormal\tdecDoubleIsNormal\n-#define decFloatIsSignaling\tdecDoubleIsSignaling\n-#define decFloatIsSignalling\tdecDoubleIsSignalling\n-#define decFloatIsSigned\tdecDoubleIsSigned\n-#define decFloatIsSubnormal\tdecDoubleIsSubnormal\n-#define decFloatIsZero\t\tdecDoubleIsZero\n-#define decFloatRadix\t\tdecDoubleRadix\n-#define decFloatSameQuantum\tdecDoubleSameQuantum\n-#define decFloatVersion\t\tdecDoubleVersion\n-\n+#define decFloatClass\t\t   decDoubleClass\n+#define decFloatClassString\t   decDoubleClassString\n+#define decFloatDigits\t\t   decDoubleDigits\n+#define decFloatIsCanonical\t   decDoubleIsCanonical\n+#define decFloatIsFinite\t   decDoubleIsFinite\n+#define decFloatIsInfinite\t   decDoubleIsInfinite\n+#define decFloatIsInteger\t   decDoubleIsInteger\n+#define decFloatIsNaN\t\t   decDoubleIsNaN\n+#define decFloatIsNormal\t   decDoubleIsNormal\n+#define decFloatIsSignaling\t   decDoubleIsSignaling\n+#define decFloatIsSignalling\t   decDoubleIsSignalling\n+#define decFloatIsSigned\t   decDoubleIsSigned\n+#define decFloatIsSubnormal\t   decDoubleIsSubnormal\n+#define decFloatIsZero\t\t   decDoubleIsZero\n+#define decFloatRadix\t\t   decDoubleRadix\n+#define decFloatSameQuantum\t   decDoubleSameQuantum\n+#define decFloatVersion \t   decDoubleVersion\n \n #include \"decNumberLocal.h\"   /* local includes (need DECPMAX) */\n #include \"decCommon.c\"\t      /* non-arithmetic decFloat routines */\n #include \"decBasic.c\"\t      /* basic formats routines */\n \n-/* Below here will move to shared file as completed */\n-"}, {"sha": "aa8d77d4b73fa937836e27e4996a03616b187636", "filename": "libdecnumber/decDouble.h", "status": "modified", "additions": 14, "deletions": 11, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f988ec96d922819a4948c1ed96c6dc1b79a7ad22/libdecnumber%2FdecDouble.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f988ec96d922819a4948c1ed96c6dc1b79a7ad22/libdecnumber%2FdecDouble.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libdecnumber%2FdecDouble.h?ref=f988ec96d922819a4948c1ed96c6dc1b79a7ad22", "patch": "@@ -31,24 +31,22 @@\n /* ------------------------------------------------------------------ */\n /* decDouble.h -- Decimal 64-bit format module header\t\t      */\n /* ------------------------------------------------------------------ */\n-/* Please see decFloats.h for an overview and documentation details.  */\n-/* ------------------------------------------------------------------ */\n \n #if !defined(DECDOUBLE)\n   #define DECDOUBLE\n \n-  #define DECDOUBLENAME\t      \"decimalDouble\"\t      /* Short name   */\n+  #define DECDOUBLENAME       \"decimalDouble\"\t      /* Short name   */\n   #define DECDOUBLETITLE      \"Decimal 64-bit datum\"  /* Verbose name */\n   #define DECDOUBLEAUTHOR     \"Mike Cowlishaw\"\t      /* Who to blame */\n \n   /* parameters for decDoubles */\n   #define DECDOUBLE_Bytes   8\t   /* length\t\t\t      */\n   #define DECDOUBLE_Pmax    16\t   /* maximum precision (digits)      */\n-  #define DECDOUBLE_Emin   -383\t   /* minimum adjusted exponent\t      */\n-  #define DECDOUBLE_Emax    384\t   /* maximum adjusted exponent\t      */\n+  #define DECDOUBLE_Emin   -383    /* minimum adjusted exponent       */\n+  #define DECDOUBLE_Emax    384    /* maximum adjusted exponent       */\n   #define DECDOUBLE_EmaxD   3\t   /* maximum exponent digits\t      */\n-  #define DECDOUBLE_Bias    398\t   /* bias for the exponent\t      */\n-  #define DECDOUBLE_String  25\t   /* maximum string length, +1\t      */\n+  #define DECDOUBLE_Bias    398    /* bias for the exponent\t      */\n+  #define DECDOUBLE_String  25\t   /* maximum string length, +1       */\n   #define DECDOUBLE_EconL   8\t   /* exponent continuation length    */\n   #define DECDOUBLE_Declets 5\t   /* count of declets\t\t      */\n   /* highest biased exponent (Elimit-1) */\n@@ -58,11 +56,14 @@\n   #include \"decContext.h\"\n   #include \"decQuad.h\"\n \n-  /* The decDouble decimal 64-bit type, accessible by various types */\n+  /* The decDouble decimal 64-bit type, accessible by all sizes */\n   typedef union {\n-    uint8_t bytes[DECDOUBLE_Bytes]; /* fields: 1, 5, 8, 50 bits\t  */\n+    uint8_t   bytes[DECDOUBLE_Bytes];\t/* fields: 1, 5, 8, 50 bits */\n     uint16_t shorts[DECDOUBLE_Bytes/2];\n-    uint32_t words[DECDOUBLE_Bytes/4];\n+    uint32_t  words[DECDOUBLE_Bytes/4];\n+    #if DECUSE64\n+    uint64_t  longs[DECDOUBLE_Bytes/8];\n+    #endif\n     } decDouble;\n \n   /* ---------------------------------------------------------------- */\n@@ -75,6 +76,7 @@\n   extern decDouble * decDoubleFromBCD(decDouble *, int32_t, const uint8_t *, int32_t);\n   extern decDouble * decDoubleFromInt32(decDouble *, int32_t);\n   extern decDouble * decDoubleFromPacked(decDouble *, int32_t, const uint8_t *);\n+  extern decDouble * decDoubleFromPackedChecked(decDouble *, int32_t, const uint8_t *);\n   extern decDouble * decDoubleFromString(decDouble *, const char *, decContext *);\n   extern decDouble * decDoubleFromUInt32(decDouble *, uint32_t);\n   extern decDouble * decDoubleFromWider(decDouble *, const decQuad *, decContext *);\n@@ -160,7 +162,8 @@\n \n   /* decNumber conversions; these are implemented as macros so as not  */\n   /* to force a dependency on decimal64 and decNumber in decDouble.    */\n+  /* decDoubleFromNumber returns a decimal64 * to avoid warnings.      */\n   #define decDoubleToNumber(dq, dn) decimal64ToNumber((decimal64 *)(dq), dn)\n-  #define decDoubleFromNumber(dq, dn, set) (decDouble *)decimal64FromNumber((decimal64 *)(dq), dn, set)\n+  #define decDoubleFromNumber(dq, dn, set) decimal64FromNumber((decimal64 *)(dq), dn, set)\n \n #endif"}, {"sha": "ebc7cf0fb50bffbdde33e0ab071b484bfd3bd24d", "filename": "libdecnumber/decNumber.c", "status": "modified", "additions": 443, "deletions": 423, "changes": 866, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f988ec96d922819a4948c1ed96c6dc1b79a7ad22/libdecnumber%2FdecNumber.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f988ec96d922819a4948c1ed96c6dc1b79a7ad22/libdecnumber%2FdecNumber.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libdecnumber%2FdecNumber.c?ref=f988ec96d922819a4948c1ed96c6dc1b79a7ad22"}, {"sha": "72dbdaf46b32bfb46f3845dbfd69325e8add7cf7", "filename": "libdecnumber/decNumber.h", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f988ec96d922819a4948c1ed96c6dc1b79a7ad22/libdecnumber%2FdecNumber.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f988ec96d922819a4948c1ed96c6dc1b79a7ad22/libdecnumber%2FdecNumber.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libdecnumber%2FdecNumber.h?ref=f988ec96d922819a4948c1ed96c6dc1b79a7ad22", "patch": "@@ -46,7 +46,7 @@\n   #define DECNEG    0x80      /* Sign; 1=negative, 0=positive or zero */\n   #define DECINF    0x40      /* 1=Infinity\t\t\t      */\n   #define DECNAN    0x20      /* 1=NaN\t\t\t\t      */\n-  #define DECSNAN   0x10      /* 1=sNaN\t\t\t\t      */\n+  #define DECSNAN   0x10      /* 1=sNaN \t\t\t      */\n   /* The remaining bits are reserved; they must be 0\t\t      */\n   #define DECSPECIAL (DECINF|DECNAN|DECSNAN) /* any special value     */\n \n@@ -124,7 +124,7 @@\n   uint8_t   * decNumberGetBCD(const decNumber *, uint8_t *);\n   decNumber * decNumberSetBCD(decNumber *, const uint8_t *, uint32_t);\n \n-  /* Operators and elementary functions\t\t\t\t      */\n+  /* Operators and elementary functions \t\t\t      */\n   decNumber * decNumberAbs(decNumber *, const decNumber *, decContext *);\n   decNumber * decNumberAdd(decNumber *, const decNumber *, const decNumber *, decContext *);\n   decNumber * decNumberAnd(decNumber *, const decNumber *, const decNumber *, decContext *);\n@@ -185,7 +185,7 @@\n \n   /* Macros for testing decNumber *dn\t\t\t\t      */\n   #define decNumberIsCanonical(dn) (1)\t/* All decNumbers are saintly */\n-  #define decNumberIsFinite(dn)\t   (((dn)->bits&DECSPECIAL)==0)\n+  #define decNumberIsFinite(dn)    (((dn)->bits&DECSPECIAL)==0)\n   #define decNumberIsInfinite(dn)  (((dn)->bits&DECINF)!=0)\n   #define decNumberIsNaN(dn)\t   (((dn)->bits&(DECNAN|DECSNAN))!=0)\n   #define decNumberIsNegative(dn)  (((dn)->bits&DECNEG)!=0)"}, {"sha": "c31b50db2450f208b8fa0b8c6fb12564cf18bebd", "filename": "libdecnumber/decNumberLocal.h", "status": "modified", "additions": 162, "deletions": 79, "changes": 241, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f988ec96d922819a4948c1ed96c6dc1b79a7ad22/libdecnumber%2FdecNumberLocal.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f988ec96d922819a4948c1ed96c6dc1b79a7ad22/libdecnumber%2FdecNumberLocal.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libdecnumber%2FdecNumberLocal.h?ref=f988ec96d922819a4948c1ed96c6dc1b79a7ad22", "patch": "@@ -31,42 +31,48 @@\n /* ------------------------------------------------------------------ */\n /* decNumber package local type, tuning, and macro definitions\t      */\n /* ------------------------------------------------------------------ */\n-/* This header file is included by all modules in the decNumber\t      */\n+/* This header file is included by all modules in the decNumber       */\n /* library, and contains local type definitions, tuning parameters,   */\n-/* etc.\t It should not need to be used by application programs.\t      */\n+/* etc.  It should not need to be used by application programs.       */\n /* decNumber.h or one of decDouble (etc.) must be included first.     */\n /* ------------------------------------------------------------------ */\n \n #if !defined(DECNUMBERLOC)\n   #define DECNUMBERLOC\n-  #define DECVERSION\t\"decNumber 3.53\" /* Package Version [16 max.] */\n+  #define DECVERSION\t\"decNumber 3.61\" /* Package Version [16 max.] */\n   #define DECNLAUTHOR\t\"Mike Cowlishaw\"\t      /* Who to blame */\n \n   #include <stdlib.h>\t      /* for abs\t\t\t      */\n   #include <string.h>\t      /* for memset, strcpy\t\t      */\n-  #include \"dconfig.h\"\t      /* for WORDS_BIGENDIAN                  */\n \n   /* Conditional code flag -- set this to match hardware platform     */\n-  /* 1=little-endian, 0=big-endian\t                              */\n-  #if WORDS_BIGENDIAN\n-  #define DECLITEND 0\n-  #else\n-  #define DECLITEND 1\n+  #if !defined(DECLITEND)\n+  #define DECLITEND 1\t      /* 1=little-endian, 0=big-endian\t      */\n   #endif\n \n   /* Conditional code flag -- set this to 1 for best performance      */\n+  #if !defined(DECUSE64)\n   #define DECUSE64  1\t      /* 1=use int64s, 0=int32 & smaller only */\n+  #endif\n \n   /* Conditional check flags -- set these to 0 for best performance   */\n+  #if !defined(DECCHECK)\n   #define DECCHECK  0\t      /* 1 to enable robust checking\t      */\n+  #endif\n+  #if !defined(DECALLOC)\n   #define DECALLOC  0\t      /* 1 to enable memory accounting\t      */\n+  #endif\n+  #if !defined(DECTRACE)\n   #define DECTRACE  0\t      /* 1 to trace certain internals, etc.   */\n+  #endif\n \n   /* Tuning parameter for decNumber (arbitrary precision) module      */\n+  #if !defined(DECBUFFER)\n   #define DECBUFFER 36\t      /* Size basis for local buffers.\tThis  */\n \t\t\t      /* should be a common maximum precision */\n \t\t\t      /* rounded up to a multiple of 4; must  */\n \t\t\t      /* be zero or positive.\t\t      */\n+  #endif\n \n   /* ---------------------------------------------------------------- */\n   /* Definitions for all modules (general-purpose)\t\t      */\n@@ -76,33 +82,33 @@\n   /* not use int or long directly.\t\t\t\t      */\n   #define Flag\t uint8_t\n   #define Byte\t int8_t\n-  #define uByte\t uint8_t\n-  #define Short\t int16_t\n+  #define uByte  uint8_t\n+  #define Short  int16_t\n   #define uShort uint16_t\n   #define Int\t int32_t\n   #define uInt\t uint32_t\n   #define Unit\t decNumberUnit\n   #if DECUSE64\n   #define Long\t int64_t\n-  #define uLong\t uint64_t\n+  #define uLong  uint64_t\n   #endif\n \n   /* Development-use definitions\t\t\t\t      */\n   typedef long int LI;\t      /* for printf arguments only\t      */\n   #define DECNOINT  0\t      /* 1 to check no internal use of 'int'  */\n+\t\t\t      /*   or stdint types\t\t      */\n   #if DECNOINT\n     /* if these interfere with your C includes, do not set DECNOINT   */\n-    #define  int ?\t      /* enable to ensure that plain C 'int'  */\n-    #define  long ??\t      /* .. or 'long' types are not used      */\n+    #define int     ?\t      /* enable to ensure that plain C 'int'  */\n+    #define long    ??\t      /* .. or 'long' types are not used      */\n   #endif\n \n   /* Shared lookup tables\t\t\t\t\t      */\n   extern const uByte  DECSTICKYTAB[10]; /* re-round digits if sticky  */\n   extern const uInt   DECPOWERS[10];\t/* powers of ten table\t      */\n   /* The following are included from decDPD.h\t\t\t      */\n-#include \"decDPDSymbols.h\"\n-  extern const uShort DPD2BIN[1024];\t/* DPD -> 0-999\t\t      */\n-  extern const uShort BIN2DPD[1000];\t/* 0-999 -> DPD\t\t      */\n+  extern const uShort DPD2BIN[1024];\t/* DPD -> 0-999 \t      */\n+  extern const uShort BIN2DPD[1000];\t/* 0-999 -> DPD \t      */\n   extern const uInt   DPD2BINK[1024];\t/* DPD -> 0-999000\t      */\n   extern const uInt   DPD2BINM[1024];\t/* DPD -> 0-999000000\t      */\n   extern const uByte  DPD2BCD8[4096];\t/* DPD -> ddd + len\t      */\n@@ -111,32 +117,42 @@\n \n   /* LONGMUL32HI -- set w=(u*v)>>32, where w, u, and v are uInts      */\n   /* (that is, sets w to be the high-order word of the 64-bit result; */\n-  /* the low-order word is simply u*v.)\t\t\t\t      */\n+  /* the low-order word is simply u*v.) \t\t\t      */\n   /* This version is derived from Knuth via Hacker's Delight;\t      */\n-  /* it seems to optimize better than some others tried\t\t      */\n+  /* it seems to optimize better than some others tried \t      */\n   #define LONGMUL32HI(w, u, v) {\t     \\\n-    uInt u0, u1, v0, v1, w0, w1, w2, t;\t     \\\n+    uInt u0, u1, v0, v1, w0, w1, w2, t;      \\\n     u0=u & 0xffff; u1=u>>16;\t\t     \\\n     v0=v & 0xffff; v1=v>>16;\t\t     \\\n     w0=u0*v0;\t\t\t\t     \\\n-    t=u1*v0 + (w0>>16);\t\t\t     \\\n+    t=u1*v0 + (w0>>16); \t\t     \\\n     w1=t & 0xffff; w2=t>>16;\t\t     \\\n     w1=u0*v1 + w1;\t\t\t     \\\n     (w)=u1*v1 + w2 + (w1>>16);}\n \n   /* ROUNDUP -- round an integer up to a multiple of n\t\t      */\n   #define ROUNDUP(i, n) ((((i)+(n)-1)/n)*n)\n+  #define ROUNDUP4(i)\t(((i)+3)&~3)\t/* special for n=4\t      */\n \n   /* ROUNDDOWN -- round an integer down to a multiple of n\t      */\n   #define ROUNDDOWN(i, n) (((i)/n)*n)\n-  #define ROUNDDOWN4(i)\t  ((i)&~3)\t/* special for n=4\t      */\n+  #define ROUNDDOWN4(i)   ((i)&~3)\t/* special for n=4\t      */\n+\n+  /* References to multi-byte sequences under different sizes; these  */\n+  /* require locally declared variables, but do not violate strict    */\n+  /* aliasing or alignment (as did the UINTAT simple cast to uInt).   */\n+  /* Variables needed are uswork, uiwork, etc. [so do not use at same */\n+  /* level in an expression, e.g., UBTOUI(x)==UBTOUI(y) may fail].    */\n \n-  /* References to multi-byte sequences under different sizes\t      */\n-  /* Refer to a uInt from four bytes starting at a char* or uByte*,   */\n-  /* etc.\t\t\t\t\t\t\t      */\n-  #define UINTAT(b)   (*((uInt\t *)(b)))\n-  #define USHORTAT(b) (*((uShort *)(b)))\n-  #define UBYTEAT(b)  (*((uByte\t *)(b)))\n+  /* Return a uInt, etc., from bytes starting at a char* or uByte*    */\n+  #define UBTOUS(b)  (memcpy((void *)&uswork, b, 2), uswork)\n+  #define UBTOUI(b)  (memcpy((void *)&uiwork, b, 4), uiwork)\n+\n+  /* Store a uInt, etc., into bytes starting at a char* or uByte*.    */\n+  /* Returns i, evaluated, for convenience; has to use uiwork because */\n+  /* i may be an expression.\t\t\t\t\t      */\n+  #define UBFROMUS(b, i)  (uswork=(i), memcpy(b, (void *)&uswork, 2), uswork)\n+  #define UBFROMUI(b, i)  (uiwork=(i), memcpy(b, (void *)&uiwork, 4), uiwork)\n \n   /* X10 and X100 -- multiply integer i by 10 or 100\t\t      */\n   /* [shifts are usually faster than multiply; could be conditional]  */\n@@ -149,7 +165,7 @@\n \n   /* Useful constants\t\t\t\t\t\t      */\n   #define BILLION      1000000000\t     /* 10**9\t\t      */\n-  /* CHARMASK: 0x30303030 for ASCII/UTF8; 0xF0F0F0F0 for EBCDIC\t      */\n+  /* CHARMASK: 0x30303030 for ASCII/UTF8; 0xF0F0F0F0 for EBCDIC       */\n   #define CHARMASK ((((((((uInt)'0')<<8)+'0')<<8)+'0')<<8)+'0')\n \n \n@@ -172,7 +188,7 @@\n     #error Minimum exponent mismatch\n   #endif\n \n-  /* Set DECDPUNMAX -- the maximum integer that fits in DECDPUN\t      */\n+  /* Set DECDPUNMAX -- the maximum integer that fits in DECDPUN       */\n   /* digits, and D2UTABLE -- the initializer for the D2U table\t      */\n   #if\tDECDPUN==1\n     #define DECDPUNMAX 9\n@@ -253,15 +269,15 @@\n   /* D2N -- return the number of decNumber structs that would be      */\n   /* needed to contain that number of digits (and the initial\t      */\n   /* decNumber struct) safely.\tNote that one Unit is included in the */\n-  /* initial structure.\t Used for allocating space that is aligned on */\n+  /* initial structure.  Used for allocating space that is aligned on */\n   /* a decNumber struct boundary. */\n   #define D2N(d) \\\n     ((((SD2U(d)-1)*sizeof(Unit))+sizeof(decNumber)*2-1)/sizeof(decNumber))\n \n   /* TODIGIT -- macro to remove the leading digit from the unsigned   */\n   /* integer u at column cut (counting from the right, LSD=0) and     */\n   /* place it as an ASCII character into the character pointed to by  */\n-  /* c.\t Note that cut must be <= 9, and the maximum value for u is   */\n+  /* c.  Note that cut must be <= 9, and the maximum value for u is   */\n   /* 2,000,000,000 (as is needed for negative exponents of\t      */\n   /* subnormals).  The unsigned integer pow is used as a temporary    */\n   /* variable. */\n@@ -274,7 +290,7 @@\n       pow/=2;\t\t\t\t  \\\n       if ((u)>=pow) {(u)-=pow; *(c)+=4;}  \\\n       pow/=2;\t\t\t\t  \\\n-      }\t\t\t\t\t  \\\n+      } \t\t\t\t  \\\n     if ((u)>=pow) {(u)-=pow; *(c)+=2;}\t  \\\n     pow/=2;\t\t\t\t  \\\n     if ((u)>=pow) {(u)-=pow; *(c)+=1;}\t  \\\n@@ -289,9 +305,9 @@\n   /* number, whose coefficient is a string of bcd8 uBytes\t      */\n   typedef struct {\n     uByte   *msd;\t      /* -> most significant digit\t      */\n-    uByte   *lsd;\t      /* -> least ditto\t\t\t      */\n+    uByte   *lsd;\t      /* -> least ditto \t\t      */\n     uInt     sign;\t      /* 0=positive, DECFLOAT_Sign=negative   */\n-    Int\t     exponent;\t      /* Unadjusted signed exponent (q), or   */\n+    Int      exponent;\t      /* Unadjusted signed exponent (q), or   */\n \t\t\t      /* DECFLOAT_NaN etc. for a special      */\n     } bcdnum;\n \n@@ -308,12 +324,12 @@\n   #define DECWORDS  (DECBYTES/4)\n   #define DECWWORDS (DECWBYTES/4)\n   #if DECLITEND\n-    #define DFWORD(df, off) ((df)->words[DECWORDS-1-(off)])\n-    #define DFBYTE(df, off) ((df)->bytes[DECBYTES-1-(off)])\n+    #define DFBYTE(df, off)   ((df)->bytes[DECBYTES-1-(off)])\n+    #define DFWORD(df, off)   ((df)->words[DECWORDS-1-(off)])\n     #define DFWWORD(dfw, off) ((dfw)->words[DECWWORDS-1-(off)])\n   #else\n-    #define DFWORD(df, off) ((df)->words[off])\n-    #define DFBYTE(df, off) ((df)->bytes[off])\n+    #define DFBYTE(df, off)   ((df)->bytes[off])\n+    #define DFWORD(df, off)   ((df)->words[off])\n     #define DFWWORD(dfw, off) ((dfw)->words[off])\n   #endif\n \n@@ -326,7 +342,6 @@\n   #define DFISSNAN(df)\t  ((DFWORD(df, 0)&0x7e000000)==0x7e000000)\n \n   /* Shared lookup tables\t\t\t\t\t      */\n-#include \"decCommonSymbols.h\"\n   extern const uInt   DECCOMBMSD[64];\t/* Combination field -> MSD   */\n   extern const uInt   DECCOMBFROM[48];\t/* exp+msd -> Combination     */\n \n@@ -338,7 +353,7 @@\n   /* Format-dependent macros and constants\t\t\t      */\n   #if defined(DECPMAX)\n \n-    /* Useful constants\t\t\t\t\t\t      */\n+    /* Useful constants \t\t\t\t\t      */\n     #define DECPMAX9  (ROUNDUP(DECPMAX, 9)/9)  /* 'Pmax' in 10**9s    */\n     /* Top words for a zero\t\t\t\t\t      */\n     #define SINGLEZERO\t 0x22500000\n@@ -350,10 +365,10 @@\n     /*\t DFISZERO   -- test for (any) zero\t\t\t      */\n     /*\t DFISCCZERO -- test for coefficient continuation being zero   */\n     /*\t DFISCC01   -- test for coefficient contains only 0s and 1s   */\n-    /*\t DFISINT    -- test for finite and exponent q=0\t\t      */\n+    /*\t DFISINT    -- test for finite and exponent q=0 \t      */\n     /*\t DFISUINT01 -- test for sign=0, finite, exponent q=0, and     */\n     /*\t\t       MSD=0 or 1\t\t\t\t      */\n-    /*\t ZEROWORD is also defined here.\t\t\t\t      */\n+    /*\t ZEROWORD is also defined here. \t\t\t      */\n     /* In DFISZERO the first test checks the least-significant word   */\n     /* (most likely to be non-zero); the penultimate tests MSD and    */\n     /* DPDs in the signword, and the final test excludes specials and */\n@@ -407,26 +422,36 @@\n       || ((dpd)&(((uInt)0x6e)<<(k)))!=(((uInt)0x6e)<<(k)))\n     /* declet is at offset k (a multiple of 2) in a pair of uInts:    */\n     /* [the top 2 bits will always be in the more-significant uInt]   */\n-    #define CANONDPDTWO(hi, lo, k) (((hi)&(0x300>>(32-(k))))==0\t    \\\n+    #define CANONDPDTWO(hi, lo, k) (((hi)&(0x300>>(32-(k))))==0     \\\n       || ((hi)&(0x6e>>(32-(k))))!=(0x6e>>(32-(k)))\t\t    \\\n       || ((lo)&(((uInt)0x6e)<<(k)))!=(((uInt)0x6e)<<(k)))\n \n     /* Macro to test whether a full-length (length DECPMAX) BCD8      */\n-    /* coefficient is zero\t\t\t\t\t      */\n-    /* test just the LSWord first, then the remainder\t\t      */\n+    /* coefficient, starting at uByte u, is all zeros\t\t      */\n+    /* Test just the LSWord first, then the remainder as a sequence   */\n+    /* of tests in order to avoid same-level use of UBTOUI\t      */\n     #if DECPMAX==7\n-      #define ISCOEFFZERO(u) (UINTAT((u)+DECPMAX-4)==0\t\t    \\\n-\t&& UINTAT((u)+DECPMAX-7)==0)\n+      #define ISCOEFFZERO(u) (\t\t\t\t\t    \\\n+\t   UBTOUI((u)+DECPMAX-4)==0\t\t\t\t    \\\n+\t&& UBTOUS((u)+DECPMAX-6)==0\t\t\t\t    \\\n+\t&& *(u)==0)\n     #elif DECPMAX==16\n-      #define ISCOEFFZERO(u) (UINTAT((u)+DECPMAX-4)==0\t\t    \\\n-\t&& (UINTAT((u)+DECPMAX-8)+UINTAT((u)+DECPMAX-12)\t    \\\n-\t   +UINTAT((u)+DECPMAX-16))==0)\n+      #define ISCOEFFZERO(u) (\t\t\t\t\t    \\\n+\t   UBTOUI((u)+DECPMAX-4)==0\t\t\t\t    \\\n+\t&& UBTOUI((u)+DECPMAX-8)==0\t\t\t\t    \\\n+\t&& UBTOUI((u)+DECPMAX-12)==0\t\t\t\t    \\\n+\t&& UBTOUI(u)==0)\n     #elif DECPMAX==34\n-      #define ISCOEFFZERO(u) (UINTAT((u)+DECPMAX-4)==0\t\t    \\\n-\t&& (UINTAT((u)+DECPMAX-8) +UINTAT((u)+DECPMAX-12)\t    \\\n-\t   +UINTAT((u)+DECPMAX-16)+UINTAT((u)+DECPMAX-20)\t    \\\n-\t   +UINTAT((u)+DECPMAX-24)+UINTAT((u)+DECPMAX-28)\t    \\\n-\t   +UINTAT((u)+DECPMAX-32)+USHORTAT((u)+DECPMAX-34))==0)\n+      #define ISCOEFFZERO(u) (\t\t\t\t\t    \\\n+\t   UBTOUI((u)+DECPMAX-4)==0\t\t\t\t    \\\n+\t&& UBTOUI((u)+DECPMAX-8)==0\t\t\t\t    \\\n+\t&& UBTOUI((u)+DECPMAX-12)==0\t\t\t\t    \\\n+\t&& UBTOUI((u)+DECPMAX-16)==0\t\t\t\t    \\\n+\t&& UBTOUI((u)+DECPMAX-20)==0\t\t\t\t    \\\n+\t&& UBTOUI((u)+DECPMAX-24)==0\t\t\t\t    \\\n+\t&& UBTOUI((u)+DECPMAX-28)==0\t\t\t\t    \\\n+\t&& UBTOUI((u)+DECPMAX-32)==0\t\t\t\t    \\\n+\t&& UBTOUS(u)==0)\n     #endif\n \n     /* Macros and masks for the exponent continuation field and MSD   */\n@@ -448,37 +473,32 @@\n     #define ECONNANMASK ((0x01ffffff>>(32-6-DECECONL))<<(32-6-DECECONL))\n \n     /* Macros to decode the coefficient in a finite decFloat *df into */\n-    /* a BCD string (uByte *bcdin) of length DECPMAX uBytes\t      */\n-\n-    /* In-line sequence to convert 10 bits at right end of uInt dpd   */\n-    /* to three BCD8 digits starting at uByte u.  Note that an extra  */\n-    /* byte is written to the right of the three digits because this  */\n-    /* moves four at a time for speed; the alternative macro moves    */\n-    /* exactly three bytes\t\t\t\t\t      */\n-    #define dpd2bcd8(u, dpd) {\t\t\t\t \\\n-      UINTAT(u)=UINTAT(&DPD2BCD8[((dpd)&0x3ff)*4]);}\n+    /* a BCD string (uByte *bcdin) of length DECPMAX uBytes.\t      */\n \n-    #define dpd2bcd83(u, dpd) {\t\t\t\t \\\n-      *(u)=DPD2BCD8[((dpd)&0x3ff)*4];\t\t\t \\\n-      *(u+1)=DPD2BCD8[((dpd)&0x3ff)*4+1];\t\t \\\n-      *(u+2)=DPD2BCD8[((dpd)&0x3ff)*4+2];}\n+    /* In-line sequence to convert least significant 10 bits of uInt  */\n+    /* dpd to three BCD8 digits starting at uByte u.  Note that an    */\n+    /* extra byte is written to the right of the three digits because */\n+    /* four bytes are moved at a time for speed; the alternative      */\n+    /* macro moves exactly three bytes (usually slower).\t      */\n+    #define dpd2bcd8(u, dpd)  memcpy(u, &DPD2BCD8[((dpd)&0x3ff)*4], 4)\n+    #define dpd2bcd83(u, dpd) memcpy(u, &DPD2BCD8[((dpd)&0x3ff)*4], 3)\n \n     /* Decode the declets.  After extracting each one, it is decoded  */\n     /* to BCD8 using a table lookup (also used for variable-length    */\n-    /* decode).\t Each DPD decode is 3 bytes BCD8 plus a one-byte      */\n-    /* length which is not used, here).\t Fixed-length 4-byte moves    */\n+    /* decode).  Each DPD decode is 3 bytes BCD8 plus a one-byte      */\n+    /* length which is not used, here).  Fixed-length 4-byte moves    */\n     /* are fast, however, almost everywhere, and so are used except   */\n     /* for the final three bytes (to avoid overrun).  The code below  */\n     /* is 36 instructions for Doubles and about 70 for Quads, even    */\n-    /* on IA32.\t\t\t\t\t\t\t      */\n+    /* on IA32. \t\t\t\t\t\t      */\n \n     /* Two macros are defined for each format:\t\t\t      */\n     /*\t GETCOEFF extracts the coefficient of the current format      */\n     /*\t GETWCOEFF extracts the coefficient of the next-wider format. */\n     /* The latter is a copy of the next-wider GETCOEFF using DFWWORD. */\n \n     #if DECPMAX==7\n-    #define GETCOEFF(df, bcd) {\t\t\t\t \\\n+    #define GETCOEFF(df, bcd) { \t\t\t \\\n       uInt sourhi=DFWORD(df, 0);\t\t\t \\\n       *(bcd)=(uByte)DECCOMBMSD[sourhi>>26];\t\t \\\n       dpd2bcd8(bcd+1, sourhi>>10);\t\t\t \\\n@@ -494,7 +514,7 @@\n       dpd2bcd83(bcd+13, sourlo);}\n \n     #elif DECPMAX==16\n-    #define GETCOEFF(df, bcd) {\t\t\t\t \\\n+    #define GETCOEFF(df, bcd) { \t\t\t \\\n       uInt sourhi=DFWORD(df, 0);\t\t\t \\\n       uInt sourlo=DFWORD(df, 1);\t\t\t \\\n       *(bcd)=(uByte)DECCOMBMSD[sourhi>>26];\t\t \\\n@@ -522,7 +542,7 @@\n       dpd2bcd83(bcd+31, sourlo);}\n \n     #elif DECPMAX==34\n-    #define GETCOEFF(df, bcd) {\t\t\t\t \\\n+    #define GETCOEFF(df, bcd) { \t\t\t \\\n       uInt sourhi=DFWORD(df, 0);\t\t\t \\\n       uInt sourmh=DFWORD(df, 1);\t\t\t \\\n       uInt sourml=DFWORD(df, 2);\t\t\t \\\n@@ -540,12 +560,12 @@\n       dpd2bcd8(bcd+28, sourlo>>10);\t\t\t \\\n       dpd2bcd83(bcd+31, sourlo);}\n \n-      #define GETWCOEFF(df, bcd) {??} /* [should never be used]\t      */\n+      #define GETWCOEFF(df, bcd) {??} /* [should never be used]       */\n     #endif\n \n     /* Macros to decode the coefficient in a finite decFloat *df into */\n     /* a base-billion uInt array, with the least-significant\t      */\n-    /* 0-999999999 'digit' at offset 0.\t\t\t\t      */\n+    /* 0-999999999 'digit' at offset 0. \t\t\t      */\n \n     /* Decode the declets.  After extracting each one, it is decoded  */\n     /* to binary using a table lookup.\tThree tables are used; one    */\n@@ -597,8 +617,8 @@\n     #endif\n \n     /* Macros to decode the coefficient in a finite decFloat *df into */\n-    /* a base-thousand uInt array, with the least-significant 0-999   */\n-    /* 'digit' at offset 0.\t\t\t\t\t      */\n+    /* a base-thousand uInt array (of size DECLETS+1, to allow for    */\n+    /* the MSD), with the least-significant 0-999 'digit' at offset 0.*/\n \n     /* Decode the declets.  After extracting each one, it is decoded  */\n     /* to binary using a table lookup.\t\t\t\t      */\n@@ -640,9 +660,72 @@\n       (buf)[9]=DPD2BIN[((sourhi<<6) | (sourmh>>26))&0x3ff];   \\\n       (buf)[10]=DPD2BIN[(sourhi>>4)&0x3ff];\t\t      \\\n       (buf)[11]=DECCOMBMSD[sourhi>>26];}\n+    #endif\n+\n+\n+    /* Macros to decode the coefficient in a finite decFloat *df and  */\n+    /* add to a base-thousand uInt array (as for GETCOEFFTHOU).       */\n+    /* After the addition then most significant 'digit' in the array  */\n+    /* might have a value larger then 10 (with a maximum of 19).      */\n+    #if DECPMAX==7\n+    #define ADDCOEFFTHOU(df, buf) {\t\t\t      \\\n+      uInt sourhi=DFWORD(df, 0);\t\t\t      \\\n+      (buf)[0]+=DPD2BIN[sourhi&0x3ff];\t\t\t      \\\n+      if (buf[0]>999) {buf[0]-=1000; buf[1]++;} \t      \\\n+      (buf)[1]+=DPD2BIN[(sourhi>>10)&0x3ff];\t\t      \\\n+      if (buf[1]>999) {buf[1]-=1000; buf[2]++;} \t      \\\n+      (buf)[2]+=DECCOMBMSD[sourhi>>26];}\n \n+    #elif DECPMAX==16\n+    #define ADDCOEFFTHOU(df, buf) {\t\t\t      \\\n+      uInt sourhi, sourlo;\t\t\t\t      \\\n+      sourlo=DFWORD(df, 1);\t\t\t\t      \\\n+      (buf)[0]+=DPD2BIN[sourlo&0x3ff];\t\t\t      \\\n+      if (buf[0]>999) {buf[0]-=1000; buf[1]++;} \t      \\\n+      (buf)[1]+=DPD2BIN[(sourlo>>10)&0x3ff];\t\t      \\\n+      if (buf[1]>999) {buf[1]-=1000; buf[2]++;} \t      \\\n+      (buf)[2]+=DPD2BIN[(sourlo>>20)&0x3ff];\t\t      \\\n+      if (buf[2]>999) {buf[2]-=1000; buf[3]++;} \t      \\\n+      sourhi=DFWORD(df, 0);\t\t\t\t      \\\n+      (buf)[3]+=DPD2BIN[((sourhi<<2) | (sourlo>>30))&0x3ff];  \\\n+      if (buf[3]>999) {buf[3]-=1000; buf[4]++;} \t      \\\n+      (buf)[4]+=DPD2BIN[(sourhi>>8)&0x3ff];\t\t      \\\n+      if (buf[4]>999) {buf[4]-=1000; buf[5]++;} \t      \\\n+      (buf)[5]+=DECCOMBMSD[sourhi>>26];}\n+\n+    #elif DECPMAX==34\n+    #define ADDCOEFFTHOU(df, buf) {\t\t\t      \\\n+      uInt sourhi, sourmh, sourml, sourlo;\t\t      \\\n+      sourlo=DFWORD(df, 3);\t\t\t\t      \\\n+      (buf)[0]+=DPD2BIN[sourlo&0x3ff];\t\t\t      \\\n+      if (buf[0]>999) {buf[0]-=1000; buf[1]++;} \t      \\\n+      (buf)[1]+=DPD2BIN[(sourlo>>10)&0x3ff];\t\t      \\\n+      if (buf[1]>999) {buf[1]-=1000; buf[2]++;} \t      \\\n+      (buf)[2]+=DPD2BIN[(sourlo>>20)&0x3ff];\t\t      \\\n+      if (buf[2]>999) {buf[2]-=1000; buf[3]++;} \t      \\\n+      sourml=DFWORD(df, 2);\t\t\t\t      \\\n+      (buf)[3]+=DPD2BIN[((sourml<<2) | (sourlo>>30))&0x3ff];  \\\n+      if (buf[3]>999) {buf[3]-=1000; buf[4]++;} \t      \\\n+      (buf)[4]+=DPD2BIN[(sourml>>8)&0x3ff];\t\t      \\\n+      if (buf[4]>999) {buf[4]-=1000; buf[5]++;} \t      \\\n+      (buf)[5]+=DPD2BIN[(sourml>>18)&0x3ff];\t\t      \\\n+      if (buf[5]>999) {buf[5]-=1000; buf[6]++;} \t      \\\n+      sourmh=DFWORD(df, 1);\t\t\t\t      \\\n+      (buf)[6]+=DPD2BIN[((sourmh<<4) | (sourml>>28))&0x3ff];  \\\n+      if (buf[6]>999) {buf[6]-=1000; buf[7]++;} \t      \\\n+      (buf)[7]+=DPD2BIN[(sourmh>>6)&0x3ff];\t\t      \\\n+      if (buf[7]>999) {buf[7]-=1000; buf[8]++;} \t      \\\n+      (buf)[8]+=DPD2BIN[(sourmh>>16)&0x3ff];\t\t      \\\n+      if (buf[8]>999) {buf[8]-=1000; buf[9]++;} \t      \\\n+      sourhi=DFWORD(df, 0);\t\t\t\t      \\\n+      (buf)[9]+=DPD2BIN[((sourhi<<6) | (sourmh>>26))&0x3ff];  \\\n+      if (buf[9]>999) {buf[9]-=1000; buf[10]++;}\t      \\\n+      (buf)[10]+=DPD2BIN[(sourhi>>4)&0x3ff];\t\t      \\\n+      if (buf[10]>999) {buf[10]-=1000; buf[11]++;}\t      \\\n+      (buf)[11]+=DECCOMBMSD[sourhi>>26];}\n     #endif\n \n+\n     /* Set a decFloat to the maximum positive finite number (Nmax)    */\n     #if DECPMAX==7\n     #define DFSETNMAX(df)\t     \\"}, {"sha": "2297d7d6e7d002625d20cbe2673a4942dd6cf3af", "filename": "libdecnumber/decPacked.c", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f988ec96d922819a4948c1ed96c6dc1b79a7ad22/libdecnumber%2FdecPacked.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f988ec96d922819a4948c1ed96c6dc1b79a7ad22/libdecnumber%2FdecPacked.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libdecnumber%2FdecPacked.c?ref=f988ec96d922819a4948c1ed96c6dc1b79a7ad22", "patch": "@@ -31,12 +31,12 @@\n /* ------------------------------------------------------------------ */\n /* Packed Decimal conversion module\t\t\t\t      */\n /* ------------------------------------------------------------------ */\n-/* This module comprises the routines for Packed Decimal format\t      */\n+/* This module comprises the routines for Packed Decimal format       */\n /* numbers.  Conversions are supplied to and from decNumber, which in */\n /* turn supports:\t\t\t\t\t\t      */\n /*   conversions to and from string\t\t\t\t      */\n /*   arithmetic routines\t\t\t\t\t      */\n-/*   utilities.\t\t\t\t\t\t\t      */\n+/*   utilities. \t\t\t\t\t\t      */\n /* Conversions from decNumber to and from densely packed decimal      */\n /* formats are provided by the decimal32 through decimal128 modules.  */\n /* ------------------------------------------------------------------ */\n@@ -51,8 +51,8 @@\n /*\t\t\t\t\t\t\t\t      */\n /*   bcd    is the BCD bytes\t\t\t\t\t      */\n /*   length is the length of the BCD array\t\t\t      */\n-/*   scale  is the scale result\t\t\t\t\t      */\n-/*   dn\t    is the decNumber\t\t\t\t\t      */\n+/*   scale  is the scale result \t\t\t\t      */\n+/*   dn     is the decNumber\t\t\t\t\t      */\n /*   returns bcd, or NULL if error\t\t\t\t      */\n /*\t\t\t\t\t\t\t\t      */\n /* The number is converted to a BCD packed decimal byte array,\t      */\n@@ -67,7 +67,7 @@\n /* as necessary.\t\t\t\t\t\t      */\n /*\t\t\t\t\t\t\t\t      */\n /* If there is an error (that is, the decNumber has too many digits   */\n-/* to fit in length bytes, or it is a NaN or Infinity), NULL is\t      */\n+/* to fit in length bytes, or it is a NaN or Infinity), NULL is       */\n /* returned and the bcd and scale results are unchanged.  Otherwise   */\n /* bcd is returned.\t\t\t\t\t\t      */\n /* ------------------------------------------------------------------ */\n@@ -86,9 +86,9 @@ uByte * decPackedFromNumber(uByte *bcd, Int length, Int *scale,\n   if (dn->digits>length*2-1\t\t     /* too long .. */\n    ||(dn->bits & DECSPECIAL)) return NULL;   /* .. or special -- hopeless */\n \n-  if (dn->bits&DECNEG) obyte=DECPMINUS;\t     /* set the sign .. */\n-   else\t\t       obyte=DECPPLUS;\n-  *scale=-dn->exponent;\t\t\t     /* .. and scale */\n+  if (dn->bits&DECNEG) obyte=DECPMINUS;      /* set the sign .. */\n+   else \t       obyte=DECPPLUS;\n+  *scale=-dn->exponent; \t\t     /* .. and scale */\n \n   /* loop from lowest (rightmost) byte */\n   out=bcd+length-1;\t\t\t     /* -> final byte */\n@@ -141,7 +141,7 @@ uByte * decPackedFromNumber(uByte *bcd, Int length, Int *scale,\n /*   bcd    is the BCD bytes\t\t\t\t\t      */\n /*   length is the length of the BCD array\t\t\t      */\n /*   scale  is the scale associated with the BCD integer\t      */\n-/*   dn\t    is the decNumber [with space for length*2 digits]\t      */\n+/*   dn     is the decNumber [with space for length*2 digits]\t      */\n /*   returns dn, or NULL if error\t\t\t\t      */\n /*\t\t\t\t\t\t\t\t      */\n /* The BCD packed decimal byte array, together with an associated     */\n@@ -157,15 +157,15 @@ uByte * decPackedFromNumber(uByte *bcd, Int length, Int *scale,\n /* no error is possible unless the adjusted exponent is out of range, */\n /* no sign nibble was found, or a sign nibble was found before the    */\n /* final nibble.  In these error cases, NULL is returned and the      */\n-/* decNumber will be 0.\t\t\t\t\t\t      */\n+/* decNumber will be 0. \t\t\t\t\t      */\n /* ------------------------------------------------------------------ */\n decNumber * decPackedToNumber(const uByte *bcd, Int length,\n \t\t\t      const Int *scale, decNumber *dn) {\n   const uByte *last=bcd+length-1;  /* -> last byte */\n   const uByte *first;\t\t   /* -> first non-zero byte */\n   uInt\tnib;\t\t\t   /* work nibble */\n   Unit\t*up=dn->lsu;\t\t   /* output pointer */\n-  Int\tdigits;\t\t\t   /* digits count */\n+  Int\tdigits; \t\t   /* digits count */\n   Int\tcut=0;\t\t\t   /* phase of output */\n \n   decNumberZero(dn);\t\t   /* default result */\n@@ -182,7 +182,7 @@ decNumber * decPackedToNumber(const uByte *bcd, Int length,\n \t\t\t\t\t/* leave as 1] */\n \n   /* check the adjusted exponent; note that scale could be unbounded */\n-  dn->exponent=-*scale;\t\t\t/* set the exponent */\n+  dn->exponent=-*scale; \t\t/* set the exponent */\n   if (*scale>=0) {\t\t\t/* usual case */\n     if ((dn->digits-*scale-1)<-DECNUMMAXE) {\t  /* underflow */\n       decNumberZero(dn);"}, {"sha": "04fcf53dfc5eb27e7b10fafe74a3e9a288ab380e", "filename": "libdecnumber/decPacked.h", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f988ec96d922819a4948c1ed96c6dc1b79a7ad22/libdecnumber%2FdecPacked.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f988ec96d922819a4948c1ed96c6dc1b79a7ad22/libdecnumber%2FdecPacked.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libdecnumber%2FdecPacked.h?ref=f988ec96d922819a4948c1ed96c6dc1b79a7ad22", "patch": "@@ -36,7 +36,7 @@\n   #define DECPACKED\n   #define DECPNAME     \"decPacked\"\t\t\t/* Short name */\n   #define DECPFULLNAME \"Packed Decimal conversions\"   /* Verbose name */\n-  #define DECPAUTHOR   \"Mike Cowlishaw\"\t\t      /* Who to blame */\n+  #define DECPAUTHOR   \"Mike Cowlishaw\" \t      /* Who to blame */\n \n   #define DECPACKED_DefP 32\t\t/* default precision\t      */\n \n@@ -47,12 +47,12 @@\n \n   /* Sign nibble constants\t\t\t\t\t      */\n   #if !defined(DECPPLUSALT)\n-    #define DECPPLUSALT\t 0x0A /* alternate plus\t nibble\t\t      */\n-    #define DECPMINUSALT 0x0B /* alternate minus nibble\t\t      */\n-    #define DECPPLUS\t 0x0C /* preferred plus\t nibble\t\t      */\n-    #define DECPMINUS\t 0x0D /* preferred minus nibble\t\t      */\n-    #define DECPPLUSALT2 0x0E /* alternate plus\t nibble\t\t      */\n-    #define DECPUNSIGNED 0x0F /* alternate plus\t nibble (unsigned)    */\n+    #define DECPPLUSALT  0x0A /* alternate plus  nibble \t      */\n+    #define DECPMINUSALT 0x0B /* alternate minus nibble \t      */\n+    #define DECPPLUS\t 0x0C /* preferred plus  nibble \t      */\n+    #define DECPMINUS\t 0x0D /* preferred minus nibble \t      */\n+    #define DECPPLUSALT2 0x0E /* alternate plus  nibble \t      */\n+    #define DECPUNSIGNED 0x0F /* alternate plus  nibble (unsigned)    */\n   #endif\n \n   /* ---------------------------------------------------------------- */"}, {"sha": "a8eb9050ddcccae2065d9d9f57d99e17804784ae", "filename": "libdecnumber/decQuad.c", "status": "modified", "additions": 85, "deletions": 85, "changes": 170, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f988ec96d922819a4948c1ed96c6dc1b79a7ad22/libdecnumber%2FdecQuad.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f988ec96d922819a4948c1ed96c6dc1b79a7ad22/libdecnumber%2FdecQuad.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libdecnumber%2FdecQuad.c?ref=f988ec96d922819a4948c1ed96c6dc1b79a7ad22", "patch": "@@ -34,111 +34,111 @@\n /* This module comprises decQuad operations (including conversions)   */\n /* ------------------------------------------------------------------ */\n \n-#include \"decContext.h\"\t      /* public includes */\n+#include \"decContext.h\"       /* public includes */\n #include \"decQuad.h\"\t      /* .. */\n \n /* Constant mappings for shared code */\n-#define DECPMAX\t    DECQUAD_Pmax\n-#define DECEMIN\t    DECQUAD_Emin\n-#define DECEMAX\t    DECQUAD_Emax\n+#define DECPMAX     DECQUAD_Pmax\n+#define DECEMIN     DECQUAD_Emin\n+#define DECEMAX     DECQUAD_Emax\n #define DECEMAXD    DECQUAD_EmaxD\n #define DECBYTES    DECQUAD_Bytes\n #define DECSTRING   DECQUAD_String\n #define DECECONL    DECQUAD_EconL\n-#define DECBIAS\t    DECQUAD_Bias\n-#define DECLETS\t    DECQUAD_Declets\n+#define DECBIAS     DECQUAD_Bias\n+#define DECLETS     DECQUAD_Declets\n #define DECQTINY   (-DECQUAD_Bias)\n \n /* Type and function mappings for shared code */\n-#define decFloat\t\tdecQuad\t\t  /* Type name */\n+#define decFloat\t\t   decQuad\t  /* Type name */\n \n /* Utilities and conversions (binary results, extractors, etc.) */\n-#define decFloatFromBCD\t\tdecQuadFromBCD\n-#define decFloatFromInt32\tdecQuadFromInt32\n-#define decFloatFromPacked\tdecQuadFromPacked\n-#define decFloatFromString\tdecQuadFromString\n-#define decFloatFromUInt32\tdecQuadFromUInt32\n-#define decFloatFromWider\tdecQuadFromWider\n-#define decFloatGetCoefficient\tdecQuadGetCoefficient\n-#define decFloatGetExponent\tdecQuadGetExponent\n-#define decFloatSetCoefficient\tdecQuadSetCoefficient\n-#define decFloatSetExponent\tdecQuadSetExponent\n-#define decFloatShow\t\tdecQuadShow\n-#define decFloatToBCD\t\tdecQuadToBCD\n-#define decFloatToEngString\tdecQuadToEngString\n-#define decFloatToInt32\t\tdecQuadToInt32\n-#define decFloatToInt32Exact\tdecQuadToInt32Exact\n-#define decFloatToPacked\tdecQuadToPacked\n-#define decFloatToString\tdecQuadToString\n-#define decFloatToUInt32\tdecQuadToUInt32\n-#define decFloatToUInt32Exact\tdecQuadToUInt32Exact\n-#define decFloatToWider\t\tdecQuadToWider\n-#define decFloatZero\t\tdecQuadZero\n+#define decFloatFromBCD \t   decQuadFromBCD\n+#define decFloatFromInt32\t   decQuadFromInt32\n+#define decFloatFromPacked\t   decQuadFromPacked\n+#define decFloatFromPackedChecked  decQuadFromPackedChecked\n+#define decFloatFromString\t   decQuadFromString\n+#define decFloatFromUInt32\t   decQuadFromUInt32\n+#define decFloatFromWider\t   decQuadFromWider\n+#define decFloatGetCoefficient\t   decQuadGetCoefficient\n+#define decFloatGetExponent\t   decQuadGetExponent\n+#define decFloatSetCoefficient\t   decQuadSetCoefficient\n+#define decFloatSetExponent\t   decQuadSetExponent\n+#define decFloatShow\t\t   decQuadShow\n+#define decFloatToBCD\t\t   decQuadToBCD\n+#define decFloatToEngString\t   decQuadToEngString\n+#define decFloatToInt32 \t   decQuadToInt32\n+#define decFloatToInt32Exact\t   decQuadToInt32Exact\n+#define decFloatToPacked\t   decQuadToPacked\n+#define decFloatToString\t   decQuadToString\n+#define decFloatToUInt32\t   decQuadToUInt32\n+#define decFloatToUInt32Exact\t   decQuadToUInt32Exact\n+#define decFloatToWider \t   decQuadToWider\n+#define decFloatZero\t\t   decQuadZero\n \n /* Computational (result is a decFloat) */\n-#define decFloatAbs\t\tdecQuadAbs\n-#define decFloatAdd\t\tdecQuadAdd\n-#define decFloatAnd\t\tdecQuadAnd\n-#define decFloatDivide\t\tdecQuadDivide\n-#define decFloatDivideInteger\tdecQuadDivideInteger\n-#define decFloatFMA\t\tdecQuadFMA\n-#define decFloatInvert\t\tdecQuadInvert\n-#define decFloatLogB\t\tdecQuadLogB\n-#define decFloatMax\t\tdecQuadMax\n-#define decFloatMaxMag\t\tdecQuadMaxMag\n-#define decFloatMin\t\tdecQuadMin\n-#define decFloatMinMag\t\tdecQuadMinMag\n-#define decFloatMinus\t\tdecQuadMinus\n-#define decFloatMultiply\tdecQuadMultiply\n-#define decFloatNextMinus\tdecQuadNextMinus\n-#define decFloatNextPlus\tdecQuadNextPlus\n-#define decFloatNextToward\tdecQuadNextToward\n-#define decFloatOr\t\tdecQuadOr\n-#define decFloatPlus\t\tdecQuadPlus\n-#define decFloatQuantize\tdecQuadQuantize\n-#define decFloatReduce\t\tdecQuadReduce\n-#define decFloatRemainder\tdecQuadRemainder\n-#define decFloatRemainderNear\tdecQuadRemainderNear\n-#define decFloatRotate\t\tdecQuadRotate\n-#define decFloatScaleB\t\tdecQuadScaleB\n-#define decFloatShift\t\tdecQuadShift\n-#define decFloatSubtract\tdecQuadSubtract\n-#define decFloatToIntegralValue decQuadToIntegralValue\n-#define decFloatToIntegralExact decQuadToIntegralExact\n-#define decFloatXor\t\tdecQuadXor\n+#define decFloatAbs\t\t   decQuadAbs\n+#define decFloatAdd\t\t   decQuadAdd\n+#define decFloatAnd\t\t   decQuadAnd\n+#define decFloatDivide\t\t   decQuadDivide\n+#define decFloatDivideInteger\t   decQuadDivideInteger\n+#define decFloatFMA\t\t   decQuadFMA\n+#define decFloatInvert\t\t   decQuadInvert\n+#define decFloatLogB\t\t   decQuadLogB\n+#define decFloatMax\t\t   decQuadMax\n+#define decFloatMaxMag\t\t   decQuadMaxMag\n+#define decFloatMin\t\t   decQuadMin\n+#define decFloatMinMag\t\t   decQuadMinMag\n+#define decFloatMinus\t\t   decQuadMinus\n+#define decFloatMultiply\t   decQuadMultiply\n+#define decFloatNextMinus\t   decQuadNextMinus\n+#define decFloatNextPlus\t   decQuadNextPlus\n+#define decFloatNextToward\t   decQuadNextToward\n+#define decFloatOr\t\t   decQuadOr\n+#define decFloatPlus\t\t   decQuadPlus\n+#define decFloatQuantize\t   decQuadQuantize\n+#define decFloatReduce\t\t   decQuadReduce\n+#define decFloatRemainder\t   decQuadRemainder\n+#define decFloatRemainderNear\t   decQuadRemainderNear\n+#define decFloatRotate\t\t   decQuadRotate\n+#define decFloatScaleB\t\t   decQuadScaleB\n+#define decFloatShift\t\t   decQuadShift\n+#define decFloatSubtract\t   decQuadSubtract\n+#define decFloatToIntegralValue    decQuadToIntegralValue\n+#define decFloatToIntegralExact    decQuadToIntegralExact\n+#define decFloatXor\t\t   decQuadXor\n \n /* Comparisons */\n-#define decFloatCompare\t\tdecQuadCompare\n-#define decFloatCompareSignal\tdecQuadCompareSignal\n-#define decFloatCompareTotal\tdecQuadCompareTotal\n-#define decFloatCompareTotalMag decQuadCompareTotalMag\n+#define decFloatCompare \t   decQuadCompare\n+#define decFloatCompareSignal\t   decQuadCompareSignal\n+#define decFloatCompareTotal\t   decQuadCompareTotal\n+#define decFloatCompareTotalMag    decQuadCompareTotalMag\n \n /* Copies */\n-#define decFloatCanonical\tdecQuadCanonical\n-#define decFloatCopy\t\tdecQuadCopy\n-#define decFloatCopyAbs\t\tdecQuadCopyAbs\n-#define decFloatCopyNegate\tdecQuadCopyNegate\n-#define decFloatCopySign\tdecQuadCopySign\n+#define decFloatCanonical\t   decQuadCanonical\n+#define decFloatCopy\t\t   decQuadCopy\n+#define decFloatCopyAbs \t   decQuadCopyAbs\n+#define decFloatCopyNegate\t   decQuadCopyNegate\n+#define decFloatCopySign\t   decQuadCopySign\n \n /* Non-computational */\n-#define decFloatClass\t\tdecQuadClass\n-#define decFloatClassString\tdecQuadClassString\n-#define decFloatDigits\t\tdecQuadDigits\n-#define decFloatIsCanonical\tdecQuadIsCanonical\n-#define decFloatIsFinite\tdecQuadIsFinite\n-#define decFloatIsInfinite\tdecQuadIsInfinite\n-#define decFloatIsInteger\tdecQuadIsInteger\n-#define decFloatIsNaN\t\tdecQuadIsNaN\n-#define decFloatIsNormal\tdecQuadIsNormal\n-#define decFloatIsSignaling\tdecQuadIsSignaling\n-#define decFloatIsSignalling\tdecQuadIsSignalling\n-#define decFloatIsSigned\tdecQuadIsSigned\n-#define decFloatIsSubnormal\tdecQuadIsSubnormal\n-#define decFloatIsZero\t\tdecQuadIsZero\n-#define decFloatRadix\t\tdecQuadRadix\n-#define decFloatSameQuantum\tdecQuadSameQuantum\n-#define decFloatVersion\t\tdecQuadVersion\n-\n+#define decFloatClass\t\t   decQuadClass\n+#define decFloatClassString\t   decQuadClassString\n+#define decFloatDigits\t\t   decQuadDigits\n+#define decFloatIsCanonical\t   decQuadIsCanonical\n+#define decFloatIsFinite\t   decQuadIsFinite\n+#define decFloatIsInfinite\t   decQuadIsInfinite\n+#define decFloatIsInteger\t   decQuadIsInteger\n+#define decFloatIsNaN\t\t   decQuadIsNaN\n+#define decFloatIsNormal\t   decQuadIsNormal\n+#define decFloatIsSignaling\t   decQuadIsSignaling\n+#define decFloatIsSignalling\t   decQuadIsSignalling\n+#define decFloatIsSigned\t   decQuadIsSigned\n+#define decFloatIsSubnormal\t   decQuadIsSubnormal\n+#define decFloatIsZero\t\t   decQuadIsZero\n+#define decFloatRadix\t\t   decQuadRadix\n+#define decFloatSameQuantum\t   decQuadSameQuantum\n+#define decFloatVersion \t   decQuadVersion\n \n #include \"decNumberLocal.h\"   /* local includes (need DECPMAX) */\n #include \"decCommon.c\"\t      /* non-arithmetic decFloat routines */"}, {"sha": "80f5eef4958a60c3a63f62d24ae647d71218a40f", "filename": "libdecnumber/decQuad.h", "status": "modified", "additions": 26, "deletions": 23, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f988ec96d922819a4948c1ed96c6dc1b79a7ad22/libdecnumber%2FdecQuad.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f988ec96d922819a4948c1ed96c6dc1b79a7ad22/libdecnumber%2FdecQuad.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libdecnumber%2FdecQuad.h?ref=f988ec96d922819a4948c1ed96c6dc1b79a7ad22", "patch": "@@ -31,39 +31,40 @@\n /* ------------------------------------------------------------------ */\n /* decQuad.h -- Decimal 128-bit format module header\t\t      */\n /* ------------------------------------------------------------------ */\n-/* Please see decFloats.h for an overview and documentation details.  */\n-/* ------------------------------------------------------------------ */\n /* This include file is always included by decSingle and decDouble,   */\n-/* and therefore also holds useful constants used by all three.\t      */\n+/* and therefore also holds useful constants used by all three.       */\n \n #if !defined(DECQUAD)\n   #define DECQUAD\n \n   #define DECQUADNAME\t      \"decimalQuad\"\t      /* Short name   */\n   #define DECQUADTITLE\t      \"Decimal 128-bit datum\" /* Verbose name */\n-  #define DECQUADAUTHOR\t      \"Mike Cowlishaw\"\t      /* Who to blame */\n+  #define DECQUADAUTHOR       \"Mike Cowlishaw\"\t      /* Who to blame */\n \n   /* parameters for decQuads */\n-  #define DECQUAD_Bytes\t   16\t   /* length\t\t\t      */\n+  #define DECQUAD_Bytes    16\t   /* length\t\t\t      */\n   #define DECQUAD_Pmax\t   34\t   /* maximum precision (digits)      */\n-  #define DECQUAD_Emin\t-6143\t   /* minimum adjusted exponent\t      */\n-  #define DECQUAD_Emax\t 6144\t   /* maximum adjusted exponent\t      */\n-  #define DECQUAD_EmaxD\t    4\t   /* maximum exponent digits\t      */\n+  #define DECQUAD_Emin\t-6143\t   /* minimum adjusted exponent       */\n+  #define DECQUAD_Emax\t 6144\t   /* maximum adjusted exponent       */\n+  #define DECQUAD_EmaxD     4\t   /* maximum exponent digits\t      */\n   #define DECQUAD_Bias\t 6176\t   /* bias for the exponent\t      */\n-  #define DECQUAD_String   43\t   /* maximum string length, +1\t      */\n-  #define DECQUAD_EconL\t   12\t   /* exponent continuation length    */\n+  #define DECQUAD_String   43\t   /* maximum string length, +1       */\n+  #define DECQUAD_EconL    12\t   /* exponent continuation length    */\n   #define DECQUAD_Declets  11\t   /* count of declets\t\t      */\n   /* highest biased exponent (Elimit-1) */\n   #define DECQUAD_Ehigh (DECQUAD_Emax + DECQUAD_Bias - (DECQUAD_Pmax-1))\n \n   /* Required include\t\t\t\t\t\t      */\n   #include \"decContext.h\"\n \n-  /* The decQuad decimal 128-bit type, accessible by various types */\n+  /* The decQuad decimal 128-bit type, accessible by all sizes */\n   typedef union {\n-    uint8_t bytes[DECQUAD_Bytes];  /* fields: 1, 5, 12, 110 bits */\n+    uint8_t   bytes[DECQUAD_Bytes];\t/* fields: 1, 5, 12, 110 bits */\n     uint16_t shorts[DECQUAD_Bytes/2];\n-    uint32_t words[DECQUAD_Bytes/4];\n+    uint32_t  words[DECQUAD_Bytes/4];\n+    #if DECUSE64\n+    uint64_t  longs[DECQUAD_Bytes/8];\n+    #endif\n     } decQuad;\n \n   /* ---------------------------------------------------------------- */\n@@ -72,21 +73,21 @@\n \n   /* sign and special values [top 32-bits; last two bits are don't-care\n      for Infinity on input, last bit don't-care for NaNs] */\n-  #define DECFLOAT_Sign\t 0x80000000\t/* 1 00000 00 Sign */\n+  #define DECFLOAT_Sign  0x80000000\t/* 1 00000 00 Sign */\n   #define DECFLOAT_NaN\t 0x7c000000\t/* 0 11111 00 NaN generic */\n-  #define DECFLOAT_qNaN\t 0x7c000000\t/* 0 11111 00 qNaN */\n-  #define DECFLOAT_sNaN\t 0x7e000000\t/* 0 11111 10 sNaN */\n+  #define DECFLOAT_qNaN  0x7c000000\t/* 0 11111 00 qNaN */\n+  #define DECFLOAT_sNaN  0x7e000000\t/* 0 11111 10 sNaN */\n   #define DECFLOAT_Inf\t 0x78000000\t/* 0 11110 00 Infinity */\n   #define DECFLOAT_MinSp 0x78000000\t/* minimum special value */\n \t\t\t\t\t/* [specials are all >=MinSp] */\n   /* Sign nibble constants\t\t\t\t\t      */\n   #if !defined(DECPPLUSALT)\n-    #define DECPPLUSALT\t 0x0A /* alternate plus\t nibble\t\t      */\n-    #define DECPMINUSALT 0x0B /* alternate minus nibble\t\t      */\n-    #define DECPPLUS\t 0x0C /* preferred plus\t nibble\t\t      */\n-    #define DECPMINUS\t 0x0D /* preferred minus nibble\t\t      */\n-    #define DECPPLUSALT2 0x0E /* alternate plus\t nibble\t\t      */\n-    #define DECPUNSIGNED 0x0F /* alternate plus\t nibble (unsigned)    */\n+    #define DECPPLUSALT  0x0A /* alternate plus  nibble \t      */\n+    #define DECPMINUSALT 0x0B /* alternate minus nibble \t      */\n+    #define DECPPLUS\t 0x0C /* preferred plus  nibble \t      */\n+    #define DECPMINUS\t 0x0D /* preferred minus nibble \t      */\n+    #define DECPPLUSALT2 0x0E /* alternate plus  nibble \t      */\n+    #define DECPUNSIGNED 0x0F /* alternate plus  nibble (unsigned)    */\n   #endif\n \n   /* ---------------------------------------------------------------- */\n@@ -99,6 +100,7 @@\n   extern decQuad * decQuadFromBCD(decQuad *, int32_t, const uint8_t *, int32_t);\n   extern decQuad * decQuadFromInt32(decQuad *, int32_t);\n   extern decQuad * decQuadFromPacked(decQuad *, int32_t, const uint8_t *);\n+  extern decQuad * decQuadFromPackedChecked(decQuad *, int32_t, const uint8_t *);\n   extern decQuad * decQuadFromString(decQuad *, const char *, decContext *);\n   extern decQuad * decQuadFromUInt32(decQuad *, uint32_t);\n   extern int32_t   decQuadGetCoefficient(const decQuad *, uint8_t *);\n@@ -182,7 +184,8 @@\n \n   /* decNumber conversions; these are implemented as macros so as not  */\n   /* to force a dependency on decimal128 and decNumber in decQuad.     */\n+  /* decQuadFromNumber returns a decimal128 * to avoid warnings.       */\n   #define decQuadToNumber(dq, dn) decimal128ToNumber((decimal128 *)(dq), dn)\n-  #define decQuadFromNumber(dq, dn, set) (decQuad *)decimal128FromNumber((decimal128 *)(dq), dn, set)\n+  #define decQuadFromNumber(dq, dn, set) decimal128FromNumber((decimal128 *)(dq), dn, set)\n \n #endif"}, {"sha": "1c56c65806e7ad8843b91ca864e780a10ff132db", "filename": "libdecnumber/decSingle.c", "status": "modified", "additions": 26, "deletions": 27, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f988ec96d922819a4948c1ed96c6dc1b79a7ad22/libdecnumber%2FdecSingle.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f988ec96d922819a4948c1ed96c6dc1b79a7ad22/libdecnumber%2FdecSingle.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libdecnumber%2FdecSingle.c?ref=f988ec96d922819a4948c1ed96c6dc1b79a7ad22", "patch": "@@ -31,22 +31,20 @@\n /* ------------------------------------------------------------------ */\n /* decSingle.c -- decSingle operations module\t\t\t      */\n /* ------------------------------------------------------------------ */\n-/* This module comprises decSingle operations (including conversions) */\n-/* ------------------------------------------------------------------ */\n \n-#include \"decContext.h\"\t      /* public includes */\n+#include \"decContext.h\"       /* public includes */\n #include \"decSingle.h\"\t      /* public includes */\n \n /* Constant mappings for shared code */\n-#define DECPMAX\t    DECSINGLE_Pmax\n-#define DECEMIN\t    DECSINGLE_Emin\n-#define DECEMAX\t    DECSINGLE_Emax\n+#define DECPMAX     DECSINGLE_Pmax\n+#define DECEMIN     DECSINGLE_Emin\n+#define DECEMAX     DECSINGLE_Emax\n #define DECEMAXD    DECSINGLE_EmaxD\n #define DECBYTES    DECSINGLE_Bytes\n #define DECSTRING   DECSINGLE_String\n #define DECECONL    DECSINGLE_EconL\n-#define DECBIAS\t    DECSINGLE_Bias\n-#define DECLETS\t    DECSINGLE_Declets\n+#define DECBIAS     DECSINGLE_Bias\n+#define DECLETS     DECSINGLE_Declets\n #define DECQTINY    (-DECSINGLE_Bias)\n /* parameters of next-wider format */\n #define DECWBYTES   DECDOUBLE_Bytes\n@@ -55,29 +53,30 @@\n #define DECWBIAS    DECDOUBLE_Bias\n \n /* Type and function mappings for shared code */\n-#define decFloat\t\tdecSingle\t  /* Type name */\n-#define decFloatWider\t\tdecDouble\t  /* Type name */\n+#define decFloat\t\t   decSingle\t  /* Type name */\n+#define decFloatWider\t\t   decDouble\t  /* Type name */\n \n /* Utility (binary results, extractors, etc.) */\n-#define decFloatFromBCD\t\tdecSingleFromBCD\n-#define decFloatFromPacked\tdecSingleFromPacked\n-#define decFloatFromString\tdecSingleFromString\n-#define decFloatFromWider\tdecSingleFromWider\n-#define decFloatGetCoefficient\tdecSingleGetCoefficient\n-#define decFloatGetExponent\tdecSingleGetExponent\n-#define decFloatSetCoefficient\tdecSingleSetCoefficient\n-#define decFloatSetExponent\tdecSingleSetExponent\n-#define decFloatShow\t\tdecSingleShow\n-#define decFloatToBCD\t\tdecSingleToBCD\n-#define decFloatToEngString\tdecSingleToEngString\n-#define decFloatToPacked\tdecSingleToPacked\n-#define decFloatToString\tdecSingleToString\n-#define decFloatToWider\t\tdecSingleToWider\n-#define decFloatZero\t\tdecSingleZero\n+#define decFloatFromBCD \t   decSingleFromBCD\n+#define decFloatFromPacked\t   decSingleFromPacked\n+#define decFloatFromPackedChecked  decSingleFromPackedChecked\n+#define decFloatFromString\t   decSingleFromString\n+#define decFloatFromWider\t   decSingleFromWider\n+#define decFloatGetCoefficient\t   decSingleGetCoefficient\n+#define decFloatGetExponent\t   decSingleGetExponent\n+#define decFloatSetCoefficient\t   decSingleSetCoefficient\n+#define decFloatSetExponent\t   decSingleSetExponent\n+#define decFloatShow\t\t   decSingleShow\n+#define decFloatToBCD\t\t   decSingleToBCD\n+#define decFloatToEngString\t   decSingleToEngString\n+#define decFloatToPacked\t   decSingleToPacked\n+#define decFloatToString\t   decSingleToString\n+#define decFloatToWider \t   decSingleToWider\n+#define decFloatZero\t\t   decSingleZero\n \n /* Non-computational */\n-#define decFloatRadix\t\tdecSingleRadix\n-#define decFloatVersion\t\tdecSingleVersion\n+#define decFloatRadix\t\t   decSingleRadix\n+#define decFloatVersion \t   decSingleVersion\n \n #include \"decNumberLocal.h\"   /* local includes (need DECPMAX) */\n #include \"decCommon.c\"\t      /* non-basic decFloat routines */"}, {"sha": "29efe438e9bfdab35bd5cb3e4394d734a554255d", "filename": "libdecnumber/decSingle.h", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f988ec96d922819a4948c1ed96c6dc1b79a7ad22/libdecnumber%2FdecSingle.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f988ec96d922819a4948c1ed96c6dc1b79a7ad22/libdecnumber%2FdecSingle.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libdecnumber%2FdecSingle.h?ref=f988ec96d922819a4948c1ed96c6dc1b79a7ad22", "patch": "@@ -31,24 +31,22 @@\n /* ------------------------------------------------------------------ */\n /* decSingle.h -- Decimal 32-bit format module header\t\t      */\n /* ------------------------------------------------------------------ */\n-/* Please see decFloats.h for an overview and documentation details.  */\n-/* ------------------------------------------------------------------ */\n \n #if !defined(DECSINGLE)\n   #define DECSINGLE\n \n-  #define DECSINGLENAME\t      \"decSingle\"\t      /* Short name   */\n+  #define DECSINGLENAME       \"decSingle\"\t      /* Short name   */\n   #define DECSINGLETITLE      \"Decimal 32-bit datum\"  /* Verbose name */\n   #define DECSINGLEAUTHOR     \"Mike Cowlishaw\"\t      /* Who to blame */\n \n   /* parameters for decSingles */\n   #define DECSINGLE_Bytes    4\t   /* length\t\t\t      */\n   #define DECSINGLE_Pmax     7\t   /* maximum precision (digits)      */\n-  #define DECSINGLE_Emin   -95\t   /* minimum adjusted exponent\t      */\n-  #define DECSINGLE_Emax    96\t   /* maximum adjusted exponent\t      */\n+  #define DECSINGLE_Emin   -95\t   /* minimum adjusted exponent       */\n+  #define DECSINGLE_Emax    96\t   /* maximum adjusted exponent       */\n   #define DECSINGLE_EmaxD    3\t   /* maximum exponent digits\t      */\n   #define DECSINGLE_Bias   101\t   /* bias for the exponent\t      */\n-  #define DECSINGLE_String  16\t   /* maximum string length, +1\t      */\n+  #define DECSINGLE_String  16\t   /* maximum string length, +1       */\n   #define DECSINGLE_EconL    6\t   /* exponent continuation length    */\n   #define DECSINGLE_Declets  2\t   /* count of declets\t\t      */\n   /* highest biased exponent (Elimit-1) */\n@@ -59,11 +57,11 @@\n   #include \"decQuad.h\"\n   #include \"decDouble.h\"\n \n-  /* The decSingle decimal 32-bit type, accessible by various types */\n+  /* The decSingle decimal 32-bit type, accessible by all sizes */\n   typedef union {\n-    uint8_t bytes[DECSINGLE_Bytes];\t/* fields: 1, 5, 6, 20 bits */\n+    uint8_t   bytes[DECSINGLE_Bytes];\t/* fields: 1, 5, 6, 20 bits */\n     uint16_t shorts[DECSINGLE_Bytes/2];\n-    uint32_t words[DECSINGLE_Bytes/4];\n+    uint32_t  words[DECSINGLE_Bytes/4];\n     } decSingle;\n \n   /* ---------------------------------------------------------------- */\n@@ -75,6 +73,7 @@\n   /* Utilities (binary argument(s) or result, extractors, etc.) */\n   extern decSingle * decSingleFromBCD(decSingle *, int32_t, const uint8_t *, int32_t);\n   extern decSingle * decSingleFromPacked(decSingle *, int32_t, const uint8_t *);\n+  extern decSingle * decSingleFromPackedChecked(decSingle *, int32_t, const uint8_t *);\n   extern decSingle * decSingleFromString(decSingle *, const char *, decContext *);\n   extern decSingle * decSingleFromWider(decSingle *, const decDouble *, decContext *);\n   extern int32_t     decSingleGetCoefficient(const decSingle *, uint8_t *);\n@@ -97,7 +96,8 @@\n \n   /* decNumber conversions; these are implemented as macros so as not  */\n   /* to force a dependency on decimal32 and decNumber in decSingle.    */\n+  /* decSingleFromNumber returns a decimal32 * to avoid warnings.      */\n   #define decSingleToNumber(dq, dn) decimal32ToNumber((decimal32 *)(dq), dn)\n-  #define decSingleFromNumber(dq, dn, set) (decSingle *)decimal32FromNumber((decimal32 *)(dq), dn, set)\n+  #define decSingleFromNumber(dq, dn, set) decimal32FromNumber((decimal32 *)(dq), dn, set)\n \n #endif"}, {"sha": "edf22e1c8d5f14ebfcccda26f99a462c86af2346", "filename": "libdecnumber/dpd/decimal128.c", "status": "modified", "additions": 59, "deletions": 60, "changes": 119, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f988ec96d922819a4948c1ed96c6dc1b79a7ad22/libdecnumber%2Fdpd%2Fdecimal128.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f988ec96d922819a4948c1ed96c6dc1b79a7ad22/libdecnumber%2Fdpd%2Fdecimal128.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libdecnumber%2Fdpd%2Fdecimal128.c?ref=f988ec96d922819a4948c1ed96c6dc1b79a7ad22", "patch": "@@ -42,11 +42,11 @@\n #include <string.h>\t      /* [for memset/memcpy] */\n #include <stdio.h>\t      /* [for printf] */\n \n-#include \"dconfig.h\"\t      /* GCC definitions */\n-#define\t DECNUMDIGITS 34      /* make decNumbers with space for 34 */\n+#include \"dconfig.h\"          /* GCC definitions */\n+#define  DECNUMDIGITS 34      /* make decNumbers with space for 34 */\n #include \"decNumber.h\"\t      /* base number library */\n #include \"decNumberLocal.h\"   /* decNumber local types, etc. */\n-#include \"decimal128.h\"\t      /* our primary include */\n+#include \"decimal128.h\"       /* our primary include */\n \n /* Utility routines and tables [in decimal64.c] */\n extern const uInt   COMBEXP[32], COMBMSD[32];\n@@ -71,7 +71,7 @@ extern void decNumberShow(const decNumber *);\t  /* .. */\n /*\t\t\t\t\t\t\t\t      */\n /*   ds is the target decimal128\t\t\t\t      */\n /*   dn is the source number (assumed valid)\t\t\t      */\n-/*   set is the context, used only for reporting errors\t\t      */\n+/*   set is the context, used only for reporting errors \t      */\n /*\t\t\t\t\t\t\t\t      */\n /* The set argument is used only for status reporting and for the     */\n /* rounding mode (used if the coefficient is more than DECIMAL128_Pmax*/\n@@ -89,8 +89,8 @@ decimal128 * decimal128FromNumber(decimal128 *d128, const decNumber *dn,\n   Int ae;\t\t\t   /* adjusted exponent */\n   decNumber  dw;\t\t   /* work */\n   decContext dc;\t\t   /* .. */\n-  uInt *pu;\t\t\t   /* .. */\n   uInt comb, exp;\t\t   /* .. */\n+  uInt uiwork;\t\t\t   /* for macros */\n   uInt targar[4]={0,0,0,0};\t   /* target 128-bit */\n   #define targhi targar[3]\t   /* name the word with the sign */\n   #define targmh targar[2]\t   /* name the words */\n@@ -102,7 +102,7 @@ decimal128 * decimal128FromNumber(decimal128 *d128, const decNumber *dn,\n   /* constraints.  This could push the number to Infinity or zero, */\n   /* so this check and rounding must be done before generating the */\n   /* decimal128] */\n-  ae=dn->exponent+dn->digits-1;\t\t     /* [0 if special] */\n+  ae=dn->exponent+dn->digits-1; \t     /* [0 if special] */\n   if (dn->digits>DECIMAL128_Pmax\t     /* too many digits */\n    || ae>DECIMAL128_Emax\t\t     /* likely overflow */\n    || ae<DECIMAL128_Emin) {\t\t     /* likely underflow */\n@@ -118,7 +118,7 @@ decimal128 * decimal128FromNumber(decimal128 *d128, const decNumber *dn,\n   if (dn->bits&DECSPECIAL) {\t\t\t  /* a special value */\n     if (dn->bits&DECINF) targhi=DECIMAL_Inf<<24;\n      else {\t\t\t\t\t  /* sNaN or qNaN */\n-      if ((*dn->lsu!=0 || dn->digits>1)\t\t  /* non-zero coefficient */\n+      if ((*dn->lsu!=0 || dn->digits>1) \t  /* non-zero coefficient */\n        && (dn->digits<DECIMAL128_Pmax)) {\t  /* coefficient fits */\n \tdecDigitsToDPD(dn, targar, 0);\n \t}\n@@ -144,11 +144,11 @@ decimal128 * decimal128FromNumber(decimal128 *d128, const decNumber *dn,\n       comb=(exp>>9) & 0x18;\t\t/* msd=0, exp top 2 bits .. */\n       }\n      else {\t\t\t\t/* non-zero finite number */\n-      uInt msd;\t\t\t\t/* work */\n+      uInt msd; \t\t\t/* work */\n       Int pad=0;\t\t\t/* coefficient pad digits */\n \n       /* the dn is known to fit, but it may need to be padded */\n-      exp=(uInt)(dn->exponent+DECIMAL128_Bias);\t   /* bias exponent */\n+      exp=(uInt)(dn->exponent+DECIMAL128_Bias);    /* bias exponent */\n       if (exp>DECIMAL128_Ehigh) {\t\t   /* fold-down case */\n \tpad=exp-DECIMAL128_Ehigh;\n \texp=DECIMAL128_Ehigh;\t\t\t   /* [to maximum] */\n@@ -172,18 +172,19 @@ decimal128 * decimal128FromNumber(decimal128 *d128, const decNumber *dn,\n   if (dn->bits&DECNEG) targhi|=0x80000000; /* add sign bit */\n \n   /* now write to storage; this is endian */\n-  pu=(uInt *)d128->bytes;\t   /* overlay */\n   if (DECLITEND) {\n-    pu[0]=targlo;\t\t   /* directly store the low int */\n-    pu[1]=targml;\t\t   /* then the mid-low */\n-    pu[2]=targmh;\t\t   /* then the mid-high */\n-    pu[3]=targhi;\t\t   /* then the high int */\n+    /* lo -> hi */\n+    UBFROMUI(d128->bytes,    targlo);\n+    UBFROMUI(d128->bytes+4,  targml);\n+    UBFROMUI(d128->bytes+8,  targmh);\n+    UBFROMUI(d128->bytes+12, targhi);\n     }\n    else {\n-    pu[0]=targhi;\t\t   /* directly store the high int */\n-    pu[1]=targmh;\t\t   /* then the mid-high */\n-    pu[2]=targml;\t\t   /* then the mid-low */\n-    pu[3]=targlo;\t\t   /* then the low int */\n+    /* hi -> lo */\n+    UBFROMUI(d128->bytes,    targhi);\n+    UBFROMUI(d128->bytes+4,  targmh);\n+    UBFROMUI(d128->bytes+8,  targml);\n+    UBFROMUI(d128->bytes+12, targlo);\n     }\n \n   if (status!=0) decContextSetStatus(set, status); /* pass on status */\n@@ -201,27 +202,26 @@ decNumber * decimal128ToNumber(const decimal128 *d128, decNumber *dn) {\n   uInt msd;\t\t\t   /* coefficient MSD */\n   uInt exp;\t\t\t   /* exponent top two bits */\n   uInt comb;\t\t\t   /* combination field */\n-  const uInt *pu;\t\t   /* work */\n-  Int  need;\t\t\t   /* .. */\n+  Int  need;\t\t\t   /* work */\n+  uInt uiwork;\t\t\t   /* for macros */\n   uInt sourar[4];\t\t   /* source 128-bit */\n   #define sourhi sourar[3]\t   /* name the word with the sign */\n   #define sourmh sourar[2]\t   /* and the mid-high word */\n   #define sourml sourar[1]\t   /* and the mod-low word */\n   #define sourlo sourar[0]\t   /* and the lowest word */\n \n   /* load source from storage; this is endian */\n-  pu=(const uInt *)d128->bytes;\t   /* overlay */\n   if (DECLITEND) {\n-    sourlo=pu[0];\t\t   /* directly load the low int */\n-    sourml=pu[1];\t\t   /* then the mid-low */\n-    sourmh=pu[2];\t\t   /* then the mid-high */\n-    sourhi=pu[3];\t\t   /* then the high int */\n+    sourlo=UBTOUI(d128->bytes\t); /* directly load the low int */\n+    sourml=UBTOUI(d128->bytes+4 ); /* then the mid-low */\n+    sourmh=UBTOUI(d128->bytes+8 ); /* then the mid-high */\n+    sourhi=UBTOUI(d128->bytes+12); /* then the high int */\n     }\n    else {\n-    sourhi=pu[0];\t\t   /* directly load the high int */\n-    sourmh=pu[1];\t\t   /* then the mid-high */\n-    sourml=pu[2];\t\t   /* then the mid-low */\n-    sourlo=pu[3];\t\t   /* then the low int */\n+    sourhi=UBTOUI(d128->bytes\t); /* directly load the high int */\n+    sourmh=UBTOUI(d128->bytes+4 ); /* then the mid-high */\n+    sourml=UBTOUI(d128->bytes+8 ); /* then the mid-low */\n+    sourlo=UBTOUI(d128->bytes+12); /* then the low int */\n     }\n \n   comb=(sourhi>>26)&0x1f;\t   /* combination field */\n@@ -232,7 +232,7 @@ decNumber * decimal128ToNumber(const decimal128 *d128, decNumber *dn) {\n   msd=COMBMSD[comb];\t\t   /* decode the combination field */\n   exp=COMBEXP[comb];\t\t   /* .. */\n \n-  if (exp==3) {\t\t\t   /* is a special */\n+  if (exp==3) { \t\t   /* is a special */\n     if (msd==0) {\n       dn->bits|=DECINF;\n       return dn;\t\t   /* no coefficient needed */\n@@ -265,7 +265,7 @@ decNumber * decimal128ToNumber(const decimal128 *d128, decNumber *dn) {\n   } /* decimal128ToNumber */\n \n /* ------------------------------------------------------------------ */\n-/* to-scientific-string -- conversion to numeric string\t\t      */\n+/* to-scientific-string -- conversion to numeric string \t      */\n /* to-engineering-string -- conversion to numeric string\t      */\n /*\t\t\t\t\t\t\t\t      */\n /*   decimal128ToString(d128, string);\t\t\t\t      */\n@@ -279,7 +279,7 @@ decNumber * decimal128ToNumber(const decimal128 *d128, decNumber *dn) {\n /*  No error is possible, and no status can be set.\t\t      */\n /* ------------------------------------------------------------------ */\n char * decimal128ToEngString(const decimal128 *d128, char *string){\n-  decNumber dn;\t\t\t\t/* work */\n+  decNumber dn; \t\t\t/* work */\n   decimal128ToNumber(d128, &dn);\n   decNumberToEngString(&dn, string);\n   return string;\n@@ -289,13 +289,13 @@ char * decimal128ToString(const decimal128 *d128, char *string){\n   uInt msd;\t\t\t   /* coefficient MSD */\n   Int  exp;\t\t\t   /* exponent top two bits or full */\n   uInt comb;\t\t\t   /* combination field */\n-  char *cstart;\t\t\t   /* coefficient start */\n+  char *cstart; \t\t   /* coefficient start */\n   char *c;\t\t\t   /* output pointer in string */\n-  const uInt *pu;\t\t   /* work */\n+  const uByte *u;\t\t   /* work */\n   char *s, *t;\t\t\t   /* .. (source, target) */\n   Int  dpd;\t\t\t   /* .. */\n   Int  pre, e;\t\t\t   /* .. */\n-  const uByte *u;\t\t   /* .. */\n+  uInt uiwork;\t\t\t   /* for macros */\n \n   uInt sourar[4];\t\t   /* source 128-bit */\n   #define sourhi sourar[3]\t   /* name the word with the sign */\n@@ -304,18 +304,17 @@ char * decimal128ToString(const decimal128 *d128, char *string){\n   #define sourlo sourar[0]\t   /* and the lowest word */\n \n   /* load source from storage; this is endian */\n-  pu=(const uInt *)d128->bytes;\t   /* overlay */\n   if (DECLITEND) {\n-    sourlo=pu[0];\t\t   /* directly load the low int */\n-    sourml=pu[1];\t\t   /* then the mid-low */\n-    sourmh=pu[2];\t\t   /* then the mid-high */\n-    sourhi=pu[3];\t\t   /* then the high int */\n+    sourlo=UBTOUI(d128->bytes\t); /* directly load the low int */\n+    sourml=UBTOUI(d128->bytes+4 ); /* then the mid-low */\n+    sourmh=UBTOUI(d128->bytes+8 ); /* then the mid-high */\n+    sourhi=UBTOUI(d128->bytes+12); /* then the high int */\n     }\n    else {\n-    sourhi=pu[0];\t\t   /* directly load the high int */\n-    sourmh=pu[1];\t\t   /* then the mid-high */\n-    sourml=pu[2];\t\t   /* then the mid-low */\n-    sourlo=pu[3];\t\t   /* then the low int */\n+    sourhi=UBTOUI(d128->bytes\t); /* directly load the high int */\n+    sourmh=UBTOUI(d128->bytes+4 ); /* then the mid-high */\n+    sourml=UBTOUI(d128->bytes+8 ); /* then the mid-low */\n+    sourlo=UBTOUI(d128->bytes+12); /* then the low int */\n     }\n \n   c=string;\t\t\t   /* where result will go */\n@@ -327,7 +326,7 @@ char * decimal128ToString(const decimal128 *d128, char *string){\n \n   if (exp==3) {\n     if (msd==0) {\t\t   /* infinity */\n-      strcpy(c,\t  \"Inf\");\n+      strcpy(c,   \"Inf\");\n       strcpy(c+3, \"inity\");\n       return string;\t\t   /* easy */\n       }\n@@ -353,12 +352,12 @@ char * decimal128ToString(const decimal128 *d128, char *string){\n   /* length.  We use fixed-length memcpys because variable-length */\n   /* causes a subroutine call in GCC.  (These are length 4 for speed */\n   /* and are safe because the array has an extra terminator byte.) */\n-  #define dpd2char u=&BIN2CHAR[DPD2BIN[dpd]*4];\t\t\t  \\\n+  #define dpd2char u=&BIN2CHAR[DPD2BIN[dpd]*4]; \t\t  \\\n \t\t   if (c!=cstart) {memcpy(c, u+1, 4); c+=3;}\t  \\\n \t\t    else if (*u)  {memcpy(c, u+4-*u, 4); c+=*u;}\n   dpd=(sourhi>>4)&0x3ff;\t\t     /* declet 1 */\n   dpd2char;\n-  dpd=((sourhi&0xf)<<6) | (sourmh>>26);\t     /* declet 2 */\n+  dpd=((sourhi&0xf)<<6) | (sourmh>>26);      /* declet 2 */\n   dpd2char;\n   dpd=(sourmh>>16)&0x3ff;\t\t     /* declet 3 */\n   dpd2char;\n@@ -381,7 +380,7 @@ char * decimal128ToString(const decimal128 *d128, char *string){\n \n   if (c==cstart) *c++='0';\t   /* all zeros -- make 0 */\n \n-  if (exp==0) {\t\t\t   /* integer or NaN case -- easy */\n+  if (exp==0) { \t\t   /* integer or NaN case -- easy */\n     *c='\\0';\t\t\t   /* terminate */\n     return string;\n     }\n@@ -409,8 +408,8 @@ char * decimal128ToString(const decimal128 *d128, char *string){\n     /* finally add the E-part, if needed; it will never be 0, and has */\n     /* a maximum length of 4 digits */\n     if (e!=0) {\n-      *c++='E';\t\t\t   /* starts with E */\n-      *c++='+';\t\t\t   /* assume positive */\n+      *c++='E'; \t\t   /* starts with E */\n+      *c++='+'; \t\t   /* assume positive */\n       if (e<0) {\n \t*(c-1)='-';\t\t   /* oops, need '-' */\n \te=-e;\t\t\t   /* uInt, please */\n@@ -449,13 +448,13 @@ char * decimal128ToString(const decimal128 *d128, char *string){\n /* ------------------------------------------------------------------ */\n /* to-number -- conversion from numeric string\t\t\t      */\n /*\t\t\t\t\t\t\t\t      */\n-/*   decimal128FromString(result, string, set);\t\t\t      */\n+/*   decimal128FromString(result, string, set); \t\t      */\n /*\t\t\t\t\t\t\t\t      */\n /*  result  is the decimal128 format number which gets the result of  */\n /*\t    the conversion\t\t\t\t\t      */\n /*  *string is the character string which should contain a valid      */\n /*\t    number (which may be a special value)\t\t      */\n-/*  set\t    is the context\t\t\t\t\t      */\n+/*  set     is the context\t\t\t\t\t      */\n /*\t\t\t\t\t\t\t\t      */\n /* The context is supplied to this routine is used for error handling */\n /* (setting of status and traps) and for the rounding mode, only.     */\n@@ -464,7 +463,7 @@ char * decimal128ToString(const decimal128 *d128, char *string){\n decimal128 * decimal128FromString(decimal128 *result, const char *string,\n \t\t\t\t  decContext *set) {\n   decContext dc;\t\t\t     /* work */\n-  decNumber dn;\t\t\t\t     /* .. */\n+  decNumber dn; \t\t\t     /* .. */\n \n   decContextDefault(&dc, DEC_INIT_DECIMAL128); /* no traps, please */\n   dc.round=set->round;\t\t\t       /* use supplied rounding */\n@@ -483,8 +482,8 @@ decimal128 * decimal128FromString(decimal128 *result, const char *string,\n /*   returns 1 if the encoding of d128 is canonical, 0 otherwise      */\n /* No error is possible.\t\t\t\t\t      */\n /* ------------------------------------------------------------------ */\n-uint32_t decimal128IsCanonical(const decimal128 *d128) {\n-  decNumber dn;\t\t\t\t/* work */\n+uInt decimal128IsCanonical(const decimal128 *d128) {\n+  decNumber dn; \t\t\t/* work */\n   decimal128 canon;\t\t\t /* .. */\n   decContext dc;\t\t\t/* .. */\n   decContextDefault(&dc, DEC_INIT_DECIMAL128);\n@@ -501,7 +500,7 @@ uint32_t decimal128IsCanonical(const decimal128 *d128) {\n /* No error is possible.\t\t\t\t\t      */\n /* ------------------------------------------------------------------ */\n decimal128 * decimal128Canonical(decimal128 *result, const decimal128 *d128) {\n-  decNumber dn;\t\t\t\t/* work */\n+  decNumber dn; \t\t\t/* work */\n   decContext dc;\t\t\t/* .. */\n   decContextDefault(&dc, DEC_INIT_DECIMAL128);\n   decimal128ToNumber(d128, &dn);\n@@ -532,13 +531,13 @@ decimal128 * decimal128Canonical(decimal128 *result, const decimal128 *d128) {\n /* This assumes range has been checked and exponent previously 0; */\n /* type of exponent must be unsigned */\n #define decimal128SetExpCon(d, e) {\t\t\t\t      \\\n-  (d)->bytes[0]|=(uint8_t)((e)>>10);\t\t\t\t      \\\n-  (d)->bytes[1] =(uint8_t)(((e)&0x3fc)>>2);\t\t\t      \\\n-  (d)->bytes[2]|=(uint8_t)(((e)&0x03)<<6);}\n+  (d)->bytes[0]|=(uByte)((e)>>10);\t\t\t\t      \\\n+  (d)->bytes[1] =(uByte)(((e)&0x3fc)>>2);\t\t\t      \\\n+  (d)->bytes[2]|=(uByte)(((e)&0x03)<<6);}\n \n /* ------------------------------------------------------------------ */\n /* decimal128Show -- display a decimal128 in hexadecimal [debug aid]  */\n-/*   d128 -- the number to show\t\t\t\t\t      */\n+/*   d128 -- the number to show \t\t\t\t      */\n /* ------------------------------------------------------------------ */\n /* Also shows sign/cob/expconfields extracted */\n void decimal128Show(const decimal128 *d128) {"}, {"sha": "95f73f4bbf4086d1a50e15aa6ca972b5381bae21", "filename": "libdecnumber/dpd/decimal128.h", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f988ec96d922819a4948c1ed96c6dc1b79a7ad22/libdecnumber%2Fdpd%2Fdecimal128.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f988ec96d922819a4948c1ed96c6dc1b79a7ad22/libdecnumber%2Fdpd%2Fdecimal128.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libdecnumber%2Fdpd%2Fdecimal128.h?ref=f988ec96d922819a4948c1ed96c6dc1b79a7ad22", "patch": "@@ -29,7 +29,7 @@\n    02110-1301, USA.  */\n \n /* ------------------------------------------------------------------ */\n-/* Decimal 128-bit format module header\t\t\t\t      */\n+/* Decimal 128-bit format module header \t\t\t      */\n /* ------------------------------------------------------------------ */\n \n #if !defined(DECIMAL128)\n@@ -46,7 +46,7 @@\n   #define DECIMAL128_Bias   6176\t/* bias for the exponent      */\n   #define DECIMAL128_String 43\t\t/* maximum string length, +1  */\n   #define DECIMAL128_EconL  12\t\t/* exp. continuation length   */\n-  /* highest biased exponent (Elimit-1)\t\t\t\t      */\n+  /* highest biased exponent (Elimit-1) \t\t\t      */\n   #define DECIMAL128_Ehigh  (DECIMAL128_Emax+DECIMAL128_Bias-DECIMAL128_Pmax+1)\n \n   /* check enough digits, if pre-defined\t\t\t      */\n@@ -71,20 +71,20 @@\n   /* special values [top byte excluding sign bit; last two bits are   */\n   /* don't-care for Infinity on input, last bit don't-care for NaN]   */\n   #if !defined(DECIMAL_NaN)\n-    #define DECIMAL_NaN\t    0x7c\t/* 0 11111 00 NaN\t      */\n+    #define DECIMAL_NaN     0x7c\t/* 0 11111 00 NaN\t      */\n     #define DECIMAL_sNaN    0x7e\t/* 0 11111 10 sNaN\t      */\n-    #define DECIMAL_Inf\t    0x78\t/* 0 11110 00 Infinity\t      */\n+    #define DECIMAL_Inf     0x78\t/* 0 11110 00 Infinity\t      */\n   #endif\n \n-  #include \"decimal128Local.h\"\n+#include \"decimal128Local.h\"\n \n   /* ---------------------------------------------------------------- */\n   /* Routines\t\t\t\t\t\t\t      */\n   /* ---------------------------------------------------------------- */\n \n-  #include \"decimal128Symbols.h\"\n+#include \"decimal128Symbols.h\"\n \n-  /* String conversions\t\t\t\t\t\t      */\n+  /* String conversions \t\t\t\t\t      */\n   decimal128 * decimal128FromString(decimal128 *, const char *, decContext *);\n   char * decimal128ToString(const decimal128 *, char *);\n   char * decimal128ToEngString(const decimal128 *, char *);\n@@ -94,7 +94,7 @@\n \t\t\t\t    decContext *);\n   decNumber * decimal128ToNumber(const decimal128 *, decNumber *);\n \n-  /* Format-dependent utilities\t\t\t\t\t      */\n+  /* Format-dependent utilities \t\t\t\t      */\n   uint32_t    decimal128IsCanonical(const decimal128 *);\n   decimal128 * decimal128Canonical(decimal128 *, const decimal128 *);\n "}, {"sha": "eefd71c2a3c4a86532b62543c76e33de093de536", "filename": "libdecnumber/dpd/decimal32.c", "status": "modified", "additions": 40, "deletions": 43, "changes": 83, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f988ec96d922819a4948c1ed96c6dc1b79a7ad22/libdecnumber%2Fdpd%2Fdecimal32.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f988ec96d922819a4948c1ed96c6dc1b79a7ad22/libdecnumber%2Fdpd%2Fdecimal32.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libdecnumber%2Fdpd%2Fdecimal32.c?ref=f988ec96d922819a4948c1ed96c6dc1b79a7ad22", "patch": "@@ -29,7 +29,7 @@\n    02110-1301, USA.  */\n \n /* ------------------------------------------------------------------ */\n-/* Decimal 32-bit format module\t\t\t\t\t      */\n+/* Decimal 32-bit format module \t\t\t\t      */\n /* ------------------------------------------------------------------ */\n /* This module comprises the routines for decimal32 format numbers.   */\n /* Conversions are supplied to and from decNumber and String.\t      */\n@@ -42,8 +42,8 @@\n #include <string.h>\t      /* [for memset/memcpy] */\n #include <stdio.h>\t      /* [for printf] */\n \n-#include \"dconfig.h\"\t      /* GCC definitions */\n-#define\t DECNUMDIGITS  7      /* make decNumbers with space for 7 */\n+#include \"dconfig.h\"          /* GCC definitions */\n+#define  DECNUMDIGITS  7      /* make decNumbers with space for 7 */\n #include \"decNumber.h\"\t      /* base number library */\n #include \"decNumberLocal.h\"   /* decNumber local types, etc. */\n #include \"decimal32.h\"\t      /* our primary include */\n@@ -69,9 +69,9 @@ extern void decNumberShow(const decNumber *);\t  /* .. */\n /* ------------------------------------------------------------------ */\n /* decimal32FromNumber -- convert decNumber to decimal32\t      */\n /*\t\t\t\t\t\t\t\t      */\n-/*   ds is the target decimal32\t\t\t\t\t      */\n+/*   ds is the target decimal32 \t\t\t\t      */\n /*   dn is the source number (assumed valid)\t\t\t      */\n-/*   set is the context, used only for reporting errors\t\t      */\n+/*   set is the context, used only for reporting errors \t      */\n /*\t\t\t\t\t\t\t\t      */\n /* The set argument is used only for status reporting and for the     */\n /* rounding mode (used if the coefficient is more than DECIMAL32_Pmax */\n@@ -89,18 +89,18 @@ decimal32 * decimal32FromNumber(decimal32 *d32, const decNumber *dn,\n   Int ae;\t\t\t   /* adjusted exponent */\n   decNumber  dw;\t\t   /* work */\n   decContext dc;\t\t   /* .. */\n-  uInt *pu;\t\t\t   /* .. */\n   uInt comb, exp;\t\t   /* .. */\n+  uInt uiwork;\t\t\t   /* for macros */\n   uInt targ=0;\t\t\t   /* target 32-bit */\n \n   /* If the number has too many digits, or the exponent could be */\n   /* out of range then reduce the number under the appropriate */\n   /* constraints.  This could push the number to Infinity or zero, */\n   /* so this check and rounding must be done before generating the */\n   /* decimal32] */\n-  ae=dn->exponent+dn->digits-1;\t\t     /* [0 if special] */\n-  if (dn->digits>DECIMAL32_Pmax\t\t     /* too many digits */\n-   || ae>DECIMAL32_Emax\t\t\t     /* likely overflow */\n+  ae=dn->exponent+dn->digits-1; \t     /* [0 if special] */\n+  if (dn->digits>DECIMAL32_Pmax \t     /* too many digits */\n+   || ae>DECIMAL32_Emax \t\t     /* likely overflow */\n    || ae<DECIMAL32_Emin) {\t\t     /* likely underflow */\n     decContextDefault(&dc, DEC_INIT_DECIMAL32); /* [no traps] */\n     dc.round=set->round;\t\t     /* use supplied rounding */\n@@ -114,7 +114,7 @@ decimal32 * decimal32FromNumber(decimal32 *d32, const decNumber *dn,\n   if (dn->bits&DECSPECIAL) {\t\t\t  /* a special value */\n     if (dn->bits&DECINF) targ=DECIMAL_Inf<<24;\n      else {\t\t\t\t\t  /* sNaN or qNaN */\n-      if ((*dn->lsu!=0 || dn->digits>1)\t\t  /* non-zero coefficient */\n+      if ((*dn->lsu!=0 || dn->digits>1) \t  /* non-zero coefficient */\n        && (dn->digits<DECIMAL32_Pmax)) {\t  /* coefficient fits */\n \tdecDigitsToDPD(dn, &targ, 0);\n \t}\n@@ -140,7 +140,7 @@ decimal32 * decimal32FromNumber(decimal32 *d32, const decNumber *dn,\n       comb=(exp>>3) & 0x18;\t\t/* msd=0, exp top 2 bits .. */\n       }\n      else {\t\t\t\t/* non-zero finite number */\n-      uInt msd;\t\t\t\t/* work */\n+      uInt msd; \t\t\t/* work */\n       Int pad=0;\t\t\t/* coefficient pad digits */\n \n       /* the dn is known to fit, but it may need to be padded */\n@@ -175,8 +175,7 @@ decimal32 * decimal32FromNumber(decimal32 *d32, const decNumber *dn,\n   if (dn->bits&DECNEG) targ|=0x80000000;  /* add sign bit */\n \n   /* now write to storage; this is endian */\n-  pu=(uInt *)d32->bytes;\t   /* overlay */\n-  *pu=targ;\t\t\t   /* directly store the int */\n+  UBFROMUI(d32->bytes, targ);\t   /* directly store the int */\n \n   if (status!=0) decContextSetStatus(set, status); /* pass on status */\n   /* decimal32Show(d32); */\n@@ -194,21 +193,20 @@ decNumber * decimal32ToNumber(const decimal32 *d32, decNumber *dn) {\n   uInt exp;\t\t\t   /* exponent top two bits */\n   uInt comb;\t\t\t   /* combination field */\n   uInt sour;\t\t\t   /* source 32-bit */\n-  const uInt *pu;\t\t   /* work */\n+  uInt uiwork;\t\t\t   /* for macros */\n \n   /* load source from storage; this is endian */\n-  pu=(const uInt *)d32->bytes;\t   /* overlay */\n-  sour=*pu;\t\t\t   /* directly load the int */\n+  sour=UBTOUI(d32->bytes);\t   /* directly load the int */\n \n-  comb=(sour>>26)&0x1f;\t\t   /* combination field */\n+  comb=(sour>>26)&0x1f; \t   /* combination field */\n \n   decNumberZero(dn);\t\t   /* clean number */\n   if (sour&0x80000000) dn->bits=DECNEG; /* set sign if negative */\n \n   msd=COMBMSD[comb];\t\t   /* decode the combination field */\n   exp=COMBEXP[comb];\t\t   /* .. */\n \n-  if (exp==3) {\t\t\t   /* is a special */\n+  if (exp==3) { \t\t   /* is a special */\n     if (msd==0) {\n       dn->bits|=DECINF;\n       return dn;\t\t   /* no coefficient needed */\n@@ -229,7 +227,7 @@ decNumber * decimal32ToNumber(const decimal32 *d32, decNumber *dn) {\n     return dn;\n     }\n   /* msd=0 */\n-  if (!sour) return dn;\t\t   /* easy: coefficient is 0 */\n+  if (!sour) return dn; \t   /* easy: coefficient is 0 */\n   if (sour&0x000ffc00)\t\t   /* need 2 declets? */\n     decDigitsFromDPD(dn, &sour, 2); /* process 2 declets */\n    else\n@@ -238,11 +236,11 @@ decNumber * decimal32ToNumber(const decimal32 *d32, decNumber *dn) {\n   } /* decimal32ToNumber */\n \n /* ------------------------------------------------------------------ */\n-/* to-scientific-string -- conversion to numeric string\t\t      */\n+/* to-scientific-string -- conversion to numeric string \t      */\n /* to-engineering-string -- conversion to numeric string\t      */\n /*\t\t\t\t\t\t\t\t      */\n /*   decimal32ToString(d32, string);\t\t\t\t      */\n-/*   decimal32ToEngString(d32, string);\t\t\t\t      */\n+/*   decimal32ToEngString(d32, string); \t\t\t      */\n /*\t\t\t\t\t\t\t\t      */\n /*  d32 is the decimal32 format number to convert\t\t      */\n /*  string is the string where the result will be laid out\t      */\n@@ -252,7 +250,7 @@ decNumber * decimal32ToNumber(const decimal32 *d32, decNumber *dn) {\n /*  No error is possible, and no status can be set.\t\t      */\n /* ------------------------------------------------------------------ */\n char * decimal32ToEngString(const decimal32 *d32, char *string){\n-  decNumber dn;\t\t\t\t/* work */\n+  decNumber dn; \t\t\t/* work */\n   decimal32ToNumber(d32, &dn);\n   decNumberToEngString(&dn, string);\n   return string;\n@@ -262,29 +260,28 @@ char * decimal32ToString(const decimal32 *d32, char *string){\n   uInt msd;\t\t\t   /* coefficient MSD */\n   Int  exp;\t\t\t   /* exponent top two bits or full */\n   uInt comb;\t\t\t   /* combination field */\n-  char *cstart;\t\t\t   /* coefficient start */\n+  char *cstart; \t\t   /* coefficient start */\n   char *c;\t\t\t   /* output pointer in string */\n-  const uInt *pu;\t\t   /* work */\n-  const uByte *u;\t\t   /* .. */\n+  const uByte *u;\t\t   /* work */\n   char *s, *t;\t\t\t   /* .. (source, target) */\n   Int  dpd;\t\t\t   /* .. */\n   Int  pre, e;\t\t\t   /* .. */\n+  uInt uiwork;\t\t\t   /* for macros */\n   uInt sour;\t\t\t   /* source 32-bit */\n \n   /* load source from storage; this is endian */\n-  pu=(const uInt *)d32->bytes;\t   /* overlay */\n-  sour=*pu;\t\t\t   /* directly load the int */\n+  sour=UBTOUI(d32->bytes);\t   /* directly load the int */\n \n   c=string;\t\t\t   /* where result will go */\n   if (((Int)sour)<0) *c++='-';\t   /* handle sign */\n \n-  comb=(sour>>26)&0x1f;\t\t   /* combination field */\n+  comb=(sour>>26)&0x1f; \t   /* combination field */\n   msd=COMBMSD[comb];\t\t   /* decode the combination field */\n   exp=COMBEXP[comb];\t\t   /* .. */\n \n   if (exp==3) {\n     if (msd==0) {\t\t   /* infinity */\n-      strcpy(c,\t  \"Inf\");\n+      strcpy(c,   \"Inf\");\n       strcpy(c+3, \"inity\");\n       return string;\t\t   /* easy */\n       }\n@@ -309,18 +306,18 @@ char * decimal32ToString(const decimal32 *d32, char *string){\n   /* length.  We use fixed-length memcpys because variable-length */\n   /* causes a subroutine call in GCC.  (These are length 4 for speed */\n   /* and are safe because the array has an extra terminator byte.) */\n-  #define dpd2char u=&BIN2CHAR[DPD2BIN[dpd]*4];\t\t\t  \\\n+  #define dpd2char u=&BIN2CHAR[DPD2BIN[dpd]*4]; \t\t  \\\n \t\t   if (c!=cstart) {memcpy(c, u+1, 4); c+=3;}\t  \\\n \t\t    else if (*u)  {memcpy(c, u+4-*u, 4); c+=*u;}\n \n-  dpd=(sour>>10)&0x3ff;\t\t   /* declet 1 */\n+  dpd=(sour>>10)&0x3ff; \t   /* declet 1 */\n   dpd2char;\n   dpd=(sour)&0x3ff;\t\t   /* declet 2 */\n   dpd2char;\n \n   if (c==cstart) *c++='0';\t   /* all zeros -- make 0 */\n \n-  if (exp==0) {\t\t\t   /* integer or NaN case -- easy */\n+  if (exp==0) { \t\t   /* integer or NaN case -- easy */\n     *c='\\0';\t\t\t   /* terminate */\n     return string;\n     }\n@@ -348,13 +345,13 @@ char * decimal32ToString(const decimal32 *d32, char *string){\n     /* finally add the E-part, if needed; it will never be 0, and has */\n     /* a maximum length of 3 digits (E-101 case) */\n     if (e!=0) {\n-      *c++='E';\t\t\t   /* starts with E */\n-      *c++='+';\t\t\t   /* assume positive */\n+      *c++='E'; \t\t   /* starts with E */\n+      *c++='+'; \t\t   /* assume positive */\n       if (e<0) {\n \t*(c-1)='-';\t\t   /* oops, need '-' */\n \te=-e;\t\t\t   /* uInt, please */\n \t}\n-      u=&BIN2CHAR[e*4];\t\t   /* -> length byte */\n+      u=&BIN2CHAR[e*4]; \t   /* -> length byte */\n       memcpy(c, u+4-*u, 4);\t   /* copy fixed 4 characters [is safe] */\n       c+=*u;\t\t\t   /* bump pointer appropriately */\n       }\n@@ -384,7 +381,7 @@ char * decimal32ToString(const decimal32 *d32, char *string){\n /*\t    the conversion\t\t\t\t\t      */\n /*  *string is the character string which should contain a valid      */\n /*\t    number (which may be a special value)\t\t      */\n-/*  set\t    is the context\t\t\t\t\t      */\n+/*  set     is the context\t\t\t\t\t      */\n /*\t\t\t\t\t\t\t\t      */\n /* The context is supplied to this routine is used for error handling */\n /* (setting of status and traps) and for the rounding mode, only.     */\n@@ -393,7 +390,7 @@ char * decimal32ToString(const decimal32 *d32, char *string){\n decimal32 * decimal32FromString(decimal32 *result, const char *string,\n \t\t\t\tdecContext *set) {\n   decContext dc;\t\t\t     /* work */\n-  decNumber dn;\t\t\t\t     /* .. */\n+  decNumber dn; \t\t\t     /* .. */\n \n   decContextDefault(&dc, DEC_INIT_DECIMAL32); /* no traps, please */\n   dc.round=set->round;\t\t\t      /* use supplied rounding */\n@@ -409,11 +406,11 @@ decimal32 * decimal32FromString(decimal32 *result, const char *string,\n /* ------------------------------------------------------------------ */\n /* decimal32IsCanonical -- test whether encoding is canonical\t      */\n /*   d32 is the source decimal32\t\t\t\t      */\n-/*   returns 1 if the encoding of d32 is canonical, 0 otherwise\t      */\n+/*   returns 1 if the encoding of d32 is canonical, 0 otherwise       */\n /* No error is possible.\t\t\t\t\t      */\n /* ------------------------------------------------------------------ */\n-uint32_t decimal32IsCanonical(const decimal32 *d32) {\n-  decNumber dn;\t\t\t\t/* work */\n+uInt decimal32IsCanonical(const decimal32 *d32) {\n+  decNumber dn; \t\t\t/* work */\n   decimal32 canon;\t\t\t/* .. */\n   decContext dc;\t\t\t/* .. */\n   decContextDefault(&dc, DEC_INIT_DECIMAL32);\n@@ -430,7 +427,7 @@ uint32_t decimal32IsCanonical(const decimal32 *d32) {\n /* No error is possible.\t\t\t\t\t      */\n /* ------------------------------------------------------------------ */\n decimal32 * decimal32Canonical(decimal32 *result, const decimal32 *d32) {\n-  decNumber dn;\t\t\t\t/* work */\n+  decNumber dn; \t\t\t/* work */\n   decContext dc;\t\t\t/* .. */\n   decContextDefault(&dc, DEC_INIT_DECIMAL32);\n   decimal32ToNumber(d32, &dn);\n@@ -460,8 +457,8 @@ decimal32 * decimal32Canonical(decimal32 *result, const decimal32 *d32) {\n /* This assumes range has been checked and exponent previously 0; */\n /* type of exponent must be unsigned */\n #define decimal32SetExpCon(d, e) {\t\t\t\t      \\\n-  (d)->bytes[0]|=(uint8_t)((e)>>4);\t\t\t\t      \\\n-  (d)->bytes[1]|=(uint8_t)(((e)&0x0F)<<4);}\n+  (d)->bytes[0]|=(uByte)((e)>>4);\t\t\t\t      \\\n+  (d)->bytes[1]|=(uByte)(((e)&0x0F)<<4);}\n \n /* ------------------------------------------------------------------ */\n /* decimal32Show -- display a decimal32 in hexadecimal [debug aid]    */"}, {"sha": "222ba973f4cd27d63839967538fe546116d55bc4", "filename": "libdecnumber/dpd/decimal32.h", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f988ec96d922819a4948c1ed96c6dc1b79a7ad22/libdecnumber%2Fdpd%2Fdecimal32.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f988ec96d922819a4948c1ed96c6dc1b79a7ad22/libdecnumber%2Fdpd%2Fdecimal32.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libdecnumber%2Fdpd%2Fdecimal32.h?ref=f988ec96d922819a4948c1ed96c6dc1b79a7ad22", "patch": "@@ -35,7 +35,7 @@\n #if !defined(DECIMAL32)\n   #define DECIMAL32\n   #define DEC32NAME\t\"decimal32\"\t\t      /* Short name   */\n-  #define DEC32FULLNAME \"Decimal 32-bit Number\"\t      /* Verbose name */\n+  #define DEC32FULLNAME \"Decimal 32-bit Number\"       /* Verbose name */\n   #define DEC32AUTHOR\t\"Mike Cowlishaw\"\t      /* Who to blame */\n \n   /* parameters for decimal32s */\n@@ -46,7 +46,7 @@\n   #define DECIMAL32_Bias   101\t\t/* bias for the exponent      */\n   #define DECIMAL32_String 15\t\t/* maximum string length, +1  */\n   #define DECIMAL32_EconL  6\t\t/* exp. continuation length   */\n-  /* highest biased exponent (Elimit-1)\t\t\t\t      */\n+  /* highest biased exponent (Elimit-1) \t\t\t      */\n   #define DECIMAL32_Ehigh  (DECIMAL32_Emax+DECIMAL32_Bias-DECIMAL32_Pmax+1)\n \n   /* check enough digits, if pre-defined\t\t\t      */\n@@ -71,18 +71,18 @@\n   /* special values [top byte excluding sign bit; last two bits are   */\n   /* don't-care for Infinity on input, last bit don't-care for NaN]   */\n   #if !defined(DECIMAL_NaN)\n-    #define DECIMAL_NaN\t    0x7c\t/* 0 11111 00 NaN\t      */\n+    #define DECIMAL_NaN     0x7c\t/* 0 11111 00 NaN\t      */\n     #define DECIMAL_sNaN    0x7e\t/* 0 11111 10 sNaN\t      */\n-    #define DECIMAL_Inf\t    0x78\t/* 0 11110 00 Infinity\t      */\n+    #define DECIMAL_Inf     0x78\t/* 0 11110 00 Infinity\t      */\n   #endif\n \n   /* ---------------------------------------------------------------- */\n   /* Routines\t\t\t\t\t\t\t      */\n   /* ---------------------------------------------------------------- */\n \n-  #include \"decimal32Symbols.h\"\n+#include \"decimal32Symbols.h\"\n \n-  /* String conversions\t\t\t\t\t\t      */\n+  /* String conversions \t\t\t\t\t      */\n   decimal32 * decimal32FromString(decimal32 *, const char *, decContext *);\n   char * decimal32ToString(const decimal32 *, char *);\n   char * decimal32ToEngString(const decimal32 *, char *);\n@@ -92,7 +92,7 @@\n \t\t\t\t  decContext *);\n   decNumber * decimal32ToNumber(const decimal32 *, decNumber *);\n \n-  /* Format-dependent utilities\t\t\t\t\t      */\n+  /* Format-dependent utilities \t\t\t\t      */\n   uint32_t    decimal32IsCanonical(const decimal32 *);\n   decimal32 * decimal32Canonical(decimal32 *, const decimal32 *);\n "}, {"sha": "77684d82fccdc86dd169f443d9281850305288eb", "filename": "libdecnumber/dpd/decimal64.c", "status": "modified", "additions": 66, "deletions": 67, "changes": 133, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f988ec96d922819a4948c1ed96c6dc1b79a7ad22/libdecnumber%2Fdpd%2Fdecimal64.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f988ec96d922819a4948c1ed96c6dc1b79a7ad22/libdecnumber%2Fdpd%2Fdecimal64.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libdecnumber%2Fdpd%2Fdecimal64.c?ref=f988ec96d922819a4948c1ed96c6dc1b79a7ad22", "patch": "@@ -29,7 +29,7 @@\n    02110-1301, USA.  */\n \n /* ------------------------------------------------------------------ */\n-/* Decimal 64-bit format module\t\t\t\t\t      */\n+/* Decimal 64-bit format module \t\t\t\t      */\n /* ------------------------------------------------------------------ */\n /* This module comprises the routines for decimal64 format numbers.   */\n /* Conversions are supplied to and from decNumber and String.\t      */\n@@ -42,8 +42,8 @@\n #include <string.h>\t      /* [for memset/memcpy] */\n #include <stdio.h>\t      /* [for printf] */\n \n-#include \"dconfig.h\"\t      /* GCC definitions */\n-#define\t DECNUMDIGITS 16      /* make decNumbers with space for 16 */\n+#include \"dconfig.h\"          /* GCC definitions */\n+#define  DECNUMDIGITS 16      /* make decNumbers with space for 16 */\n #include \"decNumber.h\"\t      /* base number library */\n #include \"decNumberLocal.h\"   /* decNumber local types, etc. */\n #include \"decimal64.h\"\t      /* our primary include */\n@@ -75,9 +75,9 @@ extern void decNumberShow(const decNumber *);\t  /* .. */\n /* ------------------------------------------------------------------ */\n /* decimal64FromNumber -- convert decNumber to decimal64\t      */\n /*\t\t\t\t\t\t\t\t      */\n-/*   ds is the target decimal64\t\t\t\t\t      */\n+/*   ds is the target decimal64 \t\t\t\t      */\n /*   dn is the source number (assumed valid)\t\t\t      */\n-/*   set is the context, used only for reporting errors\t\t      */\n+/*   set is the context, used only for reporting errors \t      */\n /*\t\t\t\t\t\t\t\t      */\n /* The set argument is used only for status reporting and for the     */\n /* rounding mode (used if the coefficient is more than DECIMAL64_Pmax */\n@@ -95,8 +95,8 @@ decimal64 * decimal64FromNumber(decimal64 *d64, const decNumber *dn,\n   Int ae;\t\t\t   /* adjusted exponent */\n   decNumber  dw;\t\t   /* work */\n   decContext dc;\t\t   /* .. */\n-  uInt *pu;\t\t\t   /* .. */\n   uInt comb, exp;\t\t   /* .. */\n+  uInt uiwork;\t\t\t   /* for macros */\n   uInt targar[2]={0, 0};\t   /* target 64-bit */\n   #define targhi targar[1]\t   /* name the word with the sign */\n   #define targlo targar[0]\t   /* and the other */\n@@ -106,9 +106,9 @@ decimal64 * decimal64FromNumber(decimal64 *d64, const decNumber *dn,\n   /* constraints.  This could push the number to Infinity or zero, */\n   /* so this check and rounding must be done before generating the */\n   /* decimal64] */\n-  ae=dn->exponent+dn->digits-1;\t\t     /* [0 if special] */\n-  if (dn->digits>DECIMAL64_Pmax\t\t     /* too many digits */\n-   || ae>DECIMAL64_Emax\t\t\t     /* likely overflow */\n+  ae=dn->exponent+dn->digits-1; \t     /* [0 if special] */\n+  if (dn->digits>DECIMAL64_Pmax \t     /* too many digits */\n+   || ae>DECIMAL64_Emax \t\t     /* likely overflow */\n    || ae<DECIMAL64_Emin) {\t\t     /* likely underflow */\n     decContextDefault(&dc, DEC_INIT_DECIMAL64); /* [no traps] */\n     dc.round=set->round;\t\t     /* use supplied rounding */\n@@ -122,7 +122,7 @@ decimal64 * decimal64FromNumber(decimal64 *d64, const decNumber *dn,\n   if (dn->bits&DECSPECIAL) {\t\t\t  /* a special value */\n     if (dn->bits&DECINF) targhi=DECIMAL_Inf<<24;\n      else {\t\t\t\t\t  /* sNaN or qNaN */\n-      if ((*dn->lsu!=0 || dn->digits>1)\t\t  /* non-zero coefficient */\n+      if ((*dn->lsu!=0 || dn->digits>1) \t  /* non-zero coefficient */\n        && (dn->digits<DECIMAL64_Pmax)) {\t  /* coefficient fits */\n \tdecDigitsToDPD(dn, targar, 0);\n \t}\n@@ -148,7 +148,7 @@ decimal64 * decimal64FromNumber(decimal64 *d64, const decNumber *dn,\n       comb=(exp>>5) & 0x18;\t\t/* msd=0, exp top 2 bits .. */\n       }\n      else {\t\t\t\t/* non-zero finite number */\n-      uInt msd;\t\t\t\t/* work */\n+      uInt msd; \t\t\t/* work */\n       Int pad=0;\t\t\t/* coefficient pad digits */\n \n       /* the dn is known to fit, but it may need to be padded */\n@@ -193,14 +193,15 @@ decimal64 * decimal64FromNumber(decimal64 *d64, const decNumber *dn,\n   if (dn->bits&DECNEG) targhi|=0x80000000; /* add sign bit */\n \n   /* now write to storage; this is now always endian */\n-  pu=(uInt *)d64->bytes;\t   /* overlay */\n   if (DECLITEND) {\n-    pu[0]=targar[0];\t\t   /* directly store the low int */\n-    pu[1]=targar[1];\t\t   /* then the high int */\n+    /* lo int then hi */\n+    UBFROMUI(d64->bytes,   targar[0]);\n+    UBFROMUI(d64->bytes+4, targar[1]);\n     }\n    else {\n-    pu[0]=targar[1];\t\t   /* directly store the high int */\n-    pu[1]=targar[0];\t\t   /* then the low int */\n+    /* hi int then lo */\n+    UBFROMUI(d64->bytes,   targar[1]);\n+    UBFROMUI(d64->bytes+4, targar[0]);\n     }\n \n   if (status!=0) decContextSetStatus(set, status); /* pass on status */\n@@ -218,21 +219,20 @@ decNumber * decimal64ToNumber(const decimal64 *d64, decNumber *dn) {\n   uInt msd;\t\t\t   /* coefficient MSD */\n   uInt exp;\t\t\t   /* exponent top two bits */\n   uInt comb;\t\t\t   /* combination field */\n-  const uInt *pu;\t\t   /* work */\n-  Int  need;\t\t\t   /* .. */\n+  Int  need;\t\t\t   /* work */\n+  uInt uiwork;\t\t\t   /* for macros */\n   uInt sourar[2];\t\t   /* source 64-bit */\n   #define sourhi sourar[1]\t   /* name the word with the sign */\n   #define sourlo sourar[0]\t   /* and the lower word */\n \n   /* load source from storage; this is endian */\n-  pu=(const uInt *)d64->bytes;\t   /* overlay */\n   if (DECLITEND) {\n-    sourlo=pu[0];\t\t   /* directly load the low int */\n-    sourhi=pu[1];\t\t   /* then the high int */\n+    sourlo=UBTOUI(d64->bytes  );   /* directly load the low int */\n+    sourhi=UBTOUI(d64->bytes+4);   /* then the high int */\n     }\n    else {\n-    sourhi=pu[0];\t\t   /* directly load the high int */\n-    sourlo=pu[1];\t\t   /* then the low int */\n+    sourhi=UBTOUI(d64->bytes  );   /* directly load the high int */\n+    sourlo=UBTOUI(d64->bytes+4);   /* then the low int */\n     }\n \n   comb=(sourhi>>26)&0x1f;\t   /* combination field */\n@@ -243,7 +243,7 @@ decNumber * decimal64ToNumber(const decimal64 *d64, decNumber *dn) {\n   msd=COMBMSD[comb];\t\t   /* decode the combination field */\n   exp=COMBEXP[comb];\t\t   /* .. */\n \n-  if (exp==3) {\t\t\t   /* is a special */\n+  if (exp==3) { \t\t   /* is a special */\n     if (msd==0) {\n       dn->bits|=DECINF;\n       return dn;\t\t   /* no coefficient needed */\n@@ -281,11 +281,11 @@ decNumber * decimal64ToNumber(const decimal64 *d64, decNumber *dn) {\n \n \n /* ------------------------------------------------------------------ */\n-/* to-scientific-string -- conversion to numeric string\t\t      */\n+/* to-scientific-string -- conversion to numeric string \t      */\n /* to-engineering-string -- conversion to numeric string\t      */\n /*\t\t\t\t\t\t\t\t      */\n /*   decimal64ToString(d64, string);\t\t\t\t      */\n-/*   decimal64ToEngString(d64, string);\t\t\t\t      */\n+/*   decimal64ToEngString(d64, string); \t\t\t      */\n /*\t\t\t\t\t\t\t\t      */\n /*  d64 is the decimal64 format number to convert\t\t      */\n /*  string is the string where the result will be laid out\t      */\n@@ -295,7 +295,7 @@ decNumber * decimal64ToNumber(const decimal64 *d64, decNumber *dn) {\n /*  No error is possible, and no status can be set.\t\t      */\n /* ------------------------------------------------------------------ */\n char * decimal64ToEngString(const decimal64 *d64, char *string){\n-  decNumber dn;\t\t\t\t/* work */\n+  decNumber dn; \t\t\t/* work */\n   decimal64ToNumber(d64, &dn);\n   decNumberToEngString(&dn, string);\n   return string;\n@@ -305,27 +305,26 @@ char * decimal64ToString(const decimal64 *d64, char *string){\n   uInt msd;\t\t\t   /* coefficient MSD */\n   Int  exp;\t\t\t   /* exponent top two bits or full */\n   uInt comb;\t\t\t   /* combination field */\n-  char *cstart;\t\t\t   /* coefficient start */\n+  char *cstart; \t\t   /* coefficient start */\n   char *c;\t\t\t   /* output pointer in string */\n-  const uInt *pu;\t\t   /* work */\n+  const uByte *u;\t\t   /* work */\n   char *s, *t;\t\t\t   /* .. (source, target) */\n   Int  dpd;\t\t\t   /* .. */\n   Int  pre, e;\t\t\t   /* .. */\n-  const uByte *u;\t\t   /* .. */\n+  uInt uiwork;\t\t\t   /* for macros */\n \n   uInt sourar[2];\t\t   /* source 64-bit */\n   #define sourhi sourar[1]\t   /* name the word with the sign */\n   #define sourlo sourar[0]\t   /* and the lower word */\n \n   /* load source from storage; this is endian */\n-  pu=(const uInt *)d64->bytes;\t   /* overlay */\n   if (DECLITEND) {\n-    sourlo=pu[0];\t\t   /* directly load the low int */\n-    sourhi=pu[1];\t\t   /* then the high int */\n+    sourlo=UBTOUI(d64->bytes  );   /* directly load the low int */\n+    sourhi=UBTOUI(d64->bytes+4);   /* then the high int */\n     }\n    else {\n-    sourhi=pu[0];\t\t   /* directly load the high int */\n-    sourlo=pu[1];\t\t   /* then the low int */\n+    sourhi=UBTOUI(d64->bytes  );   /* directly load the high int */\n+    sourlo=UBTOUI(d64->bytes+4);   /* then the low int */\n     }\n \n   c=string;\t\t\t   /* where result will go */\n@@ -337,7 +336,7 @@ char * decimal64ToString(const decimal64 *d64, char *string){\n \n   if (exp==3) {\n     if (msd==0) {\t\t   /* infinity */\n-      strcpy(c,\t  \"Inf\");\n+      strcpy(c,   \"Inf\");\n       strcpy(c+3, \"inity\");\n       return string;\t\t   /* easy */\n       }\n@@ -362,7 +361,7 @@ char * decimal64ToString(const decimal64 *d64, char *string){\n   /* length.  We use fixed-length memcpys because variable-length */\n   /* causes a subroutine call in GCC.  (These are length 4 for speed */\n   /* and are safe because the array has an extra terminator byte.) */\n-  #define dpd2char u=&BIN2CHAR[DPD2BIN[dpd]*4];\t\t\t  \\\n+  #define dpd2char u=&BIN2CHAR[DPD2BIN[dpd]*4]; \t\t  \\\n \t\t   if (c!=cstart) {memcpy(c, u+1, 4); c+=3;}\t  \\\n \t\t    else if (*u)  {memcpy(c, u+4-*u, 4); c+=*u;}\n \n@@ -379,7 +378,7 @@ char * decimal64ToString(const decimal64 *d64, char *string){\n \n   if (c==cstart) *c++='0';\t   /* all zeros -- make 0 */\n \n-  if (exp==0) {\t\t\t   /* integer or NaN case -- easy */\n+  if (exp==0) { \t\t   /* integer or NaN case -- easy */\n     *c='\\0';\t\t\t   /* terminate */\n     return string;\n     }\n@@ -407,13 +406,13 @@ char * decimal64ToString(const decimal64 *d64, char *string){\n     /* finally add the E-part, if needed; it will never be 0, and has */\n     /* a maximum length of 3 digits */\n     if (e!=0) {\n-      *c++='E';\t\t\t   /* starts with E */\n-      *c++='+';\t\t\t   /* assume positive */\n+      *c++='E'; \t\t   /* starts with E */\n+      *c++='+'; \t\t   /* assume positive */\n       if (e<0) {\n \t*(c-1)='-';\t\t   /* oops, need '-' */\n \te=-e;\t\t\t   /* uInt, please */\n \t}\n-      u=&BIN2CHAR[e*4];\t\t   /* -> length byte */\n+      u=&BIN2CHAR[e*4]; \t   /* -> length byte */\n       memcpy(c, u+4-*u, 4);\t   /* copy fixed 4 characters [is safe] */\n       c+=*u;\t\t\t   /* bump pointer appropriately */\n       }\n@@ -443,7 +442,7 @@ char * decimal64ToString(const decimal64 *d64, char *string){\n /*\t    the conversion\t\t\t\t\t      */\n /*  *string is the character string which should contain a valid      */\n /*\t    number (which may be a special value)\t\t      */\n-/*  set\t    is the context\t\t\t\t\t      */\n+/*  set     is the context\t\t\t\t\t      */\n /*\t\t\t\t\t\t\t\t      */\n /* The context is supplied to this routine is used for error handling */\n /* (setting of status and traps) and for the rounding mode, only.     */\n@@ -452,7 +451,7 @@ char * decimal64ToString(const decimal64 *d64, char *string){\n decimal64 * decimal64FromString(decimal64 *result, const char *string,\n \t\t\t\tdecContext *set) {\n   decContext dc;\t\t\t     /* work */\n-  decNumber dn;\t\t\t\t     /* .. */\n+  decNumber dn; \t\t\t     /* .. */\n \n   decContextDefault(&dc, DEC_INIT_DECIMAL64); /* no traps, please */\n   dc.round=set->round;\t\t\t      /* use supplied rounding */\n@@ -469,11 +468,11 @@ decimal64 * decimal64FromString(decimal64 *result, const char *string,\n /* ------------------------------------------------------------------ */\n /* decimal64IsCanonical -- test whether encoding is canonical\t      */\n /*   d64 is the source decimal64\t\t\t\t      */\n-/*   returns 1 if the encoding of d64 is canonical, 0 otherwise\t      */\n+/*   returns 1 if the encoding of d64 is canonical, 0 otherwise       */\n /* No error is possible.\t\t\t\t\t      */\n /* ------------------------------------------------------------------ */\n-uint32_t decimal64IsCanonical(const decimal64 *d64) {\n-  decNumber dn;\t\t\t\t/* work */\n+uInt decimal64IsCanonical(const decimal64 *d64) {\n+  decNumber dn; \t\t\t/* work */\n   decimal64 canon;\t\t\t/* .. */\n   decContext dc;\t\t\t/* .. */\n   decContextDefault(&dc, DEC_INIT_DECIMAL64);\n@@ -490,7 +489,7 @@ uint32_t decimal64IsCanonical(const decimal64 *d64) {\n /* No error is possible.\t\t\t\t\t      */\n /* ------------------------------------------------------------------ */\n decimal64 * decimal64Canonical(decimal64 *result, const decimal64 *d64) {\n-  decNumber dn;\t\t\t\t/* work */\n+  decNumber dn; \t\t\t/* work */\n   decContext dc;\t\t\t/* .. */\n   decContextDefault(&dc, DEC_INIT_DECIMAL64);\n   decimal64ToNumber(d64, &dn);\n@@ -520,8 +519,8 @@ decimal64 * decimal64Canonical(decimal64 *result, const decimal64 *d64) {\n /* This assumes range has been checked and exponent previously 0; */\n /* type of exponent must be unsigned */\n #define decimal64SetExpCon(d, e) {\t\t\t\t      \\\n-  (d)->bytes[0]|=(uint8_t)((e)>>6);\t\t\t\t      \\\n-  (d)->bytes[1]|=(uint8_t)(((e)&0x3F)<<2);}\n+  (d)->bytes[0]|=(uByte)((e)>>6);\t\t\t\t      \\\n+  (d)->bytes[1]|=(uByte)(((e)&0x3F)<<2);}\n \n /* ------------------------------------------------------------------ */\n /* decimal64Show -- display a decimal64 in hexadecimal [debug aid]    */\n@@ -591,12 +590,12 @@ const uInt COMBMSD[32]={0, 1, 2, 3, 4, 5, 6, 7,\n /* ------------------------------------------------------------------ */\n /* decDigitsToDPD -- pack coefficient into DPD form\t\t      */\n /*\t\t\t\t\t\t\t\t      */\n-/*   dn\t  is the source number (assumed valid, max DECMAX754 digits)  */\n+/*   dn   is the source number (assumed valid, max DECMAX754 digits)  */\n /*   targ is 1, 2, or 4-element uInt array, which the caller must     */\n-/*\t  have cleared to zeros\t\t\t\t\t      */\n+/*\t  have cleared to zeros \t\t\t\t      */\n /*   shift is the number of 0 digits to add on the right (normally 0) */\n /*\t\t\t\t\t\t\t\t      */\n-/* The coefficient must be known small enough to fit.  The full\t      */\n+/* The coefficient must be known small enough to fit.  The full       */\n /* coefficient is copied, including the leading 'odd' digit.  This    */\n /* digit is retrieved and packed into the combination field by the    */\n /* caller.\t\t\t\t\t\t\t      */\n@@ -625,7 +624,7 @@ void decDigitsToDPD(const decNumber *dn, uInt *targ, Int shift) {\n   uInt dpd;\t\t      /* densely packed decimal value */\n   uInt bin;\t\t      /* binary value 0-999 */\n   uInt *uout=targ;\t      /* -> current output uInt */\n-  uInt\tuoff=0;\t\t      /* -> current output offset [from right] */\n+  uInt\tuoff=0; \t      /* -> current output offset [from right] */\n   const Unit *inu=dn->lsu;    /* -> current input unit */\n   Unit\tuar[DECMAXUNITS];     /* working copy of units, iff shifted */\n   #if DECDPUN!=3\t      /* not fast path */\n@@ -636,7 +635,7 @@ void decDigitsToDPD(const decNumber *dn, uInt *targ, Int shift) {\n     /* shift the units array to the left by pad digits and copy */\n     /* [this code is a special case of decShiftToMost, which could */\n     /* be used instead if exposed and the array were copied first] */\n-    const Unit *source;\t\t\t/* .. */\n+    const Unit *source; \t\t/* .. */\n     Unit  *target, *first;\t\t/* .. */\n     uInt  next=0;\t\t\t/* work */\n \n@@ -681,12 +680,12 @@ void decDigitsToDPD(const decNumber *dn, uInt *targ, Int shift) {\n \n   for(n=0; digits>0; n++) {\t   /* each output bunch */\n     #if DECDPUN==3\t\t   /* fast path, 3-at-a-time */\n-      bin=*inu;\t\t\t   /* 3 digits ready for convert */\n+      bin=*inu; \t\t   /* 3 digits ready for convert */\n       digits-=3;\t\t   /* [may go negative] */\n       inu++;\t\t\t   /* may need another */\n \n     #else\t\t\t   /* must collect digit-by-digit */\n-      Unit dig;\t\t\t   /* current digit */\n+      Unit dig; \t\t   /* current digit */\n       Int j;\t\t\t   /* digit-in-declet count */\n       for (j=0; j<3; j++) {\n \t#if DECDPUN<=4\n@@ -698,7 +697,7 @@ void decDigitsToDPD(const decNumber *dn, uInt *targ, Int shift) {\n \t  in=in/10;\n \t#endif\n \tif (j==0) bin=dig;\n-\t else if (j==1)\t bin+=X10(dig);\n+\t else if (j==1)  bin+=X10(dig);\n \t else /* j==2 */ bin+=X100(dig);\n \tdigits--;\n \tif (digits==0) break;\t   /* [also protects *inu below] */\n@@ -750,12 +749,12 @@ void decDigitsFromDPD(decNumber *dn, const uInt *sour, Int declets) {\n   Int\tn;\t\t\t   /* counter */\n   Unit\t*uout=dn->lsu;\t\t   /* -> current output unit */\n   Unit\t*last=uout;\t\t   /* will be unit containing msd */\n-  const uInt *uin=sour;\t\t   /* -> current input uInt */\n-  uInt\tuoff=0;\t\t\t   /* -> current input offset [from right] */\n+  const uInt *uin=sour; \t   /* -> current input uInt */\n+  uInt\tuoff=0; \t\t   /* -> current input offset [from right] */\n \n   #if DECDPUN!=3\n   uInt\tbcd;\t\t\t   /* BCD result */\n-  uInt\tnibble;\t\t\t   /* work */\n+  uInt\tnibble; \t\t   /* work */\n   Unit\tout=0;\t\t\t   /* accumulator */\n   Int\tcut=0;\t\t\t   /* power of ten in current unit */\n   #endif\n@@ -772,7 +771,7 @@ void decDigitsFromDPD(decNumber *dn, const uInt *sour, Int declets) {\n       uoff-=32;\n       dpd|=*uin<<(10-uoff);\t   /* get waiting bits */\n       }\n-    dpd&=0x3ff;\t\t\t   /* clear uninteresting bits */\n+    dpd&=0x3ff; \t\t   /* clear uninteresting bits */\n \n   #if DECDPUN==3\n     if (dpd==0) *uout=0;\n@@ -822,9 +821,9 @@ void decDigitsFromDPD(decNumber *dn, const uInt *sour, Int declets) {\n     cut++;\n     if (cut==DECDPUN) {*uout=out; if (out) {last=uout; out=0;} uout++; cut=0;}\n     } /* n */\n-  if (cut!=0) {\t\t\t\t/* some more left over */\n+  if (cut!=0) { \t\t\t/* some more left over */\n     *uout=out;\t\t\t\t/* write out final unit */\n-    if (out) last=uout;\t\t\t/* and note if non-zero */\n+    if (out) last=uout; \t\t/* and note if non-zero */\n     }\n   #endif\n \n@@ -834,14 +833,14 @@ void decDigitsFromDPD(decNumber *dn, const uInt *sour, Int declets) {\n   dn->digits=(last-dn->lsu)*DECDPUN+1;\t/* floor of digits, plus */\n \t\t\t\t\t/* must be at least 1 digit */\n   #if DECDPUN>1\n-  if (*last<10) return;\t\t\t/* common odd digit or 0 */\n-  dn->digits++;\t\t\t\t/* must be 2 at least */\n+  if (*last<10) return; \t\t/* common odd digit or 0 */\n+  dn->digits++; \t\t\t/* must be 2 at least */\n   #if DECDPUN>2\n   if (*last<100) return;\t\t/* 10-99 */\n-  dn->digits++;\t\t\t\t/* must be 3 at least */\n+  dn->digits++; \t\t\t/* must be 3 at least */\n   #if DECDPUN>3\n   if (*last<1000) return;\t\t/* 100-999 */\n-  dn->digits++;\t\t\t\t/* must be 4 at least */\n+  dn->digits++; \t\t\t/* must be 4 at least */\n   #if DECDPUN>4\n   for (pow=&DECPOWERS[4]; *last>=*pow; pow++) dn->digits++;\n   #endif"}, {"sha": "95ae15f2b0f8563eabb28760285a3bf00f9454f9", "filename": "libdecnumber/dpd/decimal64.h", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f988ec96d922819a4948c1ed96c6dc1b79a7ad22/libdecnumber%2Fdpd%2Fdecimal64.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f988ec96d922819a4948c1ed96c6dc1b79a7ad22/libdecnumber%2Fdpd%2Fdecimal64.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libdecnumber%2Fdpd%2Fdecimal64.h?ref=f988ec96d922819a4948c1ed96c6dc1b79a7ad22", "patch": "@@ -35,7 +35,7 @@\n #if !defined(DECIMAL64)\n   #define DECIMAL64\n   #define DEC64NAME\t\"decimal64\"\t\t      /* Short name   */\n-  #define DEC64FULLNAME \"Decimal 64-bit Number\"\t      /* Verbose name */\n+  #define DEC64FULLNAME \"Decimal 64-bit Number\"       /* Verbose name */\n   #define DEC64AUTHOR\t\"Mike Cowlishaw\"\t      /* Who to blame */\n \n \n@@ -47,7 +47,7 @@\n   #define DECIMAL64_Bias   398\t\t/* bias for the exponent      */\n   #define DECIMAL64_String 24\t\t/* maximum string length, +1  */\n   #define DECIMAL64_EconL  8\t\t/* exp. continuation length   */\n-  /* highest biased exponent (Elimit-1)\t\t\t\t      */\n+  /* highest biased exponent (Elimit-1) \t\t\t      */\n   #define DECIMAL64_Ehigh  (DECIMAL64_Emax+DECIMAL64_Bias-DECIMAL64_Pmax+1)\n \n   /* check enough digits, if pre-defined\t\t\t      */\n@@ -73,18 +73,18 @@\n   /* special values [top byte excluding sign bit; last two bits are   */\n   /* don't-care for Infinity on input, last bit don't-care for NaN]   */\n   #if !defined(DECIMAL_NaN)\n-    #define DECIMAL_NaN\t    0x7c\t/* 0 11111 00 NaN\t      */\n+    #define DECIMAL_NaN     0x7c\t/* 0 11111 00 NaN\t      */\n     #define DECIMAL_sNaN    0x7e\t/* 0 11111 10 sNaN\t      */\n-    #define DECIMAL_Inf\t    0x78\t/* 0 11110 00 Infinity\t      */\n+    #define DECIMAL_Inf     0x78\t/* 0 11110 00 Infinity\t      */\n   #endif\n \n   /* ---------------------------------------------------------------- */\n   /* Routines\t\t\t\t\t\t\t      */\n   /* ---------------------------------------------------------------- */\n \n-  #include \"decimal64Symbols.h\"\n+#include \"decimal64Symbols.h\"\n \n-  /* String conversions\t\t\t\t\t\t      */\n+  /* String conversions \t\t\t\t\t      */\n   decimal64 * decimal64FromString(decimal64 *, const char *, decContext *);\n   char * decimal64ToString(const decimal64 *, char *);\n   char * decimal64ToEngString(const decimal64 *, char *);\n@@ -94,7 +94,7 @@\n \t\t\t\t  decContext *);\n   decNumber * decimal64ToNumber(const decimal64 *, decNumber *);\n \n-  /* Format-dependent utilities\t\t\t\t\t      */\n+  /* Format-dependent utilities \t\t\t\t      */\n   uint32_t    decimal64IsCanonical(const decimal64 *);\n   decimal64 * decimal64Canonical(decimal64 *, const decimal64 *);\n "}]}