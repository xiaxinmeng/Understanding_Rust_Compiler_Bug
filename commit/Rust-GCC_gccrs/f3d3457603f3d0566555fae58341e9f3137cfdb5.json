{"sha": "f3d3457603f3d0566555fae58341e9f3137cfdb5", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjNkMzQ1NzYwM2YzZDA1NjY1NTVmYWU1ODM0MWU5ZjMxMzdjZmRiNQ==", "commit": {"author": {"name": "Eric Botcazou", "email": "ebotcazou@adacore.com", "date": "2011-07-24T12:45:44Z"}, "committer": {"name": "Eric Botcazou", "email": "ebotcazou@gcc.gnu.org", "date": "2011-07-24T12:45:44Z"}, "message": "gigi.h (build_function_stub): Remove.\n\n\t* gcc-interface/gigi.h (build_function_stub): Remove.\n\t(build_return_expr): Likewise.\n\t(convert_vms_descriptor): Declare.\n\t* gcc-interface/utils.c (convert_vms_descriptor): Make global.\n\t(build_function_stub): Move to...\n\t* gcc-interface/utils2.c (build_return_expr): Move to...\n\t* gcc-interface/trans.c (build_function_stub): ...here.\n\t(build_return_expr): ...here.\n\t(Subprogram_Body_to_gnu): Add local variable for language_function.\n\tDisconnect the parameter attributes cache, if any, once done with it.\n\tCall end_subprog_body only after setting the end_locus.\n\tBuild the stub associated with the function, if any, at the very end.\n\t(gnat_to_gnu) <N_Return_Statement>: Remove couple of useless local\n\tvariables and streamline control flow.\n\nFrom-SVN: r176712", "tree": {"sha": "e8f8094e0aad34848de41c2150299cbb54051171", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e8f8094e0aad34848de41c2150299cbb54051171"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f3d3457603f3d0566555fae58341e9f3137cfdb5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f3d3457603f3d0566555fae58341e9f3137cfdb5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f3d3457603f3d0566555fae58341e9f3137cfdb5", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f3d3457603f3d0566555fae58341e9f3137cfdb5/comments", "author": null, "committer": null, "parents": [{"sha": "40ecdf413f8cb8709da07361200bd75f651e6fc5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/40ecdf413f8cb8709da07361200bd75f651e6fc5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/40ecdf413f8cb8709da07361200bd75f651e6fc5"}], "stats": {"total": 300, "additions": 160, "deletions": 140}, "files": [{"sha": "eeca1f37ed5c46d0a5d8ecded4d2026c4482f03e", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f3d3457603f3d0566555fae58341e9f3137cfdb5/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f3d3457603f3d0566555fae58341e9f3137cfdb5/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=f3d3457603f3d0566555fae58341e9f3137cfdb5", "patch": "@@ -1,3 +1,20 @@\n+2011-07-24  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\t* gcc-interface/gigi.h (build_function_stub): Remove.\n+\t(build_return_expr): Likewise.\n+\t(convert_vms_descriptor): Declare.\n+\t* gcc-interface/utils.c (convert_vms_descriptor): Make global.\n+\t(build_function_stub): Move to...\n+\t* gcc-interface/utils2.c (build_return_expr): Move to...\n+\t* gcc-interface/trans.c (build_function_stub): ...here.\n+\t(build_return_expr): ...here.\n+\t(Subprogram_Body_to_gnu): Add local variable for language_function.\n+\tDisconnect the parameter attributes cache, if any, once done with it.\n+\tCall end_subprog_body only after setting the end_locus.\n+\tBuild the stub associated with the function, if any, at the very end.\n+\t(gnat_to_gnu) <N_Return_Statement>: Remove couple of useless local\n+\tvariables and streamline control flow.\n+\n 2011-07-23  Arnaud Charlet  <charlet@adacore.com>\n \n \tPR ada/49819"}, {"sha": "e8a725979e806089566b661f3af2c64389ad063d", "filename": "gcc/ada/gcc-interface/gigi.h", "status": "modified", "additions": 9, "deletions": 8, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f3d3457603f3d0566555fae58341e9f3137cfdb5/gcc%2Fada%2Fgcc-interface%2Fgigi.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f3d3457603f3d0566555fae58341e9f3137cfdb5/gcc%2Fada%2Fgcc-interface%2Fgigi.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Fgigi.h?ref=f3d3457603f3d0566555fae58341e9f3137cfdb5", "patch": "@@ -706,10 +706,6 @@ extern tree build_vms_descriptor (tree type, Mechanism_Type mech,\n extern tree build_vms_descriptor32 (tree type, Mechanism_Type mech,\n                                   Entity_Id gnat_entity);\n \n-/* Build a stub for the subprogram specified by the GCC tree GNU_SUBPROG\n-   and the GNAT node GNAT_SUBPROG.  */\n-extern void build_function_stub (tree gnu_subprog, Entity_Id gnat_subprog);\n-\n /* Build a type to be used to represent an aliased object whose nominal type\n    is an unconstrained array.  This consists of a RECORD_TYPE containing a\n    field of TEMPLATE_TYPE and a field of OBJECT_TYPE, which is an ARRAY_TYPE.\n@@ -812,13 +808,9 @@ extern tree build_cond_expr (tree result_type, tree condition_operand,\n                              tree true_operand, tree false_operand);\n \n /* Similar, but for COMPOUND_EXPR.  */\n-\n extern tree build_compound_expr (tree result_type, tree stmt_operand,\n \t\t\t\t tree expr_operand);\n \n-/* Similar, but for RETURN_EXPR.  */\n-extern tree build_return_expr (tree ret_obj, tree ret_val);\n-\n /* Build a CALL_EXPR to call FUNDECL with one argument, ARG.  Return\n    the CALL_EXPR.  */\n extern tree build_call_1_expr (tree fundecl, tree arg);\n@@ -893,6 +885,15 @@ extern tree build_allocator (tree type, tree init, tree result_type,\n extern tree fill_vms_descriptor (tree gnu_type, tree gnu_expr,\n                                  Node_Id gnat_actual);\n \n+/* Convert GNU_EXPR, a pointer to a VMS descriptor, to GNU_TYPE, a regular\n+   pointer or fat pointer type.  GNU_EXPR_ALT_TYPE is the alternate (32-bit)\n+   pointer type of GNU_EXPR.  BY_REF is true if the result is to be used by\n+   reference.  GNAT_SUBPROG is the subprogram to which the VMS descriptor is\n+   passed.  */\n+extern tree convert_vms_descriptor (tree gnu_type, tree gnu_expr,\n+\t\t\t\t    tree gnu_expr_alt_type, bool by_ref,\n+\t\t\t\t    Entity_Id gnat_subprog);\n+\n /* Indicate that we need to take the address of T and that it therefore\n    should not be allocated in a register.  Returns true if successful.  */\n extern bool gnat_mark_addressable (tree t);"}, {"sha": "b0b83b3383baf9ad29909b658f6ff2bffa3bebe0", "filename": "gcc/ada/gcc-interface/trans.c", "status": "modified", "additions": 133, "deletions": 31, "changes": 164, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f3d3457603f3d0566555fae58341e9f3137cfdb5/gcc%2Fada%2Fgcc-interface%2Ftrans.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f3d3457603f3d0566555fae58341e9f3137cfdb5/gcc%2Fada%2Fgcc-interface%2Ftrans.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Ftrans.c?ref=f3d3457603f3d0566555fae58341e9f3137cfdb5", "patch": "@@ -2428,6 +2428,107 @@ establish_gnat_vms_condition_handler (void)\n \n   add_stmt (establish_stmt);\n }\n+\n+/* Similar, but for RETURN_EXPR.  If RET_VAL is non-null, build a RETURN_EXPR\n+   around the assignment of RET_VAL to RET_OBJ.  Otherwise just build a bare\n+   RETURN_EXPR around RESULT_OBJ, which may be null in this case.  */\n+\n+static tree\n+build_return_expr (tree ret_obj, tree ret_val)\n+{\n+  tree result_expr;\n+\n+  if (ret_val)\n+    {\n+      /* The gimplifier explicitly enforces the following invariant:\n+\n+\t      RETURN_EXPR\n+\t\t  |\n+\t      MODIFY_EXPR\n+\t      /        \\\n+\t     /          \\\n+\t RET_OBJ        ...\n+\n+\t As a consequence, type consistency dictates that we use the type\n+\t of the RET_OBJ as the operation type.  */\n+      tree operation_type = TREE_TYPE (ret_obj);\n+\n+      /* Convert the right operand to the operation type.  Note that it's the\n+\t same transformation as in the MODIFY_EXPR case of build_binary_op,\n+\t with the assumption that the type cannot involve a placeholder.  */\n+      if (operation_type != TREE_TYPE (ret_val))\n+\tret_val = convert (operation_type, ret_val);\n+\n+      result_expr = build2 (MODIFY_EXPR, operation_type, ret_obj, ret_val);\n+    }\n+  else\n+    result_expr = ret_obj;\n+\n+  return build1 (RETURN_EXPR, void_type_node, result_expr);\n+}\n+\n+/* Build a stub for the subprogram specified by the GCC tree GNU_SUBPROG\n+   and the GNAT node GNAT_SUBPROG.  */\n+\n+static void\n+build_function_stub (tree gnu_subprog, Entity_Id gnat_subprog)\n+{\n+  tree gnu_subprog_type, gnu_subprog_addr, gnu_subprog_call;\n+  tree gnu_subprog_param, gnu_stub_param, gnu_param;\n+  tree gnu_stub_decl = DECL_FUNCTION_STUB (gnu_subprog);\n+  VEC(tree,gc) *gnu_param_vec = NULL;\n+\n+  gnu_subprog_type = TREE_TYPE (gnu_subprog);\n+\n+  /* Initialize the information structure for the function.  */\n+  allocate_struct_function (gnu_stub_decl, false);\n+  set_cfun (NULL);\n+\n+  begin_subprog_body (gnu_stub_decl);\n+\n+  start_stmt_group ();\n+  gnat_pushlevel ();\n+\n+  /* Loop over the parameters of the stub and translate any of them\n+     passed by descriptor into a by reference one.  */\n+  for (gnu_stub_param = DECL_ARGUMENTS (gnu_stub_decl),\n+       gnu_subprog_param = DECL_ARGUMENTS (gnu_subprog);\n+       gnu_stub_param;\n+       gnu_stub_param = TREE_CHAIN (gnu_stub_param),\n+       gnu_subprog_param = TREE_CHAIN (gnu_subprog_param))\n+    {\n+      if (DECL_BY_DESCRIPTOR_P (gnu_stub_param))\n+\t{\n+\t  gcc_assert (DECL_BY_REF_P (gnu_subprog_param));\n+\t  gnu_param\n+\t    = convert_vms_descriptor (TREE_TYPE (gnu_subprog_param),\n+\t\t\t\t      gnu_stub_param,\n+\t\t\t\t      DECL_PARM_ALT_TYPE (gnu_stub_param),\n+\t\t\t\t      DECL_BY_DOUBLE_REF_P (gnu_subprog_param),\n+\t\t\t\t      gnat_subprog);\n+\t}\n+      else\n+\tgnu_param = gnu_stub_param;\n+\n+      VEC_safe_push (tree, gc, gnu_param_vec, gnu_param);\n+    }\n+\n+  /* Invoke the internal subprogram.  */\n+  gnu_subprog_addr = build1 (ADDR_EXPR, build_pointer_type (gnu_subprog_type),\n+\t\t\t     gnu_subprog);\n+  gnu_subprog_call = build_call_vec (TREE_TYPE (gnu_subprog_type),\n+                                     gnu_subprog_addr, gnu_param_vec);\n+\n+  /* Propagate the return value, if any.  */\n+  if (VOID_TYPE_P (TREE_TYPE (gnu_subprog_type)))\n+    add_stmt (gnu_subprog_call);\n+  else\n+    add_stmt (build_return_expr (DECL_RESULT (gnu_stub_decl),\n+\t\t\t\t gnu_subprog_call));\n+\n+  gnat_poplevel ();\n+  end_subprog_body (end_stmt_group ());\n+}\n \f\n /* Subroutine of gnat_to_gnu to process gnat_node, an N_Subprogram_Body.  We\n    don't return anything.  */\n@@ -2455,6 +2556,7 @@ Subprogram_Body_to_gnu (Node_Id gnat_node)\n   /* The entry in the CI_CO_LIST that represents a function return, if any.  */\n   tree gnu_return_var_elmt = NULL_TREE;\n   tree gnu_result;\n+  struct language_function *gnu_subprog_language;\n   VEC(parm_attr,gc) *cache;\n \n   /* If this is a generic object or if it has been eliminated,\n@@ -2496,8 +2598,8 @@ Subprogram_Body_to_gnu (Node_Id gnat_node)\n \n   /* Initialize the information structure for the function.  */\n   allocate_struct_function (gnu_subprog_decl, false);\n-  DECL_STRUCT_FUNCTION (gnu_subprog_decl)->language\n-    = ggc_alloc_cleared_language_function ();\n+  gnu_subprog_language = ggc_alloc_cleared_language_function ();\n+  DECL_STRUCT_FUNCTION (gnu_subprog_decl)->language = gnu_subprog_language;\n   set_cfun (NULL);\n \n   begin_subprog_body (gnu_subprog_decl);\n@@ -2594,7 +2696,7 @@ Subprogram_Body_to_gnu (Node_Id gnat_node)\n   /* If we populated the parameter attributes cache, we need to make sure that\n      the cached expressions are evaluated on all the possible paths leading to\n      their uses.  So we force their evaluation on entry of the function.  */\n-  cache = DECL_STRUCT_FUNCTION (gnu_subprog_decl)->language->parm_attr_cache;\n+  cache = gnu_subprog_language->parm_attr_cache;\n   if (cache)\n     {\n       struct parm_attr_d *pa;\n@@ -2614,6 +2716,8 @@ Subprogram_Body_to_gnu (Node_Id gnat_node)\n \n       add_stmt (gnu_result);\n       gnu_result = end_stmt_group ();\n+\n+      gnu_subprog_language->parm_attr_cache = NULL;\n     }\n \n   /* If we are dealing with a return from an Ada procedure with parameters\n@@ -2650,14 +2754,14 @@ Subprogram_Body_to_gnu (Node_Id gnat_node)\n \n   VEC_pop (tree, gnu_return_label_stack);\n \n-  end_subprog_body (gnu_result);\n-\n   /* Attempt setting the end_locus of our GCC body tree, typically a\n      BIND_EXPR or STATEMENT_LIST, then the end_locus of our GCC subprogram\n      declaration tree.  */\n   set_end_locus_from_node (gnu_result, gnat_node);\n   set_end_locus_from_node (gnu_subprog_decl, gnat_node);\n \n+  end_subprog_body (gnu_result);\n+\n   /* Finally annotate the parameters and disconnect the trees for parameters\n      that we have turned into variables since they are now unusable.  */\n   for (gnat_param = First_Formal_With_Extras (gnat_subprog_id);\n@@ -2675,12 +2779,13 @@ Subprogram_Body_to_gnu (Node_Id gnat_node)\n \tsave_gnu_tree (gnat_param, NULL_TREE, false);\n     }\n \n-  if (DECL_FUNCTION_STUB (gnu_subprog_decl))\n-    build_function_stub (gnu_subprog_decl, gnat_subprog_id);\n-\n   if (gnu_return_var_elmt)\n     TREE_VALUE (gnu_return_var_elmt) = void_type_node;\n \n+  /* If there is a stub associated with the function, build it now.  */\n+  if (DECL_FUNCTION_STUB (gnu_subprog_decl))\n+    build_function_stub (gnu_subprog_decl, gnat_subprog_id);\n+\n   mark_out_of_scope (Defining_Unit_Name (Specification (gnat_node)));\n }\n \f\n@@ -5085,23 +5190,22 @@ gnat_to_gnu (Node_Id gnat_node)\n \n     case N_Return_Statement:\n       {\n-\ttree gnu_ret_val, gnu_ret_obj;\n+\ttree gnu_ret_obj, gnu_ret_val;\n \n \t/* If the subprogram is a function, we must return the expression.  */\n \tif (Present (Expression (gnat_node)))\n \t  {\n \t    tree gnu_subprog_type = TREE_TYPE (current_function_decl);\n-\t    tree gnu_ret_type = TREE_TYPE (gnu_subprog_type);\n-\t    tree gnu_result_decl = DECL_RESULT (current_function_decl);\n-\t    gnu_ret_val = gnat_to_gnu (Expression (gnat_node));\n \n \t    /* If this function has copy-in/copy-out parameters, get the real\n-\t       variable and type for the return.  See Subprogram_to_gnu.  */\n+\t       object for the return.  See Subprogram_to_gnu.  */\n \t    if (TYPE_CI_CO_LIST (gnu_subprog_type))\n-\t      {\n-\t\tgnu_result_decl = VEC_last (tree, gnu_return_var_stack);\n-\t\tgnu_ret_type = TREE_TYPE (gnu_result_decl);\n-\t      }\n+\t      gnu_ret_obj = VEC_last (tree, gnu_return_var_stack);\n+\t    else\n+\t      gnu_ret_obj = DECL_RESULT (current_function_decl);\n+\n+\t    /* Get the GCC tree for the expression to be returned.  */\n+\t    gnu_ret_val = gnat_to_gnu (Expression (gnat_node));\n \n \t    /* Do not remove the padding from GNU_RET_VAL if the inner type is\n \t       self-referential since we want to allocate the fixed size.  */\n@@ -5112,7 +5216,7 @@ gnat_to_gnu (Node_Id gnat_node)\n \t\t   (TYPE_SIZE (TREE_TYPE (gnu_ret_val))))\n \t      gnu_ret_val = TREE_OPERAND (gnu_ret_val, 0);\n \n-\t    /* If the subprogram returns by direct reference, return a pointer\n+\t    /* If the function returns by direct reference, return a pointer\n \t       to the return value.  */\n \t    if (TYPE_RETURN_BY_DIRECT_REF_P (gnu_subprog_type)\n \t\t|| By_Ref (gnat_node))\n@@ -5124,37 +5228,33 @@ gnat_to_gnu (Node_Id gnat_node)\n \t      {\n \t\tgnu_ret_val = maybe_unconstrained_array (gnu_ret_val);\n \t\tgnu_ret_val = build_allocator (TREE_TYPE (gnu_ret_val),\n-\t\t\t\t\t       gnu_ret_val, gnu_ret_type,\n+\t\t\t\t\t       gnu_ret_val,\n+\t\t\t\t\t       TREE_TYPE (gnu_ret_obj),\n \t\t\t\t\t       Procedure_To_Call (gnat_node),\n \t\t\t\t\t       Storage_Pool (gnat_node),\n \t\t\t\t\t       gnat_node, false);\n \t      }\n \n-\t    /* If the subprogram returns by invisible reference, dereference\n+\t    /* If the function returns by invisible reference, dereference\n \t       the pointer it is passed using the type of the return value\n \t       and build the copy operation manually.  This ensures that we\n \t       don't copy too much data, for example if the return type is\n \t       unconstrained with a maximum size.  */\n \t    if (TREE_ADDRESSABLE (gnu_subprog_type))\n \t      {\n-\t\tgnu_ret_obj\n+\t\ttree gnu_ret_deref\n \t\t  = build_unary_op (INDIRECT_REF, TREE_TYPE (gnu_ret_val),\n-\t\t\t\t    gnu_result_decl);\n+\t\t\t\t    gnu_ret_obj);\n \t\tgnu_result = build_binary_op (MODIFY_EXPR, NULL_TREE,\n-\t\t\t\t\t      gnu_ret_obj, gnu_ret_val);\n+\t\t\t\t\t      gnu_ret_deref, gnu_ret_val);\n \t\tadd_stmt_with_node (gnu_result, gnat_node);\n \t\tgnu_ret_val = NULL_TREE;\n-\t\tgnu_ret_obj = gnu_result_decl;\n \t      }\n-\n-\t    /* Otherwise, build a regular return.  */\n-\t    else\n-\t      gnu_ret_obj = gnu_result_decl;\n \t  }\n \telse\n \t  {\n-\t    gnu_ret_val = NULL_TREE;\n \t    gnu_ret_obj = NULL_TREE;\n+\t    gnu_ret_val = NULL_TREE;\n \t  }\n \n \t/* If we have a return label defined, convert this into a branch to\n@@ -5167,13 +5267,15 @@ gnat_to_gnu (Node_Id gnat_node)\n \n \t    gnu_result = build1 (GOTO_EXPR, void_type_node,\n \t\t\t\t VEC_last (tree, gnu_return_label_stack));\n+\n \t    /* When not optimizing, make sure the return is preserved.  */\n \t    if (!optimize && Comes_From_Source (gnat_node))\n \t      DECL_ARTIFICIAL (VEC_last (tree, gnu_return_label_stack)) = 0;\n-\t    break;\n \t  }\n \n-\tgnu_result = build_return_expr (gnu_ret_obj, gnu_ret_val);\n+\t/* Otherwise, build a regular return.  */\n+\telse\n+\t  gnu_result = build_return_expr (gnu_ret_obj, gnu_ret_val);\n       }\n       break;\n "}, {"sha": "1ea34b1ed7c53ec98d4a5a16e07e6a860aa5592d", "filename": "gcc/ada/gcc-interface/utils.c", "status": "modified", "additions": 1, "deletions": 64, "changes": 65, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f3d3457603f3d0566555fae58341e9f3137cfdb5/gcc%2Fada%2Fgcc-interface%2Futils.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f3d3457603f3d0566555fae58341e9f3137cfdb5/gcc%2Fada%2Fgcc-interface%2Futils.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Futils.c?ref=f3d3457603f3d0566555fae58341e9f3137cfdb5", "patch": "@@ -3295,7 +3295,7 @@ convert_vms_descriptor32 (tree gnu_type, tree gnu_expr, Entity_Id gnat_subprog)\n    reference.  GNAT_SUBPROG is the subprogram to which the VMS descriptor is\n    passed.  */\n \n-static tree\n+tree\n convert_vms_descriptor (tree gnu_type, tree gnu_expr, tree gnu_expr_alt_type,\n \t\t\tbool by_ref, Entity_Id gnat_subprog)\n {\n@@ -3344,69 +3344,6 @@ convert_vms_descriptor (tree gnu_type, tree gnu_expr, tree gnu_expr_alt_type,\n \n   return build3 (COND_EXPR, gnu_type, is64bit, gnu_expr64, gnu_expr32);\n }\n-\n-/* Build a stub for the subprogram specified by the GCC tree GNU_SUBPROG\n-   and the GNAT node GNAT_SUBPROG.  */\n-\n-void\n-build_function_stub (tree gnu_subprog, Entity_Id gnat_subprog)\n-{\n-  tree gnu_subprog_type, gnu_subprog_addr, gnu_subprog_call;\n-  tree gnu_subprog_param, gnu_stub_param, gnu_param;\n-  tree gnu_stub_decl = DECL_FUNCTION_STUB (gnu_subprog);\n-  VEC(tree,gc) *gnu_param_vec = NULL;\n-\n-  gnu_subprog_type = TREE_TYPE (gnu_subprog);\n-\n-  /* Initialize the information structure for the function.  */\n-  allocate_struct_function (gnu_stub_decl, false);\n-  set_cfun (NULL);\n-\n-  begin_subprog_body (gnu_stub_decl);\n-\n-  start_stmt_group ();\n-  gnat_pushlevel ();\n-\n-  /* Loop over the parameters of the stub and translate any of them\n-     passed by descriptor into a by reference one.  */\n-  for (gnu_stub_param = DECL_ARGUMENTS (gnu_stub_decl),\n-       gnu_subprog_param = DECL_ARGUMENTS (gnu_subprog);\n-       gnu_stub_param;\n-       gnu_stub_param = TREE_CHAIN (gnu_stub_param),\n-       gnu_subprog_param = TREE_CHAIN (gnu_subprog_param))\n-    {\n-      if (DECL_BY_DESCRIPTOR_P (gnu_stub_param))\n-\t{\n-\t  gcc_assert (DECL_BY_REF_P (gnu_subprog_param));\n-\t  gnu_param\n-\t    = convert_vms_descriptor (TREE_TYPE (gnu_subprog_param),\n-\t\t\t\t      gnu_stub_param,\n-\t\t\t\t      DECL_PARM_ALT_TYPE (gnu_stub_param),\n-\t\t\t\t      DECL_BY_DOUBLE_REF_P (gnu_subprog_param),\n-\t\t\t\t      gnat_subprog);\n-\t}\n-      else\n-\tgnu_param = gnu_stub_param;\n-\n-      VEC_safe_push (tree, gc, gnu_param_vec, gnu_param);\n-    }\n-\n-  /* Invoke the internal subprogram.  */\n-  gnu_subprog_addr = build1 (ADDR_EXPR, build_pointer_type (gnu_subprog_type),\n-\t\t\t     gnu_subprog);\n-  gnu_subprog_call = build_call_vec (TREE_TYPE (gnu_subprog_type),\n-                                     gnu_subprog_addr, gnu_param_vec);\n-\n-  /* Propagate the return value, if any.  */\n-  if (VOID_TYPE_P (TREE_TYPE (gnu_subprog_type)))\n-    add_stmt (gnu_subprog_call);\n-  else\n-    add_stmt (build_return_expr (DECL_RESULT (gnu_stub_decl),\n-\t\t\t\t gnu_subprog_call));\n-\n-  gnat_poplevel ();\n-  end_subprog_body (end_stmt_group ());\n-}\n \f\n /* Build a type to be used to represent an aliased object whose nominal type\n    is an unconstrained array.  This consists of a RECORD_TYPE containing a"}, {"sha": "db894298d66bfaf805bffd4bf1c5cf3ce27d2383", "filename": "gcc/ada/gcc-interface/utils2.c", "status": "modified", "additions": 0, "deletions": 37, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f3d3457603f3d0566555fae58341e9f3137cfdb5/gcc%2Fada%2Fgcc-interface%2Futils2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f3d3457603f3d0566555fae58341e9f3137cfdb5/gcc%2Fada%2Fgcc-interface%2Futils2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Futils2.c?ref=f3d3457603f3d0566555fae58341e9f3137cfdb5", "patch": "@@ -1407,43 +1407,6 @@ build_compound_expr (tree result_type, tree stmt_operand, tree expr_operand)\n \n   return result;\n }\n-/* Similar, but for RETURN_EXPR.  If RET_VAL is non-null, build a RETURN_EXPR\n-   around the assignment of RET_VAL to RET_OBJ.  Otherwise just build a bare\n-   RETURN_EXPR around RESULT_OBJ, which may be null in this case.  */\n-\n-tree\n-build_return_expr (tree ret_obj, tree ret_val)\n-{\n-  tree result_expr;\n-\n-  if (ret_val)\n-    {\n-      /* The gimplifier explicitly enforces the following invariant:\n-\n-\t      RETURN_EXPR\n-\t\t  |\n-\t      MODIFY_EXPR\n-\t      /        \\\n-\t     /          \\\n-\t RET_OBJ        ...\n-\n-\t As a consequence, type consistency dictates that we use the type\n-\t of the RET_OBJ as the operation type.  */\n-      tree operation_type = TREE_TYPE (ret_obj);\n-\n-      /* Convert the right operand to the operation type.  Note that it's the\n-\t same transformation as in the MODIFY_EXPR case of build_binary_op,\n-\t with the assumption that the type cannot involve a placeholder.  */\n-      if (operation_type != TREE_TYPE (ret_val))\n-\tret_val = convert (operation_type, ret_val);\n-\n-      result_expr = build2 (MODIFY_EXPR, operation_type, ret_obj, ret_val);\n-    }\n-  else\n-    result_expr = ret_obj;\n-\n-  return build1 (RETURN_EXPR, void_type_node, result_expr);\n-}\n \f\n /* Build a CALL_EXPR to call FUNDECL with one argument, ARG.  Return\n    the CALL_EXPR.  */"}]}