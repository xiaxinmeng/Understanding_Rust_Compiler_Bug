{"sha": "3f9b14ffa3cefe2c35111fa9f067dab4e92dcdc8", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6M2Y5YjE0ZmZhM2NlZmUyYzM1MTExZmE5ZjA2N2RhYjRlOTJkY2RjOA==", "commit": {"author": {"name": "Steven Bosscher", "email": "steven@gcc.gnu.org", "date": "2012-08-17T09:42:06Z"}, "committer": {"name": "Steven Bosscher", "email": "steven@gcc.gnu.org", "date": "2012-08-17T09:42:06Z"}, "message": "re PR middle-end/54146 (Very slow compile with attribute((flatten)))\n\n\tPR middle-end/54146\n\t* tree-ssa-loop-im.c (lim_bitmap_obstack): New bitmap_obstack.\n\t(memref_free): Don't free the bitmaps individually here.\n\t(mem_ref_alloc): Allocate the bitmaps on the new bitmap obstack.\n\t(analyze_memory_references): Likewise.\n\t(tree_ssa_lim_initialize): Initialize the new bitmap obstack.\n\t(tree_ssa_lim_finalize): Release it.\n\t* dse.c (dse_bitmap_obstack): New bitmap obstack.\n\t(dse_obstack): New obstack.\n\t(get_group_info): Allocate the bitmaps on the new bitmap obstack.\n\t(dse_step0): Allocate the scratch bitmap on reg_obstack.  Initialize\n\tthe new bitmap obstack and normal obstack.  Use XNEWVEC for bb_table.\n\t(record_store): Allocate regs_set on reg_obstack.\n\t(dse_step1): Allocate regs_live on reg_obstack.\n\t(dse_step2_init): Allocate offset_map_n and offset_map_p on the new\n\tobstack.\n\t(dse_step3_scan): Allocate bitmaps on the new bitmap obstack.\n\t(dse_step3): Likewise.\n\t(dse_confluence_0): Likewise.\n\t(dse_confluence_n): Likewise.\n\t(dse_transfer_function): Likewise.\n\t(dse_step7): Destroy the new obstacks, and everything allocated on\n\tthem, in one big sweep.\n\t(rest_of_handle_dse): Update.\n\t* cfgexpand.c (stack_var_bitmap_obstack): New bitmap obstack.\n\t(add_stack_var_conflict): Allocate bitmaps on it.\n\t(add_scope_conflicts_1): Likewise.\n\t(add_scope_conflicts): Likewise.\n\t(update_alias_info_with_stack_vars): Likewise.\n\t(init_vars_expansion): Move TREE_USED fiddling expand_used_vars.\n\tInitialize the new bitmap obstack.\n\t(fini_vars_expansion): Release it.\n\t(estimated_stack_frame_size): Use init_vars_expansion to set things up\n\tand always clean up at the end.\n\t(expand_used_vars): Do the TREE_USED trickery here.  Always call\n\tfini_vars_expansion.\n\t* tree-ssa-live.h (struct tree_live_info_d): Make livein and liveout\n\tarrays of bitmap_head to avoid one indirection per bitmap access.\n\t(live_on_entry, live_on_exit, live_var_map, live_merge_and_clear,\n\tmake_live_on_entry): Update.\n\t* tree-ssa-live.c (partition_view_bitmap): Don't double-free 'used'.\n\t(liveness_bitmap_obstack): New bitmap obstack.\n\t(remove_unused_locals): Use it to allocate all bitmaps on.  Update\n\tfor livein/liveout changes in tree-ssa-live.h.\n\t(delete_tree_live_info): Release the bitmap obstack.\n\t(loe_visit_block, live_worklist, set_var_live_on_entry,\n\tcalculate_live_on_exit, dump_live_info): Update.\n\t(calculate_live_ranges): Initialize the bitmap.\n\t* tree-ssa-ter.c (ter_bitmap_obstack): New bitmap obstack.\n\t(new_temp_expr_table): Allocate bitmap on it.\n\t(make_dependent_on_partition, add_to_partition_kill_list,\n\tadd_dependence, process_replaceable): Likewise.\n\t(find_replaceable_exprs): Initialize and release the new obstack here.\n\t* df-problems.c (df_lr_add_problem): Allocate persistent bitmap\n\tfor out_of_date_transfer_functions on df_bitmap_obstack.\n\t(df_live_add_problem): Likewise.\n\t(df_chain_add_problem): Likewise.\n\t(df_word_lr_add_problem): Likewise.\n\nFrom-SVN: r190475", "tree": {"sha": "0ebbe8deabfc8b9cc126c002c0f1e91f0ac0ea98", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/0ebbe8deabfc8b9cc126c002c0f1e91f0ac0ea98"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3f9b14ffa3cefe2c35111fa9f067dab4e92dcdc8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3f9b14ffa3cefe2c35111fa9f067dab4e92dcdc8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3f9b14ffa3cefe2c35111fa9f067dab4e92dcdc8", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3f9b14ffa3cefe2c35111fa9f067dab4e92dcdc8/comments", "author": null, "committer": null, "parents": [{"sha": "a69b2a7d8260addd968fdff64bb3b706560cecd7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a69b2a7d8260addd968fdff64bb3b706560cecd7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a69b2a7d8260addd968fdff64bb3b706560cecd7"}], "stats": {"total": 379, "additions": 218, "deletions": 161}, "files": [{"sha": "bdabc9abd9b3c31c81f449018b5a8a3def281fa9", "filename": "gcc/ChangeLog", "status": "modified", "additions": 61, "deletions": 0, "changes": 61, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3f9b14ffa3cefe2c35111fa9f067dab4e92dcdc8/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3f9b14ffa3cefe2c35111fa9f067dab4e92dcdc8/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=3f9b14ffa3cefe2c35111fa9f067dab4e92dcdc8", "patch": "@@ -1,3 +1,64 @@\n+2012-08-17  Steven Bosscher  <steven@gcc.gnu.org>\n+\n+\tPR middle-end/54146\n+\t* tree-ssa-loop-im.c (lim_bitmap_obstack): New bitmap_obstack.\n+\t(memref_free): Don't free the bitmaps individually here.\n+\t(mem_ref_alloc): Allocate the bitmaps on the new bitmap obstack.\n+\t(analyze_memory_references): Likewise.\n+\t(tree_ssa_lim_initialize): Initialize the new bitmap obstack.\n+\t(tree_ssa_lim_finalize): Release it.\n+\t* dse.c (dse_bitmap_obstack): New bitmap obstack.\n+\t(dse_obstack): New obstack.\n+\t(get_group_info): Allocate the bitmaps on the new bitmap obstack.\n+\t(dse_step0): Allocate the scratch bitmap on reg_obstack.  Initialize\n+\tthe new bitmap obstack and normal obstack.  Use XNEWVEC for bb_table.\n+\t(record_store): Allocate regs_set on reg_obstack.\n+\t(dse_step1): Allocate regs_live on reg_obstack.\n+\t(dse_step2_init): Allocate offset_map_n and offset_map_p on the new\n+\tobstack.\n+\t(dse_step3_scan): Allocate bitmaps on the new bitmap obstack.\n+\t(dse_step3): Likewise.\n+\t(dse_confluence_0): Likewise.\n+\t(dse_confluence_n): Likewise.\n+\t(dse_transfer_function): Likewise.\n+\t(dse_step7): Destroy the new obstacks, and everything allocated on\n+\tthem, in one big sweep.\n+\t(rest_of_handle_dse): Update.\n+\t* cfgexpand.c (stack_var_bitmap_obstack): New bitmap obstack.\n+\t(add_stack_var_conflict): Allocate bitmaps on it.\n+\t(add_scope_conflicts_1): Likewise.\n+\t(add_scope_conflicts): Likewise.\n+\t(update_alias_info_with_stack_vars): Likewise.\n+\t(init_vars_expansion): Move TREE_USED fiddling expand_used_vars.\n+\tInitialize the new bitmap obstack.\n+\t(fini_vars_expansion): Release it.\n+\t(estimated_stack_frame_size): Use init_vars_expansion to set things up\n+\tand always clean up at the end.\n+\t(expand_used_vars): Do the TREE_USED trickery here.  Always call\n+\tfini_vars_expansion.\n+\t* tree-ssa-live.h (struct tree_live_info_d): Make livein and liveout\n+\tarrays of bitmap_head to avoid one indirection per bitmap access.\n+\t(live_on_entry, live_on_exit, live_var_map, live_merge_and_clear,\n+\tmake_live_on_entry): Update.\n+\t* tree-ssa-live.c (partition_view_bitmap): Don't double-free 'used'.\n+\t(liveness_bitmap_obstack): New bitmap obstack.\n+\t(remove_unused_locals): Use it to allocate all bitmaps on.  Update\n+\tfor livein/liveout changes in tree-ssa-live.h.\n+\t(delete_tree_live_info): Release the bitmap obstack.\n+\t(loe_visit_block, live_worklist, set_var_live_on_entry,\n+\tcalculate_live_on_exit, dump_live_info): Update.\n+\t(calculate_live_ranges): Initialize the bitmap.\n+\t* tree-ssa-ter.c (ter_bitmap_obstack): New bitmap obstack.\n+\t(new_temp_expr_table): Allocate bitmap on it.\n+\t(make_dependent_on_partition, add_to_partition_kill_list,\n+\tadd_dependence, process_replaceable): Likewise.\n+\t(find_replaceable_exprs): Initialize and release the new obstack here.\n+\t* df-problems.c (df_lr_add_problem): Allocate persistent bitmap\n+\tfor out_of_date_transfer_functions on df_bitmap_obstack.\n+\t(df_live_add_problem): Likewise.\n+\t(df_chain_add_problem): Likewise.\n+\t(df_word_lr_add_problem): Likewise.\n+\n 2012-08-17  Nick Clifton  <nickc@redhat.com>\n \n \t* config/mep/t-mep (mep-pragma.o): Use $(COMPILER) to compile"}, {"sha": "91457eb24550926eb6a2c17bf618c7ebc91dc4a8", "filename": "gcc/cfgexpand.c", "status": "modified", "additions": 30, "deletions": 20, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3f9b14ffa3cefe2c35111fa9f067dab4e92dcdc8/gcc%2Fcfgexpand.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3f9b14ffa3cefe2c35111fa9f067dab4e92dcdc8/gcc%2Fcfgexpand.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgexpand.c?ref=3f9b14ffa3cefe2c35111fa9f067dab4e92dcdc8", "patch": "@@ -185,6 +185,10 @@ static size_t stack_vars_alloc;\n static size_t stack_vars_num;\n static struct pointer_map_t *decl_to_stack_part;\n \n+/* Conflict bitmaps go on this obstack.  This allows us to destroy\n+   all of them in one big sweep.  */\n+static bitmap_obstack stack_var_bitmap_obstack;\n+\n /* An array of indices such that stack_vars[stack_vars_sorted[i]].size\n    is non-decreasing.  */\n static size_t *stack_vars_sorted;\n@@ -299,9 +303,9 @@ add_stack_var_conflict (size_t x, size_t y)\n   struct stack_var *a = &stack_vars[x];\n   struct stack_var *b = &stack_vars[y];\n   if (!a->conflicts)\n-    a->conflicts = BITMAP_ALLOC (NULL);\n+    a->conflicts = BITMAP_ALLOC (&stack_var_bitmap_obstack);\n   if (!b->conflicts)\n-    b->conflicts = BITMAP_ALLOC (NULL);\n+    b->conflicts = BITMAP_ALLOC (&stack_var_bitmap_obstack);\n   bitmap_set_bit (a->conflicts, y);\n   bitmap_set_bit (b->conflicts, x);\n }\n@@ -431,7 +435,7 @@ add_scope_conflicts_1 (basic_block bb, bitmap work, bool for_conflict)\n \t\t{\n \t\t  struct stack_var *a = &stack_vars[i];\n \t\t  if (!a->conflicts)\n-\t\t    a->conflicts = BITMAP_ALLOC (NULL);\n+\t\t    a->conflicts = BITMAP_ALLOC (&stack_var_bitmap_obstack);\n \t\t  bitmap_ior_into (a->conflicts, work);\n \t\t}\n \t      visit = visit_conflict;\n@@ -464,7 +468,7 @@ add_scope_conflicts (void)\n      We then do a mostly classical bitmap liveness algorithm.  */\n \n   FOR_ALL_BB (bb)\n-    bb->aux = BITMAP_ALLOC (NULL);\n+    bb->aux = BITMAP_ALLOC (&stack_var_bitmap_obstack);\n \n   rpo = XNEWVEC (int, last_basic_block);\n   n_bbs = pre_and_rev_post_order_compute (NULL, rpo, false);\n@@ -647,7 +651,7 @@ update_alias_info_with_stack_vars (void)\n     {\n       unsigned i;\n       struct pointer_set_t *visited = pointer_set_create ();\n-      bitmap temp = BITMAP_ALLOC (NULL);\n+      bitmap temp = BITMAP_ALLOC (&stack_var_bitmap_obstack);\n \n       for (i = 1; i < num_ssa_names; i++)\n \t{\n@@ -1378,14 +1382,11 @@ create_stack_guard (void)\n static void\n init_vars_expansion (void)\n {\n-  tree t;\n-  unsigned ix;\n-  /* Set TREE_USED on all variables in the local_decls.  */\n-  FOR_EACH_LOCAL_DECL (cfun, ix, t)\n-    TREE_USED (t) = 1;\n+  /* Conflict bitmaps, and a few related temporary bitmaps, go here.  */\n+  bitmap_obstack_initialize (&stack_var_bitmap_obstack);\n \n-  /* Clear TREE_USED on all variables associated with a block scope.  */\n-  clear_tree_used (DECL_INITIAL (current_function_decl));\n+  /* A map from decl to stack partition.  */\n+  decl_to_stack_part = pointer_map_create ();\n \n   /* Initialize local stack smashing state.  */\n   has_protected_decls = false;\n@@ -1396,11 +1397,11 @@ init_vars_expansion (void)\n static void\n fini_vars_expansion (void)\n {\n-  size_t i, n = stack_vars_num;\n-  for (i = 0; i < n; i++)\n-    BITMAP_FREE (stack_vars[i].conflicts);\n-  XDELETEVEC (stack_vars);\n-  XDELETEVEC (stack_vars_sorted);\n+  bitmap_obstack_release (&stack_var_bitmap_obstack);\n+  if (stack_vars)\n+    XDELETEVEC (stack_vars);\n+  if (stack_vars_sorted)\n+    XDELETEVEC (stack_vars_sorted);\n   stack_vars = NULL;\n   stack_vars_sorted = NULL;\n   stack_vars_alloc = stack_vars_num = 0;\n@@ -1428,6 +1429,8 @@ estimated_stack_frame_size (struct cgraph_node *node)\n   current_function_decl = node->symbol.decl;\n   push_cfun (fn);\n \n+  init_vars_expansion ();\n+\n   FOR_EACH_LOCAL_DECL (fn, i, var)\n     if (auto_var_in_fn_p (var, fn->decl))\n       size += expand_one_var (var, true, false);\n@@ -1439,8 +1442,9 @@ estimated_stack_frame_size (struct cgraph_node *node)\n       for (i = 0; i < stack_vars_num; ++i)\n \tstack_vars_sorted[i] = i;\n       size += account_stack_vars ();\n-      fini_vars_expansion ();\n     }\n+\n+  fini_vars_expansion ();\n   pop_cfun ();\n   current_function_decl = old_cur_fun_decl;\n   return size;\n@@ -1464,6 +1468,12 @@ expand_used_vars (void)\n     frame_phase = off ? align - off : 0;\n   }\n \n+  /* Set TREE_USED on all variables in the local_decls.  */\n+  FOR_EACH_LOCAL_DECL (cfun, i, var)\n+    TREE_USED (var) = 1;\n+  /* Clear TREE_USED on all variables associated with a block scope.  */\n+  clear_tree_used (DECL_INITIAL (current_function_decl));\n+\n   init_vars_expansion ();\n \n   ssa_name_decls = pointer_map_create ();\n@@ -1613,10 +1623,10 @@ expand_used_vars (void)\n \t}\n \n       expand_stack_vars (NULL);\n-\n-      fini_vars_expansion ();\n     }\n \n+  fini_vars_expansion ();\n+\n   /* If there were any artificial non-ignored vars without rtl\n      found earlier, see if deferred stack allocation hasn't assigned\n      rtl to them.  */"}, {"sha": "abeb118dd7ea26a8b41c82b1aa7d983a4e965448", "filename": "gcc/df-problems.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3f9b14ffa3cefe2c35111fa9f067dab4e92dcdc8/gcc%2Fdf-problems.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3f9b14ffa3cefe2c35111fa9f067dab4e92dcdc8/gcc%2Fdf-problems.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdf-problems.c?ref=3f9b14ffa3cefe2c35111fa9f067dab4e92dcdc8", "patch": "@@ -1228,7 +1228,7 @@ df_lr_add_problem (void)\n   df_add_problem (&problem_LR);\n   /* These will be initialized when df_scan_blocks processes each\n      block.  */\n-  df_lr->out_of_date_transfer_functions = BITMAP_ALLOC (NULL);\n+  df_lr->out_of_date_transfer_functions = BITMAP_ALLOC (&df_bitmap_obstack);\n }\n \n \n@@ -1757,7 +1757,7 @@ df_live_add_problem (void)\n   df_add_problem (&problem_LIVE);\n   /* These will be initialized when df_scan_blocks processes each\n      block.  */\n-  df_live->out_of_date_transfer_functions = BITMAP_ALLOC (NULL);\n+  df_live->out_of_date_transfer_functions = BITMAP_ALLOC (&df_bitmap_obstack);\n }\n \n \n@@ -2283,7 +2283,7 @@ df_chain_add_problem (unsigned int chain_flags)\n {\n   df_add_problem (&problem_CHAIN);\n   df_chain->local_flags = chain_flags;\n-  df_chain->out_of_date_transfer_functions = BITMAP_ALLOC (NULL);\n+  df_chain->out_of_date_transfer_functions = BITMAP_ALLOC (&df_bitmap_obstack);\n }\n \n #undef df_chain_problem_p\n@@ -2662,7 +2662,7 @@ df_word_lr_add_problem (void)\n   df_add_problem (&problem_WORD_LR);\n   /* These will be initialized when df_scan_blocks processes each\n      block.  */\n-  df_word_lr->out_of_date_transfer_functions = BITMAP_ALLOC (NULL);\n+  df_word_lr->out_of_date_transfer_functions = BITMAP_ALLOC (&df_bitmap_obstack);\n }\n \n "}, {"sha": "3375808b61d30ef7524f11548ad7b0262a0a7074", "filename": "gcc/dse.c", "status": "modified", "additions": 53, "deletions": 62, "changes": 115, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3f9b14ffa3cefe2c35111fa9f067dab4e92dcdc8/gcc%2Fdse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3f9b14ffa3cefe2c35111fa9f067dab4e92dcdc8/gcc%2Fdse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdse.c?ref=3f9b14ffa3cefe2c35111fa9f067dab4e92dcdc8", "patch": "@@ -200,8 +200,21 @@ along with GCC; see the file COPYING3.  If not see\n    that really have constant offsets this size.  */\n #define MAX_OFFSET (64 * 1024)\n \n-\n+/* Obstack for the DSE dataflow bitmaps.  We don't want to put these\n+   on the default obstack because these bitmaps can grow quite large\n+   (~2GB for the small (!) test case of PR54146) and we'll hold on to\n+   all that memory until the end of the compiler run.\n+   As a bonus, delete_tree_live_info can destroy all the bitmaps by just\n+   releasing the whole obstack.  */\n+static bitmap_obstack dse_bitmap_obstack;\n+\n+/* Obstack for other data.  As for above: Kinda nice to be able to\n+   throw it all away at the end in one big sweep.  */\n+static struct obstack dse_obstack;\n+\n+/* Scratch bitmap for cselib's cselib_expand_value_rtx.  */\n static bitmap scratch = NULL;\n+\n struct insn_info;\n \n /* This structure holds information about a candidate store.  */\n@@ -685,13 +698,13 @@ get_group_info (rtx base)\n \t    (group_info_t) pool_alloc (rtx_group_info_pool);\n \t  memset (gi, 0, sizeof (struct group_info));\n \t  gi->id = rtx_group_next_id++;\n-\t  gi->store1_n = BITMAP_ALLOC (NULL);\n-\t  gi->store1_p = BITMAP_ALLOC (NULL);\n-\t  gi->store2_n = BITMAP_ALLOC (NULL);\n-\t  gi->store2_p = BITMAP_ALLOC (NULL);\n-\t  gi->escaped_p = BITMAP_ALLOC (NULL);\n-\t  gi->escaped_n = BITMAP_ALLOC (NULL);\n-\t  gi->group_kill = BITMAP_ALLOC (NULL);\n+\t  gi->store1_n = BITMAP_ALLOC (&dse_bitmap_obstack);\n+\t  gi->store1_p = BITMAP_ALLOC (&dse_bitmap_obstack);\n+\t  gi->store2_n = BITMAP_ALLOC (&dse_bitmap_obstack);\n+\t  gi->store2_p = BITMAP_ALLOC (&dse_bitmap_obstack);\n+\t  gi->escaped_p = BITMAP_ALLOC (&dse_bitmap_obstack);\n+\t  gi->escaped_n = BITMAP_ALLOC (&dse_bitmap_obstack);\n+\t  gi->group_kill = BITMAP_ALLOC (&dse_bitmap_obstack);\n \t  gi->process_globally = false;\n \t  gi->offset_map_size_n = 0;\n \t  gi->offset_map_size_p = 0;\n@@ -709,13 +722,13 @@ get_group_info (rtx base)\n       gi->id = rtx_group_next_id++;\n       gi->base_mem = gen_rtx_MEM (BLKmode, base);\n       gi->canon_base_addr = canon_rtx (base);\n-      gi->store1_n = BITMAP_ALLOC (NULL);\n-      gi->store1_p = BITMAP_ALLOC (NULL);\n-      gi->store2_n = BITMAP_ALLOC (NULL);\n-      gi->store2_p = BITMAP_ALLOC (NULL);\n-      gi->escaped_p = BITMAP_ALLOC (NULL);\n-      gi->escaped_n = BITMAP_ALLOC (NULL);\n-      gi->group_kill = BITMAP_ALLOC (NULL);\n+      gi->store1_n = BITMAP_ALLOC (&dse_bitmap_obstack);\n+      gi->store1_p = BITMAP_ALLOC (&dse_bitmap_obstack);\n+      gi->store2_n = BITMAP_ALLOC (&dse_bitmap_obstack);\n+      gi->store2_p = BITMAP_ALLOC (&dse_bitmap_obstack);\n+      gi->escaped_p = BITMAP_ALLOC (&dse_bitmap_obstack);\n+      gi->escaped_n = BITMAP_ALLOC (&dse_bitmap_obstack);\n+      gi->group_kill = BITMAP_ALLOC (&dse_bitmap_obstack);\n       gi->process_globally = false;\n       gi->frame_related =\n \t(base == frame_pointer_rtx) || (base == hard_frame_pointer_rtx);\n@@ -739,8 +752,11 @@ dse_step0 (void)\n   globally_deleted = 0;\n   spill_deleted = 0;\n \n-  scratch = BITMAP_ALLOC (NULL);\n-  kill_on_calls = BITMAP_ALLOC (NULL);\n+  bitmap_obstack_initialize (&dse_bitmap_obstack);\n+  gcc_obstack_init (&dse_obstack);\n+\n+  scratch = BITMAP_ALLOC (&reg_obstack);\n+  kill_on_calls = BITMAP_ALLOC (&dse_bitmap_obstack);\n \n   rtx_store_info_pool\n     = create_alloc_pool (\"rtx_store_info_pool\",\n@@ -764,7 +780,7 @@ dse_step0 (void)\n   rtx_group_table = htab_create (11, invariant_group_base_hash,\n \t\t\t\t invariant_group_base_eq, NULL);\n \n-  bb_table = XCNEWVEC (bb_info_t, last_basic_block);\n+  bb_table = XNEWVEC (bb_info_t, last_basic_block);\n   rtx_group_next_id = 0;\n \n   stores_off_frame_dead_at_return = !cfun->stdarg;\n@@ -1694,7 +1710,7 @@ record_store (rtx body, bb_info_t bb_info)\n     {\n       store_info->is_large = true;\n       store_info->positions_needed.large.count = 0;\n-      store_info->positions_needed.large.bmap = BITMAP_ALLOC (NULL);\n+      store_info->positions_needed.large.bmap = BITMAP_ALLOC (&dse_bitmap_obstack);\n     }\n   else\n     {\n@@ -2020,7 +2036,7 @@ replace_read (store_info_t store_info, insn_info_t store_insn,\n \t live at this point.  For instance, this can happen if one of\n \t the insns sets the CC and the CC happened to be live at that\n \t point.  This does occasionally happen, see PR 37922.  */\n-      bitmap regs_set = BITMAP_ALLOC (NULL);\n+      bitmap regs_set = BITMAP_ALLOC (&reg_obstack);\n \n       for (this_insn = insns; this_insn != NULL_RTX; this_insn = NEXT_INSN (this_insn))\n \tnote_stores (PATTERN (this_insn), look_for_hardregs, regs_set);\n@@ -2718,7 +2734,7 @@ static void\n dse_step1 (void)\n {\n   basic_block bb;\n-  bitmap regs_live = BITMAP_ALLOC (NULL);\n+  bitmap regs_live = BITMAP_ALLOC (&reg_obstack);\n \n   cselib_init (0);\n   all_blocks = BITMAP_ALLOC (NULL);\n@@ -2906,9 +2922,11 @@ dse_step2_init (void)\n \t}\n \n       group->offset_map_size_n++;\n-      group->offset_map_n = XNEWVEC (int, group->offset_map_size_n);\n+      group->offset_map_n = XOBNEWVEC (&dse_obstack, int,\n+\t\t\t\t       group->offset_map_size_n);\n       group->offset_map_size_p++;\n-      group->offset_map_p = XNEWVEC (int, group->offset_map_size_p);\n+      group->offset_map_p = XOBNEWVEC (&dse_obstack, int,\n+\t\t\t\t       group->offset_map_size_p);\n       group->process_globally = false;\n       if (dump_file)\n \t{\n@@ -3261,7 +3279,7 @@ dse_step3_scan (bool for_spills, basic_block bb)\n       if (bb_info->kill)\n \tbitmap_clear (bb_info->kill);\n       else\n-\tbb_info->kill = BITMAP_ALLOC (NULL);\n+\tbb_info->kill = BITMAP_ALLOC (&dse_bitmap_obstack);\n     }\n   else\n     if (bb_info->kill)\n@@ -3354,7 +3372,7 @@ dse_step3 (bool for_spills)\n       if (bb_info->gen)\n \tbitmap_clear (bb_info->gen);\n       else\n-\tbb_info->gen = BITMAP_ALLOC (NULL);\n+\tbb_info->gen = BITMAP_ALLOC (&dse_bitmap_obstack);\n \n       if (bb->index == ENTRY_BLOCK)\n \t;\n@@ -3386,13 +3404,13 @@ dse_step3 (bool for_spills)\n \t      unsigned int j;\n \t      group_info_t group;\n \n-\t      all_ones = BITMAP_ALLOC (NULL);\n+\t      all_ones = BITMAP_ALLOC (&dse_bitmap_obstack);\n \t      FOR_EACH_VEC_ELT (group_info_t, rtx_group_vec, j, group)\n \t\tbitmap_ior_into (all_ones, group->group_kill);\n \t    }\n \t  if (!bb_info->out)\n \t    {\n-\t      bb_info->out = BITMAP_ALLOC (NULL);\n+\t      bb_info->out = BITMAP_ALLOC (&dse_bitmap_obstack);\n \t      bitmap_copy (bb_info->out, all_ones);\n \t    }\n \t}\n@@ -3428,7 +3446,7 @@ dse_confluence_0 (basic_block bb)\n \n   if (!bb_info->out)\n     {\n-      bb_info->out = BITMAP_ALLOC (NULL);\n+      bb_info->out = BITMAP_ALLOC (&dse_bitmap_obstack);\n       bitmap_copy (bb_info->out, bb_table[EXIT_BLOCK]->gen);\n     }\n }\n@@ -3449,7 +3467,7 @@ dse_confluence_n (edge e)\n \tbitmap_and_into (src_info->out, dest_info->in);\n       else\n \t{\n-\t  src_info->out = BITMAP_ALLOC (NULL);\n+\t  src_info->out = BITMAP_ALLOC (&dse_bitmap_obstack);\n \t  bitmap_copy (src_info->out, dest_info->in);\n \t}\n     }\n@@ -3488,7 +3506,7 @@ dse_transfer_function (int bb_index)\n \t\t\t\t\t bb_info->out, bb_info->kill);\n \t  else\n \t    {\n-\t      bb_info->in = BITMAP_ALLOC (NULL);\n+\t      bb_info->in = BITMAP_ALLOC (&dse_bitmap_obstack);\n \t      bitmap_ior_and_compl (bb_info->in, bb_info->gen,\n \t\t\t\t    bb_info->out, bb_info->kill);\n \t      return true;\n@@ -3506,7 +3524,7 @@ dse_transfer_function (int bb_index)\n \treturn false;\n       else\n \t{\n-\t  bb_info->in = BITMAP_ALLOC (NULL);\n+\t  bb_info->in = BITMAP_ALLOC (&dse_bitmap_obstack);\n \t  bitmap_copy (bb_info->in, bb_info->gen);\n \t  return true;\n \t}\n@@ -3786,37 +3804,10 @@ dse_step6 (void)\n ----------------------------------------------------------------------------*/\n \n static void\n-dse_step7 (bool global_done)\n+dse_step7 (void)\n {\n-  unsigned int i;\n-  group_info_t group;\n-  basic_block bb;\n-\n-  FOR_EACH_VEC_ELT (group_info_t, rtx_group_vec, i, group)\n-    {\n-      free (group->offset_map_n);\n-      free (group->offset_map_p);\n-      BITMAP_FREE (group->store1_n);\n-      BITMAP_FREE (group->store1_p);\n-      BITMAP_FREE (group->store2_n);\n-      BITMAP_FREE (group->store2_p);\n-      BITMAP_FREE (group->escaped_n);\n-      BITMAP_FREE (group->escaped_p);\n-      BITMAP_FREE (group->group_kill);\n-    }\n-\n-  if (global_done)\n-    FOR_ALL_BB (bb)\n-      {\n-\tbb_info_t bb_info = bb_table[bb->index];\n-\tBITMAP_FREE (bb_info->gen);\n-\tif (bb_info->kill)\n-\t  BITMAP_FREE (bb_info->kill);\n-\tif (bb_info->in)\n-\t  BITMAP_FREE (bb_info->in);\n-\tif (bb_info->out)\n-\t  BITMAP_FREE (bb_info->out);\n-      }\n+  bitmap_obstack_release (&dse_bitmap_obstack);\n+  obstack_free (&dse_obstack, NULL);\n \n   if (clear_alias_sets)\n     {\n@@ -3897,7 +3888,7 @@ rest_of_handle_dse (void)\n     }\n \n   dse_step6 ();\n-  dse_step7 (did_global);\n+  dse_step7 ();\n \n   if (dump_file)\n     fprintf (dump_file, \"dse: local deletions = %d, global deletions = %d, spill deletions = %d\\n\","}, {"sha": "f4ecaf33a8b503a01d26cb762b69f9482f581f74", "filename": "gcc/tree-ssa-live.c", "status": "modified", "additions": 28, "deletions": 31, "changes": 59, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3f9b14ffa3cefe2c35111fa9f067dab4e92dcdc8/gcc%2Ftree-ssa-live.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3f9b14ffa3cefe2c35111fa9f067dab4e92dcdc8/gcc%2Ftree-ssa-live.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-live.c?ref=3f9b14ffa3cefe2c35111fa9f067dab4e92dcdc8", "patch": "@@ -293,7 +293,7 @@ partition_view_fini (var_map map, bitmap selected)\n /* Create a partition view which includes all the used partitions in MAP.  If\n    WANT_BASES is true, create the base variable map as well.  */\n \n-extern void\n+void\n partition_view_normal (var_map map, bool want_bases)\n {\n   bitmap used;\n@@ -312,7 +312,7 @@ partition_view_normal (var_map map, bool want_bases)\n    the bitmap ONLY. If WANT_BASES is true, create the base variable map\n    as well.  */\n \n-extern void\n+void\n partition_view_bitmap (var_map map, bitmap only, bool want_bases)\n {\n   bitmap used;\n@@ -329,7 +329,6 @@ partition_view_bitmap (var_map map, bitmap only, bool want_bases)\n     }\n   partition_view_fini (map, new_partitions);\n \n-  BITMAP_FREE (used);\n   if (want_bases)\n     var_map_base_init (map);\n   else\n@@ -849,31 +848,37 @@ remove_unused_locals (void)\n   timevar_pop (TV_REMOVE_UNUSED);\n }\n \n+/* Obstack for globale liveness info bitmaps.  We don't want to put these\n+   on the default obstack because these bitmaps can grow quite large and\n+   we'll hold on to all that memory until the end of the compiler run.\n+   As a bonus, delete_tree_live_info can destroy all the bitmaps by just\n+   releasing the whole obstack.  */\n+static bitmap_obstack liveness_bitmap_obstack;\n \n /* Allocate and return a new live range information object base on MAP.  */\n \n static tree_live_info_p\n new_tree_live_info (var_map map)\n {\n   tree_live_info_p live;\n-  unsigned x;\n+  basic_block bb;\n \n-  live = (tree_live_info_p) xmalloc (sizeof (struct tree_live_info_d));\n+  live = XNEW (struct tree_live_info_d);\n   live->map = map;\n   live->num_blocks = last_basic_block;\n \n-  live->livein = (bitmap *)xmalloc (last_basic_block * sizeof (bitmap));\n-  for (x = 0; x < (unsigned)last_basic_block; x++)\n-    live->livein[x] = BITMAP_ALLOC (NULL);\n+  live->livein = XNEWVEC (bitmap_head, last_basic_block);\n+  FOR_EACH_BB (bb)\n+    bitmap_initialize (&live->livein[bb->index], &liveness_bitmap_obstack);\n \n-  live->liveout = (bitmap *)xmalloc (last_basic_block * sizeof (bitmap));\n-  for (x = 0; x < (unsigned)last_basic_block; x++)\n-    live->liveout[x] = BITMAP_ALLOC (NULL);\n+  live->liveout = XNEWVEC (bitmap_head, last_basic_block);\n+  FOR_EACH_BB (bb)\n+    bitmap_initialize (&live->liveout[bb->index], &liveness_bitmap_obstack);\n \n   live->work_stack = XNEWVEC (int, last_basic_block);\n   live->stack_top = live->work_stack;\n \n-  live->global = BITMAP_ALLOC (NULL);\n+  live->global = BITMAP_ALLOC (&liveness_bitmap_obstack);\n   return live;\n }\n \n@@ -883,19 +888,10 @@ new_tree_live_info (var_map map)\n void\n delete_tree_live_info (tree_live_info_p live)\n {\n-  int x;\n-\n-  BITMAP_FREE (live->global);\n+  bitmap_obstack_release (&liveness_bitmap_obstack);\n   free (live->work_stack);\n-\n-  for (x = live->num_blocks - 1; x >= 0; x--)\n-    BITMAP_FREE (live->liveout[x]);\n   free (live->liveout);\n-\n-  for (x = live->num_blocks - 1; x >= 0; x--)\n-    BITMAP_FREE (live->livein[x]);\n   free (live->livein);\n-\n   free (live);\n }\n \n@@ -928,7 +924,7 @@ loe_visit_block (tree_live_info_p live, basic_block bb, sbitmap visited,\n \t predecessor block.  This should be the live on entry vars to pred.\n \t Note that liveout is the DEFs in a block while live on entry is\n \t being calculated.  */\n-      bitmap_and_compl (tmp, loe, live->liveout[pred_bb->index]);\n+      bitmap_and_compl (tmp, loe, &live->liveout[pred_bb->index]);\n \n       /* Add these bits to live-on-entry for the pred. if there are any\n \t changes, and pred_bb has been visited already, add it to the\n@@ -952,7 +948,7 @@ live_worklist (tree_live_info_p live)\n   unsigned b;\n   basic_block bb;\n   sbitmap visited = sbitmap_alloc (last_basic_block + 1);\n-  bitmap tmp = BITMAP_ALLOC (NULL);\n+  bitmap tmp = BITMAP_ALLOC (&liveness_bitmap_obstack);\n \n   sbitmap_zero (visited);\n \n@@ -997,7 +993,7 @@ set_var_live_on_entry (tree ssa_name, tree_live_info_p live)\n       def_bb = gimple_bb (stmt);\n       /* Mark defs in liveout bitmap temporarily.  */\n       if (def_bb)\n-\tbitmap_set_bit (live->liveout[def_bb->index], p);\n+\tbitmap_set_bit (&live->liveout[def_bb->index], p);\n     }\n   else\n     def_bb = ENTRY_BLOCK_PTR;\n@@ -1036,7 +1032,7 @@ set_var_live_on_entry (tree ssa_name, tree_live_info_p live)\n       if (add_block)\n         {\n \t  global = true;\n-\t  bitmap_set_bit (live->livein[add_block->index], p);\n+\t  bitmap_set_bit (&live->livein[add_block->index], p);\n \t}\n     }\n \n@@ -1058,7 +1054,7 @@ calculate_live_on_exit (tree_live_info_p liveinfo)\n \n   /* live on entry calculations used liveout vectors for defs, clear them.  */\n   FOR_EACH_BB (bb)\n-    bitmap_clear (liveinfo->liveout[bb->index]);\n+    bitmap_clear (&liveinfo->liveout[bb->index]);\n \n   /* Set all the live-on-exit bits for uses in PHIs.  */\n   FOR_EACH_BB (bb)\n@@ -1083,14 +1079,14 @@ calculate_live_on_exit (tree_live_info_p liveinfo)\n \t\tcontinue;\n \t      e = gimple_phi_arg_edge (phi, i);\n \t      if (e->src != ENTRY_BLOCK_PTR)\n-\t\tbitmap_set_bit (liveinfo->liveout[e->src->index], p);\n+\t\tbitmap_set_bit (&liveinfo->liveout[e->src->index], p);\n \t    }\n \t}\n \n       /* Add each successors live on entry to this bock live on exit.  */\n       FOR_EACH_EDGE (e, ei, bb->succs)\n         if (e->dest != EXIT_BLOCK_PTR)\n-\t  bitmap_ior_into (liveinfo->liveout[bb->index],\n+\t  bitmap_ior_into (&liveinfo->liveout[bb->index],\n \t\t\t   live_on_entry (liveinfo, e->dest));\n     }\n }\n@@ -1106,6 +1102,7 @@ calculate_live_ranges (var_map map)\n   unsigned i;\n   tree_live_info_p live;\n \n+  bitmap_obstack_initialize (&liveness_bitmap_obstack);\n   live = new_tree_live_info (map);\n   for (i = 0; i < num_var_partitions (map); i++)\n     {\n@@ -1185,7 +1182,7 @@ dump_live_info (FILE *f, tree_live_info_p live, int flag)\n       FOR_EACH_BB (bb)\n \t{\n \t  fprintf (f, \"\\nLive on entry to BB%d : \", bb->index);\n-\t  EXECUTE_IF_SET_IN_BITMAP (live->livein[bb->index], 0, i, bi)\n+\t  EXECUTE_IF_SET_IN_BITMAP (&live->livein[bb->index], 0, i, bi)\n \t    {\n \t      print_generic_expr (f, partition_to_var (map, i), TDF_SLIM);\n \t      fprintf (f, \"  \");\n@@ -1199,7 +1196,7 @@ dump_live_info (FILE *f, tree_live_info_p live, int flag)\n       FOR_EACH_BB (bb)\n \t{\n \t  fprintf (f, \"\\nLive on exit from BB%d : \", bb->index);\n-\t  EXECUTE_IF_SET_IN_BITMAP (live->liveout[bb->index], 0, i, bi)\n+\t  EXECUTE_IF_SET_IN_BITMAP (&live->liveout[bb->index], 0, i, bi)\n \t    {\n \t      print_generic_expr (f, partition_to_var (map, i), TDF_SLIM);\n \t      fprintf (f, \"  \");"}, {"sha": "70a3aa60fd3a051719728259d557a06f49b40c95", "filename": "gcc/tree-ssa-live.h", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3f9b14ffa3cefe2c35111fa9f067dab4e92dcdc8/gcc%2Ftree-ssa-live.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3f9b14ffa3cefe2c35111fa9f067dab4e92dcdc8/gcc%2Ftree-ssa-live.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-live.h?ref=3f9b14ffa3cefe2c35111fa9f067dab4e92dcdc8", "patch": "@@ -226,8 +226,11 @@ typedef struct tree_live_info_d\n   /* Bitmap indicating which partitions are global.  */\n   bitmap global;\n \n-  /* Bitmap of live on entry blocks for partition elements.  */\n-  bitmap *livein;\n+  /* Bitmaps of live on entry blocks for partition elements.  */\n+  bitmap_head *livein;\n+\n+  /* Bitmaps of what variables are live on exit for a basic blocks.  */\n+  bitmap_head *liveout;\n \n   /* Number of basic blocks when live on exit calculated.  */\n   int num_blocks;\n@@ -237,9 +240,6 @@ typedef struct tree_live_info_d\n \n   /* Top of workstack.  */\n   int *stack_top;\n-\n-  /* Bitmap of what variables are live on exit for a basic blocks.  */\n-  bitmap *liveout;\n } *tree_live_info_p;\n \n \n@@ -273,7 +273,7 @@ live_on_entry (tree_live_info_p live, basic_block bb)\n \t\t       && bb != ENTRY_BLOCK_PTR\n \t\t       && bb != EXIT_BLOCK_PTR);\n \n-  return live->livein[bb->index];\n+  return &live->livein[bb->index];\n }\n \n \n@@ -287,7 +287,7 @@ live_on_exit (tree_live_info_p live, basic_block bb)\n \t\t       && bb != ENTRY_BLOCK_PTR\n \t\t       && bb != EXIT_BLOCK_PTR);\n \n-  return live->liveout[bb->index];\n+  return &live->liveout[bb->index];\n }\n \n \n@@ -306,9 +306,9 @@ live_var_map (tree_live_info_p live)\n static inline void\n live_merge_and_clear (tree_live_info_p live, int p1, int p2)\n {\n-  gcc_checking_assert (live->livein[p1] && live->livein[p2]);\n-  bitmap_ior_into (live->livein[p1], live->livein[p2]);\n-  bitmap_zero (live->livein[p2]);\n+  gcc_checking_assert (&live->livein[p1] && &live->livein[p2]);\n+  bitmap_ior_into (&live->livein[p1], &live->livein[p2]);\n+  bitmap_zero (&live->livein[p2]);\n }\n \n \n@@ -317,7 +317,7 @@ live_merge_and_clear (tree_live_info_p live, int p1, int p2)\n static inline void\n make_live_on_entry (tree_live_info_p live, basic_block bb , int p)\n {\n-  bitmap_set_bit (live->livein[bb->index], p);\n+  bitmap_set_bit (&live->livein[bb->index], p);\n   bitmap_set_bit (live->global, p);\n }\n "}, {"sha": "8252084a945f8556cb46db7cdc3944b98296ea2e", "filename": "gcc/tree-ssa-loop-im.c", "status": "modified", "additions": 14, "deletions": 23, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3f9b14ffa3cefe2c35111fa9f067dab4e92dcdc8/gcc%2Ftree-ssa-loop-im.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3f9b14ffa3cefe2c35111fa9f067dab4e92dcdc8/gcc%2Ftree-ssa-loop-im.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-im.c?ref=3f9b14ffa3cefe2c35111fa9f067dab4e92dcdc8", "patch": "@@ -183,6 +183,9 @@ static struct\n   struct pointer_map_t *ttae_cache;\n } memory_accesses;\n \n+/* Obstack for the bitmaps in the above data structures.  */\n+static bitmap_obstack lim_bitmap_obstack;\n+\n static bool ref_indep_loop_p (struct loop *, mem_ref_p);\n \n /* Minimum cost of an expensive expression.  */\n@@ -1491,12 +1494,6 @@ memref_free (struct mem_ref *mem)\n   unsigned i;\n   mem_ref_locs_p accs;\n \n-  BITMAP_FREE (mem->stored);\n-  BITMAP_FREE (mem->indep_loop);\n-  BITMAP_FREE (mem->dep_loop);\n-  BITMAP_FREE (mem->indep_ref);\n-  BITMAP_FREE (mem->dep_ref);\n-\n   FOR_EACH_VEC_ELT (mem_ref_locs_p, mem->accesses_in_loop, i, accs)\n     free_mem_ref_locs (accs);\n   VEC_free (mem_ref_locs_p, heap, mem->accesses_in_loop);\n@@ -1514,11 +1511,11 @@ mem_ref_alloc (tree mem, unsigned hash, unsigned id)\n   ref->mem = mem;\n   ref->id = id;\n   ref->hash = hash;\n-  ref->stored = BITMAP_ALLOC (NULL);\n-  ref->indep_loop = BITMAP_ALLOC (NULL);\n-  ref->dep_loop = BITMAP_ALLOC (NULL);\n-  ref->indep_ref = BITMAP_ALLOC (NULL);\n-  ref->dep_ref = BITMAP_ALLOC (NULL);\n+  ref->stored = BITMAP_ALLOC (&lim_bitmap_obstack);\n+  ref->indep_loop = BITMAP_ALLOC (&lim_bitmap_obstack);\n+  ref->dep_loop = BITMAP_ALLOC (&lim_bitmap_obstack);\n+  ref->indep_ref = BITMAP_ALLOC (&lim_bitmap_obstack);\n+  ref->dep_ref = BITMAP_ALLOC (&lim_bitmap_obstack);\n   ref->accesses_in_loop = NULL;\n \n   return ref;\n@@ -1738,11 +1735,11 @@ analyze_memory_references (void)\n \n   for (i = 0; i < number_of_loops (); i++)\n     {\n-      empty = BITMAP_ALLOC (NULL);\n+      empty = BITMAP_ALLOC (&lim_bitmap_obstack);\n       VEC_quick_push (bitmap, memory_accesses.refs_in_loop, empty);\n-      empty = BITMAP_ALLOC (NULL);\n+      empty = BITMAP_ALLOC (&lim_bitmap_obstack);\n       VEC_quick_push (bitmap, memory_accesses.all_refs_in_loop, empty);\n-      empty = BITMAP_ALLOC (NULL);\n+      empty = BITMAP_ALLOC (&lim_bitmap_obstack);\n       VEC_quick_push (bitmap, memory_accesses.all_refs_stored_in_loop, empty);\n     }\n \n@@ -2581,6 +2578,8 @@ tree_ssa_lim_initialize (void)\n   struct loop *loop;\n   basic_block bb;\n \n+  bitmap_obstack_initialize (&lim_bitmap_obstack);\n+\n   sbitmap_zero (contains_call);\n   FOR_EACH_BB (bb)\n     {\n@@ -2614,14 +2613,14 @@ tree_ssa_lim_finalize (void)\n {\n   basic_block bb;\n   unsigned i;\n-  bitmap b;\n   mem_ref_p ref;\n \n   free_aux_for_edges ();\n \n   FOR_EACH_BB (bb)\n     SET_ALWAYS_EXECUTED_IN (bb, NULL);\n \n+  bitmap_obstack_release (&lim_bitmap_obstack);\n   pointer_map_destroy (lim_aux_data_map);\n \n   htab_delete (memory_accesses.refs);\n@@ -2630,16 +2629,8 @@ tree_ssa_lim_finalize (void)\n     memref_free (ref);\n   VEC_free (mem_ref_p, heap, memory_accesses.refs_list);\n \n-  FOR_EACH_VEC_ELT (bitmap, memory_accesses.refs_in_loop, i, b)\n-    BITMAP_FREE (b);\n   VEC_free (bitmap, heap, memory_accesses.refs_in_loop);\n-\n-  FOR_EACH_VEC_ELT (bitmap, memory_accesses.all_refs_in_loop, i, b)\n-    BITMAP_FREE (b);\n   VEC_free (bitmap, heap, memory_accesses.all_refs_in_loop);\n-\n-  FOR_EACH_VEC_ELT (bitmap, memory_accesses.all_refs_stored_in_loop, i, b)\n-    BITMAP_FREE (b);\n   VEC_free (bitmap, heap, memory_accesses.all_refs_stored_in_loop);\n \n   if (memory_accesses.ttae_cache)"}, {"sha": "ab015df4bc5a07e1f9ddfbf1a66a5b90cd9b487a", "filename": "gcc/tree-ssa-loop-manip.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3f9b14ffa3cefe2c35111fa9f067dab4e92dcdc8/gcc%2Ftree-ssa-loop-manip.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3f9b14ffa3cefe2c35111fa9f067dab4e92dcdc8/gcc%2Ftree-ssa-loop-manip.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-manip.c?ref=3f9b14ffa3cefe2c35111fa9f067dab4e92dcdc8", "patch": "@@ -130,7 +130,7 @@ create_iv (tree base, tree step, tree var, struct loop *loop,\n   add_phi_arg (stmt, va, loop_latch_edge (loop), UNKNOWN_LOCATION);\n }\n \n-/* Return the outermost superloop LOOP of USE_LOOP that is a superloop of\n+/* Return the innermost superloop LOOP of USE_LOOP that is a superloop of\n    both DEF_LOOP and USE_LOOP.  */\n \n static inline struct loop *"}, {"sha": "3375a2777c990aeb3abaab83dc32233bdd426d1c", "filename": "gcc/tree-ssa-ter.c", "status": "modified", "additions": 16, "deletions": 9, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3f9b14ffa3cefe2c35111fa9f067dab4e92dcdc8/gcc%2Ftree-ssa-ter.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3f9b14ffa3cefe2c35111fa9f067dab4e92dcdc8/gcc%2Ftree-ssa-ter.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-ter.c?ref=3f9b14ffa3cefe2c35111fa9f067dab4e92dcdc8", "patch": "@@ -172,6 +172,9 @@ typedef struct temp_expr_table_d\n /* Used to indicate a dependency on VDEFs.  */\n #define VIRTUAL_PARTITION(table)\t(table->virtual_partition)\n \n+/* A place for the many, many bitmaps we create.  */\n+static bitmap_obstack ter_bitmap_obstack;\n+\n #ifdef ENABLE_CHECKING\n extern void debug_ter (FILE *, temp_expr_table_p);\n #endif\n@@ -192,10 +195,10 @@ new_temp_expr_table (var_map map)\n   t->expr_decl_uids = XCNEWVEC (bitmap, num_ssa_names + 1);\n   t->kill_list = XCNEWVEC (bitmap, num_var_partitions (map) + 1);\n \n-  t->partition_in_use = BITMAP_ALLOC (NULL);\n+  t->partition_in_use = BITMAP_ALLOC (&ter_bitmap_obstack);\n \n   t->virtual_partition = num_var_partitions (map);\n-  t->new_replaceable_dependencies = BITMAP_ALLOC (NULL);\n+  t->new_replaceable_dependencies = BITMAP_ALLOC (&ter_bitmap_obstack);\n \n   t->replaceable_expressions = NULL;\n   t->num_in_part = XCNEWVEC (int, num_var_partitions (map));\n@@ -269,7 +272,7 @@ static inline void\n make_dependent_on_partition (temp_expr_table_p tab, int version, int p)\n {\n   if (!tab->partition_dependencies[version])\n-    tab->partition_dependencies[version] = BITMAP_ALLOC (NULL);\n+    tab->partition_dependencies[version] = BITMAP_ALLOC (&ter_bitmap_obstack);\n \n   bitmap_set_bit (tab->partition_dependencies[version], p);\n }\n@@ -282,7 +285,7 @@ add_to_partition_kill_list (temp_expr_table_p tab, int p, int ver)\n {\n   if (!tab->kill_list[p])\n     {\n-      tab->kill_list[p] = BITMAP_ALLOC (NULL);\n+      tab->kill_list[p] = BITMAP_ALLOC (&ter_bitmap_obstack);\n       bitmap_set_bit (tab->partition_in_use, p);\n     }\n   bitmap_set_bit (tab->kill_list[p], ver);\n@@ -330,7 +333,8 @@ add_dependence (temp_expr_table_p tab, int version, tree var)\n \t  /* Rather than set partition_dependencies and in_use lists bit by\n \t     bit, simply OR in the new_replaceable_dependencies bits.  */\n \t  if (!tab->partition_dependencies[version])\n-\t    tab->partition_dependencies[version] = BITMAP_ALLOC (NULL);\n+\t    tab->partition_dependencies[version] =\n+\t      BITMAP_ALLOC (&ter_bitmap_obstack);\n \t  bitmap_ior_into (tab->partition_dependencies[version],\n \t\t\t   tab->new_replaceable_dependencies);\n \t  bitmap_ior_into (tab->partition_in_use,\n@@ -498,7 +502,7 @@ process_replaceable (temp_expr_table_p tab, gimple stmt, int call_cnt)\n \n   def = SINGLE_SSA_TREE_OPERAND (stmt, SSA_OP_DEF);\n   version = SSA_NAME_VERSION (def);\n-  def_vars = BITMAP_ALLOC (NULL);\n+  def_vars = BITMAP_ALLOC (&ter_bitmap_obstack);\n \n   basevar = SSA_NAME_VAR (def);\n   if (basevar)\n@@ -578,7 +582,9 @@ mark_replaceable (temp_expr_table_p tab, tree var, bool more_replacing)\n \n   finished_with_expr (tab, version, !more_replacing);\n \n-  /* Set the replaceable expression.  */\n+  /* Set the replaceable expression.\n+     The bitmap for this \"escapes\" from this file so it's allocated\n+     on the default obstack.  */\n   if (!tab->replaceable_expressions)\n     tab->replaceable_expressions = BITMAP_ALLOC (NULL);\n   bitmap_set_bit (tab->replaceable_expressions, version);\n@@ -706,21 +712,22 @@ find_replaceable_in_bb (temp_expr_table_p tab, basic_block bb)\n    NULL is returned by the function, otherwise an expression vector indexed\n    by SSA_NAME version numbers.  */\n \n-extern bitmap\n+bitmap\n find_replaceable_exprs (var_map map)\n {\n   basic_block bb;\n   temp_expr_table_p table;\n   bitmap ret;\n \n+  bitmap_obstack_initialize (&ter_bitmap_obstack);\n   table = new_temp_expr_table (map);\n   FOR_EACH_BB (bb)\n     {\n       find_replaceable_in_bb (table, bb);\n       gcc_checking_assert (bitmap_empty_p (table->partition_in_use));\n     }\n-\n   ret = free_temp_expr_table (table);\n+  bitmap_obstack_release (&ter_bitmap_obstack);\n   return ret;\n }\n "}]}