{"sha": "579cef8f39ea28afa93c2d84f959867a7caa1325", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTc5Y2VmOGYzOWVhMjhhZmE5M2MyZDg0Zjk1OTg2N2E3Y2FhMTMyNQ==", "commit": {"author": {"name": "Uros Bizjak", "email": "ubizjak@gmail.com", "date": "2015-04-16T11:39:53Z"}, "committer": {"name": "Uros Bizjak", "email": "uros@gcc.gnu.org", "date": "2015-04-16T11:39:53Z"}, "message": "i386.c (print_reg): Rewrite function.\n\n\t* config/i386/i386.c (print_reg): Rewrite function.\n\nFrom-SVN: r222145", "tree": {"sha": "241b9e90316bdc8808a03be0aec2828de41f6c41", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/241b9e90316bdc8808a03be0aec2828de41f6c41"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/579cef8f39ea28afa93c2d84f959867a7caa1325", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/579cef8f39ea28afa93c2d84f959867a7caa1325", "html_url": "https://github.com/Rust-GCC/gccrs/commit/579cef8f39ea28afa93c2d84f959867a7caa1325", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/579cef8f39ea28afa93c2d84f959867a7caa1325/comments", "author": {"login": "ubizjak", "id": 55479990, "node_id": "MDQ6VXNlcjU1NDc5OTkw", "avatar_url": "https://avatars.githubusercontent.com/u/55479990?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ubizjak", "html_url": "https://github.com/ubizjak", "followers_url": "https://api.github.com/users/ubizjak/followers", "following_url": "https://api.github.com/users/ubizjak/following{/other_user}", "gists_url": "https://api.github.com/users/ubizjak/gists{/gist_id}", "starred_url": "https://api.github.com/users/ubizjak/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ubizjak/subscriptions", "organizations_url": "https://api.github.com/users/ubizjak/orgs", "repos_url": "https://api.github.com/users/ubizjak/repos", "events_url": "https://api.github.com/users/ubizjak/events{/privacy}", "received_events_url": "https://api.github.com/users/ubizjak/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "dba0dd688d09f1c387e08f78103abb69587ceec4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dba0dd688d09f1c387e08f78103abb69587ceec4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/dba0dd688d09f1c387e08f78103abb69587ceec4"}], "stats": {"total": 134, "additions": 68, "deletions": 66}, "files": [{"sha": "4b661d1c928081d1eb12516d5d9025d32227ec2a", "filename": "gcc/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/579cef8f39ea28afa93c2d84f959867a7caa1325/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/579cef8f39ea28afa93c2d84f959867a7caa1325/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=579cef8f39ea28afa93c2d84f959867a7caa1325", "patch": "@@ -1,3 +1,7 @@\n+2015-04-16  Uros Bizjak  <ubizjak@gmail.com>\n+\n+\t* config/i386/i386.c (print_reg): Rewrite function.\n+\n 2015-04-16  Andreas Krebbel  <Andreas.Krebbel@de.ibm.com>\n \n \t* config/s390/s390.h (IRA_HARD_REGNO_ADD_COST_MULTIPLIER):"}, {"sha": "1f20ff394c83be989a8acd1aecb7df1221340476", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 64, "deletions": 66, "changes": 130, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/579cef8f39ea28afa93c2d84f959867a7caa1325/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/579cef8f39ea28afa93c2d84f959867a7caa1325/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=579cef8f39ea28afa93c2d84f959867a7caa1325", "patch": "@@ -15191,8 +15191,9 @@ void\n print_reg (rtx x, int code, FILE *file)\n {\n   const char *reg;\n+  int msize;\n   unsigned int regno;\n-  bool duplicated = code == 'd' && TARGET_AVX;\n+  bool duplicated;\n \n   if (ASSEMBLER_DIALECT == ASM_ATT)\n     putc ('%', file);\n@@ -15204,82 +15205,49 @@ print_reg (rtx x, int code, FILE *file)\n       return;\n     }\n \n-  regno = true_regnum (x);\n-  gcc_assert (regno != ARG_POINTER_REGNUM\n-\t      && regno != FRAME_POINTER_REGNUM\n-\t      && regno != FLAGS_REG\n-\t      && regno != FPSR_REG\n-\t      && regno != FPCR_REG);\n+  if (code == 'y' && STACK_TOP_P (x))\n+    {\n+      fputs (\"st(0)\", file);\n+      return;\n+    }\n \n   if (code == 'w')\n-    code = 2;\n+    msize = 2;\n   else if (code == 'b')\n-    code = 1;\n+    msize = 1;\n   else if (code == 'k')\n-    code = 4;\n+    msize = 4;\n   else if (code == 'q')\n-    code = 8;\n-  else if (code == 'y')\n-    code = 3;\n+    msize = 8;\n   else if (code == 'h')\n-    code = 0;\n+    msize = 0;\n   else if (code == 'x')\n-    code = 16;\n+    msize = 16;\n   else if (code == 't')\n-    code = 32;\n+    msize = 32;\n   else if (code == 'g')\n-    code = 64;\n+    msize = 64;\n   else\n-    code = GET_MODE_SIZE (GET_MODE (x));\n+    msize = GET_MODE_SIZE (GET_MODE (x));\n \n-  /* Irritatingly, AMD extended registers use different naming convention\n-     from the normal registers: \"r%d[bwd]\"  */\n-  if (REX_INT_REGNO_P (regno))\n-    {\n-      gcc_assert (TARGET_64BIT);\n-      putc ('r', file);\n-      fprint_ul (file, regno - FIRST_REX_INT_REG + 8);\n-      switch (code)\n-\t{\n-\t  case 0:\n-\t    error (\"extended registers have no high halves\");\n-\t    break;\n-\t  case 1:\n-\t    putc ('b', file);\n-\t    break;\n-\t  case 2:\n-\t    putc ('w', file);\n-\t    break;\n-\t  case 4:\n-\t    putc ('d', file);\n-\t    break;\n-\t  case 8:\n-\t    /* no suffix */\n-\t    break;\n-\t  default:\n-\t    error (\"unsupported operand size for extended register\");\n-\t    break;\n-\t}\n-      return;\n-    }\n+  regno = true_regnum (x);\n \n-  reg = NULL;\n-  switch (code)\n+  gcc_assert (regno != ARG_POINTER_REGNUM\n+\t      && regno != FRAME_POINTER_REGNUM\n+\t      && regno != FLAGS_REG\n+\t      && regno != FPSR_REG\n+\t      && regno != FPCR_REG);\n+\n+  duplicated = code == 'd' && TARGET_AVX;\n+\n+  switch (msize)\n     {\n-    case 3:\n-      if (STACK_TOP_P (x))\n-\t{\n-\t  reg = \"st(0)\";\n-\t  break;\n-\t}\n-      /* FALLTHRU */\n     case 8:\n     case 4:\n-    case 12:\n-      if (LEGACY_INT_REG_P (x))\n-\tputc (code == 8 && TARGET_64BIT ? 'r' : 'e', file);\n-      /* FALLTHRU */\n+      if (LEGACY_INT_REGNO_P (regno))\n+\tputc (msize == 8 ? 'r' : 'e', file);\n     case 16:\n+    case 12:\n     case 2:\n     normal:\n       reg = hi_reg_name[regno];\n@@ -15296,19 +15264,49 @@ print_reg (rtx x, int code, FILE *file)\n       break;\n     case 32:\n     case 64:\n-      if (SSE_REG_P (x))\n+      if (SSE_REGNO_P (regno))\n \t{\n \t  gcc_assert (!duplicated);\n-\t  putc (code == 32 ? 'y' : 'z', file);\n-\t  fputs (hi_reg_name[regno] + 1, file);\n-\t  return;\n+\t  putc (msize == 32 ? 'y' : 'z', file);\n+\t  reg = hi_reg_name[regno] + 1;\n+\t  break;\n \t}\n-      break;\n+      goto normal;\n     default:\n       gcc_unreachable ();\n     }\n \n   fputs (reg, file);\n+\n+  /* Irritatingly, AMD extended registers use\n+     different naming convention: \"r%d[bwd]\"  */\n+  if (REX_INT_REGNO_P (regno))\n+    {\n+      gcc_assert (TARGET_64BIT);\n+      switch (msize)\n+\t{\n+\t  case 0:\n+\t    error (\"extended registers have no high halves\");\n+\t    break;\n+\t  case 1:\n+\t    putc ('b', file);\n+\t    break;\n+\t  case 2:\n+\t    putc ('w', file);\n+\t    break;\n+\t  case 4:\n+\t    putc ('d', file);\n+\t    break;\n+\t  case 8:\n+\t    /* no suffix */\n+\t    break;\n+\t  default:\n+\t    error (\"unsupported operand size for extended register\");\n+\t    break;\n+\t}\n+      return;\n+    }\n+\n   if (duplicated)\n     {\n       if (ASSEMBLER_DIALECT == ASM_ATT)"}]}