{"sha": "ff9940b0157fcda551e107ade4107291605fc285", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZmY5OTQwYjAxNTdmY2RhNTUxZTEwN2FkZTQxMDcyOTE2MDVmYzI4NQ==", "commit": {"author": {"name": "Richard Earnshaw", "email": "erich@gnu.org", "date": "1993-10-03T16:33:02Z"}, "committer": {"name": "Richard Earnshaw", "email": "erich@gnu.org", "date": "1993-10-03T16:33:02Z"}, "message": "Major rewrite -- See ChangeLog for details\n\nFrom-SVN: r5564", "tree": {"sha": "b94e7daf9e44ca267437ca66c4448de27a109f0d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b94e7daf9e44ca267437ca66c4448de27a109f0d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ff9940b0157fcda551e107ade4107291605fc285", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ff9940b0157fcda551e107ade4107291605fc285", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ff9940b0157fcda551e107ade4107291605fc285", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ff9940b0157fcda551e107ade4107291605fc285/comments", "author": null, "committer": null, "parents": [{"sha": "b980bec031926a0d179602d890b2b448e52f2bbf", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b980bec031926a0d179602d890b2b448e52f2bbf", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b980bec031926a0d179602d890b2b448e52f2bbf"}], "stats": {"total": 8533, "additions": 7557, "deletions": 976}, "files": [{"sha": "fa10ce23201e3baaf4a194e9dee23a628ee7444f", "filename": "gcc/config/arm/arm.c", "status": "modified", "additions": 1265, "deletions": 104, "changes": 1369, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff9940b0157fcda551e107ade4107291605fc285/gcc%2Fconfig%2Farm%2Farm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff9940b0157fcda551e107ade4107291605fc285/gcc%2Fconfig%2Farm%2Farm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.c?ref=ff9940b0157fcda551e107ade4107291605fc285", "patch": "@@ -1,7 +1,8 @@\n /* Output routines for GCC for ARM/RISCiX.\n-   Copyright (C) 1991 Free Software Foundation, Inc.\n+   Copyright (C) 1991, 1993 Free Software Foundation, Inc.\n    Contributed by Pieter `Tiggr' Schoenmakers (rcpieter@win.tue.nl)\n    \t      and Martin Simmons (@harleqn.co.uk).\n+   More major hacks by Richard Earnshaw (rwe11@cl.cam.ac.uk)\n \n This file is part of GNU CC.\n \n@@ -18,7 +19,7 @@ GNU General Public License for more details.\n You should have received a copy of the GNU General Public License\n along with GNU CC; see the file COPYING.  If not, write to\n the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */\n-\n+    \n #include <stdio.h>\n #include \"assert.h\"\n #include \"config.h\"\n@@ -43,6 +44,16 @@ extern char *output_multi_immediate ();\n extern char *arm_output_asm_insn ();\n extern void arm_increase_location ();\n \n+/*  Define the information needed to generate branch insns.  This is\n+   stored from the compare operation. */\n+\n+rtx arm_compare_op0, arm_compare_op1;\n+int arm_compare_fp;\n+\n+/* What type of cpu are we compiling for? */\n+\n+enum processor_type arm_cpu;\n+\n /* In case of a PRE_INC, POST_INC, PRE_DEC, POST_DEC memory reference, we\n    must report the mode of the memory reference from PRINT_OPERAND to\n    PRINT_OPERAND_ADDRESS.  */\n@@ -54,6 +65,10 @@ int current_function_anonymous_args;\n /* Location counter of .text segment.  */\n int arm_text_location = 0;\n \n+/* Set to one if we think that lr is only saved because of subroutine calls,\n+   but all of these can be `put after' return insns */\n+int lr_save_eliminated;\n+\n /* A hash table is used to store text segment labels and their associated\n    offset from the start of the text segment.  */\n struct label_offset\n@@ -67,13 +82,38 @@ struct label_offset\n \n static struct label_offset *offset_table[LABEL_HASH_SIZE];\n \n+/* Set to 1 when a return insn is output, this means that the epilogue\n+   is not needed. */\n+\n+static int return_used_this_function;\n+\n /* For an explanation of these variables, see final_prescan_insn below.  */\n int arm_ccfsm_state;\n int arm_current_cc;\n rtx arm_target_insn;\n int arm_target_label;\n-char *arm_condition_codes[];\n \f\n+/* Return 1 if it is possible to return using a single instruction */\n+\n+int\n+use_return_insn ()\n+{\n+  int regno;\n+\n+  if (!reload_completed ||current_function_pretend_args_size\n+      || current_function_anonymous_args\n+      || (get_frame_size () && !(TARGET_APCS || frame_pointer_needed)))\n+    return 0;\n+\n+  /* Can't be done if any of the FPU regs are pushed, since this also\n+     requires an insn */\n+  for (regno = 20; regno < 24; regno++)\n+    if (regs_ever_live[regno])\n+      return 0;\n+\n+  return 1;\n+}\n+\n /* Return the number of mov instructions needed to get the constant VALUE into\n    a register.  */\n \n@@ -96,63 +136,210 @@ arm_const_nmoves (value)\n \n int\n const_ok_for_arm (i)\n-     int i;\n+     HOST_WIDE_INT i;\n {\n-  unsigned int mask = ~0xFF;\n+  unsigned HOST_WIDE_INT mask = ~0xFF;\n \n   do\n     {\n-      if ((i & mask) == 0)\n-\treturn(TRUE);\n-      mask = (mask << 2) | (mask >> (32 - 2));\n+      if ((i & mask & 0xffffffffu) == 0)\n+        return(TRUE);\n+      mask = (mask << 2) | ((mask & 0xffffffffu) >> (32 - 2)) | ~0xffffffffu;\n     } while (mask != ~0xFF);\n \n   return (FALSE);\n } /* const_ok_for_arm */\n \n+/* This code has been fixed for cross compilation. */\n+\n+static int fpa_consts_inited = 0;\n+\n+char *strings_fpa[8] = {\n+  \"0.0\",\n+  \"1.0\",\n+  \"2.0\",\n+  \"3.0\",\n+  \"4.0\",\n+  \"5.0\",\n+  \"0.5\",\n+  \"10.0\"\n+  };\n+\n+static REAL_VALUE_TYPE values_fpa[8];\n+\n+static void\n+init_fpa_table ()\n+{\n+  int i;\n+  REAL_VALUE_TYPE r;\n+\n+  for (i = 0; i < 8; i++)\n+    {\n+      r = REAL_VALUE_ATOF (strings_fpa[i], DFmode);\n+      values_fpa[i] = r;\n+    }\n+  fpa_consts_inited = 1;\n+}\n+\n /* Return TRUE if rtx X is a valid immediate FPU constant. */\n \n int\n const_double_rtx_ok_for_fpu (x)\n      rtx x;\n {\n-  double d;\n-  union real_extract u;\n-  u.i[0] = CONST_DOUBLE_LOW(x);\n-  u.i[1] = CONST_DOUBLE_HIGH(x);\n-  d = u.d;\n-\n-  return (d == 0.0 || d == 1.0 || d == 2.0 || d == 3.0\n-\t  || d == 4.0 || d == 5.0 || d == 0.5 || d == 10.0);\n+  REAL_VALUE_TYPE r;\n+  int i;\n+  \n+  if (!fpa_consts_inited)\n+    init_fpa_table ();\n+  \n+  REAL_VALUE_FROM_CONST_DOUBLE (r, x);\n+  if (REAL_VALUE_MINUS_ZERO (r))\n+    return 0;\n+  for (i = 0; i < 8; i++)\n+    if (REAL_VALUES_EQUAL (r, values_fpa[i]))\n+      return 1;\n+  return 0;\n } /* const_double_rtx_ok_for_fpu */\n+\n+/* Return TRUE if rtx X is a valid immediate FPU constant. */\n+\n+int\n+neg_const_double_rtx_ok_for_fpu (x)\n+     rtx x;\n+{\n+  REAL_VALUE_TYPE r;\n+  int i;\n+  \n+  if (!fpa_consts_inited)\n+    init_fpa_table ();\n+  \n+  REAL_VALUE_FROM_CONST_DOUBLE (r, x);\n+  r = REAL_VALUE_NEGATE (r);\n+  if (REAL_VALUE_MINUS_ZERO (r))\n+    return 0;\n+  for (i = 0; i < 8; i++)\n+    if (REAL_VALUES_EQUAL (r, values_fpa[i]))\n+      return 1;\n+  return 0;\n+} /* neg_const_double_rtx_ok_for_fpu */\n \f\n /* Predicates for `match_operand' and `match_operator'.  */\n \n+/* s_register_operand is the same as register_operand, but it doesn't accept\n+   (SUBREG (MEM)...). */\n+\n+int\n+s_register_operand (op, mode)\n+     register rtx op;\n+     enum machine_mode mode;\n+{\n+  if (GET_MODE (op) != mode && mode != VOIDmode)\n+    return 0;\n+\n+  if (GET_CODE (op) == SUBREG)\n+    {\n+      op = SUBREG_REG (op);\n+    }\n+\n+  /* We don't consider registers whose class is NO_REGS\n+     to be a register operand.  */\n+  return (GET_CODE (op) == REG\n+\t  && (REGNO (op) >= FIRST_PSEUDO_REGISTER\n+\t      || REGNO_REG_CLASS (REGNO (op)) != NO_REGS));\n+}\n+\n+/* Return 1 if OP is an item in memory, given that we are in reload.  */\n+\n+int\n+reload_memory_operand (op, mode)\n+     rtx op;\n+     enum machine_mode mode;\n+{\n+  int regno = true_regnum (op);\n+\n+  return (! CONSTANT_P (op)\n+\t  && (regno == -1\n+\t      || (GET_CODE (op) == REG\n+\t\t  && REGNO (op) >= FIRST_PSEUDO_REGISTER)));\n+}\n+\n /* Return TRUE for valid operands for the rhs of an ARM instruction.  */\n \n int\n arm_rhs_operand (op, mode)\n      rtx op;\n      enum machine_mode mode;\n {\n-  return (register_operand (op, mode)\n+  return (s_register_operand (op, mode)\n \t  || (GET_CODE (op) == CONST_INT && const_ok_for_arm (INTVAL (op))));\n } /* arm_rhs_operand */\n \n+/* Return TRUE for valid operands for the rhs of an ARM instruction, or a load.\n+ */\n+\n+int\n+arm_rhsm_operand (op, mode)\n+     rtx op;\n+     enum machine_mode mode;\n+{\n+  return (s_register_operand (op, mode)\n+\t  || (GET_CODE (op) == CONST_INT && const_ok_for_arm (INTVAL (op)))\n+\t  || memory_operand (op, mode));\n+} /* arm_rhs_operand */\n+\n+/* Return TRUE for valid operands for the rhs of an ARM instruction, or if a\n+   constant that is valid when negated.  */\n+\n+int\n+arm_add_operand (op, mode)\n+     rtx op;\n+     enum machine_mode mode;\n+{\n+  return (s_register_operand (op, mode)\n+\t  || (GET_CODE (op) == CONST_INT\n+\t      && (const_ok_for_arm (INTVAL (op))\n+\t\t  || const_ok_for_arm (-INTVAL (op)))));\n+} /* arm_rhs_operand */\n+\n+int\n+arm_not_operand (op, mode)\n+     rtx op;\n+     enum machine_mode mode;\n+{\n+  return (s_register_operand (op, mode)\n+\t  || (GET_CODE (op) == CONST_INT\n+\t      && (const_ok_for_arm (INTVAL (op))\n+\t\t  || const_ok_for_arm (~INTVAL (op)))));\n+} /* arm_rhs_operand */\n+\n /* Return TRUE for valid operands for the rhs of an FPU instruction.  */\n \n int\n fpu_rhs_operand (op, mode)\n      rtx op;\n      enum machine_mode mode;\n {\n-  if (register_operand (op, mode))\n+  if (s_register_operand (op, mode))\n     return(TRUE);\n   else if (GET_CODE (op) == CONST_DOUBLE)\n     return (const_double_rtx_ok_for_fpu (op));\n   else return (FALSE);\n } /* fpu_rhs_operand */\n \n+int\n+fpu_add_operand (op, mode)\n+     rtx op;\n+     enum machine_mode mode;\n+{\n+  if (s_register_operand (op, mode))\n+    return(TRUE);\n+  else if (GET_CODE (op) == CONST_DOUBLE)\n+    return const_double_rtx_ok_for_fpu (op) \n+\t|| neg_const_double_rtx_ok_for_fpu (op);\n+  return (FALSE);\n+}\n+\n /* Return nonzero if OP is a constant power of two.  */\n \n int\n@@ -169,15 +356,16 @@ power_of_two_operand (op, mode)\n } /* power_of_two_operand */\n \n /* Return TRUE for a valid operand of a DImode operation.\n-   Either: REG, CONST_DOUBLE or MEM(offsettable).\n-   Note that this disallows MEM(REG+REG).  */\n+   Either: REG, CONST_DOUBLE or MEM(DImode_address).\n+   Note that this disallows MEM(REG+REG), but allows\n+   MEM(PRE/POST_INC/DEC(REG)).  */\n \n int\n di_operand (op, mode)\n      rtx op;\n      enum machine_mode mode;\n {\n-  if (register_operand (op, mode))\n+  if (s_register_operand (op, mode))\n     return (TRUE);\n \n   switch (GET_CODE (op))\n@@ -186,8 +374,7 @@ di_operand (op, mode)\n     case CONST_INT:\n       return (TRUE);\n     case MEM:\n-      return (memory_address_p (DImode, XEXP (op, 0))\n-\t      && offsettable_address_p (FALSE, DImode, XEXP (op, 0)));\n+      return (memory_address_p (DImode, XEXP (op, 0)));\n     default:\n       return (FALSE);\n     }\n@@ -200,10 +387,25 @@ index_operand (op, mode)\n      rtx op;\n      enum machine_mode mode;\n {\n-  return (register_operand(op, mode)\n-\t  || (immediate_operand (op, mode) && abs (INTVAL (op)) < 4096));\n+  return (s_register_operand(op, mode)\n+\t  || (immediate_operand (op, mode)\n+\t      && INTVAL (op) < 4096 && INTVAL (op) > -4096));\n } /* index_operand */\n \n+/* Return TRUE for valid shifts by a constant. This also accepts any\n+   power of two on the (somewhat overly relaxed) assumption that the\n+   shift operator in this case was a mult. */\n+\n+int\n+const_shift_operand (op, mode)\n+     rtx op;\n+     enum machine_mode mode;\n+{\n+  return (power_of_two_operand (op, mode)\n+\t  || (immediate_operand (op, mode)\n+\t      && (INTVAL (op) < 32 && INTVAL (op) > 0)));\n+} /* const_shift_operand */\n+\n /* Return TRUE for arithmetic operators which can be combined with a multiply\n    (shift).  */\n \n@@ -236,13 +438,384 @@ shift_operator (x, mode)\n     {\n       enum rtx_code code = GET_CODE (x);\n \n+      if (code == MULT)\n+\treturn power_of_two_operand (XEXP (x, 1));\n       return (code == ASHIFT || code == LSHIFT\n \t      || code == ASHIFTRT || code == LSHIFTRT);\n     }\n } /* shift_operator */\n+\n+int equality_operator (x, mode)\n+rtx x;\n+enum machine_mode mode;\n+{\n+  return (GET_CODE (x) == EQ || GET_CODE (x) == NE);\n+}\n+\n+/* Return TRUE for SMIN SMAX UMIN UMAX operators. */\n+\n+int\n+minmax_operator (x, mode)\n+     rtx x;\n+     enum machine_mode mode;\n+{\n+  enum rtx_code code = GET_CODE (x);\n+\n+  if (GET_MODE (x) != mode)\n+    return FALSE;\n+  return code == SMIN || code == SMAX || code == UMIN || code == UMAX;\n+} /* minmax_operator */\n+\n+/* return TRUE if x is EQ or NE */\n+\n+/* Return TRUE if this is the condition code register, if we aren't given\n+   a mode, accept any class CCmode register */\n+\n+int\n+cc_register (x, mode)\n+rtx x;\n+enum machine_mode mode;\n+{\n+  if (mode == VOIDmode)\n+    {\n+      mode = GET_MODE (x);\n+      if (GET_MODE_CLASS (mode) != MODE_CC)\n+\treturn FALSE;\n+    }\n+  if (mode == GET_MODE (x) && GET_CODE (x) == REG && REGNO (x) == 24)\n+    return TRUE;\n+  return FALSE;\n+}\n+       \n+enum rtx_code\n+minmax_code (x)\n+rtx x;\n+{\n+  enum rtx_code code = GET_CODE (x);\n+\n+  if (code == SMAX)\n+    return GE;\n+  if (code == SMIN)\n+    return LE;\n+  if (code == UMIN)\n+    return LEU;\n+  if (code == UMAX)\n+    return GEU;\n+  abort ();\n+}\n+\n+/* Return 1 if memory locations are adjacent */\n+\n+adjacent_mem_locations (a, b)\n+     rtx a, b;\n+{\n+  int val0 = 0, val1 = 0;\n+  int reg0, reg1;\n+  \n+  if ((GET_CODE (XEXP (a, 0)) == REG\n+       || (GET_CODE (XEXP (a, 0)) == PLUS\n+\t   && GET_CODE (XEXP (XEXP (a, 0), 1)) == CONST_INT))\n+      && (GET_CODE (XEXP (b, 0)) == REG\n+\t  || (GET_CODE (XEXP (b, 0)) == PLUS\n+\t      && GET_CODE (XEXP (XEXP (b, 0), 1)) == CONST_INT)))\n+    {\n+      if (GET_CODE (XEXP (a, 0)) == PLUS)\n+        {\n+\t  reg0 = REGNO (XEXP (XEXP (a, 0), 0));\n+\t  val0 = INTVAL (XEXP (XEXP (a, 0), 1));\n+        }\n+      else\n+\treg0 = REGNO (XEXP (a, 0));\n+      if (GET_CODE (XEXP (b, 0)) == PLUS)\n+        {\n+\t  reg1 = REGNO (XEXP (XEXP (b, 0), 0));\n+\t  val1 = INTVAL (XEXP (XEXP (b, 0), 1));\n+        }\n+      else\n+\treg1 = REGNO (XEXP (b, 0));\n+      return (reg0 == reg1) && ((val1 - val0) == 4 || (val0 - val1) == 4);\n+    }\n+  return 0;\n+}\n+\n+/* Return 1 if OP is a load multiple operation.  It is known to be\n+   parallel and the first section will be tested. */\n+\n+load_multiple_operation (op, mode)\n+     rtx op;\n+     enum machine_mode mode;\n+{\n+  int count = XVECLEN (op, 0);\n+  int dest_regno;\n+  rtx src_addr;\n+  int i = 1, base = 0;\n+  rtx elt;\n+\n+  if (count <= 1\n+      || GET_CODE (XVECEXP (op, 0, 0)) != SET)\n+    return 0;\n+\n+  /* Check to see if this might be a write-back */\n+  if (GET_CODE (SET_SRC (elt = XVECEXP (op, 0, 0))) == PLUS)\n+    {\n+      i++;\n+      base = 1;\n+\n+      /* Now check it more carefully */\n+      if (GET_CODE (SET_DEST (elt)) != REG\n+          || GET_CODE (XEXP (SET_SRC (elt), 0)) != REG\n+          || REGNO (XEXP (SET_SRC (elt), 0)) != REGNO (SET_DEST (elt))\n+          || GET_CODE (XEXP (SET_SRC (elt), 1)) != CONST_INT\n+          || INTVAL (XEXP (SET_SRC (elt), 1)) != (count - 2) * 4\n+          || GET_CODE (XVECEXP (op, 0, count - 1)) != CLOBBER\n+          || GET_CODE (XEXP (XVECEXP (op, 0, count - 1), 0)) != REG\n+          || REGNO (XEXP (XVECEXP (op, 0, count - 1), 0))\n+              != REGNO (SET_DEST (elt)))\n+        return 0;\n+      count--;\n+    }\n+\n+  /* Perform a quick check so we don't blow up below.  */\n+  if (count <= i\n+      || GET_CODE (XVECEXP (op, 0, i - 1)) != SET\n+      || GET_CODE (SET_DEST (XVECEXP (op, 0, i - 1))) != REG\n+      || GET_CODE (SET_SRC (XVECEXP (op, 0, i - 1))) != MEM)\n+    return 0;\n+\n+  dest_regno = REGNO (SET_DEST (XVECEXP (op, 0, i - 1)));\n+  src_addr = XEXP (SET_SRC (XVECEXP (op, 0, i - 1)), 0);\n+\n+  for (; i < count; i++)\n+    {\n+      rtx elt = XVECEXP (op, 0, i);\n+\n+      if (GET_CODE (elt) != SET\n+          || GET_CODE (SET_DEST (elt)) != REG\n+          || GET_MODE (SET_DEST (elt)) != SImode\n+          || REGNO (SET_DEST (elt)) != dest_regno + i - base\n+          || GET_CODE (SET_SRC (elt)) != MEM\n+          || GET_MODE (SET_SRC (elt)) != SImode\n+          || GET_CODE (XEXP (SET_SRC (elt), 0)) != PLUS\n+          || ! rtx_equal_p (XEXP (XEXP (SET_SRC (elt), 0), 0), src_addr)\n+          || GET_CODE (XEXP (XEXP (SET_SRC (elt), 0), 1)) != CONST_INT\n+          || INTVAL (XEXP (XEXP (SET_SRC (elt), 0), 1)) != (i - base) * 4)\n+        return 0;\n+    }\n+\n+  return 1;\n+}\n+\n+/* Return 1 if OP is a store multiple operation.  It is known to be\n+   parallel and the first section will be tested. */\n+\n+store_multiple_operation (op, mode)\n+     rtx op;\n+     enum machine_mode mode;\n+{\n+  int count = XVECLEN (op, 0);\n+  int src_regno;\n+  rtx dest_addr;\n+  int i = 1, base = 0;\n+  rtx elt;\n+\n+  if (count <= 1\n+      || GET_CODE (XVECEXP (op, 0, 0)) != SET)\n+    return 0;\n+\n+  /* Check to see if this might be a write-back */\n+  if (GET_CODE (SET_SRC (elt = XVECEXP (op, 0, 0))) == PLUS)\n+    {\n+      i++;\n+      base = 1;\n+\n+      /* Now check it more carefully */\n+      if (GET_CODE (SET_DEST (elt)) != REG\n+          || GET_CODE (XEXP (SET_SRC (elt), 0)) != REG\n+          || REGNO (XEXP (SET_SRC (elt), 0)) != REGNO (SET_DEST (elt))\n+          || GET_CODE (XEXP (SET_SRC (elt), 1)) != CONST_INT\n+          || INTVAL (XEXP (SET_SRC (elt), 1)) != (count - 2) * 4\n+          || GET_CODE (XVECEXP (op, 0, count - 1)) != CLOBBER\n+          || GET_CODE (XEXP (XVECEXP (op, 0, count - 1), 0)) != REG\n+          || REGNO (XEXP (XVECEXP (op, 0, count - 1), 0))\n+              != REGNO (SET_DEST (elt)))\n+        return 0;\n+      count--;\n+    }\n+\n+  /* Perform a quick check so we don't blow up below.  */\n+  if (count <= i\n+      || GET_CODE (XVECEXP (op, 0, i - 1)) != SET\n+      || GET_CODE (SET_DEST (XVECEXP (op, 0, i - 1))) != MEM\n+      || GET_CODE (SET_SRC (XVECEXP (op, 0, i - 1))) != REG)\n+    return 0;\n+\n+  src_regno = REGNO (SET_SRC (XVECEXP (op, 0, i - 1)));\n+  dest_addr = XEXP (SET_DEST (XVECEXP (op, 0, i - 1)), 0);\n+\n+  for (; i < count; i++)\n+    {\n+      elt = XVECEXP (op, 0, i);\n+\n+      if (GET_CODE (elt) != SET\n+          || GET_CODE (SET_SRC (elt)) != REG\n+          || GET_MODE (SET_SRC (elt)) != SImode\n+          || REGNO (SET_SRC (elt)) != src_regno + i - base\n+          || GET_CODE (SET_DEST (elt)) != MEM\n+          || GET_MODE (SET_DEST (elt)) != SImode\n+          || GET_CODE (XEXP (SET_DEST (elt), 0)) != PLUS\n+          || ! rtx_equal_p (XEXP (XEXP (SET_DEST (elt), 0), 0), dest_addr)\n+          || GET_CODE (XEXP (XEXP (SET_DEST (elt), 0), 1)) != CONST_INT\n+          || INTVAL (XEXP (XEXP (SET_DEST (elt), 0), 1)) != (i - base) * 4)\n+        return 0;\n+    }\n+\n+  return 1;\n+}\n+\f\n+/* Routines for use in generating RTL */\n+\n+rtx arm_gen_load_multiple (base_regno, count, from, up, write_back)\n+     int base_regno;\n+     int count;\n+     rtx from;\n+     int up;\n+     int write_back;\n+{\n+  int i = 0, j;\n+  rtx result;\n+  int sign = up ? 1 : -1;\n+\n+  result = gen_rtx (PARALLEL, VOIDmode,\n+                    rtvec_alloc (count + (write_back ? 2 : 0)));\n+  if (write_back)\n+  {\n+      XVECEXP (result, 0, 0)\n+          = gen_rtx (SET, GET_MODE (from), from,\n+                     plus_constant (from, count * 4 * sign));\n+      i = 1;\n+      count++;\n+  }\n+  for (j = 0; i < count; i++, j++)\n+  {\n+      XVECEXP (result, 0, i)\n+          = gen_rtx (SET, VOIDmode, gen_rtx (REG, SImode, base_regno + j),\n+                     gen_rtx (MEM, SImode,\n+                              plus_constant (from, j * 4 * sign)));\n+  }\n+  if (write_back)\n+    XVECEXP (result, 0, i) = gen_rtx (CLOBBER, SImode, from);\n+\n+  return result;\n+}\n+\n+rtx arm_gen_store_multiple (base_regno, count, to, up, write_back)\n+     int base_regno;\n+     int count;\n+     rtx to;\n+     int up;\n+     int write_back;\n+{\n+  int i = 0, j;\n+  rtx result;\n+  int sign = up ? 1 : -1;\n+\n+  result = gen_rtx (PARALLEL, VOIDmode,\n+                    rtvec_alloc (count + (write_back ? 2 : 0)));\n+  if (write_back)\n+  {\n+      XVECEXP (result, 0, 0)\n+          = gen_rtx (SET, GET_MODE (to), to,\n+                     plus_constant (to, count * 4 * sign));\n+      i = 1;\n+      count++;\n+  }\n+  for (j = 0; i < count; i++, j++)\n+  {\n+      XVECEXP (result, 0, i)\n+          = gen_rtx (SET, VOIDmode,\n+                     gen_rtx (MEM, SImode, plus_constant (to, j * 4 * sign)),\n+                     gen_rtx (REG, SImode, base_regno + j));\n+  }\n+  if (write_back)\n+    XVECEXP (result, 0, i) = gen_rtx (CLOBBER, SImode, to);\n+\n+  return result;\n+}\n+\n+/* X and Y are two things to compare using CODE.  Emit the compare insn and\n+   return the rtx for register 0 in the proper mode.  FP means this is a\n+   floating point compare: I don't think that it is needed on the arm.  */\n+\n+rtx\n+gen_compare_reg (code, x, y, fp)\n+     enum rtx_code code;\n+     rtx x, y;\n+{\n+  enum machine_mode mode = SELECT_CC_MODE (code, x, y);\n+  rtx cc_reg = gen_rtx (REG, mode, 24);\n+\n+  emit_insn (gen_rtx (SET, VOIDmode, cc_reg,\n+                      gen_rtx (COMPARE, mode, x, y)));\n+\n+  return cc_reg;\n+}\n+\n+\f\n+/* Check to see if a branch is forwards or backwards.  Return TRUE if it\n+   is backwards.  */\n+\n+int\n+arm_backwards_branch (from, to)\n+int from, to;\n+{\n+  return (insn_addresses[to] < insn_addresses[from]);\n+}\n+\n+/* Check to see if a branch is within the distance that can be done using\n+   an arithmetic expression. */\n+int\n+short_branch (from, to)\n+int from, to;\n+{\n+  int delta = insn_addresses[from] + 2 - insn_addresses[to];\n+\n+  return abs (delta) < 245;\t/* A small margin for safety */\n+}\n+\n+/* Check to see that the insn isn't the target of the conditionalizing\n+   code */\n+int\n+arm_insn_not_targeted (insn)\n+rtx insn;\n+{\n+  return insn != arm_target_insn;\n+}\n+\n \f\n /* Routines to output assembly language.  */\n \n+/* fp_immediate_constant \n+   if the rtx is the correct value then return the string of the number.\n+   In this way we can ensure that valid double constants are generated even\n+   when cross compiling. */\n+char *\n+fp_immediate_constant (x)\n+rtx (x);\n+{\n+  REAL_VALUE_TYPE r;\n+  int i;\n+  \n+  if (!fpa_consts_inited)\n+    init_fpa_table ();\n+  \n+  REAL_VALUE_FROM_CONST_DOUBLE (r, x);\n+  for (i = 0; i < 8; i++)\n+    if (REAL_VALUES_EQUAL (r, values_fpa[i]))\n+      return strings_fpa[i];\n+  abort ();\n+}\n+\n+\n /* Output the operands of a LDM/STM instruction to STREAM.\n    MASK is the ARM register set mask of which only bits 0-15 are important.\n    INSTR is the possibly suffixed base register.  HAT unequals zero if a hat\n@@ -289,6 +862,134 @@ output_call (operands)\n   return (\"\");\n } /* output_call */\n \n+static int\n+eliminate_lr2ip (x)\n+rtx *x;\n+{\n+  int something_changed = 0;\n+  rtx x0 = *x;\n+  int code = GET_CODE (x0);\n+  register int i, j;\n+  register char *fmt;\n+  \n+  switch (code)\n+    {\n+    case REG:\n+      if (REGNO (x0) == 14)\n+        {\n+\t  *x = gen_rtx (REG, SImode, 12);\n+\t  return 1;\n+        }\n+      return 0;\n+    default:\n+      /* Scan through the sub-elements and change any references there */\n+      fmt = GET_RTX_FORMAT (code);\n+      for (i = GET_RTX_LENGTH (code) - 1; i >= 0; i--)\n+\tif (fmt[i] == 'e')\n+\t  something_changed |= eliminate_lr2ip (&XEXP (x0, i));\n+\telse if (fmt[i] == 'E')\n+\t  for (j = 0; j < XVECLEN (x0, i); j++)\n+\t    something_changed |= eliminate_lr2ip (&XVECEXP (x0, i, j));\n+      return something_changed;\n+    }\n+}\n+  \n+/* Output a 'call' insn that is a reference in memory. */\n+\n+char *\n+output_call_mem (operands)\n+\trtx operands[];\n+{\n+  operands[0] = copy_rtx (operands[0]); /* Be ultra careful */\n+  /* Handle calls using lr by using ip (which may be clobbered in subr anyway).\n+   */\n+  if (eliminate_lr2ip (&operands[0]))\n+    arm_output_asm_insn (\"mov\\tip, lr\", operands);\n+  arm_output_asm_insn (\"mov\\tlr, pc\", operands);\n+  arm_output_asm_insn (\"ldr\\tpc, %0\", operands);\n+  return (\"\");\n+} /* output_call */\n+\n+\n+/* Output a move from arm registers to an fpu registers.\n+   OPERANDS[0] is an fpu register.\n+   OPERANDS[1] is the first registers of an arm register pair.  */\n+\n+char *\n+output_mov_long_double_fpu_from_arm (operands)\n+     rtx operands[];\n+{\n+  int arm_reg0 = REGNO (operands[1]);\n+  rtx ops[3];\n+\n+  if (arm_reg0 == 12)\n+    abort();\n+  ops[0] = gen_rtx (REG, SImode, arm_reg0);\n+  ops[1] = gen_rtx (REG, SImode, 1 + arm_reg0);\n+  ops[2] = gen_rtx (REG, SImode, 2 + arm_reg0);\n+  \n+  arm_output_asm_insn (\"stmfd\\tsp!, {%0, %1, %2}\", ops);\n+  arm_output_asm_insn (\"ldfe\\t%0, [sp], #12\", operands);\n+  return (\"\");\n+} /* output_mov_long_double_fpu_from_arm */\n+\n+/* Output a move from an fpu register to arm registers.\n+   OPERANDS[0] is the first registers of an arm register pair.\n+   OPERANDS[1] is an fpu register.  */\n+\n+char *\n+output_mov_long_double_arm_from_fpu (operands)\n+     rtx operands[];\n+{\n+  int arm_reg0 = REGNO (operands[0]);\n+  rtx ops[3];\n+\n+  if (arm_reg0 == 12)\n+    abort();\n+  ops[0] = gen_rtx (REG, SImode, arm_reg0);\n+  ops[1] = gen_rtx (REG, SImode, 1 + arm_reg0);\n+  ops[2] = gen_rtx (REG, SImode, 2 + arm_reg0);\n+\n+  arm_output_asm_insn (\"stfe\\t%1, [sp, #-12]!\", operands);\n+  arm_output_asm_insn (\"ldmfd\\tsp!, {%0, %1, %2}\", ops);\n+  return(\"\");\n+} /* output_mov_long_double_arm_from_fpu */\n+\n+/* Output a move from arm registers to arm registers of a long double\n+   OPERANDS[0] is the destination.\n+   OPERANDS[1] is the source.  */\n+char *\n+output_mov_long_double_arm_from_arm (operands)\n+rtx operands[];\n+{\n+  /* We have to be careful here because the two might overlap */\n+  int dest_start = REGNO (operands[0]);\n+  int src_start = REGNO (operands[1]);\n+  rtx ops[2];\n+  int i;\n+\n+  if (dest_start < src_start)\n+    {\n+      for (i = 0; i < 3; i++)\n+\t{\n+\t  ops[0] = gen_rtx (REG, SImode, dest_start + i);\n+\t  ops[1] = gen_rtx (REG, SImode, src_start + i);\n+\t  arm_output_asm_insn (\"mov\\t%0, %1\", ops);\n+\t}\n+    }\n+  else\n+    {\n+      for (i = 2; i >= 0; i--)\n+\t{\n+\t  ops[0] = gen_rtx (REG, SImode, dest_start + i);\n+\t  ops[1] = gen_rtx (REG, SImode, src_start + i);\n+\t  arm_output_asm_insn (\"mov\\t%0, %1\", ops);\n+\t}\n+    }\n+  return \"\";\n+}\n+\n+\n /* Output a move from arm registers to an fpu registers.\n    OPERANDS[0] is an fpu register.\n    OPERANDS[1] is the first registers of an arm register pair.  */\n@@ -371,26 +1072,51 @@ output_move_double (operands)\n \t\t\t\t CONST_DOUBLE_HIGH (operands[1]));\n \t  operands[1] = gen_rtx (CONST_INT, VOIDmode,\n \t\t\t\t CONST_DOUBLE_LOW (operands[1]));\n-\t  arm_output_asm_insn (\"mov\\t%0, %1\", operands);\n-\t  arm_output_asm_insn (\"mov\\t%0, %1\", otherops);\n+\t  output_mov_immediate (operands, FALSE, \"\");\n+\t  output_mov_immediate (otherops, FALSE, \"\");\n \t}\n       else if (code1 == CONST_INT)\n \t{\n \t  otherops[1] = const0_rtx;\n-\t  arm_output_asm_insn (\"mov\\t%0, %1\", operands);\n-\t  arm_output_asm_insn (\"mov\\t%0, %1\", otherops);\n+\t  /* sign extend the intval into the high-order word */\n+\t  /* Note: output_mov_immediate may clobber operands[1], so we\n+\t     put this out first */\n+\t  if (INTVAL (operands[1]) < 0)\n+\t    arm_output_asm_insn (\"mvn\\t%0, %1\", otherops);\n+\t  else\n+\t    arm_output_asm_insn (\"mov\\t%0, %1\", otherops);\n+\t  output_mov_immediate (operands, FALSE, \"\");\n \t}\n       else if (code1 == MEM)\n \t{\n-\t  if (GET_CODE (XEXP (operands[1], 0)) == REG)\n+\t  switch (GET_CODE (XEXP (operands[1], 0)))\n \t    {\n+\t    case REG:\n \t      /* Handle the simple case where address is [r, #0] more\n \t\t efficient.  */\n \t      operands[1] = XEXP (operands[1], 0);\n \t      arm_output_asm_insn (\"ldmia\\t%1, %M0\", operands);\n-\t    }\n-\t  else\n-\t    {\n+\t      break;\n+  \t    case PRE_INC:\n+\t      operands[1] = XEXP (XEXP (operands[1], 0), 0);\n+\t      arm_output_asm_insn (\"add\\t%1, %1, #8\", operands);\n+\t      arm_output_asm_insn (\"ldmia\\t%1, %M0\", operands);\n+\t      break;\n+\t    case PRE_DEC:\n+\t      operands[1] = XEXP (XEXP (operands[1], 0), 0);\n+\t      arm_output_asm_insn (\"sub\\t%1, %1, #8\", operands);\n+\t      arm_output_asm_insn (\"ldmia\\t%1, %M0\", operands);\n+\t      break;\n+\t    case POST_INC:\n+\t      operands[1] = XEXP (XEXP (operands[1], 0), 0);\n+\t      arm_output_asm_insn (\"ldmia\\t%1!, %M0\", operands);\n+\t      break;\n+\t    case POST_DEC:\n+\t      operands[1] = XEXP (XEXP (operands[1], 0), 0);\n+\t      arm_output_asm_insn (\"ldmia\\t%1, %M0\", operands);\n+\t      arm_output_asm_insn (\"sub\\t%1, %1, #8\", operands);\n+\t      break;\n+\t    default:\n \t      otherops[1] = adj_offsettable_operand (operands[1], 4);\n \t      /* Take care of overlapping base/data reg.  */\n \t      if (reg_mentioned_p (operands[0], operands[1]))\n@@ -411,14 +1137,32 @@ output_move_double (operands)\n     {\n       if (REGNO (operands[1]) == 12)\n \tabort();\n-\n-      if (GET_CODE (XEXP (operands[0], 0)) == REG)\n-\t{\n+      switch (GET_CODE (XEXP (operands[0], 0)))\n+        {\n+\tcase REG:\n \t  operands[0] = XEXP (operands[0], 0);\n \t  arm_output_asm_insn (\"stmia\\t%0, %M1\", operands);\n-\t}\n-      else\n-\t{\n+\t  break;\n+        case PRE_INC:\n+\t  operands[0] = XEXP (XEXP (operands[0], 0), 0);\n+\t  arm_output_asm_insn (\"add\\t%0, %0, #8\", operands);\n+\t  arm_output_asm_insn (\"stmia\\t%0, %M1\", operands);\n+\t  break;\n+        case PRE_DEC:\n+\t  operands[0] = XEXP (XEXP (operands[0], 0), 0);\n+\t  arm_output_asm_insn (\"sub\\t%0, %0, #8\", operands);\n+\t  arm_output_asm_insn (\"stmia\\t%0, %M1\", operands);\n+\t  break;\n+        case POST_INC:\n+\t  operands[0] = XEXP (XEXP (operands[0], 0), 0);\n+\t  arm_output_asm_insn (\"stmia\\t%0!, %M1\", operands);\n+\t  break;\n+        case POST_DEC:\n+\t  operands[0] = XEXP (XEXP (operands[0], 0), 0);\n+\t  arm_output_asm_insn (\"stmia\\t%0, %M1\", operands);\n+\t  arm_output_asm_insn (\"sub\\t%0, %0, #8\", operands);\n+\t  break;\n+        default:\n \t  otherops[0] = adj_offsettable_operand (operands[0], 4);\n \t  otherops[1] = gen_rtx (REG, SImode, 1 + REGNO (operands[1]));\n \t  arm_output_asm_insn (\"str\\t%1, %0\", operands);\n@@ -593,6 +1337,10 @@ shift_instr (op, shift_ptr)\n       mnem = \"lsr\";\n       max_shift = 32;\n       break;\n+    case MULT:\n+      *shift_ptr = gen_rtx (CONST_INT, VOIDmode,\n+\t\t\t    int_log2 (INTVAL (*shift_ptr)));\n+      return (\"asl\");\n     default:\n       abort();\n     }\n@@ -719,6 +1467,21 @@ output_shifted_move (op, operands)\n   return (arm_output_asm_insn (mnemonic, operands));\n } /* output_shifted_move */\n \n+char *\n+output_shift_compare (operands, neg)\n+rtx *operands;\n+int neg;\n+{\n+  char buf[80];\n+\n+  if (neg)\n+    sprintf (buf, \"cmn\\t%%1, %%3, %s %%4\", shift_instr (GET_CODE (operands[2]),\n+\t\t\t\t\t\t\t&operands[4]));\n+  else\n+    sprintf (buf, \"cmp\\t%%1, %%3, %s %%4\", shift_instr (GET_CODE (operands[2]),\n+\t\t\t\t\t\t\t&operands[4]));\n+  return arm_output_asm_insn (buf, operands);\n+} /* output_shift_compare */\n \n /* Output a .ascii pseudo-op, keeping track of lengths.  This is because\n    /bin/as is horribly restrictive.  */\n@@ -768,50 +1531,235 @@ output_ascii_pseudo_op (stream, p, len)\n   arm_increase_location (chars_so_far);\n } /* output_ascii_pseudo_op */\n \f\n+\n+/* Try to determine whether a pattern really clobbers the link register.\n+   This information is useful when peepholing, so that lr need not be pushed\n+   if we combine a call followed by a return */\n+\n+static int\n+pattern_really_clobbers_lr (x)\n+rtx x;\n+{\n+  int i;\n+  \n+  switch (GET_CODE (x))\n+    {\n+    case SET:\n+      switch (GET_CODE (SET_DEST (x)))\n+\t{\n+\tcase REG:\n+\t  return REGNO (SET_DEST (x)) == 14;\n+        case SUBREG:\n+\t  if (GET_CODE (XEXP (SET_DEST (x), 0)) == REG)\n+\t    return REGNO (XEXP (SET_DEST (x), 0)) == 14;\n+\t  abort ();\n+        default:\n+\t  return 0;\n+        }\n+    case PARALLEL:\n+      for (i = 0; i < XVECLEN (x, 0); i++)\n+\tif (pattern_really_clobbers_lr (XVECEXP (x, 0, i)))\n+\t  return 1;\n+      return 0;\n+    case CLOBBER:\n+      switch (GET_CODE (XEXP (x, 0)))\n+        {\n+\tcase REG:\n+\t  return REGNO (XEXP (x, 0)) == 14;\n+        case SUBREG:\n+\t  if (GET_CODE (XEXP (XEXP (x, 0), 0)) == REG)\n+\t    return REGNO (XEXP (XEXP (x, 0), 0)) == 14;\n+\t  abort ();\n+        default:\n+\t  return 0;\n+        }\n+    case UNSPEC:\n+      return 1;\n+    default:\n+      return 0;\n+    }\n+}\n+\n+static int\n+function_really_clobbers_lr (first)\n+rtx first;\n+{\n+  rtx insn, next;\n+  \n+  for (insn = first; insn; insn = next_nonnote_insn (insn))\n+    {\n+      switch (GET_CODE (insn))\n+        {\n+\tcase BARRIER:\n+\tcase NOTE:\n+\tcase CODE_LABEL:\n+\tcase JUMP_INSN:\t\t/* Jump insns only change the PC (and conds) */\n+\tcase INLINE_HEADER:\n+\t  break;\n+        case INSN:\n+\t  if (pattern_really_clobbers_lr (PATTERN (insn)))\n+\t    return 1;\n+\t  break;\n+        case CALL_INSN:\n+\t  /* Don't yet know how to handle those calls that are not to a \n+\t     SYMBOL_REF */\n+\t  if (GET_CODE (PATTERN (insn)) != PARALLEL)\n+\t    abort ();\n+\t  switch (GET_CODE (XVECEXP (PATTERN (insn), 0, 0)))\n+\t    {\n+\t    case CALL:\n+\t      if (GET_CODE (XEXP (XEXP (XVECEXP (PATTERN (insn), 0, 0), 0), 0))\n+\t\t  != SYMBOL_REF)\n+\t\treturn 1;\n+\t      break;\n+\t    case SET:\n+\t      if (GET_CODE (XEXP (XEXP (SET_SRC (XVECEXP (PATTERN (insn),\n+\t\t\t\t\t\t\t  0, 0)), 0), 0))\n+\t\t  != SYMBOL_REF)\n+\t\treturn 1;\n+\t      break;\n+\t    default:\t/* Don't recognize it, be safe */\n+\t      return 1;\n+\t    }\n+\t  /* A call can be made (by peepholing) not to clobber lr iff it is\n+\t     followed by a return.  There may, however, be a use insn iff\n+\t     we are returning the result of the call. \n+\t     If we run off the end of the insn chain, then that means the\n+\t     call was at the end of the function.  Unfortunately we don't\n+\t     have a return insn for the peephole to recognize, so we\n+\t     must reject this.  (Can this be fixed by adding our own insn?) */\n+\t  if ((next = next_nonnote_insn (insn)) == NULL)\n+\t    return 1;\n+\t  if (GET_CODE (next) == INSN && GET_CODE (PATTERN (next)) == USE\n+\t      && (GET_CODE (XVECEXP (PATTERN (insn), 0, 0)) == SET)\n+\t      && (REGNO (SET_DEST (XVECEXP (PATTERN (insn), 0, 0)))\n+\t\t  == REGNO (XEXP (PATTERN (next), 0))))\n+\t    if ((next = next_nonnote_insn (next)) == NULL)\n+\t      return 1;\n+\t  if (GET_CODE (next) == JUMP_INSN\n+\t      && GET_CODE (PATTERN (next)) == RETURN)\n+\t    break;\n+\t  return 1;\n+        default:\n+\t  abort ();\n+        }\n+    }\n+  /* We have reached the end of the chain so lr was _not_ clobbered */\n+  return 0;\n+}\n+\n+char *\n+output_return_instruction (operand, really_return)\n+rtx operand;\n+int really_return;\n+{\n+  char instr[100];\n+  int reg, live_regs = 0;\n+\n+  if (current_function_calls_alloca && !really_return)\n+    abort();\n+    \n+  for (reg = 4; reg < 10; reg++)\n+    if (regs_ever_live[reg])\n+      live_regs++;\n+\n+  if (live_regs || (regs_ever_live[14] && !lr_save_eliminated))\n+    live_regs++;\n+\n+  if (frame_pointer_needed)\n+    live_regs += 4;\n+\n+  if (live_regs)\n+    {\n+      if (lr_save_eliminated || !regs_ever_live[14])\n+        live_regs++;\n+      if (frame_pointer_needed)\n+        strcpy (instr, \"ldm%d0ea\\tfp, {\");\n+      else\n+        strcpy (instr, \"ldm%d0fd\\tsp!, {\");\n+      for (reg = 4; reg < 10; reg++)\n+        if (regs_ever_live[reg])\n+          {\n+            strcat (instr, reg_names[reg]);\n+\t    if (--live_regs)\n+              strcat (instr, \", \");\n+          }\n+      if (frame_pointer_needed)\n+        {\n+          strcat (instr, reg_names[11]);\n+          strcat (instr, \", \");\n+          strcat (instr, reg_names[13]);\n+          strcat (instr, \", \");\n+          strcat (instr, really_return ? reg_names[15] : reg_names[14]);\n+        }\n+      else\n+        strcat (instr, really_return ? reg_names[15] : reg_names[14]);\n+      strcat (instr, (TARGET_6 || !really_return) ? \"}\" : \"}^\");\n+      arm_output_asm_insn (instr, &operand);\n+    }\n+  else if (really_return)\n+    {\n+      strcpy (instr, TARGET_6 ? \"mov%d0\\tpc, lr\" : \"mov%d0s\\tpc, lr\");\n+      arm_output_asm_insn (instr, &operand);\n+    }\n+  return_used_this_function = 1;\n+  return \"\";\n+}\n+\n+/* The amount of stack adjustment that happens here, in output_return and in\n+   output_epilogue must be exactly the same as was calculated during reload,\n+   or things will point to the wrong place.  The only time we can safely\n+   ignore this constraint is when a function has no arguments on the stack,\n+   no stack frame requirement and no live registers execpt for `lr'.  If we\n+   can guarantee that by making all function calls into tail calls and that\n+   lr is not clobbered in any other way, then there is no need to push lr\n+   onto the stack. */\n+   \n void\n output_prologue (f, frame_size)\n      FILE *f;\n      int frame_size;\n {\n-\n   int reg, live_regs_mask = 0, code_size = 0;\n   rtx operands[3];\n \n-  /* Nonzero if the `fp' (argument pointer) register is needed.  */\n-  int fp_needed = 0;\n-\n   /* Nonzero if we must stuff some register arguments onto the stack as if\n      they were passed there.  */\n   int store_arg_regs = 0;\n \n+  return_used_this_function = 0;\n+  lr_save_eliminated = 0;\n+  \n   fprintf (f, \"\\t@ args = %d, pretend = %d, frame = %d\\n\",\n-\t   current_function_args_size, current_function_pretend_args_size, frame_size);\n-  fprintf (f, \"\\t@ frame_pointer_needed = %d, current_function_anonymous_args = %d\\n\",\n+\t   current_function_args_size, current_function_pretend_args_size,\n+\t   frame_size);\n+  fprintf (f, \"\\t@ frame_needed = %d, current_function_anonymous_args = %d\\n\",\n \t   frame_pointer_needed, current_function_anonymous_args);\n \n-  if (current_function_pretend_args_size || current_function_args_size\n-      || frame_pointer_needed || current_function_anonymous_args || TARGET_APCS)\n-    fp_needed = 1;\n-\n   if (current_function_anonymous_args && current_function_pretend_args_size)\n     store_arg_regs = 1;\n \n   for (reg = 4; reg < 10; reg++)\n     if (regs_ever_live[reg])\n       live_regs_mask |= (1 << reg);\n \n-  if (fp_needed)\n+  if (frame_pointer_needed)\n     {\n       live_regs_mask |= 0xD800;\n-      /* The following statement is probably redundant now\n-\t because the frame pointer is recorded in regs_ever_live.  */\n-      if (frame_pointer_needed)\n-\tlive_regs_mask |= (1 << FRAME_POINTER_REGNUM);\n       fputs (\"\\tmov\\tip, sp\\n\", f);\n       code_size += 4;\n     }\n   else if (regs_ever_live[14])\n-    live_regs_mask |= 0x4000;\n+    {\n+      if (! current_function_args_size\n+\t  && !function_really_clobbers_lr (get_insns ()))\n+\t{\n+\t  fprintf (f,\"\\t@ I don't think this function clobbers lr\\n\");\n+\t  lr_save_eliminated = 1;\n+        }\n+      else\n+        live_regs_mask |= 0x4000;\n+    }\n \n   /* If CURRENT_FUNCTION_PRETEND_ARGS_SIZE, adjust the stack pointer to make\n      room.  If also STORE_ARG_REGS store the argument registers involved in\n@@ -827,6 +1775,7 @@ output_prologue (f, frame_size)\n \t       arg_size > 0; reg--, arg_size -= 4)\n \t    mask |= (1 << reg);\n \t  print_multi_reg (f, \"stmfd\\tsp!\", mask, FALSE);\n+\t  code_size += 4;\n \t}\n       else\n \t{\n@@ -839,6 +1788,13 @@ output_prologue (f, frame_size)\n \n   if (live_regs_mask)\n     {\n+      /* if a di mode load/store multiple is used, and the base register\n+\t is r3, then r4 can become an ever live register without lr\n+\t doing so,  in this case we need to push lr as well, or we\n+\t will fail to get a proper return. */\n+\n+      live_regs_mask |= 0x4000;\n+      lr_save_eliminated = 0;\n       print_multi_reg (f, \"stmfd\\tsp!\", live_regs_mask, FALSE);\n       code_size += 4;\n     }\n@@ -850,23 +1806,17 @@ output_prologue (f, frame_size)\n \tcode_size += 4;\n       }\n \n-  if (fp_needed)\n+  if (frame_pointer_needed)\n     {\n       /* Make `fp' point to saved value of `pc'. */\n \n-      operands[0] = arg_pointer_rtx;\n+      operands[0] = gen_rtx (REG, SImode, HARD_FRAME_POINTER_REGNUM);\n       operands[1] = gen_rtx (REG, SImode, 12);\n       operands[2] = gen_rtx (CONST_INT, VOIDmode,\n \t\t\t     - (4 + current_function_pretend_args_size));\n       output_add_immediate (operands);\n     }\n \n-  if (frame_pointer_needed)\n-    {\n-      fprintf (f, \"\\tmov\\trfp, sp\\n\");\n-      code_size += 4;\n-    }\n-\n   if (frame_size)\n     {\n       operands[0] = operands[1] = stack_pointer_rtx;\n@@ -884,36 +1834,41 @@ output_epilogue (f, frame_size)\n      int frame_size;\n {\n   int reg, live_regs_mask = 0, code_size = 0, fp_needed = 0;\n+  /* If we need this then it will always be at lesat this much */\n+  int floats_offset = 24;\n   rtx operands[3];\n \n-  if (current_function_pretend_args_size || current_function_args_size\n-      || frame_pointer_needed || current_function_anonymous_args || TARGET_APCS)\n-    fp_needed = 1;\n-\n-  for (reg = 4; reg < 10; reg++)\n-    if (regs_ever_live[reg])\n-      live_regs_mask |= (1 << reg);\n-\n-  if (fp_needed)\n+  if (use_return_insn() && return_used_this_function)\n     {\n-      live_regs_mask |= 0xA800;\n-      if (frame_pointer_needed)\n-        live_regs_mask |= (1 << FRAME_POINTER_REGNUM);\n+      if (frame_size && !(frame_pointer_needed || TARGET_APCS))\n+        {\n+          abort ();\n+        }\n+      return;\n     }\n-  else if (regs_ever_live[14])\n-    live_regs_mask |= 0x4000;\n \n-  for (reg = 20; reg < 24; reg++)\n+  for (reg = 4; reg <= 10; reg++)\n     if (regs_ever_live[reg])\n       {\n-\tfprintf (f, \"\\tldfe\\t%s, [%s], #12\\n\", reg_names[reg],\n-\t\t frame_pointer_needed ? \"rfp\" : \"sp\");\n-\tcode_size += 4;\n+        live_regs_mask |= (1 << reg);\n+\tfloats_offset += 4;\n       }\n \n-  if (fp_needed)\n+\n+  if (frame_pointer_needed)\n     {\n-      print_multi_reg (f, \"ldmea\\tfp\", live_regs_mask, TRUE);\n+      for (reg = 23; reg >= 20; reg--)\n+\tif (regs_ever_live[reg])\n+\t  {\n+\t    fprintf (f, \"\\tldfe\\t%s, [fp, #-%d]\\n\", reg_names[reg],\n+\t\t     floats_offset);\n+\t    floats_offset += 12;\n+\t    code_size += 4;\n+\t  }\n+\n+      live_regs_mask |= 0xA800;\n+      print_multi_reg (f, \"ldmea\\tfp\", live_regs_mask,\n+\t\t       TARGET_6 ? FALSE : TRUE);\n       code_size += 4;\n     }\n   else\n@@ -926,16 +1881,23 @@ output_epilogue (f, frame_size)\n \t  output_add_immediate (operands);\n \t}\n \n+      for (reg = 20; reg < 24; reg++)\n+\tif (regs_ever_live[reg])\n+\t  {\n+\t    fprintf (f, \"\\tldfe\\t%s, [sp], #12\\n\", reg_names[reg]);\n+\t    code_size += 4;\n+\t  }\n       if (current_function_pretend_args_size == 0 && regs_ever_live[14])\n \t{\n-\t  print_multi_reg (f, \"ldmfd\\tsp!\",\n-\t\t\t   (live_regs_mask & ~0x4000) | 0x8000, TRUE);\n+\t  print_multi_reg (f, \"ldmfd\\tsp!\", live_regs_mask | 0x8000,\n+\t\t\t   TARGET_6 ? FALSE : TRUE);\n \t  code_size += 4;\n \t}\n       else\n \t{\n-\t  if (live_regs_mask)\n+\t  if (live_regs_mask || regs_ever_live[14])\n \t    {\n+\t      live_regs_mask |= 0x4000;\n \t      print_multi_reg (f, \"ldmfd\\tsp!\", live_regs_mask, FALSE);\n \t      code_size += 4;\n \t    }\n@@ -946,7 +1908,7 @@ output_epilogue (f, frame_size)\n \t\t\t\t     current_function_pretend_args_size);\n \t      output_add_immediate (operands);\n \t    }\n-\t  fputs (\"\\tmovs\\tpc, lr\\n\", f);\n+\t  fputs (TARGET_6 ? \"\\tmov\\tpc, lr\\n\" : \"\\tmovs\\tpc, lr\\n\", f);\n \t  code_size += 4;\n \t}\n     }\n@@ -1086,6 +2048,72 @@ arm_output_llc (operands)\n   return (\"\");\n } /* arm_output_llc */\n \n+/* output_load_symbol ()\n+   load a symbol that is known to be in the text segment into a register */\n+\n+char *\n+output_load_symbol (operands)\n+rtx *operands;\n+{\n+  char *s, *name = XSTR (operands[1], 0);\n+  struct label_offset *he;\n+  int hash = 0;\n+  int offset;\n+  \n+  if (*name != '*')\n+    abort ();\n+\n+  for (s = &name[1]; *s; s++)\n+    hash += *s;\n+  hash = hash % LABEL_HASH_SIZE;\n+  he = offset_table[hash];\n+  while (he && strcmp (he->name, &name[1]))\n+    he = he->cdr;\n+  \n+  if (!he)\n+    abort ();\n+  \n+  offset = (arm_text_location + 8 - he->offset);\n+  if (offset < 0)\n+    abort ();\n+\n+  /* If the symbol is word aligned then we might be able to reduce the\n+     number of loads */\n+  if ((offset & 3) == 0)\n+    {\n+      arm_output_asm_insn (\"sub\\t%0, pc, #(8 + . -%a1) & 1023\", operands);\n+      if (offset > 0x3ff)\n+        {\n+\t  arm_output_asm_insn (\"sub\\t%0, %0, #(4 + . -%a1) & 261120\",\n+\t\t\t       operands);\n+\t  if (offset > 0x3ffff)\n+\t    {\n+\t      arm_output_asm_insn (\"sub\\t%0, %0, #(. -%a1) & 66846720\",\n+\t\t\t\t   operands);\n+\t      if (offset > 0x3ffffff)\n+\t\tarm_output_asm_insn (\"sub\\t%0, %0, #(. - 4 -%a1) & -67108864\",\n+\t\t\t\t       operands);\n+\t    }\n+        }\n+    }\n+  else\n+    {\n+      arm_output_asm_insn (\"sub\\t%0, pc, #(8 + . -%a1) & 255\", operands);\n+      if (offset > 0x0ff)\n+        {\n+\t  arm_output_asm_insn (\"sub\\t%0, %0, #(4 + . -%a1) & 65280\", operands);\n+\t  if (offset > 0x0ffff)\n+\t    {\n+\t      arm_output_asm_insn (\"sub\\t%0, %0, #(. -%a1) & 16711680\",\n+\t\t\t\t   operands);\n+\t      if (offset > 0x0ffffff)\n+\t\tarm_output_asm_insn (\"sub\\t%0, %0, #(. - 4 -%a1) & -16777216\",\n+\t\t\t\t     operands);\n+\t    }\n+        }\n+    }\n+  return \"\";\n+}\n \n /* Output code resembling an .lcomm directive.  /bin/as doesn't have this\n    directive hence this hack, which works by reserving some `.space' in the\n@@ -1131,6 +2159,10 @@ output_lcomm_directive (stream, name, size, rounded)\n    4 -> 0 final_prescan_insn if the `target' unconditional branch is reached\n           (the target insn is arm_target_insn).\n \n+   If the jump clobbers the conditions then we use states 2 and 4.\n+\n+   A similar thing can be done with conditional return insns.\n+\n    XXX In case the `target' is an unconditional branch, this conditionalising\n    of the instructions always reduces code size, but not always execution\n    time.  But then, I want to reduce the code size to somewhere near what\n@@ -1185,6 +2217,15 @@ final_prescan_insn (insn, opvec, noperands)\n      reversed if it appears to fail.  */\n   int reverse = 0;\n \n+  /* JUMP_CLOBBERS will be one implies that the conditions if a branch is\n+     taken are clobbered, even if the rtl suggests otherwise.  It also\n+     means that we have to grub around within the jump expression to find\n+     out what the conditions are when the jump isn't taken.  */\n+  int jump_clobbers = 0;\n+  \n+  /* If we start with a return insn, we only succeed if we find another one. */\n+  int seeking_return = 0;\n+  \n   /* START_INSN will hold the insn from where we start looking.  This is the\n      first insn after the following code_label if REVERSE is true.  */\n   rtx start_insn = insn;\n@@ -1219,6 +2260,21 @@ final_prescan_insn (insn, opvec, noperands)\n \t  else\n \t    return;\n \t}\n+      else if (GET_CODE (body) == RETURN)\n+        {\n+\t  start_insn = next_nonnote_insn (start_insn);\n+\t  if (GET_CODE (start_insn) == BARRIER)\n+\t    start_insn = next_nonnote_insn (start_insn);\n+\t  if (GET_CODE (start_insn) == CODE_LABEL\n+\t      && CODE_LABEL_NUMBER (start_insn) == arm_target_label\n+\t      && LABEL_NUSES (start_insn) == 1)\n+\t    {\n+\t      reverse = TRUE;\n+\t      seeking_return = 1;\n+\t    }\n+\t  else\n+\t    return;\n+        }\n       else\n \treturn;\n     }\n@@ -1228,25 +2284,52 @@ final_prescan_insn (insn, opvec, noperands)\n   if (GET_CODE (insn) != JUMP_INSN)\n     return;\n \n+  /* This jump might be paralled with a clobber of the condition codes \n+     the jump should always come first */\n+  if (GET_CODE (body) == PARALLEL && XVECLEN (body, 0) > 0)\n+    body = XVECEXP (body, 0, 0);\n+\n+#if 0  \n+  /* If this is a conditional return then we don't want to know */\n+  if (GET_CODE (body) == SET && GET_CODE (SET_DEST (body)) == PC\n+      && GET_CODE (SET_SRC (body)) == IF_THEN_ELSE\n+      && (GET_CODE (XEXP (SET_SRC (body), 1)) == RETURN\n+          || GET_CODE (XEXP (SET_SRC (body), 2)) == RETURN))\n+    return;\n+#endif\n+\n   if (reverse\n       || (GET_CODE (body) == SET && GET_CODE (SET_DEST (body)) == PC\n \t  && GET_CODE (SET_SRC (body)) == IF_THEN_ELSE))\n     {\n       int insns_skipped = 0, fail = FALSE, succeed = FALSE;\n       /* Flag which part of the IF_THEN_ELSE is the LABEL_REF.  */\n       int then_not_else = TRUE;\n-      rtx this_insn = start_insn, label;\n+      rtx this_insn = start_insn, label = 0;\n \n+      if (get_attr_conds (insn) == CONDS_JUMP_CLOB)\n+\tjump_clobbers = 1;\n+      \n       /* Register the insn jumped to.  */\n       if (reverse)\n-\tlabel = XEXP (SET_SRC (body), 0);\n+        {\n+\t  if (!seeking_return)\n+\t    label = XEXP (SET_SRC (body), 0);\n+        }\n       else if (GET_CODE (XEXP (SET_SRC (body), 1)) == LABEL_REF)\n \tlabel = XEXP (XEXP (SET_SRC (body), 1), 0);\n       else if (GET_CODE (XEXP (SET_SRC (body), 2)) == LABEL_REF)\n \t{\n \t  label = XEXP (XEXP (SET_SRC (body), 2), 0);\n \t  then_not_else = FALSE;\n \t}\n+      else if (GET_CODE (XEXP (SET_SRC (body), 1)) == RETURN)\n+\tseeking_return = 1;\n+      else if (GET_CODE (XEXP (SET_SRC (body), 2)) == RETURN)\n+        {\n+\t  seeking_return = 1;\n+\t  then_not_else = FALSE;\n+        }\n       else\n \tabort ();\n \n@@ -1272,33 +2355,54 @@ final_prescan_insn (insn, opvec, noperands)\n \t\t control falls in from somewhere else.  */\n \t      if (this_insn == label)\n \t\t{\n-\t\t  arm_ccfsm_state = 1;\n+\t\t  if (jump_clobbers)\n+\t\t    {\n+\t\t      arm_ccfsm_state = 2;\n+\t\t      this_insn = next_nonnote_insn (this_insn);\n+\t\t    }\n+\t\t  else\n+\t\t    arm_ccfsm_state = 1;\n \t\t  succeed = TRUE;\n \t\t}\n \t      else\n \t\tfail = TRUE;\n \t      break;\n \n-\t    case BARRIER:\t/* XXX Is this case necessary?  */\n+\t    case BARRIER:\n \t      /* Succeed if the following insn is the target label.\n-\t\t Otherwise fail.  */\n+\t\t Otherwise fail.  \n+\t\t If return insns are used then the last insn in a function \n+\t\t will be a barrier. */\n \t      this_insn = next_nonnote_insn (this_insn);\n-\t      if (this_insn == label)\n+\t      if (this_insn && this_insn == label)\n \t\t{\n-\t\t  arm_ccfsm_state = 1;\n+\t\t  if (jump_clobbers)\n+\t\t    {\n+\t\t      arm_ccfsm_state = 2;\n+\t\t      this_insn = next_nonnote_insn (this_insn);\n+\t\t    }\n+\t\t  else\n+\t\t    arm_ccfsm_state = 1;\n \t\t  succeed = TRUE;\n \t\t}\n \t      else\n \t\tfail = TRUE;\n \t      break;\n \n+\t    case CALL_INSN:\n+\t      /* The arm 6xx uses full 32 bit addresses so the cc is not \n+\t\t preserved over calls */\n+\t      if (TARGET_6)\n+\t\tfail = TRUE;\n+\t      break;\n \t    case JUMP_INSN:\n       \t      /* If this is an unconditional branch to the same label, succeed.\n \t\t If it is to another label, do nothing.  If it is conditional,\n \t\t fail.  */\n \t      /* XXX Probably, the test for the SET and the PC are unnecessary. */\n \n-\t      if (GET_CODE (scanbody) == SET && GET_CODE (SET_DEST (scanbody)) == PC)\n+\t      if (GET_CODE (scanbody) == SET\n+\t\t  && GET_CODE (SET_DEST (scanbody)) == PC)\n \t\t{\n \t\t  if (GET_CODE (SET_SRC (scanbody)) == LABEL_REF\n \t\t      && XEXP (SET_SRC (scanbody), 0) == label && !reverse)\n@@ -1309,11 +2413,31 @@ final_prescan_insn (insn, opvec, noperands)\n \t\t  else if (GET_CODE (SET_SRC (scanbody)) == IF_THEN_ELSE)\n \t\t    fail = TRUE;\n \t\t}\n+\t      else if (GET_CODE (scanbody) == RETURN\n+\t\t       && seeking_return)\n+\t        {\n+\t\t  arm_ccfsm_state = 2;\n+\t\t  succeed = TRUE;\n+\t        }\n+\t      else if (GET_CODE (scanbody) == PARALLEL)\n+\t        {\n+\t\t  switch (get_attr_conds (this_insn))\n+\t\t    {\n+\t\t    case CONDS_NOCOND:\n+\t\t      break;\n+\t\t    default:\n+\t\t      fail = TRUE;\n+\t\t      break;\n+\t\t    }\n+\t\t}\n \t      break;\n \n \t    case INSN:\n-\t      /* Instructions affecting the condition codes make it fail.  */\n-\t      if (sets_cc0_p (scanbody))\n+\t      /* Instructions using or affecting the condition codes make it\n+\t\t fail.  */\n+\t      if ((GET_CODE (scanbody) == SET\n+\t\t   || GET_CODE (scanbody) == PARALLEL)\n+\t\t  && get_attr_conds (this_insn) != CONDS_NOCOND)\n \t\tfail = TRUE;\n \t      break;\n \n@@ -1323,20 +2447,57 @@ final_prescan_insn (insn, opvec, noperands)\n \t}\n       if (succeed)\n \t{\n-\t  if (arm_ccfsm_state == 1 || reverse)\n+\t  if ((!seeking_return) && (arm_ccfsm_state == 1 || reverse))\n \t    arm_target_label = CODE_LABEL_NUMBER (label);\n-\t  else if (arm_ccfsm_state == 2)\n-\t    arm_target_insn = this_insn;\n+\t  else if (seeking_return || arm_ccfsm_state == 2)\n+\t    {\n+\t      while (this_insn && GET_CODE (PATTERN (this_insn)) == USE)\n+\t        {\n+\t\t  this_insn = next_nonnote_insn (this_insn);\n+\t\t  if (this_insn && (GET_CODE (this_insn) == BARRIER\n+\t\t\t\t    || GET_CODE (this_insn) == CODE_LABEL))\n+\t\t    abort ();\n+\t        }\n+\t      if (!this_insn)\n+\t        {\n+\t\t  /* Oh, dear! we ran off the end.. give up */\n+\t\t  recog (PATTERN (insn), insn, NULL_PTR);\n+\t\t  arm_ccfsm_state = 0;\n+\t\t  return;\n+\t        }\n+\t      arm_target_insn = this_insn;\n+\t    }\n \t  else\n \t    abort ();\n+\t  if (jump_clobbers)\n+\t    {\n+\t      if (reverse)\n+\t\tabort ();\n+\t      arm_current_cc = \n+\t\t  get_arm_condition_code (XEXP (XEXP (XEXP (SET_SRC (body),\n+\t\t\t\t\t\t\t    0), 0), 1));\n+\t      if (GET_CODE (XEXP (XEXP (SET_SRC (body), 0), 0)) == AND)\n+\t\tarm_current_cc = ARM_INVERSE_CONDITION_CODE (arm_current_cc);\n+\t      if (GET_CODE (XEXP (SET_SRC (body), 0)) == NE)\n+\t\tarm_current_cc = ARM_INVERSE_CONDITION_CODE (arm_current_cc);\n+\t    }\n+\t  else\n+\t    {\n+\t      /* If REVERSE is true, ARM_CURRENT_CC needs to be inverted from\n+\t\t what it was.  */\n+\t      if (!reverse)\n+\t\tarm_current_cc = get_arm_condition_code (XEXP (SET_SRC (body),\n+\t\t\t\t\t\t\t       0));\n+\t    }\n \n-\t  /* If REVERSE is true, ARM_CURRENT_CC needs to be inverted from what\n-\t     it was.  */\n-\t  if (!reverse)\n-\t    arm_current_cc = get_arm_condition_code (XEXP (SET_SRC (body), 0));\n \t  if (reverse || then_not_else)\n \t    arm_current_cc = ARM_INVERSE_CONDITION_CODE (arm_current_cc);\n \t}\n+      /* restore recog_operand (getting the attributes of other insns can\n+\t destroy this array, but final.c assumes that it remains intact\n+\t accross this call; since the insn has been recognized already we\n+\t call recog direct). */\n+      recog (PATTERN (insn), insn, NULL_PTR);\n     }\n } /* final_prescan_insn */\n "}, {"sha": "f51b76fe9327062013d250ccb546e01474c18077", "filename": "gcc/config/arm/arm.h", "status": "modified", "additions": 715, "deletions": 216, "changes": 931, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff9940b0157fcda551e107ade4107291605fc285/gcc%2Fconfig%2Farm%2Farm.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff9940b0157fcda551e107ade4107291605fc285/gcc%2Fconfig%2Farm%2Farm.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.h?ref=ff9940b0157fcda551e107ade4107291605fc285", "patch": "@@ -2,7 +2,8 @@\n    Copyright (C) 1991, 1993 Free Software Foundation, Inc.\n    Contributed by Pieter `Tiggr' Schoenmakers (rcpieter@win.tue.nl)\n               and Martin Simmons (@harleqn.co.uk).\n-\n+   More major hacks by Richard Earnshaw (rwe11@cl.cam.ac.uk)\n+   \n This file is part of GNU CC.\n \n GNU CC is free software; you can redistribute it and/or modify\n@@ -27,30 +28,45 @@ extern void output_prologue ();\n extern void output_epilogue ();\n extern char *arm_output_asm_insn ();\n extern char *arm_output_llc ();\n+extern char *arithmetic_instr ();\n extern char *output_add_immediate ();\n extern char *output_call ();\n+extern char *output_call_mem ();\n extern char *output_move_double ();\n extern char *output_mov_double_fpu_from_arm ();\n extern char *output_mov_double_arm_from_fpu ();\n extern char *output_mov_immediate ();\n extern char *output_multi_immediate ();\n extern char *output_shifted_move ();\n+extern char *output_shift_compare ();\n extern char *output_arithmetic_with_immediate_multiply ();\n+extern char *output_arithmetic_with_shift ();\n+extern char *output_return_instruction ();\n+extern char *output_load_symbol ();\n+extern char *fp_immediate_constant ();\n+extern struct rtx_def *gen_compare_reg ();\n+extern struct rtx_def *arm_gen_store_multiple ();\n+extern struct rtx_def *arm_gen_load_multiple ();\n+\n+extern char *arm_condition_codes[];\n+\n+/* This is needed by the tail-calling peepholes */\n+extern int frame_pointer_needed;\n+\n \f\n-/* Translation to find startup files.  On RISCiX boxes, gcrt0.o is in\n-   /usr/lib.  */\n-#define STARTFILE_SPEC  \\\n-  \"%{pg:/usr/lib/gcrt0.o%s}%{!pg:%{p:mcrt0.o%s}%{!p:crt0.o%s}}\"\n+#ifndef CPP_PREDEFINES\n+#define CPP_PREDEFINES  \"-Darm -Acpu(arm) -Amachine(arm)\"\n+#endif\n \n-#ifdef riscos\n-#define CPP_PREDEFINES  \"-Darm -Driscos -Acpu(arm) -Amachine(arm)\"\n-#else\n-#define CPP_PREDEFINES  \"-Darm -Driscix -Dunix -Asystem(unix) -Acpu(arm) -Amachine(arm)\"\n+#ifndef CPP_SPEC\n+#define CPP_SPEC \"%{m6:-D__arm6__}\"\n #endif\n \f\n /* Run-time Target Specification.  */\n+#ifndef TARGET_VERSION\n #define TARGET_VERSION  \\\n-  fputs (\" (ARM/RISCiX)\", stderr);\n+  fputs (\" (ARM/generic)\", stderr);\n+#endif\n \n /* Run-time compilation parameters selecting different hardware subsets.\n    On the ARM, misuse it in a different way.  */\n@@ -70,14 +86,50 @@ extern int target_flags;\n    case instruction scheduling becomes very uninteresting.  */\n #define TARGET_FPE\t(target_flags & 4)\n \n+/* Nonzero if destined for an ARM6xx.  Takes out bits that assume restoration\n+   of condition flags when returning from a branch & link (ie. a function) */\n+#define TARGET_6        (target_flags & 8)\n+\n+/* ARM_EXTRA_TARGET_SWITCHES is used in riscix.h to define some options which\n+   are passed to the preprocessor and the assembler post-processor.  They\n+   aren't needed in the main pass of the compiler, but if we don't define\n+   them in target switches cc1 complains about them.  For the sake of\n+   argument lets allocate bit 31 of target flags for such options. */\n+\n+#ifndef ARM_EXTRA_TARGET_SWITCHES\n+#define ARM_EXTRA_TARGET_SWITCHES\n+#endif\n+\n #define TARGET_SWITCHES  \\\n {                         \t\t\t\\\n   {\"apcs\",\t\t 1},\t\t\t\\\n   {\"poke-function-name\", 2},\t\t\t\\\n   {\"fpe\",\t\t 4},\t\t\t\\\n+  {\"6\",\t\t\t 8},\t\t\t\\\n+  {\"2\",\t\t\t-8},\t\t\t\\\n+  {\"3\",\t\t\t-8},\t\t\t\\\n+  ARM_EXTRA_TARGET_SWITCHES\t\t\t\\\n   {\"\",   \t\t TARGET_DEFAULT }\t\\\n }\n \n+/* Which processor we are running on.  Currently this is only used to\n+   get the condition code clobbering attribute right when we are running on\n+   an arm 6 */\n+\n+enum processor_type \n+{\n+  PROCESSOR_ARM2,\n+  PROCESSOR_ARM3,\n+  PROCESSOR_ARM6\n+};\n+\n+/* Recast the cpu class to be the cpu attribute. */\n+\n+/* Recast the cpu class to be the cpu attribute.  */\n+#define arm_cpu_attr ((enum attr_cpu)arm_cpu)\n+\n+extern enum processor_type arm_cpu;\n+\n #define TARGET_DEFAULT  0\n \n #define TARGET_MEM_FUNCTIONS 1\n@@ -88,33 +140,77 @@ extern int target_flags;\n    - if floating point is done by emulation, forget about instruction\n      scheduling.  Note that this only saves compilation time; it doesn't\n      matter for the final code.  */\n-#ifdef riscos\n-#define TARGET_WHEN_DEBUGGING  3\n-#else\n+#ifndef TARGET_WHEN_DEBUGGING\n #define TARGET_WHEN_DEBUGGING  1\n #endif\n \n #define OVERRIDE_OPTIONS  \\\n {\t\t\t\t\t\t\t\t\\\n-  if (write_symbols != NO_DEBUG)\t\t\t\t\\\n-    target_flags |= TARGET_WHEN_DEBUGGING;\t\t\t\\\n-  else if (TARGET_POKE_FUNCTION_NAME)\t\t\t\t\\\n+  if (write_symbols != NO_DEBUG && flag_omit_frame_pointer)\t\\\n+    warning (\"-g without a frame pointer may not give sensible debugging\");\\\n+  if (TARGET_POKE_FUNCTION_NAME)\t\t\t\t\\\n     target_flags |= 1;\t\t\t\t\t\t\\\n   if (TARGET_FPE)\t\t\t\t\t\t\\\n     flag_schedule_insns = flag_schedule_insns_after_reload = 0;\t\\\n+  arm_cpu = TARGET_6 ? PROCESSOR_ARM6: PROCESSOR_ARM2;\t\t\\\n }\n \n /* Omitting the frame pointer is a very good idea on the ARM, especially if\n    not TARGET_APCS, in which case all that pushing on function entry isn't\n-   mandatory anymore.  */\n+   mandatory anymore.  \n+   Forcing loads to be explicit also allows cse to work better */\n+\n #define OPTIMIZATION_OPTIONS(OPTIMIZE)  \\\n {\t\t\t\t\t\\\n   if (OPTIMIZE)\t\t\t\t\\\n-    flag_omit_frame_pointer = 1;\t\\\n+    {\t\t\t\t\t\\\n+      flag_force_mem = 1;\t\t\\\n+      flag_omit_frame_pointer = 1;\t\\\n+    }\t\t\t\t\t\\\n }\n \f\n /* Target machine storage Layout.  */\n \n+\n+/* Define this macro if it is advisable to hold scalars in registers\n+   in a wider mode than that declared by the program.  In such cases,\n+   the value is constrained to be within the bounds of the declared\n+   type, but kept valid in the wider mode.  The signedness of the\n+   extension may differ from that of the type.  */\n+\n+/* It is far faster to zero extend chars than to sign extend them */\n+\n+#define PROMOTE_MODE(MODE,UNSIGNEDP,TYPE)  \\\n+  if (GET_MODE_CLASS (MODE) == MODE_INT \\\n+      && GET_MODE_SIZE (MODE) < 4)      \\\n+    {\t\t\t\t\t\\\n+      if (MODE == QImode)\t\t\\\n+\tUNSIGNEDP = 1;\t\t\t\\\n+      (MODE) = SImode;\t\t\t\\\n+    }\n+\n+/* Define for XFmode extended real floating point support.\n+   This will automatically cause REAL_ARITHMETIC to be defined.  */\n+/* For the ARM:\n+   I think I have added all the code to make this work.  Unfortunately,\n+   early releases of the floating point emulation code on RISCiX used a\n+   different format for extended precision numbers.  On my RISCiX box there\n+   is a bug somewhere which causes the machine to lock up when running enquire\n+   with long doubles.  There is the additional aspect that Norcroft C\n+   treats long doubles as doubles and we ought to remain compatible.\n+   Perhaps someone with an FPA coprocessor and not running RISCiX would like\n+   to try this someday. */\n+/* #define LONG_DOUBLE_TYPE_SIZE 96 */\n+\n+/* Disable XFmode patterns in md file */\n+#define ENABLE_XF_PATTERNS 0\n+\n+/* Define if you don't want extended real, but do want to use the\n+   software floating point emulator for REAL_ARITHMETIC and\n+   decimal <-> binary conversion. */\n+/* See comment above */\n+#define REAL_ARITHMETIC\n+\n /* Define this if most significant bit is lowest numbered\n    in instructions that operate on numbered bit-fields.  */\n #define BITS_BIG_ENDIAN  0\n@@ -145,11 +241,20 @@ extern int target_flags;\n \n #define BIGGEST_ALIGNMENT  32\n \n+/* Make strings word-aligned so strcpy from constants will be faster.  */\n+#define CONSTANT_ALIGNMENT(EXP, ALIGN)  \\\n+  (TREE_CODE (EXP) == STRING_CST        \\\n+   && (ALIGN) < BITS_PER_WORD ? BITS_PER_WORD : (ALIGN))\n+\n /* Every structures size must be a multiple of 32 bits.  */\n #define STRUCTURE_SIZE_BOUNDARY 32\n \n+/* Non-zero if move instructions will actually fail to work\n+   when given unaligned data.  */\n #define STRICT_ALIGNMENT 1\n \n+#define TARGET_FLOAT_FORMAT IEEE_FLOAT_FORMAT\n+\n /* Define number of bits in most basic integer type.\n    (If undefined, default is BITS_PER_WORD).  */\n /* #define INT_TYPE_SIZE */\n@@ -177,31 +282,68 @@ extern int target_flags;\n \n \tf4-f7\t     S\tfloating point variable\n \n+\tcc\t\tThis is NOT a real register, but is used internally\n+\t                to represent things that use or set the condition\n+\t\t\tcodes.\n+\tsfp             This isn't either.  It is used during rtl generation\n+\t                since the offset between the frame pointer and the\n+\t\t\tauto's isn't known until after register allocation.\n+\tafp\t\tNor this, we only need this because of non-local\n+\t                goto.  Without it fp appears to be used and the\n+\t\t\telimination code won't get rid of sfp.  It tracks\n+\t\t\tfp exactly at all times.\n+\n    *: See CONDITIONAL_REGISTER_USAGE  */\n \n-/* The number of hard registers is 16 ARM + 8 FPU.  */\n-#define FIRST_PSEUDO_REGISTER  24\n+/* The stack backtrace structure is as follows:\n+  fp points to here:  |  save code pointer  |      [fp]\n+                      |  return link value  |      [fp, #-4]\n+                      |  return sp value    |      [fp, #-8]\n+                      |  return fp value    |      [fp, #-12]\n+                     [|  saved r10 value    |]\n+                     [|  saved r9 value     |]\n+                     [|  saved r8 value     |]\n+                     [|  saved r7 value     |]\n+                     [|  saved r6 value     |]\n+                     [|  saved r5 value     |]\n+                     [|  saved r4 value     |]\n+                     [|  saved r3 value     |]\n+                     [|  saved r2 value     |]\n+                     [|  saved r1 value     |]\n+                     [|  saved r0 value     |]\n+                     [|  saved f7 value     |]     three words\n+                     [|  saved f6 value     |]     three words\n+                     [|  saved f5 value     |]     three words\n+                     [|  saved f4 value     |]     three words\n+  r0-r3 are not normally saved in a C function.  */\n+\n+/* The number of hard registers is 16 ARM + 8 FPU + 1 CC + 1 SFP.  */\n+#define FIRST_PSEUDO_REGISTER  27\n \n /* 1 for registers that have pervasive standard uses\n    and are not available for the register allocator.  */\n #define FIXED_REGISTERS  \\\n {                        \\\n   0,0,0,0,0,0,0,0,\t \\\n   0,0,1,1,0,1,0,1,\t \\\n-  0,0,0,0,0,0,0,0\t \\\n+  0,0,0,0,0,0,0,0,\t \\\n+  1,1,1\t\t\t \\\n }\n \n /* 1 for registers not available across function calls.\n    These must include the FIXED_REGISTERS and also any\n    registers that can be used without being saved.\n    The latter must include the registers where values are returned\n    and the register where structure-value addresses are passed.\n-   Aside from that, you can include as many other registers as you like.  */\n+   Aside from that, you can include as many other registers as you like.\n+   The CC is not preserved over function calls on the ARM 6, so it is \n+   easier to assume this for all.  SFP is preserved, since FP is. */\n #define CALL_USED_REGISTERS  \\\n {                            \\\n   1,1,1,1,0,0,0,0,\t     \\\n   0,0,1,1,1,1,1,1,\t     \\\n-  1,1,1,1,0,0,0,0\t     \\\n+  1,1,1,1,0,0,0,0,\t     \\\n+  1,1,1\t\t\t     \\\n }\n \n /* If doing stupid life analysis, avoid a bug causing a return value r0 to be\n@@ -221,15 +363,19 @@ extern int target_flags;\n \n    On the ARM regs are UNITS_PER_WORD bits wide; FPU regs can hold any FP\n    mode.  */\n-#define HARD_REGNO_NREGS(REGNO, MODE)  \\\n-    ((REGNO) >= 16 ? 1\t\t\t\t\t\t\t\\\n+#define HARD_REGNO_NREGS(REGNO, MODE)  \t\t\t\t\t\\\n+    (((REGNO) >= 16 && REGNO != FRAME_POINTER_REGNUM\t\t\t\\\n+      && (REGNO) != ARG_POINTER_REGNUM) ? 1\t\t\t\t\\\n      : ((GET_MODE_SIZE (MODE) + UNITS_PER_WORD - 1) / UNITS_PER_WORD))\n \n /* Value is 1 if hard register REGNO can hold a value of machine-mode MODE.\n    This is TRUE for ARM regs since they can hold anything, and TRUE for FPU\n    regs holding FP.  */\n-#define HARD_REGNO_MODE_OK(REGNO, MODE)  \\\n-  ((REGNO) < 16 || GET_MODE_CLASS (MODE) == MODE_FLOAT)\n+#define HARD_REGNO_MODE_OK(REGNO, MODE)  \t\t\t\\\n+  ((GET_MODE_CLASS (MODE) == MODE_CC) ? (REGNO == CC_REGNUM) :\t\\\n+  ((REGNO) < 16 || REGNO == FRAME_POINTER_REGNUM\t\t\\\n+   || REGNO == ARG_POINTER_REGNUM\t\t\t\t\\\n+   || GET_MODE_CLASS (MODE) == MODE_FLOAT))\n \n /* Value is 1 if it is a good idea to tie two pseudo registers\n    when one has mode MODE1 and one has mode MODE2.\n@@ -249,15 +395,24 @@ extern int target_flags;\n #define STACK_POINTER_REGNUM\t13\n \n /* Base register for access to local variables of the function.  */\n-#define FRAME_POINTER_REGNUM\t9\n+#define FRAME_POINTER_REGNUM\t25\n+\n+/* Define this to be where the real frame pointer is if it is not possible to\n+   work out the offset between the frame pointer and the automatic variables\n+   until after register allocation has taken place.  FRAME_POINTER_REGNUM\n+   should point to a special register that we will make sure is eliminated. */\n+#define HARD_FRAME_POINTER_REGNUM 11\n \n /* Value should be nonzero if functions must have frame pointers.\n    Zero means the frame pointer need not be set up (and parms may be accessed\n-   via the stack pointer) in functions that seem suitable.  */\n-#define FRAME_POINTER_REQUIRED\t0\n+   via the stack pointer) in functions that seem suitable.  \n+   If we have to have a frame pointer we might as well make use of it.\n+   APCS says that the frame pointer does not need to be pushed in leaf\n+   functions.  */\n+#define FRAME_POINTER_REQUIRED\t(TARGET_APCS && !leaf_function_p ())\n \n /* Base register for access to arguments of the function.  */\n-#define ARG_POINTER_REGNUM\t11\n+#define ARG_POINTER_REGNUM\t26\n \n /* The native (Norcroft) Pascal compiler for the ARM passes the static chain\n    as an invisible last argument (possible since varargs don't exist in\n@@ -268,14 +423,22 @@ extern int target_flags;\n    is passed to a function.  */\n #define STRUCT_VALUE_REGNUM\t0\n \n+/* Internal, so that we don't need to refer to a raw number */\n+#define CC_REGNUM\t\t24\n+\n /* The order in which register should be allocated.  It is good to use ip\n-   since no saving is required (though calls clobber it).  It is quite good to\n-   use lr since other calls may clobber it anyway.  */\n+   since no saving is required (though calls clobber it) and it never contains\n+   function parameters.  It is quite good to use lr since other calls may\n+   clobber it anyway.  Allocate r0 through r3 in reverse order since r3 is \n+   least likely to contain a function parameter; in addition results are\n+   returned in r0.\n+   */\n #define REG_ALLOC_ORDER  \\\n {                                   \\\n-    0, 1, 2, 3, 12, 14,\t4, 5,       \\\n+    3, 2, 1, 0, 12, 14,\t4, 5,       \\\n     6, 7, 8, 10, 9, 11, 13, 15,     \\\n-    16, 17, 18, 19, 20, 21, 22, 23  \\\n+    16, 17, 18, 19, 20, 21, 22, 23, \\\n+    24, 25\t\t\t    \\\n }\n \f\n /* Register and constant classes.  */\n@@ -306,18 +469,21 @@ enum reg_class\n    of length N_REG_CLASSES.  */\n #define REG_CLASS_CONTENTS  \\\n {\t\t\t\t\\\n-  0x000000,  /* NO_REGS  */\t\\\n-  0xFF0000,  /* FPU_REGS */\t\\\n-  0x00FFFF,  /* GENERAL_REGS */\t\\\n-  0xFFFFFF   /* ALL_REGS */\t\\\n+  0x0000000, /* NO_REGS  */\t\\\n+  0x0FF0000, /* FPU_REGS */\t\\\n+  0x200FFFF, /* GENERAL_REGS */\t\\\n+  0x2FFFFFF  /* ALL_REGS */\t\\\n }\n \n /* The same information, inverted:\n    Return the class number of the smallest class containing\n    reg number REGNO.  This could be a conditional expression\n    or could index an array.  */\n-#define REGNO_REG_CLASS(REGNO)  \\\n-  ((REGNO) < 16 ? GENERAL_REGS : FPU_REGS)\n+#define REGNO_REG_CLASS(REGNO)  \t\t\t\\\n+  (((REGNO) < 16 || REGNO == FRAME_POINTER_REGNUM\t\\\n+    || REGNO == ARG_POINTER_REGNUM)\t\t\t\\\n+   ? GENERAL_REGS : (REGNO) == CC_REGNUM\t\t\\\n+   ? NO_REGS : FPU_REGS)\n \n /* The class value for index registers, and the one for base regs.  */\n #define INDEX_REG_CLASS  GENERAL_REGS\n@@ -334,33 +500,57 @@ enum reg_class\n    C is the letter, and VALUE is a constant value.\n    Return 1 if VALUE is in the range specified by C.\n \tI: immediate arithmetic operand (i.e. 8 bits shifted as required).\n-\tJ: valid indexing constants.  */\n-#define CONST_OK_FOR_LETTER_P(VALUE, C)  \\\n-  ((C) == 'I' ? const_ok_for_arm (VALUE) :\t\t\\\n-   (C) == 'J' ? (abs (VALUE) < 4096) : 0)\n-\n-/* Constant letter 'G' for the FPU immediate constants. */\n-#define CONST_DOUBLE_OK_FOR_LETTER_P(X,C)\t\\\n-    ((C) == 'G' ? const_double_rtx_ok_for_fpu (X) : 0)\n+\tJ: valid indexing constants.  \n+\tK: as I but also (not (value)) ok.\n+\tL: as I but also (neg (value)) ok.*/\n+#define CONST_OK_FOR_LETTER_P(VALUE, C)  \t\t\t\t      \\\n+  ((C) == 'I' ? const_ok_for_arm (VALUE) :\t\t\t\t      \\\n+   (C) == 'J' ? ((VALUE) < 4096 && (VALUE) > -4096) :\t\t\t      \\\n+   (C) == 'K' ? (const_ok_for_arm (VALUE) || const_ok_for_arm (~(VALUE))) :   \\\n+   (C) == 'L' ? (const_ok_for_arm (VALUE) || const_ok_for_arm (-(VALUE))) : 0)\n+\n+/* For the ARM, `Q' means that this is a memory operand that is just\n+   an offset from a register.  \n+   `S' means any symbol that has the SYMBOL_REF_FLAG set or a CONSTANT_POOL\n+   address.  This means that the symbol is in the text segment and can be\n+   accessed without using a load. */\n+\n+#define EXTRA_CONSTRAINT(OP, C)                                         \\\n+  ((C) == 'Q' ? GET_CODE (OP) == MEM && GET_CODE (XEXP (OP, 0)) == REG  \\\n+   : (C) == 'S' ? CONSTANT_ADDRESS_P (OP) : 0)\n+\n+/* Constant letter 'G' for the FPU immediate constants. \n+   'H' means the same constant negated.  */\n+#define CONST_DOUBLE_OK_FOR_LETTER_P(X,C)\t\t\t\\\n+    ((C) == 'G' ? const_double_rtx_ok_for_fpu (X) \t\t\\\n+     : (C) == 'H' ? neg_const_double_rtx_ok_for_fpu (X) : 0)\n \n /* Given an rtx X being reloaded into a reg required to be\n    in class CLASS, return the class of reg to actually use.\n    In general this is just CLASS; but on some machines\n    in some cases it is preferable to use a more restrictive class.  */\n #define PREFERRED_RELOAD_CLASS(X, CLASS)  (CLASS)\n \n+/* Return the register class of a scratch register needed to copy IN into\n+   or out of a register in CLASS in MODE.  If it can be done directly,\n+   NO_REGS is returned.  */\n+#define SECONDARY_OUTPUT_RELOAD_CLASS(CLASS,MODE,X)\t\\\n+  (((MODE) == DFmode && (CLASS) == GENERAL_REGS\t\t\\\n+    && true_regnum (X) == -1) ? GENERAL_REGS\t\t\\\n+   : NO_REGS)\n+\n /* Return the maximum number of consecutive registers\n    needed to represent mode MODE in a register of class CLASS.\n    ARM regs are UNITS_PER_WORD bits while FPU regs can hold any FP mode */\n #define CLASS_MAX_NREGS(CLASS, MODE)  \\\n     ((CLASS) == FPU_REGS ? 1\t\t\t\t\t       \\\n      : ((GET_MODE_SIZE (MODE) + UNITS_PER_WORD - 1) / UNITS_PER_WORD))\n \n-/* Moves between FPU_REGS and GENERAL_REGS are two insns.  */\n+/* Moves between FPU_REGS and GENERAL_REGS are two memory insns.  */\n #define REGISTER_MOVE_COST(CLASS1, CLASS2)  \\\n   ((((CLASS1) == FPU_REGS && (CLASS2) != FPU_REGS)\t\\\n     || ((CLASS2) == FPU_REGS && (CLASS1) != FPU_REGS))\t\\\n-   ? 4 : 2)\n+   ? 20 : 2)\n \f\n /* Stack layout; function entry, exit and calling.  */\n \n@@ -462,7 +652,7 @@ enum reg_class\n    For a library call, FNTYPE is 0.\n    On the ARM, the offset starts at 0.  */\n #define INIT_CUMULATIVE_ARGS(CUM, FNTYPE, LIBNAME)  \\\n-  ((CUM) = (((FNTYPE) && aggregate_value_p (TREE_TYPE ((FNTYPE))) ? 4 : 0))\n+  ((CUM) = (((FNTYPE) && aggregate_value_p (TREE_TYPE ((FNTYPE)))) ? 4 : 0))\n \n /* Update the data in CUM to advance over an argument\n    of mode MODE and data type TYPE.\n@@ -529,15 +719,91 @@ enum reg_class\n \n /* Determine if the epilogue should be output as RTL.\n    You should override this if you define FUNCTION_EXTRA_EPILOGUE.  */\n-/* #define USE_RETURN_INSN use_return_insn () */\n+#define USE_RETURN_INSN use_return_insn ()\n+\n+/* Definitions for register eliminations.\n+\n+   This is an array of structures.  Each structure initializes one pair\n+   of eliminable registers.  The \"from\" register number is given first,\n+   followed by \"to\".  Eliminations of the same \"from\" register are listed\n+   in order of preference.\n+\n+   We have two registers that can be eliminated on the ARM.  First, the\n+   arg pointer register can often be eliminated in favor of the stack\n+   pointer register.  Secondly, the pseudo frame pointer register can always\n+   be eliminated; it is replaced with either the stack or the real frame\n+   pointer. */\n+\n+#define ELIMINABLE_REGS\t\t\t\t\t\\\n+{{ARG_POINTER_REGNUM, STACK_POINTER_REGNUM},\t\t\\\n+ {ARG_POINTER_REGNUM, HARD_FRAME_POINTER_REGNUM},\t\\\n+ {FRAME_POINTER_REGNUM, STACK_POINTER_REGNUM},\t\t\\\n+ {FRAME_POINTER_REGNUM, HARD_FRAME_POINTER_REGNUM}}\n+\n+/* Given FROM and TO register numbers, say whether this elimination is allowed.\n+   Frame pointer elimination is automatically handled.\n+\n+   All eliminations are permissible.  Note that ARG_POINTER_REGNUM and\n+   HARD_FRAME_POINTER_REGNUM are infact the same thing.  If we need a frame\n+   pointer, we must eliminate FRAME_POINTER_REGNUM into\n+   HARD_FRAME_POINTER_REGNUM and not into STACK_POINTER_REGNUM.  */\n+#define CAN_ELIMINATE(FROM, TO)\t\t\\\n+  (((TO) == STACK_POINTER_REGNUM && frame_pointer_needed) ? 0 : 1)\n+\n+/* Define the offset between two registers, one to be eliminated, and the other\n+   its replacement, at the start of a routine.  */\n+#define INITIAL_ELIMINATION_OFFSET(FROM, TO, OFFSET)\t\t\t\\\n+{\t\t\t\t\t\t\t\t\t\\\n+  if ((FROM) == ARG_POINTER_REGNUM && (TO) == HARD_FRAME_POINTER_REGNUM)\\\n+    (OFFSET) = 0;\t\t\t\t\t\t\t\\\n+  else if ((FROM) == FRAME_POINTER_REGNUM && (TO) == STACK_POINTER_REGNUM)\\\n+    (OFFSET) = (get_frame_size () + 3 & ~3);\t\t\t\t\\\n+  else\t\t\t\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\t\\\n+      int regno;\t\t\t\t\t\t\t\\\n+      int offset = 12;\t\t\t\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+      for (regno = 4; regno <= 10; regno++)\t\t\t\t\\\n+\tif (regs_ever_live[regno])\t\t\t\t\t\\\n+\t  offset += 4;\t\t\t\t\t\t\t\\\n+      for (regno = 20; regno <=23; regno++)\t\t\t\t\\\n+\tif (regs_ever_live[regno])\t\t\t\t\t\\\n+\t  offset += 12;\t\t\t\t\t\t\t\\\n+      if ((FROM) == FRAME_POINTER_REGNUM)\t\t\t\t\\\n+\t(OFFSET) = -offset;\t\t\t\t\t\t\\\n+      else\t\t\t\t\t\t\t\t\\\n+\t{\t\t\t\t\t\t\t\t\\\n+\t   if (! regs_ever_live[HARD_FRAME_POINTER_REGNUM])\t\t\\\n+\t     offset -= 16;\t\t\t\t\t\t\\\n+\t   if (regs_ever_live[14])\t\t\t\t\t\\\n+\t     offset += 4;\t\t\t\t\t\t\\\n+\t   (OFFSET) = (get_frame_size () + 3 & ~3) + offset;\t\t\\\n+         }\t\t\t\t\t\t\t\t\\\n+    }\t\t\t\t\t\t\t\t\t\\\n+}\n \n+#if 0\n /* Store in the variable DEPTH the initial difference between the frame\n    pointer reg contents and the stack pointer reg contents, as of the start of\n    the function body.  This depends on the layout of the fixed parts of the\n    stack frame and on how registers are saved.  */\n+#define INITIAL_FRAME_POINTER_OFFSET(DEPTH) \t\t\t\\\n+{\t\t\t\t\t\t\t\t\\\n+  int regno;\t\t\t\t\t\t\t\\\n+  int offset = 12;\t\t\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\\\n+  for (regno = 0; regno < FRAME_POINTER_REGNUM; regno++)\t\\\n+    if (regs_ever_live[regno])\t\t\t\t\t\\\n+      offset += 4;\t\t\t\t\t\t\\\n+  for (regno = 20; regno < 24; regno++)\t\t\t\t\\\n+    if (regs_ever_live[regno])\t\t\t\t\t\\\n+      offset += 12;\t\t\t\t\t\t\\\n+  (DEPTH) = offset + (get_frame_size () + 3 & ~3);\t\t\\\n+}\n+\n #define INITIAL_FRAME_POINTER_OFFSET(DEPTH)  \\\n   (DEPTH) = (get_frame_size () + 3) & ~3;\n-\n+#endif\n /* Output assembler code for a block containing the constant parts\n    of a trampoline, leaving space for the variable parts.\n \n@@ -600,15 +866,19 @@ enum reg_class\n    has been allocated, which happens in local-alloc.c.\n \n    On the ARM, don't allow the pc to be used.  */\n-#define REGNO_OK_FOR_BASE_P(REGNO)  \\\n-  ((REGNO) < 15 || (unsigned) reg_renumber[(REGNO)] < 15)\n-#define REGNO_OK_FOR_INDEX_P(REGNO)  \\\n+#define REGNO_OK_FOR_BASE_P(REGNO)\t\t\t\t\\\n+  ((REGNO) < 15 || (REGNO) == FRAME_POINTER_REGNUM\t\t\\\n+   || (REGNO) == ARG_POINTER_REGNUM\t\t\t\t\\\n+   || (unsigned) reg_renumber[(REGNO)] < 15\t\t\t\\\n+   || (unsigned) reg_renumber[(REGNO)] == FRAME_POINTER_REGNUM\t\\\n+   || (unsigned) reg_renumber[(REGNO)] == ARG_POINTER_REGNUM)\n+#define REGNO_OK_FOR_INDEX_P(REGNO) \\\n   REGNO_OK_FOR_BASE_P(REGNO)\n \n /* Maximum number of registers that can appear in a valid memory address.\n-   The addressing mode [ra,rb, <shift> rc] uses the greatest number of\n-   registers.  */\n-#define MAX_REGS_PER_ADDRESS 3\n+   Shifts in addresses can't be by a register. */\n+\n+#define MAX_REGS_PER_ADDRESS 2\n \n /* Recognize any constant value that is a valid address.  */\n /* XXX We can address any constant, eventually...  */\n@@ -620,8 +890,9 @@ enum reg_class\n   ||  GET_CODE(X) == CONST )\n #endif\n \n-#define CONSTANT_ADDRESS_P(X)  \\\n-  (GET_CODE (X) == SYMBOL_REF && CONSTANT_POOL_ADDRESS_P (X))\n+#define CONSTANT_ADDRESS_P(X)  \t\t\t\t\t\\\n+  (GET_CODE (X) == SYMBOL_REF \t\t\t\t\t\\\n+   && (CONSTANT_POOL_ADDRESS_P (X) || SYMBOL_REF_FLAG (X)))\n \n /* Nonzero if the constant value X is a legitimate general operand.\n    It is given that X satisfies CONSTANT_P or is a CONST_DOUBLE.\n@@ -632,10 +903,20 @@ enum reg_class\n #define LEGITIMATE_CONSTANT_P(X)\t\t\t\t\\\n   (GET_CODE (X) == CONST_INT\t\t\t\t\t\\\n    || (GET_CODE (X) == CONST_DOUBLE\t\t\t\t\\\n-       &&  const_double_rtx_ok_for_fpu (X)))\n-#if 0\n-   || GET_CODE(X) == SYMBOL_REF && CONSTANT_POOL_ADDRESS_P(X))\n-#endif\n+       && (const_double_rtx_ok_for_fpu (X)\t\t\t\\\n+\t   || neg_const_double_rtx_ok_for_fpu (X)))\t\t\\\n+   || CONSTANT_ADDRESS_P (X))\n+\n+/* Symbols in the text segment can be accessed without indirecting via the\n+   constant pool; it may take an extra binary operation, but this is still\n+   faster than indirecting via memory.  */\n+\n+#define ENCODE_SECTION_INFO(decl)\t\t\t\t\t\\\n+{\t\t\t\t\t\t\t\t\t\\\n+  if (TREE_CONSTANT (decl)\t\t\t\t\t\t\\\n+      && (!flag_writable_strings || TREE_CODE (decl) != STRING_CST))\t\\\n+    SYMBOL_REF_FLAG (XEXP (TREE_CST_RTL (decl), 0)) = 1;\t\t\\\n+}\n \n /* The macros REG_OK_FOR..._P assume that the arg is a REG rtx\n    and check its validity for a certain class.\n@@ -644,23 +925,36 @@ enum reg_class\n    them unless they have been allocated suitable hard regs.\n    The symbol REG_OK_STRICT causes the latter definition to be used.  */\n #ifndef REG_OK_STRICT\n+\n /* Nonzero if X is a hard reg that can be used as a base reg\n    or if it is a pseudo reg.  */\n-#define REG_OK_FOR_BASE_P(X)  \\\n-  (REGNO (X) < 16 || REGNO (X) >= 24)\n+#define REG_OK_FOR_BASE_P(X)  \t\t\t\t\\\n+  (REGNO (X) < 16 || REGNO (X) >= FIRST_PSEUDO_REGISTER \\\n+   || REGNO (X) == FRAME_POINTER_REGNUM || REGNO (X) == ARG_POINTER_REGNUM)\n+\n /* Nonzero if X is a hard reg that can be used as an index\n    or if it is a pseudo reg.  */\n #define REG_OK_FOR_INDEX_P(X)  \\\n   REG_OK_FOR_BASE_P(X)\n-#define REG_OK_FOR_PRE_POST_P(X)  \\\n-  (REGNO (X) < 16 || REGNO (X) >= FIRST_PSEUDO_REGISTER)\n+\n+#define REG_OK_FOR_PRE_POST_P(X)  \t\t\t\\\n+  (REGNO (X) < 16 || REGNO (X) >= FIRST_PSEUDO_REGISTER\t\\\n+   || REGNO (X) == FRAME_POINTER_REGNUM || REGNO (X) == ARG_POINTER_REGNUM)\n+\n #else\n+\n /* Nonzero if X is a hard reg that can be used as a base reg.  */\n #define REG_OK_FOR_BASE_P(X)  REGNO_OK_FOR_BASE_P (REGNO (X))\n+\n /* Nonzero if X is a hard reg that can be used as an index.  */\n #define REG_OK_FOR_INDEX_P(X)  REGNO_OK_FOR_INDEX_P (REGNO (X))\n-#define REG_OK_FOR_PRE_POST_P(X)  \\\n-  (REGNO (X) < 16 || (unsigned) reg_renumber[REGNO (X)] < 16)\n+\n+#define REG_OK_FOR_PRE_POST_P(X)  \t\t\t\t\t   \\\n+  (REGNO (X) < 16 || (unsigned) reg_renumber[REGNO (X)] < 16\t\t   \\\n+   || REGNO (X) == FRAME_POINTER_REGNUM || REGNO (X) == ARG_POINTER_REGNUM \\\n+   || (unsigned) reg_renumber[REGNO (X)] == FRAME_POINTER_REGNUM\t   \\\n+   || (unsigned) reg_renumber[REGNO (X)] == ARG_POINTER_REGNUM)\n+\n #endif\n \f\n /* GO_IF_LEGITIMATE_ADDRESS recognizes an RTL expression\n@@ -678,18 +972,24 @@ enum reg_class\n /* A C statement (sans semicolon) to jump to LABEL for legitimate index RTXs\n    used by the macro GO_IF_LEGITIMATE_ADDRESS.  Floating point indices can\n    only be small constants. */\n-#define GO_IF_LEGITIMATE_INDEX(MODE, BASE_REGNO, INDEX, LABEL)\t\t\\\n+#define GO_IF_LEGITIMATE_INDEX(MODE, BASE_REGNO, INDEX, LABEL)  \t\\\n do\t\t\t\t\t\t\t\t\t\\\n {\t\t\t\t\t\t\t\t\t\\\n   int range;\t\t\t\t\t\t\t\t\\\n+  int code = GET_CODE (INDEX);\t\t\t\t\t\t\\\n \t\t\t\t\t\t\t\t\t\\\n   if (GET_MODE_CLASS (MODE) == MODE_FLOAT)\t\t\t\t\\\n-    range = 1024;\t\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\t\\\n+      if (code == CONST_INT && INTVAL (INDEX) < 1024\t\t\t\\\n+\t  && INTVAL (INDEX) > -1024\t\t\t\t\t\\\n+\t  && (INTVAL (INDEX) & 3) == 0)\t\t\t\t\t\\\n+\tgoto LABEL;\t\t\t\t\t\t\t\\\n+    }\t\t\t\t\t\t\t\t\t\\\n   else\t\t\t\t\t\t\t\t\t\\\n     {\t\t\t\t\t\t\t\t\t\\\n-      if (INDEX_REGISTER_RTX_P (INDEX))\t\t\t\t\t\\\n+      if (INDEX_REGISTER_RTX_P (INDEX) && GET_MODE_SIZE (MODE) <= 4)\t\\\n \tgoto LABEL;\t\t\t\t\t\t\t\\\n-      if (GET_MODE_SIZE (MODE) <= 4  &&  GET_CODE (INDEX) == MULT)\t\\\n+      if (GET_MODE_SIZE (MODE) <= 4  && code == MULT)\t\t\t\\\n \t{\t\t\t\t\t\t\t\t\\\n \t  rtx xiop0 = XEXP (INDEX, 0);\t\t\t\t\t\\\n \t  rtx xiop1 = XEXP (INDEX, 1);\t\t\t\t\t\\\n@@ -700,20 +1000,29 @@ do\t\t\t\t\t\t\t\t\t\\\n \t      && power_of_two_operand (xiop0, SImode))\t\t\t\\\n \t    goto LABEL;\t\t\t\t\t\t\t\\\n \t}\t\t\t\t\t\t\t\t\\\n-      range = 4096;\t\t\t\t\t\t\t\\\n+      if (GET_MODE_SIZE (MODE) <= 4\t\t\t\t\t\\\n+\t  && (code == LSHIFTRT || code == ASHIFTRT || code == LSHIFT\t\\\n+\t      || code == ASHIFT || code == ROTATERT))\t\t\t\\\n+\t{\t\t\t\t\t\t\t\t\\\n+\t  rtx op = XEXP (INDEX, 1);\t\t\t\t\t\\\n+\t  if (INDEX_REGISTER_RTX_P (XEXP (INDEX, 0))\t\t\t\\\n+\t      && GET_CODE (op) == CONST_INT && INTVAL (op) > 0\t\t\\\n+\t      && INTVAL (op) <= 31)\t\t\t\t\t\\\n+\t    goto LABEL;\t\t\t\t\t\t\t\\\n+        }\t\t\t\t\t\t\t\t\\\n+      range = (MODE) == HImode ? 4095 : 4096;\t\t\t\t\\\n+      if (code == CONST_INT && INTVAL (INDEX) < range\t\t\t\\\n+\t  && INTVAL (INDEX) > -range)  \t      \t\t\t\t\\\n+        goto LABEL;\t\t\t\t\t\t\t\\\n     }\t\t\t\t\t\t\t\t\t\\\n-\t\t\t\t\t\t\t\t\t\\\n-    if (GET_CODE (INDEX) == CONST_INT && INTVAL (INDEX) < range\t\t\\\n-\t&& INTVAL (INDEX) > -range)\t\t\t\t\t\\\n-      goto LABEL;\t\t\t\t\t\t\t\\\n } while (0)\n \n /* Jump to LABEL if X is a valid address RTX.  This must also take\n    REG_OK_STRICT into account when deciding about valid registers, but it uses\n    the above macros so we are in luck.  Allow REG, REG+REG, REG+INDEX,\n    INDEX+REG, REG-INDEX, and non floating SYMBOL_REF to the constant pool.\n-   Allow REG-only and AUTINC-REG if handling TImode.  Other symbol refs must\n-   be forced though a static cell to ensure addressability.  */\n+   Allow REG-only and AUTINC-REG if handling TImode or HImode.  Other symbol\n+   refs must be forced though a static cell to ensure addressability.  */\n #define GO_IF_LEGITIMATE_ADDRESS(MODE, X, LABEL)  \\\n {\t\t\t\t\t\t\t\t\t\\\n   if (BASE_REGISTER_RTX_P (X))\t\t\t\t\t\t\\\n@@ -834,10 +1143,9 @@ do\t\t\t\t\t\t\t\t\t\\\n /* This is the kind of divide that is easiest to do in the general case.  */\n #define EASY_DIV_EXPR  TRUNC_DIV_EXPR\n \n-/* 'char' is signed by default on RISCiX, unsigned on RISCOS.  */\n-#ifdef riscos\n-#define DEFAULT_SIGNED_CHAR  0\n-#else\n+/* signed 'char' is most compatible, but RISC OS wants it unsigned.\n+   unsigned is probably best, but may break some code.  */\n+#ifndef DEFAULT_SIGNED_CHAR\n #define DEFAULT_SIGNED_CHAR  1\n #endif\n \n@@ -848,6 +1156,17 @@ do\t\t\t\t\t\t\t\t\t\\\n    in one reasonably fast instruction.  */\n #define MOVE_MAX 4\n \n+/* Define if operations between registers always perform the operation\n+   on the full register even if a narrower mode is specified.  */\n+#define WORD_REGISTER_OPERATIONS\n+\n+/* Define if loading in MODE, an integral mode narrower than BITS_PER_WORD\n+   will either zero-extend or sign-extend.  The value of this macro should\n+   be the code that says which one of the two operations is implicitly\n+   done, NIL if none.  */\n+#define LOAD_EXTEND_OP(MODE) \\\n+  ((MODE) == QImode ? ZERO_EXTEND : NIL)\n+\n /* Define this if zero-extension is slow (more than one real instruction).\n    On the ARM, it is more than one instruction only if not fetching from\n    memory.  */\n@@ -861,10 +1180,11 @@ do\t\t\t\t\t\t\t\t\t\\\n    that the native compiler puts too large (> 32) immediate shift counts\n    into a register and shifts by the register, letting the ARM decide what\n    to do instead of doing that itself.  */\n-#define SHIFT_COUNT_TRUNCATED 1\n-\n-/* We have the vprintf function.  */\n-#define HAVE_VPRINTF 1\n+/* This is all wrong.  Defining SHIFT_COUNT_TRUNCATED tells combine that\n+   code like (X << (Y % 32)) for register X, Y is equivalent to (X << Y).\n+   On the arm, Y in a register is used modulo 256 for the shift. Only for\n+   rotates is modulo 32 used. */\n+/* #define SHIFT_COUNT_TRUNCATED 1 */\n \n /* XX This is not true, is it?  */\n /* All integers have the same format so truncation is easy.  */\n@@ -886,77 +1206,194 @@ do\t\t\t\t\t\t\t\t\t\\\n \n /* The relative costs of various types of constants.  Note that cse.c defines\n    REG = 1, SUBREG = 2, any node = (2 + sum of subnodes).  */\n-#define CONST_COSTS(RTX, CODE, OUTER_CODE)  \\\n-  case CONST_INT:\t\t\t\t\\\n-    if (const_ok_for_arm (INTVAL (RTX)))\t\\\n-      return (2);\t\t\t\t\\\n-    else\t\t\t\t\t\\\n-      return (5);\t\t\t\t\\\n-\t\t\t\t\t\t\\\n-  case CONST: \t\t\t\t\t\\\n-  case LABEL_REF:\t\t\t\t\\\n-  case SYMBOL_REF:\t\t\t\t\\\n-    return (6);\t\t\t\t\t\\\n-\t\t\t\t\t\t\\\n-  case CONST_DOUBLE:\t\t\t\t\\\n-    if (const_double_rtx_ok_for_fpu (RTX))\t\\\n-      return(2);\t\t\t\t\\\n-    else\t\t\t\t\t\\\n-      return(7);\n+#define CONST_COSTS(RTX, CODE, OUTER_CODE)\t\t\t\\\n+  case CONST_INT:\t\t\t\t\t\t\\\n+    if (const_ok_for_arm (INTVAL (RTX)))\t\t\t\\\n+      return (OUTER_CODE) == SET ? 2 : -1;\t    \t\t\\\n+    else if (OUTER_CODE == AND                  \t\t\\\n+             && const_ok_for_arm (~INTVAL (RTX)))\t\t\\\n+      return -1;\t                              \t\t\\\n+    else if ((OUTER_CODE == COMPARE             \t\t\\\n+              || OUTER_CODE == PLUS || OUTER_CODE == MINUS)     \\\n+             && const_ok_for_arm (-INTVAL (RTX)))\t\t\\\n+      return -1;\t                              \t\t\\\n+    else                                        \t\t\\\n+      return 5;\t\t                               \t\t\\\n+  case CONST: \t\t\t\t\t\t\t\\\n+  case LABEL_REF:\t\t\t\t\t\t\\\n+  case SYMBOL_REF:\t\t\t\t\t\t\\\n+    return 6;\t\t\t\t\t\t\t\\\n+  case CONST_DOUBLE:\t\t\t\t\t\t\\\n+    if (const_double_rtx_ok_for_fpu (RTX))\t\t\t\\\n+      return (OUTER_CODE) == SET ? 2 : -1;\t\t\t\\\n+    else if (((OUTER_CODE) == COMPARE || (OUTER_CODE) == PLUS)\t\\\n+\t     && neg_const_double_rtx_ok_for_fpu (RTX))\t\t\\\n+       return -1;\t\t\t\t\t\t\\\n+    return(7);\n+\n+#define RTX_COSTS(X,CODE,OUTER_CODE)                                    \\\n+  case MEM:                                                             \\\n+    {                                                                   \\\n+      int num_words = (GET_MODE_SIZE (GET_MODE (X)) > UNITS_PER_WORD) ? 2 : 1;\\\n+      return (COSTS_N_INSNS (10*num_words));                             \\\n+    }                                                                   \\\n+  case MULT:                                                            \\\n+    if (GET_CODE (XEXP (X, 1)) == CONST_INT                             \\\n+        && exact_log2 (INTVAL (XEXP (X, 1))) >= 0)                      \\\n+      return rtx_cost (XEXP (X, 0), GET_CODE (X))+1;                    \\\n+    return COSTS_N_INSNS (9);                                           \\\n+  case LSHIFT:\t\t\t\t\t\t\t\t\\\n+  case ASHIFT:\t\t\t\t\t\t\t\t\\\n+  case LSHIFTRT:\t\t\t\t\t\t\t\\\n+  case ASHIFTRT:\t\t\t\t\t\t\t\\\n+    if (GET_CODE (XEXP (X, 1)) == CONST_INT)\t\t\t\t\\\n+      return rtx_cost (XEXP (X, 0), GET_CODE (X))+1;\t\t\t\\\n+    break;\t\t\t\t\t\t\t\t\\\n+  case MINUS:\t\t\t\t\t\t\t\t\\\n+  {\t\t\t\t\t\t\t\t\t\\\n+    enum rtx_code code = GET_CODE (XEXP (X, 1));\t\t\t\\\n+    if (code == MULT)\t\t\t\t\t\t\t\\\n+      {\t\t\t\t\t\t\t\t\t\\\n+\tif (GET_CODE (XEXP (XEXP (X, 1), 1)) == CONST_INT\t\t\\\n+\t    && exact_log2 (INTVAL (XEXP (XEXP (X, 0), 1))) >= 0)\t\\\n+\t  return COSTS_N_INSNS (1);\t\t\t\t\t\\\n+\tbreak;\t\t\t\t\t\t\t\t\\\n+      }\t\t\t\t\t\t\t\t\t\\\n+    else if (code == ASHIFT || code == LSHIFT || code == ASHIFTRT\t\\\n+\t     || code == LSHIFTRT)\t\t\t\t\t\\\n+      return COSTS_N_INSNS (1);\t\t\t\t\t\t\\\n+  } /* fall through */\t\t\t\t\t\t\t\\\n+  case PLUS:\t\t\t\t\t\t\t\t\\\n+  case IOR:\t\t\t\t\t\t\t\t\\\n+  case XOR:\t\t\t\t\t\t\t\t\\\n+  case AND:\t\t\t\t\t\t\t\t\\\n+  {\t\t\t\t\t\t\t\t\t\\\n+    enum rtx_code code = GET_CODE (XEXP (X, 0));\t\t\t\\\n+    if (code == MULT)\t\t\t\t\t\t\t\\\n+      {\t\t\t\t\t\t\t\t\t\\\n+\tif (GET_CODE (XEXP (XEXP (X, 0), 1)) == CONST_INT\t\t\\\n+\t    && exact_log2 (INTVAL (XEXP (XEXP (X, 0), 1))) >= 0)\t\\\n+\t  return COSTS_N_INSNS (1);\t\t\t\t\t\\\n+\tif (GET_CODE (X) == PLUS)\t\t\t\t\t\\\n+\t  return COSTS_N_INSNS (12);\t\t\t\t\t\\\n+\tbreak;\t\t\t\t\t\t\t\t\\\n+      }\t\t\t\t\t\t\t\t\t\\\n+    else if (code == ASHIFT || code == LSHIFT || code == ASHIFTRT\t\\\n+\t     || code == LSHIFTRT)\t\t\t\t\t\\\n+      return COSTS_N_INSNS (1);\t\t\t\t\t\t\\\n+    break;\t\t\t\t\t\t\t\t\\\n+  }\t\t\t\t\t\t\t\t\t\\\n+  case NOT:\t\t\t\t\t\t\t\t\\\n+    return rtx_cost (XEXP (X, 0), GET_CODE (XEXP (X, 0)));\t\t\\\n+  case IF_THEN_ELSE:                                                    \\\n+    {                                                                   \\\n+      if (GET_CODE (XEXP(X,1)) == PC || GET_CODE (XEXP(X,2)) == PC)     \\\n+        return COSTS_N_INSNS (4);                                       \\\n+      return COSTS_N_INSNS (1);                                 \t\\\n+    }                                                                   \\\n+  case SIGN_EXTEND:                                                     \\\n+    return COSTS_N_INSNS (2);\t\t\t\t\t\t\\\n+  case ZERO_EXTEND:\t\t\t\t\t\t\t\\\n+    if (GET_MODE (XEXP (X, 0)) == QImode)\t\t\t\t\\\n+      {\t\t\t\t\t\t\t\t\t\\\n+\tif (GET_CODE (XEXP (X, 0)) == MEM)\t\t\t\t\\\n+\t  return COSTS_N_INSNS (10);\t\t\t\t\t\\\n+\treturn COSTS_N_INSNS (1);\t\t\t\t\t\\\n+      }\t\t\t\t\t\t\t\t\t\\\n+    break;\t\t\t\t\t\t\t\t\\\n+  case COMPARE:\t\t\t\t\t\t\t\t\\\n+    if (GET_CODE (XEXP (X, 1)) == REG)\t\t\t\t\t\\\n+      return 4;\t\t\t\t\t\t\t\t\\\n+  case SMIN:\t\t\t\t\t\t\t\t\\\n+  case SMAX:\t\t\t\t\t\t\t\t\\\n+  case UMIN:\t\t\t\t\t\t\t\t\\\n+  case UMAX:\t\t\t\t\t\t\t\t\\\n+    return COSTS_N_INSNS (3);\t\t\t\t\t\t\\\n+  case ABS:\t\t\t\t\t\t\t\t\\\n+    if (GET_MODE (X) == SImode)\t\t\t\t\t\t\\\n+      return COSTS_N_INSNS (2);\t\t\t\t\t\t\\\n+    return COSTS_N_INSNS (1);\n+\n+/* Moves to and from memory are quite expensive */\n+#define MEMORY_MOVE_COST(MODE)  10\n+\n+/* All address computations that can be done are free */\n+#define ADDRESS_COST(x) 2\n+\n+/* Try to generate sequences that don't involve branches, we can then use\n+   conditional instructions */\n+#define BRANCH_COST 4\n \f\n-/* Condition code information.  */\n-\n-/* Store in cc_status the expressions\n-   that the condition codes will describe\n-   after execution of an instruction whose pattern is EXP.\n-   Do not alter them if the instruction would not alter the cc's.  */\n-\n-/* On the ARM nothing sets the condition code implicitly---apart from DImode\n-   operations excluding moves---but we have to watch for registers in the\n-   condition code value being clobbered.  This clobbering includes (alas)\n-   function calls.  XXX They could just be considered to clobber regs 0-3 and\n-   10-15 with extra work.  */\n-#define NOTICE_UPDATE_CC(EXP, INSN)  \\\n-{\t\t\t\t\t\t\t\t\t\\\n-  if (GET_MODE (EXP) == DImode\t\t\t\t\t\t\\\n-      && GET_CODE (EXP) == SET\t\t\t\t\t\t\\\n-      && GET_CODE (SET_SRC (EXP)) != REG\t\t\t\t\\\n-      && GET_CODE (SET_SRC (EXP)) != MEM\t\t\t\t\\\n-      && GET_CODE (SET_SRC (EXP)) != CONST_INT)\t\t\t\t\\\n-    CC_STATUS_INIT;\t\t\t\t\t\t\t\\\n-  else if (GET_CODE (EXP) == SET)\t\t\t\t\t\\\n-    {\t\t\t\t\t\t\t\t\t\\\n-      rtx dest = SET_DEST (EXP);\t\t\t\t\t\\\n-      if (dest == cc0_rtx)\t\t\t\t\t\t\\\n-\t{\t\t\t\t\t\t\t\t\\\n-\t  cc_status.flags = 0;\t\t\t\t\t\t\\\n-\t  cc_status.value1 = SET_DEST (EXP);\t\t\t\t\\\n-\t  cc_status.value2 = SET_SRC (EXP);\t\t\t\t\\\n-\t}\t\t\t\t\t\t\t\t\\\n-      if (BASE_REGISTER_RTX_P (dest))\t\t\t\t\t\\\n-\t{\t\t\t\t\t\t\t\t\\\n-\t  if (cc_status.value1\t\t\t\t\t\t\\\n-\t      && reg_overlap_mentioned_p (dest, cc_status.value1))\t\\\n-\t    cc_status.value1 = 0;\t\t\t\t\t\\\n-\t  if (cc_status.value2\t\t\t\t\t\t\\\n-\t      && reg_overlap_mentioned_p (dest, cc_status.value2)) \t\\\n-\t    cc_status.value2 = 0;\t\t\t\t        \\\n-\t}\t\t\t\t\t\t\t        \\\n-    }\t\t\t\t\t\t\t\t        \\\n-  else if (GET_CODE (INSN) != JUMP_INSN && GET_CODE (EXP) == PARALLEL)\t\\\n-    {\t\t\t\t\t\t\t\t\t\\\n-      CC_STATUS_INIT;\t\t\t\t\t\t\t\\\n-    }\t\t\t\t\t\t\t\t\t\\\n-}\n+/* Condition code information. */\n+/* Given a comparison code (EQ, NE, etc.) and the first operand of a COMPARE,\n+   return the mode to be used for the comparison. \n+   CCFPEmode should be used with floating inequalites,\n+   CCFPmode should be used with floating equalities.\n+   CC_NOOVmode should be used with SImode integer equalites\n+   CCmode should be used otherwise. */\n+\n+#define EXTRA_CC_MODES CC_NOOVmode, CCFPmode, CCFPEmode\n+\n+#define EXTRA_CC_NAMES \"CC_NOOV\", \"CCFP\", \"CCFPE\"\n+\n+#define SELECT_CC_MODE(OP,X,Y)\t\t\t\t      \t\t\\\n+  (GET_MODE_CLASS (GET_MODE (X)) == MODE_FLOAT\t\t\t\t\\\n+   ? ((OP == EQ || OP == NE) ? CCFPmode : CCFPEmode)\t\t\t\\\n+   : ((GET_MODE (X) == SImode)\t\t\t\t\t\t\\\n+      && ((OP) == EQ || (OP) == NE)\t\t\t\t\t\\\n+      && (GET_CODE (X) == PLUS || GET_CODE (X) == MINUS\t\t\t\\\n+\t  || GET_CODE (X) == AND || GET_CODE (X) == IOR\t\t\t\\\n+\t  || GET_CODE (X) == XOR || GET_CODE (X) == MULT\t\t\\\n+\t  || GET_CODE (X) == NOT || GET_CODE (X) == NEG\t\t\t\\\n+\t  || GET_CODE (X) == LSHIFT || GET_CODE (X) == LSHIFTRT\t\t\\\n+\t  || GET_CODE (X) == ASHIFT || GET_CODE (X) == ASHIFTRT\t\t\\\n+\t  || GET_CODE (X) == ROTATERT || GET_CODE (X) == ZERO_EXTRACT)\t\\\n+      ? CC_NOOVmode\t\t\t\t\t\t\t\\\n+      : GET_MODE (X) == QImode ? CC_NOOVmode : CCmode))\n+\n+#define STORE_FLAG_VALUE 1\n+\n+/* Define the information needed to generate branch insns.  This is\n+   stored from the compare operation.  Note that we can't use \"rtx\" here\n+   since it hasn't been defined!  */\n+\n+extern struct rtx_def *arm_compare_op0, *arm_compare_op1;\n+extern int arm_compare_fp;\n+\n+/* Define the codes that are matched by predicates in arm.c */\n+#define PREDICATE_CODES\t\t\t\t\t\t\t\\\n+  {\"s_register_operand\", {SUBREG, REG}},\t\t\t\t\\\n+  {\"arm_add_operand\", {SUBREG, REG, CONST_INT}},\t\t\t\\\n+  {\"fpu_add_operand\", {SUBREG, REG, CONST_DOUBLE}},\t\t\t\\\n+  {\"arm_rhs_operand\", {SUBREG, REG, CONST_INT}},\t\t\t\\\n+  {\"fpu_rhs_operand\", {SUBREG, REG, CONST_DOUBLE}},\t\t\t\\\n+  {\"arm_not_operand\", {SUBREG, REG, CONST_INT}},\t\t\t\\\n+  {\"shiftable_operator\", {PLUS, MINUS, AND, IOR, XOR}},\t\t\t\\\n+  {\"minmax_operator\", {SMIN, SMAX, UMIN, UMAX}},\t\t\t\\\n+  {\"shift_operator\", {ASHIFT, LSHIFT, ASHIFTRT, LSHIFTRT, MULT}},\t\\\n+  {\"di_operand\", {SUBREG, REG, CONST_INT, CONST_DOUBLE, MEM}},\t\t\\\n+  {\"load_multiple_operation\", {PARALLEL}},\t\t\t\t\\\n+  {\"store_multiple_operation\", {PARALLEL}},\t\t\t\t\\\n+  {\"equality_operator\", {EQ, NE}},\t\t\t\t\t\\\n+  {\"arm_rhsm_operand\", {SUBREG, REG, CONST_INT, MEM}},\t\t\t\\\n+  {\"const_shift_operand\", {CONST_INT}},\t\t\t\t\t\\\n+  {\"index_operand\", {SUBREG, REG, CONST_INT}},\t\t\t\t\\\n+  {\"cc_register\", {REG}},\n+\n \f\n /* Assembler output control */\n \n+#ifndef ARM_OS_NAME\n+#define ARM_OS_NAME \"(generic)\"\n+#endif\n+\n /* The text to go at the start of the assembler file */\n #define ASM_FILE_START(STREAM)  \\\n {                                                                             \\\n   extern char *version_string;                                                \\\n-                                                                              \\\n-  fprintf (STREAM,\"@ Generated by gcc %s for ARM/RISCiX\\n\", version_string);  \\\n+                                                                             \\\n+  fprintf (STREAM,\"@ Generated by gcc %s for ARM/%s\\n\", version_string,\t      \\\n+\t   ARM_OS_NAME); \t\t\t\t\t\t      \\\n   fprintf (STREAM,\"rfp\\t.req\\tr9\\n\");                                         \\\n   fprintf (STREAM,\"fp\\t.req\\tr11\\n\");\t\t\t\t              \\\n   fprintf (STREAM,\"ip\\t.req\\tr12\\n\");\t\t\t\t              \\\n@@ -980,18 +1417,35 @@ do\t\t\t\t\t\t\t\t\t\\\n {\t\t\t\t                   \\\n   \"r0\", \"r1\", \"r2\", \"r3\", \"r4\", \"r5\", \"r6\", \"r7\",  \\\n   \"r8\",\"rfp\", \"sl\", \"fp\", \"ip\", \"sp\", \"lr\", \"pc\",  \\\n-  \"f0\", \"f1\", \"f2\", \"f3\", \"f4\", \"f5\", \"f6\", \"f7\"   \\\n+  \"f0\", \"f1\", \"f2\", \"f3\", \"f4\", \"f5\", \"f6\", \"f7\",  \\\n+  \"cc\", \"sfp\", \"afp\"\t\t\t\t   \\\n }\n \n+/* Arm Assembler barfs on dollars */\n+#define DOLLARS_IN_IDENTIFIERS 0\n+\n+#define NO_DOLLAR_IN_LABEL\n+\n /* DBX register number for a given compiler register number */\n #define DBX_REGISTER_NUMBER(REGNO)  (REGNO)\n \n-/* Generate DBX debugging information.  */\n+/* Generate DBX debugging information.  riscix.h will undefine this because\n+   the native assembler does not support stabs. */\n #define DBX_DEBUGGING_INFO  1\n \n /* Acorn dbx moans about continuation chars, so don't use any.  */\n #define DBX_CONTIN_LENGTH  0\n \n+/* Output a source filename for the debugger. RISCiX dbx insists that the\n+   ``desc'' field is set to compiler version number >= 315 (sic).  */\n+#define DBX_OUTPUT_MAIN_SOURCE_FILENAME(STREAM,NAME) \t\t\t\\\n+do {\t\t\t\t\t\t\t\t\t\\\n+  fprintf (STREAM, \".stabs \\\"%s\\\",%d,0,315,%s\\n\", (NAME), N_SO,\t\t\\\n+\t   &ltext_label_name[1]);\t\t\t\t\t\\\n+  text_section ();\t\t\t\t\t\t\t\\\n+  ASM_OUTPUT_INTERNAL_LABEL (STREAM, \"Ltext\", 0);\t\t\t\\\n+} while (0)\n+  \n /* Output a label definition.  */\n #define ASM_OUTPUT_LABEL(STREAM,NAME)  \\\n   arm_asm_output_label ((STREAM), (NAME))\n@@ -1021,11 +1475,14 @@ do\t\t\t\t\t\t\t\t\t\\\n       char *s = (char *) alloca (11 + strlen (PREFIX));\t   \t\t\\\n       extern int arm_target_label, arm_ccfsm_state;\t   \t\t\\\n \t\t\t\t\t\t           \t\t\\\n-      if (arm_ccfsm_state == 3 && arm_target_label == (NUM))   \t\t\\\n-\tarm_ccfsm_state = 0;\t\t\t\t        \t\\\n-      strcpy (s, \"*\");\t\t\t\t           \t\t\\\n-      sprintf (&s[strlen (s)], \"%s%d\", (PREFIX), (NUM));   \t\t\\\n-      arm_asm_output_label (STREAM, s);\t\t                        \\\n+      if (arm_ccfsm_state == 3 && arm_target_label == (NUM)   \t\t\\\n+\t&& !strcmp (PREFIX, \"L\"))\t\t\t\t\t\\\n+\t{\t\t\t\t\t\t\t\t\\\n+\t  arm_ccfsm_state = 0;\t\t\t\t        \t\\\n+\t}\t\t\t\t\t\t\t\t\\\n+\tstrcpy (s, \"*\");\t\t\t\t      \t\t\\\n+\tsprintf (&s[strlen (s)], \"%s%d\", (PREFIX), (NUM));   \t\t\\\n+\tarm_asm_output_label (STREAM, s);\t\t                \\\n     } while (0)\n \n /* Nothing special is done about jump tables */\n@@ -1057,13 +1514,30 @@ do\t\t\t\t\t\t\t\t\t\\\n    , fprintf (STREAM, \"\\t.word\\tL%d\\n\", VALUE))\n \n /* Output various types of constants.  */\n-#define ASM_OUTPUT_DOUBLE(STREAM, VALUE)  \\\n-  (arm_increase_location (sizeof (double))        \\\n-   , fprintf (STREAM, \"\\t.double\\t%20.20f\\n\", VALUE))\n-\n-#define ASM_OUTPUT_FLOAT(STREAM, VALUE)\t\\\n-  (arm_increase_location (sizeof (float))        \\\n-   , fprintf (STREAM, \"\\t.float\\t%20.20f\\n\", VALUE))\n+#define ASM_OUTPUT_LONG_DOUBLE(STREAM,VALUE)\t\t\t\t\\\n+do { long l[3];\t\t\t\t\t\t\t\t\\\n+     arm_increase_location (12);\t\t\t\t\t\\\n+     REAL_VALUE_TO_TARGET_LONG_DOUBLE (VALUE, l);\t\t\t\\\n+     if (sizeof (int) == sizeof (long))\t\t\t\t\t\\\n+       fprintf (STREAM, \"\\t.long 0x%x,0x%x,0x%x\\n\", l[2], l[1], l[0]);\t\\\n+     else\t\t\t\t\t\t\t\t\\\n+       fprintf (STREAM, \"\\t.long 0x%lx,0x%lx,0x%lx\\n\", l[2], l[1], l[0]);\t\\\n+   } while (0)\n+\n+    \n+#define ASM_OUTPUT_DOUBLE(STREAM, VALUE)  \t\t\\\n+do { char dstr[30];\t\t\t\t\t\\\n+     arm_increase_location (8);\t\t\t\t\\\n+     REAL_VALUE_TO_DECIMAL (VALUE, \"%.20g\", dstr);\t\\\n+     fprintf (STREAM, \"\\t.double %s\\n\", dstr);\t\\\n+   } while (0)\n+\n+#define ASM_OUTPUT_FLOAT(STREAM, VALUE)\t\t\t\\\n+do { char dstr[30];\t\t\t\t\t\\\n+     arm_increase_location (4);\t\t\t\t\\\n+     REAL_VALUE_TO_DECIMAL (VALUE, \"%.20g\", dstr);\t\\\n+     fprintf (STREAM, \"\\t.float %s\\n\", dstr);\t\t\\\n+   } while (0);\n \n #define ASM_OUTPUT_INT(STREAM, EXP)  \\\n   (fprintf (STREAM, \"\\t.word\\t\"),      \\\n@@ -1154,25 +1628,23 @@ do\t\t\t\t\t\t\t\t\t\\\n    small-distance conditional branches and have ASM_OUTPUT_OPCODE make the\n    instructions conditional.  Suffixes like s (affect flags) and b (bytewise\n    load/store) need to stay suffixes, so the possible condition code comes\n-   before these suffixes.  */\n+   before these suffixes.  %d<n> or %D<n> may appear in the opcode if\n+   it can take a condition; a null rtx will cause no condition to be added,\n+   this is what we expect to happen if arm_ccfsm_state is non-zero. */\n #define ASM_OUTPUT_OPCODE(STREAM, PTR)  \\\n   {\t\t\t\t\t        \t\t      \\\n     extern int arm_ccfsm_state, arm_current_cc;\t\t\t      \\\n     extern char *arm_condition_codes[];\t\t\t\t      \\\n     int i;\t\t\t\t\t\t\t      \\\n \t\t\t\t\t\t\t\t      \\\n     fflush (STREAM);\t    /* XXX for debugging only.  */\t      \\\n-    if (arm_ccfsm_state == 1 || arm_ccfsm_state == 2)   \t      \\\n-      {\t\t\t\t                        \t      \\\n-\tfprintf (STREAM, \"@ \\t\");\t\t\t\t      \\\n-\tarm_ccfsm_state += 2;\t\t        \t\t      \\\n-      }\t\t\t\t\t        \t\t             \\\n-    else if (arm_ccfsm_state == 3 || arm_ccfsm_state == 4)\t             \\\n+    if (arm_ccfsm_state == 3 || arm_ccfsm_state == 4)\t  \t\t\\\n       {\t\t\t\t\t        \t\t             \\\n-\tfor (i = 0; *(PTR) != ' ' && *(PTR) != '\\t' && i < 3; i++, (PTR)++)  \\\n+\tfor (i = 0; *(PTR) != ' ' && *(PTR) != '\\t' && *(PTR) != '%' && i < 3;\\\n+\t     i++, (PTR)++)  \t\t\t\t\t\t     \\\n \t  putc (*(PTR), STREAM);\t        \t\t             \\\n \tfprintf (STREAM, \"%s\", arm_condition_codes[arm_current_cc]);         \\\n-\tfor (; *(PTR) != ' ' && *(PTR) != '\\t'; (PTR)++)\t\t     \\\n+\tfor (; *(PTR) != ' ' && *(PTR) != '\\t' && *(PTR) != '%'; (PTR)++)    \\\n \t  putc (*(PTR), STREAM);\t\t\t\t\t     \\\n       }\t\t\t\t\t\t\t\t             \\\n   }\n@@ -1186,44 +1658,56 @@ do\t\t\t\t\t\t\t\t\t\\\n /* Output an operand of an instruction.  If X is a REG and CODE is `M', output\n    a ldm/stm style multi-reg.  */\n #define PRINT_OPERAND(STREAM, X, CODE)  \\\n-{\t\t\t\t\t        \t\t\\\n-  if ((CODE) == 'R')\t\t\t        \t\t\\\n-    fputs (reg_names[REGNO (X) + 1], (STREAM));\t\t\t\\\n-  else if (GET_CODE (X) == REG)\t\t        \t\t\\\n-    {\t\t\t\t\t        \t\t\\\n-      if ((CODE) != 'M')\t\t\t\t\t\\\n-\tfputs (reg_names[REGNO (X)], (STREAM));\t\t\t\\\n-      else\t\t\t\t        \t\t\\\n-\tfprintf ((STREAM), \"{%s-%s}\",\t        \t\t\\\n-\t\t reg_names[REGNO (X)],\t        \t\t\\\n-\t\t reg_names[REGNO (X) - 1        \t\t\\\n-\t\t\t   + ((GET_MODE_SIZE (GET_MODE (X))\t\\\n-\t\t\t       + GET_MODE_SIZE (SImode) - 1)\t\\\n-\t\t\t      / GET_MODE_SIZE (SImode))]);\t\\\n-    }\t\t\t\t\t\t\t\t\\\n-  else if (GET_CODE (X) == MEM)\t\t\t\t\t\\\n-    {\t\t\t\t\t\t\t\t\\\n-      extern int output_memory_reference_mode;\t\t\t\\\n-      output_memory_reference_mode = GET_MODE (X);\t\t\\\n-      output_address (XEXP (X, 0));\t\t\t\t\\\n-    }\t\t\t\t\t\t\t\t\\\n-  else if (GET_CODE(X) == CONST_DOUBLE)\t\t\t\t\\\n-    {\t\t\t\t\t\t\t\t\\\n-      union real_extract u;\t\t\t\t\t\\\n-      u.i[0] = CONST_DOUBLE_LOW (X);\t\t\t\t\\\n-      u.i[1] = CONST_DOUBLE_HIGH (X);\t\t\t\t\\\n-      fprintf(STREAM,\"#%20.20f\",u.d);\t\t\t\t\\\n-    }\t\t\t\t\t\t\t\t\\\n-  else if (GET_CODE (X) == NEG)\t\t\t\t\t\\\n-    {\t\t\t\t\t\t\t\t\\\n-      fputc ('-', (STREAM));\t\t\t\t\t\\\n-      output_operand ((X), 0);\t\t\t\t\t\\\n-    }\t\t\t\t\t\t\t\t\\\n-  else\t\t\t\t\t\t\t\t\\\n-    {\t\t\t\t\t\t\t\t\\\n-      fputc('#', STREAM);\t\t\t\t\t\\\n-      output_addr_const(STREAM, X);\t\t\t\t\\\n-    }\t\t\t\t\t\t\t\t\\\n+{\t\t\t\t\t        \t\t\t\\\n+  if ((CODE) == 'd')\t\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\t\\\n+      if (X)\t\t\t\t\t\t\t\t\\\n+        fputs (arm_condition_codes[get_arm_condition_code (X)],\t\t\\\n+\t       (STREAM));\t\t\t\t\t\t\\\n+    }\t\t\t\t\t\t\t\t\t\\\n+  else if ((CODE) == 'D')\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\t\\\n+      if (X)\t\t\t\t\t\t\t\t\\\n+        fputs (arm_condition_codes[get_arm_condition_code (X) ^ 1], \t\\\n+\t       (STREAM));\t\t\t\t\t\t\\\n+    }\t\t\t\t\t\t\t\t\t\\\n+  else if ((CODE) == 'R')\t\t\t                \t\\\n+    fputs (reg_names[REGNO (X) + 1], (STREAM));\t\t\t\t\\\n+  else if (GET_CODE (X) == REG)\t\t        \t\t\t\\\n+    {\t\t\t\t\t        \t\t\t\\\n+      if ((CODE) != 'M')\t\t\t\t\t\t\\\n+\tfputs (reg_names[REGNO (X)], (STREAM));\t\t\t\t\\\n+      else\t\t\t\t        \t\t\t\\\n+\tfprintf ((STREAM), \"{%s-%s}\",\t        \t\t\t\\\n+\t\t reg_names[REGNO (X)],\t        \t\t\t\\\n+\t\t reg_names[REGNO (X) - 1        \t\t\t\\\n+\t\t\t   + ((GET_MODE_SIZE (GET_MODE (X))\t\t\\\n+\t\t\t       + GET_MODE_SIZE (SImode) - 1)\t\t\\\n+\t\t\t      / GET_MODE_SIZE (SImode))]);\t\t\\\n+    }\t\t\t\t\t\t\t\t\t\\\n+  else if (GET_CODE (X) == MEM)\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\t\\\n+      extern int output_memory_reference_mode;\t\t\t\t\\\n+      output_memory_reference_mode = GET_MODE (X);\t\t\t\\\n+      output_address (XEXP (X, 0));\t\t\t\t\t\\\n+    }\t\t\t\t\t\t\t\t\t\\\n+  else if (GET_CODE(X) == CONST_DOUBLE)\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\t\\\n+      union real_extract u;\t\t\t\t\t\t\\\n+      u.i[0] = CONST_DOUBLE_LOW (X);\t\t\t\t\t\\\n+      u.i[1] = CONST_DOUBLE_HIGH (X);\t\t\t\t\t\\\n+      fprintf(STREAM,\"#%s\", fp_immediate_constant(X));\t\t\t\\\n+    }\t\t\t\t\t\t\t\t\t\\\n+  else if (GET_CODE (X) == NEG)\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\t\\\n+      fputc ('-', (STREAM));\t\t\t\t\t\t\\\n+      output_operand ((X), 0);\t\t\t\t\t\t\\\n+    }\t\t\t\t\t\t\t\t\t\\\n+  else\t\t\t\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\t\\\n+      fputc('#', STREAM);\t\t\t\t\t\t\\\n+      output_addr_const(STREAM, X);\t\t\t\t\t\\\n+    }\t\t\t\t\t\t\t\t\t\\\n }\n \n /* Output the address of an operand.  */\n@@ -1275,10 +1759,25 @@ do\t\t\t\t\t\t\t\t\t\\\n \t      }\t\t\t\t\t\t\t\t\\\n \t    else\t\t\t\t\t\t\t\\\n \t\tabort();\t\t\t\t\t\t\\\n-\t    fprintf (STREAM, \"[%s, %s%s, asl#%d]\", base_reg_name,\t\\\n+\t    fprintf (STREAM, \"[%s, %s%s, asl #%d]\", base_reg_name,\t\\\n \t\t     is_minus ? \"-\" : \"\", reg_names[REGNO (index)],\t\\\n \t\t     shift);\t\t\t\t\t\t\\\n \t    break;\t\t\t\t\t\t\t\\\n+\t  case ASHIFTRT:\t\t\t\t\t\t\\\n+\t  case LSHIFTRT:\t\t\t\t\t\t\\\n+\t  case ASHIFT:\t\t\t\t\t\t\t\\\n+\t  case LSHIFT:\t\t\t\t\t\t\t\\\n+\t  case ROTATERT:\t\t\t\t\t\t\\\n+\t  {\t\t\t\t\t\t\t\t\\\n+\t    char *shift_type = shift_instr (GET_CODE (index),\t\t\\\n+\t\t\t\t\t    &XEXP (index, 1));\t\t\\\n+\t    shift = INTVAL (XEXP (index, 1));\t\t\t\t\\\n+\t    index = XEXP (index, 0);\t\t\t\t\t\\\n+\t    fprintf (STREAM, \"[%s, %s%s, %s #%d]\", base_reg_name,\t\\\n+\t\t     is_minus ? \"-\" : \"\", reg_names[REGNO (index)],\t\\\n+\t\t     shift_type, shift);\t\t\t\t\\\n+\t    break;\t\t\t\t\t\t\t\\\n+\t  }\t\t\t\t\t\t\t\t\\\n \t    \t\t\t\t\t\t\t\t\\\n \t  default:\t\t\t\t\t\t\t\\\n \t    abort();\t\t\t\t\t\t\t\\"}, {"sha": "6a54de4636c94d1ba39cfff8bb200e44defc2aef", "filename": "gcc/config/arm/arm.md", "status": "modified", "additions": 5552, "deletions": 656, "changes": 6208, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff9940b0157fcda551e107ade4107291605fc285/gcc%2Fconfig%2Farm%2Farm.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff9940b0157fcda551e107ade4107291605fc285/gcc%2Fconfig%2Farm%2Farm.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.md?ref=ff9940b0157fcda551e107ade4107291605fc285"}, {"sha": "c8eaf0d35458d1c5eb7cae3cfd0b0533b61b0990", "filename": "gcc/config/arm/xm-arm.h", "status": "modified", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff9940b0157fcda551e107ade4107291605fc285/gcc%2Fconfig%2Farm%2Fxm-arm.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff9940b0157fcda551e107ade4107291605fc285/gcc%2Fconfig%2Farm%2Fxm-arm.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Fxm-arm.h?ref=ff9940b0157fcda551e107ade4107291605fc285", "patch": "@@ -2,6 +2,7 @@\n    Copyright (C) 1991, 1993 Free Software Foundation, Inc.\n    Contributed by Pieter `Tiggr' Schoenmakers (rcpieter@win.tue.nl)\n               and Martin Simmons (@harleqn.co.uk).\n+   More major hacks by Richard Earnshaw (rwe11@cl.cam.ac.uk)\n \n This file is part of GNU CC.\n \n@@ -29,6 +30,28 @@ the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */\n #define HOST_BITS_PER_INT 32\n #define HOST_BITS_PER_LONG 32\n \n+/* A code distinguishing the floating point format of the host\n+   machine.  There are three defined values: IEEE_FLOAT_FORMAT,\n+   VAX_FLOAT_FORMAT, and UNKNOWN_FLOAT_FORMAT.  */\n+\n+#define HOST_FLOAT_FORMAT IEEE_FLOAT_FORMAT\n+\n+/* If not compiled with GNU C, use C alloca.  */\n+#ifndef __GNUC__\n+#define USE_C_ALLOCA\n+#endif\n+\n+/* Define this if the library function putenv is available on your machine */\n+#define HAVE_PUTENV 1\n+\n+/* Define this if the library function vprintf is available on your machine */\n+#define HAVE_VPRINTF 1\n+\n+/* Define this to be 1 if you know the host compiler supports prototypes, even\n+   if it doesn't define __STDC__, or define it to be 0 if you do not want any\n+   prototypes when compiling GNU CC. */\n+#define USE_PROTOTYPES 1\n+\n /* target machine dependencies.\n    tm.h is a symbolic link to the actual target specific file.  */\n #include \"tm.h\"\n@@ -38,3 +61,5 @@ the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */\n #define FATAL_EXIT_CODE 33\n \n /* EOF xm-arm.h */\n+\n+"}]}