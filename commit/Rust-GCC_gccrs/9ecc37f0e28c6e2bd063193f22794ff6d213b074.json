{"sha": "9ecc37f0e28c6e2bd063193f22794ff6d213b074", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OWVjYzM3ZjBlMjhjNmUyYmQwNjMxOTNmMjI3OTRmZjZkMjEzYjA3NA==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@cygnus.com", "date": "1997-10-16T18:37:59Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "1997-10-16T18:37:59Z"}, "message": "alpha.c (alpha_return_addr_rtx): New variable.\n\n        * alpha.c (alpha_return_addr_rtx): New variable.\n        (alpha_save_machine_status): New; save it.\n        (alpha_restore_machine_status): New; restore it.\n        (alpha_init_expanders): New; clear it.\n        (alpha_return_addr): New; set it.\n        (alpha_ra_ever_killed): New; if alpha_return_addr_rtx, regs_ever_live\n        is overly conservative, so search the insns explicitly.\n        (alpha_sa_mask [VMS]): Check alpha_ra_ever_killed.\n        (alpha_sa_size [VMS && !VMS]): Likewise.\n        * alpha.h (RETURN_ADDR_RTX): Call alpha_return_addr.\n        (INIT_EXPANDERS): New definition.\n\n        * alpha.c: Move REG_PV, REG_RA somewhere more visible in the file.\n        (output_prolog [!VMS]): Use them.\n\n        * alpha.c (output_prolog [!VMS]): Move gp detection to ...\n        (alpha_does_function_need_gp): ... a new function.  Refine the\n        CALL_INSN test to just TYPE_JSR.\n        * alpha.md (most call insns): Fix some jsr/ibr type transpositions.\n\nFrom-SVN: r15936", "tree": {"sha": "2843841f70e843b7e679929b55558330d21f844d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/2843841f70e843b7e679929b55558330d21f844d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/9ecc37f0e28c6e2bd063193f22794ff6d213b074", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9ecc37f0e28c6e2bd063193f22794ff6d213b074", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9ecc37f0e28c6e2bd063193f22794ff6d213b074", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9ecc37f0e28c6e2bd063193f22794ff6d213b074/comments", "author": null, "committer": null, "parents": [{"sha": "bda2ffefc8cd48d877d9721fef72b161bba32fed", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bda2ffefc8cd48d877d9721fef72b161bba32fed", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bda2ffefc8cd48d877d9721fef72b161bba32fed"}], "stats": {"total": 241, "additions": 187, "deletions": 54}, "files": [{"sha": "d4c6c8daf6f03276db81b305bd5043aba08cec3f", "filename": "gcc/ChangeLog", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ecc37f0e28c6e2bd063193f22794ff6d213b074/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ecc37f0e28c6e2bd063193f22794ff6d213b074/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=9ecc37f0e28c6e2bd063193f22794ff6d213b074", "patch": "@@ -1,3 +1,25 @@\n+Thu Oct 16 11:20:30 1997  Richard Henderson  <rth@cygnus.com>\n+\n+\t* alpha.c (alpha_return_addr_rtx): New variable.\n+\t(alpha_save_machine_status): New; save it.\n+\t(alpha_restore_machine_status): New; restore it.\n+\t(alpha_init_expanders): New; clear it.\n+\t(alpha_return_addr): New; set it.\n+\t(alpha_ra_ever_killed): New; if alpha_return_addr_rtx, regs_ever_live\n+\tis overly conservative, so search the insns explicitly.\n+\t(alpha_sa_mask [VMS]): Check alpha_ra_ever_killed.\n+\t(alpha_sa_size [VMS && !VMS]): Likewise.\n+\t* alpha.h (RETURN_ADDR_RTX): Call alpha_return_addr.\n+\t(INIT_EXPANDERS): New definition.\n+\t\n+\t* alpha.c: Move REG_PV, REG_RA somewhere more visible in the file.\n+\t(output_prolog [!VMS]): Use them.\n+\n+\t* alpha.c (output_prolog [!VMS]): Move gp detection to ...\n+\t(alpha_does_function_need_gp): ... a new function.  Refine the \n+\tCALL_INSN test to just TYPE_JSR.\n+\t* alpha.md (most call insns): Fix some jsr/ibr type transpositions.\n+\n Thu Oct 16 09:36:47 1997  Jeffrey A Law  (law@cygnus.com)\n \n \t* version.c: Bump for snapshot."}, {"sha": "aa6cc8615141c7c93386697d35cfcdeecd9dd943", "filename": "gcc/config/alpha/alpha.c", "status": "modified", "additions": 144, "deletions": 38, "changes": 182, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ecc37f0e28c6e2bd063193f22794ff6d213b074/gcc%2Fconfig%2Falpha%2Falpha.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ecc37f0e28c6e2bd063193f22794ff6d213b074/gcc%2Fconfig%2Falpha%2Falpha.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Falpha%2Falpha.c?ref=9ecc37f0e28c6e2bd063193f22794ff6d213b074", "patch": "@@ -37,8 +37,15 @@ Boston, MA 02111-1307, USA.  */\n #include \"expr.h\"\n #include \"obstack.h\"\n #include \"tree.h\"\n+#include \"except.h\"\n+#include \"function.h\"\n+\n+/* External data.  */\n+extern char *version_string;\n+extern int rtx_equal_function_value_matters;\n \n /* Specify which cpu to schedule for. */\n+\n enum processor_type alpha_cpu;\n \n /* Specify how accurate floating-point traps need to be.  */\n@@ -54,6 +61,7 @@ enum alpha_fp_rounding_mode alpha_fprm;\n enum alpha_fp_trap_mode alpha_fptm;\n \n /* Strings decoded into the above options.  */\n+\n char *alpha_cpu_string;\t\t/* -mcpu=ev[4|5] */\n char *alpha_tp_string;\t\t/* -mtrap-precision=[p|s|i] */\n char *alpha_fprm_string;\t/* -mfp-rounding-mode=[n|m|c|d] */\n@@ -79,8 +87,9 @@ static int inside_function = FALSE;\n \n int alpha_function_needs_gp;\n \n-extern char *version_string;\n-extern int rtx_equal_function_value_matters;\n+/* If non-null, this rtx holds the return address for the function.  */\n+\n+static rtx alpha_return_addr_rtx;\n \n /* Declarations of static functions.  */\n static void alpha_set_memflags_1  PROTO((rtx, int, int, int));\n@@ -91,10 +100,16 @@ static void add_long_const\tPROTO((FILE *, HOST_WIDE_INT, int, int, int));\n /* Compute the size of the save area in the stack.  */\n static void alpha_sa_mask\tPROTO((unsigned long *imaskP,\n \t\t\t\t       unsigned long *fmaskP));\n+\n /* Strip type information.  */\n #define CURRENT_FUNCTION_ARGS_INFO  \\\n (TARGET_OPEN_VMS ? current_function_args_info & 0xff \\\n  : current_function_args_info)\n+\n+/* Some helpful register info.  */\n+#define REG_PV 27\n+#define REG_RA 26\n+\n \f\n /* Parse target option strings. */\n \n@@ -1269,6 +1284,87 @@ alpha_adjust_cost (insn, link, dep_insn, cost)\n   /* Otherwise, return the default cost. */\n   return cost;\n }\n+\f\n+/* Functions to save and restore alpha_return_addr_rtx.  */\n+\n+struct machine_function\n+{\n+  rtx ra_rtx;\n+};\n+\n+static void\n+alpha_save_machine_status (p)\n+     struct function *p;\n+{\n+  struct machine_function *machine =\n+    (struct machine_function *) xmalloc (sizeof (struct machine_function));\n+\n+  p->machine = machine;\n+  machine->ra_rtx = alpha_return_addr_rtx;\n+}\n+\n+static void\n+alpha_restore_machine_status (p)\n+     struct function *p;\n+{\n+  struct machine_function *machine = p->machine;\n+\n+  alpha_return_addr_rtx = machine->ra_rtx;\n+\n+  free (machine);\n+  p->machine = (struct machine_function *)0;\n+}\n+\n+/* Do anything needed before RTL is emitted for each function.  */\n+\n+void\n+alpha_init_expanders ()\n+{\n+  alpha_return_addr_rtx = NULL_RTX;\n+\n+  /* Arrange to save and restore machine status around nested functions.  */\n+  save_machine_status = alpha_save_machine_status;\n+  restore_machine_status = alpha_restore_machine_status;\n+}\n+\n+/* Start the ball rolling with RETURN_ADDR_RTX.  */\n+\n+rtx\n+alpha_return_addr (count, frame)\n+     int count;\n+     rtx frame;\n+{\n+  rtx init, first;\n+\n+  if (count != 0)\n+    return const0_rtx;\n+\n+  if (alpha_return_addr_rtx)\n+    return alpha_return_addr_rtx;\n+\n+  /* No rtx yet.  Invent one, and initialize it from $26 in the prologue.  */\n+  alpha_return_addr_rtx = gen_reg_rtx (Pmode);\n+  init = gen_rtx (SET, Pmode, alpha_return_addr_rtx, gen_rtx (REG, Pmode, 26));\n+\n+  /* Emit the insn to the prologue with the other argument copies.  */\n+  push_topmost_sequence ();\n+  emit_insn_after (init, get_insns ());\n+  pop_topmost_sequence ();\n+\n+  return alpha_return_addr_rtx;\n+}\n+\n+static int\n+alpha_ra_ever_killed ()\n+{\n+  rtx i, ra;\n+\n+  if (!alpha_return_addr_rtx)\n+    return regs_ever_live[REG_RA];\n+\n+  return reg_set_between_p (gen_rtx (REG, REG_RA), get_insns(), NULL_RTX);\n+}\n+\n \f\n /* Print an operand.  Recognize special options, documented below.  */\n \n@@ -1661,9 +1757,6 @@ alpha_builtin_saveregs (arglist)\n \n #if OPEN_VMS\n \n-#define REG_PV 27\n-#define REG_RA 26\n-\n /* These variables are used for communication between the following functions.\n    They indicate various things about the current function being compiled\n    that are used to tell what kind of prologue, epilogue and procedure\n@@ -1700,13 +1793,16 @@ alpha_sa_mask (imaskP, fmaskP)\n   /* One for every register we have to save.  */\n \n   for (i = 0; i < FIRST_PSEUDO_REGISTER; i++)\n-    if (! fixed_regs[i] && ! call_used_regs[i] && regs_ever_live[i])\n+    if (! fixed_regs[i] && ! call_used_regs[i]\n+\t&& regs_ever_live[i] && i != REG_RA)\n       {\n \tif (i < 32)\n \t  imask |= (1L << i);\n \telse\n \t  fmask |= (1L << (i - 32));\n       }\n+  if (alpha_ra_ever_killed ())\n+    imask |= (1L << REG_RA);\n \n   *imaskP = imask;\n   *fmaskP = fmask;\n@@ -1724,13 +1820,14 @@ alpha_sa_size ()\n   /* One for every register we have to save.  */\n \n   for (i = 0; i < FIRST_PSEUDO_REGISTER; i++)\n-    if (! fixed_regs[i] && ! call_used_regs[i] && regs_ever_live[i])\n+    if (! fixed_regs[i] && ! call_used_regs[i]\n+\t&& regs_ever_live[i] && i != REG_RA)\n       sa_size++;\n \n   /* Start by assuming we can use a register procedure if we don't make any\n      calls (REG_RA not used) or need to save any registers and a stack\n      procedure if we do.  */\n-  is_stack_procedure = regs_ever_live[REG_RA] || sa_size != 0;\n+  is_stack_procedure = sa_size != 0 || alpha_ra_ever_killed ();\n \n   /* Decide whether to refer to objects off our PV via FP or PV.\n      If we need need FP for something else or if we receive a nonlocal\n@@ -1788,12 +1885,13 @@ alpha_sa_size ()\n   int i;\n \n   for (i = 0; i < FIRST_PSEUDO_REGISTER; i++)\n-    if (! fixed_regs[i] && ! call_used_regs[i] && regs_ever_live[i])\n+    if (! fixed_regs[i] && ! call_used_regs[i]\n+\t&& regs_ever_live[i] && i != REG_RA)\n       size++;\n \n   /* If some registers were saved but not reg 26, reg 26 must also\n      be saved, so leave space for it.  */\n-  if (size != 0 && ! regs_ever_live[26])\n+  if (size != 0 || alpha_ra_ever_killed ())\n     size++;\n \n   /* Our size must be even (multiple of 16 bytes).  */\n@@ -2333,6 +2431,37 @@ output_epilog (file, size)\n \n #else /* !OPEN_VMS */\n \n+static int\n+alpha_does_function_need_gp ()\n+{\n+  rtx insn;\n+\n+  /* We never need a GP for Windows/NT.  */\n+  if (TARGET_WINDOWS_NT)\n+    return 0;\n+\n+#ifdef TARGET_PROFILING_NEEDS_GP\n+  if (profile_flag)\n+    return 1;\n+#endif\n+\n+  /* If we need a GP (we have a LDSYM insn or a CALL_INSN), load it first. \n+     Even if we are a static function, we still need to do this in case\n+     our address is taken and passed to something like qsort.  */\n+\n+  for (insn = get_insns (); insn; insn = NEXT_INSN (insn))\n+    if (GET_RTX_CLASS (GET_CODE (insn)) == 'i'\n+\t&& GET_CODE (PATTERN (insn)) != USE\n+\t&& GET_CODE (PATTERN (insn)) != CLOBBER)\n+      {\n+\tenum attr_type type = get_attr_type (insn);\n+\tif (type == TYPE_LDSYM || type == TYPE_JSR)\n+\t  return 1;\n+      }\n+\n+  return 0;\n+}\n+\n void\n output_prolog (file, size)\n      FILE *file;\n@@ -2348,7 +2477,6 @@ output_prolog (file, size)\n   HOST_WIDE_INT start_reg_offset = reg_offset;\n   HOST_WIDE_INT actual_start_reg_offset = start_reg_offset;\n   int int_reg_save_area_size = 0;\n-  rtx insn;\n   unsigned reg_mask = 0;\n   int i, sa_reg;\n \n@@ -2393,30 +2521,7 @@ output_prolog (file, size)\n   alpha_auto_offset = -frame_size + current_function_pretend_args_size;\n   alpha_arg_offset = -frame_size + 48;\n \n-  /* If we need a GP (we have a LDSYM insn or a CALL_INSN), load it first. \n-     Even if we are a static function, we still need to do this in case\n-     our address is taken and passed to something like qsort.\n-\n-     We never need a GP for Windows/NT.  */\n-\n-  alpha_function_needs_gp = 0;\n-\n-#ifdef TARGET_PROFILING_NEEDS_GP\n-  if (profile_flag)\n-    alpha_function_needs_gp = 1;\n-#endif\n-\n-  for (insn = get_insns (); insn; insn = NEXT_INSN (insn))\n-    if ((GET_CODE (insn) == CALL_INSN)\n-\t|| (GET_RTX_CLASS (GET_CODE (insn)) == 'i'\n-\t    && GET_CODE (PATTERN (insn)) != USE\n-\t    && GET_CODE (PATTERN (insn)) != CLOBBER\n-\t    && (get_attr_type (insn) == TYPE_LDSYM\n-\t\t|| get_attr_type (insn) == TYPE_ISUBR)))\n-      {\n-\talpha_function_needs_gp = 1;\n-\tbreak;\n-      }\n+  alpha_function_needs_gp = alpha_does_function_need_gp ();\n \n   if (TARGET_WINDOWS_NT == 0)\n     {\n@@ -2515,18 +2620,19 @@ output_prolog (file, size)\n       sa_reg = 24;\n     }\n     \n-  /* Save register 26 if any other register needs to be saved.  */\n+  /* Save register RA if any other register needs to be saved.  */\n   if (sa_size != 0)\n     {\n-      reg_mask |= 1 << 26;\n+      reg_mask |= 1 << REG_RA;\n       fprintf (file, \"\\tstq $26,%d($%d)\\n\", reg_offset, sa_reg);\n       reg_offset += 8;\n       int_reg_save_area_size += 8;\n     }\n \n   /* Now save any other used integer registers required to be saved.  */\n   for (i = 0; i < 32; i++)\n-    if (! fixed_regs[i] && ! call_used_regs[i] && regs_ever_live[i] && i != 26)\n+    if (! fixed_regs[i] && ! call_used_regs[i]\n+\t&& regs_ever_live[i] && i != REG_RA)\n       {\n \treg_mask |= 1 << i;\n \tfprintf (file, \"\\tstq $%d,%d($%d)\\n\", i, reg_offset, sa_reg);"}, {"sha": "77020bc0e30f37369ef3bbfe4701dbf8aa652e29", "filename": "gcc/config/alpha/alpha.h", "status": "modified", "additions": 9, "deletions": 8, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ecc37f0e28c6e2bd063193f22794ff6d213b074/gcc%2Fconfig%2Falpha%2Falpha.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ecc37f0e28c6e2bd063193f22794ff6d213b074/gcc%2Fconfig%2Falpha%2Falpha.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Falpha%2Falpha.h?ref=9ecc37f0e28c6e2bd063193f22794ff6d213b074", "patch": "@@ -1255,16 +1255,17 @@ __enable_execute_stack (addr)\t\t\t\t\t\t\\\n /* A C expression whose value is RTL representing the value of the return\n    address for the frame COUNT steps up from the current frame.\n    FRAMEADDR is the frame pointer of the COUNT frame, or the frame pointer of\n-   the COUNT-1 frame if RETURN_ADDR_IN_PREVIOUS_FRAME} is defined.\n+   the COUNT-1 frame if RETURN_ADDR_IN_PREVIOUS_FRAME} is defined.  */\n \n-   This definition for Alpha is broken, but is put in at the request of\n-   Mike Stump.  */\n+#define RETURN_ADDR_RTX  alpha_return_addr\n+extern struct rtx_def *alpha_return_addr ();\n+\n+/* Initialize data used by insn expanders.  This is called from insn_emit,\n+   once for every function before code is generated.  */\n+\n+#define INIT_EXPANDERS  alpha_init_expanders ()\n+extern void alpha_init_expanders ();\n \n-#define RETURN_ADDR_RTX(COUNT, FRAME)\t\t\t\t\t\\\n-((COUNT == 0 && alpha_sa_size () == 0 && 0 /* not right. */)\t\t\\\n- ? gen_rtx (REG, Pmode, 26)\t\t\t\t\t\t\\\n- : gen_rtx (MEM, Pmode,\t\t\t\t\t\t\t\\\n-\t    memory_address (Pmode, FRAME)))\n \f\n /* Addressing modes, and classification of registers for them.  */\n "}, {"sha": "11aedae8bde21505a6b2dde6605a3cef2f29085f", "filename": "gcc/config/alpha/alpha.md", "status": "modified", "additions": 12, "deletions": 8, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ecc37f0e28c6e2bd063193f22794ff6d213b074/gcc%2Fconfig%2Falpha%2Falpha.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ecc37f0e28c6e2bd063193f22794ff6d213b074/gcc%2Fconfig%2Falpha%2Falpha.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Falpha%2Falpha.md?ref=9ecc37f0e28c6e2bd063193f22794ff6d213b074", "patch": "@@ -33,7 +33,7 @@\n ;; separately.\n \n (define_attr \"type\"\n-  \"ld,st,ibr,fbr,jsr,iadd,ilog,shift,cmov,icmp,imull,imulq,imulh,fadd,fmul,fcpys,fdivs,fdivt,ldsym,isubr,misc\"\n+  \"ld,st,ibr,fbr,jsr,iadd,ilog,shift,cmov,icmp,imull,imulq,imulh,fadd,fmul,fcpys,fdivs,fdivt,ldsym,misc\"\n   (const_string \"iadd\"))\n \n ;; The TRAP_TYPE attribute marks instructions that may generate traps\n@@ -744,7 +744,7 @@\n ;   (clobber (reg:DI 28))]\n ;  \"!TARGET_OPEN_VMS\"\n ;  \"%E1 $24,$25,$27\"\n-;  [(set_attr \"type\" \"isubr\")])\n+;  [(set_attr \"type\" \"jsr\")])\n \n (define_insn \"\"\n   [(set (reg:DI 27)\n@@ -754,7 +754,7 @@\n    (clobber (reg:DI 28))]\n   \"!TARGET_OPEN_VMS\"\n   \"%E1 $24,$25,$27\"\n-  [(set_attr \"type\" \"isubr\")])\n+  [(set_attr \"type\" \"jsr\")])\n \f\n ;; Next are the basic logical operations.  These only exist in DImode.\n \n@@ -3289,7 +3289,7 @@\n    jsr $26,($27),0\\;ldgp $29,0($26)\n    bsr $26,%0..ng\n    jsr $26,%0\\;ldgp $29,0($26)\"\n-  [(set_attr \"type\" \"jsr,jsr,ibr\")])\n+  [(set_attr \"type\" \"jsr,ibr,jsr\")])\n       \n (define_insn \"\"\n   [(call (mem:DI (match_operand:DI 0 \"call_operand\" \"r,i\"))\n@@ -3299,7 +3299,7 @@\n   \"@\n    jsr $26,(%0)\n    bsr $26,%0\"\n-  [(set_attr \"type\" \"jsr\")])\n+  [(set_attr \"type\" \"jsr,ibr\")])\n       \n (define_insn \"\"\n   [(call (mem:DI (match_operand:DI 0 \"call_operand\" \"r,i\"))\n@@ -3325,7 +3325,7 @@\n    jsr $26,($27),0\\;ldgp $29,0($26)\n    bsr $26,%1..ng\n    jsr $26,%1\\;ldgp $29,0($26)\"\n-  [(set_attr \"type\" \"jsr,jsr,ibr\")])\n+  [(set_attr \"type\" \"jsr,ibr,jsr\")])\n \n (define_insn \"\"\n   [(set (match_operand 0 \"register_operand\" \"=rf,rf\")\n@@ -3336,7 +3336,7 @@\n   \"@\n    jsr $26,(%1)\n    bsr $26,%1\"\n-  [(set_attr \"type\" \"jsr\")])\n+  [(set_attr \"type\" \"jsr,ibr\")])\n \n (define_insn \"\"\n   [(set (match_operand 0 \"register_operand\" \"\")\n@@ -3568,11 +3568,15 @@\n \n ;; Cache flush.  Used by INITIALIZE_TRAMPOLINE.  0x86 is PAL_imb, but we don't\n ;; want to have to include pal.h in our .s file.\n+;;\n+;; Technically the type for call_pal is jsr, but we use that for determining\n+;; if we need a GP.  Use ibr instead since it has the same scheduling \n+;; characteristics.\n (define_insn \"\"\n   [(unspec_volatile [(const_int 0)] 0)]\n   \"\"\n   \"call_pal 0x86\"\n-  [(set_attr \"type\" \"isubr\")])\n+  [(set_attr \"type\" \"ibr\")])\n \f\n ;; Finally, we have the basic data motion insns.  The byte and word insns\n ;; are done via define_expand.  Start with the floating-point insns, since"}]}