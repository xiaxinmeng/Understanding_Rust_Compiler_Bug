{"sha": "dd91386dc6b2e7748d47818955ac416ff0fc1f84", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZGQ5MTM4NmRjNmIyZTc3NDhkNDc4MTg5NTVhYzQxNmZmMGZjMWY4NA==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2012-01-23T09:54:49Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2012-01-23T09:54:49Z"}, "message": "[multiple changes]\n\n2012-01-23  Robert Dewar  <dewar@adacore.com>\n\n\t* sem_prag.ads, sem_prag.adb: Minor reformatting.\n\n2012-01-23  Robert Dewar  <dewar@adacore.com>\n\n\t* sem_ch13.adb (Analyze_Aspect_Specifications): Check for\n\tlanguage defined aspect applied to renaming or formal type\n\tdeclaration (not permitted)\n\n2012-01-23  Matthew Heaney  <heaney@adacore.com>\n\n\t* a-cdlili.adb, a-cidlli.adb, a-cbdlli.adb (Vet): Replaced\n\tcomment with pragma Assert.\n\nFrom-SVN: r183423", "tree": {"sha": "df9c5acbd4502027762b846fb6a6b61266fad47b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/df9c5acbd4502027762b846fb6a6b61266fad47b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/dd91386dc6b2e7748d47818955ac416ff0fc1f84", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dd91386dc6b2e7748d47818955ac416ff0fc1f84", "html_url": "https://github.com/Rust-GCC/gccrs/commit/dd91386dc6b2e7748d47818955ac416ff0fc1f84", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dd91386dc6b2e7748d47818955ac416ff0fc1f84/comments", "author": null, "committer": null, "parents": [{"sha": "f6834394dd722a10aa72718cd7880bdda49f7f80", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f6834394dd722a10aa72718cd7880bdda49f7f80", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f6834394dd722a10aa72718cd7880bdda49f7f80"}], "stats": {"total": 209, "additions": 155, "deletions": 54}, "files": [{"sha": "c18fcedbb44d30f43f637cded4be0754650dbb68", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dd91386dc6b2e7748d47818955ac416ff0fc1f84/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dd91386dc6b2e7748d47818955ac416ff0fc1f84/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=dd91386dc6b2e7748d47818955ac416ff0fc1f84", "patch": "@@ -1,3 +1,18 @@\n+2012-01-23  Robert Dewar  <dewar@adacore.com>\n+\n+\t* sem_prag.ads, sem_prag.adb: Minor reformatting.\n+\n+2012-01-23  Robert Dewar  <dewar@adacore.com>\n+\n+\t* sem_ch13.adb (Analyze_Aspect_Specifications): Check for\n+\tlanguage defined aspect applied to renaming or formal type\n+\tdeclaration (not permitted)\n+\n+2012-01-23  Matthew Heaney  <heaney@adacore.com>\n+\n+\t* a-cdlili.adb, a-cidlli.adb, a-cbdlli.adb (Vet): Replaced\n+\tcomment with pragma Assert.\n+\n 2012-01-23  Vincent Pucci  <pucci@adacore.com>\n \n \t* sem_ch12.adb (Analyze_Generic_Subprogram_Declaration): Call"}, {"sha": "28c9622ff706dbcc84a26e32b4e4d078d3e49dd0", "filename": "gcc/ada/a-cbdlli.adb", "status": "modified", "additions": 22, "deletions": 15, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dd91386dc6b2e7748d47818955ac416ff0fc1f84/gcc%2Fada%2Fa-cbdlli.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dd91386dc6b2e7748d47818955ac416ff0fc1f84/gcc%2Fada%2Fa-cbdlli.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-cbdlli.adb?ref=dd91386dc6b2e7748d47818955ac416ff0fc1f84", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 2004-2011, Free Software Foundation, Inc.         --\n+--          Copyright (C) 2004-2012, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -81,6 +81,11 @@ package body Ada.Containers.Bounded_Doubly_Linked_Lists is\n       New_Node  : Count_Type);\n \n    function Vet (Position : Cursor) return Boolean;\n+   --  Checks invariants of the cursor and its designated container, as a\n+   --  simple way of detecting dangling references (see operation Free for a\n+   --  description of the detection mechanism), returning True if all checks\n+   --  pass. Invocations of Vet are used here as the argument of pragma Assert,\n+   --  so the checks are performed only when assertions are enabled.\n \n    ---------\n    -- \"=\" --\n@@ -682,7 +687,7 @@ package body Ada.Containers.Bounded_Doubly_Linked_Lists is\n       --  When an element is deleted from the list container, its node becomes\n       --  inactive, and so we set its Prev component to a negative value, to\n       --  indicate that it is now inactive. This provides a useful way to\n-      --  detect a dangling cursor reference.\n+      --  detect a dangling cursor reference (and which is used in Vet).\n \n       N (X).Prev := -1;  -- Node is deallocated (not on active list)\n \n@@ -2184,6 +2189,14 @@ package body Ada.Containers.Bounded_Doubly_Linked_Lists is\n             return False;\n          end if;\n \n+         --  An invariant of an active node is that its Previous and Next\n+         --  components are non-negative. Operation Free sets the Previous\n+         --  component of the node to the value -1 before actually deallocating\n+         --  the node, to mark the node as inactive. (By \"dellocating\" we mean\n+         --  only that the node is linked onto a list of inactive nodes used\n+         --  for storage.) This marker gives us a simple way to detect a\n+         --  dangling reference to a node.\n+\n          if N (Position.Node).Prev < 0 then  -- see Free\n             return False;\n          end if;\n@@ -2206,19 +2219,17 @@ package body Ada.Containers.Bounded_Doubly_Linked_Lists is\n             return False;\n          end if;\n \n-         --  If we get here, we know that this disjunction is true:\n-         --  N (Position.Node).Prev /= 0 or else Position.Node = L.First\n-         --  Why not do this with an assertion???\n+         pragma Assert (N (Position.Node).Prev /= 0\n+                          or else Position.Node = L.First);\n \n          if N (Position.Node).Next = 0\n            and then Position.Node /= L.Last\n          then\n             return False;\n          end if;\n \n-         --  If we get here, we know that this disjunction is true:\n-         --  N (Position.Node).Next /= 0 or else Position.Node = L.Last\n-         --  Why not do this with an assertion???\n+         pragma Assert (N (Position.Node).Next /= 0\n+                          or else Position.Node = L.Last);\n \n          if L.Length = 1 then\n             return L.First = L.Last;\n@@ -2264,21 +2275,17 @@ package body Ada.Containers.Bounded_Doubly_Linked_Lists is\n             return False;\n          end if;\n \n-         --  Eliminate earlier disjunct\n-\n-         if Position.Node = L.First then\n+         if Position.Node = L.First then  -- eliminates earlier disjunct\n             return True;\n          end if;\n \n-         --  If we get to this point, we know that this predicate is true:\n-         --  N (Position.Node).Prev /= 0\n+         pragma Assert (N (Position.Node).Prev /= 0);\n \n          if Position.Node = L.Last then  -- eliminates earlier disjunct\n             return True;\n          end if;\n \n-         --  If we get to this point, we know that this predicate is true:\n-         --  N (Position.Node).Next /= 0\n+         pragma Assert (N (Position.Node).Next /= 0);\n \n          if N (N (Position.Node).Next).Prev /= Position.Node then\n             return False;"}, {"sha": "1346e86ef42f9509a5cd3a563e216bf3543d7fa5", "filename": "gcc/ada/a-cdlili.adb", "status": "modified", "additions": 42, "deletions": 15, "changes": 57, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dd91386dc6b2e7748d47818955ac416ff0fc1f84/gcc%2Fada%2Fa-cdlili.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dd91386dc6b2e7748d47818955ac416ff0fc1f84/gcc%2Fada%2Fa-cdlili.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-cdlili.adb?ref=dd91386dc6b2e7748d47818955ac416ff0fc1f84", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 2004-2011, Free Software Foundation, Inc.         --\n+--          Copyright (C) 2004-2012, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -65,6 +65,11 @@ package body Ada.Containers.Doubly_Linked_Lists is\n       New_Node  : Node_Access);\n \n    function Vet (Position : Cursor) return Boolean;\n+   --  Checks invariants of the cursor and its designated container, as a\n+   --  simple way of detecting dangling references (see operation Free for a\n+   --  description of the detection mechanism), returning True if all checks\n+   --  pass. Invocations of Vet are used here as the argument of pragma Assert,\n+   --  so the checks are performed only when assertions are enabled.\n \n    ---------\n    -- \"=\" --\n@@ -528,8 +533,23 @@ package body Ada.Containers.Doubly_Linked_Lists is\n       procedure Deallocate is\n          new Ada.Unchecked_Deallocation (Node_Type, Node_Access);\n    begin\n+      --  While a node is in use, as an active link in a list, its Previous and\n+      --  Next components must be null, or designate a different node; this is\n+      --  a node invariant. Before actually deallocating the node, we set both\n+      --  access value components of the node to point to the node itself, thus\n+      --  falsifying the node invariant. Subprogram Vet inspects the value of\n+      --  the node components when interrogating the node, in order to detect\n+      --  whether the cursor's node access value is dangling.\n+\n+      --  Note that we have no guarantee that the storage for the node isn't\n+      --  modified when it is deallocated, but there are other tests that Vet\n+      --  does if node invariants appear to be satisifed. However, in practice\n+      --  this simple test works well enough, detecting dangling references\n+      --  immediately, without needing further interrogation.\n+\n       X.Prev := X;\n       X.Next := X;\n+\n       Deallocate (X);\n    end Free;\n \n@@ -1966,6 +1986,13 @@ package body Ada.Containers.Doubly_Linked_Lists is\n          return False;\n       end if;\n \n+      --  An invariant of a node is that its Previous and Next components can\n+      --  be null, or designate a different node. Operation Free sets the\n+      --  access value components of the node to designate the node itself\n+      --  before actually deallocating the node, thus deliberately violating\n+      --  the node invariant. This gives us a simple way to detect a dangling\n+      --  reference to a node.\n+\n       if Position.Node.Next = Position.Node then\n          return False;\n       end if;\n@@ -1974,6 +2001,12 @@ package body Ada.Containers.Doubly_Linked_Lists is\n          return False;\n       end if;\n \n+      --  In practice the tests above will detect most instances of a dangling\n+      --  reference. If we get here, it means that the invariants of the\n+      --  designated node are satisfied (they at least appear to be satisfied),\n+      --  so we perform some more tests, to determine whether invariants of the\n+      --  designated list are satisfied too.\n+\n       declare\n          L : List renames Position.Container.all;\n       begin\n@@ -2003,17 +2036,17 @@ package body Ada.Containers.Doubly_Linked_Lists is\n             return False;\n          end if;\n \n-         --  If we get here, we know that this disjunction is true:\n-         --  Position.Node.Prev /= null or else Position.Node = L.First\n+         pragma Assert (Position.Node.Prev /= null\n+                          or else Position.Node = L.First);\n \n          if Position.Node.Next = null\n            and then Position.Node /= L.Last\n          then\n             return False;\n          end if;\n \n-         --  If we get here, we know that this disjunction is true:\n-         --  Position.Node.Next /= null or else Position.Node = L.Last\n+         pragma Assert (Position.Node.Next /= null\n+                          or else Position.Node = L.Last);\n \n          if L.Length = 1 then\n             return L.First = L.Last;\n@@ -2059,23 +2092,17 @@ package body Ada.Containers.Doubly_Linked_Lists is\n             return False;\n          end if;\n \n-         --  Eliminate earlier disjunct\n-\n-         if Position.Node = L.First then\n+         if Position.Node = L.First then  -- eliminates earlier disjunct\n             return True;\n          end if;\n \n-         --  If we get here, we know (disjunctive syllogism) that this\n-         --  predicate is true: Position.Node.Prev /= null\n-\n-         --  Eliminate earlier disjunct\n+         pragma Assert (Position.Node.Prev /= null);\n \n-         if Position.Node = L.Last then\n+         if Position.Node = L.Last then  -- eliminates earlier disjunct\n             return True;\n          end if;\n \n-         --  If we get here, we know (disjunctive syllogism) that this\n-         --  predicate is true: Position.Node.Next /= null\n+         pragma Assert (Position.Node.Next /= null);\n \n          if Position.Node.Next.Prev /= Position.Node then\n             return False;"}, {"sha": "9d4eea12f16e6fbab970ace8374ace2981eba0fb", "filename": "gcc/ada/a-cidlli.adb", "status": "modified", "additions": 37, "deletions": 1, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dd91386dc6b2e7748d47818955ac416ff0fc1f84/gcc%2Fada%2Fa-cidlli.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dd91386dc6b2e7748d47818955ac416ff0fc1f84/gcc%2Fada%2Fa-cidlli.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-cidlli.adb?ref=dd91386dc6b2e7748d47818955ac416ff0fc1f84", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 2004-2011, Free Software Foundation, Inc.         --\n+--          Copyright (C) 2004-2012, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -68,6 +68,11 @@ package body Ada.Containers.Indefinite_Doubly_Linked_Lists is\n       New_Node  : Node_Access);\n \n    function Vet (Position : Cursor) return Boolean;\n+   --  Checks invariants of the cursor and its designated container, as a\n+   --  simple way of detecting dangling references (see operation Free for a\n+   --  description of the detection mechanism), returning True if all checks\n+   --  pass. Invocations of Vet are used here as the argument of pragma Assert,\n+   --  so the checks are performed only when assertions are enabled.\n \n    ---------\n    -- \"=\" --\n@@ -570,6 +575,23 @@ package body Ada.Containers.Indefinite_Doubly_Linked_Lists is\n          new Ada.Unchecked_Deallocation (Node_Type, Node_Access);\n \n    begin\n+      --  While a node is in use, as an active link in a list, its Previous and\n+      --  Next components must be null, or designate a different node; this is\n+      --  a node invariant. For this indefinite list, there is an additional\n+      --  invariant: that the element access value be non-null. Before actually\n+      --  deallocating the node, we set the node access value components of the\n+      --  node to point to the node itself, and set the element access value to\n+      --  null (by deallocating the node's element), thus falsifying the node\n+      --  invariant. Subprogram Vet inspects the value of the node components\n+      --  when interrogating the node, in order to detect whether the cursor's\n+      --  node access value is dangling.\n+\n+      --  Note that we have no guarantee that the storage for the node isn't\n+      --  modified when it is deallocated, but there are other tests that Vet\n+      --  does if node invariants appear to be satisifed. However, in practice\n+      --  this simple test works well enough, detecting dangling references\n+      --  immediately, without needing further interrogation.\n+\n       X.Next := X;\n       X.Prev := X;\n \n@@ -2048,6 +2070,14 @@ package body Ada.Containers.Indefinite_Doubly_Linked_Lists is\n          return False;\n       end if;\n \n+      --  An invariant of a node is that its Previous and Next components can\n+      --  be null, or designate a different node. Also, its element access\n+      --  value must be non-null. Operation Free sets the node access value\n+      --  components of the node to designate the node itself, and the element\n+      --  access value to null, before actually deallocating the node, thus\n+      --  deliberately violating the node invariant. This gives us a simple way\n+      --  to detect a dangling reference to a node.\n+\n       if Position.Node.Next = Position.Node then\n          return False;\n       end if;\n@@ -2060,6 +2090,12 @@ package body Ada.Containers.Indefinite_Doubly_Linked_Lists is\n          return False;\n       end if;\n \n+      --  In practice the tests above will detect most instances of a dangling\n+      --  reference. If we get here, it means that the invariants of the\n+      --  designated node are satisfied (they at least appear to be satisfied),\n+      --  so we perform some more tests, to determine whether invariants of the\n+      --  designated list are satisfied too.\n+\n       declare\n          L : List renames Position.Container.all;\n       begin"}, {"sha": "978c6ba060f11a8113e5baf1c65f123bef93546f", "filename": "gcc/ada/sem_ch13.adb", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dd91386dc6b2e7748d47818955ac416ff0fc1f84/gcc%2Fada%2Fsem_ch13.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dd91386dc6b2e7748d47818955ac416ff0fc1f84/gcc%2Fada%2Fsem_ch13.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch13.adb?ref=dd91386dc6b2e7748d47818955ac416ff0fc1f84", "patch": "@@ -890,6 +890,28 @@ package body Sem_Ch13 is\n                end loop;\n             end if;\n \n+            --  Check some general restrictions on language defined aspects\n+\n+            if not Impl_Defined_Aspects (A_Id) then\n+               Error_Msg_Name_1 := Nam;\n+\n+               --  Not allowed for renaming declarations\n+\n+               if Nkind (N) in N_Renaming_Declaration then\n+                  Error_Msg_N\n+                    (\"aspect % not allowed for renaming declaration\",\n+                     Aspect);\n+               end if;\n+\n+               --  Not allowed for formal type declarations\n+\n+               if Nkind (N) = N_Formal_Type_Declaration then\n+                  Error_Msg_N\n+                    (\"aspect % not allowed for formal type declaration\",\n+                     Aspect);\n+               end if;\n+            end if;\n+\n             --  Copy expression for later processing by the procedures\n             --  Check_Aspect_At_[Freeze_Point | End_Of_Declarations]\n "}, {"sha": "26289cbfcc5247857436178cf3ea717c0e04b829", "filename": "gcc/ada/sem_prag.adb", "status": "modified", "additions": 15, "deletions": 20, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dd91386dc6b2e7748d47818955ac416ff0fc1f84/gcc%2Fada%2Fsem_prag.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dd91386dc6b2e7748d47818955ac416ff0fc1f84/gcc%2Fada%2Fsem_prag.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_prag.adb?ref=dd91386dc6b2e7748d47818955ac416ff0fc1f84", "patch": "@@ -15247,27 +15247,24 @@ package body Sem_Prag is\n    -- Make_Aspect_For_PPC_In_Gen_Sub_Decl --\n    -----------------------------------------\n \n-   --  Convert any PPC and pragmas that appear within a generic subprogram\n-   --  declaration into aspect.\n-\n    procedure Make_Aspect_For_PPC_In_Gen_Sub_Decl (Decl : Node_Id) is\n-      Aspects          : constant List_Id := New_List;\n-      Loc              : constant Source_Ptr := Sloc (Decl);\n-      Or_Decl          : constant Node_Id := Original_Node (Decl);\n-      Aspect           : Node_Id;\n+      Aspects : constant List_Id := New_List;\n+      Loc     : constant Source_Ptr := Sloc (Decl);\n+      Or_Decl : constant Node_Id := Original_Node (Decl);\n+      Aspect  : Node_Id;\n+\n       Original_Aspects : List_Id;\n       --  To capture global references, a copy of the created aspects must be\n       --  inserted in the original tree.\n \n-      Prag             : Node_Id;\n-      Prag_Arg_Ass     : Node_Id;\n-      Prag_Id          : Pragma_Id;\n+      Prag         : Node_Id;\n+      Prag_Arg_Ass : Node_Id;\n+      Prag_Id      : Pragma_Id;\n \n    begin\n-      Prag := Next (Decl);\n-\n       --  Check for any PPC pragmas that appear within Decl\n \n+      Prag := Next (Decl);\n       while Nkind (Prag) = N_Pragma loop\n          Prag_Id := Get_Pragma_Id (Chars (Pragma_Identifier (Prag)));\n \n@@ -15298,18 +15295,20 @@ package body Sem_Prag is\n       --  Set all new aspects into the generic declaration node\n \n       if Is_Non_Empty_List (Aspects) then\n-         --  Create the list of aspects which will be inserted in the original\n-         --  tree.\n+\n+         --  Create the list of aspects to be inserted in the original tree\n \n          Original_Aspects := Copy_Separate_List (Aspects);\n \n          --  Check if Decl already has aspects\n+\n          --  Attach the new lists of aspects to both the generic copy and the\n          --  original tree.\n \n          if Has_Aspects (Decl) then\n             Append_List (Aspects, Aspect_Specifications (Decl));\n             Append_List (Original_Aspects, Aspect_Specifications (Or_Decl));\n+\n          else\n             Set_Parent (Aspects, Decl);\n             Set_Aspect_Specifications (Decl, Aspects);\n@@ -15335,9 +15334,7 @@ package body Sem_Prag is\n          --  In ASIS mode, for a pragma generated from a source aspect, also\n          --  analyze the original aspect expression.\n \n-         if ASIS_Mode\n-           and then Present (Corresponding_Aspect (N))\n-         then\n+         if ASIS_Mode and then Present (Corresponding_Aspect (N)) then\n             Preanalyze_Spec_Expression\n               (Original_Node (Get_Pragma_Arg (Arg_Req)), Standard_Boolean);\n          end if;\n@@ -15350,9 +15347,7 @@ package body Sem_Prag is\n          --  In ASIS mode, for a pragma generated from a source aspect, also\n          --  analyze the original aspect expression.\n \n-         if ASIS_Mode\n-           and then Present (Corresponding_Aspect (N))\n-         then\n+         if ASIS_Mode and then Present (Corresponding_Aspect (N)) then\n             Preanalyze_Spec_Expression\n               (Original_Node (Get_Pragma_Arg (Arg_Ens)), Standard_Boolean);\n          end if;"}, {"sha": "ede9d28783921c3d9d0945dc8504e0a51ee55c62", "filename": "gcc/ada/sem_prag.ads", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dd91386dc6b2e7748d47818955ac416ff0fc1f84/gcc%2Fada%2Fsem_prag.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dd91386dc6b2e7748d47818955ac416ff0fc1f84/gcc%2Fada%2Fsem_prag.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_prag.ads?ref=dd91386dc6b2e7748d47818955ac416ff0fc1f84", "patch": "@@ -113,9 +113,8 @@ package Sem_Prag is\n    procedure Make_Aspect_For_PPC_In_Gen_Sub_Decl (Decl : Node_Id);\n    --  This routine makes aspects from precondition or postcondition pragmas\n    --  that appear within a generic subprogram declaration. Decl is the generic\n-   --  subprogram declaration node.\n-   --  Note that the aspects are attached to the generic copy and also to the\n-   --  orginal tree.\n+   --  subprogram declaration node. Note that the aspects are attached to the\n+   --  generic copy and also to the orginal tree.\n \n    procedure Process_Compilation_Unit_Pragmas (N : Node_Id);\n    --  Called at the start of processing compilation unit N to deal with any"}]}