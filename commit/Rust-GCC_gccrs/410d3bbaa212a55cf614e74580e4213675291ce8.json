{"sha": "410d3bbaa212a55cf614e74580e4213675291ce8", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDEwZDNiYmFhMjEyYTU1Y2Y2MTRlNzQ1ODBlNDIxMzY3NTI5MWNlOA==", "commit": {"author": {"name": "Victor Leikehman", "email": "lei@il.ibm.com", "date": "2004-11-18T08:45:11Z"}, "committer": {"name": "Victor Leikehman", "email": "victorlei@gcc.gnu.org", "date": "2004-11-18T08:45:11Z"}, "message": "Modified Files:\n\n\tChangeLog generated/matmul_c4.c generated/matmul_c8.c\n\tgenerated/matmul_i4.c generated/matmul_i8.c\n\tgenerated/matmul_r4.c generated/matmul_r8.c m4/matmul.m4\n\n2004-11-18  Victor Leikehman  <lei@il.ibm.com>\n\n\t* m4/matmul.m4: Loops reordered to improve cache behavior.\n\t* generated/matmul_??.c: Regenerated.\n\nFrom-SVN: r90853", "tree": {"sha": "1bf92b09fa37314da9efc3b1c11b7617fadc2eba", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1bf92b09fa37314da9efc3b1c11b7617fadc2eba"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/410d3bbaa212a55cf614e74580e4213675291ce8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/410d3bbaa212a55cf614e74580e4213675291ce8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/410d3bbaa212a55cf614e74580e4213675291ce8", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/410d3bbaa212a55cf614e74580e4213675291ce8/comments", "author": null, "committer": null, "parents": [{"sha": "d7518354cd7dfbac47f7c6a16aed88cf5ca51c29", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d7518354cd7dfbac47f7c6a16aed88cf5ca51c29", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d7518354cd7dfbac47f7c6a16aed88cf5ca51c29"}], "stats": {"total": 1083, "additions": 663, "deletions": 420}, "files": [{"sha": "15315d270f7de7ace8a65e9f2448e8b009c46171", "filename": "libgfortran/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/410d3bbaa212a55cf614e74580e4213675291ce8/libgfortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/410d3bbaa212a55cf614e74580e4213675291ce8/libgfortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2FChangeLog?ref=410d3bbaa212a55cf614e74580e4213675291ce8", "patch": "@@ -1,3 +1,8 @@\n+2004-11-18  Victor Leikehman  <lei@il.ibm.com>\n+\n+\t* m4/matmul.m4: Loops reordered to improve cache behavior.\n+\t* generated/matmul_??.c: Regenerated.\n+\t\n 2004-11-10  Paul Brook  <paul@codesourcery.com>\n \n \tPR fortran/18218"}, {"sha": "fd265d8b5b1349e6561bca520f92ef0c995cfd61", "filename": "libgfortran/generated/matmul_c4.c", "status": "modified", "additions": 94, "deletions": 60, "changes": 154, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/410d3bbaa212a55cf614e74580e4213675291ce8/libgfortran%2Fgenerated%2Fmatmul_c4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/410d3bbaa212a55cf614e74580e4213675291ce8/libgfortran%2Fgenerated%2Fmatmul_c4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmatmul_c4.c?ref=410d3bbaa212a55cf614e74580e4213675291ce8", "patch": "@@ -21,37 +21,46 @@ Boston, MA 02111-1307, USA.  */\n \n #include \"config.h\"\n #include <stdlib.h>\n+#include <string.h>\n #include <assert.h>\n #include \"libgfortran.h\"\n \n-/* Dimensions: retarray(x,y) a(x, count) b(count,y).\n-   Either a or b can be rank 1.  In this case x or y is 1.  */\n+/* This is a C version of the following fortran pseudo-code. The key\n+   point is the loop order -- we access all arrays column-first, which\n+   improves the performance enough to boost galgel spec score by 50%.\n+\n+   DIMENSION A(M,COUNT), B(COUNT,N), C(M,N)\n+   C = 0\n+   DO J=1,N\n+     DO K=1,COUNT\n+       DO I=1,M\n+         C(I,J) = C(I,J)+A(I,K)*B(K,J)\n+*/\n+\n void\n __matmul_c4 (gfc_array_c4 * retarray, gfc_array_c4 * a, gfc_array_c4 * b)\n {\n   GFC_COMPLEX_4 *abase;\n   GFC_COMPLEX_4 *bbase;\n   GFC_COMPLEX_4 *dest;\n-  GFC_COMPLEX_4 res;\n-  index_type rxstride;\n-  index_type rystride;\n-  index_type xcount;\n-  index_type ycount;\n-  index_type xstride;\n-  index_type ystride;\n-  index_type x;\n-  index_type y;\n-\n-  GFC_COMPLEX_4 *pa;\n-  GFC_COMPLEX_4 *pb;\n-  index_type astride;\n-  index_type bstride;\n-  index_type count;\n-  index_type n;\n+\n+  index_type rxstride, rystride, axstride, aystride, bxstride, bystride;\n+  index_type x, y, n, count, xcount, ycount;\n \n   assert (GFC_DESCRIPTOR_RANK (a) == 2\n           || GFC_DESCRIPTOR_RANK (b) == 2);\n \n+/* C[xcount,ycount] = A[xcount, count] * B[count,ycount]\n+\n+   Either A or B (but not both) can be rank 1:\n+\n+   o One-dimensional argument A is implicitly treated as a row matrix\n+     dimensioned [1,count], so xcount=1.\n+\n+   o One-dimensional argument B is implicitly treated as a column matrix\n+     dimensioned [count, 1], so ycount=1.\n+  */\n+\n   if (retarray->data == NULL)\n     {\n       if (GFC_DESCRIPTOR_RANK (a) == 1)\n@@ -95,74 +104,99 @@ __matmul_c4 (gfc_array_c4 * retarray, gfc_array_c4 * a, gfc_array_c4 * b)\n \n   if (GFC_DESCRIPTOR_RANK (retarray) == 1)\n     {\n-      rxstride = retarray->dim[0].stride;\n-      rystride = rxstride;\n+      /* One-dimensional result may be addressed in the code below\n+\t either as a row or a column matrix. We want both cases to\n+\t work. */\n+      rxstride = rystride = retarray->dim[0].stride;\n     }\n   else\n     {\n       rxstride = retarray->dim[0].stride;\n       rystride = retarray->dim[1].stride;\n     }\n \n-  /* If we have rank 1 parameters, zero the absent stride, and set the size to\n-     one.  */\n+\n   if (GFC_DESCRIPTOR_RANK (a) == 1)\n     {\n-      astride = a->dim[0].stride;\n-      count = a->dim[0].ubound + 1 - a->dim[0].lbound;\n-      xstride = 0;\n-      rxstride = 0;\n+      /* Treat it as a a row matrix A[1,count]. */\n+      axstride = a->dim[0].stride;\n+      aystride = 1;\n+\n       xcount = 1;\n+      count = a->dim[0].ubound + 1 - a->dim[0].lbound;\n     }\n   else\n     {\n-      astride = a->dim[1].stride;\n+      axstride = a->dim[0].stride;\n+      aystride = a->dim[1].stride;\n+\n       count = a->dim[1].ubound + 1 - a->dim[1].lbound;\n-      xstride = a->dim[0].stride;\n       xcount = a->dim[0].ubound + 1 - a->dim[0].lbound;\n     }\n+\n+  assert(count == b->dim[0].ubound + 1 - b->dim[0].lbound);\n+\n   if (GFC_DESCRIPTOR_RANK (b) == 1)\n     {\n-      bstride = b->dim[0].stride;\n-      assert(count == b->dim[0].ubound + 1 - b->dim[0].lbound);\n-      ystride = 0;\n-      rystride = 0;\n+      /* Treat it as a column matrix B[count,1] */\n+      bxstride = b->dim[0].stride;\n+\n+      /* bystride should never be used for 1-dimensional b.\n+\t in case it is we want it to cause a segfault, rather than\n+\t an incorrect result. */\n+      bystride = 0xDEADBEEF; \n       ycount = 1;\n     }\n   else\n     {\n-      bstride = b->dim[0].stride;\n-      assert(count == b->dim[0].ubound + 1 - b->dim[0].lbound);\n-      ystride = b->dim[1].stride;\n+      bxstride = b->dim[0].stride;\n+      bystride = b->dim[1].stride;\n       ycount = b->dim[1].ubound + 1 - b->dim[1].lbound;\n     }\n \n-  for (y = 0; y < ycount; y++)\n+  assert (a->base == 0);\n+  assert (b->base == 0);\n+  assert (retarray->base == 0);\n+\n+  abase = a->data;\n+  bbase = b->data;\n+  dest = retarray->data;\n+\n+  if (rxstride == 1 && axstride == 1 && bxstride == 1)\n     {\n-      for (x = 0; x < xcount; x++)\n-        {\n-          /* Do the summation for this element.  For real and integer types\n-             this is the same as DOT_PRODUCT.  For complex types we use do\n-             a*b, not conjg(a)*b.  */\n-          pa = abase;\n-          pb = bbase;\n-          res = 0;\n-\n-          for (n = 0; n < count; n++)\n-            {\n-              res += *pa * *pb;\n-              pa += astride;\n-              pb += bstride;\n-            }\n-\n-          *dest = res;\n-\n-          dest += rxstride;\n-          abase += xstride;\n-        }\n-      abase -= xstride * xcount;\n-      bbase += ystride;\n-      dest += rystride - (rxstride * xcount);\n+      GFC_COMPLEX_4 *bbase_y;\n+      GFC_COMPLEX_4 *dest_y;\n+      GFC_COMPLEX_4 *abase_n;\n+      GFC_COMPLEX_4 bbase_yn;\n+\n+      memset (dest, 0, (sizeof (GFC_COMPLEX_4) * size0(retarray)));\n+\n+      for (y = 0; y < ycount; y++)\n+\t{\n+\t  bbase_y = bbase + y*bystride;\n+\t  dest_y = dest + y*rystride;\n+\t  for (n = 0; n < count; n++)\n+\t    {\n+\t      abase_n = abase + n*aystride;\n+\t      bbase_yn = bbase_y[n];\n+\t      for (x = 0; x < xcount; x++)\n+\t\t{\n+\t\t  dest_y[x] += abase_n[x] * bbase_yn;\n+\t\t}\n+\t    }\n+\t}\n+    }\n+  else\n+    {\n+      for (y = 0; y < ycount; y++)\n+\tfor (x = 0; x < xcount; x++)\n+\t  dest[x*rxstride + y*rystride] = (GFC_COMPLEX_4)0;\n+\n+      for (y = 0; y < ycount; y++)\n+\tfor (n = 0; n < count; n++)\n+\t  for (x = 0; x < xcount; x++)\n+\t    /* dest[x,y] += a[x,n] * b[n,y] */\n+\t    dest[x*rxstride + y*rystride] += abase[x*axstride + n*aystride] * bbase[n*bxstride + y*bystride];\n     }\n }\n "}, {"sha": "bc51e4a9db3c0e2da9e5d886f99d2591672cb2de", "filename": "libgfortran/generated/matmul_c8.c", "status": "modified", "additions": 94, "deletions": 60, "changes": 154, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/410d3bbaa212a55cf614e74580e4213675291ce8/libgfortran%2Fgenerated%2Fmatmul_c8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/410d3bbaa212a55cf614e74580e4213675291ce8/libgfortran%2Fgenerated%2Fmatmul_c8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmatmul_c8.c?ref=410d3bbaa212a55cf614e74580e4213675291ce8", "patch": "@@ -21,37 +21,46 @@ Boston, MA 02111-1307, USA.  */\n \n #include \"config.h\"\n #include <stdlib.h>\n+#include <string.h>\n #include <assert.h>\n #include \"libgfortran.h\"\n \n-/* Dimensions: retarray(x,y) a(x, count) b(count,y).\n-   Either a or b can be rank 1.  In this case x or y is 1.  */\n+/* This is a C version of the following fortran pseudo-code. The key\n+   point is the loop order -- we access all arrays column-first, which\n+   improves the performance enough to boost galgel spec score by 50%.\n+\n+   DIMENSION A(M,COUNT), B(COUNT,N), C(M,N)\n+   C = 0\n+   DO J=1,N\n+     DO K=1,COUNT\n+       DO I=1,M\n+         C(I,J) = C(I,J)+A(I,K)*B(K,J)\n+*/\n+\n void\n __matmul_c8 (gfc_array_c8 * retarray, gfc_array_c8 * a, gfc_array_c8 * b)\n {\n   GFC_COMPLEX_8 *abase;\n   GFC_COMPLEX_8 *bbase;\n   GFC_COMPLEX_8 *dest;\n-  GFC_COMPLEX_8 res;\n-  index_type rxstride;\n-  index_type rystride;\n-  index_type xcount;\n-  index_type ycount;\n-  index_type xstride;\n-  index_type ystride;\n-  index_type x;\n-  index_type y;\n-\n-  GFC_COMPLEX_8 *pa;\n-  GFC_COMPLEX_8 *pb;\n-  index_type astride;\n-  index_type bstride;\n-  index_type count;\n-  index_type n;\n+\n+  index_type rxstride, rystride, axstride, aystride, bxstride, bystride;\n+  index_type x, y, n, count, xcount, ycount;\n \n   assert (GFC_DESCRIPTOR_RANK (a) == 2\n           || GFC_DESCRIPTOR_RANK (b) == 2);\n \n+/* C[xcount,ycount] = A[xcount, count] * B[count,ycount]\n+\n+   Either A or B (but not both) can be rank 1:\n+\n+   o One-dimensional argument A is implicitly treated as a row matrix\n+     dimensioned [1,count], so xcount=1.\n+\n+   o One-dimensional argument B is implicitly treated as a column matrix\n+     dimensioned [count, 1], so ycount=1.\n+  */\n+\n   if (retarray->data == NULL)\n     {\n       if (GFC_DESCRIPTOR_RANK (a) == 1)\n@@ -95,74 +104,99 @@ __matmul_c8 (gfc_array_c8 * retarray, gfc_array_c8 * a, gfc_array_c8 * b)\n \n   if (GFC_DESCRIPTOR_RANK (retarray) == 1)\n     {\n-      rxstride = retarray->dim[0].stride;\n-      rystride = rxstride;\n+      /* One-dimensional result may be addressed in the code below\n+\t either as a row or a column matrix. We want both cases to\n+\t work. */\n+      rxstride = rystride = retarray->dim[0].stride;\n     }\n   else\n     {\n       rxstride = retarray->dim[0].stride;\n       rystride = retarray->dim[1].stride;\n     }\n \n-  /* If we have rank 1 parameters, zero the absent stride, and set the size to\n-     one.  */\n+\n   if (GFC_DESCRIPTOR_RANK (a) == 1)\n     {\n-      astride = a->dim[0].stride;\n-      count = a->dim[0].ubound + 1 - a->dim[0].lbound;\n-      xstride = 0;\n-      rxstride = 0;\n+      /* Treat it as a a row matrix A[1,count]. */\n+      axstride = a->dim[0].stride;\n+      aystride = 1;\n+\n       xcount = 1;\n+      count = a->dim[0].ubound + 1 - a->dim[0].lbound;\n     }\n   else\n     {\n-      astride = a->dim[1].stride;\n+      axstride = a->dim[0].stride;\n+      aystride = a->dim[1].stride;\n+\n       count = a->dim[1].ubound + 1 - a->dim[1].lbound;\n-      xstride = a->dim[0].stride;\n       xcount = a->dim[0].ubound + 1 - a->dim[0].lbound;\n     }\n+\n+  assert(count == b->dim[0].ubound + 1 - b->dim[0].lbound);\n+\n   if (GFC_DESCRIPTOR_RANK (b) == 1)\n     {\n-      bstride = b->dim[0].stride;\n-      assert(count == b->dim[0].ubound + 1 - b->dim[0].lbound);\n-      ystride = 0;\n-      rystride = 0;\n+      /* Treat it as a column matrix B[count,1] */\n+      bxstride = b->dim[0].stride;\n+\n+      /* bystride should never be used for 1-dimensional b.\n+\t in case it is we want it to cause a segfault, rather than\n+\t an incorrect result. */\n+      bystride = 0xDEADBEEF; \n       ycount = 1;\n     }\n   else\n     {\n-      bstride = b->dim[0].stride;\n-      assert(count == b->dim[0].ubound + 1 - b->dim[0].lbound);\n-      ystride = b->dim[1].stride;\n+      bxstride = b->dim[0].stride;\n+      bystride = b->dim[1].stride;\n       ycount = b->dim[1].ubound + 1 - b->dim[1].lbound;\n     }\n \n-  for (y = 0; y < ycount; y++)\n+  assert (a->base == 0);\n+  assert (b->base == 0);\n+  assert (retarray->base == 0);\n+\n+  abase = a->data;\n+  bbase = b->data;\n+  dest = retarray->data;\n+\n+  if (rxstride == 1 && axstride == 1 && bxstride == 1)\n     {\n-      for (x = 0; x < xcount; x++)\n-        {\n-          /* Do the summation for this element.  For real and integer types\n-             this is the same as DOT_PRODUCT.  For complex types we use do\n-             a*b, not conjg(a)*b.  */\n-          pa = abase;\n-          pb = bbase;\n-          res = 0;\n-\n-          for (n = 0; n < count; n++)\n-            {\n-              res += *pa * *pb;\n-              pa += astride;\n-              pb += bstride;\n-            }\n-\n-          *dest = res;\n-\n-          dest += rxstride;\n-          abase += xstride;\n-        }\n-      abase -= xstride * xcount;\n-      bbase += ystride;\n-      dest += rystride - (rxstride * xcount);\n+      GFC_COMPLEX_8 *bbase_y;\n+      GFC_COMPLEX_8 *dest_y;\n+      GFC_COMPLEX_8 *abase_n;\n+      GFC_COMPLEX_8 bbase_yn;\n+\n+      memset (dest, 0, (sizeof (GFC_COMPLEX_8) * size0(retarray)));\n+\n+      for (y = 0; y < ycount; y++)\n+\t{\n+\t  bbase_y = bbase + y*bystride;\n+\t  dest_y = dest + y*rystride;\n+\t  for (n = 0; n < count; n++)\n+\t    {\n+\t      abase_n = abase + n*aystride;\n+\t      bbase_yn = bbase_y[n];\n+\t      for (x = 0; x < xcount; x++)\n+\t\t{\n+\t\t  dest_y[x] += abase_n[x] * bbase_yn;\n+\t\t}\n+\t    }\n+\t}\n+    }\n+  else\n+    {\n+      for (y = 0; y < ycount; y++)\n+\tfor (x = 0; x < xcount; x++)\n+\t  dest[x*rxstride + y*rystride] = (GFC_COMPLEX_8)0;\n+\n+      for (y = 0; y < ycount; y++)\n+\tfor (n = 0; n < count; n++)\n+\t  for (x = 0; x < xcount; x++)\n+\t    /* dest[x,y] += a[x,n] * b[n,y] */\n+\t    dest[x*rxstride + y*rystride] += abase[x*axstride + n*aystride] * bbase[n*bxstride + y*bystride];\n     }\n }\n "}, {"sha": "7b8cfbdd995cc80cb676e06a87c8435f2b18e9f5", "filename": "libgfortran/generated/matmul_i4.c", "status": "modified", "additions": 94, "deletions": 60, "changes": 154, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/410d3bbaa212a55cf614e74580e4213675291ce8/libgfortran%2Fgenerated%2Fmatmul_i4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/410d3bbaa212a55cf614e74580e4213675291ce8/libgfortran%2Fgenerated%2Fmatmul_i4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmatmul_i4.c?ref=410d3bbaa212a55cf614e74580e4213675291ce8", "patch": "@@ -21,37 +21,46 @@ Boston, MA 02111-1307, USA.  */\n \n #include \"config.h\"\n #include <stdlib.h>\n+#include <string.h>\n #include <assert.h>\n #include \"libgfortran.h\"\n \n-/* Dimensions: retarray(x,y) a(x, count) b(count,y).\n-   Either a or b can be rank 1.  In this case x or y is 1.  */\n+/* This is a C version of the following fortran pseudo-code. The key\n+   point is the loop order -- we access all arrays column-first, which\n+   improves the performance enough to boost galgel spec score by 50%.\n+\n+   DIMENSION A(M,COUNT), B(COUNT,N), C(M,N)\n+   C = 0\n+   DO J=1,N\n+     DO K=1,COUNT\n+       DO I=1,M\n+         C(I,J) = C(I,J)+A(I,K)*B(K,J)\n+*/\n+\n void\n __matmul_i4 (gfc_array_i4 * retarray, gfc_array_i4 * a, gfc_array_i4 * b)\n {\n   GFC_INTEGER_4 *abase;\n   GFC_INTEGER_4 *bbase;\n   GFC_INTEGER_4 *dest;\n-  GFC_INTEGER_4 res;\n-  index_type rxstride;\n-  index_type rystride;\n-  index_type xcount;\n-  index_type ycount;\n-  index_type xstride;\n-  index_type ystride;\n-  index_type x;\n-  index_type y;\n-\n-  GFC_INTEGER_4 *pa;\n-  GFC_INTEGER_4 *pb;\n-  index_type astride;\n-  index_type bstride;\n-  index_type count;\n-  index_type n;\n+\n+  index_type rxstride, rystride, axstride, aystride, bxstride, bystride;\n+  index_type x, y, n, count, xcount, ycount;\n \n   assert (GFC_DESCRIPTOR_RANK (a) == 2\n           || GFC_DESCRIPTOR_RANK (b) == 2);\n \n+/* C[xcount,ycount] = A[xcount, count] * B[count,ycount]\n+\n+   Either A or B (but not both) can be rank 1:\n+\n+   o One-dimensional argument A is implicitly treated as a row matrix\n+     dimensioned [1,count], so xcount=1.\n+\n+   o One-dimensional argument B is implicitly treated as a column matrix\n+     dimensioned [count, 1], so ycount=1.\n+  */\n+\n   if (retarray->data == NULL)\n     {\n       if (GFC_DESCRIPTOR_RANK (a) == 1)\n@@ -95,74 +104,99 @@ __matmul_i4 (gfc_array_i4 * retarray, gfc_array_i4 * a, gfc_array_i4 * b)\n \n   if (GFC_DESCRIPTOR_RANK (retarray) == 1)\n     {\n-      rxstride = retarray->dim[0].stride;\n-      rystride = rxstride;\n+      /* One-dimensional result may be addressed in the code below\n+\t either as a row or a column matrix. We want both cases to\n+\t work. */\n+      rxstride = rystride = retarray->dim[0].stride;\n     }\n   else\n     {\n       rxstride = retarray->dim[0].stride;\n       rystride = retarray->dim[1].stride;\n     }\n \n-  /* If we have rank 1 parameters, zero the absent stride, and set the size to\n-     one.  */\n+\n   if (GFC_DESCRIPTOR_RANK (a) == 1)\n     {\n-      astride = a->dim[0].stride;\n-      count = a->dim[0].ubound + 1 - a->dim[0].lbound;\n-      xstride = 0;\n-      rxstride = 0;\n+      /* Treat it as a a row matrix A[1,count]. */\n+      axstride = a->dim[0].stride;\n+      aystride = 1;\n+\n       xcount = 1;\n+      count = a->dim[0].ubound + 1 - a->dim[0].lbound;\n     }\n   else\n     {\n-      astride = a->dim[1].stride;\n+      axstride = a->dim[0].stride;\n+      aystride = a->dim[1].stride;\n+\n       count = a->dim[1].ubound + 1 - a->dim[1].lbound;\n-      xstride = a->dim[0].stride;\n       xcount = a->dim[0].ubound + 1 - a->dim[0].lbound;\n     }\n+\n+  assert(count == b->dim[0].ubound + 1 - b->dim[0].lbound);\n+\n   if (GFC_DESCRIPTOR_RANK (b) == 1)\n     {\n-      bstride = b->dim[0].stride;\n-      assert(count == b->dim[0].ubound + 1 - b->dim[0].lbound);\n-      ystride = 0;\n-      rystride = 0;\n+      /* Treat it as a column matrix B[count,1] */\n+      bxstride = b->dim[0].stride;\n+\n+      /* bystride should never be used for 1-dimensional b.\n+\t in case it is we want it to cause a segfault, rather than\n+\t an incorrect result. */\n+      bystride = 0xDEADBEEF; \n       ycount = 1;\n     }\n   else\n     {\n-      bstride = b->dim[0].stride;\n-      assert(count == b->dim[0].ubound + 1 - b->dim[0].lbound);\n-      ystride = b->dim[1].stride;\n+      bxstride = b->dim[0].stride;\n+      bystride = b->dim[1].stride;\n       ycount = b->dim[1].ubound + 1 - b->dim[1].lbound;\n     }\n \n-  for (y = 0; y < ycount; y++)\n+  assert (a->base == 0);\n+  assert (b->base == 0);\n+  assert (retarray->base == 0);\n+\n+  abase = a->data;\n+  bbase = b->data;\n+  dest = retarray->data;\n+\n+  if (rxstride == 1 && axstride == 1 && bxstride == 1)\n     {\n-      for (x = 0; x < xcount; x++)\n-        {\n-          /* Do the summation for this element.  For real and integer types\n-             this is the same as DOT_PRODUCT.  For complex types we use do\n-             a*b, not conjg(a)*b.  */\n-          pa = abase;\n-          pb = bbase;\n-          res = 0;\n-\n-          for (n = 0; n < count; n++)\n-            {\n-              res += *pa * *pb;\n-              pa += astride;\n-              pb += bstride;\n-            }\n-\n-          *dest = res;\n-\n-          dest += rxstride;\n-          abase += xstride;\n-        }\n-      abase -= xstride * xcount;\n-      bbase += ystride;\n-      dest += rystride - (rxstride * xcount);\n+      GFC_INTEGER_4 *bbase_y;\n+      GFC_INTEGER_4 *dest_y;\n+      GFC_INTEGER_4 *abase_n;\n+      GFC_INTEGER_4 bbase_yn;\n+\n+      memset (dest, 0, (sizeof (GFC_INTEGER_4) * size0(retarray)));\n+\n+      for (y = 0; y < ycount; y++)\n+\t{\n+\t  bbase_y = bbase + y*bystride;\n+\t  dest_y = dest + y*rystride;\n+\t  for (n = 0; n < count; n++)\n+\t    {\n+\t      abase_n = abase + n*aystride;\n+\t      bbase_yn = bbase_y[n];\n+\t      for (x = 0; x < xcount; x++)\n+\t\t{\n+\t\t  dest_y[x] += abase_n[x] * bbase_yn;\n+\t\t}\n+\t    }\n+\t}\n+    }\n+  else\n+    {\n+      for (y = 0; y < ycount; y++)\n+\tfor (x = 0; x < xcount; x++)\n+\t  dest[x*rxstride + y*rystride] = (GFC_INTEGER_4)0;\n+\n+      for (y = 0; y < ycount; y++)\n+\tfor (n = 0; n < count; n++)\n+\t  for (x = 0; x < xcount; x++)\n+\t    /* dest[x,y] += a[x,n] * b[n,y] */\n+\t    dest[x*rxstride + y*rystride] += abase[x*axstride + n*aystride] * bbase[n*bxstride + y*bystride];\n     }\n }\n "}, {"sha": "c84c0241301842f2de4c02336fa056d3d99fc19c", "filename": "libgfortran/generated/matmul_i8.c", "status": "modified", "additions": 94, "deletions": 60, "changes": 154, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/410d3bbaa212a55cf614e74580e4213675291ce8/libgfortran%2Fgenerated%2Fmatmul_i8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/410d3bbaa212a55cf614e74580e4213675291ce8/libgfortran%2Fgenerated%2Fmatmul_i8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmatmul_i8.c?ref=410d3bbaa212a55cf614e74580e4213675291ce8", "patch": "@@ -21,37 +21,46 @@ Boston, MA 02111-1307, USA.  */\n \n #include \"config.h\"\n #include <stdlib.h>\n+#include <string.h>\n #include <assert.h>\n #include \"libgfortran.h\"\n \n-/* Dimensions: retarray(x,y) a(x, count) b(count,y).\n-   Either a or b can be rank 1.  In this case x or y is 1.  */\n+/* This is a C version of the following fortran pseudo-code. The key\n+   point is the loop order -- we access all arrays column-first, which\n+   improves the performance enough to boost galgel spec score by 50%.\n+\n+   DIMENSION A(M,COUNT), B(COUNT,N), C(M,N)\n+   C = 0\n+   DO J=1,N\n+     DO K=1,COUNT\n+       DO I=1,M\n+         C(I,J) = C(I,J)+A(I,K)*B(K,J)\n+*/\n+\n void\n __matmul_i8 (gfc_array_i8 * retarray, gfc_array_i8 * a, gfc_array_i8 * b)\n {\n   GFC_INTEGER_8 *abase;\n   GFC_INTEGER_8 *bbase;\n   GFC_INTEGER_8 *dest;\n-  GFC_INTEGER_8 res;\n-  index_type rxstride;\n-  index_type rystride;\n-  index_type xcount;\n-  index_type ycount;\n-  index_type xstride;\n-  index_type ystride;\n-  index_type x;\n-  index_type y;\n-\n-  GFC_INTEGER_8 *pa;\n-  GFC_INTEGER_8 *pb;\n-  index_type astride;\n-  index_type bstride;\n-  index_type count;\n-  index_type n;\n+\n+  index_type rxstride, rystride, axstride, aystride, bxstride, bystride;\n+  index_type x, y, n, count, xcount, ycount;\n \n   assert (GFC_DESCRIPTOR_RANK (a) == 2\n           || GFC_DESCRIPTOR_RANK (b) == 2);\n \n+/* C[xcount,ycount] = A[xcount, count] * B[count,ycount]\n+\n+   Either A or B (but not both) can be rank 1:\n+\n+   o One-dimensional argument A is implicitly treated as a row matrix\n+     dimensioned [1,count], so xcount=1.\n+\n+   o One-dimensional argument B is implicitly treated as a column matrix\n+     dimensioned [count, 1], so ycount=1.\n+  */\n+\n   if (retarray->data == NULL)\n     {\n       if (GFC_DESCRIPTOR_RANK (a) == 1)\n@@ -95,74 +104,99 @@ __matmul_i8 (gfc_array_i8 * retarray, gfc_array_i8 * a, gfc_array_i8 * b)\n \n   if (GFC_DESCRIPTOR_RANK (retarray) == 1)\n     {\n-      rxstride = retarray->dim[0].stride;\n-      rystride = rxstride;\n+      /* One-dimensional result may be addressed in the code below\n+\t either as a row or a column matrix. We want both cases to\n+\t work. */\n+      rxstride = rystride = retarray->dim[0].stride;\n     }\n   else\n     {\n       rxstride = retarray->dim[0].stride;\n       rystride = retarray->dim[1].stride;\n     }\n \n-  /* If we have rank 1 parameters, zero the absent stride, and set the size to\n-     one.  */\n+\n   if (GFC_DESCRIPTOR_RANK (a) == 1)\n     {\n-      astride = a->dim[0].stride;\n-      count = a->dim[0].ubound + 1 - a->dim[0].lbound;\n-      xstride = 0;\n-      rxstride = 0;\n+      /* Treat it as a a row matrix A[1,count]. */\n+      axstride = a->dim[0].stride;\n+      aystride = 1;\n+\n       xcount = 1;\n+      count = a->dim[0].ubound + 1 - a->dim[0].lbound;\n     }\n   else\n     {\n-      astride = a->dim[1].stride;\n+      axstride = a->dim[0].stride;\n+      aystride = a->dim[1].stride;\n+\n       count = a->dim[1].ubound + 1 - a->dim[1].lbound;\n-      xstride = a->dim[0].stride;\n       xcount = a->dim[0].ubound + 1 - a->dim[0].lbound;\n     }\n+\n+  assert(count == b->dim[0].ubound + 1 - b->dim[0].lbound);\n+\n   if (GFC_DESCRIPTOR_RANK (b) == 1)\n     {\n-      bstride = b->dim[0].stride;\n-      assert(count == b->dim[0].ubound + 1 - b->dim[0].lbound);\n-      ystride = 0;\n-      rystride = 0;\n+      /* Treat it as a column matrix B[count,1] */\n+      bxstride = b->dim[0].stride;\n+\n+      /* bystride should never be used for 1-dimensional b.\n+\t in case it is we want it to cause a segfault, rather than\n+\t an incorrect result. */\n+      bystride = 0xDEADBEEF; \n       ycount = 1;\n     }\n   else\n     {\n-      bstride = b->dim[0].stride;\n-      assert(count == b->dim[0].ubound + 1 - b->dim[0].lbound);\n-      ystride = b->dim[1].stride;\n+      bxstride = b->dim[0].stride;\n+      bystride = b->dim[1].stride;\n       ycount = b->dim[1].ubound + 1 - b->dim[1].lbound;\n     }\n \n-  for (y = 0; y < ycount; y++)\n+  assert (a->base == 0);\n+  assert (b->base == 0);\n+  assert (retarray->base == 0);\n+\n+  abase = a->data;\n+  bbase = b->data;\n+  dest = retarray->data;\n+\n+  if (rxstride == 1 && axstride == 1 && bxstride == 1)\n     {\n-      for (x = 0; x < xcount; x++)\n-        {\n-          /* Do the summation for this element.  For real and integer types\n-             this is the same as DOT_PRODUCT.  For complex types we use do\n-             a*b, not conjg(a)*b.  */\n-          pa = abase;\n-          pb = bbase;\n-          res = 0;\n-\n-          for (n = 0; n < count; n++)\n-            {\n-              res += *pa * *pb;\n-              pa += astride;\n-              pb += bstride;\n-            }\n-\n-          *dest = res;\n-\n-          dest += rxstride;\n-          abase += xstride;\n-        }\n-      abase -= xstride * xcount;\n-      bbase += ystride;\n-      dest += rystride - (rxstride * xcount);\n+      GFC_INTEGER_8 *bbase_y;\n+      GFC_INTEGER_8 *dest_y;\n+      GFC_INTEGER_8 *abase_n;\n+      GFC_INTEGER_8 bbase_yn;\n+\n+      memset (dest, 0, (sizeof (GFC_INTEGER_8) * size0(retarray)));\n+\n+      for (y = 0; y < ycount; y++)\n+\t{\n+\t  bbase_y = bbase + y*bystride;\n+\t  dest_y = dest + y*rystride;\n+\t  for (n = 0; n < count; n++)\n+\t    {\n+\t      abase_n = abase + n*aystride;\n+\t      bbase_yn = bbase_y[n];\n+\t      for (x = 0; x < xcount; x++)\n+\t\t{\n+\t\t  dest_y[x] += abase_n[x] * bbase_yn;\n+\t\t}\n+\t    }\n+\t}\n+    }\n+  else\n+    {\n+      for (y = 0; y < ycount; y++)\n+\tfor (x = 0; x < xcount; x++)\n+\t  dest[x*rxstride + y*rystride] = (GFC_INTEGER_8)0;\n+\n+      for (y = 0; y < ycount; y++)\n+\tfor (n = 0; n < count; n++)\n+\t  for (x = 0; x < xcount; x++)\n+\t    /* dest[x,y] += a[x,n] * b[n,y] */\n+\t    dest[x*rxstride + y*rystride] += abase[x*axstride + n*aystride] * bbase[n*bxstride + y*bystride];\n     }\n }\n "}, {"sha": "6896a2e9bef3a2205666f1ab3b309860119d9aae", "filename": "libgfortran/generated/matmul_r4.c", "status": "modified", "additions": 94, "deletions": 60, "changes": 154, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/410d3bbaa212a55cf614e74580e4213675291ce8/libgfortran%2Fgenerated%2Fmatmul_r4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/410d3bbaa212a55cf614e74580e4213675291ce8/libgfortran%2Fgenerated%2Fmatmul_r4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmatmul_r4.c?ref=410d3bbaa212a55cf614e74580e4213675291ce8", "patch": "@@ -21,37 +21,46 @@ Boston, MA 02111-1307, USA.  */\n \n #include \"config.h\"\n #include <stdlib.h>\n+#include <string.h>\n #include <assert.h>\n #include \"libgfortran.h\"\n \n-/* Dimensions: retarray(x,y) a(x, count) b(count,y).\n-   Either a or b can be rank 1.  In this case x or y is 1.  */\n+/* This is a C version of the following fortran pseudo-code. The key\n+   point is the loop order -- we access all arrays column-first, which\n+   improves the performance enough to boost galgel spec score by 50%.\n+\n+   DIMENSION A(M,COUNT), B(COUNT,N), C(M,N)\n+   C = 0\n+   DO J=1,N\n+     DO K=1,COUNT\n+       DO I=1,M\n+         C(I,J) = C(I,J)+A(I,K)*B(K,J)\n+*/\n+\n void\n __matmul_r4 (gfc_array_r4 * retarray, gfc_array_r4 * a, gfc_array_r4 * b)\n {\n   GFC_REAL_4 *abase;\n   GFC_REAL_4 *bbase;\n   GFC_REAL_4 *dest;\n-  GFC_REAL_4 res;\n-  index_type rxstride;\n-  index_type rystride;\n-  index_type xcount;\n-  index_type ycount;\n-  index_type xstride;\n-  index_type ystride;\n-  index_type x;\n-  index_type y;\n-\n-  GFC_REAL_4 *pa;\n-  GFC_REAL_4 *pb;\n-  index_type astride;\n-  index_type bstride;\n-  index_type count;\n-  index_type n;\n+\n+  index_type rxstride, rystride, axstride, aystride, bxstride, bystride;\n+  index_type x, y, n, count, xcount, ycount;\n \n   assert (GFC_DESCRIPTOR_RANK (a) == 2\n           || GFC_DESCRIPTOR_RANK (b) == 2);\n \n+/* C[xcount,ycount] = A[xcount, count] * B[count,ycount]\n+\n+   Either A or B (but not both) can be rank 1:\n+\n+   o One-dimensional argument A is implicitly treated as a row matrix\n+     dimensioned [1,count], so xcount=1.\n+\n+   o One-dimensional argument B is implicitly treated as a column matrix\n+     dimensioned [count, 1], so ycount=1.\n+  */\n+\n   if (retarray->data == NULL)\n     {\n       if (GFC_DESCRIPTOR_RANK (a) == 1)\n@@ -95,74 +104,99 @@ __matmul_r4 (gfc_array_r4 * retarray, gfc_array_r4 * a, gfc_array_r4 * b)\n \n   if (GFC_DESCRIPTOR_RANK (retarray) == 1)\n     {\n-      rxstride = retarray->dim[0].stride;\n-      rystride = rxstride;\n+      /* One-dimensional result may be addressed in the code below\n+\t either as a row or a column matrix. We want both cases to\n+\t work. */\n+      rxstride = rystride = retarray->dim[0].stride;\n     }\n   else\n     {\n       rxstride = retarray->dim[0].stride;\n       rystride = retarray->dim[1].stride;\n     }\n \n-  /* If we have rank 1 parameters, zero the absent stride, and set the size to\n-     one.  */\n+\n   if (GFC_DESCRIPTOR_RANK (a) == 1)\n     {\n-      astride = a->dim[0].stride;\n-      count = a->dim[0].ubound + 1 - a->dim[0].lbound;\n-      xstride = 0;\n-      rxstride = 0;\n+      /* Treat it as a a row matrix A[1,count]. */\n+      axstride = a->dim[0].stride;\n+      aystride = 1;\n+\n       xcount = 1;\n+      count = a->dim[0].ubound + 1 - a->dim[0].lbound;\n     }\n   else\n     {\n-      astride = a->dim[1].stride;\n+      axstride = a->dim[0].stride;\n+      aystride = a->dim[1].stride;\n+\n       count = a->dim[1].ubound + 1 - a->dim[1].lbound;\n-      xstride = a->dim[0].stride;\n       xcount = a->dim[0].ubound + 1 - a->dim[0].lbound;\n     }\n+\n+  assert(count == b->dim[0].ubound + 1 - b->dim[0].lbound);\n+\n   if (GFC_DESCRIPTOR_RANK (b) == 1)\n     {\n-      bstride = b->dim[0].stride;\n-      assert(count == b->dim[0].ubound + 1 - b->dim[0].lbound);\n-      ystride = 0;\n-      rystride = 0;\n+      /* Treat it as a column matrix B[count,1] */\n+      bxstride = b->dim[0].stride;\n+\n+      /* bystride should never be used for 1-dimensional b.\n+\t in case it is we want it to cause a segfault, rather than\n+\t an incorrect result. */\n+      bystride = 0xDEADBEEF; \n       ycount = 1;\n     }\n   else\n     {\n-      bstride = b->dim[0].stride;\n-      assert(count == b->dim[0].ubound + 1 - b->dim[0].lbound);\n-      ystride = b->dim[1].stride;\n+      bxstride = b->dim[0].stride;\n+      bystride = b->dim[1].stride;\n       ycount = b->dim[1].ubound + 1 - b->dim[1].lbound;\n     }\n \n-  for (y = 0; y < ycount; y++)\n+  assert (a->base == 0);\n+  assert (b->base == 0);\n+  assert (retarray->base == 0);\n+\n+  abase = a->data;\n+  bbase = b->data;\n+  dest = retarray->data;\n+\n+  if (rxstride == 1 && axstride == 1 && bxstride == 1)\n     {\n-      for (x = 0; x < xcount; x++)\n-        {\n-          /* Do the summation for this element.  For real and integer types\n-             this is the same as DOT_PRODUCT.  For complex types we use do\n-             a*b, not conjg(a)*b.  */\n-          pa = abase;\n-          pb = bbase;\n-          res = 0;\n-\n-          for (n = 0; n < count; n++)\n-            {\n-              res += *pa * *pb;\n-              pa += astride;\n-              pb += bstride;\n-            }\n-\n-          *dest = res;\n-\n-          dest += rxstride;\n-          abase += xstride;\n-        }\n-      abase -= xstride * xcount;\n-      bbase += ystride;\n-      dest += rystride - (rxstride * xcount);\n+      GFC_REAL_4 *bbase_y;\n+      GFC_REAL_4 *dest_y;\n+      GFC_REAL_4 *abase_n;\n+      GFC_REAL_4 bbase_yn;\n+\n+      memset (dest, 0, (sizeof (GFC_REAL_4) * size0(retarray)));\n+\n+      for (y = 0; y < ycount; y++)\n+\t{\n+\t  bbase_y = bbase + y*bystride;\n+\t  dest_y = dest + y*rystride;\n+\t  for (n = 0; n < count; n++)\n+\t    {\n+\t      abase_n = abase + n*aystride;\n+\t      bbase_yn = bbase_y[n];\n+\t      for (x = 0; x < xcount; x++)\n+\t\t{\n+\t\t  dest_y[x] += abase_n[x] * bbase_yn;\n+\t\t}\n+\t    }\n+\t}\n+    }\n+  else\n+    {\n+      for (y = 0; y < ycount; y++)\n+\tfor (x = 0; x < xcount; x++)\n+\t  dest[x*rxstride + y*rystride] = (GFC_REAL_4)0;\n+\n+      for (y = 0; y < ycount; y++)\n+\tfor (n = 0; n < count; n++)\n+\t  for (x = 0; x < xcount; x++)\n+\t    /* dest[x,y] += a[x,n] * b[n,y] */\n+\t    dest[x*rxstride + y*rystride] += abase[x*axstride + n*aystride] * bbase[n*bxstride + y*bystride];\n     }\n }\n "}, {"sha": "f0fc1a64a858f79a8de7002c291e10b3a45f70e6", "filename": "libgfortran/generated/matmul_r8.c", "status": "modified", "additions": 94, "deletions": 60, "changes": 154, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/410d3bbaa212a55cf614e74580e4213675291ce8/libgfortran%2Fgenerated%2Fmatmul_r8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/410d3bbaa212a55cf614e74580e4213675291ce8/libgfortran%2Fgenerated%2Fmatmul_r8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmatmul_r8.c?ref=410d3bbaa212a55cf614e74580e4213675291ce8", "patch": "@@ -21,37 +21,46 @@ Boston, MA 02111-1307, USA.  */\n \n #include \"config.h\"\n #include <stdlib.h>\n+#include <string.h>\n #include <assert.h>\n #include \"libgfortran.h\"\n \n-/* Dimensions: retarray(x,y) a(x, count) b(count,y).\n-   Either a or b can be rank 1.  In this case x or y is 1.  */\n+/* This is a C version of the following fortran pseudo-code. The key\n+   point is the loop order -- we access all arrays column-first, which\n+   improves the performance enough to boost galgel spec score by 50%.\n+\n+   DIMENSION A(M,COUNT), B(COUNT,N), C(M,N)\n+   C = 0\n+   DO J=1,N\n+     DO K=1,COUNT\n+       DO I=1,M\n+         C(I,J) = C(I,J)+A(I,K)*B(K,J)\n+*/\n+\n void\n __matmul_r8 (gfc_array_r8 * retarray, gfc_array_r8 * a, gfc_array_r8 * b)\n {\n   GFC_REAL_8 *abase;\n   GFC_REAL_8 *bbase;\n   GFC_REAL_8 *dest;\n-  GFC_REAL_8 res;\n-  index_type rxstride;\n-  index_type rystride;\n-  index_type xcount;\n-  index_type ycount;\n-  index_type xstride;\n-  index_type ystride;\n-  index_type x;\n-  index_type y;\n-\n-  GFC_REAL_8 *pa;\n-  GFC_REAL_8 *pb;\n-  index_type astride;\n-  index_type bstride;\n-  index_type count;\n-  index_type n;\n+\n+  index_type rxstride, rystride, axstride, aystride, bxstride, bystride;\n+  index_type x, y, n, count, xcount, ycount;\n \n   assert (GFC_DESCRIPTOR_RANK (a) == 2\n           || GFC_DESCRIPTOR_RANK (b) == 2);\n \n+/* C[xcount,ycount] = A[xcount, count] * B[count,ycount]\n+\n+   Either A or B (but not both) can be rank 1:\n+\n+   o One-dimensional argument A is implicitly treated as a row matrix\n+     dimensioned [1,count], so xcount=1.\n+\n+   o One-dimensional argument B is implicitly treated as a column matrix\n+     dimensioned [count, 1], so ycount=1.\n+  */\n+\n   if (retarray->data == NULL)\n     {\n       if (GFC_DESCRIPTOR_RANK (a) == 1)\n@@ -95,74 +104,99 @@ __matmul_r8 (gfc_array_r8 * retarray, gfc_array_r8 * a, gfc_array_r8 * b)\n \n   if (GFC_DESCRIPTOR_RANK (retarray) == 1)\n     {\n-      rxstride = retarray->dim[0].stride;\n-      rystride = rxstride;\n+      /* One-dimensional result may be addressed in the code below\n+\t either as a row or a column matrix. We want both cases to\n+\t work. */\n+      rxstride = rystride = retarray->dim[0].stride;\n     }\n   else\n     {\n       rxstride = retarray->dim[0].stride;\n       rystride = retarray->dim[1].stride;\n     }\n \n-  /* If we have rank 1 parameters, zero the absent stride, and set the size to\n-     one.  */\n+\n   if (GFC_DESCRIPTOR_RANK (a) == 1)\n     {\n-      astride = a->dim[0].stride;\n-      count = a->dim[0].ubound + 1 - a->dim[0].lbound;\n-      xstride = 0;\n-      rxstride = 0;\n+      /* Treat it as a a row matrix A[1,count]. */\n+      axstride = a->dim[0].stride;\n+      aystride = 1;\n+\n       xcount = 1;\n+      count = a->dim[0].ubound + 1 - a->dim[0].lbound;\n     }\n   else\n     {\n-      astride = a->dim[1].stride;\n+      axstride = a->dim[0].stride;\n+      aystride = a->dim[1].stride;\n+\n       count = a->dim[1].ubound + 1 - a->dim[1].lbound;\n-      xstride = a->dim[0].stride;\n       xcount = a->dim[0].ubound + 1 - a->dim[0].lbound;\n     }\n+\n+  assert(count == b->dim[0].ubound + 1 - b->dim[0].lbound);\n+\n   if (GFC_DESCRIPTOR_RANK (b) == 1)\n     {\n-      bstride = b->dim[0].stride;\n-      assert(count == b->dim[0].ubound + 1 - b->dim[0].lbound);\n-      ystride = 0;\n-      rystride = 0;\n+      /* Treat it as a column matrix B[count,1] */\n+      bxstride = b->dim[0].stride;\n+\n+      /* bystride should never be used for 1-dimensional b.\n+\t in case it is we want it to cause a segfault, rather than\n+\t an incorrect result. */\n+      bystride = 0xDEADBEEF; \n       ycount = 1;\n     }\n   else\n     {\n-      bstride = b->dim[0].stride;\n-      assert(count == b->dim[0].ubound + 1 - b->dim[0].lbound);\n-      ystride = b->dim[1].stride;\n+      bxstride = b->dim[0].stride;\n+      bystride = b->dim[1].stride;\n       ycount = b->dim[1].ubound + 1 - b->dim[1].lbound;\n     }\n \n-  for (y = 0; y < ycount; y++)\n+  assert (a->base == 0);\n+  assert (b->base == 0);\n+  assert (retarray->base == 0);\n+\n+  abase = a->data;\n+  bbase = b->data;\n+  dest = retarray->data;\n+\n+  if (rxstride == 1 && axstride == 1 && bxstride == 1)\n     {\n-      for (x = 0; x < xcount; x++)\n-        {\n-          /* Do the summation for this element.  For real and integer types\n-             this is the same as DOT_PRODUCT.  For complex types we use do\n-             a*b, not conjg(a)*b.  */\n-          pa = abase;\n-          pb = bbase;\n-          res = 0;\n-\n-          for (n = 0; n < count; n++)\n-            {\n-              res += *pa * *pb;\n-              pa += astride;\n-              pb += bstride;\n-            }\n-\n-          *dest = res;\n-\n-          dest += rxstride;\n-          abase += xstride;\n-        }\n-      abase -= xstride * xcount;\n-      bbase += ystride;\n-      dest += rystride - (rxstride * xcount);\n+      GFC_REAL_8 *bbase_y;\n+      GFC_REAL_8 *dest_y;\n+      GFC_REAL_8 *abase_n;\n+      GFC_REAL_8 bbase_yn;\n+\n+      memset (dest, 0, (sizeof (GFC_REAL_8) * size0(retarray)));\n+\n+      for (y = 0; y < ycount; y++)\n+\t{\n+\t  bbase_y = bbase + y*bystride;\n+\t  dest_y = dest + y*rystride;\n+\t  for (n = 0; n < count; n++)\n+\t    {\n+\t      abase_n = abase + n*aystride;\n+\t      bbase_yn = bbase_y[n];\n+\t      for (x = 0; x < xcount; x++)\n+\t\t{\n+\t\t  dest_y[x] += abase_n[x] * bbase_yn;\n+\t\t}\n+\t    }\n+\t}\n+    }\n+  else\n+    {\n+      for (y = 0; y < ycount; y++)\n+\tfor (x = 0; x < xcount; x++)\n+\t  dest[x*rxstride + y*rystride] = (GFC_REAL_8)0;\n+\n+      for (y = 0; y < ycount; y++)\n+\tfor (n = 0; n < count; n++)\n+\t  for (x = 0; x < xcount; x++)\n+\t    /* dest[x,y] += a[x,n] * b[n,y] */\n+\t    dest[x*rxstride + y*rystride] += abase[x*axstride + n*aystride] * bbase[n*bxstride + y*bystride];\n     }\n }\n "}, {"sha": "0602be690615ac27e6a85eeae3fc487a284f9344", "filename": "libgfortran/m4/matmul.m4", "status": "modified", "additions": 94, "deletions": 60, "changes": 154, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/410d3bbaa212a55cf614e74580e4213675291ce8/libgfortran%2Fm4%2Fmatmul.m4", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/410d3bbaa212a55cf614e74580e4213675291ce8/libgfortran%2Fm4%2Fmatmul.m4", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fm4%2Fmatmul.m4?ref=410d3bbaa212a55cf614e74580e4213675291ce8", "patch": "@@ -21,38 +21,47 @@ Boston, MA 02111-1307, USA.  */\n \n #include \"config.h\"\n #include <stdlib.h>\n+#include <string.h>\n #include <assert.h>\n #include \"libgfortran.h\"'\n include(iparm.m4)dnl\n \n-/* Dimensions: retarray(x,y) a(x, count) b(count,y).\n-   Either a or b can be rank 1.  In this case x or y is 1.  */\n+/* This is a C version of the following fortran pseudo-code. The key\n+   point is the loop order -- we access all arrays column-first, which\n+   improves the performance enough to boost galgel spec score by 50%.\n+\n+   DIMENSION A(M,COUNT), B(COUNT,N), C(M,N)\n+   C = 0\n+   DO J=1,N\n+     DO K=1,COUNT\n+       DO I=1,M\n+         C(I,J) = C(I,J)+A(I,K)*B(K,J)\n+*/\n+\n void\n `__matmul_'rtype_code (rtype * retarray, rtype * a, rtype * b)\n {\n   rtype_name *abase;\n   rtype_name *bbase;\n   rtype_name *dest;\n-  rtype_name res;\n-  index_type rxstride;\n-  index_type rystride;\n-  index_type xcount;\n-  index_type ycount;\n-  index_type xstride;\n-  index_type ystride;\n-  index_type x;\n-  index_type y;\n-\n-  rtype_name *pa;\n-  rtype_name *pb;\n-  index_type astride;\n-  index_type bstride;\n-  index_type count;\n-  index_type n;\n+\n+  index_type rxstride, rystride, axstride, aystride, bxstride, bystride;\n+  index_type x, y, n, count, xcount, ycount;\n \n   assert (GFC_DESCRIPTOR_RANK (a) == 2\n           || GFC_DESCRIPTOR_RANK (b) == 2);\n \n+/* C[xcount,ycount] = A[xcount, count] * B[count,ycount]\n+\n+   Either A or B (but not both) can be rank 1:\n+\n+   o One-dimensional argument A is implicitly treated as a row matrix\n+     dimensioned [1,count], so xcount=1.\n+\n+   o One-dimensional argument B is implicitly treated as a column matrix\n+     dimensioned [count, 1], so ycount=1.\n+  */\n+\n   if (retarray->data == NULL)\n     {\n       if (GFC_DESCRIPTOR_RANK (a) == 1)\n@@ -97,74 +106,99 @@ sinclude(`matmul_asm_'rtype_code`.m4')dnl\n \n   if (GFC_DESCRIPTOR_RANK (retarray) == 1)\n     {\n-      rxstride = retarray->dim[0].stride;\n-      rystride = rxstride;\n+      /* One-dimensional result may be addressed in the code below\n+\t either as a row or a column matrix. We want both cases to\n+\t work. */\n+      rxstride = rystride = retarray->dim[0].stride;\n     }\n   else\n     {\n       rxstride = retarray->dim[0].stride;\n       rystride = retarray->dim[1].stride;\n     }\n \n-  /* If we have rank 1 parameters, zero the absent stride, and set the size to\n-     one.  */\n+\n   if (GFC_DESCRIPTOR_RANK (a) == 1)\n     {\n-      astride = a->dim[0].stride;\n-      count = a->dim[0].ubound + 1 - a->dim[0].lbound;\n-      xstride = 0;\n-      rxstride = 0;\n+      /* Treat it as a a row matrix A[1,count]. */\n+      axstride = a->dim[0].stride;\n+      aystride = 1;\n+\n       xcount = 1;\n+      count = a->dim[0].ubound + 1 - a->dim[0].lbound;\n     }\n   else\n     {\n-      astride = a->dim[1].stride;\n+      axstride = a->dim[0].stride;\n+      aystride = a->dim[1].stride;\n+\n       count = a->dim[1].ubound + 1 - a->dim[1].lbound;\n-      xstride = a->dim[0].stride;\n       xcount = a->dim[0].ubound + 1 - a->dim[0].lbound;\n     }\n+\n+  assert(count == b->dim[0].ubound + 1 - b->dim[0].lbound);\n+\n   if (GFC_DESCRIPTOR_RANK (b) == 1)\n     {\n-      bstride = b->dim[0].stride;\n-      assert(count == b->dim[0].ubound + 1 - b->dim[0].lbound);\n-      ystride = 0;\n-      rystride = 0;\n+      /* Treat it as a column matrix B[count,1] */\n+      bxstride = b->dim[0].stride;\n+\n+      /* bystride should never be used for 1-dimensional b.\n+\t in case it is we want it to cause a segfault, rather than\n+\t an incorrect result. */\n+      bystride = 0xDEADBEEF; \n       ycount = 1;\n     }\n   else\n     {\n-      bstride = b->dim[0].stride;\n-      assert(count == b->dim[0].ubound + 1 - b->dim[0].lbound);\n-      ystride = b->dim[1].stride;\n+      bxstride = b->dim[0].stride;\n+      bystride = b->dim[1].stride;\n       ycount = b->dim[1].ubound + 1 - b->dim[1].lbound;\n     }\n \n-  for (y = 0; y < ycount; y++)\n+  assert (a->base == 0);\n+  assert (b->base == 0);\n+  assert (retarray->base == 0);\n+\n+  abase = a->data;\n+  bbase = b->data;\n+  dest = retarray->data;\n+\n+  if (rxstride == 1 && axstride == 1 && bxstride == 1)\n     {\n-      for (x = 0; x < xcount; x++)\n-        {\n-          /* Do the summation for this element.  For real and integer types\n-             this is the same as DOT_PRODUCT.  For complex types we use do\n-             a*b, not conjg(a)*b.  */\n-          pa = abase;\n-          pb = bbase;\n-          res = 0;\n-\n-          for (n = 0; n < count; n++)\n-            {\n-              res += *pa * *pb;\n-              pa += astride;\n-              pb += bstride;\n-            }\n-\n-          *dest = res;\n-\n-          dest += rxstride;\n-          abase += xstride;\n-        }\n-      abase -= xstride * xcount;\n-      bbase += ystride;\n-      dest += rystride - (rxstride * xcount);\n+      rtype_name *bbase_y;\n+      rtype_name *dest_y;\n+      rtype_name *abase_n;\n+      rtype_name bbase_yn;\n+\n+      memset (dest, 0, (sizeof (rtype_name) * size0(retarray)));\n+\n+      for (y = 0; y < ycount; y++)\n+\t{\n+\t  bbase_y = bbase + y*bystride;\n+\t  dest_y = dest + y*rystride;\n+\t  for (n = 0; n < count; n++)\n+\t    {\n+\t      abase_n = abase + n*aystride;\n+\t      bbase_yn = bbase_y[n];\n+\t      for (x = 0; x < xcount; x++)\n+\t\t{\n+\t\t  dest_y[x] += abase_n[x] * bbase_yn;\n+\t\t}\n+\t    }\n+\t}\n+    }\n+  else\n+    {\n+      for (y = 0; y < ycount; y++)\n+\tfor (x = 0; x < xcount; x++)\n+\t  dest[x*rxstride + y*rystride] = (rtype_name)0;\n+\n+      for (y = 0; y < ycount; y++)\n+\tfor (n = 0; n < count; n++)\n+\t  for (x = 0; x < xcount; x++)\n+\t    /* dest[x,y] += a[x,n] * b[n,y] */\n+\t    dest[x*rxstride + y*rystride] += abase[x*axstride + n*aystride] * bbase[n*bxstride + y*bystride];\n     }\n }\n "}]}