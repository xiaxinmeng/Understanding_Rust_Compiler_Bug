{"sha": "98cd3025d4d3204a18f327627a61b6773fd377a5", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OThjZDMwMjVkNGQzMjA0YTE4ZjMyNzYyN2E2MWI2NzczZmQzNzdhNQ==", "commit": {"author": {"name": "Eric Botcazou", "email": "ebotcazou@adacore.com", "date": "2010-11-09T11:59:55Z"}, "committer": {"name": "Eric Botcazou", "email": "ebotcazou@gcc.gnu.org", "date": "2010-11-09T11:59:55Z"}, "message": "tree.h (contains_placeholder_p): Fix comment.\n\n\t* tree.h (contains_placeholder_p): Fix comment.\n\t(type_contains_placeholder_p): Adjust comment.\n\t* tree.c (contains_placeholder_p): Fix comment.\n\t(type_contains_placeholder_1): Do not recurse on pointed-to types and\n\tadjust comment.\n\t(type_contains_placeholder_p): Add comment.\nada/\n\t* gcc-interface/decl.c (finish_fat_pointer_type): New function.\n\t(gnat_to_gnu_entity) <E_Array_Type>: Use it to build the fat pointer\n\ttype.\n\t<E_Access_Type>: Likewise.\n\nFrom-SVN: r166484", "tree": {"sha": "f3683767b5743cd5036a7a65c1816ad7f965366b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f3683767b5743cd5036a7a65c1816ad7f965366b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/98cd3025d4d3204a18f327627a61b6773fd377a5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/98cd3025d4d3204a18f327627a61b6773fd377a5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/98cd3025d4d3204a18f327627a61b6773fd377a5", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/98cd3025d4d3204a18f327627a61b6773fd377a5/comments", "author": null, "committer": null, "parents": [{"sha": "b9cb66d281d279a13ed9628a9046e4523cb677d5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b9cb66d281d279a13ed9628a9046e4523cb677d5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b9cb66d281d279a13ed9628a9046e4523cb677d5"}], "stats": {"total": 141, "additions": 98, "deletions": 43}, "files": [{"sha": "3db49916f733a5c4818fcb76ac77376e11f77a17", "filename": "gcc/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/98cd3025d4d3204a18f327627a61b6773fd377a5/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/98cd3025d4d3204a18f327627a61b6773fd377a5/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=98cd3025d4d3204a18f327627a61b6773fd377a5", "patch": "@@ -1,3 +1,12 @@\n+2010-11-09  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\t* tree.h (contains_placeholder_p): Fix comment.\n+\t(type_contains_placeholder_p): Adjust comment.\n+\t* tree.c (contains_placeholder_p): Fix comment.\n+\t(type_contains_placeholder_1): Do not recurse on pointed-to types and\n+\tadjust comment.\n+\t(type_contains_placeholder_p): Add comment.\n+\n 2010-11-09  Paul Koning  <ni1d@arrl.net>\n \n \t* config/pdp11/pdp11.c (pdp11_assemble_integer): Clean up fix for"}, {"sha": "f4cc6a2b505169d3b33048cf255a8a7ffe21d518", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/98cd3025d4d3204a18f327627a61b6773fd377a5/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/98cd3025d4d3204a18f327627a61b6773fd377a5/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=98cd3025d4d3204a18f327627a61b6773fd377a5", "patch": "@@ -1,3 +1,10 @@\n+2010-11-09  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\t* gcc-interface/decl.c (finish_fat_pointer_type): New function.\n+\t(gnat_to_gnu_entity) <E_Array_Type>: Use it to build the fat pointer\n+\ttype.\n+\t<E_Access_Type>: Likewise.\n+\n 2010-11-02  Eric Botcazou  <ebotcazou@adacore.com>\n \n \t* gcc-interface/gigi.h (add_stmt_force): Declare."}, {"sha": "c2b82786a847a1aec2fbf0e98dc207df5ea91f75", "filename": "gcc/ada/gcc-interface/decl.c", "status": "modified", "additions": 31, "deletions": 27, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/98cd3025d4d3204a18f327627a61b6773fd377a5/gcc%2Fada%2Fgcc-interface%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/98cd3025d4d3204a18f327627a61b6773fd377a5/gcc%2Fada%2Fgcc-interface%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Fdecl.c?ref=98cd3025d4d3204a18f327627a61b6773fd377a5", "patch": "@@ -177,6 +177,7 @@ static tree create_variant_part_from (tree, VEC(variant_desc,heap) *, tree,\n \t\t\t\t      tree, VEC(subst_pair,heap) *);\n static void copy_and_substitute_in_size (tree, tree, VEC(subst_pair,heap) *);\n static void rest_of_type_decl_compilation_no_defer (tree);\n+static void finish_fat_pointer_type (tree, tree);\n \n /* The relevant constituents of a subprogram binding to a GCC builtin.  Used\n    to pass around calls performing profile compatibilty checks.  */\n@@ -188,7 +189,6 @@ typedef struct {\n } intrin_binding_t;\n \n static bool intrin_profiles_compatible_p (intrin_binding_t *);\n-\n \f\n /* Given GNAT_ENTITY, a GNAT defining identifier node, which denotes some Ada\n    entity, return the equivalent GCC tree for that entity (a ..._DECL node)\n@@ -1915,23 +1915,13 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t/* Build the fat pointer type.  Use a \"void *\" object instead of\n \t   a pointer to the array type since we don't have the array type\n \t   yet (it will reference the fat pointer via the bounds).  */\n-\ttem = chainon (chainon (NULL_TREE,\n-\t\t\t\tcreate_field_decl (get_identifier (\"P_ARRAY\"),\n-\t\t\t\t\t\t   ptr_void_type_node,\n-\t\t\t\t\t\t   gnu_fat_type, NULL_TREE,\n-\t\t\t\t\t\t   NULL_TREE, 0, 0)),\n-\t\t       create_field_decl (get_identifier (\"P_BOUNDS\"),\n-\t\t\t\t\t  gnu_ptr_template,\n-\t\t\t\t\t  gnu_fat_type, NULL_TREE,\n-\t\t\t\t\t  NULL_TREE, 0, 0));\n-\n-\t/* Make sure we can put this into a register.  */\n-\tTYPE_ALIGN (gnu_fat_type) = MIN (BIGGEST_ALIGNMENT, 2 * POINTER_SIZE);\n-\n-\t/* Do not emit debug info for this record type since the types of its\n-\t   fields are still incomplete at this point.  */\n-\tfinish_record_type (gnu_fat_type, tem, 0, false);\n-\tTYPE_FAT_POINTER_P (gnu_fat_type) = 1;\n+\ttem\n+\t  = create_field_decl (get_identifier (\"P_ARRAY\"), ptr_void_type_node,\n+\t\t\t       gnu_fat_type, NULL_TREE, NULL_TREE, 0, 0);\n+\tTREE_CHAIN (tem)\n+\t  = create_field_decl (get_identifier (\"P_BOUNDS\"), gnu_ptr_template,\n+\t\t\t       gnu_fat_type, NULL_TREE, NULL_TREE, 0, 0);\n+\tfinish_fat_pointer_type (gnu_fat_type, tem);\n \n \t/* Build a reference to the template from a PLACEHOLDER_EXPR that\n \t   is the fat pointer.  This will be used to access the individual\n@@ -3587,15 +3577,7 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t\t  = create_field_decl (get_identifier (\"P_BOUNDS\"),\n \t\t\t\t       gnu_ptr_template, gnu_type,\n \t\t\t\t       NULL_TREE, NULL_TREE, 0, 0);\n-\n-\t\t/* Make sure we can place this into a register.  */\n-\t\tTYPE_ALIGN (gnu_type)\n-\t\t  = MIN (BIGGEST_ALIGNMENT, 2 * POINTER_SIZE);\n-\t\tTYPE_FAT_POINTER_P (gnu_type) = 1;\n-\n-\t\t/* Do not emit debug info for this record type since the types\n-\t\t   of its fields are incomplete.  */\n-\t\tfinish_record_type (gnu_type, fields, 0, false);\n+\t\tfinish_fat_pointer_type (gnu_type, fields);\n \n \t\tTYPE_OBJECT_RECORD_TYPE (gnu_desig_type)\n \t\t  = make_node (RECORD_TYPE);\n@@ -5125,6 +5107,28 @@ rest_of_type_decl_compilation_no_defer (tree decl)\n     }\n }\n \n+/* Given a record type RECORD_TYPE and a list of FIELD_DECL nodes FIELD_LIST,\n+   finish constructing the record type as a fat pointer type.  */\n+\n+static void\n+finish_fat_pointer_type (tree record_type, tree field_list)\n+{\n+  /* Make sure we can put it into a register.  */\n+  TYPE_ALIGN (record_type) = MIN (BIGGEST_ALIGNMENT, 2 * POINTER_SIZE);\n+\n+  /* Show what it really is.  */\n+  TYPE_FAT_POINTER_P (record_type) = 1;\n+\n+  /* Do not emit debug info for it since the types of its fields may still be\n+     incomplete at this point.  */\n+  finish_record_type (record_type, field_list, 0, false);\n+\n+  /* Force type_contains_placeholder_p to return true on it.  Although the\n+     PLACEHOLDER_EXPRs are referenced only indirectly, this isn't a pointer\n+     type but the representation of the unconstrained array.  */\n+  TYPE_CONTAINS_PLACEHOLDER_INTERNAL (record_type) = 2;\n+}\n+\n /* Finalize any From_With_Type incomplete types.  We do this after processing\n    our compilation unit and after processing its spec, if this is a body.  */\n "}, {"sha": "6e1dde84e933deb189e999a119398a3d606fec71", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/98cd3025d4d3204a18f327627a61b6773fd377a5/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/98cd3025d4d3204a18f327627a61b6773fd377a5/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=98cd3025d4d3204a18f327627a61b6773fd377a5", "patch": "@@ -1,3 +1,8 @@\n+2010-11-09  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\t* gnat.dg/specs/static_initializer5.ads: New test.\n+\t* gnat.dg/specs/static_initializer5_pkg.ads: New helper.\n+\n 2010-11-09  Jakub Jelinek  <jakub@redhat.com>\n \n \tPR middle-end/46360"}, {"sha": "29845ceebb2c9de72efe67ffee69818984ff196a", "filename": "gcc/testsuite/gnat.dg/specs/static_initializer5.ads", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/98cd3025d4d3204a18f327627a61b6773fd377a5/gcc%2Ftestsuite%2Fgnat.dg%2Fspecs%2Fstatic_initializer5.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/98cd3025d4d3204a18f327627a61b6773fd377a5/gcc%2Ftestsuite%2Fgnat.dg%2Fspecs%2Fstatic_initializer5.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgnat.dg%2Fspecs%2Fstatic_initializer5.ads?ref=98cd3025d4d3204a18f327627a61b6773fd377a5", "patch": "@@ -0,0 +1,13 @@\n+-- { dg-do compile }\n+\n+with Static_Initializer5_Pkg; use Static_Initializer5_Pkg;\n+\n+package Static_Initializer5 is\n+\n+   type Derived is new Rec with record\n+      Target : Boolean;\n+   end record;\n+\n+   Null_Derived : constant Derived := (Null_Rec with Target => False);\n+\n+end Static_Initializer5;"}, {"sha": "16a8f7277180c9c08382c26aea7a589172c83b3f", "filename": "gcc/testsuite/gnat.dg/specs/static_initializer5_pkg.ads", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/98cd3025d4d3204a18f327627a61b6773fd377a5/gcc%2Ftestsuite%2Fgnat.dg%2Fspecs%2Fstatic_initializer5_pkg.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/98cd3025d4d3204a18f327627a61b6773fd377a5/gcc%2Ftestsuite%2Fgnat.dg%2Fspecs%2Fstatic_initializer5_pkg.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgnat.dg%2Fspecs%2Fstatic_initializer5_pkg.ads?ref=98cd3025d4d3204a18f327627a61b6773fd377a5", "patch": "@@ -0,0 +1,17 @@\n+package Static_Initializer5_Pkg is\n+\n+   type Arr is array (Positive range <>) of Character;\n+\n+   type Buffer_Type (Length : Positive) is record\n+      Content : Arr (1 .. Length);\n+   end record;\n+\n+   type Buffer_Access is access Buffer_Type;\n+\n+   type Rec is tagged record\n+      Buffer : Buffer_Access;\n+   end record;\n+\n+   Null_Rec : constant Rec := (Buffer => null);\n+\n+end Static_Initializer5_Pkg;"}, {"sha": "756ceaac1f29658f2f1b834db75922e0f84bdd8e", "filename": "gcc/tree.c", "status": "modified", "additions": 11, "deletions": 8, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/98cd3025d4d3204a18f327627a61b6773fd377a5/gcc%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/98cd3025d4d3204a18f327627a61b6773fd377a5/gcc%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.c?ref=98cd3025d4d3204a18f327627a61b6773fd377a5", "patch": "@@ -2795,8 +2795,8 @@ process_call_operands (tree t)\n   TREE_READONLY (t) = read_only;\n }\n \f\n-/* Return 1 if EXP contains a PLACEHOLDER_EXPR; i.e., if it represents a size\n-   or offset that depends on a field within a record.  */\n+/* Return true if EXP contains a PLACEHOLDER_EXPR, i.e. if it represents a\n+   size or offset that depends on a field within a record.  */\n \n bool\n contains_placeholder_p (const_tree exp)\n@@ -2882,9 +2882,9 @@ contains_placeholder_p (const_tree exp)\n   return 0;\n }\n \n-/* Return true if any part of the computation of TYPE involves a\n-   PLACEHOLDER_EXPR.  This includes size, bounds, qualifiers\n-   (for QUAL_UNION_TYPE) and field positions.  */\n+/* Return true if any part of the structure of TYPE involves a PLACEHOLDER_EXPR\n+   directly.  This includes size, bounds, qualifiers (for QUAL_UNION_TYPE) and\n+   field positions.  */\n \n static bool\n type_contains_placeholder_1 (const_tree type)\n@@ -2893,7 +2893,8 @@ type_contains_placeholder_1 (const_tree type)\n      the case of arrays) type involves a placeholder, this type does.  */\n   if (CONTAINS_PLACEHOLDER_P (TYPE_SIZE (type))\n       || CONTAINS_PLACEHOLDER_P (TYPE_SIZE_UNIT (type))\n-      || (TREE_TYPE (type) != 0\n+      || (!POINTER_TYPE_P (type)\n+\t  && TREE_TYPE (type)\n \t  && type_contains_placeholder_p (TREE_TYPE (type))))\n     return true;\n \n@@ -2921,8 +2922,8 @@ type_contains_placeholder_1 (const_tree type)\n \t      || CONTAINS_PLACEHOLDER_P (TYPE_MAX_VALUE (type)));\n \n     case ARRAY_TYPE:\n-      /* We're already checked the component type (TREE_TYPE), so just check\n-\t the index type.  */\n+      /* We have already checked the component type above, so just check the\n+\t domain type.  */\n       return type_contains_placeholder_p (TYPE_DOMAIN (type));\n \n     case RECORD_TYPE:\n@@ -2947,6 +2948,8 @@ type_contains_placeholder_1 (const_tree type)\n     }\n }\n \n+/* Wrapper around above function used to cache its result.  */\n+\n bool\n type_contains_placeholder_p (tree type)\n {"}, {"sha": "c50870d1c67a3ff66c02cf99678dc9eaf6496e61", "filename": "gcc/tree.h", "status": "modified", "additions": 5, "deletions": 8, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/98cd3025d4d3204a18f327627a61b6773fd377a5/gcc%2Ftree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/98cd3025d4d3204a18f327627a61b6773fd377a5/gcc%2Ftree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.h?ref=98cd3025d4d3204a18f327627a61b6773fd377a5", "patch": "@@ -4588,11 +4588,8 @@ extern tree skip_simple_arithmetic (tree);\n \n enum tree_node_structure_enum tree_node_structure (const_tree);\n \n-/* Return 1 if EXP contains a PLACEHOLDER_EXPR; i.e., if it represents a size\n-   or offset that depends on a field within a record.\n-\n-   Note that we only allow such expressions within simple arithmetic\n-   or a COND_EXPR.  */\n+/* Return true if EXP contains a PLACEHOLDER_EXPR, i.e. if it represents a\n+   size or offset that depends on a field within a record.  */\n \n extern bool contains_placeholder_p (const_tree);\n \n@@ -4602,9 +4599,9 @@ extern bool contains_placeholder_p (const_tree);\n #define CONTAINS_PLACEHOLDER_P(EXP) \\\n   ((EXP) != 0 && ! TREE_CONSTANT (EXP) && contains_placeholder_p (EXP))\n \n-/* Return 1 if any part of the computation of TYPE involves a PLACEHOLDER_EXPR.\n-   This includes size, bounds, qualifiers (for QUAL_UNION_TYPE) and field\n-   positions.  */\n+/* Return true if any part of the structure of TYPE involves a PLACEHOLDER_EXPR\n+   directly.  This includes size, bounds, qualifiers (for QUAL_UNION_TYPE) and\n+   field positions.  */\n \n extern bool type_contains_placeholder_p (tree);\n "}]}