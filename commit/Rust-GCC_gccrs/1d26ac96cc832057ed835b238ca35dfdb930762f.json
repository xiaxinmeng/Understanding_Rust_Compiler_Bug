{"sha": "1d26ac96cc832057ed835b238ca35dfdb930762f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MWQyNmFjOTZjYzgzMjA1N2VkODM1YjIzOGNhMzVkZmRiOTMwNzYyZg==", "commit": {"author": {"name": "Marek Michalkiewicz", "email": "marekm@linux.org.pl", "date": "2001-01-20T16:49:01Z"}, "committer": {"name": "Marek Michalkiewicz", "email": "marekm@gcc.gnu.org", "date": "2001-01-20T16:49:01Z"}, "message": "avr.h (INIT_TARGET_OPTABS): Remove most of it, was the same as the default library function names.\n\n\t* config/avr/avr.h (INIT_TARGET_OPTABS): Remove most of it, was\n\tthe same as the default library function names.\n\t* config/avr/avr.md: Document special characters after '%'.\n\t(mulqi3, mulhi3, mulsi3): Call libgcc.S functions ourselves,\n\tknowing which of the call-used registers are really clobbered.\n\t(divmodqi4, udivmodqi4, divmodhi4, udivmodhi4, divmodsi4, udivmodsi4):\n\tNew.  Both quotient and remainder from one libgcc.S call.\n\t* config/avr/libgcc.S: Optimize mul/divmod for the new insns above,\n\tclobber as few registers as possible.\n\t* config/avr/t-avr (LIB1ASMFUNCS): Adjust for the above changes.\n\nFrom-SVN: r39155", "tree": {"sha": "75f03b137a710860f037be265d3c44482bd2144e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/75f03b137a710860f037be265d3c44482bd2144e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/1d26ac96cc832057ed835b238ca35dfdb930762f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1d26ac96cc832057ed835b238ca35dfdb930762f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1d26ac96cc832057ed835b238ca35dfdb930762f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1d26ac96cc832057ed835b238ca35dfdb930762f/comments", "author": null, "committer": null, "parents": [{"sha": "b845f897479c5989a2a3855bb89767706dd8f8aa", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b845f897479c5989a2a3855bb89767706dd8f8aa", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b845f897479c5989a2a3855bb89767706dd8f8aa"}], "stats": {"total": 844, "additions": 507, "deletions": 337}, "files": [{"sha": "cded5b23d6aec8e41746c20ab1236dc0846977a7", "filename": "gcc/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1d26ac96cc832057ed835b238ca35dfdb930762f/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1d26ac96cc832057ed835b238ca35dfdb930762f/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=1d26ac96cc832057ed835b238ca35dfdb930762f", "patch": "@@ -1,3 +1,16 @@\n+2001-01-20  Marek Michalkiewicz  <marekm@linux.org.pl>\n+\n+\t* config/avr/avr.h (INIT_TARGET_OPTABS): Remove most of it, was\n+\tthe same as the default library function names.\n+\t* config/avr/avr.md: Document special characters after '%'.\n+\t(mulqi3, mulhi3, mulsi3): Call libgcc.S functions ourselves,\n+\tknowing which of the call-used registers are really clobbered.\n+\t(divmodqi4, udivmodqi4, divmodhi4, udivmodhi4, divmodsi4, udivmodsi4):\n+\tNew.  Both quotient and remainder from one libgcc.S call.\n+\t* config/avr/libgcc.S: Optimize mul/divmod for the new insns above,\n+\tclobber as few registers as possible.\n+\t* config/avr/t-avr (LIB1ASMFUNCS): Adjust for the above changes.\n+\n 2001-01-20  Neil Booth  <neil@daikokuya.demon.co.uk>\n \n         * cppmacro.c (funlike_invocation_p): Don't move back up to the"}, {"sha": "773f8b3071f20d932588c9399125ed0277b24308", "filename": "gcc/config/avr/avr.h", "status": "modified", "additions": 0, "deletions": 44, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1d26ac96cc832057ed835b238ca35dfdb930762f/gcc%2Fconfig%2Favr%2Favr.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1d26ac96cc832057ed835b238ca35dfdb930762f/gcc%2Fconfig%2Favr%2Favr.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Favr%2Favr.h?ref=1d26ac96cc832057ed835b238ca35dfdb930762f", "patch": "@@ -3228,50 +3228,6 @@ valid_machine_decl_attribute (DECL, ATTRIBUTES, IDENTIFIER, ARGS)\n \n #define INIT_TARGET_OPTABS\t\t\t\t\\\n {\t\t\t\t\t\t\t\\\n-  smul_optab->handlers[(int) QImode].libfunc\t\t\\\n-    = gen_rtx (SYMBOL_REF, Pmode, \"__mulqi3\");\t\t\\\n-\t\t\t\t\t\t\t\\\n-  sdiv_optab->handlers[(int) QImode].libfunc\t\t\\\n-    = gen_rtx (SYMBOL_REF, Pmode, \"__divqi3\");\t\t\\\n-\t\t\t\t\t\t\t\\\n-  smod_optab->handlers[(int) QImode].libfunc\t\t\\\n-    = gen_rtx (SYMBOL_REF, Pmode, \"__modqi3\");\t\t\\\n-\t\t\t\t\t\t\t\\\n-  udiv_optab->handlers[(int) QImode].libfunc\t\t\\\n-    = gen_rtx (SYMBOL_REF, Pmode, \"__udivqi3\");\t\t\\\n-\t\t\t\t\t\t\t\\\n-  umod_optab->handlers[(int) QImode].libfunc\t\t\\\n-    = gen_rtx (SYMBOL_REF, Pmode, \"__umodqi3\");\t\t\\\n-\t\t\t\t\t\t\t\\\n-  smul_optab->handlers[(int) HImode].libfunc\t\t\\\n-    = gen_rtx (SYMBOL_REF, Pmode, \"__mulhi3\");\t\t\\\n-\t\t\t\t\t\t\t\\\n-  sdiv_optab->handlers[(int) HImode].libfunc\t\t\\\n-    = gen_rtx (SYMBOL_REF, Pmode, \"__divhi3\");\t\t\\\n-\t\t\t\t\t\t\t\\\n-  smod_optab->handlers[(int) HImode].libfunc\t\t\\\n-    = gen_rtx (SYMBOL_REF, Pmode, \"__modhi3\");\t\t\\\n-\t\t\t\t\t\t\t\\\n-  udiv_optab->handlers[(int) HImode].libfunc\t\t\\\n-    = gen_rtx (SYMBOL_REF, Pmode, \"__udivhi3\");\t\t\\\n-\t\t\t\t\t\t\t\\\n-  umod_optab->handlers[(int) HImode].libfunc\t\t\\\n-    = gen_rtx (SYMBOL_REF, Pmode, \"__umodhi3\");\t\t\\\n-\t\t\t\t\t\t\t\\\n-  smul_optab->handlers[(int) SImode].libfunc\t\t\\\n-    = gen_rtx (SYMBOL_REF, Pmode, \"__mulsi3\");\t\t\\\n-\t\t\t\t\t\t\t\\\n-  sdiv_optab->handlers[(int) SImode].libfunc\t\t\\\n-    = gen_rtx (SYMBOL_REF, Pmode, \"__divsi3\");\t\t\\\n-\t\t\t\t\t\t\t\\\n-  smod_optab->handlers[(int) SImode].libfunc\t\t\\\n-    = gen_rtx (SYMBOL_REF, Pmode, \"__modsi3\");\t\t\\\n-\t\t\t\t\t\t\t\\\n-  udiv_optab->handlers[(int) SImode].libfunc\t\t\\\n-    = gen_rtx (SYMBOL_REF, Pmode, \"__udivsi3\");\t\t\\\n-\t\t\t\t\t\t\t\\\n-  umod_optab->handlers[(int) SImode].libfunc\t\t\\\n-    = gen_rtx (SYMBOL_REF, Pmode, \"__umodsi3\");\t\t\\\n   avr_init_once ();\t\t\t\t\t\\\n }\n "}, {"sha": "663585669cfadae22bc46ccdf13c0eca8989683b", "filename": "gcc/config/avr/avr.md", "status": "modified", "additions": 254, "deletions": 8, "changes": 262, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1d26ac96cc832057ed835b238ca35dfdb930762f/gcc%2Fconfig%2Favr%2Favr.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1d26ac96cc832057ed835b238ca35dfdb930762f/gcc%2Fconfig%2Favr%2Favr.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Favr%2Favr.md?ref=1d26ac96cc832057ed835b238ca35dfdb930762f", "patch": "@@ -21,6 +21,16 @@\n ;; the Free Software Foundation, 59 Temple Place - Suite 330,\n ;; Boston, MA 02111-1307, USA.\n \n+;; Special characters after '%':\n+;;  A  No effect (add 0).\n+;;  B  Add 1 to REG number, MEM address or CONST_INT.\n+;;  C  Add 2.\n+;;  D  Add 3.\n+;;  j  Branch condition.\n+;;  k  Reverse branch condition.\n+;;  o  Displacement for (mem (plus (reg) (const_int))) operands.\n+;;  ~  Output 'r' if not AVR_MEGA.\n+\n ;; UNSPEC usage:\n ;;  0  Length of a string, see \"strlenhi\".\n ;;  1  Read from a word address in program memory, see \"casesi\".\n@@ -634,7 +644,20 @@\n ;******************************************************************************\n ; mul\n \n-(define_insn \"mulqi3\"\n+(define_expand \"mulqi3\"\n+  [(set (match_operand:QI 0 \"register_operand\" \"\")\n+\t(mult:QI (match_operand:QI 1 \"register_operand\" \"\")\n+\t\t (match_operand:QI 2 \"register_operand\" \"\")))]\n+  \"\"\n+  \"{\n+  if (!AVR_ENHANCED)\n+    {\n+      emit_insn (gen_mulqi3_call (operands[0], operands[1], operands[2]));\n+      DONE;\n+    }\n+}\")\n+\n+(define_insn \"*mulqi3_enh\"\n   [(set (match_operand:QI 0 \"register_operand\" \"=r\")\n \t(mult:QI (match_operand:QI 1 \"register_operand\" \"r\")\n \t\t (match_operand:QI 2 \"register_operand\" \"r\")))]\n@@ -645,6 +668,25 @@\n   [(set_attr \"length\" \"3\")\n    (set_attr \"cc\" \"clobber\")])\n \n+(define_expand \"mulqi3_call\"\n+  [(set (reg:QI 24) (match_operand:QI 1 \"register_operand\" \"\"))\n+   (set (reg:QI 22) (match_operand:QI 2 \"register_operand\" \"\"))\n+   (parallel [(set (reg:QI 24) (mult:QI (reg:QI 24) (reg:QI 22)))\n+\t      (clobber (reg:QI 22))])\n+   (set (match_operand:QI 0 \"register_operand\" \"\") (reg:QI 24))]\n+  \"\"\n+  \"\")\n+\n+(define_insn \"*mulqi3_call\"\n+  [(set (reg:QI 24) (mult:QI (reg:QI 24) (reg:QI 22)))\n+   (clobber (reg:QI 22))]\n+  \"!AVR_ENHANCED\"\n+  \"%~call __mulqi3\"\n+  [(set (attr \"length\") (if_then_else (eq_attr \"mcu_mega\" \"no\")\n+\t\t\t\t      (const_int 1)\n+\t\t\t\t      (const_int 2)))\n+   (set_attr \"cc\" \"clobber\")])\n+\n (define_insn \"mulqihi3\"\n   [(set (match_operand:HI 0 \"register_operand\" \"=r\")\n \t(mult:HI (sign_extend:HI (match_operand:QI 1 \"register_operand\" \"d\"))\n@@ -667,7 +709,21 @@\n   [(set_attr \"length\" \"3\")\n    (set_attr \"cc\" \"clobber\")])\n \n-(define_insn \"mulhi3\"\n+(define_expand \"mulhi3\"\n+  [(set (match_operand:HI 0 \"register_operand\" \"\")\n+\t(mult:HI (match_operand:HI 1 \"register_operand\" \"\")\n+\t\t (match_operand:HI 2 \"register_operand\" \"\")))]\n+  \"\"\n+  \"\n+{\n+  if (!AVR_ENHANCED)\n+    {\n+      emit_insn (gen_mulhi3_call (operands[0], operands[1], operands[2]));\n+      DONE;\n+    }\n+}\")\n+\n+(define_insn \"*mulhi3_enh\"\n   [(set (match_operand:HI 0 \"register_operand\" \"=&r\")\n \t(mult:HI (match_operand:HI 1 \"register_operand\" \"r\")\n \t\t (match_operand:HI 2 \"register_operand\" \"r\")))]\n@@ -682,6 +738,200 @@\n   [(set_attr \"length\" \"7\")\n    (set_attr \"cc\" \"clobber\")])\n \n+(define_expand \"mulhi3_call\"\n+  [(set (reg:HI 24) (match_operand:HI 1 \"register_operand\" \"\"))\n+   (set (reg:HI 22) (match_operand:HI 2 \"register_operand\" \"\"))\n+   (parallel [(set (reg:HI 24) (mult:HI (reg:HI 24) (reg:HI 22)))\n+\t      (clobber (reg:HI 22))\n+\t      (clobber (reg:QI 21))])\n+   (set (match_operand:HI 0 \"register_operand\" \"\") (reg:HI 24))]\n+  \"\"\n+  \"\")\n+\n+(define_insn \"*mulhi3_call\"\n+  [(set (reg:HI 24) (mult:HI (reg:HI 24) (reg:HI 22)))\n+   (clobber (reg:HI 22))\n+   (clobber (reg:QI 21))]\n+  \"!AVR_ENHANCED\"\n+  \"%~call __mulhi3\"\n+  [(set (attr \"length\") (if_then_else (eq_attr \"mcu_mega\" \"no\")\n+\t\t\t\t      (const_int 1)\n+\t\t\t\t      (const_int 2)))\n+   (set_attr \"cc\" \"clobber\")])\n+\n+;; Operand 2 (reg:SI 18) not clobbered on the enhanced core.\n+;; All call-used registers clobbered otherwise - normal library call.\n+(define_expand \"mulsi3\"\n+  [(set (reg:SI 22) (match_operand:SI 1 \"register_operand\" \"\"))\n+   (set (reg:SI 18) (match_operand:SI 2 \"register_operand\" \"\"))\n+   (parallel [(set (reg:SI 22) (mult:SI (reg:SI 22) (reg:SI 18)))\n+\t      (clobber (reg:HI 26))\n+\t      (clobber (reg:HI 30))])\n+   (set (match_operand:SI 0 \"register_operand\" \"\") (reg:SI 22))]\n+  \"AVR_ENHANCED\"\n+  \"\")\n+\n+(define_insn \"*mulsi3_call\"\n+  [(set (reg:SI 22) (mult:SI (reg:SI 22) (reg:SI 18)))\n+   (clobber (reg:HI 26))\n+   (clobber (reg:HI 30))]\n+  \"AVR_ENHANCED\"\n+  \"%~call __mulsi3\"\n+  [(set (attr \"length\") (if_then_else (eq_attr \"mcu_mega\" \"no\")\n+\t\t\t\t      (const_int 1)\n+\t\t\t\t      (const_int 2)))\n+   (set_attr \"cc\" \"clobber\")])\n+\n+; / % / % / % / % / % / % / % / % / % / % / % / % / % / % / % / % / % / % / %\n+; divmod\n+\n+;; Generate libgcc.S calls ourselves, because:\n+;;  - we know exactly which registers are clobbered (for QI and HI\n+;;    modes, some of the call-used registers are preserved)\n+;;  - we get both the quotient and the remainder at no extra cost\n+\n+(define_expand \"divmodqi4\"\n+  [(set (reg:QI 24) (match_operand:QI 1 \"register_operand\" \"\"))\n+   (set (reg:QI 22) (match_operand:QI 2 \"register_operand\" \"\"))\n+   (parallel [(set (reg:QI 24) (div:QI (reg:QI 24) (reg:QI 22)))\n+\t      (set (reg:QI 25) (mod:QI (reg:QI 24) (reg:QI 22)))\n+\t      (clobber (reg:QI 22))\n+\t      (clobber (reg:QI 23))])\n+   (set (match_operand:QI 0 \"register_operand\" \"\") (reg:QI 24))\n+   (set (match_operand:QI 3 \"register_operand\" \"\") (reg:QI 25))]\n+  \"\"\n+  \"\")\n+\n+(define_insn \"*divmodqi4_call\"\n+  [(set (reg:QI 24) (div:QI (reg:QI 24) (reg:QI 22)))\n+   (set (reg:QI 25) (mod:QI (reg:QI 24) (reg:QI 22)))\n+   (clobber (reg:QI 22))\n+   (clobber (reg:QI 23))]\n+  \"\"\n+  \"%~call __divmodqi4\"\n+  [(set (attr \"length\") (if_then_else (eq_attr \"mcu_mega\" \"no\")\n+\t\t\t\t      (const_int 1)\n+\t\t\t\t      (const_int 2)))\n+   (set_attr \"cc\" \"clobber\")])\n+\n+(define_expand \"udivmodqi4\"\n+  [(set (reg:QI 24) (match_operand:QI 1 \"register_operand\" \"\"))\n+   (set (reg:QI 22) (match_operand:QI 2 \"register_operand\" \"\"))\n+   (parallel [(set (reg:QI 24) (udiv:QI (reg:QI 24) (reg:QI 22)))\n+\t      (set (reg:QI 25) (umod:QI (reg:QI 24) (reg:QI 22)))\n+\t      (clobber (reg:QI 23))])\n+   (set (match_operand:QI 0 \"register_operand\" \"\") (reg:QI 24))\n+   (set (match_operand:QI 3 \"register_operand\" \"\") (reg:QI 25))]\n+  \"\"\n+  \"\")\n+\n+(define_insn \"*udivmodqi4_call\"\n+  [(set (reg:QI 24) (udiv:QI (reg:QI 24) (reg:QI 22)))\n+   (set (reg:QI 25) (umod:QI (reg:QI 24) (reg:QI 22)))\n+   (clobber (reg:QI 23))]\n+  \"\"\n+  \"%~call __udivmodqi4\"\n+  [(set (attr \"length\") (if_then_else (eq_attr \"mcu_mega\" \"no\")\n+\t\t\t\t      (const_int 1)\n+\t\t\t\t      (const_int 2)))\n+   (set_attr \"cc\" \"clobber\")])\n+\n+(define_expand \"divmodhi4\"\n+  [(set (reg:HI 24) (match_operand:HI 1 \"register_operand\" \"\"))\n+   (set (reg:HI 22) (match_operand:HI 2 \"register_operand\" \"\"))\n+   (parallel [(set (reg:HI 22) (div:HI (reg:HI 24) (reg:HI 22)))\n+\t      (set (reg:HI 24) (mod:HI (reg:HI 24) (reg:HI 22)))\n+\t      (clobber (reg:HI 26))\n+\t      (clobber (reg:QI 21))])\n+   (set (match_operand:HI 0 \"register_operand\" \"\") (reg:HI 22))\n+   (set (match_operand:HI 3 \"register_operand\" \"\") (reg:HI 24))]\n+  \"\"\n+  \"\")\n+\n+(define_insn \"*divmodhi4_call\"\n+  [(set (reg:HI 22) (div:HI (reg:HI 24) (reg:HI 22)))\n+   (set (reg:HI 24) (mod:HI (reg:HI 24) (reg:HI 22)))\n+   (clobber (reg:HI 26))\n+   (clobber (reg:QI 21))]\n+  \"\"\n+  \"%~call __divmodhi4\"\n+  [(set (attr \"length\") (if_then_else (eq_attr \"mcu_mega\" \"no\")\n+\t\t\t\t      (const_int 1)\n+\t\t\t\t      (const_int 2)))\n+   (set_attr \"cc\" \"clobber\")])\n+\n+(define_expand \"udivmodhi4\"\n+  [(set (reg:HI 24) (match_operand:HI 1 \"register_operand\" \"\"))\n+   (set (reg:HI 22) (match_operand:HI 2 \"register_operand\" \"\"))\n+   (parallel [(set (reg:HI 22) (udiv:HI (reg:HI 24) (reg:HI 22)))\n+\t      (set (reg:HI 24) (umod:HI (reg:HI 24) (reg:HI 22)))\n+\t      (clobber (reg:HI 26))\n+\t      (clobber (reg:QI 21))])\n+   (set (match_operand:HI 0 \"register_operand\" \"\") (reg:HI 22))\n+   (set (match_operand:HI 3 \"register_operand\" \"\") (reg:HI 24))]\n+  \"\"\n+  \"\")\n+\n+(define_insn \"*udivmodhi4_call\"\n+  [(set (reg:HI 22) (udiv:HI (reg:HI 24) (reg:HI 22)))\n+   (set (reg:HI 24) (umod:HI (reg:HI 24) (reg:HI 22)))\n+   (clobber (reg:HI 26))\n+   (clobber (reg:QI 21))]\n+  \"\"\n+  \"%~call __udivmodhi4\"\n+  [(set (attr \"length\") (if_then_else (eq_attr \"mcu_mega\" \"no\")\n+\t\t\t\t      (const_int 1)\n+\t\t\t\t      (const_int 2)))\n+   (set_attr \"cc\" \"clobber\")])\n+\n+(define_expand \"divmodsi4\"\n+  [(set (reg:SI 22) (match_operand:SI 1 \"register_operand\" \"\"))\n+   (set (reg:SI 18) (match_operand:SI 2 \"register_operand\" \"\"))\n+   (parallel [(set (reg:SI 18) (div:SI (reg:SI 22) (reg:SI 18)))\n+\t      (set (reg:SI 22) (mod:SI (reg:SI 22) (reg:SI 18)))\n+\t      (clobber (reg:HI 26))\n+\t      (clobber (reg:HI 30))])\n+   (set (match_operand:SI 0 \"register_operand\" \"\") (reg:SI 18))\n+   (set (match_operand:SI 3 \"register_operand\" \"\") (reg:SI 22))]\n+  \"\"\n+  \"\")\n+\n+(define_insn \"*divmodsi4_call\"\n+  [(set (reg:SI 18) (div:SI (reg:SI 22) (reg:SI 18)))\n+   (set (reg:SI 22) (mod:SI (reg:SI 22) (reg:SI 18)))\n+   (clobber (reg:HI 26))\n+   (clobber (reg:HI 30))]\n+  \"\"\n+  \"%~call __divmodsi4\"\n+  [(set (attr \"length\") (if_then_else (eq_attr \"mcu_mega\" \"no\")\n+\t\t\t\t      (const_int 1)\n+\t\t\t\t      (const_int 2)))\n+   (set_attr \"cc\" \"clobber\")])\n+\n+(define_expand \"udivmodsi4\"\n+  [(set (reg:SI 22) (match_operand:SI 1 \"register_operand\" \"\"))\n+   (set (reg:SI 18) (match_operand:SI 2 \"register_operand\" \"\"))\n+   (parallel [(set (reg:SI 18) (udiv:SI (reg:SI 22) (reg:SI 18)))\n+\t      (set (reg:SI 22) (umod:SI (reg:SI 22) (reg:SI 18)))\n+\t      (clobber (reg:HI 26))\n+\t      (clobber (reg:HI 30))])\n+   (set (match_operand:SI 0 \"register_operand\" \"\") (reg:SI 18))\n+   (set (match_operand:SI 3 \"register_operand\" \"\") (reg:SI 22))]\n+  \"\"\n+  \"\")\n+\n+(define_insn \"*udivmodsi4_call\"\n+  [(set (reg:SI 18) (udiv:SI (reg:SI 22) (reg:SI 18)))\n+   (set (reg:SI 22) (umod:SI (reg:SI 22) (reg:SI 18)))\n+   (clobber (reg:HI 26))\n+   (clobber (reg:HI 30))]\n+  \"\"\n+  \"%~call __udivmodsi4\"\n+  [(set (attr \"length\") (if_then_else (eq_attr \"mcu_mega\" \"no\")\n+\t\t\t\t      (const_int 1)\n+\t\t\t\t      (const_int 2)))\n+   (set_attr \"cc\" \"clobber\")])\n+\n ;&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&\n ; and\n \n@@ -1794,9 +2044,7 @@\n \t\tAS2 (mov, r31, %B0) CR_TAB\n \t\t\\\"icall\\\");\n     }\n-  else if (!AVR_MEGA)\n-     return AS1(rcall,%c0);   \n-  return AS1(call,%c0);\n+  return AS1(%~call,%c0);\n }\"\n   [(set_attr \"cc\" \"clobber,clobber,clobber\")\n    (set_attr_alternative \"length\"\n@@ -1829,9 +2077,7 @@\n \t\tAS2 (mov, r31, %B1) CR_TAB\n \t\t\\\"icall\\\");\n     }\n-  else if (!AVR_MEGA)\n-     return AS1(rcall,%c1);   \n-  return AS1(call,%c1);\n+  return AS1(%~call,%c1);\n }\"\n   [(set_attr \"cc\" \"clobber,clobber,clobber\")\n    (set_attr_alternative \"length\""}, {"sha": "aa96a520239618564aad612a1b188264fd384667", "filename": "gcc/config/avr/libgcc.S", "status": "modified", "additions": 234, "deletions": 273, "changes": 507, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1d26ac96cc832057ed835b238ca35dfdb930762f/gcc%2Fconfig%2Favr%2Flibgcc.S", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1d26ac96cc832057ed835b238ca35dfdb930762f/gcc%2Fconfig%2Favr%2Flibgcc.S", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Favr%2Flibgcc.S?ref=1d26ac96cc832057ed835b238ca35dfdb930762f", "patch": "@@ -32,8 +32,29 @@ Boston, MA 02111-1307, USA.  */\n #define __SP_H__ 0x3e\n #define __SP_L__ 0x3d\n \n+/* Most of the functions here are called directly from avr.md\n+   patterns, instead of using the standard libcall mechanisms.\n+   This can make better code because GCC knows exactly which\n+   of the call-used registers (not all of them) are clobbered.  */\n+\n \t.section .text.libgcc, \"ax\", @progbits\n \n+\t.macro\tmov_l  r_dest, r_src\n+#if defined (__AVR_ENHANCED__)\n+\tmovw\t\\r_dest, \\r_src\n+#else\n+\tmov\t\\r_dest, \\r_src\n+#endif\n+\t.endm\n+\n+\t.macro\tmov_h  r_dest, r_src\n+#if defined (__AVR_ENHANCED__)\n+\t; empty\n+#else\n+\tmov\t\\r_dest, \\r_src\n+#endif\n+\t.endm\n+\n /* Note: mulqi3, mulhi3 are open-coded on the enhanced core.  */\n #if !defined (__AVR_ENHANCED__)\n /*******************************************************\n@@ -67,6 +88,29 @@ __mulqi3_exit:\n .endfunc\n #endif \t/* defined (L_mulqi3) */\n \n+#if defined (L_mulqihi3)\n+\t.global\t__mulqihi3\n+\t.func\t__mulqihi3\n+__mulqihi3:\n+\tclr\tr25\n+\tsbrc\tr24, 7\n+\tdec\tr25\n+\tclr\tr23\n+\tsbrc\tr22, 7\n+\tdec\tr22\n+\trjmp\t__mulhi3\n+\t.endfunc\n+#endif /* defined (L_mulqihi3) */\n+\n+#if defined (L_umulqihi3)\n+\t.global\t__umulqihi3\n+\t.func\t__umulqihi3\n+__umulqihi3:\n+\tclr\tr25\n+\tclr\tr23\n+\trjmp\t__mulhi3\n+\t.endfunc\n+#endif /* defined (L_umulqihi3) */\n \n /*******************************************************\n                Multiplication  16 x 16\n@@ -76,7 +120,7 @@ __mulqi3_exit:\n #define\tr_arg1H\tr25\t\t/* multiplier High */\n #define\tr_arg2L\tr22\t\t/* multiplicand Low */\n #define\tr_arg2H\tr23\t\t/* multiplicand High */\n-#define r_resL\tr20\t\t/* result Low */\n+#define r_resL\t__tmp_reg__\t/* result Low */\n #define r_resH  r21\t\t/* result High */\n \n \t.global\t__mulhi3\n@@ -116,6 +160,38 @@ __mulhi3_exit:\n #endif /* defined (L_mulhi3) */\n #endif /* !defined (__AVR_ENHANCED__) */\n \n+#if defined (L_mulhisi3)\n+\t.global\t__mulhisi3\n+\t.func\t__mulhisi3\n+__mulhisi3:\n+\tmov_l\tr18, r24\n+\tmov_h\tr19, r25\n+\tclr\tr24\n+\tsbrc\tr23, 7\n+\tdec\tr24\n+\tmov\tr25, r24\n+\tclr\tr20\n+\tsbrc\tr19, 7\n+\tdec\tr20\n+\tmov\tr21, r20\n+\trjmp\t__mulsi3\n+\t.endfunc\n+#endif /* defined (L_mulhisi3) */\n+\n+#if defined (L_umulhisi3)\n+\t.global\t__umulhisi3\n+\t.func\t__umulhisi3\n+__umulhisi3:\n+\tmov_l\tr18, r24\n+\tmov_h\tr19, r25\n+\tclr\tr24\n+\tclr\tr25\n+\tclr\tr20\n+\tclr\tr21\n+\trjmp\t__mulsi3\n+\t.endfunc\n+#endif /* defined (L_umulhisi3) */\n+\n #if defined (L_mulsi3)\n /*******************************************************\n                Multiplication  32 x 32\n@@ -227,81 +303,54 @@ __mulsi3_exit:\n /*******************************************************\n        Division 8 / 8 => (result + remainder)\n *******************************************************/\n-#define\tr_rem\tr26\t/* remainder */\n-#define\tr_arg1\tr24\t/* dividend */\n+#define\tr_rem\tr25\t/* remainder */\n+#define\tr_arg1\tr24\t/* dividend, quotient */\n #define\tr_arg2\tr22\t/* divisor */\n-#define\tr_cnt\tr27\t/* loop count */\n-\n-#if defined (L_umodqi3)\n-\n-\t.global\t__umodqi3\n-\t.func\t__umodqi3\n-__umodqi3:\n-\tclt\n-\trcall\t__udivqi3\n-\tmov\tr24,r_rem\n-\tret\n-.endfunc\n-#endif /* defined (L_umodqi3) */\n-\t\n-#if defined (L_udivqi3)\n-\n-\t.global\t__udivqi3\n-\t.func\t__udivqi3\n-__udivqi3:\n-\tclr\t__tmp_reg__\n-\trjmp\t__divqi_raw\n-.endfunc\n-#endif /* defined (L_udivqi3) */\n+#define\tr_cnt\tr23\t/* loop count */\n \n-#if defined (L_modqi3)\n-\t\n-\t.global\t__modqi3\n-\t.func\t__modqi3\n-__modqi3:\n-\trcall\t__divqi3\n-\tmov\tr24,r_rem\n+#if defined (L_udivmodqi4)\n+\t.global\t__udivmodqi4\n+\t.func\t__udivmodqi4\n+__udivmodqi4:\n+\tsub\tr_rem,r_rem\t; clear remainder and carry\n+\tldi\tr_cnt,9\t\t; init loop counter\n+\trjmp\t__udivmodqi4_ep\t; jump to entry point\n+__udivmodqi4_loop:\n+\trol\tr_rem\t\t; shift dividend into remainder\n+\tcp\tr_rem,r_arg2\t; compare remainder & divisor\n+\tbrcs\t__udivmodqi4_ep\t; remainder <= divisor\n+\tsub\tr_rem,r_arg2\t; restore remainder\n+__udivmodqi4_ep:\n+\trol\tr_arg1\t\t; shift dividend (with CARRY)\n+\tdec\tr_cnt\t\t; decrement loop counter\n+\tbrne\t__udivmodqi4_loop\n+\tcom\tr_arg1\t\t; complement result \n+\t\t\t\t; because C flag was complemented in loop\n \tret\n-.endfunc\n-#endif /* defined (L_modqi3) */\n-\n-#if defined (L_divqi3)\n-\n-\t.global\t__divqi3\n-\t.func\t__divqi3\n-__divqi3:\n-        bst     r_arg1,7\t; store sign of divident\n+\t.endfunc\n+#endif /* defined (L_udivmodqi4) */\n+\n+#if defined (L_divmodqi4)\n+\t.global\t__divmodqi4\n+\t.func\t__divmodqi4\n+__divmodqi4:\n+        bst     r_arg1,7\t; store sign of dividend\n         mov     __tmp_reg__,r_arg1\n         eor     __tmp_reg__,r_arg2; r0.7 is sign of result\n         sbrc\tr_arg1,7\n-        neg     r_arg1\t\t; divident negative : negate\n+\tneg     r_arg1\t\t; dividend negative : negate\n         sbrc\tr_arg2,7\n-        neg     r_arg2\t\t; divisor negative : negate\n-\t.global\t__divqi_raw\n-__divqi_raw:\t\n-\tsub\tr_rem,r_rem\t; clear remainder and carry\n-\tldi\tr_cnt,9\t\t; init loop counter\n-\trjmp\t__divqi3_ep\t; jump to entry point\n-__divqi3_loop:\n-        rol\tr_rem\t\t; shift dividend into remainder\n-        cp\tr_rem,r_arg2\t; compare remainder & divisor\n-        brcs\t__divqi3_ep\t; remainder <= divisor\n-        sub\tr_rem,r_arg2\t; restore remainder\n-__divqi3_ep:\n-        rol\tr_arg1\t\t; shift dividend (with CARRY)\n-        dec\tr_cnt\t\t; decrement loop counter\n-        brne\t__divqi3_loop\t; loop\n-\tcom\tr_arg1\t\t; complement result \n-\t\t\t\t; because C flag was complemented in loop\n-\tbrtc\t__divqi3_1\n+\tneg     r_arg2\t\t; divisor negative : negate\n+\trcall\t__udivmodqi4\t; do the unsigned div/mod\n+\tbrtc\t__divmodqi4_1\n \tneg\tr_rem\t\t; correct remainder sign\n-__divqi3_1:\n+__divmodqi4_1:\n \tsbrc\t__tmp_reg__,7\n \tneg\tr_arg1\t\t; correct result sign\n-__divqi3_exit:\n-\tret\t\t\t; result already in r24 (r_arg1)\n-.endfunc\n-#endif /* defined (L_divqi3) */\n+__divmodqi4_exit:\n+\tret\n+\t.endfunc\n+#endif /* defined (L_divmodqi4) */\n \n #undef r_rem\n #undef r_arg1\n@@ -314,113 +363,80 @@ __divqi3_exit:\n *******************************************************/\n #define\tr_remL\tr26\t/* remainder Low */\n #define\tr_remH\tr27\t/* remainder High */\n-\t\n+\n+/* return: remainder */\n #define\tr_arg1L\tr24\t/* dividend Low */\n #define\tr_arg1H\tr25\t/* dividend High */\n-\t\n+\n+/* return: quotient */\n #define\tr_arg2L\tr22\t/* divisor Low */\n #define\tr_arg2H\tr23\t/* divisor High */\n \t\n #define\tr_cnt\tr21\t/* loop count */\n-#if defined (L_umodhi3)\n-\t.global\t__umodhi3\n-\t.func\t__umodhi3\n-__umodhi3:\n-\tclt\n-\trcall\t__udivhi3\n-\t.global\t__umodhi3_ret\n-__umodhi3_ret:\n-#if defined (__AVR_ENHANCED__)\n-\tmovw\tr24, r_remL\n-#else\n-\tmov\tr24,r_remL\n-\tmov\tr25,r_remH\n-#endif\n-\tret\n-.endfunc\n-#endif /* defined (L_umodhi3) */\n-\t\n-#if defined (L_udivhi3)\n-\t\n-\t.global\t__udivhi3\n-\t.func\t__udivhi3\n-__udivhi3:\n-\tclr\t__tmp_reg__\n-\trjmp\t__divhi_raw\n-.endfunc\n-#endif /* defined (L_udivhi3) */\n \n-#if defined (L_modhi3)\n-\t.global\t__modhi3\n-\t.func\t__modhi3\n-__modhi3:\n-\t.global\t_div\n-_div:\n-\trcall\t__divhi3\n-#if defined (__AVR_ENHANCED__)\n-\tmovw\tr22, r24\n-#else\n-\tmov\tr22,r24\t\t; needed for div () function\n-\tmov\tr23,r25\n-#endif\n-\trjmp\t__umodhi3_ret\n-.endfunc\n-#endif /* defined (L_modhi3) */\n-\t\n-\t\n-#if defined (L_divhi3)\n-\t.global\t__divhi3\n-\t.func\t__divhi3\n-__divhi3:\n-        bst     r_arg1H,7\t; store sign of divident\n-        mov     __tmp_reg__,r_arg1H\n-        eor     __tmp_reg__,r_arg2H   ; r0.7 is sign of result\n-\tbrtc\t__divhi3_skip1\n-\tcom\tr_arg1H\n-        neg     r_arg1L\t\t; divident negative : negate\n-\tsbci\tr_arg1H,0xff\n-__divhi3_skip1:\n-        tst\tr_arg2H\n-\tbrpl\t__divhi3_skip2\n-\tcom\tr_arg2H\n-        neg     r_arg2L\t\t; divisor negative : negate\n-\tsbci\tr_arg2H,0xff\n-__divhi3_skip2:\n-\t.global\t__divhi_raw\n-__divhi_raw:\n+#if defined (L_udivmodhi4)\n+\t.global\t__udivmodhi4\n+\t.func\t__udivmodhi4\n+__udivmodhi4:\n \tsub\tr_remL,r_remL\n-\tsub\tr_remH,r_remH\t\t; clear remainder and carry\n+\tsub\tr_remH,r_remH\t; clear remainder and carry\n \tldi\tr_cnt,17\t; init loop counter\n-\trjmp\t__divhi3_ep\t; jump to entry point\n-__divhi3_loop:\n+\trjmp\t__udivmodhi4_ep\t; jump to entry point\n+__udivmodhi4_loop:\n         rol\tr_remL\t\t; shift dividend into remainder\n \trol\tr_remH\n         cp\tr_remL,r_arg2L\t; compare remainder & divisor\n \tcpc\tr_remH,r_arg2H\n-        brcs\t__divhi3_ep\t; remainder < divisor\n+        brcs\t__udivmodhi4_ep\t; remainder < divisor\n         sub\tr_remL,r_arg2L\t; restore remainder\n         sbc\tr_remH,r_arg2H\n-__divhi3_ep:\n+__udivmodhi4_ep:\n         rol\tr_arg1L\t\t; shift dividend (with CARRY)\n         rol\tr_arg1H\n         dec\tr_cnt\t\t; decrement loop counter\n-        brne\t__divhi3_loop\t; loop\n-\tbrtc\t__divhi3_1\n-\tcom\tr_remH\n-\tneg\tr_remL\t\t; correct remainder sign\n-\tsbci\tr_remH,0xff\n-__divhi3_1:\n+        brne\t__udivmodhi4_loop\n+\tcom\tr_arg1L\n+\tcom\tr_arg1H\n+; div/mod results to return registers, as for the div() function\n+\tmov_l\tr_arg2L, r_arg1L\t; quotient\n+\tmov_h\tr_arg2H, r_arg1H\n+\tmov_l\tr_arg1L, r_remL\t\t; remainder\n+\tmov_h\tr_arg1H, r_remH\n+\tret\n+\t.endfunc\n+#endif /* defined (L_udivmodhi4) */\n+\n+#if defined (L_divmodhi4)\n+\t.global\t__divmodhi4\n+\t.func\t__divmodhi4\n+__divmodhi4:\n+\t.global\t_div\n+_div:\n+        bst     r_arg1H,7\t; store sign of dividend\n+        mov     __tmp_reg__,r_arg1H\n+        eor     __tmp_reg__,r_arg2H   ; r0.7 is sign of result\n+\trcall\t__divmodhi4_neg1 ; dividend negative : negate\n+\tsbrc\tr_arg2H,7\n+\trcall\t__divmodhi4_neg2 ; divisor negative : negate\n+\trcall\t__udivmodhi4\t; do the unsigned div/mod\n+\trcall\t__divmodhi4_neg1 ; correct remainder sign\n \ttst\t__tmp_reg__\n-\tbrpl\t__divhi3_exit\n-\tadiw\tr_arg1L,1\t; correct result sign\n+\tbrpl\t__divmodhi4_exit\n+__divmodhi4_neg2:\n+\tcom\tr_arg2H\n+\tneg\tr_arg2L\t\t; correct divisor/result sign\n+\tsbci\tr_arg2H,0xff\n+__divmodhi4_exit:\n \tret\n-__divhi3_exit:\n-\tcom\tr_arg1L\n+__divmodhi4_neg1:\n+\tbrtc\t__divmodhi4_exit\n \tcom\tr_arg1H\n+\tneg\tr_arg1L\t\t; correct dividend/remainder sign\n+\tsbci\tr_arg1H,0xff\n \tret\n-.endfunc\n-#endif /* defined (L_divhi3) */\n-\t\n+\t.endfunc\n+#endif /* defined (L_divmodhi4) */\n+\n #undef r_remH  \n #undef r_remL  \n              \n@@ -439,113 +455,33 @@ __divhi3_exit:\n #define\tr_remHL\tr30\n #define\tr_remH\tr27\n #define\tr_remL\tr26\t/* remainder Low */\n-\t\n+\n+/* return: remainder */\n #define\tr_arg1HH r25\t/* dividend High */\n #define\tr_arg1HL r24\n #define\tr_arg1H  r23\n #define\tr_arg1L  r22\t/* dividend Low */\n-\t\n+\n+/* return: quotient */\n #define\tr_arg2HH r21\t/* divisor High */\n #define\tr_arg2HL r20\n #define\tr_arg2H  r19\n #define\tr_arg2L  r18\t/* divisor Low */\n \t\n #define\tr_cnt __zero_reg__  /* loop count (0 after the loop!) */\n \n-#if defined (L_umodsi3)\n-\n-\t.global\t__umodsi3\n-\t.func\t__umodsi3\n-__umodsi3:\n-\tclt\n-\trcall\t__udivsi3\n-\t.global\t__umodsi3_ret\n-__umodsi3_ret:\n-#if defined (__AVR_ENHANCED__)\n-\tmovw\tr24, r_remHL\n-\tmovw\tr22, r_remL\n-#else\n-\tmov\tr25,r_remHH\n-\tmov\tr24,r_remHL\n-\tmov\tr23,r_remH\n-\tmov\tr22,r_remL\n-#endif\n-\tret\n-.endfunc\n-#endif /* defined (L_umodsi3) */\n-\t\n-#if defined (L_udivsi3)\n-\n-\t.global\t__udivsi3\n-\t.func\t__udivsi3\n-__udivsi3:\n-\tclr\t__tmp_reg__\n-\trjmp\t__divsi_raw\n-.endfunc\n-#endif /* defined (L_udivsi3) */\n-\n-#if defined (L_modsi3)\n-\t\n-\t.global\t__modsi3\n-\t.func\t__modsi3\n-__modsi3:\n-\t.global\t_ldiv\n-_ldiv:\n-\trcall\t__divsi3\n-#if defined (__AVR_ENHANCED__)\n-\tmovw\tr18, r22\n-\tmovw\tr20, r24\n-#else\n-\tmov\tr18,r22\t\t/* Needed for ldiv */\n-\tmov\tr19,r23\n-\tmov\tr20,r24\n-\tmov\tr21,r25\n-#endif\n-\trjmp\t__umodsi3_ret\n-.endfunc\n-#endif /* defined (L_modsi3) */\n-\n-#if defined (L_divsi3)\n-\n-\t.global\t__divsi3\n-\t.func\t__divsi3\n-__divsi3:\n-        bst     r_arg1HH,7\t; store sign of divident\n-        mov     __tmp_reg__,r_arg1HH\n-        eor     __tmp_reg__,r_arg2HH   ; r0.7 is sign of result\n-\tbrtc\t__divsi3_skip1\n-\tcom\tr_arg1HH\n-\tcom\tr_arg1HL\n-\tcom\tr_arg1H\n-        neg     r_arg1L\t\t; divident negative : negate\n-\tsbci\tr_arg1H, 0xff\n-\tsbci\tr_arg1HL,0xff\n-\tsbci\tr_arg1HH,0xff\n-__divsi3_skip1:\n-        tst\tr_arg2HH\n-\tbrpl\t__divsi3_skip2\n-\tcom\tr_arg2HH\n-\tcom\tr_arg2HL\n-\tcom\tr_arg2H\n-        neg     r_arg2L\t\t; divisor negative : negate\n-\tsbci\tr_arg2H, 0xff\n-\tsbci\tr_arg2HL,0xff\n-\tsbci\tr_arg2HH,0xff\n-__divsi3_skip2:\n-\t.global\t__divsi_raw\n-__divsi_raw:\n+#if defined (L_udivmodsi4)\n+\t.global\t__udivmodsi4\n+\t.func\t__udivmodsi4\n+__udivmodsi4:\n \tldi\tr_remL, 33\t; init loop counter\n \tmov\tr_cnt, r_remL\n \tsub\tr_remL,r_remL\n-\tsub\tr_remH,r_remH\n-#if defined (__AVR_ENHANCED__)\n-\tmovw\tr_remHL, r_remL\n-#else\n-\tsub\tr_remHL,r_remHL\n-\tsub\tr_remHH,r_remHH\t; clear remainder and carry\n-#endif\n-\trjmp\t__divsi3_ep\t; jump to entry point\n-__divsi3_loop:\n+\tsub\tr_remH,r_remH\t; clear remainder and carry\n+\tmov_l\tr_remHL, r_remL\n+\tmov_h\tr_remHH, r_remH\n+\trjmp\t__udivmodsi4_ep\t; jump to entry point\n+__udivmodsi4_loop:\n         rol\tr_remL\t\t; shift dividend into remainder\n \trol\tr_remH\n \trol\tr_remHL\n@@ -554,43 +490,72 @@ __divsi3_loop:\n \tcpc\tr_remH,r_arg2H\n \tcpc\tr_remHL,r_arg2HL\n \tcpc\tr_remHH,r_arg2HH\n-        brcs\t__divsi3_ep\t; remainder <= divisor\n+\tbrcs\t__udivmodsi4_ep\t; remainder <= divisor\n         sub\tr_remL,r_arg2L\t; restore remainder\n         sbc\tr_remH,r_arg2H\n         sbc\tr_remHL,r_arg2HL\n         sbc\tr_remHH,r_arg2HH\n-__divsi3_ep:\n+__udivmodsi4_ep:\n         rol\tr_arg1L\t\t; shift dividend (with CARRY)\n         rol\tr_arg1H\n         rol\tr_arg1HL\n         rol\tr_arg1HH\n         dec\tr_cnt\t\t; decrement loop counter\n-        brne\t__divsi3_loop\t; loop\n+        brne\t__udivmodsi4_loop\n \t\t\t\t; __zero_reg__ now restored (r_cnt == 0)\n-\tbrtc\t__divsi3_1\n-\tcom\tr_remHH\n-\tcom\tr_remHL\n-\tcom\tr_remH\n-\tneg\tr_remL\t\t; correct remainder sign\n-\tsbci\tr_remH, 0xff\n-\tsbci\tr_remHL,0xff\n-\tsbci\tr_remHH,0xff\n-__divsi3_1:\n-\trol\t__tmp_reg__\n-\tbrcc\t__divsi3_exit\n-\tadc\tr_arg1L,__zero_reg__; correct result sign\n-\tadc\tr_arg1H,__zero_reg__\n-\tadc\tr_arg1HL,__zero_reg__\n-\tadc\tr_arg1HH,__zero_reg__\n-\tret\n-__divsi3_exit:\n \tcom\tr_arg1L\n \tcom\tr_arg1H\n \tcom\tr_arg1HL\n \tcom\tr_arg1HH\n+; div/mod results to return registers, as for the ldiv() function\n+\tmov_l\tr_arg2L,  r_arg1L\t; quotient\n+\tmov_h\tr_arg2H,  r_arg1H\n+\tmov_l\tr_arg2HL, r_arg1HL\n+\tmov_h\tr_arg2HH, r_arg1HH\n+\tmov_l\tr_arg1L,  r_remL\t; remainder\n+\tmov_h\tr_arg1H,  r_remH\n+\tmov_l\tr_arg1HL, r_remHL\n+\tmov_h\tr_arg1HH, r_remHH\n \tret\n-.endfunc\n-#endif /* defined (L_divsi3) */\n+\t.endfunc\n+#endif /* defined (L_udivmodsi4) */\n+\n+#if defined (L_divmodsi4)\n+\t.global\t__divmodsi4\n+\t.func\t__divmodsi4\n+__divmodsi4:\n+        bst     r_arg1HH,7\t; store sign of dividend\n+        mov     __tmp_reg__,r_arg1HH\n+        eor     __tmp_reg__,r_arg2HH   ; r0.7 is sign of result\n+\trcall\t__divmodsi4_neg1 ; dividend negative : negate\n+\tsbrc\tr_arg2HH,7\n+\trcall\t__divmodsi4_neg2 ; divisor negative : negate\n+\trcall\t__udivmodsi4\t; do the unsigned div/mod\n+\trcall\t__divmodsi4_neg1 ; correct remainder sign\n+\trol\t__tmp_reg__\n+\tbrcc\t__divmodsi4_exit\n+__divmodsi4_neg2:\n+\tcom\tr_arg2HH\n+\tcom\tr_arg2HL\n+\tcom\tr_arg2H\n+\tneg\tr_arg2L\t\t; correct divisor/quotient sign\n+\tsbci\tr_arg2H,0xff\n+\tsbci\tr_arg2HL,0xff\n+\tsbci\tr_arg2HH,0xff\n+__divmodsi4_exit:\n+\tret\n+__divmodsi4_neg1:\n+\tbrtc\t__divmodsi4_exit\n+\tcom\tr_arg1HH\n+\tcom\tr_arg1HL\n+\tcom\tr_arg1H\n+\tneg\tr_arg1L\t\t; correct dividend/remainder sign\n+\tsbci\tr_arg1H, 0xff\n+\tsbci\tr_arg1HL,0xff\n+\tsbci\tr_arg1HH,0xff\n+\tret\n+\t.endfunc\n+#endif /* defined (L_divmodsi4) */\n \n /**********************************\n  * This is a prologue subroutine\n@@ -664,12 +629,8 @@ __epilogue_restores__:\n \tout\t__SP_H__,r29\n \tout\t__SREG__,__tmp_reg__\n \tout\t__SP_L__,r28\n-#if defined (__AVR_ENHANCED__)\n-\tmovw\tr28, r26\n-#else\n-\tmov\tr28,r26\n-\tmov\tr29,r27\n-#endif\n+\tmov_l\tr28, r26\n+\tmov_h\tr29, r27\n \tret\n .endfunc\n #endif /* defined (L_epilogue) */\n@@ -708,7 +669,7 @@ __tablejump2__:\n \tlpm\n \tpush\tr0\n \tret\n-.endfunc\n #endif\n+.endfunc\n #endif /* defined (L_tablejump) */\n "}, {"sha": "bc6aeeb5ffd163d529c920934d112e8e6fd4f0a5", "filename": "gcc/config/avr/t-avr", "status": "modified", "additions": 6, "deletions": 12, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1d26ac96cc832057ed835b238ca35dfdb930762f/gcc%2Fconfig%2Favr%2Ft-avr", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1d26ac96cc832057ed835b238ca35dfdb930762f/gcc%2Fconfig%2Favr%2Ft-avr", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Favr%2Ft-avr?ref=1d26ac96cc832057ed835b238ca35dfdb930762f", "patch": "@@ -8,18 +8,12 @@ LIB1ASMFUNCS = \\\n \t_mulqi3 \\\n \t_mulhi3 \\\n \t_mulsi3 \\\n-\t_umodqi3 \\\n-\t_udivqi3 \\\n-\t_modqi3 \\\n-\t_divqi3 \\\n-\t_umodhi3 \\\n-\t_udivhi3 \\\n-\t_modhi3 \\\n-\t_divhi3 \\\n-\t_umodsi3 \\\n-\t_udivsi3 \\\n-\t_modsi3 \\\n-\t_divsi3 \\\n+\t_udivmodqi4 \\\n+\t_divmodqi4 \\\n+\t_udivmodhi4 \\\n+\t_divmodhi4 \\\n+\t_udivmodsi4 \\\n+\t_divmodsi4 \\\n \t_prologue \\\n \t_epilogue \\\n \t_exit \\"}]}