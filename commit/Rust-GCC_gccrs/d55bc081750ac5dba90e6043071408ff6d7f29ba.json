{"sha": "d55bc081750ac5dba90e6043071408ff6d7f29ba", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDU1YmMwODE3NTBhYzVkYmE5MGU2MDQzMDcxNDA4ZmY2ZDdmMjliYQ==", "commit": {"author": {"name": "Zdenek Dvorak", "email": "rakdver@atrey.karlin.mff.cuni.cz", "date": "2002-05-27T13:45:44Z"}, "committer": {"name": "Zdenek Dvorak", "email": "rakdver@gcc.gnu.org", "date": "2002-05-27T13:45:44Z"}, "message": "basic-block.h (last_basic_block): Defined as synonym for n_basic_blocks.\n\n\t* basic-block.h (last_basic_block): Defined as synonym for\n\tn_basic_blocks.\n\t* cfganal.c (mark_dfs_back_edges, flow_reverse_top_sort_order_compute,\n\tflow_depth_first_order_compute, flow_preorder_transversal_compute,\n\tflow_dfs_compute_reverse_init): Replaced relevant occurences of\n\tn_basic_blocks with last_basic_block.\n\t* cfgbuild.c (make_edges): Likewise.\n\t* cfgloop.c (flow_loop_scan, flow_loops_find): Likewise.\n\t* cfgrtl.c (verify_flow_info, purge_all_dead_edges): Likewise.\n\t* combine.c (combine_instructions): Likewise.\n\t* df.c (df_alloc, df_analyse_1, df_analyse, iterative_dataflow_sbitmap,\n\titerative_dataflow_bitmap): Likewise.\n\t* dominance.c (init_dom_info, calc_dfs_tree_nonrec, calc_dfs_tree,\n\tcalc_idoms, idoms_to_doms): Likewise.\n\t* flow.c (update_life_info_in_dirty_blocks, free_basic_block_vars):\n\tLikewise.\n\t* gcse.c (gcse_main, alloc_gcse_mem, compute_local_properties,\n\tcompute_hash_table, expr_reaches_here_p, one_classic_gcse_pass,\n\tone_cprop_pass, compute_pre_data, pre_expr_reaches_here_p,\n\tone_pre_gcse_pass, compute_transpout, delete_null_pointer_checks_1,\n\tdelete_null_pointer_checks, compute_code_hoist_vbeinout,\n\thoist_expr_reaches_here_p, hoist_code, one_code_hoisting_pass,\n\tcompute_store_table, build_store_vectors): Likewise.\n\t* haifa-sched.c (sched_init): Likewise.\n\t* ifcvt.c (if_convert): Likewise.\n\t* lcm.c (compute_antinout_edge, compute_laterin, compute_insert_delete,\n\tpre_edge_lcm, compute_available, compute_nearerout,\n\tcompute_rev_insert_delete, pre_edge_rev_lcm, optimize_mode_switching):\n\tLikewise.\n\t* predict.c (estimate_probability, process_note_prediction,\n\tnote_prediction_to_br_prob): Likewise.\n\t* profile.c (GCOV_INDEX_TO_BB, BB_TO_GCOV_INDEX): Likewise.\n\t* recog.c (split_all_insns, peephole2_optimize): Likewise.\n\t* regrename.c (copyprop_hardreg_forward): Likewise.\n\t* resource.c (init_resource_info): Likewise.\n\t* sched-rgn.c (build_control_flow, find_rgns, compute_trg_info,\n\tinit_regions, schedule_insns): Likewise.\n\t* ssa-ccp.c (ssa_const_prop): Likewise.\n\t* ssa-dce.c (ssa_eliminate_dead_code): Likewise.\n\t* ssa.c (compute_dominance_frontiers,\n\tcompute_iterated_dominance_frontiers, convert_to_ssa): Likewise.\n\n\t* df.c (df_refs_unlink): Fix FOR_EACH_BB usage (in #if 0'ed code)\n\t* gcse.c (alloc_rd_mem, alloc_avail_expr_mem): Use n_blocks for vector\n\tsizes consistently.\n\nFrom-SVN: r53924", "tree": {"sha": "5e75f1f3015434e7c5c88a788dd95d9066e0d55f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5e75f1f3015434e7c5c88a788dd95d9066e0d55f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d55bc081750ac5dba90e6043071408ff6d7f29ba", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d55bc081750ac5dba90e6043071408ff6d7f29ba", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d55bc081750ac5dba90e6043071408ff6d7f29ba", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d55bc081750ac5dba90e6043071408ff6d7f29ba/comments", "author": null, "committer": null, "parents": [{"sha": "71d2c5bd9b1373e2db43821fc64597f9c067e442", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/71d2c5bd9b1373e2db43821fc64597f9c067e442", "html_url": "https://github.com/Rust-GCC/gccrs/commit/71d2c5bd9b1373e2db43821fc64597f9c067e442"}], "stats": {"total": 487, "additions": 269, "deletions": 218}, "files": [{"sha": "fa8828173d08893921d3b9c3443aea35d8c10d50", "filename": "gcc/ChangeLog", "status": "modified", "additions": 48, "deletions": 0, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d55bc081750ac5dba90e6043071408ff6d7f29ba/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d55bc081750ac5dba90e6043071408ff6d7f29ba/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=d55bc081750ac5dba90e6043071408ff6d7f29ba", "patch": "@@ -1,3 +1,51 @@\n+2002-05-27  Zdenek Dvorak  <rakdver@atrey.karlin.mff.cuni.cz>\n+\n+\t* basic-block.h (last_basic_block): Defined as synonym for\n+\tn_basic_blocks.\n+\t* cfganal.c (mark_dfs_back_edges, flow_reverse_top_sort_order_compute,\n+\tflow_depth_first_order_compute, flow_preorder_transversal_compute,\n+\tflow_dfs_compute_reverse_init): Replaced relevant occurences of\n+\tn_basic_blocks with last_basic_block.\n+\t* cfgbuild.c (make_edges): Likewise.\n+\t* cfgloop.c (flow_loop_scan, flow_loops_find): Likewise.\n+\t* cfgrtl.c (verify_flow_info, purge_all_dead_edges): Likewise.\n+\t* combine.c (combine_instructions): Likewise.\n+\t* df.c (df_alloc, df_analyse_1, df_analyse, iterative_dataflow_sbitmap,\n+\titerative_dataflow_bitmap): Likewise.\n+\t* dominance.c (init_dom_info, calc_dfs_tree_nonrec, calc_dfs_tree,\n+\tcalc_idoms, idoms_to_doms): Likewise.\n+\t* flow.c (update_life_info_in_dirty_blocks, free_basic_block_vars):\n+\tLikewise.\n+\t* gcse.c (gcse_main, alloc_gcse_mem, compute_local_properties,\n+\tcompute_hash_table, expr_reaches_here_p, one_classic_gcse_pass,\n+\tone_cprop_pass, compute_pre_data, pre_expr_reaches_here_p,\n+\tone_pre_gcse_pass, compute_transpout, delete_null_pointer_checks_1,\n+\tdelete_null_pointer_checks, compute_code_hoist_vbeinout,\n+\thoist_expr_reaches_here_p, hoist_code, one_code_hoisting_pass,\n+\tcompute_store_table, build_store_vectors): Likewise.\n+\t* haifa-sched.c (sched_init): Likewise.\n+\t* ifcvt.c (if_convert): Likewise.\n+\t* lcm.c (compute_antinout_edge, compute_laterin, compute_insert_delete,\n+\tpre_edge_lcm, compute_available, compute_nearerout,\n+\tcompute_rev_insert_delete, pre_edge_rev_lcm, optimize_mode_switching):\n+\tLikewise.\n+\t* predict.c (estimate_probability, process_note_prediction,\n+\tnote_prediction_to_br_prob): Likewise.\n+\t* profile.c (GCOV_INDEX_TO_BB, BB_TO_GCOV_INDEX): Likewise.\n+\t* recog.c (split_all_insns, peephole2_optimize): Likewise.\n+\t* regrename.c (copyprop_hardreg_forward): Likewise.\n+\t* resource.c (init_resource_info): Likewise.\n+\t* sched-rgn.c (build_control_flow, find_rgns, compute_trg_info,\n+\tinit_regions, schedule_insns): Likewise.\n+\t* ssa-ccp.c (ssa_const_prop): Likewise.\n+\t* ssa-dce.c (ssa_eliminate_dead_code): Likewise.\n+\t* ssa.c (compute_dominance_frontiers,\n+\tcompute_iterated_dominance_frontiers, convert_to_ssa): Likewise.\n+\n+\t* df.c (df_refs_unlink): Fix FOR_EACH_BB usage (in #if 0'ed code)\n+\t* gcse.c (alloc_rd_mem, alloc_avail_expr_mem): Use n_blocks for vector\n+\tsizes consistently.\n+\n Mon May 27 14:28:12 CEST 2002  Jan Hubicka  <jh@suse.cz>\n \n \t* basic-block.h (can_hoist_p, hoist_insn_after, hoist_insn_to_edge):"}, {"sha": "55981644d4e81c3967a279de11db34627befd904", "filename": "gcc/basic-block.h", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d55bc081750ac5dba90e6043071408ff6d7f29ba/gcc%2Fbasic-block.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d55bc081750ac5dba90e6043071408ff6d7f29ba/gcc%2Fbasic-block.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbasic-block.h?ref=d55bc081750ac5dba90e6043071408ff6d7f29ba", "patch": "@@ -233,6 +233,10 @@ typedef struct basic_block_def {\n \n extern int n_basic_blocks;\n \n+/* First free basic block number.  */\n+\n+#define last_basic_block n_basic_blocks\n+\n /* Number of edges in the current function.  */\n \n extern int n_edges;"}, {"sha": "15031f621c538d5f2d68bfe1033215f09ce9cc0e", "filename": "gcc/cfganal.c", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d55bc081750ac5dba90e6043071408ff6d7f29ba/gcc%2Fcfganal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d55bc081750ac5dba90e6043071408ff6d7f29ba/gcc%2Fcfganal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfganal.c?ref=d55bc081750ac5dba90e6043071408ff6d7f29ba", "patch": "@@ -120,15 +120,15 @@ mark_dfs_back_edges ()\n   bool found = false;\n \n   /* Allocate the preorder and postorder number arrays.  */\n-  pre = (int *) xcalloc (n_basic_blocks, sizeof (int));\n-  post = (int *) xcalloc (n_basic_blocks, sizeof (int));\n+  pre = (int *) xcalloc (last_basic_block, sizeof (int));\n+  post = (int *) xcalloc (last_basic_block, sizeof (int));\n \n   /* Allocate stack for back-tracking up CFG.  */\n   stack = (edge *) xmalloc ((n_basic_blocks + 1) * sizeof (edge));\n   sp = 0;\n \n   /* Allocate bitmap to track nodes that have been visited.  */\n-  visited = sbitmap_alloc (n_basic_blocks);\n+  visited = sbitmap_alloc (last_basic_block);\n \n   /* None of the nodes in the CFG have been visited yet.  */\n   sbitmap_zero (visited);\n@@ -741,7 +741,7 @@ flow_reverse_top_sort_order_compute (rts_order)\n   sp = 0;\n \n   /* Allocate bitmap to track nodes that have been visited.  */\n-  visited = sbitmap_alloc (n_basic_blocks);\n+  visited = sbitmap_alloc (last_basic_block);\n \n   /* None of the nodes in the CFG have been visited yet.  */\n   sbitmap_zero (visited);\n@@ -812,7 +812,7 @@ flow_depth_first_order_compute (dfs_order, rc_order)\n   sp = 0;\n \n   /* Allocate bitmap to track nodes that have been visited.  */\n-  visited = sbitmap_alloc (n_basic_blocks);\n+  visited = sbitmap_alloc (last_basic_block);\n \n   /* None of the nodes in the CFG have been visited yet.  */\n   sbitmap_zero (visited);\n@@ -918,7 +918,7 @@ flow_preorder_transversal_compute (pot_order)\n   sp = 0;\n \n   /* Allocate the tree.  */\n-  dfst = (struct dfst_node *) xcalloc (n_basic_blocks,\n+  dfst = (struct dfst_node *) xcalloc (last_basic_block,\n \t\t\t\t       sizeof (struct dfst_node));\n \n   FOR_EACH_BB (bb)\n@@ -935,7 +935,7 @@ flow_preorder_transversal_compute (pot_order)\n     }\n \n   /* Allocate bitmap to track nodes that have been visited.  */\n-  visited = sbitmap_alloc (n_basic_blocks);\n+  visited = sbitmap_alloc (last_basic_block);\n \n   /* None of the nodes in the CFG have been visited yet.  */\n   sbitmap_zero (visited);\n@@ -1002,7 +1002,7 @@ flow_preorder_transversal_compute (pot_order)\n \n   /* Free the tree.  */\n \n-  for (i = 0; i < n_basic_blocks; i++)\n+  for (i = 0; i < last_basic_block; i++)\n     if (dfst[i].node)\n       free (dfst[i].node);\n \n@@ -1049,7 +1049,7 @@ flow_dfs_compute_reverse_init (data)\n   data->sp = 0;\n \n   /* Allocate bitmap to track nodes that have been visited.  */\n-  data->visited_blocks = sbitmap_alloc (n_basic_blocks - (INVALID_BLOCK + 1));\n+  data->visited_blocks = sbitmap_alloc (last_basic_block - (INVALID_BLOCK + 1));\n \n   /* None of the nodes in the CFG have been visited yet.  */\n   sbitmap_zero (data->visited_blocks);"}, {"sha": "3a86e1ca8f366809793011c118e89f75748946c2", "filename": "gcc/cfgbuild.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d55bc081750ac5dba90e6043071408ff6d7f29ba/gcc%2Fcfgbuild.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d55bc081750ac5dba90e6043071408ff6d7f29ba/gcc%2Fcfgbuild.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgbuild.c?ref=d55bc081750ac5dba90e6043071408ff6d7f29ba", "patch": "@@ -295,8 +295,8 @@ make_edges (label_value_list, min, max, update_p)\n      amount of time searching the edge lists for duplicates.  */\n   if (forced_labels || label_value_list)\n     {\n-      edge_cache = sbitmap_vector_alloc (n_basic_blocks, n_basic_blocks);\n-      sbitmap_vector_zero (edge_cache, n_basic_blocks);\n+      edge_cache = sbitmap_vector_alloc (last_basic_block, last_basic_block);\n+      sbitmap_vector_zero (edge_cache, last_basic_block);\n \n       if (update_p)\n         FOR_BB_BETWEEN (bb, min, max->next_bb, next_bb)"}, {"sha": "a2b10dcacbb94af46c2c80945ec1b42ba50f4289", "filename": "gcc/cfgloop.c", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d55bc081750ac5dba90e6043071408ff6d7f29ba/gcc%2Fcfgloop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d55bc081750ac5dba90e6043071408ff6d7f29ba/gcc%2Fcfgloop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgloop.c?ref=d55bc081750ac5dba90e6043071408ff6d7f29ba", "patch": "@@ -600,7 +600,7 @@ flow_loop_scan (loops, loop, flags)\n \n       /* Determine which loop nodes dominate all the exits\n \t of the loop.  */\n-      loop->exits_doms = sbitmap_alloc (n_basic_blocks);\n+      loop->exits_doms = sbitmap_alloc (last_basic_block);\n       sbitmap_copy (loop->exits_doms, loop->nodes);\n       for (j = 0; j < loop->num_exits; j++)\n \tsbitmap_a_and_b (loop->exits_doms, loop->exits_doms,\n@@ -663,7 +663,7 @@ flow_loops_find (loops, flags)\n   rc_order = NULL;\n \n   /* Compute the dominators.  */\n-  dom = sbitmap_vector_alloc (n_basic_blocks, n_basic_blocks);\n+  dom = sbitmap_vector_alloc (last_basic_block, last_basic_block);\n   calculate_dominance_info (NULL, dom, CDI_DOMINATORS);\n \n   /* Count the number of loop edges (back edges).  This should be the\n@@ -705,10 +705,10 @@ flow_loops_find (loops, flags)\n       loops->array\n \t= (struct loop *) xcalloc (num_loops, sizeof (struct loop));\n \n-      headers = sbitmap_alloc (n_basic_blocks);\n+      headers = sbitmap_alloc (last_basic_block);\n       sbitmap_zero (headers);\n \n-      loops->shared_headers = sbitmap_alloc (n_basic_blocks);\n+      loops->shared_headers = sbitmap_alloc (last_basic_block);\n       sbitmap_zero (loops->shared_headers);\n \n       /* Find and record information about all the natural loops\n@@ -760,7 +760,7 @@ flow_loops_find (loops, flags)\n \t  SET_BIT (headers, loop->header->index);\n \n \t  /* Find nodes contained within the loop.  */\n-\t  loop->nodes = sbitmap_alloc (n_basic_blocks);\n+\t  loop->nodes = sbitmap_alloc (last_basic_block);\n \t  loop->num_nodes\n \t    = flow_loop_nodes_find (loop->header, loop->latch, loop->nodes);\n "}, {"sha": "79f7c0a403aef41436549eec5f9e42d72739958c", "filename": "gcc/cfgrtl.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d55bc081750ac5dba90e6043071408ff6d7f29ba/gcc%2Fcfgrtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d55bc081750ac5dba90e6043071408ff6d7f29ba/gcc%2Fcfgrtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgrtl.c?ref=d55bc081750ac5dba90e6043071408ff6d7f29ba", "patch": "@@ -1712,9 +1712,9 @@ verify_flow_info ()\n   basic_block bb, last_bb_seen;\n \n   bb_info = (basic_block *) xcalloc (max_uid, sizeof (basic_block));\n-  last_visited = (basic_block *) xcalloc (n_basic_blocks + 2,\n+  last_visited = (basic_block *) xcalloc (last_basic_block + 2,\n \t\t\t\t\t  sizeof (basic_block));\n-  edge_checksum = (size_t *) xcalloc (n_basic_blocks + 2, sizeof (size_t));\n+  edge_checksum = (size_t *) xcalloc (last_basic_block + 2, sizeof (size_t));\n \n   /* Check bb chain & numbers.  */\n   last_bb_seen = ENTRY_BLOCK_PTR;\n@@ -2317,7 +2317,7 @@ purge_all_dead_edges (update_life_p)\n \n   if (update_life_p)\n     {\n-      blocks = sbitmap_alloc (n_basic_blocks);\n+      blocks = sbitmap_alloc (last_basic_block);\n       sbitmap_zero (blocks);\n     }\n "}, {"sha": "f0e4431486960a3876a2573250c8088f6ebf48f2", "filename": "gcc/combine.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d55bc081750ac5dba90e6043071408ff6d7f29ba/gcc%2Fcombine.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d55bc081750ac5dba90e6043071408ff6d7f29ba/gcc%2Fcombine.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcombine.c?ref=d55bc081750ac5dba90e6043071408ff6d7f29ba", "patch": "@@ -578,7 +578,7 @@ combine_instructions (f, nregs)\n \n   setup_incoming_promotions ();\n \n-  refresh_blocks = sbitmap_alloc (n_basic_blocks);\n+  refresh_blocks = sbitmap_alloc (last_basic_block);\n   sbitmap_zero (refresh_blocks);\n   need_refresh = 0;\n "}, {"sha": "a35978e579cd17b05638a4fca1759e967c20817a", "filename": "gcc/df.c", "status": "modified", "additions": 23, "deletions": 25, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d55bc081750ac5dba90e6043071408ff6d7f29ba/gcc%2Fdf.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d55bc081750ac5dba90e6043071408ff6d7f29ba/gcc%2Fdf.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdf.c?ref=d55bc081750ac5dba90e6043071408ff6d7f29ba", "patch": "@@ -547,7 +547,7 @@ df_alloc (df, n_regs)\n   df->uses = xmalloc (df->use_size * sizeof (*df->uses));\n \n   df->n_regs = n_regs;\n-  df->n_bbs = n_basic_blocks;\n+  df->n_bbs = last_basic_block;\n \n   /* Allocate temporary working array used during local dataflow analysis.  */\n   df->reg_def_last = xmalloc (df->n_regs * sizeof (struct ref *));\n@@ -561,7 +561,7 @@ df_alloc (df, n_regs)\n \n   df->flags = 0;\n \n-  df->bbs = xcalloc (df->n_bbs, sizeof (struct bb_info));\n+  df->bbs = xcalloc (last_basic_block, sizeof (struct bb_info));\n \n   df->all_blocks = BITMAP_XMALLOC ();\n   FOR_EACH_BB (bb)\n@@ -2006,9 +2006,9 @@ df_analyse_1 (df, blocks, flags, update)\n   df->dfs_order = xmalloc (sizeof(int) * n_basic_blocks);\n   df->rc_order = xmalloc (sizeof(int) * n_basic_blocks);\n   df->rts_order = xmalloc (sizeof(int) * n_basic_blocks);\n-  df->inverse_dfs_map = xmalloc (sizeof(int) * n_basic_blocks);\n-  df->inverse_rc_map = xmalloc (sizeof(int) * n_basic_blocks);\n-  df->inverse_rts_map = xmalloc (sizeof(int) * n_basic_blocks);\n+  df->inverse_dfs_map = xmalloc (sizeof(int) * last_basic_block);\n+  df->inverse_rc_map = xmalloc (sizeof(int) * last_basic_block);\n+  df->inverse_rts_map = xmalloc (sizeof(int) * last_basic_block);\n \n   flow_depth_first_order_compute (df->dfs_order, df->rc_order);\n   flow_reverse_top_sort_order_compute (df->rts_order);\n@@ -2023,10 +2023,10 @@ df_analyse_1 (df, blocks, flags, update)\n       /* Compute the sets of gens and kills for the defs of each bb.  */\n       df_rd_local_compute (df, df->flags & DF_RD ? blocks : df->all_blocks);\n       {\n-\tbitmap *in = xmalloc (sizeof (bitmap) * n_basic_blocks);\n-\tbitmap *out = xmalloc (sizeof (bitmap) * n_basic_blocks);\n-\tbitmap *gen = xmalloc (sizeof (bitmap) * n_basic_blocks);\n-\tbitmap *kill = xmalloc (sizeof (bitmap) * n_basic_blocks);\n+\tbitmap *in = xmalloc (sizeof (bitmap) * last_basic_block);\n+\tbitmap *out = xmalloc (sizeof (bitmap) * last_basic_block);\n+\tbitmap *gen = xmalloc (sizeof (bitmap) * last_basic_block);\n+\tbitmap *kill = xmalloc (sizeof (bitmap) * last_basic_block);\n \tFOR_EACH_BB (bb)\n \t  {\n \t    in[bb->index] = DF_BB_INFO (df, bb)->rd_in;\n@@ -2059,10 +2059,10 @@ df_analyse_1 (df, blocks, flags, update)\n \t uses in each bb.  */\n       df_ru_local_compute (df, df->flags & DF_RU ? blocks : df->all_blocks);\n       {\n-\tbitmap *in = xmalloc (sizeof (bitmap) * n_basic_blocks);\n-\tbitmap *out = xmalloc (sizeof (bitmap) * n_basic_blocks);\n-\tbitmap *gen = xmalloc (sizeof (bitmap) * n_basic_blocks);\n-\tbitmap *kill = xmalloc (sizeof (bitmap) * n_basic_blocks);\n+\tbitmap *in = xmalloc (sizeof (bitmap) * last_basic_block);\n+\tbitmap *out = xmalloc (sizeof (bitmap) * last_basic_block);\n+\tbitmap *gen = xmalloc (sizeof (bitmap) * last_basic_block);\n+\tbitmap *kill = xmalloc (sizeof (bitmap) * last_basic_block);\n \tFOR_EACH_BB (bb)\n \t  {\n \t    in[bb->index] = DF_BB_INFO (df, bb)->ru_in;\n@@ -2098,10 +2098,10 @@ df_analyse_1 (df, blocks, flags, update)\n       /* Compute the sets of defs and uses of live variables.  */\n       df_lr_local_compute (df, df->flags & DF_LR ? blocks : df->all_blocks);\n       {\n-\tbitmap *in = xmalloc (sizeof (bitmap) * n_basic_blocks);\n-\tbitmap *out = xmalloc (sizeof (bitmap) * n_basic_blocks);\n-\tbitmap *use = xmalloc (sizeof (bitmap) * n_basic_blocks);\n-\tbitmap *def = xmalloc (sizeof (bitmap) * n_basic_blocks);\n+\tbitmap *in = xmalloc (sizeof (bitmap) * last_basic_block);\n+\tbitmap *out = xmalloc (sizeof (bitmap) * last_basic_block);\n+\tbitmap *use = xmalloc (sizeof (bitmap) * last_basic_block);\n+\tbitmap *def = xmalloc (sizeof (bitmap) * last_basic_block);\n \tFOR_EACH_BB (bb)\n \t  {\n \t    in[bb->index] = DF_BB_INFO (df, bb)->lr_in;\n@@ -2292,7 +2292,7 @@ df_analyse (df, blocks, flags)\n \n   /* We could deal with additional basic blocks being created by\n      rescanning everything again.  */\n-  if (df->n_bbs && df->n_bbs != (unsigned int)n_basic_blocks)\n+  if (df->n_bbs && df->n_bbs != (unsigned int) last_basic_block)\n     abort ();\n \n   update = df_modified_p (df, blocks);\n@@ -2402,10 +2402,8 @@ df_refs_unlink (df, blocks)\n     }\n   else\n     {\n-      FOR_EACH_BB (bb,\n-      {\n+      FOR_EACH_BB (bb)\n \tdf_bb_refs_unlink (df, bb);\n-      });\n     }\n }\n #endif\n@@ -3846,8 +3844,8 @@ iterative_dataflow_sbitmap (in, out, gen, kill, blocks,\n   fibheap_t worklist;\n   basic_block bb;\n   sbitmap visited, pending;\n-  pending = sbitmap_alloc (n_basic_blocks);\n-  visited = sbitmap_alloc (n_basic_blocks);\n+  pending = sbitmap_alloc (last_basic_block);\n+  visited = sbitmap_alloc (last_basic_block);\n   sbitmap_zero (pending);\n   sbitmap_zero (visited);\n   worklist = fibheap_new ();\n@@ -3905,8 +3903,8 @@ iterative_dataflow_bitmap (in, out, gen, kill, blocks,\n   fibheap_t worklist;\n   basic_block bb;\n   sbitmap visited, pending;\n-  pending = sbitmap_alloc (n_basic_blocks);\n-  visited = sbitmap_alloc (n_basic_blocks);\n+  pending = sbitmap_alloc (last_basic_block);\n+  visited = sbitmap_alloc (last_basic_block);\n   sbitmap_zero (pending);\n   sbitmap_zero (visited);\n   worklist = fibheap_new ();"}, {"sha": "0ba90dbad6829dbbaec9917f3cf020899788bb32", "filename": "gcc/dominance.c", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d55bc081750ac5dba90e6043071408ff6d7f29ba/gcc%2Fdominance.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d55bc081750ac5dba90e6043071408ff6d7f29ba/gcc%2Fdominance.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdominance.c?ref=d55bc081750ac5dba90e6043071408ff6d7f29ba", "patch": "@@ -45,7 +45,7 @@\n    number of the corresponding basic block.  Please note, that we include the\n    artificial ENTRY_BLOCK (or EXIT_BLOCK in the post-dom case) in our lists to\n    support multiple entry points.  As it has no real basic block index we use\n-   'n_basic_blocks' for that.  Its dfs number is of course 1.  */\n+   'last_basic_block' for that.  Its dfs number is of course 1.  */\n \n /* Type of Basic Block aka. TBB */\n typedef unsigned int TBB;\n@@ -155,7 +155,7 @@ init_dom_info (di)\n   init_ar (di->set_size, unsigned int, num, 1);\n   init_ar (di->set_child, TBB, num, 0);\n \n-  init_ar (di->dfs_order, TBB, (unsigned int) n_basic_blocks + 1, 0);\n+  init_ar (di->dfs_order, TBB, (unsigned int) last_basic_block + 1, 0);\n   init_ar (di->dfs_to_bb, basic_block, num, 0);\n \n   di->dfsnum = 1;\n@@ -271,7 +271,7 @@ calc_dfs_tree_nonrec (di, bb, reverse)\n \t  if (bb != en_block)\n \t    my_i = di->dfs_order[bb->index];\n \t  else\n-\t    my_i = di->dfs_order[n_basic_blocks];\n+\t    my_i = di->dfs_order[last_basic_block];\n \t  child_i = di->dfs_order[bn->index] = di->dfsnum++;\n \t  di->dfs_to_bb[child_i] = bn;\n \t  di->dfs_parent[child_i] = my_i;\n@@ -314,7 +314,7 @@ calc_dfs_tree (di, reverse)\n {\n   /* The first block is the ENTRY_BLOCK (or EXIT_BLOCK if REVERSE).  */\n   basic_block begin = reverse ? EXIT_BLOCK_PTR : ENTRY_BLOCK_PTR;\n-  di->dfs_order[n_basic_blocks] = di->dfsnum;\n+  di->dfs_order[last_basic_block] = di->dfsnum;\n   di->dfs_to_bb[di->dfsnum] = begin;\n   di->dfsnum++;\n \n@@ -493,7 +493,7 @@ calc_idoms (di, reverse)\n \t      e_next = e->pred_next;\n \t    }\n \t  if (b == en_block)\n-\t    k1 = di->dfs_order[n_basic_blocks];\n+\t    k1 = di->dfs_order[last_basic_block];\n \t  else\n \t    k1 = di->dfs_order[b->index];\n \n@@ -541,10 +541,10 @@ idoms_to_doms (di, dominators)\n {\n   TBB i, e_index;\n   int bb, bb_idom;\n-  sbitmap_vector_zero (dominators, n_basic_blocks);\n+  sbitmap_vector_zero (dominators, last_basic_block);\n   /* We have to be careful, to not include the ENTRY_BLOCK or EXIT_BLOCK\n      in the list of (post)-doms, so remember that in e_index.  */\n-  e_index = di->dfs_order[n_basic_blocks];\n+  e_index = di->dfs_order[last_basic_block];\n \n   for (i = 1; i <= di->nodes; i++)\n     {\n@@ -576,8 +576,8 @@ idoms_to_doms (di, dominators)\n }\n \n /* The main entry point into this module.  IDOM is an integer array with room\n-   for n_basic_blocks integers, DOMS is a preallocated sbitmap array having\n-   room for n_basic_blocks^2 bits, and POST is true if the caller wants to\n+   for last_basic_block integers, DOMS is a preallocated sbitmap array having\n+   room for last_basic_block^2 bits, and POST is true if the caller wants to\n    know post-dominators.\n \n    On return IDOM[i] will be the BB->index of the immediate (post) dominator"}, {"sha": "a4dbe1ef14c13b18e883476db3ee769e895da91a", "filename": "gcc/flow.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d55bc081750ac5dba90e6043071408ff6d7f29ba/gcc%2Fflow.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d55bc081750ac5dba90e6043071408ff6d7f29ba/gcc%2Fflow.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fflow.c?ref=d55bc081750ac5dba90e6043071408ff6d7f29ba", "patch": "@@ -761,7 +761,7 @@ update_life_info_in_dirty_blocks (extent, prop_flags)\n      enum update_life_extent extent;\n      int prop_flags;\n {\n-  sbitmap update_life_blocks = sbitmap_alloc (n_basic_blocks);\n+  sbitmap update_life_blocks = sbitmap_alloc (last_basic_block);\n   int n = 0;\n   basic_block bb;\n   int retval = 0;\n@@ -797,6 +797,7 @@ free_basic_block_vars (keep_head_end_p)\n \t  VARRAY_FREE (basic_block_info);\n \t}\n       n_basic_blocks = 0;\n+      last_basic_block = 0;\n \n       ENTRY_BLOCK_PTR->aux = NULL;\n       ENTRY_BLOCK_PTR->global_live_at_end = NULL;"}, {"sha": "f279dde90af08baba2914cda7d5ed933909b9f0c", "filename": "gcc/gcse.c", "status": "modified", "additions": 57, "deletions": 57, "changes": 114, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d55bc081750ac5dba90e6043071408ff6d7f29ba/gcc%2Fgcse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d55bc081750ac5dba90e6043071408ff6d7f29ba/gcc%2Fgcse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgcse.c?ref=d55bc081750ac5dba90e6043071408ff6d7f29ba", "patch": "@@ -834,11 +834,11 @@ gcse_main (f, file)\n \t    {\n \t      free_modify_mem_tables ();\n \t      modify_mem_list\n-\t\t= (rtx *) gmalloc (n_basic_blocks * sizeof (rtx));\n+\t\t= (rtx *) gmalloc (last_basic_block * sizeof (rtx));\n \t      canon_modify_mem_list\n-\t\t= (rtx *) gmalloc (n_basic_blocks * sizeof (rtx));\n-\t      memset ((char *) modify_mem_list, 0, n_basic_blocks * sizeof (rtx));\n-\t      memset ((char *) canon_modify_mem_list, 0, n_basic_blocks * sizeof (rtx));\n+\t\t= (rtx *) gmalloc (last_basic_block * sizeof (rtx));\n+\t      memset ((char *) modify_mem_list, 0, last_basic_block * sizeof (rtx));\n+\t      memset ((char *) canon_modify_mem_list, 0, last_basic_block * sizeof (rtx));\n \t      orig_bb_count = n_basic_blocks;\n \t    }\n \t  free_reg_set_mem ();\n@@ -1019,14 +1019,14 @@ alloc_gcse_mem (f)\n   reg_set_bitmap = BITMAP_XMALLOC ();\n \n   /* Allocate vars to track sets of regs, memory per block.  */\n-  reg_set_in_block = (sbitmap *) sbitmap_vector_alloc (n_basic_blocks,\n+  reg_set_in_block = (sbitmap *) sbitmap_vector_alloc (last_basic_block,\n \t\t\t\t\t\t       max_gcse_regno);\n   /* Allocate array to keep a list of insns which modify memory in each\n      basic block.  */\n-  modify_mem_list = (rtx *) gmalloc (n_basic_blocks * sizeof (rtx));\n-  canon_modify_mem_list = (rtx *) gmalloc (n_basic_blocks * sizeof (rtx));\n-  memset ((char *) modify_mem_list, 0, n_basic_blocks * sizeof (rtx));\n-  memset ((char *) canon_modify_mem_list, 0, n_basic_blocks * sizeof (rtx));\n+  modify_mem_list = (rtx *) gmalloc (last_basic_block * sizeof (rtx));\n+  canon_modify_mem_list = (rtx *) gmalloc (last_basic_block * sizeof (rtx));\n+  memset ((char *) modify_mem_list, 0, last_basic_block * sizeof (rtx));\n+  memset ((char *) canon_modify_mem_list, 0, last_basic_block * sizeof (rtx));\n   modify_mem_list_set = BITMAP_XMALLOC ();\n   canon_modify_mem_list_set = BITMAP_XMALLOC ();\n }\n@@ -1132,15 +1132,15 @@ compute_local_properties (transp, comp, antloc, setp)\n   if (transp)\n     {\n       if (setp)\n-\tsbitmap_vector_zero (transp, n_basic_blocks);\n+\tsbitmap_vector_zero (transp, last_basic_block);\n       else\n-\tsbitmap_vector_ones (transp, n_basic_blocks);\n+\tsbitmap_vector_ones (transp, last_basic_block);\n     }\n \n   if (comp)\n-    sbitmap_vector_zero (comp, n_basic_blocks);\n+    sbitmap_vector_zero (comp, last_basic_block);\n   if (antloc)\n-    sbitmap_vector_zero (antloc, n_basic_blocks);\n+    sbitmap_vector_zero (antloc, last_basic_block);\n \n   /* We use the same code for cprop, pre and hoisting.  For cprop\n      we care about the set hash table, for pre and hoisting we\n@@ -2495,7 +2495,7 @@ compute_hash_table (set_p)\n      registers are set in which blocks.\n      ??? This isn't needed during const/copy propagation, but it's cheap to\n      compute.  Later.  */\n-  sbitmap_vector_zero (reg_set_in_block, n_basic_blocks);\n+  sbitmap_vector_zero (reg_set_in_block, last_basic_block);\n \n   /* re-Cache any INSN_LIST nodes we have allocated.  */\n   clear_modify_mem_tables ();\n@@ -2940,16 +2940,16 @@ alloc_rd_mem (n_blocks, n_insns)\n      int n_blocks, n_insns;\n {\n   rd_kill = (sbitmap *) sbitmap_vector_alloc (n_blocks, n_insns);\n-  sbitmap_vector_zero (rd_kill, n_basic_blocks);\n+  sbitmap_vector_zero (rd_kill, n_blocks);\n \n   rd_gen = (sbitmap *) sbitmap_vector_alloc (n_blocks, n_insns);\n-  sbitmap_vector_zero (rd_gen, n_basic_blocks);\n+  sbitmap_vector_zero (rd_gen, n_blocks);\n \n   reaching_defs = (sbitmap *) sbitmap_vector_alloc (n_blocks, n_insns);\n-  sbitmap_vector_zero (reaching_defs, n_basic_blocks);\n+  sbitmap_vector_zero (reaching_defs, n_blocks);\n \n   rd_out = (sbitmap *) sbitmap_vector_alloc (n_blocks, n_insns);\n-  sbitmap_vector_zero (rd_out, n_basic_blocks);\n+  sbitmap_vector_zero (rd_out, n_blocks);\n }\n \n /* Free reaching def variables.  */\n@@ -3071,16 +3071,16 @@ alloc_avail_expr_mem (n_blocks, n_exprs)\n      int n_blocks, n_exprs;\n {\n   ae_kill = (sbitmap *) sbitmap_vector_alloc (n_blocks, n_exprs);\n-  sbitmap_vector_zero (ae_kill, n_basic_blocks);\n+  sbitmap_vector_zero (ae_kill, n_blocks);\n \n   ae_gen = (sbitmap *) sbitmap_vector_alloc (n_blocks, n_exprs);\n-  sbitmap_vector_zero (ae_gen, n_basic_blocks);\n+  sbitmap_vector_zero (ae_gen, n_blocks);\n \n   ae_in = (sbitmap *) sbitmap_vector_alloc (n_blocks, n_exprs);\n-  sbitmap_vector_zero (ae_in, n_basic_blocks);\n+  sbitmap_vector_zero (ae_in, n_blocks);\n \n   ae_out = (sbitmap *) sbitmap_vector_alloc (n_blocks, n_exprs);\n-  sbitmap_vector_zero (ae_out, n_basic_blocks);\n+  sbitmap_vector_zero (ae_out, n_blocks);\n }\n \n static void\n@@ -3285,7 +3285,7 @@ expr_reaches_here_p (occr, expr, bb, check_self_loop)\n      int check_self_loop;\n {\n   int rval;\n-  char *visited = (char *) xcalloc (n_basic_blocks, 1);\n+  char *visited = (char *) xcalloc (last_basic_block, 1);\n \n   rval = expr_reaches_here_p_work (occr, expr, bb, check_self_loop, visited);\n   \n@@ -3675,7 +3675,7 @@ one_classic_gcse_pass (pass)\n   gcse_create_count = 0;\n \n   alloc_expr_hash_table (max_cuid);\n-  alloc_rd_mem (n_basic_blocks, max_cuid);\n+  alloc_rd_mem (last_basic_block, max_cuid);\n   compute_expr_hash_table ();\n   if (gcse_file)\n     dump_hash_table (gcse_file, \"Expression\", expr_hash_table,\n@@ -3685,7 +3685,7 @@ one_classic_gcse_pass (pass)\n     {\n       compute_kill_rd ();\n       compute_rd ();\n-      alloc_avail_expr_mem (n_basic_blocks, n_exprs);\n+      alloc_avail_expr_mem (last_basic_block, n_exprs);\n       compute_ae_gen ();\n       compute_ae_kill (ae_gen, ae_kill);\n       compute_available (ae_gen, ae_kill, ae_out, ae_in);\n@@ -4358,7 +4358,7 @@ one_cprop_pass (pass, alter_jumps)\n \t\t     n_sets);\n   if (n_sets > 0)\n     {\n-      alloc_cprop_mem (n_basic_blocks, n_sets);\n+      alloc_cprop_mem (last_basic_block, n_sets);\n       compute_cprop_data ();\n       changed = cprop (alter_jumps);\n       free_cprop_mem ();\n@@ -4472,7 +4472,7 @@ compute_pre_data ()\n   unsigned int ui;\n \n   compute_local_properties (transp, comp, antloc, 0);\n-  sbitmap_vector_zero (ae_kill, n_basic_blocks);\n+  sbitmap_vector_zero (ae_kill, last_basic_block);\n \n   /* Collect expressions which might trap.  */\n   trapping_expr = sbitmap_alloc (n_exprs);\n@@ -4591,7 +4591,7 @@ pre_expr_reaches_here_p (occr_bb, expr, bb)\n      basic_block bb;\n {\n   int rval;\n-  char *visited = (char *) xcalloc (n_basic_blocks, 1);\n+  char *visited = (char *) xcalloc (last_basic_block, 1);\n \n   rval = pre_expr_reaches_here_p_work (occr_bb, expr, bb, visited);\n \n@@ -5111,7 +5111,7 @@ one_pre_gcse_pass (pass)\n \n   if (n_exprs > 0)\n     {\n-      alloc_pre_mem (n_basic_blocks, n_exprs);\n+      alloc_pre_mem (last_basic_block, n_exprs);\n       compute_pre_data ();\n       changed |= pre_gcse ();\n       free_edge_list (edge_list);\n@@ -5199,7 +5199,7 @@ compute_transpout ()\n   unsigned int i;\n   struct expr *expr;\n \n-  sbitmap_vector_ones (transpout, n_basic_blocks);\n+  sbitmap_vector_ones (transpout, last_basic_block);\n \n   FOR_EACH_BB (bb)\n     {\n@@ -5281,8 +5281,8 @@ delete_null_pointer_checks_1 (block_reg, nonnull_avin,\n      Note that a register can have both properties in a single block.  That\n      indicates that it's killed, then later in the block a new value is\n      computed.  */\n-  sbitmap_vector_zero (nonnull_local, n_basic_blocks);\n-  sbitmap_vector_zero (nonnull_killed, n_basic_blocks);\n+  sbitmap_vector_zero (nonnull_local, last_basic_block);\n+  sbitmap_vector_zero (nonnull_killed, last_basic_block);\n \n   FOR_EACH_BB (current_block)\n     {\n@@ -5459,18 +5459,18 @@ delete_null_pointer_checks (f)\n   /* We need four bitmaps, each with a bit for each register in each\n      basic block.  */\n   max_reg = max_reg_num ();\n-  regs_per_pass = get_bitmap_width (4, n_basic_blocks, max_reg);\n+  regs_per_pass = get_bitmap_width (4, last_basic_block, max_reg);\n \n   /* Allocate bitmaps to hold local and global properties.  */\n-  npi.nonnull_local = sbitmap_vector_alloc (n_basic_blocks, regs_per_pass);\n-  npi.nonnull_killed = sbitmap_vector_alloc (n_basic_blocks, regs_per_pass);\n-  nonnull_avin = sbitmap_vector_alloc (n_basic_blocks, regs_per_pass);\n-  nonnull_avout = sbitmap_vector_alloc (n_basic_blocks, regs_per_pass);\n+  npi.nonnull_local = sbitmap_vector_alloc (last_basic_block, regs_per_pass);\n+  npi.nonnull_killed = sbitmap_vector_alloc (last_basic_block, regs_per_pass);\n+  nonnull_avin = sbitmap_vector_alloc (last_basic_block, regs_per_pass);\n+  nonnull_avout = sbitmap_vector_alloc (last_basic_block, regs_per_pass);\n \n   /* Go through the basic blocks, seeing whether or not each block\n      ends with a conditional branch whose condition is a comparison\n      against zero.  Record the register compared in BLOCK_REG.  */\n-  block_reg = (unsigned int *) xcalloc (n_basic_blocks, sizeof (int));\n+  block_reg = (unsigned int *) xcalloc (last_basic_block, sizeof (int));\n   FOR_EACH_BB (bb)\n     {\n       rtx last_insn = bb->end;\n@@ -5586,8 +5586,8 @@ compute_code_hoist_vbeinout ()\n   int changed, passes;\n   basic_block bb;\n \n-  sbitmap_vector_zero (hoist_vbeout, n_basic_blocks);\n-  sbitmap_vector_zero (hoist_vbein, n_basic_blocks);\n+  sbitmap_vector_zero (hoist_vbeout, last_basic_block);\n+  sbitmap_vector_zero (hoist_vbein, last_basic_block);\n \n   passes = 0;\n   changed = 1;\n@@ -5653,7 +5653,7 @@ hoist_expr_reaches_here_p (expr_bb, expr_index, bb, visited)\n   if (visited == NULL)\n     {\n       visited_allocated_locally = 1;\n-      visited = xcalloc (n_basic_blocks, 1);\n+      visited = xcalloc (last_basic_block, 1);\n     }\n \n   for (pred = bb->pred; pred != NULL; pred = pred->pred_next)\n@@ -5696,7 +5696,7 @@ hoist_code ()\n   struct expr **index_map;\n   struct expr *expr;\n \n-  sbitmap_vector_zero (hoist_exprs, n_basic_blocks);\n+  sbitmap_vector_zero (hoist_exprs, last_basic_block);\n \n   /* Compute a mapping from expression number (`bitmap_index') to\n      hash table entry.  */\n@@ -5871,7 +5871,7 @@ one_code_hoisting_pass ()\n \n   if (n_exprs > 0)\n     {\n-      alloc_code_hoist_mem (n_basic_blocks, n_exprs);\n+      alloc_code_hoist_mem (last_basic_block, n_exprs);\n       compute_code_hoist_data ();\n       hoist_code ();\n       free_code_hoist_mem ();\n@@ -6453,9 +6453,9 @@ compute_store_table ()\n \n   max_gcse_regno = max_reg_num ();\n \n-  reg_set_in_block = (sbitmap *) sbitmap_vector_alloc (n_basic_blocks,\n+  reg_set_in_block = (sbitmap *) sbitmap_vector_alloc (last_basic_block,\n \t\t\t\t\t\t       max_gcse_regno);\n-  sbitmap_vector_zero (reg_set_in_block, n_basic_blocks);\n+  sbitmap_vector_zero (reg_set_in_block, last_basic_block);\n   pre_ldst_mems = 0;\n \n   /* Find all the stores we care about.  */\n@@ -6654,11 +6654,11 @@ build_store_vectors ()\n \n   /* Build the gen_vector. This is any store in the table which is not killed\n      by aliasing later in its block.  */\n-  ae_gen = (sbitmap *) sbitmap_vector_alloc (n_basic_blocks, num_stores);\n-  sbitmap_vector_zero (ae_gen, n_basic_blocks);\n+  ae_gen = (sbitmap *) sbitmap_vector_alloc (last_basic_block, num_stores);\n+  sbitmap_vector_zero (ae_gen, last_basic_block);\n \n-  st_antloc = (sbitmap *) sbitmap_vector_alloc (n_basic_blocks, num_stores);\n-  sbitmap_vector_zero (st_antloc, n_basic_blocks);\n+  st_antloc = (sbitmap *) sbitmap_vector_alloc (last_basic_block, num_stores);\n+  sbitmap_vector_zero (st_antloc, last_basic_block);\n \n   for (ptr = first_ls_expr (); ptr != NULL; ptr = next_ls_expr (ptr))\n     { \n@@ -6713,11 +6713,11 @@ build_store_vectors ()\n       free_INSN_LIST_list (&store_list);\n     }\n \t  \n-  ae_kill = (sbitmap *) sbitmap_vector_alloc (n_basic_blocks, num_stores);\n-  sbitmap_vector_zero (ae_kill, n_basic_blocks);\n+  ae_kill = (sbitmap *) sbitmap_vector_alloc (last_basic_block, num_stores);\n+  sbitmap_vector_zero (ae_kill, last_basic_block);\n \n-  transp = (sbitmap *) sbitmap_vector_alloc (n_basic_blocks, num_stores);\n-  sbitmap_vector_zero (transp, n_basic_blocks);\n+  transp = (sbitmap *) sbitmap_vector_alloc (last_basic_block, num_stores);\n+  sbitmap_vector_zero (transp, last_basic_block);\n \n   for (ptr = first_ls_expr (); ptr != NULL; ptr = next_ls_expr (ptr))\n     FOR_EACH_BB (b)\n@@ -6754,10 +6754,10 @@ build_store_vectors ()\n     {\n       fprintf (gcse_file, \"ST_avail and ST_antic (shown under loads..)\\n\");\n       print_ldst_list (gcse_file);\n-      dump_sbitmap_vector (gcse_file, \"st_antloc\", \"\", st_antloc, n_basic_blocks);\n-      dump_sbitmap_vector (gcse_file, \"st_kill\", \"\", ae_kill, n_basic_blocks);\n-      dump_sbitmap_vector (gcse_file, \"Transpt\", \"\", transp, n_basic_blocks);\n-      dump_sbitmap_vector (gcse_file, \"st_avloc\", \"\", ae_gen, n_basic_blocks);\n+      dump_sbitmap_vector (gcse_file, \"st_antloc\", \"\", st_antloc, last_basic_block);\n+      dump_sbitmap_vector (gcse_file, \"st_kill\", \"\", ae_kill, last_basic_block);\n+      dump_sbitmap_vector (gcse_file, \"Transpt\", \"\", transp, last_basic_block);\n+      dump_sbitmap_vector (gcse_file, \"st_avloc\", \"\", ae_gen, last_basic_block);\n     }\n }\n "}, {"sha": "3e0a44588d074f96ff18cbb097a4f50a67108ea3", "filename": "gcc/haifa-sched.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d55bc081750ac5dba90e6043071408ff6d7f29ba/gcc%2Fhaifa-sched.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d55bc081750ac5dba90e6043071408ff6d7f29ba/gcc%2Fhaifa-sched.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fhaifa-sched.c?ref=d55bc081750ac5dba90e6043071408ff6d7f29ba", "patch": "@@ -2384,7 +2384,7 @@ sched_init (dump_file)\n     {\n       rtx line;\n \n-      line_note_head = (rtx *) xcalloc (n_basic_blocks, sizeof (rtx));\n+      line_note_head = (rtx *) xcalloc (last_basic_block, sizeof (rtx));\n \n       /* Save-line-note-head:\n          Determine the line-number at the start of each basic block."}, {"sha": "b444f3b24d372130820d96de92e7b6ac98cbd3af", "filename": "gcc/ifcvt.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d55bc081750ac5dba90e6043071408ff6d7f29ba/gcc%2Fifcvt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d55bc081750ac5dba90e6043071408ff6d7f29ba/gcc%2Fifcvt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fifcvt.c?ref=d55bc081750ac5dba90e6043071408ff6d7f29ba", "patch": "@@ -2700,7 +2700,7 @@ if_convert (x_life_data_ok)\n   post_dominators = NULL;\n   if (HAVE_conditional_execution || life_data_ok)\n     {\n-      post_dominators = sbitmap_vector_alloc (n_basic_blocks, n_basic_blocks);\n+      post_dominators = sbitmap_vector_alloc (last_basic_block, last_basic_block);\n       calculate_dominance_info (NULL, post_dominators, CDI_POST_DOMINATORS);\n     }\n   if (life_data_ok)"}, {"sha": "ff0af92f0fa2fb75e9fb129d48483849778de0a6", "filename": "gcc/lcm.c", "status": "modified", "additions": 60, "deletions": 60, "changes": 120, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d55bc081750ac5dba90e6043071408ff6d7f29ba/gcc%2Flcm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d55bc081750ac5dba90e6043071408ff6d7f29ba/gcc%2Flcm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flcm.c?ref=d55bc081750ac5dba90e6043071408ff6d7f29ba", "patch": "@@ -119,7 +119,7 @@ compute_antinout_edge (antloc, transp, antin, antout)\n \n   /* We want a maximal solution, so make an optimistic initialization of\n      ANTIN.  */\n-  sbitmap_vector_ones (antin, n_basic_blocks);\n+  sbitmap_vector_ones (antin, last_basic_block);\n \n   /* Put every block on the worklist; this is necessary because of the\n      optimistic initialization of ANTIN above.  */\n@@ -348,10 +348,10 @@ compute_laterin (edge_list, earliest, antloc, later, laterin)\n   /* Computation of insertion and deletion points requires computing LATERIN\n      for the EXIT block.  We allocated an extra entry in the LATERIN array\n      for just this purpose.  */\n-  sbitmap_ones (laterin[n_basic_blocks]);\n+  sbitmap_ones (laterin[last_basic_block]);\n   for (e = EXIT_BLOCK_PTR->pred; e != NULL; e = e->pred_next)\n-    sbitmap_a_and_b (laterin[n_basic_blocks],\n-\t\t     laterin[n_basic_blocks],\n+    sbitmap_a_and_b (laterin[last_basic_block],\n+\t\t     laterin[last_basic_block],\n \t\t     later[(size_t) e->aux]);\n \n   clear_aux_for_edges ();\n@@ -377,7 +377,7 @@ compute_insert_delete (edge_list, antloc, later, laterin,\n       basic_block b = INDEX_EDGE_SUCC_BB (edge_list, x);\n \n       if (b == EXIT_BLOCK_PTR)\n-\tsbitmap_difference (insert[x], later[x], laterin[n_basic_blocks]);\n+\tsbitmap_difference (insert[x], later[x], laterin[last_basic_block]);\n       else\n \tsbitmap_difference (insert[x], later[x], laterin[b->index]);\n     }\n@@ -413,29 +413,29 @@ pre_edge_lcm (file, n_exprs, transp, avloc, antloc, kill, insert, delete)\n       fprintf (file, \"Edge List:\\n\");\n       verify_edge_list (file, edge_list);\n       print_edge_list (file, edge_list);\n-      dump_sbitmap_vector (file, \"transp\", \"\", transp, n_basic_blocks);\n-      dump_sbitmap_vector (file, \"antloc\", \"\", antloc, n_basic_blocks);\n-      dump_sbitmap_vector (file, \"avloc\", \"\", avloc, n_basic_blocks);\n-      dump_sbitmap_vector (file, \"kill\", \"\", kill, n_basic_blocks);\n+      dump_sbitmap_vector (file, \"transp\", \"\", transp, last_basic_block);\n+      dump_sbitmap_vector (file, \"antloc\", \"\", antloc, last_basic_block);\n+      dump_sbitmap_vector (file, \"avloc\", \"\", avloc, last_basic_block);\n+      dump_sbitmap_vector (file, \"kill\", \"\", kill, last_basic_block);\n     }\n #endif\n \n   /* Compute global availability.  */\n-  avin = sbitmap_vector_alloc (n_basic_blocks, n_exprs);\n-  avout = sbitmap_vector_alloc (n_basic_blocks, n_exprs);\n+  avin = sbitmap_vector_alloc (last_basic_block, n_exprs);\n+  avout = sbitmap_vector_alloc (last_basic_block, n_exprs);\n   compute_available (avloc, kill, avout, avin);\n   sbitmap_vector_free (avin);\n \n   /* Compute global anticipatability.  */\n-  antin = sbitmap_vector_alloc (n_basic_blocks, n_exprs);\n-  antout = sbitmap_vector_alloc (n_basic_blocks, n_exprs);\n+  antin = sbitmap_vector_alloc (last_basic_block, n_exprs);\n+  antout = sbitmap_vector_alloc (last_basic_block, n_exprs);\n   compute_antinout_edge (antloc, transp, antin, antout);\n \n #ifdef LCM_DEBUG_INFO\n   if (file)\n     {\n-      dump_sbitmap_vector (file, \"antin\", \"\", antin, n_basic_blocks);\n-      dump_sbitmap_vector (file, \"antout\", \"\", antout, n_basic_blocks);\n+      dump_sbitmap_vector (file, \"antin\", \"\", antin, last_basic_block);\n+      dump_sbitmap_vector (file, \"antout\", \"\", antout, last_basic_block);\n     }\n #endif\n \n@@ -455,21 +455,21 @@ pre_edge_lcm (file, n_exprs, transp, avloc, antloc, kill, insert, delete)\n   later = sbitmap_vector_alloc (num_edges, n_exprs);\n \n   /* Allocate an extra element for the exit block in the laterin vector.  */\n-  laterin = sbitmap_vector_alloc (n_basic_blocks + 1, n_exprs);\n+  laterin = sbitmap_vector_alloc (last_basic_block + 1, n_exprs);\n   compute_laterin (edge_list, earliest, antloc, later, laterin);\n \n #ifdef LCM_DEBUG_INFO\n   if (file)\n     {\n-      dump_sbitmap_vector (file, \"laterin\", \"\", laterin, n_basic_blocks + 1);\n+      dump_sbitmap_vector (file, \"laterin\", \"\", laterin, last_basic_block + 1);\n       dump_sbitmap_vector (file, \"later\", \"\", later, num_edges);\n     }\n #endif\n \n   sbitmap_vector_free (earliest);\n \n   *insert = sbitmap_vector_alloc (num_edges, n_exprs);\n-  *delete = sbitmap_vector_alloc (n_basic_blocks, n_exprs);\n+  *delete = sbitmap_vector_alloc (last_basic_block, n_exprs);\n   compute_insert_delete (edge_list, antloc, later, laterin, *insert, *delete);\n \n   sbitmap_vector_free (laterin);\n@@ -480,7 +480,7 @@ pre_edge_lcm (file, n_exprs, transp, avloc, antloc, kill, insert, delete)\n     {\n       dump_sbitmap_vector (file, \"pre_insert_map\", \"\", *insert, num_edges);\n       dump_sbitmap_vector (file, \"pre_delete_map\", \"\", *delete,\n-\t\t\t   n_basic_blocks);\n+\t\t\t   last_basic_block);\n     }\n #endif\n \n@@ -505,7 +505,7 @@ compute_available (avloc, kill, avout, avin)\n     = (basic_block *) xmalloc (sizeof (basic_block) * n_basic_blocks);\n \n   /* We want a maximal solution.  */\n-  sbitmap_vector_ones (avout, n_basic_blocks);\n+  sbitmap_vector_ones (avout, last_basic_block);\n \n   /* Put every block on the worklist; this is necessary because of the\n      optimistic initialization of AVOUT above.  */\n@@ -689,10 +689,10 @@ compute_nearerout (edge_list, farthest, st_avloc, nearer, nearerout)\n   /* Computation of insertion and deletion points requires computing NEAREROUT\n      for the ENTRY block.  We allocated an extra entry in the NEAREROUT array\n      for just this purpose.  */\n-  sbitmap_ones (nearerout[n_basic_blocks]);\n+  sbitmap_ones (nearerout[last_basic_block]);\n   for (e = ENTRY_BLOCK_PTR->succ; e != NULL; e = e->succ_next)\n-    sbitmap_a_and_b (nearerout[n_basic_blocks],\n-\t\t     nearerout[n_basic_blocks],\n+    sbitmap_a_and_b (nearerout[last_basic_block],\n+\t\t     nearerout[last_basic_block],\n \t\t     nearer[(size_t) e->aux]);\n \n   clear_aux_for_edges ();\n@@ -717,7 +717,7 @@ compute_rev_insert_delete (edge_list, st_avloc, nearer, nearerout,\n     {\n       basic_block b = INDEX_EDGE_PRED_BB (edge_list, x);\n       if (b == ENTRY_BLOCK_PTR)\n-\tsbitmap_difference (insert[x], nearer[x], nearerout[n_basic_blocks]);\n+\tsbitmap_difference (insert[x], nearer[x], nearerout[last_basic_block]);\n       else\n \tsbitmap_difference (insert[x], nearer[x], nearerout[b->index]);\n     }\n@@ -749,15 +749,15 @@ pre_edge_rev_lcm (file, n_exprs, transp, st_avloc, st_antloc, kill,\n   edge_list = create_edge_list ();\n   num_edges = NUM_EDGES (edge_list);\n \n-  st_antin = (sbitmap *) sbitmap_vector_alloc (n_basic_blocks, n_exprs);\n-  st_antout = (sbitmap *) sbitmap_vector_alloc (n_basic_blocks, n_exprs);\n-  sbitmap_vector_zero (st_antin, n_basic_blocks);\n-  sbitmap_vector_zero (st_antout, n_basic_blocks);\n+  st_antin = (sbitmap *) sbitmap_vector_alloc (last_basic_block, n_exprs);\n+  st_antout = (sbitmap *) sbitmap_vector_alloc (last_basic_block, n_exprs);\n+  sbitmap_vector_zero (st_antin, last_basic_block);\n+  sbitmap_vector_zero (st_antout, last_basic_block);\n   compute_antinout_edge (st_antloc, transp, st_antin, st_antout);\n \n   /* Compute global anticipatability.  */\n-  st_avout = sbitmap_vector_alloc (n_basic_blocks, n_exprs);\n-  st_avin = sbitmap_vector_alloc (n_basic_blocks, n_exprs);\n+  st_avout = sbitmap_vector_alloc (last_basic_block, n_exprs);\n+  st_avin = sbitmap_vector_alloc (last_basic_block, n_exprs);\n   compute_available (st_avloc, kill, st_avout, st_avin);\n \n #ifdef LCM_DEBUG_INFO\n@@ -766,20 +766,20 @@ pre_edge_rev_lcm (file, n_exprs, transp, st_avloc, st_antloc, kill,\n       fprintf (file, \"Edge List:\\n\");\n       verify_edge_list (file, edge_list);\n       print_edge_list (file, edge_list);\n-      dump_sbitmap_vector (file, \"transp\", \"\", transp, n_basic_blocks);\n-      dump_sbitmap_vector (file, \"st_avloc\", \"\", st_avloc, n_basic_blocks);\n-      dump_sbitmap_vector (file, \"st_antloc\", \"\", st_antloc, n_basic_blocks);\n-      dump_sbitmap_vector (file, \"st_antin\", \"\", st_antin, n_basic_blocks);\n-      dump_sbitmap_vector (file, \"st_antout\", \"\", st_antout, n_basic_blocks);\n-      dump_sbitmap_vector (file, \"st_kill\", \"\", kill, n_basic_blocks);\n+      dump_sbitmap_vector (file, \"transp\", \"\", transp, last_basic_block);\n+      dump_sbitmap_vector (file, \"st_avloc\", \"\", st_avloc, last_basic_block);\n+      dump_sbitmap_vector (file, \"st_antloc\", \"\", st_antloc, last_basic_block);\n+      dump_sbitmap_vector (file, \"st_antin\", \"\", st_antin, last_basic_block);\n+      dump_sbitmap_vector (file, \"st_antout\", \"\", st_antout, last_basic_block);\n+      dump_sbitmap_vector (file, \"st_kill\", \"\", kill, last_basic_block);\n     }\n #endif\n \n #ifdef LCM_DEBUG_INFO\n   if (file)\n     {\n-      dump_sbitmap_vector (file, \"st_avout\", \"\", st_avout, n_basic_blocks);\n-      dump_sbitmap_vector (file, \"st_avin\", \"\", st_avin, n_basic_blocks);\n+      dump_sbitmap_vector (file, \"st_avout\", \"\", st_avout, last_basic_block);\n+      dump_sbitmap_vector (file, \"st_avin\", \"\", st_avin, last_basic_block);\n     }\n #endif\n \n@@ -802,22 +802,22 @@ pre_edge_rev_lcm (file, n_exprs, transp, st_avloc, st_antloc, kill,\n   nearer = sbitmap_vector_alloc (num_edges, n_exprs);\n \n   /* Allocate an extra element for the entry block.  */\n-  nearerout = sbitmap_vector_alloc (n_basic_blocks + 1, n_exprs);\n+  nearerout = sbitmap_vector_alloc (last_basic_block + 1, n_exprs);\n   compute_nearerout (edge_list, farthest, st_avloc, nearer, nearerout);\n \n #ifdef LCM_DEBUG_INFO\n   if (file)\n     {\n       dump_sbitmap_vector (file, \"nearerout\", \"\", nearerout,\n-\t\t\t   n_basic_blocks + 1);\n+\t\t\t   last_basic_block + 1);\n       dump_sbitmap_vector (file, \"nearer\", \"\", nearer, num_edges);\n     }\n #endif\n \n   sbitmap_vector_free (farthest);\n \n   *insert = sbitmap_vector_alloc (num_edges, n_exprs);\n-  *delete = sbitmap_vector_alloc (n_basic_blocks, n_exprs);\n+  *delete = sbitmap_vector_alloc (last_basic_block, n_exprs);\n   compute_rev_insert_delete (edge_list, st_avloc, nearer, nearerout,\n \t\t\t     *insert, *delete);\n \n@@ -829,7 +829,7 @@ pre_edge_rev_lcm (file, n_exprs, transp, st_avloc, st_antloc, kill,\n     {\n       dump_sbitmap_vector (file, \"pre_insert_map\", \"\", *insert, num_edges);\n       dump_sbitmap_vector (file, \"pre_delete_map\", \"\", *delete,\n-\t\t\t   n_basic_blocks);\n+\t\t\t   last_basic_block);\n     }\n #endif\n   return edge_list;\n@@ -1030,24 +1030,24 @@ optimize_mode_switching (file)\n \n   clear_bb_flags ();\n #ifdef NORMAL_MODE\n-  /* Increment n_basic_blocks before allocating bb_info.  */\n-  n_basic_blocks++;\n+  /* Increment last_basic_block before allocating bb_info.  */\n+  last_basic_block++;\n #endif\n \n   for (e = N_ENTITIES - 1, n_entities = 0; e >= 0; e--)\n     if (OPTIMIZE_MODE_SWITCHING (e))\n       {\n \t/* Create the list of segments within each basic block.  */\n \tbb_info[n_entities]\n-\t  = (struct bb_info *) xcalloc (n_basic_blocks, sizeof **bb_info);\n+\t  = (struct bb_info *) xcalloc (last_basic_block, sizeof **bb_info);\n \tentity_map[n_entities++] = e;\n \tif (num_modes[e] > max_num_modes)\n \t  max_num_modes = num_modes[e];\n       }\n \n #ifdef NORMAL_MODE\n   /* Decrement it back in case we return below.  */\n-  n_basic_blocks--;\n+  last_basic_block--;\n #endif\n \n   if (! n_entities)\n@@ -1059,20 +1059,20 @@ optimize_mode_switching (file)\n      EXIT_BLOCK isn't optimized away.  We do this by incrementing the\n      basic block count, growing the VARRAY of basic_block_info and\n      appending the EXIT_BLOCK_PTR to it.  */\n-  n_basic_blocks++;\n-  if (VARRAY_SIZE (basic_block_info) < n_basic_blocks)\n-    VARRAY_GROW (basic_block_info, n_basic_blocks);\n-  BASIC_BLOCK (n_basic_blocks - 1) = EXIT_BLOCK_PTR;\n-  EXIT_BLOCK_PTR->index = n_basic_blocks - 1;\n+  last_basic_block++;\n+  if (VARRAY_SIZE (basic_block_info) < last_basic_block)\n+    VARRAY_GROW (basic_block_info, last_basic_block);\n+  BASIC_BLOCK (last_basic_block - 1) = EXIT_BLOCK_PTR;\n+  EXIT_BLOCK_PTR->index = last_basic_block - 1;\n #endif\n \n   /* Create the bitmap vectors.  */\n \n-  antic = sbitmap_vector_alloc (n_basic_blocks, n_entities);\n-  transp = sbitmap_vector_alloc (n_basic_blocks, n_entities);\n-  comp = sbitmap_vector_alloc (n_basic_blocks, n_entities);\n+  antic = sbitmap_vector_alloc (last_basic_block, n_entities);\n+  transp = sbitmap_vector_alloc (last_basic_block, n_entities);\n+  comp = sbitmap_vector_alloc (last_basic_block, n_entities);\n \n-  sbitmap_vector_ones (transp, n_basic_blocks);\n+  sbitmap_vector_ones (transp, last_basic_block);\n \n   for (j = n_entities - 1; j >= 0; j--)\n     {\n@@ -1169,14 +1169,14 @@ optimize_mode_switching (file)\n #endif /* NORMAL_MODE */\n     }\n \n-  kill = sbitmap_vector_alloc (n_basic_blocks, n_entities);\n+  kill = sbitmap_vector_alloc (last_basic_block, n_entities);\n   for (i = 0; i < max_num_modes; i++)\n     {\n       int current_mode[N_ENTITIES];\n \n       /* Set the anticipatable and computing arrays.  */\n-      sbitmap_vector_zero (antic, n_basic_blocks);\n-      sbitmap_vector_zero (comp, n_basic_blocks);\n+      sbitmap_vector_zero (antic, last_basic_block);\n+      sbitmap_vector_zero (comp, last_basic_block);\n       for (j = n_entities - 1; j >= 0; j--)\n \t{\n \t  int m = current_mode[j] = MODE_PRIORITY_TO_MODE (entity_map[j], i);\n@@ -1301,10 +1301,10 @@ optimize_mode_switching (file)\n       int no_mode = num_modes[entity_map[j]];\n \n #ifdef NORMAL_MODE\n-      if (bb_info[j][n_basic_blocks].seginfo->mode != no_mode)\n+      if (bb_info[j][last_basic_block].seginfo->mode != no_mode)\n \t{\n \t  edge eg;\n-\t  struct seginfo *ptr = bb_info[j][n_basic_blocks].seginfo;\n+\t  struct seginfo *ptr = bb_info[j][last_basic_block].seginfo;\n \n \t  for (eg = EXIT_BLOCK_PTR->pred; eg; eg = eg->pred_next)\n \t    {"}, {"sha": "34045c4d7be55e31afee0e54dff3b698c8d390bd", "filename": "gcc/predict.c", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d55bc081750ac5dba90e6043071408ff6d7f29ba/gcc%2Fpredict.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d55bc081750ac5dba90e6043071408ff6d7f29ba/gcc%2Fpredict.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpredict.c?ref=d55bc081750ac5dba90e6043071408ff6d7f29ba", "patch": "@@ -412,8 +412,8 @@ estimate_probability (loops_info)\n   basic_block bb;\n   int i;\n \n-  dominators = sbitmap_vector_alloc (n_basic_blocks, n_basic_blocks);\n-  post_dominators = sbitmap_vector_alloc (n_basic_blocks, n_basic_blocks);\n+  dominators = sbitmap_vector_alloc (last_basic_block, last_basic_block);\n+  post_dominators = sbitmap_vector_alloc (last_basic_block, last_basic_block);\n   calculate_dominance_info (NULL, dominators, CDI_DOMINATORS);\n   calculate_dominance_info (NULL, post_dominators, CDI_POST_DOMINATORS);\n \n@@ -756,7 +756,7 @@ process_note_prediction (bb, heads, dominators, post_dominators, pred, flags)\n \n   /* Now find the edge that leads to our branch and aply the prediction.  */\n \n-  if (y == n_basic_blocks)\n+  if (y == last_basic_block)\n     return;\n   for (e = BASIC_BLOCK (y)->succ; e; e = e->succ_next)\n     if (e->dest->index >= 0\n@@ -841,15 +841,15 @@ note_prediction_to_br_prob ()\n   add_noreturn_fake_exit_edges ();\n   connect_infinite_loops_to_exit ();\n \n-  dominators = xmalloc (sizeof (int) * n_basic_blocks);\n-  memset (dominators, -1, sizeof (int) * n_basic_blocks);\n-  post_dominators = sbitmap_vector_alloc (n_basic_blocks, n_basic_blocks);\n+  dominators = xmalloc (sizeof (int) * last_basic_block);\n+  memset (dominators, -1, sizeof (int) * last_basic_block);\n+  post_dominators = sbitmap_vector_alloc (last_basic_block, last_basic_block);\n   calculate_dominance_info (NULL, post_dominators, CDI_POST_DOMINATORS);\n   calculate_dominance_info (dominators, NULL, CDI_DOMINATORS);\n \n-  heads = xmalloc (sizeof (int) * n_basic_blocks);\n-  memset (heads, -1, sizeof (int) * n_basic_blocks);\n-  heads[ENTRY_BLOCK_PTR->next_bb->index] = n_basic_blocks;\n+  heads = xmalloc (sizeof (int) * last_basic_block);\n+  memset (heads, -1, sizeof (int) * last_basic_block);\n+  heads[ENTRY_BLOCK_PTR->next_bb->index] = last_basic_block;\n \n   /* Process all prediction notes.  */\n "}, {"sha": "dcc75c0d5f8ee25bd7e08ee386eb26e2db965dfc", "filename": "gcc/profile.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d55bc081750ac5dba90e6043071408ff6d7f29ba/gcc%2Fprofile.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d55bc081750ac5dba90e6043071408ff6d7f29ba/gcc%2Fprofile.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fprofile.c?ref=d55bc081750ac5dba90e6043071408ff6d7f29ba", "patch": "@@ -73,11 +73,11 @@ struct bb_info\n /* Keep all basic block indexes nonnegative in the gcov output.  Index 0\n    is used for entry block, last block exit block.  */\n #define GCOV_INDEX_TO_BB(i)  ((i) == 0 ? ENTRY_BLOCK_PTR\t\t\\\n-\t\t\t      : (((i) == n_basic_blocks + 1)\t\t\\\n+\t\t\t      : (((i) == last_basic_block + 1)\t\t\\\n \t\t\t         ? EXIT_BLOCK_PTR : BASIC_BLOCK ((i)-1)))\n #define BB_TO_GCOV_INDEX(bb)  ((bb) == ENTRY_BLOCK_PTR ? 0\t\t\\\n \t\t\t       : ((bb) == EXIT_BLOCK_PTR\t\t\\\n-\t\t\t\t  ? n_basic_blocks + 1 : (bb)->index + 1))\n+\t\t\t\t  ? last_basic_block + 1 : (bb)->index + 1))\n \n /* Instantiate the profile info structure.  */\n "}, {"sha": "10287450e81d50371058f769c6d458ba084b063c", "filename": "gcc/recog.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d55bc081750ac5dba90e6043071408ff6d7f29ba/gcc%2Frecog.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d55bc081750ac5dba90e6043071408ff6d7f29ba/gcc%2Frecog.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frecog.c?ref=d55bc081750ac5dba90e6043071408ff6d7f29ba", "patch": "@@ -2729,7 +2729,7 @@ split_all_insns (upd_life)\n   int changed;\n   basic_block bb;\n \n-  blocks = sbitmap_alloc (n_basic_blocks);\n+  blocks = sbitmap_alloc (last_basic_block);\n   sbitmap_zero (blocks);\n   changed = 0;\n \n@@ -3013,7 +3013,7 @@ peephole2_optimize (dump_file)\n   live = INITIALIZE_REG_SET (rs_heads[i]);\n \n #ifdef HAVE_conditional_execution\n-  blocks = sbitmap_alloc (n_basic_blocks);\n+  blocks = sbitmap_alloc (last_basic_block);\n   sbitmap_zero (blocks);\n   changed = false;\n #else"}, {"sha": "ffe170e279575b025c667ed7932c3f79f8c07666", "filename": "gcc/regrename.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d55bc081750ac5dba90e6043071408ff6d7f29ba/gcc%2Fregrename.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d55bc081750ac5dba90e6043071408ff6d7f29ba/gcc%2Fregrename.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fregrename.c?ref=d55bc081750ac5dba90e6043071408ff6d7f29ba", "patch": "@@ -1729,7 +1729,7 @@ copyprop_hardreg_forward ()\n \n   need_refresh = false;\n \n-  all_vd = xmalloc (sizeof (struct value_data) * n_basic_blocks);\n+  all_vd = xmalloc (sizeof (struct value_data) * last_basic_block);\n \n   FOR_EACH_BB (bb)\n     {"}, {"sha": "3e60e43a4ec2ddb7b60e7c9febe9f6a39fe28ea6", "filename": "gcc/resource.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d55bc081750ac5dba90e6043071408ff6d7f29ba/gcc%2Fresource.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d55bc081750ac5dba90e6043071408ff6d7f29ba/gcc%2Fresource.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fresource.c?ref=d55bc081750ac5dba90e6043071408ff6d7f29ba", "patch": "@@ -1240,7 +1240,7 @@ init_resource_info (epilogue_insn)\n   /* Allocate and initialize the tables used by mark_target_live_regs.  */\n   target_hash_table = (struct target_info **)\n     xcalloc (TARGET_HASH_PRIME, sizeof (struct target_info *));\n-  bb_ticks = (int *) xcalloc (n_basic_blocks, sizeof (int));\n+  bb_ticks = (int *) xcalloc (last_basic_block, sizeof (int));\n }\n \f\n /* Free up the resources allcated to mark_target_live_regs ().  This"}, {"sha": "dc9c3041c8472cf1a3fb1e975bf3c1ee1e3307fe", "filename": "gcc/sched-rgn.c", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d55bc081750ac5dba90e6043071408ff6d7f29ba/gcc%2Fsched-rgn.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d55bc081750ac5dba90e6043071408ff6d7f29ba/gcc%2Fsched-rgn.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsched-rgn.c?ref=d55bc081750ac5dba90e6043071408ff6d7f29ba", "patch": "@@ -403,8 +403,8 @@ build_control_flow (edge_list)\n     }\n \n   /* ??? We can kill these soon.  */\n-  in_edges = (int *) xcalloc (n_basic_blocks, sizeof (int));\n-  out_edges = (int *) xcalloc (n_basic_blocks, sizeof (int));\n+  in_edges = (int *) xcalloc (last_basic_block, sizeof (int));\n+  out_edges = (int *) xcalloc (last_basic_block, sizeof (int));\n   edge_table = (haifa_edge *) xcalloc (num_edges, sizeof (haifa_edge));\n \n   nr_edges = 0;\n@@ -661,23 +661,23 @@ find_rgns (edge_list, dom)\n      STACK, SP and DFS_NR are only used during the first traversal.  */\n \n   /* Allocate and initialize variables for the first traversal.  */\n-  max_hdr = (int *) xmalloc (n_basic_blocks * sizeof (int));\n-  dfs_nr = (int *) xcalloc (n_basic_blocks, sizeof (int));\n+  max_hdr = (int *) xmalloc (last_basic_block * sizeof (int));\n+  dfs_nr = (int *) xcalloc (last_basic_block, sizeof (int));\n   stack = (int *) xmalloc (nr_edges * sizeof (int));\n \n-  inner = sbitmap_alloc (n_basic_blocks);\n+  inner = sbitmap_alloc (last_basic_block);\n   sbitmap_ones (inner);\n \n-  header = sbitmap_alloc (n_basic_blocks);\n+  header = sbitmap_alloc (last_basic_block);\n   sbitmap_zero (header);\n \n   passed = sbitmap_alloc (nr_edges);\n   sbitmap_zero (passed);\n \n-  in_queue = sbitmap_alloc (n_basic_blocks);\n+  in_queue = sbitmap_alloc (last_basic_block);\n   sbitmap_zero (in_queue);\n \n-  in_stack = sbitmap_alloc (n_basic_blocks);\n+  in_stack = sbitmap_alloc (last_basic_block);\n   sbitmap_zero (in_stack);\n \n   for (i = 0; i < n_basic_blocks; i++)\n@@ -1197,8 +1197,8 @@ compute_trg_info (trg)\n \t     add the TO block to the update block list.  This list can end\n \t     up with a lot of duplicates.  We need to weed them out to avoid\n \t     overrunning the end of the bblst_table.  */\n-\t  update_blocks = (char *) alloca (n_basic_blocks);\n-\t  memset (update_blocks, 0, n_basic_blocks);\n+\t  update_blocks = (char *) alloca (last_basic_block);\n+\t  memset (update_blocks, 0, last_basic_block);\n \n \t  update_idx = 0;\n \t  for (j = 0; j < el.nr_members; j++)\n@@ -2890,8 +2890,8 @@ init_regions ()\n   nr_regions = 0;\n   rgn_table = (region *) xmalloc ((n_basic_blocks) * sizeof (region));\n   rgn_bb_table = (int *) xmalloc ((n_basic_blocks) * sizeof (int));\n-  block_to_bb = (int *) xmalloc ((n_basic_blocks) * sizeof (int));\n-  containing_rgn = (int *) xmalloc ((n_basic_blocks) * sizeof (int));\n+  block_to_bb = (int *) xmalloc ((last_basic_block) * sizeof (int));\n+  containing_rgn = (int *) xmalloc ((last_basic_block) * sizeof (int));\n \n   /* Compute regions for scheduling.  */\n   if (reload_completed\n@@ -2912,7 +2912,7 @@ init_regions ()\n \t  sbitmap *dom;\n \t  struct edge_list *edge_list;\n \n-\t  dom = sbitmap_vector_alloc (n_basic_blocks, n_basic_blocks);\n+\t  dom = sbitmap_vector_alloc (last_basic_block, last_basic_block);\n \n \t  /* The scheduler runs after flow; therefore, we can't blindly call\n \t     back into find_basic_blocks since doing so could invalidate the\n@@ -2953,7 +2953,7 @@ init_regions ()\n \n   if (CHECK_DEAD_NOTES)\n     {\n-      blocks = sbitmap_alloc (n_basic_blocks);\n+      blocks = sbitmap_alloc (last_basic_block);\n       deaths_in_region = (int *) xmalloc (sizeof (int) * nr_regions);\n       /* Remove all death notes from the subroutine.  */\n       for (rgn = 0; rgn < nr_regions; rgn++)\n@@ -3021,12 +3021,12 @@ schedule_insns (dump_file)\n   compute_bb_for_insn (get_max_uid ());\n \n   any_large_regions = 0;\n-  large_region_blocks = sbitmap_alloc (n_basic_blocks);\n+  large_region_blocks = sbitmap_alloc (last_basic_block);\n   sbitmap_zero (large_region_blocks);\n   FOR_EACH_BB (bb)\n     SET_BIT (large_region_blocks, bb->index);\n \n-  blocks = sbitmap_alloc (n_basic_blocks);\n+  blocks = sbitmap_alloc (last_basic_block);\n   sbitmap_zero (blocks);\n \n   /* Update life information.  For regions consisting of multiple blocks"}, {"sha": "2549f67b4dc76a56bbb2bcfbb5ba09609afbe1a1", "filename": "gcc/ssa-ccp.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d55bc081750ac5dba90e6043071408ff6d7f29ba/gcc%2Fssa-ccp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d55bc081750ac5dba90e6043071408ff6d7f29ba/gcc%2Fssa-ccp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fssa-ccp.c?ref=d55bc081750ac5dba90e6043071408ff6d7f29ba", "patch": "@@ -1016,7 +1016,7 @@ ssa_const_prop ()\n   ssa_edges = sbitmap_alloc (VARRAY_SIZE (ssa_definition));\n   sbitmap_zero (ssa_edges);\n \n-  executable_blocks = sbitmap_alloc (n_basic_blocks);\n+  executable_blocks = sbitmap_alloc (last_basic_block);\n   sbitmap_zero (executable_blocks);\n \n   executable_edges = sbitmap_alloc (NUM_EDGES (edges));"}, {"sha": "148a3153d77943b9119d58856628d220e9928277", "filename": "gcc/ssa-dce.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d55bc081750ac5dba90e6043071408ff6d7f29ba/gcc%2Fssa-dce.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d55bc081750ac5dba90e6043071408ff6d7f29ba/gcc%2Fssa-dce.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fssa-dce.c?ref=d55bc081750ac5dba90e6043071408ff6d7f29ba", "patch": "@@ -506,20 +506,20 @@ ssa_eliminate_dead_code ()\n   mark_all_insn_unnecessary ();\n   VARRAY_RTX_INIT (unprocessed_instructions, 64,\n \t\t   \"unprocessed instructions\");\n-  cdbte = control_dependent_block_to_edge_map_create (n_basic_blocks);\n+  cdbte = control_dependent_block_to_edge_map_create (last_basic_block);\n \n   /* Prepare for use of BLOCK_NUM ().  */\n   connect_infinite_loops_to_exit ();\n    /* Be careful not to clear the added edges.  */\n   compute_bb_for_insn (max_insn_uid);\n \n   /* Compute control dependence.  */\n-  pdom = (int *) xmalloc (n_basic_blocks * sizeof (int));\n-  for (i = 0; i < n_basic_blocks; ++i)\n+  pdom = (int *) xmalloc (last_basic_block * sizeof (int));\n+  for (i = 0; i < last_basic_block; ++i)\n     pdom[i] = INVALID_BLOCK;\n   calculate_dominance_info (pdom, NULL, CDI_POST_DOMINATORS);\n   /* Assume there is a path from each node to the exit block.  */\n-  for (i = 0; i < n_basic_blocks; ++i)\n+  for (i = 0; i < last_basic_block; ++i)\n     if (pdom[i] == INVALID_BLOCK)\n       pdom[i] = EXIT_BLOCK;\n   el = create_edge_list ();"}, {"sha": "835bf55ce0c132a0588979895dd315130e385eb2", "filename": "gcc/ssa.c", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d55bc081750ac5dba90e6043071408ff6d7f29ba/gcc%2Fssa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d55bc081750ac5dba90e6043071408ff6d7f29ba/gcc%2Fssa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fssa.c?ref=d55bc081750ac5dba90e6043071408ff6d7f29ba", "patch": "@@ -559,7 +559,7 @@ compute_dominance_frontiers (frontiers, idom)\n      sbitmap *frontiers;\n      int *idom;\n {\n-  sbitmap done = sbitmap_alloc (n_basic_blocks);\n+  sbitmap done = sbitmap_alloc (last_basic_block);\n   sbitmap_zero (done);\n \n   compute_dominance_frontiers_1 (frontiers, idom, 0, done);\n@@ -585,7 +585,7 @@ compute_iterated_dominance_frontiers (idfs, frontiers, evals, nregs)\n   sbitmap worklist;\n   int reg, passes = 0;\n \n-  worklist = sbitmap_alloc (n_basic_blocks);\n+  worklist = sbitmap_alloc (last_basic_block);\n \n   for (reg = 0; reg < nregs; ++reg)\n     {\n@@ -1150,8 +1150,8 @@ convert_to_ssa ()\n      dead code.  We'll let the SSA optimizers do that.  */\n   life_analysis (get_insns (), NULL, 0);\n \n-  idom = (int *) alloca (n_basic_blocks * sizeof (int));\n-  memset ((void *) idom, -1, (size_t) n_basic_blocks * sizeof (int));\n+  idom = (int *) alloca (last_basic_block * sizeof (int));\n+  memset ((void *) idom, -1, (size_t) last_basic_block * sizeof (int));\n   calculate_dominance_info (idom, NULL, CDI_DOMINATORS);\n \n   if (rtl_dump_file)\n@@ -1164,26 +1164,26 @@ convert_to_ssa ()\n \n   /* Compute dominance frontiers.  */\n \n-  dfs = sbitmap_vector_alloc (n_basic_blocks, n_basic_blocks);\n+  dfs = sbitmap_vector_alloc (last_basic_block, last_basic_block);\n   compute_dominance_frontiers (dfs, idom);\n \n   if (rtl_dump_file)\n     {\n       dump_sbitmap_vector (rtl_dump_file, \";; Dominance Frontiers:\",\n-\t\t\t   \"; Basic Block\", dfs, n_basic_blocks);\n+\t\t\t   \"; Basic Block\", dfs, last_basic_block);\n       fflush (rtl_dump_file);\n     }\n \n   /* Compute register evaluations.  */\n \n   ssa_max_reg_num = max_reg_num ();\n   nregs = ssa_max_reg_num;\n-  evals = sbitmap_vector_alloc (nregs, n_basic_blocks);\n+  evals = sbitmap_vector_alloc (nregs, last_basic_block);\n   find_evaluations (evals, nregs);\n \n   /* Compute the iterated dominance frontier for each register.  */\n \n-  idfs = sbitmap_vector_alloc (nregs, n_basic_blocks);\n+  idfs = sbitmap_vector_alloc (nregs, last_basic_block);\n   compute_iterated_dominance_frontiers (idfs, dfs, evals, nregs);\n \n   if (rtl_dump_file)"}]}