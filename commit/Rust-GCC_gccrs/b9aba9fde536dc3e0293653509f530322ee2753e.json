{"sha": "b9aba9fde536dc3e0293653509f530322ee2753e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjlhYmE5ZmRlNTM2ZGMzZTAyOTM2NTM1MDlmNTMwMzIyZWUyNzUzZQ==", "commit": {"author": {"name": "Jan Hubicka", "email": "hubicka@ucw.cz", "date": "2018-02-12T09:48:06Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2018-02-12T09:48:06Z"}, "message": "re PR middle-end/83665 (Big code size regression and some code quality improvement at Jan 2 2018)\n\n\n\tPR middle-end/83665\n\t* params.def (inline-min-speedup): Increase from 8 to 15.\n\t(max-inline-insns-auto): Decrease from 40 to 30.\n\t* ipa-split.c (consider_split): Add some buffer for function to\n\tbe considered inlining candidate.\n\t* invoke.texi (max-inline-insns-auto, inline-min-speedup): UPdate\n\tdefault values.\n\nFrom-SVN: r257582", "tree": {"sha": "391970e14e69d07fc50d2a3537089c09d6f7aff3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/391970e14e69d07fc50d2a3537089c09d6f7aff3"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b9aba9fde536dc3e0293653509f530322ee2753e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b9aba9fde536dc3e0293653509f530322ee2753e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b9aba9fde536dc3e0293653509f530322ee2753e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b9aba9fde536dc3e0293653509f530322ee2753e/comments", "author": null, "committer": null, "parents": [{"sha": "85c5e2f576fd41e1ab5620cde3c63b3ca6673bea", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/85c5e2f576fd41e1ab5620cde3c63b3ca6673bea", "html_url": "https://github.com/Rust-GCC/gccrs/commit/85c5e2f576fd41e1ab5620cde3c63b3ca6673bea"}], "stats": {"total": 28, "additions": 21, "deletions": 7}, "files": [{"sha": "6faa322572f134d43634dae5d52fcdc0595e9de3", "filename": "gcc/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b9aba9fde536dc3e0293653509f530322ee2753e/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b9aba9fde536dc3e0293653509f530322ee2753e/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=b9aba9fde536dc3e0293653509f530322ee2753e", "patch": "@@ -1,3 +1,13 @@\n+2018-02-08  Jan Hubicka  <hubicka@ucw.cz>\n+\n+\tPR middle-end/83665\n+\t* params.def (inline-min-speedup): Increase from 8 to 15.\n+\t(max-inline-insns-auto): Decrease from 40 to 30.\n+\t* ipa-split.c (consider_split): Add some buffer for function to\n+\tbe considered inlining candidate.\n+\t* invoke.texi (max-inline-insns-auto, inline-min-speedup): UPdate\n+\tdefault values.\n+\n 2018-02-12  Richard Biener  <rguenther@suse.de>\n \n \tPR tree-optimization/84037"}, {"sha": "9db9d083a47543502e0ce5a4013ebe550d84e80b", "filename": "gcc/doc/invoke.texi", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b9aba9fde536dc3e0293653509f530322ee2753e/gcc%2Fdoc%2Finvoke.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b9aba9fde536dc3e0293653509f530322ee2753e/gcc%2Fdoc%2Finvoke.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Finvoke.texi?ref=b9aba9fde536dc3e0293653509f530322ee2753e", "patch": "@@ -10131,13 +10131,14 @@ a lot of functions that would otherwise not be considered for inlining\n by the compiler are investigated.  To those functions, a different\n (more restrictive) limit compared to functions declared inline can\n be applied.\n-The default value is 40.\n+The default value is 30.\n \n @item inline-min-speedup\n When estimated performance improvement of caller + callee runtime exceeds this\n threshold (in percent), the function can be inlined regardless of the limit on\n @option{--param max-inline-insns-single} and @option{--param\n max-inline-insns-auto}.\n+The default value is 15.\n \n @item large-function-insns\n The limit specifying really large functions.  For functions larger than this"}, {"sha": "b03ae02924aab68df6bac2a921e5ddb066698dfb", "filename": "gcc/ipa-split.c", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b9aba9fde536dc3e0293653509f530322ee2753e/gcc%2Fipa-split.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b9aba9fde536dc3e0293653509f530322ee2753e/gcc%2Fipa-split.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-split.c?ref=b9aba9fde536dc3e0293653509f530322ee2753e", "patch": "@@ -558,10 +558,13 @@ consider_split (struct split_point *current, bitmap non_ssa_vars,\n \t\t \"  Refused: split size is smaller than call overhead\\n\");\n       return;\n     }\n+  /* FIXME: The logic here is not very precise, because inliner does use\n+     inline predicates to reduce function body size.  We add 10 to anticipate\n+     that.  Next stage1 we should try to be more meaningful here.  */\n   if (current->header_size + call_overhead\n       >= (unsigned int)(DECL_DECLARED_INLINE_P (current_function_decl)\n \t\t\t? MAX_INLINE_INSNS_SINGLE\n-\t\t\t: MAX_INLINE_INSNS_AUTO))\n+\t\t\t: MAX_INLINE_INSNS_AUTO) + 10)\n     {\n       if (dump_file && (dump_flags & TDF_DETAILS))\n \tfprintf (dump_file,\n@@ -574,7 +577,7 @@ consider_split (struct split_point *current, bitmap non_ssa_vars,\n      Limit this duplication.  This is consistent with limit in tree-sra.c  \n      FIXME: with LTO we ought to be able to do better!  */\n   if (DECL_ONE_ONLY (current_function_decl)\n-      && current->split_size >= (unsigned int) MAX_INLINE_INSNS_AUTO)\n+      && current->split_size >= (unsigned int) MAX_INLINE_INSNS_AUTO + 10)\n     {\n       if (dump_file && (dump_flags & TDF_DETAILS))\n \tfprintf (dump_file,"}, {"sha": "e3336793b230f112b69c787a0d6748ffcbbc212e", "filename": "gcc/params.def", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b9aba9fde536dc3e0293653509f530322ee2753e/gcc%2Fparams.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b9aba9fde536dc3e0293653509f530322ee2753e/gcc%2Fparams.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fparams.def?ref=b9aba9fde536dc3e0293653509f530322ee2753e", "patch": "@@ -52,13 +52,13 @@ DEFPARAM (PARAM_PREDICTABLE_BRANCH_OUTCOME,\n DEFPARAM (PARAM_INLINE_MIN_SPEEDUP,\n \t  \"inline-min-speedup\",\n \t  \"The minimal estimated speedup allowing inliner to ignore inline-insns-single and inline-insns-auto.\",\n-\t  8, 0, 0)\n+\t  15, 0, 0)\n \n /* The single function inlining limit. This is the maximum size\n    of a function counted in internal gcc instructions (not in\n    real machine instructions) that is eligible for inlining\n    by the tree inliner.\n-   The default value is 450.\n+   The default value is 400.\n    Only functions marked inline (or methods defined in the class\n    definition for C++) are affected by this.\n    There are more restrictions to inlining: If inlined functions\n@@ -77,11 +77,11 @@ DEFPARAM (PARAM_MAX_INLINE_INSNS_SINGLE,\n    that is applied to functions marked inlined (or defined in the\n    class declaration in C++) given by the \"max-inline-insns-single\"\n    parameter.\n-   The default value is 40.  */\n+   The default value is 30.  */\n DEFPARAM (PARAM_MAX_INLINE_INSNS_AUTO,\n \t  \"max-inline-insns-auto\",\n \t  \"The maximum number of instructions when automatically inlining.\",\n-\t  40, 0, 0)\n+\t  30, 0, 0)\n \n DEFPARAM (PARAM_MAX_INLINE_INSNS_RECURSIVE,\n \t  \"max-inline-insns-recursive\","}]}