{"sha": "30b2f58b544acfa8a90cc4f0cf5d6ae7e0956f37", "node_id": "C_kwDOANBUbNoAKDMwYjJmNThiNTQ0YWNmYThhOTBjYzRmMGNmNWQ2YWU3ZTA5NTZmMzc", "commit": {"author": {"name": "Faisal Abbas", "email": "90.abbasfaisal@gmail.com", "date": "2022-07-30T18:12:17Z"}, "committer": {"name": "Philip Herron", "email": "philip.herron@embecosm.com", "date": "2022-08-25T11:40:26Z"}, "message": "rust-constexpr.cc: port MEF_REF and INDIRECT_REF cases to eval_constant_expression().", "tree": {"sha": "b0b42c82afbf41ea56ea888997c1e7b2421099ed", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b0b42c82afbf41ea56ea888997c1e7b2421099ed"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/30b2f58b544acfa8a90cc4f0cf5d6ae7e0956f37", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/30b2f58b544acfa8a90cc4f0cf5d6ae7e0956f37", "html_url": "https://github.com/Rust-GCC/gccrs/commit/30b2f58b544acfa8a90cc4f0cf5d6ae7e0956f37", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/30b2f58b544acfa8a90cc4f0cf5d6ae7e0956f37/comments", "author": {"login": "abbasfaisal", "id": 9428333, "node_id": "MDQ6VXNlcjk0MjgzMzM=", "avatar_url": "https://avatars.githubusercontent.com/u/9428333?v=4", "gravatar_id": "", "url": "https://api.github.com/users/abbasfaisal", "html_url": "https://github.com/abbasfaisal", "followers_url": "https://api.github.com/users/abbasfaisal/followers", "following_url": "https://api.github.com/users/abbasfaisal/following{/other_user}", "gists_url": "https://api.github.com/users/abbasfaisal/gists{/gist_id}", "starred_url": "https://api.github.com/users/abbasfaisal/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/abbasfaisal/subscriptions", "organizations_url": "https://api.github.com/users/abbasfaisal/orgs", "repos_url": "https://api.github.com/users/abbasfaisal/repos", "events_url": "https://api.github.com/users/abbasfaisal/events{/privacy}", "received_events_url": "https://api.github.com/users/abbasfaisal/received_events", "type": "User", "site_admin": false}, "committer": {"login": "philberty", "id": 84585, "node_id": "MDQ6VXNlcjg0NTg1", "avatar_url": "https://avatars.githubusercontent.com/u/84585?v=4", "gravatar_id": "", "url": "https://api.github.com/users/philberty", "html_url": "https://github.com/philberty", "followers_url": "https://api.github.com/users/philberty/followers", "following_url": "https://api.github.com/users/philberty/following{/other_user}", "gists_url": "https://api.github.com/users/philberty/gists{/gist_id}", "starred_url": "https://api.github.com/users/philberty/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/philberty/subscriptions", "organizations_url": "https://api.github.com/users/philberty/orgs", "repos_url": "https://api.github.com/users/philberty/repos", "events_url": "https://api.github.com/users/philberty/events{/privacy}", "received_events_url": "https://api.github.com/users/philberty/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "266891d17c751d104d8c75e0258cf1b462756ad9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/266891d17c751d104d8c75e0258cf1b462756ad9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/266891d17c751d104d8c75e0258cf1b462756ad9"}], "stats": {"total": 457, "additions": 331, "deletions": 126}, "files": [{"sha": "b8f62e38525b2cf7ad15e02315c3214922eb1ae8", "filename": "gcc/rust/backend/rust-constexpr.cc", "status": "modified", "additions": 331, "deletions": 126, "changes": 457, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/30b2f58b544acfa8a90cc4f0cf5d6ae7e0956f37/gcc%2Frust%2Fbackend%2Frust-constexpr.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/30b2f58b544acfa8a90cc4f0cf5d6ae7e0956f37/gcc%2Frust%2Fbackend%2Frust-constexpr.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-constexpr.cc?ref=30b2f58b544acfa8a90cc4f0cf5d6ae7e0956f37", "patch": "@@ -586,6 +586,329 @@ same_type_ignoring_tlq_and_bounds_p (tree type1, tree type2)\n   return same_type_ignoring_top_level_qualifiers_p (type1, type2);\n }\n \n+// forked from gcc/cp/constexpr.cc cxx_union_active_member\n+\n+/* Try to determine the currently active union member for an expression\n+   with UNION_TYPE.  If it can be determined, return the FIELD_DECL,\n+   otherwise return NULL_TREE.  */\n+\n+static tree\n+union_active_member (const constexpr_ctx *ctx, tree t)\n+{\n+  constexpr_ctx new_ctx = *ctx;\n+  new_ctx.quiet = true;\n+  bool non_constant_p = false, overflow_p = false;\n+  tree ctor = eval_constant_expression (&new_ctx, t, false, &non_constant_p,\n+\t\t\t\t\t&overflow_p);\n+  if (TREE_CODE (ctor) == CONSTRUCTOR && CONSTRUCTOR_NELTS (ctor) == 1\n+      && CONSTRUCTOR_ELT (ctor, 0)->index\n+      && TREE_CODE (CONSTRUCTOR_ELT (ctor, 0)->index) == FIELD_DECL)\n+    return CONSTRUCTOR_ELT (ctor, 0)->index;\n+  return NULL_TREE;\n+}\n+\n+// forked from gcc/cp/constexpr.cc cxx_fold_indirect_ref_1\n+\n+static tree\n+fold_indirect_ref_1 (const constexpr_ctx *ctx, location_t loc, tree type,\n+\t\t     tree op, unsigned HOST_WIDE_INT off, bool *empty_base)\n+{\n+  tree optype = TREE_TYPE (op);\n+  unsigned HOST_WIDE_INT const_nunits;\n+  if (off == 0 && similar_type_p (optype, type))\n+    return op;\n+  else if (TREE_CODE (optype) == COMPLEX_TYPE\n+\t   && similar_type_p (type, TREE_TYPE (optype)))\n+    {\n+      /* *(foo *)&complexfoo => __real__ complexfoo */\n+      if (off == 0)\n+\treturn build1_loc (loc, REALPART_EXPR, type, op);\n+      /* ((foo*)&complexfoo)[1] => __imag__ complexfoo */\n+      else if (tree_to_uhwi (TYPE_SIZE_UNIT (type)) == off)\n+\treturn build1_loc (loc, IMAGPART_EXPR, type, op);\n+    }\n+  /* ((foo*)&vectorfoo)[x] => BIT_FIELD_REF<vectorfoo,...> */\n+  else if (VECTOR_TYPE_P (optype) && similar_type_p (type, TREE_TYPE (optype))\n+\t   && TYPE_VECTOR_SUBPARTS (optype).is_constant (&const_nunits))\n+    {\n+      unsigned HOST_WIDE_INT part_width = tree_to_uhwi (TYPE_SIZE_UNIT (type));\n+      unsigned HOST_WIDE_INT max_offset = part_width * const_nunits;\n+      if (off < max_offset && off % part_width == 0)\n+\t{\n+\t  tree index = bitsize_int (off * BITS_PER_UNIT);\n+\t  return build3_loc (loc, BIT_FIELD_REF, type, op, TYPE_SIZE (type),\n+\t\t\t     index);\n+\t}\n+    }\n+  /* ((foo *)&fooarray)[x] => fooarray[x] */\n+  else if (TREE_CODE (optype) == ARRAY_TYPE\n+\t   && tree_fits_uhwi_p (TYPE_SIZE_UNIT (TREE_TYPE (optype)))\n+\t   && !integer_zerop (TYPE_SIZE_UNIT (TREE_TYPE (optype))))\n+    {\n+      tree type_domain = TYPE_DOMAIN (optype);\n+      tree min_val = size_zero_node;\n+      if (type_domain && TYPE_MIN_VALUE (type_domain))\n+\tmin_val = TYPE_MIN_VALUE (type_domain);\n+      unsigned HOST_WIDE_INT el_sz\n+\t= tree_to_uhwi (TYPE_SIZE_UNIT (TREE_TYPE (optype)));\n+      unsigned HOST_WIDE_INT idx = off / el_sz;\n+      unsigned HOST_WIDE_INT rem = off % el_sz;\n+      if (tree_fits_uhwi_p (min_val))\n+\t{\n+\t  tree index = size_int (idx + tree_to_uhwi (min_val));\n+\t  op = build4_loc (loc, ARRAY_REF, TREE_TYPE (optype), op, index,\n+\t\t\t   NULL_TREE, NULL_TREE);\n+\t  return fold_indirect_ref_1 (ctx, loc, type, op, rem, empty_base);\n+\t}\n+    }\n+  /* ((foo *)&struct_with_foo_field)[x] => COMPONENT_REF */\n+  else if (TREE_CODE (optype) == RECORD_TYPE\n+\t   || TREE_CODE (optype) == UNION_TYPE)\n+    {\n+      if (TREE_CODE (optype) == UNION_TYPE)\n+\t/* For unions prefer the currently active member.  */\n+\tif (tree field = union_active_member (ctx, op))\n+\t  {\n+\t    unsigned HOST_WIDE_INT el_sz\n+\t      = tree_to_uhwi (TYPE_SIZE_UNIT (TREE_TYPE (field)));\n+\t    if (off < el_sz)\n+\t      {\n+\t\ttree cop = build3 (COMPONENT_REF, TREE_TYPE (field), op, field,\n+\t\t\t\t   NULL_TREE);\n+\t\tif (tree ret = fold_indirect_ref_1 (ctx, loc, type, cop, off,\n+\t\t\t\t\t\t    empty_base))\n+\t\t  return ret;\n+\t      }\n+\t  }\n+      for (tree field = TYPE_FIELDS (optype); field; field = DECL_CHAIN (field))\n+\tif (TREE_CODE (field) == FIELD_DECL\n+\t    && TREE_TYPE (field) != error_mark_node\n+\t    && tree_fits_uhwi_p (TYPE_SIZE_UNIT (TREE_TYPE (field))))\n+\t  {\n+\t    tree pos = byte_position (field);\n+\t    if (!tree_fits_uhwi_p (pos))\n+\t      continue;\n+\t    unsigned HOST_WIDE_INT upos = tree_to_uhwi (pos);\n+\t    unsigned HOST_WIDE_INT el_sz\n+\t      = tree_to_uhwi (TYPE_SIZE_UNIT (TREE_TYPE (field)));\n+\t    if (upos <= off && off < upos + el_sz)\n+\t      {\n+\t\ttree cop = build3 (COMPONENT_REF, TREE_TYPE (field), op, field,\n+\t\t\t\t   NULL_TREE);\n+\t\tif (tree ret = fold_indirect_ref_1 (ctx, loc, type, cop,\n+\t\t\t\t\t\t    off - upos, empty_base))\n+\t\t  return ret;\n+\t      }\n+\t  }\n+      /* Also handle conversion to an empty base class, which\n+\t is represented with a NOP_EXPR.  */\n+      if (is_empty_class (type) && CLASS_TYPE_P (optype))\n+\t{\n+\t  *empty_base = true;\n+\t  return op;\n+\t}\n+    }\n+\n+  return NULL_TREE;\n+}\n+\n+// forked from gcc/cp/constexpr.cc cxx_fold_indirect_ref\n+\n+/* A less strict version of fold_indirect_ref_1, which requires cv-quals to\n+   match.  We want to be less strict for simple *& folding; if we have a\n+   non-const temporary that we access through a const pointer, that should\n+   work.  We handle this here rather than change fold_indirect_ref_1\n+   because we're dealing with things like ADDR_EXPR of INTEGER_CST which\n+   don't really make sense outside of constant expression evaluation.  Also\n+   we want to allow folding to COMPONENT_REF, which could cause trouble\n+   with TBAA in fold_indirect_ref_1.  */\n+\n+static tree\n+rs_fold_indirect_ref (const constexpr_ctx *ctx, location_t loc, tree type,\n+\t\t      tree op0, bool *empty_base)\n+{\n+  tree sub = op0;\n+  tree subtype;\n+  poly_uint64 const_op01;\n+\n+  /* STRIP_NOPS, but stop if REINTERPRET_CAST_P.  */\n+  while (CONVERT_EXPR_P (sub) || TREE_CODE (sub) == NON_LVALUE_EXPR\n+\t || TREE_CODE (sub) == VIEW_CONVERT_EXPR)\n+    {\n+      if (TREE_CODE (sub) == NOP_EXPR && REINTERPRET_CAST_P (sub))\n+\treturn NULL_TREE;\n+      sub = TREE_OPERAND (sub, 0);\n+    }\n+\n+  subtype = TREE_TYPE (sub);\n+  if (!INDIRECT_TYPE_P (subtype))\n+    return NULL_TREE;\n+\n+  /* Canonicalizes the given OBJ/OFF pair by iteratively absorbing\n+     the innermost component into the offset until it would make the\n+     offset positive, so that cxx_fold_indirect_ref_1 can identify\n+     more folding opportunities.  */\n+  auto canonicalize_obj_off = [] (tree &obj, tree &off) {\n+    while (TREE_CODE (obj) == COMPONENT_REF\n+\t   && (tree_int_cst_sign_bit (off) || integer_zerop (off)))\n+      {\n+\ttree field = TREE_OPERAND (obj, 1);\n+\ttree pos = byte_position (field);\n+\tif (integer_zerop (off) && integer_nonzerop (pos))\n+\t  /* If the offset is already 0, keep going as long as the\n+\t     component is at position 0.  */\n+\t  break;\n+\toff = int_const_binop (PLUS_EXPR, off, pos);\n+\tobj = TREE_OPERAND (obj, 0);\n+      }\n+  };\n+\n+  if (TREE_CODE (sub) == ADDR_EXPR)\n+    {\n+      tree op = TREE_OPERAND (sub, 0);\n+      tree optype = TREE_TYPE (op);\n+\n+      /* *&CONST_DECL -> to the value of the const decl.  */\n+      if (TREE_CODE (op) == CONST_DECL)\n+\treturn DECL_INITIAL (op);\n+      /* *&p => p;  make sure to handle *&\"str\"[cst] here.  */\n+      if (similar_type_p (optype, type))\n+\t{\n+\t  tree fop = fold_read_from_constant_string (op);\n+\t  if (fop)\n+\t    return fop;\n+\t  else\n+\t    return op;\n+\t}\n+      else\n+\t{\n+\t  tree off = integer_zero_node;\n+\t  canonicalize_obj_off (op, off);\n+\t  gcc_assert (integer_zerop (off));\n+\t  return fold_indirect_ref_1 (ctx, loc, type, op, 0, empty_base);\n+\t}\n+    }\n+  else if (TREE_CODE (sub) == POINTER_PLUS_EXPR\n+\t   && tree_fits_uhwi_p (TREE_OPERAND (sub, 1)))\n+    {\n+      tree op00 = TREE_OPERAND (sub, 0);\n+      tree off = TREE_OPERAND (sub, 1);\n+\n+      STRIP_NOPS (op00);\n+      if (TREE_CODE (op00) == ADDR_EXPR)\n+\t{\n+\t  tree obj = TREE_OPERAND (op00, 0);\n+\t  canonicalize_obj_off (obj, off);\n+\t  return fold_indirect_ref_1 (ctx, loc, type, obj, tree_to_uhwi (off),\n+\t\t\t\t      empty_base);\n+\t}\n+    }\n+  /* *(foo *)fooarrptr => (*fooarrptr)[0] */\n+  else if (TREE_CODE (TREE_TYPE (subtype)) == ARRAY_TYPE\n+\t   && similar_type_p (type, TREE_TYPE (TREE_TYPE (subtype))))\n+    {\n+      tree type_domain;\n+      tree min_val = size_zero_node;\n+      tree newsub\n+\t= rs_fold_indirect_ref (ctx, loc, TREE_TYPE (subtype), sub, NULL);\n+      if (newsub)\n+\tsub = newsub;\n+      else\n+\tsub = build1_loc (loc, INDIRECT_REF, TREE_TYPE (subtype), sub);\n+      type_domain = TYPE_DOMAIN (TREE_TYPE (sub));\n+      if (type_domain && TYPE_MIN_VALUE (type_domain))\n+\tmin_val = TYPE_MIN_VALUE (type_domain);\n+      return build4_loc (loc, ARRAY_REF, type, sub, min_val, NULL_TREE,\n+\t\t\t NULL_TREE);\n+    }\n+\n+  return NULL_TREE;\n+}\n+\n+static tree\n+rs_eval_indirect_ref (const constexpr_ctx *ctx, tree t, bool lval,\n+\t\t      bool *non_constant_p, bool *overflow_p)\n+{\n+  tree orig_op0 = TREE_OPERAND (t, 0);\n+  bool empty_base = false;\n+\n+  /* We can handle a MEM_REF like an INDIRECT_REF, if MEM_REF's second\n+     operand is an integer-zero.  Otherwise reject the MEM_REF for now.  */\n+\n+  if (TREE_CODE (t) == MEM_REF\n+      && (!TREE_OPERAND (t, 1) || !integer_zerop (TREE_OPERAND (t, 1))))\n+    {\n+      gcc_assert (ctx->quiet);\n+      *non_constant_p = true;\n+      return t;\n+    }\n+\n+  /* First try to simplify it directly.  */\n+  tree r = rs_fold_indirect_ref (ctx, EXPR_LOCATION (t), TREE_TYPE (t),\n+\t\t\t\t orig_op0, &empty_base);\n+  if (!r)\n+    {\n+      /* If that didn't work, evaluate the operand first.  */\n+      tree op0\n+\t= eval_constant_expression (ctx, orig_op0,\n+\t\t\t\t    /*lval*/ false, non_constant_p, overflow_p);\n+      /* Don't VERIFY_CONSTANT here.  */\n+      if (*non_constant_p)\n+\treturn t;\n+\n+      if (!lval && integer_zerop (op0))\n+\t{\n+\t  if (!ctx->quiet)\n+\t    error (\"dereferencing a null pointer\");\n+\t  *non_constant_p = true;\n+\t  return t;\n+\t}\n+\n+      r = rs_fold_indirect_ref (ctx, EXPR_LOCATION (t), TREE_TYPE (t), op0,\n+\t\t\t\t&empty_base);\n+      if (r == NULL_TREE)\n+\t{\n+\t  /* We couldn't fold to a constant value.  Make sure it's not\n+\t     something we should have been able to fold.  */\n+\t  tree sub = op0;\n+\t  STRIP_NOPS (sub);\n+\t  if (TREE_CODE (sub) == ADDR_EXPR)\n+\t    {\n+\t      gcc_assert (\n+\t\t!similar_type_p (TREE_TYPE (TREE_TYPE (sub)), TREE_TYPE (t)));\n+\t      /* DR 1188 says we don't have to deal with this.  */\n+\t      if (!ctx->quiet)\n+\t\terror_at (rs_expr_loc_or_input_loc (t),\n+\t\t\t  \"accessing value of %qE through a %qT glvalue in a \"\n+\t\t\t  \"constant expression\",\n+\t\t\t  build_fold_indirect_ref (sub), TREE_TYPE (t));\n+\t      *non_constant_p = true;\n+\t      return t;\n+\t    }\n+\n+\t  if (lval && op0 != orig_op0)\n+\t    return build1 (INDIRECT_REF, TREE_TYPE (t), op0);\n+\t  if (!lval)\n+\t    VERIFY_CONSTANT (t);\n+\t  return t;\n+\t}\n+    }\n+\n+  r = eval_constant_expression (ctx, r, lval, non_constant_p, overflow_p);\n+  if (*non_constant_p)\n+    return t;\n+\n+  /* If we're pulling out the value of an empty base, just return an empty\n+     CONSTRUCTOR.  */\n+  if (empty_base && !lval)\n+    {\n+      r = build_constructor (TREE_TYPE (t), NULL);\n+      TREE_CONSTANT (r) = true;\n+    }\n+\n+  return r;\n+}\n+\n static tree\n eval_constant_expression (const constexpr_ctx *ctx, tree t, bool lval,\n \t\t\t  bool *non_constant_p, bool *overflow_p,\n@@ -723,6 +1046,14 @@ eval_constant_expression (const constexpr_ctx *ctx, tree t, bool lval,\n \t}\n       break;\n \n+    /* These differ from cxx_eval_unary_expression in that this doesn't\n+\t check for a constant operand or result; an address can be\n+\t constant without its operand being, and vice versa.  */\n+    case MEM_REF:\n+    case INDIRECT_REF:\n+      r = rs_eval_indirect_ref (ctx, t, lval, non_constant_p, overflow_p);\n+      break;\n+\n     case NOP_EXPR:\n       if (REINTERPRET_CAST_P (t))\n \t{\n@@ -3196,132 +3527,6 @@ eval_unary_expression (const constexpr_ctx *ctx, tree t, bool /*lval*/,\n   return r;\n }\n \n-// forked from gcc/cp/constexpr.cc cxx_union_active_member\n-\n-/* Try to determine the currently active union member for an expression\n-   with UNION_TYPE.  If it can be determined, return the FIELD_DECL,\n-   otherwise return NULL_TREE.  */\n-\n-static tree\n-union_active_member (const constexpr_ctx *ctx, tree t)\n-{\n-  constexpr_ctx new_ctx = *ctx;\n-  new_ctx.quiet = true;\n-  bool non_constant_p = false, overflow_p = false;\n-  tree ctor = eval_constant_expression (&new_ctx, t, false, &non_constant_p,\n-\t\t\t\t\t&overflow_p);\n-  if (TREE_CODE (ctor) == CONSTRUCTOR && CONSTRUCTOR_NELTS (ctor) == 1\n-      && CONSTRUCTOR_ELT (ctor, 0)->index\n-      && TREE_CODE (CONSTRUCTOR_ELT (ctor, 0)->index) == FIELD_DECL)\n-    return CONSTRUCTOR_ELT (ctor, 0)->index;\n-  return NULL_TREE;\n-}\n-\n-// forked from gcc/cp/constexpr.cc cxx_fold_indirect_ref_1\n-\n-static tree\n-fold_indirect_ref_1 (const constexpr_ctx *ctx, location_t loc, tree type,\n-\t\t     tree op, unsigned HOST_WIDE_INT off, bool *empty_base)\n-{\n-  tree optype = TREE_TYPE (op);\n-  unsigned HOST_WIDE_INT const_nunits;\n-  if (off == 0 && similar_type_p (optype, type))\n-    return op;\n-  else if (TREE_CODE (optype) == COMPLEX_TYPE\n-\t   && similar_type_p (type, TREE_TYPE (optype)))\n-    {\n-      /* *(foo *)&complexfoo => __real__ complexfoo */\n-      if (off == 0)\n-\treturn build1_loc (loc, REALPART_EXPR, type, op);\n-      /* ((foo*)&complexfoo)[1] => __imag__ complexfoo */\n-      else if (tree_to_uhwi (TYPE_SIZE_UNIT (type)) == off)\n-\treturn build1_loc (loc, IMAGPART_EXPR, type, op);\n-    }\n-  /* ((foo*)&vectorfoo)[x] => BIT_FIELD_REF<vectorfoo,...> */\n-  else if (VECTOR_TYPE_P (optype) && similar_type_p (type, TREE_TYPE (optype))\n-\t   && TYPE_VECTOR_SUBPARTS (optype).is_constant (&const_nunits))\n-    {\n-      unsigned HOST_WIDE_INT part_width = tree_to_uhwi (TYPE_SIZE_UNIT (type));\n-      unsigned HOST_WIDE_INT max_offset = part_width * const_nunits;\n-      if (off < max_offset && off % part_width == 0)\n-\t{\n-\t  tree index = bitsize_int (off * BITS_PER_UNIT);\n-\t  return build3_loc (loc, BIT_FIELD_REF, type, op, TYPE_SIZE (type),\n-\t\t\t     index);\n-\t}\n-    }\n-  /* ((foo *)&fooarray)[x] => fooarray[x] */\n-  else if (TREE_CODE (optype) == ARRAY_TYPE\n-\t   && tree_fits_uhwi_p (TYPE_SIZE_UNIT (TREE_TYPE (optype)))\n-\t   && !integer_zerop (TYPE_SIZE_UNIT (TREE_TYPE (optype))))\n-    {\n-      tree type_domain = TYPE_DOMAIN (optype);\n-      tree min_val = size_zero_node;\n-      if (type_domain && TYPE_MIN_VALUE (type_domain))\n-\tmin_val = TYPE_MIN_VALUE (type_domain);\n-      unsigned HOST_WIDE_INT el_sz\n-\t= tree_to_uhwi (TYPE_SIZE_UNIT (TREE_TYPE (optype)));\n-      unsigned HOST_WIDE_INT idx = off / el_sz;\n-      unsigned HOST_WIDE_INT rem = off % el_sz;\n-      if (tree_fits_uhwi_p (min_val))\n-\t{\n-\t  tree index = size_int (idx + tree_to_uhwi (min_val));\n-\t  op = build4_loc (loc, ARRAY_REF, TREE_TYPE (optype), op, index,\n-\t\t\t   NULL_TREE, NULL_TREE);\n-\t  return fold_indirect_ref_1 (ctx, loc, type, op, rem, empty_base);\n-\t}\n-    }\n-  /* ((foo *)&struct_with_foo_field)[x] => COMPONENT_REF */\n-  else if (TREE_CODE (optype) == RECORD_TYPE\n-\t   || TREE_CODE (optype) == UNION_TYPE)\n-    {\n-      if (TREE_CODE (optype) == UNION_TYPE)\n-\t/* For unions prefer the currently active member.  */\n-\tif (tree field = union_active_member (ctx, op))\n-\t  {\n-\t    unsigned HOST_WIDE_INT el_sz\n-\t      = tree_to_uhwi (TYPE_SIZE_UNIT (TREE_TYPE (field)));\n-\t    if (off < el_sz)\n-\t      {\n-\t\ttree cop = build3 (COMPONENT_REF, TREE_TYPE (field), op, field,\n-\t\t\t\t   NULL_TREE);\n-\t\tif (tree ret = fold_indirect_ref_1 (ctx, loc, type, cop, off,\n-\t\t\t\t\t\t    empty_base))\n-\t\t  return ret;\n-\t      }\n-\t  }\n-      for (tree field = TYPE_FIELDS (optype); field; field = DECL_CHAIN (field))\n-\tif (TREE_CODE (field) == FIELD_DECL\n-\t    && TREE_TYPE (field) != error_mark_node\n-\t    && tree_fits_uhwi_p (TYPE_SIZE_UNIT (TREE_TYPE (field))))\n-\t  {\n-\t    tree pos = byte_position (field);\n-\t    if (!tree_fits_uhwi_p (pos))\n-\t      continue;\n-\t    unsigned HOST_WIDE_INT upos = tree_to_uhwi (pos);\n-\t    unsigned HOST_WIDE_INT el_sz\n-\t      = tree_to_uhwi (TYPE_SIZE_UNIT (TREE_TYPE (field)));\n-\t    if (upos <= off && off < upos + el_sz)\n-\t      {\n-\t\ttree cop = build3 (COMPONENT_REF, TREE_TYPE (field), op, field,\n-\t\t\t\t   NULL_TREE);\n-\t\tif (tree ret = fold_indirect_ref_1 (ctx, loc, type, cop,\n-\t\t\t\t\t\t    off - upos, empty_base))\n-\t\t  return ret;\n-\t      }\n-\t  }\n-      /* Also handle conversion to an empty base class, which\n-\t is represented with a NOP_EXPR.  */\n-      if (is_empty_class (type) && CLASS_TYPE_P (optype))\n-\t{\n-\t  *empty_base = true;\n-\t  return op;\n-\t}\n-    }\n-\n-  return NULL_TREE;\n-}\n-\n // #include \"gt-rust-rust-constexpr.h\"\n \n } // namespace Compile"}]}