{"sha": "cb1119b785be0b910b6c7a9e2ee1f0338badf579", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Y2IxMTE5Yjc4NWJlMGI5MTBiNmM3YTllMmVlMWYwMzM4YmFkZjU3OQ==", "commit": {"author": {"name": "Richard Guenther", "email": "rguenther@suse.de", "date": "2005-07-14T07:46:23Z"}, "committer": {"name": "Richard Biener", "email": "rguenth@gcc.gnu.org", "date": "2005-07-14T07:46:23Z"}, "message": "re PR middle-end/22347 (Return value register not correctly computed for indirect function call)\n\n2005-07-14  Richard Guenther  <rguenther@suse.de>\n\n\tPR middle-end/22347\n\t* config/i386/i386-protos.h (ix86_function_value): Change\n\tprototype to match new target hook.\n\t* config/i386/i386.c (ix86_value_regno): Change prototype\n\tto take extra type argument.\n\t(TARGET_FUNCTION_VALUE): Define.\n\t(ix86_function_ok_for_sibcall): Pass extra argument to\n\tix86_value_regno, check return slot rtx for exact match.\n\t(ix86_function_value): Take extra parameter.  Dispatch to\n\tix86_value_regno with fndecl/fntype as provided.\n\t(ix86_value_regno): Handle extra type argument.\n\t* config/i386/i386.h (FUNCTION_VALUE): No longer define.\n\n\t* testsuite/gcc.target/i386/sseregparm-3.c: New testcase.\n\t* testsuite/gcc.target/i386/sseregparm-4.c: New testcase.\n\t* testsuite/gcc.target/i386/sseregparm-5.c: New testcase.\n\t* testsuite/gcc.target/i386/sseregparm-6.c: New testcase.\n\t* testsuite/gcc.target/i386/sseregparm-7.c: New testcase.\n\nFrom-SVN: r102014", "tree": {"sha": "e23fe4eb2d1a570d31a48f2d2648f10e107f2e10", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e23fe4eb2d1a570d31a48f2d2648f10e107f2e10"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/cb1119b785be0b910b6c7a9e2ee1f0338badf579", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cb1119b785be0b910b6c7a9e2ee1f0338badf579", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cb1119b785be0b910b6c7a9e2ee1f0338badf579", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cb1119b785be0b910b6c7a9e2ee1f0338badf579/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "1d636cc69fa14e7f7daa4eef6ecb6a6a1413cfda", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1d636cc69fa14e7f7daa4eef6ecb6a6a1413cfda", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1d636cc69fa14e7f7daa4eef6ecb6a6a1413cfda"}], "stats": {"total": 145, "additions": 124, "deletions": 21}, "files": [{"sha": "b0ca4f999eda0a30be79e1720e274e57038bab76", "filename": "gcc/ChangeLog", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb1119b785be0b910b6c7a9e2ee1f0338badf579/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb1119b785be0b910b6c7a9e2ee1f0338badf579/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=cb1119b785be0b910b6c7a9e2ee1f0338badf579", "patch": "@@ -1,3 +1,24 @@\n+2005-07-14  Richard Guenther  <rguenther@suse.de>\n+\n+\tPR middle-end/22347\n+\t* config/i386/i386-protos.h (ix86_function_value): Change\n+\tprototype to match new target hook.\n+\t* config/i386/i386.c (ix86_value_regno): Change prototype\n+\tto take extra type argument.\n+\t(TARGET_FUNCTION_VALUE): Define.\n+\t(ix86_function_ok_for_sibcall): Pass extra argument to\n+\tix86_value_regno, check return slot rtx for exact match.\n+\t(ix86_function_value): Take extra parameter.  Dispatch to\n+\tix86_value_regno with fndecl/fntype as provided.\n+\t(ix86_value_regno): Handle extra type argument.\n+\t* config/i386/i386.h (FUNCTION_VALUE): No longer define.\n+\n+\t* testsuite/gcc.target/i386/sseregparm-3.c: New testcase.\n+\t* testsuite/gcc.target/i386/sseregparm-4.c: New testcase.\n+\t* testsuite/gcc.target/i386/sseregparm-5.c: New testcase.\n+\t* testsuite/gcc.target/i386/sseregparm-6.c: New testcase.\n+\t* testsuite/gcc.target/i386/sseregparm-7.c: New testcase.\n+\n 2005-07-14  Richard Guenther  <rguenther@suse.de>\n \n \t* Makefile.in (explow.o, reg-stack.o): Depend on target.h."}, {"sha": "957876c4c7b6d70b39750c25ace4981740594725", "filename": "gcc/config/i386/i386-protos.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb1119b785be0b910b6c7a9e2ee1f0338badf579/gcc%2Fconfig%2Fi386%2Fi386-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb1119b785be0b910b6c7a9e2ee1f0338badf579/gcc%2Fconfig%2Fi386%2Fi386-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386-protos.h?ref=cb1119b785be0b910b6c7a9e2ee1f0338badf579", "patch": "@@ -206,7 +206,7 @@ extern void init_cumulative_args (CUMULATIVE_ARGS *, tree, rtx, tree);\n extern rtx function_arg (CUMULATIVE_ARGS *, enum machine_mode, tree, int);\n extern void function_arg_advance (CUMULATIVE_ARGS *, enum machine_mode,\n \t\t\t\t  tree, int);\n-extern rtx ix86_function_value (tree, tree);\n+extern rtx ix86_function_value (tree, tree, bool);\n #endif\n \n #endif"}, {"sha": "17d8ea0b0c5c04884eece80c12e41e84c93db0cc", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 34, "deletions": 13, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb1119b785be0b910b6c7a9e2ee1f0338badf579/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb1119b785be0b910b6c7a9e2ee1f0338badf579/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=cb1119b785be0b910b6c7a9e2ee1f0338badf579", "patch": "@@ -891,7 +891,7 @@ static int ix86_function_regparm (tree, tree);\n const struct attribute_spec ix86_attribute_table[];\n static bool ix86_function_ok_for_sibcall (tree, tree);\n static tree ix86_handle_cconv_attribute (tree *, tree, tree, int, bool *);\n-static int ix86_value_regno (enum machine_mode, tree);\n+static int ix86_value_regno (enum machine_mode, tree, tree);\n static bool contains_128bit_aligned_vector_p (tree);\n static rtx ix86_struct_value_rtx (tree, int);\n static bool ix86_ms_bitfield_layout_p (tree);\n@@ -1085,6 +1085,9 @@ static void init_ext_80387_constants (void);\n #undef TARGET_STACK_PROTECT_FAIL\n #define TARGET_STACK_PROTECT_FAIL ix86_stack_protect_fail\n \n+#undef TARGET_FUNCTION_VALUE\n+#define TARGET_FUNCTION_VALUE ix86_function_value\n+\n struct gcc_target targetm = TARGET_INITIALIZER;\n \n \f\n@@ -1705,6 +1708,7 @@ static bool\n ix86_function_ok_for_sibcall (tree decl, tree exp)\n {\n   tree func;\n+  rtx a, b;\n \n   /* If we are generating position-independent code, we cannot sibcall\n      optimize any indirect call, or a direct call to a global function,\n@@ -1715,16 +1719,23 @@ ix86_function_ok_for_sibcall (tree decl, tree exp)\n   if (decl)\n     func = decl;\n   else\n-    func = NULL;\n+    {\n+      func = TREE_TYPE (TREE_OPERAND (exp, 0));\n+      if (POINTER_TYPE_P (func))\n+        func = TREE_TYPE (func);\n+    }\n \n-  /* If we are returning floats on the 80387 register stack, we cannot\n+  /* Check that the return value locations are the same.  Like\n+     if we are returning floats on the 80387 register stack, we cannot\n      make a sibcall from a function that doesn't return a float to a\n      function that does or, conversely, from a function that does return\n      a float to a function that doesn't; the necessary stack adjustment\n-     would not be executed.  */\n-  if (STACK_REG_P (ix86_function_value (TREE_TYPE (exp), func))\n-      != STACK_REG_P (ix86_function_value (TREE_TYPE (DECL_RESULT (cfun->decl)),\n-\t\t\t\t\t   cfun->decl)))\n+     would not be executed.  This is also the place we notice\n+     differences in the return value ABI.  */\n+  a = ix86_function_value (TREE_TYPE (exp), func, false);\n+  b = ix86_function_value (TREE_TYPE (DECL_RESULT (cfun->decl)),\n+\t\t\t   cfun->decl, false);\n+  if (! rtx_equal_p (a, b))\n     return false;\n \n   /* If this call is indirect, we'll need to be able to use a call-clobbered\n@@ -3189,7 +3200,8 @@ ix86_function_value_regno_p (int regno)\n    If the precise function being called is known, FUNC is its FUNCTION_DECL;\n    otherwise, FUNC is 0.  */\n rtx\n-ix86_function_value (tree valtype, tree func)\n+ix86_function_value (tree valtype, tree fntype_or_decl,\n+\t\t     bool outgoing ATTRIBUTE_UNUSED)\n {\n   enum machine_mode natmode = type_natural_mode (valtype);\n \n@@ -3205,7 +3217,15 @@ ix86_function_value (tree valtype, tree func)\n       return ret;\n     }\n   else\n-    return gen_rtx_REG (TYPE_MODE (valtype), ix86_value_regno (natmode, func));\n+    {\n+      tree fn = NULL_TREE, fntype;\n+      if (fntype_or_decl\n+\t  && DECL_P (fntype_or_decl))\n+        fn = fntype_or_decl;\n+      fntype = fn ? TREE_TYPE (fn) : fntype_or_decl;\n+      return gen_rtx_REG (TYPE_MODE (valtype),\n+\t\t\t  ix86_value_regno (natmode, fn, fntype));\n+    }\n }\n \n /* Return false iff type is returned in memory.  */\n@@ -3321,13 +3341,13 @@ ix86_libcall_value (enum machine_mode mode)\n \t}\n     }\n   else\n-    return gen_rtx_REG (mode, ix86_value_regno (mode, NULL));\n+    return gen_rtx_REG (mode, ix86_value_regno (mode, NULL, NULL));\n }\n \n /* Given a mode, return the register to use for a return value.  */\n \n static int\n-ix86_value_regno (enum machine_mode mode, tree func)\n+ix86_value_regno (enum machine_mode mode, tree func, tree fntype)\n {\n   gcc_assert (!TARGET_64BIT);\n \n@@ -3347,9 +3367,10 @@ ix86_value_regno (enum machine_mode mode, tree func)\n \n   /* Floating point return values in %st(0), except for local functions when\n      SSE math is enabled or for functions with sseregparm attribute.  */\n-  if (func && (mode == SFmode || mode == DFmode))\n+  if ((func || fntype)\n+      && (mode == SFmode || mode == DFmode))\n     {\n-      int sse_level = ix86_function_sseregparm (TREE_TYPE (func), func);\n+      int sse_level = ix86_function_sseregparm (fntype, func);\n       if ((sse_level >= 1 && mode == SFmode)\n \t  || (sse_level == 2 && mode == DFmode))\n         return FIRST_SSE_REG;"}, {"sha": "7a54cba9e8413cc5a3a8310c71159f3e0ef30dbf", "filename": "gcc/config/i386/i386.h", "status": "modified", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb1119b785be0b910b6c7a9e2ee1f0338badf579/gcc%2Fconfig%2Fi386%2Fi386.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb1119b785be0b910b6c7a9e2ee1f0338badf579/gcc%2Fconfig%2Fi386%2Fi386.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.h?ref=cb1119b785be0b910b6c7a9e2ee1f0338badf579", "patch": "@@ -1433,13 +1433,6 @@ enum reg_class\n #define RETURN_POPS_ARGS(FUNDECL, FUNTYPE, SIZE) \\\n   ix86_return_pops_args ((FUNDECL), (FUNTYPE), (SIZE))\n \n-/* Define how to find the value returned by a function.\n-   VALTYPE is the data type of the value (as a tree).\n-   If the precise function being called is known, FUNC is its FUNCTION_DECL;\n-   otherwise, FUNC is 0.  */\n-#define FUNCTION_VALUE(VALTYPE, FUNC)  \\\n-   ix86_function_value (VALTYPE, FUNC)\n-\n #define FUNCTION_VALUE_REGNO_P(N) \\\n   ix86_function_value_regno_p (N)\n "}, {"sha": "9ee82af44aec75be3018b4e1ba2f7a542a31a760", "filename": "gcc/testsuite/gcc.target/i386/sseregparm-3.c", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb1119b785be0b910b6c7a9e2ee1f0338badf579/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fsseregparm-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb1119b785be0b910b6c7a9e2ee1f0338badf579/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fsseregparm-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fsseregparm-3.c?ref=cb1119b785be0b910b6c7a9e2ee1f0338badf579", "patch": "@@ -0,0 +1,14 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-msse2 -O2\" } */\n+/* { dg-require-effective-target ilp32 } */\n+\n+/* Make sure we know that mysinfp returns in %xmm0.  */\n+\n+double __attribute__((sseregparm)) mysin(double x);\n+double __attribute__((sseregparm)) (*mysinfp)(double) = mysin;\n+double bar(double x)\n+{\n+  return 1.0+mysinfp(x);\n+}\n+\n+/* { dg-final { scan-assembler \"fldl\" } } */"}, {"sha": "a29cf06bf5c93497c92915caaf7b35ba43bdf0a0", "filename": "gcc/testsuite/gcc.target/i386/sseregparm-4.c", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb1119b785be0b910b6c7a9e2ee1f0338badf579/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fsseregparm-4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb1119b785be0b910b6c7a9e2ee1f0338badf579/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fsseregparm-4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fsseregparm-4.c?ref=cb1119b785be0b910b6c7a9e2ee1f0338badf579", "patch": "@@ -0,0 +1,14 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-msse2 -O2\" } */\n+/* { dg-require-effective-target ilp32 } */\n+\n+/* Make sure we know that mysinfp returns in %xmm0.  */\n+\n+double __attribute__((sseregparm)) mysin(double x);\n+double __attribute__((sseregparm)) (*mysinfp)(double) = mysin;\n+double bar(double x)\n+{\n+  return mysinfp(x);\n+}\n+\n+/* { dg-final { scan-assembler \"fldl\" } } */"}, {"sha": "7423722d69418255e651305f1bbeb75d46feb1fa", "filename": "gcc/testsuite/gcc.target/i386/sseregparm-5.c", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb1119b785be0b910b6c7a9e2ee1f0338badf579/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fsseregparm-5.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb1119b785be0b910b6c7a9e2ee1f0338badf579/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fsseregparm-5.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fsseregparm-5.c?ref=cb1119b785be0b910b6c7a9e2ee1f0338badf579", "patch": "@@ -0,0 +1,14 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-msse2 -O2\" } */\n+/* { dg-require-effective-target ilp32 } */\n+\n+/* Make sure we know that mysinfp returns in %xmm0.  */\n+\n+double __attribute__((sseregparm)) mysin(void);\n+double __attribute__((sseregparm)) (*mysinfp)(void) = mysin;\n+double bar(double x)\n+{\n+  return mysinfp();\n+}\n+\n+/* { dg-final { scan-assembler \"fldl\" } } */"}, {"sha": "6203b6b59712225d2f1b67762570e06d71529524", "filename": "gcc/testsuite/gcc.target/i386/sseregparm-6.c", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb1119b785be0b910b6c7a9e2ee1f0338badf579/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fsseregparm-6.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb1119b785be0b910b6c7a9e2ee1f0338badf579/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fsseregparm-6.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fsseregparm-6.c?ref=cb1119b785be0b910b6c7a9e2ee1f0338badf579", "patch": "@@ -0,0 +1,13 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-msse2 -O2\" } */\n+/* { dg-require-effective-target ilp32 } */\n+\n+/* Make sure we know that mysinfp returns in %xmm0.  */\n+\n+double __attribute__((sseregparm)) mysin(double x);\n+double bar(double x)\n+{\n+  return mysin(x);\n+}\n+\n+/* { dg-final { scan-assembler \"fldl\" } } */"}, {"sha": "61267df9853b14c18eec9aece875923812d5f304", "filename": "gcc/testsuite/gcc.target/i386/sseregparm-7.c", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb1119b785be0b910b6c7a9e2ee1f0338badf579/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fsseregparm-7.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb1119b785be0b910b6c7a9e2ee1f0338badf579/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fsseregparm-7.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fsseregparm-7.c?ref=cb1119b785be0b910b6c7a9e2ee1f0338badf579", "patch": "@@ -0,0 +1,13 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-msse2 -O2\" } */\n+/* { dg-require-effective-target ilp32 } */\n+\n+/* Make sure we know that mysinfp returns in %xmm0.  */\n+\n+double __attribute__((sseregparm)) mysin(void);\n+double bar(double x)\n+{\n+  return mysin();\n+}\n+\n+/* { dg-final { scan-assembler \"fldl\" } } */"}]}