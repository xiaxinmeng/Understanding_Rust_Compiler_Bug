{"sha": "c47b0cb46626dd1df1aad35c5d1ee9f5be43debe", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YzQ3YjBjYjQ2NjI2ZGQxZGYxYWFkMzVjNWQxZWU5ZjViZTQzZGViZQ==", "commit": {"author": {"name": "Maxim Kuvyrkov", "email": "maxim@codesourcery.com", "date": "2007-09-11T13:56:30Z"}, "committer": {"name": "Maxim Kuvyrkov", "email": "mkuvyrkov@gcc.gnu.org", "date": "2007-09-11T13:56:30Z"}, "message": "predicates.md (movsi_const0_operand, [...]): New predicates.\n\n\t* config/m68k/predicates.md (movsi_const0_operand,\n\tnon_symbolic_call_operand): New predicates.\n\n\t* config/m68k/constraints.md: (Cs, Ci, C0, Cj, CQ, CW, CZ, CS, Ap, Ac):\n\tNew constraints.\n\t* doc/md.texi (Constraints for Particular Machines: Motorola 680x0):\n\tDocument constraints N, O, P, R, S, T, Q, U, W, Cs, Ci, C0, Cj, CQ,\n\tCW, CZ, CS, Ap and Ac.\n\n\t* config/m68k/m68k.md (UNSPEC_IB): New constant.\n\t(constraints.md): New include.\n\t(cpu, type, type1, opx, opy, opx_type, opy_type, size, opx_access,\n\topx_mem, opy_mem, op_mem, guess, split): New attributes.\n\t(movdf_internal): Name pattern.  Fix to use alternatives.  Add split.\n\tSpecify attributes.\n\t(pushdi): Add split.\n\t(tstsi_internal): Name pattern.  Fix to use alternatives.  Specify\n\tattributes.  Split tstsi_internal_68020_cf from it.\n\t(tstsi_internal_68020_cf): New pattern.\n\t(tsthi_internal, tstqi_internal): Name pattern.  Specify attributes.\n\t(tst<mode>_cf): Specify attributea.\n\t(cmpsi_cf): Name pattern.  Specify attributes.\n\t(cmp<mode>_68881, cmp<mode>_cf): Specify type attribute.\n\t(pushexthisi_const): Fix to use alternatives.  Specify\n\tattributes.\n\t(movsi_const0): Split movsi_const0_68000_10 and movsi_const0_68040_60\n\tfrom it.  Fix to use alternatives.  Specify attributes.\n\t(movsi_const0_68040_10, movsi_const0_68040_60): New patterns.\n\t(movsi_cf, movstrictqi_cf): Fix to use alternatives.  Specify\n\tattributes.\n\t(movsf_cf_soft): Specify attributes.\n\t(movdf_cf_soft): Add split.\n\t(pushasi, zero_extendhisi2_cf, zero_extendqisi2_cfv4,\n\tcfv4_extendhisi2, 68k_extendhisi2, extendqihi2, cfv4_extendqisi2,\n\t68k_extendqisi2, truncdfsf2_cf): Specify attributes.\n\t(truncdfsf2_68881): Name pattern.  Specify attributes.\n\t(floatsi<mode>2_cf, floathi<mode>2_68881, floathi<mode>2_cf,\n\tfloatqi<mode>2_68881, floatqi<mode>2_cf, ftrunc<mode>2_cf,\n\tfix<mode>qi2_cf, fix<mode>hi2_cf, fix<mode>si2_cf, adddi_dishl32):\n\tSpecify attributes.\n\t(addsi3_5200): Fix to use alternatives.  Specify attributes.\n\tAdd splits.\n\t(add<mode>3_cf, subdi_dishl32): Specify attributes.\n\t(subsi3): Add alternative for subq.l.  Specify attributes.\n\t(sub<mode>3_cf, mulhi3, mulhisi3): Specify attributes.\n\t(mulhisisi3_s, mulsi3_68020, mulsi3_cf): Name pattern.  Specify\n\tattributes.\n\t(umulhisi3): Specify attributes.\n\t(mulhisisi3_z): Name pattern.  Specify attributes.\n\t(fmul<mode>3_cf, div<mode>3_cf, negsi2_internal, negsi2_5200,\n\tsqrt<mode>2_68881, clzsi2, one_cmplsi2_5200, subreghi1ashrdi_const32,\n\tsubregsi1ashrdi_const32, ashrsi3, subreg1lshrdi_const32, lshrsi3,\n\tbsetmemqi): Specify attributes.\n\t(bsetmemqi_ext): Name pattern.  Specify attributes.\n\t(bclrmemqi): Specify attributes.\n\t(bclrmemqi_ext, scc, sls): Name pattern.  Specify attributes.\n\t(beq, bne, bgt, bgtu, blt, bltu, bge, bgeu, ble, bleu): Specify\n\tattributes.\n\t(beq2, bne2, bgt2, bgtu2, blt2, bltu2, bge2, bgeu2, ble2, bleu2): Name\n\tpattern.  Specify attributes.\n\t(jump): Specify attributes.\n\t(tablejump_internal): Name pattern.  Specify attributes.\n\t(call_value): Split into non_symbolic_call_value,\n\tsymbolic_call_value_jsr, symbolic_call_value_bsr.  Fix to use\n\talternatives.  Specify attributes.\n\t(non_symbolic_call_value, symbolic_call_value_jsr,\n\tsymbolic_call_value_bsr): New patterns.\n\t(nop, return, unlink, indirect_jump): Specify attributes.\n\t(trap): Fix condition.  Specify attributes.\n\t(ib): New pattern.\n\n\t* config/m68k/m68k.c (m68k_symbolic_call_var): New variable.\n\t(override_options): Initialize it.  Initialize m68k_sched_cpu.\n\t(CONST_METHOD): Rename to M68K_CONST_METHOD, move to m68k.h.\n\t(const_method): Make global, rename to m68k_const_method.\n\t(const_int_cost, output_move_const_into_data_reg): Update.\n\t(output_move_double): Parametrize to emit rtl code, rename to\n\thandle_move_double.\n\t(output_reg_adjust, emit_reg_adjust, output_compadr, output_movsi,\n\temit_movsi): New static functions.\n\t(output_move_double): New function with semantics of old\n\toutput_move_double.\n\t(m68k_emit_move_double): New function.\n\t(m68k_sched_cpu): New variable.\n\t(attr_op_type): New enum.\n\t(sched_guess_p): New variable.\n\t(sched_address_type, sched_operand_type, sched_attr_op_type):\n\tNew static functions.\n\t(m68k_sched_attr_opx_type, m68k_sched_attr_opy_type,\n\tm68k_sched_attr_size, m68k_sched_attr_op_mem): New functions.\n\t(sched_branch_type): New static variable.\n\t(m68k_sched_branch_type): New function.\n\t* config/m68k/m68k.h (M68K_SYMBOLIC_CALL): New enum.\n\t(m68k_symbolic_call_var): Declare.\n\t(M68K_CONST_METHOD): Rename from CONST_METHOD.  Move here from m68k.c.\n\t(m68k_const_method, m68k_emit_move_double, m68k_sched_cpu,\n\tm68k_sched_attr_opx_type, m68k_sched_attr_opy_type,\n\tm68k_sched_attr_size, m68k_sched_attr_op_mem, m68k_sched_branch_type):\n\tDeclare.\n\nFrom-SVN: r128377", "tree": {"sha": "872e1e19c4888e93d9ac7b2a03a6a0bd5dc9f646", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/872e1e19c4888e93d9ac7b2a03a6a0bd5dc9f646"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c47b0cb46626dd1df1aad35c5d1ee9f5be43debe", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c47b0cb46626dd1df1aad35c5d1ee9f5be43debe", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c47b0cb46626dd1df1aad35c5d1ee9f5be43debe", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c47b0cb46626dd1df1aad35c5d1ee9f5be43debe/comments", "author": null, "committer": null, "parents": [{"sha": "ab0e176c5b252f6cf61e520b36f6c0d313a3281d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ab0e176c5b252f6cf61e520b36f6c0d313a3281d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ab0e176c5b252f6cf61e520b36f6c0d313a3281d"}], "stats": {"total": 1856, "additions": 1591, "deletions": 265}, "files": [{"sha": "add575350f5361505df8bffcc729d1b78db2e465", "filename": "gcc/ChangeLog", "status": "modified", "additions": 102, "deletions": 0, "changes": 102, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c47b0cb46626dd1df1aad35c5d1ee9f5be43debe/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c47b0cb46626dd1df1aad35c5d1ee9f5be43debe/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=c47b0cb46626dd1df1aad35c5d1ee9f5be43debe", "patch": "@@ -1,3 +1,105 @@\n+2007-09-11  Maxim Kuvyrkov  <maxim@codesourcery.com>\n+\n+\t* config/m68k/predicates.md (movsi_const0_operand,\n+\tnon_symbolic_call_operand): New predicates.\n+\n+\t* config/m68k/constraints.md: (Cs, Ci, C0, Cj, CQ, CW, CZ, CS, Ap, Ac):\n+\tNew constraints.\n+\t* doc/md.texi (Constraints for Particular Machines: Motorola 680x0):\n+\tDocument constraints N, O, P, R, S, T, Q, U, W, Cs, Ci, C0, Cj, CQ,\n+\tCW, CZ, CS, Ap and Ac.\n+\n+\t* config/m68k/m68k.md (UNSPEC_IB): New constant.\n+\t(constraints.md): New include.\n+\t(cpu, type, type1, opx, opy, opx_type, opy_type, size, opx_access,\n+\topx_mem, opy_mem, op_mem, guess, split): New attributes.\n+\t(movdf_internal): Name pattern.  Fix to use alternatives.  Add split.\n+\tSpecify attributes.\n+\t(pushdi): Add split.\n+\t(tstsi_internal): Name pattern.  Fix to use alternatives.  Specify\n+\tattributes.  Split tstsi_internal_68020_cf from it.\n+\t(tstsi_internal_68020_cf): New pattern.\n+\t(tsthi_internal, tstqi_internal): Name pattern.  Specify attributes.\n+\t(tst<mode>_cf): Specify attributea.\n+\t(cmpsi_cf): Name pattern.  Specify attributes.\n+\t(cmp<mode>_68881, cmp<mode>_cf): Specify type attribute.\n+\t(pushexthisi_const): Fix to use alternatives.  Specify\n+\tattributes.\n+\t(movsi_const0): Split movsi_const0_68000_10 and movsi_const0_68040_60\n+\tfrom it.  Fix to use alternatives.  Specify attributes.\n+\t(movsi_const0_68040_10, movsi_const0_68040_60): New patterns.\n+\t(movsi_cf, movstrictqi_cf): Fix to use alternatives.  Specify\n+\tattributes.\n+\t(movsf_cf_soft): Specify attributes.\n+\t(movdf_cf_soft): Add split.\n+\t(pushasi, zero_extendhisi2_cf, zero_extendqisi2_cfv4,\n+\tcfv4_extendhisi2, 68k_extendhisi2, extendqihi2, cfv4_extendqisi2,\n+\t68k_extendqisi2, truncdfsf2_cf): Specify attributes.\n+\t(truncdfsf2_68881): Name pattern.  Specify attributes.\n+\t(floatsi<mode>2_cf, floathi<mode>2_68881, floathi<mode>2_cf,\n+\tfloatqi<mode>2_68881, floatqi<mode>2_cf, ftrunc<mode>2_cf,\n+\tfix<mode>qi2_cf, fix<mode>hi2_cf, fix<mode>si2_cf, adddi_dishl32):\n+\tSpecify attributes.\n+\t(addsi3_5200): Fix to use alternatives.  Specify attributes.\n+\tAdd splits.\n+\t(add<mode>3_cf, subdi_dishl32): Specify attributes.\n+\t(subsi3): Add alternative for subq.l.  Specify attributes.\n+\t(sub<mode>3_cf, mulhi3, mulhisi3): Specify attributes.\n+\t(mulhisisi3_s, mulsi3_68020, mulsi3_cf): Name pattern.  Specify\n+\tattributes.\n+\t(umulhisi3): Specify attributes.\n+\t(mulhisisi3_z): Name pattern.  Specify attributes.\n+\t(fmul<mode>3_cf, div<mode>3_cf, negsi2_internal, negsi2_5200,\n+\tsqrt<mode>2_68881, clzsi2, one_cmplsi2_5200, subreghi1ashrdi_const32,\n+\tsubregsi1ashrdi_const32, ashrsi3, subreg1lshrdi_const32, lshrsi3,\n+\tbsetmemqi): Specify attributes.\n+\t(bsetmemqi_ext): Name pattern.  Specify attributes.\n+\t(bclrmemqi): Specify attributes.\n+\t(bclrmemqi_ext, scc, sls): Name pattern.  Specify attributes.\n+\t(beq, bne, bgt, bgtu, blt, bltu, bge, bgeu, ble, bleu): Specify\n+\tattributes.\n+\t(beq2, bne2, bgt2, bgtu2, blt2, bltu2, bge2, bgeu2, ble2, bleu2): Name\n+\tpattern.  Specify attributes.\n+\t(jump): Specify attributes.\n+\t(tablejump_internal): Name pattern.  Specify attributes.\n+\t(call_value): Split into non_symbolic_call_value,\n+\tsymbolic_call_value_jsr, symbolic_call_value_bsr.  Fix to use\n+\talternatives.  Specify attributes.\n+\t(non_symbolic_call_value, symbolic_call_value_jsr,\n+\tsymbolic_call_value_bsr): New patterns.\n+\t(nop, return, unlink, indirect_jump): Specify attributes.\n+\t(trap): Fix condition.  Specify attributes.\n+\t(ib): New pattern.\n+\n+\t* config/m68k/m68k.c (m68k_symbolic_call_var): New variable.\n+\t(override_options): Initialize it.  Initialize m68k_sched_cpu.\n+\t(CONST_METHOD): Rename to M68K_CONST_METHOD, move to m68k.h.\n+\t(const_method): Make global, rename to m68k_const_method.\n+\t(const_int_cost, output_move_const_into_data_reg): Update.\n+\t(output_move_double): Parametrize to emit rtl code, rename to\n+\thandle_move_double.\n+\t(output_reg_adjust, emit_reg_adjust, output_compadr, output_movsi,\n+\temit_movsi): New static functions.\n+\t(output_move_double): New function with semantics of old\n+\toutput_move_double.\n+\t(m68k_emit_move_double): New function.\n+\t(m68k_sched_cpu): New variable.\n+\t(attr_op_type): New enum.\n+\t(sched_guess_p): New variable.\n+\t(sched_address_type, sched_operand_type, sched_attr_op_type):\n+\tNew static functions.\n+\t(m68k_sched_attr_opx_type, m68k_sched_attr_opy_type,\n+\tm68k_sched_attr_size, m68k_sched_attr_op_mem): New functions.\n+\t(sched_branch_type): New static variable.\n+\t(m68k_sched_branch_type): New function.\n+\t* config/m68k/m68k.h (M68K_SYMBOLIC_CALL): New enum.\n+\t(m68k_symbolic_call_var): Declare.\n+\t(M68K_CONST_METHOD): Rename from CONST_METHOD.  Move here from m68k.c.\n+\t(m68k_const_method, m68k_emit_move_double, m68k_sched_cpu,\n+\tm68k_sched_attr_opx_type, m68k_sched_attr_opy_type,\n+\tm68k_sched_attr_size, m68k_sched_attr_op_mem, m68k_sched_branch_type):\n+\tDeclare.\n+\n 2007-09-11  Jakub Jelinek  <jakub@redhat.com>\n \n \t* builtins.def (BUILT_IN_VA_ARG_PACK_LEN): New builtin."}, {"sha": "592112a155b05fed16726104f321421ee0de2ae3", "filename": "gcc/config/m68k/constraints.md", "status": "modified", "additions": 48, "deletions": 0, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c47b0cb46626dd1df1aad35c5d1ee9f5be43debe/gcc%2Fconfig%2Fm68k%2Fconstraints.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c47b0cb46626dd1df1aad35c5d1ee9f5be43debe/gcc%2Fconfig%2Fm68k%2Fconstraints.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm68k%2Fconstraints.md?ref=c47b0cb46626dd1df1aad35c5d1ee9f5be43debe", "patch": "@@ -104,3 +104,51 @@\n (define_constraint \"W\"\n   \"Used for const_call_operands.\"\n   (match_operand 0 \"const_call_operand\"))\n+\n+(define_constraint \"Cs\"\n+  \"symbol_ref or const.\"\n+  (match_code \"symbol_ref,const\"))\n+\n+(define_constraint \"Ci\"\n+  \"const_int.\"\n+  (and (match_code \"const_int\")\n+       (match_test \"true\")))\n+\n+(define_constraint \"C0\"\n+  \"const_int 0.\"\n+  (and (match_code \"const_int\")\n+       (match_test \"ival == 0\")))\n+\n+(define_constraint \"Cj\"\n+  \"Range of signed numbers that don't fit in 16 bits.\"\n+  (and (match_code \"const_int\")\n+       (match_test \"ival < -0x8000 || ival > 0x7FFF\")))\n+\n+(define_constraint \"CQ\"\n+  \"Integers valid for mvq.\"\n+  (and (match_code \"const_int\")\n+       (match_test \"m68k_const_method (ival) == MOVQ\")))\n+\n+(define_constraint \"CW\"\n+  \"Integers valid for a moveq followed by a swap.\"\n+  (and (match_code \"const_int\")\n+       (match_test \"m68k_const_method (ival) == SWAP\")))\n+\n+(define_constraint \"CZ\"\n+  \"Integers valid for mvz.\"\n+  (and (match_code \"const_int\")\n+       (match_test \"m68k_const_method (ival) == MVZ\")))\n+\n+(define_constraint \"CS\"\n+  \"Integers valid for mvs.\"\n+  (and (match_code \"const_int\")\n+       (match_test \"m68k_const_method (ival) == MVS\")))\n+\n+(define_constraint \"Ap\"\n+  \"push_operand.\"\n+  (match_operand 0 \"push_operand\"))\n+\n+(define_constraint \"Ac\"\n+  \"Non-register operands allowed in clr.\"\n+  (and (match_operand 0 \"movsi_const0_operand\")\n+       (match_test \"!REG_P (op)\")))"}, {"sha": "654add3d197492d84a4b801fcea47f62a2080f84", "filename": "gcc/config/m68k/m68k.c", "status": "modified", "additions": 680, "deletions": 73, "changes": 753, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c47b0cb46626dd1df1aad35c5d1ee9f5be43debe/gcc%2Fconfig%2Fm68k%2Fm68k.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c47b0cb46626dd1df1aad35c5d1ee9f5be43debe/gcc%2Fconfig%2Fm68k%2Fm68k.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm68k%2Fm68k.c?ref=c47b0cb46626dd1df1aad35c5d1ee9f5be43debe", "patch": "@@ -353,6 +353,10 @@ unsigned int m68k_cpu_flags;\n    in operand 0.  */\n const char *m68k_symbolic_call;\n const char *m68k_symbolic_jump;\n+\n+/* Enum variable that corresponds to m68k_symbolic_call values.  */\n+enum M68K_SYMBOLIC_CALL m68k_symbolic_call_var;\n+\n \f\n /* See whether TABLE has an entry with name NAME.  Return true and\n    store the entry in *ENTRY if so, otherwise return false and\n@@ -563,11 +567,11 @@ override_options (void)\n \n   if (!flag_pic)\n     {\n+      m68k_symbolic_call_var = M68K_SYMBOLIC_CALL_JSR;\n+\n #if MOTOROLA && !defined (USE_GAS)\n-      m68k_symbolic_call = \"jsr %a0\";\n       m68k_symbolic_jump = \"jmp %a0\";\n #else\n-      m68k_symbolic_call = \"jbsr %a0\";\n       m68k_symbolic_jump = \"jra %a0\";\n #endif\n     }\n@@ -577,15 +581,10 @@ override_options (void)\n   else if (TARGET_68020 || TARGET_ISAB || TARGET_ISAC)\n     {\n       if (TARGET_PCREL)\n-\tm68k_symbolic_call = \"bsr.l %c0\";\n+\tm68k_symbolic_call_var = M68K_SYMBOLIC_CALL_BSR_C;\n       else\n-\t{\n-#if defined(USE_GAS)\n-\t  m68k_symbolic_call = \"bsr.l %p0\";\n-#else\n-\t  m68k_symbolic_call = \"bsr %p0\";\n-#endif\n-\t}\n+\tm68k_symbolic_call_var = M68K_SYMBOLIC_CALL_BSR_P;\n+\n       if (TARGET_ISAC)\n \t/* No unconditional long branch */;\n       else if (TARGET_PCREL)\n@@ -605,7 +604,48 @@ override_options (void)\n       flag_no_function_cse = 1;\n     }\n \n+  switch (m68k_symbolic_call_var)\n+    {\n+    case M68K_SYMBOLIC_CALL_JSR:\n+#if MOTOROLA && !defined (USE_GAS)\n+      m68k_symbolic_call = \"jsr %a0\";\n+#else\n+      m68k_symbolic_call = \"jbsr %a0\";\n+#endif\n+      break;\n+\n+    case M68K_SYMBOLIC_CALL_BSR_C:\n+      m68k_symbolic_call = \"bsr.l %c0\";\n+      break;\n+\n+    case M68K_SYMBOLIC_CALL_BSR_P:\n+#if defined(USE_GAS)\n+      m68k_symbolic_call = \"bsr.l %p0\";\n+#else\n+      m68k_symbolic_call = \"bsr %p0\";\n+#endif\n+      break;\n+\n+    case M68K_SYMBOLIC_CALL_NONE:\n+      gcc_assert (m68k_symbolic_call == NULL);\n+      break;\n+\n+    default:\n+      gcc_unreachable ();\n+    }\n+\n   SUBTARGET_OVERRIDE_OPTIONS;\n+\n+  /* Setup scheduling options.  */\n+  if (TUNE_CFV2)\n+    m68k_sched_cpu = CPU_CF_V2;\n+  else\n+    {\n+      m68k_sched_cpu = CPU_UNKNOWN;\n+      flag_schedule_insns = 0;\n+      flag_schedule_insns_after_reload = 0;\n+      flag_modulo_sched = 0;\n+    }\n }\n \n /* Generate a macro of the form __mPREFIX_cpu_NAME, where PREFIX is the\n@@ -2037,14 +2077,13 @@ legitimize_pic_address (rtx orig, enum machine_mode mode ATTRIBUTE_UNUSED,\n }\n \n \f\n-typedef enum { MOVL, SWAP, NEGW, NOTW, NOTB, MOVQ, MVS, MVZ } CONST_METHOD;\n \n #define USE_MOVQ(i)\t((unsigned) ((i) + 128) <= 255)\n \n /* Return the type of move that should be used for integer I.  */\n \n-static CONST_METHOD\n-const_method (HOST_WIDE_INT i)\n+M68K_CONST_METHOD\n+m68k_const_method (HOST_WIDE_INT i)\n {\n   unsigned u;\n \n@@ -2090,7 +2129,7 @@ const_method (HOST_WIDE_INT i)\n static int\n const_int_cost (HOST_WIDE_INT i)\n {\n-  switch (const_method (i))\n+  switch (m68k_const_method (i))\n     {\n     case MOVQ:\n       /* Constants between -128 and 127 are cheap due to moveq.  */\n@@ -2254,7 +2293,7 @@ output_move_const_into_data_reg (rtx *operands)\n   HOST_WIDE_INT i;\n \n   i = INTVAL (operands[1]);\n-  switch (const_method (i))\n+  switch (m68k_const_method (i))\n     {\n     case MVZ:\n       return \"mvzw %1,%0\";\n@@ -2478,11 +2517,18 @@ singlemove_string (rtx *operands)\n }\n \n \n-/* Output assembler code to perform a doubleword move insn\n-   with operands OPERANDS.  */\n+/* Output assembler or rtl code to perform a doubleword move insn\n+   with operands OPERANDS.\n+   Pointers to 3 helper functions should be specified:\n+   HANDLE_REG_ADJUST to adjust a register by a small value,\n+   HANDLE_COMPADR to compute an address and\n+   HANDLE_MOVSI to move 4 bytes.  */\n \n-const char *\n-output_move_double (rtx *operands)\n+static void\n+handle_move_double (rtx operands[2],\n+\t\t    void (*handle_reg_adjust) (rtx, int),\n+\t\t    void (*handle_compadr) (rtx [2]),\n+\t\t    void (*handle_movsi) (rtx [2]))\n {\n   enum\n     {\n@@ -2540,10 +2586,9 @@ output_move_double (rtx *operands)\n   if (optype0 == PUSHOP && optype1 == POPOP)\n     {\n       operands[0] = XEXP (XEXP (operands[0], 0), 0);\n-      if (size == 12)\n-        output_asm_insn (\"sub%.l #12,%0\", operands);\n-      else\n-        output_asm_insn (\"subq%.l #8,%0\", operands);\n+\n+      handle_reg_adjust (operands[0], -size);\n+\n       if (GET_MODE (operands[1]) == XFmode)\n \toperands[0] = gen_rtx_MEM (XFmode, operands[0]);\n       else if (GET_MODE (operands[0]) == DFmode)\n@@ -2555,10 +2600,9 @@ output_move_double (rtx *operands)\n   if (optype0 == POPOP && optype1 == PUSHOP)\n     {\n       operands[1] = XEXP (XEXP (operands[1], 0), 0);\n-      if (size == 12)\n-        output_asm_insn (\"sub%.l #12,%1\", operands);\n-      else\n-        output_asm_insn (\"subq%.l #8,%1\", operands);\n+\n+      handle_reg_adjust (operands[1], -size);\n+\n       if (GET_MODE (operands[1]) == XFmode)\n \toperands[1] = gen_rtx_MEM (XFmode, operands[1]);\n       else if (GET_MODE (operands[1]) == DFmode)\n@@ -2600,8 +2644,8 @@ output_move_double (rtx *operands)\n \t}\n       else\n \t{\n-\t  middlehalf[0] = operands[0];\n-\t  latehalf[0] = operands[0];\n+\t  middlehalf[0] = adjust_address (operands[0], SImode, 0);\n+\t  latehalf[0] = adjust_address (operands[0], SImode, 0);\n \t}\n \n       if (optype1 == REGOP)\n@@ -2636,8 +2680,8 @@ output_move_double (rtx *operands)\n \t}\n       else\n \t{\n-\t  middlehalf[1] = operands[1];\n-\t  latehalf[1] = operands[1];\n+\t  middlehalf[1] = adjust_address (operands[1], SImode, 0);\n+\t  latehalf[1] = adjust_address (operands[1], SImode, 0);\n \t}\n     }\n   else\n@@ -2648,7 +2692,7 @@ output_move_double (rtx *operands)\n       else if (optype0 == OFFSOP)\n \tlatehalf[0] = adjust_address (operands[0], SImode, size - 4);\n       else\n-\tlatehalf[0] = operands[0];\n+\tlatehalf[0] = adjust_address (operands[0], SImode, 0);\n \n       if (optype1 == REGOP)\n \tlatehalf[1] = gen_rtx_REG (SImode, REGNO (operands[1]) + 1);\n@@ -2657,7 +2701,7 @@ output_move_double (rtx *operands)\n       else if (optype1 == CNSTOP)\n \tsplit_double (operands[1], &operands[1], &latehalf[1]);\n       else\n-\tlatehalf[1] = operands[1];\n+\tlatehalf[1] = adjust_address (operands[1], SImode, 0);\n     }\n \n   /* If insn is effectively movd N(sp),-(sp) then we will do the\n@@ -2687,8 +2731,9 @@ output_move_double (rtx *operands)\n \tcompadr:\n \t  xops[0] = latehalf[0];\n \t  xops[1] = XEXP (operands[1], 0);\n-\t  output_asm_insn (\"lea %a1,%0\", xops);\n-\t  if (GET_MODE (operands[1]) == XFmode )\n+\n+\t  handle_compadr (xops);\n+\t  if (GET_MODE (operands[1]) == XFmode)\n \t    {\n \t      operands[1] = gen_rtx_MEM (XFmode, latehalf[0]);\n \t      middlehalf[1] = adjust_address (operands[1], DImode, size - 8);\n@@ -2718,10 +2763,11 @@ output_move_double (rtx *operands)\n \t  gcc_assert (!addreg0 && !addreg1);\n \n \t  /* Only the middle reg conflicts; simply put it last.  */\n-\t  output_asm_insn (singlemove_string (operands), operands);\n-\t  output_asm_insn (singlemove_string (latehalf), latehalf);\n-\t  output_asm_insn (singlemove_string (middlehalf), middlehalf);\n-\t  return \"\";\n+\t  handle_movsi (operands);\n+\t  handle_movsi (latehalf);\n+\t  handle_movsi (middlehalf);\n+\n+\t  return;\n \t}\n       else if (reg_overlap_mentioned_p (testlow, XEXP (operands[1], 0)))\n \t/* If the low half of dest is mentioned in the source memory\n@@ -2745,85 +2791,194 @@ output_move_double (rtx *operands)\n     {\n       /* Make any unoffsettable addresses point at high-numbered word.  */\n       if (addreg0)\n-\t{\n-\t  if (size == 12)\n-\t    output_asm_insn (\"addq%.l #8,%0\", &addreg0);\n-\t  else\n-\t    output_asm_insn (\"addq%.l #4,%0\", &addreg0);\n-\t}\n+\thandle_reg_adjust (addreg0, size - 4);\n       if (addreg1)\n-\t{\n-\t  if (size == 12)\n-\t    output_asm_insn (\"addq%.l #8,%0\", &addreg1);\n-\t  else\n-\t    output_asm_insn (\"addq%.l #4,%0\", &addreg1);\n-\t}\n+\thandle_reg_adjust (addreg1, size - 4);\n \n       /* Do that word.  */\n-      output_asm_insn (singlemove_string (latehalf), latehalf);\n+      handle_movsi (latehalf);\n \n       /* Undo the adds we just did.  */\n       if (addreg0)\n-\toutput_asm_insn (\"subq%.l #4,%0\", &addreg0);\n+\thandle_reg_adjust (addreg0, -4);\n       if (addreg1)\n-\toutput_asm_insn (\"subq%.l #4,%0\", &addreg1);\n+\thandle_reg_adjust (addreg1, -4);\n \n       if (size == 12)\n \t{\n-\t  output_asm_insn (singlemove_string (middlehalf), middlehalf);\n+\t  handle_movsi (middlehalf);\n+\n \t  if (addreg0)\n-\t    output_asm_insn (\"subq%.l #4,%0\", &addreg0);\n+\t    handle_reg_adjust (addreg0, -4);\n \t  if (addreg1)\n-\t    output_asm_insn (\"subq%.l #4,%0\", &addreg1);\n+\t    handle_reg_adjust (addreg1, -4);\n \t}\n \n       /* Do low-numbered word.  */\n-      return singlemove_string (operands);\n+\n+      handle_movsi (operands);\n+      return;\n     }\n \n   /* Normal case: do the two words, low-numbered first.  */\n \n-  output_asm_insn (singlemove_string (operands), operands);\n+  handle_movsi (operands);\n \n   /* Do the middle one of the three words for long double */\n   if (size == 12)\n     {\n       if (addreg0)\n-\toutput_asm_insn (\"addq%.l #4,%0\", &addreg0);\n+\thandle_reg_adjust (addreg0, 4);\n       if (addreg1)\n-\toutput_asm_insn (\"addq%.l #4,%0\", &addreg1);\n+\thandle_reg_adjust (addreg1, 4);\n \n-      output_asm_insn (singlemove_string (middlehalf), middlehalf);\n+      handle_movsi (middlehalf);\n     }\n \n   /* Make any unoffsettable addresses point at high-numbered word.  */\n   if (addreg0)\n-    output_asm_insn (\"addq%.l #4,%0\", &addreg0);\n+    handle_reg_adjust (addreg0, 4);\n   if (addreg1)\n-    output_asm_insn (\"addq%.l #4,%0\", &addreg1);\n+    handle_reg_adjust (addreg1, 4);\n \n   /* Do that word.  */\n-  output_asm_insn (singlemove_string (latehalf), latehalf);\n+  handle_movsi (latehalf);\n \n   /* Undo the adds we just did.  */\n   if (addreg0)\n+    handle_reg_adjust (addreg0, -(size - 4));\n+  if (addreg1)\n+    handle_reg_adjust (addreg1, -(size - 4));\n+\n+  return;\n+}\n+\n+/* Output assembler code to adjust REG by N.  */\n+static void\n+output_reg_adjust (rtx reg, int n)\n+{\n+  const char *s;\n+\n+  gcc_assert (GET_MODE (reg) == SImode\n+\t      && -12 <= n && n != 0 && n <= 12);\n+\n+  switch (n)\n     {\n-      if (size == 12)\n-        output_asm_insn (\"subq%.l #8,%0\", &addreg0);\n-      else\n-        output_asm_insn (\"subq%.l #4,%0\", &addreg0);\n+    case 12:\n+      s = \"add%.l #12,%0\";\n+      break;\n+\n+    case 8:\n+      s = \"addq%.l #8,%0\";\n+      break;\n+\n+    case 4:\n+      s = \"addq%.l #4,%0\";\n+      break;\n+\n+    case -12:\n+      s = \"sub%.l #12,%0\";\n+      break;\n+\n+    case -8:\n+      s = \"subq%.l #8,%0\";\n+      break;\n+\n+    case -4:\n+      s = \"subq%.l #4,%0\";\n+      break;\n+\n+    default:\n+      gcc_unreachable ();\n+      s = NULL;\n     }\n-  if (addreg1)\n+\n+  output_asm_insn (s, &reg);\n+}\n+\n+/* Emit rtl code to adjust REG by N.  */\n+static void\n+emit_reg_adjust (rtx reg1, int n)\n+{\n+  rtx reg2;\n+\n+  gcc_assert (GET_MODE (reg1) == SImode\n+\t      && -12 <= n && n != 0 && n <= 12);\n+\n+  reg1 = copy_rtx (reg1);\n+  reg2 = copy_rtx (reg1);\n+\n+  if (n < 0)\n+    emit_insn (gen_subsi3 (reg1, reg2, GEN_INT (-n)));\n+  else if (n > 0)\n+    emit_insn (gen_addsi3 (reg1, reg2, GEN_INT (n)));\n+  else\n+    gcc_unreachable ();\n+}\n+\n+/* Output assembler to load address OPERANDS[0] to register OPERANDS[1].  */\n+static void\n+output_compadr (rtx operands[2])\n+{\n+  output_asm_insn (\"lea %a1,%0\", operands);\n+}\n+\n+/* Output the best assembler insn for moving operands[1] into operands[0]\n+   as a fullword.  */\n+static void\n+output_movsi (rtx operands[2])\n+{\n+  output_asm_insn (singlemove_string (operands), operands);\n+}\n+\n+/* Copy OP and change its mode to MODE.  */\n+static rtx\n+copy_operand (rtx op, enum machine_mode mode)\n+{\n+  /* ??? This looks really ugly.  There must be a better way\n+     to change a mode on the operand.  */\n+  if (GET_MODE (op) != VOIDmode)\n     {\n-      if (size == 12)\n-        output_asm_insn (\"subq%.l #8,%0\", &addreg1);\n+      if (REG_P (op))\n+\top = gen_rtx_REG (mode, REGNO (op));\n       else\n-        output_asm_insn (\"subq%.l #4,%0\", &addreg1);\n+\t{\n+\t  op = copy_rtx (op);\n+\t  PUT_MODE (op, mode);\n+\t}\n     }\n \n+  return op;\n+}\n+\n+/* Emit rtl code for moving operands[1] into operands[0] as a fullword.  */\n+static void\n+emit_movsi (rtx operands[2])\n+{\n+  operands[0] = copy_operand (operands[0], SImode);\n+  operands[1] = copy_operand (operands[1], SImode);\n+\n+  emit_insn (gen_movsi (operands[0], operands[1]));\n+}\n+\n+/* Output assembler code to perform a doubleword move insn\n+   with operands OPERANDS.  */\n+const char *\n+output_move_double (rtx *operands)\n+{\n+  handle_move_double (operands,\n+\t\t      output_reg_adjust, output_compadr, output_movsi);\n+\n   return \"\";\n }\n \n+/* Output rtl code to perform a doubleword move insn\n+   with operands OPERANDS.  */\n+void\n+m68k_emit_move_double (rtx operands[2])\n+{\n+  handle_move_double (operands, emit_reg_adjust, emit_movsi, emit_movsi);\n+}\n \n /* Ensure mode of ORIG, a REG rtx, is MODE.  Returns either ORIG or a\n    new rtx with the correct mode.  */\n@@ -4432,3 +4587,455 @@ m68k_return_in_memory (tree type, tree fntype ATTRIBUTE_UNUSED)\n   return false;\n }\n #endif\n+\n+/* CPU to schedule the program for.  */\n+enum attr_cpu m68k_sched_cpu;\n+\n+/* Operand type.  */\n+enum attr_op_type\n+  {\n+    /* No operand.  */\n+    OP_TYPE_NONE,\n+\n+    /* Register.  */\n+    OP_TYPE_REG,\n+\n+    /* Implicit mem reference (e.g. stack).  */\n+    OP_TYPE_MEM1,\n+\n+    /* Memory without offset or indexing.  EA modes 2, 3 and 4.  */\n+    OP_TYPE_MEM234,\n+\n+    /* Memory with offset but without indexing.  EA mode 5.  */\n+    OP_TYPE_MEM5,\n+\n+    /* Memory with indexing.  EA mode 6.  */\n+    OP_TYPE_MEM6,\n+\n+    /* Memory referenced by absolute address.  EA mode 7.  */\n+    OP_TYPE_MEM7,\n+\n+    /* Immediate operand that doesn't require extension word.  */\n+    OP_TYPE_IMM_Q,\n+\n+    /* Immediate 16 bit operand.  */\n+    OP_TYPE_IMM_W,\n+\n+    /* Immediate 32 bit operand.  */\n+    OP_TYPE_IMM_L\n+  };\n+\n+/* True if current insn doesn't have complete pipeline description.  */\n+static bool sched_guess_p;\n+\n+/* Return type of memory ADDR_RTX refers to.  */\n+static enum attr_op_type\n+sched_address_type (enum machine_mode mode, rtx addr_rtx)\n+{\n+  struct m68k_address address;\n+\n+  if (!m68k_decompose_address (mode, addr_rtx,\n+\t\t\t       reload_completed, &address))\n+    {\n+      gcc_assert (sched_guess_p);\n+      /* Reload will likely fix the address to be in the register.  */\n+      return OP_TYPE_MEM234;\n+    }\n+\n+  if (address.scale != 0)\n+    return OP_TYPE_MEM6;\n+\n+  if (address.base != NULL_RTX)\n+    {\n+      if (address.offset == NULL_RTX)\n+\treturn OP_TYPE_MEM234;\n+\n+      return OP_TYPE_MEM5;\n+    }\n+\n+  gcc_assert (address.offset != NULL_RTX);\n+\n+  return OP_TYPE_MEM7;\n+}\n+\n+/* Return type of the operand OP.\n+   If ADDRESS_P is true, return type of memory location OP refers to.  */\n+static enum attr_op_type\n+sched_operand_type (rtx op, bool address_p)\n+{\n+  gcc_assert (op != NULL_RTX);\n+\n+  if (address_p)\n+    return sched_address_type (QImode, op);\n+\n+  if (memory_operand (op, VOIDmode))\n+    return sched_address_type (GET_MODE (op), XEXP (op, 0));\n+\n+  if (register_operand (op, VOIDmode))\n+    return OP_TYPE_REG;\n+\n+  if (GET_CODE (op) == CONST_INT)\n+    {\n+      /* ??? Below condition should probably check if the operation is\n+\t signed or unsigned.  */\n+      if (IN_RANGE (INTVAL (op), -0x8000, 0x7fff))\n+\treturn OP_TYPE_IMM_W;\n+\n+      return OP_TYPE_IMM_L;\n+    }\n+\n+  if (GET_CODE (op) == CONST_DOUBLE)\n+    {\n+      switch (GET_MODE (op))\n+\t{\n+\tcase SFmode:\n+\t  return OP_TYPE_IMM_W;\n+\n+\tcase VOIDmode:\n+\tcase DFmode:\n+\t  return OP_TYPE_IMM_L;\n+\n+\tdefault:\n+\t  gcc_unreachable ();\n+\t}\n+    }\n+\n+  if (symbolic_operand (op, VOIDmode)\n+      || LABEL_P (op))\n+    {\n+      switch (GET_MODE (op))\n+\t{\n+\tcase QImode:\n+\t  return OP_TYPE_IMM_Q;\n+\n+\tcase HImode:\n+\t  return OP_TYPE_IMM_W;\n+\n+\tcase SImode:\n+\t  return OP_TYPE_IMM_L;\n+\n+\tdefault:\n+\t  if (GET_CODE (op) == SYMBOL_REF)\n+\t    /* ??? Just a guess.  Probably we can guess better using length\n+\t       attribute of the instructions.  */\n+\t    return OP_TYPE_IMM_W;\n+\n+\t  return OP_TYPE_IMM_L;\n+\t}\n+    }\n+\n+  gcc_assert (sched_guess_p);\n+\n+  return OP_TYPE_REG;\n+}\n+\n+/* Return type of INSN's operand X (if OPX_P) or operand Y (if !OPX_P).\n+   If ADDRESS_P is true, return type of memory location operand refers to.  */\n+static enum attr_op_type\n+sched_attr_op_type (rtx insn, bool opx_p, bool address_p)\n+{\n+  int i;\n+\n+  extract_constrain_insn_cached (insn);\n+\n+  if (opx_p)\n+    i = get_attr_opx (insn);\n+  else\n+    i = get_attr_opy (insn);\n+\n+  if (i >= recog_data.n_operands)\n+    {\n+      gcc_assert (sched_guess_p);\n+      return OP_TYPE_REG;\n+    }\n+\n+  return sched_operand_type (recog_data.operand[i], address_p);\n+}\n+\n+/* Implement opx_type attribute.\n+   Return type of INSN's operand X.\n+   If ADDRESS_P is true, return type of memory location operand refers to.  */\n+enum attr_opx_type\n+m68k_sched_attr_opx_type (rtx insn, int address_p)\n+{\n+  sched_guess_p = (get_attr_guess (insn) == GUESS_YES);\n+\n+  switch (sched_attr_op_type (insn, true, address_p != 0))\n+    {\n+    case OP_TYPE_REG:\n+      return OPX_TYPE_REG;\n+\n+    case OP_TYPE_MEM1:\n+      return OPX_TYPE_MEM1;\n+\n+    case OP_TYPE_MEM234:\n+      return OPX_TYPE_MEM234;\n+\n+    case OP_TYPE_MEM5:\n+      return OPX_TYPE_MEM5;\n+\n+    case OP_TYPE_MEM6:\n+      return OPX_TYPE_MEM6;\n+\n+    case OP_TYPE_MEM7:\n+      return OPX_TYPE_MEM7;\n+\n+    case OP_TYPE_IMM_Q:\n+      return OPX_TYPE_IMM_Q;\n+\n+    case OP_TYPE_IMM_W:\n+      return OPX_TYPE_IMM_W;\n+\n+    case OP_TYPE_IMM_L:\n+      return OPX_TYPE_IMM_L;\n+\n+    default:\n+      gcc_unreachable ();\n+      return 0;\n+    }\n+}\n+\n+/* Implement opy_type attribute.\n+   Return type of INSN's operand Y.\n+   If ADDRESS_P is true, return type of memory location operand refers to.  */\n+enum attr_opy_type\n+m68k_sched_attr_opy_type (rtx insn, int address_p)\n+{\n+  sched_guess_p = (get_attr_guess (insn) == GUESS_YES);\n+\n+  switch (sched_attr_op_type (insn, false, address_p != 0))\n+    {\n+    case OP_TYPE_REG:\n+      return OPY_TYPE_REG;\n+\n+    case OP_TYPE_MEM1:\n+      return OPY_TYPE_MEM1;\n+\n+    case OP_TYPE_MEM234:\n+      return OPY_TYPE_MEM234;\n+\n+    case OP_TYPE_MEM5:\n+      return OPY_TYPE_MEM5;\n+\n+    case OP_TYPE_MEM6:\n+      return OPY_TYPE_MEM6;\n+\n+    case OP_TYPE_MEM7:\n+      return OPY_TYPE_MEM7;\n+\n+    case OP_TYPE_IMM_Q:\n+      return OPY_TYPE_IMM_Q;\n+\n+    case OP_TYPE_IMM_W:\n+      return OPY_TYPE_IMM_W;\n+\n+    case OP_TYPE_IMM_L:\n+      return OPY_TYPE_IMM_L;\n+\n+    default:\n+      gcc_unreachable ();\n+      return 0;\n+    }\n+}\n+\n+/* Return the size of INSN.  */\n+int\n+m68k_sched_attr_size (rtx insn)\n+{\n+  int size;\n+\n+  sched_guess_p = (get_attr_guess (insn) == GUESS_YES);\n+\n+  switch (get_attr_type1 (insn))\n+    {\n+    case TYPE1_MUL_L:\n+      size = 2;\n+      break;\n+\n+    default:\n+      size = 1;\n+      break;\n+    }\n+\n+  switch (get_attr_opx_type (insn))\n+    {\n+    case OPX_TYPE_NONE:\n+    case OPX_TYPE_REG:\n+    case OPX_TYPE_MEM1:\n+    case OPX_TYPE_MEM234:\n+    case OPY_TYPE_IMM_Q:\n+      break;\n+\n+    case OPX_TYPE_MEM5:\n+    case OPX_TYPE_MEM6:\n+      /* Here we assume that most absolute references are short.  */\n+    case OPX_TYPE_MEM7:\n+    case OPY_TYPE_IMM_W:\n+      ++size;\n+      break;\n+\n+    case OPY_TYPE_IMM_L:\n+      size += 2;\n+      break;\n+\n+    default:\n+      gcc_unreachable ();\n+    }\n+\n+  switch (get_attr_opy_type (insn))\n+    {\n+    case OPY_TYPE_NONE:\n+    case OPY_TYPE_REG:\n+    case OPY_TYPE_MEM1:\n+    case OPY_TYPE_MEM234:\n+    case OPY_TYPE_IMM_Q:\n+      break;\n+\n+    case OPY_TYPE_MEM5:\n+    case OPY_TYPE_MEM6:\n+      /* Here we assume that most absolute references are short.  */\n+    case OPY_TYPE_MEM7:\n+    case OPY_TYPE_IMM_W:\n+      ++size;\n+      break;\n+\n+    case OPY_TYPE_IMM_L:\n+      size += 2;\n+      break;\n+\n+    default:\n+      gcc_unreachable ();\n+    }\n+\n+  if (size > 3)\n+    {\n+      gcc_assert (sched_guess_p);\n+\n+      size = 3;\n+    }\n+\n+  return size;\n+}\n+\n+/* Implement op_mem attribute.  */\n+enum attr_op_mem\n+m68k_sched_attr_op_mem (rtx insn)\n+{\n+  enum attr_opy_mem opy;\n+  enum attr_opx_mem opx;\n+\n+  sched_guess_p = (get_attr_guess (insn) == GUESS_YES);\n+\n+  opy = get_attr_opy_mem (insn);\n+  opx = get_attr_opx_mem (insn);\n+\n+  if (opy == OPY_MEM_R && opx == OPX_MEM_R)\n+    return OP_MEM_00;\n+\n+  if (opy == OPY_MEM_R && opx == OPX_MEM_M)\n+    {\n+      switch (get_attr_opx_access (insn))\n+\t{\n+\tcase OPX_ACCESS_R:\n+\t  return OP_MEM_10;\n+\n+\tcase OPX_ACCESS_W:\n+\t  return OP_MEM_01;\n+\n+\tcase OPX_ACCESS_RW:\n+\t  return OP_MEM_11;\n+\n+\tdefault:\n+\t  gcc_assert (sched_guess_p);\n+\t  return OP_MEM_UNKNOWN;\n+\t}\n+    }\n+\n+  if (opy == OPY_MEM_R && opx == OPX_MEM_I)\n+    {\n+      switch (get_attr_opx_access (insn))\n+\t{\n+\tcase OPX_ACCESS_R:\n+\t  return OP_MEM_I0;\n+\n+\tcase OPX_ACCESS_W:\n+\t  return OP_MEM_0I;\n+\n+\tcase OPX_ACCESS_RW:\n+\t  return OP_MEM_I1;\n+\n+\tdefault:\n+\t  gcc_assert (sched_guess_p);\n+\t  return OP_MEM_UNKNOWN;\n+\t}\n+    }\n+\n+  if (opy == OPY_MEM_M && opx == OPX_MEM_R)\n+    return OP_MEM_10;\n+\n+  if (opy == OPY_MEM_M && opx == OPX_MEM_M)\n+    {\n+      switch (get_attr_opx_access (insn))\n+\t{\n+\tcase OPX_ACCESS_W:\n+\t  return OP_MEM_11;\n+\n+\tdefault:\n+\t  gcc_assert (sched_guess_p);\n+\t  return OP_MEM_UNKNOWN;\n+\t}\n+    }\n+\n+  if (opy == OPY_MEM_M && opx == OPX_MEM_I)\n+    {\n+      switch (get_attr_opx_access (insn))\n+\t{\n+\tcase OPX_ACCESS_W:\n+\t  return OP_MEM_1I;\n+\n+\tdefault:\n+\t  gcc_assert (sched_guess_p);\n+\t  return OP_MEM_UNKNOWN;\n+\t}\n+    }\n+\n+  if (opy == OPY_MEM_I && opx == OPX_MEM_R)\n+    return OP_MEM_I0;\n+\n+\n+  if (opy == OPY_MEM_I && opx == OPX_MEM_M)\n+    {\n+      switch (get_attr_opx_access (insn))\n+\t{\n+\tcase OPX_ACCESS_W:\n+\t  return OP_MEM_I1;\n+\n+\tdefault:\n+\t  gcc_assert (sched_guess_p);\n+\t  return OP_MEM_UNKNOWN;\n+\t}\n+    }\n+\n+  gcc_assert (sched_guess_p);\n+  return OP_MEM_UNKNOWN;\n+}\n+\n+/* Jump instructions types.  Indexed by INSN_UID.\n+   The same rtl insn can be expanded into different asm instructions\n+   depending on the cc0_status.  To properly determine type of jump\n+   instructions we scan instruction stream and map jumps types to this\n+   array.  */\n+static enum attr_type *sched_branch_type;\n+\n+/* Return the type of the jump insn.  */\n+enum attr_type\n+m68k_sched_branch_type (rtx insn)\n+{\n+  enum attr_type type;\n+\n+  type = sched_branch_type[INSN_UID (insn)];\n+\n+  gcc_assert (type != 0);\n+\n+  return type;\n+}"}, {"sha": "3767413e18baf70bb340affddc5c571bc032b022", "filename": "gcc/config/m68k/m68k.h", "status": "modified", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c47b0cb46626dd1df1aad35c5d1ee9f5be43debe/gcc%2Fconfig%2Fm68k%2Fm68k.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c47b0cb46626dd1df1aad35c5d1ee9f5be43debe/gcc%2Fconfig%2Fm68k%2Fm68k.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm68k%2Fm68k.h?ref=c47b0cb46626dd1df1aad35c5d1ee9f5be43debe", "patch": "@@ -1125,3 +1125,27 @@ extern enum fpu_type m68k_fpu;\n extern unsigned int m68k_cpu_flags;\n extern const char *m68k_symbolic_call;\n extern const char *m68k_symbolic_jump;\n+\n+enum M68K_SYMBOLIC_CALL { M68K_SYMBOLIC_CALL_NONE, M68K_SYMBOLIC_CALL_JSR,\n+\t\t\t  M68K_SYMBOLIC_CALL_BSR_C, M68K_SYMBOLIC_CALL_BSR_P };\n+\n+extern enum M68K_SYMBOLIC_CALL m68k_symbolic_call_var;\n+\n+/* ??? HOST_WIDE_INT is not being defined for auto-generated files.\n+   Workaround that.  */\n+#ifdef HOST_WIDE_INT\n+typedef enum { MOVL, SWAP, NEGW, NOTW, NOTB, MOVQ, MVS, MVZ }\n+  M68K_CONST_METHOD;\n+\n+extern M68K_CONST_METHOD m68k_const_method (HOST_WIDE_INT);\n+#endif\n+\n+extern void m68k_emit_move_double (rtx [2]);\n+\n+extern enum attr_cpu m68k_sched_cpu;\n+\n+extern enum attr_opx_type m68k_sched_attr_opx_type (rtx, int);\n+extern enum attr_opy_type m68k_sched_attr_opy_type (rtx, int);\n+extern int m68k_sched_attr_size (rtx);\n+extern enum attr_op_mem m68k_sched_attr_op_mem (rtx);\n+extern enum attr_type m68k_sched_branch_type (rtx);"}, {"sha": "63c0a0edba259f9058d7d5f8a1e299df6f651a92", "filename": "gcc/config/m68k/m68k.md", "status": "modified", "additions": 664, "deletions": 191, "changes": 855, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c47b0cb46626dd1df1aad35c5d1ee9f5be43debe/gcc%2Fconfig%2Fm68k%2Fm68k.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c47b0cb46626dd1df1aad35c5d1ee9f5be43debe/gcc%2Fconfig%2Fm68k%2Fm68k.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm68k%2Fm68k.md?ref=c47b0cb46626dd1df1aad35c5d1ee9f5be43debe", "patch": "@@ -114,6 +114,7 @@\n   [(UNSPEC_SIN 1)\n    (UNSPEC_COS 2)\n    (UNSPEC_GOT 3)\n+   (UNSPEC_IB 4)\n   ])\n \n ;; UNSPEC_VOLATILE usage:\n@@ -136,6 +137,205 @@\n (include \"predicates.md\")\n (include \"constraints.md\")\n \f\n+;; ::::::::::::::::::::\n+;; ::\n+;; :: Attributes\n+;; ::\n+;; ::::::::::::::::::::\n+\n+;; Processor type.\n+(define_attr \"cpu\" \"cf_v2, unknown\" (const (symbol_ref \"m68k_sched_cpu\")))\n+\n+;; Instruction type.\n+;; Basically, an asm pattern.\n+(define_attr \"type\"\n+  \"add_l, addq_l, asr_l, bcc, bclr, bra, bset, bsr,\n+   clr_b, clr_w, clr_l, cmp_l,\n+   ext_w, extb_l, ext_l,\n+   fadd, fcmp, fdiv, ff1, fintrz, fmove, fmul, fsqrt, fsub, ftst, jmp, jsr,\n+   ib,\n+   lea, lsr_l,\n+   move_b, move_w, move_l, moveq_l, mov3q_l, mvs_b, mvs_w, mvz_b, mvz_w,\n+   muls_w, muls_l, mulu_w, mulu_l,\n+   neg_l, nop, not_l,\n+   pea, rts,\n+   scc, sub_l, subq_l,\n+   trap, tst_b, tst_l, tst_w,\n+   unlk, unknown\"\n+  (const_string \"unknown\"))\n+\n+;; Instruction type for use in scheduling description.\n+;; _l and _w suffixes indicate size of the operands of instruction.\n+;; alu - usual arithmetic or logic instruction.\n+;; alu_reg1 - arithmetic or logic instruction with one operand that is\n+;;            a register.\n+;; alu_regx - arithmetic or logic instruction which has a register for its\n+;;            X operand.\n+;; aluq - arithmetic or logic instruction which has a quick immediate (the one\n+;;        that is encoded in the instruction word) for its Y operand.\n+;; <all other values> - corresponding asm instructions.\n+(define_attr \"type1\"\n+  \"alu_l, alu_reg1, alu_regx, aluq_l, bcc, bra, bsr, clr, cmp_l, jmp, jsr, lea,\n+   mov3q_l, move, move_l, moveq_l, mul_l, mul_w, pea, rts, tst, tst_l, unlk,\n+   unknown\"\n+  (cond [(eq_attr \"type\" \"add_l,sub_l\") (const_string \"alu_l\")\n+\t (eq_attr \"type\" \"ext_w,extb_l,ext_l,neg_l,not_l\")\n+\t (const_string \"alu_reg1\")\n+\t (eq_attr \"type\" \"asr_l,lsr_l\") (const_string \"alu_regx\")\n+\t (eq_attr \"type\" \"addq_l,subq_l\") (const_string \"aluq_l\")\n+\t (eq_attr \"type\" \"bcc\") (const_string \"bcc\")\n+\t (eq_attr \"type\" \"bra\") (const_string \"bra\")\n+\t (eq_attr \"type\" \"bsr\") (const_string \"bsr\")\n+\t (eq_attr \"type\" \"clr_b,clr_l,clr_w\") (const_string \"clr\")\n+\t (eq_attr \"type\" \"cmp_l\") (const_string \"cmp_l\")\n+\t (eq_attr \"type\" \"jmp\") (const_string \"jmp\")\n+\t (eq_attr \"type\" \"jsr\") (const_string \"jsr\")\n+\t (eq_attr \"type\" \"lea\") (const_string \"lea\")\n+\t (eq_attr \"type\" \"mov3q_l\") (const_string \"mov3q_l\")\n+\t (eq_attr \"type\" \"move_b,move_w\") (const_string \"move\")\n+\t (eq_attr \"type\" \"move_l\") (const_string \"move_l\")\n+\t (eq_attr \"type\" \"moveq_l\") (const_string \"moveq_l\")\n+\t (eq_attr \"type\" \"muls_l,mulu_l\") (const_string \"mul_l\")\n+\t (eq_attr \"type\" \"muls_w,mulu_w\") (const_string \"mul_w\")\n+\t (eq_attr \"type\" \"pea\") (const_string \"pea\")\n+\t (eq_attr \"type\" \"rts\") (const_string \"rts\")\n+\t (eq_attr \"type\" \"tst_b,tst_w\") (const_string \"tst\")\n+\t (eq_attr \"type\" \"tst_l\") (const_string \"tst_l\")\n+\t (eq_attr \"type\" \"unlk\") (const_string \"unlk\")]\n+\t(const_string \"unknown\")))\n+\n+;; Index of the X or Y operand in recog_data.operand[].\n+;; Should be used only within opx_type and opy_type.\n+(define_attr \"opx\" \"\" (const_int 0))\n+(define_attr \"opy\" \"\" (const_int 1))\n+\n+;; Type of the X operand.\n+;; See m68k.c: enum attr_op_type.\n+(define_attr \"opx_type\"\n+  \"none, reg, mem1, mem234, mem5, mem6, mem7, imm_q, imm_w, imm_l\"\n+  (cond [(eq_attr \"type1\" \"rts,unlk\") (const_string \"none\")\n+\t (eq_attr \"type1\" \"alu_reg1,alu_regx,lea,moveq_l,mul_l,mul_w\")\n+\t (const_string \"reg\")\n+\t (eq_attr \"type1\" \"pea\") (const_string \"mem1\")\n+\t (eq_attr \"type1\" \"bcc\") (const_string \"imm_q\")\n+\t (eq_attr \"type1\" \"bra,bsr\") (const_string \"imm_w\")\n+\t (eq_attr \"type1\" \"jmp,jsr\")\n+\t (symbol_ref \"m68k_sched_attr_opx_type (insn, 1)\")]\n+\t(symbol_ref \"m68k_sched_attr_opx_type (insn, 0)\")))\n+\n+;; Type of the Y operand.\n+;; See m68k.c: enum attr_op_type.\n+(define_attr \"opy_type\"\n+  \"none, reg, mem1, mem234, mem5, mem6, mem7, imm_q, imm_w, imm_l\"\n+  (cond [(eq_attr \"type1\" \"alu_reg1,bcc,bra,bsr,clr,jmp,jsr,rts,tst,tst_l,\n+                           unlk\") (const_string \"none\")\n+\t (eq_attr \"type1\" \"mov3q_l,moveq_l,aluq_l\") (const_string \"imm_q\")\n+\t (eq_attr \"type1\" \"lea,pea\")\n+\t (symbol_ref \"m68k_sched_attr_opy_type (insn, 1)\")]\n+\t(symbol_ref \"m68k_sched_attr_opy_type (insn, 0)\")))\n+\n+;; Instruction size in words.\n+(define_attr \"size\" \"\"\n+  (cond [(eq_attr \"type1\" \"alu_reg1,moveq_l,rts,unlk\") (const_int 1)]\n+\t(symbol_ref \"m68k_sched_attr_size (insn)\")))\n+\n+;; Access to the X operand: none, read, write, read/write, unknown.\n+;; Access to the Y operand is either none (if opy_type is none)\n+;; or read otherwise.\n+(define_attr \"opx_access\" \"none, r, w, rw, unknown\"\n+  (cond [(eq_attr \"type1\" \"rts,unlk\") (const_string \"none\")\n+\t (eq_attr \"type1\" \"bcc,bra,bsr,cmp_l,jmp,jsr,tst,tst_l\")\n+\t (const_string \"r\")\n+\t (eq_attr \"type1\" \"clr,lea,mov3q_l,move,move_l,moveq_l,pea\")\n+\t (const_string \"w\")\n+\t (eq_attr \"type1\" \"alu_l,alu_reg1,alu_regx,aluq_l\")\n+\t (const_string \"rw\")]\n+\t(const_string \"unknown\")))\n+\n+;; Memory relation of operands:\n+;; r - register or immediate operand\n+;; m - non-indexed memory location\n+;; i - indexed memory location\n+\n+(define_attr \"opx_mem\" \"r, m, i, unknown\"\n+  (cond [(eq_attr \"opx_type\" \"none,reg,imm_q,imm_w,imm_l\") (const_string \"r\")\n+\t (eq_attr \"opx_type\" \"mem1,mem234,mem5,mem7\") (const_string \"m\")\n+\t (eq_attr \"opx_type\" \"mem6\") (const_string \"i\")]\n+\t(const_string \"unknown\")))\n+\n+(define_attr \"opy_mem\" \"r, m, i, unknown\"\n+  (cond [(eq_attr \"opy_type\" \"none,reg,imm_q,imm_w,imm_l\") (const_string \"r\")\n+\t (eq_attr \"opy_type\" \"mem1,mem234,mem5,mem7\") (const_string \"m\")\n+\t (eq_attr \"opy_type\" \"mem6\") (const_string \"i\")]\n+\t(const_string \"unknown\")))\n+\n+;; Memory accesses of the insn.\n+;; 00 - no memory references\n+;; 10 - memory is read\n+;; i10 - indexed memory is read\n+;; 01 - memory is written\n+;; 0i1 - indexed memory is written\n+;; 11 - memory is read, memory is written\n+;; i11 - indexed memory is read, memory is written\n+;; 1i1 - memory is read, indexed memory is written\n+;;\n+;; unknown - should now occur on normal insn.\n+;; ??? This attribute is implemented in C to spare genattrtab from\n+;; ??? optimizing it.\n+(define_attr \"op_mem\" \"00, 10, i0, 01, 0i, 11, i1, 1i, unknown\"\n+;  (cond [(and (eq_attr \"opy_mem\" \"r\") (eq_attr \"opx_mem\" \"r\"))\n+;\t (const_string \"00\")\n+;\n+;\t (and (eq_attr \"opy_mem\" \"r\") (eq_attr \"opx_mem\" \"m\"))\n+;\t (cond [(eq_attr \"opx_access\" \"r\") (const_string \"10\")\n+;\t        (eq_attr \"opx_access\" \"w\") (const_string \"01\")\n+;\t        (eq_attr \"opx_access\" \"rw\") (const_string \"11\")]\n+;\t       (const_string \"unknown\"))\n+;\n+;\t (and (eq_attr \"opy_mem\" \"r\") (eq_attr \"opx_mem\" \"i\"))\n+;\t (cond [(eq_attr \"opx_access\" \"r\") (const_string \"i0\")\n+;\t        (eq_attr \"opx_access\" \"w\") (const_string \"0i\")\n+;\t\t(eq_attr \"opx_access\" \"rw\") (const_string \"i1\")]\n+;\t       (const_string \"unknown\"))\n+;\n+;\t (and (eq_attr \"opy_mem\" \"m\") (eq_attr \"opx_mem\" \"r\"))\n+;\t (const_string \"10\")\n+;\n+;\t (and (eq_attr \"opy_mem\" \"m\") (eq_attr \"opx_mem\" \"m\"))\n+;\t (cond [(eq_attr \"opx_access\" \"w\") (const_string \"11\")]\n+;\t       (const_string \"unknown\"))\n+;\n+;\t (and (eq_attr \"opy_mem\" \"m\") (eq_attr \"opx_mem\" \"i\"))\n+;\t (cond [(eq_attr \"opx_access\" \"w\") (const_string \"1i\")]\n+;\t       (const_string \"unknown\"))\n+;\n+;\t (and (eq_attr \"opy_mem\" \"i\") (eq_attr \"opx_mem\" \"r\"))\n+;\t (const_string \"i0\")\n+;\n+;\t (and (eq_attr \"opy_mem\" \"i\") (eq_attr \"opx_mem\" \"m\"))\n+;\t (cond [(eq_attr \"opx_access\" \"w\") (const_string \"i1\")]\n+;\t       (const_string \"unknown\"))]\n+;\t(const_string \"unknown\"))\n+  (symbol_ref \"m68k_sched_attr_op_mem (insn)\"))\n+\n+;; Attribute to support partial automata description.\n+;; This attribute has value 'yes' for instructions that are not\n+;; fully handled yet.\n+(define_attr \"guess\" \"yes, no\"\n+  (cond [(ior (eq (symbol_ref \"reload_completed\") (const_int 0))\n+\t      (eq_attr \"type1\" \"unknown\"))\n+\t (const_string \"yes\")]\n+\t(const_string \"no\")))\n+\n+;; Attribute to support statistics gathering.\n+;; Todo means that insn lacks something to get pipeline description.\n+;; Done means that insn was transformed to suit pipeline description.\n+;; Nothing means that insn was originally good enough for scheduling. \n+(define_attr \"split\" \"todo, done, nothing\"\n+  (if_then_else (eq_attr \"type\" \"unknown\")\n+\t\t(const_string \"todo\")\n+\t\t(const_string \"nothing\")))\n+\f\n ;; Mode macros for floating point operations.\n ;; Valid floating point modes\n (define_mode_iterator FP [SF DF (XF \"TARGET_68881\")])\n@@ -150,22 +350,33 @@\n ;; Allowable 68881 constant constraints\n (define_mode_attr const [(SF \"F\") (DF \"G\") (XF \"\")])\n \f\n-(define_insn \"\"\n-  [(set (match_operand:DF 0 \"push_operand\" \"=m\")\n-\t(match_operand:DF 1 \"general_operand\" \"ro<>fE\"))]\n+\n+(define_insn_and_split \"*movdf_internal\"\n+  [(set (match_operand:DF 0 \"push_operand\"   \"=m, m\")\n+\t(match_operand:DF 1 \"general_operand\" \"f, ro<>E\"))]\n   \"\"\n+  \"@\n+   fmove%.d %f1,%0\n+   #\"\n+  \"&& reload_completed && (extract_constrain_insn_cached (insn), which_alternative == 1)\"\n+  [(const_int 0)]\n {\n-  if (FP_REG_P (operands[1]))\n-    return \"fmove%.d %f1,%0\";\n-  return output_move_double (operands);\n-})\n+  m68k_emit_move_double (operands);\n+  DONE;\n+}\n+  [(set_attr \"type\" \"fmove,*\")\n+   (set_attr \"split\" \"done,*\")])\n \n-(define_insn \"pushdi\"\n+(define_insn_and_split \"pushdi\"\n   [(set (match_operand:DI 0 \"push_operand\" \"=m\")\n \t(match_operand:DI 1 \"general_operand\" \"ro<>Fi\"))]\n   \"\"\n+  \"#\"\n+  \"&& reload_completed\"\n+  [(const_int 0)]\n {\n-  return output_move_double (operands);\n+  m68k_emit_move_double (operands);\n+  DONE;\n })\n \f\n ;; We don't want to allow a constant operand for test insns because\n@@ -194,12 +405,12 @@\n       xoperands[0] = operands[2];\n       xoperands[1] = operands[0];\n       output_move_double (xoperands);\n-      cc_status.flags |= CC_REVERSED;\n+      cc_status.flags |= CC_REVERSED; /*|*/\n       return \"neg%.l %R2\\;negx%.l %2\";\n     }\n   if (find_reg_note (insn, REG_DEAD, operands[0]))\n     {\n-      cc_status.flags |= CC_REVERSED;\n+      cc_status.flags |= CC_REVERSED; /*|*/\n       return \"neg%.l %R0\\;negx%.l %0\";\n     }\n   else\n@@ -217,18 +428,24 @@\n   \"\"\n   \"m68k_last_compare_had_fp_operands = 0;\")\n \n-(define_insn \"\"\n+;; If you think that the 68020 does not support tstl a0,\n+;; reread page B-167 of the 68020 manual more carefully.\n+(define_insn \"*tstsi_internal_68020_cf\"\n   [(set (cc0)\n \t(match_operand:SI 0 \"nonimmediate_operand\" \"rm\"))]\n-  \"\"\n-{\n-  if (TARGET_68020 || TARGET_COLDFIRE || ! ADDRESS_REG_P (operands[0]))\n-    return \"tst%.l %0\";\n-  /* If you think that the 68020 does not support tstl a0,\n-     reread page B-167 of the 68020 manual more carefully.  */\n-  /* On an address reg, cmpw may replace cmpl.  */\n-  return \"cmp%.w #0,%0\";\n-})\n+  \"TARGET_68020 || TARGET_COLDFIRE\"\n+  \"tst%.l %0\"\n+  [(set_attr \"type\" \"tst_l\")])\n+\n+;; On an address reg, cmpw may replace cmpl.\n+(define_insn \"*tstsi_internal\"\n+  [(set (cc0)\n+\t(match_operand:SI 0 \"nonimmediate_operand\" \"dm,r\"))]\n+  \"!(TARGET_68020 || TARGET_COLDFIRE)\"\n+  \"@\n+   tst%.l %0\n+   cmp%.w #0,%0\"\n+  [(set_attr \"type\" \"tst_l,*\")])\n \n ;; This can't use an address register, because comparisons\n ;; with address registers as second operand always test the whole word.\n@@ -238,23 +455,25 @@\n   \"\"\n   \"m68k_last_compare_had_fp_operands = 0;\")\n \n-(define_insn \"\"\n+(define_insn \"*tsthi_internal\"\n   [(set (cc0)\n \t(match_operand:HI 0 \"nonimmediate_operand\" \"dm\"))]\n   \"\"\n-  \"tst%.w %0\")\n+  \"tst%.w %0\"\n+  [(set_attr \"type\" \"tst_w\")])\n \n (define_expand \"tstqi\"\n   [(set (cc0)\n \t(match_operand:QI 0 \"nonimmediate_operand\" \"\"))]\n   \"\"\n   \"m68k_last_compare_had_fp_operands = 0;\")\n \n-(define_insn \"\"\n+(define_insn \"*tstqi_internal\"\n   [(set (cc0)\n \t(match_operand:QI 0 \"nonimmediate_operand\" \"dm\"))]\n   \"\"\n-  \"tst%.b %0\")\n+  \"tst%.b %0\"\n+  [(set_attr \"type\" \"tst_b\")])\n \n (define_expand \"tst<mode>\"\n   [(set (cc0)\n@@ -284,7 +503,8 @@\n   if (FP_REG_P (operands[0]))\n     return \"ftst%.d %0\";\n   return \"ftst%.<FP:prec> %0\";\n-})\n+}\n+  [(set_attr \"type\" \"ftst\")])\n \n \f\n ;; compare instructions.\n@@ -309,7 +529,7 @@\n     return \"sub%.l %R2,%R0\\;subx%.l %2,%0\";\n   else\n     {\n-      cc_status.flags |= CC_REVERSED;\n+      cc_status.flags |= CC_REVERSED; /*|*/\n       return \"sub%.l %R1,%R0\\;subx%.l %1,%0\";\n     }\n })\n@@ -335,7 +555,7 @@\n   if (REG_P (operands[1])\n       || (!REG_P (operands[0]) && GET_CODE (operands[0]) != MEM))\n     {\n-      cc_status.flags |= CC_REVERSED;\n+      cc_status.flags |= CC_REVERSED; /*|*/\n       return \"cmp%.l %d0,%d1\";\n     }\n   if (ADDRESS_REG_P (operands[0])\n@@ -346,7 +566,7 @@\n   return \"cmp%.l %d1,%d0\";\n })\n \n-(define_insn \"\"\n+(define_insn \"*cmpsi_cf\"\n   [(set (cc0)\n \t(compare (match_operand:SI 0 \"nonimmediate_operand\" \"mrKs,r\")\n \t\t (match_operand:SI 1 \"general_operand\" \"r,mrKs\")))]\n@@ -355,11 +575,12 @@\n   if (REG_P (operands[1])\n       || (!REG_P (operands[0]) && GET_CODE (operands[0]) != MEM))\n     {\n-      cc_status.flags |= CC_REVERSED;\n+      cc_status.flags |= CC_REVERSED; /*|*/\n       return \"cmp%.l %d0,%d1\";\n     }\n   return \"cmp%.l %d1,%d0\";\n-})\n+}\n+  [(set_attr \"type\" \"cmp_l\")])\n \n (define_expand \"cmphi\"\n   [(set (cc0)\n@@ -403,7 +624,7 @@\n   if (REG_P (operands[1])\n       || (!REG_P (operands[0]) && GET_CODE (operands[0]) != MEM))\n     {\n-      cc_status.flags |= CC_REVERSED;\n+      cc_status.flags |= CC_REVERSED; /*|*/\n       return \"cmp%.b %d0,%d1\";\n     }\n   return \"cmp%.b %d1,%d0\";\n@@ -434,9 +655,10 @@\n       else\n         return \"fcmp%.<FP:prec> %f1,%0\";\n     }\n-  cc_status.flags |= CC_REVERSED;\n+  cc_status.flags |= CC_REVERSED; /*|*/\n   return \"fcmp%.<FP:prec> %f0,%1\";\n-})\n+}\n+  [(set_attr \"type\" \"fcmp\")])\n \n (define_insn \"cmp<mode>_cf\"\n   [(set (cc0)\n@@ -452,9 +674,10 @@\n       else\n \treturn \"fcmp%.<FP:prec> %f1,%0\";\n     }\n-  cc_status.flags |= CC_REVERSED;\n+  cc_status.flags |= CC_REVERSED; /*|*/\n   return \"fcmp%.<FP:prec> %f0,%1\";\n-})\n+}\n+  [(set_attr \"type\" \"fcmp\")])\n \f\n ;; Recognizers for btst instructions.\n \n@@ -578,16 +801,15 @@\n ;; A special case in which it is not desirable\n ;; to reload the constant into a data register.\n (define_insn \"pushexthisi_const\"\n-  [(set (match_operand:SI 0 \"push_operand\" \"=m\")\n-\t(match_operand:SI 1 \"const_int_operand\" \"J\"))]\n+  [(set (match_operand:SI 0 \"push_operand\" \"=m,m,m\")\n+\t(match_operand:SI 1 \"const_int_operand\" \"C0,R,J\"))]\n   \"INTVAL (operands[1]) >= -0x8000 && INTVAL (operands[1]) < 0x8000\"\n-{\n-  if (operands[1] == const0_rtx)\n-    return \"clr%.l %0\";\n-  if (valid_mov3q_const (INTVAL (operands[1])))\n-    return \"mov3q%.l %1,%-\";\n-  return \"pea %a1\";\n-})\n+  \"@\n+   clr%.l %0\n+   mov3q%.l %1,%-\n+   pea %a1\"\n+  [(set_attr \"type\" \"clr_l,mov3q_l,pea\")\n+   (set_attr \"split\" \"done\")])\n \n ;This is never used.\n ;(define_insn \"swapsi\"\n@@ -597,30 +819,52 @@\n ;  \"\"\n ;  \"exg %1,%0\")\n \n-;; Special case of fullword move when source is zero.\n-;; The reason this is special is to avoid loading a zero\n-;; into a data reg with moveq in order to store it elsewhere.\n-\n-(define_insn \"movsi_const0\"\n-  [(set (match_operand:SI 0 \"nonimmediate_operand\" \"=g\")\n+;; Special case of fullword move when source is zero for 68000_10.\n+;; moveq is faster on the 68000.\n+(define_insn \"*movsi_const0_68000_10\"\n+  [(set (match_operand:SI 0 \"movsi_const0_operand\" \"=d,a,g\")\n+\t(const_int 0))]\n+  \"TUNE_68000_10\"\n+  \"@\n+   moveq #0,%0\n+   sub%.l %0,%0\n+   clr%.l %0\"\n+  [(set_attr \"type\" \"moveq_l,sub_l,clr_l\")\n+   (set_attr \"opy_type\" \"imm_q,reg,*\")\n+   (set_attr \"split\" \"done\")])\n+\n+;; Special case of fullword move when source is zero for 68040_60.\n+;; On the '040, 'subl an,an' takes 2 clocks while lea takes only 1\n+(define_insn \"*movsi_const0_68040_60\"\n+  [(set (match_operand:SI 0 \"movsi_const0_operand\" \"=a,g\")\n \t(const_int 0))]\n-  ;; clr insns on 68000 read before writing.\n-  \"((TARGET_68010 || TARGET_COLDFIRE)\n-    || !(GET_CODE (operands[0]) == MEM && MEM_VOLATILE_P (operands[0])))\"\n+  \"TUNE_68040_60\"\n {\n-  if (ADDRESS_REG_P (operands[0]))\n+  if (which_alternative == 0)\n+    return MOTOROLA ? \"lea 0.w,%0\" : \"lea 0:w,%0\";\n+  else if (which_alternative == 1)\n+    return \"clr%.l %0\";\n+  else\n     {\n-      /* On the '040, 'subl an,an' takes 2 clocks while lea takes only 1 */\n-      if (TUNE_68040_60)\n-\treturn MOTOROLA ? \"lea 0.w,%0\" : \"lea 0:w,%0\";\n-      else\n-\treturn \"sub%.l %0,%0\";\n+      gcc_unreachable ();\n+      return \"\";\n     }\n-  /* moveq is faster on the 68000.  */\n-  if (DATA_REG_P (operands[0]) && TUNE_68000_10)\n-    return \"moveq #0,%0\";\n-  return \"clr%.l %0\";\n-})\n+}\n+  [(set_attr \"type\" \"lea,clr_l\")\n+   (set_attr \"opy_type\" \"imm_w,*\")\n+   (set_attr \"split\" \"done\")])\n+\n+;; Special case of fullword move when source is zero.\n+(define_insn \"*movsi_const0\"\n+  [(set (match_operand:SI 0 \"movsi_const0_operand\" \"=a,g\")\n+\t(const_int 0))]\n+  \"!(TUNE_68000_10 || TUNE_68040_60)\"\n+  \"@\n+   sub%.l %0,%0\n+   clr%.l %0\"\n+  [(set_attr \"type\" \"sub_l,clr_l\")\n+   (set_attr \"opy_type\" \"reg,*\")\n+   (set_attr \"split\" \"done\")])\n \n ;; General case of fullword move.\n ;;\n@@ -688,10 +932,59 @@\n \n ;; ColdFire move instructions can have at most one operand of mode >= 6.\n (define_insn \"*movsi_cf\"\n-  [(set (match_operand:SI 0 \"nonimmediate_operand\" \"=r<Q>,g,U\")\n-\t(match_operand:SI 1 \"general_operand\" \"g,Rr<Q>,U\"))]\n+  [(set (match_operand:SI 0 \"nonimmediate_operand\" \"=g,d, d, d, d, d, a,Ap,  a,  r<Q>,g,    U\")\n+\t(match_operand:SI 1 \"general_operand\"      \" R,CQ,CW,CZ,CS,Ci,J,J Cs,Cs, g,   Rr<Q>,U\"))]\n   \"TARGET_COLDFIRE\"\n-  \"* return output_move_simode (operands);\")\n+{\n+  switch (which_alternative)\n+    {\n+    case 0:\n+      return \"mov3q%.l %1,%0\";\n+\n+    case 1:\n+      return \"moveq %1,%0\";\n+\n+    case 2:\n+      {\n+\tunsigned u = INTVAL (operands[1]);\n+\n+\toperands[1] = GEN_INT ((u << 16) | (u >> 16));  /*|*/\n+\treturn \"moveq %1,%0\\n\\tswap %0\";\n+      }\n+\n+    case 3:\n+      return \"mvz%.w %1,%0\";\n+\n+    case 4:\n+      return \"mvs%.w %1,%0\";\n+\n+    case 5:\n+      return \"move%.l %1,%0\";\n+\n+    case 6:\n+      return \"move%.w %1,%0\";\n+\n+    case 7:\n+      return \"pea %a1\";\n+\n+    case 8:\n+      return \"lea %a1,%0\";\n+\n+    case 9:\n+    case 10:\n+    case 11:\n+      return \"move%.l %1,%0\";\n+\n+    default:\n+      gcc_unreachable ();\n+      return \"\";\n+    }\n+}\n+  [(set_attr \"type\" \"mov3q_l, moveq_l,*, mvz_w, mvs_w, move_l, move_w, pea, lea, move_l, move_l, move_l\")\n+   (set (attr \"split\")\n+\t(if_then_else (eq_attr \"alternative\" \"2\")\n+\t\t      (const_string \"*\")\n+\t\t      (const_string \"done\")))])\n \n ;; Special case of fullword move, where we need to get a non-GOT PIC\n ;; reference into an address register.\n@@ -771,11 +1064,17 @@\n   \"!TARGET_COLDFIRE\"\n   \"* return output_move_strictqi (operands);\")\n \n-(define_insn \"\"\n-  [(set (strict_low_part (match_operand:QI 0 \"nonimmediate_operand\" \"+d,m\"))\n-\t(match_operand:QI 1 \"general_src_operand\" \"dmn,d\"))]\n+(define_insn \"*movstrictqi_cf\"\n+  [(set (strict_low_part (match_operand:QI 0 \"nonimmediate_operand\" \"+d, Ac, d,m\"))\n+\t(match_operand:QI 1 \"general_src_operand\"                    \"C0,C0, dmn,d\"))]\n   \"TARGET_COLDFIRE\"\n-  \"* return output_move_strictqi (operands);\")\n+  \"@\n+   clr%.b %0\n+   clr%.b %0\n+   move%.b %1,%0\n+   move%.b %1,%0\"\n+  [(set_attr \"type\" \"clr_b,clr_b,move_b,move_b\")\n+   (set_attr \"split\" \"done\")])\n \n (define_expand \"pushqi1\"\n   [(set (reg:SI SP_REG) (plus:SI (reg:SI SP_REG) (const_int -2)))\n@@ -864,9 +1163,8 @@\n   [(set (match_operand:SF 0 \"nonimmediate_operand\" \"=r<Q>,g,U\")\n \t(match_operand:SF 1 \"general_operand\" \"g,r<Q>,U\"))]\n   \"TARGET_COLDFIRE && !TARGET_COLDFIRE_FPU\"\n-{\n-  return \"move%.l %1,%0\";\n-})\n+  \"move%.l %1,%0\"\n+  [(set_attr \"type\" \"move_l\")])\n \n ;; SFmode MEMs are restricted to modes 2-4 if TARGET_COLDFIRE_FPU.\n ;; The move instructions can handle all combinations.\n@@ -1003,12 +1301,16 @@\n   return output_move_double (operands);\n })\n \n-(define_insn \"movdf_cf_soft\"\n+(define_insn_and_split \"movdf_cf_soft\"\n   [(set (match_operand:DF 0 \"nonimmediate_operand\" \"=r,g\")\n \t(match_operand:DF 1 \"general_operand\" \"g,r\"))]\n   \"TARGET_COLDFIRE && !TARGET_COLDFIRE_FPU\"\n+  \"#\"\n+  \"&& reload_completed\"\n+  [(const_int 0)]\n {\n-  return output_move_double (operands);\n+  m68k_emit_move_double (operands);\n+  DONE;\n })\n \n (define_insn \"movdf_cf_hard\"\n@@ -1230,7 +1532,8 @@\n   [(set (match_operand:SI 0 \"push_operand\" \"=m\")\n \t(match_operand:SI 1 \"address_operand\" \"p\"))]\n   \"\"\n-  \"pea %a1\")\n+  \"pea %a1\"\n+  [(set_attr \"type\" \"pea\")])\n \f\n ;; truncation instructions\n (define_insn \"truncsiqi2\"\n@@ -1391,7 +1694,8 @@\n   [(set (match_operand:SI 0 \"register_operand\" \"=d\")\n \t(zero_extend:SI (match_operand:HI 1 \"nonimmediate_src_operand\" \"rmS\")))]\n   \"ISA_HAS_MVS_MVZ\"\n-  \"mvz%.w %1,%0\")\n+  \"mvz%.w %1,%0\"\n+  [(set_attr \"type\" \"mvz_w\")])\n \n (define_insn \"zero_extendhisi2\"\n   [(set (match_operand:SI 0 \"register_operand\" \"=d\")\n@@ -1415,7 +1719,8 @@\n   [(set (match_operand:SI 0 \"register_operand\" \"=d\")\n \t(zero_extend:SI (match_operand:QI 1 \"nonimmediate_src_operand\" \"dmS\")))]\n   \"ISA_HAS_MVS_MVZ\"\n-  \"mvz%.b %1,%0\")\n+  \"mvz%.b %1,%0\"\n+  [(set_attr \"type\" \"mvz_b\")])\n \n (define_insn \"zero_extendqisi2\"\n   [(set (match_operand:SI 0 \"register_operand\" \"=d\")\n@@ -1567,24 +1872,25 @@\n \t(sign_extend:SI\n \t (match_operand:HI 1 \"nonimmediate_src_operand\" \"rmS\")))]\n   \"ISA_HAS_MVS_MVZ\"\n-  \"mvs%.w %1,%0\")\n+  \"mvs%.w %1,%0\"\n+  [(set_attr \"type\" \"mvs_w\")])\n \n (define_insn \"*68k_extendhisi2\"\n   [(set (match_operand:SI 0 \"nonimmediate_operand\" \"=*d,a\")\n \t(sign_extend:SI\n \t (match_operand:HI 1 \"nonimmediate_src_operand\" \"0,rmS\")))]\n   \"!ISA_HAS_MVS_MVZ\"\n-{\n-  if (ADDRESS_REG_P (operands[0]))\n-    return \"move%.w %1,%0\";\n-  return \"ext%.l %0\";\n-})\n+  \"@\n+   ext%.l %0\n+   move%.w %1,%0\"\n+  [(set_attr \"type\" \"ext_l,move_w\")])\n \n (define_insn \"extendqihi2\"\n   [(set (match_operand:HI 0 \"nonimmediate_operand\" \"=d\")\n \t(sign_extend:HI (match_operand:QI 1 \"nonimmediate_operand\" \"0\")))]\n   \"\"\n-  \"ext%.w %0\")\n+  \"ext%.w %0\"\n+  [(set_attr \"type\" \"ext_w\")])\n \n (define_expand \"extendqisi2\"\n   [(set (match_operand:SI 0 \"nonimmediate_operand\" \"\")\n@@ -1596,13 +1902,15 @@\n   [(set (match_operand:SI 0 \"nonimmediate_operand\" \"=d\")\n \t(sign_extend:SI (match_operand:QI 1 \"nonimmediate_operand\" \"rms\")))]\n   \"ISA_HAS_MVS_MVZ\"\n-  \"mvs%.b %1,%0\")\n+  \"mvs%.b %1,%0\"\n+  [(set_attr \"type\" \"mvs_b\")])\n \n (define_insn \"*68k_extendqisi2\"\n   [(set (match_operand:SI 0 \"nonimmediate_operand\" \"=d\")\n \t(sign_extend:SI (match_operand:QI 1 \"nonimmediate_operand\" \"0\")))]\n   \"TARGET_68020 || (TARGET_COLDFIRE && !ISA_HAS_MVS_MVZ)\"\n-  \"extb%.l %0\")\n+  \"extb%.l %0\"\n+  [(set_attr \"type\" \"extb_l\")])\n \f\n ;; Conversions between float and double.\n \n@@ -1691,14 +1999,16 @@\n   \"TARGET_COLDFIRE_FPU\"\n   \"@\n   fsmove%.d %1,%0\n-  fmove%.s %1,%0\")\n+  fmove%.s %1,%0\"\n+  [(set_attr \"type\" \"fmove\")])\n \n-(define_insn \"\"\n+(define_insn \"*truncdfsf2_68881\"\n   [(set (match_operand:SF 0 \"nonimmediate_operand\" \"=dm\")\n \t(float_truncate:SF\n \t  (match_operand:DF 1 \"general_operand\" \"f\")))]\n   \"TARGET_68881\"\n-  \"fmove%.s %f1,%0\")\n+  \"fmove%.s %f1,%0\"\n+  [(set_attr \"type\" \"fmove\")])\n \f\n ;; Conversion between fixed point and floating point.\n ;; Note that among the fix-to-float insns\n@@ -1724,7 +2034,8 @@\n   [(set (match_operand:FP 0 \"nonimmediate_operand\" \"=f\")\n \t(float:FP (match_operand:SI 1 \"general_operand\" \"d<Q>U\")))]\n   \"TARGET_COLDFIRE_FPU\"\n-  \"f<FP:prec>move%.l %1,%0\")\n+  \"f<FP:prec>move%.l %1,%0\"\n+  [(set_attr \"type\" \"fmove\")])\n \n \n (define_expand \"floathi<mode>2\"\n@@ -1737,13 +2048,15 @@\n   [(set (match_operand:FP 0 \"nonimmediate_operand\" \"=f\")\n \t(float:FP (match_operand:HI 1 \"general_operand\" \"dmn\")))]\n   \"TARGET_68881\"\n-  \"fmove%.w %1,%0\")\n+  \"fmove%.w %1,%0\"\n+  [(set_attr \"type\" \"fmove\")])\n \n (define_insn \"floathi<mode>2_cf\"\n   [(set (match_operand:FP 0 \"nonimmediate_operand\" \"=f\")\n         (float:FP (match_operand:HI 1 \"general_operand\" \"d<Q>U\")))]\n   \"TARGET_COLDFIRE_FPU\"\n-  \"fmove%.w %1,%0\")\n+  \"fmove%.w %1,%0\"\n+  [(set_attr \"type\" \"fmove\")])\n \n \n (define_expand \"floatqi<mode>2\"\n@@ -1756,13 +2069,15 @@\n   [(set (match_operand:FP 0 \"nonimmediate_operand\" \"=f\")\n \t(float:FP (match_operand:QI 1 \"general_operand\" \"dmn\")))]\n   \"TARGET_68881\"\n-  \"fmove%.b %1,%0\")\n+  \"fmove%.b %1,%0\"\n+  [(set_attr \"type\" \"fmove\")])\n \n (define_insn \"floatqi<mode>2_cf\"\n   [(set (match_operand:FP 0 \"nonimmediate_operand\" \"=f\")\n \t(float:FP (match_operand:QI 1 \"general_operand\" \"d<Q>U\")))]\n   \"TARGET_COLDFIRE_FPU\"\n-  \"fmove%.b %1,%0\")\n+  \"fmove%.b %1,%0\"\n+  [(set_attr \"type\" \"fmove\")])\n \n \n ;; New routines to convert floating-point values to integers\n@@ -1830,7 +2145,8 @@\n   if (FP_REG_P (operands[1]))\n     return \"fintrz%.d %f1,%0\";\n   return \"fintrz%.<FP:prec> %f1,%0\";\n-})\n+}\n+  [(set_attr \"type\" \"fintrz\")])\n \n ;; Convert a float whose value is an integer\n ;; to an actual integer.  Second stage of converting float to integer type.\n@@ -1850,7 +2166,8 @@\n   [(set (match_operand:QI 0 \"nonimmediate_operand\" \"=d<Q>U\")\n \t(fix:QI (match_operand:FP 1 \"general_operand\" \"f\")))]\n   \"TARGET_COLDFIRE_FPU\"\n-  \"fmove%.b %1,%0\")\n+  \"fmove%.b %1,%0\"\n+  [(set_attr \"type\" \"fmove\")])\n \n (define_expand \"fix<mode>hi2\"\n   [(set (match_operand:HI 0 \"nonimmediate_operand\" \"\")\n@@ -1868,7 +2185,8 @@\n   [(set (match_operand:HI 0 \"nonimmediate_operand\" \"=d<Q>U\")\n \t(fix:HI (match_operand:FP 1 \"general_operand\" \"f\")))]\n   \"TARGET_COLDFIRE_FPU\"\n-  \"fmove%.w %1,%0\")\n+  \"fmove%.w %1,%0\"\n+  [(set_attr \"type\" \"fmove\")])\n \n (define_expand \"fix<mode>si2\"\n   [(set (match_operand:SI 0 \"nonimmediate_operand\" \"\")\n@@ -1886,7 +2204,8 @@\n   [(set (match_operand:SI 0 \"nonimmediate_operand\" \"=d<Q>U\")\n \t(fix:SI (match_operand:FP 1 \"general_operand\" \"f\")))]\n   \"TARGET_COLDFIRE_FPU\"\n-  \"fmove%.l %1,%0\")\n+  \"fmove%.l %1,%0\"\n+  [(set_attr \"type\" \"fmove\")])\n \n \f\n ;; add instructions\n@@ -1984,7 +2303,8 @@\n   else\n     operands[1] = adjust_address (operands[1], SImode, 4);\n   return \"add%.l %1,%0\";\n-})\n+}\n+  [(set_attr \"type\" \"add_l\")])\n \n (define_insn \"adddi3\"\n   [(set (match_operand:DI 0 \"nonimmediate_operand\" \"=o<>,d,d,d\")\n@@ -2107,12 +2427,54 @@\n   \"! TARGET_COLDFIRE\"\n   \"* return output_addsi3 (operands);\")\n \n-(define_insn \"*addsi3_5200\"\n-  [(set (match_operand:SI 0 \"nonimmediate_operand\" \"=m,?a,?a,r\")\n-\t(plus:SI (match_operand:SI 1 \"general_operand\" \"%0,a,rJK,0\")\n-\t\t (match_operand:SI 2 \"general_src_operand\" \"dIL,rJK,a,mrIKLi\")))]\n+(define_insn_and_split \"*addsi3_5200\"\n+  [(set (match_operand:SI 0 \"nonimmediate_operand\"         \"=mr,mr,m,r,  ?a,?a,?a,?a\")\n+\t(plus:SI (match_operand:SI 1 \"general_operand\"     \"%0, 0, 0,0,   a, a, r, a\")\n+\t\t (match_operand:SI 2 \"general_src_operand\" \" I, L, d,mrKi,Cj,r, a, J\")))]\n   \"TARGET_COLDFIRE\"\n-  \"* return output_addsi3 (operands);\")\n+{\n+  switch (which_alternative)\n+    {\n+    case 0:\n+      return \"addq%.l %2,%0\";\n+\n+    case 1:\n+      operands[2] = GEN_INT (- INTVAL (operands[2]));\n+      return \"subq%.l %2,%0\";\n+\n+    case 2:\n+    case 3:\n+      return \"add%.l %2,%0\";\n+\n+    case 4:\n+      /* move%.l %2,%0\\n\\tadd%.l %1,%0 */\n+      return \"#\";\n+\n+    case 5:\n+      return MOTOROLA ? \"lea (%1,%2.l),%0\" : \"lea %1@(0,%2:l),%0\";\n+\n+    case 6:\n+      return MOTOROLA ? \"lea (%2,%1.l),%0\" : \"lea %2@(0,%1:l),%0\";\n+\n+    case 7:\n+      return MOTOROLA ? \"lea (%c2,%1),%0\" : \"lea %1@(%c2),%0\";\n+\n+    default:\n+      gcc_unreachable ();\n+      return \"\";\n+    }\n+}\n+  \"&& reload_completed && (extract_constrain_insn_cached (insn), which_alternative == 4) && !operands_match_p (operands[0], operands[1])\"\n+  [(set (match_dup 0)\n+\t(match_dup 2))\n+   (set (match_dup 0)\n+\t(plus:SI (match_dup 0)\n+\t\t (match_dup 1)))]\n+  \"\"\n+  [(set_attr \"type\" \"addq_l,subq_l,add_l,add_l,*,lea,lea,lea\")\n+   (set_attr \"opy\" \"2,2,2,2,*,*,*,*\")\n+   (set_attr \"opy_type\" \"*,*,*,*,*,mem6,mem6,mem5\")\n+   (set_attr \"split\" \"done,done,done,done,*,done,done,done\")])\n \n (define_insn \"\"\n   [(set (match_operand:SI 0 \"nonimmediate_operand\" \"=a\")\n@@ -2392,7 +2754,8 @@\n   if (FP_REG_P (operands[2]))\n     return \"f<FP:prec>add%.d %2,%0\";\n   return \"f<FP:prec>add%.<FP:prec> %2,%0\";\n-})\n+}\n+  [(set_attr \"type\" \"fadd\")])\n \f\n ;; subtract instructions\n \n@@ -2426,7 +2789,8 @@\n   else\n     operands[1] = adjust_address (operands[1], SImode, 4);\n   return \"sub%.l %1,%0\";\n-})\n+}\n+  [(set_attr \"type\" \"sub_l\")])\n \n (define_insn \"subdi3\"\n   [(set (match_operand:DI 0 \"nonimmediate_operand\" \"=o<>,d,d,d\")\n@@ -2508,11 +2872,17 @@\n })\n \n (define_insn \"subsi3\"\n-  [(set (match_operand:SI 0 \"nonimmediate_operand\" \"=m,d,a\")\n-\t(minus:SI (match_operand:SI 1 \"general_operand\" \"0,0,0\")\n-\t\t  (match_operand:SI 2 \"general_src_operand\" \"dT,mSrT,mSrs\")))]\n+  [(set (match_operand:SI 0 \"nonimmediate_operand\" \"=mda,m,d,a\")\n+\t(minus:SI (match_operand:SI 1 \"general_operand\" \"0,0,0,0\")\n+\t\t  (match_operand:SI 2 \"general_src_operand\" \"I,dT,mSrT,mSrs\")))]\n   \"\"\n-  \"sub%.l %2,%0\")\n+  \"@\n+   subq%.l %2, %0\n+   sub%.l %2,%0\n+   sub%.l %2,%0\n+   sub%.l %2,%0\"\n+  [(set_attr \"type\" \"subq_l,sub_l,sub_l,sub_l\")\n+   (set_attr \"opy\" \"2\")])\n \n (define_insn \"\"\n   [(set (match_operand:SI 0 \"nonimmediate_operand\" \"=a\")\n@@ -2598,7 +2968,8 @@\n   if (FP_REG_P (operands[2]))\n     return \"f<FP:prec>sub%.d %2,%0\";\n   return \"f<FP:prec>sub%.<FP:prec> %2,%0\";\n-})\n+}\n+  [(set_attr \"type\" \"fsub\")])\n \f\n ;; multiply instructions\n \n@@ -2609,7 +2980,9 @@\n   \"\"\n {\n   return MOTOROLA ? \"muls%.w %2,%0\" : \"muls %2,%0\";\n-})\n+}\n+  [(set_attr \"type\" \"muls_w\")\n+   (set_attr \"opy\" \"2\")])\n \n (define_insn \"mulhisi3\"\n   [(set (match_operand:SI 0 \"nonimmediate_operand\" \"=d\")\n@@ -2620,17 +2993,21 @@\n   \"\"\n {\n   return MOTOROLA ? \"muls%.w %2,%0\" : \"muls %2,%0\";\n-})\n+}\n+  [(set_attr \"type\" \"muls_w\")\n+   (set_attr \"opy\" \"2\")])\n \n-(define_insn \"\"\n+(define_insn \"*mulhisisi3_s\"\n   [(set (match_operand:SI 0 \"nonimmediate_operand\" \"=d\")\n \t(mult:SI (sign_extend:SI\n \t\t  (match_operand:HI 1 \"nonimmediate_operand\" \"%0\"))\n \t\t (match_operand:SI 2 \"const_int_operand\" \"n\")))]\n   \"INTVAL (operands[2]) >= -0x8000 && INTVAL (operands[2]) <= 0x7fff\"\n {\n   return MOTOROLA ? \"muls%.w %2,%0\" : \"muls %2,%0\";\n-})\n+}\n+  [(set_attr \"type\" \"muls_w\")\n+   (set_attr \"opy\" \"2\")])\n \n (define_expand \"mulsi3\"\n   [(set (match_operand:SI 0 \"nonimmediate_operand\" \"\")\n@@ -2639,20 +3016,24 @@\n   \"TARGET_68020 || TARGET_COLDFIRE\"\n   \"\")\n \n-(define_insn \"\"\n+(define_insn \"*mulsi3_68020\"\n   [(set (match_operand:SI 0 \"nonimmediate_operand\" \"=d\")\n \t(mult:SI (match_operand:SI 1 \"general_operand\" \"%0\")\n                  (match_operand:SI 2 \"general_src_operand\" \"dmSTK\")))]\n \n   \"TARGET_68020\"\n-  \"muls%.l %2,%0\")\n+  \"muls%.l %2,%0\"\n+  [(set_attr \"type\" \"muls_l\")\n+   (set_attr \"opy\" \"2\")])\n \n-(define_insn \"\"\n+(define_insn \"*mulsi3_cf\"\n   [(set (match_operand:SI 0 \"nonimmediate_operand\" \"=d\")\n \t(mult:SI (match_operand:SI 1 \"general_operand\" \"%0\")\n \t\t (match_operand:SI 2 \"general_operand\" \"d<Q>\")))]\n   \"TARGET_COLDFIRE\"\n-  \"muls%.l %2,%0\")\n+  \"muls%.l %2,%0\"\n+  [(set_attr \"type\" \"muls_l\")\n+   (set_attr \"opy\" \"2\")])\n \n (define_insn \"umulhisi3\"\n   [(set (match_operand:SI 0 \"nonimmediate_operand\" \"=d\")\n@@ -2663,17 +3044,21 @@\n   \"\"\n {\n   return MOTOROLA ? \"mulu%.w %2,%0\" : \"mulu %2,%0\";\n-})\n+}\n+  [(set_attr \"type\" \"mulu_w\")\n+   (set_attr \"opy\" \"2\")])\n \n-(define_insn \"\"\n+(define_insn \"*mulhisisi3_z\"\n   [(set (match_operand:SI 0 \"nonimmediate_operand\" \"=d\")\n \t(mult:SI (zero_extend:SI\n \t\t  (match_operand:HI 1 \"nonimmediate_operand\" \"%0\"))\n \t\t (match_operand:SI 2 \"const_int_operand\" \"n\")))]\n   \"INTVAL (operands[2]) >= 0 && INTVAL (operands[2]) <= 0xffff\"\n {\n   return MOTOROLA ? \"mulu%.w %2,%0\" : \"mulu %2,%0\";\n-})\n+}\n+  [(set_attr \"type\" \"mulu_w\")\n+   (set_attr \"opy\" \"2\")])\n \n ;; We need a separate DEFINE_EXPAND for u?mulsidi3 to be able to use the\n ;; proper matching constraint.  This is because the matching is between\n@@ -2932,7 +3317,8 @@\n   if (FP_REG_P (operands[2]))\n     return \"f<FP:prec>mul%.d %2,%0\";\n   return \"f<FP:prec>mul%.<FP:prec> %2,%0\";\n-})\n+}\n+  [(set_attr \"type\" \"fmul\")])\n \f\n ;; divide instructions\n \n@@ -3000,7 +3386,8 @@\n   if (FP_REG_P (operands[2]))\n     return \"f<FP:prec>div%.d %2,%0\";\n   return \"f<FP:prec>div%.<FP:prec> %2,%0\";\n-})\n+}\n+  [(set_attr \"type\" \"fdiv\")])\n \f\n ;; Remainder instructions.\n \n@@ -3692,13 +4079,15 @@\n   [(set (match_operand:SI 0 \"nonimmediate_operand\" \"=dm\")\n \t(neg:SI (match_operand:SI 1 \"general_operand\" \"0\")))]\n   \"!TARGET_COLDFIRE\"\n-  \"neg%.l %0\")\n+  \"neg%.l %0\"\n+  [(set_attr \"type\" \"neg_l\")])\n \n (define_insn \"negsi2_5200\"\n   [(set (match_operand:SI 0 \"nonimmediate_operand\" \"=d\")\n \t(neg:SI (match_operand:SI 1 \"general_operand\" \"0\")))]\n   \"TARGET_COLDFIRE\"\n-  \"neg%.l %0\")\n+  \"neg%.l %0\"\n+  [(set_attr \"type\" \"neg_l\")])\n \n (define_insn \"neghi2\"\n   [(set (match_operand:HI 0 \"nonimmediate_operand\" \"=dm\")\n@@ -3863,7 +4252,8 @@\n   if (FP_REG_P (operands[1]))\n     return \"f<FP:round>sqrt%.x %1,%0\";\n   return \"f<FP:round>sqrt%.<FP:prec> %1,%0\";\n-})\n+}\n+  [(set_attr \"type\" \"fsqrt\")])\n \n (define_insn \"sqrt<mode>2_cf\"\n   [(set (match_operand:FP 0 \"nonimmediate_operand\" \"=f\")\n@@ -4005,7 +4395,8 @@\n   [(set (match_operand:SI 0 \"register_operand\" \"=d\")\n  \t(clz:SI (match_operand:SI 1 \"register_operand\" \"0\")))]\n   \"ISA_HAS_FF1\"\n-  \"ff1 %0\")\n+  \"ff1 %0\"\n+  [(set_attr \"type\" \"ff1\")])\n \f\n ;; one complement instructions\n \n@@ -4048,7 +4439,8 @@\n   [(set (match_operand:SI 0 \"nonimmediate_operand\" \"=d\")\n \t(not:SI (match_operand:SI 1 \"general_operand\" \"0\")))]\n   \"TARGET_COLDFIRE\"\n-  \"not%.l %0\")\n+  \"not%.l %0\"\n+  [(set_attr \"type\" \"not_l\")])\n \n (define_insn \"one_cmplhi2\"\n   [(set (match_operand:HI 0 \"nonimmediate_operand\" \"=dm\")\n@@ -4399,7 +4791,8 @@\n   if (GET_CODE (operands[1]) != REG)\n     operands[1] = adjust_address (operands[1], HImode, 2);\n   return \"move%.w %1,%0\";\n-})\n+}\n+  [(set_attr \"type\" \"move_w\")])\n \n (define_insn \"subregsi1ashrdi_const32\"\n   [(set (match_operand:SI 0 \"nonimmediate_operand\" \"=rm\")\n@@ -4408,7 +4801,8 @@\n   \"\"\n {\n   return \"move%.l %1,%0\";\n-})\n+}\n+  [(set_attr \"type\" \"move_l\")])\n \n (define_insn \"*ashrdi3_const1\"\n   [(set (match_operand:DI 0 \"register_operand\" \"=d\")\n@@ -4577,7 +4971,9 @@\n \t(ashiftrt:SI (match_operand:SI 1 \"register_operand\" \"0\")\n \t\t     (match_operand:SI 2 \"general_operand\" \"dI\")))]\n   \"\"\n-  \"asr%.l %2,%0\")\n+  \"asr%.l %2,%0\"\n+  [(set_attr \"type\" \"asr_l\")\n+   (set_attr \"opy\" \"2\")])\n \n (define_insn \"ashrhi3\"\n   [(set (match_operand:HI 0 \"register_operand\" \"=d\")\n@@ -4643,9 +5039,8 @@\n     (subreg:SI (lshiftrt:DI (match_operand:DI 1 \"general_operand\" \"ro\")\n             (const_int 32)) 4))]\n   \"\"\n-{\n-  return \"move%.l %1,%0\";\n-})\n+  \"move%.l %1,%0\"\n+  [(set_attr \"type\" \"move_l\")])\n \n (define_insn \"*lshrdi3_const1\"\n   [(set (match_operand:DI 0 \"register_operand\" \"=d\")\n@@ -4872,7 +5267,9 @@\n \t(lshiftrt:SI (match_operand:SI 1 \"register_operand\" \"0\")\n \t\t     (match_operand:SI 2 \"general_operand\" \"dI\")))]\n   \"\"\n-  \"lsr%.l %2,%0\")\n+  \"lsr%.l %2,%0\"\n+  [(set_attr \"type\" \"lsr_l\")\n+   (set_attr \"opy\" \"2\")])\n \n (define_insn \"lshrhi3\"\n   [(set (match_operand:HI 0 \"register_operand\" \"=d\")\n@@ -5029,10 +5426,11 @@\n {\n   CC_STATUS_INIT;\n   return \"bset %1,%0\";\n-})\n+}\n+  [(set_attr \"type\" \"bset\")])\n \n ;; set bit, bit number is (sign/zero)_extended from HImode/QImode\n-(define_insn \"\"\n+(define_insn \"*bsetmemqi_ext\"\n   [(set (match_operand:QI 0 \"memory_operand\" \"+m\")\n \t(ior:QI (subreg:QI (ashift:SI (const_int 1)\n \t    (match_operator:SI 2 \"extend_operator\"\n@@ -5042,7 +5440,8 @@\n {\n   CC_STATUS_INIT;\n   return \"bset %1,%0\";\n-})\n+}\n+  [(set_attr \"type\" \"bset\")])\n \n ;; clear bit, bit number is int\n (define_insn \"bclrmemqi\"\n@@ -5055,10 +5454,11 @@\n {\n   CC_STATUS_INIT;\n   return \"bclr %1,%0\";\n-})\n+}\n+  [(set_attr \"type\" \"bclr\")])\n \n ;; clear bit, bit number is (sign/zero)_extended from HImode/QImode\n-(define_insn \"\"\n+(define_insn \"*bclrmemqi_ext\"\n   [(set (zero_extract:SI (match_operand:QI 0 \"memory_operand\" \"+m\")\n \t(const_int 1)\n \t(minus:SI (const_int 7)\n@@ -5069,7 +5469,8 @@\n {\n   CC_STATUS_INIT;\n   return \"bclr %1,%0\";\n-})\n+}\n+  [(set_attr \"type\" \"bclr\")])\n \n ;; Special cases of bit-field insns which we should\n ;; recognize in preference to the general case.\n@@ -5641,14 +6042,15 @@\n   \"\"\n   \"\")\n \n-(define_insn \"\"\n+(define_insn \"*scc\"\n   [(set (match_operand:QI 0 \"register_operand\" \"=d\")\n \t(geu:QI (cc0) (const_int 0)))]\n   \"\"\n {\n    cc_status = cc_prev_status;\n    return \"scc %0\";\n-})\n+}\n+  [(set_attr \"type\" \"scc\")])\n \n (define_expand \"sle\"\n   [(set (match_operand:QI 0 \"register_operand\" \"\")\n@@ -5678,14 +6080,15 @@\n   \"\"\n   \"\")\n \n-(define_insn \"\"\n+(define_insn \"*sls\"\n   [(set (match_operand:QI 0 \"register_operand\" \"=d\")\n \t(leu:QI (cc0) (const_int 0)))]\n   \"\"\n {\n    cc_status = cc_prev_status;\n    return \"sls %0\";\n-})\n+}\n+  [(set_attr \"type\" \"scc\")])\n \n (define_expand \"sordered\"\n   [(set (match_operand:QI 0 \"register_operand\" \"\")\n@@ -6085,7 +6488,9 @@\n     OUTPUT_JUMP (\"jbeq %l0\", \"fbeq %l0\", \"jbeq %l0\");\n   else\n     OUTPUT_JUMP (\"jeq %l0\", \"fjeq %l0\", \"jeq %l0\");\n-})\n+}\n+  [(set (attr \"type\") (symbol_ref \"m68k_sched_branch_type (insn)\"))\n+   (set_attr \"split\" \"done\")])\n \n (define_insn \"bne\"\n   [(set (pc)\n@@ -6099,7 +6504,9 @@\n     OUTPUT_JUMP (\"jbne %l0\", \"fbne %l0\", \"jbne %l0\");\n   else\n     OUTPUT_JUMP (\"jne %l0\", \"fjne %l0\", \"jne %l0\");\n-})\n+}\n+  [(set (attr \"type\") (symbol_ref \"m68k_sched_branch_type (insn)\"))\n+   (set_attr \"split\" \"done\")])\n \n (define_insn \"bgt\"\n   [(set (pc)\n@@ -6113,7 +6520,9 @@\n     OUTPUT_JUMP (\"jbgt %l0\", \"fbgt %l0\", 0);\n   else\n     OUTPUT_JUMP (\"jgt %l0\", \"fjgt %l0\", 0);\n-})\n+}\n+  [(set (attr \"type\") (symbol_ref \"m68k_sched_branch_type (insn)\"))\n+   (set_attr \"split\" \"done\")])\n \n (define_insn \"bgtu\"\n   [(set (pc)\n@@ -6124,7 +6533,8 @@\n   \"\"\n {\n   return MOTOROLA ? \"jbhi %l0\" : \"jhi %l0\";\n-})\n+}\n+  [(set_attr \"type\" \"bcc\")])\n \n (define_insn \"blt\"\n   [(set (pc)\n@@ -6138,7 +6548,9 @@\n     OUTPUT_JUMP (\"jblt %l0\", \"fblt %l0\", \"jbmi %l0\");\n   else\n     OUTPUT_JUMP (\"jlt %l0\", \"fjlt %l0\", \"jmi %l0\");\n-})\n+}\n+  [(set (attr \"type\") (symbol_ref \"m68k_sched_branch_type (insn)\"))\n+   (set_attr \"split\" \"done\")])\n \n (define_insn \"bltu\"\n   [(set (pc)\n@@ -6149,7 +6561,8 @@\n   \"\"\n {\n   return MOTOROLA ? \"jbcs %l0\" : \"jcs %l0\";\n-})\n+}\n+  [(set_attr \"type\" \"bcc\")])\n \n (define_insn \"bge\"\n   [(set (pc)\n@@ -6174,7 +6587,8 @@\n   \"\"\n {\n   return MOTOROLA ? \"jbcc %l0\" : \"jcc %l0\";\n-})\n+}\n+  [(set_attr \"type\" \"bcc\")])\n \n (define_insn \"ble\"\n   [(set (pc)\n@@ -6188,7 +6602,8 @@\n     OUTPUT_JUMP (\"jble %l0\", \"fble %l0\", 0);\n   else\n     OUTPUT_JUMP (\"jle %l0\", \"fjle %l0\", 0);\n-})\n+}\n+  [(set_attr \"type\" \"bcc\")])\n \n (define_insn \"bleu\"\n   [(set (pc)\n@@ -6199,7 +6614,8 @@\n   \"\"\n {\n   return MOTOROLA ? \"jbls %l0\" : \"jls %l0\";\n-})\n+}\n+  [(set_attr \"type\" \"bcc\")])\n \n (define_insn \"bordered\"\n   [(set (pc)\n@@ -6291,7 +6707,7 @@\n \f\n ;; Negated conditional jump instructions.\n \n-(define_insn \"\"\n+(define_insn \"*beq2\"\n   [(set (pc)\n \t(if_then_else (eq (cc0)\n \t\t\t  (const_int 0))\n@@ -6303,9 +6719,10 @@\n     OUTPUT_JUMP (\"jbne %l0\", \"fbne %l0\", \"jbne %l0\");\n   else\n     OUTPUT_JUMP (\"jne %l0\", \"fjne %l0\", \"jne %l0\");\n-})\n+}\n+  [(set_attr \"type\" \"bcc\")])\n \n-(define_insn \"\"\n+(define_insn \"*bne2\"\n   [(set (pc)\n \t(if_then_else (ne (cc0)\n \t\t\t  (const_int 0))\n@@ -6317,9 +6734,10 @@\n     OUTPUT_JUMP (\"jbeq %l0\", \"fbeq %l0\", \"jbeq %l0\");\n   else\n     OUTPUT_JUMP (\"jeq %l0\", \"fjeq %l0\", \"jeq %l0\");\n-})\n+}\n+  [(set_attr \"type\" \"bcc\")])\n \n-(define_insn \"\"\n+(define_insn \"*bgt2\"\n   [(set (pc)\n \t(if_then_else (gt (cc0)\n \t\t\t  (const_int 0))\n@@ -6331,9 +6749,10 @@\n     OUTPUT_JUMP (\"jble %l0\", \"fbngt %l0\", 0);\n   else\n     OUTPUT_JUMP (\"jle %l0\", \"fjngt %l0\", 0);\n-})\n+}\n+  [(set_attr \"type\" \"bcc\")])\n \n-(define_insn \"\"\n+(define_insn \"*bgtu2\"\n   [(set (pc)\n \t(if_then_else (gtu (cc0)\n \t\t\t   (const_int 0))\n@@ -6342,9 +6761,10 @@\n   \"\"\n {\n   return MOTOROLA ? \"jbls %l0\" : \"jls %l0\";\n-})\n+}\n+  [(set_attr \"type\" \"bcc\")])\n \n-(define_insn \"\"\n+(define_insn \"*blt2\"\n   [(set (pc)\n \t(if_then_else (lt (cc0)\n \t\t\t  (const_int 0))\n@@ -6356,9 +6776,10 @@\n     OUTPUT_JUMP (\"jbge %l0\", \"fbnlt %l0\", \"jbpl %l0\");\n   else\n     OUTPUT_JUMP (\"jge %l0\", \"fjnlt %l0\", \"jpl %l0\");\n-})\n+}\n+  [(set_attr \"type\" \"bcc\")])\n \n-(define_insn \"\"\n+(define_insn \"*bltu2\"\n   [(set (pc)\n \t(if_then_else (ltu (cc0)\n \t\t\t   (const_int 0))\n@@ -6367,9 +6788,10 @@\n   \"\"\n {\n   return MOTOROLA ? \"jbcc %l0\" : \"jcc %l0\";\n-})\n+}\n+  [(set_attr \"type\" \"bcc\")])\n \n-(define_insn \"\"\n+(define_insn \"*bge2\"\n   [(set (pc)\n \t(if_then_else (ge (cc0)\n \t\t\t  (const_int 0))\n@@ -6381,9 +6803,10 @@\n     OUTPUT_JUMP (\"jblt %l0\", \"fbnge %l0\", \"jbmi %l0\");\n   else\n     OUTPUT_JUMP (\"jlt %l0\", \"fjnge %l0\", \"jmi %l0\");\n-})\n+}\n+  [(set_attr \"type\" \"bcc\")])\n \n-(define_insn \"\"\n+(define_insn \"*bgeu2\"\n   [(set (pc)\n \t(if_then_else (geu (cc0)\n \t\t\t   (const_int 0))\n@@ -6392,9 +6815,10 @@\n   \"\"\n {\n   return MOTOROLA ? \"jbcs %l0\" : \"jcs %l0\";\n-})\n+}\n+  [(set_attr \"type\" \"bcc\")])\n \n-(define_insn \"\"\n+(define_insn \"*ble2\"\n   [(set (pc)\n \t(if_then_else (le (cc0)\n \t\t\t  (const_int 0))\n@@ -6406,9 +6830,10 @@\n     OUTPUT_JUMP (\"jbgt %l0\", \"fbnle %l0\", 0);\n   else\n     OUTPUT_JUMP (\"jgt %l0\", \"fjnle %l0\", 0);\n-})\n+}\n+  [(set_attr \"type\" \"bcc\")])\n \n-(define_insn \"\"\n+(define_insn \"*bleu2\"\n   [(set (pc)\n \t(if_then_else (leu (cc0)\n \t\t\t   (const_int 0))\n@@ -6417,7 +6842,8 @@\n   \"\"\n {\n   return MOTOROLA ? \"jbhi %l0\" : \"jhi %l0\";\n-})\n+}\n+  [(set_attr \"type\" \"bcc\")])\n \n (define_insn \"*bordered_rev\"\n   [(set (pc)\n@@ -6514,7 +6940,8 @@\n   \"\"\n {\n   return MOTOROLA ? \"jbra %l0\" : \"jra %l0\";\n-})\n+}\n+  [(set_attr \"type\" \"bra\")])\n \n (define_expand \"tablejump\"\n   [(parallel [(set (pc) (match_operand 0 \"\" \"\"))\n@@ -6528,13 +6955,14 @@\n })\n \n ;; Jump to variable address from dispatch table of absolute addresses.\n-(define_insn \"\"\n+(define_insn \"*tablejump_internal\"\n   [(set (pc) (match_operand:SI 0 \"register_operand\" \"a\"))\n    (use (label_ref (match_operand 1 \"\" \"\")))]\n   \"\"\n {\n   return MOTOROLA ? \"jmp (%0)\" : \"jmp %0@\";\n-})\n+}\n+  [(set_attr \"type\" \"bra\")])\n \n ;; Jump to variable address from dispatch table of relative addresses.\n (define_insn \"\"\n@@ -6746,16 +7174,46 @@\n   operands[1] = m68k_legitimize_call_address (operands[1]);\n })\n \n-(define_insn \"*call_value\"\n+(define_insn \"*non_symbolic_call_value\"\n   [(set (match_operand 0 \"\" \"=rf,rf\")\n-\t(call (mem:QI (match_operand:SI 1 \"call_operand\" \"a,W\"))\n+\t(call (mem:QI (match_operand:SI 1 \"non_symbolic_call_operand\" \"a,W\"))\n \t      (match_operand:SI 2 \"general_operand\" \"g,g\")))]\n   ;; Operand 2 not really used on the m68000.\n   \"!SIBLING_CALL_P (insn)\"\n+  \"jsr %a1\"\n+  [(set_attr \"type\" \"jsr\")\n+   (set_attr \"split\" \"done\")\n+   (set_attr \"opx\" \"1\")])\n+\n+(define_insn \"*symbolic_call_value_jsr\"\n+  [(set (match_operand 0 \"\" \"=rf,rf\")\n+\t(call (mem:QI (match_operand:SI 1 \"symbolic_operand\" \"a,W\"))\n+\t      (match_operand:SI 2 \"general_operand\" \"g,g\")))]\n+  ;; Operand 2 not really used on the m68000.\n+  \"!SIBLING_CALL_P (insn) && m68k_symbolic_call_var == M68K_SYMBOLIC_CALL_JSR\"\n {\n   operands[0] = operands[1];\n-  return output_call (operands[0]);\n-})\n+  return m68k_symbolic_call;\n+}\n+  [(set_attr \"type\" \"jsr\")\n+   (set_attr \"split\" \"done\")\n+   (set_attr \"opx\" \"1\")])\n+\n+(define_insn \"*symbolic_call_value_bsr\"\n+  [(set (match_operand 0 \"\" \"=rf,rf\")\n+\t(call (mem:QI (match_operand:SI 1 \"symbolic_operand\" \"a,W\"))\n+\t      (match_operand:SI 2 \"general_operand\" \"g,g\")))]\n+  ;; Operand 2 not really used on the m68000.\n+  \"!SIBLING_CALL_P (insn)\n+   && (m68k_symbolic_call_var == M68K_SYMBOLIC_CALL_BSR_C\n+       || m68k_symbolic_call_var == M68K_SYMBOLIC_CALL_BSR_P)\"\n+{\n+  operands[0] = operands[1];\n+  return m68k_symbolic_call;\n+}\n+  [(set_attr \"type\" \"bsr\")\n+   (set_attr \"split\" \"done\")\n+   (set_attr \"opx\" \"1\")])\n \n ;; Call subroutine returning any type.\n \n@@ -6796,7 +7254,8 @@\n (define_insn \"nop\"\n   [(const_int 0)]\n   \"\"\n-  \"nop\")\n+  \"nop\"\n+  [(set_attr \"type\" \"nop\")])\n \n (define_expand \"prologue\"\n   [(const_int 0)]\n@@ -6849,7 +7308,8 @@\n       else\n \treturn \"rts\";\n     }\n-})\n+}\n+  [(set_attr \"type\" \"rts\")])\n \n (define_insn \"*m68k_store_multiple\"\n   [(match_parallel 0 \"\" [(match_operand 1 \"\")])]\n@@ -6939,7 +7399,8 @@\n \t(plus:SI (match_dup 0)\n \t\t (const_int 4)))]\n   \"\"\n-  \"unlk %0\")\n+  \"unlk %0\"\n+  [(set_attr \"type\" \"unlk\")])\n \n (define_insn \"load_got\"\n   [(set (match_operand:SI 0 \"register_operand\" \"=a\")\n@@ -6971,7 +7432,8 @@\n (define_insn \"indirect_jump\"\n   [(set (pc) (match_operand:SI 0 \"address_operand\" \"p\"))]\n   \"\"\n-  \"jmp %a0\")\n+  \"jmp %a0\"\n+  [(set_attr \"type\" \"jmp\")])\n \f\n ;; This should not be used unless the add/sub insns can't be.\n \n@@ -7373,10 +7835,12 @@\n     return \"fcos%.<FP:prec> %1,%0\";\n })\n \n+;; Unconditional traps are assumed to have (const_int 1) for the condition.\n (define_insn \"trap\"\n-  [(trap_if (const_int -1) (const_int 7))]\n+  [(trap_if (const_int 1) (const_int 7))]\n   \"\"\n-  \"trap #7\")\n+  \"trap #7\"\n+  [(set_attr \"type\" \"trap\")])\n \n (define_insn \"conditional_trap\"\n   [(trap_if (match_operator 0 \"valid_dbcc_comparison_p\"\n@@ -7399,3 +7863,12 @@\n   default: gcc_unreachable ();\n   }\n })\n+\n+;; Instruction that subscribes one word in ColdFire instruction buffer.\n+;; This instruction is used within scheduler only and should not appear\n+;; in the instruction stream.\n+(define_insn \"ib\"\n+  [(unspec [(const_int 0)] UNSPEC_IB)]\n+  \"\"\n+  \"#\"\n+  [(set_attr \"type\" \"ib\")])"}, {"sha": "bf968635c257f0064613e9e73d4c4c9d5fa47557", "filename": "gcc/config/m68k/predicates.md", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c47b0cb46626dd1df1aad35c5d1ee9f5be43debe/gcc%2Fconfig%2Fm68k%2Fpredicates.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c47b0cb46626dd1df1aad35c5d1ee9f5be43debe/gcc%2Fconfig%2Fm68k%2Fpredicates.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm68k%2Fpredicates.md?ref=c47b0cb46626dd1df1aad35c5d1ee9f5be43debe", "patch": "@@ -192,3 +192,17 @@\n (define_predicate \"pre_dec_operand\"\n   (and (match_code \"mem\")\n        (match_test \"GET_CODE (XEXP (op, 0)) == PRE_DEC\")))\n+\n+;; An operand for movsi_const0 pattern.\n+(define_predicate \"movsi_const0_operand\"\n+  (and (match_operand 0 \"nonimmediate_operand\")\n+       (match_test \"(TARGET_68010 || TARGET_COLDFIRE)\n+                    || !(MEM_P (op) && MEM_VOLATILE_P (op))\")))\n+ \n+;; A non-symbolic call operand.\n+;; We need to special case 'const_int' to ignore its mode while matching.\n+(define_predicate \"non_symbolic_call_operand\"\n+  (and (match_operand 0 \"call_operand\")\n+       (ior (and (match_code \"const_int\")\n+ \t\t (match_test \"!symbolic_operand (op, mode)\"))\n+ \t    (match_test \"!symbolic_operand (op,mode)\"))))"}, {"sha": "553c58de0813461ef84e0955d50803f76124b1a2", "filename": "gcc/doc/md.texi", "status": "modified", "additions": 59, "deletions": 1, "changes": 60, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c47b0cb46626dd1df1aad35c5d1ee9f5be43debe/gcc%2Fdoc%2Fmd.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c47b0cb46626dd1df1aad35c5d1ee9f5be43debe/gcc%2Fdoc%2Fmd.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fmd.texi?ref=c47b0cb46626dd1df1aad35c5d1ee9f5be43debe", "patch": "@@ -2542,7 +2542,7 @@ Floating-point zero.\n An address that can be used in a non-macro load or store.\n @end table\n \n-@item Motorola 680x0---@file{config/m68k/m68k.h}\n+@item Motorola 680x0---@file{config/m68k/constraints.md}\n @table @code\n @item a\n Address register\n@@ -2568,8 +2568,66 @@ Integer in the range @minus{}8 to @minus{}1\n @item M\n Signed number whose magnitude is greater than 0x100\n \n+@item N\n+Range 24 to 31, rotatert:SI 8 to 1 expressed as rotate\n+\n+@item O\n+16 (for rotate using swap)\n+\n+@item P\n+Range 8 to 15, rotatert:HI 8 to 1 expressed as rotate\n+\n+@item R\n+Numbers that mov3q can handle\n+\n @item G\n Floating point constant that is not a 68881 constant\n+\n+@item S\n+Operands that satisfy 'm' when -mpcrel is in effect\n+\n+@item T\n+Operands that satisfy 's' when -mpcrel is not in effect\n+\n+@item Q\n+Address register indirect addressing mode\n+\n+@item U\n+Register offset addressing\n+\n+@item W\n+const_call_operand\n+\n+@item Cs\n+symbol_ref or const\n+\n+@item Ci\n+const_int\n+\n+@item C0\n+const_int 0\n+\n+@item Cj\n+Range of signed numbers that don't fit in 16 bits\n+\n+@item Cmvq\n+Integers valid for mvq\n+\n+@item Capsw\n+Integers valid for a moveq followed by a swap\n+\n+@item Cmvz\n+Integers valid for mvz\n+\n+@item Cmvs\n+Integers valid for mvs\n+\n+@item Ap\n+push_operand\n+\n+@item Ac\n+Non-register operands allowed in clr\n+\n @end table\n \n @item Motorola 68HC11 & 68HC12 families---@file{config/m68hc11/m68hc11.h}"}]}