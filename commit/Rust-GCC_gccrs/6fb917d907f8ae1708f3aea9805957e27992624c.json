{"sha": "6fb917d907f8ae1708f3aea9805957e27992624c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NmZiOTE3ZDkwN2Y4YWUxNzA4ZjNhZWE5ODA1OTU3ZTI3OTkyNjI0Yw==", "commit": {"author": {"name": "Oleg Endo", "email": "olegendo@gcc.gnu.org", "date": "2015-09-28T14:00:44Z"}, "committer": {"name": "Oleg Endo", "email": "olegendo@gcc.gnu.org", "date": "2015-09-28T14:00:44Z"}, "message": "re PR target/54236 ([SH] Improve addc and subc insn utilization)\n\ngcc/\n\tPR target/54236\n\t* config/sh/predicates.md (t_reg_operand, negt_reg_operand): Allow\n\tand handle ne and eq codes.\n\t* config/sh/sh.c (sh_rtx_costs): Adjust matching of tst #imm,r0 insn.\n\t(sh_recog_treg_set_expr): Early accept negt_reg_operand.  Eearly reject\n\tCONST_INT_P.  Use reverse_condition.\n\t(sh_split_treg_set_expr): Likewise.\n\ngcc/testsuite/\n\tPR target/54236\n\t* gcc.target/sh/pr54236-1.c (test_09, test_10, test_11): New.\n\t* gcc.target/sh/pr59533-1.c (test_23, test_24, test_25, test_26,\n\ttest_27): New.\n\t* gcc.target/sh/pr54236-5.c: New.\n\t* gcc.target/sh/pr54236-6.c: New.\n\nFrom-SVN: r228202", "tree": {"sha": "6216aae2244aba8041d0560ac893e46a4b569ff6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6216aae2244aba8041d0560ac893e46a4b569ff6"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6fb917d907f8ae1708f3aea9805957e27992624c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6fb917d907f8ae1708f3aea9805957e27992624c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6fb917d907f8ae1708f3aea9805957e27992624c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6fb917d907f8ae1708f3aea9805957e27992624c/comments", "author": null, "committer": null, "parents": [{"sha": "b81f1ee3b33dd046db7f508ebf0e29d0e12c406d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b81f1ee3b33dd046db7f508ebf0e29d0e12c406d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b81f1ee3b33dd046db7f508ebf0e29d0e12c406d"}], "stats": {"total": 378, "additions": 322, "deletions": 56}, "files": [{"sha": "6b9af395919c2a00981399023bace8ad80c52326", "filename": "gcc/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6fb917d907f8ae1708f3aea9805957e27992624c/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6fb917d907f8ae1708f3aea9805957e27992624c/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=6fb917d907f8ae1708f3aea9805957e27992624c", "patch": "@@ -1,3 +1,13 @@\n+2015-09-28  Oleg Endo  <olegendo@gcc.gnu.org>\n+\n+\tPR target/54236\n+\t* config/sh/predicates.md (t_reg_operand, negt_reg_operand): Allow\n+\tand handle ne and eq codes.\n+\t* config/sh/sh.c (sh_rtx_costs): Adjust matching of tst #imm,r0 insn.\n+\t(sh_recog_treg_set_expr): Early accept negt_reg_operand.  Eearly reject\n+\tCONST_INT_P.  Use reverse_condition.\n+\t(sh_split_treg_set_expr): Likewise.\n+\n 2015-09-28  James Greenhalgh  <james.greenhalgh@arm.com>\n \n \t* config/arm/types.md (type): Add rotate_imm."}, {"sha": "b847ae74a9d27e16d617bb6dbc09fcf18e1276b3", "filename": "gcc/config/sh/predicates.md", "status": "modified", "additions": 19, "deletions": 3, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6fb917d907f8ae1708f3aea9805957e27992624c/gcc%2Fconfig%2Fsh%2Fpredicates.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6fb917d907f8ae1708f3aea9805957e27992624c/gcc%2Fconfig%2Fsh%2Fpredicates.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fpredicates.md?ref=6fb917d907f8ae1708f3aea9805957e27992624c", "patch": "@@ -1158,10 +1158,18 @@\n \n ;; A predicate describing the T bit register in any form.\n (define_predicate \"t_reg_operand\"\n-  (match_code \"reg,subreg,sign_extend,zero_extend\")\n+  (match_code \"reg,subreg,sign_extend,zero_extend,ne,eq\")\n {\n   switch (GET_CODE (op))\n     {\n+      case EQ:\n+\treturn t_reg_operand (XEXP (op, 0), GET_MODE (XEXP (op, 0)))\n+\t       && XEXP (op, 1) == const1_rtx;\n+\n+      case NE:\n+\treturn t_reg_operand (XEXP (op, 0), GET_MODE (XEXP (op, 0)))\n+\t       && XEXP (op, 1) == const0_rtx;\n+\n       case REG:\n \treturn REGNO (op) == T_REG;\n \n@@ -1183,13 +1191,21 @@\n \n ;; A predicate describing a negated T bit register.\n (define_predicate \"negt_reg_operand\"\n-  (match_code \"subreg,xor\")\n+  (match_code \"subreg,xor,ne,eq\")\n {\n   switch (GET_CODE (op))\n     {\n+      case EQ:\n+\treturn t_reg_operand (XEXP (op, 0), GET_MODE (XEXP (op, 0)))\n+\t       && XEXP (op, 1) == const0_rtx;\n+\n+      case NE:\n+\treturn t_reg_operand (XEXP (op, 0), GET_MODE (XEXP (op, 0)))\n+\t       && XEXP (op, 1) == const1_rtx;\n+\n       case XOR:\n \treturn t_reg_operand (XEXP (op, 0), GET_MODE (XEXP (op, 0)))\n-\t       && satisfies_constraint_M (XEXP (op, 1));\n+\t       && XEXP (op, 1) == const1_rtx;\n \n       case SUBREG:\n \treturn negt_reg_operand (XEXP (op, 0), GET_MODE (XEXP (op, 0)));"}, {"sha": "b203258102af2b84bf2837bc0912bc47d3df3427", "filename": "gcc/config/sh/sh.c", "status": "modified", "additions": 55, "deletions": 45, "changes": 100, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6fb917d907f8ae1708f3aea9805957e27992624c/gcc%2Fconfig%2Fsh%2Fsh.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6fb917d907f8ae1708f3aea9805957e27992624c/gcc%2Fconfig%2Fsh%2Fsh.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fsh.c?ref=6fb917d907f8ae1708f3aea9805957e27992624c", "patch": "@@ -3592,13 +3592,12 @@ sh_rtx_costs (rtx x, machine_mode mode ATTRIBUTE_UNUSED, int outer_code,\n \n     case EQ:\n       /* An and with a constant compared against zero is\n-\t most likely going to be a TST #imm, R0 instruction.\n-\t Notice that this does not catch the zero_extract variants from\n-\t the md file.  */\n+\t most likely going to be a TST #imm, R0 instruction.  */\n       if (XEXP (x, 1) == const0_rtx\n-          && (GET_CODE (XEXP (x, 0)) == AND\n-              || (SUBREG_P (XEXP (x, 0))\n-\t\t  && GET_CODE (SUBREG_REG (XEXP (x, 0))) == AND)))\n+          && ((GET_CODE (XEXP (x, 0)) == AND\n+               || (SUBREG_P (XEXP (x, 0))\n+\t\t   && GET_CODE (SUBREG_REG (XEXP (x, 0))) == AND))\n+\t      || GET_CODE (XEXP (x, 0)) == ZERO_EXTRACT))\n \t{\n \t  *total = 1;\n \t  return true;\n@@ -14200,7 +14199,8 @@ sh_recog_treg_set_expr (rtx op, machine_mode mode)\n     return false;\n \n   /* Early accept known possible operands before doing recog.  */\n-  if (op == const0_rtx || op == const1_rtx || t_reg_operand (op, mode))\n+  if (op == const0_rtx || op == const1_rtx || t_reg_operand (op, mode)\n+      || negt_reg_operand (op, mode))\n     return true;\n \n   /* Early reject impossible operands before doing recog.\n@@ -14209,8 +14209,8 @@ sh_recog_treg_set_expr (rtx op, machine_mode mode)\n      such as lower-subreg will bail out.  Some insns such as SH4A movua are\n      done with UNSPEC, so must reject those, too, or else it would result\n      in an invalid reg -> treg move.  */\n-  if (register_operand (op, mode) || memory_operand (op, mode)\n-      || sh_unspec_insn_p (op))\n+  if (CONST_INT_P (op) || register_operand (op, mode)\n+      || memory_operand (op, mode) || sh_unspec_insn_p (op))\n     return false;\n \n   if (!can_create_pseudo_p ())\n@@ -14230,26 +14230,30 @@ sh_recog_treg_set_expr (rtx op, machine_mode mode)\n   SET_PREV_INSN (i) = NULL;\n   SET_NEXT_INSN (i) = NULL;\n \n+  /* If the comparison op doesn't have a result mode, set it to SImode.  */\n+  machine_mode prev_op_mode = GET_MODE (op);\n+  if (COMPARISON_P (op) && prev_op_mode == VOIDmode)\n+    PUT_MODE (op, SImode);\n+\n   int result = recog (PATTERN (i), i, 0);\n \n-  /* It seems there is no insn like that.  Create a simple negated\n-     version and try again.  If we hit a negated form, we'll allow that\n-     and append a nott sequence when splitting out the insns.  Insns that\n-     do the split can then remove the trailing nott if they know how to\n-     deal with it.  */\n-  if (result < 0 && GET_CODE (op) == EQ)\n+  /* It seems there is no insn like that.  Create a negated version and\n+     try again.  If we hit a negated form, we'll allow that and append a\n+     nott sequence when splitting out the insns.  Insns that do the split\n+     can then remove the trailing nott if they know how to deal with it.  */\n+  if (result < 0 && COMPARISON_P (op))\n     {\n-      PUT_CODE (op, NE);\n-      result = recog (PATTERN (i), i, 0);\n-      PUT_CODE (op, EQ);\n-    }\n-  if (result < 0 && GET_CODE (op) == NE)\n-    {\n-      PUT_CODE (op, EQ);\n+      machine_mode cmp_mode = GET_MODE (XEXP (op, 0));\n+      if (cmp_mode == VOIDmode)\n+        cmp_mode = GET_MODE (XEXP (op, 1));\n+\n+      rtx_code prev_code = GET_CODE (op);\n+      PUT_CODE (op, reverse_condition (GET_CODE (op)));\n       result = recog (PATTERN (i), i, 0);\n-      PUT_CODE (op, NE);\n+      PUT_CODE (op, prev_code);\n     }\n \n+  PUT_MODE (op, prev_op_mode);\n   recog_data = prev_recog_data;\n   return result >= 0;\n }\n@@ -14350,36 +14354,42 @@ sh_split_treg_set_expr (rtx x, rtx_insn* curr_insn)\n       fprintf (dump_file, \"\\n\");\n     }\n \n+  /* If the insn is not found, we will try a negated form and append\n+     a nott.  */\n+  bool append_nott = false;\n+\n   /* We are going to invoke recog/split_insns in a re-entrant way and thus\n      have to capture its current state and restore it afterwards.  */\n   recog_data_d prev_recog_data = recog_data;\n \n-  int insn_code = recog (PATTERN (i), i, 0);\n-\n-  /* If the insn was not found, see if we matched the negated form before\n-     and append a nott.  */\n-  bool append_nott = false;\n-\n-  if (insn_code < 0 && GET_CODE (x) == EQ)\n+  if (negt_reg_operand (x, GET_MODE (x)))\n     {\n-      PUT_CODE (x, NE);\n-      insn_code = recog (PATTERN (i), i, 0);\n-      if (insn_code >= 0)\n-\tappend_nott = true;\n-      else\n-\tPUT_CODE (x, EQ);\n+      /* This is a normal movt followed by a nott.  It will be converted\n+\t into a movrt after initial expansion.  */\n+      XEXP (PATTERN (i), 1) = get_t_reg_rtx ();\n+      append_nott = true;\n     }\n-  if (insn_code < 0 && GET_CODE (x) == NE)\n+  else\n     {\n-      PUT_CODE (x, EQ);\n-      insn_code = recog (PATTERN (i), i, 0);\n-      if (insn_code >= 0)\n-\tappend_nott = true;\n-      else\n-\tPUT_CODE (x, NE);\n-    }\n+      /* If the comparison op doesn't have a mode set, set it to SImode.  */\n+      if (COMPARISON_P (x) && GET_MODE (x) == VOIDmode)\n+\tPUT_MODE (x, SImode);\n+\n+      int insn_code = recog (PATTERN (i), i, 0);\n \n-  gcc_assert (insn_code >= 0);\n+      if (insn_code < 0 && COMPARISON_P (x))\n+\t{\n+\t  machine_mode cmp_mode = GET_MODE (XEXP (x, 0));\n+\t  if (cmp_mode == VOIDmode)\n+\t    cmp_mode = GET_MODE (XEXP (x, 1));\n+\n+\t  PUT_CODE (x, reverse_condition (GET_CODE (x)));\n+\t  insn_code = recog (PATTERN (i), i, 0);\n+\t  append_nott = true;\n+\t}\n+\n+      gcc_assert (insn_code >= 0);\n+    }\n \n   /* Try to recursively split the insn.  Some insns might refuse to split\n      any further while we are in the treg_set_expr splitting phase.  They"}, {"sha": "c2f693b7e3391730b46ad64c429c8dc50877d989", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6fb917d907f8ae1708f3aea9805957e27992624c/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6fb917d907f8ae1708f3aea9805957e27992624c/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=6fb917d907f8ae1708f3aea9805957e27992624c", "patch": "@@ -1,3 +1,12 @@\n+2015-09-28  Oleg Endo  <olegendo@gcc.gnu.org>\n+\n+\tPR target/54236\n+\t* gcc.target/sh/pr54236-1.c (test_09, test_10, test_11): New.\n+\t* gcc.target/sh/pr59533-1.c (test_23, test_24, test_25, test_26,\n+\ttest_27): New.\n+\t* gcc.target/sh/pr54236-5.c: New.\n+\t* gcc.target/sh/pr54236-6.c: New.\n+\n 2015-09-28  Kyrylo Tkachov  <kyrylo.tkachov@arm.com>\n \n \tPR rtl-optimization/67456"}, {"sha": "7d89a5ee1701e5b8d88e19c3c5cd16609c59dfe9", "filename": "gcc/testsuite/gcc.target/sh/pr54236-1.c", "status": "modified", "additions": 24, "deletions": 2, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6fb917d907f8ae1708f3aea9805957e27992624c/gcc%2Ftestsuite%2Fgcc.target%2Fsh%2Fpr54236-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6fb917d907f8ae1708f3aea9805957e27992624c/gcc%2Ftestsuite%2Fgcc.target%2Fsh%2Fpr54236-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fsh%2Fpr54236-1.c?ref=6fb917d907f8ae1708f3aea9805957e27992624c", "patch": "@@ -4,8 +4,8 @@\n /* { dg-do compile }  */\n /* { dg-options \"-O1\" } */\n /* { dg-skip-if \"\" { \"sh*-*-*\" } { \"-m5*\"} { \"\" } } */\n-/* { dg-final { scan-assembler-times \"addc\" 4 } } */\n-/* { dg-final { scan-assembler-times \"subc\" 3 } } */\n+/* { dg-final { scan-assembler-times \"addc\" 6 } } */\n+/* { dg-final { scan-assembler-times \"subc\" 4 } } */\n /* { dg-final { scan-assembler-times \"sett\" 5 } } */\n \n /* { dg-final { scan-assembler-times \"negc\" 2 { target { ! sh2a } } } }  */\n@@ -86,3 +86,25 @@ test_08 (int a)\n   /* 1x addc, 1x sett  */\n   return (a << 1) + 1;\n }\n+\n+unsigned int\n+test_09 (unsigned int x)\n+{\n+  /* 1x tst, 1x addc  */\n+  return x - (x != 0);\n+}\n+\n+unsigned int\n+test_10 (unsigned int x)\n+{\n+  /* 1x tst, 1x subc  */\n+  return x + (x == 0);\n+}\n+\n+unsigned int\n+test_11 (unsigned int x)\n+{\n+  /* 1x tst, 1x addc  */\n+  return x + (x != 0);\n+}\n+"}, {"sha": "082b4f0bd3e610c4b567b26d348bb6bbf1a281f5", "filename": "gcc/testsuite/gcc.target/sh/pr54236-5.c", "status": "added", "additions": 89, "deletions": 0, "changes": 89, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6fb917d907f8ae1708f3aea9805957e27992624c/gcc%2Ftestsuite%2Fgcc.target%2Fsh%2Fpr54236-5.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6fb917d907f8ae1708f3aea9805957e27992624c/gcc%2Ftestsuite%2Fgcc.target%2Fsh%2Fpr54236-5.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fsh%2Fpr54236-5.c?ref=6fb917d907f8ae1708f3aea9805957e27992624c", "patch": "@@ -0,0 +1,89 @@\n+/* Check that addc and subc instructions are generated as expected in\n+   combination with ifcvt.  */\n+/* { dg-do compile }  */\n+/* { dg-options \"-O2\" }  */\n+\n+/* { dg-final { scan-assembler-times \"subc\" 4 { target { ! sh2a } } } }  */\n+/* { dg-final { scan-assembler-times \"addc\" 4 { target { ! sh2a } } } }  */\n+/* { dg-final { scan-assembler-times \"not\\t\" 0 { target { ! sh2a } } } }  */\n+\n+/* { dg-final { scan-assembler-times \"subc\" 4 { target { sh2a } } } }  */\n+/* { dg-final { scan-assembler-times \"addc\" 4 { target { sh2a } } } }  */\n+/* { dg-final { scan-assembler-times \"nott\" 0 { target { sh2a } } } }  */\n+\n+/* { dg-final { scan-assembler-times \"tst\\t\" 4 } }  */\n+/* { dg-final { scan-assembler-times \"cmp/eq\" 1 } }  */\n+/* { dg-final { scan-assembler-times \"cmp/pl\" 2 } }  */\n+/* { dg-final { scan-assembler-times \"cmp/gt\" 1 } }  */\n+\n+/* { dg-final { scan-assembler-not \"movt\" } }  */\n+/* { dg-final { scan-assembler-not \"negc\" } }  */\n+/* { dg-final { scan-assembler-not \"movrt\" } }  */\n+\n+int\n+test_00 (int x, int y)\n+{\n+  /* 1x tst, 1x subc  */\n+  if (y)\n+    ++x;\n+  return x;\n+}\n+\n+int\n+test_01 (int x, int y)\n+{\n+  /* 1x tst, 1x addc  */\n+  if (y)\n+    --x;\n+  return x;\n+}\n+\n+int\n+test_02 (int x, int y)\n+{\n+  /* 1x tst, 1x addc  */\n+  if (!y)\n+    ++x;\n+  return x;\n+}\n+\n+int\n+test_03 (int x, int y)\n+{\n+  /* 1x tst, 1x subc  */\n+  if (!y)\n+    --x;\n+  return x;\n+}\n+\n+int\n+test_04 (int x, int y)\n+{\n+  /* 1x cmp/eq, 1x addc  */\n+  if (y == x)\n+    ++x;\n+  return x;\n+}\n+\n+int\n+test_05 (int x, int y)\n+{\n+  /* 1x cmp/gt, 1x subc  */\n+  if (y < 4)\n+    ++x;\n+  return x;\n+}\n+\n+int\n+test_06 (int x)\n+{\n+  /* 1x cmp/pl, 1x addc  */\n+  return x > 0 ? x + 1 : x;\n+}\n+\n+int\n+test_07 (int x)\n+{\n+  /* 1x cmp/pl, 1x subc  */\n+  return x > 0 ? x - 1 : x;\n+}"}, {"sha": "9920618f3a83c8ff31c2bc04a7dbed26d612d4a3", "filename": "gcc/testsuite/gcc.target/sh/pr54236-6.c", "status": "added", "additions": 75, "deletions": 0, "changes": 75, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6fb917d907f8ae1708f3aea9805957e27992624c/gcc%2Ftestsuite%2Fgcc.target%2Fsh%2Fpr54236-6.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6fb917d907f8ae1708f3aea9805957e27992624c/gcc%2Ftestsuite%2Fgcc.target%2Fsh%2Fpr54236-6.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fsh%2Fpr54236-6.c?ref=6fb917d907f8ae1708f3aea9805957e27992624c", "patch": "@@ -0,0 +1,75 @@\n+/* In this snippet, there was a missed subc case:\n+\ttst\t#1,r0\n+\tmovt\tr0\n+\tneg\tr0,r0\n+\n+   which should be:\n+\ttst\t#1,r0\n+\tsubc\tr0,r0\n+*/\n+\n+/* { dg-do compile }  */\n+/* { dg-options \"-O2\" }  */\n+\n+/* { dg-final { scan-assembler-times {tst\t#1,r0} 1 } }  */\n+/* { dg-final { scan-assembler-times {subc\tr} 1 } }  */\n+\n+/* { dg-final { scan-assembler-not \"movt|not|neg\\movrt\" } }  */\n+\n+\n+struct inode\n+{\n+  unsigned int i_gid;\n+};\n+\n+struct iattr\n+{\n+  unsigned int ia_valid;\n+  unsigned int ia_gid;\n+};\n+\n+struct task_struct\n+{\n+  unsigned long flags;\n+  unsigned int cap_effective;\n+};\n+\n+extern int in_group_p (unsigned int);\n+\n+static inline struct task_struct*\n+get_current (void)\n+{\n+  struct task_struct *current;\n+  return current;\n+}\n+\n+static inline int\n+capable (int cap)\n+{\n+  if (((get_current()->cap_effective) & (1 << (cap))))\n+    {\n+      get_current()->flags |= 0x00000100;\n+      return 1;\n+    }\n+  return 0;\n+}\n+\n+int\n+inode_change_ok (struct inode *inode, struct iattr *attr)\n+{\n+  int retval = -1;\n+  unsigned int ia_valid = attr->ia_valid;\n+\n+  if (ia_valid & 512)\n+    goto fine;\n+\n+  if ((ia_valid & 4)\n+      && (!in_group_p(attr->ia_gid) && attr->ia_gid != inode->i_gid)\n+      && !capable(0))\n+    goto error;\n+\n+fine:\n+ retval = 0;\n+error:\n+ return retval;\n+}"}, {"sha": "c5c6c7e141b7d79f6b0bff2bae6d80ec8c4ee2f4", "filename": "gcc/testsuite/gcc.target/sh/pr59533-1.c", "status": "modified", "additions": 41, "deletions": 6, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6fb917d907f8ae1708f3aea9805957e27992624c/gcc%2Ftestsuite%2Fgcc.target%2Fsh%2Fpr59533-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6fb917d907f8ae1708f3aea9805957e27992624c/gcc%2Ftestsuite%2Fgcc.target%2Fsh%2Fpr59533-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fsh%2Fpr59533-1.c?ref=6fb917d907f8ae1708f3aea9805957e27992624c", "patch": "@@ -9,13 +9,13 @@\n /* { dg-final { scan-assembler-times \"and\" 3 } }  */\n /* { dg-final { scan-assembler-times \"extu.b\" 5 } }  */\n \n-/* { dg-final { scan-assembler-times \"cmp/pz\" 22 { target { ! sh2a } } } }  */\n-/* { dg-final { scan-assembler-times \"addc\" 3 { target { ! sh2a } } } }  */\n-/* { dg-final { scan-assembler-times \"subc\" 12 { target { ! sh2a } } } }  */\n+/* { dg-final { scan-assembler-times \"cmp/pz\" 27 { target { ! sh2a } } } }  */\n+/* { dg-final { scan-assembler-times \"addc\" 4 { target { ! sh2a } } } }  */\n+/* { dg-final { scan-assembler-times \"subc\" 16 { target { ! sh2a } } } }  */\n \n-/* { dg-final { scan-assembler-times \"cmp/pz\" 20 { target { sh2a } } } }  */\n-/* { dg-final { scan-assembler-times \"addc\" 5 { target { sh2a } } } }  */\n-/* { dg-final { scan-assembler-times \"subc\" 10 { target { sh2a } } } }  */\n+/* { dg-final { scan-assembler-times \"cmp/pz\" 25 { target { sh2a } } } }  */\n+/* { dg-final { scan-assembler-times \"addc\" 6 { target { sh2a } } } }  */\n+/* { dg-final { scan-assembler-times \"subc\" 14 { target { sh2a } } } }  */\n /* { dg-final { scan-assembler-times \"bld\" 2 { target { sh2a } } } }  */\n \n int\n@@ -183,3 +183,38 @@ test_22 (int x)\n   /* 1x cmp/pz, 1x movt  */\n   return (x >> 31) + 1;\n }\n+\n+int\n+test_23 (int x)\n+{\n+  /* 1x cmp/pz, 1x subc */\n+  return x < 0 ? x + 1 : x;\n+}\n+\n+unsigned int\n+test_24 (unsigned int x)\n+{\n+  /* 1x cmp/pz, 1x subc */\n+  return x & 0x80000000 ? x + 1 : x;\n+}\n+\n+unsigned int\n+test_25 (unsigned int x)\n+{\n+  /* 1x cmp/pz, 1x subc */\n+  return x >> 31 ? x + 1 : x;\n+}\n+\n+int\n+test_26 (int x)\n+{\n+  /* 1x cmp/pz, 1x subc  */\n+  return x >> 31 ? x + 1 : x;\n+}\n+\n+int\n+test_27 (int x, int y, int z)\n+{\n+  /* 1x cmp/pz, 1x addc  */\n+  return 1 - ((x >> 4) < 0) + z;\n+}"}]}