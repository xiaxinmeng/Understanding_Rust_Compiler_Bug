{"sha": "ed513abf7727c017096c2461bd4be33c833840d6", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZWQ1MTNhYmY3NzI3YzAxNzA5NmMyNDYxYmQ0YmUzM2M4MzM4NDBkNg==", "commit": {"author": {"name": "Kaveh R. Ghazi", "email": "ghazi@caip.rutgers.edu", "date": "1999-03-17T06:34:46Z"}, "committer": {"name": "Kaveh Ghazi", "email": "ghazi@gcc.gnu.org", "date": "1999-03-17T06:34:46Z"}, "message": "c-lex.c: Don't include setjmp.h.\n\n        * c-lex.c: Don't include setjmp.h.\n        (parse_float): New static function.\n        (pf_args): New struct.\n        (yylex): Use them in call to `do_float_handler'.\n\nFrom-SVN: r25816", "tree": {"sha": "bd80e289866143e1b501d6fa2ad993495bc5a9d7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/bd80e289866143e1b501d6fa2ad993495bc5a9d7"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ed513abf7727c017096c2461bd4be33c833840d6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ed513abf7727c017096c2461bd4be33c833840d6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ed513abf7727c017096c2461bd4be33c833840d6", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ed513abf7727c017096c2461bd4be33c833840d6/comments", "author": null, "committer": null, "parents": [{"sha": "5395a57667808cc1593687f4ad4f7f9e2a332940", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5395a57667808cc1593687f4ad4f7f9e2a332940", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5395a57667808cc1593687f4ad4f7f9e2a332940"}], "stats": {"total": 246, "additions": 144, "deletions": 102}, "files": [{"sha": "84bff3ff0b23257c593c5ea6fc44c715d372d0ac", "filename": "gcc/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ed513abf7727c017096c2461bd4be33c833840d6/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ed513abf7727c017096c2461bd4be33c833840d6/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=ed513abf7727c017096c2461bd4be33c833840d6", "patch": "@@ -1,3 +1,10 @@\n+Wed Mar 17 09:25:06 1999  Kaveh R. Ghazi  <ghazi@caip.rutgers.edu>\n+\n+        * c-lex.c: Don't include setjmp.h.\n+\t(parse_float): New static function.\n+\t(pf_args): New struct.\n+\t(yylex): Use them in call to `do_float_handler'.\n+\n 1999-03-16  Andreas Schwab  <schwab@issan.cs.uni-dortmund.de>\n \n \t* cexp.y (yyerror): Call verror to get a usefull error message."}, {"sha": "ce7c6e9bcfa0a26bac8b7ac54f2618b9799c2104", "filename": "gcc/c-lex.c", "status": "modified", "additions": 137, "deletions": 102, "changes": 239, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ed513abf7727c017096c2461bd4be33c833840d6/gcc%2Fc-lex.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ed513abf7727c017096c2461bd4be33c833840d6/gcc%2Fc-lex.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-lex.c?ref=ed513abf7727c017096c2461bd4be33c833840d6", "patch": "@@ -20,7 +20,6 @@ Boston, MA 02111-1307, USA.  */\n \n #include \"config.h\"\n #include \"system.h\"\n-#include <setjmp.h>\n \n #include \"rtl.h\"\n #include \"tree.h\"\n@@ -126,6 +125,7 @@ static int skip_white_space\t\tPROTO((int));\n static int skip_white_space_on_line\tPROTO((void));\n static char *extend_token_buffer\tPROTO((const char *));\n static int readescape\t\t\tPROTO((int *));\n+static void parse_float\t\t\tPROTO((PTR));\n \f\n /* Do not insert generated code into the source, instead, include it.\n    This allows us to build gcc automatically even for targets that\n@@ -1090,6 +1090,120 @@ struct try_type type_sequence[] =\n };\n #endif /* 0 */\n \f\n+struct pf_args\n+{\n+  /* Input */\n+  int base;\n+  char * p;\n+  /* I/O */\n+  int c;\n+  int imag;\n+  tree type;\n+  int conversion_errno;\n+  /* Output */\n+  REAL_VALUE_TYPE value;\n+};\n+ \n+static void\n+parse_float (data)\n+  PTR data;\n+{\n+  struct pf_args * args = (struct pf_args *) data;\n+  int fflag = 0, lflag = 0;\n+  /* Copy token_buffer now, while it has just the number\n+     and not the suffixes; once we add `f' or `i',\n+     REAL_VALUE_ATOF may not work any more.  */\n+  char *copy = (char *) alloca (args->p - token_buffer + 1);\n+  bcopy (token_buffer, copy, args->p - token_buffer + 1);\n+\n+  while (1)\n+    {\n+      int lose = 0;\n+\n+      /* Read the suffixes to choose a data type.  */\n+      switch (args->c)\n+\t{\n+\tcase 'f': case 'F':\n+\t  if (fflag)\n+\t    error (\"more than one `f' in numeric constant\");\n+\t  fflag = 1;\n+\t  break;\n+\n+\tcase 'l': case 'L':\n+\t  if (lflag)\n+\t    error (\"more than one `l' in numeric constant\");\n+\t  lflag = 1;\n+\t  break;\n+\n+\tcase 'i': case 'I':\n+\t  if (args->imag)\n+\t    error (\"more than one `i' or `j' in numeric constant\");\n+\t  else if (pedantic)\n+\t    pedwarn (\"ANSI C forbids imaginary numeric constants\");\n+\t  args->imag = 1;\n+\t  break;\n+\n+\tdefault:\n+\t  lose = 1;\n+\t}\n+\n+      if (lose)\n+\tbreak;\n+\n+      if (args->p >= token_buffer + maxtoken - 3)\n+\targs->p = extend_token_buffer (args->p);\n+      *(args->p++) = args->c;\n+      *(args->p) = 0;\n+      args->c = GETC();\n+    }\n+\n+  /* The second argument, machine_mode, of REAL_VALUE_ATOF\n+     tells the desired precision of the binary result\n+     of decimal-to-binary conversion.  */\n+\n+  if (fflag)\n+    {\n+      if (lflag)\n+\terror (\"both `f' and `l' in floating constant\");\n+\n+      args->type = float_type_node;\n+      errno = 0;\n+      if (args->base == 16)\n+\targs->value = REAL_VALUE_HTOF (copy, TYPE_MODE (args->type));\n+      else\n+\targs->value = REAL_VALUE_ATOF (copy, TYPE_MODE (args->type));\n+      args->conversion_errno = errno;\n+      /* A diagnostic is required here by some ANSI C testsuites.\n+\t This is not pedwarn, because some people don't want\n+\t an error for this.  */\n+      if (REAL_VALUE_ISINF (args->value) && pedantic)\n+\twarning (\"floating point number exceeds range of `float'\");\n+    }\n+  else if (lflag)\n+    {\n+      args->type = long_double_type_node;\n+      errno = 0;\n+      if (args->base == 16)\n+\targs->value = REAL_VALUE_HTOF (copy, TYPE_MODE (args->type));\n+      else\n+\targs->value = REAL_VALUE_ATOF (copy, TYPE_MODE (args->type));\n+      args->conversion_errno = errno;\n+      if (REAL_VALUE_ISINF (args->value) && pedantic)\n+\twarning (\"floating point number exceeds range of `long double'\");\n+    }\n+  else\n+    {\n+      errno = 0;\n+      if (args->base == 16)\n+\targs->value = REAL_VALUE_HTOF (copy, TYPE_MODE (args->type));\n+      else\n+\targs->value = REAL_VALUE_ATOF (copy, TYPE_MODE (args->type));\n+      args->conversion_errno = errno;\n+      if (REAL_VALUE_ISINF (args->value) && pedantic)\n+\twarning (\"floating point number exceeds range of `double'\");\n+    }\n+}\n+ \n int\n yylex ()\n {\n@@ -1490,7 +1604,7 @@ yylex ()\n \t    int imag = 0;\n \t    int conversion_errno = 0;\n \t    REAL_VALUE_TYPE value;\n-\t    jmp_buf handler;\n+\t    struct pf_args args;\n \n \t    /* Read explicit exponent if any, and put it in tokenbuf.  */\n \n@@ -1522,112 +1636,33 @@ yylex ()\n \n \t    *p = 0;\n \n+\t    /* Setup input for parse_float() */\n+\t    args.base = base;\n+\t    args.p = p;\n+\t    args.c = c;\n+\t    args.imag = imag;\n+\t    args.type = type;\n+\t    args.conversion_errno = conversion_errno;\n+\n \t    /* Convert string to a double, checking for overflow.  */\n-\t    if (setjmp (handler))\n+\t    if (do_float_handler (parse_float, (PTR) &args))\n \t      {\n-\t\terror (\"floating constant out of range\");\n-\t\tvalue = dconst0;\n+\t\t/* Receive output from parse_float() */\n+\t\tvalue = args.value;\n \t      }\n \t    else\n \t      {\n-\t\tint fflag = 0, lflag = 0;\n-\t\t/* Copy token_buffer now, while it has just the number\n-\t\t   and not the suffixes; once we add `f' or `i',\n-\t\t   REAL_VALUE_ATOF may not work any more.  */\n-\t\tchar *copy = (char *) alloca (p - token_buffer + 1);\n-\t\tbcopy (token_buffer, copy, p - token_buffer + 1);\n-\n-\t\tset_float_handler (handler);\n-\n-\t\twhile (1)\n-\t\t  {\n-\t\t    int lose = 0;\n-\n-\t\t    /* Read the suffixes to choose a data type.  */\n-\t\t    switch (c)\n-\t\t      {\n-\t\t      case 'f': case 'F':\n-\t\t\tif (fflag)\n-\t\t\t  error (\"more than one `f' in numeric constant\");\n-\t\t\tfflag = 1;\n-\t\t\tbreak;\n-\n-\t\t      case 'l': case 'L':\n-\t\t\tif (lflag)\n-\t\t\t  error (\"more than one `l' in numeric constant\");\n-\t\t\tlflag = 1;\n-\t\t\tbreak;\n-\n-\t\t      case 'i': case 'I':\n-\t\t\tif (imag)\n-\t\t\t  error (\"more than one `i' or `j' in numeric constant\");\n-\t\t\telse if (pedantic)\n-\t\t\t  pedwarn (\"ANSI C forbids imaginary numeric constants\");\n-\t\t\timag = 1;\n-\t\t\tbreak;\n-\n-\t\t      default:\n-\t\t\tlose = 1;\n-\t\t      }\n-\n-\t\t    if (lose)\n-\t\t      break;\n-\n-\t\t    if (p >= token_buffer + maxtoken - 3)\n-\t\t      p = extend_token_buffer (p);\n-\t\t    *p++ = c;\n-\t\t    *p = 0;\n-\t\t    c = GETC();\n-\t\t  }\n-\n-\t\t/* The second argument, machine_mode, of REAL_VALUE_ATOF\n-\t\t   tells the desired precision of the binary result\n-\t\t   of decimal-to-binary conversion.  */\n-\n-\t\tif (fflag)\n-\t\t  {\n-\t\t    if (lflag)\n-\t\t      error (\"both `f' and `l' in floating constant\");\n-\n-\t\t    type = float_type_node;\n-\t\t    errno = 0;\n-\t\t    if (base == 16)\n-\t\t      value = REAL_VALUE_HTOF (copy, TYPE_MODE (type));\n-\t\t    else\n-\t\t      value = REAL_VALUE_ATOF (copy, TYPE_MODE (type));\n-\t\t    conversion_errno = errno;\n-\t\t    /* A diagnostic is required here by some ANSI C testsuites.\n-\t\t       This is not pedwarn, because some people don't want\n-\t\t       an error for this.  */\n-\t\t    if (REAL_VALUE_ISINF (value) && pedantic)\n-\t\t      warning (\"floating point number exceeds range of `float'\");\n-\t\t  }\n-\t\telse if (lflag)\n-\t\t  {\n-\t\t    type = long_double_type_node;\n-\t\t    errno = 0;\n-\t\t    if (base == 16)\n-\t\t      value = REAL_VALUE_HTOF (copy, TYPE_MODE (type));\n-\t\t    else\n-\t\t      value = REAL_VALUE_ATOF (copy, TYPE_MODE (type));\n-\t\t    conversion_errno = errno;\n-\t\t    if (REAL_VALUE_ISINF (value) && pedantic)\n-\t\t      warning (\"floating point number exceeds range of `long double'\");\n-\t\t  }\n-\t\telse\n-\t\t  {\n-\t\t    errno = 0;\n-\t\t    if (base == 16)\n-\t\t      value = REAL_VALUE_HTOF (copy, TYPE_MODE (type));\n-\t\t    else\n-\t\t      value = REAL_VALUE_ATOF (copy, TYPE_MODE (type));\n-\t\t    conversion_errno = errno;\n-\t\t    if (REAL_VALUE_ISINF (value) && pedantic)\n-\t\t      warning (\"floating point number exceeds range of `double'\");\n-\t\t  }\n+\t\t/* We got an exception from parse_float() */\n+\t\terror (\"floating constant out of range\");\n+\t\tvalue = dconst0;\n+\t      }\n \n-\t\tset_float_handler (NULL_PTR);\n-\t    }\n+\t    /* Receive output from parse_float() */\n+\t    c = args.c;\n+\t    imag = args.imag;\n+\t    type = args.type;\n+\t    conversion_errno = args.conversion_errno;\n+\t    \n #ifdef ERANGE\n \t    /* ERANGE is also reported for underflow,\n \t       so test the value to distinguish overflow from that.  */"}]}