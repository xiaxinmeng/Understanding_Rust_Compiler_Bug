{"sha": "fbaeb717be672acdb109f85765eedc647628d855", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZmJhZWI3MTdiZTY3MmFjZGIxMDlmODU3NjVlZWRjNjQ3NjI4ZDg1NQ==", "commit": {"author": {"name": "Kaz Kojima", "email": "kkojima@gcc.gnu.org", "date": "2007-07-03T16:56:20Z"}, "committer": {"name": "Nick Clifton", "email": "nickc@gcc.gnu.org", "date": "2007-07-03T16:56:20Z"}, "message": "constraints.md: New file.\n\n* config/m32r/constraints.md: New file.\n* config/m32r/m32r.c: Include tm-constrs.h.\n  (small_data_operand): Use satisfies_constraint_* instead of macro.\n  (addr24_operand, gen_compare): Likewise.\n* config/m32r/m32r.h (REG_CLASS_FROM_LETTER): Remove.\n  (INT8_P, UPPER16_P, UINT32_P, UINT5_P, INVERTED_SIGNED_8BIT,\n  CONST_OK_FOR_LETTER_P, CONST_DOUBLE_OK_FOR_LETTER_P, EXTRA_CONSTRAINT): Likewise.\n* config/m32r/m32r.md: Include constraints.md.\n  (movsi_insn): Use satisfies_constraint_* instead of macro.\n  (andsi3, iorsi3, xorsi3, seq_insn+1, sne): Likewise.\n* config/m32r/predicates.md (conditional_move_operand): Likewise.\n  (two_insn_const_operand, int8_operand, uint16_operand,\n   reg_or_int16_operand, reg_or_uint16_operand,\n   reg_or_cmp_int16_operand, cmp_int16_operand,\n   seth_add3_operand): Likewise.\n\nFrom-SVN: r126265", "tree": {"sha": "9e67e8dd0a06a422c7fc60ee07ff0ba61eeffe22", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/9e67e8dd0a06a422c7fc60ee07ff0ba61eeffe22"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/fbaeb717be672acdb109f85765eedc647628d855", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fbaeb717be672acdb109f85765eedc647628d855", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fbaeb717be672acdb109f85765eedc647628d855", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fbaeb717be672acdb109f85765eedc647628d855/comments", "author": null, "committer": null, "parents": [{"sha": "db430f6a2a5997bed3109eff088c4e86020378d0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/db430f6a2a5997bed3109eff088c4e86020378d0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/db430f6a2a5997bed3109eff088c4e86020378d0"}], "stats": {"total": 300, "additions": 184, "deletions": 116}, "files": [{"sha": "3915974ed416969fb05431efb4a8ca4c043247fa", "filename": "gcc/ChangeLog", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fbaeb717be672acdb109f85765eedc647628d855/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fbaeb717be672acdb109f85765eedc647628d855/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=fbaeb717be672acdb109f85765eedc647628d855", "patch": "@@ -1,3 +1,22 @@\n+2007-07-01  Kaz Kojima  <kkojima@gcc.gnu.org>\n+\n+\t* config/m32r/constraints.md: New file.\n+\t* config/m32r/m32r.c: Include tm-constrs.h.\n+\t(small_data_operand): Use satisfies_constraint_* instead of macro.\n+\t(addr24_operand, gen_compare): Likewise.\n+\t* config/m32r/m32r.h (REG_CLASS_FROM_LETTER): Remove.\n+\t(INT8_P, UPPER16_P, UINT32_P, UINT5_P, INVERTED_SIGNED_8BIT,\n+\tCONST_OK_FOR_LETTER_P, CONST_DOUBLE_OK_FOR_LETTER_P,\n+\tEXTRA_CONSTRAINT): Likewise.\n+\t* config/m32r/m32r.md: Include constraints.md.\n+\t(*movsi_insn): Use satisfies_constraint_* instead of macro.\n+\t(andsi3, iorsi3, xorsi3, seq_insn+1, sne): Likewise.\n+\t* config/m32r/predicates.md (conditional_move_operand): Likewise.\n+\t(two_insn_const_operand, int8_operand, uint16_operand,\n+\treg_or_int16_operand, reg_or_uint16_operand,\n+\treg_or_cmp_int16_operand, cmp_int16_operand,\n+\tseth_add3_operand): Likewise.\n+\n 2007-07-03  Eric Christopher  <echristo@gmail.com>\n \n \t* libgcc2.h: Conditionally declare __bswapsi2 and"}, {"sha": "c9563fa5ded89c7a60ce95bf3e2f02fea23b4304", "filename": "gcc/config/m32r/constraints.md", "status": "added", "additions": 131, "deletions": 0, "changes": 131, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fbaeb717be672acdb109f85765eedc647628d855/gcc%2Fconfig%2Fm32r%2Fconstraints.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fbaeb717be672acdb109f85765eedc647628d855/gcc%2Fconfig%2Fm32r%2Fconstraints.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm32r%2Fconstraints.md?ref=fbaeb717be672acdb109f85765eedc647628d855", "patch": "@@ -0,0 +1,131 @@\n+;; Constraint definitions for Renesas M32R cpu for GNU C compiler\n+;; Copyright (C) 2007 Free Software Foundation, Inc.\n+;;\n+;; This file is part of GCC.\n+;;\n+;; GCC is free software; you can redistribute it and/or modify it\n+;; under the terms of the GNU General Public License as published\n+;; by the Free Software Foundation; either version 2, or (at your\n+;; option) any later version.\n+\n+;; GCC is distributed in the hope that it will be useful, but WITHOUT\n+;; ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n+;; or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public\n+;; License for more details.\n+;;\n+;; You should have received a copy of the GNU General Public License\n+;; along with GCC; see the file COPYING.  If not, write to\n+;; the Free Software Foundation, 51 Franklin Street, Fifth Floor,\n+;; Boston, MA 02110-1301, USA.\n+\n+\n+;; The letters I, J, K, L, M, N, O, P in a register constraint string\n+;; can be used to stand for particular ranges of immediate operands.\n+;; The letters Q, R, S, T, U are used to segregate specific types of\n+;; operands, usually memory references, for the target machine.\n+;;\n+;; I is used for 8-bit signed immediates.\n+;; J is used for 16-bit signed immediates.\n+;; K is used for 16-bit unsigned immediates.\n+;; L is used for 16-bit immediates left shifted by 16 (sign ???).\n+;; M is used for 24-bit unsigned immediates.\n+;; N is used for 8-bit signed immediates for compares\n+;;   (values in the range -127 to +128).\n+;; O is used for 5-bit unsigned immediates (shift count).\n+;; P is used for 16-bit signed immediates for compares\n+;;     (values in the range -32767 to +32768).\n+;;\n+;; Q is for symbolic addresses loadable with ld24.\n+;; R is for symbolic addresses when ld24 can't be used.\n+;; S is for stores with pre {inc,dec}rement\n+;; T is for indirect of a pointer.\n+;; U is for loads with post increment.\n+;;\n+;; Register constraints\n+\n+(define_register_constraint \"a\" \"ACCUM_REGS\"\n+  \"@internal\")\n+\n+(define_register_constraint \"c\" \"CARRY_REG\"\n+  \"@internal\")\n+\n+;; Integer constraints\n+(define_constraint \"I\"\n+  \"8-bit signed immediate.\"\n+  (and (match_code \"const_int\")\n+       (match_test \"ival >= -0x80 && ival <= 0x7f\")))\n+\n+(define_constraint \"J\"\n+  \"16-bit signed immediate.\"\n+  (and (match_code \"const_int\")\n+       (match_test \"ival >= -0x8000 && ival <= 0x7fff\")))\n+\n+(define_constraint \"K\"\n+  \"16-bit unsigned immediate.\"\n+  (and (match_code \"const_int\")\n+       (match_test \"(unsigned HOST_WIDE_INT) ival <= 0x0000ffff\")))\n+\n+(define_constraint \"L\"\n+  \"16-bit signed immediate left shifted by 16.\"\n+  (and (match_code \"const_int\")\n+       (match_test \"(ival & 0xffff) == 0\")\n+       (match_test \"(ival >> 16) >= -0x8000 && (ival >> 16) <= 0x7fff\")))\n+\n+(define_constraint \"M\"\n+  \"24-bit unsigned immediate.\"\n+  (and (match_code \"const_int\")\n+       (match_test \"(unsigned HOST_WIDE_INT) ival <= 0x00ffffff\")))\n+\n+(define_constraint \"N\"\n+  \"8-bit signed immediate for compare.\"\n+  (and (match_code \"const_int\")\n+       (match_test \"ival >= -127 && ival <= 128\")))\n+\n+(define_constraint \"O\"\n+  \"5-bit unsigned immediate.\"\n+  (and (match_code \"const_int\")\n+       (match_test \"ival >= 0 && ival < 32\")))\n+\n+(define_constraint \"P\"\n+  \"16-bit signed immediate for compare.\"\n+  (and (match_code \"const_int\")\n+       (match_test \"ival >= -0x7fff && ival <= 0x8000\")))\n+\n+;; Floating-point constraints\n+(define_constraint \"G\"\n+  \"Double constant loadable with 2 ldi insns.\"\n+  (and (match_code \"const_double\")\n+       (match_test \"easy_di_const (op)\")))\n+\n+(define_constraint \"H\"\n+  \"Double constant loadable with movdf.\"\n+  (and (match_code \"const_double\")\n+       (match_test \"easy_df_const (op)\")))\n+\n+;; Extra constraints\n+(define_constraint \"Q\"\n+  \"A symbolic addresse loadable when ld24.\"\n+  (ior (and (match_test \"TARGET_ADDR24\")\n+\t    (match_test \"GET_CODE (op) == LABEL_REF\"))\n+       (match_test \"addr24_operand (op, VOIDmode)\")))\n+\n+(define_constraint \"R\"\n+  \"A symbolic addresse loadable with ld24 can't be used.\"\n+  (ior (and (match_test \"TARGET_ADDR32\")\n+\t    (match_test \"GET_CODE (op) == LABEL_REF\"))\n+       (match_test \"addr32_operand (op, VOIDmode)\")))\n+\n+(define_constraint \"S\"\n+  \"A store with pre {inc,dec}rement.\"\n+  (and (match_code \"mem\")\n+       (match_test \"STORE_PREINC_PREDEC_P (GET_MODE (op), XEXP (op, 0))\")))\n+\n+(define_constraint \"T\"\n+  \"An indirect of a pointer.\"\n+  (and (match_code \"mem\")\n+       (match_test \"memreg_operand (op, GET_MODE (op))\")))\n+\n+(define_constraint \"U\"\n+  \"A load with post increment.\"\n+  (and (match_code \"mem\")\n+       (match_test \"LOAD_POSTINC_P (GET_MODE (op), XEXP (op, 0))\")))"}, {"sha": "6758d1a579da0f9f357efe9d8e5ea59493796641", "filename": "gcc/config/m32r/m32r.c", "status": "modified", "additions": 7, "deletions": 10, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fbaeb717be672acdb109f85765eedc647628d855/gcc%2Fconfig%2Fm32r%2Fm32r.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fbaeb717be672acdb109f85765eedc647628d855/gcc%2Fconfig%2Fm32r%2Fm32r.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm32r%2Fm32r.c?ref=fbaeb717be672acdb109f85765eedc647628d855", "patch": "@@ -42,6 +42,7 @@\n #include \"tm_p.h\"\n #include \"target.h\"\n #include \"target-def.h\"\n+#include \"tm-constrs.h\"\n \n /* Save the operands last given to a compare for use when we\n    generate a scc or bcc insn.  */\n@@ -508,8 +509,7 @@ small_data_operand (rtx op, enum machine_mode mode ATTRIBUTE_UNUSED)\n   if (GET_CODE (op) == CONST\n       && GET_CODE (XEXP (op, 0)) == PLUS\n       && GET_CODE (XEXP (XEXP (op, 0), 0)) == SYMBOL_REF\n-      && GET_CODE (XEXP (XEXP (op, 0), 1)) == CONST_INT\n-      && INT16_P (INTVAL (XEXP (XEXP (op, 0), 1))))\n+      && satisfies_constraint_J (XEXP (XEXP (op, 0), 1)))\n     return SYMBOL_REF_SMALL_P (XEXP (XEXP (op, 0), 0));\n \n   return 0;\n@@ -533,8 +533,7 @@ addr24_operand (rtx op, enum machine_mode mode ATTRIBUTE_UNUSED)\n   else if (GET_CODE (op) == CONST\n \t   && GET_CODE (XEXP (op, 0)) == PLUS\n \t   && GET_CODE (XEXP (XEXP (op, 0), 0)) == SYMBOL_REF\n-\t   && GET_CODE (XEXP (XEXP (op, 0), 1)) == CONST_INT\n-\t   && UINT24_P (INTVAL (XEXP (XEXP (op, 0), 1))))\n+\t   && satisfies_constraint_M (XEXP (XEXP (op, 0), 1)))\n     sym = XEXP (XEXP (op, 0), 0);\n   else\n     return 0;\n@@ -691,8 +690,7 @@ gen_compare (enum rtx_code code, rtx x, rtx y, int need_compare)\n       switch (compare_code)\n \t{\n \tcase EQ:\n-\t  if (GET_CODE (y) == CONST_INT\n-\t      && CMP_INT16_P (INTVAL (y))\t\t/* Reg equal to small const.  */\n+\t  if (satisfies_constraint_P (y)\t\t/* Reg equal to small const.  */\n \t      && y != const0_rtx)\n \t    {\n \t      rtx tmp = gen_reg_rtx (SImode);\n@@ -718,7 +716,7 @@ gen_compare (enum rtx_code code, rtx x, rtx y, int need_compare)\n \n \tcase LT:\n \t  if (register_operand (y, SImode)\n-\t      || (GET_CODE (y) == CONST_INT && CMP_INT16_P (INTVAL (y))))\n+\t      || satisfies_constraint_P (y))\n \t    {\n \t      rtx tmp = gen_reg_rtx (SImode);\t      /* Reg compared to reg.  */\n \n@@ -758,7 +756,7 @@ gen_compare (enum rtx_code code, rtx x, rtx y, int need_compare)\n \n \tcase LTU:\n \t  if (register_operand (y, SImode)\n-\t      || (GET_CODE (y) == CONST_INT && CMP_INT16_P (INTVAL (y))))\n+\t      || satisfies_constraint_P (y))\n \t    {\n \t      rtx tmp = gen_reg_rtx (SImode);\t      /* Reg (unsigned) compared to reg.  */\n \n@@ -814,8 +812,7 @@ gen_compare (enum rtx_code code, rtx x, rtx y, int need_compare)\n \n       /* Reg/smallconst equal comparison.  */\n       if (compare_code == EQ\n-\t  && GET_CODE (y) == CONST_INT\n-\t  && CMP_INT16_P (INTVAL (y)))\n+\t  && satisfies_constraint_P (y))\n \t{\n \t  rtx tmp = gen_reg_rtx (SImode);\n "}, {"sha": "3b22347d1916b8bfe46fb399f2e4e1f3d9c9c483", "filename": "gcc/config/m32r/m32r.h", "status": "modified", "additions": 4, "deletions": 78, "changes": 82, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fbaeb717be672acdb109f85765eedc647628d855/gcc%2Fconfig%2Fm32r%2Fm32r.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fbaeb717be672acdb109f85765eedc647628d855/gcc%2Fconfig%2Fm32r%2Fm32r.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm32r%2Fm32r.h?ref=fbaeb717be672acdb109f85765eedc647628d855", "patch": "@@ -1,6 +1,6 @@\n /* Definitions of target machine for GNU compiler, Renesas M32R cpu.\n    Copyright (C) 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004,\n-   2005, 2006 Free Software Foundation, Inc.\n+   2005, 2006, 2007 Free Software Foundation, Inc.\n \n    This file is part of GCC.\n \n@@ -671,11 +671,6 @@ extern enum reg_class m32r_regno_reg_class[FIRST_PSEUDO_REGISTER];\n #define INDEX_REG_CLASS GENERAL_REGS\n #define BASE_REG_CLASS GENERAL_REGS\n \n-#define REG_CLASS_FROM_LETTER(C)\t\t\t\\\n-  (  (C) == 'c'\t? CARRY_REG\t\t\t\t\\\n-   : (C) == 'a'\t? ACCUM_REGS\t\t\t\t\\\n-   :\t\t  NO_REGS)\n-\n /* These assume that REGNO is a hard or pseudo reg number.\n    They give nonzero only if REGNO is a hard reg of the suitable class\n    or a pseudo reg currently allocated to a suitable hard reg.\n@@ -699,85 +694,16 @@ extern enum reg_class m32r_regno_reg_class[FIRST_PSEUDO_REGISTER];\n #define CLASS_MAX_NREGS(CLASS, MODE) \\\n   ((GET_MODE_SIZE (MODE) + UNITS_PER_WORD - 1) / UNITS_PER_WORD)\n \n-/* The letters I, J, K, L, M, N, O, P in a register constraint string\n-   can be used to stand for particular ranges of immediate operands.\n-   This macro defines what the ranges are.\n-   C is the letter, and VALUE is a constant value.\n-   Return 1 if VALUE is in the range specified by C.  */\n-/* 'I' is used for 8-bit signed immediates.\n-   'J' is used for 16-bit signed immediates.\n-   'K' is used for 16-bit unsigned immediates.\n-   'L' is used for 16-bit immediates left shifted by 16 (sign ???).\n-   'M' is used for 24-bit unsigned immediates.\n-   'N' is used for any 32-bit non-symbolic value.\n-   'O' is used for 5-bit unsigned immediates (shift count).\n-   'P' is used for 16-bit signed immediates for compares\n-       (values in the range -32767 to +32768).  */\n-\n /* Return true if a value is inside a range.  */\n-#define IN_RANGE_P(VALUE, LOW, HIGH)\t\t\t\t\t\\\n-  (((unsigned HOST_WIDE_INT)((VALUE) - (LOW)))\t\t\t\t\\\n+#define IN_RANGE_P(VALUE, LOW, HIGH)\t\t\t\\\n+  (((unsigned HOST_WIDE_INT)((VALUE) - (LOW)))\t\t\\\n    <= ((unsigned HOST_WIDE_INT)((HIGH) - (LOW))))\n \n-/* Local to this file.  */\n-#define INT8_P(X)      ((X) >= -   0x80 && (X) <= 0x7f)\n+/* Some range macros.  */\n #define INT16_P(X)     ((X) >= - 0x8000 && (X) <= 0x7fff)\n #define CMP_INT16_P(X) ((X) >= - 0x7fff && (X) <= 0x8000)\n-#define UPPER16_P(X)  (((X) & 0xffff) == 0\t\t\t\t\\\n-\t\t        && ((X) >> 16) >= - 0x8000\t\t\t\\\n-\t\t        && ((X) >> 16) <= 0x7fff)\n #define UINT16_P(X)   (((unsigned HOST_WIDE_INT) (X)) <= 0x0000ffff)\n #define UINT24_P(X)   (((unsigned HOST_WIDE_INT) (X)) <= 0x00ffffff)\n-#define UINT32_P(X)   (((unsigned HOST_WIDE_INT) (X)) <= 0xffffffff)\n-#define UINT5_P(X)    ((X) >= 0 && (X) < 32)\n-#define INVERTED_SIGNED_8BIT(VAL) ((VAL) >= -127 && (VAL) <= 128)\n-\n-#define CONST_OK_FOR_LETTER_P(VALUE, C)\t\t\t\t\t\\\n-  (  (C) == 'I' ? INT8_P (VALUE)\t\t\t\t\t\\\n-   : (C) == 'J' ? INT16_P (VALUE)\t\t\t\t\t\\\n-   : (C) == 'K' ? UINT16_P (VALUE)\t\t\t\t\t\\\n-   : (C) == 'L' ? UPPER16_P (VALUE)\t\t\t\t\t\\\n-   : (C) == 'M' ? UINT24_P (VALUE)\t\t\t\t\t\\\n-   : (C) == 'N' ? INVERTED_SIGNED_8BIT (VALUE)\t\t\t\t\\\n-   : (C) == 'O' ? UINT5_P (VALUE)\t\t\t\t\t\\\n-   : (C) == 'P' ? CMP_INT16_P (VALUE)\t\t\t\t\t\\\n-   : 0)\n-\n-/* Similar, but for floating constants, and defining letters G and H.\n-   Here VALUE is the CONST_DOUBLE rtx itself.\n-   For the m32r, handle a few constants inline.\n-   ??? We needn't treat DI and DF modes differently, but for now we do.  */\n-#define CONST_DOUBLE_OK_FOR_LETTER_P(VALUE, C)\t\t\t\t\\\n-  (  (C) == 'G' ? easy_di_const (VALUE)\t\t\t\t\t\\\n-   : (C) == 'H' ? easy_df_const (VALUE)\t\t\t\t\t\\\n-   : 0)\n-\n-/* A C expression that defines the optional machine-dependent constraint\n-   letters that can be used to segregate specific types of operands,\n-   usually memory references, for the target machine.  It should return 1 if\n-   VALUE corresponds to the operand type represented by the constraint letter\n-   C.  If C is not defined as an extra constraint, the value returned should\n-   be 0 regardless of VALUE.  */\n-/* Q is for symbolic addresses loadable with ld24.\n-   R is for symbolic addresses when ld24 can't be used.\n-   S is for stores with pre {inc,dec}rement\n-   T is for indirect of a pointer.\n-   U is for loads with post increment.  */\n-\n-#define EXTRA_CONSTRAINT(VALUE, C)\t\t\t\t\t\\\n-  (  (C) == 'Q' ? ((TARGET_ADDR24 && GET_CODE (VALUE) == LABEL_REF)\t\\\n-\t\t || addr24_operand (VALUE, VOIDmode))\t\t\t\\\n-   : (C) == 'R' ? ((TARGET_ADDR32 && GET_CODE (VALUE) == LABEL_REF)\t\\\n-\t\t || addr32_operand (VALUE, VOIDmode))\t\t\t\\\n-   : (C) == 'S' ? (GET_CODE (VALUE) == MEM\t\t\t\t\\\n-\t\t && STORE_PREINC_PREDEC_P (GET_MODE (VALUE),\t\t\\\n-\t\t\t\t\t   XEXP (VALUE, 0)))\t\t\\\n-   : (C) == 'T' ? (GET_CODE (VALUE) == MEM\t\t\t\t\\\n-\t\t && memreg_operand (VALUE, GET_MODE (VALUE)))\t\t\\\n-   : (C) == 'U' ? (GET_CODE (VALUE) == MEM\t\t\t\t\\\n-\t\t && LOAD_POSTINC_P (GET_MODE (VALUE),\t\t\t\\\n-\t\t\t\t    XEXP (VALUE, 0)))\t\t\t\\\n-   : 0)\n \f\n /* Stack layout and stack pointer usage.  */\n "}, {"sha": "33ef4d94d6d23a5c89c5e8c0943f95c7d3f8802e", "filename": "gcc/config/m32r/m32r.md", "status": "modified", "additions": 11, "deletions": 15, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fbaeb717be672acdb109f85765eedc647628d855/gcc%2Fconfig%2Fm32r%2Fm32r.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fbaeb717be672acdb109f85765eedc647628d855/gcc%2Fconfig%2Fm32r%2Fm32r.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm32r%2Fm32r.md?ref=fbaeb717be672acdb109f85765eedc647628d855", "patch": "@@ -200,6 +200,7 @@\n \n \f\n (include \"predicates.md\")\n+(include \"constraints.md\")\n \n ;; Expand prologue as RTL\n (define_expand \"prologue\"\n@@ -388,14 +389,13 @@\n \t    return \\\"ld %0,%1\\\";\n \n \t  case CONST_INT:\n-\t    value = INTVAL (operands[1]);\n-\t    if (INT16_P (value))\n+\t    if (satisfies_constraint_J (operands[1]))\n \t      return \\\"ldi %0,%#%1\\\\t; %X1\\\";\n \n-\t    if (UINT24_P (value))\n+\t    if (satisfies_constraint_M (operands[1]))\n \t      return \\\"ld24 %0,%#%1\\\\t; %X1\\\";\n \n-\t    if (UPPER16_P (value))\n+\t    if (satisfies_constraint_L (operands[1]))\n \t      return \\\"seth %0,%#%T1\\\\t; %X1\\\";\n \n \t    return \\\"#\\\";\n@@ -834,7 +834,7 @@\n ;\t\t (match_operand:SI 2 \"int8_operand\" \"\")))]\n ;  \"reload_completed\n ;   && REGNO (operands[0]) != REGNO (operands[1])\n-;   && INT8_P (INTVAL (operands[2]))\n+;   && satisfies_constraint_I (operands[2])\n ;   && INTVAL (operands[2]) != 0\"\n ;  [(set (match_dup 0) (match_dup 1))\n ;   (set (match_dup 0) (plus:SI (match_dup 0) (match_dup 2)))]\n@@ -1034,8 +1034,7 @@\n      short instructions, which might eliminate a NOP being inserted.  */\n   if (optimize_size\n       && m32r_not_same_reg (operands[0], operands[1])\n-      && GET_CODE (operands[2]) == CONST_INT\n-      && INT8_P (INTVAL (operands[2])))\n+      && satisfies_constraint_I (operands[2]))\n     return \\\"#\\\";\n \n   else if (GET_CODE (operands[2]) == CONST_INT)\n@@ -1066,8 +1065,7 @@\n      short instructions, which might eliminate a NOP being inserted.  */\n   if (optimize_size\n       && m32r_not_same_reg (operands[0], operands[1])\n-      && GET_CODE (operands[2]) == CONST_INT\n-      && INT8_P (INTVAL (operands[2])))\n+      && satisfies_constraint_I (operands[2]))\n     return \\\"#\\\";\n \n   else if (GET_CODE (operands[2]) == CONST_INT)\n@@ -1098,8 +1096,7 @@\n      short instructions, which might eliminate a NOP being inserted.  */\n   if (optimize_size\n       && m32r_not_same_reg (operands[0], operands[1])\n-      && GET_CODE (operands[2]) == CONST_INT\n-      && INT8_P (INTVAL (operands[2])))\n+      && satisfies_constraint_I (operands[2]))\n     return \\\"#\\\";\n \n   else if (GET_CODE (operands[2]) == CONST_INT)\n@@ -1732,8 +1729,7 @@\n       op1 = op3;\n     }\n \n-  if (GET_CODE (op2) == CONST_INT && (value = INTVAL (op2)) != 0\n-      && CMP_INT16_P (value))\n+  if (satisfies_constraint_P (op2) && (value = INTVAL (op2)) != 0)\n     emit_insn (gen_addsi3 (op3, op1, GEN_INT (-value)));\n   else\n     emit_insn (gen_xorsi3 (op3, op1, op2));\n@@ -1757,8 +1753,8 @@\n   if (mode != SImode)\n     FAIL;\n \n-  if (GET_CODE (op2) != CONST_INT\n-      || (INTVAL (op2) != 0 && UINT16_P (INTVAL (op2))))\n+   if (GET_CODE (op2) != CONST_INT\n+      || (INTVAL (op2) != 0 && satisfies_constraint_K (op2)))\n     {\n       rtx reg;\n "}, {"sha": "de161c68f5e01d80e3505f465ab28abebc7c8d5c", "filename": "gcc/config/m32r/predicates.md", "status": "modified", "additions": 12, "deletions": 13, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fbaeb717be672acdb109f85765eedc647628d855/gcc%2Fconfig%2Fm32r%2Fpredicates.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fbaeb717be672acdb109f85765eedc647628d855/gcc%2Fconfig%2Fm32r%2Fpredicates.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm32r%2Fpredicates.md?ref=fbaeb717be672acdb109f85765eedc647628d855", "patch": "@@ -1,5 +1,5 @@\n ;; Predicate definitions for Renesas M32R.\n-;; Copyright (C) 2005 Free Software Foundation, Inc.\n+;; Copyright (C) 2005, 2007 Free Software Foundation, Inc.\n ;;\n ;; This file is part of GCC.\n ;;\n@@ -51,7 +51,7 @@\n       return 1;\n \n     case CONST_INT:\n-      return INT8_P (INTVAL (op));\n+      return satisfies_constraint_I (op);\n \n     default:\n #if 0\n@@ -229,9 +229,9 @@\n {\n   if (GET_CODE (op) != CONST_INT)\n     return 0;\n-  if (INT16_P (INTVAL (op))\n-      || UINT24_P (INTVAL (op))\n-      || UPPER16_P (INTVAL (op)))\n+  if (satisfies_constraint_J (op)\n+      || satisfies_constraint_M (op)\n+      || satisfies_constraint_L (op))\n     return 0;\n   return 1;\n })\n@@ -260,7 +260,7 @@\n {\n   if (GET_CODE (op) != CONST_INT)\n     return 0;\n-  return INT8_P (INTVAL (op));\n+  return satisfies_constraint_I (op);\n })\n \n ;; Return true if OP is an unsigned 16-bit immediate value.\n@@ -270,7 +270,7 @@\n {\n   if (GET_CODE (op) != CONST_INT)\n     return 0;\n-  return UINT16_P (INTVAL (op));\n+  return satisfies_constraint_K (op);\n })\n \n ;; Return true if OP is a register or signed 16-bit value.\n@@ -282,7 +282,7 @@\n     return register_operand (op, mode);\n   if (GET_CODE (op) != CONST_INT)\n     return 0;\n-  return INT16_P (INTVAL (op));\n+  return satisfies_constraint_J (op);\n })\n \n ;; Return true if OP is a register or an unsigned 16-bit value.\n@@ -294,7 +294,7 @@\n     return register_operand (op, mode);\n   if (GET_CODE (op) != CONST_INT)\n     return 0;\n-  return UINT16_P (INTVAL (op));\n+  return satisfies_constraint_K (op);\n })\n \n ;; Return true if OP is a register or signed 16-bit value for\n@@ -307,7 +307,7 @@\n     return register_operand (op, mode);\n   if (GET_CODE (op) != CONST_INT)\n     return 0;\n-  return CMP_INT16_P (INTVAL (op));\n+  return satisfies_constraint_P (op);\n })\n \n ;; Return true if OP is a register or an integer value that can be\n@@ -338,7 +338,7 @@\n {\n   if (GET_CODE (op) != CONST_INT)\n     return 0;\n-  return CMP_INT16_P (INTVAL (op));\n+  return satisfies_constraint_P (op);\n })\n \n ;; Acceptable arguments to the call insn.\n@@ -434,8 +434,7 @@\n   if (GET_CODE (op) == CONST\n       && GET_CODE (XEXP (op, 0)) == PLUS\n       && GET_CODE (XEXP (XEXP (op, 0), 0)) == SYMBOL_REF\n-      && GET_CODE (XEXP (XEXP (op, 0), 1)) == CONST_INT\n-      && INT16_P (INTVAL (XEXP (XEXP (op, 0), 1))))\n+      && satisfies_constraint_J (XEXP (XEXP (op, 0), 1)))\n     return 1;\n \n   return 0;"}]}