{"sha": "a41a56b62d0638791b57ee160dd16fe144e2b49b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTQxYTU2YjYyZDA2Mzg3OTFiNTdlZTE2MGRkMTZmZTE0NGUyYjQ5Yg==", "commit": {"author": {"name": "Richard Earnshaw", "email": "rearnsha@arm.com", "date": "2006-11-14T23:25:43Z"}, "committer": {"name": "Richard Earnshaw", "email": "rearnsha@gcc.gnu.org", "date": "2006-11-14T23:25:43Z"}, "message": "expmed.c (emit_store_flag_1): New function.\n\n\t* expmed.c (emit_store_flag_1): New function.\n\t(emit_store_flag): Call it.  If we can't find a suitable scc insn,\n\ttry a cstore insn.\n\t* expr.c (do_store_flag): If we can't find a scc insn, try cstore.\n\tUse do_compare_rtx_and_jump.\n\t* arm.h (BRANCH_COST): Increase to 2 on Thumb.\n\t* arm.md (cstoresi4): New define_expand.\n\t(cstoresi_eq0_thumb, cstoresi_ne0_thumb): Likewise.\n\t(cstoresi_eq0_thumb_insn, cstore_ne0_thumb_insn): New patterns.\n\t(cstoresi_nltu_thumb, thumb_addsi3_addgeu): New patterns.\n\nFrom-SVN: r118829", "tree": {"sha": "07b49d656bca875286894404e9122b058e2a2a0e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/07b49d656bca875286894404e9122b058e2a2a0e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a41a56b62d0638791b57ee160dd16fe144e2b49b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a41a56b62d0638791b57ee160dd16fe144e2b49b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a41a56b62d0638791b57ee160dd16fe144e2b49b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a41a56b62d0638791b57ee160dd16fe144e2b49b/comments", "author": null, "committer": null, "parents": [{"sha": "75dc0b383db8e50ab0c11ac25b09f3538106a3f0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/75dc0b383db8e50ab0c11ac25b09f3538106a3f0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/75dc0b383db8e50ab0c11ac25b09f3538106a3f0"}], "stats": {"total": 432, "additions": 350, "deletions": 82}, "files": [{"sha": "81f343422347fbdc3cb2229638d40626a3f02749", "filename": "gcc/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a41a56b62d0638791b57ee160dd16fe144e2b49b/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a41a56b62d0638791b57ee160dd16fe144e2b49b/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=a41a56b62d0638791b57ee160dd16fe144e2b49b", "patch": "@@ -1,3 +1,16 @@\n+2006-11-14  Richard Earnshaw  <rearnsha@arm.com>\n+\n+\t* expmed.c (emit_store_flag_1): New function.\n+\t(emit_store_flag): Call it.  If we can't find a suitable scc insn,\n+\ttry a cstore insn.\n+\t* expr.c (do_store_flag): If we can't find a scc insn, try cstore.\n+\tUse do_compare_rtx_and_jump.\n+\t* arm.h (BRANCH_COST): Increase to 2 on Thumb.\n+\t* arm.md (cstoresi4): New define_expand.\n+\t(cstoresi_eq0_thumb, cstoresi_ne0_thumb): Likewise.\n+\t(cstoresi_eq0_thumb_insn, cstore_ne0_thumb_insn): New patterns.\n+\t(cstoresi_nltu_thumb, thumb_addsi3_addgeu): New patterns.\n+\n 2006-11-14  Caroline Tice  <ctice@apple.com>\n \t\t\n \t* dwarf2out.c (debug_pubtypes_section): New static global variable."}, {"sha": "5570924bade3f32c10e09851c8840d5458193a68", "filename": "gcc/config/arm/arm.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a41a56b62d0638791b57ee160dd16fe144e2b49b/gcc%2Fconfig%2Farm%2Farm.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a41a56b62d0638791b57ee160dd16fe144e2b49b/gcc%2Fconfig%2Farm%2Farm.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.h?ref=a41a56b62d0638791b57ee160dd16fe144e2b49b", "patch": "@@ -2091,7 +2091,7 @@ do {\t\t\t\t\t\t\t\\\n /* Try to generate sequences that don't involve branches, we can then use\n    conditional instructions */\n #define BRANCH_COST \\\n-  (TARGET_ARM ? 4 : (optimize > 1 ? 1 : 0))\n+  (TARGET_ARM ? 4 : (optimize > 0 ? 2 : 0))\n \f\n /* Position Independent Code.  */\n /* We decide which register to use based on the compilation options and"}, {"sha": "b2e3c7ee997288f68ee7a8220adafd909f7d4020", "filename": "gcc/config/arm/arm.md", "status": "modified", "additions": 192, "deletions": 0, "changes": 192, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a41a56b62d0638791b57ee160dd16fe144e2b49b/gcc%2Fconfig%2Farm%2Farm.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a41a56b62d0638791b57ee160dd16fe144e2b49b/gcc%2Fconfig%2Farm%2Farm.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.md?ref=a41a56b62d0638791b57ee160dd16fe144e2b49b", "patch": "@@ -7460,6 +7460,198 @@\n    (set_attr \"length\" \"8\")]\n )\n \n+(define_expand \"cstoresi4\"\n+  [(set (match_operand:SI 0 \"s_register_operand\" \"\")\n+\t(match_operator:SI 1 \"arm_comparison_operator\"\n+\t [(match_operand:SI 2 \"s_register_operand\" \"\")\n+\t  (match_operand:SI 3 \"reg_or_int_operand\" \"\")]))]\n+  \"TARGET_THUMB\"\n+  \"{\n+  rtx op3, scratch, scratch2;\n+\n+  if (operands[3] == const0_rtx)\n+    {\n+      switch (GET_CODE (operands[1]))\n+\t{\n+\tcase EQ:\n+\t  emit_insn (gen_cstoresi_eq0_thumb (operands[0], operands[2]));\n+\t  break;\n+\n+\tcase NE:\n+\t  emit_insn (gen_cstoresi_ne0_thumb (operands[0], operands[2]));\n+\t  break;\n+\n+\tcase LE:\n+          scratch = expand_binop (SImode, add_optab, operands[2], constm1_rtx,\n+\t\t\t\t  NULL_RTX, 0, OPTAB_WIDEN);\n+          scratch = expand_binop (SImode, ior_optab, operands[2], scratch,\n+\t\t\t\t  NULL_RTX, 0, OPTAB_WIDEN);\n+          expand_binop (SImode, lshr_optab, scratch, GEN_INT (31),\n+\t\t\toperands[0], 1, OPTAB_WIDEN);\n+\t  break;\n+\n+        case GE:\n+          scratch = expand_unop (SImode, one_cmpl_optab, operands[2],\n+\t\t\t\t NULL_RTX, 1);\n+          expand_binop (SImode, lshr_optab, scratch, GEN_INT (31),\n+\t\t\tNULL_RTX, 1, OPTAB_WIDEN);\n+          break;\n+\n+        case GT:\n+          scratch = expand_binop (SImode, ashr_optab, operands[2],\n+\t\t\t\t  GEN_INT (31), NULL_RTX, 0, OPTAB_WIDEN);\n+          scratch = expand_binop (SImode, sub_optab, scratch, operands[2],\n+\t\t\t\t  NULL_RTX, 0, OPTAB_WIDEN);\n+          expand_binop (SImode, lshr_optab, scratch, GEN_INT (31), operands[0],\n+\t\t\t0, OPTAB_WIDEN);\n+          break;\n+\n+\t/* LT is handled by generic code.  No need for unsigned with 0.  */\n+\tdefault:\n+\t  FAIL;\n+\t}\n+      DONE;\n+    }\n+\n+  switch (GET_CODE (operands[1]))\n+    {\n+    case EQ:\n+      scratch = expand_binop (SImode, sub_optab, operands[2], operands[3],\n+\t\t\t      NULL_RTX, 0, OPTAB_WIDEN);\n+      emit_insn (gen_cstoresi_eq0_thumb (operands[0], scratch));\n+      break;\n+\n+    case NE:\n+      scratch = expand_binop (SImode, sub_optab, operands[2], operands[3],\n+\t\t\t      NULL_RTX, 0, OPTAB_WIDEN);\n+      emit_insn (gen_cstoresi_ne0_thumb (operands[0], scratch));\n+      break;\n+\n+    case LE:\n+      op3 = force_reg (SImode, operands[3]);\n+\n+      scratch = expand_binop (SImode, lshr_optab, operands[2], GEN_INT (31),\n+\t\t\t      NULL_RTX, 1, OPTAB_WIDEN);\n+      scratch2 = expand_binop (SImode, ashr_optab, op3, GEN_INT (31),\n+\t\t\t      NULL_RTX, 0, OPTAB_WIDEN);\n+      emit_insn (gen_thumb_addsi3_addgeu (operands[0], scratch, scratch2,\n+\t\t\t\t\t  op3, operands[2]));\n+      break;\n+\n+    case GE:\n+      op3 = operands[3];\n+      if (!thumb_cmp_operand (op3, SImode))\n+        op3 = force_reg (SImode, op3);\n+      scratch = expand_binop (SImode, ashr_optab, operands[2], GEN_INT (31),\n+\t\t\t      NULL_RTX, 0, OPTAB_WIDEN);\n+      scratch2 = expand_binop (SImode, lshr_optab, op3, GEN_INT (31),\n+\t\t\t       NULL_RTX, 1, OPTAB_WIDEN);\n+      emit_insn (gen_thumb_addsi3_addgeu (operands[0], scratch, scratch2,\n+\t\t\t\t\t  operands[2], op3));\n+      break;\n+\n+    case LEU:\n+      op3 = force_reg (SImode, operands[3]);\n+      scratch = force_reg (SImode, const0_rtx);\n+      emit_insn (gen_thumb_addsi3_addgeu (operands[0], scratch, scratch,\n+\t\t\t\t\t  op3, operands[2]));\n+      break;\n+\n+    case GEU:\n+      op3 = operands[3];\n+      if (!thumb_cmp_operand (op3, SImode))\n+        op3 = force_reg (SImode, op3);\n+      scratch = force_reg (SImode, const0_rtx);\n+      emit_insn (gen_thumb_addsi3_addgeu (operands[0], scratch, scratch,\n+\t\t\t\t\t  operands[2], op3));\n+      break;\n+\n+    case LTU:\n+      op3 = operands[3];\n+      if (!thumb_cmp_operand (op3, SImode))\n+        op3 = force_reg (SImode, op3);\n+      scratch = gen_reg_rtx (SImode);\n+      emit_insn (gen_cstoresi_nltu_thumb (scratch, operands[2], op3));\n+      emit_insn (gen_negsi2 (operands[0], scratch));\n+      break;\n+\n+    case GTU:\n+      op3 = force_reg (SImode, operands[3]);\n+      scratch = gen_reg_rtx (SImode);\n+      emit_insn (gen_cstoresi_nltu_thumb (scratch, op3, operands[2]));\n+      emit_insn (gen_negsi2 (operands[0], scratch));\n+      break;\n+\n+    /* No good sequences for GT, LT.  */\n+    default:\n+      FAIL;\n+    }\n+  DONE;\n+}\")\n+\n+(define_expand \"cstoresi_eq0_thumb\"\n+  [(parallel\n+    [(set (match_operand:SI 0 \"s_register_operand\" \"\")\n+\t  (eq:SI (match_operand:SI 1 \"s_register_operand\" \"\")\n+\t\t (const_int 0)))\n+     (clobber (match_dup:SI 2))])]\n+  \"TARGET_THUMB\"\n+  \"operands[2] = gen_reg_rtx (SImode);\"\n+)\n+\n+(define_expand \"cstoresi_ne0_thumb\"\n+  [(parallel\n+    [(set (match_operand:SI 0 \"s_register_operand\" \"\")\n+\t  (ne:SI (match_operand:SI 1 \"s_register_operand\" \"\")\n+\t\t (const_int 0)))\n+     (clobber (match_dup:SI 2))])]\n+  \"TARGET_THUMB\"\n+  \"operands[2] = gen_reg_rtx (SImode);\"\n+)\n+\n+(define_insn \"*cstoresi_eq0_thumb_insn\"\n+  [(set (match_operand:SI 0 \"s_register_operand\" \"=&l,l\")\n+\t(eq:SI (match_operand:SI 1 \"s_register_operand\" \"l,0\")\n+\t       (const_int 0)))\n+   (clobber (match_operand:SI 2 \"s_register_operand\" \"=X,l\"))]\n+  \"TARGET_THUMB\"\n+  \"@\n+   neg\\\\t%0, %1\\;adc\\\\t%0, %0, %1\n+   neg\\\\t%2, %1\\;adc\\\\t%0, %1, %2\"\n+  [(set_attr \"length\" \"4\")]\n+)\n+\n+(define_insn \"*cstoresi_ne0_thumb_insn\"\n+  [(set (match_operand:SI 0 \"s_register_operand\" \"=l\")\n+\t(ne:SI (match_operand:SI 1 \"s_register_operand\" \"0\")\n+\t       (const_int 0)))\n+   (clobber (match_operand:SI 2 \"s_register_operand\" \"=l\"))]\n+  \"TARGET_THUMB\"\n+  \"sub\\\\t%2, %1, #1\\;sbc\\\\t%0, %1, %2\"\n+  [(set_attr \"length\" \"4\")]\n+)\n+\n+(define_insn \"cstoresi_nltu_thumb\"\n+  [(set (match_operand:SI 0 \"s_register_operand\" \"=l,l\")\n+        (neg:SI (gtu:SI (match_operand:SI 1 \"s_register_operand\" \"l,*h\")\n+\t\t\t(match_operand:SI 2 \"thumb_cmp_operand\" \"lI*h,*r\"))))]\n+  \"TARGET_THUMB\"\n+  \"cmp\\\\t%1, %2\\;sbc\\\\t%0, %0, %0\"\n+  [(set_attr \"length\" \"4\")]\n+)\n+\n+;; Used as part of the expansion of thumb les sequence.\n+(define_insn \"thumb_addsi3_addgeu\"\n+  [(set (match_operand:SI 0 \"s_register_operand\" \"=l\")\n+        (plus:SI (plus:SI (match_operand:SI 1 \"s_register_operand\" \"%0\")\n+\t\t\t  (match_operand:SI 2 \"s_register_operand\" \"l\"))\n+\t\t (geu:SI (match_operand:SI 3 \"s_register_operand\" \"l\")\n+\t\t\t (match_operand:SI 4 \"thumb_cmp_operand\" \"lI\"))))]\n+  \"TARGET_THUMB\"\n+  \"cmp\\\\t%3, %4\\;adc\\\\t%0, %1, %2\"\n+  [(set_attr \"length\" \"4\")]\n+)\n+\n \f\n ;; Conditional move insns\n "}, {"sha": "4008c08d2230a2dc44cc00398d5f6feef8eb5bdb", "filename": "gcc/expmed.c", "status": "modified", "additions": 130, "deletions": 63, "changes": 193, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a41a56b62d0638791b57ee160dd16fe144e2b49b/gcc%2Fexpmed.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a41a56b62d0638791b57ee160dd16fe144e2b49b/gcc%2Fexpmed.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpmed.c?ref=a41a56b62d0638791b57ee160dd16fe144e2b49b", "patch": "@@ -5091,6 +5091,77 @@ expand_and (enum machine_mode mode, rtx op0, rtx op1, rtx target)\n   return target;\n }\n \f\n+/* Helper function for emit_store_flag.  */\n+static rtx\n+emit_store_flag_1 (rtx target, rtx subtarget, enum machine_mode mode,\n+\t\t   int normalizep)\n+{\n+  rtx op0;\n+  enum machine_mode target_mode = GET_MODE (target);\n+  \n+  /* If we are converting to a wider mode, first convert to\n+     TARGET_MODE, then normalize.  This produces better combining\n+     opportunities on machines that have a SIGN_EXTRACT when we are\n+     testing a single bit.  This mostly benefits the 68k.\n+\n+     If STORE_FLAG_VALUE does not have the sign bit set when\n+     interpreted in MODE, we can do this conversion as unsigned, which\n+     is usually more efficient.  */\n+  if (GET_MODE_SIZE (target_mode) > GET_MODE_SIZE (mode))\n+    {\n+      convert_move (target, subtarget,\n+\t\t    (GET_MODE_BITSIZE (mode) <= HOST_BITS_PER_WIDE_INT)\n+\t\t    && 0 == (STORE_FLAG_VALUE\n+\t\t\t     & ((HOST_WIDE_INT) 1\n+\t\t\t\t<< (GET_MODE_BITSIZE (mode) -1))));\n+      op0 = target;\n+      mode = target_mode;\n+    }\n+  else\n+    op0 = subtarget;\n+\n+  /* If we want to keep subexpressions around, don't reuse our last\n+     target.  */\n+  if (optimize)\n+    subtarget = 0;\n+\n+  /* Now normalize to the proper value in MODE.  Sometimes we don't\n+     have to do anything.  */\n+  if (normalizep == 0 || normalizep == STORE_FLAG_VALUE)\n+    ;\n+  /* STORE_FLAG_VALUE might be the most negative number, so write\n+     the comparison this way to avoid a compiler-time warning.  */\n+  else if (- normalizep == STORE_FLAG_VALUE)\n+    op0 = expand_unop (mode, neg_optab, op0, subtarget, 0);\n+\n+  /* We don't want to use STORE_FLAG_VALUE < 0 below since this makes\n+     it hard to use a value of just the sign bit due to ANSI integer\n+     constant typing rules.  */\n+  else if (GET_MODE_BITSIZE (mode) <= HOST_BITS_PER_WIDE_INT\n+\t   && (STORE_FLAG_VALUE\n+\t       & ((HOST_WIDE_INT) 1 << (GET_MODE_BITSIZE (mode) - 1))))\n+    op0 = expand_shift (RSHIFT_EXPR, mode, op0,\n+\t\t\tsize_int (GET_MODE_BITSIZE (mode) - 1), subtarget,\n+\t\t\tnormalizep == 1);\n+  else\n+    {\n+      gcc_assert (STORE_FLAG_VALUE & 1);\n+\n+      op0 = expand_and (mode, op0, const1_rtx, subtarget);\n+      if (normalizep == -1)\n+\top0 = expand_unop (mode, neg_optab, op0, op0, 0);\n+    }\n+\n+  /* If we were converting to a smaller mode, do the conversion now.  */\n+  if (target_mode != mode)\n+    {\n+      convert_move (target, op0, 0);\n+      return target;\n+    }\n+  else\n+    return op0;\n+}\n+\n /* Emit a store-flags instruction for comparison CODE on OP0 and OP1\n    and storing in TARGET.  Normally return TARGET.\n    Return 0 if that cannot be done.\n@@ -5180,12 +5251,14 @@ emit_store_flag (rtx target, enum rtx_code code, rtx op0, rtx op1,\n \t{\n \t  rtx op00, op01, op0both;\n \n-\t  /* Do a logical OR or AND of the two words and compare the result.  */\n+\t  /* Do a logical OR or AND of the two words and compare the\n+\t     result.  */\n \t  op00 = simplify_gen_subreg (word_mode, op0, mode, 0);\n \t  op01 = simplify_gen_subreg (word_mode, op0, mode, UNITS_PER_WORD);\n \t  op0both = expand_binop (word_mode,\n \t\t\t\t  op1 == const0_rtx ? ior_optab : and_optab,\n-\t\t\t\t  op00, op01, NULL_RTX, unsignedp, OPTAB_DIRECT);\n+\t\t\t\t  op00, op01, NULL_RTX, unsignedp,\n+\t\t\t\t  OPTAB_DIRECT);\n \n \t  if (op0both != 0)\n \t    return emit_store_flag (target, code, op0both, op1, word_mode,\n@@ -5197,23 +5270,22 @@ emit_store_flag (rtx target, enum rtx_code code, rtx op0, rtx op1,\n \n \t  /* If testing the sign bit, can just test on high word.  */\n \t  op0h = simplify_gen_subreg (word_mode, op0, mode,\n-\t\t\t\t      subreg_highpart_offset (word_mode, mode));\n+\t\t\t\t      subreg_highpart_offset (word_mode,\n+\t\t\t\t\t\t\t      mode));\n \t  return emit_store_flag (target, code, op0h, op1, word_mode,\n \t\t\t\t  unsignedp, normalizep);\n \t}\n     }\n \n-  /* From now on, we won't change CODE, so set ICODE now.  */\n-  icode = setcc_gen_code[(int) code];\n-\n   /* If this is A < 0 or A >= 0, we can do this by taking the ones\n      complement of A (for GE) and shifting the sign bit to the low bit.  */\n   if (op1 == const0_rtx && (code == LT || code == GE)\n       && GET_MODE_CLASS (mode) == MODE_INT\n       && (normalizep || STORE_FLAG_VALUE == 1\n \t  || (GET_MODE_BITSIZE (mode) <= HOST_BITS_PER_WIDE_INT\n \t      && ((STORE_FLAG_VALUE & GET_MODE_MASK (mode))\n-\t\t  == (unsigned HOST_WIDE_INT) 1 << (GET_MODE_BITSIZE (mode) - 1)))))\n+\t\t  == ((unsigned HOST_WIDE_INT) 1\n+\t\t      << (GET_MODE_BITSIZE (mode) - 1))))))\n     {\n       subtarget = target;\n \n@@ -5248,6 +5320,8 @@ emit_store_flag (rtx target, enum rtx_code code, rtx op0, rtx op1,\n       return op0;\n     }\n \n+  icode = setcc_gen_code[(int) code];\n+\n   if (icode != CODE_FOR_nothing)\n     {\n       insn_operand_predicate_fn pred;\n@@ -5305,72 +5379,65 @@ emit_store_flag (rtx target, enum rtx_code code, rtx op0, rtx op1,\n       if (pattern)\n \t{\n \t  emit_insn (pattern);\n+\t  return emit_store_flag_1 (target, subtarget, compare_mode,\n+\t\t\t\t    normalizep);\n+\t}\n+    }\n+  else\n+    {\n+      /* We don't have an scc insn, so try a cstore insn.  */\n+\n+      for (compare_mode = mode; compare_mode != VOIDmode;\n+\t   compare_mode = GET_MODE_WIDER_MODE (compare_mode))\n+\t{\n+\t  icode = cstore_optab->handlers[(int) compare_mode].insn_code;\n+\t  if (icode != CODE_FOR_nothing)\n+\t    break;\n+\t}\n+\n+      if (icode != CODE_FOR_nothing)\n+\t{\n+\t  enum machine_mode result_mode\n+\t    = insn_data[(int) icode].operand[0].mode;\n+\t  rtx cstore_op0 = op0;\n+\t  rtx cstore_op1 = op1;\n \n-\t  /* If we are converting to a wider mode, first convert to\n-\t     TARGET_MODE, then normalize.  This produces better combining\n-\t     opportunities on machines that have a SIGN_EXTRACT when we are\n-\t     testing a single bit.  This mostly benefits the 68k.\n+\t  do_pending_stack_adjust ();\n+\t  last = get_last_insn ();\n \n-\t     If STORE_FLAG_VALUE does not have the sign bit set when\n-\t     interpreted in COMPARE_MODE, we can do this conversion as\n-\t     unsigned, which is usually more efficient.  */\n-\t  if (GET_MODE_SIZE (target_mode) > GET_MODE_SIZE (compare_mode))\n+\t  if (compare_mode != mode)\n \t    {\n-\t      convert_move (target, subtarget,\n-\t\t\t    (GET_MODE_BITSIZE (compare_mode)\n-\t\t\t     <= HOST_BITS_PER_WIDE_INT)\n-\t\t\t    && 0 == (STORE_FLAG_VALUE\n-\t\t\t\t     & ((HOST_WIDE_INT) 1\n-\t\t\t\t\t<< (GET_MODE_BITSIZE (compare_mode) -1))));\n-\t      op0 = target;\n-\t      compare_mode = target_mode;\n+\t      cstore_op0 = convert_modes (compare_mode, mode, cstore_op0,\n+\t\t\t\t\t  unsignedp);\n+\t      cstore_op1 = convert_modes (compare_mode, mode, cstore_op1,\n+\t\t\t\t\t  unsignedp);\n \t    }\n-\t  else\n-\t    op0 = subtarget;\n+\t  \n+\t  if (!insn_data[(int) icode].operand[2].predicate (cstore_op0,\n+\t\t\t\t\t\t\t    compare_mode))\n+\t    cstore_op0 = copy_to_mode_reg (compare_mode, cstore_op0);\n \n-\t  /* If we want to keep subexpressions around, don't reuse our\n-\t     last target.  */\n+\t  if (!insn_data[(int) icode].operand[3].predicate (cstore_op1,\n+\t\t\t\t\t\t\t    compare_mode))\n+\t    cstore_op1 = copy_to_mode_reg (compare_mode, cstore_op1);\n \n-\t  if (optimize)\n-\t    subtarget = 0;\n+\t  comparison = gen_rtx_fmt_ee (code, result_mode, cstore_op0,\n+\t\t\t\t       cstore_op1);\n+\t  subtarget = target;\n \n-\t  /* Now normalize to the proper value in COMPARE_MODE.  Sometimes\n-\t     we don't have to do anything.  */\n-\t  if (normalizep == 0 || normalizep == STORE_FLAG_VALUE)\n-\t    ;\n-\t  /* STORE_FLAG_VALUE might be the most negative number, so write\n-\t     the comparison this way to avoid a compiler-time warning.  */\n-\t  else if (- normalizep == STORE_FLAG_VALUE)\n-\t    op0 = expand_unop (compare_mode, neg_optab, op0, subtarget, 0);\n-\n-\t  /* We don't want to use STORE_FLAG_VALUE < 0 below since this\n-\t     makes it hard to use a value of just the sign bit due to\n-\t     ANSI integer constant typing rules.  */\n-\t  else if (GET_MODE_BITSIZE (compare_mode) <= HOST_BITS_PER_WIDE_INT\n-\t\t   && (STORE_FLAG_VALUE\n-\t\t       & ((HOST_WIDE_INT) 1\n-\t\t\t  << (GET_MODE_BITSIZE (compare_mode) - 1))))\n-\t    op0 = expand_shift (RSHIFT_EXPR, compare_mode, op0,\n-\t\t\t\tsize_int (GET_MODE_BITSIZE (compare_mode) - 1),\n-\t\t\t\tsubtarget, normalizep == 1);\n-\t  else\n-\t    {\n-\t      gcc_assert (STORE_FLAG_VALUE & 1);\n-\t      \n-\t      op0 = expand_and (compare_mode, op0, const1_rtx, subtarget);\n-\t      if (normalizep == -1)\n-\t\top0 = expand_unop (compare_mode, neg_optab, op0, op0, 0);\n-\t    }\n+\t  if (optimize || !(insn_data[(int) icode].operand[0].predicate\n+\t\t\t    (subtarget, result_mode)))\n+\t    subtarget = gen_reg_rtx (result_mode);\n \n-\t  /* If we were converting to a smaller mode, do the\n-\t     conversion now.  */\n-\t  if (target_mode != compare_mode)\n+\t  pattern = GEN_FCN (icode) (subtarget, comparison, cstore_op0,\n+\t\t\t\t     cstore_op1);\n+\n+\t  if (pattern)\n \t    {\n-\t      convert_move (target, op0, 0);\n-\t      return target;\n+\t      emit_insn (pattern);\n+\t      return emit_store_flag_1 (target, subtarget, result_mode,\n+\t\t\t\t\tnormalizep);\n \t    }\n-\t  else\n-\t    return op0;\n \t}\n     }\n "}, {"sha": "74627882a915b9140763698d42f6895f95b16300", "filename": "gcc/expr.c", "status": "modified", "additions": 14, "deletions": 18, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a41a56b62d0638791b57ee160dd16fe144e2b49b/gcc%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a41a56b62d0638791b57ee160dd16fe144e2b49b/gcc%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.c?ref=a41a56b62d0638791b57ee160dd16fe144e2b49b", "patch": "@@ -9155,6 +9155,17 @@ do_store_flag (tree exp, rtx target, enum machine_mode mode, int only_cheap)\n     return 0;\n \n   icode = setcc_gen_code[(int) code];\n+\n+  if (icode == CODE_FOR_nothing)\n+    {\n+      enum machine_mode wmode;\n+      \n+      for (wmode = operand_mode;\n+\t   icode == CODE_FOR_nothing && wmode != VOIDmode;\n+\t   wmode = GET_MODE_WIDER_MODE (wmode))\n+\ticode = cstore_optab->handlers[(int) wmode].insn_code;\n+    }\n+\n   if (icode == CODE_FOR_nothing\n       || (only_cheap && insn_data[(int) icode].operand[0].mode != mode))\n     {\n@@ -9200,25 +9211,10 @@ do_store_flag (tree exp, rtx target, enum machine_mode mode, int only_cheap)\n     target = gen_reg_rtx (GET_MODE (target));\n \n   emit_move_insn (target, invert ? const0_rtx : const1_rtx);\n-  result = compare_from_rtx (op0, op1, code, unsignedp,\n-\t\t\t     operand_mode, NULL_RTX);\n-  if (GET_CODE (result) == CONST_INT)\n-    return (((result == const0_rtx && ! invert)\n-\t     || (result != const0_rtx && invert))\n-\t    ? const0_rtx : const1_rtx);\n-\n-  /* The code of RESULT may not match CODE if compare_from_rtx\n-     decided to swap its operands and reverse the original code.\n-\n-     We know that compare_from_rtx returns either a CONST_INT or\n-     a new comparison code, so it is safe to just extract the\n-     code from RESULT.  */\n-  code = GET_CODE (result);\n-\n   label = gen_label_rtx ();\n-  gcc_assert (bcc_gen_fctn[(int) code]);\n-\n-  emit_jump_insn ((*bcc_gen_fctn[(int) code]) (label));\n+  do_compare_rtx_and_jump (op0, op1, code, unsignedp, operand_mode, NULL_RTX,\n+\t\t\t   NULL_RTX, label);\n+  \n   emit_move_insn (target, invert ? const1_rtx : const0_rtx);\n   emit_label (label);\n "}]}