{"sha": "7802a8ec9a03e6ced5b5d8f9018c6b9f45677c3f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzgwMmE4ZWM5YTAzZTZjZWQ1YjVkOGY5MDE4YzZiOWY0NTY3N2MzZg==", "commit": {"author": {"name": "Martin Sebor", "email": "msebor@redhat.com", "date": "2019-06-12T16:33:04Z"}, "committer": {"name": "Martin Sebor", "email": "msebor@gcc.gnu.org", "date": "2019-06-12T16:33:04Z"}, "message": "PR tree-optimization/90662 - strlen of a string in a vla plus offset not folded\n\ngcc/ChangeLog:\n\n\tPR tree-optimization/90662\n\t* tree-ssa-strlen.c (get_stridx): Handle simple VLAs and pointers\n\tto arrays.\n\ngcc/testsuite/ChangeLog:\n\n\tPR tree-optimization/90662\n\t* gcc.dg/strlenopt-62.c: New test.\n\t* gcc.dg/strlenopt-63.c: New test.\n\t* gcc.dg/strlenopt-64.c: New test.\n\nFrom-SVN: r272197", "tree": {"sha": "38646c19e96f5ea0cbd1edfaeeec89e7c2000611", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/38646c19e96f5ea0cbd1edfaeeec89e7c2000611"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/7802a8ec9a03e6ced5b5d8f9018c6b9f45677c3f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7802a8ec9a03e6ced5b5d8f9018c6b9f45677c3f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7802a8ec9a03e6ced5b5d8f9018c6b9f45677c3f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7802a8ec9a03e6ced5b5d8f9018c6b9f45677c3f/comments", "author": {"login": "msebor", "id": 381149, "node_id": "MDQ6VXNlcjM4MTE0OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/381149?v=4", "gravatar_id": "", "url": "https://api.github.com/users/msebor", "html_url": "https://github.com/msebor", "followers_url": "https://api.github.com/users/msebor/followers", "following_url": "https://api.github.com/users/msebor/following{/other_user}", "gists_url": "https://api.github.com/users/msebor/gists{/gist_id}", "starred_url": "https://api.github.com/users/msebor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/msebor/subscriptions", "organizations_url": "https://api.github.com/users/msebor/orgs", "repos_url": "https://api.github.com/users/msebor/repos", "events_url": "https://api.github.com/users/msebor/events{/privacy}", "received_events_url": "https://api.github.com/users/msebor/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "4b557bcc0d0674011a45ad259f44b9830289bd1f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4b557bcc0d0674011a45ad259f44b9830289bd1f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4b557bcc0d0674011a45ad259f44b9830289bd1f"}], "stats": {"total": 619, "additions": 602, "deletions": 17}, "files": [{"sha": "d05e60f0fd3cdd14fc58f8772391d6ee66103b5b", "filename": "gcc/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7802a8ec9a03e6ced5b5d8f9018c6b9f45677c3f/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7802a8ec9a03e6ced5b5d8f9018c6b9f45677c3f/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=7802a8ec9a03e6ced5b5d8f9018c6b9f45677c3f", "patch": "@@ -1,3 +1,9 @@\n+2019-06-12  Martin Sebor  <msebor@redhat.com>\n+\n+\tPR tree-optimization/90662\n+\t* tree-ssa-strlen.c (get_stridx): Handle simple VLAs and pointers\n+\tto arrays.\n+\n 2019-06-12  Tom de Vries  <tdevries@suse.de>\n \n \tPR tree-optimization/90009"}, {"sha": "dfdf3f3678ad4839224ecb96607a2ac2712e561b", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7802a8ec9a03e6ced5b5d8f9018c6b9f45677c3f/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7802a8ec9a03e6ced5b5d8f9018c6b9f45677c3f/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=7802a8ec9a03e6ced5b5d8f9018c6b9f45677c3f", "patch": "@@ -1,3 +1,10 @@\n+2019-06-12  Martin Sebor  <msebor@redhat.com>\n+\n+\tPR tree-optimization/90662\n+\t* gcc.dg/strlenopt-62.c: New test.\n+\t* gcc.dg/strlenopt-63.c: New test.\n+\t* gcc.dg/strlenopt-64.c: New test.\n+\n 2019-06-12  Przemyslaw Wirkus  <przemyslaw.wirkus@arm.com>\n \n         * gcc.target/arm/ssadv16qi.c: New test."}, {"sha": "0e09a7ab0e178c867cee7071c79a6c898ab64851", "filename": "gcc/testsuite/gcc.dg/strlenopt-62.c", "status": "added", "additions": 189, "deletions": 0, "changes": 189, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7802a8ec9a03e6ced5b5d8f9018c6b9f45677c3f/gcc%2Ftestsuite%2Fgcc.dg%2Fstrlenopt-62.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7802a8ec9a03e6ced5b5d8f9018c6b9f45677c3f/gcc%2Ftestsuite%2Fgcc.dg%2Fstrlenopt-62.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fstrlenopt-62.c?ref=7802a8ec9a03e6ced5b5d8f9018c6b9f45677c3f", "patch": "@@ -0,0 +1,189 @@\n+/* PR tree-optimization/90662 - strlen of a string in a vla plus offset\n+   not folded\n+   { dg-do compile }\n+   { dg-options \"-O2 -Wall -fdump-tree-gimple -fdump-tree-optimized\" } */\n+\n+#include \"strlenopt.h\"\n+\n+typedef __INT16_TYPE__   int16_t;\n+typedef __INT32_TYPE__   int32_t;\n+\n+#define CONCAT(x, y) x ## y\n+#define CAT(x, y) CONCAT (x, y)\n+#define FAILNAME(name, counter) \\\n+  CAT (CAT (CAT (call_ ## name ##_on_line_, __LINE__), _), counter)\n+\n+#define FAIL(name, counter) do {\t\t\t\\\n+    extern void FAILNAME (name, counter) (void);\t\\\n+    FAILNAME (name, counter)();\t\t\t\t\\\n+  } while (0)\n+\n+/* Macro to emit a call to funcation named\n+     call_in_true_branch_not_eliminated_on_line_NNN()\n+   for each call that's expected to be eliminated.  The dg-final\n+   scan-tree-dump-time directive at the bottom of the test verifies\n+   that no such call appears in output.  */\n+#define ELIM(expr) \\\n+  if (!(expr)) FAIL (in_true_branch_not_eliminated, __COUNTER__); else (void)0\n+\n+#define ARGS(...) __VA_ARGS__\n+\n+void sink (void*, ...);\n+\n+\n+#define T(Type, expect, init, p)\t\t\t\\\n+  do {\t\t\t\t\t\t\t\\\n+    Type vla[n];\t\t\t\t\t\\\n+    char *ptr = strcpy ((char*)vla, init);\t\t\\\n+    ELIM (expect == strlen (p));\t\t\t\\\n+    sink (ptr);\t\t\t\t\t\t\\\n+  } while (0)\n+\n+void test_char_vla_local (int n)\n+{\n+  T (char, 0, \"\", vla);\n+  T (char, 0, \"\\0\", vla);\n+  T (char, 1, \"1\", vla);\n+  T (char, 2, \"12\", vla);\n+  T (char, 3, \"123\", vla);\n+\n+  T (char, 2, \"123\", vla + 1);\n+  T (char, 1, \"123\", &vla[2]);\n+  T (char, 0, \"123\", &vla[1] + 2);\n+\n+  T (char, 2, \"123\", &vla[2] - 1);\n+  T (char, 3, \"123\", &vla[1] - 1);\n+\n+  T (char, 0, \"\", ptr);\n+  T (char, 0, \"\\0\", ptr);\n+  T (char, 1, \"1\", ptr);\n+  T (char, 2, \"12\", ptr);\n+  T (char, 3, \"123\", ptr);\n+\n+  T (char, 2, \"123\", ptr + 1);\n+  T (char, 1, \"123\", &ptr[2]);\n+  T (char, 0, \"123\", &ptr[1] + 2);\n+}\n+\n+void test_int16_vla_local (int n)\n+{\n+  T (int16_t, 0, \"\", (char*)vla);\n+  T (int16_t, 0, \"\\0\", (char*)vla);\n+  T (int16_t, 1, \"1\", (char*)vla);\n+  T (int16_t, 2, \"12\", (char*)vla);\n+  T (int16_t, 3, \"123\", (char*)vla);\n+\n+  T (int16_t, 2, \"1234\", (char*)(vla + 1));\n+  T (int16_t, 2, \"123456\", (char*)&vla[2]);\n+  T (int16_t, 1, \"123456\", (char*)&vla[2] + 1);\n+  T (int16_t, 0, \"123456\", (char*)&vla[2] + 2);\n+  T (int16_t, 0, \"123456\", (char*)(&vla[1] + 2));\n+\n+  T (int16_t, 3, \"123456\", (char*)&vla[2] - 1);\n+  T (int16_t, 4, \"123456\", (char*)&vla[2] - 2);\n+\n+  T (int16_t, 0, \"\", ptr);\n+  T (int16_t, 0, \"\\0\", ptr);\n+  T (int16_t, 1, \"1\", ptr);\n+  T (int16_t, 2, \"12\", ptr);\n+  T (int16_t, 3, \"123\", ptr);\n+\n+  T (int16_t, 2, \"123\", ptr + 1);\n+  T (int16_t, 1, \"123\", &ptr[2]);\n+  T (int16_t, 0, \"123\", &ptr[1] + 2);\n+}\n+\n+void test_int_vla_local (int n)\n+{\n+  T (int16_t, 0, \"\", (char*)vla);\n+  T (int16_t, 0, \"\\0\", (char*)vla);\n+  T (int16_t, 1, \"1\", (char*)vla);\n+  T (int16_t, 2, \"12\", (char*)vla);\n+  T (int16_t, 3, \"123\", (char*)vla);\n+\n+  T (int16_t, 2, \"1234\", (char*)(vla + 1));\n+  T (int16_t, 2, \"123456\", (char*)&vla[2]);\n+  T (int16_t, 1, \"123456\", (char*)&vla[2] + 1);\n+  T (int16_t, 0, \"123456\", (char*)&vla[2] + 2);\n+  T (int16_t, 0, \"123456\", (char*)(&vla[1] + 2));\n+\n+  T (int, 0, \"\", ptr);\n+  T (int, 0, \"\\0\", ptr);\n+  T (int, 1, \"1\", ptr);\n+  T (int, 2, \"12\", ptr);\n+  T (int, 3, \"123\", ptr);\n+\n+  T (int, 2, \"123\", ptr + 1);\n+  T (int, 1, \"123\", &ptr[2]);\n+  T (int, 0, \"123\", &ptr[1] + 2);\n+}\n+\n+\n+#undef T\n+#define T(Type, expect, parr, init, p)\t\t\t\\\n+  do {\t\t\t\t\t\t\t\\\n+    Type (*parray)[] = *ppa++;\t\t\t\t\\\n+    char *ptr = strcpy ((char*)parr, init);\t\t\\\n+    (void)&ptr;\t\t\t\t\t\t\\\n+    ELIM (expect == strlen (p));\t\t\t\\\n+  } while (0)\n+\n+/* Have the function take a pointer to pointers to arrays so that each\n+   test case can use its own pointer to avoid interference between.  */\n+\n+void test_char_array_ptr (char (**ppa)[])\n+{\n+  T (char, 0, *parray, \"\", *parray);\n+  T (char, 0, *parray, \"\", &(*parray)[0]);\n+\n+  T (char, 1, *parray, \"1\", &(*parray)[0]);\n+  T (char, 0, *parray, \"1\", &(*parray)[1]);\n+\n+  T (char, 2, *parray, \"12\", &(*parray)[0]);\n+  T (char, 1, *parray, \"12\", &(*parray)[1]);\n+  T (char, 0, *parray, \"12\", &(*parray)[2]);\n+\n+  T (char, 3, *parray, \"123\", &(*parray)[0]);\n+  T (char, 2, *parray, \"123\", &(*parray)[1]);\n+  T (char, 1, *parray, \"123\", &(*parray)[2]);\n+  T (char, 0, *parray, \"123\", &(*parray)[3]);\n+\n+  T (char, 3, *parray, \"123\", ptr);\n+  T (char, 2, *parray, \"123\", &ptr[1]);\n+  T (char, 1, *parray, \"123\", &ptr[2]);\n+  T (char, 0, *parray, \"123\", &ptr[3]);\n+}\n+\n+void test_int16_array_ptr (int16_t (**ppa)[])\n+{\n+  T (int16_t, 0, *parray, \"\", (char*)*parray);\n+  T (int16_t, 0, *parray, \"\", (char*)&(*parray)[0]);\n+\n+  T (int16_t, 1, *parray, \"1\", (char*)&(*parray)[0]);\n+  T (int16_t, 0, *parray, \"12\", (char*)&(*parray)[1]);\n+\n+  T (int16_t, 2, *parray, \"12\", (char*)&(*parray)[0]);\n+  T (int16_t, 1, *parray, \"12\", (char*)&(*parray)[0] + 1);\n+  T (int16_t, 2, *parray, \"1234\", (char*)&(*parray)[1]);\n+  T (int16_t, 1, *parray, \"1234\", (char*)&(*parray)[1] + 1);\n+  T (int16_t, 0, *parray, \"1234\", (char*)&(*parray)[2]);\n+\n+  T (int16_t, 6, *parray, \"123456\", (char*)&(*parray)[0]);\n+  T (int16_t, 5, *parray, \"123456\", (char*)&(*parray)[0] + 1);\n+  T (int16_t, 0, *parray, \"123456\", (char*)&(*parray)[0] + 6);\n+  T (int16_t, 4, *parray, \"123456\", (char*)&(*parray)[1]);\n+  T (int16_t, 3, *parray, \"123456\", (char*)&(*parray)[1] + 1);\n+  T (int16_t, 0, *parray, \"123456\", (char*)&(*parray)[1] + 4);\n+  T (int16_t, 2, *parray, \"123456\", (char*)&(*parray)[2]);\n+  T (int16_t, 1, *parray, \"123456\", (char*)&(*parray)[2] + 1);\n+  T (int16_t, 0, *parray, \"123456\", (char*)&(*parray)[2] + 2);\n+  T (int16_t, 0, *parray, \"123456\", (char*)&(*parray)[3]);\n+\n+  T (int16_t, 3, *parray, \"123\", (char*)ptr);\n+  T (int16_t, 2, *parray, \"123\", (char*)&ptr[1]);\n+  T (int16_t, 1, *parray, \"123\", (char*)&ptr[2]);\n+  T (int16_t, 0, *parray, \"123\", (char*)&ptr[3]);\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"strlen\" 0 \"optimized\" } }\n+   { dg-final { scan-tree-dump-times \"not_eliminated\" 0 \"optimized\" } } */"}, {"sha": "f77db6bbe7ab4b3036d05a40b0b7c0c9854af0ab", "filename": "gcc/testsuite/gcc.dg/strlenopt-63.c", "status": "added", "additions": 158, "deletions": 0, "changes": 158, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7802a8ec9a03e6ced5b5d8f9018c6b9f45677c3f/gcc%2Ftestsuite%2Fgcc.dg%2Fstrlenopt-63.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7802a8ec9a03e6ced5b5d8f9018c6b9f45677c3f/gcc%2Ftestsuite%2Fgcc.dg%2Fstrlenopt-63.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fstrlenopt-63.c?ref=7802a8ec9a03e6ced5b5d8f9018c6b9f45677c3f", "patch": "@@ -0,0 +1,158 @@\n+/* PR tree-optimization/90662 - strlen of a string in a vla plus offset\n+   not folded\n+   Verify that strlen of pointers to char arrays are computed correctly\n+   (whether folded or not).\n+   { dg-do run }\n+   { dg-options \"-O2 -Wall\" } */\n+\n+#include \"strlenopt.h\"\n+\n+#define A(expr)                                                 \\\n+  ((expr)                                                       \\\n+   ? (void)0                                                    \\\n+   : (__builtin_printf (\"assertion failed on line %i: %s\\n\",    \\\n+                        __LINE__, #expr),                       \\\n+      __builtin_abort ()))\n+\n+typedef char A5[5];\n+\n+A5 a5[5];\n+A5* p[5] = { &a5[4], &a5[3], &a5[2], &a5[1], &a5[0] };\n+\n+__attribute__ ((noclone, noinline, noipa))\n+void deref_deref (void)\n+{\n+  strcpy (**p, \"12345\");\n+  A (strlen (**p) == 5);\n+}\n+\n+__attribute__ ((noclone, noinline, noipa))\n+void deref_idx_0 (void)\n+{\n+  strcpy (*p[0], \"\");\n+  A (strlen (*p[0]) == 0);\n+}\n+\n+__attribute__ ((noclone, noinline, noipa))\n+void deref_idx_1 (void)\n+{\n+  strcpy (*p[1], \"1\");\n+  A (strlen (*p[1]) == 1);\n+  A (strlen (&(*p[1])[1]) == 0);\n+\n+  A (strlen (*p[0]) == 0);\n+}\n+\n+__attribute__ ((noclone, noinline, noipa))\n+void deref_idx_2 (void)\n+{\n+  strcpy (*p[2], \"12\");\n+  A (strlen (*p[2]) == 2);\n+  A (strlen (&(*p[2])[1]) == 1);\n+  A (strlen (&(*p[2])[2]) == 0);\n+\n+  A (strlen (*p[1]) == 1);\n+  A (strlen (*p[0]) == 0);\n+}\n+\n+__attribute__ ((noclone, noinline, noipa))\n+void deref_idx_3 (void)\n+{\n+  strcpy (*p[3], \"123\");\n+  A (strlen (*p[3]) == 3);\n+  A (strlen (&(*p[3])[1]) == 2);\n+  A (strlen (&(*p[3])[2]) == 1);\n+  A (strlen (&(*p[3])[3]) == 0);\n+\n+  A (strlen (*p[2]) == 2);\n+  A (strlen (*p[1]) == 1);\n+  A (strlen (*p[0]) == 0);\n+}\n+\n+__attribute__ ((noclone, noinline, noipa))\n+void deref_idx_4 (void)\n+{\n+  strcpy (*p[4], \"1234\");\n+  A (strlen (*p[4]) == 4);\n+  A (strlen (&(*p[4])[1]) == 3);\n+  A (strlen (&(*p[4])[2]) == 2);\n+  A (strlen (&(*p[4])[3]) == 1);\n+  A (strlen (&(*p[4])[4]) == 0);\n+\n+  A (strlen (*p[3]) == 3);\n+  A (strlen (*p[2]) == 2);\n+  A (strlen (*p[1]) == 1);\n+  A (strlen (*p[0]) == 0);\n+}\n+\n+__attribute__ ((noclone, noinline, noipa))\n+void deref_idx_4_x (void)\n+{\n+  strcpy (*p[4], \"\");\n+  A (strlen (*p[4]) == 0);\n+  A (strlen (*p[3]) == 3);\n+  A (strlen (*p[2]) == 2);\n+  A (strlen (*p[1]) == 1);\n+  A (strlen (*p[0]) == 0);\n+}\n+\n+__attribute__ ((noclone, noinline, noipa))\n+void deref_idx_3_x (void)\n+{\n+  strcpy (&(*p[3])[0], \"1\");\n+  A (strlen (*p[4]) == 0);\n+  A (strlen (*p[3]) == 1);\n+  A (strlen (*p[2]) == 2);\n+  A (strlen (*p[1]) == 1);\n+  A (strlen (*p[0]) == 0);\n+}\n+\n+__attribute__ ((noclone, noinline, noipa))\n+void deref_idx_2_x (void)\n+{\n+  strcpy (*p[2], \"12\");\n+  A (strlen (*p[4]) == 0);\n+  A (strlen (*p[3]) == 1);\n+  A (strlen (*p[2]) == 2);\n+  A (strlen (*p[1]) == 1);\n+  A (strlen (*p[0]) == 0);\n+}\n+\n+__attribute__ ((noclone, noinline, noipa))\n+void deref_idx_1_x (void)\n+{\n+  strcpy (*p[1], \"123\");\n+  A (strlen (*p[4]) == 0);\n+  A (strlen (*p[3]) == 1);\n+  A (strlen (*p[2]) == 2);\n+  A (strlen (*p[1]) == 3);\n+  A (strlen (*p[0]) == 0);\n+}\n+\n+__attribute__ ((noclone, noinline, noipa))\n+void deref_idx_0_x (void)\n+{\n+  strcpy (*p[0], \"1234\");\n+  A (strlen (*p[4]) == 0);\n+  A (strlen (*p[3]) == 1);\n+  A (strlen (*p[2]) == 2);\n+  A (strlen (*p[1]) == 3);\n+  A (strlen (*p[0]) == 4);\n+}\n+\n+int main (void)\n+{\n+  deref_deref ();\n+\n+  deref_idx_0 ();\n+  deref_idx_1 ();\n+  deref_idx_2 ();\n+  deref_idx_3 ();\n+  deref_idx_4 ();\n+\n+  deref_idx_4_x ();\n+  deref_idx_3_x ();\n+  deref_idx_2_x ();\n+  deref_idx_1_x ();\n+  deref_idx_0_x ();\n+}"}, {"sha": "5451457dc31d335d1c932bda0a72c66e81035848", "filename": "gcc/testsuite/gcc.dg/strlenopt-64.c", "status": "added", "additions": 182, "deletions": 0, "changes": 182, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7802a8ec9a03e6ced5b5d8f9018c6b9f45677c3f/gcc%2Ftestsuite%2Fgcc.dg%2Fstrlenopt-64.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7802a8ec9a03e6ced5b5d8f9018c6b9f45677c3f/gcc%2Ftestsuite%2Fgcc.dg%2Fstrlenopt-64.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fstrlenopt-64.c?ref=7802a8ec9a03e6ced5b5d8f9018c6b9f45677c3f", "patch": "@@ -0,0 +1,182 @@\n+/* PR tree-optimization/90662 - strlen of a string in a vla plus offset\n+   not folded\n+   Verify that strlen of pointers to wide character arrays (emulated\n+   by int16_t) are computed correctly (whether folded or not).\n+   { dg-do run }\n+   { dg-options \"-O2 -Wall -Wno-incompatible-pointer-types\" } */\n+\n+#include \"strlenopt.h\"\n+\n+typedef __INT16_TYPE__ int16_t;\n+\n+#define A(expr)                                                 \\\n+  ((expr)                                                       \\\n+   ? (void)0                                                    \\\n+   : (__builtin_printf (\"assertion failed on line %i: %s\\n\",    \\\n+                        __LINE__, #expr),                       \\\n+      __builtin_abort ()))\n+\n+typedef int16_t A5[5];\n+\n+A5 a5[5];\n+A5* p[5] = { &a5[4], &a5[3], &a5[2], &a5[1], &a5[0] };\n+\n+__attribute__ ((noclone, noinline, noipa))\n+void deref_deref (void)\n+{\n+  strcpy (**p, \"12345\");\n+  A (strlen (**p) == 5);\n+}\n+\n+__attribute__ ((noclone, noinline, noipa))\n+void deref_idx_0 (void)\n+{\n+  strcpy (*p[0], \"\");\n+  A (strlen (*p[0]) == 0);\n+}\n+\n+__attribute__ ((noclone, noinline, noipa))\n+void deref_idx_1 (void)\n+{\n+  strcpy (*p[1], \"12\");\n+  A (strlen (*p[1]) == 2);\n+  A (strlen (&(*p[1])[1]) == 0);\n+\n+  A (strlen ((char*)*p[1] + 1) == 1);\n+  A (strlen ((char*)*p[1] + 2) == 0);\n+  A (strlen ((char*)*p[1] + 3) == 0);\n+\n+  A (strlen ((char*)&(*p[1])[1] + 1) == 0);\n+\n+  A (strlen (*p[0]) == 0);\n+}\n+\n+__attribute__ ((noclone, noinline, noipa))\n+void deref_idx_2 (void)\n+{\n+  strcpy (*p[2], \"1234\");\n+  A (strlen (*p[2]) == 4);\n+  A (strlen (&(*p[2])[1]) == 2);\n+  A (strlen (&(*p[2])[2]) == 0);\n+\n+  A (strlen ((char*)*p[2] + 1) == 3);\n+  A (strlen ((char*)*p[2] + 2) == 2);\n+  A (strlen ((char*)*p[2] + 3) == 1);\n+  A (strlen ((char*)*p[2] + 4) == 0);\n+  A (strlen ((char*)*p[2] + 5) == 0);\n+\n+  A (strlen ((char*)&(*p[2])[1] + 1) == 1);\n+  A (strlen ((char*)&(*p[2])[1] + 2) == 0);\n+\n+  A (strlen (*p[1]) == 2);\n+  A (strlen (*p[0]) == 0);\n+}\n+\n+__attribute__ ((noclone, noinline, noipa))\n+void deref_idx_3 (void)\n+{\n+  strcpy (*p[3], \"123456\");\n+  A (strlen (*p[3]) == 6);\n+  A (strlen (&(*p[3])[1]) == 4);\n+  A (strlen (&(*p[3])[2]) == 2);\n+  A (strlen (&(*p[3])[3]) == 0);\n+\n+  A (strlen ((char*)*p[3] + 1) == 5);\n+  A (strlen ((char*)*p[3] + 2) == 4);\n+  A (strlen ((char*)*p[3] + 3) == 3);\n+  A (strlen ((char*)*p[3] + 4) == 2);\n+  A (strlen ((char*)*p[3] + 5) == 1);\n+  A (strlen ((char*)*p[3] + 6) == 0);\n+\n+  A (strlen (*p[2]) == 4);\n+  A (strlen (*p[1]) == 2);\n+  A (strlen (*p[0]) == 0);\n+}\n+\n+__attribute__ ((noclone, noinline, noipa))\n+void deref_idx_4 (void)\n+{\n+  strcpy (*p[4], \"12345678\");\n+  A (strlen (*p[4]) == 8);\n+  A (strlen (&(*p[4])[1]) == 6);\n+  A (strlen (&(*p[4])[2]) == 4);\n+  A (strlen (&(*p[4])[3]) == 2);\n+  A (strlen (&(*p[4])[4]) == 0);\n+\n+  A (strlen (*p[3]) == 6);\n+  A (strlen (*p[2]) == 4);\n+  A (strlen (*p[1]) == 2);\n+  A (strlen (*p[0]) == 0);\n+}\n+\n+__attribute__ ((noclone, noinline, noipa))\n+void deref_idx_4_x (void)\n+{\n+  strcpy (*p[4], \"\");\n+  A (strlen (*p[4]) == 0);\n+  A (strlen (*p[3]) == 6);\n+  A (strlen (*p[2]) == 4);\n+  A (strlen (*p[1]) == 2);\n+  A (strlen (*p[0]) == 0);\n+}\n+\n+__attribute__ ((noclone, noinline, noipa))\n+void deref_idx_3_x (void)\n+{\n+  strcpy (&(*p[3])[0], \"1\");\n+  A (strlen (*p[4]) == 0);\n+  A (strlen (*p[3]) == 1);\n+  A (strlen (*p[2]) == 4);\n+  A (strlen (*p[1]) == 2);\n+  A (strlen (*p[0]) == 0);\n+}\n+\n+__attribute__ ((noclone, noinline, noipa))\n+void deref_idx_2_x (void)\n+{\n+  strcpy (*p[2], \"12\");\n+  A (strlen (*p[4]) == 0);\n+  A (strlen (*p[3]) == 1);\n+  A (strlen (*p[2]) == 2);\n+  A (strlen (*p[1]) == 2);\n+  A (strlen (*p[0]) == 0);\n+}\n+\n+__attribute__ ((noclone, noinline, noipa))\n+void deref_idx_1_x (void)\n+{\n+  strcpy (*p[1], \"123\");\n+  A (strlen (*p[4]) == 0);\n+  A (strlen (*p[3]) == 1);\n+  A (strlen (*p[2]) == 2);\n+  A (strlen (*p[1]) == 3);\n+  A (strlen (*p[0]) == 0);\n+}\n+\n+__attribute__ ((noclone, noinline, noipa))\n+void deref_idx_0_x (void)\n+{\n+  strcpy (*p[0], \"1234\");\n+  A (strlen (*p[4]) == 0);\n+  A (strlen (*p[3]) == 1);\n+  A (strlen (*p[2]) == 2);\n+  A (strlen (*p[1]) == 3);\n+  A (strlen (*p[0]) == 4);\n+}\n+\n+int main (void)\n+{\n+  deref_deref ();\n+\n+  deref_idx_0 ();\n+  deref_idx_1 ();\n+  deref_idx_2 ();\n+  deref_idx_3 ();\n+  deref_idx_4 ();\n+\n+  deref_idx_4_x ();\n+  deref_idx_3_x ();\n+  deref_idx_2_x ();\n+  deref_idx_1_x ();\n+  deref_idx_0_x ();\n+}"}, {"sha": "944650cecd5302c04107fc9ae4d2007c00b035fb", "filename": "gcc/tree-ssa-strlen.c", "status": "modified", "additions": 60, "deletions": 17, "changes": 77, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7802a8ec9a03e6ced5b5d8f9018c6b9f45677c3f/gcc%2Ftree-ssa-strlen.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7802a8ec9a03e6ced5b5d8f9018c6b9f45677c3f/gcc%2Ftree-ssa-strlen.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-strlen.c?ref=7802a8ec9a03e6ced5b5d8f9018c6b9f45677c3f", "patch": "@@ -296,34 +296,77 @@ get_stridx (tree exp)\n     {\n       if (ssa_ver_to_stridx[SSA_NAME_VERSION (exp)])\n \treturn ssa_ver_to_stridx[SSA_NAME_VERSION (exp)];\n-      int i;\n+\n       tree e = exp;\n-      HOST_WIDE_INT off = 0;\n-      for (i = 0; i < 5; i++)\n+      HOST_WIDE_INT offset = 0;\n+      /* Follow a chain of at most 5 assignments.  */\n+      for (int i = 0; i < 5; i++)\n \t{\n \t  gimple *def_stmt = SSA_NAME_DEF_STMT (e);\n-\t  if (!is_gimple_assign (def_stmt)\n-\t      || gimple_assign_rhs_code (def_stmt) != POINTER_PLUS_EXPR)\n+\t  if (!is_gimple_assign (def_stmt))\n \t    return 0;\n-\t  tree rhs1 = gimple_assign_rhs1 (def_stmt);\n-\t  tree rhs2 = gimple_assign_rhs2 (def_stmt);\n-\t  if (TREE_CODE (rhs1) != SSA_NAME\n-\t      || !tree_fits_shwi_p (rhs2))\n+\n+\t  tree_code rhs_code = gimple_assign_rhs_code (def_stmt);\n+\t  tree ptr, off;\n+\n+\t  if (rhs_code == ADDR_EXPR)\n+\t    {\n+\t      /* Handle indices/offsets into VLAs which are implemented\n+\t         as pointers to arrays.  */\n+\t      ptr = gimple_assign_rhs1 (def_stmt);\n+\t      ptr = TREE_OPERAND (ptr, 0);\n+\n+\t      /* Handle also VLAs of types larger than char.  */\n+\t      if (tree eltsize = TYPE_SIZE_UNIT (TREE_TYPE (ptr)))\n+\t\t{\n+\t\t  if (TREE_CODE (ptr) == ARRAY_REF)\n+\t\t    {\n+\t\t      off = TREE_OPERAND (ptr, 1);\n+\t\t      /* Scale the array index by the size of the element\n+\t\t\t type (normally 1 for char).  */\n+\t\t      off = fold_build2 (MULT_EXPR, TREE_TYPE (off), off,\n+\t\t\t\t\t eltsize);\n+\t\t      ptr = TREE_OPERAND (ptr, 0);\n+\t\t    }\n+\t\t  else\n+\t\t    off = integer_zero_node;\n+\t\t}\n+\t      else\n+\t\treturn 0;\n+\n+\t      if (TREE_CODE (ptr) != MEM_REF)\n+\t        return 0;\n+\n+\t      /* Add the MEM_REF byte offset.  */\n+\t      tree mem_off = TREE_OPERAND (ptr, 1);\n+\t      off = fold_build2 (PLUS_EXPR, TREE_TYPE (off), off, mem_off);\n+\t      ptr = TREE_OPERAND (ptr, 0);\n+\t    }\n+\t  else if (rhs_code == POINTER_PLUS_EXPR)\n+\t    {\n+\t      ptr = gimple_assign_rhs1 (def_stmt);\n+\t      off = gimple_assign_rhs2 (def_stmt);\n+\t    }\n+\t  else\n+\t    return 0;\n+\n+\t  if (TREE_CODE (ptr) != SSA_NAME\n+\t      || !tree_fits_shwi_p (off))\n \t    return 0;\n-\t  HOST_WIDE_INT this_off = tree_to_shwi (rhs2);\n+\t  HOST_WIDE_INT this_off = tree_to_shwi (off);\n \t  if (this_off < 0)\n \t    return 0;\n-\t  off = (unsigned HOST_WIDE_INT) off + this_off;\n-\t  if (off < 0)\n+\t  offset = (unsigned HOST_WIDE_INT) offset + this_off;\n+\t  if (offset < 0)\n \t    return 0;\n-\t  if (ssa_ver_to_stridx[SSA_NAME_VERSION (rhs1)])\n+\t  if (ssa_ver_to_stridx[SSA_NAME_VERSION (ptr)])\n \t    {\n \t      strinfo *si\n-\t\t= get_strinfo (ssa_ver_to_stridx[SSA_NAME_VERSION (rhs1)]);\n-\t      if (si && compare_nonzero_chars (si, off) >= 0)\n-\t\treturn get_stridx_plus_constant (si, off, exp);\n+\t        = get_strinfo (ssa_ver_to_stridx[SSA_NAME_VERSION (ptr)]);\n+\t      if (si && compare_nonzero_chars (si, offset) >= 0)\n+\t        return get_stridx_plus_constant (si, offset, exp);\n \t    }\n-\t  e = rhs1;\n+\t  e = ptr;\n \t}\n       return 0;\n     }"}]}