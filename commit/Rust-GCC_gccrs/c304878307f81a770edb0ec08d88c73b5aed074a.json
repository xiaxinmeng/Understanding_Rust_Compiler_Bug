{"sha": "c304878307f81a770edb0ec08d88c73b5aed074a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YzMwNDg3ODMwN2Y4MWE3NzBlZGIwZWMwOGQ4OGM3M2I1YWVkMDc0YQ==", "commit": {"author": {"name": "Eric Botcazou", "email": "ebotcazou@adacore.com", "date": "2007-09-27T16:28:50Z"}, "committer": {"name": "Eric Botcazou", "email": "ebotcazou@gcc.gnu.org", "date": "2007-09-27T16:28:50Z"}, "message": "Mapped location support\n\n\tMapped location support\n\t* back_end.adb (Call_Back_End): Pass information about source\n\tfiles instead of units to gigi.\n\t* gigi.h (struct File_Info_Type): New.\n\t(gigi): Rename and change type of number_units parameter, change\n\ttype of file_info_ptr parameter.\n\t* trans.c (number_files): New global variable.\n\t(gigi): Rename and change type of number_units parameter, change\n\ttype of file_info_ptr parameter.\n\tIf mapped location support is enabled, create the isomorphic mapping\n\tbetween source files and line maps.\n\t(Sloc_to_locus): If mapped location support is enabled, translate\n\tsource location into mapped location.\n\t(annotate_with_node): Rename into set_expr_location_from_node.\n\tCall set_expr_location instead of annotate_with_locus.\n\t(Pragma_to_gnu): Adjust for above change.\n\t(Loop_Statement_to_gnu): Likewise.\n\t(call_to_gnu): Likewise.\n\t(Handled_Sequence_Of_Statements_to_gnu): Likewise.\n\t(gnat_to_gnu): Likewise.\n\t(add_stmt_with_node): Likewise.\n\t(add_cleanup): Likewise.\n\t* utils.c (gnat_init_decl_processing): Do not set input_line.\n\nFrom-SVN: r128839", "tree": {"sha": "e54622c690bcc79a191af53be66102c651e122be", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e54622c690bcc79a191af53be66102c651e122be"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c304878307f81a770edb0ec08d88c73b5aed074a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c304878307f81a770edb0ec08d88c73b5aed074a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c304878307f81a770edb0ec08d88c73b5aed074a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c304878307f81a770edb0ec08d88c73b5aed074a/comments", "author": null, "committer": null, "parents": [{"sha": "3c1eb9eb6c8cf087a78774d6f3a1d7e1eaf1d036", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3c1eb9eb6c8cf087a78774d6f3a1d7e1eaf1d036", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3c1eb9eb6c8cf087a78774d6f3a1d7e1eaf1d036"}], "stats": {"total": 186, "additions": 128, "deletions": 58}, "files": [{"sha": "3da4b5688117c948218e5f650360665d32bbfc73", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c304878307f81a770edb0ec08d88c73b5aed074a/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c304878307f81a770edb0ec08d88c73b5aed074a/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=c304878307f81a770edb0ec08d88c73b5aed074a", "patch": "@@ -1,3 +1,29 @@\n+2007-09-27  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\tMapped location support\n+\t* back_end.adb (Call_Back_End): Pass information about source\n+\tfiles instead of units to gigi.\n+\t* gigi.h (struct File_Info_Type): New.\n+\t(gigi): Rename and change type of number_units parameter, change\n+\ttype of file_info_ptr parameter.\n+\t* trans.c (number_files): New global variable.\n+\t(gigi): Rename and change type of number_units parameter, change\n+\ttype of file_info_ptr parameter.\n+\tIf mapped location support is enabled, create the isomorphic mapping\n+\tbetween source files and line maps.\n+\t(Sloc_to_locus): If mapped location support is enabled, translate\n+\tsource location into mapped location.\n+\t(annotate_with_node): Rename into set_expr_location_from_node.\n+\tCall set_expr_location instead of annotate_with_locus.\n+\t(Pragma_to_gnu): Adjust for above change.\n+\t(Loop_Statement_to_gnu): Likewise.\n+\t(call_to_gnu): Likewise.\n+\t(Handled_Sequence_Of_Statements_to_gnu): Likewise.\n+\t(gnat_to_gnu): Likewise.\n+\t(add_stmt_with_node): Likewise.\n+\t(add_cleanup): Likewise.\n+\t* utils.c (gnat_init_decl_processing): Do not set input_line.\n+\n 2007-09-26  Hristian Kirtchev  <kirtchev@adacore.com>\n \n \t* sem_ch8.adb (Analyze_Use_Type): Code cleanup."}, {"sha": "4f7a41134bb335cacbc23a03c12bcd31d4eac57e", "filename": "gcc/ada/back_end.adb", "status": "modified", "additions": 10, "deletions": 18, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c304878307f81a770edb0ec08d88c73b5aed074a/gcc%2Fada%2Fback_end.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c304878307f81a770edb0ec08d88c73b5aed074a/gcc%2Fada%2Fback_end.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fback_end.adb?ref=c304878307f81a770edb0ec08d88c73b5aed074a", "patch": "@@ -48,19 +48,16 @@ package body Back_End is\n \n    procedure Call_Back_End (Mode : Back_End_Mode_Type) is\n \n-      --  The File_Record type has a lot of components that are meaningless\n-      --  to the back end, so a new record is created here to contain the\n-      --  needed information for each file.\n+      --  The Source_File_Record type has a lot of components that are\n+      --  meaningless to the back end, so a new record type is created\n+      --  here to contain the needed information for each file.\n \n-      type Needed_File_Info_Type is record\n+      type File_Info_Type is record\n          File_Name        : File_Name_Type;\n-         First_Sloc       : Source_Ptr;\n-         Last_Sloc        : Source_Ptr;\n          Num_Source_Lines : Nat;\n       end record;\n \n-      File_Info_Array :\n-        array (Main_Unit .. Last_Unit) of Needed_File_Info_Type;\n+      File_Info_Array : array (1 .. Last_Source_File) of File_Info_Type;\n \n       procedure gigi (\n          gnat_root                     : Int;\n@@ -76,7 +73,7 @@ package body Back_End is\n          strings_ptr                   : Address;\n          string_chars_ptr              : Address;\n          list_headers_ptr              : Address;\n-         number_units                  : Int;\n+         number_file                   : Nat;\n \n          file_info_ptr                 : Address;\n          gigi_standard_integer         : Entity_Id;\n@@ -86,21 +83,16 @@ package body Back_End is\n \n       pragma Import (C, gigi);\n \n-      S : Source_File_Index;\n-\n    begin\n       --  Skip call if in -gnatdH mode\n \n       if Debug_Flag_HH then\n          return;\n       end if;\n \n-      for J in Main_Unit .. Last_Unit loop\n-         S := Source_Index (J);\n-         File_Info_Array (J).File_Name        := File_Name (S);\n-         File_Info_Array (J).First_Sloc       := Source_Text (S)'First;\n-         File_Info_Array (J).Last_Sloc        := Source_Text (S)'Last;\n-         File_Info_Array (J).Num_Source_Lines := Num_Source_Lines (S);\n+      for I in 1 .. Last_Source_File loop\n+         File_Info_Array (I).File_Name        := Full_Debug_Name (I);\n+         File_Info_Array (I).Num_Source_Lines := Num_Source_Lines (I);\n       end loop;\n \n       gigi (\n@@ -117,7 +109,7 @@ package body Back_End is\n          strings_ptr        => Strings_Address,\n          string_chars_ptr   => String_Chars_Address,\n          list_headers_ptr   => Lists_Address,\n-         number_units       => Num_Units,\n+         number_file        => Num_Source_Files,\n \n          file_info_ptr                 => File_Info_Array'Address,\n          gigi_standard_integer         => Standard_Integer,"}, {"sha": "fd7e5967904dcb0ace1cfa6a2910658c51eb6a23", "filename": "gcc/ada/gigi.h", "status": "modified", "additions": 12, "deletions": 7, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c304878307f81a770edb0ec08d88c73b5aed074a/gcc%2Fada%2Fgigi.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c304878307f81a770edb0ec08d88c73b5aed074a/gcc%2Fada%2Fgigi.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgigi.h?ref=c304878307f81a770edb0ec08d88c73b5aed074a", "patch": "@@ -192,6 +192,13 @@ extern bool type_annotate_only;\n /* Current file name without path */\n extern const char *ref_filename;\n \n+/* This structure must be kept synchronized with Call_Back_End.  */\n+struct File_Info_Type\n+{\n+  File_Name_Type File_Name;\n+  Nat Num_Source_Lines;\n+};\n+\n /* This is the main program of the back-end.  It sets up all the table\n    structures and then generates code.\n \n@@ -204,8 +211,8 @@ extern void gigi (Node_Id gnat_root, int max_gnat_node, int number_name,\n                   struct String_Entry *strings_ptr,\n                   Char_Code *strings_chars_ptr,\n                   struct List_Header *list_headers_ptr,\n-\t\t  Int number_units ATTRIBUTE_UNUSED,\n-                  char *file_info_ptr ATTRIBUTE_UNUSED,\n+                  Nat number_file,\n+                  struct File_Info_Type *file_info_ptr ATTRIBUTE_UNUSED,\n                   Entity_Id standard_integer,\n                   Entity_Id standard_long_long_float,\n                   Entity_Id standard_exception_type,\n@@ -229,11 +236,9 @@ extern int gnat_gimplify_expr (tree *expr_p, tree *pre_p,\n    make a GCC type for GNAT_ENTITY and set up the correspondence.  */\n extern void process_type (Entity_Id gnat_entity);\n \n-/* Convert Sloc into *LOCUS (a location_t).  Return true if this Sloc\n-   corresponds to a source code location and false if it doesn't.  In the\n-   latter case, we don't update *LOCUS.  We also set the Gigi global variable\n-   REF_FILENAME to the reference file name as given by sinput (i.e no\n-   directory).  */\n+/* Convert SLOC into LOCUS.  Return true if SLOC corresponds to a source code\n+   location and false if it doesn't.  In the former case, set the Gigi global\n+   variable REF_FILENAME to the simple debug file name as given by sinput.  */\n extern bool Sloc_to_locus (Source_Ptr Sloc, location_t *locus);\n \n /* Post an error message.  MSG is the error message, properly annotated."}, {"sha": "04729f7b4b14517b8f2a70986f8b7c7c7d967087", "filename": "gcc/ada/trans.c", "status": "modified", "additions": 80, "deletions": 31, "changes": 111, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c304878307f81a770edb0ec08d88c73b5aed074a/gcc%2Fada%2Ftrans.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c304878307f81a770edb0ec08d88c73b5aed074a/gcc%2Fada%2Ftrans.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Ftrans.c?ref=c304878307f81a770edb0ec08d88c73b5aed074a", "patch": "@@ -68,8 +68,11 @@\n #define TARGET_ABI_OPEN_VMS 0\n #endif\n \n+extern char *__gnat_to_canonical_file_spec (char *);\n+\n int max_gnat_nodes;\n int number_names;\n+int number_files;\n struct Node *Nodes_Ptr;\n Node_Id *Next_Node_Ptr;\n Node_Id *Prev_Node_Ptr;\n@@ -205,7 +208,7 @@ static tree pos_to_constructor (Node_Id, tree, Entity_Id);\n static tree maybe_implicit_deref (tree);\n static tree gnat_stabilize_reference (tree, bool);\n static tree gnat_stabilize_reference_1 (tree, bool);\n-static void annotate_with_node (tree, Node_Id);\n+static void set_expr_location_from_node (tree, Node_Id);\n static int lvalue_required_p (Node_Id, tree, int);\n \f\n /* This is the main program of the back-end.  It sets up all the table\n@@ -216,17 +219,19 @@ gigi (Node_Id gnat_root, int max_gnat_node, int number_name,\n       struct Node *nodes_ptr, Node_Id *next_node_ptr, Node_Id *prev_node_ptr,\n       struct Elist_Header *elists_ptr, struct Elmt_Item *elmts_ptr,\n       struct String_Entry *strings_ptr, Char_Code *string_chars_ptr,\n-      struct List_Header *list_headers_ptr, Int number_units ATTRIBUTE_UNUSED,\n-      char *file_info_ptr ATTRIBUTE_UNUSED, Entity_Id standard_integer,\n-      Entity_Id standard_long_long_float, Entity_Id standard_exception_type,\n-      Int gigi_operating_mode)\n+      struct List_Header *list_headers_ptr, Nat number_file,\n+      struct File_Info_Type *file_info_ptr ATTRIBUTE_UNUSED,\n+      Entity_Id standard_integer, Entity_Id standard_long_long_float,\n+      Entity_Id standard_exception_type, Int gigi_operating_mode)\n {\n   tree gnu_standard_long_long_float;\n   tree gnu_standard_exception_type;\n   struct elab_info *info;\n+  int i ATTRIBUTE_UNUSED;\n \n   max_gnat_nodes = max_gnat_node;\n   number_names = number_name;\n+  number_files = number_file;\n   Nodes_Ptr = nodes_ptr;\n   Next_Node_Ptr = next_node_ptr;\n   Prev_Node_Ptr = prev_node_ptr;\n@@ -238,6 +243,32 @@ gigi (Node_Id gnat_root, int max_gnat_node, int number_name,\n \n   type_annotate_only = (gigi_operating_mode == 1);\n \n+#ifdef USE_MAPPED_LOCATION\n+  for (i = 0; i < number_files; i++)\n+    {\n+      /* Use the identifier table to make a permanent copy of the filename as\n+\t the name table gets reallocated after Gigi returns but before all the\n+\t debugging information is output.  The __gnat_to_canonical_file_spec\n+\t call translates filenames from pragmas Source_Reference that contain\n+\t host style syntax not understood by gdb. */\n+      const char *filename\n+\t= IDENTIFIER_POINTER\n+\t   (get_identifier\n+\t    (__gnat_to_canonical_file_spec\n+\t     (Get_Name_String (file_info_ptr[i].File_Name))));\n+\n+      /* We rely on the order isomorphism between files and line maps.  */\n+      gcc_assert ((int) line_table->used == i);\n+\n+      /* We create the line map for a source file at once, with a fixed number\n+\t of columns chosen to avoid jumping over the next power of 2.  */\n+      linemap_add (line_table, LC_ENTER, 0, filename, 1);\n+      linemap_line_start (line_table, file_info_ptr[i].Num_Source_Lines, 252);\n+      linemap_position_for_column (line_table, 252 - 1);\n+      linemap_add (line_table, LC_LEAVE, 0, NULL, 0);\n+    }\n+#endif\n+\n   init_gnat_to_gnu ();\n   gnat_compute_largest_alignment ();\n   init_dummy_type ();\n@@ -699,7 +730,7 @@ Pragma_to_gnu (Node_Id gnat_node)\n \t\t\t      gnu_expr, NULL_TREE),\n \t\t\t     NULL_TREE);\n \t  ASM_VOLATILE_P (gnu_expr) = 1;\n-\t  annotate_with_node (gnu_expr, gnat_node);\n+\t  set_expr_location_from_node (gnu_expr, gnat_node);\n \t  append_to_statement_list (gnu_expr, &gnu_result);\n \t}\n       break;\n@@ -1517,7 +1548,7 @@ Loop_Statement_to_gnu (Node_Id gnat_node)\n   TREE_TYPE (gnu_loop_stmt) = void_type_node;\n   TREE_SIDE_EFFECTS (gnu_loop_stmt) = 1;\n   LOOP_STMT_LABEL (gnu_loop_stmt) = create_artificial_label ();\n-  annotate_with_node (gnu_loop_stmt, gnat_node);\n+  set_expr_location_from_node (gnu_loop_stmt, gnat_node);\n \n   /* Save the end label of this LOOP_STMT in a stack so that the corresponding\n      N_Exit_Statement can find it.  */\n@@ -1562,7 +1593,7 @@ Loop_Statement_to_gnu (Node_Id gnat_node)\n \t\t      build_binary_op (LE_EXPR, integer_type_node,\n \t\t\t\t       gnu_low, gnu_high),\n \t\t      NULL_TREE, alloc_stmt_list ());\n-\t  annotate_with_node (gnu_cond_expr, gnat_loop_spec);\n+\t  set_expr_location_from_node (gnu_cond_expr, gnat_loop_spec);\n \t}\n \n       /* Open a new nesting level that will surround the loop to declare the\n@@ -1597,7 +1628,7 @@ Loop_Statement_to_gnu (Node_Id gnat_node)\n \t\t\t   gnu_loop_var,\n \t\t\t   convert (TREE_TYPE (gnu_loop_var),\n \t\t\t\t    integer_one_node));\n-      annotate_with_node (LOOP_STMT_UPDATE (gnu_loop_stmt),\n+      set_expr_location_from_node (LOOP_STMT_UPDATE (gnu_loop_stmt),\n \t\t\t  gnat_iter_scheme);\n     }\n \n@@ -2091,7 +2122,7 @@ call_to_gnu (Node_Id gnat_node, tree *gnu_result_type_p, tree gnu_target)\n \t      /* Set up to move the copy back to the original.  */\n \t      gnu_temp = build_binary_op (MODIFY_EXPR, NULL_TREE,\n \t\t\t\t\t  gnu_copy, gnu_actual);\n-\t      annotate_with_node (gnu_temp, gnat_actual);\n+\t      set_expr_location_from_node (gnu_temp, gnat_actual);\n \t      append_to_statement_list (gnu_temp, &gnu_after_list);\n \n \t      /* Account for next statement just below.  */\n@@ -2453,15 +2484,15 @@ call_to_gnu (Node_Id gnat_node, tree *gnu_result_type_p, tree gnu_target)\n \n \t    gnu_result = build_binary_op (MODIFY_EXPR, NULL_TREE,\n \t\t\t\t\t  gnu_actual, gnu_result);\n-\t    annotate_with_node (gnu_result, gnat_actual);\n+\t    set_expr_location_from_node (gnu_result, gnat_actual);\n \t    append_to_statement_list (gnu_result, &gnu_before_list);\n \t    scalar_return_list = TREE_CHAIN (scalar_return_list);\n \t    gnu_name_list = TREE_CHAIN (gnu_name_list);\n \t  }\n \t}\n   else\n     {\n-      annotate_with_node (gnu_subprog_call, gnat_node);\n+      set_expr_location_from_node (gnu_subprog_call, gnat_node);\n       append_to_statement_list (gnu_subprog_call, &gnu_before_list);\n     }\n \n@@ -2611,7 +2642,7 @@ Handled_Sequence_Of_Statements_to_gnu (Node_Id gnat_node)\n \t defer abortion.  */\n       gnu_expr = build_call_1_expr (raise_nodefer_decl,\n \t\t\t\t    TREE_VALUE (gnu_except_ptr_stack));\n-      annotate_with_node (gnu_expr, gnat_node);\n+      set_expr_location_from_node (gnu_expr, gnat_node);\n \n       if (gnu_else_ptr)\n \t*gnu_else_ptr = gnu_expr;\n@@ -3977,7 +4008,7 @@ gnat_to_gnu (Node_Id gnat_node)\n \t      COND_EXPR_THEN (gnu_expr)\n \t\t= build_stmt_group (Then_Statements (gnat_temp), false);\n \t      TREE_SIDE_EFFECTS (gnu_expr) = 1;\n-\t      annotate_with_node (gnu_expr, gnat_temp);\n+\t      set_expr_location_from_node (gnu_expr, gnat_temp);\n \t      *gnu_else_ptr = gnu_expr;\n \t      gnu_else_ptr = &COND_EXPR_ELSE (gnu_expr);\n \t    }\n@@ -4617,7 +4648,7 @@ gnat_to_gnu (Node_Id gnat_node)\n \t is one.  */\n       if (TREE_CODE (gnu_result_type) == VOID_TYPE)\n \t{\n-\t  annotate_with_node (gnu_result, gnat_node);\n+\t  set_expr_location_from_node (gnu_result, gnat_node);\n \n \t  if (Present (Condition (gnat_node)))\n \t    gnu_result = build3 (COND_EXPR, void_type_node,\n@@ -4708,7 +4739,7 @@ gnat_to_gnu (Node_Id gnat_node)\n      no result if we tried to build a CALL_EXPR node to a procedure with\n      no side-effects and optimization is enabled.  */\n   if (gnu_result && EXPR_P (gnu_result) && !REFERENCE_CLASS_P (gnu_result))\n-    annotate_with_node (gnu_result, gnat_node);\n+    set_expr_location_from_node (gnu_result, gnat_node);\n \n   /* If we're supposed to return something of void_type, it means we have\n      something we're elaborating for effect, so just return.  */\n@@ -4895,7 +4926,7 @@ void\n add_stmt_with_node (tree gnu_stmt, Node_Id gnat_node)\n {\n   if (Present (gnat_node))\n-    annotate_with_node (gnu_stmt, gnat_node);\n+    set_expr_location_from_node (gnu_stmt, gnat_node);\n   add_stmt (gnu_stmt);\n }\n \n@@ -5011,7 +5042,7 @@ static void\n add_cleanup (tree gnu_cleanup, Node_Id gnat_node)\n {\n   if (Present (gnat_node))\n-    annotate_with_node (gnu_cleanup, gnat_node);\n+    set_expr_location_from_node (gnu_cleanup, gnat_node);\n   append_to_statement_list (gnu_cleanup, &current_stmt_group->cleanups);\n }\n \n@@ -6518,21 +6549,37 @@ gnat_stabilize_reference_1 (tree e, bool force)\n   return result;\n }\n \f\n-extern char *__gnat_to_canonical_file_spec (char *);\n-\n-/* Convert Sloc into *LOCUS (a location_t).  Return true if this Sloc\n-   corresponds to a source code location and false if it doesn't.  In the\n-   latter case, we don't update *LOCUS.  We also set the Gigi global variable\n-   REF_FILENAME to the reference file name as given by sinput (i.e no\n-   directory).  */\n+/* Convert SLOC into LOCUS.  Return true if SLOC corresponds to a source code\n+   location and false if it doesn't.  In the former case, set the Gigi global\n+   variable REF_FILENAME to the simple debug file name as given by sinput.  */\n \n bool\n Sloc_to_locus (Source_Ptr Sloc, location_t *locus)\n {\n-  /* If node not from source code, ignore.  */\n-  if (Sloc < 0)\n+  if (Sloc == No_Location)\n     return false;\n \n+  if (Sloc <= Standard_Location)\n+#ifdef USE_MAPPED_LOCATION\n+    {\n+      *locus = BUILTINS_LOCATION;\n+      return false;\n+    }\n+  else\n+    {\n+      Source_File_Index file = Get_Source_File_Index (Sloc);\n+      Logical_Line_Number line = Get_Logical_Line_Number (Sloc);\n+      Column_Number column = Get_Column_Number (Sloc);\n+      struct line_map *map = &line_table->maps[file - 1];\n+\n+      /* Translate the location according to the line-map.h formula.  */\n+      *locus = map->start_location\n+\t\t+ ((line - map->to_line) << map->column_bits)\n+\t\t+ (column & ((1 << map->column_bits) - 1));\n+    }\n+#else\n+  return false;\n+\n   /* Use the identifier table to make a hashed, permanent copy of the filename,\n      since the name table gets reallocated after Gigi returns but before all\n      the debugging information is output. The __gnat_to_canonical_file_spec\n@@ -6545,6 +6592,7 @@ Sloc_to_locus (Source_Ptr Sloc, location_t *locus)\n \t(Get_Name_String (Full_Debug_Name (Get_Source_File_Index (Sloc))))));\n \n   locus->line = Get_Logical_Line_Number (Sloc);\n+#endif\n \n   ref_filename\n     = IDENTIFIER_POINTER\n@@ -6554,18 +6602,18 @@ Sloc_to_locus (Source_Ptr Sloc, location_t *locus)\n   return true;\n }\n \n-/* Similar to annotate_with_locus, but start with the Sloc of GNAT_NODE and\n+/* Similar to set_expr_location, but start with the Sloc of GNAT_NODE and\n    don't do anything if it doesn't correspond to a source location.  */\n \n static void\n-annotate_with_node (tree node, Node_Id gnat_node)\n+set_expr_location_from_node (tree node, Node_Id gnat_node)\n {\n   location_t locus;\n \n   if (!Sloc_to_locus (Sloc (gnat_node), &locus))\n     return;\n \n-  annotate_with_locus (node, locus);\n+  set_expr_location (node, locus);\n }\n \f\n /* Post an error message.  MSG is the error message, properly annotated.\n@@ -6714,7 +6762,6 @@ init_code_table (void)\n   gnu_codes[N_Op_Shift_Right_Arithmetic] = RSHIFT_EXPR;\n }\n \n-#include \"gt-ada-trans.h\"\n /* Return a label to branch to for the exception type in KIND or NULL_TREE\n    if none.  */\n \n@@ -6730,3 +6777,5 @@ get_exception_label (char kind)\n   else\n     return NULL_TREE;\n }\n+\n+#include \"gt-ada-trans.h\""}, {"sha": "77be01dc6d91d7ba11c2fcd049e0fc5768866895", "filename": "gcc/ada/utils.c", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c304878307f81a770edb0ec08d88c73b5aed074a/gcc%2Fada%2Futils.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c304878307f81a770edb0ec08d88c73b5aed074a/gcc%2Fada%2Futils.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Futils.c?ref=c304878307f81a770edb0ec08d88c73b5aed074a", "patch": "@@ -478,8 +478,6 @@ gnat_pushdecl (tree decl, Node_Id gnat_node)\n void\n gnat_init_decl_processing (void)\n {\n-  input_line = 0;\n-\n   /* Make the binding_level structure for global names.  */\n   current_function_decl = 0;\n   current_binding_level = 0;"}]}