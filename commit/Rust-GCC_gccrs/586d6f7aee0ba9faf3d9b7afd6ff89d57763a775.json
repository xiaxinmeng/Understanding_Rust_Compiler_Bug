{"sha": "586d6f7aee0ba9faf3d9b7afd6ff89d57763a775", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTg2ZDZmN2FlZTBiYTlmYWYzZDliN2FmZDZmZjg5ZDU3NzYzYTc3NQ==", "commit": {"author": {"name": "Aldy Hernandez", "email": "aldyh@redhat.com", "date": "2021-05-19T16:27:05Z"}, "committer": {"name": "Aldy Hernandez", "email": "aldyh@redhat.com", "date": "2021-05-26T19:26:54Z"}, "message": "Common API for accessing global and on-demand ranges.\n\nThis patch provides a generic API for accessing global ranges.  It is\nmeant to replace get_range_info() and get_ptr_nonnull() with one\ncommon interface.  It uses the same API as the ranger (class\nrange_query), so there will now be one API for accessing local and\nglobal ranges alike.\n\nFollow-up patches will convert all users of get_range_info and\nget_ptr_nonnull to this API.\n\nFor get_range_info, instead of:\n\n  if (!POINTER_TYPE_P (TREE_TYPE (name)) && SSA_NAME_RANGE_INFO (name))\n    get_range_info (name, vr);\n\nYou can now do:\n\n  get_range_query (cfun)->range_of_expr (vr, name, [stmt]);\n\n...as well as any other of the range_query methods (range_on_edge,\nrange_of_stmt, value_of_expr, value_on_edge, value_on_stmt, etc).\n\nAs per the API, range_of_expr will work on constants, SSA names, and\nanything we support in irange::supports_type_p().\n\nFor pointers, the interface is the same, so instead of:\n\n  else if (POINTER_TYPE_P (TREE_TYPE (name)) && SSA_NAME_PTR_INFO (name))\n    {\n      if (get_ptr_nonnull (name))\n        stuff();\n    }\n\nOne can do:\n\n  get_range_query (cfun)->range_of_expr (vr, name, [stmt]);\n  if (vr.nonzero_p ())\n    stuff ();\n\nAlong with this interface, we are providing a mechanism by which a\npass can use an on-demand ranger transparently, without having to\nchange its code.  Of course, this assumes all get_range_info() and\nget_ptr_nonnull() users have been converted to the new API, which\nfollow-up patches will do.\n\nIf a pass would prefer to use an on-demand ranger with finer grained\nand context aware ranges, all it would have to do is call\nenable_ranger() at the beginning of the pass, and disable_ranger() at\nthe end of the pass.\n\nNote, that to use context aware ranges, any user of range_of_expr()\nwould need to pass additional context.  For example, the optional\ngimple statement (or perhaps use range_on_edge or range_of_stmt).\n\nThe observant reader will note that get_range_query is tied to a\nstruct function, which may not be available in certain contexts, such\nas at RTL time, gimple-fold, or some other places where we may or may\nnot have cfun set.\n\nFor cases where we are sure there is no function, you can use\nget_global_range_query() instead of get_range_query(fun).  The API is\nthe same.\n\nFor cases where a function may be called with or without a function,\nyou could use the following idiom:\n\n  range_query *query = cfun ? get_range_query (cfun)\n    : get_global_range_query ();\n\n  query->range_of_expr (range, expr, [stmt]);\n\nThe default range query obtained by get_range_query() is the global\nrange query, unless the user has enabled an on-demand ranger with\nenable_ranger(), in which case it will use the currently active ranger.\nThat is, until disable_ranger() is called, at which point, we revert\nback to global ranges.\n\nWe think this provides a generic way of accessing ranges, both\nglobally and locally, without having to keep track of types,\nSSA_NAME_RANGE_INFO, and SSA_NAME_PTR_INFO.  We also hope this can be\nused to transition passes from global to on-demand ranges when\nappropriate.\n\ngcc/ChangeLog:\n\n\t* function.c (allocate_struct_function): Set cfun->x_range_query.\n\t* function.h (struct function): Declare x_range_query.\n\t(get_range_query): New.\n\t(get_global_range_query): New.\n\t* gimple-range-cache.cc (ssa_global_cache::ssa_global_cache):\n\tRemove call to safe_grow_cleared.\n\t* gimple-range.cc (get_range_global): New.\n\t(gimple_range_global): Move from gimple-range.h.\n\t(get_global_range_query): New.\n\t(global_range_query::range_of_expr): New.\n\t(enable_ranger): New.\n\t(disable_ranger): New.\n\t* gimple-range.h (gimple_range_global): Move to gimple-range.cc.\n\t(class global_range_query): New.\n\t(enable_ranger): New.\n\t(disable_ranger): New.\n\t* gimple-ssa-evrp.c (evrp_folder::~evrp_folder): Rename\n\tdump_all_value_ranges to dump.\n\t* tree-vrp.c (vrp_prop::finalize): Same.\n\t* value-query.cc (range_query::dump): New.\n\t* value-query.h (range_query::dump): New.\n\t* vr-values.c (vr_values::dump_all_value_ranges): Rename to...\n\t(vr_values::dump): ...this.\n\t* vr-values.h (class vr_values): Rename dump_all_value_ranges to\n\tdump and make virtual.", "tree": {"sha": "42a7e51305d494dc2209159686571148982a0be7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/42a7e51305d494dc2209159686571148982a0be7"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/586d6f7aee0ba9faf3d9b7afd6ff89d57763a775", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/586d6f7aee0ba9faf3d9b7afd6ff89d57763a775", "html_url": "https://github.com/Rust-GCC/gccrs/commit/586d6f7aee0ba9faf3d9b7afd6ff89d57763a775", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/586d6f7aee0ba9faf3d9b7afd6ff89d57763a775/comments", "author": {"login": "aldyh", "id": 12937877, "node_id": "MDQ6VXNlcjEyOTM3ODc3", "avatar_url": "https://avatars.githubusercontent.com/u/12937877?v=4", "gravatar_id": "", "url": "https://api.github.com/users/aldyh", "html_url": "https://github.com/aldyh", "followers_url": "https://api.github.com/users/aldyh/followers", "following_url": "https://api.github.com/users/aldyh/following{/other_user}", "gists_url": "https://api.github.com/users/aldyh/gists{/gist_id}", "starred_url": "https://api.github.com/users/aldyh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/aldyh/subscriptions", "organizations_url": "https://api.github.com/users/aldyh/orgs", "repos_url": "https://api.github.com/users/aldyh/repos", "events_url": "https://api.github.com/users/aldyh/events{/privacy}", "received_events_url": "https://api.github.com/users/aldyh/received_events", "type": "User", "site_admin": false}, "committer": {"login": "aldyh", "id": 12937877, "node_id": "MDQ6VXNlcjEyOTM3ODc3", "avatar_url": "https://avatars.githubusercontent.com/u/12937877?v=4", "gravatar_id": "", "url": "https://api.github.com/users/aldyh", "html_url": "https://github.com/aldyh", "followers_url": "https://api.github.com/users/aldyh/followers", "following_url": "https://api.github.com/users/aldyh/following{/other_user}", "gists_url": "https://api.github.com/users/aldyh/gists{/gist_id}", "starred_url": "https://api.github.com/users/aldyh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/aldyh/subscriptions", "organizations_url": "https://api.github.com/users/aldyh/orgs", "repos_url": "https://api.github.com/users/aldyh/repos", "events_url": "https://api.github.com/users/aldyh/events{/privacy}", "received_events_url": "https://api.github.com/users/aldyh/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "28484d00c45b7bf094a22a4fddf9ffdc7482c7e1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/28484d00c45b7bf094a22a4fddf9ffdc7482c7e1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/28484d00c45b7bf094a22a4fddf9ffdc7482c7e1"}], "stats": {"total": 222, "additions": 172, "deletions": 50}, "files": [{"sha": "675769509832c4ef937cfa6410cba8f0b5f48ec3", "filename": "gcc/function.c", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/586d6f7aee0ba9faf3d9b7afd6ff89d57763a775/gcc%2Ffunction.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/586d6f7aee0ba9faf3d9b7afd6ff89d57763a775/gcc%2Ffunction.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffunction.c?ref=586d6f7aee0ba9faf3d9b7afd6ff89d57763a775", "patch": "@@ -82,6 +82,8 @@ along with GCC; see the file COPYING3.  If not see\n #include \"gimple.h\"\n #include \"options.h\"\n #include \"function-abi.h\"\n+#include \"value-range.h\"\n+#include \"gimple-range.h\"\n \n /* So we can assign to cfun in this file.  */\n #undef cfun\n@@ -4856,6 +4858,8 @@ allocate_struct_function (tree fndecl, bool abstract_p)\n      binding annotations among them.  */\n   cfun->debug_nonbind_markers = lang_hooks.emits_begin_stmt\n     && MAY_HAVE_DEBUG_MARKER_STMTS;\n+\n+  cfun->x_range_query = &global_ranges;\n }\n \n /* This is like allocate_struct_function, but pushes a new cfun for FNDECL"}, {"sha": "0db51775e7c68732ed42d0edd9cab4065d690ab6", "filename": "gcc/function.h", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/586d6f7aee0ba9faf3d9b7afd6ff89d57763a775/gcc%2Ffunction.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/586d6f7aee0ba9faf3d9b7afd6ff89d57763a775/gcc%2Ffunction.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffunction.h?ref=586d6f7aee0ba9faf3d9b7afd6ff89d57763a775", "patch": "@@ -157,6 +157,7 @@ struct GTY(()) rtl_eh {\n struct gimple_df;\n struct call_site_record_d;\n struct dw_fde_node;\n+class range_query;\n \n struct GTY(()) varasm_status {\n   /* If we're using a per-function constant pool, this is it.  */\n@@ -309,6 +310,11 @@ struct GTY(()) function {\n      debugging is enabled.  */\n   struct dw_fde_node *fde;\n \n+  /* Range query mechanism for functions.  The default is to pick up\n+     global ranges.  If a pass wants on-demand ranges OTOH, it must\n+     call enable/disable_ranger().  */\n+  range_query * GTY ((skip)) x_range_query;\n+\n   /* Last statement uid.  */\n   int last_stmt_uid;\n \n@@ -712,4 +718,15 @@ extern const char *current_function_name (void);\n \n extern void used_types_insert (tree);\n \n+/* Returns the currently active range access class.  When there is no active\n+   range class, global ranges are used.  */\n+\n+inline range_query *\n+get_range_query (struct function *fun)\n+{\n+  return fun->x_range_query;\n+}\n+\n+extern range_query *get_global_range_query ();\n+\n #endif  /* GCC_FUNCTION_H */"}, {"sha": "889cac1ea65d3bced4f1011eb71adadd30e192ca", "filename": "gcc/gimple-range-cache.cc", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/586d6f7aee0ba9faf3d9b7afd6ff89d57763a775/gcc%2Fgimple-range-cache.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/586d6f7aee0ba9faf3d9b7afd6ff89d57763a775/gcc%2Fgimple-range-cache.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-range-cache.cc?ref=586d6f7aee0ba9faf3d9b7afd6ff89d57763a775", "patch": "@@ -384,7 +384,6 @@ block_range_cache::dump (FILE *f, basic_block bb, bool print_varying)\n ssa_global_cache::ssa_global_cache ()\n {\n   m_tab.create (0);\n-  m_tab.safe_grow_cleared (num_ssa_names);\n   m_irange_allocator = new irange_allocator;\n }\n "}, {"sha": "e351a841583953c302cba9ba5fd0f5960ae8abdb", "filename": "gcc/gimple-range.cc", "status": "modified", "additions": 126, "deletions": 0, "changes": 126, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/586d6f7aee0ba9faf3d9b7afd6ff89d57763a775/gcc%2Fgimple-range.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/586d6f7aee0ba9faf3d9b7afd6ff89d57763a775/gcc%2Fgimple-range.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-range.cc?ref=586d6f7aee0ba9faf3d9b7afd6ff89d57763a775", "patch": "@@ -1440,3 +1440,129 @@ trace_ranger::range_of_expr (irange &r, tree name, gimple *s)\n \n   return trailer (idx, \"range_of_expr\", res, name, r);\n }\n+\n+// Return the legacy global range for NAME if it has one, otherwise\n+// return VARYING.\n+\n+static void\n+get_range_global (irange &r, tree name)\n+{\n+  tree type = TREE_TYPE (name);\n+\n+  if (SSA_NAME_IS_DEFAULT_DEF (name))\n+    {\n+      tree sym = SSA_NAME_VAR (name);\n+      // Adapted from vr_values::get_lattice_entry().\n+      // Use a range from an SSA_NAME's available range.\n+      if (TREE_CODE (sym) == PARM_DECL)\n+\t{\n+\t  // Try to use the \"nonnull\" attribute to create ~[0, 0]\n+\t  // anti-ranges for pointers.  Note that this is only valid with\n+\t  // default definitions of PARM_DECLs.\n+\t  if (POINTER_TYPE_P (type)\n+\t      && ((cfun && nonnull_arg_p (sym)) || get_ptr_nonnull (name)))\n+\t    r.set_nonzero (type);\n+\t  else if (INTEGRAL_TYPE_P (type))\n+\t    {\n+\t      get_range_info (name, r);\n+\t      if (r.undefined_p ())\n+\t\tr.set_varying (type);\n+\t    }\n+\t  else\n+\t    r.set_varying (type);\n+\t}\n+      // If this is a local automatic with no definition, use undefined.\n+      else if (TREE_CODE (sym) != RESULT_DECL)\n+\tr.set_undefined ();\n+      else\n+\tr.set_varying (type);\n+   }\n+  else if (!POINTER_TYPE_P (type) && SSA_NAME_RANGE_INFO (name))\n+    {\n+      get_range_info (name, r);\n+      if (r.undefined_p ())\n+\tr.set_varying (type);\n+    }\n+  else if (POINTER_TYPE_P (type) && SSA_NAME_PTR_INFO (name))\n+    {\n+      if (get_ptr_nonnull (name))\n+\tr.set_nonzero (type);\n+      else\n+\tr.set_varying (type);\n+    }\n+  else\n+    r.set_varying (type);\n+}\n+\n+// ?? Like above, but only for default definitions of NAME.  This is\n+// so VRP passes using ranger do not start with known ranges,\n+// otherwise we'd eliminate builtin_unreachables too early because of\n+// inlining.\n+//\n+// Without this restriction, the test in g++.dg/tree-ssa/pr61034.C has\n+// all of its unreachable calls removed too early.  We should\n+// investigate whether we should just adjust the test above.\n+\n+value_range\n+gimple_range_global (tree name)\n+{\n+  gcc_checking_assert (gimple_range_ssa_p (name));\n+  tree type = TREE_TYPE (name);\n+\n+  if (SSA_NAME_IS_DEFAULT_DEF (name))\n+    {\n+      value_range vr;\n+      get_range_global (vr, name);\n+      return vr;\n+    }\n+  return value_range (type);\n+}\n+\n+// ----------------------------------------------\n+// global_range_query implementation.\n+\n+global_range_query global_ranges;\n+\n+// Like get_range_query, but for accessing global ranges.\n+\n+range_query *\n+get_global_range_query ()\n+{\n+  return &global_ranges;\n+}\n+\n+bool\n+global_range_query::range_of_expr (irange &r, tree expr, gimple *)\n+{\n+  tree type = TREE_TYPE (expr);\n+\n+  if (!irange::supports_type_p (type) || !gimple_range_ssa_p (expr))\n+    return get_tree_range (r, expr);\n+\n+  get_range_global (r, expr);\n+\n+  return true;\n+}\n+\n+gimple_ranger *\n+enable_ranger (struct function *fun)\n+{\n+  gimple_ranger *r;\n+\n+  if (param_evrp_mode & EVRP_MODE_TRACE)\n+    r = new trace_ranger;\n+  else\n+    r = new gimple_ranger;\n+\n+  fun->x_range_query = r;\n+\n+  return r;\n+}\n+\n+void\n+disable_ranger (struct function *fun)\n+{\n+  delete fun->x_range_query;\n+\n+  fun->x_range_query = &global_ranges;\n+}"}, {"sha": "23734c6e226114a5f754095c46431ea5cd64daf2", "filename": "gcc/gimple-range.h", "status": "modified", "additions": 15, "deletions": 45, "changes": 60, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/586d6f7aee0ba9faf3d9b7afd6ff89d57763a775/gcc%2Fgimple-range.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/586d6f7aee0ba9faf3d9b7afd6ff89d57763a775/gcc%2Fgimple-range.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-range.h?ref=586d6f7aee0ba9faf3d9b7afd6ff89d57763a775", "patch": "@@ -65,7 +65,7 @@ class gimple_ranger : public range_query\n   virtual void range_on_entry (irange &r, basic_block bb, tree name);\n   virtual void range_on_exit (irange &r, basic_block bb, tree name);\n   void export_global_ranges ();\n-  void dump (FILE *f);\n+  virtual void dump (FILE *f) OVERRIDE;\n   void dump_bb (FILE *f, basic_block bb);\n protected:\n   bool fold_range_internal (irange &r, gimple *s, tree name);\n@@ -227,50 +227,6 @@ range_compatible_p (tree type1, tree type2)\n \t  && TYPE_SIGN (type1) == TYPE_SIGN (type2));\n }\n \n-// Return the legacy GCC global range for NAME if it has one, otherwise\n-// return VARYING.\n-\n-static inline value_range\n-gimple_range_global (tree name)\n-{\n-  gcc_checking_assert (gimple_range_ssa_p (name));\n-  tree type = TREE_TYPE (name);\n-\n-  if (SSA_NAME_IS_DEFAULT_DEF (name))\n-    {\n-      tree sym = SSA_NAME_VAR (name);\n-      // Adapted from vr_values::get_lattice_entry().\n-      // Use a range from an SSA_NAME's available range.\n-      if (TREE_CODE (sym) == PARM_DECL)\n-\t{\n-\t  // Try to use the \"nonnull\" attribute to create ~[0, 0]\n-\t  // anti-ranges for pointers.  Note that this is only valid with\n-\t  // default definitions of PARM_DECLs.\n-\t  if (POINTER_TYPE_P (type)\n-\t      && (nonnull_arg_p (sym) || get_ptr_nonnull (name)))\n-\t    {\n-\t      value_range r;\n-\t      r.set_nonzero (type);\n-\t      return r;\n-\t    }\n-\t  else if (INTEGRAL_TYPE_P (type))\n-\t    {\n-\t      value_range r;\n-\t      get_range_info (name, r);\n-\t      if (r.undefined_p ())\n-\t\tr.set_varying (type);\n-\t      return r;\n-\t    }\n-\t}\n-      // If this is a local automatic with no definition, use undefined.\n-      else if (TREE_CODE (sym) != RESULT_DECL)\n-\treturn value_range ();\n-   }\n-  // Otherwise return range for the type.\n-  return value_range (type);\n-}\n-\n-\n // This class overloads the ranger routines to provide tracing facilties\n // Entry and exit values to each of the APIs is placed in the dumpfile.\n \n@@ -296,4 +252,18 @@ class trace_ranger : public gimple_ranger\n // Flag to enable debugging the various internal Caches.\n #define DEBUG_RANGE_CACHE (dump_file && (param_evrp_mode & EVRP_MODE_DEBUG))\n \n+// Global ranges for SSA names using SSA_NAME_RANGE_INFO.\n+\n+class global_range_query : public range_query\n+{\n+public:\n+  bool range_of_expr (irange &r, tree expr, gimple * = NULL) OVERRIDE;\n+};\n+\n+extern global_range_query global_ranges;\n+extern value_range gimple_range_global (tree name);\n+\n+extern gimple_ranger *enable_ranger (struct function *);\n+extern void disable_ranger (struct function *);\n+\n #endif // GCC_GIMPLE_RANGE_STMT_H"}, {"sha": "829fdcdaef2a927e5c2e683610329787f2942ae0", "filename": "gcc/gimple-ssa-evrp.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/586d6f7aee0ba9faf3d9b7afd6ff89d57763a775/gcc%2Fgimple-ssa-evrp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/586d6f7aee0ba9faf3d9b7afd6ff89d57763a775/gcc%2Fgimple-ssa-evrp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-ssa-evrp.c?ref=586d6f7aee0ba9faf3d9b7afd6ff89d57763a775", "patch": "@@ -60,7 +60,7 @@ class evrp_folder : public substitute_and_fold_engine\n     if (dump_file)\n       {\n \tfprintf (dump_file, \"\\nValue ranges after Early VRP:\\n\\n\");\n-\tm_range_analyzer.dump_all_value_ranges (dump_file);\n+\tm_range_analyzer.dump (dump_file);\n \tfprintf (dump_file, \"\\n\");\n       }\n   }"}, {"sha": "b0f1c47f05c8255efd8c150588d886fbfec18aa1", "filename": "gcc/tree-vrp.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/586d6f7aee0ba9faf3d9b7afd6ff89d57763a775/gcc%2Ftree-vrp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/586d6f7aee0ba9faf3d9b7afd6ff89d57763a775/gcc%2Ftree-vrp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vrp.c?ref=586d6f7aee0ba9faf3d9b7afd6ff89d57763a775", "patch": "@@ -4044,7 +4044,7 @@ vrp_prop::finalize ()\n   if (dump_file)\n     {\n       fprintf (dump_file, \"\\nValue ranges after VRP:\\n\\n\");\n-      m_vr_values->dump_all_value_ranges (dump_file);\n+      m_vr_values->dump (dump_file);\n       fprintf (dump_file, \"\\n\");\n     }\n "}, {"sha": "509d2d33cc528fdc4e54c6cef0ac90b8d012b36b", "filename": "gcc/value-query.cc", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/586d6f7aee0ba9faf3d9b7afd6ff89d57763a775/gcc%2Fvalue-query.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/586d6f7aee0ba9faf3d9b7afd6ff89d57763a775/gcc%2Fvalue-query.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvalue-query.cc?ref=586d6f7aee0ba9faf3d9b7afd6ff89d57763a775", "patch": "@@ -135,6 +135,11 @@ range_query::value_of_stmt (gimple *stmt, tree name)\n \n }\n \n+void\n+range_query::dump (FILE *)\n+{\n+}\n+\n // valuation_query support routines for value_range_equiv's.\n \n class equiv_allocator : public object_allocator<value_range_equiv>"}, {"sha": "5eff9317ed539548d8025b83531afd1f22e08bc1", "filename": "gcc/value-query.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/586d6f7aee0ba9faf3d9b7afd6ff89d57763a775/gcc%2Fvalue-query.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/586d6f7aee0ba9faf3d9b7afd6ff89d57763a775/gcc%2Fvalue-query.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvalue-query.h?ref=586d6f7aee0ba9faf3d9b7afd6ff89d57763a775", "patch": "@@ -95,6 +95,7 @@ class range_query : public value_query\n   // rewrite all uses of it to the above API.\n   virtual const class value_range_equiv *get_value_range (const_tree,\n \t\t\t\t\t\t\t  gimple * = NULL);\n+  virtual void dump (FILE *);\n \n protected:\n   class value_range_equiv *allocate_value_range_equiv ();"}, {"sha": "e0c8844bb0d91cf26b8923e7e812db3efd35c02f", "filename": "gcc/vr-values.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/586d6f7aee0ba9faf3d9b7afd6ff89d57763a775/gcc%2Fvr-values.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/586d6f7aee0ba9faf3d9b7afd6ff89d57763a775/gcc%2Fvr-values.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvr-values.c?ref=586d6f7aee0ba9faf3d9b7afd6ff89d57763a775", "patch": "@@ -1819,7 +1819,7 @@ vr_values::adjust_range_with_scev (value_range_equiv *vr, class loop *loop,\n /* Dump value ranges of all SSA_NAMEs to FILE.  */\n \n void\n-vr_values::dump_all_value_ranges (FILE *file)\n+vr_values::dump (FILE *file)\n {\n   size_t i;\n "}, {"sha": "81b9131f7f1cb64a8d2aa16107d173c1fea2ddb5", "filename": "gcc/vr-values.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/586d6f7aee0ba9faf3d9b7afd6ff89d57763a775/gcc%2Fvr-values.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/586d6f7aee0ba9faf3d9b7afd6ff89d57763a775/gcc%2Fvr-values.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvr-values.h?ref=586d6f7aee0ba9faf3d9b7afd6ff89d57763a775", "patch": "@@ -116,7 +116,7 @@ class vr_values : public range_query\n   tree op_with_constant_singleton_value_range (tree);\n   void adjust_range_with_scev (value_range_equiv *, class loop *,\n \t\t\t       gimple *, tree);\n-  void dump_all_value_ranges (FILE *);\n+  virtual void dump (FILE *) OVERRIDE;\n \n   void extract_range_for_var_from_comparison_expr (tree, enum tree_code,\n \t\t\t\t\t\t   tree, tree,"}]}