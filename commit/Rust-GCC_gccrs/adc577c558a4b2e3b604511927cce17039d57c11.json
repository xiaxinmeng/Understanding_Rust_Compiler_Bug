{"sha": "adc577c558a4b2e3b604511927cce17039d57c11", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YWRjNTc3YzU1OGE0YjJlM2I2MDQ1MTE5MjdjY2UxNzAzOWQ1N2MxMQ==", "commit": {"author": {"name": "Aldy Hernandez", "email": "aldyh@redhat.com", "date": "2016-10-18T21:40:58Z"}, "committer": {"name": "Aldy Hernandez", "email": "aldyh@gcc.gnu.org", "date": "2016-10-18T21:40:58Z"}, "message": "Makefile.in (OBJS): Add gimple-ssa-warn-alloca.o.\n\n\t* Makefile.in (OBJS): Add gimple-ssa-warn-alloca.o.\n\t* passes.def: Add two instances of pass_walloca.\n\t* tree-pass.h (make_pass_walloca): New.\n\t* gimple-ssa-warn-walloca.c: New file.\n\t* doc/invoke.texi: Document -Walloca, -Walloca-larger-than=, and\n\t-Wvla-larger-than= options.\n\nFrom-SVN: r241318", "tree": {"sha": "dfe1d533c1e9dab17d08ca538f808ea3dd632eea", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/dfe1d533c1e9dab17d08ca538f808ea3dd632eea"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/adc577c558a4b2e3b604511927cce17039d57c11", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/adc577c558a4b2e3b604511927cce17039d57c11", "html_url": "https://github.com/Rust-GCC/gccrs/commit/adc577c558a4b2e3b604511927cce17039d57c11", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/adc577c558a4b2e3b604511927cce17039d57c11/comments", "author": {"login": "aldyh", "id": 12937877, "node_id": "MDQ6VXNlcjEyOTM3ODc3", "avatar_url": "https://avatars.githubusercontent.com/u/12937877?v=4", "gravatar_id": "", "url": "https://api.github.com/users/aldyh", "html_url": "https://github.com/aldyh", "followers_url": "https://api.github.com/users/aldyh/followers", "following_url": "https://api.github.com/users/aldyh/following{/other_user}", "gists_url": "https://api.github.com/users/aldyh/gists{/gist_id}", "starred_url": "https://api.github.com/users/aldyh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/aldyh/subscriptions", "organizations_url": "https://api.github.com/users/aldyh/orgs", "repos_url": "https://api.github.com/users/aldyh/repos", "events_url": "https://api.github.com/users/aldyh/events{/privacy}", "received_events_url": "https://api.github.com/users/aldyh/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "c354ab1fb22e031c69ff75e498eee0e70eaea40f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c354ab1fb22e031c69ff75e498eee0e70eaea40f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c354ab1fb22e031c69ff75e498eee0e70eaea40f"}], "stats": {"total": 1033, "additions": 1030, "deletions": 3}, "files": [{"sha": "2431b30627e3f4351894dd6a80553322602fa4f0", "filename": "gcc/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/adc577c558a4b2e3b604511927cce17039d57c11/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/adc577c558a4b2e3b604511927cce17039d57c11/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=adc577c558a4b2e3b604511927cce17039d57c11", "patch": "@@ -1,3 +1,12 @@\n+2016-10-18  Aldy Hernandez  <aldyh@redhat.com>\n+\n+\t* Makefile.in (OBJS): Add gimple-ssa-warn-alloca.o.\n+\t* passes.def: Add two instances of pass_walloca.\n+\t* tree-pass.h (make_pass_walloca): New.\n+\t* gimple-ssa-warn-alloca.c: New file.\n+\t* doc/invoke.texi: Document -Walloca, -Walloca-larger-than=, and\n+\t-Wvla-larger-than= options.\n+\n 2016-10-18  Thomas Schwinge  <thomas@codesourcery.com>\n \n \t* cfg.c (clear_bb_flags): Use FOR_ALL_BB_FN."}, {"sha": "c08da80be2775fa197544b98f5db06b69b12e574", "filename": "gcc/Makefile.in", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/adc577c558a4b2e3b604511927cce17039d57c11/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/adc577c558a4b2e3b604511927cce17039d57c11/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=adc577c558a4b2e3b604511927cce17039d57c11", "patch": "@@ -1298,6 +1298,7 @@ OBJS = \\\n \tgimple-ssa-split-paths.o \\\n \tgimple-ssa-strength-reduction.o \\\n \tgimple-ssa-sprintf.o \\\n+\tgimple-ssa-warn-alloca.o \\\n \tgimple-streamer-in.o \\\n \tgimple-streamer-out.o \\\n \tgimple-walk.o \\"}, {"sha": "f305593006527c840fe63b6a8ce09b7dbb5cb342", "filename": "gcc/c-family/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/adc577c558a4b2e3b604511927cce17039d57c11/gcc%2Fc-family%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/adc577c558a4b2e3b604511927cce17039d57c11/gcc%2Fc-family%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2FChangeLog?ref=adc577c558a4b2e3b604511927cce17039d57c11", "patch": "@@ -1,3 +1,9 @@\n+2016-06-16  Aldy Hernandez  <aldyh@redhat.com>\n+\n+\t* c.opt (Walloca): New.\n+\t(Walloca-larger-than=): New.\n+\t(Wvla-larger-than=): New.\n+\n 2016-10-17  Marek Polacek  <polacek@redhat.com>\n \n \t* c-warn.c (find_array_ref_with_const_idx_r): Remove parameter names."}, {"sha": "c39930708d6192cb00a956e8dd05f68c13671c41", "filename": "gcc/c-family/c-opts.c", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/adc577c558a4b2e3b604511927cce17039d57c11/gcc%2Fc-family%2Fc-opts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/adc577c558a4b2e3b604511927cce17039d57c11/gcc%2Fc-family%2Fc-opts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc-opts.c?ref=adc577c558a4b2e3b604511927cce17039d57c11", "patch": "@@ -380,6 +380,16 @@ c_common_handle_option (size_t scode, const char *arg, int value,\n       cpp_opts->warn_num_sign_change = value;\n       break;\n \n+    case OPT_Walloca_larger_than_:\n+      if (!value)\n+\tinform (loc, \"-Walloca-larger-than=0 is meaningless\");\n+      break;\n+\n+    case OPT_Wvla_larger_than_:\n+      if (!value)\n+\tinform (loc, \"-Wvla-larger-than=0 is meaningless\");\n+      break;\n+\n     case OPT_Wunknown_pragmas:\n       /* Set to greater than 1, so that even unknown pragmas in\n \t system headers will be warned about.  */"}, {"sha": "458d453cdd8c9f9ebc82ab40a7e8d9bf6f1ea8ff", "filename": "gcc/c-family/c.opt", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/adc577c558a4b2e3b604511927cce17039d57c11/gcc%2Fc-family%2Fc.opt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/adc577c558a4b2e3b604511927cce17039d57c11/gcc%2Fc-family%2Fc.opt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc.opt?ref=adc577c558a4b2e3b604511927cce17039d57c11", "patch": "@@ -295,6 +295,16 @@ Wall\n C ObjC C++ ObjC++ Warning\n Enable most warning messages.\n \n+Walloca\n+C ObjC C++ ObjC++ Var(warn_alloca) Warning\n+Warn on any use of alloca.\n+\n+Walloca-larger-than=\n+C ObjC C++ ObjC++ Var(warn_alloca_limit) Warning Joined RejectNegative UInteger\n+-Walloca-larger-than=<number> Warn on unbounded uses of\n+alloca, and on bounded uses of alloca whose bound can be larger than\n+<number> bytes.\n+\n Warray-bounds\n LangEnabledBy(C ObjC C++ ObjC++,Wall)\n ; in common.opt\n@@ -1030,6 +1040,12 @@ Wvla\n C ObjC C++ ObjC++ Var(warn_vla) Init(-1) Warning\n Warn if a variable length array is used.\n \n+Wvla-larger-than=\n+C ObjC C++ ObjC++ Var(warn_vla_limit) Warning Joined RejectNegative UInteger\n+-Wvla-larger-than=<number> Warn on unbounded uses of variable-length arrays, and\n+on bounded uses of variable-length arrays whose bound can be\n+larger than <number> bytes.\n+\n Wvolatile-register-var\n C ObjC C++ ObjC++ Var(warn_volatile_register_var) Warning LangEnabledBy(C ObjC C++ ObjC++,Wall)\n Warn when a register variable is declared volatile."}, {"sha": "556ad36be0dda811462affdfbb6b08b3495892ac", "filename": "gcc/doc/invoke.texi", "status": "modified", "additions": 87, "deletions": 3, "changes": 90, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/adc577c558a4b2e3b604511927cce17039d57c11/gcc%2Fdoc%2Finvoke.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/adc577c558a4b2e3b604511927cce17039d57c11/gcc%2Fdoc%2Finvoke.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Finvoke.texi?ref=adc577c558a4b2e3b604511927cce17039d57c11", "patch": "@@ -255,6 +255,7 @@ Objective-C and Objective-C++ Dialects}.\n @gccoptlist{-fsyntax-only  -fmax-errors=@var{n}  -Wpedantic @gol\n -pedantic-errors @gol\n -w  -Wextra  -Wall  -Waddress  -Waggregate-return  @gol\n+-Walloca -Walloca-larger-than=@var{n} @gol\n -Wno-aggressive-loop-optimizations -Warray-bounds -Warray-bounds=@var{n} @gol\n -Wno-attributes -Wbool-compare -Wbool-operation @gol\n -Wno-builtin-macro-redefined -Wc90-c99-compat -Wc99-c11-compat @gol\n@@ -313,7 +314,7 @@ Objective-C and Objective-C++ Dialects}.\n -Wunused-const-variable -Wunused-const-variable=@var{n} @gol\n -Wunused-but-set-parameter -Wunused-but-set-variable @gol\n -Wuseless-cast -Wvariadic-macros -Wvector-operation-performance @gol\n--Wvla -Wvolatile-register-var  -Wwrite-strings @gol\n+-Wvla -Wvla-larger-than=@var{n} -Wvolatile-register-var  -Wwrite-strings @gol\n -Wzero-as-null-pointer-constant -Whsa}\n \n @item C and Objective-C-only Warning Options\n@@ -4976,6 +4977,73 @@ annotations.\n Warn about overriding virtual functions that are not marked with the override\n keyword.\n \n+@item -Walloca\n+@opindex Wno-alloca\n+@opindex Walloca\n+This option warns on all uses of @code{alloca} in the source.\n+\n+@item -Walloca-larger-than=@var{n}\n+This option warns on calls to @code{alloca} that are not bounded by a\n+controlling predicate limiting its size to @var{n} bytes, or calls to\n+@code{alloca} where the bound is unknown.\n+\n+For example, a bounded case of @code{alloca} could be:\n+\n+@smallexample\n+void func (size_t n)\n+@{\n+  void *p;\n+  if (n <= 1000)\n+    p = alloca (n);\n+  else\n+    p = malloc (n);\n+  f (p);\n+@}\n+@end smallexample\n+\n+In the above example, passing @code{-Walloca=1000} would not issue a\n+warning because the call to @code{alloca} is known to be at most 1000\n+bytes.  However, if @code{-Walloca=500} was passed, the compiler would\n+have emitted a warning.\n+\n+Unbounded uses, on the other hand, are uses of @code{alloca} with no\n+controlling predicate verifying its size.  For example:\n+\n+@smallexample\n+void func ()\n+@{\n+  void *p = alloca (n);\n+  f (p);\n+@}\n+@end smallexample\n+\n+If @code{-Walloca=500} was passed, the above would trigger a warning,\n+but this time because of the lack of bounds checking.\n+\n+Note, that even seemingly correct code involving signed integers could\n+cause a warning:\n+\n+@smallexample\n+void func (signed int n)\n+@{\n+  if (n < 500)\n+    @{\n+      p = alloca (n);\n+      f (p);\n+    @}\n+@}\n+@end smallexample\n+\n+In the above example, @var{n} could be negative, causing a larger than\n+expected argument to be implicitly casted into the @code{alloca} call.\n+\n+This option also warns when @code{alloca} is used in a loop.\n+\n+This warning is not enabled by @option{-Wall}, and is only active when\n+@option{-ftree-vrp} is active (default for @option{-O2} and above).\n+\n+See also @option{-Wvla-larger-than=@var{n}}.\n+\n @item -Warray-bounds\n @itemx -Warray-bounds=@var{n}\n @opindex Wno-array-bounds\n@@ -6172,9 +6240,25 @@ moving from a moved-from object, this warning can be disabled.\n @item -Wvla\n @opindex Wvla\n @opindex Wno-vla\n-Warn if variable length array is used in the code.\n+Warn if a variable-length array is used in the code.\n @option{-Wno-vla} prevents the @option{-Wpedantic} warning of\n-the variable length array.\n+the variable-length array.\n+\n+@item -Wvla-larger-than=@var{n}\n+If this option is used, the compiler will warn on uses of\n+variable-length arrays where the size is either unbounded, or bounded\n+by an argument that can be larger than @var{n} bytes.  This is similar\n+to how @option{-Walloca-larger-than=@var{n}} works, but with\n+variable-length arrays.\n+\n+Note that GCC may optimize small variable-length arrays of a known\n+value into plain arrays, so this warning may not get triggered for\n+such arrays.\n+\n+This warning is not enabled by @option{-Wall}, and is only active when\n+@option{-ftree-vrp} is active (default for @option{-O2} and above).\n+\n+See also @option{-Walloca-larger-than=@var{n}}.\n \n @item -Wvolatile-register-var\n @opindex Wvolatile-register-var"}, {"sha": "e75f2fa76fccb555fe30a05ae40a42f158ebfa71", "filename": "gcc/gimple-ssa-warn-alloca.c", "status": "added", "additions": 524, "deletions": 0, "changes": 524, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/adc577c558a4b2e3b604511927cce17039d57c11/gcc%2Fgimple-ssa-warn-alloca.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/adc577c558a4b2e3b604511927cce17039d57c11/gcc%2Fgimple-ssa-warn-alloca.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-ssa-warn-alloca.c?ref=adc577c558a4b2e3b604511927cce17039d57c11", "patch": "@@ -0,0 +1,524 @@\n+/* Warn on problematic uses of alloca and variable length arrays.\n+   Copyright (C) 2016 Free Software Foundation, Inc.\n+   Contributed by Aldy Hernandez <aldyh@redhat.com>.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it under\n+the terms of the GNU General Public License as published by the Free\n+Software Foundation; either version 3, or (at your option) any later\n+version.\n+\n+GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING3.  If not see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#include \"config.h\"\n+#include \"system.h\"\n+#include \"coretypes.h\"\n+#include \"backend.h\"\n+#include \"tree.h\"\n+#include \"gimple.h\"\n+#include \"tree-pass.h\"\n+#include \"ssa.h\"\n+#include \"gimple-pretty-print.h\"\n+#include \"diagnostic-core.h\"\n+#include \"fold-const.h\"\n+#include \"gimple-iterator.h\"\n+#include \"tree-ssa.h\"\n+#include \"params.h\"\n+#include \"tree-cfg.h\"\n+#include \"calls.h\"\n+#include \"cfgloop.h\"\n+#include \"intl.h\"\n+\n+const pass_data pass_data_walloca = {\n+  GIMPLE_PASS,\n+  \"walloca\",\n+  OPTGROUP_NONE,\n+  TV_NONE,\n+  PROP_cfg, // properties_required\n+  0,\t    // properties_provided\n+  0,\t    // properties_destroyed\n+  0,\t    // properties_start\n+  0,\t    // properties_finish\n+};\n+\n+class pass_walloca : public gimple_opt_pass\n+{\n+public:\n+  pass_walloca (gcc::context *ctxt)\n+    : gimple_opt_pass(pass_data_walloca, ctxt), first_time_p (false)\n+  {}\n+  opt_pass *clone () { return new pass_walloca (m_ctxt); }\n+  void set_pass_param (unsigned int n, bool param)\n+    {\n+      gcc_assert (n == 0);\n+      first_time_p = param;\n+    }\n+  virtual bool gate (function *);\n+  virtual unsigned int execute (function *);\n+\n+ private:\n+  // Set to TRUE the first time we run this pass on a function.\n+  bool first_time_p;\n+};\n+\n+bool\n+pass_walloca::gate (function *fun ATTRIBUTE_UNUSED)\n+{\n+  // The first time this pass is called, it is called before\n+  // optimizations have been run and range information is unavailable,\n+  // so we can only perform strict alloca checking.\n+  if (first_time_p)\n+    return warn_alloca != 0;\n+\n+  return warn_alloca_limit > 0 || warn_vla_limit > 0;\n+}\n+\n+// Possible problematic uses of alloca.\n+enum alloca_type {\n+  // Alloca argument is within known bounds that are appropriate.\n+  ALLOCA_OK,\n+\n+  // Alloca argument is KNOWN to have a value that is too large.\n+  ALLOCA_BOUND_DEFINITELY_LARGE,\n+\n+  // Alloca argument may be too large.\n+  ALLOCA_BOUND_MAYBE_LARGE,\n+\n+  // Alloca argument is bounded but of an indeterminate size.\n+  ALLOCA_BOUND_UNKNOWN,\n+\n+  // Alloca argument was casted from a signed integer.\n+  ALLOCA_CAST_FROM_SIGNED,\n+\n+  // Alloca appears in a loop.\n+  ALLOCA_IN_LOOP,\n+\n+  // Alloca argument is 0.\n+  ALLOCA_ARG_IS_ZERO,\n+\n+  // Alloca call is unbounded.  That is, there is no controlling\n+  // predicate for its argument.\n+  ALLOCA_UNBOUNDED\n+};\n+\n+// Type of an alloca call with its corresponding limit, if applicable.\n+struct alloca_type_and_limit {\n+  enum alloca_type type;\n+  // For ALLOCA_BOUND_MAYBE_LARGE and ALLOCA_BOUND_DEFINITELY_LARGE\n+  // types, this field indicates the assumed limit if known or\n+  // integer_zero_node if unknown.  For any other alloca types, this\n+  // field is undefined.\n+  wide_int limit;\n+  alloca_type_and_limit ();\n+  alloca_type_and_limit (enum alloca_type type,\n+\t\t\t wide_int i) : type(type), limit(i) { }\n+  alloca_type_and_limit (enum alloca_type type) : type(type) { }\n+};\n+\n+// NOTE: When we get better range info, this entire function becomes\n+// irrelevant, as it should be possible to get range info for an SSA\n+// name at any point in the program.\n+//\n+// We have a few heuristics up our sleeve to determine if a call to\n+// alloca() is within bounds.  Try them out and return the type of\n+// alloca call with its assumed limit (if applicable).\n+//\n+// Given a known argument (ARG) to alloca() and an EDGE (E)\n+// calculating said argument, verify that the last statement in the BB\n+// in E->SRC is a gate comparing ARG to an acceptable bound for\n+// alloca().  See examples below.\n+//\n+// If set, ARG_CASTED is the possible unsigned argument to which ARG\n+// was casted to.  This is to handle cases where the controlling\n+// predicate is looking at a casted value, not the argument itself.\n+//    arg_casted = (size_t) arg;\n+//    if (arg_casted < N)\n+//      goto bb3;\n+//    else\n+//      goto bb5;\n+//\n+// MAX_SIZE is WARN_ALLOCA= adjusted for VLAs.  It is the maximum size\n+// in bytes we allow for arg.\n+\n+static struct alloca_type_and_limit\n+alloca_call_type_by_arg (tree arg, tree arg_casted, edge e, unsigned max_size)\n+{\n+  basic_block bb = e->src;\n+  gimple_stmt_iterator gsi = gsi_last_bb (bb);\n+  gimple *last = gsi_stmt (gsi);\n+  if (!last || gimple_code (last) != GIMPLE_COND)\n+    return alloca_type_and_limit (ALLOCA_UNBOUNDED);\n+\n+  enum tree_code cond_code = gimple_cond_code (last);\n+  if (e->flags & EDGE_TRUE_VALUE)\n+    ;\n+  else if (e->flags & EDGE_FALSE_VALUE)\n+    cond_code = invert_tree_comparison (cond_code, false);\n+  else\n+    return alloca_type_and_limit (ALLOCA_UNBOUNDED);\n+\n+  // Check for:\n+  //   if (ARG .COND. N)\n+  //     goto <bb 3>;\n+  //   else\n+  //     goto <bb 4>;\n+  //   <bb 3>:\n+  //   alloca(ARG);\n+  if ((cond_code == LE_EXPR\n+       || cond_code == LT_EXPR\n+       || cond_code == GT_EXPR\n+       || cond_code == GE_EXPR)\n+      && (gimple_cond_lhs (last) == arg\n+\t  || gimple_cond_lhs (last) == arg_casted))\n+    {\n+      if (TREE_CODE (gimple_cond_rhs (last)) == INTEGER_CST)\n+\t{\n+\t  tree rhs = gimple_cond_rhs (last);\n+\t  int tst = wi::cmpu (wi::to_widest (rhs), max_size);\n+\t  if ((cond_code == LT_EXPR && tst == -1)\n+\t      || (cond_code == LE_EXPR && (tst == -1 || tst == 0)))\n+\t    return alloca_type_and_limit (ALLOCA_OK);\n+\t  else\n+\t    {\n+\t      // Let's not get too specific as to how large the limit\n+\t      // may be.  Someone's clearly an idiot when things\n+\t      // degrade into \"if (N > Y) alloca(N)\".\n+\t      if (cond_code == GT_EXPR || cond_code == GE_EXPR)\n+\t\trhs = integer_zero_node;\n+\t      return alloca_type_and_limit (ALLOCA_BOUND_MAYBE_LARGE, rhs);\n+\t    }\n+\t}\n+      else\n+\treturn alloca_type_and_limit (ALLOCA_BOUND_UNKNOWN);\n+    }\n+\n+  // Similarly, but check for a comparison with an unknown LIMIT.\n+  //   if (LIMIT .COND. ARG)\n+  //     alloca(arg);\n+  //\n+  //   Where LIMIT has a bound of unknown range.\n+  //\n+  // Note: All conditions of the form (ARG .COND. XXXX) where covered\n+  // by the previous check above, so we only need to look for (LIMIT\n+  // .COND. ARG) here.\n+  tree limit = gimple_cond_lhs (last);\n+  if ((gimple_cond_rhs (last) == arg\n+       || gimple_cond_rhs (last) == arg_casted)\n+      && TREE_CODE (limit) == SSA_NAME)\n+    {\n+      wide_int min, max;\n+      value_range_type range_type = get_range_info (limit, &min, &max);\n+\n+      if (range_type == VR_UNDEFINED || range_type == VR_VARYING)\n+\treturn alloca_type_and_limit (ALLOCA_BOUND_UNKNOWN);\n+\n+      // ?? It looks like the above `if' is unnecessary, as we never\n+      // get any VR_RANGE or VR_ANTI_RANGE here.  If we had a range\n+      // for LIMIT, I suppose we would have taken care of it in\n+      // alloca_call_type(), or handled above where we handle (ARG .COND. N).\n+      //\n+      // If this ever triggers, we should probably figure out why and\n+      // handle it, though it is likely to be just an ALLOCA_UNBOUNDED.\n+      return alloca_type_and_limit (ALLOCA_UNBOUNDED);\n+    }\n+\n+  return alloca_type_and_limit (ALLOCA_UNBOUNDED);\n+}\n+\n+// Return TRUE if SSA's definition is a cast from a signed type.\n+// If so, set *INVALID_CASTED_TYPE to the signed type.\n+\n+static bool\n+cast_from_signed_p (tree ssa, tree *invalid_casted_type)\n+{\n+  gimple *def = SSA_NAME_DEF_STMT (ssa);\n+  if (def\n+      && !gimple_nop_p (def)\n+      && gimple_assign_cast_p (def)\n+      && !TYPE_UNSIGNED (TREE_TYPE (gimple_assign_rhs1 (def))))\n+    {\n+      *invalid_casted_type = TREE_TYPE (gimple_assign_rhs1 (def));\n+      return true;\n+    }\n+  return false;\n+}\n+\n+// Return TRUE if X has a maximum range of MAX, basically covering the\n+// entire domain, in which case it's no range at all.\n+\n+static bool\n+is_max (tree x, wide_int max)\n+{\n+  return wi::max_value (TREE_TYPE (x)) == max;\n+}\n+\n+// Analyze the alloca call in STMT and return the alloca type with its\n+// corresponding limit (if applicable).  IS_VLA is set if the alloca\n+// call is really a BUILT_IN_ALLOCA_WITH_ALIGN, signifying a VLA.\n+//\n+// If the alloca call may be too large because of a cast from a signed\n+// type to an unsigned type, set *INVALID_CASTED_TYPE to the\n+// problematic signed type.\n+\n+static struct alloca_type_and_limit\n+alloca_call_type (gimple *stmt, bool is_vla, tree *invalid_casted_type)\n+{\n+  gcc_assert (gimple_alloca_call_p (stmt));\n+  tree len = gimple_call_arg (stmt, 0);\n+  tree len_casted = NULL;\n+  wide_int min, max;\n+  struct alloca_type_and_limit ret = alloca_type_and_limit (ALLOCA_UNBOUNDED);\n+\n+  gcc_assert (!is_vla || warn_vla_limit > 0);\n+  gcc_assert (is_vla || warn_alloca_limit > 0);\n+\n+  // Adjust warn_alloca_max_size for VLAs, by taking the underlying\n+  // type into account.\n+  unsigned HOST_WIDE_INT max_size;\n+  if (is_vla)\n+    max_size = (unsigned HOST_WIDE_INT) warn_vla_limit;\n+  else\n+    max_size = (unsigned HOST_WIDE_INT) warn_alloca_limit;\n+\n+  // Check for the obviously bounded case.\n+  if (TREE_CODE (len) == INTEGER_CST)\n+    {\n+      if (tree_to_uhwi (len) > max_size)\n+\treturn alloca_type_and_limit (ALLOCA_BOUND_DEFINITELY_LARGE, len);\n+      if (integer_zerop (len))\n+\treturn alloca_type_and_limit (ALLOCA_ARG_IS_ZERO);\n+      ret = alloca_type_and_limit (ALLOCA_OK);\n+    }\n+  // Check the range info if available.\n+  else if (value_range_type range_type = get_range_info (len, &min, &max))\n+    {\n+      if (range_type == VR_RANGE)\n+\t{\n+\t  if (wi::leu_p (max, max_size))\n+\t    ret = alloca_type_and_limit (ALLOCA_OK);\n+\t  else\n+\t    {\n+\t      // A cast may have created a range we don't care\n+\t      // about.  For instance, a cast from 16-bit to\n+\t      // 32-bit creates a range of 0..65535, even if there\n+\t      // is not really a determinable range in the\n+\t      // underlying code.  In this case, look through the\n+\t      // cast at the original argument, and fall through\n+\t      // to look at other alternatives.\n+\t      //\n+\t      // We only look at through the cast when its from\n+\t      // unsigned to unsigned, otherwise we may risk\n+\t      // looking at SIGNED_INT < N, which is clearly not\n+\t      // what we want.  In this case, we'd be interested\n+\t      // in a VR_RANGE of [0..N].\n+\t      //\n+\t      // Note: None of this is perfect, and should all go\n+\t      // away with better range information.  But it gets\n+\t      // most of the cases.\n+\t      gimple *def = SSA_NAME_DEF_STMT (len);\n+\t      if (gimple_assign_cast_p (def)\n+\t\t  && TYPE_UNSIGNED (TREE_TYPE (gimple_assign_rhs1 (def))))\n+\n+\t\t{\n+\t\t  len_casted = gimple_assign_rhs1 (def);\n+\t\t  range_type = get_range_info (len_casted, &min, &max);\n+\t\t}\n+\t      // An unknown range or a range of the entire domain is\n+\t      // really no range at all.\n+\t      if (range_type == VR_VARYING\n+\t\t  || (!len_casted && is_max (len, max))\n+\t\t  || (len_casted && is_max (len_casted, max)))\n+\t\t{\n+\t\t  // Fall through.\n+\t\t}\n+\t      else if (range_type != VR_VARYING)\n+\t\treturn\n+\t\t  alloca_type_and_limit (ALLOCA_BOUND_MAYBE_LARGE, max);\n+\t    }\n+\t}\n+      else if (range_type == VR_ANTI_RANGE)\n+\t{\n+\t  // There may be some wrapping around going on.  Catch it\n+\t  // with this heuristic.  Hopefully, this VR_ANTI_RANGE\n+\t  // nonsense will go away, and we won't have to catch the\n+\t  // sign conversion problems with this crap.\n+\t  if (cast_from_signed_p (len, invalid_casted_type))\n+\t    return alloca_type_and_limit (ALLOCA_CAST_FROM_SIGNED);\n+\t}\n+      // No easily determined range and try other things.\n+    }\n+\n+  // If we couldn't find anything, try a few heuristics for things we\n+  // can easily determine.  Check these misc cases but only accept\n+  // them if all predecessors have a known bound.\n+  basic_block bb = gimple_bb (stmt);\n+  if (ret.type == ALLOCA_UNBOUNDED)\n+    {\n+      ret.type = ALLOCA_OK;\n+      for (unsigned ix = 0; ix < EDGE_COUNT (bb->preds); ix++)\n+\t{\n+\t  gcc_assert (!len_casted || TYPE_UNSIGNED (TREE_TYPE (len_casted)));\n+\t  ret = alloca_call_type_by_arg (len, len_casted,\n+\t\t\t\t\t EDGE_PRED (bb, ix), max_size);\n+\t  if (ret.type != ALLOCA_OK)\n+\t    return ret;\n+\t}\n+    }\n+\n+  return ret;\n+}\n+\n+// Return TRUE if the alloca call in STMT is in a loop, otherwise\n+// return FALSE. As an exception, ignore alloca calls for VLAs that\n+// occur in a loop since those will be cleaned up when they go out of\n+// scope.\n+\n+static bool\n+in_loop_p (bool is_vla, gimple *stmt)\n+{\n+  basic_block bb = gimple_bb (stmt);\n+  if (bb->loop_father\n+      && bb->loop_father->header != ENTRY_BLOCK_PTR_FOR_FN (cfun))\n+    {\n+      // Do not warn on VLAs occurring in a loop, since VLAs are\n+      // guaranteed to be cleaned up when they go out of scope.\n+      // That is, there is a corresponding __builtin_stack_restore\n+      // at the end of the scope in which the VLA occurs.\n+      tree fndecl = gimple_call_fn (stmt);\n+      while (TREE_CODE (fndecl) == ADDR_EXPR)\n+\tfndecl = TREE_OPERAND (fndecl, 0);\n+      if (DECL_BUILT_IN_CLASS (fndecl) == BUILT_IN_NORMAL\n+\t  && is_vla\n+\t  && DECL_FUNCTION_CODE (fndecl) == BUILT_IN_ALLOCA_WITH_ALIGN)\n+\treturn false;\n+\n+      return true;\n+    }\n+  return false;\n+}\n+\n+unsigned int\n+pass_walloca::execute (function *fun)\n+{\n+  basic_block bb;\n+  FOR_EACH_BB_FN (bb, fun)\n+    {\n+      for (gimple_stmt_iterator si = gsi_start_bb (bb); !gsi_end_p (si);\n+\t   gsi_next (&si))\n+\t{\n+\t  gimple *stmt = gsi_stmt (si);\n+\t  location_t loc = gimple_location (stmt);\n+\n+\t  if (!gimple_alloca_call_p (stmt))\n+\t    continue;\n+\t  gcc_assert (gimple_call_num_args (stmt) >= 1);\n+\n+\t  bool is_vla = gimple_alloca_call_p (stmt)\n+\t    && gimple_call_alloca_for_var_p (as_a <gcall *> (stmt));\n+\n+\t  // Strict mode whining for VLAs is handled by the front-end,\n+\t  // so we can safely ignore this case.  Also, ignore VLAs if\n+\t  // the user doesn't care about them.\n+\t  if (is_vla\n+\t      && (warn_vla > 0 || !warn_vla_limit))\n+\t    continue;\n+\n+\t  if (!is_vla && (warn_alloca || !warn_alloca_limit))\n+\t    {\n+\t      if (warn_alloca)\n+\t\twarning_at (loc, OPT_Walloca, G_(\"use of %<alloca%>\"));\n+\t      continue;\n+\t    }\n+\n+\t  tree invalid_casted_type = NULL;\n+\t  struct alloca_type_and_limit t\n+\t    = alloca_call_type (stmt, is_vla, &invalid_casted_type);\n+\n+\t  // Even if we think the alloca call is OK, make sure it's\n+\t  // not in a loop.\n+\t  if (t.type == ALLOCA_OK && in_loop_p (is_vla, stmt))\n+\t    t = alloca_type_and_limit (ALLOCA_IN_LOOP);\n+\n+\t  enum opt_code wcode\n+\t    = is_vla ? OPT_Wvla_larger_than_ : OPT_Walloca_larger_than_;\n+\t  char buff[WIDE_INT_MAX_PRECISION / 4 + 4];\n+\t  switch (t.type)\n+\t    {\n+\t    case ALLOCA_OK:\n+\t      break;\n+\t    case ALLOCA_BOUND_MAYBE_LARGE:\n+\t      if (warning_at (loc, wcode,\n+\t\t\t      is_vla ? G_(\"argument to variable-length array \"\n+\t\t\t\t\t  \"may be too large\")\n+\t\t\t      : G_(\"argument to %<alloca%> may be too large\"))\n+\t\t  && t.limit != integer_zero_node)\n+\t\t{\n+\t\t  print_decu (t.limit, buff);\n+\t\t  inform (loc, G_(\"limit is %u bytes, but argument \"\n+\t\t\t\t  \"may be as large as %s\"),\n+\t\t\t  is_vla ? warn_vla_limit : warn_alloca_limit, buff);\n+\t\t}\n+\t      break;\n+\t    case ALLOCA_BOUND_DEFINITELY_LARGE:\n+\t      if (warning_at (loc, wcode,\n+\t\t\t      is_vla ? G_(\"argument to variable-length array \"\n+\t\t\t\t\t  \"is too large\")\n+\t\t\t      : G_(\"argument to %<alloca%> is too large\"))\n+\t\t  && t.limit != integer_zero_node)\n+\t\t{\n+\t\t  print_decu (t.limit, buff);\n+\t\t  inform (loc, G_(\"limit is %u bytes, but argument is %s\"),\n+\t\t\t  is_vla ? warn_vla_limit : warn_alloca_limit, buff);\n+\t\t}\n+\t      break;\n+\t    case ALLOCA_BOUND_UNKNOWN:\n+\t      warning_at (loc, wcode,\n+\t\t\t  is_vla ? G_(\"variable-length array bound is unknown\")\n+\t\t\t  : G_(\"%<alloca%> bound is unknown\"));\n+\t      break;\n+\t    case ALLOCA_UNBOUNDED:\n+\t      warning_at (loc, wcode,\n+\t\t\t  is_vla ? G_(\"unbounded use of variable-length array\")\n+\t\t\t  : G_(\"unbounded use of %<alloca%>\"));\n+\t      break;\n+\t    case ALLOCA_IN_LOOP:\n+\t      gcc_assert (!is_vla);\n+\t      warning_at (loc, wcode, G_(\"use of %<alloca%> within a loop\"));\n+\t      break;\n+\t    case ALLOCA_CAST_FROM_SIGNED:\n+\t      gcc_assert (invalid_casted_type != NULL_TREE);\n+\t      warning_at (loc, wcode,\n+\t\t\t  is_vla ? G_(\"argument to variable-length array \"\n+\t\t\t\t      \"may be too large due to \"\n+\t\t\t\t      \"conversion from %qT to %qT\")\n+\t\t\t  : G_(\"argument to %<alloca%> may be too large \"\n+\t\t\t       \"due to conversion from %qT to %qT\"),\n+\t\t\t  invalid_casted_type, size_type_node);\n+\t      break;\n+\t    case ALLOCA_ARG_IS_ZERO:\n+\t      warning_at (loc, wcode,\n+\t\t\t  is_vla ? G_(\"argument to variable-length array \"\n+\t\t\t\t      \"is zero\")\n+\t\t\t  : G_(\"argument to %<alloca%> is zero\"));\n+\t      break;\n+\t    default:\n+\t      gcc_unreachable ();\n+\t    }\n+\t}\n+    }\n+  return 0;\n+}\n+\n+gimple_opt_pass *\n+make_pass_walloca (gcc::context *ctxt)\n+{\n+  return new pass_walloca (ctxt);\n+}"}, {"sha": "51e9aa7eba4af631a7d2c8c8a0ece08ad94e5543", "filename": "gcc/passes.def", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/adc577c558a4b2e3b604511927cce17039d57c11/gcc%2Fpasses.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/adc577c558a4b2e3b604511927cce17039d57c11/gcc%2Fpasses.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpasses.def?ref=adc577c558a4b2e3b604511927cce17039d57c11", "patch": "@@ -44,6 +44,7 @@ along with GCC; see the file COPYING3.  If not see\n   NEXT_PASS (pass_expand_omp);\n   NEXT_PASS (pass_build_cgraph_edges);\n   NEXT_PASS (pass_sprintf_length, false);\n+  NEXT_PASS (pass_walloca, /*strict_mode_p=*/true);\n   TERMINATE_PASS_LIST (all_lowering_passes)\n \n   /* Interprocedural optimization passes.  */\n@@ -251,6 +252,7 @@ along with GCC; see the file COPYING3.  If not see\n       NEXT_PASS (pass_laddress);\n       NEXT_PASS (pass_lim);\n       NEXT_PASS (pass_split_crit_edges);\n+      NEXT_PASS (pass_walloca, false);\n       NEXT_PASS (pass_pre);\n       NEXT_PASS (pass_sink_code);\n       NEXT_PASS (pass_sancov);"}, {"sha": "34a20c3e6a900df5beee53ad345f42205b6223d6", "filename": "gcc/testsuite/gcc.dg/Walloca-1.c", "status": "added", "additions": 63, "deletions": 0, "changes": 63, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/adc577c558a4b2e3b604511927cce17039d57c11/gcc%2Ftestsuite%2Fgcc.dg%2FWalloca-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/adc577c558a4b2e3b604511927cce17039d57c11/gcc%2Ftestsuite%2Fgcc.dg%2FWalloca-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2FWalloca-1.c?ref=adc577c558a4b2e3b604511927cce17039d57c11", "patch": "@@ -0,0 +1,63 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-Walloca-larger-than=2000 -O2\" } */\n+\n+#define alloca __builtin_alloca\n+\n+typedef __SIZE_TYPE__ size_t;\n+extern size_t strlen(const char *);\n+\n+extern void useit (char *);\n+\n+int num;\n+\n+void foo1 (size_t len, size_t len2, size_t len3)\n+{\n+  int i;\n+\n+  for (i=0; i < 123; ++i)\n+    {\n+      char *s = alloca (566);\t/* { dg-warning \"'alloca' within a loop\" } */\n+      useit (s);\n+    }\n+\n+  char *s = alloca (123);\n+  useit (s);\t\t\t// OK, constant argument to alloca\n+\n+  s = alloca (num);\t\t// { dg-warning \"large due to conversion\" }\n+  useit (s);\n+\n+  s = alloca(90000);\t\t/* { dg-warning \"is too large\" } */\n+  useit (s);\n+\n+  if (len < 2000)\n+    {\n+      s = alloca(len);\t\t// OK, bounded\n+      useit (s);\n+    }\n+\n+  if (len + len2 < 2000)\t// OK, bounded\n+    {\n+      s = alloca(len + len2);\n+      useit (s);\n+    }\n+\n+  if (len3 <= 2001)\n+    {\n+      s = alloca(len3);\t\t/* { dg-warning \"may be too large\" } */\n+      useit(s);\n+    }\n+}\n+\n+void foo2 (__SIZE_TYPE__ len)\n+{\n+  // Test that a direct call to __builtin_alloca_with_align is not confused\n+  // with a VLA.\n+  void *p = __builtin_alloca_with_align (len, 8); // { dg-warning \"unbounded use of 'alloca'\" }\n+  useit (p);\n+}\n+\n+void foo3 (unsigned char a)\n+{\n+  if (a == 0)\n+    useit (__builtin_alloca (a)); // { dg-warning \"argument to 'alloca' is zero\" }\n+}"}, {"sha": "69549fcc0d507e064649bdb04317e1cb2307e11a", "filename": "gcc/testsuite/gcc.dg/Walloca-10.c", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/adc577c558a4b2e3b604511927cce17039d57c11/gcc%2Ftestsuite%2Fgcc.dg%2FWalloca-10.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/adc577c558a4b2e3b604511927cce17039d57c11/gcc%2Ftestsuite%2Fgcc.dg%2FWalloca-10.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2FWalloca-10.c?ref=adc577c558a4b2e3b604511927cce17039d57c11", "patch": "@@ -0,0 +1,25 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-Walloca-larger-than=2000 -O2\" } */\n+\n+// Test when the conditionals are incorrectly reversed.\n+\n+void f (void *);\n+void foo (__SIZE_TYPE__ len)\n+{\n+  void *p;\n+  if (len < 500)\n+    p = __builtin_malloc (len);\n+  else\n+    p = __builtin_alloca (len); // { dg-warning \"argument to .alloca. may be too large\" }\n+  f (p);\n+}\n+\n+void bar (__SIZE_TYPE__ len)\n+{\n+  void *p;\n+  if (len > 500)\n+    p = __builtin_alloca (len); // { dg-warning \"argument to .alloca. may be too large\" }\n+  else\n+    p = __builtin_malloc (len);\n+  f (p);\n+}"}, {"sha": "284b34e323f39aa4f2ad9b5388fb7f8bd08987e5", "filename": "gcc/testsuite/gcc.dg/Walloca-2.c", "status": "added", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/adc577c558a4b2e3b604511927cce17039d57c11/gcc%2Ftestsuite%2Fgcc.dg%2FWalloca-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/adc577c558a4b2e3b604511927cce17039d57c11/gcc%2Ftestsuite%2Fgcc.dg%2FWalloca-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2FWalloca-2.c?ref=adc577c558a4b2e3b604511927cce17039d57c11", "patch": "@@ -0,0 +1,40 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-Walloca-larger-than=2000 -O2\" } */\n+\n+void f (void *);\n+\n+void\n+g1 (int n)\n+{\n+  void *p;\n+  if (n > 0 && n < 2000)\n+    p = __builtin_alloca (n);\n+  else\n+    p = __builtin_malloc (n);\n+  f (p);\n+}\n+\n+void\n+g2 (int n)\n+{\n+  void *p;\n+  if (n < 2000)\n+    p = __builtin_alloca (n); // { dg-warning \"large due to conversion\" }\n+  else\n+    p = __builtin_malloc (n);\n+  f (p);\n+}\n+\n+void\n+g3 (int n)\n+{\n+  void *p;\n+  if (n > 0 && n < 3000)\n+    {\n+      p = __builtin_alloca (n); // { dg-warning \"'alloca' may be too large\" }\n+      // { dg-message \"note:.*argument may be as large as 2999\" \"note\" { target *-*-* } 34 }\n+    }\n+  else\n+    p = __builtin_malloc (n);\n+  f (p);\n+}"}, {"sha": "5345197eba874292f8a850e5bd9c1466c727649d", "filename": "gcc/testsuite/gcc.dg/Walloca-3.c", "status": "added", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/adc577c558a4b2e3b604511927cce17039d57c11/gcc%2Ftestsuite%2Fgcc.dg%2FWalloca-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/adc577c558a4b2e3b604511927cce17039d57c11/gcc%2Ftestsuite%2Fgcc.dg%2FWalloca-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2FWalloca-3.c?ref=adc577c558a4b2e3b604511927cce17039d57c11", "patch": "@@ -0,0 +1,33 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-Walloca-larger-than=2000 -O2\" } */\n+\n+void f (void *);\n+\n+__SIZE_TYPE__ LIMIT;\n+\n+// Warn when there is an alloca bound, but it is an unknown bound.\n+\n+void\n+g1 (__SIZE_TYPE__ n)\n+{\n+  void *p;\n+  if (n < LIMIT)\n+    p = __builtin_alloca (n); // { dg-warning \"'alloca' bound is unknown\" }\n+  else\n+    p = __builtin_malloc (n);\n+  f (p);\n+}\n+\n+// Similar to the above, but do not get confused by the upcast.\n+\n+unsigned short SHORT_LIMIT;\n+void\n+g2 (unsigned short n)\n+{\n+  void *p;\n+  if (n < SHORT_LIMIT)\n+    p = __builtin_alloca (n); // { dg-warning \"'alloca' bound is unknown\" }\n+  else\n+    p = __builtin_malloc (n);\n+  f (p);\n+}"}, {"sha": "a559534acaa7b908090d8448f0c23f2a3435eb5e", "filename": "gcc/testsuite/gcc.dg/Walloca-4.c", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/adc577c558a4b2e3b604511927cce17039d57c11/gcc%2Ftestsuite%2Fgcc.dg%2FWalloca-4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/adc577c558a4b2e3b604511927cce17039d57c11/gcc%2Ftestsuite%2Fgcc.dg%2FWalloca-4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2FWalloca-4.c?ref=adc577c558a4b2e3b604511927cce17039d57c11", "patch": "@@ -0,0 +1,16 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-Walloca-larger-than=5000 -O2\" } */\n+\n+ char *\n+ _i18n_number_rewrite (char *w, char *rear_ptr)\n+{\n+\n+  char *src;\n+ _Bool \n+      use_alloca = (((rear_ptr - w) * sizeof (char)) < 4096U);\n+ if (use_alloca)\n+    src = (char *) __builtin_alloca ((rear_ptr - w) * sizeof (char));\n+  else\n+    src = (char *) __builtin_malloc ((rear_ptr - w) * sizeof (char));\n+  return src;\n+}"}, {"sha": "5ed1171e0d30fcfd826489c7ec68a0618019598f", "filename": "gcc/testsuite/gcc.dg/Walloca-5.c", "status": "added", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/adc577c558a4b2e3b604511927cce17039d57c11/gcc%2Ftestsuite%2Fgcc.dg%2FWalloca-5.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/adc577c558a4b2e3b604511927cce17039d57c11/gcc%2Ftestsuite%2Fgcc.dg%2FWalloca-5.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2FWalloca-5.c?ref=adc577c558a4b2e3b604511927cce17039d57c11", "patch": "@@ -0,0 +1,32 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-Walloca-larger-than=123 -O2\" } */\n+/* { dg-xfail-if \"Currently broken but Andrew's work should fix this\" { *-*-* } } */\n+\n+/* The argument to alloca ends up having a range of 0..MAXINT(32bits),\n+   so we think we have a range because of the upcast.  Consequently,\n+   we warn with \"alloca may be too large\", but we should technically\n+   warn with \"unbounded use of alloca\".\n+\n+   We currently drill through casts to figure this stuff out, but we\n+   get confused because it's not just a cast.  It's a cast, plus a\n+   multiply.\n+\n+   <bb 2>:\n+  # RANGE [0, 4294967295] NONZERO 4294967295\n+  _1 = (long unsigned int) something_4(D);\n+  # RANGE [0, 34359738360] NONZERO 34359738360\n+  _2 = _1 * 8;\n+  _3 = __builtin_alloca (_2);\n+\n+  I don't know whether it's even worth such fine-grained warnings.\n+  Perhaps we should generically warn everywhere with \"alloca may be\n+  too large\".\n+\n+  I'm hoping that this particular case will be easier to diagnose with\n+  Andrew's work.  */\n+\n+void useit(void *);\n+void foobar(unsigned int something)\n+{\n+  useit(__builtin_alloca (something * sizeof (const char *))); // { dg-warning \"unbounded use of alloca\" \"\" { xfail *-*-* } }\n+}"}, {"sha": "b4d8d41b062bd9e284bfa2483e1c794045605f57", "filename": "gcc/testsuite/gcc.dg/Walloca-6.c", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/adc577c558a4b2e3b604511927cce17039d57c11/gcc%2Ftestsuite%2Fgcc.dg%2FWalloca-6.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/adc577c558a4b2e3b604511927cce17039d57c11/gcc%2Ftestsuite%2Fgcc.dg%2FWalloca-6.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2FWalloca-6.c?ref=adc577c558a4b2e3b604511927cce17039d57c11", "patch": "@@ -0,0 +1,11 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-Walloca-larger-than=256 -O2\" } */\n+/* { dg-xfail-if \"Currently broken but Andrew's work should fix this\" { *-*-* } } */\n+\n+void f (void*);\n+void g (__SIZE_TYPE__ n)\n+{\n+  // No warning on this case.  Range is easily determinable.\n+  if (n > 0 && n < 256)\n+    f (__builtin_alloca (n));\n+}"}, {"sha": "d6581a5b20b20a87d238fea8a52dc9069dbb70be", "filename": "gcc/testsuite/gcc.dg/Walloca-7.c", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/adc577c558a4b2e3b604511927cce17039d57c11/gcc%2Ftestsuite%2Fgcc.dg%2FWalloca-7.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/adc577c558a4b2e3b604511927cce17039d57c11/gcc%2Ftestsuite%2Fgcc.dg%2FWalloca-7.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2FWalloca-7.c?ref=adc577c558a4b2e3b604511927cce17039d57c11", "patch": "@@ -0,0 +1,17 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-Walloca -O0\" } */\n+\n+extern void f(void *);\n+\n+void foo(void)\n+{\n+  // Test that strict -Walloca works even without optimization.\n+  f (__builtin_alloca(500)); // { dg-warning \"use of 'alloca'\" }\n+}\n+\n+void bar(void)\n+{\n+  // Test that we warn on alloca() calls, not just __builtin_alloca calls.\n+  extern void *alloca(__SIZE_TYPE__);\n+  f (alloca (123)); // { dg-warning \"use of 'alloca'\" }\n+}"}, {"sha": "a4a120485cd7a33559b66b5eaa75ca6b56f56904", "filename": "gcc/testsuite/gcc.dg/Walloca-8.c", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/adc577c558a4b2e3b604511927cce17039d57c11/gcc%2Ftestsuite%2Fgcc.dg%2FWalloca-8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/adc577c558a4b2e3b604511927cce17039d57c11/gcc%2Ftestsuite%2Fgcc.dg%2FWalloca-8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2FWalloca-8.c?ref=adc577c558a4b2e3b604511927cce17039d57c11", "patch": "@@ -0,0 +1,12 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-Walloca-larger-than=2000 -O2\" } */\n+\n+void *p;\n+void\n+foo (__SIZE_TYPE__ len)\n+{\n+  if (len < 2000 / sizeof (void *))\n+    p = __builtin_alloca (len * sizeof (void *));\n+  else\n+    p = __builtin_malloc (len * sizeof (void *));\n+}"}, {"sha": "c67d9d632553ed1e8c970ab3338920d4e26c0a59", "filename": "gcc/testsuite/gcc.dg/Walloca-9.c", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/adc577c558a4b2e3b604511927cce17039d57c11/gcc%2Ftestsuite%2Fgcc.dg%2FWalloca-9.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/adc577c558a4b2e3b604511927cce17039d57c11/gcc%2Ftestsuite%2Fgcc.dg%2FWalloca-9.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2FWalloca-9.c?ref=adc577c558a4b2e3b604511927cce17039d57c11", "patch": "@@ -0,0 +1,19 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-Walloca-larger-than=5000 -O2\" } */\n+\n+extern void useit(char *);\n+\n+int\n+foobar (unsigned short length)\n+{\n+  char *pbuf;\n+  __SIZE_TYPE__ size = (__SIZE_TYPE__) length;\n+\n+  if (size < 4032)\n+    pbuf = (char *) __builtin_alloca(size);\n+  else\n+    pbuf = (char *) __builtin_malloc (size);\n+\n+  useit(pbuf);\n+  return 0;\n+}"}, {"sha": "384c930c9951d1c66387ddc610e80d7e4afa7b31", "filename": "gcc/testsuite/gcc.dg/Wvla-1.c", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/adc577c558a4b2e3b604511927cce17039d57c11/gcc%2Ftestsuite%2Fgcc.dg%2FWvla-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/adc577c558a4b2e3b604511927cce17039d57c11/gcc%2Ftestsuite%2Fgcc.dg%2FWvla-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2FWvla-1.c?ref=adc577c558a4b2e3b604511927cce17039d57c11", "patch": "@@ -0,0 +1,24 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-Wvla-larger-than=100 -O2\" } */\n+\n+typedef __SIZE_TYPE__ size_t;\n+\n+extern void useit (char *);\n+\n+int num;\n+\n+void test_vlas (size_t num)\n+{\n+  char str2[num];\t\t/* { dg-warning \"unbounded use\" } */\n+  useit(str2);\n+\n+  num = 98;\n+  for (int i=0; i < 1234; ++i) {\n+    char str[num];\t        // OK, VLA in a loop, but it is a\n+\t\t\t\t// known size *AND* the compiler takes\n+\t\t\t\t// care of cleaning up between\n+\t\t\t\t// iterations with\n+\t\t\t\t// __builtin_stack_restore.\n+    useit(str);\n+  }\n+}"}, {"sha": "96814dcaac08cbc02d127a2571c667f4e5c8da23", "filename": "gcc/testsuite/gcc.dg/Wvla-2.c", "status": "added", "additions": 70, "deletions": 0, "changes": 70, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/adc577c558a4b2e3b604511927cce17039d57c11/gcc%2Ftestsuite%2Fgcc.dg%2FWvla-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/adc577c558a4b2e3b604511927cce17039d57c11/gcc%2Ftestsuite%2Fgcc.dg%2FWvla-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2FWvla-2.c?ref=adc577c558a4b2e3b604511927cce17039d57c11", "patch": "@@ -0,0 +1,70 @@\n+/* { dg-do compile } */\n+/* { dg-require-effective-target stdint_types } */\n+/* { dg-options \"-O2 -Wvla-larger-than=40\" } */\n+\n+#include <stdint.h>\n+\n+void f0 (void *);\n+void\n+f1 (__SIZE_TYPE__ a)\n+{\n+  if (a <= 10)\n+    {\n+      // 10 * 4 bytes = 40: OK!\n+      uint32_t x[a];\n+      f0 (x);\n+    }\n+}\n+\n+void\n+f2 (__SIZE_TYPE__ a)\n+{\n+  if (a <= 11)\n+    {\n+      // 11 * 4 bytes = 44: Not OK.\n+      uint32_t x[a]; // { dg-warning \"array may be too large\" }\n+      // { dg-message \"note:.*argument may be as large as 44\" \"note\" { target *-*-* } 25 }\n+      f0 (x);\n+    }\n+}\n+\n+void\n+f3 (__SIZE_TYPE__ a, __SIZE_TYPE__ b)\n+{\n+  if (a <= 5 && b <= 3)\n+    {\n+      // 5 * 3 * 4 bytes = 60: Not OK.\n+      uint32_t x[a][b]; // { dg-warning \"array may be too large\" }\n+      f0 (x);\n+    }\n+}\n+\n+void\n+f4 (__SIZE_TYPE__ a, __SIZE_TYPE__ b)\n+{\n+  if (a <= 5 && b <= 2)\n+    {\n+      // 5 * 2 * 4 bytes = 40 bytes: OK!\n+      uint32_t x[a][b];\n+      f0 (x);\n+    }\n+}\n+\n+void\n+f5 (__SIZE_TYPE__ len)\n+{\n+  // Test that a direct call to __builtin_alloca_with_align is not\n+  // confused with a VLA.\n+  void *p = __builtin_alloca_with_align (len, 8);\n+  f0 (p);\n+}\n+\n+void\n+f6 (unsigned stuff)\n+{\n+  int n = 7000;\n+  do {\n+    char a[n]; // { dg-warning \"variable-length array is too large\" }\n+    f0 (a);\n+  } while (stuff--);\n+}"}, {"sha": "5124476d71fe40e57ab17bf4ee54d900b3da04a2", "filename": "gcc/testsuite/gcc.dg/Wvla-3.c", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/adc577c558a4b2e3b604511927cce17039d57c11/gcc%2Ftestsuite%2Fgcc.dg%2FWvla-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/adc577c558a4b2e3b604511927cce17039d57c11/gcc%2Ftestsuite%2Fgcc.dg%2FWvla-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2FWvla-3.c?ref=adc577c558a4b2e3b604511927cce17039d57c11", "patch": "@@ -0,0 +1,12 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-Walloca -O2\" } */\n+\n+// Make sure we don't warn on VLA with -Walloca.\n+\n+void f (void*);\n+\n+void h1 (unsigned n)\n+{\n+  int a [n];\n+  f (a);\n+}"}, {"sha": "dda693b213eba1fe55e8572fb87d671b84c34632", "filename": "gcc/tree-pass.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/adc577c558a4b2e3b604511927cce17039d57c11/gcc%2Ftree-pass.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/adc577c558a4b2e3b604511927cce17039d57c11/gcc%2Ftree-pass.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-pass.h?ref=adc577c558a4b2e3b604511927cce17039d57c11", "patch": "@@ -472,6 +472,7 @@ extern simple_ipa_opt_pass *make_pass_ipa_oacc_kernels (gcc::context *ctxt);\n extern gimple_opt_pass *make_pass_gen_hsail (gcc::context *ctxt);\n extern gimple_opt_pass *make_pass_warn_nonnull_compare (gcc::context *ctxt);\n extern gimple_opt_pass *make_pass_sprintf_length (gcc::context *ctxt);\n+extern gimple_opt_pass *make_pass_walloca (gcc::context *ctxt);\n \n /* IPA Passes */\n extern simple_ipa_opt_pass *make_pass_ipa_lower_emutls (gcc::context *ctxt);"}]}