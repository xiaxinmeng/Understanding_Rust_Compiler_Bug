{"sha": "1ca6a74f8900cd8e18a5603eaea2c16f4f0d1e36", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MWNhNmE3NGY4OTAwY2Q4ZTE4YTU2MDNlYWVhMmMxNmY0ZjBkMWUzNg==", "commit": {"author": {"name": "Paul Thomas", "email": "pault@gcc.gnu.org", "date": "2017-02-20T09:42:48Z"}, "committer": {"name": "Paul Thomas", "email": "pault@gcc.gnu.org", "date": "2017-02-20T09:42:48Z"}, "message": "re PR fortran/79434 ([submodules] separate module procedure breaks encapsulation)\n\n2017-02-20  Paul Thomas  <pault@gcc.gnu.org>\n\n\tPR fortran/79434\n\t* parse.c (check_component, parse_union): Whitespace.\n\t(set_syms_host_assoc): For a derived type, check if the module\n\tin which it was declared is one of the submodule ancestors. If\n\tit is, make the components public. Otherwise, reset attribute\n\t'host_assoc' and set 'use-assoc' so that encapsulation is\n\tpreserved.\n\n2017-02-20  Paul Thomas  <pault@gcc.gnu.org>\n\n\tPR fortran/79434\n\t* gfortran.dg/submodule_25.f08 : New test.\n\nFrom-SVN: r245595", "tree": {"sha": "b5e680edda864662c08e9de5a6a1487bc94cf1d6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b5e680edda864662c08e9de5a6a1487bc94cf1d6"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/1ca6a74f8900cd8e18a5603eaea2c16f4f0d1e36", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1ca6a74f8900cd8e18a5603eaea2c16f4f0d1e36", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1ca6a74f8900cd8e18a5603eaea2c16f4f0d1e36", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1ca6a74f8900cd8e18a5603eaea2c16f4f0d1e36/comments", "author": null, "committer": null, "parents": [{"sha": "8f712b76904c9e495d16817fa93f8edde4c1f0cd", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8f712b76904c9e495d16817fa93f8edde4c1f0cd", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8f712b76904c9e495d16817fa93f8edde4c1f0cd"}], "stats": {"total": 89, "additions": 83, "deletions": 6}, "files": [{"sha": "78d40afea290d8446b5f2278fb9126c04a545aa8", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1ca6a74f8900cd8e18a5603eaea2c16f4f0d1e36/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1ca6a74f8900cd8e18a5603eaea2c16f4f0d1e36/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=1ca6a74f8900cd8e18a5603eaea2c16f4f0d1e36", "patch": "@@ -1,3 +1,13 @@\n+2017-02-20  Paul Thomas  <pault@gcc.gnu.org>\n+\n+\tPR fortran/79434\n+\t* parse.c (check_component, parse_union): Whitespace.\n+\t(set_syms_host_assoc): For a derived type, check if the module\n+\tin which it was declared is one of the submodule ancestors. If\n+\tit is, make the components public. Otherwise, reset attribute\n+\t'host_assoc' and set 'use-assoc' so that encapsulation is\n+\tpreserved.\n+\n 2017-02-19  Paul Thomas  <pault@gcc.gnu.org>\n \n \tPR fortran/79447"}, {"sha": "3809ec1855608bba3f656e8c2991a25e366f8164", "filename": "gcc/fortran/parse.c", "status": "modified", "additions": 25, "deletions": 6, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1ca6a74f8900cd8e18a5603eaea2c16f4f0d1e36/gcc%2Ffortran%2Fparse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1ca6a74f8900cd8e18a5603eaea2c16f4f0d1e36/gcc%2Ffortran%2Fparse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fparse.c?ref=1ca6a74f8900cd8e18a5603eaea2c16f4f0d1e36", "patch": "@@ -2917,7 +2917,7 @@ check_component (gfc_symbol *sym, gfc_component *c, gfc_component **lockp,\n       coarray = true;\n       sym->attr.coarray_comp = 1;\n     }\n- \n+\n   if (c->ts.type == BT_DERIVED && c->ts.u.derived->attr.coarray_comp\n       && !c->attr.pointer)\n     {\n@@ -3081,7 +3081,7 @@ parse_union (void)\n           /* Add a component to the union for each map. */\n           if (!gfc_add_component (un, gfc_new_block->name, &c))\n             {\n-              gfc_internal_error (\"failed to create map component '%s'\", \n+              gfc_internal_error (\"failed to create map component '%s'\",\n                   gfc_new_block->name);\n               reject_statement ();\n               return;\n@@ -5809,23 +5809,42 @@ static void\n set_syms_host_assoc (gfc_symbol *sym)\n {\n   gfc_component *c;\n+  const char dot[2] = \".\";\n+  char parent1[GFC_MAX_SYMBOL_LEN + 1];\n+  char parent2[GFC_MAX_SYMBOL_LEN + 1];\n \n   if (sym == NULL)\n     return;\n \n   if (sym->attr.module_procedure)\n     sym->attr.external = 0;\n \n-/*  sym->attr.access = ACCESS_PUBLIC;  */\n-\n   sym->attr.use_assoc = 0;\n   sym->attr.host_assoc = 1;\n   sym->attr.used_in_submodule =1;\n \n   if (sym->attr.flavor == FL_DERIVED)\n     {\n-      for (c = sym->components; c; c = c->next)\n-\tc->attr.access = ACCESS_PUBLIC;\n+      /* Derived types with PRIVATE components that are declared in\n+\t modules other than the parent module must not be changed to be\n+\t PUBLIC. The 'use-assoc' attribute must be reset so that the\n+\t test in symbol.c(gfc_find_component) works correctly. This is\n+\t not necessary for PRIVATE symbols since they are not read from\n+\t the module.  */\n+      memset(parent1, '\\0', sizeof(parent1));\n+      memset(parent2, '\\0', sizeof(parent2));\n+      strcpy (parent1, gfc_new_block->name);\n+      strcpy (parent2, sym->module);\n+      if (strcmp (strtok (parent1, dot), strtok (parent2, dot)) == 0)\n+\t{\n+\t  for (c = sym->components; c; c = c->next)\n+\t    c->attr.access = ACCESS_PUBLIC;\n+\t}\n+      else\n+\t{\n+\t  sym->attr.use_assoc = 1;\n+\t  sym->attr.host_assoc = 0;\n+\t}\n     }\n }\n "}, {"sha": "fab1612270a1c969fed080ee524b7380145d28d0", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1ca6a74f8900cd8e18a5603eaea2c16f4f0d1e36/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1ca6a74f8900cd8e18a5603eaea2c16f4f0d1e36/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=1ca6a74f8900cd8e18a5603eaea2c16f4f0d1e36", "patch": "@@ -1,3 +1,8 @@\n+2017-02-20  Paul Thomas  <pault@gcc.gnu.org>\n+\n+\tPR fortran/79434\n+\t* gfortran.dg/submodule_25.f08 : New test.\n+\n 2017-02-19  Paul Thomas  <pault@gcc.gnu.org>\n \n \tPR fortran/79447"}, {"sha": "0581ce3ca7645ccf939250c50d81acf6dbff0e57", "filename": "gcc/testsuite/gfortran.dg/submodule_25.f08", "status": "added", "additions": 43, "deletions": 0, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1ca6a74f8900cd8e18a5603eaea2c16f4f0d1e36/gcc%2Ftestsuite%2Fgfortran.dg%2Fsubmodule_25.f08", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1ca6a74f8900cd8e18a5603eaea2c16f4f0d1e36/gcc%2Ftestsuite%2Fgfortran.dg%2Fsubmodule_25.f08", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fsubmodule_25.f08?ref=1ca6a74f8900cd8e18a5603eaea2c16f4f0d1e36", "patch": "@@ -0,0 +1,43 @@\n+! { dg-do compile }\n+! Test the fix for PR79434 in which the PRIVATE attribute of the\n+! component 'i' of the derived type 't' was not respected in the\n+! submodule 's_u'.\n+!\n+! Contributed by Reinhold Bader  <Bader@lrz.de>\n+!\n+module mod_encap_t\n+  implicit none\n+  type, public :: t\n+    private\n+    integer :: i\n+  end type\n+end module\n+module mod_encap_u\n+  use mod_encap_t\n+  type, public, extends(t) :: u\n+    private\n+    integer :: j\n+  end type\n+  interface\n+    module subroutine fu(this)\n+      type(u), intent(inout) :: this\n+    end subroutine\n+  end interface\n+end module\n+submodule (mod_encap_u) s_u\n+contains\n+  module procedure fu\n+!   the following statement should cause the compiler to\n+!   abort, pointing out a private component defined in\n+!   a USED module is being accessed\n+    this%i = 2 ! { dg-error \"is a PRIVATE component\" }\n+    this%j = 1\n+    write(*, *) 'FAIL'\n+  end procedure\n+end submodule\n+program p\n+  use mod_encap_u\n+  implicit none\n+  type(u) :: x\n+  call fu(x)\n+end program"}]}