{"sha": "94e7f906ca5c73fb79d21ec54733e9e75a96c2b4", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTRlN2Y5MDZjYTVjNzNmYjc5ZDIxZWM1NDczM2U5ZTc1YTk2YzJiNA==", "commit": {"author": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2019-10-10T07:07:30Z"}, "committer": {"name": "Jakub Jelinek", "email": "jakub@gcc.gnu.org", "date": "2019-10-10T07:07:30Z"}, "message": "c-common.h (c_omp_check_context_selector, [...]): Declare.\n\nc-family/\n\t* c-common.h (c_omp_check_context_selector,\n\tc_omp_get_context_selector): Declare.\n\t* c-omp.c (c_omp_declare_simd_clauses_to_numbers): Fix spelling\n\tin diagnostic message.\n\t(c_omp_check_context_selector, c_omp_get_context_selector): New\n\tfunctions.\n\t* c-attribs.c (c_common_attribute_table): Add \"omp declare variant\"\n\tattribute.\n\t(handle_omp_declare_variant_attribute): New function.\nc/\n\t* c-parser.c (c_parser_omp_all_clauses): Add NESTED_P argument, if\n\ttrue, terminate processing on closing paren and don't skip to end of\n\tpragma line.\n\t(c_parser_omp_declare_simd): Handle also declare variant.\n\t(omp_construct_selectors, omp_device_selectors,\n\tomp_implementation_selectors, omp_user_selectors): New variables.\n\t(c_parser_omp_context_selector,\n\tc_parser_omp_context_selector_specification,\n\tc_finish_omp_declare_variant): New functions.\n\t(c_finish_omp_declare_simd): Handle both declare simd and\n\tdeclare variant.\n\t(c_parser_omp_declare): Handle declare variant.\ncp/\n\t* parser.h (struct cp_omp_declare_simd_data): Add variant_p member.\n\t* parser.c (cp_ensure_no_omp_declare_simd): Handle both declare simd\n\tand declare variant.\n\t(cp_parser_oacc_all_clauses): Formatting fix.\n\t(cp_parser_omp_all_clauses): Add NESTED_P argument, if true, terminate\n\tprocessing on closing paren and don't skip to end of pragma line.\n\t(cp_parser_omp_declare_simd): Add VARIANT_P argument.  Handle also\n\tdeclare variant.\n\t(omp_construct_selectors, omp_device_selectors,\n\tomp_implementation_selectors, omp_user_selectors): New variables.\n\t(cp_parser_omp_context_selector,\n\tcp_parser_omp_context_selector_specification,\n\tcp_finish_omp_declare_variant): New functions.\n\t(cp_parser_late_parsing_omp_declare_simd): Handle also declare variant.\n\t(cp_parser_omp_declare): Handle declare variant.\ntestsuite/\n\t* c-c++-common/gomp/declare-variant-1.c: New test.\n\t* c-c++-common/gomp/declare-variant-2.c: New test.\n\t* c-c++-common/gomp/declare-variant-3.c: New test.\n\t* g++.dg/gomp/this-1.C: Adjust for diagnostic message spelling fix.\n\t* gcc.dg/gomp/declare-variant-1.c: New test.\n\t* gcc.dg/gomp/declare-variant-2.c: New test.\n\nFrom-SVN: r276789", "tree": {"sha": "5f686002d13f0905df1681a9408a9d96b23ee258", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5f686002d13f0905df1681a9408a9d96b23ee258"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/94e7f906ca5c73fb79d21ec54733e9e75a96c2b4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/94e7f906ca5c73fb79d21ec54733e9e75a96c2b4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/94e7f906ca5c73fb79d21ec54733e9e75a96c2b4", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/94e7f906ca5c73fb79d21ec54733e9e75a96c2b4/comments", "author": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "6ea20bd0218fd6386cef3701befa653cee6f1101", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6ea20bd0218fd6386cef3701befa653cee6f1101", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6ea20bd0218fd6386cef3701befa653cee6f1101"}], "stats": {"total": 1641, "additions": 1570, "deletions": 71}, "files": [{"sha": "598fea4f8583e29f5cb47a298e26e03c3ee36b3d", "filename": "gcc/c-family/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94e7f906ca5c73fb79d21ec54733e9e75a96c2b4/gcc%2Fc-family%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94e7f906ca5c73fb79d21ec54733e9e75a96c2b4/gcc%2Fc-family%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2FChangeLog?ref=94e7f906ca5c73fb79d21ec54733e9e75a96c2b4", "patch": "@@ -1,3 +1,15 @@\n+2019-10-10  Jakub Jelinek  <jakub@redhat.com>\n+\n+\t* c-common.h (c_omp_check_context_selector,\n+\tc_omp_get_context_selector): Declare.\n+\t* c-omp.c (c_omp_declare_simd_clauses_to_numbers): Fix spelling\n+\tin diagnostic message.\n+\t(c_omp_check_context_selector, c_omp_get_context_selector): New\n+\tfunctions.\n+\t* c-attribs.c (c_common_attribute_table): Add \"omp declare variant\"\n+\tattribute.\n+\t(handle_omp_declare_variant_attribute): New function.\n+\n 2019-10-09  Martin Sebor  <msebor@redhat.com>\n \n \tPR tree-optimization/90879"}, {"sha": "917d483bcbfd872a19f53d4b014708985211d4bd", "filename": "gcc/c-family/c-attribs.c", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94e7f906ca5c73fb79d21ec54733e9e75a96c2b4/gcc%2Fc-family%2Fc-attribs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94e7f906ca5c73fb79d21ec54733e9e75a96c2b4/gcc%2Fc-family%2Fc-attribs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc-attribs.c?ref=94e7f906ca5c73fb79d21ec54733e9e75a96c2b4", "patch": "@@ -140,6 +140,8 @@ static tree handle_warn_unused_attribute (tree *, tree, tree, int, bool *);\n static tree handle_returns_nonnull_attribute (tree *, tree, tree, int, bool *);\n static tree handle_omp_declare_simd_attribute (tree *, tree, tree, int,\n \t\t\t\t\t       bool *);\n+static tree handle_omp_declare_variant_attribute (tree *, tree, tree, int,\n+\t\t\t\t\t\t  bool *);\n static tree handle_simd_attribute (tree *, tree, tree, int, bool *);\n static tree handle_omp_declare_target_attribute (tree *, tree, tree, int,\n \t\t\t\t\t\t bool *);\n@@ -442,6 +444,8 @@ const struct attribute_spec c_common_attribute_table[] =\n \t\t\t      handle_returns_nonnull_attribute, NULL },\n   { \"omp declare simd\",       0, -1, true,  false, false, false,\n \t\t\t      handle_omp_declare_simd_attribute, NULL },\n+  { \"omp declare variant\",    0, -1, true,  false, false, false,\n+\t\t\t      handle_omp_declare_variant_attribute, NULL },\n   { \"simd\",\t\t      0, 1, true,  false, false, false,\n \t\t\t      handle_simd_attribute, NULL },\n   { \"omp declare target\",     0, -1, true, false, false, false,\n@@ -3064,6 +3068,15 @@ handle_omp_declare_simd_attribute (tree *, tree, tree, int, bool *)\n   return NULL_TREE;\n }\n \n+/* Handle an \"omp declare variant\" attribute; arguments as in\n+   struct attribute_spec.handler.  */\n+\n+static tree\n+handle_omp_declare_variant_attribute (tree *, tree, tree, int, bool *)\n+{\n+  return NULL_TREE;\n+}\n+\n /* Handle a \"simd\" attribute.  */\n \n static tree"}, {"sha": "eabe689120fed38b7b49bb48a3e19cd92eac2e14", "filename": "gcc/c-family/c-common.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94e7f906ca5c73fb79d21ec54733e9e75a96c2b4/gcc%2Fc-family%2Fc-common.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94e7f906ca5c73fb79d21ec54733e9e75a96c2b4/gcc%2Fc-family%2Fc-common.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc-common.h?ref=94e7f906ca5c73fb79d21ec54733e9e75a96c2b4", "patch": "@@ -1189,6 +1189,8 @@ extern tree c_omp_declare_simd_clauses_to_numbers (tree, tree);\n extern void c_omp_declare_simd_clauses_to_decls (tree, tree);\n extern bool c_omp_predefined_variable (tree);\n extern enum omp_clause_default_kind c_omp_predetermined_sharing (tree);\n+extern tree c_omp_check_context_selector (location_t, tree);\n+extern tree c_omp_get_context_selector (tree, const char *, const char *);\n \n /* Return next tree in the chain for chain_next walking of tree nodes.  */\n static inline tree"}, {"sha": "542625604ad336b8bb74d56651a90ba11548064f", "filename": "gcc/c-family/c-omp.c", "status": "modified", "additions": 132, "deletions": 2, "changes": 134, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94e7f906ca5c73fb79d21ec54733e9e75a96c2b4/gcc%2Fc-family%2Fc-omp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94e7f906ca5c73fb79d21ec54733e9e75a96c2b4/gcc%2Fc-family%2Fc-omp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc-omp.c?ref=94e7f906ca5c73fb79d21ec54733e9e75a96c2b4", "patch": "@@ -2011,7 +2011,7 @@ c_omp_declare_simd_clauses_to_numbers (tree parms, tree clauses)\n \t  if (arg == NULL_TREE)\n \t    {\n \t      error_at (OMP_CLAUSE_LOCATION (c),\n-\t\t\t\"%qD is not an function argument\", decl);\n+\t\t\t\"%qD is not a function argument\", decl);\n \t      continue;\n \t    }\n \t  OMP_CLAUSE_DECL (c) = build_int_cst (integer_type_node, idx);\n@@ -2026,7 +2026,7 @@ c_omp_declare_simd_clauses_to_numbers (tree parms, tree clauses)\n \t      if (arg == NULL_TREE)\n \t\t{\n \t\t  error_at (OMP_CLAUSE_LOCATION (c),\n-\t\t\t    \"%qD is not an function argument\", decl);\n+\t\t\t    \"%qD is not a function argument\", decl);\n \t\t  continue;\n \t\t}\n \t      OMP_CLAUSE_LINEAR_STEP (c)\n@@ -2120,3 +2120,133 @@ c_omp_predetermined_sharing (tree decl)\n \n   return OMP_CLAUSE_DEFAULT_UNSPECIFIED;\n }\n+\n+/* Diagnose errors in an OpenMP context selector, return CTX if\n+   it is correct or error_mark_node otherwise.  */\n+\n+tree\n+c_omp_check_context_selector (location_t loc, tree ctx)\n+{\n+  /* Each trait-set-selector-name can only be specified once.\n+     There are just 4 set names.  */\n+  for (tree t1 = ctx; t1; t1 = TREE_CHAIN (t1))\n+    for (tree t2 = TREE_CHAIN (t1); t2; t2 = TREE_CHAIN (t2))\n+      if (TREE_PURPOSE (t1) == TREE_PURPOSE (t2))\n+\t{\n+\t  error_at (loc, \"selector set %qs specified more than once\",\n+\t  \t    IDENTIFIER_POINTER (TREE_PURPOSE (t1)));\n+\t  return error_mark_node;\n+\t}\n+  for (tree t = ctx; t; t = TREE_CHAIN (t))\n+    {\n+      /* Each trait-selector-name can only be specified once.  */\n+      if (list_length (TREE_VALUE (t)) < 5)\n+\t{\n+\t  for (tree t1 = TREE_VALUE (t); t1; t1 = TREE_CHAIN (t1))\n+\t    for (tree t2 = TREE_CHAIN (t1); t2; t2 = TREE_CHAIN (t2))\n+\t      if (TREE_PURPOSE (t1) == TREE_PURPOSE (t2))\n+\t\t{\n+\t\t  error_at (loc,\n+\t\t\t    \"selector %qs specified more than once in set %qs\",\n+\t\t\t    IDENTIFIER_POINTER (TREE_PURPOSE (t1)),\n+\t\t\t    IDENTIFIER_POINTER (TREE_PURPOSE (t)));\n+\t\t  return error_mark_node;\n+\t\t}\n+\t}\n+      else\n+\t{\n+\t  hash_set<tree> pset;\n+\t  for (tree t1 = TREE_VALUE (t); t1; t1 = TREE_CHAIN (t1))\n+\t    if (pset.add (TREE_PURPOSE (t1)))\n+\t      {\n+\t\terror_at (loc,\n+\t\t\t  \"selector %qs specified more than once in set %qs\",\n+\t\t\t  IDENTIFIER_POINTER (TREE_PURPOSE (t1)),\n+\t\t\t  IDENTIFIER_POINTER (TREE_PURPOSE (t)));\n+\t\treturn error_mark_node;\n+\t      }\n+\t}\n+\n+      static const char *const kind[] = {\n+\t\"host\", \"nohost\", \"cpu\", \"gpu\", \"fpga\", \"any\", NULL };\n+      static const char *const vendor[] = {\n+\t\"amd\", \"arm\", \"bsc\", \"cray\", \"fujitsu\", \"gnu\", \"ibm\", \"intel\",\n+\t\"llvm\", \"pgi\", \"ti\", \"unknown\", NULL };\n+      static const char *const extension[] = { NULL };\n+      static const char *const atomic_default_mem_order[] = {\n+\t\"seq_cst\", \"relaxed\", \"acq_rel\", NULL };\n+      struct known_properties { const char *set; const char *selector;\n+\t\t\t\tconst char *const *props; };\n+      known_properties props[] = {\n+\t{ \"device\", \"kind\", kind },\n+\t{ \"implementation\", \"vendor\", vendor },\n+\t{ \"implementation\", \"extension\", extension },\n+\t{ \"implementation\", \"atomic_default_mem_order\",\n+\t  atomic_default_mem_order } };\n+      for (tree t1 = TREE_VALUE (t); t1; t1 = TREE_CHAIN (t1))\n+\tfor (unsigned i = 0; i < ARRAY_SIZE (props); i++)\n+\t  if (!strcmp (IDENTIFIER_POINTER (TREE_PURPOSE (t1)),\n+\t\t\t\t\t   props[i].selector)\n+\t      && !strcmp (IDENTIFIER_POINTER (TREE_PURPOSE (t)),\n+\t\t\t\t\t      props[i].set))\n+\t    for (tree t2 = TREE_VALUE (t1); t2; t2 = TREE_CHAIN (t2))\n+\t      for (unsigned j = 0; ; j++)\n+\t\t{\n+\t\t  if (props[i].props[j] == NULL)\n+\t\t    {\n+\t\t      if (!strcmp (IDENTIFIER_POINTER (TREE_PURPOSE (t2)),\n+\t\t\t\t   \" score\"))\n+\t\t\tbreak;\n+\t\t      if (props[i].props == atomic_default_mem_order)\n+\t\t\t{\n+\t\t\t  error_at (loc,\n+\t\t\t\t    \"incorrect property %qs of %qs selector\",\n+\t\t\t\t    IDENTIFIER_POINTER (TREE_PURPOSE (t2)),\n+\t\t\t\t    \"atomic_default_mem_order\");\n+\t\t\t  return error_mark_node;\n+\t\t\t}\n+\t\t      else\n+\t\t\twarning_at (loc, 0,\n+\t\t\t\t    \"unknown property %qs of %qs selector\",\n+\t\t\t\t    IDENTIFIER_POINTER (TREE_PURPOSE (t2)),\n+\t\t\t\t    props[i].selector);\n+\t\t      break;\n+\t\t    }\n+\t\t  else if (!strcmp (IDENTIFIER_POINTER (TREE_PURPOSE (t2)),\n+\t\t\t\t    props[i].props[j]))\n+\t\t    {\n+\t\t      if (props[i].props == atomic_default_mem_order\n+\t\t\t  && t2 != TREE_VALUE (t1))\n+\t\t\t{\n+\t\t\t  tree t3 = TREE_VALUE (t1);\n+\t\t\t  if (!strcmp (IDENTIFIER_POINTER (TREE_PURPOSE (t3)),\n+\t\t\t\t       \" score\")\n+\t\t\t      && t2 == TREE_CHAIN (TREE_VALUE (t1)))\n+\t\t\t    break;\n+\t\t\t  error_at (loc,\n+\t\t\t\t    \"%qs selector must have a single property\",\n+\t\t\t\t    \"atomic_default_mem_order\");\n+\t\t\t  return error_mark_node;\n+\t\t\t}\n+\t\t      break;\n+\t\t    }\n+\t\t}\n+    }\n+  return ctx;\n+}\n+\n+/* From context selector CTX, return trait-selector with name SEL in\n+   trait-selector-set with name SET if any, or NULL_TREE if not found.  */\n+\n+tree\n+c_omp_get_context_selector (tree ctx, const char *set, const char *sel)\n+{\n+  tree setid = get_identifier (set);\n+  tree selid = get_identifier (sel);\n+  for (tree t1 = ctx; t1; t1 = TREE_CHAIN (t1))\n+    if (TREE_PURPOSE (t1) == setid)\n+      for (tree t2 = TREE_VALUE (t1); t2; t2 = TREE_CHAIN (t2))\n+\tif (TREE_PURPOSE (t2) == selid)\n+\t  return t2;\n+  return NULL_TREE;\n+}"}, {"sha": "fa1001cc9cb533dddf88db68998163d8125ab29f", "filename": "gcc/c/ChangeLog", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94e7f906ca5c73fb79d21ec54733e9e75a96c2b4/gcc%2Fc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94e7f906ca5c73fb79d21ec54733e9e75a96c2b4/gcc%2Fc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc%2FChangeLog?ref=94e7f906ca5c73fb79d21ec54733e9e75a96c2b4", "patch": "@@ -1,3 +1,18 @@\n+2019-10-10  Jakub Jelinek  <jakub@redhat.com>\n+\n+\t* c-parser.c (c_parser_omp_all_clauses): Add NESTED_P argument, if\n+\ttrue, terminate processing on closing paren and don't skip to end of\n+\tpragma line.\n+\t(c_parser_omp_declare_simd): Handle also declare variant.\n+\t(omp_construct_selectors, omp_device_selectors,\n+\tomp_implementation_selectors, omp_user_selectors): New variables.\n+\t(c_parser_omp_context_selector,\n+\tc_parser_omp_context_selector_specification,\n+\tc_finish_omp_declare_variant): New functions.\n+\t(c_finish_omp_declare_simd): Handle both declare simd and\n+\tdeclare variant.\n+\t(c_parser_omp_declare): Handle declare variant.\n+\n 2019-10-02  Joseph Myers  <joseph@codesourcery.com>\n \n \t* c-parser.c (c_parser_asm_statement): Handle CPP_SCOPE like two"}, {"sha": "2daaee80d85b31a17f7bf94b4bc70d4e6c6fc409", "filename": "gcc/c/c-parser.c", "status": "modified", "additions": 505, "deletions": 40, "changes": 545, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94e7f906ca5c73fb79d21ec54733e9e75a96c2b4/gcc%2Fc%2Fc-parser.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94e7f906ca5c73fb79d21ec54733e9e75a96c2b4/gcc%2Fc%2Fc-parser.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc%2Fc-parser.c?ref=94e7f906ca5c73fb79d21ec54733e9e75a96c2b4", "patch": "@@ -15213,11 +15213,15 @@ c_parser_oacc_all_clauses (c_parser *parser, omp_clause_mask mask,\n }\n \n /* Parse all OpenMP clauses.  The set clauses allowed by the directive\n-   is a bitmask in MASK.  Return the list of clauses found.  */\n+   is a bitmask in MASK.  Return the list of clauses found.\n+   FINISH_P set if c_finish_omp_clauses should be called.\n+   NESTED_P set if clauses should be terminated by closing paren instead\n+   of end of pragma.  */\n \n static tree\n c_parser_omp_all_clauses (c_parser *parser, omp_clause_mask mask,\n-\t\t\t  const char *where, bool finish_p = true)\n+\t\t\t  const char *where, bool finish_p = true,\n+\t\t\t  bool nested_p = false)\n {\n   tree clauses = NULL;\n   bool first = true;\n@@ -15229,6 +15233,9 @@ c_parser_omp_all_clauses (c_parser *parser, omp_clause_mask mask,\n       const char *c_name;\n       tree prev = clauses;\n \n+      if (nested_p && c_parser_next_token_is (parser, CPP_CLOSE_PAREN))\n+\tbreak;\n+\n       if (!first && c_parser_next_token_is (parser, CPP_COMMA))\n \tc_parser_consume_token (parser);\n \n@@ -15513,7 +15520,8 @@ c_parser_omp_all_clauses (c_parser *parser, omp_clause_mask mask,\n     }\n \n  saw_error:\n-  c_parser_skip_to_pragma_eol (parser);\n+  if (!nested_p)\n+    c_parser_skip_to_pragma_eol (parser);\n \n   if (finish_p)\n     {\n@@ -18919,7 +18927,11 @@ c_parser_omp_target (c_parser *parser, enum pragma_context context, bool *if_p)\n }\n \n /* OpenMP 4.0:\n-   # pragma omp declare simd declare-simd-clauses[optseq] new-line  */\n+   # pragma omp declare simd declare-simd-clauses[optseq] new-line\n+\n+   OpenMP 5.0:\n+   # pragma omp declare variant (identifier) match(context-selector) new-line\n+   */\n \n #define OMP_DECLARE_SIMD_CLAUSE_MASK\t\t\t\t\\\n \t( (OMP_CLAUSE_MASK_1 << PRAGMA_OMP_CLAUSE_SIMDLEN)\t\\\n@@ -18932,6 +18944,12 @@ c_parser_omp_target (c_parser *parser, enum pragma_context context, bool *if_p)\n static void\n c_parser_omp_declare_simd (c_parser *parser, enum pragma_context context)\n {\n+  c_token *token = c_parser_peek_token (parser);\n+  gcc_assert (token->type == CPP_NAME);\n+  tree kind = token->value;\n+  gcc_assert (strcmp (IDENTIFIER_POINTER (kind), \"simd\") == 0\n+\t      || strcmp (IDENTIFIER_POINTER (kind), \"variant\") == 0);\n+\n   auto_vec<c_token> clauses;\n   while (c_parser_next_token_is_not (parser, CPP_PRAGMA_EOL))\n     {\n@@ -18949,17 +18967,14 @@ c_parser_omp_declare_simd (c_parser *parser, enum pragma_context context)\n \n   while (c_parser_next_token_is (parser, CPP_PRAGMA))\n     {\n-      if (c_parser_peek_token (parser)->pragma_kind\n-\t  != PRAGMA_OMP_DECLARE\n+      if (c_parser_peek_token (parser)->pragma_kind != PRAGMA_OMP_DECLARE\n \t  || c_parser_peek_2nd_token (parser)->type != CPP_NAME\n-\t  || strcmp (IDENTIFIER_POINTER\n-\t\t\t\t(c_parser_peek_2nd_token (parser)->value),\n-\t\t     \"simd\") != 0)\n+\t  || c_parser_peek_2nd_token (parser)->value != kind)\n \t{\n-\t  c_parser_error (parser,\n-\t\t\t  \"%<#pragma omp declare simd%> must be followed by \"\n-\t\t\t  \"function declaration or definition or another \"\n-\t\t\t  \"%<#pragma omp declare simd%>\");\n+\t  error (\"%<#pragma omp declare %s%> must be followed by \"\n+\t\t \"function declaration or definition or another \"\n+\t\t \"%<#pragma omp declare %s%>\",\n+\t\t IDENTIFIER_POINTER (kind), IDENTIFIER_POINTER (kind));\n \t  return;\n \t}\n       c_parser_consume_pragma (parser);\n@@ -19007,8 +19022,9 @@ c_parser_omp_declare_simd (c_parser *parser, enum pragma_context context)\n     case pragma_struct:\n     case pragma_param:\n     case pragma_stmt:\n-      c_parser_error (parser, \"%<#pragma omp declare simd%> must be followed by \"\n-\t\t\t      \"function declaration or definition\");\n+      error (\"%<#pragma omp declare %s%> must be followed by \"\n+\t     \"function declaration or definition\",\n+\t     IDENTIFIER_POINTER (kind));\n       break;\n     case pragma_compound:\n       if (c_parser_next_token_is (parser, CPP_KEYWORD)\n@@ -19034,38 +19050,470 @@ c_parser_omp_declare_simd (c_parser *parser, enum pragma_context context)\n \t\t\t\t\t NULL, clauses);\n \t  break;\n \t}\n-      c_parser_error (parser, \"%<#pragma omp declare simd%> must be followed by \"\n-\t\t\t      \"function declaration or definition\");\n+      error (\"%<#pragma omp declare %s%> must be followed by \"\n+\t     \"function declaration or definition\",\n+\t     IDENTIFIER_POINTER (kind));\n       break;\n     default:\n       gcc_unreachable ();\n     }\n }\n \n-/* Finalize #pragma omp declare simd clauses after FNDECL has been parsed,\n-   and put that into \"omp declare simd\" attribute.  */\n+static const char *const omp_construct_selectors[] = {\n+  \"simd\", \"target\", \"teams\", \"parallel\", \"for\", NULL };\n+static const char *const omp_device_selectors[] = {\n+  \"kind\", \"isa\", \"arch\", NULL };\n+static const char *const omp_implementation_selectors[] = {\n+  \"vendor\", \"extension\", \"atomic_default_mem_order\", \"unified_address\",\n+  \"unified_shared_memory\", \"dynamic_allocators\", \"reverse_offload\", NULL };\n+static const char *const omp_user_selectors[] = {\n+  \"condition\", NULL };\n+\n+/* OpenMP 5.0:\n+\n+   trait-selector:\n+     trait-selector-name[([trait-score:]trait-property[,trait-property[,...]])]\n+\n+   trait-score:\n+     score(score-expression)  */\n+\n+static tree\n+c_parser_omp_context_selector (c_parser *parser, tree set, tree parms)\n+{\n+  tree ret = NULL_TREE;\n+  do\n+    {\n+      tree selector;\n+      if (c_parser_next_token_is (parser, CPP_KEYWORD)\n+\t  || c_parser_next_token_is (parser, CPP_NAME))\n+\tselector = c_parser_peek_token (parser)->value;\n+      else\n+\t{\n+\t  c_parser_error (parser, \"expected trait selector name\");\n+\t  return error_mark_node;\n+\t}\n+\n+      tree properties = NULL_TREE;\n+      const char *const *selectors = NULL;\n+      bool allow_score = true;\n+      bool allow_user = false;\n+      int property_limit = 0;\n+      enum { CTX_PROPERTY_NONE, CTX_PROPERTY_USER, CTX_PROPERTY_IDLIST,\n+\t     CTX_PROPERTY_EXPR, CTX_PROPERTY_SIMD } property_kind\n+\t= CTX_PROPERTY_NONE;\n+      switch (IDENTIFIER_POINTER (set)[0])\n+\t{\n+\tcase 'c': /* construct */\n+\t  selectors = omp_construct_selectors;\n+\t  allow_score = false;\n+\t  property_limit = 1;\n+\t  property_kind = CTX_PROPERTY_SIMD;\n+\t  break;\n+\tcase 'd': /* device */\n+\t  selectors = omp_device_selectors;\n+\t  allow_score = false;\n+\t  allow_user = true;\n+\t  property_limit = 3;\n+\t  property_kind = CTX_PROPERTY_IDLIST;\n+\t  break;\n+\tcase 'i': /* implementation */\n+\t  selectors = omp_implementation_selectors;\n+\t  allow_user = true;\n+\t  property_limit = 3;\n+\t  property_kind = CTX_PROPERTY_IDLIST;\n+\t  break;\n+\tcase 'u': /* user */\n+\t  selectors = omp_user_selectors;\n+\t  property_limit = 1;\n+\t  property_kind = CTX_PROPERTY_EXPR;\n+\t  break;\n+\tdefault:\n+\t  gcc_unreachable ();\n+\t}\n+      for (int i = 0; ; i++)\n+\t{\n+\t  if (selectors[i] == NULL)\n+\t    {\n+\t      if (allow_user)\n+\t\t{\n+\t\t  property_kind = CTX_PROPERTY_USER;\n+\t\t  break;\n+\t\t}\n+\t      else\n+\t\t{\n+\t\t  error_at (c_parser_peek_token (parser)->location,\n+\t\t\t    \"selector %qs not allowed for context selector \"\n+\t\t\t    \"set %qs\", IDENTIFIER_POINTER (selector),\n+\t\t\t    IDENTIFIER_POINTER (set));\n+\t\t  c_parser_consume_token (parser);\n+\t\t  return error_mark_node;\n+\t\t}\n+\t    }\n+\t  if (i == property_limit)\n+\t    property_kind = CTX_PROPERTY_NONE;\n+\t  if (strcmp (selectors[i], IDENTIFIER_POINTER (selector)) == 0)\n+\t    break;\n+\t}\n+\n+      c_parser_consume_token (parser);\n+\n+      if (c_parser_next_token_is (parser, CPP_OPEN_PAREN))\n+\t{\n+\t  if (property_kind == CTX_PROPERTY_NONE)\n+\t    {\n+\t      error_at (c_parser_peek_token (parser)->location,\n+\t\t\t\"selector %qs does not accept any properties\",\n+\t\t\tIDENTIFIER_POINTER (selector));\n+\t      return error_mark_node;\n+\t    }\n+\n+\t  matching_parens parens;\n+\t  parens.require_open (parser);\n+\n+\t  c_token *token = c_parser_peek_token (parser);\n+\t  if (allow_score\n+\t      && c_parser_next_token_is (parser, CPP_NAME)\n+\t      && strcmp (IDENTIFIER_POINTER (token->value), \"score\") == 0\n+\t      && c_parser_peek_2nd_token (parser)->type == CPP_OPEN_PAREN)\n+\t    {\n+\t      c_parser_consume_token (parser);\n+\n+\t      matching_parens parens2;\n+\t      parens2.require_open (parser);\n+\t      tree score = c_parser_expr_no_commas (parser, NULL).value;\n+\t      parens2.skip_until_found_close (parser);\n+\t      c_parser_require (parser, CPP_COLON, \"expected %<:%>\");\n+\t      if (score != error_mark_node)\n+\t\t{\n+\t\t  mark_exp_read (score);\n+\t\t  score = c_fully_fold (score, false, NULL);\n+\t\t  if (!INTEGRAL_TYPE_P (TREE_TYPE (score))\n+\t\t      || !tree_fits_shwi_p (score))\n+\t\t    error_at (token->location, \"score argument must be \"\n+\t\t\t      \"constant integer expression\");\n+\t\t  else\n+\t\t    properties = tree_cons (get_identifier (\" score\"),\n+\t\t\t\t\t    score, properties);\n+\t\t}\n+\t      token = c_parser_peek_token (parser);\n+\t    }\n+\n+\t  switch (property_kind)\n+\t    {\n+\t      tree t;\n+\t    case CTX_PROPERTY_USER:\n+\t      do\n+\t\t{\n+\t\t  t = c_parser_expr_no_commas (parser, NULL).value;\n+\t\t  if (TREE_CODE (t) == STRING_CST)\n+\t\t    properties = tree_cons (NULL_TREE, t, properties);\n+\t\t  else if (t != error_mark_node)\n+\t\t    {\n+\t\t      mark_exp_read (t);\n+\t\t      t = c_fully_fold (t, false, NULL);\n+\t\t      if (!INTEGRAL_TYPE_P (TREE_TYPE (t))\n+\t\t\t  || !tree_fits_shwi_p (t))\n+\t\t\terror_at (token->location, \"property must be \"\n+\t\t\t\t  \"constant integer expression or string \"\n+\t\t\t\t  \"literal\");\n+\t\t      else\n+\t\t\tproperties = tree_cons (NULL_TREE, t, properties);\n+\t\t    }\n+\n+\t\t  if (c_parser_next_token_is (parser, CPP_COMMA))\n+\t\t    c_parser_consume_token (parser);\n+\t\t  else\n+\t\t    break;\n+\t\t}\n+\t      while (1);\n+\t      break;\n+\t    case CTX_PROPERTY_IDLIST:\n+\t      do\n+\t\t{\n+\t\t  tree prop;\n+\t\t  if (c_parser_next_token_is (parser, CPP_KEYWORD)\n+\t\t      || c_parser_next_token_is (parser, CPP_NAME))\n+\t\t    prop = c_parser_peek_token (parser)->value;\n+\t\t  else\n+\t\t    {\n+\t\t      c_parser_error (parser, \"expected identifier\");\n+\t\t      return error_mark_node;\n+\t\t    }\n+\t\t  c_parser_consume_token (parser);\n+\n+\t\t  properties = tree_cons (prop, NULL_TREE, properties);\n+\n+\t\t  if (c_parser_next_token_is (parser, CPP_COMMA))\n+\t\t    c_parser_consume_token (parser);\n+\t\t  else\n+\t\t    break;\n+\t\t}\n+\t      while (1);\n+\t      break;\n+\t    case CTX_PROPERTY_EXPR:\n+\t      t = c_parser_expr_no_commas (parser, NULL).value;\n+\t      if (t != error_mark_node)\n+\t\t{\n+\t\t  mark_exp_read (t);\n+\t\t  t = c_fully_fold (t, false, NULL);\n+\t\t  if (!INTEGRAL_TYPE_P (TREE_TYPE (t))\n+\t\t      || !tree_fits_shwi_p (t))\n+\t\t    error_at (token->location, \"property must be \"\n+\t\t\t      \"constant integer expression\");\n+\t\t  else\n+\t\t    properties = tree_cons (NULL_TREE, t, properties);\n+\t\t}\n+\t      break;\n+\t    case CTX_PROPERTY_SIMD:\n+\t      if (parms == NULL_TREE)\n+\t\t{\n+\t\t  error_at (token->location, \"properties for %<simd%> \"\n+\t\t\t    \"selector may not be specified in \"\n+\t\t\t    \"%<metadirective%>\");\n+\t\t  return error_mark_node;\n+\t\t}\n+\t      tree c;\n+\t      c = c_parser_omp_all_clauses (parser,\n+\t\t\t\t\t    OMP_DECLARE_SIMD_CLAUSE_MASK,\n+\t\t\t\t\t    \"simd\", true, true);\n+\t      c = c_omp_declare_simd_clauses_to_numbers (parms\n+\t\t\t\t\t\t\t == error_mark_node\n+\t\t\t\t\t\t\t ? NULL_TREE : parms,\n+\t\t\t\t\t\t\t c);\n+\t      properties = tree_cons (NULL_TREE, c, properties);\n+\t      break;\n+\t    default:\n+\t      gcc_unreachable ();\n+\t    }\n+\n+\t  parens.skip_until_found_close (parser);\n+\t  properties = nreverse (properties);\n+\t}\n+      else if (property_kind == CTX_PROPERTY_IDLIST\n+\t       || property_kind == CTX_PROPERTY_EXPR)\n+\t{\n+\t  c_parser_require (parser, CPP_OPEN_PAREN, \"expected %<(%>\");\n+\t  return error_mark_node;\n+\t}\n+\n+      ret = tree_cons (selector, properties, ret);\n+\n+      if (c_parser_next_token_is (parser, CPP_COMMA))\n+\tc_parser_consume_token (parser);\n+      else\n+\tbreak;\n+    }\n+  while (1);\n+\n+  return nreverse (ret);\n+}\n+\n+/* OpenMP 5.0:\n+\n+   trait-set-selector[,trait-set-selector[,...]]\n+\n+   trait-set-selector:\n+     trait-set-selector-name = { trait-selector[, trait-selector[, ...]] }\n+\n+   trait-set-selector-name:\n+     constructor\n+     device\n+     implementation\n+     user  */\n+\n+static tree\n+c_parser_omp_context_selector_specification (c_parser *parser, tree parms)\n+{\n+  tree ret = NULL_TREE;\n+  do\n+    {\n+      const char *setp = \"\";\n+      if (c_parser_next_token_is (parser, CPP_NAME))\n+\tsetp = IDENTIFIER_POINTER (c_parser_peek_token (parser)->value);\n+      switch (setp[0])\n+\t{\n+\tcase 'c':\n+\t  if (strcmp (setp, \"construct\") == 0)\n+\t    setp = NULL;\n+\t  break;\n+\tcase 'd':\n+\t  if (strcmp (setp, \"device\") == 0)\n+\t    setp = NULL;\n+\t  break;\n+\tcase 'i':\n+\t  if (strcmp (setp, \"implementation\") == 0)\n+\t    setp = NULL;\n+\t  break;\n+\tcase 'u':\n+\t  if (strcmp (setp, \"user\") == 0)\n+\t    setp = NULL;\n+\t  break;\n+\tdefault:\n+\t  break;\n+\t}\n+      if (setp)\n+\t{\n+\t  c_parser_error (parser, \"expected %<construct%>, %<device%>, \"\n+\t\t\t\t  \"%<implementation%> or %<user%>\");\n+\t  return error_mark_node;\n+\t}\n+\n+      tree set = c_parser_peek_token (parser)->value;\n+      c_parser_consume_token (parser);\n+\n+      if (!c_parser_require (parser, CPP_EQ, \"expected %<=%>\"))\n+\treturn error_mark_node;\n+\n+      matching_braces braces;\n+      if (!braces.require_open (parser))\n+\treturn error_mark_node;\n+\n+      tree selectors = c_parser_omp_context_selector (parser, set, parms);\n+      if (selectors == error_mark_node)\n+\tret = error_mark_node;\n+      else if (ret != error_mark_node)\n+\tret = tree_cons (set, selectors, ret);\n+\n+      braces.skip_until_found_close (parser);\n+\n+      if (c_parser_next_token_is (parser, CPP_COMMA))\n+\tc_parser_consume_token (parser);\n+      else\n+\tbreak;\n+    }\n+  while (1);\n+\n+  if (ret == error_mark_node)\n+    return ret;\n+  return nreverse (ret);\n+}\n+\n+/* Finalize #pragma omp declare variant after FNDECL has been parsed, and put\n+   that into \"omp declare variant\" attribute.  */\n+\n+static void\n+c_finish_omp_declare_variant (c_parser *parser, tree fndecl, tree parms)\n+{\n+  matching_parens parens;\n+  if (!parens.require_open (parser))\n+    {\n+     fail:\n+      c_parser_skip_to_pragma_eol (parser, false);\n+      return;\n+    }\n+\n+  if (c_parser_next_token_is_not (parser, CPP_NAME)\n+      || c_parser_peek_token (parser)->id_kind != C_ID_ID)\n+    {\n+      c_parser_error (parser, \"expected identifier\");\n+      goto fail;\n+    }\n+\n+  c_token *token = c_parser_peek_token (parser);\n+  tree variant = lookup_name (token->value);\n+\n+  if (variant == NULL_TREE)\n+    {\n+      undeclared_variable (token->location, token->value);\n+      variant = error_mark_node;\n+    }\n+\n+  c_parser_consume_token (parser);\n+\n+  parens.require_close (parser);\n+\n+  const char *clause = \"\";\n+  location_t match_loc = c_parser_peek_token (parser)->location;\n+  if (c_parser_next_token_is (parser, CPP_NAME))\n+    clause = IDENTIFIER_POINTER (c_parser_peek_token (parser)->value);\n+  if (strcmp (clause, \"match\"))\n+    {\n+      c_parser_error (parser, \"expected %<match%>\");\n+      goto fail;\n+    }\n+\n+  c_parser_consume_token (parser);\n+\n+  if (!parens.require_open (parser))\n+    goto fail;\n+\n+  if (parms == NULL_TREE)\n+    parms = error_mark_node;\n+\n+  tree ctx = c_parser_omp_context_selector_specification (parser, parms);\n+  if (ctx == error_mark_node)\n+    goto fail;\n+  ctx = c_omp_check_context_selector (match_loc, ctx);\n+  if (ctx != error_mark_node && variant != error_mark_node)\n+    {\n+      if (TREE_CODE (variant) != FUNCTION_DECL)\n+\t{\n+\t  error_at (token->location, \"variant %qD is not a function\", variant);\n+\t  variant = error_mark_node;\n+\t}\n+      else if (c_omp_get_context_selector (ctx, \"construct\", \"simd\")\n+\t       == NULL_TREE\n+\t       && !comptypes (TREE_TYPE (fndecl), TREE_TYPE (variant)))\n+\t{\n+\t  error_at (token->location, \"variant %qD and base %qD have \"\n+\t\t\t\t     \"incompatible types\", variant, fndecl);\n+\t  variant = error_mark_node;\n+\t}\n+      else if (fndecl_built_in_p (variant)\n+\t       && (strncmp (IDENTIFIER_POINTER (DECL_NAME (variant)),\n+\t\t\t    \"__builtin_\", strlen (\"__builtin_\")) == 0\n+\t\t   || strncmp (IDENTIFIER_POINTER (DECL_NAME (variant)),\n+\t\t\t       \"__sync_\", strlen (\"__sync_\")) == 0\n+\t\t   || strncmp (IDENTIFIER_POINTER (DECL_NAME (variant)),\n+\t\t\t       \"__atomic_\", strlen (\"__atomic_\")) == 0))\n+\t{\n+\t  error_at (token->location, \"variant %qD is a built-in\", variant);\n+\t  variant = error_mark_node;\n+\t}\n+      if (variant != error_mark_node)\n+\t{\n+\t  C_DECL_USED (variant) = 1;\n+\t  tree attr = tree_cons (get_identifier (\"omp declare variant\"),\n+\t\t\t\t build_tree_list (variant, ctx),\n+\t\t\t\t DECL_ATTRIBUTES (fndecl));\n+\t  DECL_ATTRIBUTES (fndecl) = attr;\n+\t}\n+    }\n+\n+  parens.require_close (parser);\n+  c_parser_skip_to_pragma_eol (parser);\n+}\n+\n+/* Finalize #pragma omp declare simd or #pragma omp declare variant\n+   clauses after FNDECL has been parsed, and put that into \"omp declare simd\"\n+   or \"omp declare variant\" attribute.  */\n \n static void\n c_finish_omp_declare_simd (c_parser *parser, tree fndecl, tree parms,\n \t\t\t   vec<c_token> clauses)\n {\n-  /* Normally first token is CPP_NAME \"simd\".  CPP_EOF there indicates\n-     error has been reported and CPP_PRAGMA that c_finish_omp_declare_simd\n-     has already processed the tokens.  */\n+  /* Normally first token is CPP_NAME \"simd\" or \"variant\".  CPP_EOF there\n+     indicates error has been reported and CPP_PRAGMA that\n+     c_finish_omp_declare_simd has already processed the tokens.  */\n   if (clauses.exists () && clauses[0].type == CPP_EOF)\n     return;\n+  const char *kind = \"simd\";\n+  if (clauses.exists ()\n+      && (clauses[0].type == CPP_NAME || clauses[0].type == CPP_PRAGMA))\n+    kind = IDENTIFIER_POINTER (clauses[0].value);\n+  gcc_assert (strcmp (kind, \"simd\") == 0 || strcmp (kind, \"variant\") == 0);\n   if (fndecl == NULL_TREE || TREE_CODE (fndecl) != FUNCTION_DECL)\n     {\n-      error (\"%<#pragma omp declare simd%> not immediately followed by \"\n-\t     \"a function declaration or definition\");\n+      error (\"%<#pragma omp declare %s%> not immediately followed by \"\n+\t     \"a function declaration or definition\", kind);\n       clauses[0].type = CPP_EOF;\n       return;\n     }\n   if (clauses.exists () && clauses[0].type != CPP_NAME)\n     {\n       error_at (DECL_SOURCE_LOCATION (fndecl),\n-\t\t\"%<#pragma omp declare simd%> not immediately followed by \"\n-\t\t\"a single function declaration or definition\");\n+\t\t\"%<#pragma omp declare %s%> not immediately followed by \"\n+\t\t\"a single function declaration or definition\", kind);\n       clauses[0].type = CPP_EOF;\n       return;\n     }\n@@ -19075,7 +19523,6 @@ c_finish_omp_declare_simd (c_parser *parser, tree fndecl, tree parms,\n \n   unsigned int tokens_avail = parser->tokens_avail;\n   gcc_assert (parser->tokens == &parser->tokens_buf[0]);\n-  \n \n   parser->tokens = clauses.address ();\n   parser->tokens_avail = clauses.length ();\n@@ -19085,19 +19532,27 @@ c_finish_omp_declare_simd (c_parser *parser, tree fndecl, tree parms,\n     {\n       c_token *token = c_parser_peek_token (parser);\n       gcc_assert (token->type == CPP_NAME\n-\t\t  && strcmp (IDENTIFIER_POINTER (token->value), \"simd\") == 0);\n+\t\t  && strcmp (IDENTIFIER_POINTER (token->value), kind) == 0);\n       c_parser_consume_token (parser);\n       parser->in_pragma = true;\n \n-      tree c = NULL_TREE;\n-      c = c_parser_omp_all_clauses (parser, OMP_DECLARE_SIMD_CLAUSE_MASK,\n-\t\t\t\t      \"#pragma omp declare simd\");\n-      c = c_omp_declare_simd_clauses_to_numbers (parms, c);\n-      if (c != NULL_TREE)\n-\tc = tree_cons (NULL_TREE, c, NULL_TREE);\n-      c = build_tree_list (get_identifier (\"omp declare simd\"), c);\n-      TREE_CHAIN (c) = DECL_ATTRIBUTES (fndecl);\n-      DECL_ATTRIBUTES (fndecl) = c;\n+      if (strcmp (kind, \"simd\") == 0)\n+\t{\n+\t  tree c;\n+\t  c = c_parser_omp_all_clauses (parser, OMP_DECLARE_SIMD_CLAUSE_MASK,\n+\t\t\t\t\t\"#pragma omp declare simd\");\n+\t  c = c_omp_declare_simd_clauses_to_numbers (parms, c);\n+\t  if (c != NULL_TREE)\n+\t    c = tree_cons (NULL_TREE, c, NULL_TREE);\n+\t  c = build_tree_list (get_identifier (\"omp declare simd\"), c);\n+\t  TREE_CHAIN (c) = DECL_ATTRIBUTES (fndecl);\n+\t  DECL_ATTRIBUTES (fndecl) = c;\n+\t}\n+      else\n+\t{\n+\t  gcc_assert (strcmp (kind, \"variant\") == 0);\n+\t  c_finish_omp_declare_variant (parser, fndecl, parms);\n+\t}\n     }\n \n   parser->tokens = &parser->tokens_buf[0];\n@@ -19612,7 +20067,10 @@ c_parser_omp_declare_reduction (c_parser *parser, enum pragma_context context)\n    #pragma omp declare simd declare-simd-clauses[optseq] new-line\n    #pragma omp declare reduction (reduction-id : typename-list : expression) \\\n       initializer-clause[opt] new-line\n-   #pragma omp declare target new-line  */\n+   #pragma omp declare target new-line\n+\n+   OpenMP 5.0\n+   #pragma omp declare variant (identifier) match (context-selector)  */\n \n static void\n c_parser_omp_declare (c_parser *parser, enum pragma_context context)\n@@ -19645,10 +20103,17 @@ c_parser_omp_declare (c_parser *parser, enum pragma_context context)\n \t  c_parser_omp_declare_target (parser);\n \t  return;\n \t}\n+      if (strcmp (p, \"variant\") == 0)\n+\t{\n+\t  /* c_parser_consume_token (parser); done in\n+\t     c_parser_omp_declare_simd.  */\n+\t  c_parser_omp_declare_simd (parser, context);\n+\t  return;\n+\t}\n     }\n \n-  c_parser_error (parser, \"expected %<simd%> or %<reduction%> \"\n-\t\t\t  \"or %<target%>\");\n+  c_parser_error (parser, \"expected %<simd%>, %<reduction%>, \"\n+\t\t\t  \"%<target%> or %<variant%>\");\n   c_parser_skip_to_pragma_eol (parser);\n }\n "}, {"sha": "9ed731195849e7e1587d26f4a116fef2706ecaf6", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94e7f906ca5c73fb79d21ec54733e9e75a96c2b4/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94e7f906ca5c73fb79d21ec54733e9e75a96c2b4/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=94e7f906ca5c73fb79d21ec54733e9e75a96c2b4", "patch": "@@ -1,3 +1,21 @@\n+2019-10-10  Jakub Jelinek  <jakub@redhat.com>\n+\n+\t* parser.h (struct cp_omp_declare_simd_data): Add variant_p member.\n+\t* parser.c (cp_ensure_no_omp_declare_simd): Handle both declare simd\n+\tand declare variant.\n+\t(cp_parser_oacc_all_clauses): Formatting fix.\n+\t(cp_parser_omp_all_clauses): Add NESTED_P argument, if true, terminate\n+\tprocessing on closing paren and don't skip to end of pragma line.\n+\t(cp_parser_omp_declare_simd): Add VARIANT_P argument.  Handle also\n+\tdeclare variant.\n+\t(omp_construct_selectors, omp_device_selectors,\n+\tomp_implementation_selectors, omp_user_selectors): New variables.\n+\t(cp_parser_omp_context_selector,\n+\tcp_parser_omp_context_selector_specification,\n+\tcp_finish_omp_declare_variant): New functions.\n+\t(cp_parser_late_parsing_omp_declare_simd): Handle also declare variant.\n+\t(cp_parser_omp_declare): Handle declare variant.\n+\n 2019-10-09  Jason Merrill  <jason@redhat.com>\n \n \t* cp-tree.h (template_info_decl_check): Check ENABLE_TREE_CHECKING."}, {"sha": "3ee8da7db949aff0e9a8bc33868e0c41b0e4aa65", "filename": "gcc/cp/parser.c", "status": "modified", "additions": 480, "deletions": 26, "changes": 506, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94e7f906ca5c73fb79d21ec54733e9e75a96c2b4/gcc%2Fcp%2Fparser.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94e7f906ca5c73fb79d21ec54733e9e75a96c2b4/gcc%2Fcp%2Fparser.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparser.c?ref=94e7f906ca5c73fb79d21ec54733e9e75a96c2b4", "patch": "@@ -1376,8 +1376,9 @@ cp_ensure_no_omp_declare_simd (cp_parser *parser)\n {\n   if (parser->omp_declare_simd && !parser->omp_declare_simd->error_seen)\n     {\n-      error (\"%<#pragma omp declare simd%> not immediately followed by \"\n-\t     \"function declaration or definition\");\n+      error (\"%<#pragma omp declare %s%> not immediately followed by \"\n+\t     \"function declaration or definition\",\n+\t     parser->omp_declare_simd->variant_p ? \"variant\" : \"simd\");\n       parser->omp_declare_simd = NULL;\n     }\n }\n@@ -35878,8 +35879,8 @@ cp_parser_oacc_clause_async (cp_parser *parser, tree list)\n \n static tree\n cp_parser_oacc_all_clauses (cp_parser *parser, omp_clause_mask mask,\n-\t\t\t   const char *where, cp_token *pragma_tok,\n-\t\t\t   bool finish_p = true)\n+\t\t\t    const char *where, cp_token *pragma_tok,\n+\t\t\t    bool finish_p = true)\n {\n   tree clauses = NULL;\n   bool first = true;\n@@ -36075,13 +36076,15 @@ cp_parser_oacc_all_clauses (cp_parser *parser, omp_clause_mask mask,\n }\n \n /* Parse all OpenMP clauses.  The set clauses allowed by the directive\n-   is a bitmask in MASK.  Return the list of clauses found; the result\n-   of clause default goes in *pdefault.  */\n+   is a bitmask in MASK.  Return the list of clauses found.\n+   FINISH_P set if finish_omp_clauses should be called.\n+   NESTED_P set if clauses should be terminated by closing paren instead\n+   of end of pragma.  */\n \n static tree\n cp_parser_omp_all_clauses (cp_parser *parser, omp_clause_mask mask,\n \t\t\t   const char *where, cp_token *pragma_tok,\n-\t\t\t   bool finish_p = true)\n+\t\t\t   bool finish_p = true, bool nested_p = false)\n {\n   tree clauses = NULL;\n   bool first = true;\n@@ -36096,6 +36099,9 @@ cp_parser_omp_all_clauses (cp_parser *parser, omp_clause_mask mask,\n       const char *c_name;\n       tree prev = clauses;\n \n+      if (nested_p && cp_lexer_next_token_is (parser->lexer, CPP_CLOSE_PAREN))\n+\tbreak;\n+\n       if (!first && cp_lexer_next_token_is (parser->lexer, CPP_COMMA))\n \tcp_lexer_consume_token (parser->lexer);\n \n@@ -36415,7 +36421,8 @@ cp_parser_omp_all_clauses (cp_parser *parser, omp_clause_mask mask,\n \t}\n     }\n  saw_error:\n-  cp_parser_skip_to_pragma_eol (parser, pragma_tok);\n+  if (!nested_p)\n+    cp_parser_skip_to_pragma_eol (parser, pragma_tok);\n   if (finish_p)\n     {\n       if ((mask & (OMP_CLAUSE_MASK_1 << PRAGMA_OMP_CLAUSE_UNIFORM)) != 0)\n@@ -40241,20 +40248,31 @@ cp_parser_oacc_wait (cp_parser *parser, cp_token *pragma_tok)\n \n static void\n cp_parser_omp_declare_simd (cp_parser *parser, cp_token *pragma_tok,\n-\t\t\t    enum pragma_context context)\n+\t\t\t    enum pragma_context context,\n+\t\t\t    bool variant_p)\n {\n   bool first_p = parser->omp_declare_simd == NULL;\n   cp_omp_declare_simd_data data;\n   if (first_p)\n     {\n       data.error_seen = false;\n       data.fndecl_seen = false;\n+      data.variant_p = variant_p;\n       data.tokens = vNULL;\n       data.clauses = NULL_TREE;\n       /* It is safe to take the address of a local variable; it will only be\n \t used while this scope is live.  */\n       parser->omp_declare_simd = &data;\n     }\n+  else if (parser->omp_declare_simd->variant_p != variant_p)\n+    {\n+      error_at (pragma_tok->location,\n+\t\t\"%<#pragma omp declare %s%> followed by \"\n+\t\t\"%<#pragma omp declare %s%>\",\n+\t\tparser->omp_declare_simd->variant_p ? \"variant\" : \"simd\",\n+\t\tparser->omp_declare_simd->variant_p ? \"simd\" : \"variant\");\n+      parser->omp_declare_simd->error_seen = true;\n+    }\n \n   /* Store away all pragma tokens.  */\n   while (cp_lexer_next_token_is_not (parser->lexer, CPP_PRAGMA_EOL)\n@@ -40290,13 +40308,427 @@ cp_parser_omp_declare_simd (cp_parser *parser, cp_token *pragma_tok,\n \t  && !parser->omp_declare_simd->error_seen\n \t  && !parser->omp_declare_simd->fndecl_seen)\n \terror_at (pragma_tok->location,\n-\t\t  \"%<#pragma omp declare simd%> not immediately followed by \"\n-\t\t  \"function declaration or definition\");\n+\t\t  \"%<#pragma omp declare %s%> not immediately followed by \"\n+\t\t  \"function declaration or definition\",\n+\t\t  parser->omp_declare_simd->variant_p ? \"variant\" : \"simd\");\n       data.tokens.release ();\n       parser->omp_declare_simd = NULL;\n     }\n }\n \n+static const char *const omp_construct_selectors[] = {\n+  \"simd\", \"target\", \"teams\", \"parallel\", \"for\", NULL };\n+static const char *const omp_device_selectors[] = {\n+  \"kind\", \"isa\", \"arch\", NULL };\n+static const char *const omp_implementation_selectors[] = {\n+  \"vendor\", \"extension\", \"atomic_default_mem_order\", \"unified_address\",\n+  \"unified_shared_memory\", \"dynamic_allocators\", \"reverse_offload\", NULL };\n+static const char *const omp_user_selectors[] = {\n+  \"condition\", NULL };\n+\n+/* OpenMP 5.0:\n+\n+   trait-selector:\n+     trait-selector-name[([trait-score:]trait-property[,trait-property[,...]])]\n+\n+   trait-score:\n+     score(score-expression)  */\n+\n+static tree\n+cp_parser_omp_context_selector (cp_parser *parser, tree set, bool has_parms_p)\n+{\n+  tree ret = NULL_TREE;\n+  do\n+    {\n+      tree selector;\n+      if (cp_lexer_next_token_is (parser->lexer, CPP_KEYWORD)\n+\t  || cp_lexer_next_token_is (parser->lexer, CPP_NAME))\n+\tselector = cp_lexer_peek_token (parser->lexer)->u.value;\n+      else\n+\t{\n+\t  cp_parser_error (parser, \"expected trait selector name\");\n+\t  return error_mark_node;\n+\t}\n+\n+      tree properties = NULL_TREE;\n+      const char *const *selectors = NULL;\n+      bool allow_score = true;\n+      bool allow_user = false;\n+      int property_limit = 0;\n+      enum { CTX_PROPERTY_NONE, CTX_PROPERTY_USER, CTX_PROPERTY_IDLIST,\n+\t     CTX_PROPERTY_EXPR, CTX_PROPERTY_SIMD } property_kind\n+\t= CTX_PROPERTY_NONE;\n+      switch (IDENTIFIER_POINTER (set)[0])\n+\t{\n+\tcase 'c': /* construct */\n+\t  selectors = omp_construct_selectors;\n+\t  allow_score = false;\n+\t  property_limit = 1;\n+\t  property_kind = CTX_PROPERTY_SIMD;\n+\t  break;\n+\tcase 'd': /* device */\n+\t  selectors = omp_device_selectors;\n+\t  allow_score = false;\n+\t  allow_user = true;\n+\t  property_limit = 3;\n+\t  property_kind = CTX_PROPERTY_IDLIST;\n+\t  break;\n+\tcase 'i': /* implementation */\n+\t  selectors = omp_implementation_selectors;\n+\t  allow_user = true;\n+\t  property_limit = 3;\n+\t  property_kind = CTX_PROPERTY_IDLIST;\n+\t  break;\n+\tcase 'u': /* user */\n+\t  selectors = omp_user_selectors;\n+\t  property_limit = 1;\n+\t  property_kind = CTX_PROPERTY_EXPR;\n+\t  break;\n+\tdefault:\n+\t  gcc_unreachable ();\n+\t}\n+      for (int i = 0; ; i++)\n+\t{\n+\t  if (selectors[i] == NULL)\n+\t    {\n+\t      if (allow_user)\n+\t\t{\n+\t\t  property_kind = CTX_PROPERTY_USER;\n+\t\t  break;\n+\t\t}\n+\t      else\n+\t\t{\n+\t\t  error (\"selector %qs not allowed for context selector \"\n+\t\t\t \"set %qs\", IDENTIFIER_POINTER (selector),\n+\t\t\t IDENTIFIER_POINTER (set));\n+\t\t  cp_lexer_consume_token (parser->lexer);\n+\t\t  return error_mark_node;\n+\t\t}\n+\t    }\n+\t  if (i == property_limit)\n+\t    property_kind = CTX_PROPERTY_NONE;\n+\t  if (strcmp (selectors[i], IDENTIFIER_POINTER (selector)) == 0)\n+\t    break;\n+\t}\n+\n+      cp_lexer_consume_token (parser->lexer);\n+\n+      if (cp_lexer_next_token_is (parser->lexer, CPP_OPEN_PAREN))\n+\t{\n+\t  if (property_kind == CTX_PROPERTY_NONE)\n+\t    {\n+\t      error (\"selector %qs does not accept any properties\",\n+\t\t     IDENTIFIER_POINTER (selector));\n+\t      return error_mark_node;\n+\t    }\n+\n+\t  matching_parens parens;\n+\t  parens.consume_open (parser);\n+\n+\t  cp_token *token = cp_lexer_peek_token (parser->lexer);\n+\t  if (allow_score\n+\t      && cp_lexer_next_token_is (parser->lexer, CPP_NAME)\n+\t      && strcmp (IDENTIFIER_POINTER (token->u.value), \"score\") == 0\n+\t      && cp_lexer_nth_token_is (parser->lexer, 2, CPP_OPEN_PAREN))\n+\t    {\n+\t      cp_lexer_save_tokens (parser->lexer);\n+\t      cp_lexer_consume_token (parser->lexer);\n+\t      cp_lexer_consume_token (parser->lexer);\n+\t      if (cp_parser_skip_to_closing_parenthesis (parser, false, false,\n+\t\t\t\t\t\t\t true)\n+\t\t  && cp_lexer_next_token_is (parser->lexer, CPP_COLON))\n+\t\t{\n+\t\t  cp_lexer_rollback_tokens (parser->lexer);\n+\t\t  cp_lexer_consume_token (parser->lexer);\n+\n+\t\t  matching_parens parens2;\n+\t\t  parens2.require_open (parser);\n+\t\t  tree score = cp_parser_constant_expression (parser);\n+\t\t  if (!parens2.require_close (parser))\n+\t\t    cp_parser_skip_to_closing_parenthesis (parser, true,\n+\t\t\t\t\t\t\t   false, true);\n+\t\t  cp_parser_require (parser, CPP_COLON, RT_COLON);\n+\t\t  if (score != error_mark_node)\n+\t\t    {\n+\t\t      score = fold_non_dependent_expr (score);\n+\t\t      if (!value_dependent_expression_p (score)\n+\t\t\t  && (!INTEGRAL_TYPE_P (TREE_TYPE (score))\n+\t\t\t      || !tree_fits_shwi_p (score)))\n+\t\t\terror_at (token->location, \"score argument must be \"\n+\t\t\t\t  \"constant integer expression\");\n+\t\t      else\n+\t\t\tproperties = tree_cons (get_identifier (\" score\"),\n+\t\t\t\t\t\tscore, properties);\n+\t\t    }\n+\t\t}\n+\t      else\n+\t\tcp_lexer_rollback_tokens (parser->lexer);\n+\n+\t      token = cp_lexer_peek_token (parser->lexer);\n+\t    }\n+\n+\t  switch (property_kind)\n+\t    {\n+\t      tree t;\n+\t    case CTX_PROPERTY_USER:\n+\t      do\n+\t\t{\n+\t\t  t = cp_parser_constant_expression (parser);\n+\t\t  if (t != error_mark_node)\n+\t\t    {\n+\t\t      t = fold_non_dependent_expr (t);\n+\t\t      if (TREE_CODE (t) == STRING_CST)\n+\t\t\tproperties = tree_cons (NULL_TREE, t, properties);\n+\t\t      else if (!value_dependent_expression_p (t)\n+\t\t\t       && (!INTEGRAL_TYPE_P (TREE_TYPE (t))\n+\t\t\t\t   || !tree_fits_shwi_p (t)))\n+\t\t\terror_at (token->location, \"property must be \"\n+\t\t\t\t  \"constant integer expression or string \"\n+\t\t\t\t  \"literal\");\n+\t\t      else\n+\t\t\tproperties = tree_cons (NULL_TREE, t, properties);\n+\t\t    }\n+\n+\t\t  if (cp_lexer_next_token_is (parser->lexer, CPP_COMMA))\n+\t\t    cp_lexer_consume_token (parser->lexer);\n+\t\t  else\n+\t\t    break;\n+\t\t}\n+\t      while (1);\n+\t      break;\n+\t    case CTX_PROPERTY_IDLIST:\n+\t      do\n+\t\t{\n+\t\t  tree prop;\n+\t\t  if (cp_lexer_next_token_is (parser->lexer, CPP_KEYWORD)\n+\t\t      || cp_lexer_next_token_is (parser->lexer, CPP_NAME))\n+\t\t    prop = cp_lexer_peek_token (parser->lexer)->u.value;\n+\t\t  else\n+\t\t    {\n+\t\t      cp_parser_error (parser, \"expected identifier\");\n+\t\t      return error_mark_node;\n+\t\t    }\n+\t\t  cp_lexer_consume_token (parser->lexer);\n+\n+\t\t  properties = tree_cons (prop, NULL_TREE, properties);\n+\n+\t\t  if (cp_lexer_next_token_is (parser->lexer, CPP_COMMA))\n+\t\t    cp_lexer_consume_token (parser->lexer);\n+\t\t  else\n+\t\t    break;\n+\t\t}\n+\t      while (1);\n+\t      break;\n+\t    case CTX_PROPERTY_EXPR:\n+\t      t = cp_parser_constant_expression (parser);\n+\t      if (t != error_mark_node)\n+\t\t{\n+\t\t  t = fold_non_dependent_expr (t);\n+\t\t  if (!value_dependent_expression_p (t)\n+\t\t      && (!INTEGRAL_TYPE_P (TREE_TYPE (t))\n+\t\t\t  || !tree_fits_shwi_p (t)))\n+\t\t    error_at (token->location, \"property must be \"\n+\t\t\t      \"constant integer expression\");\n+\t\t  else\n+\t\t    properties = tree_cons (NULL_TREE, t, properties);\n+\t\t}\n+\t      break;\n+\t    case CTX_PROPERTY_SIMD:\n+\t      if (!has_parms_p)\n+\t\t{\n+\t\t  error_at (token->location, \"properties for %<simd%> \"\n+\t\t\t    \"selector may not be specified in \"\n+\t\t\t    \"%<metadirective%>\");\n+\t\t  return error_mark_node;\n+\t\t}\n+\t      tree c;\n+\t      c = cp_parser_omp_all_clauses (parser,\n+\t\t\t\t\t     OMP_DECLARE_SIMD_CLAUSE_MASK,\n+\t\t\t\t\t     \"simd\", NULL, true, true);\n+\t      properties = tree_cons (NULL_TREE, c, properties);\n+\t      break;\n+\t    default:\n+\t      gcc_unreachable ();\n+\t    }\n+\n+\t  if (!parens.require_close (parser))\n+\t    cp_parser_skip_to_closing_parenthesis (parser, true, false, true);\n+\n+\t  properties = nreverse (properties);\n+\t}\n+      else if (property_kind == CTX_PROPERTY_IDLIST\n+\t       || property_kind == CTX_PROPERTY_EXPR)\n+\t{\n+\t  cp_parser_require (parser, CPP_OPEN_PAREN, RT_OPEN_PAREN);\n+\t  return error_mark_node;\n+\t}\n+\n+      ret = tree_cons (selector, properties, ret);\n+\n+      if (cp_lexer_next_token_is (parser->lexer, CPP_COMMA))\n+\tcp_lexer_consume_token (parser->lexer);\n+      else\n+\tbreak;\n+    }\n+  while (1);\n+\n+  return nreverse (ret);\n+}\n+\n+/* OpenMP 5.0:\n+\n+   trait-set-selector[,trait-set-selector[,...]]\n+\n+   trait-set-selector:\n+     trait-set-selector-name = { trait-selector[, trait-selector[, ...]] }\n+\n+   trait-set-selector-name:\n+     constructor\n+     device\n+     implementation\n+     user  */\n+\n+static tree\n+cp_parser_omp_context_selector_specification (cp_parser *parser,\n+\t\t\t\t\t      bool has_parms_p)\n+{\n+  tree ret = NULL_TREE;\n+  do\n+    {\n+      const char *setp = \"\";\n+      if (cp_lexer_next_token_is (parser->lexer, CPP_NAME))\n+\tsetp\n+\t  = IDENTIFIER_POINTER (cp_lexer_peek_token (parser->lexer)->u.value);\n+      switch (setp[0])\n+\t{\n+\tcase 'c':\n+\t  if (strcmp (setp, \"construct\") == 0)\n+\t    setp = NULL;\n+\t  break;\n+\tcase 'd':\n+\t  if (strcmp (setp, \"device\") == 0)\n+\t    setp = NULL;\n+\t  break;\n+\tcase 'i':\n+\t  if (strcmp (setp, \"implementation\") == 0)\n+\t    setp = NULL;\n+\t  break;\n+\tcase 'u':\n+\t  if (strcmp (setp, \"user\") == 0)\n+\t    setp = NULL;\n+\t  break;\n+\tdefault:\n+\t  break;\n+\t}\n+      if (setp)\n+\t{\n+\t  cp_parser_error (parser, \"expected %<construct%>, %<device%>, \"\n+\t\t\t\t   \"%<implementation%> or %<user%>\");\n+\t  return error_mark_node;\n+\t}\n+\n+      tree set = cp_lexer_peek_token (parser->lexer)->u.value;\n+      cp_lexer_consume_token (parser->lexer);\n+\n+      if (!cp_parser_require (parser, CPP_EQ, RT_EQ))\n+\treturn error_mark_node;\n+\n+      matching_braces braces;\n+      if (!braces.require_open (parser))\n+\treturn error_mark_node;\n+\n+      tree selectors\n+\t= cp_parser_omp_context_selector (parser, set, has_parms_p);\n+      if (selectors == error_mark_node)\n+\t{\n+\t  cp_parser_skip_to_closing_brace (parser);\n+\t  ret = error_mark_node;\n+\t}\n+      else if (ret != error_mark_node)\n+\tret = tree_cons (set, selectors, ret);\n+\n+      braces.require_close (parser);\n+\n+      if (cp_lexer_next_token_is (parser->lexer, CPP_COMMA))\n+\tcp_lexer_consume_token (parser->lexer);\n+      else\n+\tbreak;\n+    }\n+  while (1);\n+\n+  if (ret == error_mark_node)\n+    return ret;\n+  return nreverse (ret);\n+}\n+\n+/* Finalize #pragma omp declare variant after a fndecl has been parsed, and put\n+   that into \"omp declare variant\" attribute.  */\n+\n+static tree\n+cp_finish_omp_declare_variant (cp_parser *parser, cp_token *pragma_tok,\n+\t\t\t       tree attrs)\n+{\n+  matching_parens parens;\n+  if (!parens.require_open (parser))\n+    {\n+     fail:\n+      cp_parser_skip_to_pragma_eol (parser, pragma_tok);\n+      return attrs;\n+    }\n+\n+  cp_token *token = cp_lexer_peek_token (parser->lexer);\n+  tree variant;\n+  tree name = cp_parser_id_expression (parser, /*template_p=*/false,\n+\t\t\t\t       /*check_dependency_p=*/true,\n+\t\t\t\t       /*template_p=*/NULL,\n+\t\t\t\t       /*declarator_p=*/false,\n+\t\t\t\t       /*optional_p=*/false);\n+  if (identifier_p (name))\n+    variant = cp_parser_lookup_name_simple (parser, name, token->location);\n+  else\n+    variant = name;\n+  if (variant == error_mark_node)\n+    {\n+      cp_parser_name_lookup_error (parser, name, variant, NLE_NULL,\n+\t\t\t\t   token->location);\n+      variant = error_mark_node;\n+    }\n+\n+  parens.require_close (parser);\n+\n+  const char *clause = \"\";\n+  location_t match_loc = cp_lexer_peek_token (parser->lexer)->location;\n+  if (cp_lexer_next_token_is (parser->lexer, CPP_NAME))\n+    clause = IDENTIFIER_POINTER (cp_lexer_peek_token (parser->lexer)->u.value);\n+  if (strcmp (clause, \"match\"))\n+    {\n+      cp_parser_error (parser, \"expected %<match%>\");\n+      goto fail;\n+    }\n+\n+  cp_lexer_consume_token (parser->lexer);\n+\n+  if (!parens.require_open (parser))\n+    goto fail;\n+\n+  tree ctx = cp_parser_omp_context_selector_specification (parser, true);\n+  if (ctx == error_mark_node)\n+    goto fail;\n+  ctx = c_omp_check_context_selector (match_loc, ctx);\n+  if (ctx != error_mark_node && variant != error_mark_node)\n+    {\n+      attrs = tree_cons (get_identifier (\"omp declare variant\"),\n+\t\t\t build_tree_list (variant, ctx), attrs);\n+      if (processing_template_decl)\n+\tATTR_IS_DEPENDENT (attrs) = 1;\n+    }\n+\n+  parens.require_close (parser);\n+  cp_parser_skip_to_pragma_eol (parser, pragma_tok);\n+  return attrs;\n+}\n+\n+\n /* Finalize #pragma omp declare simd clauses after direct declarator has\n    been parsed, and put that into \"omp declare simd\" attribute.  */\n \n@@ -40309,8 +40741,9 @@ cp_parser_late_parsing_omp_declare_simd (cp_parser *parser, tree attrs)\n \n   if (!data->error_seen && data->fndecl_seen)\n     {\n-      error (\"%<#pragma omp declare simd%> not immediately followed by \"\n-\t     \"a single function declaration or definition\");\n+      error (\"%<#pragma omp declare %s%> not immediately followed by \"\n+\t     \"a single function declaration or definition\",\n+\t     data->variant_p ? \"variant\" : \"simd\");\n       data->error_seen = true;\n     }\n   if (data->error_seen)\n@@ -40324,17 +40757,28 @@ cp_parser_late_parsing_omp_declare_simd (cp_parser *parser, tree attrs)\n       parser->lexer->in_pragma = true;\n       gcc_assert (cp_lexer_peek_token (parser->lexer)->type == CPP_PRAGMA);\n       cp_token *pragma_tok = cp_lexer_consume_token (parser->lexer);\n+      tree id = cp_lexer_peek_token (parser->lexer)->u.value;\n+      const char *kind = IDENTIFIER_POINTER (id);\n       cp_lexer_consume_token (parser->lexer);\n-      cl = cp_parser_omp_all_clauses (parser, OMP_DECLARE_SIMD_CLAUSE_MASK,\n-\t\t\t\t      \"#pragma omp declare simd\", pragma_tok);\n+      if (strcmp (kind, \"simd\") == 0)\n+\t{\n+\t  cl = cp_parser_omp_all_clauses (parser, OMP_DECLARE_SIMD_CLAUSE_MASK,\n+\t\t\t\t\t  \"#pragma omp declare simd\",\n+\t\t\t\t\t  pragma_tok);\n+\t  if (cl)\n+\t    cl = tree_cons (NULL_TREE, cl, NULL_TREE);\n+\t  c = build_tree_list (get_identifier (\"omp declare simd\"), cl);\n+\t  TREE_CHAIN (c) = attrs;\n+\t  if (processing_template_decl)\n+\t    ATTR_IS_DEPENDENT (c) = 1;\n+\t  attrs = c;\n+\t}\n+      else\n+\t{\n+\t  gcc_assert (strcmp (kind, \"variant\") == 0);\n+\t  attrs = cp_finish_omp_declare_variant (parser, pragma_tok, attrs);\n+\t}\n       cp_parser_pop_lexer (parser);\n-      if (cl)\n-\tcl = tree_cons (NULL_TREE, cl, NULL_TREE);\n-      c = build_tree_list (get_identifier (\"omp declare simd\"), cl);\n-      TREE_CHAIN (c) = attrs;\n-      if (processing_template_decl)\n-\tATTR_IS_DEPENDENT (c) = 1;\n-      attrs = c;\n     }\n \n   data->fndecl_seen = true;\n@@ -40898,7 +41342,10 @@ cp_parser_omp_declare_reduction (cp_parser *parser, cp_token *pragma_tok,\n    #pragma omp declare simd declare-simd-clauses[optseq] new-line\n    #pragma omp declare reduction (reduction-id : typename-list : expression) \\\n       initializer-clause[opt] new-line\n-   #pragma omp declare target new-line  */\n+   #pragma omp declare target new-line\n+\n+   OpenMP 5.0\n+   #pragma omp declare variant (identifier) match (context-selector)  */\n \n static bool\n cp_parser_omp_declare (cp_parser *parser, cp_token *pragma_tok,\n@@ -40913,7 +41360,14 @@ cp_parser_omp_declare (cp_parser *parser, cp_token *pragma_tok,\n \t{\n \t  cp_lexer_consume_token (parser->lexer);\n \t  cp_parser_omp_declare_simd (parser, pragma_tok,\n-\t\t\t\t      context);\n+\t\t\t\t      context, false);\n+\t  return true;\n+\t}\n+      if (flag_openmp && strcmp (p, \"variant\") == 0)\n+\t{\n+\t  cp_lexer_consume_token (parser->lexer);\n+\t  cp_parser_omp_declare_simd (parser, pragma_tok,\n+\t\t\t\t      context, true);\n \t  return true;\n \t}\n       cp_ensure_no_omp_declare_simd (parser);\n@@ -40936,8 +41390,8 @@ cp_parser_omp_declare (cp_parser *parser, cp_token *pragma_tok,\n \t  return false;\n \t}\n     }\n-  cp_parser_error (parser, \"expected %<simd%> or %<reduction%> \"\n-\t\t\t   \"or %<target%>\");\n+  cp_parser_error (parser, \"expected %<simd%>, %<reduction%>, \"\n+\t\t\t   \"%<target%> or %<variant%>\");\n   cp_parser_require_pragma_eol (parser, pragma_tok);\n   return false;\n }"}, {"sha": "91b5916622d950195b81fad610da283273dfd452", "filename": "gcc/cp/parser.h", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94e7f906ca5c73fb79d21ec54733e9e75a96c2b4/gcc%2Fcp%2Fparser.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94e7f906ca5c73fb79d21ec54733e9e75a96c2b4/gcc%2Fcp%2Fparser.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparser.h?ref=94e7f906ca5c73fb79d21ec54733e9e75a96c2b4", "patch": "@@ -202,10 +202,11 @@ struct GTY (()) cp_parser_context {\n };\n \n \n-/* Helper data structure for parsing #pragma omp declare simd.  */\n+/* Helper data structure for parsing #pragma omp declare {simd,variant}.  */\n struct cp_omp_declare_simd_data {\n   bool error_seen; /* Set if error has been reported.  */\n   bool fndecl_seen; /* Set if one fn decl/definition has been seen already.  */\n+  bool variant_p; /* Set for #pragma omp declare variant.  */\n   vec<cp_token_cache_ptr> tokens;\n   tree clauses;\n };"}, {"sha": "0a4961b327d8c0ba116bd932b168c2ec41493853", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94e7f906ca5c73fb79d21ec54733e9e75a96c2b4/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94e7f906ca5c73fb79d21ec54733e9e75a96c2b4/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=94e7f906ca5c73fb79d21ec54733e9e75a96c2b4", "patch": "@@ -1,3 +1,12 @@\n+2019-10-10  Jakub Jelinek  <jakub@redhat.com>\n+\n+\t* c-c++-common/gomp/declare-variant-1.c: New test.\n+\t* c-c++-common/gomp/declare-variant-2.c: New test.\n+\t* c-c++-common/gomp/declare-variant-3.c: New test.\n+\t* g++.dg/gomp/this-1.C: Adjust for diagnostic message spelling fix.\n+\t* gcc.dg/gomp/declare-variant-1.c: New test.\n+\t* gcc.dg/gomp/declare-variant-2.c: New test.\n+\n 2019-10-09  Martin Sebor  <msebor@redhat.com>\n \n \tPR tree-optimization/90879"}, {"sha": "8b3cd7fed9f7e1d29ef1c571efac7642412afb1c", "filename": "gcc/testsuite/c-c++-common/gomp/declare-variant-1.c", "status": "added", "additions": 54, "deletions": 0, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94e7f906ca5c73fb79d21ec54733e9e75a96c2b4/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Fdeclare-variant-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94e7f906ca5c73fb79d21ec54733e9e75a96c2b4/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Fdeclare-variant-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Fdeclare-variant-1.c?ref=94e7f906ca5c73fb79d21ec54733e9e75a96c2b4", "patch": "@@ -0,0 +1,54 @@\n+int foo (int, int, int *);\n+int bar (int, int, int *);\n+#pragma omp declare variant (foo) \\\n+  match (construct={parallel,for},\\\n+\t device={isa(avx512f,avx512vl),kind(host,cpu)},\\\n+\t implementation={vendor(score(0):gnu),unified_shared_memory},\\\n+\t user={condition(score(0):0)})\n+#pragma omp declare variant (bar) \\\n+  match (device={arch(x86_64,powerpc64),isa(avx512f,popcntb)}, \\\n+\t implementation={atomic_default_mem_order(seq_cst),made_up_selector(\"foo\", 13, \"bar\")}, \\\n+\t user={condition(3-3)})\n+int baz (int, int, int *);\n+\n+int\n+qux (void)\n+{\n+  int i = 3;\n+  return baz (1, 2, &i);\n+}\n+\n+int quux (int);\n+\n+void\n+corge (void)\n+{\n+  int i;\n+  #pragma omp declare variant (quux) match (construct={parallel,for})\n+  extern int waldo (int);\n+  waldo (5);\n+  #pragma omp parallel for\n+  for (i = 0; i < 3; i++)\n+    waldo (6);\n+  #pragma omp parallel\n+  #pragma omp taskgroup\n+  #pragma omp for\n+  for (i = 0; i < 3; i++)\n+    waldo (7);\n+  #pragma omp parallel\n+  #pragma omp master    \n+  waldo (8);\n+}\n+\n+#pragma omp declare variant (bar) match \\\n+  (implementation={atomic_default_mem_order(relaxed), \\\n+\t\t   unified_address, unified_shared_memory, \\\n+\t\t   dynamic_allocators, reverse_offload})\n+int baz2 (int x, int y, int *z)\n+{\n+  return x + y + *z;\n+}\n+\n+#pragma omp declare variant (bar) match \\\n+  (implementation={atomic_default_mem_order(score(3): acq_rel)})\n+int baz3 (int, int, int *);"}, {"sha": "bc12398911cd42e706b76956d71c116036b1e422", "filename": "gcc/testsuite/c-c++-common/gomp/declare-variant-2.c", "status": "added", "additions": 122, "deletions": 0, "changes": 122, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94e7f906ca5c73fb79d21ec54733e9e75a96c2b4/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Fdeclare-variant-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94e7f906ca5c73fb79d21ec54733e9e75a96c2b4/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Fdeclare-variant-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Fdeclare-variant-2.c?ref=94e7f906ca5c73fb79d21ec54733e9e75a96c2b4", "patch": "@@ -0,0 +1,122 @@\n+void f1 (void);\n+#pragma omp declare variant\t/* { dg-error \"expected '\\\\(' before end of line\" } */\n+void f2 (void);\n+#pragma omp declare variant (\t/* { dg-error \"\" } */\n+void f3 (void);\n+#pragma omp declare variant ()\t/* { dg-error \"\" } */\n+void f4 (void);\n+#pragma omp declare variant match(user={condition(0)})\t/* { dg-error \"expected '\\\\(' before 'match'\" } */\n+void f5 (void);\n+#pragma omp declare variant (f1)\t/* { dg-error \"expected 'match' before end of line\" } */\n+void f6 (void);\n+#pragma omp declare variant (f1) simd\t/* { dg-error \"expected 'match' before 'simd'\" } */\n+void f7 (void);\n+#pragma omp declare variant (f1) match\t/* { dg-error \"expected '\\\\(' before end of line\" } */\n+void f8 (void);\n+#pragma omp declare variant (f1) match(\t/* { dg-error \"expected 'construct', 'device', 'implementation' or 'user' before end of line\" } */\n+void f9 (void);\n+#pragma omp declare variant (f1) match()\t/* { dg-error \"expected 'construct', 'device', 'implementation' or 'user' before '\\\\)' token\" } */\n+void f10 (void);\n+#pragma omp declare variant (f1) match(foo)\t/* { dg-error \"expected 'construct', 'device', 'implementation' or 'user' before 'foo'\" } */\n+void f11 (void);\n+#pragma omp declare variant (f1) match(something={something})\t/* { dg-error \"expected 'construct', 'device', 'implementation' or 'user' before 'something'\" } */\n+void f12 (void);\n+#pragma omp declare variant (f1) match(user)\t/* { dg-error \"expected '=' before '\\\\)' token\" } */\n+void f13 (void);\n+#pragma omp declare variant (f1) match(user=)\t/* { dg-error \"expected '\\\\\\{' before '\\\\)' token\" } */\n+void f14 (void);\n+#pragma omp declare variant (f1) match(user=\t/* { dg-error \"expected '\\\\\\{' before end of line\" } */\n+void f15 (void);\n+#pragma omp declare variant (f1) match(user={)\t/* { dg-error \"expected trait selector name before '\\\\)' token\" } */\n+void f16 (void);\t\t\t\t/* { dg-error \"expected '\\\\\\}' before\" \"\" { target c++ } .-1 } */\n+#pragma omp declare variant (f1) match(user={})\t/* { dg-error \"expected trait selector name before '\\\\\\}' token\" } */\n+void f17 (void);\n+#pragma omp declare variant (f1) match(user={condition})\t/* { dg-error \"expected '\\\\(' before '\\\\\\}' token\" } */\n+void f18 (void);\n+#pragma omp declare variant (f1) match(user={condition(})\t/* { dg-error \"expected \\[^\\n\\r]*expression before '\\\\\\}' token\" } */\n+void f19 (void);\t\t\t\t\t\t/* { dg-error \"expected '\\\\)' before '\\\\\\}' token\" \"\" { target c++ } .-1 } */\n+#pragma omp declare variant (f1) match(user={condition()})\t/* { dg-error \"expected \\[^\\n\\r]*expression before '\\\\)' token\" } */\n+void f20 (void);\n+#pragma omp declare variant (f1) match(user={condition(f1)})\t/* { dg-error \"property must be constant integer expression\" \"\" { target { c || c++11 } } } */\n+void f21 (void);\t\t\t\t\t\t/* { dg-error \"cannot appear in a constant-expression\" \"\" { target c++98_only } .-1 } */\n+#pragma omp declare variant (f1) match(user={condition(1, 2, 3)})\t/* { dg-error \"expected '\\\\)' before ',' token\" } */\n+void f22 (void);\n+#pragma omp declare variant (f1) match(construct={master})\t/* { dg-error \"selector 'master' not allowed for context selector set 'construct'\" } */\n+void f23 (void);\n+#pragma omp declare variant (f1) match(construct={teams,parallel,master,for})\t/* { dg-error \"selector 'master' not allowed for context selector set 'construct'\" } */\n+void f24 (void);\t\t\t\t\t\t/* { dg-error \"expected '\\\\\\}' before ',' token\" \"\" { target c } .-1 } */\n+#pragma omp declare variant (f1) match(construct={parallel(1\t/* { dg-error \"selector 'parallel' does not accept any properties\" } */\n+void f25 (void);\t\t\t\t\t\t/* { dg-error \"expected '\\\\\\}' before end of line\" \"\" { target c++ } .-1 } */\n+\t\t\t\t\t\t\t\t/* { dg-error \"expected '\\\\\\}' before '\\\\(' token\" \"\" { target c } .-2 } */\n+#pragma omp declare variant (f1) match(construct={parallel(1)})\t/* { dg-error \"selector 'parallel' does not accept any properties\" } */\n+void f26 (void);\t\t\t\t\t\t\t/* { dg-error \"expected '\\\\\\}' before '\\\\(' token\" \"\" { target c } .-1 } */\n+#pragma omp declare variant (f1) match(construct={simd(12)})\t/* { dg-error \"expected \\[^\\n\\r]* clause before\" } */\n+void f27 (void);\t\t\t\t\t\t/* { dg-error \"'\\\\)' before numeric constant\" \"\" { target c++ } .-1 } */\n+#pragma omp declare variant (f1) match(construct={parallel},construct={for})\t/* { dg-error \"selector set 'construct' specified more than once\" } */\n+void f28 (void);\n+#pragma omp declare variant (f1) match(construct={parallel},construct={parallel})\t/* { dg-error \"selector set 'construct' specified more than once\" } */\n+void f29 (void);\n+#pragma omp declare variant (f1) match(user={condition(0)},construct={target},user={condition(0)})\t/* { dg-error \"selector set 'user' specified more than once\" } */\n+void f30 (void);\n+#pragma omp declare variant (f1) match(user={condition(0)},user={condition(1)})\t/* { dg-error \"selector set 'user' specified more than once\" } */\n+void f31 (void);\n+#pragma omp declare variant (f1) match(device={kind})\t/* { dg-error \"expected '\\\\(' before '\\\\\\}' token\" } */\n+void f32 (void);\n+#pragma omp declare variant (f1) match(device={isa})\t/* { dg-error \"expected '\\\\(' before '\\\\\\}' token\" } */\n+void f33 (void);\n+#pragma omp declare variant (f1) match(device={arch})\t/* { dg-error \"expected '\\\\(' before '\\\\\\}' token\" } */\n+void f34 (void);\n+#pragma omp declare variant (f1) match(device={kind,isa,arch})\t/* { dg-error \"expected '\\\\(' before ',' token\" } */\n+void f35 (void);\n+#pragma omp declare variant (f1) match(device={kind(})\t/* { dg-error \"expected identifier before '\\\\\\}' token\" } */\n+void f36 (void);\n+#pragma omp declare variant (f1) match(device={kind(unknown)})\t/* { dg-warning \"unknown property 'unknown' of 'kind' selector\" } */\n+void f37 (void);\n+#pragma omp declare variant (f1) match(device={kind(unknown,foobar)})\t/* { dg-warning \"unknown property 'unknown' of 'kind' selector\" } */\n+void f38 (void);\t\t\t\t\t\t\t/* { dg-warning \"unknown property 'foobar' of 'kind' selector\" \"\" { target *-*-* } .-1 } */\n+#pragma omp declare variant (f1) match(device={isa(1)})\t/* { dg-error \"expected identifier before numeric constant\" } */\n+void f39 (void);\n+#pragma omp declare variant (f1) match(device={arch(17)})\t/* { dg-error \"expected identifier before numeric constant\" } */\n+void f40 (void);\n+#pragma omp declare variant (f1) match(device={foobar(3)})\n+void f41 (void);\n+#pragma omp declare variant (f1) match(device={arch(x86_64)},device={isa(avx512vl)})\t/* { dg-error \"selector set 'device' specified more than once\" } */\n+void f42 (void);\n+#pragma omp declare variant (f1) match(implementation={foobar(3)})\n+void f43 (void);\n+#pragma omp declare variant (f1) match(implementation={vendor})\t/* { dg-error \"expected '\\\\(' before '\\\\\\}' token\" } */\n+void f44 (void);\n+#pragma omp declare variant (f1) match(implementation={extension})\t/* { dg-error \"expected '\\\\(' before '\\\\\\}' token\" } */\n+void f45 (void);\n+#pragma omp declare variant (f1) match(implementation={vendor()})\t/* { dg-error \"expected identifier before '\\\\)' token\" } */\n+void f45 (void);\n+#pragma omp declare variant (f1) match(implementation={vendor(123-234)})\t/* { dg-error \"expected identifier before numeric constant\" } */\n+void f46 (void);\n+#pragma omp declare variant (f1) match(implementation={vendor(\"x86_64\")})\t/* { dg-error \"expected identifier before string constant\" } */\n+void f47 (void);\n+#pragma omp declare variant (f1) match(implementation={unified_address(yes)})\t/* { dg-error \"selector 'unified_address' does not accept any properties\" } */\n+void f48 (void);\t\t\t\t\t\t\t\t/* { dg-error \"expected '\\\\\\}' before '\\\\(' token\" \"\" { target c } .-1 } */\n+#pragma omp declare variant (f1) match(implementation={unified_shared_memory(no)})\t/* { dg-error \"selector 'unified_shared_memory' does not accept any properties\" } */\n+void f49 (void);\t\t\t\t\t\t\t\t\t/* { dg-error \"expected '\\\\\\}' before '\\\\(' token\" \"\" { target c } .-1 } */\n+#pragma omp declare variant (f1) match(implementation={dynamic_allocators(42)})\t/* { dg-error \"selector 'dynamic_allocators' does not accept any properties\" } */\n+void f50 (void);\t\t\t\t\t\t\t\t/* { dg-error \"expected '\\\\\\}' before '\\\\(' token\" \"\" { target c } .-1 } */\n+#pragma omp declare variant (f1) match(implementation={reverse_offload()})\t/* { dg-error \"selector 'reverse_offload' does not accept any properties\" } */\n+void f51 (void);\t\t\t\t\t\t\t\t/* { dg-error \"expected '\\\\\\}' before '\\\\(' token\" \"\" { target c } .-1 } */\n+#pragma omp declare variant (f1) match(implementation={atomic_default_mem_order})\t/* { dg-error \"expected '\\\\(' before '\\\\\\}' token\" } */\n+void f52 (void);\n+#pragma omp declare variant (f1) match(implementation={atomic_default_mem_order(acquire)})\t/* { dg-error \"incorrect property 'acquire' of 'atomic_default_mem_order' selector\" } */\n+void f53 (void);\n+#pragma omp declare variant (f1) match(implementation={atomic_default_mem_order(release)})\t/* { dg-error \"incorrect property 'release' of 'atomic_default_mem_order' selector\" } */\n+void f54 (void);\n+#pragma omp declare variant (f1) match(implementation={atomic_default_mem_order(foobar)})\t/* { dg-error \"incorrect property 'foobar' of 'atomic_default_mem_order' selector\" } */\n+void f55 (void);\n+#pragma omp declare variant (f1) match(implementation={atomic_default_mem_order(relaxed,seq_cst)})\t/* { dg-error \"'atomic_default_mem_order' selector must have a single property\" } */\n+void f56 (void);\n+#pragma omp declare variant (f1) match(implementation={atomic_default_mem_order(relaxed)},implementation={atomic_default_mem_order(relaxed)})\t/* { dg-error \"selector set 'implementation' specified more than once\" } */\n+void f57 (void);\n+#pragma omp declare variant (f1) match(user={foobar(3)})\t/* { dg-error \"selector 'foobar' not allowed for context selector set 'user'\" } */\n+void f58 (void);\t\t\t\t\t\t/* { dg-error \"expected '\\\\\\}' before '\\\\(' token\" \"\" { target c } .-1 } */\n+#pragma omp declare variant (f1) match(construct={foobar(3)})\t/* { dg-error \"selector 'foobar' not allowed for context selector set 'construct'\" } */\n+void f59 (void);\t\t\t\t\t\t/* { dg-error \"expected '\\\\\\}' before '\\\\(' token\" \"\" { target c } .-1 } */\n+#pragma omp declare variant (f1) match(construct={parallel},foobar={bar})\t/* { dg-error \"expected 'construct', 'device', 'implementation' or 'user' before 'foobar'\" } */\n+void f60 (void);"}, {"sha": "34a2a06db1b79e345feea0265293a4f5d7c34a80", "filename": "gcc/testsuite/c-c++-common/gomp/declare-variant-3.c", "status": "added", "additions": 141, "deletions": 0, "changes": 141, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94e7f906ca5c73fb79d21ec54733e9e75a96c2b4/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Fdeclare-variant-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94e7f906ca5c73fb79d21ec54733e9e75a96c2b4/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Fdeclare-variant-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Fdeclare-variant-3.c?ref=94e7f906ca5c73fb79d21ec54733e9e75a96c2b4", "patch": "@@ -0,0 +1,141 @@\n+void f1 (void);\n+#pragma omp declare variant (f1) match (construct={target})\n+void f2 (void);\n+void f3 (void);\n+#pragma omp declare variant (f3) match (construct={teams})\n+void f4 (void);\n+void f5 (void);\n+#pragma omp declare variant (f5) match (construct={parallel})\n+void f6 (void);\n+void f7 (void);\n+#pragma omp declare variant (f7) match (construct={for})\n+void f8 (void);\n+void f9 (void);\n+#pragma omp declare variant (f9) match (construct={target,teams,parallel,for})\n+void f10 (void);\n+void f11 (void);\n+#pragma omp declare variant (f11) match (construct={teams,for,parallel})\n+void f12 (void);\n+void f13 (void);\n+#pragma omp declare variant (f13) match (device={kind(any)})\n+void f14 (void);\n+#pragma omp declare variant (f13) match (device={kind(host)})\n+void f15 (void);\n+#pragma omp declare variant (f13) match (device={kind(nohost)})\n+void f16 (void);\n+#pragma omp declare variant (f13) match (device={kind(cpu)})\n+void f17 (void);\n+#pragma omp declare variant (f13) match (device={kind(gpu)})\n+void f18 (void);\n+#pragma omp declare variant (f13) match (device={kind(fpga)})\n+void f19 (void);\n+#pragma omp declare variant (f13) match (device={kind(any,any)})\n+void f20 (void);\n+#pragma omp declare variant (f13) match (device={kind(host,nohost)})\n+void f21 (void);\n+#pragma omp declare variant (f13) match (device={kind(cpu,gpu,fpga)})\n+void f22 (void);\n+#pragma omp declare variant (f13) match (device={kind(any,cpu,nohost)})\n+void f23 (void);\n+#pragma omp declare variant (f13) match (device={isa(avx)})\n+void f24 (void);\n+#pragma omp declare variant (f13) match (device={isa(sse4,avx512f,avx512vl,avx512bw)})\n+void f25 (void);\n+#pragma omp declare variant (f13) match (device={arch(x86_64)})\n+void f26 (void);\n+#pragma omp declare variant (f13) match (device={arch(riscv64)})\n+void f27 (void);\n+#pragma omp declare variant (f13) match (device={arch(nvptx)})\n+void f28 (void);\n+#pragma omp declare variant (f13) match (device={arch(x86_64),isa(avx512f,avx512vl),kind(cpu)})\n+void f29 (void);\n+#pragma omp declare variant (f13) match (implementation={vendor(amd)})\n+void f30 (void);\n+#pragma omp declare variant (f13) match (implementation={vendor(arm)})\n+void f31 (void);\n+#pragma omp declare variant (f13) match (implementation={vendor(bsc)})\n+void f32 (void);\n+#pragma omp declare variant (f13) match (implementation={vendor(cray)})\n+void f33 (void);\n+#pragma omp declare variant (f13) match (implementation={vendor(fujitsu)})\n+void f34 (void);\n+#pragma omp declare variant (f13) match (implementation={vendor(gnu)})\n+void f35 (void);\n+#pragma omp declare variant (f13) match (implementation={vendor(ibm)})\n+void f36 (void);\n+#pragma omp declare variant (f13) match (implementation={vendor(intel)})\n+void f37 (void);\n+#pragma omp declare variant (f13) match (implementation={vendor(llvm)})\n+void f38 (void);\n+#pragma omp declare variant (f13) match (implementation={vendor(pgi)})\n+void f39 (void);\n+#pragma omp declare variant (f13) match (implementation={vendor(ti)})\n+void f40 (void);\n+#pragma omp declare variant (f13) match (implementation={vendor(unknown)})\n+void f41 (void);\n+#pragma omp declare variant (f13) match (implementation={vendor(gnu,llvm,intel,ibm)})\n+void f42 (void);\n+#pragma omp declare variant (f13) match (implementation={extension(my_cute_extension)})\t/* { dg-warning \"unknown property 'my_cute_extension' of 'extension' selector\" } */\n+void f43 (void);\n+#pragma omp declare variant (f13) match (implementation={extension(some_other_ext,another_ext)})\t/* { dg-warning \"unknown property 'some_other_ext' of 'extension' selector\" } */\n+void f44 (void);\t\t\t\t\t\t\t\t\t\t\t/* { dg-warning \"unknown property 'another_ext' of 'extension' selector\" \"\" { target *-*-* } .-1 } */\n+#pragma omp declare variant (f13) match (implementation={unified_shared_memory})\n+void f45 (void);\n+#pragma omp declare variant (f13) match (implementation={unified_address})\n+void f46 (void);\n+#pragma omp declare variant (f13) match (implementation={dynamic_allocators})\n+void f47 (void);\n+#pragma omp declare variant (f13) match (implementation={reverse_offload})\n+void f48 (void);\n+#pragma omp declare variant (f13) match (implementation={atomic_default_mem_order(seq_cst)})\n+void f49 (void);\n+#pragma omp declare variant (f13) match (implementation={atomic_default_mem_order(relaxed)})\n+void f50 (void);\n+#pragma omp declare variant (f13) match (implementation={atomic_default_mem_order(acq_rel)})\n+void f51 (void);\n+#pragma omp declare variant (f14) match (implementation={atomic_default_mem_order(acq_rel),vendor(gnu),unified_address,extension(foobar)})\t/* { dg-warning \"unknown property 'foobar' of 'extension' selector\" } */\n+void f52 (void);\n+#pragma omp declare variant (f13) match (implementation={vendor(score(3):amd)})\n+void f53 (void);\n+#pragma omp declare variant (f13) match (implementation={vendor(score(4):arm)})\n+void f54 (void);\n+#pragma omp declare variant (f13) match (implementation={vendor(score(5):bsc)})\n+void f55 (void);\n+#pragma omp declare variant (f13) match (implementation={vendor(score(6):cray)})\n+void f56 (void);\n+#pragma omp declare variant (f13) match (implementation={vendor(score(7):fujitsu)})\n+void f57 (void);\n+#pragma omp declare variant (f13) match (implementation={vendor(score(8):gnu)})\n+void f58 (void);\n+#pragma omp declare variant (f13) match (implementation={vendor(score(9):ibm)})\n+void f59 (void);\n+#pragma omp declare variant (f13) match (implementation={vendor(score(10):intel)})\n+void f60 (void);\n+#pragma omp declare variant (f13) match (implementation={vendor(score(11):llvm)})\n+void f61 (void);\n+#pragma omp declare variant (f13) match (implementation={vendor(score(12):pgi)})\n+void f62 (void);\n+#pragma omp declare variant (f13) match (implementation={vendor(score(13):ti)})\n+void f63 (void);\n+#pragma omp declare variant (f13) match (implementation={vendor(score(14):unknown)})\n+void f64 (void);\n+#pragma omp declare variant (f13) match (implementation={vendor(score(15):gnu,llvm,intel,ibm)})\n+void f65 (void);\n+#pragma omp declare variant (f13) match (implementation={extension(score(16):my_cute_extension)})\t/* { dg-warning \"unknown property 'my_cute_extension' of 'extension' selector\" } */\n+void f66 (void);\n+#pragma omp declare variant (f13) match (implementation={extension(score(17):some_other_ext,another_ext)})\t/* { dg-warning \"unknown property 'some_other_ext' of 'extension' selector\" } */\n+void f67 (void);\t\t\t\t\t\t\t\t\t\t\t\t/* { dg-warning \"unknown property 'another_ext' of 'extension' selector\" \"\" { target *-*-* } .-1 } */\n+#pragma omp declare variant (f13) match (implementation={atomic_default_mem_order(score(18):seq_cst)})\n+void f68 (void);\n+#pragma omp declare variant (f13) match (implementation={atomic_default_mem_order(score(19):relaxed)})\n+void f69 (void);\n+#pragma omp declare variant (f13) match (implementation={atomic_default_mem_order(score(20):acq_rel)})\n+void f70 (void);\n+#pragma omp declare variant (f13) match (implementation={atomic_default_mem_order(score(21):acq_rel),vendor(score(22):gnu),unified_address,extension(score(22):foobar)})\t/* { dg-warning \"unknown property 'foobar' of 'extension' selector\" } */\n+void f71 (void);\n+#pragma omp declare variant (f13) match (user={condition(0)})\n+void f72 (void);\n+#pragma omp declare variant (f13) match (user={condition(272-272*1)})\n+void f73 (void);\n+#pragma omp declare variant (f13) match (user={condition(score(25):1)})\n+void f74 (void);"}, {"sha": "30ab8b3903cc4c8b7e105663d4ec96bb7fce4911", "filename": "gcc/testsuite/g++.dg/gomp/this-1.C", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94e7f906ca5c73fb79d21ec54733e9e75a96c2b4/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Fthis-1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94e7f906ca5c73fb79d21ec54733e9e75a96c2b4/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Fthis-1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Fthis-1.C?ref=94e7f906ca5c73fb79d21ec54733e9e75a96c2b4", "patch": "@@ -3,7 +3,7 @@\n \n struct S\n {\n-  #pragma omp declare simd linear(this)\t\t// { dg-error \"is not an function argument\" }\n+  #pragma omp declare simd linear(this)\t\t// { dg-error \"is not a function argument\" }\n   static void foo ();\n   void bar ();\n };\n@@ -35,7 +35,7 @@ S::bar ()\n template <int N>\n struct T\n {\n-  #pragma omp declare simd linear(this)\t\t// { dg-error \"is not an function argument\" }\n+  #pragma omp declare simd linear(this)\t\t// { dg-error \"is not a function argument\" }\n   static void foo ();\n   void bar ();\n };"}, {"sha": "9b20cfef8c7a7c74c603c3d14fbbd93bbbff8d44", "filename": "gcc/testsuite/gcc.dg/gomp/declare-variant-1.c", "status": "added", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94e7f906ca5c73fb79d21ec54733e9e75a96c2b4/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Fdeclare-variant-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94e7f906ca5c73fb79d21ec54733e9e75a96c2b4/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Fdeclare-variant-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Fdeclare-variant-1.c?ref=94e7f906ca5c73fb79d21ec54733e9e75a96c2b4", "patch": "@@ -0,0 +1,41 @@\n+/* Test parsing of #pragma omp declare variant */\n+/* { dg-do compile } */\n+\n+int fn0 (int);\n+int fn6 (int);\n+\n+#pragma omp declare variant (fn0) match (user={condition(0)})\n+int a;\t/* { dg-error \"not immediately followed by a function declaration or definition\" } */\n+\n+#pragma omp declare variant (fn0) match (user={condition(0)})\n+int fn1 (int a), fn2 (int a);\t/* { dg-error \"not immediately followed by a single function declaration or definition\" } */\n+\n+#pragma omp declare variant (fn0) match (user={condition(0)})\n+int b, fn3 (int a);\t/* { dg-error \"not immediately followed by a function declaration or definition\" } */\n+\n+#pragma omp declare variant (fn0) match (user={condition(0)})\n+int fn4 (int a), c;\t/* { dg-error \"not immediately followed by a function declaration or definition\" } */\n+\n+int t;\n+\n+#pragma omp declare variant (fn0) match (user={condition(0)})\n+#pragma omp declare variant (fn6) match (implementation={vendor(unknown)})\n+#pragma omp threadprivate(t)\t/* { dg-error \"must be followed by function declaration or definition or another\" } */\n+int fn5 (int a);\n+\n+#pragma omp declare variant (1 + 2) match (user={condition(0)})\t/* { dg-error \"expected identifier before numeric constant\" } */\n+int fn7 (int);\n+\n+#pragma omp declare variant (t) match (user={condition(0)})\t/* { dg-error \"variant 't' is not a function\" } */\n+int fn8 (int);\n+\n+long fn9 (char, short);\n+\n+#pragma omp declare variant (fn9) match (implementation={vendor(unknown)})\t/* { dg-error \"variant 'fn9' and base 'fn10' have incompatible types\" } */\n+int fn10 (int, long long);\n+\n+#pragma omp declare variant (memcpy) match (implementation={vendor(llvm)})\t/* { dg-error \"'memcpy' undeclared here\" } */\n+void *fn11 (void *, const void *, __SIZE_TYPE__);\n+\n+#pragma omp declare variant (__builtin_memmove) match (implementation={vendor(gnu)})\t/* { dg-error \"variant '__builtin_memmove' is a built-in\" } */\n+void *fn12 (void *, const void *, __SIZE_TYPE__);"}, {"sha": "701d83b0ec37b4cdf056f9074a880bfd3c95e43e", "filename": "gcc/testsuite/gcc.dg/gomp/declare-variant-2.c", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94e7f906ca5c73fb79d21ec54733e9e75a96c2b4/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Fdeclare-variant-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94e7f906ca5c73fb79d21ec54733e9e75a96c2b4/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Fdeclare-variant-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Fdeclare-variant-2.c?ref=94e7f906ca5c73fb79d21ec54733e9e75a96c2b4", "patch": "@@ -0,0 +1,22 @@\n+/* Test parsing of #pragma omp declare variant */\n+/* { dg-do compile } */\n+\n+int f0 (int, int *, int);\n+\n+int\n+f1 (int x)\n+{\n+  if (x)\n+    #pragma omp declare variant (fn0) match (user={condition(0)})\n+    extern int f3 (int a, int *b, int c);\t/* { dg-error \"must be followed by function declaration or definition\" } */\n+  while (x < 10)\n+    #pragma omp declare variant (fn0) match (user={condition(0)})\n+    extern int f4 (int a, int *b, int c);\t/* { dg-error \"must be followed by function declaration or definition\" } */\n+  {\n+lab:\n+    #pragma omp declare variant (fn0) match (user={condition(0)})\n+    extern int f5 (int a, int *b, int c);\t/* { dg-error \"must be followed by function declaration or definition\" } */\n+    x++;\t\t\t\t\t/* { dg-error \"expected expression before\" \"\" { target *-*-* } .-1 } */\n+  }\n+  return x;\n+}"}]}