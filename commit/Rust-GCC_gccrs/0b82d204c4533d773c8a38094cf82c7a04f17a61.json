{"sha": "0b82d204c4533d773c8a38094cf82c7a04f17a61", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MGI4MmQyMDRjNDUzM2Q3NzNjOGEzODA5NGNmODJjN2EwNGYxN2E2MQ==", "commit": {"author": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2002-03-13T19:48:29Z"}, "committer": {"name": "Jakub Jelinek", "email": "jakub@gcc.gnu.org", "date": "2002-03-13T19:48:29Z"}, "message": "re PR target/5626 (gcc-3.1 on sparcv9 does not generate code for long jumps)\n\n\tPR target/5626\n\t* config/sparc/sparc.md (normal_branch, inverted_branch,\n\tnormal_fp_branch, inverted_fp_branch, normal_fpe_branch,\n\tinverted_fp_branch): Adjust calls to output_cbranch.\n\tSet length attribute.\n\t(normal_int_branch_sp64, inverted_int_branch_sp64): Adjust calls to\n\toutput_v9branch.  Set length attribute.\n\t* config/sparc/sparc.c (fcc0_reg_operand, noov_compare64_op): New\n\tpredicates.\n\t(noov_compare_op): Handle CCX_NOOVmode the same way as CC_NOOVmode.\n\t(output_cbranch): Likewise.  Handle far branches.\n\t(output_v9branch): Handle far branches.\n\t* config/sparc/sparc-protos.h (output_cbranch, output_v9branch):\n\tAdjust prototypes.\n\t* config/sparc/sparc.h (PREDICATE_CODES): Add fcc0_reg_operand and\n\tnoov_compare64_op predicates.\n\nFrom-SVN: r50753", "tree": {"sha": "ca5b4670920d0459a567dfef299745cad91e024c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ca5b4670920d0459a567dfef299745cad91e024c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0b82d204c4533d773c8a38094cf82c7a04f17a61", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0b82d204c4533d773c8a38094cf82c7a04f17a61", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0b82d204c4533d773c8a38094cf82c7a04f17a61", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0b82d204c4533d773c8a38094cf82c7a04f17a61/comments", "author": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "56668fb05b1b64db231909ad195e1d74aad12f9e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/56668fb05b1b64db231909ad195e1d74aad12f9e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/56668fb05b1b64db231909ad195e1d74aad12f9e"}], "stats": {"total": 428, "additions": 345, "deletions": 83}, "files": [{"sha": "4286a2112cbdf6f3ed2ab878b43722e7cefad63c", "filename": "gcc/ChangeLog", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0b82d204c4533d773c8a38094cf82c7a04f17a61/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0b82d204c4533d773c8a38094cf82c7a04f17a61/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=0b82d204c4533d773c8a38094cf82c7a04f17a61", "patch": "@@ -1,3 +1,22 @@\n+2002-03-13  Jakub Jelinek  <jakub@redhat.com>\n+\n+\tPR target/5626\n+\t* config/sparc/sparc.md (normal_branch, inverted_branch,\n+\tnormal_fp_branch, inverted_fp_branch, normal_fpe_branch,\n+\tinverted_fp_branch): Adjust calls to output_cbranch.\n+\tSet length attribute.\n+\t(normal_int_branch_sp64, inverted_int_branch_sp64): Adjust calls to\n+\toutput_v9branch.  Set length attribute.\n+\t* config/sparc/sparc.c (fcc0_reg_operand, noov_compare64_op): New\n+\tpredicates.\n+\t(noov_compare_op): Handle CCX_NOOVmode the same way as CC_NOOVmode.\n+\t(output_cbranch): Likewise.  Handle far branches.\n+\t(output_v9branch): Handle far branches.\n+\t* config/sparc/sparc-protos.h (output_cbranch, output_v9branch):\n+\tAdjust prototypes.\n+\t* config/sparc/sparc.h (PREDICATE_CODES): Add fcc0_reg_operand and\n+\tnoov_compare64_op predicates.\n+\n 2002-03-13  Jason Merrill  <jason@redhat.com>\n \n \t* gthr-posix.h (__gthread_active_p): Move __gthread_active_ptr"}, {"sha": "682b7bdb8533e5e57c1b5bba4277eca01cae1f3c", "filename": "gcc/config/sparc/sparc-protos.h", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0b82d204c4533d773c8a38094cf82c7a04f17a61/gcc%2Fconfig%2Fsparc%2Fsparc-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0b82d204c4533d773c8a38094cf82c7a04f17a61/gcc%2Fconfig%2Fsparc%2Fsparc-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fsparc-protos.h?ref=0b82d204c4533d773c8a38094cf82c7a04f17a61", "patch": "@@ -85,10 +85,11 @@ extern void sparc_emit_set_const64 PARAMS ((rtx, rtx));\n extern void sparc_emit_set_symbolic_const64 PARAMS ((rtx, rtx, rtx));\n extern int sparc_splitdi_legitimate PARAMS ((rtx, rtx));\n extern int sparc_absnegfloat_split_legitimate PARAMS ((rtx, rtx));\n-extern char *output_cbranch PARAMS ((rtx, int, int, int, int, rtx));\n+extern char *output_cbranch PARAMS ((rtx, rtx, int, int, int, int, rtx));\n extern const char *output_return PARAMS ((rtx *));\n extern const char *output_sibcall PARAMS ((rtx, rtx));\n-extern char *output_v9branch PARAMS ((rtx, int, int, int, int, int, rtx));\n+extern char *output_v9branch PARAMS ((rtx, rtx, int, int, int, int, int,\n+\t\t\t\t      rtx));\n extern void emit_v9_brxx_insn PARAMS ((enum rtx_code, rtx, rtx));\n extern void print_operand PARAMS ((FILE *, rtx, int));\n extern int mems_ok_for_ldd_peep PARAMS ((rtx, rtx, rtx));"}, {"sha": "6f33bcc0cb920c673c69b73762d79dc4b8f54d52", "filename": "gcc/config/sparc/sparc.c", "status": "modified", "additions": 213, "deletions": 65, "changes": 278, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0b82d204c4533d773c8a38094cf82c7a04f17a61/gcc%2Fconfig%2Fsparc%2Fsparc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0b82d204c4533d773c8a38094cf82c7a04f17a61/gcc%2Fconfig%2Fsparc%2Fsparc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fsparc.c?ref=0b82d204c4533d773c8a38094cf82c7a04f17a61", "patch": "@@ -608,6 +608,27 @@ fcc_reg_operand (op, mode)\n #endif\n }\n \n+/* Nonzero if OP is a floating point condition code fcc0 register.  */\n+\n+int\n+fcc0_reg_operand (op, mode)\n+     rtx op;\n+     enum machine_mode mode;\n+{\n+  /* This can happen when recog is called from combine.  Op may be a MEM.\n+     Fail instead of calling abort in this case.  */\n+  if (GET_CODE (op) != REG)\n+    return 0;\n+\n+  if (mode != VOIDmode && mode != GET_MODE (op))\n+    return 0;\n+  if (mode == VOIDmode\n+      && (GET_MODE (op) != CCFPmode && GET_MODE (op) != CCFPEmode))\n+    return 0;\n+\n+  return REGNO (op) == SPARC_FCC_REG;\n+}\n+\n /* Nonzero if OP is an integer or floating point condition code register.  */\n \n int\n@@ -878,12 +899,35 @@ noov_compare_op (op, mode)\n   if (GET_RTX_CLASS (code) != '<')\n     return 0;\n \n-  if (GET_MODE (XEXP (op, 0)) == CC_NOOVmode)\n+  if (GET_MODE (XEXP (op, 0)) == CC_NOOVmode\n+      || GET_MODE (XEXP (op, 0)) == CCX_NOOVmode)\n     /* These are the only branches which work with CC_NOOVmode.  */\n     return (code == EQ || code == NE || code == GE || code == LT);\n   return 1;\n }\n \n+/* Return 1 if this is a 64-bit comparison operator.  This allows the use of\n+   MATCH_OPERATOR to recognize all the branch insns.  */\n+\n+int\n+noov_compare64_op (op, mode)\n+    register rtx op;\n+    enum machine_mode mode ATTRIBUTE_UNUSED;\n+{\n+  enum rtx_code code = GET_CODE (op);\n+\n+  if (! TARGET_V9)\n+    return 0;\n+\n+  if (GET_RTX_CLASS (code) != '<')\n+    return 0;\n+\n+  if (GET_MODE (XEXP (op, 0)) == CCX_NOOVmode)\n+    /* These are the only branches which work with CCX_NOOVmode.  */\n+    return (code == EQ || code == NE || code == GE || code == LT);\n+  return (GET_MODE (XEXP (op, 0)) == CCXmode);\n+}\n+\n /* Nonzero if OP is a comparison operator suitable for use in v9\n    conditional move or branch on register contents instructions.  */\n \n@@ -4996,25 +5040,43 @@ sparc_va_arg (valist, type)\n    INSN, if set, is the insn.  */\n \n char *\n-output_cbranch (op, label, reversed, annul, noop, insn)\n-     rtx op;\n+output_cbranch (op, dest, label, reversed, annul, noop, insn)\n+     rtx op, dest;\n      int label;\n      int reversed, annul, noop;\n      rtx insn;\n {\n-  static char string[32];\n+  static char string[50];\n   enum rtx_code code = GET_CODE (op);\n   rtx cc_reg = XEXP (op, 0);\n   enum machine_mode mode = GET_MODE (cc_reg);\n-  static char v8_labelno[] = \"%lX\";\n-  static char v9_icc_labelno[] = \"%%icc, %lX\";\n-  static char v9_xcc_labelno[] = \"%%xcc, %lX\";\n-  static char v9_fcc_labelno[] = \"%%fccX, %lY\";\n-  char *labelno;\n-  const char *branch;\n-  int labeloff, spaces = 8;\n+  const char *labelno, *branch;\n+  int spaces = 8, far;\n+  char *p;\n+\n+  /* v9 branches are limited to +-1MB.  If it is too far away,\n+     change\n+\n+     bne,pt %xcc, .LC30\n+\n+     to\n+\n+     be,pn %xcc, .+12\n+     nop\n+     ba .LC30\n+\n+     and\n+\n+     fbne,a,pn %fcc2, .LC29\n \n-  if (reversed)\n+     to\n+\n+     fbe,pt %fcc2, .+16\n+     nop\n+     ba .LC29  */\n+\n+  far = get_attr_length (insn) >= 3;\n+  if (reversed ^ far)\n     {\n       /* Reversal of FP compares takes care -- an ordered compare\n \t becomes an unordered compare and vice versa.  */\n@@ -5097,7 +5159,7 @@ output_cbranch (op, label, reversed, annul, noop, insn)\n \t  branch = \"be\";\n \t  break;\n \tcase GE:\n-\t  if (mode == CC_NOOVmode)\n+\t  if (mode == CC_NOOVmode || mode == CCX_NOOVmode)\n \t    branch = \"bpos\";\n \t  else\n \t    branch = \"bge\";\n@@ -5109,7 +5171,7 @@ output_cbranch (op, label, reversed, annul, noop, insn)\n \t  branch = \"ble\";\n \t  break;\n \tcase LT:\n-\t  if (mode == CC_NOOVmode)\n+\t  if (mode == CC_NOOVmode || mode == CCX_NOOVmode)\n \t    branch = \"bneg\";\n \t  else\n \t    branch = \"bl\";\n@@ -5133,54 +5195,89 @@ output_cbranch (op, label, reversed, annul, noop, insn)\n       strcpy (string, branch);\n     }\n   spaces -= strlen (branch);\n+  p = strchr (string, '\\0');\n \n   /* Now add the annulling, the label, and a possible noop.  */\n-  if (annul)\n+  if (annul && ! far)\n     {\n-      strcat (string, \",a\");\n+      strcpy (p, \",a\");\n+      p += 2;\n       spaces -= 2;\n     }\n \n   if (! TARGET_V9)\n-    {\n-      labeloff = 2;\n-      labelno = v8_labelno;\n-    }\n+    labelno = \"\";\n   else\n     {\n       rtx note;\n+      int v8 = 0;\n \n-      if (insn && (note = find_reg_note (insn, REG_BR_PRED, NULL_RTX)))\n+      if (! far && insn && INSN_ADDRESSES_SET_P ())\n \t{\n-\t  strcat (string,\n-\t\t  INTVAL (XEXP (note, 0)) & ATTR_FLAG_likely ? \",pt\" : \",pn\");\n-\t  spaces -= 3;\n+\t  int delta = (INSN_ADDRESSES (INSN_UID (dest))\n+\t\t       - INSN_ADDRESSES (INSN_UID (insn)));\n+\t  /* Leave some instructions for \"slop\".  */\n+\t  if (delta < -260000 || delta >= 260000)\n+\t    v8 = 1;\n \t}\n \n-      labeloff = 9;\n       if (mode == CCFPmode || mode == CCFPEmode)\n \t{\n-\t  labeloff = 10;\n-\t  labelno = v9_fcc_labelno;\n+\t  static char v9_fcc_labelno[] = \"%%fccX, \";\n \t  /* Set the char indicating the number of the fcc reg to use.  */\n-\t  labelno[5] = REGNO (cc_reg) - SPARC_FIRST_V9_FCC_REG + '0';\n+\t  v9_fcc_labelno[5] = REGNO (cc_reg) - SPARC_FIRST_V9_FCC_REG + '0';\n+\t  labelno = v9_fcc_labelno;\n+\t  if (v8)\n+\t    {\n+\t      if (REGNO (cc_reg) == SPARC_FCC_REG)\n+\t\tlabelno = \"\";\n+\t      else\n+\t\tabort ();\n+\t    }\n \t}\n       else if (mode == CCXmode || mode == CCX_NOOVmode)\n-\tlabelno = v9_xcc_labelno;\n+\t{\n+\t  labelno = \"%%xcc, \";\n+\t  if (v8)\n+\t    abort ();\n+\t}\n       else\n-\tlabelno = v9_icc_labelno;\n+\t{\n+\t  labelno = \"%%icc, \";\n+\t  if (v8)\n+\t    labelno = \"\";\n+\t}\n+\n+      if (*labelno && insn && (note = find_reg_note (insn, REG_BR_PRED, NULL_RTX)))\n+\t{\n+\t  strcpy (p,\n+\t\t  (((INTVAL (XEXP (note, 0)) & ATTR_FLAG_likely) != 0) ^ far)\n+\t\t  ? \",pt\" : \",pn\");\n+\t  p += 3;\n+\t  spaces -= 3;\n+\t}\n     }\n-  /* Set the char indicating the number of the operand containing the\n-     label_ref.  */\n-  labelno[labeloff] = label + '0';\n   if (spaces > 0)\n-    strcat (string, \"\\t\");\n+    *p++ = '\\t';\n   else\n-    strcat (string, \" \");\n-  strcat (string, labelno);\n-\n+    *p++ = ' ';\n+  strcpy (p, labelno);\n+  p = strchr (p, '\\0');\n+  if (far)\n+    {\n+      strcpy (p, \".+12\\n\\tnop\\n\\tb\\t\");\n+      if (annul || noop)\n+        p[3] = '6';\n+      p += 13;\n+    }\n+  *p++ = '%';\n+  *p++ = 'l';\n+  /* Set the char indicating the number of the operand containing the\n+     label_ref.  */\n+  *p++ = label + '0';\n+  *p = '\\0';\n   if (noop)\n-    strcat (string, \"\\n\\tnop\");\n+    strcpy (p, \"\\n\\tnop\");\n \n   return string;\n }\n@@ -5338,22 +5435,45 @@ sparc_emit_float_lib_cmp (x, y, comparison)\n    NOOP is non-zero if we have to follow this branch by a noop.  */\n \n char *\n-output_v9branch (op, reg, label, reversed, annul, noop, insn)\n-     rtx op;\n+output_v9branch (op, dest, reg, label, reversed, annul, noop, insn)\n+     rtx op, dest;\n      int reg, label;\n      int reversed, annul, noop;\n      rtx insn;\n {\n-  static char string[20];\n+  static char string[50];\n   enum rtx_code code = GET_CODE (op);\n   enum machine_mode mode = GET_MODE (XEXP (op, 0));\n-  static char labelno[] = \"%X, %lX\";\n   rtx note;\n-  int spaces = 8;\n+  int far;\n+  char *p;\n+\n+  /* branch on register are limited to +-128KB.  If it is too far away,\n+     change\n+     \n+     brnz,pt %g1, .LC30\n+     \n+     to\n+     \n+     brz,pn %g1, .+12\n+     nop\n+     ba,pt %xcc, .LC30\n+     \n+     and\n+     \n+     brgez,a,pn %o1, .LC29\n+     \n+     to\n+     \n+     brlz,pt %o1, .+16\n+     nop\n+     ba,pt %xcc, .LC29  */\n+\n+  far = get_attr_length (insn) >= 3;\n \n   /* If not floating-point or if EQ or NE, we can just reverse the code.  */\n-  if (reversed)\n-    code = reverse_condition (code), reversed = 0;\n+  if (reversed ^ far)\n+    code = reverse_condition (code);\n \n   /* Only 64 bit versions of these instructions exist.  */\n   if (mode != DImode)\n@@ -5365,62 +5485,90 @@ output_v9branch (op, reg, label, reversed, annul, noop, insn)\n     {\n     case NE:\n       strcpy (string, \"brnz\");\n-      spaces -= 4;\n       break;\n \n     case EQ:\n       strcpy (string, \"brz\");\n-      spaces -= 3;\n       break;\n \n     case GE:\n       strcpy (string, \"brgez\");\n-      spaces -= 5;\n       break;\n \n     case LT:\n       strcpy (string, \"brlz\");\n-      spaces -= 4;\n       break;\n \n     case LE:\n       strcpy (string, \"brlez\");\n-      spaces -= 5;\n       break;\n \n     case GT:\n       strcpy (string, \"brgz\");\n-      spaces -= 4;\n       break;\n \n     default:\n       abort ();\n     }\n \n+  p = strchr (string, '\\0');\n+\n   /* Now add the annulling, reg, label, and nop.  */\n-  if (annul)\n+  if (annul && ! far)\n     {\n-      strcat (string, \",a\");\n-      spaces -= 2;\n+      strcpy (p, \",a\");\n+      p += 2;\n     }\n \n   if (insn && (note = find_reg_note (insn, REG_BR_PRED, NULL_RTX)))\n     {\n-      strcat (string,\n-\t      INTVAL (XEXP (note, 0)) & ATTR_FLAG_likely ? \",pt\" : \",pn\");\n-      spaces -= 3;\n+      strcpy (p,\n+\t      (((INTVAL (XEXP (note, 0)) & ATTR_FLAG_likely) != 0) ^ far)\n+\t      ? \",pt\" : \",pn\");\n+      p += 3;\n     }\n \n-  labelno[1] = reg + '0';\n-  labelno[6] = label + '0';\n-  if (spaces > 0)\n-    strcat (string, \"\\t\");\n-  else\n-    strcat (string, \" \");\n-  strcat (string, labelno);\n+  *p = p < string + 8 ? '\\t' : ' ';\n+  p++;\n+  *p++ = '%';\n+  *p++ = '0' + reg;\n+  *p++ = ',';\n+  *p++ = ' ';\n+  if (far)\n+    {\n+      int veryfar = 1, delta;\n+\n+      if (INSN_ADDRESSES_SET_P ())\n+\t{\n+\t  delta = (INSN_ADDRESSES (INSN_UID (dest))\n+\t\t   - INSN_ADDRESSES (INSN_UID (insn)));\n+\t  /* Leave some instructions for \"slop\".  */\n+\t  if (delta >= -260000 && delta < 260000)\n+\t    veryfar = 0;\n+\t}\n+\n+      strcpy (p, \".+12\\n\\tnop\\n\\t\");\n+      if (annul || noop)\n+        p[3] = '6';\n+      p += 11;\n+      if (veryfar)\n+\t{\n+\t  strcpy (p, \"b\\t\");\n+\t  p += 2;\n+\t}\n+      else\n+\t{\n+\t  strcpy (p, \"ba,pt\\t%%xcc, \");\n+\t  p += 13;\n+\t}\n+    }\n+  *p++ = '%';\n+  *p++ = 'l';\n+  *p++ = '0' + label;\n+  *p = '\\0';\n \n   if (noop)\n-    strcat (string, \"\\n\\tnop\");\n+    strcpy (p, \"\\n\\tnop\");\n \n   return string;\n }"}, {"sha": "e765973c07d0bc0ac7cc4334ffcc68935f55e3d8", "filename": "gcc/config/sparc/sparc.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0b82d204c4533d773c8a38094cf82c7a04f17a61/gcc%2Fconfig%2Fsparc%2Fsparc.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0b82d204c4533d773c8a38094cf82c7a04f17a61/gcc%2Fconfig%2Fsparc%2Fsparc.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fsparc.h?ref=0b82d204c4533d773c8a38094cf82c7a04f17a61", "patch": "@@ -2974,6 +2974,7 @@ do {\t\t\t\t\t\t\t\t\t\\\n {\"fp_zero_operand\", {CONST_DOUBLE}},\t\t\t\t\t\\\n {\"intreg_operand\", {SUBREG, REG}},\t\t\t\t\t\\\n {\"fcc_reg_operand\", {REG}},\t\t\t\t\t\t\\\n+{\"fcc0_reg_operand\", {REG}},\t\t\t\t\t\t\\\n {\"icc_or_fcc_reg_operand\", {REG}},\t\t\t\t\t\\\n {\"restore_operand\", {REG}},\t\t\t\t\t\t\\\n {\"call_operand\", {MEM}},\t\t\t\t\t\t\\\n@@ -2991,6 +2992,7 @@ do {\t\t\t\t\t\t\t\t\t\\\n {\"eq_or_neq\", {EQ, NE}},\t\t\t\t\t\t\\\n {\"normal_comp_operator\", {GE, GT, LE, LT, GTU, LEU}},\t\t\t\\\n {\"noov_compare_op\", {NE, EQ, GE, GT, LE, LT, GEU, GTU, LEU, LTU}},\t\\\n+{\"noov_compare64_op\", {NE, EQ, GE, GT, LE, LT, GEU, GTU, LEU, LTU}},\t\\\n {\"v9_regcmp_op\", {EQ, NE, GE, LT, LE, GT}},\t\t\t\t\\\n {\"extend_op\", {SIGN_EXTEND, ZERO_EXTEND}},\t\t\t\t\\\n {\"cc_arithop\", {AND, IOR, XOR}},\t\t\t\t\t\\"}, {"sha": "c203e4fa89208eabad641998415d07d67d3dfdaf", "filename": "gcc/config/sparc/sparc.md", "status": "modified", "additions": 108, "deletions": 16, "changes": 124, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0b82d204c4533d773c8a38094cf82c7a04f17a61/gcc%2Fconfig%2Fsparc%2Fsparc.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0b82d204c4533d773c8a38094cf82c7a04f17a61/gcc%2Fconfig%2Fsparc%2Fsparc.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fsparc.md?ref=0b82d204c4533d773c8a38094cf82c7a04f17a61", "patch": "@@ -1893,11 +1893,23 @@\n   \"\"\n   \"*\n {\n-  return output_cbranch (operands[0], 1, 0,\n+  return output_cbranch (operands[0], operands[1], 1, 0,\n \t\t\t final_sequence && INSN_ANNULLED_BRANCH_P (insn),\n \t\t\t ! final_sequence, insn);\n }\"\n-  [(set_attr \"type\" \"branch\")])\n+  [(set_attr \"type\" \"branch\")\n+   (set (attr \"length\")\n+\t(if_then_else (match_operand 0 \"noov_compare64_op\" \"\")\n+\t\t      (if_then_else (lt (pc) (match_dup 1))\n+\t\t\t\t    (if_then_else (lt (minus (match_dup 1) (pc))\n+\t\t\t\t\t\t      (const_int 260000))\n+\t\t\t\t\t\t  (const_int 1)\n+\t\t\t\t\t\t  (const_int 3))\n+\t\t\t\t    (if_then_else (lt (minus (pc) (match_dup 1))\n+\t\t\t\t\t\t      (const_int 260000))\n+\t\t\t\t\t\t  (const_int 1)\n+\t\t\t\t\t\t  (const_int 3)))\n+\t\t      (const_int 1)))])\n \n ;; XXX fpcmp nop braindamage\n (define_insn \"*inverted_branch\"\n@@ -1909,11 +1921,23 @@\n   \"\"\n   \"*\n {\n-  return output_cbranch (operands[0], 1, 1,\n+  return output_cbranch (operands[0], operands[1], 1, 1,\n \t\t\t final_sequence && INSN_ANNULLED_BRANCH_P (insn),\n \t\t\t ! final_sequence, insn);\n }\"\n-  [(set_attr \"type\" \"branch\")])\n+  [(set_attr \"type\" \"branch\")\n+   (set (attr \"length\")\n+\t(if_then_else (match_operand 0 \"noov_compare64_op\" \"\")\n+\t\t      (if_then_else (lt (pc) (match_dup 1))\n+\t\t\t\t    (if_then_else (lt (minus (match_dup 1) (pc))\n+\t\t\t\t\t\t      (const_int 260000))\n+\t\t\t\t\t\t  (const_int 1)\n+\t\t\t\t\t\t  (const_int 3))\n+\t\t\t\t    (if_then_else (lt (minus (pc) (match_dup 1))\n+\t\t\t\t\t\t      (const_int 260000))\n+\t\t\t\t\t\t  (const_int 1)\n+\t\t\t\t\t\t  (const_int 3)))\n+\t\t      (const_int 1)))])\n \n ;; XXX fpcmp nop braindamage\n (define_insn \"*normal_fp_branch\"\n@@ -1926,11 +1950,23 @@\n   \"\"\n   \"*\n {\n-  return output_cbranch (operands[1], 2, 0,\n+  return output_cbranch (operands[1], operands[2], 2, 0,\n \t\t\t final_sequence && INSN_ANNULLED_BRANCH_P (insn),\n \t\t\t ! final_sequence, insn);\n }\"\n-  [(set_attr \"type\" \"branch\")])\n+  [(set_attr \"type\" \"branch\")\n+   (set (attr \"length\")\n+\t(if_then_else (match_operand 0 \"fcc0_reg_operand\" \"\")\n+\t\t      (const_int 1)\n+\t\t      (if_then_else (lt (pc) (match_dup 2))\n+\t\t\t\t    (if_then_else (lt (minus (match_dup 2) (pc))\n+\t\t\t\t\t\t      (const_int 260000))\n+\t\t\t\t\t\t  (const_int 1)\n+\t\t\t\t\t\t  (const_int 3))\n+\t\t\t\t    (if_then_else (lt (minus (pc) (match_dup 2))\n+\t\t\t\t\t\t      (const_int 260000))\n+\t\t\t\t\t\t  (const_int 1)\n+\t\t\t\t\t\t  (const_int 3)))))])\n \n ;; XXX fpcmp nop braindamage\n (define_insn \"*inverted_fp_branch\"\n@@ -1943,11 +1979,23 @@\n   \"\"\n   \"*\n {\n-  return output_cbranch (operands[1], 2, 1,\n+  return output_cbranch (operands[1], operands[2], 2, 1,\n \t\t\t final_sequence && INSN_ANNULLED_BRANCH_P (insn),\n \t\t\t ! final_sequence, insn);\n }\"\n-  [(set_attr \"type\" \"branch\")])\n+  [(set_attr \"type\" \"branch\")\n+   (set (attr \"length\")\n+\t(if_then_else (match_operand 0 \"fcc0_reg_operand\" \"\")\n+\t\t      (const_int 1)\n+\t\t      (if_then_else (lt (pc) (match_dup 2))\n+\t\t\t\t    (if_then_else (lt (minus (match_dup 2) (pc))\n+\t\t\t\t\t\t      (const_int 260000))\n+\t\t\t\t\t\t  (const_int 1)\n+\t\t\t\t\t\t  (const_int 3))\n+\t\t\t\t    (if_then_else (lt (minus (pc) (match_dup 2))\n+\t\t\t\t\t\t      (const_int 260000))\n+\t\t\t\t\t\t  (const_int 1)\n+\t\t\t\t\t\t  (const_int 3)))))])\n \n ;; XXX fpcmp nop braindamage\n (define_insn \"*normal_fpe_branch\"\n@@ -1960,11 +2008,23 @@\n   \"\"\n   \"*\n {\n-  return output_cbranch (operands[1], 2, 0,\n+  return output_cbranch (operands[1], operands[2], 2, 0,\n \t\t\t final_sequence && INSN_ANNULLED_BRANCH_P (insn),\n \t\t\t ! final_sequence, insn);\n }\"\n-  [(set_attr \"type\" \"branch\")])\n+  [(set_attr \"type\" \"branch\")\n+   (set (attr \"length\")\n+\t(if_then_else (match_operand 0 \"fcc0_reg_operand\" \"\")\n+\t\t      (const_int 1)\n+\t\t      (if_then_else (lt (pc) (match_dup 2))\n+\t\t\t\t    (if_then_else (lt (minus (match_dup 2) (pc))\n+\t\t\t\t\t\t      (const_int 260000))\n+\t\t\t\t\t\t  (const_int 1)\n+\t\t\t\t\t\t  (const_int 3))\n+\t\t\t\t    (if_then_else (lt (minus (pc) (match_dup 2))\n+\t\t\t\t\t\t      (const_int 260000))\n+\t\t\t\t\t\t  (const_int 1)\n+\t\t\t\t\t\t  (const_int 3)))))])\n \n ;; XXX fpcmp nop braindamage\n (define_insn \"*inverted_fpe_branch\"\n@@ -1977,11 +2037,23 @@\n   \"\"\n   \"*\n {\n-  return output_cbranch (operands[1], 2, 1,\n+  return output_cbranch (operands[1], operands[2], 2, 1,\n \t\t\t final_sequence && INSN_ANNULLED_BRANCH_P (insn),\n \t\t\t ! final_sequence, insn);\n }\"\n-  [(set_attr \"type\" \"branch\")])\n+  [(set_attr \"type\" \"branch\")\n+   (set (attr \"length\")\n+\t(if_then_else (match_operand 0 \"fcc0_reg_operand\" \"\")\n+\t\t      (const_int 1)\n+\t\t      (if_then_else (lt (pc) (match_dup 2))\n+\t\t\t\t    (if_then_else (lt (minus (match_dup 2) (pc))\n+\t\t\t\t\t\t      (const_int 260000))\n+\t\t\t\t\t\t  (const_int 1)\n+\t\t\t\t\t\t  (const_int 3))\n+\t\t\t\t    (if_then_else (lt (minus (pc) (match_dup 2))\n+\t\t\t\t\t\t      (const_int 260000))\n+\t\t\t\t\t\t  (const_int 1)\n+\t\t\t\t\t\t  (const_int 3)))))])\n \n ;; Sparc V9-specific jump insns.  None of these are guaranteed to be\n ;; in the architecture.\n@@ -1999,11 +2071,21 @@\n   \"TARGET_ARCH64\"\n   \"*\n {\n-  return output_v9branch (operands[0], 1, 2, 0,\n+  return output_v9branch (operands[0], operands[2], 1, 2, 0,\n \t\t\t  final_sequence && INSN_ANNULLED_BRANCH_P (insn),\n \t\t\t  ! final_sequence, insn);\n }\"\n-  [(set_attr \"type\" \"branch\")])\n+  [(set_attr \"type\" \"branch\")\n+   (set (attr \"length\")\n+        (if_then_else (lt (pc) (match_dup 2))\n+\t\t      (if_then_else (lt (minus (match_dup 2) (pc))\n+\t\t\t\t\t(const_int 32000))\n+\t\t\t\t    (const_int 1)\n+\t\t\t\t    (const_int 3))\n+\t\t      (if_then_else (lt (minus (pc) (match_dup 2))\n+\t\t\t\t\t(const_int 32000))\n+\t\t\t\t    (const_int 1)\n+\t\t\t\t    (const_int 3))))])\n \n ;; XXX\n (define_insn \"*inverted_int_branch_sp64\"\n@@ -2016,11 +2098,21 @@\n   \"TARGET_ARCH64\"\n   \"*\n {\n-  return output_v9branch (operands[0], 1, 2, 1,\n+  return output_v9branch (operands[0], operands[2], 1, 2, 1,\n \t\t\t  final_sequence && INSN_ANNULLED_BRANCH_P (insn),\n \t\t\t  ! final_sequence, insn);\n }\"\n-  [(set_attr \"type\" \"branch\")])\n+  [(set_attr \"type\" \"branch\")\n+   (set (attr \"length\")\n+        (if_then_else (lt (pc) (match_dup 2))\n+\t\t      (if_then_else (lt (minus (match_dup 2) (pc))\n+\t\t\t\t\t(const_int 32000))\n+\t\t\t\t    (const_int 1)\n+\t\t\t\t    (const_int 3))\n+\t\t      (if_then_else (lt (minus (pc) (match_dup 2))\n+\t\t\t\t\t(const_int 32000))\n+\t\t\t\t    (const_int 1)\n+\t\t\t\t    (const_int 3))))])\n \f\n ;; Load program counter insns.\n "}]}