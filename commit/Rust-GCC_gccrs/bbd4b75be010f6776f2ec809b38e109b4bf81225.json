{"sha": "bbd4b75be010f6776f2ec809b38e109b4bf81225", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YmJkNGI3NWJlMDEwZjY3NzZmMmVjODA5YjM4ZTEwOWI0YmY4MTIyNQ==", "commit": {"author": {"name": "Richard Stallman", "email": "rms@gnu.org", "date": "1994-08-14T21:29:21Z"}, "committer": {"name": "Richard Stallman", "email": "rms@gnu.org", "date": "1994-08-14T21:29:21Z"}, "message": "(skip_if_group): New arg op.  All callers changed.\n\nIf output_conditionals is true, output text of failed conditionals.\n(conditional_skip): New arg op.  All callers changed.\n(main): Handle -ifoutput option.\n\nFrom-SVN: r7917", "tree": {"sha": "dfa418e961ab44791b5c45d72cb02d8d9e6cf6e2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/dfa418e961ab44791b5c45d72cb02d8d9e6cf6e2"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/bbd4b75be010f6776f2ec809b38e109b4bf81225", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bbd4b75be010f6776f2ec809b38e109b4bf81225", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bbd4b75be010f6776f2ec809b38e109b4bf81225", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bbd4b75be010f6776f2ec809b38e109b4bf81225/comments", "author": null, "committer": null, "parents": [{"sha": "86b38416af1ff5483510c0e6179d583643e8bb16", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/86b38416af1ff5483510c0e6179d583643e8bb16", "html_url": "https://github.com/Rust-GCC/gccrs/commit/86b38416af1ff5483510c0e6179d583643e8bb16"}], "stats": {"total": 77, "additions": 64, "deletions": 13}, "files": [{"sha": "fe0c5de337acac5bb64a60a7653023850c3cfd73", "filename": "gcc/cccp.c", "status": "modified", "additions": 64, "deletions": 13, "changes": 77, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bbd4b75be010f6776f2ec809b38e109b4bf81225/gcc%2Fcccp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bbd4b75be010f6776f2ec809b38e109b4bf81225/gcc%2Fcccp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcccp.c?ref=bbd4b75be010f6776f2ec809b38e109b4bf81225", "patch": "@@ -395,6 +395,11 @@ static int print_include_names = 0;\n \n static int no_line_commands;\n \n+/* Nonzero means output the text in failing conditionals,\n+   inside #failed ... #endfailed.  */\n+\n+static int output_conditionals;\n+\n /* dump_only means inhibit output of the preprocessed text\n              and instead output the definitions of all user-defined\n              macros in a form suitable for use as input to cccp.\n@@ -1202,6 +1207,9 @@ main (argc, argv)\n \t  else\n \t    include_prefix = argv[++i];\n \t}\n+\tif (!strcmp (argv[i], \"-ifoutput\")) {\n+\t  output_conditionals = 1;\n+\t}\n \tif (!strcmp (argv[i], \"-isystem\")) {\n \t  struct file_name_list *dirtmp;\n \n@@ -2502,7 +2510,7 @@ do { ip = &instack[indepth];\t\t\\\n      obp = op->bufp; } while (0)\n \n   if (no_output && instack[indepth].fname != 0)\n-    skip_if_group (&instack[indepth], 1);\n+    skip_if_group (&instack[indepth], 1, NULL);\n \n   obp = op->bufp;\n   RECACHE;\n@@ -2615,7 +2623,7 @@ do { ip = &instack[indepth];\t\t\\\n \t  /* If not generating expanded output,\n \t     what we do with ordinary text is skip it.\n \t     Discard everything until next # directive.  */\n-\t  skip_if_group (&instack[indepth], 1);\n+\t  skip_if_group (&instack[indepth], 1, 0);\n \t  RECACHE;\n \t  beg_of_line = ibp;\n \t  break;\n@@ -2639,7 +2647,7 @@ do { ip = &instack[indepth];\t\t\\\n       /* If not generating expanded output, ignore everything until\n \t next # directive.  */\n       if (no_output && instack[indepth].fname)\n-\tskip_if_group (&instack[indepth], 1);\n+\tskip_if_group (&instack[indepth], 1, 0);\n       obp = op->bufp;\n       RECACHE;\n       beg_of_line = ibp;\n@@ -6686,7 +6694,7 @@ do_if (buf, limit, op, keyword)\n   FILE_BUF *ip = &instack[indepth];\n \n   value = eval_if_expression (buf, limit - buf);\n-  conditional_skip (ip, value == 0, T_IF, NULL_PTR);\n+  conditional_skip (ip, value == 0, T_IF, NULL_PTR, op);\n   return 0;\n }\n \n@@ -6720,11 +6728,11 @@ do_elif (buf, limit, op, keyword)\n   }\n \n   if (if_stack->if_succeeded)\n-    skip_if_group (ip, 0);\n+    skip_if_group (ip, 0, op);\n   else {\n     value = eval_if_expression (buf, limit - buf);\n     if (value == 0)\n-      skip_if_group (ip, 0);\n+      skip_if_group (ip, 0, op);\n     else {\n       ++if_stack->if_succeeded;\t/* continue processing input */\n       output_line_command (ip, op, 1, same_file);\n@@ -6846,7 +6854,7 @@ do_xifdef (buf, limit, op, keyword)\n     }\n   }\n   \n-  conditional_skip (ip, skip, T_IF, control_macro);\n+  conditional_skip (ip, skip, T_IF, control_macro, op);\n   return 0;\n }\n \n@@ -6856,11 +6864,12 @@ do_xifdef (buf, limit, op, keyword)\n    Otherwise, CONTROL_MACRO is 0.  */\n \n static void\n-conditional_skip (ip, skip, type, control_macro)\n+conditional_skip (ip, skip, type, control_macro, op)\n      FILE_BUF *ip;\n      int skip;\n      enum node_type type;\n      U_CHAR *control_macro;\n+     FILE_BUF *op;\n {\n   IF_STACK_FRAME *temp;\n \n@@ -6874,7 +6883,7 @@ conditional_skip (ip, skip, type, control_macro)\n   if_stack->type = type;\n \n   if (skip != 0) {\n-    skip_if_group (ip, 0);\n+    skip_if_group (ip, 0, op);\n     return;\n   } else {\n     ++if_stack->if_succeeded;\n@@ -6888,9 +6897,10 @@ conditional_skip (ip, skip, type, control_macro)\n  * If ANY is nonzero, return at next directive of any sort.\n  */\n static void\n-skip_if_group (ip, any)\n+skip_if_group (ip, any, op)\n      FILE_BUF *ip;\n      int any;\n+     FILE_BUF *op;\n {\n   register U_CHAR *bp = ip->bufp, *cp;\n   register U_CHAR *endb = ip->buf + ip->length;\n@@ -6899,6 +6909,25 @@ skip_if_group (ip, any)\n   U_CHAR *beg_of_line = bp;\n   register int ident_length;\n   U_CHAR *ident, *after_ident;\n+  /* Save info about where the group starts.  */\n+  U_CHAR *beg_of_group = bp;\n+  int beg_lineno = ip->lineno;\n+\n+  if (output_conditionals && op != 0) {\n+    char *ptr = \"#failed\\n\";\n+    int len = strlen (ptr);\n+\n+    if (op->bufp > op->buf && op->bufp[-1] != '\\n')\n+      {\n+\t*op->bufp++ = '\\n';\n+\top->lineno++;\n+      }\n+    check_expand (op, len);\n+    bcopy (ptr, (char *) op->bufp, len);\n+    op->bufp += len;\n+    op->lineno++;\n+    output_line_command (ip, op, 1, 0);\n+  }\n \n   while (bp < endb) {\n     switch (*bp++) {\n@@ -7050,7 +7079,7 @@ skip_if_group (ip, any)\n \t    && strncmp (cp, kt->name, kt->length) == 0) {\n \t  /* If we are asked to return on next directive, do so now.  */\n \t  if (any)\n-\t    return;\n+\t    goto done;\n \n \t  switch (kt->type) {\n \t  case T_IF:\n@@ -7073,7 +7102,7 @@ skip_if_group (ip, any)\n \t      break;\n \t    }\n \t    else if (if_stack == save_if_stack)\n-\t      return;\t\t/* found what we came for */\n+\t      goto done;\t\t/* found what we came for */\n \n \t    if (kt->type != T_ENDIF) {\n \t      if (if_stack->type == T_ELSE)\n@@ -7095,10 +7124,32 @@ skip_if_group (ip, any)\n \tpedwarn (\"invalid preprocessor directive name\");\n     }\n   }\n+\n   ip->bufp = bp;\n   /* after this returns, rescan will exit because ip->bufp\n      now points to the end of the buffer.\n      rescan is responsible for the error message also.  */\n+\n+ done:\n+  if (output_conditionals && op != 0) {\n+    char *ptr = \"#endfailed\\n\";\n+    int len = strlen (ptr);\n+\n+    if (op->bufp > op->buf && op->bufp[-1] != '\\n')\n+      {\n+\t*op->bufp++ = '\\n';\n+\top->lineno++;\n+      }\n+    check_expand (op, beg_of_line - beg_of_group);\n+    bcopy ((char *) beg_of_group, (char *) op->bufp,\n+\t   beg_of_line - beg_of_group);\n+    op->bufp += beg_of_line - beg_of_group;\n+    op->lineno += ip->lineno - beg_lineno;\n+    check_expand (op, len);\n+    bcopy (ptr, (char *) op->bufp, len);\n+    op->bufp += len;\n+    op->lineno++;\n+  }\n }\n \n /*\n@@ -7141,7 +7192,7 @@ do_else (buf, limit, op, keyword)\n   }\n \n   if (if_stack->if_succeeded)\n-    skip_if_group (ip, 0);\n+    skip_if_group (ip, 0, op);\n   else {\n     ++if_stack->if_succeeded;\t/* continue processing input */\n     output_line_command (ip, op, 1, same_file);"}]}