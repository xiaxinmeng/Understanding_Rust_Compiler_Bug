{"sha": "959e0a760641de7d2d5090b0b30a6077079530df", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTU5ZTBhNzYwNjQxZGU3ZDJkNTA5MGIwYjMwYTYwNzcwNzk1MzBkZg==", "commit": {"author": {"name": "Michael Hayes", "email": "m.hayes@elec.canterbury.ac.nz", "date": "1998-11-25T20:21:49Z"}, "committer": {"name": "Michael Hayes", "email": "m.hayes@gcc.gnu.org", "date": "1998-11-25T20:21:49Z"}, "message": "c4x.md: Fix minor formatting problems.\n\n\t* config/c4x/c4x.md: Fix minor formatting problems.  Update docs.\n\t(*b, *b_rev, *b_noov, *b_noov_rev, *db,\n\tdecrement_and_branch_until_zero, rptb_end): Use c4x_output_cbranch\n\tto output the instruction sequences.\n\t(rpts): Delete.\n\t(rptb_top): Provide alternatives to use any register or memory\n\tfor loop counter.\n\t(rptb_end):  Emit use of operands rather than assigning them\n\texplicitly to the RS and RE registers.\n\nFrom-SVN: r23880", "tree": {"sha": "c2b6e623d498517357525e73d3f4ea13de4f476b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c2b6e623d498517357525e73d3f4ea13de4f476b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/959e0a760641de7d2d5090b0b30a6077079530df", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/959e0a760641de7d2d5090b0b30a6077079530df", "html_url": "https://github.com/Rust-GCC/gccrs/commit/959e0a760641de7d2d5090b0b30a6077079530df", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/959e0a760641de7d2d5090b0b30a6077079530df/comments", "author": null, "committer": null, "parents": [{"sha": "4271f0030d108619d834b70a8930b46b51658693", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4271f0030d108619d834b70a8930b46b51658693", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4271f0030d108619d834b70a8930b46b51658693"}], "stats": {"total": 257, "additions": 150, "deletions": 107}, "files": [{"sha": "4118573b72d3899417edd3f744dfe08798928b6d", "filename": "gcc/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/959e0a760641de7d2d5090b0b30a6077079530df/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/959e0a760641de7d2d5090b0b30a6077079530df/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=959e0a760641de7d2d5090b0b30a6077079530df", "patch": "@@ -1,3 +1,15 @@\n+Thu Nov 26 17:15:38 1998  Michael Hayes  <m.hayes@elec.canterbury.ac.nz>\n+\n+\t* config/c4x/c4x.md: Fix minor formatting problems.  Update docs.\n+\t(*b, *b_rev, *b_noov, *b_noov_rev, *db, \n+\tdecrement_and_branch_until_zero, rptb_end): Use c4x_output_cbranch\n+\tto output the instruction sequences.\n+\t(rpts): Delete.\n+\t(rptb_top): Provide alternatives to use any register or memory\n+\tfor loop counter.\n+\t(rptb_end):  Emit use of operands rather than assigning them\n+\texplicitly to the RS and RE registers.\n+\n Thu Nov 26 16:37:59 1998  Michael Hayes  <m.hayes@elec.canterbury.ac.nz>\n \n \t* config/c4x/c4x.c (c4x_modified_between_p, c4x_mem_set_p,"}, {"sha": "776f2cac1632483385093d33f24b57ea1cc2c6b4", "filename": "gcc/config/c4x/c4x.md", "status": "modified", "additions": 138, "deletions": 107, "changes": 245, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/959e0a760641de7d2d5090b0b30a6077079530df/gcc%2Fconfig%2Fc4x%2Fc4x.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/959e0a760641de7d2d5090b0b30a6077079530df/gcc%2Fconfig%2Fc4x%2Fc4x.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fc4x%2Fc4x.md?ref=959e0a760641de7d2d5090b0b30a6077079530df", "patch": "@@ -23,7 +23,7 @@\n \n ;\n ; TODO :\n-;        Set up addressing macros to handle direct memory references properly\n+;        Set up addressing macros to handle direct memory references properly.\n ;        Try using PQImode again for addresses since C30 only uses\n ;        24-bit addresses.   Ideally GCC would emit different insns\n ;        for QImode and Pmode, whether Pmode was QImode or PQImode.\n@@ -90,16 +90,25 @@\n ; b   stack pointer        SP\n ; c   other int reg        AR0-AR7, IR0-IR1, RC, RS, RE\n ; d   fp reg               R0-R11 (sets CC when dst) \n+; e\n ; f   fp reg               R0-R11 (sets CC when dst)\n ; g   general reg, memory, constant\n-; h   fp reg               R0-R11 (sets CC when dst) \n+; h   fp reg (HFmode)      R0-R11 (sets CC when dst) \n ; i   immediate int constant\n+; j\n+; k   block count          BK\n+; l\n ; m   memory\n+; n   immediate int constant with known numeric value\n+; o   offsettable memory\n+; p   memory address\n ; q   low fp reg           R0-R7  (sets CC when dst)\n ; r   general reg          R0-R11, AR0-AR7, IR0-IR1, RC, RS, RE\n-; s   immediate int (value not explicit)\n+; s   immediate int constant (value not explicit)\n ; t                        R0-R1\n ; u                        R2-R3\n+; v   repeat count reg     RC\n+; w\n ; x   index reg            IR0-IR1\n ; y   status (CC) reg      ST\n ; z   data pointer         DP\n@@ -117,6 +126,8 @@\n ; R   ARx + 5-bit unsigned disp  (C4x only)\n ; S   ARx + 0, 1, IRx disp\n ; T   symbol ref (direct)\n+; V   non offsettable memory\n+; X   any operand\n ; <   memory operand with autodecrement addressing\n ; >   memory operand with autoincrement addressing\n ; {   memory operand with pre-modify addressing\n@@ -1063,6 +1074,14 @@\n                             (const_int 1) (const_int 0))]\n              (const_int 0)))\n \n+\n+;\n+; C4x INSN PATTERNS:\n+;\n+; Note that the movMM and addP patterns can be called during reload\n+; so we need to take special care with theses patterns since\n+; we cannot blindly clobber CC or generate new pseudo registers.\n+\n ;\n ; TWO OPERAND INTEGER INSTRUCTIONS\n ;\n@@ -1110,6 +1129,7 @@\n \n ;\n ; LDIU/LDA/STI/STIK\n+;\n ; The following moves will not set the condition codes register.\n ;\n \n@@ -1596,7 +1616,8 @@\n ; Default to int16 data attr.\n \n ; This pattern is required primarily for manipulating the stack pointer\n-; where GCC doesn't expect CC to be clobbered.\n+; where GCC doesn't expect CC to be clobbered or for calculating\n+; addresses during reload.\n (define_insn \"addqi3_noclobber\"\n   [(set (match_operand:QI 0 \"std_reg_operand\" \"=c,?c,c\")\n         (plus:QI (match_operand:QI 1 \"src_operand\" \"%rR,rS<>,0\")\n@@ -1765,13 +1786,13 @@\n        if (operands[1] == operands[2])\n          {\n             /* Do the squaring operation in-line.  */\n-            emit_insn (gen_sqrqi2_inline(operands[0], operands[1]));\n+            emit_insn (gen_sqrqi2_inline (operands[0], operands[1]));\n             DONE;\n          }\n        if (TARGET_INLINE)\n          {\n-            emit_insn (gen_mulqi3_inline(operands[0], operands[1],\n-                                         operands[2]));\n+            emit_insn (gen_mulqi3_inline (operands[0], operands[1],\n+                                          operands[2]));\n             DONE;\n          }\n        c4x_emit_libcall3 (MULQI3_LIBCALL, MULT, QImode, operands);\n@@ -3261,7 +3282,7 @@\n      FAIL;\n    else\n      {\n-       emit_insn (gen_sqrtqf2_inline( operands[0], operands[1]));\n+       emit_insn (gen_sqrtqf2_inline (operands[0], operands[1]));\n        DONE;\n      }\n   \")\n@@ -3506,7 +3527,7 @@\n      }\n    else\n      {\n-       emit_insn (gen_divqf3_inline( operands[0], operands[1], operands[2]));\n+       emit_insn (gen_divqf3_inline (operands[0], operands[1], operands[2]));\n        DONE;\n      }\n   \")\n@@ -3533,10 +3554,10 @@\n                           [(reg:CC_NOOV 21) (const_int 0)])\n                          (match_operand:QI 2 \"src_operand\" \"g,0\")\n                          (match_operand:QI 3 \"src_operand\" \"0,g\")))]\n- \"GET_CODE(operands[1]) != LE\n-  && GET_CODE(operands[1]) != GE\n-  && GET_CODE(operands[1]) != LT\n-  && GET_CODE(operands[1]) != GT\"\n+ \"GET_CODE (operands[1]) != LE\n+  && GET_CODE (operands[1]) != GE\n+  && GET_CODE (operands[1]) != LT\n+  && GET_CODE (operands[1]) != GT\"\n  \"@\n   ldi%1\\\\t%2,%0\n   ldi%I1\\\\t%3,%0\"\n@@ -3581,10 +3602,10 @@\n                           [(reg:CC_NOOV 21) (const_int 0)])\n                          (match_operand:QF 2 \"src_operand\" \"fmH,0\")\n                          (match_operand:QF 3 \"src_operand\" \"0,fmH\")))]\n- \"GET_CODE(operands[1]) != LE\n-  && GET_CODE(operands[1]) != GE\n-  && GET_CODE(operands[1]) != LT\n-  && GET_CODE(operands[1]) != GT\"\n+ \"GET_CODE (operands[1]) != LE\n+  && GET_CODE (operands[1]) != GE\n+  && GET_CODE (operands[1]) != LT\n+  && GET_CODE (operands[1]) != GT\"\n  \"@\n   ldf%1\\\\t%2,%0\n   ldf%I1\\\\t%3,%0\"\n@@ -3818,10 +3839,10 @@\n \n (define_insn \"*mulqf3_addqf3_clobber\"\n   [(set (match_operand:QF 0 \"r0r1_reg_operand\" \"=t\")\n-        (mult:QF (match_operand:QF 1 \"parallel_operand\" \"S<>q\")\n+        (mult:QF (match_operand:QF 1 \"parallel_operand\" \"%S<>q\")\n                  (match_operand:QF 2 \"parallel_operand\" \"S<>q\")))\n    (set (match_operand:QF 3 \"r2r3_reg_operand\" \"=u\")\n-        (plus:QF (match_operand:QF 4 \"parallel_operand\" \"S<>q\")\n+        (plus:QF (match_operand:QF 4 \"parallel_operand\" \"%S<>q\")\n                  (match_operand:QF 5 \"parallel_operand\" \"S<>q\")))\n    (clobber (reg:CC 21))]\n   \"TARGET_PARALLEL_MPY && valid_parallel_operands_6 (operands, QFmode)\"\n@@ -4134,7 +4155,7 @@\n                            (pc)))]\n   \"\"\n   \"*\n-   return c4x_output_cbranch (0, insn);\"\n+   return c4x_output_cbranch (\\\"b%0\\\", insn);\"\n   [(set_attr \"type\" \"jmpc\")])\n \n (define_insn \"*b_rev\"\n@@ -4144,33 +4165,33 @@\n                            (label_ref (match_operand 1 \"\" \"\"))))]\n   \"\"\n   \"*\n-   return c4x_output_cbranch (1, insn);\"\n+   return c4x_output_cbranch (\\\"b%I0\\\", insn);\"\n   [(set_attr \"type\" \"jmpc\")])\n \n (define_insn \"*b_noov\"\n   [(set (pc) (if_then_else (match_operator 0 \"comparison_operator\"\n \t\t\t   [(reg:CC_NOOV 21) (const_int 0)])\n                            (label_ref (match_operand 1 \"\" \"\"))\n                            (pc)))]\n- \"GET_CODE(operands[0]) != LE\n-  && GET_CODE(operands[0]) != GE\n-  && GET_CODE(operands[0]) != LT\n-  && GET_CODE(operands[0]) != GT\"\n+ \"GET_CODE (operands[0]) != LE\n+  && GET_CODE (operands[0]) != GE\n+  && GET_CODE (operands[0]) != LT\n+  && GET_CODE (operands[0]) != GT\"\n   \"*\n-   return c4x_output_cbranch (0, insn);\"\n+   return c4x_output_cbranch (\\\"b%0\\\", insn);\"\n   [(set_attr \"type\" \"jmpc\")])\n \n (define_insn \"*b_noov_rev\"\n   [(set (pc) (if_then_else (match_operator 0 \"comparison_operator\"\n \t\t\t   [(reg:CC_NOOV 21) (const_int 0)])\n                            (pc)\n                            (label_ref (match_operand 1 \"\" \"\"))))]\n- \"GET_CODE(operands[0]) != LE\n-  && GET_CODE(operands[0]) != GE\n-  && GET_CODE(operands[0]) != LT\n-  && GET_CODE(operands[0]) != GT\"\n+ \"GET_CODE (operands[0]) != LE\n+  && GET_CODE (operands[0]) != GE\n+  && GET_CODE (operands[0]) != LT\n+  && GET_CODE (operands[0]) != GT\"\n   \"*\n-   return c4x_output_cbranch (1, insn);\"\n+   return c4x_output_cbranch (\\\"b%I0\\\", insn);\"\n   [(set_attr \"type\" \"jmpc\")])\n \n (define_expand \"beq\"\n@@ -4382,10 +4403,10 @@\n                       [(reg:CC_NOOV 21) (const_int 0)])\n                       (return)\n                        (pc)))]\n-  \"GET_CODE(operands[0]) != LE\n-   && GET_CODE(operands[0]) != GE\n-   && GET_CODE(operands[0]) != LT\n-   && GET_CODE(operands[0]) != GT\n+  \"GET_CODE (operands[0]) != LE\n+   && GET_CODE (operands[0]) != GE\n+   && GET_CODE (operands[0]) != LT\n+   && GET_CODE (operands[0]) != GT\n    && c4x_null_epilogue_p ()\"\n   \"rets%0\"\n   [(set_attr \"type\" \"rets\")])\n@@ -4406,10 +4427,10 @@\n                       [(reg:CC_NOOV 21) (const_int 0)])\n                        (pc)\n                       (return)))]\n-  \"GET_CODE(operands[0]) != LE\n-   && GET_CODE(operands[0]) != GE\n-   && GET_CODE(operands[0]) != LT\n-   && GET_CODE(operands[0]) != GT\n+  \"GET_CODE (operands[0]) != LE\n+   && GET_CODE (operands[0]) != GE\n+   && GET_CODE (operands[0]) != LT\n+   && GET_CODE (operands[0]) != GT\n    && c4x_null_epilogue_p ()\"\n   \"rets%I0\"\n   [(set_attr \"type\" \"rets\")])\n@@ -4434,55 +4455,50 @@\n ; have an option to disable this instruction.\n (define_insn \"*db\"\n   [(set (pc)\n-        (if_then_else (ne (match_operand:QI 0 \"addr_reg_operand\" \"+a,!d,!m\")\n+        (if_then_else (ne (match_operand:QI 2 \"addr_reg_operand\" \"0,0,0,0\")\n                           (const_int 0))\n                       (label_ref (match_operand 1 \"\" \"\"))\n                       (pc)))\n-   (set (match_dup 0)\n+   (set (match_operand:QI 0 \"addr_reg_operand\" \"+a,?*d,??*r,!m\")\n         (plus:QI (match_dup 0)\n-                 (const_int -1)))]\n+                 (const_int -1)))\n+   (clobber (reg:CC_NOOV 21))]\n   \"TARGET_DB && TARGET_LOOP_UNSIGNED\"\n   \"*\n-  if (IS_ADDR_REG (REGNO (operands[0])))\n-    {\n-        return \\\"dbu%#\\\\t%0,%l1\\\";\n-    }\n-  else if (IS_EXT_REG (REGNO (operands[0])))\n-    {\n-        return \\\"subi\\\\t1,%0\\\\n\\\\tbge%#\\\\t%l1\\\";\n-    }\n+  if (which_alternative == 0)\n+    return \\\"dbu%#\\\\t%0,%l1\\\";\n+  else if (which_alternative == 1)\n+    return c4x_output_cbranch (\\\"subi\\\\t1,%0\\\\n\\\\tbge\\\", insn);\n+  else if (which_alternative == 2)\n+    return c4x_output_cbranch (\\\"subi\\\\t1,%0\\\\n\\\\tcmpi\\\\t0,%0\\\\n\\\\tbge\\\", insn);\n   else\n-    {\n-        return \\\"push\\\\tr0\\\\n\\\\tldi\\\\t%0,r0\\\\n\\\\tsubi\\\\t1,r0\\\\n\\\\tsti\\\\tr0,%0\\\\n\\\\tpop\\\\tr0\\\\n\\\\tbhs%#\\\\t%l1\\\";\n-    }\n+    return c4x_output_cbranch (\\\"push\\\\tr0\\\\n\\\\tldi\\\\t%0,r0\\\\n\\\\tsubi\\\\t1,r0\\\\n\\\\tsti\\\\tr0,%0\\\\n\\\\tpop\\\\tr0\\\\n\\\\tbhs\\\", insn);\n   \"\n-  [(set_attr \"type\" \"db\")])\n+  [(set_attr \"type\" \"db,jmpc,jmpc,jmpc\")])\n \n (define_insn \"decrement_and_branch_until_zero\"\n   [(set (pc)\n-        (if_then_else (ge (plus:QI (match_operand:QI 0 \"addr_reg_operand\" \"+a,!d,!m\")\n-                          (const_int -1)) (const_int 0))\n+        (if_then_else (ge (plus:QI (match_operand:QI 2 \"addr_reg_operand\" \"0,0,0,0\")\n+\t\t\t           (const_int -1))\n+\t\t\t  (const_int 0))\n                       (label_ref (match_operand 1 \"\" \"\"))\n                       (pc)))\n-   (set (match_dup 0)\n+   (set (match_operand:QI 0 \"addr_reg_operand\" \"+a,?*d,??*r,!m\")\n         (plus:QI (match_dup 0)\n-                 (const_int -1)))]\n+                 (const_int -1)))\n+   (clobber (reg:CC_NOOV 21))]\n   \"TARGET_DB && find_reg_note (insn, REG_NONNEG, 0)\"\n   \"*\n-  if (IS_ADDR_REG (REGNO (operands[0])))\n-    {\n-        return \\\"dbu%#\\\\t%0,%l1\\\";\n-    }\n-  else if (IS_EXT_REG (REGNO (operands[0])))\n-    {\n-        return \\\"subi\\\\t1,%0\\\\n\\\\tbge%#\\\\t%l1\\\";\n-    }\n+  if (which_alternative == 0)\n+    return \\\"dbu%#\\\\t%0,%l1\\\";\n+  else if (which_alternative == 1)\n+    return c4x_output_cbranch (\\\"subi\\\\t1,%0\\\\n\\\\tbge\\\", insn);\n+  else if (which_alternative == 2)\n+    return c4x_output_cbranch (\\\"subi\\\\t1,%0\\\\n\\\\tcmpi\\\\t0,%0\\\\n\\\\tbge\\\", insn);\n   else\n-    {\n-        return \\\"push\\\\tr0\\\\n\\\\tldi\\\\t%0,r0\\\\n\\\\tsubi\\\\t1,r0\\\\n\\\\tsti\\\\tr0,%0\\\\n\\\\t\\\\tpop\\\\tr0\\\\n\\\\tbhs%#\\\\t%l1\\\";\n-    }\n+    return c4x_output_cbranch (\\\"push\\\\tr0\\\\n\\\\tldi\\\\t%0,r0\\\\n\\\\tsubi\\\\t1,r0\\\\n\\\\tsti\\\\tr0,%0\\\\n\\\\tpop\\\\tr0\\\\n\\\\tbhs\\\", insn);\n   \"\n-  [(set_attr \"type\" \"db\")])\n+  [(set_attr \"type\" \"db,jmpc,jmpc,jmpc\")])\n \n ;\n ; MISC INSTRUCTIONS\n@@ -4497,48 +4513,58 @@\n   \"nop\")\n ; Default to misc type attr.\n \n-;\n-; RPTS\n-;\n-; Should we disallow RPTS if we get a silly number of shifts?\n-(define_insn \"rpts\"\n-  [(set (reg:QI 27)\n-        (unspec [(match_operand:QI 0 \"src_operand\" \"g\")] 2))\n-   (clobber (reg:QI 25))\n-   (clobber (reg:QI 26))]\n-  \"\"\n-  \"rpts\\\\t%0\"\n-  [(set_attr \"type\" \"repeat\")])\n \n ;\n ; RPTB\n ;\n (define_insn \"rptb_top\"\n-  [(set (reg:QI 25) (label_ref (match_operand 0 \"\" \"\")))\n-   (set (reg:QI 26) (label_ref (match_operand 1 \"\" \"\")))]\n+  [(use (label_ref (match_operand 0 \"\" \"\")))\n+   (use (label_ref (match_operand 1 \"\" \"\")))]\n   \"\"\n   \"*\n    return !final_sequence && c4x_rptb_rpts_p (insn, operands[0])\n \t ? \\\"rpts\\\\trc\\\" : \\\"rptb%#\\\\t%l1-1\\\";\n   \"\n   [(set_attr \"type\" \"repeat_top\")])\n \n+; This pattern needs to be emitted at the start of the loop to\n+; say that RS and RE are loaded.\n+(define_insn \"init_branch_on_count\"\n+  [(unspec[(match_operand:QI 0 \"rc_reg_operand\" \"v\")] 22)\n+   (clobber (reg:QI 25))\n+   (clobber (reg:QI 26))]\n+  \"\"\n+  \"\"\n+  [(set_attr \"type\" \"repeat\")])\n \n+; The RS (25) and RE (26) registers must be unviolate from the top of the loop\n+; to here.\n (define_insn \"rptb_end\"\n   [(set (pc)\n-        (if_then_else (ge (match_operand:QI 0 \"rc_reg_operand\" \"v\")\n+        (if_then_else (ge (match_operand:QI 2 \"rc_reg_operand\" \"0,0,0,0,0\")\n                           (const_int 0))\n                       (label_ref (match_operand 1 \"\" \"\"))\n                       (pc)))\n-   (set (match_dup 0)\n+   (set (match_operand:QI 0 \"rc_reg_operand\" \"+v,*a,*d,*x*k,*m\")\n         (plus:QI (match_dup 0)\n                  (const_int -1)))\n-   (clobber (reg:QI 25))\n-   (clobber (reg:QI 26))]\n+   (use (reg:QI 25))\n+   (use (reg:QI 26))\n+   (clobber (reg:CC_NOOV 21))]\n   \"\"\n   \"*\n-   return c4x_rptb_nop_p(insn) ? \\\"nop\\\" : \\\"\\\";\"\n-  [(set_attr \"type\" \"repeat\")])\n+   if (which_alternative == 0)\n+     return c4x_rptb_nop_p (insn) ? \\\"nop\\\" : \\\"\\\";\n+   else if (which_alternative == 1)\n+     return \\\"dbu%#\\\\t%0,%l1\\\";\n+   else if (which_alternative == 2)\n+     return c4x_output_cbranch (\\\"subi\\\\t1,%0\\\\n\\\\tbge\\\", insn);\n+   else if (which_alternative == 3)\n+     return c4x_output_cbranch (\\\"subi\\\\t1,%0\\\\n\\\\tcmpi\\\\t0,%0\\\\n\\\\tbge\\\", insn);\n+   else\n+     return c4x_output_cbranch (\\\"push\\\\tr0\\\\n\\\\tldi\\\\t%0,r0\\\\n\\\\tsubi\\\\t1,r0\\\\n\\\\tsti\\\\tr0,%0\\\\n\\\\tpop\\\\tr0\\\\n\\\\tbhs\\\", insn);\n+  \"\n+  [(set_attr \"type\" \"repeat,db,jmpc,jmpc,jmpc\")])\n \n \n (define_expand \"decrement_and_branch_on_count\"\n@@ -4547,9 +4573,12 @@\n                                      (const_int 0))\n                                  (label_ref (match_operand 1 \"\" \"\"))\n                                  (pc)))\n-              (set (match_dup 0) (plus:QI (match_dup 0) (const_int -1)))\n-              (clobber (reg:QI 25))\n-              (clobber (reg:QI 26))])]\n+              (set (match_dup 0)\n+\t\t   (plus:QI (match_dup 0)\n+\t\t\t    (const_int -1)))\n+              (use (reg:QI 25))\n+              (use (reg:QI 26))\n+              (clobber (reg:CC_NOOV 21))])]\n   \"\"\n   \"\")\n \n@@ -4647,7 +4676,7 @@\n    int len = INTVAL (operands[2]);\n \n    output_asm_insn (\\\"ldiu\\\\t*%1++,%4\\\", operands);\n-   if (TARGET_RPTS_CYCLES(len))\n+   if (TARGET_RPTS_CYCLES (len))\n      {\n         output_asm_insn (\\\"rpts\\\\t%2-2\\\", operands);  \n         output_asm_insn (\\\"sti\\\\t%4,*%0++\\\", operands);\n@@ -4665,7 +4694,7 @@\n      }\n   }\n   \"\n-  [(set_attr \"type\" \"repeat\")])\n+  [(set_attr \"type\" \"multi\")])\n \n ; Operand 2 is the count, operand 3 is the alignment.\n (define_expand \"movstrqi\"\n@@ -4684,8 +4713,8 @@\n         FAIL;  /* Try to call _memcpy */\n      }\n \n-   operands[0] = copy_to_mode_reg (Pmode, XEXP(operands[0], 0));\n-   operands[1] = copy_to_mode_reg (Pmode, XEXP(operands[1], 0));\n+   operands[0] = copy_to_mode_reg (Pmode, XEXP (operands[0], 0));\n+   operands[1] = copy_to_mode_reg (Pmode, XEXP (operands[1], 0));\n    tmp = gen_reg_rtx (QImode);\n    if (INTVAL (operands[2]) < 8)\n      emit_insn (gen_movstrqi_small (operands[0], operands[1], operands[2],\n@@ -4733,8 +4762,8 @@\n      {\n         FAIL;\n      }\n-   operands[1] = copy_to_mode_reg (Pmode, XEXP(operands[1], 0));\n-   operands[2] = copy_to_mode_reg (Pmode, XEXP(operands[2], 0));\n+   operands[1] = copy_to_mode_reg (Pmode, XEXP (operands[1], 0));\n+   operands[2] = copy_to_mode_reg (Pmode, XEXP (operands[2], 0));\n    operands[5] = gen_reg_rtx (QImode);\n }\")\n \n@@ -5116,7 +5145,7 @@\n      FAIL;\n    else\n      {\n-       emit_insn (gen_sqrthf2_inline( operands[0], operands[1]));\n+       emit_insn (gen_sqrthf2_inline (operands[0], operands[1]));\n        DONE;\n      }\n   \")\n@@ -5269,7 +5298,7 @@\n      }\n    else\n      {\n-       emit_insn (gen_divhf3_inline( operands[0], operands[1], operands[2]));\n+       emit_insn (gen_divhf3_inline (operands[0], operands[1], operands[2]));\n        DONE;\n      }\n   \")\n@@ -6122,14 +6151,15 @@\n    (parallel\n     [(set (pc)\n           (if_then_else\n-            (ge (plus:QI (match_operand:QI 0 \"addr_reg_operand\" \"+a\")\n+            (ge (plus:QI (match_operand:QI 4 \"addr_reg_operand\" \"0\")\n                          (const_int -1))\n                 (const_int 0))\n             (label_ref (match_operand 1 \"\" \"\"))\n             (pc)))\n-     (set (match_dup 0)\n+     (set (match_operand:QI 0 \"addr_reg_operand\" \"+a\")\n           (plus:QI (match_dup 0)\n-                   (const_int -1)))])]\n+                   (const_int -1)))\n+     (clobber (reg:CC_NOOV 21))])]\n   \"!c4x_label_conflict (insn, operands[2], operands[1])\"\n   \"db%I3\\\\t%0,%l1\\\\n\\\\tb%3\\\\t%l2\")\n \n@@ -6141,13 +6171,14 @@\n    (parallel\n     [(set (pc)\n           (if_then_else\n-            (ne (match_operand:QI 0 \"addr_reg_operand\" \"+a\")\n+            (ne (match_operand:QI 4 \"addr_reg_operand\" \"0\")\n                 (const_int 0))\n             (label_ref (match_operand 1 \"\" \"\"))\n             (pc)))\n-     (set (match_dup 0)\n+     (set (match_operand:QI 0 \"addr_reg_operand\" \"+a\")\n           (plus:QI (match_dup 0)\n-                   (const_int -1)))])]\n+                   (const_int -1)))\n+     (clobber (reg:CC_NOOV 21))])]\n   \"!c4x_label_conflict (insn, operands[2], operands[1])\"\n   \"db%I3\\\\t%0,%l1\\\\n\\\\tb%3\\\\t%l2\")\n "}]}