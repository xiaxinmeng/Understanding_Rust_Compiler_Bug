{"sha": "c194537c63180722ea6977000451174f5da1b40b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YzE5NDUzN2M2MzE4MDcyMmVhNjk3NzAwMDQ1MTE3NGY1ZGExYjQwYg==", "commit": {"author": {"name": "Tobias Burnus", "email": "burnus@net-b.de", "date": "2014-08-14T18:35:01Z"}, "committer": {"name": "Tobias Burnus", "email": "burnus@gcc.gnu.org", "date": "2014-08-14T18:35:01Z"}, "message": "gfortran.texi (Coarray Programming): Add first ABI documentation.\n\n2014-08-14  Tobias Burnus  <burnus@net-b.de>\n\n        * gfortran.texi (Coarray Programming): Add first ABI\n        documentation.\n\nFrom-SVN: r213978", "tree": {"sha": "87eb9aca240032b8d14af3fdc6c8e91be31f6553", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/87eb9aca240032b8d14af3fdc6c8e91be31f6553"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c194537c63180722ea6977000451174f5da1b40b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c194537c63180722ea6977000451174f5da1b40b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c194537c63180722ea6977000451174f5da1b40b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c194537c63180722ea6977000451174f5da1b40b/comments", "author": {"login": "tob2", "id": 264461, "node_id": "MDQ6VXNlcjI2NDQ2MQ==", "avatar_url": "https://avatars.githubusercontent.com/u/264461?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tob2", "html_url": "https://github.com/tob2", "followers_url": "https://api.github.com/users/tob2/followers", "following_url": "https://api.github.com/users/tob2/following{/other_user}", "gists_url": "https://api.github.com/users/tob2/gists{/gist_id}", "starred_url": "https://api.github.com/users/tob2/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tob2/subscriptions", "organizations_url": "https://api.github.com/users/tob2/orgs", "repos_url": "https://api.github.com/users/tob2/repos", "events_url": "https://api.github.com/users/tob2/events{/privacy}", "received_events_url": "https://api.github.com/users/tob2/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "9c8d7ac2a3ebe431b996a8f6877d5a3801022faa", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9c8d7ac2a3ebe431b996a8f6877d5a3801022faa", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9c8d7ac2a3ebe431b996a8f6877d5a3801022faa"}], "stats": {"total": 380, "additions": 380, "deletions": 0}, "files": [{"sha": "50fda78f0c4c22ad2277e97d3fb26c54004ebc7d", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c194537c63180722ea6977000451174f5da1b40b/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c194537c63180722ea6977000451174f5da1b40b/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=c194537c63180722ea6977000451174f5da1b40b", "patch": "@@ -1,3 +1,8 @@\n+2014-08-14  Tobias Burnus  <burnus@net-b.de>\n+\n+\t* gfortran.texi (Coarray Programming): Add first ABI\n+\tdocumentation.\n+\n 2014-08-14  Jakub Jelinek  <jakub@redhat.com>\n \n \tPR fortran/62076"}, {"sha": "5f6bf5d4b6a6448801a91f744aa56ef86bb1c28f", "filename": "gcc/fortran/gfortran.texi", "status": "modified", "additions": 375, "deletions": 0, "changes": 375, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c194537c63180722ea6977000451174f5da1b40b/gcc%2Ffortran%2Fgfortran.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c194537c63180722ea6977000451174f5da1b40b/gcc%2Ffortran%2Fgfortran.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fgfortran.texi?ref=c194537c63180722ea6977000451174f5da1b40b", "patch": "@@ -184,6 +184,7 @@ Part II: Language Reference\n * Compiler Characteristics::      User-visible implementation details.\n * Extensions::                    Language extensions implemented by GNU Fortran.\n * Mixed-Language Programming::    Interoperability with C\n+* Coarray Programming::\n * Intrinsic Procedures:: Intrinsic procedures supported by GNU Fortran.\n * Intrinsic Modules::    Intrinsic modules supported by GNU Fortran.\n \n@@ -3176,6 +3177,380 @@ of such a type\n @end itemize\n \n \n+@c ---------------------------------------------------------------------\n+@c Coarray Programming\n+@c ---------------------------------------------------------------------\n+\n+@node Coarray Programming\n+@chapter Coarray Programming\n+@cindex Coarrays\n+\n+@menu\n+* Type and enum ABI Documentation::\n+* Function ABI Documentation::\n+@end menu\n+\n+\n+@node Type and enum ABI Documentation\n+@section Type and enum ABI Documentation\n+\n+@menu\n+* caf_token_t::\n+* caf_register_t::\n+@end menu\n+\n+@node caf_token_t\n+@subsection @code{caf_token_t}\n+\n+Typedef of type @code{void *} on the compiler side. Can be any data\n+type on the library side.\n+\n+@node caf_register_t\n+@subsection @code{caf_register_t}\n+\n+Indicates which kind of coarray variable should be registered.\n+\n+@verbatim\n+typedef enum caf_register_t {\n+  CAF_REGTYPE_COARRAY_STATIC,\n+  CAF_REGTYPE_COARRAY_ALLOC,\n+  CAF_REGTYPE_LOCK_STATIC,\n+  CAF_REGTYPE_LOCK_ALLOC\n+}\n+caf_register_t;\n+@end verbatim\n+\n+\n+@node Function ABI Documentation\n+@section Function ABI Documentation\n+\n+@menu\n+* _gfortran_caf_init:: Initialiation function\n+* _gfortran_caf_finish:: Finalization function\n+* _gfortran_caf_this_image:: Querying the image number\n+* _gfortran_caf_num_images:: Querying the maximal number of images\n+* _gfortran_caf_register:: Registering coarrays\n+* _gfortran_caf_deregister:: Deregistering coarrays\n+* _gfortran_caf_send:: Sending data from a local image to a remote image\n+* _gfortran_caf_get:: Getting data from a remote image\n+* _gfortran_caf_sendget:: Sending data between remote images\n+@end menu\n+\n+\n+@node _gfortran_caf_init\n+@subsection @code{_gfortran_caf_init} --- Initialiation function\n+@cindex Coarray, _gfortran_caf_init\n+\n+@table @asis\n+@item @emph{Description}:\n+This function is called at startup of the program before the Fortran main\n+program, if the latter has been compiled with @option{-fcoarray=lib}.\n+It takes as arguments the command-line arguments of the program.  It is\n+permitted to pass to @code{NULL} pointers as argument; if non-@code{NULL},\n+the library is permitted to modify the arguments.\n+\n+@item @emph{Syntax}:\n+@code{void _gfortran_caf_init (int *argc, char ***argv)}\n+\n+@item @emph{Arguments}:\n+@multitable @columnfractions .15 .70\n+@item @var{argc} @tab intent(inout) An integer pointer with the number of\n+arguments passed to the program or @code{NULL}.\n+@item @var{argv} @tab intent(inout) A pointer to an array of strings with the\n+command-line arguments or @code{NULL}.\n+@end multitable\n+\n+@item @emph{NOTES}\n+The function is modelled after the initialization function of the Message\n+Passing Interface (MPI) specification.  Due to the way coarray registration\n+works, it might not be the first call to the libaray.  If the main program is\n+not written in Fortran and only a library uses coarrays, it can happen that\n+this function is never called.  Therefore, it is recommended that the library\n+does not rely on the passed arguments and whether the call has been done.\n+@end table\n+\n+\n+@node _gfortran_caf_finish\n+@subsection @code{_gfortran_caf_finish} --- Finalization function\n+@cindex Coarray, _gfortran_caf_finish\n+\n+@table @asis\n+@item @emph{Description}:\n+This function is called at the end of the Fortran main program, if it has\n+been compiled with the @option{-fcoarray=lib} option.\n+\n+@item @emph{Syntax}:\n+@code{void _gfortran_caf_finish (void)}\n+\n+@item @emph{NOTES}\n+For non-Fortran programs, it is recommended to call the function at the end\n+of the main program.  To ensure that the shutdown is also performed for\n+programs where this function is not explicitly invoked, for instance\n+non-Fortran programs or calls to the system's exit() function, the library\n+can use a destructor function.  Note that programs can also be terminated\n+using the STOP and ERROR STOP statements; those use different library calls.\n+@end table\n+\n+\n+@node _gfortran_caf_this_image\n+@subsection @code{_gfortran_caf_this_image} --- Querying the image number\n+@cindex Coarray, _gfortran_caf_this_image\n+\n+@table @asis\n+@item @emph{Description}:\n+This function returns the current image number, which is a positive number.\n+\n+@item @emph{Syntax}:\n+@code{int _gfortran_caf_this_image (int distance)}\n+\n+@item @emph{Arguments}:\n+@multitable @columnfractions .15 .70\n+@item @var{distance} @tab As specified for the @code{this_image} intrinsic\n+in TS18508. Shall be a nonnegative number.\n+@end multitable\n+\n+@item @emph{NOTES}\n+If the Fortran intrinsic @code{this_image} is invoked without an argument, which\n+is the only permitted form in Fortran 2008, GCC passes @code{0} as\n+first argument.\n+@end table\n+\n+\n+@node _gfortran_caf_num_images\n+@subsection @code{_gfortran_caf_num_images} --- Querying the maximal number of images\n+@cindex Coarray, _gfortran_caf_num_images\n+\n+@table @asis\n+@item @emph{Description}:\n+This function returns the number of images in the current team, if\n+@var{distance} is 0 or the number of images in the parent team at the specified\n+distance. If failed is -1, the function returns the number of all images at\n+the specified distance; if it is 0, the function returns the number of\n+nonfailed images, and if it is 1, it returns the number of failed images.\n+\n+@item @emph{Syntax}:\n+@code{int _gfortran_caf_num_images(int distance, int failed)}\n+\n+@item @emph{Arguments}:\n+@multitable @columnfractions .15 .70\n+@item @var{distance} @tab the distance from this image to the ancestor.\n+Shall be positive.\n+@item @var{failed} @tab shall be -1, 0, or 1\n+@end multitable\n+\n+@item @emph{NOTES}\n+This function follows TS18508. If the num_image intrinsic has no arguments,\n+the the compiler passes @code{distance=0} and @code{failed=-1} to the function.\n+@end table\n+\n+\n+@node _gfortran_caf_register\n+@subsection @code{_gfortran_caf_register} --- Registering coarrays\n+@cindex Coarray, _gfortran_caf_deregister\n+\n+@table @asis\n+@item @emph{Description}:\n+Allocates memory for a coarray and creates a token to identify the coarray. The\n+function is called for both coarrays with @code{SAVE} attribute and using an\n+explicit @code{ALLOCATE} statement. If an error occurs and @var{STAT} is a\n+@code{NULL} pointer, the function shall abort with printing an error message\n+and starting the error termination.  If no error occurs and @var{STAT} is\n+present, it shall be set to zero. Otherwise, it shall be set to a positive\n+value and, if not-@code{NULL}, @var{ERRMSG} shall be set to a string describing\n+the failure. The function shall return a pointer to the requested memory\n+for the local image as a call to @code{malloc} would do.\n+\n+@item @emph{Syntax}:\n+@code{void *caf_register (size_t size, caf_register_t type, caf_token_t *token,\n+int *stat, char *errmsg, int errmsg_len)}\n+\n+@item @emph{Arguments}:\n+@multitable @columnfractions .15 .70\n+@item @var{size} @tab byte size of the coarray to be allocated\n+@item @var{type} @tab one of the caf_register_t types.\n+@item @var{token} @tab intent(out) An opaque pointer identifying the coarray.\n+@item @var{stat} @tab intent(out) For allocatable coarrays, stores the STAT=; may be NULL\n+@item @var{errmsg} @tab intent(out) When an error occurs, this will be set to an error message; may be NULL\n+@item @var{errmsg_len} @tab the buffer size of errmsg.\n+@end multitable\n+\n+@item @emph{NOTES}\n+Nonalloatable coarrays have to be registered prior use from remote images.\n+In order to guarantee this, they have to be registered before the main\n+program. This can be achieved by creating constructor functions. That is what\n+GCC does such that also nonallocatable coarrays the memory is allocated and no\n+static memory is used.  The token permits to identify the coarray; to the\n+processor, the token is a nonaliasing pointer. The library can, for instance,\n+store the base address of the coarray in the token, some handle or a more\n+complicated struct.\n+@end table\n+\n+\n+@node _gfortran_caf_deregister\n+@subsection @code{_gfortran_caf_deregister} --- Deregistering coarrays\n+@cindex Coarray, _gfortran_caf_deregister\n+\n+@table @asis\n+@item @emph{Description}:\n+Called to free the memory of a coarray; the processor calls this function for\n+automatic and explicit deallocation.  In case of an error, this function shall\n+fail with an error message, unless the @var{STAT} variable is not null.\n+\n+@item @emph{Syntax}:\n+@code{void caf_deregister (const caf_token_t *token, int *stat, char *errmsg,\n+int errmsg_len)}\n+\n+@item @emph{Arguments}:\n+@multitable @columnfractions .15 .70\n+@item @var{stat} @tab intent(out) For allocatable coarrays, stores the STAT=; may be NULL\n+@item @var{errmsg} @tab intent(out) When an error occurs, this will be set to an error message; may be NULL\n+@item @var{errmsg_len} @tab the buffer size of errmsg.\n+@end multitable\n+\n+@item @emph{NOTES}\n+For nonalloatable coarrays this function is never called.  If a cleanup is\n+required, it has to be handled via the finish, stop and error stop functions,\n+and via destructors.\n+@end table\n+\n+\n+@node _gfortran_caf_send\n+@subsection @code{_gfortran_caf_send} --- Sending data from a local image to a remote image\n+@cindex Coarray, _gfortran_caf_send\n+\n+@table @asis\n+@item @emph{Description}:\n+Called to send a scalar, an array section or whole array from a local\n+to a remote image identified by the image_index.\n+\n+@item @emph{Syntax}:\n+@code{void _gfortran_caf_send (caf_token_t token, size_t offset,\n+int image_index, gfc_descriptor_t *dest, caf_vector_t *dst_vector,\n+gfc_descriptor_t *src, int dst_kind, int src_kind)}\n+\n+@item @emph{Arguments}:\n+@multitable @columnfractions .15 .70\n+@item @var{token} @tab intent(in)  An opaque pointer identifying the coarray.\n+@item @var{offset} @tab By which amount of bytes the actual data is shifted\n+compared to the base address of the coarray.\n+@item @var{image_index} @tab The ID of the remote image; must be a positive\n+number.\n+@item @var{dest} @tab intent(in) Array descriptor for the remote image for the\n+bounds and the size. The base_addr shall not be accessed.\n+@item @var{dst_vector} @tab intent(int)  If not NULL, it contains the vector\n+subscript of the destination array; the values are relative to the dimension\n+triplet of the dest argument.\n+@item @var{src} @tab intent(in) Array descriptor of the local array to be\n+transferred to the remote image\n+@item @var{dst_kind} @tab Kind of the destination argument\n+@item @var{src_kind} @tab Kind of the source argument\n+@end multitable\n+\n+@item @emph{NOTES}\n+It is permitted to have image_id equal the current image; the memory of the\n+send-to and the send-from might (partially) overlap in that case. The\n+implementation has to take care that it handles this case. Note that the\n+assignment of a scalar to an array is permitted. In addition, the library has\n+to handle numeric-type conversion and for strings, padding and different\n+character kinds.\n+@end table\n+\n+\n+@node _gfortran_caf_get\n+@subsection @code{_gfortran_caf_get} --- Getting data from a remote image\n+@cindex Coarray, _gfortran_caf_get\n+\n+@table @asis\n+@item @emph{Description}:\n+Called to get an array section or whole array from a a remote,\n+image identified by the image_index.\n+\n+@item @emph{Syntax}:\n+@code{void _gfortran_caf_get_desc (caf_token_t token, size_t offset,\n+int image_index, gfc_descriptor_t *src, caf_vector_t *src_vector,\n+gfc_descriptor_t *dest, int src_kind, int dst_kind)}\n+\n+@item @emph{Arguments}:\n+@multitable @columnfractions .15 .70\n+@item @var{token} @tab intent(in)  An opaque pointer identifying the coarray.\n+@item @var{offset} @tab By which amount of bytes the actual data is shifted\n+compared to the base address of the coarray.\n+@item @var{image_index} @tab The ID of the remote image; must be a positive\n+number.\n+@item @var{dest} @tab intent(in) Array descriptor of the local array to be\n+transferred to the remote image\n+@item @var{src} @tab intent(in) Array descriptor for the remote image for the\n+bounds and the size. The base_addr shall not be accessed.\n+@item @var{src_vector} @tab intent(int)  If not NULL, it contains the vector\n+subscript of the destination array; the values are relative to the dimension\n+triplet of the dest argument.\n+@item @var{dst_kind} @tab Kind of the destination argument\n+@item @var{src_kind} @tab Kind of the source argument\n+@end multitable\n+\n+@item @emph{NOTES}\n+It is permitted to have image_id equal the current image; the memory of the\n+send-to and the send-from might (partially) overlap in that case. The\n+implementation has to take care that it handles this case. Note that the\n+library has to handle numeric-type conversion and for strings, padding\n+and different character kinds.\n+@end table\n+\n+\n+@node _gfortran_caf_sendget\n+@subsection @code{_gfortran_caf_sendget} --- Sending data between remote images\n+@cindex Coarray, _gfortran_caf_sendget\n+\n+@table @asis\n+@item @emph{Description}:\n+Called to send a scalar, an array section or whole array from a remote image\n+identified by the src_image_index to a remote image identified by the\n+dst_image_index.\n+\n+@item @emph{Syntax}:\n+@code{void _gfortran_caf_sendget (caf_token_t dst_token, size_t dst_offset,\n+int dst_image_index, gfc_descriptor_t *dest, caf_vector_t *dst_vector,\n+caf_token_t src_token, size_t src_offset, int src_image_index,\n+gfc_descriptor_t *src, caf_vector_t *src_vector, int dst_kind, int src_kind)}\n+\n+@item @emph{Arguments}:\n+@multitable @columnfractions .15 .70\n+@item @var{dst_token} @tab intent(in)  An opaque pointer identifying the\n+destination coarray.\n+@item @var{dst_offset} @tab  By which amount of bytes the actual data is\n+shifted compared to the base address of the destination coarray.\n+@item @var{dst_image_index} @tab The ID of the destination remote image; must\n+be a positive number.\n+@item @var{dst_dest} @tab intent(in) Array descriptor for the destination\n+remote image for the bounds and the size. The base_addr shall not be accessed.\n+@item @var{dst_vector} @tab intent(int)  If not NULL, it contains the vector\n+subscript of the destination array; the values are relative to the dimension\n+triplet of the dest argument.\n+@item @var{src_token} @tab An opaque pointer identifying the source coarray.\n+@item @var{src_offset} @tab By which amount of bytes the actual data is shifted\n+compared to the base address of the source coarray.\n+@item @var{src_image_index} @tab The ID of the source remote image; must be a\n+positive number.\n+@item @var{src_dest} @tab intent(in) Array descriptor of the local array to be\n+transferred to the remote image.\n+@item @var{src_vector} @tab intent(in) Array descriptor of the local array to\n+be transferred to the remote image\n+@item @var{dst_kind} @tab Kind of the destination argument\n+@item @var{src_kind} @tab Kind of the source argument\n+@end multitable\n+\n+@item @emph{NOTES}\n+It is permitted to have image_id equal the current image; the memory of the\n+send-to and the send-from might (partially) overlap in that case. The\n+implementation has to take care that it handles this case. Note that the\n+assignment of a scalar to an array is permitted. In addition, the library has\n+to handle numeric-type conversion and for strings, padding and different\n+character kinds.\n+@end table\n+\n+\n+\n+\n \n @c Intrinsic Procedures\n @c ---------------------------------------------------------------------"}]}