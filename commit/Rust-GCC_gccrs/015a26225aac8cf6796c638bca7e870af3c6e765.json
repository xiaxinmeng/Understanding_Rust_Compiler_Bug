{"sha": "015a26225aac8cf6796c638bca7e870af3c6e765", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDE1YTI2MjI1YWFjOGNmNjc5NmM2MzhiY2E3ZTg3MGFmM2M2ZTc2NQ==", "commit": {"author": {"name": "Uros Bizjak", "email": "uros@gcc.gnu.org", "date": "2012-11-21T13:20:37Z"}, "committer": {"name": "Uros Bizjak", "email": "uros@gcc.gnu.org", "date": "2012-11-21T13:20:37Z"}, "message": "* config/i386/i386.md\n\t(*float<SWI48x:mode><MODEF:mode>2_mixed_with_temp): Use SWI48 mode\n\titerator instead of SWI48x.  Update insn constraint.\n\t(*float<SWI48x:mode><MODEF:mode>2_mixed_interunit): Ditto.\n\t(*float<SWI48x:mode><MODEF:mode>2_mixed_nointerunit): Ditto.\n\t(*float<SWI48x:mode><MODEF:mode>2_sse_with_temp): Ditto.\n\t(*float<SWI48x:mode><MODEF:mode>2_sse_interunit): Ditto.\n\t(*float<SWI48x:mode><MODEF:mode>2_sse_nointerunit): Ditto.\n\t(*float<SWI48x:mode><MODEF:mode>2 splitters): Ditto.\n\t(lrint<MODEF:mode><SWI48x:mode>2): Ditto.\n\nFrom-SVN: r193692", "tree": {"sha": "de7960f2862420f3617522e3b8b496b0822ed543", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/de7960f2862420f3617522e3b8b496b0822ed543"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/015a26225aac8cf6796c638bca7e870af3c6e765", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/015a26225aac8cf6796c638bca7e870af3c6e765", "html_url": "https://github.com/Rust-GCC/gccrs/commit/015a26225aac8cf6796c638bca7e870af3c6e765", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/015a26225aac8cf6796c638bca7e870af3c6e765/comments", "author": null, "committer": null, "parents": [{"sha": "c3e3d235489be0ffa764ab81f4d018b96b2a0d16", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c3e3d235489be0ffa764ab81f4d018b96b2a0d16", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c3e3d235489be0ffa764ab81f4d018b96b2a0d16"}], "stats": {"total": 128, "additions": 65, "deletions": 63}, "files": [{"sha": "e071a680eb3b85e1e2a790d39a82030ce7b7d480", "filename": "gcc/ChangeLog", "status": "modified", "additions": 16, "deletions": 2, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/015a26225aac8cf6796c638bca7e870af3c6e765/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/015a26225aac8cf6796c638bca7e870af3c6e765/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=015a26225aac8cf6796c638bca7e870af3c6e765", "patch": "@@ -1,3 +1,16 @@\n+2012-11-21  Uros Bizjak  <ubizjak@gmail.com>\n+\n+\t* config/i386/i386.md\n+\t(*float<SWI48x:mode><MODEF:mode>2_mixed_with_temp): Use SWI48 mode\n+\titerator instead of SWI48x.  Update insn constraint.\n+\t(*float<SWI48x:mode><MODEF:mode>2_mixed_interunit): Ditto.\n+\t(*float<SWI48x:mode><MODEF:mode>2_mixed_nointerunit): Ditto.\n+\t(*float<SWI48x:mode><MODEF:mode>2_sse_with_temp): Ditto.\n+\t(*float<SWI48x:mode><MODEF:mode>2_sse_interunit): Ditto.\n+\t(*float<SWI48x:mode><MODEF:mode>2_sse_nointerunit): Ditto.\n+\t(*float<SWI48x:mode><MODEF:mode>2 splitters): Ditto.\n+\t(lrint<MODEF:mode><SWI48x:mode>2): Ditto.\n+\n 2012-11-21  Marcus Shawcroft  <marcus.shawcroft@arm.com>\n \n \t* Makefile.in (gengtype-lex.o): Add dependency on $(BCONFIG_H).\n@@ -95,13 +108,14 @@\n \t(peephole2 to shorten x87->SSE reload sequences): Remove peephole2.\n \t* config/i386/i386.h (enum ix86_tune_indices)\n \t<IX86_TUNE_SHORTEN_X87_SSE>: Remove.\n-\t* config/i386/i386.h (initial_ix86_tune_features): Update.\n+\t(TARGET_SHORTEN_X87_SSE): Remove.\n+\t* config/i386/i386.c (initial_ix86_tune_features): Update.\n \n 2012-11-20  Vladimir Makarov  <vmakarov@redhat.com>\n \n \tPR target/19398\n \t* lra-constraints.c (process_alt_operands): Discourage reloads\n-\tthrough secodnary memory.\n+\tthrough secondary memory.\n \n 2012-11-20  David Edelsohn  <dje.gcc@gmail.com>\n "}, {"sha": "b0821c045e7f41b5bccf0a88dababdf744793f5f", "filename": "gcc/config/i386/i386.md", "status": "modified", "additions": 49, "deletions": 61, "changes": 110, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/015a26225aac8cf6796c638bca7e870af3c6e765/gcc%2Fconfig%2Fi386%2Fi386.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/015a26225aac8cf6796c638bca7e870af3c6e765/gcc%2Fconfig%2Fi386%2Fi386.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.md?ref=015a26225aac8cf6796c638bca7e870af3c6e765", "patch": "@@ -4906,13 +4906,12 @@\n    (set_attr \"bdver1_decode\" \"*,direct\")\n    (set_attr \"fp_int_src\" \"true\")])\n \n-(define_insn \"*float<SWI48x:mode><MODEF:mode>2_mixed_with_temp\"\n+(define_insn \"*float<SWI48:mode><MODEF:mode>2_mixed_with_temp\"\n   [(set (match_operand:MODEF 0 \"register_operand\" \"=f,f,x,x\")\n \t(float:MODEF\n-\t  (match_operand:SWI48x 1 \"nonimmediate_operand\" \"m,?r,r,m\")))\n-   (clobber (match_operand:SWI48x 2 \"memory_operand\" \"=X,m,m,X\"))]\n-  \"(<SWI48x:MODE>mode != DImode || TARGET_64BIT)\n-   && SSE_FLOAT_MODE_P (<MODEF:MODE>mode) && TARGET_MIX_SSE_I387\"\n+\t  (match_operand:SWI48 1 \"nonimmediate_operand\" \"m,?r,r,m\")))\n+   (clobber (match_operand:SWI48 2 \"memory_operand\" \"=X,m,m,X\"))]\n+  \"SSE_FLOAT_MODE_P (<MODEF:MODE>mode) && TARGET_MIX_SSE_I387\"\n   \"#\"\n   [(set_attr \"type\" \"fmov,multi,sseicvt,sseicvt\")\n    (set_attr \"mode\" \"<MODEF:MODE>\")\n@@ -4924,10 +4923,9 @@\n \n (define_split\n   [(set (match_operand:MODEF 0 \"register_operand\")\n-\t(float:MODEF (match_operand:SWI48x 1 \"register_operand\")))\n-   (clobber (match_operand:SWI48x 2 \"memory_operand\"))]\n-  \"(<SWI48x:MODE>mode != DImode || TARGET_64BIT)\n-   && SSE_FLOAT_MODE_P (<MODEF:MODE>mode) && TARGET_MIX_SSE_I387\n+\t(float:MODEF (match_operand:SWI48 1 \"register_operand\")))\n+   (clobber (match_operand:SWI48 2 \"memory_operand\"))]\n+  \"SSE_FLOAT_MODE_P (<MODEF:MODE>mode) && TARGET_MIX_SSE_I387\n    && TARGET_INTER_UNIT_CONVERSIONS\n    && reload_completed\n    && (SSE_REG_P (operands[0])\n@@ -4937,10 +4935,9 @@\n \n (define_split\n   [(set (match_operand:MODEF 0 \"register_operand\")\n-\t(float:MODEF (match_operand:SWI48x 1 \"register_operand\")))\n-   (clobber (match_operand:SWI48x 2 \"memory_operand\"))]\n-  \"(<SWI48x:MODE>mode != DImode || TARGET_64BIT)\n-   && SSE_FLOAT_MODE_P (<MODEF:MODE>mode) && TARGET_MIX_SSE_I387\n+\t(float:MODEF (match_operand:SWI48 1 \"register_operand\")))\n+   (clobber (match_operand:SWI48 2 \"memory_operand\"))]\n+  \"SSE_FLOAT_MODE_P (<MODEF:MODE>mode) && TARGET_MIX_SSE_I387\n    && !(TARGET_INTER_UNIT_CONVERSIONS || optimize_function_for_size_p (cfun))\n    && reload_completed\n    && (SSE_REG_P (operands[0])\n@@ -4949,24 +4946,23 @@\n   [(set (match_dup 2) (match_dup 1))\n    (set (match_dup 0) (float:MODEF (match_dup 2)))])\n \n-(define_insn \"*float<SWI48x:mode><MODEF:mode>2_mixed_interunit\"\n+(define_insn \"*float<SWI48:mode><MODEF:mode>2_mixed_interunit\"\n   [(set (match_operand:MODEF 0 \"register_operand\" \"=f,x,x\")\n \t(float:MODEF\n-\t  (match_operand:SWI48x 1 \"nonimmediate_operand\" \"m,r,m\")))]\n-  \"(<SWI48x:MODE>mode != DImode || TARGET_64BIT)\n-   && SSE_FLOAT_MODE_P (<MODEF:MODE>mode) && TARGET_MIX_SSE_I387\n+\t  (match_operand:SWI48 1 \"nonimmediate_operand\" \"m,r,m\")))]\n+  \"SSE_FLOAT_MODE_P (<MODEF:MODE>mode) && TARGET_MIX_SSE_I387\n    && (TARGET_INTER_UNIT_CONVERSIONS || optimize_function_for_size_p (cfun))\"\n   \"@\n    fild%Z1\\t%1\n-   %vcvtsi2<MODEF:ssemodesuffix><SWI48x:rex64suffix>\\t{%1, %d0|%d0, %1}\n-   %vcvtsi2<MODEF:ssemodesuffix><SWI48x:rex64suffix>\\t{%1, %d0|%d0, %1}\"\n+   %vcvtsi2<MODEF:ssemodesuffix><SWI48:rex64suffix>\\t{%1, %d0|%d0, %1}\n+   %vcvtsi2<MODEF:ssemodesuffix><SWI48:rex64suffix>\\t{%1, %d0|%d0, %1}\"\n   [(set_attr \"type\" \"fmov,sseicvt,sseicvt\")\n    (set_attr \"prefix\" \"orig,maybe_vex,maybe_vex\")\n    (set_attr \"mode\" \"<MODEF:MODE>\")\n    (set (attr \"prefix_rex\")\n      (if_then_else\n        (and (eq_attr \"prefix\" \"maybe_vex\")\n-\t    (match_test \"<SWI48x:MODE>mode == DImode\"))\n+\t    (match_test \"<SWI48:MODE>mode == DImode\"))\n        (const_string \"1\")\n        (const_string \"*\")))\n    (set_attr \"unit\" \"i387,*,*\")\n@@ -4975,23 +4971,22 @@\n    (set_attr \"bdver1_decode\" \"*,double,direct\")\n    (set_attr \"fp_int_src\" \"true\")])\n \n-(define_insn \"*float<SWI48x:mode><MODEF:mode>2_mixed_nointerunit\"\n+(define_insn \"*float<SWI48:mode><MODEF:mode>2_mixed_nointerunit\"\n   [(set (match_operand:MODEF 0 \"register_operand\" \"=f,x\")\n \t(float:MODEF\n-\t  (match_operand:SWI48x 1 \"memory_operand\" \"m,m\")))]\n-  \"(<SWI48x:MODE>mode != DImode || TARGET_64BIT)\n-   && SSE_FLOAT_MODE_P (<MODEF:MODE>mode) && TARGET_MIX_SSE_I387\n+\t  (match_operand:SWI48 1 \"memory_operand\" \"m,m\")))]\n+  \"SSE_FLOAT_MODE_P (<MODEF:MODE>mode) && TARGET_MIX_SSE_I387\n    && !(TARGET_INTER_UNIT_CONVERSIONS || optimize_function_for_size_p (cfun))\"\n   \"@\n    fild%Z1\\t%1\n-   %vcvtsi2<MODEF:ssemodesuffix><SWI48x:rex64suffix>\\t{%1, %d0|%d0, %1}\"\n+   %vcvtsi2<MODEF:ssemodesuffix><SWI48:rex64suffix>\\t{%1, %d0|%d0, %1}\"\n   [(set_attr \"type\" \"fmov,sseicvt\")\n    (set_attr \"prefix\" \"orig,maybe_vex\")\n    (set_attr \"mode\" \"<MODEF:MODE>\")\n    (set (attr \"prefix_rex\")\n      (if_then_else\n        (and (eq_attr \"prefix\" \"maybe_vex\")\n-\t    (match_test \"<SWI48x:MODE>mode == DImode\"))\n+\t    (match_test \"<SWI48:MODE>mode == DImode\"))\n        (const_string \"1\")\n        (const_string \"*\")))\n    (set_attr \"athlon_decode\" \"*,direct\")\n@@ -5165,13 +5160,12 @@\n   DONE;\n })\n \n-(define_insn \"*float<SWI48x:mode><MODEF:mode>2_sse_with_temp\"\n+(define_insn \"*float<SWI48:mode><MODEF:mode>2_sse_with_temp\"\n   [(set (match_operand:MODEF 0 \"register_operand\" \"=x,x\")\n \t(float:MODEF\n-\t  (match_operand:SWI48x 1 \"nonimmediate_operand\" \"r,m\")))\n-  (clobber (match_operand:SWI48x 2 \"memory_operand\" \"=m,X\"))]\n-  \"(<SWI48x:MODE>mode != DImode || TARGET_64BIT)\n-   && SSE_FLOAT_MODE_P (<MODEF:MODE>mode) && TARGET_SSE_MATH\"\n+\t  (match_operand:SWI48 1 \"nonimmediate_operand\" \"r,m\")))\n+  (clobber (match_operand:SWI48 2 \"memory_operand\" \"=m,X\"))]\n+  \"SSE_FLOAT_MODE_P (<MODEF:MODE>mode) && TARGET_SSE_MATH\"\n   \"#\"\n   [(set_attr \"type\" \"sseicvt\")\n    (set_attr \"mode\" \"<MODEF:MODE>\")\n@@ -5180,21 +5174,20 @@\n    (set_attr \"bdver1_decode\" \"double,direct\")\n    (set_attr \"fp_int_src\" \"true\")])\n \n-(define_insn \"*float<SWI48x:mode><MODEF:mode>2_sse_interunit\"\n+(define_insn \"*float<SWI48:mode><MODEF:mode>2_sse_interunit\"\n   [(set (match_operand:MODEF 0 \"register_operand\" \"=x,x\")\n \t(float:MODEF\n-\t  (match_operand:SWI48x 1 \"nonimmediate_operand\" \"r,m\")))]\n-  \"(<SWI48x:MODE>mode != DImode || TARGET_64BIT)\n-   && SSE_FLOAT_MODE_P (<MODEF:MODE>mode) && TARGET_SSE_MATH\n+\t  (match_operand:SWI48 1 \"nonimmediate_operand\" \"r,m\")))]\n+  \"SSE_FLOAT_MODE_P (<MODEF:MODE>mode) && TARGET_SSE_MATH\n    && (TARGET_INTER_UNIT_CONVERSIONS || optimize_function_for_size_p (cfun))\"\n-  \"%vcvtsi2<MODEF:ssemodesuffix><SWI48x:rex64suffix>\\t{%1, %d0|%d0, %1}\"\n+  \"%vcvtsi2<MODEF:ssemodesuffix><SWI48:rex64suffix>\\t{%1, %d0|%d0, %1}\"\n   [(set_attr \"type\" \"sseicvt\")\n    (set_attr \"prefix\" \"maybe_vex\")\n    (set_attr \"mode\" \"<MODEF:MODE>\")\n    (set (attr \"prefix_rex\")\n      (if_then_else\n        (and (eq_attr \"prefix\" \"maybe_vex\")\n-\t    (match_test \"<SWI48x:MODE>mode == DImode\"))\n+\t    (match_test \"<SWI48:MODE>mode == DImode\"))\n        (const_string \"1\")\n        (const_string \"*\")))\n    (set_attr \"athlon_decode\" \"double,direct\")\n@@ -5204,32 +5197,30 @@\n \n (define_split\n   [(set (match_operand:MODEF 0 \"register_operand\")\n-\t(float:MODEF (match_operand:SWI48x 1 \"nonimmediate_operand\")))\n-   (clobber (match_operand:SWI48x 2 \"memory_operand\"))]\n-  \"(<SWI48x:MODE>mode != DImode || TARGET_64BIT)\n-   && SSE_FLOAT_MODE_P (<MODEF:MODE>mode) && TARGET_SSE_MATH\n+\t(float:MODEF (match_operand:SWI48 1 \"nonimmediate_operand\")))\n+   (clobber (match_operand:SWI48 2 \"memory_operand\"))]\n+  \"SSE_FLOAT_MODE_P (<MODEF:MODE>mode) && TARGET_SSE_MATH\n    && (TARGET_INTER_UNIT_CONVERSIONS || optimize_function_for_size_p (cfun))\n    && reload_completed\n    && (SSE_REG_P (operands[0])\n        || (GET_CODE (operands[0]) == SUBREG\n \t   && SSE_REG_P (SUBREG_REG (operands[0]))))\"\n   [(set (match_dup 0) (float:MODEF (match_dup 1)))])\n \n-(define_insn \"*float<SWI48x:mode><MODEF:mode>2_sse_nointerunit\"\n+(define_insn \"*float<SWI48:mode><MODEF:mode>2_sse_nointerunit\"\n   [(set (match_operand:MODEF 0 \"register_operand\" \"=x\")\n \t(float:MODEF\n-\t  (match_operand:SWI48x 1 \"memory_operand\" \"m\")))]\n-  \"(<SWI48x:MODE>mode != DImode || TARGET_64BIT)\n-   && SSE_FLOAT_MODE_P (<MODEF:MODE>mode) && TARGET_SSE_MATH\n+\t  (match_operand:SWI48 1 \"memory_operand\" \"m\")))]\n+  \"SSE_FLOAT_MODE_P (<MODEF:MODE>mode) && TARGET_SSE_MATH\n    && !(TARGET_INTER_UNIT_CONVERSIONS || optimize_function_for_size_p (cfun))\"\n-  \"%vcvtsi2<MODEF:ssemodesuffix><SWI48x:rex64suffix>\\t{%1, %d0|%d0, %1}\"\n+  \"%vcvtsi2<MODEF:ssemodesuffix><SWI48:rex64suffix>\\t{%1, %d0|%d0, %1}\"\n   [(set_attr \"type\" \"sseicvt\")\n    (set_attr \"prefix\" \"maybe_vex\")\n    (set_attr \"mode\" \"<MODEF:MODE>\")\n    (set (attr \"prefix_rex\")\n      (if_then_else\n        (and (eq_attr \"prefix\" \"maybe_vex\")\n-\t    (match_test \"<SWI48x:MODE>mode == DImode\"))\n+\t    (match_test \"<SWI48:MODE>mode == DImode\"))\n        (const_string \"1\")\n        (const_string \"*\")))\n    (set_attr \"athlon_decode\" \"direct\")\n@@ -5239,10 +5230,9 @@\n \n (define_split\n   [(set (match_operand:MODEF 0 \"register_operand\")\n-\t(float:MODEF (match_operand:SWI48x 1 \"register_operand\")))\n-   (clobber (match_operand:SWI48x 2 \"memory_operand\"))]\n-  \"(<SWI48x:MODE>mode != DImode || TARGET_64BIT)\n-   && SSE_FLOAT_MODE_P (<MODEF:MODE>mode) && TARGET_SSE_MATH\n+\t(float:MODEF (match_operand:SWI48 1 \"register_operand\")))\n+   (clobber (match_operand:SWI48 2 \"memory_operand\"))]\n+  \"SSE_FLOAT_MODE_P (<MODEF:MODE>mode) && TARGET_SSE_MATH\n    && !(TARGET_INTER_UNIT_CONVERSIONS || optimize_function_for_size_p (cfun))\n    && reload_completed\n    && (SSE_REG_P (operands[0])\n@@ -5253,10 +5243,9 @@\n \n (define_split\n   [(set (match_operand:MODEF 0 \"register_operand\")\n-\t(float:MODEF (match_operand:SWI48x 1 \"memory_operand\")))\n-   (clobber (match_operand:SWI48x 2 \"memory_operand\"))]\n-  \"(<SWI48x:MODE>mode != DImode || TARGET_64BIT)\n-   && SSE_FLOAT_MODE_P (<MODEF:MODE>mode) && TARGET_SSE_MATH\n+\t(float:MODEF (match_operand:SWI48 1 \"memory_operand\")))\n+   (clobber (match_operand:SWI48 2 \"memory_operand\"))]\n+  \"SSE_FLOAT_MODE_P (<MODEF:MODE>mode) && TARGET_SSE_MATH\n    && reload_completed\n    && (SSE_REG_P (operands[0])\n        || (GET_CODE (operands[0]) == SUBREG\n@@ -14867,12 +14856,11 @@\n \t\t     UNSPEC_FIST))]\n   \"TARGET_USE_FANCY_MATH_387\")\n \n-(define_expand \"lrint<MODEF:mode><SWI48x:mode>2\"\n-  [(set (match_operand:SWI48x 0 \"nonimmediate_operand\")\n-     (unspec:SWI48x [(match_operand:MODEF 1 \"register_operand\")]\n-\t\t\tUNSPEC_FIX_NOTRUNC))]\n-  \"SSE_FLOAT_MODE_P (<MODEF:MODE>mode) && TARGET_SSE_MATH\n-   && ((<SWI48x:MODE>mode != DImode) || TARGET_64BIT)\")\n+(define_expand \"lrint<MODEF:mode><SWI48:mode>2\"\n+  [(set (match_operand:SWI48 0 \"nonimmediate_operand\")\n+     (unspec:SWI48 [(match_operand:MODEF 1 \"register_operand\")]\n+\t\t   UNSPEC_FIX_NOTRUNC))]\n+  \"SSE_FLOAT_MODE_P (<MODEF:MODE>mode) && TARGET_SSE_MATH\")\n \n (define_expand \"lround<X87MODEF:mode><SWI248x:mode>2\"\n   [(match_operand:SWI248x 0 \"nonimmediate_operand\")"}]}