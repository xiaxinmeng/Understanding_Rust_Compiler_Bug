{"sha": "b731b39027f635f0afa97010e803212c1133ee55", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjczMWIzOTAyN2Y2MzVmMGFmYTk3MDEwZTgwMzIxMmMxMTMzZWU1NQ==", "commit": {"author": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2014-11-29T11:35:30Z"}, "committer": {"name": "Jakub Jelinek", "email": "jakub@gcc.gnu.org", "date": "2014-11-29T11:35:30Z"}, "message": "gimple-expr.h (create_tmp_var_raw, [...]): Add default NULL value to last argument.\n\n\t* gimple-expr.h (create_tmp_var_raw, create_tmp_var,\n\tcreate_tmp_reg): Add default NULL value to last argument.\n\t* tree-ssanames.h (make_ssa_name, copy_ssa_name): Likewise.\n\t* gimple-low.c (lower_builtin_posix_memalign): Remove NULL\n\tlast argument from create_tmp_var_raw, create_tmp_var,\n\tcreate_tmp_reg, make_ssa_name and copy_ssa_name calls.\n\t* tree-ssa-strlen.c (get_string_length): Likewise.\n\t* tree-emutls.c (gen_emutls_addr, lower_emutls_1): Likewise.\n\t* tree-ssa-phiprop.c (phiprop_insert_phi): Likewise.\n\t* tree-vect-slp.c (vect_get_constant_vectors): Likewise.\n\t* ipa-prop.c (ipa_modify_call_arguments): Likewise.\n\t* tree-ssa-forwprop.c (simplify_rotate): Likewise.\n\t* tree-ssa-ccp.c (fold_builtin_alloca_with_align): Likewise.\n\t* asan.c (build_shadow_mem_access, maybe_create_ssa_name,\n\tmaybe_cast_to_ptrmode, asan_expand_check_ifn): Likewise.\n\t* tsan.c (instrument_expr, instrument_builtin_call,\n\tinstrument_func_entry): Likewise.\n\t* varpool.c (add_new_static_var): Likewise.\n\t* tree-loop-distribution.c (generate_memset_builtin): Likewise.\n\t* gimplify.c (internal_get_tmp_var, gimplify_return_expr,\n\tgimplify_modify_expr_to_memcpy, gimplify_modify_expr_to_memset,\n\tgimplify_init_ctor_eval_range, gimplify_init_constructor,\n\tgimplify_omp_atomic, gimplify_expr): Likewise.\n\t* gimple-builder.c (build_assign, build_type_cast): Likewise.\n\t* tree-vect-loop-manip.c (slpeel_update_phi_nodes_for_guard1,\n\tslpeel_update_phi_nodes_for_guard2, slpeel_tree_peel_loop_to_edge,\n\tvect_loop_versioning): Likewise.\n\t* tree-if-conv.c (version_loop_for_if_conversion): Likewise.\n\t* gimple-match-head.c (maybe_push_res_to_seq): Likewise.\n\t* tree-vect-patterns.c (vect_handle_widen_op_by_const,\n\tvect_recog_widen_mult_pattern, vect_operation_fits_smaller_type,\n\tvect_recog_over_widening_pattern): Likewise.\n\t* tree-sra.c (build_ref_for_offset, create_access_replacement):\n\tLikewise.\n\t* tree-cfg.c (make_blocks): Likewise.\n\t* tree-eh.c (lower_eh_constructs_2, lower_resx, lower_eh_dispatch):\n\tLikewise.\n\t* tree-ssa-propagate.c (update_call_from_tree): Likewise.\n\t* tree-complex.c (get_component_ssa_name, expand_complex_div_wide):\n\tLikewise.\n\t* tree-ssa-math-opts.c (build_and_insert_cast): Likewise.\n\t* tree-tailcall.c (update_accumulator_with_ops): Likewise.\n\t* tree-predcom.c (initialize_root_vars, initialize_root_vars_lm,\n\texecute_load_motion, reassociate_to_the_same_stmt): Likewise.\n\t* tree-ssa-reassoc.c (build_and_add_sum,\n\toptimize_range_tests_to_bit_test, update_ops,\n\tmaybe_optimize_range_tests, rewrite_expr_tree, linearize_expr,\n\tnegate_value, repropagate_negates): Likewise.\n\t* tree-vect-loop.c (vect_is_simple_reduction_1,\n\tvect_create_epilog_for_reduction): Likewise.\n\t* ipa-split.c (split_function): Likewise.\n\t* tree-inline.c (remap_ssa_name, setup_one_parameter,\n\tdeclare_return_variable, tree_function_versioning): Likewise.\n\t* tree-cfgcleanup.c (fixup_noreturn_call): Likewise.\n\t* cfgexpand.c (update_alias_info_with_stack_vars, expand_used_vars):\n\tLikewise.\n\t* tree-ssa-phiopt.c (conditional_replacement, abs_replacement,\n\tneg_replacement): Likewise.\n\t* gimplify-me.c (force_gimple_operand_1, gimple_regimplify_operands):\n\tLikewise.\n\t* tree-vrp.c (simplify_truth_ops_using_ranges,\n\tsimplify_float_conversion_using_ranges,\n\tsimplify_internal_call_using_ranges): Likewise.\n\t* tree-switch-conversion.c (emit_case_bit_tests,\n\tbuild_one_array, build_arrays, gen_def_assigns): Likewise.\n\t* gimple-fold.c (gimple_fold_builtin_memory_op,\n\tgimple_fold_builtin_strcat, gimple_fold_call, gimple_build): Likewise.\n\t* tree-vect-generic.c (expand_vector_divmod,\n\toptimize_vector_constructor): Likewise.\n\t* ubsan.c (ubsan_encode_value, ubsan_expand_null_ifn,\n\tubsan_expand_objsize_ifn, instrument_si_overflow,\n\tinstrument_bool_enum_load, instrument_nonnull_arg): Likewise.\n\t* tree-outof-ssa.c (insert_backedge_copies): Likewise.\n\t* tree-ssa-loop-manip.c (create_iv,\n\ttree_transform_and_unroll_loop): Likewise.\n\t* omp-low.c (scan_omp_parallel, lower_rec_simd_input_clauses,\n\tlower_rec_input_clauses, lower_lastprivate_clauses,\n\texpand_parallel_call, expand_omp_for_static_chunk,\n\texpand_omp_atomic_pipeline, expand_omp_target,\n\tmaybe_add_implicit_barrier_cancel, lower_omp_single_simple,\n\tlower_omp_critical, lower_omp_for, task_copyfn_copy_decl,\n\tlower_depend_clauses, lower_omp_target, lower_omp_1,\n\tipa_simd_modify_stmt_ops, simd_clone_adjust): Likewise.\n\t* tree-parloops.c (take_address_of, create_phi_for_local_result,\n\tcreate_call_for_reduction_1, separate_decls_in_region,\n\tcreate_parallel_loop): Likewise.\n\t* graphite-sese-to-poly.c (rewrite_cross_bb_scalar_dependence,\n\thandle_scalar_deps_crossing_scop_limits): Likewise.\n\t* trans-mem.c (lower_transaction, build_tm_load, build_tm_store,\n\texpand_assign_tm, expand_call_tm, expand_transaction,\n\tipa_tm_insert_gettmclone_call): Likewise.\n\t* tree-vect-data-refs.c (bump_vector_ptr, vect_setup_realignment):\n\tLikewise.\n\t* tree-vect-stmts.c (vect_init_vector, vectorizable_mask_load_store,\n\tvectorizable_call, vectorizable_simd_clone_call,\n\tvectorizable_conversion, vectorizable_store, permute_vec_elements,\n\tvectorizable_load): Likewise.\nc/\n\t* c-typeck.c (convert_lvalue_to_rvalue, build_atomic_assign,\n\tc_finish_stmt_expr): Remove NULL last argument from\n\tcreate_tmp_var_raw and create_tmp_var calls.\n\t* c-array-notation.c (fix_builtin_array_notation_fn,\n\tbuild_array_notation_expr, fix_conditional_array_notations_1,\n\tfix_array_notation_expr, fix_array_notation_call_expr): Likewise.\ncp/\n\t* cp-gimplify.c (cxx_omp_clause_apply_fn): Remove NULL last argument\n\tfrom create_tmp_var calls.\nc-family/\n\t* c-common.c (convert_vector_to_pointer_for_subscript): Remove NULL\n\tlast argument from create_tmp_var_raw and create_tmp_var calls.\n\t* cilk.c (gimplify_cilk_spawn): Likewise.\n\t* c-omp.c (c_finish_omp_atomic): Likewise.\nfortran/\n\t* trans-openmp.c (gfc_omp_finish_clause,\n\tgfc_trans_omp_array_reduction_or_udr, gfc_trans_omp_atomic): Remove\n\tNULL last argument from create_tmp_var_raw and create_tmp_var calls.\n\nFrom-SVN: r218181", "tree": {"sha": "e3c645b51a02b878b08ab7f21402a4a2a22c7d4e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e3c645b51a02b878b08ab7f21402a4a2a22c7d4e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b731b39027f635f0afa97010e803212c1133ee55", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b731b39027f635f0afa97010e803212c1133ee55", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b731b39027f635f0afa97010e803212c1133ee55", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b731b39027f635f0afa97010e803212c1133ee55/comments", "author": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "d0e168a01625742725503a68c1ebf8b64d5f8f11", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d0e168a01625742725503a68c1ebf8b64d5f8f11", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d0e168a01625742725503a68c1ebf8b64d5f8f11"}], "stats": {"total": 705, "additions": 405, "deletions": 300}, "files": [{"sha": "075ccbfca02e3fcfffc1de2ac4fa612b66c00e56", "filename": "gcc/ChangeLog", "status": "modified", "additions": 100, "deletions": 0, "changes": 100, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b731b39027f635f0afa97010e803212c1133ee55/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b731b39027f635f0afa97010e803212c1133ee55/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=b731b39027f635f0afa97010e803212c1133ee55", "patch": "@@ -1,3 +1,103 @@\n+2014-11-29  Jakub Jelinek  <jakub@redhat.com>\n+\n+\t* gimple-expr.h (create_tmp_var_raw, create_tmp_var,\n+\tcreate_tmp_reg): Add default NULL value to last argument.\n+\t* tree-ssanames.h (make_ssa_name, copy_ssa_name): Likewise.\n+\t* gimple-low.c (lower_builtin_posix_memalign): Remove NULL\n+\tlast argument from create_tmp_var_raw, create_tmp_var,\n+\tcreate_tmp_reg, make_ssa_name and copy_ssa_name calls.\n+\t* tree-ssa-strlen.c (get_string_length): Likewise.\n+\t* tree-emutls.c (gen_emutls_addr, lower_emutls_1): Likewise.\n+\t* tree-ssa-phiprop.c (phiprop_insert_phi): Likewise.\n+\t* tree-vect-slp.c (vect_get_constant_vectors): Likewise.\n+\t* ipa-prop.c (ipa_modify_call_arguments): Likewise.\n+\t* tree-ssa-forwprop.c (simplify_rotate): Likewise.\n+\t* tree-ssa-ccp.c (fold_builtin_alloca_with_align): Likewise.\n+\t* asan.c (build_shadow_mem_access, maybe_create_ssa_name,\n+\tmaybe_cast_to_ptrmode, asan_expand_check_ifn): Likewise.\n+\t* tsan.c (instrument_expr, instrument_builtin_call,\n+\tinstrument_func_entry): Likewise.\n+\t* varpool.c (add_new_static_var): Likewise.\n+\t* tree-loop-distribution.c (generate_memset_builtin): Likewise.\n+\t* gimplify.c (internal_get_tmp_var, gimplify_return_expr,\n+\tgimplify_modify_expr_to_memcpy, gimplify_modify_expr_to_memset,\n+\tgimplify_init_ctor_eval_range, gimplify_init_constructor,\n+\tgimplify_omp_atomic, gimplify_expr): Likewise.\n+\t* gimple-builder.c (build_assign, build_type_cast): Likewise.\n+\t* tree-vect-loop-manip.c (slpeel_update_phi_nodes_for_guard1,\n+\tslpeel_update_phi_nodes_for_guard2, slpeel_tree_peel_loop_to_edge,\n+\tvect_loop_versioning): Likewise.\n+\t* tree-if-conv.c (version_loop_for_if_conversion): Likewise.\n+\t* gimple-match-head.c (maybe_push_res_to_seq): Likewise.\n+\t* tree-vect-patterns.c (vect_handle_widen_op_by_const,\n+\tvect_recog_widen_mult_pattern, vect_operation_fits_smaller_type,\n+\tvect_recog_over_widening_pattern): Likewise.\n+\t* tree-sra.c (build_ref_for_offset, create_access_replacement):\n+\tLikewise.\n+\t* tree-cfg.c (make_blocks): Likewise.\n+\t* tree-eh.c (lower_eh_constructs_2, lower_resx, lower_eh_dispatch):\n+\tLikewise.\n+\t* tree-ssa-propagate.c (update_call_from_tree): Likewise.\n+\t* tree-complex.c (get_component_ssa_name, expand_complex_div_wide):\n+\tLikewise.\n+\t* tree-ssa-math-opts.c (build_and_insert_cast): Likewise.\n+\t* tree-tailcall.c (update_accumulator_with_ops): Likewise.\n+\t* tree-predcom.c (initialize_root_vars, initialize_root_vars_lm,\n+\texecute_load_motion, reassociate_to_the_same_stmt): Likewise.\n+\t* tree-ssa-reassoc.c (build_and_add_sum,\n+\toptimize_range_tests_to_bit_test, update_ops,\n+\tmaybe_optimize_range_tests, rewrite_expr_tree, linearize_expr,\n+\tnegate_value, repropagate_negates): Likewise.\n+\t* tree-vect-loop.c (vect_is_simple_reduction_1,\n+\tvect_create_epilog_for_reduction): Likewise.\n+\t* ipa-split.c (split_function): Likewise.\n+\t* tree-inline.c (remap_ssa_name, setup_one_parameter,\n+\tdeclare_return_variable, tree_function_versioning): Likewise.\n+\t* tree-cfgcleanup.c (fixup_noreturn_call): Likewise.\n+\t* cfgexpand.c (update_alias_info_with_stack_vars, expand_used_vars):\n+\tLikewise.\n+\t* tree-ssa-phiopt.c (conditional_replacement, abs_replacement,\n+\tneg_replacement): Likewise.\n+\t* gimplify-me.c (force_gimple_operand_1, gimple_regimplify_operands):\n+\tLikewise.\n+\t* tree-vrp.c (simplify_truth_ops_using_ranges,\n+\tsimplify_float_conversion_using_ranges,\n+\tsimplify_internal_call_using_ranges): Likewise.\n+\t* tree-switch-conversion.c (emit_case_bit_tests,\n+\tbuild_one_array, build_arrays, gen_def_assigns): Likewise.\n+\t* gimple-fold.c (gimple_fold_builtin_memory_op,\n+\tgimple_fold_builtin_strcat, gimple_fold_call, gimple_build): Likewise.\n+\t* tree-vect-generic.c (expand_vector_divmod,\n+\toptimize_vector_constructor): Likewise.\n+\t* ubsan.c (ubsan_encode_value, ubsan_expand_null_ifn,\n+\tubsan_expand_objsize_ifn, instrument_si_overflow,\n+\tinstrument_bool_enum_load, instrument_nonnull_arg): Likewise.\n+\t* tree-outof-ssa.c (insert_backedge_copies): Likewise.\n+\t* tree-ssa-loop-manip.c (create_iv,\n+\ttree_transform_and_unroll_loop): Likewise.\n+\t* omp-low.c (scan_omp_parallel, lower_rec_simd_input_clauses,\n+\tlower_rec_input_clauses, lower_lastprivate_clauses,\n+\texpand_parallel_call, expand_omp_for_static_chunk,\n+\texpand_omp_atomic_pipeline, expand_omp_target,\n+\tmaybe_add_implicit_barrier_cancel, lower_omp_single_simple,\n+\tlower_omp_critical, lower_omp_for, task_copyfn_copy_decl,\n+\tlower_depend_clauses, lower_omp_target, lower_omp_1,\n+\tipa_simd_modify_stmt_ops, simd_clone_adjust): Likewise.\n+\t* tree-parloops.c (take_address_of, create_phi_for_local_result,\n+\tcreate_call_for_reduction_1, separate_decls_in_region,\n+\tcreate_parallel_loop): Likewise.\n+\t* graphite-sese-to-poly.c (rewrite_cross_bb_scalar_dependence,\n+\thandle_scalar_deps_crossing_scop_limits): Likewise.\n+\t* trans-mem.c (lower_transaction, build_tm_load, build_tm_store,\n+\texpand_assign_tm, expand_call_tm, expand_transaction,\n+\tipa_tm_insert_gettmclone_call): Likewise.\n+\t* tree-vect-data-refs.c (bump_vector_ptr, vect_setup_realignment):\n+\tLikewise.\n+\t* tree-vect-stmts.c (vect_init_vector, vectorizable_mask_load_store,\n+\tvectorizable_call, vectorizable_simd_clone_call,\n+\tvectorizable_conversion, vectorizable_store, permute_vec_elements,\n+\tvectorizable_load): Likewise.\n+\n 2014-11-29  Tobias Burnus  <burnus@net-b.de>\n \t    Manuel L\u00f3pez-Ib\u00e1\u00f1ez  <manu@gcc.gnu.org>\n "}, {"sha": "a976455c6e641607d2db8f90a2f678d41325c1a4", "filename": "gcc/asan.c", "status": "modified", "additions": 15, "deletions": 20, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b731b39027f635f0afa97010e803212c1133ee55/gcc%2Fasan.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b731b39027f635f0afa97010e803212c1133ee55/gcc%2Fasan.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fasan.c?ref=b731b39027f635f0afa97010e803212c1133ee55", "patch": "@@ -1585,29 +1585,25 @@ build_shadow_mem_access (gimple_stmt_iterator *gsi, location_t location,\n   gimple g;\n \n   t = build_int_cst (uintptr_type, ASAN_SHADOW_SHIFT);\n-  g = gimple_build_assign_with_ops (RSHIFT_EXPR,\n-\t\t\t\t    make_ssa_name (uintptr_type, NULL),\n+  g = gimple_build_assign_with_ops (RSHIFT_EXPR, make_ssa_name (uintptr_type),\n \t\t\t\t    base_addr, t);\n   gimple_set_location (g, location);\n   gsi_insert_after (gsi, g, GSI_NEW_STMT);\n \n   t = build_int_cst (uintptr_type, asan_shadow_offset ());\n-  g = gimple_build_assign_with_ops (PLUS_EXPR,\n-\t\t\t\t    make_ssa_name (uintptr_type, NULL),\n+  g = gimple_build_assign_with_ops (PLUS_EXPR, make_ssa_name (uintptr_type),\n \t\t\t\t    gimple_assign_lhs (g), t);\n   gimple_set_location (g, location);\n   gsi_insert_after (gsi, g, GSI_NEW_STMT);\n \n-  g = gimple_build_assign_with_ops (NOP_EXPR,\n-\t\t\t\t    make_ssa_name (shadow_ptr_type, NULL),\n+  g = gimple_build_assign_with_ops (NOP_EXPR, make_ssa_name (shadow_ptr_type),\n \t\t\t\t    gimple_assign_lhs (g));\n   gimple_set_location (g, location);\n   gsi_insert_after (gsi, g, GSI_NEW_STMT);\n \n   t = build2 (MEM_REF, shadow_type, gimple_assign_lhs (g),\n \t      build_int_cst (shadow_ptr_type, 0));\n-  g = gimple_build_assign_with_ops (MEM_REF,\n-\t\t\t\t    make_ssa_name (shadow_type, NULL), t);\n+  g = gimple_build_assign_with_ops (MEM_REF, make_ssa_name (shadow_type), t);\n   gimple_set_location (g, location);\n   gsi_insert_after (gsi, g, GSI_NEW_STMT);\n   return gimple_assign_lhs (g);\n@@ -1624,8 +1620,7 @@ maybe_create_ssa_name (location_t loc, tree base, gimple_stmt_iterator *iter,\n     return base;\n   gimple g\n     = gimple_build_assign_with_ops (TREE_CODE (base),\n-\t\t\t\t    make_ssa_name (TREE_TYPE (base), NULL),\n-\t\t\t\t    base);\n+\t\t\t\t    make_ssa_name (TREE_TYPE (base)), base);\n   gimple_set_location (g, loc);\n   if (before_p)\n     gsi_insert_before (iter, g, GSI_SAME_STMT);\n@@ -1645,8 +1640,8 @@ maybe_cast_to_ptrmode (location_t loc, tree len, gimple_stmt_iterator *iter,\n     return len;\n   gimple g\n     = gimple_build_assign_with_ops (NOP_EXPR,\n-\t\t\t\t    make_ssa_name (pointer_sized_int_node,\n-\t\t\t\t\t\t   NULL), len);\n+\t\t\t\t    make_ssa_name (pointer_sized_int_node),\n+\t\t\t\t    len);\n   gimple_set_location (g, loc);\n   if (before_p)\n     gsi_insert_before (iter, g, GSI_SAME_STMT);\n@@ -2549,8 +2544,8 @@ asan_expand_check_ifn (gimple_stmt_iterator *iter, bool use_calls)\n       /* Instrument using callbacks.  */\n       gimple g\n \t= gimple_build_assign_with_ops (NOP_EXPR,\n-\t\t\t\t\tmake_ssa_name (pointer_sized_int_node,\n-\t\t\t\t\t\t       NULL), base);\n+\t\t\t\t\tmake_ssa_name (pointer_sized_int_node),\n+\t\t\t\t\tbase);\n       gimple_set_location (g, loc);\n       gsi_insert_before (iter, g, GSI_SAME_STMT);\n       tree base_addr = gimple_assign_lhs (g);\n@@ -2563,8 +2558,8 @@ asan_expand_check_ifn (gimple_stmt_iterator *iter, bool use_calls)\n \t{\n \t  gcc_assert (nargs == 2);\n \t  g = gimple_build_assign_with_ops (NOP_EXPR,\n-\t\t\t\t\t    make_ssa_name (pointer_sized_int_node,\n-\t\t\t\t\t\t\t   NULL), len);\n+\t\t\t\t\t    make_ssa_name (pointer_sized_int_node),\n+\t\t\t\t\t    len);\n \t  gimple_set_location (g, loc);\n \t  gsi_insert_before (iter, g, GSI_SAME_STMT);\n \t  tree sz_arg = gimple_assign_lhs (g);\n@@ -2622,8 +2617,8 @@ asan_expand_check_ifn (gimple_stmt_iterator *iter, bool use_calls)\n \t\t\t\t  &else_bb);\n \n   g = gimple_build_assign_with_ops (NOP_EXPR,\n-\t\t\t\t    make_ssa_name (pointer_sized_int_node,\n-\t\t\t\t\t\t   NULL), base);\n+\t\t\t\t    make_ssa_name (pointer_sized_int_node),\n+\t\t\t\t    base);\n   gimple_set_location (g, loc);\n   gsi_insert_before (&gsi, g, GSI_NEW_STMT);\n   tree base_addr = gimple_assign_lhs (g);\n@@ -2676,14 +2671,14 @@ asan_expand_check_ifn (gimple_stmt_iterator *iter, bool use_calls)\n       if (size_in_bytes == -1)\n \t{\n \t  g = gimple_build_assign_with_ops (MINUS_EXPR,\n-\t\t\t\t\t    make_ssa_name (pointer_sized_int_node, NULL),\n+\t\t\t\t\t    make_ssa_name (pointer_sized_int_node),\n \t\t\t\t\t    len,\n \t\t\t\t\t    build_int_cst (pointer_sized_int_node, 1));\n \t  gimple_set_location (g, loc);\n \t  gsi_insert_after (&gsi, g, GSI_NEW_STMT);\n \t  tree last = gimple_assign_lhs (g);\n \t  g = gimple_build_assign_with_ops (PLUS_EXPR,\n-\t\t\t\t\t    make_ssa_name (pointer_sized_int_node, NULL),\n+\t\t\t\t\t    make_ssa_name (pointer_sized_int_node),\n \t\t\t\t\t    base_addr,\n \t\t\t\t\t    last);\n \t  gimple_set_location (g, loc);"}, {"sha": "ca3e0b36bab4da8d45d74bf9d76b3baa044ac025", "filename": "gcc/c-family/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b731b39027f635f0afa97010e803212c1133ee55/gcc%2Fc-family%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b731b39027f635f0afa97010e803212c1133ee55/gcc%2Fc-family%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2FChangeLog?ref=b731b39027f635f0afa97010e803212c1133ee55", "patch": "@@ -1,3 +1,10 @@\n+2014-11-29  Jakub Jelinek  <jakub@redhat.com>\n+\n+\t* c-common.c (convert_vector_to_pointer_for_subscript): Remove NULL\n+\tlast argument from create_tmp_var_raw and create_tmp_var calls.\n+\t* cilk.c (gimplify_cilk_spawn): Likewise.\n+\t* c-omp.c (c_finish_omp_atomic): Likewise.\n+\n 2014-11-28  Marek Polacek  <polacek@redhat.com>\n \n \t* c-ubsan.c (ubsan_instrument_shift): Use op1_utype for MINUS_EXPR"}, {"sha": "65256cfecd9bccc1cea6618a8ab0c673952f1b05", "filename": "gcc/c-family/c-common.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b731b39027f635f0afa97010e803212c1133ee55/gcc%2Fc-family%2Fc-common.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b731b39027f635f0afa97010e803212c1133ee55/gcc%2Fc-family%2Fc-common.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc-common.c?ref=b731b39027f635f0afa97010e803212c1133ee55", "patch": "@@ -12052,7 +12052,7 @@ convert_vector_to_pointer_for_subscript (location_t loc,\n \n       if (ret)\n \t{\n-\t  tree tmp = create_tmp_var_raw (type, NULL);\n+\t  tree tmp = create_tmp_var_raw (type);\n \t  DECL_SOURCE_LOCATION (tmp) = loc;\n \t  *vecp = c_save_expr (*vecp);\n \t  if (TREE_CODE (*vecp) == C_MAYBE_CONST_EXPR)"}, {"sha": "b7318244eec3d9a766ebbc3b97c1fcc040851075", "filename": "gcc/c-family/c-omp.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b731b39027f635f0afa97010e803212c1133ee55/gcc%2Fc-family%2Fc-omp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b731b39027f635f0afa97010e803212c1133ee55/gcc%2Fc-family%2Fc-omp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc-omp.c?ref=b731b39027f635f0afa97010e803212c1133ee55", "patch": "@@ -170,7 +170,7 @@ c_finish_omp_atomic (location_t loc, enum tree_code code,\n     {\n       /* Make sure LHS is simple enough so that goa_lhs_expr_p can recognize\n \t it even after unsharing function body.  */\n-      tree var = create_tmp_var_raw (TREE_TYPE (addr), NULL);\n+      tree var = create_tmp_var_raw (TREE_TYPE (addr));\n       DECL_CONTEXT (var) = current_function_decl;\n       addr = build4 (TARGET_EXPR, TREE_TYPE (addr), var, addr, NULL, NULL);\n     }"}, {"sha": "82dd2cb5581349c96c75f7e207ba7a8391edd34c", "filename": "gcc/c-family/cilk.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b731b39027f635f0afa97010e803212c1133ee55/gcc%2Fc-family%2Fcilk.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b731b39027f635f0afa97010e803212c1133ee55/gcc%2Fc-family%2Fcilk.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fcilk.c?ref=b731b39027f635f0afa97010e803212c1133ee55", "patch": "@@ -792,7 +792,7 @@ gimplify_cilk_spawn (tree *spawn_p)\n   tree frame_ptr = build1 (ADDR_EXPR, f_ptr_type, cfun->cilk_frame_decl);\n   tree save_fp = build_call_expr (cilk_save_fp_fndecl, 1, frame_ptr);\n   append_to_statement_list (save_fp, spawn_p);\t\t  \n-  setjmp_value = create_tmp_var (TREE_TYPE (call1), NULL);\n+  setjmp_value = create_tmp_var (TREE_TYPE (call1));\n   setjmp_expr = fold_build2 (MODIFY_EXPR, void_type_node, setjmp_value, call1);\n \n   append_to_statement_list_force (setjmp_expr, spawn_p);"}, {"sha": "cef3aa186878652f01d3bb00a43f045636eec5c8", "filename": "gcc/c/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b731b39027f635f0afa97010e803212c1133ee55/gcc%2Fc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b731b39027f635f0afa97010e803212c1133ee55/gcc%2Fc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc%2FChangeLog?ref=b731b39027f635f0afa97010e803212c1133ee55", "patch": "@@ -1,3 +1,12 @@\n+2014-11-29  Jakub Jelinek  <jakub@redhat.com>\n+\n+\t* c-typeck.c (convert_lvalue_to_rvalue, build_atomic_assign,\n+\tc_finish_stmt_expr): Remove NULL last argument from\n+\tcreate_tmp_var_raw and create_tmp_var calls.\n+\t* c-array-notation.c (fix_builtin_array_notation_fn,\n+\tbuild_array_notation_expr, fix_conditional_array_notations_1,\n+\tfix_array_notation_expr, fix_array_notation_call_expr): Likewise.\n+\n 2014-11-28  Marek Polacek  <polacek@redhat.com>\n \n \tPR c/63862"}, {"sha": "dd063f347d0d589eb1b88235b5626b24af760129", "filename": "gcc/c/c-array-notation.c", "status": "modified", "additions": 6, "deletions": 8, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b731b39027f635f0afa97010e803212c1133ee55/gcc%2Fc%2Fc-array-notation.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b731b39027f635f0afa97010e803212c1133ee55/gcc%2Fc%2Fc-array-notation.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc%2Fc-array-notation.c?ref=b731b39027f635f0afa97010e803212c1133ee55", "patch": "@@ -295,7 +295,7 @@ fix_builtin_array_notation_fn (tree an_builtin_fn, tree *new_var)\n \n   for (ii = 0; ii < rank; ii++)\n     {\n-      an_loop_info[ii].var = create_tmp_var (integer_type_node, NULL);\n+      an_loop_info[ii].var = create_tmp_var (integer_type_node);\n       an_loop_info[ii].ind_init =\n \tbuild_modify_expr (location, an_loop_info[ii].var,\n \t\t\t   TREE_TYPE (an_loop_info[ii].var), NOP_EXPR,\n@@ -795,8 +795,7 @@ build_array_notation_expr (location_t location, tree lhs, tree lhs_origtype,\n   for (ii = 0; ii < lhs_rank; ii++)\n     if (lhs_an_info[0][ii].is_vector)\n       {\n-\tlhs_an_loop_info[ii].var = create_tmp_var (integer_type_node,\n-\t\t\t\t\t\t   NULL);\n+\tlhs_an_loop_info[ii].var = create_tmp_var (integer_type_node);\n \tlhs_an_loop_info[ii].ind_init = build_modify_expr\n \t  (location, lhs_an_loop_info[ii].var,\n \t   TREE_TYPE (lhs_an_loop_info[ii].var), NOP_EXPR,\n@@ -807,8 +806,7 @@ build_array_notation_expr (location_t location, tree lhs, tree lhs_origtype,\n     {\n       /* When we have a polynomial, we assume that the indices are of type \n \t integer.  */\n-      rhs_an_loop_info[ii].var = create_tmp_var (integer_type_node,\n-\t\t\t\t\t\t NULL);\n+      rhs_an_loop_info[ii].var = create_tmp_var (integer_type_node);\n       rhs_an_loop_info[ii].ind_init = build_modify_expr\n \t(location, rhs_an_loop_info[ii].var,\n \t TREE_TYPE (rhs_an_loop_info[ii].var), NOP_EXPR,\n@@ -984,7 +982,7 @@ fix_conditional_array_notations_1 (tree stmt)\n   cilkplus_extract_an_triplets (array_list, list_size, rank, &an_info);\n   for (ii = 0; ii < rank; ii++)\n     {\n-      an_loop_info[ii].var = create_tmp_var (integer_type_node, NULL);\n+      an_loop_info[ii].var = create_tmp_var (integer_type_node);\n       an_loop_info[ii].ind_init =\n \tbuild_modify_expr (location, an_loop_info[ii].var,\n \t\t\t   TREE_TYPE (an_loop_info[ii].var), NOP_EXPR,\n@@ -1080,7 +1078,7 @@ fix_array_notation_expr (location_t location, enum tree_code code,\n   loop_init = push_stmt_list ();\n   for (ii = 0; ii < rank; ii++)\n     {\n-      an_loop_info[ii].var = create_tmp_var (integer_type_node, NULL);\n+      an_loop_info[ii].var = create_tmp_var (integer_type_node);\n       an_loop_info[ii].ind_init =\n \tbuild_modify_expr (location, an_loop_info[ii].var,\n \t\t\t   TREE_TYPE (an_loop_info[ii].var), NOP_EXPR,\n@@ -1175,7 +1173,7 @@ fix_array_notation_call_expr (tree arg)\n     }\n   for (ii = 0; ii < rank; ii++)\n     {\n-      an_loop_info[ii].var = create_tmp_var (integer_type_node, NULL);\n+      an_loop_info[ii].var = create_tmp_var (integer_type_node);\n       an_loop_info[ii].ind_init =\n \tbuild_modify_expr (location, an_loop_info[ii].var,\n \t\t\t   TREE_TYPE (an_loop_info[ii].var), NOP_EXPR, location,"}, {"sha": "ca9d512adf85bc186afcc3ecb83ade6ffd37ce04", "filename": "gcc/c/c-typeck.c", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b731b39027f635f0afa97010e803212c1133ee55/gcc%2Fc%2Fc-typeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b731b39027f635f0afa97010e803212c1133ee55/gcc%2Fc%2Fc-typeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc%2Fc-typeck.c?ref=b731b39027f635f0afa97010e803212c1133ee55", "patch": "@@ -2012,7 +2012,7 @@ convert_lvalue_to_rvalue (location_t loc, struct c_expr exp,\n       /* Remove the qualifiers for the rest of the expressions and\n \t create the VAL temp variable to hold the RHS.  */\n       nonatomic_type = build_qualified_type (expr_type, TYPE_UNQUALIFIED);\n-      tmp = create_tmp_var (nonatomic_type, NULL);\n+      tmp = create_tmp_var (nonatomic_type);\n       tmp_addr = build_unary_op (loc, ADDR_EXPR, tmp, 0);\n       TREE_ADDRESSABLE (tmp) = 1;\n       TREE_NO_WARNING (tmp) = 1;\n@@ -3632,7 +3632,7 @@ build_atomic_assign (location_t loc, tree lhs, enum tree_code modifycode,\n      the VAL temp variable to hold the RHS.  */\n   nonatomic_lhs_type = build_qualified_type (lhs_type, TYPE_UNQUALIFIED);\n   nonatomic_rhs_type = build_qualified_type (rhs_type, TYPE_UNQUALIFIED);\n-  val = create_tmp_var (nonatomic_rhs_type, NULL);\n+  val = create_tmp_var (nonatomic_rhs_type);\n   TREE_ADDRESSABLE (val) = 1;\n   TREE_NO_WARNING (val) = 1;\n   rhs = build2 (MODIFY_EXPR, nonatomic_rhs_type, val, rhs);\n@@ -3661,12 +3661,12 @@ build_atomic_assign (location_t loc, tree lhs, enum tree_code modifycode,\n     }\n \n   /* Create the variables and labels required for the op= form.  */\n-  old = create_tmp_var (nonatomic_lhs_type, NULL);\n+  old = create_tmp_var (nonatomic_lhs_type);\n   old_addr = build_unary_op (loc, ADDR_EXPR, old, 0);\n   TREE_ADDRESSABLE (old) = 1;\n   TREE_NO_WARNING (old) = 1;\n \n-  newval = create_tmp_var (nonatomic_lhs_type, NULL);\n+  newval = create_tmp_var (nonatomic_lhs_type);\n   newval_addr = build_unary_op (loc, ADDR_EXPR, newval, 0);\n   TREE_ADDRESSABLE (newval) = 1;\n \n@@ -9956,7 +9956,7 @@ c_finish_stmt_expr (location_t loc, tree body)\n   /* Now that we've located the expression containing the value, it seems\n      silly to make voidify_wrapper_expr repeat the process.  Create a\n      temporary of the appropriate type and stick it in a TARGET_EXPR.  */\n-  tmp = create_tmp_var_raw (type, NULL);\n+  tmp = create_tmp_var_raw (type);\n \n   /* Unwrap a no-op NOP_EXPR as added by c_finish_expr_stmt.  This avoids\n      tree_expr_nonnegative_p giving up immediately.  */"}, {"sha": "c99631708dfbc61403a8bdbd3c5b2b9e1039c0bb", "filename": "gcc/cfgexpand.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b731b39027f635f0afa97010e803212c1133ee55/gcc%2Fcfgexpand.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b731b39027f635f0afa97010e803212c1133ee55/gcc%2Fcfgexpand.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgexpand.c?ref=b731b39027f635f0afa97010e803212c1133ee55", "patch": "@@ -690,8 +690,8 @@ update_alias_info_with_stack_vars (void)\n          as base during alias-oracle queries on RTL for bases that\n \t have been partitioned.  */\n       if (var == NULL_TREE)\n-\tvar = create_tmp_var (ptr_type_node, NULL);\n-      name = make_ssa_name (var, NULL);\n+\tvar = create_tmp_var (ptr_type_node);\n+      name = make_ssa_name (var);\n \n       /* Create bitmaps representing partitions.  They will be used for\n          points-to sets later, so use GGC alloc.  */\n@@ -1738,7 +1738,7 @@ expand_used_vars (void)\n \t{\n \t  tree *slot = &ssa_name_decls.get_or_insert (TREE_TYPE (var));\n \t  if (!*slot)\n-\t    *slot = create_tmp_reg (TREE_TYPE (var), NULL);\n+\t    *slot = create_tmp_reg (TREE_TYPE (var));\n \t  replace_ssa_name_symbol (var, *slot);\n \t}\n "}, {"sha": "6ad557c1b947af6bbd638c4074564041f1553002", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b731b39027f635f0afa97010e803212c1133ee55/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b731b39027f635f0afa97010e803212c1133ee55/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=b731b39027f635f0afa97010e803212c1133ee55", "patch": "@@ -1,3 +1,8 @@\n+2014-11-29  Jakub Jelinek  <jakub@redhat.com>\n+\n+\t* cp-gimplify.c (cxx_omp_clause_apply_fn): Remove NULL last argument\n+\tfrom create_tmp_var calls.\n+\n 2014-11-28  Marek Polacek  <polacek@redhat.com>\n \n \tPR c/63862"}, {"sha": "0a3a0d46b49c9e45037143c811afe90732618ac1", "filename": "gcc/cp/cp-gimplify.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b731b39027f635f0afa97010e803212c1133ee55/gcc%2Fcp%2Fcp-gimplify.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b731b39027f635f0afa97010e803212c1133ee55/gcc%2Fcp%2Fcp-gimplify.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-gimplify.c?ref=b731b39027f635f0afa97010e803212c1133ee55", "patch": "@@ -1410,13 +1410,13 @@ cxx_omp_clause_apply_fn (tree fn, tree arg1, tree arg2)\n       end1 = TYPE_SIZE_UNIT (TREE_TYPE (arg1));\n       end1 = fold_build_pointer_plus (start1, end1);\n \n-      p1 = create_tmp_var (TREE_TYPE (start1), NULL);\n+      p1 = create_tmp_var (TREE_TYPE (start1));\n       t = build2 (MODIFY_EXPR, TREE_TYPE (p1), p1, start1);\n       append_to_statement_list (t, &ret);\n \n       if (arg2)\n \t{\n-\t  p2 = create_tmp_var (TREE_TYPE (start2), NULL);\n+\t  p2 = create_tmp_var (TREE_TYPE (start2));\n \t  t = build2 (MODIFY_EXPR, TREE_TYPE (p2), p2, start2);\n \t  append_to_statement_list (t, &ret);\n \t}"}, {"sha": "db8b5cdf5b770c497a25df1edb6545b22d70694d", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b731b39027f635f0afa97010e803212c1133ee55/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b731b39027f635f0afa97010e803212c1133ee55/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=b731b39027f635f0afa97010e803212c1133ee55", "patch": "@@ -1,3 +1,9 @@\n+2014-11-29  Jakub Jelinek  <jakub@redhat.com>\n+\n+\t* trans-openmp.c (gfc_omp_finish_clause,\n+\tgfc_trans_omp_array_reduction_or_udr, gfc_trans_omp_atomic): Remove\n+\tNULL last argument from create_tmp_var_raw and create_tmp_var calls.\n+\n 2014-11-29  Tobias Burnus  <burnus@net-b.de>\n \n \t* scanner.c (skip_free_comments, gfc_gobble_whitespace): Use"}, {"sha": "c7edcadfe7a310af6be2320a74f5e6307042d9dd", "filename": "gcc/fortran/trans-openmp.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b731b39027f635f0afa97010e803212c1133ee55/gcc%2Ffortran%2Ftrans-openmp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b731b39027f635f0afa97010e803212c1133ee55/gcc%2Ffortran%2Ftrans-openmp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-openmp.c?ref=b731b39027f635f0afa97010e803212c1133ee55", "patch": "@@ -1069,7 +1069,7 @@ gfc_omp_finish_clause (tree c, gimple_seq *pre_p)\n       OMP_CLAUSE_MAP_KIND (c3) = OMP_CLAUSE_MAP_POINTER;\n       OMP_CLAUSE_DECL (c3) = gfc_conv_descriptor_data_get (decl);\n       OMP_CLAUSE_SIZE (c3) = size_int (0);\n-      tree size = create_tmp_var (gfc_array_index_type, NULL);\n+      tree size = create_tmp_var (gfc_array_index_type);\n       tree elemsz = TYPE_SIZE_UNIT (gfc_get_element_type (type));\n       elemsz = fold_convert (gfc_array_index_type, elemsz);\n       if (GFC_TYPE_ARRAY_AKIND (type) == GFC_ARRAY_POINTER\n@@ -1361,7 +1361,7 @@ gfc_trans_omp_array_reduction_or_udr (tree c, gfc_omp_namelist *n, locus where)\n   decl = OMP_CLAUSE_DECL (c);\n   gfc_current_locus = where;\n   type = TREE_TYPE (decl);\n-  outer_decl = create_tmp_var_raw (type, NULL);\n+  outer_decl = create_tmp_var_raw (type);\n   if (TREE_CODE (decl) == PARM_DECL\n       && TREE_CODE (type) == REFERENCE_TYPE\n       && GFC_DESCRIPTOR_TYPE_P (TREE_TYPE (type))\n@@ -2689,7 +2689,7 @@ gfc_trans_omp_atomic (gfc_code *code)\n     {\n       /* Make sure LHS is simple enough so that goa_lhs_expr_p can recognize\n \t it even after unsharing function body.  */\n-      tree var = create_tmp_var_raw (TREE_TYPE (lhsaddr), NULL);\n+      tree var = create_tmp_var_raw (TREE_TYPE (lhsaddr));\n       DECL_CONTEXT (var) = current_function_decl;\n       lhsaddr = build4 (TARGET_EXPR, TREE_TYPE (lhsaddr), var, lhsaddr,\n \t\t\tNULL_TREE, NULL_TREE);"}, {"sha": "52176738afb6dbdef588453733d51d4844b0be46", "filename": "gcc/gimple-builder.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b731b39027f635f0afa97010e803212c1133ee55/gcc%2Fgimple-builder.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b731b39027f635f0afa97010e803212c1133ee55/gcc%2Fgimple-builder.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-builder.c?ref=b731b39027f635f0afa97010e803212c1133ee55", "patch": "@@ -65,7 +65,7 @@ build_assign (enum tree_code code, tree op1, int val, tree lhs)\n {\n   tree op2 = build_int_cst (TREE_TYPE (op1), val);\n   if (lhs == NULL_TREE)\n-    lhs = make_ssa_name (get_expr_type (code, op1), NULL);\n+    lhs = make_ssa_name (get_expr_type (code, op1));\n   return gimple_build_assign_with_ops (code, lhs, op1, op2);\n }\n \n@@ -88,7 +88,7 @@ gassign *\n build_assign (enum tree_code code, tree op1, tree op2, tree lhs)\n {\n   if (lhs == NULL_TREE)\n-    lhs = make_ssa_name (get_expr_type (code, op1), NULL);\n+    lhs = make_ssa_name (get_expr_type (code, op1));\n   return gimple_build_assign_with_ops (code, lhs, op1, op2);\n }\n \n@@ -119,7 +119,7 @@ gassign *\n build_type_cast (tree to_type, tree op, tree lhs)\n {\n   if (lhs == NULL_TREE)\n-    lhs = make_ssa_name (to_type, NULL);\n+    lhs = make_ssa_name (to_type);\n   return gimple_build_assign_with_ops (NOP_EXPR, lhs, op);\n }\n "}, {"sha": "fd79095668409a04b0aa831ac7c47efd53963659", "filename": "gcc/gimple-expr.h", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b731b39027f635f0afa97010e803212c1133ee55/gcc%2Fgimple-expr.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b731b39027f635f0afa97010e803212c1133ee55/gcc%2Fgimple-expr.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-expr.h?ref=b731b39027f635f0afa97010e803212c1133ee55", "patch": "@@ -30,9 +30,9 @@ extern const char *gimple_decl_printable_name (tree, int);\n extern tree copy_var_decl (tree, tree, tree);\n extern bool gimple_can_coalesce_p (tree, tree);\n extern tree create_tmp_var_name (const char *);\n-extern tree create_tmp_var_raw (tree, const char *);\n-extern tree create_tmp_var (tree, const char *);\n-extern tree create_tmp_reg (tree, const char *);\n+extern tree create_tmp_var_raw (tree, const char * = NULL);\n+extern tree create_tmp_var (tree, const char * = NULL);\n+extern tree create_tmp_reg (tree, const char * = NULL);\n extern tree create_tmp_reg_fn (struct function *, tree, const char *);\n \n "}, {"sha": "12191762d06ab76d1f9ac2cb8e57e7fdfe9cbe71", "filename": "gcc/gimple-fold.c", "status": "modified", "additions": 18, "deletions": 19, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b731b39027f635f0afa97010e803212c1133ee55/gcc%2Fgimple-fold.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b731b39027f635f0afa97010e803212c1133ee55/gcc%2Fgimple-fold.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-fold.c?ref=b731b39027f635f0afa97010e803212c1133ee55", "patch": "@@ -860,8 +860,7 @@ gimple_fold_builtin_memory_op (gimple_stmt_iterator *gsi,\n \t\t\t    srcmem = make_ssa_name (TREE_TYPE (srcmem),\n \t\t\t\t\t\t    new_stmt);\n \t\t\t  else\n-\t\t\t    srcmem = create_tmp_reg (TREE_TYPE (srcmem),\n-\t\t\t\t\t\t     NULL);\n+\t\t\t    srcmem = create_tmp_reg (TREE_TYPE (srcmem));\n \t\t\t  gimple_assign_set_lhs (new_stmt, srcmem);\n \t\t\t  gimple_set_vuse (new_stmt, gimple_vuse (stmt));\n \t\t\t  gsi_insert_before (gsi, new_stmt, GSI_SAME_STMT);\n@@ -1146,7 +1145,7 @@ gimple_fold_builtin_memory_op (gimple_stmt_iterator *gsi,\n \t  if (gimple_in_ssa_p (cfun))\n \t    srcvar = make_ssa_name (TREE_TYPE (srcvar), new_stmt);\n \t  else\n-\t    srcvar = create_tmp_reg (TREE_TYPE (srcvar), NULL);\n+\t    srcvar = create_tmp_reg (TREE_TYPE (srcvar));\n \t  gimple_assign_set_lhs (new_stmt, srcvar);\n \t  gimple_set_vuse (new_stmt, gimple_vuse (stmt));\n \t  gsi_insert_before (gsi, new_stmt, GSI_SAME_STMT);\n@@ -1554,9 +1553,9 @@ gimple_fold_builtin_strcat (gimple_stmt_iterator *gsi, tree dst, tree src)\n   gimple repl = gimple_build_call (strlen_fn, 1, dst);\n   gimple_set_location (repl, loc);\n   if (gimple_in_ssa_p (cfun))\n-    newdst = make_ssa_name (size_type_node, NULL);\n+    newdst = make_ssa_name (size_type_node);\n   else\n-    newdst = create_tmp_reg (size_type_node, NULL);\n+    newdst = create_tmp_reg (size_type_node);\n   gimple_call_set_lhs (repl, newdst);\n   gimple_seq_add_stmt_without_update (&stmts, repl);\n \n@@ -2685,7 +2684,7 @@ gimple_fold_call (gimple_stmt_iterator *gsi, bool inplace)\n \t\t    {\n \t\t      if (TREE_CODE (lhs) == SSA_NAME)\n \t\t\t{\n-\t\t\t  tree var = create_tmp_var (TREE_TYPE (lhs), NULL);\n+\t\t\t  tree var = create_tmp_var (TREE_TYPE (lhs));\n \t\t\t  tree def = get_or_create_ssa_default_def (cfun, var);\n \t\t\t  gimple new_stmt = gimple_build_assign (lhs, def);\n \t\t\t  gsi_insert_before (gsi, new_stmt, GSI_SAME_STMT);\n@@ -2700,7 +2699,7 @@ gimple_fold_call (gimple_stmt_iterator *gsi, bool inplace)\n \t\t  gimple_set_location (new_stmt, gimple_location (stmt));\n \t\t  if (lhs && TREE_CODE (lhs) == SSA_NAME)\n \t\t    {\n-\t\t      tree var = create_tmp_var (TREE_TYPE (lhs), NULL);\n+\t\t      tree var = create_tmp_var (TREE_TYPE (lhs));\n \t\t      tree def = get_or_create_ssa_default_def (cfun, var);\n \n \t\t      /* To satisfy condition for\n@@ -5666,9 +5665,9 @@ gimple_build (gimple_seq *seq, location_t loc,\n   if (!res)\n     {\n       if (gimple_in_ssa_p (cfun))\n-\tres = make_ssa_name (type, NULL);\n+\tres = make_ssa_name (type);\n       else\n-\tres = create_tmp_reg (type, NULL);\n+\tres = create_tmp_reg (type);\n       gimple stmt;\n       if (code == REALPART_EXPR\n \t  || code == IMAGPART_EXPR\n@@ -5698,9 +5697,9 @@ gimple_build (gimple_seq *seq, location_t loc,\n   if (!res)\n     {\n       if (gimple_in_ssa_p (cfun))\n-\tres = make_ssa_name (type, NULL);\n+\tres = make_ssa_name (type);\n       else\n-\tres = create_tmp_reg (type, NULL);\n+\tres = create_tmp_reg (type);\n       gimple stmt = gimple_build_assign_with_ops (code, res, op0, op1);\n       gimple_set_location (stmt, loc);\n       gimple_seq_add_stmt_without_update (seq, stmt);\n@@ -5724,9 +5723,9 @@ gimple_build (gimple_seq *seq, location_t loc,\n   if (!res)\n     {\n       if (gimple_in_ssa_p (cfun))\n-\tres = make_ssa_name (type, NULL);\n+\tres = make_ssa_name (type);\n       else\n-\tres = create_tmp_reg (type, NULL);\n+\tres = create_tmp_reg (type);\n       gimple stmt;\n       if (code == BIT_FIELD_REF)\n \tstmt = gimple_build_assign_with_ops (code, res,\n@@ -5760,9 +5759,9 @@ gimple_build (gimple_seq *seq, location_t loc,\n       if (!VOID_TYPE_P (type))\n \t{\n \t  if (gimple_in_ssa_p (cfun))\n-\t    res = make_ssa_name (type, NULL);\n+\t    res = make_ssa_name (type);\n \t  else\n-\t    res = create_tmp_reg (type, NULL);\n+\t    res = create_tmp_reg (type);\n \t  gimple_call_set_lhs (stmt, res);\n \t}\n       gimple_set_location (stmt, loc);\n@@ -5791,9 +5790,9 @@ gimple_build (gimple_seq *seq, location_t loc,\n       if (!VOID_TYPE_P (type))\n \t{\n \t  if (gimple_in_ssa_p (cfun))\n-\t    res = make_ssa_name (type, NULL);\n+\t    res = make_ssa_name (type);\n \t  else\n-\t    res = create_tmp_reg (type, NULL);\n+\t    res = create_tmp_reg (type);\n \t  gimple_call_set_lhs (stmt, res);\n \t}\n       gimple_set_location (stmt, loc);\n@@ -5823,9 +5822,9 @@ gimple_build (gimple_seq *seq, location_t loc,\n       if (!VOID_TYPE_P (type))\n \t{\n \t  if (gimple_in_ssa_p (cfun))\n-\t    res = make_ssa_name (type, NULL);\n+\t    res = make_ssa_name (type);\n \t  else\n-\t    res = create_tmp_reg (type, NULL);\n+\t    res = create_tmp_reg (type);\n \t  gimple_call_set_lhs (stmt, res);\n \t}\n       gimple_set_location (stmt, loc);"}, {"sha": "72121bad5183a0ae9a88f7139ea1c2baa58d5cd5", "filename": "gcc/gimple-low.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b731b39027f635f0afa97010e803212c1133ee55/gcc%2Fgimple-low.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b731b39027f635f0afa97010e803212c1133ee55/gcc%2Fgimple-low.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-low.c?ref=b731b39027f635f0afa97010e803212c1133ee55", "patch": "@@ -828,10 +828,10 @@ lower_builtin_posix_memalign (gimple_stmt_iterator *gsi)\n   tree pptr = gimple_call_arg (call, 0);\n   tree align = gimple_call_arg (call, 1);\n   tree res = gimple_call_lhs (call);\n-  tree ptr = create_tmp_reg (ptr_type_node, NULL);\n+  tree ptr = create_tmp_reg (ptr_type_node);\n   if (TREE_CODE (pptr) == ADDR_EXPR)\n     {\n-      tree tem = create_tmp_var (ptr_type_node, NULL);\n+      tree tem = create_tmp_var (ptr_type_node);\n       TREE_ADDRESSABLE (tem) = 1;\n       gimple_call_set_arg (call, 0, build_fold_addr_expr (tem));\n       stmt = gimple_build_assign (ptr, tem);\n@@ -842,7 +842,7 @@ lower_builtin_posix_memalign (gimple_stmt_iterator *gsi)\n \t\t\t\t\t     build_int_cst (ptr_type_node, 0)));\n   if (res == NULL_TREE)\n     {\n-      res = create_tmp_reg (integer_type_node, NULL);\n+      res = create_tmp_reg (integer_type_node);\n       gimple_call_set_lhs (call, res);\n     }\n   tree align_label = create_artificial_label (UNKNOWN_LOCATION);"}, {"sha": "2e31f104f3888db5d4944a78a553cabf7dbdf09f", "filename": "gcc/gimple-match-head.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b731b39027f635f0afa97010e803212c1133ee55/gcc%2Fgimple-match-head.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b731b39027f635f0afa97010e803212c1133ee55/gcc%2Fgimple-match-head.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-match-head.c?ref=b731b39027f635f0afa97010e803212c1133ee55", "patch": "@@ -330,7 +330,7 @@ maybe_push_res_to_seq (code_helper rcode, tree type, tree *ops,\n \t      && SSA_NAME_OCCURS_IN_ABNORMAL_PHI (ops[2])))\n \treturn NULL_TREE;\n       if (!res)\n-\tres = make_ssa_name (type, NULL);\n+\tres = make_ssa_name (type);\n       maybe_build_generic_op (rcode, type, &ops[0], ops[1], ops[2]);\n       gimple new_stmt = gimple_build_assign_with_ops (rcode, res,\n \t\t\t\t\t\t      ops[0], ops[1], ops[2]);\n@@ -358,7 +358,7 @@ maybe_push_res_to_seq (code_helper rcode, tree type, tree *ops,\n \t      && SSA_NAME_OCCURS_IN_ABNORMAL_PHI (ops[2])))\n \treturn NULL_TREE;\n       if (!res)\n-\tres = make_ssa_name (type, NULL);\n+\tres = make_ssa_name (type);\n       gimple new_stmt = gimple_build_call (decl, nargs, ops[0], ops[1], ops[2]);\n       gimple_call_set_lhs (new_stmt, res);\n       gimple_seq_add_stmt_without_update (seq, new_stmt);"}, {"sha": "5454e0cab2c4aa798d7c3bc0268ef93172143fe8", "filename": "gcc/gimplify-me.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b731b39027f635f0afa97010e803212c1133ee55/gcc%2Fgimplify-me.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b731b39027f635f0afa97010e803212c1133ee55/gcc%2Fgimplify-me.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimplify-me.c?ref=b731b39027f635f0afa97010e803212c1133ee55", "patch": "@@ -78,7 +78,7 @@ force_gimple_operand_1 (tree expr, gimple_seq *stmts,\n   if (var)\n     {\n       if (gimple_in_ssa_p (cfun) && is_gimple_reg (var))\n-\tvar = make_ssa_name (var, NULL);\n+\tvar = make_ssa_name (var);\n       expr = build2 (MODIFY_EXPR, TREE_TYPE (var), var, expr);\n     }\n \n@@ -313,9 +313,9 @@ gimple_regimplify_operands (gimple stmt, gimple_stmt_iterator *gsi_p)\n \t    }\n \t  if (need_temp)\n \t    {\n-\t      tree temp = create_tmp_reg (TREE_TYPE (lhs), NULL);\n+\t      tree temp = create_tmp_reg (TREE_TYPE (lhs));\n \t      if (gimple_in_ssa_p (cfun))\n-\t\ttemp = make_ssa_name (temp, NULL);\n+\t\ttemp = make_ssa_name (temp);\n \t      gimple_set_lhs (stmt, temp);\n \t      post_stmt = gimple_build_assign (lhs, temp);\n \t    }"}, {"sha": "4db2c7e553e4d4182f4dbb574966e0a8dd7b180f", "filename": "gcc/gimplify.c", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b731b39027f635f0afa97010e803212c1133ee55/gcc%2Fgimplify.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b731b39027f635f0afa97010e803212c1133ee55/gcc%2Fgimplify.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimplify.c?ref=b731b39027f635f0afa97010e803212c1133ee55", "patch": "@@ -530,7 +530,7 @@ internal_get_tmp_var (tree val, gimple_seq *pre_p, gimple_seq *post_p,\n \n   if (gimplify_ctxp->into_ssa\n       && is_gimple_reg_type (TREE_TYPE (val)))\n-    t = make_ssa_name (TYPE_MAIN_VARIANT (TREE_TYPE (val)), NULL);\n+    t = make_ssa_name (TYPE_MAIN_VARIANT (TREE_TYPE (val)));\n   else\n     t = lookup_tmp_var (val, is_formal);\n \n@@ -1271,7 +1271,7 @@ gimplify_return_expr (tree stmt, gimple_seq *pre_p)\n     result = gimplify_ctxp->return_temp;\n   else\n     {\n-      result = create_tmp_reg (TREE_TYPE (result_decl), NULL);\n+      result = create_tmp_reg (TREE_TYPE (result_decl));\n \n       /* ??? With complex control flow (usually involving abnormal edges),\n \t we can wind up warning about an uninitialized value for this.  Due\n@@ -3263,7 +3263,7 @@ gimplify_modify_expr_to_memcpy (tree *expr_p, tree size, bool want_value,\n   if (want_value)\n     {\n       /* tmp = memcpy() */\n-      t = create_tmp_var (TREE_TYPE (to_ptr), NULL);\n+      t = create_tmp_var (TREE_TYPE (to_ptr));\n       gimple_call_set_lhs (gs, t);\n       gimplify_seq_add_stmt (seq_p, gs);\n \n@@ -3310,7 +3310,7 @@ gimplify_modify_expr_to_memset (tree *expr_p, tree size, bool want_value,\n   if (want_value)\n     {\n       /* tmp = memset() */\n-      t = create_tmp_var (TREE_TYPE (to_ptr), NULL);\n+      t = create_tmp_var (TREE_TYPE (to_ptr));\n       gimple_call_set_lhs (gs, t);\n       gimplify_seq_add_stmt (seq_p, gs);\n \n@@ -3486,7 +3486,7 @@ gimplify_init_ctor_eval_range (tree object, tree lower, tree upper,\n \n   /* Create and initialize the index variable.  */\n   var_type = TREE_TYPE (upper);\n-  var = create_tmp_var (var_type, NULL);\n+  var = create_tmp_var (var_type);\n   gimplify_seq_add_stmt (pre_p, gimple_build_assign (var, lower));\n \n   /* Add the loop entry label.  */\n@@ -3945,7 +3945,7 @@ gimplify_init_constructor (tree *expr_p, gimple_seq *pre_p, gimple_seq *post_p,\n \t    && num_nonzero_elements > 0\n \t    && vec_safe_length (elts) > 1)\n \t  {\n-\t    tree temp = create_tmp_var (TYPE_MAIN_VARIANT (type), NULL);\n+\t    tree temp = create_tmp_var (TYPE_MAIN_VARIANT (type));\n \t    TREE_OPERAND (*expr_p, 0) = temp;\n \t    *expr_p = build2 (COMPOUND_EXPR, TREE_TYPE (*expr_p),\n \t\t\t      *expr_p,\n@@ -7374,7 +7374,7 @@ gimplify_omp_atomic (tree *expr_p, gimple_seq *pre_p)\n   gomp_atomic_load *loadstmt;\n   gomp_atomic_store *storestmt;\n \n-  tmp_load = create_tmp_reg (type, NULL);\n+  tmp_load = create_tmp_reg (type);\n   if (rhs && goa_stabilize_expr (&rhs, pre_p, addr, tmp_load) < 0)\n     return GS_ERROR;\n \n@@ -7791,7 +7791,7 @@ gimplify_expr (tree *expr_p, gimple_seq *pre_p, gimple_seq *post_p,\n \t\tret = GS_OK;\n \t\tbreak;\n \t      }\n-\t    tree tmp = create_tmp_var (type, NULL);\n+\t    tree tmp = create_tmp_var (type);\n \t    gimplify_arg (&cond, pre_p, EXPR_LOCATION (*expr_p));\n \t    gcall *call\n \t      = gimple_build_call_internal (IFN_ANNOTATE, 2, cond, kind);"}, {"sha": "2e140ecb6ef7e14435177c35a23d57e98314b3df", "filename": "gcc/graphite-sese-to-poly.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b731b39027f635f0afa97010e803212c1133ee55/gcc%2Fgraphite-sese-to-poly.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b731b39027f635f0afa97010e803212c1133ee55/gcc%2Fgraphite-sese-to-poly.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgraphite-sese-to-poly.c?ref=b731b39027f635f0afa97010e803212c1133ee55", "patch": "@@ -2347,7 +2347,7 @@ rewrite_cross_bb_scalar_dependence (scop_p scop, tree zero_dim_array,\n \n   gcc_assert (gimple_code (use_stmt) != GIMPLE_PHI);\n \n-  name = copy_ssa_name (def, NULL);\n+  name = copy_ssa_name (def);\n   name_stmt = gimple_build_assign (name, zero_dim_array);\n \n   gimple_assign_set_lhs (name_stmt, name);\n@@ -2367,7 +2367,7 @@ rewrite_cross_bb_scalar_dependence (scop_p scop, tree zero_dim_array,\n static void\n handle_scalar_deps_crossing_scop_limits (scop_p scop, tree def, gimple stmt)\n {\n-  tree var = create_tmp_reg (TREE_TYPE (def), NULL);\n+  tree var = create_tmp_reg (TREE_TYPE (def));\n   tree new_name = make_ssa_name (var, stmt);\n   bool needs_copy = false;\n   use_operand_p use_p;"}, {"sha": "2d5ecac92e2f22ffe98fc64de7893af628ff9cd0", "filename": "gcc/ipa-prop.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b731b39027f635f0afa97010e803212c1133ee55/gcc%2Fipa-prop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b731b39027f635f0afa97010e803212c1133ee55/gcc%2Fipa-prop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-prop.c?ref=b731b39027f635f0afa97010e803212c1133ee55", "patch": "@@ -4004,7 +4004,7 @@ ipa_modify_call_arguments (struct cgraph_edge *cs, gcall *stmt,\n \t\t      expr = make_ssa_name (TREE_TYPE (expr), tem);\n \t\t    }\n \t\t  else\n-\t\t    expr = create_tmp_reg (TREE_TYPE (expr), NULL);\n+\t\t    expr = create_tmp_reg (TREE_TYPE (expr));\n \t\t  gimple_assign_set_lhs (tem, expr);\n \t\t  gsi_insert_before (&gsi, tem, GSI_SAME_STMT);\n \t\t}"}, {"sha": "98afe4c4b02fa4ac0d26ab47d103d1d52ee00621", "filename": "gcc/ipa-split.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b731b39027f635f0afa97010e803212c1133ee55/gcc%2Fipa-split.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b731b39027f635f0afa97010e803212c1133ee55/gcc%2Fipa-split.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-split.c?ref=b731b39027f635f0afa97010e803212c1133ee55", "patch": "@@ -1584,7 +1584,7 @@ split_function (struct split_point *split_point)\n \t\t  if (!useless_type_conversion_p (TREE_TYPE (retval), restype))\n \t\t    {\n \t\t      gimple cpy;\n-\t\t      tree tem = create_tmp_reg (restype, NULL);\n+\t\t      tree tem = create_tmp_reg (restype);\n \t\t      tem = make_ssa_name (tem, call);\n \t\t      cpy = gimple_build_assign_with_ops (NOP_EXPR, retval,\n \t\t\t\t\t\t\t  tem);\n@@ -1614,14 +1614,14 @@ split_function (struct split_point *split_point)\n \n \t      if (chkp_function_instrumented_p (current_function_decl)\n \t\t  && BOUNDED_P (retval))\n-\t\tretbnd = create_tmp_reg (pointer_bounds_type_node, NULL);\n+\t\tretbnd = create_tmp_reg (pointer_bounds_type_node);\n \n \t      /* We use temporary register to hold value when aggregate_value_p\n \t\t is false.  Similarly for DECL_BY_REFERENCE we must avoid extra\n \t\t copy.  */\n \t      if (!aggregate_value_p (retval, TREE_TYPE (current_function_decl))\n \t\t  && !DECL_BY_REFERENCE (retval))\n-\t\tretval = create_tmp_reg (TREE_TYPE (retval), NULL);\n+\t\tretval = create_tmp_reg (TREE_TYPE (retval));\n \t      if (is_gimple_reg (retval))\n \t\t{\n \t\t  /* When returning by reference, there is only one SSA name"}, {"sha": "41400c706a0de715efe39d4b36fbbd9b7f01429d", "filename": "gcc/omp-low.c", "status": "modified", "additions": 39, "deletions": 40, "changes": 79, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b731b39027f635f0afa97010e803212c1133ee55/gcc%2Fomp-low.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b731b39027f635f0afa97010e803212c1133ee55/gcc%2Fomp-low.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fomp-low.c?ref=b731b39027f635f0afa97010e803212c1133ee55", "patch": "@@ -2110,7 +2110,7 @@ scan_omp_parallel (gimple_stmt_iterator *gsi, omp_context *outer_ctx)\n \t    count += fd.collapse - 1;\n \t  for (i = 0; i < count; i++)\n \t    {\n-\t      tree temp = create_tmp_var (type, NULL);\n+\t      tree temp = create_tmp_var (type);\n \t      tree c = build_omp_clause (UNKNOWN_LOCATION,\n \t\t\t\t\t OMP_CLAUSE__LOOPTEMP_);\n \t      insert_decl_map (&outer_ctx->cb, temp, temp);\n@@ -3165,15 +3165,15 @@ lower_rec_simd_input_clauses (tree new_var, omp_context *ctx, int &max_vf,\n \t}\n       if (max_vf > 1)\n \t{\n-\t  idx = create_tmp_var (unsigned_type_node, NULL);\n-\t  lane = create_tmp_var (unsigned_type_node, NULL);\n+\t  idx = create_tmp_var (unsigned_type_node);\n+\t  lane = create_tmp_var (unsigned_type_node);\n \t}\n     }\n   if (max_vf == 1)\n     return false;\n \n   tree atype = build_array_type_nelts (TREE_TYPE (new_var), max_vf);\n-  tree avar = create_tmp_var_raw (atype, NULL);\n+  tree avar = create_tmp_var_raw (atype);\n   if (TREE_ADDRESSABLE (new_var))\n     TREE_ADDRESSABLE (avar) = 1;\n   DECL_ATTRIBUTES (avar)\n@@ -3343,7 +3343,7 @@ lower_rec_input_clauses (tree clauses, gimple_seq *ilist, gimple_seq *dlist,\n \t\t  t = build_call_expr_loc (clause_loc, t2, 2, t,\n \t\t\t\t\t   omp_clause_aligned_alignment (c));\n \t\t  t = fold_convert_loc (clause_loc, ptype, t);\n-\t\t  x = create_tmp_var (ptype, NULL);\n+\t\t  x = create_tmp_var (ptype);\n \t\t  t = build2 (MODIFY_EXPR, ptype, x, t);\n \t\t  gimplify_and_add (t, ilist);\n \t\t  t = build_simple_mem_ref_loc (clause_loc, x);\n@@ -3386,7 +3386,7 @@ lower_rec_input_clauses (tree clauses, gimple_seq *ilist, gimple_seq *dlist,\n \t\t  /* void *tmp = __builtin_alloca */\n \t\t  atmp = builtin_decl_explicit (BUILT_IN_ALLOCA);\n \t\t  stmt = gimple_build_call (atmp, 1, x);\n-\t\t  tmp = create_tmp_var_raw (ptr_type_node, NULL);\n+\t\t  tmp = create_tmp_var_raw (ptr_type_node);\n \t\t  gimple_add_tmp_var (tmp);\n \t\t  gimple_call_set_lhs (stmt, tmp);\n \n@@ -3622,7 +3622,7 @@ lower_rec_input_clauses (tree clauses, gimple_seq *ilist, gimple_seq *dlist,\n \t\t    {\n \t\t      if (OMP_CLAUSE_CODE (c) == OMP_CLAUSE_LINEAR)\n \t\t\t{\n-\t\t\t  tree iv = create_tmp_var (TREE_TYPE (new_var), NULL);\n+\t\t\t  tree iv = create_tmp_var (TREE_TYPE (new_var));\n \t\t\t  x = lang_hooks.decls.omp_clause_copy_ctor (c, iv, x);\n \t\t\t  gimplify_and_add (x, ilist);\n \t\t\t  gimple_stmt_iterator gsi\n@@ -3851,7 +3851,7 @@ lower_rec_input_clauses (tree clauses, gimple_seq *ilist, gimple_seq *dlist,\n       for (int i = 0; i < 2; i++)\n \tif (llist[i])\n \t  {\n-\t    tree vf = create_tmp_var (unsigned_type_node, NULL);\n+\t    tree vf = create_tmp_var (unsigned_type_node);\n \t    g = gimple_build_call_internal (IFN_GOMP_SIMD_VF, 1, uid);\n \t    gimple_call_set_lhs (g, vf);\n \t    gimple_seq *seq = i == 0 ? ilist : dlist;\n@@ -4009,7 +4009,7 @@ lower_lastprivate_clauses (tree clauses, tree predicate, gimple_seq *stmt_list,\n \t\t{\n \t\t  if (lastlane == NULL)\n \t\t    {\n-\t\t      lastlane = create_tmp_var (unsigned_type_node, NULL);\n+\t\t      lastlane = create_tmp_var (unsigned_type_node);\n \t\t      gcall *g\n \t\t\t= gimple_build_call_internal (IFN_GOMP_SIMD_LAST_LANE,\n \t\t\t\t\t\t      2, simduid,\n@@ -4464,12 +4464,12 @@ expand_parallel_call (struct omp_region *region, basic_block bb,\n \t  edge e, e_then, e_else;\n \t  tree tmp_then, tmp_else, tmp_join, tmp_var;\n \n-\t  tmp_var = create_tmp_var (TREE_TYPE (val), NULL);\n+\t  tmp_var = create_tmp_var (TREE_TYPE (val));\n \t  if (gimple_in_ssa_p (cfun))\n \t    {\n-\t      tmp_then = make_ssa_name (tmp_var, NULL);\n-\t      tmp_else = make_ssa_name (tmp_var, NULL);\n-\t      tmp_join = make_ssa_name (tmp_var, NULL);\n+\t      tmp_then = make_ssa_name (tmp_var);\n+\t      tmp_else = make_ssa_name (tmp_var);\n+\t      tmp_join = make_ssa_name (tmp_var);\n \t    }\n \t  else\n \t    {\n@@ -6572,9 +6572,9 @@ expand_omp_for_static_chunk (struct omp_region *region,\n   trip_var = create_tmp_reg (itype, \".trip\");\n   if (gimple_in_ssa_p (cfun))\n     {\n-      trip_init = make_ssa_name (trip_var, NULL);\n-      trip_main = make_ssa_name (trip_var, NULL);\n-      trip_back = make_ssa_name (trip_var, NULL);\n+      trip_init = make_ssa_name (trip_var);\n+      trip_main = make_ssa_name (trip_var);\n+      trip_back = make_ssa_name (trip_var);\n     }\n   else\n     {\n@@ -8009,16 +8009,16 @@ expand_omp_atomic_pipeline (basic_block load_bb, basic_block store_bb,\n       tree iaddr_val;\n \n       iaddr = create_tmp_reg (build_pointer_type_for_mode (itype, ptr_mode,\n-\t\t\t\t\t\t\t   true), NULL);\n+\t\t\t\t\t\t\t   true));\n       iaddr_val\n \t= force_gimple_operand_gsi (&si,\n \t\t\t\t    fold_convert (TREE_TYPE (iaddr), addr),\n \t\t\t\t    false, NULL_TREE, true, GSI_SAME_STMT);\n       stmt = gimple_build_assign (iaddr, iaddr_val);\n       gsi_insert_before (&si, stmt, GSI_SAME_STMT);\n-      loadedi = create_tmp_var (itype, NULL);\n+      loadedi = create_tmp_var (itype);\n       if (gimple_in_ssa_p (cfun))\n-\tloadedi = make_ssa_name (loadedi, NULL);\n+\tloadedi = make_ssa_name (loadedi);\n     }\n   else\n     {\n@@ -8102,7 +8102,7 @@ expand_omp_atomic_pipeline (basic_block load_bb, basic_block store_bb,\n     old_vali = loadedi;\n   else\n     {\n-      old_vali = create_tmp_var (TREE_TYPE (loadedi), NULL);\n+      old_vali = create_tmp_var (TREE_TYPE (loadedi));\n       stmt = gimple_build_assign (old_vali, loadedi);\n       gsi_insert_before (&si, stmt, GSI_SAME_STMT);\n \n@@ -8508,7 +8508,7 @@ expand_omp_target (struct omp_region *region)\n       edge e;\n       tree tmp_var;\n \n-      tmp_var = create_tmp_var (TREE_TYPE (device), NULL);\n+      tmp_var = create_tmp_var (TREE_TYPE (device));\n       if (kind != GF_OMP_TARGET_KIND_REGION)\n \t{\n \t  gsi = gsi_last_bb (new_bb);\n@@ -8930,7 +8930,7 @@ maybe_add_implicit_barrier_cancel (omp_context *ctx, gimple_seq *body)\n     {\n       tree fndecl = builtin_decl_explicit (BUILT_IN_GOMP_CANCEL);\n       tree c_bool_type = TREE_TYPE (TREE_TYPE (fndecl));\n-      tree lhs = create_tmp_var (c_bool_type, NULL);\n+      tree lhs = create_tmp_var (c_bool_type);\n       gimple_omp_return_set_lhs (omp_return, lhs);\n       tree fallthru_label = create_artificial_label (UNKNOWN_LOCATION);\n       gimple g = gimple_build_cond (NE_EXPR, lhs,\n@@ -9059,7 +9059,7 @@ lower_omp_single_simple (gomp_single *single_stmt, gimple_seq *pre_p)\n   tree lhs, decl;\n \n   decl = builtin_decl_explicit (BUILT_IN_GOMP_SINGLE_START);\n-  lhs = create_tmp_var (TREE_TYPE (TREE_TYPE (decl)), NULL);\n+  lhs = create_tmp_var (TREE_TYPE (TREE_TYPE (decl)));\n   call = gimple_build_call (decl, 0);\n   gimple_call_set_lhs (call, lhs);\n   gimple_seq_add_stmt (pre_p, call);\n@@ -9355,7 +9355,7 @@ lower_omp_critical (gimple_stmt_iterator *gsi_p, omp_context *ctx)\n \t{\n \t  char *new_str;\n \n-\t  decl = create_tmp_var_raw (ptr_type_node, NULL);\n+\t  decl = create_tmp_var_raw (ptr_type_node);\n \n \t  new_str = ACONCAT ((\".gomp_critical_user_\",\n \t\t\t      IDENTIFIER_POINTER (name), NULL));\n@@ -9555,7 +9555,7 @@ lower_omp_for (gimple_stmt_iterator *gsi_p, omp_context *ctx)\n \t    }\n \t  else\n \t    {\n-\t      temp = create_tmp_var (type, NULL);\n+\t      temp = create_tmp_var (type);\n \t      insert_decl_map (&ctx->outer->cb, temp, temp);\n \t    }\n \t  *pc = build_omp_clause (UNKNOWN_LOCATION, OMP_CLAUSE__LOOPTEMP_);\n@@ -9675,7 +9675,7 @@ task_copyfn_copy_decl (tree var, copy_body_data *cb)\n   struct omp_taskcopy_context *tcctx = (struct omp_taskcopy_context *) cb;\n \n   if (splay_tree_lookup (tcctx->ctx->sfield_map, (splay_tree_key) var))\n-    return create_tmp_var (TREE_TYPE (var), NULL);\n+    return create_tmp_var (TREE_TYPE (var));\n \n   return var;\n }\n@@ -9964,7 +9964,7 @@ lower_depend_clauses (gimple stmt, gimple_seq *iseq, gimple_seq *oseq)\n \t  gcc_unreachable ();\n \t}\n   tree type = build_array_type_nelts (ptr_type_node, n_in + n_out + 2);\n-  tree array = create_tmp_var (type, NULL);\n+  tree array = create_tmp_var (type);\n   tree r = build4 (ARRAY_REF, ptr_type_node, array, size_int (0), NULL_TREE,\n \t\t   NULL_TREE);\n   g = gimple_build_assign (r, build_int_cst (ptr_type_node, n_in + n_out));\n@@ -10306,7 +10306,7 @@ lower_omp_target (gimple_stmt_iterator *gsi_p, omp_context *ctx)\n \t\t  {\n \t\t    gcc_assert (kind == GF_OMP_TARGET_KIND_REGION);\n \t\t    tree avar\n-\t\t      = create_tmp_var (TREE_TYPE (TREE_TYPE (x)), NULL);\n+\t\t      = create_tmp_var (TREE_TYPE (TREE_TYPE (x)));\n \t\t    mark_addressable (avar);\n \t\t    gimplify_assign (avar, build_fold_addr_expr (var), &ilist);\n \t\t    talign = DECL_ALIGN_UNIT (avar);\n@@ -10316,7 +10316,7 @@ lower_omp_target (gimple_stmt_iterator *gsi_p, omp_context *ctx)\n \t\telse if (is_gimple_reg (var))\n \t\t  {\n \t\t    gcc_assert (kind == GF_OMP_TARGET_KIND_REGION);\n-\t\t    tree avar = create_tmp_var (TREE_TYPE (var), NULL);\n+\t\t    tree avar = create_tmp_var (TREE_TYPE (var));\n \t\t    mark_addressable (avar);\n \t\t    if (OMP_CLAUSE_MAP_KIND (c) != OMP_CLAUSE_MAP_ALLOC\n \t\t\t&& OMP_CLAUSE_MAP_KIND (c) != OMP_CLAUSE_MAP_FROM)\n@@ -10685,7 +10685,7 @@ lower_omp_1 (gimple_stmt_iterator *gsi_p, omp_context *ctx)\n \t\tgimple_call_set_fntype (call_stmt, TREE_TYPE (fndecl));\n \t      }\n \t    tree lhs;\n-\t    lhs = create_tmp_var (TREE_TYPE (TREE_TYPE (fndecl)), NULL);\n+\t    lhs = create_tmp_var (TREE_TYPE (TREE_TYPE (fndecl)));\n \t    gimple_call_set_lhs (call_stmt, lhs);\n \t    tree fallthru_label;\n \t    fallthru_label = create_artificial_label (UNKNOWN_LOCATION);\n@@ -11924,8 +11924,7 @@ ipa_simd_modify_stmt_ops (tree *tp, int *walk_subtrees, void *data)\n \t}\n       else\n \t{\n-\t  stmt = gimple_build_assign (make_ssa_name (TREE_TYPE (repl),\n-\t\t\t\t\t\t     NULL), repl);\n+\t  stmt = gimple_build_assign (make_ssa_name (TREE_TYPE (repl)), repl);\n \t  repl = gimple_assign_lhs (stmt);\n \t}\n       gimple_stmt_iterator gsi = gsi_for_stmt (info->stmt);\n@@ -12090,8 +12089,8 @@ simd_clone_adjust (struct cgraph_node *node)\n   /* Adjust all uses of vector arguments accordingly.  Adjust all\n      return values accordingly.  */\n   tree iter = create_tmp_var (unsigned_type_node, \"iter\");\n-  tree iter1 = make_ssa_name (iter, NULL);\n-  tree iter2 = make_ssa_name (iter, NULL);\n+  tree iter1 = make_ssa_name (iter);\n+  tree iter2 = make_ssa_name (iter);\n   ipa_simd_modify_function_body (node, adjustments, retval, iter1);\n \n   /* Initialize the iteration variable.  */\n@@ -12140,7 +12139,7 @@ simd_clone_adjust (struct cgraph_node *node)\n       gimple_stmt_iterator gsi = gsi_last_bb (loop->header);\n       tree mask_array\n \t= node->simdclone->args[node->simdclone->nargs - 1].simd_array;\n-      tree mask = make_ssa_name (TREE_TYPE (TREE_TYPE (mask_array)), NULL);\n+      tree mask = make_ssa_name (TREE_TYPE (TREE_TYPE (mask_array)));\n       tree aref = build4 (ARRAY_REF,\n \t\t\t  TREE_TYPE (TREE_TYPE (mask_array)),\n \t\t\t  mask_array, iter1,\n@@ -12152,7 +12151,7 @@ simd_clone_adjust (struct cgraph_node *node)\n \t{\n \t  aref = build1 (VIEW_CONVERT_EXPR,\n \t\t\t build_nonstandard_integer_type (bitsize, 0), mask);\n-\t  mask = make_ssa_name (TREE_TYPE (aref), NULL);\n+\t  mask = make_ssa_name (TREE_TYPE (aref));\n \t  g = gimple_build_assign (mask, aref);\n \t  gsi_insert_after (&gsi, g, GSI_CONTINUE_LINKING);\n \t}\n@@ -12234,12 +12233,12 @@ simd_clone_adjust (struct cgraph_node *node)\n \t    if (!useless_type_conversion_p (TREE_TYPE (orig_arg),\n \t\t\t\t\t    ptr_type_node))\n \t      need_cvt = true;\n-\t    tree t = make_ssa_name (need_cvt ? ptr_type_node : orig_arg, NULL);\n+\t    tree t = make_ssa_name (need_cvt ? ptr_type_node : orig_arg);\n \t    gimple_call_set_lhs (g, t);\n \t    gimple_seq_add_stmt_without_update (&seq, g);\n \t    if (need_cvt)\n \t      {\n-\t\tt = make_ssa_name (orig_arg, NULL);\n+\t\tt = make_ssa_name (orig_arg);\n \t\tg = gimple_build_assign_with_ops (NOP_EXPR, t,\n \t\t\t\t\t\t  gimple_call_lhs (g));\n \t\tgimple_seq_add_stmt_without_update (&seq, g);\n@@ -12274,8 +12273,8 @@ simd_clone_adjust (struct cgraph_node *node)\n \t\t    || POINTER_TYPE_P (TREE_TYPE (orig_arg)));\n \tif (def && !has_zero_uses (def))\n \t  {\n-\t    iter1 = make_ssa_name (orig_arg, NULL);\n-\t    iter2 = make_ssa_name (orig_arg, NULL);\n+\t    iter1 = make_ssa_name (orig_arg);\n+\t    iter2 = make_ssa_name (orig_arg);\n \t    phi = create_phi_node (iter1, body_bb);\n \t    add_phi_arg (phi, def, preheader_edge, UNKNOWN_LOCATION);\n \t    add_phi_arg (phi, iter2, latch_edge, UNKNOWN_LOCATION);"}, {"sha": "49c2920989a32d50a75e9b9cd00227c4f8e3b95d", "filename": "gcc/trans-mem.c", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b731b39027f635f0afa97010e803212c1133ee55/gcc%2Ftrans-mem.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b731b39027f635f0afa97010e803212c1133ee55/gcc%2Ftrans-mem.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftrans-mem.c?ref=b731b39027f635f0afa97010e803212c1133ee55", "patch": "@@ -1675,7 +1675,7 @@ lower_transaction (gimple_stmt_iterator *gsi, struct walk_stmt_info *wi)\n \n       g = gimple_build_call (builtin_decl_explicit (BUILT_IN_EH_POINTER),\n \t\t\t     1, integer_zero_node);\n-      ptr = create_tmp_var (ptr_type_node, NULL);\n+      ptr = create_tmp_var (ptr_type_node);\n       gimple_call_set_lhs (g, ptr);\n       gimple_seq_add_stmt (&e_seq, g);\n \n@@ -2195,7 +2195,7 @@ build_tm_load (location_t loc, tree lhs, tree rhs, gimple_stmt_iterator *gsi)\n       gimple g;\n       tree temp;\n \n-      temp = create_tmp_reg (t, NULL);\n+      temp = create_tmp_reg (t);\n       gimple_call_set_lhs (gcall, temp);\n       gsi_insert_before (gsi, gcall, GSI_SAME_STMT);\n \n@@ -2273,7 +2273,7 @@ build_tm_store (location_t loc, tree lhs, tree rhs, gimple_stmt_iterator *gsi)\n       gimple g;\n       tree temp;\n \n-      temp = create_tmp_reg (simple_type, NULL);\n+      temp = create_tmp_reg (simple_type);\n       t = fold_build1 (VIEW_CONVERT_EXPR, simple_type, rhs);\n       g = gimple_build_assign (temp, t);\n       gimple_set_location (g, loc);\n@@ -2339,7 +2339,7 @@ expand_assign_tm (struct tm_region *region, gimple_stmt_iterator *gsi)\n \n       if (load_p && is_gimple_reg (lhs))\n \t{\n-\t  tmp = create_tmp_var (TREE_TYPE (lhs), NULL);\n+\t  tmp = create_tmp_var (TREE_TYPE (lhs));\n \t  lhs_addr = build_fold_addr_expr (tmp);\n \t}\n       else\n@@ -2466,7 +2466,7 @@ expand_call_tm (struct tm_region *region,\n   if (lhs && requires_barrier (region->entry_block, lhs, stmt)\n       && !gimple_call_return_slot_opt_p (stmt))\n     {\n-      tree tmp = create_tmp_reg (TREE_TYPE (lhs), NULL);\n+      tree tmp = create_tmp_reg (TREE_TYPE (lhs));\n       location_t loc = gimple_location (stmt);\n       edge fallthru_edge = NULL;\n       gassign *assign_stmt;\n@@ -2805,7 +2805,7 @@ expand_transaction (struct tm_region *region, void *data ATTRIBUTE_UNUSED)\n       if (region->restart_block == region->entry_block)\n \tregion->restart_block = test_bb;\n \n-      tree t1 = create_tmp_reg (tm_state_type, NULL);\n+      tree t1 = create_tmp_reg (tm_state_type);\n       tree t2 = build_int_cst (tm_state_type, A_RESTORELIVEVARIABLES);\n       gimple stmt = gimple_build_assign_with_ops (BIT_AND_EXPR, t1,\n \t\t\t\t\t\t  tm_state, t2);\n@@ -2846,7 +2846,7 @@ expand_transaction (struct tm_region *region, void *data ATTRIBUTE_UNUSED)\n       if (region->restart_block == region->entry_block)\n \tregion->restart_block = test_bb;\n \n-      tree t1 = create_tmp_reg (tm_state_type, NULL);\n+      tree t1 = create_tmp_reg (tm_state_type);\n       tree t2 = build_int_cst (tm_state_type, A_ABORTTRANSACTION);\n       gimple stmt = gimple_build_assign_with_ops (BIT_AND_EXPR, t1,\n \t\t\t\t\t\t  tm_state, t2);\n@@ -2888,7 +2888,7 @@ expand_transaction (struct tm_region *region, void *data ATTRIBUTE_UNUSED)\n       if (region->restart_block == region->entry_block)\n \tregion->restart_block = test_bb;\n \n-      tree t1 = create_tmp_reg (tm_state_type, NULL);\n+      tree t1 = create_tmp_reg (tm_state_type);\n       tree t2 = build_int_cst (tm_state_type, A_RUNUNINSTRUMENTEDCODE);\n \n       gimple stmt = gimple_build_assign_with_ops (BIT_AND_EXPR, t1,\n@@ -5053,7 +5053,7 @@ ipa_tm_insert_gettmclone_call (struct cgraph_node *node,\n   safe = is_tm_safe (TREE_TYPE (old_fn));\n   gettm_fn = builtin_decl_explicit (safe ? BUILT_IN_TM_GETTMCLONE_SAFE\n \t\t\t\t    : BUILT_IN_TM_GETTMCLONE_IRR);\n-  ret = create_tmp_var (ptr_type_node, NULL);\n+  ret = create_tmp_var (ptr_type_node);\n \n   if (!safe)\n     transaction_subcode_ior (region, GTMA_MAY_ENTER_IRREVOCABLE);\n@@ -5074,7 +5074,7 @@ ipa_tm_insert_gettmclone_call (struct cgraph_node *node,\n \n   /* Cast return value from tm_gettmclone* into appropriate function\n      pointer.  */\n-  callfn = create_tmp_var (TREE_TYPE (old_fn), NULL);\n+  callfn = create_tmp_var (TREE_TYPE (old_fn));\n   g2 = gimple_build_assign (callfn,\n \t\t\t    fold_build1 (NOP_EXPR, TREE_TYPE (callfn), ret));\n   callfn = make_ssa_name (callfn, g2);\n@@ -5099,7 +5099,7 @@ ipa_tm_insert_gettmclone_call (struct cgraph_node *node,\n     {\n       tree temp;\n \n-      temp = create_tmp_reg (rettype, 0);\n+      temp = create_tmp_reg (rettype);\n       gimple_call_set_lhs (stmt, temp);\n \n       g2 = gimple_build_assign (lhs,"}, {"sha": "fbbe9c8a9a5fa0a911aba62d5504b6688a0a555d", "filename": "gcc/tree-cfg.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b731b39027f635f0afa97010e803212c1133ee55/gcc%2Ftree-cfg.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b731b39027f635f0afa97010e803212c1133ee55/gcc%2Ftree-cfg.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-cfg.c?ref=b731b39027f635f0afa97010e803212c1133ee55", "patch": "@@ -546,7 +546,7 @@ make_blocks (gimple_seq seq)\n \t      && is_gimple_reg_type (TREE_TYPE (gimple_get_lhs (stmt))))\n \t    {\n \t      tree lhs = gimple_get_lhs (stmt);\n-\t      tree tmp = create_tmp_var (TREE_TYPE (lhs), NULL);\n+\t      tree tmp = create_tmp_var (TREE_TYPE (lhs));\n \t      gimple s = gimple_build_assign (lhs, tmp);\n \t      gimple_set_location (s, gimple_location (stmt));\n \t      gimple_set_block (s, gimple_block (stmt));"}, {"sha": "81425d0057fed301304a974db6cc96c0a07f92e1", "filename": "gcc/tree-cfgcleanup.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b731b39027f635f0afa97010e803212c1133ee55/gcc%2Ftree-cfgcleanup.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b731b39027f635f0afa97010e803212c1133ee55/gcc%2Ftree-cfgcleanup.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-cfgcleanup.c?ref=b731b39027f635f0afa97010e803212c1133ee55", "patch": "@@ -598,7 +598,7 @@ fixup_noreturn_call (gimple stmt)\n       /* We need to fix up the SSA name to avoid checking errors.  */\n       if (TREE_CODE (lhs) == SSA_NAME)\n \t{\n-\t  tree new_var = create_tmp_reg (TREE_TYPE (lhs), NULL);\n+\t  tree new_var = create_tmp_reg (TREE_TYPE (lhs));\n \t  SET_SSA_NAME_VAR_OR_IDENTIFIER (lhs, new_var);\n \t  SSA_NAME_DEF_STMT (lhs) = gimple_build_nop ();\n \t  set_ssa_default_def (cfun, new_var, lhs);"}, {"sha": "7fe7c2ddd7c12be98945c5a71de0ab30e2bd8cf7", "filename": "gcc/tree-complex.c", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b731b39027f635f0afa97010e803212c1133ee55/gcc%2Ftree-complex.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b731b39027f635f0afa97010e803212c1133ee55/gcc%2Ftree-complex.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-complex.c?ref=b731b39027f635f0afa97010e803212c1133ee55", "patch": "@@ -514,7 +514,7 @@ get_component_ssa_name (tree ssa_name, bool imag_p)\n \tret = get_component_var (SSA_NAME_VAR (ssa_name), imag_p);\n       else\n \tret = TREE_TYPE (TREE_TYPE (ssa_name));\n-      ret = make_ssa_name (ret, NULL);\n+      ret = make_ssa_name (ret);\n \n       /* Copy some properties from the original.  In particular, whether it\n \t is used in an abnormal phi, and whether it's uninitialized.  */\n@@ -1143,11 +1143,11 @@ expand_complex_div_wide (gimple_stmt_iterator *gsi, tree inner_type,\n       gimple stmt;\n       tree cond, tmp;\n \n-      tmp = create_tmp_var (boolean_type_node, NULL);\n+      tmp = create_tmp_var (boolean_type_node);\n       stmt = gimple_build_assign (tmp, compare);\n       if (gimple_in_ssa_p (cfun))\n \t{\n-\t  tmp = make_ssa_name (tmp,  stmt);\n+\t  tmp = make_ssa_name (tmp, stmt);\n \t  gimple_assign_set_lhs (stmt, tmp);\n \t}\n \n@@ -1182,8 +1182,8 @@ expand_complex_div_wide (gimple_stmt_iterator *gsi, tree inner_type,\n           set_immediate_dominator (CDI_DOMINATORS, bb_false, bb_cond);\n         }\n \n-      rr = create_tmp_reg (inner_type, NULL);\n-      ri = create_tmp_reg (inner_type, NULL);\n+      rr = create_tmp_reg (inner_type);\n+      ri = create_tmp_reg (inner_type);\n     }\n \n   /* In the TRUE branch, we compute"}, {"sha": "5d151f721e4cfd799b2bdda223e5cd682ba84c12", "filename": "gcc/tree-eh.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b731b39027f635f0afa97010e803212c1133ee55/gcc%2Ftree-eh.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b731b39027f635f0afa97010e803212c1133ee55/gcc%2Ftree-eh.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-eh.c?ref=b731b39027f635f0afa97010e803212c1133ee55", "patch": "@@ -2044,7 +2044,7 @@ lower_eh_constructs_2 (struct leh_state *state, gimple_stmt_iterator *gsi)\n \t  && is_gimple_reg_type (TREE_TYPE (gimple_get_lhs (stmt))))\n \t{\n \t  tree lhs = gimple_get_lhs (stmt);\n-\t  tree tmp = create_tmp_var (TREE_TYPE (lhs), NULL);\n+\t  tree tmp = create_tmp_var (TREE_TYPE (lhs));\n \t  gimple s = gimple_build_assign (lhs, tmp);\n \t  gimple_set_location (s, gimple_location (stmt));\n \t  gimple_set_block (s, gimple_block (stmt));\n@@ -3286,7 +3286,7 @@ lower_resx (basic_block bb, gresx *stmt,\n \t  fn = builtin_decl_implicit (BUILT_IN_EH_POINTER);\n \t  src_nr = build_int_cst (integer_type_node, src_r->index);\n \t  x = gimple_build_call (fn, 1, src_nr);\n-\t  var = create_tmp_var (ptr_type_node, NULL);\n+\t  var = create_tmp_var (ptr_type_node);\n \t  var = make_ssa_name (var, x);\n \t  gimple_call_set_lhs (x, var);\n \t  gsi_insert_before (&gsi, x, GSI_SAME_STMT);\n@@ -3652,7 +3652,7 @@ lower_eh_dispatch (basic_block src, geh_dispatch *stmt)\n \t    fn = builtin_decl_implicit (BUILT_IN_EH_FILTER);\n \t    x = gimple_build_call (fn, 1, build_int_cst (integer_type_node,\n \t\t\t\t\t\t\t region_nr));\n-\t    filter = create_tmp_var (TREE_TYPE (TREE_TYPE (fn)), NULL);\n+\t    filter = create_tmp_var (TREE_TYPE (TREE_TYPE (fn)));\n \t    filter = make_ssa_name (filter, x);\n \t    gimple_call_set_lhs (x, filter);\n \t    gsi_insert_before (&gsi, x, GSI_SAME_STMT);\n@@ -3675,7 +3675,7 @@ lower_eh_dispatch (basic_block src, geh_dispatch *stmt)\n \tfn = builtin_decl_implicit (BUILT_IN_EH_FILTER);\n \tx = gimple_build_call (fn, 1, build_int_cst (integer_type_node,\n \t\t\t\t\t\t     region_nr));\n-\tfilter = create_tmp_var (TREE_TYPE (TREE_TYPE (fn)), NULL);\n+\tfilter = create_tmp_var (TREE_TYPE (TREE_TYPE (fn)));\n \tfilter = make_ssa_name (filter, x);\n \tgimple_call_set_lhs (x, filter);\n \tgsi_insert_before (&gsi, x, GSI_SAME_STMT);"}, {"sha": "d20759f182a0e010334fbf658544ed3d12fc746b", "filename": "gcc/tree-emutls.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b731b39027f635f0afa97010e803212c1133ee55/gcc%2Ftree-emutls.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b731b39027f635f0afa97010e803212c1133ee55/gcc%2Ftree-emutls.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-emutls.c?ref=b731b39027f635f0afa97010e803212c1133ee55", "patch": "@@ -425,7 +425,7 @@ gen_emutls_addr (tree decl, struct lower_emutls_data *d)\n       cdecl = cvar->decl;\n       TREE_ADDRESSABLE (cdecl) = 1;\n \n-      addr = create_tmp_var (build_pointer_type (TREE_TYPE (decl)), NULL);\n+      addr = create_tmp_var (build_pointer_type (TREE_TYPE (decl)));\n       x = gimple_build_call (d->builtin_decl, 1, build_fold_addr_expr (cdecl));\n       gimple_set_location (x, d->loc);\n \n@@ -493,7 +493,7 @@ lower_emutls_1 (tree *ptr, int *walk_subtrees, void *cb_data)\n \t    {\n \t      gimple x;\n \n-\t      addr = create_tmp_var (TREE_TYPE (t), NULL);\n+\t      addr = create_tmp_var (TREE_TYPE (t));\n \t      x = gimple_build_assign (addr, t);\n \t      gimple_set_location (x, d->loc);\n "}, {"sha": "f7befac6f5fae4fe92e69f04f5c672d20b319f18", "filename": "gcc/tree-if-conv.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b731b39027f635f0afa97010e803212c1133ee55/gcc%2Ftree-if-conv.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b731b39027f635f0afa97010e803212c1133ee55/gcc%2Ftree-if-conv.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-if-conv.c?ref=b731b39027f635f0afa97010e803212c1133ee55", "patch": "@@ -2108,7 +2108,7 @@ static bool\n version_loop_for_if_conversion (struct loop *loop)\n {\n   basic_block cond_bb;\n-  tree cond = make_ssa_name (boolean_type_node, NULL);\n+  tree cond = make_ssa_name (boolean_type_node);\n   struct loop *new_loop;\n   gimple g;\n   gimple_stmt_iterator gsi;"}, {"sha": "0a7548967c53f343e987d60ac3376d01f9e6320f", "filename": "gcc/tree-inline.c", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b731b39027f635f0afa97010e803212c1133ee55/gcc%2Ftree-inline.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b731b39027f635f0afa97010e803212c1133ee55/gcc%2Ftree-inline.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-inline.c?ref=b731b39027f635f0afa97010e803212c1133ee55", "patch": "@@ -260,7 +260,7 @@ remap_ssa_name (tree name, copy_body_data *id)\n \t  && !DECL_NAME (var)))\n     {\n       struct ptr_info_def *pi;\n-      new_tree = make_ssa_name (remap_type (TREE_TYPE (name), id), NULL);\n+      new_tree = make_ssa_name (remap_type (TREE_TYPE (name), id));\n       if (!var && SSA_NAME_IDENTIFIER (name))\n \tSET_SSA_NAME_VAR_OR_IDENTIFIER (new_tree, SSA_NAME_IDENTIFIER (name));\n       insert_decl_map (id, name, new_tree);\n@@ -294,7 +294,7 @@ remap_ssa_name (tree name, copy_body_data *id)\n \t  || !id->transform_return_to_modify))\n     {\n       struct ptr_info_def *pi;\n-      new_tree = make_ssa_name (new_tree, NULL);\n+      new_tree = make_ssa_name (new_tree);\n       insert_decl_map (id, name, new_tree);\n       SSA_NAME_OCCURS_IN_ABNORMAL_PHI (new_tree)\n \t= SSA_NAME_OCCURS_IN_ABNORMAL_PHI (name);\n@@ -3189,7 +3189,7 @@ setup_one_parameter (copy_body_data *id, tree p, tree value, tree fn,\n \t    }\n \t  else if (!optimize)\n \t    {\n-\t      def = make_ssa_name (var, NULL);\n+\t      def = make_ssa_name (var);\n \t      init_stmt = gimple_build_assign (def, rhs);\n \t    }\n \t}\n@@ -3454,7 +3454,7 @@ declare_return_variable (copy_body_data *id, tree return_slot, tree modify_dest,\n       if (gimple_in_ssa_p (id->src_cfun)\n \t  && is_gimple_reg (result))\n \t{\n-\t  temp = make_ssa_name (temp, NULL);\n+\t  temp = make_ssa_name (temp);\n \t  insert_decl_map (id, ssa_default_def (id->src_cfun, result), temp);\n \t}\n       insert_init_stmt (id, entry_bb, gimple_build_assign (temp, var));\n@@ -5719,7 +5719,7 @@ tree_function_versioning (tree old_decl, tree new_decl,\n \t  && DECL_BY_REFERENCE (DECL_RESULT (old_decl))\n \t  && (old_name = ssa_default_def (id.src_cfun, DECL_RESULT (old_decl))))\n \t{\n-\t  tree new_name = make_ssa_name (DECL_RESULT (new_decl), NULL);\n+\t  tree new_name = make_ssa_name (DECL_RESULT (new_decl));\n \t  insert_decl_map (&id, old_name, new_name);\n \t  SSA_NAME_DEF_STMT (new_name) = gimple_build_nop ();\n \t  set_ssa_default_def (cfun, DECL_RESULT (new_decl), new_name);"}, {"sha": "c88a41144391538451e07a58870872d1ed65bb6c", "filename": "gcc/tree-loop-distribution.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b731b39027f635f0afa97010e803212c1133ee55/gcc%2Ftree-loop-distribution.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b731b39027f635f0afa97010e803212c1133ee55/gcc%2Ftree-loop-distribution.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-loop-distribution.c?ref=b731b39027f635f0afa97010e803212c1133ee55", "patch": "@@ -822,7 +822,7 @@ generate_memset_builtin (struct loop *loop, partition_t partition)\n     val = fold_convert (integer_type_node, val);\n   else if (!useless_type_conversion_p (integer_type_node, TREE_TYPE (val)))\n     {\n-      tree tem = make_ssa_name (integer_type_node, NULL);\n+      tree tem = make_ssa_name (integer_type_node);\n       gimple cstmt = gimple_build_assign_with_ops (NOP_EXPR, tem, val);\n       gsi_insert_after (&gsi, cstmt, GSI_CONTINUE_LINKING);\n       val = tem;"}, {"sha": "622b71b13ceead0384becec7908caf52231de517", "filename": "gcc/tree-outof-ssa.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b731b39027f635f0afa97010e803212c1133ee55/gcc%2Ftree-outof-ssa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b731b39027f635f0afa97010e803212c1133ee55/gcc%2Ftree-outof-ssa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-outof-ssa.c?ref=b731b39027f635f0afa97010e803212c1133ee55", "patch": "@@ -1169,7 +1169,7 @@ insert_backedge_copies (void)\n \n \t\t  /* Create a new instance of the underlying variable of the\n \t\t     PHI result.  */\n-\t\t  name = copy_ssa_name (result, NULL);\n+\t\t  name = copy_ssa_name (result);\n \t\t  stmt = gimple_build_assign (name,\n \t\t\t\t\t      gimple_phi_arg_def (phi, i));\n "}, {"sha": "7af59938d64937dd47d284456d788f14fb143e62", "filename": "gcc/tree-parloops.c", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b731b39027f635f0afa97010e803212c1133ee55/gcc%2Ftree-parloops.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b731b39027f635f0afa97010e803212c1133ee55/gcc%2Ftree-parloops.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-parloops.c?ref=b731b39027f635f0afa97010e803212c1133ee55", "patch": "@@ -533,7 +533,7 @@ take_address_of (tree obj, tree type, edge entry,\n       if (obj_name)\n \tname = make_temp_ssa_name (TREE_TYPE (addr), NULL, obj_name);\n       else\n-\tname = make_ssa_name (TREE_TYPE (addr), NULL);\n+\tname = make_ssa_name (TREE_TYPE (addr));\n       stmt = gimple_build_assign (name, addr);\n       gsi_insert_on_edge_immediate (entry, stmt);\n \n@@ -1057,7 +1057,7 @@ create_phi_for_local_result (reduction_info **slot, struct loop *loop)\n     e = EDGE_PRED (store_bb, 1);\n   else\n     e = EDGE_PRED (store_bb, 0);\n-  local_res = copy_ssa_name (gimple_assign_lhs (reduc->reduc_stmt), NULL);\n+  local_res = copy_ssa_name (gimple_assign_lhs (reduc->reduc_stmt));\n   locus = gimple_location (reduc->reduc_stmt);\n   new_phi = create_phi_node (local_res, store_bb);\n   add_phi_arg (new_phi, reduc->init, e, locus);\n@@ -1107,8 +1107,8 @@ create_call_for_reduction_1 (reduction_info **slot, struct clsn_data *clsn_data)\n   e = split_block (bb, t);\n   new_bb = e->dest;\n \n-  tmp_load = create_tmp_var (TREE_TYPE (TREE_TYPE (addr)), NULL);\n-  tmp_load = make_ssa_name (tmp_load, NULL);\n+  tmp_load = create_tmp_var (TREE_TYPE (TREE_TYPE (addr)));\n+  tmp_load = make_ssa_name (tmp_load);\n   load = gimple_build_omp_atomic_load (tmp_load, addr);\n   SSA_NAME_DEF_STMT (tmp_load) = load;\n   gsi = gsi_start_bb (new_bb);\n@@ -1388,7 +1388,7 @@ separate_decls_in_region (edge entry, edge exit,\n       /* Create the loads and stores.  */\n       *arg_struct = create_tmp_var (type, \".paral_data_store\");\n       nvar = create_tmp_var (build_pointer_type (type), \".paral_data_load\");\n-      *new_arg_struct = make_ssa_name (nvar, NULL);\n+      *new_arg_struct = make_ssa_name (nvar);\n \n       ld_st_data->store = *arg_struct;\n       ld_st_data->load = *new_arg_struct;\n@@ -1406,7 +1406,7 @@ separate_decls_in_region (edge entry, edge exit,\n \t  reduction_list\n \t    ->traverse <struct clsn_data *, create_stores_for_reduction>\n \t    (ld_st_data);\n-\t  clsn_data.load = make_ssa_name (nvar, NULL);\n+\t  clsn_data.load = make_ssa_name (nvar);\n \t  clsn_data.load_bb = exit->dest;\n \t  clsn_data.store = ld_st_data->store;\n \t  create_final_loads_for_reduction (reduction_list, &clsn_data);\n@@ -1649,7 +1649,7 @@ create_parallel_loop (struct loop *loop, tree loop_fn, tree data,\n \n       gsi = gsi_after_labels (bb);\n \n-      param = make_ssa_name (DECL_ARGUMENTS (loop_fn), NULL);\n+      param = make_ssa_name (DECL_ARGUMENTS (loop_fn));\n       assign_stmt = gimple_build_assign (param, build_fold_addr_expr (data));\n       gsi_insert_before (&gsi, assign_stmt, GSI_SAME_STMT);\n \n@@ -1673,7 +1673,7 @@ create_parallel_loop (struct loop *loop, tree loop_fn, tree data,\n   cvar_base = SSA_NAME_VAR (cvar);\n   phi = SSA_NAME_DEF_STMT (cvar);\n   cvar_init = PHI_ARG_DEF_FROM_EDGE (phi, loop_preheader_edge (loop));\n-  initvar = copy_ssa_name (cvar, NULL);\n+  initvar = copy_ssa_name (cvar);\n   SET_USE (PHI_ARG_DEF_PTR_FROM_EDGE (phi, loop_preheader_edge (loop)),\n \t   initvar);\n   cvar_next = PHI_ARG_DEF_FROM_EDGE (phi, loop_latch_edge (loop));"}, {"sha": "e5f3ea78143b821030fdf37338f5e9ea44372a1b", "filename": "gcc/tree-predcom.c", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b731b39027f635f0afa97010e803212c1133ee55/gcc%2Ftree-predcom.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b731b39027f635f0afa97010e803212c1133ee55/gcc%2Ftree-predcom.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-predcom.c?ref=b731b39027f635f0afa97010e803212c1133ee55", "patch": "@@ -1491,7 +1491,7 @@ initialize_root_vars (struct loop *loop, chain_p chain, bitmap tmp_vars)\n     chain->vars.quick_push (chain->vars[0]);\n \n   FOR_EACH_VEC_ELT (chain->vars, i, var)\n-    chain->vars[i] = make_ssa_name (var, NULL);\n+    chain->vars[i] = make_ssa_name (var);\n \n   for (i = 0; i < n; i++)\n     {\n@@ -1555,7 +1555,7 @@ initialize_root_vars_lm (struct loop *loop, dref root, bool written,\n     vars->quick_push ((*vars)[0]);\n \n   FOR_EACH_VEC_ELT (*vars, i, var)\n-    (*vars)[i] = make_ssa_name (var, NULL);\n+    (*vars)[i] = make_ssa_name (var);\n \n   var = (*vars)[0];\n \n@@ -1613,7 +1613,7 @@ execute_load_motion (struct loop *loop, chain_p chain, bitmap tmp_vars)\n \t  if (n_writes)\n \t    {\n \t      var = vars[0];\n-\t      var = make_ssa_name (SSA_NAME_VAR (var), NULL);\n+\t      var = make_ssa_name (SSA_NAME_VAR (var));\n \t      vars[0] = var;\n \t    }\n \t  else\n@@ -2191,11 +2191,11 @@ reassociate_to_the_same_stmt (tree name1, tree name2)\n   /* Insert the new statement combining NAME1 and NAME2 before S1, and\n      combine it with the rhs of S1.  */\n   var = create_tmp_reg (type, \"predreastmp\");\n-  new_name = make_ssa_name (var, NULL);\n+  new_name = make_ssa_name (var);\n   new_stmt = gimple_build_assign_with_ops (code, new_name, name1, name2);\n \n   var = create_tmp_reg (type, \"predreastmp\");\n-  tmp_name = make_ssa_name (var, NULL);\n+  tmp_name = make_ssa_name (var);\n \n   /* Rhs of S1 may now be either a binary expression with operation\n      CODE, or gimple_val (in case that stmt1 == s1 or stmt2 == s1,"}, {"sha": "f213c8076e6e77a40c7d55c3fb328b6b47bc1c4f", "filename": "gcc/tree-sra.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b731b39027f635f0afa97010e803212c1133ee55/gcc%2Ftree-sra.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b731b39027f635f0afa97010e803212c1133ee55/gcc%2Ftree-sra.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-sra.c?ref=b731b39027f635f0afa97010e803212c1133ee55", "patch": "@@ -1548,7 +1548,7 @@ build_ref_for_offset (location_t loc, tree base, HOST_WIDE_INT offset,\n       tree tmp, addr;\n \n       gcc_checking_assert (gsi);\n-      tmp = make_ssa_name (build_pointer_type (TREE_TYPE (prev_base)), NULL);\n+      tmp = make_ssa_name (build_pointer_type (TREE_TYPE (prev_base)));\n       addr = build_fold_addr_expr (unshare_expr (prev_base));\n       STRIP_USELESS_TYPE_CONVERSION (addr);\n       stmt = gimple_build_assign (tmp, addr);\n@@ -1990,7 +1990,7 @@ create_access_replacement (struct access *access)\n \n   if (access->grp_to_be_debug_replaced)\n     {\n-      repl = create_tmp_var_raw (access->type, NULL);\n+      repl = create_tmp_var_raw (access->type);\n       DECL_CONTEXT (repl) = current_function_decl;\n     }\n   else"}, {"sha": "1095821f4a7d6c7149e789b64a7ab68d990e765b", "filename": "gcc/tree-ssa-ccp.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b731b39027f635f0afa97010e803212c1133ee55/gcc%2Ftree-ssa-ccp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b731b39027f635f0afa97010e803212c1133ee55/gcc%2Ftree-ssa-ccp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-ccp.c?ref=b731b39027f635f0afa97010e803212c1133ee55", "patch": "@@ -2065,7 +2065,7 @@ fold_builtin_alloca_with_align (gimple stmt)\n   elem_type = build_nonstandard_integer_type (BITS_PER_UNIT, 1);\n   n_elem = size * 8 / BITS_PER_UNIT;\n   array_type = build_array_type_nelts (elem_type, n_elem);\n-  var = create_tmp_var (array_type, NULL);\n+  var = create_tmp_var (array_type);\n   DECL_ALIGN (var) = TREE_INT_CST_LOW (gimple_call_arg (stmt, 1));\n   {\n     struct ptr_info_def *pi = SSA_NAME_PTR_INFO (lhs);"}, {"sha": "9c6f25bdfb94ecd06de79126a7e688b750813a38", "filename": "gcc/tree-ssa-forwprop.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b731b39027f635f0afa97010e803212c1133ee55/gcc%2Ftree-ssa-forwprop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b731b39027f635f0afa97010e803212c1133ee55/gcc%2Ftree-ssa-forwprop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-forwprop.c?ref=b731b39027f635f0afa97010e803212c1133ee55", "patch": "@@ -1723,14 +1723,14 @@ simplify_rotate (gimple_stmt_iterator *gsi)\n \t\t\t\t  TREE_TYPE (rotcnt)))\n     {\n       g = gimple_build_assign_with_ops (NOP_EXPR,\n-\t\t\t\t\tmake_ssa_name (TREE_TYPE (def_arg2[0]),\n-\t\t\t\t\t\t       NULL), rotcnt);\n+\t\t\t\t\tmake_ssa_name (TREE_TYPE (def_arg2[0])),\n+\t\t\t\t\trotcnt);\n       gsi_insert_before (gsi, g, GSI_SAME_STMT);\n       rotcnt = gimple_assign_lhs (g);\n     }\n   lhs = gimple_assign_lhs (stmt);\n   if (!useless_type_conversion_p (rtype, TREE_TYPE (def_arg1[0])))\n-    lhs = make_ssa_name (TREE_TYPE (def_arg1[0]), NULL);\n+    lhs = make_ssa_name (TREE_TYPE (def_arg1[0]));\n   g = gimple_build_assign_with_ops (((def_code[0] == LSHIFT_EXPR) ^ swapped_p)\n \t\t\t\t    ? LROTATE_EXPR : RROTATE_EXPR,\n \t\t\t\t    lhs, def_arg1[0], rotcnt);"}, {"sha": "eb98b42cf9595d07559d9edf644adab06c7aca06", "filename": "gcc/tree-ssa-loop-manip.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b731b39027f635f0afa97010e803212c1133ee55/gcc%2Ftree-ssa-loop-manip.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b731b39027f635f0afa97010e803212c1133ee55/gcc%2Ftree-ssa-loop-manip.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-manip.c?ref=b731b39027f635f0afa97010e803212c1133ee55", "patch": "@@ -92,8 +92,8 @@ create_iv (tree base, tree step, tree var, struct loop *loop,\n \n   if (var != NULL_TREE)\n     {\n-      vb = make_ssa_name (var, NULL);\n-      va = make_ssa_name (var, NULL);\n+      vb = make_ssa_name (var);\n+      va = make_ssa_name (var);\n     }\n   else\n     {\n@@ -1158,11 +1158,11 @@ tree_transform_and_unroll_loop (struct loop *loop, unsigned factor,\n       if (TREE_CODE (next) == SSA_NAME\n \t  && useless_type_conversion_p (TREE_TYPE (next),\n \t\t\t\t\tTREE_TYPE (init)))\n-\tnew_init = copy_ssa_name (next, NULL);\n+\tnew_init = copy_ssa_name (next);\n       else if (TREE_CODE (init) == SSA_NAME\n \t       && useless_type_conversion_p (TREE_TYPE (init),\n \t\t\t\t\t     TREE_TYPE (next)))\n-\tnew_init = copy_ssa_name (init, NULL);\n+\tnew_init = copy_ssa_name (init);\n       else if (useless_type_conversion_p (TREE_TYPE (next), TREE_TYPE (init)))\n \tnew_init = make_temp_ssa_name (TREE_TYPE (next), NULL, \"unrinittmp\");\n       else"}, {"sha": "14b09b4599ab0986e73f97e18768733ee2677ae4", "filename": "gcc/tree-ssa-math-opts.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b731b39027f635f0afa97010e803212c1133ee55/gcc%2Ftree-ssa-math-opts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b731b39027f635f0afa97010e803212c1133ee55/gcc%2Ftree-ssa-math-opts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-math-opts.c?ref=b731b39027f635f0afa97010e803212c1133ee55", "patch": "@@ -1129,7 +1129,7 @@ static tree\n build_and_insert_cast (gimple_stmt_iterator *gsi, location_t loc,\n \t\t       tree type, tree val)\n {\n-  tree result = make_ssa_name (type, NULL);\n+  tree result = make_ssa_name (type);\n   gassign *stmt = gimple_build_assign_with_ops (NOP_EXPR, result, val);\n   gimple_set_location (stmt, loc);\n   gsi_insert_before (gsi, stmt, GSI_SAME_STMT);"}, {"sha": "dc3bbdc777b4998128aa5a8e4f9d9480c497b2e7", "filename": "gcc/tree-ssa-phiopt.c", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b731b39027f635f0afa97010e803212c1133ee55/gcc%2Ftree-ssa-phiopt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b731b39027f635f0afa97010e803212c1133ee55/gcc%2Ftree-ssa-phiopt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-phiopt.c?ref=b731b39027f635f0afa97010e803212c1133ee55", "patch": "@@ -536,7 +536,7 @@ conditional_replacement (basic_block cond_bb, basic_block middle_bb,\n     {\n       source_location locus_0, locus_1;\n \n-      new_var2 = make_ssa_name (TREE_TYPE (result), NULL);\n+      new_var2 = make_ssa_name (TREE_TYPE (result));\n       new_stmt = gimple_build_assign_with_ops (CONVERT_EXPR, new_var2,\n \t\t\t\t\t       new_var);\n       gsi_insert_before (&gsi, new_stmt, GSI_SAME_STMT);\n@@ -1253,7 +1253,7 @@ abs_replacement (basic_block cond_bb, basic_block middle_bb,\n   result = duplicate_ssa_name (result, NULL);\n \n   if (negate)\n-    lhs = make_ssa_name (TREE_TYPE (result), NULL);\n+    lhs = make_ssa_name (TREE_TYPE (result));\n   else\n     lhs = result;\n \n@@ -1370,7 +1370,7 @@ neg_replacement (basic_block cond_bb, basic_block middle_bb,\n \t}\n     }\n \n-  tree cond_val = make_ssa_name (boolean_type_node, NULL);\n+  tree cond_val = make_ssa_name (boolean_type_node);\n   new_stmt = gimple_build_assign_with_ops (cond_code, cond_val,\n \t\t\t\t\t   gimple_cond_lhs (cond),\n \t\t\t\t\t   gimple_cond_rhs (cond));\n@@ -1381,7 +1381,7 @@ neg_replacement (basic_block cond_bb, basic_block middle_bb,\n      condition.  */\n   if (invert)\n     {\n-      tree tmp = make_ssa_name (boolean_type_node, NULL);\n+      tree tmp = make_ssa_name (boolean_type_node);\n       new_stmt = gimple_build_assign_with_ops (BIT_XOR_EXPR, tmp,\n \t\t\t\t\t       cond_val, boolean_true_node);\n       gsi_insert_after (&gsi, new_stmt, GSI_NEW_STMT);\n@@ -1390,22 +1390,22 @@ neg_replacement (basic_block cond_bb, basic_block middle_bb,\n \n   /* Get the condition in the right type so that we can perform\n      logical and arithmetic operations on it.  */\n-  tree cond_val_converted = make_ssa_name (TREE_TYPE (rhs), NULL);\n+  tree cond_val_converted = make_ssa_name (TREE_TYPE (rhs));\n   new_stmt = gimple_build_assign_with_ops (NOP_EXPR, cond_val_converted,\n \t\t\t\t\t   cond_val);\n   gsi_insert_after (&gsi, new_stmt, GSI_NEW_STMT);\n \n-  tree neg_cond_val_converted = make_ssa_name (TREE_TYPE (rhs), NULL);\n+  tree neg_cond_val_converted = make_ssa_name (TREE_TYPE (rhs));\n   new_stmt = gimple_build_assign_with_ops (NEGATE_EXPR, neg_cond_val_converted,\n \t\t\t\t\t   cond_val_converted);\n   gsi_insert_after (&gsi, new_stmt, GSI_NEW_STMT);\n \n-  tree tmp = make_ssa_name (TREE_TYPE (rhs), NULL);\n+  tree tmp = make_ssa_name (TREE_TYPE (rhs));\n   new_stmt = gimple_build_assign_with_ops (BIT_XOR_EXPR, tmp,\n \t\t\t\t\t   rhs, neg_cond_val_converted);\n   gsi_insert_after (&gsi, new_stmt, GSI_NEW_STMT);\n \n-  tree new_lhs = make_ssa_name (TREE_TYPE (rhs), NULL);\n+  tree new_lhs = make_ssa_name (TREE_TYPE (rhs));\n   new_stmt = gimple_build_assign_with_ops (PLUS_EXPR, new_lhs,\n \t\t\t\t\t   tmp, cond_val_converted);\n   gsi_insert_after (&gsi, new_stmt, GSI_NEW_STMT);"}, {"sha": "8565144b0b620bc2c9e32453c15da01d9d07ab81", "filename": "gcc/tree-ssa-phiprop.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b731b39027f635f0afa97010e803212c1133ee55/gcc%2Ftree-ssa-phiprop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b731b39027f635f0afa97010e803212c1133ee55/gcc%2Ftree-ssa-phiprop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-phiprop.c?ref=b731b39027f635f0afa97010e803212c1133ee55", "patch": "@@ -208,7 +208,7 @@ phiprop_insert_phi (basic_block bb, gphi *phi, gimple use_stmt,\n \t{\n \t  tree rhs = gimple_assign_rhs1 (use_stmt);\n \t  gcc_assert (TREE_CODE (old_arg) == ADDR_EXPR);\n-\t  new_var = make_ssa_name (TREE_TYPE (rhs), NULL);\n+\t  new_var = make_ssa_name (TREE_TYPE (rhs));\n \t  if (!is_gimple_min_invariant (old_arg))\n \t    old_arg = PHI_ARG_DEF_FROM_EDGE (phi, e);\n \t  else"}, {"sha": "1cd082eea2eb9cad9dcbbb14331b2ac50b8e32c8", "filename": "gcc/tree-ssa-propagate.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b731b39027f635f0afa97010e803212c1133ee55/gcc%2Ftree-ssa-propagate.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b731b39027f635f0afa97010e803212c1133ee55/gcc%2Ftree-ssa-propagate.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-propagate.c?ref=b731b39027f635f0afa97010e803212c1133ee55", "patch": "@@ -835,9 +835,9 @@ update_call_from_tree (gimple_stmt_iterator *si_p, tree expr)\n              with a dummy (unused) lhs variable.  */\n           STRIP_USELESS_TYPE_CONVERSION (expr);\n \t  if (gimple_in_ssa_p (cfun))\n-\t    lhs = make_ssa_name (TREE_TYPE (expr), NULL);\n+\t    lhs = make_ssa_name (TREE_TYPE (expr));\n \t  else\n-\t    lhs = create_tmp_var (TREE_TYPE (expr), NULL);\n+\t    lhs = create_tmp_var (TREE_TYPE (expr));\n           new_stmt = gimple_build_assign (lhs, expr);\n \t  gimple_set_vuse (new_stmt, gimple_vuse (stmt));\n \t  gimple_set_vdef (new_stmt, gimple_vdef (stmt));"}, {"sha": "4a2bda6acff77190bb991481c0bac6982ca3e3c8", "filename": "gcc/tree-ssa-reassoc.c", "status": "modified", "additions": 9, "deletions": 11, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b731b39027f635f0afa97010e803212c1133ee55/gcc%2Ftree-ssa-reassoc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b731b39027f635f0afa97010e803212c1133ee55/gcc%2Ftree-ssa-reassoc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-reassoc.c?ref=b731b39027f635f0afa97010e803212c1133ee55", "patch": "@@ -1341,7 +1341,7 @@ build_and_add_sum (tree type, tree op1, tree op2, enum tree_code opcode)\n   gassign *sum;\n \n   /* Create the addition statement.  */\n-  op = make_ssa_name (type, NULL);\n+  op = make_ssa_name (type);\n   sum = gimple_build_assign_with_ops (opcode, op, op1, op2);\n \n   /* Find an insertion place and insert.  */\n@@ -2594,8 +2594,7 @@ optimize_range_tests_to_bit_test (enum tree_code opcode, int first, int length,\n \t  gimple_set_visited (SSA_NAME_DEF_STMT (exp), true);\n \t  gimple g\n \t    = gimple_build_assign_with_ops (BIT_IOR_EXPR,\n-\t\t\t\t\t    make_ssa_name (optype, NULL),\n-\t\t\t\t\t    tem, exp);\n+\t\t\t\t\t    make_ssa_name (optype), tem, exp);\n \t  gimple_set_location (g, loc);\n \t  gimple_seq_add_stmt_without_update (&seq, g);\n \t  exp = gimple_assign_lhs (g);\n@@ -2999,7 +2998,7 @@ update_ops (tree var, enum tree_code code, vec<operand_entry_t> ops,\n       && (rhs[2] != rhs[1] || rhs[3] != rhs[0]))\n     {\n       gimple_stmt_iterator gsi = gsi_for_stmt (stmt);\n-      var = make_ssa_name (TREE_TYPE (var), NULL);\n+      var = make_ssa_name (TREE_TYPE (var));\n       gassign *g = gimple_build_assign_with_ops (gimple_assign_rhs_code (stmt),\n \t\t\t\t\t\t var, rhs[2], rhs[3]);\n       gimple_set_uid (g, gimple_uid (stmt));\n@@ -3296,7 +3295,7 @@ maybe_optimize_range_tests (gimple stmt)\n \t\t    {\n \t\t      gcc_assert (bb == last_bb);\n \t\t      tree lhs = gimple_assign_lhs (cast_stmt);\n-\t\t      tree new_lhs = make_ssa_name (TREE_TYPE (lhs), NULL);\n+\t\t      tree new_lhs = make_ssa_name (TREE_TYPE (lhs));\n \t\t      enum tree_code rhs_code\n \t\t\t= gimple_assign_rhs_code (cast_stmt);\n \t\t      gassign *g;\n@@ -3518,7 +3517,7 @@ rewrite_expr_tree (gimple stmt, unsigned int opindex,\n \t  if (changed)\n \t    {\n \t      gimple insert_point = find_insert_point (stmt, oe1->op, oe2->op);\n-\t      lhs = make_ssa_name (TREE_TYPE (lhs), NULL);\n+\t      lhs = make_ssa_name (TREE_TYPE (lhs));\n \t      stmt\n \t\t= gimple_build_assign_with_ops (gimple_assign_rhs_code (stmt),\n \t\t\t\t\t\tlhs, oe1->op, oe2->op);\n@@ -3583,7 +3582,7 @@ rewrite_expr_tree (gimple stmt, unsigned int opindex,\n \t  unsigned int uid = gimple_uid (stmt);\n \t  gimple insert_point = find_insert_point (stmt, new_rhs1, oe->op);\n \n-\t  lhs = make_ssa_name (TREE_TYPE (lhs), NULL);\n+\t  lhs = make_ssa_name (TREE_TYPE (lhs));\n \t  stmt = gimple_build_assign_with_ops (gimple_assign_rhs_code (stmt),\n \t\t\t\t\t       lhs, new_rhs1, oe->op);\n \t  gimple_set_uid (stmt, uid);\n@@ -3802,7 +3801,7 @@ linearize_expr (gimple stmt)\n \n   gimple_assign_set_rhs2 (stmt, gimple_assign_rhs1 (binrhs));\n   binrhs = gimple_build_assign_with_ops (gimple_assign_rhs_code (binrhs),\n-\t\t\t\t\t make_ssa_name (TREE_TYPE (lhs), NULL),\n+\t\t\t\t\t make_ssa_name (TREE_TYPE (lhs)),\n \t\t\t\t\t gimple_assign_lhs (binlhs),\n \t\t\t\t\t gimple_assign_rhs2 (binrhs));\n   gimple_assign_set_rhs1 (stmt, gimple_assign_lhs (binrhs));\n@@ -3890,7 +3889,7 @@ negate_value (tree tonegate, gimple_stmt_iterator *gsip)\n       rhs2 = negate_value (rhs2, &gsi);\n \n       gsi = gsi_for_stmt (negatedefstmt);\n-      lhs = make_ssa_name (TREE_TYPE (lhs), NULL);\n+      lhs = make_ssa_name (TREE_TYPE (lhs));\n       gimple_set_visited (negatedefstmt, true);\n       g = gimple_build_assign_with_ops (PLUS_EXPR, lhs, rhs1, rhs2);\n       gimple_set_uid (g, gimple_uid (negatedefstmt));\n@@ -4217,8 +4216,7 @@ repropagate_negates (void)\n \t      tree b = gimple_assign_rhs2 (user);\n \t      gimple_stmt_iterator gsi = gsi_for_stmt (feed);\n \t      gimple_stmt_iterator gsi2 = gsi_for_stmt (user);\n-\t      tree x = make_ssa_name (TREE_TYPE (gimple_assign_lhs (feed)),\n-\t\t\t\t      NULL);\n+\t      tree x = make_ssa_name (TREE_TYPE (gimple_assign_lhs (feed)));\n \t      gimple g = gimple_build_assign_with_ops (PLUS_EXPR, x, a, b);\n \t      gsi_insert_before (&gsi2, g, GSI_SAME_STMT);\n \t      gimple_assign_set_rhs_with_ops (&gsi2, NEGATE_EXPR, x);"}, {"sha": "0b7673ba0d153d21c8f5fbdf25163de0e85769bc", "filename": "gcc/tree-ssa-strlen.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b731b39027f635f0afa97010e803212c1133ee55/gcc%2Ftree-ssa-strlen.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b731b39027f635f0afa97010e803212c1133ee55/gcc%2Ftree-ssa-strlen.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-strlen.c?ref=b731b39027f635f0afa97010e803212c1133ee55", "patch": "@@ -468,7 +468,7 @@ get_string_length (strinfo si)\n \t  lenstmt\n \t    = gimple_build_assign_with_ops\n \t        (POINTER_PLUS_EXPR,\n-\t\t make_ssa_name (TREE_TYPE (gimple_call_arg (stmt, 0)), NULL),\n+\t\t make_ssa_name (TREE_TYPE (gimple_call_arg (stmt, 0))),\n \t\t tem, lhs);\n \t  gsi_insert_before (&gsi, lenstmt, GSI_SAME_STMT);\n \t  gimple_call_set_arg (stmt, 0, gimple_assign_lhs (lenstmt));"}, {"sha": "0623cf18e2cb3c497265d8c06c671e3febc3df01", "filename": "gcc/tree-ssanames.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b731b39027f635f0afa97010e803212c1133ee55/gcc%2Ftree-ssanames.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b731b39027f635f0afa97010e803212c1133ee55/gcc%2Ftree-ssanames.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssanames.h?ref=b731b39027f635f0afa97010e803212c1133ee55", "patch": "@@ -102,7 +102,7 @@ extern void replace_ssa_name_symbol (tree, tree);\n    in function cfun.  */\n \n static inline tree\n-make_ssa_name (tree var, gimple stmt)\n+make_ssa_name (tree var, gimple stmt = NULL)\n {\n   return make_ssa_name_fn (cfun, var, stmt);\n }\n@@ -111,7 +111,7 @@ make_ssa_name (tree var, gimple stmt)\n    statement STMT in function cfun.  */\n \n static inline tree\n-copy_ssa_name (tree var, gimple stmt)\n+copy_ssa_name (tree var, gimple stmt = NULL)\n {\n   return copy_ssa_name_fn (cfun, var, stmt);\n }"}, {"sha": "eb5fbebd693a48a212944049c15230b6b04376d3", "filename": "gcc/tree-switch-conversion.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b731b39027f635f0afa97010e803212c1133ee55/gcc%2Ftree-switch-conversion.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b731b39027f635f0afa97010e803212c1133ee55/gcc%2Ftree-switch-conversion.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-switch-conversion.c?ref=b731b39027f635f0afa97010e803212c1133ee55", "patch": "@@ -444,7 +444,7 @@ emit_case_bit_tests (gswitch *swtch, tree index_expr,\n     }\n \n   /* csui = (1 << (word_mode) idx) */\n-  csui = make_ssa_name (word_type_node, NULL);\n+  csui = make_ssa_name (word_type_node);\n   tmp = fold_build2 (LSHIFT_EXPR, word_type_node, word_mode_one,\n \t\t     fold_convert (word_type_node, idx));\n   tmp = force_gimple_operand_gsi (&gsi, tmp,\n@@ -1047,7 +1047,7 @@ build_one_array (gswitch *swtch, int num, tree arr_index_type,\n \n   gcc_assert (info->default_values[num]);\n \n-  name = copy_ssa_name (PHI_RESULT (phi), NULL);\n+  name = copy_ssa_name (PHI_RESULT (phi));\n   info->target_inbound_names[num] = name;\n \n   cst = constructor_contains_same_values_p (info->constructors[num]);\n@@ -1123,7 +1123,7 @@ build_arrays (gswitch *swtch, struct switch_conv_info *info)\n     utype = lang_hooks.types.type_for_mode (TYPE_MODE (utype), 1);\n \n   arr_index_type = build_index_type (info->range_size);\n-  tidx = make_ssa_name (utype, NULL);\n+  tidx = make_ssa_name (utype);\n   sub = fold_build2_loc (loc, MINUS_EXPR, utype,\n \t\t\t fold_convert_loc (loc, utype, info->index_expr),\n \t\t\t fold_convert_loc (loc, utype, info->range_min));\n@@ -1151,7 +1151,7 @@ gen_def_assigns (gimple_stmt_iterator *gsi, struct switch_conv_info *info)\n \n   for (i = 0; i < info->phi_count; i++)\n     {\n-      tree name = copy_ssa_name (info->target_inbound_names[i], NULL);\n+      tree name = copy_ssa_name (info->target_inbound_names[i]);\n       info->target_outbound_names[i] = name;\n       assign = gimple_build_assign (name, info->default_values[i]);\n       gsi_insert_before (gsi, assign, GSI_SAME_STMT);"}, {"sha": "3a04b2558b0252347ce05144220dc1e598378202", "filename": "gcc/tree-tailcall.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b731b39027f635f0afa97010e803212c1133ee55/gcc%2Ftree-tailcall.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b731b39027f635f0afa97010e803212c1133ee55/gcc%2Ftree-tailcall.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-tailcall.c?ref=b731b39027f635f0afa97010e803212c1133ee55", "patch": "@@ -694,7 +694,7 @@ update_accumulator_with_ops (enum tree_code code, tree acc, tree op1,\n \t\t\t     gimple_stmt_iterator gsi)\n {\n   gassign *stmt;\n-  tree var = copy_ssa_name (acc, NULL);\n+  tree var = copy_ssa_name (acc);\n   if (types_compatible_p (TREE_TYPE (acc), TREE_TYPE (op1)))\n     stmt = gimple_build_assign_with_ops (code, var, acc, op1);\n   else"}, {"sha": "4ed9bb14dc4a10f42d90a242542186b72f57c421", "filename": "gcc/tree-vect-data-refs.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b731b39027f635f0afa97010e803212c1133ee55/gcc%2Ftree-vect-data-refs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b731b39027f635f0afa97010e803212c1133ee55/gcc%2Ftree-vect-data-refs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-data-refs.c?ref=b731b39027f635f0afa97010e803212c1133ee55", "patch": "@@ -4347,7 +4347,7 @@ bump_vector_ptr (tree dataref_ptr, gimple ptr_incr, gimple_stmt_iterator *gsi,\n   if (bump)\n     update = bump;\n \n-  new_dataref_ptr = copy_ssa_name (dataref_ptr, NULL);\n+  new_dataref_ptr = copy_ssa_name (dataref_ptr);\n   incr_stmt = gimple_build_assign_with_ops (POINTER_PLUS_EXPR, new_dataref_ptr,\n \t\t\t\t\t    dataref_ptr, update);\n   vect_finish_stmt_generation (stmt, incr_stmt, gsi);\n@@ -4879,7 +4879,7 @@ vect_setup_realignment (gimple stmt, gimple_stmt_iterator *gsi,\n       ptr = vect_create_data_ref_ptr (stmt, vectype, loop_for_initial_load,\n \t\t\t\t      NULL_TREE, &init_addr, NULL, &inc,\n \t\t\t\t      true, &inv_p);\n-      new_temp = copy_ssa_name (ptr, NULL);\n+      new_temp = copy_ssa_name (ptr);\n       new_stmt = gimple_build_assign_with_ops\n \t\t   (BIT_AND_EXPR, new_temp, ptr,\n \t\t    build_int_cst (TREE_TYPE (ptr),\n@@ -4967,7 +4967,7 @@ vect_setup_realignment (gimple stmt, gimple_stmt_iterator *gsi,\n \n   pe = loop_preheader_edge (containing_loop);\n   vec_dest = vect_create_destination_var (scalar_dest, vectype);\n-  msq = make_ssa_name (vec_dest, NULL);\n+  msq = make_ssa_name (vec_dest);\n   phi_stmt = create_phi_node (msq, containing_loop->header);\n   add_phi_arg (phi_stmt, msq_init, pe, UNKNOWN_LOCATION);\n "}, {"sha": "9757a613e632117498f1f0268c15564992bb1be0", "filename": "gcc/tree-vect-generic.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b731b39027f635f0afa97010e803212c1133ee55/gcc%2Ftree-vect-generic.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b731b39027f635f0afa97010e803212c1133ee55/gcc%2Ftree-vect-generic.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-generic.c?ref=b731b39027f635f0afa97010e803212c1133ee55", "patch": "@@ -639,7 +639,7 @@ expand_vector_divmod (gimple_stmt_iterator *gsi, tree type, tree op0,\n \t\t\t\t\t((unsigned HOST_WIDE_INT) 1\n \t\t\t\t\t << shifts[i]) - 1);\n \t      cst = build_vector (type, vec);\n-\t      addend = make_ssa_name (type, NULL);\n+\t      addend = make_ssa_name (type);\n \t      stmt = gimple_build_assign_with_ops (VEC_COND_EXPR, addend,\n \t\t\t\t\t\t   cond, cst, zero);\n \t      gsi_insert_before (gsi, stmt, GSI_SAME_STMT);\n@@ -1080,7 +1080,7 @@ optimize_vector_constructor (gimple_stmt_iterator *gsi)\n     }\n   for (i = 0; i < nelts; i++)\n     CONSTRUCTOR_ELT (rhs, i)->value = base;\n-  g = gimple_build_assign (make_ssa_name (type, NULL), rhs);\n+  g = gimple_build_assign (make_ssa_name (type), rhs);\n   gsi_insert_before (gsi, g, GSI_SAME_STMT);\n   g = gimple_build_assign_with_ops (PLUS_EXPR, lhs, gimple_assign_lhs (g),\n \t\t\t\t    build_vector (type, cst));"}, {"sha": "57d2b346a67dab8d57a417b9a29fa50e08a0f7fa", "filename": "gcc/tree-vect-loop-manip.c", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b731b39027f635f0afa97010e803212c1133ee55/gcc%2Ftree-vect-loop-manip.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b731b39027f635f0afa97010e803212c1133ee55/gcc%2Ftree-vect-loop-manip.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-loop-manip.c?ref=b731b39027f635f0afa97010e803212c1133ee55", "patch": "@@ -432,7 +432,7 @@ slpeel_update_phi_nodes_for_guard1 (edge guard_edge, struct loop *loop,\n       /** 1. Handle new-merge-point phis  **/\n \n       /* 1.1. Generate new phi node in NEW_MERGE_BB:  */\n-      new_res = copy_ssa_name (PHI_RESULT (orig_phi), NULL);\n+      new_res = copy_ssa_name (PHI_RESULT (orig_phi));\n       new_phi = create_phi_node (new_res, new_merge_bb);\n \n       /* 1.2. NEW_MERGE_BB has two incoming edges: GUARD_EDGE and the exit-edge\n@@ -462,7 +462,7 @@ slpeel_update_phi_nodes_for_guard1 (edge guard_edge, struct loop *loop,\n \tcontinue;\n \n       /* 2.1. Generate new phi node in NEW_EXIT_BB:  */\n-      new_res = copy_ssa_name (PHI_RESULT (orig_phi), NULL);\n+      new_res = copy_ssa_name (PHI_RESULT (orig_phi));\n       new_phi = create_phi_node (new_res, *new_exit_bb);\n \n       /* 2.2. NEW_EXIT_BB has one incoming edge: the exit-edge of the loop.  */\n@@ -576,7 +576,7 @@ slpeel_update_phi_nodes_for_guard2 (edge guard_edge, struct loop *loop,\n       /** 1. Handle new-merge-point phis  **/\n \n       /* 1.1. Generate new phi node in NEW_MERGE_BB:  */\n-      new_res = copy_ssa_name (PHI_RESULT (orig_phi), NULL);\n+      new_res = copy_ssa_name (PHI_RESULT (orig_phi));\n       new_phi = create_phi_node (new_res, new_merge_bb);\n \n       /* 1.2. NEW_MERGE_BB has two incoming edges: GUARD_EDGE and the exit-edge\n@@ -618,7 +618,7 @@ slpeel_update_phi_nodes_for_guard2 (edge guard_edge, struct loop *loop,\n       /** 2. Handle loop-closed-ssa-form phis  **/\n \n       /* 2.1. Generate new phi node in NEW_EXIT_BB:  */\n-      new_res = copy_ssa_name (PHI_RESULT (orig_phi), NULL);\n+      new_res = copy_ssa_name (PHI_RESULT (orig_phi));\n       new_phi = create_phi_node (new_res, *new_exit_bb);\n \n       /* 2.2. NEW_EXIT_BB has one incoming edge: the exit-edge of the loop.  */\n@@ -653,7 +653,7 @@ slpeel_update_phi_nodes_for_guard2 (edge guard_edge, struct loop *loop,\n       arg = guard_arg;\n \n       /* 3.2. Generate new phi node in GUARD_BB:  */\n-      new_res = copy_ssa_name (PHI_RESULT (orig_phi), NULL);\n+      new_res = copy_ssa_name (PHI_RESULT (orig_phi));\n       new_phi = create_phi_node (new_res, guard_edge->src);\n \n       /* 3.3. GUARD_BB has one incoming edge:  */\n@@ -1224,7 +1224,7 @@ slpeel_tree_peel_loop_to_edge (struct loop *loop, struct loop *scalar_loop,\n \t    break;\n \tif (gsi_end_p (gsi))\n \t  {\n-\t    tree new_vop = copy_ssa_name (PHI_RESULT (phi), NULL);\n+\t    tree new_vop = copy_ssa_name (PHI_RESULT (phi));\n \t    gphi *new_phi = create_phi_node (new_vop, exit_e->dest);\n \t    tree vop = PHI_ARG_DEF_FROM_EDGE (phi, EDGE_SUCC (loop->latch, 0));\n \t    imm_use_iterator imm_iter;\n@@ -2439,7 +2439,7 @@ vect_loop_versioning (loop_vec_info loop_vinfo,\n \t{\n \t  tree new_res;\n \t  orig_phi = gsi.phi ();\n-\t  new_res = copy_ssa_name (PHI_RESULT (orig_phi), NULL);\n+\t  new_res = copy_ssa_name (PHI_RESULT (orig_phi));\n \t  new_phi = create_phi_node (new_res, new_exit_bb);\n \t  arg = PHI_ARG_DEF_FROM_EDGE (orig_phi, e);\n \t  add_phi_arg (new_phi, arg, new_exit_e,"}, {"sha": "94feea068bc2a9a9ab74f1ae5a9e8d04b3167ee7", "filename": "gcc/tree-vect-loop.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b731b39027f635f0afa97010e803212c1133ee55/gcc%2Ftree-vect-loop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b731b39027f635f0afa97010e803212c1133ee55/gcc%2Ftree-vect-loop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-loop.c?ref=b731b39027f635f0afa97010e803212c1133ee55", "patch": "@@ -2502,7 +2502,7 @@ vect_is_simple_reduction_1 (loop_vec_info loop_info, gimple phi,\n   if (orig_code == MINUS_EXPR)\n     {\n       tree rhs = gimple_assign_rhs2 (def_stmt);\n-      tree negrhs = make_ssa_name (TREE_TYPE (rhs), NULL);\n+      tree negrhs = make_ssa_name (TREE_TYPE (rhs));\n       gimple negate_stmt = gimple_build_assign_with_ops (NEGATE_EXPR, negrhs,\n \t\t\t\t\t\t\t rhs);\n       gimple_stmt_iterator gsi = gsi_for_stmt (def_stmt);\n@@ -4074,7 +4074,7 @@ vect_create_epilog_for_reduction (vec<tree> vect_defs, gimple stmt,\n     {\n       for (j = 0; j < ncopies; j++)\n         {\n-\t  tree new_def = copy_ssa_name (def, NULL);\n+\t  tree new_def = copy_ssa_name (def);\n           phi = create_phi_node (new_def, exit_bb);\n           set_vinfo_for_stmt (phi, new_stmt_vec_info (phi, loop_vinfo, NULL));\n           if (j == 0)\n@@ -4099,7 +4099,7 @@ vect_create_epilog_for_reduction (vec<tree> vect_defs, gimple stmt,\n       inner_phis.create (vect_defs.length ());\n       FOR_EACH_VEC_ELT (new_phis, i, phi)\n \t{\n-\t  tree new_result = copy_ssa_name (PHI_RESULT (phi), NULL);\n+\t  tree new_result = copy_ssa_name (PHI_RESULT (phi));\n \t  gphi *outer_phi = create_phi_node (new_result, exit_bb);\n \t  SET_PHI_ARG_DEF (outer_phi, single_exit (loop)->dest_idx,\n \t\t\t   PHI_RESULT (phi));\n@@ -4111,7 +4111,7 @@ vect_create_epilog_for_reduction (vec<tree> vect_defs, gimple stmt,\n           while (STMT_VINFO_RELATED_STMT (vinfo_for_stmt (phi)))\n             {\n \t      phi = STMT_VINFO_RELATED_STMT (vinfo_for_stmt (phi));\n-\t      new_result = copy_ssa_name (PHI_RESULT (phi), NULL);\n+\t      new_result = copy_ssa_name (PHI_RESULT (phi));\n \t      outer_phi = create_phi_node (new_result, exit_bb);\n \t      SET_PHI_ARG_DEF (outer_phi, single_exit (loop)->dest_idx,\n \t\t\t       PHI_RESULT (phi));"}, {"sha": "d97008f701449a994a87fd09eda8f4fc09d6483d", "filename": "gcc/tree-vect-patterns.c", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b731b39027f635f0afa97010e803212c1133ee55/gcc%2Ftree-vect-patterns.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b731b39027f635f0afa97010e803212c1133ee55/gcc%2Ftree-vect-patterns.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-patterns.c?ref=b731b39027f635f0afa97010e803212c1133ee55", "patch": "@@ -759,7 +759,7 @@ vect_handle_widen_op_by_const (gimple stmt, enum tree_code code,\n     {\n       /* Create a_T = (NEW_TYPE) a_t;  */\n       *oprnd = gimple_assign_rhs1 (def_stmt);\n-      new_oprnd = make_ssa_name (new_type, NULL);\n+      new_oprnd = make_ssa_name (new_type);\n       new_stmt = gimple_build_assign_with_ops (NOP_EXPR, new_oprnd, *oprnd);\n       STMT_VINFO_RELATED_STMT (vinfo_for_stmt (def_stmt)) = new_stmt;\n       stmts->safe_push (def_stmt);\n@@ -932,7 +932,7 @@ vect_recog_widen_mult_pattern (vec<gimple> *stmts,\n \t}\n \n         tree old_oprnd = gimple_assign_rhs1 (def_stmt);\n-        tree new_oprnd = make_ssa_name (half_type0, NULL);\n+\ttree new_oprnd = make_ssa_name (half_type0);\n         new_stmt = gimple_build_assign_with_ops (NOP_EXPR, new_oprnd,\n \t\t\t\t\t\t old_oprnd);\n         *oprnd = new_oprnd;\n@@ -1439,7 +1439,7 @@ vect_operation_fits_smaller_type (gimple stmt, tree def, tree *new_type,\n             {\n               /* Create NEW_OPRND = (INTERM_TYPE) OPRND.  */\n               oprnd = gimple_assign_rhs1 (def_stmt);\n-              new_oprnd = make_ssa_name (interm_type, NULL);\n+\t      new_oprnd = make_ssa_name (interm_type);\n               new_stmt = gimple_build_assign_with_ops (NOP_EXPR, new_oprnd,\n \t\t\t\t\t\t       oprnd);\n               STMT_VINFO_RELATED_STMT (vinfo_for_stmt (def_stmt)) = new_stmt;\n@@ -1458,7 +1458,7 @@ vect_operation_fits_smaller_type (gimple stmt, tree def, tree *new_type,\n       if (interm_type)\n         {\n           /* Create a type conversion HALF_TYPE->INTERM_TYPE.  */\n-          new_oprnd = make_ssa_name (interm_type, NULL);\n+\t  new_oprnd = make_ssa_name (interm_type);\n           new_stmt = gimple_build_assign_with_ops (NOP_EXPR, new_oprnd,\n \t\t\t\t\t\t   oprnd);\n           oprnd = new_oprnd;\n@@ -1590,7 +1590,7 @@ vect_recog_over_widening_pattern (vec<gimple> *stmts,\n           || TYPE_PRECISION (new_type) != TYPE_PRECISION (use_type))\n         {\n           /* Create NEW_TYPE->USE_TYPE conversion.  */\n-          new_oprnd = make_ssa_name (use_type, NULL);\n+\t  new_oprnd = make_ssa_name (use_type);\n           pattern_stmt = gimple_build_assign_with_ops (NOP_EXPR, new_oprnd,\n \t\t\t\t\t\t       var);\n           STMT_VINFO_RELATED_STMT (vinfo_for_stmt (use_stmt)) = pattern_stmt;"}, {"sha": "4c1b74247b6f1acbe78e4a032f3b30068702b837", "filename": "gcc/tree-vect-slp.c", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b731b39027f635f0afa97010e803212c1133ee55/gcc%2Ftree-vect-slp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b731b39027f635f0afa97010e803212c1133ee55/gcc%2Ftree-vect-slp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-slp.c?ref=b731b39027f635f0afa97010e803212c1133ee55", "patch": "@@ -2669,8 +2669,7 @@ vect_get_constant_vectors (tree op, slp_tree slp_node,\n \t\t}\n \t      else\n \t\t{\n-\t\t  tree new_temp\n-\t\t    = make_ssa_name (TREE_TYPE (vector_type), NULL);\n+\t\t  tree new_temp = make_ssa_name (TREE_TYPE (vector_type));\n \t\t  gimple init_stmt;\n \t\t  op = build1 (VIEW_CONVERT_EXPR, TREE_TYPE (vector_type),\n \t\t\t       op);\t\t  "}, {"sha": "09c887c9f437644753bc2f4ad64897213077e75e", "filename": "gcc/tree-vect-stmts.c", "status": "modified", "additions": 26, "deletions": 28, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b731b39027f635f0afa97010e803212c1133ee55/gcc%2Ftree-vect-stmts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b731b39027f635f0afa97010e803212c1133ee55/gcc%2Ftree-vect-stmts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-stmts.c?ref=b731b39027f635f0afa97010e803212c1133ee55", "patch": "@@ -1331,7 +1331,7 @@ vect_init_vector (gimple stmt, tree val, tree type, gimple_stmt_iterator *gsi)\n \t    val = fold_unary (VIEW_CONVERT_EXPR, TREE_TYPE (type), val);\n \t  else\n \t    {\n-\t      new_temp = make_ssa_name (TREE_TYPE (type), NULL);\n+\t      new_temp = make_ssa_name (TREE_TYPE (type));\n \t      init_stmt = gimple_build_assign_with_ops (NOP_EXPR,\n \t\t\t\t\t\t\tnew_temp, val);\n \t      vect_init_vector_1 (stmt, init_stmt, gsi);\n@@ -1966,7 +1966,7 @@ vectorizable_mask_load_store (gimple stmt, gimple_stmt_iterator *gsi,\n \t      gcc_assert (TYPE_VECTOR_SUBPARTS (TREE_TYPE (op))\n \t\t\t  == TYPE_VECTOR_SUBPARTS (idxtype));\n \t      var = vect_get_new_vect_var (idxtype, vect_simple_var, NULL);\n-\t      var = make_ssa_name (var, NULL);\n+\t      var = make_ssa_name (var);\n \t      op = build1 (VIEW_CONVERT_EXPR, idxtype, op);\n \t      new_stmt\n \t\t= gimple_build_assign_with_ops (VIEW_CONVERT_EXPR, var, op);\n@@ -1995,7 +1995,7 @@ vectorizable_mask_load_store (gimple stmt, gimple_stmt_iterator *gsi,\n \t\t\t      == TYPE_VECTOR_SUBPARTS (masktype));\n \t\t  var = vect_get_new_vect_var (masktype, vect_simple_var,\n \t\t\t\t\t       NULL);\n-\t\t  var = make_ssa_name (var, NULL);\n+\t\t  var = make_ssa_name (var);\n \t\t  mask_op = build1 (VIEW_CONVERT_EXPR, masktype, mask_op);\n \t\t  new_stmt\n \t\t    = gimple_build_assign_with_ops (VIEW_CONVERT_EXPR, var,\n@@ -2017,7 +2017,7 @@ vectorizable_mask_load_store (gimple stmt, gimple_stmt_iterator *gsi,\n \t      op = make_ssa_name (var, new_stmt);\n \t      gimple_call_set_lhs (new_stmt, op);\n \t      vect_finish_stmt_generation (stmt, new_stmt, gsi);\n-\t      var = make_ssa_name (vec_dest, NULL);\n+\t      var = make_ssa_name (vec_dest);\n \t      op = build1 (VIEW_CONVERT_EXPR, vectype, op);\n \t      new_stmt\n \t\t= gimple_build_assign_with_ops (VIEW_CONVERT_EXPR, var, op);\n@@ -2158,7 +2158,7 @@ vectorizable_mask_load_store (gimple stmt, gimple_stmt_iterator *gsi,\n \t    = gimple_build_call_internal (IFN_MASK_LOAD, 3, dataref_ptr,\n \t\t\t\t\t  gimple_call_arg (stmt, 1),\n \t\t\t\t\t  vec_mask);\n-\t  gimple_call_set_lhs (new_stmt, make_ssa_name (vec_dest, NULL));\n+\t  gimple_call_set_lhs (new_stmt, make_ssa_name (vec_dest));\n \t  vect_finish_stmt_generation (stmt, new_stmt, gsi);\n \t  if (i == 0)\n \t    STMT_VINFO_VEC_STMT (stmt_info) = *vec_stmt = new_stmt;\n@@ -2467,7 +2467,7 @@ vectorizable_call (gimple gs, gimple_stmt_iterator *gsi, gimple *vec_stmt,\n \t      new_temp = make_ssa_name (new_var, init_stmt);\n \t      gimple_assign_set_lhs (init_stmt, new_temp);\n \t      vect_init_vector_1 (stmt, init_stmt, NULL);\n-\t      new_temp = make_ssa_name (vec_dest, NULL);\n+\t      new_temp = make_ssa_name (vec_dest);\n \t      new_stmt = gimple_build_assign (new_temp,\n \t\t\t\t\t      gimple_assign_lhs (init_stmt));\n \t    }\n@@ -2971,7 +2971,7 @@ vectorizable_simd_clone_call (gimple stmt, gimple_stmt_iterator *gsi,\n \t\t\t\t  size_int (prec),\n \t\t\t\t  bitsize_int ((m & (k - 1)) * prec));\n \t\t      new_stmt\n-\t\t\t= gimple_build_assign (make_ssa_name (atype, NULL),\n+\t\t\t= gimple_build_assign (make_ssa_name (atype),\n \t\t\t\t\t       vec_oprnd0);\n \t\t      vect_finish_stmt_generation (stmt, new_stmt, gsi);\n \t\t      vargs.safe_push (gimple_assign_lhs (new_stmt));\n@@ -3007,7 +3007,7 @@ vectorizable_simd_clone_call (gimple stmt, gimple_stmt_iterator *gsi,\n \t\t\t{\n \t\t\t  vec_oprnd0 = build_constructor (atype, ctor_elts);\n \t\t\t  new_stmt\n-\t\t\t    = gimple_build_assign (make_ssa_name (atype, NULL),\n+\t\t\t    = gimple_build_assign (make_ssa_name (atype),\n \t\t\t\t\t\t   vec_oprnd0);\n \t\t\t  vect_finish_stmt_generation (stmt, new_stmt, gsi);\n \t\t\t  vargs.safe_push (gimple_assign_lhs (new_stmt));\n@@ -3032,7 +3032,7 @@ vectorizable_simd_clone_call (gimple stmt, gimple_stmt_iterator *gsi,\n \t\t      new_bb = gsi_insert_seq_on_edge_immediate (pe, stmts);\n \t\t      gcc_assert (!new_bb);\n \t\t    }\n-\t\t  tree phi_res = copy_ssa_name (op, NULL);\n+\t\t  tree phi_res = copy_ssa_name (op);\n \t\t  gphi *new_phi = create_phi_node (phi_res, loop->header);\n \t\t  set_vinfo_for_stmt (new_phi,\n \t\t\t\t      new_stmt_vec_info (new_phi, loop_vinfo,\n@@ -3048,7 +3048,7 @@ vectorizable_simd_clone_call (gimple stmt, gimple_stmt_iterator *gsi,\n \t\t    = wi::mul (bestn->simdclone->args[i].linear_step,\n \t\t\t       ncopies * nunits);\n \t\t  tree tcst = wide_int_to_tree (type, cst);\n-\t\t  tree phi_arg = copy_ssa_name (op, NULL);\n+\t\t  tree phi_arg = copy_ssa_name (op);\n \t\t  new_stmt = gimple_build_assign_with_ops (code, phi_arg,\n \t\t\t\t\t\t\t   phi_res, tcst);\n \t\t  gimple_stmt_iterator si = gsi_after_labels (loop->header);\n@@ -3072,7 +3072,7 @@ vectorizable_simd_clone_call (gimple stmt, gimple_stmt_iterator *gsi,\n \t\t    = wi::mul (bestn->simdclone->args[i].linear_step,\n \t\t\t       j * nunits);\n \t\t  tree tcst = wide_int_to_tree (type, cst);\n-\t\t  new_temp = make_ssa_name (TREE_TYPE (op), NULL);\n+\t\t  new_temp = make_ssa_name (TREE_TYPE (op));\n \t\t  new_stmt\n \t\t    = gimple_build_assign_with_ops (code, new_temp,\n \t\t\t\t\t\t    arginfo[i].op, tcst);\n@@ -3091,7 +3091,7 @@ vectorizable_simd_clone_call (gimple stmt, gimple_stmt_iterator *gsi,\n \t{\n \t  gcc_assert (ratype || TYPE_VECTOR_SUBPARTS (rtype) == nunits);\n \t  if (ratype)\n-\t    new_temp = create_tmp_var (ratype, NULL);\n+\t    new_temp = create_tmp_var (ratype);\n \t  else if (TYPE_VECTOR_SUBPARTS (vectype)\n \t\t   == TYPE_VECTOR_SUBPARTS (rtype))\n \t    new_temp = make_ssa_name (vec_dest, new_stmt);\n@@ -3123,7 +3123,7 @@ vectorizable_simd_clone_call (gimple stmt, gimple_stmt_iterator *gsi,\n \t\t    t = build3 (BIT_FIELD_REF, vectype, new_temp,\n \t\t\t\tsize_int (prec), bitsize_int (l * prec));\n \t\t  new_stmt\n-\t\t    = gimple_build_assign (make_ssa_name (vectype, NULL), t);\n+\t\t    = gimple_build_assign (make_ssa_name (vectype), t);\n \t\t  vect_finish_stmt_generation (stmt, new_stmt, gsi);\n \t\t  if (j == 0 && l == 0)\n \t\t    STMT_VINFO_VEC_STMT (stmt_info) = *vec_stmt = new_stmt;\n@@ -3157,8 +3157,7 @@ vectorizable_simd_clone_call (gimple stmt, gimple_stmt_iterator *gsi,\n \t\t      tree tem = build4 (ARRAY_REF, rtype, new_temp,\n \t\t\t\t\t size_int (m), NULL_TREE, NULL_TREE);\n \t\t      new_stmt\n-\t\t\t= gimple_build_assign (make_ssa_name (rtype, NULL),\n-\t\t\t\t\t       tem);\n+\t\t\t= gimple_build_assign (make_ssa_name (rtype), tem);\n \t\t      vect_finish_stmt_generation (stmt, new_stmt, gsi);\n \t\t      CONSTRUCTOR_APPEND_ELT (ret_ctor_elts, NULL_TREE,\n \t\t\t\t\t      gimple_assign_lhs (new_stmt));\n@@ -3174,8 +3173,7 @@ vectorizable_simd_clone_call (gimple stmt, gimple_stmt_iterator *gsi,\n \t\tcontinue;\n \t      vec_oprnd0 = build_constructor (vectype, ret_ctor_elts);\n \t      new_stmt\n-\t\t= gimple_build_assign (make_ssa_name (vec_dest, NULL),\n-\t\t\t\t       vec_oprnd0);\n+\t\t= gimple_build_assign (make_ssa_name (vec_dest), vec_oprnd0);\n \t      vect_finish_stmt_generation (stmt, new_stmt, gsi);\n \n \t      if ((unsigned) j == k - 1)\n@@ -3192,7 +3190,7 @@ vectorizable_simd_clone_call (gimple stmt, gimple_stmt_iterator *gsi,\n \t      t = build2 (MEM_REF, vectype, t,\n \t\t\t  build_int_cst (TREE_TYPE (t), 0));\n \t      new_stmt\n-\t\t= gimple_build_assign (make_ssa_name (vec_dest, NULL), t);\n+\t\t= gimple_build_assign (make_ssa_name (vec_dest), t);\n \t      vect_finish_stmt_generation (stmt, new_stmt, gsi);\n \t      tree clobber = build_constructor (ratype, NULL);\n \t      TREE_THIS_VOLATILE (clobber) = 1;\n@@ -3939,7 +3937,7 @@ vectorizable_conversion (gimple stmt, gimple_stmt_iterator *gsi,\n \t\t  else\n \t\t    {\n \t\t      gcc_assert (TREE_CODE_LENGTH (codecvt1) == unary_op);\n-\t\t      new_temp = make_ssa_name (vec_dest, NULL);\n+\t\t      new_temp = make_ssa_name (vec_dest);\n \t\t      new_stmt = gimple_build_assign_with_ops (codecvt1,\n \t\t\t\t\t\t\t       new_temp, vop0);\n \t\t    }\n@@ -3996,7 +3994,7 @@ vectorizable_conversion (gimple stmt, gimple_stmt_iterator *gsi,\n \t\telse\n \t\t  {\n \t\t    gcc_assert (TREE_CODE_LENGTH (codecvt1) == unary_op);\n-\t\t    new_temp = make_ssa_name (vec_dest, NULL);\n+\t\t    new_temp = make_ssa_name (vec_dest);\n \t\t    new_stmt = gimple_build_assign_with_ops (codecvt1, new_temp,\n \t\t\t\t\t\t\t     vop0);\n \t\t  }\n@@ -5465,7 +5463,7 @@ vectorizable_store (gimple stmt, gimple_stmt_iterator *gsi, gimple *vec_stmt,\n \t\t  tree perm_dest \n \t\t    = vect_create_destination_var (gimple_assign_rhs1 (stmt),\n \t\t\t\t\t\t   vectype);\n-\t\t  tree new_temp = make_ssa_name (perm_dest, NULL);\n+\t\t  tree new_temp = make_ssa_name (perm_dest);\n \n \t\t  /* Generate the permute statement.  */\n \t\t  gimple perm_stmt \n@@ -5557,7 +5555,7 @@ permute_vec_elements (tree x, tree y, tree mask_vec, gimple stmt,\n   gimple perm_stmt;\n \n   perm_dest = vect_create_destination_var (gimple_get_lhs (stmt), vectype);\n-  data_ref = make_ssa_name (perm_dest, NULL);\n+  data_ref = make_ssa_name (perm_dest);\n \n   /* Generate the permute statement.  */\n   perm_stmt = gimple_build_assign_with_ops (VEC_PERM_EXPR, data_ref,\n@@ -5993,7 +5991,7 @@ vectorizable_load (gimple stmt, gimple_stmt_iterator *gsi, gimple *vec_stmt,\n \t      gcc_assert (TYPE_VECTOR_SUBPARTS (TREE_TYPE (op))\n \t\t\t  == TYPE_VECTOR_SUBPARTS (idxtype));\n \t      var = vect_get_new_vect_var (idxtype, vect_simple_var, NULL);\n-\t      var = make_ssa_name (var, NULL);\n+\t      var = make_ssa_name (var);\n \t      op = build1 (VIEW_CONVERT_EXPR, idxtype, op);\n \t      new_stmt\n \t\t= gimple_build_assign_with_ops (VIEW_CONVERT_EXPR, var, op);\n@@ -6012,7 +6010,7 @@ vectorizable_load (gimple stmt, gimple_stmt_iterator *gsi, gimple *vec_stmt,\n \t      op = make_ssa_name (var, new_stmt);\n \t      gimple_call_set_lhs (new_stmt, op);\n \t      vect_finish_stmt_generation (stmt, new_stmt, gsi);\n-\t      var = make_ssa_name (vec_dest, NULL);\n+\t      var = make_ssa_name (vec_dest);\n \t      op = build1 (VIEW_CONVERT_EXPR, vectype, op);\n \t      new_stmt\n \t\t= gimple_build_assign_with_ops (VIEW_CONVERT_EXPR, var, op);\n@@ -6118,7 +6116,7 @@ vectorizable_load (gimple stmt, gimple_stmt_iterator *gsi, gimple *vec_stmt,\n \t\t\t\t\t\t NULL_TREE, true,\n \t\t\t\t\t\t GSI_SAME_STMT);\n \t      CONSTRUCTOR_APPEND_ELT (v, NULL_TREE, newref);\n-\t      newoff = copy_ssa_name (running_off, NULL);\n+\t      newoff = copy_ssa_name (running_off);\n \t      incr = gimple_build_assign_with_ops (POINTER_PLUS_EXPR, newoff,\n \t\t\t\t\t\t   running_off, stride_step);\n \t      vect_finish_stmt_generation (stmt, incr, gsi);\n@@ -6457,7 +6455,7 @@ vectorizable_load (gimple stmt, gimple_stmt_iterator *gsi, gimple *vec_stmt,\n \t\t\t\t\t\t    dr_explicit_realign,\n \t\t\t\t\t\t    dataref_ptr, NULL);\n \n-\t\t    ptr = copy_ssa_name (dataref_ptr, NULL);\n+\t\t    ptr = copy_ssa_name (dataref_ptr);\n \t\t    new_stmt = gimple_build_assign_with_ops\n \t\t\t\t (BIT_AND_EXPR, ptr, dataref_ptr,\n \t\t\t\t  build_int_cst\n@@ -6496,7 +6494,7 @@ vectorizable_load (gimple stmt, gimple_stmt_iterator *gsi, gimple *vec_stmt,\n \t\t    break;\n \t\t  }\n \t\tcase dr_explicit_realign_optimized:\n-\t\t  new_temp = copy_ssa_name (dataref_ptr, NULL);\n+\t\t  new_temp = copy_ssa_name (dataref_ptr);\n \t\t  new_stmt = gimple_build_assign_with_ops\n \t\t\t       (BIT_AND_EXPR, new_temp, dataref_ptr,\n \t\t\t\tbuild_int_cst\n@@ -6566,7 +6564,7 @@ vectorizable_load (gimple stmt, gimple_stmt_iterator *gsi, gimple *vec_stmt,\n \t\t\t  dump_gimple_stmt (MSG_NOTE, TDF_SLIM, stmt, 0);\n \t\t\t  dump_printf (MSG_NOTE, \"\\n\");\n \t\t\t}\n-\t\t      tree tem = copy_ssa_name (scalar_dest, NULL);\n+\t\t      tree tem = copy_ssa_name (scalar_dest);\n \t\t      gsi_insert_on_edge_immediate\n \t\t\t(loop_preheader_edge (loop),\n \t\t\t gimple_build_assign (tem,"}, {"sha": "f3dbc508429fedfb8c53e071cda2febde9906461", "filename": "gcc/tree-vrp.c", "status": "modified", "additions": 6, "deletions": 7, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b731b39027f635f0afa97010e803212c1133ee55/gcc%2Ftree-vrp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b731b39027f635f0afa97010e803212c1133ee55/gcc%2Ftree-vrp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vrp.c?ref=b731b39027f635f0afa97010e803212c1133ee55", "patch": "@@ -8966,7 +8966,7 @@ simplify_truth_ops_using_ranges (gimple_stmt_iterator *gsi, gimple stmt)\n   /* For A != B we substitute A ^ B.  Either with conversion.  */\n   else if (need_conversion)\n     {\n-      tree tem = make_ssa_name (TREE_TYPE (op0), NULL);\n+      tree tem = make_ssa_name (TREE_TYPE (op0));\n       gassign *newop\n \t= gimple_build_assign_with_ops (BIT_XOR_EXPR, tem, op0, op1);\n       gsi_insert_before (gsi, newop, GSI_SAME_STMT);\n@@ -9734,7 +9734,7 @@ simplify_float_conversion_using_ranges (gimple_stmt_iterator *gsi, gimple stmt)\n   /* It works, insert a truncation or sign-change before the\n      float conversion.  */\n   tem = make_ssa_name (build_nonstandard_integer_type\n-\t\t\t  (GET_MODE_PRECISION (mode), 0), NULL);\n+\t\t\t  (GET_MODE_PRECISION (mode), 0));\n   conv = gimple_build_assign_with_ops (NOP_EXPR, tem, rhs1);\n   gsi_insert_before (gsi, conv, GSI_SAME_STMT);\n   gimple_assign_set_rhs1 (stmt, tem);\n@@ -9809,7 +9809,7 @@ simplify_internal_call_using_ranges (gimple_stmt_iterator *gsi, gimple stmt)\n       else if (!useless_type_conversion_p (utype, TREE_TYPE (op0)))\n \t{\n \t  g = gimple_build_assign_with_ops (NOP_EXPR,\n-\t\t\t\t\t    make_ssa_name (utype, NULL), op0);\n+\t\t\t\t\t    make_ssa_name (utype), op0);\n \t  gimple_set_location (g, loc);\n \t  gsi_insert_before (gsi, g, GSI_SAME_STMT);\n \t  op0 = gimple_assign_lhs (g);\n@@ -9819,19 +9819,18 @@ simplify_internal_call_using_ranges (gimple_stmt_iterator *gsi, gimple stmt)\n       else if (!useless_type_conversion_p (utype, TREE_TYPE (op1)))\n \t{\n \t  g = gimple_build_assign_with_ops (NOP_EXPR,\n-\t\t\t\t\t    make_ssa_name (utype, NULL), op1);\n+\t\t\t\t\t    make_ssa_name (utype), op1);\n \t  gimple_set_location (g, loc);\n \t  gsi_insert_before (gsi, g, GSI_SAME_STMT);\n \t  op1 = gimple_assign_lhs (g);\n \t}\n-      g = gimple_build_assign_with_ops (subcode, make_ssa_name (utype, NULL),\n+      g = gimple_build_assign_with_ops (subcode, make_ssa_name (utype),\n \t\t\t\t\top0, op1);\n       gimple_set_location (g, loc);\n       gsi_insert_before (gsi, g, GSI_SAME_STMT);\n       if (utype != type)\n \t{\n-\t  g = gimple_build_assign_with_ops (NOP_EXPR,\n-\t\t\t\t\t    make_ssa_name (type, NULL),\n+\t  g = gimple_build_assign_with_ops (NOP_EXPR, make_ssa_name (type),\n \t\t\t\t\t    gimple_assign_lhs (g));\n \t  gimple_set_location (g, loc);\n \t  gsi_insert_before (gsi, g, GSI_SAME_STMT);"}, {"sha": "18b4d92b81892e4cf681e2167c051815b037e678", "filename": "gcc/tsan.c", "status": "modified", "additions": 8, "deletions": 12, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b731b39027f635f0afa97010e803212c1133ee55/gcc%2Ftsan.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b731b39027f635f0afa97010e803212c1133ee55/gcc%2Ftsan.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftsan.c?ref=b731b39027f635f0afa97010e803212c1133ee55", "patch": "@@ -168,8 +168,7 @@ instrument_expr (gimple_stmt_iterator gsi, tree expr, bool is_write)\n   seq = NULL;\n   if (!is_gimple_val (expr_ptr))\n     {\n-      g = gimple_build_assign (make_ssa_name (TREE_TYPE (expr_ptr), NULL),\n-\t\t\t       expr_ptr);\n+      g = gimple_build_assign (make_ssa_name (TREE_TYPE (expr_ptr)), expr_ptr);\n       expr_ptr = gimple_assign_lhs (g);\n       gimple_set_location (g, loc);\n       gimple_seq_add_stmt_without_update (&seq, g);\n@@ -500,17 +499,16 @@ instrument_builtin_call (gimple_stmt_iterator *gsi)\n \t\tif (!useless_type_conversion_p (TREE_TYPE (lhs),\n \t\t\t\t\t\tTREE_TYPE (args[1])))\n \t\t  {\n-\t\t    tree var = make_ssa_name (TREE_TYPE (lhs), NULL);\n+\t\t    tree var = make_ssa_name (TREE_TYPE (lhs));\n \t\t    g = gimple_build_assign_with_ops (NOP_EXPR, var, args[1]);\n \t\t    gsi_insert_after (gsi, g, GSI_NEW_STMT);\n \t\t    args[1] = var;\n \t\t  }\n-\t\tgimple_call_set_lhs (stmt,\n-\t\t\t\t     make_ssa_name (TREE_TYPE (lhs), NULL));\n+\t\tgimple_call_set_lhs (stmt, make_ssa_name (TREE_TYPE (lhs)));\n \t\t/* BIT_NOT_EXPR stands for NAND.  */\n \t\tif (tsan_atomic_table[i].code == BIT_NOT_EXPR)\n \t\t  {\n-\t\t    tree var = make_ssa_name (TREE_TYPE (lhs), NULL);\n+\t\t    tree var = make_ssa_name (TREE_TYPE (lhs));\n \t\t    g = gimple_build_assign_with_ops (BIT_AND_EXPR, var,\n \t\t\t\t\t\t      gimple_call_lhs (stmt),\n \t\t\t\t\t\t      args[1]);\n@@ -550,14 +548,13 @@ instrument_builtin_call (gimple_stmt_iterator *gsi)\n \t      args[j] = gimple_call_arg (stmt, j);\n \t    t = TYPE_ARG_TYPES (TREE_TYPE (decl));\n \t    t = TREE_VALUE (TREE_CHAIN (TREE_CHAIN (t)));\n-\t    t = create_tmp_var (t, NULL);\n+\t    t = create_tmp_var (t);\n \t    mark_addressable (t);\n \t    if (!useless_type_conversion_p (TREE_TYPE (t),\n \t\t\t\t\t    TREE_TYPE (args[1])))\n \t      {\n \t\tg = gimple_build_assign_with_ops (NOP_EXPR,\n-\t\t\t\t\t\t  make_ssa_name (TREE_TYPE (t),\n-\t\t\t\t\t\t\t\t NULL),\n+\t\t\t\t\t\t  make_ssa_name (TREE_TYPE (t)),\n \t\t\t\t\t\t  args[1]);\n \t\tgsi_insert_before (gsi, g, GSI_SAME_STMT);\n \t\targs[1] = gimple_assign_lhs (g);\n@@ -575,8 +572,7 @@ instrument_builtin_call (gimple_stmt_iterator *gsi)\n \t      {\n \t\ttree cond;\n \t\tstmt = gsi_stmt (*gsi);\n-\t\tg = gimple_build_assign (make_ssa_name (TREE_TYPE (t), NULL),\n-\t\t\t\t\t t);\n+\t\tg = gimple_build_assign (make_ssa_name (TREE_TYPE (t)), t);\n \t\tgsi_insert_after (gsi, g, GSI_NEW_STMT);\n \t\tt = make_ssa_name (TREE_TYPE (TREE_TYPE (decl)), stmt);\n \t\tcond = build2 (NE_EXPR, boolean_type_node, t,\n@@ -671,7 +667,7 @@ instrument_func_entry (void)\n \n   builtin_decl = builtin_decl_implicit (BUILT_IN_RETURN_ADDRESS);\n   g = gimple_build_call (builtin_decl, 1, integer_zero_node);\n-  ret_addr = make_ssa_name (ptr_type_node, NULL);\n+  ret_addr = make_ssa_name (ptr_type_node);\n   gimple_call_set_lhs (g, ret_addr);\n   gimple_set_location (g, cfun->function_start_locus);\n   gsi_insert_before (&gsi, g, GSI_SAME_STMT);"}, {"sha": "ea5ccb432ec22d98d36abe6c2412005a6a064f2b", "filename": "gcc/ubsan.c", "status": "modified", "additions": 9, "deletions": 12, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b731b39027f635f0afa97010e803212c1133ee55/gcc%2Fubsan.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b731b39027f635f0afa97010e803212c1133ee55/gcc%2Fubsan.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fubsan.c?ref=b731b39027f635f0afa97010e803212c1133ee55", "patch": "@@ -172,7 +172,7 @@ ubsan_encode_value (tree t, bool in_expand_p)\n \t{\n \t  /* The reason for this is that we don't want to pessimize\n \t     code by making vars unnecessarily addressable.  */\n-\t  tree var = create_tmp_var (type, NULL);\n+\t  tree var = create_tmp_var (type);\n \t  tree tem = build2 (MODIFY_EXPR, void_type_node, var, t);\n \t  if (in_expand_p)\n \t    {\n@@ -747,7 +747,7 @@ ubsan_expand_null_ifn (gimple_stmt_iterator *gsip)\n       unsigned int ptralign = get_pointer_alignment (ptr) / BITS_PER_UNIT;\n       if (compare_tree_int (align, ptralign) == 1)\n \t{\n-\t  check_align = make_ssa_name (pointer_sized_int_node, NULL);\n+\t  check_align = make_ssa_name (pointer_sized_int_node);\n \t  g = gimple_build_assign_with_ops (NOP_EXPR, check_align, ptr);\n \t  gimple_set_location (g, loc);\n \t  gsi_insert_before (&gsi, g, GSI_SAME_STMT);\n@@ -871,8 +871,7 @@ ubsan_expand_null_ifn (gimple_stmt_iterator *gsip)\n       tree mask = build_int_cst (pointer_sized_int_node,\n \t\t\t\t tree_to_uhwi (align) - 1);\n       g = gimple_build_assign_with_ops (BIT_AND_EXPR,\n-\t\t\t\t\tmake_ssa_name (pointer_sized_int_node,\n-\t\t\t\t\t\t       NULL),\n+\t\t\t\t\tmake_ssa_name (pointer_sized_int_node),\n \t\t\t\t\tcheck_align, mask);\n       gimple_set_location (g, loc);\n       if (check_null)\n@@ -944,7 +943,7 @@ ubsan_expand_objsize_ifn (gimple_stmt_iterator *gsi)\n \t    = (flag_sanitize_recover & SANITIZE_OBJECT_SIZE)\n \t      ? BUILT_IN_UBSAN_HANDLE_TYPE_MISMATCH\n \t      : BUILT_IN_UBSAN_HANDLE_TYPE_MISMATCH_ABORT;\n-\t  tree p = make_ssa_name (pointer_sized_int_node, NULL);\n+\t  tree p = make_ssa_name (pointer_sized_int_node);\n \t  g = gimple_build_assign_with_ops (NOP_EXPR, p, ptr);\n \t  gimple_set_location (g, loc);\n \t  gsi_insert_before (gsi, g, GSI_SAME_STMT);\n@@ -1113,7 +1112,7 @@ instrument_si_overflow (gimple_stmt_iterator gsi)\n       a = build_int_cst (lhstype, 0);\n       b = gimple_assign_rhs1 (stmt);\n       g = gimple_build_call_internal (IFN_UBSAN_CHECK_SUB, 2, a, b);\n-      a = make_ssa_name (lhstype, NULL);\n+      a = make_ssa_name (lhstype);\n       gimple_call_set_lhs (g, a);\n       gimple_set_location (g, gimple_location (stmt));\n       gsi_insert_before (&gsi, g, GSI_SAME_STMT);\n@@ -1176,13 +1175,13 @@ instrument_bool_enum_load (gimple_stmt_iterator *gsi)\n   tree lhs = gimple_assign_lhs (stmt);\n   tree ptype = build_pointer_type (TREE_TYPE (rhs));\n   tree atype = reference_alias_ptr_type (rhs);\n-  gimple g = gimple_build_assign (make_ssa_name (ptype, NULL),\n+  gimple g = gimple_build_assign (make_ssa_name (ptype),\n \t\t\t\t  build_fold_addr_expr (rhs));\n   gimple_set_location (g, loc);\n   gsi_insert_before (gsi, g, GSI_SAME_STMT);\n   tree mem = build2 (MEM_REF, utype, gimple_assign_lhs (g),\n \t\t     build_int_cst (atype, 0));\n-  tree urhs = make_ssa_name (utype, NULL);\n+  tree urhs = make_ssa_name (utype);\n   if (can_throw)\n     {\n       gimple_assign_set_lhs (stmt, urhs);\n@@ -1205,8 +1204,7 @@ instrument_bool_enum_load (gimple_stmt_iterator *gsi)\n   maxv = fold_convert (utype, maxv);\n   if (!integer_zerop (minv))\n     {\n-      g = gimple_build_assign_with_ops (MINUS_EXPR,\n-\t\t\t\t\tmake_ssa_name (utype, NULL),\n+      g = gimple_build_assign_with_ops (MINUS_EXPR, make_ssa_name (utype),\n \t\t\t\t\turhs, minv);\n       gimple_set_location (g, loc);\n       gsi_insert_before (gsi, g, GSI_SAME_STMT);\n@@ -1399,8 +1397,7 @@ instrument_nonnull_arg (gimple_stmt_iterator *gsi)\n \t  gimple g;\n \t  if (!is_gimple_val (arg))\n \t    {\n-\t      g = gimple_build_assign (make_ssa_name (TREE_TYPE (arg), NULL),\n-\t\t\t\t       arg);\n+\t      g = gimple_build_assign (make_ssa_name (TREE_TYPE (arg)), arg);\n \t      gimple_set_location (g, loc[0]);\n \t      gsi_insert_before (gsi, g, GSI_SAME_STMT);\n \t      arg = gimple_assign_lhs (g);"}, {"sha": "0526b7f195e5d15a0a8c5e522a99d0fdc481bef5", "filename": "gcc/varpool.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b731b39027f635f0afa97010e803212c1133ee55/gcc%2Fvarpool.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b731b39027f635f0afa97010e803212c1133ee55/gcc%2Fvarpool.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvarpool.c?ref=b731b39027f635f0afa97010e803212c1133ee55", "patch": "@@ -752,7 +752,7 @@ add_new_static_var (tree type)\n   tree new_decl;\n   varpool_node *new_node;\n \n-  new_decl = create_tmp_var_raw (type, NULL);\n+  new_decl = create_tmp_var_raw (type);\n   DECL_NAME (new_decl) = create_tmp_var_name (NULL);\n   TREE_READONLY (new_decl) = 0;\n   TREE_STATIC (new_decl) = 1;"}]}