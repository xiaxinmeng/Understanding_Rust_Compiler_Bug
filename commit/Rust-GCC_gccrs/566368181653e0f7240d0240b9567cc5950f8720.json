{"sha": "566368181653e0f7240d0240b9567cc5950f8720", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTY2MzY4MTgxNjUzZTBmNzI0MGQwMjQwYjk1NjdjYzU5NTBmODcyMA==", "commit": {"author": {"name": "Jeffrey A Law", "email": "law@cygnus.com", "date": "1997-11-03T02:26:49Z"}, "committer": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "1997-11-03T02:26:49Z"}, "message": "* arm.c (output_move_double): Allocate 3 entries in otherops array.\n\nFrom-SVN: r16281", "tree": {"sha": "a9c7da63cf4771fcd2d7c4e2c3a91803695e6bee", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a9c7da63cf4771fcd2d7c4e2c3a91803695e6bee"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/566368181653e0f7240d0240b9567cc5950f8720", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/566368181653e0f7240d0240b9567cc5950f8720", "html_url": "https://github.com/Rust-GCC/gccrs/commit/566368181653e0f7240d0240b9567cc5950f8720", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/566368181653e0f7240d0240b9567cc5950f8720/comments", "author": null, "committer": null, "parents": [{"sha": "b9ddcfac31ed5b5b495931e5a8660bc63166dc09", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b9ddcfac31ed5b5b495931e5a8660bc63166dc09", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b9ddcfac31ed5b5b495931e5a8660bc63166dc09"}], "stats": {"total": 187, "additions": 124, "deletions": 63}, "files": [{"sha": "28bc348c9c20ffbae9e79fc0792f0c83f3d5fd17", "filename": "gcc/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/566368181653e0f7240d0240b9567cc5950f8720/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/566368181653e0f7240d0240b9567cc5950f8720/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=566368181653e0f7240d0240b9567cc5950f8720", "patch": "@@ -1,3 +1,7 @@\n+Sun Nov  2 19:27:21 1997  Jeffrey A Law  (law@cygnus.com)\n+\n+\t* arm.c (output_move_double): Allocate 3 entries in otherops array.\n+\n Sat Nov  1 21:43:00 1997  Mike Stump  (mrs@wrs.com)\n \n \t* except.c (expand_ex_region_start_for_decl): Emit EH_REGION_BEG"}, {"sha": "ac433374fa411419eba090ec0764d419a4207633", "filename": "gcc/config/arm/arm.c", "status": "modified", "additions": 120, "deletions": 63, "changes": 183, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/566368181653e0f7240d0240b9567cc5950f8720/gcc%2Fconfig%2Farm%2Farm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/566368181653e0f7240d0240b9567cc5950f8720/gcc%2Fconfig%2Farm%2Farm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.c?ref=566368181653e0f7240d0240b9567cc5950f8720", "patch": "@@ -21,10 +21,10 @@ along with GNU CC; see the file COPYING.  If not, write to\n the Free Software Foundation, 59 Temple Place - Suite 330,\n Boston, MA 02111-1307, USA.  */\n     \n+#include \"config.h\"\n #include <stdio.h>\n #include <string.h>\n #include \"assert.h\"\n-#include \"config.h\"\n #include \"rtl.h\"\n #include \"regs.h\"\n #include \"hard-reg-set.h\"\n@@ -376,7 +376,8 @@ use_return_insn ()\n \n   if (!reload_completed ||current_function_pretend_args_size\n       || current_function_anonymous_args\n-      || (get_frame_size () && !(TARGET_APCS || frame_pointer_needed)))\n+      || ((get_frame_size () + current_function_outgoing_args_size != 0)\n+\t  && !(TARGET_APCS || frame_pointer_needed)))\n     return 0;\n \n   /* Can't be done if interworking with Thumb, and any registers have been\n@@ -407,6 +408,13 @@ const_ok_for_arm (i)\n {\n   unsigned HOST_WIDE_INT mask = ~0xFF;\n \n+  /* For machines with >32 bit HOST_WIDE_INT, the bits above bit 31 must \n+     be all zero, or all one.  */\n+  if ((i & ~(unsigned HOST_WIDE_INT) 0xffffffff) != 0\n+      && ((i & ~(unsigned HOST_WIDE_INT) 0xffffffff) \n+\t  != (((HOST_WIDE_INT) -1) & ~(unsigned HOST_WIDE_INT) 0xffffffff)))\n+    return FALSE;\n+  \n   /* Fast return for 0 and powers of 2 */\n   if ((i & (i - 1)) == 0)\n     return TRUE;\n@@ -1501,6 +1509,17 @@ arm_rtx_costs (x, code, outer_code)\n \t      + (REG_OR_SUBREG_REG (XEXP (x, 0)) ? 0 : 4)\n \t      + (REG_OR_SUBREG_REG (XEXP (x, 1)) ? 0 : 4));\n \n+    case TRUNCATE:\n+      if (arm_fast_multiply && mode == SImode\n+\t  && GET_CODE (XEXP (x, 0)) == LSHIFTRT\n+\t  && GET_CODE (XEXP (XEXP (x, 0), 0)) == MULT\n+\t  && (GET_CODE (XEXP (XEXP (XEXP (x, 0), 0), 0))\n+\t      == GET_CODE (XEXP (XEXP (XEXP (x, 0), 0), 1)))\n+\t  && (GET_CODE (XEXP (XEXP (XEXP (x, 0), 0), 0)) == ZERO_EXTEND\n+\t      || GET_CODE (XEXP (XEXP (XEXP (x, 0), 0), 0)) == SIGN_EXTEND))\n+\treturn 8;\n+      return 99;\n+\n     case NEG:\n       if (GET_MODE_CLASS (mode) == MODE_FLOAT)\n \treturn 4 + (REG_OR_SUBREG_REG (XEXP (x, 0)) ? 0 : 6);\n@@ -2352,6 +2371,10 @@ load_multiple_sequence (operands, nops, regs, base, load_offset)\n       rtx reg;\n       rtx offset;\n \n+      /* Convert a subreg of a mem into the mem itself.  */\n+      if (GET_CODE (operands[nops + i]) == SUBREG)\n+\toperands[nops + i] = alter_subreg(operands[nops + i]);\n+\n       if (GET_CODE (operands[nops + i]) != MEM)\n \tabort ();\n \n@@ -2551,6 +2574,10 @@ store_multiple_sequence (operands, nops, regs, base, load_offset)\n       rtx reg;\n       rtx offset;\n \n+      /* Convert a subreg of a mem into the mem itself.  */\n+      if (GET_CODE (operands[nops + i]) == SUBREG)\n+\toperands[nops + i] = alter_subreg(operands[nops + i]);\n+\n       if (GET_CODE (operands[nops + i]) != MEM)\n \tabort ();\n \n@@ -2761,16 +2788,20 @@ arm_naked_function_p (func)\n /* Routines for use in generating RTL */\n \n rtx\n-arm_gen_load_multiple (base_regno, count, from, up, write_back)\n+arm_gen_load_multiple (base_regno, count, from, up, write_back, unchanging_p,\n+\t\t       in_struct_p)\n      int base_regno;\n      int count;\n      rtx from;\n      int up;\n      int write_back;\n+     int unchanging_p;\n+     int in_struct_p;\n {\n   int i = 0, j;\n   rtx result;\n   int sign = up ? 1 : -1;\n+  rtx mem;\n \n   result = gen_rtx (PARALLEL, VOIDmode,\n                     rtvec_alloc (count + (write_back ? 2 : 0)));\n@@ -2785,10 +2816,13 @@ arm_gen_load_multiple (base_regno, count, from, up, write_back)\n \n   for (j = 0; i < count; i++, j++)\n     {\n-      XVECEXP (result, 0, i)\n-\t= gen_rtx (SET, VOIDmode, gen_rtx (REG, SImode, base_regno + j),\n-\t\t   gen_rtx (MEM, SImode,\n-\t\t\t    plus_constant (from, j * 4 * sign)));\n+      mem = gen_rtx (MEM, SImode, plus_constant (from, j * 4 * sign));\n+      RTX_UNCHANGING_P (mem) = unchanging_p;\n+      MEM_IN_STRUCT_P (mem) = in_struct_p;\n+\n+      XVECEXP (result, 0, i) = gen_rtx (SET, VOIDmode,\n+\t\t\t\t\tgen_rtx (REG, SImode, base_regno + j),\n+\t\t\t\t\tmem);\n     }\n \n   if (write_back)\n@@ -2798,16 +2832,20 @@ arm_gen_load_multiple (base_regno, count, from, up, write_back)\n }\n \n rtx\n-arm_gen_store_multiple (base_regno, count, to, up, write_back)\n+arm_gen_store_multiple (base_regno, count, to, up, write_back, unchanging_p,\n+\t\t\tin_struct_p)\n      int base_regno;\n      int count;\n      rtx to;\n      int up;\n      int write_back;\n+     int unchanging_p;\n+     int in_struct_p;\n {\n   int i = 0, j;\n   rtx result;\n   int sign = up ? 1 : -1;\n+  rtx mem;\n \n   result = gen_rtx (PARALLEL, VOIDmode,\n                     rtvec_alloc (count + (write_back ? 2 : 0)));\n@@ -2822,10 +2860,12 @@ arm_gen_store_multiple (base_regno, count, to, up, write_back)\n \n   for (j = 0; i < count; i++, j++)\n     {\n-      XVECEXP (result, 0, i)\n-\t= gen_rtx (SET, VOIDmode,\n-\t\t   gen_rtx (MEM, SImode, plus_constant (to, j * 4 * sign)),\n-\t\t   gen_rtx (REG, SImode, base_regno + j));\n+      mem = gen_rtx (MEM, SImode, plus_constant (to, j * 4 * sign));\n+      RTX_UNCHANGING_P (mem) = unchanging_p;\n+      MEM_IN_STRUCT_P (mem) = in_struct_p;\n+\n+      XVECEXP (result, 0, i) = gen_rtx (SET, VOIDmode, mem,\n+\t\t\t\t\tgen_rtx (REG, SImode, base_regno + j));\n     }\n \n   if (write_back)\n@@ -2843,6 +2883,8 @@ arm_gen_movstrqi (operands)\n   rtx src, dst;\n   rtx st_src, st_dst, end_src, end_dst, fin_src, fin_dst;\n   rtx part_bytes_reg = NULL;\n+  rtx mem;\n+  int dst_unchanging_p, dst_in_struct_p, src_unchanging_p, src_in_struct_p;\n   extern int optimize;\n \n   if (GET_CODE (operands[2]) != CONST_INT\n@@ -2853,6 +2895,12 @@ arm_gen_movstrqi (operands)\n \n   st_dst = XEXP (operands[0], 0);\n   st_src = XEXP (operands[1], 0);\n+\n+  dst_unchanging_p = RTX_UNCHANGING_P (operands[0]);\n+  dst_in_struct_p = MEM_IN_STRUCT_P (operands[0]);\n+  src_unchanging_p = RTX_UNCHANGING_P (operands[1]);\n+  src_in_struct_p = MEM_IN_STRUCT_P (operands[1]);\n+\n   fin_dst = dst = copy_to_mode_reg (SImode, st_dst);\n   fin_src = src = copy_to_mode_reg (SImode, st_src);\n \n@@ -2866,24 +2914,32 @@ arm_gen_movstrqi (operands)\n   for (i = 0; in_words_to_go >= 2; i+=4)\n     {\n       if (in_words_to_go > 4)\n-\temit_insn (arm_gen_load_multiple (0, 4, src, TRUE, TRUE));\n+\temit_insn (arm_gen_load_multiple (0, 4, src, TRUE, TRUE,\n+\t\t\t\t\t  src_unchanging_p, src_in_struct_p));\n       else\n \temit_insn (arm_gen_load_multiple (0, in_words_to_go, src, TRUE, \n-\t\t\t\t\t  FALSE));\n+\t\t\t\t\t  FALSE, src_unchanging_p,\n+\t\t\t\t\t  src_in_struct_p));\n \n       if (out_words_to_go)\n \t{\n \t  if (out_words_to_go > 4)\n-\t    emit_insn (arm_gen_store_multiple (0, 4, dst, TRUE, TRUE));\n+\t    emit_insn (arm_gen_store_multiple (0, 4, dst, TRUE, TRUE,\n+\t\t\t\t\t       dst_unchanging_p,\n+\t\t\t\t\t       dst_in_struct_p));\n \t  else if (out_words_to_go != 1)\n \t    emit_insn (arm_gen_store_multiple (0, out_words_to_go,\n \t\t\t\t\t       dst, TRUE, \n \t\t\t\t\t       (last_bytes == 0\n-\t\t\t\t\t\t? FALSE : TRUE)));\n+\t\t\t\t\t\t? FALSE : TRUE),\n+\t\t\t\t\t       dst_unchanging_p,\n+\t\t\t\t\t       dst_in_struct_p));\n \t  else\n \t    {\n-\t      emit_move_insn (gen_rtx (MEM, SImode, dst),\n-\t\t\t      gen_rtx (REG, SImode, 0));\n+\t      mem = gen_rtx (MEM, SImode, dst);\n+\t      RTX_UNCHANGING_P (mem) = dst_unchanging_p;\n+\t      MEM_IN_STRUCT_P (mem) = dst_in_struct_p;\n+\t      emit_move_insn (mem, gen_rtx (REG, SImode, 0));\n \t      if (last_bytes != 0)\n \t\temit_insn (gen_addsi3 (dst, dst, GEN_INT (4)));\n \t    }\n@@ -2898,9 +2954,16 @@ arm_gen_movstrqi (operands)\n   {\n     rtx sreg;\n \n-    emit_move_insn (sreg = gen_reg_rtx (SImode), gen_rtx (MEM, SImode, src));\n+    mem = gen_rtx (MEM, SImode, src);\n+    RTX_UNCHANGING_P (mem) = src_unchanging_p;\n+    MEM_IN_STRUCT_P (mem) = src_in_struct_p;\n+    emit_move_insn (sreg = gen_reg_rtx (SImode), mem);\n     emit_move_insn (fin_src = gen_reg_rtx (SImode), plus_constant (src, 4));\n-    emit_move_insn (gen_rtx (MEM, SImode, dst), sreg);\n+\n+    mem = gen_rtx (MEM, SImode, dst);\n+    RTX_UNCHANGING_P (mem) = dst_unchanging_p;\n+    MEM_IN_STRUCT_P (mem) = dst_in_struct_p;\n+    emit_move_insn (mem, sreg);\n     emit_move_insn (fin_dst = gen_reg_rtx (SImode), plus_constant (dst, 4));\n     in_words_to_go--;\n \n@@ -2913,7 +2976,10 @@ arm_gen_movstrqi (operands)\n       if (in_words_to_go < 0)\n \tabort ();\n \n-      part_bytes_reg = copy_to_mode_reg (SImode, gen_rtx (MEM, SImode, src));\n+      mem = gen_rtx (MEM, SImode, src);\n+      RTX_UNCHANGING_P (mem) = src_unchanging_p;\n+      MEM_IN_STRUCT_P (mem) = src_in_struct_p;\n+      part_bytes_reg = copy_to_mode_reg (SImode, mem);\n     }\n \n   if (BYTES_BIG_ENDIAN && last_bytes)\n@@ -2930,9 +2996,10 @@ arm_gen_movstrqi (operands)\n       \n       while (last_bytes)\n \t{\n-\t  emit_move_insn (gen_rtx (MEM, QImode, \n-\t\t\t\t   plus_constant (dst, last_bytes - 1)),\n-\t\t\t  gen_rtx (SUBREG, QImode, part_bytes_reg, 0));\n+\t  mem = gen_rtx (MEM, QImode, plus_constant (dst, last_bytes - 1));\n+\t  RTX_UNCHANGING_P (mem) = dst_unchanging_p;\n+\t  MEM_IN_STRUCT_P (mem) = dst_in_struct_p;\n+\t  emit_move_insn (mem, gen_rtx (SUBREG, QImode, part_bytes_reg, 0));\n \t  if (--last_bytes)\n \t    {\n \t      tmp = gen_reg_rtx (SImode);\n@@ -2949,8 +3016,10 @@ arm_gen_movstrqi (operands)\n \t  if (part_bytes_reg == NULL)\n \t    abort ();\n \n-\t  emit_move_insn (gen_rtx (MEM, QImode, dst),\n-\t\t\t  gen_rtx (SUBREG, QImode, part_bytes_reg, 0));\n+\t  mem = gen_rtx (MEM, QImode, dst);\n+\t  RTX_UNCHANGING_P (mem) = dst_unchanging_p;\n+\t  MEM_IN_STRUCT_P (mem) = dst_in_struct_p;\n+\t  emit_move_insn (mem, gen_rtx (SUBREG, QImode, part_bytes_reg, 0));\n \t  if (--last_bytes)\n \t    {\n \t      rtx tmp = gen_reg_rtx (SImode);\n@@ -3913,7 +3982,7 @@ output_move_double (operands)\n {\n   enum rtx_code code0 = GET_CODE (operands[0]);\n   enum rtx_code code1 = GET_CODE (operands[1]);\n-  rtx otherops[2];\n+  rtx otherops[3];\n \n   if (code0 == REG)\n     {\n@@ -3964,7 +4033,21 @@ output_move_double (operands)\n \t}\n       else if (code1 == CONST_INT)\n \t{\n-\t  /* sign extend the intval into the high-order word */\n+#if HOST_BITS_PER_WIDE_INT > 32\n+\t  /* If HOST_WIDE_INT is more than 32 bits, the intval tells us\n+\t     what the upper word is.  */\n+\t  if (WORDS_BIG_ENDIAN)\n+\t    {\n+\t      otherops[1] = GEN_INT (ARM_SIGN_EXTEND (INTVAL (operands[1])));\n+\t      operands[1] = GEN_INT (INTVAL (operands[1]) >> 32);\n+\t    }\n+\t  else\n+\t    {\n+\t      otherops[1] = GEN_INT (INTVAL (operands[1]) >> 32);\n+\t      operands[1] = GEN_INT (ARM_SIGN_EXTEND (INTVAL (operands[1])));\n+\t    }\n+#else\n+\t  /* Sign extend the intval into the high-order word */\n \t  if (WORDS_BIG_ENDIAN)\n \t    {\n \t      otherops[1] = operands[1];\n@@ -3973,6 +4056,7 @@ output_move_double (operands)\n \t    }\n \t  else\n \t    otherops[1] = INTVAL (operands[1]) < 0 ? constm1_rtx : const0_rtx;\n+#endif\n \t  output_mov_immediate (otherops);\n \t  output_mov_immediate (operands);\n \t}\n@@ -4762,10 +4846,9 @@ output_func_epilogue (f, frame_size)\n \n   if (use_return_insn() && return_used_this_function)\n     {\n-      if (frame_size && !(frame_pointer_needed || TARGET_APCS))\n-        {\n-          abort ();\n-        }\n+      if ((frame_size + current_function_outgoing_args_size) != 0\n+\t  && !(frame_pointer_needed || TARGET_APCS))\n+\tabort ();\n       goto epilogue_done;\n     }\n \n@@ -4853,10 +4936,11 @@ output_func_epilogue (f, frame_size)\n   else\n     {\n       /* Restore stack pointer if necessary.  */\n-      if (frame_size)\n+      if (frame_size + current_function_outgoing_args_size != 0)\n \t{\n \t  operands[0] = operands[1] = stack_pointer_rtx;\n-\t  operands[2] = gen_rtx (CONST_INT, VOIDmode, frame_size);\n+\t  operands[2] = GEN_INT (frame_size\n+\t\t\t\t + current_function_outgoing_args_size);\n \t  output_add_immediate (operands);\n \t}\n \n@@ -5028,7 +5112,8 @@ void\n arm_expand_prologue ()\n {\n   int reg;\n-  rtx amount = GEN_INT (- get_frame_size ());\n+  rtx amount = GEN_INT (-(get_frame_size ()\n+\t\t\t  + current_function_outgoing_args_size));\n   rtx push_insn;\n   int num_regs;\n   int live_regs_mask = 0;\n@@ -5295,34 +5380,6 @@ arm_print_operand (stream, x, code)\n     }\n }\n \n-/* Output a label definition.  */\n-\n-void\n-arm_asm_output_label (stream, name)\n-     FILE *stream;\n-     char *name;\n-{\n-  ARM_OUTPUT_LABEL (stream, name);\n-}\n-\n-/* Output code resembling an .lcomm directive.  /bin/as doesn't have this\n-   directive hence this hack, which works by reserving some `.space' in the\n-   bss segment directly.\n-\n-   XXX This is a severe hack, which is guaranteed NOT to work since it doesn't\n-   define STATIC COMMON space but merely STATIC BSS space.  */\n-\n-void\n-output_lcomm_directive (stream, name, size, align)\n-     FILE *stream;\n-     char *name;\n-     int size, align;\n-{\n-  bss_section ();\n-  ASM_OUTPUT_ALIGN (stream, floor_log2 (align / BITS_PER_UNIT));\n-  ARM_OUTPUT_LABEL (stream, name);\n-  fprintf (stream, \"\\t.space\\t%d\\n\", size);\n-}\n \f\n /* A finite state machine takes care of noticing whether or not instructions\n    can be conditionally executed, and thus decrease execution time and code"}]}