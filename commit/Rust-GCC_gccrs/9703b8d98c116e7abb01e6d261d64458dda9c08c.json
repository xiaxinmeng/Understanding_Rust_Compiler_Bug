{"sha": "9703b8d98c116e7abb01e6d261d64458dda9c08c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTcwM2I4ZDk4YzExNmU3YWJiMDFlNmQyNjFkNjQ0NThkZGE5YzA4Yw==", "commit": {"author": {"name": "Nathan Sidwell", "email": "nathan@acm.org", "date": "2020-10-29T11:56:27Z"}, "committer": {"name": "Nathan Sidwell", "email": "nathan@acm.org", "date": "2020-10-29T14:16:45Z"}, "message": "c++: Stop (most) function-scope entities having a template header\n\nCurrently push_template_decl (mostly) decides whether to add a\ntemplate header to an entity by seeing if it has DECL_LANG_SPECIFIC.\nThat might have been a useful predicate at one time, but basing\nsemantic implications on how we've decided to represent decls is bound\nto be brittle.  And indeed it is, as more decls grow a use for\nlang-specific.  In particular I discovered that function-scope\nVAR_DECLs couild grow lang-specific, and thereby get a template\nheader.  There's no need for that, and it breaks an invariant modules\nwas expected.\n\nThis patch changes that, and bases the descision on the properties of\nthe decl.  In particular the only function-scope decl that gets a\ntemplate header is an implicit-typedef.\n\nI also cleaned up the behaviour of it building a template-info only to\nignore it.\n\n\tgcc/cp/\n\t* pt.c (push_template_decl): Do not give function-scope entities\n\tother than implicit typedefs a template header. Do not readd\n\ttemplate info to a redeclared template.", "tree": {"sha": "496fc9724c1e2aed2b148dbbad51b6dbd7df6db4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/496fc9724c1e2aed2b148dbbad51b6dbd7df6db4"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/9703b8d98c116e7abb01e6d261d64458dda9c08c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9703b8d98c116e7abb01e6d261d64458dda9c08c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9703b8d98c116e7abb01e6d261d64458dda9c08c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9703b8d98c116e7abb01e6d261d64458dda9c08c/comments", "author": {"login": "urnathan", "id": 13103001, "node_id": "MDQ6VXNlcjEzMTAzMDAx", "avatar_url": "https://avatars.githubusercontent.com/u/13103001?v=4", "gravatar_id": "", "url": "https://api.github.com/users/urnathan", "html_url": "https://github.com/urnathan", "followers_url": "https://api.github.com/users/urnathan/followers", "following_url": "https://api.github.com/users/urnathan/following{/other_user}", "gists_url": "https://api.github.com/users/urnathan/gists{/gist_id}", "starred_url": "https://api.github.com/users/urnathan/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/urnathan/subscriptions", "organizations_url": "https://api.github.com/users/urnathan/orgs", "repos_url": "https://api.github.com/users/urnathan/repos", "events_url": "https://api.github.com/users/urnathan/events{/privacy}", "received_events_url": "https://api.github.com/users/urnathan/received_events", "type": "User", "site_admin": false}, "committer": {"login": "urnathan", "id": 13103001, "node_id": "MDQ6VXNlcjEzMTAzMDAx", "avatar_url": "https://avatars.githubusercontent.com/u/13103001?v=4", "gravatar_id": "", "url": "https://api.github.com/users/urnathan", "html_url": "https://github.com/urnathan", "followers_url": "https://api.github.com/users/urnathan/followers", "following_url": "https://api.github.com/users/urnathan/following{/other_user}", "gists_url": "https://api.github.com/users/urnathan/gists{/gist_id}", "starred_url": "https://api.github.com/users/urnathan/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/urnathan/subscriptions", "organizations_url": "https://api.github.com/users/urnathan/orgs", "repos_url": "https://api.github.com/users/urnathan/repos", "events_url": "https://api.github.com/users/urnathan/events{/privacy}", "received_events_url": "https://api.github.com/users/urnathan/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2e0216f9c4db8fde09706f57e6a6d80161c0da07", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2e0216f9c4db8fde09706f57e6a6d80161c0da07", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2e0216f9c4db8fde09706f57e6a6d80161c0da07"}], "stats": {"total": 143, "additions": 80, "deletions": 63}, "files": [{"sha": "f31a1a7047326230860e0dc3a306c1a19077f0f3", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 80, "deletions": 63, "changes": 143, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9703b8d98c116e7abb01e6d261d64458dda9c08c/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9703b8d98c116e7abb01e6d261d64458dda9c08c/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=9703b8d98c116e7abb01e6d261d64458dda9c08c", "patch": "@@ -5682,11 +5682,6 @@ template_parm_outer_level (tree t, void *data)\n tree\n push_template_decl (tree decl, bool is_friend)\n {\n-  int new_template_p = 0;\n-  /* True if the template is a member template, in the sense of\n-     [temp.mem].  */\n-  bool member_template_p = false;\n-\n   if (decl == error_mark_node || !current_template_parms)\n     return error_mark_node;\n \n@@ -5739,12 +5734,17 @@ push_template_decl (tree decl, bool is_friend)\n   else\n     is_primary = template_parm_scope_p ();\n \n+  /* True if the template is a member template, in the sense of\n+     [temp.mem].  */\n+  bool member_template_p = false;\n+\n   if (is_primary)\n     {\n       warning (OPT_Wtemplates, \"template %qD declared\", decl);\n \n       if (DECL_CLASS_SCOPE_P (decl))\n \tmember_template_p = true;\n+\n       if (TREE_CODE (decl) == TYPE_DECL\n \t  && IDENTIFIER_ANON_P (DECL_NAME (decl)))\n \t{\n@@ -5812,11 +5812,16 @@ push_template_decl (tree decl, bool is_friend)\n \t}\n     }\n \n+  bool local_p = (!DECL_IMPLICIT_TYPEDEF_P (decl)\n+\t\t  && ((ctx && TREE_CODE (ctx) == FUNCTION_DECL)\n+\t\t      || (VAR_OR_FUNCTION_DECL_P (decl)\n+\t\t\t  && DECL_LOCAL_DECL_P (decl))));\n+\n   /* Check to see that the rules regarding the use of default\n      arguments are not being violated.  We check args for a friend\n      functions when we know whether it's a definition, introducing\n      declaration or re-declaration.  */\n-  if (!is_friend || TREE_CODE (decl) != FUNCTION_DECL)\n+  if (!local_p && (!is_friend || TREE_CODE (decl) != FUNCTION_DECL))\n     check_default_tmpl_args (decl, current_template_parms,\n \t\t\t     is_primary, is_partial, is_friend);\n \n@@ -5869,14 +5874,20 @@ push_template_decl (tree decl, bool is_friend)\n     return process_partial_specialization (decl);\n \n   tree args = current_template_args ();\n-\n-  tree tmpl;\n-  if (!ctx\n-      || TREE_CODE (ctx) == FUNCTION_DECL\n-      || (CLASS_TYPE_P (ctx) && TYPE_BEING_DEFINED (ctx))\n-      || (TREE_CODE (decl) == TYPE_DECL && LAMBDA_TYPE_P (TREE_TYPE (decl)))\n-      || (is_friend && !(DECL_LANG_SPECIFIC (decl)\n-\t\t\t && DECL_TEMPLATE_INFO (decl))))\n+  tree tmpl = NULL_TREE;\n+  bool new_template_p = false;\n+  if (local_p)\n+    {\n+      /* Does not get a template head.  */\n+      tmpl = NULL_TREE;\n+      gcc_checking_assert (!is_primary);\n+    }\n+  else if (!ctx\n+\t   || TREE_CODE (ctx) == FUNCTION_DECL\n+\t   || (CLASS_TYPE_P (ctx) && TYPE_BEING_DEFINED (ctx))\n+\t   || (TREE_CODE (decl) == TYPE_DECL && LAMBDA_TYPE_P (TREE_TYPE (decl)))\n+\t   || (is_friend && !(DECL_LANG_SPECIFIC (decl)\n+\t\t\t      && DECL_TEMPLATE_INFO (decl))))\n     {\n       if (DECL_LANG_SPECIFIC (decl)\n \t  && DECL_TEMPLATE_INFO (decl)\n@@ -5903,7 +5914,7 @@ push_template_decl (tree decl, bool is_friend)\n \t{\n \t  tmpl = build_template_decl (decl, current_template_parms,\n \t\t\t\t      member_template_p);\n-\t  new_template_p = 1;\n+\t  new_template_p = true;\n \n \t  if (DECL_LANG_SPECIFIC (decl)\n \t      && DECL_TEMPLATE_SPECIALIZATION (decl))\n@@ -5935,16 +5946,14 @@ push_template_decl (tree decl, bool is_friend)\n \t  && DECL_TEMPLATE_SPECIALIZATION (decl)\n \t  && DECL_MEMBER_TEMPLATE_P (tmpl))\n \t{\n-\t  tree new_tmpl;\n-\n \t  /* The declaration is a specialization of a member\n \t     template, declared outside the class.  Therefore, the\n \t     innermost template arguments will be NULL, so we\n \t     replace them with the arguments determined by the\n \t     earlier call to check_explicit_specialization.  */\n \t  args = DECL_TI_ARGS (decl);\n \n-\t  new_tmpl\n+\t  tree new_tmpl\n \t    = build_template_decl (decl, current_template_parms,\n \t\t\t\t   member_template_p);\n \t  DECL_TI_TEMPLATE (decl) = new_tmpl;\n@@ -6016,7 +6025,7 @@ push_template_decl (tree decl, bool is_friend)\n \t}\n     }\n \n-  gcc_checking_assert (DECL_TEMPLATE_RESULT (tmpl) == decl);\n+  gcc_checking_assert (!tmpl || DECL_TEMPLATE_RESULT (tmpl) == decl);\n \n   if (new_template_p)\n     {\n@@ -6028,65 +6037,71 @@ push_template_decl (tree decl, bool is_friend)\n       if (!ctx\n \t  && !(is_friend && template_class_depth (current_class_type) > 0))\n \t{\n-\t  tmpl = pushdecl_namespace_level (tmpl, /*hiding=*/is_friend);\n-\t  if (tmpl == error_mark_node)\n+\t  tree pushed = pushdecl_namespace_level (tmpl, /*hiding=*/is_friend);\n+\t  if (pushed == error_mark_node)\n \t    return error_mark_node;\n+\n+\t  /* pushdecl may have found an existing template.  */\n+\t  if (pushed != tmpl)\n+\t    {\n+\t      decl = DECL_TEMPLATE_RESULT (pushed);\n+\t      tmpl = NULL_TREE;\n+\t    }\n \t}\n     }\n-  else\n+  else if (tmpl)\n     /* The type may have been completed, or (erroneously) changed.  */\n     TREE_TYPE (tmpl) = TREE_TYPE (decl);\n \n-  if (is_primary)\n+  if (tmpl)\n     {\n-      tree parms = DECL_TEMPLATE_PARMS (tmpl);\n+      if (is_primary)\n+\t{\n+\t  tree parms = DECL_TEMPLATE_PARMS (tmpl);\n \n-      DECL_PRIMARY_TEMPLATE (tmpl) = tmpl;\n+\t  DECL_PRIMARY_TEMPLATE (tmpl) = tmpl;\n \n-      /* Give template template parms a DECL_CONTEXT of the template\n-\t for which they are a parameter.  */\n-      parms = INNERMOST_TEMPLATE_PARMS (parms);\n-      for (int i = TREE_VEC_LENGTH (parms) - 1; i >= 0; --i)\n-\t{\n-\t  tree parm = TREE_VALUE (TREE_VEC_ELT (parms, i));\n-\t  if (TREE_CODE (parm) == TEMPLATE_DECL)\n-\t    DECL_CONTEXT (parm) = tmpl;\n-\t}\n+\t  /* Give template template parms a DECL_CONTEXT of the template\n+\t     for which they are a parameter.  */\n+\t  parms = INNERMOST_TEMPLATE_PARMS (parms);\n+\t  for (int i = TREE_VEC_LENGTH (parms) - 1; i >= 0; --i)\n+\t    {\n+\t      tree parm = TREE_VALUE (TREE_VEC_ELT (parms, i));\n+\t      if (TREE_CODE (parm) == TEMPLATE_DECL)\n+\t\tDECL_CONTEXT (parm) = tmpl;\n+\t    }\n \n-      if (TREE_CODE (decl) == TYPE_DECL\n-\t  && TYPE_DECL_ALIAS_P (decl))\n-\t{\n-\t  if (tree constr\n-\t      = TEMPLATE_PARMS_CONSTRAINTS (DECL_TEMPLATE_PARMS (tmpl)))\n+\t  if (TREE_CODE (decl) == TYPE_DECL\n+\t      && TYPE_DECL_ALIAS_P (decl))\n \t    {\n-\t      /* ??? Why don't we do this here for all templates?  */\n-\t      constr = build_constraints (constr, NULL_TREE);\n-\t      set_constraints (decl, constr);\n+\t      if (tree constr\n+\t\t  = TEMPLATE_PARMS_CONSTRAINTS (DECL_TEMPLATE_PARMS (tmpl)))\n+\t\t{\n+\t\t  /* ??? Why don't we do this here for all templates?  */\n+\t\t  constr = build_constraints (constr, NULL_TREE);\n+\t\t  set_constraints (decl, constr);\n+\t\t}\n+\t      if (complex_alias_template_p (tmpl))\n+\t\tTEMPLATE_DECL_COMPLEX_ALIAS_P (tmpl) = true;\n \t    }\n-\t  if (complex_alias_template_p (tmpl))\n-\t    TEMPLATE_DECL_COMPLEX_ALIAS_P (tmpl) = true;\n \t}\n-    }\n \n-  /* The DECL_TI_ARGS of DECL contains full set of arguments referring\n-     back to its most general template.  If TMPL is a specialization,\n-     ARGS may only have the innermost set of arguments.  Add the missing\n-     argument levels if necessary.  */\n-  if (DECL_TEMPLATE_INFO (tmpl))\n-    args = add_outermost_template_args (DECL_TI_ARGS (tmpl), args);\n+      /* The DECL_TI_ARGS of DECL contains full set of arguments\n+\t referring wback to its most general template.  If TMPL is a\n+\t specialization, ARGS may only have the innermost set of\n+\t arguments.  Add the missing argument levels if necessary.  */\n+      if (DECL_TEMPLATE_INFO (tmpl))\n+\targs = add_outermost_template_args (DECL_TI_ARGS (tmpl), args);\n \n-  tree info = build_template_info (tmpl, args);\n+      tree info = build_template_info (tmpl, args);\n \n-  if (DECL_IMPLICIT_TYPEDEF_P (decl))\n-    SET_TYPE_TEMPLATE_INFO (TREE_TYPE (tmpl), info);\n-  else\n-    {\n-      if (is_primary)\n-\tretrofit_lang_decl (decl);\n-      if (DECL_LANG_SPECIFIC (decl)\n-\t  && !(VAR_OR_FUNCTION_DECL_P (decl)\n-\t       && DECL_LOCAL_DECL_P (decl)))\n-\tDECL_TEMPLATE_INFO (decl) = info;\n+      if (DECL_IMPLICIT_TYPEDEF_P (decl))\n+\tSET_TYPE_TEMPLATE_INFO (TREE_TYPE (tmpl), info);\n+      else\n+\t{\n+\t  retrofit_lang_decl (decl);\n+\t  DECL_TEMPLATE_INFO (decl) = info;\n+\t}\n     }\n \n   if (flag_implicit_templates\n@@ -6098,7 +6113,9 @@ push_template_decl (tree decl, bool is_friend)\n        mark_needed will tell cgraph to do the right thing.  */\n     DECL_COMDAT (decl) = true;\n \n-  return DECL_TEMPLATE_RESULT (tmpl);\n+  gcc_checking_assert (!tmpl || DECL_TEMPLATE_RESULT (tmpl) == decl);\n+\n+  return decl;\n }\n \n /* FN is an inheriting constructor that inherits from the constructor"}]}