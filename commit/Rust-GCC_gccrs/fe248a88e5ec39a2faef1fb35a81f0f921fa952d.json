{"sha": "fe248a88e5ec39a2faef1fb35a81f0f921fa952d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZmUyNDhhODhlNWVjMzlhMmZhZWYxZmIzNWE4MWYwZjkyMWZhOTUyZA==", "commit": {"author": {"name": "Martin Liska", "email": "mliska@suse.cz", "date": "2019-07-28T17:10:26Z"}, "committer": {"name": "Martin Liska", "email": "marxin@gcc.gnu.org", "date": "2019-07-28T17:10:26Z"}, "message": "Release cgraph_{node,edge} via ggc_free (PR ipa/89330).\n\n2019-07-28  Martin Liska  <mliska@suse.cz>\n\n\tPR ipa/89330\n\t* cgraph.c (symbol_table::create_edge): Always allocate\n\ta cgraph_edge.\n\t(symbol_table::free_edge): Store summary_id to\n\tedge_released_summary_ids if != -1;\n\t* cgraph.h (NEXT_FREE_NODE): Remove.\n\t(SET_NEXT_FREE_NODE): Likewise.\n\t(NEXT_FREE_EDGE): Likewise.\n\t(symbol_table::release_symbol): Store summary_id to\n\tcgraph_released_summary_ids if != -1;\n\t(symbol_table::allocate_cgraph_symbol): Always allocate\n\ta cgraph_node.\n\nFrom-SVN: r273857", "tree": {"sha": "ba5e596764b3e32248ad0ad682802284d60fddae", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ba5e596764b3e32248ad0ad682802284d60fddae"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/fe248a88e5ec39a2faef1fb35a81f0f921fa952d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fe248a88e5ec39a2faef1fb35a81f0f921fa952d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fe248a88e5ec39a2faef1fb35a81f0f921fa952d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fe248a88e5ec39a2faef1fb35a81f0f921fa952d/comments", "author": {"login": "marxin", "id": 2658545, "node_id": "MDQ6VXNlcjI2NTg1NDU=", "avatar_url": "https://avatars.githubusercontent.com/u/2658545?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marxin", "html_url": "https://github.com/marxin", "followers_url": "https://api.github.com/users/marxin/followers", "following_url": "https://api.github.com/users/marxin/following{/other_user}", "gists_url": "https://api.github.com/users/marxin/gists{/gist_id}", "starred_url": "https://api.github.com/users/marxin/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marxin/subscriptions", "organizations_url": "https://api.github.com/users/marxin/orgs", "repos_url": "https://api.github.com/users/marxin/repos", "events_url": "https://api.github.com/users/marxin/events{/privacy}", "received_events_url": "https://api.github.com/users/marxin/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "4f394a9e1c5fffda66f822b13d2b9cc2623db653", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4f394a9e1c5fffda66f822b13d2b9cc2623db653", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4f394a9e1c5fffda66f822b13d2b9cc2623db653"}], "stats": {"total": 99, "additions": 46, "deletions": 53}, "files": [{"sha": "c95d59302580023e8855f950c1bc4df651352dd8", "filename": "gcc/ChangeLog", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fe248a88e5ec39a2faef1fb35a81f0f921fa952d/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fe248a88e5ec39a2faef1fb35a81f0f921fa952d/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=fe248a88e5ec39a2faef1fb35a81f0f921fa952d", "patch": "@@ -1,3 +1,18 @@\n+2019-07-28  Martin Liska  <mliska@suse.cz>\n+\n+\tPR ipa/89330\n+\t* cgraph.c (symbol_table::create_edge): Always allocate\n+\ta cgraph_edge.\n+\t(symbol_table::free_edge): Store summary_id to\n+\tedge_released_summary_ids if != -1;\n+\t* cgraph.h (NEXT_FREE_NODE): Remove.\n+\t(SET_NEXT_FREE_NODE): Likewise.\n+\t(NEXT_FREE_EDGE): Likewise.\n+\t(symbol_table::release_symbol): Store summary_id to\n+\tcgraph_released_summary_ids if != -1;\n+\t(symbol_table::allocate_cgraph_symbol): Always allocate\n+\ta cgraph_node.\n+\n 2019-07-28  Alan Modra  <amodra@gmail.com>\n \n \t* gcc/config/rs6000/rs6000-call.c (rs6000_output_mi_thunk): Use"}, {"sha": "81250acb70c19985c32ff39874785dbd358895ed", "filename": "gcc/cgraph.c", "status": "modified", "additions": 7, "deletions": 19, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fe248a88e5ec39a2faef1fb35a81f0f921fa952d/gcc%2Fcgraph.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fe248a88e5ec39a2faef1fb35a81f0f921fa952d/gcc%2Fcgraph.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraph.c?ref=fe248a88e5ec39a2faef1fb35a81f0f921fa952d", "patch": "@@ -846,17 +846,8 @@ symbol_table::create_edge (cgraph_node *caller, cgraph_node *callee,\n       gcc_assert (is_gimple_call (call_stmt));\n     }\n \n-  if (free_edges)\n-    {\n-      edge = free_edges;\n-      free_edges = NEXT_FREE_EDGE (edge);\n-    }\n-  else\n-    {\n-      edge = ggc_alloc<cgraph_edge> ();\n-      edge->m_summary_id = -1;\n-    }\n-\n+  edge = ggc_alloc<cgraph_edge> ();\n+  edge->m_summary_id = -1;\n   edges_count++;\n \n   gcc_assert (++edges_max_uid != 0);\n@@ -1013,16 +1004,13 @@ cgraph_edge::remove_caller (void)\n void\n symbol_table::free_edge (cgraph_edge *e)\n {\n+  edges_count--;\n+  if (e->m_summary_id != -1)\n+    edge_released_summary_ids.safe_push (e->m_summary_id);\n+\n   if (e->indirect_info)\n     ggc_free (e->indirect_info);\n-\n-  /* Clear out the edge so we do not dangle pointers.  */\n-  int summary_id = e->m_summary_id;\n-  memset (e, 0, sizeof (*e));\n-  e->m_summary_id = summary_id;\n-  NEXT_FREE_EDGE (e) = free_edges;\n-  free_edges = e;\n-  edges_count--;\n+  ggc_free (e);\n }\n \n /* Remove the edge in the cgraph.  */"}, {"sha": "fbf20b3f48355ca178cc952e37583ac761749c93", "filename": "gcc/cgraph.h", "status": "modified", "additions": 24, "deletions": 34, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fe248a88e5ec39a2faef1fb35a81f0f921fa952d/gcc%2Fcgraph.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fe248a88e5ec39a2faef1fb35a81f0f921fa952d/gcc%2Fcgraph.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraph.h?ref=fe248a88e5ec39a2faef1fb35a81f0f921fa952d", "patch": "@@ -2027,12 +2027,6 @@ is_a_helper <varpool_node *>::test (symtab_node *p)\n   return p && p->type == SYMTAB_VARIABLE;\n }\n \n-/* Macros to access the next item in the list of free cgraph nodes and\n-   edges. */\n-#define NEXT_FREE_NODE(NODE) dyn_cast<cgraph_node *> ((NODE)->next)\n-#define SET_NEXT_FREE_NODE(NODE,NODE2) ((NODE))->next = NODE2\n-#define NEXT_FREE_EDGE(EDGE) (EDGE)->prev_caller\n-\n typedef void (*cgraph_edge_hook)(cgraph_edge *, void *);\n typedef void (*cgraph_node_hook)(cgraph_node *, void *);\n typedef void (*varpool_node_hook)(varpool_node *, void *);\n@@ -2088,7 +2082,8 @@ class GTY((tag (\"SYMTAB\"))) symbol_table\n   friend struct cgraph_edge;\n \n   symbol_table (): cgraph_max_uid (1), cgraph_max_summary_id (0),\n-  edges_max_uid (1), edges_max_summary_id (0)\n+  edges_max_uid (1), edges_max_summary_id (0),\n+  cgraph_released_summary_ids (), edge_released_summary_ids ()\n   {\n   }\n \n@@ -2297,14 +2292,22 @@ class GTY((tag (\"SYMTAB\"))) symbol_table\n   /* Assign a new summary ID for the callgraph NODE.  */\n   inline int assign_summary_id (cgraph_node *node)\n   {\n-    node->m_summary_id = cgraph_max_summary_id++;\n+    if (!cgraph_released_summary_ids.is_empty ())\n+      node->m_summary_id = cgraph_released_summary_ids.pop ();\n+    else\n+      node->m_summary_id = cgraph_max_summary_id++;\n+\n     return node->m_summary_id;\n   }\n \n   /* Assign a new summary ID for the callgraph EDGE.  */\n   inline int assign_summary_id (cgraph_edge *edge)\n   {\n-    edge->m_summary_id = edges_max_summary_id++;\n+    if (!edge_released_summary_ids.is_empty ())\n+      edge->m_summary_id = edge_released_summary_ids.pop ();\n+    else\n+      edge->m_summary_id = edges_max_summary_id++;\n+\n     return edge->m_summary_id;\n   }\n \n@@ -2320,14 +2323,15 @@ class GTY((tag (\"SYMTAB\"))) symbol_table\n   int edges_max_uid;\n   int edges_max_summary_id;\n \n+  /* Vector of released summary IDS for cgraph nodes.  */\n+  vec<int> GTY ((skip)) cgraph_released_summary_ids;\n+\n+  /* Vector of released summary IDS for cgraph nodes.  */\n+  vec<int> GTY ((skip)) edge_released_summary_ids;\n+\n   symtab_node* GTY(()) nodes;\n   asm_node* GTY(()) asmnodes;\n   asm_node* GTY(()) asm_last_node;\n-  cgraph_node* GTY(()) free_nodes;\n-\n-  /* Head of a linked list of unused (freed) call graph edges.\n-     Do not GTY((delete)) this list so UIDs gets reliably recycled.  */\n-  cgraph_edge * GTY(()) free_edges;\n \n   /* The order index of the next symtab node to be created.  This is\n      used so that we can sort the cgraph nodes in order by when we saw\n@@ -2687,15 +2691,9 @@ inline void\n symbol_table::release_symbol (cgraph_node *node)\n {\n   cgraph_count--;\n-\n-  /* Clear out the node to NULL all pointers and add the node to the free\n-     list.  */\n-  int summary_id = node->m_summary_id;\n-  memset (node, 0, sizeof (*node));\n-  node->type = SYMTAB_FUNCTION;\n-  node->m_summary_id = summary_id;\n-  SET_NEXT_FREE_NODE (node, free_nodes);\n-  free_nodes = node;\n+  if (node->m_summary_id != -1)\n+    cgraph_released_summary_ids.safe_push (node->m_summary_id);\n+  ggc_free (node);\n }\n \n /* Allocate new callgraph node.  */\n@@ -2705,17 +2703,9 @@ symbol_table::allocate_cgraph_symbol (void)\n {\n   cgraph_node *node;\n \n-  if (free_nodes)\n-    {\n-      node = free_nodes;\n-      free_nodes = NEXT_FREE_NODE (node);\n-    }\n-  else\n-    {\n-      node = ggc_cleared_alloc<cgraph_node> ();\n-      node->m_summary_id = -1;\n-    }\n-\n+  node = ggc_cleared_alloc<cgraph_node> ();\n+  node->type = SYMTAB_FUNCTION;\n+  node->m_summary_id = -1;\n   node->m_uid = cgraph_max_uid++;\n   return node;\n }"}]}