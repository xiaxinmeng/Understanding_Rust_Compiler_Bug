{"sha": "315cff155219ea11bf95209165121376b12fe06e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzE1Y2ZmMTU1MjE5ZWExMWJmOTUyMDkxNjUxMjEzNzZiMTJmZTA2ZQ==", "commit": {"author": {"name": "Eric Botcazou", "email": "ebotcazou@adacore.com", "date": "2009-10-16T20:07:52Z"}, "committer": {"name": "Eric Botcazou", "email": "ebotcazou@gcc.gnu.org", "date": "2009-10-16T20:07:52Z"}, "message": "ada-tree.h (TYPE_FAT_POINTER_P): Swap with...\n\n\t* gcc-interface/ada-tree.h (TYPE_FAT_POINTER_P): Swap with...\n\t(TYPE_IS_FAT_POINTER_P): ...this.\n\t(TYPE_THIN_POINTER_P): Rename into...\n\t(TYPE_IS_THIN_POINTER_P): ...this.\n\t(TYPE_FAT_OR_THIN_POINTER_P): Rename into...\n\t(TYPE_IS_FAT_OR_THIN_POINTER_P): ...this.\n\t(TYPE_IS_PADDING_P): Change definition, move old one to...\n\t(TYPE_PADDING_P): ...this.\n\t* gcc-interface/decl.c (gnat_to_gnu_entity): Adjust for above changes.\n\t(get_unpadded_type): Likewise.\n\t(gnat_to_gnu_component_type): Likewise.\n\t(gnat_to_gnu_param): Likewise.\n\t(relate_alias_sets): Likewise.\n\t(make_packable_type): Likewise.\n\t(maybe_pad_type): Likewise.\n\t(gnat_to_gnu_field): Likewise.\n\t(is_variable_size): Likewise.\n\t(annotate_object): Likewise.\n\t(validate_size): Likewise.\n\t(set_rm_size): Likewise.\n\t(make_type_from_size): Likewise.\n\t(rm_size): Likewise.\n\t* gcc-interface/misc.c (gnat_print_type): Likewise.\n\t(gnat_get_alias_set): Likewise.\n\t* gcc-interface/trans.c (Identifier_to_gnu): Likewise.\n\t(Attribute_to_gnu): Likewise.\n\t(call_to_gnu): Likewise.\n\t(gnat_to_gnu): Likewise.\n\t(add_decl_expr): Likewise.\n\t(convert_with_check): Likewise.\n\t(addressable_p): Likewise.\n\t(maybe_implicit_deref): Likewise.\n\t(protect_multiple_eval): Likewise.\n\t(gnat_stabilize_reference_1): Likewise.\n\t* gcc-interface/utils.c (gnat_pushdecl): Likewise.\n\t(finish_record_type): Likewise.\n\t(rest_of_record_type_compilation): Likewise.\n\t(create_type_decl): Likewise.\n\t(gnat_types_compatible_p): Likewise.\n\t(build_template): Likewise.\n\t(convert_vms_descriptor64): Likewise.\n\t(convert_vms_descriptor32): Likewise.\n\t(build_unc_object_type_from_ptr): Likewise.\n\t(update_pointer_to): Likewise.\n\t(convert_to_fat_pointer): Likewise.\n\t(convert_to_fat_pointer): Likewise.\n\t(convert): Likewise.\n\t(remove_conversions): Likewise.\n\t(maybe_unconstrained_array): Likewise.\n\t(unchecked_convert): Likewise.\n\t(handle_vector_type_attribute): Likewise.\n\t* gcc-interface/utils2.c (build_binary_op): Likewise.\n\t(build_unary_op): Likewise.\n\t(build_allocator): Likewise.\n\nFrom-SVN: r152917", "tree": {"sha": "ea0653c4e0e1f6ee65ac81ecd0a7b5b635286ede", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ea0653c4e0e1f6ee65ac81ecd0a7b5b635286ede"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/315cff155219ea11bf95209165121376b12fe06e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/315cff155219ea11bf95209165121376b12fe06e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/315cff155219ea11bf95209165121376b12fe06e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/315cff155219ea11bf95209165121376b12fe06e/comments", "author": null, "committer": null, "parents": [{"sha": "afb4afcd90d30faf064bcba6a7b5a86fd4003bdc", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/afb4afcd90d30faf064bcba6a7b5a86fd4003bdc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/afb4afcd90d30faf064bcba6a7b5a86fd4003bdc"}], "stats": {"total": 372, "additions": 192, "deletions": 180}, "files": [{"sha": "219193f82c5b3dda6f3b4e6e523736459ce72cda", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 57, "deletions": 0, "changes": 57, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/315cff155219ea11bf95209165121376b12fe06e/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/315cff155219ea11bf95209165121376b12fe06e/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=315cff155219ea11bf95209165121376b12fe06e", "patch": "@@ -1,3 +1,60 @@\n+2009-10-16  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\t* gcc-interface/ada-tree.h (TYPE_FAT_POINTER_P): Swap with...\n+\t(TYPE_IS_FAT_POINTER_P): ...this.\n+\t(TYPE_THIN_POINTER_P): Rename into...\n+\t(TYPE_IS_THIN_POINTER_P): ...this.\n+\t(TYPE_FAT_OR_THIN_POINTER_P): Rename into...\n+\t(TYPE_IS_FAT_OR_THIN_POINTER_P): ...this.\n+\t(TYPE_IS_PADDING_P): Change definition, move old one to...\n+\t(TYPE_PADDING_P): ...this.\n+\t* gcc-interface/decl.c (gnat_to_gnu_entity): Adjust for above changes.\n+\t(get_unpadded_type): Likewise.\n+\t(gnat_to_gnu_component_type): Likewise.\n+\t(gnat_to_gnu_param): Likewise.\n+\t(relate_alias_sets): Likewise.\n+\t(make_packable_type): Likewise.\n+\t(maybe_pad_type): Likewise.\n+\t(gnat_to_gnu_field): Likewise.\n+\t(is_variable_size): Likewise.\n+\t(annotate_object): Likewise.\n+\t(validate_size): Likewise.\n+\t(set_rm_size): Likewise.\n+\t(make_type_from_size): Likewise.\n+\t(rm_size): Likewise.\n+\t* gcc-interface/misc.c (gnat_print_type): Likewise.\n+\t(gnat_get_alias_set): Likewise.\n+\t* gcc-interface/trans.c (Identifier_to_gnu): Likewise.\n+\t(Attribute_to_gnu): Likewise.\n+\t(call_to_gnu): Likewise.\n+\t(gnat_to_gnu): Likewise.\n+\t(add_decl_expr): Likewise.\n+\t(convert_with_check): Likewise.\n+\t(addressable_p): Likewise.\n+\t(maybe_implicit_deref): Likewise.\n+\t(protect_multiple_eval): Likewise.\n+\t(gnat_stabilize_reference_1): Likewise.\n+\t* gcc-interface/utils.c (gnat_pushdecl): Likewise.\n+\t(finish_record_type): Likewise.\n+\t(rest_of_record_type_compilation): Likewise.\n+\t(create_type_decl): Likewise.\n+\t(gnat_types_compatible_p): Likewise.\n+\t(build_template): Likewise.\n+\t(convert_vms_descriptor64): Likewise.\n+\t(convert_vms_descriptor32): Likewise.\n+\t(build_unc_object_type_from_ptr): Likewise.\n+\t(update_pointer_to): Likewise.\n+\t(convert_to_fat_pointer): Likewise.\n+\t(convert_to_fat_pointer): Likewise.\n+\t(convert): Likewise.\n+\t(remove_conversions): Likewise.\n+\t(maybe_unconstrained_array): Likewise.\n+\t(unchecked_convert): Likewise.\n+\t(handle_vector_type_attribute): Likewise.\n+\t* gcc-interface/utils2.c (build_binary_op): Likewise.\n+\t(build_unary_op): Likewise.\n+\t(build_allocator): Likewise.\n+\n 2009-10-16  Eric Botcazou  <ebotcazou@adacore.com>\n \n \t* exp_dbug.ads: Adjust type names in comments."}, {"sha": "67a16ef0eb8a258036cb9bddc282da1879467d57", "filename": "gcc/ada/gcc-interface/ada-tree.h", "status": "modified", "additions": 10, "deletions": 8, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/315cff155219ea11bf95209165121376b12fe06e/gcc%2Fada%2Fgcc-interface%2Fada-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/315cff155219ea11bf95209165121376b12fe06e/gcc%2Fada%2Fgcc-interface%2Fada-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Fada-tree.h?ref=315cff155219ea11bf95209165121376b12fe06e", "patch": "@@ -65,11 +65,11 @@ do {\t\t\t\t\t\t\t    \\\n \n /* For RECORD_TYPE, UNION_TYPE, and QUAL_UNION_TYPE, nonzero if this is a\n    record being used as a fat pointer (only true for RECORD_TYPE).  */\n-#define TYPE_IS_FAT_POINTER_P(NODE) \\\n+#define TYPE_FAT_POINTER_P(NODE) \\\n   TYPE_LANG_FLAG_0 (RECORD_OR_UNION_CHECK (NODE))\n \n-#define TYPE_FAT_POINTER_P(NODE) \\\n-  (TREE_CODE (NODE) == RECORD_TYPE && TYPE_IS_FAT_POINTER_P (NODE))\n+#define TYPE_IS_FAT_POINTER_P(NODE) \\\n+  (TREE_CODE (NODE) == RECORD_TYPE && TYPE_FAT_POINTER_P (NODE))\n \n /* For integral types and array types, nonzero if this is a packed array type\n    used for bit-packed types.  Such types should not be extended to a larger\n@@ -117,15 +117,15 @@ do {\t\t\t\t\t\t\t    \\\n   TYPE_LANG_FLAG_3 (INTEGER_TYPE_CHECK (NODE))\n \n /* True if NODE is a thin pointer.  */\n-#define TYPE_THIN_POINTER_P(NODE)\t\t\t\\\n+#define TYPE_IS_THIN_POINTER_P(NODE)\t\t\t\\\n   (POINTER_TYPE_P (NODE)\t\t\t\t\\\n    && TREE_CODE (TREE_TYPE (NODE)) == RECORD_TYPE\t\\\n    && TYPE_CONTAINS_TEMPLATE_P (TREE_TYPE (NODE)))\n \n /* True if TYPE is either a fat or thin pointer to an unconstrained\n    array.  */\n-#define TYPE_FAT_OR_THIN_POINTER_P(NODE) \\\n-  (TYPE_FAT_POINTER_P (NODE) || TYPE_THIN_POINTER_P (NODE))\n+#define TYPE_IS_FAT_OR_THIN_POINTER_P(NODE) \\\n+  (TYPE_IS_FAT_POINTER_P (NODE) || TYPE_IS_THIN_POINTER_P (NODE))\n \n /* For INTEGER_TYPEs, nonzero if the type has a biased representation.  */\n #define TYPE_BIASED_REPRESENTATION_P(NODE) \\\n@@ -143,7 +143,6 @@ do {\t\t\t\t\t\t\t    \\\n    is a dummy type, made to correspond to a private or incomplete type.  */\n #define TYPE_DUMMY_P(NODE) TYPE_LANG_FLAG_4 (NODE)\n \n-/* True if TYPE is such a dummy type.  */\n #define TYPE_IS_DUMMY_P(NODE) \\\n   ((TREE_CODE (NODE) == VOID_TYPE || TREE_CODE (NODE) == RECORD_TYPE\t\\\n     || TREE_CODE (NODE) == UNION_TYPE || TREE_CODE (NODE) == ENUMERAL_TYPE) \\\n@@ -160,7 +159,10 @@ do {\t\t\t\t\t\t\t    \\\n \n /* For a RECORD_TYPE, nonzero if this was made just to supply needed\n    padding or alignment.  */\n-#define TYPE_IS_PADDING_P(NODE) TYPE_LANG_FLAG_5 (RECORD_TYPE_CHECK (NODE))\n+#define TYPE_PADDING_P(NODE) TYPE_LANG_FLAG_5 (RECORD_TYPE_CHECK (NODE))\n+\n+#define TYPE_IS_PADDING_P(NODE) \\\n+  (TREE_CODE (NODE) == RECORD_TYPE && TYPE_PADDING_P (NODE))\n \n /* True if TYPE can alias any other types.  */\n #define TYPE_UNIVERSAL_ALIASING_P(NODE) TYPE_LANG_FLAG_6 (NODE)"}, {"sha": "a2af179817036c07b23759f0b92afba7ca04426a", "filename": "gcc/ada/gcc-interface/decl.c", "status": "modified", "additions": 43, "deletions": 58, "changes": 101, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/315cff155219ea11bf95209165121376b12fe06e/gcc%2Fada%2Fgcc-interface%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/315cff155219ea11bf95209165121376b12fe06e/gcc%2Fada%2Fgcc-interface%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Fdecl.c?ref=315cff155219ea11bf95209165121376b12fe06e", "patch": "@@ -676,8 +676,6 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t\t       despite having a nominal type with self-referential\n \t\t       size, we can get the size directly from it.  */\n \t\t    if (TREE_CODE (gnu_expr) == COMPONENT_REF\n-\t\t\t&& TREE_CODE (TREE_TYPE (TREE_OPERAND (gnu_expr, 0)))\n-\t\t\t   == RECORD_TYPE\n \t\t\t&& TYPE_IS_PADDING_P\n \t\t\t   (TREE_TYPE (TREE_OPERAND (gnu_expr, 0)))\n \t\t\t&& TREE_CODE (TREE_OPERAND (gnu_expr, 0)) == VAR_DECL\n@@ -852,8 +850,6 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t    /* If the renamed object had padding, strip off the reference\n \t       to the inner object and reset our type.  */\n \t    if ((TREE_CODE (gnu_expr) == COMPONENT_REF\n-\t\t && TREE_CODE (TREE_TYPE (TREE_OPERAND (gnu_expr, 0)))\n-\t\t    == RECORD_TYPE\n \t\t && TYPE_IS_PADDING_P (TREE_TYPE (TREE_OPERAND (gnu_expr, 0))))\n \t\t/* Strip useless conversions around the object.  */\n \t\t|| (TREE_CODE (gnu_expr) == NOP_EXPR\n@@ -1018,14 +1014,14 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t    && TREE_CODE (gnu_type) == RECORD_TYPE\n \t    && (TYPE_CONTAINS_TEMPLATE_P (gnu_type)\n \t        /* Beware that padding might have been introduced above.  */\n-\t\t|| (TYPE_IS_PADDING_P (gnu_type)\n+\t\t|| (TYPE_PADDING_P (gnu_type)\n \t\t    && TREE_CODE (TREE_TYPE (TYPE_FIELDS (gnu_type)))\n \t\t       == RECORD_TYPE\n \t\t    && TYPE_CONTAINS_TEMPLATE_P\n \t\t       (TREE_TYPE (TYPE_FIELDS (gnu_type))))))\n \t  {\n \t    tree template_field\n-\t      = TYPE_IS_PADDING_P (gnu_type)\n+\t      = TYPE_PADDING_P (gnu_type)\n \t\t? TYPE_FIELDS (TREE_TYPE (TYPE_FIELDS (gnu_type)))\n \t\t: TYPE_FIELDS (gnu_type);\n \n@@ -1049,17 +1045,16 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \tif (gnu_expr\n \t    && TREE_CODE (gnu_type) != UNCONSTRAINED_ARRAY_TYPE\n \t    && !CONTAINS_PLACEHOLDER_P (TYPE_SIZE (gnu_type))\n-\t    && !(TREE_CODE (gnu_type) == RECORD_TYPE\n-\t\t && TYPE_IS_PADDING_P (gnu_type)\n-\t\t && (CONTAINS_PLACEHOLDER_P\n-\t\t     (TYPE_SIZE (TREE_TYPE (TYPE_FIELDS (gnu_type)))))))\n+\t    && !(TYPE_IS_PADDING_P (gnu_type)\n+\t\t && CONTAINS_PLACEHOLDER_P\n+\t\t    (TYPE_SIZE (TREE_TYPE (TYPE_FIELDS (gnu_type))))))\n \t  gnu_expr = convert (gnu_type, gnu_expr);\n \n \t/* If this is a pointer and it does not have an initializing\n \t   expression, initialize it to NULL, unless the object is\n \t   imported.  */\n \tif (definition\n-\t    && (POINTER_TYPE_P (gnu_type) || TYPE_FAT_POINTER_P (gnu_type))\n+\t    && (POINTER_TYPE_P (gnu_type) || TYPE_IS_FAT_POINTER_P (gnu_type))\n \t    && !Is_Imported (gnat_entity) && !gnu_expr)\n \t  gnu_expr = integer_zero_node;\n \n@@ -1278,10 +1273,9 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \tif (gnu_expr\n \t    && TREE_CODE (gnu_type) != UNCONSTRAINED_ARRAY_TYPE\n \t    && !CONTAINS_PLACEHOLDER_P (TYPE_SIZE (gnu_type))\n-\t    && !(TREE_CODE (gnu_type) == RECORD_TYPE\n-\t\t && TYPE_IS_PADDING_P (gnu_type)\n-\t\t && (CONTAINS_PLACEHOLDER_P\n-\t\t     (TYPE_SIZE (TREE_TYPE (TYPE_FIELDS (gnu_type)))))))\n+\t    && !(TYPE_IS_PADDING_P (gnu_type)\n+\t\t && CONTAINS_PLACEHOLDER_P\n+\t\t    (TYPE_SIZE (TREE_TYPE (TYPE_FIELDS (gnu_type))))))\n \t  gnu_expr = convert (gnu_type, gnu_expr);\n \n \t/* If this name is external or there was a name specified, use it,\n@@ -1303,8 +1297,7 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t    && gnu_expr && TREE_CONSTANT (gnu_expr)\n \t    && AGGREGATE_TYPE_P (gnu_type)\n \t    && host_integerp (TYPE_SIZE_UNIT (gnu_type), 1)\n-\t    && !(TREE_CODE (gnu_type) == RECORD_TYPE\n-\t\t && TYPE_IS_PADDING_P (gnu_type)\n+\t    && !(TYPE_IS_PADDING_P (gnu_type)\n \t\t && !host_integerp (TYPE_SIZE_UNIT\n \t\t\t\t    (TREE_TYPE (TYPE_FIELDS (gnu_type))), 1)))\n \t  static_p = true;\n@@ -1686,7 +1679,7 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t\t\t\t\t gnu_field_type, gnu_type, 1, 0, 0, 0);\n \n \t  finish_record_type (gnu_type, gnu_field, 0, false);\n-\t  TYPE_IS_PADDING_P (gnu_type) = 1;\n+\t  TYPE_PADDING_P (gnu_type) = 1;\n \n \t  relate_alias_sets (gnu_type, gnu_field_type, ALIAS_SET_COPY);\n \t}\n@@ -1834,7 +1827,7 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t/* Do not finalize this record type since the types of its fields\n \t   are still incomplete at this point.  */\n \tfinish_record_type (gnu_fat_type, tem, 0, true);\n-\tTYPE_IS_FAT_POINTER_P (gnu_fat_type) = 1;\n+\tTYPE_FAT_POINTER_P (gnu_fat_type) = 1;\n \n \t/* Build a reference to the template from a PLACEHOLDER_EXPR that\n \t   is the fat pointer.  This will be used to access the individual\n@@ -2476,7 +2469,7 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t      gnu_inner = gnu_type;\n \t      while (TREE_CODE (gnu_inner) == RECORD_TYPE\n \t\t     && (TYPE_JUSTIFIED_MODULAR_P (gnu_inner)\n-\t\t\t || TYPE_IS_PADDING_P (gnu_inner)))\n+\t\t\t || TYPE_PADDING_P (gnu_inner)))\n \t\tgnu_inner = TREE_TYPE (TYPE_FIELDS (gnu_inner));\n \n \t      /* We need to attach the index type to the type we just made so\n@@ -2985,8 +2978,7 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t      copy_and_substitute_in_size (gnu_type, gnu_base_type,\n \t\t\t\t\t   gnu_subst_list);\n \n-\t      if (TREE_CODE (gnu_base_type) == RECORD_TYPE\n-\t\t  && TYPE_IS_PADDING_P (gnu_base_type))\n+\t      if (TYPE_IS_PADDING_P (gnu_base_type))\n \t\tgnu_unpad_base_type = TREE_TYPE (TYPE_FIELDS (gnu_base_type));\n \t      else\n \t\tgnu_unpad_base_type = gnu_base_type;\n@@ -3096,7 +3088,7 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t\t      {\n \t\t\tgnu_size = DECL_SIZE (gnu_old_field);\n \t\t\tif (TREE_CODE (gnu_field_type) == RECORD_TYPE\n-\t\t\t    && !TYPE_IS_FAT_POINTER_P (gnu_field_type)\n+\t\t\t    && !TYPE_FAT_POINTER_P (gnu_field_type)\n \t\t\t    && host_integerp (TYPE_SIZE (gnu_field_type), 1))\n \t\t\t  gnu_field_type\n \t\t\t    = make_packable_type (gnu_field_type, true);\n@@ -3464,7 +3456,7 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t\t/* Make sure we can place this into a register.  */\n \t\tTYPE_ALIGN (gnu_type)\n \t\t  = MIN (BIGGEST_ALIGNMENT, 2 * POINTER_SIZE);\n-\t\tTYPE_IS_FAT_POINTER_P (gnu_type) = 1;\n+\t\tTYPE_FAT_POINTER_P (gnu_type) = 1;\n \n \t\t/* Do not finalize this record type since the types of\n \t\t   its fields are incomplete.  */\n@@ -3598,11 +3590,11 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \tif ((! in_main_unit || is_from_limited_with) && made_dummy)\n \t  {\n \t    tree gnu_old_type\n-\t      = TYPE_FAT_POINTER_P (gnu_type)\n+\t      = TYPE_IS_FAT_POINTER_P (gnu_type)\n \t\t? TYPE_UNCONSTRAINED_ARRAY (gnu_type) : TREE_TYPE (gnu_type);\n \n \t    if (esize == POINTER_SIZE\n-\t\t&& (got_fat_p || TYPE_FAT_POINTER_P (gnu_type)))\n+\t\t&& (got_fat_p || TYPE_IS_FAT_POINTER_P (gnu_type)))\n \t      gnu_type\n \t\t= build_pointer_type\n \t\t  (TYPE_OBJECT_RECORD_TYPE\n@@ -3914,8 +3906,7 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t/* If the type is a padded type and the underlying type would not\n \t   be passed by reference or this function has a foreign convention,\n \t   return the underlying type.  */\n-\telse if (TREE_CODE (gnu_return_type) == RECORD_TYPE\n-\t\t && TYPE_IS_PADDING_P (gnu_return_type)\n+\telse if (TYPE_IS_PADDING_P (gnu_return_type)\n \t\t && (!default_pass_by_ref (TREE_TYPE\n \t\t\t\t\t   (TYPE_FIELDS (gnu_return_type)))\n \t\t     || Has_Foreign_Convention (gnat_entity)))\n@@ -4053,7 +4044,7 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t\t   between two calls, so they can't be CSE'ed.  The latter\n \t\t   case also handles by-ref parameters.  */\n \t\tif (POINTER_TYPE_P (gnu_param_type)\n-\t\t    || TYPE_FAT_POINTER_P (gnu_param_type))\n+\t\t    || TYPE_IS_FAT_POINTER_P (gnu_param_type))\n \t\t  const_flag = false;\n \t      }\n \n@@ -4416,7 +4407,7 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t      else if ((TREE_CODE (gnu_type) == RECORD_TYPE\n \t\t\t|| TREE_CODE (gnu_type) == UNION_TYPE\n \t\t\t|| TREE_CODE (gnu_type) == QUAL_UNION_TYPE)\n-\t\t       && !TYPE_IS_FAT_POINTER_P (gnu_type))\n+\t\t       && !TYPE_FAT_POINTER_P (gnu_type))\n \t\tsize = rm_size (gnu_type);\n \t      else\n \t        size = TYPE_SIZE (gnu_type);\n@@ -4447,8 +4438,7 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \tgnu_type = maybe_pad_type (gnu_type, gnu_size, align, gnat_entity,\n \t\t\t\t   false, true, definition, false);\n \n-      if (TREE_CODE (gnu_type) == RECORD_TYPE\n-\t  && TYPE_IS_PADDING_P (gnu_type))\n+      if (TYPE_IS_PADDING_P (gnu_type))\n \t{\n \t  gnu_entity_name = TYPE_NAME (gnu_type);\n \t  if (TREE_CODE (gnu_entity_name) == TYPE_DECL)\n@@ -4704,8 +4694,7 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n       tree gnu_low_bound, gnu_high_bound;\n \n       /* If this is a padded type, we need to use the underlying type.  */\n-      if (TREE_CODE (gnu_scalar_type) == RECORD_TYPE\n-\t  && TYPE_IS_PADDING_P (gnu_scalar_type))\n+      if (TYPE_IS_PADDING_P (gnu_scalar_type))\n \tgnu_scalar_type = TREE_TYPE (TYPE_FIELDS (gnu_scalar_type));\n \n       /* If this is a floating point type and we haven't set a floating\n@@ -4851,7 +4840,7 @@ get_unpadded_type (Entity_Id gnat_entity)\n {\n   tree type = gnat_to_gnu_type (gnat_entity);\n \n-  if (TREE_CODE (type) == RECORD_TYPE && TYPE_IS_PADDING_P (type))\n+  if (TYPE_IS_PADDING_P (type))\n     type = TREE_TYPE (TYPE_FIELDS (type));\n \n   return type;\n@@ -4984,7 +4973,7 @@ gnat_to_gnu_component_type (Entity_Id gnat_array, bool definition,\n       && !Has_Aliased_Components (gnat_array)\n       && !Strict_Alignment (Component_Type (gnat_array))\n       && TREE_CODE (gnu_type) == RECORD_TYPE\n-      && !TYPE_IS_FAT_POINTER_P (gnu_type)\n+      && !TYPE_FAT_POINTER_P (gnu_type)\n       && host_integerp (TYPE_SIZE (gnu_type), 1))\n     gnu_type = make_packable_type (gnu_type, false);\n \n@@ -5088,8 +5077,7 @@ gnat_to_gnu_param (Entity_Id gnat_param, Mechanism_Type mech,\n \n   /* If this is either a foreign function or if the underlying type won't\n      be passed by reference, strip off possible padding type.  */\n-  if (TREE_CODE (gnu_param_type) == RECORD_TYPE\n-      && TYPE_IS_PADDING_P (gnu_param_type))\n+  if (TYPE_IS_PADDING_P (gnu_param_type))\n     {\n       tree unpadded_type = TREE_TYPE (TYPE_FIELDS (gnu_param_type));\n \n@@ -5161,7 +5149,7 @@ gnat_to_gnu_param (Entity_Id gnat_param, Mechanism_Type mech,\n     }\n \n   /* Fat pointers are passed as thin pointers for foreign conventions.  */\n-  else if (foreign && TYPE_FAT_POINTER_P (gnu_param_type))\n+  else if (foreign && TYPE_IS_FAT_POINTER_P (gnu_param_type))\n     gnu_param_type\n       = make_type_from_size (gnu_param_type, size_int (POINTER_SIZE), 0);\n \n@@ -5462,7 +5450,7 @@ relate_alias_sets (tree gnu_new_type, tree gnu_old_type, enum alias_set_op op)\n      see the inner types.  */\n   while (TREE_CODE (gnu_old_type) == RECORD_TYPE\n \t && (TYPE_JUSTIFIED_MODULAR_P (gnu_old_type)\n-\t     || TYPE_IS_PADDING_P (gnu_old_type)))\n+\t     || TYPE_PADDING_P (gnu_old_type)))\n     gnu_old_type = TREE_TYPE (TYPE_FIELDS (gnu_old_type));\n \n   /* Unconstrained array types are deemed incomplete and would thus be given\n@@ -5928,7 +5916,7 @@ make_packable_type (tree type, bool in_record)\n   TYPE_JUSTIFIED_MODULAR_P (new_type) = TYPE_JUSTIFIED_MODULAR_P (type);\n   TYPE_CONTAINS_TEMPLATE_P (new_type) = TYPE_CONTAINS_TEMPLATE_P (type);\n   if (TREE_CODE (type) == RECORD_TYPE)\n-    TYPE_IS_PADDING_P (new_type) = TYPE_IS_PADDING_P (type);\n+    TYPE_PADDING_P (new_type) = TYPE_PADDING_P (type);\n \n   /* If we are in a record and have a small size, set the alignment to\n      try for an integral mode.  Otherwise set it to try for a smaller\n@@ -5971,7 +5959,7 @@ make_packable_type (tree type, bool in_record)\n       if ((TREE_CODE (new_field_type) == RECORD_TYPE\n \t   || TREE_CODE (new_field_type) == UNION_TYPE\n \t   || TREE_CODE (new_field_type) == QUAL_UNION_TYPE)\n-\t  && !TYPE_IS_FAT_POINTER_P (new_field_type)\n+\t  && !TYPE_FAT_POINTER_P (new_field_type)\n \t  && host_integerp (TYPE_SIZE (new_field_type), 1))\n \tnew_field_type = make_packable_type (new_field_type, true);\n \n@@ -5983,7 +5971,7 @@ make_packable_type (tree type, bool in_record)\n \t  && (TREE_CODE (new_field_type) == RECORD_TYPE\n \t      || TREE_CODE (new_field_type) == UNION_TYPE\n \t      || TREE_CODE (new_field_type) == QUAL_UNION_TYPE)\n-\t  && !TYPE_IS_FAT_POINTER_P (new_field_type)\n+\t  && !TYPE_FAT_POINTER_P (new_field_type)\n \t  && !TYPE_CONTAINS_TEMPLATE_P (new_field_type)\n \t  && TYPE_ADA_SIZE (new_field_type))\n \tnew_size = TYPE_ADA_SIZE (new_field_type);\n@@ -6012,8 +6000,7 @@ make_packable_type (tree type, bool in_record)\n \n   /* If this is a padding record, we never want to make the size smaller\n      than what was specified.  For QUAL_UNION_TYPE, also copy the size.  */\n-  if ((TREE_CODE (type) == RECORD_TYPE && TYPE_IS_PADDING_P (type))\n-      || TREE_CODE (type) == QUAL_UNION_TYPE)\n+  if (TYPE_IS_PADDING_P (type) || TREE_CODE (type) == QUAL_UNION_TYPE)\n     {\n       TYPE_SIZE (new_type) = TYPE_SIZE (type);\n       TYPE_SIZE_UNIT (new_type) = TYPE_SIZE_UNIT (type);\n@@ -6066,7 +6053,7 @@ maybe_pad_type (tree type, tree size, unsigned int align,\n      off the padding, since we will either be returning the inner type\n      or repadding it.  If no size or alignment is specified, use that of\n      the original padded type.  */\n-  if (TREE_CODE (type) == RECORD_TYPE && TYPE_IS_PADDING_P (type))\n+  if (TYPE_IS_PADDING_P (type))\n     {\n       if ((!size\n \t   || operand_equal_p (round_up (size,\n@@ -6115,7 +6102,7 @@ maybe_pad_type (tree type, tree size, unsigned int align,\n      generate incorrect debugging information.  So make a new record\n      type and name.  */\n   record = make_node (RECORD_TYPE);\n-  TYPE_IS_PADDING_P (record) = 1;\n+  TYPE_PADDING_P (record) = 1;\n \n   if (Present (gnat_entity))\n     TYPE_NAME (record) = create_concat_name (gnat_entity, \"PAD\");\n@@ -6438,7 +6425,7 @@ gnat_to_gnu_field (Entity_Id gnat_field, tree gnu_record_type, int packed,\n      from a component clause.  */\n \n   if (TREE_CODE (gnu_field_type) == RECORD_TYPE\n-      && !TYPE_IS_FAT_POINTER_P (gnu_field_type)\n+      && !TYPE_FAT_POINTER_P (gnu_field_type)\n       && host_integerp (TYPE_SIZE (gnu_field_type), 1)\n       && (packed == 1\n \t  || (gnu_size\n@@ -6668,8 +6655,7 @@ is_variable_size (tree type)\n   if (!TREE_CONSTANT (TYPE_SIZE (type)))\n     return true;\n \n-  if (TREE_CODE (type) == RECORD_TYPE\n-      && TYPE_IS_PADDING_P (type)\n+  if (TYPE_IS_PADDING_P (type)\n       && !TREE_CONSTANT (DECL_SIZE (TYPE_FIELDS (type))))\n     return true;\n \n@@ -7218,7 +7204,7 @@ annotate_object (Entity_Id gnat_entity, tree gnu_type, tree size, bool by_ref)\n {\n   if (by_ref)\n     {\n-      if (TYPE_FAT_POINTER_P (gnu_type))\n+      if (TYPE_IS_FAT_POINTER_P (gnu_type))\n \tgnu_type = TYPE_UNCONSTRAINED_ARRAY (gnu_type);\n       else\n \tgnu_type = TREE_TYPE (gnu_type);\n@@ -7533,7 +7519,7 @@ validate_size (Uint uint_size, tree gnu_type, Entity_Id gnat_object,\n \n   /* If this is an access type or a fat pointer, the minimum size is that given\n      by the smallest integral mode that's valid for pointers.  */\n-  if ((TREE_CODE (gnu_type) == POINTER_TYPE) || TYPE_FAT_POINTER_P (gnu_type))\n+  if (TREE_CODE (gnu_type) == POINTER_TYPE || TYPE_IS_FAT_POINTER_P (gnu_type))\n     {\n       enum machine_mode p_mode;\n \n@@ -7627,8 +7613,7 @@ set_rm_size (Uint uint_size, tree gnu_type, Entity_Id gnat_entity)\n       || (AGGREGATE_TYPE_P (gnu_type)\n \t  && !(TREE_CODE (gnu_type) == ARRAY_TYPE\n \t       && TYPE_PACKED_ARRAY_TYPE_P (gnu_type))\n-\t  && !(TREE_CODE (gnu_type) == RECORD_TYPE\n-\t       && TYPE_IS_PADDING_P (gnu_type)\n+\t  && !(TYPE_IS_PADDING_P (gnu_type)\n \t       && TREE_CODE (TREE_TYPE (TYPE_FIELDS (gnu_type))) == ARRAY_TYPE\n \t       && TYPE_PACKED_ARRAY_TYPE_P (TREE_TYPE (TYPE_FIELDS (gnu_type))))\n \t  && tree_int_cst_lt (size, old_size)))\n@@ -7651,7 +7636,7 @@ set_rm_size (Uint uint_size, tree gnu_type, Entity_Id gnat_entity)\n   else if ((TREE_CODE (gnu_type) == RECORD_TYPE\n \t    || TREE_CODE (gnu_type) == UNION_TYPE\n \t    || TREE_CODE (gnu_type) == QUAL_UNION_TYPE)\n-\t   && !TYPE_IS_FAT_POINTER_P (gnu_type))\n+\t   && !TYPE_FAT_POINTER_P (gnu_type))\n     SET_TYPE_ADA_SIZE (gnu_type, size);\n }\n \f\n@@ -7718,7 +7703,7 @@ make_type_from_size (tree type, tree size_tree, bool for_biased)\n     case RECORD_TYPE:\n       /* Do something if this is a fat pointer, in which case we\n \t may need to return the thin pointer.  */\n-      if (TYPE_IS_FAT_POINTER_P (type) && size < POINTER_SIZE * 2)\n+      if (TYPE_FAT_POINTER_P (type) && size < POINTER_SIZE * 2)\n \t{\n \t  enum machine_mode p_mode = mode_for_size (size, MODE_INT, 0);\n \t  if (!targetm.valid_pointer_mode (p_mode))\n@@ -7733,7 +7718,7 @@ make_type_from_size (tree type, tree size_tree, bool for_biased)\n     case POINTER_TYPE:\n       /* Only do something if this is a thin pointer, in which case we\n \t may need to return the fat pointer.  */\n-      if (TYPE_THIN_POINTER_P (type) && size >= POINTER_SIZE * 2)\n+      if (TYPE_IS_THIN_POINTER_P (type) && size >= POINTER_SIZE * 2)\n \treturn\n \t  build_pointer_type (TYPE_UNCONSTRAINED_ARRAY (TREE_TYPE (type)));\n       break;\n@@ -8384,7 +8369,7 @@ rm_size (tree gnu_type)\n   if ((TREE_CODE (gnu_type) == RECORD_TYPE\n        || TREE_CODE (gnu_type) == UNION_TYPE\n        || TREE_CODE (gnu_type) == QUAL_UNION_TYPE)\n-      && !TYPE_IS_FAT_POINTER_P (gnu_type)\n+      && !TYPE_FAT_POINTER_P (gnu_type)\n       && TYPE_ADA_SIZE (gnu_type))\n     return TYPE_ADA_SIZE (gnu_type);\n "}, {"sha": "570bd111a95195177d87aacc36a8bde52cc19fc5", "filename": "gcc/ada/gcc-interface/misc.c", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/315cff155219ea11bf95209165121376b12fe06e/gcc%2Fada%2Fgcc-interface%2Fmisc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/315cff155219ea11bf95209165121376b12fe06e/gcc%2Fada%2Fgcc-interface%2Fmisc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Fmisc.c?ref=315cff155219ea11bf95209165121376b12fe06e", "patch": "@@ -527,7 +527,7 @@ gnat_print_type (FILE *file, tree node, int indent)\n       break;\n \n     case RECORD_TYPE:\n-      if (TYPE_IS_FAT_POINTER_P (node) || TYPE_CONTAINS_TEMPLATE_P (node))\n+      if (TYPE_FAT_POINTER_P (node) || TYPE_CONTAINS_TEMPLATE_P (node))\n \tprint_node (file, \"unconstrained array\",\n \t\t    TYPE_UNCONSTRAINED_ARRAY (node), indent + 4);\n       else\n@@ -600,8 +600,7 @@ static alias_set_type\n gnat_get_alias_set (tree type)\n {\n   /* If this is a padding type, use the type of the first field.  */\n-  if (TREE_CODE (type) == RECORD_TYPE\n-      && TYPE_IS_PADDING_P (type))\n+  if (TYPE_IS_PADDING_P (type))\n     return get_alias_set (TREE_TYPE (TYPE_FIELDS (type)));\n \n   /* If the type is an unconstrained array, use the type of the"}, {"sha": "ffcc72aac0fb188d4fc3c42d14a35db15fbcac2a", "filename": "gcc/ada/gcc-interface/trans.c", "status": "modified", "additions": 32, "deletions": 51, "changes": 83, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/315cff155219ea11bf95209165121376b12fe06e/gcc%2Fada%2Fgcc-interface%2Ftrans.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/315cff155219ea11bf95209165121376b12fe06e/gcc%2Fada%2Fgcc-interface%2Ftrans.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Ftrans.c?ref=315cff155219ea11bf95209165121376b12fe06e", "patch": "@@ -946,8 +946,7 @@ Identifier_to_gnu (Node_Id gnat_node, tree *gnu_result_type_p)\n       || Is_Constr_Subt_For_UN_Aliased (gnat_temp_type))\n     {\n       gnu_result_type = TREE_TYPE (gnu_result);\n-      if (TREE_CODE (gnu_result_type) == RECORD_TYPE\n-\t  && TYPE_IS_PADDING_P (gnu_result_type))\n+      if (TYPE_IS_PADDING_P (gnu_result_type))\n \tgnu_result_type = TREE_TYPE (TYPE_FIELDS (gnu_result_type));\n     }\n \n@@ -1256,7 +1255,7 @@ Attribute_to_gnu (Node_Id gnat_node, tree *gnu_result_type_p, int attribute)\n \t/* If this is an unconstrained array, we know the object has been\n \t   allocated with the template in front of the object.  So compute\n \t   the template address.  */\n-\tif (TYPE_FAT_POINTER_P (TREE_TYPE (gnu_ptr)))\n+\tif (TYPE_IS_FAT_POINTER_P (TREE_TYPE (gnu_ptr)))\n \t  gnu_ptr\n \t    = convert (build_pointer_type\n \t\t       (TYPE_OBJECT_RECORD_TYPE\n@@ -1334,8 +1333,7 @@ Attribute_to_gnu (Node_Id gnat_node, tree *gnu_result_type_p, int attribute)\n \t     of the relevant field.  Using the MAX of those two produces the\n \t     right result in all case.  Don't use the size of the field if it's\n \t     a self-referential type, since that's never what's wanted.  */\n-\t  if (TREE_CODE (gnu_type) == RECORD_TYPE\n-\t      && TYPE_IS_PADDING_P (gnu_type)\n+\t  if (TYPE_IS_PADDING_P (gnu_type)\n \t      && TREE_CODE (gnu_expr) == COMPONENT_REF)\n \t    {\n \t      gnu_result = rm_size (gnu_type);\n@@ -1353,7 +1351,7 @@ Attribute_to_gnu (Node_Id gnat_node, tree *gnu_result_type_p, int attribute)\n \t      tree gnu_ptr_type\n \t\t= TREE_TYPE (gnat_to_gnu (Prefix (gnat_deref)));\n \n-\t      if (TYPE_FAT_OR_THIN_POINTER_P (gnu_ptr_type)\n+\t      if (TYPE_IS_FAT_OR_THIN_POINTER_P (gnu_ptr_type)\n \t\t  && Present (gnat_actual_subtype))\n \t\t{\n \t\t  tree gnu_actual_obj_type\n@@ -1403,9 +1401,7 @@ Attribute_to_gnu (Node_Id gnat_node, tree *gnu_result_type_p, int attribute)\n \tunsigned int align;\n \n \tif (TREE_CODE (gnu_prefix) == COMPONENT_REF\n-\t    && (TREE_CODE (TREE_TYPE (TREE_OPERAND (gnu_prefix, 0)))\n-\t\t== RECORD_TYPE)\n-\t    && (TYPE_IS_PADDING_P (TREE_TYPE (TREE_OPERAND (gnu_prefix, 0)))))\n+\t    && TYPE_IS_PADDING_P (TREE_TYPE (TREE_OPERAND (gnu_prefix, 0))))\n \t  gnu_prefix = TREE_OPERAND (gnu_prefix, 0);\n \n \tgnu_type = TREE_TYPE (gnu_prefix);\n@@ -1742,9 +1738,7 @@ Attribute_to_gnu (Node_Id gnat_node, tree *gnu_result_type_p, int attribute)\n \n     case Attr_Component_Size:\n       if (TREE_CODE (gnu_prefix) == COMPONENT_REF\n-\t  && (TREE_CODE (TREE_TYPE (TREE_OPERAND (gnu_prefix, 0)))\n-\t      == RECORD_TYPE)\n-\t  && (TYPE_IS_PADDING_P (TREE_TYPE (TREE_OPERAND (gnu_prefix, 0)))))\n+\t  && TYPE_IS_PADDING_P (TREE_TYPE (TREE_OPERAND (gnu_prefix, 0))))\n \tgnu_prefix = TREE_OPERAND (gnu_prefix, 0);\n \n       gnu_prefix = maybe_implicit_deref (gnu_prefix);\n@@ -2562,10 +2556,8 @@ call_to_gnu (Node_Id gnat_node, tree *gnu_result_type_p, tree gnu_target)\n \n \t  /* Otherwise remove unpadding from the object and reset the copy.  */\n \t  else if (TREE_CODE (gnu_name) == COMPONENT_REF\n-\t\t   && ((TREE_CODE (TREE_TYPE (TREE_OPERAND (gnu_name, 0)))\n-\t\t\t== RECORD_TYPE)\n-\t\t\t&& (TYPE_IS_PADDING_P\n-\t\t\t    (TREE_TYPE (TREE_OPERAND (gnu_name, 0))))))\n+\t\t   && TYPE_IS_PADDING_P\n+\t\t      (TREE_TYPE (TREE_OPERAND (gnu_name, 0))))\n \t    gnu_name = gnu_copy = TREE_OPERAND (gnu_name, 0);\n \n \t  /* Otherwise convert to the nominal type of the object if it's\n@@ -2604,7 +2596,6 @@ call_to_gnu (Node_Id gnat_node, tree *gnu_result_type_p, tree gnu_target)\n       /* If this was a procedure call, we may not have removed any padding.\n \t So do it here for the part we will use as an input, if any.  */\n       if (Ekind (gnat_formal) != E_Out_Parameter\n-\t  && TREE_CODE (TREE_TYPE (gnu_actual)) == RECORD_TYPE\n \t  && TYPE_IS_PADDING_P (TREE_TYPE (gnu_actual)))\n \tgnu_actual = convert (get_unpadded_type (Etype (gnat_actual)),\n \t\t\t      gnu_actual);\n@@ -2674,8 +2665,7 @@ call_to_gnu (Node_Id gnat_node, tree *gnu_result_type_p, tree gnu_target)\n \t      gnu_actual = gnu_name;\n \n \t      /* If we have a padded type, be sure we've removed padding.  */\n-\t      if (TREE_CODE (TREE_TYPE (gnu_actual)) == RECORD_TYPE\n-\t\t  && TYPE_IS_PADDING_P (TREE_TYPE (gnu_actual))\n+\t      if (TYPE_IS_PADDING_P (TREE_TYPE (gnu_actual))\n \t\t  && TREE_CODE (gnu_actual) != SAVE_EXPR)\n \t\tgnu_actual = convert (get_unpadded_type (Etype (gnat_actual)),\n \t\t\t\t      gnu_actual);\n@@ -2708,8 +2698,7 @@ call_to_gnu (Node_Id gnat_node, tree *gnu_result_type_p, tree gnu_target)\n \t  gnu_actual = maybe_implicit_deref (gnu_actual);\n \t  gnu_actual = maybe_unconstrained_array (gnu_actual);\n \n-\t  if (TREE_CODE (gnu_formal_type) == RECORD_TYPE\n-\t      && TYPE_IS_PADDING_P (gnu_formal_type))\n+\t  if (TYPE_IS_PADDING_P (gnu_formal_type))\n \t    {\n \t      gnu_formal_type = TREE_TYPE (TYPE_FIELDS (gnu_formal_type));\n \t      gnu_actual = convert (gnu_formal_type, gnu_actual);\n@@ -2901,8 +2890,7 @@ call_to_gnu (Node_Id gnat_node, tree *gnu_result_type_p, tree gnu_target)\n \t      = maybe_unconstrained_array (TREE_VALUE (gnu_name_list));\n \n \t    /* If the result is a padded type, remove the padding.  */\n-\t    if (TREE_CODE (TREE_TYPE (gnu_result)) == RECORD_TYPE\n-\t\t&& TYPE_IS_PADDING_P (TREE_TYPE (gnu_result)))\n+\t    if (TYPE_IS_PADDING_P (TREE_TYPE (gnu_result)))\n \t      gnu_result = convert (TREE_TYPE (TYPE_FIELDS\n \t\t\t\t\t       (TREE_TYPE (gnu_result))),\n \t\t\t\t    gnu_result);\n@@ -3861,8 +3849,7 @@ gnat_to_gnu (Node_Id gnat_node)\n \tgnu_array_object = maybe_unconstrained_array (gnu_array_object);\n \n \t/* If we got a padded type, remove it too.  */\n-\tif (TREE_CODE (TREE_TYPE (gnu_array_object)) == RECORD_TYPE\n-\t    && TYPE_IS_PADDING_P (TREE_TYPE (gnu_array_object)))\n+\tif (TYPE_IS_PADDING_P (TREE_TYPE (gnu_array_object)))\n \t  gnu_array_object\n \t    = convert (TREE_TYPE (TYPE_FIELDS (TREE_TYPE (gnu_array_object))),\n \t\t       gnu_array_object);\n@@ -4718,12 +4705,10 @@ gnat_to_gnu (Node_Id gnat_node)\n \t\t   type is self-referential since we want to allocate the fixed\n \t\t   size in that case.  */\n \t\tif (TREE_CODE (gnu_ret_val) == COMPONENT_REF\n-\t\t    && (TREE_CODE (TREE_TYPE (TREE_OPERAND (gnu_ret_val, 0)))\n-\t\t\t== RECORD_TYPE)\n-\t\t    && (TYPE_IS_PADDING_P\n-\t\t\t(TREE_TYPE (TREE_OPERAND (gnu_ret_val, 0))))\n-\t\t    && (CONTAINS_PLACEHOLDER_P\n-\t\t\t(TYPE_SIZE (TREE_TYPE (gnu_ret_val)))))\n+\t\t    && TYPE_IS_PADDING_P\n+\t\t       (TREE_TYPE (TREE_OPERAND (gnu_ret_val, 0)))\n+\t\t    && CONTAINS_PLACEHOLDER_P\n+\t\t       (TYPE_SIZE (TREE_TYPE (gnu_ret_val))))\n \t\t  gnu_ret_val = TREE_OPERAND (gnu_ret_val, 0);\n \n \t\tif (TYPE_RETURNS_BY_REF_P (gnu_subprog_type)\n@@ -5156,7 +5141,7 @@ gnat_to_gnu (Node_Id gnat_node)\n \t     a fat pointer, then go back below to a thin pointer.  The\n \t     reason for this is that we need a fat pointer someplace in\n \t     order to properly compute the size.  */\n-\t  if (TYPE_THIN_POINTER_P (TREE_TYPE (gnu_ptr)))\n+\t  if (TYPE_IS_THIN_POINTER_P (TREE_TYPE (gnu_ptr)))\n \t    gnu_ptr = build_unary_op (ADDR_EXPR, NULL_TREE,\n \t\t\t\t      build_unary_op (INDIRECT_REF, NULL_TREE,\n \t\t\t\t\t\t      gnu_ptr));\n@@ -5165,7 +5150,7 @@ gnat_to_gnu (Node_Id gnat_node)\n \t     have been allocated with the template in front of the object.\n \t     So pass the template address, but get the total size.  Do this\n \t     by converting to a thin pointer.  */\n-\t  if (TYPE_FAT_POINTER_P (TREE_TYPE (gnu_ptr)))\n+\t  if (TYPE_IS_FAT_POINTER_P (TREE_TYPE (gnu_ptr)))\n \t    gnu_ptr\n \t      = convert (build_pointer_type\n \t\t\t (TYPE_OBJECT_RECORD_TYPE\n@@ -5179,7 +5164,7 @@ gnat_to_gnu (Node_Id gnat_node)\n \t      gnu_actual_obj_type\n \t\t= gnat_to_gnu_type (Actual_Designated_Subtype (gnat_node));\n \n-\t      if (TYPE_FAT_OR_THIN_POINTER_P (gnu_ptr_type))\n+\t      if (TYPE_IS_FAT_OR_THIN_POINTER_P (gnu_ptr_type))\n \t\tgnu_actual_obj_type\n \t\t  = build_unc_object_type_from_ptr (gnu_ptr_type,\n \t\t\t\t\t\t    gnu_actual_obj_type,\n@@ -5291,18 +5276,18 @@ gnat_to_gnu (Node_Id gnat_node)\n \n \t/* But if the result is a fat pointer type, we have no mechanism to\n \t   do that, so we unconditionally warn in problematic cases.  */\n-\telse if (TYPE_FAT_POINTER_P (gnu_target_type))\n+\telse if (TYPE_IS_FAT_POINTER_P (gnu_target_type))\n \t  {\n \t    tree gnu_source_array_type\n-\t      = TYPE_FAT_POINTER_P (gnu_source_type)\n+\t      = TYPE_IS_FAT_POINTER_P (gnu_source_type)\n \t\t? TREE_TYPE (TREE_TYPE (TYPE_FIELDS (gnu_source_type)))\n \t\t: NULL_TREE;\n \t    tree gnu_target_array_type\n \t      = TREE_TYPE (TREE_TYPE (TYPE_FIELDS (gnu_target_type)));\n \n \t    if ((TYPE_DUMMY_P (gnu_target_array_type)\n \t\t || get_alias_set (gnu_target_array_type) != 0)\n-\t\t&& (!TYPE_FAT_POINTER_P (gnu_source_type)\n+\t\t&& (!TYPE_IS_FAT_POINTER_P (gnu_source_type)\n \t\t    || (TYPE_DUMMY_P (gnu_source_array_type)\n \t\t\t!= TYPE_DUMMY_P (gnu_target_array_type))\n \t\t    || (TYPE_DUMMY_P (gnu_source_array_type)\n@@ -5443,8 +5428,7 @@ gnat_to_gnu (Node_Id gnat_node)\n \t size: in that case it must be an object of unconstrained type\n \t with a default discriminant and we want to avoid copying too\n \t much data.  */\n-      if (TREE_CODE (TREE_TYPE (gnu_result)) == RECORD_TYPE\n-\t  && TYPE_IS_PADDING_P (TREE_TYPE (gnu_result))\n+      if (TYPE_IS_PADDING_P (TREE_TYPE (gnu_result))\n \t  && CONTAINS_PLACEHOLDER_P (TYPE_SIZE (TREE_TYPE (TYPE_FIELDS\n \t\t\t\t     (TREE_TYPE (gnu_result))))))\n \tgnu_result = convert (TREE_TYPE (TYPE_FIELDS (TREE_TYPE (gnu_result))),\n@@ -5464,8 +5448,7 @@ gnat_to_gnu (Node_Id gnat_node)\n \t       && TREE_CODE (TREE_TYPE (gnu_result)) == RECORD_TYPE))\n     {\n       /* Remove any padding.  */\n-      if (TREE_CODE (TREE_TYPE (gnu_result)) == RECORD_TYPE\n-\t  && TYPE_IS_PADDING_P (TREE_TYPE (gnu_result)))\n+      if (TYPE_IS_PADDING_P (TREE_TYPE (gnu_result)))\n \tgnu_result = convert (TREE_TYPE (TYPE_FIELDS (TREE_TYPE (gnu_result))),\n \t\t\t      gnu_result);\n     }\n@@ -5607,7 +5590,7 @@ add_decl_expr (tree gnu_decl, Entity_Id gnat_entity)\n     {\n       /* If GNU_DECL has a padded type, convert it to the unpadded\n \t type so the assignment is done properly.  */\n-      if (TREE_CODE (type) == RECORD_TYPE && TYPE_IS_PADDING_P (type))\n+      if (TYPE_IS_PADDING_P (type))\n \tt = convert (TREE_TYPE (TYPE_FIELDS (type)), gnu_decl);\n       else\n \tt = gnu_decl;\n@@ -6791,8 +6774,7 @@ convert_with_check (Entity_Id gnat_type, tree gnu_expr, bool overflowp,\n \t= FP_ARITH_MAY_WIDEN ? longest_float_type_node : gnu_in_basetype;\n \n       /* FIXME: Should not have padding in the first place.  */\n-      if (TREE_CODE (calc_type) == RECORD_TYPE\n-\t  && TYPE_IS_PADDING_P (calc_type))\n+      if (TYPE_IS_PADDING_P (calc_type))\n \tcalc_type = TREE_TYPE (TYPE_FIELDS (calc_type));\n \n       /* Compute the exact value calc_type'Pred (0.5) at compile time.  */\n@@ -6989,7 +6971,7 @@ addressable_p (tree gnu_expr, tree gnu_type)\n \t\t    || DECL_ALIGN (TREE_OPERAND (gnu_expr, 1))\n \t\t       >= TYPE_ALIGN (TREE_TYPE (gnu_expr))))\n \t       /* The field of a padding record is always addressable.  */\n-\t       || TYPE_IS_PADDING_P (TREE_TYPE (TREE_OPERAND (gnu_expr, 0))))\n+\t       || TYPE_PADDING_P (TREE_TYPE (TREE_OPERAND (gnu_expr, 0))))\n \t      && addressable_p (TREE_OPERAND (gnu_expr, 0), NULL_TREE));\n \n     case ARRAY_REF:  case ARRAY_RANGE_REF:\n@@ -7269,13 +7251,12 @@ static tree\n maybe_implicit_deref (tree exp)\n {\n   /* If the type is a pointer, dereference it.  */\n-\n-  if (POINTER_TYPE_P (TREE_TYPE (exp)) || TYPE_FAT_POINTER_P (TREE_TYPE (exp)))\n+  if (POINTER_TYPE_P (TREE_TYPE (exp))\n+      || TYPE_IS_FAT_POINTER_P (TREE_TYPE (exp)))\n     exp = build_unary_op (INDIRECT_REF, NULL_TREE, exp);\n \n   /* If we got a padded type, remove it too.  */\n-  if (TREE_CODE (TREE_TYPE (exp)) == RECORD_TYPE\n-      && TYPE_IS_PADDING_P (TREE_TYPE (exp)))\n+  if (TYPE_IS_PADDING_P (TREE_TYPE (exp)))\n     exp = convert (TREE_TYPE (TYPE_FIELDS (TREE_TYPE (exp))), exp);\n \n   return exp;\n@@ -7313,7 +7294,7 @@ protect_multiple_eval (tree exp)\n \n   /* If this is a fat pointer or something that can be placed into a\n      register, just make a SAVE_EXPR.  */\n-  if (TYPE_FAT_POINTER_P (type) || TYPE_MODE (type) != BLKmode)\n+  if (TYPE_IS_FAT_POINTER_P (type) || TYPE_MODE (type) != BLKmode)\n     return save_expr (exp);\n \n   /* Otherwise, reference, protect the address and dereference.  */\n@@ -7498,7 +7479,7 @@ gnat_stabilize_reference_1 (tree e, bool force)\n \t fat pointer.  This may be more efficient, but will also allow\n \t us to more easily find the match for the PLACEHOLDER_EXPR.  */\n       if (code == COMPONENT_REF\n-\t  && TYPE_FAT_POINTER_P (TREE_TYPE (TREE_OPERAND (e, 0))))\n+\t  && TYPE_IS_FAT_POINTER_P (TREE_TYPE (TREE_OPERAND (e, 0))))\n \tresult = build3 (COMPONENT_REF, type,\n \t\t\t gnat_stabilize_reference_1 (TREE_OPERAND (e, 0),\n \t\t\t\t\t\t     force),"}, {"sha": "86575b529d953115250978382e1e7b636f8fdf6c", "filename": "gcc/ada/gcc-interface/utils.c", "status": "modified", "additions": 30, "deletions": 34, "changes": 64, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/315cff155219ea11bf95209165121376b12fe06e/gcc%2Fada%2Fgcc-interface%2Futils.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/315cff155219ea11bf95209165121376b12fe06e/gcc%2Fada%2Fgcc-interface%2Futils.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Futils.c?ref=315cff155219ea11bf95209165121376b12fe06e", "patch": "@@ -490,7 +490,7 @@ gnat_pushdecl (tree decl, Node_Id gnat_node)\n \n       if (!(TYPE_NAME (t) && TREE_CODE (TYPE_NAME (t)) == TYPE_DECL))\n \t;\n-      else if (TYPE_FAT_POINTER_P (t))\n+      else if (TYPE_IS_FAT_POINTER_P (t))\n \t{\n \t  tree tt = build_variant_type_copy (t);\n \t  TYPE_NAME (tt) = decl;\n@@ -643,7 +643,7 @@ finish_record_type (tree record_type, tree fieldlist, int rep_level,\n       if ((TREE_CODE (type) == RECORD_TYPE\n \t   || TREE_CODE (type) == UNION_TYPE\n \t   || TREE_CODE (type) == QUAL_UNION_TYPE)\n-\t  && !TYPE_IS_FAT_POINTER_P (type)\n+\t  && !TYPE_FAT_POINTER_P (type)\n \t  && !TYPE_CONTAINS_TEMPLATE_P (type)\n \t  && TYPE_ADA_SIZE (type))\n \tthis_ada_size = TYPE_ADA_SIZE (type);\n@@ -743,12 +743,11 @@ finish_record_type (tree record_type, tree fieldlist, int rep_level,\n     {\n       /* If this is a padding record, we never want to make the size smaller\n \t than what was specified in it, if any.  */\n-      if (TREE_CODE (record_type) == RECORD_TYPE\n-\t  && TYPE_IS_PADDING_P (record_type) && TYPE_SIZE (record_type))\n+      if (TYPE_IS_PADDING_P (record_type) && TYPE_SIZE (record_type))\n \tsize = TYPE_SIZE (record_type);\n \n       /* Now set any of the values we've just computed that apply.  */\n-      if (!TYPE_IS_FAT_POINTER_P (record_type)\n+      if (!TYPE_FAT_POINTER_P (record_type)\n \t  && !TYPE_CONTAINS_TEMPLATE_P (record_type))\n \tSET_TYPE_ADA_SIZE (record_type, ada_size);\n \n@@ -810,9 +809,7 @@ rest_of_record_type_compilation (tree record_type)\n      that tells the debugger how the record is laid out.  See\n      exp_dbug.ads.  But don't do this for records that are padding\n      since they confuse GDB.  */\n-  if (var_size\n-      && !(TREE_CODE (record_type) == RECORD_TYPE\n-\t   && TYPE_IS_PADDING_P (record_type)))\n+  if (var_size && !TYPE_IS_PADDING_P (record_type))\n     {\n       tree new_record_type\n \t= make_node (TREE_CODE (record_type) == QUAL_UNION_TYPE\n@@ -1301,7 +1298,7 @@ create_type_decl (tree type_name, tree type, struct attrib *attr_list,\n   if (code == UNCONSTRAINED_ARRAY_TYPE || !debug_info_p)\n     DECL_IGNORED_P (type_decl) = 1;\n   else if (code != ENUMERAL_TYPE\n-\t   && (code != RECORD_TYPE || TYPE_IS_FAT_POINTER_P (type))\n+\t   && (code != RECORD_TYPE || TYPE_FAT_POINTER_P (type))\n \t   && !((code == POINTER_TYPE || code == REFERENCE_TYPE)\n \t\t&& TYPE_IS_DUMMY_P (TREE_TYPE (type)))\n \t   && !(code == RECORD_TYPE\n@@ -2286,7 +2283,7 @@ gnat_types_compatible_p (tree t1, tree t2)\n   /* Padding record types are also compatible if they pad the same\n      type and have the same constant size.  */\n   if (code == RECORD_TYPE\n-      && TYPE_IS_PADDING_P (t1) && TYPE_IS_PADDING_P (t2)\n+      && TYPE_PADDING_P (t1) && TYPE_PADDING_P (t2)\n       && TREE_TYPE (TYPE_FIELDS (t1)) == TREE_TYPE (TYPE_FIELDS (t2))\n       && tree_int_cst_equal (TYPE_SIZE (t1), TYPE_SIZE (t2)))\n     return 1;\n@@ -2436,7 +2433,7 @@ build_template (tree template_type, tree array_type, tree expr)\n   tree field;\n \n   while (TREE_CODE (array_type) == RECORD_TYPE\n-\t && (TYPE_IS_PADDING_P (array_type)\n+\t && (TYPE_PADDING_P (array_type)\n \t     || TYPE_JUSTIFIED_MODULAR_P (array_type)))\n     array_type = TREE_TYPE (TYPE_FIELDS (array_type));\n \n@@ -3150,7 +3147,7 @@ convert_vms_descriptor64 (tree gnu_type, tree gnu_expr, Entity_Id gnat_subprog)\n   if (POINTER_TYPE_P (gnu_type))\n     return convert (gnu_type, gnu_expr64);\n \n-  else if (TYPE_FAT_POINTER_P (gnu_type))\n+  else if (TYPE_IS_FAT_POINTER_P (gnu_type))\n     {\n       tree p_array_type = TREE_TYPE (TYPE_FIELDS (gnu_type));\n       tree p_bounds_type = TREE_TYPE (TREE_CHAIN (TYPE_FIELDS (gnu_type)));\n@@ -3299,7 +3296,7 @@ convert_vms_descriptor32 (tree gnu_type, tree gnu_expr, Entity_Id gnat_subprog)\n   if (POINTER_TYPE_P (gnu_type))\n     return convert (gnu_type, gnu_expr32);\n \n-  else if (TYPE_FAT_POINTER_P (gnu_type))\n+  else if (TYPE_IS_FAT_POINTER_P (gnu_type))\n     {\n       tree p_array_type = TREE_TYPE (TYPE_FIELDS (gnu_type));\n       tree p_bounds_type = TREE_TYPE (TREE_CHAIN (TYPE_FIELDS (gnu_type)));\n@@ -3537,10 +3534,10 @@ build_unc_object_type_from_ptr (tree thin_fat_ptr_type, tree object_type,\n {\n   tree template_type;\n \n-  gcc_assert (TYPE_FAT_OR_THIN_POINTER_P (thin_fat_ptr_type));\n+  gcc_assert (TYPE_IS_FAT_OR_THIN_POINTER_P (thin_fat_ptr_type));\n \n   template_type\n-    = (TYPE_FAT_POINTER_P (thin_fat_ptr_type)\n+    = (TYPE_IS_FAT_POINTER_P (thin_fat_ptr_type)\n        ? TREE_TYPE (TREE_TYPE (TREE_CHAIN (TYPE_FIELDS (thin_fat_ptr_type))))\n        : TREE_TYPE (TYPE_FIELDS (TREE_TYPE (thin_fat_ptr_type))));\n   return build_unc_object_type (template_type, object_type, name);\n@@ -3636,7 +3633,7 @@ update_pointer_to (tree old_type, tree new_type)\n   /* Now deal with the unconstrained array case.  In this case the \"pointer\"\n      is actually a RECORD_TYPE where both fields are pointers to dummy nodes.\n      Turn them into pointers to the correct types using update_pointer_to.  */\n-  else if (!TYPE_FAT_POINTER_P (ptr))\n+  else if (!TYPE_IS_FAT_POINTER_P (ptr))\n     gcc_unreachable ();\n \n   else\n@@ -3737,7 +3734,7 @@ convert_to_fat_pointer (tree type, tree expr)\n \t\t\t       NULL_TREE)));\n \n   /* If EXPR is a thin pointer, make template and data from the record..  */\n-  else if (TYPE_THIN_POINTER_P (etype))\n+  else if (TYPE_IS_THIN_POINTER_P (etype))\n     {\n       tree fields = TYPE_FIELDS (TREE_TYPE (etype));\n \n@@ -3787,7 +3784,7 @@ convert_to_fat_pointer (tree type, tree expr)\n static tree\n convert_to_thin_pointer (tree type, tree expr)\n {\n-  if (!TYPE_FAT_POINTER_P (TREE_TYPE (expr)))\n+  if (!TYPE_IS_FAT_POINTER_P (TREE_TYPE (expr)))\n     expr\n       = convert_to_fat_pointer\n \t(TREE_TYPE (TYPE_UNCONSTRAINED_ARRAY (TREE_TYPE (type))), expr);\n@@ -3822,7 +3819,7 @@ convert (tree type, tree expr)\n      as an unchecked conversion.  Likewise if one is a mere variant of the\n      other, so we avoid a pointless unpad/repad sequence.  */\n   else if (code == RECORD_TYPE && ecode == RECORD_TYPE\n-\t   && TYPE_IS_PADDING_P (type) && TYPE_IS_PADDING_P (etype)\n+\t   && TYPE_PADDING_P (type) && TYPE_PADDING_P (etype)\n \t   && (!TREE_CONSTANT (TYPE_SIZE (type))\n \t       || !TREE_CONSTANT (TYPE_SIZE (etype))\n \t       || gnat_types_compatible_p (type, etype)\n@@ -3832,7 +3829,7 @@ convert (tree type, tree expr)\n \n   /* If the output type has padding, convert to the inner type and make a\n      constructor to build the record, unless a variable size is involved.  */\n-  else if (code == RECORD_TYPE && TYPE_IS_PADDING_P (type))\n+  else if (code == RECORD_TYPE && TYPE_PADDING_P (type))\n     {\n       /* If we previously converted from another type and our type is\n \t of variable size, remove the conversion to avoid the need for\n@@ -3850,7 +3847,6 @@ convert (tree type, tree expr)\n \t variable-sized temporaries.  Likewise if the padding is a variant\n \t of the other, so we avoid a pointless unpad/repad sequence.  */\n       if (TREE_CODE (expr) == COMPONENT_REF\n-\t  && TREE_CODE (TREE_TYPE (TREE_OPERAND (expr, 0))) == RECORD_TYPE\n \t  && TYPE_IS_PADDING_P (TREE_TYPE (TREE_OPERAND (expr, 0)))\n \t  && (!TREE_CONSTANT (TYPE_SIZE (type))\n \t      || gnat_types_compatible_p (type,\n@@ -3893,7 +3889,7 @@ convert (tree type, tree expr)\n      The conditions ordering is arranged to ensure that the output type is not\n      a padding type here, as it is not clear whether the conversion would\n      always be correct if this was to happen.  */\n-  else if (ecode == RECORD_TYPE && TYPE_IS_PADDING_P (etype))\n+  else if (ecode == RECORD_TYPE && TYPE_PADDING_P (etype))\n     {\n       tree unpadded;\n \n@@ -4142,7 +4138,8 @@ convert (tree type, tree expr)\n \t    /* Otherwise, we may just bypass the input view conversion unless\n \t       one of the types is a fat pointer,  which is handled by\n \t       specialized code below which relies on exact type matching.  */\n-\t    else if (!TYPE_FAT_POINTER_P (type) && !TYPE_FAT_POINTER_P (etype))\n+\t    else if (!TYPE_IS_FAT_POINTER_P (type)\n+\t\t     && !TYPE_IS_FAT_POINTER_P (etype))\n \t      return convert (type, op0);\n \t  }\n       }\n@@ -4161,7 +4158,7 @@ convert (tree type, tree expr)\n \t      || TREE_CODE (type) == UNION_TYPE)\n \t  && (TREE_CODE (etype) == RECORD_TYPE\n \t      || TREE_CODE (etype) == UNION_TYPE)\n-\t  && !TYPE_FAT_POINTER_P (type) && !TYPE_FAT_POINTER_P (etype))\n+\t  && !TYPE_IS_FAT_POINTER_P (type) && !TYPE_IS_FAT_POINTER_P (etype))\n \treturn build_unary_op (INDIRECT_REF, NULL_TREE,\n \t\t\t       convert (build_pointer_type (type),\n \t\t\t\t\tTREE_OPERAND (expr, 0)));\n@@ -4172,7 +4169,7 @@ convert (tree type, tree expr)\n     }\n \n   /* Check for converting to a pointer to an unconstrained array.  */\n-  if (TYPE_FAT_POINTER_P (type) && !TYPE_FAT_POINTER_P (etype))\n+  if (TYPE_IS_FAT_POINTER_P (type) && !TYPE_IS_FAT_POINTER_P (etype))\n     return convert_to_fat_pointer (type, expr);\n \n   /* If we are converting between two aggregate or vector types that are mere\n@@ -4244,7 +4241,7 @@ convert (tree type, tree expr)\n       /* If converting between two pointers to records denoting\n \t both a template and type, adjust if needed to account\n \t for any differing offsets, since one might be negative.  */\n-      if (TYPE_THIN_POINTER_P (etype) && TYPE_THIN_POINTER_P (type))\n+      if (TYPE_IS_THIN_POINTER_P (etype) && TYPE_IS_THIN_POINTER_P (type))\n \t{\n \t  tree bit_diff\n \t    = size_diffop (bit_position (TYPE_FIELDS (TREE_TYPE (etype))),\n@@ -4262,13 +4259,13 @@ convert (tree type, tree expr)\n \t}\n \n       /* If converting to a thin pointer, handle specially.  */\n-      if (TYPE_THIN_POINTER_P (type)\n+      if (TYPE_IS_THIN_POINTER_P (type)\n \t  && TYPE_UNCONSTRAINED_ARRAY (TREE_TYPE (type)))\n \treturn convert_to_thin_pointer (type, expr);\n \n       /* If converting fat pointer to normal pointer, get the pointer to the\n \t array and then convert it.  */\n-      else if (TYPE_FAT_POINTER_P (etype))\n+      else if (TYPE_IS_FAT_POINTER_P (etype))\n \texpr = build_component_ref (expr, get_identifier (\"P_ARRAY\"),\n \t\t\t\t    NULL_TREE, false);\n \n@@ -4365,8 +4362,7 @@ remove_conversions (tree exp, bool true_address)\n       break;\n \n     case COMPONENT_REF:\n-      if (TREE_CODE (TREE_TYPE (TREE_OPERAND (exp, 0))) == RECORD_TYPE\n-\t  && TYPE_IS_PADDING_P (TREE_TYPE (TREE_OPERAND (exp, 0))))\n+      if (TYPE_IS_PADDING_P (TREE_TYPE (TREE_OPERAND (exp, 0))))\n \treturn remove_conversions (TREE_OPERAND (exp, 0), true_address);\n       break;\n \n@@ -4415,7 +4411,7 @@ maybe_unconstrained_array (tree exp)\n     case RECORD_TYPE:\n       /* If this is a padded type, convert to the unpadded type and see if\n \t it contains a template.  */\n-      if (TYPE_IS_PADDING_P (TREE_TYPE (exp)))\n+      if (TYPE_PADDING_P (TREE_TYPE (exp)))\n \t{\n \t  new_exp = convert (TREE_TYPE (TYPE_FIELDS (TREE_TYPE (exp))), exp);\n \t  if (TREE_CODE (TREE_TYPE (new_exp)) == RECORD_TYPE\n@@ -4518,13 +4514,13 @@ unchecked_convert (tree type, tree expr, bool notrunc_p)\n   if ((((INTEGRAL_TYPE_P (type)\n \t && !(TREE_CODE (type) == INTEGER_TYPE\n \t      && TYPE_VAX_FLOATING_POINT_P (type)))\n-\t|| (POINTER_TYPE_P (type) && ! TYPE_THIN_POINTER_P (type))\n+\t|| (POINTER_TYPE_P (type) && ! TYPE_IS_THIN_POINTER_P (type))\n \t|| (TREE_CODE (type) == RECORD_TYPE\n \t    && TYPE_JUSTIFIED_MODULAR_P (type)))\n        && ((INTEGRAL_TYPE_P (etype)\n \t    && !(TREE_CODE (etype) == INTEGER_TYPE\n \t\t && TYPE_VAX_FLOATING_POINT_P (etype)))\n-\t   || (POINTER_TYPE_P (etype) && !TYPE_THIN_POINTER_P (etype))\n+\t   || (POINTER_TYPE_P (etype) && !TYPE_IS_THIN_POINTER_P (etype))\n \t   || (TREE_CODE (etype) == RECORD_TYPE\n \t       && TYPE_JUSTIFIED_MODULAR_P (etype))))\n       || TREE_CODE (type) == UNCONSTRAINED_ARRAY_TYPE)\n@@ -5504,7 +5500,7 @@ handle_vector_type_attribute (tree *node, tree name, tree ARG_UNUSED (args),\n   /* Get the representative array type, possibly nested within a\n      padding record e.g. for alignment purposes.  */\n \n-  if (TREE_CODE (rep_type) == RECORD_TYPE && TYPE_IS_PADDING_P (rep_type))\n+  if (TYPE_IS_PADDING_P (rep_type))\n     rep_type = TREE_TYPE (TYPE_FIELDS (rep_type));\n \n   if (TREE_CODE (rep_type) != ARRAY_TYPE)"}, {"sha": "fcd9ecd1253fd5d85f60ba9ecabccfe99a5d6264", "filename": "gcc/ada/gcc-interface/utils2.c", "status": "modified", "additions": 18, "deletions": 26, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/315cff155219ea11bf95209165121376b12fe06e/gcc%2Fada%2Fgcc-interface%2Futils2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/315cff155219ea11bf95209165121376b12fe06e/gcc%2Fada%2Fgcc-interface%2Futils2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Futils2.c?ref=315cff155219ea11bf95209165121376b12fe06e", "patch": "@@ -654,12 +654,9 @@ build_binary_op (enum tree_code op_code, tree result_type,\n \t can convert the constructor to the inner type, to avoid putting a\n \t VIEW_CONVERT_EXPR on the LHS.  But don't do so if we wouldn't have\n \t actually copied anything.  */\n-      else if (TREE_CODE (left_type) == RECORD_TYPE\n-\t       && TYPE_IS_PADDING_P (left_type)\n+      else if (TYPE_IS_PADDING_P (left_type)\n \t       && TREE_CONSTANT (TYPE_SIZE (left_type))\n \t       && ((TREE_CODE (right_operand) == COMPONENT_REF\n-\t\t    && TREE_CODE (TREE_TYPE (TREE_OPERAND (right_operand, 0)))\n-\t\t       == RECORD_TYPE\n \t\t    && TYPE_IS_PADDING_P\n \t\t       (TREE_TYPE (TREE_OPERAND (right_operand, 0)))\n \t\t    && gnat_types_compatible_p\n@@ -836,8 +833,8 @@ build_binary_op (enum tree_code op_code, tree result_type,\n \t convert both operands to that type.  */\n       if (left_base_type != right_base_type)\n \t{\n-\t  if (TYPE_FAT_POINTER_P (left_base_type)\n-\t      && TYPE_FAT_POINTER_P (right_base_type)\n+\t  if (TYPE_IS_FAT_POINTER_P (left_base_type)\n+\t      && TYPE_IS_FAT_POINTER_P (right_base_type)\n \t      && TYPE_MAIN_VARIANT (left_base_type)\n \t\t == TYPE_MAIN_VARIANT (right_base_type))\n \t    best_type = left_base_type;\n@@ -872,7 +869,7 @@ build_binary_op (enum tree_code op_code, tree result_type,\n \n       /* If we are comparing a fat pointer against zero, we need to\n \t just compare the data pointer.  */\n-      else if (TYPE_FAT_POINTER_P (left_base_type)\n+      else if (TYPE_IS_FAT_POINTER_P (left_base_type)\n \t       && TREE_CODE (right_operand) == CONSTRUCTOR\n \t       && integer_zerop (VEC_index (constructor_elt,\n \t\t\t\t\t    CONSTRUCTOR_ELTS (right_operand),\n@@ -1117,11 +1114,10 @@ build_unary_op (enum tree_code op_code, tree result_type, tree operand)\n \t      /* If INNER is a padding type whose field has a self-referential\n \t\t size, convert to that inner type.  We know the offset is zero\n \t\t and we need to have that type visible.  */\n-\t      if (TREE_CODE (TREE_TYPE (inner)) == RECORD_TYPE\n-\t\t  && TYPE_IS_PADDING_P (TREE_TYPE (inner))\n-\t\t  && (CONTAINS_PLACEHOLDER_P\n-\t\t      (TYPE_SIZE (TREE_TYPE (TYPE_FIELDS\n-\t\t\t\t\t     (TREE_TYPE (inner)))))))\n+\t      if (TYPE_IS_PADDING_P (TREE_TYPE (inner))\n+\t\t  && CONTAINS_PLACEHOLDER_P\n+\t\t     (TYPE_SIZE (TREE_TYPE (TYPE_FIELDS\n+\t\t\t\t\t    (TREE_TYPE (inner))))))\n \t\tinner = convert (TREE_TYPE (TYPE_FIELDS (TREE_TYPE (inner))),\n \t\t\t\t inner);\n \n@@ -1154,13 +1150,11 @@ build_unary_op (enum tree_code op_code, tree result_type, tree operand)\n \t  /* If this is just a constructor for a padded record, we can\n \t     just take the address of the single field and convert it to\n \t     a pointer to our type.  */\n-\t  if (TREE_CODE (type) == RECORD_TYPE && TYPE_IS_PADDING_P (type))\n+\t  if (TYPE_IS_PADDING_P (type))\n \t    {\n-\t      result = (VEC_index (constructor_elt,\n-\t\t\t\t   CONSTRUCTOR_ELTS (operand),\n-\t\t\t\t   0)\n-\t\t\t->value);\n-\n+\t      result = VEC_index (constructor_elt,\n+\t\t\t\t  CONSTRUCTOR_ELTS (operand),\n+\t\t\t\t  0)->value;\n \t      result = convert (build_pointer_type (TREE_TYPE (operand)),\n \t\t\t\tbuild_unary_op (ADDR_EXPR, NULL_TREE, result));\n \t      break;\n@@ -1202,8 +1196,7 @@ build_unary_op (enum tree_code op_code, tree result_type, tree operand)\n \n \t  /* If we are taking the address of a padded record whose field is\n \t     contains a template, take the address of the template.  */\n-\t  if (TREE_CODE (type) == RECORD_TYPE\n-\t      && TYPE_IS_PADDING_P (type)\n+\t  if (TYPE_IS_PADDING_P (type)\n \t      && TREE_CODE (TREE_TYPE (TYPE_FIELDS (type))) == RECORD_TYPE\n \t      && TYPE_CONTAINS_TEMPLATE_P (TREE_TYPE (TYPE_FIELDS (type))))\n \t    {\n@@ -1226,7 +1219,7 @@ build_unary_op (enum tree_code op_code, tree result_type, tree operand)\n \t make up an expression to do so.  This will never survive to\n \t the backend.  If TYPE is a thin pointer, first convert the\n \t operand to a fat pointer.  */\n-      if (TYPE_THIN_POINTER_P (type)\n+      if (TYPE_IS_THIN_POINTER_P (type)\n \t  && TYPE_UNCONSTRAINED_ARRAY (TREE_TYPE (type)))\n \t{\n \t  operand\n@@ -1235,7 +1228,7 @@ build_unary_op (enum tree_code op_code, tree result_type, tree operand)\n \t  type = TREE_TYPE (operand);\n \t}\n \n-      if (TYPE_FAT_POINTER_P (type))\n+      if (TYPE_IS_FAT_POINTER_P (type))\n \t{\n \t  result = build1 (UNCONSTRAINED_ARRAY_REF,\n \t\t\t   TYPE_UNCONSTRAINED_ARRAY (type), operand);\n@@ -1252,7 +1245,7 @@ build_unary_op (enum tree_code op_code, tree result_type, tree operand)\n \t}\n \n       side_effects\n-\t=  (!TYPE_FAT_POINTER_P (type) && TYPE_VOLATILE (TREE_TYPE (type)));\n+\t= (!TYPE_IS_FAT_POINTER_P (type) && TYPE_VOLATILE (TREE_TYPE (type)));\n       break;\n \n     case NEGATE_EXPR:\n@@ -2027,7 +2020,7 @@ build_allocator (tree type, tree init, tree result_type, Entity_Id gnat_proc,\n   /* If RESULT_TYPE is a fat or thin pointer, set SIZE to be the sum of the\n      sizes of the object and its template.  Allocate the whole thing and\n      fill in the parts that are known.  */\n-  else if (TYPE_FAT_OR_THIN_POINTER_P (result_type))\n+  else if (TYPE_IS_FAT_OR_THIN_POINTER_P (result_type))\n     {\n       tree storage_type\n \t= build_unc_object_type_from_ptr (result_type, type,\n@@ -2049,10 +2042,9 @@ build_allocator (tree type, tree init, tree result_type, Entity_Id gnat_proc,\n \t\t\t\t\t  gnat_proc, gnat_pool, gnat_node);\n       storage = convert (storage_ptr_type, protect_multiple_eval (storage));\n \n-      if (TREE_CODE (type) == RECORD_TYPE && TYPE_IS_PADDING_P (type))\n+      if (TYPE_IS_PADDING_P (type))\n \t{\n \t  type = TREE_TYPE (TYPE_FIELDS (type));\n-\n \t  if (init)\n \t    init = convert (type, init);\n \t}"}]}