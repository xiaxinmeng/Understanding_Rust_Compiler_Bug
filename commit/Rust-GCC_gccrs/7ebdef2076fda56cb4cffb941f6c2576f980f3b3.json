{"sha": "7ebdef2076fda56cb4cffb941f6c2576f980f3b3", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6N2ViZGVmMjA3NmZkYTU2Y2I0Y2ZmYjk0MWY2YzI1NzZmOTgwZjNiMw==", "commit": {"author": {"name": "Eric Botcazou", "email": "ebotcazou@adacore.com", "date": "2021-04-05T17:49:56Z"}, "committer": {"name": "Eric Botcazou", "email": "ebotcazou@adacore.com", "date": "2021-04-05T17:52:29Z"}, "message": "Fix small regression with -fdump-ada-spec\n\nWhen the enumeration constants of an enumeration type are defined by\nexplicit values, the binding generated by -fdump-ada-spec does not use\nan enumeration type on the Ada side, because the set of allowed values\nin C/C++ is larger than the set of allowed values in Ada, but instead\nuse an integer subtype and defines a set of explicit constants, which\nused to be of this subtype but were changed to the base type at some\npoint.  This reinstates the subtype for them.\n\ngcc/c-family/\n\t* c-ada-spec.c (is_simple_enum): Minor tweaks.\n\t(dump_ada_enum_type): Add TYPE and PARENT parameters.  For non-simple\n\tenumeral types use again the type name for the enumeration constants.\n\t(dump_ada_node): Adjust call to dump_ada_enum_type.\n\t(dump_nested_type): Likewise.", "tree": {"sha": "7363fd884d965637daf1edafd9fe8bf92f4f8441", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/7363fd884d965637daf1edafd9fe8bf92f4f8441"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/7ebdef2076fda56cb4cffb941f6c2576f980f3b3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7ebdef2076fda56cb4cffb941f6c2576f980f3b3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7ebdef2076fda56cb4cffb941f6c2576f980f3b3", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7ebdef2076fda56cb4cffb941f6c2576f980f3b3/comments", "author": null, "committer": null, "parents": [{"sha": "f1d012911bd103e9701ed378f32928a3cbcf028a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f1d012911bd103e9701ed378f32928a3cbcf028a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f1d012911bd103e9701ed378f32928a3cbcf028a"}], "stats": {"total": 39, "additions": 21, "deletions": 18}, "files": [{"sha": "9fef5f05cc878054881004266e8c3d0eaf48b641", "filename": "gcc/c-family/c-ada-spec.c", "status": "modified", "additions": 21, "deletions": 18, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7ebdef2076fda56cb4cffb941f6c2576f980f3b3/gcc%2Fc-family%2Fc-ada-spec.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7ebdef2076fda56cb4cffb941f6c2576f980f3b3/gcc%2Fc-family%2Fc-ada-spec.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc-ada-spec.c?ref=7ebdef2076fda56cb4cffb941f6c2576f980f3b3", "patch": "@@ -1932,8 +1932,8 @@ dump_ada_template (pretty_printer *buffer, tree t, int spc)\n   return num_inst > 0;\n }\n \n-/* Return true if NODE is a simple enum types, that can be mapped to an\n-   Ada enum type directly.  */\n+/* Return true if NODE is a simple enumeral type that can be mapped to an\n+   Ada enumeration type directly.  */\n \n static bool\n is_simple_enum (tree node)\n@@ -1947,9 +1947,7 @@ is_simple_enum (tree node)\n       if (TREE_CODE (int_val) != INTEGER_CST)\n \tint_val = DECL_INITIAL (int_val);\n \n-      if (!tree_fits_shwi_p (int_val))\n-\treturn false;\n-      else if (tree_to_shwi (int_val) != count)\n+      if (!tree_fits_shwi_p (int_val) || tree_to_shwi (int_val) != count)\n \treturn false;\n \n       count++;\n@@ -1958,11 +1956,12 @@ is_simple_enum (tree node)\n   return true;\n }\n \n-/* Dump in BUFFER an enumeral type NODE in Ada syntax.  SPC is the indentation\n-   level.  */\n+/* Dump in BUFFER the declaration of enumeral NODE of type TYPE in Ada syntax.\n+   PARENT is the parent node of NODE.  SPC is the indentation level.  */\n \n static void\n-dump_ada_enum_type (pretty_printer *buffer, tree node, int spc)\n+dump_ada_enum_type (pretty_printer *buffer, tree node, tree type, tree parent,\n+\t\t    int spc)\n {\n   if (is_simple_enum (node))\n     {\n@@ -1993,25 +1992,29 @@ dump_ada_enum_type (pretty_printer *buffer, tree node, int spc)\n \tpp_string (buffer, \"unsigned\");\n       else\n \tpp_string (buffer, \"int\");\n+\n       for (tree value = TYPE_VALUES (node); value; value = TREE_CHAIN (value))\n \t{\n+\t  tree int_val = TREE_VALUE (value);\n+\n+\t  if (TREE_CODE (int_val) != INTEGER_CST)\n+\t    int_val = DECL_INITIAL (int_val);\n+\n \t  pp_semicolon (buffer);\n \t  newline_and_indent (buffer, spc);\n \n \t  pp_ada_tree_identifier (buffer, TREE_PURPOSE (value), node, false);\n \t  pp_string (buffer, \" : constant \");\n \n-\t  if (TYPE_UNSIGNED (node))\n-\t    pp_string (buffer, \"unsigned\");\n+\t  if (TYPE_NAME (node))\n+\t    dump_ada_node (buffer, node, NULL_TREE, spc, false, true);\n+\t  else if (type)\n+\t    dump_ada_node (buffer, type, NULL_TREE, spc, false, true);\n \t  else\n-\t    pp_string (buffer, \"int\");\n+\t    dump_anonymous_type_name (buffer, node, parent);\n \n \t  pp_string (buffer, \" := \");\n-\t  dump_ada_node (buffer,\n-\t\t\t TREE_CODE (TREE_VALUE (value)) == INTEGER_CST\n-\t\t\t ? TREE_VALUE (value)\n-\t\t\t : DECL_INITIAL (TREE_VALUE (value)),\n-\t\t\t node, spc, false, true);\n+\t  dump_ada_node (buffer, int_val, node, spc, false, true);\n \t}\n     }\n }\n@@ -2098,7 +2101,7 @@ dump_ada_node (pretty_printer *buffer, tree node, tree type, int spc,\n       if (name_only)\n \tdump_ada_node (buffer, TYPE_NAME (node), node, spc, false, true);\n       else\n-\tdump_ada_enum_type (buffer, node, spc);\n+\tdump_ada_enum_type (buffer, node, type, NULL_TREE, spc);\n       break;\n \n     case REAL_TYPE:\n@@ -2577,7 +2580,7 @@ dump_nested_type (pretty_printer *buffer, tree field, tree t, tree parent,\n       else\n \tdump_anonymous_type_name (buffer, field_type, parent);\n       pp_string (buffer, \" is \");\n-      dump_ada_enum_type (buffer, field_type, spc);\n+      dump_ada_enum_type (buffer, field_type, NULL_TREE, parent, spc);\n       pp_semicolon (buffer);\n       newline_and_indent (buffer, spc);\n       break;"}]}