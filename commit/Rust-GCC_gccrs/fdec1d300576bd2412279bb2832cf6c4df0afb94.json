{"sha": "fdec1d300576bd2412279bb2832cf6c4df0afb94", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZmRlYzFkMzAwNTc2YmQyNDEyMjc5YmIyODMyY2Y2YzRkZjBhZmI5NA==", "commit": {"author": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1996-01-16T01:57:28Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1996-01-16T01:57:28Z"}, "message": "Initial revision\n\nFrom-SVN: r11007", "tree": {"sha": "569d7fabe0a6642d390f37d19bc139c5415238c5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/569d7fabe0a6642d390f37d19bc139c5415238c5"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/fdec1d300576bd2412279bb2832cf6c4df0afb94", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fdec1d300576bd2412279bb2832cf6c4df0afb94", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fdec1d300576bd2412279bb2832cf6c4df0afb94", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fdec1d300576bd2412279bb2832cf6c4df0afb94/comments", "author": null, "committer": null, "parents": [{"sha": "38b3fa0818eb9876a78cb0fca234c8ad322c4234", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/38b3fa0818eb9876a78cb0fca234c8ad322c4234", "html_url": "https://github.com/Rust-GCC/gccrs/commit/38b3fa0818eb9876a78cb0fca234c8ad322c4234"}], "stats": {"total": 1083, "additions": 1083, "deletions": 0}, "files": [{"sha": "63d76a9642ce4e18a4caa3f2bcfb2f5d310e9b1f", "filename": "gcc/config/i386/sco5.h", "status": "added", "additions": 975, "deletions": 0, "changes": 975, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fdec1d300576bd2412279bb2832cf6c4df0afb94/gcc%2Fconfig%2Fi386%2Fsco5.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fdec1d300576bd2412279bb2832cf6c4df0afb94/gcc%2Fconfig%2Fi386%2Fsco5.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fsco5.h?ref=fdec1d300576bd2412279bb2832cf6c4df0afb94", "patch": "@@ -0,0 +1,975 @@\n+/* Definitions for Intel 386 running SCO Unix System V 3.2 Version 5.\n+   Written by Kean Johnston (hug@netcom.com)\n+   Copyright (C) 1992, 1995, 1996 Free Software Foundation, Inc.\n+\n+This file is part of GNU CC.\n+\n+GNU CC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU CC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU CC; see the file COPYING.  If not, write to\n+the Free Software Foundation, 59 Temple Place - Suite 330,\n+Boston, MA 02111-1307, USA.  */\n+\n+#include \"i386/i386.h\"\t/* Base i386 target definitions */\n+#include \"i386/att.h\"\t/* Use AT&T i386 assembler syntax */\n+\n+#undef TARGET_VERSION\n+#define TARGET_VERSION fprintf (stderr, \" (i386, SCO OpenServer 5 Syntax)\");\n+\n+#undef LPREFIX\n+#define LPREFIX\t\t\t\t\".L\"\n+\n+#undef ALIGN_ASM_OP\n+#define ALIGN_ASM_OP\t\t\t\"\\t.align\"\n+\n+#undef ASCII_DATA_ASM_OP\n+#define ASCII_DATA_ASM_OP\t\t\"\\t.ascii\"\n+\n+#undef ASM_BYTE_OP\n+#define ASM_BYTE_OP\t\t\t\"\\t.byte\"\n+\n+#undef IDENT_ASM_OP\n+#define IDENT_ASM_OP\t\t\t\"\\t.ident\"\n+\n+#undef COMMON_ASM_OP\n+#define COMMON_ASM_OP\t\t\t\"\\t.comm\"\n+\n+#undef SET_ASM_OP\n+#define SET_ASM_OP\t\t\t\"\\t.set\"\n+\n+#undef LOCAL_ASM_OP\n+#define LOCAL_ASM_OP\t\t\t\"\\t.local\"\n+\n+#undef INT_ASM_OP\n+#define INT_ASM_OP\t\t\t\"\\t.long\"\n+\n+#undef ASM_SHORT\n+#define ASM_SHORT\t\t\t\"\\t.value\"\n+\n+#undef ASM_LONG\n+#define ASM_LONG\t\t\t\"\\t.long\"\n+\n+#undef ASM_DOUBLE\n+#define ASM_DOUBLE\t\t\t\"\\t.double\"\n+\n+#undef TYPE_ASM_OP\n+#define TYPE_ASM_OP\t\t\t\"\\t.type\"\n+\n+#undef SIZE_ASM_OP\n+#define SIZE_ASM_OP\t\t\t\"\\t.size\"\n+\n+#undef STRING_ASM_OP\n+#define STRING_ASM_OP\t\t\t\"\\t.string\"\n+\n+#undef SKIP_ASM_OP\n+#define SKIP_ASM_OP\t\t\t\"\\t.zero\"\n+\n+#undef GLOBAL_ASM_OP\n+#define GLOBAL_ASM_OP\t\t\t\"\\t.globl\"\n+\n+#undef CONST_SECTION_ASM_OP\n+#define CONST_SECTION_ASM_OP_COFF\t\"\\t.section\\t.rodata, \\\"x\\\"\"\n+#define CONST_SECTION_ASM_OP_ELF\t\"\\t.section\\t.rodata\"\n+#define CONST_SECTION_ASM_OP\t\\\n+  ((TARGET_ELF) ? CONST_SECTION_ASM_OP_ELF : CONST_SECTION_ASM_OP_COFF)\n+\n+#undef USE_CONST_SECTION\n+#define USE_CONST_SECTION_ELF\t\t1\n+#define USE_CONST_SECTION_COFF\t\t0\n+#define USE_CONST_SECTION\t\\\n+ ((TARGET_ELF) ? USE_CONST_SECTION_ELF : USE_CONST_SECTION_COFF)\n+\n+#undef INIT_SECTION_ASM_OP\n+#define INIT_SECTION_ASM_OP_ELF\t\t\"\\t.section\\t.init\"\n+#define INIT_SECTION_ASM_OP_COFF\t\"\\t.section\\t.init ,\\\"x\\\"\"\n+#define INIT_SECTION_ASM_OP\t\\\n+  ((TARGET_ELF) ? INIT_SECTION_ASM_OP_ELF : INIT_SECTION_ASM_OP_COFF)\n+\n+#undef CTORS_SECTION_ASM_OP\n+#define CTORS_SECTION_ASM_OP_ELF\t\"\\t.section\\t.ctors,\\\"aw\\\"\"\n+#define CTORS_SECTION_ASM_OP_COFF\tINIT_SECTION_ASM_OP_COFF\n+#define CTORS_SECTION_ASM_OP\t\\\n+ ((TARGET_ELF) ? CTORS_SECTION_ASM_OP_ELF : CTORS_SECTION_ASM_OP_COFF)\n+\n+#undef DTORS_SECTION_ASM_OP\n+#define DTORS_SECTION_ASM_OP_ELF\t\"\\t.section\\t.dtors, \\\"aw\\\"\"\n+#define DTORS_SECTION_ASM_OP_COFF\tFINI_SECTION_ASM_OP_COFF\n+#define DTORS_SECTION_ASM_OP\t\\\n+ ((TARGET_ELF) ? DTORS_SECTION_ASM_OP_ELF : DTORS_SECTION_ASM_OP_COFF)\n+\n+#undef FINI_SECTION_ASM_OP\n+#define FINI_SECTION_ASM_OP_ELF\t\t\"\\t.section\\t.fini\"\n+#define FINI_SECTION_ASM_OP_COFF\t\"\\t.section\\t.fini, \\\"x\\\"\"\n+#define FINI_SECTION_ASM_OP\t\\\n+ ((TARGET_ELF) ? FINI_SECTION_ASM_OP_ELF : FINI_SECTION_ASM_OP_COFF)\n+\n+#undef BSS_SECTION_ASM_OP\n+#define BSS_SECTION_ASM_OP\t\t\"\\t.bss\"\n+\n+#undef TEXT_SECTION_ASM_OP\n+#define TEXT_SECTION_ASM_OP\t\t\"\\t.text\"\n+\n+#undef DATA_SECTION_ASM_OP\n+#define DATA_SECTION_ASM_OP\t\t\"\\t.data\"\n+\n+#undef TYPE_OPERAND_FMT\n+#define TYPE_OPERAND_FMT\t\t\"@%s\"\n+\n+#undef APPLY_RESULT_SIZE\n+#define APPLY_RESULT_SIZE\t\t\t\t\t\t\\\n+(TARGET_ELF) ? size : 116\n+\n+#ifndef ASM_DECLARE_RESULT\n+#define ASM_DECLARE_RESULT(FILE, RESULT)\n+#endif\n+\n+#define SCO_DEFAULT_ASM_COFF(FILE,NAME)\t\t\t\t\t\\\n+do {\t\t\t\t\t\t\t\t\t\\\n+    if (output_bytecode)\t\t\t\t\t\t\\\n+      BC_OUTPUT_LABEL (FILE, NAME);\t\t\t\t\t\\\n+    else\t\t\t\t\t\t\t\t\\\n+      ASM_OUTPUT_LABEL (FILE, NAME);\t\t\t\t\t\\\n+  } while (0)\n+\n+#undef ASM_DECLARE_FUNCTION_NAME\n+#define ASM_DECLARE_FUNCTION_NAME(FILE, NAME, DECL)\t\t\t\\\n+  do {\t\t\t\t\t\t\t\t\t\\\n+    if (TARGET_ELF) {\t\t\t\t\t\t\t\\\n+      fprintf (FILE, \"%s\\t \", TYPE_ASM_OP);\t\t\t\t\\\n+      assemble_name (FILE, NAME);\t\t\t\t\t\\\n+      putc (',', FILE);\t\t\t\t\t\t\t\\\n+      fprintf (FILE, TYPE_OPERAND_FMT, \"function\");\t\t\t\\\n+      putc ('\\n', FILE);\t\t\t\t\t\t\\\n+      ASM_DECLARE_RESULT (FILE, DECL_RESULT (DECL));\t\t\t\\\n+      ASM_OUTPUT_LABEL(FILE, NAME);\t\t\t\t\t\\\n+    } else\t\t\t\t\t\t\t\t\\\n+      SCO_DEFAULT_ASM_COFF(FILE, NAME);\t\t\t\t\t\\\n+} while (0)\n+\n+#undef ASM_DECLARE_FUNCTION_SIZE\n+#define ASM_DECLARE_FUNCTION_SIZE(FILE, FNAME, DECL)\t\t\t\\\n+  do {\t\t\t\t\t\t\t\t\t\\\n+    if (TARGET_ELF) { if (!flag_inhibit_size_directive)\t\t\t\\\n+      {\t\t\t\t\t\t\t\t\t\\\n+\tfprintf (FILE, \"%s\\t \", SIZE_ASM_OP);\t\t\t\t\\\n+\tassemble_name (FILE, (FNAME));\t\t\t\t\t\\\n+        fprintf (FILE, \",.-\");\t\t\t\t\t\t\\\n+\tassemble_name (FILE, (FNAME));\t\t\t\t\t\\\n+\tputc ('\\n', FILE);\t\t\t\t\t\t\\\n+      }\t}\t\t\t\t\t\t\t\t\\\n+  } while (0)\n+\n+#undef ASM_DECLARE_OBJECT_NAME\n+#define ASM_DECLARE_OBJECT_NAME(FILE, NAME, DECL)\t\t\t\\\n+  do {\t\t\t\t\t\t\t\t\t\\\n+    if (TARGET_ELF) {\t\t\t\t\t\t\t\\\n+      fprintf (FILE, \"%s\\t \", TYPE_ASM_OP);\t\t\t\t\\\n+      assemble_name (FILE, NAME);\t\t\t\t\t\\\n+      putc (',', FILE);\t\t\t\t\t\t\t\\\n+      fprintf (FILE, TYPE_OPERAND_FMT, \"object\");\t\t\t\\\n+      putc ('\\n', FILE);\t\t\t\t\t\t\\\n+      size_directive_output = 0;\t\t\t\t\t\\\n+      if (!flag_inhibit_size_directive && DECL_SIZE (DECL))\t\t\\\n+        {\t\t\t\t\t\t\t\t\\\n+  \tsize_directive_output = 1;\t\t\t\t\t\\\n+\tfprintf (FILE, \"%s\\t \", SIZE_ASM_OP);\t\t\t\t\\\n+\tassemble_name (FILE, NAME);\t\t\t\t\t\\\n+\tfprintf (FILE, \",%d\\n\",  int_size_in_bytes (TREE_TYPE (DECL)));\t\\\n+        }\t\t\t\t\t\t\t\t\\\n+      ASM_OUTPUT_LABEL(FILE, NAME);\t\t\t\t\t\\\n+    } else\t\t\t\t\t\t\t\t\\\n+      SCO_DEFAULT_ASM_COFF(FILE, NAME);\t\t\t\t\t\\\n+  } while (0)\n+\n+#undef ASM_FILE_START_1\n+#define ASM_FILE_START_1(FILE)\n+\n+#undef ASM_FILE_START\n+#define ASM_FILE_START(FILE)\t\t\t\t\t\t\\\n+do {\t\t\t\t\t\t\t\t\t\\\n+  output_file_directive((FILE),main_input_filename);\t\t\t\\\n+  fprintf ((FILE), \"\\t.version\\t\\\"01.01\\\"\\n\");\t\t\t\t\\\n+} while (0)\n+\n+#undef ASM_FILE_END\n+#define ASM_FILE_END(FILE)\t\t\t\t\t\t\\\n+do {\t\t\t\t\t\t\t\t\t\\\n+  fprintf ((FILE), \"%s\\t\\\"GCC: (GNU) %s\\\"\\n\",\t\t\t\t\\\n+    IDENT_ASM_OP, version_string);\t\t\t\t\t\\\n+} while (0)\n+\n+#undef ASM_FINISH_DECLARE_OBJECT\n+#define ASM_FINISH_DECLARE_OBJECT(FILE, DECL, TOP_LEVEL, AT_END)\t \\\n+do {\t\t\t\t\t\t\t\t\t \\\n+  if (TARGET_ELF) {\t\t\t\t\t\t\t\\\n+     char *name = XSTR (XEXP (DECL_RTL (DECL), 0), 0);\t\t\t \\\n+     if (!flag_inhibit_size_directive && DECL_SIZE (DECL)\t\t \\\n+         && ! AT_END && TOP_LEVEL\t\t\t\t\t \\\n+\t && DECL_INITIAL (DECL) == error_mark_node\t\t\t \\\n+\t && !size_directive_output)\t\t\t\t\t \\\n+       {\t\t\t\t\t\t\t\t \\\n+\t size_directive_output = 1;\t\t\t\t\t \\\n+\t fprintf (FILE, \"%s\\t \", SIZE_ASM_OP);\t\t\t \t \\\n+\t assemble_name (FILE, name);\t\t\t\t\t \\\n+\t fprintf (FILE, \",%d\\n\",  int_size_in_bytes (TREE_TYPE (DECL))); \\\n+       }\t\t\t\t\t\t\t\t \\\n+    }\t\t\t\t\t\t\t\t\t \\\n+} while (0)\n+\n+#undef ASM_GENERATE_INTERNAL_LABEL\n+#define ASM_GENERATE_INTERNAL_LABEL(LABEL, PREFIX, NUM)\t\t\t\\\n+do {\t\t\t\t\t\t\t\t\t\\\n+  if (TARGET_ELF)\t\t\t\t\t\t\t\\\n+    sprintf (LABEL, \"*.%s%d\", (PREFIX), (NUM));\t\t\t\t\\\n+  else\t\t\t\t\t\t\t\t\t\\\n+    sprintf (LABEL, \".%s%d\", (PREFIX), (NUM));\t\t\t\t\\\n+} while (0)\n+\n+#undef ASM_OUTPUT_ADDR_DIFF_ELT\n+#define ASM_OUTPUT_ADDR_DIFF_ELT(FILE, VALUE, REL) \\\n+do {\t\t\t\t\t\t\t\t\t\\\n+  if (TARGET_ELF)\t\t\t\t\t\t\t\\\n+    fprintf (FILE, \"%s _GLOBAL_OFFSET_TABLE_+[.-%s%d]\\n\", ASM_LONG, LPREFIX, VALUE); \\\n+  else\t\t\t\t\t\t\t\t\t\\\n+    fprintf (FILE, \"\\t.word %s%d-%s%d\\n\", LPREFIX,VALUE,LPREFIX,REL);\t\\\n+} while (0)\n+\n+#undef ASM_OUTPUT_ALIGNED_COMMON\n+#define ASM_OUTPUT_ALIGNED_COMMON(FILE, NAME, SIZE, ALIGN)\t\t\\\n+do {\t\t\t\t\t\t\t\t\t\\\n+  fprintf ((FILE), \"%s\\t\", COMMON_ASM_OP);\t\t\t\t\\\n+  assemble_name ((FILE), (NAME));\t\t\t\t\t\\\n+  if (TARGET_ELF)\t\t\t\t\t\t\t\\\n+    fprintf ((FILE), \",%u,%u\\n\", (SIZE), (ALIGN) / BITS_PER_UNIT);\t\\\n+  else\t\t\t\t\t\t\t\t\t\\\n+    fprintf ((FILE), \",%u\\n\", (SIZE));\t\t\t\t\t\\\n+} while (0)\n+\n+#undef ASM_OUTPUT_ALIGNED_LOCAL\n+#define ASM_OUTPUT_ALIGNED_LOCAL(FILE, NAME, SIZE, ALIGN)\t\t\\\n+do {\t\t\t\t\t\t\t\t\t\\\n+  if (TARGET_ELF) {\t\t\t\t\t\t\t\\\n+    fprintf ((FILE), \"%s\\t\", LOCAL_ASM_OP);\t\t\t\t\\\n+    assemble_name ((FILE), (NAME));\t\t\t\t\t\\\n+    fprintf ((FILE), \"\\n\");\t\t\t\t\t\t\\\n+    ASM_OUTPUT_ALIGNED_COMMON (FILE, NAME, SIZE, ALIGN);\t\t\\\n+  } else {\t\t\t\t\t\t\t\t\\\n+    int align = exact_log2 (ALIGN);\t\t\t\t\t\\\n+    if (align > 2) align = 2;\t\t\t\t\t\t\\\n+    if (TARGET_SVR3_SHLIB)\t\t\t\t\t\t\\\n+      data_section ();\t\t\t\t\t\t\t\\\n+    else\t\t\t\t\t\t\t\t\\\n+      bss_section ();\t\t\t\t\t\t\t\\\n+    ASM_OUTPUT_ALIGN ((FILE), align == -1 ? 2 : align);\t\t\t\\\n+    ASM_OUTPUT_LABEL ((FILE), (NAME));\t\t\t\t\t\\\n+    fprintf ((FILE), \"%s\\t.,.+%u\\n\", SET_ASM_OP, (ALIGN));\t\t\\\n+   }\t\t\t\t\t\t\t\t\t\\\n+} while (0)\n+\n+#undef ESCAPES\n+#define ESCAPES \\\n+\"\\1\\1\\1\\1\\1\\1\\1\\1btn\\1fr\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\\n+\\0\\0\\\"\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\\n+\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\\\\\0\\0\\0\\\n+\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\1\\\n+\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\\n+\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\\n+\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\\n+\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\"\n+\n+#undef STRING_LIMIT\n+#define STRING_LIMIT\t((unsigned) 256)\n+\n+#undef ASM_OUTPUT_LIMITED_STRING\n+#define ASM_OUTPUT_LIMITED_STRING(FILE, STR)\t\t\t\t\\\n+  do\t\t\t\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\t\\\n+      register unsigned char *_limited_str = (unsigned char *) (STR);\t\\\n+      register unsigned ch;\t\t\t\t\t\t\\\n+      fprintf ((FILE), \"%s\\t\\\"\", STRING_ASM_OP);\t\t\t\\\n+      for (; ch = *_limited_str; _limited_str++)\t\t\t\\\n+        {\t\t\t\t\t\t\t\t\\\n+\t  register int escape;\t\t\t\t\t\t\\\n+\t  switch (escape = ESCAPES[ch])\t\t\t\t\t\\\n+\t    {\t\t\t\t\t\t\t\t\\\n+\t    case 0:\t\t\t\t\t\t\t\\\n+\t      putc (ch, (FILE));\t\t\t\t\t\\\n+\t      break;\t\t\t\t\t\t\t\\\n+\t    case 1:\t\t\t\t\t\t\t\\\n+\t      fprintf ((FILE), \"\\\\%03o\", ch);\t\t\t\t\\\n+\t      break;\t\t\t\t\t\t\t\\\n+\t    default:\t\t\t\t\t\t\t\\\n+\t      putc ('\\\\', (FILE));\t\t\t\t\t\\\n+\t      putc (escape, (FILE));\t\t\t\t\t\\\n+\t      break;\t\t\t\t\t\t\t\\\n+\t    }\t\t\t\t\t\t\t\t\\\n+        }\t\t\t\t\t\t\t\t\\\n+      fprintf ((FILE), \"\\\"\\n\");\t\t\t\t\t\t\\\n+    }\t\t\t\t\t\t\t\t\t\\\n+  while (0)\n+\n+\n+#undef ASM_OUTPUT_ASCII\n+#define ASM_OUTPUT_ASCII(FILE, STR, LENGTH)\t\t\t\t\\\n+do {\t\t\t\t\t\t\t\t\t\\\n+   if (TARGET_ELF) {\t\t\t\t\t\t\t\\\n+      register unsigned char *_ascii_bytes = (unsigned char *) (STR);\t\\\n+      register unsigned char *limit = _ascii_bytes + (LENGTH);\t\t\\\n+      register unsigned bytes_in_chunk = 0;\t\t\t\t\\\n+      for (; _ascii_bytes < limit; _ascii_bytes++)\t\t\t\\\n+        {\t\t\t\t\t\t\t\t\\\n+\t  register unsigned char *p;\t\t\t\t\t\\\n+\t  if (bytes_in_chunk >= 64)\t\t\t\t\t\\\n+\t    {\t\t\t\t\t\t\t\t\\\n+\t      fputc ('\\n', (FILE));\t\t\t\t\t\\\n+\t      bytes_in_chunk = 0;\t\t\t\t\t\\\n+\t    }\t\t\t\t\t\t\t\t\\\n+\t  for (p = _ascii_bytes; p < limit && *p != '\\0'; p++)\t\t\\\n+\t    continue;\t\t\t\t\t\t\t\\\n+\t  if (p < limit && (p - _ascii_bytes) <= STRING_LIMIT)\t\t\\\n+\t    {\t\t\t\t\t\t\t\t\\\n+\t      if (bytes_in_chunk > 0)\t\t\t\t\t\\\n+\t\t{\t\t\t\t\t\t\t\\\n+\t\t  fputc ('\\n', (FILE));\t\t\t\t\t\\\n+\t\t  bytes_in_chunk = 0;\t\t\t\t\t\\\n+\t\t}\t\t\t\t\t\t\t\\\n+\t      ASM_OUTPUT_LIMITED_STRING ((FILE), _ascii_bytes);\t\t\\\n+\t      _ascii_bytes = p;\t\t\t\t\t\t\\\n+\t    }\t\t\t\t\t\t\t\t\\\n+\t  else\t\t\t\t\t\t\t\t\\\n+\t    {\t\t\t\t\t\t\t\t\\\n+\t      if (bytes_in_chunk == 0)\t\t\t\t\t\\\n+\t\tfprintf ((FILE), \"%s\\t\", ASM_BYTE_OP);\t\t\t\\\n+\t      else\t\t\t\t\t\t\t\\\n+\t\tfputc (',', (FILE));\t\t\t\t\t\\\n+\t      fprintf ((FILE), \"0x%02x\", *_ascii_bytes);\t\t\\\n+\t      bytes_in_chunk += 5;\t\t\t\t\t\\\n+\t    }\t\t\t\t\t\t\t\t\\\n+\t}\t\t\t\t\t\t\t\t\\\n+      if (bytes_in_chunk > 0)\t\t\t\t\t\t\\\n+        fprintf ((FILE), \"\\n\");\t\t\t\t\t\t\\\n+  } else {\t\t\t\t\t\t\t\t\\\n+   int i = 0; \t\t\t\t\t\t\t\t\\\n+   while (i < (LENGTH))\t\t\t\t\t\t\t\\\n+    { if (i%10 == 0) { if (i!=0) fprintf ((FILE), \"\\n\");\t\t\\\n+\t\t       fprintf ((FILE), \"%s \", ASM_BYTE_OP); }\t\t\\\n+      else fprintf ((FILE), \",\");\t\t\t\t\t\\\n+\tfprintf ((FILE), \"0x%x\", ((STR)[i++] & 0377)) ;}\t\t\\\n+      fprintf ((FILE), \"\\n\"); }\t\t\t\t\t\t\\\n+} while (0)\n+\n+#undef ASM_OUTPUT_CASE_LABEL\n+#define ASM_OUTPUT_CASE_LABEL(FILE,PREFIX,NUM,JUMPTABLE)\t\t\\\n+do {\t\t\t\t\t\t\t\t\t\\\n+  if (TARGET_ELF)\t\t\t\t\t\t\t\\\n+    ASM_OUTPUT_ALIGN ((FILE), 2);\t\t\t\t\t\\\n+  ASM_OUTPUT_INTERNAL_LABEL((FILE),(PREFIX),(NUM));\t\t\t\\\n+} while (0)\n+\n+\n+#undef ASM_OUTPUT_CONSTRUCTOR\n+#define ASM_OUTPUT_CONSTRUCTOR(FILE,NAME)\t\t\t\t\\\n+do {\t\t\t\t\t\t\t\t\t\\\n+  if (TARGET_ELF) {\t\t\t\t\t\t\t\\\n+     ctors_section ();\t\t\t\t\t\t\t\\\n+     fprintf (FILE, \"%s\\t \", INT_ASM_OP);\t\t\t\t\\\n+     assemble_name (FILE, NAME);\t\t\t\t\t\\\n+     fprintf (FILE, \"\\n\");\t\t\t\t\t\t\\\n+  } else {\t\t\t\t\t\t\t\t\\\n+    init_section ();\t\t\t\t\t\t\t\\\n+    fprintf (FILE, \"\\tpushl $\");\t\t\t\t\t\\\n+    assemble_name (FILE, NAME);\t\t\t\t\t\t\\\n+    fprintf (FILE, \"\\n\"); }\t\t\t\t\t\t\\\n+  } while (0)\n+\n+#undef ASM_OUTPUT_DESTRUCTOR\n+#define ASM_OUTPUT_DESTRUCTOR(FILE,NAME)\t\t\t\t\\\n+do {\t\t\t\t\t\t\t\t\t\\\n+  if (TARGET_ELF) {\t\t\t\t\t\t\t\\\n+    dtors_section ();                   \t\t\t\t\\\n+    fprintf (FILE, \"%s\\t \", INT_ASM_OP);\t\t\t\t\\\n+    assemble_name (FILE, NAME);              \t\t\t\t\\\n+    fprintf (FILE, \"\\n\");\t\t\t\t\t\t\\\n+  } else {\t\t\t\t\t\t\t\t\\\n+    fini_section ();                   \t\t\t\t\t\\\n+    fprintf (FILE, \"%s\\t \", ASM_LONG);\t\t\t\t\t\\\n+    assemble_name (FILE, NAME);              \t\t\t\t\\\n+    fprintf (FILE, \"\\n\"); }\t\t\t\t\t\t\\\n+  } while (0)\n+\n+\n+#undef ASM_OUTPUT_DOUBLE\n+#define ASM_OUTPUT_DOUBLE(FILE,VALUE)\t\t\t\t\t\\\n+do {\t\t\t\t\t\t\t\t\t\\\n+  long value[2];\t\t\t\t\t\t\t\\\n+  REAL_VALUE_TO_TARGET_DOUBLE ((VALUE), value);\t\t\t\t\\\n+  if (TARGET_ELF) {\t\t\t\t\t\t\t\\\n+     if (sizeof (int) == sizeof (long))\t\t\t\t\t\\\n+       {\t\t\t\t\t\t\t\t\\\n+         fprintf((FILE), \"%s\\t0x%x\\n\", ASM_LONG, value[0]);\t\t\\\n+         fprintf((FILE), \"%s\\t0x%x\\n\", ASM_LONG, value[1]);\t\t\\\n+       }\t\t\t\t\t\t\t\t\\\n+     else\t\t\t\t\t\t\t\t\\\n+       {\t\t\t\t\t\t\t\t\\\n+         fprintf((FILE), \"%s\\t0x%lx\\n\", ASM_LONG, value[0]);\t\t\\\n+         fprintf((FILE), \"%s\\t0x%lx\\n\", ASM_LONG, value[1]);\t\t\\\n+       }\t\t\t\t\t\t\t\t\\\n+  } else {\t\t\t\t\t\t\t\t\\\n+     if (sizeof (int) == sizeof (long))\t\t\t\t\t\\\n+       fprintf (FILE, \"%s 0x%x,0x%x\\n\", ASM_LONG, value[0], value[1]);\t\\\n+     else\t\t\t\t\t\t\t\t\\\n+       fprintf (FILE, \"%s 0x%lx,0x%lx\\n\", ASM_LONG,value[0],value[1]);}\t\\\n+} while (0)\n+\n+#undef ASM_OUTPUT_FLOAT\n+#define ASM_OUTPUT_FLOAT(FILE,VALUE)\t\t\t\t\t\\\n+do {\t\t\t\t\t\t\t\t\t\\\n+  long value;\t\t\t\t\t\t\t\t\\\n+  REAL_VALUE_TO_TARGET_SINGLE ((VALUE), value);\t\t\t\t\\\n+  if (sizeof (int) == sizeof (long))\t\t\t\t\t\\\n+     fprintf((FILE), \"%s\\t0x%x\\n\", ASM_LONG, value);\t\t\t\\\n+  else\t\t\t\t\t\t\t\t\t\\\n+     fprintf((FILE), \"%s\\t0x%lx\\n\", ASM_LONG, value);\t\t\t\\\n+} while (0)\n+\n+#undef ASM_OUTPUT_LONG_DOUBLE\n+#define ASM_OUTPUT_LONG_DOUBLE(FILE,VALUE)\t\t\t\t\\\n+do {\t\t\t\t\t\t\t\t\t\\\n+  long l[3];\t\t\t\t\t\t\t\t\\\n+  REAL_VALUE_TO_TARGET_LONG_DOUBLE ((VALUE), l);\t\t\t\\\n+  if (TARGET_ELF) {\t\t\t\t\t\t\t\\\n+     if (sizeof (int) == sizeof (long))\t\t\t\t\t\\\n+       {\t\t\t\t\t\t\t\t\\\n+         fprintf((FILE), \"%s\\t0x%x\\n\", ASM_LONG, l[0]);\t\t\t\\\n+         fprintf((FILE), \"%s\\t0x%x\\n\", ASM_LONG, l[1]);\t\t\t\\\n+         fprintf((FILE), \"%s\\t0x%x\\n\", ASM_LONG, l[2]);\t\t\t\\\n+       }\t\t\t\t\t\t\t\t\\\n+     else\t\t\t\t\t\t\t\t\\\n+       {\t\t\t\t\t\t\t\t\\\n+         fprintf((FILE), \"%s\\t0x%lx\\n\", ASM_LONG, l[0]);\t\t\\\n+         fprintf((FILE), \"%s\\t0x%lx\\n\", ASM_LONG, l[1]);\t\t\\\n+         fprintf((FILE), \"%s\\t0x%lx\\n\", ASM_LONG, l[2]);\t\t\\\n+       }\t\t\t\t\t\t\t\t\\\n+  } else {\t\t\t\t\t\t\t\t\\\n+     if (sizeof (int) == sizeof (long))\t\t\t\t\t\\\n+       fprintf (FILE, \"%s 0x%x,0x%x,0x%x\\n\", ASM_LONG, l[0], l[1], l[2]); \\\n+     else\t\t\t\t\t\t\t\t\\\n+       fprintf (FILE, \"%s 0x%lx,0x%lx,0x%lx\\n\", ASM_LONG,l[0],l[1],l[2]);} \\\n+} while (0)\n+\n+#undef ASM_OUTPUT_IDENT\n+#define ASM_OUTPUT_IDENT(FILE, NAME) \\\n+  fprintf (FILE, \"%s\\t\\\"%s\\\"\\n\", IDENT_ASM_OP, NAME);\n+\n+#undef ASM_GLOBALIZE_LABEL\n+#define ASM_GLOBALIZE_LABEL(FILE,NAME)\t\\\n+  (fprintf ((FILE), \"%s \", GLOBAL_ASM_OP), assemble_name (FILE, NAME), fputs (\"\\n\", FILE))\n+\n+#undef ASM_OUTPUT_EXTERNAL_LIBCALL\n+#define ASM_OUTPUT_EXTERNAL_LIBCALL(FILE, FUN)\t\t\t\t\\\n+  if (TARGET_ELF) ASM_GLOBALIZE_LABEL (FILE, XSTR (FUN, 0))\n+\n+#undef ASM_OUTPUT_INTERNAL_LABEL\n+#define ASM_OUTPUT_INTERNAL_LABEL(FILE,PREFIX,NUM)\t\t\t\\\n+  fprintf (FILE, \".%s%d:\\n\", PREFIX, NUM)\n+\n+#undef ASM_OUTPUT_LABELREF\n+#define ASM_OUTPUT_LABELREF(FILE,NAME)\t\t\t\t\t\\\n+  fprintf (FILE, \"%s\", NAME)\n+\n+#undef ASM_OUTPUT_SECTION_NAME\n+#define ASM_OUTPUT_SECTION_NAME(FILE, DECL, NAME) \\\n+do {\t\t\t\t\t\t\t\t\t\\\n+  if (TARGET_ELF)\t\t\t\t\t\t\t\\\n+    fprintf (FILE, \".section\\t%s,\\\"%s\\\",@progbits\\n\", NAME, \t\t\\\n+\t   (DECL) && TREE_CODE (DECL) == FUNCTION_DECL ? \"ax\" : \t\\\n+\t   (DECL) && TREE_READONLY (DECL) ? \"a\" : \"aw\");\t\t\\\n+} while (0)\n+\n+#undef ASM_OUTPUT_SKIP\n+#define ASM_OUTPUT_SKIP(FILE,SIZE) \\\n+do {\t\t\t\t\t\t\t\t\t\\\n+  if (TARGET_ELF)\t\t\t\t\t\t\t\\\n+    fprintf (FILE, \"%s\\t%u\\n\", SKIP_ASM_OP, (SIZE));\t\t\t\\\n+  else\t\t\t\t\t\t\t\t\t\\\n+    fprintf ((FILE), \"%s\\t.,.+%u\\n\", SET_ASM_OP, (SIZE));\t\t\\\n+} while (0)\n+\n+\n+#undef CLASS_LIKELY_SPILLED_P\n+#define CLASS_LIKELY_SPILLED_P(CLASS)\t\t\t\t\t\\\n+  (TARGET_ELF) ? (reg_class_size[(int)(CLASS)] == 1) :\t\t\t\\\n+    (((CLASS) == AREG) || ((CLASS) == DREG) || ((CLASS) == CREG) ||\t\\\n+    ((CLASS) == BREG) || ((CLASS) == SIREG) || ((CLASS) == DIREG))\n+\n+#undef CTOR_LIST_BEGIN\n+#define CTOR_LIST_BEGIN\t\t\t\t\t\t\t\\\n+do {\t\t\t\t\t\t\t\t\t\\\n+  asm (CTORS_SECTION_ASM_OP);\t\t\t\t\t\t\\\n+  if (TARGET_ELF)\t\t\t\t\t\t\t\\\n+    STATIC func_ptr __CTOR_LIST__[1] = { (func_ptr) (-1) };\t\t\\\n+  else\t\t\t\t\t\t\t\t\t\\\n+    asm (\"pushl $0\");\t\t\t\t\t\t\t\\\n+} while (0)\n+\n+#undef CTOR_LIST_END\n+#define CTOR_LIST_END\t\t\t\t\t\t\t\\\n+do {\t\t\t\t\t\t\t\t\t\\\n+  if (TARGET_ELF) {\t\t\t\t\t\t\t\\\n+    asm (CTORS_SECTION_ASM_OP);\t\t\t\t\t\t\\\n+    STATIC func_ptr __CTOR_LIST__[1] = { (func_ptr) (0) };\t\t\\\n+  } else {\t\t\t\t\t\t\t\t\\\n+    CTOR_LIST_BEGIN;\t\t\t\t\t\t\t\\\n+  }\t\t\t\t\t\t\t\t\t\\\n+} while (0)\n+\n+#undef DBX_BLOCKS_FUNCTION_RELATIVE\n+#define DBX_BLOCKS_FUNCTION_RELATIVE 1\n+\n+#undef DBX_FUNCTION_FIRST\n+#define DBX_FUNCTION_FIRST 1\n+\n+#undef DBX_REGISTER_NUMBER\n+#define DBX_REGISTER_NUMBER(n)\t\t\t\t\t\t\\\n+((TARGET_ELF) ?\t\t\t\t\t\t\t\t\\\n+ ((n) == 0 ? 0 \t\t\t\t\t\t\t\t\\\n+  : (n) == 1 ? 2 \t\t\t\t\t\t\t\\\n+  : (n) == 2 ? 1 \t\t\t\t\t\t\t\\\n+  : (n) == 3 ? 3 \t\t\t\t\t\t\t\\\n+  : (n) == 4 ? 6 \t\t\t\t\t\t\t\\\n+  : (n) == 5 ? 7 \t\t\t\t\t\t\t\\\n+  : (n) == 6 ? 5 \t\t\t\t\t\t\t\\\n+  : (n) == 7 ? 4 \t\t\t\t\t\t\t\\\n+  : ((n) >= FIRST_STACK_REG && (n) <= LAST_STACK_REG) ? (n)+3 \t\t\\\n+  : (-1))\t\t\t\t\t\t\t\t\\\n+ :\t\t\t\t\t\t\t\t\t\\\n+ ((n) == 0 ? 0 : \t\t\t\t\t\t\t\\\n+  (n) == 1 ? 2 : \t\t\t\t\t\t\t\\\n+  (n) == 2 ? 1 : \t\t\t\t\t\t\t\\\n+  (n) == 3 ? 3 : \t\t\t\t\t\t\t\\\n+  (n) == 4 ? 6 : \t\t\t\t\t\t\t\\\n+  (n) == 5 ? 7 : \t\t\t\t\t\t\t\\\n+  (n) == 6 ? 4 : \t\t\t\t\t\t\t\\\n+  (n) == 7 ? 5 : \t\t\t\t\t\t\t\\\n+  (n) + 4))\n+\n+#undef DWARF_DEBUGGING_INFO\n+#undef SDB_DEBUGGING_INFO\n+#undef DBX_DEBUGGING_INFO\n+#undef PREFERRED_DEBUGGING_TYPE\n+\n+#define DWARF_DEBUGGING_INFO 1\n+#define SDB_DEBUGGING_INFO   1\n+#define PREFERRED_DEBUGGING_TYPE\t\t\t\t\t\\\n+  ((TARGET_ELF) ? DWARF_DEBUG: SDB_DEBUG)\n+\n+#undef EXTRA_SECTIONS\n+#define EXTRA_SECTIONS in_const, in_bss, in_init, in_fini, in_ctors, in_dtors\n+\n+#undef EXTRA_SECTION_FUNCTIONS\n+#define EXTRA_SECTION_FUNCTIONS\t\t\t\t\t\t\\\n+  CONST_SECTION_FUNCTION\t\t\t\t\t\t\\\n+  BSS_SECTION_FUNCTION\t\t\t\t\t\t\t\\\n+  INIT_SECTION_FUNCTION\t\t\t\t\t\t\t\\\n+  FINI_SECTION_FUNCTION\t\t\t\t\t\t\t\\\n+  CTORS_SECTION_FUNCTION\t\t\t\t\t\t\\\n+  DTORS_SECTION_FUNCTION\n+\n+#undef CONST_SECTION_FUNCTION\n+#define CONST_SECTION_FUNCTION\t\t\t\t\t\t\\\n+void\t\t\t\t\t\t\t\t\t\\\n+const_section ()\t\t\t\t\t\t\t\\\n+{\t\t\t\t\t\t\t\t\t\\\n+  extern void text_section();\t\t\t\t\t\t\\\n+  if (!USE_CONST_SECTION)\t\t\t\t\t\t\\\n+    text_section();\t\t\t\t\t\t\t\\\n+  else if (in_section != in_const)\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\t\\\n+      fprintf (asm_out_file, \"%s\\n\", CONST_SECTION_ASM_OP);\t\t\\\n+      in_section = in_const;\t\t\t\t\t\t\\\n+    }\t\t\t\t\t\t\t\t\t\\\n+}\n+\n+#undef FINI_SECTION_FUNCTION\n+#define FINI_SECTION_FUNCTION\t\t\t\t\t\t\\\n+void\t\t\t\t\t\t\t\t\t\\\n+fini_section ()\t\t\t\t\t\t\t\t\\\n+{\t\t\t\t\t\t\t\t\t\\\n+  if ((!TARGET_ELF) && in_section != in_fini)\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\t\\\n+      fprintf (asm_out_file, \"%s\\n\", FINI_SECTION_ASM_OP);\t\t\\\n+      in_section = in_fini;\t\t\t\t\t\t\\\n+    }\t\t\t\t\t\t\t\t\t\\\n+}\n+\n+#undef BSS_SECTION_FUNCTION\n+#define BSS_SECTION_FUNCTION\t\t\t\t\t\t\\\n+void\t\t\t\t\t\t\t\t\t\\\n+bss_section ()\t\t\t\t\t\t\t\t\\\n+{\t\t\t\t\t\t\t\t\t\\\n+  if (in_section != in_bss)\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\t\\\n+      fprintf (asm_out_file, \"%s\\n\", BSS_SECTION_ASM_OP);\t\t\\\n+      in_section = in_bss;\t\t\t\t\t\t\\\n+    }\t\t\t\t\t\t\t\t\t\\\n+}\n+\n+#undef INIT_SECTION_FUNCTION\n+#define INIT_SECTION_FUNCTION\t\t\t\t\t\t\\\n+void\t\t\t\t\t\t\t\t\t\\\n+init_section ()\t\t\t\t\t\t\t\t\\\n+{\t\t\t\t\t\t\t\t\t\\\n+  if ((!TARGET_ELF) && in_section != in_init)\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\t\\\n+      fprintf (asm_out_file, \"%s\\n\", INIT_SECTION_ASM_OP);\t\t\\\n+      in_section = in_init;\t\t\t\t\t\t\\\n+    }\t\t\t\t\t\t\t\t\t\\\n+}\n+\n+#undef CTORS_SECTION_FUNCTION\n+#define CTORS_SECTION_FUNCTION\t\t\t\t\t\t\\\n+void\t\t\t\t\t\t\t\t\t\\\n+ctors_section ()\t\t\t\t\t\t\t\\\n+{\t\t\t\t\t\t\t\t\t\\\n+  if (in_section != in_ctors)\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\t\\\n+      fprintf (asm_out_file, \"%s\\n\", CTORS_SECTION_ASM_OP);\t\t\\\n+      in_section = in_ctors;\t\t\t\t\t\t\\\n+    }\t\t\t\t\t\t\t\t\t\\\n+}\n+\n+#undef DTORS_SECTION_FUNCTION\n+#define DTORS_SECTION_FUNCTION\t\t\t\t\t\t\\\n+void\t\t\t\t\t\t\t\t\t\\\n+dtors_section ()\t\t\t\t\t\t\t\\\n+{\t\t\t\t\t\t\t\t\t\\\n+  if (in_section != in_dtors)\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\t\\\n+      fprintf (asm_out_file, \"%s\\n\", DTORS_SECTION_ASM_OP);\t\t\\\n+      in_section = in_dtors;\t\t\t\t\t\t\\\n+    }\t\t\t\t\t\t\t\t\t\\\n+}\n+\n+#undef FRAME_POINTER_REQUIRED\n+#define FRAME_POINTER_REQUIRED\t\t\t\t\t\t\\\n+  ((TARGET_ELF) ? 0 : \t\t\t\t\t\t\t\\\n+   (current_function_calls_setjmp || current_function_calls_longjmp))\n+\n+#undef JUMP_TABLES_IN_TEXT_SECTION\n+#define JUMP_TABLES_IN_TEXT_SECTION 1\n+\n+#undef LOCAL_LABEL_PREFIX\n+#define LOCAL_LABEL_PREFIX\t\t\t\t\t\t\\\n+ ((TARGET_ELF) ? \"\" : \".\")\n+\n+#undef MD_EXEC_PREFIX\n+#undef MD_STARTFILE_PREFIX\n+#define MD_EXEC_PREFIX \"/usr/ccs/bin/\"\n+#define MD_STARTFILE_PREFIX \"/usr/ccs/lib/\"\n+\n+#undef NON_SAVING_SETJMP\n+#define NON_SAVING_SETJMP\t\t\t\t\t\t\\\n+  ((TARGET_ELF) ? 0 : \t\t\t\t\t\t\t\\\n+   (current_function_calls_setjmp && current_function_calls_longjmp))\n+\n+#undef NO_IMPLICIT_EXTERN_C\n+#define NO_IMPLICIT_EXTERN_C 1\n+\n+/* JKJ FIXME - examine the rammifications of RETURN_IN_MEMORY and\n+   RETURN_POPS_ARGS */\n+\n+#undef RETURN_POPS_ARGS\n+#define RETURN_POPS_ARGS(FUNDECL,FUNTYPE,SIZE) \t\t\t\t\\\n+ ((TARGET_ELF) ?\t\t\t\t\t\t\t\\\n+  (i386_return_pops_args (FUNDECL, FUNTYPE, SIZE)) : \t\t\t\\\n+  (TREE_CODE (FUNTYPE) == IDENTIFIER_NODE ? 0\t\t\t\t\\\n+   : (TARGET_RTD\t\t\t\t\t\t\t\\\n+      && (TYPE_ARG_TYPES (FUNTYPE) == 0\t\t\t\t\t\\\n+\t  || (TREE_VALUE (tree_last (TYPE_ARG_TYPES (FUNTYPE)))\t\t\\\n+\t      == void_type_node))) ? (SIZE)\t\t\t\t\\\n+   : 0))\n+\n+#undef SELECT_SECTION\n+#define SELECT_SECTION(DECL,RELOC)\t\t\t\t\t\\\n+{\t\t\t\t\t\t\t\t\t\\\n+  if (TREE_CODE (DECL) == STRING_CST)\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\t\\\n+      if (! flag_writable_strings)\t\t\t\t\t\\\n+\tconst_section ();\t\t\t\t\t\t\\\n+      else\t\t\t\t\t\t\t\t\\\n+\tdata_section ();\t\t\t\t\t\t\\\n+    }\t\t\t\t\t\t\t\t\t\\\n+  else if (TREE_CODE (DECL) == VAR_DECL)\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\t\\\n+      if ((TARGET_ELF && flag_pic && RELOC)\t\t\t\t\\\n+\t  || !TREE_READONLY (DECL) || TREE_SIDE_EFFECTS (DECL)\t\t\\\n+\t  || !DECL_INITIAL (DECL)\t\t\t\t\t\\\n+\t  || (DECL_INITIAL (DECL) != error_mark_node\t\t\t\\\n+\t      && !TREE_CONSTANT (DECL_INITIAL (DECL))))\t\t\t\\\n+\tdata_section ();\t\t\t\t\t\t\\\n+      else\t\t\t\t\t\t\t\t\\\n+\tconst_section ();\t\t\t\t\t\t\\\n+    }\t\t\t\t\t\t\t\t\t\\\n+  else\t\t\t\t\t\t\t\t\t\\\n+    const_section ();\t\t\t\t\t\t\t\\\n+}\n+\n+#undef SWITCH_TAKES_ARG\n+#define SWITCH_TAKES_ARG(CHAR) \t\t\t\t\t\t\\\n+  (   (CHAR) == 'D' \t\t\t\t\t\t\t\\\n+   || (CHAR) == 'U' \t\t\t\t\t\t\t\\\n+   || (CHAR) == 'o' \t\t\t\t\t\t\t\\\n+   || (CHAR) == 'e' \t\t\t\t\t\t\t\\\n+   || (CHAR) == 'u' \t\t\t\t\t\t\t\\\n+   || (CHAR) == 'I' \t\t\t\t\t\t\t\\\n+   || (CHAR) == 'm' \t\t\t\t\t\t\t\\\n+   || (CHAR) == 'L' \t\t\t\t\t\t\t\\\n+   || (CHAR) == 'A' \t\t\t\t\t\t\t\\\n+   || (CHAR) == 'h' \t\t\t\t\t\t\t\\\n+   || (CHAR) == 'z')\n+\n+#undef WORD_SWITCH_TAKES_ARG\n+#define WORD_SWITCH_TAKES_ARG(STR)\t\t\t\t\t\\\n+ (DEFAULT_WORD_SWITCH_TAKES_ARG (STR)\t\t\t\t\t\\\n+  && strcmp (STR, \"Tdata\") && strcmp (STR, \"Ttext\")\t\t\t\\\n+  && strcmp (STR, \"Tbss\"))\n+\n+#undef TARGET_DEFAULT\n+#define TARGET_DEFAULT 0201\n+\n+#undef HANDLE_SYSV_PRAGMA\n+#define HANDLE_SYSV_PRAGMA 1\n+\n+#undef SCCS_DIRECTIVE\n+#define SCCS_DIRECTIVE 1\n+\n+/*\n+ * Define sizes and types\n+ */\n+#undef SIZE_TYPE\n+#undef PTRDIFF_TYPE\n+#undef WCHAR_TYPE\n+#undef WCHAR_TYPE_SIZE\n+#undef LONG_DOUBLE_TYPE_SIZE\n+#define LONG_DOUBLE_TYPE_SIZE \t96\n+#define SIZE_TYPE\t\t\"unsigned int\"\n+#define PTRDIFF_TYPE\t\t\"int\"\n+#define WCHAR_TYPE\t\t\"long int\"\n+#define WCHAR_TYPE_SIZE\t\tBITS_PER_WORD\n+\n+\f\n+/* Please note that these specs may look messy but they are required in\n+   order to emulate the SCO Development system as closely as possible.\n+   With SCO Open Server 5.0, you now get the linker and assembler free,\n+   so that is what these specs are targeted for. These utilities are\n+   very argument sensitive: a space in the wrong place breaks everything.\n+   So RMS, please forgive this mess. It works.\n+\n+   Parameters which can be passed to gcc, and their SCO equivalents:\n+   GCC Parameter                SCO Equivalent\n+   -ansi                        -a ansi\n+   -posix                       -a posix\n+   -Xpg4                        -a xpg4\n+   -Xpg4plus                    -a xpg4plus\n+   -Xods30                      -a ods30\n+\n+   As with SCO, the default is XPG4 plus mode. SCO also allows you to\n+   specify a C dialect with -Xt, -Xa, -Xc, -Xk and -Xm. These are passed\n+   on to the assembler and linker in the same way that the SCO compiler\n+   does.\n+\n+   SCO also allows you to compile, link and generate either ELF or COFF\n+   binaries. With gcc, as with the SCO compiler, the default is coff.\n+   Specify -melf to gcc to produce elf binaries. -fpic will get the\n+   assembler and linker to produce PIC code.\n+*/\n+\n+/* Set up assembler flags for PIC and ELF compilations */\n+#undef ASM_SPEC\n+#define ASM_SPEC \\\n+ \"-b %{melf:elf}%{!melf:coff \\\n+   %{static:%e-static only valid with -melf} \\\n+   %{shared:%e-shared only valid with -melf} \\\n+   %{symbolic:%e-symbolic only valid with -melf}} \\\n+  %{Ym,*} %{Yd,*} %{Wa,*:%*} \\\n+  %{melf:-E%{Xa:a}%{!Xa:%{Xc:c}%{!Xc:%{Xk:k}%{!Xk:%{Xt:t}%{!Xt:a}}}},%{ansi:ansi}%{!ansi:%{posix:posix}%{!posix:%{Xpg4:xpg4}%{!Xpg4:%{Xpg4plus:XPG4PLUS}%{!Xpg4plus:%{Xods30:ods30}%{!Xods30:XPG4PLUS}}}}},ELF %{Qn:} %{!Qy:-Qn}}\"\n+\n+/* Use crt1.o as a startup file and crtn.o as a closing file.  */\n+\n+#undef STARTFILE_SPEC\n+#define STARTFILE_SPEC \\\n+ \"%{!shared:\\\n+   %{!symbolic: \\\n+    %{pg:gcrt.o%s}%{!pg:%{p:mcrt1.o%s}%{!p:crt1.o%s}}}} \\\n+  %{!melf:crtbegin.o%s} \\\n+  %{melf:%{ansi:values-Xc.o%s} \\\n+    %{!ansi: \\\n+     %{traditional:values-Xt.o%s} \\\n+     %{!traditional: \\\n+      %{Xa:values-Xa.o%s} \\\n+       %{!Xa:%{Xc:values-Xc.o%s} \\\n+        %{!Xc:%{Xk:values-Xk.o%s} \\\n+         %{!Xk:%{Xt:values-Xt.o%s} \\\n+          %{!Xt:values-Xa.o%s}}}}}} \\\n+   %{static:crtbegin.o%s}%{!static:crtbeginS.o%s}}\"\n+\n+#undef ENDFILE_SPEC\n+#define ENDFILE_SPEC \\\n+ \"%{melf:%{!static:crtendS.o%s}%{static:crtend.o%s}} \\\n+  %{!melf:crtend.o%s} \\\n+  %{pg:gcrtn.o%s}%{!pg:crtn.o%s}\"\n+\n+#undef CPP_PREDEFINES\n+#define CPP_PREDEFINES \\\n+ \"-Asystem(unix) -Asystem(svr3) -Acpu(i386) -Amachine(i386)\"\n+\n+/* You are in a maze of GCC specs ... all alike */\n+\n+#undef CPP_SPEC\n+#define CPP_SPEC \\\n+ \"%{melf:-Asystem(svr4) -D__svr4__} \\\n+  %{fpic:%{!melf:%e-fpic is only valid with -melf}} \\\n+  %{fPIC:%{!melf:%e-fPIC is only valid with -melf}} \\\n+  -D__i386 -D__unix -D_SCO_DS=1 -D_M_I386 -D_M_XENIX -D_M_UNIX \\\n+  %{!Xods30:-D_STRICT_NAMES} \\\n+  %{!ansi:%{!posix:%{!Xods30:-D_SCO_XPG_VERS=4}}} \\\n+  %{ansi:-D_STRICT_ANSI} \\\n+  %{!ansi: \\\n+   %{!Xpg4: \\\n+    %{!Xpg4plus: \\\n+     %{!Xods30: \\\n+      %{posix:-D_POSIX_C_SOURCE=2 -D_POSIX_SOURCE}}}}} \\\n+  %{!ansi: \\\n+   %{!posix: \\\n+    %{!Xods30: \\\n+     %{!Xpg4plus: \\\n+      %{Xpg4:-D_XOPEN_SOURCE}}}}} \\\n+  %{!ansi: \\\n+   %{!posix: \\\n+    %{!Xpg4: \\\n+     %{!Xpg4plus: \\\n+      %{Xods30:-D_SCO_ODS_30 -DM_I86 -DM_I86SM -DM_SDATA -DM_STEXT \\\n+               -DM_BITFIELDS -DM_SYS5 -DM_SYSV -DM_SYS3 -DM_SYSIII \\\n+               -DM_WORDSWAP}}}}} \\\n+  %{!ansi: \\\n+   %{!posix: \\\n+    %{!Xpg4:-D_M_I86 -D_M_I86SM -D_M_I86SM -D_M_SDATA -D_M_STEXT \\\n+            -D_M_BITFIELDS -D_M_SYS5 -D_M_SYSV -D_M_SYS3 -D_M_SYSIII \\\n+            -D_M_WORDSWAP -Di386 -Dunix -DM_I386 -DM_UNIX -DM_XENIX}}} \\\n+  %{scointl:-DM_INTERNAT -D_M_INTERNAT} \\\n+  %{traditional:-D_KR -D_SVID -D_NO_PROTOTYPE} \\\n+  %{melf:-D_SCO_ELF -DM_ELF -D_M_ELF} \\\n+  %{!melf:-D_M_COFF -DM_COFF -D_SCO_COFF} \\\n+  %{melf:%{fpic:-D__PIC__ -D__pic__} \\\n+         %{fPIC:%{!fpic:-D__PIC__ -D__pic__}}} \\\n+  %{Xa:-D_SCO_C_DIALECT=1} \\\n+   %{!Xa:%{Xc:-D_SCO_C_DIALECT=3} \\\n+    %{!Xc:%{Xk:-D_SCO_C_DIALECT=4} \\\n+     %{!Xk:%{Xt:-D_SCO_C_DIALECT=2  \\\n+             %{!traditional:-traditional -D_KR -D_NO_PROTOTYPE}}}}} \\\n+  %{traditional:-traditional -D_KR -D_NO_PROTOTYPE}\"\n+\n+#undef LINK_SPEC\n+#define LINK_SPEC \\\n+ \"-b %{melf:elf}%{!melf:coff \\\n+   %{static:%e-static only valid with -melf} \\\n+   %{shared:%e-shared only valid with -melf} \\\n+   %{symbolic:%e-symbolic only valid with -melf} \\\n+   %{fpic:%e-fpic only valid with -melf} \\\n+   %{fPIC:%e-fPIC only valid with -melf}} \\\n+  -R%{Xa:a}%{!Xa:%{Xc:c}%{!Xc:%{Xk:k}%{!Xk:%{Xt:t}%{!Xt:a}}}},%{ansi:ansi}%{!ansi:%{posix:posix}%{!posix:%{Xpg4:xpg4}%{!Xpg4:%{Xpg4plus:XPG4PLUS}%{!Xpg4plus:%{Xods30:ods30}%{!Xods30:XPG4PLUS}}}}},%{melf:ELF}%{!melf:COFF} \\\n+  %{Wl,*%*} %{YP,*} %{YL,*} %{YU,*} \\\n+  %{!YP,*:%{p:-YP,/usr/ccs/libp:/usr/libp:/usr/ccs/lib:/usr/lib} \\\n+   %{!p:-YP,/usr/ccs/lib:/usr/lib}} \\\n+  %{h*} %{static:-dn -Bstatic} %{shared:-G -dy %{!z*:-z text}} \\\n+  %{symbolic:-Bsymbolic -G -dy %{!z*:-z text}} \\\n+  %{G:-G} %{melf:%{Qn:} %{!Qy:-Qn}}\"\n+\n+/* Library spec. If we are not building a shared library, provide the\n+   standard libraries, as per the SCO compiler.  */\n+\n+#undef LIB_SPEC\n+#define LIB_SPEC \\\n+ \"%{!shared:%{!symbolic:-lcrypt -lgen -lc}}\"\n+\n+#undef LIBGCC_SPEC\n+#define LIBGCC_SPEC \\\n+ \"%{!melf:-lgcc}%{melf:%{!shared:%{!symbolic:-lgcc-elf}}}\"\n+\n+#define MASK_ELF     \t\t010000000000\t/* Mask for elf generation */\n+#define TARGET_ELF              (target_flags & MASK_ELF)\n+\n+#undef SUBTARGET_SWITCHES\n+#define SUBTARGET_SWITCHES { \"elf\", MASK_ELF },\n+\n+#define NO_DOLLAR_IN_LABEL\n+\n+/*\n+Here comes some major hackery to get the crt stuff to compile properly.\n+Since we can (and do) compile for both COFF and ELF environments, we\n+set things up accordingly, based on the pre-processor defines for ELF\n+and COFF. This is insane, but then I guess having one compiler with a\n+single back-end supporting two vastly different file format types is\n+a little insane too. But it is not impossible and we get a useful\n+compiler at the end of the day. Onward we go ...\n+*/\n+\n+#if defined(CRT_BEGIN) || defined(CRT_END) || defined(IN_LIBGCC2)\n+# if defined (_SCO_ELF)\n+#  undef OBJECT_FORMAT_ELF\n+#  define OBJECT_FORMAT_ELF\n+#  undef INIT_SECTION_ASM_OP\n+#  undef FINI_SECTION_ASM_OP\n+#  undef DTORS_SECTION_ASM_OP\n+#  undef CTORS_SECTION_ASM_OP\n+#  undef CTOR_LIST_BEGIN\n+#  undef CTOR_LIST_END\n+#  undef DO_GLOBAL_CTORS_BODY\n+#  define INIT_SECTION_ASM_OP INIT_SECTION_ASM_OP_ELF\n+#  define FINI_SECTION_ASM_OP FINI_SECTION_ASM_OP_ELF\n+#  define DTORS_SECTION_ASM_OP DTORS_SECTION_ASM_OP_ELF\n+#  define CTORS_SECTION_ASM_OP CTORS_SECTION_ASM_OP_ELF\n+#  define CTOR_LIST_BEGIN asm (CTORS_SECTION_ASM_OP_ELF); \\\n+    STATIC func_ptr __CTOR_LIST__[1] = { (func_ptr) (-1) };\n+#  define DO_GLOBAL_CTORS_BODY\t\t\t\t\t\t\\\n+do {\t\t\t\t\t\t\t\t\t\\\n+    unsigned long nptrs = (unsigned long) __CTOR_LIST__[0];\t\t\\\n+    unsigned i;\t\t\t\t\t\t\t\t\\\n+    if (nptrs == -1)\t\t\t\t\t\t\t\\\n+      for (nptrs=0; __CTOR_LIST__[nptrs+1] != 0; nptrs++);\t\t\\\n+    for (i = nptrs; i >= 1; i--)\t\t\t\t\t\\\n+      __CTOR_LIST__[i] ();\t\t\t\t\t\t\\\n+} while (0)\n+# else /* ! _SCO_ELF */\n+#  undef OBJECT_FORMAT_ELF\n+#  undef INIT_SECTION_ASM_OP\n+#  undef FINI_SECTION_ASM_OP\n+#  undef DTORS_SECTION_ASM_OP\n+#  undef CTORS_SECTION_ASM_OP\n+#  define INIT_SECTION_ASM_OP INIT_SECTION_ASM_OP_COFF\n+#  define FINI_SECTION_ASM_OP FINI_SECTION_ASM_OP_COFF\n+#  define DTORS_SECTION_ASM_OP DTORS_SECTION_ASM_OP_COFF\n+#  define CTORS_SECTION_ASM_OP CTORS_SECTION_ASM_OP_COFF\n+#  undef CTOR_LIST_BEGIN\n+#  undef CTOR_LIST_END\n+#  undef DO_GLOBAL_CTORS_BODY\n+#  define CTOR_LIST_BEGIN asm (INIT_SECTION_ASM_OP); asm (\"pushl $0\")\n+#  define CTOR_LIST_END CTOR_LIST_BEGIN\n+#  define DO_GLOBAL_CTORS_BODY\t\t\t\t\t\t\\\n+do {\t\t\t\t\t\t\t\t\t\\\n+     func_ptr *p, *beg = alloca(0);\t\t\t\t\t\\\n+     for (p = beg; *p;)\t\t\t\t\t\t\t\\\n+      (*p++) ();\t\t\t\t\t\t\t\\\n+} while (0)\n+# endif /* ! _SCO_ELF */\n+#endif /* CRT_BEGIN !! CRT_END */\n+"}, {"sha": "e72a5c4c476fc6062f1dceec8ea63777736f7a9a", "filename": "gcc/config/i386/t-sco5", "status": "added", "additions": 91, "deletions": 0, "changes": 91, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fdec1d300576bd2412279bb2832cf6c4df0afb94/gcc%2Fconfig%2Fi386%2Ft-sco5", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fdec1d300576bd2412279bb2832cf6c4df0afb94/gcc%2Fconfig%2Fi386%2Ft-sco5", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Ft-sco5?ref=fdec1d300576bd2412279bb2832cf6c4df0afb94", "patch": "@@ -0,0 +1,91 @@\n+# The pushl in CTOR initialization interferes with frame pointer elimination.\n+CRTSTUFF_T_CFLAGS =-fno-omit-frame-pointer\n+CRTSTUFF_T_CFLAGS_S = $(CRTSTUFF_T_CFLAGS) -melf -fPIC \n+\n+#\n+# Becuase we can be compiling for either elf or coff, we need to create\n+# special versions of libgcc.a. It IS possible for this not to be done\n+# and let the SCO linker transform the coff objects (which are created\n+# by default) into elf objects. However, this is inefficient. So,\n+# we create a libgcc-elf.a, which is used in the specs in sco5.h.\n+# These are the rules for doing that.\n+#\n+# NOTE: This is duplicated directly from Makefile.in. If you change it\n+# there, be sure to change things here!\n+#\n+EXTRA_PARTS = libgcc-elf.a crtbegin.o crtend.o crtbeginS.o crtendS.o\n+TAROUTOPTS = xpf\n+\n+libgcc1-elf.a: stamp-crtS stamp-crt libgcc1.c $(CONFIG_H) $(LIB1FUNCS_EXTRA) config.status\n+\t-rm -f tmplibgcc1-elf.a\n+\tfor name in $(LIB1FUNCS); \\\n+\tdo \\\n+\t  echo $${name}; \\\n+\t  rm -f $${name}$(objext); \\\n+\t  $(OLDCC) -DIN_LIBGCC1 -dy $(CCLIBFLAGS) $(INCLUDES) -c -DL$${name} $(srcdir)/libgcc1.c; \\\n+\t  if [ $$? -eq 0 ] ; then true; else exit 1; fi; \\\n+\t  mv libgcc1$(objext) $${name}$(objext); \\\n+\t  $(OLDAR) $(OLDAR_FLAGS) tmplibgcc1-elf.a $${name}$(objext); \\\n+\t  rm -f $${name}$(objext); \\\n+\tdone\n+\tfor file in .. $(LIB1FUNCS_EXTRA); \\\n+\tdo \\\n+\t  if [ x$${file} != x.. ]; then \\\n+\t    name=`echo $${file} | sed -e 's/[.][cS]$$//' -e 's/[.]asm$$//'`; \\\n+\t    echo $${name}; \\\n+\t    if [ $${name}.asm = $${file} ]; then \\\n+\t      cp $${file} $${name}.s || exit 1; file=$${name}.s; \\\n+\t    else true; fi; \\\n+\t    $(OLDCC) -DIN_LIBGCC1 -dy $(CCLIBFLAGS) $(INCLUDES) -c $${file}; \\\n+\t    if [ $$? -eq 0 ] ; then true; else exit 1; fi; \\\n+\t    $(OLDAR) $(OLDAR_FLAGS) tmplibgcc1-elf.a $${name}$(objext); \\\n+\t    if [ $$? -eq 0 ] ; then true; else exit 1; fi; \\\n+\t    rm -f $${name}.s $${name}$(objext); \\\n+\t  else true; \\\n+\t  fi; \\\n+\tdone\n+\t-if $(RANLIB_TEST) ; then $(RANLIB) tmplibgcc1-elf.a; else true; fi\n+\tmv tmplibgcc1-elf.a libgcc1-elf.a\n+\n+libgcc2-elf.a: stamp-crtS stamp-crt libgcc2.c libgcc2.ready $(CONFIG_H) $(LIB2FUNCS_EXTRA) \\\n+   machmode.h longlong.h gbl-ctors.h config.status\n+\t-rm -f tmplibgcc2-elf.a\n+\tfor name in $(LIB2FUNCS); \\\n+\tdo \\\n+\t  echo $${name}; \\\n+\t  $(GCC_FOR_TARGET) -melf $(LIBGCC2_CFLAGS) $(INCLUDES) -c -DL$${name} \\\n+\t      $(srcdir)/libgcc2.c -o $${name}$(objext); \\\n+\t  if [ $$? -eq 0 ] ; then true; else exit 1; fi; \\\n+\t  $(AR) $(AR_FLAGS) tmplibgcc2-elf.a $${name}$(objext); \\\n+\t  rm -f $${name}$(objext); \\\n+\tdone\n+\tfor file in .. $(LIB2FUNCS_EXTRA); \\\n+\tdo \\\n+\t  if [ x$${file} != x.. ]; then \\\n+\t    name=`echo $${file} | sed -e 's/[.][cS]$$//' -e 's/[.]asm$$//'`; \\\n+\t    oname=` echo $${name} | sed -e 's,.*/,,'`; \\\n+\t    echo $${name}; \\\n+\t    if [ $${name}.asm = $${file} ]; then \\\n+\t      cp $${file} $${name}.s || exit 1; file=$${name}.s; \\\n+\t    else true; fi; \\\n+\t    $(GCC_FOR_TARGET) -melf $(LIBGCC2_CFLAGS) $(INCLUDES) -c $${file}; \\\n+\t    if [ $$? -eq 0 ] ; then true; else exit 1; fi; \\\n+\t    $(AR) $(AR_FLAGS) tmplibgcc2-elf.a $${oname}$(objext); \\\n+\t    rm -f $${name}.s $${oname}$(objext); \\\n+\t  else true; \\\n+\t  fi; \\\n+\tdone\n+\tmv tmplibgcc2-elf.a libgcc2-elf.a\n+\n+# Combine the various libraries into a single library, libgcc.a.\n+libgcc-elf.a: libgcc1-elf.a libgcc2-elf.a\n+\t-rm -rf tmplibgcc-elf.a libgcc-elf.a tmpcopy\n+\tmkdir tmpcopy\n+\t-(cd tmpcopy; $(AR) x ../libgcc1-elf.a)\n+\t-(cd tmpcopy; chmod +w * > /dev/null 2>&1)\n+\t-(cd tmpcopy; $(AR) x ../libgcc2-elf.a)\n+\t(cd tmpcopy; $(AR) $(AR_FLAGS) ../tmplibgcc-elf.a *$(objext))\n+\trm -rf tmpcopy\n+\t-if $(RANLIB_TEST) ; then $(RANLIB) tmplibgcc-elf.a; else true; fi\n+\tmv tmplibgcc-elf.a libgcc-elf.a\n+"}, {"sha": "ada44eda382c45309ae8a2046f1db0aa97fc1085", "filename": "gcc/config/i386/x-sco5", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fdec1d300576bd2412279bb2832cf6c4df0afb94/gcc%2Fconfig%2Fi386%2Fx-sco5", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fdec1d300576bd2412279bb2832cf6c4df0afb94/gcc%2Fconfig%2Fi386%2Fx-sco5", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fx-sco5?ref=fdec1d300576bd2412279bb2832cf6c4df0afb94", "patch": "@@ -0,0 +1,9 @@\n+RANLIB = :\n+RANLIB_TEST = false\n+CC = cc \n+OLDCC = cc\n+CCLIBFLAGS =\n+CLIB = -lPW\n+\n+# See all the declarations.\n+FIXPROTO_DEFINES = -D_XOPEN_SOURCE -D_POSIX_C_SOURCE=2"}, {"sha": "27adf86490e9815a57fee8c01c71704b80e5f651", "filename": "gcc/config/i386/xm-sco5.h", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fdec1d300576bd2412279bb2832cf6c4df0afb94/gcc%2Fconfig%2Fi386%2Fxm-sco5.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fdec1d300576bd2412279bb2832cf6c4df0afb94/gcc%2Fconfig%2Fi386%2Fxm-sco5.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fxm-sco5.h?ref=fdec1d300576bd2412279bb2832cf6c4df0afb94", "patch": "@@ -0,0 +1,8 @@\n+/* Configuration for GCC for Intel i386 running SCO.  */\n+\n+#include \"i386/xm-sysv3.h\"\n+\n+/* Big buffers improve performance.  */\n+\n+#define IO_BUFFER_SIZE (0x8000 - 1024)\n+"}]}