{"sha": "5576518a5667ad826937125a19b7c59c34d8733c", "node_id": "C_kwDOANBUbNoAKDU1NzY1MThhNTY2N2FkODI2OTM3MTI1YTE5YjdjNTljMzRkODczM2M", "commit": {"author": {"name": "Ju-Zhe Zhong", "email": "juzhe.zhong@rivai.ai", "date": "2022-11-06T08:56:33Z"}, "committer": {"name": "Kito Cheng", "email": "kito.cheng@sifive.com", "date": "2022-11-11T08:16:13Z"}, "message": "RISC-V: Add RVV registers register spilling\n\nThis patch support RVV scalable register spilling.\nprologue && epilogue handling pick up prototype from Monk Chiang <monk.chiang@sifive.com>.\nCo-authored-by: Monk Chiang <monk.chiang@sifive.com>\n\ngcc/ChangeLog:\n\n\t* config/riscv/riscv-v.cc (emit_pred_move): Adjust for scalable register spilling.\n\t(legitimize_move): Ditto.\n\t* config/riscv/riscv.cc (riscv_v_adjust_scalable_frame): New function.\n\t(riscv_first_stack_step): Adjust for scalable register spilling.\n\t(riscv_expand_prologue): Ditto.\n\t(riscv_expand_epilogue): Ditto.\n\t(riscv_dwarf_poly_indeterminate_value): New function.\n\t(TARGET_DWARF_POLY_INDETERMINATE_VALUE): New target hook support for register spilling.\n\t* config/riscv/riscv.h (RISCV_DWARF_VLENB): New macro.\n\t(RISCV_PROLOGUE_TEMP2_REGNUM): Ditto.\n\t(RISCV_PROLOGUE_TEMP2): Ditto.\n\t* config/riscv/vector-iterators.md: New iterators.\n\t* config/riscv/vector.md (*mov<mode>): Fix it for register spilling.\n\t(*mov<mode>_whole): New pattern.\n\t(*mov<mode>_fract): New pattern.\n\t(@pred_mov<mode>): Fix it for register spilling.\n\ngcc/testsuite/ChangeLog:\n\n\t* gcc.target/riscv/rvv/base/macro.h: New test.\n\t* gcc.target/riscv/rvv/base/spill-1.c: New test.\n\t* gcc.target/riscv/rvv/base/spill-10.c: New test.\n\t* gcc.target/riscv/rvv/base/spill-11.c: New test.\n\t* gcc.target/riscv/rvv/base/spill-12.c: New test.\n\t* gcc.target/riscv/rvv/base/spill-2.c: New test.\n\t* gcc.target/riscv/rvv/base/spill-3.c: New test.\n\t* gcc.target/riscv/rvv/base/spill-4.c: New test.\n\t* gcc.target/riscv/rvv/base/spill-5.c: New test.\n\t* gcc.target/riscv/rvv/base/spill-6.c: New test.\n\t* gcc.target/riscv/rvv/base/spill-7.c: New test.\n\t* gcc.target/riscv/rvv/base/spill-8.c: New test.\n\t* gcc.target/riscv/rvv/base/spill-9.c: New test.", "tree": {"sha": "1ed21ca1b776c24f97651aad2145733b05e2b70a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1ed21ca1b776c24f97651aad2145733b05e2b70a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5576518a5667ad826937125a19b7c59c34d8733c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5576518a5667ad826937125a19b7c59c34d8733c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5576518a5667ad826937125a19b7c59c34d8733c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5576518a5667ad826937125a19b7c59c34d8733c/comments", "author": {"login": "zhongjuzhe", "id": 66454988, "node_id": "MDQ6VXNlcjY2NDU0OTg4", "avatar_url": "https://avatars.githubusercontent.com/u/66454988?v=4", "gravatar_id": "", "url": "https://api.github.com/users/zhongjuzhe", "html_url": "https://github.com/zhongjuzhe", "followers_url": "https://api.github.com/users/zhongjuzhe/followers", "following_url": "https://api.github.com/users/zhongjuzhe/following{/other_user}", "gists_url": "https://api.github.com/users/zhongjuzhe/gists{/gist_id}", "starred_url": "https://api.github.com/users/zhongjuzhe/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/zhongjuzhe/subscriptions", "organizations_url": "https://api.github.com/users/zhongjuzhe/orgs", "repos_url": "https://api.github.com/users/zhongjuzhe/repos", "events_url": "https://api.github.com/users/zhongjuzhe/events{/privacy}", "received_events_url": "https://api.github.com/users/zhongjuzhe/received_events", "type": "User", "site_admin": false}, "committer": {"login": "kito-cheng", "id": 2723185, "node_id": "MDQ6VXNlcjI3MjMxODU=", "avatar_url": "https://avatars.githubusercontent.com/u/2723185?v=4", "gravatar_id": "", "url": "https://api.github.com/users/kito-cheng", "html_url": "https://github.com/kito-cheng", "followers_url": "https://api.github.com/users/kito-cheng/followers", "following_url": "https://api.github.com/users/kito-cheng/following{/other_user}", "gists_url": "https://api.github.com/users/kito-cheng/gists{/gist_id}", "starred_url": "https://api.github.com/users/kito-cheng/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/kito-cheng/subscriptions", "organizations_url": "https://api.github.com/users/kito-cheng/orgs", "repos_url": "https://api.github.com/users/kito-cheng/repos", "events_url": "https://api.github.com/users/kito-cheng/events{/privacy}", "received_events_url": "https://api.github.com/users/kito-cheng/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "fbad7a74aaaddea3d7b39045a09dd3860603658e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fbad7a74aaaddea3d7b39045a09dd3860603658e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fbad7a74aaaddea3d7b39045a09dd3860603658e"}], "stats": {"total": 2103, "additions": 2017, "deletions": 86}, "files": [{"sha": "e0459e3f610439c71b1ad6cb4b3ea2034a7b099b", "filename": "gcc/config/riscv/riscv-v.cc", "status": "modified", "additions": 16, "deletions": 31, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5576518a5667ad826937125a19b7c59c34d8733c/gcc%2Fconfig%2Friscv%2Friscv-v.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5576518a5667ad826937125a19b7c59c34d8733c/gcc%2Fconfig%2Friscv%2Friscv-v.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Friscv%2Friscv-v.cc?ref=5576518a5667ad826937125a19b7c59c34d8733c", "patch": "@@ -106,28 +106,25 @@ const_vec_all_same_in_range_p (rtx x, HOST_WIDE_INT minval,\n \n /* Emit an RVV unmask && vl mov from SRC to DEST.  */\n static void\n-emit_pred_move (rtx dest, rtx src, rtx vl, machine_mode mask_mode)\n+emit_pred_move (rtx dest, rtx src, machine_mode mask_mode)\n {\n   insn_expander<7> e;\n-\n   machine_mode mode = GET_MODE (dest);\n-  if (register_operand (src, mode) && register_operand (dest, mode))\n-    {\n-      emit_move_insn (dest, src);\n-      return;\n-    }\n+  rtx vl = gen_reg_rtx (Pmode);\n+  unsigned int sew = GET_MODE_CLASS (mode) == MODE_VECTOR_BOOL\n+\t\t       ? 8\n+\t\t       : GET_MODE_BITSIZE (GET_MODE_INNER (mode));\n+\n+  emit_insn (gen_vsetvl_no_side_effects (\n+    Pmode, vl, gen_rtx_REG (Pmode, 0), gen_int_mode (sew, Pmode),\n+    gen_int_mode ((unsigned int) mode, Pmode), const1_rtx, const1_rtx));\n \n   e.add_output_operand (dest, mode);\n   e.add_all_one_mask_operand (mask_mode);\n-  /* For load operation, we create undef operand.\n-     For store operation, we make it depend on the dest memory to\n-     avoid potential bugs.  */\n-  if (MEM_P (src))\n-    e.add_vundef_operand (mode);\n-  else\n-    e.add_input_operand (dest, mode);\n+  e.add_vundef_operand (mode);\n \n   e.add_input_operand (src, mode);\n+\n   e.add_input_operand (vl, Pmode);\n \n   e.add_policy_operand (TAIL_AGNOSTIC, MASK_AGNOSTIC);\n@@ -143,37 +140,25 @@ bool\n legitimize_move (rtx dest, rtx src, machine_mode mask_mode)\n {\n   machine_mode mode = GET_MODE (dest);\n-  /* For whole registers load/store or register-register move,\n-     we don't need to specially handle them, just let them go\n-     through \"*mov<mode>\" and then use the codegen directly.  */\n-  if ((known_ge (GET_MODE_SIZE (mode), BYTES_PER_RISCV_VECTOR)\n-       && (GET_MODE_CLASS (mode) != MODE_VECTOR_BOOL))\n-      || (register_operand (src, mode) && register_operand (dest, mode)))\n+  if (known_ge (GET_MODE_SIZE (mode), BYTES_PER_RISCV_VECTOR)\n+      && GET_MODE_CLASS (mode) != MODE_VECTOR_BOOL)\n     {\n       /* Need to force register if mem <- !reg.  */\n       if (MEM_P (dest) && !REG_P (src))\n \tsrc = force_reg (mode, src);\n+\n       return false;\n     }\n-\n-  rtx vlmax = gen_reg_rtx (Pmode);\n-  unsigned int sew = GET_MODE_CLASS (mode) == MODE_VECTOR_BOOL\n-\t\t       ? 8\n-\t\t       : GET_MODE_BITSIZE (GET_MODE_INNER (mode));\n-  emit_insn (gen_vsetvl_no_side_effects (\n-    Pmode, vlmax, gen_rtx_REG (Pmode, 0), gen_int_mode (sew, Pmode),\n-    gen_int_mode ((unsigned int) mode, Pmode), const1_rtx, const1_rtx));\n-\n   if (!register_operand (src, mode) && !register_operand (dest, mode))\n     {\n       rtx tmp = gen_reg_rtx (mode);\n       if (MEM_P (src))\n-\temit_pred_move (tmp, src, vlmax, mask_mode);\n+\temit_pred_move (tmp, src, mask_mode);\n       else\n \temit_move_insn (tmp, src);\n       src = tmp;\n     }\n-  emit_pred_move (dest, src, vlmax, mask_mode);\n+  emit_pred_move (dest, src, mask_mode);\n   return true;\n }\n "}, {"sha": "02a01ca0b7c1b5ca0b4a335d4dd61463015994a1", "filename": "gcc/config/riscv/riscv.cc", "status": "modified", "additions": 125, "deletions": 22, "changes": 147, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5576518a5667ad826937125a19b7c59c34d8733c/gcc%2Fconfig%2Friscv%2Friscv.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5576518a5667ad826937125a19b7c59c34d8733c/gcc%2Fconfig%2Friscv%2Friscv.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Friscv%2Friscv.cc?ref=5576518a5667ad826937125a19b7c59c34d8733c", "patch": "@@ -1940,6 +1940,37 @@ riscv_legitimize_poly_move (machine_mode mode, rtx dest, rtx tmp, rtx src)\n     }\n }\n \n+/* Adjust scalable frame of vector for prologue && epilogue. */\n+\n+static void\n+riscv_v_adjust_scalable_frame (rtx target, poly_int64 offset, bool epilogue)\n+{\n+  rtx tmp = RISCV_PROLOGUE_TEMP (Pmode);\n+  rtx adjust_size = RISCV_PROLOGUE_TEMP2 (Pmode);\n+  rtx insn, dwarf, adjust_frame_rtx;\n+\n+  riscv_legitimize_poly_move (Pmode, adjust_size, tmp,\n+\t\t\t      gen_int_mode (offset, Pmode));\n+\n+  if (epilogue)\n+    insn = gen_add3_insn (target, target, adjust_size);\n+  else\n+    insn = gen_sub3_insn (target, target, adjust_size);\n+\n+  insn = emit_insn (insn);\n+\n+  RTX_FRAME_RELATED_P (insn) = 1;\n+\n+  adjust_frame_rtx\n+    = gen_rtx_SET (target,\n+\t\t   plus_constant (Pmode, target, epilogue ? offset : -offset));\n+\n+  dwarf = alloc_reg_note (REG_FRAME_RELATED_EXPR, copy_rtx (adjust_frame_rtx),\n+\t\t\t  NULL_RTX);\n+\n+  REG_NOTES (insn) = dwarf;\n+}\n+\n /* If (set DEST SRC) is not a valid move instruction, emit an equivalent\n    sequence that is valid.  */\n \n@@ -4832,21 +4863,29 @@ riscv_restore_reg (rtx reg, rtx mem)\n static HOST_WIDE_INT\n riscv_first_stack_step (struct riscv_frame_info *frame)\n {\n-  if (SMALL_OPERAND (frame->total_size.to_constant()))\n-    return frame->total_size.to_constant();\n+  HOST_WIDE_INT frame_total_constant_size;\n+  if (!frame->total_size.is_constant ())\n+    frame_total_constant_size\n+      = riscv_stack_align (frame->total_size.coeffs[0])\n+\t- riscv_stack_align (frame->total_size.coeffs[1]);\n+  else\n+    frame_total_constant_size = frame->total_size.to_constant ();\n+\n+  if (SMALL_OPERAND (frame_total_constant_size))\n+    return frame_total_constant_size;\n \n   HOST_WIDE_INT min_first_step =\n     RISCV_STACK_ALIGN ((frame->total_size - frame->fp_sp_offset).to_constant());\n   HOST_WIDE_INT max_first_step = IMM_REACH / 2 - PREFERRED_STACK_BOUNDARY / 8;\n-  HOST_WIDE_INT min_second_step = frame->total_size.to_constant() - max_first_step;\n+  HOST_WIDE_INT min_second_step = frame_total_constant_size - max_first_step;\n   gcc_assert (min_first_step <= max_first_step);\n \n   /* As an optimization, use the least-significant bits of the total frame\n      size, so that the second adjustment step is just LUI + ADD.  */\n   if (!SMALL_OPERAND (min_second_step)\n-      && frame->total_size.to_constant() % IMM_REACH < IMM_REACH / 2\n-      && frame->total_size.to_constant() % IMM_REACH >= min_first_step)\n-    return frame->total_size.to_constant() % IMM_REACH;\n+      && frame_total_constant_size % IMM_REACH < IMM_REACH / 2\n+      && frame_total_constant_size % IMM_REACH >= min_first_step)\n+    return frame_total_constant_size % IMM_REACH;\n \n   if (TARGET_RVC)\n     {\n@@ -4919,12 +4958,12 @@ void\n riscv_expand_prologue (void)\n {\n   struct riscv_frame_info *frame = &cfun->machine->frame;\n-  HOST_WIDE_INT size = frame->total_size.to_constant ();\n+  poly_int64 size = frame->total_size;\n   unsigned mask = frame->mask;\n   rtx insn;\n \n   if (flag_stack_usage_info)\n-    current_function_static_stack_size = size;\n+    current_function_static_stack_size = constant_lower_bound (size);\n \n   if (cfun->machine->naked_p)\n     return;\n@@ -4946,7 +4985,9 @@ riscv_expand_prologue (void)\n   /* Save the registers.  */\n   if ((frame->mask | frame->fmask) != 0)\n     {\n-      HOST_WIDE_INT step1 = MIN (size, riscv_first_stack_step (frame));\n+      HOST_WIDE_INT step1 = riscv_first_stack_step (frame);\n+      if (size.is_constant ())\n+\tstep1 = MIN (size.to_constant(), step1);\n \n       insn = gen_add3_insn (stack_pointer_rtx,\n \t\t\t    stack_pointer_rtx,\n@@ -4969,23 +5010,40 @@ riscv_expand_prologue (void)\n     }\n \n   /* Allocate the rest of the frame.  */\n-  if (size > 0)\n+  if (known_gt (size, 0))\n     {\n-      if (SMALL_OPERAND (-size))\n+      /* Two step adjustment:\n+\t 1.scalable frame. 2.constant frame.  */\n+      poly_int64 scalable_frame (0, 0);\n+      if (!size.is_constant ())\n+\t{\n+\t  /* First for scalable frame.  */\n+\t  poly_int64 scalable_frame = size;\n+\t  scalable_frame.coeffs[0] = size.coeffs[1];\n+\t  riscv_v_adjust_scalable_frame (stack_pointer_rtx, scalable_frame, false);\n+\t  size -= scalable_frame;\n+\t}\n+\n+      /* Second step for constant frame.  */\n+      HOST_WIDE_INT constant_frame = size.to_constant ();\n+      if (constant_frame == 0)\n+\treturn;\n+\n+      if (SMALL_OPERAND (-constant_frame))\n \t{\n \t  insn = gen_add3_insn (stack_pointer_rtx, stack_pointer_rtx,\n-\t\t\t\tGEN_INT (-size));\n+\t\t\t\tGEN_INT (-constant_frame));\n \t  RTX_FRAME_RELATED_P (emit_insn (insn)) = 1;\n \t}\n       else\n \t{\n-\t  riscv_emit_move (RISCV_PROLOGUE_TEMP (Pmode), GEN_INT (-size));\n+\t  riscv_emit_move (RISCV_PROLOGUE_TEMP (Pmode), GEN_INT (-constant_frame));\n \t  emit_insn (gen_add3_insn (stack_pointer_rtx,\n \t\t\t\t    stack_pointer_rtx,\n \t\t\t\t    RISCV_PROLOGUE_TEMP (Pmode)));\n \n \t  /* Describe the effect of the previous instructions.  */\n-\t  insn = plus_constant (Pmode, stack_pointer_rtx, -size);\n+\t  insn = plus_constant (Pmode, stack_pointer_rtx, -constant_frame);\n \t  insn = gen_rtx_SET (stack_pointer_rtx, insn);\n \t  riscv_set_frame_expr (insn);\n \t}\n@@ -5028,7 +5086,7 @@ riscv_expand_epilogue (int style)\n      Start off by assuming that no registers need to be restored.  */\n   struct riscv_frame_info *frame = &cfun->machine->frame;\n   unsigned mask = frame->mask;\n-  HOST_WIDE_INT step1 = frame->total_size.to_constant ();\n+  poly_int64 step1 = frame->total_size;\n   HOST_WIDE_INT step2 = 0;\n   bool use_restore_libcall = ((style == NORMAL_RETURN)\n \t\t\t      && riscv_use_save_libcall (frame));\n@@ -5064,11 +5122,27 @@ riscv_expand_epilogue (int style)\n       riscv_emit_stack_tie ();\n       need_barrier_p = false;\n \n-      rtx adjust = GEN_INT (-frame->hard_frame_pointer_offset.to_constant ());\n-      if (!SMALL_OPERAND (INTVAL (adjust)))\n+      poly_int64 adjust_offset = -frame->hard_frame_pointer_offset;\n+      rtx adjust = NULL_RTX;\n+\n+      if (!adjust_offset.is_constant ())\n \t{\n-\t  riscv_emit_move (RISCV_PROLOGUE_TEMP (Pmode), adjust);\n-\t  adjust = RISCV_PROLOGUE_TEMP (Pmode);\n+\t  rtx tmp1 = RISCV_PROLOGUE_TEMP (Pmode);\n+\t  rtx tmp2 = RISCV_PROLOGUE_TEMP2 (Pmode);\n+\t  riscv_legitimize_poly_move (Pmode, tmp1, tmp2,\n+\t\t\t\t      gen_int_mode (adjust_offset, Pmode));\n+\t  adjust = tmp1;\n+\t}\n+      else\n+\t{\n+\t  if (!SMALL_OPERAND (adjust_offset.to_constant ()))\n+\t    {\n+\t      riscv_emit_move (RISCV_PROLOGUE_TEMP (Pmode),\n+\t\t\t       GEN_INT (adjust_offset.to_constant ()));\n+\t      adjust = RISCV_PROLOGUE_TEMP (Pmode);\n+\t    }\n+\t  else\n+\t    adjust = GEN_INT (adjust_offset.to_constant ());\n \t}\n \n       insn = emit_insn (\n@@ -5078,7 +5152,7 @@ riscv_expand_epilogue (int style)\n       rtx dwarf = NULL_RTX;\n       rtx cfa_adjust_value = gen_rtx_PLUS (\n \t\t\t       Pmode, hard_frame_pointer_rtx,\n-\t\t\t       GEN_INT (-frame->hard_frame_pointer_offset.to_constant ()));\n+\t\t\t       gen_int_mode (-frame->hard_frame_pointer_offset, Pmode));\n       rtx cfa_adjust_rtx = gen_rtx_SET (stack_pointer_rtx, cfa_adjust_value);\n       dwarf = alloc_reg_note (REG_CFA_ADJUST_CFA, cfa_adjust_rtx, dwarf);\n       RTX_FRAME_RELATED_P (insn) = 1;\n@@ -5101,9 +5175,19 @@ riscv_expand_epilogue (int style)\n       riscv_emit_stack_tie ();\n       need_barrier_p = false;\n \n+      /* Restore the scalable frame which is assigned in prologue.  */\n+      if (!step1.is_constant ())\n+\t{\n+\t  poly_int64 scalable_frame = step1;\n+\t  scalable_frame.coeffs[0] = step1.coeffs[1];\n+\t  riscv_v_adjust_scalable_frame (stack_pointer_rtx, scalable_frame,\n+\t\t\t\t\t true);\n+\t  step1 -= scalable_frame;\n+\t}\n+\n       /* Get an rtx for STEP1 that we can add to BASE.  */\n-      rtx adjust = GEN_INT (step1);\n-      if (!SMALL_OPERAND (step1))\n+      rtx adjust = GEN_INT (step1.to_constant ());\n+      if (!SMALL_OPERAND (step1.to_constant ()))\n \t{\n \t  riscv_emit_move (RISCV_PROLOGUE_TEMP (Pmode), adjust);\n \t  adjust = RISCV_PROLOGUE_TEMP (Pmode);\n@@ -6484,6 +6568,22 @@ riscv_regmode_natural_size (machine_mode mode)\n   return UNITS_PER_WORD;\n }\n \n+/* Implement the TARGET_DWARF_POLY_INDETERMINATE_VALUE hook.  */\n+\n+static unsigned int\n+riscv_dwarf_poly_indeterminate_value (unsigned int i, unsigned int *factor,\n+\t\t\t\t      int *offset)\n+{\n+  /* Polynomial invariant 1 == (VLENB / riscv_bytes_per_vector_chunk) - 1.\n+     1. TARGET_MIN_VLEN == 32, olynomial invariant 1 == (VLENB / 4) - 1.\n+     2. TARGET_MIN_VLEN > 32, olynomial invariant 1 == (VLENB / 8) - 1.\n+  */\n+  gcc_assert (i == 1);\n+  *factor = riscv_bytes_per_vector_chunk;\n+  *offset = 1;\n+  return RISCV_DWARF_VLENB;\n+}\n+\n /* Initialize the GCC target structure.  */\n #undef TARGET_ASM_ALIGNED_HI_OP\n #define TARGET_ASM_ALIGNED_HI_OP \"\\t.half\\t\"\n@@ -6705,6 +6805,9 @@ riscv_regmode_natural_size (machine_mode mode)\n #undef TARGET_VECTOR_ALIGNMENT\n #define TARGET_VECTOR_ALIGNMENT riscv_vector_alignment\n \n+#undef TARGET_DWARF_POLY_INDETERMINATE_VALUE\n+#define TARGET_DWARF_POLY_INDETERMINATE_VALUE riscv_dwarf_poly_indeterminate_value\n+\n struct gcc_target targetm = TARGET_INITIALIZER;\n \n #include \"gt-riscv.h\""}, {"sha": "2d0d170645c33254a168c08bd39ae4dd181b0b88", "filename": "gcc/config/riscv/riscv.h", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5576518a5667ad826937125a19b7c59c34d8733c/gcc%2Fconfig%2Friscv%2Friscv.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5576518a5667ad826937125a19b7c59c34d8733c/gcc%2Fconfig%2Friscv%2Friscv.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Friscv%2Friscv.h?ref=5576518a5667ad826937125a19b7c59c34d8733c", "patch": "@@ -392,6 +392,7 @@ ASM_MISA_SPEC\n /* Define Dwarf for RVV.  */\n #define RISCV_DWARF_VL (4096 + 0xc20)\n #define RISCV_DWARF_VTYPE (4096 + 0xc21)\n+#define RISCV_DWARF_VLENB (4096 + 0xc22)\n \n /* Register in which static-chain is passed to a function.  */\n #define STATIC_CHAIN_REGNUM (GP_TEMP_FIRST + 2)\n@@ -405,6 +406,8 @@ ASM_MISA_SPEC\n \n #define RISCV_PROLOGUE_TEMP_REGNUM (GP_TEMP_FIRST)\n #define RISCV_PROLOGUE_TEMP(MODE) gen_rtx_REG (MODE, RISCV_PROLOGUE_TEMP_REGNUM)\n+#define RISCV_PROLOGUE_TEMP2_REGNUM (GP_TEMP_FIRST + 1)\n+#define RISCV_PROLOGUE_TEMP2(MODE) gen_rtx_REG (MODE, RISCV_PROLOGUE_TEMP2_REGNUM)\n \n #define RISCV_CALL_ADDRESS_TEMP_REGNUM (GP_TEMP_FIRST + 1)\n #define RISCV_CALL_ADDRESS_TEMP(MODE) \\"}, {"sha": "9d4a9dc8a0ee9e8664dcdc684367a1940df2ac7b", "filename": "gcc/config/riscv/vector-iterators.md", "status": "modified", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5576518a5667ad826937125a19b7c59c34d8733c/gcc%2Fconfig%2Friscv%2Fvector-iterators.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5576518a5667ad826937125a19b7c59c34d8733c/gcc%2Fconfig%2Friscv%2Fvector-iterators.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Friscv%2Fvector-iterators.md?ref=5576518a5667ad826937125a19b7c59c34d8733c", "patch": "@@ -34,6 +34,29 @@\n   (VNx8DF \"TARGET_VECTOR_ELEN_FP_64\")\n ])\n \n+(define_mode_iterator V_WHOLE [\n+  (VNx4QI \"TARGET_MIN_VLEN == 32\") VNx8QI VNx16QI VNx32QI (VNx64QI \"TARGET_MIN_VLEN > 32\")\n+  (VNx2HI \"TARGET_MIN_VLEN == 32\") VNx4HI VNx8HI VNx16HI (VNx32HI \"TARGET_MIN_VLEN > 32\")\n+  (VNx1SI \"TARGET_MIN_VLEN == 32\") VNx2SI VNx4SI VNx8SI (VNx16SI \"TARGET_MIN_VLEN > 32\")\n+  VNx1DI VNx2DI VNx4DI (VNx8DI \"TARGET_MIN_VLEN > 32\")\n+  (VNx1SF \"TARGET_VECTOR_ELEN_FP_32 && TARGET_MIN_VLEN == 32\")\n+  (VNx2SF \"TARGET_VECTOR_ELEN_FP_32\")\n+  (VNx4SF \"TARGET_VECTOR_ELEN_FP_32\")\n+  (VNx8SF \"TARGET_VECTOR_ELEN_FP_32\")\n+  (VNx16SF \"TARGET_VECTOR_ELEN_FP_32 && TARGET_MIN_VLEN > 32\")\n+  (VNx1DF \"TARGET_VECTOR_ELEN_FP_64\")\n+  (VNx2DF \"TARGET_VECTOR_ELEN_FP_64\")\n+  (VNx4DF \"TARGET_VECTOR_ELEN_FP_64\")\n+  (VNx8DF \"TARGET_VECTOR_ELEN_FP_64\")\n+])\n+\n+(define_mode_iterator V_FRACT [\n+  VNx1QI VNx2QI (VNx4QI \"TARGET_MIN_VLEN > 32\")\n+  VNx1HI (VNx2HI \"TARGET_MIN_VLEN > 32\")\n+  (VNx1SI \"TARGET_MIN_VLEN > 32\")\n+  (VNx1SF \"TARGET_VECTOR_ELEN_FP_32 && TARGET_MIN_VLEN > 32\")\n+])\n+\n (define_mode_iterator VB [\n   VNx1BI VNx2BI VNx4BI VNx8BI VNx16BI VNx32BI\n   (VNx64BI \"TARGET_MIN_VLEN > 32\")"}, {"sha": "01418ac5fcff29fa9e0ec23acb5e1d240152601f", "filename": "gcc/config/riscv/vector.md", "status": "modified", "additions": 103, "deletions": 33, "changes": 136, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5576518a5667ad826937125a19b7c59c34d8733c/gcc%2Fconfig%2Friscv%2Fvector.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5576518a5667ad826937125a19b7c59c34d8733c/gcc%2Fconfig%2Friscv%2Fvector.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Friscv%2Fvector.md?ref=5576518a5667ad826937125a19b7c59c34d8733c", "patch": "@@ -53,6 +53,36 @@\n \t(match_operand:V 1 \"vector_move_operand\"))]\n   \"TARGET_VECTOR\"\n {\n+  /* For whole register move, we transform the pattern into the format\n+     that excludes the clobber of scratch register.\n+\n+     We include clobber of a scalar scratch register which is going to be\n+     used for emit of vsetvl instruction after reload_completed since we\n+     need vsetvl instruction to set VL/VTYPE global status for fractional\n+     vector load/store.\n+\n+     For example:\n+       [(set (match_operand:VNx1QI v24)\n+\t     (match_operand:VNx1QI (mem: a4)))\n+\t     (clobber (scratch:SI a5))]\n+     ====>> vsetvl a5,zero,e8,mf8\n+     ====>> vle8.v v24,(a4)\n+\n+     Philosophy:\n+\n+       - Clobber a scalar scratch register for each mov<mode>.\n+\n+       - Classify the machine_mode mode = <MODE>mode into 2 class:\n+\t Whole register move and fractional register move.\n+\n+       - Transform and remove scratch clobber register for whole\n+\t register move so that we can avoid occupying the scalar\n+\t registers.\n+\n+       - We can not leave it to TARGET_SECONDARY_RELOAD since it happens\n+\t before spilling. The clobber scratch is used by spilling fractional\n+\t registers in IRA/LRA so it's too early.  */\n+\n   if (riscv_vector::legitimize_move (operands[0], operands[1], <VM>mode))\n     DONE;\n })\n@@ -61,31 +91,61 @@\n ;; Also applicable for all register moves.\n ;; Fractional vector modes load/store are not allowed to match this pattern.\n ;; Mask modes load/store are not allowed to match this pattern.\n-(define_insn \"*mov<mode>\"\n-  [(set (match_operand:V 0 \"reg_or_mem_operand\" \"=vr,m,vr\")\n-\t(match_operand:V 1 \"reg_or_mem_operand\" \"m,vr,vr\"))]\n-  \"TARGET_VECTOR && ((register_operand (operands[0], <MODE>mode)\n-\t\t      && register_operand (operands[1], <MODE>mode))\n-   || known_ge (GET_MODE_SIZE (<MODE>mode), BYTES_PER_RISCV_VECTOR))\"\n+;; We seperate \"*mov<mode>\" into \"*mov<mode>_whole\" and \"*mov<mode>_fract\" because\n+;; we don't want to include fractional load/store in \"*mov<mode>\" which will\n+;; create unexpected patterns in LRA.\n+;; For example:\n+;; ira rtl:\n+;;   (insn 20 19 9 2 (set (reg/v:VNx2QI 97 v1 [ v1 ])\n+;;      (reg:VNx2QI 134 [ _1 ])) \"rvv.c\":9:22 571 {*movvnx2qi_fract}\n+;;   (nil))\n+;; When the value of pseudo register 134 of the insn above is discovered already\n+;; spilled in the memory during LRA.\n+;; LRA will reload this pattern into a memory load instruction pattern.\n+;; Because VNx2QI is a fractional vector, we want LRA reload this pattern into\n+;;  (insn 20 19 9 2 (parallel [\n+;;       (set (reg:VNx2QI 98 v2 [orig:134 _1 ] [134])\n+;;           (mem/c:VNx2QI (reg:SI 13 a3 [155]) [1 %sfp+[-2, -2] S[2, 2] A8]))\n+;;       (clobber (reg:SI 14 a4 [149]))])\n+;; So that we could be able to emit vsetvl instruction using clobber sratch a4.\n+;; To let LRA generate the expected pattern, we should exclude fractional vector\n+;; load/store in \"*mov<mode>_whole\". Otherwise, it will reload this pattern into:\n+;;  (insn 20 19 9 2 (set (reg:VNx2QI 98 v2 [orig:134 _1 ] [134])\n+;;           (mem/c:VNx2QI (reg:SI 13 a3 [155]) [1 %sfp+[-2, -2] S[2, 2] A8])))\n+;; which is not the pattern we want.\n+;; According the facts above, we make \"*mov<mode>_whole\" includes load/store/move for whole\n+;; vector modes according to '-march' and \"*mov<mode>_fract\" only include fractional vector modes.\n+(define_insn \"*mov<mode>_whole\"\n+  [(set (match_operand:V_WHOLE 0 \"reg_or_mem_operand\" \"=vr, m,vr\")\n+\t(match_operand:V_WHOLE 1 \"reg_or_mem_operand\" \"  m,vr,vr\"))]\n+  \"TARGET_VECTOR\"\n   \"@\n    vl%m1re<sew>.v\\t%0,%1\n    vs%m1r.v\\t%1,%0\n    vmv%m1r.v\\t%0,%1\"\n   [(set_attr \"type\" \"vldr,vstr,vmov\")\n    (set_attr \"mode\" \"<MODE>\")])\n \n+(define_insn \"*mov<mode>_fract\"\n+  [(set (match_operand:V_FRACT 0 \"register_operand\" \"=vr\")\n+\t(match_operand:V_FRACT 1 \"register_operand\" \" vr\"))]\n+  \"TARGET_VECTOR\"\n+  \"vmv1r.v\\t%0,%1\"\n+  [(set_attr \"type\" \"vmov\")\n+   (set_attr \"mode\" \"<MODE>\")])\n+\n (define_expand \"mov<mode>\"\n   [(set (match_operand:VB 0 \"reg_or_mem_operand\")\n \t(match_operand:VB 1 \"vector_move_operand\"))]\n   \"TARGET_VECTOR\"\n {\n   if (riscv_vector::legitimize_move (operands[0], operands[1], <MODE>mode))\n-     DONE;\n+    DONE;\n })\n \n (define_insn \"*mov<mode>\"\n   [(set (match_operand:VB 0 \"register_operand\" \"=vr\")\n-\t(match_operand:VB 1 \"register_operand\" \"vr\"))]\n+\t(match_operand:VB 1 \"register_operand\" \" vr\"))]\n   \"TARGET_VECTOR\"\n   \"vmv1r.v\\t%0,%1\"\n   [(set_attr \"type\" \"vmov\")\n@@ -290,50 +350,60 @@\n ;;                (const_int:QI N)]), -15 <= N < 16.\n ;;    2. (const_vector:VNx1SF repeat [\n ;;                (const_double:SF 0.0 [0x0.0p+0])]).\n-(define_insn \"@pred_mov<mode>\"\n+(define_insn_and_split \"@pred_mov<mode>\"\n   [(set (match_operand:V 0 \"nonimmediate_operand\"        \"=vd,  vr,     m,    vr,    vr\")\n-        (if_then_else:V\n-          (unspec:<VM>\n-            [(match_operand:<VM> 1 \"vector_mask_operand\" \" vm, Wc1, vmWc1, vmWc1,   Wc1\")\n-             (match_operand 4 \"vector_length_operand\"    \" rK,  rK,    rK,    rK,    rK\")\n-             (match_operand 5 \"const_int_operand\"        \"  i,   i,     i,     i,     i\")\n-             (match_operand 6 \"const_int_operand\"        \"  i,   i,     i,     i,     i\")\n-             (reg:SI VL_REGNUM)\n-             (reg:SI VTYPE_REGNUM)] UNSPEC_VPREDICATE)\n-          (match_operand:V 3 \"vector_move_operand\"       \"  m,   m,    vr,    vr, viWc0\")\n-          (match_operand:V 2 \"vector_merge_operand\"      \"  0,  vu,     0,   vu0,   vu0\")))]\n+\t(if_then_else:V\n+\t  (unspec:<VM>\n+\t    [(match_operand:<VM> 1 \"vector_mask_operand\" \" vm, Wc1, vmWc1,   Wc1,   Wc1\")\n+\t     (match_operand 4 \"vector_length_operand\"    \" rK,  rK,    rK,    rK,    rK\")\n+\t     (match_operand 5 \"const_int_operand\"        \"  i,   i,     i,     i,     i\")\n+\t     (match_operand 6 \"const_int_operand\"        \"  i,   i,     i,     i,     i\")\n+\t     (reg:SI VL_REGNUM)\n+\t     (reg:SI VTYPE_REGNUM)] UNSPEC_VPREDICATE)\n+\t  (match_operand:V 3 \"vector_move_operand\"       \"  m,   m,    vr,    vr, viWc0\")\n+\t  (match_operand:V 2 \"vector_merge_operand\"      \"  0,  vu,   vu0,   vu0,   vu0\")))]\n   \"TARGET_VECTOR\"\n   \"@\n    vle<sew>.v\\t%0,%3%p1\n    vle<sew>.v\\t%0,%3%p1\n    vse<sew>.v\\t%3,%0%p1\n    vmv.v.v\\t%0,%3\n    vmv.v.i\\t%0,v%3\"\n+  \"&& register_operand (operands[0], <MODE>mode)\n+   && register_operand (operands[3], <MODE>mode)\n+   && satisfies_constraint_vu (operands[2])\"\n+  [(set (match_dup 0) (match_dup 3))]\n+  \"\"\n   [(set_attr \"type\" \"vlde,vlde,vste,vimov,vimov\")\n    (set_attr \"mode\" \"<MODE>\")])\n \n ;; vlm.v/vsm.v/vmclr.m/vmset.m.\n ;; constraint alternative 0 match vlm.v.\n-;; constraint alternative 2 match vsm.v.\n+;; constraint alternative 1 match vsm.v.\n ;; constraint alternative 3 match vmclr.m.\n ;; constraint alternative 4 match vmset.m.\n-(define_insn \"@pred_mov<mode>\"\n-  [(set (match_operand:VB 0 \"nonimmediate_operand\"       \"=vr,   m,  vr,  vr\")\n-        (if_then_else:VB\n-          (unspec:VB\n-            [(match_operand:VB 1 \"vector_mask_operand\"   \"Wc1, Wc1, Wc1, Wc1\")\n-             (match_operand 4 \"vector_length_operand\"    \" rK,  rK,  rK,  rK\")\n-             (match_operand 5 \"const_int_operand\"        \"  i,   i,   i,   i\")\n-             (match_operand 6 \"const_int_operand\"        \"  i,   i,   i,   i\")\n-             (reg:SI VL_REGNUM)\n-             (reg:SI VTYPE_REGNUM)] UNSPEC_VPREDICATE)\n-          (match_operand:VB 3 \"vector_move_operand\"      \"  m,  vr, Wc0, Wc1\")\n-          (match_operand:VB 2 \"vector_merge_operand\"     \" vu,   0,  vu,  vu\")))]\n+(define_insn_and_split \"@pred_mov<mode>\"\n+  [(set (match_operand:VB 0 \"nonimmediate_operand\"       \"=vr,   m,  vr,  vr,  vr\")\n+\t(if_then_else:VB\n+\t  (unspec:VB\n+\t    [(match_operand:VB 1 \"vector_mask_operand\"   \"Wc1, Wc1, Wc1, Wc1, Wc1\")\n+\t     (match_operand 4 \"vector_length_operand\"    \" rK,  rK,  rK,  rK,  rK\")\n+\t     (match_operand 5 \"const_int_operand\"        \"  i,   i,   i,   i,   i\")\n+\t     (match_operand 6 \"const_int_operand\"        \"  i,   i,   i,   i,   i\")\n+\t     (reg:SI VL_REGNUM)\n+\t     (reg:SI VTYPE_REGNUM)] UNSPEC_VPREDICATE)\n+\t  (match_operand:VB 3 \"vector_move_operand\"      \"  m,  vr,  vr, Wc0, Wc1\")\n+\t  (match_operand:VB 2 \"vector_merge_operand\"     \" vu, vu0,  vu,  vu,  vu\")))]\n   \"TARGET_VECTOR\"\n   \"@\n    vlm.v\\t%0,%3\n    vsm.v\\t%3,%0\n+   #\n    vmclr.m\\t%0\n    vmset.m\\t%0\"\n-  [(set_attr \"type\" \"vldm,vstm,vmalu,vmalu\")\n+  \"&& register_operand (operands[0], <MODE>mode)\n+   && register_operand (operands[3], <MODE>mode)\"\n+  [(set (match_dup 0) (match_dup 3))]\n+  \"\"\n+  [(set_attr \"type\" \"vldm,vstm,vimov,vmalu,vmalu\")\n    (set_attr \"mode\" \"<MODE>\")])"}, {"sha": "a032ac38f5afe7e0aa08c14e3aacee42243a741d", "filename": "gcc/testsuite/gcc.target/riscv/rvv/base/macro.h", "status": "added", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5576518a5667ad826937125a19b7c59c34d8733c/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fbase%2Fmacro.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5576518a5667ad826937125a19b7c59c34d8733c/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fbase%2Fmacro.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fbase%2Fmacro.h?ref=5576518a5667ad826937125a19b7c59c34d8733c", "patch": "@@ -0,0 +1,6 @@\n+#define exhaust_vector_regs()                                                  \\\n+  asm volatile(\"#\" ::                                                          \\\n+\t\t : \"v0\", \"v1\", \"v2\", \"v3\", \"v4\", \"v5\", \"v6\", \"v7\", \"v8\", \"v9\", \\\n+\t\t   \"v10\", \"v11\", \"v12\", \"v13\", \"v14\", \"v15\", \"v16\", \"v17\",     \\\n+\t\t   \"v18\", \"v19\", \"v20\", \"v21\", \"v22\", \"v23\", \"v24\", \"v25\",     \\\n+\t\t   \"v26\", \"v27\", \"v28\", \"v29\", \"v30\", \"v31\");"}, {"sha": "b1220c48f1b6a6fb0da498c9cb58bd235ef72780", "filename": "gcc/testsuite/gcc.target/riscv/rvv/base/spill-1.c", "status": "added", "additions": 385, "deletions": 0, "changes": 385, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5576518a5667ad826937125a19b7c59c34d8733c/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fbase%2Fspill-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5576518a5667ad826937125a19b7c59c34d8733c/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fbase%2Fspill-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fbase%2Fspill-1.c?ref=5576518a5667ad826937125a19b7c59c34d8733c", "patch": "@@ -0,0 +1,385 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-march=rv32gcv -mabi=ilp32 -mpreferred-stack-boundary=3 -O3 -fno-schedule-insns -fno-schedule-insns2\" } */\n+/* { dg-final { check-function-bodies \"**\" \"\" } } */\n+\n+#include \"riscv_vector.h\"\n+#include \"macro.h\"\n+\n+/*\n+** spill_1:\n+**  csrr\\tt0,vlenb\n+**  sub\\tsp,sp,t0\n+**  ...\n+**  csrr\\ta2,vlenb\n+**  srli\\ta2,a2,3\n+**  slli\\ta3,a2,3\n+**  sub\\ta3,a3,a2\n+**  add\\ta3,a3,sp\n+**  vse8.v\\tv24,0\\(a3\\)\n+**  ...\n+**  csrr\\ta2,vlenb\n+**  srli\\ta2,a2,3\n+**  slli\\ta3,a2,3\n+**  sub\\ta3,a3,a2\n+**  add\\ta3,a3,sp\n+**  vle8.v\\tv24,0\\(a3\\)\n+**  vse8.v\\tv24,0\\(a1\\)\n+**  csrr\\tt0,vlenb\n+**  add\\tsp,sp,t0\n+**  ...\n+**  jr\\tra\n+*/\n+void\n+spill_1 (int8_t *in, int8_t *out)\n+{\n+  vint8mf8_t v1 = *(vint8mf8_t*)in;\n+  exhaust_vector_regs ();\n+  *(vint8mf8_t*)out = v1;\n+}\n+\n+/*\n+** spill_2:\n+**  csrr\\tt0,vlenb\n+**  sub\\tsp,sp,t0\n+**  vsetvli\\ta5,zero,e8,mf4,ta,ma\n+**  vle8.v\\tv24,0\\(a0\\)\n+**  csrr\\ta2,vlenb\n+**  srli\\ta2,a2,2\n+**  slli\\ta3,a2,2\n+**  sub\\ta3,a3,a2\n+**  add\\ta3,a3,sp\n+**  vse8.v\\tv24,0\\(a3\\)\n+**  ...\n+**  csrr\\ta2,vlenb\n+**  srli\\ta2,a2,2\n+**  slli\\ta3,a2,2\n+**  sub\\ta3,a3,a2\n+**  add\\ta3,a3,sp\n+**  vle8.v\\tv24,0\\(a3\\)\n+**  vse8.v\\tv24,0\\(a1\\)\n+**  csrr\\tt0,vlenb\n+**  add\\tsp,sp,t0\n+**  ...\n+**  jr\\tra\n+*/\n+void\n+spill_2 (int8_t *in, int8_t *out)\n+{\n+  vint8mf4_t v1 = *(vint8mf4_t*)in;\n+  exhaust_vector_regs ();\n+  *(vint8mf4_t*)out = v1;\n+}\n+\n+/*\n+** spill_3:\n+** csrr\\tt0,vlenb\n+** sub\\tsp,sp,t0\n+** vsetvli\\ta5,zero,e8,mf2,ta,ma\n+** vle8.v\\tv24,0\\(a0\\)\n+** csrr\\ta3,vlenb\n+** srli\\ta3,a3,1\n+** add\\ta3,a3,sp\n+** vse8.v\\tv24,0\\(a3\\)\n+**  ...\n+** csrr\\ta3,vlenb\n+** srli\\ta3,a3,1\n+** add\\ta3,a3,sp\n+** vle8.v\\tv24,0\\(a3\\)\n+** vse8.v\\tv24,0\\(a1\\)\n+** csrr\\tt0,vlenb\n+** add\\tsp,sp,t0\n+**  ...\n+**  jr\\tra\n+*/\n+void\n+spill_3 (int8_t *in, int8_t *out)\n+{\n+  vint8mf2_t v1 = *(vint8mf2_t*)in;\n+  exhaust_vector_regs ();\n+  *(vint8mf2_t*)out = v1;\n+}\n+\n+/*\n+** spill_4:\n+**  csrr\\tt0,vlenb\n+**  sub\\tsp,sp,t0\n+**  ...\n+**  vs1r.v\\tv24,0\\(sp\\)\n+**  ...\n+**  vl1re8.v\\tv2,0\\(sp\\)\n+**  vs1r.v\\tv2,0\\(a1\\)\n+**  ...\n+**  jr\\tra\n+*/\n+void\n+spill_4 (int8_t *in, int8_t *out)\n+{\n+  register vint8m1_t v1 asm(\"v1\") = *(vint8m1_t*)in; \n+  asm volatile (\"# %0\"::\"vr\"(v1)); \n+  exhaust_vector_regs (); \n+  register vint8m1_t v2 asm(\"v2\") = v1; \n+  *(vint8m1_t*)out = v2; \n+  asm volatile (\"# %0\"::\"vr\"(v2));\n+}\n+\n+/*\n+** spill_5:\n+**  csrr\\tt0,vlenb\n+**  slli\\tt1,t0,1\n+**  sub\\tsp,sp,t1\n+**  ...\n+**  vs2r.v\\tv24,0\\(sp\\)\n+**  ...\n+**  vl2re8.v\\tv4,0\\(sp\\)\n+**  vs2r.v\\tv4,0\\(a1\\)\n+**  ...\n+**  jr\\tra\n+*/\n+void\n+spill_5 (int8_t *in, int8_t *out)\n+{\n+  register vint8m2_t v2 asm(\"v2\") = *(vint8m2_t*)in; \n+  asm volatile (\"# %0\"::\"vr\"(v2)); \n+  exhaust_vector_regs (); \n+  register vint8m2_t v4 asm(\"v4\") = v2; \n+  *(vint8m2_t*)out = v4; \n+  asm volatile (\"# %0\"::\"vr\"(v4));\n+}\n+\n+/*\n+** spill_6:\n+**  csrr\\tt0,vlenb\n+**  slli\\tt1,t0,2\n+**  sub\\tsp,sp,t1\n+**  ...\n+**  vs4r.v\\tv24,0\\(sp\\)\n+**  ...\n+**  vl4re8.v\\tv8,0\\(sp\\)\n+**  vs4r.v\\tv8,0\\(a1\\)\n+**  ...\n+**  jr\\tra\n+*/\n+void\n+spill_6 (int8_t *in, int8_t *out)\n+{\n+  register vint8m4_t v4 asm(\"v4\") = *(vint8m4_t*)in; \n+  asm volatile (\"# %0\"::\"vr\"(v4)); \n+  exhaust_vector_regs (); \n+  register vint8m4_t v8 asm(\"v8\") = v4; \n+  *(vint8m4_t*)out = v8; \n+  asm volatile (\"# %0\"::\"vr\"(v8));\n+}\n+\n+/*\n+** spill_7:\n+**  csrr\\tt0,vlenb\n+**  slli\\tt1,t0,3\n+**  sub\\tsp,sp,t1\n+**  ...\n+**  vs8r.v\\tv24,0\\(sp\\)\n+**  ...\n+**  vl8re8.v\\tv16,0\\(sp\\)\n+**  vs8r.v\\tv16,0\\(a1\\)\n+**  ...\n+**  jr\\tra\n+*/\n+void\n+spill_7 (int8_t *in, int8_t *out)\n+{\n+  register vint8m8_t v8 asm(\"v8\") = *(vint8m8_t*)in; \n+  asm volatile (\"# %0\"::\"vr\"(v8)); \n+  exhaust_vector_regs (); \n+  register vint8m8_t v16 asm(\"v16\") = v8; \n+  *(vint8m8_t*)out = v16; \n+  asm volatile (\"# %0\"::\"vr\"(v16));\n+}\n+\n+/*\n+** spill_8:\n+** csrr\\tt0,vlenb\n+** sub\\tsp,sp,t0\n+** vsetvli\\ta5,zero,e8,mf8,ta,ma\n+** vle8.v\\tv24,0\\(a0\\)\n+** csrr\\ta2,vlenb\n+** srli\\ta2,a2,3\n+** slli\\ta3,a2,3\n+** sub\\ta3,a3,a2\n+** add\\ta3,a3,sp\n+** vse8.v\\tv24,0\\(a3\\)\n+**  ...\n+**  csrr\\ta2,vlenb\n+**  srli\\ta2,a2,3\n+**  slli\\ta3,a2,3\n+**  sub\\ta3,a3,a2\n+**  add\\ta3,a3,sp\n+**  vle8.v\\tv24,0\\(a3\\)\n+**  vse8.v\\tv24,0\\(a1\\)\n+**  csrr\\tt0,vlenb\n+**  add\\tsp,sp,t0\n+**  ...\n+**  jr\\tra\n+*/\n+void\n+spill_8 (uint8_t *in, uint8_t *out)\n+{\n+  vuint8mf8_t v1 = *(vuint8mf8_t*)in;\n+  exhaust_vector_regs ();\n+  *(vuint8mf8_t*)out = v1;\n+}\n+\n+/*\n+** spill_9:\n+**  csrr\\tt0,vlenb\n+**  sub\\tsp,sp,t0\n+**  vsetvli\\ta5,zero,e8,mf4,ta,ma\n+**  vle8.v\\tv24,0\\(a0\\)\n+**  csrr\\ta2,vlenb\n+**  srli\\ta2,a2,2\n+**  slli\\ta3,a2,2\n+**  sub\\ta3,a3,a2\n+**  add\\ta3,a3,sp\n+**  vse8.v\\tv24,0\\(a3\\)\n+**  ...\n+**  csrr\\ta2,vlenb\n+**  srli\\ta2,a2,2\n+**  slli\\ta3,a2,2\n+**  sub\\ta3,a3,a2\n+**  add\\ta3,a3,sp\n+**  vle8.v\\tv24,0\\(a3\\)\n+**  vse8.v\\tv24,0\\(a1\\)\n+**  csrr\\tt0,vlenb\n+**  add\\tsp,sp,t0\n+**  ...\n+**  jr\\tra\n+*/\n+void\n+spill_9 (uint8_t *in, uint8_t *out)\n+{\n+  vuint8mf4_t v1 = *(vuint8mf4_t*)in;\n+  exhaust_vector_regs ();\n+  *(vuint8mf4_t*)out = v1;\n+}\n+\n+/*\n+** spill_10:\n+** csrr\\tt0,vlenb\n+** sub\\tsp,sp,t0\n+** vsetvli\\ta5,zero,e8,mf2,ta,ma\n+** vle8.v\\tv24,0\\(a0\\)\n+** csrr\\ta3,vlenb\n+** srli\\ta3,a3,1\n+** add\\ta3,a3,sp\n+** vse8.v\\tv24,0\\(a3\\)\n+**  ...\n+**  csrr\\ta3,vlenb\n+**  srli\\ta3,a3,1\n+**  add\\ta3,a3,sp\n+**  vle8.v\\tv24,0\\(a3\\)\n+**  vse8.v\\tv24,0\\(a1\\)\n+**  csrr\\tt0,vlenb\n+**  add\\tsp,sp,t0\n+**  ...\n+**  jr\\tra\n+*/\n+void\n+spill_10 (uint8_t *in, uint8_t *out)\n+{\n+  vuint8mf2_t v1 = *(vuint8mf2_t*)in;\n+  exhaust_vector_regs ();\n+  *(vuint8mf2_t*)out = v1;\n+}\n+\n+/*\n+** spill_11:\n+**  csrr\\tt0,vlenb\n+**  sub\\tsp,sp,t0\n+**  ...\n+**  vs1r.v\\tv24,0\\(sp\\)\n+**  ...\n+**  vl1re8.v\\tv2,0\\(sp\\)\n+**  vs1r.v\\tv2,0\\(a1\\)\n+**  ...\n+**  jr\\tra\n+*/\n+void\n+spill_11 (uint8_t *in, uint8_t *out)\n+{\n+  register vuint8m1_t v1 asm(\"v1\") = *(vuint8m1_t*)in; \n+  asm volatile (\"# %0\"::\"vr\"(v1)); \n+  exhaust_vector_regs (); \n+  register vuint8m1_t v2 asm(\"v2\") = v1; \n+  *(vuint8m1_t*)out = v2; \n+  asm volatile (\"# %0\"::\"vr\"(v2));\n+}\n+\n+/*\n+** spill_12:\n+**  csrr\\tt0,vlenb\n+**  slli\\tt1,t0,1\n+**  sub\\tsp,sp,t1\n+**  ...\n+**  vs2r.v\\tv24,0\\(sp\\)\n+**  ...\n+**  vl2re8.v\\tv4,0\\(sp\\)\n+**  vs2r.v\\tv4,0\\(a1\\)\n+**  ...\n+**  jr\\tra\n+*/\n+void\n+spill_12 (uint8_t *in, uint8_t *out)\n+{\n+  register vuint8m2_t v2 asm(\"v2\") = *(vuint8m2_t*)in; \n+  asm volatile (\"# %0\"::\"vr\"(v2)); \n+  exhaust_vector_regs (); \n+  register vuint8m2_t v4 asm(\"v4\") = v2; \n+  *(vuint8m2_t*)out = v4; \n+  asm volatile (\"# %0\"::\"vr\"(v4));\n+}\n+\n+/*\n+** spill_13:\n+**  csrr\\tt0,vlenb\n+**  slli\\tt1,t0,2\n+**  sub\\tsp,sp,t1\n+**  ...\n+**  vs4r.v\\tv24,0\\(sp\\)\n+**  ...\n+**  vl4re8.v\\tv8,0\\(sp\\)\n+**  vs4r.v\\tv8,0\\(a1\\)\n+**  ...\n+**  jr\\tra\n+*/\n+void\n+spill_13 (uint8_t *in, uint8_t *out)\n+{\n+  register vuint8m4_t v4 asm(\"v4\") = *(vuint8m4_t*)in; \n+  asm volatile (\"# %0\"::\"vr\"(v4)); \n+  exhaust_vector_regs (); \n+  register vuint8m4_t v8 asm(\"v8\") = v4; \n+  *(vuint8m4_t*)out = v8; \n+  asm volatile (\"# %0\"::\"vr\"(v8));\n+}\n+\n+/*\n+** spill_14:\n+**  csrr\\tt0,vlenb\n+**  slli\\tt1,t0,3\n+**  sub\\tsp,sp,t1\n+**  ...\n+**  vs8r.v\\tv24,0\\(sp\\)\n+**  ...\n+**  vl8re8.v\\tv16,0\\(sp\\)\n+**  vs8r.v\\tv16,0\\(a1\\)\n+**  ...\n+**  jr\\tra\n+*/\n+void\n+spill_14 (uint8_t *in, uint8_t *out)\n+{\n+  register vuint8m8_t v8 asm(\"v8\") = *(vuint8m8_t*)in; \n+  asm volatile (\"# %0\"::\"vr\"(v8)); \n+  exhaust_vector_regs (); \n+  register vuint8m8_t v16 asm(\"v16\") = v8; \n+  *(vuint8m8_t*)out = v16; \n+  asm volatile (\"# %0\"::\"vr\"(v16));\n+}"}, {"sha": "d37857e24ab48fdfc03480df01345a527cea3fab", "filename": "gcc/testsuite/gcc.target/riscv/rvv/base/spill-10.c", "status": "added", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5576518a5667ad826937125a19b7c59c34d8733c/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fbase%2Fspill-10.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5576518a5667ad826937125a19b7c59c34d8733c/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fbase%2Fspill-10.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fbase%2Fspill-10.c?ref=5576518a5667ad826937125a19b7c59c34d8733c", "patch": "@@ -0,0 +1,41 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-march=rv32gcv -mabi=ilp32 -mpreferred-stack-boundary=3 -fno-schedule-insns -fno-schedule-insns2 -O3\" } */\n+/* { dg-final { check-function-bodies \"**\" \"\" } } */\n+\n+#include \"riscv_vector.h\"\n+\n+void f (char*);\n+\n+/*\n+** stach_check_alloca_1:\n+**\taddi\\tsp,sp,-32\n+**\tsw\\tra,4\\(sp\\)\n+**\tsw\\ts0,0\\(sp\\)\n+**\taddi\\ts0,sp,8\n+**\tcsrr\\tt0,vlenb\n+**\tsub\\tsp,sp,t0\n+**\t...\n+**\taddi\\ta2,a2,15\n+**\tandi\\ta2,a2,-8\n+**\tsub\\tsp,sp,a2\n+**\t...\n+**\tlw\\tra,4\\(sp\\)\n+**\tlw\\ts0,0\\(sp\\)\n+**\taddi\\tsp,sp,32\n+**\tjr\\tra\n+*/\n+void stach_check_alloca_1 (vuint8m1_t data, uint8_t *base, int y, ...)\n+{\n+  vuint8m8_t v0, v8, v16, v24;\n+  asm volatile (\"nop\"\n+                : \"=vr\" (v0), \"=vr\" (v8), \"=vr\" (v16), \"=vr\" (v24)\n+                :\n+                :);\n+  asm volatile (\"nop\"\n+                :\n+                : \"vr\" (v0), \"vr\" (v8), \"vr\" (v16), \"vr\" (v24)\n+                :);\n+  *(vuint8m1_t *)base = data;\n+  char* pStr = (char*)__builtin_alloca(y);\n+  f(pStr);\n+}"}, {"sha": "c2f68b86d9083a1203c8ccca0b0a08160101dcac", "filename": "gcc/testsuite/gcc.target/riscv/rvv/base/spill-11.c", "status": "added", "additions": 60, "deletions": 0, "changes": 60, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5576518a5667ad826937125a19b7c59c34d8733c/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fbase%2Fspill-11.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5576518a5667ad826937125a19b7c59c34d8733c/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fbase%2Fspill-11.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fbase%2Fspill-11.c?ref=5576518a5667ad826937125a19b7c59c34d8733c", "patch": "@@ -0,0 +1,60 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-msave-restore -march=rv32gcv -mabi=ilp32 -msave-restore -fno-schedule-insns -fno-schedule-insns2 -O3\" } */\n+/* { dg-final { check-function-bodies \"**\" \"\" } } */\n+#include \"riscv_vector.h\"\n+\n+void fn2 (float a1, float a2, float a3, float a4,\n+          float a5, float a6, float a7, float a8);\n+void fn3 (char*);\n+\n+/*\n+** stack_save_restore_2:\n+**\tcall\\tt0,__riscv_save_2\n+**\tcsrr\\tt0,vlenb\n+**\tslli\\tt1,t0,1\n+**\tsub\\tsp,sp,t1\n+**\tli\\tt0,-8192\n+**\taddi\\tt0,t0,192\n+**\tadd\\tsp,sp,t0\n+**\t...\n+**\tcsrr\\tt0,vlenb\n+**\tslli\\tt1,t0,1\n+**\tadd\\tsp,sp,t1\n+**\tli\\tt0,8192\n+**\taddi\\tt0,t0,-208\n+**\tadd\\tsp,sp,t0\n+**\taddi\\tsp,sp,16\n+**\ttail\\t__riscv_restore_2\n+*/\n+int stack_save_restore_2 (float a1, float a2, float a3, float a4,\n+                      float a5, float a6, float a7, float a8,\n+                      vuint8m1_t data, uint8_t *base)\n+{\n+  char d[8000];\n+  float f1, f2, f3, f4, f5, f6, f7, f8, f9, f10, f11, f12, f13;\n+  asm volatile (\"nop\"\n+                : \"=f\" (f1), \"=f\" (f2), \"=f\" (f3), \"=f\" (f4), \"=f\" (f5), \"=f\" (f6),\n+                  \"=f\" (f7), \"=f\" (f8), \"=f\" (f9),  \"=f\" (f10), \"=f\" (f11),\n+                  \"=f\" (f12), \"=f\" (f13)\n+                :\n+                :);\n+  asm volatile (\"nop\"\n+                :\n+                : \"f\" (f1), \"f\" (f2), \"f\" (f3), \"f\" (f4), \"f\" (f5), \"f\" (f6),\n+                  \"f\" (f7), \"f\" (f8), \"f\" (f9), \"f\" (f10), \"f\" (f11),\n+                  \"f\" (f12), \"f\" (f13)\n+                :);\n+  vuint8m8_t v0, v8, v16, v24;\n+  asm volatile (\"nop\"\n+                : \"=vr\" (v0), \"=vr\" (v8), \"=vr\" (v16), \"=vr\" (v24)\n+                :\n+                :);\n+  asm volatile (\"nop\"\n+                :\n+                : \"vr\" (v0), \"vr\" (v8), \"vr\" (v16), \"vr\" (v24)\n+                :);\n+  *(vuint8m1_t *)base = data;\n+  fn2 (a1, a2, a3, a4, a5, a6, a7, a8);\n+  fn3(d);\n+  return 0;\n+}"}, {"sha": "de6e0604a3cd35d2719f7a7be2869de270f5b959", "filename": "gcc/testsuite/gcc.target/riscv/rvv/base/spill-12.c", "status": "added", "additions": 47, "deletions": 0, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5576518a5667ad826937125a19b7c59c34d8733c/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fbase%2Fspill-12.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5576518a5667ad826937125a19b7c59c34d8733c/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fbase%2Fspill-12.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fbase%2Fspill-12.c?ref=5576518a5667ad826937125a19b7c59c34d8733c", "patch": "@@ -0,0 +1,47 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-march=rv32gcv -mabi=ilp32 -msave-restore -fno-schedule-insns -fno-schedule-insns2 -O3\" } */\n+/* { dg-final { check-function-bodies \"**\" \"\" } } */\n+\n+\n+void fn2 (float a1, float a2, float a3, float a4,\n+          float a5, float a6, float a7, float a8);\n+void fn3 (char*);\n+\n+\n+/*\n+** stack_save_restore_1:\n+**\tcall\\tt0,__riscv_save_0\n+**\tli\\tt0,-8192\n+**\taddi\\tt0,t0,192\n+**\tadd\\tsp,sp,t0\n+**\t...\n+**\tli\\ta0,-8192\n+**\taddi\\ta0,a0,192\n+**\tli\\ta5,8192\n+**\taddi\\ta5,a5,-192\n+**\tadd\\ta5,a5,a0\n+**\tadd\\ta0,a5,sp\n+**\t...\n+**\ttail\\t__riscv_restore_0\n+*/\n+int stack_save_restore_1 (float a1, float a2, float a3, float a4,\n+                      float a5, float a6, float a7, float a8)\n+{\n+  char d[8000];\n+  float f1, f2, f3, f4, f5, f6, f7, f8, f9, f10, f11, f12, f13;\n+  asm volatile (\"nop\"\n+                : \"=f\" (f1), \"=f\" (f2), \"=f\" (f3), \"=f\" (f4), \"=f\" (f5), \"=f\" (f6),\n+                  \"=f\" (f7), \"=f\" (f8), \"=f\" (f9),  \"=f\" (f10), \"=f\" (f11),\n+                  \"=f\" (f12), \"=f\" (f13)\n+                :\n+                :);\n+  asm volatile (\"nop\"\n+                :\n+                : \"f\" (f1), \"f\" (f2), \"f\" (f3), \"f\" (f4), \"f\" (f5), \"f\" (f6),\n+                  \"f\" (f7), \"f\" (f8), \"f\" (f9), \"f\" (f10), \"f\" (f11),\n+                  \"f\" (f12), \"f\" (f13)\n+                :);\n+  fn2 (a1, a2, a3, a4, a5, a6, a7, a8);\n+  fn3(d);\n+  return 0;\n+}"}, {"sha": "ca1904b830d1d4f80998a559523160baaef57e4f", "filename": "gcc/testsuite/gcc.target/riscv/rvv/base/spill-2.c", "status": "added", "additions": 320, "deletions": 0, "changes": 320, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5576518a5667ad826937125a19b7c59c34d8733c/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fbase%2Fspill-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5576518a5667ad826937125a19b7c59c34d8733c/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fbase%2Fspill-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fbase%2Fspill-2.c?ref=5576518a5667ad826937125a19b7c59c34d8733c", "patch": "@@ -0,0 +1,320 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-march=rv32gcv -mabi=ilp32 -mpreferred-stack-boundary=3 -O3 -fno-schedule-insns -fno-schedule-insns2\" } */\n+/* { dg-final { check-function-bodies \"**\" \"\" } } */\n+\n+#include \"riscv_vector.h\"\n+#include \"macro.h\"\n+\n+/*\n+** spill_2:\n+**  csrr\\tt0,vlenb\n+**  sub\\tsp,sp,t0\n+**  vsetvli\\ta5,zero,e16,mf4,ta,ma\n+**  vle16.v\\tv24,0\\(a0\\)\n+**  csrr\\ta2,vlenb\n+**  srli\\ta2,a2,2\n+**  slli\\ta3,a2,2\n+**  sub\\ta3,a3,a2\n+**  add\\ta3,a3,sp\n+**  vse16.v\\tv24,0\\(a3\\)\n+**  ...\n+**  csrr\\ta2,vlenb\n+**  srli\\ta2,a2,2\n+**  slli\\ta3,a2,2\n+**  sub\\ta3,a3,a2\n+**  add\\ta3,a3,sp\n+**  vle16.v\\tv24,0\\(a3\\)\n+**  vse16.v\\tv24,0\\(a1\\)\n+**  csrr\\tt0,vlenb\n+**  add\\tsp,sp,t0\n+**  ...\n+**  jr\\tra\n+*/\n+void\n+spill_2 (int16_t *in, int16_t *out)\n+{\n+  vint16mf4_t v1 = *(vint16mf4_t*)in;\n+  exhaust_vector_regs ();\n+  *(vint16mf4_t*)out = v1;\n+}\n+\n+/*\n+** spill_3:\n+**  csrr\\tt0,vlenb\n+**  sub\\tsp,sp,t0\n+**  vsetvli\\ta5,zero,e16,mf2,ta,ma\n+**  vle16.v\\tv24,0\\(a0\\)\n+**  csrr\\ta3,vlenb\n+**  srli\\ta3,a3,1\n+**  add\\ta3,a3,sp\n+**  vse16.v\\tv24,0\\(a3\\)\n+**  ...\n+**  csrr\\ta3,vlenb\n+**  srli\\ta3,a3,1\n+**  add\\ta3,a3,sp\n+**  vle16.v\\tv24,0\\(a3\\)\n+**  vse16.v\\tv24,0\\(a1\\)\n+**  csrr\\tt0,vlenb\n+**  add\\tsp,sp,t0\n+**  ...\n+**  jr\\tra\n+*/\n+void\n+spill_3 (int16_t *in, int16_t *out)\n+{\n+  vint16mf2_t v1 = *(vint16mf2_t*)in;\n+  exhaust_vector_regs ();\n+  *(vint16mf2_t*)out = v1;\n+}\n+\n+/*\n+** spill_4:\n+**  csrr\\tt0,vlenb\n+**  sub\\tsp,sp,t0\n+**  ...\n+**  vs1r.v\\tv24,0\\(sp\\)\n+**  ...\n+**  vl1re16.v\\tv2,0\\(sp\\)\n+**  vs1r.v\\tv2,0\\(a1\\)\n+**  ...\n+**  jr\\tra\n+*/\n+void\n+spill_4 (int16_t *in, int16_t *out)\n+{\n+  register vint16m1_t v1 asm(\"v1\") = *(vint16m1_t*)in; \n+  asm volatile (\"# %0\"::\"vr\"(v1)); \n+  exhaust_vector_regs (); \n+  register vint16m1_t v2 asm(\"v2\") = v1; \n+  *(vint16m1_t*)out = v2; \n+  asm volatile (\"# %0\"::\"vr\"(v2));\n+}\n+\n+/*\n+** spill_5:\n+**  csrr\\tt0,vlenb\n+**  slli\\tt1,t0,1\n+**  sub\\tsp,sp,t1\n+**  ...\n+**  vs2r.v\\tv24,0\\(sp\\)\n+**  ...\n+**  vl2re16.v\\tv4,0\\(sp\\)\n+**  vs2r.v\\tv4,0\\(a1\\)\n+**  ...\n+**  jr\\tra\n+*/\n+void\n+spill_5 (int16_t *in, int16_t *out)\n+{\n+  register vint16m2_t v2 asm(\"v2\") = *(vint16m2_t*)in; \n+  asm volatile (\"# %0\"::\"vr\"(v2)); \n+  exhaust_vector_regs (); \n+  register vint16m2_t v4 asm(\"v4\") = v2; \n+  *(vint16m2_t*)out = v4; \n+  asm volatile (\"# %0\"::\"vr\"(v4));\n+}\n+\n+/*\n+** spill_6:\n+**  csrr\\tt0,vlenb\n+**  slli\\tt1,t0,2\n+**  sub\\tsp,sp,t1\n+**  ...\n+**  vs4r.v\\tv24,0\\(sp\\)\n+**  ...\n+**  vl4re16.v\\tv8,0\\(sp\\)\n+**  vs4r.v\\tv8,0\\(a1\\)\n+**  ...\n+**  jr\\tra\n+*/\n+void\n+spill_6 (int16_t *in, int16_t *out)\n+{\n+  register vint16m4_t v4 asm(\"v4\") = *(vint16m4_t*)in; \n+  asm volatile (\"# %0\"::\"vr\"(v4)); \n+  exhaust_vector_regs (); \n+  register vint16m4_t v8 asm(\"v8\") = v4; \n+  *(vint16m4_t*)out = v8; \n+  asm volatile (\"# %0\"::\"vr\"(v8));\n+}\n+\n+/*\n+** spill_7:\n+**  csrr\\tt0,vlenb\n+**  slli\\tt1,t0,3\n+**  sub\\tsp,sp,t1\n+**  ...\n+**  vs8r.v\\tv24,0\\(sp\\)\n+**  ...\n+**  vl8re16.v\\tv16,0\\(sp\\)\n+**  vs8r.v\\tv16,0\\(a1\\)\n+**  ...\n+**  jr\\tra\n+*/\n+void\n+spill_7 (int16_t *in, int16_t *out)\n+{\n+  register vint16m8_t v8 asm(\"v8\") = *(vint16m8_t*)in; \n+  asm volatile (\"# %0\"::\"vr\"(v8)); \n+  exhaust_vector_regs (); \n+  register vint16m8_t v16 asm(\"v16\") = v8; \n+  *(vint16m8_t*)out = v16; \n+  asm volatile (\"# %0\"::\"vr\"(v16));\n+}\n+\n+/*\n+** spill_9:\n+**  csrr\\tt0,vlenb\n+**  sub\\tsp,sp,t0\n+**  vsetvli\\ta5,zero,e16,mf4,ta,ma\n+**  vle16.v\\tv24,0\\(a0\\)\n+**  csrr\\ta2,vlenb\n+**  srli\\ta2,a2,2\n+**  slli\\ta3,a2,2\n+**  sub\\ta3,a3,a2\n+**  add\\ta3,a3,sp\n+**  vse16.v\\tv24,0\\(a3\\)\n+**  ...\n+**  csrr\\ta2,vlenb\n+**  srli\\ta2,a2,2\n+**  slli\\ta3,a2,2\n+**  sub\\ta3,a3,a2\n+**  add\\ta3,a3,sp\n+**  vle16.v\\tv24,0\\(a3\\)\n+**  vse16.v\\tv24,0\\(a1\\)\n+**  csrr\\tt0,vlenb\n+**  add\\tsp,sp,t0\n+**  ...\n+**  jr\\tra\n+*/\n+void\n+spill_9 (uint16_t *in, uint16_t *out)\n+{\n+  vuint16mf4_t v1 = *(vuint16mf4_t*)in;\n+  exhaust_vector_regs ();\n+  *(vuint16mf4_t*)out = v1;\n+}\n+\n+/*\n+** spill_10:\n+**  csrr\\tt0,vlenb\n+**  sub\\tsp,sp,t0\n+**  vsetvli\\ta5,zero,e16,mf2,ta,ma\n+**  vle16.v\\tv24,0\\(a0\\)\n+**  csrr\\ta3,vlenb\n+**  srli\\ta3,a3,1\n+**  add\\ta3,a3,sp\n+**  vse16.v\\tv24,0\\(a3\\)\n+**  ...\n+**  csrr\\ta3,vlenb\n+**  srli\\ta3,a3,1\n+**  add\\ta3,a3,sp\n+**  vle16.v\\tv24,0\\(a3\\)\n+**  vse16.v\\tv24,0\\(a1\\)\n+**  csrr\\tt0,vlenb\n+**  add\\tsp,sp,t0\n+**  ...\n+**  jr\\tra\n+*/\n+void\n+spill_10 (uint16_t *in, uint16_t *out)\n+{\n+  vuint16mf2_t v1 = *(vuint16mf2_t*)in;\n+  exhaust_vector_regs ();\n+  *(vuint16mf2_t*)out = v1;\n+}\n+\n+/*\n+** spill_11:\n+**  csrr\\tt0,vlenb\n+**  sub\\tsp,sp,t0\n+**  ...\n+**  vs1r.v\\tv24,0\\(sp\\)\n+**  ...\n+**  vl1re16.v\\tv2,0\\(sp\\)\n+**  vs1r.v\\tv2,0\\(a1\\)\n+**  ...\n+**  jr\\tra\n+*/\n+void\n+spill_11 (uint16_t *in, uint16_t *out)\n+{\n+  register vuint16m1_t v1 asm(\"v1\") = *(vuint16m1_t*)in; \n+  asm volatile (\"# %0\"::\"vr\"(v1)); \n+  exhaust_vector_regs (); \n+  register vuint16m1_t v2 asm(\"v2\") = v1; \n+  *(vuint16m1_t*)out = v2; \n+  asm volatile (\"# %0\"::\"vr\"(v2));\n+}\n+\n+/*\n+** spill_12:\n+**  csrr\\tt0,vlenb\n+**  slli\\tt1,t0,1\n+**  sub\\tsp,sp,t1\n+**  ...\n+**  vs2r.v\\tv24,0\\(sp\\)\n+**  ...\n+**  vl2re16.v\\tv4,0\\(sp\\)\n+**  vs2r.v\\tv4,0\\(a1\\)\n+**  ...\n+**  jr\\tra\n+*/\n+void\n+spill_12 (uint16_t *in, uint16_t *out)\n+{\n+  register vuint16m2_t v2 asm(\"v2\") = *(vuint16m2_t*)in; \n+  asm volatile (\"# %0\"::\"vr\"(v2)); \n+  exhaust_vector_regs (); \n+  register vuint16m2_t v4 asm(\"v4\") = v2; \n+  *(vuint16m2_t*)out = v4; \n+  asm volatile (\"# %0\"::\"vr\"(v4));\n+}\n+\n+/*\n+** spill_13:\n+**  csrr\\tt0,vlenb\n+**  slli\\tt1,t0,2\n+**  sub\\tsp,sp,t1\n+**  ...\n+**  vs4r.v\\tv24,0\\(sp\\)\n+**  ...\n+**  vl4re16.v\\tv8,0\\(sp\\)\n+**  vs4r.v\\tv8,0\\(a1\\)\n+**  ...\n+**  jr\\tra\n+*/\n+void\n+spill_13 (uint16_t *in, uint16_t *out)\n+{\n+  register vuint16m4_t v4 asm(\"v4\") = *(vuint16m4_t*)in; \n+  asm volatile (\"# %0\"::\"vr\"(v4)); \n+  exhaust_vector_regs (); \n+  register vuint16m4_t v8 asm(\"v8\") = v4; \n+  *(vuint16m4_t*)out = v8; \n+  asm volatile (\"# %0\"::\"vr\"(v8));\n+}\n+\n+/*\n+** spill_14:\n+**  csrr\\tt0,vlenb\n+**  slli\\tt1,t0,3\n+**  sub\\tsp,sp,t1\n+**  ...\n+**  vs8r.v\\tv24,0\\(sp\\)\n+**  ...\n+**  vl8re16.v\\tv16,0\\(sp\\)\n+**  vs8r.v\\tv16,0\\(a1\\)\n+**  ...\n+**  jr\\tra\n+*/\n+void\n+spill_14 (uint16_t *in, uint16_t *out)\n+{\n+  register vuint16m8_t v8 asm(\"v8\") = *(vuint16m8_t*)in; \n+  asm volatile (\"# %0\"::\"vr\"(v8)); \n+  exhaust_vector_regs (); \n+  register vuint16m8_t v16 asm(\"v16\") = v8; \n+  *(vuint16m8_t*)out = v16; \n+  asm volatile (\"# %0\"::\"vr\"(v16));\n+}"}, {"sha": "2039ca345167d328eaa806fc7f6a0aebade8bcae", "filename": "gcc/testsuite/gcc.target/riscv/rvv/base/spill-3.c", "status": "added", "additions": 254, "deletions": 0, "changes": 254, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5576518a5667ad826937125a19b7c59c34d8733c/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fbase%2Fspill-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5576518a5667ad826937125a19b7c59c34d8733c/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fbase%2Fspill-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fbase%2Fspill-3.c?ref=5576518a5667ad826937125a19b7c59c34d8733c", "patch": "@@ -0,0 +1,254 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-march=rv32gcv -mabi=ilp32 -mpreferred-stack-boundary=3 -O3 -fno-schedule-insns -fno-schedule-insns2\" } */\n+/* { dg-final { check-function-bodies \"**\" \"\" } } */\n+\n+#include \"riscv_vector.h\"\n+#include \"macro.h\"\n+\n+/*\n+** spill_3:\n+**  csrr\\tt0,vlenb\n+**  sub\\tsp,sp,t0\n+**  vsetvli\\ta5,zero,e32,mf2,ta,ma\n+**  vle32.v\\tv24,0\\(a0\\)\n+**  csrr\\ta3,vlenb\n+**  srli\\ta3,a3,1\n+**  add\\ta3,a3,sp\n+**  vse32.v\\tv24,0\\(a3\\)\n+**  ...\n+**  csrr\\ta3,vlenb\n+**  srli\\ta3,a3,1\n+**  add\\ta3,a3,sp\n+**  vle32.v\\tv24,0\\(a3\\)\n+**  vse32.v\\tv24,0\\(a1\\)\n+**  csrr\\tt0,vlenb\n+**  add\\tsp,sp,t0\n+**  ...\n+**  jr\\tra\n+*/\n+void\n+spill_3 (int32_t *in, int32_t *out)\n+{\n+  vint32mf2_t v1 = *(vint32mf2_t*)in;\n+  exhaust_vector_regs ();\n+  *(vint32mf2_t*)out = v1;\n+}\n+\n+/*\n+** spill_4:\n+**  csrr\\tt0,vlenb\n+**  sub\\tsp,sp,t0\n+**  ...\n+**  vs1r.v\\tv24,0\\(sp\\)\n+**  ...\n+**  vl1re32.v\\tv2,0\\(sp\\)\n+**  vs1r.v\\tv2,0\\(a1\\)\n+**  ...\n+**  jr\\tra\n+*/\n+void\n+spill_4 (int32_t *in, int32_t *out)\n+{\n+  register vint32m1_t v1 asm(\"v1\") = *(vint32m1_t*)in; \n+  asm volatile (\"# %0\"::\"vr\"(v1)); \n+  exhaust_vector_regs (); \n+  register vint32m1_t v2 asm(\"v2\") = v1; \n+  *(vint32m1_t*)out = v2; \n+  asm volatile (\"# %0\"::\"vr\"(v2));\n+}\n+\n+/*\n+** spill_5:\n+**  csrr\\tt0,vlenb\n+**  slli\\tt1,t0,1\n+**  sub\\tsp,sp,t1\n+**  ...\n+**  vs2r.v\\tv24,0\\(sp\\)\n+**  ...\n+**  vl2re32.v\\tv4,0\\(sp\\)\n+**  vs2r.v\\tv4,0\\(a1\\)\n+**  ...\n+**  jr\\tra\n+*/\n+void\n+spill_5 (int32_t *in, int32_t *out)\n+{\n+  register vint32m2_t v2 asm(\"v2\") = *(vint32m2_t*)in; \n+  asm volatile (\"# %0\"::\"vr\"(v2)); \n+  exhaust_vector_regs (); \n+  register vint32m2_t v4 asm(\"v4\") = v2; \n+  *(vint32m2_t*)out = v4; \n+  asm volatile (\"# %0\"::\"vr\"(v4));\n+}\n+\n+/*\n+** spill_6:\n+**  csrr\\tt0,vlenb\n+**  slli\\tt1,t0,2\n+**  sub\\tsp,sp,t1\n+**  ...\n+**  vs4r.v\\tv24,0\\(sp\\)\n+**  ...\n+**  vl4re32.v\\tv8,0\\(sp\\)\n+**  vs4r.v\\tv8,0\\(a1\\)\n+**  ...\n+**  jr\\tra\n+*/\n+void\n+spill_6 (int32_t *in, int32_t *out)\n+{\n+  register vint32m4_t v4 asm(\"v4\") = *(vint32m4_t*)in; \n+  asm volatile (\"# %0\"::\"vr\"(v4)); \n+  exhaust_vector_regs (); \n+  register vint32m4_t v8 asm(\"v8\") = v4; \n+  *(vint32m4_t*)out = v8; \n+  asm volatile (\"# %0\"::\"vr\"(v8));\n+}\n+\n+/*\n+** spill_7:\n+**  csrr\\tt0,vlenb\n+**  slli\\tt1,t0,3\n+**  sub\\tsp,sp,t1\n+**  ...\n+**  vs8r.v\\tv24,0\\(sp\\)\n+**  ...\n+**  vl8re32.v\\tv16,0\\(sp\\)\n+**  vs8r.v\\tv16,0\\(a1\\)\n+**  ...\n+**  jr\\tra\n+*/\n+void\n+spill_7 (int32_t *in, int32_t *out)\n+{\n+  register vint32m8_t v8 asm(\"v8\") = *(vint32m8_t*)in; \n+  asm volatile (\"# %0\"::\"vr\"(v8)); \n+  exhaust_vector_regs (); \n+  register vint32m8_t v16 asm(\"v16\") = v8; \n+  *(vint32m8_t*)out = v16; \n+  asm volatile (\"# %0\"::\"vr\"(v16));\n+}\n+\n+/*\n+** spill_10:\n+**  csrr\\tt0,vlenb\n+**  sub\\tsp,sp,t0\n+**  vsetvli\\ta5,zero,e32,mf2,ta,ma\n+**  vle32.v\\tv24,0\\(a0\\)\n+**  csrr\\ta3,vlenb\n+**  srli\\ta3,a3,1\n+**  add\\ta3,a3,sp\n+**  vse32.v\\tv24,0\\(a3\\)\n+**  ...\n+**  csrr\\ta3,vlenb\n+**  srli\\ta3,a3,1\n+**  add\\ta3,a3,sp\n+**  vle32.v\\tv24,0\\(a3\\)\n+**  vse32.v\\tv24,0\\(a1\\)\n+**  csrr\\tt0,vlenb\n+**  add\\tsp,sp,t0\n+**  ...\n+**  jr\\tra\n+*/\n+void\n+spill_10 (uint32_t *in, uint32_t *out)\n+{\n+  vuint32mf2_t v1 = *(vuint32mf2_t*)in;\n+  exhaust_vector_regs ();\n+  *(vuint32mf2_t*)out = v1;\n+}\n+\n+/*\n+** spill_11:\n+**  csrr\\tt0,vlenb\n+**  sub\\tsp,sp,t0\n+**  ...\n+**  vs1r.v\\tv24,0\\(sp\\)\n+**  ...\n+**  vl1re32.v\\tv2,0\\(sp\\)\n+**  vs1r.v\\tv2,0\\(a1\\)\n+**  ...\n+**  jr\\tra\n+*/\n+void\n+spill_11 (uint32_t *in, uint32_t *out)\n+{\n+  register vuint32m1_t v1 asm(\"v1\") = *(vuint32m1_t*)in; \n+  asm volatile (\"# %0\"::\"vr\"(v1)); \n+  exhaust_vector_regs (); \n+  register vuint32m1_t v2 asm(\"v2\") = v1; \n+  *(vuint32m1_t*)out = v2; \n+  asm volatile (\"# %0\"::\"vr\"(v2));\n+}\n+\n+/*\n+** spill_12:\n+**  csrr\\tt0,vlenb\n+**  slli\\tt1,t0,1\n+**  sub\\tsp,sp,t1\n+**  ...\n+**  vs2r.v\\tv24,0\\(sp\\)\n+**  ...\n+**  vl2re32.v\\tv4,0\\(sp\\)\n+**  vs2r.v\\tv4,0\\(a1\\)\n+**  ...\n+**  jr\\tra\n+*/\n+void\n+spill_12 (uint32_t *in, uint32_t *out)\n+{\n+  register vuint32m2_t v2 asm(\"v2\") = *(vuint32m2_t*)in; \n+  asm volatile (\"# %0\"::\"vr\"(v2)); \n+  exhaust_vector_regs (); \n+  register vuint32m2_t v4 asm(\"v4\") = v2; \n+  *(vuint32m2_t*)out = v4; \n+  asm volatile (\"# %0\"::\"vr\"(v4));\n+}\n+\n+/*\n+** spill_13:\n+**  csrr\\tt0,vlenb\n+**  slli\\tt1,t0,2\n+**  sub\\tsp,sp,t1\n+**  ...\n+**  vs4r.v\\tv24,0\\(sp\\)\n+**  ...\n+**  vl4re32.v\\tv8,0\\(sp\\)\n+**  vs4r.v\\tv8,0\\(a1\\)\n+**  ...\n+**  jr\\tra\n+*/\n+void\n+spill_13 (uint32_t *in, uint32_t *out)\n+{\n+  register vuint32m4_t v4 asm(\"v4\") = *(vuint32m4_t*)in; \n+  asm volatile (\"# %0\"::\"vr\"(v4)); \n+  exhaust_vector_regs (); \n+  register vuint32m4_t v8 asm(\"v8\") = v4; \n+  *(vuint32m4_t*)out = v8; \n+  asm volatile (\"# %0\"::\"vr\"(v8));\n+}\n+\n+/*\n+** spill_14:\n+**  csrr\\tt0,vlenb\n+**  slli\\tt1,t0,3\n+**  sub\\tsp,sp,t1\n+**  ...\n+**  vs8r.v\\tv24,0\\(sp\\)\n+**  ...\n+**  vl8re32.v\\tv16,0\\(sp\\)\n+**  vs8r.v\\tv16,0\\(a1\\)\n+**  ...\n+**  jr\\tra\n+*/\n+void\n+spill_14 (uint32_t *in, uint32_t *out)\n+{\n+  register vuint32m8_t v8 asm(\"v8\") = *(vuint32m8_t*)in; \n+  asm volatile (\"# %0\"::\"vr\"(v8)); \n+  exhaust_vector_regs (); \n+  register vuint32m8_t v16 asm(\"v16\") = v8; \n+  *(vuint32m8_t*)out = v16; \n+  asm volatile (\"# %0\"::\"vr\"(v16));\n+}"}, {"sha": "83c80b0b0456bf84ed3f2406cf1729bf1109e2aa", "filename": "gcc/testsuite/gcc.target/riscv/rvv/base/spill-4.c", "status": "added", "additions": 196, "deletions": 0, "changes": 196, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5576518a5667ad826937125a19b7c59c34d8733c/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fbase%2Fspill-4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5576518a5667ad826937125a19b7c59c34d8733c/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fbase%2Fspill-4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fbase%2Fspill-4.c?ref=5576518a5667ad826937125a19b7c59c34d8733c", "patch": "@@ -0,0 +1,196 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-march=rv32gcv -mabi=ilp32 -mpreferred-stack-boundary=3 -O3 -fno-schedule-insns -fno-schedule-insns2\" } */\n+/* { dg-final { check-function-bodies \"**\" \"\" } } */\n+\n+#include \"riscv_vector.h\"\n+#include \"macro.h\"\n+\n+/*\n+** spill_4:\n+**  csrr\\tt0,vlenb\n+**  sub\\tsp,sp,t0\n+**  ...\n+**  vs1r.v\\tv24,0\\(sp\\)\n+**  ...\n+**  vl1re64.v\\tv2,0\\(sp\\)\n+**  vs1r.v\\tv2,0\\(a1\\)\n+**  ...\n+**  jr\\tra\n+*/\n+void\n+spill_4 (int64_t *in, int64_t *out)\n+{\n+  register vint64m1_t v1 asm(\"v1\") = *(vint64m1_t*)in; \n+  asm volatile (\"# %0\"::\"vr\"(v1)); \n+  exhaust_vector_regs (); \n+  register vint64m1_t v2 asm(\"v2\") = v1; \n+  *(vint64m1_t*)out = v2; \n+  asm volatile (\"# %0\"::\"vr\"(v2));\n+}\n+\n+/*\n+** spill_5:\n+**  csrr\\tt0,vlenb\n+**  slli\\tt1,t0,1\n+**  sub\\tsp,sp,t1\n+**  ...\n+**  vs2r.v\\tv24,0\\(sp\\)\n+**  ...\n+**  vl2re64.v\\tv4,0\\(sp\\)\n+**  vs2r.v\\tv4,0\\(a1\\)\n+**  ...\n+**  jr\\tra\n+*/\n+void\n+spill_5 (int64_t *in, int64_t *out)\n+{\n+  register vint64m2_t v2 asm(\"v2\") = *(vint64m2_t*)in; \n+  asm volatile (\"# %0\"::\"vr\"(v2)); \n+  exhaust_vector_regs (); \n+  register vint64m2_t v4 asm(\"v4\") = v2; \n+  *(vint64m2_t*)out = v4; \n+  asm volatile (\"# %0\"::\"vr\"(v4));\n+}\n+\n+/*\n+** spill_6:\n+**  csrr\\tt0,vlenb\n+**  slli\\tt1,t0,2\n+**  sub\\tsp,sp,t1\n+**  ...\n+**  vs4r.v\\tv24,0\\(sp\\)\n+**  ...\n+**  vl4re64.v\\tv8,0\\(sp\\)\n+**  vs4r.v\\tv8,0\\(a1\\)\n+**  ...\n+**  jr\\tra\n+*/\n+void\n+spill_6 (int64_t *in, int64_t *out)\n+{\n+  register vint64m4_t v4 asm(\"v4\") = *(vint64m4_t*)in; \n+  asm volatile (\"# %0\"::\"vr\"(v4)); \n+  exhaust_vector_regs (); \n+  register vint64m4_t v8 asm(\"v8\") = v4; \n+  *(vint64m4_t*)out = v8; \n+  asm volatile (\"# %0\"::\"vr\"(v8));\n+}\n+\n+/*\n+** spill_7:\n+**  csrr\\tt0,vlenb\n+**  slli\\tt1,t0,3\n+**  sub\\tsp,sp,t1\n+**  ...\n+**  vs8r.v\\tv24,0\\(sp\\)\n+**  ...\n+**  vl8re64.v\\tv16,0\\(sp\\)\n+**  vs8r.v\\tv16,0\\(a1\\)\n+**  ...\n+**  jr\\tra\n+*/\n+void\n+spill_7 (int64_t *in, int64_t *out)\n+{\n+  register vint64m8_t v8 asm(\"v8\") = *(vint64m8_t*)in; \n+  asm volatile (\"# %0\"::\"vr\"(v8)); \n+  exhaust_vector_regs (); \n+  register vint64m8_t v16 asm(\"v16\") = v8; \n+  *(vint64m8_t*)out = v16; \n+  asm volatile (\"# %0\"::\"vr\"(v16));\n+}\n+\n+/*\n+** spill_11:\n+**  csrr\\tt0,vlenb\n+**  sub\\tsp,sp,t0\n+**  ...\n+**  vs1r.v\\tv24,0\\(sp\\)\n+**  ...\n+**  vl1re64.v\\tv2,0\\(sp\\)\n+**  vs1r.v\\tv2,0\\(a1\\)\n+**  ...\n+**  jr\\tra\n+*/\n+void\n+spill_11 (uint64_t *in, uint64_t *out)\n+{\n+  register vuint64m1_t v1 asm(\"v1\") = *(vuint64m1_t*)in; \n+  asm volatile (\"# %0\"::\"vr\"(v1)); \n+  exhaust_vector_regs (); \n+  register vuint64m1_t v2 asm(\"v2\") = v1; \n+  *(vuint64m1_t*)out = v2; \n+  asm volatile (\"# %0\"::\"vr\"(v2));\n+}\n+\n+/*\n+** spill_12:\n+**  csrr\\tt0,vlenb\n+**  slli\\tt1,t0,1\n+**  sub\\tsp,sp,t1\n+**  ...\n+**  vs2r.v\\tv24,0\\(sp\\)\n+**  ...\n+**  vl2re64.v\\tv4,0\\(sp\\)\n+**  vs2r.v\\tv4,0\\(a1\\)\n+**  ...\n+**  jr\\tra\n+*/\n+void\n+spill_12 (uint64_t *in, uint64_t *out)\n+{\n+  register vuint64m2_t v2 asm(\"v2\") = *(vuint64m2_t*)in; \n+  asm volatile (\"# %0\"::\"vr\"(v2)); \n+  exhaust_vector_regs (); \n+  register vuint64m2_t v4 asm(\"v4\") = v2; \n+  *(vuint64m2_t*)out = v4; \n+  asm volatile (\"# %0\"::\"vr\"(v4));\n+}\n+\n+/*\n+** spill_13:\n+**  csrr\\tt0,vlenb\n+**  slli\\tt1,t0,2\n+**  sub\\tsp,sp,t1\n+**  ...\n+**  vs4r.v\\tv24,0\\(sp\\)\n+**  ...\n+**  vl4re64.v\\tv8,0\\(sp\\)\n+**  vs4r.v\\tv8,0\\(a1\\)\n+**  ...\n+**  jr\\tra\n+*/\n+void\n+spill_13 (uint64_t *in, uint64_t *out)\n+{\n+  register vuint64m4_t v4 asm(\"v4\") = *(vuint64m4_t*)in; \n+  asm volatile (\"# %0\"::\"vr\"(v4)); \n+  exhaust_vector_regs (); \n+  register vuint64m4_t v8 asm(\"v8\") = v4; \n+  *(vuint64m4_t*)out = v8; \n+  asm volatile (\"# %0\"::\"vr\"(v8));\n+}\n+\n+/*\n+** spill_14:\n+**  csrr\\tt0,vlenb\n+**  slli\\tt1,t0,3\n+**  sub\\tsp,sp,t1\n+**  ...\n+**  vs8r.v\\tv24,0\\(sp\\)\n+**  ...\n+**  vl8re64.v\\tv16,0\\(sp\\)\n+**  vs8r.v\\tv16,0\\(a1\\)\n+**  ...\n+**  jr\\tra\n+*/\n+void\n+spill_14 (uint64_t *in, uint64_t *out)\n+{\n+  register vuint64m8_t v8 asm(\"v8\") = *(vuint64m8_t*)in; \n+  asm volatile (\"# %0\"::\"vr\"(v8)); \n+  exhaust_vector_regs (); \n+  register vuint64m8_t v16 asm(\"v16\") = v8; \n+  *(vuint64m8_t*)out = v16; \n+  asm volatile (\"# %0\"::\"vr\"(v16));\n+}"}, {"sha": "3c228a00c4886460f8eee6b435a6b6410620f9fc", "filename": "gcc/testsuite/gcc.target/riscv/rvv/base/spill-5.c", "status": "added", "additions": 130, "deletions": 0, "changes": 130, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5576518a5667ad826937125a19b7c59c34d8733c/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fbase%2Fspill-5.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5576518a5667ad826937125a19b7c59c34d8733c/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fbase%2Fspill-5.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fbase%2Fspill-5.c?ref=5576518a5667ad826937125a19b7c59c34d8733c", "patch": "@@ -0,0 +1,130 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-march=rv32gcv -mabi=ilp32 -mpreferred-stack-boundary=3 -O3 -fno-schedule-insns -fno-schedule-insns2\" } */\n+/* { dg-final { check-function-bodies \"**\" \"\" } } */\n+\n+#include \"riscv_vector.h\"\n+#include \"macro.h\"\n+\n+/*\n+** spill_3:\n+**  csrr\\tt0,vlenb\n+**  sub\\tsp,sp,t0\n+**  vsetvli\\ta5,zero,e32,mf2,ta,ma\n+**  vle32.v\\tv24,0\\(a0\\)\n+**  csrr\\ta3,vlenb\n+**  srli\\ta3,a3,1\n+**  add\\ta3,a3,sp\n+**  vse32.v\\tv24,0\\(a3\\)\n+**  ...\n+**  csrr\\ta3,vlenb\n+**  srli\\ta3,a3,1\n+**  add\\ta3,a3,sp\n+**  vle32.v\\tv24,0\\(a3\\)\n+**  vse32.v\\tv24,0\\(a1\\)\n+**  csrr\\tt0,vlenb\n+**  add\\tsp,sp,t0\n+**  ...\n+**  jr\\tra\n+*/\n+void\n+spill_3 (float *in, float *out)\n+{\n+  vfloat32mf2_t v1 = *(vfloat32mf2_t*)in;\n+  exhaust_vector_regs ();\n+  *(vfloat32mf2_t*)out = v1;\n+}\n+\n+/*\n+** spill_4:\n+**  csrr\\tt0,vlenb\n+**  sub\\tsp,sp,t0\n+**  ...\n+**  vs1r.v\\tv24,0\\(sp\\)\n+**  ...\n+**  vl1re32.v\\tv2,0\\(sp\\)\n+**  vs1r.v\\tv2,0\\(a1\\)\n+**  ...\n+**  jr\\tra\n+*/\n+void\n+spill_4 (float *in, float *out)\n+{\n+  register vfloat32m1_t v1 asm(\"v1\") = *(vfloat32m1_t*)in; \n+  asm volatile (\"# %0\"::\"vr\"(v1)); \n+  exhaust_vector_regs (); \n+  register vfloat32m1_t v2 asm(\"v2\") = v1; \n+  *(vfloat32m1_t*)out = v2; \n+  asm volatile (\"# %0\"::\"vr\"(v2));\n+}\n+\n+/*\n+** spill_5:\n+**  csrr\\tt0,vlenb\n+**  slli\\tt1,t0,1\n+**  sub\\tsp,sp,t1\n+**  ...\n+**  vs2r.v\\tv24,0\\(sp\\)\n+**  ...\n+**  vl2re32.v\\tv4,0\\(sp\\)\n+**  vs2r.v\\tv4,0\\(a1\\)\n+**  ...\n+**  jr\\tra\n+*/\n+void\n+spill_5 (float *in, float *out)\n+{\n+  register vfloat32m2_t v2 asm(\"v2\") = *(vfloat32m2_t*)in; \n+  asm volatile (\"# %0\"::\"vr\"(v2)); \n+  exhaust_vector_regs (); \n+  register vfloat32m2_t v4 asm(\"v4\") = v2; \n+  *(vfloat32m2_t*)out = v4; \n+  asm volatile (\"# %0\"::\"vr\"(v4));\n+}\n+\n+/*\n+** spill_6:\n+**  csrr\\tt0,vlenb\n+**  slli\\tt1,t0,2\n+**  sub\\tsp,sp,t1\n+**  ...\n+**  vs4r.v\\tv24,0\\(sp\\)\n+**  ...\n+**  vl4re32.v\\tv8,0\\(sp\\)\n+**  vs4r.v\\tv8,0\\(a1\\)\n+**  ...\n+**  jr\\tra\n+*/\n+void\n+spill_6 (float *in, float *out)\n+{\n+  register vfloat32m4_t v4 asm(\"v4\") = *(vfloat32m4_t*)in; \n+  asm volatile (\"# %0\"::\"vr\"(v4)); \n+  exhaust_vector_regs (); \n+  register vfloat32m4_t v8 asm(\"v8\") = v4; \n+  *(vfloat32m4_t*)out = v8; \n+  asm volatile (\"# %0\"::\"vr\"(v8));\n+}\n+\n+/*\n+** spill_7:\n+**  csrr\\tt0,vlenb\n+**  slli\\tt1,t0,3\n+**  sub\\tsp,sp,t1\n+**  ...\n+**  vs8r.v\\tv24,0\\(sp\\)\n+**  ...\n+**  vl8re32.v\\tv16,0\\(sp\\)\n+**  vs8r.v\\tv16,0\\(a1\\)\n+**  ...\n+**  jr\\tra\n+*/\n+void\n+spill_7 (float *in, float *out)\n+{\n+  register vfloat32m8_t v8 asm(\"v8\") = *(vfloat32m8_t*)in; \n+  asm volatile (\"# %0\"::\"vr\"(v8)); \n+  exhaust_vector_regs (); \n+  register vfloat32m8_t v16 asm(\"v16\") = v8; \n+  *(vfloat32m8_t*)out = v16; \n+  asm volatile (\"# %0\"::\"vr\"(v16));\n+}"}, {"sha": "340029da88b277155980405d2c22993258e34942", "filename": "gcc/testsuite/gcc.target/riscv/rvv/base/spill-6.c", "status": "added", "additions": 101, "deletions": 0, "changes": 101, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5576518a5667ad826937125a19b7c59c34d8733c/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fbase%2Fspill-6.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5576518a5667ad826937125a19b7c59c34d8733c/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fbase%2Fspill-6.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fbase%2Fspill-6.c?ref=5576518a5667ad826937125a19b7c59c34d8733c", "patch": "@@ -0,0 +1,101 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-march=rv32gcv -mabi=ilp32 -mpreferred-stack-boundary=3 -O3 -fno-schedule-insns -fno-schedule-insns2\" } */\n+/* { dg-final { check-function-bodies \"**\" \"\" } } */\n+\n+#include \"riscv_vector.h\"\n+#include \"macro.h\"\n+\n+/*\n+** spill_4:\n+**  csrr\\tt0,vlenb\n+**  sub\\tsp,sp,t0\n+**  ...\n+**  vs1r.v\\tv24,0\\(sp\\)\n+**  ...\n+**  vl1re64.v\\tv2,0\\(sp\\)\n+**  vs1r.v\\tv2,0\\(a1\\)\n+**  ...\n+**  jr\\tra\n+*/\n+void\n+spill_4 (double *in, double *out)\n+{\n+  register vfloat64m1_t v1 asm(\"v1\") = *(vfloat64m1_t*)in; \n+  asm volatile (\"# %0\"::\"vr\"(v1)); \n+  exhaust_vector_regs (); \n+  register vfloat64m1_t v2 asm(\"v2\") = v1; \n+  *(vfloat64m1_t*)out = v2; \n+  asm volatile (\"# %0\"::\"vr\"(v2));\n+}\n+\n+/*\n+** spill_5:\n+**  csrr\\tt0,vlenb\n+**  slli\\tt1,t0,1\n+**  sub\\tsp,sp,t1\n+**  ...\n+**  vs2r.v\\tv24,0\\(sp\\)\n+**  ...\n+**  vl2re64.v\\tv4,0\\(sp\\)\n+**  vs2r.v\\tv4,0\\(a1\\)\n+**  ...\n+**  jr\\tra\n+*/\n+void\n+spill_5 (double *in, double *out)\n+{\n+  register vfloat64m2_t v2 asm(\"v2\") = *(vfloat64m2_t*)in; \n+  asm volatile (\"# %0\"::\"vr\"(v2)); \n+  exhaust_vector_regs (); \n+  register vfloat64m2_t v4 asm(\"v4\") = v2; \n+  *(vfloat64m2_t*)out = v4; \n+  asm volatile (\"# %0\"::\"vr\"(v4));\n+}\n+\n+/*\n+** spill_6:\n+**  csrr\\tt0,vlenb\n+**  slli\\tt1,t0,2\n+**  sub\\tsp,sp,t1\n+**  ...\n+**  vs4r.v\\tv24,0\\(sp\\)\n+**  ...\n+**  vl4re64.v\\tv8,0\\(sp\\)\n+**  vs4r.v\\tv8,0\\(a1\\)\n+**  ...\n+**  jr\\tra\n+*/\n+void\n+spill_6 (double *in, double *out)\n+{\n+  register vfloat64m4_t v4 asm(\"v4\") = *(vfloat64m4_t*)in; \n+  asm volatile (\"# %0\"::\"vr\"(v4)); \n+  exhaust_vector_regs (); \n+  register vfloat64m4_t v8 asm(\"v8\") = v4; \n+  *(vfloat64m4_t*)out = v8; \n+  asm volatile (\"# %0\"::\"vr\"(v8));\n+}\n+\n+/*\n+** spill_7:\n+**  csrr\\tt0,vlenb\n+**  slli\\tt1,t0,3\n+**  sub\\tsp,sp,t1\n+**  ...\n+**  vs8r.v\\tv24,0\\(sp\\)\n+**  ...\n+**  vl8re64.v\\tv16,0\\(sp\\)\n+**  vs8r.v\\tv16,0\\(a1\\)\n+**  ...\n+**  jr\\tra\n+*/\n+void\n+spill_7 (double *in, double *out)\n+{\n+  register vfloat64m8_t v8 asm(\"v8\") = *(vfloat64m8_t*)in; \n+  asm volatile (\"# %0\"::\"vr\"(v8)); \n+  exhaust_vector_regs (); \n+  register vfloat64m8_t v16 asm(\"v16\") = v8; \n+  *(vfloat64m8_t*)out = v16; \n+  asm volatile (\"# %0\"::\"vr\"(v16));\n+}"}, {"sha": "cf1eea2fa3fc967c4e401bca1759a03825bb408c", "filename": "gcc/testsuite/gcc.target/riscv/rvv/base/spill-7.c", "status": "added", "additions": 114, "deletions": 0, "changes": 114, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5576518a5667ad826937125a19b7c59c34d8733c/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fbase%2Fspill-7.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5576518a5667ad826937125a19b7c59c34d8733c/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fbase%2Fspill-7.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fbase%2Fspill-7.c?ref=5576518a5667ad826937125a19b7c59c34d8733c", "patch": "@@ -0,0 +1,114 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-march=rv32gcv -mabi=ilp32 -mpreferred-stack-boundary=3 -O3 -fno-schedule-insns -fno-schedule-insns2\" } */\n+/* { dg-final { check-function-bodies \"**\" \"\" } } */\n+\n+#include \"riscv_vector.h\"\n+#include \"macro.h\"\n+\n+/*\n+** spill:\n+**  csrr\\tt0,vlenb\n+**  slli\\tt1,t0,4\n+**  sub\\tsp,sp,t1\n+**  vsetvli\\ta3,zero,e8,mf8,ta,ma\n+**  vle8.v\\tv24,0\\(a0\\)\n+**  csrr\\ta5,vlenb\n+**  srli\\ta5,a5,3\n+**  add\\ta5,a5,sp\n+**  vse8.v\\tv24,0\\(a5\\)\n+**  addi\\ta5,a0,1\n+**  vsetvli\\ta4,zero,e8,mf4,ta,ma\n+**  vle8.v\\tv24,0\\(a5\\)\n+**  csrr\\ta5,vlenb\n+**  srli\\ta5,a5,2\n+**  add\\ta5,a5,sp\n+**  vse8.v\\tv24,0\\(a5\\)\n+**  addi\\ta2,a0,2\n+**  vsetvli\\ta5,zero,e8,mf2,ta,ma\n+**  vle8.v\\tv24,0\\(a2\\)\n+**  csrr\\ta2,vlenb\n+**  srli\\ta2,a2,1\n+**  add\\ta2,a2,sp\n+**  vse8.v\\tv24,0\\(a2\\)\n+**  addi\\ta2,a0,3\n+**  vl1re8.v\\tv24,0\\(a2\\)\n+**  csrr\\ta2,vlenb\n+**  add\\ta2,a2,sp\n+**  vs1r.v\\tv24,0\\(a2\\)\n+**  addi\\ta2,a0,4\n+**  vl2re8.v\\tv24,0\\(a2\\)\n+**  csrr\\tt3,vlenb\n+**  slli\\ta2,t3,1\n+**  add\\ta2,a2,sp\n+**  vs2r.v\\tv24,0\\(a2\\)\n+**  addi\\ta2,a0,5\n+**  vl4re8.v\\tv24,0\\(a2\\)\n+**  mv\\ta2,t3\n+**  slli\\tt3,t3,2\n+**  add\\tt3,t3,sp\n+**  vs4r.v\\tv24,0\\(t3\\)\n+**  addi\\ta0,a0,6\n+**  vl8re8.v\\tv24,0\\(a0\\)\n+**  slli\\ta0,a2,3\n+**  add\\ta0,a0,sp\n+**  vs8r.v\\tv24,0\\(a0\\)\n+**  ...\n+**  srli\\ta0,a2,3\n+**  add\\ta0,a0,sp\n+**  ...\n+**  vle8.v\\tv27,0\\(a0\\)\n+**  vse8.v\\tv27,0\\(a1\\)\n+**  addi\\ta3,a1,1\n+**  srli\\ta0,a2,2\n+**  add\\ta0,a0,sp\n+**  ...\n+**  vle8.v\\tv27,0\\(a0\\)\n+**  vse8.v\\tv27,0\\(a3\\)\n+**  addi\\ta4,a1,2\n+**  srli\\ta3,a2,1\n+**  add\\ta3,a3,sp\n+**  ...\n+**  vle8.v\\tv27,0\\(a3\\)\n+**  vse8.v\\tv27,0\\(a4\\)\n+**  addi\\ta5,a1,3\n+**  add\\ta4,a2,sp\n+**  vl1re8.v\\tv25,0\\(a4\\)\n+**  vs1r.v\\tv25,0\\(a5\\)\n+**  addi\\ta5,a1,4\n+**  slli\\ta4,a2,1\n+**  add\\ta4,a4,sp\n+**  vl2re8.v\\tv26,0\\(a4\\)\n+**  vs2r.v\\tv26,0\\(a5\\)\n+**  addi\\ta5,a1,5\n+**  vl4re8.v\\tv28,0\\(t3\\)\n+**  vs4r.v\\tv28,0\\(a5\\)\n+**  addi\\ta1,a1,6\n+**  slli\\ta5,a2,3\n+**  add\\ta5,a5,sp\n+**  vl8re8.v\\tv24,0\\(a5\\)\n+**  vs8r.v\\tv24,0\\(a1\\)\n+**  csrr\\tt0,vlenb\n+**  slli\\tt1,t0,4\n+**  add\\tsp,sp,t1\n+**  ...\n+**  jr\\tra\n+*/\n+void\n+spill (int8_t *in, int8_t *out)\n+{\n+  vint8mf8_t v0 = *(vint8mf8_t*)in;\n+  vint8mf4_t v1 = *(vint8mf4_t*)(in + 1);\n+  vint8mf2_t v2 = *(vint8mf2_t*)(in + 2);\n+  vint8m1_t v3 = *(vint8m1_t*)(in + 3);\n+  vint8m2_t v4 = *(vint8m2_t*)(in + 4);\n+  vint8m4_t v8 = *(vint8m4_t*)(in + 5);\n+  vint8m8_t v16 = *(vint8m8_t*)(in + 6);\n+  exhaust_vector_regs (); \n+  *(vint8mf8_t*)out = v0;\n+  *(vint8mf4_t*)(out + 1) = v1; \n+  *(vint8mf2_t*)(out + 2) = v2;\n+  *(vint8m1_t*)(out + 3) = v3;\n+  *(vint8m2_t*)(out + 4) = v4;\n+  *(vint8m4_t*)(out + 5) = v8;\n+  *(vint8m8_t*)(out + 6) = v16;\n+}"}, {"sha": "ddc36e888eb493e1e988a3f794eb82e619551da6", "filename": "gcc/testsuite/gcc.target/riscv/rvv/base/spill-8.c", "status": "added", "additions": 51, "deletions": 0, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5576518a5667ad826937125a19b7c59c34d8733c/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fbase%2Fspill-8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5576518a5667ad826937125a19b7c59c34d8733c/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fbase%2Fspill-8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fbase%2Fspill-8.c?ref=5576518a5667ad826937125a19b7c59c34d8733c", "patch": "@@ -0,0 +1,51 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-march=rv32gcv -mabi=ilp32 -fno-schedule-insns -fno-schedule-insns2 -O3\" } */\n+/* { dg-final { check-function-bodies \"**\" \"\" } } */\n+\n+void f2 (char*);\n+void f3 (char*, ...);\n+\n+/*\n+** stach_check_alloca_1:\n+**\taddi\tsp,sp,-48\n+**\tsw\tra,12\\(sp\\)\n+**\tsw\ts0,8\\(sp\\)\n+**\taddi\ts0,sp,16\n+**\t...\n+**\taddi\ta0,a0,23\n+**\tandi\ta0,a0,-16\n+**\tsub\tsp,sp,a0\n+**\t...\n+**\taddi\tsp,s0,-16\n+**\tlw\tra,12\\(sp\\)\n+**\tlw\ts0,8\\(sp\\)\n+**\taddi\tsp,sp,48\n+**\tjr\tra\n+*/\n+void stach_check_alloca_1 (int y, ...)\n+{\n+  char* pStr = (char*)__builtin_alloca(y);\n+  f2(pStr);\n+}\n+\n+/*\n+** stach_check_alloca_2:\n+**\taddi\tsp,sp,-48\n+**\tsw\tra,44\\(sp\\)\n+**\tsw\ts0,40\\(sp\\)\n+**\taddi\ts0,sp,48\n+**\taddi\ta0,a0,23\n+**\tandi\ta0,a0,-16\n+**\tsub\tsp,sp,a0\n+**\t...\n+**\taddi\tsp,s0,-48\n+**\tlw\tra,44\\(sp\\)\n+**\tlw\ts0,40\\(sp\\)\n+**\taddi\tsp,sp,48\n+**\tjr\tra\n+*/\n+void stach_check_alloca_2 (int y)\n+{\n+  char* pStr = (char*)__builtin_alloca(y);\n+  f3(pStr, pStr, pStr, pStr, pStr, pStr, pStr, pStr, 2, pStr, pStr, pStr, 1);\n+}"}, {"sha": "7111113d393a7553d6fb054810ae925836a572d4", "filename": "gcc/testsuite/gcc.target/riscv/rvv/base/spill-9.c", "status": "added", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5576518a5667ad826937125a19b7c59c34d8733c/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fbase%2Fspill-9.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5576518a5667ad826937125a19b7c59c34d8733c/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fbase%2Fspill-9.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fbase%2Fspill-9.c?ref=5576518a5667ad826937125a19b7c59c34d8733c", "patch": "@@ -0,0 +1,42 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-march=rv32gcv -mabi=ilp32 -fno-schedule-insns -fno-schedule-insns2 -O3\" } */\n+/* { dg-final { check-function-bodies \"**\" \"\" } } */\n+\n+#include \"riscv_vector.h\"\n+\n+void f (char*);\n+\n+/*\n+** stach_check_alloca_1:\n+**\taddi\\tsp,sp,-48\n+**\tsw\\tra,12\\(sp\\)\n+**\tsw\\ts0,8\\(sp\\)\n+**\taddi\\ts0,sp,16\n+**\tcsrr\\tt0,vlenb\n+**\tslli\\tt1,t0,1\n+**\tsub\\tsp,sp,t1\n+**\t...\n+**\taddi\\ta2,a2,23\n+**\tandi\\ta2,a2,-16\n+**\tsub\\tsp,sp,a2\n+**\t...\n+**\tlw\\tra,12\\(sp\\)\n+**\tlw\\ts0,8\\(sp\\)\n+**\taddi\\tsp,sp,48\n+**\tjr\\tra\n+*/\n+void stach_check_alloca_1 (vuint8m1_t data, uint8_t *base, int y, ...)\n+{\n+  vuint8m8_t v0, v8, v16, v24;\n+  asm volatile (\"nop\"\n+                : \"=vr\" (v0), \"=vr\" (v8), \"=vr\" (v16), \"=vr\" (v24)\n+                :\n+                :);\n+  asm volatile (\"nop\"\n+                :\n+                : \"vr\" (v0), \"vr\" (v8), \"vr\" (v16), \"vr\" (v24)\n+                :);\n+  *(vuint8m1_t *)base = data;\n+  char* pStr = (char*)__builtin_alloca(y);\n+  f(pStr);\n+}"}]}