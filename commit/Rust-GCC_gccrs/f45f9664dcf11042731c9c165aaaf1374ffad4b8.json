{"sha": "f45f9664dcf11042731c9c165aaaf1374ffad4b8", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjQ1Zjk2NjRkY2YxMTA0MjczMWM5YzE2NWFhYWYxMzc0ZmZhZDRiOA==", "commit": {"author": {"name": "Eric Botcazou", "email": "ebotcazou@adacore.com", "date": "2009-06-26T08:54:26Z"}, "committer": {"name": "Eric Botcazou", "email": "ebotcazou@gcc.gnu.org", "date": "2009-06-26T08:54:26Z"}, "message": "decl.c (cannot_be_superflat_p): New predicate.\n\n\t* gcc-interface/decl.c (cannot_be_superflat_p): New predicate.\n\t(gnat_to_gnu_entity) <E_Array_Subtype>: Use it to build the expression\n\tof the upper bound of the index types.\n\nFrom-SVN: r148966", "tree": {"sha": "c5d31602694fa4c3558cefaee6e8b57845307622", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c5d31602694fa4c3558cefaee6e8b57845307622"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f45f9664dcf11042731c9c165aaaf1374ffad4b8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f45f9664dcf11042731c9c165aaaf1374ffad4b8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f45f9664dcf11042731c9c165aaaf1374ffad4b8", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f45f9664dcf11042731c9c165aaaf1374ffad4b8/comments", "author": null, "committer": null, "parents": [{"sha": "bcade3954a00a9964783f5ed74be2e2e1991eb41", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bcade3954a00a9964783f5ed74be2e2e1991eb41", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bcade3954a00a9964783f5ed74be2e2e1991eb41"}], "stats": {"total": 101, "additions": 89, "deletions": 12}, "files": [{"sha": "bf1d3c67afc65f72679044100df74545680e3e06", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f45f9664dcf11042731c9c165aaaf1374ffad4b8/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f45f9664dcf11042731c9c165aaaf1374ffad4b8/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=f45f9664dcf11042731c9c165aaaf1374ffad4b8", "patch": "@@ -1,3 +1,9 @@\n+2009-06-26  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\t* gcc-interface/decl.c (cannot_be_superflat_p): New predicate.\n+\t(gnat_to_gnu_entity) <E_Array_Subtype>: Use it to build the expression\n+\tof the upper bound of the index types.\n+\n 2009-06-26  Eric Botcazou  <ebotcazou@adacore.com>\n \n \t* gcc-interface/decl.c (gnat_to_gnu_entity) <E_Array_Subtype>: Factor"}, {"sha": "b4e3a4ee2ef4293ce9be21850e7cf719a18ca43a", "filename": "gcc/ada/gcc-interface/decl.c", "status": "modified", "additions": 56, "deletions": 12, "changes": 68, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f45f9664dcf11042731c9c165aaaf1374ffad4b8/gcc%2Fada%2Fgcc-interface%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f45f9664dcf11042731c9c165aaaf1374ffad4b8/gcc%2Fada%2Fgcc-interface%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Fdecl.c?ref=f45f9664dcf11042731c9c165aaaf1374ffad4b8", "patch": "@@ -136,6 +136,7 @@ static tree gnat_to_gnu_param (Entity_Id, Mechanism_Type, Entity_Id, bool,\n static bool same_discriminant_p (Entity_Id, Entity_Id);\n static bool array_type_has_nonaliased_component (Entity_Id, tree);\n static bool compile_time_known_address_p (Node_Id);\n+static bool cannot_be_superflat_p (Node_Id);\n static void components_to_record (tree, Node_Id, tree, int, bool, tree *,\n \t\t\t\t  bool, bool, bool, bool);\n static Uint annotate_value (tree);\n@@ -2202,22 +2203,27 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t\t  gnu_high = gnu_max;\n \t\t}\n \n+\t      /* Compute the size of this dimension in the general case.  We\n+\t\t need to provide GCC with an upper bound to use but have to\n+\t\t deal with the \"superflat\" case.  There are three ways to do\n+\t\t this.  If we can prove that the array can never be superflat,\n+\t\t we can just use the high bound of the index type.  */\n+\t      else if (Nkind (gnat_index) == N_Range\n+\t\t       && cannot_be_superflat_p (gnat_index))\n+\t\tgnu_high = gnu_max;\n+\n+\t      /* Otherwise, if we can prove that the low bound minus one and\n+\t\t the high bound cannot overflow, we can just use the expression\n+\t\t MAX (hb, lb - 1).  Otherwise, we have to use the most general\n+\t\t expression (hb >= lb) ? hb : lb - 1.  Note that the comparison\n+\t\t must be done in the original index type, to avoid any overflow\n+\t\t during the conversion.  */\n \t      else\n \t\t{\n-\t\t  /* Now compute the size of this bound.  We need to provide\n-\t\t     GCC with an upper bound to use but have to deal with the\n-\t\t     \"superflat\" case.  There are three ways to do this.  If\n-\t\t     we can prove that the array can never be superflat, we\n-\t\t     can just use the high bound of the index subtype.  If we\n-\t\t     can prove that the low bound minus one and the high bound\n-\t\t     can't overflow, we can do this as MAX (hb, lb - 1).  But,\n-\t\t     otherwise, we have to use (hb >= lb) ? hb : lb - 1.  Note\n-\t\t     that the comparison must be done in the original index\n-\t\t     type, to avoid any overflow during the conversion.  */\n \t\t  gnu_high = size_binop (MINUS_EXPR, gnu_min, size_one_node);\n \n-\t\t  /* If gnu_high is a constant that has overflowed, the array\n-\t\t     cannot be superflat.  */\n+\t\t  /* If gnu_high is a constant that has overflowed, the bound\n+\t\t     is the smallest integer so cannot be the maximum.  */\n \t\t  if (TREE_CODE (gnu_high) == INTEGER_CST\n \t\t      && TREE_OVERFLOW (gnu_high))\n \t\t    gnu_high = gnu_max;\n@@ -5304,6 +5310,44 @@ compile_time_known_address_p (Node_Id gnat_address)\n \n   return Compile_Time_Known_Value (gnat_address);\n }\n+\n+/* Return true if GNAT_RANGE, a N_Range node, cannot be superflat, i.e.\n+   cannot verify HB < LB-1 when LB and HB are the low and high bounds.  */\n+\n+static bool\n+cannot_be_superflat_p (Node_Id gnat_range)\n+{\n+  Node_Id gnat_lb = Low_Bound (gnat_range), gnat_hb = High_Bound (gnat_range);\n+  tree gnu_lb, gnu_hb;\n+\n+  /* If the low bound is not constant, try to find an upper bound.  */\n+  while (Nkind (gnat_lb) != N_Integer_Literal\n+\t && (Ekind (Etype (gnat_lb)) == E_Signed_Integer_Subtype\n+\t     || Ekind (Etype (gnat_lb)) == E_Modular_Integer_Subtype)\n+\t && Nkind (Scalar_Range (Etype (gnat_lb))) == N_Range)\n+    gnat_lb = High_Bound (Scalar_Range (Etype (gnat_lb)));\n+\n+  /* If the high bound is not constant, try to find a lower bound.  */\n+  while (Nkind (gnat_hb) != N_Integer_Literal\n+\t && (Ekind (Etype (gnat_hb)) == E_Signed_Integer_Subtype\n+\t     || Ekind (Etype (gnat_hb)) == E_Modular_Integer_Subtype)\n+\t && Nkind (Scalar_Range (Etype (gnat_hb))) == N_Range)\n+    gnat_hb = Low_Bound (Scalar_Range (Etype (gnat_hb)));\n+\n+  if (!(Nkind (gnat_lb) == N_Integer_Literal\n+\t&& Nkind (gnat_hb) == N_Integer_Literal))\n+    return false;\n+\n+  gnu_lb = UI_To_gnu (Intval (gnat_lb), bitsizetype);\n+  gnu_hb = UI_To_gnu (Intval (gnat_hb), bitsizetype);\n+\n+  /* If the low bound is the smallest integer, nothing can be smaller.  */\n+  gnu_lb = size_binop (MINUS_EXPR, gnu_lb, bitsize_one_node);\n+  if (TREE_OVERFLOW (gnu_lb))\n+    return true;\n+\n+  return (tree_int_cst_lt (gnu_hb, gnu_lb) == 0);\n+}\n \f\n /* Given GNAT_ENTITY, elaborate all expressions that are required to\n    be elaborated at the point of its definition, but do nothing else.  */"}, {"sha": "047981de962d56ba2b8c5ce8eb3735188eec2c4c", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f45f9664dcf11042731c9c165aaaf1374ffad4b8/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f45f9664dcf11042731c9c165aaaf1374ffad4b8/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=f45f9664dcf11042731c9c165aaaf1374ffad4b8", "patch": "@@ -1,3 +1,7 @@\n+2009-06-26  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\t* gnat.dg/array7.ad[sb]: New test.\n+\n 2009-06-26  Eric Botcazou  <ebotcazou@adacore.com>\n \n \t* gnat.dg/array6.adb: New test."}, {"sha": "ff4e9e48857718685529530937ea64efbbf787b9", "filename": "gcc/testsuite/gnat.dg/array7.adb", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f45f9664dcf11042731c9c165aaaf1374ffad4b8/gcc%2Ftestsuite%2Fgnat.dg%2Farray7.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f45f9664dcf11042731c9c165aaaf1374ffad4b8/gcc%2Ftestsuite%2Fgnat.dg%2Farray7.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgnat.dg%2Farray7.adb?ref=f45f9664dcf11042731c9c165aaaf1374ffad4b8", "patch": "@@ -0,0 +1,13 @@\n+-- { dg-do compile }\n+-- { dg-options \"-O -gnatp -fdump-tree-optimized\" }\n+\n+package body Array7 is\n+\n+   function Get_Arr (Nbr : My_Range) return Arr_Acc is\n+   begin\n+      return new Arr (1 .. Nbr);\n+   end;\n+\n+end Array7;\n+\n+-- { dg-final { scan-tree-dump-not \"MAX_EXPR\" \"optimized\" } }"}, {"sha": "b47a1b6318e112a756c89d2c4c637dd4d7a6473b", "filename": "gcc/testsuite/gnat.dg/array7.ads", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f45f9664dcf11042731c9c165aaaf1374ffad4b8/gcc%2Ftestsuite%2Fgnat.dg%2Farray7.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f45f9664dcf11042731c9c165aaaf1374ffad4b8/gcc%2Ftestsuite%2Fgnat.dg%2Farray7.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgnat.dg%2Farray7.ads?ref=f45f9664dcf11042731c9c165aaaf1374ffad4b8", "patch": "@@ -0,0 +1,10 @@\n+package Array7 is\n+\n+   type Arr is array (Positive range <>) of Integer;\n+   type Arr_Acc is access Arr;\n+\n+   subtype My_Range is Integer range 1 .. 25;\n+\n+   function Get_Arr (Nbr : My_Range) return Arr_Acc;\n+\n+end Array7;"}]}