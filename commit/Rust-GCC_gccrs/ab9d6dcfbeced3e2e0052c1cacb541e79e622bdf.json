{"sha": "ab9d6dcfbeced3e2e0052c1cacb541e79e622bdf", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YWI5ZDZkY2ZiZWNlZDNlMmUwMDUyYzFjYWNiNTQxZTc5ZTYyMmJkZg==", "commit": {"author": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2010-12-24T01:26:14Z"}, "committer": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2010-12-24T01:26:14Z"}, "message": "Avoid endless loop on array with recursive length.\n\nFrom-SVN: r168223", "tree": {"sha": "7d62e153325fc825945f9edfd0e6316eb47bf1f5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/7d62e153325fc825945f9edfd0e6316eb47bf1f5"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ab9d6dcfbeced3e2e0052c1cacb541e79e622bdf", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ab9d6dcfbeced3e2e0052c1cacb541e79e622bdf", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ab9d6dcfbeced3e2e0052c1cacb541e79e622bdf", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ab9d6dcfbeced3e2e0052c1cacb541e79e622bdf/comments", "author": null, "committer": null, "parents": [{"sha": "3746f0c781beee40cd72fccfe88357bc16ffe1f9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3746f0c781beee40cd72fccfe88357bc16ffe1f9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3746f0c781beee40cd72fccfe88357bc16ffe1f9"}], "stats": {"total": 58, "additions": 52, "deletions": 6}, "files": [{"sha": "f64e5ee4edf52804bf6c74f8847d1eb5db4f80d3", "filename": "gcc/go/gofrontend/expressions.cc", "status": "modified", "additions": 52, "deletions": 6, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ab9d6dcfbeced3e2e0052c1cacb541e79e622bdf/gcc%2Fgo%2Fgofrontend%2Fexpressions.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ab9d6dcfbeced3e2e0052c1cacb541e79e622bdf/gcc%2Fgo%2Fgofrontend%2Fexpressions.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fexpressions.cc?ref=ab9d6dcfbeced3e2e0052c1cacb541e79e622bdf", "patch": "@@ -6463,6 +6463,9 @@ class Builtin_call_expression : public Call_expression\n   Gogo* gogo_;\n   // The builtin function being called.\n   Builtin_function_code code_;\n+  // Used to stop endless loops when the length of an array uses len\n+  // or cap of the array itself.\n+  mutable bool seen_;\n };\n \n Builtin_call_expression::Builtin_call_expression(Gogo* gogo,\n@@ -6471,7 +6474,7 @@ Builtin_call_expression::Builtin_call_expression(Gogo* gogo,\n \t\t\t\t\t\t bool is_varargs,\n \t\t\t\t\t\t source_location location)\n   : Call_expression(fn, args, is_varargs, location),\n-    gogo_(gogo), code_(BUILTIN_INVALID)\n+    gogo_(gogo), code_(BUILTIN_INVALID), seen_(false)\n {\n   Func_expression* fnexp = this->fn()->func_expression();\n   gcc_assert(fnexp != NULL);\n@@ -6781,6 +6784,9 @@ Builtin_call_expression::do_is_constant() const\n     case BUILTIN_LEN:\n     case BUILTIN_CAP:\n       {\n+\tif (this->seen_)\n+\t  return false;\n+\n \tExpression* arg = this->one_arg();\n \tif (arg == NULL)\n \t  return false;\n@@ -6793,10 +6799,15 @@ Builtin_call_expression::do_is_constant() const\n \n \tif (arg_type->array_type() != NULL\n \t    && arg_type->array_type()->length() != NULL)\n-\t  return arg_type->array_type()->length()->is_constant();\n+\t  return true;\n \n \tif (this->code_ == BUILTIN_LEN && arg_type->is_string_type())\n-\t  return arg->is_constant();\n+\t  {\n+\t    this->seen_ = true;\n+\t    bool ret = arg->is_constant();\n+\t    this->seen_ = false;\n+\t    return ret;\n+\t  }\n       }\n       break;\n \n@@ -6868,8 +6879,13 @@ Builtin_call_expression::do_integer_constant_value(bool iota_is_constant,\n       if (arg_type->array_type() != NULL\n \t  && arg_type->array_type()->length() != NULL)\n \t{\n+\t  if (this->seen_)\n+\t    return false;\n \t  Expression* e = arg_type->array_type()->length();\n-\t  if (e->integer_constant_value(iota_is_constant, val, ptype))\n+\t  this->seen_ = true;\n+\t  bool r = e->integer_constant_value(iota_is_constant, val, ptype);\n+\t  this->seen_ = false;\n+\t  if (r)\n \t    {\n \t      *ptype = Type::lookup_integer_type(\"int\");\n \t      return true;\n@@ -7484,7 +7500,18 @@ Builtin_call_expression::do_get_tree(Translate_context* context)\n \tgcc_assert(args != NULL && args->size() == 1);\n \tExpression* arg = *args->begin();\n \tType* arg_type = arg->type();\n+\n+\tif (this->seen_)\n+\t  {\n+\t    gcc_assert(saw_errors());\n+\t    return error_mark_node;\n+\t  }\n+\tthis->seen_ = true;\n+\n \ttree arg_tree = arg->get_tree(context);\n+\n+\tthis->seen_ = false;\n+\n \tif (arg_tree == error_mark_node)\n \t  return error_mark_node;\n \n@@ -7503,7 +7530,16 @@ Builtin_call_expression::do_get_tree(Translate_context* context)\n \t    if (arg_type->is_string_type())\n \t      val_tree = String_type::length_tree(gogo, arg_tree);\n \t    else if (arg_type->array_type() != NULL)\n-\t      val_tree = arg_type->array_type()->length_tree(gogo, arg_tree);\n+\t      {\n+\t\tif (this->seen_)\n+\t\t  {\n+\t\t    gcc_assert(saw_errors());\n+\t\t    return error_mark_node;\n+\t\t  }\n+\t\tthis->seen_ = true;\n+\t\tval_tree = arg_type->array_type()->length_tree(gogo, arg_tree);\n+\t\tthis->seen_ = false;\n+\t      }\n \t    else if (arg_type->map_type() != NULL)\n \t      {\n \t\tstatic tree map_len_fndecl;\n@@ -7532,7 +7568,17 @@ Builtin_call_expression::do_get_tree(Translate_context* context)\n \telse\n \t  {\n \t    if (arg_type->array_type() != NULL)\n-\t      val_tree = arg_type->array_type()->capacity_tree(gogo, arg_tree);\n+\t      {\n+\t\tif (this->seen_)\n+\t\t  {\n+\t\t    gcc_assert(saw_errors());\n+\t\t    return error_mark_node;\n+\t\t  }\n+\t\tthis->seen_ = true;\n+\t\tval_tree = arg_type->array_type()->capacity_tree(gogo,\n+\t\t\t\t\t\t\t\t arg_tree);\n+\t\tthis->seen_ = false;\n+\t      }\n \t    else if (arg_type->channel_type() != NULL)\n \t      {\n \t\tstatic tree chan_cap_fndecl;"}]}