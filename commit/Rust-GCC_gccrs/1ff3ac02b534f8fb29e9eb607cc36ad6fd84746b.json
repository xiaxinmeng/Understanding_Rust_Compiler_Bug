{"sha": "1ff3ac02b534f8fb29e9eb607cc36ad6fd84746b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MWZmM2FjMDJiNTM0ZjhmYjI5ZTllYjYwN2NjMzZhZDZmZDg0NzQ2Yg==", "commit": {"author": {"name": "Richard Sandiford", "email": "richard@codesourcery.com", "date": "2006-05-22T15:58:03Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2006-05-22T15:58:03Z"}, "message": "re PR rtl-optimization/25514 (internal consistency failure)\n\n\tPR rtl-optimization/25514\n\t* combine.c (replaced_rhs_insn): New variable.\n\t(combine_instructions): Set replaced_rhs_insn when trying to replace\n\ta SET_SRC with a REG_EQUAL note.\n\t(distribute_notes): Use replaced_rhs_insn when determining the live\n\trange of a REG_DEAD register.\n\ngcc/testsute\n\t* gcc.c-torture/compile/pr25514.c: New test.\n\nFrom-SVN: r113983", "tree": {"sha": "1b43b83f68f5f180323cec80a8a5d5feb8ce778d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1b43b83f68f5f180323cec80a8a5d5feb8ce778d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/1ff3ac02b534f8fb29e9eb607cc36ad6fd84746b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1ff3ac02b534f8fb29e9eb607cc36ad6fd84746b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1ff3ac02b534f8fb29e9eb607cc36ad6fd84746b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1ff3ac02b534f8fb29e9eb607cc36ad6fd84746b/comments", "author": null, "committer": null, "parents": [{"sha": "8c21550d5b849e6b38a88d8b1c3668a169dec5fd", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8c21550d5b849e6b38a88d8b1c3668a169dec5fd", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8c21550d5b849e6b38a88d8b1c3668a169dec5fd"}], "stats": {"total": 109, "additions": 73, "deletions": 36}, "files": [{"sha": "e1e61a5e2f16e3a0d0666156eab4dd9794482983", "filename": "gcc/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1ff3ac02b534f8fb29e9eb607cc36ad6fd84746b/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1ff3ac02b534f8fb29e9eb607cc36ad6fd84746b/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=1ff3ac02b534f8fb29e9eb607cc36ad6fd84746b", "patch": "@@ -1,3 +1,12 @@\n+2006-05-22  Richard Sandiford  <richard@codesourcery.com>\n+\n+\tPR rtl-optimization/25514\n+\t* combine.c (replaced_rhs_insn): New variable.\n+\t(combine_instructions): Set replaced_rhs_insn when trying to replace\n+\ta SET_SRC with a REG_EQUAL note.\n+\t(distribute_notes): Use replaced_rhs_insn when determining the live\n+\trange of a REG_DEAD register.\n+\n 2006-18-05  Joerg Wunsch <j.gnu@uriah.heep.sax.de>\n             Anatoly Sokolov <aesok@post.ru>\n "}, {"sha": "4d71b6d31b65d6e6d69c9a392a4807712c17e0f6", "filename": "gcc/combine.c", "status": "modified", "additions": 35, "deletions": 36, "changes": 71, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1ff3ac02b534f8fb29e9eb607cc36ad6fd84746b/gcc%2Fcombine.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1ff3ac02b534f8fb29e9eb607cc36ad6fd84746b/gcc%2Fcombine.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcombine.c?ref=1ff3ac02b534f8fb29e9eb607cc36ad6fd84746b", "patch": "@@ -123,6 +123,11 @@ static int combine_successes;\n \n static int total_attempts, total_merges, total_extras, total_successes;\n \n+/* Sometimes combine tries to replace the right hand side of an insn\n+   with the value of a REG_EQUAL note.  This is the insn that has been\n+   so modified, or null if none.  */\n+\n+static rtx replaced_rhs_insn;\n \f\n /* Vector mapping INSN_UIDs to cuids.\n    The cuids are like uids but increase monotonically always.\n@@ -922,8 +927,10 @@ combine_instructions (rtx f, unsigned int nregs)\n \t\t\t be deleted or recognized by try_combine.  */\n \t\t      rtx orig = SET_SRC (set);\n \t\t      SET_SRC (set) = note;\n+\t\t      replaced_rhs_insn = temp;\n \t\t      next = try_combine (insn, temp, NULL_RTX,\n \t\t\t\t\t  &new_direct_jump_p);\n+\t\t      replaced_rhs_insn = NULL;\n \t\t      if (next)\n \t\t\tgoto retry;\n \t\t      SET_SRC (set) = orig;\n@@ -12093,7 +12100,15 @@ distribute_notes (rtx notes, rtx from_insn, rtx i3, rtx i2, rtx elim_i2,\n \t  break;\n \n \tcase REG_DEAD:\n-\t  /* If the register is used as an input in I3, it dies there.\n+\t  /* If we replaced the right hand side of FROM_INSN with a\n+\t     REG_EQUAL note, the original use of the dying register\n+\t     will not have been combined into I3 and I2.  In such cases,\n+\t     FROM_INSN is guaranteed to be the first of the combined\n+\t     instructions, so we simply need to search back before\n+\t     FROM_INSN for the previous use or set of this register,\n+\t     then alter the notes there appropriately.\n+\n+\t     If the register is used as an input in I3, it dies there.\n \t     Similarly for I2, if it is nonzero and adjacent to I3.\n \n \t     If the register is not used as an input in either I3 or I2\n@@ -12107,30 +12122,30 @@ distribute_notes (rtx notes, rtx from_insn, rtx i3, rtx i2, rtx elim_i2,\n \t     In both cases, we must search to see if we can find a previous\n \t     use of A and put the death note there.  */\n \n-\t  if (from_insn\n-\t      && CALL_P (from_insn)\n-\t      && find_reg_fusage (from_insn, USE, XEXP (note, 0)))\n-\t    place = from_insn;\n-\t  else if (reg_referenced_p (XEXP (note, 0), PATTERN (i3)))\n-\t    place = i3;\n-\t  else if (i2 != 0 && next_nonnote_insn (i2) == i3\n-\t\t   && reg_referenced_p (XEXP (note, 0), PATTERN (i2)))\n-\t    place = i2;\n-\n-\t  if (place == 0\n-\t      && (rtx_equal_p (XEXP (note, 0), elim_i2)\n-\t\t  || rtx_equal_p (XEXP (note, 0), elim_i1)))\n-\t    break;\n+\t  if (from_insn && from_insn == replaced_rhs_insn)\n+\t    tem = from_insn;\n+\t  else\n+\t    {\n+\t      if (from_insn\n+\t\t  && CALL_P (from_insn)\n+\t\t  && find_reg_fusage (from_insn, USE, XEXP (note, 0)))\n+\t\tplace = from_insn;\n+\t      else if (reg_referenced_p (XEXP (note, 0), PATTERN (i3)))\n+\t\tplace = i3;\n+\t      else if (i2 != 0 && next_nonnote_insn (i2) == i3\n+\t\t       && reg_referenced_p (XEXP (note, 0), PATTERN (i2)))\n+\t\tplace = i2;\n+\t      else if (rtx_equal_p (XEXP (note, 0), elim_i2)\n+\t\t       || rtx_equal_p (XEXP (note, 0), elim_i1))\n+\t\tbreak;\n+\t      tem = i3;\n+\t    }\n \n \t  if (place == 0)\n \t    {\n \t      basic_block bb = this_basic_block;\n \n-\t      /* You might think you could search back from FROM_INSN\n-\t\t rather than from I3, but combine tries to split invalid\n-\t\t combined instructions.  This can result in the old I2\n-\t\t or I1 moving later in the insn sequence.  */\n-\t      for (tem = PREV_INSN (i3); place == 0; tem = PREV_INSN (tem))\n+\t      for (tem = PREV_INSN (tem); place == 0; tem = PREV_INSN (tem))\n \t\t{\n \t\t  if (! INSN_P (tem))\n \t\t    {\n@@ -12230,22 +12245,6 @@ distribute_notes (rtx notes, rtx from_insn, rtx i3, rtx i2, rtx elim_i2,\n \t\t\t   || (CALL_P (tem)\n \t\t\t       && find_reg_fusage (tem, USE, XEXP (note, 0))))\n \t\t    {\n-\t\t      /* This may not be the correct place for the death\n-\t\t\t note if FROM_INSN is before TEM, and the reg is\n-\t\t\t set between FROM_INSN and TEM.  The reg might\n-\t\t\t die two or more times.  An existing death note\n-\t\t\t means we are looking at the wrong live range.  */\n-\t\t      if (from_insn\n-\t\t\t  && INSN_CUID (from_insn) < INSN_CUID (tem)\n-\t\t\t  && find_regno_note (tem, REG_DEAD,\n-\t\t\t\t\t      REGNO (XEXP (note, 0))))\n-\t\t\t{\n-\t\t\t  tem = from_insn;\n-\t\t\t  if (tem == BB_HEAD (bb))\n-\t\t\t    break;\n-\t\t\t  continue;\n-\t\t\t}\n-\n \t\t      place = tem;\n \n \t\t      /* If we are doing a 3->2 combination, and we have a"}, {"sha": "c7a4eb2c8b9b025919c3d5f115f052dafd44279d", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1ff3ac02b534f8fb29e9eb607cc36ad6fd84746b/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1ff3ac02b534f8fb29e9eb607cc36ad6fd84746b/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=1ff3ac02b534f8fb29e9eb607cc36ad6fd84746b", "patch": "@@ -1,3 +1,8 @@\n+2006-05-22  Richard Sandiford  <richard@codesourcery.com>\n+\n+\tPR rtl-optimization/25514\n+\t* gcc.c-torture/compile/pr25514.c: New test.\n+\n 2006-05-22  Richard Guenther  <rguenther@suse.de>\n \n \tRevert"}, {"sha": "0bf5aa9077dc0f9b8f909f43f217b009e860de36", "filename": "gcc/testsuite/gcc.c-torture/compile/pr25514.c", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1ff3ac02b534f8fb29e9eb607cc36ad6fd84746b/gcc%2Ftestsuite%2Fgcc.c-torture%2Fcompile%2Fpr25514.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1ff3ac02b534f8fb29e9eb607cc36ad6fd84746b/gcc%2Ftestsuite%2Fgcc.c-torture%2Fcompile%2Fpr25514.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.c-torture%2Fcompile%2Fpr25514.c?ref=1ff3ac02b534f8fb29e9eb607cc36ad6fd84746b", "patch": "@@ -0,0 +1,24 @@\n+struct node {\n+  struct node *next;\n+  int value;\n+};\n+\n+struct node *current_node, global_list;\n+\n+void\n+bar (void)\n+{\n+  struct node *node, *next;\n+\n+  node = current_node;\n+  next = node->next;\n+  if (node != &global_list)\n+    current_node = next;\n+  else\n+    {\n+      node = global_list.next;\n+      global_list.value = node->value;\n+      global_list.next = node->next;\n+    }\n+  foo (node);\n+}"}]}