{"sha": "3d348653e0fbd1567780a1858a8ca3fcccbbe385", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6M2QzNDg2NTNlMGZiZDE1Njc3ODBhMTg1OGE4Y2EzZmNjY2JiZTM4NQ==", "commit": {"author": {"name": "Doug Evans", "email": "dje@gnu.org", "date": "1996-08-06T18:25:30Z"}, "committer": {"name": "Doug Evans", "email": "dje@gnu.org", "date": "1996-08-06T18:25:30Z"}, "message": "gen-protos.c (overrides): New static local.\n\n\t* gen-protos.c (overrides): New static local.\n\t(add_hash,parse_fn_proto): New static functions.\n\t(main): Add prototypes from SYS_PROTO_OVERRIDES to hash table before\n\tparsing sys-protos.h.  Reserve entry 0 in std_protos.\n\t* alpha/alpha.h (SYS_PROTO_OVERRIDES): Define.\n\nFrom-SVN: r12598", "tree": {"sha": "f4020011264843c6bb4424b195cad6319422c5ed", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f4020011264843c6bb4424b195cad6319422c5ed"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3d348653e0fbd1567780a1858a8ca3fcccbbe385", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3d348653e0fbd1567780a1858a8ca3fcccbbe385", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3d348653e0fbd1567780a1858a8ca3fcccbbe385", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3d348653e0fbd1567780a1858a8ca3fcccbbe385/comments", "author": null, "committer": null, "parents": [{"sha": "d50014aec65054e8a46ead153a31e21c5ce43622", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d50014aec65054e8a46ead153a31e21c5ce43622", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d50014aec65054e8a46ead153a31e21c5ce43622"}], "stats": {"total": 246, "additions": 158, "deletions": 88}, "files": [{"sha": "ff8dea11f4ea4a00038c7a019260a51a061ea271", "filename": "gcc/config/alpha/alpha.h", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3d348653e0fbd1567780a1858a8ca3fcccbbe385/gcc%2Fconfig%2Falpha%2Falpha.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3d348653e0fbd1567780a1858a8ca3fcccbbe385/gcc%2Fconfig%2Falpha%2Falpha.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Falpha%2Falpha.h?ref=3d348653e0fbd1567780a1858a8ca3fcccbbe385", "patch": "@@ -2253,3 +2253,7 @@ do {\t\t\t\t\t\t\t\\\n #define HAS_INIT_SECTION\n #define LD_INIT_SWITCH \"-init\"\n #define LD_FINI_SWITCH \"-fini\"\n+\n+/* Define gethostid in unistd.h as returning an int, not a long.  */\n+#define SYS_PROTO_OVERRIDES \\\n+  \"extern int gethostid (void);\","}, {"sha": "47cf87e60182f4d463fb4facaa953ce953016ce4", "filename": "gcc/gen-protos.c", "status": "modified", "additions": 154, "deletions": 88, "changes": 242, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3d348653e0fbd1567780a1858a8ca3fcccbbe385/gcc%2Fgen-protos.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3d348653e0fbd1567780a1858a8ca3fcccbbe385/gcc%2Fgen-protos.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgen-protos.c?ref=3d348653e0fbd1567780a1858a8ca3fcccbbe385", "patch": "@@ -1,5 +1,5 @@\n /* gen-protos.c - massages a list of prototypes, for use by fixproto.\n-   Copyright (C) 1993, 1994, 1995 Free Software Foundation, Inc.\n+   Copyright (C) 1993, 1994, 1995, 1996 Free Software Foundation, Inc.\n \n This program is free software; you can redistribute it and/or modify it\n under the terms of the GNU General Public License as published by the\n@@ -22,9 +22,23 @@ Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */\n #include \"cpplib.h\"\n #include \"cpphash.h\"\n \n+int verbose = 0;\n+char *progname;\n+\n+/* Table of prototypes that override sys-protos.h.  */\n+static char *overrides[] =\n+{\n+#ifdef SYS_PROTO_OVERRIDES\n+  SYS_PROTO_OVERRIDES\n+#endif\n+  0\n+};\n+\n #define HASH_SIZE 2503 /* a prime */\n+int hash_tab[HASH_SIZE];\n+int next_index;\n \n-int\n+static int\n hashf (name, len, hashsize)\n      register U_CHAR *name;\n      register int len;\n@@ -38,20 +52,99 @@ hashf (name, len, hashsize)\n   return MAKE_POS (r) % hashsize;\n }\n \n-int hash_tab[HASH_SIZE];\n-int verbose = 0;\n-char *progname;\n+static void\n+add_hash (fname)\n+     char *fname;\n+{\n+  int i, i0;\n \n-sstring linebuf;\n+  /* NOTE:  If you edit this, also edit lookup_std_proto in fix-header.c !! */\n+  i = hashf (fname, strlen (fname), HASH_SIZE);\n+  i0 = i;\n+  if (hash_tab[i] != 0)\n+    {\n+      for (;;)\n+\t{\n+\t  i = (i+1) % HASH_SIZE;\n+\t  if (i == i0)\n+\t    abort ();\n+\t  if (hash_tab[i] == 0)\n+\t    break;\n+\t}\n+    }\n+  hash_tab[i] = next_index;\n \n-/* Avoid error if config defines abort as fancy_abort.\n-   It's not worth \"really\" implementing this because ordinary\n-   compiler users never run fix-header.  */\n+  next_index++;\n+}\n \n-void\n-fancy_abort ()\n+/* Given a function prototype, fill in the fields of FN.\n+   The result is a boolean indicating if a function prototype was found.\n+\n+   The input string is modified (trailing NULs are inserted).\n+   The fields of FN point to the input string.  */\n+\n+static int\n+parse_fn_proto (start, end, fn)\n+     char *start, *end;\n+     struct fn_decl *fn;\n {\n-  abort ();\n+  register char *ptr;\n+  int param_nesting = 1;\n+  char *param_start, *param_end, *decl_start, *name_start, *name_end;\n+\n+  ptr = end - 1;\n+  while (*ptr == ' ' || *ptr == '\\t') ptr--;\n+  if (*ptr-- != ';')\n+    {\n+      fprintf (stderr, \"Funny input line: %s\\n\", start);\n+      return 0;\n+    }\n+  while (*ptr == ' ' || *ptr == '\\t') ptr--;\n+  if (*ptr != ')')\n+    {\n+      fprintf (stderr, \"Funny input line: %s\\n\", start);\n+      return 0;\n+    }\n+  param_end = ptr;\n+  for (;;)\n+    {\n+      int c = *--ptr;\n+      if (c == '(' && --param_nesting == 0)\n+\tbreak;\n+      else if (c == ')')\n+\tparam_nesting++;\n+    }\n+  param_start = ptr+1;\n+\n+  ptr--;\n+  while (*ptr == ' ' || *ptr == '\\t') ptr--;\n+\n+  if (!isalnum (*ptr))\n+    {\n+      if (verbose)\n+\tfprintf (stderr, \"%s: Can't handle this complex prototype: %s\\n\",\n+\t\t progname, start);\n+      return 0;\n+    }\n+  name_end = ptr+1;\n+\n+  while (isalnum (*ptr) || *ptr == '_') --ptr;\n+  name_start = ptr+1;\n+  while (*ptr == ' ' || *ptr == '\\t') ptr--;\n+  ptr[1] = 0;\n+  *param_end = 0;\n+  *name_end = 0;\n+\n+  decl_start = start;\n+  if (strncmp (decl_start, \"typedef \", 8) == 0)\n+    return 0;\n+  if (strncmp (decl_start, \"extern \", 7) == 0)\n+    decl_start += 7;\n+\n+  fn->fname = name_start;\n+  fn->rtype = decl_start;\n+  fn->params = param_start;\n+  return 1;\n }\n \n int\n@@ -61,22 +154,50 @@ main (argc, argv)\n {\n   FILE *inf = stdin;\n   FILE *outf = stdout;\n-  int next_index = 0;\n-  int i, i0;\n+  int i;\n+  sstring linebuf;\n+  char **optr;\n+  struct fn_decl fn_decl;\n \n   i = strlen (argv[0]);\n   while (i > 0 && argv[0][i-1] != '/') --i;\n   progname = &argv[0][i];\n \n+  INIT_SSTRING (&linebuf);\n+\n   fprintf (outf, \"struct fn_decl std_protos[] = {\\n\");\n \n+  /* A hash table entry of 0 means \"unused\" so reserve it.  */\n+  fprintf (outf, \"  {\\\"\\\", \\\"\\\", \\\"\\\"},\\n\");\n+  next_index = 1;\n+  \n+  /* Output the overriding prototypes first so fix-header will use them\n+     in preference to the default ones.  */\n+  /* ??? Two copies of the prototype are output.  This doesn't cause any\n+     problems, but one might wish to avoid outputting the second one.  */\n+\n+  for (optr = overrides; *optr; ++optr)\n+    {\n+      /* Using sstring's here may be overkill but parse_fn_proto modifies\n+\t the input string.  */\n+      linebuf.ptr = linebuf.base;\n+      make_sstring_space (&linebuf, strlen (*optr) + 1);\n+      strcpy (linebuf.base, *optr);\n+      linebuf.ptr = linebuf.base + strlen (*optr);\n+\n+      if (! parse_fn_proto (linebuf.base, linebuf.ptr, &fn_decl))\n+\tcontinue;\n+\n+      add_hash (fn_decl.fname);\n+\n+      fprintf (outf, \"  {\\\"%s\\\", \\\"%s\\\", \\\"%s\\\"},\\n\",\n+\t       fn_decl.fname, fn_decl.rtype, fn_decl.params);\n+    }\n+\n   for (;;)\n     {\n       int c = skip_spaces (inf, ' ');\n-      int param_nesting = 1;\n-      char *param_start, *param_end, *decl_start,\n-      *name_start, *name_end;\n-      register char *ptr;\n+\n       if (c == EOF)\n \tbreak;\n       linebuf.ptr = linebuf.base;\n@@ -87,83 +208,18 @@ main (argc, argv)\n       if (linebuf.base[0] == '\\0') /* skip empty line */\n \tcontinue;\n \n-      ptr = linebuf.ptr - 1;\n-      while (*ptr == ' ' || *ptr == '\\t') ptr--;\n-      if (*ptr-- != ';')\n-\t{\n-\t  fprintf (stderr, \"Funny input line: %s\\n\", linebuf.base);\n-\t  continue;\n-\t}\n-      while (*ptr == ' ' || *ptr == '\\t') ptr--;\n-      if (*ptr != ')')\n-\t{\n-\t  fprintf (stderr, \"Funny input line: %s\\n\", linebuf.base);\n-\t  continue;\n-\t}\n-      param_end = ptr;\n-      for (;;)\n-\t{\n-\t  int c = *--ptr;\n-\t  if (c == '(' && --param_nesting == 0)\n-\t    break;\n-\t  else if (c == ')')\n-\t    param_nesting++;\n-\t}\n-      param_start = ptr+1;\n-\n-      ptr--;\n-      while (*ptr == ' ' || *ptr == '\\t') ptr--;\n-\n-      if (!isalnum (*ptr))\n-\t{\n-\t  if (verbose)\n-\t    fprintf (stderr, \"%s: Can't handle this complex prototype: %s\\n\",\n-\t\t     argv[0], linebuf.base);\n-\t  continue;\n-\t}\n-      name_end = ptr+1;\n-\n-      while (isalnum (*ptr) || *ptr == '_') --ptr;\n-      name_start = ptr+1;\n-      while (*ptr == ' ' || *ptr == '\\t') ptr--;\n-      ptr[1] = 0;\n-      *name_end = 0;\n-      *param_end = 0;\n-      *name_end = 0;\n-\n-      decl_start = linebuf.base;\n-      if (strncmp (decl_start, \"typedef \", 8) == 0)\n+      if (! parse_fn_proto (linebuf.base, linebuf.ptr, &fn_decl))\n \tcontinue;\n-      if (strncmp (decl_start, \"extern \", 7) == 0)\n-\tdecl_start += 7;\n \n+      add_hash (fn_decl.fname);\n \n-      /* NOTE:  If you edit this,\n-\t also edit lookup_std_proto in fix-header.c !! */\n-      i = hashf (name_start, name_end - name_start, HASH_SIZE);\n-      i0 = i;\n-      if (hash_tab[i] != 0)\n-\t{\n-\t  for (;;)\n-\t    {\n-\t      i = (i+1) % HASH_SIZE;\n-\t      if (i == i0)\n-\t\tabort ();\n-\t      if (hash_tab[i] == 0)\n-\t\tbreak;\n-\t    }\n-\t}\n-      hash_tab[i] = next_index;\n-\n-      fprintf (outf, \"  {\\\"%s\\\", \\\"%s\\\", \\\"%s\\\" },\\n\",\n-\t       name_start, decl_start, param_start);\n-\n-      next_index++;\n+      fprintf (outf, \"  {\\\"%s\\\", \\\"%s\\\", \\\"%s\\\"},\\n\",\n+\t       fn_decl.fname, fn_decl.rtype, fn_decl.params);\n \n       if (c == EOF)\n \tbreak;\n     }\n-  fprintf (outf, \"{0, 0, 0}\\n};\\n\");\n+  fprintf (outf, \"  {0, 0, 0}\\n};\\n\");\n \n \n   fprintf (outf, \"#define HASH_SIZE %d\\n\", HASH_SIZE);\n@@ -175,6 +231,16 @@ main (argc, argv)\n   return 0;\n }\n \n+/* Avoid error if config defines abort as fancy_abort.\n+   It's not worth \"really\" implementing this because ordinary\n+   compiler users never run fix-header.  */\n+\n+void\n+fancy_abort ()\n+{\n+  abort ();\n+}\n+\n void\n fatal (s)\n      char *s;"}]}