{"sha": "7c76aa3f9f6a59ad56dcf3bce8197f4ac53242dc", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6N2M3NmFhM2Y5ZjZhNTlhZDU2ZGNmM2JjZTgxOTdmNGFjNTMyNDJkYw==", "commit": {"author": {"name": "Hristian Kirtchev", "email": "kirtchev@adacore.com", "date": "2015-03-02T11:09:11Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2015-03-02T11:09:11Z"}, "message": "sem_attr.adb (Analyze_Attribute): Factor out heavily indented code in Denote_Same_Function.\n\n2015-03-02  Hristian Kirtchev  <kirtchev@adacore.com>\n\n\t* sem_attr.adb (Analyze_Attribute): Factor out heavily indented\n\tcode in Denote_Same_Function.  Do not analyze attribute 'Result\n\twhen it is inside procedure _Postconditions.  Remove a misplaced\n\twarning diagnostic. Code cleanup.\n\t(Denote_Same_Function): New routine.\n\t* sem_prag.adb (Analyze_Contract_Cases_In_Decl_Part): Code\n\tcleanup. Warn on pre/postconditions on an inlined subprogram.\n\t(Analyze_Pragma, Refined_Post case): Warn on pre/postconditions on\n\tan inlined subprogram.\n\t(Analyze_Pre_Post_Condition_In_Decl_Part): Code cleanup. Warn on\n\tpre/post condition on an inlined subprogram.\n\t(Analyze_Test_Case_In_Decl_Part): Code cleanup. Warn on\n\tpre/postconditions on an inlined subprogram.\n\t(Check_Postcondition_Use_In_Inlined_Subprogram): New routine.\n\nFrom-SVN: r221112", "tree": {"sha": "b8abb6423bafd49b454a04699c1b78e9ea319509", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b8abb6423bafd49b454a04699c1b78e9ea319509"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/7c76aa3f9f6a59ad56dcf3bce8197f4ac53242dc", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7c76aa3f9f6a59ad56dcf3bce8197f4ac53242dc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7c76aa3f9f6a59ad56dcf3bce8197f4ac53242dc", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7c76aa3f9f6a59ad56dcf3bce8197f4ac53242dc/comments", "author": {"login": "kirtchev-adacore", "id": 60669983, "node_id": "MDQ6VXNlcjYwNjY5OTgz", "avatar_url": "https://avatars.githubusercontent.com/u/60669983?v=4", "gravatar_id": "", "url": "https://api.github.com/users/kirtchev-adacore", "html_url": "https://github.com/kirtchev-adacore", "followers_url": "https://api.github.com/users/kirtchev-adacore/followers", "following_url": "https://api.github.com/users/kirtchev-adacore/following{/other_user}", "gists_url": "https://api.github.com/users/kirtchev-adacore/gists{/gist_id}", "starred_url": "https://api.github.com/users/kirtchev-adacore/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/kirtchev-adacore/subscriptions", "organizations_url": "https://api.github.com/users/kirtchev-adacore/orgs", "repos_url": "https://api.github.com/users/kirtchev-adacore/repos", "events_url": "https://api.github.com/users/kirtchev-adacore/events{/privacy}", "received_events_url": "https://api.github.com/users/kirtchev-adacore/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "aaeb3b3a867a793f3e08de6cd6ac76539907fef3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/aaeb3b3a867a793f3e08de6cd6ac76539907fef3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/aaeb3b3a867a793f3e08de6cd6ac76539907fef3"}], "stats": {"total": 326, "additions": 186, "deletions": 140}, "files": [{"sha": "1c8ef6a8f46ad1cc433c873bcdb1e56aef40a2b8", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7c76aa3f9f6a59ad56dcf3bce8197f4ac53242dc/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7c76aa3f9f6a59ad56dcf3bce8197f4ac53242dc/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=7c76aa3f9f6a59ad56dcf3bce8197f4ac53242dc", "patch": "@@ -1,3 +1,20 @@\n+2015-03-02  Hristian Kirtchev  <kirtchev@adacore.com>\n+\n+\t* sem_attr.adb (Analyze_Attribute): Factor out heavily indented\n+\tcode in Denote_Same_Function.  Do not analyze attribute 'Result\n+\twhen it is inside procedure _Postconditions.  Remove a misplaced\n+\twarning diagnostic. Code cleanup.\n+\t(Denote_Same_Function): New routine.\n+\t* sem_prag.adb (Analyze_Contract_Cases_In_Decl_Part): Code\n+\tcleanup. Warn on pre/postconditions on an inlined subprogram.\n+\t(Analyze_Pragma, Refined_Post case): Warn on pre/postconditions on\n+\tan inlined subprogram.\n+\t(Analyze_Pre_Post_Condition_In_Decl_Part): Code cleanup. Warn on\n+\tpre/post condition on an inlined subprogram.\n+\t(Analyze_Test_Case_In_Decl_Part): Code cleanup. Warn on\n+\tpre/postconditions on an inlined subprogram.\n+\t(Check_Postcondition_Use_In_Inlined_Subprogram): New routine.\n+\n 2015-03-02  Hristian Kirtchev  <kirtchev@adacore.com>\n \n \t* sem_prag.adb (Ensure_Aggregate_Form):"}, {"sha": "b3786f106ce2f39551734adffdf41e77d28de330", "filename": "gcc/ada/sem_attr.adb", "status": "modified", "additions": 95, "deletions": 121, "changes": 216, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7c76aa3f9f6a59ad56dcf3bce8197f4ac53242dc/gcc%2Fada%2Fsem_attr.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7c76aa3f9f6a59ad56dcf3bce8197f4ac53242dc/gcc%2Fada%2Fsem_attr.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_attr.adb?ref=7c76aa3f9f6a59ad56dcf3bce8197f4ac53242dc", "patch": "@@ -4997,6 +4997,12 @@ package body Sem_Attr is\n          --  Verify that attribute 'Result appears within the Ensures argument\n          --  of pragma Test_Case.\n \n+         function Denote_Same_Function\n+           (Pref_Id : Entity_Id;\n+            Spec_Id : Entity_Id) return Boolean;\n+         --  Determine whether the entity of the prefix Pref_Id denotes the\n+         --  same entity as that of the related subprogram Spec_Id.\n+\n          function Is_Within\n            (Nod      : Node_Id;\n             Encl_Nod : Node_Id) return Boolean;\n@@ -5078,6 +5084,57 @@ package body Sem_Attr is\n             end if;\n          end Check_Placement_In_Test_Case;\n \n+         --------------------------\n+         -- Denote_Same_Function --\n+         --------------------------\n+\n+         function Denote_Same_Function\n+           (Pref_Id : Entity_Id;\n+            Spec_Id : Entity_Id) return Boolean\n+         is\n+            Subp_Spec : constant Node_Id := Parent (Spec_Id);\n+\n+         begin\n+            --  The prefix denotes the related subprogram\n+\n+            if Pref_Id = Spec_Id then\n+               return True;\n+\n+            --  Account for a special case when attribute 'Result appears in\n+            --  the postcondition of a generic function.\n+\n+            --    generic\n+            --    function Gen_Func return ...\n+            --      with Post => Gen_Func'Result ...;\n+\n+            --  When the generic function is instantiated, the Chars field of\n+            --  the instantiated prefix still denotes the name of the generic\n+            --  function. Note that any preemptive transformation is impossible\n+            --  without a proper analysis. The structure of the wrapper package\n+            --  is as follows:\n+\n+            --    package Anon_Gen_Pack is\n+            --       <subtypes and renamings>\n+            --       function Subp_Decl return ...;               --  (!)\n+            --       pragma Postcondition (Gen_Func'Result ...);  --  (!)\n+            --       function Gen_Func ... renames Subp_Decl;\n+            --    end Anon_Gen_Pack;\n+\n+            elsif Nkind (Subp_Spec) = N_Function_Specification\n+              and then Present (Generic_Parent (Subp_Spec))\n+              and then Ekind (Pref_Id) = E_Function\n+              and then Present (Alias (Pref_Id))\n+              and then Alias (Pref_Id) = Spec_Id\n+            then\n+               return True;\n+\n+            --  Otherwise the prefix does not denote the related subprogram\n+\n+            else\n+               return False;\n+            end if;\n+         end Denote_Same_Function;\n+\n          ---------------\n          -- Is_Within --\n          ---------------\n@@ -5108,14 +5165,11 @@ package body Sem_Attr is\n \n          --  Local variables\n \n-         In_Post   : Boolean := False;\n          Prag      : Node_Id;\n          Prag_Id   : Pragma_Id;\n          Pref_Id   : Entity_Id;\n          Spec_Id   : Entity_Id;\n          Subp_Decl : Node_Id;\n-         Subp_Id   : Entity_Id;\n-         Subp_Spec : Node_Id;\n \n       --  Start of processing for Result\n \n@@ -5204,128 +5258,62 @@ package body Sem_Attr is\n             Subp_Decl := Find_Related_Subprogram_Or_Body (Prag);\n          end if;\n \n-         --  The pragma where attribute 'Result appears is associated with a\n-         --  subprogram declaration or a body.\n+         --  The pragma where attribute 'Result resides should be associated\n+         --  with a subprogram declaration or a body. If this is not the case,\n+         --  then the pragma is illegal. Return as analysis cannot be carried\n+         --  out.\n \n-         if Nkind_In (Subp_Decl, N_Abstract_Subprogram_Declaration,\n-                                 N_Entry_Declaration,\n-                                 N_Generic_Subprogram_Declaration,\n-                                 N_Subprogram_Body,\n-                                 N_Subprogram_Body_Stub,\n-                                 N_Subprogram_Declaration)\n+         if not Nkind_In (Subp_Decl, N_Abstract_Subprogram_Declaration,\n+                                     N_Entry_Declaration,\n+                                     N_Generic_Subprogram_Declaration,\n+                                     N_Subprogram_Body,\n+                                     N_Subprogram_Body_Stub,\n+                                     N_Subprogram_Declaration)\n          then\n-            Subp_Id := Defining_Entity (Subp_Decl);\n+            return;\n+         end if;\n \n-            --  Attribute 'Result is part of the _Postconditions procedure of\n-            --  the related subprogram. Retrieve the related subprogram.\n+         Spec_Id := Corresponding_Spec_Of (Subp_Decl);\n \n-            if Chars (Subp_Id) = Name_uPostconditions then\n-               In_Post   := True;\n-               Subp_Decl := Parent (Subp_Decl);\n-               Subp_Id   := Scope (Subp_Id);\n-            end if;\n+         --  Attribute 'Result is part of a _Postconditions procedure. There is\n+         --  no need to perform the semantic checks below as they were already\n+         --  verified when the attribute was analyzed in its original context.\n+         --  Instead, rewrite the attribute as a reference to formal parameter\n+         --  _Result of the _Postconditions procedure.\n \n-            --  Retrieve the entity of the spec (if any)\n+         if Chars (Spec_Id) = Name_uPostconditions then\n+            Rewrite (N, Make_Identifier (Loc, Name_uResult));\n \n-            if Nkind (Subp_Decl) = N_Subprogram_Body\n-              and then Present (Corresponding_Spec (Subp_Decl))\n-            then\n-               Spec_Id := Corresponding_Spec (Subp_Decl);\n+            --  The type of formal parameter _Result is that of the function\n+            --  encapsulating the _Postconditions procedure. Resolution must\n+            --  be carried out against the function return type.\n \n-            elsif Nkind (Subp_Decl) = N_Subprogram_Body_Stub\n-              and then Present (Corresponding_Spec_Of_Stub (Subp_Decl))\n-            then\n-               Spec_Id := Corresponding_Spec_Of_Stub (Subp_Decl);\n+            Analyze_And_Resolve (N, Etype (Scope (Spec_Id)));\n \n-            else\n-               Spec_Id := Subp_Id;\n-            end if;\n+         --  Otherwise attribute 'Result appears in its original context and\n+         --  all semantic checks should be carried out.\n \n-            --  When the subprogram is always inlined, the postcondition will\n-            --  not be propagated to the expanded body.\n-\n-            if Warn_On_Redundant_Constructs\n-              and then Has_Pragma_Inline_Always (Spec_Id)\n-            then\n-               Error_Msg_N\n-                 (\"postconditions on inlined functions not enforced?r?\", P);\n-            end if;\n-\n-            --  Ensure that the prefix of attribute 'Result denotes the related\n-            --  subprogram.\n+         else\n+            --  Verify the legality of the prefix. It must denotes the entity\n+            --  of the related [generic] function.\n \n             if Is_Entity_Name (P) then\n                Pref_Id := Entity (P);\n \n-               --  When a subprogram with contract assertions is imported, it\n-               --  is encapsulated in a wrapper. In this case the scope of the\n-               --  wrapper denotes the original imported subprogram.\n-\n-               if Is_Imported (Pref_Id) then\n-                  Pref_Id := Scope (Pref_Id);\n-               end if;\n-\n                if Ekind_In (Pref_Id, E_Function, E_Generic_Function) then\n+                  if Denote_Same_Function (Pref_Id, Spec_Id) then\n+                     Set_Etype (N, Etype (Spec_Id));\n \n-                  --  The prefix of attribute 'Result denotes the entity of\n-                  --  some other unrelated function.\n-\n-                  if Pref_Id /= Spec_Id then\n-                     Subp_Spec := Parent (Spec_Id);\n-\n-                     --  Attribute 'Result appears in a postcondition of a\n-                     --  generic function that acts as a compilation unit:\n-\n-                     --    generic\n-                     --    function Gen_Func return ...\n-                     --      with Post => Gen_Func'Result ...;\n-\n-                     --  When the function is instantiated, the Chars field of\n-                     --  attribute 'Result's prefix still denotes the generic\n-                     --  function. Note that any preemptive transformation is\n-                     --  impossible without a proper analysis. The structure of\n-                     --  the anonymous wrapper package is as follows:\n-\n-                     --    package Anon_Gen_Pack is\n-                     --       <subtypes and renamings>\n-                     --       function Subp_Decl return ...;\n-                     --       pragma Postcondition (Gen_Func'Result ...);\n-                     --       function Gen_Func ... renames Subp_Decl;\n-                     --    end Anon_Gen_Pack;\n-\n-                     --  Recognize this case and do not flag it as illegal\n+                  --  Otherwise the prefix denotes some unrelated function\n \n-                     if Nkind (Subp_Spec) = N_Function_Specification\n-                       and then Present (Generic_Parent (Subp_Spec))\n-                     then\n-                        if Generic_Parent (Subp_Spec) = Pref_Id then\n-                           null;\n-\n-                        elsif Ekind (Pref_Id) = E_Function\n-                          and then Present (Alias (Pref_Id))\n-                          and then Alias (Pref_Id) = Spec_Id\n-                        then\n-                           null;\n-\n-                        else\n-                           Error_Msg_Name_2 := Chars (Spec_Id);\n-                           Error_Attr\n-                             (\"incorrect prefix for % attribute, expected %\",\n-                              P);\n-                        end if;\n-\n-                     --  Otherwise the context is not a function instantiation\n-                     --  and the prefix is illegal\n-\n-                     else\n-                        Error_Msg_Name_2 := Chars (Spec_Id);\n-                        Error_Attr\n-                          (\"incorrect prefix for % attribute, expected %\", P);\n-                     end if;\n+                  else\n+                     Error_Msg_Name_2 := Chars (Spec_Id);\n+                     Error_Attr\n+                       (\"incorrect prefix for % attribute, expected %\", P);\n                   end if;\n \n-               --  Otherwise the attribute's prefix denotes some other form of\n-               --  a non-function subprogram.\n+               --  Otherwise the prefix denotes some other form of subprogram\n+               --  entity.\n \n                else\n                   Error_Attr\n@@ -5339,20 +5327,6 @@ package body Sem_Attr is\n                Error_Msg_Name_2 := Chars (Spec_Id);\n                Error_Attr (\"incorrect prefix for % attribute, expected %\", P);\n             end if;\n-\n-            --  Attribute 'Result is part of the _Postconditions procedure of\n-            --  the related subprogram. Rewrite the attribute as a reference to\n-            --  the _Result formal parameter of _Postconditions.\n-\n-            if In_Post then\n-               Rewrite (N, Make_Identifier (Loc, Name_uResult));\n-               Analyze_And_Resolve (N, Etype (Subp_Id));\n-\n-            --  Otherwise decorate the attribute\n-\n-            else\n-               Set_Etype (N, Etype (Subp_Id));\n-            end if;\n          end if;\n       end Result;\n "}, {"sha": "9e216c642fe7aff5b704906ee5fc05aff33c502e", "filename": "gcc/ada/sem_prag.adb", "status": "modified", "additions": 74, "deletions": 19, "changes": 93, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7c76aa3f9f6a59ad56dcf3bce8197f4ac53242dc/gcc%2Fada%2Fsem_prag.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7c76aa3f9f6a59ad56dcf3bce8197f4ac53242dc/gcc%2Fada%2Fsem_prag.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_prag.adb?ref=7c76aa3f9f6a59ad56dcf3bce8197f4ac53242dc", "patch": "@@ -202,6 +202,13 @@ package body Sem_Prag is\n    --  _Post, _Invariant, or _Type_Invariant, which are special names used\n    --  in identifiers to represent these attribute references.\n \n+   procedure Check_Postcondition_Use_In_Inlined_Subprogram\n+     (Prag    : Node_Id;\n+      Subp_Id : Entity_Id);\n+   --  Subsidiary to the analysis of pragmas Contract_Cases, Postcondition,\n+   --  Precondition, Refined_Post and Test_Case. Emit a warning when pragma\n+   --  Prag is associated with subprogram Subp_Id subject to Inline_Always.\n+\n    procedure Check_State_And_Constituent_Use\n      (States   : Elist_Id;\n       Constits : Elist_Id;\n@@ -427,6 +434,7 @@ package body Sem_Prag is\n \n       All_Cases : Node_Id;\n       CCase     : Node_Id;\n+      Spec_Id   : Entity_Id;\n       Subp_Decl : Node_Id;\n       Subp_Id   : Entity_Id;\n \n@@ -439,6 +447,7 @@ package body Sem_Prag is\n       Set_Analyzed (N);\n \n       Subp_Decl := Find_Related_Subprogram_Or_Body (N);\n+      Spec_Id   := Corresponding_Spec_Of (Subp_Decl);\n       Subp_Id   := Defining_Entity (Subp_Decl);\n       All_Cases := Expression (Get_Argument (N, Subp_Id));\n \n@@ -455,14 +464,14 @@ package body Sem_Prag is\n          --  to subprogram declarations. Skip the installation for subprogram\n          --  bodies because the formals are already visible.\n \n-         if not In_Open_Scopes (Subp_Id) then\n+         if not In_Open_Scopes (Spec_Id) then\n             Restore_Scope := True;\n-            Push_Scope (Subp_Id);\n+            Push_Scope (Spec_Id);\n \n-            if Is_Generic_Subprogram (Subp_Id) then\n-               Install_Generic_Formals (Subp_Id);\n+            if Is_Generic_Subprogram (Spec_Id) then\n+               Install_Generic_Formals (Spec_Id);\n             else\n-               Install_Formals (Subp_Id);\n+               Install_Formals (Spec_Id);\n             end if;\n          end if;\n \n@@ -472,6 +481,11 @@ package body Sem_Prag is\n             Next (CCase);\n          end loop;\n \n+         --  Currently it is not possible to inline pre/postconditions on a\n+         --  subprogram subject to pragma Inline_Always.\n+\n+         Check_Postcondition_Use_In_Inlined_Subprogram (N, Spec_Id);\n+\n          if Restore_Scope then\n             End_Scope;\n          end if;\n@@ -18465,6 +18479,11 @@ package body Sem_Prag is\n             if Legal then\n                Analyze_Pre_Post_Condition_In_Decl_Part (N);\n \n+               --  Currently it is not possible to inline pre/postconditions on\n+               --  a subprogram subject to pragma Inline_Always.\n+\n+               Check_Postcondition_Use_In_Inlined_Subprogram (N, Spec_Id);\n+\n                --  Chain the pragma on the contract for easy retrieval\n \n                Add_Contract_Item (N, Body_Id);\n@@ -21513,6 +21532,11 @@ package body Sem_Prag is\n          Process_Class_Wide_Condition (Expr, Spec_Id, Subp_Decl);\n       end if;\n \n+      --  Currently it is not possible to inline pre/postconditions on a\n+      --  subprogram subject to pragma Inline_Always.\n+\n+      Check_Postcondition_Use_In_Inlined_Subprogram (N, Spec_Id);\n+\n       --  Remove the subprogram from the scope stack now that the pre-analysis\n       --  of the precondition/postcondition is done.\n \n@@ -24151,26 +24175,26 @@ package body Sem_Prag is\n    procedure Analyze_Test_Case_In_Decl_Part (N : Node_Id) is\n       procedure Preanalyze_Test_Case_Arg\n         (Arg_Nam : Name_Id;\n-         Subp_Id : Entity_Id);\n+         Spec_Id : Entity_Id);\n       --  Preanalyze one of the optional arguments \"Requires\" or \"Ensures\"\n-      --  denoted by Arg_Nam. Subp_Id is the entity of the subprogram subject\n-      --  to pragma Test_Case.\n+      --  denoted by Arg_Nam. Spec_Id is the entity of the subprogram spec\n+      --  subject to pragma Test_Case.\n \n       ------------------------------\n       -- Preanalyze_Test_Case_Arg --\n       ------------------------------\n \n       procedure Preanalyze_Test_Case_Arg\n         (Arg_Nam : Name_Id;\n-         Subp_Id : Entity_Id)\n+         Spec_Id : Entity_Id)\n       is\n          Arg : Node_Id;\n \n       begin\n          --  Preanalyze the original aspect argument for ASIS or for a generic\n          --  subprogram to properly capture global references.\n \n-         if ASIS_Mode or else Is_Generic_Subprogram (Subp_Id) then\n+         if ASIS_Mode or else Is_Generic_Subprogram (Spec_Id) then\n             Arg :=\n               Test_Case_Arg\n                 (Prag        => N,\n@@ -24192,8 +24216,8 @@ package body Sem_Prag is\n \n       --  Local variables\n \n+      Spec_Id   : Entity_Id;\n       Subp_Decl : Node_Id;\n-      Subp_Id   : Entity_Id;\n \n       Restore_Scope : Boolean := False;\n       --  Gets set True if we do a Push_Scope needing a Pop_Scope on exit\n@@ -24202,25 +24226,30 @@ package body Sem_Prag is\n \n    begin\n       Subp_Decl := Find_Related_Subprogram_Or_Body (N);\n-      Subp_Id   := Defining_Entity (Subp_Decl);\n+      Spec_Id   := Corresponding_Spec_Of (Subp_Decl);\n \n       --  Ensure that the formal parameters are visible when analyzing all\n       --  clauses. This falls out of the general rule of aspects pertaining\n       --  to subprogram declarations.\n \n-      if not In_Open_Scopes (Subp_Id) then\n+      if not In_Open_Scopes (Spec_Id) then\n          Restore_Scope := True;\n-         Push_Scope (Subp_Id);\n+         Push_Scope (Spec_Id);\n \n-         if Is_Generic_Subprogram (Subp_Id) then\n-            Install_Generic_Formals (Subp_Id);\n+         if Is_Generic_Subprogram (Spec_Id) then\n+            Install_Generic_Formals (Spec_Id);\n          else\n-            Install_Formals (Subp_Id);\n+            Install_Formals (Spec_Id);\n          end if;\n       end if;\n \n-      Preanalyze_Test_Case_Arg (Name_Requires, Subp_Id);\n-      Preanalyze_Test_Case_Arg (Name_Ensures,  Subp_Id);\n+      Preanalyze_Test_Case_Arg (Name_Requires, Spec_Id);\n+      Preanalyze_Test_Case_Arg (Name_Ensures,  Spec_Id);\n+\n+      --  Currently it is not possible to inline pre/postconditions on a\n+      --  subprogram subject to pragma Inline_Always.\n+\n+      Check_Postcondition_Use_In_Inlined_Subprogram (N, Spec_Id);\n \n       if Restore_Scope then\n          End_Scope;\n@@ -24604,6 +24633,32 @@ package body Sem_Prag is\n       end if;\n    end Check_Missing_Part_Of;\n \n+   ---------------------------------------------------\n+   -- Check_Postcondition_Use_In_Inlined_Subprogram --\n+   ---------------------------------------------------\n+\n+   procedure Check_Postcondition_Use_In_Inlined_Subprogram\n+     (Prag    : Node_Id;\n+      Subp_Id : Entity_Id)\n+   is\n+   begin\n+      if Warn_On_Redundant_Constructs\n+        and then Has_Pragma_Inline_Always (Subp_Id)\n+      then\n+         Error_Msg_Name_1 := Original_Aspect_Pragma_Name (Prag);\n+\n+         if From_Aspect_Specification (Prag) then\n+            Error_Msg_NE\n+              (\"aspect % not enforced on inlined subprogram &?r?\",\n+               Corresponding_Aspect (Prag), Subp_Id);\n+         else\n+            Error_Msg_NE\n+              (\"pragma % not enforced on inlined subprogram &?r?\",\n+               Prag, Subp_Id);\n+         end if;\n+      end if;\n+   end Check_Postcondition_Use_In_Inlined_Subprogram;\n+\n    -------------------------------------\n    -- Check_State_And_Constituent_Use --\n    -------------------------------------"}]}