{"sha": "bf4787b26777cad2bf7ed499248a350387366d9f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YmY0Nzg3YjI2Nzc3Y2FkMmJmN2VkNDk5MjQ4YTM1MDM4NzM2NmQ5Zg==", "commit": {"author": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2014-03-12T12:59:03Z"}, "committer": {"name": "Jakub Jelinek", "email": "jakub@gcc.gnu.org", "date": "2014-03-12T12:59:03Z"}, "message": "tree-ssa-ifcombine.c (forwarder_block_to): New function.\n\n\t* tree-ssa-ifcombine.c (forwarder_block_to): New function.\n\t(tree_ssa_ifcombine_bb_1): New function.\n\t(tree_ssa_ifcombine_bb): Use it.  Handle also cases where else_bb\n\tis an empty forwarder block to then_bb or vice versa and then_bb\n\tand else_bb are effectively swapped.\n\n\t* gcc.dg/tree-ssa/ssa-ifcombine-12.c: New test.\n\t* gcc.dg/tree-ssa/ssa-ifcombine-13.c: New test.\n\t* gcc.dg/tree-ssa/phi-opt-2.c: Pass -mbranch-cost=1 if\n\tpossible, only test for exactly one if if -mbranch-cost=1\n\thas been passed.\n\nFrom-SVN: r208512", "tree": {"sha": "05765033e37c62eaaa2671e33349a3edc4370a9a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/05765033e37c62eaaa2671e33349a3edc4370a9a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/bf4787b26777cad2bf7ed499248a350387366d9f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bf4787b26777cad2bf7ed499248a350387366d9f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bf4787b26777cad2bf7ed499248a350387366d9f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bf4787b26777cad2bf7ed499248a350387366d9f/comments", "author": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "7d55b94832e4c81e06cbc5007aa77ee31a8875a6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7d55b94832e4c81e06cbc5007aa77ee31a8875a6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7d55b94832e4c81e06cbc5007aa77ee31a8875a6"}], "stats": {"total": 260, "additions": 188, "deletions": 72}, "files": [{"sha": "3863dc1b7c54886aa3e3fb5a6fe27652df54920e", "filename": "gcc/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bf4787b26777cad2bf7ed499248a350387366d9f/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bf4787b26777cad2bf7ed499248a350387366d9f/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=bf4787b26777cad2bf7ed499248a350387366d9f", "patch": "@@ -1,3 +1,11 @@\n+2014-03-12  Jakub Jelinek  <jakub@redhat.com>\n+\n+\t* tree-ssa-ifcombine.c (forwarder_block_to): New function.\n+\t(tree_ssa_ifcombine_bb_1): New function.\n+\t(tree_ssa_ifcombine_bb): Use it.  Handle also cases where else_bb\n+\tis an empty forwarder block to then_bb or vice versa and then_bb\n+\tand else_bb are effectively swapped.\n+\n 2014-03-12  Christian Bruel  <christian.bruel@st.com>\n \n \tPR target/60264"}, {"sha": "5f1297e27b35a65acb4c21d4ecbb580a3e38088f", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bf4787b26777cad2bf7ed499248a350387366d9f/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bf4787b26777cad2bf7ed499248a350387366d9f/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=bf4787b26777cad2bf7ed499248a350387366d9f", "patch": "@@ -1,3 +1,11 @@\n+2014-03-12  Jakub Jelinek  <jakub@redhat.com>\n+\n+\t* gcc.dg/tree-ssa/ssa-ifcombine-12.c: New test.\n+\t* gcc.dg/tree-ssa/ssa-ifcombine-13.c: New test.\n+\t* gcc.dg/tree-ssa/phi-opt-2.c: Pass -mbranch-cost=1 if\n+\tpossible, only test for exactly one if if -mbranch-cost=1\n+\thas been passed.\n+\n 2014-03-12  Christian Bruel  <christian.bruel@st.com>\n \n \tPR target/60264"}, {"sha": "3d34ef3f638b1bf9b3bc45aae12a5d3ce1ce7b44", "filename": "gcc/testsuite/gcc.dg/tree-ssa/phi-opt-2.c", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bf4787b26777cad2bf7ed499248a350387366d9f/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fphi-opt-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bf4787b26777cad2bf7ed499248a350387366d9f/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fphi-opt-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fphi-opt-2.c?ref=bf4787b26777cad2bf7ed499248a350387366d9f", "patch": "@@ -1,5 +1,6 @@\n /* { dg-do compile } */\n /* { dg-options \"-O1 -fdump-tree-optimized\" } */\n+/* { dg-additional-options \"-mbranch-cost=1\" { target { i?86-*-* x86_64-*-* mips*-*-* s390*-*-* avr*-*-* } } } */\n \n _Bool f1(_Bool a, _Bool b)\n {\n@@ -17,6 +18,8 @@ _Bool f1(_Bool a, _Bool b)\n /* There should be only one if, the outer one; the inner one\n    should have been changed to straight line code with the\n    value of b (except that we don't fold ! (b != 0) into b\n-   which can be fixed in a different patch).  */\n-/* { dg-final { scan-tree-dump-times \"if\" 1 \"optimized\"} } */\n+   which can be fixed in a different patch).\n+   Test this only when known to be !LOGICAL_OP_NON_SHORT_CIRCUIT,\n+   otherwise ifcombine may convert this into return a & b;.  */\n+/* { dg-final { scan-tree-dump-times \"if\" 1 \"optimized\" { target { i?86-*-* x86_64-*-* mips*-*-* s390*-*-* avr*-*-* } } } } */\n /* { dg-final { cleanup-tree-dump \"optimized\" } } */"}, {"sha": "5893ba7be790ec5cb2922db78687aad7f24a8a0d", "filename": "gcc/testsuite/gcc.dg/tree-ssa/ssa-ifcombine-12.c", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bf4787b26777cad2bf7ed499248a350387366d9f/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fssa-ifcombine-12.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bf4787b26777cad2bf7ed499248a350387366d9f/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fssa-ifcombine-12.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fssa-ifcombine-12.c?ref=bf4787b26777cad2bf7ed499248a350387366d9f", "patch": "@@ -0,0 +1,20 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -fno-tree-vrp -fdump-tree-optimized\" } */\n+\n+/* Testcase for PR31657.  */\n+\n+int f(int x, int a, int b)\n+{\n+  int t = 0;\n+  int c = 1 << a;\n+  if (!(x & 1))\n+    t = 0;\n+  else\n+    if (x & (1 << 2))\n+      t = 3;\n+    else\n+      t = 0;\n+  return t;\n+}\n+/* { dg-final { scan-tree-dump \"& 5\" \"optimized\" } } */\n+/* { dg-final { cleanup-tree-dump \"optimized\" } } */"}, {"sha": "19f892eaa852d3e79892d7f5ad89f1550814ae96", "filename": "gcc/testsuite/gcc.dg/tree-ssa/ssa-ifcombine-13.c", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bf4787b26777cad2bf7ed499248a350387366d9f/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fssa-ifcombine-13.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bf4787b26777cad2bf7ed499248a350387366d9f/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fssa-ifcombine-13.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fssa-ifcombine-13.c?ref=bf4787b26777cad2bf7ed499248a350387366d9f", "patch": "@@ -0,0 +1,21 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O1 -fdump-tree-optimized\" } */\n+/* { dg-additional-options \"-mbranch-cost=2\" { target { i?86-*-* x86_64-*-* mips*-*-* s390*-*-* avr*-*-* } } } */\n+\n+_Bool f1(_Bool a, _Bool b)\n+{\n+  if (a)\n+   {\n+     if (b)\n+      return 1;\n+     else\n+      return 0;\n+   }\n+  return 0;\n+}\n+\n+\n+/* For LOGICAL_OP_NON_SHORT_CIRCUIT, this should be optimized\n+   into return a & b;, with no ifs.  */\n+/* { dg-final { scan-tree-dump-not \"if\" \"optimized\" { target { i?86-*-* x86_64-*-* mips*-*-* s390*-*-* avr*-*-* } } } } */\n+/* { dg-final { cleanup-tree-dump \"optimized\" } } */"}, {"sha": "be28fb00417826e2f74687ff6efd2cb5cfb49470", "filename": "gcc/tree-ssa-ifcombine.c", "status": "modified", "additions": 126, "deletions": 70, "changes": 196, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bf4787b26777cad2bf7ed499248a350387366d9f/gcc%2Ftree-ssa-ifcombine.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bf4787b26777cad2bf7ed499248a350387366d9f/gcc%2Ftree-ssa-ifcombine.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-ifcombine.c?ref=bf4787b26777cad2bf7ed499248a350387366d9f", "patch": "@@ -135,6 +135,16 @@ bb_no_side_effects_p (basic_block bb)\n   return true;\n }\n \n+/* Return true if BB is an empty forwarder block to TO_BB.  */\n+\n+static bool\n+forwarder_block_to (basic_block bb, basic_block to_bb)\n+{\n+  return empty_block_p (bb)\n+\t && single_succ_p (bb)\n+\t && single_succ (bb) == to_bb;\n+}\n+\n /* Verify if all PHI node arguments in DEST for edges from BB1 or\n    BB2 to DEST are the same.  This makes the CFG merge point\n    free from side-effects.  Return true in this case, else false.  */\n@@ -561,6 +571,99 @@ ifcombine_ifandif (basic_block inner_cond_bb, bool inner_inv,\n   return false;\n }\n \n+/* Helper function for tree_ssa_ifcombine_bb.  Recognize a CFG pattern and\n+   dispatch to the appropriate if-conversion helper for a particular\n+   set of INNER_COND_BB, OUTER_COND_BB, THEN_BB and ELSE_BB.\n+   PHI_PRED_BB should be one of INNER_COND_BB, THEN_BB or ELSE_BB.  */\n+\n+static bool\n+tree_ssa_ifcombine_bb_1 (basic_block inner_cond_bb, basic_block outer_cond_bb,\n+\t\t\t basic_block then_bb, basic_block else_bb,\n+\t\t\t basic_block phi_pred_bb)\n+{\n+  /* The && form is characterized by a common else_bb with\n+     the two edges leading to it mergable.  The latter is\n+     guaranteed by matching PHI arguments in the else_bb and\n+     the inner cond_bb having no side-effects.  */\n+  if (phi_pred_bb != else_bb\n+      && recognize_if_then_else (outer_cond_bb, &inner_cond_bb, &else_bb)\n+      && same_phi_args_p (outer_cond_bb, phi_pred_bb, else_bb)\n+      && bb_no_side_effects_p (inner_cond_bb))\n+    {\n+      /* We have\n+\t   <outer_cond_bb>\n+\t     if (q) goto inner_cond_bb; else goto else_bb;\n+\t   <inner_cond_bb>\n+\t     if (p) goto ...; else goto else_bb;\n+\t     ...\n+\t   <else_bb>\n+\t     ...\n+       */\n+      return ifcombine_ifandif (inner_cond_bb, false, outer_cond_bb, false,\n+\t\t\t\tfalse);\n+    }\n+\n+  /* And a version where the outer condition is negated.  */\n+  if (phi_pred_bb != else_bb\n+      && recognize_if_then_else (outer_cond_bb, &else_bb, &inner_cond_bb)\n+      && same_phi_args_p (outer_cond_bb, phi_pred_bb, else_bb)\n+      && bb_no_side_effects_p (inner_cond_bb))\n+    {\n+      /* We have\n+\t   <outer_cond_bb>\n+\t     if (q) goto else_bb; else goto inner_cond_bb;\n+\t   <inner_cond_bb>\n+\t     if (p) goto ...; else goto else_bb;\n+\t     ...\n+\t   <else_bb>\n+\t     ...\n+       */\n+      return ifcombine_ifandif (inner_cond_bb, false, outer_cond_bb, true,\n+\t\t\t\tfalse);\n+    }\n+\n+  /* The || form is characterized by a common then_bb with the\n+     two edges leading to it mergable.  The latter is guaranteed\n+     by matching PHI arguments in the then_bb and the inner cond_bb\n+     having no side-effects.  */\n+  if (phi_pred_bb != then_bb\n+      && recognize_if_then_else (outer_cond_bb, &then_bb, &inner_cond_bb)\n+      && same_phi_args_p (outer_cond_bb, phi_pred_bb, then_bb)\n+      && bb_no_side_effects_p (inner_cond_bb))\n+    {\n+      /* We have\n+\t   <outer_cond_bb>\n+\t     if (q) goto then_bb; else goto inner_cond_bb;\n+\t   <inner_cond_bb>\n+\t     if (q) goto then_bb; else goto ...;\n+\t   <then_bb>\n+\t     ...\n+       */\n+      return ifcombine_ifandif (inner_cond_bb, true, outer_cond_bb, true,\n+\t\t\t\ttrue);\n+    }\n+\n+  /* And a version where the outer condition is negated.  */\n+  if (phi_pred_bb != then_bb\n+      && recognize_if_then_else (outer_cond_bb, &inner_cond_bb, &then_bb)\n+      && same_phi_args_p (outer_cond_bb, phi_pred_bb, then_bb)\n+      && bb_no_side_effects_p (inner_cond_bb))\n+    {\n+      /* We have\n+\t   <outer_cond_bb>\n+\t     if (q) goto inner_cond_bb; else goto then_bb;\n+\t   <inner_cond_bb>\n+\t     if (q) goto then_bb; else goto ...;\n+\t   <then_bb>\n+\t     ...\n+       */\n+      return ifcombine_ifandif (inner_cond_bb, true, outer_cond_bb, false,\n+\t\t\t\ttrue);\n+    }\n+\n+  return false;\n+}\n+\n /* Recognize a CFG pattern and dispatch to the appropriate\n    if-conversion helper.  We start with BB as the innermost\n    worker basic-block.  Returns true if a transformation was done.  */\n@@ -585,80 +688,33 @@ tree_ssa_ifcombine_bb (basic_block inner_cond_bb)\n     {\n       basic_block outer_cond_bb = single_pred (inner_cond_bb);\n \n-      /* The && form is characterized by a common else_bb with\n-\t the two edges leading to it mergable.  The latter is\n-\t guaranteed by matching PHI arguments in the else_bb and\n-\t the inner cond_bb having no side-effects.  */\n-      if (recognize_if_then_else (outer_cond_bb, &inner_cond_bb, &else_bb)\n-\t  && same_phi_args_p (outer_cond_bb, inner_cond_bb, else_bb)\n-\t  && bb_no_side_effects_p (inner_cond_bb))\n-\t{\n-\t  /* We have\n-\t       <outer_cond_bb>\n-\t\t if (q) goto inner_cond_bb; else goto else_bb;\n-\t       <inner_cond_bb>\n-\t\t if (p) goto ...; else goto else_bb;\n-\t\t ...\n-\t       <else_bb>\n-\t\t ...\n-\t   */\n-\t  return ifcombine_ifandif (inner_cond_bb, false, outer_cond_bb, false,\n-\t\t\t\t    false);\n-\t}\n+      if (tree_ssa_ifcombine_bb_1 (inner_cond_bb, outer_cond_bb,\n+\t\t\t\t   then_bb, else_bb, inner_cond_bb))\n+\treturn true;\n \n-      /* And a version where the outer condition is negated.  */\n-      if (recognize_if_then_else (outer_cond_bb, &else_bb, &inner_cond_bb)\n-\t  && same_phi_args_p (outer_cond_bb, inner_cond_bb, else_bb)\n-\t  && bb_no_side_effects_p (inner_cond_bb))\n+      if (forwarder_block_to (else_bb, then_bb))\n \t{\n-\t  /* We have\n-\t       <outer_cond_bb>\n-\t\t if (q) goto else_bb; else goto inner_cond_bb;\n-\t       <inner_cond_bb>\n-\t\t if (p) goto ...; else goto else_bb;\n-\t\t ...\n-\t       <else_bb>\n-\t\t ...\n-\t   */\n-\t  return ifcombine_ifandif (inner_cond_bb, false, outer_cond_bb, true,\n-\t\t\t\t    false);\n+\t  /* Other possibilities for the && form, if else_bb is\n+\t     empty forwarder block to then_bb.  Compared to the above simpler\n+\t     forms this can be treated as if then_bb and else_bb were swapped,\n+\t     and the corresponding inner_cond_bb not inverted because of that.\n+\t     For same_phi_args_p we look at equality of arguments between\n+\t     edge from outer_cond_bb and the forwarder block.  */\n+\t  if (tree_ssa_ifcombine_bb_1 (inner_cond_bb, outer_cond_bb, else_bb,\n+\t\t\t\t       then_bb, else_bb))\n+\t    return true;\n \t}\n-\n-      /* The || form is characterized by a common then_bb with the\n-\t two edges leading to it mergable.  The latter is guaranteed\n-         by matching PHI arguments in the then_bb and the inner cond_bb\n-\t having no side-effects.  */\n-      if (recognize_if_then_else (outer_cond_bb, &then_bb, &inner_cond_bb)\n-\t  && same_phi_args_p (outer_cond_bb, inner_cond_bb, then_bb)\n-\t  && bb_no_side_effects_p (inner_cond_bb))\n-\t{\n-\t  /* We have\n-\t       <outer_cond_bb>\n-\t\t if (q) goto then_bb; else goto inner_cond_bb;\n-\t       <inner_cond_bb>\n-\t\t if (q) goto then_bb; else goto ...;\n-\t       <then_bb>\n-\t\t ...\n-\t   */\n-\t  return ifcombine_ifandif (inner_cond_bb, true, outer_cond_bb, true,\n-\t\t\t\t    true);\n-\t}\n-\n-      /* And a version where the outer condition is negated.  */\n-      if (recognize_if_then_else (outer_cond_bb, &inner_cond_bb, &then_bb)\n-\t  && same_phi_args_p (outer_cond_bb, inner_cond_bb, then_bb)\n-\t  && bb_no_side_effects_p (inner_cond_bb))\n+      else if (forwarder_block_to (then_bb, else_bb))\n \t{\n-\t  /* We have\n-\t       <outer_cond_bb>\n-\t\t if (q) goto inner_cond_bb; else goto then_bb;\n-\t       <inner_cond_bb>\n-\t\t if (q) goto then_bb; else goto ...;\n-\t       <then_bb>\n-\t\t ...\n-\t   */\n-\t  return ifcombine_ifandif (inner_cond_bb, true, outer_cond_bb, false,\n-\t\t\t\t    true);\n+\t  /* Other possibilities for the || form, if then_bb is\n+\t     empty forwarder block to else_bb.  Compared to the above simpler\n+\t     forms this can be treated as if then_bb and else_bb were swapped,\n+\t     and the corresponding inner_cond_bb not inverted because of that.\n+\t     For same_phi_args_p we look at equality of arguments between\n+\t     edge from outer_cond_bb and the forwarder block.  */\n+\t  if (tree_ssa_ifcombine_bb_1 (inner_cond_bb, outer_cond_bb, else_bb,\n+\t\t\t\t       then_bb, then_bb))\n+\t    return true;\n \t}\n     }\n "}]}