{"sha": "6fa3d4b4a75e63276f5460a59395e1d3a634c477", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NmZhM2Q0YjRhNzVlNjMyNzZmNTQ2MGE1OTM5NWUxZDNhNjM0YzQ3Nw==", "commit": {"author": {"name": "Bin Cheng", "email": "bin.cheng@arm.com", "date": "2016-07-13T15:06:40Z"}, "committer": {"name": "Bin Cheng", "email": "amker@gcc.gnu.org", "date": "2016-07-13T15:06:40Z"}, "message": "tree-vect-data-refs.c (vect_no_alias_p): New function.\n\n\t* tree-vect-data-refs.c (vect_no_alias_p): New function.\n\t(vect_prune_runtime_alias_test_list): Call vect_no_alias_p to\n\tresolve alias checks which are known at compilation time.\n\tTruncate vector LOOP_VINFO_MAY_ALIAS_DDRS(loop_vinfo) if all\n\talias checks are resolved.  Move dump info for too many runtime\n\talias checks to here...\n\t* tree-vect-loop.c (vect_analyze_loop_2): ...From here.\n\n\tgcc/testsuite\n\t* gcc.dg/vect/vect-35-big-array.c: Refine comment and test.\n\t* gcc.dg/vect/vect-35.c: Ditto.\n\t* gcc.dg/vect/vect-alias-check-2.c: New test.\n\nFrom-SVN: r238301", "tree": {"sha": "da48e610f52224f60624eb2d668dad26e54d3861", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/da48e610f52224f60624eb2d668dad26e54d3861"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6fa3d4b4a75e63276f5460a59395e1d3a634c477", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6fa3d4b4a75e63276f5460a59395e1d3a634c477", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6fa3d4b4a75e63276f5460a59395e1d3a634c477", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6fa3d4b4a75e63276f5460a59395e1d3a634c477/comments", "author": null, "committer": null, "parents": [{"sha": "65f18bc635b2d6e9db318d3430f618f4219d8c13", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/65f18bc635b2d6e9db318d3430f618f4219d8c13", "html_url": "https://github.com/Rust-GCC/gccrs/commit/65f18bc635b2d6e9db318d3430f618f4219d8c13"}], "stats": {"total": 149, "additions": 130, "deletions": 19}, "files": [{"sha": "2862d0ed15f759b36e95a4171300093d7191cb6b", "filename": "gcc/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6fa3d4b4a75e63276f5460a59395e1d3a634c477/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6fa3d4b4a75e63276f5460a59395e1d3a634c477/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=6fa3d4b4a75e63276f5460a59395e1d3a634c477", "patch": "@@ -1,3 +1,13 @@\n+2016-07-13  Bin Cheng  <bin.cheng@arm.com>\n+\n+\t* tree-vect-data-refs.c (vect_no_alias_p): New function.\n+\t(vect_prune_runtime_alias_test_list): Call vect_no_alias_p to\n+\tresolve alias checks which are known at compilation time.\n+\tTruncate vector LOOP_VINFO_MAY_ALIAS_DDRS(loop_vinfo) if all\n+\talias checks are resolved.  Move dump info for too many runtime\n+\talias checks to here...\n+\t* tree-vect-loop.c (vect_analyze_loop_2): ...From here.\n+\n 2016-07-13  Richard Biener  <rguenther@suse.de>\n \n \tPR tree-optimization/24574"}, {"sha": "f868af33cc5401be0b57185ccd552f8fdba97c92", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6fa3d4b4a75e63276f5460a59395e1d3a634c477/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6fa3d4b4a75e63276f5460a59395e1d3a634c477/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=6fa3d4b4a75e63276f5460a59395e1d3a634c477", "patch": "@@ -1,3 +1,9 @@\n+2016-07-13  Bin Cheng  <bin.cheng@arm.com>\n+\n+\t* gcc.dg/vect/vect-35-big-array.c: Refine comment and test.\n+\t* gcc.dg/vect/vect-35.c: Ditto.\n+\t* gcc.dg/vect/vect-alias-check-2.c: New test.\n+\n 2016-07-13  Martin Liska  <mliska@suse.cz>\n \n \t* gfortran.dg/ldist-1.f90: Revert change introduces in r238114."}, {"sha": "ca57a10f714a126505f7d66d38f589ea2957d0f3", "filename": "gcc/testsuite/gcc.dg/vect/vect-35-big-array.c", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6fa3d4b4a75e63276f5460a59395e1d3a634c477/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-35-big-array.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6fa3d4b4a75e63276f5460a59395e1d3a634c477/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-35-big-array.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-35-big-array.c?ref=6fa3d4b4a75e63276f5460a59395e1d3a634c477", "patch": "@@ -21,7 +21,9 @@ int main1 ()\n     }\n \n   /* Dependence analysis fails cause s.a and s.b may overlap.\n-     Use runtime aliasing test with versioning.  */\n+     Try to use runtime aliasing test with versioning, and\n+     later versioning/vectorization are skipped because the\n+     overlap is proven at compilation time.  */\n   for (i = 0; i < N; i++)\n     {\n       s.a[i] = s.b[i] + 1;\n@@ -45,5 +47,5 @@ int main (void)\n }\n \n \n-/* { dg-final { scan-tree-dump-times \"vectorized 2 loops\" 1 \"vect\"  { xfail { ia64-*-* sparc*-*-* } } } } */\n-/* { dg-final { scan-tree-dump-times \"can't determine dependence between\" 1 \"vect\" } } */\n+/* { dg-final { scan-tree-dump-times \"vectorized 1 loops\" 1 \"vect\"  { xfail { ia64-*-* sparc*-*-* } } } } */\n+/* { dg-final { scan-tree-dump \"can't determine dependence between\" \"vect\" } } */"}, {"sha": "76fe32d68ad466c4d1933b1efc01727683cde027", "filename": "gcc/testsuite/gcc.dg/vect/vect-35.c", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6fa3d4b4a75e63276f5460a59395e1d3a634c477/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-35.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6fa3d4b4a75e63276f5460a59395e1d3a634c477/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-35.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-35.c?ref=6fa3d4b4a75e63276f5460a59395e1d3a634c477", "patch": "@@ -21,7 +21,9 @@ int main1 ()\n     }\n \n   /* Dependence analysis fails cause s.a and s.b may overlap.\n-     Use runtime aliasing test with versioning.  */\n+     Try to use runtime aliasing test with versioning, and\n+     later versioning/vectorization are skipped because the\n+     overlap is proven at compilation time.  */\n   for (i = 0; i < N; i++)\n     {\n       s.a[i] = s.b[i] + 1;\n@@ -45,5 +47,5 @@ int main (void)\n } \n \n \n-/* { dg-final { scan-tree-dump-times \"vectorized 2 loops\" 1 \"vect\"  { xfail { ia64-*-* sparc*-*-* } } } } */\n+/* { dg-final { scan-tree-dump-times \"vectorized 1 loops\" 1 \"vect\"  { xfail { ia64-*-* sparc*-*-* } } } } */\n /* { dg-final { scan-tree-dump \"can't determine dependence between\" \"vect\" } } */"}, {"sha": "116331452450b956f205b4a0b7f495ce18032bbc", "filename": "gcc/testsuite/gcc.dg/vect/vect-alias-check-2.c", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6fa3d4b4a75e63276f5460a59395e1d3a634c477/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-alias-check-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6fa3d4b4a75e63276f5460a59395e1d3a634c477/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-alias-check-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-alias-check-2.c?ref=6fa3d4b4a75e63276f5460a59395e1d3a634c477", "patch": "@@ -0,0 +1,19 @@\n+/* { dg-do compile } */\n+/* { dg-require-effective-target vect_int_mult } */\n+\n+int a [128];\n+int b[128] = {0};\n+\n+int foo (void)\n+{\n+  int k;\n+\n+  for(k=0; k<64; k++)\n+  {\n+    b[k] = 10 - b[127-k];\n+    a[k] = b[k] * 3;\n+    a[127-k] = b[127-k] * 2;\n+  }\n+}\n+\n+/* { dg-final { scan-tree-dump-not \"versioning for alias checks.\" \"vect\" } } */"}, {"sha": "9a5408e14a52a2da4795a85cd0fe5dae3775aaf5", "filename": "gcc/tree-vect-data-refs.c", "status": "modified", "additions": 85, "deletions": 5, "changes": 90, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6fa3d4b4a75e63276f5460a59395e1d3a634c477/gcc%2Ftree-vect-data-refs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6fa3d4b4a75e63276f5460a59395e1d3a634c477/gcc%2Ftree-vect-data-refs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-data-refs.c?ref=6fa3d4b4a75e63276f5460a59395e1d3a634c477", "patch": "@@ -2938,6 +2938,56 @@ vect_vfa_segment_size (struct data_reference *dr, tree length_factor)\n   return segment_length;\n }\n \n+/* Function vect_no_alias_p.\n+\n+   Given data references A and B with equal base and offset, the alias\n+   relation can be decided at compilation time, return TRUE if they do\n+   not alias to each other; return FALSE otherwise.  SEGMENT_LENGTH_A\n+   and SEGMENT_LENGTH_B are the memory lengths accessed by A and B\n+   respectively.  */\n+\n+static bool\n+vect_no_alias_p (struct data_reference *a, struct data_reference *b,\n+                 tree segment_length_a, tree segment_length_b)\n+{\n+  gcc_assert (TREE_CODE (DR_INIT (a)) == INTEGER_CST\n+\t      && TREE_CODE (DR_INIT (b)) == INTEGER_CST);\n+  if (tree_int_cst_equal (DR_INIT (a), DR_INIT (b)))\n+    return false;\n+\n+  tree seg_a_min = DR_INIT (a);\n+  tree seg_a_max = fold_build2 (PLUS_EXPR, TREE_TYPE (seg_a_min),\n+\t\t\t\tseg_a_min, segment_length_a);\n+  /* For negative step, we need to adjust address range by TYPE_SIZE_UNIT\n+     bytes, e.g., int a[3] -> a[1] range is [a+4, a+16) instead of\n+     [a, a+12) */\n+  if (tree_int_cst_compare (DR_STEP (a), size_zero_node) < 0)\n+    {\n+      tree unit_size = TYPE_SIZE_UNIT (TREE_TYPE (DR_REF (a)));\n+      seg_a_min = fold_build2 (PLUS_EXPR, TREE_TYPE (seg_a_max),\n+\t\t\t       seg_a_max, unit_size);\n+      seg_a_max = fold_build2 (PLUS_EXPR, TREE_TYPE (DR_INIT (a)),\n+\t\t\t       DR_INIT (a), unit_size);\n+    }\n+  tree seg_b_min = DR_INIT (b);\n+  tree seg_b_max = fold_build2 (PLUS_EXPR, TREE_TYPE (seg_b_min),\n+\t\t\t\tseg_b_min, segment_length_b);\n+  if (tree_int_cst_compare (DR_STEP (b), size_zero_node) < 0)\n+    {\n+      tree unit_size = TYPE_SIZE_UNIT (TREE_TYPE (DR_REF (b)));\n+      seg_b_min = fold_build2 (PLUS_EXPR, TREE_TYPE (seg_b_max),\n+\t\t\t       seg_b_max, unit_size);\n+      seg_b_max = fold_build2 (PLUS_EXPR, TREE_TYPE (DR_INIT (b)),\n+\t\t\t       DR_INIT (b), unit_size);\n+    }\n+\n+  if (tree_int_cst_le (seg_a_max, seg_b_min)\n+      || tree_int_cst_le (seg_b_max, seg_a_min))\n+    return true;\n+\n+  return false;\n+}\n+\n /* Function vect_prune_runtime_alias_test_list.\n \n    Prune a list of ddrs to be tested at run-time by versioning for alias.\n@@ -3030,15 +3080,33 @@ vect_prune_runtime_alias_test_list (loop_vec_info loop_vinfo)\n       segment_length_a = vect_vfa_segment_size (dr_a, length_factor);\n       segment_length_b = vect_vfa_segment_size (dr_b, length_factor);\n \n+      comp_res = compare_tree (DR_BASE_ADDRESS (dr_a), DR_BASE_ADDRESS (dr_b));\n+      if (comp_res == 0)\n+\tcomp_res = compare_tree (DR_OFFSET (dr_a), DR_OFFSET (dr_b));\n+\n+      /* Alias is known at compilation time.  */\n+      if (comp_res == 0\n+\t  && TREE_CODE (DR_STEP (dr_a)) == INTEGER_CST\n+\t  && TREE_CODE (DR_STEP (dr_b)) == INTEGER_CST\n+\t  && TREE_CODE (segment_length_a) == INTEGER_CST\n+\t  && TREE_CODE (segment_length_b) == INTEGER_CST)\n+\t{\n+\t  if (vect_no_alias_p (dr_a, dr_b, segment_length_a, segment_length_b))\n+\t    continue;\n+\n+\t  if (dump_enabled_p ())\n+\t    dump_printf_loc (MSG_NOTE, vect_location,\n+\t\t\t     \"not vectorized: compilation time alias.\\n\");\n+\n+\t  return false;\n+\t}\n+\n       dr_with_seg_len_pair_t dr_with_seg_len_pair\n \t  (dr_with_seg_len (dr_a, segment_length_a),\n \t   dr_with_seg_len (dr_b, segment_length_b));\n \n       /* Canonicalize pairs by sorting the two DR members.  */\n-      comp_res = compare_tree (DR_BASE_ADDRESS (dr_a), DR_BASE_ADDRESS (dr_b));\n-      if (comp_res > 0\n-          || (comp_res == 0\n-              && compare_tree (DR_OFFSET (dr_a), DR_OFFSET (dr_b)) > 0))\n+      if (comp_res > 0)\n \tstd::swap (dr_with_seg_len_pair.first, dr_with_seg_len_pair.second);\n \n       comp_alias_ddrs.safe_push (dr_with_seg_len_pair);\n@@ -3187,7 +3255,19 @@ vect_prune_runtime_alias_test_list (loop_vec_info loop_vinfo)\n \t\t   may_alias_ddrs.length (), comp_alias_ddrs.length ());\n   if ((int) comp_alias_ddrs.length () >\n       PARAM_VALUE (PARAM_VECT_MAX_VERSION_FOR_ALIAS_CHECKS))\n-    return false;\n+    {\n+      if (dump_enabled_p ())\n+\tdump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n+\t\t\t \"number of versioning for alias \"\n+\t\t\t \"run-time tests exceeds %d \"\n+\t\t\t \"(--param vect-max-version-for-alias-checks)\\n\",\n+\t\t\t PARAM_VALUE (PARAM_VECT_MAX_VERSION_FOR_ALIAS_CHECKS));\n+      return false;\n+    }\n+\n+  /* All alias checks have been resolved at compilation time.  */\n+  if (!comp_alias_ddrs.length ())\n+    LOOP_VINFO_MAY_ALIAS_DDRS (loop_vinfo).truncate (0);\n \n   return true;\n }"}, {"sha": "11863af66fc0d38550c212b72ea8585e2c2e7930", "filename": "gcc/tree-vect-loop.c", "status": "modified", "additions": 1, "deletions": 9, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6fa3d4b4a75e63276f5460a59395e1d3a634c477/gcc%2Ftree-vect-loop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6fa3d4b4a75e63276f5460a59395e1d3a634c477/gcc%2Ftree-vect-loop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-loop.c?ref=6fa3d4b4a75e63276f5460a59395e1d3a634c477", "patch": "@@ -1961,15 +1961,7 @@ vect_analyze_loop_2 (loop_vec_info loop_vinfo, bool &fatal)\n      since we use grouping information gathered by interleaving analysis.  */\n   ok = vect_prune_runtime_alias_test_list (loop_vinfo);\n   if (!ok)\n-    {\n-      if (dump_enabled_p ())\n-\tdump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n-\t\t\t \"number of versioning for alias \"\n-\t\t\t \"run-time tests exceeds %d \"\n-\t\t\t \"(--param vect-max-version-for-alias-checks)\\n\",\n-\t\t\t PARAM_VALUE (PARAM_VECT_MAX_VERSION_FOR_ALIAS_CHECKS));\n-      return false;\n-    }\n+    return false;\n \n   /* This pass will decide on using loop versioning and/or loop peeling in\n      order to enhance the alignment of data references in the loop.  */"}]}