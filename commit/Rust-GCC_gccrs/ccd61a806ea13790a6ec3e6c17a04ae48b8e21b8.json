{"sha": "ccd61a806ea13790a6ec3e6c17a04ae48b8e21b8", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Y2NkNjFhODA2ZWExMzc5MGE2ZWMzZTZjMTdhMDRhZTQ4YjhlMjFiOA==", "commit": {"author": {"name": "David S. Miller", "email": "davem@redhat.com", "date": "1999-12-13T01:20:07Z"}, "committer": {"name": "David S. Miller", "email": "davem@gcc.gnu.org", "date": "1999-12-13T01:20:07Z"}, "message": "sparc.md (movtf reg/reg split): Don't generate SUBREGs by hand, gen the appropriate hard reg directly.\n\n\t* config/sparc/sparc.md (movtf reg/reg split): Don't generate\n\tSUBREGs by hand, gen the appropriate hard reg directly.\n\t(movtf reg/mem split): Likewise and alter_subreg on destination\n\tif necessary.\n\t(movtf mem/reg split): Similarly.\n\t(movdf_cc_sp64): Rename from hidden pattern.\n\t(movtf_cc_hq_sp64): Renamed from movtf_cc_sp64.\n\t(movtf_cc_sp64, following split): New pattern and splitter.\n\t(movdf_cc_reg_sp64): Rename from hidden pattern.\n\t(movtf_cc_reg_hq_sp64): Renamed from movtf_cc_reg_sp64, require\n\tTARGET_HARD_QUAD.\n\t(movtf_cc_reg_sp64, following split): New pattern and splitter.\n\nCo-Authored-By: Jakub Jelinek <jakub@redhat.com>\n\nFrom-SVN: r30880", "tree": {"sha": "e4ba53e1087812c1f19fb9ffb7b71e21d1b44ffd", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e4ba53e1087812c1f19fb9ffb7b71e21d1b44ffd"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ccd61a806ea13790a6ec3e6c17a04ae48b8e21b8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ccd61a806ea13790a6ec3e6c17a04ae48b8e21b8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ccd61a806ea13790a6ec3e6c17a04ae48b8e21b8", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ccd61a806ea13790a6ec3e6c17a04ae48b8e21b8/comments", "author": null, "committer": null, "parents": [{"sha": "38b58895a4a73c3584de9606206be02c564e54b6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/38b58895a4a73c3584de9606206be02c564e54b6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/38b58895a4a73c3584de9606206be02c564e54b6"}], "stats": {"total": 208, "additions": 185, "deletions": 23}, "files": [{"sha": "10ac35ab122145b1c7fcb2a758df4ec822a81440", "filename": "gcc/ChangeLog", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ccd61a806ea13790a6ec3e6c17a04ae48b8e21b8/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ccd61a806ea13790a6ec3e6c17a04ae48b8e21b8/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=ccd61a806ea13790a6ec3e6c17a04ae48b8e21b8", "patch": "@@ -1,3 +1,19 @@\n+1999-12-12  David S. Miller  <davem@redhat.com>\n+\t    Jakub Jelinek    <jakub@redhat.com>\n+\n+\t* config/sparc/sparc.md (movtf reg/reg split): Don't generate\n+\tSUBREGs by hand, gen the appropriate hard reg directly.\n+\t(movtf reg/mem split): Likewise and alter_subreg on destination\n+\tif necessary.\n+\t(movtf mem/reg split): Similarly.\n+\t(movdf_cc_sp64): Rename from hidden pattern.\n+\t(movtf_cc_hq_sp64): Renamed from movtf_cc_sp64.\n+\t(movtf_cc_sp64, following split): New pattern and splitter.\n+\t(movdf_cc_reg_sp64): Rename from hidden pattern.\n+\t(movtf_cc_reg_hq_sp64): Renamed from movtf_cc_reg_sp64, require\n+\tTARGET_HARD_QUAD.\n+\t(movtf_cc_reg_sp64, following split): New pattern and splitter.\n+\n 1999-12-12  Stephen L Moshier <moshier@mediaone.net>\n \n \t* loop.c (load_mems): Don't hoist written floating point mem"}, {"sha": "87243ebd6c1a9fc5eb0a7d3ad7de5cf92284a6a3", "filename": "gcc/config/sparc/sparc.md", "status": "modified", "additions": 169, "deletions": 23, "changes": 192, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ccd61a806ea13790a6ec3e6c17a04ae48b8e21b8/gcc%2Fconfig%2Fsparc%2Fsparc.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ccd61a806ea13790a6ec3e6c17a04ae48b8e21b8/gcc%2Fconfig%2Fsparc%2Fsparc.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fsparc.md?ref=ccd61a806ea13790a6ec3e6c17a04ae48b8e21b8", "patch": "@@ -3643,11 +3643,14 @@\n   if (GET_CODE (set_src) == SUBREG)\n     set_src = alter_subreg (set_src);\n \n-  /* Ugly, but gen_highpart will crap out here for 32-bit targets.  */\n-  dest1 = gen_rtx_SUBREG (DFmode, set_dest, WORDS_BIG_ENDIAN == 0);\n-  dest2 = gen_rtx_SUBREG (DFmode, set_dest, WORDS_BIG_ENDIAN != 0);\n-  src1 = gen_rtx_SUBREG (DFmode, set_src, WORDS_BIG_ENDIAN == 0);\n-  src2 = gen_rtx_SUBREG (DFmode, set_src, WORDS_BIG_ENDIAN != 0);\n+  dest1 = gen_rtx_REG (DFmode,\n+                       REGNO (set_dest) + (WORDS_BIG_ENDIAN ? 0 : 2));\n+  dest2 = gen_rtx_REG (DFmode,\n+                       REGNO (set_dest) + (WORDS_BIG_ENDIAN ? 2 : 0));\n+  src1 = gen_rtx_REG (DFmode,\n+                      REGNO (set_src) + (WORDS_BIG_ENDIAN ? 0 : 2));\n+  src2 = gen_rtx_REG (DFmode,\n+                      REGNO (set_src) + (WORDS_BIG_ENDIAN ? 2 : 0));\n \n   /* Now emit using the real source and destination we found, swapping\n      the order if we detect overlap.  */\n@@ -3675,11 +3678,16 @@\n   rtx word0 = change_address (operands[1], DFmode, NULL_RTX);\n   rtx word1 = change_address (operands[1], DFmode,\n \t\t\t      plus_constant_for_output (XEXP (word0, 0), 8));\n-  rtx dest1, dest2;\n+  rtx set_dest, dest1, dest2;\n+\n+  set_dest = operands[0];\n+  if (GET_CODE (set_dest) == SUBREG)\n+    set_dest = alter_subreg (set_dest);\n \n-  /* Ugly, but gen_highpart will crap out here for 32-bit targets.  */\n-  dest1 = gen_rtx_SUBREG (DFmode, operands[0], WORDS_BIG_ENDIAN == 0);\n-  dest2 = gen_rtx_SUBREG (DFmode, operands[0], WORDS_BIG_ENDIAN != 0);\n+  dest1 = gen_rtx_REG (DFmode,\n+                       REGNO (set_dest) + (WORDS_BIG_ENDIAN ? 0 : 2));\n+  dest2 = gen_rtx_REG (DFmode,\n+                       REGNO (set_dest) + (WORDS_BIG_ENDIAN ? 2 : 0));\n \n   /* Now output, ordering such that we don't clobber any registers\n      mentioned in the address.  */\n@@ -3705,16 +3713,21 @@\n   [(clobber (const_int 0))]\n   \"\n {\n-  rtx word0 = change_address (operands[0], DFmode, NULL_RTX);\n-  rtx word1 = change_address (operands[0], DFmode,\n-\t\t\t      plus_constant_for_output (XEXP (word0, 0), 8));\n-  rtx src1, src2;\n+  rtx word1 = change_address (operands[0], DFmode, NULL_RTX);\n+  rtx word2 = change_address (operands[0], DFmode,\n+\t\t\t      plus_constant_for_output (XEXP (word1, 0), 8));\n+  rtx set_src, src1, src2;\n \n-  /* Ugly, but gen_highpart will crap out here for 32-bit targets.  */\n-  src1 = gen_rtx_SUBREG (DFmode, operands[1], WORDS_BIG_ENDIAN == 0);\n-  src2 = gen_rtx_SUBREG (DFmode, operands[1], WORDS_BIG_ENDIAN != 0);\n-  emit_insn (gen_movdf (word0, src1));\n-  emit_insn (gen_movdf (word1, src2));\n+  set_src = operands[1];\n+  if (GET_CODE (set_src) == SUBREG)\n+    set_src = alter_subreg (set_src);\n+\n+  src1 = gen_rtx_REG (DFmode,\n+                      REGNO (set_src) + (WORDS_BIG_ENDIAN ? 0 : 2));\n+  src2 = gen_rtx_REG (DFmode,\n+                      REGNO (set_src) + (WORDS_BIG_ENDIAN ? 2 : 0));\n+  emit_insn (gen_movdf (word1, src1));\n+  emit_insn (gen_movdf (word2, src2));\n   DONE;\n }\")\n \f\n@@ -4017,7 +4030,7 @@\n   [(set_attr \"type\" \"fpcmove\")\n    (set_attr \"length\" \"1\")])\n \n-(define_insn \"*movdf_cc_sp64\"\n+(define_insn \"movdf_cc_sp64\"\n   [(set (match_operand:DF 0 \"register_operand\" \"=e,e\")\n \t(if_then_else:DF (match_operator 1 \"comparison_operator\"\n \t\t\t\t[(match_operand 2 \"icc_or_fcc_reg_operand\" \"X,X\")\n@@ -4031,7 +4044,7 @@\n   [(set_attr \"type\" \"fpcmove\")\n    (set_attr \"length\" \"1\")])\n \n-(define_insn \"*movtf_cc_sp64\"\n+(define_insn \"*movtf_cc_hq_sp64\"\n   [(set (match_operand:TF 0 \"register_operand\" \"=e,e\")\n \t(if_then_else:TF (match_operator 1 \"comparison_operator\"\n \t\t\t\t[(match_operand 2 \"icc_or_fcc_reg_operand\" \"X,X\")\n@@ -4045,6 +4058,72 @@\n   [(set_attr \"type\" \"fpcmove\")\n    (set_attr \"length\" \"1\")])\n \n+(define_insn \"*movtf_cc_sp64\"\n+  [(set (match_operand:TF 0 \"register_operand\" \"=e,e\")\n+\t(if_then_else:TF (match_operator 1 \"comparison_operator\"\n+\t\t\t\t[(match_operand 2 \"icc_or_fcc_reg_operand\" \"X,X\")\n+\t\t\t\t (const_int 0)])\n+                         (match_operand:TF 3 \"register_operand\" \"e,0\")\n+                         (match_operand:TF 4 \"register_operand\" \"0,e\")))]\n+  \"TARGET_V9 && TARGET_FPU && !TARGET_HARD_QUAD\"\n+  \"#\"\n+  [(set_attr \"type\" \"fpcmove\")\n+   (set_attr \"length\" \"2\")])\n+\n+(define_split\n+  [(set (match_operand:TF 0 \"register_operand\" \"=e,e\")\n+\t(if_then_else:TF (match_operator 1 \"comparison_operator\"\n+\t\t\t\t[(match_operand 2 \"icc_or_fcc_reg_operand\" \"X,X\")\n+\t\t\t\t (const_int 0)])\n+                         (match_operand:TF 3 \"register_operand\" \"e,0\")\n+                         (match_operand:TF 4 \"register_operand\" \"0,e\")))]\n+  \"reload_completed && TARGET_V9 && TARGET_FPU && !TARGET_HARD_QUAD\"\n+  [(clobber (const_int 0))]\n+  \"\n+{\n+  rtx set_dest = operands[0];\n+  rtx set_srca = operands[3];\n+  rtx set_srcb = operands[4];\n+  int third = rtx_equal_p (set_dest, set_srca);\n+  rtx dest1, dest2;\n+  rtx srca1, srca2, srcb1, srcb2;\n+\n+  if (GET_CODE (set_dest) == SUBREG)\n+    set_dest = alter_subreg (set_dest);\n+  if (GET_CODE (set_srca) == SUBREG)\n+    set_srca = alter_subreg (set_srca);\n+  if (GET_CODE (set_srcb) == SUBREG)\n+    set_srcb = alter_subreg (set_srcb);\n+\n+  dest1 = gen_rtx_REG (DFmode,\n+                       REGNO (set_dest) + (WORDS_BIG_ENDIAN ? 0 : 2));\n+  dest2 = gen_rtx_REG (DFmode,\n+                       REGNO (set_dest) + (WORDS_BIG_ENDIAN ? 2 : 0));\n+  srca1 = gen_rtx_REG (DFmode,\n+                       REGNO (set_srca) + (WORDS_BIG_ENDIAN ? 0 : 2));\n+  srca2 = gen_rtx_REG (DFmode,\n+                       REGNO (set_srca) + (WORDS_BIG_ENDIAN ? 2 : 0));\n+  srcb1 = gen_rtx_REG (DFmode,\n+                       REGNO (set_srcb) + (WORDS_BIG_ENDIAN ? 0 : 2));\n+  srcb2 = gen_rtx_REG (DFmode,\n+                       REGNO (set_srcb) + (WORDS_BIG_ENDIAN ? 2 : 0));\n+\n+  /* Now emit using the real source and destination we found, swapping\n+     the order if we detect overlap.  */\n+  if ((third && reg_overlap_mentioned_p (dest1, srcb2))\n+      || (!third && reg_overlap_mentioned_p (dest1, srca2)))\n+    {\n+      emit_insn (gen_movdf_cc_sp64 (dest2, operands[1], operands[2], srca2, srcb2));\n+      emit_insn (gen_movdf_cc_sp64 (dest1, operands[1], operands[2], srca1, srcb1));\n+    }\n+  else\n+    {\n+      emit_insn (gen_movdf_cc_sp64 (dest1, operands[1], operands[2], srca1, srcb1));\n+      emit_insn (gen_movdf_cc_sp64 (dest2, operands[1], operands[2], srca2, srcb2));\n+    }\n+  DONE;\n+}\")\n+\n (define_insn \"*movqi_cc_reg_sp64\"\n   [(set (match_operand:QI 0 \"register_operand\" \"=r,r\")\n \t(if_then_else:QI (match_operator 1 \"v9_regcmp_op\"\n@@ -4130,7 +4209,7 @@\n   [(set_attr \"type\" \"fpcmove\")\n    (set_attr \"length\" \"1\")])\n \n-(define_insn \"*movdf_cc_reg_sp64\"\n+(define_insn \"movdf_cc_reg_sp64\"\n   [(set (match_operand:DF 0 \"register_operand\" \"=e,e\")\n \t(if_then_else:DF (match_operator 1 \"v9_regcmp_op\"\n \t\t\t\t[(match_operand:DI 2 \"register_operand\" \"r,r\")\n@@ -4144,19 +4223,86 @@\n   [(set_attr \"type\" \"fpcmove\")\n    (set_attr \"length\" \"1\")])\n \n-(define_insn \"*movtf_cc_reg_sp64\"\n+(define_insn \"*movtf_cc_reg_hq_sp64\"\n   [(set (match_operand:TF 0 \"register_operand\" \"=e,e\")\n \t(if_then_else:TF (match_operator 1 \"v9_regcmp_op\"\n \t\t\t\t[(match_operand:DI 2 \"register_operand\" \"r,r\")\n \t\t\t\t (const_int 0)])\n                          (match_operand:TF 3 \"register_operand\" \"e,0\")\n                          (match_operand:TF 4 \"register_operand\" \"0,e\")))]\n-  \"TARGET_ARCH64 && TARGET_FPU\"\n+  \"TARGET_ARCH64 && TARGET_FPU && TARGET_HARD_QUAD\"\n   \"@\n    fmovrq%D1\\\\t%2, %3, %0\n    fmovrq%d1\\\\t%2, %4, %0\"\n   [(set_attr \"type\" \"fpcmove\")\n    (set_attr \"length\" \"1\")])\n+\n+(define_insn \"*movtf_cc_reg_sp64\"\n+  [(set (match_operand:TF 0 \"register_operand\" \"=e,e\")\n+\t(if_then_else:TF (match_operator 1 \"v9_regcmp_op\"\n+\t\t\t\t[(match_operand:DI 2 \"register_operand\" \"r,r\")\n+\t\t\t\t (const_int 0)])\n+                         (match_operand:TF 3 \"register_operand\" \"e,0\")\n+                         (match_operand:TF 4 \"register_operand\" \"0,e\")))]\n+  \"TARGET_ARCH64 && TARGET_FPU && ! TARGET_HARD_QUAD\"\n+  \"#\"\n+  [(set_attr \"type\" \"fpcmove\")\n+   (set_attr \"length\" \"2\")])\n+\n+(define_split\n+  [(set (match_operand:TF 0 \"register_operand\" \"=e,e\")\n+\t(if_then_else:TF (match_operator 1 \"v9_regcmp_op\"\n+\t\t\t\t[(match_operand:DI 2 \"register_operand\" \"r,r\")\n+\t\t\t\t (const_int 0)])\n+                         (match_operand:TF 3 \"register_operand\" \"e,0\")\n+                         (match_operand:TF 4 \"register_operand\" \"0,e\")))]\n+  \"reload_completed && TARGET_ARCH64 && TARGET_FPU && ! TARGET_HARD_QUAD\"\n+  [(clobber (const_int 0))]\n+  \"\n+{\n+  rtx set_dest = operands[0];\n+  rtx set_srca = operands[3];\n+  rtx set_srcb = operands[4];\n+  int third = rtx_equal_p (set_dest, set_srca);\n+  rtx dest1, dest2;\n+  rtx srca1, srca2, srcb1, srcb2;\n+\n+  if (GET_CODE (set_dest) == SUBREG)\n+    set_dest = alter_subreg (set_dest);\n+  if (GET_CODE (set_srca) == SUBREG)\n+    set_srca = alter_subreg (set_srca);\n+  if (GET_CODE (set_srcb) == SUBREG)\n+    set_srcb = alter_subreg (set_srcb);\n+\n+  dest1 = gen_rtx_REG (DFmode,\n+                       REGNO (set_dest) + (WORDS_BIG_ENDIAN ? 0 : 2));\n+  dest2 = gen_rtx_REG (DFmode,\n+                       REGNO (set_dest) + (WORDS_BIG_ENDIAN ? 2 : 0));\n+  srca1 = gen_rtx_REG (DFmode,\n+                       REGNO (set_srca) + (WORDS_BIG_ENDIAN ? 0 : 2));\n+  srca2 = gen_rtx_REG (DFmode,\n+                       REGNO (set_srca) + (WORDS_BIG_ENDIAN ? 2 : 0));\n+  srcb1 = gen_rtx_REG (DFmode,\n+                       REGNO (set_srcb) + (WORDS_BIG_ENDIAN ? 0 : 2));\n+  srcb2 = gen_rtx_REG (DFmode,\n+                       REGNO (set_srcb) + (WORDS_BIG_ENDIAN ? 2 : 0));\n+\n+  /* Now emit using the real source and destination we found, swapping\n+     the order if we detect overlap.  */\n+  if ((third && reg_overlap_mentioned_p (dest1, srcb2))\n+      || (!third && reg_overlap_mentioned_p (dest1, srca2)))\n+    {\n+      emit_insn (gen_movdf_cc_reg_sp64 (dest2, operands[1], operands[2], srca2, srcb2));\n+      emit_insn (gen_movdf_cc_reg_sp64 (dest1, operands[1], operands[2], srca1, srcb1));\n+    }\n+  else\n+    {\n+      emit_insn (gen_movdf_cc_reg_sp64 (dest1, operands[1], operands[2], srca1, srcb1));\n+      emit_insn (gen_movdf_cc_reg_sp64 (dest2, operands[1], operands[2], srca2, srcb2));\n+    }\n+  DONE;\n+}\")\n+\n \f\n ;;- zero extension instructions\n "}]}