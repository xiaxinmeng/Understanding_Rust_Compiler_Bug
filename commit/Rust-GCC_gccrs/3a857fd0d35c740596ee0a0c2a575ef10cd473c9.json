{"sha": "3a857fd0d35c740596ee0a0c2a575ef10cd473c9", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6M2E4NTdmZDBkMzVjNzQwNTk2ZWUwYTBjMmE1NzVlZjEwY2Q0NzNjOQ==", "commit": {"author": {"name": "Thomas Preud'homme", "email": "thomas.preudhomme@arm.com", "date": "2015-05-12T08:01:29Z"}, "committer": {"name": "Thomas Preud'homme", "email": "thopre01@gcc.gnu.org", "date": "2015-05-12T08:01:29Z"}, "message": "combine.c i (set_nonzero_bits_and_sign_copies): Split code updating rsp->sign_bit_copies and rsp->nonzero_bits into ...\n\n2015-05-12  Thomas Preud'homme  <thomas.preudhomme@arm.com>\n\n    * combine.c i(set_nonzero_bits_and_sign_copies): Split code updating\n    rsp->sign_bit_copies and rsp->nonzero_bits into ...\n    (update_rsp_from_reg_equal): This.  Also use REG_EQUAL note on src if\n    present to get more accurate information about the number of sign bit\n    copies and non zero bits.\n\nFrom-SVN: r223034", "tree": {"sha": "737dea429ba623d54e8602a42e92aaa063bc47de", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/737dea429ba623d54e8602a42e92aaa063bc47de"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3a857fd0d35c740596ee0a0c2a575ef10cd473c9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3a857fd0d35c740596ee0a0c2a575ef10cd473c9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3a857fd0d35c740596ee0a0c2a575ef10cd473c9", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3a857fd0d35c740596ee0a0c2a575ef10cd473c9/comments", "author": {"login": "RoboTux", "id": 272327, "node_id": "MDQ6VXNlcjI3MjMyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/272327?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RoboTux", "html_url": "https://github.com/RoboTux", "followers_url": "https://api.github.com/users/RoboTux/followers", "following_url": "https://api.github.com/users/RoboTux/following{/other_user}", "gists_url": "https://api.github.com/users/RoboTux/gists{/gist_id}", "starred_url": "https://api.github.com/users/RoboTux/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RoboTux/subscriptions", "organizations_url": "https://api.github.com/users/RoboTux/orgs", "repos_url": "https://api.github.com/users/RoboTux/repos", "events_url": "https://api.github.com/users/RoboTux/events{/privacy}", "received_events_url": "https://api.github.com/users/RoboTux/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "dfc55d308ef79c55173542cd2bdea3ae92847a83", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dfc55d308ef79c55173542cd2bdea3ae92847a83", "html_url": "https://github.com/Rust-GCC/gccrs/commit/dfc55d308ef79c55173542cd2bdea3ae92847a83"}], "stats": {"total": 70, "additions": 54, "deletions": 16}, "files": [{"sha": "0af90650f647ffe4db7f8649c8de0033969ac7c1", "filename": "gcc/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3a857fd0d35c740596ee0a0c2a575ef10cd473c9/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3a857fd0d35c740596ee0a0c2a575ef10cd473c9/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=3a857fd0d35c740596ee0a0c2a575ef10cd473c9", "patch": "@@ -1,3 +1,11 @@\n+2015-05-12  Thomas Preud'homme  <thomas.preudhomme@arm.com>\n+\n+\t* combine.c i(set_nonzero_bits_and_sign_copies): Split code updating\n+\trsp->sign_bit_copies and rsp->nonzero_bits into ...\n+\t(update_rsp_from_reg_equal): This.  Also use REG_EQUAL note on src if\n+\tpresent to get more accurate information about the number of sign bit\n+\tcopies and non zero bits.\n+\n 2015-05-12  Richard Biener  <rguenther@suse.de>\n \n \t* tree-vect-slp.c (vect_build_slp_tree_1): For BB vectorization"}, {"sha": "274a2d93dbbd862b550ed945d3ed32ac35d81789", "filename": "gcc/combine.c", "status": "modified", "additions": 46, "deletions": 16, "changes": 62, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3a857fd0d35c740596ee0a0c2a575ef10cd473c9/gcc%2Fcombine.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3a857fd0d35c740596ee0a0c2a575ef10cd473c9/gcc%2Fcombine.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcombine.c?ref=3a857fd0d35c740596ee0a0c2a575ef10cd473c9", "patch": "@@ -1668,6 +1668,51 @@ sign_extend_short_imm (rtx src, machine_mode mode, unsigned int prec)\n }\n #endif\n \n+/* Update RSP for pseudo-register X from INSN's REG_EQUAL note (if one exists)\n+   and SET.  */\n+\n+static void\n+update_rsp_from_reg_equal (reg_stat_type *rsp, rtx_insn *insn, const_rtx set,\n+\t\t\t   rtx x)\n+{\n+  rtx reg_equal_note = insn ? find_reg_equal_equiv_note (insn) : NULL_RTX;\n+  unsigned HOST_WIDE_INT bits = 0;\n+  rtx reg_equal = NULL, src = SET_SRC (set);\n+  unsigned int num = 0;\n+\n+  if (reg_equal_note)\n+    reg_equal = XEXP (reg_equal_note, 0);\n+\n+#ifdef SHORT_IMMEDIATES_SIGN_EXTEND\n+  src = sign_extend_short_imm (src, GET_MODE (x), BITS_PER_WORD);\n+  if (reg_equal)\n+    reg_equal = sign_extend_short_imm (reg_equal, GET_MODE (x), BITS_PER_WORD);\n+#endif\n+\n+  /* Don't call nonzero_bits if it cannot change anything.  */\n+  if (rsp->nonzero_bits != ~(unsigned HOST_WIDE_INT) 0)\n+    {\n+      bits = nonzero_bits (src, nonzero_bits_mode);\n+      if (reg_equal && bits)\n+\tbits &= nonzero_bits (reg_equal, nonzero_bits_mode);\n+      rsp->nonzero_bits |= bits;\n+    }\n+\n+  /* Don't call num_sign_bit_copies if it cannot change anything.  */\n+  if (rsp->sign_bit_copies != 1)\n+    {\n+      num = num_sign_bit_copies (SET_SRC (set), GET_MODE (x));\n+      if (reg_equal && num != GET_MODE_PRECISION (GET_MODE (x)))\n+\t{\n+\t  unsigned int numeq = num_sign_bit_copies (reg_equal, GET_MODE (x));\n+\t  if (num == 0 || numeq > num)\n+\t    num = numeq;\n+\t}\n+      if (rsp->sign_bit_copies == 0 || num < rsp->sign_bit_copies)\n+\trsp->sign_bit_copies = num;\n+    }\n+}\n+\n /* Called via note_stores.  If X is a pseudo that is narrower than\n    HOST_BITS_PER_WIDE_INT and is being set, record what bits are known zero.\n \n@@ -1683,7 +1728,6 @@ static void\n set_nonzero_bits_and_sign_copies (rtx x, const_rtx set, void *data)\n {\n   rtx_insn *insn = (rtx_insn *) data;\n-  unsigned int num;\n \n   if (REG_P (x)\n       && REGNO (x) >= FIRST_PSEUDO_REGISTER\n@@ -1743,21 +1787,7 @@ set_nonzero_bits_and_sign_copies (rtx x, const_rtx set, void *data)\n       if (SET_DEST (set) == x\n \t  || (paradoxical_subreg_p (SET_DEST (set))\n \t      && SUBREG_REG (SET_DEST (set)) == x))\n-\t{\n-\t  rtx src = SET_SRC (set);\n-\n-#ifdef SHORT_IMMEDIATES_SIGN_EXTEND\n-\t  src = sign_extend_short_imm (src, GET_MODE (x), BITS_PER_WORD);\n-#endif\n-\n-\t  /* Don't call nonzero_bits if it cannot change anything.  */\n-\t  if (rsp->nonzero_bits != ~(unsigned HOST_WIDE_INT) 0)\n-\t    rsp->nonzero_bits |= nonzero_bits (src, nonzero_bits_mode);\n-\t  num = num_sign_bit_copies (SET_SRC (set), GET_MODE (x));\n-\t  if (rsp->sign_bit_copies == 0\n-\t      || rsp->sign_bit_copies > num)\n-\t    rsp->sign_bit_copies = num;\n-\t}\n+\tupdate_rsp_from_reg_equal (rsp, insn, set, x);\n       else\n \t{\n \t  rsp->nonzero_bits = GET_MODE_MASK (GET_MODE (x));"}]}