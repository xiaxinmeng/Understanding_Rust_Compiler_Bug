{"sha": "2199e5fade2d41cbdb19bb730e494613b9b7e262", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MjE5OWU1ZmFkZTJkNDFjYmRiMTliYjczMGU0OTQ2MTNiOWI3ZTI2Mg==", "commit": {"author": {"name": "Zack Weinberg", "email": "zack@gcc.gnu.org", "date": "2002-07-29T18:02:47Z"}, "committer": {"name": "Zack Weinberg", "email": "zack@gcc.gnu.org", "date": "2002-07-29T18:02:47Z"}, "message": "gensupport.c: Include hashtab.h.\n\n\t* gensupport.c: Include hashtab.h.\n\t(insn_elision, condition_table, hash_c_test, cmp_c_test,\n\tmaybe_eval_c_test): New routines and data structures to\n\tsupport insn elision.\n\t(init_md_reader): Read and initialize the condition_table.\n\t(read_md_rtx): Discard insn patterns whose C test is provably\n\talways false.\n\t* gensupport.h: Declare new functions and data structures.\n\n\t* genconditions.c, dummy-conditions.c: New files.\n\t* Makefile.in: Build genconditions; run it to construct\n\tinsn-conditions.c; build that and link it into most gen*\n\tprograms.\n\t(HOST_SUPPORT, HOST_EARLY_SUPPORT): New variables.\n\t(GEN): Delete, unused.\n\t(STAGESTUFF): Update.\n\n\t* gencodes.c: (gen_insn): #define CODE_FOR_xxx equal to\n\tCODE_FOR_nothing for all elided patterns.\n\t(main): Tweaked to support this.\n\t* genflags.c (gen_proto): Emit a static inline generator\n\tfunction here for all elided patterns, which simply returns\n\tNULL_RTX.\n\t(gen_insn): Do not define HAVE_xxx for elided patterns.\n\t(main): Tweaked to support this.  No need to forward-declare\n\tstruct rtx_def.\n\t* genrecog.c: Do not bother emitting the C test if it's known\n\tto be true at compile time.\n\nFrom-SVN: r55839", "tree": {"sha": "8880ef10951d3d1fbca761d1c3b95b762f0409e5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8880ef10951d3d1fbca761d1c3b95b762f0409e5"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2199e5fade2d41cbdb19bb730e494613b9b7e262", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2199e5fade2d41cbdb19bb730e494613b9b7e262", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2199e5fade2d41cbdb19bb730e494613b9b7e262", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2199e5fade2d41cbdb19bb730e494613b9b7e262/comments", "author": null, "committer": null, "parents": [{"sha": "6ab185d6a53a5d77b86144d26414b5167778384a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6ab185d6a53a5d77b86144d26414b5167778384a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6ab185d6a53a5d77b86144d26414b5167778384a"}], "stats": {"total": 661, "additions": 596, "deletions": 65}, "files": [{"sha": "e1e8fcaef8bf8938b9a59b4741f3c94edae2b00d", "filename": "gcc/ChangeLog", "status": "modified", "additions": 33, "deletions": 2, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2199e5fade2d41cbdb19bb730e494613b9b7e262/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2199e5fade2d41cbdb19bb730e494613b9b7e262/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=2199e5fade2d41cbdb19bb730e494613b9b7e262", "patch": "@@ -1,7 +1,38 @@\n+2002-07-29  Zack Weinberg  <zack@codesourcery.com>\n+\n+\t* gensupport.c: Include hashtab.h.\n+\t(insn_elision, condition_table, hash_c_test, cmp_c_test,\n+\tmaybe_eval_c_test): New routines and data structures to\n+\tsupport insn elision.\n+\t(init_md_reader): Read and initialize the condition_table.\n+\t(read_md_rtx): Discard insn patterns whose C test is provably\n+\talways false.\n+\t* gensupport.h: Declare new functions and data structures.\n+\n+\t* genconditions.c, dummy-conditions.c: New files.\n+\t* Makefile.in: Build genconditions; run it to construct\n+\tinsn-conditions.c; build that and link it into most gen*\n+\tprograms.\n+\t(HOST_SUPPORT, HOST_EARLY_SUPPORT): New variables.\n+\t(GEN): Delete, unused.\n+\t(STAGESTUFF): Update.\n+\n+\t* gencodes.c: (gen_insn): #define CODE_FOR_xxx equal to\n+\tCODE_FOR_nothing for all elided patterns.\n+\t(main): Tweaked to support this.\n+\t* genflags.c (gen_proto): Emit a static inline generator\n+\tfunction here for all elided patterns, which simply returns\n+\tNULL_RTX.\n+\t(gen_insn): Do not define HAVE_xxx for elided patterns.\n+\t(main): Tweaked to support this.  No need to forward-declare\n+\tstruct rtx_def.\n+\t* genrecog.c: Do not bother emitting the C test if it's known\n+\tto be true at compile time.\n+\n 2002-07-29  Mike Stump  <mrs@apple.com>\n \n-\t* config.gcc (target_gtfiles): Initialize, as otherwise cross compilers hosted on\n-\tpowerpc-apple-darwin6.0 won't even build.\n+\t* config.gcc (target_gtfiles): Initialize, as otherwise cross \n+\tcompilers hosted on powerpc-apple-darwin6.0 won't even build.\n \n 2002-07-29  Richard Earnshaw  <rearnsha@arm.com>\n "}, {"sha": "3fdd3023e305f10457ab8ed320a35fd338df37e6", "filename": "gcc/Makefile.in", "status": "modified", "additions": 79, "deletions": 38, "changes": 117, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2199e5fade2d41cbdb19bb730e494613b9b7e262/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2199e5fade2d41cbdb19bb730e494613b9b7e262/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=2199e5fade2d41cbdb19bb730e494613b9b7e262", "patch": "@@ -622,7 +622,9 @@ SYSLIBS = @GNAT_LIBEXC@\n HOST_LIBS = $(BUILD_LIBIBERTY)\n \n HOST_RTL = $(BUILD_PREFIX)rtl.o read-rtl.o $(BUILD_PREFIX)bitmap.o \\\n-\t\t$(BUILD_PREFIX)ggc-none.o gensupport.o\n+\t\t$(BUILD_PREFIX)ggc-none.o\n+HOST_SUPPORT = gensupport.o insn-conditions.o\n+HOST_EARLY_SUPPORT = gensupport.o dummy-conditions.o\n \n HOST_PRINT = $(BUILD_PREFIX)print-rtl.o\n HOST_ERRORS = $(BUILD_PREFIX)errors.o\n@@ -742,29 +744,20 @@ OBJS = alias.o bb-reorder.o bitmap.o builtins.o caller-save.o calls.o\t   \\\n \n BACKEND = main.o libbackend.a\n \n-# GEN files are listed separately, so they can be built before doing parallel\n-#  makes for cc1 or cc1plus.  Otherwise sequent parallel make attempts to load\n-#  them before rtl.o is compiled.\n-GEN= genemit$(build_exeext) genoutput$(build_exeext) genrecog$(build_exeext) \\\n- genextract$(build_exeext) genflags$(build_exeext) gencodes$(build_exeext)   \\\n- genconfig$(build_exeext) genpeep$(build_exeext) gengenrtl$(build_exeext)    \\\n- gencheck$(build_exeext) genpreds$(build_exeext) genconstants$(build_exeext) \\\n- gengtype$(build_exeext)\n-\n # Files to be copied away after each stage in building.\n STAGESTUFF = *$(objext) insn-flags.h insn-config.h insn-codes.h \\\n  insn-output.c insn-recog.c insn-emit.c insn-extract.c insn-peep.c \\\n  insn-attr.h insn-attrtab.c insn-opinit.c insn-constants.h tm-preds.h \\\n- tree-check.h \\\n+ tree-check.h insn-conditions.c \\\n  s-flags s-config s-codes s-mlib s-under s-genrtl s-gtype gtyp-gen.h \\\n- s-output s-recog s-emit s-extract s-peep s-check \\\n+ s-output s-recog s-emit s-extract s-peep s-check s-conditions \\\n  s-attr s-attrtab s-opinit s-preds s-constants s-crt0 \\\n  genemit$(build_exeext) genoutput$(build_exeext) genrecog$(build_exeext) \\\n  genextract$(build_exeext) genflags$(build_exeext) gencodes$(build_exeext) \\\n  genconfig$(build_exeext) genpeep$(build_exeext) genattrtab$(build_exeext) \\\n  genattr$(build_exeext) genopinit$(build_exeext) gengenrtl$(build_exeext) \\\n  gencheck$(build_exeext) genpreds$(build_exeext) genconstants$(build_exeext) \\\n- gengtype$(build_exeext) \\\n+ gengtype$(build_exeext) genconditions$(build_exeext) \\\n  genrtl.c genrtl.h gt-*.h gtype-*.h gtype-desc.c \\\n  xgcc$(exeext) cpp$(exeext) cc1$(exeext) $(EXTRA_PASSES) \\\n  $(EXTRA_PARTS) $(EXTRA_PROGRAMS) gcc-cross$(exeext) cc1obj$(exeext) \\\n@@ -1698,6 +1691,21 @@ s-config : $(md_file) genconfig$(build_exeext) $(srcdir)/move-if-change\n \t$(SHELL) $(srcdir)/move-if-change tmp-config.h insn-config.h\n \t$(STAMP) s-config\n \n+insn-conditions.c: s-conditions ; @true\n+s-conditions : $(md_file) genconditions$(build_exeext) $(srcdir)/move-if-change\n+\t./genconditions$(build_exeext) $(md_file) > tmp-conditions.c\n+\t$(SHELL) $(srcdir)/move-if-change tmp-conditions.c insn-conditions.c\n+\t$(STAMP) s-conditions\n+\n+insn-conditions.o : insn-conditions.c $(GCONFIG_H) $(SYSTEM_H) $(RTL_H) \\\n+  $(TM_P_H) $(REGS_H) function.h $(RECOG_H) real.h output.h flags.h \\\n+  hard-reg-set.h resource.h toplev.h reload.h gensupport.h insn-constants.h\n+\t$(HOST_CC) -c $(HOST_CFLAGS) $(HOST_CPPFLAGS) $(INCLUDES) insn-conditions.c\n+\n+dummy-conditions.o : dummy-conditions.c $(GCONFIG_H) $(SYSTEM_H) gensupport.h\n+\t$(HOST_CC) -c $(HOST_CFLAGS) $(HOST_CPPFLAGS) $(INCLUDES) \\\n+\t    $(srcdir)/dummy-conditions.c $(OUTPUT_OPTION)\n+\n insn-flags.h: s-flags ; @true\n s-flags : $(md_file) genflags$(build_exeext) $(srcdir)/move-if-change\n \t./genflags$(build_exeext) $(md_file) > tmp-flags.h\n@@ -1904,88 +1912,109 @@ read-rtl.o: read-rtl.c $(HCONFIG_H) $(SYSTEM_H) $(RTL_H) \\\n gensupport.o: gensupport.c $(RTL_H) $(OBSTACK_H) $(SYSTEM_H) errors.h gensupport.h\n \t$(HOST_CC) -c $(HOST_CFLAGS) $(HOST_CPPFLAGS) $(INCLUDES) $(srcdir)/gensupport.c $(OUTPUT_OPTION)\n \n-genconfig$(build_exeext) : genconfig.o $(HOST_RTL) $(HOST_PRINT) $(HOST_ERRORS) $(HOST_LIBDEPS)\n+genconfig$(build_exeext) : genconfig.o $(HOST_RTL) $(HOST_SUPPORT) \\\n+  $(HOST_PRINT) $(HOST_ERRORS) $(HOST_LIBDEPS)\n \t$(HOST_CC) $(HOST_CFLAGS) $(HOST_LDFLAGS) -o $@ \\\n-\t  genconfig.o $(HOST_RTL) $(HOST_PRINT) $(HOST_ERRORS) $(HOST_LIBS)\n+\t  genconfig.o $(HOST_RTL) $(HOST_SUPPORT) $(HOST_PRINT) \\\n+\t    $(HOST_ERRORS) $(HOST_LIBS)\n \n genconfig.o : genconfig.c $(RTL_H) $(HCONFIG_H) \\\n   $(SYSTEM_H) errors.h gensupport.h\n \t$(HOST_CC) -c $(HOST_CFLAGS) $(HOST_CPPFLAGS) $(INCLUDES) $(srcdir)/genconfig.c $(OUTPUT_OPTION)\n \n-genflags$(build_exeext) : genflags.o $(HOST_RTL) $(HOST_PRINT) $(HOST_ERRORS) $(HOST_LIBDEPS)\n+genflags$(build_exeext) : genflags.o $(HOST_RTL) $(HOST_SUPPORT) \\\n+  $(HOST_PRINT) $(HOST_ERRORS) $(HOST_LIBDEPS)\n \t$(HOST_CC) $(HOST_CFLAGS) $(HOST_LDFLAGS) -o $@ \\\n-\t genflags.o $(HOST_RTL) $(HOST_PRINT) $(HOST_ERRORS) $(HOST_LIBS)\n+\t genflags.o $(HOST_RTL) $(HOST_SUPPORT) $(HOST_PRINT) \\\n+\t    $(HOST_ERRORS) $(HOST_LIBS)\n \n genflags.o : genflags.c $(RTL_H) $(OBSTACK_H) $(HCONFIG_H) \\\n   $(SYSTEM_H) errors.h gensupport.h\n \t$(HOST_CC) -c $(HOST_CFLAGS) $(HOST_CPPFLAGS) $(INCLUDES) $(srcdir)/genflags.c $(OUTPUT_OPTION)\n \n-gencodes$(build_exeext) : gencodes.o $(HOST_RTL) $(HOST_PRINT) $(HOST_ERRORS) $(HOST_LIBDEPS)\n+gencodes$(build_exeext) : gencodes.o $(HOST_RTL) $(HOST_SUPPORT) \\\n+  $(HOST_PRINT) $(HOST_ERRORS) $(HOST_LIBDEPS)\n \t$(HOST_CC) $(HOST_CFLAGS) $(HOST_LDFLAGS) -o $@ \\\n-\t gencodes.o $(HOST_RTL) $(HOST_PRINT) $(HOST_ERRORS) $(HOST_LIBS)\n+\t gencodes.o $(HOST_RTL) $(HOST_SUPPORT) $(HOST_PRINT) \\\n+\t    $(HOST_ERRORS) $(HOST_LIBS)\n \n gencodes.o : gencodes.c $(RTL_H) $(HCONFIG_H) \\\n   $(SYSTEM_H) errors.h gensupport.h\n \t$(HOST_CC) -c $(HOST_CFLAGS) $(HOST_CPPFLAGS) $(INCLUDES) $(srcdir)/gencodes.c $(OUTPUT_OPTION)\n \n-genconstants$(build_exeext) : genconstants.o $(HOST_RTL) $(HOST_ERRORS) $(HOST_LIBDEPS)\n+genconstants$(build_exeext) : genconstants.o $(HOST_RTL) $(HOST_EARLY_SUPPORT) \\\n+  $(HOST_ERRORS) $(HOST_LIBDEPS)\n \t$(HOST_CC) $(HOST_CFLAGS) $(HOST_LDFLAGS) -o $@ \\\n-\t genconstants.o $(HOST_RTL) $(HOST_ERRORS) $(HOST_LIBS)\n+\t genconstants.o $(HOST_EARLY_SUPPORT) $(HOST_RTL) \\\n+\t    $(HOST_ERRORS) $(HOST_LIBS)\n \n genconstants.o : genconstants.c $(RTL_H) $(HCONFIG_H) $(SYSTEM_H) errors.h\n \t$(HOST_CC) -c $(HOST_CFLAGS) $(HOST_CPPFLAGS) $(INCLUDES) $(srcdir)/genconstants.c $(OUTPUT_OPTION)\n \n-genemit$(build_exeext) : genemit.o $(HOST_RTL) $(HOST_PRINT) $(HOST_ERRORS) $(HOST_LIBDEPS)\n+genemit$(build_exeext) : genemit.o $(HOST_RTL) $(HOST_SUPPORT) \\\n+  $(HOST_PRINT) $(HOST_ERRORS) $(HOST_LIBDEPS)\n \t$(HOST_CC) $(HOST_CFLAGS) $(HOST_LDFLAGS) -o $@ \\\n-\t genemit.o $(HOST_RTL) $(HOST_PRINT) $(HOST_ERRORS) $(HOST_LIBS)\n+\t genemit.o $(HOST_RTL) $(HOST_SUPPORT) $(HOST_PRINT) \\\n+\t    $(HOST_ERRORS) $(HOST_LIBS)\n \n genemit.o : genemit.c $(RTL_H) $(HCONFIG_H) $(SYSTEM_H) errors.h gensupport.h\n \t$(HOST_CC) -c $(HOST_CFLAGS) $(HOST_CPPFLAGS) $(INCLUDES) $(srcdir)/genemit.c $(OUTPUT_OPTION)\n \n-genopinit$(build_exeext) : genopinit.o $(HOST_RTL) $(HOST_PRINT) $(HOST_ERRORS) $(HOST_LIBDEPS)\n+genopinit$(build_exeext) : genopinit.o $(HOST_RTL) $(HOST_SUPPORT) \\\n+  $(HOST_PRINT) $(HOST_ERRORS) $(HOST_LIBDEPS)\n \t$(HOST_CC) $(HOST_CFLAGS) $(HOST_LDFLAGS) -o $@ \\\n-\t genopinit.o $(HOST_RTL) $(HOST_PRINT) $(HOST_ERRORS) $(HOST_LIBS)\n+\t genopinit.o $(HOST_RTL) $(HOST_SUPPORT) $(HOST_PRINT) \\\n+\t    $(HOST_ERRORS) $(HOST_LIBS)\n \n genopinit.o : genopinit.c $(RTL_H) $(HCONFIG_H) \\\n   $(SYSTEM_H) errors.h gensupport.h\n \t$(HOST_CC) -c $(HOST_CFLAGS) $(HOST_CPPFLAGS) $(INCLUDES) $(srcdir)/genopinit.c $(OUTPUT_OPTION)\n \n-genrecog$(build_exeext) : genrecog.o $(HOST_RTL) $(HOST_PRINT) $(HOST_ERRORS) $(HOST_LIBDEPS)\n+genrecog$(build_exeext) : genrecog.o $(HOST_RTL) $(HOST_SUPPORT) \\\n+    $(HOST_PRINT) $(HOST_ERRORS) $(HOST_LIBDEPS)\n \t$(HOST_CC) $(HOST_CFLAGS) $(HOST_LDFLAGS) -o $@ \\\n-\t genrecog.o $(HOST_RTL) $(HOST_PRINT) $(HOST_ERRORS) $(HOST_LIBS)\n+\t genrecog.o $(HOST_RTL) $(HOST_SUPPORT) $(HOST_PRINT) \\\n+\t    $(HOST_ERRORS) $(HOST_LIBS)\n \n genrecog.o : genrecog.c $(RTL_H) $(HCONFIG_H) \\\n   $(SYSTEM_H) errors.h gensupport.h\n \t$(HOST_CC) -c $(HOST_CFLAGS) $(HOST_CPPFLAGS) $(INCLUDES) $(srcdir)/genrecog.c $(OUTPUT_OPTION)\n \n-genextract$(build_exeext) : genextract.o $(HOST_RTL) $(HOST_PRINT) $(HOST_ERRORS) $(HOST_LIBDEPS)\n+genextract$(build_exeext) : genextract.o $(HOST_RTL) $(HOST_SUPPORT) \\\n+  $(HOST_PRINT) $(HOST_ERRORS) $(HOST_LIBDEPS)\n \t$(HOST_CC) $(HOST_CFLAGS) $(HOST_LDFLAGS) -o $@ \\\n-\t genextract.o $(HOST_RTL) $(HOST_PRINT) $(HOST_ERRORS) $(HOST_LIBS)\n+\t genextract.o $(HOST_RTL) $(HOST_SUPPORT) $(HOST_PRINT) \\\n+\t    $(HOST_ERRORS) $(HOST_LIBS)\n \n genextract.o : genextract.c $(RTL_H) $(HCONFIG_H) \\\n   $(SYSTEM_H) insn-config.h errors.h gensupport.h\n \t$(HOST_CC) -c $(HOST_CFLAGS) $(HOST_CPPFLAGS) $(INCLUDES) $(srcdir)/genextract.c $(OUTPUT_OPTION)\n \n-genpeep$(build_exeext) : genpeep.o $(HOST_RTL) $(HOST_PRINT) $(HOST_ERRORS) $(HOST_LIBDEPS)\n+genpeep$(build_exeext) : genpeep.o $(HOST_RTL) $(HOST_SUPPORT) \\\n+  $(HOST_PRINT) $(HOST_ERRORS) $(HOST_LIBDEPS)\n \t$(HOST_CC) $(HOST_CFLAGS) $(HOST_LDFLAGS) -o $@ \\\n-\t genpeep.o $(HOST_RTL) $(HOST_PRINT) $(HOST_ERRORS) $(HOST_LIBS)\n+\t genpeep.o $(HOST_RTL) $(HOST_SUPPORT) $(HOST_PRINT) \\\n+\t    $(HOST_ERRORS) $(HOST_LIBS)\n \n genpeep.o : genpeep.c $(RTL_H) $(HCONFIG_H) $(SYSTEM_H) errors.h gensupport.h\n \t$(HOST_CC) -c $(HOST_CFLAGS) $(HOST_CPPFLAGS) $(INCLUDES) $(srcdir)/genpeep.c $(OUTPUT_OPTION)\n \n-genattr$(build_exeext) : genattr.o $(HOST_RTL) $(HOST_PRINT) $(HOST_ERRORS) $(HOST_LIBDEPS)\n+genattr$(build_exeext) : genattr.o $(HOST_RTL) $(HOST_SUPPORT) \\\n+  $(HOST_PRINT) $(HOST_ERRORS) $(HOST_LIBDEPS)\n \t$(HOST_CC) $(HOST_CFLAGS) $(HOST_LDFLAGS) -o $@ \\\n-\t genattr.o $(HOST_RTL) $(HOST_PRINT) $(HOST_ERRORS) $(HOST_LIBS)\n+\t genattr.o $(HOST_RTL) $(HOST_SUPPORT) $(HOST_PRINT) \\\n+\t    $(HOST_ERRORS) $(HOST_LIBS)\n \n genattr.o : genattr.c $(RTL_H) $(HCONFIG_H) $(SYSTEM_H) errors.h gensupport.h\n \t$(HOST_CC) -c $(HOST_CFLAGS) $(HOST_CPPFLAGS) $(INCLUDES) $(srcdir)/genattr.c $(OUTPUT_OPTION)\n \n genattrtab$(build_exeext) : genattrtab.o genautomata.o \\\n-  $(HOST_RTL) $(HOST_PRINT) $(HOST_ERRORS) $(HOST_VARRAY) $(HOST_LIBDEPS)\n+  $(HOST_RTL) $(HOST_SUPPORT) $(HOST_PRINT) $(HOST_ERRORS) $(HOST_VARRAY) \\\n+  $(HOST_LIBDEPS)\n \t$(HOST_CC) $(HOST_CFLAGS) $(HOST_LDFLAGS) -o $@ \\\n \t genattrtab.o genautomata.o \\\n-\t $(HOST_RTL) $(HOST_PRINT) $(HOST_ERRORS) $(HOST_VARRAY) \\\n-\t $(HOST_LIBS) -lm\n+\t $(HOST_RTL) $(HOST_SUPPORT) $(HOST_PRINT) $(HOST_ERRORS) \\\n+\t $(HOST_VARRAY) $(HOST_LIBS) -lm\n \n genattrtab.o : genattrtab.c $(RTL_H) $(OBSTACK_H) $(HCONFIG_H) \\\n   $(SYSTEM_H) errors.h $(GGC_H) gensupport.h genattrtab.h\n@@ -1995,9 +2024,11 @@ genautomata.o : genautomata.c $(RTL_H) $(OBSTACK_H) $(HCONFIG_H) \\\n   $(SYSTEM_H) errors.h varray.h genattrtab.h $(HASHTAB_H)\n \t$(HOST_CC) -c $(HOST_CFLAGS) $(HOST_CPPFLAGS) $(INCLUDES) $(srcdir)/genautomata.c $(OUTPUT_OPTION)\n \n-genoutput$(build_exeext) : genoutput.o $(HOST_RTL) $(HOST_PRINT) $(HOST_ERRORS) $(HOST_LIBDEPS)\n+genoutput$(build_exeext) : genoutput.o $(HOST_RTL) $(HOST_SUPPORT) \\\n+  $(HOST_PRINT) $(HOST_ERRORS) $(HOST_LIBDEPS)\n \t$(HOST_CC) $(HOST_CFLAGS) $(HOST_LDFLAGS) -o $@ \\\n-\t genoutput.o $(HOST_RTL) $(HOST_PRINT) $(HOST_ERRORS) $(HOST_LIBS)\n+\t genoutput.o $(HOST_RTL) $(HOST_SUPPORT) $(HOST_PRINT) \\\n+\t    $(HOST_ERRORS) $(HOST_LIBS)\n \n genoutput.o : genoutput.c $(RTL_H) $(HCONFIG_H) \\\n   $(SYSTEM_H) errors.h gensupport.h\n@@ -2052,6 +2083,16 @@ $(srcdir)/gengtype-yacc.c: $(srcdir)/gengtype-yacc.y\n \t $(BISON) $(BISONFLAGS) -d -o gengtype-yacc.c gengtype-yacc.y || \\\n \t ( rm -f $@ && false ) )\n \n+genconditions$(build_exeext) : genconditions.o $(HOST_EARLY_SUPPORT) \\\n+  $(HOST_RTL) $(HOST_ERRORS) $(HOST_LIBDEPS)\n+\t$(HOST_CC) $(HOST_CFLAGS) $(HOST_LDFLAGS) -o $@ \\\n+\t genconditions.o $(HOST_EARLY_SUPPORT) $(HOST_RTL) \\\n+\t    $(HOST_ERRORS) $(HOST_LIBS)\n+\n+genconditions.o : genconditions.c $(RTL_H) $(HCONFIG_H) $(SYSTEM_H) errors.h\n+\t$(HOST_CC) -c $(HOST_CFLAGS) $(HOST_CPPFLAGS) $(INCLUDES) \\\n+\t\t$(srcdir)/genconditions.c $(OUTPUT_OPTION)\n+\n #\f\n # Compile the libraries to be used by gen*.\n # If we are not cross-building, gen* use the same .o's that cc1 will use,"}, {"sha": "157f86bd639d81d21e26395a75f00dcabb2c494c", "filename": "gcc/dummy-conditions.c", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2199e5fade2d41cbdb19bb730e494613b9b7e262/gcc%2Fdummy-conditions.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2199e5fade2d41cbdb19bb730e494613b9b7e262/gcc%2Fdummy-conditions.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdummy-conditions.c?ref=2199e5fade2d41cbdb19bb730e494613b9b7e262", "patch": "@@ -0,0 +1,34 @@\n+/* Support for calculating constant conditions.\n+   Copyright (C) 2002 Free Software Foundation, Inc.\n+\n+   This file is part of GNU CC.\n+\n+   GNU CC is free software; you can redistribute it and/or modify\n+   it under the terms of the GNU General Public License as published by\n+   the Free Software Foundation; either version 2, or (at your option)\n+   any later version.\n+\n+   GNU CC is distributed in the hope that it will be useful,\n+   but WITHOUT ANY WARRANTY; without even the implied warranty of\n+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+   GNU General Public License for more details.\n+\n+   You should have received a copy of the GNU General Public License\n+   along with GNU CC; see the file COPYING.  If not, write to\n+   the Free Software Foundation, 59 Temple Place - Suite 330,\n+   Boston, MA 02111-1307, USA.  */\n+\n+#include \"hconfig.h\"\n+#include \"system.h\"\n+#include \"gensupport.h\"\n+\n+/* MD generators that are run before insn-conditions.c exists should\n+   link against this file instead.  Currently that is genconditions\n+   and genconstants.  */\n+\n+/* Empty conditions table to prevent link errors.  */\n+const struct c_test insn_conditions[1] = { { 0, 0 } };\n+const size_t n_insn_conditions = 0;\n+\n+/* Disable insn elision, since it is currently impossible.  */\n+const int insn_elision_unavailable = 1;"}, {"sha": "5a292821c393152364f245c6035595fc8fe92cba", "filename": "gcc/gencodes.c", "status": "modified", "additions": 18, "deletions": 6, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2199e5fade2d41cbdb19bb730e494613b9b7e262/gcc%2Fgencodes.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2199e5fade2d41cbdb19bb730e494613b9b7e262/gcc%2Fgencodes.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgencodes.c?ref=2199e5fade2d41cbdb19bb730e494613b9b7e262", "patch": "@@ -28,18 +28,26 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n #include \"errors.h\"\n #include \"gensupport.h\"\n \n-static void gen_insn PARAMS ((const char *, int));\n+static void gen_insn PARAMS ((rtx, int));\n \n static void\n-gen_insn (name, code)\n-     const char *name;\n+gen_insn (insn, code)\n+     rtx insn;\n      int code;\n {\n+  const char *name = XSTR (insn, 0);\n+  int truth = maybe_eval_c_test (XSTR (insn, 2));\n+\n   /* Don't mention instructions whose names are the null string\n      or begin with '*'.  They are in the machine description just\n      to be recognized.  */\n   if (name[0] != 0 && name[0] != '*')\n-    printf (\"  CODE_FOR_%s = %d,\\n\", name, code);\n+    {\n+      if (truth == 0)\n+\tprintf (\"#define CODE_FOR_%s CODE_FOR_nothing\\n\", name);\n+      else\n+\tprintf (\"  CODE_FOR_%s = %d,\\n\", name, code);\n+    }\n }\n \n extern int main PARAMS ((int, char **));\n@@ -53,6 +61,10 @@ main (argc, argv)\n \n   progname = \"gencodes\";\n \n+  /* We need to see all the possibilities.  Elided insns may have\n+     direct references to CODE_FOR_xxx in C code.  */\n+  insn_elision = 0;\n+\n   if (argc <= 1)\n     fatal (\"no input file name\");\n \n@@ -80,10 +92,10 @@ enum insn_code {\");\n \tbreak;\n \n       if (GET_CODE (desc) == DEFINE_INSN || GET_CODE (desc) == DEFINE_EXPAND)\n-\tgen_insn (XSTR (desc, 0), insn_code_number);\n+\tgen_insn (desc, insn_code_number);\n     }\n \n-  puts (\"CODE_FOR_nothing\\n\\\n+  puts (\"  CODE_FOR_nothing\\n\\\n };\\n\\\n \\n\\\n #endif /* GCC_INSN_CODES_H */\");"}, {"sha": "02f80ee478de2e70240f614b86c7ce112fe3a9f3", "filename": "gcc/genconditions.c", "status": "added", "additions": 240, "deletions": 0, "changes": 240, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2199e5fade2d41cbdb19bb730e494613b9b7e262/gcc%2Fgenconditions.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2199e5fade2d41cbdb19bb730e494613b9b7e262/gcc%2Fgenconditions.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgenconditions.c?ref=2199e5fade2d41cbdb19bb730e494613b9b7e262", "patch": "@@ -0,0 +1,240 @@\n+/* Process machine description and calculate constant conditions.\n+   Copyright (C) 2001, 2002 Free Software Foundation, Inc.\n+\n+   This file is part of GNU CC.\n+\n+   GNU CC is free software; you can redistribute it and/or modify\n+   it under the terms of the GNU General Public License as published by\n+   the Free Software Foundation; either version 2, or (at your option)\n+   any later version.\n+\n+   GNU CC is distributed in the hope that it will be useful,\n+   but WITHOUT ANY WARRANTY; without even the implied warranty of\n+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+   GNU General Public License for more details.\n+\n+   You should have received a copy of the GNU General Public License\n+   along with GNU CC; see the file COPYING.  If not, write to\n+   the Free Software Foundation, 59 Temple Place - Suite 330,\n+   Boston, MA 02111-1307, USA.  */\n+\n+/* In a machine description, all of the insn patterns - define_insn,\n+   define_expand, define_split, define_peephole, define_peephole2 -\n+   contain an optional C expression which makes the final decision\n+   about whether or not this pattern is usable.  That expression may\n+   turn out to be always false when the compiler is built.  If it is,\n+   most of the programs that generate code from the machine\n+   description can simply ignore the entire pattern.  */\n+\n+#include \"hconfig.h\"\n+#include \"system.h\"\n+#include \"rtl.h\"\n+#include \"errors.h\"\n+#include \"hashtab.h\"\n+#include \"gensupport.h\"\n+\n+/* so we can include except.h in the generated file */\n+static int saw_eh_return;\n+\n+static htab_t condition_table;\n+\n+static void add_condition\tPARAMS ((const char *));\n+static void write_header\tPARAMS ((void));\n+static void write_conditions\tPARAMS ((void));\n+static int write_one_condition\tPARAMS ((PTR *, PTR));\n+\n+extern int main\t\t\tPARAMS ((int, char **));\n+\n+/* Record the C test expression EXPR in the condition_table.\n+   Duplicates clobber previous entries, which leaks memory, but\n+   we don't care for this application.  */\n+\n+static void\n+add_condition (expr)\n+     const char *expr;\n+{\n+  struct c_test *test;\n+\n+  if (expr[0] == 0)\n+    return;\n+\n+  test = (struct c_test *) xmalloc (sizeof (struct c_test));\n+  test->expr = expr;\n+\n+  *(htab_find_slot (condition_table, test, INSERT)) = test;\n+}\n+\n+/* Generate the header for insn-conditions.c.  */\n+\n+static void\n+write_header ()\n+{\n+  puts (\"\\\n+/* Generated automatically by the program `genconditions' from the target\\n\\\n+   machine description file.  */\\n\\\n+\\n\\\n+#include \\\"hconfig.h\\\"\\n\\\n+#include \\\"insn-constants.h\\\"\\n\");\n+\n+  puts (\"\\\n+/* Do not allow checking to confuse the issue.  */\\n\\\n+#undef ENABLE_CHECKING\\n\\\n+#undef ENABLE_TREE_CHECKING\\n\\\n+#undef ENABLE_RTL_CHECKING\\n\\\n+#undef ENABLE_RTL_FLAG_CHECKING\\n\\\n+#undef ENABLE_GC_CHECKING\\n\\\n+#undef ENABLE_GC_ALWAYS_COLLECT\\n\");\n+\n+  puts (\"\\\n+#include \\\"system.h\\\"\\n\\\n+#include \\\"rtl.h\\\"\\n\\\n+#include \\\"tm_p.h\\\"\\n\\\n+#include \\\"function.h\\\"\\n\");\n+\n+  puts (\"\\\n+/* Fake - insn-config.h doesn't exist yet.  */\\n\\\n+#define MAX_RECOG_OPERANDS 10\\n\\\n+#define MAX_DUP_OPERANDS 10\\n\\\n+#define MAX_INSNS_PER_SPLIT 5\\n\");\n+\n+  puts (\"\\\n+#include \\\"regs.h\\\"\\n\\\n+#include \\\"recog.h\\\"\\n\\\n+#include \\\"real.h\\\"\\n\\\n+#include \\\"output.h\\\"\\n\\\n+#include \\\"flags.h\\\"\\n\\\n+#include \\\"hard-reg-set.h\\\"\\n\\\n+#include \\\"resource.h\\\"\\n\\\n+#include \\\"toplev.h\\\"\\n\\\n+#include \\\"reload.h\\\"\\n\\\n+#include \\\"gensupport.h\\\"\\n\");\n+\n+  if (saw_eh_return)\n+    puts (\"#define HAVE_eh_return 1\");\n+  puts (\"#include \\\"except.h\\\"\\n\");\n+\n+  puts (\"\\\n+/* Dummy external declarations.  */\\n\\\n+extern rtx insn;\\n\\\n+extern rtx ins1;\\n\\\n+extern rtx operands[];\\n\\\n+extern int next_insn_tests_no_inequality PARAMS ((rtx));\\n\");\n+\n+  puts (\"\\\n+/* If we don't have __builtin_constant_p, or it's not acceptable in\\n\\\n+   array initializers, fall back to assuming that all conditions\\n\\\n+   potentially vary at run time.  It works in 3.0.1 and later; 3.0\\n\\\n+   only when not optimizing.  */\\n\\\n+#if (GCC_VERSION >= 3001) || ((GCC_VERSION == 3000) && !__OPTIMIZE__)\\n\\\n+# define MAYBE_EVAL(expr) (__builtin_constant_p(expr) ? (int) (expr) : -1)\\n\\\n+#else\\n\\\n+# define MAYBE_EVAL(expr) -1\\n\\\n+#endif\\n\");\n+}\n+\n+/* Write out one entry in the conditions table, using the data pointed\n+   to by SLOT.  Each entry looks like this:\n+  { \"! optimize_size && ! TARGET_READ_MODIFY_WRITE\",\n+    MAYBE_EVAL (! optimize_size && ! TARGET_READ_MODIFY_WRITE) },  */\n+\n+static int\n+write_one_condition (slot, dummy)\n+     PTR *slot;\n+     PTR dummy ATTRIBUTE_UNUSED;\n+{\n+  const struct c_test *test = * (const struct c_test **) slot;\n+  const char *p;\n+\n+  fputs (\"  { \\\"\", stdout);\n+  for (p = test->expr; *p; p++)\n+    {\n+      if (*p == '\\n')\n+\tfputs (\"\\\\n\\\\\\n\", stdout);\n+      else if (*p == '\"')\n+\tfputs (\"\\\\\\\"\", stdout);\n+      else\n+\tputchar (*p);\n+    }\n+\n+  printf (\"\\\",\\n    MAYBE_EVAL (%s) },\\n\", test->expr);\n+  return 1;\n+}\n+\n+/* Write out the complete conditions table, its size, and a flag\n+   indicating that gensupport.c can now do insn elision.  */\n+static void\n+write_conditions ()\n+{\n+  puts (\"\\\n+/* This table lists each condition found in the machine description.\\n\\\n+   Each condition is mapped to its truth value (0 or 1), or -1 if that\\n\\\n+   cannot be calculated at compile time. */\\n\\\n+\\n\\\n+const struct c_test insn_conditions[] = {\");\n+\n+  htab_traverse (condition_table, write_one_condition, 0);\n+\n+  puts (\"};\\n\");\n+\n+  printf (\"const size_t n_insn_conditions = %lu;\\n\",\n+\t  (unsigned long) htab_elements (condition_table));\n+  puts (\"const int insn_elision_unavailable = 0;\");\n+}\n+\n+int\n+main (argc, argv)\n+     int argc;\n+     char **argv;\n+{\n+  rtx desc;\n+  int pattern_lineno; /* not used */\n+  int code;\n+\n+  progname = \"genconditions\";\n+\n+  if (argc <= 1)\n+    fatal (\"No input file name.\");\n+\n+  if (init_md_reader (argv[1]) != SUCCESS_EXIT_CODE)\n+    return (FATAL_EXIT_CODE);\n+\n+  condition_table = htab_create (1000, hash_c_test, cmp_c_test, NULL);\n+\n+  /* Read the machine description.  */\n+\n+  while (1)\n+    {\n+      desc = read_md_rtx (&pattern_lineno, &code);\n+      if (desc == NULL)\n+\tbreak;\n+\n+      /* N.B. define_insn_and_split, define_cond_exec are handled\n+\t entirely within read_md_rtx; we never see them.  */\n+      switch (GET_CODE (desc))\n+\t{\n+\tdefault:\n+\t  break;\n+\n+\tcase DEFINE_INSN:\n+\tcase DEFINE_EXPAND:\n+\t  add_condition (XSTR (desc, 2));\n+\t  /* except.h needs to know whether there is an eh_return\n+\t     pattern in the machine description.  */\n+\t  if (!strcmp (XSTR (desc, 0), \"eh_return\"))\n+\t    saw_eh_return = 1;\n+\t  break;\n+\n+\tcase DEFINE_SPLIT:\n+\tcase DEFINE_PEEPHOLE:\n+\tcase DEFINE_PEEPHOLE2:\n+\t  add_condition (XSTR (desc, 1));\n+\t  break;\n+\t}\n+    }\n+\n+  write_header ();\n+  write_conditions ();\n+\n+  fflush (stdout);\n+  return (ferror (stdout) != 0 ? FATAL_EXIT_CODE : SUCCESS_EXIT_CODE);\n+}"}, {"sha": "948068167627c1d07b76cb650aab87d23fccbcf3", "filename": "gcc/genflags.c", "status": "modified", "additions": 47, "deletions": 16, "changes": 63, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2199e5fade2d41cbdb19bb730e494613b9b7e262/gcc%2Fgenflags.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2199e5fade2d41cbdb19bb730e494613b9b7e262/gcc%2Fgenflags.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgenflags.c?ref=2199e5fade2d41cbdb19bb730e494613b9b7e262", "patch": "@@ -124,14 +124,18 @@ gen_macro (name, real, expect)\n   printf (\"(%c))\\n\", i + 'A');\n }\n \n-/* Print out prototype information for a function.  */\n+/* Print out prototype information for a generator function.  If the\n+   insn pattern has been elided, print out a dummy generator that\n+   does nothing.  */\n \n static void\n gen_proto (insn)\n      rtx insn;\n {\n   int num = num_operands (insn);\n+  int i;\n   const char *name = XSTR (insn, 0);\n+  int truth = maybe_eval_c_test (XSTR (insn, 2));\n \n   /* Many md files don't refer to the last two operands passed to the\n      call patterns.  This means their generator functions will be two\n@@ -152,19 +156,41 @@ gen_proto (insn)\n \tgen_macro (name, num, 5);\n     }\n \n-  printf (\"extern struct rtx_def *gen_%-*s PARAMS ((\", max_id_len, name);\n+  if (truth != 0)\n+    printf (\"extern rtx        gen_%-*s PARAMS ((\", max_id_len, name);\n+  else\n+    printf (\"static inline rtx gen_%-*s PARAMS ((\", max_id_len, name);\n \n   if (num == 0)\n-    printf (\"void\");\n+    fputs (\"void\", stdout);\n   else\n     {\n-      while (num-- > 1)\n-\tprintf (\"struct rtx_def *, \");\n-\n-      printf (\"struct rtx_def *\");\n+      for (i = 1; i < num; i++)\n+\tfputs (\"rtx, \", stdout);\n+      \n+      fputs (\"rtx\", stdout);\n     }\n \n-  printf (\"));\\n\");\n+  puts (\"));\");\n+\n+  /* Some back ends want to take the address of generator functions,\n+     so we cannot simply use #define for these dummy definitions.  */\n+  if (truth == 0)\n+    {\n+      printf (\"static inline rtx\\ngen_%s\", name);\n+      if (num > 0)\n+\t{\n+\t  putchar ('(');\n+\t  for (i = 0; i < num-1; i++)\n+\t    printf (\"%c, \", 'a' + i);\n+\t  printf (\"%c)\\n\", 'a' + i);\n+\t  for (i = 0; i < num; i++)\n+\t    printf (\"     rtx %c ATTRIBUTE_UNUSED;\\n\", 'a' + i);\n+\t}\n+      else\n+\tputs (\"()\");\n+      puts (\"{\\n  return 0;\\n}\");\n+    }\n \n }\n \n@@ -175,6 +201,7 @@ gen_insn (insn)\n   const char *name = XSTR (insn, 0);\n   const char *p;\n   int len;\n+  int truth = maybe_eval_c_test (XSTR (insn, 2));\n \n   /* Don't mention instructions whose names are the null string\n      or begin with '*'.  They are in the machine description just\n@@ -187,22 +214,23 @@ gen_insn (insn)\n   if (len > max_id_len)\n     max_id_len = len;\n \n-  printf (\"#define HAVE_%s \", name);\n-  if (strlen (XSTR (insn, 2)) == 0)\n-    printf (\"1\\n\");\n+  if (truth == 0)\n+    /* emit nothing */;\n+  else if (truth == 1)\n+    printf (\"#define HAVE_%s 1\\n\", name);\n   else\n     {\n       /* Write the macro definition, putting \\'s at the end of each line,\n \t if more than one.  */\n-      printf (\"(\");\n+      printf (\"#define HAVE_%s (\", name);\n       for (p = XSTR (insn, 2); *p; p++)\n \t{\n \t  if (IS_VSPACE (*p))\n-\t    printf (\" \\\\\\n\");\n+\t    fputs (\" \\\\\\n\", stdout);\n \t  else\n-\t    printf (\"%c\", *p);\n+\t    putchar (*p);\n \t}\n-      printf (\")\\n\");\n+      fputs (\")\\n\", stdout);\n     }\n \n   obstack_grow (&obstack, &insn, sizeof (rtx));\n@@ -223,6 +251,10 @@ main (argc, argv)\n   progname = \"genflags\";\n   obstack_init (&obstack);\n \n+  /* We need to see all the possibilities.  Elided insns may have\n+     direct calls to their generators in C code.  */\n+  insn_elision = 0;\n+\n   if (argc <= 1)\n     fatal (\"no input file name\");\n \n@@ -252,7 +284,6 @@ main (argc, argv)\n   obstack_grow (&obstack, &dummy, sizeof (rtx));\n   insns = (rtx *) obstack_finish (&obstack);\n \n-  printf (\"struct rtx_def;\\n\");\n   for (insn_ptr = insns; *insn_ptr; insn_ptr++)\n     gen_proto (*insn_ptr);\n "}, {"sha": "7709eb8b6a65b963fbcfc1240fb6a3cf5874908f", "filename": "gcc/genrecog.c", "status": "modified", "additions": 10, "deletions": 2, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2199e5fade2d41cbdb19bb730e494613b9b7e262/gcc%2Fgenrecog.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2199e5fade2d41cbdb19bb730e494613b9b7e262/gcc%2Fgenrecog.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgenrecog.c?ref=2199e5fade2d41cbdb19bb730e494613b9b7e262", "patch": "@@ -2452,11 +2452,16 @@ make_insn_sequence (insn, type)\n {\n   rtx x;\n   const char *c_test = XSTR (insn, type == RECOG ? 2 : 1);\n+  int truth = maybe_eval_c_test (c_test);\n   struct decision *last;\n   struct decision_test *test, **place;\n   struct decision_head head;\n   char c_test_pos[2];\n \n+  /* We should never see an insn whose C test is false at compile time.  */\n+  if (truth == 0)\n+    abort ();\n+\n   record_insn_name (next_insn_code, (type == RECOG ? XSTR (insn, 0) : NULL));\n \n   c_test_pos[0] = '\\0';\n@@ -2504,7 +2509,8 @@ make_insn_sequence (insn, type)\n     continue;\n   place = &test->next;\n \n-  if (c_test[0])\n+  /* Skip the C test if it's known to be true at compile time.  */\n+  if (truth == -1)\n     {\n       /* Need a new node if we have another test to add.  */\n       if (test->type == DT_accept_op)\n@@ -2577,7 +2583,9 @@ make_insn_sequence (insn, type)\n \t\t  place = &last->tests;\n \t\t}\n \n-\t      if (c_test[0])\n+\t      /* Skip the C test if it's known to be true at compile\n+                 time.  */\n+\t      if (truth == -1)\n \t\t{\n \t\t  test = new_decision_test (DT_c_test, &place);\n \t\t  test->u.c_test = c_test;"}, {"sha": "5a9ff21f9782d3fb070429b2b3758df32148bbfc", "filename": "gcc/gensupport.c", "status": "modified", "additions": 99, "deletions": 1, "changes": 100, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2199e5fade2d41cbdb19bb730e494613b9b7e262/gcc%2Fgensupport.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2199e5fade2d41cbdb19bb730e494613b9b7e262/gcc%2Fgensupport.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgensupport.c?ref=2199e5fade2d41cbdb19bb730e494613b9b7e262", "patch": "@@ -23,12 +23,15 @@\n #include \"rtl.h\"\n #include \"obstack.h\"\n #include \"errors.h\"\n+#include \"hashtab.h\"\n #include \"gensupport.h\"\n \n \n /* In case some macros used by files we include need it, define this here.  */\n int target_flags;\n \n+int insn_elision = 1;\n+\n static struct obstack obstack;\n struct obstack *rtl_obstack = &obstack;\n \n@@ -39,6 +42,8 @@ static int predicable_default;\n static const char *predicable_true;\n static const char *predicable_false;\n \n+static htab_t condition_table;\n+\n static char *base_dir = NULL;\n \n /* We initially queue all patterns, process the define_insn and\n@@ -950,6 +955,7 @@ init_md_reader (filename)\n {\n   FILE *input_file;\n   int c;\n+  size_t i;\n   char *lastsl;\n \n   lastsl = strrchr (filename, '/');\n@@ -964,6 +970,14 @@ init_md_reader (filename)\n       return FATAL_EXIT_CODE;\n     }\n \n+  /* Initialize the table of insn conditions.  */\n+  condition_table = htab_create (n_insn_conditions,\n+\t\t\t\t hash_c_test, cmp_c_test, NULL);\n+\n+  for (i = 0; i < n_insn_conditions; i++)\n+    *(htab_find_slot (condition_table, (PTR) &insn_conditions[i], INSERT))\n+      = (PTR) &insn_conditions[i];\n+\n   obstack_init (rtl_obstack);\n   errors = 0;\n   sequence_num = 0;\n@@ -1002,6 +1016,8 @@ read_md_rtx (lineno, seqnr)\n   struct queue_elem **queue, *elem;\n   rtx desc;\n \n+ discard:\n+\n   /* Read all patterns from a given queue before moving on to the next.  */\n   if (define_attr_queue != NULL)\n     queue = &define_attr_queue;\n@@ -1021,14 +1037,29 @@ read_md_rtx (lineno, seqnr)\n \n   free (elem);\n \n+  /* Discard insn patterns which we know can never match (because\n+     their C test is provably always false).  If insn_elision is\n+     false, our caller needs to see all the patterns.  Note that the\n+     elided patterns are never counted by the sequence numbering; it\n+     it is the caller's responsibility, when insn_elision is false, not\n+     to use elided pattern numbers for anything.  */\n   switch (GET_CODE (desc))\n     {\n     case DEFINE_INSN:\n     case DEFINE_EXPAND:\n+      if (maybe_eval_c_test (XSTR (desc, 2)) != 0)\n+\tsequence_num++;\n+      else if (insn_elision)\n+\tgoto discard;\n+      break;\n+\n     case DEFINE_SPLIT:\n     case DEFINE_PEEPHOLE:\n     case DEFINE_PEEPHOLE2:\n-      sequence_num++;\n+      if (maybe_eval_c_test (XSTR (desc, 1)) != 0)\n+\tsequence_num++;\n+      else if (insn_elision)\n+\t    goto discard;\n       break;\n \n     default:\n@@ -1038,6 +1069,73 @@ read_md_rtx (lineno, seqnr)\n   return desc;\n }\n \n+/* Helper functions for insn elision.  */\n+\n+/* Compute a hash function of a c_test structure, which is keyed\n+   by its ->expr field.  */\n+hashval_t\n+hash_c_test (x)\n+     const PTR x;\n+{\n+  const struct c_test *a = (const struct c_test *) x;\n+  const unsigned char *base, *s = (const unsigned char *) a->expr;\n+  hashval_t hash;\n+  unsigned char c;\n+  unsigned int len;\n+\n+  base = s;\n+  hash = 0;\n+\n+  while ((c = *s++) != '\\0')\n+    {\n+      hash += c + (c << 17);\n+      hash ^= hash >> 2;\n+    }\n+\n+  len = s - base;\n+  hash += len + (len << 17);\n+  hash ^= hash >> 2;\n+\n+  return hash;\n+}\n+\n+/* Compare two c_test expression structures.  */\n+int\n+cmp_c_test (x, y)\n+     const PTR x;\n+     const PTR y;\n+{\n+  const struct c_test *a = (const struct c_test *) x;\n+  const struct c_test *b = (const struct c_test *) y;\n+\n+  return !strcmp (a->expr, b->expr);\n+}\n+\n+/* Given a string representing a C test expression, look it up in the\n+   condition_table and report whether or not its value is known\n+   at compile time.  Returns a tristate: 1 for known true, 0 for\n+   known false, -1 for unknown.  */\n+int\n+maybe_eval_c_test (expr)\n+     const char *expr;\n+{\n+  const struct c_test *test;\n+  struct c_test dummy;\n+\n+  if (expr[0] == 0)\n+    return 1;\n+\n+  if (insn_elision_unavailable)\n+    return -1;\n+\n+  dummy.expr = expr;\n+  test = (const struct c_test *) htab_find (condition_table, &dummy);\n+  if (!test)\n+    abort ();\n+\n+  return test->value;\n+}\n+\n /* Given a string, return the number of comma-separated elements in it.\n    Return 0 for the null string.  */\n int"}, {"sha": "8dbd0b70ea955374155acc45e139bd6daacbf73e", "filename": "gcc/gensupport.h", "status": "modified", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2199e5fade2d41cbdb19bb730e494613b9b7e262/gcc%2Fgensupport.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2199e5fade2d41cbdb19bb730e494613b9b7e262/gcc%2Fgensupport.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgensupport.h?ref=2199e5fade2d41cbdb19bb730e494613b9b7e262", "patch": "@@ -18,6 +18,9 @@ along with GCC; see the file COPYING.  If not, write to the Free\n Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n 02111-1307, USA.  */\n \n+#ifndef GCC_GENSUPPORT_H\n+#define GCC_GENSUPPORT_H\n+\n struct obstack;\n extern struct obstack *rtl_obstack;\n \n@@ -28,6 +31,39 @@ extern rtx read_md_rtx\t\tPARAMS ((int *, int *));\n extern void message_with_line\tPARAMS ((int, const char *, ...))\n      ATTRIBUTE_PRINTF_2;\n \n+/* Set this to 0 to disable automatic elision of insn patterns which\n+   can never be used in this configuration.  See genconditions.c.\n+   Must be set before calling init_md_reader.  */\n+extern int insn_elision;\n+\n+/* If this is 1, the insn elision table doesn't even exist yet;\n+   maybe_eval_c_test will always return -1.  This is distinct from\n+   insn_elision because genflags and gencodes need to see all the\n+   patterns, but treat elided patterns differently.  */\n+extern const int insn_elision_unavailable;\n+\n+/* If the C test passed as the argument can be evaluated at compile\n+   time, return its truth value; else return -1.  The test must have\n+   appeared somewhere in the machine description when genconditions\n+   was run.  */\n+extern int maybe_eval_c_test\tPARAMS ((const char *));\n+\n+/* This table should not be accessed directly; use maybe_eval_c_test.  */\n+struct c_test\n+{\n+  const char *expr;\n+  int value;\n+};\n+\n+extern const struct c_test insn_conditions[];\n+extern const size_t n_insn_conditions;\n+\n+#ifdef __HASHTAB_H__\n+extern hashval_t hash_c_test PARAMS ((const PTR));\n+extern int cmp_c_test PARAMS ((const PTR, const PTR));\n+#endif\n+\n extern int n_comma_elts\t\tPARAMS ((const char *));\n extern const char *scan_comma_elt PARAMS ((const char **));\n \n+#endif /* GCC_GENSUPPORT_H */"}]}