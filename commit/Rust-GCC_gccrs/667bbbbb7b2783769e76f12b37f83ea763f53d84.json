{"sha": "667bbbbb7b2783769e76f12b37f83ea763f53d84", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NjY3YmJiYmI3YjI3ODM3NjllNzZmMTJiMzdmODNlYTc2M2Y1M2Q4NA==", "commit": {"author": {"name": "Eric Christopher", "email": "echristo@gcc.gnu.org", "date": "2004-09-08T23:24:40Z"}, "committer": {"name": "Eric Christopher", "email": "echristo@gcc.gnu.org", "date": "2004-09-08T23:24:40Z"}, "message": "builtins.c (fold_builtin_strlen, [...]): New functions.\n\n2004-09-08  Eric Christopher  <echristo@redhat.com>\n\n        * builtins.c (fold_builtin_strlen, fold_builtin_sqrt, fold_builtin_cbrt,\n\tfold_builtin_pow, fold_builtin_sin, fold_builtin_cos, fold_builtin_tan,\n        fold_builtin_atan): New functions. Migrate function bodies...\n        (fold_builtin_1): ... from here.\n\nFrom-SVN: r87206", "tree": {"sha": "486a68d656944050929594ad4f3358da2132da84", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/486a68d656944050929594ad4f3358da2132da84"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/667bbbbb7b2783769e76f12b37f83ea763f53d84", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/667bbbbb7b2783769e76f12b37f83ea763f53d84", "html_url": "https://github.com/Rust-GCC/gccrs/commit/667bbbbb7b2783769e76f12b37f83ea763f53d84", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/667bbbbb7b2783769e76f12b37f83ea763f53d84/comments", "author": null, "committer": null, "parents": [{"sha": "640450295efd52c5ed8a0868e14866c1a269efb7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/640450295efd52c5ed8a0868e14866c1a269efb7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/640450295efd52c5ed8a0868e14866c1a269efb7"}], "stats": {"total": 690, "additions": 391, "deletions": 299}, "files": [{"sha": "52eca28192256cf2ab80fbcccc6143483b19d7dd", "filename": "gcc/ChangeLog", "status": "modified", "additions": 12, "deletions": 5, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/667bbbbb7b2783769e76f12b37f83ea763f53d84/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/667bbbbb7b2783769e76f12b37f83ea763f53d84/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=667bbbbb7b2783769e76f12b37f83ea763f53d84", "patch": "@@ -1,3 +1,10 @@\n+2004-09-08  Eric Christopher  <echristo@redhat.com>\n+\n+\t* builtins.c (fold_builtin_strlen, fold_builtin_sqrt, fold_builtin_cbrt,\n+\tfold_builtin_pow, fold_builtin_sin, fold_builtin_cos, fold_builtin_tan,\n+\tfold_builtin_atan): New functions. Migrate function bodies...\n+\t(fold_builtin_1): ... from here.\n+\n 2004-09-09  Alan Modra  <amodra@bigpond.net.au>\n \n \t* config/rs6000/rs6000.c (rs6000_stack_info): Correct alignment of\n@@ -100,7 +107,7 @@\n \tedge block.\n \t(replace_phi_with_cond_modify_expr): Select conditional expr args\n \tbased on true edge basic block.\n-\t\n+\n 2004-09-08  Jan Hubicka  <jh@suse.cz>\n \n \t* tree-ssa-operands.c (add_stmt_operand): Use V_MUST_DEF even for\n@@ -149,7 +156,7 @@\n \t(gcc_loop_to_lambda_loop): Handle all exit tests.\n \tHandle case where we have (invariant >= induction var).\n \t(find_induction_var_from_exit_cond): Ditto.\n-\t\n+\n 2004-09-08  Jie Zhang  <zhangjie@magima.com.cn>\n \n \t* tree-ssa-alias.c (compute_flow_insensitive_aliasing): If type\n@@ -289,7 +296,7 @@\n \tforce operand 0.0 into register in XFmode. Also do not force\n \toperand 0.0 into register if !TARGET_CMOVE.\n \t* config/i386/i386.md (*cmpfp_0): Delete. Remove comment.\n-\t(*cmpfp_0_sf, cmpfp_0_df, cmpfp_0_xf): New patterns to \n+\t(*cmpfp_0_sf, cmpfp_0_df, cmpfp_0_xf): New patterns to\n \timplement ftst x87 instruction.\n \t(*fp_jcc_7): New insn pattern. Change corresponding split\n \tpattern to handle \"general_operand\" instead of\n@@ -420,7 +427,7 @@\n \n \t* cfgrtl.c (rtl_verify_flow_info_1):  Add new edge flag,\n \tEDGE_CROSSING, to flags test case.\n-\t\n+\n 2004-09-07  Jan Hubicka  <jh@suse.cz>\n \n \t* tree-ssa-loop-ivopts.c (contains_abnormal_ssa_name_p): Deal with '<'\n@@ -520,7 +527,7 @@\n \tcheck_format_types, format_type_warning,\n \tfind_char_info_specifier_index, init_dynamic_asm_fprintf_info,\n \tinit_dynamic_diag_info, handle_format_attribute): Likewise.\n-\t* c-gimplify.c (push_context, pop_context, finish_bc_block): \n+\t* c-gimplify.c (push_context, pop_context, finish_bc_block):\n \t* c-lex.c (c_lex_with_flags, lex_string): Likewise.\n \t* c-objc-common.c (c_tree_printer): Likewise.\n \t* c-pch.c (pch_init): Likewise."}, {"sha": "f13e725b8ed4bd2b57497093a9159fc3c51be542", "filename": "gcc/builtins.c", "status": "modified", "additions": 379, "deletions": 294, "changes": 673, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/667bbbbb7b2783769e76f12b37f83ea763f53d84/gcc%2Fbuiltins.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/667bbbbb7b2783769e76f12b37f83ea763f53d84/gcc%2Fbuiltins.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbuiltins.c?ref=667bbbbb7b2783769e76f12b37f83ea763f53d84", "patch": "@@ -139,6 +139,7 @@ static tree stabilize_va_list (tree, int);\n static rtx expand_builtin_expect (tree, rtx);\n static tree fold_builtin_constant_p (tree);\n static tree fold_builtin_classify_type (tree);\n+static tree fold_builtin_strlen (tree);\n static tree fold_builtin_inf (tree, int);\n static tree fold_builtin_nan (tree, tree, int);\n static int validate_arglist (tree, ...);\n@@ -148,6 +149,13 @@ static bool readonly_data_expr (tree);\n static rtx expand_builtin_fabs (tree, rtx, rtx);\n static rtx expand_builtin_signbit (tree, rtx);\n static tree fold_builtin_cabs (tree, tree);\n+static tree fold_builtin_sqrt (tree, tree);\n+static tree fold_builtin_cbrt (tree, tree);\n+static tree fold_builtin_pow (tree, tree, tree);\n+static tree fold_builtin_sin (tree);\n+static tree fold_builtin_cos (tree, tree, tree);\n+static tree fold_builtin_tan (tree);\n+static tree fold_builtin_atan (tree);\n static tree fold_builtin_trunc (tree);\n static tree fold_builtin_floor (tree);\n static tree fold_builtin_ceil (tree);\n@@ -6255,6 +6263,29 @@ fold_builtin_classify_type (tree arglist)\n \t\t\ttype_to_class (TREE_TYPE (TREE_VALUE (arglist))));\n }\n \n+/* Fold a call to __builtin_strlen.  */\n+\n+static tree\n+fold_builtin_strlen (tree arglist)\n+{\n+  if (!validate_arglist (arglist, POINTER_TYPE, VOID_TYPE))\n+    return NULL_TREE;\n+  else\n+    {\n+      tree len = c_strlen (TREE_VALUE (arglist), 0);\n+\n+      if (len)\n+\t{\n+\t  /* Convert from the internal \"sizetype\" type to \"size_t\".  */\n+\t  if (size_type_node)\n+\t    len = fold_convert (size_type_node, len);\n+\t  return len;\n+\t}\n+\n+      return NULL_TREE;\n+    }\n+}\n+\n /* Fold a call to __builtin_inf or __builtin_huge_val.  */\n \n static tree\n@@ -6537,6 +6568,235 @@ fold_builtin_cabs (tree arglist, tree type)\n   return NULL_TREE;\n }\n \n+/* Fold a builtin function call to sqrt, sqrtf, or sqrtl.  Return\n+   NULL_TREE if no simplification can be made.  */\n+\n+static tree\n+fold_builtin_sqrt (tree arglist, tree type)\n+{\n+\n+  enum built_in_function fcode;\n+  tree arg = TREE_VALUE (arglist);\n+\n+  if (!validate_arglist (arglist, REAL_TYPE, VOID_TYPE))\n+    return NULL_TREE;\n+\n+  /* Optimize sqrt of constant value.  */\n+  if (TREE_CODE (arg) == REAL_CST\n+      && ! TREE_CONSTANT_OVERFLOW (arg))\n+    {\n+      REAL_VALUE_TYPE r, x;\n+\n+      x = TREE_REAL_CST (arg);\n+      if (real_sqrt (&r, TYPE_MODE (type), &x)\n+\t  || (!flag_trapping_math && !flag_errno_math))\n+\treturn build_real (type, r);\n+    }\n+\n+  /* Optimize sqrt(expN(x)) = expN(x*0.5).  */\n+  fcode = builtin_mathfn_code (arg);\n+  if (flag_unsafe_math_optimizations && BUILTIN_EXPONENT_P (fcode))\n+    {\n+      tree expfn = TREE_OPERAND (TREE_OPERAND (arg, 0), 0);\n+      arg = fold (build2 (MULT_EXPR, type,\n+\t\t\t  TREE_VALUE (TREE_OPERAND (arg, 1)),\n+\t\t\t  build_real (type, dconsthalf)));\n+      arglist = build_tree_list (NULL_TREE, arg);\n+      return build_function_call_expr (expfn, arglist);\n+    }\n+\n+  /* Optimize sqrt(Nroot(x)) -> pow(x,1/(2*N)).  */\n+  if (flag_unsafe_math_optimizations && BUILTIN_ROOT_P (fcode))\n+    {\n+      tree powfn = mathfn_built_in (type, BUILT_IN_POW);\n+\n+      if (powfn)\n+\t{\n+\t  tree arg0 = TREE_VALUE (TREE_OPERAND (arg, 1));\n+\t  tree tree_root;\n+\t  /* The inner root was either sqrt or cbrt.  */\n+\t  REAL_VALUE_TYPE dconstroot =\n+\t    BUILTIN_SQRT_P (fcode) ? dconsthalf : dconstthird;\n+\n+\t  /* Adjust for the outer root.  */\n+\t  SET_REAL_EXP (&dconstroot, REAL_EXP (&dconstroot) - 1);\n+\t  dconstroot = real_value_truncate (TYPE_MODE (type), dconstroot);\n+\t  tree_root = build_real (type, dconstroot);\n+\t  arglist = tree_cons (NULL_TREE, arg0,\n+\t\t\t       build_tree_list (NULL_TREE, tree_root));\n+\t  return build_function_call_expr (powfn, arglist);\n+\t}\n+    }\n+\n+  /* Optimize sqrt(pow(x,y)) = pow(x,y*0.5).  */\n+  if (flag_unsafe_math_optimizations\n+      && (fcode == BUILT_IN_POW\n+\t  || fcode == BUILT_IN_POWF\n+\t  || fcode == BUILT_IN_POWL))\n+    {\n+      tree powfn = TREE_OPERAND (TREE_OPERAND (arg, 0), 0);\n+      tree arg0 = TREE_VALUE (TREE_OPERAND (arg, 1));\n+      tree arg1 = TREE_VALUE (TREE_CHAIN (TREE_OPERAND (arg, 1)));\n+      tree narg1 = fold (build2 (MULT_EXPR, type, arg1,\n+\t\t\t\t build_real (type, dconsthalf)));\n+      arglist = tree_cons (NULL_TREE, arg0,\n+\t\t\t   build_tree_list (NULL_TREE, narg1));\n+      return build_function_call_expr (powfn, arglist);\n+    }\n+\n+  return NULL_TREE;\n+}\n+\n+/* Fold a builtin function call to cbrt, cbrtf, or cbrtl.  Return\n+   NULL_TREE if no simplification can be made.  */\n+static tree\n+fold_builtin_cbrt (tree arglist, tree type)\n+{\n+  tree arg = TREE_VALUE (arglist);\n+  const enum built_in_function fcode = builtin_mathfn_code (arg);\n+\n+  if (!validate_arglist (arglist, REAL_TYPE, VOID_TYPE))\n+    return NULL_TREE;\n+\n+  /* Optimize cbrt of constant value.  */\n+  if (real_zerop (arg) || real_onep (arg) || real_minus_onep (arg))\n+    return arg;\n+\n+  /* Optimize cbrt(expN(x)) -> expN(x/3).  */\n+  if (flag_unsafe_math_optimizations && BUILTIN_EXPONENT_P (fcode))\n+    {\n+      tree expfn = TREE_OPERAND (TREE_OPERAND (arg, 0), 0);\n+      const REAL_VALUE_TYPE third_trunc =\n+\treal_value_truncate (TYPE_MODE (type), dconstthird);\n+      arg = fold (build2 (MULT_EXPR, type,\n+\t\t\t  TREE_VALUE (TREE_OPERAND (arg, 1)),\n+\t\t\t  build_real (type, third_trunc)));\n+      arglist = build_tree_list (NULL_TREE, arg);\n+      return build_function_call_expr (expfn, arglist);\n+    }\n+\n+  /* Optimize cbrt(sqrt(x)) -> pow(x,1/6).  */\n+  /* We don't optimize cbrt(cbrt(x)) -> pow(x,1/9) because if\n+     x is negative pow will error but cbrt won't.  */\n+  if (flag_unsafe_math_optimizations && BUILTIN_SQRT_P (fcode))\n+    {\n+      tree powfn = mathfn_built_in (type, BUILT_IN_POW);\n+\n+      if (powfn)\n+\t{\n+\t  tree arg0 = TREE_VALUE (TREE_OPERAND (arg, 1));\n+\t  tree tree_root;\n+\t  REAL_VALUE_TYPE dconstroot = dconstthird;\n+\n+\t  SET_REAL_EXP (&dconstroot, REAL_EXP (&dconstroot) - 1);\n+\t  dconstroot = real_value_truncate (TYPE_MODE (type), dconstroot);\n+\t  tree_root = build_real (type, dconstroot);\n+\t  arglist = tree_cons (NULL_TREE, arg0,\n+\t\t\t       build_tree_list (NULL_TREE, tree_root));\n+\t  return build_function_call_expr (powfn, arglist);\n+\t}\n+\n+    }\n+  return NULL_TREE;\n+}\n+\n+/* Fold function call to builtin sin, sinf, or sinl.  Return\n+   NULL_TREE if no simplification can be made.  */\n+static tree\n+fold_builtin_sin (tree arglist)\n+{\n+  tree arg = TREE_VALUE (arglist);\n+\n+  if (!validate_arglist (arglist, REAL_TYPE, VOID_TYPE))\n+    return NULL_TREE;\n+\n+  /* Optimize sin (0.0) = 0.0.  */\n+  if (real_zerop (arg))\n+    return arg;\n+\n+  return NULL_TREE;\n+}\n+\n+/* Fold function call to builtin cos, cosf, or cosl.  Return\n+   NULL_TREE if no simplification can be made.  */\n+static tree\n+fold_builtin_cos (tree arglist, tree type, tree fndecl)\n+{\n+  tree arg = TREE_VALUE (arglist);\n+\n+  if (!validate_arglist (arglist, REAL_TYPE, VOID_TYPE))\n+    return NULL_TREE;\n+\n+  /* Optimize cos (0.0) = 1.0.  */\n+  if (real_zerop (arg))\n+    return build_real (type, dconst1);\n+\n+  /* Optimize cos(-x) into cos (x).  */\n+  if (TREE_CODE (arg) == NEGATE_EXPR)\n+    {\n+      tree args = build_tree_list (NULL_TREE,\n+\t\t\t\t   TREE_OPERAND (arg, 0));\n+      return build_function_call_expr (fndecl, args);\n+    }\n+\n+  return NULL_TREE;\n+}\n+\n+/* Fold function call to builtin tan, tanf, or tanl.  Return\n+   NULL_TREE if no simplification can be made.  */\n+static tree\n+fold_builtin_tan (tree arglist)\n+{\n+  enum built_in_function fcode;\n+  tree arg = TREE_VALUE (arglist);\n+\n+  if (!validate_arglist (arglist, REAL_TYPE, VOID_TYPE))\n+    return NULL_TREE;\n+\n+  /* Optimize tan(0.0) = 0.0.  */\n+  if (real_zerop (arg))\n+    return arg;\n+\n+  /* Optimize tan(atan(x)) = x.  */\n+  fcode = builtin_mathfn_code (arg);\n+  if (flag_unsafe_math_optimizations\n+      && (fcode == BUILT_IN_ATAN\n+\t  || fcode == BUILT_IN_ATANF\n+\t  || fcode == BUILT_IN_ATANL))\n+    return TREE_VALUE (TREE_OPERAND (arg, 1));\n+\n+  return NULL_TREE;\n+}\n+\n+/* Fold function call to builtin atan, atanf, or atanl.  Return\n+   NULL_TREE if no simplification can be made.  */\n+\n+static tree\n+fold_builtin_atan (tree arglist, tree type)\n+{\n+\n+  tree arg = TREE_VALUE (arglist);\n+\n+  if (!validate_arglist (arglist, REAL_TYPE, VOID_TYPE))\n+    return NULL_TREE;\n+\n+  /* Optimize atan(0.0) = 0.0.  */\n+  if (real_zerop (arg))\n+    return arg;\n+\n+  /* Optimize atan(1.0) = pi/4.  */\n+  if (real_onep (arg))\n+    {\n+      REAL_VALUE_TYPE cst;\n+\n+      real_convert (&cst, TYPE_MODE (type), &dconstpi);\n+      SET_REAL_EXP (&cst, REAL_EXP (&cst) - 2);\n+      return build_real (type, cst);\n+    }\n+\n+  return NULL_TREE;\n+}\n+\n /* Fold function call to builtin trunc, truncf or truncl.  Return\n    NULL_TREE if no simplification can be made.  */\n \n@@ -6935,6 +7195,117 @@ fold_builtin_logarithm (tree exp, const REAL_VALUE_TYPE *value)\n   return 0;\n }\n \n+/* Fold a builtin function call to pow, powf, or powl.  Return\n+   NULL_TREE if no simplification can be made.  */\n+static tree\n+fold_builtin_pow (tree fndecl, tree arglist, tree type)\n+{\n+  enum built_in_function fcode;\n+  tree arg0 = TREE_VALUE (arglist);\n+  tree arg1 = TREE_VALUE (TREE_CHAIN (arglist));\n+\n+  if (!validate_arglist (arglist, REAL_TYPE, REAL_TYPE, VOID_TYPE))\n+    return NULL_TREE;\n+\n+  /* Optimize pow(1.0,y) = 1.0.  */\n+  if (real_onep (arg0))\n+    return omit_one_operand (type, build_real (type, dconst1), arg1);\n+\n+  if (TREE_CODE (arg1) == REAL_CST\n+      && ! TREE_CONSTANT_OVERFLOW (arg1))\n+    {\n+      REAL_VALUE_TYPE c;\n+      c = TREE_REAL_CST (arg1);\n+\n+      /* Optimize pow(x,0.0) = 1.0.  */\n+      if (REAL_VALUES_EQUAL (c, dconst0))\n+\treturn omit_one_operand (type, build_real (type, dconst1),\n+\t\t\t\t arg0);\n+\n+      /* Optimize pow(x,1.0) = x.  */\n+      if (REAL_VALUES_EQUAL (c, dconst1))\n+\treturn arg0;\n+\n+      /* Optimize pow(x,-1.0) = 1.0/x.  */\n+      if (REAL_VALUES_EQUAL (c, dconstm1))\n+\treturn fold (build2 (RDIV_EXPR, type,\n+\t\t\t     build_real (type, dconst1), arg0));\n+\n+      /* Optimize pow(x,0.5) = sqrt(x).  */\n+      if (flag_unsafe_math_optimizations\n+\t  && REAL_VALUES_EQUAL (c, dconsthalf))\n+\t{\n+\t  tree sqrtfn = mathfn_built_in (type, BUILT_IN_SQRT);\n+\n+\t  if (sqrtfn != NULL_TREE)\n+\t    {\n+\t      tree arglist = build_tree_list (NULL_TREE, arg0);\n+\t      return build_function_call_expr (sqrtfn, arglist);\n+\t    }\n+\t}\n+\n+      /* Attempt to evaluate pow at compile-time.  */\n+      if (TREE_CODE (arg0) == REAL_CST\n+\t  && ! TREE_CONSTANT_OVERFLOW (arg0))\n+\t{\n+\t  REAL_VALUE_TYPE cint;\n+\t  HOST_WIDE_INT n;\n+\n+\t  n = real_to_integer (&c);\n+\t  real_from_integer (&cint, VOIDmode, n,\n+\t\t\t     n < 0 ? -1 : 0, 0);\n+\t  if (real_identical (&c, &cint))\n+\t    {\n+\t      REAL_VALUE_TYPE x;\n+\t      bool inexact;\n+\n+\t      x = TREE_REAL_CST (arg0);\n+\t      inexact = real_powi (&x, TYPE_MODE (type), &x, n);\n+\t      if (flag_unsafe_math_optimizations || !inexact)\n+\t\treturn build_real (type, x);\n+\t    }\n+\t}\n+    }\n+\n+  /* Optimize pow(expN(x),y) = expN(x*y).  */\n+  fcode = builtin_mathfn_code (arg0);\n+  if (flag_unsafe_math_optimizations && BUILTIN_EXPONENT_P (fcode))\n+    {\n+      tree expfn = TREE_OPERAND (TREE_OPERAND (arg0, 0), 0);\n+      tree arg = TREE_VALUE (TREE_OPERAND (arg0, 1));\n+      arg = fold (build2 (MULT_EXPR, type, arg, arg1));\n+      arglist = build_tree_list (NULL_TREE, arg);\n+      return build_function_call_expr (expfn, arglist);\n+    }\n+\n+  /* Optimize pow(sqrt(x),y) = pow(x,y*0.5).  */\n+  if (flag_unsafe_math_optimizations && BUILTIN_SQRT_P (fcode))\n+    {\n+      tree narg0 = TREE_VALUE (TREE_OPERAND (arg0, 1));\n+      tree narg1 = fold (build2 (MULT_EXPR, type, arg1,\n+\t\t\t\t build_real (type, dconsthalf)));\n+\n+      arglist = tree_cons (NULL_TREE, narg0,\n+\t\t\t   build_tree_list (NULL_TREE, narg1));\n+      return build_function_call_expr (fndecl, arglist);\n+    }\n+\n+  /* Optimize pow(pow(x,y),z) = pow(x,y*z).  */\n+  if (flag_unsafe_math_optimizations\n+      && (fcode == BUILT_IN_POW\n+\t  || fcode == BUILT_IN_POWF\n+\t  || fcode == BUILT_IN_POWL))\n+    {\n+      tree arg00 = TREE_VALUE (TREE_OPERAND (arg0, 1));\n+      tree arg01 = TREE_VALUE (TREE_CHAIN (TREE_OPERAND (arg0, 1)));\n+      tree narg1 = fold (build2 (MULT_EXPR, type, arg01, arg1));\n+      arglist = tree_cons (NULL_TREE, arg00,\n+\t\t\t   build_tree_list (NULL_TREE, narg1));\n+      return build_function_call_expr (fndecl, arglist);\n+    }\n+  return NULL_TREE;\n+}\n+\n /* A subroutine of fold_builtin to fold the various exponent\n    functions.  EXP is the CALL_EXPR of a call to a builtin function.\n    VALUE is the value which will be raised to a power.  */\n@@ -7834,18 +8205,7 @@ fold_builtin_1 (tree exp, bool ignore)\n       return fold_builtin_classify_type (arglist);\n \n     case BUILT_IN_STRLEN:\n-      if (validate_arglist (arglist, POINTER_TYPE, VOID_TYPE))\n-\t{\n-\t  tree len = c_strlen (TREE_VALUE (arglist), 0);\n-\t  if (len)\n-\t    {\n-\t      /* Convert from the internal \"sizetype\" type to \"size_t\".  */\n-\t      if (size_type_node)\n-\t\tlen = fold_convert (size_type_node, len);\n-\t      return len;\n-\t    }\n-\t}\n-      break;\n+      return fold_builtin_strlen (arglist);\n \n     case BUILT_IN_FABS:\n     case BUILT_IN_FABSF:\n@@ -7889,159 +8249,22 @@ fold_builtin_1 (tree exp, bool ignore)\n     case BUILT_IN_SQRT:\n     case BUILT_IN_SQRTF:\n     case BUILT_IN_SQRTL:\n-      if (validate_arglist (arglist, REAL_TYPE, VOID_TYPE))\n-\t{\n-\t  enum built_in_function fcode;\n-\t  tree arg = TREE_VALUE (arglist);\n-\n-\t  /* Optimize sqrt of constant value.  */\n-\t  if (TREE_CODE (arg) == REAL_CST\n-\t      && ! TREE_CONSTANT_OVERFLOW (arg))\n-\t    {\n-\t      REAL_VALUE_TYPE r, x;\n-\n-\t      x = TREE_REAL_CST (arg);\n-\t      if (real_sqrt (&r, TYPE_MODE (type), &x)\n-\t\t  || (!flag_trapping_math && !flag_errno_math))\n-\t\treturn build_real (type, r);\n-\t    }\n-\n-\t  /* Optimize sqrt(expN(x)) = expN(x*0.5).  */\n-\t  fcode = builtin_mathfn_code (arg);\n-\t  if (flag_unsafe_math_optimizations && BUILTIN_EXPONENT_P (fcode))\n-\t    {\n-\t      tree expfn = TREE_OPERAND (TREE_OPERAND (arg, 0), 0);\n-\t      arg = fold (build2 (MULT_EXPR, type,\n-\t\t\t\t  TREE_VALUE (TREE_OPERAND (arg, 1)),\n-\t\t\t\t  build_real (type, dconsthalf)));\n-\t      arglist = build_tree_list (NULL_TREE, arg);\n-\t      return build_function_call_expr (expfn, arglist);\n-\t    }\n-\n-\t  /* Optimize sqrt(Nroot(x)) -> pow(x,1/(2*N)).  */\n-\t  if (flag_unsafe_math_optimizations && BUILTIN_ROOT_P (fcode))\n-\t    {\n-\t      tree powfn = mathfn_built_in (type, BUILT_IN_POW);\n-\n-\t      if (powfn)\n-\t        {\n-\t\t  tree arg0 = TREE_VALUE (TREE_OPERAND (arg, 1));\n-\t\t  tree tree_root;\n-\t\t  /* The inner root was either sqrt or cbrt.  */\n-\t\t  REAL_VALUE_TYPE dconstroot =\n-\t\t    BUILTIN_SQRT_P (fcode) ? dconsthalf : dconstthird;\n-\n-\t\t  /* Adjust for the outer root.  */\n-\t\t  SET_REAL_EXP (&dconstroot, REAL_EXP (&dconstroot) - 1);\n-\t\t  dconstroot = real_value_truncate (TYPE_MODE (type), dconstroot);\n-\t\t  tree_root = build_real (type, dconstroot);\n-\t\t  arglist = tree_cons (NULL_TREE, arg0,\n-\t\t\t\t       build_tree_list (NULL_TREE, tree_root));\n-\t\t  return build_function_call_expr (powfn, arglist);\n-\t\t}\n-\t    }\n-\n-\t  /* Optimize sqrt(pow(x,y)) = pow(x,y*0.5).  */\n-\t  if (flag_unsafe_math_optimizations\n-\t      && (fcode == BUILT_IN_POW\n-\t\t  || fcode == BUILT_IN_POWF\n-\t\t  || fcode == BUILT_IN_POWL))\n-\t    {\n-\t      tree powfn = TREE_OPERAND (TREE_OPERAND (arg, 0), 0);\n-\t      tree arg0 = TREE_VALUE (TREE_OPERAND (arg, 1));\n-\t      tree arg1 = TREE_VALUE (TREE_CHAIN (TREE_OPERAND (arg, 1)));\n-\t      tree narg1 = fold (build2 (MULT_EXPR, type, arg1,\n-\t\t\t\t\t build_real (type, dconsthalf)));\n-\t      arglist = tree_cons (NULL_TREE, arg0,\n-\t\t\t\t   build_tree_list (NULL_TREE, narg1));\n-\t      return build_function_call_expr (powfn, arglist);\n-\t    }\n-\t}\n-      break;\n+      return fold_builtin_sqrt (arglist, type);\n \n     case BUILT_IN_CBRT:\n     case BUILT_IN_CBRTF:\n     case BUILT_IN_CBRTL:\n-      if (validate_arglist (arglist, REAL_TYPE, VOID_TYPE))\n-\t{\n-\t  tree arg = TREE_VALUE (arglist);\n-\t  const enum built_in_function fcode = builtin_mathfn_code (arg);\n-\n-\t  /* Optimize cbrt of constant value.  */\n-\t  if (real_zerop (arg) || real_onep (arg) || real_minus_onep (arg))\n-\t    return arg;\n-\n-\t  /* Optimize cbrt(expN(x)) -> expN(x/3).  */\n-\t  if (flag_unsafe_math_optimizations && BUILTIN_EXPONENT_P (fcode))\n-\t    {\n-\t      tree expfn = TREE_OPERAND (TREE_OPERAND (arg, 0), 0);\n-\t      const REAL_VALUE_TYPE third_trunc =\n-\t\treal_value_truncate (TYPE_MODE (type), dconstthird);\n-\t      arg = fold (build2 (MULT_EXPR, type,\n-\t\t\t\t  TREE_VALUE (TREE_OPERAND (arg, 1)),\n-\t\t\t\t  build_real (type, third_trunc)));\n-\t      arglist = build_tree_list (NULL_TREE, arg);\n-\t      return build_function_call_expr (expfn, arglist);\n-\t    }\n-\n-\t  /* Optimize cbrt(sqrt(x)) -> pow(x,1/6).  */\n-\t  /* We don't optimize cbrt(cbrt(x)) -> pow(x,1/9) because if\n-             x is negative pow will error but cbrt won't.  */\n-\t  if (flag_unsafe_math_optimizations && BUILTIN_SQRT_P (fcode))\n-\t    {\n-\t      tree powfn = mathfn_built_in (type, BUILT_IN_POW);\n-\n-\t      if (powfn)\n-\t        {\n-\t\t  tree arg0 = TREE_VALUE (TREE_OPERAND (arg, 1));\n-\t\t  tree tree_root;\n-\t\t  REAL_VALUE_TYPE dconstroot = dconstthird;\n-\n-\t\t  SET_REAL_EXP (&dconstroot, REAL_EXP (&dconstroot) - 1);\n-\t\t  dconstroot = real_value_truncate (TYPE_MODE (type), dconstroot);\n-\t\t  tree_root = build_real (type, dconstroot);\n-\t\t  arglist = tree_cons (NULL_TREE, arg0,\n-\t\t\t\t       build_tree_list (NULL_TREE, tree_root));\n-\t\t  return build_function_call_expr (powfn, arglist);\n-\t\t}\n-\n-\t    }\n-\t}\n-      break;\n+      return fold_builtin_cbrt (arglist, type);\n \n     case BUILT_IN_SIN:\n     case BUILT_IN_SINF:\n     case BUILT_IN_SINL:\n-      if (validate_arglist (arglist, REAL_TYPE, VOID_TYPE))\n-\t{\n-\t  tree arg = TREE_VALUE (arglist);\n-\n-\t  /* Optimize sin(0.0) = 0.0.  */\n-\t  if (real_zerop (arg))\n-\t    return arg;\n-\t}\n-      break;\n+      return fold_builtin_sin (arglist);\n \n     case BUILT_IN_COS:\n     case BUILT_IN_COSF:\n     case BUILT_IN_COSL:\n-      if (validate_arglist (arglist, REAL_TYPE, VOID_TYPE))\n-\t{\n-\t  tree arg = TREE_VALUE (arglist);\n-\n-\t  /* Optimize cos(0.0) = 1.0.  */\n-\t  if (real_zerop (arg))\n-\t    return build_real (type, dconst1);\n-\n-\t  /* Optimize cos(-x) into cos(x).  */\n-\t  if (TREE_CODE (arg) == NEGATE_EXPR)\n-\t    {\n-\t      tree arglist = build_tree_list (NULL_TREE,\n-\t\t\t\t\t      TREE_OPERAND (arg, 0));\n-\t      return build_function_call_expr (fndecl, arglist);\n-\t    }\n-\t}\n-      break;\n+      return fold_builtin_cos (arglist, type, fndecl);\n \n     case BUILT_IN_EXP:\n     case BUILT_IN_EXPF:\n@@ -8079,155 +8302,17 @@ fold_builtin_1 (tree exp, bool ignore)\n     case BUILT_IN_TAN:\n     case BUILT_IN_TANF:\n     case BUILT_IN_TANL:\n-      if (validate_arglist (arglist, REAL_TYPE, VOID_TYPE))\n-\t{\n-\t  enum built_in_function fcode;\n-\t  tree arg = TREE_VALUE (arglist);\n-\n-\t  /* Optimize tan(0.0) = 0.0.  */\n-\t  if (real_zerop (arg))\n-\t    return arg;\n-\n-\t  /* Optimize tan(atan(x)) = x.  */\n-\t  fcode = builtin_mathfn_code (arg);\n-\t  if (flag_unsafe_math_optimizations\n-\t      && (fcode == BUILT_IN_ATAN\n-\t\t  || fcode == BUILT_IN_ATANF\n-\t\t  || fcode == BUILT_IN_ATANL))\n-\t    return TREE_VALUE (TREE_OPERAND (arg, 1));\n-\t}\n-      break;\n+      return fold_builtin_tan (arglist);\n \n     case BUILT_IN_ATAN:\n     case BUILT_IN_ATANF:\n     case BUILT_IN_ATANL:\n-      if (validate_arglist (arglist, REAL_TYPE, VOID_TYPE))\n-\t{\n-\t  tree arg = TREE_VALUE (arglist);\n-\n-\t  /* Optimize atan(0.0) = 0.0.  */\n-\t  if (real_zerop (arg))\n-\t    return arg;\n-\n-\t  /* Optimize atan(1.0) = pi/4.  */\n-\t  if (real_onep (arg))\n-\t    {\n-\t      REAL_VALUE_TYPE cst;\n-\n-\t      real_convert (&cst, TYPE_MODE (type), &dconstpi);\n-\t      SET_REAL_EXP (&cst, REAL_EXP (&cst) - 2);\n-\t      return build_real (type, cst);\n-\t    }\n-\t}\n-      break;\n+      return fold_builtin_atan (arglist, type);\n \n     case BUILT_IN_POW:\n     case BUILT_IN_POWF:\n     case BUILT_IN_POWL:\n-      if (validate_arglist (arglist, REAL_TYPE, REAL_TYPE, VOID_TYPE))\n-\t{\n-\t  enum built_in_function fcode;\n-\t  tree arg0 = TREE_VALUE (arglist);\n-\t  tree arg1 = TREE_VALUE (TREE_CHAIN (arglist));\n-\n-\t  /* Optimize pow(1.0,y) = 1.0.  */\n-\t  if (real_onep (arg0))\n-\t    return omit_one_operand (type, build_real (type, dconst1), arg1);\n-\n-\t  if (TREE_CODE (arg1) == REAL_CST\n-\t      && ! TREE_CONSTANT_OVERFLOW (arg1))\n-\t    {\n-\t      REAL_VALUE_TYPE c;\n-\t      c = TREE_REAL_CST (arg1);\n-\n-\t      /* Optimize pow(x,0.0) = 1.0.  */\n-\t      if (REAL_VALUES_EQUAL (c, dconst0))\n-\t\treturn omit_one_operand (type, build_real (type, dconst1),\n-\t\t\t\t\t arg0);\n-\n-\t      /* Optimize pow(x,1.0) = x.  */\n-\t      if (REAL_VALUES_EQUAL (c, dconst1))\n-\t\treturn arg0;\n-\n-\t      /* Optimize pow(x,-1.0) = 1.0/x.  */\n-\t      if (REAL_VALUES_EQUAL (c, dconstm1))\n-\t\treturn fold (build2 (RDIV_EXPR, type,\n-\t\t\t\t     build_real (type, dconst1), arg0));\n-\n-\t      /* Optimize pow(x,0.5) = sqrt(x).  */\n-\t      if (flag_unsafe_math_optimizations\n-\t\t  && REAL_VALUES_EQUAL (c, dconsthalf))\n-\t\t{\n-\t\t  tree sqrtfn = mathfn_built_in (type, BUILT_IN_SQRT);\n-\n-\t\t  if (sqrtfn != NULL_TREE)\n-\t\t    {\n-\t\t      tree arglist = build_tree_list (NULL_TREE, arg0);\n-\t\t      return build_function_call_expr (sqrtfn, arglist);\n-\t\t    }\n-\t\t}\n-\n-\t      /* Attempt to evaluate pow at compile-time.  */\n-\t      if (TREE_CODE (arg0) == REAL_CST\n-\t\t  && ! TREE_CONSTANT_OVERFLOW (arg0))\n-\t\t{\n-\t\t  REAL_VALUE_TYPE cint;\n-\t\t  HOST_WIDE_INT n;\n-\n-\t\t  n = real_to_integer (&c);\n-\t\t  real_from_integer (&cint, VOIDmode, n,\n-\t\t\t\t     n < 0 ? -1 : 0, 0);\n-\t\t  if (real_identical (&c, &cint))\n-\t\t    {\n-\t\t      REAL_VALUE_TYPE x;\n-\t\t      bool inexact;\n-\n-\t\t      x = TREE_REAL_CST (arg0);\n-\t\t      inexact = real_powi (&x, TYPE_MODE (type), &x, n);\n-\t\t      if (flag_unsafe_math_optimizations || !inexact)\n-\t\t\treturn build_real (type, x);\n-\t\t    }\n-\t\t}\n-\t    }\n-\n-\t  /* Optimize pow(expN(x),y) = expN(x*y).  */\n-\t  fcode = builtin_mathfn_code (arg0);\n-\t  if (flag_unsafe_math_optimizations && BUILTIN_EXPONENT_P (fcode))\n-\t    {\n-\t      tree expfn = TREE_OPERAND (TREE_OPERAND (arg0, 0), 0);\n-\t      tree arg = TREE_VALUE (TREE_OPERAND (arg0, 1));\n-\t      arg = fold (build2 (MULT_EXPR, type, arg, arg1));\n-\t      arglist = build_tree_list (NULL_TREE, arg);\n-\t      return build_function_call_expr (expfn, arglist);\n-\t    }\n-\n-\t  /* Optimize pow(sqrt(x),y) = pow(x,y*0.5).  */\n-\t  if (flag_unsafe_math_optimizations && BUILTIN_SQRT_P (fcode))\n-\t    {\n-\t      tree narg0 = TREE_VALUE (TREE_OPERAND (arg0, 1));\n-\t      tree narg1 = fold (build2 (MULT_EXPR, type, arg1,\n-\t\t\t\t\t build_real (type, dconsthalf)));\n-\n-\t      arglist = tree_cons (NULL_TREE, narg0,\n-\t\t\t\t   build_tree_list (NULL_TREE, narg1));\n-\t      return build_function_call_expr (fndecl, arglist);\n-\t    }\n-\n-\t  /* Optimize pow(pow(x,y),z) = pow(x,y*z).  */\n-\t  if (flag_unsafe_math_optimizations\n-\t      && (fcode == BUILT_IN_POW\n-\t\t  || fcode == BUILT_IN_POWF\n-\t\t  || fcode == BUILT_IN_POWL))\n-\t    {\n-\t      tree arg00 = TREE_VALUE (TREE_OPERAND (arg0, 1));\n-\t      tree arg01 = TREE_VALUE (TREE_CHAIN (TREE_OPERAND (arg0, 1)));\n-\t      tree narg1 = fold (build2 (MULT_EXPR, type, arg01, arg1));\n-\t      arglist = tree_cons (NULL_TREE, arg00,\n-\t\t\t\t   build_tree_list (NULL_TREE, narg1));\n-\t      return build_function_call_expr (fndecl, arglist);\n-\t    }\n-\t}\n-      break;\n+      return fold_builtin_pow (fndecl, arglist, type);\n \n     case BUILT_IN_INF:\n     case BUILT_IN_INFF:"}]}