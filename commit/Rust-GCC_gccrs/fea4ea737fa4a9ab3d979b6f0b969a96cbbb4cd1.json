{"sha": "fea4ea737fa4a9ab3d979b6f0b969a96cbbb4cd1", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZmVhNGVhNzM3ZmE0YTlhYjNkOTc5YjZmMGI5NjlhOTZjYmJiNGNkMQ==", "commit": {"author": {"name": "Eric Botcazou", "email": "ebotcazou@adacore.com", "date": "2012-09-17T14:50:13Z"}, "committer": {"name": "Eric Botcazou", "email": "ebotcazou@gcc.gnu.org", "date": "2012-09-17T14:50:13Z"}, "message": "* tree-cfgcleanup. (cleanup_control_expr_graph) <GIMPLE_COND>: Remove\n\tcode doing propagation from degenerate PHI nodes.\n\t* tree-ssa-loop-ivcanon.c (propagate_into_all_uses): New function.\n\t(propagate_constants_for_unrolling): Likewise.\n\t(tree_unroll_loops_completely): If the current loop has been unrolled\n\tand its father isn't the entire function, propagate constants within\n\tthe new basic blocks by means of propagate_constants_for_unrolling.\n\nFrom-SVN: r191387", "tree": {"sha": "d096ec551125ec07018795cb4a794091435c90a9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d096ec551125ec07018795cb4a794091435c90a9"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/fea4ea737fa4a9ab3d979b6f0b969a96cbbb4cd1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fea4ea737fa4a9ab3d979b6f0b969a96cbbb4cd1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fea4ea737fa4a9ab3d979b6f0b969a96cbbb4cd1", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fea4ea737fa4a9ab3d979b6f0b969a96cbbb4cd1/comments", "author": null, "committer": null, "parents": [{"sha": "9bf714c23f5dd6d340571d090f2b22d7f67a9503", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9bf714c23f5dd6d340571d090f2b22d7f67a9503", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9bf714c23f5dd6d340571d090f2b22d7f67a9503"}], "stats": {"total": 216, "additions": 178, "deletions": 38}, "files": [{"sha": "587f878be60eb7e14fdf63423e55eace68396fdd", "filename": "gcc/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fea4ea737fa4a9ab3d979b6f0b969a96cbbb4cd1/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fea4ea737fa4a9ab3d979b6f0b969a96cbbb4cd1/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=fea4ea737fa4a9ab3d979b6f0b969a96cbbb4cd1", "patch": "@@ -1,3 +1,13 @@\n+2012-09-17  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\t* tree-cfgcleanup. (cleanup_control_expr_graph) <GIMPLE_COND>: Remove\n+\tcode doing propagation from degenerate PHI nodes.\n+\t* tree-ssa-loop-ivcanon.c (propagate_into_all_uses): New function.\n+\t(propagate_constants_for_unrolling): Likewise.\n+\t(tree_unroll_loops_completely): If the current loop has been unrolled\n+\tand its father isn't the entire function, propagate constants within\n+\tthe new basic blocks by means of propagate_constants_for_unrolling.\n+\n 2012-09-17  Jakub Jelinek  <jakub@redhat.com>\n \n \tPR tree-optimization/54563"}, {"sha": "7581988f70150b9072ff0d3de79dace5a498dbc1", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fea4ea737fa4a9ab3d979b6f0b969a96cbbb4cd1/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fea4ea737fa4a9ab3d979b6f0b969a96cbbb4cd1/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=fea4ea737fa4a9ab3d979b6f0b969a96cbbb4cd1", "patch": "@@ -1,3 +1,7 @@\n+2012-09-17  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\t* gnat.dg/loop_optimization12.ad[sb]: New test.\n+\n 2012-09-17  Janus Weil  <janus@gcc.gnu.org>\n \n \tPR fortran/54285"}, {"sha": "240874654a7f8400a1763744b52654badf446ff2", "filename": "gcc/testsuite/gnat.dg/loop_optimization12.adb", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fea4ea737fa4a9ab3d979b6f0b969a96cbbb4cd1/gcc%2Ftestsuite%2Fgnat.dg%2Floop_optimization12.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fea4ea737fa4a9ab3d979b6f0b969a96cbbb4cd1/gcc%2Ftestsuite%2Fgnat.dg%2Floop_optimization12.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgnat.dg%2Floop_optimization12.adb?ref=fea4ea737fa4a9ab3d979b6f0b969a96cbbb4cd1", "patch": "@@ -0,0 +1,22 @@\n+-- { dg-do compile }\n+-- { dg-options \"-O2\" }\n+\n+package body Loop_Optimization12 is\n+\n+  procedure Reset (S : Rec_Ptr) is\n+  begin\n+    for I in Enum1 loop\n+      S.F (I).all := (others =>\n+                       (others =>\n+                         (others =>\n+                           (others =>\n+                             (others =>\n+                               (others =>\n+                                 (others =>\n+                                   (others =>\n+                                    (others =>\n+                                      (others => 0))))))))));\n+    end loop;\n+  end;\n+\n+end Loop_Optimization12;"}, {"sha": "0ed4e8b4b20af633f85ead39ad751a230e7f57b8", "filename": "gcc/testsuite/gnat.dg/loop_optimization12.ads", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fea4ea737fa4a9ab3d979b6f0b969a96cbbb4cd1/gcc%2Ftestsuite%2Fgnat.dg%2Floop_optimization12.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fea4ea737fa4a9ab3d979b6f0b969a96cbbb4cd1/gcc%2Ftestsuite%2Fgnat.dg%2Floop_optimization12.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgnat.dg%2Floop_optimization12.ads?ref=fea4ea737fa4a9ab3d979b6f0b969a96cbbb4cd1", "patch": "@@ -0,0 +1,27 @@\n+package Loop_Optimization12 is\n+\n+  type Enum1 is (A, B, C, D, E, F, G, H, I, J);\n+\n+  type Enum2 is (A, B, C);\n+\n+  type Enum3 is (A, B, C, D, E, F);\n+\n+  type Enum4 is (A, B, C, D);\n+\n+  type Enum5 is (A, B, C, D, E);\n+\n+  type Arr is array (Enum3, Enum4, Enum4, Enum5, Enum5, Enum3,\n+                     Enum2, Enum3, Enum5, Enum3) of Natural;\n+\n+  type Arr_Ptr is access Arr;\n+  type Ext_Arr is array (Enum1) of Arr_Ptr;\n+\n+  type Rec is record\n+    F : Ext_Arr;\n+  end record;\n+\n+  type Rec_Ptr is access Rec;\n+\n+  procedure Reset (S : Rec_Ptr);\n+\n+end Loop_Optimization12;"}, {"sha": "9c5228614011bf4496957ad304c0d24946159494", "filename": "gcc/tree-cfgcleanup.c", "status": "modified", "additions": 5, "deletions": 34, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fea4ea737fa4a9ab3d979b6f0b969a96cbbb4cd1/gcc%2Ftree-cfgcleanup.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fea4ea737fa4a9ab3d979b6f0b969a96cbbb4cd1/gcc%2Ftree-cfgcleanup.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-cfgcleanup.c?ref=fea4ea737fa4a9ab3d979b6f0b969a96cbbb4cd1", "patch": "@@ -88,40 +88,11 @@ cleanup_control_expr_graph (basic_block bb, gimple_stmt_iterator gsi)\n       switch (gimple_code (stmt))\n \t{\n \tcase GIMPLE_COND:\n-\t  {\n-\t    tree lhs = gimple_cond_lhs (stmt);\n-\t    tree rhs = gimple_cond_rhs (stmt);\n-\t    /* For conditions try harder and lookup single-argument\n-\t       PHI nodes.  Only do so from the same basic-block though\n-\t       as other basic-blocks may be dead already.  */\n-\t    if (TREE_CODE (lhs) == SSA_NAME\n-\t\t&& !name_registered_for_update_p (lhs))\n-\t      {\n-\t\tgimple def_stmt = SSA_NAME_DEF_STMT (lhs);\n-\t\tif (gimple_code (def_stmt) == GIMPLE_PHI\n-\t\t    && gimple_phi_num_args (def_stmt) == 1\n-\t\t    && gimple_bb (def_stmt) == gimple_bb (stmt)\n-\t\t    && (TREE_CODE (PHI_ARG_DEF (def_stmt, 0)) != SSA_NAME\n-\t\t\t|| !name_registered_for_update_p (PHI_ARG_DEF (def_stmt,\n-\t\t\t\t\t\t\t\t       0))))\n-\t\t  lhs = PHI_ARG_DEF (def_stmt, 0);\n-\t      }\n-\t    if (TREE_CODE (rhs) == SSA_NAME\n-\t\t&& !name_registered_for_update_p (rhs))\n-\t      {\n-\t\tgimple def_stmt = SSA_NAME_DEF_STMT (rhs);\n-\t\tif (gimple_code (def_stmt) == GIMPLE_PHI\n-\t\t    && gimple_phi_num_args (def_stmt) == 1\n-\t\t    && gimple_bb (def_stmt) == gimple_bb (stmt)\n-\t\t    && (TREE_CODE (PHI_ARG_DEF (def_stmt, 0)) != SSA_NAME\n-\t\t\t|| !name_registered_for_update_p (PHI_ARG_DEF (def_stmt,\n-\t\t\t\t\t\t\t\t       0))))\n-\t\t  rhs = PHI_ARG_DEF (def_stmt, 0);\n-\t      }\n-\t    val = fold_binary_loc (loc, gimple_cond_code (stmt),\n-\t\t\t\t   boolean_type_node, lhs, rhs);\n-\t    break;\n-\t  }\n+\t  val = fold_binary_loc (loc, gimple_cond_code (stmt),\n+\t\t\t\t boolean_type_node,\n+\t\t\t         gimple_cond_lhs (stmt),\n+\t\t\t\t gimple_cond_rhs (stmt));\n+\t  break;\n \n \tcase GIMPLE_SWITCH:\n \t  val = gimple_switch_index (stmt);"}, {"sha": "1e44dd4c7355607e633127014d3299910b0a13b5", "filename": "gcc/tree-ssa-loop-ivcanon.c", "status": "modified", "additions": 110, "deletions": 4, "changes": 114, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fea4ea737fa4a9ab3d979b6f0b969a96cbbb4cd1/gcc%2Ftree-ssa-loop-ivcanon.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fea4ea737fa4a9ab3d979b6f0b969a96cbbb4cd1/gcc%2Ftree-ssa-loop-ivcanon.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-ivcanon.c?ref=fea4ea737fa4a9ab3d979b6f0b969a96cbbb4cd1", "patch": "@@ -503,13 +503,88 @@ canonicalize_induction_variables (void)\n   return 0;\n }\n \n+/* Propagate VAL into all uses of SSA_NAME.  */\n+\n+static void\n+propagate_into_all_uses (tree ssa_name, tree val)\n+{\n+  imm_use_iterator iter;\n+  gimple use_stmt;\n+\n+  FOR_EACH_IMM_USE_STMT (use_stmt, iter, ssa_name)\n+    {\n+      gimple_stmt_iterator use_stmt_gsi = gsi_for_stmt (use_stmt);\n+      use_operand_p use;\n+\n+      FOR_EACH_IMM_USE_ON_STMT (use, iter)\n+\tSET_USE (use, val);\n+\n+      if (is_gimple_assign (use_stmt)\n+\t  && get_gimple_rhs_class (gimple_assign_rhs_code (use_stmt))\n+\t     == GIMPLE_SINGLE_RHS)\n+\t{\n+\t  tree rhs = gimple_assign_rhs1 (use_stmt);\n+\n+\t  if (TREE_CODE (rhs) == ADDR_EXPR)\n+\t    recompute_tree_invariant_for_addr_expr (rhs);\n+\t}\n+\n+      fold_stmt_inplace (&use_stmt_gsi);\n+      update_stmt (use_stmt);\n+    }\n+}\n+\n+/* Propagate constant SSA_NAMEs defined in basic block BB.  */\n+\n+static void\n+propagate_constants_for_unrolling (basic_block bb)\n+{\n+  gimple_stmt_iterator gsi;\n+\n+  /* Look for degenerate PHI nodes with constant argument.  */\n+  for (gsi = gsi_start_phis (bb); !gsi_end_p (gsi); )\n+    {\n+      gimple phi = gsi_stmt (gsi);\n+      tree result = gimple_phi_result (phi);\n+      tree arg = gimple_phi_arg_def (phi, 0);\n+\n+      if (gimple_phi_num_args (phi) == 1 && TREE_CODE (arg) == INTEGER_CST)\n+\t{\n+\t  propagate_into_all_uses (result, arg);\n+\t  gsi_remove (&gsi, true);\n+\t  release_ssa_name (result);\n+\t}\n+      else\n+\tgsi_next (&gsi);\n+    }\n+\n+  /* Look for assignments to SSA names with constant RHS.  */\n+  for (gsi = gsi_start_bb (bb); !gsi_end_p (gsi); )\n+    {\n+      gimple stmt = gsi_stmt (gsi);\n+      tree lhs;\n+\n+      if (is_gimple_assign (stmt)\n+\t  && (lhs = gimple_assign_lhs (stmt), TREE_CODE (lhs) == SSA_NAME)\n+\t  && gimple_assign_rhs_code (stmt) == INTEGER_CST)\n+\t{\n+\t  propagate_into_all_uses (lhs, gimple_assign_rhs1 (stmt));\n+\t  gsi_remove (&gsi, true);\n+\t  release_ssa_name (lhs);\n+\t}\n+      else\n+\tgsi_next (&gsi);\n+    }\n+}\n+\n /* Unroll LOOPS completely if they iterate just few times.  Unless\n    MAY_INCREASE_SIZE is true, perform the unrolling only if the\n    size of the code does not increase.  */\n \n unsigned int\n tree_unroll_loops_completely (bool may_increase_size, bool unroll_outer)\n {\n+  VEC(loop_p,stack) *father_stack = VEC_alloc (loop_p, stack, 16);\n   loop_iterator li;\n   struct loop *loop;\n   bool changed;\n@@ -522,22 +597,51 @@ tree_unroll_loops_completely (bool may_increase_size, bool unroll_outer)\n \n       FOR_EACH_LOOP (li, loop, LI_ONLY_INNERMOST)\n \t{\n+\t  struct loop *loop_father = loop_outer (loop);\n+\n \t  if (may_increase_size && optimize_loop_for_speed_p (loop)\n \t      /* Unroll outermost loops only if asked to do so or they do\n \t\t not cause code growth.  */\n-\t      && (unroll_outer\n-\t\t  || loop_outer (loop_outer (loop))))\n+\t      && (unroll_outer || loop_outer (loop_father)))\n \t    ul = UL_ALL;\n \t  else\n \t    ul = UL_NO_GROWTH;\n-\t  changed |= canonicalize_loop_induction_variables\n-\t\t       (loop, false, ul, !flag_tree_loop_ivcanon);\n+\n+\t  if (canonicalize_loop_induction_variables (loop, false, ul,\n+\t\t\t\t\t\t     !flag_tree_loop_ivcanon))\n+\t    {\n+\t      changed = true;\n+\t      /* If we'll continue unrolling, we need to propagate constants\n+\t\t within the new basic blocks to fold away induction variable\n+\t\t computations; otherwise, the size might blow up before the\n+\t\t iteration is complete and the IR eventually cleaned up.  */\n+\t      if (loop_outer (loop_father) && !loop_father->aux)\n+\t        {\n+\t\t  VEC_safe_push (loop_p, stack, father_stack, loop_father);\n+\t\t  loop_father->aux = loop_father;\n+\t\t}\n+\t    }\n \t}\n \n       if (changed)\n \t{\n+\t  struct loop **iter;\n+\t  unsigned i;\n+\n \t  update_ssa (TODO_update_ssa);\n \n+\t  /* Propagate the constants within the new basic blocks.  */\n+\t  FOR_EACH_VEC_ELT (loop_p, father_stack, i, iter)\n+\t    {\n+\t      unsigned j;\n+\t      basic_block *body = get_loop_body_in_dom_order (*iter);\n+\t      for (j = 0; j < (*iter)->num_nodes; j++)\n+\t\tpropagate_constants_for_unrolling (body[j]);\n+\t      free (body);\n+\t      (*iter)->aux = NULL;\n+\t    }\n+\t  VEC_truncate (loop_p, father_stack, 0);\n+\n \t  /* This will take care of removing completely unrolled loops\n \t     from the loop structures so we can continue unrolling now\n \t     innermost loops.  */\n@@ -552,5 +656,7 @@ tree_unroll_loops_completely (bool may_increase_size, bool unroll_outer)\n   while (changed\n \t && ++iteration <= PARAM_VALUE (PARAM_MAX_UNROLL_ITERATIONS));\n \n+  VEC_free (loop_p, stack, father_stack);\n+\n   return 0;\n }"}]}