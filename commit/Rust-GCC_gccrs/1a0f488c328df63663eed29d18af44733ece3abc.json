{"sha": "1a0f488c328df63663eed29d18af44733ece3abc", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MWEwZjQ4OGMzMjhkZjYzNjYzZWVkMjlkMThhZjQ0NzMzZWNlM2FiYw==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@redhat.com", "date": "2004-12-25T09:54:40Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2004-12-25T09:54:40Z"}, "message": "ffi64.c (struct register_args): Rename from stackLayout.\n\n        * src/x86/ffi64.c (struct register_args): Rename from stackLayout.\n        (enum x86_64_reg_class): Add X86_64_COMPLEX_X87_CLASS.\n        (merge_classes): Check for it.\n        (SSE_CLASS_P): New.\n        (classify_argument): Pass byte_offset by value; perform all updates\n        inside struct case.\n        (examine_argument): Add classes argument; handle\n        X86_64_COMPLEX_X87_CLASS.\n        (ffi_prep_args): Merge into ...\n        (ffi_call): ... here.  Share stack frame with ffi_call_unix64.\n        (ffi_prep_cif_machdep): Setup cif->flags for proper structure return.\n        (ffi_fill_return_value): Remove.\n        (ffi_prep_closure): Remove dead assert.\n        (ffi_closure_unix64_inner): Rename from ffi_closure_UNIX64_inner.\n        Rewrite to use struct register_args instead of va_list.  Create\n        flags for handling structure returns.\n        * src/x86/unix64.S: Remove dead strings.\n        (ffi_call_unix64): Rename from ffi_call_UNIX64.  Rewrite to share\n        stack frame with ffi_call.  Handle structure returns properly.\n        (float2sse, floatfloat2sse, double2sse): Remove.\n        (sse2float, sse2double, sse2floatfloat): Remove.\n        (ffi_closure_unix64): Rename from ffi_closure_UNIX64.  Rewrite\n        to handle structure returns properly.\n\nFrom-SVN: r92602", "tree": {"sha": "ee86acf0cf82fc125cf24870db047bb772f51cfa", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ee86acf0cf82fc125cf24870db047bb772f51cfa"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/1a0f488c328df63663eed29d18af44733ece3abc", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1a0f488c328df63663eed29d18af44733ece3abc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1a0f488c328df63663eed29d18af44733ece3abc", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1a0f488c328df63663eed29d18af44733ece3abc/comments", "author": null, "committer": null, "parents": [{"sha": "fa54a7a743310d8c10cec4fef91d7bff3705984f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fa54a7a743310d8c10cec4fef91d7bff3705984f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fa54a7a743310d8c10cec4fef91d7bff3705984f"}], "stats": {"total": 1232, "additions": 592, "deletions": 640}, "files": [{"sha": "e26f22d9d21f23a15d2ea72890570132d28f19f0", "filename": "libffi/ChangeLog", "status": "modified", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a0f488c328df63663eed29d18af44733ece3abc/libffi%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a0f488c328df63663eed29d18af44733ece3abc/libffi%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2FChangeLog?ref=1a0f488c328df63663eed29d18af44733ece3abc", "patch": "@@ -1,3 +1,29 @@\n+2004-12-25  Richard Henderson  <rth@redhat.com>\n+\n+\t* src/x86/ffi64.c (struct register_args): Rename from stackLayout.\n+\t(enum x86_64_reg_class): Add X86_64_COMPLEX_X87_CLASS.\n+\t(merge_classes): Check for it.\n+\t(SSE_CLASS_P): New.\n+\t(classify_argument): Pass byte_offset by value; perform all updates\n+\tinside struct case.\n+\t(examine_argument): Add classes argument; handle\n+\tX86_64_COMPLEX_X87_CLASS.\n+\t(ffi_prep_args): Merge into ...\n+\t(ffi_call): ... here.  Share stack frame with ffi_call_unix64.\n+\t(ffi_prep_cif_machdep): Setup cif->flags for proper structure return.\n+\t(ffi_fill_return_value): Remove.\n+\t(ffi_prep_closure): Remove dead assert.\n+\t(ffi_closure_unix64_inner): Rename from ffi_closure_UNIX64_inner.\n+\tRewrite to use struct register_args instead of va_list.  Create\n+\tflags for handling structure returns.\n+\t* src/x86/unix64.S: Remove dead strings.\n+\t(ffi_call_unix64): Rename from ffi_call_UNIX64.  Rewrite to share\n+\tstack frame with ffi_call.  Handle structure returns properly.\n+\t(float2sse, floatfloat2sse, double2sse): Remove.\n+\t(sse2float, sse2double, sse2floatfloat): Remove.\n+\t(ffi_closure_unix64): Rename from ffi_closure_UNIX64.  Rewrite\n+\tto handle structure returns properly.\n+\n 2004-12-08  David Edelsohn  <edelsohn@gnu.org>\n \n \t* Makefile.am (AM_MAKEFLAGS): Remove duplicate LIBCFLAGS and"}, {"sha": "754975ec060303ae389ce74e87d4384edb6fa6c8", "filename": "libffi/src/x86/ffi64.c", "status": "modified", "additions": 249, "deletions": 395, "changes": 644, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a0f488c328df63663eed29d18af44733ece3abc/libffi%2Fsrc%2Fx86%2Fffi64.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a0f488c328df63663eed29d18af44733ece3abc/libffi%2Fsrc%2Fx86%2Fffi64.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Fsrc%2Fx86%2Fffi64.c?ref=1a0f488c328df63663eed29d18af44733ece3abc", "patch": "@@ -29,22 +29,20 @@\n #include <stdlib.h>\n #include <stdarg.h>\n \n-/* ffi_prep_args is called by the assembly routine once stack space\n-   has been allocated for the function's arguments */\n-\n #ifdef __x86_64__\n \n #define MAX_GPR_REGS 6\n #define MAX_SSE_REGS 8\n-typedef struct\n+\n+struct register_args\n {\n   /* Registers for argument passing.  */\n-  long gpr[MAX_GPR_REGS];\n+  UINT64 gpr[MAX_GPR_REGS];\n   __int128_t sse[MAX_SSE_REGS];\n+};\n \n-  /* Stack space for arguments.  */\n-  char argspace[0];\n-} stackLayout;\n+extern void ffi_call_unix64 (void *args, unsigned long bytes, unsigned flags,\n+\t\t\t     void *raddr, void (*fnaddr)());\n \n /* All reference to register classes here is identical to the code in\n    gcc/config/i386/i386.c. Do *not* change one without the other.  */\n@@ -55,8 +53,7 @@ typedef struct\n    use SF or DFmode move instead of DImode to avoid reformating penalties.\n \n    Similary we play games with INTEGERSI_CLASS to use cheaper SImode moves\n-   whenever possible (upper half does contain padding).\n- */\n+   whenever possible (upper half does contain padding).  */\n enum x86_64_reg_class\n   {\n     X86_64_NO_CLASS,\n@@ -68,11 +65,14 @@ enum x86_64_reg_class\n     X86_64_SSEUP_CLASS,\n     X86_64_X87_CLASS,\n     X86_64_X87UP_CLASS,\n+    X86_64_COMPLEX_X87_CLASS,\n     X86_64_MEMORY_CLASS\n   };\n \n #define MAX_CLASSES 4\n \n+#define SSE_CLASS_P(X)\t((X) >= X86_64_SSE_CLASS && X <= X86_64_SSEUP_CLASS)\n+\n /* x86-64 register passing implementation.  See x86-64 ABI for details.  Goal\n    of this code is to classify each 8bytes of incoming argument by the register\n    class and assign registers accordingly.  */\n@@ -106,9 +106,14 @@ merge_classes (enum x86_64_reg_class class1, enum x86_64_reg_class class2)\n       || class2 == X86_64_INTEGER_CLASS || class2 == X86_64_INTEGERSI_CLASS)\n     return X86_64_INTEGER_CLASS;\n \n-  /* Rule #5: If one of the classes is X87 or X87UP class, MEMORY is used.  */\n-  if (class1 == X86_64_X87_CLASS || class1 == X86_64_X87UP_CLASS\n-      || class2 == X86_64_X87_CLASS || class2 == X86_64_X87UP_CLASS)\n+  /* Rule #5: If one of the classes is X87, X87UP, or COMPLEX_X87 class,\n+     MEMORY is used.  */\n+  if (class1 == X86_64_X87_CLASS\n+      || class1 == X86_64_X87UP_CLASS\n+      || class1 == X86_64_COMPLEX_X87_CLASS\n+      || class2 == X86_64_X87_CLASS\n+      || class2 == X86_64_X87UP_CLASS\n+      || class2 == X86_64_COMPLEX_X87_CLASS)\n     return X86_64_MEMORY_CLASS;\n \n   /* Rule #6: Otherwise class SSE is used.  */\n@@ -125,11 +130,8 @@ merge_classes (enum x86_64_reg_class class1, enum x86_64_reg_class class2)\n */\n static int\n classify_argument (ffi_type *type, enum x86_64_reg_class classes[],\n-\t\t   int *byte_offset)\n+\t\t   size_t byte_offset)\n {\n-  /* First, align to the right place.  */\n-  *byte_offset = ALIGN(*byte_offset, type->alignment);\n-\n   switch (type->type)\n     {\n     case FFI_TYPE_UINT8:\n@@ -141,13 +143,13 @@ classify_argument (ffi_type *type, enum x86_64_reg_class classes[],\n     case FFI_TYPE_UINT64:\n     case FFI_TYPE_SINT64:\n     case FFI_TYPE_POINTER:\n-      if (((*byte_offset) % 8 + type->size) <= 4)\n+      if (byte_offset + type->size <= 4)\n \tclasses[0] = X86_64_INTEGERSI_CLASS;\n       else\n \tclasses[0] = X86_64_INTEGER_CLASS;\n       return 1;\n     case FFI_TYPE_FLOAT:\n-      if (((*byte_offset) % 8) == 0)\n+      if (byte_offset == 0)\n \tclasses[0] = X86_64_SSESF_CLASS;\n       else\n \tclasses[0] = X86_64_SSE_CLASS;\n@@ -175,22 +177,23 @@ classify_argument (ffi_type *type, enum x86_64_reg_class classes[],\n \t  classes[i] = X86_64_NO_CLASS;\n \n \t/* Merge the fields of structure.  */\n-\tfor (ptr=type->elements; (*ptr)!=NULL; ptr++)\n+\tfor (ptr = type->elements; *ptr != NULL; ptr++)\n \t  {\n \t    int num;\n \n-\t    num = classify_argument (*ptr, subclasses, byte_offset);\n+\t    byte_offset = ALIGN (byte_offset, (*ptr)->alignment);\n+\n+\t    num = classify_argument (*ptr, subclasses, byte_offset % 8);\n \t    if (num == 0)\n \t      return 0;\n \t    for (i = 0; i < num; i++)\n \t      {\n-\t\tint pos = *byte_offset / 8;\n+\t\tint pos = byte_offset / 8;\n \t\tclasses[i + pos] =\n \t\t  merge_classes (subclasses[i], classes[i + pos]);\n \t      }\n \n-\t    if ((*ptr)->type != FFI_TYPE_STRUCT)\n-\t      *byte_offset += (*ptr)->size;\n+\t    byte_offset += (*ptr)->size;\n \t  }\n \n \t/* Final merger cleanup.  */\n@@ -222,359 +225,210 @@ classify_argument (ffi_type *type, enum x86_64_reg_class classes[],\n }\n \n /* Examine the argument and return set number of register required in each\n-   class.  Return 0 iff parameter should be passed in memory.  */\n+   class.  Return zero iff parameter should be passed in memory, otherwise\n+   the number of registers.  */\n+\n static int\n-examine_argument (ffi_type *type, int in_return, int *int_nregs,int *sse_nregs)\n+examine_argument (ffi_type *type, enum x86_64_reg_class classes[MAX_CLASSES],\n+\t\t  _Bool in_return, int *pngpr, int *pnsse)\n {\n-  enum x86_64_reg_class class[MAX_CLASSES];\n-  int offset = 0;\n-  int n;\n-\n-  n = classify_argument (type, class, &offset);\n+  int i, n, ngpr, nsse;\n \n+  n = classify_argument (type, classes, 0);\n   if (n == 0)\n     return 0;\n \n-  *int_nregs = 0;\n-  *sse_nregs = 0;\n-  for (n--; n>=0; n--)\n-    switch (class[n])\n+  ngpr = nsse = 0;\n+  for (i = 0; i < n; ++i)\n+    switch (classes[i])\n       {\n       case X86_64_INTEGER_CLASS:\n       case X86_64_INTEGERSI_CLASS:\n-\t(*int_nregs)++;\n+\tngpr++;\n \tbreak;\n       case X86_64_SSE_CLASS:\n       case X86_64_SSESF_CLASS:\n       case X86_64_SSEDF_CLASS:\n-\t(*sse_nregs)++;\n+\tnsse++;\n \tbreak;\n       case X86_64_NO_CLASS:\n       case X86_64_SSEUP_CLASS:\n \tbreak;\n       case X86_64_X87_CLASS:\n       case X86_64_X87UP_CLASS:\n-\tif (!in_return)\n-\t  return 0;\n-\tbreak;\n+      case X86_64_COMPLEX_X87_CLASS:\n+\treturn in_return != 0;\n       default:\n \tabort ();\n       }\n-  return 1;\n-}\n \n-/* Functions to load floats and double to an SSE register placeholder.  */\n-extern void float2sse (float, __int128_t *);\n-extern void double2sse (double, __int128_t *);\n-extern void floatfloat2sse (void *, __int128_t *);\n+  *pngpr = ngpr;\n+  *pnsse = nsse;\n \n-/* Functions to put the floats and doubles back.  */\n-extern float sse2float (__int128_t *);\n-extern double sse2double (__int128_t *);\n-extern void sse2floatfloat(__int128_t *, void *);\n+  return n;\n+}\n \n-/*@-exportheader@*/\n-void\n-ffi_prep_args (stackLayout *stack, extended_cif *ecif)\n-/*@=exportheader@*/\n+/* Perform machine dependent cif processing.  */\n+\n+ffi_status\n+ffi_prep_cif_machdep (ffi_cif *cif)\n {\n-  int gprcount, ssecount, i, g, s;\n-  void **p_argv;\n-  void *argp = &stack->argspace;\n-  ffi_type **p_arg;\n+  int gprcount, ssecount, i, avn, n, ngpr, nsse, flags;\n+  enum x86_64_reg_class classes[MAX_CLASSES];\n+  size_t bytes;\n \n-  /* First check if the return value should be passed in memory. If so,\n-     pass the pointer as the first argument.  */\n   gprcount = ssecount = 0;\n-  if (ecif->cif->rtype->type != FFI_TYPE_VOID \n-      && examine_argument (ecif->cif->rtype, 1, &g, &s) == 0)\n-    stack->gpr[gprcount++] = (long) ecif->rvalue;\n \n-  for (i=ecif->cif->nargs, p_arg=ecif->cif->arg_types, p_argv = ecif->avalue;\n-       i!=0; i--, p_arg++, p_argv++)\n+  flags = cif->rtype->type;\n+  if (flags != FFI_TYPE_VOID)\n     {\n-      int in_register = 0;\n-\n-      switch ((*p_arg)->type)\n-\t{\n-\tcase FFI_TYPE_SINT8:\n-\tcase FFI_TYPE_SINT16:\n-\tcase FFI_TYPE_SINT32:\n-\tcase FFI_TYPE_SINT64:\n-\tcase FFI_TYPE_UINT8:\n-\tcase FFI_TYPE_UINT16:\n-\tcase FFI_TYPE_UINT32:\n-\tcase FFI_TYPE_UINT64:\n-\tcase FFI_TYPE_POINTER:\n-\t  if (gprcount < MAX_GPR_REGS)\n-\t    {\n-\t      stack->gpr[gprcount] = 0;\n-\t      stack->gpr[gprcount++] = *(long long *)(*p_argv);\n-\t      in_register = 1;\n-\t    }\n-\t  break;\n-\n-\tcase FFI_TYPE_FLOAT:\n-\t  if (ssecount < MAX_SSE_REGS)\n-\t    {\n-\t      float2sse (*(float *)(*p_argv), &stack->sse[ssecount++]);\n-\t      in_register = 1;\n-\t    }\n-\t  break;\n-\n-\tcase FFI_TYPE_DOUBLE:\n-\t  if (ssecount < MAX_SSE_REGS)\n-\t    {\n-\t      double2sse (*(double *)(*p_argv), &stack->sse[ssecount++]);\n-\t      in_register = 1;\n-\t    }\n-\t  break;\n-\t}\n-\n-      if (in_register)\n-\tcontinue;\n-\n-      /* Either all places in registers where filled, or this is a\n-\t type that potentially goes into a memory slot.  */\n-      if (examine_argument (*p_arg, 0, &g, &s) == 0\n-\t  || gprcount + g > MAX_GPR_REGS || ssecount + s > MAX_SSE_REGS)\n+      n = examine_argument (cif->rtype, classes, 1, &ngpr, &nsse);\n+      if (n == 0)\n \t{\n-\t  /* Pass this argument in memory.  */\n-\t  argp = (void *)ALIGN(argp, (*p_arg)->alignment);\n-\t  /* Stack arguments are *always* at least 8 byte aligned.  */\n-\t  argp = (void *)ALIGN(argp, 8);\n-\t  memcpy (argp, *p_argv, (*p_arg)->size);\n-\t  argp += (*p_arg)->size;\n+\t  /* The return value is passed in memory.  A pointer to that\n+\t     memory is the first argument.  Allocate a register for it.  */\n+\t  gprcount++;\n+\t  /* We don't have to do anything in asm for the return.  */\n+\t  flags = FFI_TYPE_VOID;\n \t}\n-      else\n+      else if (flags == FFI_TYPE_STRUCT)\n \t{\n-\t  /* All easy cases are eliminated. Now fire the big guns.  */\n-\n-\t  enum x86_64_reg_class classes[MAX_CLASSES];\n-\t  int offset = 0, j, num;\n-\t  void *a;\n-\n-\t  num = classify_argument (*p_arg, classes, &offset);\n-\t  for (j=0, a=*p_argv; j<num; j++, a+=8)\n-\t    {\n-\t      switch (classes[j])\n-\t\t{\n-\t\tcase X86_64_INTEGER_CLASS:\n-\t\tcase X86_64_INTEGERSI_CLASS:\n-\t\t  stack->gpr[gprcount++] = *(long long *)a;\n-\t\t  break;\n-\t\tcase X86_64_SSE_CLASS:\n-\t\t  floatfloat2sse (a, &stack->sse[ssecount++]);\n-\t\t  break;\n-\t\tcase X86_64_SSESF_CLASS:\n-\t\t  float2sse (*(float *)a, &stack->sse[ssecount++]);\n-\t\t  break;\n-\t\tcase X86_64_SSEDF_CLASS:\n-\t\t  double2sse (*(double *)a, &stack->sse[ssecount++]);\n-\t\t  break;\n-\t\tdefault:\n-\t\t  abort();\n-\t\t}\n-\t    }\n+\t  /* Mark which registers the result appears in.  */\n+\t  _Bool sse0 = SSE_CLASS_P (classes[0]);\n+\t  _Bool sse1 = n == 2 && SSE_CLASS_P (classes[1]);\n+\t  if (sse0 && !sse1)\n+\t    flags |= 1 << 8;\n+\t  else if (!sse0 && sse1)\n+\t    flags |= 1 << 9;\n+\t  else if (sse0 && sse1)\n+\t    flags |= 1 << 10;\n+\t  /* Mark the true size of the structure.  */\n+\t  flags |= cif->rtype->size << 11;\n \t}\n     }\n-}\n-\n-/* Perform machine dependent cif processing.  */\n-ffi_status\n-ffi_prep_cif_machdep (ffi_cif *cif)\n-{\n-  int gprcount, ssecount, i, g, s;\n-\n-  gprcount = ssecount = 0;\n-\n-  /* Reset the byte count. We handle this size estimation here.  */\n-  cif->bytes = 0;\n-\n-  /* If the return value should be passed in memory, pass the pointer\n-     as the first argument. The actual memory isn't allocated here.  */\n-  if (cif->rtype->type != FFI_TYPE_VOID \n-      && examine_argument (cif->rtype, 1, &g, &s) == 0)\n-    gprcount = 1;\n+  cif->flags = flags;\n \n   /* Go over all arguments and determine the way they should be passed.\n      If it's in a register and there is space for it, let that be so. If\n      not, add it's size to the stack byte count.  */\n-  for (i=0; i<cif->nargs; i++)\n+  for (bytes = 0, i = 0, avn = cif->nargs; i < avn; i++)\n     {\n-      if (examine_argument (cif->arg_types[i], 0, &g, &s) == 0\n-\t  || gprcount + g > MAX_GPR_REGS || ssecount + s > MAX_SSE_REGS)\n+      if (examine_argument (cif->arg_types[i], classes, 0, &ngpr, &nsse) == 0\n+\t  || gprcount + ngpr > MAX_GPR_REGS\n+\t  || ssecount + nsse > MAX_SSE_REGS)\n \t{\n-\t  /* This is passed in memory. First align to the basic type.  */\n-\t  cif->bytes = ALIGN(cif->bytes, cif->arg_types[i]->alignment);\n+\t  long align = cif->arg_types[i]->alignment;\n \n-\t  /* Stack arguments are *always* at least 8 byte aligned.  */\n-\t  cif->bytes = ALIGN(cif->bytes, 8);\n+\t  if (align < 8)\n+\t    align = 8;\n \n-\t  /* Now add the size of this argument.  */\n-\t  cif->bytes += cif->arg_types[i]->size;\n+\t  bytes = ALIGN(bytes, align);\n+\t  bytes += cif->arg_types[i]->size;\n \t}\n       else\n \t{\n-\t  gprcount += g;\n-\t  ssecount += s;\n+\t  gprcount += ngpr;\n+\t  ssecount += nsse;\n \t}\n     }\n-\n-  /* Set the flag for the closures return.  */\n-    switch (cif->rtype->type)\n-    {\n-    case FFI_TYPE_VOID:\n-    case FFI_TYPE_STRUCT:\n-    case FFI_TYPE_SINT64:\n-    case FFI_TYPE_FLOAT:\n-    case FFI_TYPE_DOUBLE:\n-    case FFI_TYPE_LONGDOUBLE:\n-      cif->flags = (unsigned) cif->rtype->type;\n-      break;\n-\n-    case FFI_TYPE_UINT64:\n-      cif->flags = FFI_TYPE_SINT64;\n-      break;\n-\n-    default:\n-      cif->flags = FFI_TYPE_INT;\n-      break;\n-    }\n+  cif->bytes = bytes;\n \n   return FFI_OK;\n }\n \n-typedef struct\n-{\n-  long gpr[2];\n-  __int128_t sse[2];\n-  long double st0;\n-} return_value;\n-\n void\n-ffi_fill_return_value (return_value *rv, extended_cif *ecif)\n+ffi_call (ffi_cif *cif, void (*fn)(), void *rvalue, void **avalue)\n {\n   enum x86_64_reg_class classes[MAX_CLASSES];\n-  int i = 0, num;\n-  long *gpr = rv->gpr;\n-  __int128_t *sse = rv->sse;\n-  signed char sc;\n-  signed short ss;\n-\n-  /* This is needed because of the way x86-64 handles signed short\n-     integers.  */\n-  switch (ecif->cif->rtype->type)\n-    {\n-    case FFI_TYPE_SINT8:\n-      sc = *(signed char *)gpr;\n-      *(long long *)ecif->rvalue = (long long)sc;\n-      return;\n-    case FFI_TYPE_SINT16:\n-      ss = *(signed short *)gpr;\n-      *(long long *)ecif->rvalue = (long long)ss;\n-      return;\n-    default:\n-      /* Just continue.  */\n-      ;\n-    }\n+  char *stack, *argp;\n+  ffi_type **arg_types;\n+  int gprcount, ssecount, ngpr, nsse, i, avn;\n+  _Bool ret_in_memory;\n+  struct register_args *reg_args;\n+\n+  /* Can't call 32-bit mode from 64-bit mode.  */\n+  FFI_ASSERT (cif->abi == FFI_UNIX64);\n+\n+  /* If the return value is a struct and we don't have a return value\n+     address then we need to make one.  Note the setting of flags to\n+     VOID above in ffi_prep_cif_machdep.  */\n+  ret_in_memory = (cif->rtype->type == FFI_TYPE_STRUCT\n+\t\t   && cif->flags == FFI_TYPE_VOID);\n+  if (rvalue == NULL && ret_in_memory)\n+    rvalue = alloca (cif->rtype->size);\n+\n+  /* Allocate the space for the arguments, plus 4 words of temp space.  */\n+  stack = alloca (sizeof (struct register_args) + cif->bytes + 4*8);\n+  reg_args = (struct register_args *) stack;\n+  argp = stack + sizeof (struct register_args);\n+\n+  gprcount = ssecount = 0;\n \n-  num = classify_argument (ecif->cif->rtype, classes, &i);\n-\n-  if (num == 0)\n-    /* Return in memory.  */\n-    ecif->rvalue = (void *) rv->gpr[0];\n-  else if (num == 2 && classes[0] == X86_64_X87_CLASS &&\n-\tclasses[1] == X86_64_X87UP_CLASS)\n-    /* This is a long double (this is easiest to handle this way instead\n-       of an eightbyte at a time as in the loop below.  */\n-    *((long double *)ecif->rvalue) = rv->st0;\n-  else\n+  /* If the return value is passed in memory, add the pointer as the\n+     first integer argument.  */\n+  if (ret_in_memory)\n+    reg_args->gpr[gprcount++] = (long) rvalue;\n+\n+  avn = cif->nargs;\n+  arg_types = cif->arg_types;\n+\n+  for (i = 0; i < avn; ++i)\n     {\n-      void *a;\n+      size_t size = arg_types[i]->size;\n+      int n;\n \n-      for (i=0, a=ecif->rvalue; i<num; i++, a+=8)\n+      n = examine_argument (arg_types[i], classes, 0, &ngpr, &nsse);\n+      if (n == 0\n+\t  || gprcount + ngpr > MAX_GPR_REGS\n+\t  || ssecount + nsse > MAX_SSE_REGS)\n \t{\n-\t  switch (classes[i])\n-\t    {\n-\t    case X86_64_INTEGER_CLASS:\n-\t    case X86_64_INTEGERSI_CLASS:\n-\t      *(long long *)a = *gpr;\n-\t      gpr++;\n-\t      break;\n-\t    case X86_64_SSE_CLASS:\n-\t      sse2floatfloat (sse++, a);\n-\t      break;\n-\t    case X86_64_SSESF_CLASS:\n-\t      *(float *)a = sse2float (sse++);\n-\t      break;\n-\t    case X86_64_SSEDF_CLASS:\n-\t      *(double *)a = sse2double (sse++);\n-\t      break;\n-\t    default:\n-\t      abort();\n-\t    }\n-\t}\n-    }\n-}\n+\t  long align = arg_types[i]->alignment;\n \n-/*@-declundef@*/\n-/*@-exportheader@*/\n-extern void ffi_call_UNIX64(void (*)(stackLayout *, extended_cif *),\n-\t\t\t    void (*) (return_value *, extended_cif *),\n-\t\t\t    /*@out@*/ extended_cif *, \n-\t\t\t    unsigned, /*@out@*/ unsigned *, void (*fn)());\n-/*@=declundef@*/\n-/*@=exportheader@*/\n-\n-void ffi_call(/*@dependent@*/ ffi_cif *cif, \n-\t      void (*fn)(), \n-\t      /*@out@*/ void *rvalue, \n-\t      /*@dependent@*/ void **avalue)\n-{\n-  extended_cif ecif;\n-  int dummy;\n+\t  /* Stack arguments are *always* at least 8 byte aligned.  */\n+\t  if (align < 8)\n+\t    align = 8;\n \n-  ecif.cif = cif;\n-  ecif.avalue = avalue;\n-  \n-  /* If the return value is a struct and we don't have a return\t*/\n-  /* value address then we need to make one\t\t        */\n+\t  /* Pass this argument in memory.  */\n+\t  argp = (void *) ALIGN (argp, align);\n+\t  memcpy (argp, avalue[i], size);\n+\t  argp += size;\n+\t}\n+      else\n+\t{\n+\t  /* The argument is passed entirely in registers.  */\n+\t  char *a = (char *) avalue[i];\n+\t  int j;\n \n-  if ((rvalue == NULL) && \n-      (examine_argument (cif->rtype, 1, &dummy, &dummy) == 0))\n-    {\n-      /*@-sysunrecog@*/\n-      ecif.rvalue = alloca(cif->rtype->size);\n-      /*@=sysunrecog@*/\n+\t  for (j = 0; j < n; j++, a += 8, size -= 8)\n+\t    {\n+\t      switch (classes[j])\n+\t\t{\n+\t\tcase X86_64_INTEGER_CLASS:\n+\t\tcase X86_64_INTEGERSI_CLASS:\n+\t\t  reg_args->gpr[gprcount] = 0;\n+\t\t  memcpy (&reg_args->gpr[gprcount], a, size < 8 ? size : 8);\n+\t\t  gprcount++;\n+\t\t  break;\n+\t\tcase X86_64_SSE_CLASS:\n+\t\tcase X86_64_SSEDF_CLASS:\n+\t\t  reg_args->sse[ssecount++] = *(UINT64 *) a;\n+\t\t  break;\n+\t\tcase X86_64_SSESF_CLASS:\n+\t\t  reg_args->sse[ssecount++] = *(UINT32 *) a;\n+\t\t  break;\n+\t\tdefault:\n+\t\t  abort();\n+\t\t}\n+\t    }\n+\t}\n     }\n-  else\n-    ecif.rvalue = rvalue;\n-    \n-  /* Stack must always be 16byte aligned. Make it so.  */\n-  cif->bytes = ALIGN(cif->bytes, 16);\n-  \n-  switch (cif->abi) \n-    {\n-    case FFI_SYSV:\n-      /* Calling 32bit code from 64bit is not possible  */\n-      FFI_ASSERT(0);\n-      break;\n-\n-    case FFI_UNIX64:\n-      /*@-usedef@*/\n-      ffi_call_UNIX64 (ffi_prep_args, ffi_fill_return_value, &ecif,\n-\t\t       cif->bytes, ecif.rvalue, fn);\n-      /*@=usedef@*/\n-      break;\n \n-    default:\n-      FFI_ASSERT(0);\n-      break;\n-    }\n+  ffi_call_unix64 (stack, cif->bytes + sizeof (struct register_args),\n+\t\t   cif->flags, rvalue, fn);\n }\n \n-extern void ffi_closure_UNIX64(void);\n+\n+extern void ffi_closure_unix64(void);\n \n ffi_status\n ffi_prep_closure (ffi_closure* closure,\n@@ -584,14 +438,12 @@ ffi_prep_closure (ffi_closure* closure,\n {\n   volatile unsigned short *tramp;\n \n-  /* FFI_ASSERT (cif->abi == FFI_OSF);  */\n-\n   tramp = (volatile unsigned short *) &closure->tramp[0];\n   tramp[0] = 0xbb49;\t\t/* mov <code>, %r11\t*/\n   tramp[5] = 0xba49;\t\t/* mov <data>, %r10\t*/\n   tramp[10] = 0xff49;\t\t/* jmp *%r11\t*/\n   tramp[11] = 0x00e3;\n-  *(void * volatile *) &tramp[1] = ffi_closure_UNIX64;\n+  *(void * volatile *) &tramp[1] = ffi_closure_unix64;\n   *(void * volatile *) &tramp[6] = closure;\n \n   closure->cif = cif;\n@@ -602,107 +454,109 @@ ffi_prep_closure (ffi_closure* closure,\n }\n \n int\n-ffi_closure_UNIX64_inner(ffi_closure *closure, va_list l, void *rp)\n+ffi_closure_unix64_inner(ffi_closure *closure, void *rvalue,\n+\t\t\t struct register_args *reg_args, char *argp)\n {\n   ffi_cif *cif;\n   void **avalue;\n   ffi_type **arg_types;\n-  long i, avn, argn;\n+  long i, avn;\n+  int gprcount, ssecount, ngpr, nsse;\n+  int ret;\n \n   cif = closure->cif;\n   avalue = alloca(cif->nargs * sizeof(void *));\n+  gprcount = ssecount = 0;\n \n-  argn = 0;\n+  ret = cif->rtype->type;\n+  if (ret != FFI_TYPE_VOID)\n+    {\n+      enum x86_64_reg_class classes[MAX_CLASSES];\n+      int n = examine_argument (cif->rtype, classes, 1, &ngpr, &nsse);\n+      if (n == 0)\n+\t{\n+\t  /* The return value goes in memory.  Arrange for the closure\n+\t     return value to go directly back to the original caller.  */\n+\t  rvalue = (void *) reg_args->gpr[gprcount++];\n+\t  /* We don't have to do anything in asm for the return.  */\n+\t  ret = FFI_TYPE_VOID;\n+\t}\n+      else if (ret == FFI_TYPE_STRUCT && n == 2)\n+\t{\n+\t  /* Mark which register the second word of the structure goes in.  */\n+\t  _Bool sse0 = SSE_CLASS_P (classes[0]);\n+\t  _Bool sse1 = SSE_CLASS_P (classes[1]);\n+\t  if (!sse0 && sse1)\n+\t    ret |= 1 << 8;\n+\t  else if (sse0 && !sse1)\n+\t    ret |= 1 << 9;\n+\t}\n+    }\n \n-  i = 0;\n   avn = cif->nargs;\n   arg_types = cif->arg_types;\n   \n-  /* Grab the addresses of the arguments from the stack frame.  */\n-  while (i < avn)\n+  for (i = 0; i < avn; ++i)\n     {\n-      switch (arg_types[i]->type)\n+      enum x86_64_reg_class classes[MAX_CLASSES];\n+      int n;\n+\n+      n = examine_argument (arg_types[i], classes, 0, &ngpr, &nsse);\n+      if (n == 0\n+\t  || gprcount + ngpr > MAX_GPR_REGS\n+\t  || ssecount + nsse > MAX_SSE_REGS)\n \t{\n-\tcase FFI_TYPE_SINT8:\n-\tcase FFI_TYPE_UINT8:\n-\tcase FFI_TYPE_SINT16:\n-\tcase FFI_TYPE_UINT16:\n-\tcase FFI_TYPE_SINT32:\n-\tcase FFI_TYPE_UINT32:\n-\tcase FFI_TYPE_SINT64:\n-\tcase FFI_TYPE_UINT64:\n-\tcase FFI_TYPE_POINTER:\n-\t  {\n-\t    if (l->gp_offset > 48-8)\n-\t      {\n-\t\tavalue[i] = l->overflow_arg_area;\n-\t\tl->overflow_arg_area = (char *)l->overflow_arg_area + 8;\n-\t      }\n-\t    else\n-\t      {\n-\t\tavalue[i] = (char *)l->reg_save_area + l->gp_offset;\n-\t\tl->gp_offset += 8;\n-\t      }\n-\t  }\n-\t  break;\n+\t  long align = arg_types[i]->alignment;\n \n-\tcase FFI_TYPE_STRUCT:\n-\t  /* FIXME  */\n-\t  FFI_ASSERT(0);\n-\t  break;\n+\t  /* Stack arguments are *always* at least 8 byte aligned.  */\n+\t  if (align < 8)\n+\t    align = 8;\n \n-\tcase FFI_TYPE_DOUBLE:\n-\t  {\n-\t    if (l->fp_offset > 176-16)\n-\t      {\n-\t\tavalue[i] = l->overflow_arg_area;\n-\t\tl->overflow_arg_area = (char *)l->overflow_arg_area + 8;\n-\t      }\n-\t    else\n-\t      {\n-\t\tavalue[i] = (char *)l->reg_save_area + l->fp_offset;\n-\t\tl->fp_offset += 16;\n-\t      }\n-\t  }\n-#if DEBUG_FFI\n-\t  fprintf (stderr, \"double arg %d = %g\\n\", i, *(double *)avalue[i]);\n-#endif\n-\t  break;\n-\t  \n-\tcase FFI_TYPE_FLOAT:\n-\t  {\n-\t    if (l->fp_offset > 176-16)\n-\t      {\n-\t\tavalue[i] = l->overflow_arg_area;\n-\t\tl->overflow_arg_area = (char *)l->overflow_arg_area + 8;\n-\t      }\n-\t    else\n-\t      {\n-\t\tavalue[i] = (char *)l->reg_save_area + l->fp_offset;\n-\t\tl->fp_offset += 16;\n-\t      }\n-\t  }\n-#if DEBUG_FFI\n-\t  fprintf (stderr, \"float arg %d = %g\\n\", i, *(float *)avalue[i]);\n-#endif\n-\t  break;\n-\t  \n-\tdefault:\n-\t  FFI_ASSERT(0);\n+\t  /* Pass this argument in memory.  */\n+\t  argp = (void *) ALIGN (argp, align);\n+\t  avalue[i] = argp;\n+\t  argp += arg_types[i]->size;\n \t}\n+      /* If the argument is in a single register, or two consecutive\n+\t registers, then we can use that address directly.  */\n+      else if (n == 1\n+\t       || (n == 2\n+\t\t   && SSE_CLASS_P (classes[0]) == SSE_CLASS_P (classes[1])))\n+\t{\n+\t  /* The argument is in a single register.  */\n+\t  if (SSE_CLASS_P (classes[0]))\n+\t    {\n+\t      avalue[i] = &reg_args->sse[ssecount];\n+\t      ssecount += n;\n+\t    }\n+\t  else\n+\t    {\n+\t      avalue[i] = &reg_args->gpr[gprcount];\n+\t      gprcount += n;\n+\t    }\n+\t}\n+      /* Otherwise, allocate space to make them consecutive.  */\n+      else\n+\t{\n+\t  char *a = alloca (16);\n+\t  int j;\n \n-      argn += ALIGN(arg_types[i]->size, FFI_SIZEOF_ARG) / FFI_SIZEOF_ARG;\n-      i++;\n+\t  avalue[i] = a;\n+\t  for (j = 0; j < n; j++, a += 8)\n+\t    {\n+\t      if (SSE_CLASS_P (classes[j]))\n+\t\tmemcpy (a, &reg_args->sse[ssecount++], 8);\n+\t      else\n+\t\tmemcpy (a, &reg_args->gpr[gprcount++], 8);\n+\t    }\n+\t}\n     }\n \n   /* Invoke the closure.  */\n-  (closure->fun) (cif, rp, avalue, closure->user_data);\n-\n-  /* FIXME: Structs not supported.  */\n-  FFI_ASSERT(cif->rtype->type != FFI_TYPE_STRUCT);\n+  closure->fun (cif, rvalue, avalue, closure->user_data);\n \n-  /* Tell ffi_closure_UNIX64 how to perform return type promotions.  */\n-\n-  return cif->rtype->type;\n+  /* Tell assembly how to perform return type promotions.  */\n+  return ret;\n }\n-#endif /* ifndef __x86_64__ */\n+\n+#endif /* __x86_64__ */"}, {"sha": "5e1c6c5e516d63af791974a30dbb42d798d06c94", "filename": "libffi/src/x86/unix64.S", "status": "modified", "additions": 317, "deletions": 245, "changes": 562, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a0f488c328df63663eed29d18af44733ece3abc/libffi%2Fsrc%2Fx86%2Funix64.S", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a0f488c328df63663eed29d18af44733ece3abc/libffi%2Fsrc%2Fx86%2Funix64.S", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Fsrc%2Fx86%2Funix64.S?ref=1a0f488c328df63663eed29d18af44733ece3abc", "patch": "@@ -28,276 +28,348 @@\n #include <fficonfig.h>\n #include <ffi.h>\n \n-\t.section\t.rodata\n-.LC0:\n-\t.string\t\"asm in progress %lld\\n\"\n-.LC1:\n-\t.string\t\"asm in progress\\n\"\n .text\n+\n+/* ffi_call_unix64 (void *args, unsigned long bytes, unsigned flags,\n+                    void *raddr, void (*fnaddr)());\n+\n+   Bit o trickiness here -- ARGS+BYTES is the base of the stack frame\n+   for this function.  This has been allocated by ffi_call.  We also\n+   deallocate some of the stack that has been alloca'd.  */\n+\n \t.align\t2\n-.globl ffi_call_UNIX64\n-        .type\tffi_call_UNIX64,@function\n-\n-ffi_call_UNIX64:\n-.LFB1:\n-        pushq\t%rbp\n-.LCFI0:\n-        movq\t%rsp, %rbp\n-.LCFI1:\n-\t/* Save all arguments */\n-\tsubq\t$48, %rsp\n-.LCFI2:\n-\tmovq\t%rdi, -8(%rbp)\t\t/* ffi_prep_args\t */\n-\tmovq\t%rsi, -16(%rbp)\t\t/* ffi_fill_return_value */\n-\tmovq\t%rdx, -24(%rbp)\t\t/* ecif\t\t\t */\n-\tmovq\t%rcx, -32(%rbp)\t\t/* cif->bytes\t\t */\n-\tmovq\t%r8, -40(%rbp)\t\t/* ecif.rvalue\t\t */\n-\tmovq\t%r9, -48(%rbp)\t\t/* fn\t\t\t */\n-\n-\t/* Make room for all of the new args and the register args */\n-\taddl\t$176, %ecx\n-.LCFI3:\n-\tsubq\t%rcx, %rsp\n-.LCFI4:\n-\t/* Setup the call to ffi_prep_args.  */\n-\tmovq\t%rdi, %rax\t\t/* &ffi_prep_args\t*/\n-\tmovq\t%rsp, %rdi\t\t/* stackLayout\t\t*/\n-\tmovq\t%rdx, %rsi\t\t/* ecif\t\t\t*/\n-\tcall\t*%rax\t\t\t/* ffi_prep_args(stackLayout, ecif);*/ \n-\n-\t/* ffi_prep_args have put all the register contents into the  */\n-\t/* stackLayout struct. Now put the register values in place.  */\n-\tmovq\t(%rsp), %rdi\n-\tmovq\t8(%rsp), %rsi\n-\tmovq\t16(%rsp), %rdx\n-\tmovq\t24(%rsp), %rcx\n-\tmovq\t32(%rsp), %r8\n-\tmovq\t40(%rsp), %r9\n-\tmovaps\t48(%rsp), %xmm0\n-\tmovaps\t64(%rsp), %xmm1\n-\tmovaps\t80(%rsp), %xmm2\n-\tmovaps\t96(%rsp), %xmm3\n-\tmovaps\t112(%rsp), %xmm4\n-\tmovaps\t128(%rsp), %xmm5\n-\tmovaps\t144(%rsp), %xmm6\n-\tmovaps\t160(%rsp), %xmm7\n-\n-\t/* Remove space for stackLayout so stack arguments are placed\n-\t   correctly for the call.  */\n-.LCFI5:\n-\taddq\t$176, %rsp\n-.LCFI6:\n+\t.globl\tffi_call_unix64\n+        .type\tffi_call_unix64,@function\n+\n+ffi_call_unix64:\n+.LUW0:\n+\tmovq\t(%rsp), %r10\t\t/* Load return address.  */\n+\tleaq\t(%rdi, %rsi), %rax\t/* Find local stack base.  */\n+\tmovq\t%rdx, (%rax)\t\t/* Save flags.  */\n+\tmovq\t%rcx, 8(%rax)\t\t/* Save raddr.  */\n+\tmovq\t%rbp, 16(%rax)\t\t/* Save old frame pointer.  */\n+\tmovq\t%r10, 24(%rax)\t\t/* Relocate return address.  */\n+\tmovq\t%rax, %rbp\t\t/* Finalize local stack frame.  */\n+.LUW1:\n+\tmovq\t%rdi, %r10\t\t/* Save a copy of the register area. */\n+\tmovq\t%r8, %r11\t\t/* Save a copy of the target fn.  */\n+\n+\t/* Load up all argument registers.  */\n+\tmovq\t(%r10), %rdi\n+\tmovq\t8(%r10), %rsi\n+\tmovq\t16(%r10), %rdx\n+\tmovq\t24(%r10), %rcx\n+\tmovq\t32(%r10), %r8\n+\tmovq\t40(%r10), %r9\n+\tmovdqa\t48(%r10), %xmm0\n+\tmovdqa\t64(%r10), %xmm1\n+\tmovdqa\t80(%r10), %xmm2\n+\tmovdqa\t96(%r10), %xmm3\n+\tmovdqa\t112(%r10), %xmm4\n+\tmovdqa\t128(%r10), %xmm5\n+\tmovdqa\t144(%r10), %xmm6\n+\tmovdqa\t160(%r10), %xmm7\n+\n+\t/* Deallocate the reg arg area.  */\n+\tleaq\t176(%r10), %rsp\n+\n \t/* Call the user function.  */\n-\tcall\t*-48(%rbp)\n-\n-\t/* Make stack space for the return_value struct.  */\n-\tsubq\t$64, %rsp\n-\n-\t/* Fill in all potential return values to this struct.  */\n-\tmovq\t%rax, (%rsp)\n-\tmovq\t%rdx, 8(%rsp)\n-\tmovaps\t%xmm0, 16(%rsp)\n-\tmovaps\t%xmm1, 32(%rsp)\n-\tfstpt\t48(%rsp)\n-\n-\t/* Now call ffi_fill_return_value.  */\n-\tmovq\t%rsp, %rdi\t\t/* struct return_value\t  */\n-\tmovq\t-24(%rbp), %rsi\t\t/* ecif\t\t\t  */\n-\tmovq\t-16(%rbp), %rax\t\t/* &ffi_fill_return_value */\n-\tcall\t*%rax\t\t\t/* call it\t\t  */\n-\n-\t/* And the work is done.  */\n-        leave\n-        ret\n-.LFE1:\n-.ffi_call_UNIX64_end:\n-        .size    ffi_call_UNIX64,.ffi_call_UNIX64_end-ffi_call_UNIX64\n+\tcall\t*%r11\n \n-.text\n-\t.align\t2\n-.globl float2sse\n-        .type\tfloat2sse,@function\n-float2sse:\n-\t/* Save the contents of this sse-float in a pointer.  */\n-\tmovaps\t%xmm0, (%rdi)\n-\tret\n+\t/* Deallocate stack arg area; local stack frame in redzone.  */\n+\tleaq\t24(%rbp), %rsp\n \n-\t.align\t2\n-.globl floatfloat2sse\n-        .type\tfloatfloat2sse,@function\n-floatfloat2sse:\n-\t/* Save the contents of these two sse-floats in a pointer.  */\n-\tmovq\t(%rdi), %xmm0\n-\tmovaps\t%xmm0, (%rsi)\n-\tret\n+\tmovq\t0(%rbp), %rcx\t\t/* Reload flags.  */\n+\tmovq\t8(%rbp), %rdi\t\t/* Reload raddr.  */\n+\tmovq\t16(%rbp), %rbp\t\t/* Reload old frame pointer.  */\n+.LUW2:\n \n-\t.align\t2\n-.globl double2sse\n-        .type\tdouble2sse,@function\n-double2sse:\n-\t/* Save the contents of this sse-double in a pointer.  */\n-\tmovaps\t%xmm0, (%rdi)\n+\t/* The first byte of the flags contains the FFI_TYPE.  */\n+\tmovzbl\t%cl, %r10d\n+\tleaq\t.Lstore_table(%rip), %r11\n+\tmovslq\t(%r11, %r10, 4), %r10\n+\taddq\t%r11, %r10\n+\tjmp\t*%r10\n+\n+\t.section .rodata\n+.Lstore_table:\n+\t.long\t.Lst_void-.Lstore_table\t\t/* FFI_TYPE_VOID */\n+\t.long\t.Lst_sint32-.Lstore_table\t/* FFI_TYPE_INT */\n+\t.long\t.Lst_float-.Lstore_table\t/* FFI_TYPE_FLOAT */\n+\t.long\t.Lst_double-.Lstore_table\t/* FFI_TYPE_DOUBLE */\n+\t.long\t.Lst_ldouble-.Lstore_table\t/* FFI_TYPE_LONGDOUBLE */\n+\t.long\t.Lst_uint8-.Lstore_table\t/* FFI_TYPE_UINT8 */\n+\t.long\t.Lst_sint8-.Lstore_table\t/* FFI_TYPE_SINT8 */\n+\t.long\t.Lst_uint16-.Lstore_table\t/* FFI_TYPE_UINT16 */\n+\t.long\t.Lst_sint16-.Lstore_table\t/* FFI_TYPE_SINT16 */\n+\t.long\t.Lst_uint32-.Lstore_table\t/* FFI_TYPE_UINT32 */\n+\t.long\t.Lst_sint32-.Lstore_table\t/* FFI_TYPE_SINT32 */\n+\t.long\t.Lst_int64-.Lstore_table\t/* FFI_TYPE_UINT64 */\n+\t.long\t.Lst_int64-.Lstore_table\t/* FFI_TYPE_SINT64 */\n+\t.long\t.Lst_struct-.Lstore_table\t/* FFI_TYPE_STRUCT */\n+\t.long\t.Lst_int64-.Lstore_table\t/* FFI_TYPE_POINTER */\n+\n+\t.text\n+\t.align 2\n+.Lst_void:\n \tret\n+\t.align 2\n \n-\t.align\t2\n-.globl sse2float\n-        .type\tsse2float,@function\n-sse2float:\n-\t/* Save the contents of this sse-float in a pointer.  */\n-\tmovaps\t(%rdi), %xmm0\n+.Lst_uint8:\n+\tmovzbq\t%al, %rax\n+\tmovq\t%rax, (%rdi)\n+\tret\n+\t.align 2\n+.Lst_sint8:\n+\tmovsbq\t%al, %rax\n+\tmovq\t%rax, (%rdi)\n+\tret\n+\t.align 2\n+.Lst_uint16:\n+\tmovzwq\t%ax, %rax\n+\tmovq\t%rax, (%rdi)\n+\t.align 2\n+.Lst_sint16:\n+\tmovswq\t%ax, %rax\n+\tmovq\t%rax, (%rdi)\n+\tret\n+\t.align 2\n+.Lst_uint32:\n+\tmovl\t%eax, %eax\n+\tmovq\t%rax, (%rdi)\n+\t.align 2\n+.Lst_sint32:\n+\tcltq\n+\tmovq\t%rax, (%rdi)\n+\tret\n+\t.align 2\n+.Lst_int64:\n+\tmovq\t%rax, (%rdi)\n \tret\n \n-\t.align\t2\n-.globl sse2double\n-        .type\tsse2double,@function\n-sse2double:\n-\t/* Save the contents of this pointer in a sse-double.  */\n-\tmovaps\t(%rdi), %xmm0\n+\t.align 2\n+.Lst_float:\n+\tmovss\t%xmm0, (%rdi)\n+\tret\n+\t.align 2\n+.Lst_double:\n+\tmovsd\t%xmm0, (%rdi)\n+\tret\n+.Lst_ldouble:\n+\tfstpt\t(%rdi)\n \tret\n \n-\t.align\t2\n-.globl sse2floatfloat\n-        .type\tsse2floatfloat,@function\n-sse2floatfloat:\n-\t/* Save the contents of this pointer in two sse-floats.  */\n-\tmovaps\t(%rdi), %xmm0\n-\tmovq\t%xmm0, (%rsi)\n+\t.align 2\n+.Lst_struct:\n+\tleaq\t-20(%rsp), %rsi\t\t/* Scratch area in redzone.  */\n+\n+\t/* We have to locate the values now, and since we don't want to\n+\t   write too much data into the user's return value, we spill the\n+\t   value to a 16 byte scratch area first.  Bits 8, 9, and 10\n+\t   control where the values are located.  Only one of the three\n+\t   bits will be set; see ffi_prep_cif_machdep for the pattern.  */\n+\tmovd\t%xmm0, %r10\n+\tmovd\t%xmm1, %r11\n+\ttestl\t$0x100, %ecx\n+\tcmovnz\t%rax, %rdx\n+\tcmovnz\t%r10, %rax\n+\ttestl\t$0x200, %ecx\n+\tcmovnz\t%r10, %rdx\n+\ttestl\t$0x400, %ecx\n+\tcmovnz\t%r10, %rax\n+\tcmovnz\t%r11, %rdx\n+\tmovq\t%rax, (%rsi)\n+\tmovq\t%rdx, 8(%rsi)\n+\n+\t/* Bits 11-31 contain the true size of the structure.  Copy from\n+\t   the scratch area to the true destination.  */\n+\tshrl\t$11, %ecx\n+\trep movsb\n \tret\n+.LUW3:\n+\t.size    ffi_call_unix64,.-ffi_call_unix64\n \n \t.align\t2\n-.globl ffi_closure_UNIX64\n-        .type\tffi_closure_UNIX64,@function\n-\n-ffi_closure_UNIX64:\n-.LFB2:\n-        pushq   %rbp\n-.LCFI10:\n-        movq    %rsp, %rbp\n-.LCFI11:\n-        subq    $240, %rsp\n-.LCFI12:\n-\tmovq\t%rdi, -176(%rbp)\n-        movq    %rsi, -168(%rbp)\n-        movq    %rdx, -160(%rbp)\n-        movq    %rcx, -152(%rbp)\n-        movq    %r8, -144(%rbp)\n-        movq    %r9, -136(%rbp)\n-        /* FIXME: We can avoid all this stashing of XMM registers by\n-\t   (in ffi_prep_closure) computing the number of\n-\t   floating-point args and moving it into %rax before calling\n-\t   this function.  Once this is done, uncomment the next few\n-\t   lines and only the essential XMM registers will be written\n-\t   to memory.  This is a significant saving.  */\n-/*         movzbl  %al, %eax  */\n-/*         movq    %rax, %rdx */\n-/*         leaq    0(,%rdx,4), %rax */\n-/*         leaq    2f(%rip), %rdx */\n-/*         subq    %rax, %rdx */\n-        leaq    -1(%rbp), %rax\n-/*         jmp     *%rdx */\n-        movaps  %xmm7, -15(%rax)\n-        movaps  %xmm6, -31(%rax)\n-        movaps  %xmm5, -47(%rax)\n-        movaps  %xmm4, -63(%rax)\n-        movaps  %xmm3, -79(%rax)\n-        movaps  %xmm2, -95(%rax)\n-        movaps  %xmm1, -111(%rax)\n-        movaps  %xmm0, -127(%rax)\n-2:\n-        movl    %edi, -180(%rbp)\n-        movl    $0, -224(%rbp)\n-        movl    $48, -220(%rbp)\n-        leaq    16(%rbp), %rax\n-        movq    %rax, -216(%rbp)\n-        leaq    -176(%rbp), %rdx\n-        movq    %rdx, -208(%rbp)\n-        leaq    -224(%rbp), %rsi\n+\t.globl ffi_closure_unix64\n+        .type\tffi_closure_unix64,@function\n+\n+ffi_closure_unix64:\n+.LUW4:\n+\tsubq\t$200, %rsp\n+.LUW5:\n+\n+\tmovq\t%rdi, (%rsp)\n+        movq    %rsi, 8(%rsp)\n+        movq    %rdx, 16(%rsp)\n+        movq    %rcx, 24(%rsp)\n+        movq    %r8, 32(%rsp)\n+        movq    %r9, 40(%rsp)\n+\tmovdqa\t%xmm0, 48(%rsp)\n+\tmovdqa\t%xmm1, 64(%rsp)\n+\tmovdqa\t%xmm2, 80(%rsp)\n+\tmovdqa\t%xmm3, 96(%rsp)\n+\tmovdqa\t%xmm4, 112(%rsp)\n+\tmovdqa\t%xmm5, 128(%rsp)\n+\tmovdqa\t%xmm6, 144(%rsp)\n+\tmovdqa\t%xmm7, 160(%rsp)\n+\n \tmovq\t%r10, %rdi\n+\tleaq\t176(%rsp), %rsi\n \tmovq\t%rsp, %rdx\n-        call    ffi_closure_UNIX64_inner@PLT\n-\n-\tcmpl\t$FFI_TYPE_FLOAT, %eax\n-\tje\t1f\n-\tcmpl\t$FFI_TYPE_DOUBLE, %eax\n-\tje\t2f\n-\tcmpl\t$FFI_TYPE_LONGDOUBLE, %eax\n-\tje\t3f\n-\tcmpl\t$FFI_TYPE_STRUCT, %eax\n-\tje\t4f\n-\tpopq\t%rax\n-        leave\n-        ret\n-1:\n-2:\n-3:\t\n-\tmovaps\t-240(%rbp), %xmm0\n-        leave\n-        ret\n-4:\n-\tleave\n+\tleaq\t208(%rsp), %rcx\n+\tcall\tffi_closure_unix64_inner@PLT\n+\n+\t/* Deallocate stack frame early; return value is now in redzone.  */\n+\taddq\t$200, %rsp\n+.LUW6:\n+\n+\t/* The first byte of the return value contains the FFI_TYPE.  */\n+\tmovzbl\t%al, %r10d\n+\tleaq\t.Lload_table(%rip), %r11\n+\tmovslq\t(%r11, %r10, 4), %r10\n+\taddq\t%r11, %r10\n+\tjmp\t*%r10\n+\n+\t.section .rodata\n+.Lload_table:\n+\t.long\t.Lld_void-.Lload_table\t\t/* FFI_TYPE_VOID */\n+\t.long\t.Lld_int32-.Lload_table\t\t/* FFI_TYPE_INT */\n+\t.long\t.Lld_float-.Lload_table\t\t/* FFI_TYPE_FLOAT */\n+\t.long\t.Lld_double-.Lload_table\t/* FFI_TYPE_DOUBLE */\n+\t.long\t.Lld_ldouble-.Lload_table\t/* FFI_TYPE_LONGDOUBLE */\n+\t.long\t.Lld_int8-.Lload_table\t\t/* FFI_TYPE_UINT8 */\n+\t.long\t.Lld_int8-.Lload_table\t\t/* FFI_TYPE_SINT8 */\n+\t.long\t.Lld_int16-.Lload_table\t\t/* FFI_TYPE_UINT16 */\n+\t.long\t.Lld_int16-.Lload_table\t\t/* FFI_TYPE_SINT16 */\n+\t.long\t.Lld_int32-.Lload_table\t\t/* FFI_TYPE_UINT32 */\n+\t.long\t.Lld_int32-.Lload_table\t\t/* FFI_TYPE_SINT32 */\n+\t.long\t.Lld_int64-.Lload_table\t\t/* FFI_TYPE_UINT64 */\n+\t.long\t.Lld_int64-.Lload_table\t\t/* FFI_TYPE_SINT64 */\n+\t.long\t.Lld_struct-.Lload_table\t/* FFI_TYPE_STRUCT */\n+\t.long\t.Lld_int64-.Lload_table\t\t/* FFI_TYPE_POINTER */\n+\n+\t.text\n+\t.align 2\n+.Lld_void:\n+\tret\n+\n+\t.align 2\n+.Lld_int8:\n+\tmovzbl\t-24(%rsp), %eax\n+\tret\n+\t.align 2\n+.Lld_int16:\n+\tmovzwl\t-24(%rsp), %eax\n+\tret\n+\t.align 2\n+.Lld_int32:\n+\tmovl\t-24(%rsp), %eax\n+\tret\n+\t.align 2\n+.Lld_int64:\n+\tmovq\t-24(%rsp), %rax\n \tret\n-.LFE2:\t\n-\t\t\n-        .section        .eh_frame,EH_FRAME_FLAGS,@progbits\n-.Lframe0:\n-        .long   .LECIE1-.LSCIE1\n+\n+\t.align 2\n+.Lld_float:\n+\tmovss\t-24(%rsp), %xmm0\n+\tret\n+\t.align 2\n+.Lld_double:\n+\tmovsd\t-24(%rsp), %xmm0\n+\tret\n+\t.align 2\n+.Lld_ldouble:\n+\tfldt\t-24(%rsp)\n+\tret\n+\n+\t.align 2\n+.Lld_struct:\n+\t/* There are four possibilities here, %rax/%rdx, %xmm0/%rax,\n+\t   %rax/%xmm0, %xmm0/%xmm1.  We collapse two by always loading\n+\t   both rdx and xmm1 with the second word.  For the remaining,\n+\t   bit 8 set means xmm0 gets the second word, and bit 9 means\n+\t   that rax gets the second word.  */\n+\tmovq\t-24(%rsp), %rcx\n+\tmovq\t-16(%rsp), %rdx\n+\tmovq\t-16(%rsp), %xmm1\n+\ttestl\t$0x100, %eax\n+\tcmovnz\t%rdx, %rcx\n+\tmovd\t%rcx, %xmm0\n+\ttestl\t$0x200, %eax\n+\tmovq\t-24(%rsp), %rax\n+\tcmovnz\t%rdx, %rax\n+\tret\n+.LUW7:\n+\t.size\tffi_closure_unix64,.-ffi_closure_unix64\n+\n+\t.section\t.eh_frame,\"a\",@progbits\n+.Lframe1:\n+\t.long\t.LECIE1-.LSCIE1\t\t/* CIE Length */\n .LSCIE1:\n-        .long   0x0\n-        .byte   0x1\n-        .string \"zR\"\n-        .uleb128 0x1\n-        .sleb128 -8\n-        .byte   0x10\n-        .uleb128 0x1\n-        .byte   0x1b\n-        .byte   0xc\n-        .uleb128 0x7\n-        .uleb128 0x8\n-        .byte   0x90\n-        .uleb128 0x1\n-        .align 8\n+\t.long\t0\t\t\t/* CIE Identifier Tag */\n+\t.byte\t1\t\t\t/* CIE Version */\n+\t.ascii \"zR\\0\"\t\t\t/* CIE Augmentation */\n+\t.uleb128 1\t\t\t/* CIE Code Alignment Factor */\n+\t.sleb128 -8\t\t\t/* CIE Data Alignment Factor */\n+\t.byte\t0x10\t\t\t/* CIE RA Column */\n+\t.uleb128 1\t\t\t/* Augmentation size */\n+\t.byte\t0x1b\t\t\t/* FDE Encoding (pcrel sdata4) */\n+\t.byte\t0xc\t\t\t/* DW_CFA_def_cfa, %rsp offset 8 */\n+\t.uleb128 7\n+\t.uleb128 8\n+\t.byte\t0x80+16\t\t\t/* DW_CFA_offset, %rip offset 1*-8 */\n+\t.uleb128 1\n+\t.align 8\n .LECIE1:\n .LSFDE1:\n-\t.long\t.LEFDE1-.LASFDE1\n+\t.long\t.LEFDE1-.LASFDE1\t/* FDE Length */\n .LASFDE1:\n-        .long   .LASFDE1-.Lframe0\n-\n-        .long   .LFB1-.\n-        .long   .LFE1-.LFB1\n-        .uleb128 0x0\n-        .byte   0x4\t\t# DW_CFA_advance_loc4\n-        .long   .LCFI0-.LFB1\n-        .byte   0xe\t\t# DW_CFA_def_cfa_offset\n-        .uleb128 0x10\n-        .byte   0x86\t\t# DW_CFA_offset: r6 at cfa-16\n-        .uleb128 0x2\n-        .byte   0x4\t\t# DW_CFA_advance_loc4\n-        .long   .LCFI1-.LCFI0\n-        .byte   0x86\t\t# DW_CFA_offset: r6 at cfa-16\n-        .uleb128 0x2\n-        .byte   0xd\t\t# DW_CFA_def_cfa_reg: r6\n-        .uleb128 0x6\n+\t.long\t.LASFDE1-.Lframe1\t/* FDE CIE offset */\n+\t.long\t.LUW0-.\t\t\t/* FDE initial location */\n+\t.long\t.LUW3-.LUW0\t\t/* FDE address range */\n+\t.uleb128 0x0\t\t\t/* Augmentation size */\n+\n+\t.byte\t0x4\t\t\t/* DW_CFA_advance_loc4 */\n+\t.long\t.LUW1-.LUW0\n+\n+        /* New stack frame based off rbp.  This is a itty bit of unwind\n+           trickery in that the CFA *has* changed.  There is no easy way\n+           to describe it correctly on entry to the function.  Fortunately,\n+           it doesn't matter too much since at all points we can correctly\n+           unwind back to ffi_call.  Note that the location to which we\n+           moved the return address is (the new) CFA-8, so from the\n+           perspective of the unwind info, it hasn't moved.  */\n+\t.byte\t0xc\t\t\t/* DW_CFA_def_cfa, %rbp offset 32 */\n+\t.uleb128 6\n+\t.uleb128 32\n+\t.byte\t0x80+6\t\t\t/* DW_CFA_offset, %rbp offset 2*-8 */\n+\t.uleb128 2\n+\n+\t.byte\t0x4\t\t\t/* DW_CFA_advance_loc4 */\n+\t.long\t.LUW2-.LUW3\n+\t.byte\t0xc\t\t\t/* DW_CFA_def_cfa, %rsp offset 8 */\n+\t.uleb128 7\n+\t.uleb128 8\n+\t.byte\t0xc0+6\t\t\t/* DW_CFA_restore, %rbp */\n \t.align 8\n .LEFDE1:\n .LSFDE3:\n-        .long   .LEFDE3-.LASFDE3        # FDE Length\n+\t.long\t.LEFDE3-.LASFDE3\t/* FDE Length */\n .LASFDE3:\n-        .long   .LASFDE3-.Lframe0       # FDE CIE offset\n-\n-        .long   .LFB2-. # FDE initial location\n-        .long   .LFE2-.LFB2     # FDE address range\n-        .uleb128 0x0    # Augmentation size\n-        .byte   0x4     # DW_CFA_advance_loc4\n-        .long   .LCFI10-.LFB2\n-        .byte   0xe     # DW_CFA_def_cfa_offset\n-        .uleb128 0x10\n-        .byte   0x86    # DW_CFA_offset, column 0x6\n-        .uleb128 0x2\n-        .byte   0x4     # DW_CFA_advance_loc4\n-        .long   .LCFI11-.LCFI10\n-        .byte   0xd     # DW_CFA_def_cfa_register\n-        .uleb128 0x6\n-        .align 8\n+\t.long\t.LASFDE3-.Lframe1\t/* FDE CIE offset */\n+\t.long\t.LUW4-.\t\t\t/* FDE initial location */\n+\t.long\t.LUW7-.LUW4\t\t/* FDE address range */\n+\t.uleb128 0x0\t\t\t/* Augmentation size */\n+\t.byte\t0x4\t\t\t/* DW_CFA_advance_loc4 */\n+\t.long\t.LUW5-.LUW4\n+\t.byte\t0xe\t\t\t/* DW_CFA_def_cfa_offset */\n+\t.uleb128 208\n+\t.byte\t0x4\t\t\t/* DW_CFA_advance_loc4 */\n+\t.long\t.LUW6-.LUW5\n+\t.byte\t0xe\t\t\t/* DW_CFA_def_cfa_offset */\n+\t.uleb128 8\n+\t.align 8\n .LEFDE3:\n \n-#endif /* __x86_64__  */\n+#endif /* __x86_64__ */"}]}