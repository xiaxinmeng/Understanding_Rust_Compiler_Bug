{"sha": "b8ddd61b7400465ee87613c11831e38962ec6ed2", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjhkZGQ2MWI3NDAwNDY1ZWU4NzYxM2MxMTgzMWUzODk2MmVjNmVkMg==", "commit": {"author": {"name": "Ian Lance Taylor", "email": "iant@google.com", "date": "2013-11-28T16:19:57Z"}, "committer": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2013-11-28T16:19:57Z"}, "message": "dwarf.c (find_address_ranges): New static function, broken out of build_address_map.\n\n\t* dwarf.c (find_address_ranges): New static function, broken out\n\tof build_address_map.\n\t(build_address_map): Call it.\n\t* btest.c (check): Check for missing filename or function, rather\n\tthan crashing.\n\t(f3): Check that enough frames were returned.\n\nFrom-SVN: r205490", "tree": {"sha": "2ae4d566474dc53783ba4c92cf34eaa4638d28e4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/2ae4d566474dc53783ba4c92cf34eaa4638d28e4"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b8ddd61b7400465ee87613c11831e38962ec6ed2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b8ddd61b7400465ee87613c11831e38962ec6ed2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b8ddd61b7400465ee87613c11831e38962ec6ed2", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b8ddd61b7400465ee87613c11831e38962ec6ed2/comments", "author": null, "committer": null, "parents": [{"sha": "f5c8b24c731e1b0343cbdcc3438ab4c40e82fc71", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f5c8b24c731e1b0343cbdcc3438ab4c40e82fc71", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f5c8b24c731e1b0343cbdcc3438ab4c40e82fc71"}], "stats": {"total": 364, "additions": 208, "deletions": 156}, "files": [{"sha": "3b86043fbfbb909a353b3cd4c8cc465a694c373d", "filename": "libbacktrace/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b8ddd61b7400465ee87613c11831e38962ec6ed2/libbacktrace%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b8ddd61b7400465ee87613c11831e38962ec6ed2/libbacktrace%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libbacktrace%2FChangeLog?ref=b8ddd61b7400465ee87613c11831e38962ec6ed2", "patch": "@@ -1,3 +1,12 @@\n+2013-11-27  Ian Lance Taylor  <iant@google.com>\n+\n+\t* dwarf.c (find_address_ranges): New static function, broken out\n+\tof build_address_map.\n+\t(build_address_map): Call it.\n+\t* btest.c (check): Check for missing filename or function, rather\n+\tthan crashing.\n+\t(f3): Check that enough frames were returned.\n+\n 2013-11-19  Jakub Jelinek  <jakub@redhat.com>\n \n \t* backtrace.h (backtrace_syminfo_callback): Add symsize argument."}, {"sha": "17fea3061f51a6a7173577fcd871ca5aa843f33d", "filename": "libbacktrace/btest.c", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b8ddd61b7400465ee87613c11831e38962ec6ed2/libbacktrace%2Fbtest.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b8ddd61b7400465ee87613c11831e38962ec6ed2/libbacktrace%2Fbtest.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libbacktrace%2Fbtest.c?ref=b8ddd61b7400465ee87613c11831e38962ec6ed2", "patch": "@@ -129,6 +129,13 @@ check (const char *name, int index, const struct info *all, int want_lineno,\n {\n   if (*failed)\n     return;\n+  if (all[index].filename == NULL || all[index].function == NULL)\n+    {\n+      fprintf (stderr, \"%s: [%d]: missing file name or function name\\n\",\n+\t       name, index);\n+      *failed = 1;\n+      return;\n+    }\n   if (strcmp (base (all[index].filename), \"btest.c\") != 0)\n     {\n       fprintf (stderr, \"%s: [%d]: got %s expected test.c\\n\", name, index,\n@@ -310,6 +317,14 @@ f3 (int f1line, int f2line)\n       data.failed = 1;\n     }\n \n+  if (data.index < 3)\n+    {\n+      fprintf (stderr,\n+\t       \"test1: not enough frames; got %zu, expected at least 3\\n\",\n+\t       data.index);\n+      data.failed = 1;\n+    }\n+\n   check (\"test1\", 0, all, f3line, \"f3\", &data.failed);\n   check (\"test1\", 1, all, f2line, \"f2\", &data.failed);\n   check (\"test1\", 2, all, f1line, \"test1\", &data.failed);"}, {"sha": "f9c3b3723e76674f0f3ab4977490932ed0c5f150", "filename": "libbacktrace/dwarf.c", "status": "modified", "additions": 184, "deletions": 156, "changes": 340, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b8ddd61b7400465ee87613c11831e38962ec6ed2/libbacktrace%2Fdwarf.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b8ddd61b7400465ee87613c11831e38962ec6ed2/libbacktrace%2Fdwarf.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libbacktrace%2Fdwarf.c?ref=b8ddd61b7400465ee87613c11831e38962ec6ed2", "patch": "@@ -1235,112 +1235,40 @@ add_unit_ranges (struct backtrace_state *state, uintptr_t base_address,\n   return 1;\n }\n \n-/* Build a mapping from address ranges to the compilation units where\n-   the line number information for that range can be found.  Returns 1\n-   on success, 0 on failure.  */\n+/* Find the address range covered by a compilation unit, reading from\n+   UNIT_BUF and adding values to U.  Returns 1 if all data could be\n+   read, 0 if there is some error.  */\n \n static int\n-build_address_map (struct backtrace_state *state, uintptr_t base_address,\n-\t\t   const unsigned char *dwarf_info, size_t dwarf_info_size,\n-\t\t   const unsigned char *dwarf_abbrev, size_t dwarf_abbrev_size,\n-\t\t   const unsigned char *dwarf_ranges, size_t dwarf_ranges_size,\n-\t\t   const unsigned char *dwarf_str, size_t dwarf_str_size,\n-\t\t   int is_bigendian, backtrace_error_callback error_callback,\n-\t\t   void *data, struct unit_addrs_vector *addrs)\n+find_address_ranges (struct backtrace_state *state, uintptr_t base_address,\n+\t\t     struct dwarf_buf *unit_buf, \n+\t\t     const unsigned char *dwarf_str, size_t dwarf_str_size,\n+\t\t     const unsigned char *dwarf_ranges,\n+\t\t     size_t dwarf_ranges_size,\n+\t\t     int is_bigendian, backtrace_error_callback error_callback,\n+\t\t     void *data, struct unit *u,\n+\t\t     struct unit_addrs_vector *addrs)\n {\n-  struct dwarf_buf info;\n-  struct abbrevs abbrevs;\n-\n-  memset (&addrs->vec, 0, sizeof addrs->vec);\n-  addrs->count = 0;\n-\n-  /* Read through the .debug_info section.  FIXME: Should we use the\n-     .debug_aranges section?  gdb and addr2line don't use it, but I'm\n-     not sure why.  */\n-\n-  info.name = \".debug_info\";\n-  info.start = dwarf_info;\n-  info.buf = dwarf_info;\n-  info.left = dwarf_info_size;\n-  info.is_bigendian = is_bigendian;\n-  info.error_callback = error_callback;\n-  info.data = data;\n-  info.reported_underflow = 0;\n-\n-  memset (&abbrevs, 0, sizeof abbrevs);\n-  while (info.left > 0)\n+  while (unit_buf->left > 0)\n     {\n-      const unsigned char *unit_data_start;\n-      uint64_t len;\n-      int is_dwarf64;\n-      struct dwarf_buf unit_buf;\n-      int version;\n-      uint64_t abbrev_offset;\n-      const struct abbrev *abbrev;\n-      int addrsize;\n-      const unsigned char *unit_data;\n-      size_t unit_data_len;\n-      size_t unit_data_offset;\n       uint64_t code;\n-      size_t i;\n+      const struct abbrev *abbrev;\n       uint64_t lowpc;\n       int have_lowpc;\n       uint64_t highpc;\n       int have_highpc;\n       int highpc_is_relative;\n       uint64_t ranges;\n       int have_ranges;\n-      uint64_t lineoff;\n-      int have_lineoff;\n-      const char *filename;\n-      const char *comp_dir;\n-\n-      if (info.reported_underflow)\n-\tgoto fail;\n-\n-      unit_data_start = info.buf;\n-\n-      is_dwarf64 = 0;\n-      len = read_uint32 (&info);\n-      if (len == 0xffffffff)\n-\t{\n-\t  len = read_uint64 (&info);\n-\t  is_dwarf64 = 1;\n-\t}\n-\n-      unit_buf = info;\n-      unit_buf.left = len;\n-\n-      if (!advance (&info, len))\n-\tgoto fail;\n-\n-      version = read_uint16 (&unit_buf);\n-      if (version < 2 || version > 4)\n-\t{\n-\t  dwarf_buf_error (&unit_buf, \"unrecognized DWARF version\");\n-\t  goto fail;\n-\t}\n-\n-      abbrev_offset = read_offset (&unit_buf, is_dwarf64);\n-      if (!read_abbrevs (state, abbrev_offset, dwarf_abbrev, dwarf_abbrev_size,\n-\t\t\t is_bigendian, error_callback, data, &abbrevs))\n-\tgoto fail;\n-\n-      addrsize = read_byte (&unit_buf);\n-\n-      unit_data = unit_buf.buf;\n-      unit_data_len = unit_buf.left;\n-      unit_data_offset = unit_buf.buf - unit_data_start;\n+      size_t i;\n \n-      /* We only look at the first attribute in the compilation unit.\n-\t In practice this will be a DW_TAG_compile_unit which will\n-\t tell us the PC range and where to find the line number\n-\t information.  */\n+      code = read_uleb128 (unit_buf);\n+      if (code == 0)\n+\treturn 1;\n \n-      code = read_uleb128 (&unit_buf);\n-      abbrev = lookup_abbrev (&abbrevs, code, error_callback, data);\n+      abbrev = lookup_abbrev (&u->abbrevs, code, error_callback, data);\n       if (abbrev == NULL)\n-\tgoto fail;\n+\treturn 0;\n \n       lowpc = 0;\n       have_lowpc = 0;\n@@ -1349,18 +1277,14 @@ build_address_map (struct backtrace_state *state, uintptr_t base_address,\n       highpc_is_relative = 0;\n       ranges = 0;\n       have_ranges = 0;\n-      lineoff = 0;\n-      have_lineoff = 0;\n-      filename = NULL;\n-      comp_dir = NULL;\n       for (i = 0; i < abbrev->num_attrs; ++i)\n \t{\n \t  struct attr_val val;\n \n-\t  if (!read_attribute (abbrev->attrs[i].form, &unit_buf, is_dwarf64,\n-\t\t\t       version, addrsize, dwarf_str, dwarf_str_size,\n-\t\t\t       &val))\n-\t    goto fail;\n+\t  if (!read_attribute (abbrev->attrs[i].form, unit_buf,\n+\t\t\t       u->is_dwarf64, u->version, u->addrsize,\n+\t\t\t       dwarf_str, dwarf_str_size, &val))\n+\t    return 0;\n \n \t  switch (abbrev->attrs[i].name)\n \t    {\n@@ -1371,6 +1295,7 @@ build_address_map (struct backtrace_state *state, uintptr_t base_address,\n \t\t  have_lowpc = 1;\n \t\t}\n \t      break;\n+\n \t    case DW_AT_high_pc:\n \t      if (val.encoding == ATTR_VAL_ADDRESS)\n \t\t{\n@@ -1384,6 +1309,7 @@ build_address_map (struct backtrace_state *state, uintptr_t base_address,\n \t\t  highpc_is_relative = 1;\n \t\t}\n \t      break;\n+\n \t    case DW_AT_ranges:\n \t      if (val.encoding == ATTR_VAL_UINT\n \t\t  || val.encoding == ATTR_VAL_REF_SECTION)\n@@ -1392,73 +1318,46 @@ build_address_map (struct backtrace_state *state, uintptr_t base_address,\n \t\t  have_ranges = 1;\n \t\t}\n \t      break;\n+\n \t    case DW_AT_stmt_list:\n-\t      if (val.encoding == ATTR_VAL_UINT\n-\t\t  || val.encoding == ATTR_VAL_REF_SECTION)\n-\t\t{\n-\t\t  lineoff = val.u.uint;\n-\t\t  have_lineoff = 1;\n-\t\t}\n+\t      if (abbrev->tag == DW_TAG_compile_unit\n+\t\t  && (val.encoding == ATTR_VAL_UINT\n+\t\t      || val.encoding == ATTR_VAL_REF_SECTION))\n+\t\tu->lineoff = val.u.uint;\n \t      break;\n+\n \t    case DW_AT_name:\n-\t      if (val.encoding == ATTR_VAL_STRING)\n-\t\tfilename = val.u.string;\n+\t      if (abbrev->tag == DW_TAG_compile_unit\n+\t\t  && val.encoding == ATTR_VAL_STRING)\n+\t\tu->filename = val.u.string;\n \t      break;\n+\n \t    case DW_AT_comp_dir:\n-\t      if (val.encoding == ATTR_VAL_STRING)\n-\t\tcomp_dir = val.u.string;\n+\t      if (abbrev->tag == DW_TAG_compile_unit\n+\t\t  && val.encoding == ATTR_VAL_STRING)\n+\t\tu->comp_dir = val.u.string;\n \t      break;\n+\n \t    default:\n \t      break;\n \t    }\n \t}\n \n-      if (unit_buf.reported_underflow)\n-\tgoto fail;\n-\n-      if (((have_lowpc && have_highpc) || have_ranges) && have_lineoff)\n+      if (abbrev->tag == DW_TAG_compile_unit\n+\t  || abbrev->tag == DW_TAG_subprogram)\n \t{\n-\t  struct unit *u;\n-\t  struct unit_addrs a;\n-\n-\t  u = ((struct unit *)\n-\t       backtrace_alloc (state, sizeof *u, error_callback, data));\n-\t  if (u == NULL)\n-\t    goto fail;\n-\t  u->unit_data = unit_data;\n-\t  u->unit_data_len = unit_data_len;\n-\t  u->unit_data_offset = unit_data_offset;\n-\t  u->version = version;\n-\t  u->is_dwarf64 = is_dwarf64;\n-\t  u->addrsize = addrsize;\n-\t  u->filename = filename;\n-\t  u->comp_dir = comp_dir;\n-\t  u->abs_filename = NULL;\n-\t  u->lineoff = lineoff;\n-\t  u->abbrevs = abbrevs;\n-\t  memset (&abbrevs, 0, sizeof abbrevs);\n-\n-\t  /* The actual line number mappings will be read as\n-\t     needed.  */\n-\t  u->lines = NULL;\n-\t  u->lines_count = 0;\n-\t  u->function_addrs = NULL;\n-\t  u->function_addrs_count = 0;\n-\n \t  if (have_ranges)\n \t    {\n \t      if (!add_unit_ranges (state, base_address, u, ranges, lowpc,\n \t\t\t\t    is_bigendian, dwarf_ranges,\n-\t\t\t\t    dwarf_ranges_size, error_callback, data,\n-\t\t\t\t    addrs))\n-\t\t{\n-\t\t  free_abbrevs (state, &u->abbrevs, error_callback, data);\n-\t\t  backtrace_free (state, u, sizeof *u, error_callback, data);\n-\t\t  goto fail;\n-\t\t}\n+\t\t\t\t    dwarf_ranges_size, error_callback,\n+\t\t\t\t    data, addrs))\n+\t\treturn 0;\n \t    }\n-\t  else\n+\t  else if (have_lowpc && have_highpc)\n \t    {\n+\t      struct unit_addrs a;\n+\n \t      if (highpc_is_relative)\n \t\thighpc += lowpc;\n \t      a.low = lowpc;\n@@ -1467,17 +1366,146 @@ build_address_map (struct backtrace_state *state, uintptr_t base_address,\n \n \t      if (!add_unit_addr (state, base_address, a, error_callback, data,\n \t\t\t\t  addrs))\n-\t\t{\n-\t\t  free_abbrevs (state, &u->abbrevs, error_callback, data);\n-\t\t  backtrace_free (state, u, sizeof *u, error_callback, data);\n-\t\t  goto fail;\n-\t\t}\n+\t\treturn 0;\n \t    }\n+\n+\t  /* If we found the PC range in the DW_TAG_compile_unit, we\n+\t     can stop now.  */\n+\t  if (abbrev->tag == DW_TAG_compile_unit\n+\t      && (have_ranges || (have_lowpc && have_highpc)))\n+\t    return 1;\n \t}\n-      else\n+\n+      if (abbrev->has_children)\n \t{\n-\t  free_abbrevs (state, &abbrevs, error_callback, data);\n-\t  memset (&abbrevs, 0, sizeof abbrevs);\n+\t  if (!find_address_ranges (state, base_address, unit_buf,\n+\t\t\t\t    dwarf_str, dwarf_str_size,\n+\t\t\t\t    dwarf_ranges, dwarf_ranges_size,\n+\t\t\t\t    is_bigendian, error_callback, data,\n+\t\t\t\t    u, addrs))\n+\t    return 0;\n+\t}\n+    }\n+\n+  return 1;\n+}\n+\n+/* Build a mapping from address ranges to the compilation units where\n+   the line number information for that range can be found.  Returns 1\n+   on success, 0 on failure.  */\n+\n+static int\n+build_address_map (struct backtrace_state *state, uintptr_t base_address,\n+\t\t   const unsigned char *dwarf_info, size_t dwarf_info_size,\n+\t\t   const unsigned char *dwarf_abbrev, size_t dwarf_abbrev_size,\n+\t\t   const unsigned char *dwarf_ranges, size_t dwarf_ranges_size,\n+\t\t   const unsigned char *dwarf_str, size_t dwarf_str_size,\n+\t\t   int is_bigendian, backtrace_error_callback error_callback,\n+\t\t   void *data, struct unit_addrs_vector *addrs)\n+{\n+  struct dwarf_buf info;\n+  struct abbrevs abbrevs;\n+\n+  memset (&addrs->vec, 0, sizeof addrs->vec);\n+  addrs->count = 0;\n+\n+  /* Read through the .debug_info section.  FIXME: Should we use the\n+     .debug_aranges section?  gdb and addr2line don't use it, but I'm\n+     not sure why.  */\n+\n+  info.name = \".debug_info\";\n+  info.start = dwarf_info;\n+  info.buf = dwarf_info;\n+  info.left = dwarf_info_size;\n+  info.is_bigendian = is_bigendian;\n+  info.error_callback = error_callback;\n+  info.data = data;\n+  info.reported_underflow = 0;\n+\n+  memset (&abbrevs, 0, sizeof abbrevs);\n+  while (info.left > 0)\n+    {\n+      const unsigned char *unit_data_start;\n+      uint64_t len;\n+      int is_dwarf64;\n+      struct dwarf_buf unit_buf;\n+      int version;\n+      uint64_t abbrev_offset;\n+      int addrsize;\n+      struct unit *u;\n+\n+      if (info.reported_underflow)\n+\tgoto fail;\n+\n+      unit_data_start = info.buf;\n+\n+      is_dwarf64 = 0;\n+      len = read_uint32 (&info);\n+      if (len == 0xffffffff)\n+\t{\n+\t  len = read_uint64 (&info);\n+\t  is_dwarf64 = 1;\n+\t}\n+\n+      unit_buf = info;\n+      unit_buf.left = len;\n+\n+      if (!advance (&info, len))\n+\tgoto fail;\n+\n+      version = read_uint16 (&unit_buf);\n+      if (version < 2 || version > 4)\n+\t{\n+\t  dwarf_buf_error (&unit_buf, \"unrecognized DWARF version\");\n+\t  goto fail;\n+\t}\n+\n+      abbrev_offset = read_offset (&unit_buf, is_dwarf64);\n+      if (!read_abbrevs (state, abbrev_offset, dwarf_abbrev, dwarf_abbrev_size,\n+\t\t\t is_bigendian, error_callback, data, &abbrevs))\n+\tgoto fail;\n+\n+      addrsize = read_byte (&unit_buf);\n+\n+      u = ((struct unit *)\n+\t   backtrace_alloc (state, sizeof *u, error_callback, data));\n+      if (u == NULL)\n+\tgoto fail;\n+      u->unit_data = unit_buf.buf;\n+      u->unit_data_len = unit_buf.left;\n+      u->unit_data_offset = unit_buf.buf - unit_data_start;\n+      u->version = version;\n+      u->is_dwarf64 = is_dwarf64;\n+      u->addrsize = addrsize;\n+      u->filename = NULL;\n+      u->comp_dir = NULL;\n+      u->abs_filename = NULL;\n+      u->lineoff = 0;\n+      u->abbrevs = abbrevs;\n+      memset (&abbrevs, 0, sizeof abbrevs);\n+\n+      /* The actual line number mappings will be read as needed.  */\n+      u->lines = NULL;\n+      u->lines_count = 0;\n+      u->function_addrs = NULL;\n+      u->function_addrs_count = 0;\n+\n+      if (!find_address_ranges (state, base_address, &unit_buf,\n+\t\t\t\tdwarf_str, dwarf_str_size,\n+\t\t\t\tdwarf_ranges, dwarf_ranges_size,\n+\t\t\t\tis_bigendian, error_callback, data,\n+\t\t\t\tu, addrs))\n+\t{\n+\t  free_abbrevs (state, &u->abbrevs, error_callback, data);\n+\t  backtrace_free (state, u, sizeof *u, error_callback, data);\n+\t  goto fail;\n+\t}\n+\n+      if (unit_buf.reported_underflow)\n+\t{\n+\t  free_abbrevs (state, &u->abbrevs, error_callback, data);\n+\t  backtrace_free (state, u, sizeof *u, error_callback, data);\n+\t  goto fail;\n \t}\n     }\n   if (info.reported_underflow)"}]}