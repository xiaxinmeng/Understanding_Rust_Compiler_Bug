{"sha": "e8427749a9c5ad6ec2c0653dcc4edea5b41efc31", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTg0Mjc3NDlhOWM1YWQ2ZWMyYzA2NTNkY2M0ZWRlYTViNDFlZmMzMQ==", "commit": {"author": {"name": "Javier Miranda", "email": "miranda@adacore.com", "date": "2018-07-17T08:06:09Z"}, "committer": {"name": "Pierre-Marie de Rodat", "email": "pmderodat@gcc.gnu.org", "date": "2018-07-17T08:06:09Z"}, "message": "[Ada] Secondary stack leak in loop iterator\n\nWhen the evaluation of the loop iterator invokes a function whose\nresult relies on the secondary stack the compiler does not generate\ncode to release the consumed memory as soon as the loop terminates.\n\nAfter this patch the following test works fine.\n\nwith Text_IO; use Text_IO;\npragma Warnings (Off);\nwith System.Secondary_Stack;\npragma Warnings (On);\nprocedure Sec_Stack_Leak is\n   function F (X : String) return Integer is\n   begin\n      return 10;\n   end F;\n\n   function G (X : Integer) return String is\n   begin\n      return (1 .. X => 'x');\n   end G;\n\n   procedure Info is new System.Secondary_Stack.Ss_Info (Put_Line);\n\n   procedure Nest is\n   begin\n      for I in Integer range 1 .. 100 loop\n         for J in Integer range 1 .. F (G (10_000)) loop\n            null;\n         end loop;\n         Info;\n      end loop;\n      Info;\n   end Nest;\n\nbegin\n   Info;\n   Nest;\n   Info;\nend Sec_Stack_Leak;\n\nCommands:\n  gnatmake -q sec_stack_leak.adb\n  sec_stack_leak | grep \"Current allocated space :\" | uniq\nOutput:\n  Current allocated space :  0 bytes\n\n2018-07-17  Javier Miranda  <miranda@adacore.com>\n\ngcc/ada/\n\n\t* sem_ch5.adb (Has_Call_Using_Secondary_Stack): Moved to library level\n\tto reuse it.\n\t(Analyze_Loop_Statement): Wrap the loop in a block when the evaluation\n\tof the loop iterator relies on the secondary stack.\n\nFrom-SVN: r262774", "tree": {"sha": "5d54cbc1fd07e8494974476978436cde9c5428c8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5d54cbc1fd07e8494974476978436cde9c5428c8"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e8427749a9c5ad6ec2c0653dcc4edea5b41efc31", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e8427749a9c5ad6ec2c0653dcc4edea5b41efc31", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e8427749a9c5ad6ec2c0653dcc4edea5b41efc31", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e8427749a9c5ad6ec2c0653dcc4edea5b41efc31/comments", "author": {"login": "miranda-adacore", "id": 54413934, "node_id": "MDQ6VXNlcjU0NDEzOTM0", "avatar_url": "https://avatars.githubusercontent.com/u/54413934?v=4", "gravatar_id": "", "url": "https://api.github.com/users/miranda-adacore", "html_url": "https://github.com/miranda-adacore", "followers_url": "https://api.github.com/users/miranda-adacore/followers", "following_url": "https://api.github.com/users/miranda-adacore/following{/other_user}", "gists_url": "https://api.github.com/users/miranda-adacore/gists{/gist_id}", "starred_url": "https://api.github.com/users/miranda-adacore/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/miranda-adacore/subscriptions", "organizations_url": "https://api.github.com/users/miranda-adacore/orgs", "repos_url": "https://api.github.com/users/miranda-adacore/repos", "events_url": "https://api.github.com/users/miranda-adacore/events{/privacy}", "received_events_url": "https://api.github.com/users/miranda-adacore/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "5ffc5c55091ba8a2d5290f7a0851c5d484e8ac85", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5ffc5c55091ba8a2d5290f7a0851c5d484e8ac85", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5ffc5c55091ba8a2d5290f7a0851c5d484e8ac85"}], "stats": {"total": 187, "additions": 122, "deletions": 65}, "files": [{"sha": "db369ccbadab798ee5ea641d6b6da48800fdf4af", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e8427749a9c5ad6ec2c0653dcc4edea5b41efc31/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e8427749a9c5ad6ec2c0653dcc4edea5b41efc31/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=e8427749a9c5ad6ec2c0653dcc4edea5b41efc31", "patch": "@@ -1,3 +1,10 @@\n+2018-07-17  Javier Miranda  <miranda@adacore.com>\n+\n+\t* sem_ch5.adb (Has_Call_Using_Secondary_Stack): Moved to library level\n+\tto reuse it.\n+\t(Analyze_Loop_Statement): Wrap the loop in a block when the evaluation\n+\tof the loop iterator relies on the secondary stack.\n+\n 2018-07-17  Piotr Trojanek  <trojanek@adacore.com>\n \n \t* sem_util.adb (Next_Actual): If the parent is a N_Null_Statement,"}, {"sha": "ad592fb42c25fb87fcc40776cbf9d2371fbd583c", "filename": "gcc/ada/sem_ch5.adb", "status": "modified", "additions": 115, "deletions": 65, "changes": 180, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e8427749a9c5ad6ec2c0653dcc4edea5b41efc31/gcc%2Fada%2Fsem_ch5.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e8427749a9c5ad6ec2c0653dcc4edea5b41efc31/gcc%2Fada%2Fsem_ch5.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch5.adb?ref=e8427749a9c5ad6ec2c0653dcc4edea5b41efc31", "patch": "@@ -83,6 +83,12 @@ package body Sem_Ch5 is\n    --  messages. This variable is recursively saved on entry to processing the\n    --  construct, and restored on exit.\n \n+   function Has_Call_Using_Secondary_Stack (N : Node_Id) return Boolean;\n+   --  N is the node for an arbitrary construct. This function searches the\n+   --  construct N to see if any expressions within it contain function\n+   --  calls that use the secondary stack, returning True if any such call\n+   --  is found, and False otherwise.\n+\n    procedure Preanalyze_Range (R_Copy : Node_Id);\n    --  Determine expected type of range or domain of iteration of Ada 2012\n    --  loop by analyzing separate copy. Do the analysis and resolution of the\n@@ -2692,12 +2698,6 @@ package body Sem_Ch5 is\n       --  forms. In this case it is not sufficent to check the static predicate\n       --  function only, look for a dynamic predicate aspect as well.\n \n-      function Has_Call_Using_Secondary_Stack (N : Node_Id) return Boolean;\n-      --  N is the node for an arbitrary construct. This function searches the\n-      --  construct N to see if any expressions within it contain function\n-      --  calls that use the secondary stack, returning True if any such call\n-      --  is found, and False otherwise.\n-\n       procedure Process_Bounds (R : Node_Id);\n       --  If the iteration is given by a range, create temporaries and\n       --  assignment statements block to capture the bounds and perform\n@@ -2782,65 +2782,6 @@ package body Sem_Ch5 is\n          end if;\n       end Check_Predicate_Use;\n \n-      ------------------------------------\n-      -- Has_Call_Using_Secondary_Stack --\n-      ------------------------------------\n-\n-      function Has_Call_Using_Secondary_Stack (N : Node_Id) return Boolean is\n-         function Check_Call (N : Node_Id) return Traverse_Result;\n-         --  Check if N is a function call which uses the secondary stack\n-\n-         ----------------\n-         -- Check_Call --\n-         ----------------\n-\n-         function Check_Call (N : Node_Id) return Traverse_Result is\n-            Nam  : Node_Id;\n-            Subp : Entity_Id;\n-            Typ  : Entity_Id;\n-\n-         begin\n-            if Nkind (N) = N_Function_Call then\n-               Nam := Name (N);\n-\n-               --  Obtain the subprogram being invoked\n-\n-               loop\n-                  if Nkind (Nam) = N_Explicit_Dereference then\n-                     Nam := Prefix (Nam);\n-\n-                  elsif Nkind (Nam) = N_Selected_Component then\n-                     Nam := Selector_Name (Nam);\n-\n-                  else\n-                     exit;\n-                  end if;\n-               end loop;\n-\n-               Subp := Entity (Nam);\n-               Typ  := Etype (Subp);\n-\n-               if Requires_Transient_Scope (Typ) then\n-                  return Abandon;\n-\n-               elsif Sec_Stack_Needed_For_Return (Subp) then\n-                  return Abandon;\n-               end if;\n-            end if;\n-\n-            --  Continue traversing the tree\n-\n-            return OK;\n-         end Check_Call;\n-\n-         function Check_Calls is new Traverse_Func (Check_Call);\n-\n-      --  Start of processing for Has_Call_Using_Secondary_Stack\n-\n-      begin\n-         return Check_Calls (N) = Abandon;\n-      end Has_Call_Using_Secondary_Stack;\n-\n       --------------------\n       -- Process_Bounds --\n       --------------------\n@@ -3644,6 +3585,56 @@ package body Sem_Ch5 is\n          end;\n       end if;\n \n+      --  Wrap the loop in a block when the evaluation of the loop iterator\n+      --  relies on the secondary stack. Required to ensure releasing the\n+      --  secondary stack as soon as the loop completes.\n+\n+      if Present (Iter)\n+        and then Present (Loop_Parameter_Specification (Iter))\n+        and then not Is_Wrapped_In_Block (N)\n+      then\n+         declare\n+            LPS       : constant Node_Id :=\n+                          Loop_Parameter_Specification (Iter);\n+            DSD       : constant Node_Id :=\n+                          Original_Node (Discrete_Subtype_Definition (LPS));\n+            Block_Nod : Node_Id;\n+            Block_Id  : Entity_Id;\n+            HB        : Node_Id;\n+            LB        : Node_Id;\n+\n+         begin\n+            if Nkind (DSD) = N_Subtype_Indication\n+              and then Nkind (Range_Expression (Constraint (DSD))) = N_Range\n+            then\n+               LB := New_Copy_Tree\n+                       (Low_Bound (Range_Expression (Constraint (DSD))));\n+               HB := New_Copy_Tree\n+                       (High_Bound (Range_Expression (Constraint (DSD))));\n+\n+               Preanalyze (LB);\n+               Preanalyze (HB);\n+\n+               if Has_Call_Using_Secondary_Stack (LB)\n+                    or else Has_Call_Using_Secondary_Stack (HB)\n+               then\n+                  Block_Nod :=\n+                    Make_Block_Statement (Loc,\n+                      Declarations => New_List,\n+                    Handled_Statement_Sequence =>\n+                      Make_Handled_Sequence_Of_Statements (Loc,\n+                        Statements => New_List (Relocate_Node (N))));\n+\n+                  Add_Block_Identifier (Block_Nod, Block_Id);\n+                  Set_Uses_Sec_Stack (Block_Id);\n+                  Rewrite (N, Block_Nod);\n+                  Analyze (N);\n+                  return;\n+               end if;\n+            end if;\n+         end;\n+      end if;\n+\n       --  Kill current values on entry to loop, since statements in the body of\n       --  the loop may have been executed before the loop is entered. Similarly\n       --  we kill values after the loop, since we do not know that the body of\n@@ -4072,6 +4063,65 @@ package body Sem_Ch5 is\n       end if;\n    end Check_Unreachable_Code;\n \n+   ------------------------------------\n+   -- Has_Call_Using_Secondary_Stack --\n+   ------------------------------------\n+\n+   function Has_Call_Using_Secondary_Stack (N : Node_Id) return Boolean is\n+      function Check_Call (N : Node_Id) return Traverse_Result;\n+      --  Check if N is a function call which uses the secondary stack\n+\n+      ----------------\n+      -- Check_Call --\n+      ----------------\n+\n+      function Check_Call (N : Node_Id) return Traverse_Result is\n+         Nam  : Node_Id;\n+         Subp : Entity_Id;\n+         Typ  : Entity_Id;\n+\n+      begin\n+         if Nkind (N) = N_Function_Call then\n+            Nam := Name (N);\n+\n+            --  Obtain the subprogram being invoked\n+\n+            loop\n+               if Nkind (Nam) = N_Explicit_Dereference then\n+                  Nam := Prefix (Nam);\n+\n+               elsif Nkind (Nam) = N_Selected_Component then\n+                  Nam := Selector_Name (Nam);\n+\n+               else\n+                  exit;\n+               end if;\n+            end loop;\n+\n+            Subp := Entity (Nam);\n+            Typ  := Etype (Subp);\n+\n+            if Requires_Transient_Scope (Typ) then\n+               return Abandon;\n+\n+            elsif Sec_Stack_Needed_For_Return (Subp) then\n+               return Abandon;\n+            end if;\n+         end if;\n+\n+         --  Continue traversing the tree\n+\n+         return OK;\n+      end Check_Call;\n+\n+      function Check_Calls is new Traverse_Func (Check_Call);\n+\n+   --  Start of processing for Has_Call_Using_Secondary_Stack\n+\n+   begin\n+      return Check_Calls (N) = Abandon;\n+   end Has_Call_Using_Secondary_Stack;\n+\n    ----------------------\n    -- Preanalyze_Range --\n    ----------------------"}]}