{"sha": "1ac9258cca8030745d3c0b8f63186f0adf0ebc27", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MWFjOTI1OGNjYTgwMzA3NDVkM2MwYjhmNjMxODZmMGFkZjBlYmMyNw==", "commit": {"author": {"name": "Martin Liska", "email": "mliska@suse.cz", "date": "2020-06-30T06:57:27Z"}, "committer": {"name": "Martin Liska", "email": "mliska@suse.cz", "date": "2020-07-02T10:41:42Z"}, "message": "VEC_COND_EXPR: do not expand comparisons feeding it\n\ngcc/ChangeLog:\n\n\tPR middle-end/95830\n\t* tree-vect-generic.c (expand_vector_condition): Forward declaration.\n\t(expand_vector_comparison): Do not expand a comparison if all\n\tuses are consumed by a VEC_COND_EXPR.\n\t(expand_vector_operation): Change void return type to bool.\n\t(expand_vector_operations_1): Pass dce_ssa_names.", "tree": {"sha": "4c3f0e518f942282d5f3c3a1ae77c2c50544a251", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/4c3f0e518f942282d5f3c3a1ae77c2c50544a251"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/1ac9258cca8030745d3c0b8f63186f0adf0ebc27", "comment_count": 0, "verification": {"verified": false, "reason": "unknown_key", "signature": "-----BEGIN PGP SIGNATURE-----\n\niQEzBAABCAAdFiEE6I4wzqqylQBfXaRhTcGC3A+nN4UFAl79ueYACgkQTcGC3A+n\nN4WcfAgAm36KzMGvJH19QOn2k1FJZuu5eCG7rtaw1DzbLtCtRTZGajloAaui/Yk+\nx7F5x4DQDAKiWSTCxl55x0e/5+DZpO8AKUsDKjBRfUBSw7nglicx8KAs6tk2roPi\n8z4qhtglRQkJmCqZHMfb070c2hOnId+lFBGYouWrDbiGxtY9wp3jo3jrXQQSif7E\nXzeh13G2uiOZbKcMRvmQXBL0h4wMTlE3FxJeGhnzZZAcT927/gEWWBCwAvTVd/10\nQd4jL2V0ZQjVHvrukTIAVAwda+gg93ZCFlFMowWNhw0zZ2l0rruatrVXPihOPt/J\n1l3IWobgOrpkq7bIUIWMGngce6C1yQ==\n=aUZj\n-----END PGP SIGNATURE-----", "payload": "tree 4c3f0e518f942282d5f3c3a1ae77c2c50544a251\nparent d59a576b8b5e12c3a56f0262912090e2921f5daa\nauthor Martin Liska <mliska@suse.cz> 1593500247 +0200\ncommitter Martin Liska <mliska@suse.cz> 1593686502 +0200\n\nVEC_COND_EXPR: do not expand comparisons feeding it\n\ngcc/ChangeLog:\n\n\tPR middle-end/95830\n\t* tree-vect-generic.c (expand_vector_condition): Forward declaration.\n\t(expand_vector_comparison): Do not expand a comparison if all\n\tuses are consumed by a VEC_COND_EXPR.\n\t(expand_vector_operation): Change void return type to bool.\n\t(expand_vector_operations_1): Pass dce_ssa_names.\n"}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1ac9258cca8030745d3c0b8f63186f0adf0ebc27", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1ac9258cca8030745d3c0b8f63186f0adf0ebc27", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1ac9258cca8030745d3c0b8f63186f0adf0ebc27/comments", "author": {"login": "marxin", "id": 2658545, "node_id": "MDQ6VXNlcjI2NTg1NDU=", "avatar_url": "https://avatars.githubusercontent.com/u/2658545?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marxin", "html_url": "https://github.com/marxin", "followers_url": "https://api.github.com/users/marxin/followers", "following_url": "https://api.github.com/users/marxin/following{/other_user}", "gists_url": "https://api.github.com/users/marxin/gists{/gist_id}", "starred_url": "https://api.github.com/users/marxin/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marxin/subscriptions", "organizations_url": "https://api.github.com/users/marxin/orgs", "repos_url": "https://api.github.com/users/marxin/repos", "events_url": "https://api.github.com/users/marxin/events{/privacy}", "received_events_url": "https://api.github.com/users/marxin/received_events", "type": "User", "site_admin": false}, "committer": {"login": "marxin", "id": 2658545, "node_id": "MDQ6VXNlcjI2NTg1NDU=", "avatar_url": "https://avatars.githubusercontent.com/u/2658545?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marxin", "html_url": "https://github.com/marxin", "followers_url": "https://api.github.com/users/marxin/followers", "following_url": "https://api.github.com/users/marxin/following{/other_user}", "gists_url": "https://api.github.com/users/marxin/gists{/gist_id}", "starred_url": "https://api.github.com/users/marxin/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marxin/subscriptions", "organizations_url": "https://api.github.com/users/marxin/orgs", "repos_url": "https://api.github.com/users/marxin/repos", "events_url": "https://api.github.com/users/marxin/events{/privacy}", "received_events_url": "https://api.github.com/users/marxin/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d59a576b8b5e12c3a56f0262912090e2921f5daa", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d59a576b8b5e12c3a56f0262912090e2921f5daa", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d59a576b8b5e12c3a56f0262912090e2921f5daa"}], "stats": {"total": 69, "additions": 57, "deletions": 12}, "files": [{"sha": "f8bd26f215635ebc7dd99f3223b932aae058991e", "filename": "gcc/tree-vect-generic.c", "status": "modified", "additions": 57, "deletions": 12, "changes": 69, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1ac9258cca8030745d3c0b8f63186f0adf0ebc27/gcc%2Ftree-vect-generic.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1ac9258cca8030745d3c0b8f63186f0adf0ebc27/gcc%2Ftree-vect-generic.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-generic.c?ref=1ac9258cca8030745d3c0b8f63186f0adf0ebc27", "patch": "@@ -44,7 +44,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"recog.h\"\t\t/* FIXME: for insn_data */\n \n \n-static void expand_vector_operations_1 (gimple_stmt_iterator *, auto_bitmap *);\n+static void expand_vector_operations_1 (gimple_stmt_iterator *, bitmap);\n \n /* Return the number of elements in a vector type TYPE that we have\n    already decided needs to be expanded piecewise.  We don't support\n@@ -371,14 +371,53 @@ expand_vector_addition (gimple_stmt_iterator *gsi,\n \t\t\t\t    a, b, code);\n }\n \n+static bool\n+expand_vector_condition (gimple_stmt_iterator *gsi, bitmap dce_ssa_names);\n+\n /* Try to expand vector comparison expression OP0 CODE OP1 by\n    querying optab if the following expression:\n \tVEC_COND_EXPR< OP0 CODE OP1, {-1,...}, {0,...}>\n    can be expanded.  */\n static tree\n expand_vector_comparison (gimple_stmt_iterator *gsi, tree type, tree op0,\n-                          tree op1, enum tree_code code)\n+\t\t\t  tree op1, enum tree_code code,\n+\t\t\t  bitmap dce_ssa_names)\n {\n+  tree lhs = gimple_assign_lhs (gsi_stmt (*gsi));\n+  use_operand_p use_p;\n+  imm_use_iterator iterator;\n+  bool vec_cond_expr_only = true;\n+\n+  /* As seen in PR95830, we should not expand comparisons that are only\n+     feeding a VEC_COND_EXPR statement.  */\n+  auto_vec<gimple *> uses;\n+  FOR_EACH_IMM_USE_FAST (use_p, iterator, lhs)\n+    uses.safe_push (USE_STMT (use_p));\n+\n+  for (unsigned i = 0; i < uses.length (); i ++)\n+    {\n+      gassign *use = dyn_cast<gassign *> (uses[i]);\n+      if (use != NULL\n+\t  && gimple_assign_rhs_code (use) == VEC_COND_EXPR\n+\t  && gimple_assign_rhs1 (use) == lhs)\n+\t{\n+\t  gimple_stmt_iterator it = gsi_for_stmt (use);\n+\t  if (!expand_vector_condition (&it, dce_ssa_names))\n+\t    {\n+\t      vec_cond_expr_only = false;\n+\t      break;\n+\t    }\n+\t}\n+      else\n+\t{\n+\t  vec_cond_expr_only = false;\n+\t  break;\n+\t}\n+    }\n+\n+  if (!uses.is_empty () && vec_cond_expr_only)\n+    return NULL_TREE;\n+\n   tree t;\n   if (!expand_vec_cmp_expr_p (TREE_TYPE (op0), type, code)\n       && !expand_vec_cond_expr_p (type, TREE_TYPE (op0), code))\n@@ -932,8 +971,9 @@ expand_vector_divmod (gimple_stmt_iterator *gsi, tree type, tree op0,\n \n /* Expand a vector condition to scalars, by using many conditions\n    on the vector's elements.  */\n-static void\n-expand_vector_condition (gimple_stmt_iterator *gsi, auto_bitmap *dce_ssa_names)\n+\n+static bool\n+expand_vector_condition (gimple_stmt_iterator *gsi, bitmap dce_ssa_names)\n {\n   gassign *stmt = as_a <gassign *> (gsi_stmt (*gsi));\n   tree type = gimple_expr_type (stmt);\n@@ -975,7 +1015,7 @@ expand_vector_condition (gimple_stmt_iterator *gsi, auto_bitmap *dce_ssa_names)\n   if (expand_vec_cond_expr_p (type, TREE_TYPE (a1), code))\n     {\n       gcc_assert (TREE_CODE (a) == SSA_NAME || TREE_CODE (a) == VECTOR_CST);\n-      return;\n+      return true;\n     }\n \n   /* Handle vector boolean types with bitmasks.  If there is a comparison\n@@ -1006,7 +1046,7 @@ expand_vector_condition (gimple_stmt_iterator *gsi, auto_bitmap *dce_ssa_names)\n       a = gimplify_build2 (gsi, BIT_IOR_EXPR, type, a1, a2);\n       gimple_assign_set_rhs_from_tree (gsi, a);\n       update_stmt (gsi_stmt (*gsi));\n-      return;\n+      return true;\n     }\n \n   /* TODO: try and find a smaller vector type.  */\n@@ -1068,13 +1108,16 @@ expand_vector_condition (gimple_stmt_iterator *gsi, auto_bitmap *dce_ssa_names)\n   update_stmt (gsi_stmt (*gsi));\n \n   if (a_is_comparison)\n-    bitmap_set_bit (*dce_ssa_names,\n+    bitmap_set_bit (dce_ssa_names,\n \t\t    SSA_NAME_VERSION (gimple_assign_lhs (assign)));\n+\n+  return false;\n }\n \n static tree\n expand_vector_operation (gimple_stmt_iterator *gsi, tree type, tree compute_type,\n-\t\t\t gassign *assign, enum tree_code code)\n+\t\t\t gassign *assign, enum tree_code code,\n+\t\t\t bitmap dce_ssa_names)\n {\n   machine_mode compute_mode = TYPE_MODE (compute_type);\n \n@@ -1128,7 +1171,8 @@ expand_vector_operation (gimple_stmt_iterator *gsi, tree type, tree compute_type\n \t  tree rhs1 = gimple_assign_rhs1 (assign);\n \t  tree rhs2 = gimple_assign_rhs2 (assign);\n \n-\t  return expand_vector_comparison (gsi, type, rhs1, rhs2, code);\n+\t  return expand_vector_comparison (gsi, type, rhs1, rhs2, code,\n+\t\t\t\t\t   dce_ssa_names);\n \t}\n \n       case TRUNC_DIV_EXPR:\n@@ -1963,7 +2007,7 @@ expand_vector_conversion (gimple_stmt_iterator *gsi)\n \n static void\n expand_vector_operations_1 (gimple_stmt_iterator *gsi,\n-\t\t\t    auto_bitmap *dce_ssa_names)\n+\t\t\t    bitmap dce_ssa_names)\n {\n   tree lhs, rhs1, rhs2 = NULL, type, compute_type = NULL_TREE;\n   enum tree_code code;\n@@ -2213,7 +2257,8 @@ expand_vector_operations_1 (gimple_stmt_iterator *gsi,\n   if (compute_type == type)\n     return;\n \n-  new_rhs = expand_vector_operation (gsi, type, compute_type, stmt, code);\n+  new_rhs = expand_vector_operation (gsi, type, compute_type, stmt, code,\n+\t\t\t\t     dce_ssa_names);\n \n   /* Leave expression untouched for later expansion.  */\n   if (new_rhs == NULL_TREE)\n@@ -2246,7 +2291,7 @@ expand_vector_operations (void)\n     {\n       for (gsi = gsi_start_bb (bb); !gsi_end_p (gsi); gsi_next (&gsi))\n \t{\n-\t  expand_vector_operations_1 (&gsi, &dce_ssa_names);\n+\t  expand_vector_operations_1 (&gsi, dce_ssa_names);\n \t  /* ???  If we do not cleanup EH then we will ICE in\n \t     verification.  But in reality we have created wrong-code\n \t     as we did not properly transition EH info and edges to"}]}