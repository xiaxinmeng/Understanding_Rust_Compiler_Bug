{"sha": "c41fea4af48ddaeeef4c043d874c8c333d669849", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YzQxZmVhNGFmNDhkZGFlZWVmNGMwNDNkODc0YzhjMzMzZDY2OTg0OQ==", "commit": {"author": {"name": "Paul Thomas", "email": "pault@gcc.gnu.org", "date": "2009-01-17T11:32:02Z"}, "committer": {"name": "Paul Thomas", "email": "pault@gcc.gnu.org", "date": "2009-01-17T11:32:02Z"}, "message": "re PR fortran/34955 (transfer_assumed_size_1.f90: Valgrind error: invalid read of size 3)\n\n2009-01-17  Paul Thomas  <pault@gcc.gnu.org>\n\n\tPR fortran/34955\n\t* trans-intrinsic.c (gfc_conv_intrinsic_array_transfer): Has\n\tbeen absorbed into gfc_conv_intrinsic_transfer. All\n\treferences to it in trans-intrinsic.c have been changed\n\taccordingly.  PR fixed by using a temporary for scalar\n\tcharacter transfer, when the source is shorter than the\n\tdestination.\n\n2009-01-17  Paul Thomas  <pault@gcc.gnu.org>\n\n\tPR fortran/34955\n\t* gfortran.dg/transfer_intrinsic_1.f90: New test.\n\t* gfortran.dg/transfer_intrinsic_2.f90: New test.\n\nFrom-SVN: r143462", "tree": {"sha": "b49b7eeb639e35d827b9259d118ebb112c60d632", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b49b7eeb639e35d827b9259d118ebb112c60d632"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c41fea4af48ddaeeef4c043d874c8c333d669849", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c41fea4af48ddaeeef4c043d874c8c333d669849", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c41fea4af48ddaeeef4c043d874c8c333d669849", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c41fea4af48ddaeeef4c043d874c8c333d669849/comments", "author": null, "committer": null, "parents": [{"sha": "6e7ff326cfc495b24cb815cc2b539c6bc139c8ea", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6e7ff326cfc495b24cb815cc2b539c6bc139c8ea", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6e7ff326cfc495b24cb815cc2b539c6bc139c8ea"}], "stats": {"total": 241, "additions": 154, "deletions": 87}, "files": [{"sha": "c8c46dac2b3c7708a40ac324fe8db905af8f0e86", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c41fea4af48ddaeeef4c043d874c8c333d669849/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c41fea4af48ddaeeef4c043d874c8c333d669849/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=c41fea4af48ddaeeef4c043d874c8c333d669849", "patch": "@@ -1,3 +1,13 @@\n+2009-01-17  Paul Thomas  <pault@gcc.gnu.org>\n+\n+\tPR fortran/34955\n+\t* trans-intrinsic.c (gfc_conv_intrinsic_array_transfer): Has\n+\tbeen absorbed into gfc_conv_intrinsic_transfer. All\n+\treferences to it in trans-intrinsic.c have been changed\n+\taccordingly.  PR fixed by using a temporary for scalar\n+\tcharacter transfer, when the source is shorter than the\n+\tdestination.\n+\n 2009-01-17  Paul Thomas  <pault@gcc.gnu.org>\n \n \tPR fortran/38657"}, {"sha": "e3941c554140f3c3308b74c7f6b681127de09f7c", "filename": "gcc/fortran/trans-intrinsic.c", "status": "modified", "additions": 92, "deletions": 84, "changes": 176, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c41fea4af48ddaeeef4c043d874c8c333d669849/gcc%2Ffortran%2Ftrans-intrinsic.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c41fea4af48ddaeeef4c043d874c8c333d669849/gcc%2Ffortran%2Ftrans-intrinsic.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-intrinsic.c?ref=c41fea4af48ddaeeef4c043d874c8c333d669849", "patch": "@@ -3615,18 +3615,27 @@ gfc_conv_intrinsic_adjust (gfc_se * se, gfc_expr * expr, tree fndecl)\n }\n \n \n-/* Array transfer statement.\n-     DEST(1:N) = TRANSFER (SOURCE, MOLD[, SIZE])\n-   where:\n-     typeof<DEST> = typeof<MOLD>\n-   and:\n-     N = min (sizeof (SOURCE(:)), sizeof (DEST(:)),\n+/* Generate code for the TRANSFER intrinsic:\n+\tFor scalar results:\n+\t  DEST = TRANSFER (SOURCE, MOLD)\n+\twhere:\n+\t  typeof<DEST> = typeof<MOLD>\n+\tand:\n+\t  MOLD is scalar.\n+\n+\tFor array results:\n+\t  DEST(1:N) = TRANSFER (SOURCE, MOLD[, SIZE])\n+\twhere:\n+\t  typeof<DEST> = typeof<MOLD>\n+\tand:\n+\t  N = min (sizeof (SOURCE(:)), sizeof (DEST(:)),\n \t      sizeof (DEST(0) * SIZE).  */\n-\n static void\n-gfc_conv_intrinsic_array_transfer (gfc_se * se, gfc_expr * expr)\n+gfc_conv_intrinsic_transfer (gfc_se * se, gfc_expr * expr)\n {\n   tree tmp;\n+  tree tmpdecl;\n+  tree ptr;\n   tree extent;\n   tree source;\n   tree source_type;\n@@ -3645,14 +3654,27 @@ gfc_conv_intrinsic_array_transfer (gfc_se * se, gfc_expr * expr)\n   gfc_ss_info *info;\n   stmtblock_t block;\n   int n;\n+  bool scalar_mold;\n \n-  gcc_assert (se->loop);\n-  info = &se->ss->data.info;\n+  info = NULL;\n+  if (se->loop)\n+    info = &se->ss->data.info;\n \n   /* Convert SOURCE.  The output from this stage is:-\n \tsource_bytes = length of the source in bytes\n \tsource = pointer to the source data.  */\n   arg = expr->value.function.actual;\n+\n+  /* Ensure double transfer through LOGICAL preserves all\n+     the needed bits.  */\n+  if (arg->expr->expr_type == EXPR_FUNCTION\n+\t&& arg->expr->value.function.esym == NULL\n+\t&& arg->expr->value.function.isym != NULL\n+\t&& arg->expr->value.function.isym->id == GFC_ISYM_TRANSFER\n+\t&& arg->expr->ts.type == BT_LOGICAL\n+\t&& expr->ts.type != arg->expr->ts.type)\n+    arg->expr->value.function.name = \"__transfer_in_transfer\";\n+\n   gfc_init_se (&argse, NULL);\n   ss = gfc_walk_expr (arg->expr);\n \n@@ -3682,8 +3704,8 @@ gfc_conv_intrinsic_array_transfer (gfc_se * se, gfc_expr * expr)\n       source_type = gfc_get_element_type (TREE_TYPE (argse.expr));\n \n       /* Repack the source if not a full variable array.  */\n-      if (!(arg->expr->expr_type == EXPR_VARIABLE\n-\t      && arg->expr->ref->u.ar.type == AR_FULL))\n+      if (arg->expr->expr_type == EXPR_VARIABLE\n+\t      && arg->expr->ref->u.ar.type != AR_FULL)\n \t{\n \t  tmp = build_fold_addr_expr (argse.expr);\n \n@@ -3750,6 +3772,8 @@ gfc_conv_intrinsic_array_transfer (gfc_se * se, gfc_expr * expr)\n   gfc_init_se (&argse, NULL);\n   ss = gfc_walk_expr (arg->expr);\n \n+  scalar_mold = arg->expr->rank == 0;\n+\n   if (ss == gfc_ss_terminator)\n     {\n       gfc_conv_expr_reference (&argse, arg->expr);\n@@ -3763,6 +3787,9 @@ gfc_conv_intrinsic_array_transfer (gfc_se * se, gfc_expr * expr)\n       mold_type = gfc_get_element_type (TREE_TYPE (argse.expr));\n     }\n \n+  gfc_add_block_to_block (&se->pre, &argse.pre);\n+  gfc_add_block_to_block (&se->post, &argse.post);\n+\n   if (strcmp (expr->value.function.name, \"__transfer_in_transfer\") == 0)\n     {\n       /* If this TRANSFER is nested in another TRANSFER, use a type\n@@ -3799,14 +3826,14 @@ gfc_conv_intrinsic_array_transfer (gfc_se * se, gfc_expr * expr)\n   else\n     tmp = NULL_TREE;\n \n+  /* Separate array and scalar results.  */\n+  if (scalar_mold && tmp == NULL_TREE)\n+    goto scalar_transfer;\n+\n   size_bytes = gfc_create_var (gfc_array_index_type, NULL);\n   if (tmp != NULL_TREE)\n-    {\n-      tmp = fold_build2 (MULT_EXPR, gfc_array_index_type,\n-\t\t\t tmp, dest_word_len);\n-      tmp = fold_build2 (MIN_EXPR, gfc_array_index_type,\n-\t\t\t tmp, source_bytes);\n-    }\n+    tmp = fold_build2 (MULT_EXPR, gfc_array_index_type,\n+\t\t       tmp, dest_word_len);\n   else\n     tmp = source_bytes;\n \n@@ -3847,9 +3874,7 @@ gfc_conv_intrinsic_array_transfer (gfc_se * se, gfc_expr * expr)\n   se->loop->to[n] = upper;\n \n   /* Build a destination descriptor, using the pointer, source, as the\n-     data field.  This is already allocated so set callee_alloc.\n-     FIXME callee_alloc is not set!  */\n-\n+     data field.  */\n   gfc_trans_create_temp_array (&se->pre, &se->post, se->loop,\n \t\t\t       info, mold_type, NULL_TREE, false, true, false,\n \t\t\t       &expr->where);\n@@ -3863,72 +3888,71 @@ gfc_conv_intrinsic_array_transfer (gfc_se * se, gfc_expr * expr)\n \t\t\t 3,\n \t\t\t tmp,\n \t\t\t fold_convert (pvoid_type_node, source),\n-\t\t\t size_bytes);\n+\t\t\t fold_build2 (MIN_EXPR, gfc_array_index_type,\n+\t\t\t\t      size_bytes, source_bytes));\n   gfc_add_expr_to_block (&se->pre, tmp);\n \n   se->expr = info->descriptor;\n   if (expr->ts.type == BT_CHARACTER)\n     se->string_length = dest_word_len;\n-}\n \n+  return;\n \n-/* Scalar transfer statement.\n-   TRANSFER (source, mold) = memcpy(&tmpdecl, &source, size), tmpdecl.  */\n+/* Deal with scalar results.  */\n+scalar_transfer:\n+  extent = fold_build2 (MIN_EXPR, gfc_array_index_type,\n+\t\t\tdest_word_len, source_bytes);\n \n-static void\n-gfc_conv_intrinsic_transfer (gfc_se * se, gfc_expr * expr)\n-{\n-  gfc_actual_arglist *arg;\n-  gfc_se argse;\n-  tree type;\n-  tree ptr;\n-  gfc_ss *ss;\n-  tree tmpdecl, tmp;\n+  if (expr->ts.type == BT_CHARACTER)\n+    {\n+      tree direct;\n+      tree indirect;\n \n-  /* Get a pointer to the source.  */\n-  arg = expr->value.function.actual;\n-  ss = gfc_walk_expr (arg->expr);\n-  gfc_init_se (&argse, NULL);\n-  if (ss == gfc_ss_terminator)\n-    gfc_conv_expr_reference (&argse, arg->expr);\n-  else\n-    gfc_conv_array_parameter (&argse, arg->expr, ss, 1, NULL, NULL);\n-  gfc_add_block_to_block (&se->pre, &argse.pre);\n-  gfc_add_block_to_block (&se->post, &argse.post);\n-  ptr = argse.expr;\n+      ptr = convert (gfc_get_pchar_type (expr->ts.kind), source);\n+      tmpdecl = gfc_create_var (gfc_get_pchar_type (expr->ts.kind),\n+\t\t\t\t\"transfer\");\n \n-  arg = arg->next;\n-  type = gfc_typenode_for_spec (&expr->ts);\n-  if (strcmp (expr->value.function.name, \"__transfer_in_transfer\") == 0)\n-    {\n-      /* If this TRANSFER is nested in another TRANSFER, use a type\n-\t that preserves all bits.  */\n-      if (expr->ts.type == BT_LOGICAL)\n-\ttype = gfc_get_int_type (expr->ts.kind);\n-    }\n+      /* If source is longer than the destination, use a pointer to\n+\t the source directly.  */\n+      gfc_init_block (&block);\n+      gfc_add_modify (&block, tmpdecl, ptr);\n+      direct = gfc_finish_block (&block);\n \n-  if (expr->ts.type == BT_CHARACTER)\n-    {\n-      ptr = convert (build_pointer_type (type), ptr);\n-      gfc_init_se (&argse, NULL);\n-      gfc_conv_expr (&argse, arg->expr);\n-      gfc_add_block_to_block (&se->pre, &argse.pre);\n-      gfc_add_block_to_block (&se->post, &argse.post);\n-      se->expr = ptr;\n-      se->string_length = argse.string_length;\n+      /* Otherwise, allocate a string with the length of the destination\n+\t and copy the source into it.  */\n+      gfc_init_block (&block);\n+      tmp = gfc_get_pchar_type (expr->ts.kind);\n+      tmp = gfc_call_malloc (&block, tmp, dest_word_len);\n+      gfc_add_modify (&block, tmpdecl,\n+\t\t      fold_convert (TREE_TYPE (ptr), tmp));\n+      tmp = build_call_expr (built_in_decls[BUILT_IN_MEMCPY], 3,\n+\t\t\t     fold_convert (pvoid_type_node, tmpdecl),\n+\t\t\t     fold_convert (pvoid_type_node, ptr),\n+\t\t\t     extent);\n+      gfc_add_expr_to_block (&block, tmp);\n+      indirect = gfc_finish_block (&block);\n+\n+      /* Wrap it up with the condition.  */\n+      tmp = fold_build2 (LE_EXPR, boolean_type_node,\n+\t\t\t dest_word_len, source_bytes);\n+      tmp = build3_v (COND_EXPR, tmp, direct, indirect);\n+      gfc_add_expr_to_block (&se->pre, tmp);\n+\n+      se->expr = tmpdecl;\n+      se->string_length = dest_word_len;\n     }\n   else\n     {\n-      tree moldsize;\n-      tmpdecl = gfc_create_var (type, \"transfer\");\n-      moldsize = size_in_bytes (type);\n+      tmpdecl = gfc_create_var (mold_type, \"transfer\");\n+\n+      ptr = convert (build_pointer_type (mold_type), source);\n \n       /* Use memcpy to do the transfer.  */\n       tmp = build_fold_addr_expr (tmpdecl);\n       tmp = build_call_expr (built_in_decls[BUILT_IN_MEMCPY], 3,\n \t\t\t     fold_convert (pvoid_type_node, tmp),\n \t\t\t     fold_convert (pvoid_type_node, ptr),\n-\t\t\t     moldsize);\n+\t\t\t     extent);\n       gfc_add_expr_to_block (&se->pre, tmp);\n \n       se->expr = tmpdecl;\n@@ -4828,23 +4852,7 @@ gfc_conv_intrinsic_function (gfc_se * se, gfc_expr * expr)\n \t  gfc_advance_se_ss_chain (se);\n \t}\n       else\n-\t{\n-\t  /* Ensure double transfer through LOGICAL preserves all\n-\t     the needed bits.  */\n-\t  gfc_expr *source = expr->value.function.actual->expr;\n-\t  if (source->expr_type == EXPR_FUNCTION\n-\t      && source->value.function.esym == NULL\n-\t      && source->value.function.isym != NULL\n-\t      && source->value.function.isym->id == GFC_ISYM_TRANSFER\n-\t      && source->ts.type == BT_LOGICAL\n-\t      && expr->ts.type != source->ts.type)\n-\t    source->value.function.name = \"__transfer_in_transfer\";\n-\n-\t  if (se->ss)\n-\t    gfc_conv_intrinsic_array_transfer (se, expr);\n-\t  else\n-\t    gfc_conv_intrinsic_transfer (se, expr);\n-\t}\n+\tgfc_conv_intrinsic_transfer (se, expr);\n       break;\n \n     case GFC_ISYM_TTYNAM:"}, {"sha": "3ffd5b528b8254358455c7666034fcf42d6b05f6", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c41fea4af48ddaeeef4c043d874c8c333d669849/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c41fea4af48ddaeeef4c043d874c8c333d669849/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=c41fea4af48ddaeeef4c043d874c8c333d669849", "patch": "@@ -1,3 +1,9 @@\n+2009-01-17  Paul Thomas  <pault@gcc.gnu.org>\n+\n+\tPR fortran/34955\n+\t* gfortran.dg/transfer_intrinsic_1.f90: New test.\n+\t* gfortran.dg/transfer_intrinsic_2.f90: New test.\n+\n 2009-01-17  Paul Thomas  <pault@gcc.gnu.org>\n \n \tPR fortran/38657"}, {"sha": "2eca9cfdaad233066bbcb29d4e106db686ae02c8", "filename": "gcc/testsuite/gfortran.dg/char_cast_1.f90", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c41fea4af48ddaeeef4c043d874c8c333d669849/gcc%2Ftestsuite%2Fgfortran.dg%2Fchar_cast_1.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c41fea4af48ddaeeef4c043d874c8c333d669849/gcc%2Ftestsuite%2Fgfortran.dg%2Fchar_cast_1.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fchar_cast_1.f90?ref=c41fea4af48ddaeeef4c043d874c8c333d669849", "patch": "@@ -25,7 +25,7 @@ Character (len=20) Function Upper (string)\n     return\n   end function Upper\n end\n-! The sign that all is well is that [S.5][1] appears twice.\n-! Platform dependent variations are [S$5][1], [__S_5][1], [S___5][1]\n-! { dg-final { scan-tree-dump-times \"5\\\\\\]\\\\\\[1\\\\\\]\" 2 \"original\" } }\n+! The sign that all is well is that [S.6][1] appears twice.\n+! Platform dependent variations are [S$6][1], [__S_6][1], [S___6][1]\n+! { dg-final { scan-tree-dump-times \"6\\\\\\]\\\\\\[1\\\\\\]\" 2 \"original\" } }\n ! { dg-final { cleanup-tree-dump \"original\" } }"}, {"sha": "b82b9b04026f388d9817290d69deedff59ca2bfa", "filename": "gcc/testsuite/gfortran.dg/transfer_intrinsic_1.f90", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c41fea4af48ddaeeef4c043d874c8c333d669849/gcc%2Ftestsuite%2Fgfortran.dg%2Ftransfer_intrinsic_1.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c41fea4af48ddaeeef4c043d874c8c333d669849/gcc%2Ftestsuite%2Fgfortran.dg%2Ftransfer_intrinsic_1.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Ftransfer_intrinsic_1.f90?ref=c41fea4af48ddaeeef4c043d874c8c333d669849", "patch": "@@ -0,0 +1,18 @@\n+! { dg-do compile }\n+! { dg-options \"-fdump-tree-original\" }\n+!\n+! Check the fix for PR34955 in which three bytes would be copied\n+! from bytes by TRANSFER, instead of the required two.\n+!\n+! Contributed by Tobias Burnus  <burnus@gcc.gnu.org>\n+!\n+subroutine BytesToString(bytes, string)\n+    type ByteType\n+      integer(kind=1) :: singleByte\n+    end type\n+    type (ByteType) :: bytes(2)\n+    character(len=*) :: string\n+    string = transfer(bytes, string)\n+  end subroutine\n+! { dg-final { scan-tree-dump-times \"MIN_EXPR\" 1 \"original\" } }\n+! { dg-final { cleanup-tree-dump \"original\" } }"}, {"sha": "686c0605df28a801f38bfc4205c36e115e8dc143", "filename": "gcc/testsuite/gfortran.dg/transfer_intrinsic_2.f90", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c41fea4af48ddaeeef4c043d874c8c333d669849/gcc%2Ftestsuite%2Fgfortran.dg%2Ftransfer_intrinsic_2.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c41fea4af48ddaeeef4c043d874c8c333d669849/gcc%2Ftestsuite%2Fgfortran.dg%2Ftransfer_intrinsic_2.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Ftransfer_intrinsic_2.f90?ref=c41fea4af48ddaeeef4c043d874c8c333d669849", "patch": "@@ -0,0 +1,25 @@\n+! { dg-do run }\n+!\n+! Check the fix for PR34955 in which three bytes would be copied\n+! from bytes by TRANSFER, instead of the required two and the\n+! resulting string length would be incorrect.\n+!\n+! Contributed by Dominique Dhumieres  <dominiq@lps.ens.fr>\n+!\n+  character(len = 1)  :: string = \"z\"\n+  character(len = 20) :: tmp = \"\"\n+  tmp = Upper (\"abcdefgh\")\n+  if (trim(tmp) .ne. \"ab\") call abort ()\n+contains\n+  Character (len = 20) Function Upper (string)\n+    Character(len = *) string\n+    integer :: ij\n+    i = size (transfer (string,\"xy\",len (string)))\n+    if (i /= len (string)) call abort ()\n+    Upper = \"\"\n+    Upper(1:2) = &\n+    transfer (merge (transfer (string,\"xy\",len (string)),    &\n+      string(1:2), .true.), \"xy\")\n+    return\n+  end function Upper\n+end"}]}