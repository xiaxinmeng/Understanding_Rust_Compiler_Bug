{"sha": "939c12d26a67c4e4d42d106d31c8f821b68cb1fb", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTM5YzEyZDI2YTY3YzRlNGQ0MmQxMDZkMzFjOGY4MjFiNjhjYjFmYg==", "commit": {"author": {"name": "Robert Dewar", "email": "dewar@adacore.com", "date": "2007-08-14T08:37:08Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2007-08-14T08:37:08Z"}, "message": "inline.adb, [...]: Suppress unmodified in-out parameter warning in some cases This patch is a also...\n\n2007-08-14  Robert Dewar  <dewar@adacore.com>\n\t    Ed Schonberg  <schonberg@adacore.com>\n\n\t* inline.adb, types.ads, inline.ads, frontend.adb, alloc.ads: \n\tSuppress unmodified in-out parameter warning in some cases\n\tThis patch is a also fairly significant change to the way suppressible\n\tchecks are handled.\n\n\t* checks.ads, checks.adb (Install_Null_Excluding_Check): No check\n\tneeded for access to concurrent record types generated by the expander.\n\t(Generate_Range_Check): When generating a temporary to capture the\n\tvalue of a conversion that requires a range check, set the type of the\n\ttemporary before rewriting the node, so that the type is always\n\tproperly placed for back-end use.\n\t(Apply_Float_Conversion_Check): Handle case where the conversion is\n\ttruncating.\n\t(Get_Discriminal): Code reformatting. Climb the scope stack looking\n\tfor a protected type in order to examine its discriminants.\n\nFrom-SVN: r127410", "tree": {"sha": "0b0083f9957b2140f9c2d30921874267d00521be", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/0b0083f9957b2140f9c2d30921874267d00521be"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/939c12d26a67c4e4d42d106d31c8f821b68cb1fb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/939c12d26a67c4e4d42d106d31c8f821b68cb1fb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/939c12d26a67c4e4d42d106d31c8f821b68cb1fb", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/939c12d26a67c4e4d42d106d31c8f821b68cb1fb/comments", "author": null, "committer": null, "parents": [{"sha": "835d23b2e08bb08e88163700eac0dc08442b2b0b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/835d23b2e08bb08e88163700eac0dc08442b2b0b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/835d23b2e08bb08e88163700eac0dc08442b2b0b"}], "stats": {"total": 555, "additions": 350, "deletions": 205}, "files": [{"sha": "317d3ffa3e1e7fcbf05d2b0edd55376e9dbe0ab0", "filename": "gcc/ada/alloc.ads", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/939c12d26a67c4e4d42d106d31c8f821b68cb1fb/gcc%2Fada%2Falloc.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/939c12d26a67c4e4d42d106d31c8f821b68cb1fb/gcc%2Fada%2Falloc.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Falloc.ads?ref=939c12d26a67c4e4d42d106d31c8f821b68cb1fb", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---          Copyright (C) 1992-2006, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2007, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -63,15 +63,15 @@ package Alloc is\n    Elmts_Initial                    : constant := 1_200;   -- Elists\n    Elmts_Increment                  : constant := 100;\n \n-   Entity_Suppress_Initial          : constant := 100;     -- Sem\n-   Entity_Suppress_Increment        : constant := 200;\n-\n    Inlined_Bodies_Initial           : constant := 50;      -- Inline\n    Inlined_Bodies_Increment         : constant := 200;\n \n    Inlined_Initial                  : constant := 100;     -- Inline\n    Inlined_Increment                : constant := 100;\n \n+   In_Out_Warnings_Initial          : constant := 100;     -- Sem_Warn\n+   In_Out_Warnings_Increment        : constant := 100;\n+\n    Interp_Map_Initial               : constant := 200;     -- Sem_Type\n    Interp_Map_Increment             : constant := 100;\n "}, {"sha": "027f5cbc73c6ad1cbc5f74ef6882d330a51b9f9a", "filename": "gcc/ada/checks.adb", "status": "modified", "additions": 173, "deletions": 80, "changes": 253, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/939c12d26a67c4e4d42d106d31c8f821b68cb1fb/gcc%2Fada%2Fchecks.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/939c12d26a67c4e4d42d106d31c8f821b68cb1fb/gcc%2Fada%2Fchecks.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fchecks.adb?ref=939c12d26a67c4e4d42d106d31c8f821b68cb1fb", "patch": "@@ -36,7 +36,6 @@ with Elists;   use Elists;\n with Eval_Fat; use Eval_Fat;\n with Freeze;   use Freeze;\n with Lib;      use Lib;\n-with Namet;    use Namet;\n with Nlists;   use Nlists;\n with Nmake;    use Nmake;\n with Opt;      use Opt;\n@@ -220,7 +219,7 @@ package body Checks is\n    --  routine. The Do_Static flag indicates that only a static check is\n    --  to be done.\n \n-   type Check_Type is (Access_Check, Division_Check);\n+   type Check_Type is new Check_Id range Access_Check .. Division_Check;\n    function Check_Needed (Nod : Node_Id; Check : Check_Type) return Boolean;\n    --  This function is used to see if an access or division by zero check is\n    --  needed. The check is to be applied to a single variable appearing in the\n@@ -543,12 +542,12 @@ package body Checks is\n               (\"?specified address for& may be inconsistent with alignment \",\n                Aexp, E);\n             Error_Msg_FE\n-              (\"\\?program execution may be erroneous ('R'M 13.3(27))\",\n+              (\"\\?program execution may be erroneous (RM 13.3(27))\",\n                Aexp, E);\n          end if;\n       end Compile_Time_Bad_Alignment;\n \n-   --  Start of processing for Apply_Address_Check\n+   --  Start of processing for Apply_Address_Clause_Check\n \n    begin\n       --  First obtain expression from address clause\n@@ -637,7 +636,7 @@ package body Checks is\n       --  maximum alignment is one, since the check will always succeed.\n \n       --  Note: we do not check for checks suppressed here, since that check\n-      --  was done in Sem_Ch13 when the address clause was proceeds. We are\n+      --  was done in Sem_Ch13 when the address clause was processed. We are\n       --  only called if checks were not suppressed. The reason for this is\n       --  that we have to delay the call to Apply_Alignment_Check till freeze\n       --  time (so that all types etc are elaborated), but we have to check\n@@ -953,7 +952,7 @@ package body Checks is\n \n          --  No checks necessary if expression statically null\n \n-         if Nkind (N) = N_Null then\n+         if Known_Null (N) then\n             if Can_Never_Be_Null (Typ) then\n                Install_Null_Excluding_Check (N);\n             end if;\n@@ -1007,7 +1006,7 @@ package body Checks is\n       --  unconstrained subtype (through instantiation). If this is a\n       --  discriminated component assigned in the expansion of an aggregate\n       --  in an initialization, the check must be suppressed. This unusual\n-      --  situation requires a predicate of its own (see 7503-008).\n+      --  situation requires a predicate of its own.\n \n       ----------------------------------------\n       -- Is_Aliased_Unconstrained_Component --\n@@ -1064,7 +1063,7 @@ package body Checks is\n       --  incomplete, then the access value must be null and we suppress the\n       --  check.\n \n-      if Nkind (N) = N_Null then\n+      if Known_Null (N) then\n          return;\n \n       elsif Is_Access_Type (S_Typ) then\n@@ -1388,28 +1387,38 @@ package body Checks is\n    --  to perform a range check in the floating-point domain instead, however:\n \n    --      (1)  The bounds may not be known at compile time\n-   --      (2)  The check must take into account possible rounding.\n+   --      (2)  The check must take into account rounding or truncation.\n    --      (3)  The range of type I may not be exactly representable in F.\n-   --      (4)  The end-points I'First - 0.5 and I'Last + 0.5 may or may\n-   --           not be in range, depending on the sign of  I'First and I'Last.\n+   --      (4)  For the rounding case, The end-points I'First - 0.5 and\n+   --           I'Last + 0.5 may or may not be in range, depending on the\n+   --           sign of  I'First and I'Last.\n    --      (5)  X may be a NaN, which will fail any comparison\n \n-   --  The following steps take care of these issues converting X:\n+   --  The following steps correctly convert X with rounding:\n \n    --      (1) If either I'First or I'Last is not known at compile time, use\n    --          I'Base instead of I in the next three steps and perform a\n    --          regular range check against I'Range after conversion.\n    --      (2) If I'First - 0.5 is representable in F then let Lo be that\n    --          value and define Lo_OK as (I'First > 0). Otherwise, let Lo be\n-   --          F'Machine (T) and let Lo_OK be (Lo >= I'First). In other words,\n-   --          take one of the closest floating-point numbers to T, and see if\n-   --          it is in range or not.\n+   --          F'Machine (I'First) and let Lo_OK be (Lo >= I'First).\n+   --          In other words, take one of the closest floating-point numbers\n+   --          (which is an integer value) to I'First, and see if it is in\n+   --          range or not.\n    --      (3) If I'Last + 0.5 is representable in F then let Hi be that value\n    --          and define Hi_OK as (I'Last < 0). Otherwise, let Hi be\n-   --          F'Rounding (T) and let Hi_OK be (Hi <= I'Last).\n+   --          F'Machine (I'Last) and let Hi_OK be (Hi <= I'Last).\n    --      (4) Raise CE when (Lo_OK and X < Lo) or (not Lo_OK and X <= Lo)\n    --                     or (Hi_OK and X > Hi) or (not Hi_OK and X >= Hi)\n \n+   --  For the truncating case, replace steps (2) and (3) as follows:\n+   --      (2) If I'First > 0, then let Lo be F'Pred (I'First) and let Lo_OK\n+   --          be False. Otherwise, let Lo be F'Succ (I'First - 1) and let\n+   --          Lo_OK be True.\n+   --      (3) If I'Last < 0, then let Hi be F'Succ (I'Last) and let Hi_OK\n+   --          be False. Otherwise let Hi be F'Pred (I'Last + 1) and let\n+   --          Hi_OK be False\n+\n    procedure Apply_Float_Conversion_Check\n      (Ck_Node    : Node_Id;\n       Target_Typ : Entity_Id)\n@@ -1421,9 +1430,16 @@ package body Checks is\n       Target_Base : constant Entity_Id  :=\n                       Implementation_Base_Type (Target_Typ);\n \n-      Max_Bound   : constant Uint := UI_Expon\n-                                       (Machine_Radix (Expr_Type),\n-                                        Machine_Mantissa (Expr_Type) - 1) - 1;\n+      Par : constant Node_Id := Parent (Ck_Node);\n+      pragma Assert (Nkind (Par) = N_Type_Conversion);\n+      --  Parent of check node, must be a type conversion\n+\n+      Truncate  : constant Boolean := Float_Truncate (Par);\n+      Max_Bound : constant Uint :=\n+                    UI_Expon\n+                      (Machine_Radix (Expr_Type),\n+                       Machine_Mantissa (Expr_Type) - 1) - 1;\n+\n       --  Largest bound, so bound plus or minus half is a machine number of F\n \n       Ifirst, Ilast : Uint;\n@@ -1449,10 +1465,7 @@ package body Checks is\n             --  to prevent overflow during conversion and then perform a\n             --  regular range check against the (dynamic) bounds.\n \n-            Par : constant Node_Id := Parent (Ck_Node);\n-\n             pragma Assert (Target_Base /= Target_Typ);\n-            pragma Assert (Nkind (Par) = N_Type_Conversion);\n \n             Temp : constant Entity_Id :=\n                     Make_Defining_Identifier (Loc,\n@@ -1489,9 +1502,18 @@ package body Checks is\n \n       --  Check against lower bound\n \n-      if abs (Ifirst) < Max_Bound then\n+      if Truncate and then Ifirst > 0 then\n+         Lo := Pred (Expr_Type, UR_From_Uint (Ifirst));\n+         Lo_OK := False;\n+\n+      elsif Truncate then\n+         Lo := Succ (Expr_Type, UR_From_Uint (Ifirst - 1));\n+         Lo_OK := True;\n+\n+      elsif abs (Ifirst) < Max_Bound then\n          Lo := UR_From_Uint (Ifirst) - Ureal_Half;\n          Lo_OK := (Ifirst > 0);\n+\n       else\n          Lo := Machine (Expr_Type, UR_From_Uint (Ifirst), Round_Even, Ck_Node);\n          Lo_OK := (Lo >= UR_From_Uint (Ifirst));\n@@ -1515,7 +1537,15 @@ package body Checks is\n \n       --  Check against higher bound\n \n-      if abs (Ilast) < Max_Bound then\n+      if Truncate and then Ilast < 0 then\n+         Hi := Succ (Expr_Type, UR_From_Uint (Ilast));\n+         Lo_OK := False;\n+\n+      elsif Truncate then\n+         Hi := Pred (Expr_Type, UR_From_Uint (Ilast + 1));\n+         Hi_OK := True;\n+\n+      elsif abs (Ilast) < Max_Bound then\n          Hi := UR_From_Uint (Ilast) + Ureal_Half;\n          Hi_OK := (Ilast < 0);\n       else\n@@ -1636,17 +1666,25 @@ package body Checks is\n    --  Start of processing for Apply_Scalar_Range_Check\n \n    begin\n-      if Inside_A_Generic then\n-         return;\n+      --  Return if check obviously not needed\n \n-      --  Return if check obviously not needed. Note that we do not check for\n-      --  the expander being inactive, since this routine does not insert any\n-      --  code, but it does generate useful warnings sometimes, which we would\n-      --  like even if we are in semantics only mode.\n+      if\n+         --  Not needed inside generic\n \n-      elsif Target_Typ = Any_Type\n-        or else not Is_Scalar_Type (Target_Typ)\n-        or else Raises_Constraint_Error (Expr)\n+         Inside_A_Generic\n+\n+         --  Not needed if previous error\n+\n+         or else Target_Typ = Any_Type\n+         or else Nkind (Expr) = N_Error\n+\n+         --  Not needed for non-scalar type\n+\n+         or else not Is_Scalar_Type (Target_Typ)\n+\n+         --  Not needed if we know node raises CE already\n+\n+         or else Raises_Constraint_Error (Expr)\n       then\n          return;\n       end if;\n@@ -2498,11 +2536,11 @@ package body Checks is\n          return True;\n       end if;\n \n-      --  Right operand of test mus be key value (zero or null)\n+      --  Right operand of test must be key value (zero or null)\n \n       case Check is\n          when Access_Check =>\n-            if Nkind (R) /= N_Null then\n+            if not Known_Null (R) then\n                return True;\n             end if;\n \n@@ -2512,6 +2550,9 @@ package body Checks is\n             then\n                return True;\n             end if;\n+\n+         when others =>\n+            raise Program_Error;\n       end case;\n \n       --  Here we have the optimizable case, warn if not short-circuited\n@@ -2526,6 +2567,9 @@ package body Checks is\n                Error_Msg_N\n                  (\"Constraint_Error may be raised (zero divide)?\",\n                   Parent (Nod));\n+\n+            when others =>\n+               raise Program_Error;\n          end case;\n \n          if K = N_Op_And then\n@@ -2682,29 +2726,27 @@ package body Checks is\n       if K /= N_Function_Specification then\n          Expr := Expression (N);\n \n-         if Present (Expr)\n-           and then Nkind (Expr) = N_Null\n-         then\n+         if Present (Expr) and then Known_Null (Expr) then\n             case K is\n                when N_Component_Declaration      |\n                     N_Discriminant_Specification =>\n                   Apply_Compile_Time_Constraint_Error\n                     (N      => Expr,\n-                     Msg    => \"(Ada 2005) NULL not allowed \" &\n+                     Msg    => \"(Ada 2005) null not allowed \" &\n                                \"in null-excluding components?\",\n                      Reason => CE_Null_Not_Allowed);\n \n                when N_Object_Declaration =>\n                   Apply_Compile_Time_Constraint_Error\n                     (N      => Expr,\n-                     Msg    => \"(Ada 2005) NULL not allowed \" &\n+                     Msg    => \"(Ada 2005) null not allowed \" &\n                                \"in null-excluding objects?\",\n                      Reason => CE_Null_Not_Allowed);\n \n                when N_Parameter_Specification =>\n                   Apply_Compile_Time_Constraint_Error\n                     (N      => Expr,\n-                     Msg    => \"(Ada 2005) NULL not allowed \" &\n+                     Msg    => \"(Ada 2005) null not allowed \" &\n                                \"in null-excluding formals?\",\n                      Reason => CE_Null_Not_Allowed);\n \n@@ -4459,6 +4501,12 @@ package body Checks is\n                 Reason => Reason)));\n \n             Rewrite (N, New_Occurrence_Of (Tnn, Loc));\n+\n+            --  Set the type of N, because the declaration for Tnn might not\n+            --  be analyzed yet, as is the case if N appears within a record\n+            --  declaration, as a discriminant constraint or expression.\n+\n+            Set_Etype (N, Target_Base_Type);\n          end;\n \n       --  At this stage, we know that we have two scalar types, which are\n@@ -4626,6 +4674,32 @@ package body Checks is\n       end if;\n    end Generate_Range_Check;\n \n+   ------------------\n+   -- Get_Check_Id --\n+   ------------------\n+\n+   function Get_Check_Id (N : Name_Id) return Check_Id is\n+   begin\n+      --  For standard check name, we can do a direct computation\n+\n+      if N in First_Check_Name .. Last_Check_Name then\n+         return Check_Id (N - (First_Check_Name - 1));\n+\n+      --  For non-standard names added by pragma Check_Name, search table\n+\n+      else\n+         for J in All_Checks + 1 .. Check_Names.Last loop\n+            if Check_Names.Table (J) = N then\n+               return J;\n+            end if;\n+         end loop;\n+      end if;\n+\n+      --  No matching name found\n+\n+      return No_Check_Id;\n+   end Get_Check_Id;\n+\n    ---------------------\n    -- Get_Discriminal --\n    ---------------------\n@@ -4636,38 +4710,55 @@ package body Checks is\n       Sc  : Entity_Id;\n \n    begin\n-      --  The entity E is the type of a private component of the protected\n-      --  type, or the type of a renaming of that component within a protected\n-      --  operation of that type.\n-\n-      Sc := Scope (E);\n-\n-      if Ekind (Sc) /= E_Protected_Type then\n-         Sc := Scope (Sc);\n-\n-         if Ekind (Sc) /= E_Protected_Type then\n-            return Bound;\n-         end if;\n-      end if;\n-\n       --  The bound can be a bona fide parameter of a protected operation,\n       --  rather than a prival encoded as an in-parameter.\n \n       if No (Discriminal_Link (Entity (Bound))) then\n          return Bound;\n       end if;\n \n+      --  Climb the scope stack looking for an enclosing protected type. If\n+      --  we run out of scopes, return the bound itself.\n+\n+      Sc := Scope (E);\n+      while Present (Sc) loop\n+         if Sc = Standard_Standard then\n+            return Bound;\n+\n+         elsif Ekind (Sc) = E_Protected_Type then\n+            exit;\n+         end if;\n+\n+         Sc := Scope (Sc);\n+      end loop;\n+\n       D := First_Discriminant (Sc);\n+      while Present (D) loop\n+         if Chars (D) = Chars (Bound) then\n+            return New_Occurrence_Of (Discriminal (D), Loc);\n+         end if;\n \n-      while Present (D)\n-        and then Chars (D) /= Chars (Bound)\n-      loop\n          Next_Discriminant (D);\n       end loop;\n \n-      return New_Occurrence_Of (Discriminal (D), Loc);\n+      return Bound;\n    end Get_Discriminal;\n \n+   ----------------------\n+   -- Get_Range_Checks --\n+   ----------------------\n+\n+   function Get_Range_Checks\n+     (Ck_Node    : Node_Id;\n+      Target_Typ : Entity_Id;\n+      Source_Typ : Entity_Id := Empty;\n+      Warn_Node  : Node_Id   := Empty) return Check_Result\n+   is\n+   begin\n+      return Selected_Range_Checks\n+        (Ck_Node, Target_Typ, Source_Typ, Warn_Node);\n+   end Get_Range_Checks;\n+\n    ------------------\n    -- Guard_Access --\n    ------------------\n@@ -4717,6 +4808,12 @@ package body Checks is\n       for J in Determine_Range_Cache_N'Range loop\n          Determine_Range_Cache_N (J) := Empty;\n       end loop;\n+\n+      Check_Names.Init;\n+\n+      for J in Int range 1 .. All_Checks loop\n+         Check_Names.Append (Name_Id (Int (First_Check_Name) + J - 1));\n+      end loop;\n    end Initialize;\n \n    -------------------------\n@@ -4952,6 +5049,18 @@ package body Checks is\n          return;\n       end if;\n \n+      --  No check needed for access to concurrent record types generated by\n+      --  the expander. This is not just an optimization (though it does indeed\n+      --  remove junk checks). It also avoids generation of junk warnings.\n+\n+      if Nkind (N) in N_Has_Chars\n+        and then Chars (N) = Name_uObject\n+        and then Is_Concurrent_Record_Type\n+                   (Directly_Designated_Type (Etype (N)))\n+      then\n+         return;\n+      end if;\n+\n       --  Otherwise install access check\n \n       Insert_Action (N,\n@@ -5050,22 +5159,6 @@ package body Checks is\n          return Scope_Suppress (Overflow_Check);\n       end if;\n    end Overflow_Checks_Suppressed;\n-\n-   -----------------\n-   -- Range_Check --\n-   -----------------\n-\n-   function Range_Check\n-     (Ck_Node    : Node_Id;\n-      Target_Typ : Entity_Id;\n-      Source_Typ : Entity_Id := Empty;\n-      Warn_Node  : Node_Id   := Empty) return Check_Result\n-   is\n-   begin\n-      return Selected_Range_Checks\n-        (Ck_Node, Target_Typ, Source_Typ, Warn_Node);\n-   end Range_Check;\n-\n    -----------------------------\n    -- Range_Checks_Suppressed --\n    -----------------------------\n@@ -5357,7 +5450,7 @@ package body Checks is\n                   Next_Index (Indx_Type);\n                end loop;\n \n-               Get_Index_Bounds  (Indx_Type, Lo, Hi);\n+               Get_Index_Bounds (Indx_Type, Lo, Hi);\n \n                if Nkind (Lo) = N_Identifier\n                  and then Ekind (Entity (Lo)) = E_In_Parameter\n@@ -5542,9 +5635,9 @@ package body Checks is\n          T_Typ := Designated_Type (T_Typ);\n          Do_Access := True;\n \n-         --  A simple optimization\n+         --  A simple optimization for the null case\n \n-         if Nkind (Ck_Node) = N_Null then\n+         if Known_Null (Ck_Node) then\n             return Ret_Result;\n          end if;\n       end if;\n@@ -6193,9 +6286,9 @@ package body Checks is\n          T_Typ := Designated_Type (T_Typ);\n          Do_Access := True;\n \n-         --  A simple optimization\n+         --  A simple optimization for the null case\n \n-         if Nkind (Ck_Node) = N_Null then\n+         if Known_Null (Ck_Node) then\n             return Ret_Result;\n          end if;\n       end if;"}, {"sha": "18cb6e7289044b5831d79f7551f06b5e3db7e9c5", "filename": "gcc/ada/checks.ads", "status": "modified", "additions": 42, "deletions": 18, "changes": 60, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/939c12d26a67c4e4d42d106d31c8f821b68cb1fb/gcc%2Fada%2Fchecks.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/939c12d26a67c4e4d42d106d31c8f821b68cb1fb/gcc%2Fada%2Fchecks.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fchecks.ads?ref=939c12d26a67c4e4d42d106d31c8f821b68cb1fb", "patch": "@@ -36,8 +36,10 @@\n --  This always occurs whether checks are suppressed or not.  Dynamic range\n --  checks are, of course, not inserted if checks are suppressed.\n \n-with Types; use Types;\n-with Uintp; use Uintp;\n+with Namet;  use Namet;\n+with Table;\n+with Types;  use Types;\n+with Uintp;  use Uintp;\n \n package Checks is\n \n@@ -383,16 +385,28 @@ package Checks is\n    --  values (i.e. the underlying integer value is used).\n \n    type Check_Result is private;\n-   --  Type used to return result of Range_Check call, for later use in\n+   --  Type used to return result of Get_Range_Checks call, for later use in\n    --  call to Insert_Range_Checks procedure.\n \n+   function Get_Range_Checks\n+     (Ck_Node    : Node_Id;\n+      Target_Typ : Entity_Id;\n+      Source_Typ : Entity_Id := Empty;\n+      Warn_Node  : Node_Id   := Empty) return Check_Result;\n+   --  Like Apply_Range_Check, except it does not modify anything. Instead\n+   --  it returns an encapsulated result of the check operations for later\n+   --  use in a call to Insert_Range_Checks. If Warn_Node is non-empty, its\n+   --  Sloc is used, in the static case, for the generated warning or error.\n+   --  Additionally, it is used rather than Expr (or Low/High_Bound of Expr)\n+   --  in constructing the check.\n+\n    procedure Append_Range_Checks\n      (Checks       : Check_Result;\n       Stmts        : List_Id;\n       Suppress_Typ : Entity_Id;\n       Static_Sloc  : Source_Ptr;\n       Flag_Node    : Node_Id);\n-   --  Called to append range checks as returned by a call to Range_Check.\n+   --  Called to append range checks as returned by a call to Get_Range_Checks.\n    --  Stmts is a list to which either the dynamic check is appended or the\n    --  raise Constraint_Error statement is appended (for static checks).\n    --  Static_Sloc is the Sloc at which the raise CE node points, Flag_Node is\n@@ -406,7 +420,7 @@ package Checks is\n       Static_Sloc  : Source_Ptr := No_Location;\n       Flag_Node    : Node_Id    := Empty;\n       Do_Before    : Boolean    := False);\n-   --  Called to insert range checks as returned by a call to Range_Check.\n+   --  Called to insert range checks as returned by a call to Get_Range_Checks.\n    --  Node is the node after which either the dynamic check is inserted or\n    --  the raise Constraint_Error statement is inserted (for static checks).\n    --  Suppress_Typ is the type to check to determine if checks are suppressed.\n@@ -417,19 +431,6 @@ package Checks is\n    --  inserted after, if Do_Before is True, the check is inserted before\n    --  Node.\n \n-   function Range_Check\n-     (Ck_Node    : Node_Id;\n-      Target_Typ : Entity_Id;\n-      Source_Typ : Entity_Id := Empty;\n-      Warn_Node  : Node_Id   := Empty)\n-      return       Check_Result;\n-   --  Like Apply_Range_Check, except it does not modify anything. Instead\n-   --  it returns an encapsulated result of the check operations for later\n-   --  use in a call to Insert_Range_Checks. If Warn_Node is non-empty, its\n-   --  Sloc is used, in the static case, for the generated warning or error.\n-   --  Additionally, it is used rather than Expr (or Low/High_Bound of Expr)\n-   --  in constructing the check.\n-\n    -----------------------\n    -- Expander Routines --\n    -----------------------\n@@ -659,6 +660,29 @@ package Checks is\n    --  If N is an N_Range node, then Ensure_Valid is called on its bounds,\n    --  if validity checking of operands is enabled.\n \n+   -----------------------------\n+   -- Handling of Check Names --\n+   -----------------------------\n+\n+   --  The following table contains Name_Id's for recognized checks. The first\n+   --  entries (corresponding to the values of the subtype Predefined_Check_Id)\n+   --  contain the Name_Id values for the checks that are predefined, including\n+   --  All_Checks (see Types). Remaining entries are those that are introduced\n+   --  by pragma Check_Names.\n+\n+   package Check_Names is new Table.Table (\n+     Table_Component_Type => Name_Id,\n+     Table_Index_Type     => Check_Id,\n+     Table_Low_Bound      => 1,\n+     Table_Initial        => 30,\n+     Table_Increment      => 200,\n+     Table_Name           => \"Name_Check_Names\");\n+\n+   function Get_Check_Id (N : Name_Id) return Check_Id;\n+   --  Function to search above table for matching name. If found returns the\n+   --  corresponding Check_Id value in the range 1 .. Check_Name.Last. If not\n+   --  found returns No_Check_Id.\n+\n private\n \n    type Check_Result is array (Positive range 1 .. 2) of Node_Id;"}, {"sha": "7c6676cd4c720e933eeb60ac0bd792d168ba30fb", "filename": "gcc/ada/frontend.adb", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/939c12d26a67c4e4d42d106d31c8f821b68cb1fb/gcc%2Fada%2Ffrontend.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/939c12d26a67c4e4d42d106d31c8f821b68cb1fb/gcc%2Fada%2Ffrontend.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Ffrontend.adb?ref=939c12d26a67c4e4d42d106d31c8f821b68cb1fb", "patch": "@@ -322,9 +322,10 @@ begin\n             Lib.List;\n          end if;\n \n-         --  Output any messages for unreferenced entities\n+         --  Output waiting warning messages\n \n-         Output_Unreferenced_Messages;\n+         Sem_Warn.Output_Non_Modifed_In_Out_Warnings;\n+         Sem_Warn.Output_Unreferenced_Messages;\n          Sem_Warn.Check_Unused_Withs;\n       end if;\n    end if;"}, {"sha": "597c975bb3b12a355eb78e2e8b85a4bfed73e732", "filename": "gcc/ada/inline.adb", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/939c12d26a67c4e4d42d106d31c8f821b68cb1fb/gcc%2Fada%2Finline.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/939c12d26a67c4e4d42d106d31c8f821b68cb1fb/gcc%2Fada%2Finline.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Finline.adb?ref=939c12d26a67c4e4d42d106d31c8f821b68cb1fb", "patch": "@@ -957,7 +957,6 @@ package body Inline is\n          --  set (that's why we can't simply use a FOR loop here).\n \n          J := 0;\n-\n          while J <= Pending_Instantiations.Last\n            and then Serious_Errors_Detected = 0\n          loop"}, {"sha": "4b80f7774bd5500cca34d26b29a59d4104d6e163", "filename": "gcc/ada/inline.ads", "status": "modified", "additions": 20, "deletions": 3, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/939c12d26a67c4e4d42d106d31c8f821b68cb1fb/gcc%2Fada%2Finline.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/939c12d26a67c4e4d42d106d31c8f821b68cb1fb/gcc%2Fada%2Finline.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Finline.ads?ref=939c12d26a67c4e4d42d106d31c8f821b68cb1fb", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---          Copyright (C) 1992-2001 Free Software Foundation, Inc.          --\n+--          Copyright (C) 1992-2007, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -37,8 +37,9 @@\n --  Frontend, and thus are not mutually recursive.\n \n with Alloc;\n+with Sem;   use Sem;\n with Table;\n-with Types;  use Types;\n+with Types; use Types;\n \n package Inline is\n \n@@ -51,7 +52,7 @@ package Inline is\n    --  global data structure, and the bodies constructed by means of a separate\n    --  analysis and expansion step.\n \n-   --  See full description in body of Sem_Ch12 for details\n+   --  See full description in body of Sem_Ch12 for more details\n \n    type Pending_Body_Info is record\n       Inst_Node : Node_Id;\n@@ -68,6 +69,22 @@ package Inline is\n       --  The semantic unit within which the instantiation is found. Must\n       --  be restored when compiling the body, to insure that internal enti-\n       --  ties use the same counter and are unique over spec and body.\n+\n+      Scope_Suppress           : Suppress_Array;\n+      Local_Suppress_Stack_Top : Suppress_Stack_Entry_Ptr;\n+      --  Save suppress information at the point of instantiation. Used to\n+      --  properly inherit check status active at this point (see RM 11.5\n+      --  (7.2/2), AI95-00224-01):\n+      --\n+      --    \"If a checking pragma applies to a generic instantiation, then the\n+      --    checking pragma also applies to the instance. If a checking pragma\n+      --    applies to a call to a subprogram that has a pragma Inline applied\n+      --    to it, then the checking pragma also applies to the inlined\n+      --    subprogram body\".\n+      --\n+      --  This means we have to capture this information from the current scope\n+      --  at the point of instantiation.\n+\n    end record;\n \n    package Pending_Instantiations is new Table.Table ("}, {"sha": "4d5ebfc027049a0db6e8c8aa1a2651330029a567", "filename": "gcc/ada/types.ads", "status": "modified", "additions": 108, "deletions": 97, "changes": 205, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/939c12d26a67c4e4d42d106d31c8f821b68cb1fb/gcc%2Fada%2Ftypes.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/939c12d26a67c4e4d42d106d31c8f821b68cb1fb/gcc%2Fada%2Ftypes.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Ftypes.ads?ref=939c12d26a67c4e4d42d106d31c8f821b68cb1fb", "patch": "@@ -31,13 +31,13 @@\n --                                                                          --\n ------------------------------------------------------------------------------\n \n---  This package contains host independent type definitions which are used\n---  in more than one unit in the compiler. They are gathered here for easy\n+--  This package contains host independent type definitions which are used in\n+--  more than one unit in the compiler. They are gathered here for easy\n --  reference, though in some cases the full description is found in the\n---  relevant module which implements the definition. The main reason that\n---  they are not in their \"natural\" specs is that this would cause a lot\n---  of inter-spec dependencies, and in particular some awkward circular\n---  dependencies would have to be dealt with.\n+--  relevant module which implements the definition. The main reason that they\n+--  are not in their \"natural\" specs is that this would cause a lot of inter-\n+--  spec dependencies, and in particular some awkward circular dependencies\n+--  would have to be dealt with.\n \n --  WARNING: There is a C version of this package. Any changes to this source\n --  file must be properly reflected in the C header file types.h declarations.\n@@ -108,9 +108,9 @@ package Types is\n    --  Line terminator characters (LF, VT, FF, CR)\n    --\n    --  This definition is dubious now that we have two more wide character\n-   --  sequences that constitute a line terminator. Every reference to\n-   --  this subtype needs checking to make sure the wide character case\n-   --  is handled appropriately. ???\n+   --  sequences that constitute a line terminator. Every reference to this\n+   --  subtype needs checking to make sure the wide character case is handled\n+   --  appropriately. ???\n \n    subtype Upper_Half_Character is\n      Character range Character'Val (16#80#) .. Character'Val (16#FF#);\n@@ -134,9 +134,9 @@ package Types is\n    -- Types Used for Text Buffer Handling --\n    -----------------------------------------\n \n-   --  We can't use type String for text buffers, since we must use the\n-   --  standard 32-bit integer as an index value, since we count on all\n-   --  index values being the same size.\n+   --  We can not use type String for text buffers, since we must use the\n+   --  standard 32-bit integer as an index value, since we count on all index\n+   --  values being the same size.\n \n    type Text_Ptr is new Int;\n    --  Type used for subscripts in text buffer\n@@ -167,9 +167,9 @@ package Types is\n \n    type Physical_Line_Number is range 1 .. Int'Last;\n    for Physical_Line_Number'Size use 32;\n-   --  Line number type, used for storing physical line numbers (i.e.\n-   --  line numbers in the physical file being compiled, unaffected by\n-   --  the presence of source reference pragmas.\n+   --  Line number type, used for storing physical line numbers (i.e. line\n+   --  numbers in the physical file being compiled, unaffected by the presence\n+   --  of source reference pragmas.\n \n    type Column_Number is range 0 .. 32767;\n    for Column_Number'Size use 16;\n@@ -183,20 +183,20 @@ package Types is\n    subtype Source_Buffer is Text_Buffer;\n    --  Type used to store text of a source file . The buffer for the main\n    --  source (the source specified on the command line) has a lower bound\n-   --  starting at zero. Subsequent subsidiary sources have lower bounds\n-   --  which are one greater than the previous upper bound.\n+   --  starting at zero. Subsequent subsidiary sources have lower bounds which\n+   --  are one greater than the previous upper bound.\n \n    subtype Big_Source_Buffer is Text_Buffer (0 .. Text_Ptr'Last);\n    --  This is a virtual type used as the designated type of the access\n    --  type Source_Buffer_Ptr, see Osint.Read_Source_File for details.\n \n    type Source_Buffer_Ptr is access all Big_Source_Buffer;\n-   --  Pointer to source buffer. We use virtual origin addressing for\n-   --  source buffers, with thin pointers. The pointer points to a virtual\n-   --  instance of type Big_Source_Buffer, where the actual type is in fact\n-   --  of type Source_Buffer. The address is adjusted so that the virtual\n-   --  origin addressing works correctly. See Osint.Read_Source_Buffer for\n-   --  further details.\n+   --  Pointer to source buffer. We use virtual origin addressing for source\n+   --  buffers, with thin pointers. The pointer points to a virtual instance\n+   --  of type Big_Source_Buffer, where the actual type is in fact of type\n+   --  Source_Buffer. The address is adjusted so that the virtual origin\n+   --  addressing works correctly. See Osint.Read_Source_Buffer for further\n+   --  details.\n \n    subtype Source_Ptr is Text_Ptr;\n    --  Type used to represent a source location, which is a subscript of a\n@@ -215,10 +215,10 @@ package Types is\n    --  mode and the corresponding source line in -gnatD mode).\n \n    Standard_Location : constant Source_Ptr := -2;\n-   --  Used for all nodes in the representation of package Standard other\n-   --  than nodes representing the contents of Standard.ASCII. Note that\n-   --  testing for <= Standard_Location tests for both Standard_Location\n-   --  and for Standard_ASCII_Location.\n+   --  Used for all nodes in the representation of package Standard other than\n+   --  nodes representing the contents of Standard.ASCII. Note that testing for\n+   --  a value being <= Standard_Location tests for both Standard_Location and\n+   --  for Standard_ASCII_Location.\n \n    Standard_ASCII_Location : constant Source_Ptr := -3;\n    --  Used for all nodes in the presentation of package Standard.ASCII\n@@ -266,13 +266,13 @@ package Types is\n    --  List_Id and Node_Id values (see further description below).\n \n    List_High_Bound : constant := 0;\n-   --  Maximum List_Id subscript value. This allows up to 100 million list\n-   --  Id values, which is in practice infinite, and there is no need to\n-   --  check the range. The range overlaps the node range by one element\n-   --  (with value zero), which is used both for the Empty node, and for\n-   --  indicating no list. The fact that the same value is used is convenient\n-   --  because it means that the default value of Empty applies to both nodes\n-   --  and lists, and also is more efficient to test for.\n+   --  Maximum List_Id subscript value. This allows up to 100 million list Id\n+   --  values, which is in practice infinite, and there is no need to check the\n+   --  range. The range overlaps the node range by one element (with value\n+   --  zero), which is used both for the Empty node, and for indicating no\n+   --  list. The fact that the same value is used is convenient because it\n+   --  means that the default value of Empty applies to both nodes and lists,\n+   --  and also is more efficient to test for.\n \n    Node_Low_Bound : constant := 0;\n    --  The tree Id values start at zero, because we use zero for Empty (to\n@@ -413,10 +413,10 @@ package Types is\n    ------------------------------\n \n    --  List_Id values are used to identify node lists in the tree. They are\n-   --  subscripts into the Lists table declared in package Tree. Note that\n-   --  the special value Error_List is a subscript in this table, but the\n-   --  value No_List is *not* a valid subscript, and any attempt to apply\n-   --  list operations to No_List will cause a (detected) error.\n+   --  subscripts into the Lists table declared in package Tree. Note that the\n+   --  special value Error_List is a subscript in this table, but the value\n+   --  No_List is *not* a valid subscript, and any attempt to apply list\n+   --  operations to No_List will cause a (detected) error.\n \n    type List_Id is range List_Low_Bound .. List_High_Bound;\n    --  Type used to identify a node list\n@@ -439,10 +439,10 @@ package Types is\n    -- Types for Elists Package --\n    ------------------------------\n \n-   --  Element list Id values are used to identify element lists stored in\n-   --  the tree (see package Tree for further details). They are formed by\n-   --  adding a bias (Element_List_Bias) to subscript values in the same\n-   --  array that is used for node list headers.\n+   --  Element list Id values are used to identify element lists stored in the\n+   --  tree (see package Tree for further details). They are formed by adding a\n+   --  bias (Element_List_Bias) to subscript values in the same array that is\n+   --  used for node list headers.\n \n    type Elist_Id is range Elist_Low_Bound .. Elist_High_Bound;\n    --  Type used to identify an element list (Elist header table subscript)\n@@ -471,8 +471,8 @@ package Types is\n    -- Types for Stringt Package --\n    -------------------------------\n \n-   --  String_Id values are used to identify entries in the strings table.\n-   --  They are subscripts into the strings table defined in package Strings.\n+   --  String_Id values are used to identify entries in the strings table. They\n+   --  are subscripts into the strings table defined in package Strings.\n \n    --  Note that with only a few exceptions, which are clearly documented, the\n    --  type String_Id should be regarded as a private type. In particular it is\n@@ -492,15 +492,15 @@ package Types is\n    -- Character Code Type --\n    -------------------------\n \n-   --  The type Char is used for character data internally in the compiler,\n-   --  but character codes in the source are represented by the Char_Code\n-   --  type. Each character literal in the source is interpreted as being one\n-   --  of the 16#8000_0000 possible Wide_Wide_Character codes, and a unique\n-   --  Integer Value is assigned, corresponding to the UTF_32 value, which\n-   --  also correspondds to the POS value in the Wide_Wide_Character type,\n-   --  and also corresponds to the POS value in the Wide_Character and\n-   --  Character types for values that are in appropriate range. String\n-   --  literals are similarly interpreted as a sequence of such codes.\n+   --  The type Char is used for character data internally in the compiler, but\n+   --  character codes in the source are represented by the Char_Code type.\n+   --  Each character literal in the source is interpreted as being one of the\n+   --  16#8000_0000 possible Wide_Wide_Character codes, and a unique Integer\n+   --  Value is assigned, corresponding to the UTF_32 value, which also\n+   --  correspondds to the POS value in the Wide_Wide_Character type, and also\n+   --  corresponds to the POS value in the Wide_Character and Character types\n+   --  for values that are in appropriate range. String literals are similarly\n+   --  interpreted as a sequence of such codes.\n \n    type Char_Code_Base is mod 2 ** 32;\n    for Char_Code_Base'Size use 32;\n@@ -530,7 +530,7 @@ package Types is\n    pragma Inline (Get_Character);\n    --  For a character C that is in Character range (see above function), this\n    --  function returns the corresponding Character value. It is an error to\n-   --  call Get_Character if C is not in C haracter range\n+   --  call Get_Character if C is not in Character range.\n \n    function Get_Wide_Character (C : Char_Code) return Wide_Character;\n    --  For a character C that is in Wide_Character range (see above function),\n@@ -596,11 +596,10 @@ package Types is\n    --  Type used to represent time stamp\n \n    Empty_Time_Stamp : constant Time_Stamp_Type := (others => ' ');\n-   --  Type used to represent an empty or missing time stamp. Looks less\n-   --  than any real time stamp if two time stamps are compared. Note that\n-   --  although this is not a private type, clients should not rely on the\n-   --  exact way in which this string is represented, and instead should\n-   --  use the subprograms below.\n+   --  Value representing an empty or missing time stamp. Looks less than any\n+   --  real time stamp if two time stamps are compared. Note that although this\n+   --  is not private, clients should not rely on the exact way in which this\n+   --  string is represented, and instead should use the subprograms below.\n \n    Dummy_Time_Stamp : constant Time_Stamp_Type := (others => '0');\n    --  This is used for dummy time stamp values used in the D lines for\n@@ -611,14 +610,15 @@ package Types is\n    function \">=\" (Left, Right : Time_Stamp_Type) return Boolean;\n    function \"<\"  (Left, Right : Time_Stamp_Type) return Boolean;\n    function \">\"  (Left, Right : Time_Stamp_Type) return Boolean;\n-   --  Comparison functions on time stamps. Note that two time stamps\n-   --  are defined as being equal if they have the same day/month/year\n-   --  and the hour/minutes/seconds values are within 2 seconds of one\n-   --  another. This deals with rounding effects in library file time\n-   --  stamps caused by copying operations during installation. We have\n-   --  particularly noticed that WinNT seems susceptible to such changes.\n-   --  Note: the Empty_Time_Stamp value looks equal to itself, and less\n-   --  than any non-empty time stamp value.\n+   --  Comparison functions on time stamps. Note that two time stamps are\n+   --  defined as being equal if they have the same day/month/year and the\n+   --  hour/minutes/seconds values are within 2 seconds of one another. This\n+   --  deals with rounding effects in library file time stamps caused by\n+   --  copying operations during installation. We have particularly noticed\n+   --  that WinNT seems susceptible to such changes.\n+   --\n+   --  Note : the Empty_Time_Stamp value looks equal to itself, and less than\n+   --  any non-empty time stamp value.\n \n    procedure Split_Time_Stamp\n      (TS      : Time_Stamp_Type;\n@@ -644,21 +644,32 @@ package Types is\n    -- Types used for Pragma Suppress Management --\n    -----------------------------------------------\n \n-   type Check_Id is\n-     (Access_Check,\n-      Accessibility_Check,\n-      Alignment_Check,\n-      Discriminant_Check,\n-      Division_Check,\n-      Elaboration_Check,\n-      Index_Check,\n-      Length_Check,\n-      Overflow_Check,\n-      Range_Check,\n-      Storage_Check,\n-      Tag_Check,\n-      Validity_Check,\n-      All_Checks);\n+   type Check_Id is new Nat;\n+   --  Type used to represent a check id\n+\n+   No_Check_Id         : constant := 0;\n+   --  Check_Id value used to indicate no check\n+\n+   Access_Check        : constant :=  1;\n+   Accessibility_Check : constant :=  2;\n+   Alignment_Check     : constant :=  3;\n+   Discriminant_Check  : constant :=  4;\n+   Division_Check      : constant :=  5;\n+   Elaboration_Check   : constant :=  6;\n+   Index_Check         : constant :=  7;\n+   Length_Check        : constant :=  8;\n+   Overflow_Check      : constant :=  9;\n+   Range_Check         : constant := 10;\n+   Storage_Check       : constant := 11;\n+   Tag_Check           : constant := 12;\n+   Validity_Check      : constant := 13;\n+   --  Values used to represent individual predefined checks\n+\n+   All_Checks          : constant := 14;\n+   --  Value used to represent All_Checks value\n+\n+   subtype Predefined_Check_Id is Check_Id range 1 .. All_Checks;\n+   --  Subtype for predefined checks, including All_Checks\n \n    --  The following array contains an entry for each recognized check name\n    --  for pragma Suppress. It is used to represent current settings of scope\n@@ -672,7 +683,7 @@ package Types is\n    --  We recognize only an explicit suppress of Elaboration_Check as a signal\n    --  that the static elaboration checking should skip a compile time check.\n \n-   type Suppress_Array is array (Check_Id) of Boolean;\n+   type Suppress_Array is array (Predefined_Check_Id) of Boolean;\n    pragma Pack (Suppress_Array);\n \n    --  To add a new check type to GNAT, the following steps are required:\n@@ -691,19 +702,19 @@ package Types is\n    --  throughout the compiler or in other GNAT tools.\n \n    Unrecoverable_Error : exception;\n-   --  This exception is raised to immediately terminate the compilation\n-   --  of the current source program. Used in situations where things are\n-   --  bad enough that it doesn't seem worth continuing (e.g. max errors\n-   --  reached, or a required file is not found). Also raised when the\n-   --  compiler finds itself in trouble after an error (see Comperr).\n+   --  This exception is raised to immediately terminate the compilation of the\n+   --  current source program. Used in situations where things are bad enough\n+   --  that it doesn't seem worth continuing (e.g. max errors reached, or a\n+   --  required file is not found). Also raised when the compiler finds itself\n+   --  in trouble after an error (see Comperr).\n \n    Terminate_Program : exception;\n    --  This exception is raised to immediately terminate the tool being\n-   --  executed. Each tool where this exception may be raised must have\n-   --  a single exception handler that contains only a null statement and\n-   --  that is the last statement of the program. If needed, procedure\n-   --  Set_Exit_Status is called with the appropriate exit status before\n-   --  raising Terminate_Program.\n+   --  executed. Each tool where this exception may be raised must have a\n+   --  single exception handler that contains only a null statement and that is\n+   --  the last statement of the program. If needed, procedure Set_Exit_Status\n+   --  is called with the appropriate exit status before raising\n+   --  Terminate_Program.\n \n    ---------------------------------\n    -- Parameter Mechanism Control --\n@@ -722,10 +733,10 @@ package Types is\n    -- Run-Time Exception Codes --\n    ------------------------------\n \n-   --  When the code generator generates a run-time exception, it provides\n-   --  a reason code which is one of the following. This reason code is used\n-   --  to select the appropriate run-time routine to be called, determining\n-   --  both the exception to be raised, and the message text to be added.\n+   --  When the code generator generates a run-time exception, it provides a\n+   --  reason code which is one of the following. This reason code is used to\n+   --  select the appropriate run-time routine to be called, determining both\n+   --  the exception to be raised, and the message text to be added.\n \n    --  The prefix CE/PE/SE indicates the exception to be raised\n    --    CE = Constraint_Error"}]}