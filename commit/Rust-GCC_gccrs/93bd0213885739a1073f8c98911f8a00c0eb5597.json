{"sha": "93bd0213885739a1073f8c98911f8a00c0eb5597", "node_id": "C_kwDOANBUbNoAKDkzYmQwMjEzODg1NzM5YTEwNzNmOGM5ODkxMWY4YTAwYzBlYjU1OTc", "commit": {"author": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2021-10-18T13:55:22Z"}, "committer": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2021-10-19T14:09:01Z"}, "message": "Refactor vect_supportable_dr_alignment\n\nThis refactors vect_supportable_dr_alignment to get the misalignment\nas input parameter which allows us to elide modifying/restoring\nof DR_MISALIGNMENT during alignment peeling analysis which eventually\nmakes it more straight-forward to split out the negative step\nhandling.\n\n2021-10-19  Richard Biener  <rguenther@suse.de>\n\n\t* tree-vectorizer.h (vect_supportable_dr_alignment): Add\n\tmisalignment parameter.\n\t* tree-vect-data-refs.c (vect_get_peeling_costs_all_drs):\n\tDo not change DR_MISALIGNMENT in place, instead pass the\n\tadjusted misalignment to vect_supportable_dr_alignment.\n\t(vect_peeling_supportable): Likewise.\n\t(vect_peeling_hash_get_lowest_cost): Adjust.\n\t(vect_enhance_data_refs_alignment): Likewise.\n\t(vect_vfa_access_size): Likewise.\n\t(vect_supportable_dr_alignment): Add misalignment\n\tparameter and simplify.\n\t* tree-vect-stmts.c (get_negative_load_store_type): Adjust.\n\t(get_group_load_store_type): Likewise.\n\t(get_load_store_type): Likewise.", "tree": {"sha": "64e1e20c84b9ed5128131476933af6b6d2234d14", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/64e1e20c84b9ed5128131476933af6b6d2234d14"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/93bd0213885739a1073f8c98911f8a00c0eb5597", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/93bd0213885739a1073f8c98911f8a00c0eb5597", "html_url": "https://github.com/Rust-GCC/gccrs/commit/93bd0213885739a1073f8c98911f8a00c0eb5597", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/93bd0213885739a1073f8c98911f8a00c0eb5597/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5a8832b1659e311437d25b7ec8b078be27ae54b8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5a8832b1659e311437d25b7ec8b078be27ae54b8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5a8832b1659e311437d25b7ec8b078be27ae54b8"}], "stats": {"total": 141, "additions": 85, "deletions": 56}, "files": [{"sha": "556ae9725f13c653054d397dbcc0fb1c8a629ba9", "filename": "gcc/tree-vect-data-refs.c", "status": "modified", "additions": 70, "deletions": 43, "changes": 113, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/93bd0213885739a1073f8c98911f8a00c0eb5597/gcc%2Ftree-vect-data-refs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/93bd0213885739a1073f8c98911f8a00c0eb5597/gcc%2Ftree-vect-data-refs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-data-refs.c?ref=93bd0213885739a1073f8c98911f8a00c0eb5597", "patch": "@@ -1529,37 +1529,49 @@ vect_get_peeling_costs_all_drs (loop_vec_info loop_vinfo,\n \t\t\t\tunsigned int *outside_cost,\n \t\t\t\tstmt_vector_for_cost *body_cost_vec,\n \t\t\t\tstmt_vector_for_cost *prologue_cost_vec,\n-\t\t\t\tunsigned int npeel,\n-\t\t\t\tbool unknown_misalignment)\n+\t\t\t\tunsigned int npeel)\n {\n   vec<data_reference_p> datarefs = LOOP_VINFO_DATAREFS (loop_vinfo);\n \n+  bool dr0_alignment_known_p\n+    = (dr0_info\n+       && known_alignment_for_access_p (dr0_info,\n+\t\t\t\t\tSTMT_VINFO_VECTYPE (dr0_info->stmt)));\n+\n   for (data_reference *dr : datarefs)\n     {\n       dr_vec_info *dr_info = loop_vinfo->lookup_dr (dr);\n       if (!vect_relevant_for_alignment_p (dr_info))\n \tcontinue;\n \n-      int save_misalignment;\n-      save_misalignment = dr_info->misalignment;\n+      tree vectype = STMT_VINFO_VECTYPE (dr_info->stmt);\n+      dr_alignment_support alignment_support_scheme;\n+      int misalignment;\n+      unsigned HOST_WIDE_INT alignment;\n+\n       if (npeel == 0)\n-\t;\n-      else if (unknown_misalignment && dr_info == dr0_info)\n-\tSET_DR_MISALIGNMENT (dr_info,\n-\t\t\t     vect_dr_misalign_for_aligned_access (dr0_info));\n+\tmisalignment = dr_misalignment (dr_info, vectype);\n+      else if (dr_info == dr0_info\n+\t       || vect_dr_aligned_if_peeled_dr_is (dr_info, dr0_info))\n+\tmisalignment = 0;\n+      else if (!dr0_alignment_known_p\n+\t       || !known_alignment_for_access_p (dr_info, vectype)\n+\t       || !DR_TARGET_ALIGNMENT (dr_info).is_constant (&alignment))\n+\tmisalignment = DR_MISALIGNMENT_UNKNOWN;\n       else\n-\tvect_update_misalignment_for_peel (dr_info, dr0_info, npeel);\n-      /* ???  We should be able to avoid both the adjustment before and the\n-\t call to vect_supportable_dr_alignment below.  */\n-      tree vectype = STMT_VINFO_VECTYPE (dr_info->stmt);\n-      int misalignment = dr_misalignment (dr_info, vectype);\n-      dr_alignment_support alignment_support_scheme\n-\t= vect_supportable_dr_alignment (loop_vinfo, dr_info, vectype);\n+\t{\n+\t  misalignment = dr_misalignment (dr_info, vectype);\n+\t  misalignment += npeel * TREE_INT_CST_LOW (DR_STEP (dr_info->dr));\n+\t  misalignment &= alignment - 1;\n+\t}\n+      alignment_support_scheme\n+\t= vect_supportable_dr_alignment (loop_vinfo, dr_info, vectype,\n+\t\t\t\t\t misalignment);\n+\n       vect_get_data_access_cost (loop_vinfo, dr_info,\n \t\t\t\t alignment_support_scheme, misalignment,\n \t\t\t\t inside_cost, outside_cost,\n \t\t\t\t body_cost_vec, prologue_cost_vec);\n-      SET_DR_MISALIGNMENT (dr_info, save_misalignment);\n     }\n }\n \n@@ -1583,7 +1595,7 @@ vect_peeling_hash_get_lowest_cost (_vect_peel_info **slot,\n \n   vect_get_peeling_costs_all_drs (loop_vinfo, elem->dr_info, &inside_cost,\n \t\t\t\t  &outside_cost, &body_cost_vec,\n-\t\t\t\t  &prologue_cost_vec, elem->npeel, false);\n+\t\t\t\t  &prologue_cost_vec, elem->npeel);\n \n   body_cost_vec.release ();\n \n@@ -1655,25 +1667,37 @@ vect_peeling_supportable (loop_vec_info loop_vinfo, dr_vec_info *dr0_info,\n   vec<data_reference_p> datarefs = LOOP_VINFO_DATAREFS (loop_vinfo);\n   enum dr_alignment_support supportable_dr_alignment;\n \n+  bool dr0_alignment_known_p\n+    = known_alignment_for_access_p (dr0_info,\n+\t\t\t\t    STMT_VINFO_VECTYPE (dr0_info->stmt));\n+\n   /* Ensure that all data refs can be vectorized after the peel.  */\n   for (data_reference *dr : datarefs)\n     {\n-      int save_misalignment;\n-\n       if (dr == dr0_info->dr)\n \tcontinue;\n \n       dr_vec_info *dr_info = loop_vinfo->lookup_dr (dr);\n-      if (!vect_relevant_for_alignment_p (dr_info))\n+      if (!vect_relevant_for_alignment_p (dr_info)\n+\t  || vect_dr_aligned_if_peeled_dr_is (dr_info, dr0_info))\n \tcontinue;\n \n-      save_misalignment = dr_info->misalignment;\n-      vect_update_misalignment_for_peel (dr_info, dr0_info, npeel);\n       tree vectype = STMT_VINFO_VECTYPE (dr_info->stmt);\n+      int misalignment;\n+      unsigned HOST_WIDE_INT alignment;\n+      if (!dr0_alignment_known_p\n+\t  || !known_alignment_for_access_p (dr_info, vectype)\n+\t  || !DR_TARGET_ALIGNMENT (dr_info).is_constant (&alignment))\n+\tmisalignment = DR_MISALIGNMENT_UNKNOWN;\n+      else\n+\t{\n+\t  misalignment = dr_misalignment (dr_info, vectype);\n+\t  misalignment += npeel * TREE_INT_CST_LOW (DR_STEP (dr_info->dr));\n+\t  misalignment &= alignment - 1;\n+\t}\n       supportable_dr_alignment\n-\t= vect_supportable_dr_alignment (loop_vinfo, dr_info, vectype);\n-      SET_DR_MISALIGNMENT (dr_info, save_misalignment);\n-\n+\t= vect_supportable_dr_alignment (loop_vinfo, dr_info, vectype,\n+\t\t\t\t\t misalignment);\n       if (supportable_dr_alignment == dr_unaligned_unsupported)\n \treturn false;\n     }\n@@ -2017,7 +2041,8 @@ vect_enhance_data_refs_alignment (loop_vec_info loop_vinfo)\n \t      /* Check for data refs with unsupportable alignment that\n \t         can be peeled.  */\n \t      enum dr_alignment_support supportable_dr_alignment\n-\t\t= vect_supportable_dr_alignment (loop_vinfo, dr_info, vectype);\n+\t\t= vect_supportable_dr_alignment (loop_vinfo, dr_info, vectype,\n+\t\t\t\t\t\t DR_MISALIGNMENT_UNKNOWN);\n \t      if (supportable_dr_alignment == dr_unaligned_unsupported)\n \t\t{\n \t\t  one_dr_unsupportable = true;\n@@ -2074,7 +2099,7 @@ vect_enhance_data_refs_alignment (loop_vec_info loop_vinfo)\n       vect_get_peeling_costs_all_drs (loop_vinfo, dr0_info,\n \t\t\t\t      &load_inside_cost,\n \t\t\t\t      &load_outside_cost,\n-\t\t\t\t      &dummy, &dummy, estimated_npeels, true);\n+\t\t\t\t      &dummy, &dummy, estimated_npeels);\n       dummy.release ();\n \n       if (first_store)\n@@ -2084,7 +2109,7 @@ vect_enhance_data_refs_alignment (loop_vec_info loop_vinfo)\n \t\t\t\t\t  &store_inside_cost,\n \t\t\t\t\t  &store_outside_cost,\n \t\t\t\t\t  &dummy, &dummy,\n-\t\t\t\t\t  estimated_npeels, true);\n+\t\t\t\t\t  estimated_npeels);\n \t  dummy.release ();\n \t}\n       else\n@@ -2172,8 +2197,7 @@ vect_enhance_data_refs_alignment (loop_vec_info loop_vinfo)\n       stmt_vector_for_cost dummy;\n       dummy.create (2);\n       vect_get_peeling_costs_all_drs (loop_vinfo, NULL, &nopeel_inside_cost,\n-\t\t\t\t      &nopeel_outside_cost, &dummy, &dummy,\n-\t\t\t\t      0, false);\n+\t\t\t\t      &nopeel_outside_cost, &dummy, &dummy, 0);\n       dummy.release ();\n \n       /* Add epilogue costs.  As we do not peel for alignment here, no prologue\n@@ -2362,7 +2386,8 @@ vect_enhance_data_refs_alignment (loop_vec_info loop_vinfo)\n \t  dr_vec_info *dr_info = loop_vinfo->lookup_dr (dr);\n \t  stmt_vec_info stmt_info = dr_info->stmt;\n \t  tree vectype = STMT_VINFO_VECTYPE (stmt_info);\n-\t  if (aligned_access_p (dr_info, vectype)\n+\t  int misalignment;\n+\t  if ((misalignment = dr_misalignment (dr_info, vectype)) == 0\n \t      || !vect_relevant_for_alignment_p (dr_info))\n \t    continue;\n \n@@ -2373,12 +2398,13 @@ vect_enhance_data_refs_alignment (loop_vec_info loop_vinfo)\n \t    }\n \n \t  enum dr_alignment_support supportable_dr_alignment\n-\t    = vect_supportable_dr_alignment (loop_vinfo, dr_info, vectype);\n+\t    = vect_supportable_dr_alignment (loop_vinfo, dr_info, vectype,\n+\t\t\t\t\t     misalignment);\n \t  if (supportable_dr_alignment == dr_unaligned_unsupported)\n             {\n-\t      if (known_alignment_for_access_p (dr_info, vectype)\n-                  || LOOP_VINFO_MAY_MISALIGN_STMTS (loop_vinfo).length ()\n-\t\t  >= (unsigned) param_vect_max_version_for_alignment_checks)\n+\t      if (misalignment != DR_MISALIGNMENT_UNKNOWN\n+\t\t  || (LOOP_VINFO_MAY_MISALIGN_STMTS (loop_vinfo).length ()\n+\t\t      >= (unsigned) param_vect_max_version_for_alignment_checks))\n                 {\n                   do_versioning = false;\n                   break;\n@@ -3321,8 +3347,10 @@ vect_vfa_access_size (vec_info *vinfo, dr_vec_info *dr_info)\n       access_size *= DR_GROUP_SIZE (stmt_vinfo) - DR_GROUP_GAP (stmt_vinfo);\n     }\n   tree vectype = STMT_VINFO_VECTYPE (stmt_vinfo);\n+  int misalignment;\n   if (STMT_VINFO_VEC_STMTS (stmt_vinfo).exists ()\n-      && (vect_supportable_dr_alignment (vinfo, dr_info, vectype)\n+      && ((misalignment = dr_misalignment (dr_info, vectype)), true)\n+      && (vect_supportable_dr_alignment (vinfo, dr_info, vectype, misalignment)\n \t  == dr_explicit_realign_optimized))\n     {\n       /* We might access a full vector's worth.  */\n@@ -6638,7 +6666,6 @@ vect_can_force_dr_alignment_p (const_tree decl, poly_uint64 alignment)\n     return (known_le (alignment, (unsigned HOST_WIDE_INT) MAX_STACK_ALIGNMENT));\n }\n \n-\n /* Return whether the data reference DR_INFO is supported with respect to its\n    alignment.\n    If CHECK_ALIGNED_ACCESSES is TRUE, check if the access is supported even\n@@ -6647,7 +6674,7 @@ vect_can_force_dr_alignment_p (const_tree decl, poly_uint64 alignment)\n \n enum dr_alignment_support\n vect_supportable_dr_alignment (vec_info *vinfo, dr_vec_info *dr_info,\n-\t\t\t       tree vectype)\n+\t\t\t       tree vectype, int misalignment)\n {\n   data_reference *dr = dr_info->dr;\n   stmt_vec_info stmt_info = dr_info->stmt;\n@@ -6656,7 +6683,7 @@ vect_supportable_dr_alignment (vec_info *vinfo, dr_vec_info *dr_info,\n   class loop *vect_loop = NULL;\n   bool nested_in_vect_loop = false;\n \n-  if (aligned_access_p (dr_info, vectype))\n+  if (misalignment == 0)\n     return dr_aligned;\n \n   /* For now assume all conditional loads/stores support unaligned\n@@ -6762,11 +6789,11 @@ vect_supportable_dr_alignment (vec_info *vinfo, dr_vec_info *dr_info,\n     }\n \n   bool is_packed = false;\n-  tree type = (TREE_TYPE (DR_REF (dr)));\n-  if (!known_alignment_for_access_p (dr_info, vectype))\n+  tree type = TREE_TYPE (DR_REF (dr));\n+  if (misalignment == DR_MISALIGNMENT_UNKNOWN)\n     is_packed = not_size_aligned (DR_REF (dr));\n-  if (targetm.vectorize.support_vector_misalignment\n-\t(mode, type, dr_misalignment (dr_info, vectype), is_packed))\n+  if (targetm.vectorize.support_vector_misalignment (mode, type, misalignment,\n+\t\t\t\t\t\t     is_packed))\n     return dr_unaligned_supported;\n \n   /* Unsupported.  */"}, {"sha": "9cbc1af4cc913d07c32f953986159fecea6942e5", "filename": "gcc/tree-vect-stmts.c", "status": "modified", "additions": 14, "deletions": 12, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/93bd0213885739a1073f8c98911f8a00c0eb5597/gcc%2Ftree-vect-stmts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/93bd0213885739a1073f8c98911f8a00c0eb5597/gcc%2Ftree-vect-stmts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-stmts.c?ref=93bd0213885739a1073f8c98911f8a00c0eb5597", "patch": "@@ -1986,8 +1986,9 @@ get_negative_load_store_type (vec_info *vinfo,\n       return VMAT_ELEMENTWISE;\n     }\n \n-  alignment_support_scheme = vect_supportable_dr_alignment (vinfo, dr_info,\n-\t\t\t\t\t\t\t    vectype);\n+  int misalignment = dr_misalignment (dr_info, vectype);\n+  alignment_support_scheme\n+    = vect_supportable_dr_alignment (vinfo, dr_info, vectype, misalignment);\n   if (alignment_support_scheme != dr_aligned\n       && alignment_support_scheme != dr_unaligned_supported)\n     {\n@@ -2184,15 +2185,15 @@ get_group_load_store_type (vec_info *vinfo, stmt_vec_info stmt_info,\n \t     can do half-vector operations avoid the epilogue peeling\n \t     by simply loading half of the vector only.  Usually\n \t     the construction with an upper zero half will be elided.  */\n-\t  dr_alignment_support alignment_support_scheme;\n+\t  dr_alignment_support alss;\n+\t  int misalign = dr_misalignment (first_dr_info, vectype);\n \t  tree half_vtype;\n \t  if (overrun_p\n \t      && !masked_p\n-\t      && (((alignment_support_scheme\n-\t\t      = vect_supportable_dr_alignment (vinfo, first_dr_info,\n-\t\t\t\t\t\t       vectype)))\n+\t      && (((alss = vect_supportable_dr_alignment (vinfo, first_dr_info,\n+\t\t\t\t\t\t\t  vectype, misalign)))\n \t\t   == dr_aligned\n-\t\t  || alignment_support_scheme == dr_unaligned_supported)\n+\t\t  || alss == dr_unaligned_supported)\n \t      && known_eq (nunits, (group_size - gap) * 2)\n \t      && known_eq (nunits, group_size)\n \t      && (vector_vector_composition_type (vectype, 2, &half_vtype)\n@@ -2304,9 +2305,10 @@ get_group_load_store_type (vec_info *vinfo, stmt_vec_info stmt_info,\n     }\n   else\n     {\n-      *alignment_support_scheme\n-\t= vect_supportable_dr_alignment (vinfo, first_dr_info, vectype);\n       *misalignment = dr_misalignment (first_dr_info, vectype);\n+      *alignment_support_scheme\n+\t= vect_supportable_dr_alignment (vinfo, first_dr_info, vectype,\n+\t\t\t\t\t *misalignment);\n     }\n \n   if (vls_type != VLS_LOAD && first_stmt_info == stmt_info)\n@@ -2452,12 +2454,12 @@ get_load_store_type (vec_info  *vinfo, stmt_vec_info stmt_info,\n \t       (vinfo, stmt_info, vectype, vls_type, ncopies, poffset);\n \t  else\n \t    *memory_access_type = VMAT_CONTIGUOUS;\n+\t  *misalignment = dr_misalignment (STMT_VINFO_DR_INFO (stmt_info),\n+\t\t\t\t\t   vectype);\n \t  *alignment_support_scheme\n \t    = vect_supportable_dr_alignment (vinfo,\n \t\t\t\t\t     STMT_VINFO_DR_INFO (stmt_info),\n-\t\t\t\t\t     vectype);\n-\t  *misalignment = dr_misalignment (STMT_VINFO_DR_INFO (stmt_info),\n-\t\t\t\t\t   vectype);\n+\t\t\t\t\t     vectype, *misalignment);\n \t}\n     }\n "}, {"sha": "866d813a12c5df42b53e5f0770fdc76e9e8b471e", "filename": "gcc/tree-vectorizer.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/93bd0213885739a1073f8c98911f8a00c0eb5597/gcc%2Ftree-vectorizer.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/93bd0213885739a1073f8c98911f8a00c0eb5597/gcc%2Ftree-vectorizer.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vectorizer.h?ref=93bd0213885739a1073f8c98911f8a00c0eb5597", "patch": "@@ -1980,7 +1980,7 @@ extern opt_tree vect_get_mask_type_for_stmt (stmt_vec_info, unsigned int = 0);\n /* In tree-vect-data-refs.c.  */\n extern bool vect_can_force_dr_alignment_p (const_tree, poly_uint64);\n extern enum dr_alignment_support vect_supportable_dr_alignment\n-\t\t\t\t   (vec_info *, dr_vec_info *, tree);\n+\t\t\t\t   (vec_info *, dr_vec_info *, tree, int);\n extern tree vect_get_smallest_scalar_type (stmt_vec_info, tree);\n extern opt_result vect_analyze_data_ref_dependences (loop_vec_info, unsigned int *);\n extern bool vect_slp_analyze_instance_dependence (vec_info *, slp_instance);"}]}