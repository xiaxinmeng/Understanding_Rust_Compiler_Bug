{"sha": "e8f142e28262a5048c6f40f4bfb6a612d3da55f0", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZThmMTQyZTI4MjYyYTUwNDhjNmY0MGY0YmZiNmE2MTJkM2RhNTVmMA==", "commit": {"author": {"name": "Richard Sandiford", "email": "richard.sandiford@linaro.org", "date": "2017-09-14T16:30:36Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2017-09-14T16:30:36Z"}, "message": "Add a vect_get_num_copies helper routine\n\nThis patch adds a vectoriser helper routine to calculate how\nmany copies of a vector statement we need.  At present this\nis always:\n\n  LOOP_VINFO_VECT_FACTOR (loop_vinfo) / TYPE_VECTOR_SUBPARTS (vectype)\n\nbut later patches add other cases.  Another benefit of using\na helper routine is that it can assert that the division is\nexact (which it must be).\n\n2017-09-14  Richard Sandiford  <richard.sandiford@linaro.org>\n\t    Alan Hayward  <alan.hayward@arm.com>\n\t    David Sherwood  <david.sherwood@arm.com>\n\ngcc/\n\t* tree-vectorizer.h (vect_get_num_copies): New function.\n\t* tree-vect-data-refs.c (vect_get_data_access_cost): Use it.\n\t* tree-vect-loop.c (vectorizable_reduction): Likewise.\n\t(vectorizable_induction): Likewise.\n\t(vectorizable_live_operation): Likewise.\n\t* tree-vect-stmts.c (vectorizable_mask_load_store): Likewise.\n\t(vectorizable_bswap): Likewise.\n\t(vectorizable_call): Likewise.\n\t(vectorizable_conversion): Likewise.\n\t(vectorizable_assignment): Likewise.\n\t(vectorizable_shift): Likewise.\n\t(vectorizable_operation): Likewise.\n\t(vectorizable_store): Likewise.\n\t(vectorizable_load): Likewise.\n\t(vectorizable_condition): Likewise.\n\t(vectorizable_comparison): Likewise.\n\t(vect_analyze_stmt): Pass the slp node to vectorizable_live_operation.\n\nCo-Authored-By: Alan Hayward <alan.hayward@arm.com>\nCo-Authored-By: David Sherwood <david.sherwood@arm.com>\n\nFrom-SVN: r252764", "tree": {"sha": "be4373fc3725870e0d59bf2eddb56c9874962e4d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/be4373fc3725870e0d59bf2eddb56c9874962e4d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e8f142e28262a5048c6f40f4bfb6a612d3da55f0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e8f142e28262a5048c6f40f4bfb6a612d3da55f0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e8f142e28262a5048c6f40f4bfb6a612d3da55f0", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e8f142e28262a5048c6f40f4bfb6a612d3da55f0/comments", "author": null, "committer": null, "parents": [{"sha": "dccf43aed37281a7bb91a7984a75470ad62eb0f1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dccf43aed37281a7bb91a7984a75470ad62eb0f1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/dccf43aed37281a7bb91a7984a75470ad62eb0f1"}], "stats": {"total": 89, "additions": 65, "deletions": 24}, "files": [{"sha": "8c30dea3a10cbccb33f4a12d60828b06b92e2c5f", "filename": "gcc/ChangeLog", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e8f142e28262a5048c6f40f4bfb6a612d3da55f0/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e8f142e28262a5048c6f40f4bfb6a612d3da55f0/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=e8f142e28262a5048c6f40f4bfb6a612d3da55f0", "patch": "@@ -1,3 +1,25 @@\n+2017-09-14  Richard Sandiford  <richard.sandiford@linaro.org>\n+\t    Alan Hayward  <alan.hayward@arm.com>\n+\t    David Sherwood  <david.sherwood@arm.com>\n+\n+\t* tree-vectorizer.h (vect_get_num_copies): New function.\n+\t* tree-vect-data-refs.c (vect_get_data_access_cost): Use it.\n+\t* tree-vect-loop.c (vectorizable_reduction): Likewise.\n+\t(vectorizable_induction): Likewise.\n+\t(vectorizable_live_operation): Likewise.\n+\t* tree-vect-stmts.c (vectorizable_mask_load_store): Likewise.\n+\t(vectorizable_bswap): Likewise.\n+\t(vectorizable_call): Likewise.\n+\t(vectorizable_conversion): Likewise.\n+\t(vectorizable_assignment): Likewise.\n+\t(vectorizable_shift): Likewise.\n+\t(vectorizable_operation): Likewise.\n+\t(vectorizable_store): Likewise.\n+\t(vectorizable_load): Likewise.\n+\t(vectorizable_condition): Likewise.\n+\t(vectorizable_comparison): Likewise.\n+\t(vect_analyze_stmt): Pass the slp node to vectorizable_live_operation.\n+\n 2017-09-14  Richard Sandiford  <richard.sandiford@linaro.org>\n \t    Alan Hayward  <alan.hayward@arm.com>\n \t    David Sherwood  <david.sherwood@arm.com>"}, {"sha": "a6969791bb2e181ca5aa6920dc756bc82479c0db", "filename": "gcc/tree-vect-data-refs.c", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e8f142e28262a5048c6f40f4bfb6a612d3da55f0/gcc%2Ftree-vect-data-refs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e8f142e28262a5048c6f40f4bfb6a612d3da55f0/gcc%2Ftree-vect-data-refs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-data-refs.c?ref=e8f142e28262a5048c6f40f4bfb6a612d3da55f0", "patch": "@@ -1181,10 +1181,13 @@ vect_get_data_access_cost (struct data_reference *dr,\n {\n   gimple *stmt = DR_STMT (dr);\n   stmt_vec_info stmt_info = vinfo_for_stmt (stmt);\n-  int nunits = TYPE_VECTOR_SUBPARTS (STMT_VINFO_VECTYPE (stmt_info));\n   loop_vec_info loop_vinfo = STMT_VINFO_LOOP_VINFO (stmt_info);\n-  int vf = LOOP_VINFO_VECT_FACTOR (loop_vinfo);\n-  int ncopies = MAX (1, vf / nunits); /* TODO: Handle SLP properly  */\n+  int ncopies;\n+\n+  if (PURE_SLP_STMT (stmt_info))\n+    ncopies = 1;\n+  else\n+    ncopies = vect_get_num_copies (loop_vinfo, STMT_VINFO_VECTYPE (stmt_info));\n \n   if (DR_IS_READ (dr))\n     vect_get_load_cost (dr, ncopies, true, inside_cost, outside_cost,"}, {"sha": "af730139612345da889fe314a42c8ac5b1538e18", "filename": "gcc/tree-vect-loop.c", "status": "modified", "additions": 9, "deletions": 6, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e8f142e28262a5048c6f40f4bfb6a612d3da55f0/gcc%2Ftree-vect-loop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e8f142e28262a5048c6f40f4bfb6a612d3da55f0/gcc%2Ftree-vect-loop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-loop.c?ref=e8f142e28262a5048c6f40f4bfb6a612d3da55f0", "patch": "@@ -5683,8 +5683,7 @@ vectorizable_reduction (gimple *stmt, gimple_stmt_iterator *gsi,\n       if (slp_node)\n \tncopies = 1;\n       else\n-\tncopies = (LOOP_VINFO_VECT_FACTOR (loop_vinfo)\n-\t\t   / TYPE_VECTOR_SUBPARTS (vectype_in));\n+\tncopies = vect_get_num_copies (loop_vinfo, vectype_in);\n \n       use_operand_p use_p;\n       gimple *use_stmt;\n@@ -5980,8 +5979,7 @@ vectorizable_reduction (gimple *stmt, gimple_stmt_iterator *gsi,\n   if (slp_node)\n     ncopies = 1;\n   else\n-    ncopies = (LOOP_VINFO_VECT_FACTOR (loop_vinfo)\n-               / TYPE_VECTOR_SUBPARTS (vectype_in));\n+    ncopies = vect_get_num_copies (loop_vinfo, vectype_in);\n \n   gcc_assert (ncopies >= 1);\n \n@@ -6550,7 +6548,7 @@ vectorizable_induction (gimple *phi,\n   if (slp_node)\n     ncopies = 1;\n   else\n-    ncopies = vf / nunits;\n+    ncopies = vect_get_num_copies (loop_vinfo, vectype);\n   gcc_assert (ncopies >= 1);\n \n   /* FORNOW. These restrictions should be relaxed.  */\n@@ -7013,12 +7011,17 @@ vectorizable_live_operation (gimple *stmt,\n   tree lhs, lhs_type, bitsize, vec_bitsize;\n   tree vectype = STMT_VINFO_VECTYPE (stmt_info);\n   int nunits = TYPE_VECTOR_SUBPARTS (vectype);\n-  int ncopies = LOOP_VINFO_VECT_FACTOR (loop_vinfo) / nunits;\n+  int ncopies;\n   gimple *use_stmt;\n   auto_vec<tree> vec_oprnds;\n \n   gcc_assert (STMT_VINFO_LIVE_P (stmt_info));\n \n+  if (slp_node)\n+    ncopies = 1;\n+  else\n+    ncopies = vect_get_num_copies (loop_vinfo, vectype);\n+\n   if (STMT_VINFO_DEF_TYPE (stmt_info) == vect_reduction_def)\n     return false;\n "}, {"sha": "4244e28110fcddcf352af0ce8d4f4275210399ee", "filename": "gcc/tree-vect-stmts.c", "status": "modified", "additions": 14, "deletions": 15, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e8f142e28262a5048c6f40f4bfb6a612d3da55f0/gcc%2Ftree-vect-stmts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e8f142e28262a5048c6f40f4bfb6a612d3da55f0/gcc%2Ftree-vect-stmts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-stmts.c?ref=e8f142e28262a5048c6f40f4bfb6a612d3da55f0", "patch": "@@ -2038,7 +2038,7 @@ vectorizable_mask_load_store (gimple *stmt, gimple_stmt_iterator *gsi,\n   if (slp_node != NULL)\n     return false;\n \n-  ncopies = LOOP_VINFO_VECT_FACTOR (loop_vinfo) / nunits;\n+  ncopies = vect_get_num_copies (loop_vinfo, vectype);\n   gcc_assert (ncopies >= 1);\n \n   mask = gimple_call_arg (stmt, 2);\n@@ -2472,7 +2472,7 @@ vectorizable_bswap (gimple *stmt, gimple_stmt_iterator *gsi,\n   if (slp_node)\n     ncopies = 1;\n   else\n-    ncopies = LOOP_VINFO_VECT_FACTOR (loop_vinfo) / nunits;\n+    ncopies = vect_get_num_copies (loop_vinfo, vectype);\n \n   gcc_assert (ncopies >= 1);\n \n@@ -2805,9 +2805,9 @@ vectorizable_call (gimple *gs, gimple_stmt_iterator *gsi, gimple **vec_stmt,\n   if (slp_node)\n     ncopies = 1;\n   else if (modifier == NARROW && ifn == IFN_LAST)\n-    ncopies = LOOP_VINFO_VECT_FACTOR (loop_vinfo) / nunits_out;\n+    ncopies = vect_get_num_copies (loop_vinfo, vectype_out);\n   else\n-    ncopies = LOOP_VINFO_VECT_FACTOR (loop_vinfo) / nunits_in;\n+    ncopies = vect_get_num_copies (loop_vinfo, vectype_in);\n \n   /* Sanity check: make sure that at least one copy of the vectorized stmt\n      needs to be generated.  */\n@@ -4204,9 +4204,9 @@ vectorizable_conversion (gimple *stmt, gimple_stmt_iterator *gsi,\n   if (slp_node)\n     ncopies = 1;\n   else if (modifier == NARROW)\n-    ncopies = LOOP_VINFO_VECT_FACTOR (loop_vinfo) / nunits_out;\n+    ncopies = vect_get_num_copies (loop_vinfo, vectype_out);\n   else\n-    ncopies = LOOP_VINFO_VECT_FACTOR (loop_vinfo) / nunits_in;\n+    ncopies = vect_get_num_copies (loop_vinfo, vectype_in);\n \n   /* Sanity check: make sure that at least one copy of the vectorized stmt\n      needs to be generated.  */\n@@ -4690,7 +4690,7 @@ vectorizable_assignment (gimple *stmt, gimple_stmt_iterator *gsi,\n   if (slp_node)\n     ncopies = 1;\n   else\n-    ncopies = LOOP_VINFO_VECT_FACTOR (loop_vinfo) / nunits;\n+    ncopies = vect_get_num_copies (loop_vinfo, vectype);\n \n   gcc_assert (ncopies >= 1);\n \n@@ -4948,7 +4948,7 @@ vectorizable_shift (gimple *stmt, gimple_stmt_iterator *gsi,\n   if (slp_node)\n     ncopies = 1;\n   else\n-    ncopies = LOOP_VINFO_VECT_FACTOR (loop_vinfo) / nunits_in;\n+    ncopies = vect_get_num_copies (loop_vinfo, vectype);\n \n   gcc_assert (ncopies >= 1);\n \n@@ -5379,7 +5379,7 @@ vectorizable_operation (gimple *stmt, gimple_stmt_iterator *gsi,\n   if (slp_node)\n     ncopies = 1;\n   else\n-    ncopies = LOOP_VINFO_VECT_FACTOR (loop_vinfo) / nunits_in;\n+    ncopies = vect_get_num_copies (loop_vinfo, vectype);\n \n   gcc_assert (ncopies >= 1);\n \n@@ -5718,7 +5718,7 @@ vectorizable_store (gimple *stmt, gimple_stmt_iterator *gsi, gimple **vec_stmt,\n   if (slp)\n     ncopies = 1;\n   else\n-    ncopies = LOOP_VINFO_VECT_FACTOR (loop_vinfo) / nunits;\n+    ncopies = vect_get_num_copies (loop_vinfo, vectype);\n \n   gcc_assert (ncopies >= 1);\n \n@@ -6713,7 +6713,7 @@ vectorizable_load (gimple *stmt, gimple_stmt_iterator *gsi, gimple **vec_stmt,\n   if (slp)\n     ncopies = 1;\n   else\n-    ncopies = LOOP_VINFO_VECT_FACTOR (loop_vinfo) / nunits;\n+    ncopies = vect_get_num_copies (loop_vinfo, vectype);\n \n   gcc_assert (ncopies >= 1);\n \n@@ -7926,13 +7926,12 @@ vectorizable_condition (gimple *stmt, gimple_stmt_iterator *gsi,\n     return false;\n \n   tree vectype = STMT_VINFO_VECTYPE (stmt_info);\n-  int nunits = TYPE_VECTOR_SUBPARTS (vectype);\n   tree vectype1 = NULL_TREE, vectype2 = NULL_TREE;\n \n   if (slp_node)\n     ncopies = 1;\n   else\n-    ncopies = LOOP_VINFO_VECT_FACTOR (loop_vinfo) / nunits;\n+    ncopies = vect_get_num_copies (loop_vinfo, vectype);\n \n   gcc_assert (ncopies >= 1);\n   if (reduc_index && ncopies > 1)\n@@ -8269,7 +8268,7 @@ vectorizable_comparison (gimple *stmt, gimple_stmt_iterator *gsi,\n   if (slp_node)\n     ncopies = 1;\n   else\n-    ncopies = LOOP_VINFO_VECT_FACTOR (loop_vinfo) / nunits;\n+    ncopies = vect_get_num_copies (loop_vinfo, vectype);\n \n   gcc_assert (ncopies >= 1);\n   if (STMT_VINFO_DEF_TYPE (stmt_info) != vect_internal_def\n@@ -8700,7 +8699,7 @@ vect_analyze_stmt (gimple *stmt, bool *need_to_vectorize, slp_tree node,\n       need extra handling, except for vectorizable reductions.  */\n   if (STMT_VINFO_LIVE_P (stmt_info)\n       && STMT_VINFO_TYPE (stmt_info) != reduc_vec_info_type)\n-    ok = vectorizable_live_operation (stmt, NULL, NULL, -1, NULL);\n+    ok = vectorizable_live_operation (stmt, NULL, node, -1, NULL);\n \n   if (!ok)\n     {"}, {"sha": "6efcd51c0a1ac252f3be443e1e742140bc9d360e", "filename": "gcc/tree-vectorizer.h", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e8f142e28262a5048c6f40f4bfb6a612d3da55f0/gcc%2Ftree-vectorizer.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e8f142e28262a5048c6f40f4bfb6a612d3da55f0/gcc%2Ftree-vectorizer.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vectorizer.h?ref=e8f142e28262a5048c6f40f4bfb6a612d3da55f0", "patch": "@@ -1076,6 +1076,20 @@ unlimited_cost_model (loop_p loop)\n   return (flag_vect_cost_model == VECT_COST_MODEL_UNLIMITED);\n }\n \n+/* Return the number of copies needed for loop vectorization when\n+   a statement operates on vectors of type VECTYPE.  This is the\n+   vectorization factor divided by the number of elements in\n+   VECTYPE and is always known at compile time.  */\n+\n+static inline unsigned int\n+vect_get_num_copies (loop_vec_info loop_vinfo, tree vectype)\n+{\n+  gcc_checking_assert (LOOP_VINFO_VECT_FACTOR (loop_vinfo)\n+\t\t       % TYPE_VECTOR_SUBPARTS (vectype) == 0);\n+  return (LOOP_VINFO_VECT_FACTOR (loop_vinfo)\n+\t  / TYPE_VECTOR_SUBPARTS (vectype));\n+}\n+\n /* Source location */\n extern source_location vect_location;\n "}]}