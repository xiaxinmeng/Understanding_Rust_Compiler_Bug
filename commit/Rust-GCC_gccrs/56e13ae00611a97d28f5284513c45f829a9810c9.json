{"sha": "56e13ae00611a97d28f5284513c45f829a9810c9", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTZlMTNhZTAwNjExYTk3ZDI4ZjUyODQ1MTNjNDVmODI5YTk4MTBjOQ==", "commit": {"author": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2014-01-31T01:58:12Z"}, "committer": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2014-01-31T01:58:12Z"}, "message": "compiler: Use backend interface for conditional expressions.\n\nFrom-SVN: r207330", "tree": {"sha": "9a22219e0d5bdaa944919e195aff19b9098d0600", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/9a22219e0d5bdaa944919e195aff19b9098d0600"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/56e13ae00611a97d28f5284513c45f829a9810c9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/56e13ae00611a97d28f5284513c45f829a9810c9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/56e13ae00611a97d28f5284513c45f829a9810c9", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/56e13ae00611a97d28f5284513c45f829a9810c9/comments", "author": null, "committer": null, "parents": [{"sha": "8fec1e9b781820ae4ccf0946371d8eb27f1b5491", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8fec1e9b781820ae4ccf0946371d8eb27f1b5491", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8fec1e9b781820ae4ccf0946371d8eb27f1b5491"}], "stats": {"total": 104, "additions": 103, "deletions": 1}, "files": [{"sha": "c4230f6b2799f8be6cb2690b29aaee5efda25a43", "filename": "gcc/go/gofrontend/expressions.cc", "status": "modified", "additions": 97, "deletions": 0, "changes": 97, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/56e13ae00611a97d28f5284513c45f829a9810c9/gcc%2Fgo%2Fgofrontend%2Fexpressions.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/56e13ae00611a97d28f5284513c45f829a9810c9/gcc%2Fgo%2Fgofrontend%2Fexpressions.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fexpressions.cc?ref=56e13ae00611a97d28f5284513c45f829a9810c9", "patch": "@@ -15040,6 +15040,103 @@ Expression::make_label_addr(Label* label, Location location)\n   return new Label_addr_expression(label, location);\n }\n \n+// Conditional expressions.\n+\n+class Conditional_expression : public Expression\n+{\n+ public:\n+  Conditional_expression(Expression* cond, Expression* then_expr,\n+                         Expression* else_expr, Location location)\n+      : Expression(EXPRESSION_CONDITIONAL, location),\n+        cond_(cond), then_(then_expr), else_(else_expr)\n+  {}\n+\n+ protected:\n+  Type*\n+  do_type();\n+\n+  void\n+  do_determine_type(const Type_context*)\n+  { }\n+\n+  Expression*\n+  do_copy()\n+  {\n+    return new Conditional_expression(this->cond_->copy(), this->then_->copy(),\n+                                      this->else_->copy(), this->location());\n+  }\n+\n+  tree\n+  do_get_tree(Translate_context* context);\n+\n+  void\n+  do_dump_expression(Ast_dump_context*) const;\n+\n+ private:\n+  // The condition to be checked.\n+  Expression* cond_;\n+  // The expression to execute if the condition is true.\n+  Expression* then_;\n+  // The expression to execute if the condition is false.\n+  Expression* else_;\n+};\n+\n+// Return the type of the conditional expression.\n+\n+Type*\n+Conditional_expression::do_type()\n+{\n+  Type* result_type = Type::make_void_type();\n+  if (this->then_->type() == this->else_->type())\n+    result_type = this->then_->type();\n+  else if (this->then_->is_nil_expression()\n+           || this->else_->is_nil_expression())\n+    result_type = (!this->then_->is_nil_expression()\n+                   ? this->then_->type()\n+                   : this->else_->type());\n+  return result_type;\n+}\n+\n+// Get the backend representation of a conditional expression.\n+\n+tree\n+Conditional_expression::do_get_tree(Translate_context* context)\n+{\n+  Gogo* gogo = context->gogo();\n+  Btype* result_btype = this->type()->get_backend(gogo);\n+  Bexpression* cond = tree_to_expr(this->cond_->get_tree(context));\n+  Bexpression* then = tree_to_expr(this->then_->get_tree(context));\n+  Bexpression* belse = tree_to_expr(this->else_->get_tree(context));\n+  Bexpression* ret =\n+      gogo->backend()->conditional_expression(result_btype, cond, then, belse,\n+                                              this->location());\n+  return expr_to_tree(ret);\n+}\n+\n+// Dump ast representation of a conditional expression.\n+\n+void\n+Conditional_expression::do_dump_expression(\n+    Ast_dump_context* ast_dump_context) const\n+{\n+  ast_dump_context->ostream() << \"(\";\n+  ast_dump_context->dump_expression(this->cond_);\n+  ast_dump_context->ostream() << \" ? \";\n+  ast_dump_context->dump_expression(this->then_);\n+  ast_dump_context->ostream() << \" : \";\n+  ast_dump_context->dump_expression(this->else_);\n+  ast_dump_context->ostream() << \") \";\n+}\n+\n+// Make a conditional expression.\n+\n+Expression*\n+Expression::make_conditional(Expression* cond, Expression* then,\n+                             Expression* else_expr, Location location)\n+{\n+  return new Conditional_expression(cond, then, else_expr, location);\n+}\n+\n // Import an expression.  This comes at the end in order to see the\n // various class definitions.\n "}, {"sha": "99a0d0720ebc2f1bdc04c288d979ea0f7eced3ee", "filename": "gcc/go/gofrontend/expressions.h", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/56e13ae00611a97d28f5284513c45f829a9810c9/gcc%2Fgo%2Fgofrontend%2Fexpressions.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/56e13ae00611a97d28f5284513c45f829a9810c9/gcc%2Fgo%2Fgofrontend%2Fexpressions.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fexpressions.h?ref=56e13ae00611a97d28f5284513c45f829a9810c9", "patch": "@@ -106,7 +106,8 @@ class Expression\n     EXPRESSION_INTERFACE_INFO,\n     EXPRESSION_STRUCT_FIELD_OFFSET,\n     EXPRESSION_MAP_DESCRIPTOR,\n-    EXPRESSION_LABEL_ADDR\n+    EXPRESSION_LABEL_ADDR,\n+    EXPRESSION_CONDITIONAL\n   };\n \n   Expression(Expression_classification, Location);\n@@ -388,6 +389,10 @@ class Expression\n   static Expression*\n   make_label_addr(Label*, Location);\n \n+  // Make a conditional expression.\n+  static Expression*\n+  make_conditional(Expression*, Expression*, Expression*, Location);\n+\n   // Return the expression classification.\n   Expression_classification\n   classification() const"}]}