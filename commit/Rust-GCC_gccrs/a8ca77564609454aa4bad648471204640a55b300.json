{"sha": "a8ca77564609454aa4bad648471204640a55b300", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YThjYTc3NTY0NjA5NDU0YWE0YmFkNjQ4NDcxMjA0NjQwYTU1YjMwMA==", "commit": {"author": {"name": "Jim Wilson", "email": "wilson@cygnus.com", "date": "2000-10-25T01:30:25Z"}, "committer": {"name": "Jim Wilson", "email": "wilson@gcc.gnu.org", "date": "2000-10-25T01:30:25Z"}, "message": "Fixes for C++ structure layout breakage.\n\n\t* expmed.c (store_bit_field): Move integer pun code down after\n\tcode that calls emit_move_insn for entire register move.\n\t* stor-layout.c (compute_record_mode): Revert Mar 25, Aug 18, and\n\tOct 20 changes.  Only store mode in TYPE_MODE if RECORD_TYPE.\n\nFrom-SVN: r37041", "tree": {"sha": "9642e7e20204571cf15e101b98b0af82637ce77f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/9642e7e20204571cf15e101b98b0af82637ce77f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a8ca77564609454aa4bad648471204640a55b300", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a8ca77564609454aa4bad648471204640a55b300", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a8ca77564609454aa4bad648471204640a55b300", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a8ca77564609454aa4bad648471204640a55b300/comments", "author": null, "committer": null, "parents": [{"sha": "c0fc376bcfaaf42823c07e5cd8420343fd56b370", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c0fc376bcfaaf42823c07e5cd8420343fd56b370", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c0fc376bcfaaf42823c07e5cd8420343fd56b370"}], "stats": {"total": 52, "additions": 29, "deletions": 23}, "files": [{"sha": "6e87a7899996cff63a96cd88799ca6667847e5b2", "filename": "gcc/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a8ca77564609454aa4bad648471204640a55b300/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a8ca77564609454aa4bad648471204640a55b300/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=a8ca77564609454aa4bad648471204640a55b300", "patch": "@@ -1,3 +1,10 @@\n+2000-10-24  Jim Wilson  <wilson@cygnus.com>\n+\n+\t* expmed.c (store_bit_field): Move integer pun code down after\n+\tcode that calls emit_move_insn for entire register move.\n+\t* stor-layout.c (compute_record_mode): Revert Mar 25, Aug 18, and\n+\tOct 20 changes.  Only store mode in TYPE_MODE if RECORD_TYPE.\n+\t\n 2000-10-24  Richard Henderson  <rth@cygnus.com>\n \n \t* rtlanal.c (rtx_unstable_p, rtx_varies_p): Don't consider pic"}, {"sha": "254d052d8b5162e1d5785b0f46cc06d826e38c65", "filename": "gcc/expmed.c", "status": "modified", "additions": 17, "deletions": 15, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a8ca77564609454aa4bad648471204640a55b300/gcc%2Fexpmed.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a8ca77564609454aa4bad648471204640a55b300/gcc%2Fexpmed.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpmed.c?ref=a8ca77564609454aa4bad648471204640a55b300", "patch": "@@ -269,21 +269,6 @@ store_bit_field (str_rtx, bitsize, bitnum, fieldmode, value, align, total_size)\n       op0 = SUBREG_REG (op0);\n     }\n \n-  /* Make sure we are playing with integral modes.  Pun with subregs\n-     if we aren't.  */\n-  {\n-    enum machine_mode imode = int_mode_for_mode (GET_MODE (op0));\n-    if (imode != GET_MODE (op0))\n-      {\n-\tif (GET_CODE (op0) == MEM)\n-\t  op0 = change_address (op0, imode, NULL_RTX);\n-\telse if (imode != BLKmode)\n-\t  op0 = gen_lowpart (imode, op0);\n-\telse\n-\t  abort ();\n-      }\n-  }\n-\n   /* If OP0 is a register, BITPOS must count within a word.\n      But as we have it, it counts within whatever size OP0 now has.\n      On a bigendian machine, these are not the same, so convert.  */\n@@ -337,6 +322,23 @@ store_bit_field (str_rtx, bitsize, bitnum, fieldmode, value, align, total_size)\n       return value;\n     }\n \n+  /* Make sure we are playing with integral modes.  Pun with subregs\n+     if we aren't.  This must come after the entire register case above,\n+     since that case is valid for any mode.  The following cases are only\n+     valid for integral modes.  */\n+  {\n+    enum machine_mode imode = int_mode_for_mode (GET_MODE (op0));\n+    if (imode != GET_MODE (op0))\n+      {\n+\tif (GET_CODE (op0) == MEM)\n+\t  op0 = change_address (op0, imode, NULL_RTX);\n+\telse if (imode != BLKmode)\n+\t  op0 = gen_lowpart (imode, op0);\n+\telse\n+\t  abort ();\n+      }\n+  }\n+\n   /* Storing an lsb-aligned field in a register\n      can be done with a movestrict instruction.  */\n "}, {"sha": "797b4cea17da24c5d9e4bd0f99b2db91ea42635f", "filename": "gcc/stor-layout.c", "status": "modified", "additions": 5, "deletions": 8, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a8ca77564609454aa4bad648471204640a55b300/gcc%2Fstor-layout.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a8ca77564609454aa4bad648471204640a55b300/gcc%2Fstor-layout.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fstor-layout.c?ref=a8ca77564609454aa4bad648471204640a55b300", "patch": "@@ -1065,12 +1065,8 @@ compute_record_mode (type)\n \n       /* If this field is the whole struct, remember its mode so\n \t that, say, we can put a double in a class into a DF\n-\t register instead of forcing it to live in the stack.  However,\n-\t we don't support using such a mode if there is no integer mode\n-\t of the same size, so don't set it here.  */\n-      if (field == TYPE_FIELDS (type) && TREE_CHAIN (field) == 0\n-\t  && int_mode_for_mode (DECL_MODE (field)) != BLKmode\n-\t  && operand_equal_p (DECL_SIZE (field), TYPE_SIZE (type), 1))\n+\t register instead of forcing it to live in the stack.  */\n+      if (simple_cst_equal (TYPE_SIZE (type), DECL_SIZE (field)))\n \tmode = DECL_MODE (field);\n \n #ifdef STRUCT_FORCE_BLK\n@@ -1081,8 +1077,9 @@ compute_record_mode (type)\n #endif /* STRUCT_FORCE_BLK  */\n     }\n \n-  if (mode != VOIDmode)\n-    /* We only have one real field; use its mode.  */\n+  /* If we only have one real field; use its mode.  This only applies to\n+     RECORD_TYPE.  This does not apply to unions.  */\n+  if (TREE_CODE (type) == RECORD_TYPE && mode != VOIDmode)\n     TYPE_MODE (type) = mode;\n   else\n     TYPE_MODE (type) = mode_for_size_tree (TYPE_SIZE (type), MODE_INT, 1);"}]}