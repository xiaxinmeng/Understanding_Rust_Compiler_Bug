{"sha": "10f135942226e4ae2bbeb48515be4368d9745d68", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTBmMTM1OTQyMjI2ZTRhZTJiYmViNDg1MTViZTQzNjhkOTc0NWQ2OA==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@cygnus.com", "date": "2000-04-17T19:21:09Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2000-04-17T19:21:09Z"}, "message": "loop.c (canonicalize_condition): Add WANT_REG argument.\n\n        * loop.c (canonicalize_condition): Add WANT_REG argument.\n        Stop the search if we match it.\n        * expr.h (canonicalize_condition): Update decl.\n        * predict.c (expected_value_to_br_prob): Use it.  Track last\n        expected value note.\n        (find_expected_value): Remove.\n\n        * reorg.c (mostly_true_jump): Always use BR_PROB if present.\n\nFrom-SVN: r33214", "tree": {"sha": "0304d00cbc94155e5757d349d3e7de66029fc4e0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/0304d00cbc94155e5757d349d3e7de66029fc4e0"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/10f135942226e4ae2bbeb48515be4368d9745d68", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/10f135942226e4ae2bbeb48515be4368d9745d68", "html_url": "https://github.com/Rust-GCC/gccrs/commit/10f135942226e4ae2bbeb48515be4368d9745d68", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/10f135942226e4ae2bbeb48515be4368d9745d68/comments", "author": null, "committer": null, "parents": [{"sha": "a73848406c824b7b2f6095c205828e2a1c8427a2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a73848406c824b7b2f6095c205828e2a1c8427a2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a73848406c824b7b2f6095c205828e2a1c8427a2"}], "stats": {"total": 154, "additions": 75, "deletions": 79}, "files": [{"sha": "9fcbff80587d0da14328e6a2a25566d51380688b", "filename": "gcc/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/10f135942226e4ae2bbeb48515be4368d9745d68/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/10f135942226e4ae2bbeb48515be4368d9745d68/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=10f135942226e4ae2bbeb48515be4368d9745d68", "patch": "@@ -1,3 +1,14 @@\n+2000-04-17  Richard Henderson  <rth@cygnus.com>\n+\n+\t* loop.c (canonicalize_condition): Add WANT_REG argument.\n+\tStop the search if we match it.\n+\t* expr.h (canonicalize_condition): Update decl.\n+\t* predict.c (expected_value_to_br_prob): Use it.  Track last\n+\texpected value note.\n+\t(find_expected_value): Remove.\n+\n+\t* reorg.c (mostly_true_jump): Always use BR_PROB if present.\n+\n 2000-04-17  Zack Weinberg  <zack@wolery.cumb.org>\n \n \t* aclocal.m4 (AM_GNU_GETTEXT): Don't AC_REQUIRE([AC_FUNC_MMAP])."}, {"sha": "8d7a9d8152cc1e78d931879cdc3f8b4ef1f74d57", "filename": "gcc/expr.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/10f135942226e4ae2bbeb48515be4368d9745d68/gcc%2Fexpr.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/10f135942226e4ae2bbeb48515be4368d9745d68/gcc%2Fexpr.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.h?ref=10f135942226e4ae2bbeb48515be4368d9745d68", "patch": "@@ -894,7 +894,7 @@ extern rtx emit_store_flag_force PARAMS ((rtx, enum rtx_code, rtx, rtx,\n \n /* Given an insn and condition, return a canonical description of\n    the test being made.  */\n-extern rtx canonicalize_condition PARAMS ((rtx, rtx, int, rtx *));\n+extern rtx canonicalize_condition PARAMS ((rtx, rtx, int, rtx *, rtx));\n \n /* Given a JUMP_INSN, return a canonical description of the test\n    being made.  */"}, {"sha": "8a3eb4df741bb500412e59db85e1a7ffd78f0175", "filename": "gcc/loop.c", "status": "modified", "additions": 11, "deletions": 4, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/10f135942226e4ae2bbeb48515be4368d9745d68/gcc%2Floop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/10f135942226e4ae2bbeb48515be4368d9745d68/gcc%2Floop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Floop.c?ref=10f135942226e4ae2bbeb48515be4368d9745d68", "patch": "@@ -9013,14 +9013,19 @@ update_reg_last_use (x, insn)\n    If EARLIEST is non-zero, it is a pointer to a place where the earliest\n    insn used in locating the condition was found.  If a replacement test\n    of the condition is desired, it should be placed in front of that\n-   insn and we will be sure that the inputs are still valid.  */\n+   insn and we will be sure that the inputs are still valid.\n+\n+   If WANT_REG is non-zero, we wish the condition to be relative to that\n+   register, if possible.  Therefore, do not canonicalize the condition\n+   further.  */\n \n rtx\n-canonicalize_condition (insn, cond, reverse, earliest)\n+canonicalize_condition (insn, cond, reverse, earliest, want_reg)\n      rtx insn;\n      rtx cond;\n      int reverse;\n      rtx *earliest;\n+     rtx want_reg;\n {\n   enum rtx_code code;\n   rtx prev = insn;\n@@ -9050,7 +9055,9 @@ canonicalize_condition (insn, cond, reverse, earliest)\n      the same tests as a function of STORE_FLAG_VALUE as find_comparison_args\n      in cse.c  */\n \n-  while (GET_RTX_CLASS (code) == '<' && op1 == CONST0_RTX (GET_MODE (op0)))\n+  while (GET_RTX_CLASS (code) == '<'\n+         && op1 == CONST0_RTX (GET_MODE (op0))\n+\t && op0 != want_reg)\n     {\n       /* Set non-zero when we find something of interest.  */\n       rtx x = 0;\n@@ -9291,7 +9298,7 @@ get_condition (jump, earliest)\n     = GET_CODE (XEXP (SET_SRC (PATTERN (jump)), 2)) == LABEL_REF\n       && XEXP (XEXP (SET_SRC (PATTERN (jump)), 2), 0) == JUMP_LABEL (jump);\n \n-  return canonicalize_condition (jump, cond, reverse, earliest);\n+  return canonicalize_condition (jump, cond, reverse, earliest, NULL_RTX);\n }\n \n /* Similar to above routine, except that we also put an invariant last"}, {"sha": "958dbf925b8babb31fb3e3c7a163b6a820044da3", "filename": "gcc/predict.c", "status": "modified", "additions": 38, "deletions": 59, "changes": 97, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/10f135942226e4ae2bbeb48515be4368d9745d68/gcc%2Fpredict.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/10f135942226e4ae2bbeb48515be4368d9745d68/gcc%2Fpredict.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpredict.c?ref=10f135942226e4ae2bbeb48515be4368d9745d68", "patch": "@@ -190,29 +190,46 @@ static rtx find_expected_value\t\tPARAMS ((rtx, rtx));\n void\n expected_value_to_br_prob ()\n {\n-  rtx insn, cond, earliest, ev;\n+  rtx insn, cond, ev = NULL_RTX, ev_reg;\n \n   for (insn = get_insns (); insn ; insn = NEXT_INSN (insn))\n     {\n-      /* Look for simple conditional branches.  */\n-      if (GET_CODE (insn) != JUMP_INSN)\n-\tcontinue;\n-      if (! condjump_p (insn) || simplejump_p (insn))\n-\tcontinue;\n+      switch (GET_CODE (insn))\n+\t{\n+\tcase NOTE:\n+\t  /* Look for expected value notes.  */\n+\t  if (NOTE_LINE_NUMBER (insn) == NOTE_INSN_EXPECTED_VALUE)\n+\t    {\n+\t      ev = NOTE_EXPECTED_VALUE (insn);\n+\t      ev_reg = XEXP (ev, 0);\n+\t    }\n+\t  continue;\n+\n+\tcase CODE_LABEL:\n+\t  /* Never propagate across labels.  */\n+\t  ev = NULL_RTX;\n+\t  continue;\n \n-      /* Collect the branch condition.  Some machines can branch on\n-\t user values directly, others need a compare instruction.  If\n-\t the branch condition involves a MODE_INT register, try that\n-\t expression first.  Otherwise use get_condition.  */\n+\tdefault:\n+\t  /* Look for insns that clobber the EV register.  */\n+\t  if (ev && reg_set_p (ev_reg, insn))\n+\t    ev = NULL_RTX;\n+\t  continue;\n+\n+\tcase JUMP_INSN:\n+\t  /* Look for simple conditional branches.  If we havn't got an\n+\t     expected value yet, no point going further.  */\n+\t  if (GET_CODE (insn) != JUMP_INSN || ev == NULL_RTX)\n+\t    continue;\n+\t  if (! condjump_p (insn) || simplejump_p (insn))\n+\t    continue;\n+\t  break;\n+\t}\n+\n+      /* Collect the branch condition, hopefully relative to EV_REG.  */\n       cond = XEXP (SET_SRC (PATTERN (insn)), 0);\n-      if (GET_RTX_CLASS (GET_CODE (cond)) != '<')\n-\tabort ();\n-      if (GET_CODE (XEXP (cond, 0)) == REG\n-\t  && GET_MODE_CLASS (GET_MODE (XEXP (cond, 0))) == MODE_INT\n-\t  && (ev = find_expected_value (cond, insn)) != NULL_RTX)\n-\t;\n-      else if ((cond = get_condition (insn, &earliest)) == NULL_RTX\n-\t       || (ev = find_expected_value (cond, earliest)) == NULL_RTX)\n+      cond = canonicalize_condition (insn, cond, 0, NULL, ev_reg);\n+      if (! cond || XEXP (cond, 0) != ev_reg)\n \tcontinue;\n \n       /* Substitute and simplify.  Given that the expression we're \n@@ -223,48 +240,10 @@ expected_value_to_br_prob ()\n       cond = simplify_rtx (cond);\n \n       /* Turn the condition into a scaled branch probability.  */\n-      if (cond == const0_rtx)\n-\tcond = const1_rtx;\n-      else if (cond == const1_rtx)\n-\tcond = GEN_INT (REG_BR_PROB_BASE - 1);\n-      else\n+      if (cond == const1_rtx)\n+\tcond = GEN_INT (REG_BR_PROB_BASE);\n+      else if (cond != const0_rtx)\n \tabort ();\n       REG_NOTES (insn) = alloc_EXPR_LIST (REG_BR_PROB, cond, REG_NOTES (insn));\n     }\n }\n-\n-/* Search backwards for a NOTE_INSN_EXPECTED_VALUE note with a register\n-   that matches the condition.  */\n-\n-static rtx\n-find_expected_value (cond, earliest)\n-     rtx cond, earliest;\n-{\n-  rtx insn, reg = XEXP (cond, 0);\n-  int timeout;\n-\n-  /* The condition should be (op (reg) (const_int)), otherwise we\n-     won't be able to intuit anything about it.  */\n-  if (GET_CODE (reg) != REG\n-      || GET_CODE (XEXP (cond, 1)) != CONST_INT\n-      || GET_MODE_CLASS (GET_MODE (reg)) != MODE_INT)\n-    return NULL_RTX;\n-\n-  /* Assuming the user wrote something like `if (__builtin_expect(...))',\n-     we shouldn't have to search too far.  Also stop if we reach a code\n-     label or if REG is modified.  */\n-  for (insn = earliest, timeout = 10;\n-       insn && timeout > 0;\n-       insn = PREV_INSN (insn), --timeout)\n-    {\n-      if (GET_CODE (insn) == NOTE\n-\t  && NOTE_LINE_NUMBER (insn) == NOTE_INSN_EXPECTED_VALUE\n-\t  && XEXP (NOTE_EXPECTED_VALUE (insn), 0) == reg)\n-\treturn NOTE_EXPECTED_VALUE (insn);\n-\n-      if (GET_CODE (insn) == CODE_LABEL || reg_set_p (reg, insn))\n-\tbreak;\n-    }\n-\n-  return NULL_RTX;\n-}"}, {"sha": "cce40c0d7cf46b79d32cdd6c4ff6a2bf1bdbced0", "filename": "gcc/reorg.c", "status": "modified", "additions": 14, "deletions": 15, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/10f135942226e4ae2bbeb48515be4368d9745d68/gcc%2Freorg.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/10f135942226e4ae2bbeb48515be4368d9745d68/gcc%2Freorg.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freorg.c?ref=10f135942226e4ae2bbeb48515be4368d9745d68", "patch": "@@ -900,30 +900,29 @@ mostly_true_jump (jump_insn, condition)\n      rtx jump_insn, condition;\n {\n   rtx target_label = JUMP_LABEL (jump_insn);\n-  rtx insn;\n+  rtx insn, note;\n   int rare_dest = rare_destination (target_label);\n   int rare_fallthrough = rare_destination (NEXT_INSN (jump_insn));\n \n   /* If branch probabilities are available, then use that number since it\n      always gives a correct answer.  */\n-  if (flag_branch_probabilities)\n+  note = find_reg_note (jump_insn, REG_BR_PROB, 0);\n+  if (note)\n     {\n-      rtx note = find_reg_note (jump_insn, REG_BR_PROB, 0);\n-      if (note)\n-\t{\n-\t  int prob = XINT (note, 0);\n+      int prob = INTVAL (XEXP (note, 0));\n \n-\t  if (prob >= REG_BR_PROB_BASE * 9 / 10)\n-\t    return 2;\n-\t  else if (prob >= REG_BR_PROB_BASE / 2)\n-\t    return 1;\n-\t  else if (prob >= REG_BR_PROB_BASE / 10)\n-\t    return 0;\n-\t  else\n-\t    return -1;\n-\t}\n+      if (prob >= REG_BR_PROB_BASE * 9 / 10)\n+        return 2;\n+      else if (prob >= REG_BR_PROB_BASE / 2)\n+        return 1;\n+      else if (prob >= REG_BR_PROB_BASE / 10)\n+        return 0;\n+      else\n+        return -1;\n     }\n \n+  /* ??? Ought to use estimate_probability instead.  */\n+\n   /* If this is a branch outside a loop, it is highly unlikely.  */\n   if (GET_CODE (PATTERN (jump_insn)) == SET\n       && GET_CODE (SET_SRC (PATTERN (jump_insn))) == IF_THEN_ELSE"}]}