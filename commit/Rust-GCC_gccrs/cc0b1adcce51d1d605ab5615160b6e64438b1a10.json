{"sha": "cc0b1adcce51d1d605ab5615160b6e64438b1a10", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Y2MwYjFhZGNjZTUxZDFkNjA1YWI1NjE1MTYwYjZlNjQ0MzhiMWExMA==", "commit": {"author": {"name": "Jeffrey A Law", "email": "law@cygnus.com", "date": "1999-02-24T16:29:36Z"}, "committer": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "1999-02-24T16:29:36Z"}, "message": "calls.c (precompute_arguments): New function, extracted from expand_call.\n\n        * calls.c (precompute_arguments): New function, extracted from\n        expand_call.\n        (expand_call): Use precompute_arguments.\n\nFrom-SVN: r25409", "tree": {"sha": "f87ae99a30be3d490d78e0fe431e2bbdffdf283d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f87ae99a30be3d490d78e0fe431e2bbdffdf283d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/cc0b1adcce51d1d605ab5615160b6e64438b1a10", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cc0b1adcce51d1d605ab5615160b6e64438b1a10", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cc0b1adcce51d1d605ab5615160b6e64438b1a10", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cc0b1adcce51d1d605ab5615160b6e64438b1a10/comments", "author": null, "committer": null, "parents": [{"sha": "1de558ee81d8ce1ffa6662e6fc0a940306c816d9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1de558ee81d8ce1ffa6662e6fc0a940306c816d9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1de558ee81d8ce1ffa6662e6fc0a940306c816d9"}], "stats": {"total": 127, "additions": 82, "deletions": 45}, "files": [{"sha": "3f6f0857b871f274a2a2ac4c2172e191ed07a153", "filename": "gcc/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cc0b1adcce51d1d605ab5615160b6e64438b1a10/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cc0b1adcce51d1d605ab5615160b6e64438b1a10/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=cc0b1adcce51d1d605ab5615160b6e64438b1a10", "patch": "@@ -1,5 +1,9 @@\n Wed Feb 24 14:03:54 1999  Jeffrey A Law  (law@cygnus.com)\n \n+\t* calls.c (precompute_arguments): New function, extracted from\n+\texpand_call.\n+\t(expand_call): Use precompute_arguments.\n+\n \t* calls.c (finalize_must_preallocate): New function, extracted from\n \texpand_call.\n \t(expand_call): Use finalize_must_preallocate."}, {"sha": "bfc71e7f775936ca73812a9227bcff4b876d6dd9", "filename": "gcc/calls.c", "status": "modified", "additions": 78, "deletions": 45, "changes": 123, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cc0b1adcce51d1d605ab5615160b6e64438b1a10/gcc%2Fcalls.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cc0b1adcce51d1d605ab5615160b6e64438b1a10/gcc%2Fcalls.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcalls.c?ref=cc0b1adcce51d1d605ab5615160b6e64438b1a10", "patch": "@@ -140,6 +140,9 @@ static void store_unaligned_arguments_into_pseudos PROTO ((struct arg_data *,\n static int finalize_must_preallocate\t\tPROTO ((int, int,\n \t\t\t\t\t\t\tstruct arg_data *,\n \t\t\t\t\t\t\tstruct args_size *));\n+static void precompute_arguments \t\tPROTO ((int, int, int,\n+\t\t\t\t\t\t\tstruct arg_data *,\n+\t\t\t\t\t\t\tstruct args_size *));\n \n \n #if defined(ACCUMULATE_OUTGOING_ARGS) && defined(REG_PARM_STACK_SPACE)\n@@ -826,6 +829,78 @@ store_unaligned_arguments_into_pseudos (args, num_actuals)\n       }\n }\n \n+/* Precompute parameters has needed for a function call.\n+\n+   IS_CONST indicates the target function is a pure function.\n+\n+   MUST_PREALLOCATE indicates that we must preallocate stack space for\n+   any stack arguments.\n+\n+   NUM_ACTUALS is the number of arguments.\n+\n+   ARGS is an array containing information for each argument; this routine\n+   fills in the INITIAL_VALUE and VALUE fields for each precomputed argument.\n+\n+   ARGS_SIZE contains information about the size of the arg list.  */\n+\n+static void\n+precompute_arguments (is_const, must_preallocate, num_actuals, args, args_size)\n+     int is_const;\n+     int must_preallocate;\n+     int num_actuals;\n+     struct arg_data *args;\n+     struct args_size *args_size;\n+{\n+  int i;\n+\n+  /* If this function call is cse'able, precompute all the parameters.\n+     Note that if the parameter is constructed into a temporary, this will\n+     cause an additional copy because the parameter will be constructed\n+     into a temporary location and then copied into the outgoing arguments.\n+     If a parameter contains a call to alloca and this function uses the\n+     stack, precompute the parameter.  */\n+\n+  /* If we preallocated the stack space, and some arguments must be passed\n+     on the stack, then we must precompute any parameter which contains a\n+     function call which will store arguments on the stack.\n+     Otherwise, evaluating the parameter may clobber previous parameters\n+     which have already been stored into the stack.  */\n+\n+  for (i = 0; i < num_actuals; i++)\n+    if (is_const\n+\t|| ((args_size->var != 0 || args_size->constant != 0)\n+\t    && calls_function (args[i].tree_value, 1))\n+\t|| (must_preallocate\n+\t    && (args_size->var != 0 || args_size->constant != 0)\n+\t    && calls_function (args[i].tree_value, 0)))\n+      {\n+\t/* If this is an addressable type, we cannot pre-evaluate it.  */\n+\tif (TREE_ADDRESSABLE (TREE_TYPE (args[i].tree_value)))\n+\t  abort ();\n+\n+\tpush_temp_slots ();\n+\n+\targs[i].initial_value = args[i].value\n+\t  = expand_expr (args[i].tree_value, NULL_RTX, VOIDmode, 0);\n+\n+\tpreserve_temp_slots (args[i].value);\n+\tpop_temp_slots ();\n+\n+\t/* ANSI doesn't require a sequence point here,\n+\t   but PCC has one, so this will avoid some problems.  */\n+\temit_queue ();\n+\n+\targs[i].initial_value = args[i].value\n+\t  = protect_from_queue (args[i].initial_value, 0);\n+\n+\tif (TYPE_MODE (TREE_TYPE (args[i].tree_value)) != args[i].mode)\n+\t  args[i].value\n+\t    = convert_modes (args[i].mode, \n+\t\t\t     TYPE_MODE (TREE_TYPE (args[i].tree_value)),\n+\t\t\t     args[i].value, args[i].unsignedp);\n+      }\n+}\n+\n /* Given the current state of MUST_PREALLOCATE and information about\n    arguments to a function call in NUM_ACTUALS, ARGS and ARGS_SIZE,\n    compute and return the final value for MUST_PREALLOCATE.  */\n@@ -1649,51 +1724,9 @@ expand_call (exp, target, ignore)\n \t  ))\n     structure_value_addr = copy_to_reg (structure_value_addr);\n \n-  /* If this function call is cse'able, precompute all the parameters.\n-     Note that if the parameter is constructed into a temporary, this will\n-     cause an additional copy because the parameter will be constructed\n-     into a temporary location and then copied into the outgoing arguments.\n-     If a parameter contains a call to alloca and this function uses the\n-     stack, precompute the parameter.  */\n-\n-  /* If we preallocated the stack space, and some arguments must be passed\n-     on the stack, then we must precompute any parameter which contains a\n-     function call which will store arguments on the stack.\n-     Otherwise, evaluating the parameter may clobber previous parameters\n-     which have already been stored into the stack.  */\n-\n-  for (i = 0; i < num_actuals; i++)\n-    if (is_const\n-\t|| ((args_size.var != 0 || args_size.constant != 0)\n-\t    && calls_function (args[i].tree_value, 1))\n-\t|| (must_preallocate && (args_size.var != 0 || args_size.constant != 0)\n-\t    && calls_function (args[i].tree_value, 0)))\n-      {\n-\t/* If this is an addressable type, we cannot pre-evaluate it.  */\n-\tif (TREE_ADDRESSABLE (TREE_TYPE (args[i].tree_value)))\n-\t  abort ();\n-\n-\tpush_temp_slots ();\n-\n-\targs[i].initial_value = args[i].value\n-\t  = expand_expr (args[i].tree_value, NULL_RTX, VOIDmode, 0);\n-\n-\tpreserve_temp_slots (args[i].value);\n-\tpop_temp_slots ();\n-\n-\t/* ANSI doesn't require a sequence point here,\n-\t   but PCC has one, so this will avoid some problems.  */\n-\temit_queue ();\n-\n-\targs[i].initial_value = args[i].value\n-\t  = protect_from_queue (args[i].initial_value, 0);\n-\n-\tif (TYPE_MODE (TREE_TYPE (args[i].tree_value)) != args[i].mode)\n-\t  args[i].value\n-\t    = convert_modes (args[i].mode, \n-\t\t\t     TYPE_MODE (TREE_TYPE (args[i].tree_value)),\n-\t\t\t     args[i].value, args[i].unsignedp);\n-      }\n+  /* Precompute any arguments as needed.  */\n+  precompute_arguments (is_const, must_preallocate, num_actuals,\n+                        args, &args_size);\n \n   /* Now we are about to start emitting insns that can be deleted\n      if a libcall is deleted.  */"}]}