{"sha": "ff5e9a942cba0770cd0ccdd44d38cf03c3c5cbfb", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZmY1ZTlhOTQyY2JhMDc3MGNkMGNjZGQ0NGQzOGNmMDNjM2M1Y2JmYg==", "commit": {"author": {"name": "Sebastian Pop", "email": "pop@cri.ensmp.fr", "date": "2006-04-07T15:44:59Z"}, "committer": {"name": "Sebastian Pop", "email": "spop@gcc.gnu.org", "date": "2006-04-07T15:44:59Z"}, "message": "tree-ssa-loop-niter.c (inverse, [...]): Use build_int_cst instead of build_int_cst_type.\n\n\t* tree-ssa-loop-niter.c (inverse, number_of_iterations_ne,\n\tassert_no_overflow_lt, assert_loop_rolls_lt, number_of_iterations_lt,\n\tnumber_of_iterations_le, number_of_iterations_cond, find_loop_niter,\n\testimate_numbers_of_iterations_loop): Use build_int_cst instead of \n\tbuild_int_cst_type.\n\t* tree-chrec.c (chrec_fold_multiply_poly_poly,\n\tchrec_fold_multiply): Same.\n\t* tree-ssa-loop-ivopts.c (strip_offset_1, force_expr_to_var_cost,\n\tforce_expr_to_var_cost): Same.\n\t* tree-mudflap.c (mf_xform_derefs_1): Same.\n\t* tree-ssa-loop-prefetch.c (idx_analyze_ref): Same.\n\nFrom-SVN: r112755", "tree": {"sha": "4c625bc9e9d89752ba6cd25b32250d60cc28c748", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/4c625bc9e9d89752ba6cd25b32250d60cc28c748"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ff5e9a942cba0770cd0ccdd44d38cf03c3c5cbfb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ff5e9a942cba0770cd0ccdd44d38cf03c3c5cbfb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ff5e9a942cba0770cd0ccdd44d38cf03c3c5cbfb", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ff5e9a942cba0770cd0ccdd44d38cf03c3c5cbfb/comments", "author": null, "committer": {"login": "sebpop", "id": 568397, "node_id": "MDQ6VXNlcjU2ODM5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/568397?v=4", "gravatar_id": "", "url": "https://api.github.com/users/sebpop", "html_url": "https://github.com/sebpop", "followers_url": "https://api.github.com/users/sebpop/followers", "following_url": "https://api.github.com/users/sebpop/following{/other_user}", "gists_url": "https://api.github.com/users/sebpop/gists{/gist_id}", "starred_url": "https://api.github.com/users/sebpop/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/sebpop/subscriptions", "organizations_url": "https://api.github.com/users/sebpop/orgs", "repos_url": "https://api.github.com/users/sebpop/repos", "events_url": "https://api.github.com/users/sebpop/events{/privacy}", "received_events_url": "https://api.github.com/users/sebpop/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "544c479db3108ec43654e2cea7fe1f0046df83ef", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/544c479db3108ec43654e2cea7fe1f0046df83ef", "html_url": "https://github.com/Rust-GCC/gccrs/commit/544c479db3108ec43654e2cea7fe1f0046df83ef"}], "stats": {"total": 60, "additions": 37, "deletions": 23}, "files": [{"sha": "8a403bf1e574341c86d6c48215f5ae32828fc789", "filename": "gcc/ChangeLog", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff5e9a942cba0770cd0ccdd44d38cf03c3c5cbfb/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff5e9a942cba0770cd0ccdd44d38cf03c3c5cbfb/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=ff5e9a942cba0770cd0ccdd44d38cf03c3c5cbfb", "patch": "@@ -1,3 +1,17 @@\n+2006-04-07  Sebastian Pop  <pop@cri.ensmp.fr>\n+\n+\t* tree-ssa-loop-niter.c (inverse, number_of_iterations_ne,\n+\tassert_no_overflow_lt, assert_loop_rolls_lt, number_of_iterations_lt,\n+\tnumber_of_iterations_le, number_of_iterations_cond, find_loop_niter,\n+\testimate_numbers_of_iterations_loop): Use build_int_cst instead of \n+\tbuild_int_cst_type.\n+\t* tree-chrec.c (chrec_fold_multiply_poly_poly,\n+\tchrec_fold_multiply): Same.\n+\t* tree-ssa-loop-ivopts.c (strip_offset_1, force_expr_to_var_cost,\n+\tforce_expr_to_var_cost): Same.\n+\t* tree-mudflap.c (mf_xform_derefs_1): Same.\n+\t* tree-ssa-loop-prefetch.c (idx_analyze_ref): Same.\n+\n 2006-04-07  David Edelsohn  <edelsohn@gnu.org>\n \n \t* config/rs6000/rs6000.c (rs6000_rtx_costs) <CONST_DOUBLE>: Do not"}, {"sha": "c0819b096c153500c43e3dcaacab6ec17c80e953", "filename": "gcc/tree-chrec.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff5e9a942cba0770cd0ccdd44d38cf03c3c5cbfb/gcc%2Ftree-chrec.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff5e9a942cba0770cd0ccdd44d38cf03c3c5cbfb/gcc%2Ftree-chrec.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-chrec.c?ref=ff5e9a942cba0770cd0ccdd44d38cf03c3c5cbfb", "patch": "@@ -218,7 +218,7 @@ chrec_fold_multiply_poly_poly (tree type,\n   t2 = chrec_fold_multiply (type, CHREC_RIGHT (poly0), CHREC_RIGHT (poly1));\n   t2 = chrec_fold_multiply (type, SCALAR_FLOAT_TYPE_P (type)\n \t\t\t    ? build_real (type, dconst2)\n-\t\t\t    : build_int_cst_type (type, 2), t2);\n+\t\t\t    : build_int_cst (type, 2), t2);\n \n   var = CHREC_VARIABLE (poly0);\n   return build_polynomial_chrec (var, t0,\n@@ -374,7 +374,7 @@ chrec_fold_multiply (tree type,\n \t  if (integer_onep (op1))\n \t    return op0;\n \t  if (integer_zerop (op1))\n-\t    return build_int_cst_type (type, 0);\n+\t    return build_int_cst (type, 0);\n \t  \n \t  return build_polynomial_chrec \n \t    (CHREC_VARIABLE (op0), \n@@ -387,7 +387,7 @@ chrec_fold_multiply (tree type,\n \treturn op1;\n       \n       if (integer_zerop (op0))\n-    \treturn build_int_cst_type (type, 0);\n+    \treturn build_int_cst (type, 0);\n       \n       switch (TREE_CODE (op1))\n \t{\n@@ -401,7 +401,7 @@ chrec_fold_multiply (tree type,\n \t  if (integer_onep (op1))\n \t    return op0;\n \t  if (integer_zerop (op1))\n-\t    return build_int_cst_type (type, 0);\n+\t    return build_int_cst (type, 0);\n \t  return fold_build2 (MULT_EXPR, type, op0, op1);\n \t}\n     }"}, {"sha": "1a62859e6f10b4a5c1e78f4de7df9b760179395d", "filename": "gcc/tree-mudflap.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff5e9a942cba0770cd0ccdd44d38cf03c3c5cbfb/gcc%2Ftree-mudflap.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff5e9a942cba0770cd0ccdd44d38cf03c3c5cbfb/gcc%2Ftree-mudflap.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-mudflap.c?ref=ff5e9a942cba0770cd0ccdd44d38cf03c3c5cbfb", "patch": "@@ -845,7 +845,7 @@ mf_xform_derefs_1 (block_stmt_iterator *iter, tree *tp,\n       base = addr;\n       limit = fold_build2 (MINUS_EXPR, ptr_type_node,\n \t\t\t   fold_build2 (PLUS_EXPR, ptr_type_node, base, size),\n-\t\t\t   build_int_cst_type (ptr_type_node, 1));\n+\t\t\t   build_int_cst (ptr_type_node, 1));\n       break;\n \n     case ARRAY_RANGE_REF:"}, {"sha": "acc8c8a3da5e7a2d3993fe8698bb05a215ec6e90", "filename": "gcc/tree-ssa-loop-ivopts.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff5e9a942cba0770cd0ccdd44d38cf03c3c5cbfb/gcc%2Ftree-ssa-loop-ivopts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff5e9a942cba0770cd0ccdd44d38cf03c3c5cbfb/gcc%2Ftree-ssa-loop-ivopts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-ivopts.c?ref=ff5e9a942cba0770cd0ccdd44d38cf03c3c5cbfb", "patch": "@@ -1763,7 +1763,7 @@ strip_offset_1 (tree expr, bool inside_addr, bool top_compref,\n \treturn orig_expr;\n \n       *offset = int_cst_value (expr);\n-      return build_int_cst_type (orig_type, 0);\n+      return build_int_cst (orig_type, 0);\n \n     case PLUS_EXPR:\n     case MINUS_EXPR:\n@@ -3380,8 +3380,8 @@ force_expr_to_var_cost (tree expr)\n       tree addr;\n       tree type = build_pointer_type (integer_type_node);\n \n-      integer_cost = computation_cost (build_int_cst_type (integer_type_node,\n-\t\t\t\t\t\t\t   2000));\n+      integer_cost = computation_cost (build_int_cst (integer_type_node,\n+\t\t\t\t\t\t      2000));\n \n       SET_DECL_RTL (var, x);\n       TREE_STATIC (var) = 1;\n@@ -3391,7 +3391,7 @@ force_expr_to_var_cost (tree expr)\n       address_cost\n \t= computation_cost (build2 (PLUS_EXPR, type,\n \t\t\t\t    addr,\n-\t\t\t\t    build_int_cst_type (type, 2000))) + 1;\n+\t\t\t\t    build_int_cst (type, 2000))) + 1;\n       if (dump_file && (dump_flags & TDF_DETAILS))\n \t{\n \t  fprintf (dump_file, \"force_expr_to_var_cost:\\n\");"}, {"sha": "c9f01e883319428c6a9f606a5b80a6409957f1c2", "filename": "gcc/tree-ssa-loop-niter.c", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff5e9a942cba0770cd0ccdd44d38cf03c3c5cbfb/gcc%2Ftree-ssa-loop-niter.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff5e9a942cba0770cd0ccdd44d38cf03c3c5cbfb/gcc%2Ftree-ssa-loop-niter.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-niter.c?ref=ff5e9a942cba0770cd0ccdd44d38cf03c3c5cbfb", "patch": "@@ -114,7 +114,7 @@ inverse (tree x, tree mask)\n     }\n   else\n     {\n-      rslt = build_int_cst_type (type, 1);\n+      rslt = build_int_cst (type, 1);\n       for (; ctr; ctr--)\n \t{\n \t  rslt = int_const_binop (MULT_EXPR, rslt, x, 0);\n@@ -178,7 +178,7 @@ number_of_iterations_ne (tree type, affine_iv *iv, tree final,\n \t\t\t\t- tree_low_cst (bits, 1)));\n \n   d = fold_binary_to_constant (LSHIFT_EXPR, niter_type,\n-\t\t\t       build_int_cst_type (niter_type, 1), bits);\n+\t\t\t       build_int_cst (niter_type, 1), bits);\n   s = fold_binary_to_constant (RSHIFT_EXPR, niter_type, s, bits);\n \n   if (!never_infinite)\n@@ -305,7 +305,7 @@ assert_no_overflow_lt (tree type, affine_iv *iv0, affine_iv *iv1,\n \t}\n       else\n \tdiff = fold_build2 (MINUS_EXPR, niter_type, step,\n-\t\t\t    build_int_cst_type (niter_type, 1));\n+\t\t\t    build_int_cst (niter_type, 1));\n       bound = fold_build2 (MINUS_EXPR, type,\n \t\t\t   TYPE_MAX_VALUE (type), fold_convert (type, diff));\n       assumption = fold_build2 (LE_EXPR, boolean_type_node,\n@@ -326,7 +326,7 @@ assert_no_overflow_lt (tree type, affine_iv *iv0, affine_iv *iv1,\n \t}\n       else\n \tdiff = fold_build2 (MINUS_EXPR, niter_type, step,\n-\t\t\t    build_int_cst_type (niter_type, 1));\n+\t\t\t    build_int_cst (niter_type, 1));\n       bound = fold_build2 (PLUS_EXPR, type,\n \t\t\t   TYPE_MIN_VALUE (type), fold_convert (type, diff));\n       assumption = fold_build2 (GE_EXPR, boolean_type_node,\n@@ -357,7 +357,7 @@ assert_loop_rolls_lt (tree type, affine_iv *iv0, affine_iv *iv1,\n   if (nonzero_p (iv0->step))\n     {\n       diff = fold_build2 (MINUS_EXPR, type,\n-\t\t\t  iv0->step, build_int_cst_type (type, 1));\n+\t\t\t  iv0->step, build_int_cst (type, 1));\n \n       /* We need to know that iv0->base >= MIN + iv0->step - 1.  Since\n \t 0 address never belongs to any object, we can assume this for\n@@ -378,7 +378,7 @@ assert_loop_rolls_lt (tree type, affine_iv *iv0, affine_iv *iv1,\n   else\n     {\n       diff = fold_build2 (PLUS_EXPR, type,\n-\t\t\t  iv1->step, build_int_cst_type (type, 1));\n+\t\t\t  iv1->step, build_int_cst (type, 1));\n \n       if (!POINTER_TYPE_P (type))\n \t{\n@@ -464,7 +464,7 @@ number_of_iterations_lt (tree type, affine_iv *iv0, affine_iv *iv1,\n     {\n       affine_iv zps;\n \n-      zps.base = build_int_cst_type (niter_type, 0);\n+      zps.base = build_int_cst (niter_type, 0);\n       zps.step = step;\n       /* number_of_iterations_lt_to_ne will add assumptions that ensure that\n \t zps does not overflow.  */\n@@ -483,7 +483,7 @@ number_of_iterations_lt (tree type, affine_iv *iv0, affine_iv *iv1,\n   assert_loop_rolls_lt (type, iv0, iv1, niter);\n \n   s = fold_build2 (MINUS_EXPR, niter_type,\n-\t\t   step, build_int_cst_type (niter_type, 1));\n+\t\t   step, build_int_cst (niter_type, 1));\n   delta = fold_build2 (PLUS_EXPR, niter_type, delta, s);\n   niter->niter = fold_build2 (FLOOR_DIV_EXPR, niter_type, delta, step);\n   return true;\n@@ -525,10 +525,10 @@ number_of_iterations_le (tree type, affine_iv *iv0, affine_iv *iv1,\n \n   if (nonzero_p (iv0->step))\n     iv1->base = fold_build2 (PLUS_EXPR, type,\n-\t\t\t     iv1->base, build_int_cst_type (type, 1));\n+\t\t\t     iv1->base, build_int_cst (type, 1));\n   else\n     iv0->base = fold_build2 (MINUS_EXPR, type,\n-\t\t\t     iv0->base, build_int_cst_type (type, 1));\n+\t\t\t     iv0->base, build_int_cst (type, 1));\n   return number_of_iterations_lt (type, iv0, iv1, niter, never_infinite);\n }\n \n@@ -649,7 +649,7 @@ number_of_iterations_cond (tree type, affine_iv *iv0, enum tree_code code,\n   /* If the loop exits immediately, there is nothing to do.  */\n   if (zero_p (fold_build2 (code, boolean_type_node, iv0->base, iv1->base)))\n     {\n-      niter->niter = build_int_cst_type (unsigned_type_for (type), 0);\n+      niter->niter = build_int_cst (unsigned_type_for (type), 0);\n       return true;\n     }\n \n@@ -1171,7 +1171,7 @@ find_loop_niter (struct loop *loop, edge *exit)\n \t{\n \t  /* We exit in the first iteration through this exit.\n \t     We won't find anything better.  */\n-\t  niter = build_int_cst_type (unsigned_type_node, 0);\n+\t  niter = build_int_cst (unsigned_type_node, 0);\n \t  *exit = ex;\n \t  break;\n \t}\n@@ -1649,7 +1649,7 @@ estimate_numbers_of_iterations_loop (struct loop *loop)\n       if (!zero_p (niter_desc.may_be_zero)\n \t  && !nonzero_p (niter_desc.may_be_zero))\n \tniter = build3 (COND_EXPR, type, niter_desc.may_be_zero,\n-\t\t\tbuild_int_cst_type (type, 0),\n+\t\t\tbuild_int_cst (type, 0),\n \t\t\tniter);\n       record_estimate (loop, niter,\n \t\t       niter_desc.additional_info,"}, {"sha": "44713a3d6d2cc074c648019b8e10c1f059c7af2a", "filename": "gcc/tree-ssa-loop-prefetch.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff5e9a942cba0770cd0ccdd44d38cf03c3c5cbfb/gcc%2Ftree-ssa-loop-prefetch.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff5e9a942cba0770cd0ccdd44d38cf03c3c5cbfb/gcc%2Ftree-ssa-loop-prefetch.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-prefetch.c?ref=ff5e9a942cba0770cd0ccdd44d38cf03c3c5cbfb", "patch": "@@ -366,7 +366,7 @@ idx_analyze_ref (tree base, tree *index, void *data)\n   if (cst_and_fits_in_hwi (ibase))\n     {\n       idelta += int_cst_value (ibase);\n-      ibase = build_int_cst_type (TREE_TYPE (ibase), 0);\n+      ibase = build_int_cst (TREE_TYPE (ibase), 0);\n     }\n \n   if (TREE_CODE (base) == ARRAY_REF)"}]}