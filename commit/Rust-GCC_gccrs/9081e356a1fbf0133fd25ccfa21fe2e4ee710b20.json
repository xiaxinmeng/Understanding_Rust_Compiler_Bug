{"sha": "9081e356a1fbf0133fd25ccfa21fe2e4ee710b20", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTA4MWUzNTZhMWZiZjAxMzNmZDI1Y2NmYTIxZmUyZTRlZTcxMGIyMA==", "commit": {"author": {"name": "Paul Thomas", "email": "pault@gcc.gnu.org", "date": "2005-11-10T22:24:28Z"}, "committer": {"name": "Paul Thomas", "email": "pault@gcc.gnu.org", "date": "2005-11-10T22:24:28Z"}, "message": "re PR fortran/24655 (ICE with statement function)\n\n2005-11-10  Paul Thomas  <pault@gcc.gnu.org>\n\n\tPR fortran/24655\n\tPR fortran/24755\n\t* match.c (recursive_stmt_fcn): Add checks that symtree exists\n\tfor the expression to weed out inline intrinsic functions and\n\tparameters.\n\n\tPR fortran/24409\n\t* module.c (mio_symtree_ref): Correct the patch of 0923 so that\n\ta symbol is not substituted for by a the symbol for the module\n\titself and to prevent the promotion of a formal argument.\n\n2005-11-10  Paul Thomas  <pault@gcc.gnu.org>\n\n\tPR fortran/24655\n\tPR fortran/24755\n\t* gfortran.dg/recursive_statement_functions.f90: Add statement \n\tfunctions using inline intrinsic functions and parameters to test\n\tthat they no longer seg-fault.\n\n\tPR fortran/24409\n\tgfortran.dg/nested_modules_4.f90: New test.\n\tgfortran.dg/nested_modules_5.f90: New test.\n\nFrom-SVN: r106756", "tree": {"sha": "f8af7b25e393d0bdcc9c501354353285b3dd30cc", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f8af7b25e393d0bdcc9c501354353285b3dd30cc"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/9081e356a1fbf0133fd25ccfa21fe2e4ee710b20", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9081e356a1fbf0133fd25ccfa21fe2e4ee710b20", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9081e356a1fbf0133fd25ccfa21fe2e4ee710b20", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9081e356a1fbf0133fd25ccfa21fe2e4ee710b20/comments", "author": null, "committer": null, "parents": [{"sha": "c040ffff7577b6798465f6c025de2b1f77cec1e9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c040ffff7577b6798465f6c025de2b1f77cec1e9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c040ffff7577b6798465f6c025de2b1f77cec1e9"}], "stats": {"total": 123, "additions": 113, "deletions": 10}, "files": [{"sha": "a138bb11ba84ce73a296690ebf464978699e6cce", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9081e356a1fbf0133fd25ccfa21fe2e4ee710b20/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9081e356a1fbf0133fd25ccfa21fe2e4ee710b20/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=9081e356a1fbf0133fd25ccfa21fe2e4ee710b20", "patch": "@@ -1,3 +1,16 @@\n+2005-11-10  Paul Thomas  <pault@gcc.gnu.org>\n+\n+\tPR fortran/24655\n+\tPR fortran/24755\n+\t* match.c (recursive_stmt_fcn): Add checks that symtree exists\n+\tfor the expression to weed out inline intrinsic functions and\n+\tparameters.\n+\n+\tPR fortran/24409\n+\t* module.c (mio_symtree_ref): Correct the patch of 0923 so that\n+\ta symbol is not substituted for by a the symbol for the module\n+\titself and to prevent the promotion of a formal argument.\n+\n 2005-11-10  Tobias Schl\"uter  <tobias.schlueter@physik.uni-muenchen.de>\n \n \tPR fortran/24643"}, {"sha": "97e8f5a434f910c490a9aaf8446d151aca715d3a", "filename": "gcc/fortran/match.c", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9081e356a1fbf0133fd25ccfa21fe2e4ee710b20/gcc%2Ffortran%2Fmatch.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9081e356a1fbf0133fd25ccfa21fe2e4ee710b20/gcc%2Ffortran%2Fmatch.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fmatch.c?ref=9081e356a1fbf0133fd25ccfa21fe2e4ee710b20", "patch": "@@ -2723,6 +2723,9 @@ recursive_stmt_fcn (gfc_expr *e, gfc_symbol *sym)\n \t    return true;\n \t}\n \n+      if (e->symtree == NULL)\n+\treturn false;\n+\n       /* Check the name before testing for nested recursion!  */\n       if (sym->name == e->symtree->n.sym->name)\n \treturn true;\n@@ -2736,7 +2739,7 @@ recursive_stmt_fcn (gfc_expr *e, gfc_symbol *sym)\n       break;\n \n     case EXPR_VARIABLE:\n-      if (sym->name == e->symtree->n.sym->name)\n+      if (e->symtree && sym->name == e->symtree->n.sym->name)\n \treturn true;\n       break;\n "}, {"sha": "6f978aa293e1e610e2889daca2bf51c5145e8fe8", "filename": "gcc/fortran/module.c", "status": "modified", "additions": 11, "deletions": 3, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9081e356a1fbf0133fd25ccfa21fe2e4ee710b20/gcc%2Ffortran%2Fmodule.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9081e356a1fbf0133fd25ccfa21fe2e4ee710b20/gcc%2Ffortran%2Fmodule.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fmodule.c?ref=9081e356a1fbf0133fd25ccfa21fe2e4ee710b20", "patch": "@@ -2113,9 +2113,17 @@ mio_symtree_ref (gfc_symtree ** stp)\n \t namespace to see if the required, non-contained symbol is available\n \t yet. If so, the latter should be written.  */\n       if ((*stp)->n.sym && check_unique_name((*stp)->name))\n-\tns_st = gfc_find_symtree (gfc_current_ns->sym_root, (*stp)->n.sym->name);\n-\n-      mio_symbol_ref (ns_st ? &ns_st->n.sym : &(*stp)->n.sym);\n+\tns_st = gfc_find_symtree (gfc_current_ns->sym_root,\n+\t\t\t\t    (*stp)->n.sym->name);\n+\n+      /* On the other hand, if the existing symbol is the module name or the\n+\t new symbol is a dummy argument, do not do the promotion.  */\n+      if (ns_st && ns_st->n.sym\n+\t    && ns_st->n.sym->attr.flavor != FL_MODULE\n+\t    && !(*stp)->n.sym->attr.dummy)\n+\tmio_symbol_ref (&ns_st->n.sym);\n+      else\n+\tmio_symbol_ref (&(*stp)->n.sym);\n     }\n   else\n     {"}, {"sha": "ac89480809b0a17fca6b2cd5d66db1d629b11a28", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9081e356a1fbf0133fd25ccfa21fe2e4ee710b20/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9081e356a1fbf0133fd25ccfa21fe2e4ee710b20/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=9081e356a1fbf0133fd25ccfa21fe2e4ee710b20", "patch": "@@ -1,3 +1,15 @@\n+2005-11-10  Paul Thomas  <pault@gcc.gnu.org>\n+\n+\tPR fortran/24655\n+\tPR fortran/24755\n+\t* gfortran.dg/recursive_statement_functions.f90: Add statement \n+\tfunctions using inline intrinsic functions and parameters to test\n+\tthat they no longer seg-fault.\n+\n+\tPR fortran/24409\n+\tgfortran.dg/nested_modules_4.f90: New test.\n+\tgfortran.dg/nested_modules_5.f90: New test.\n+\n 2005-11-10  Tobias Schl\"uter  <tobias.schlueter@physik.uni-muenchen.de>\n \n \tPR fortran/24643"}, {"sha": "b9e0fd39467cd6cd510c4768bbe40b2202efc8af", "filename": "gcc/testsuite/gfortran.dg/nested_modules_4.f90", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9081e356a1fbf0133fd25ccfa21fe2e4ee710b20/gcc%2Ftestsuite%2Fgfortran.dg%2Fnested_modules_4.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9081e356a1fbf0133fd25ccfa21fe2e4ee710b20/gcc%2Ftestsuite%2Fgfortran.dg%2Fnested_modules_4.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fnested_modules_4.f90?ref=9081e356a1fbf0133fd25ccfa21fe2e4ee710b20", "patch": "@@ -0,0 +1,25 @@\n+! { dg-do compile }\n+!\n+! Test for the fix to PR24409 - the name clash between the module\n+! name and the interface formal argument would cause an ICE.\n+!\n+! Contributed by Paul Thomas  <pault@gcc.gnu.org>\n+!\n+module string \n+  interface\n+    function  lc(string )\n+      character(len=*), intent(in)  :: string \n+      character(len=len(string ))    :: lc\n+    end function lc\n+  end interface\n+end module string\n+\n+module serial\n+  use string\n+end module serial\n+\n+  use serial\n+  use string\n+  character*15  :: buffer  \n+  buffer = lc (\"Have a Nice DAY\")\n+  end"}, {"sha": "7f96bdba0d4881f00d08bce724d436d96c59cfd7", "filename": "gcc/testsuite/gfortran.dg/nested_modules_5.f90", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9081e356a1fbf0133fd25ccfa21fe2e4ee710b20/gcc%2Ftestsuite%2Fgfortran.dg%2Fnested_modules_5.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9081e356a1fbf0133fd25ccfa21fe2e4ee710b20/gcc%2Ftestsuite%2Fgfortran.dg%2Fnested_modules_5.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fnested_modules_5.f90?ref=9081e356a1fbf0133fd25ccfa21fe2e4ee710b20", "patch": "@@ -0,0 +1,26 @@\n+! { dg-do compile }\n+!\n+! Test for supplementary fix to PR24409 - the name clash between the module\n+! variable and the interface formal argument would cause an ICE.\n+!\n+! Contributed by Paul Thomas  <pault@gcc.gnu.org>\n+!\n+module anything \n+  interface\n+    function  lc(string )\n+      character(len=*), intent(in)  :: string \n+      character(len=len(string ))    :: lc\n+    end function lc\n+  end interface\n+  character(len=12) :: string\n+end module anything\n+\n+module serial\n+  use anything\n+end module serial\n+\n+  use serial\n+  use anything\n+  character*15  :: buffer  \n+  buffer = lc (\"Have a Nice DAY\")\n+  end"}, {"sha": "cc3caaebc272d96ffefcdfb49add8fd331f6c43e", "filename": "gcc/testsuite/gfortran.dg/recursive_statement_functions.f90", "status": "modified", "additions": 22, "deletions": 6, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9081e356a1fbf0133fd25ccfa21fe2e4ee710b20/gcc%2Ftestsuite%2Fgfortran.dg%2Frecursive_statement_functions.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9081e356a1fbf0133fd25ccfa21fe2e4ee710b20/gcc%2Ftestsuite%2Fgfortran.dg%2Frecursive_statement_functions.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Frecursive_statement_functions.f90?ref=9081e356a1fbf0133fd25ccfa21fe2e4ee710b20", "patch": "@@ -1,16 +1,32 @@\n ! { dg-do compile }\n ! PR20866 - A statement function cannot be recursive.\n ! Contributed by Joost VandeVondele <jv244@cam.ac.uk>\n-  INTEGER :: i, st1, st2, st3\n+!\n+! Modified 20051110 to check that regressions PR24655 and PR24755\n+! are fixed. Thanks to pavarini@pv.infn.it and tdeutsch@cea.fr for\n+! the tests.\n+!\n+  INTEGER :: i, st1, st2, st3, lambda, n\n   REAL :: x, z(2,2)\n-  character*8 :: ch\n+  character(8) :: ch\n+  real(8)   :: fi, arg, sigma, dshpfunc\n+  real(8), parameter :: one=1d0\n !\n ! Test check for recursion via other statement functions, string\n ! length references, function actual arguments and array index\n ! references.\n-  st1(i)=len(ch(st2(1):8))\n-  st2(i)=max (st3(1), 4)\n-  st3(i)=2 + cos (z(st1 (1), i)) ! { dg-error \"is recursive\" }\n-  write(6,*) st1(1)\n+!\n+  st1 (i) = len (ch(st2 (1):8))\n+  st2 (i) = max (st3 (1), 4)\n+  st3 (i) = 2 + cos (z(st1 (1), i)) ! { dg-error \"is recursive\" }\n+!\n+! Test the two regressions.\n+!\n+  fi (n) = n *one\n+  dshpfunc (arg)=-lambda/sigma*(arg/sigma)**(lambda-1)*exp(-(arg/sigma)**lambda)\n+!\n+! References to each statement function.\n+!\n+  write(6,*) st1 (1), fi (2), dshpfunc (1.0_8)\n   END\n "}]}