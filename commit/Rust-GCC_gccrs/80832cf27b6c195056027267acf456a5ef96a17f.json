{"sha": "80832cf27b6c195056027267acf456a5ef96a17f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODA4MzJjZjI3YjZjMTk1MDU2MDI3MjY3YWNmNDU2YTVlZjk2YTE3Zg==", "commit": {"author": {"name": "Herman A.J. ten Brugge", "email": "Haj.Ten.Brugge@net.HCC.nl", "date": "1999-08-07T05:57:14Z"}, "committer": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "1999-08-07T05:57:14Z"}, "message": "1999-08-6 Herman A.J. ten Brugge <Haj.Ten.Brugge@net.HCC.nl>\n\n        * reg-stack.c (change_stack) Fixed problem with negative array index.\n\nFrom-SVN: r28570", "tree": {"sha": "f9660b0a6b176dac536e61aba9f91664b7356576", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f9660b0a6b176dac536e61aba9f91664b7356576"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/80832cf27b6c195056027267acf456a5ef96a17f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/80832cf27b6c195056027267acf456a5ef96a17f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/80832cf27b6c195056027267acf456a5ef96a17f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/80832cf27b6c195056027267acf456a5ef96a17f/comments", "author": null, "committer": null, "parents": [{"sha": "76632dd06d3c245c25f5c20b3606787b27d36c9e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/76632dd06d3c245c25f5c20b3606787b27d36c9e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/76632dd06d3c245c25f5c20b3606787b27d36c9e"}], "stats": {"total": 57, "additions": 32, "deletions": 25}, "files": [{"sha": "6eaa20f4fc5219725e311ffef4117e0c82eaa959", "filename": "gcc/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/80832cf27b6c195056027267acf456a5ef96a17f/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/80832cf27b6c195056027267acf456a5ef96a17f/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=80832cf27b6c195056027267acf456a5ef96a17f", "patch": "@@ -1,3 +1,7 @@\n+1999-08-6 Herman A.J. ten Brugge <Haj.Ten.Brugge@net.HCC.nl>\n+\n+\t* reg-stack.c (change_stack) Fixed problem with negative array index.\n+\n Fri Aug  6 23:08:44 1999  Jeffrey A Law  (law@cygnus.com)\n \n \t* extend.texi, install.texi: Fix spelling mistakes."}, {"sha": "dd4a87e697cdada17e85db0b62aa2d80c6fe0b4a", "filename": "gcc/reg-stack.c", "status": "modified", "additions": 28, "deletions": 25, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/80832cf27b6c195056027267acf456a5ef96a17f/gcc%2Freg-stack.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/80832cf27b6c195056027267acf456a5ef96a17f/gcc%2Freg-stack.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freg-stack.c?ref=80832cf27b6c195056027267acf456a5ef96a17f", "patch": "@@ -2640,43 +2640,46 @@ change_stack (insn, old, new, when)\n       if (old->top != new->top)\n \tabort ();\n \n-      /* Loop here emitting swaps until the stack is correct.  The\n-\t worst case number of swaps emitted is N + 2, where N is the\n+      /* If the stack is not empty (new->top != -1), loop here emitting\n+\t swaps until the stack is correct. \n+\n+\t The worst case number of swaps emitted is N + 2, where N is the\n \t depth of the stack.  In some cases, the reg at the top of\n \t stack may be correct, but swapped anyway in order to fix\n \t other regs.  But since we never swap any other reg away from\n \t its correct slot, this algorithm will converge.  */\n \n-      do\n-\t{\n-\t  /* Swap the reg at top of stack into the position it is\n-\t     supposed to be in, until the correct top of stack appears.  */\n+      if (new->top != -1)\n+\tdo\n+\t  {\n+\t    /* Swap the reg at top of stack into the position it is\n+\t       supposed to be in, until the correct top of stack appears.  */\n \n-\t  while (old->reg[old->top] != new->reg[new->top])\n-\t    {\n-\t      for (reg = new->top; reg >= 0; reg--)\n-\t\tif (new->reg[reg] == old->reg[old->top])\n-\t\t  break;\n+\t    while (old->reg[old->top] != new->reg[new->top])\n+\t      {\n+\t\tfor (reg = new->top; reg >= 0; reg--)\n+\t\t  if (new->reg[reg] == old->reg[old->top])\n+\t\t    break;\n \n-\t      if (reg == -1)\n-\t\tabort ();\n+\t\tif (reg == -1)\n+\t\t  abort ();\n \n-\t      emit_swap_insn (insn, old,\n-\t\t\t      FP_MODE_REG (old->reg[reg], DFmode));\n-\t    }\n+\t\temit_swap_insn (insn, old,\n+\t\t\t\tFP_MODE_REG (old->reg[reg], DFmode));\n+\t      }\n \n-\t  /* See if any regs remain incorrect.  If so, bring an\n+\t    /* See if any regs remain incorrect.  If so, bring an\n \t     incorrect reg to the top of stack, and let the while loop\n \t     above fix it.  */\n \n-\t  for (reg = new->top; reg >= 0; reg--)\n-\t    if (new->reg[reg] != old->reg[reg])\n-\t      {\n-\t\temit_swap_insn (insn, old,\n-\t\t\t\tFP_MODE_REG (old->reg[reg], DFmode));\n-\t\tbreak;\n-\t      }\n-\t} while (reg >= 0);\n+\t    for (reg = new->top; reg >= 0; reg--)\n+\t      if (new->reg[reg] != old->reg[reg])\n+\t\t{\n+\t\t  emit_swap_insn (insn, old,\n+\t\t\t\t  FP_MODE_REG (old->reg[reg], DFmode));\n+\t\t  break;\n+\t\t}\n+\t  } while (reg >= 0);\n \n       /* At this point there must be no differences.  */\n "}]}