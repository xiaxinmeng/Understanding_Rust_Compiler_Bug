{"sha": "19c93809c274015f25db9856ffdfb40df3a828ab", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTljOTM4MDljMjc0MDE1ZjI1ZGI5ODU2ZmZkZmI0MGRmM2E4MjhhYg==", "commit": {"author": {"name": "Kito Cheng", "email": "kito.cheng@gmail.com", "date": "2018-05-20T07:23:39Z"}, "committer": {"name": "Chung-Ju Wu", "email": "jasonwucj@gcc.gnu.org", "date": "2018-05-20T07:23:39Z"}, "message": "[NDS32] Rewrite cost model.\n\ngcc/\n\t* config/nds32/nds32-cost.c (rtx_cost_model_t): New structure.\n\t(insn_size_16bit, insn_size_32bit): New variables for cost evaluation.\n\t(nds32_rtx_costs_impl): Simplify.\n\t(nds32_address_cost_impl): Simplify.\n\t(nds32_init_rtx_costs): New function.\n\t(nds32_rtx_costs_speed_prefer): Likewise.\n\t(nds32_rtx_costs_size_prefer): Likewise.\n\t(nds32_address_cost_speed_prefer): Likewise.\n\t(nds32_address_cost_speed_fwprop): Likewise.\n\t(nds32_address_cost_size_prefer): Likewise.\n\t* config/nds32/nds32-protos.h (nds32_init_rtx_costs): Declare.\n\t* config/nds32/nds32.c (nds32_option_override): Use\n\tnds32_init_rtx_costs function.\n\nCo-Authored-By: Chung-Ju Wu <jasonwucj@gmail.com>\n\nFrom-SVN: r260411", "tree": {"sha": "d2f91bea2615a61a6a77d8c4aae5eb01e6188c0c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d2f91bea2615a61a6a77d8c4aae5eb01e6188c0c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/19c93809c274015f25db9856ffdfb40df3a828ab", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/19c93809c274015f25db9856ffdfb40df3a828ab", "html_url": "https://github.com/Rust-GCC/gccrs/commit/19c93809c274015f25db9856ffdfb40df3a828ab", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/19c93809c274015f25db9856ffdfb40df3a828ab/comments", "author": {"login": "kito-cheng", "id": 2723185, "node_id": "MDQ6VXNlcjI3MjMxODU=", "avatar_url": "https://avatars.githubusercontent.com/u/2723185?v=4", "gravatar_id": "", "url": "https://api.github.com/users/kito-cheng", "html_url": "https://github.com/kito-cheng", "followers_url": "https://api.github.com/users/kito-cheng/followers", "following_url": "https://api.github.com/users/kito-cheng/following{/other_user}", "gists_url": "https://api.github.com/users/kito-cheng/gists{/gist_id}", "starred_url": "https://api.github.com/users/kito-cheng/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/kito-cheng/subscriptions", "organizations_url": "https://api.github.com/users/kito-cheng/orgs", "repos_url": "https://api.github.com/users/kito-cheng/repos", "events_url": "https://api.github.com/users/kito-cheng/events{/privacy}", "received_events_url": "https://api.github.com/users/kito-cheng/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "b5535ac221b936706dd159497703817d75ea18a0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b5535ac221b936706dd159497703817d75ea18a0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b5535ac221b936706dd159497703817d75ea18a0"}], "stats": {"total": 627, "additions": 560, "deletions": 67}, "files": [{"sha": "63e5c66865981ce22a9d44cf707187ed7bddb26b", "filename": "gcc/ChangeLog", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/19c93809c274015f25db9856ffdfb40df3a828ab/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/19c93809c274015f25db9856ffdfb40df3a828ab/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=19c93809c274015f25db9856ffdfb40df3a828ab", "patch": "@@ -1,3 +1,20 @@\n+2018-05-20  Kito Cheng  <kito.cheng@gmail.com>\n+\t    Chung-Ju Wu  <jasonwucj@gmail.com>\n+\n+\t* config/nds32/nds32-cost.c (rtx_cost_model_t): New structure.\n+\t(insn_size_16bit, insn_size_32bit): New variables for cost evaluation.\n+\t(nds32_rtx_costs_impl): Simplify.\n+\t(nds32_address_cost_impl): Simplify.\n+\t(nds32_init_rtx_costs): New function.\n+\t(nds32_rtx_costs_speed_prefer): Likewise.\n+\t(nds32_rtx_costs_size_prefer): Likewise.\n+\t(nds32_address_cost_speed_prefer): Likewise.\n+\t(nds32_address_cost_speed_fwprop): Likewise.\n+\t(nds32_address_cost_size_prefer): Likewise.\n+\t* config/nds32/nds32-protos.h (nds32_init_rtx_costs): Declare.\n+\t* config/nds32/nds32.c (nds32_option_override): Use\n+\tnds32_init_rtx_costs function.\n+\n 2018-05-20  Chung-Ju Wu  <jasonwucj@gmail.com>\n \n \t* config/nds32/nds32.c (nds32_asm_file_start): Output pipeline model."}, {"sha": "979000fcc45b255a45a32ee725af56b43fcc95de", "filename": "gcc/config/nds32/nds32-cost.c", "status": "modified", "additions": 541, "deletions": 67, "changes": 608, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/19c93809c274015f25db9856ffdfb40df3a828ab/gcc%2Fconfig%2Fnds32%2Fnds32-cost.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/19c93809c274015f25db9856ffdfb40df3a828ab/gcc%2Fconfig%2Fnds32%2Fnds32-cost.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fnds32%2Fnds32-cost.c?ref=19c93809c274015f25db9856ffdfb40df3a828ab", "patch": "@@ -34,66 +34,379 @@\n #include \"optabs.h\"\t\t/* For GEN_FCN.  */\n #include \"recog.h\"\n #include \"tm-constrs.h\"\n+#include \"tree-pass.h\"\n \n /* ------------------------------------------------------------------------ */\n \n-bool\n-nds32_rtx_costs_impl (rtx x,\n-\t\t      machine_mode mode ATTRIBUTE_UNUSED,\n-\t\t      int outer_code,\n-\t\t      int opno ATTRIBUTE_UNUSED,\n-\t\t      int *total,\n-\t\t      bool speed)\n-{\n-  int code = GET_CODE (x);\n+typedef bool (*rtx_cost_func) (rtx, int, int, int, int*);\n \n-  /* According to 'speed', goto suitable cost model section.  */\n-  if (speed)\n-    goto performance_cost;\n-  else\n-    goto size_cost;\n+struct rtx_cost_model_t {\n+  rtx_cost_func speed_prefer;\n+  rtx_cost_func size_prefer;\n+};\n \n+static rtx_cost_model_t rtx_cost_model;\n \n-performance_cost:\n-  /* This is section for performance cost model.  */\n+static int insn_size_16bit; /* Initial at nds32_init_rtx_costs.  */\n+static const int insn_size_32bit = 4;\n+\n+static bool\n+nds32_rtx_costs_speed_prefer (rtx x ATTRIBUTE_UNUSED,\n+\t\t\t      int code,\n+\t\t\t      int outer_code ATTRIBUTE_UNUSED,\n+\t\t\t      int opno ATTRIBUTE_UNUSED,\n+\t\t\t      int *total)\n+{\n+  rtx op0;\n+  rtx op1;\n+  machine_mode mode = GET_MODE (x);\n+  /* Scale cost by mode size.  */\n+  int cost = COSTS_N_INSNS (GET_MODE_SIZE (mode) / GET_MODE_SIZE (SImode));\n \n-  /* In gcc/rtl.h, the default value of COSTS_N_INSNS(N) is N*4.\n-     We treat it as 4-cycle cost for each instruction\n-     under performance consideration.  */\n   switch (code)\n     {\n-    case SET:\n-      /* For 'SET' rtx, we need to return false\n-         so that it can recursively calculate costs.  */\n-      return false;\n-\n     case USE:\n       /* Used in combine.c as a marker.  */\n       *total = 0;\n-      break;\n+      return true;\n+\n+    case CONST_INT:\n+      /* When not optimizing for size, we care more about the cost\n+\t of hot code, and hot code is often in a loop.  If a constant\n+\t operand needs to be forced into a register, we will often be\n+\t able to hoist the constant load out of the loop, so the load\n+\t should not contribute to the cost.  */\n+      if (outer_code == SET || outer_code == PLUS)\n+\t*total = satisfies_constraint_Is20 (x) ? 0 : 4;\n+      else if (outer_code == AND || outer_code == IOR || outer_code == XOR\n+\t       || outer_code == MINUS)\n+\t*total = satisfies_constraint_Iu15 (x) ? 0 : 4;\n+      else if (outer_code == ASHIFT || outer_code == ASHIFTRT\n+\t       || outer_code == LSHIFTRT)\n+\t*total = satisfies_constraint_Iu05 (x) ? 0 : 4;\n+      else if (GET_RTX_CLASS (outer_code) == RTX_COMPARE\n+\t       || GET_RTX_CLASS (outer_code) == RTX_COMM_COMPARE)\n+\t*total = satisfies_constraint_Is16 (x) ? 0 : 4;\n+      else\n+\t*total = COSTS_N_INSNS (1);\n+      return true;\n+\n+    case CONST:\n+    case LO_SUM:\n+    case HIGH:\n+    case SYMBOL_REF:\n+      *total = COSTS_N_INSNS (1);\n+      return true;\n+\n+    case MEM:\n+      *total = COSTS_N_INSNS (1);\n+      return true;\n+\n+    case SET:\n+      op0 = SET_DEST (x);\n+      op1 = SET_SRC (x);\n+      mode = GET_MODE (op0);\n+      /* Scale cost by mode size.  */\n+      cost = COSTS_N_INSNS (GET_MODE_SIZE (mode) / GET_MODE_SIZE (SImode));\n+\n+      switch (GET_CODE (op1))\n+\t{\n+\tcase REG:\n+\tcase SUBREG:\n+\t  /* Register move and Store instructions.  */\n+\t  if ((REG_P (op0) || MEM_P (op0))\n+\t      && GET_MODE_SIZE (mode) <= GET_MODE_SIZE (DImode))\n+\t    *total = COSTS_N_INSNS (1);\n+\t  else\n+\t    *total = cost;\n+\t  return true;\n+\n+\tcase MEM:\n+\t  /* Load instructions.  */\n+\t  if (REG_P (op0) && GET_MODE_SIZE (mode) <= GET_MODE_SIZE (DImode))\n+\t    *total = COSTS_N_INSNS (1);\n+\t  else\n+\t    *total = cost;\n+\t  return true;\n+\n+\tcase CONST_INT:\n+\t  /* movi instruction.  */\n+\t  if (REG_P (op0) && GET_MODE_SIZE (mode) < GET_MODE_SIZE (DImode))\n+\t    {\n+\t      if (satisfies_constraint_Is20 (op1))\n+\t\t*total = COSTS_N_INSNS (1) - 1;\n+\t      else\n+\t\t*total = COSTS_N_INSNS (2);\n+\t    }\n+\t  else\n+\t    *total = cost;\n+\t  return true;\n+\n+\tcase CONST:\n+\tcase SYMBOL_REF:\n+\tcase LABEL_REF:\n+\t  /* la instruction.  */\n+\t  if (REG_P (op0) && GET_MODE_SIZE (mode) < GET_MODE_SIZE (DImode))\n+\t    *total = COSTS_N_INSNS (1) - 1;\n+\t  else\n+\t    *total = cost;\n+\t  return true;\n+\tcase VEC_SELECT:\n+\t  *total = cost;\n+\t  return true;\n+\n+\tdefault:\n+\t  *total = cost;\n+\t  return true;\n+\t}\n+\n+    case PLUS:\n+      op0 = XEXP (x, 0);\n+      op1 = XEXP (x, 1);\n+\n+      if (GET_MODE_SIZE (mode) >= GET_MODE_SIZE (DImode))\n+\t*total = cost;\n+      else if (GET_CODE (op0) == MULT || GET_CODE (op0) == LSHIFTRT\n+\t       || GET_CODE (op1) == MULT || GET_CODE (op1) == LSHIFTRT)\n+\t/* ALU_SHIFT */\n+\t*total = COSTS_N_INSNS (2);\n+\n+      else if ((GET_CODE (op1) == CONST_INT\n+\t\t&& satisfies_constraint_Is15 (op1))\n+\t\t|| REG_P (op1))\n+\t/* ADD instructions */\n+\t*total = COSTS_N_INSNS (1);\n+      else\n+\t/* ADD instructions: IMM out of range.  */\n+\t*total = COSTS_N_INSNS (2);\n+      return true;\n+\n+    case MINUS:\n+      op0 = XEXP (x, 0);\n+      op1 = XEXP (x, 1);\n+\n+      if (GET_MODE_SIZE (mode) >= GET_MODE_SIZE (DImode))\n+\t*total = cost;\n+      else if (GET_CODE (op0) == MULT || GET_CODE (op0) == LSHIFTRT\n+\t       || GET_CODE (op1) == MULT || GET_CODE (op1) == LSHIFTRT)\n+\t/* ALU_SHIFT */\n+\t*total = COSTS_N_INSNS (2);\n+      else if ((GET_CODE (op0) == CONST_INT\n+\t\t&& satisfies_constraint_Is15 (op0))\n+\t\t|| REG_P (op0))\n+\t/* SUB instructions */\n+\t*total = COSTS_N_INSNS (1);\n+      else\n+\t/* SUB instructions: IMM out of range.  */\n+\t*total = COSTS_N_INSNS (2);\n+      return true;\n+\n+    case TRUNCATE:\n+      /* TRUNCATE and AND behavior is same. */\n+      *total = COSTS_N_INSNS (1);\n+      return true;\n+\n+    case AND:\n+    case IOR:\n+    case XOR:\n+      op0 = XEXP (x, 0);\n+      op1 = XEXP (x, 1);\n+\n+      if (NDS32_EXT_DSP_P ())\n+\t{\n+\t  /* We prefer (and (ior) (ior)) than (ior (and) (and)) for\n+\t     synthetize pk** and insb instruction.  */\n+\t  if (code == AND && GET_CODE (op0) == IOR && GET_CODE (op1) == IOR)\n+\t    return COSTS_N_INSNS (1);\n+\n+\t  if (code == IOR && GET_CODE (op0) == AND && GET_CODE (op1) == AND)\n+\t    return COSTS_N_INSNS (10);\n+\t}\n+\n+      if (GET_MODE_SIZE (mode) >= GET_MODE_SIZE (DImode))\n+\t*total = cost;\n+      else if (GET_CODE (op0) == ASHIFT || GET_CODE (op0) == LSHIFTRT)\n+\t*total = COSTS_N_INSNS (2);\n+      else if ((GET_CODE (op1) == CONST_INT\n+\t       && satisfies_constraint_Iu15 (op1))\n+\t       || REG_P (op1))\n+\t/* AND, OR, XOR instructions */\n+\t*total = COSTS_N_INSNS (1);\n+      else if (code == AND || GET_CODE (op0) == NOT)\n+\t/* BITC instruction */\n+\t*total = COSTS_N_INSNS (1);\n+      else\n+\t/* AND, OR, XOR instructions: IMM out of range.  */\n+\t*total = COSTS_N_INSNS (2);\n+      return true;\n \n     case MULT:\n+      if (GET_MODE (x) == DImode\n+\t  || GET_CODE (XEXP (x, 1)) == SIGN_EXTEND\n+\t  || GET_CODE (XEXP (x, 1)) == ZERO_EXTEND)\n+\t/* MUL instructions */\n+\t*total = COSTS_N_INSNS (1);\n+      else if (GET_MODE_SIZE (mode) >= GET_MODE_SIZE (DImode))\n+\t*total = cost;\n+      else if (outer_code == PLUS || outer_code == MINUS)\n+\t*total = COSTS_N_INSNS (2);\n+      else if ((GET_CODE (XEXP (x, 1)) == CONST_INT\n+\t       && satisfies_constraint_Iu05 (XEXP (x, 1)))\n+\t       || REG_P (XEXP (x, 1)))\n+\t/* MUL instructions */\n+\t*total = COSTS_N_INSNS (1);\n+      else\n+\t/* MUL instructions: IMM out of range.  */\n+\t*total = COSTS_N_INSNS (2);\n+\n+      if (TARGET_MUL_SLOW)\n+\t*total += COSTS_N_INSNS (4);\n+\n+      return true;\n+\n+    case LSHIFTRT:\n+      if (GET_MODE_SIZE (mode) >= GET_MODE_SIZE (DImode))\n+\t*total = cost;\n+      else if (outer_code == PLUS || outer_code == MINUS\n+\t       || outer_code == AND || outer_code == IOR\n+\t       || outer_code == XOR)\n+\t*total = COSTS_N_INSNS (2);\n+      else if ((GET_CODE (XEXP (x, 1)) == CONST_INT\n+\t       && satisfies_constraint_Iu05 (XEXP (x, 1)))\n+\t       || REG_P (XEXP (x, 1)))\n+\t/* SRL instructions */\n+\t*total = COSTS_N_INSNS (1);\n+      else\n+\t/* SRL instructions: IMM out of range.  */\n+\t*total = COSTS_N_INSNS (2);\n+      return true;\n+\n+    case ASHIFT:\n+      if (GET_MODE_SIZE (mode) >= GET_MODE_SIZE (DImode))\n+\t*total = cost;\n+      else if (outer_code == AND || outer_code == IOR\n+\t       || outer_code == XOR)\n+\t*total = COSTS_N_INSNS (2);\n+      else if ((GET_CODE (XEXP (x, 1)) == CONST_INT\n+\t       && satisfies_constraint_Iu05 (XEXP (x, 1)))\n+\t       || REG_P (XEXP (x, 1)))\n+\t/* SLL instructions */\n+\t*total = COSTS_N_INSNS (1);\n+      else\n+\t/* SLL instructions: IMM out of range.  */\n+\t*total = COSTS_N_INSNS (2);\n+      return true;\n+\n+    case ASHIFTRT:\n+    case ROTATERT:\n+      if (GET_MODE_SIZE (mode) >= GET_MODE_SIZE (DImode))\n+\t*total = cost;\n+      else if ((GET_CODE (XEXP (x, 1)) == CONST_INT\n+\t       && satisfies_constraint_Iu05 (XEXP (x, 1)))\n+\t       || REG_P (XEXP (x, 1)))\n+\t/* ROTR, SLL instructions */\n+\t*total = COSTS_N_INSNS (1);\n+      else\n+\t/* ROTR, SLL instructions: IMM out of range.  */\n+\t*total = COSTS_N_INSNS (2);\n+      return true;\n+\n+    case LT:\n+    case LTU:\n+      if (outer_code == SET)\n+\t{\n+\t  if ((GET_CODE (XEXP (x, 1)) == CONST_INT\n+\t      && satisfies_constraint_Iu15 (XEXP (x, 1)))\n+\t      || REG_P (XEXP (x, 1)))\n+\t    /* SLT, SLTI instructions */\n+\t    *total = COSTS_N_INSNS (1);\n+\t  else\n+\t    /* SLT, SLT instructions: IMM out of range.  */\n+\t    *total = COSTS_N_INSNS (2);\n+\t}\n+      else\n+\t/* branch */\n+\t*total = COSTS_N_INSNS (2);\n+      return true;\n+\n+    case EQ:\n+    case NE:\n+    case GE:\n+    case LE:\n+    case GT:\n+      /* branch */\n+      *total = COSTS_N_INSNS (2);\n+      return true;\n+\n+    case IF_THEN_ELSE:\n+      if (GET_CODE (XEXP (x, 1)) == LABEL_REF)\n+\t/* branch */\n+\t*total = COSTS_N_INSNS (2);\n+      else\n+\t/* cmovz, cmovn instructions */\n+\t*total = COSTS_N_INSNS (1);\n+      return true;\n+\n+    case LABEL_REF:\n+      if (outer_code == IF_THEN_ELSE)\n+\t/* branch */\n+\t*total = COSTS_N_INSNS (2);\n+      else\n+\t*total = COSTS_N_INSNS (1);\n+      return true;\n+\n+    case ZERO_EXTEND:\n+    case SIGN_EXTEND:\n+      if (MEM_P (XEXP (x, 0)))\n+\t/* Using memory access. */\n+\t*total = COSTS_N_INSNS (1);\n+      else\n+\t/* Zero extend and sign extend instructions.  */\n+\t*total = COSTS_N_INSNS (1);\n+      return true;\n+\n+    case NEG:\n+    case NOT:\n       *total = COSTS_N_INSNS (1);\n-      break;\n+      return true;\n \n     case DIV:\n     case UDIV:\n     case MOD:\n     case UMOD:\n-      *total = COSTS_N_INSNS (7);\n-      break;\n+      *total = COSTS_N_INSNS (20);\n+      return true;\n \n-    default:\n+    case CALL:\n+      *total = COSTS_N_INSNS (2);\n+      return true;\n+\n+    case CLZ:\n+    case SMIN:\n+    case SMAX:\n+    case ZERO_EXTRACT:\n+      if (TARGET_EXT_PERF)\n+\t*total = COSTS_N_INSNS (1);\n+      else\n+\t*total = COSTS_N_INSNS (3);\n+      return true;\n+    case VEC_SELECT:\n       *total = COSTS_N_INSNS (1);\n-      break;\n-    }\n-\n-  return true;\n+      return true;\n \n+    default:\n+      *total = COSTS_N_INSNS (3);\n+      return true;\n+    }\n+}\n \n-size_cost:\n-  /* This is section for size cost model.  */\n-\n+static bool\n+nds32_rtx_costs_size_prefer (rtx x,\n+\t\t\t     int code,\n+\t\t\t     int outer_code,\n+\t\t\t     int opno ATTRIBUTE_UNUSED,\n+\t\t\t     int *total)\n+{\n   /* In gcc/rtl.h, the default value of COSTS_N_INSNS(N) is N*4.\n      We treat it as 4-byte cost for each instruction\n      under code size consideration.  */\n@@ -118,85 +431,162 @@ nds32_rtx_costs_impl (rtx x,\n \t     (set X imm20s), use movi, 4-byte cost.\n \t     (set X BIG_INT), use sethi/ori, 8-byte cost.  */\n \t  if (satisfies_constraint_Is05 (x))\n-\t    *total = COSTS_N_INSNS (1) - 2;\n+\t    *total = insn_size_16bit;\n \t  else if (satisfies_constraint_Is20 (x))\n-\t    *total = COSTS_N_INSNS (1);\n+\t    *total = insn_size_32bit;\n \t  else\n-\t    *total = COSTS_N_INSNS (2);\n+\t    *total = insn_size_32bit * 2;\n \t}\n       else if (outer_code == PLUS || outer_code == MINUS)\n \t{\n \t  /* Possible addi333/subi333 or subi45/addi45, 2-byte cost.\n \t     General case, cost 1 instruction with 4-byte.  */\n \t  if (satisfies_constraint_Iu05 (x))\n-\t    *total = COSTS_N_INSNS (1) - 2;\n+\t    *total = insn_size_16bit;\n \t  else\n-\t    *total = COSTS_N_INSNS (1);\n+\t    *total = insn_size_32bit;\n \t}\n       else if (outer_code == ASHIFT)\n \t{\n \t  /* Possible slli333, 2-byte cost.\n \t     General case, cost 1 instruction with 4-byte.  */\n \t  if (satisfies_constraint_Iu03 (x))\n-\t    *total = COSTS_N_INSNS (1) - 2;\n+\t    *total = insn_size_16bit;\n \t  else\n-\t    *total = COSTS_N_INSNS (1);\n+\t    *total = insn_size_32bit;\n \t}\n       else if (outer_code == ASHIFTRT || outer_code == LSHIFTRT)\n \t{\n \t  /* Possible srai45 or srli45, 2-byte cost.\n \t     General case, cost 1 instruction with 4-byte.  */\n \t  if (satisfies_constraint_Iu05 (x))\n-\t    *total = COSTS_N_INSNS (1) - 2;\n+\t    *total = insn_size_16bit;\n \t  else\n-\t    *total = COSTS_N_INSNS (1);\n+\t    *total = insn_size_32bit;\n \t}\n       else\n \t{\n \t  /* For other cases, simply set it 4-byte cost.  */\n-\t  *total = COSTS_N_INSNS (1);\n+\t  *total = insn_size_32bit;\n \t}\n       break;\n \n     case CONST_DOUBLE:\n       /* It requires high part and low part processing, set it 8-byte cost.  */\n-      *total = COSTS_N_INSNS (2);\n+      *total = insn_size_32bit * 2;\n+      break;\n+\n+    case CONST:\n+    case SYMBOL_REF:\n+      *total = insn_size_32bit * 2;\n       break;\n \n     default:\n       /* For other cases, generally we set it 4-byte cost\n-         and stop resurively traversing.  */\n-      *total = COSTS_N_INSNS (1);\n+\t and stop resurively traversing.  */\n+      *total = insn_size_32bit;\n       break;\n     }\n \n   return true;\n }\n \n-int\n-nds32_address_cost_impl (rtx address,\n-\t\t\t machine_mode mode ATTRIBUTE_UNUSED,\n-\t\t\t addr_space_t as ATTRIBUTE_UNUSED,\n-\t\t\t bool speed)\n+void\n+nds32_init_rtx_costs (void)\n+{\n+  rtx_cost_model.speed_prefer = nds32_rtx_costs_speed_prefer;\n+  rtx_cost_model.size_prefer  = nds32_rtx_costs_size_prefer;\n+\n+  if (TARGET_16_BIT)\n+    insn_size_16bit = 2;\n+  else\n+    insn_size_16bit = 4;\n+}\n+\n+/* This target hook describes the relative costs of RTL expressions.\n+   Return 'true' when all subexpressions of x have been processed.\n+   Return 'false' to sum the costs of sub-rtx, plus cost of this operation.\n+   Refer to gcc/rtlanal.c for more information.  */\n+bool\n+nds32_rtx_costs_impl (rtx x,\n+\t\t      machine_mode mode ATTRIBUTE_UNUSED,\n+\t\t      int outer_code,\n+\t\t      int opno,\n+\t\t      int *total,\n+\t\t      bool speed)\n+{\n+  int code = GET_CODE (x);\n+\n+  /* According to 'speed', use suitable cost model section.  */\n+  if (speed)\n+    return rtx_cost_model.speed_prefer(x, code, outer_code, opno, total);\n+  else\n+    return rtx_cost_model.size_prefer(x, code, outer_code, opno, total);\n+}\n+\n+\n+int nds32_address_cost_speed_prefer (rtx address)\n {\n   rtx plus0, plus1;\n   enum rtx_code code;\n \n   code = GET_CODE (address);\n \n-  /* According to 'speed', goto suitable cost model section.  */\n-  if (speed)\n-    goto performance_cost;\n-  else\n-    goto size_cost;\n+  switch (code)\n+    {\n+    case POST_MODIFY:\n+    case POST_INC:\n+    case POST_DEC:\n+      /* We encourage that rtx contains\n+\t POST_MODIFY/POST_INC/POST_DEC behavior.  */\n+      return COSTS_N_INSNS (1) - 2;\n+\n+    case SYMBOL_REF:\n+      /* We can have gp-relative load/store for symbol_ref.\n+\tHave it 4-byte cost.  */\n+      return COSTS_N_INSNS (2);\n+\n+    case CONST:\n+      /* It is supposed to be the pattern (const (plus symbol_ref const_int)).\n+\t Have it 4-byte cost.  */\n+      return COSTS_N_INSNS (2);\n+\n+    case REG:\n+      /* Simply return 4-byte costs.  */\n+      return COSTS_N_INSNS (1) - 2;\n+\n+    case PLUS:\n+      /* We do not need to check if the address is a legitimate address,\n+\t because this hook is never called with an invalid address.\n+\t But we better check the range of\n+\t const_int value for cost, if it exists.  */\n+      plus0 = XEXP (address, 0);\n+      plus1 = XEXP (address, 1);\n+\n+      if (REG_P (plus0) && CONST_INT_P (plus1))\n+\treturn COSTS_N_INSNS (1) - 2;\n+      else if (ARITHMETIC_P (plus0) || ARITHMETIC_P (plus1))\n+\treturn COSTS_N_INSNS (1) - 1;\n+      else if (REG_P (plus0) && REG_P (plus1))\n+\treturn COSTS_N_INSNS (1);\n+\n+      /* For other 'plus' situation, make it cost 4-byte.  */\n+      return COSTS_N_INSNS (1);\n+\n+    default:\n+      break;\n+    }\n+\n+  return COSTS_N_INSNS (4);\n \n-performance_cost:\n-  /* This is section for performance cost model.  */\n+}\n \n-  /* FALLTHRU, currently we use same cost model as size_cost.  */\n+int nds32_address_cost_speed_fwprop (rtx address)\n+{\n+  rtx plus0, plus1;\n+  enum rtx_code code;\n \n-size_cost:\n-  /* This is section for size cost model.  */\n+  code = GET_CODE (address);\n \n   switch (code)\n     {\n@@ -210,12 +600,12 @@ nds32_address_cost_impl (rtx address,\n     case SYMBOL_REF:\n       /* We can have gp-relative load/store for symbol_ref.\n \t Have it 4-byte cost.  */\n-      return COSTS_N_INSNS (1);\n+      return COSTS_N_INSNS (2);\n \n     case CONST:\n       /* It is supposed to be the pattern (const (plus symbol_ref const_int)).\n \t Have it 4-byte cost.  */\n-      return COSTS_N_INSNS (1);\n+      return COSTS_N_INSNS (2);\n \n     case REG:\n       /* Simply return 4-byte costs.  */\n@@ -233,11 +623,15 @@ nds32_address_cost_impl (rtx address,\n \t{\n \t  /* If it is possible to be lwi333/swi333 form,\n \t     make it 2-byte cost.  */\n-\t  if (satisfies_constraint_Iu05 (plus1))\n+\t  if (satisfies_constraint_Iu03 (plus1))\n \t    return (COSTS_N_INSNS (1) - 2);\n \t  else\n \t    return COSTS_N_INSNS (1);\n \t}\n+      if (ARITHMETIC_P (plus0) || ARITHMETIC_P (plus1))\n+\treturn COSTS_N_INSNS (1) - 2;\n+      else if (REG_P (plus0) && REG_P (plus1))\n+\treturn COSTS_N_INSNS (1);\n \n       /* For other 'plus' situation, make it cost 4-byte.  */\n       return COSTS_N_INSNS (1);\n@@ -249,4 +643,84 @@ nds32_address_cost_impl (rtx address,\n   return COSTS_N_INSNS (4);\n }\n \n+\n+int nds32_address_cost_size_prefer (rtx address)\n+{\n+  rtx plus0, plus1;\n+  enum rtx_code code;\n+\n+  code = GET_CODE (address);\n+\n+  switch (code)\n+    {\n+    case POST_MODIFY:\n+    case POST_INC:\n+    case POST_DEC:\n+      /* We encourage that rtx contains\n+\t POST_MODIFY/POST_INC/POST_DEC behavior.  */\n+      return 0;\n+\n+    case SYMBOL_REF:\n+      /* We can have gp-relative load/store for symbol_ref.\n+\t Have it 4-byte cost.  */\n+      return COSTS_N_INSNS (2);\n+\n+    case CONST:\n+      /* It is supposed to be the pattern (const (plus symbol_ref const_int)).\n+\t Have it 4-byte cost.  */\n+      return COSTS_N_INSNS (2);\n+\n+    case REG:\n+      /* Simply return 4-byte costs.  */\n+      return COSTS_N_INSNS (1) - 1;\n+\n+    case PLUS:\n+      /* We do not need to check if the address is a legitimate address,\n+\t because this hook is never called with an invalid address.\n+\t But we better check the range of\n+\t const_int value for cost, if it exists.  */\n+      plus0 = XEXP (address, 0);\n+      plus1 = XEXP (address, 1);\n+\n+      if (REG_P (plus0) && CONST_INT_P (plus1))\n+\t{\n+\t  /* If it is possible to be lwi333/swi333 form,\n+\t     make it 2-byte cost.  */\n+\t  if (satisfies_constraint_Iu03 (plus1))\n+\t    return (COSTS_N_INSNS (1) - 2);\n+\t  else\n+\t    return COSTS_N_INSNS (1) - 1;\n+\t}\n+\n+      /* (plus (reg) (mult (reg) (const))) */\n+      if (ARITHMETIC_P (plus0) || ARITHMETIC_P (plus1))\n+\treturn (COSTS_N_INSNS (1) - 1);\n+\n+      /* For other 'plus' situation, make it cost 4-byte.  */\n+      return COSTS_N_INSNS (1);\n+\n+    default:\n+      break;\n+    }\n+\n+  return COSTS_N_INSNS (4);\n+\n+}\n+\n+int nds32_address_cost_impl (rtx address,\n+\t\t\t     machine_mode mode ATTRIBUTE_UNUSED,\n+\t\t\t     addr_space_t as ATTRIBUTE_UNUSED,\n+\t\t\t     bool speed_p)\n+{\n+  if (speed_p)\n+    {\n+      if (current_pass->tv_id == TV_FWPROP)\n+\treturn nds32_address_cost_speed_fwprop (address);\n+      else\n+\treturn nds32_address_cost_speed_prefer (address);\n+    }\n+  else\n+    return nds32_address_cost_size_prefer (address);\n+}\n+\n /* ------------------------------------------------------------------------ */"}, {"sha": "8a93002e09dff5247b75a005a80448889d07d011", "filename": "gcc/config/nds32/nds32-protos.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/19c93809c274015f25db9856ffdfb40df3a828ab/gcc%2Fconfig%2Fnds32%2Fnds32-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/19c93809c274015f25db9856ffdfb40df3a828ab/gcc%2Fconfig%2Fnds32%2Fnds32-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fnds32%2Fnds32-protos.h?ref=19c93809c274015f25db9856ffdfb40df3a828ab", "patch": "@@ -311,6 +311,7 @@ extern bool nds32_isr_function_p (tree);\n \n /* Auxiliary functions for cost calculation.  */\n \n+extern void nds32_init_rtx_costs (void);\n extern bool nds32_rtx_costs_impl (rtx, machine_mode, int, int, int *, bool);\n extern int nds32_address_cost_impl (rtx, machine_mode, addr_space_t, bool);\n "}, {"sha": "ac67ba43de3a9d1a276fc1c1f201b13d15d479b5", "filename": "gcc/config/nds32/nds32.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/19c93809c274015f25db9856ffdfb40df3a828ab/gcc%2Fconfig%2Fnds32%2Fnds32.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/19c93809c274015f25db9856ffdfb40df3a828ab/gcc%2Fconfig%2Fnds32%2Fnds32.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fnds32%2Fnds32.c?ref=19c93809c274015f25db9856ffdfb40df3a828ab", "patch": "@@ -4096,6 +4096,7 @@ nds32_option_override (void)\n \t       \"must be enable '-mext-fpu-sp' or '-mext-fpu-dp'\");\n     }\n \n+  nds32_init_rtx_costs ();\n \n   nds32_register_passes ();\n }"}]}