{"sha": "26383c648f1e2bb6e3e2da84eaa6061159fe3904", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MjYzODNjNjQ4ZjFlMmJiNmUzZTJkYTg0ZWFhNjA2MTE1OWZlMzkwNA==", "commit": {"author": {"name": "Eric Botcazou", "email": "ebotcazou@adacore.com", "date": "2009-04-23T10:22:55Z"}, "committer": {"name": "Eric Botcazou", "email": "ebotcazou@gcc.gnu.org", "date": "2009-04-23T10:22:55Z"}, "message": "ada-tree.h (union lang_tree_node): Use standard idiom.\n\n\t* gcc-interface/ada-tree.h (union lang_tree_node): Use standard idiom.\n\t(SET_TYPE_LANG_SPECIFIC): Likewise.  Fix formatting.\n\t(SET_DECL_LANG_SPECIFIC): Likewise.\n\tReorder macros.\n\t* gcc-interface/decl.c (gnat_to_gnu_entity) <E_Signed_Integer_Subtype>:\n\tUpdate comment about use of build_range_type.\n\t<E_Array_Type, E_Array_Subtype>: Use consistent naming convention.\n\t<E_Array_Subtype>: Rework comments about TYPE_ACTUAL_BOUNDS and add\n\tcheck for other cases of overloading.\n\t* gcc-interface/trans.c (gigi): Use size_int in lieu of build_int_cst.\n\t* gcc-interface/utils2.c (build_call_raise): Fix off-by-one error.\n\tUse size_int in lieu of build_int_cst.\n\t(build_call_alloc_dealloc): Use build_index_2_type in lieu of\n\tbuild_range_type.\n\nFrom-SVN: r146639", "tree": {"sha": "9e425a0292fcfe1ed87343fee372b792fc2df72f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/9e425a0292fcfe1ed87343fee372b792fc2df72f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/26383c648f1e2bb6e3e2da84eaa6061159fe3904", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/26383c648f1e2bb6e3e2da84eaa6061159fe3904", "html_url": "https://github.com/Rust-GCC/gccrs/commit/26383c648f1e2bb6e3e2da84eaa6061159fe3904", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/26383c648f1e2bb6e3e2da84eaa6061159fe3904/comments", "author": null, "committer": null, "parents": [{"sha": "4782dfa72f25706e3276784417630b6d163e784d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4782dfa72f25706e3276784417630b6d163e784d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4782dfa72f25706e3276784417630b6d163e784d"}], "stats": {"total": 229, "additions": 129, "deletions": 100}, "files": [{"sha": "ff047322956d876e94b40f9ca552a967d29dfa11", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/26383c648f1e2bb6e3e2da84eaa6061159fe3904/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/26383c648f1e2bb6e3e2da84eaa6061159fe3904/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=26383c648f1e2bb6e3e2da84eaa6061159fe3904", "patch": "@@ -1,3 +1,20 @@\n+2009-04-23  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\t* gcc-interface/ada-tree.h (union lang_tree_node): Use standard idiom.\n+\t(SET_TYPE_LANG_SPECIFIC): Likewise.  Fix formatting.\n+\t(SET_DECL_LANG_SPECIFIC): Likewise.\n+\tReorder macros.\n+\t* gcc-interface/decl.c (gnat_to_gnu_entity) <E_Signed_Integer_Subtype>:\n+\tUpdate comment about use of build_range_type.\n+\t<E_Array_Type, E_Array_Subtype>: Use consistent naming convention.\n+\t<E_Array_Subtype>: Rework comments about TYPE_ACTUAL_BOUNDS and add\n+\tcheck for other cases of overloading.\n+\t* gcc-interface/trans.c (gigi): Use size_int in lieu of build_int_cst.\n+\t* gcc-interface/utils2.c (build_call_raise): Fix off-by-one error.\n+\tUse size_int in lieu of build_int_cst.\n+\t(build_call_alloc_dealloc): Use build_index_2_type in lieu of\n+\tbuild_range_type.\n+\n 2009-04-22  Eric Botcazou  <ebotcazou@adacore.com>\n \n \t* gcc-interface/utils2.c (build_binary_op) <PLUS_EXPR>: If operation's"}, {"sha": "19c9fa51f2bc8623abfd21b84f3a9dc921da1a32", "filename": "gcc/ada/gcc-interface/ada-tree.h", "status": "modified", "additions": 53, "deletions": 43, "changes": 96, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/26383c648f1e2bb6e3e2da84eaa6061159fe3904/gcc%2Fada%2Fgcc-interface%2Fada-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/26383c648f1e2bb6e3e2da84eaa6061159fe3904/gcc%2Fada%2Fgcc-interface%2Fada-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Fada-tree.h?ref=26383c648f1e2bb6e3e2da84eaa6061159fe3904", "patch": "@@ -23,33 +23,39 @@\n  *                                                                          *\n  ****************************************************************************/\n \n-/* Ada uses the lang_decl and lang_type fields to hold a tree.  */\n+/* The resulting tree type.  */\n union GTY((desc (\"0\"),\n-           chain_next (\"(union lang_tree_node *)TREE_CHAIN (&%h.t)\"))) lang_tree_node\n+\t   chain_next (\"(union lang_tree_node *)TREE_CHAIN (&%h.generic)\")))\n+  lang_tree_node\n {\n-  union tree_node GTY((tag (\"0\"))) t;\n+  union tree_node GTY((tag (\"0\"),\n+\t\t       desc (\"tree_node_structure (&%h)\"))) generic;\n };\n-struct GTY(()) lang_decl {tree t; };\n-struct GTY(()) lang_type {tree t; };\n \n-/* Define macros to get and set the tree in TYPE_ and DECL_LANG_SPECIFIC.  */\n+/* Ada uses the lang_decl and lang_type fields to hold a tree.  */\n+struct GTY(()) lang_type { tree t; };\n+struct GTY(()) lang_decl { tree t; };\n+\n+/* Macros to get and set the tree in TYPE_LANG_SPECIFIC.  */\n #define GET_TYPE_LANG_SPECIFIC(NODE) \\\n   (TYPE_LANG_SPECIFIC (NODE) ? TYPE_LANG_SPECIFIC (NODE)->t : NULL_TREE)\n+\n #define SET_TYPE_LANG_SPECIFIC(NODE, X)\t\\\n- (TYPE_LANG_SPECIFIC (NODE)\t\t\t\\\n-  = (TYPE_LANG_SPECIFIC (NODE)\t\t\t\\\n-     ? TYPE_LANG_SPECIFIC (NODE) : GGC_NEW (struct lang_type))) \\\n- ->t = X;\n+  (TYPE_LANG_SPECIFIC (NODE)\t\t\\\n+   = (TYPE_LANG_SPECIFIC (NODE)\t\t\\\n+      ? TYPE_LANG_SPECIFIC (NODE) : GGC_NEW (struct lang_type)))->t = (X)\n \n+/* Macros to get and set the tree in DECL_LANG_SPECIFIC.  */\n #define GET_DECL_LANG_SPECIFIC(NODE) \\\n   (DECL_LANG_SPECIFIC (NODE) ? DECL_LANG_SPECIFIC (NODE)->t : NULL_TREE)\n-#define SET_DECL_LANG_SPECIFIC(NODE, VALUE)\t\\\n- (DECL_LANG_SPECIFIC (NODE)\t\t\t\\\n-  = (DECL_LANG_SPECIFIC (NODE)\t\t\t\\\n-     ? DECL_LANG_SPECIFIC (NODE) : GGC_NEW (struct lang_decl))) \\\n- ->t = VALUE;\n \n-/* Flags added to GCC type nodes.  */\n+#define SET_DECL_LANG_SPECIFIC(NODE, X)\t\\\n+  (DECL_LANG_SPECIFIC (NODE)\t\t\\\n+   = (DECL_LANG_SPECIFIC (NODE)\t\t\\\n+      ? DECL_LANG_SPECIFIC (NODE) : GGC_NEW (struct lang_decl)))->t = (X)\n+\n+\n+/* Flags added to type nodes.  */\n \n /* For RECORD_TYPE, UNION_TYPE, and QUAL_UNION_TYPE, nonzero if this is a\n    record being used as a fat pointer (only true for RECORD_TYPE).  */\n@@ -161,29 +167,46 @@ struct GTY(()) lang_type {tree t; };\n    mechanism refer to the routine gnat_to_gnu_entity. */\n #define TYPE_CI_CO_LIST(NODE) TYPE_LANG_SLOT_1 (FUNCTION_TYPE_CHECK (NODE))\n \n-/* For integral types, this is the RM Size of the type.  */\n+/* For integral types, this is the RM size of the type.  */\n #define TYPE_RM_SIZE(NODE) \\\n   TYPE_LANG_SLOT_1 (TREE_CHECK3 (NODE, ENUMERAL_TYPE, BOOLEAN_TYPE, INTEGER_TYPE))\n \n+/* In an UNCONSTRAINED_ARRAY_TYPE, points to the record containing both\n+   the template and object.\n+\n+   ??? We also put this on an ENUMERAL_TYPE that's dummy.  Technically,\n+   this is a conflict on the minval field, but there doesn't seem to be\n+   simple fix, so we'll live with this kludge for now.  */\n+#define TYPE_OBJECT_RECORD_TYPE(NODE) \\\n+  (TREE_CHECK2 ((NODE), UNCONSTRAINED_ARRAY_TYPE, ENUMERAL_TYPE)->type.minval)\n+\n /* For an INTEGER_TYPE with TYPE_MODULAR_P, this is the value of the\n    modulus. */\n #define TYPE_MODULUS(NODE) GET_TYPE_LANG_SPECIFIC (INTEGER_TYPE_CHECK (NODE))\n #define SET_TYPE_MODULUS(NODE, X) \\\n   SET_TYPE_LANG_SPECIFIC (INTEGER_TYPE_CHECK (NODE), X)\n \n-/* For an INTEGER_TYPE that is the TYPE_DOMAIN of some ARRAY_TYPE, points to\n+/* For an INTEGER_TYPE with TYPE_VAX_FLOATING_POINT_P, this is the\n+   Digits_Value.  */\n+#define TYPE_DIGITS_VALUE(NODE) \\\n+  GET_TYPE_LANG_SPECIFIC (INTEGER_TYPE_CHECK (NODE))\n+#define SET_TYPE_DIGITS_VALUE(NODE, X) \\\n+  SET_TYPE_LANG_SPECIFIC (INTEGER_TYPE_CHECK (NODE), X)\n+\n+/* For an INTEGER_TYPE that is the TYPE_DOMAIN of some ARRAY_TYPE, this is\n    the type corresponding to the Ada index type.  */\n #define TYPE_INDEX_TYPE(NODE) \\\n   GET_TYPE_LANG_SPECIFIC (INTEGER_TYPE_CHECK (NODE))\n #define SET_TYPE_INDEX_TYPE(NODE, X) \\\n   SET_TYPE_LANG_SPECIFIC (INTEGER_TYPE_CHECK (NODE), X)\n \n-/* For an INTEGER_TYPE with TYPE_VAX_FLOATING_POINT_P, stores the\n-   Digits_Value.  */\n-#define TYPE_DIGITS_VALUE(NODE) \\\n-  GET_TYPE_LANG_SPECIFIC (INTEGER_TYPE_CHECK (NODE))\n-#define SET_TYPE_DIGITS_VALUE(NODE, X) \\\n-  SET_TYPE_LANG_SPECIFIC (INTEGER_TYPE_CHECK (NODE), X)\n+/* For an INTEGER_TYPE with TYPE_HAS_ACTUAL_BOUNDS_P or an ARRAY_TYPE, this is\n+   the index type that should be used when the actual bounds are required for\n+   a template.  This is used in the case of packed arrays.  */\n+#define TYPE_ACTUAL_BOUNDS(NODE) \\\n+  GET_TYPE_LANG_SPECIFIC (TREE_CHECK2 (NODE, INTEGER_TYPE, ARRAY_TYPE))\n+#define SET_TYPE_ACTUAL_BOUNDS(NODE, X) \\\n+  SET_TYPE_LANG_SPECIFIC (TREE_CHECK2 (NODE, INTEGER_TYPE, ARRAY_TYPE), X)\n \n /* For a RECORD_TYPE that is a fat pointer, point to the type for the\n    unconstrained object.  Likewise for a RECORD_TYPE that is pointed\n@@ -201,22 +224,8 @@ struct GTY(()) lang_type {tree t; };\n #define SET_TYPE_ADA_SIZE(NODE, X) \\\n   SET_TYPE_LANG_SPECIFIC (RECORD_OR_UNION_CHECK (NODE), X)\n \n-/* For an INTEGER_TYPE with TYPE_HAS_ACTUAL_BOUNDS_P or an ARRAY_TYPE, this is\n-   the index type that should be used when the actual bounds are required for\n-   a template.  This is used in the case of packed arrays.  */\n-#define TYPE_ACTUAL_BOUNDS(NODE) \\\n-  GET_TYPE_LANG_SPECIFIC (TREE_CHECK2 (NODE, INTEGER_TYPE, ARRAY_TYPE))\n-#define SET_TYPE_ACTUAL_BOUNDS(NODE, X) \\\n-  SET_TYPE_LANG_SPECIFIC (TREE_CHECK2 (NODE, INTEGER_TYPE, ARRAY_TYPE), X)\n \n-/* In an UNCONSTRAINED_ARRAY_TYPE, points to the record containing both\n-   the template and object.\n-\n-   ??? We also put this on an ENUMERAL_TYPE that's dummy.  Technically,\n-   this is a conflict on the minval field, but there doesn't seem to be\n-   simple fix, so we'll live with this kludge for now.  */\n-#define TYPE_OBJECT_RECORD_TYPE(NODE) \\\n-  (TREE_CHECK2 ((NODE), UNCONSTRAINED_ARRAY_TYPE, ENUMERAL_TYPE)->type.minval)\n+/* Flags added to decl nodes.  */\n \n /* Nonzero in a FUNCTION_DECL that represents a stubbed function\n    discriminant.  */\n@@ -251,6 +260,10 @@ struct GTY(()) lang_type {tree t; };\n /* Nonzero in a VAR_DECL if it is a pointer renaming a global object.  */\n #define DECL_RENAMING_GLOBAL_P(NODE) DECL_LANG_FLAG_5 (VAR_DECL_CHECK (NODE))\n \n+/* In a FIELD_DECL corresponding to a discriminant, contains the\n+   discriminant number.  */\n+#define DECL_DISCRIMINANT_NUMBER(NODE) DECL_INITIAL (FIELD_DECL_CHECK (NODE))\n+\n /* In a CONST_DECL, points to a VAR_DECL that is allocatable to\n    memory.  Used when a scalar constant is aliased or has its\n    address taken.  */\n@@ -293,11 +306,8 @@ struct GTY(()) lang_type {tree t; };\n #define SET_DECL_PARM_ALT_TYPE(NODE, X) \\\n   SET_DECL_LANG_SPECIFIC (PARM_DECL_CHECK (NODE), X)\n \n-/* In a FIELD_DECL corresponding to a discriminant, contains the\n-   discriminant number.  */\n-#define DECL_DISCRIMINANT_NUMBER(NODE) DECL_INITIAL (FIELD_DECL_CHECK (NODE))\n \n-/* Define fields and macros for statements.  */\n+/* Fields and macros for statements.  */\n #define IS_ADA_STMT(NODE) \\\n   (STATEMENT_CLASS_P (NODE) && TREE_CODE (NODE) >= STMT_STMT)\n "}, {"sha": "85d7783bbb4616e4a898355073707b83ac2e81c6", "filename": "gcc/ada/gcc-interface/decl.c", "status": "modified", "additions": 54, "deletions": 49, "changes": 103, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/26383c648f1e2bb6e3e2da84eaa6061159fe3904/gcc%2Fada%2Fgcc-interface%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/26383c648f1e2bb6e3e2da84eaa6061159fe3904/gcc%2Fada%2Fgcc-interface%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Fdecl.c?ref=26383c648f1e2bb6e3e2da84eaa6061159fe3904", "patch": "@@ -1521,10 +1521,11 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n     case E_Ordinary_Fixed_Point_Subtype:\n     case E_Decimal_Fixed_Point_Subtype:\n \n-      /* For integral subtypes, we make a new INTEGER_TYPE.  Note hat we do\n+      /* For integral subtypes, we make a new INTEGER_TYPE.  Note that we do\n \t not want to call build_range_type since we would like each subtype\n-\t node to be distinct.  This will be important when memory aliasing\n-\t is implemented.\n+\t node to be distinct.  ??? Historically this was in preparation for\n+\t when memory aliasing is implemented.  But that's obsolete now given\n+\t the call to relate_alias_sets below.\n \n \t The TREE_TYPE field of the INTEGER_TYPE points to the base type;\n \t this fact is used by the arithmetic conversion functions.\n@@ -1768,25 +1769,23 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n     case E_String_Type:\n     case E_Array_Type:\n       {\n-\ttree gnu_template_fields = NULL_TREE;\n-\ttree gnu_template_type = make_node (RECORD_TYPE);\n-\ttree gnu_ptr_template = build_pointer_type (gnu_template_type);\n-\ttree gnu_fat_type = make_node (RECORD_TYPE);\n+\tEntity_Id gnat_ind_subtype;\n+\tEntity_Id gnat_ind_base_subtype;\n \tint ndim = Number_Dimensions (gnat_entity);\n-\tint firstdim\n+\tint first_dim\n \t  = (Convention (gnat_entity) == Convention_Fortran) ? ndim - 1 : 0;\n-\tint nextdim\n+\tint next_dim\n \t  = (Convention (gnat_entity) == Convention_Fortran) ? - 1 : 1;\n \tint index;\n-\ttree *gnu_index_types = (tree *) alloca (ndim * sizeof (tree *));\n-\ttree *gnu_temp_fields = (tree *) alloca (ndim * sizeof (tree *));\n-\ttree gnu_comp_size = 0;\n-\ttree gnu_max_size = size_one_node;\n-\ttree gnu_max_size_unit;\n-\tEntity_Id gnat_ind_subtype;\n-\tEntity_Id gnat_ind_base_subtype;\n+\ttree gnu_template_fields = NULL_TREE;\n+\ttree gnu_template_type = make_node (RECORD_TYPE);\n \ttree gnu_template_reference;\n-\ttree tem;\n+\ttree gnu_ptr_template = build_pointer_type (gnu_template_type);\n+\ttree gnu_fat_type = make_node (RECORD_TYPE);\n+\ttree *gnu_index_types = (tree *) alloca (ndim * sizeof (tree));\n+\ttree *gnu_temp_fields = (tree *) alloca (ndim * sizeof (tree));\n+\ttree gnu_max_size = size_one_node, gnu_max_size_unit;\n+\ttree gnu_comp_size, tem;\n \n \tTYPE_NAME (gnu_template_type)\n \t  = create_concat_name (gnat_entity, \"XUB\");\n@@ -1829,11 +1828,11 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \n \t/* Now create the GCC type for each index and add the fields for\n \t   that index to the template.  */\n-\tfor (index = firstdim, gnat_ind_subtype = First_Index (gnat_entity),\n+\tfor (index = first_dim, gnat_ind_subtype = First_Index (gnat_entity),\n \t     gnat_ind_base_subtype\n \t       = First_Index (Implementation_Base_Type (gnat_entity));\n \t     index < ndim && index >= 0;\n-\t     index += nextdim,\n+\t     index += next_dim,\n \t     gnat_ind_subtype = Next_Index (gnat_ind_subtype),\n \t     gnat_ind_base_subtype = Next_Index (gnat_ind_base_subtype))\n \t  {\n@@ -1932,7 +1931,8 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \n \t/* If the component type is a RECORD_TYPE that has a self-referential\n \t   size, use the maximum size.  */\n-\tif (!gnu_comp_size && TREE_CODE (tem) == RECORD_TYPE\n+\tif (!gnu_comp_size\n+\t    && TREE_CODE (tem) == RECORD_TYPE\n \t    && CONTAINS_PLACEHOLDER_P (TYPE_SIZE (tem)))\n \t  gnu_comp_size = max_size (TYPE_SIZE (tem), true);\n \n@@ -2059,20 +2059,17 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \tbreak;\n       else\n \t{\n-\t  int index;\n-\t  int array_dim = Number_Dimensions (gnat_entity);\n+\t  Entity_Id gnat_ind_subtype;\n+\t  Entity_Id gnat_ind_base_subtype;\n+\t  int dim = Number_Dimensions (gnat_entity);\n \t  int first_dim\n-\t    = ((Convention (gnat_entity) == Convention_Fortran)\n-\t       ? array_dim - 1 : 0);\n+\t    = (Convention (gnat_entity) == Convention_Fortran) ? dim - 1 : 0;\n \t  int next_dim\n \t    = (Convention (gnat_entity) == Convention_Fortran) ? -1 : 1;\n-\t  Entity_Id gnat_ind_subtype;\n-\t  Entity_Id gnat_ind_base_subtype;\n+\t  int index;\n \t  tree gnu_base_type = gnu_type;\n-\t  tree *gnu_index_type = (tree *) alloca (array_dim * sizeof (tree *));\n-\t  tree gnu_comp_size = NULL_TREE;\n-\t  tree gnu_max_size = size_one_node;\n-\t  tree gnu_max_size_unit;\n+\t  tree *gnu_index_type = (tree *) alloca (dim * sizeof (tree));\n+\t  tree gnu_max_size = size_one_node, gnu_max_size_unit;\n \t  bool need_index_type_struct = false;\n \t  bool max_overflow = false;\n \n@@ -2084,7 +2081,7 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t  for (index = first_dim, gnat_ind_subtype = First_Index (gnat_entity),\n \t       gnat_ind_base_subtype\n \t\t = First_Index (Implementation_Base_Type (gnat_entity));\n-\t       index < array_dim && index >= 0;\n+\t       index < dim && index >= 0;\n \t       index += next_dim,\n \t       gnat_ind_subtype = Next_Index (gnat_ind_subtype),\n \t       gnat_ind_base_subtype = Next_Index (gnat_ind_base_subtype))\n@@ -2273,7 +2270,7 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t      && !Is_Bit_Packed_Array (Original_Array_Type (gnat_entity)))\n \t    {\n \t      gnu_type = gnat_to_gnu_type (Original_Array_Type (gnat_entity));\n-\t      for (index = array_dim - 1; index >= 0; index--)\n+\t      for (index = dim - 1; index >= 0; index--)\n \t\tgnu_type = TREE_TYPE (gnu_type);\n \n \t      /* One of the above calls might have caused us to be elaborated,\n@@ -2286,6 +2283,8 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t    }\n \t  else\n \t    {\n+\t      tree gnu_comp_size;\n+\n \t      gnu_type = gnat_to_gnu_type (Component_Type (gnat_entity));\n \n \t      /* One of the above calls might have caused us to be elaborated,\n@@ -2352,7 +2351,7 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t\t\t\t     convert (bitsizetype, gnu_max_size),\n \t\t\t\t     TYPE_SIZE (gnu_type));\n \n-\t  for (index = array_dim - 1; index >= 0; index --)\n+\t  for (index = dim - 1; index >= 0; index --)\n \t    {\n \t      gnu_type = build_array_type (gnu_type, gnu_index_type[index]);\n \t      TYPE_MULTI_ARRAY_P (gnu_type) = (index > 0);\n@@ -2368,7 +2367,7 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t  /* If we are at file level and this is a multi-dimensional array, we\n \t     need to make a variable corresponding to the stride of the\n \t     inner dimensions.   */\n-\t  if (global_bindings_p () && array_dim > 1)\n+\t  if (global_bindings_p () && dim > 1)\n \t    {\n \t      tree gnu_str_name = get_identifier (\"ST\");\n \t      tree gnu_arr_type;\n@@ -2419,7 +2418,7 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t      TYPE_NAME (gnu_bound_rec)\n \t\t= create_concat_name (gnat_entity, \"XA\");\n \n-\t      for (index = array_dim - 1; index >= 0; index--)\n+\t      for (index = dim - 1; index >= 0; index--)\n \t\t{\n \t\t  tree gnu_index = TYPE_INDEX_TYPE (gnu_index_type[index]);\n \t\t  tree gnu_index_name = TYPE_NAME (gnu_index);\n@@ -2505,42 +2504,48 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t\t     || TYPE_IS_PADDING_P (gnu_inner_type)))\n \t    gnu_inner_type = TREE_TYPE (TYPE_FIELDS (gnu_inner_type));\n \n-\t  /* We need to point the type we just made to our index type so\n-\t     the actual bounds can be put into a template.  */\n-\n+\t  /* We need to attach the index type to the type we just made so\n+\t     that the actual bounds can later be put into a template.  */\n \t  if ((TREE_CODE (gnu_inner_type) == ARRAY_TYPE\n \t       && !TYPE_ACTUAL_BOUNDS (gnu_inner_type))\n \t      || (TREE_CODE (gnu_inner_type) == INTEGER_TYPE\n \t\t  && !TYPE_HAS_ACTUAL_BOUNDS_P (gnu_inner_type)))\n \t    {\n \t      if (TREE_CODE (gnu_inner_type) == INTEGER_TYPE)\n \t\t{\n-\t\t  /* The TYPE_ACTUAL_BOUNDS field is also used for the modulus.\n-\t\t     If it is, we need to make another type.  */\n+\t\t  /* The TYPE_ACTUAL_BOUNDS field is overloaded with the\n+\t\t     TYPE_MODULUS for modular types so we make an extra\n+\t\t     subtype if necessary.  */\n \t\t  if (TYPE_MODULAR_P (gnu_inner_type))\n \t\t    {\n-\t\t      tree gnu_subtype;\n-\n-\t\t      gnu_subtype = make_node (INTEGER_TYPE);\n-\n+\t\t      tree gnu_subtype = make_node (INTEGER_TYPE);\n \t\t      TREE_TYPE (gnu_subtype) = gnu_inner_type;\n+\t\t      TYPE_EXTRA_SUBTYPE_P (gnu_subtype) = 1;\n+\n+\t\t      TYPE_UNSIGNED (gnu_subtype) = 1;\n+\t\t      TYPE_PRECISION (gnu_subtype)\n+\t\t\t= TYPE_PRECISION (gnu_inner_type);\n \t\t      TYPE_MIN_VALUE (gnu_subtype)\n \t\t\t= TYPE_MIN_VALUE (gnu_inner_type);\n \t\t      TYPE_MAX_VALUE (gnu_subtype)\n \t\t\t= TYPE_MAX_VALUE (gnu_inner_type);\n-\t\t      TYPE_PRECISION (gnu_subtype)\n-\t\t\t= TYPE_PRECISION (gnu_inner_type);\n-\t\t      TYPE_UNSIGNED (gnu_subtype)\n-\t\t\t= TYPE_UNSIGNED (gnu_inner_type);\n-\t\t      TYPE_EXTRA_SUBTYPE_P (gnu_subtype) = 1;\n \t\t      layout_type (gnu_subtype);\n \n \t\t      gnu_inner_type = gnu_subtype;\n \t\t    }\n \n \t\t  TYPE_HAS_ACTUAL_BOUNDS_P (gnu_inner_type) = 1;\n+\n+#ifdef ENABLE_CHECKING\n+\t\t  /* Check for other cases of overloading.  */\n+\t\t  gcc_assert (!TYPE_ACTUAL_BOUNDS (gnu_inner_type));\n+#endif\n \t\t}\n \n+\t      /* ??? This is necessary to make sure that the container is\n+\t\t allocated with a null tree upfront; otherwise, it could\n+\t\t be allocated with an uninitialized tree that is accessed\n+\t\t before being set below.  See ada-tree.h for details.  */\n \t      SET_TYPE_ACTUAL_BOUNDS (gnu_inner_type, NULL_TREE);\n \n \t      for (gnat_index = First_Index (gnat_entity);"}, {"sha": "cb5dc7b4ac843eb8d05bf7c9f34c3ccde024cb0c", "filename": "gcc/ada/gcc-interface/trans.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/26383c648f1e2bb6e3e2da84eaa6061159fe3904/gcc%2Fada%2Fgcc-interface%2Ftrans.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/26383c648f1e2bb6e3e2da84eaa6061159fe3904/gcc%2Fada%2Fgcc-interface%2Ftrans.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Ftrans.c?ref=26383c648f1e2bb6e3e2da84eaa6061159fe3904", "patch": "@@ -405,7 +405,7 @@ gigi (Node_Id gnat_root, int max_gnat_node, int number_name,\n   /* Make the types and functions used for exception processing.  */\n   jmpbuf_type\n     = build_array_type (gnat_type_for_mode (Pmode, 0),\n-\t\t\tbuild_index_type (build_int_cst (NULL_TREE, 5)));\n+\t\t\tbuild_index_type (size_int (5)));\n   record_builtin_type (\"JMPBUF_T\", jmpbuf_type);\n   jmpbuf_ptr_type = build_pointer_type (jmpbuf_type);\n "}, {"sha": "baa8a27b1fecc3fac799b3e07d3a7ed573f57271", "filename": "gcc/ada/gcc-interface/utils2.c", "status": "modified", "additions": 4, "deletions": 7, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/26383c648f1e2bb6e3e2da84eaa6061159fe3904/gcc%2Fada%2Fgcc-interface%2Futils2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/26383c648f1e2bb6e3e2da84eaa6061159fe3904/gcc%2Fada%2Fgcc-interface%2Futils2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Futils2.c?ref=26383c648f1e2bb6e3e2da84eaa6061159fe3904", "patch": "@@ -1591,15 +1591,14 @@ build_call_raise (int msg, Node_Id gnat_node, char kind)\n \t\t\t    (Get_Source_File_Index (Sloc (gnat_node))))))\n         : ref_filename;\n \n-  len = strlen (str) + 1;\n+  len = strlen (str);\n   filename = build_string (len, str);\n   line_number\n     = (gnat_node != Empty && Sloc (gnat_node) != No_Location)\n       ? Get_Logical_Line_Number (Sloc(gnat_node)) : input_line;\n \n   TREE_TYPE (filename)\n-    = build_array_type (char_type_node,\n-\t\t\tbuild_index_type (build_int_cst (NULL_TREE, len)));\n+    = build_array_type (char_type_node, build_index_type (size_int (len)));\n \n   return\n     build_call_2_expr (fndecl,\n@@ -1928,14 +1927,12 @@ build_call_alloc_dealloc (tree gnu_obj, tree gnu_size, unsigned align,\n       /* If the size is a constant, we can put it in the fixed portion of\n \t the stack frame to avoid the need to adjust the stack pointer.  */\n \t{\n-\t  tree gnu_range\n-\t    = build_range_type (NULL_TREE, size_one_node, gnu_size);\n-\t  tree gnu_array_type = build_array_type (char_type_node, gnu_range);\n+\t  tree gnu_index = build_index_2_type (size_one_node, gnu_size);\n+\t  tree gnu_array_type = build_array_type (char_type_node, gnu_index);\n \t  tree gnu_decl\n \t    = create_var_decl (get_identifier (\"RETVAL\"), NULL_TREE,\n \t\t\t       gnu_array_type, NULL_TREE, false, false, false,\n \t\t\t       false, NULL, gnat_node);\n-\n \t  return convert (ptr_void_type_node,\n \t\t\t  build_unary_op (ADDR_EXPR, NULL_TREE, gnu_decl));\n \t}"}]}