{"sha": "81ff723b4ecccafb5aa6e4f5ce910d9f45064dbc", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODFmZjcyM2I0ZWNjY2FmYjVhYTZlNGY1Y2U5MTBkOWY0NTA2NGRiYw==", "commit": {"author": {"name": "Alexander Malmberg", "email": "alexander@malmberg.org", "date": "2003-10-03T22:24:03Z"}, "committer": {"name": "Ziemowit Laski", "email": "zlaski@gcc.gnu.org", "date": "2003-10-03T22:24:03Z"}, "message": "objc-act.c (add_method_to_hash_list, [...]): New functions.\n\n[gcc]\n2003-10-03  Alexander Malmberg  <alexander@malmberg.org>\n            Ziemowit Laski  <zlaski@apple.com>\n\n        * objc/objc-act.c (add_method_to_hash_list, lookup_category):\n        New functions.\n        (lookup_method_in_hash_lists): New parameter indicating whether\n        we are messaging 'Class' or 'id'.\n        (check_duplicates): Likewise; do not assume all methods will\n        be either class or instance methods.\n        (generate_category, finish_class): Use lookup_category().\n        (add_method): Use add_method_to_hash_list(); insert instance\n        methods of root classes into the global class method hash table.\n        (add_category): Use lookup_category(); avoid constructing\n        duplicate categories.\n        (really_start_method): Add method to corresponding @interface,\n        if not already there (and if the @interface exists).\n        (finish_message_expr, finish_objc): Adjust calls to\n        check_duplicates().\n\n[gcc/testsuite]\n2003-10-03  Alexander Malmberg  <alexander@malmberg.org>\n            Ziemowit Laski  <zlaski@apple.com>\n\n        * objc.dg/method-6.m ('starboard'): Move prototype from 'Base' to\n        'Derived', so that it is never considered a class method; add\n        new warning for '+port' method ambiguity.\n        * objc.dg/method-12.m: Include <objc/objc.h> instead of\n        <objc/objc-api.h> (needed on Mac OS X).\n        * objc.dg/method-13.m: New test.\n\nCo-Authored-By: Ziemowit Laski <zlaski@apple.com>\n\nFrom-SVN: r72080", "tree": {"sha": "e37abdb5f9046a1b3c2c5a65570f0a9f40582a2b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e37abdb5f9046a1b3c2c5a65570f0a9f40582a2b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/81ff723b4ecccafb5aa6e4f5ce910d9f45064dbc", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/81ff723b4ecccafb5aa6e4f5ce910d9f45064dbc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/81ff723b4ecccafb5aa6e4f5ce910d9f45064dbc", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/81ff723b4ecccafb5aa6e4f5ce910d9f45064dbc/comments", "author": {"login": "AlexMalmberg", "id": 4164906, "node_id": "MDQ6VXNlcjQxNjQ5MDY=", "avatar_url": "https://avatars.githubusercontent.com/u/4164906?v=4", "gravatar_id": "", "url": "https://api.github.com/users/AlexMalmberg", "html_url": "https://github.com/AlexMalmberg", "followers_url": "https://api.github.com/users/AlexMalmberg/followers", "following_url": "https://api.github.com/users/AlexMalmberg/following{/other_user}", "gists_url": "https://api.github.com/users/AlexMalmberg/gists{/gist_id}", "starred_url": "https://api.github.com/users/AlexMalmberg/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/AlexMalmberg/subscriptions", "organizations_url": "https://api.github.com/users/AlexMalmberg/orgs", "repos_url": "https://api.github.com/users/AlexMalmberg/repos", "events_url": "https://api.github.com/users/AlexMalmberg/events{/privacy}", "received_events_url": "https://api.github.com/users/AlexMalmberg/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "875eda9c345e57676c4f21f753274ee51025fa41", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/875eda9c345e57676c4f21f753274ee51025fa41", "html_url": "https://github.com/Rust-GCC/gccrs/commit/875eda9c345e57676c4f21f753274ee51025fa41"}], "stats": {"total": 337, "additions": 253, "deletions": 84}, "files": [{"sha": "2a742ac49ee6027f91d9e3559917a46ed3dfe408", "filename": "gcc/ChangeLog", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/81ff723b4ecccafb5aa6e4f5ce910d9f45064dbc/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/81ff723b4ecccafb5aa6e4f5ce910d9f45064dbc/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=81ff723b4ecccafb5aa6e4f5ce910d9f45064dbc", "patch": "@@ -1,3 +1,22 @@\n+2003-10-03  Alexander Malmberg  <alexander@malmberg.org>\n+\t    Ziemowit Laski  <zlaski@apple.com>\n+\n+\t* objc/objc-act.c (add_method_to_hash_list, lookup_category):\n+\tNew functions.\n+\t(lookup_method_in_hash_lists): New parameter indicating whether\n+\twe are messaging 'Class' or 'id'.\n+\t(check_duplicates): Likewise; do not assume all methods will\n+\tbe either class or instance methods.\n+\t(generate_category, finish_class): Use lookup_category().\n+\t(add_method): Use add_method_to_hash_list(); insert instance\n+\tmethods of root classes into the global class method hash table.\n+\t(add_category): Use lookup_category(); avoid constructing\n+\tduplicate categories.\n+\t(really_start_method): Add method to corresponding @interface,\n+\tif not already there (and if the @interface exists).\n+\t(finish_message_expr, finish_objc): Adjust calls to\n+\tcheck_duplicates().\n+\n 2003-10-03  Roger Sayle  <roger@eyesopen.com>\n \n \tPR optimization/9325, PR java/6391"}, {"sha": "6b6d2f1907f32f0aeec90a4e42f293e904bdb027", "filename": "gcc/objc/objc-act.c", "status": "modified", "additions": 131, "deletions": 73, "changes": 204, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/81ff723b4ecccafb5aa6e4f5ce910d9f45064dbc/gcc%2Fobjc%2Fobjc-act.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/81ff723b4ecccafb5aa6e4f5ce910d9f45064dbc/gcc%2Fobjc%2Fobjc-act.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fobjc%2Fobjc-act.c?ref=81ff723b4ecccafb5aa6e4f5ce910d9f45064dbc", "patch": "@@ -149,7 +149,7 @@ static tree build_private_template (tree);\n static void build_class_template (void);\n static void build_selector_template (void);\n static void build_category_template (void);\n-static tree lookup_method_in_hash_lists (tree);\n+static tree lookup_method_in_hash_lists (tree, int);\n static void build_super_template (void);\n static tree build_category_initializer (tree, tree, tree, tree, tree, tree);\n static tree build_protocol_initializer (tree, tree, tree, tree, tree);\n@@ -184,8 +184,10 @@ static hash hash_lookup (hash *, tree);\n static void hash_add_attr (hash, tree);\n static tree lookup_method (tree, tree);\n static tree lookup_method_static (tree, tree, int);\n+static void add_method_to_hash_list (hash *, tree);\n static tree add_class (tree);\n static void add_category (tree, tree);\n+static tree lookup_category (tree, tree);\n \n enum string_section\n {\n@@ -280,7 +282,7 @@ static tree build_shared_structure_initializer (tree, tree, tree, tree,\n static void generate_category (tree);\n static int is_objc_type_qualifier (tree);\n static tree adjust_type_for_id_default (tree);\n-static tree check_duplicates (hash, int);\n+static tree check_duplicates (hash, int, int);\n static tree receiver_is_class_object (tree, int, int);\n static int check_methods (tree, tree, int);\n static int conforms_to_protocol (tree, tree);\n@@ -5064,6 +5066,18 @@ build_shared_structure_initializer (tree type, tree isa, tree super,\n   return objc_build_constructor (type, nreverse (initlist));\n }\n \n+/* Retrieve category interface CAT_NAME (if any) associated with CLASS.  */\n+\n+static tree\n+lookup_category (tree class, tree cat_name)\n+{\n+  tree category = CLASS_CATEGORY_LIST (class);\n+\n+  while (category && CLASS_SUPER_NAME (category) != cat_name)\n+    category = CLASS_CATEGORY_LIST (category);\n+  return category;\n+}\n+\n /* static struct objc_category _OBJC_CATEGORY_<name> = { ... };  */\n \n static void\n@@ -5078,15 +5092,8 @@ generate_category (tree cat)\n \n   class_name_expr = add_objc_string (CLASS_NAME (cat), class_names);\n \n-  category = CLASS_CATEGORY_LIST (implementation_template);\n-\n-  /* find the category interface from the class it is associated with */\n-  while (category)\n-    {\n-      if (CLASS_SUPER_NAME (cat) == CLASS_SUPER_NAME (category))\n-\tbreak;\n-      category = CLASS_CATEGORY_LIST (category);\n-    }\n+  category = lookup_category (implementation_template,\n+\t\t\t\tCLASS_SUPER_NAME (cat));\n \n   if (category && CLASS_PROTOCOL_LIST (category))\n     {\n@@ -5481,7 +5488,7 @@ get_arg_type_list (tree meth, int context, int superflag)\n }\n \n static tree\n-check_duplicates (hash hsh, int methods)\n+check_duplicates (hash hsh, int methods, int is_class)\n {\n   tree meth = NULL_TREE;\n \n@@ -5494,15 +5501,23 @@ check_duplicates (hash hsh, int methods)\n \t  /* We have two or more methods with the same name but\n \t     different types.  */\n \t  attr loop;\n-\t  char type = (TREE_CODE (meth) == INSTANCE_METHOD_DECL) ? '-' : '+';\n \n \t  warning (\"multiple %s named `%c%s' found\",\n-\t\t   methods ? \"methods\" : \"selectors\", type,\n+\t\t   methods ? \"methods\" : \"selectors\",\n+\t\t   (is_class ? '+' : '-'),\n \t\t   IDENTIFIER_POINTER (METHOD_SEL_NAME (meth)));\n \n-\t  warn_with_method (methods ? \"using\" : \"found\", type, meth);\n+\t  warn_with_method (methods ? \"using\" : \"found\",\n+\t\t\t    ((TREE_CODE (meth) == INSTANCE_METHOD_DECL)\n+\t\t\t     ? '-'\n+\t\t\t     : '+'), \n+\t\t\t    meth);\n \t  for (loop = hsh->list; loop; loop = loop->next)\n-\t    warn_with_method (\"also found\", type, loop->value);\n+\t    warn_with_method (\"also found\",\n+\t\t\t      ((TREE_CODE (loop->value) == INSTANCE_METHOD_DECL)\n+\t\t\t       ? '-' \n+\t\t\t       : '+'),\n+\t\t\t      loop->value);\n         }\n     }\n   return meth;\n@@ -5638,17 +5653,27 @@ build_message_expr (tree mess)\n   return finish_message_expr (receiver, sel_name, method_params);\n }\n \n+/* Look up method SEL_NAME that would be suitable for receiver\n+   of type 'id' (if IS_CLASS is zero) or 'Class' (if IS_CLASS is\n+   non-zero), and report on any duplicates.  */\n+\n static tree\n-lookup_method_in_hash_lists (tree sel_name)\n+lookup_method_in_hash_lists (tree sel_name, int is_class)\n {\n-  hash method_prototype = hash_lookup (nst_method_hash_list,\n-\t\t\t\t       sel_name);\n+  hash method_prototype = NULL;\n+\n+  if (!is_class)\n+    method_prototype = hash_lookup (nst_method_hash_list,\n+\t\t\t\t    sel_name);\n \t\t\t\t\t\n   if (!method_prototype)\n-    method_prototype = hash_lookup (cls_method_hash_list,\n-\t\t\t\t    sel_name);\n+    {\n+      method_prototype = hash_lookup (cls_method_hash_list,\n+\t\t\t\t      sel_name);\n+      is_class = 1;\n+    }\n \n-  return check_duplicates (method_prototype, 1);\n+  return check_duplicates (method_prototype, 1, is_class);\n }\n \n /* The 'finish_message_expr' routine is called from within\n@@ -5726,9 +5751,8 @@ finish_message_expr (tree receiver, tree sel_name, tree method_params)\n \t\t\t\t\t    is_class != NULL_TREE);\n       if (!method_prototype && !rprotos)\n \tmethod_prototype\n-\t  = (is_class\n-\t     ? check_duplicates (hash_lookup (cls_method_hash_list, sel_name), 1)\n-\t     : lookup_method_in_hash_lists (sel_name));\n+\t  = lookup_method_in_hash_lists (sel_name,\n+\t\t\t\t\t is_class != NULL_TREE);\n     }\n   else\n     {\n@@ -6251,11 +6275,34 @@ lookup_method_static (tree interface, tree ident, int is_class)\n   return is_class ? lookup_method_static (root_inter, ident, 0): NULL_TREE;\n }\n \n+/* Add the method to the hash list if it doesn't contain an identical\n+   method already. */\n+static void\n+add_method_to_hash_list (hash *hash_list, tree method)\n+{\n+  hash hsh;\n+\n+  if (!(hsh = hash_lookup (hash_list, METHOD_SEL_NAME (method))))\n+    {\n+      /* Install on a global chain.  */\n+      hash_enter (hash_list, method);\n+    }\n+  else\n+    {\n+      /* Check types against those; if different, add to a list.  */\n+      attr loop;\n+      int already_there = comp_proto_with_proto (method, hsh->key);\n+      for (loop = hsh->list; !already_there && loop; loop = loop->next)\n+\talready_there |= comp_proto_with_proto (method, loop->value);\n+      if (!already_there)\n+\thash_add_attr (hsh, method);\n+    }\n+}\n+\n tree\n add_method (tree class, tree method, int is_class)\n {\n   tree mth;\n-  hash hsh;\n \n   if (!(mth = lookup_method (is_class ? CLASS_CLS_METHODS (class) : CLASS_NST_METHODS (class), method)))\n     {\n@@ -6273,34 +6320,35 @@ add_method (tree class, tree method, int is_class)\n     }\n   else\n     {\n-      /* When processing an @interface for a class or category, give hard errors on methods with\n-\t identical selectors but differing argument and/or return types. We do not do this for\n-\t @implementations, because C/C++ will do it for us (i.e., there will be\n-\t duplicate function definition errors).  */\n+      /* When processing an @interface for a class or category, give hard\n+\t errors on methods with identical selectors but differing argument\n+\t and/or return types. We do not do this for @implementations, because\n+\t C/C++ will do it for us (i.e., there will be duplicate function\n+\t definition errors).  */\n       if ((TREE_CODE (class) == CLASS_INTERFACE_TYPE\n \t   || TREE_CODE (class) == CATEGORY_INTERFACE_TYPE)\n \t  && !comp_proto_with_proto (method, mth))\n \terror (\"duplicate declaration of method `%c%s'\",\n \t\tis_class ? '+' : '-', IDENTIFIER_POINTER (METHOD_SEL_NAME (mth)));\n     }\n \n-  if (!(hsh = hash_lookup (is_class\n-\t\t\t   ? cls_method_hash_list\n-\t\t\t   : nst_method_hash_list, METHOD_SEL_NAME (method))))\n-    {\n-      /* Install on a global chain.  */\n-      hash_enter (is_class ? cls_method_hash_list : nst_method_hash_list, method);\n-    }\n+  if (is_class)\n+    add_method_to_hash_list (cls_method_hash_list, method);\n   else\n     {\n-      /* Check types against those; if different, add to a list.  */\n-      attr loop;\n-      int already_there = comp_proto_with_proto (method, hsh->key);\n-      for (loop = hsh->list; !already_there && loop; loop = loop->next)\n-\talready_there |= comp_proto_with_proto (method, loop->value);\n-      if (!already_there)\n-\thash_add_attr (hsh, method);\n+      add_method_to_hash_list (nst_method_hash_list, method);\n+\n+      /* Instance methods in root classes (and categories thereof)\n+\t may acts as class methods as a last resort. */\n+      if (TREE_CODE (class) == CATEGORY_INTERFACE_TYPE\n+\t  || TREE_CODE (class) == CATEGORY_IMPLEMENTATION_TYPE)\n+\tclass = lookup_interface (CLASS_NAME (class));\n+\n+      if (TREE_CODE (class) != PROTOCOL_INTERFACE_TYPE\n+\t  && !CLASS_SUPER_NAME (class))\n+\tadd_method_to_hash_list (cls_method_hash_list, method);\n     }\n+\n   return method;\n }\n \n@@ -6317,23 +6365,19 @@ static void\n add_category (tree class, tree category)\n {\n   /* Put categories on list in reverse order.  */\n-  tree cat = CLASS_CATEGORY_LIST (class);\n+  tree cat = lookup_category (class, CLASS_SUPER_NAME (category));\n \n-  while (cat)\n+  if (cat)\n     {\n-      if (CLASS_SUPER_NAME (cat) == CLASS_SUPER_NAME (category))\n-#ifdef OBJCPLUS\n-\terror (\"duplicate interface declaration for category `%s(%s)'\",\n-#else\t\n-\twarning (\"duplicate interface declaration for category `%s(%s)'\",\n-#endif\t\n-\t\t IDENTIFIER_POINTER (CLASS_NAME (class)),\n-\t\t IDENTIFIER_POINTER (CLASS_SUPER_NAME (category)));\n-      cat = CLASS_CATEGORY_LIST (cat);\n+      warning (\"duplicate interface declaration for category `%s(%s)'\",\n+\t       IDENTIFIER_POINTER (CLASS_NAME (class)),\n+\t       IDENTIFIER_POINTER (CLASS_SUPER_NAME (category)));\n+    }\n+  else\n+    {\n+      CLASS_CATEGORY_LIST (category) = CLASS_CATEGORY_LIST (class);\n+      CLASS_CATEGORY_LIST (class) = category;\n     }\n-\n-  CLASS_CATEGORY_LIST (category) = CLASS_CATEGORY_LIST (class);\n-  CLASS_CATEGORY_LIST (class) = category;\n }\n \n /* Called after parsing each instance variable declaration. Necessary to\n@@ -6951,15 +6995,7 @@ finish_class (tree class)\n \n   else if (TREE_CODE (class) == CATEGORY_IMPLEMENTATION_TYPE)\n     {\n-      tree category = CLASS_CATEGORY_LIST (implementation_template);\n-\n-      /* Find the category interface from the class it is associated with.  */\n-      while (category)\n-\t{\n-\t  if (CLASS_SUPER_NAME (class) == CLASS_SUPER_NAME (category))\n-\t    break;\n-\t  category = CLASS_CATEGORY_LIST (category);\n-\t}\n+      tree category = lookup_category (implementation_template, CLASS_SUPER_NAME (class));\n \n       if (category)\n \t{\n@@ -7753,12 +7789,34 @@ really_start_method (tree method, tree parmlist)\n \t\t\t\tMETHOD_SEL_NAME (method),\n \t\t\t\tTREE_CODE (method) == CLASS_METHOD_DECL);\n \n-      if (proto && ! comp_method_with_proto (method, proto))\n+      if (proto)\n \t{\n-\t  char type = (TREE_CODE (method) == INSTANCE_METHOD_DECL ? '-' : '+');\n+\t  if (!comp_method_with_proto (method, proto))\n+\t    {\n+\t      char type = (TREE_CODE (method) == INSTANCE_METHOD_DECL ? '-' : '+');\n \n-\t  warn_with_method (\"conflicting types for\", type, method);\n-\t  warn_with_method (\"previous declaration of\", type, proto);\n+\t      warn_with_method (\"conflicting types for\", type, method);\n+\t      warn_with_method (\"previous declaration of\", type, proto);\n+\t    }\n+\t}\n+      else\n+\t{\n+\t  /* We have a method @implementation even though we did not\n+\t     see a corresponding @interface declaration (which is allowed\n+\t     by Objective-C rules).  Go ahead and place the method in\n+\t     the @interface anyway, so that message dispatch lookups\n+\t     will see it.  */\n+\t  tree interface = implementation_template;\n+\n+\t  if (TREE_CODE (objc_implementation_context)\n+\t      == CATEGORY_IMPLEMENTATION_TYPE)\n+\t    interface = lookup_category\n+\t\t\t(interface,\n+\t\t\t CLASS_SUPER_NAME (objc_implementation_context));\n+\n+\t  if (interface)\n+\t    add_method (interface, copy_node (method),\n+\t\t\tTREE_CODE (method) == CLASS_METHOD_DECL);\n \t}\n     }\n }\n@@ -8844,9 +8902,9 @@ finish_objc (void)\n       for (slot = 0; slot < SIZEHASHTABLE; slot++)\n \t{\n \t  for (hsh = cls_method_hash_list[slot]; hsh; hsh = hsh->next)\n-\t    check_duplicates (hsh, 0);\n+\t    check_duplicates (hsh, 0, 1);\n \t  for (hsh = nst_method_hash_list[slot]; hsh; hsh = hsh->next)\n-\t    check_duplicates (hsh, 0);\n+\t    check_duplicates (hsh, 0, 1);\n \t}\n     }\n "}, {"sha": "66151d408aefe8b91ed28ef4fd670583941df1c8", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/81ff723b4ecccafb5aa6e4f5ce910d9f45064dbc/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/81ff723b4ecccafb5aa6e4f5ce910d9f45064dbc/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=81ff723b4ecccafb5aa6e4f5ce910d9f45064dbc", "patch": "@@ -1,3 +1,13 @@\n+2003-10-03  Alexander Malmberg  <alexander@malmberg.org>\n+\t    Ziemowit Laski  <zlaski@apple.com>\n+\n+\t* objc.dg/method-6.m ('starboard'): Move prototype from 'Base' to\n+\t'Derived', so that it is never considered a class method; add\n+\tnew warning for '+port' method ambiguity.\n+\t* objc.dg/method-12.m: Include <objc/objc.h> instead of\n+\t<objc/objc-api.h> (needed on Mac OS X).\n+\t* objc.dg/method-13.m: New test.\n+\n 2003-10-03  Roger Sayle  <roger@eyesopen.com>\n \n \tPR optimization/9325, PR java/6391"}, {"sha": "411caac111ad283318ec7431a18ce6905a4e8097", "filename": "gcc/testsuite/objc.dg/method-12.m", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/81ff723b4ecccafb5aa6e4f5ce910d9f45064dbc/gcc%2Ftestsuite%2Fobjc.dg%2Fmethod-12.m", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/81ff723b4ecccafb5aa6e4f5ce910d9f45064dbc/gcc%2Ftestsuite%2Fobjc.dg%2Fmethod-12.m", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fobjc.dg%2Fmethod-12.m?ref=81ff723b4ecccafb5aa6e4f5ce910d9f45064dbc", "patch": "@@ -1,7 +1,7 @@\n /* Contributed by Igor Seleznev <selez@mail.ru>.  */\n /* This used to be broken.  */\n \n-#include <objc/objc-api.h>\n+#include <objc/objc.h>\n \n @interface A\n + (A *)currentContext;"}, {"sha": "c824398ac5b9ba4d0cdf5f8379bf07a04add58ed", "filename": "gcc/testsuite/objc.dg/method-13.m", "status": "added", "additions": 77, "deletions": 0, "changes": 77, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/81ff723b4ecccafb5aa6e4f5ce910d9f45064dbc/gcc%2Ftestsuite%2Fobjc.dg%2Fmethod-13.m", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/81ff723b4ecccafb5aa6e4f5ce910d9f45064dbc/gcc%2Ftestsuite%2Fobjc.dg%2Fmethod-13.m", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fobjc.dg%2Fmethod-13.m?ref=81ff723b4ecccafb5aa6e4f5ce910d9f45064dbc", "patch": "@@ -0,0 +1,77 @@\n+/* Test if instance methods of root classes are used as class methods, if no\n+   \"real\" methods are found.  For receivers of type 'id' and 'Class', all\n+   root classes must be considered.  */\n+/* Author: Ziemowit Laski <zlaski@apple.com>.  */\n+/* { dg-do run } */\n+\n+#include <objc/objc.h>\n+\n+#ifdef __NEXT_RUNTIME__\n+#define OBJC_GETCLASS objc_getClass\n+#else\n+#define OBJC_GETCLASS objc_get_class\n+#endif\n+\n+extern void abort(void);\n+extern int strcmp(const char *, const char *);\n+#define CHECK_IF(expr) if(!(expr)) abort()\n+\n+@protocol Proto\n+- (const char *) method4;\n+@end\n+\n+@interface Root\n+{ Class isa; }\n++ (const char *) method2;\n+@end\n+\n+@interface Derived: Root\n+- (const char *) method1;\n+- (const char *) method2;\n+- (const char *) method3;\n+@end\n+\n+@interface Root (Categ)\n+- (const char *) method3;\n+@end\n+\n+@implementation Root (Categ)\n+- (const char *) method3 { return \"Root(Categ)::-method3\"; }\n+- (const char *) method4 { return \"Root(Categ)::-method4\"; }\n+@end\n+\n+@implementation Derived\n+- (const char *) method1 { return \"Derived::-method1\"; }\n+- (const char *) method2 { return \"Derived::-method2\"; }\n+- (const char *) method3 { return \"Derived::-method3\"; }\n+@end\n+\n+@implementation Root\n+#ifdef __NEXT_RUNTIME__\n++ initialize { return self; }\n+#endif\n+- (const char *) method1 { return \"Root::-method1\"; }\n++ (const char *) method2 { return \"Root::+method2\"; }\n+@end\n+\n+int main(void)\n+{\n+  Class obj = OBJC_GETCLASS(\"Derived\");\n+\n+  /* None of the following should elicit compiler-time warnings.  */\n+\n+  CHECK_IF(!strcmp([Root method1], \"Root::-method1\"));\n+  CHECK_IF(!strcmp([Root method2], \"Root::+method2\"));\n+  CHECK_IF(!strcmp([Root method3], \"Root(Categ)::-method3\"));\n+  CHECK_IF(!strcmp([Root method4], \"Root(Categ)::-method4\"));\n+  CHECK_IF(!strcmp([Derived method1], \"Root::-method1\"));\n+  CHECK_IF(!strcmp([Derived method2], \"Root::+method2\"));\n+  CHECK_IF(!strcmp([Derived method3], \"Root(Categ)::-method3\"));\n+  CHECK_IF(!strcmp([Derived method4], \"Root(Categ)::-method4\"));\n+  CHECK_IF(!strcmp([obj method1], \"Root::-method1\"));\n+  CHECK_IF(!strcmp([obj method2], \"Root::+method2\"));\n+  CHECK_IF(!strcmp([obj method3], \"Root(Categ)::-method3\"));\n+  CHECK_IF(!strcmp([obj method4], \"Root(Categ)::-method4\"));\n+\n+  return 0;\n+}"}, {"sha": "a4ca787b7f66ac5503fa42fc9593cd46e0077f8d", "filename": "gcc/testsuite/objc.dg/method-6.m", "status": "modified", "additions": 15, "deletions": 10, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/81ff723b4ecccafb5aa6e4f5ce910d9f45064dbc/gcc%2Ftestsuite%2Fobjc.dg%2Fmethod-6.m", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/81ff723b4ecccafb5aa6e4f5ce910d9f45064dbc/gcc%2Ftestsuite%2Fobjc.dg%2Fmethod-6.m", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fobjc.dg%2Fmethod-6.m?ref=81ff723b4ecccafb5aa6e4f5ce910d9f45064dbc", "patch": "@@ -1,26 +1,31 @@\n-/* Check that sending messages to variables of type 'Class' does not involve instance methods.  */\n+/* Check that sending messages to variables of type 'Class' does not involve instance methods,\n+   unless they reside in root classes.  */\n /* Author: Ziemowit Laski <zlaski@apple.com>  */\n /* { dg-do compile } */\n \n #include <objc/Protocol.h>\n \n @interface Base\n - (unsigned)port;\n-- (id)starboard;\n @end\n \n @interface Derived: Base\n - (Object *)port;\n + (Protocol *)port;\n+- (id)starboard;\n @end\n \n-id foo(void) {\n+void foo(void) {\n   Class receiver;\n-  id p = [receiver port];  /* there should be no warnings here! */\n-  p = [receiver starboard];  /* { dg-warning \".Class. may not respond to .\\\\+starboard.\" } */\n-       /* { dg-warning \"Messages without a matching method signature\" \"\" { target *-*-* } 20 } */\n-       /* { dg-warning \"will be assumed to return .id. and accept\" \"\" { target *-*-* } 20 } */\n-       /* { dg-warning \".\\.\\.\\.. as arguments\" \"\" { target *-*-* } 20 } */\n-  p = [Class port];  /* { dg-error \".Class. is not an Objective\\\\-C class name or alias\" } */\n-  return p;\n+\n+  [receiver port];  /* { dg-warning \"multiple methods named .\\\\+port. found\" } */\n+       /* { dg-warning \"using .\\\\-\\\\(unsigned\\\\)port.\" \"\" { target *-*-* } 9 } */\n+       /* { dg-warning \"also found .\\\\+\\\\(Protocol \\\\*\\\\)port.\" \"\" { target *-*-* } 14 } */\n+\n+  [receiver starboard];  /* { dg-warning \".Class. may not respond to .\\\\+starboard.\" } */\n+       /* { dg-warning \"Messages without a matching method signature\" \"\" { target *-*-* } 25 } */\n+       /* { dg-warning \"will be assumed to return .id. and accept\" \"\" { target *-*-* } 25 } */\n+       /* { dg-warning \".\\.\\.\\.. as arguments\" \"\" { target *-*-* } 25 } */\n+\n+  [Class port];  /* { dg-error \".Class. is not an Objective\\\\-C class name or alias\" } */\n }"}]}