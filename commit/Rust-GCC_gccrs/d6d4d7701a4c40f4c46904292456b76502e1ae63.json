{"sha": "d6d4d7701a4c40f4c46904292456b76502e1ae63", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDZkNGQ3NzAxYTRjNDBmNGM0NjkwNDI5MjQ1NmI3NjUwMmUxYWU2Mw==", "commit": {"author": {"name": "Daniel Santos", "email": "daniel.santos@pobox.com", "date": "2017-05-14T10:22:08Z"}, "committer": {"name": "Uros Bizjak", "email": "uros@gcc.gnu.org", "date": "2017-05-14T10:22:08Z"}, "message": "i386.opt: Add option -mcall-ms2sysv-xlogues.\n\ngcc/ChangeLog:\n\n\t* config/i386/i386.opt: Add option -mcall-ms2sysv-xlogues.\n\t* config/i386/i386.h\n\t(x86_64_ms_sysv_extra_clobbered_registers): Change type to unsigned.\n\t(NUM_X86_64_MS_CLOBBERED_REGS): New macro.\n\t(struct machine_function): Add new members call_ms2sysv,\n\tcall_ms2sysv_pad_in, call_ms2sysv_pad_out and call_ms2sysv_extra_regs.\n\t(struct machine_frame_state): New fields sp_realigned and\n\tsp_realigned_offset.\n\t* config/i386/i386.c\n\t(enum xlogue_stub): New enum.\n\t(enum xlogue_stub_sets): New enum.\n\t(class xlogue_layout): New class.\n\t(struct ix86_frame): New fields stack_realign_allocate_offset,\n\tstack_realign_offset and outlined_save_offset.  Modify comments to\n\tdetail stack layout when using out-of-line stubs.\n\t(ix86_target_string): Add -mcall-ms2sysv-xlogues option.\n\t(ix86_option_override_internal): Add sorry() for TARGET_SEH and\n\t-mcall-ms2sysv-xlogues.\n\t(stub_managed_regs): New static variable.\n\t(ix86_save_reg): Add new parameter ignore_outlined to optionally omit\n\tregisters managed by out-of-line stub.\n\t(disable_call_ms2sysv_xlogues): New function.\n\t(ix86_compute_frame_layout): Modify re-alignment calculations, disable\n\tm->call_ms2sysv when appropriate and compute frame layout for\n\tout-of-line stubs.\n\t(sp_valid_at, fp_valid_at): New inline functions.\n\t(choose_basereg): New function.\n\t(choose_baseaddr): Add align parameter, use choose_basereg and modify\n\tall callers.\n\t(ix86_emit_save_reg_using_mov, ix86_emit_restore_sse_regs_using_mov):\n\tUse align parameter of choose_baseaddr to generated aligned SSE movs\n\twhen possible.\n\t(pro_epilogue_adjust_stack): Modify to track\n\tmachine_frame_state::sp_realigned.\n\t(ix86_nsaved_regs): Modify to accommodate changes to ix86_save_reg.\n\t(ix86_nsaved_sseregs): Likewise.\n\t(ix86_emit_save_regs): Likewise.\n\t(ix86_emit_save_regs_using_mov): Likewise.\n\t(ix86_emit_save_sse_regs_using_mov): Likewise.\n\t(get_scratch_register_on_entry): Likewise.\n\t(gen_frame_set): New function.\n\t(gen_frame_load): Likewise.\n\t(gen_frame_store): Likewise.\n\t(emit_outlined_ms2sysv_save): Likewise.\n\t(emit_outlined_ms2sysv_restore): Likewise.\n\t(ix86_expand_prologue): Modify stack re-alignment code and call\n\temit_outlined_ms2sysv_save when appropriate.\n\t(ix86_emit_leave): Clear machine_frame_state::sp_realigned.  Add\n\tparameter rtx_insn *insn, which allows the function to be used to only\n\tgenerate the notes.\n\t(ix86_expand_epilogue): Modify validity checks of frame and stack\n\tpointers, and call emit_outlined_ms2sysv_restore when appropriate.\n\t(ix86_expand_call): Modify to enable m->call_ms2sysv when appropriate.\n\t* config/i386/predicates.md\n\t(save_multiple): New predicate.\n\t(restore_multiple): Likewise.\n\t* config/i386/sse.md\n\t(save_multiple<mode>): New pattern.\n\t(save_multiple_realign<mode>): Likewise.\n\t(restore_multiple<mode>): Likewise.\n\t(restore_multiple_and_return<mode>): Likewise.\n\t(restore_multiple_leave_return<mode>): Likewise.\n\t* Makefile.in: Export HOSTCXX and HOSTCXXFLAGS to site.exp\n\ngcc/testsuite/ChangeLog:\n\n\t* gcc.target/x86_64/abi/ms-sysv/do-test.S: New file.\n\t* gcc.target/x86_64/abi/ms-sysv/gen.cc: Likewise.\n\t* gcc.target/x86_64/abi/ms-sysv/ms-sysv.c: Likewise.\n\t* gcc.target/x86_64/abi/ms-sysv/ms-sysv.exp: Likewise.\n\nlibgcc/ChangeLog:\n\n\t* config.host: Add i386/t-msabi to i386/t-linux file list.\n\t* config/i386/i386-asm.h: New file.\n\t* config/i386/resms64.S: New file.\n\t* config/i386/resms64f.S: New file.\n\t* config/i386/resms64fx.S: New file.\n\t* config/i386/resms64x.S: New file.\n\t* config/i386/savms64.S: New file.\n\t* config/i386/savms64f.S: New file.\n\t* config/i386/t-msabi: New file.\n\nFrom-SVN: r248029", "tree": {"sha": "370d24fd9d1803bfd9738ef07f5ade5ff76469eb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/370d24fd9d1803bfd9738ef07f5ade5ff76469eb"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d6d4d7701a4c40f4c46904292456b76502e1ae63", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d6d4d7701a4c40f4c46904292456b76502e1ae63", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d6d4d7701a4c40f4c46904292456b76502e1ae63", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d6d4d7701a4c40f4c46904292456b76502e1ae63/comments", "author": {"login": "daniel-santos", "id": 980562, "node_id": "MDQ6VXNlcjk4MDU2Mg==", "avatar_url": "https://avatars.githubusercontent.com/u/980562?v=4", "gravatar_id": "", "url": "https://api.github.com/users/daniel-santos", "html_url": "https://github.com/daniel-santos", "followers_url": "https://api.github.com/users/daniel-santos/followers", "following_url": "https://api.github.com/users/daniel-santos/following{/other_user}", "gists_url": "https://api.github.com/users/daniel-santos/gists{/gist_id}", "starred_url": "https://api.github.com/users/daniel-santos/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/daniel-santos/subscriptions", "organizations_url": "https://api.github.com/users/daniel-santos/orgs", "repos_url": "https://api.github.com/users/daniel-santos/repos", "events_url": "https://api.github.com/users/daniel-santos/events{/privacy}", "received_events_url": "https://api.github.com/users/daniel-santos/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "b9bdd60b8792e2d3173ecfacd5c25aac894a94e5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b9bdd60b8792e2d3173ecfacd5c25aac894a94e5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b9bdd60b8792e2d3173ecfacd5c25aac894a94e5"}], "stats": {"total": 3134, "additions": 3038, "deletions": 96}, "files": [{"sha": "4dceeb32e6ae991083ae6bf6702126dac7233bc4", "filename": "gcc/ChangeLog", "status": "modified", "additions": 66, "deletions": 0, "changes": 66, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6d4d7701a4c40f4c46904292456b76502e1ae63/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6d4d7701a4c40f4c46904292456b76502e1ae63/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=d6d4d7701a4c40f4c46904292456b76502e1ae63", "patch": "@@ -1,3 +1,69 @@\n+2017-05-14  Daniel Santos  <daniel.santos@pobox.com>\n+\n+\t* config/i386/i386.opt: Add option -mcall-ms2sysv-xlogues.\n+\t* config/i386/i386.h\n+\t(x86_64_ms_sysv_extra_clobbered_registers): Change type to unsigned.\n+\t(NUM_X86_64_MS_CLOBBERED_REGS): New macro.\n+\t(struct machine_function): Add new members call_ms2sysv,\n+\tcall_ms2sysv_pad_in, call_ms2sysv_pad_out and call_ms2sysv_extra_regs.\n+\t(struct machine_frame_state): New fields sp_realigned and\n+\tsp_realigned_offset.\n+\t* config/i386/i386.c\n+\t(enum xlogue_stub): New enum.\n+\t(enum xlogue_stub_sets): New enum.\n+\t(class xlogue_layout): New class.\n+\t(struct ix86_frame): New fields stack_realign_allocate_offset,\n+\tstack_realign_offset and outlined_save_offset.  Modify comments to\n+\tdetail stack layout when using out-of-line stubs.\n+\t(ix86_target_string): Add -mcall-ms2sysv-xlogues option.\n+\t(ix86_option_override_internal): Add sorry() for TARGET_SEH and\n+\t-mcall-ms2sysv-xlogues.\n+\t(stub_managed_regs): New static variable.\n+\t(ix86_save_reg): Add new parameter ignore_outlined to optionally omit\n+\tregisters managed by out-of-line stub.\n+\t(disable_call_ms2sysv_xlogues): New function.\n+\t(ix86_compute_frame_layout): Modify re-alignment calculations, disable\n+\tm->call_ms2sysv when appropriate and compute frame layout for\n+\tout-of-line stubs.\n+\t(sp_valid_at, fp_valid_at): New inline functions.\n+\t(choose_basereg): New function.\n+\t(choose_baseaddr): Add align parameter, use choose_basereg and modify\n+\tall callers.\n+\t(ix86_emit_save_reg_using_mov, ix86_emit_restore_sse_regs_using_mov):\n+\tUse align parameter of choose_baseaddr to generated aligned SSE movs\n+\twhen possible.\n+\t(pro_epilogue_adjust_stack): Modify to track\n+\tmachine_frame_state::sp_realigned.\n+\t(ix86_nsaved_regs): Modify to accommodate changes to ix86_save_reg.\n+\t(ix86_nsaved_sseregs): Likewise.\n+\t(ix86_emit_save_regs): Likewise.\n+\t(ix86_emit_save_regs_using_mov): Likewise.\n+\t(ix86_emit_save_sse_regs_using_mov): Likewise.\n+\t(get_scratch_register_on_entry): Likewise.\n+\t(gen_frame_set): New function.\n+\t(gen_frame_load): Likewise.\n+\t(gen_frame_store): Likewise.\n+\t(emit_outlined_ms2sysv_save): Likewise.\n+\t(emit_outlined_ms2sysv_restore): Likewise.\n+\t(ix86_expand_prologue): Modify stack re-alignment code and call\n+\temit_outlined_ms2sysv_save when appropriate.\n+\t(ix86_emit_leave): Clear machine_frame_state::sp_realigned.  Add\n+\tparameter rtx_insn *insn, which allows the function to be used to only\n+\tgenerate the notes.\n+\t(ix86_expand_epilogue): Modify validity checks of frame and stack\n+\tpointers, and call emit_outlined_ms2sysv_restore when appropriate.\n+\t(ix86_expand_call): Modify to enable m->call_ms2sysv when appropriate.\n+\t* config/i386/predicates.md\n+\t(save_multiple): New predicate.\n+\t(restore_multiple): Likewise.\n+\t* config/i386/sse.md\n+\t(save_multiple<mode>): New pattern.\n+\t(save_multiple_realign<mode>): Likewise.\n+\t(restore_multiple<mode>): Likewise.\n+\t(restore_multiple_and_return<mode>): Likewise.\n+\t(restore_multiple_leave_return<mode>): Likewise.\n+\t* Makefile.in: Export HOSTCXX and HOSTCXXFLAGS to site.exp\n+\n 2017-05-14  Julia Koval  <julia.koval@intel.com>\n \n \t* config/i386/i386-builtin-types.def (VOID_FTYPE_INT_INT64): New type."}, {"sha": "8fa77e353288290884cc47a1093860600a897d1c", "filename": "gcc/Makefile.in", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6d4d7701a4c40f4c46904292456b76502e1ae63/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6d4d7701a4c40f4c46904292456b76502e1ae63/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=d6d4d7701a4c40f4c46904292456b76502e1ae63", "patch": "@@ -3810,7 +3810,9 @@ site.exp: ./config.status Makefile\n \t@echo \"set CFLAGS \\\"\\\"\" >> ./site.tmp\n \t@echo \"set CXXFLAGS \\\"\\\"\" >> ./site.tmp\n \t@echo \"set HOSTCC \\\"$(CC)\\\"\" >> ./site.tmp\n+\t@echo \"set HOSTCXX \\\"$(CXX)\\\"\" >> ./site.tmp\n \t@echo \"set HOSTCFLAGS \\\"$(CFLAGS)\\\"\" >> ./site.tmp\n+\t@echo \"set HOSTCXXFLAGS \\\"$(CXXFLAGS)\\\"\" >> ./site.tmp\n # TEST_ALWAYS_FLAGS are flags that should be passed to every compilation.\n # They are passed first to allow individual tests to override them.\n \t@echo \"set TEST_ALWAYS_FLAGS \\\"$(SYSROOT_CFLAGS_FOR_TARGET)\\\"\" >> ./site.tmp"}, {"sha": "4676e7ff49ae2ae22fb43a1e47ba3ffd05cce962", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 831, "deletions": 91, "changes": 922, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6d4d7701a4c40f4c46904292456b76502e1ae63/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6d4d7701a4c40f4c46904292456b76502e1ae63/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=d6d4d7701a4c40f4c46904292456b76502e1ae63", "patch": "@@ -93,6 +93,7 @@ static rtx legitimize_dllimport_symbol (rtx, bool);\n static rtx legitimize_pe_coff_extern_decl (rtx, bool);\n static rtx legitimize_pe_coff_symbol (rtx, bool);\n static void ix86_print_operand_address_as (FILE *, rtx, addr_space_t, bool);\n+static bool ix86_save_reg (unsigned int, bool, bool);\n \n #ifndef CHECK_STACK_LIMIT\n #define CHECK_STACK_LIMIT (-1)\n@@ -2424,14 +2425,275 @@ static int const x86_64_int_return_registers[4] =\n \n /* Additional registers that are clobbered by SYSV calls.  */\n \n-int const x86_64_ms_sysv_extra_clobbered_registers[12] =\n+unsigned const x86_64_ms_sysv_extra_clobbered_registers[12] =\n {\n   SI_REG, DI_REG,\n   XMM6_REG, XMM7_REG,\n   XMM8_REG, XMM9_REG, XMM10_REG, XMM11_REG,\n   XMM12_REG, XMM13_REG, XMM14_REG, XMM15_REG\n };\n \n+enum xlogue_stub {\n+  XLOGUE_STUB_SAVE,\n+  XLOGUE_STUB_RESTORE,\n+  XLOGUE_STUB_RESTORE_TAIL,\n+  XLOGUE_STUB_SAVE_HFP,\n+  XLOGUE_STUB_RESTORE_HFP,\n+  XLOGUE_STUB_RESTORE_HFP_TAIL,\n+\n+  XLOGUE_STUB_COUNT\n+};\n+\n+enum xlogue_stub_sets {\n+  XLOGUE_SET_ALIGNED,\n+  XLOGUE_SET_ALIGNED_PLUS_8,\n+  XLOGUE_SET_HFP_ALIGNED_OR_REALIGN,\n+  XLOGUE_SET_HFP_ALIGNED_PLUS_8,\n+\n+  XLOGUE_SET_COUNT\n+};\n+\n+/* Register save/restore layout used by out-of-line stubs.  */\n+class xlogue_layout {\n+public:\n+  struct reginfo\n+  {\n+    unsigned regno;\n+    HOST_WIDE_INT offset;\t/* Offset used by stub base pointer (rax or\n+\t\t\t\t   rsi) to where each register is stored.  */\n+  };\n+\n+  unsigned get_nregs () const\t\t\t{return m_nregs;}\n+  HOST_WIDE_INT get_stack_align_off_in () const\t{return m_stack_align_off_in;}\n+\n+  const reginfo &get_reginfo (unsigned reg) const\n+  {\n+    gcc_assert (reg < m_nregs);\n+    return m_regs[reg];\n+  }\n+\n+  const char *get_stub_name (enum xlogue_stub stub,\n+\t\t\t     unsigned n_extra_args) const;\n+  /* Returns an rtx for the stub's symbol based upon\n+       1.) the specified stub (save, restore or restore_ret) and\n+       2.) the value of cfun->machine->call_ms2sysv_extra_regs and\n+       3.) rather or not stack alignment is being performed.  */\n+  rtx get_stub_rtx (enum xlogue_stub stub) const;\n+\n+  /* Returns the amount of stack space (including padding) that the stub\n+     needs to store registers based upon data in the machine_function.  */\n+  HOST_WIDE_INT get_stack_space_used () const\n+  {\n+    const struct machine_function &m = *cfun->machine;\n+    unsigned last_reg = m.call_ms2sysv_extra_regs + MIN_REGS - 1;\n+\n+    gcc_assert (m.call_ms2sysv_extra_regs <= MAX_EXTRA_REGS);\n+    return m_regs[last_reg].offset\n+\t    + (m.call_ms2sysv_pad_out ? 8 : 0)\n+\t    + STUB_INDEX_OFFSET;\n+  }\n+\n+  /* Returns the offset for the base pointer used by the stub.  */\n+  HOST_WIDE_INT get_stub_ptr_offset () const\n+  {\n+    return STUB_INDEX_OFFSET + m_stack_align_off_in;\n+  }\n+\n+  static const struct xlogue_layout &get_instance ();\n+  static unsigned compute_stub_managed_regs (HARD_REG_SET &stub_managed_regs);\n+\n+  static const HOST_WIDE_INT STUB_INDEX_OFFSET = 0x70;\n+  static const unsigned MIN_REGS = NUM_X86_64_MS_CLOBBERED_REGS;\n+  static const unsigned MAX_REGS = 18;\n+  static const unsigned MAX_EXTRA_REGS = MAX_REGS - MIN_REGS;\n+  static const unsigned VARIANT_COUNT = MAX_EXTRA_REGS + 1;\n+  static const unsigned STUB_NAME_MAX_LEN = 16;\n+  static const char * const STUB_BASE_NAMES[XLOGUE_STUB_COUNT];\n+  static const unsigned REG_ORDER[MAX_REGS];\n+  static const unsigned REG_ORDER_REALIGN[MAX_REGS];\n+\n+private:\n+  xlogue_layout ();\n+  xlogue_layout (HOST_WIDE_INT stack_align_off_in, bool hfp);\n+  xlogue_layout (const xlogue_layout &);\n+\n+  /* True if hard frame pointer is used.  */\n+  bool m_hfp;\n+\n+  /* Max number of register this layout manages.  */\n+  unsigned m_nregs;\n+\n+  /* Incoming offset from 16-byte alignment.  */\n+  HOST_WIDE_INT m_stack_align_off_in;\n+\n+  /* Register order and offsets.  */\n+  struct reginfo m_regs[MAX_REGS];\n+\n+  /* Lazy-inited cache of symbol names for stubs.  */\n+  char m_stub_names[XLOGUE_STUB_COUNT][VARIANT_COUNT][STUB_NAME_MAX_LEN];\n+\n+  static const struct xlogue_layout GTY(()) s_instances[XLOGUE_SET_COUNT];\n+};\n+\n+const char * const xlogue_layout::STUB_BASE_NAMES[XLOGUE_STUB_COUNT] = {\n+  \"savms64\",\n+  \"resms64\",\n+  \"resms64x\",\n+  \"savms64f\",\n+  \"resms64f\",\n+  \"resms64fx\"\n+};\n+\n+const unsigned xlogue_layout::REG_ORDER[xlogue_layout::MAX_REGS] = {\n+/* The below offset values are where each register is stored for the layout\n+   relative to incoming stack pointer.  The value of each m_regs[].offset will\n+   be relative to the incoming base pointer (rax or rsi) used by the stub.\n+\n+    s_instances:   0\t\t1\t\t2\t\t3\n+    Offset:\t\t\t\t\trealigned or\taligned + 8\n+    Register\t   aligned\taligned + 8\taligned w/HFP\tw/HFP\t*/\n+    XMM15_REG,\t/* 0x10\t\t0x18\t\t0x10\t\t0x18\t*/\n+    XMM14_REG,\t/* 0x20\t\t0x28\t\t0x20\t\t0x28\t*/\n+    XMM13_REG,\t/* 0x30\t\t0x38\t\t0x30\t\t0x38\t*/\n+    XMM12_REG,\t/* 0x40\t\t0x48\t\t0x40\t\t0x48\t*/\n+    XMM11_REG,\t/* 0x50\t\t0x58\t\t0x50\t\t0x58\t*/\n+    XMM10_REG,\t/* 0x60\t\t0x68\t\t0x60\t\t0x68\t*/\n+    XMM9_REG,\t/* 0x70\t\t0x78\t\t0x70\t\t0x78\t*/\n+    XMM8_REG,\t/* 0x80\t\t0x88\t\t0x80\t\t0x88\t*/\n+    XMM7_REG,\t/* 0x90\t\t0x98\t\t0x90\t\t0x98\t*/\n+    XMM6_REG,\t/* 0xa0\t\t0xa8\t\t0xa0\t\t0xa8\t*/\n+    SI_REG,\t/* 0xa8\t\t0xb0\t\t0xa8\t\t0xb0\t*/\n+    DI_REG,\t/* 0xb0\t\t0xb8\t\t0xb0\t\t0xb8\t*/\n+    BX_REG,\t/* 0xb8\t\t0xc0\t\t0xb8\t\t0xc0\t*/\n+    BP_REG,\t/* 0xc0\t\t0xc8\t\tN/A\t\tN/A\t*/\n+    R12_REG,\t/* 0xc8\t\t0xd0\t\t0xc0\t\t0xc8\t*/\n+    R13_REG,\t/* 0xd0\t\t0xd8\t\t0xc8\t\t0xd0\t*/\n+    R14_REG,\t/* 0xd8\t\t0xe0\t\t0xd0\t\t0xd8\t*/\n+    R15_REG,\t/* 0xe0\t\t0xe8\t\t0xd8\t\t0xe0\t*/\n+};\n+\n+/* Instantiates all xlogue_layout instances.  */\n+const struct xlogue_layout GTY(())\n+xlogue_layout::s_instances[XLOGUE_SET_COUNT] = {\n+  xlogue_layout (0, false),\n+  xlogue_layout (8, false),\n+  xlogue_layout (0, true),\n+  xlogue_layout (8, true)\n+};\n+\n+/* Return an appropriate const instance of xlogue_layout based upon values\n+   in cfun->machine and crtl.  */\n+const struct xlogue_layout &xlogue_layout::get_instance ()\n+{\n+  enum xlogue_stub_sets stub_set;\n+  bool aligned_plus_8 = cfun->machine->call_ms2sysv_pad_in;\n+\n+  if (stack_realign_fp)\n+    stub_set = XLOGUE_SET_HFP_ALIGNED_OR_REALIGN;\n+  else if (frame_pointer_needed)\n+    stub_set = aligned_plus_8\n+\t      ? XLOGUE_SET_HFP_ALIGNED_PLUS_8\n+\t      : XLOGUE_SET_HFP_ALIGNED_OR_REALIGN;\n+  else\n+    stub_set = aligned_plus_8 ? XLOGUE_SET_ALIGNED_PLUS_8 : XLOGUE_SET_ALIGNED;\n+\n+  return s_instances[stub_set];\n+}\n+\n+/* Determine which clobbered registers can be saved by the stub and store\n+   them in stub_managed_regs.  Returns the count of registers the stub will\n+   save and restore.  */\n+unsigned\n+xlogue_layout::compute_stub_managed_regs (HARD_REG_SET &stub_managed_regs)\n+{\n+  bool hfp = frame_pointer_needed || stack_realign_fp;\n+\n+  unsigned i, count;\n+  unsigned regno;\n+\n+  for (i = 0; i < NUM_X86_64_MS_CLOBBERED_REGS; ++i)\n+    {\n+      regno = x86_64_ms_sysv_extra_clobbered_registers[i];\n+      if (regno == BP_REG && hfp)\n+\tcontinue;\n+      if (!ix86_save_reg (regno, false, false))\n+\treturn 0;\n+    }\n+\n+  for (count = i = 0; i < MAX_REGS; ++i)\n+    {\n+      regno = REG_ORDER[i];\n+      if (regno == BP_REG && hfp)\n+\tcontinue;\n+      if (!ix86_save_reg (regno, false, false))\n+\tbreak;\n+      add_to_hard_reg_set (&stub_managed_regs, DImode, regno);\n+      ++count;\n+    }\n+    gcc_assert (count >= MIN_REGS && count <= MAX_REGS);\n+    return count;\n+}\n+\n+/* Constructor for xlogue_layout.  */\n+xlogue_layout::xlogue_layout (HOST_WIDE_INT stack_align_off_in, bool hfp)\n+  : m_hfp (hfp) , m_nregs (hfp ? 17 : 18),\n+    m_stack_align_off_in (stack_align_off_in)\n+{\n+  memset (m_regs, 0, sizeof (m_regs));\n+  memset (m_stub_names, 0, sizeof (m_stub_names));\n+\n+  HOST_WIDE_INT offset = stack_align_off_in;\n+  unsigned i, j;\n+  for (i = j = 0; i < MAX_REGS; ++i)\n+    {\n+      unsigned regno = REG_ORDER[i];\n+\n+      if (regno == BP_REG && hfp)\n+\tcontinue;\n+      if (SSE_REGNO_P (regno))\n+\t{\n+\t  offset += 16;\n+\t  /* Verify that SSE regs are always aligned.  */\n+\t  gcc_assert (!((stack_align_off_in + offset) & 15));\n+\t}\n+      else\n+\toffset += 8;\n+\n+      m_regs[j].regno    = regno;\n+      m_regs[j++].offset = offset - STUB_INDEX_OFFSET;\n+    }\n+    gcc_assert (j == m_nregs);\n+}\n+\n+const char *xlogue_layout::get_stub_name (enum xlogue_stub stub,\n+\t\t\t\t\t  unsigned n_extra_regs) const\n+{\n+  xlogue_layout *writey_this = const_cast<xlogue_layout*>(this);\n+  char *name = writey_this->m_stub_names[stub][n_extra_regs];\n+\n+  /* Lazy init */\n+  if (!*name)\n+    {\n+      int res = snprintf (name, STUB_NAME_MAX_LEN, \"__%s_%u\",\n+\t\t\t  STUB_BASE_NAMES[stub], MIN_REGS + n_extra_regs);\n+      gcc_checking_assert (res <= (int)STUB_NAME_MAX_LEN);\n+    }\n+\n+  return name;\n+}\n+\n+/* Return rtx of a symbol ref for the entry point (based upon\n+   cfun->machine->call_ms2sysv_extra_regs) of the specified stub.  */\n+rtx xlogue_layout::get_stub_rtx (enum xlogue_stub stub) const\n+{\n+  const unsigned n_extra_regs = cfun->machine->call_ms2sysv_extra_regs;\n+  gcc_checking_assert (n_extra_regs <= MAX_EXTRA_REGS);\n+  gcc_assert (stub < XLOGUE_STUB_COUNT);\n+  gcc_assert (crtl->stack_realign_finalized);\n+\n+  return gen_rtx_SYMBOL_REF (Pmode, get_stub_name (stub, n_extra_regs));\n+}\n+\n /* Define the structure for the machine field in struct function.  */\n \n struct GTY(()) stack_local_entry {\n@@ -2453,12 +2715,29 @@ struct GTY(()) stack_local_entry {\n    saved frame pointer\t\t\tif frame_pointer_needed\n \t\t\t\t\t<- HARD_FRAME_POINTER\n    [saved regs]\n-\t\t\t\t\t<- regs_save_offset\n+\t\t\t\t\t<- reg_save_offset\n    [padding0]\n-\n+\t\t\t\t\t<- stack_realign_offset\n    [saved SSE regs]\n+\tOR\n+   [stub-saved registers for ms x64 --> sysv clobbers\n+\t\t\t<- Start of out-of-line, stub-saved/restored regs\n+\t\t\t   (see libgcc/config/i386/(sav|res)ms64*.S)\n+     [XMM6-15]\n+     [RSI]\n+     [RDI]\n+     [?RBX]\t\tonly if RBX is clobbered\n+     [?RBP]\t\tonly if RBP and RBX are clobbered\n+     [?R12]\t\tonly if R12 and all previous regs are clobbered\n+     [?R13]\t\tonly if R13 and all previous regs are clobbered\n+     [?R14]\t\tonly if R14 and all previous regs are clobbered\n+     [?R15]\t\tonly if R15 and all previous regs are clobbered\n+\t\t\t<- end of stub-saved/restored regs\n+     [padding1]\n+   ]\n+\t\t\t\t\t<- outlined_save_offset\n \t\t\t\t\t<- sse_regs_save_offset\n-   [padding1]          |\n+   [padding2]\n \t\t       |\t\t<- FRAME_POINTER\n    [va_arg registers]  |\n \t\t       |\n@@ -2481,6 +2760,9 @@ struct ix86_frame\n   HOST_WIDE_INT stack_pointer_offset;\n   HOST_WIDE_INT hfp_save_offset;\n   HOST_WIDE_INT reg_save_offset;\n+  HOST_WIDE_INT stack_realign_allocate_offset;\n+  HOST_WIDE_INT stack_realign_offset;\n+  HOST_WIDE_INT outlined_save_offset;\n   HOST_WIDE_INT sse_reg_save_offset;\n \n   /* When save_regs_using_mov is set, emit prologue using\n@@ -4506,7 +4788,8 @@ ix86_target_string (HOST_WIDE_INT isa, HOST_WIDE_INT isa2,\n     { \"-mstv\",\t\t\t\tMASK_STV },\n     { \"-mavx256-split-unaligned-load\",\tMASK_AVX256_SPLIT_UNALIGNED_LOAD },\n     { \"-mavx256-split-unaligned-store\",\tMASK_AVX256_SPLIT_UNALIGNED_STORE },\n-    { \"-mprefer-avx128\",\t\tMASK_PREFER_AVX128 }\n+    { \"-mprefer-avx128\",\t\tMASK_PREFER_AVX128 },\n+    { \"-mcall-ms2sysv-xlogues\",\t\tMASK_CALL_MS2SYSV_XLOGUES }\n   };\n \n   /* Additional flag options.  */\n@@ -6317,6 +6600,9 @@ ix86_option_override_internal (bool main_args_p,\n #endif\n    }\n \n+  if (TARGET_SEH && TARGET_CALL_MS2SYSV_XLOGUES)\n+    sorry (\"-mcall-ms2sysv-xlogues isn%'t currently supported with SEH\");\n+\n   if (!(opts_set->x_target_flags & MASK_VZEROUPPER))\n     opts->x_target_flags |= MASK_VZEROUPPER;\n   if (!(opts_set->x_target_flags & MASK_STV))\n@@ -12348,6 +12634,10 @@ ix86_hard_regno_scratch_ok (unsigned int regno)\n \t      && df_regs_ever_live_p (regno)));\n }\n \n+/* Registers who's save & restore will be managed by stubs called from\n+   pro/epilogue.  */\n+static HARD_REG_SET GTY(()) stub_managed_regs;\n+\n /* Return true if register class CL should be an additional allocno\n    class.  */\n \n@@ -12360,7 +12650,7 @@ ix86_additional_allocno_class_p (reg_class_t cl)\n /* Return TRUE if we need to save REGNO.  */\n \n static bool\n-ix86_save_reg (unsigned int regno, bool maybe_eh_return)\n+ix86_save_reg (unsigned int regno, bool maybe_eh_return, bool ignore_outlined)\n {\n   /* If there are no caller-saved registers, we preserve all registers,\n      except for MMX and x87 registers which aren't supported when saving\n@@ -12428,6 +12718,10 @@ ix86_save_reg (unsigned int regno, bool maybe_eh_return)\n \t}\n     }\n \n+  if (ignore_outlined && cfun->machine->call_ms2sysv\n+      && in_hard_reg_set_p (stub_managed_regs, DImode, regno))\n+    return false;\n+\n   if (crtl->drap_reg\n       && regno == REGNO (crtl->drap_reg)\n       && !cfun->machine->no_drap_save_restore)\n@@ -12448,7 +12742,7 @@ ix86_nsaved_regs (void)\n   int regno;\n \n   for (regno = 0; regno < FIRST_PSEUDO_REGISTER; regno++)\n-    if (GENERAL_REGNO_P (regno) && ix86_save_reg (regno, true))\n+    if (GENERAL_REGNO_P (regno) && ix86_save_reg (regno, true, true))\n       nregs ++;\n   return nregs;\n }\n@@ -12464,7 +12758,7 @@ ix86_nsaved_sseregs (void)\n   if (!TARGET_64BIT_MS_ABI)\n     return 0;\n   for (regno = 0; regno < FIRST_PSEUDO_REGISTER; regno++)\n-    if (SSE_REGNO_P (regno) && ix86_save_reg (regno, true))\n+    if (SSE_REGNO_P (regno) && ix86_save_reg (regno, true, true))\n       nregs ++;\n   return nregs;\n }\n@@ -12524,6 +12818,15 @@ ix86_builtin_setjmp_frame_value (void)\n   return stack_realign_fp ? hard_frame_pointer_rtx : virtual_stack_vars_rtx;\n }\n \n+/* Disables out-of-lined msabi to sysv pro/epilogues and emits a warning if\n+   warn_once is null, or *warn_once is zero.  */\n+static void disable_call_ms2sysv_xlogues (const char *feature)\n+{\n+  cfun->machine->call_ms2sysv = false;\n+  warning (OPT_mcall_ms2sysv_xlogues, \"not currently compatible with %s.\",\n+\t   feature);\n+}\n+\n /* When using -fsplit-stack, the allocation routines set a field in\n    the TCB to the bottom of the stack plus this much space, measured\n    in bytes.  */\n@@ -12535,14 +12838,57 @@ ix86_builtin_setjmp_frame_value (void)\n static void\n ix86_compute_frame_layout (struct ix86_frame *frame)\n {\n+  struct machine_function *m = cfun->machine;\n   unsigned HOST_WIDE_INT stack_alignment_needed;\n   HOST_WIDE_INT offset;\n   unsigned HOST_WIDE_INT preferred_alignment;\n   HOST_WIDE_INT size = get_frame_size ();\n   HOST_WIDE_INT to_allocate;\n \n+  CLEAR_HARD_REG_SET (stub_managed_regs);\n+\n+  /* m->call_ms2sysv is initially enabled in ix86_expand_call for all 64-bit\n+   * ms_abi functions that call a sysv function.  We now need to prune away\n+   * cases where it should be disabled.  */\n+  if (TARGET_64BIT && m->call_ms2sysv)\n+  {\n+    gcc_assert (TARGET_64BIT_MS_ABI);\n+    gcc_assert (TARGET_CALL_MS2SYSV_XLOGUES);\n+    gcc_assert (!TARGET_SEH);\n+\n+    if (!TARGET_SSE)\n+      m->call_ms2sysv = false;\n+\n+    /* Don't break hot-patched functions.  */\n+    else if (ix86_function_ms_hook_prologue (current_function_decl))\n+      m->call_ms2sysv = false;\n+\n+    /* TODO: Cases not yet examined.  */\n+    else if (crtl->calls_eh_return)\n+      disable_call_ms2sysv_xlogues (\"__builtin_eh_return\");\n+\n+    else if (ix86_static_chain_on_stack)\n+      disable_call_ms2sysv_xlogues (\"static call chains\");\n+\n+    else if (ix86_using_red_zone ())\n+      disable_call_ms2sysv_xlogues (\"red zones\");\n+\n+    else if (flag_split_stack)\n+      disable_call_ms2sysv_xlogues (\"split stack\");\n+\n+    /* Finally, compute which registers the stub will manage.  */\n+    else\n+      {\n+\tunsigned count = xlogue_layout\n+\t\t\t ::compute_stub_managed_regs (stub_managed_regs);\n+\tm->call_ms2sysv_extra_regs = count - xlogue_layout::MIN_REGS;\n+      }\n+  }\n+\n   frame->nregs = ix86_nsaved_regs ();\n   frame->nsseregs = ix86_nsaved_sseregs ();\n+  m->call_ms2sysv_pad_in = 0;\n+  m->call_ms2sysv_pad_out = 0;\n \n   /* 64-bit MS ABI seem to require stack alignment to be always 16,\n      except for function prologues, leaf functions and when the defult\n@@ -12569,19 +12915,19 @@ ix86_compute_frame_layout (struct ix86_frame *frame)\n      scheduling that can be done, which means that there's very little point\n      in doing anything except PUSHs.  */\n   if (TARGET_SEH)\n-    cfun->machine->use_fast_prologue_epilogue = false;\n+    m->use_fast_prologue_epilogue = false;\n \n   /* During reload iteration the amount of registers saved can change.\n      Recompute the value as needed.  Do not recompute when amount of registers\n      didn't change as reload does multiple calls to the function and does not\n      expect the decision to change within single iteration.  */\n   else if (!optimize_bb_for_size_p (ENTRY_BLOCK_PTR_FOR_FN (cfun))\n-           && cfun->machine->use_fast_prologue_epilogue_nregs != frame->nregs)\n+\t   && m->use_fast_prologue_epilogue_nregs != frame->nregs)\n     {\n       int count = frame->nregs;\n       struct cgraph_node *node = cgraph_node::get (current_function_decl);\n \n-      cfun->machine->use_fast_prologue_epilogue_nregs = count;\n+      m->use_fast_prologue_epilogue_nregs = count;\n \n       /* The fast prologue uses move instead of push to save registers.  This\n          is significantly longer, but also executes faster as modern hardware\n@@ -12598,14 +12944,14 @@ ix86_compute_frame_layout (struct ix86_frame *frame)\n       if (node->frequency < NODE_FREQUENCY_NORMAL\n \t  || (flag_branch_probabilities\n \t      && node->frequency < NODE_FREQUENCY_HOT))\n-        cfun->machine->use_fast_prologue_epilogue = false;\n+\tm->use_fast_prologue_epilogue = false;\n       else\n-        cfun->machine->use_fast_prologue_epilogue\n+\tm->use_fast_prologue_epilogue\n \t   = !expensive_function_p (count);\n     }\n \n   frame->save_regs_using_mov\n-    = (TARGET_PROLOGUE_USING_MOVE && cfun->machine->use_fast_prologue_epilogue\n+    = (TARGET_PROLOGUE_USING_MOVE && m->use_fast_prologue_epilogue\n        /* If static stack checking is enabled and done with probes,\n \t  the registers need to be saved before allocating the frame.  */\n        && flag_stack_check != STATIC_BUILTIN_STACK_CHECK);\n@@ -12634,28 +12980,54 @@ ix86_compute_frame_layout (struct ix86_frame *frame)\n   if (TARGET_SEH)\n     frame->hard_frame_pointer_offset = offset;\n \n+  /* When re-aligning the stack frame, but not saving SSE registers, this\n+     is the offset we want adjust the stack pointer to.  */\n+  frame->stack_realign_allocate_offset = offset;\n+\n+  /* The re-aligned stack starts here.  Values before this point are not\n+     directly comparable with values below this point.  Use sp_valid_at\n+     to determine if the stack pointer is valid for a given offset and\n+     fp_valid_at for the frame pointer.  */\n+  if (stack_realign_fp)\n+    offset = ROUND_UP (offset, stack_alignment_needed);\n+  frame->stack_realign_offset = offset;\n+\n+  if (TARGET_64BIT && m->call_ms2sysv)\n+    {\n+      gcc_assert (stack_alignment_needed >= 16);\n+      gcc_assert (!frame->nsseregs);\n+\n+      m->call_ms2sysv_pad_in = !!(offset & UNITS_PER_WORD);\n+\n+      /* Select an appropriate layout for incoming stack offset.  */\n+      const struct xlogue_layout &xlogue = xlogue_layout::get_instance ();\n+\n+      if ((offset + xlogue.get_stack_space_used ()) & UNITS_PER_WORD)\n+\tm->call_ms2sysv_pad_out = 1;\n+\n+      offset += xlogue.get_stack_space_used ();\n+      gcc_assert (!(offset & 0xf));\n+      frame->outlined_save_offset = offset;\n+    }\n+\n   /* Align and set SSE register save area.  */\n-  if (frame->nsseregs)\n+  else if (frame->nsseregs)\n     {\n       /* The only ABI that has saved SSE registers (Win64) also has a\n-\t 16-byte aligned default stack, and thus we don't need to be\n-\t within the re-aligned local stack frame to save them.  In case\n-\t incoming stack boundary is aligned to less than 16 bytes,\n-\t unaligned move of SSE register will be emitted, so there is\n-\t no point to round up the SSE register save area outside the\n-\t re-aligned local stack frame to 16 bytes.  */\n-      if (ix86_incoming_stack_boundary >= 128)\n+\t 16-byte aligned default stack.  However, many programs violate\n+\t the ABI, and Wine64 forces stack realignment to compensate.\n+\n+\t If the incoming stack boundary is at least 16 bytes, or DRAP is\n+\t required and the DRAP re-alignment boundary is at least 16 bytes,\n+\t then we want the SSE register save area properly aligned.  */\n+      if (ix86_incoming_stack_boundary >= 128\n+\t       || (stack_realign_drap && stack_alignment_needed >= 16))\n \toffset = ROUND_UP (offset, 16);\n       offset += frame->nsseregs * 16;\n+      frame->stack_realign_allocate_offset = offset;\n     }\n-  frame->sse_reg_save_offset = offset;\n \n-  /* The re-aligned stack starts here.  Values before this point are not\n-     directly comparable with values below this point.  In order to make\n-     sure that no value happens to be the same before and after, force\n-     the alignment computation below to add a non-zero value.  */\n-  if (stack_realign_fp)\n-    offset = ROUND_UP (offset, stack_alignment_needed);\n+  frame->sse_reg_save_offset = offset;\n \n   /* Va-arg area */\n   frame->va_arg_size = ix86_varargs_gpr_size + ix86_varargs_fpr_size;\n@@ -12771,15 +13143,57 @@ choose_baseaddr_len (unsigned int regno, HOST_WIDE_INT offset)\n   return len;\n }\n \n-/* Return an RTX that points to CFA_OFFSET within the stack frame.\n-   The valid base registers are taken from CFUN->MACHINE->FS.  */\n+/* Determine if the stack pointer is valid for accessing the cfa_offset.  */\n \n-static rtx\n-choose_baseaddr (HOST_WIDE_INT cfa_offset)\n+static inline bool sp_valid_at (HOST_WIDE_INT cfa_offset)\n+{\n+  const struct machine_frame_state &fs = cfun->machine->fs;\n+  return fs.sp_valid && !(fs.sp_realigned\n+\t\t\t  && cfa_offset < fs.sp_realigned_offset);\n+}\n+\n+/* Determine if the frame pointer is valid for accessing the cfa_offset.  */\n+\n+static inline bool fp_valid_at (HOST_WIDE_INT cfa_offset)\n+{\n+  const struct machine_frame_state &fs = cfun->machine->fs;\n+  return fs.fp_valid && !(fs.sp_valid && fs.sp_realigned\n+\t\t\t  && cfa_offset >= fs.sp_realigned_offset);\n+}\n+\n+/* Choose a base register based upon alignment requested, speed and/or\n+   size.  */\n+\n+static void choose_basereg (HOST_WIDE_INT cfa_offset, rtx &base_reg,\n+\t\t\t    HOST_WIDE_INT &base_offset,\n+\t\t\t    unsigned int align_reqested, unsigned int *align)\n {\n   const struct machine_function *m = cfun->machine;\n-  rtx base_reg = NULL;\n-  HOST_WIDE_INT base_offset = 0;\n+  unsigned int hfp_align;\n+  unsigned int drap_align;\n+  unsigned int sp_align;\n+  bool hfp_ok  = fp_valid_at (cfa_offset);\n+  bool drap_ok = m->fs.drap_valid;\n+  bool sp_ok   = sp_valid_at (cfa_offset);\n+\n+  hfp_align = drap_align = sp_align = INCOMING_STACK_BOUNDARY;\n+\n+  /* Filter out any registers that don't meet the requested alignment\n+     criteria.  */\n+  if (align_reqested)\n+    {\n+      if (m->fs.realigned)\n+\thfp_align = drap_align = sp_align = crtl->stack_alignment_needed;\n+      /* SEH unwind code does do not currently support REG_CFA_EXPRESSION\n+\t notes (which we would need to use a realigned stack pointer),\n+\t so disable on SEH targets.  */\n+      else if (m->fs.sp_realigned)\n+\tsp_align = crtl->stack_alignment_needed;\n+\n+      hfp_ok = hfp_ok && hfp_align >= align_reqested;\n+      drap_ok = drap_ok && drap_align >= align_reqested;\n+      sp_ok = sp_ok && sp_align >= align_reqested;\n+    }\n \n   if (m->use_fast_prologue_epilogue)\n     {\n@@ -12788,17 +13202,17 @@ choose_baseaddr (HOST_WIDE_INT cfa_offset)\n          while DRAP must be reloaded within the epilogue.  But choose either\n          over the SP due to increased encoding size.  */\n \n-      if (m->fs.fp_valid)\n+      if (hfp_ok)\n \t{\n \t  base_reg = hard_frame_pointer_rtx;\n \t  base_offset = m->fs.fp_offset - cfa_offset;\n \t}\n-      else if (m->fs.drap_valid)\n+      else if (drap_ok)\n \t{\n \t  base_reg = crtl->drap_reg;\n \t  base_offset = 0 - cfa_offset;\n \t}\n-      else if (m->fs.sp_valid)\n+      else if (sp_ok)\n \t{\n \t  base_reg = stack_pointer_rtx;\n \t  base_offset = m->fs.sp_offset - cfa_offset;\n@@ -12811,13 +13225,13 @@ choose_baseaddr (HOST_WIDE_INT cfa_offset)\n \n       /* Choose the base register with the smallest address encoding.\n          With a tie, choose FP > DRAP > SP.  */\n-      if (m->fs.sp_valid)\n+      if (sp_ok)\n \t{\n \t  base_reg = stack_pointer_rtx;\n \t  base_offset = m->fs.sp_offset - cfa_offset;\n           len = choose_baseaddr_len (STACK_POINTER_REGNUM, base_offset);\n \t}\n-      if (m->fs.drap_valid)\n+      if (drap_ok)\n \t{\n \t  toffset = 0 - cfa_offset;\n \t  tlen = choose_baseaddr_len (REGNO (crtl->drap_reg), toffset);\n@@ -12828,7 +13242,7 @@ choose_baseaddr (HOST_WIDE_INT cfa_offset)\n \t      len = tlen;\n \t    }\n \t}\n-      if (m->fs.fp_valid)\n+      if (hfp_ok)\n \t{\n \t  toffset = m->fs.fp_offset - cfa_offset;\n \t  tlen = choose_baseaddr_len (HARD_FRAME_POINTER_REGNUM, toffset);\n@@ -12840,8 +13254,40 @@ choose_baseaddr (HOST_WIDE_INT cfa_offset)\n \t    }\n \t}\n     }\n-  gcc_assert (base_reg != NULL);\n \n+    /* Set the align return value.  */\n+    if (align)\n+      {\n+\tif (base_reg == stack_pointer_rtx)\n+\t  *align = sp_align;\n+\telse if (base_reg == crtl->drap_reg)\n+\t  *align = drap_align;\n+\telse if (base_reg == hard_frame_pointer_rtx)\n+\t  *align = hfp_align;\n+      }\n+}\n+\n+/* Return an RTX that points to CFA_OFFSET within the stack frame and\n+   the alignment of address.  If align is non-null, it should point to\n+   an alignment value (in bits) that is preferred or zero and will\n+   recieve the alignment of the base register that was selected.  The\n+   valid base registers are taken from CFUN->MACHINE->FS.  */\n+\n+static rtx\n+choose_baseaddr (HOST_WIDE_INT cfa_offset, unsigned int *align)\n+{\n+  rtx base_reg = NULL;\n+  HOST_WIDE_INT base_offset = 0;\n+\n+  /* If a specific alignment is requested, try to get a base register\n+     with that alignment first.  */\n+  if (align && *align)\n+    choose_basereg (cfa_offset, base_reg, base_offset, *align, align);\n+\n+  if (!base_reg)\n+    choose_basereg (cfa_offset, base_reg, base_offset, 0, align);\n+\n+  gcc_assert (base_reg != NULL);\n   return plus_constant (Pmode, base_reg, base_offset);\n }\n \n@@ -12854,7 +13300,7 @@ ix86_emit_save_regs (void)\n   rtx_insn *insn;\n \n   for (regno = FIRST_PSEUDO_REGISTER - 1; regno-- > 0; )\n-    if (GENERAL_REGNO_P (regno) && ix86_save_reg (regno, true))\n+    if (GENERAL_REGNO_P (regno) && ix86_save_reg (regno, true, true))\n       {\n \tinsn = emit_insn (gen_push (gen_rtx_REG (word_mode, regno)));\n \tRTX_FRAME_RELATED_P (insn) = 1;\n@@ -12870,13 +13316,14 @@ ix86_emit_save_reg_using_mov (machine_mode mode, unsigned int regno,\n   struct machine_function *m = cfun->machine;\n   rtx reg = gen_rtx_REG (mode, regno);\n   rtx mem, addr, base, insn;\n-  unsigned int align;\n+  unsigned int align = GET_MODE_ALIGNMENT (mode);\n \n-  addr = choose_baseaddr (cfa_offset);\n+  addr = choose_baseaddr (cfa_offset, &align);\n   mem = gen_frame_mem (mode, addr);\n \n-  /* The location is aligned up to INCOMING_STACK_BOUNDARY.  */\n-  align = MIN (GET_MODE_ALIGNMENT (mode), INCOMING_STACK_BOUNDARY);\n+  /* The location aligment depends upon the base register.  */\n+  align = MIN (GET_MODE_ALIGNMENT (mode), align);\n+  gcc_assert (! (cfa_offset & (align / BITS_PER_UNIT - 1)));\n   set_mem_align (mem, align);\n \n   insn = emit_insn (gen_rtx_SET (mem, reg));\n@@ -12916,6 +13363,13 @@ ix86_emit_save_reg_using_mov (machine_mode mode, unsigned int regno,\n \t}\n     }\n \n+  else if (base == stack_pointer_rtx && m->fs.sp_realigned\n+\t   && cfa_offset >= m->fs.sp_realigned_offset)\n+    {\n+      gcc_checking_assert (stack_realign_fp);\n+      add_reg_note (insn, REG_CFA_EXPRESSION, gen_rtx_SET (mem, reg));\n+    }\n+\n   /* The memory may not be relative to the current CFA register,\n      which means that we may need to generate a new pattern for\n      use by the unwind info.  */\n@@ -12936,7 +13390,7 @@ ix86_emit_save_regs_using_mov (HOST_WIDE_INT cfa_offset)\n   unsigned int regno;\n \n   for (regno = 0; regno < FIRST_PSEUDO_REGISTER; regno++)\n-    if (GENERAL_REGNO_P (regno) && ix86_save_reg (regno, true))\n+    if (GENERAL_REGNO_P (regno) && ix86_save_reg (regno, true, true))\n       {\n         ix86_emit_save_reg_using_mov (word_mode, regno, cfa_offset);\n \tcfa_offset -= UNITS_PER_WORD;\n@@ -12951,7 +13405,7 @@ ix86_emit_save_sse_regs_using_mov (HOST_WIDE_INT cfa_offset)\n   unsigned int regno;\n \n   for (regno = 0; regno < FIRST_PSEUDO_REGISTER; regno++)\n-    if (SSE_REGNO_P (regno) && ix86_save_reg (regno, true))\n+    if (SSE_REGNO_P (regno) && ix86_save_reg (regno, true, true))\n       {\n \tix86_emit_save_reg_using_mov (V4SFmode, regno, cfa_offset);\n \tcfa_offset -= GET_MODE_SIZE (V4SFmode);\n@@ -13069,15 +13523,18 @@ pro_epilogue_adjust_stack (rtx dest, rtx src, rtx offset,\n     {\n       HOST_WIDE_INT ooffset = m->fs.sp_offset;\n       bool valid = m->fs.sp_valid;\n+      bool realigned = m->fs.sp_realigned;\n \n       if (src == hard_frame_pointer_rtx)\n \t{\n \t  valid = m->fs.fp_valid;\n+\t  realigned = false;\n \t  ooffset = m->fs.fp_offset;\n \t}\n       else if (src == crtl->drap_reg)\n \t{\n \t  valid = m->fs.drap_valid;\n+\t  realigned = false;\n \t  ooffset = 0;\n \t}\n       else\n@@ -13091,6 +13548,7 @@ pro_epilogue_adjust_stack (rtx dest, rtx src, rtx offset,\n \n       m->fs.sp_offset = ooffset - INTVAL (offset);\n       m->fs.sp_valid = valid;\n+      m->fs.sp_realigned = realigned;\n     }\n }\n \n@@ -13331,13 +13789,13 @@ get_scratch_register_on_entry (struct scratch_reg *sr)\n \t       && !static_chain_p\n \t       && drap_regno != CX_REG)\n \tregno = CX_REG;\n-      else if (ix86_save_reg (BX_REG, true))\n+      else if (ix86_save_reg (BX_REG, true, false))\n \tregno = BX_REG;\n       /* esi is the static chain register.  */\n       else if (!(regparm == 3 && static_chain_p)\n-\t       && ix86_save_reg (SI_REG, true))\n+\t       && ix86_save_reg (SI_REG, true, false))\n \tregno = SI_REG;\n-      else if (ix86_save_reg (DI_REG, true))\n+      else if (ix86_save_reg (DI_REG, true, false))\n \tregno = DI_REG;\n       else\n \t{\n@@ -13811,6 +14269,78 @@ ix86_elim_entry_set_got (rtx reg)\n     }\n }\n \n+static rtx\n+gen_frame_set (rtx reg, rtx frame_reg, int offset, bool store)\n+{\n+  rtx addr, mem;\n+\n+  if (offset)\n+    addr = gen_rtx_PLUS (Pmode, frame_reg, GEN_INT (offset));\n+  mem = gen_frame_mem (GET_MODE (reg), offset ? addr : frame_reg);\n+  return gen_rtx_SET (store ? mem : reg, store ? reg : mem);\n+}\n+\n+static inline rtx\n+gen_frame_load (rtx reg, rtx frame_reg, int offset)\n+{\n+  return gen_frame_set (reg, frame_reg, offset, false);\n+}\n+\n+static inline rtx\n+gen_frame_store (rtx reg, rtx frame_reg, int offset)\n+{\n+  return gen_frame_set (reg, frame_reg, offset, true);\n+}\n+\n+static void\n+ix86_emit_outlined_ms2sysv_save (const struct ix86_frame &frame)\n+{\n+  struct machine_function *m = cfun->machine;\n+  const unsigned ncregs = NUM_X86_64_MS_CLOBBERED_REGS\n+\t\t\t  + m->call_ms2sysv_extra_regs;\n+  rtvec v = rtvec_alloc (ncregs + 1);\n+  unsigned int align, i, vi = 0;\n+  rtx_insn *insn;\n+  rtx sym, addr;\n+  rtx rax = gen_rtx_REG (word_mode, AX_REG);\n+  const struct xlogue_layout &xlogue = xlogue_layout::get_instance ();\n+  HOST_WIDE_INT rax_offset = xlogue.get_stub_ptr_offset () + m->fs.sp_offset;\n+  HOST_WIDE_INT stack_alloc_size = frame.stack_pointer_offset - m->fs.sp_offset;\n+  HOST_WIDE_INT stack_align_off_in = xlogue.get_stack_align_off_in ();\n+\n+  /* Verify that the incoming stack 16-byte alignment offset matches the\n+     layout we're using.  */\n+  gcc_assert (stack_align_off_in == (m->fs.sp_offset & UNITS_PER_WORD));\n+\n+  /* Get the stub symbol.  */\n+  sym = xlogue.get_stub_rtx (frame_pointer_needed ? XLOGUE_STUB_SAVE_HFP\n+\t\t\t\t\t\t  : XLOGUE_STUB_SAVE);\n+  RTVEC_ELT (v, vi++) = gen_rtx_USE (VOIDmode, sym);\n+\n+  /* Setup RAX as the stub's base pointer.  */\n+  align = GET_MODE_ALIGNMENT (V4SFmode);\n+  addr = choose_baseaddr (rax_offset, &align);\n+  gcc_assert (align >= GET_MODE_ALIGNMENT (V4SFmode));\n+  insn = emit_insn (gen_rtx_SET (rax, addr));\n+\n+  gcc_assert (stack_alloc_size >= xlogue.get_stack_space_used ());\n+  pro_epilogue_adjust_stack (stack_pointer_rtx, stack_pointer_rtx,\n+\t\t\t     GEN_INT (-stack_alloc_size), -1,\n+\t\t\t     m->fs.cfa_reg == stack_pointer_rtx);\n+  for (i = 0; i < ncregs; ++i)\n+    {\n+      const xlogue_layout::reginfo &r = xlogue.get_reginfo (i);\n+      rtx reg = gen_rtx_REG ((SSE_REGNO_P (r.regno) ? V4SFmode : word_mode),\n+\t\t\t     r.regno);\n+      RTVEC_ELT (v, vi++) = gen_frame_store (reg, rax, -r.offset);;\n+    }\n+\n+  gcc_assert (vi == (unsigned)GET_NUM_ELEM (v));\n+\n+  insn = emit_insn (gen_rtx_PARALLEL (VOIDmode, v));\n+  RTX_FRAME_RELATED_P (insn) = true;\n+}\n+\n /* Expand the prologue into a bunch of separate insns.  */\n \n void\n@@ -13840,6 +14370,7 @@ ix86_expand_prologue (void)\n      this is fudged; we're interested to offsets within the local frame.  */\n   m->fs.sp_offset = INCOMING_FRAME_SP_OFFSET;\n   m->fs.sp_valid = true;\n+  m->fs.sp_realigned = false;\n \n   ix86_compute_frame_layout (&frame);\n \n@@ -14056,25 +14587,34 @@ ix86_expand_prologue (void)\n \t that we must allocate the size of the register save area before\n \t performing the actual alignment.  Otherwise we cannot guarantee\n \t that there's enough storage above the realignment point.  */\n-      if (m->fs.sp_offset != frame.sse_reg_save_offset)\n+      allocate = frame.stack_realign_allocate_offset - m->fs.sp_offset;\n+      if (allocate && !m->call_ms2sysv)\n         pro_epilogue_adjust_stack (stack_pointer_rtx, stack_pointer_rtx,\n-\t\t\t\t   GEN_INT (m->fs.sp_offset\n-\t\t\t\t\t    - frame.sse_reg_save_offset),\n-\t\t\t\t   -1, false);\n+\t\t\t\t   GEN_INT (-allocate), -1, false);\n \n       /* Align the stack.  */\n       insn = emit_insn (ix86_gen_andsp (stack_pointer_rtx,\n \t\t\t\t\tstack_pointer_rtx,\n \t\t\t\t\tGEN_INT (-align_bytes)));\n-\n       /* For the purposes of register save area addressing, the stack\n-         pointer is no longer valid.  As for the value of sp_offset,\n-\t see ix86_compute_frame_layout, which we need to match in order\n-\t to pass verification of stack_pointer_offset at the end.  */\n+\t pointer can no longer be used to access anything in the frame\n+\t below m->fs.sp_realigned_offset and the frame pointer cannot be\n+\t used for anything at or above.  */\n       m->fs.sp_offset = ROUND_UP (m->fs.sp_offset, align_bytes);\n-      m->fs.sp_valid = false;\n+      m->fs.sp_realigned = true;\n+      m->fs.sp_realigned_offset = m->fs.sp_offset - frame.nsseregs * 16;\n+      gcc_assert (m->fs.sp_realigned_offset == frame.stack_realign_offset);\n+      /* SEH unwind emit doesn't currently support REG_CFA_EXPRESSION, which\n+\t is needed to describe where a register is saved using a realigned\n+\t stack pointer, so we need to invalidate the stack pointer for that\n+\t target.  */\n+      if (TARGET_SEH)\n+\tm->fs.sp_valid = false;\n     }\n \n+  if (m->call_ms2sysv)\n+    ix86_emit_outlined_ms2sysv_save (frame);\n+\n   allocate = frame.stack_pointer_offset - m->fs.sp_offset;\n \n   if (flag_stack_usage_info)\n@@ -14308,7 +14848,7 @@ ix86_expand_prologue (void)\n       /* vDRAP is setup but after reload it turns out stack realign\n          isn't necessary, here we will emit prologue to setup DRAP\n          without stack realign adjustment */\n-      t = choose_baseaddr (0);\n+      t = choose_baseaddr (0, NULL);\n       emit_insn (gen_rtx_SET (crtl->drap_reg, t));\n     }\n \n@@ -14395,22 +14935,25 @@ ix86_emit_restore_regs_using_pop (void)\n   unsigned int regno;\n \n   for (regno = 0; regno < FIRST_PSEUDO_REGISTER; regno++)\n-    if (GENERAL_REGNO_P (regno) && ix86_save_reg (regno, false))\n+    if (GENERAL_REGNO_P (regno) && ix86_save_reg (regno, false, true))\n       ix86_emit_restore_reg_using_pop (gen_rtx_REG (word_mode, regno));\n }\n \n-/* Emit code and notes for the LEAVE instruction.  */\n+/* Emit code and notes for the LEAVE instruction.  If insn is non-null,\n+   omits the emit and only attaches the notes.  */\n \n static void\n-ix86_emit_leave (void)\n+ix86_emit_leave (rtx_insn *insn)\n {\n   struct machine_function *m = cfun->machine;\n-  rtx_insn *insn = emit_insn (ix86_gen_leave ());\n+  if (!insn)\n+    insn = emit_insn (ix86_gen_leave ());\n \n   ix86_add_queued_cfa_restore_notes (insn);\n \n   gcc_assert (m->fs.fp_valid);\n   m->fs.sp_valid = true;\n+  m->fs.sp_realigned = false;\n   m->fs.sp_offset = m->fs.fp_offset - UNITS_PER_WORD;\n   m->fs.fp_valid = false;\n \n@@ -14438,13 +14981,13 @@ ix86_emit_restore_regs_using_mov (HOST_WIDE_INT cfa_offset,\n   unsigned int regno;\n \n   for (regno = 0; regno < FIRST_PSEUDO_REGISTER; regno++)\n-    if (GENERAL_REGNO_P (regno) && ix86_save_reg (regno, maybe_eh_return))\n+    if (GENERAL_REGNO_P (regno) && ix86_save_reg (regno, maybe_eh_return, true))\n       {\n \trtx reg = gen_rtx_REG (word_mode, regno);\n \trtx mem;\n \trtx_insn *insn;\n \n-\tmem = choose_baseaddr (cfa_offset);\n+\tmem = choose_baseaddr (cfa_offset, NULL);\n \tmem = gen_frame_mem (word_mode, mem);\n \tinsn = emit_move_insn (reg, mem);\n \n@@ -14477,17 +15020,18 @@ ix86_emit_restore_sse_regs_using_mov (HOST_WIDE_INT cfa_offset,\n   unsigned int regno;\n \n   for (regno = 0; regno < FIRST_PSEUDO_REGISTER; regno++)\n-    if (SSE_REGNO_P (regno) && ix86_save_reg (regno, maybe_eh_return))\n+    if (SSE_REGNO_P (regno) && ix86_save_reg (regno, maybe_eh_return, true))\n       {\n \trtx reg = gen_rtx_REG (V4SFmode, regno);\n \trtx mem;\n-\tunsigned int align;\n+\tunsigned int align = GET_MODE_ALIGNMENT (V4SFmode);\n \n-\tmem = choose_baseaddr (cfa_offset);\n+\tmem = choose_baseaddr (cfa_offset, &align);\n \tmem = gen_rtx_MEM (V4SFmode, mem);\n \n-\t/* The location is aligned up to INCOMING_STACK_BOUNDARY.  */\n-\talign = MIN (GET_MODE_ALIGNMENT (V4SFmode), INCOMING_STACK_BOUNDARY);\n+\t/* The location aligment depends upon the base register.  */\n+\talign = MIN (GET_MODE_ALIGNMENT (V4SFmode), align);\n+\tgcc_assert (! (cfa_offset & (align / BITS_PER_UNIT - 1)));\n \tset_mem_align (mem, align);\n \temit_insn (gen_rtx_SET (reg, mem));\n \n@@ -14497,6 +15041,164 @@ ix86_emit_restore_sse_regs_using_mov (HOST_WIDE_INT cfa_offset,\n       }\n }\n \n+static void\n+ix86_emit_outlined_ms2sysv_restore (const struct ix86_frame &frame,\n+\t\t\t\t  bool use_call, int style)\n+{\n+  struct machine_function *m = cfun->machine;\n+  const unsigned ncregs = NUM_X86_64_MS_CLOBBERED_REGS\n+\t\t\t  + m->call_ms2sysv_extra_regs;\n+  rtvec v;\n+  unsigned int elems_needed, align, i, vi = 0;\n+  rtx_insn *insn;\n+  rtx sym, tmp;\n+  rtx rsi = gen_rtx_REG (word_mode, SI_REG);\n+  rtx r10 = NULL_RTX;\n+  const struct xlogue_layout &xlogue = xlogue_layout::get_instance ();\n+  HOST_WIDE_INT stub_ptr_offset = xlogue.get_stub_ptr_offset ();\n+  HOST_WIDE_INT rsi_offset = frame.stack_realign_offset + stub_ptr_offset;\n+  rtx rsi_frame_load = NULL_RTX;\n+  HOST_WIDE_INT rsi_restore_offset = (HOST_WIDE_INT)-1;\n+  enum xlogue_stub stub;\n+\n+  gcc_assert (!m->fs.fp_valid || frame_pointer_needed);\n+\n+  /* If using a realigned stack, we should never start with padding.  */\n+  gcc_assert (!stack_realign_fp || !xlogue.get_stack_align_off_in ());\n+\n+  /* Setup RSI as the stub's base pointer.  */\n+  align = GET_MODE_ALIGNMENT (V4SFmode);\n+  tmp = choose_baseaddr (rsi_offset, &align);\n+  gcc_assert (align >= GET_MODE_ALIGNMENT (V4SFmode));\n+  emit_insn (gen_rtx_SET (rsi, tmp));\n+\n+  /* Get a symbol for the stub.  */\n+  if (frame_pointer_needed)\n+    stub = use_call ? XLOGUE_STUB_RESTORE_HFP\n+\t\t    : XLOGUE_STUB_RESTORE_HFP_TAIL;\n+  else\n+    stub = use_call ? XLOGUE_STUB_RESTORE\n+\t\t    : XLOGUE_STUB_RESTORE_TAIL;\n+  sym = xlogue.get_stub_rtx (stub);\n+\n+  elems_needed = ncregs;\n+  if (use_call)\n+    elems_needed += 1;\n+  else\n+    elems_needed += frame_pointer_needed ? 5 : 3;\n+  v = rtvec_alloc (elems_needed);\n+\n+  /* We call the epilogue stub when we need to pop incoming args or we are\n+     doing a sibling call as the tail.  Otherwise, we will emit a jmp to the\n+     epilogue stub and it is the tail-call.  */\n+  if (use_call)\n+      RTVEC_ELT (v, vi++) = gen_rtx_USE (VOIDmode, sym);\n+  else\n+    {\n+      RTVEC_ELT (v, vi++) = ret_rtx;\n+      RTVEC_ELT (v, vi++) = gen_rtx_USE (VOIDmode, sym);\n+      if (frame_pointer_needed)\n+\t{\n+\t  rtx rbp = gen_rtx_REG (DImode, BP_REG);\n+\t  gcc_assert (m->fs.fp_valid);\n+\t  gcc_assert (m->fs.cfa_reg == hard_frame_pointer_rtx);\n+\n+\t  tmp = gen_rtx_PLUS (DImode, rbp, GEN_INT (8));\n+\t  RTVEC_ELT (v, vi++) = gen_rtx_SET (stack_pointer_rtx, tmp);\n+\t  RTVEC_ELT (v, vi++) = gen_rtx_SET (rbp, gen_rtx_MEM (DImode, rbp));\n+\t  tmp = gen_rtx_MEM (BLKmode, gen_rtx_SCRATCH (VOIDmode));\n+\t  RTVEC_ELT (v, vi++) = gen_rtx_CLOBBER (VOIDmode, tmp);\n+\t}\n+      else\n+\t{\n+\t  /* If no hard frame pointer, we set R10 to the SP restore value.  */\n+\t  gcc_assert (!m->fs.fp_valid);\n+\t  gcc_assert (m->fs.cfa_reg == stack_pointer_rtx);\n+\t  gcc_assert (m->fs.sp_valid);\n+\n+\t  r10 = gen_rtx_REG (DImode, R10_REG);\n+\t  tmp = gen_rtx_PLUS (Pmode, rsi, GEN_INT (stub_ptr_offset));\n+\t  emit_insn (gen_rtx_SET (r10, tmp));\n+\n+\t  RTVEC_ELT (v, vi++) = gen_rtx_SET (stack_pointer_rtx, r10);\n+\t}\n+    }\n+\n+  /* Generate frame load insns and restore notes.  */\n+  for (i = 0; i < ncregs; ++i)\n+    {\n+      const xlogue_layout::reginfo &r = xlogue.get_reginfo (i);\n+      enum machine_mode mode = SSE_REGNO_P (r.regno) ? V4SFmode : word_mode;\n+      rtx reg, frame_load;\n+\n+      reg = gen_rtx_REG (mode, r.regno);\n+      frame_load = gen_frame_load (reg, rsi, r.offset);\n+\n+      /* Save RSI frame load insn & note to add last.  */\n+      if (r.regno == SI_REG)\n+\t{\n+\t  gcc_assert (!rsi_frame_load);\n+\t  rsi_frame_load = frame_load;\n+\t  rsi_restore_offset = r.offset;\n+\t}\n+      else\n+\t{\n+\t  RTVEC_ELT (v, vi++) = frame_load;\n+\t  ix86_add_cfa_restore_note (NULL, reg, r.offset);\n+\t}\n+    }\n+\n+  /* Add RSI frame load & restore note at the end.  */\n+  gcc_assert (rsi_frame_load);\n+  gcc_assert (rsi_restore_offset != (HOST_WIDE_INT)-1);\n+  RTVEC_ELT (v, vi++) = rsi_frame_load;\n+  ix86_add_cfa_restore_note (NULL, gen_rtx_REG (DImode, SI_REG),\n+\t\t\t     rsi_restore_offset);\n+\n+  /* Finally, for tail-call w/o a hard frame pointer, set SP to R10.  */\n+  if (!use_call && !frame_pointer_needed)\n+    {\n+      gcc_assert (m->fs.sp_valid);\n+      gcc_assert (!m->fs.sp_realigned);\n+\n+      /* At this point, R10 should point to frame.stack_realign_offset.  */\n+      if (m->fs.cfa_reg == stack_pointer_rtx)\n+\tm->fs.cfa_offset += m->fs.sp_offset - frame.stack_realign_offset;\n+      m->fs.sp_offset = frame.stack_realign_offset;\n+    }\n+\n+  gcc_assert (vi == (unsigned int)GET_NUM_ELEM (v));\n+  tmp = gen_rtx_PARALLEL (VOIDmode, v);\n+  if (use_call)\n+      insn = emit_insn (tmp);\n+  else\n+    {\n+      insn = emit_jump_insn (tmp);\n+      JUMP_LABEL (insn) = ret_rtx;\n+\n+      if (frame_pointer_needed)\n+\tix86_emit_leave (insn);\n+      else\n+\t{\n+\t  /* Need CFA adjust note.  */\n+\t  tmp = gen_rtx_SET (stack_pointer_rtx, r10);\n+\t  add_reg_note (insn, REG_CFA_ADJUST_CFA, tmp);\n+\t}\n+    }\n+\n+  RTX_FRAME_RELATED_P (insn) = true;\n+  ix86_add_queued_cfa_restore_notes (insn);\n+\n+  /* If we're not doing a tail-call, we need to adjust the stack.  */\n+  if (use_call && m->fs.sp_valid)\n+    {\n+      HOST_WIDE_INT dealloc = m->fs.sp_offset - frame.stack_realign_offset;\n+      pro_epilogue_adjust_stack (stack_pointer_rtx, stack_pointer_rtx,\n+\t\t\t\tGEN_INT (dealloc), style,\n+\t\t\t\tm->fs.cfa_reg == stack_pointer_rtx);\n+    }\n+}\n+\n /* Restore function stack, frame, and registers.  */\n \n void\n@@ -14507,13 +15209,15 @@ ix86_expand_epilogue (int style)\n   struct ix86_frame frame;\n   bool restore_regs_via_mov;\n   bool using_drap;\n+  bool restore_stub_is_tail = false;\n \n   ix86_finalize_stack_realign_flags ();\n   ix86_compute_frame_layout (&frame);\n \n-  m->fs.sp_valid = (!frame_pointer_needed\n-\t\t    || (crtl->sp_is_unchanging\n-\t\t\t&& !stack_realign_fp));\n+  m->fs.sp_realigned = stack_realign_fp;\n+  m->fs.sp_valid = stack_realign_fp\n+\t\t   || !frame_pointer_needed\n+\t\t   || crtl->sp_is_unchanging;\n   gcc_assert (!m->fs.sp_valid\n \t      || m->fs.sp_offset == frame.stack_pointer_offset);\n \n@@ -14563,10 +15267,10 @@ ix86_expand_epilogue (int style)\n   /* SEH requires the use of pops to identify the epilogue.  */\n   else if (TARGET_SEH)\n     restore_regs_via_mov = false;\n-  /* If we're only restoring one register and sp is not valid then\n+  /* If we're only restoring one register and sp cannot be used then\n      using a move instruction to restore the register since it's\n      less work than reloading sp and popping the register.  */\n-  else if (!m->fs.sp_valid && frame.nregs <= 1)\n+  else if (!sp_valid_at (frame.hfp_save_offset) && frame.nregs <= 1)\n     restore_regs_via_mov = true;\n   else if (TARGET_EPILOGUE_USING_MOVE\n \t   && cfun->machine->use_fast_prologue_epilogue\n@@ -14591,7 +15295,7 @@ ix86_expand_epilogue (int style)\n \t the stack pointer, if we will restore via sp.  */\n       if (TARGET_64BIT\n \t  && m->fs.sp_offset > 0x7fffffff\n-\t  && !(m->fs.fp_valid || m->fs.drap_valid)\n+\t  && !(fp_valid_at (frame.stack_realign_offset) || m->fs.drap_valid)\n \t  && (frame.nsseregs + frame.nregs) != 0)\n \t{\n \t  pro_epilogue_adjust_stack (stack_pointer_rtx, stack_pointer_rtx,\n@@ -14608,7 +15312,37 @@ ix86_expand_epilogue (int style)\n     ix86_emit_restore_sse_regs_using_mov (frame.sse_reg_save_offset,\n \t\t\t\t\t  style == 2);\n \n-  if (restore_regs_via_mov)\n+  if (m->call_ms2sysv)\n+    {\n+      int pop_incoming_args = crtl->args.pops_args && crtl->args.size;\n+\n+      /* We cannot use a tail-call for the stub if:\n+\t 1. We have to pop incoming args,\n+\t 2. We have additional int regs to restore, or\n+\t 3. A sibling call will be the tail-call, or\n+\t 4. We are emitting an eh_return_internal epilogue.\n+\n+\t TODO: Item 4 has not yet tested!\n+\n+\t If any of the above are true, we will call the stub rather than\n+\t jump to it.  */\n+      restore_stub_is_tail = !(pop_incoming_args || frame.nregs || style != 1);\n+      ix86_emit_outlined_ms2sysv_restore (frame, !restore_stub_is_tail, style);\n+    }\n+\n+  /* If using out-of-line stub that is a tail-call, then...*/\n+  if (m->call_ms2sysv && restore_stub_is_tail)\n+    {\n+      /* TODO: parinoid tests. (remove eventually)  */\n+      gcc_assert (m->fs.sp_valid);\n+      gcc_assert (!m->fs.sp_realigned);\n+      gcc_assert (!m->fs.fp_valid);\n+      gcc_assert (!m->fs.realigned);\n+      gcc_assert (m->fs.sp_offset == UNITS_PER_WORD);\n+      gcc_assert (!crtl->drap_reg);\n+      gcc_assert (!frame.nregs);\n+    }\n+  else if (restore_regs_via_mov)\n     {\n       rtx t;\n \n@@ -14677,6 +15411,7 @@ ix86_expand_epilogue (int style)\n \t    }\n \t  m->fs.sp_offset = UNITS_PER_WORD;\n \t  m->fs.sp_valid = true;\n+\t  m->fs.sp_realigned = false;\n \t}\n     }\n   else\n@@ -14698,10 +15433,11 @@ ix86_expand_epilogue (int style)\n \t}\n \n       /* First step is to deallocate the stack frame so that we can\n-\t pop the registers.  Also do it on SEH target for very large\n-\t frame as the emitted instructions aren't allowed by the ABI in\n-\t epilogues.  */\n-      if (!m->fs.sp_valid\n+\t pop the registers.  If the stack pointer was realigned, it needs\n+\t to be restored now.  Also do it on SEH target for very large\n+\t frame as the emitted instructions aren't allowed by the ABI\n+\t in epilogues.  */\n+      if (!m->fs.sp_valid || m->fs.sp_realigned\n  \t  || (TARGET_SEH\n \t      && (m->fs.sp_offset - frame.reg_save_offset\n \t\t  >= SEH_MAX_FRAME_SIZE)))\n@@ -14729,14 +15465,15 @@ ix86_expand_epilogue (int style)\n     {\n       /* If the stack pointer is valid and pointing at the frame\n \t pointer store address, then we only need a pop.  */\n-      if (m->fs.sp_valid && m->fs.sp_offset == frame.hfp_save_offset)\n+      if (sp_valid_at (frame.hfp_save_offset)\n+\t  && m->fs.sp_offset == frame.hfp_save_offset)\n \tix86_emit_restore_reg_using_pop (hard_frame_pointer_rtx);\n       /* Leave results in shorter dependency chains on CPUs that are\n \t able to grok it fast.  */\n       else if (TARGET_USE_LEAVE\n \t       || optimize_bb_for_size_p (EXIT_BLOCK_PTR_FOR_FN (cfun))\n \t       || !cfun->machine->use_fast_prologue_epilogue)\n-\tix86_emit_leave ();\n+\tix86_emit_leave (NULL);\n       else\n         {\n \t  pro_epilogue_adjust_stack (stack_pointer_rtx,\n@@ -14783,6 +15520,7 @@ ix86_expand_epilogue (int style)\n      be possible to merge the local stack deallocation with the\n      deallocation forced by ix86_static_chain_on_stack.   */\n   gcc_assert (m->fs.sp_valid);\n+  gcc_assert (!m->fs.sp_realigned);\n   gcc_assert (!m->fs.fp_valid);\n   gcc_assert (!m->fs.realigned);\n   if (m->fs.sp_offset != UNITS_PER_WORD)\n@@ -14846,7 +15584,7 @@ ix86_expand_epilogue (int style)\n       else\n \temit_jump_insn (gen_simple_return_pop_internal (popc));\n     }\n-  else\n+  else if (!m->call_ms2sysv || !restore_stub_is_tail)\n     emit_jump_insn (gen_simple_return_internal ());\n \n   /* Restore the state back to the state from the prologue,\n@@ -28570,17 +29308,19 @@ ix86_expand_call (rtx retval, rtx fnaddr, rtx callarg1,\n   else if (TARGET_64BIT_MS_ABI\n \t   && (!callarg2 || INTVAL (callarg2) != -2))\n     {\n-      int const cregs_size\n-\t= ARRAY_SIZE (x86_64_ms_sysv_extra_clobbered_registers);\n-      int i;\n+      unsigned i;\n \n-      for (i = 0; i < cregs_size; i++)\n+      for (i = 0; i < NUM_X86_64_MS_CLOBBERED_REGS; i++)\n \t{\n \t  int regno = x86_64_ms_sysv_extra_clobbered_registers[i];\n \t  machine_mode mode = SSE_REGNO_P (regno) ? TImode : DImode;\n \n \t  clobber_reg (&use, gen_rtx_REG (mode, regno));\n \t}\n+\n+      /* Set here, but it may get cleared later.  */\n+      if (TARGET_CALL_MS2SYSV_XLOGUES)\n+\tcfun->machine->call_ms2sysv = true;\n     }\n \n   if (vec_len > 1)"}, {"sha": "5366f1fc88f5bf6783c0502dc8c5bb54ffa77aa3", "filename": "gcc/config/i386/i386.h", "status": "modified", "additions": 32, "deletions": 1, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6d4d7701a4c40f4c46904292456b76502e1ae63/gcc%2Fconfig%2Fi386%2Fi386.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6d4d7701a4c40f4c46904292456b76502e1ae63/gcc%2Fconfig%2Fi386%2Fi386.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.h?ref=d6d4d7701a4c40f4c46904292456b76502e1ae63", "patch": "@@ -2163,7 +2163,9 @@ extern int const dbx_register_map[FIRST_PSEUDO_REGISTER];\n extern int const dbx64_register_map[FIRST_PSEUDO_REGISTER];\n extern int const svr4_dbx_register_map[FIRST_PSEUDO_REGISTER];\n \n-extern int const x86_64_ms_sysv_extra_clobbered_registers[12];\n+extern unsigned const x86_64_ms_sysv_extra_clobbered_registers[12];\n+#define NUM_X86_64_MS_CLOBBERED_REGS \\\n+  (ARRAY_SIZE (x86_64_ms_sysv_extra_clobbered_registers))\n \n /* Before the prologue, RA is at 0(%esp).  */\n #define INCOMING_RETURN_ADDR_RTX \\\n@@ -2482,6 +2484,17 @@ struct GTY(()) machine_frame_state\n      set, the SP/FP offsets above are relative to the aligned frame\n      and not the CFA.  */\n   BOOL_BITFIELD realigned : 1;\n+\n+  /* Indicates whether the stack pointer has been re-aligned.  When set,\n+     SP/FP continue to be relative to the CFA, but the stack pointer\n+     should only be used for offsets >= sp_realigned_offset, while\n+     the frame pointer should be used for offsets < sp_realigned_offset.\n+     The flags realigned and sp_realigned are mutually exclusive.  */\n+  BOOL_BITFIELD sp_realigned : 1;\n+\n+  /* If sp_realigned is set, this is the offset from the CFA that the\n+     stack pointer was realigned to.  */\n+  HOST_WIDE_INT sp_realigned_offset;\n };\n \n /* Private to winnt.c.  */\n@@ -2565,6 +2578,24 @@ struct GTY(()) machine_function {\n      pass arguments and can be used for indirect sibcall.  */\n   BOOL_BITFIELD arg_reg_available : 1;\n \n+  /* If true, we're out-of-lining reg save/restore for regs clobbered\n+     by ms_abi functions calling a sysv function.  */\n+  BOOL_BITFIELD call_ms2sysv : 1;\n+\n+  /* If true, the incoming 16-byte aligned stack has an offset (of 8) and\n+     needs padding.  */\n+  BOOL_BITFIELD call_ms2sysv_pad_in : 1;\n+\n+  /* If true, the size of the stub save area plus inline int reg saves will\n+     result in an 8 byte offset, so needs padding.  */\n+  BOOL_BITFIELD call_ms2sysv_pad_out : 1;\n+\n+  /* This is the number of extra registers saved by stub (valid range is\n+     0-6). Each additional register is only saved/restored by the stubs\n+     if all successive ones are. (Will always be zero when using a hard\n+     frame pointer.) */\n+  unsigned int call_ms2sysv_extra_regs:3;\n+\n   /* During prologue/epilogue generation, the current frame state.\n      Otherwise, the frame state at the end of the prologue.  */\n   struct machine_frame_state fs;"}, {"sha": "65b228544a5f15f4c2da59b76496116beffbd3f1", "filename": "gcc/config/i386/i386.opt", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6d4d7701a4c40f4c46904292456b76502e1ae63/gcc%2Fconfig%2Fi386%2Fi386.opt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6d4d7701a4c40f4c46904292456b76502e1ae63/gcc%2Fconfig%2Fi386%2Fi386.opt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.opt?ref=d6d4d7701a4c40f4c46904292456b76502e1ae63", "patch": "@@ -538,6 +538,10 @@ Enum(calling_abi) String(sysv) Value(SYSV_ABI)\n EnumValue\n Enum(calling_abi) String(ms) Value(MS_ABI)\n \n+mcall-ms2sysv-xlogues\n+Target Report Mask(CALL_MS2SYSV_XLOGUES) Save\n+Use libgcc stubs to save and restore registers clobbered by 64-bit Microsoft to System V ABI calls.\n+\n mveclibabi=\n Target RejectNegative Joined Var(ix86_veclibabi_type) Enum(ix86_veclibabi) Init(ix86_veclibabi_type_none)\n Vector library ABI to use."}, {"sha": "e7371a41b160f184ef202afcb2c9bcb8982060a2", "filename": "gcc/config/i386/predicates.md", "status": "modified", "additions": 81, "deletions": 0, "changes": 81, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6d4d7701a4c40f4c46904292456b76502e1ae63/gcc%2Fconfig%2Fi386%2Fpredicates.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6d4d7701a4c40f4c46904292456b76502e1ae63/gcc%2Fconfig%2Fi386%2Fpredicates.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fpredicates.md?ref=d6d4d7701a4c40f4c46904292456b76502e1ae63", "patch": "@@ -1657,3 +1657,84 @@\n   (ior (match_operand 0 \"register_operand\")\n        (and (match_code \"const_int\")\n \t    (match_test \"op == constm1_rtx\"))))\n+\n+;; Return true if the vector ends with between 12 and 18 register saves using\n+;; RAX as the base address.\n+(define_predicate \"save_multiple\"\n+  (match_code \"parallel\")\n+{\n+  const unsigned len = XVECLEN (op, 0);\n+  unsigned i;\n+\n+  /* Starting from end of vector, count register saves.  */\n+  for (i = 0; i < len; ++i)\n+    {\n+      rtx src, dest, addr;\n+      rtx e = XVECEXP (op, 0, len - 1 - i);\n+\n+      if (GET_CODE (e) != SET)\n+\tbreak;\n+\n+      src  = SET_SRC (e);\n+      dest = SET_DEST (e);\n+\n+      if (!REG_P (src) || !MEM_P (dest))\n+\tbreak;\n+\n+      addr = XEXP (dest, 0);\n+\n+      /* Good if dest address is in RAX.  */\n+      if (REG_P (addr) && REGNO (addr) == AX_REG)\n+\tcontinue;\n+\n+      /* Good if dest address is offset of RAX.  */\n+      if (GET_CODE (addr) == PLUS\n+\t  && REG_P (XEXP (addr, 0))\n+\t  && REGNO (XEXP (addr, 0)) == AX_REG)\n+\tcontinue;\n+\n+      break;\n+    }\n+  return (i >= 12 && i <= 18);\n+})\n+\n+\n+;; Return true if the vector ends with between 12 and 18 register loads using\n+;; RSI as the base address.\n+(define_predicate \"restore_multiple\"\n+  (match_code \"parallel\")\n+{\n+  const unsigned len = XVECLEN (op, 0);\n+  unsigned i;\n+\n+  /* Starting from end of vector, count register restores.  */\n+  for (i = 0; i < len; ++i)\n+    {\n+      rtx src, dest, addr;\n+      rtx e = XVECEXP (op, 0, len - 1 - i);\n+\n+      if (GET_CODE (e) != SET)\n+\tbreak;\n+\n+      src  = SET_SRC (e);\n+      dest = SET_DEST (e);\n+\n+      if (!MEM_P (src) || !REG_P (dest))\n+\tbreak;\n+\n+      addr = XEXP (src, 0);\n+\n+      /* Good if src address is in RSI.  */\n+      if (REG_P (addr) && REGNO (addr) == SI_REG)\n+\tcontinue;\n+\n+      /* Good if src address is offset of RSI.  */\n+      if (GET_CODE (addr) == PLUS\n+\t  && REG_P (XEXP (addr, 0))\n+\t  && REGNO (XEXP (addr, 0)) == SI_REG)\n+\tcontinue;\n+\n+      break;\n+    }\n+  return (i >= 12 && i <= 18);\n+})"}, {"sha": "ff91c45d4953d6ee5222ae4dbd7297d4ac65b298", "filename": "gcc/config/i386/sse.md", "status": "modified", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6d4d7701a4c40f4c46904292456b76502e1ae63/gcc%2Fconfig%2Fi386%2Fsse.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6d4d7701a4c40f4c46904292456b76502e1ae63/gcc%2Fconfig%2Fi386%2Fsse.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fsse.md?ref=d6d4d7701a4c40f4c46904292456b76502e1ae63", "patch": "@@ -20031,3 +20031,40 @@\n           (match_operand:VI48_512 1 \"nonimmediate_operand\" \"vm\")))]\n   \"TARGET_AVX512VPOPCNTDQ\"\n   \"vpopcnt<ssemodesuffix>\\t{%1, %0<mask_operand2>|%0<mask_operand2>, %1}\")\n+\n+;; Save multiple registers out-of-line.\n+(define_insn \"save_multiple<mode>\"\n+  [(match_parallel 0 \"save_multiple\"\n+    [(use (match_operand:P 1 \"symbol_operand\"))])]\n+  \"TARGET_SSE && TARGET_64BIT\"\n+  \"call\\t%P1\")\n+\n+;; Restore multiple registers out-of-line.\n+(define_insn \"restore_multiple<mode>\"\n+  [(match_parallel 0 \"restore_multiple\"\n+    [(use (match_operand:P 1 \"symbol_operand\"))])]\n+  \"TARGET_SSE && TARGET_64BIT\"\n+  \"call\\t%P1\")\n+\n+;; Restore multiple registers out-of-line and return.\n+(define_insn \"restore_multiple_and_return<mode>\"\n+  [(match_parallel 0 \"restore_multiple\"\n+    [(return)\n+     (use (match_operand:P 1 \"symbol_operand\"))\n+     (set (reg:DI SP_REG) (reg:DI R10_REG))\n+    ])]\n+  \"TARGET_SSE && TARGET_64BIT\"\n+  \"jmp\\t%P1\")\n+\n+;; Restore multiple registers out-of-line when hard frame pointer is used,\n+;; perform the leave operation prior to returning (from the function).\n+(define_insn \"restore_multiple_leave_return<mode>\"\n+  [(match_parallel 0 \"restore_multiple\"\n+    [(return)\n+     (use (match_operand:P 1 \"symbol_operand\"))\n+     (set (reg:DI SP_REG) (plus:DI (reg:DI BP_REG) (const_int 8)))\n+     (set (reg:DI BP_REG) (mem:DI (reg:DI BP_REG)))\n+     (clobber (mem:BLK (scratch)))\n+    ])]\n+  \"TARGET_SSE && TARGET_64BIT\"\n+  \"jmp\\t%P1\")"}, {"sha": "8272c7fddc1ff2aa0bc92b39aae35e753fba74d1", "filename": "gcc/config/i386/winnt.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6d4d7701a4c40f4c46904292456b76502e1ae63/gcc%2Fconfig%2Fi386%2Fwinnt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6d4d7701a4c40f4c46904292456b76502e1ae63/gcc%2Fconfig%2Fi386%2Fwinnt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fwinnt.c?ref=d6d4d7701a4c40f4c46904292456b76502e1ae63", "patch": "@@ -1128,7 +1128,8 @@ i386_pe_seh_unwind_emit (FILE *asm_out_file, rtx_insn *insn)\n \n \tcase REG_CFA_DEF_CFA:\n \tcase REG_CFA_EXPRESSION:\n-\t  /* Only emitted with DRAP, which we disable.  */\n+\t  /* Only emitted with DRAP and aligned memory access using a\n+\t     realigned SP, both of which we disable.  */\n \t  gcc_unreachable ();\n \t  break;\n "}, {"sha": "715830a1a438c15b2fb45ac2fe8db7a3022f6f04", "filename": "gcc/doc/invoke.texi", "status": "modified", "additions": 12, "deletions": 1, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6d4d7701a4c40f4c46904292456b76502e1ae63/gcc%2Fdoc%2Finvoke.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6d4d7701a4c40f4c46904292456b76502e1ae63/gcc%2Fdoc%2Finvoke.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Finvoke.texi?ref=d6d4d7701a4c40f4c46904292456b76502e1ae63", "patch": "@@ -1212,7 +1212,7 @@ See RS/6000 and PowerPC Options.\n -msse2avx  -mfentry  -mrecord-mcount  -mnop-mcount  -m8bit-idiv @gol\n -mavx256-split-unaligned-load  -mavx256-split-unaligned-store @gol\n -malign-data=@var{type}  -mstack-protector-guard=@var{guard} @gol\n--mmitigate-rop  -mgeneral-regs-only}\n+-mmitigate-rop  -mgeneral-regs-only  -mcall-ms2sysv-xlogues}\n \n @emph{x86 Windows Options}\n @gccoptlist{-mconsole  -mcygwin  -mno-cygwin  -mdll @gol\n@@ -25307,6 +25307,17 @@ You can control this behavior for specific functions by\n using the function attributes @code{ms_abi} and @code{sysv_abi}.\n @xref{Function Attributes}.\n \n+@item -mcall-ms2sysv-xlogues\n+@opindex mcall-ms2sysv-xlogues\n+@opindex mno-call-ms2sysv-xlogues\n+Due to differences in 64-bit ABIs, any Microsoft ABI function that calls a\n+System V ABI function must consider RSI, RDI and XMM6-15 as clobbered.  By\n+default, the code for saving and restoring these registers is emitted inline,\n+resulting in fairly lengthy prologues and epilogues.  Using\n+@option{-mcall-ms2sysv-xlogues} emits prologues and epilogues that\n+use stubs in the static portion of libgcc to perform these saves and restores,\n+thus reducing function size at the cost of a few extra instructions.\n+\n @item -mtls-dialect=@var{type}\n @opindex mtls-dialect\n Generate code to access thread-local storage using the @samp{gnu} or"}, {"sha": "889ffe434384f9dbbfa5b96e703c748290b34bf2", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6d4d7701a4c40f4c46904292456b76502e1ae63/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6d4d7701a4c40f4c46904292456b76502e1ae63/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=d6d4d7701a4c40f4c46904292456b76502e1ae63", "patch": "@@ -1,3 +1,10 @@\n+2017-05-14  Daniel Santos  <daniel.santos@pobox.com>\n+\n+\t* gcc.target/x86_64/abi/ms-sysv/do-test.S: New file.\n+\t* gcc.target/x86_64/abi/ms-sysv/gen.cc: Likewise.\n+\t* gcc.target/x86_64/abi/ms-sysv/ms-sysv.c: Likewise.\n+\t* gcc.target/x86_64/abi/ms-sysv/ms-sysv.exp: Likewise.\n+\n 2017-05-14  Julia Koval  <julia.koval@intel.com>\n \n \t* gcc.target/i386/xgetsetbv.c: New test."}, {"sha": "1395235fd1e8bba4be2972d695c8cccd53d571e2", "filename": "gcc/testsuite/gcc.target/x86_64/abi/ms-sysv/do-test.S", "status": "added", "additions": 163, "deletions": 0, "changes": 163, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6d4d7701a4c40f4c46904292456b76502e1ae63/gcc%2Ftestsuite%2Fgcc.target%2Fx86_64%2Fabi%2Fms-sysv%2Fdo-test.S", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6d4d7701a4c40f4c46904292456b76502e1ae63/gcc%2Ftestsuite%2Fgcc.target%2Fx86_64%2Fabi%2Fms-sysv%2Fdo-test.S", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fx86_64%2Fabi%2Fms-sysv%2Fdo-test.S?ref=d6d4d7701a4c40f4c46904292456b76502e1ae63", "patch": "@@ -0,0 +1,163 @@\n+/* Assembly proxy functions for ms_abi tests.\n+   Copyright (C) 2016-2017 Free Software Foundation, Inc.\n+   Contributed by Daniel Santos <daniel.santos@pobox.com>\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 3, or (at your option)\n+any later version.\n+\n+GCC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+Under Section 7 of GPL version 3, you are granted additional\n+permissions described in the GCC Runtime Library Exception, version\n+3.1, as published by the Free Software Foundation.\n+\n+You should have received a copy of the GNU General Public License and\n+a copy of the GCC Runtime Library Exception along with this program;\n+see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#ifdef __x86_64__\n+\n+# ifdef __ELF__\n+#  define ELFFN_BEGIN(fn)       .type fn,@function\n+#  define ELFFN_END(fn)         .size fn,.-fn\n+# else\n+#  define ELFFN_BEGIN(fn)\n+#  define ELFFN_END(fn)\n+# endif\n+\n+# define FUNC(fn)\t\t\\\n+\t.global fn;\t\t\\\n+\tELFFN_BEGIN(fn);\t\\\n+fn:\n+\n+#define FUNC_END(fn) ELFFN_END(fn)\n+\n+# ifdef __AVX__\n+#  define MOVAPS vmovaps\n+# else\n+#  define MOVAPS movaps\n+# endif\n+\n+/* TODO: Is there a cleaner way to provide these offsets?  */\n+\t.struct 0\n+test_data_save:\n+\n+\t.struct test_data_save + 224\n+test_data_input:\n+\n+\t.struct test_data_save + 448\n+test_data_output:\n+\n+\t.struct test_data_save + 672\n+test_data_fn:\n+\n+\t.struct test_data_save + 680\n+test_data_retaddr:\n+\n+\t.text\n+\n+regs_to_mem:\n+\tMOVAPS\t%xmm6, (%rax)\n+\tMOVAPS\t%xmm7, 0x10(%rax)\n+\tMOVAPS\t%xmm8, 0x20(%rax)\n+\tMOVAPS\t%xmm9, 0x30(%rax)\n+\tMOVAPS\t%xmm10, 0x40(%rax)\n+\tMOVAPS\t%xmm11, 0x50(%rax)\n+\tMOVAPS\t%xmm12, 0x60(%rax)\n+\tMOVAPS\t%xmm13, 0x70(%rax)\n+\tMOVAPS\t%xmm14, 0x80(%rax)\n+\tMOVAPS\t%xmm15, 0x90(%rax)\n+\tmov\t%rsi, 0xa0(%rax)\n+\tmov\t%rdi, 0xa8(%rax)\n+\tmov\t%rbx, 0xb0(%rax)\n+\tmov\t%rbp, 0xb8(%rax)\n+\tmov\t%r12, 0xc0(%rax)\n+\tmov\t%r13, 0xc8(%rax)\n+\tmov\t%r14, 0xd0(%rax)\n+\tmov\t%r15, 0xd8(%rax)\n+\tretq\n+\n+mem_to_regs:\n+\tMOVAPS\t(%rax), %xmm6\n+\tMOVAPS\t0x10(%rax),%xmm7\n+\tMOVAPS\t0x20(%rax),%xmm8\n+\tMOVAPS\t0x30(%rax),%xmm9\n+\tMOVAPS\t0x40(%rax),%xmm10\n+\tMOVAPS\t0x50(%rax),%xmm11\n+\tMOVAPS\t0x60(%rax),%xmm12\n+\tMOVAPS\t0x70(%rax),%xmm13\n+\tMOVAPS\t0x80(%rax),%xmm14\n+\tMOVAPS\t0x90(%rax),%xmm15\n+\tmov\t0xa0(%rax),%rsi\n+\tmov\t0xa8(%rax),%rdi\n+\tmov\t0xb0(%rax),%rbx\n+\tmov\t0xb8(%rax),%rbp\n+\tmov\t0xc0(%rax),%r12\n+\tmov\t0xc8(%rax),%r13\n+\tmov\t0xd0(%rax),%r14\n+\tmov\t0xd8(%rax),%r15\n+\tretq\n+\n+# NOTE: Not MT safe\n+FUNC(do_test_unaligned)\n+\t.cfi_startproc\n+\t# The below alignment checks are to verify correctness of the test\n+\t# its self.\n+\n+\t# Verify that incoming stack is aligned + 8\n+\tpushf\n+\ttest\t$0x8, %rsp\n+\tjne\tL0\n+\tint\t$3\t\t# Stack not unaligned\n+\n+FUNC(do_test_aligned)\n+\t# Verify that incoming stack is aligned\n+\tpushf\n+\ttest\t$0xf, %rsp\n+\tje\tL0\n+\tint\t$3\t\t# Stack not aligned\n+L0:\n+\tpopf\n+\n+\t# Save registers\n+\tlea\ttest_data(%rip), %rax\n+\tcall\tregs_to_mem\n+\n+\t# Load register with random data\n+\tlea\ttest_data + test_data_input(%rip), %rax\n+\tcall\tmem_to_regs\n+\n+\t# Save original return address\n+\tpop\t%rax\n+\tmovq    %rax, test_data + test_data_retaddr(%rip)\n+\n+\t# Call the test function\n+\tcall\t*test_data + test_data_fn(%rip)\n+\n+\t# Restore the original return address\n+\tmovq    test_data + test_data_retaddr(%rip), %rcx\n+\tpush\t%rcx\n+\n+\t# Save test function return value and store resulting register values\n+\tpush\t%rax\n+\tlea\ttest_data + test_data_output(%rip), %rax\n+\tcall\tregs_to_mem\n+\n+\t# Restore registers\n+\tlea\ttest_data(%rip), %rax\n+\tcall\tmem_to_regs\n+\tpop\t%rax\n+\tretq\n+        .cfi_endproc\n+FUNC_END(do_test_aligned)\n+FUNC_END(do_test_unaligned)\n+\n+#endif /* __x86_64__ */"}, {"sha": "947a12bf2aefba0591444e0c0d0b13abd4528517", "filename": "gcc/testsuite/gcc.target/x86_64/abi/ms-sysv/gen.cc", "status": "added", "additions": 807, "deletions": 0, "changes": 807, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6d4d7701a4c40f4c46904292456b76502e1ae63/gcc%2Ftestsuite%2Fgcc.target%2Fx86_64%2Fabi%2Fms-sysv%2Fgen.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6d4d7701a4c40f4c46904292456b76502e1ae63/gcc%2Ftestsuite%2Fgcc.target%2Fx86_64%2Fabi%2Fms-sysv%2Fgen.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fx86_64%2Fabi%2Fms-sysv%2Fgen.cc?ref=d6d4d7701a4c40f4c46904292456b76502e1ae63", "patch": "@@ -0,0 +1,807 @@\n+/* Test program generator for 64-bit Microsoft ABI.\n+   Copyright (C) 2016-2017 Free Software Foundation, Inc.\n+   Contributed by Daniel Santos <daniel.santos@pobox.com>\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 3, or (at your option)\n+any later version.\n+\n+GCC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+Under Section 7 of GPL version 3, you are granted additional\n+permissions described in the GCC Runtime Library Exception, version\n+3.1, as published by the Free Software Foundation.\n+\n+You should have received a copy of the GNU General Public License and\n+a copy of the GCC Runtime Library Exception along with this program;\n+see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#include <cstdio>\n+#include <cassert>\n+#include <vector>\n+#include <string>\n+#include <cstring>\n+#include <iostream>\n+#include <algorithm>\n+#include <ios>\n+#include <iomanip>\n+#include <sstream>\n+#include <fstream>\n+#include <memory>\n+#include <regex>\n+#include <stdexcept>\n+\n+#include <unistd.h>\n+#include <getopt.h>\n+\n+using namespace std;\n+\n+/* A basic Effective C++ Item 6. */\n+class uncopyable\n+{\n+private:\n+  uncopyable (const uncopyable &) = delete;\n+  const uncopyable& operator= (const uncopyable &) = delete;\n+\n+protected:\n+  uncopyable() {}\n+  ~uncopyable() {}\n+};\n+\n+/* A simple class for adding text delimiters.  */\n+class list_delimiter : protected uncopyable\n+{\n+  int m_pos;\n+  string m_delim;\n+  static string s_empty;\n+\n+  list_delimiter ();\n+\n+public:\n+  list_delimiter (const char *delim, int init_pos = 0)\n+      : m_pos (init_pos), m_delim(delim) {}\n+  const string &get ()\t{return m_pos++ ? m_delim : s_empty;}\n+  void reset () \t{m_pos = 0;}\n+  int get_pos ()\t{return m_pos;}\n+};\n+\n+string list_delimiter::s_empty = \"\";\n+\n+/* Bitmasks for representing non-volatile retisters of an ms_abi call that\n+   are not already clobbered by a sysv_abi call.  */\n+enum optional_regs\n+{\n+  OPTIONAL_REG_RBX = 0x01,\n+  OPTIONAL_REG_RBP = 0x02,\n+  OPTIONAL_REG_R12 = 0x04,\n+  OPTIONAL_REG_R13 = 0x08,\n+  OPTIONAL_REG_R14 = 0x10,\n+  OPTIONAL_REG_R15 = 0x20,\n+\n+  OPTIONAL_REG_ALL = 0x3f,\n+  OPTIONAL_REG_HFP_ALL = OPTIONAL_REG_ALL & (~OPTIONAL_REG_RBP)\n+};\n+\n+static const char * const optional_regs_str[] = {\n+  \"rbx\",\n+  \"rbp\",\n+  \"r12\",\n+  \"r13\",\n+  \"r14\",\n+  \"r15\",\n+};\n+\n+/* A simple type & name representation of a function parameter.  */\n+class arg\n+{\n+  string name;\n+  string type;\n+  bool type_is_integral:1;\n+\n+public:\n+  arg(const char *name, const char *type, bool type_is_integral);\n+\n+  bool is_type_integral () const\t{return type_is_integral;}\n+  const string &get_name () const\t{return name;}\n+  const string &get_type () const\t{return type;}\n+};\n+\n+arg::arg(const char *name, const char *type, bool type_is_integral)\n+    : name (name), type (type), type_is_integral (type_is_integral)\n+{\n+}\n+\n+/* A stupid operator<< implementation for arg objects.  */\n+template<class T> T &operator<< (T &out, const arg &a)\n+{\n+  return out << a.get_type () << \" \" << a.get_name ();\n+}\n+\n+/* Bitmask representation of all possible varients of a test function. The\n+   value FN_VAR_MSABI is only used internally to distinguish between an\n+   ms_abi and sysv_abi function.  */\n+enum fn_variants {\n+  FN_VAR_MSABI\t\t= 0x01,\n+  FN_VAR_HFP\t\t= 0x02,\n+  FN_VAR_REALIGN\t= 0x04,\n+  FN_VAR_ALLOCA\t\t= 0x08,\n+  FN_VAR_VARARGS\t= 0x10,\n+  FN_VAR_SIBCALL\t= 0x20,\n+  FN_VAR_SHRINK_WRAP\t= 0x40,\n+\n+  FN_VAR_HFP_OR_REALIGN\t= FN_VAR_HFP | FN_VAR_REALIGN,\n+  FN_VAR_MASK\t\t= 0x7f,\n+  FN_VAR_COUNT\t\t= 7\n+};\n+\n+/* Representation of a Microsoft or System V ABI function with varying\n+   parameters, quirks and optimization goals.\n+\n+   Function name nomenclature:\n+     (msabi|sysv)_[xx_][r|f][a][v][s][w]<n>\n+      |            |    |    |  |  |  |  |\n+      |            |    |    |  |  |  |  Number of extra (long) parameters\n+      |            |    |    |  |  |  shrink wrap\n+      |            |    |    |  |  sibling call\n+      |            |    |    |  varargs\n+      |            |    |    alloca\n+      |            |    Forced realignment or hard frame pointer\n+      |            Explicit clobbers (hexidecimal mask, ms_abi only)\n+      Calling Convention  */\n+class fn : protected uncopyable\n+{\n+private:\n+  const vector<arg> &m_args;\n+  string m_name;\n+  string m_attr_decl_str;\n+  string m_attr_def_str;\n+  int m_clobbers:FN_VAR_COUNT;\n+  int m_var;\n+\n+public:\n+  fn (const vector<arg> &args, int clobbers, int var);\n+\n+  void print_params (ostream &out) const;\n+  void print_decl (ostream &out, bool for_def = false) const;\n+  void print_noinfo_def (ostream &out) const;\n+  void print_def (ostream &out) const;\n+  const string &get_name () const\t{return m_name;}\n+  const vector<arg> &get_args () const\t{return m_args;}\n+\n+  bool get_hfp_or_realign () const\t{return m_var & FN_VAR_HFP_OR_REALIGN;}\n+  bool get_msabi () const\t\t{return m_var & FN_VAR_MSABI;}\n+  bool get_hfp () const\t\t\t{return m_var & FN_VAR_HFP;}\n+  bool get_realign () const\t\t{return m_var & FN_VAR_REALIGN;}\n+  bool get_alloca () const\t\t{return m_var & FN_VAR_ALLOCA;}\n+  bool get_varargs () const\t\t{return m_var & FN_VAR_VARARGS;}\n+  bool get_sibcall () const\t\t{return m_var & FN_VAR_SIBCALL;}\n+  bool get_shrink_wrap () const\t\t{return m_var & FN_VAR_SHRINK_WRAP;}\n+};\n+\n+fn::fn (const vector<arg> &args, int clobbers, int var)\n+    : m_args (args)\n+    , m_name ()\n+    , m_attr_decl_str ()\n+    , m_attr_def_str (\"noinline\")\n+    , m_clobbers (clobbers)\n+    , m_var (var)\n+{\n+  assert (!(var & ~FN_VAR_MASK));\n+\n+  if (get_hfp () && get_realign ())\n+    throw invalid_argument (\"`hfp' with `realign' does nothing.\");\n+\n+  if (get_varargs () && args.empty ())\n+    throw invalid_argument (\"Need at least one normal argument to use varargs\");\n+\n+  assert (!(get_hfp () || get_realign ()) || !(clobbers & OPTIONAL_REG_RBP));\n+\n+  stringstream name;\n+  name << (get_msabi () ? \"msabi_\" : \"sysv_\");\n+  if (get_msabi ())\n+    name << setfill('0') << setw(2) << hex << m_clobbers << \"_\";\n+  name << (get_realign () ? \"r\" : (get_hfp () ? \"f\" : \"\"))\n+       << (get_alloca () ? \"a\" : \"\")\n+       << (get_varargs () ? \"v\" : \"\")\n+       << (get_sibcall () ? \"s\" : \"\")\n+       << (get_shrink_wrap () ? \"w\" : \"\")\n+       << setw(0) << dec << (unsigned)args.size();\n+  m_name = name.str();\n+\n+  list_delimiter decl_comma (\", \", !m_attr_decl_str.empty ());\n+  list_delimiter def_comma (\", \", !m_attr_def_str.empty ());\n+  if (get_msabi ())\n+    {\n+\tm_attr_decl_str += decl_comma.get ();\n+\tm_attr_decl_str += \"ms_abi\";\n+\tm_attr_def_str += def_comma.get ();\n+\tm_attr_def_str += \"ms_abi\";\n+    }\n+\n+  if (get_realign ())\n+    {\n+      m_attr_def_str += def_comma.get();\n+      m_attr_def_str += \"__force_align_arg_pointer__\";\n+    }\n+  else if (get_hfp ())\n+    {\n+      m_attr_def_str += def_comma.get();\n+      m_attr_def_str += \"optimize (\\\"no-omit-frame-pointer\\\")\";\n+    }\n+}\n+\n+/* Print the parameters for a function declaration.  */\n+void fn::print_params (ostream &out) const\n+{\n+  list_delimiter comma (\", \");\n+\n+  vector<arg>::const_iterator i;\n+  if (get_alloca () && !get_msabi ())\n+    out << comma.get () << \"void *alloca_mem\";\n+  for (i = m_args.begin(); i != m_args.end(); ++i)\n+    out << comma.get () << *i;\n+\n+  if (get_varargs ())\n+    out << comma.get () << (get_msabi () ? \"...\" : \"va_list argptr\");\n+}\n+\n+/* Print the declaration for a function.  */\n+void fn::print_decl (ostream &out, bool for_def) const\n+{\n+  const string &attr_str = (for_def ? m_attr_def_str : m_attr_decl_str);\n+  if (!for_def)\n+    out << \"extern \";\n+\n+  if (!attr_str.empty ())\n+    out << \"__attribute__ ((\" << attr_str << \")) \";\n+\n+  out << \"long \" << m_name << \" (\";\n+  print_params (out);\n+  out << \")\";\n+  if (!for_def)\n+    out << \";\" << endl;\n+}\n+\n+/* Output a volatile \"_noinfo\" function pointer definition.  */\n+void fn::print_noinfo_def (ostream &out) const\n+{\n+  out << \"static \";\n+  if (!m_attr_decl_str.empty ())\n+    out << \"__attribute__ ((\" << m_attr_decl_str << \")) \";\n+  out << \"long (*const volatile \" << m_name << \"_noinfo) (\";\n+  print_params (out);\n+  out << \") = \" << m_name << \";\" << endl;\n+}\n+\n+/* Print the definition of a function.  */\n+void fn::print_def (ostream &out) const\n+{\n+  vector<arg>::const_iterator i;\n+\n+  print_decl (out, true);\n+  out << endl << \"{\" << endl;\n+\n+  if (get_msabi () && get_alloca ())\n+    {\n+      const char *size_str = m_args.empty () ? \"42\" : \"a\";\n+      out << \"  void *alloca_mem = alloca (8 + \" << size_str << \");\" << endl\n+\t  << \"  *(long*)alloca_mem = FLAG_ALLOCA;\" << endl;\n+    }\n+  if (get_msabi () && get_varargs ())\n+    out << \"  va_list argptr;\" << endl;\n+  if (get_shrink_wrap ())\n+    out << \"  if (shrink_wrap_global == FLAG_SHRINK_WRAP_FAST_PATH)\" << endl\n+\t<< \"    return FLAG_SHRINK_WRAP_FAST_PATH;\" << endl;\n+\n+  list_delimiter comma (\", \");\n+  if (m_clobbers)\n+    {\n+      out << \"  __asm__ __volatile__ (\\\"\\\" :::\";\n+      unsigned c;\n+      unsigned mask = m_clobbers;\n+      comma.reset ();\n+      for (c = 0, mask = m_clobbers; mask; ++c, mask >>= 1)\n+\tif (mask & 1)\n+\t  out << comma.get () << \"\\\"\" << optional_regs_str[c] << \"\\\"\";\n+      out << \");\" << endl;\n+    }\n+\n+  if (get_msabi () && get_varargs ())\n+    {\n+      assert (!m_args.empty ());\n+      out << \"  va_start(argptr, \" << m_args.back ().get_name () << \");\" << endl;\n+    }\n+\n+  out << \"  return \";\n+  if (get_msabi ())\n+    {\n+      if (get_sibcall ())\n+\tout << \"do_sibcall_noinfo (\";\n+\n+      comma.reset ();\n+      out << \"sysv_\"\n+\t  << (get_alloca () ? \"a\" : \"\")\n+\t  << (get_varargs () ? \"v\" : \"\")\n+\t  << m_args.size ()\n+\t  << \"_noinfo (\";\n+\n+      if (get_alloca ())\n+\tout << comma.get () << \"alloca_mem\";\n+      for (i = m_args.begin(); i != m_args.end(); ++i)\n+\tout << comma.get () << i->get_name ();\n+      if (get_varargs ())\n+\tout << comma.get () << \"argptr\";\n+      out << \")\";\n+      if (get_shrink_wrap ())\n+\tout << \" + FLAG_SHRINK_WRAP_SLOW_PATH\";\n+      if (get_sibcall ())\n+\tout << \")\";\n+    }\n+  else\n+    {\n+      list_delimiter plus (\" + \");\n+      for (i = m_args.begin(); i != m_args.end(); ++i)\n+\t  if (i->is_type_integral ())\n+\t    out << plus.get () << i->get_name ();\n+      if (get_alloca ())\n+\tout << plus.get () << \"*(long*)alloca_mem\";\n+      if (!plus.get_pos ())\n+\tout << \"0\";\n+    }\n+  out << \";\" << endl;\n+  if (get_msabi () && get_varargs ())\n+    out << \"  va_end(argptr);\" << endl;\n+  out << \"}\" << endl << endl;\n+}\n+\n+/* Global variables.  */\n+string argv0;\n+string out_file_name;\n+unsigned int extra_params_min = 0;\n+unsigned int extra_params_max = 5;\n+unsigned fn_variant_mask = FN_VAR_MASK;\n+bool omit_rbp_clobbers = false;\n+vector<class fn*> sysv_funcs;\n+vector<class fn*> msabi_funcs;\n+\n+\n+/* Emit extern for do_test_aligned and do_test_unaligned (defined in do_test.S)\n+   followed by all of the various do_test* function function pointers that\n+   are just aliases of them.  */\n+static void make_do_tests_decl (const vector<class arg> &args, ostream &out)\n+{\n+  vector<class arg>::const_iterator ai;\n+  unsigned i, varargs, unaligned;\n+\n+  out << \"extern __attribute__ ((ms_abi)) long do_test_aligned ();\" << endl\n+      << \"extern __attribute__ ((ms_abi)) long do_test_unaligned ();\" << endl;\n+\n+  list_delimiter comma (\", \");\n+  for (i = extra_params_min; i <= args.size (); ++i)\n+    for (unaligned = 0; unaligned <= 1; ++unaligned)\n+      for (varargs = 0; varargs <= 1; ++varargs)\n+\t{\n+\t  if (!i && varargs)  /* skip varargs version when no other args */\n+\t    continue;\n+\n+\t  comma.reset ();\n+\t  out << \"static __attribute__ ((ms_abi)) long (*const do_test_\"\n+\t      << (unaligned ? \"u\" : \"\")\n+\t      << (varargs ? \"v\" : \"\") << i << \") (\";\n+\n+\t  unsigned j;\n+\t  for (j = 0, ai = args.begin (); j < i; ++j, ++ai)\n+\t    out << comma.get () << ai->get_type () << \" \"\n+\t\t<< ai->get_name ();\n+\t  if (varargs)\n+\t    out << comma.get () << \"...\";\n+\t  out << \") = (void*)do_test_\" << (unaligned ? \"un\" : \"\")\n+\t      << \"aligned;\" << endl;\n+\t}\n+}\n+\n+/* Generate do_tests function.  We actually break it up into multiple\n+   do_test_xxxx functions to keep compile times down (with just one large\n+   function, it is a very slow build).  */\n+void make_do_test (const vector<class arg> &args,\n+\t\t   const vector<class fn*> &msabi_funcs,\n+\t\t   ostream &out)\n+{\n+  const unsigned TESTS_PER_FN_MAX = 64;\n+  unsigned i;\n+  vector<string> do_tests_fn_names;\n+  unsigned fn_count = 0;\n+  unsigned test_count = TESTS_PER_FN_MAX;\n+  string params_str;\n+  string param_names_str;\n+  string param_types_str;\n+\n+  /* Init some commonly used strings.  */\n+  {\n+    stringstream s1, s2, s3;\n+    list_delimiter comma(\", \");\n+    for (auto arg : args)\n+      {\n+\tconst string &c = comma.get ();\n+\ts1 << c << arg;\n+\ts2 << c << arg.get_name ();\n+\ts3 << c << arg.get_type ();\n+      }\n+    params_str = s1.str ();\n+    param_names_str = s2.str ();\n+    param_types_str = s3.str ();\n+  }\n+\n+  vector<class fn*>::const_iterator fi;\n+  for (fi = msabi_funcs.begin(); fi != msabi_funcs.end(); ++fi)\n+    {\n+      const fn &f = **fi;\n+      unsigned unaligned, shrink_wrap;\n+\n+      for (unaligned = 0; unaligned <= !!f.get_realign (); ++unaligned)\n+\tfor (shrink_wrap = 0; shrink_wrap <= !!f.get_shrink_wrap ();\n+\t     ++shrink_wrap)\n+\t  {\n+\t    const vector<class arg> &fargs = f.get_args ();\n+\n+\t    /* To prevent unwieldy build times, we split up tests to 64-ish per\n+\t       function.  */\n+\t    if (++test_count > TESTS_PER_FN_MAX)\n+\t      {\n+\t\ttest_count = 1;\n+\t\tif (fn_count > 0) {\n+\t\t  out << \"}\" << endl << endl;\n+\t\t}\n+\n+\t\tstringstream fn_name;\n+\t\tfn_name << \"do_tests_\" << setfill('0') << setw(4) << hex\n+\t\t     << fn_count++;\n+\t\tdo_tests_fn_names.push_back (fn_name.str ());\n+\n+\t\tout << \"static __attribute__((noinline)) void \"\n+\t\t    << fn_name.str () << \" (\" << params_str << \")\" << endl\n+\t\t    << \"{\" << endl\n+\t\t    << \"  long ret;\" << endl;\n+\t      }\n+\n+\t    /* Call init_test.  */\n+\t    out << endl\n+\t\t<< \"  init_test (\" << f.get_name () << \", \\\"\"\n+\t\t<< f.get_name () << \"\\\", \";\n+\n+\t    if (f.get_realign ())\n+\t      out << (unaligned ? \"ALIGNMENT_MISALIGNED\"\n+\t\t\t\t: \"ALIGNMENT_ALIGNED\");\n+\t    else\n+\t      out << \"ALIGNMENT_NOT_TESTED\";\n+\n+\t    out << \", \";\n+\t    if (f.get_shrink_wrap ())\n+\t      out << (shrink_wrap ? \"SHRINK_WRAP_SLOW_PATH\"\n+\t\t\t\t  : \"SHRINK_WRAP_FAST_PATH\");\n+\t    else\n+\t      out << \"SHRINK_WRAP_NONE\";\n+\t    out << \", \";\n+\n+\t    /* Calculated the expected return value.  */\n+\t    if (f.get_shrink_wrap () && shrink_wrap == 0)\n+\t      out << \"FLAG_SHRINK_WRAP_FAST_PATH\";\n+\t    else\n+\t      {\n+\t\tlist_delimiter plus (\" + \");\n+\t\tfor (auto const &arg : fargs)\n+\t\t  out << plus.get () << arg.get_name ();\n+\t\tif (f.get_sibcall ())\n+\t\t  out << plus.get () << \"FLAG_SIBCALL\";\n+\t\tif (f.get_alloca ())\n+\t\t  out << plus.get () << \"FLAG_ALLOCA\";\n+\t\tif (f.get_shrink_wrap () && shrink_wrap == 1)\n+\t\t  out << plus.get () << \"FLAG_SHRINK_WRAP_SLOW_PATH\";\n+\t\tif (!plus.get_pos ())\n+\t\t  out << \"0\";\n+\t      }\n+\t    out << \");\" << endl;\n+\t    /* End if init_test call.  */\n+\n+\t    if (f.get_realign () && unaligned == 1)\n+\t      out << \"  __asm__ __volatile__ (\\\"subq $8,%%rsp\\\":::\\\"cc\\\");\"\n+\t\t  << endl;\n+\n+\t    out << \"  ret = do_test_\"\n+\t\t<< (f.get_realign () && unaligned == 1 ? \"u\" : \"\")\n+\t\t<< (f.get_varargs () ? \"v\" : \"\")\n+\t\t<< fargs.size () << \" (\";\n+\n+\t    list_delimiter comma (\", \");\n+\t    for (auto const &arg : fargs)\n+\t      out << comma.get () << arg.get_name ();\n+\t    out << \");\" << endl;\n+\n+\t    if (f.get_realign () && unaligned == 1)\n+\t      out << \"  __asm__ __volatile__ (\\\"addq $8,%%rsp\\\":::\\\"cc\\\");\"\n+\t\t  << endl;\n+\n+\t    out << \"  check_results (ret);\" << endl;\n+\t  }\n+    }\n+\n+  /* Close the last function and define the main do_tests function.  */\n+  out << \"}\" << endl << endl;\n+\n+  /* Define _noinfo pointers to each do_tests_* function.  */\n+  for (auto const &fn_name : do_tests_fn_names)\n+    out << \"  static void (*volatile \" << fn_name << \"_noinfo) (\"\n+\t<< param_types_str << \") = \" << fn_name << \";\" << endl;\n+\n+  /* Define main do_tests () function.  */\n+  out << endl\n+      << \"void do_tests ()\" << endl\n+      << \"{\" << endl;\n+  i = 1;\n+  for (auto const &arg : args)\n+    {\n+      out << \"  \" << arg.get_type () << \" \" << arg.get_name () << \" = \" << i\n+\t  << \";\" << endl;\n+      i <<= 1;\n+    }\n+  out << endl;\n+\n+  /* Call do_tests_*_noinfo functions.  */\n+  for (auto const &fn_name : do_tests_fn_names)\n+    out << \"  \" << fn_name << \"_noinfo (\" << param_names_str << \");\" << endl;\n+  out << \"}\" << endl << endl;\n+}\n+\n+/* Generate output file.  */\n+void generate_header (const string &args)\n+{\n+  vector<class arg> all_args;\n+  vector<vector<class arg> > arg_sets;\n+\n+  ofstream out;\n+  out.exceptions (ios::failbit | ios::badbit);\n+  out.open (out_file_name);\n+  out << \"/* Generated with \" << args << \" */\" << endl << endl;\n+\n+  assert (extra_params_max < 26);\n+\n+  /* Build the extra argument array.  */\n+  for (unsigned int i = 0; i < extra_params_max; ++i)\n+    {\n+      char name[2] = \"a\";\n+      name[0] += i;\n+      class arg myarg (name, \"long\", true);\n+\n+      all_args.push_back (myarg);\n+    }\n+\n+  arg_sets.resize (extra_params_max - extra_params_min + 1);\n+  for (unsigned int i = 0; i < arg_sets.size (); ++i)\n+      arg_sets[i].insert (arg_sets[i].end(), all_args.begin(),\n+\t\t\t  all_args.begin () + i + extra_params_min);\n+\n+  /* Print sysv functions */\n+  for (const vector<class arg> &as : arg_sets)\n+    {\n+      const int alloca_max = !!(fn_variant_mask & FN_VAR_MSABI);\n+      const int varargs_max = !!(fn_variant_mask & FN_VAR_VARARGS);\n+      fn *fn;\n+      for (int _alloca = 0; _alloca <= alloca_max; ++_alloca)\n+\tfor (int varargs = 0; varargs <= varargs_max; ++varargs)\n+\t{\n+\t  try {\n+\t    int var = (_alloca ? FN_VAR_ALLOCA : 0)\n+\t\t    | (varargs ? FN_VAR_VARARGS : 0);\n+\t    fn = new ::fn (as, 0, var);\n+\t  } catch (invalid_argument) {\n+\t    continue;\n+\t  }\n+\t  sysv_funcs.push_back (fn);\n+\t  fn->print_def (out);\n+\t}\n+    }\n+\n+  /* Print _noinfo function pointers for sysv functions.  */\n+  for (const fn *f : sysv_funcs)\n+    f->print_noinfo_def (out);\n+\n+  /* Print ms_abi functions.  */\n+  unsigned int var;\n+  for (var = 0; var <= FN_VAR_MASK; ++var)\n+    {\n+      /* We only want ms_abi fns for this.  */\n+      if (! (var & FN_VAR_MSABI))\n+\tcontinue;\n+\n+      /*  */\n+      if ((var & fn_variant_mask) != var)\n+\tcontinue;\n+\n+      unsigned clobbers;\n+      for (clobbers = 0; clobbers <= OPTIONAL_REG_ALL; ++clobbers)\n+\t{\n+\t  /* Skip clobbers that would be invalid.  */\n+\t  if (clobbers & OPTIONAL_REG_RBP)\n+\t    {\n+\t      /* Whole program built with hard frame pointer.  */\n+\t      if (omit_rbp_clobbers)\n+\t\tcontinue;\n+\n+\t      /* Uses BP explicitly.  */\n+\t      if (var & FN_VAR_HFP_OR_REALIGN)\n+\t\tcontinue;\n+\n+\t      /* Alloca seems to require DRAP, which uses BP.  */\n+\t      if (var & FN_VAR_ALLOCA)\n+\t\tcontinue;\n+\t    }\n+\n+\t  for (auto const &as : arg_sets)\n+\t    {\n+\t      fn *fn;\n+\t      try {\n+\t\tfn = new ::fn (as, clobbers, var);\n+\t      } catch (invalid_argument) {\n+\t\tcontinue;\n+\t      }\n+\n+\t      msabi_funcs.push_back (fn);\n+\t      fn->print_def (out);\n+\t    }\n+\t}\n+    }\n+\n+  out << endl;\n+  make_do_tests_decl (all_args, out);\n+  out << endl;\n+\n+  make_do_test (all_args, msabi_funcs, out);\n+  out.close ();\n+}\n+\n+/* Parse a string into a long and return true upon success.  */\n+static bool long_optarg (const char *optarg, long &dest)\n+{\n+  char *end;\n+\n+  errno = 0;\n+  dest = strtol(optarg, &end, 0);\n+  if (errno)\n+    cerr << strerror(errno) << endl;\n+\n+  while (isspace(*end))\n+    ++end;\n+\n+  /* Error if errno non-zero or junk at end of string.  */\n+  return errno || *end;\n+}\n+\n+void usage ()\n+{\n+  cerr\n+<< \"Usage: \" << argv0 << \" [options] <output_file>\" << endl\n+<< endl\n+<< \"    -p <n|n-n>, --max-extra-params <expr>\" << endl\n+<< \"        A single or range of extra parameters\" << endl\n+<< \"        Examples:\" << endl\n+<< \"            -p0-5\" << endl\n+<< \"            -p12\" << endl\n+<< endl\n+<< \"    -v <n>, --variant-mask <n>\" << endl\n+<< \"        Set mask of test variants (see enum fn_variants for values,\" << endl\n+<< \"        defaults to 0x\" << hex << FN_VAR_MASK << \" [FN_VAR_MASK])\" << endl\n+<< endl\n+<< \"    -0, --omit-rbp-clobbers\" << endl\n+<< \"        Omit tests that clobber RBP.\" << endl;\n+  exit (-1);\n+}\n+\n+/* Parse string representing a number range or a list of numbers.  */\n+void set_extra_param_counts (const char *str)\n+{\n+  char copy[0x40];\n+  char *max_str;\n+  bool bad = false;\n+  long int min, max;\n+\n+  strncpy (copy, str, sizeof (copy) - 1);\n+  max_str = strchr(copy, '-');\n+  if (max_str)\n+      *max_str++ = 0;\n+\n+  bad = long_optarg (copy, min);\n+  if (max_str)\n+    bad = bad || long_optarg (max_str, max);\n+  else\n+    max = min;\n+\n+  if (min > max)\n+    usage ();\n+\n+  extra_params_min = min;\n+  extra_params_max = max;\n+}\n+\n+int main (int argc, char *argv[])\n+{\n+  argv0 = argv[0];\n+  const char *short_options = \"p:v:0\";\n+  const struct option long_options[] = {\n+    {\"extra-params\",\t\trequired_argument, 0, 'p'},\n+    {\"variant-mask\",\t\trequired_argument, 0, 'v'},\n+    {\"omit-rbp-clobbers\",\tno_argument,\t   0, '0'},\n+    {\"help\",\t\t\tno_argument,\t   0, 'h'},\n+    {0, 0, 0, 0},\n+  };\n+\n+  int option_index = 0;\n+  int c;\n+  while ((c = getopt_long (argc, argv, short_options, long_options,\n+\t\t\t   &option_index)) != -1)\n+    {\n+      switch (c)\n+\t{\n+\tlong l;\n+\n+\tcase 'p':\n+\t  set_extra_param_counts (optarg);\n+\t  break;\n+\n+\tcase 'v':\n+\t  if (long_optarg (optarg, l) || (l & ~FN_VAR_MASK))\n+\t  {\n+\t    cerr << \"ERROR: Bad value for -v: `\" << optarg <<  \"`\" << endl;\n+\t    usage ();\n+\t  }\n+\t  fn_variant_mask = (unsigned)l;\n+\t  break;\n+\n+\tcase '0':\n+\t  omit_rbp_clobbers = true;\n+\t  break;\n+\n+\tcase 'h':\n+\tdefault:\n+\t  usage ();\n+\t}\n+    }\n+\n+  if (argc - optind != 1)\n+    usage ();\n+  out_file_name = argv[optind];\n+\n+  /* Can't skip msabi funcions.  */\n+  fn_variant_mask |= FN_VAR_MSABI;\n+\n+  /* If whole program has HFP, explicit tests that enable it are redundant.  */\n+  if (omit_rbp_clobbers)\n+    fn_variant_mask &= ~FN_VAR_HFP;\n+\n+  stringstream argv_str;\n+\n+  for (int i = 0; i < argc; ++i)\n+    argv_str << (i ? \" \" : \"\") << argv[i];\n+\n+  int ret = 0;\n+  try\n+    {\n+      generate_header (argv_str.str());\n+    }\n+  catch (exception &e)\n+    {\n+      cerr << \"ERROR: While writing `\" << out_file_name << \"': \"\n+\t   << strerror(errno) << endl;\n+      ret = 1;\n+    }\n+  for_each (sysv_funcs.begin (), sysv_funcs.end (), default_delete<fn> ());\n+  for_each (msabi_funcs.begin (), msabi_funcs.end (), default_delete<fn> ());\n+\n+  return ret;\n+}"}, {"sha": "2a011f5103daf77d94542c1a56cb22a788160a6b", "filename": "gcc/testsuite/gcc.target/x86_64/abi/ms-sysv/ms-sysv.c", "status": "added", "additions": 373, "deletions": 0, "changes": 373, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6d4d7701a4c40f4c46904292456b76502e1ae63/gcc%2Ftestsuite%2Fgcc.target%2Fx86_64%2Fabi%2Fms-sysv%2Fms-sysv.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6d4d7701a4c40f4c46904292456b76502e1ae63/gcc%2Ftestsuite%2Fgcc.target%2Fx86_64%2Fabi%2Fms-sysv%2Fms-sysv.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fx86_64%2Fabi%2Fms-sysv%2Fms-sysv.c?ref=d6d4d7701a4c40f4c46904292456b76502e1ae63", "patch": "@@ -0,0 +1,373 @@\n+/* Test program for 64-Bit Microsoft to System V function calls.\n+   Copyright (C) 2016-2017 Free Software Foundation, Inc.\n+   Contributed by Daniel Santos <daniel.santos@pobox.com>\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 3, or (at your option)\n+any later version.\n+\n+GCC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+Under Section 7 of GPL version 3, you are granted additional\n+permissions described in the GCC Runtime Library Exception, version\n+3.1, as published by the Free Software Foundation.\n+\n+You should have received a copy of the GNU General Public License and\n+a copy of the GCC Runtime Library Exception along with this program;\n+see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+<http://www.gnu.org/licenses/>.  */\n+\n+/* This is a single-threaded test program for Microsoft 64-bit ABI functions.\n+   It is aimed at verifying correctness of pro/epilogues of ms_abi functions\n+   that call sysv_abi functions to assure clobbered registers are properly\n+   saved and restored and attempt to detect any flaws in the behavior of these\n+   functions.  The following variants are tested:\n+\n+   * Either uses hard frame pointer, re-aligns the stack or neither,\n+   * Uses alloca (and thus DRAP) or not,\n+   * Uses sibling call optimization or not,\n+   * Uses variable argument list or not, and\n+   * Has shrink-wrapped code or not.\n+\n+  In addition, an ms_abi function is generated for each of these combinations\n+  clobbering each unique combination additional registers (excluding BP when\n+  a frame pointer is used). Shrink-wrap variants are called in a way that\n+  both the fast and slow path are used. Re-aligned variants are called with\n+  an aligned and mis-aligned stack.\n+\n+  Each ms_abi function is called via an assembly stub that first saves all\n+  volatile registers and fills them with random values. The ms_abi function\n+  is then called.  After the function returns, the value of all volatile\n+  registers is verified against the random data and then restored.  */\n+\n+#include <stdio.h>\n+#include <string.h>\n+#include <stdlib.h>\n+#include <signal.h>\n+#include <unistd.h>\n+#include <stdint.h>\n+#include <alloca.h>\n+#include <stdarg.h>\n+#include <assert.h>\n+#include <errno.h>\n+#include <ctype.h>\n+\n+#ifndef __x86_64__\n+# error Test only valid on x86_64\n+#endif\n+\n+enum reg_data_sets\n+{\n+  REG_SET_SAVE,\n+  REG_SET_INPUT,\n+  REG_SET_OUTPUT,\n+\n+  REG_SET_COUNT\n+};\n+\n+enum flags\n+{\n+  FLAG_ALLOCA\t\t\t= 0x01000000,\n+  FLAG_SIBCALL\t\t\t= 0x02000000,\n+  FLAG_SHRINK_WRAP_FAST_PATH\t= 0x08000000,\n+  FLAG_SHRINK_WRAP_SLOW_PATH\t= 0x0c000000,\n+};\n+\n+enum alignment_option\n+{\n+  ALIGNMENT_NOT_TESTED,\n+  ALIGNMENT_ALIGNED,\n+  ALIGNMENT_MISALIGNED,\n+\n+  ALIGNMENT_COUNT,\n+};\n+\n+enum shrink_wrap_option\n+{\n+  SHRINK_WRAP_NONE,\n+  SHRINK_WRAP_FAST_PATH,\n+  SHRINK_WRAP_SLOW_PATH,\n+\n+  SHRINK_WRAP_COUNT\n+};\n+\n+union regdata {\n+  struct {\n+    __uint128_t\tsseregs[10];\n+    union {\n+      uint64_t\tintregs[8];\n+      struct {\n+\tuint64_t\trsi;\n+\tuint64_t\trdi;\n+\tuint64_t\trbx;\n+\tuint64_t\trbp;\n+\tuint64_t\tr12;\n+\tuint64_t\tr13;\n+\tuint64_t\tr14;\n+\tuint64_t\tr15;\n+      };\n+    };\n+  };\n+  uint32_t\t\tu32_arr[56];\n+} __attribute__((aligned (16)));\n+\n+struct test_data\n+{\n+  union regdata regdata[REG_SET_COUNT];\n+  void *fn;\n+  void *retaddr;\n+  const char *name;\n+  enum alignment_option alignment;\n+  enum shrink_wrap_option shrink_wrap;\n+  long ret_expected;\n+} test_data;\n+\n+static int shrink_wrap_global;\n+static void __attribute((sysv_abi)) do_tests ();\n+static void init_test (void *fn, const char *name,\n+\t\t       enum alignment_option alignment,\n+\t\t       enum shrink_wrap_option shrink_wrap, long ret_expected);\n+static void check_results (long ret);\n+static __attribute__((ms_abi)) long do_sibcall (long arg);\n+static __attribute__((ms_abi)) long\n+(*const volatile do_sibcall_noinfo) (long) = do_sibcall;\n+\n+/* Defines do_tests ().  */\n+#include \"ms-sysv-generated.h\"\n+\n+static int arbitrarily_fail;\n+static const char *argv0;\n+\n+static void __attribute__((noinline))\n+init_test (void *fn, const char *name, enum alignment_option alignment,\n+\t   enum shrink_wrap_option shrink_wrap, long ret_expected)\n+{\n+  int i;\n+  union regdata *data = &test_data.regdata[REG_SET_INPUT];\n+\n+  assert (alignment < ALIGNMENT_COUNT);\n+  assert (shrink_wrap < SHRINK_WRAP_COUNT);\n+\n+  memset (&test_data, 0, sizeof (test_data));\n+  for (i = 55; i >= 0; --i)\n+    data->u32_arr[i] = (uint32_t)lrand48 ();\n+  test_data.fn = fn;\n+  test_data.name = name;\n+  test_data.alignment = alignment;\n+  test_data.shrink_wrap = shrink_wrap;\n+  test_data.ret_expected = ret_expected;\n+\n+  switch (shrink_wrap)\n+  {\n+    case SHRINK_WRAP_NONE:\n+    case SHRINK_WRAP_COUNT:\n+      break;\n+    case SHRINK_WRAP_FAST_PATH:\n+      shrink_wrap_global = FLAG_SHRINK_WRAP_FAST_PATH;\n+      break;\n+    case SHRINK_WRAP_SLOW_PATH:\n+      shrink_wrap_global = FLAG_SHRINK_WRAP_SLOW_PATH;\n+      break;\n+  }\n+}\n+\n+static const char *alignment_str[ALIGNMENT_COUNT] =\n+{\n+  \"\", \"aligned\", \"misaligned\"\n+};\n+\n+static const char *shrink_wrap_str[SHRINK_WRAP_COUNT] =\n+{\n+  \"\", \"shrink-wrap fast path\", \"shrink-wrap slow path\"\n+};\n+\n+static const char *test_descr ()\n+{\n+  static char buffer[0x400];\n+\n+  if (test_data.alignment || test_data.shrink_wrap)\n+    snprintf (buffer, sizeof (buffer) - 1, \"`%s' (%s%s%s)\",\n+\t      test_data.name,\n+\t      alignment_str[test_data.alignment],\n+\t      (test_data.alignment && test_data.shrink_wrap ? \", \" : \"\"),\n+\t      shrink_wrap_str[test_data.shrink_wrap]);\n+  else\n+    snprintf (buffer, sizeof (buffer) - 1, \"`%s'\", test_data.name);\n+\n+  return buffer;\n+}\n+\n+static const char *regnames[] = {\n+  \"XMM6\",\n+  \"XMM7\",\n+  \"XMM8\",\n+  \"XMM9\",\n+  \"XMM10\",\n+  \"XMM11\",\n+  \"XMM12\",\n+  \"XMM13\",\n+  \"XMM14\",\n+  \"XMM15\",\n+  \"RSI\",\n+  \"RDI\",\n+  \"RBX\",\n+  \"RBP\",\n+  \"R12\",\n+  \"R13\",\n+  \"R14\",\n+  \"R15\",\n+};\n+\n+static void print_header (int *header_printed)\n+{\n+  if (!*header_printed)\n+    fprintf (stderr, \"       %-35s    %-35s\\n\", \"Expected\", \"Got\");\n+  *header_printed = 1;\n+}\n+\n+static int compare_reg128 (const __uint128_t *a, const __uint128_t *b,\n+\t\t\t   const char *name, int *header_printed)\n+{\n+  if (!memcmp (a, b, sizeof (*a)))\n+    return 0;\n+  else\n+    {\n+      long ha = *((long*)a);\n+      long la = *((long*)a + 16);\n+      long hb = *((long*)b);\n+      long lb = *((long*)a + 16);\n+      print_header (header_printed);\n+      fprintf (stderr, \"%-5s: 0x%016lx %016lx != 0x%016lx %016lx\\n\",\n+\t       name, ha, la, hb, lb);\n+      return 1;\n+    }\n+}\n+\n+static int compare_reg64 (long a, long b, const char *name,\n+\t\t\t  int *header_printed)\n+{\n+  if (a == b)\n+    return 0;\n+  else\n+    {\n+      print_header (header_printed);\n+      fprintf (stderr, \"%s: 0x%016lx != 0x%016lx\\n\", name, a, b);\n+      return 1;\n+    }\n+}\n+\n+\n+static void __attribute__((noinline)) check_results (long ret)\n+{\n+  unsigned i;\n+  unsigned bad = 0;\n+  int header_printed = 0;\n+\n+  union regdata *a = &test_data.regdata[REG_SET_INPUT];\n+  union regdata *b = &test_data.regdata[REG_SET_OUTPUT];\n+\n+  a = __builtin_assume_aligned(a, 16);\n+  b = __builtin_assume_aligned(b, 16);\n+\n+  if (arbitrarily_fail) {\n+    uint64_t u64 = lrand48 ();\n+    if (u64 % 100 == 0)\n+      b->u32_arr[u64 % 56] = 0xfdfdfdfd;\n+  }\n+\n+  for (i = 0; i < 10; ++i)\n+    bad |= compare_reg128 (&a->sseregs[i], &b->sseregs[i], regnames[i],\n+\t\t\t   &header_printed);\n+\n+  for (i = 0; i < 8; ++i)\n+    bad |= compare_reg64 (a->intregs[i], b->intregs[i], regnames[i + 10],\n+\t\t\t  &header_printed);\n+\n+  if (ret != test_data.ret_expected)\n+    {\n+      fprintf (stderr, \"Wrong return value: got 0x%016lx, expected 0x%016lx\\n\",\n+\t       ret, test_data.ret_expected);\n+      bad = 1;\n+    }\n+\n+  if (bad)\n+    {\n+      fprintf (stderr, \"Failed on test function %s\\n\", test_descr ());\n+      raise (SIGTRAP);\n+      exit (-1);\n+    }\n+}\n+\n+static __attribute__((ms_abi, noinline)) long do_sibcall (long arg) {\n+  return arg + FLAG_SIBCALL;\n+}\n+\n+void usage ()\n+{\n+  fprintf (stderr, \"Usage: %s [-s <seed>] [-f]\\n\", argv0);\n+  exit (-1);\n+}\n+\n+static long long_optarg (const char *optarg, const char *optstr)\n+{\n+  char *end;\n+  long ret;\n+\n+  errno = 0;\n+  ret = strtol(optarg, &end, 0);\n+\n+  while (isspace (*end))\n+    ++end;\n+\n+  if (errno || *end)\n+    {\n+      fprintf (stderr, \"ERROR: Bad value for %s: `%s`\\n\", optstr, optarg);\n+      if (errno)\n+\tfprintf (stderr, \"%s\\n\", strerror (errno));\n+      exit (-1);\n+    }\n+\n+  return ret;\n+}\n+\n+int main (int argc, char *argv[])\n+{\n+  long seed = 0;\n+  int c;\n+  argv0 = argv[0];\n+\n+  assert (!((long)&test_data.regdata[REG_SET_SAVE] & 15));\n+  assert (!((long)&test_data.regdata[REG_SET_INPUT] & 15));\n+  assert (!((long)&test_data.regdata[REG_SET_OUTPUT] & 15));\n+\n+  while ((c = getopt (argc, argv, \"s:f\")) != -1)\n+    {\n+      switch (c)\n+\t{\n+\tcase 's':\n+\t  seed = long_optarg (optarg, \"-s\");\n+\t  break;\n+\n+\tcase 'f':\n+\t  arbitrarily_fail = 1;\n+\t  fprintf (stderr, \"NOTE: Aribrary failure enabled (-f).\\n\");\n+\t  break;\n+\t}\n+    }\n+\n+  srand48 (seed);\n+  do_tests ();\n+\n+  /* Just in case we don't have enough tests to randomly trigger the\n+     failure.  */\n+  if (arbitrarily_fail)\n+    return -1;\n+\n+  return 0;\n+}"}, {"sha": "e317af9bd854e6a9f441c42160d29820655f1d1d", "filename": "gcc/testsuite/gcc.target/x86_64/abi/ms-sysv/ms-sysv.exp", "status": "added", "additions": 178, "deletions": 0, "changes": 178, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6d4d7701a4c40f4c46904292456b76502e1ae63/gcc%2Ftestsuite%2Fgcc.target%2Fx86_64%2Fabi%2Fms-sysv%2Fms-sysv.exp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6d4d7701a4c40f4c46904292456b76502e1ae63/gcc%2Ftestsuite%2Fgcc.target%2Fx86_64%2Fabi%2Fms-sysv%2Fms-sysv.exp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fx86_64%2Fabi%2Fms-sysv%2Fms-sysv.exp?ref=d6d4d7701a4c40f4c46904292456b76502e1ae63", "patch": "@@ -0,0 +1,178 @@\n+# Tests for ms_abi to sysv_abi calls.\n+# Copyright (C) 2016-2017 Free Software Foundation, Inc.\n+# Contributed by Daniel Santos <daniel.santos@pobox.com>\n+#\n+# This file is part of GCC.\n+#\n+# GCC is free software; you can redistribute it and/or modify\n+# it under the terms of the GNU General Public License as published by\n+# the Free Software Foundation; either version 3, or (at your option)\n+# any later version.\n+#\n+# GCC is distributed in the hope that it will be useful,\n+# but WITHOUT ANY WARRANTY; without even the implied warranty of\n+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+# GNU General Public License for more details.\n+#\n+# Under Section 7 of GPL version 3, you are granted additional\n+# permissions described in the GCC Runtime Library Exception, version\n+# 3.1, as published by the Free Software Foundation.\n+#\n+# You should have received a copy of the GNU General Public License and\n+# a copy of the GCC Runtime Library Exception along with this program;\n+# see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+# <http://www.gnu.org/licenses/>.\n+\n+# Exit immediately if this isn't a native x86_64 target.\n+if { (![istarget x86_64-*-*] && ![istarget i?86-*-*])\n+     || ![is-effective-target lp64] || ![isnative] } then {\n+    unsupported \"$subdir\"\n+    return\n+}\n+\n+global GCC_RUNTEST_PARALLELIZE_DIR\n+\n+load_lib gcc-dg.exp\n+\n+proc runtest_ms_sysv { cflags generator_args } {\n+    global GCC_UNDER_TEST HOSTCXX HOSTCXXFLAGS tmpdir srcdir subdir \\\n+\t   parallel_dir next_test\n+\n+    set objdir \"$tmpdir/ms-sysv\"\n+    set generator \"$tmpdir/ms-sysv-generate.exe\"\n+    set generated_header \"$objdir/ms-sysv-generated.h\"\n+    set do_test_o \"$objdir/do-test.o\"\n+    set ms_sysv_o \"$objdir/ms-sysv.o\"\n+    set ms_sysv_exe \"$objdir/ms-sysv.exe\"\n+    set status 0\n+    set warn_flags \"-Wall\"\n+    set this_test $next_test\n+    incr next_test\n+\n+    # Do parallelization here\n+    if [catch {set fd [open \"$parallel_dir/$this_test\" \\\n+\t\t\t    [list RDWR CREAT EXCL]]} ] {\n+\tif { [lindex $::errorCode 1] eq \"EEXIST\" } then {\n+\t    # Another job is running this test\n+\t    return\n+\t} else {\n+\t    error \"Failed to open $parallel_dir/$this_test: $::errorCode\"\n+\t    set status 1\n+\t}\n+    } else {\n+      close $fd\n+    }\n+\n+    # Detect when hard frame pointers are enabled (or required) so we know not\n+    # to generate bp clobbers.\n+    if [regexp \"^(.+ +| *)-(O0|fno-omit-frame-pointer|p|pg)( +.*)?$\" \\\n+\t       $cflags match] then {\n+\tset generator_args \"$generator_args --omit-rbp-clobbers\"\n+    }\n+\n+    set descr \"$subdir CFLAGS=\\\"$cflags\\\" generator_args=\\\"$generator_args\\\"\"\n+    verbose \"$tmpdir: Running test $descr\" 1\n+\n+    # Cleanup any previous test in objdir\n+    file delete -force $objdir\n+    file mkdir $objdir\n+\n+    # Build the generator (only needs to be done once).\n+    set src \"$srcdir/$subdir/gen.cc\"\n+    if { $status == 0 } then {\n+\tif { (![file exists \"$generator\"]) || ([file mtime \"$generator\"]\n+\t\t\t\t\t    < [file mtime \"$src\"]) } {\n+\t    # Temporarily switch to the environment for the host compiler.\n+\t    restore_ld_library_path_env_vars\n+\t    set cxx \"$HOSTCXX $HOSTCXXFLAGS $warn_flags -std=c++11\"\n+\t    set status [remote_exec host \"$cxx -o $generator $src\"]\n+\t    set status [lindex $status 0]\n+\t    set_ld_library_path_env_vars\n+\t    if { $status != 0 } then {\n+\t\twarning \"Could not build $subdir generator\"\n+\t    }\n+\t}\n+    }\n+\n+    # Generate header\n+    if { $status == 0 } then {\n+\tset status [remote_exec host \"$generator $generator_args $generated_header\"]\n+\tset status [lindex $status 0]\n+\tif { $status != 0 } then {\n+\t    warning \"Could not generate $generated_header\"\n+\t}\n+    }\n+\n+    set cc \"$GCC_UNDER_TEST -I$objdir -I$srcdir/$subdir $cflags $warn_flags\"\n+\n+    # Assemble do-test.S\n+    set src \"$srcdir/$subdir/do-test.S\"\n+    if { $status == 0 } then {\n+\tset status [remote_exec build \"$cc -c -o $do_test_o $src\"]\n+\tset status [lindex $status 0]\n+\tif { $status != 0 } then {\n+\t    warning \"Could not assemble $src\"\n+\t}\n+    }\n+\n+    # Build ms-sysv.c\n+    set src \"$srcdir/$subdir/ms-sysv.c\"\n+    if { $status == 0 } then {\n+\tset status [remote_exec build \"$cc -c -o $ms_sysv_o $src\" \"\" \"\" \"\" 1200]\n+\tset status [lindex $status 0]\n+\tif { $status != 0 } then {\n+\t    warning \"Could not build $src.\"\n+\t}\n+    }\n+\n+    # Link\n+    if { $status == 0 } then {\n+\tset status [remote_exec build \"$cc -o $ms_sysv_exe $ms_sysv_o $do_test_o\"]\n+\tset status [lindex $status 0]\n+\tif { $status != 0 } then {\n+\t    warning \"Link failed.\"\n+\t}\n+    }\n+\n+    # Execute\n+    if { $status == 0 } then {\n+\tset status [remote_exec build \"$ms_sysv_exe\"]\n+\tset status [lindex $status 0]\n+    }\n+\n+    if { $status != 0 } then {\n+\tfail $descr\n+    } else {\n+\tpass $descr\n+    }\n+}\n+\n+dg-init\n+\n+# Setup parallelization\n+set next_test 0\n+set parallel_dir \"$env(GCC_RUNTEST_PARALLELIZE_DIR)/abi-ms-sysv\"\n+file mkdir \"$env(GCC_RUNTEST_PARALLELIZE_DIR)\"\n+file mkdir \"$parallel_dir\"\n+\n+if { ![file isdirectory \"$parallel_dir\"] } then {\n+    error \"Failed to create directory $parallel_dir: $::errorCode\"\n+    return\n+}\n+\n+set gen_opts \"-p0-5\"\n+set all_options [list \"-O2\" \"-O0 -g3\"]\n+\n+# Run without -mcall-ms2sysv-xlogues always\n+foreach opt $all_options {\n+    runtest_ms_sysv \"$opt\" \"$gen_opts\"\n+}\n+\n+# Skip -mcall-ms2sysv-xlogues on Windows (not supported)\n+if { ![istarget *-*-cygwin*] && ![istarget *-*-mingw*] } {\n+    foreach opt $all_options {\n+\truntest_ms_sysv \"-mcall-ms2sysv-xlogues $opt\" \"$gen_opts\"\n+    }\n+}\n+\n+dg-finish"}, {"sha": "13bdd94641c0db2c9256110e327c21def0359e49", "filename": "libgcc/ChangeLog", "status": "modified", "additions": 13, "deletions": 1, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6d4d7701a4c40f4c46904292456b76502e1ae63/libgcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6d4d7701a4c40f4c46904292456b76502e1ae63/libgcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2FChangeLog?ref=d6d4d7701a4c40f4c46904292456b76502e1ae63", "patch": "@@ -1,3 +1,15 @@\n+2017-05-14  Daniel Santos  <daniel.santos@pobox.com>\n+\n+\t* config.host: Add i386/t-msabi to i386/t-linux file list.\n+\t* config/i386/i386-asm.h: New file.\n+\t* config/i386/resms64.S: New file.\n+\t* config/i386/resms64f.S: New file.\n+\t* config/i386/resms64fx.S: New file.\n+\t* config/i386/resms64x.S: New file.\n+\t* config/i386/savms64.S: New file.\n+\t* config/i386/savms64f.S: New file.\n+\t* config/i386/t-msabi: New file.\n+\n 2017-05-09  Andreas Tobler  <andreast@gcc.gnu.org>\n \n \t* config.host: Use the generic FreeBSD t-slibgcc-elf-ver for\n@@ -9,7 +21,7 @@\n \tpc-relative indirect handling for fuchsia.\n \t* config/t-slibgcc-fuchsia: New file.\n \t* config.host (*-*-fuchsia*, aarch64*-*-fuchsia*, arm*-*-fuchsia*,\n-\tx86_64-*-fuchsia*): Add definitions. \n+\tx86_64-*-fuchsia*): Add definitions.\n \n 2017-04-19  Martin Liska  <mliska@suse.cz>\n "}, {"sha": "466b855c39b76daac7e2e04422066d28b9136a89", "filename": "libgcc/config.host", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6d4d7701a4c40f4c46904292456b76502e1ae63/libgcc%2Fconfig.host", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6d4d7701a4c40f4c46904292456b76502e1ae63/libgcc%2Fconfig.host", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig.host?ref=d6d4d7701a4c40f4c46904292456b76502e1ae63", "patch": "@@ -1368,7 +1368,7 @@ case ${host} in\n i[34567]86-*-linux* | x86_64-*-linux* | \\\n   i[34567]86-*-kfreebsd*-gnu | x86_64-*-kfreebsd*-gnu | \\\n   i[34567]86-*-gnu*)\n-\ttmake_file=\"${tmake_file} t-tls i386/t-linux t-slibgcc-libgcc\"\n+\ttmake_file=\"${tmake_file} t-tls i386/t-linux i386/t-msabi t-slibgcc-libgcc\"\n \tif test \"$libgcc_cv_cfi\" = \"yes\"; then\n \t\ttmake_file=\"${tmake_file} t-stack i386/t-stack-i386\"\n \tfi"}, {"sha": "c613e9fd83ddfd0095921d14dbc008625fbbe860", "filename": "libgcc/config/i386/i386-asm.h", "status": "added", "additions": 82, "deletions": 0, "changes": 82, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6d4d7701a4c40f4c46904292456b76502e1ae63/libgcc%2Fconfig%2Fi386%2Fi386-asm.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6d4d7701a4c40f4c46904292456b76502e1ae63/libgcc%2Fconfig%2Fi386%2Fi386-asm.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Fi386%2Fi386-asm.h?ref=d6d4d7701a4c40f4c46904292456b76502e1ae63", "patch": "@@ -0,0 +1,82 @@\n+/* Defines common perprocessor and assembly macros for use by various stubs.\n+   Copyright (C) 2016-2017 Free Software Foundation, Inc.\n+   Contributed by Daniel Santos <daniel.santos@pobox.com>\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 3, or (at your option)\n+any later version.\n+\n+GCC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+Under Section 7 of GPL version 3, you are granted additional\n+permissions described in the GCC Runtime Library Exception, version\n+3.1, as published by the Free Software Foundation.\n+\n+You should have received a copy of the GNU General Public License and\n+a copy of the GCC Runtime Library Exception along with this program;\n+see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#ifndef I386_ASM_H\n+#define I386_ASM_H\n+\n+#ifdef __ELF__\n+# define ELFFN(fn) .type fn,@function\n+#else\n+# define ELFFN(fn)\n+#endif\n+\n+#define FUNC_START(fn)\t\\\n+\t.global fn;\t\\\n+\tELFFN (fn);\t\\\n+fn:\n+\n+#define HIDDEN_FUNC(fn)\\\n+\tFUNC_START (fn)\t\\\n+\t.hidden fn;\t\\\n+\n+#define FUNC_END(fn) .size fn,.-fn\n+\n+#ifdef __SSE2__\n+# ifdef __AVX__\n+#  define MOVAPS vmovaps\n+# else\n+#  define MOVAPS movaps\n+# endif\n+\n+/* Save SSE registers 6-15. off is the offset of rax to get to xmm6.  */\n+.macro SSE_SAVE off=0\n+\tMOVAPS %xmm15,(\\off - 0x90)(%rax)\n+\tMOVAPS %xmm14,(\\off - 0x80)(%rax)\n+\tMOVAPS %xmm13,(\\off - 0x70)(%rax)\n+\tMOVAPS %xmm12,(\\off - 0x60)(%rax)\n+\tMOVAPS %xmm11,(\\off - 0x50)(%rax)\n+\tMOVAPS %xmm10,(\\off - 0x40)(%rax)\n+\tMOVAPS %xmm9, (\\off - 0x30)(%rax)\n+\tMOVAPS %xmm8, (\\off - 0x20)(%rax)\n+\tMOVAPS %xmm7, (\\off - 0x10)(%rax)\n+\tMOVAPS %xmm6, \\off(%rax)\n+.endm\n+\n+/* Restore SSE registers 6-15. off is the offset of rsi to get to xmm6.  */\n+.macro SSE_RESTORE off=0\n+\tMOVAPS (\\off - 0x90)(%rsi), %xmm15\n+\tMOVAPS (\\off - 0x80)(%rsi), %xmm14\n+\tMOVAPS (\\off - 0x70)(%rsi), %xmm13\n+\tMOVAPS (\\off - 0x60)(%rsi), %xmm12\n+\tMOVAPS (\\off - 0x50)(%rsi), %xmm11\n+\tMOVAPS (\\off - 0x40)(%rsi), %xmm10\n+\tMOVAPS (\\off - 0x30)(%rsi), %xmm9\n+\tMOVAPS (\\off - 0x20)(%rsi), %xmm8\n+\tMOVAPS (\\off - 0x10)(%rsi), %xmm7\n+\tMOVAPS \\off(%rsi), %xmm6\n+.endm\n+\n+#endif /* __SSE2__ */\n+#endif /* I386_ASM_H */"}, {"sha": "f47e2f066fb31b629e56e8faa714d68ea18faef9", "filename": "libgcc/config/i386/resms64.S", "status": "added", "additions": 57, "deletions": 0, "changes": 57, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6d4d7701a4c40f4c46904292456b76502e1ae63/libgcc%2Fconfig%2Fi386%2Fresms64.S", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6d4d7701a4c40f4c46904292456b76502e1ae63/libgcc%2Fconfig%2Fi386%2Fresms64.S", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Fi386%2Fresms64.S?ref=d6d4d7701a4c40f4c46904292456b76502e1ae63", "patch": "@@ -0,0 +1,57 @@\n+/* Epilogue stub for 64-bit ms/sysv clobbers: restore\n+   Copyright (C) 2016-2017 Free Software Foundation, Inc.\n+   Contributed by Daniel Santos <daniel.santos@pobox.com>\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 3, or (at your option)\n+any later version.\n+\n+GCC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+Under Section 7 of GPL version 3, you are granted additional\n+permissions described in the GCC Runtime Library Exception, version\n+3.1, as published by the Free Software Foundation.\n+\n+You should have received a copy of the GNU General Public License and\n+a copy of the GCC Runtime Library Exception along with this program;\n+see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#ifdef __x86_64__\n+#include \"i386-asm.h\"\n+\n+/* Epilogue routine for restoring 64-bit ms/sysv registers.  */\n+\n+\t.text\n+HIDDEN_FUNC(__resms64_18)\n+\tmov\t-0x70(%rsi),%r15\n+HIDDEN_FUNC(__resms64_17)\n+\tmov\t-0x68(%rsi),%r14\n+HIDDEN_FUNC(__resms64_16)\n+\tmov\t-0x60(%rsi),%r13\n+HIDDEN_FUNC(__resms64_15)\n+\tmov\t-0x58(%rsi),%r12\n+HIDDEN_FUNC(__resms64_14)\n+\tmov\t-0x50(%rsi),%rbp\n+HIDDEN_FUNC(__resms64_13)\n+\tmov\t-0x48(%rsi),%rbx\n+HIDDEN_FUNC(__resms64_12)\n+\tmov\t-0x40(%rsi),%rdi\n+\tSSE_RESTORE off=0x60\n+\tmov\t-0x38(%rsi),%rsi\n+\tret\n+FUNC_END(__resms64_12)\n+FUNC_END(__resms64_13)\n+FUNC_END(__resms64_14)\n+FUNC_END(__resms64_15)\n+FUNC_END(__resms64_16)\n+FUNC_END(__resms64_17)\n+FUNC_END(__resms64_18)\n+\n+#endif /* __x86_64__ */"}, {"sha": "817da60cf1595adc22fce3c5ae9793f348acbbef", "filename": "libgcc/config/i386/resms64f.S", "status": "added", "additions": 55, "deletions": 0, "changes": 55, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6d4d7701a4c40f4c46904292456b76502e1ae63/libgcc%2Fconfig%2Fi386%2Fresms64f.S", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6d4d7701a4c40f4c46904292456b76502e1ae63/libgcc%2Fconfig%2Fi386%2Fresms64f.S", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Fi386%2Fresms64f.S?ref=d6d4d7701a4c40f4c46904292456b76502e1ae63", "patch": "@@ -0,0 +1,55 @@\n+/* Epilogue stub for 64-bit ms/sysv clobbers: restore (with hard frame pointer)\n+   Copyright (C) 2016-2017 Free Software Foundation, Inc.\n+   Contributed by Daniel Santos <daniel.santos@pobox.com>\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 3, or (at your option)\n+any later version.\n+\n+GCC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+Under Section 7 of GPL version 3, you are granted additional\n+permissions described in the GCC Runtime Library Exception, version\n+3.1, as published by the Free Software Foundation.\n+\n+You should have received a copy of the GNU General Public License and\n+a copy of the GCC Runtime Library Exception along with this program;\n+see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#ifdef __x86_64__\n+#include \"i386-asm.h\"\n+\n+/* Epilogue routine for restoring 64-bit ms/sysv registers when hard frame\n+   pointer is used.  */\n+\n+\t.text\n+HIDDEN_FUNC(__resms64f_17)\n+\tmov\t-0x68(%rsi),%r15\n+HIDDEN_FUNC(__resms64f_16)\n+\tmov\t-0x60(%rsi),%r14\n+HIDDEN_FUNC(__resms64f_15)\n+\tmov\t-0x58(%rsi),%r13\n+HIDDEN_FUNC(__resms64f_14)\n+\tmov\t-0x50(%rsi),%r12\n+HIDDEN_FUNC(__resms64f_13)\n+\tmov\t-0x48(%rsi),%rbx\n+HIDDEN_FUNC(__resms64f_12)\n+\tmov\t-0x40(%rsi),%rdi\n+\tSSE_RESTORE off=0x60\n+\tmov\t-0x38(%rsi),%rsi\n+\tret\n+FUNC_END(__resms64f_12)\n+FUNC_END(__resms64f_13)\n+FUNC_END(__resms64f_14)\n+FUNC_END(__resms64f_15)\n+FUNC_END(__resms64f_16)\n+FUNC_END(__resms64f_17)\n+\n+#endif /* __x86_64__ */"}, {"sha": "5dba5848dee0688399fa55b1ee1723313329d96d", "filename": "libgcc/config/i386/resms64fx.S", "status": "added", "additions": 57, "deletions": 0, "changes": 57, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6d4d7701a4c40f4c46904292456b76502e1ae63/libgcc%2Fconfig%2Fi386%2Fresms64fx.S", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6d4d7701a4c40f4c46904292456b76502e1ae63/libgcc%2Fconfig%2Fi386%2Fresms64fx.S", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Fi386%2Fresms64fx.S?ref=d6d4d7701a4c40f4c46904292456b76502e1ae63", "patch": "@@ -0,0 +1,57 @@\n+/* Epilogue stub for 64-bit ms/sysv clobbers: restore, leave and return\n+   Copyright (C) 2016-2017 Free Software Foundation, Inc.\n+   Contributed by Daniel Santos <daniel.santos@pobox.com>\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 3, or (at your option)\n+any later version.\n+\n+GCC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+Under Section 7 of GPL version 3, you are granted additional\n+permissions described in the GCC Runtime Library Exception, version\n+3.1, as published by the Free Software Foundation.\n+\n+You should have received a copy of the GNU General Public License and\n+a copy of the GCC Runtime Library Exception along with this program;\n+see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#ifdef __x86_64__\n+#include \"i386-asm.h\"\n+\n+/* Epilogue routine for 64-bit ms/sysv registers when hard frame pointer\n+ * used -- restores registers, restores frame pointer and then returns\n+ * from the function.  */\n+\n+\t.text\n+HIDDEN_FUNC(__resms64fx_17)\n+\tmov\t-0x68(%rsi),%r15\n+HIDDEN_FUNC(__resms64fx_16)\n+\tmov\t-0x60(%rsi),%r14\n+HIDDEN_FUNC(__resms64fx_15)\n+\tmov\t-0x58(%rsi),%r13\n+HIDDEN_FUNC(__resms64fx_14)\n+\tmov\t-0x50(%rsi),%r12\n+HIDDEN_FUNC(__resms64fx_13)\n+\tmov\t-0x48(%rsi),%rbx\n+HIDDEN_FUNC(__resms64fx_12)\n+\tmov\t-0x40(%rsi),%rdi\n+\tSSE_RESTORE off=0x60\n+\tmov\t-0x38(%rsi),%rsi\n+\tleaveq\n+\tret\n+FUNC_END(__resms64fx_12)\n+FUNC_END(__resms64fx_13)\n+FUNC_END(__resms64fx_14)\n+FUNC_END(__resms64fx_15)\n+FUNC_END(__resms64fx_16)\n+FUNC_END(__resms64fx_17)\n+\n+#endif /* __x86_64__ */"}, {"sha": "7770447cf382423db1bc3ca921e529cb01468e09", "filename": "libgcc/config/i386/resms64x.S", "status": "added", "additions": 59, "deletions": 0, "changes": 59, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6d4d7701a4c40f4c46904292456b76502e1ae63/libgcc%2Fconfig%2Fi386%2Fresms64x.S", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6d4d7701a4c40f4c46904292456b76502e1ae63/libgcc%2Fconfig%2Fi386%2Fresms64x.S", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Fi386%2Fresms64x.S?ref=d6d4d7701a4c40f4c46904292456b76502e1ae63", "patch": "@@ -0,0 +1,59 @@\n+/* Epilogue stub for 64-bit ms/sysv clobbers: restore and return\n+   Copyright (C) 2016-2017 Free Software Foundation, Inc.\n+   Contributed by Daniel Santos <daniel.santos@pobox.com>\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 3, or (at your option)\n+any later version.\n+\n+GCC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+Under Section 7 of GPL version 3, you are granted additional\n+permissions described in the GCC Runtime Library Exception, version\n+3.1, as published by the Free Software Foundation.\n+\n+You should have received a copy of the GNU General Public License and\n+a copy of the GCC Runtime Library Exception along with this program;\n+see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#ifdef __x86_64__\n+#include \"i386-asm.h\"\n+\n+/* Epilogue routine for restoring 64-bit ms/sysv registers and returning from\n+ * function.  */\n+\n+\t.text\n+HIDDEN_FUNC(__resms64x_18)\n+\tmov\t-0x70(%rsi),%r15\n+HIDDEN_FUNC(__resms64x_17)\n+\tmov\t-0x68(%rsi),%r14\n+HIDDEN_FUNC(__resms64x_16)\n+\tmov\t-0x60(%rsi),%r13\n+HIDDEN_FUNC(__resms64x_15)\n+\tmov\t-0x58(%rsi),%r12\n+HIDDEN_FUNC(__resms64x_14)\n+\tmov\t-0x50(%rsi),%rbp\n+HIDDEN_FUNC(__resms64x_13)\n+\tmov\t-0x48(%rsi),%rbx\n+HIDDEN_FUNC(__resms64x_12)\n+\tmov\t-0x40(%rsi),%rdi\n+\tSSE_RESTORE off=0x60\n+\tmov\t-0x38(%rsi),%rsi\n+\tmov\t%r10,%rsp\n+\tret\n+FUNC_END(__resms64x_12)\n+FUNC_END(__resms64x_13)\n+FUNC_END(__resms64x_14)\n+FUNC_END(__resms64x_15)\n+FUNC_END(__resms64x_16)\n+FUNC_END(__resms64x_17)\n+FUNC_END(__resms64x_18)\n+\n+#endif /* __x86_64__ */"}, {"sha": "2067dd8614f36941fbaa908393661c0c56479a82", "filename": "libgcc/config/i386/savms64.S", "status": "added", "additions": 57, "deletions": 0, "changes": 57, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6d4d7701a4c40f4c46904292456b76502e1ae63/libgcc%2Fconfig%2Fi386%2Fsavms64.S", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6d4d7701a4c40f4c46904292456b76502e1ae63/libgcc%2Fconfig%2Fi386%2Fsavms64.S", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Fi386%2Fsavms64.S?ref=d6d4d7701a4c40f4c46904292456b76502e1ae63", "patch": "@@ -0,0 +1,57 @@\n+/* Prologue stub for 64-bit ms/sysv clobbers: save\n+   Copyright (C) 2016-2017 Free Software Foundation, Inc.\n+   Contributed by Daniel Santos <daniel.santos@pobox.com>\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 3, or (at your option)\n+any later version.\n+\n+GCC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+Under Section 7 of GPL version 3, you are granted additional\n+permissions described in the GCC Runtime Library Exception, version\n+3.1, as published by the Free Software Foundation.\n+\n+You should have received a copy of the GNU General Public License and\n+a copy of the GCC Runtime Library Exception along with this program;\n+see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#ifdef __x86_64__\n+#include \"i386-asm.h\"\n+\n+/* Prologue routine for saving 64-bit ms/sysv registers.  */\n+\n+\t.text\n+HIDDEN_FUNC(__savms64_18)\n+\tmov\t%r15,-0x70(%rax)\n+HIDDEN_FUNC(__savms64_17)\n+\tmov\t%r14,-0x68(%rax)\n+HIDDEN_FUNC(__savms64_16)\n+\tmov\t%r13,-0x60(%rax)\n+HIDDEN_FUNC(__savms64_15)\n+\tmov\t%r12,-0x58(%rax)\n+HIDDEN_FUNC(__savms64_14)\n+\tmov\t%rbp,-0x50(%rax)\n+HIDDEN_FUNC(__savms64_13)\n+\tmov\t%rbx,-0x48(%rax)\n+HIDDEN_FUNC(__savms64_12)\n+\tmov\t%rdi,-0x40(%rax)\n+\tmov\t%rsi,-0x38(%rax)\n+\tSSE_SAVE off=0x60\n+\tret\n+FUNC_END(__savms64_12)\n+FUNC_END(__savms64_13)\n+FUNC_END(__savms64_14)\n+FUNC_END(__savms64_15)\n+FUNC_END(__savms64_16)\n+FUNC_END(__savms64_17)\n+FUNC_END(__savms64_18)\n+\n+#endif /* __x86_64__ */"}, {"sha": "81583b6eb689862b134bee41be50a1d38dc9f9dc", "filename": "libgcc/config/i386/savms64f.S", "status": "added", "additions": 55, "deletions": 0, "changes": 55, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6d4d7701a4c40f4c46904292456b76502e1ae63/libgcc%2Fconfig%2Fi386%2Fsavms64f.S", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6d4d7701a4c40f4c46904292456b76502e1ae63/libgcc%2Fconfig%2Fi386%2Fsavms64f.S", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Fi386%2Fsavms64f.S?ref=d6d4d7701a4c40f4c46904292456b76502e1ae63", "patch": "@@ -0,0 +1,55 @@\n+/* Prologue stub for 64-bit ms/sysv clobbers: save (with hard frame pointer)\n+   Copyright (C) 2016-2017 Free Software Foundation, Inc.\n+   Contributed by Daniel Santos <daniel.santos@pobox.com>\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 3, or (at your option)\n+any later version.\n+\n+GCC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+Under Section 7 of GPL version 3, you are granted additional\n+permissions described in the GCC Runtime Library Exception, version\n+3.1, as published by the Free Software Foundation.\n+\n+You should have received a copy of the GNU General Public License and\n+a copy of the GCC Runtime Library Exception along with this program;\n+see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#ifdef __x86_64__\n+#include \"i386-asm.h\"\n+\n+/* Prologue routine for saving 64-bit ms/sysv registers when realignment is\n+ * needed or hard frame pointer used.  */\n+\n+\t.text\n+HIDDEN_FUNC(__savms64f_17)\n+\tmov\t%r15,-0x68(%rax)\n+HIDDEN_FUNC(__savms64f_16)\n+\tmov\t%r14,-0x60(%rax)\n+HIDDEN_FUNC(__savms64f_15)\n+\tmov\t%r13,-0x58(%rax)\n+HIDDEN_FUNC(__savms64f_14)\n+\tmov\t%r12,-0x50(%rax)\n+HIDDEN_FUNC(__savms64f_13)\n+\tmov\t%rbx,-0x48(%rax)\n+HIDDEN_FUNC(__savms64f_12)\n+\tmov\t%rdi,-0x40(%rax)\n+\tmov\t%rsi,-0x38(%rax)\n+\tSSE_SAVE off=0x60\n+\tret\n+FUNC_END(__savms64f_12)\n+FUNC_END(__savms64f_13)\n+FUNC_END(__savms64f_14)\n+FUNC_END(__savms64f_15)\n+FUNC_END(__savms64f_16)\n+FUNC_END(__savms64f_17)\n+\n+#endif /* __x86_64__ */"}, {"sha": "f9806a611aace34ce03c77e24fda5c329f6f4d7a", "filename": "libgcc/config/i386/t-msabi", "status": "added", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6d4d7701a4c40f4c46904292456b76502e1ae63/libgcc%2Fconfig%2Fi386%2Ft-msabi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6d4d7701a4c40f4c46904292456b76502e1ae63/libgcc%2Fconfig%2Fi386%2Ft-msabi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Fi386%2Ft-msabi?ref=d6d4d7701a4c40f4c46904292456b76502e1ae63", "patch": "@@ -0,0 +1,7 @@\n+# Makefile fragment to support -mcall-ms2sysv-xlogues\n+LIB2ADD_ST += $(srcdir)/config/i386/savms64.S \\\n+\t      $(srcdir)/config/i386/resms64.S \\\n+\t      $(srcdir)/config/i386/resms64x.S \\\n+\t      $(srcdir)/config/i386/savms64f.S \\\n+\t      $(srcdir)/config/i386/resms64f.S \\\n+\t      $(srcdir)/config/i386/resms64fx.S"}]}