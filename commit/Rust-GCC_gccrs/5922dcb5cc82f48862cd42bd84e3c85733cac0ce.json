{"sha": "5922dcb5cc82f48862cd42bd84e3c85733cac0ce", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTkyMmRjYjVjYzgyZjQ4ODYyY2Q0MmJkODRlM2M4NTczM2NhYzBjZQ==", "commit": {"author": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2018-08-01T09:10:31Z"}, "committer": {"name": "Jakub Jelinek", "email": "jakub@gcc.gnu.org", "date": "2018-08-01T09:10:31Z"}, "message": "re PR c/85704 (cc1 run out of memory when it compile)\n\n\tPR c/85704\n\t* c-typeck.c (init_field_decl_cmp): New function.\n\t(output_pending_init_elements): Use it for field comparisons\n\tinstead of pure bit_position comparisons.\n\n\t* gcc.c-torture/compile/pr85704.c: New test.\n\nFrom-SVN: r263198", "tree": {"sha": "5da99f1c888c027956275da6051673c2ce41f66f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5da99f1c888c027956275da6051673c2ce41f66f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5922dcb5cc82f48862cd42bd84e3c85733cac0ce", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5922dcb5cc82f48862cd42bd84e3c85733cac0ce", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5922dcb5cc82f48862cd42bd84e3c85733cac0ce", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5922dcb5cc82f48862cd42bd84e3c85733cac0ce/comments", "author": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "d1b05d128dca0009642908dd2fb490c1ee27e72e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d1b05d128dca0009642908dd2fb490c1ee27e72e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d1b05d128dca0009642908dd2fb490c1ee27e72e"}], "stats": {"total": 108, "additions": 91, "deletions": 17}, "files": [{"sha": "0c845e27c6d6180bbf04cae5dd962c6440f88340", "filename": "gcc/c/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5922dcb5cc82f48862cd42bd84e3c85733cac0ce/gcc%2Fc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5922dcb5cc82f48862cd42bd84e3c85733cac0ce/gcc%2Fc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc%2FChangeLog?ref=5922dcb5cc82f48862cd42bd84e3c85733cac0ce", "patch": "@@ -1,3 +1,10 @@\n+2018-08-01  Jakub Jelinek  <jakub@redhat.com>\n+\n+\tPR c/85704\n+\t* c-typeck.c (init_field_decl_cmp): New function.\n+\t(output_pending_init_elements): Use it for field comparisons\n+\tinstead of pure bit_position comparisons.\n+\n 2018-07-12  Jakub Jelinek  <jakub@redhat.com>\n \n \t* c-decl.c (c_decl_attributes): Don't diagnose vars without mappable"}, {"sha": "f6a326c8152cde22adb092bc7f47a1064f798d20", "filename": "gcc/c/c-typeck.c", "status": "modified", "additions": 69, "deletions": 17, "changes": 86, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5922dcb5cc82f48862cd42bd84e3c85733cac0ce/gcc%2Fc%2Fc-typeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5922dcb5cc82f48862cd42bd84e3c85733cac0ce/gcc%2Fc%2Fc-typeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc%2Fc-typeck.c?ref=5922dcb5cc82f48862cd42bd84e3c85733cac0ce", "patch": "@@ -9330,6 +9330,65 @@ output_init_element (location_t loc, tree value, tree origtype,\n     output_pending_init_elements (0, braced_init_obstack);\n }\n \n+/* For two FIELD_DECLs in the same chain, return -1 if field1\n+   comes before field2, 1 if field1 comes after field2 and\n+   0 if field1 == field2.  */\n+\n+static int\n+init_field_decl_cmp (tree field1, tree field2)\n+{\n+  if (field1 == field2)\n+    return 0;\n+\n+  tree bitpos1 = bit_position (field1);\n+  tree bitpos2 = bit_position (field2);\n+  if (tree_int_cst_equal (bitpos1, bitpos2))\n+    {\n+      /* If one of the fields has non-zero bitsize, then that\n+\t field must be the last one in a sequence of zero\n+\t sized fields, fields after it will have bigger\n+\t bit_position.  */\n+      if (TREE_TYPE (field1) != error_mark_node\n+\t  && COMPLETE_TYPE_P (TREE_TYPE (field1))\n+\t  && integer_nonzerop (TREE_TYPE (field1)))\n+\treturn 1;\n+      if (TREE_TYPE (field2) != error_mark_node\n+\t  && COMPLETE_TYPE_P (TREE_TYPE (field2))\n+\t  && integer_nonzerop (TREE_TYPE (field2)))\n+\treturn -1;\n+      /* Otherwise, fallback to DECL_CHAIN walk to find out\n+\t which field comes earlier.  Walk chains of both\n+\t fields, so that if field1 and field2 are close to each\n+\t other in either order, it is found soon even for large\n+\t sequences of zero sized fields.  */\n+      tree f1 = field1, f2 = field2;\n+      while (1)\n+\t{\n+\t  f1 = DECL_CHAIN (f1);\n+\t  f2 = DECL_CHAIN (f2);\n+\t  if (f1 == NULL_TREE)\n+\t    {\n+\t      gcc_assert (f2);\n+\t      return 1;\n+\t    }\n+\t  if (f2 == NULL_TREE)\n+\t    return -1;\n+\t  if (f1 == field2)\n+\t    return -1;\n+\t  if (f2 == field1)\n+\t    return 1;\n+\t  if (!tree_int_cst_equal (bit_position (f1), bitpos1))\n+\t    return 1;\n+\t  if (!tree_int_cst_equal (bit_position (f2), bitpos1))\n+\t    return -1;\n+\t}\n+    }\n+  else if (tree_int_cst_lt (bitpos1, bitpos2))\n+    return -1;\n+  else\n+    return 1;\n+}\n+\n /* Output any pending elements which have become next.\n    As we output elements, constructor_unfilled_{fields,index}\n    advances, which may cause other elements to become next;\n@@ -9401,25 +9460,18 @@ output_pending_init_elements (int all, struct obstack * braced_init_obstack)\n \t}\n       else if (RECORD_OR_UNION_TYPE_P (constructor_type))\n \t{\n-\t  tree ctor_unfilled_bitpos, elt_bitpos;\n-\n \t  /* If the current record is complete we are done.  */\n \t  if (constructor_unfilled_fields == NULL_TREE)\n \t    break;\n \n-\t  ctor_unfilled_bitpos = bit_position (constructor_unfilled_fields);\n-\t  elt_bitpos = bit_position (elt->purpose);\n-\t  /* We can't compare fields here because there might be empty\n-\t     fields in between.  */\n-\t  if (tree_int_cst_equal (elt_bitpos, ctor_unfilled_bitpos))\n-\t    {\n-\t      constructor_unfilled_fields = elt->purpose;\n-\t      output_init_element (input_location, elt->value, elt->origtype,\n-\t\t\t\t   true, TREE_TYPE (elt->purpose),\n-\t\t\t\t   elt->purpose, false, false,\n-\t\t\t\t   braced_init_obstack);\n-\t    }\n-\t  else if (tree_int_cst_lt (ctor_unfilled_bitpos, elt_bitpos))\n+\t  int cmp = init_field_decl_cmp (constructor_unfilled_fields,\n+\t\t\t\t\t elt->purpose);\n+\t  if (cmp == 0)\n+\t    output_init_element (input_location, elt->value, elt->origtype,\n+\t\t\t\t true, TREE_TYPE (elt->purpose),\n+\t\t\t\t elt->purpose, false, false,\n+\t\t\t\t braced_init_obstack);\n+\t  else if (cmp < 0)\n \t    {\n \t      /* Advance to the next smaller node.  */\n \t      if (elt->left)\n@@ -9445,8 +9497,8 @@ output_pending_init_elements (int all, struct obstack * braced_init_obstack)\n \t\t    elt = elt->parent;\n \t\t  elt = elt->parent;\n \t\t  if (elt\n-\t\t      && (tree_int_cst_lt (ctor_unfilled_bitpos,\n-\t\t\t\t\t   bit_position (elt->purpose))))\n+\t\t      && init_field_decl_cmp (constructor_unfilled_fields,\n+\t\t\t\t\t      elt->purpose) < 0)\n \t\t    {\n \t\t      next = elt->purpose;\n \t\t      break;"}, {"sha": "c4561cd4594dabb440953a7b6057c3c4e3a1af5a", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5922dcb5cc82f48862cd42bd84e3c85733cac0ce/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5922dcb5cc82f48862cd42bd84e3c85733cac0ce/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=5922dcb5cc82f48862cd42bd84e3c85733cac0ce", "patch": "@@ -1,3 +1,8 @@\n+2018-08-01  Jakub Jelinek  <jakub@redhat.com>\n+\n+\tPR c/85704\n+\t* gcc.c-torture/compile/pr85704.c: New test.\n+\n 2018-07-31  Alexandre Oliva  <oliva@adacore.com>\n             Olivier Hainque  <hainque@adacore.com>\n "}, {"sha": "52dd50433d6481f15a7847f4d514dd95d5292fd0", "filename": "gcc/testsuite/gcc.c-torture/compile/pr85704.c", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5922dcb5cc82f48862cd42bd84e3c85733cac0ce/gcc%2Ftestsuite%2Fgcc.c-torture%2Fcompile%2Fpr85704.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5922dcb5cc82f48862cd42bd84e3c85733cac0ce/gcc%2Ftestsuite%2Fgcc.c-torture%2Fcompile%2Fpr85704.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.c-torture%2Fcompile%2Fpr85704.c?ref=5922dcb5cc82f48862cd42bd84e3c85733cac0ce", "patch": "@@ -0,0 +1,10 @@\n+/* PR c/85704 */\n+\n+struct C { struct {} c; };\n+struct D { int d; struct C e; int f; };\n+\n+void\n+foo (struct D *x)\n+{\n+  *x = (struct D) { .e = (struct C) { .c = {} } };\n+}"}]}