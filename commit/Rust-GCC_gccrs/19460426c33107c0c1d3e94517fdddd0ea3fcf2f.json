{"sha": "19460426c33107c0c1d3e94517fdddd0ea3fcf2f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTk0NjA0MjZjMzMxMDdjMGMxZDNlOTQ1MTdmZGRkZDBlYTNmY2YyZg==", "commit": {"author": {"name": "Doug Evans", "email": "dje@google.com", "date": "2012-05-22T17:47:49Z"}, "committer": {"name": "Doug Evans", "email": "devans@gcc.gnu.org", "date": "2012-05-22T17:47:49Z"}, "message": "* leb128.h: New file.\n\nFrom-SVN: r187780", "tree": {"sha": "a11574575d509a919863600b3be69e9eadc48b04", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a11574575d509a919863600b3be69e9eadc48b04"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/19460426c33107c0c1d3e94517fdddd0ea3fcf2f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/19460426c33107c0c1d3e94517fdddd0ea3fcf2f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/19460426c33107c0c1d3e94517fdddd0ea3fcf2f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/19460426c33107c0c1d3e94517fdddd0ea3fcf2f/comments", "author": null, "committer": null, "parents": [{"sha": "ef1f343258a2fba8b7ce3af5534787ed38d0ee3e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ef1f343258a2fba8b7ce3af5534787ed38d0ee3e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ef1f343258a2fba8b7ce3af5534787ed38d0ee3e"}], "stats": {"total": 128, "additions": 128, "deletions": 0}, "files": [{"sha": "65b34080a884908f3a622d278145a9ed49eaf788", "filename": "include/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/19460426c33107c0c1d3e94517fdddd0ea3fcf2f/include%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/19460426c33107c0c1d3e94517fdddd0ea3fcf2f/include%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/include%2FChangeLog?ref=19460426c33107c0c1d3e94517fdddd0ea3fcf2f", "patch": "@@ -1,3 +1,7 @@\n+2012-05-22  Doug Evans  <dje@google.com>\n+\n+\t* leb128.h: New file.\n+\n 2012-05-19  Gary Funck  <gary@intrepid.com>\n \n \t* dwarf2.def: Update comment re: UPC extensions to reference"}, {"sha": "f0ff3520bea0a162e03f5418e14680f4bf4878d3", "filename": "include/leb128.h", "status": "added", "additions": 124, "deletions": 0, "changes": 124, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/19460426c33107c0c1d3e94517fdddd0ea3fcf2f/include%2Fleb128.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/19460426c33107c0c1d3e94517fdddd0ea3fcf2f/include%2Fleb128.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/include%2Fleb128.h?ref=19460426c33107c0c1d3e94517fdddd0ea3fcf2f", "patch": "@@ -0,0 +1,124 @@\n+/* Utilities for reading leb128 values.\n+   Copyright (C) 2012 Free Software Foundation, Inc.\n+\n+This file is part of the libiberty library.\n+Libiberty is free software; you can redistribute it and/or\n+modify it under the terms of the GNU Library General Public\n+License as published by the Free Software Foundation; either\n+version 2 of the License, or (at your option) any later version.\n+\n+Libiberty is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+Library General Public License for more details.\n+\n+You should have received a copy of the GNU Library General Public\n+License along with libiberty; see the file COPYING.LIB.  If not, write\n+to the Free Software Foundation, Inc., 51 Franklin Street - Fifth Floor,\n+Boston, MA 02110-1301, USA.  */\n+\n+/* The functions defined here can be speed critical.\n+   Since they are all pretty small we keep things simple and just define\n+   them all as \"static inline\".  */\n+\n+#ifndef LEB128_H\n+#define LEB128_H\n+\n+/* Get a definition for inline.  */\n+#include \"ansidecl.h\"\n+\n+/* Get a definition for NULL, size_t.  */\n+#include <stddef.h>\n+\n+/* Decode the unsigned LEB128 constant at BUF into the variable pointed to\n+   by R, and return the number of bytes read.\n+   If we read off the end of the buffer, zero is returned,\n+   and nothing is stored in R.\n+\n+   Note: The result is an int instead of a pointer to the next byte to be\n+   read to avoid const-vs-non-const problems.  */\n+\n+static inline size_t\n+read_uleb128_to_ull (const unsigned char *buf, const unsigned char *buf_end,\n+\t\t     unsigned long long *r)\n+{\n+  const unsigned char *p = buf;\n+  unsigned int shift = 0;\n+  unsigned long long result = 0;\n+  unsigned char byte;\n+\n+  while (1)\n+    {\n+      if (p >= buf_end)\n+\treturn 0;\n+\n+      byte = *p++;\n+      result |= ((unsigned long long) (byte & 0x7f)) << shift;\n+      if ((byte & 0x80) == 0)\n+\tbreak;\n+      shift += 7;\n+    }\n+\n+  *r = result;\n+  return p - buf;\n+}\n+\n+/* Decode the signed LEB128 constant at BUF into the variable pointed to\n+   by R, and return the number of bytes read.\n+   If we read off the end of the buffer, zero is returned,\n+   and nothing is stored in R.\n+\n+   Note: The result is an int instead of a pointer to the next byte to be\n+   read to avoid const-vs-non-const problems.  */\n+\n+static inline size_t\n+read_sleb128_to_ll (const unsigned char *buf, const unsigned char *buf_end,\n+\t\t    long long *r)\n+{\n+  const unsigned char *p = buf;\n+  unsigned int shift = 0;\n+  long long result = 0;\n+  unsigned char byte;\n+\n+  while (1)\n+    {\n+      if (p >= buf_end)\n+\treturn 0;\n+\n+      byte = *p++;\n+      result |= ((unsigned long long) (byte & 0x7f)) << shift;\n+      shift += 7;\n+      if ((byte & 0x80) == 0)\n+\tbreak;\n+    }\n+  if (shift < (sizeof (*r) * 8) && (byte & 0x40) != 0)\n+    result |= -(((unsigned long long) 1) << shift);\n+\n+  *r = result;\n+  return p - buf;\n+}\n+\n+/* Return the number of bytes to read to skip past an LEB128 number in BUF.\n+   If the end isn't found before reaching BUF_END, return zero.\n+\n+   Note: The result is an int instead of a pointer to the next byte to be\n+   read to avoid const-vs-non-const problems.  */\n+\n+static inline size_t\n+skip_leb128 (const unsigned char *buf, const unsigned char *buf_end)\n+{\n+  const unsigned char *p = buf;\n+  unsigned char byte;\n+\n+  while (1)\n+    {\n+      if (p == buf_end)\n+\treturn 0;\n+\n+      byte = *p++;\n+      if ((byte & 0x80) == 0)\n+\treturn p - buf;\n+    }\n+}\n+\n+#endif /* LEB128_H */"}]}