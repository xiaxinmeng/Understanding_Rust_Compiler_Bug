{"sha": "46d096a3c7a69f3a8c88c88a3dcaa6925d242513", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDZkMDk2YTNjN2E2OWYzYThjODhjODhhM2RjYWE2OTI1ZDI0MjUxMw==", "commit": {"author": {"name": "Steven Bosscher", "email": "stevenb@suse.de", "date": "2005-01-05T23:19:23Z"}, "committer": {"name": "Steven Bosscher", "email": "steven@gcc.gnu.org", "date": "2005-01-05T23:19:23Z"}, "message": "combine.c (expand_compound_operation): Add comment that we fall through after case.\n\n\t* combine.c (expand_compound_operation)  <ZERO_EXTRACT>: Add\n\tcomment that we fall through after case.\n\t(mark_used_regs_combine): Don't expect a SIGN_EXTRACT in a SET_DEST.\n\t(distribute_links): Likewise.\n\t* cse.c (cse_insn): Likewise.\n\t* cselib.c (cselib_invalidate_mem): Likewise.\n\t* df.c: Update comments at the top of the file.\n\t(read_modify_subreg_p): Update comments here too.\n\t(df_def_record_1): Don't expect a SIGN_EXTRACT in a SET_DEST.\n\t* flow.c (mark_set_1): Likewise.\n\t(mark_used_regs): Likewise.\n\t* gcse.c (mems_conflict_for_gcse_p): Likewise.\n\t(canon_list_insert): Likewise.\n\t(mark_set): Likewise.\n\t(try_replace_reg): Likewise.\n\t(store_killed_in_insn): Likewise.\n\t* loop.c (count_one_set): Likewise.\n\t(basic_induction_var): Likewise.\n\t* postreload-gcse.c (find_mem_conflicts): Likewise.\n\t* postreload.c (reload_combine_note_store): Likewise.\n\t(move2add_note_store): Likewise.\n\t* reload.c (find_equiv_reg): Likewise.\n\t(mark_referenced_resources): Likewise.\n\t* rtlanal.c (set_noop_p): Likewise.\n\t(note_stores): Likewise.\n\t(note_uses): Likewise.\n\t* sched-deps.c (sched_analyze_1): Likewise.\n\t* sched-rgn.c (check_live_1): Likewise.\n\t(update_live_1): Likewise.\n\t* config/i860/i860.c: Likewise.\n\n\t* rtl.dec (SIGN_EXTRACT): Document that this cannot appear as\n\tan lvalue.\n\t(ZERO_EXTRACT): Mention that this one can be an lvalue.\n\n\t* doc/rtl.texi: Update documentation for bit-fields and SET.\n\nFrom-SVN: r92974", "tree": {"sha": "8d81e917b2a1cc0618df0ec47f5dcced22b199dc", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8d81e917b2a1cc0618df0ec47f5dcced22b199dc"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/46d096a3c7a69f3a8c88c88a3dcaa6925d242513", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/46d096a3c7a69f3a8c88c88a3dcaa6925d242513", "html_url": "https://github.com/Rust-GCC/gccrs/commit/46d096a3c7a69f3a8c88c88a3dcaa6925d242513", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/46d096a3c7a69f3a8c88c88a3dcaa6925d242513/comments", "author": null, "committer": null, "parents": [{"sha": "b95ec5c19194b9595a4209b3dc953cd7a713a484", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b95ec5c19194b9595a4209b3dc953cd7a713a484", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b95ec5c19194b9595a4209b3dc953cd7a713a484"}], "stats": {"total": 174, "additions": 104, "deletions": 70}, "files": [{"sha": "281c9dbadf57ab232e7d55ed04c1c71d98e86eaa", "filename": "gcc/ChangeLog", "status": "modified", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/46d096a3c7a69f3a8c88c88a3dcaa6925d242513/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/46d096a3c7a69f3a8c88c88a3dcaa6925d242513/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=46d096a3c7a69f3a8c88c88a3dcaa6925d242513", "patch": "@@ -1,3 +1,42 @@\n+2005-01-05  Steven Bosscher  <stevenb@suse.de>\n+\n+\t* combine.c (expand_compound_operation)  <ZERO_EXTRACT>: Add\n+\tcomment that we fall through after case.\n+\t(mark_used_regs_combine): Don't expect a SIGN_EXTRACT in a SET_DEST.\n+\t(distribute_links): Likewise.\n+\t* cse.c (cse_insn): Likewise.\n+\t* cselib.c (cselib_invalidate_mem): Likewise.\n+\t* df.c: Update comments at the top of the file.\n+\t(read_modify_subreg_p): Update comments here too.\n+\t(df_def_record_1): Don't expect a SIGN_EXTRACT in a SET_DEST.\n+\t* flow.c (mark_set_1): Likewise.\n+\t(mark_used_regs): Likewise.\n+\t* gcse.c (mems_conflict_for_gcse_p): Likewise.\n+\t(canon_list_insert): Likewise.\n+\t(mark_set): Likewise.\n+\t(try_replace_reg): Likewise.\n+\t(store_killed_in_insn): Likewise.\n+\t* loop.c (count_one_set): Likewise.\n+\t(basic_induction_var): Likewise.\n+\t* postreload-gcse.c (find_mem_conflicts): Likewise.\n+\t* postreload.c (reload_combine_note_store): Likewise.\n+\t(move2add_note_store): Likewise.\n+\t* reload.c (find_equiv_reg): Likewise.\n+\t(mark_referenced_resources): Likewise.\n+\t* rtlanal.c (set_noop_p): Likewise.\n+\t(note_stores): Likewise.\n+\t(note_uses): Likewise.\n+\t* sched-deps.c (sched_analyze_1): Likewise.\n+\t* sched-rgn.c (check_live_1): Likewise.\n+\t(update_live_1): Likewise.\n+\t* config/i860/i860.c: Likewise.\n+\n+\t* rtl.dec (SIGN_EXTRACT): Document that this cannot appear as\n+\tan lvalue.\n+\t(ZERO_EXTRACT): Mention that this one can be an lvalue.\n+\n+\t* doc/rtl.texi: Update documentation for bit-fields and SET.\n+\n 2005-01-05  Roger Sayle  <roger@eyesopen.com>\n \n \t* ifcvt.c (find_if_case_1): Revert 2005-01-04 change."}, {"sha": "a870ff3751c7f42bc0e48b333b00e17cee47b792", "filename": "gcc/combine.c", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/46d096a3c7a69f3a8c88c88a3dcaa6925d242513/gcc%2Fcombine.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/46d096a3c7a69f3a8c88c88a3dcaa6925d242513/gcc%2Fcombine.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcombine.c?ref=46d096a3c7a69f3a8c88c88a3dcaa6925d242513", "patch": "@@ -5793,6 +5793,9 @@ expand_compound_operation (rtx x)\n \n     case ZERO_EXTRACT:\n       unsignedp = 1;\n+\n+      /* ... fall through ...  */\n+\n     case SIGN_EXTRACT:\n       /* If the operand is a CLOBBER, just return it.  */\n       if (GET_CODE (XEXP (x, 0)) == CLOBBER)\n@@ -11429,7 +11432,6 @@ mark_used_regs_combine (rtx x)\n \n \twhile (GET_CODE (testreg) == SUBREG\n \t       || GET_CODE (testreg) == ZERO_EXTRACT\n-\t       || GET_CODE (testreg) == SIGN_EXTRACT\n \t       || GET_CODE (testreg) == STRICT_LOW_PART)\n \t  testreg = XEXP (testreg, 0);\n \n@@ -12302,7 +12304,6 @@ distribute_links (rtx links)\n \n       reg = SET_DEST (set);\n       while (GET_CODE (reg) == SUBREG || GET_CODE (reg) == ZERO_EXTRACT\n-\t     || GET_CODE (reg) == SIGN_EXTRACT\n \t     || GET_CODE (reg) == STRICT_LOW_PART)\n \treg = XEXP (reg, 0);\n "}, {"sha": "ed9cae6d4af9fc5b36217e9edf95c98af812d877", "filename": "gcc/config/i860/i860.c", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/46d096a3c7a69f3a8c88c88a3dcaa6925d242513/gcc%2Fconfig%2Fi860%2Fi860.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/46d096a3c7a69f3a8c88c88a3dcaa6925d242513/gcc%2Fconfig%2Fi860%2Fi860.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi860%2Fi860.c?ref=46d096a3c7a69f3a8c88c88a3dcaa6925d242513", "patch": "@@ -145,7 +145,6 @@ reg_clobbered_p (rtx reg, rtx in)\n \n       while (GET_CODE (dest) == STRICT_LOW_PART\n \t     || GET_CODE (dest) == SUBREG\n-\t     || GET_CODE (dest) == SIGN_EXTRACT\n \t     || GET_CODE (dest) == ZERO_EXTRACT)\n \tdest = XEXP (dest, 0);\n "}, {"sha": "eee27422f8c57031cbcc5db0c618c4ba6a38a630", "filename": "gcc/cse.c", "status": "modified", "additions": 7, "deletions": 11, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/46d096a3c7a69f3a8c88c88a3dcaa6925d242513/gcc%2Fcse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/46d096a3c7a69f3a8c88c88a3dcaa6925d242513/gcc%2Fcse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcse.c?ref=46d096a3c7a69f3a8c88c88a3dcaa6925d242513", "patch": "@@ -4865,17 +4865,17 @@ cse_insn (rtx insn, rtx libcall_insn)\n       else\n \tSET_SRC (sets[i].rtl) = new;\n \n-      if (GET_CODE (dest) == ZERO_EXTRACT || GET_CODE (dest) == SIGN_EXTRACT)\n+      if (GET_CODE (dest) == ZERO_EXTRACT)\n \t{\n \t  validate_change (insn, &XEXP (dest, 1),\n \t\t\t   canon_reg (XEXP (dest, 1), insn), 1);\n \t  validate_change (insn, &XEXP (dest, 2),\n \t\t\t   canon_reg (XEXP (dest, 2), insn), 1);\n \t}\n \n-      while (GET_CODE (dest) == SUBREG || GET_CODE (dest) == STRICT_LOW_PART\n+      while (GET_CODE (dest) == SUBREG\n \t     || GET_CODE (dest) == ZERO_EXTRACT\n-\t     || GET_CODE (dest) == SIGN_EXTRACT)\n+\t     || GET_CODE (dest) == STRICT_LOW_PART)\n \tdest = XEXP (dest, 0);\n \n       if (MEM_P (dest))\n@@ -4972,8 +4972,7 @@ cse_insn (rtx insn, rtx libcall_insn)\n \t causes later instructions to be mis-optimized.  */\n       /* If storing a constant in a bitfield, pre-truncate the constant\n \t so we will be able to record it later.  */\n-      if (GET_CODE (SET_DEST (sets[i].rtl)) == ZERO_EXTRACT\n-\t  || GET_CODE (SET_DEST (sets[i].rtl)) == SIGN_EXTRACT)\n+      if (GET_CODE (SET_DEST (sets[i].rtl)) == ZERO_EXTRACT)\n \t{\n \t  rtx width = XEXP (SET_DEST (sets[i].rtl), 1);\n \n@@ -5629,11 +5628,9 @@ cse_insn (rtx insn, rtx libcall_insn)\n       /* Now deal with the destination.  */\n       do_not_record = 0;\n \n-      /* Look within any SIGN_EXTRACT or ZERO_EXTRACT\n-\t to the MEM or REG within it.  */\n-      while (GET_CODE (dest) == SIGN_EXTRACT\n+      /* Look within any ZERO_EXTRACT to the MEM or REG within it.  */\n+      while (GET_CODE (dest) == SUBREG\n \t     || GET_CODE (dest) == ZERO_EXTRACT\n-\t     || GET_CODE (dest) == SUBREG\n \t     || GET_CODE (dest) == STRICT_LOW_PART)\n \tdest = XEXP (dest, 0);\n \n@@ -5661,8 +5658,7 @@ cse_insn (rtx insn, rtx libcall_insn)\n \t because the value in it after the store\n \t may not equal what was stored, due to truncation.  */\n \n-      if (GET_CODE (SET_DEST (sets[i].rtl)) == ZERO_EXTRACT\n-\t  || GET_CODE (SET_DEST (sets[i].rtl)) == SIGN_EXTRACT)\n+      if (GET_CODE (SET_DEST (sets[i].rtl)) == ZERO_EXTRACT)\n \t{\n \t  rtx width = XEXP (SET_DEST (sets[i].rtl), 1);\n "}, {"sha": "13c3a1f421ef2a858dcf0c07ca892121a37180be", "filename": "gcc/cselib.c", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/46d096a3c7a69f3a8c88c88a3dcaa6925d242513/gcc%2Fcselib.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/46d096a3c7a69f3a8c88c88a3dcaa6925d242513/gcc%2Fcselib.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcselib.c?ref=46d096a3c7a69f3a8c88c88a3dcaa6925d242513", "patch": "@@ -1148,8 +1148,9 @@ cselib_invalidate_mem (rtx mem_rtx)\n void\n cselib_invalidate_rtx (rtx dest)\n {\n-  while (GET_CODE (dest) == STRICT_LOW_PART || GET_CODE (dest) == SIGN_EXTRACT\n-\t || GET_CODE (dest) == ZERO_EXTRACT || GET_CODE (dest) == SUBREG)\n+  while (GET_CODE (dest) == SUBREG\n+\t || GET_CODE (dest) == ZERO_EXTRACT\n+\t || GET_CODE (dest) == STRICT_LOW_PART)\n     dest = XEXP (dest, 0);\n \n   if (REG_P (dest))"}, {"sha": "81ba0ea0932806b4842fadf194e9146889f95644", "filename": "gcc/df.c", "status": "modified", "additions": 13, "deletions": 10, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/46d096a3c7a69f3a8c88c88a3dcaa6925d242513/gcc%2Fdf.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/46d096a3c7a69f3a8c88c88a3dcaa6925d242513/gcc%2Fdf.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdf.c?ref=46d096a3c7a69f3a8c88c88a3dcaa6925d242513", "patch": "@@ -107,8 +107,8 @@ These are linked into a variety of lists; namely reg-def, reg-use,\n the reg-def lists contain all the refs that define a given register\n while the insn-use lists contain all the refs used by an insn.\n \n-Note that the reg-def and reg-use chains are generally short (except for the\n-hard registers) and thus it is much faster to search these chains\n+Note that the reg-def and reg-use chains are generally short (except for\n+the hard registers) and thus it is much faster to search these chains\n rather than searching the def or use bitmaps.\n \n If the insns are in SSA form then the reg-def and use-def lists\n@@ -166,10 +166,13 @@ generates a use of reg 41 then a def of reg 41 (both marked read/write),\n even though reg 41 is decremented before it is used for the memory\n address in this second example.\n \n-A set to a REG inside a ZERO_EXTRACT, SIGN_EXTRACT, or SUBREG invokes\n-a read-modify write operation.  We generate both a use and a def\n-and again mark them read/write.\n-*/\n+A set to a REG inside a ZERO_EXTRACT, or a set to a non-paradoxical SUBREG\n+for which the number of word_mode units covered by the outer mode is\n+smaller than that covered by the inner mode, invokes a read-modify-write.\n+operation.  We generate both a use and a def and again mark them\n+read/write.\n+Paradoxical subreg writes don't leave a trace of the old content, so they\n+are write-only operations.  */\n \n #include \"config.h\"\n #include \"system.h\"\n@@ -858,8 +861,10 @@ df_ref_record (struct df *df, rtx reg, rtx *loc, rtx insn,\n }\n \n \n-/* Return nonzero if writes to paradoxical SUBREGs, or SUBREGs which\n-   are too narrow, are read-modify-write.  */\n+/* A set to a non-paradoxical SUBREG for which the number of word_mode units\n+   covered by the outer mode is smaller than that covered by the inner mode,\n+   is a read-modify-write operation.\n+   This function returns true iff the SUBREG X is such a SUBREG.  */\n bool\n read_modify_subreg_p (rtx x)\n {\n@@ -868,7 +873,6 @@ read_modify_subreg_p (rtx x)\n     return false;\n   isize = GET_MODE_SIZE (GET_MODE (SUBREG_REG (x)));\n   osize = GET_MODE_SIZE (GET_MODE (x));\n-  /* Paradoxical subreg writes don't leave a trace of the old content.  */\n   return (isize > osize && isize > UNITS_PER_WORD);\n }\n \n@@ -909,7 +913,6 @@ df_def_record_1 (struct df *df, rtx x, basic_block bb, rtx insn)\n      be handy for the reg allocator.  */\n   while (GET_CODE (dst) == STRICT_LOW_PART\n \t || GET_CODE (dst) == ZERO_EXTRACT\n-\t || GET_CODE (dst) == SIGN_EXTRACT\n \t || ((df->flags & DF_FOR_REGALLOC) == 0\n              && read_modify_subreg_p (dst)))\n     {"}, {"sha": "606851624321d3a49469c7562e5cd6e7239cf48b", "filename": "gcc/doc/rtl.texi", "status": "modified", "additions": 16, "deletions": 7, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/46d096a3c7a69f3a8c88c88a3dcaa6925d242513/gcc%2Fdoc%2Frtl.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/46d096a3c7a69f3a8c88c88a3dcaa6925d242513/gcc%2Fdoc%2Frtl.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Frtl.texi?ref=46d096a3c7a69f3a8c88c88a3dcaa6925d242513", "patch": "@@ -2132,9 +2132,6 @@ for insn attributes.  @xref{Insn Attributes}.\n @cindex bit-fields\n \n Special expression codes exist to represent bit-field instructions.\n-These types of expressions are lvalues in RTL; they may appear\n-on the left side of an assignment, indicating insertion of a value\n-into the specified bit-field.\n \n @table @code\n @findex sign_extract\n@@ -2158,11 +2155,18 @@ in the @code{insv} or @code{extv} pattern.\n The mode @var{m} is the same as the mode that would be used for\n @var{loc} if it were a register.\n \n+A @code{sign_extract} can not appear as an lvalue, or part thereof,\n+in RTL.\n+\n @findex zero_extract\n @item (zero_extract:@var{m} @var{loc} @var{size} @var{pos})\n Like @code{sign_extract} but refers to an unsigned or zero-extended\n bit-field.  The same sequence of bits are extracted, but they\n are filled to an entire word with zeros instead of by sign-extension.\n+\n+Unlike @code{sign_extract}, this type of expressions can be lvalues\n+in RTL; they may appear on the left side of an assignment, indicating\n+insertion of a value into the specified bit-field.\n @end table\n \n @node Vector Operations\n@@ -2365,10 +2369,15 @@ rest of the register receives an undefined value.  Likewise, if\n the mode of the register, the rest of the register can be changed in\n an undefined way.\n \n-If @var{lval} is a @code{strict_low_part} or @code{zero_extract}\n-of a @code{subreg}, then the part of the register specified by the\n-machine mode of the @code{subreg} is given the value @var{x} and\n-the rest of the register is not changed.\n+If @var{lval} is a @code{strict_low_part} of a subreg, then the part\n+of the register specified by the machine mode of the @code{subreg} is\n+given the value @var{x} and the rest of the register is not changed.\n+\n+If @var{lval} is a @code{zero_extract}, then the referenced part of\n+the bit-field (a memory or register reference) specified by the\n+@code{zero_extract} is given the value @var{x} and the rest of the\n+bit-field is not changed.  Note that @code{sign_extract} can not\n+appear in @var{lval}.\n \n If @var{lval} is @code{(cc0)}, it has no machine mode, and @var{x} may\n be either a @code{compare} expression or a value that may have any mode."}, {"sha": "e3d10a13814df541ce78d413d0f3a6431e536a5e", "filename": "gcc/flow.c", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/46d096a3c7a69f3a8c88c88a3dcaa6925d242513/gcc%2Fflow.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/46d096a3c7a69f3a8c88c88a3dcaa6925d242513/gcc%2Fflow.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fflow.c?ref=46d096a3c7a69f3a8c88c88a3dcaa6925d242513", "patch": "@@ -2554,15 +2554,17 @@ mark_set_1 (struct propagate_block_info *pbi, enum rtx_code code, rtx reg, rtx c\n \t\t      flags);\n       return;\n \n-    case ZERO_EXTRACT:\n     case SIGN_EXTRACT:\n+      /* SIGN_EXTRACT cannot be an lvalue.  */\n+      gcc_unreachable ();\n+\n+    case ZERO_EXTRACT:\n     case STRICT_LOW_PART:\n       /* ??? Assumes STRICT_LOW_PART not used on multi-word registers.  */\n       do\n \treg = XEXP (reg, 0);\n       while (GET_CODE (reg) == SUBREG\n \t     || GET_CODE (reg) == ZERO_EXTRACT\n-\t     || GET_CODE (reg) == SIGN_EXTRACT\n \t     || GET_CODE (reg) == STRICT_LOW_PART);\n       if (MEM_P (reg))\n \tbreak;\n@@ -3844,7 +3846,6 @@ mark_used_regs (struct propagate_block_info *pbi, rtx x, rtx cond, rtx insn)\n \t   then this SET is not needed.  */\n \twhile (GET_CODE (testreg) == STRICT_LOW_PART\n \t       || GET_CODE (testreg) == ZERO_EXTRACT\n-\t       || GET_CODE (testreg) == SIGN_EXTRACT\n \t       || GET_CODE (testreg) == SUBREG)\n \t  {\n #ifdef CANNOT_CHANGE_MODE_CLASS"}, {"sha": "67f8053e9c811167dc487ff3daf58cc121bff0c6", "filename": "gcc/gcse.c", "status": "modified", "additions": 2, "deletions": 7, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/46d096a3c7a69f3a8c88c88a3dcaa6925d242513/gcc%2Fgcse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/46d096a3c7a69f3a8c88c88a3dcaa6925d242513/gcc%2Fgcse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgcse.c?ref=46d096a3c7a69f3a8c88c88a3dcaa6925d242513", "patch": "@@ -1366,7 +1366,6 @@ mems_conflict_for_gcse_p (rtx dest, rtx setter ATTRIBUTE_UNUSED,\n {\n   while (GET_CODE (dest) == SUBREG\n \t || GET_CODE (dest) == ZERO_EXTRACT\n-\t || GET_CODE (dest) == SIGN_EXTRACT\n \t || GET_CODE (dest) == STRICT_LOW_PART)\n     dest = XEXP (dest, 0);\n \n@@ -2002,7 +2001,6 @@ canon_list_insert (rtx dest ATTRIBUTE_UNUSED, rtx unused1 ATTRIBUTE_UNUSED,\n \n   while (GET_CODE (dest) == SUBREG\n       || GET_CODE (dest) == ZERO_EXTRACT\n-      || GET_CODE (dest) == SIGN_EXTRACT\n       || GET_CODE (dest) == STRICT_LOW_PART)\n     dest = XEXP (dest, 0);\n \n@@ -2390,7 +2388,6 @@ mark_set (rtx pat, rtx insn)\n \n   while (GET_CODE (dest) == SUBREG\n \t || GET_CODE (dest) == ZERO_EXTRACT\n-\t || GET_CODE (dest) == SIGN_EXTRACT\n \t || GET_CODE (dest) == STRICT_LOW_PART)\n     dest = XEXP (dest, 0);\n \n@@ -2739,8 +2736,7 @@ try_replace_reg (rtx from, rtx to, rtx insn)\n \t have a note, and have no special SET, add a REG_EQUAL note to not\n \t lose information.  */\n       if (!success && note == 0 && set != 0\n-\t  && GET_CODE (XEXP (set, 0)) != ZERO_EXTRACT\n-\t  && GET_CODE (XEXP (set, 0)) != SIGN_EXTRACT)\n+\t  && GET_CODE (SET_DEST (set)) != ZERO_EXTRACT)\n \tnote = set_unique_reg_note (insn, REG_EQUAL, copy_rtx (src));\n     }\n \n@@ -5960,8 +5956,7 @@ store_killed_in_insn (rtx x, rtx x_regs, rtx insn, int after)\n       rtx pat = PATTERN (insn);\n       rtx dest = SET_DEST (pat);\n \n-      if (GET_CODE (dest) == SIGN_EXTRACT\n-\t  || GET_CODE (dest) == ZERO_EXTRACT)\n+      if (GET_CODE (dest) == ZERO_EXTRACT)\n \tdest = XEXP (dest, 0);\n \n       /* Check for memory stores to aliased objects.  */"}, {"sha": "3fa0f48a77824eba0c4412f16c67a19bf6352ab4", "filename": "gcc/loop.c", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/46d096a3c7a69f3a8c88c88a3dcaa6925d242513/gcc%2Floop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/46d096a3c7a69f3a8c88c88a3dcaa6925d242513/gcc%2Floop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Floop.c?ref=46d096a3c7a69f3a8c88c88a3dcaa6925d242513", "patch": "@@ -3849,7 +3849,6 @@ count_one_set (struct loop_regs *regs, rtx insn, rtx x, rtx *last_set)\n       rtx dest = SET_DEST (x);\n       while (GET_CODE (dest) == SUBREG\n \t     || GET_CODE (dest) == ZERO_EXTRACT\n-\t     || GET_CODE (dest) == SIGN_EXTRACT\n \t     || GET_CODE (dest) == STRICT_LOW_PART)\n \tdest = XEXP (dest, 0);\n       if (REG_P (dest))\n@@ -7595,9 +7594,8 @@ basic_induction_var (const struct loop *loop, rtx x, enum machine_mode mode,\n \t\t\t\t\tdest_reg, insn,\n \t\t\t\t\tinc_val, mult_val, location);\n \n-\t  while (GET_CODE (dest) == SIGN_EXTRACT\n+\t  while (GET_CODE (dest) == SUBREG\n \t\t || GET_CODE (dest) == ZERO_EXTRACT\n-\t\t || GET_CODE (dest) == SUBREG\n \t\t || GET_CODE (dest) == STRICT_LOW_PART)\n \t    dest = XEXP (dest, 0);\n \t  if (dest == x)"}, {"sha": "70e60452fd09422a0c70ec5c9780b2bac2f1b56a", "filename": "gcc/postreload-gcse.c", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/46d096a3c7a69f3a8c88c88a3dcaa6925d242513/gcc%2Fpostreload-gcse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/46d096a3c7a69f3a8c88c88a3dcaa6925d242513/gcc%2Fpostreload-gcse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpostreload-gcse.c?ref=46d096a3c7a69f3a8c88c88a3dcaa6925d242513", "patch": "@@ -570,7 +570,6 @@ find_mem_conflicts (rtx dest, rtx setter ATTRIBUTE_UNUSED,\n \n   while (GET_CODE (dest) == SUBREG\n \t || GET_CODE (dest) == ZERO_EXTRACT\n-\t || GET_CODE (dest) == SIGN_EXTRACT\n \t || GET_CODE (dest) == STRICT_LOW_PART)\n     dest = XEXP (dest, 0);\n "}, {"sha": "06714b90ab8b288d110d54fee9f6f8c2978b16e0", "filename": "gcc/postreload.c", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/46d096a3c7a69f3a8c88c88a3dcaa6925d242513/gcc%2Fpostreload.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/46d096a3c7a69f3a8c88c88a3dcaa6925d242513/gcc%2Fpostreload.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpostreload.c?ref=46d096a3c7a69f3a8c88c88a3dcaa6925d242513", "patch": "@@ -1005,11 +1005,9 @@ reload_combine_note_store (rtx dst, rtx set, void *data ATTRIBUTE_UNUSED)\n \n   /* note_stores might have stripped a STRICT_LOW_PART, so we have to be\n      careful with registers / register parts that are not full words.\n-\n-     Similarly for ZERO_EXTRACT and SIGN_EXTRACT.  */\n+     Similarly for ZERO_EXTRACT.  */\n   if (GET_CODE (set) != SET\n       || GET_CODE (SET_DEST (set)) == ZERO_EXTRACT\n-      || GET_CODE (SET_DEST (set)) == SIGN_EXTRACT\n       || GET_CODE (SET_DEST (set)) == STRICT_LOW_PART)\n     {\n       for (i = hard_regno_nregs[regno][mode] - 1 + regno; i >= regno; i--)\n@@ -1462,7 +1460,6 @@ move2add_note_store (rtx dst, rtx set, void *data ATTRIBUTE_UNUSED)\n   if (SCALAR_INT_MODE_P (mode)\n       && hard_regno_nregs[regno][mode] == 1 && GET_CODE (set) == SET\n       && GET_CODE (SET_DEST (set)) != ZERO_EXTRACT\n-      && GET_CODE (SET_DEST (set)) != SIGN_EXTRACT\n       && GET_CODE (SET_DEST (set)) != STRICT_LOW_PART)\n     {\n       rtx src = SET_SRC (set);"}, {"sha": "2bb2fb96a9558b4f6374f647825054990d8880a4", "filename": "gcc/reload.c", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/46d096a3c7a69f3a8c88c88a3dcaa6925d242513/gcc%2Freload.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/46d096a3c7a69f3a8c88c88a3dcaa6925d242513/gcc%2Freload.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freload.c?ref=46d096a3c7a69f3a8c88c88a3dcaa6925d242513", "patch": "@@ -6734,7 +6734,6 @@ find_equiv_reg (rtx goal, rtx insn, enum reg_class class, int other,\n \t      rtx dest = SET_DEST (pat);\n \t      while (GET_CODE (dest) == SUBREG\n \t\t     || GET_CODE (dest) == ZERO_EXTRACT\n-\t\t     || GET_CODE (dest) == SIGN_EXTRACT\n \t\t     || GET_CODE (dest) == STRICT_LOW_PART)\n \t\tdest = XEXP (dest, 0);\n \t      if (REG_P (dest))\n@@ -6778,7 +6777,6 @@ find_equiv_reg (rtx goal, rtx insn, enum reg_class class, int other,\n \t\t      rtx dest = SET_DEST (v1);\n \t\t      while (GET_CODE (dest) == SUBREG\n \t\t\t     || GET_CODE (dest) == ZERO_EXTRACT\n-\t\t\t     || GET_CODE (dest) == SIGN_EXTRACT\n \t\t\t     || GET_CODE (dest) == STRICT_LOW_PART)\n \t\t\tdest = XEXP (dest, 0);\n \t\t      if (REG_P (dest))"}, {"sha": "aa419ceac9ceb4f64065aac24e3456de37eaf138", "filename": "gcc/resource.c", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/46d096a3c7a69f3a8c88c88a3dcaa6925d242513/gcc%2Fresource.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/46d096a3c7a69f3a8c88c88a3dcaa6925d242513/gcc%2Fresource.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fresource.c?ref=46d096a3c7a69f3a8c88c88a3dcaa6925d242513", "patch": "@@ -299,13 +299,12 @@ mark_referenced_resources (rtx x, struct resources *res,\n     case SET:\n       /* Usually, the first operand of SET is set, not referenced.  But\n \t registers used to access memory are referenced.  SET_DEST is\n-\t also referenced if it is a ZERO_EXTRACT or SIGN_EXTRACT.  */\n+\t also referenced if it is a ZERO_EXTRACT.  */\n \n       mark_referenced_resources (SET_SRC (x), res, 0);\n \n       x = SET_DEST (x);\n-      if (GET_CODE (x) == SIGN_EXTRACT\n-\t  || GET_CODE (x) == ZERO_EXTRACT\n+      if (GET_CODE (x) == ZERO_EXTRACT\n \t  || GET_CODE (x) == STRICT_LOW_PART)\n \tmark_referenced_resources (x, res, 0);\n       else if (GET_CODE (x) == SUBREG)"}, {"sha": "7bee09b1c6ddfd1df97610e5135fc11ac76b5a81", "filename": "gcc/rtl.def", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/46d096a3c7a69f3a8c88c88a3dcaa6925d242513/gcc%2Frtl.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/46d096a3c7a69f3a8c88c88a3dcaa6925d242513/gcc%2Frtl.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtl.def?ref=46d096a3c7a69f3a8c88c88a3dcaa6925d242513", "patch": "@@ -587,10 +587,12 @@ DEF_RTL_EXPR(PARITY, \"parity\", \"e\", RTX_UNARY)\n    If BITS_BIG_ENDIAN is defined, the first bit is the msb and\n    operand 2 counts from the msb of the memory unit.\n    Otherwise, the first bit is the lsb and operand 2 counts from\n-   the lsb of the memory unit.  */\n+   the lsb of the memory unit.\n+   This kind of expression can not appear as an lvalue in RTL.  */\n DEF_RTL_EXPR(SIGN_EXTRACT, \"sign_extract\", \"eee\", RTX_BITFIELD_OPS)\n \n-/* Similar for unsigned bit-field.  */\n+/* Similar for unsigned bit-field.\n+   But note!  This kind of expression _can_ appear as an lvalue.  */\n DEF_RTL_EXPR(ZERO_EXTRACT, \"zero_extract\", \"eee\", RTX_BITFIELD_OPS)\n \n /* For RISC machines.  These save memory when splitting insns.  */"}, {"sha": "98a284324e41509f6b0d0c5015fca2b935f5176d", "filename": "gcc/rtlanal.c", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/46d096a3c7a69f3a8c88c88a3dcaa6925d242513/gcc%2Frtlanal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/46d096a3c7a69f3a8c88c88a3dcaa6925d242513/gcc%2Frtlanal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtlanal.c?ref=46d096a3c7a69f3a8c88c88a3dcaa6925d242513", "patch": "@@ -1075,8 +1075,7 @@ set_noop_p (rtx set)\n   if (MEM_P (dst) && MEM_P (src))\n     return rtx_equal_p (dst, src) && !side_effects_p (dst);\n \n-  if (GET_CODE (dst) == SIGN_EXTRACT\n-      || GET_CODE (dst) == ZERO_EXTRACT)\n+  if (GET_CODE (dst) == ZERO_EXTRACT)\n     return rtx_equal_p (XEXP (dst, 0), src)\n \t   && ! BYTES_BIG_ENDIAN && XEXP (dst, 2) == const0_rtx\n \t   && !side_effects_p (src);\n@@ -1405,7 +1404,6 @@ note_stores (rtx x, void (*fun) (rtx, rtx, void *), void *data)\n \t      && (!REG_P (SUBREG_REG (dest))\n \t\t  || REGNO (SUBREG_REG (dest)) >= FIRST_PSEUDO_REGISTER))\n \t     || GET_CODE (dest) == ZERO_EXTRACT\n-\t     || GET_CODE (dest) == SIGN_EXTRACT\n \t     || GET_CODE (dest) == STRICT_LOW_PART)\n \tdest = XEXP (dest, 0);\n \n@@ -1514,8 +1512,8 @@ note_uses (rtx *pbody, void (*fun) (rtx *, void *), void *data)\n    This will be true if X is (cc0) or if X is a register and\n    X dies in INSN or because INSN entirely sets X.\n \n-   \"Entirely set\" means set directly and not through a SUBREG,\n-   ZERO_EXTRACT or SIGN_EXTRACT, so no trace of the old contents remains.\n+   \"Entirely set\" means set directly and not through a SUBREG, or\n+   ZERO_EXTRACT, so no trace of the old contents remains.\n    Likewise, REG_INC does not count.\n \n    REG may be a hard or pseudo reg.  Renumbering is not taken into account,"}, {"sha": "52f6e5b1746c5184f7ae94f0e294f7ea74c5f9ed", "filename": "gcc/sched-deps.c", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/46d096a3c7a69f3a8c88c88a3dcaa6925d242513/gcc%2Fsched-deps.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/46d096a3c7a69f3a8c88c88a3dcaa6925d242513/gcc%2Fsched-deps.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsched-deps.c?ref=46d096a3c7a69f3a8c88c88a3dcaa6925d242513", "patch": "@@ -507,11 +507,10 @@ sched_analyze_1 (struct deps *deps, rtx x, rtx insn)\n     }\n \n   while (GET_CODE (dest) == STRICT_LOW_PART || GET_CODE (dest) == SUBREG\n-\t || GET_CODE (dest) == ZERO_EXTRACT || GET_CODE (dest) == SIGN_EXTRACT)\n+\t || GET_CODE (dest) == ZERO_EXTRACT)\n     {\n       if (GET_CODE (dest) == STRICT_LOW_PART\n \t || GET_CODE (dest) == ZERO_EXTRACT\n-\t || GET_CODE (dest) == SIGN_EXTRACT\n \t || read_modify_subreg_p (dest))\n         {\n \t  /* These both read and modify the result.  We must handle\n@@ -522,7 +521,7 @@ sched_analyze_1 (struct deps *deps, rtx x, rtx insn)\n \n \t  sched_analyze_2 (deps, XEXP (dest, 0), insn);\n \t}\n-      if (GET_CODE (dest) == ZERO_EXTRACT || GET_CODE (dest) == SIGN_EXTRACT)\n+      if (GET_CODE (dest) == ZERO_EXTRACT)\n \t{\n \t  /* The second and third arguments are values read by this insn.  */\n \t  sched_analyze_2 (deps, XEXP (dest, 1), insn);"}, {"sha": "2aba7f3b1c1882e88fed179fdcb3fb36a1b517e9", "filename": "gcc/sched-rgn.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/46d096a3c7a69f3a8c88c88a3dcaa6925d242513/gcc%2Fsched-rgn.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/46d096a3c7a69f3a8c88c88a3dcaa6925d242513/gcc%2Fsched-rgn.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsched-rgn.c?ref=46d096a3c7a69f3a8c88c88a3dcaa6925d242513", "patch": "@@ -1146,8 +1146,8 @@ check_live_1 (int src, rtx x)\n   if (reg == 0)\n     return 1;\n \n-  while (GET_CODE (reg) == SUBREG || GET_CODE (reg) == ZERO_EXTRACT\n-\t || GET_CODE (reg) == SIGN_EXTRACT\n+  while (GET_CODE (reg) == SUBREG\n+\t || GET_CODE (reg) == ZERO_EXTRACT\n \t || GET_CODE (reg) == STRICT_LOW_PART)\n     reg = XEXP (reg, 0);\n \n@@ -1223,8 +1223,8 @@ update_live_1 (int src, rtx x)\n   if (reg == 0)\n     return;\n \n-  while (GET_CODE (reg) == SUBREG || GET_CODE (reg) == ZERO_EXTRACT\n-\t || GET_CODE (reg) == SIGN_EXTRACT\n+  while (GET_CODE (reg) == SUBREG\n+\t || GET_CODE (reg) == ZERO_EXTRACT\n \t || GET_CODE (reg) == STRICT_LOW_PART)\n     reg = XEXP (reg, 0);\n "}]}