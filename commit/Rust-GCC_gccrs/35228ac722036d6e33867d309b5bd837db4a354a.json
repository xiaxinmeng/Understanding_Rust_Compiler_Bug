{"sha": "35228ac722036d6e33867d309b5bd837db4a354a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzUyMjhhYzcyMjAzNmQ2ZTMzODY3ZDMwOWI1YmQ4MzdkYjRhMzU0YQ==", "commit": {"author": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2015-01-15T22:58:42Z"}, "committer": {"name": "Jakub Jelinek", "email": "jakub@gcc.gnu.org", "date": "2015-01-15T22:58:42Z"}, "message": "flag-types.h (enum sanitize_code): Add SANITIZE_VPTR, include SANITIZE_VPTR in SANITIZE_UNDEFINED.\n\n\t* flag-types.h (enum sanitize_code): Add SANITIZE_VPTR,\n\tinclude SANITIZE_VPTR in SANITIZE_UNDEFINED.\n\t* opts.c (common_handle_option): Add -fsanitize=vptr.\n\t* sanitizer.def (BUILT_IN_UBSAN_HANDLE_DYNAMIC_TYPE_CACHE_MISS,\n\tBUILT_IN_UBSAN_HANDLE_DYNAMIC_TYPE_CACHE_MISS_ABORT): New.\n\t* ubsan.h (enum ubsan_null_ckind): Add UBSAN_DOWNCAST_POINTER,\n\tUBSAN_DOWNCAST_REFERENCE, UBSAN_UPCAST and UBSAN_CAST_TO_VBASE.\n\t(ubsan_expand_vptr_ifn): New prototype.\n\t* internal-fn.c (expand_ANNOTATE, expand_GOMP_SIMD_LANE,\n\texpand_GOMP_SIMD_VF, expand_GOMP_SIMD_LAST_LANE, expand_UBSAN_NULL,\n\texpand_UBSAN_BOUNDS, expand_UBSAN_OBJECT_SIZE, expand_ASAN_CHECK,\n\texpand_LOOP_VECTORIZED): Make argument nameless, remove\n\tATTRIBUTE_UNUSED.\n\t(expand_UBSAN_VPTR): New function.\n\t* internal-fn.def (UBSAN_NULL, ASAN_CHECK): Use R instead of W\n\tin fn spec.\n\t(UBSAN_VPTR): New internal function.\n\t* sanopt.c (tree_map_traits): Renamed to ...\n\t(sanopt_tree_map_traits): ... this.\n\t(sanopt_tree_triplet, sanopt_tree_triplet_map_traits): New classes.\n\t(sanopt_ctx): Adjust asan_check_map type for tree_map_traits\n\tto sanopt_tree_map_traits renaming.  Add vptr_check_map field.\n\t(maybe_optimize_ubsan_vptr_ifn): New function.\n\t(sanopt_optimize_walker): Handle IFN_UBSAN_VPTR.\n\t(pass_sanopt::execute): Likewise.  Call sanopt_optimize even for\n\t-fsanitize=vptr.\n\t* tree-ssa-alias.c (call_may_clobber_ref_p_1): Handle certain\n\tinternal calls like pure functions for aliasing, even when they\n\thave other side-effects that prevent making them ECF_PURE.\n\t* ubsan.c (ubsan_vptr_type_cache_decl): New variable.\n\t(ubsan_expand_vptr_ifn): New function.\ncp/\n\t* cp-gimplify.c (cp_genericize_r): Call\n\tcp_ubsan_maybe_instrument_member_call for member calls.\n\t(cp_ubsan_check_member_access_r): New function.\n\t(cp_genericize_tree): Call cp_ubsan_instrument_member_accesses.\n\t* cp-tree.h (cp_ubsan_maybe_instrument_member_call,\n\tcp_ubsan_instrument_member_accesses,\n\tcp_ubsan_maybe_instrument_downcast,\n\tcp_ubsan_maybe_instrument_cast_to_vbase): New prototypes.\n\t* cp-ubsan.c: New file.\n\t* Make-lang.in (CXX_AND_OBJCXX_OBJS): Add cp/cp-ubsan.o.\n\t* constexpr.c (cxx_eval_call_expression): Return void_node\n\tfor IFN_UBSAN_VPTR.\n\t(potential_constant_expression_1): Return true for\n\tUBSAN_NULL, UBSAN_BOUNDS and UBSAN_VPTR internal calls.\n\t* typeck.c (build_class_member_access_expr): Provide locus\n\tfor COMPONENT_REFs.\n\t(build_static_cast_1): Instrument downcasts.\n\t* class.c (build_base_path): For -fsanitize=vptr and !fixed_type_p\n\tadd ubsan instrumentation for virtual_access.\n\t* call.c: Include internal-fn.h.\n\t(set_flags_from_callee): Handle internal calls.\ngcc/testsuite/\n\t* g++.dg/ubsan/vptr-1.C: New test.\n\t* g++.dg/ubsan/vptr-2.C: New test.\n\t* g++.dg/ubsan/vptr-3.C: New test.\n\t* g++.dg/ubsan/vptr-4.C: New test.\n\t* g++.dg/ubsan/vptr-5.C: New test.\n\t* g++.dg/ubsan/vptr-6.C: New test.\n\t* g++.dg/ubsan/vptr-7.C: New test.\n\t* g++.dg/ubsan/vptr-8.C: New test.\n\t* g++.dg/ubsan/vptr-9.C: New test.\n\nFrom-SVN: r219695", "tree": {"sha": "87841bfb25f6c201d9024ec907daaa179efe5b14", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/87841bfb25f6c201d9024ec907daaa179efe5b14"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/35228ac722036d6e33867d309b5bd837db4a354a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/35228ac722036d6e33867d309b5bd837db4a354a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/35228ac722036d6e33867d309b5bd837db4a354a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/35228ac722036d6e33867d309b5bd837db4a354a/comments", "author": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "9f584046ad9379face5af75f4c16938ee1aabfc6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9f584046ad9379face5af75f4c16938ee1aabfc6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9f584046ad9379face5af75f4c16938ee1aabfc6"}], "stats": {"total": 1543, "additions": 1511, "deletions": 32}, "files": [{"sha": "087bcd59f87247d65b41f97bec9cda601b216c2c", "filename": "gcc/ChangeLog", "status": "modified", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/35228ac722036d6e33867d309b5bd837db4a354a/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/35228ac722036d6e33867d309b5bd837db4a354a/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=35228ac722036d6e33867d309b5bd837db4a354a", "patch": "@@ -1,3 +1,37 @@\n+2015-01-15  Jakub Jelinek  <jakub@redhat.com>\n+\n+\t* flag-types.h (enum sanitize_code): Add SANITIZE_VPTR,\n+\tinclude SANITIZE_VPTR in SANITIZE_UNDEFINED.\n+\t* opts.c (common_handle_option): Add -fsanitize=vptr.\n+\t* sanitizer.def (BUILT_IN_UBSAN_HANDLE_DYNAMIC_TYPE_CACHE_MISS,\n+\tBUILT_IN_UBSAN_HANDLE_DYNAMIC_TYPE_CACHE_MISS_ABORT): New.\n+\t* ubsan.h (enum ubsan_null_ckind): Add UBSAN_DOWNCAST_POINTER,\n+\tUBSAN_DOWNCAST_REFERENCE, UBSAN_UPCAST and UBSAN_CAST_TO_VBASE.\n+\t(ubsan_expand_vptr_ifn): New prototype.\n+\t* internal-fn.c (expand_ANNOTATE, expand_GOMP_SIMD_LANE,\n+\texpand_GOMP_SIMD_VF, expand_GOMP_SIMD_LAST_LANE, expand_UBSAN_NULL,\n+\texpand_UBSAN_BOUNDS, expand_UBSAN_OBJECT_SIZE, expand_ASAN_CHECK,\n+\texpand_LOOP_VECTORIZED): Make argument nameless, remove\n+\tATTRIBUTE_UNUSED.\n+\t(expand_UBSAN_VPTR): New function.\n+\t* internal-fn.def (UBSAN_NULL, ASAN_CHECK): Use R instead of W\n+\tin fn spec.\n+\t(UBSAN_VPTR): New internal function.\n+\t* sanopt.c (tree_map_traits): Renamed to ...\n+\t(sanopt_tree_map_traits): ... this.\n+\t(sanopt_tree_triplet, sanopt_tree_triplet_map_traits): New classes.\n+\t(sanopt_ctx): Adjust asan_check_map type for tree_map_traits\n+\tto sanopt_tree_map_traits renaming.  Add vptr_check_map field.\n+\t(maybe_optimize_ubsan_vptr_ifn): New function.\n+\t(sanopt_optimize_walker): Handle IFN_UBSAN_VPTR.\n+\t(pass_sanopt::execute): Likewise.  Call sanopt_optimize even for\n+\t-fsanitize=vptr.\n+\t* tree-ssa-alias.c (call_may_clobber_ref_p_1): Handle certain\n+\tinternal calls like pure functions for aliasing, even when they\n+\thave other side-effects that prevent making them ECF_PURE.\n+\t* ubsan.c (ubsan_vptr_type_cache_decl): New variable.\n+\t(ubsan_expand_vptr_ifn): New function.\n+\n 2015-01-15  Vladimir Makarov  <vmakarov@redhat.com>\n \n \tPR rtl-optimization/64110"}, {"sha": "889f3c1a4d5bda515d342346ae632d8d1edcc46d", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/35228ac722036d6e33867d309b5bd837db4a354a/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/35228ac722036d6e33867d309b5bd837db4a354a/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=35228ac722036d6e33867d309b5bd837db4a354a", "patch": "@@ -1,3 +1,27 @@\n+2015-01-15  Jakub Jelinek  <jakub@redhat.com>\n+\n+\t* cp-gimplify.c (cp_genericize_r): Call\n+\tcp_ubsan_maybe_instrument_member_call for member calls.\n+\t(cp_ubsan_check_member_access_r): New function.\n+\t(cp_genericize_tree): Call cp_ubsan_instrument_member_accesses.\n+\t* cp-tree.h (cp_ubsan_maybe_instrument_member_call,\n+\tcp_ubsan_instrument_member_accesses,\n+\tcp_ubsan_maybe_instrument_downcast,\n+\tcp_ubsan_maybe_instrument_cast_to_vbase): New prototypes.\n+\t* cp-ubsan.c: New file.\n+\t* Make-lang.in (CXX_AND_OBJCXX_OBJS): Add cp/cp-ubsan.o.\n+\t* constexpr.c (cxx_eval_call_expression): Return void_node\n+\tfor IFN_UBSAN_VPTR.\n+\t(potential_constant_expression_1): Return true for\n+\tUBSAN_NULL, UBSAN_BOUNDS and UBSAN_VPTR internal calls.\n+\t* typeck.c (build_class_member_access_expr): Provide locus\n+\tfor COMPONENT_REFs.\n+\t(build_static_cast_1): Instrument downcasts.\n+\t* class.c (build_base_path): For -fsanitize=vptr and !fixed_type_p\n+\tadd ubsan instrumentation for virtual_access.\n+\t* call.c: Include internal-fn.h.\n+\t(set_flags_from_callee): Handle internal calls.\n+\n 2015-01-15  Momchil Velikov  <momchil.velikov@gmail.com>\n \n \tPR c++/59366"}, {"sha": "e98beb1e33e4bcc4943361c559ae71b7eb345346", "filename": "gcc/cp/Make-lang.in", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/35228ac722036d6e33867d309b5bd837db4a354a/gcc%2Fcp%2FMake-lang.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/35228ac722036d6e33867d309b5bd837db4a354a/gcc%2Fcp%2FMake-lang.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FMake-lang.in?ref=35228ac722036d6e33867d309b5bd837db4a354a", "patch": "@@ -78,7 +78,7 @@ CXX_AND_OBJCXX_OBJS = cp/call.o cp/decl.o cp/expr.o cp/pt.o cp/typeck2.o \\\n  cp/mangle.o cp/cp-objcp-common.o cp/name-lookup.o cp/cxx-pretty-print.o \\\n  cp/cp-cilkplus.o \\\n  cp/cp-gimplify.o cp/cp-array-notation.o cp/lambda.o \\\n- cp/vtable-class-hierarchy.o cp/constexpr.o $(CXX_C_OBJS)\n+ cp/vtable-class-hierarchy.o cp/constexpr.o cp/cp-ubsan.o $(CXX_C_OBJS)\n \n # Language-specific object files for C++.\n CXX_OBJS = cp/cp-lang.o c-family/stub-objc.o $(CXX_AND_OBJCXX_OBJS)"}, {"sha": "f2076c67aee090368fee08ab72fcee35470d9ead", "filename": "gcc/cp/call.c", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/35228ac722036d6e33867d309b5bd837db4a354a/gcc%2Fcp%2Fcall.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/35228ac722036d6e33867d309b5bd837db4a354a/gcc%2Fcp%2Fcall.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcall.c?ref=35228ac722036d6e33867d309b5bd837db4a354a", "patch": "@@ -58,6 +58,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"ipa-ref.h\"\n #include \"cgraph.h\"\n #include \"wide-int.h\"\n+#include \"internal-fn.h\"\n \n /* The various kinds of conversion.  */\n \n@@ -338,13 +339,16 @@ build_call_n (tree function, int n, ...)\n void\n set_flags_from_callee (tree call)\n {\n-  int nothrow;\n+  bool nothrow;\n   tree decl = get_callee_fndecl (call);\n \n   /* We check both the decl and the type; a function may be known not to\n      throw without being declared throw().  */\n-  nothrow = ((decl && TREE_NOTHROW (decl))\n-\t     || TYPE_NOTHROW_P (TREE_TYPE (TREE_TYPE (CALL_EXPR_FN (call)))));\n+  nothrow = decl && TREE_NOTHROW (decl);\n+  if (CALL_EXPR_FN (call))\n+    nothrow |= TYPE_NOTHROW_P (TREE_TYPE (TREE_TYPE (CALL_EXPR_FN (call))));\n+  else if (internal_fn_flags (CALL_EXPR_IFN (call)) & ECF_NOTHROW)\n+    nothrow = true;\n \n   if (!nothrow && at_function_scope_p () && cfun && cp_function_chain)\n     cp_function_chain->can_throw = 1;"}, {"sha": "1273064db3a8b44fbe394b79a29890c9f1191813", "filename": "gcc/cp/class.c", "status": "modified", "additions": 14, "deletions": 4, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/35228ac722036d6e33867d309b5bd837db4a354a/gcc%2Fcp%2Fclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/35228ac722036d6e33867d309b5bd837db4a354a/gcc%2Fcp%2Fclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fclass.c?ref=35228ac722036d6e33867d309b5bd837db4a354a", "patch": "@@ -447,10 +447,20 @@ build_base_path (enum tree_code code,\n \t  v_offset = cp_build_indirect_ref (v_offset, RO_NULL, complain);\n \t}\n       else\n-\tv_offset = build_vfield_ref (cp_build_indirect_ref (expr, RO_NULL,\n-                                                            complain),\n-\t\t\t\t     TREE_TYPE (TREE_TYPE (expr)));\n-      \n+\t{\n+\t  tree t = expr;\n+\t  if ((flag_sanitize & SANITIZE_VPTR) && fixed_type_p == 0)\n+\t    {\n+\t      t = cp_ubsan_maybe_instrument_cast_to_vbase (input_location,\n+\t\t\t\t\t\t\t   probe, expr);\n+\t      if (t == NULL_TREE)\n+\t\tt = expr;\n+\t    }\n+\t  v_offset = build_vfield_ref (cp_build_indirect_ref (t, RO_NULL,\n+\t\t\t\t\t\t\t      complain),\n+\t  TREE_TYPE (TREE_TYPE (expr)));\n+\t}\n+\n       if (v_offset == error_mark_node)\n \treturn error_mark_node;\n "}, {"sha": "0d474245d36166d5db7ad938cff9bec1df04a219", "filename": "gcc/cp/constexpr.c", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/35228ac722036d6e33867d309b5bd837db4a354a/gcc%2Fcp%2Fconstexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/35228ac722036d6e33867d309b5bd837db4a354a/gcc%2Fcp%2Fconstexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fconstexpr.c?ref=35228ac722036d6e33867d309b5bd837db4a354a", "patch": "@@ -1176,6 +1176,7 @@ cxx_eval_call_expression (const constexpr_ctx *ctx, tree t,\n       {\n       case IFN_UBSAN_NULL:\n       case IFN_UBSAN_BOUNDS:\n+      case IFN_UBSAN_VPTR:\n \treturn void_node;\n       default:\n \tif (!ctx->quiet)\n@@ -3820,6 +3821,19 @@ potential_constant_expression_1 (tree t, bool want_rval, bool strict,\n \n \tif (fun == NULL_TREE)\n \t  {\n+\t    if (TREE_CODE (t) == CALL_EXPR\n+\t\t&& CALL_EXPR_FN (t) == NULL_TREE)\n+\t      switch (CALL_EXPR_IFN (t))\n+\t\t{\n+\t\t/* These should be ignored, they are optimized away from\n+\t\t   constexpr functions.  */\n+\t\tcase IFN_UBSAN_NULL:\n+\t\tcase IFN_UBSAN_BOUNDS:\n+\t\tcase IFN_UBSAN_VPTR:\n+\t\t  return true;\n+\t\tdefault:\n+\t\t  break;\n+\t\t}\n \t    /* fold_call_expr can't do anything with IFN calls.  */\n \t    if (flags & tf_error)\n \t      error_at (EXPR_LOC_OR_LOC (t, input_location),"}, {"sha": "4233a64aefe88da857bee8fb6e1c3cd389fbc51b", "filename": "gcc/cp/cp-gimplify.c", "status": "modified", "additions": 10, "deletions": 3, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/35228ac722036d6e33867d309b5bd837db4a354a/gcc%2Fcp%2Fcp-gimplify.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/35228ac722036d6e33867d309b5bd837db4a354a/gcc%2Fcp%2Fcp-gimplify.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-gimplify.c?ref=35228ac722036d6e33867d309b5bd837db4a354a", "patch": "@@ -1197,9 +1197,11 @@ cp_genericize_r (tree *stmt_p, int *walk_subtrees, void *data)\n \t*stmt_p = size_one_node;\n       return NULL;\n     }    \n-  else if (flag_sanitize & (SANITIZE_NULL | SANITIZE_ALIGNMENT))\n+  else if (flag_sanitize\n+\t   & (SANITIZE_NULL | SANITIZE_ALIGNMENT | SANITIZE_VPTR))\n     {\n-      if (TREE_CODE (stmt) == NOP_EXPR\n+      if ((flag_sanitize & (SANITIZE_NULL | SANITIZE_ALIGNMENT))\n+\t  && TREE_CODE (stmt) == NOP_EXPR\n \t  && TREE_CODE (TREE_TYPE (stmt)) == REFERENCE_TYPE)\n \tubsan_maybe_instrument_reference (stmt);\n       else if (TREE_CODE (stmt) == CALL_EXPR)\n@@ -1214,7 +1216,10 @@ cp_genericize_r (tree *stmt_p, int *walk_subtrees, void *data)\n \t\t= TREE_CODE (fn) == ADDR_EXPR\n \t\t  && TREE_CODE (TREE_OPERAND (fn, 0)) == FUNCTION_DECL\n \t\t  && DECL_CONSTRUCTOR_P (TREE_OPERAND (fn, 0));\n-\t      ubsan_maybe_instrument_member_call (stmt, is_ctor);\n+\t      if (flag_sanitize & (SANITIZE_NULL | SANITIZE_ALIGNMENT))\n+\t\tubsan_maybe_instrument_member_call (stmt, is_ctor);\n+\t      if ((flag_sanitize & SANITIZE_VPTR) && !is_ctor)\n+\t\tcp_ubsan_maybe_instrument_member_call (stmt);\n \t    }\n \t}\n     }\n@@ -1237,6 +1242,8 @@ cp_genericize_tree (tree* t_p)\n   cp_walk_tree (t_p, cp_genericize_r, &wtd, NULL);\n   delete wtd.p_set;\n   wtd.bind_expr_stack.release ();\n+  if (flag_sanitize & SANITIZE_VPTR)\n+    cp_ubsan_instrument_member_accesses (t_p);\n }\n \n /* If a function that should end with a return in non-void"}, {"sha": "1176583cef77f42b5553b11d5631474b74376b77", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/35228ac722036d6e33867d309b5bd837db4a354a/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/35228ac722036d6e33867d309b5bd837db4a354a/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=35228ac722036d6e33867d309b5bd837db4a354a", "patch": "@@ -6412,6 +6412,12 @@ extern vec<tree> cx_error_context               (void);\n /* In c-family/cilk.c */\n extern bool cilk_valid_spawn                    (tree);\n \n+/* In cp-ubsan.c */\n+extern void cp_ubsan_maybe_instrument_member_call (tree);\n+extern void cp_ubsan_instrument_member_accesses (tree *);\n+extern tree cp_ubsan_maybe_instrument_downcast\t(location_t, tree, tree);\n+extern tree cp_ubsan_maybe_instrument_cast_to_vbase (location_t, tree, tree);\n+\n /* -- end of C++ */\n \n #endif /* ! GCC_CP_TREE_H */"}, {"sha": "69e486442fedbe7191c6595147514ec960d8b543", "filename": "gcc/cp/cp-ubsan.c", "status": "added", "additions": 302, "deletions": 0, "changes": 302, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/35228ac722036d6e33867d309b5bd837db4a354a/gcc%2Fcp%2Fcp-ubsan.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/35228ac722036d6e33867d309b5bd837db4a354a/gcc%2Fcp%2Fcp-ubsan.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-ubsan.c?ref=35228ac722036d6e33867d309b5bd837db4a354a", "patch": "@@ -0,0 +1,302 @@\n+/* UndefinedBehaviorSanitizer, undefined behavior detector.\n+   Copyright (C) 2014 Free Software Foundation, Inc.\n+   Contributed by Jakub Jelinek <jakub@redhat.com>\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it under\n+the terms of the GNU General Public License as published by the Free\n+Software Foundation; either version 3, or (at your option) any later\n+version.\n+\n+GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING3.  If not see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#include \"config.h\"\n+#include \"system.h\"\n+#include \"coretypes.h\"\n+#include \"hash-set.h\"\n+#include \"machmode.h\"\n+#include \"vec.h\"\n+#include \"double-int.h\"\n+#include \"input.h\"\n+#include \"alias.h\"\n+#include \"symtab.h\"\n+#include \"options.h\"\n+#include \"wide-int.h\"\n+#include \"inchash.h\"\n+#include \"tree.h\"\n+#include \"alloc-pool.h\"\n+#include \"output.h\"\n+#include \"toplev.h\"\n+#include \"ubsan.h\"\n+#include \"cp-tree.h\"\n+#include \"c-family/c-common.h\"\n+#include \"c-family/c-ubsan.h\"\n+#include \"asan.h\"\n+#include \"internal-fn.h\"\n+#include \"stor-layout.h\"\n+#include \"builtins.h\"\n+#include \"fold-const.h\"\n+#include \"stringpool.h\"\n+#include \"is-a.h\"\n+#include \"predict.h\"\n+#include \"tree-ssa-alias.h\"\n+#include \"basic-block.h\"\n+#include \"gimple-expr.h\"\n+#include \"gimple.h\"\n+#include \"ipa-ref.h\"\n+#include \"lto-streamer.h\"\n+#include \"cgraph.h\"\n+\n+/* Test if we should instrument vptr access.  */\n+\n+static bool\n+cp_ubsan_instrument_vptr_p (tree type)\n+{\n+  if (!flag_rtti || flag_sanitize_undefined_trap_on_error)\n+    return false;\n+\n+  if (current_function_decl\n+      && lookup_attribute (\"no_sanitize_undefined\",\n+\t\t\t   DECL_ATTRIBUTES (current_function_decl)))\n+    return false;\n+\n+  if (type)\n+    {\n+      type = TYPE_MAIN_VARIANT (type);\n+      if (!CLASS_TYPE_P (type) || !CLASSTYPE_VTABLES (type))\n+\treturn false;\n+    }\n+\n+  return true;\n+}\n+\n+/* Helper function for\n+   cp_ubsan_maybe_instrument_{member_{call,access},downcast}.\n+   Instrument vptr access.  */\n+\n+static tree\n+cp_ubsan_instrument_vptr (location_t loc, tree op, tree type, bool is_addr,\n+\t\t\t  enum ubsan_null_ckind ckind)\n+{\n+  type = TYPE_MAIN_VARIANT (type);\n+  const char *mangled = mangle_type_string (type);\n+  hashval_t str_hash1 = htab_hash_string (mangled);\n+  hashval_t str_hash2 = iterative_hash (mangled, strlen (mangled), 0);\n+  tree str_hash = wide_int_to_tree (uint64_type_node,\n+\t\t\t\t    wi::uhwi (((uint64_t) str_hash1 << 32)\n+\t\t\t\t\t      | str_hash2, 64));\n+  if (!is_addr)\n+    op = build_fold_addr_expr_loc (loc, op);\n+  op = save_expr (op);\n+  tree vptr = fold_build3_loc (loc, COMPONENT_REF,\n+\t\t\t       TREE_TYPE (TYPE_VFIELD (type)),\n+\t\t\t       build_fold_indirect_ref_loc (loc, op),\n+\t\t\t       TYPE_VFIELD (type), NULL_TREE);\n+  vptr = fold_convert_loc (loc, pointer_sized_int_node, vptr);\n+  vptr = fold_convert_loc (loc, uint64_type_node, vptr);\n+  if (ckind == UBSAN_DOWNCAST_POINTER)\n+    vptr = fold_build3 (COND_EXPR, uint64_type_node,\n+\t\t\tfold_build2 (NE_EXPR, boolean_type_node, op,\n+\t\t\t\t     build_zero_cst (TREE_TYPE (op))),\n+\t\t\tvptr, build_int_cst (uint64_type_node, 0));\n+  vptr = build1_loc (loc, SAVE_EXPR, uint64_type_node, vptr);\n+  tree ti_decl = get_tinfo_decl (type);\n+  mark_used (ti_decl);\n+  tree ptype = build_pointer_type (type);\n+  tree call\n+    = build_call_expr_internal_loc (loc, IFN_UBSAN_VPTR,\n+\t\t\t\t    void_type_node, 5, op, vptr, str_hash,\n+\t\t\t\t    build_address (ti_decl),\n+\t\t\t\t    build_int_cst (ptype, ckind));\n+  TREE_SIDE_EFFECTS (call) = 1;\n+  return fold_build2 (COMPOUND_EXPR, TREE_TYPE (op), call, op);\n+}\n+\n+/* Helper function for\n+   cp_ubsan_maybe_instrument_{member_{call,access},downcast}.\n+   Instrument vptr access if it should be instrumented, otherwise return\n+   NULL_TREE.  */\n+\n+static tree\n+cp_ubsan_maybe_instrument_vptr (location_t loc, tree op, tree type,\n+\t\t\t\tbool is_addr, enum ubsan_null_ckind ckind)\n+{\n+  if (!cp_ubsan_instrument_vptr_p (type))\n+    return NULL_TREE;\n+  return cp_ubsan_instrument_vptr (loc, op, type, is_addr, ckind);\n+}\n+\n+/* Instrument a member call (but not constructor call) if needed.  */\n+\n+void\n+cp_ubsan_maybe_instrument_member_call (tree stmt)\n+{\n+  if (call_expr_nargs (stmt) == 0)\n+    return;\n+  tree *opp = &CALL_EXPR_ARG (stmt, 0);\n+  tree op = *opp;\n+  if (op == error_mark_node\n+      || !POINTER_TYPE_P (TREE_TYPE (op)))\n+    return;\n+  while (TREE_CODE (op) == COMPOUND_EXPR)\n+    {\n+      opp = &TREE_OPERAND (op, 1);\n+      op = *opp;\n+    }\n+  op = cp_ubsan_maybe_instrument_vptr (EXPR_LOCATION (stmt), op,\n+\t\t\t\t       TREE_TYPE (TREE_TYPE (op)),\n+\t\t\t\t       true, UBSAN_MEMBER_CALL);\n+  if (op)\n+    *opp = op;\n+}\n+\n+/* Data passed to cp_ubsan_check_member_access_r.  */\n+\n+struct cp_ubsan_check_member_access_data\n+{\n+  hash_set<tree> *pset;\n+  bool is_addr;\n+};\n+\n+static tree cp_ubsan_check_member_access_r (tree *, int *, void *);\n+\n+/* Instrument a member access.  */\n+\n+static bool\n+cp_ubsan_maybe_instrument_member_access\n+     (tree stmt, cp_ubsan_check_member_access_data *ucmd)\n+{\n+  if (DECL_ARTIFICIAL (TREE_OPERAND (stmt, 1)))\n+    return false;\n+\n+  tree base = TREE_OPERAND (stmt, 0);\n+  if (!cp_ubsan_instrument_vptr_p (TREE_TYPE (base)))\n+    return false;\n+\n+  cp_walk_tree (&base, cp_ubsan_check_member_access_r, ucmd, ucmd->pset);\n+\n+  base = cp_ubsan_instrument_vptr (EXPR_LOCATION (stmt), base,\n+\t\t\t\t   TREE_TYPE (base), false,\n+\t\t\t\t   UBSAN_MEMBER_ACCESS);\n+  TREE_OPERAND (stmt, 0)\n+    = build_fold_indirect_ref_loc (EXPR_LOCATION (stmt), base);\n+  return true;\n+}\n+\n+/* Attempt to instrument member accesses inside of the function.\n+   cp_ubsan_maybe_instrument_member_access should be called on COMPONENT_REFs\n+   in the GENERIC IL, but only when the field is actually accessed, not\n+   merely when it's address is taken.  Therefore we track in is_addr field\n+   whether in the current context we are processing address taken\n+   handled components or not.  E.g. for &x->y[w->z] we want to call\n+   cp_ubsan_maybe_instrument_member_access on *w.z COMPONENT_REF, but\n+   not on *x.y.  */\n+\n+static tree\n+cp_ubsan_check_member_access_r (tree *stmt_p, int *walk_subtrees, void *data)\n+{\n+  tree stmt = *stmt_p, t;\n+  cp_ubsan_check_member_access_data *ucmd\n+    = (cp_ubsan_check_member_access_data *) data;\n+  switch (TREE_CODE (stmt))\n+    {\n+    case ADDR_EXPR:\n+      t = TREE_OPERAND (stmt, 0);\n+      while ((TREE_CODE (t) == MEM_REF || TREE_CODE (t) == INDIRECT_REF)\n+\t     && TREE_CODE (TREE_OPERAND (t, 0)) == ADDR_EXPR)\n+\tt = TREE_OPERAND (TREE_OPERAND (t, 0), 0);\n+      if (handled_component_p (t))\n+\t{\n+\t  *walk_subtrees = 0;\n+\t  ucmd->is_addr = true;\n+\t  cp_walk_tree (&t, cp_ubsan_check_member_access_r,\n+\t\t\tdata, ucmd->pset);\n+\t  ucmd->is_addr = false;\n+\t}\n+      break;\n+    case MEM_REF:\n+    case INDIRECT_REF:\n+      t = TREE_OPERAND (stmt, 0);\n+      if (TREE_CODE (t) == ADDR_EXPR)\n+\t{\n+\t  *walk_subtrees = 0;\n+\t  t = TREE_OPERAND (stmt, 0);\n+\t  cp_walk_tree (&t, cp_ubsan_check_member_access_r, data, ucmd->pset);\n+\t}\n+      break;\n+    case COMPONENT_REF:\n+      if (!ucmd->is_addr && cp_ubsan_maybe_instrument_member_access (stmt, ucmd))\n+\t{\n+\t  *walk_subtrees = 0;\n+\t  break;\n+\t}\n+      /* FALLTHRU */\n+    default:\n+      if (ucmd->is_addr && handled_component_p (stmt))\n+\t{\n+\t  int i, len = TREE_OPERAND_LENGTH (stmt);\n+\t  *walk_subtrees = 0;\n+\t  if (!handled_component_p (TREE_OPERAND (stmt, 0)))\n+\t    ucmd->is_addr = false;\n+\t  for (i = 0; i < len; i++)\n+\t    {\n+\t      cp_walk_tree (&TREE_OPERAND (stmt, i),\n+\t\t\t    cp_ubsan_check_member_access_r, data, ucmd->pset);\n+\t      ucmd->is_addr = false;\n+\t    }\n+\t  ucmd->is_addr = true;\n+\t}\n+      break;\n+    }\n+  return NULL_TREE;\n+}\n+\n+/* Instrument all member accesses inside GENERIC *T_P.  */\n+\n+void\n+cp_ubsan_instrument_member_accesses (tree *t_p)\n+{\n+  if (cp_ubsan_instrument_vptr_p (NULL_TREE))\n+    {\n+      hash_set<tree> pset;\n+      cp_ubsan_check_member_access_data ucmd;\n+      ucmd.pset = &pset;\n+      ucmd.is_addr = false;\n+      cp_walk_tree (t_p, cp_ubsan_check_member_access_r, &ucmd, &pset);\n+    }\n+}\n+\n+/* Instrument downcast.  */\n+\n+tree\n+cp_ubsan_maybe_instrument_downcast (location_t loc, tree type, tree op)\n+{\n+  if (!POINTER_TYPE_P (type)\n+      || !POINTER_TYPE_P (TREE_TYPE (op))\n+      || !CLASS_TYPE_P (TREE_TYPE (type))\n+      || !CLASS_TYPE_P (TREE_TYPE (TREE_TYPE (op)))\n+      || !DERIVED_FROM_P (TREE_TYPE (TREE_TYPE (op)), TREE_TYPE (type)))\n+    return NULL_TREE;\n+\n+  return cp_ubsan_maybe_instrument_vptr (loc, op, TREE_TYPE (type), true,\n+\t\t\t\t\t TREE_CODE (type) == POINTER_TYPE\n+\t\t\t\t\t ? UBSAN_DOWNCAST_POINTER\n+\t\t\t\t\t : UBSAN_DOWNCAST_REFERENCE);\n+}\n+\n+/* Instrument cast to virtual base.  */\n+\n+tree\n+cp_ubsan_maybe_instrument_cast_to_vbase (location_t loc, tree type, tree op)\n+{\n+  return cp_ubsan_maybe_instrument_vptr (loc, op, type, true,\n+\t\t\t\t\t UBSAN_CAST_TO_VBASE);\n+}"}, {"sha": "32ee78ec307014f36d6bca98019d308331d25406", "filename": "gcc/cp/typeck.c", "status": "modified", "additions": 24, "deletions": 5, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/35228ac722036d6e33867d309b5bd837db4a354a/gcc%2Fcp%2Ftypeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/35228ac722036d6e33867d309b5bd837db4a354a/gcc%2Fcp%2Ftypeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck.c?ref=35228ac722036d6e33867d309b5bd837db4a354a", "patch": "@@ -2425,8 +2425,8 @@ build_class_member_access_expr (tree object, tree member,\n \t  member_type = cp_build_qualified_type (member_type, type_quals);\n \t}\n \n-      result = build3 (COMPONENT_REF, member_type, object, member,\n-\t\t       NULL_TREE);\n+      result = build3_loc (input_location, COMPONENT_REF, member_type,\n+\t\t\t   object, member, NULL_TREE);\n       result = fold_if_not_in_template (result);\n \n       /* Mark the expression const or volatile, as appropriate.  Even\n@@ -6474,11 +6474,21 @@ build_static_cast_1 (tree type, tree expr, bool c_cast_p,\n       base = lookup_base (TREE_TYPE (type), intype,\n \t\t\t  c_cast_p ? ba_unique : ba_check,\n \t\t\t  NULL, complain);\n+      expr = build_address (expr);\n+\n+      if (flag_sanitize & SANITIZE_VPTR)\n+\t{\n+\t  tree ubsan_check\n+\t    = cp_ubsan_maybe_instrument_downcast (input_location, type, expr);\n+\t  if (ubsan_check)\n+\t    expr = ubsan_check;\n+\t}\n \n       /* Convert from \"B*\" to \"D*\".  This function will check that \"B\"\n \t is not a virtual base of \"D\".  */\n-      expr = build_base_path (MINUS_EXPR, build_address (expr),\n-\t\t\t      base, /*nonnull=*/false, complain);\n+      expr = build_base_path (MINUS_EXPR, expr, base, /*nonnull=*/false,\n+\t\t\t      complain);\n+\n       /* Convert the pointer to a reference -- but then remember that\n \t there are no expressions with reference type in C++.\n \n@@ -6606,7 +6616,16 @@ build_static_cast_1 (tree type, tree expr, bool c_cast_p,\n \t\t\t  NULL, complain);\n       expr = build_base_path (MINUS_EXPR, expr, base, /*nonnull=*/false,\n \t\t\t      complain);\n-      return cp_fold_convert(type, expr);\n+\n+      if (flag_sanitize & SANITIZE_VPTR)\n+\t{\n+\t  tree ubsan_check\n+\t    = cp_ubsan_maybe_instrument_downcast (input_location, type, expr);\n+\t  if (ubsan_check)\n+\t    expr = ubsan_check;\n+\t}\n+\n+      return cp_fold_convert (type, expr);\n     }\n \n   if ((TYPE_PTRDATAMEM_P (type) && TYPE_PTRDATAMEM_P (intype))"}, {"sha": "bfdce442a629854556c93d2e98bff322d1841f3c", "filename": "gcc/flag-types.h", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/35228ac722036d6e33867d309b5bd837db4a354a/gcc%2Fflag-types.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/35228ac722036d6e33867d309b5bd837db4a354a/gcc%2Fflag-types.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fflag-types.h?ref=35228ac722036d6e33867d309b5bd837db4a354a", "patch": "@@ -237,13 +237,14 @@ enum sanitize_code {\n   SANITIZE_NONNULL_ATTRIBUTE = 1UL << 18,\n   SANITIZE_RETURNS_NONNULL_ATTRIBUTE = 1UL << 19,\n   SANITIZE_OBJECT_SIZE = 1UL << 20,\n+  SANITIZE_VPTR = 1UL << 21,\n   SANITIZE_UNDEFINED = SANITIZE_SHIFT | SANITIZE_DIVIDE | SANITIZE_UNREACHABLE\n \t\t       | SANITIZE_VLA | SANITIZE_NULL | SANITIZE_RETURN\n \t\t       | SANITIZE_SI_OVERFLOW | SANITIZE_BOOL | SANITIZE_ENUM\n \t\t       | SANITIZE_BOUNDS | SANITIZE_ALIGNMENT\n \t\t       | SANITIZE_NONNULL_ATTRIBUTE\n \t\t       | SANITIZE_RETURNS_NONNULL_ATTRIBUTE\n-\t\t       | SANITIZE_OBJECT_SIZE,\n+\t\t       | SANITIZE_OBJECT_SIZE | SANITIZE_VPTR,\n   SANITIZE_NONDEFAULT = SANITIZE_FLOAT_DIVIDE | SANITIZE_FLOAT_CAST\n };\n "}, {"sha": "e4028250c2acecb6387eefee44b56efdf3b404a5", "filename": "gcc/internal-fn.c", "status": "modified", "additions": 17, "deletions": 9, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/35228ac722036d6e33867d309b5bd837db4a354a/gcc%2Finternal-fn.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/35228ac722036d6e33867d309b5bd837db4a354a/gcc%2Finternal-fn.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Finternal-fn.c?ref=35228ac722036d6e33867d309b5bd837db4a354a", "patch": "@@ -166,63 +166,71 @@ expand_STORE_LANES (gcall *stmt)\n }\n \n static void\n-expand_ANNOTATE (gcall *stmt ATTRIBUTE_UNUSED)\n+expand_ANNOTATE (gcall *)\n {\n   gcc_unreachable ();\n }\n \n /* This should get expanded in adjust_simduid_builtins.  */\n \n static void\n-expand_GOMP_SIMD_LANE (gcall *stmt ATTRIBUTE_UNUSED)\n+expand_GOMP_SIMD_LANE (gcall *)\n {\n   gcc_unreachable ();\n }\n \n /* This should get expanded in adjust_simduid_builtins.  */\n \n static void\n-expand_GOMP_SIMD_VF (gcall *stmt ATTRIBUTE_UNUSED)\n+expand_GOMP_SIMD_VF (gcall *)\n {\n   gcc_unreachable ();\n }\n \n /* This should get expanded in adjust_simduid_builtins.  */\n \n static void\n-expand_GOMP_SIMD_LAST_LANE (gcall *stmt ATTRIBUTE_UNUSED)\n+expand_GOMP_SIMD_LAST_LANE (gcall *)\n {\n   gcc_unreachable ();\n }\n \n /* This should get expanded in the sanopt pass.  */\n \n static void\n-expand_UBSAN_NULL (gcall *stmt ATTRIBUTE_UNUSED)\n+expand_UBSAN_NULL (gcall *)\n {\n   gcc_unreachable ();\n }\n \n /* This should get expanded in the sanopt pass.  */\n \n static void\n-expand_UBSAN_BOUNDS (gcall *stmt ATTRIBUTE_UNUSED)\n+expand_UBSAN_BOUNDS (gcall *)\n {\n   gcc_unreachable ();\n }\n \n /* This should get expanded in the sanopt pass.  */\n \n static void\n-expand_UBSAN_OBJECT_SIZE (gcall *stmt ATTRIBUTE_UNUSED)\n+expand_UBSAN_VPTR (gcall *)\n {\n   gcc_unreachable ();\n }\n \n /* This should get expanded in the sanopt pass.  */\n \n static void\n-expand_ASAN_CHECK (gcall *stmt ATTRIBUTE_UNUSED)\n+expand_UBSAN_OBJECT_SIZE (gcall *)\n+{\n+  gcc_unreachable ();\n+}\n+\n+/* This should get expanded in the sanopt pass.  */\n+\n+static void\n+expand_ASAN_CHECK (gcall *)\n {\n   gcc_unreachable ();\n }\n@@ -1889,7 +1897,7 @@ expand_MUL_OVERFLOW (gcall *stmt)\n /* This should get folded in tree-vectorizer.c.  */\n \n static void\n-expand_LOOP_VECTORIZED (gcall *stmt ATTRIBUTE_UNUSED)\n+expand_LOOP_VECTORIZED (gcall *)\n {\n   gcc_unreachable ();\n }"}, {"sha": "032ce6c909e5a4a872e010ac89d82e43f1e449f6", "filename": "gcc/internal-fn.def", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/35228ac722036d6e33867d309b5bd837db4a354a/gcc%2Finternal-fn.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/35228ac722036d6e33867d309b5bd837db4a354a/gcc%2Finternal-fn.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Finternal-fn.def?ref=35228ac722036d6e33867d309b5bd837db4a354a", "patch": "@@ -48,15 +48,16 @@ DEF_INTERNAL_FN (LOOP_VECTORIZED, ECF_NOVOPS | ECF_LEAF | ECF_NOTHROW, NULL)\n DEF_INTERNAL_FN (MASK_LOAD, ECF_PURE | ECF_LEAF, NULL)\n DEF_INTERNAL_FN (MASK_STORE, ECF_LEAF, NULL)\n DEF_INTERNAL_FN (ANNOTATE,  ECF_CONST | ECF_LEAF | ECF_NOTHROW, NULL)\n-DEF_INTERNAL_FN (UBSAN_NULL, ECF_LEAF | ECF_NOTHROW, \".W.\")\n+DEF_INTERNAL_FN (UBSAN_NULL, ECF_LEAF | ECF_NOTHROW, \".R.\")\n DEF_INTERNAL_FN (UBSAN_BOUNDS, ECF_LEAF | ECF_NOTHROW, NULL)\n+DEF_INTERNAL_FN (UBSAN_VPTR, ECF_LEAF | ECF_NOTHROW, \".RR..\")\n DEF_INTERNAL_FN (UBSAN_CHECK_ADD, ECF_CONST | ECF_LEAF | ECF_NOTHROW, NULL)\n DEF_INTERNAL_FN (UBSAN_CHECK_SUB, ECF_CONST | ECF_LEAF | ECF_NOTHROW, NULL)\n DEF_INTERNAL_FN (UBSAN_CHECK_MUL, ECF_CONST | ECF_LEAF | ECF_NOTHROW, NULL)\n DEF_INTERNAL_FN (UBSAN_OBJECT_SIZE, ECF_LEAF | ECF_NOTHROW, NULL)\n DEF_INTERNAL_FN (ABNORMAL_DISPATCHER, ECF_NORETURN, NULL)\n DEF_INTERNAL_FN (BUILTIN_EXPECT, ECF_CONST | ECF_LEAF | ECF_NOTHROW, NULL)\n-DEF_INTERNAL_FN (ASAN_CHECK, ECF_TM_PURE | ECF_LEAF | ECF_NOTHROW, \".W...\")\n+DEF_INTERNAL_FN (ASAN_CHECK, ECF_TM_PURE | ECF_LEAF | ECF_NOTHROW, \".R...\")\n DEF_INTERNAL_FN (ADD_OVERFLOW, ECF_CONST | ECF_LEAF | ECF_NOTHROW, NULL)\n DEF_INTERNAL_FN (SUB_OVERFLOW, ECF_CONST | ECF_LEAF | ECF_NOTHROW, NULL)\n DEF_INTERNAL_FN (MUL_OVERFLOW, ECF_CONST | ECF_LEAF | ECF_NOTHROW, NULL)"}, {"sha": "305e349497201526b4a0231abd114ff77972fba7", "filename": "gcc/opts.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/35228ac722036d6e33867d309b5bd837db4a354a/gcc%2Fopts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/35228ac722036d6e33867d309b5bd837db4a354a/gcc%2Fopts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fopts.c?ref=35228ac722036d6e33867d309b5bd837db4a354a", "patch": "@@ -1588,6 +1588,7 @@ common_handle_option (struct gcc_options *opts,\n \t\tsizeof \"returns-nonnull-attribute\" - 1 },\n \t      { \"object-size\", SANITIZE_OBJECT_SIZE,\n \t\tsizeof \"object-size\" - 1 },\n+\t      { \"vptr\", SANITIZE_VPTR, sizeof \"vptr\" - 1 },\n \t      { \"all\", ~0, sizeof \"all\" - 1 },\n \t      { NULL, 0, 0 }\n \t    };"}, {"sha": "0f18928810785de4504b2eaec5fa206edfac370d", "filename": "gcc/sanitizer.def", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/35228ac722036d6e33867d309b5bd837db4a354a/gcc%2Fsanitizer.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/35228ac722036d6e33867d309b5bd837db4a354a/gcc%2Fsanitizer.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsanitizer.def?ref=35228ac722036d6e33867d309b5bd837db4a354a", "patch": "@@ -499,3 +499,11 @@ DEF_SANITIZER_BUILTIN(BUILT_IN_UBSAN_HANDLE_NONNULL_RETURN_ABORT,\n \t\t      \"__ubsan_handle_nonnull_return_abort\",\n \t\t      BT_FN_VOID_PTR,\n \t\t      ATTR_COLD_NORETURN_NOTHROW_LEAF_LIST)\n+DEF_SANITIZER_BUILTIN(BUILT_IN_UBSAN_HANDLE_DYNAMIC_TYPE_CACHE_MISS,\n+\t\t      \"__ubsan_handle_dynamic_type_cache_miss\",\n+\t\t      BT_FN_VOID_PTR_PTR_PTR,\n+\t\t      ATTR_COLD_NOTHROW_LEAF_LIST)\n+DEF_SANITIZER_BUILTIN(BUILT_IN_UBSAN_HANDLE_DYNAMIC_TYPE_CACHE_MISS_ABORT,\n+\t\t      \"__ubsan_handle_dynamic_type_cache_miss_abort\",\n+\t\t      BT_FN_VOID_PTR_PTR_PTR,\n+\t\t      ATTR_COLD_NOTHROW_LEAF_LIST)"}, {"sha": "9689aef4f0a4c65ee613a7e318c9a474d1907238", "filename": "gcc/sanopt.c", "status": "modified", "additions": 99, "deletions": 3, "changes": 102, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/35228ac722036d6e33867d309b5bd837db4a354a/gcc%2Fsanopt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/35228ac722036d6e33867d309b5bd837db4a354a/gcc%2Fsanopt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsanopt.c?ref=35228ac722036d6e33867d309b5bd837db4a354a", "patch": "@@ -108,7 +108,7 @@ maybe_get_single_definition (tree t)\n \n /* Traits class for tree hash maps below.  */\n \n-struct tree_map_traits : default_hashmap_traits\n+struct sanopt_tree_map_traits : default_hashmap_traits\n {\n   static inline hashval_t hash (const_tree ref)\n   {\n@@ -121,6 +121,63 @@ struct tree_map_traits : default_hashmap_traits\n   }\n }; \n \n+/* Tree triplet for vptr_check_map.  */\n+struct sanopt_tree_triplet\n+{\n+  tree t1, t2, t3;\n+};\n+\n+/* Traits class for tree triplet hash maps below.  */\n+\n+struct sanopt_tree_triplet_map_traits : default_hashmap_traits\n+{\n+  static inline hashval_t\n+  hash (const sanopt_tree_triplet &ref)\n+  {\n+    inchash::hash hstate (0);\n+    inchash::add_expr (ref.t1, hstate);\n+    inchash::add_expr (ref.t2, hstate);\n+    inchash::add_expr (ref.t3, hstate);\n+    return hstate.end ();\n+  }\n+\n+  static inline bool\n+  equal_keys (const sanopt_tree_triplet &ref1, const sanopt_tree_triplet &ref2)\n+  {\n+    return operand_equal_p (ref1.t1, ref2.t1, 0)\n+\t   && operand_equal_p (ref1.t2, ref2.t2, 0)\n+\t   && operand_equal_p (ref1.t3, ref2.t3, 0);\n+  }\n+\n+  template<typename T>\n+  static inline void\n+  mark_deleted (T &e)\n+  {\n+    e.m_key.t1 = reinterpret_cast<T *> (1);\n+  }\n+\n+  template<typename T>\n+  static inline void\n+  mark_empty (T &e)\n+  {\n+    e.m_key.t1 = NULL;\n+  }\n+\n+  template<typename T>\n+  static inline bool\n+  is_deleted (T &e)\n+  {\n+    return e.m_key.t1 == (void *) 1;\n+  }\n+\n+  template<typename T>\n+  static inline bool\n+  is_empty (T &e)\n+  {\n+    return e.m_key.t1 == NULL;\n+  }\n+};\n+\n /* This is used to carry various hash maps and variables used\n    in sanopt_optimize_walker.  */\n \n@@ -132,7 +189,13 @@ struct sanopt_ctx\n \n   /* This map maps a pointer (the second argument of ASAN_CHECK) to\n      a vector of ASAN_CHECK call statements that check the access.  */\n-  hash_map<tree, auto_vec<gimple>, tree_map_traits> asan_check_map;\n+  hash_map<tree, auto_vec<gimple>, sanopt_tree_map_traits> asan_check_map;\n+\n+  /* This map maps a tree triplet (the first, second and fourth argument\n+     of UBSAN_VPTR) to a vector of UBSAN_VPTR call statements that check\n+     that virtual table pointer.  */\n+  hash_map<sanopt_tree_triplet, auto_vec<gimple>,\n+\t   sanopt_tree_triplet_map_traits> vptr_check_map;\n \n   /* Number of IFN_ASAN_CHECK statements.  */\n   int asan_num_accesses;\n@@ -306,6 +369,32 @@ maybe_optimize_ubsan_null_ifn (struct sanopt_ctx *ctx, gimple stmt)\n   return remove;\n }\n \n+/* Optimize away redundant UBSAN_VPTR calls.  The second argument\n+   is the value loaded from the virtual table, so rely on FRE to find out\n+   when we can actually optimize.  */\n+\n+static bool\n+maybe_optimize_ubsan_vptr_ifn (struct sanopt_ctx *ctx, gimple stmt)\n+{\n+  gcc_assert (gimple_call_num_args (stmt) == 5);\n+  sanopt_tree_triplet triplet;\n+  triplet.t1 = gimple_call_arg (stmt, 0);\n+  triplet.t2 = gimple_call_arg (stmt, 1);\n+  triplet.t3 = gimple_call_arg (stmt, 3);\n+\n+  auto_vec<gimple> &v = ctx->vptr_check_map.get_or_insert (triplet);\n+  gimple g = maybe_get_dominating_check (v);\n+  if (!g)\n+    {\n+      /* For this PTR we don't have any UBSAN_VPTR stmts recorded, so there's\n+\t nothing to optimize yet.  */\n+      v.safe_push (stmt);\n+      return false;\n+    }\n+\n+  return true;\n+}\n+\n /* Returns TRUE if ASan check of length LEN in block BB can be removed\n    if preceded by checks in V.  */\n \n@@ -497,6 +586,9 @@ sanopt_optimize_walker (basic_block bb, struct sanopt_ctx *ctx)\n \t  case IFN_UBSAN_NULL:\n \t    remove = maybe_optimize_ubsan_null_ifn (ctx, stmt);\n \t    break;\n+\t  case IFN_UBSAN_VPTR:\n+\t    remove = maybe_optimize_ubsan_vptr_ifn (ctx, stmt);\n+\t    break;\n \t  case IFN_ASAN_CHECK:\n \t    if (asan_check_optimize)\n \t      remove = maybe_optimize_asan_check_ifn (ctx, stmt);\n@@ -601,7 +693,8 @@ pass_sanopt::execute (function *fun)\n   /* Try to remove redundant checks.  */\n   if (optimize\n       && (flag_sanitize\n-\t  & (SANITIZE_NULL | SANITIZE_ALIGNMENT | SANITIZE_ADDRESS)))\n+\t  & (SANITIZE_NULL | SANITIZE_ALIGNMENT\n+\t     | SANITIZE_ADDRESS | SANITIZE_VPTR)))\n     asan_num_accesses = sanopt_optimize (fun);\n   else if (flag_sanitize & SANITIZE_ADDRESS)\n     {\n@@ -647,6 +740,9 @@ pass_sanopt::execute (function *fun)\n \t\tcase IFN_UBSAN_OBJECT_SIZE:\n \t\t  no_next = ubsan_expand_objsize_ifn (&gsi);\n \t\t  break;\n+\t\tcase IFN_UBSAN_VPTR:\n+\t\t  no_next = ubsan_expand_vptr_ifn (&gsi);\n+\t\t  break;\n \t\tcase IFN_ASAN_CHECK:\n \t\t  no_next = asan_expand_check_ifn (&gsi, use_calls);\n \t\t  break;"}, {"sha": "8a9f9271080e1f53ca086bc85b0b566745e4ac54", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/35228ac722036d6e33867d309b5bd837db4a354a/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/35228ac722036d6e33867d309b5bd837db4a354a/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=35228ac722036d6e33867d309b5bd837db4a354a", "patch": "@@ -1,3 +1,15 @@\n+2015-01-15  Jakub Jelinek  <jakub@redhat.com>\n+\n+\t* g++.dg/ubsan/vptr-1.C: New test.\n+\t* g++.dg/ubsan/vptr-2.C: New test.\n+\t* g++.dg/ubsan/vptr-3.C: New test.\n+\t* g++.dg/ubsan/vptr-4.C: New test.\n+\t* g++.dg/ubsan/vptr-5.C: New test.\n+\t* g++.dg/ubsan/vptr-6.C: New test.\n+\t* g++.dg/ubsan/vptr-7.C: New test.\n+\t* g++.dg/ubsan/vptr-8.C: New test.\n+\t* g++.dg/ubsan/vptr-9.C: New test.\n+\n 2015-01-15  Eric Botcazou  <ebotcazou@adacore.com>\n \n \t* lib/c-torture.exp: Compute LTO_TORTURE_OPTIONS after the environment"}, {"sha": "f4260c1ba41363234d33437c6ce4e9cfe3c6ac39", "filename": "gcc/testsuite/g++.dg/ubsan/vptr-1.C", "status": "added", "additions": 184, "deletions": 0, "changes": 184, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/35228ac722036d6e33867d309b5bd837db4a354a/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fubsan%2Fvptr-1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/35228ac722036d6e33867d309b5bd837db4a354a/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fubsan%2Fvptr-1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fubsan%2Fvptr-1.C?ref=35228ac722036d6e33867d309b5bd837db4a354a", "patch": "@@ -0,0 +1,184 @@\n+// { dg-do run { target { ilp32 || lp64 } } }\n+// { dg-options \"-fsanitize=vptr\" }\n+\n+struct S\n+{\n+  S() : a(0) {}\n+  ~S() {}\n+  int a;\n+  int f() { return 0; }\n+  virtual int v() { return 0; }\n+};\n+\n+struct T : S\n+{\n+  T() : b(0) {}\n+  int b;\n+  int g() { return 0; }\n+  virtual int v() { return 1; }\n+};\n+\n+struct U : S, T { virtual int v() { return 2; } }; // { dg-warning \"direct base .S. inaccessible in .U. due to ambiguity\" }\n+struct V : S {};\n+\n+void\n+foo ()\n+{\n+  T t;\n+  (void)t.a;\n+  (void)t.b;\n+  (void)t.f();\n+  (void)t.g();\n+  (void)t.v();\n+  (void)t.S::v();\n+\n+  U u;\n+  (void)u.T::a;\n+  (void)u.b;\n+  (void)u.T::f();\n+  (void)u.g();\n+  (void)u.v();\n+  (void)u.T::v();\n+  (void)((T&)u).S::v();\n+}\n+\n+T *x;\n+\n+__attribute__((noinline, noclone)) int\n+bar (T *p, int q)\n+{\n+  switch (q)\n+    {\n+    // These shouldn't fail:\n+    case 0x10:\n+    case 0x20:\n+    case 0x30:\n+    case 0x40:\n+      {\n+\tT &r = *p;\n+\tbreak;\n+      }\n+    case 0x21:\n+    case 0x31:\n+      return p->b;\n+    case 0x22:\n+    case 0x32:\n+      return p->g ();\n+    case 0x23:\n+    case 0x33:\n+      x = static_cast<T*>(reinterpret_cast<S*>(p));\n+      break;\n+    case 0x44:\n+      return reinterpret_cast<U*>(p)->v() - 2;\n+    // These should:\n+    case 0x11:\n+      return p->b;\n+    // { dg-output \"\\[^\\n\\r]*vptr-1.C:75:\\[0-9]*: runtime error: member access within address 0x\\[0-9a-fA-F]* which does not point to an object of type 'T'(\\n|\\r\\n|\\r)\" }\n+    // { dg-output \"0x\\[0-9a-fA-F]*: note: object is of type 'S'(\\n|\\r\\n|\\r)\" }\n+    // { dg-output \" .. .. .. ..  .. .. .. .. .. .. .. ..  \\[^\\n\\r]*(\\n|\\r\\n|\\r)\" }\n+    // { dg-output \"              \\\\^~~~~~~~~~~\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" }\n+    // { dg-output \"              vptr for 'S'\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" }\n+    case 0x12:\n+      return p->g ();\n+    // { dg-output \"\\[^\\n\\r]*vptr-1.C:82:\\[0-9]*: runtime error: member call on address 0x\\[0-9a-fA-F]* which does not point to an object of type 'T'(\\n|\\r\\n|\\r)\" }\n+    // { dg-output \"0x\\[0-9a-fA-F]*: note: object is of type 'S'(\\n|\\r\\n|\\r)\" }\n+    // { dg-output \" .. .. .. ..  .. .. .. .. .. .. .. ..  \\[^\\n\\r]*(\\n|\\r\\n|\\r)\" }\n+    // { dg-output \"              \\\\^~~~~~~~~~~\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" }\n+    // { dg-output \"              vptr for 'S'\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" }\n+    case 0x13:\n+      x = static_cast<T*>(reinterpret_cast<S*>(p));\n+      break;\n+    // { dg-output \"\\[^\\n\\r]*vptr-1.C:89:\\[0-9]*: runtime error: downcast of address 0x\\[0-9a-fA-F]* which does not point to an object of type 'T'(\\n|\\r\\n|\\r)\" }\n+    // { dg-output \"0x\\[0-9a-fA-F]*: note: object is of type 'S'(\\n|\\r\\n|\\r)\" }\n+    // { dg-output \" .. .. .. ..  .. .. .. .. .. .. .. ..  \\[^\\n\\r]*(\\n|\\r\\n|\\r)\" }\n+    // { dg-output \"              \\\\^~~~~~~~~~~\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" }\n+    // { dg-output \"              vptr for 'S'\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" }\n+    case 0x34:\n+      return reinterpret_cast<U*>(p)->v() - 2;\n+    // { dg-output \"\\[^\\n\\r]*vptr-1.C:97:\\[0-9]*: runtime error: member call on address 0x\\[0-9a-fA-F]* which does not point to an object of type 'U'(\\n|\\r\\n|\\r)\" }\n+    // { dg-output \"0x\\[0-9a-fA-F]*: note: object is base class subobject at offset 16 within object of type 'U'(\\n|\\r\\n|\\r)\" { target lp64 } }\n+    // { dg-output \"0x\\[0-9a-fA-F]*: note: object is base class subobject at offset 8 within object of type 'U'(\\n|\\r\\n|\\r)\" { target ilp32 } }\n+    // { dg-output \" .. .. .. ..  .. .. .. .. .. .. .. ..  .. .. .. .. .. .. .. ..  .. .. .. .. .. .. .. ..  \\[^\\n\\r]*(\\n|\\r\\n|\\r)\" }\n+    // { dg-output \"              \\\\^                                                 ~~~~~~~~~~~~~~~~~~~~~~~(\\n|\\r\\n|\\r)\" { target lp64 } }\n+    // { dg-output \"                                                                vptr for 'T' base class of 'U'\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" { target lp64 } }\n+    // { dg-output \"              \\\\^                        ~~~~~~~~~~~(\\n|\\r\\n|\\r)\" { target ilp32 } }\n+    // { dg-output \"                                       vptr for 'T' base class of 'U'\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" { target ilp32 } }\n+    case 0x41:\n+      return p->b;\n+    // { dg-output \"\\[^\\n\\r]*vptr-1.C:107:\\[0-9]*: runtime error: member access within address 0x\\[0-9a-fA-F]* which does not point to an object of type 'T'(\\n|\\r\\n|\\r)\" }\n+    // { dg-output \"0x\\[0-9a-fA-F]*: note: object is of type 'U'(\\n|\\r\\n|\\r)\" }\n+    // { dg-output \" .. .. .. ..  .. .. .. .. .. .. .. ..  \\[^\\n\\r]*(\\n|\\r\\n|\\r)\" }\n+    // { dg-output \"              \\\\^~~~~~~~~~~\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" }\n+    // { dg-output \"              vptr for 'U'\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" }\n+    case 0x42:\n+      return p->g ();\n+    // { dg-output \"\\[^\\n\\r]*vptr-1.C:114:\\[0-9]*: runtime error: member call on address 0x\\[0-9a-fA-F]* which does not point to an object of type 'T'(\\n|\\r\\n|\\r)\" }\n+    // { dg-output \"0x\\[0-9a-fA-F]*: note: object is of type 'U'(\\n|\\r\\n|\\r)\" }\n+    // { dg-output \" .. .. .. ..  .. .. .. .. .. .. .. ..  \\[^\\n\\r]*(\\n|\\r\\n|\\r)\" }\n+    // { dg-output \"              \\\\^~~~~~~~~~~\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" }\n+    // { dg-output \"              vptr for 'U'\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" }\n+    case 0x43:\n+      x = static_cast<T*>(reinterpret_cast<S*>(p));\n+      break;\n+    // { dg-output \"\\[^\\n\\r]*vptr-1.C:121:\\[0-9]*: runtime error: downcast of address 0x\\[0-9a-fA-F]* which does not point to an object of type 'T'(\\n|\\r\\n|\\r)\" }\n+    // { dg-output \"0x\\[0-9a-fA-F]*: note: object is of type 'U'(\\n|\\r\\n|\\r)\" }\n+    // { dg-output \" .. .. .. ..  .. .. .. .. .. .. .. ..  \\[^\\n\\r]*(\\n|\\r\\n|\\r)\" }\n+    // { dg-output \"              \\\\^~~~~~~~~~~\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" }\n+    // { dg-output \"              vptr for 'U'\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" }\n+    case 0x51:\n+      return p->b;\n+    // { dg-output \"\\[^\\n\\r]*vptr-1.C:129:\\[0-9]*: runtime error: member access within address 0x\\[0-9a-fA-F]* which does not point to an object of type 'T'(\\n|\\r\\n|\\r)\" }\n+    // { dg-output \"0x\\[0-9a-fA-F]*: note: object has invalid vptr(\\n|\\r\\n|\\r)\" }\n+    // { dg-output \" .. .. .. ..  00 00 00 00 00 00 00 00  \\[^\\n\\r]*(\\n|\\r\\n|\\r)\" { target lp64 } }\n+    // { dg-output \"              \\\\^~~~~~~~~~~~~~~~~~~~~~~\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" { target lp64 } }\n+    // { dg-output \"  ?.. .. .. ..  ?00 00 00 00  ?.. .. .. ..  ?\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" { target ilp32 } }\n+    // { dg-output \"              \\\\^~~~~~~~~~~\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" { target ilp32 } }\n+    // { dg-output \"              invalid vptr\" }\n+    }\n+  return 0;\n+}\n+\n+char b[sizeof (U)] __attribute__((aligned (__alignof__ (U)))) = {};\n+\n+__attribute__((noinline, noclone)) void\n+baz (int q)\n+{\n+  T *p = 0;\n+  S *s = 0;\n+  U *u = 0;\n+  switch (q)\n+    {\n+    case 0x10: case 0x11: case 0x12: case 0x13:\n+      s = new S;\n+      bar (reinterpret_cast<T *>(s), q);\n+      delete s;\n+      break;\n+    case 0x20: case 0x21: case 0x22: case 0x23:\n+      p = new T;\n+      bar (p, q);\n+      delete p;\n+      break;\n+    case 0x30: case 0x31: case 0x32: case 0x33: case 0x34:\n+      u = new U;\n+      bar (u, q);\n+      delete u;\n+      break;\n+    case 0x40: case 0x41: case 0x42: case 0x43: case 0x44:\n+      u = new U;\n+      bar (reinterpret_cast<T *>(u), q);\n+      delete u;\n+      break;\n+    case 0x51:\n+      p = reinterpret_cast<T*>(b);\n+      bar (p, q);\n+      break;\n+    }\n+}\n+\n+int\n+main ()\n+{\n+  foo ();\n+  for (int q = 0; q < 0x52; q++)\n+    baz (q);\n+}"}, {"sha": "2aa70469a622f02a5c1ea2d62c5c2aa05e031522", "filename": "gcc/testsuite/g++.dg/ubsan/vptr-2.C", "status": "added", "additions": 184, "deletions": 0, "changes": 184, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/35228ac722036d6e33867d309b5bd837db4a354a/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fubsan%2Fvptr-2.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/35228ac722036d6e33867d309b5bd837db4a354a/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fubsan%2Fvptr-2.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fubsan%2Fvptr-2.C?ref=35228ac722036d6e33867d309b5bd837db4a354a", "patch": "@@ -0,0 +1,184 @@\n+// { dg-do run { target { ilp32 || lp64 } } }\n+// { dg-options \"-fsanitize=vptr\" }\n+\n+struct S\n+{\n+  S() : a(0) {}\n+  ~S() {}\n+  int a;\n+  int f() { return 0; }\n+  virtual int v() { return 0; }\n+};\n+\n+struct T : S\n+{\n+  T() : b(0) {}\n+  int b;\n+  int g() { return 0; }\n+  virtual int v() { return 1; }\n+};\n+\n+struct U : S, T { virtual int v() { return 2; } }; // { dg-warning \"direct base .S. inaccessible in .U. due to ambiguity\" }\n+struct V : S {};\n+\n+void\n+foo ()\n+{\n+  T t;\n+  (void)t.a;\n+  (void)t.b;\n+  (void)t.f();\n+  (void)t.g();\n+  (void)t.v();\n+  (void)t.S::v();\n+\n+  U u;\n+  (void)u.T::a;\n+  (void)u.b;\n+  (void)u.T::f();\n+  (void)u.g();\n+  (void)u.v();\n+  (void)u.T::v();\n+  (void)((T&)u).S::v();\n+}\n+\n+T *x;\n+template <typename S, typename T, typename U>\n+__attribute__((noinline, noclone)) int\n+bar (T *p, int q)\n+{\n+  switch (q)\n+    {\n+    // These shouldn't fail:\n+    case 0x10:\n+    case 0x20:\n+    case 0x30:\n+    case 0x40:\n+      {\n+\tT &r = *p;\n+\tbreak;\n+      }\n+    case 0x21:\n+    case 0x31:\n+      return p->b;\n+    case 0x22:\n+    case 0x32:\n+      return p->g ();\n+    case 0x23:\n+    case 0x33:\n+      x = static_cast<T*>(reinterpret_cast<S*>(p));\n+      break;\n+    case 0x44:\n+      return reinterpret_cast<U*>(p)->v() - 2;\n+    // These should:\n+    case 0x11:\n+      return p->b;\n+    // { dg-output \"\\[^\\n\\r]*vptr-2.C:75:\\[0-9]*: runtime error: member access within address 0x\\[0-9a-fA-F]* which does not point to an object of type 'T'(\\n|\\r\\n|\\r)\" }\n+    // { dg-output \"0x\\[0-9a-fA-F]*: note: object is of type 'S'(\\n|\\r\\n|\\r)\" }\n+    // { dg-output \" .. .. .. ..  .. .. .. .. .. .. .. ..  \\[^\\n\\r]*(\\n|\\r\\n|\\r)\" }\n+    // { dg-output \"              \\\\^~~~~~~~~~~\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" }\n+    // { dg-output \"              vptr for 'S'\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" }\n+    case 0x12:\n+      return p->g ();\n+    // { dg-output \"\\[^\\n\\r]*vptr-2.C:82:\\[0-9]*: runtime error: member call on address 0x\\[0-9a-fA-F]* which does not point to an object of type 'T'(\\n|\\r\\n|\\r)\" }\n+    // { dg-output \"0x\\[0-9a-fA-F]*: note: object is of type 'S'(\\n|\\r\\n|\\r)\" }\n+    // { dg-output \" .. .. .. ..  .. .. .. .. .. .. .. ..  \\[^\\n\\r]*(\\n|\\r\\n|\\r)\" }\n+    // { dg-output \"              \\\\^~~~~~~~~~~\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" }\n+    // { dg-output \"              vptr for 'S'\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" }\n+    case 0x13:\n+      x = static_cast<T*>(reinterpret_cast<S*>(p));\n+      break;\n+    // { dg-output \"\\[^\\n\\r]*vptr-2.C:89:\\[0-9]*: runtime error: downcast of address 0x\\[0-9a-fA-F]* which does not point to an object of type 'T'(\\n|\\r\\n|\\r)\" }\n+    // { dg-output \"0x\\[0-9a-fA-F]*: note: object is of type 'S'(\\n|\\r\\n|\\r)\" }\n+    // { dg-output \" .. .. .. ..  .. .. .. .. .. .. .. ..  \\[^\\n\\r]*(\\n|\\r\\n|\\r)\" }\n+    // { dg-output \"              \\\\^~~~~~~~~~~\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" }\n+    // { dg-output \"              vptr for 'S'\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" }\n+    case 0x34:\n+      return reinterpret_cast<U*>(p)->v() - 2;\n+    // { dg-output \"\\[^\\n\\r]*vptr-2.C:97:\\[0-9]*: runtime error: member call on address 0x\\[0-9a-fA-F]* which does not point to an object of type 'U'(\\n|\\r\\n|\\r)\" }\n+    // { dg-output \"0x\\[0-9a-fA-F]*: note: object is base class subobject at offset 16 within object of type 'U'(\\n|\\r\\n|\\r)\" { target lp64 } }\n+    // { dg-output \"0x\\[0-9a-fA-F]*: note: object is base class subobject at offset 8 within object of type 'U'(\\n|\\r\\n|\\r)\" { target ilp32 } }\n+    // { dg-output \" .. .. .. ..  .. .. .. .. .. .. .. ..  .. .. .. .. .. .. .. ..  .. .. .. .. .. .. .. ..  \\[^\\n\\r]*(\\n|\\r\\n|\\r)\" }\n+    // { dg-output \"              \\\\^                                                 ~~~~~~~~~~~~~~~~~~~~~~~(\\n|\\r\\n|\\r)\" { target lp64 } }\n+    // { dg-output \"                                                                vptr for 'T' base class of 'U'\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" { target lp64 } }\n+    // { dg-output \"              \\\\^                        ~~~~~~~~~~~(\\n|\\r\\n|\\r)\" { target ilp32 } }\n+    // { dg-output \"                                       vptr for 'T' base class of 'U'\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" { target ilp32 } }\n+    case 0x41:\n+      return p->b;\n+    // { dg-output \"\\[^\\n\\r]*vptr-2.C:107:\\[0-9]*: runtime error: member access within address 0x\\[0-9a-fA-F]* which does not point to an object of type 'T'(\\n|\\r\\n|\\r)\" }\n+    // { dg-output \"0x\\[0-9a-fA-F]*: note: object is of type 'U'(\\n|\\r\\n|\\r)\" }\n+    // { dg-output \" .. .. .. ..  .. .. .. .. .. .. .. ..  \\[^\\n\\r]*(\\n|\\r\\n|\\r)\" }\n+    // { dg-output \"              \\\\^~~~~~~~~~~\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" }\n+    // { dg-output \"              vptr for 'U'\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" }\n+    case 0x42:\n+      return p->g ();\n+    // { dg-output \"\\[^\\n\\r]*vptr-2.C:114:\\[0-9]*: runtime error: member call on address 0x\\[0-9a-fA-F]* which does not point to an object of type 'T'(\\n|\\r\\n|\\r)\" }\n+    // { dg-output \"0x\\[0-9a-fA-F]*: note: object is of type 'U'(\\n|\\r\\n|\\r)\" }\n+    // { dg-output \" .. .. .. ..  .. .. .. .. .. .. .. ..  \\[^\\n\\r]*(\\n|\\r\\n|\\r)\" }\n+    // { dg-output \"              \\\\^~~~~~~~~~~\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" }\n+    // { dg-output \"              vptr for 'U'\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" }\n+    case 0x43:\n+      x = static_cast<T*>(reinterpret_cast<S*>(p));\n+      break;\n+    // { dg-output \"\\[^\\n\\r]*vptr-2.C:121:\\[0-9]*: runtime error: downcast of address 0x\\[0-9a-fA-F]* which does not point to an object of type 'T'(\\n|\\r\\n|\\r)\" }\n+    // { dg-output \"0x\\[0-9a-fA-F]*: note: object is of type 'U'(\\n|\\r\\n|\\r)\" }\n+    // { dg-output \" .. .. .. ..  .. .. .. .. .. .. .. ..  \\[^\\n\\r]*(\\n|\\r\\n|\\r)\" }\n+    // { dg-output \"              \\\\^~~~~~~~~~~\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" }\n+    // { dg-output \"              vptr for 'U'\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" }\n+    case 0x51:\n+      return p->b;\n+    // { dg-output \"\\[^\\n\\r]*vptr-2.C:129:\\[0-9]*: runtime error: member access within address 0x\\[0-9a-fA-F]* which does not point to an object of type 'T'(\\n|\\r\\n|\\r)\" }\n+    // { dg-output \"0x\\[0-9a-fA-F]*: note: object has invalid vptr(\\n|\\r\\n|\\r)\" }\n+    // { dg-output \" .. .. .. ..  00 00 00 00 00 00 00 00  \\[^\\n\\r]*(\\n|\\r\\n|\\r)\" { target lp64 } }\n+    // { dg-output \"              \\\\^~~~~~~~~~~~~~~~~~~~~~~\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" { target lp64 } }\n+    // { dg-output \"  ?.. .. .. ..  ?00 00 00 00  ?.. .. .. ..  ?\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" { target ilp32 } }\n+    // { dg-output \"              \\\\^~~~~~~~~~~\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" { target ilp32 } }\n+    // { dg-output \"              invalid vptr\" }\n+    }\n+  return 0;\n+}\n+\n+char b[sizeof (U)] __attribute__((aligned (__alignof__ (U)))) = {};\n+\n+__attribute__((noinline, noclone)) void\n+baz (int q)\n+{\n+  T *p = 0;\n+  S *s = 0;\n+  U *u = 0;\n+  switch (q)\n+    {\n+    case 0x10: case 0x11: case 0x12: case 0x13:\n+      s = new S;\n+      bar<S, T, U> (reinterpret_cast<T *>(s), q);\n+      delete s;\n+      break;\n+    case 0x20: case 0x21: case 0x22: case 0x23:\n+      p = new T;\n+      bar<S, T, U> (p, q);\n+      delete p;\n+      break;\n+    case 0x30: case 0x31: case 0x32: case 0x33: case 0x34:\n+      u = new U;\n+      bar<S, T, U> (u, q);\n+      delete u;\n+      break;\n+    case 0x40: case 0x41: case 0x42: case 0x43: case 0x44:\n+      u = new U;\n+      bar<S, T, U> (reinterpret_cast<T *>(u), q);\n+      delete u;\n+      break;\n+    case 0x51:\n+      p = reinterpret_cast<T*>(b);\n+      bar<S, T, U> (p, q);\n+      break;\n+    }\n+}\n+\n+int\n+main ()\n+{\n+  foo ();\n+  for (int q = 0; q < 0x52; q++)\n+    baz (q);\n+}"}, {"sha": "916d8ef8e280a4a2e9389bfb8c2c4eae4fd22d0d", "filename": "gcc/testsuite/g++.dg/ubsan/vptr-3.C", "status": "added", "additions": 184, "deletions": 0, "changes": 184, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/35228ac722036d6e33867d309b5bd837db4a354a/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fubsan%2Fvptr-3.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/35228ac722036d6e33867d309b5bd837db4a354a/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fubsan%2Fvptr-3.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fubsan%2Fvptr-3.C?ref=35228ac722036d6e33867d309b5bd837db4a354a", "patch": "@@ -0,0 +1,184 @@\n+// { dg-do run { target { ilp32 || lp64 } } }\n+// { dg-options \"-fsanitize=vptr\" }\n+\n+struct S\n+{\n+  S() : a(0) {}\n+  ~S() {}\n+  int a;\n+  int f() { return 0; }\n+  virtual int v() { return 0; }\n+};\n+\n+struct T : S\n+{\n+  T() : b(0) {}\n+  int b;\n+  int g() { return 0; }\n+  virtual int v() { return 1; }\n+};\n+\n+struct U : S, T { virtual int v() { return 2; } }; // { dg-warning \"direct base .S. inaccessible in .U. due to ambiguity\" }\n+struct V : S {};\n+\n+void\n+foo ()\n+{\n+  T t;\n+  (void)t.a;\n+  (void)t.b;\n+  (void)t.f();\n+  (void)t.g();\n+  (void)t.v();\n+  (void)t.S::v();\n+\n+  U u;\n+  (void)u.T::a;\n+  (void)u.b;\n+  (void)u.T::f();\n+  (void)u.g();\n+  (void)u.v();\n+  (void)u.T::v();\n+  (void)((T&)u).S::v();\n+}\n+\n+T *x;\n+template <int N>\n+__attribute__((noinline, noclone)) int\n+bar (T *p, int q)\n+{\n+  switch (q)\n+    {\n+    // These shouldn't fail:\n+    case 0x10:\n+    case 0x20:\n+    case 0x30:\n+    case 0x40:\n+      {\n+\tT &r = *p;\n+\tbreak;\n+      }\n+    case 0x21:\n+    case 0x31:\n+      return p->b;\n+    case 0x22:\n+    case 0x32:\n+      return p->g ();\n+    case 0x23:\n+    case 0x33:\n+      x = static_cast<T*>(reinterpret_cast<S*>(p));\n+      break;\n+    case 0x44:\n+      return reinterpret_cast<U*>(p)->v() - 2;\n+    // These should:\n+    case 0x11:\n+      return p->b;\n+    // { dg-output \"\\[^\\n\\r]*vptr-3.C:75:\\[0-9]*: runtime error: member access within address 0x\\[0-9a-fA-F]* which does not point to an object of type 'T'(\\n|\\r\\n|\\r)\" }\n+    // { dg-output \"0x\\[0-9a-fA-F]*: note: object is of type 'S'(\\n|\\r\\n|\\r)\" }\n+    // { dg-output \" .. .. .. ..  .. .. .. .. .. .. .. ..  \\[^\\n\\r]*(\\n|\\r\\n|\\r)\" }\n+    // { dg-output \"              \\\\^~~~~~~~~~~\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" }\n+    // { dg-output \"              vptr for 'S'\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" }\n+    case 0x12:\n+      return p->g ();\n+    // { dg-output \"\\[^\\n\\r]*vptr-3.C:82:\\[0-9]*: runtime error: member call on address 0x\\[0-9a-fA-F]* which does not point to an object of type 'T'(\\n|\\r\\n|\\r)\" }\n+    // { dg-output \"0x\\[0-9a-fA-F]*: note: object is of type 'S'(\\n|\\r\\n|\\r)\" }\n+    // { dg-output \" .. .. .. ..  .. .. .. .. .. .. .. ..  \\[^\\n\\r]*(\\n|\\r\\n|\\r)\" }\n+    // { dg-output \"              \\\\^~~~~~~~~~~\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" }\n+    // { dg-output \"              vptr for 'S'\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" }\n+    case 0x13:\n+      x = static_cast<T*>(reinterpret_cast<S*>(p));\n+      break;\n+    // { dg-output \"\\[^\\n\\r]*vptr-3.C:89:\\[0-9]*: runtime error: downcast of address 0x\\[0-9a-fA-F]* which does not point to an object of type 'T'(\\n|\\r\\n|\\r)\" }\n+    // { dg-output \"0x\\[0-9a-fA-F]*: note: object is of type 'S'(\\n|\\r\\n|\\r)\" }\n+    // { dg-output \" .. .. .. ..  .. .. .. .. .. .. .. ..  \\[^\\n\\r]*(\\n|\\r\\n|\\r)\" }\n+    // { dg-output \"              \\\\^~~~~~~~~~~\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" }\n+    // { dg-output \"              vptr for 'S'\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" }\n+    case 0x34:\n+      return reinterpret_cast<U*>(p)->v() - 2;\n+    // { dg-output \"\\[^\\n\\r]*vptr-3.C:97:\\[0-9]*: runtime error: member call on address 0x\\[0-9a-fA-F]* which does not point to an object of type 'U'(\\n|\\r\\n|\\r)\" }\n+    // { dg-output \"0x\\[0-9a-fA-F]*: note: object is base class subobject at offset 16 within object of type 'U'(\\n|\\r\\n|\\r)\" { target lp64 } }\n+    // { dg-output \"0x\\[0-9a-fA-F]*: note: object is base class subobject at offset 8 within object of type 'U'(\\n|\\r\\n|\\r)\" { target ilp32 } }\n+    // { dg-output \" .. .. .. ..  .. .. .. .. .. .. .. ..  .. .. .. .. .. .. .. ..  .. .. .. .. .. .. .. ..  \\[^\\n\\r]*(\\n|\\r\\n|\\r)\" }\n+    // { dg-output \"              \\\\^                                                 ~~~~~~~~~~~~~~~~~~~~~~~(\\n|\\r\\n|\\r)\" { target lp64 } }\n+    // { dg-output \"                                                                vptr for 'T' base class of 'U'\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" { target lp64 } }\n+    // { dg-output \"              \\\\^                        ~~~~~~~~~~~(\\n|\\r\\n|\\r)\" { target ilp32 } }\n+    // { dg-output \"                                       vptr for 'T' base class of 'U'\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" { target ilp32 } }\n+    case 0x41:\n+      return p->b;\n+    // { dg-output \"\\[^\\n\\r]*vptr-3.C:107:\\[0-9]*: runtime error: member access within address 0x\\[0-9a-fA-F]* which does not point to an object of type 'T'(\\n|\\r\\n|\\r)\" }\n+    // { dg-output \"0x\\[0-9a-fA-F]*: note: object is of type 'U'(\\n|\\r\\n|\\r)\" }\n+    // { dg-output \" .. .. .. ..  .. .. .. .. .. .. .. ..  \\[^\\n\\r]*(\\n|\\r\\n|\\r)\" }\n+    // { dg-output \"              \\\\^~~~~~~~~~~\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" }\n+    // { dg-output \"              vptr for 'U'\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" }\n+    case 0x42:\n+      return p->g ();\n+    // { dg-output \"\\[^\\n\\r]*vptr-3.C:114:\\[0-9]*: runtime error: member call on address 0x\\[0-9a-fA-F]* which does not point to an object of type 'T'(\\n|\\r\\n|\\r)\" }\n+    // { dg-output \"0x\\[0-9a-fA-F]*: note: object is of type 'U'(\\n|\\r\\n|\\r)\" }\n+    // { dg-output \" .. .. .. ..  .. .. .. .. .. .. .. ..  \\[^\\n\\r]*(\\n|\\r\\n|\\r)\" }\n+    // { dg-output \"              \\\\^~~~~~~~~~~\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" }\n+    // { dg-output \"              vptr for 'U'\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" }\n+    case 0x43:\n+      x = static_cast<T*>(reinterpret_cast<S*>(p));\n+      break;\n+    // { dg-output \"\\[^\\n\\r]*vptr-3.C:121:\\[0-9]*: runtime error: downcast of address 0x\\[0-9a-fA-F]* which does not point to an object of type 'T'(\\n|\\r\\n|\\r)\" }\n+    // { dg-output \"0x\\[0-9a-fA-F]*: note: object is of type 'U'(\\n|\\r\\n|\\r)\" }\n+    // { dg-output \" .. .. .. ..  .. .. .. .. .. .. .. ..  \\[^\\n\\r]*(\\n|\\r\\n|\\r)\" }\n+    // { dg-output \"              \\\\^~~~~~~~~~~\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" }\n+    // { dg-output \"              vptr for 'U'\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" }\n+    case 0x51:\n+      return p->b;\n+    // { dg-output \"\\[^\\n\\r]*vptr-3.C:129:\\[0-9]*: runtime error: member access within address 0x\\[0-9a-fA-F]* which does not point to an object of type 'T'(\\n|\\r\\n|\\r)\" }\n+    // { dg-output \"0x\\[0-9a-fA-F]*: note: object has invalid vptr(\\n|\\r\\n|\\r)\" }\n+    // { dg-output \" .. .. .. ..  00 00 00 00 00 00 00 00  \\[^\\n\\r]*(\\n|\\r\\n|\\r)\" { target lp64 } }\n+    // { dg-output \"              \\\\^~~~~~~~~~~~~~~~~~~~~~~\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" { target lp64 } }\n+    // { dg-output \"  ?.. .. .. ..  ?00 00 00 00  ?.. .. .. ..  ?\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" { target ilp32 } }\n+    // { dg-output \"              \\\\^~~~~~~~~~~\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" { target ilp32 } }\n+    // { dg-output \"              invalid vptr\" }\n+    }\n+  return 0;\n+}\n+\n+char b[sizeof (U)] __attribute__((aligned (__alignof__ (U)))) = {};\n+\n+__attribute__((noinline, noclone)) void\n+baz (int q)\n+{\n+  T *p = 0;\n+  S *s = 0;\n+  U *u = 0;\n+  switch (q)\n+    {\n+    case 0x10: case 0x11: case 0x12: case 0x13:\n+      s = new S;\n+      bar<0> (reinterpret_cast<T *>(s), q);\n+      delete s;\n+      break;\n+    case 0x20: case 0x21: case 0x22: case 0x23:\n+      p = new T;\n+      bar<0> (p, q);\n+      delete p;\n+      break;\n+    case 0x30: case 0x31: case 0x32: case 0x33: case 0x34:\n+      u = new U;\n+      bar<0> (u, q);\n+      delete u;\n+      break;\n+    case 0x40: case 0x41: case 0x42: case 0x43: case 0x44:\n+      u = new U;\n+      bar<0> (reinterpret_cast<T *>(u), q);\n+      delete u;\n+      break;\n+    case 0x51:\n+      p = reinterpret_cast<T*>(b);\n+      bar<0> (p, q);\n+      break;\n+    }\n+}\n+\n+int\n+main ()\n+{\n+  foo ();\n+  for (int q = 0; q < 0x52; q++)\n+    baz (q);\n+}"}, {"sha": "1c037d047dd1c19045f9a445c4ada9500dd86d43", "filename": "gcc/testsuite/g++.dg/ubsan/vptr-4.C", "status": "added", "additions": 54, "deletions": 0, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/35228ac722036d6e33867d309b5bd837db4a354a/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fubsan%2Fvptr-4.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/35228ac722036d6e33867d309b5bd837db4a354a/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fubsan%2Fvptr-4.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fubsan%2Fvptr-4.C?ref=35228ac722036d6e33867d309b5bd837db4a354a", "patch": "@@ -0,0 +1,54 @@\n+// Verify that -fsanitize=vptr downcast instrumentation works properly\n+// inside of constexpr.\n+// { dg-do compile }\n+// { dg-options \"-std=c++11 -fsanitize=vptr\" }\n+\n+struct S {\n+  constexpr S() : a(0) {}\n+  int a;\n+  int f() { return 0; }\n+  virtual int v() { return 0; }\n+};\n+\n+struct T : S {\n+  constexpr T() : b(0) {}\n+  int b;\n+  int g() { return 0; }\n+  virtual int v() { return 1; }\n+  constexpr const T *foo() { return (const T *) reinterpret_cast<const S *> (this); }\n+};\n+\n+constexpr T t;\n+constexpr const T *p = t.foo ();\n+\n+template <typename U>\n+struct V {\n+  constexpr V() : a(0) {}\n+  int a;\n+  int f() { return 0; }\n+  virtual int v() { return 0; }\n+};\n+\n+template <typename U>\n+struct W : V<U> {\n+  constexpr W() : b(0) {}\n+  int b;\n+  int g() { return 0; }\n+  virtual int v() { return 1; }\n+  constexpr const W<U> *foo() { return (const W<U> *) reinterpret_cast<const V<U> *> (this); }\n+};\n+\n+constexpr W<int> w;\n+constexpr const W<int> *s = w.foo ();\n+\n+template <typename U>\n+int foo (void)\n+{\n+  static constexpr T t;\n+  static constexpr const T *p = t.foo ();\n+  static constexpr W<U> w;\n+  static constexpr const W<U> *s = w.foo ();\n+  return t.b + w.b;\n+}\n+\n+int x = foo <char> ();"}, {"sha": "fb9d15cc99ef7eb88b9b0f1e11e536ec090bae4b", "filename": "gcc/testsuite/g++.dg/ubsan/vptr-5.C", "status": "added", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/35228ac722036d6e33867d309b5bd837db4a354a/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fubsan%2Fvptr-5.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/35228ac722036d6e33867d309b5bd837db4a354a/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fubsan%2Fvptr-5.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fubsan%2Fvptr-5.C?ref=35228ac722036d6e33867d309b5bd837db4a354a", "patch": "@@ -0,0 +1,32 @@\n+// { dg-do run }\n+// { dg-options \"-fsanitize=vptr\" }\n+\n+struct S\n+{\n+  S() : a(0) {}\n+  ~S() {}\n+  int a;\n+  int f() { return 0; }\n+  virtual int v() { return 0; }\n+};\n+\n+struct T : S\n+{\n+  T() : b(0) {}\n+  int b;\n+  int g() { return 0; }\n+  virtual int v() { return 1; }\n+};\n+\n+T *\n+foo (S *p)\n+{\n+  return (T *) p;\n+}\n+\n+int\n+main ()\n+{\n+  if (foo (__null) != __null)\n+    __builtin_abort ();\n+}"}, {"sha": "1e595c50c9e4b3a4f06a493fdfe3e0d80ed6f217", "filename": "gcc/testsuite/g++.dg/ubsan/vptr-6.C", "status": "added", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/35228ac722036d6e33867d309b5bd837db4a354a/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fubsan%2Fvptr-6.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/35228ac722036d6e33867d309b5bd837db4a354a/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fubsan%2Fvptr-6.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fubsan%2Fvptr-6.C?ref=35228ac722036d6e33867d309b5bd837db4a354a", "patch": "@@ -0,0 +1,32 @@\n+// { dg-do compile }\n+// { dg-skip-if \"\" { *-*-* } { \"-flto\" } { \"\" } }\n+// { dg-options \"-fsanitize=vptr -O2 -fdump-tree-optimized\" }\n+\n+struct S { virtual ~S (); int i; _Complex int j[5]; };\n+\n+int\n+f1 (S *p)\n+{\n+  return p->i;\n+}\n+\n+int\n+f2 (S *p)\n+{\n+  return *&p->i;\n+}\n+\n+_Complex int *\n+f3 (S *p, S *q)\n+{\n+  return &p->j[q->i];\n+}\n+\n+int\n+f4 (S &p, S &q)\n+{\n+  return __imag__ p.j[q.i];\n+}\n+\n+// { dg-final { scan-tree-dump-times \"__ubsan_handle_dynamic_type_cache_miss\" 5 \"optimized\" } }\n+// { dg-final { cleanup-tree-dump \"optimized\" } }"}, {"sha": "d3ff1a36d5b60ad9b75afe67b26958e50f97c0c5", "filename": "gcc/testsuite/g++.dg/ubsan/vptr-7.C", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/35228ac722036d6e33867d309b5bd837db4a354a/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fubsan%2Fvptr-7.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/35228ac722036d6e33867d309b5bd837db4a354a/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fubsan%2Fvptr-7.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fubsan%2Fvptr-7.C?ref=35228ac722036d6e33867d309b5bd837db4a354a", "patch": "@@ -0,0 +1,26 @@\n+// { dg-do compile }\n+// { dg-skip-if \"\" { *-*-* } { \"-flto\" } { \"\" } }\n+// { dg-options \"-fsanitize=vptr -O2 -fdump-tree-optimized\" }\n+\n+struct S { virtual ~S (); int i; };\n+\n+int *\n+f1 (S *p)\n+{\n+  return &p->i;\n+}\n+\n+int *\n+f2 (S *p)\n+{\n+  return &*&p->i;\n+}\n+\n+int &\n+f3 (S *p)\n+{\n+  return p->i;\n+}\n+\n+// { dg-final { scan-tree-dump-times \"__ubsan_handle_dynamic_type_cache_miss\" 0 \"optimized\" } }\n+// { dg-final { cleanup-tree-dump \"optimized\" } }"}, {"sha": "1533f20f1f1ca03fce1d86e782a450b1bd135163", "filename": "gcc/testsuite/g++.dg/ubsan/vptr-8.C", "status": "added", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/35228ac722036d6e33867d309b5bd837db4a354a/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fubsan%2Fvptr-8.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/35228ac722036d6e33867d309b5bd837db4a354a/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fubsan%2Fvptr-8.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fubsan%2Fvptr-8.C?ref=35228ac722036d6e33867d309b5bd837db4a354a", "patch": "@@ -0,0 +1,32 @@\n+// { dg-do run }\n+// { dg-shouldfail \"ubsan\" }\n+// { dg-options \"-fsanitize=vptr -fno-sanitize-recover=vptr\" }\n+\n+extern \"C\" void abort ();\n+\n+struct S { virtual void f () {} };\n+struct T : S { ~T (); };\n+struct U : S { };\n+struct V : T, virtual U {};\n+\n+U *up;\n+V *vp;\n+\n+int\n+main ()\n+{\n+  V v;\n+  up = vp = &v;\n+}\n+\n+T::~T ()\n+{\n+  if (vp != up)\n+   abort ();\n+}\n+\n+// { dg-output \"\\[^\\n\\r]*vptr-8.C:24:\\[0-9]*: runtime error: cast to virtual base of address 0x\\[0-9a-fA-F]* which does not point to an object of type 'V'(\\n|\\r\\n|\\r)\" }\n+// { dg-output \"0x\\[0-9a-fA-F]*: note: object is of type 'T'(\\n|\\r\\n|\\r)\" }\n+// { dg-output \"  ?.. .. .. ..  ?.. .. .. ..  ?.. .. .. .. \\[^\\n\\r]*(\\n|\\r\\n|\\r)\" }\n+// { dg-output \"              ?\\\\^~~~~~~~~~~\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" }\n+// { dg-output \"              ?vptr for 'T'\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" }"}, {"sha": "482e3e6030d8157e15cf9b290199db2426f7a11b", "filename": "gcc/testsuite/g++.dg/ubsan/vptr-9.C", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/35228ac722036d6e33867d309b5bd837db4a354a/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fubsan%2Fvptr-9.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/35228ac722036d6e33867d309b5bd837db4a354a/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fubsan%2Fvptr-9.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fubsan%2Fvptr-9.C?ref=35228ac722036d6e33867d309b5bd837db4a354a", "patch": "@@ -0,0 +1,22 @@\n+// { dg-do run }\n+// { dg-shouldfail \"ubsan\" }\n+// { dg-options \"-fsanitize=vptr -fno-sanitize-recover=undefined\" }\n+\n+struct S { virtual int f () { return 0; } };\n+struct T : virtual S {};\n+struct U { virtual int f () { return 0; } };\n+\n+int\n+main ()\n+{\n+  U u;\n+  T *t = (T *) &u;\n+  S *s = t;\n+  return s->f ();\n+}\n+\n+// { dg-output \"\\[^\\n\\r]*vptr-9.C:14:\\[0-9]*: runtime error: cast to virtual base of address 0x\\[0-9a-fA-F]* which does not point to an object of type 'T'(\\n|\\r\\n|\\r)\" }\n+// { dg-output \"0x\\[0-9a-fA-F]*: note: object is of type 'U'(\\n|\\r\\n|\\r)\" }\n+// { dg-output \"  ?.. .. .. ..  ?.. .. .. ..  ?.. .. .. .. \\[^\\n\\r]*(\\n|\\r\\n|\\r)\" }\n+// { dg-output \"              ?\\\\^~~~~~~~~~~\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" }\n+// { dg-output \"              ?vptr for 'U'\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" }"}, {"sha": "fa6caef21e185cac61cdbea24394a62ed21c0524", "filename": "gcc/tree-ssa-alias.c", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/35228ac722036d6e33867d309b5bd837db4a354a/gcc%2Ftree-ssa-alias.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/35228ac722036d6e33867d309b5bd837db4a354a/gcc%2Ftree-ssa-alias.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-alias.c?ref=35228ac722036d6e33867d309b5bd837db4a354a", "patch": "@@ -1929,6 +1929,22 @@ call_may_clobber_ref_p_1 (gcall *call, ao_ref *ref)\n   if (gimple_call_flags (call)\n       & (ECF_PURE|ECF_CONST|ECF_LOOPING_CONST_OR_PURE|ECF_NOVOPS))\n     return false;\n+  if (gimple_call_internal_p (call))\n+    switch (gimple_call_internal_fn (call))\n+      {\n+\t/* Treat these internal calls like ECF_PURE for aliasing,\n+\t   they don't write to any memory the program should care about.\n+\t   They have important other side-effects, and read memory,\n+\t   so can't be ECF_NOVOPS.  */\n+      case IFN_UBSAN_NULL:\n+      case IFN_UBSAN_BOUNDS:\n+      case IFN_UBSAN_VPTR:\n+      case IFN_UBSAN_OBJECT_SIZE:\n+      case IFN_ASAN_CHECK:\n+\treturn false;\n+      default:\n+\tbreak;\n+      }\n \n   base = ao_ref_base (ref);\n   if (!base)"}, {"sha": "5bf53276d7dc0a11888d184868832cfcd019861f", "filename": "gcc/ubsan.c", "status": "modified", "additions": 161, "deletions": 0, "changes": 161, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/35228ac722036d6e33867d309b5bd837db4a354a/gcc%2Fubsan.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/35228ac722036d6e33867d309b5bd837db4a354a/gcc%2Fubsan.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fubsan.c?ref=35228ac722036d6e33867d309b5bd837db4a354a", "patch": "@@ -981,6 +981,167 @@ ubsan_expand_objsize_ifn (gimple_stmt_iterator *gsi)\n   return gsi_end_p (*gsi);\n }\n \n+/* Cached __ubsan_vptr_type_cache decl.  */\n+static GTY(()) tree ubsan_vptr_type_cache_decl;\n+\n+/* Expand UBSAN_VPTR internal call.  The type is kept on the ckind\n+   argument which is a constant, because the middle-end treats pointer\n+   conversions as useless and therefore the type of the first argument\n+   could be changed to any other pointer type.  */\n+\n+bool\n+ubsan_expand_vptr_ifn (gimple_stmt_iterator *gsip)\n+{\n+  gimple_stmt_iterator gsi = *gsip;\n+  gimple stmt = gsi_stmt (gsi);\n+  location_t loc = gimple_location (stmt);\n+  gcc_assert (gimple_call_num_args (stmt) == 5);\n+  tree op = gimple_call_arg (stmt, 0);\n+  tree vptr = gimple_call_arg (stmt, 1);\n+  tree str_hash = gimple_call_arg (stmt, 2);\n+  tree ti_decl_addr = gimple_call_arg (stmt, 3);\n+  tree ckind_tree = gimple_call_arg (stmt, 4);\n+  ubsan_null_ckind ckind = (ubsan_null_ckind) tree_to_uhwi (ckind_tree);\n+  tree type = TREE_TYPE (TREE_TYPE (ckind_tree));\n+  gimple g;\n+  basic_block fallthru_bb = NULL;\n+\n+  if (ckind == UBSAN_DOWNCAST_POINTER)\n+    {\n+      /* Guard everything with if (op != NULL) { ... }.  */\n+      basic_block then_bb;\n+      gimple_stmt_iterator cond_insert_point\n+\t= create_cond_insert_point (gsip, false, false, true,\n+\t\t\t\t    &then_bb, &fallthru_bb);\n+      g = gimple_build_cond (NE_EXPR, op, build_zero_cst (TREE_TYPE (op)),\n+\t\t\t     NULL_TREE, NULL_TREE);\n+      gimple_set_location (g, loc);\n+      gsi_insert_after (&cond_insert_point, g, GSI_NEW_STMT);\n+      *gsip = gsi_after_labels (then_bb);\n+      gsi_remove (&gsi, false);\n+      gsi_insert_before (gsip, stmt, GSI_NEW_STMT);\n+      gsi = *gsip;\n+    }\n+\n+  tree htype = TREE_TYPE (str_hash);\n+  tree cst = wide_int_to_tree (htype,\n+\t\t\t       wi::uhwi (((uint64_t) 0x9ddfea08 << 32)\n+\t\t\t       | 0xeb382d69, 64));\n+  g = gimple_build_assign (make_ssa_name (htype), BIT_XOR_EXPR,\n+\t\t\t   vptr, str_hash);\n+  gimple_set_location (g, loc);\n+  gsi_insert_before (gsip, g, GSI_SAME_STMT);\n+  g = gimple_build_assign (make_ssa_name (htype), MULT_EXPR,\n+\t\t\t   gimple_assign_lhs (g), cst);\n+  gimple_set_location (g, loc);\n+  gsi_insert_before (gsip, g, GSI_SAME_STMT);\n+  tree t1 = gimple_assign_lhs (g);\n+  g = gimple_build_assign (make_ssa_name (htype), LSHIFT_EXPR,\n+\t\t\t   t1, build_int_cst (integer_type_node, 47));\n+  gimple_set_location (g, loc);\n+  tree t2 = gimple_assign_lhs (g);\n+  gsi_insert_before (gsip, g, GSI_SAME_STMT);\n+  g = gimple_build_assign (make_ssa_name (htype), BIT_XOR_EXPR,\n+\t\t\t   vptr, t1);\n+  gimple_set_location (g, loc);\n+  gsi_insert_before (gsip, g, GSI_SAME_STMT);\n+  g = gimple_build_assign (make_ssa_name (htype), BIT_XOR_EXPR,\n+\t\t\t   t2, gimple_assign_lhs (g));\n+  gimple_set_location (g, loc);\n+  gsi_insert_before (gsip, g, GSI_SAME_STMT);\n+  g = gimple_build_assign (make_ssa_name (htype), MULT_EXPR,\n+\t\t\t   gimple_assign_lhs (g), cst);\n+  gimple_set_location (g, loc);\n+  gsi_insert_before (gsip, g, GSI_SAME_STMT);\n+  tree t3 = gimple_assign_lhs (g);\n+  g = gimple_build_assign (make_ssa_name (htype), LSHIFT_EXPR,\n+\t\t\t   t3, build_int_cst (integer_type_node, 47));\n+  gimple_set_location (g, loc);\n+  gsi_insert_before (gsip, g, GSI_SAME_STMT);\n+  g = gimple_build_assign (make_ssa_name (htype), BIT_XOR_EXPR,\n+\t\t\t   t3, gimple_assign_lhs (g));\n+  gimple_set_location (g, loc);\n+  gsi_insert_before (gsip, g, GSI_SAME_STMT);\n+  g = gimple_build_assign (make_ssa_name (htype), MULT_EXPR,\n+\t\t\t   gimple_assign_lhs (g), cst);\n+  gimple_set_location (g, loc);\n+  gsi_insert_before (gsip, g, GSI_SAME_STMT);\n+  if (!useless_type_conversion_p (pointer_sized_int_node, htype))\n+    {\n+      g = gimple_build_assign (make_ssa_name (pointer_sized_int_node),\n+\t\t\t       NOP_EXPR, gimple_assign_lhs (g));\n+      gimple_set_location (g, loc);\n+      gsi_insert_before (gsip, g, GSI_SAME_STMT);\n+    }\n+  tree hash = gimple_assign_lhs (g);\n+\n+  if (ubsan_vptr_type_cache_decl == NULL_TREE)\n+    {\n+      tree atype = build_array_type_nelts (pointer_sized_int_node, 128);\n+      tree array = build_decl (UNKNOWN_LOCATION, VAR_DECL,\n+\t\t\t       get_identifier (\"__ubsan_vptr_type_cache\"),\n+\t\t\t       atype);\n+      DECL_ARTIFICIAL (array) = 1;\n+      DECL_IGNORED_P (array) = 1;\n+      TREE_PUBLIC (array) = 1;\n+      TREE_STATIC (array) = 1;\n+      DECL_EXTERNAL (array) = 1;\n+      DECL_VISIBILITY (array) = VISIBILITY_DEFAULT;\n+      DECL_VISIBILITY_SPECIFIED (array) = 1;\n+      varpool_node::finalize_decl (array);\n+      ubsan_vptr_type_cache_decl = array;\n+   }\n+\n+  g = gimple_build_assign (make_ssa_name (pointer_sized_int_node),\n+\t\t\t   BIT_AND_EXPR, hash,\n+\t\t\t   build_int_cst (pointer_sized_int_node, 127));\n+  gimple_set_location (g, loc);\n+  gsi_insert_before (gsip, g, GSI_SAME_STMT);\n+\n+  tree c = build4_loc (loc, ARRAY_REF, pointer_sized_int_node,\n+\t\t       ubsan_vptr_type_cache_decl, gimple_assign_lhs (g),\n+\t\t       NULL_TREE, NULL_TREE);\n+  g = gimple_build_assign (make_ssa_name (pointer_sized_int_node),\n+\t\t\t   ARRAY_REF, c);\n+  gimple_set_location (g, loc);\n+  gsi_insert_before (gsip, g, GSI_SAME_STMT);\n+\n+  basic_block then_bb, fallthru2_bb;\n+  gimple_stmt_iterator cond_insert_point\n+    = create_cond_insert_point (gsip, false, false, true,\n+\t\t\t\t&then_bb, &fallthru2_bb);\n+  g = gimple_build_cond (NE_EXPR, gimple_assign_lhs (g), hash,\n+\t\t\t NULL_TREE, NULL_TREE);\n+  gimple_set_location (g, loc);\n+  gsi_insert_after (&cond_insert_point, g, GSI_NEW_STMT);\n+  *gsip = gsi_after_labels (then_bb);\n+  if (fallthru_bb == NULL)\n+    fallthru_bb = fallthru2_bb;\n+\n+  tree data\n+    = ubsan_create_data (\"__ubsan_vptr_data\", 1, &loc,\n+\t\t\t ubsan_type_descriptor (type), NULL_TREE, ti_decl_addr,\n+\t\t\t build_int_cst (unsigned_char_type_node, ckind),\n+\t\t\t NULL_TREE);\n+  data = build_fold_addr_expr_loc (loc, data);\n+  enum built_in_function bcode\n+    = (flag_sanitize_recover & SANITIZE_VPTR)\n+      ? BUILT_IN_UBSAN_HANDLE_DYNAMIC_TYPE_CACHE_MISS\n+      : BUILT_IN_UBSAN_HANDLE_DYNAMIC_TYPE_CACHE_MISS_ABORT;\n+\n+  g = gimple_build_call (builtin_decl_explicit (bcode), 3, data, op, hash);\n+  gimple_set_location (g, loc);\n+  gsi_insert_before (gsip, g, GSI_SAME_STMT);\n+\n+  /* Point GSI to next logical statement.  */\n+  *gsip = gsi_start_bb (fallthru_bb);\n+\n+  /* Get rid of the UBSAN_VPTR call from the IR.  */\n+  unlink_stmt_vdef (stmt);\n+  gsi_remove (&gsi, true);\n+  return gsi_end_p (*gsip);\n+}\n+\n /* Instrument a memory reference.  BASE is the base of MEM, IS_LHS says\n    whether the pointer is on the left hand side of the assignment.  */\n "}, {"sha": "9f23a382ec08b079937526b23af3dc8ea23990d8", "filename": "gcc/ubsan.h", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/35228ac722036d6e33867d309b5bd837db4a354a/gcc%2Fubsan.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/35228ac722036d6e33867d309b5bd837db4a354a/gcc%2Fubsan.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fubsan.h?ref=35228ac722036d6e33867d309b5bd837db4a354a", "patch": "@@ -28,7 +28,11 @@ enum ubsan_null_ckind {\n   UBSAN_REF_BINDING,\n   UBSAN_MEMBER_ACCESS,\n   UBSAN_MEMBER_CALL,\n-  UBSAN_CTOR_CALL\n+  UBSAN_CTOR_CALL,\n+  UBSAN_DOWNCAST_POINTER,\n+  UBSAN_DOWNCAST_REFERENCE,\n+  UBSAN_UPCAST,\n+  UBSAN_CAST_TO_VBASE\n };\n \n /* This controls how ubsan prints types.  Used in ubsan_type_descriptor.  */\n@@ -42,6 +46,7 @@ extern bool do_ubsan_in_current_function (void);\n extern bool ubsan_expand_bounds_ifn (gimple_stmt_iterator *);\n extern bool ubsan_expand_null_ifn (gimple_stmt_iterator *);\n extern bool ubsan_expand_objsize_ifn (gimple_stmt_iterator *);\n+extern bool ubsan_expand_vptr_ifn (gimple_stmt_iterator *);\n extern bool ubsan_instrument_unreachable (gimple_stmt_iterator *);\n extern tree ubsan_create_data (const char *, int, const location_t *, ...);\n extern tree ubsan_type_descriptor (tree, enum ubsan_print_style = UBSAN_PRINT_NORMAL);"}]}