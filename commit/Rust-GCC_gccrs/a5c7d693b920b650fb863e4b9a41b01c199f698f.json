{"sha": "a5c7d693b920b650fb863e4b9a41b01c199f698f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTVjN2Q2OTNiOTIwYjY1MGZiODYzZTRiOWE0MWIwMWMxOTlmNjk4Zg==", "commit": {"author": {"name": "Richard Sandiford", "email": "richard.sandiford@linaro.org", "date": "2011-03-23T09:30:58Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2011-03-23T09:30:58Z"}, "message": "optabs.h (emit_unop_insn, [...]): Change insn code parameter from \"int\" to \"enum insn_code\".\n\ngcc/\n\t* optabs.h (emit_unop_insn, maybe_emit_unop_insn): Change insn code\n\tparameter from \"int\" to \"enum insn_code\".\n\t(expand_operand_type): New enum.\n\t(expand_operand): New structure.\n\t(create_expand_operand): New function.\n\t(create_fixed_operand, create_output_operand): Likewise\n\t(create_input_operand, create_convert_operand_to): Likewise.\n\t(create_convert_operand_from, create_address_operand): Likewise.\n\t(create_integer_operand): Likewise.\n\t(create_convert_operand_from_type, maybe_legitimize_operands): Declare.\n\t(maybe_gen_insn, maybe_expand_insn, maybe_expand_jump_insn): Likewise.\n\t(expand_insn, expand_jump_insn): Likewise.\n\t* builtins.c (expand_builtin_prefetch): Use the new interfaces.\n\t(expand_builtin_interclass_mathfn, expand_builtin_strlen): Likewise.\n\t(expand_movstr, expand_builtin___clear_cache): Likewise.\n\t(expand_builtin_lock_release): Likewise.\n\t* explow.c (allocate_dynamic_stack_space): Likewise.\n\t(probe_stack_range): Likewise.  Allow check_stack to FAIL,\n\tand use the default handling in that case.\n\t* expmed.c (check_predicate_volatile_ok): Delete.\n\t(store_bit_field_1, extract_bit_field_1): Use the new interfaces.\n\t(emit_cstore): Likewise.\n\t* expr.c (emit_block_move_via_movmem): Likewise.\n\t(set_storage_via_setmem, expand_assignment): Likewise.\n\t(emit_storent_insn, try_casesi): Likewise.\n\t(emit_single_push_insn): Likewise.  Allow the expansion to fail.\n\t* optabs.c (expand_widen_pattern_expr, expand_ternary_op): Likewise.\n\t(expand_vec_shift_expr, expand_binop_directly): Likewise.\n\t(expand_twoval_unop, expand_twoval_binop): Likewise.\n\t(expand_unop_direct, emit_indirect_jump): Likewise.\n\t(emit_conditional_move, vector_compare_rtx): Likewise.\n\t(expand_vec_cond_expr, expand_val_compare_and_swap_1): Likewise.\n\t(expand_sync_operation, expand_sync_fetch_operation): Likewise.\n\t(expand_sync_lock_test_and_set): Likewise.\n\t(maybe_emit_unop_insn): Likewise.  Change icode to an insn_code.\n\t(emit_unop_insn): Likewise.\n\t(expand_copysign_absneg): Change icode to an insn_code.\n\t(create_convert_operand_from_type): New function.\n\t(maybe_legitimize_operand, maybe_legitimize_operands): Likewise.\n\t(maybe_gen_insn, maybe_expand_insn, maybe_expand_jump_insn): Likewise.\n\t(expand_insn, expand_jump_insn): Likewise.\n\t* config/i386/i386.md (setmem<mode>): Use nonmemory_operand rather\n\tthan const_int_operand for operand 2.\n\nFrom-SVN: r171341", "tree": {"sha": "149ffb595908dd2c0744e01184f253f737706ef4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/149ffb595908dd2c0744e01184f253f737706ef4"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a5c7d693b920b650fb863e4b9a41b01c199f698f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a5c7d693b920b650fb863e4b9a41b01c199f698f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a5c7d693b920b650fb863e4b9a41b01c199f698f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a5c7d693b920b650fb863e4b9a41b01c199f698f/comments", "author": null, "committer": null, "parents": [{"sha": "78fadbabe3c1efabb7ebc58819ed75131958dfc4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/78fadbabe3c1efabb7ebc58819ed75131958dfc4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/78fadbabe3c1efabb7ebc58819ed75131958dfc4"}], "stats": {"total": 1709, "additions": 766, "deletions": 943}, "files": [{"sha": "14f8008214ca0dfa76613f8edb7e0742877941f1", "filename": "gcc/ChangeLog", "status": "modified", "additions": 46, "deletions": 0, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a5c7d693b920b650fb863e4b9a41b01c199f698f/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a5c7d693b920b650fb863e4b9a41b01c199f698f/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=a5c7d693b920b650fb863e4b9a41b01c199f698f", "patch": "@@ -1,3 +1,49 @@\n+2011-03-23  Richard Sandiford  <richard.sandiford@linaro.org>\n+\n+\t* optabs.h (emit_unop_insn, maybe_emit_unop_insn): Change insn code\n+\tparameter from \"int\" to \"enum insn_code\".\n+\t(expand_operand_type): New enum.\n+\t(expand_operand): New structure.\n+\t(create_expand_operand): New function.\n+\t(create_fixed_operand, create_output_operand): Likewise\n+\t(create_input_operand, create_convert_operand_to): Likewise.\n+\t(create_convert_operand_from, create_address_operand): Likewise.\n+\t(create_integer_operand): Likewise.\n+\t(create_convert_operand_from_type, maybe_legitimize_operands): Declare.\n+\t(maybe_gen_insn, maybe_expand_insn, maybe_expand_jump_insn): Likewise.\n+\t(expand_insn, expand_jump_insn): Likewise.\n+\t* builtins.c (expand_builtin_prefetch): Use the new interfaces.\n+\t(expand_builtin_interclass_mathfn, expand_builtin_strlen): Likewise.\n+\t(expand_movstr, expand_builtin___clear_cache): Likewise.\n+\t(expand_builtin_lock_release): Likewise.\n+\t* explow.c (allocate_dynamic_stack_space): Likewise.\n+\t(probe_stack_range): Likewise.  Allow check_stack to FAIL,\n+\tand use the default handling in that case.\n+\t* expmed.c (check_predicate_volatile_ok): Delete.\n+\t(store_bit_field_1, extract_bit_field_1): Use the new interfaces.\n+\t(emit_cstore): Likewise.\n+\t* expr.c (emit_block_move_via_movmem): Likewise.\n+\t(set_storage_via_setmem, expand_assignment): Likewise.\n+\t(emit_storent_insn, try_casesi): Likewise.\n+\t(emit_single_push_insn): Likewise.  Allow the expansion to fail.\n+\t* optabs.c (expand_widen_pattern_expr, expand_ternary_op): Likewise.\n+\t(expand_vec_shift_expr, expand_binop_directly): Likewise.\n+\t(expand_twoval_unop, expand_twoval_binop): Likewise.\n+\t(expand_unop_direct, emit_indirect_jump): Likewise.\n+\t(emit_conditional_move, vector_compare_rtx): Likewise.\n+\t(expand_vec_cond_expr, expand_val_compare_and_swap_1): Likewise.\n+\t(expand_sync_operation, expand_sync_fetch_operation): Likewise.\n+\t(expand_sync_lock_test_and_set): Likewise.\n+\t(maybe_emit_unop_insn): Likewise.  Change icode to an insn_code.\n+\t(emit_unop_insn): Likewise.\n+\t(expand_copysign_absneg): Change icode to an insn_code.\n+\t(create_convert_operand_from_type): New function.\n+\t(maybe_legitimize_operand, maybe_legitimize_operands): Likewise.\n+\t(maybe_gen_insn, maybe_expand_insn, maybe_expand_jump_insn): Likewise.\n+\t(expand_insn, expand_jump_insn): Likewise.\n+\t* config/i386/i386.md (setmem<mode>): Use nonmemory_operand rather\n+\tthan const_int_operand for operand 2.\n+\n 2011-03-23  Andreas Krebbel  <Andreas.Krebbel@de.ibm.com>\n \n \t* dwarf2out.c (const_ok_for_output_1): Print the unspec enum name"}, {"sha": "f2b5130b837f18e1df80cb36b829dc47b8f3c5be", "filename": "gcc/builtins.c", "status": "modified", "additions": 52, "deletions": 98, "changes": 150, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a5c7d693b920b650fb863e4b9a41b01c199f698f/gcc%2Fbuiltins.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a5c7d693b920b650fb863e4b9a41b01c199f698f/gcc%2Fbuiltins.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbuiltins.c?ref=a5c7d693b920b650fb863e4b9a41b01c199f698f", "patch": "@@ -1143,15 +1143,13 @@ expand_builtin_prefetch (tree exp)\n #ifdef HAVE_prefetch\n   if (HAVE_prefetch)\n     {\n-      if ((! (*insn_data[(int) CODE_FOR_prefetch].operand[0].predicate)\n-\t     (op0,\n-\t      insn_data[(int) CODE_FOR_prefetch].operand[0].mode))\n-\t  || (GET_MODE (op0) != Pmode))\n-\t{\n-\t  op0 = convert_memory_address (Pmode, op0);\n-\t  op0 = force_reg (Pmode, op0);\n-\t}\n-      emit_insn (gen_prefetch (op0, op1, op2));\n+      struct expand_operand ops[3];\n+\n+      create_address_operand (&ops[0], op0);\n+      create_integer_operand (&ops[1], INTVAL (op1));\n+      create_integer_operand (&ops[2], INTVAL (op2));\n+      if (maybe_expand_insn (CODE_FOR_prefetch, 3, ops))\n+\treturn;\n     }\n #endif\n \n@@ -2431,16 +2429,9 @@ expand_builtin_interclass_mathfn (tree exp, rtx target)\n \n   if (icode != CODE_FOR_nothing)\n     {\n+      struct expand_operand ops[1];\n       rtx last = get_last_insn ();\n       tree orig_arg = arg;\n-      /* Make a suitable register to place result in.  */\n-      if (!target\n-\t  || GET_MODE (target) != TYPE_MODE (TREE_TYPE (exp))\n-\t  || !insn_data[icode].operand[0].predicate (target, GET_MODE (target)))\n-         target = gen_reg_rtx (TYPE_MODE (TREE_TYPE (exp)));\n-\n-      gcc_assert (insn_data[icode].operand[0].predicate\n-\t\t  (target, GET_MODE (target)));\n \n       /* Wrap the computation of the argument in a SAVE_EXPR, as we may\n \t need to expand the argument again.  This way, we will not perform\n@@ -2452,10 +2443,11 @@ expand_builtin_interclass_mathfn (tree exp, rtx target)\n       if (mode != GET_MODE (op0))\n \top0 = convert_to_mode (mode, op0, 0);\n \n-      /* Compute into TARGET.\n-\t Set TARGET to wherever the result comes back.  */\n-      if (maybe_emit_unop_insn (icode, target, op0, UNKNOWN))\n-\treturn target;\n+      create_output_operand (&ops[0], target, TYPE_MODE (TREE_TYPE (exp)));\n+      if (maybe_legitimize_operands (icode, 0, 1, ops)\n+\t  && maybe_emit_unop_insn (icode, ops[0].value, op0, UNKNOWN))\n+\treturn ops[0].value;\n+\n       delete_insns_since (last);\n       CALL_EXPR_ARG (exp, 0) = orig_arg;\n     }\n@@ -3362,11 +3354,12 @@ expand_builtin_strlen (tree exp, rtx target,\n     return NULL_RTX;\n   else\n     {\n+      struct expand_operand ops[4];\n       rtx pat;\n       tree len;\n       tree src = CALL_EXPR_ARG (exp, 0);\n-      rtx result, src_reg, char_rtx, before_strlen;\n-      enum machine_mode insn_mode = target_mode, char_mode;\n+      rtx src_reg, before_strlen;\n+      enum machine_mode insn_mode = target_mode;\n       enum insn_code icode = CODE_FOR_nothing;\n       unsigned int align;\n \n@@ -3405,14 +3398,6 @@ expand_builtin_strlen (tree exp, rtx target,\n       if (insn_mode == VOIDmode)\n \treturn NULL_RTX;\n \n-      /* Make a place to write the result of the instruction.  */\n-      result = target;\n-      if (! (result != 0\n-\t     && REG_P (result)\n-\t     && GET_MODE (result) == insn_mode\n-\t     && REGNO (result) >= FIRST_PSEUDO_REGISTER))\n-\tresult = gen_reg_rtx (insn_mode);\n-\n       /* Make a place to hold the source address.  We will not expand\n \t the actual source until we are sure that the expansion will\n \t not fail -- there are trees that cannot be expanded twice.  */\n@@ -3422,17 +3407,12 @@ expand_builtin_strlen (tree exp, rtx target,\n \t source operand later.  */\n       before_strlen = get_last_insn ();\n \n-      char_rtx = const0_rtx;\n-      char_mode = insn_data[(int) icode].operand[2].mode;\n-      if (! (*insn_data[(int) icode].operand[2].predicate) (char_rtx,\n-\t\t\t\t\t\t\t    char_mode))\n-\tchar_rtx = copy_to_mode_reg (char_mode, char_rtx);\n-\n-      pat = GEN_FCN (icode) (result, gen_rtx_MEM (BLKmode, src_reg),\n-\t\t\t     char_rtx, GEN_INT (align));\n-      if (! pat)\n+      create_output_operand (&ops[0], target, insn_mode);\n+      create_fixed_operand (&ops[1], gen_rtx_MEM (BLKmode, src_reg));\n+      create_integer_operand (&ops[2], 0);\n+      create_integer_operand (&ops[3], align);\n+      if (!maybe_expand_insn (icode, 4, ops))\n \treturn NULL_RTX;\n-      emit_insn (pat);\n \n       /* Now that we are assured of success, expand the source.  */\n       start_sequence ();\n@@ -3448,12 +3428,12 @@ expand_builtin_strlen (tree exp, rtx target,\n \temit_insn_before (pat, get_insns ());\n \n       /* Return the value in the proper mode for this function.  */\n-      if (GET_MODE (result) == target_mode)\n-\ttarget = result;\n+      if (GET_MODE (ops[0].value) == target_mode)\n+\ttarget = ops[0].value;\n       else if (target != 0)\n-\tconvert_move (target, result, 0);\n+\tconvert_move (target, ops[0].value, 0);\n       else\n-\ttarget = convert_to_mode (target_mode, result, 0);\n+\ttarget = convert_to_mode (target_mode, ops[0].value, 0);\n \n       return target;\n     }\n@@ -3674,56 +3654,39 @@ expand_builtin_mempcpy_args (tree dest, tree src, tree len,\n static rtx\n expand_movstr (tree dest, tree src, rtx target, int endp)\n {\n+  struct expand_operand ops[3];\n   rtx end;\n   rtx dest_mem;\n   rtx src_mem;\n-  rtx insn;\n-  const struct insn_data_d * data;\n \n   if (!HAVE_movstr)\n     return NULL_RTX;\n \n   dest_mem = get_memory_rtx (dest, NULL);\n   src_mem = get_memory_rtx (src, NULL);\n-  data = insn_data + CODE_FOR_movstr;\n   if (!endp)\n     {\n       target = force_reg (Pmode, XEXP (dest_mem, 0));\n       dest_mem = replace_equiv_address (dest_mem, target);\n-      end = gen_reg_rtx (Pmode);\n-    }\n-  else\n-    {\n-      if (target == 0\n-\t  || target == const0_rtx\n-\t  || ! (*data->operand[0].predicate) (target, Pmode))\n-\t{\n-\t  end = gen_reg_rtx (Pmode);\n-\t  if (target != const0_rtx)\n-\t    target = end;\n-\t}\n-      else\n-\tend = target;\n     }\n \n-  if (data->operand[0].mode != VOIDmode)\n-    end = gen_lowpart (data->operand[0].mode, end);\n-\n-  insn = data->genfun (end, dest_mem, src_mem);\n-\n-  gcc_assert (insn);\n+  create_output_operand (&ops[0], endp ? target : NULL_RTX, Pmode);\n+  create_fixed_operand (&ops[1], dest_mem);\n+  create_fixed_operand (&ops[2], src_mem);\n+  expand_insn (CODE_FOR_movstr, 3, ops);\n \n-  emit_insn (insn);\n-\n-  /* movstr is supposed to set end to the address of the NUL\n-     terminator.  If the caller requested a mempcpy-like return value,\n-     adjust it.  */\n-  if (endp == 1 && target != const0_rtx)\n+  if (endp && target != const0_rtx)\n     {\n-      rtx tem = plus_constant (gen_lowpart (GET_MODE (target), end), 1);\n-      emit_move_insn (target, force_operand (tem, NULL_RTX));\n+      target = ops[0].value;\n+      /* movstr is supposed to set end to the address of the NUL\n+\t terminator.  If the caller requested a mempcpy-like return value,\n+\t adjust it.  */\n+      if (endp == 1)\n+\t{\n+\t  rtx tem = plus_constant (gen_lowpart (GET_MODE (target), end), 1);\n+\t  emit_move_insn (target, force_operand (tem, NULL_RTX));\n+\t}\n     }\n-\n   return target;\n }\n \n@@ -5223,7 +5186,6 @@ expand_builtin___clear_cache (tree exp ATTRIBUTE_UNUSED)\n   /* We have a \"clear_cache\" insn, and it will handle everything.  */\n   tree begin, end;\n   rtx begin_rtx, end_rtx;\n-  enum insn_code icode;\n \n   /* We must not expand to a library call.  If we did, any\n      fallback library function in libgcc that might contain a call to\n@@ -5236,21 +5198,18 @@ expand_builtin___clear_cache (tree exp ATTRIBUTE_UNUSED)\n \n   if (HAVE_clear_cache)\n     {\n-      icode = CODE_FOR_clear_cache;\n+      struct expand_operand ops[2];\n \n       begin = CALL_EXPR_ARG (exp, 0);\n       begin_rtx = expand_expr (begin, NULL_RTX, Pmode, EXPAND_NORMAL);\n-      begin_rtx = convert_memory_address (Pmode, begin_rtx);\n-      if (!insn_data[icode].operand[0].predicate (begin_rtx, Pmode))\n-\tbegin_rtx = copy_to_mode_reg (Pmode, begin_rtx);\n \n       end = CALL_EXPR_ARG (exp, 1);\n       end_rtx = expand_expr (end, NULL_RTX, Pmode, EXPAND_NORMAL);\n-      end_rtx = convert_memory_address (Pmode, end_rtx);\n-      if (!insn_data[icode].operand[1].predicate (end_rtx, Pmode))\n-\tend_rtx = copy_to_mode_reg (Pmode, end_rtx);\n \n-      emit_insn (gen_clear_cache (begin_rtx, end_rtx));\n+      create_address_operand (&ops[0], begin_rtx);\n+      create_address_operand (&ops[1], end_rtx);\n+      if (maybe_expand_insn (CODE_FOR_clear_cache, 2, ops))\n+\treturn const0_rtx;\n     }\n   return const0_rtx;\n #endif /* HAVE_clear_cache */\n@@ -5748,9 +5707,9 @@ expand_builtin_synchronize (void)\n static void\n expand_builtin_lock_release (enum machine_mode mode, tree exp)\n {\n+  struct expand_operand ops[2];\n   enum insn_code icode;\n-  rtx mem, insn;\n-  rtx val = const0_rtx;\n+  rtx mem;\n \n   /* Expand the operands.  */\n   mem = get_builtin_sync_mem (CALL_EXPR_ARG (exp, 0), mode);\n@@ -5759,21 +5718,16 @@ expand_builtin_lock_release (enum machine_mode mode, tree exp)\n   icode = direct_optab_handler (sync_lock_release_optab, mode);\n   if (icode != CODE_FOR_nothing)\n     {\n-      if (!insn_data[icode].operand[1].predicate (val, mode))\n-\tval = force_reg (mode, val);\n-\n-      insn = GEN_FCN (icode) (mem, val);\n-      if (insn)\n-\t{\n-\t  emit_insn (insn);\n-\t  return;\n-\t}\n+      create_fixed_operand (&ops[0], mem);\n+      create_input_operand (&ops[1], const0_rtx, mode);\n+      if (maybe_expand_insn (icode, 2, ops))\n+\treturn;\n     }\n \n   /* Otherwise we can implement this operation by emitting a barrier\n      followed by a store of zero.  */\n   expand_builtin_synchronize ();\n-  emit_move_insn (mem, val);\n+  emit_move_insn (mem, const0_rtx);\n }\n \f\n /* Expand an expression EXP that calls a built-in function,"}, {"sha": "c2901decdf385f3247cea194d4a12e500dffb119", "filename": "gcc/config/i386/i386.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a5c7d693b920b650fb863e4b9a41b01c199f698f/gcc%2Fconfig%2Fi386%2Fi386.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a5c7d693b920b650fb863e4b9a41b01c199f698f/gcc%2Fconfig%2Fi386%2Fi386.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.md?ref=a5c7d693b920b650fb863e4b9a41b01c199f698f", "patch": "@@ -15793,7 +15793,7 @@\n (define_expand \"setmem<mode>\"\n    [(use (match_operand:BLK 0 \"memory_operand\" \"\"))\n     (use (match_operand:SWI48 1 \"nonmemory_operand\" \"\"))\n-    (use (match_operand 2 \"const_int_operand\" \"\"))\n+    (use (match_operand:QI 2 \"nonmemory_operand\" \"\"))\n     (use (match_operand 3 \"const_int_operand\" \"\"))\n     (use (match_operand:SI 4 \"const_int_operand\" \"\"))\n     (use (match_operand:SI 5 \"const_int_operand\" \"\"))]"}, {"sha": "a0a160dd2bd2e721d8d607d3c97a3afa936aa5cf", "filename": "gcc/explow.c", "status": "modified", "additions": 11, "deletions": 19, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a5c7d693b920b650fb863e4b9a41b01c199f698f/gcc%2Fexplow.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a5c7d693b920b650fb863e4b9a41b01c199f698f/gcc%2Fexplow.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexplow.c?ref=a5c7d693b920b650fb863e4b9a41b01c199f698f", "patch": "@@ -1379,21 +1379,13 @@ allocate_dynamic_stack_space (rtx size, unsigned size_align,\n #ifdef HAVE_allocate_stack\n   if (HAVE_allocate_stack)\n     {\n-      enum machine_mode mode = STACK_SIZE_MODE;\n-      insn_operand_predicate_fn pred;\n-\n+      struct expand_operand ops[2];\n       /* We don't have to check against the predicate for operand 0 since\n \t TARGET is known to be a pseudo of the proper mode, which must\n-\t be valid for the operand.  For operand 1, convert to the\n-\t proper mode and validate.  */\n-      if (mode == VOIDmode)\n-\tmode = insn_data[(int) CODE_FOR_allocate_stack].operand[1].mode;\n-\n-      pred = insn_data[(int) CODE_FOR_allocate_stack].operand[1].predicate;\n-      if (pred && ! ((*pred) (size, mode)))\n-\tsize = copy_to_mode_reg (mode, convert_to_mode (mode, size, 1));\n-\n-      emit_insn (gen_allocate_stack (target, size));\n+\t be valid for the operand.  */\n+      create_fixed_operand (&ops[0], target);\n+      create_convert_operand_to (&ops[1], size, STACK_SIZE_MODE, true);\n+      expand_insn (CODE_FOR_allocate_stack, 2, ops);\n     }\n   else\n #endif\n@@ -1544,22 +1536,22 @@ probe_stack_range (HOST_WIDE_INT first, rtx size)\n \t\t\t\t\t         plus_constant (size, first)));\n       emit_library_call (stack_check_libfunc, LCT_NORMAL, VOIDmode, 1, addr,\n \t\t\t Pmode);\n+      return;\n     }\n \n   /* Next see if we have an insn to check the stack.  */\n #ifdef HAVE_check_stack\n-  else if (HAVE_check_stack)\n+  if (HAVE_check_stack)\n     {\n+      struct expand_operand ops[1];\n       rtx addr = memory_address (Pmode,\n \t\t\t\t gen_rtx_fmt_ee (STACK_GROW_OP, Pmode,\n \t\t\t\t\t         stack_pointer_rtx,\n \t\t\t\t\t         plus_constant (size, first)));\n-      insn_operand_predicate_fn pred\n-\t= insn_data[(int) CODE_FOR_check_stack].operand[0].predicate;\n-      if (pred && !((*pred) (addr, Pmode)))\n-\taddr = copy_to_mode_reg (Pmode, addr);\n \n-      emit_insn (gen_check_stack (addr));\n+      create_input_operand (&ops[0], addr, Pmode);\n+      if (maybe_expand_insn (CODE_FOR_check_stack, 1, ops))\n+\treturn;\n     }\n #endif\n "}, {"sha": "6218f3d4ce80854ac77d57f393de430e28dd7e6b", "filename": "gcc/expmed.c", "status": "modified", "additions": 61, "deletions": 164, "changes": 225, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a5c7d693b920b650fb863e4b9a41b01c199f698f/gcc%2Fexpmed.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a5c7d693b920b650fb863e4b9a41b01c199f698f/gcc%2Fexpmed.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpmed.c?ref=a5c7d693b920b650fb863e4b9a41b01c199f698f", "patch": "@@ -323,22 +323,6 @@ mode_for_extraction (enum extraction_pattern pattern, int opno)\n     return word_mode;\n   return data->operand[opno].mode;\n }\n-\n-/* Return true if X, of mode MODE, matches the predicate for operand\n-   OPNO of instruction ICODE.  Allow volatile memories, regardless of\n-   the ambient volatile_ok setting.  */\n-\n-static bool\n-check_predicate_volatile_ok (enum insn_code icode, int opno,\n-\t\t\t     rtx x, enum machine_mode mode)\n-{\n-  bool save_volatile_ok, result;\n-\n-  save_volatile_ok = volatile_ok;\n-  result = insn_data[(int) icode].operand[opno].predicate (x, mode);\n-  volatile_ok = save_volatile_ok;\n-  return result;\n-}\n \f\n /* A subroutine of store_bit_field, with the same arguments.  Return true\n    if the operation could be implemented.\n@@ -405,40 +389,17 @@ store_bit_field_1 (rtx str_rtx, unsigned HOST_WIDE_INT bitsize,\n       && bitsize == GET_MODE_BITSIZE (GET_MODE_INNER (GET_MODE (op0)))\n       && !(bitnum % GET_MODE_BITSIZE (GET_MODE_INNER (GET_MODE (op0)))))\n     {\n+      struct expand_operand ops[3];\n       enum machine_mode outermode = GET_MODE (op0);\n       enum machine_mode innermode = GET_MODE_INNER (outermode);\n-      int icode = (int) optab_handler (vec_set_optab, outermode);\n+      enum insn_code icode = optab_handler (vec_set_optab, outermode);\n       int pos = bitnum / GET_MODE_BITSIZE (innermode);\n-      rtx rtxpos = GEN_INT (pos);\n-      rtx src = value;\n-      rtx dest = op0;\n-      rtx pat, seq;\n-      enum machine_mode mode0 = insn_data[icode].operand[0].mode;\n-      enum machine_mode mode1 = insn_data[icode].operand[1].mode;\n-      enum machine_mode mode2 = insn_data[icode].operand[2].mode;\n-\n-      start_sequence ();\n \n-      if (! (*insn_data[icode].operand[1].predicate) (src, mode1))\n-\tsrc = copy_to_mode_reg (mode1, src);\n-\n-      if (! (*insn_data[icode].operand[2].predicate) (rtxpos, mode2))\n-\trtxpos = copy_to_mode_reg (mode1, rtxpos);\n-\n-      /* We could handle this, but we should always be called with a pseudo\n-\t for our targets and all insns should take them as outputs.  */\n-      gcc_assert ((*insn_data[icode].operand[0].predicate) (dest, mode0)\n-\t\t  && (*insn_data[icode].operand[1].predicate) (src, mode1)\n-\t\t  && (*insn_data[icode].operand[2].predicate) (rtxpos, mode2));\n-      pat = GEN_FCN (icode) (dest, src, rtxpos);\n-      seq = get_insns ();\n-      end_sequence ();\n-      if (pat)\n-\t{\n-\t  emit_insn (seq);\n-\t  emit_insn (pat);\n-\t  return true;\n-\t}\n+      create_fixed_operand (&ops[0], op0);\n+      create_input_operand (&ops[1], value, innermode);\n+      create_integer_operand (&ops[2], pos);\n+      if (maybe_expand_insn (icode, 3, ops))\n+\treturn true;\n     }\n \n   /* If the target is a register, overwriting the entire object, or storing\n@@ -515,44 +476,30 @@ store_bit_field_1 (rtx str_rtx, unsigned HOST_WIDE_INT bitsize,\n       && bitsize == GET_MODE_BITSIZE (fieldmode)\n       && optab_handler (movstrict_optab, fieldmode) != CODE_FOR_nothing)\n     {\n-      int icode = optab_handler (movstrict_optab, fieldmode);\n-      rtx insn;\n-      rtx start = get_last_insn ();\n+      struct expand_operand ops[2];\n+      enum insn_code icode = optab_handler (movstrict_optab, fieldmode);\n       rtx arg0 = op0;\n \n-      /* Get appropriate low part of the value being stored.  */\n-      if (CONST_INT_P (value) || REG_P (value))\n-\tvalue = gen_lowpart (fieldmode, value);\n-      else if (!(GET_CODE (value) == SYMBOL_REF\n-\t\t || GET_CODE (value) == LABEL_REF\n-\t\t || GET_CODE (value) == CONST))\n-\tvalue = convert_to_mode (fieldmode, value, 0);\n-\n-      if (! (*insn_data[icode].operand[1].predicate) (value, fieldmode))\n-\tvalue = copy_to_mode_reg (fieldmode, value);\n-\n-      if (GET_CODE (op0) == SUBREG)\n+      if (GET_CODE (arg0) == SUBREG)\n \t{\n \t  /* Else we've got some float mode source being extracted into\n \t     a different float mode destination -- this combination of\n \t     subregs results in Severe Tire Damage.  */\n-\t  gcc_assert (GET_MODE (SUBREG_REG (op0)) == fieldmode\n+\t  gcc_assert (GET_MODE (SUBREG_REG (arg0)) == fieldmode\n \t\t      || GET_MODE_CLASS (fieldmode) == MODE_INT\n \t\t      || GET_MODE_CLASS (fieldmode) == MODE_PARTIAL_INT);\n-\t  arg0 = SUBREG_REG (op0);\n+\t  arg0 = SUBREG_REG (arg0);\n \t}\n \n-      insn = (GEN_FCN (icode)\n-\t\t (gen_rtx_SUBREG (fieldmode, arg0,\n-\t\t\t\t  (bitnum % BITS_PER_WORD) / BITS_PER_UNIT\n-\t\t\t\t  + (offset * UNITS_PER_WORD)),\n-\t\t\t\t  value));\n-      if (insn)\n-\t{\n-\t  emit_insn (insn);\n-\t  return true;\n-\t}\n-      delete_insns_since (start);\n+      arg0 = gen_rtx_SUBREG (fieldmode, arg0,\n+\t\t\t     (bitnum % BITS_PER_WORD) / BITS_PER_UNIT\n+\t\t\t     + (offset * UNITS_PER_WORD));\n+\n+      create_fixed_operand (&ops[0], arg0);\n+      /* Shrink the source operand to FIELDMODE.  */\n+      create_convert_operand_to (&ops[1], value, fieldmode, false);\n+      if (maybe_expand_insn (icode, 2, ops))\n+\treturn true;\n     }\n \n   /* Handle fields bigger than a word.  */\n@@ -653,16 +600,13 @@ store_bit_field_1 (rtx str_rtx, unsigned HOST_WIDE_INT bitsize,\n       && bitsize > 0\n       && GET_MODE_BITSIZE (op_mode) >= bitsize\n       && ! ((REG_P (op0) || GET_CODE (op0) == SUBREG)\n-\t    && (bitsize + bitpos > GET_MODE_BITSIZE (op_mode)))\n-      && insn_data[CODE_FOR_insv].operand[1].predicate (GEN_INT (bitsize),\n-\t\t\t\t\t\t\tVOIDmode)\n-      && check_predicate_volatile_ok (CODE_FOR_insv, 0, op0, VOIDmode))\n+\t    && (bitsize + bitpos > GET_MODE_BITSIZE (op_mode))))\n     {\n+      struct expand_operand ops[4];\n       int xbitpos = bitpos;\n       rtx value1;\n       rtx xop0 = op0;\n       rtx last = get_last_insn ();\n-      rtx pat;\n       bool copy_back = false;\n \n       /* Add OFFSET into OP0's address.  */\n@@ -743,17 +687,12 @@ store_bit_field_1 (rtx str_rtx, unsigned HOST_WIDE_INT bitsize,\n \t    gcc_assert (CONSTANT_P (value));\n \t}\n \n-      /* If this machine's insv insists on a register,\n-\t get VALUE1 into a register.  */\n-      if (! ((*insn_data[(int) CODE_FOR_insv].operand[3].predicate)\n-\t     (value1, op_mode)))\n-\tvalue1 = force_reg (op_mode, value1);\n-\n-      pat = gen_insv (xop0, GEN_INT (bitsize), GEN_INT (xbitpos), value1);\n-      if (pat)\n+      create_fixed_operand (&ops[0], xop0);\n+      create_integer_operand (&ops[1], bitsize);\n+      create_integer_operand (&ops[2], xbitpos);\n+      create_input_operand (&ops[3], value1, op_mode);\n+      if (maybe_expand_insn (CODE_FOR_insv, 4, ops))\n \t{\n-\t  emit_insn (pat);\n-\n \t  if (copy_back)\n \t    convert_move (op0, xop0, true);\n \t  return true;\n@@ -1235,50 +1174,21 @@ extract_bit_field_1 (rtx str_rtx, unsigned HOST_WIDE_INT bitsize,\n       && ((bitnum + bitsize - 1) / GET_MODE_BITSIZE (GET_MODE_INNER (GET_MODE (op0)))\n \t  == bitnum / GET_MODE_BITSIZE (GET_MODE_INNER (GET_MODE (op0)))))\n     {\n+      struct expand_operand ops[3];\n       enum machine_mode outermode = GET_MODE (op0);\n       enum machine_mode innermode = GET_MODE_INNER (outermode);\n-      int icode = (int) optab_handler (vec_extract_optab, outermode);\n+      enum insn_code icode = optab_handler (vec_extract_optab, outermode);\n       unsigned HOST_WIDE_INT pos = bitnum / GET_MODE_BITSIZE (innermode);\n-      rtx rtxpos = GEN_INT (pos);\n-      rtx src = op0;\n-      rtx dest = NULL, pat, seq;\n-      enum machine_mode mode0 = insn_data[icode].operand[0].mode;\n-      enum machine_mode mode1 = insn_data[icode].operand[1].mode;\n-      enum machine_mode mode2 = insn_data[icode].operand[2].mode;\n-\n-      if (innermode == tmode || innermode == mode)\n-\tdest = target;\n-\n-      if (!dest)\n-\tdest = gen_reg_rtx (innermode);\n-\n-      start_sequence ();\n-\n-      if (! (*insn_data[icode].operand[0].predicate) (dest, mode0))\n-\tdest = copy_to_mode_reg (mode0, dest);\n \n-      if (! (*insn_data[icode].operand[1].predicate) (src, mode1))\n-\tsrc = copy_to_mode_reg (mode1, src);\n-\n-      if (! (*insn_data[icode].operand[2].predicate) (rtxpos, mode2))\n-\trtxpos = copy_to_mode_reg (mode1, rtxpos);\n-\n-      /* We could handle this, but we should always be called with a pseudo\n-\t for our targets and all insns should take them as outputs.  */\n-      gcc_assert ((*insn_data[icode].operand[0].predicate) (dest, mode0)\n-\t\t  && (*insn_data[icode].operand[1].predicate) (src, mode1)\n-\t\t  && (*insn_data[icode].operand[2].predicate) (rtxpos, mode2));\n-\n-      pat = GEN_FCN (icode) (dest, src, rtxpos);\n-      seq = get_insns ();\n-      end_sequence ();\n-      if (pat)\n+      create_output_operand (&ops[0], target, innermode);\n+      create_input_operand (&ops[1], op0, outermode);\n+      create_integer_operand (&ops[2], pos);\n+      if (maybe_expand_insn (icode, 3, ops))\n \t{\n-\t  emit_insn (seq);\n-\t  emit_insn (pat);\n-      \t  if (mode0 != mode)\n-\t    return gen_lowpart (tmode, dest);\n-\t  return dest;\n+\t  target = ops[0].value;\n+      \t  if (GET_MODE (target) != mode)\n+\t    return gen_lowpart (tmode, target);\n+\t  return target;\n \t}\n     }\n \n@@ -1517,17 +1427,14 @@ extract_bit_field_1 (rtx str_rtx, unsigned HOST_WIDE_INT bitsize,\n \t acceptable to the format of ext(z)v.  */\n       && !(GET_CODE (op0) == SUBREG && GET_MODE (op0) != ext_mode)\n       && !((REG_P (op0) || GET_CODE (op0) == SUBREG)\n-\t   && (bitsize + bitpos > GET_MODE_BITSIZE (ext_mode)))\n-      && check_predicate_volatile_ok (icode, 1, op0, GET_MODE (op0)))\n+\t   && (bitsize + bitpos > GET_MODE_BITSIZE (ext_mode))))\n     {\n+      struct expand_operand ops[4];\n       unsigned HOST_WIDE_INT xbitpos = bitpos, xoffset = offset;\n-      rtx bitsize_rtx, bitpos_rtx;\n-      rtx last = get_last_insn ();\n       rtx xop0 = op0;\n       rtx xtarget = target;\n       rtx xspec_target = target;\n       rtx xspec_target_subreg = 0;\n-      rtx pat;\n \n       /* If op0 is a register, we need it in EXT_MODE to make it\n \t acceptable to the format of ext(z)v.  */\n@@ -1570,27 +1477,20 @@ extract_bit_field_1 (rtx str_rtx, unsigned HOST_WIDE_INT bitsize,\n \t    xtarget = gen_reg_rtx (ext_mode);\n \t}\n \n-      /* If this machine's ext(z)v insists on a register target,\n-\t make sure we have one.  */\n-      if (!insn_data[(int) icode].operand[0].predicate (xtarget, ext_mode))\n-\txtarget = gen_reg_rtx (ext_mode);\n-\n-      bitsize_rtx = GEN_INT (bitsize);\n-      bitpos_rtx = GEN_INT (xbitpos);\n-\n-      pat = (unsignedp\n-\t     ? gen_extzv (xtarget, xop0, bitsize_rtx, bitpos_rtx)\n-\t     : gen_extv (xtarget, xop0, bitsize_rtx, bitpos_rtx));\n-      if (pat)\n+      create_output_operand (&ops[0], xtarget, ext_mode);\n+      create_fixed_operand (&ops[1], xop0);\n+      create_integer_operand (&ops[2], bitsize);\n+      create_integer_operand (&ops[3], xbitpos);\n+      if (maybe_expand_insn (unsignedp ? CODE_FOR_extzv : CODE_FOR_extv,\n+\t\t\t     4, ops))\n \t{\n-\t  emit_insn (pat);\n+\t  xtarget = ops[0].value;\n \t  if (xtarget == xspec_target)\n \t    return xtarget;\n \t  if (xtarget == xspec_target_subreg)\n \t    return xspec_target;\n \t  return convert_extracted_bit_field (xtarget, mode, tmode, unsignedp);\n \t}\n-      delete_insns_since (last);\n     }\n \n   /* If OP0 is a memory, try copying it to a register and seeing if a\n@@ -5101,19 +5001,14 @@ emit_cstore (rtx target, enum insn_code icode, enum rtx_code code,\n \t     int unsignedp, rtx x, rtx y, int normalizep,\n \t     enum machine_mode target_mode)\n {\n-  rtx op0, last, comparison, subtarget, pattern;\n+  struct expand_operand ops[4];\n+  rtx op0, last, comparison, subtarget;\n   enum machine_mode result_mode = insn_data[(int) icode].operand[0].mode;\n \n   last = get_last_insn ();\n   x = prepare_operand (icode, x, 2, mode, compare_mode, unsignedp);\n   y = prepare_operand (icode, y, 3, mode, compare_mode, unsignedp);\n-  comparison = gen_rtx_fmt_ee (code, result_mode, x, y);\n-  if (!x || !y\n-      || !insn_data[icode].operand[2].predicate\n-\t  (x, insn_data[icode].operand[2].mode)\n-      || !insn_data[icode].operand[3].predicate\n-\t  (y, insn_data[icode].operand[3].mode)\n-      || !insn_data[icode].operand[1].predicate (comparison, VOIDmode))\n+  if (!x || !y)\n     {\n       delete_insns_since (last);\n       return NULL_RTX;\n@@ -5124,16 +5019,18 @@ emit_cstore (rtx target, enum insn_code icode, enum rtx_code code,\n   if (!target)\n     target = gen_reg_rtx (target_mode);\n \n-  if (optimize\n-      || !(insn_data[(int) icode].operand[0].predicate (target, result_mode)))\n-    subtarget = gen_reg_rtx (result_mode);\n-  else\n-    subtarget = target;\n+  comparison = gen_rtx_fmt_ee (code, result_mode, x, y);\n \n-  pattern = GEN_FCN (icode) (subtarget, comparison, x, y);\n-  if (!pattern)\n-    return NULL_RTX;\n-  emit_insn (pattern);\n+  create_output_operand (&ops[0], optimize ? NULL_RTX : target, result_mode);\n+  create_fixed_operand (&ops[1], comparison);\n+  create_fixed_operand (&ops[2], x);\n+  create_fixed_operand (&ops[3], y);\n+  if (!maybe_expand_insn (icode, 4, ops))\n+    {\n+      delete_insns_since (last);\n+      return NULL_RTX;\n+    }\n+  subtarget = ops[0].value;\n \n   /* If we are converting to a wider mode, first convert to\n      TARGET_MODE, then normalize.  This produces better combining"}, {"sha": "572f0f4eb6025262937d132a9cba1841e47feb6e", "filename": "gcc/expr.c", "status": "modified", "additions": 61, "deletions": 131, "changes": 192, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a5c7d693b920b650fb863e4b9a41b01c199f698f/gcc%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a5c7d693b920b650fb863e4b9a41b01c199f698f/gcc%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.c?ref=a5c7d693b920b650fb863e4b9a41b01c199f698f", "patch": "@@ -1258,7 +1258,6 @@ static bool\n emit_block_move_via_movmem (rtx x, rtx y, rtx size, unsigned int align,\n \t\t\t    unsigned int expected_align, HOST_WIDE_INT expected_size)\n {\n-  rtx opalign = GEN_INT (align / BITS_PER_UNIT);\n   int save_volatile_ok = volatile_ok;\n   enum machine_mode mode;\n \n@@ -1276,7 +1275,6 @@ emit_block_move_via_movmem (rtx x, rtx y, rtx size, unsigned int align,\n        mode = GET_MODE_WIDER_MODE (mode))\n     {\n       enum insn_code code = direct_optab_handler (movmem_optab, mode);\n-      insn_operand_predicate_fn pred;\n \n       if (code != CODE_FOR_nothing\n \t  /* We don't need MODE to be narrower than BITS_PER_HOST_WIDE_INT\n@@ -1286,43 +1284,32 @@ emit_block_move_via_movmem (rtx x, rtx y, rtx size, unsigned int align,\n \t  && ((CONST_INT_P (size)\n \t       && ((unsigned HOST_WIDE_INT) INTVAL (size)\n \t\t   <= (GET_MODE_MASK (mode) >> 1)))\n-\t      || GET_MODE_BITSIZE (mode) >= BITS_PER_WORD)\n-\t  && ((pred = insn_data[(int) code].operand[0].predicate) == 0\n-\t      || (*pred) (x, BLKmode))\n-\t  && ((pred = insn_data[(int) code].operand[1].predicate) == 0\n-\t      || (*pred) (y, BLKmode))\n-\t  && ((pred = insn_data[(int) code].operand[3].predicate) == 0\n-\t      || (*pred) (opalign, VOIDmode)))\n-\t{\n-\t  rtx op2;\n-\t  rtx last = get_last_insn ();\n-\t  rtx pat;\n-\n-\t  op2 = convert_to_mode (mode, size, 1);\n-\t  pred = insn_data[(int) code].operand[2].predicate;\n-\t  if (pred != 0 && ! (*pred) (op2, mode))\n-\t    op2 = copy_to_mode_reg (mode, op2);\n+\t      || GET_MODE_BITSIZE (mode) >= BITS_PER_WORD))\n+\t{\n+\t  struct expand_operand ops[6];\n+\t  unsigned int nops;\n \n \t  /* ??? When called via emit_block_move_for_call, it'd be\n \t     nice if there were some way to inform the backend, so\n \t     that it doesn't fail the expansion because it thinks\n \t     emitting the libcall would be more efficient.  */\n-\n-\t  if (insn_data[(int) code].n_operands == 4)\n-\t    pat = GEN_FCN ((int) code) (x, y, op2, opalign);\n-\t  else\n-\t    pat = GEN_FCN ((int) code) (x, y, op2, opalign,\n-\t\t\t\t\tGEN_INT (expected_align\n-\t\t\t\t\t\t / BITS_PER_UNIT),\n-\t\t\t\t\tGEN_INT (expected_size));\n-\t  if (pat)\n+\t  nops = insn_data[(int) code].n_operands;\n+\t  create_fixed_operand (&ops[0], x);\n+\t  create_fixed_operand (&ops[1], y);\n+\t  /* The check above guarantees that this size conversion is valid.  */\n+\t  create_convert_operand_to (&ops[2], size, mode, true);\n+\t  create_integer_operand (&ops[3], align / BITS_PER_UNIT);\n+\t  if (nops != 4)\n+\t    {\n+\t      create_integer_operand (&ops[4], expected_align / BITS_PER_UNIT);\n+\t      create_integer_operand (&ops[5], expected_size);\n+\t      nops = 6;\n+\t    }\n+\t  if (maybe_expand_insn (code, nops, ops))\n \t    {\n-\t      emit_insn (pat);\n \t      volatile_ok = save_volatile_ok;\n \t      return true;\n \t    }\n-\t  else\n-\t    delete_insns_since (last);\n \t}\n     }\n \n@@ -2705,7 +2692,6 @@ set_storage_via_setmem (rtx object, rtx size, rtx val, unsigned int align,\n      including more than one in the machine description unless\n      the more limited one has some advantage.  */\n \n-  rtx opalign = GEN_INT (align / BITS_PER_UNIT);\n   enum machine_mode mode;\n \n   if (expected_align < align)\n@@ -2715,7 +2701,6 @@ set_storage_via_setmem (rtx object, rtx size, rtx val, unsigned int align,\n        mode = GET_MODE_WIDER_MODE (mode))\n     {\n       enum insn_code code = direct_optab_handler (setmem_optab, mode);\n-      insn_operand_predicate_fn pred;\n \n       if (code != CODE_FOR_nothing\n \t  /* We don't need MODE to be narrower than\n@@ -2725,46 +2710,25 @@ set_storage_via_setmem (rtx object, rtx size, rtx val, unsigned int align,\n \t  && ((CONST_INT_P (size)\n \t       && ((unsigned HOST_WIDE_INT) INTVAL (size)\n \t\t   <= (GET_MODE_MASK (mode) >> 1)))\n-\t      || GET_MODE_BITSIZE (mode) >= BITS_PER_WORD)\n-\t  && ((pred = insn_data[(int) code].operand[0].predicate) == 0\n-\t      || (*pred) (object, BLKmode))\n-\t  && ((pred = insn_data[(int) code].operand[3].predicate) == 0\n-\t      || (*pred) (opalign, VOIDmode)))\n-\t{\n-\t  rtx opsize, opchar;\n-\t  enum machine_mode char_mode;\n-\t  rtx last = get_last_insn ();\n-\t  rtx pat;\n-\n-\t  opsize = convert_to_mode (mode, size, 1);\n-\t  pred = insn_data[(int) code].operand[1].predicate;\n-\t  if (pred != 0 && ! (*pred) (opsize, mode))\n-\t    opsize = copy_to_mode_reg (mode, opsize);\n-\n-\t  opchar = val;\n-\t  char_mode = insn_data[(int) code].operand[2].mode;\n-\t  if (char_mode != VOIDmode)\n+\t      || GET_MODE_BITSIZE (mode) >= BITS_PER_WORD))\n+\t{\n+\t  struct expand_operand ops[6];\n+\t  unsigned int nops;\n+\n+\t  nops = insn_data[(int) code].n_operands;\n+\t  create_fixed_operand (&ops[0], object);\n+\t  /* The check above guarantees that this size conversion is valid.  */\n+\t  create_convert_operand_to (&ops[1], size, mode, true);\n+\t  create_convert_operand_from (&ops[2], val, byte_mode, true);\n+\t  create_integer_operand (&ops[3], align / BITS_PER_UNIT);\n+\t  if (nops != 4)\n \t    {\n-\t      opchar = convert_to_mode (char_mode, opchar, 1);\n-\t      pred = insn_data[(int) code].operand[2].predicate;\n-\t      if (pred != 0 && ! (*pred) (opchar, char_mode))\n-\t\topchar = copy_to_mode_reg (char_mode, opchar);\n+\t      create_integer_operand (&ops[4], expected_align / BITS_PER_UNIT);\n+\t      create_integer_operand (&ops[5], expected_size);\n+\t      nops = 6;\n \t    }\n-\n-\t  if (insn_data[(int) code].n_operands == 4)\n-\t    pat = GEN_FCN ((int) code) (object, opsize, opchar, opalign);\n-\t  else\n-\t    pat = GEN_FCN ((int) code) (object, opsize, opchar, opalign,\n-\t\t\t\t\tGEN_INT (expected_align\n-\t\t\t\t\t\t / BITS_PER_UNIT),\n-\t\t\t\t\tGEN_INT (expected_size));\n-\t  if (pat)\n-\t    {\n-\t      emit_insn (pat);\n-\t      return true;\n-\t    }\n-\t  else\n-\t    delete_insns_since (last);\n+\t  if (maybe_expand_insn (code, nops, ops))\n+\t    return true;\n \t}\n     }\n \n@@ -3547,19 +3511,18 @@ emit_single_push_insn (enum machine_mode mode, rtx x, tree type)\n   unsigned rounded_size = PUSH_ROUNDING (GET_MODE_SIZE (mode));\n   rtx dest;\n   enum insn_code icode;\n-  insn_operand_predicate_fn pred;\n \n   stack_pointer_delta += PUSH_ROUNDING (GET_MODE_SIZE (mode));\n   /* If there is push pattern, use it.  Otherwise try old way of throwing\n      MEM representing push operation to move expander.  */\n   icode = optab_handler (push_optab, mode);\n   if (icode != CODE_FOR_nothing)\n     {\n-      if (((pred = insn_data[(int) icode].operand[0].predicate)\n-\t   && !((*pred) (x, mode))))\n-\tx = force_reg (mode, x);\n-      emit_insn (GEN_FCN (icode) (x));\n-      return;\n+      struct expand_operand ops[1];\n+\n+      create_input_operand (&ops[0], x, mode);\n+      if (maybe_expand_insn (icode, 1, ops))\n+\treturn;\n     }\n   if (GET_MODE_SIZE (mode) == rounded_size)\n     dest_addr = gen_rtx_fmt_e (STACK_PUSH_CODE, Pmode, stack_pointer_rtx);\n@@ -4147,7 +4110,8 @@ expand_assignment (tree to, tree from, bool nontemporal)\n   rtx to_rtx = 0;\n   rtx result;\n   enum machine_mode mode;\n-  int align, icode;\n+  int align;\n+  enum insn_code icode;\n \n   /* Don't crash if the lhs of the assignment was erroneous.  */\n   if (TREE_CODE (to) == ERROR_MARK)\n@@ -4170,8 +4134,9 @@ expand_assignment (tree to, tree from, bool nontemporal)\n       && ((icode = optab_handler (movmisalign_optab, mode))\n \t  != CODE_FOR_nothing))\n     {\n-      enum machine_mode address_mode, op_mode1;\n-      rtx insn, reg, op0, mem;\n+      struct expand_operand ops[2];\n+      enum machine_mode address_mode;\n+      rtx reg, op0, mem;\n \n       reg = expand_expr (from, NULL_RTX, VOIDmode, EXPAND_NORMAL);\n       reg = force_not_mem (reg);\n@@ -4212,16 +4177,11 @@ expand_assignment (tree to, tree from, bool nontemporal)\n       if (TREE_THIS_VOLATILE (to))\n \tMEM_VOLATILE_P (mem) = 1;\n \n-      op_mode1 = insn_data[icode].operand[1].mode;\n-      if (! (*insn_data[icode].operand[1].predicate) (reg, op_mode1)\n-\t  && op_mode1 != VOIDmode)\n-\treg = copy_to_mode_reg (op_mode1, reg);\n-\n-      insn = GEN_FCN (icode) (mem, reg);\n+      create_fixed_operand (&ops[0], mem);\n+      create_input_operand (&ops[1], reg, mode);\n       /* The movmisalign<mode> pattern cannot fail, else the assignment would\n          silently be omitted.  */\n-      gcc_assert (insn != NULL_RTX);\n-      emit_insn (insn);\n+      expand_insn (icode, 2, ops);\n       return;\n     }\n \n@@ -4483,31 +4443,16 @@ expand_assignment (tree to, tree from, bool nontemporal)\n bool\n emit_storent_insn (rtx to, rtx from)\n {\n-  enum machine_mode mode = GET_MODE (to), imode;\n+  struct expand_operand ops[2];\n+  enum machine_mode mode = GET_MODE (to);\n   enum insn_code code = optab_handler (storent_optab, mode);\n-  rtx pattern;\n \n   if (code == CODE_FOR_nothing)\n     return false;\n \n-  imode = insn_data[code].operand[0].mode;\n-  if (!insn_data[code].operand[0].predicate (to, imode))\n-    return false;\n-\n-  imode = insn_data[code].operand[1].mode;\n-  if (!insn_data[code].operand[1].predicate (from, imode))\n-    {\n-      from = copy_to_mode_reg (imode, from);\n-      if (!insn_data[code].operand[1].predicate (from, imode))\n-\treturn false;\n-    }\n-\n-  pattern = GEN_FCN (code) (to, from);\n-  if (pattern == NULL_RTX)\n-    return false;\n-\n-  emit_insn (pattern);\n-  return true;\n+  create_fixed_operand (&ops[0], to);\n+  create_input_operand (&ops[1], from, mode);\n+  return maybe_expand_insn (code, 2, ops);\n }\n \n /* Generate code for computing expression EXP,\n@@ -10120,10 +10065,10 @@ try_casesi (tree index_type, tree index_expr, tree minval, tree range,\n \t    rtx table_label ATTRIBUTE_UNUSED, rtx default_label,\n \t    rtx fallback_label ATTRIBUTE_UNUSED)\n {\n+  struct expand_operand ops[5];\n   enum machine_mode index_mode = SImode;\n   int index_bits = GET_MODE_BITSIZE (index_mode);\n   rtx op1, op2, index;\n-  enum machine_mode op_mode;\n \n   if (! HAVE_casesi)\n     return 0;\n@@ -10158,32 +10103,17 @@ try_casesi (tree index_type, tree index_expr, tree minval, tree range,\n \n   do_pending_stack_adjust ();\n \n-  op_mode = insn_data[(int) CODE_FOR_casesi].operand[0].mode;\n-  if (! (*insn_data[(int) CODE_FOR_casesi].operand[0].predicate)\n-      (index, op_mode))\n-    index = copy_to_mode_reg (op_mode, index);\n-\n   op1 = expand_normal (minval);\n-\n-  op_mode = insn_data[(int) CODE_FOR_casesi].operand[1].mode;\n-  op1 = convert_modes (op_mode, TYPE_MODE (TREE_TYPE (minval)),\n-\t\t       op1, TYPE_UNSIGNED (TREE_TYPE (minval)));\n-  if (! (*insn_data[(int) CODE_FOR_casesi].operand[1].predicate)\n-      (op1, op_mode))\n-    op1 = copy_to_mode_reg (op_mode, op1);\n-\n   op2 = expand_normal (range);\n \n-  op_mode = insn_data[(int) CODE_FOR_casesi].operand[2].mode;\n-  op2 = convert_modes (op_mode, TYPE_MODE (TREE_TYPE (range)),\n-\t\t       op2, TYPE_UNSIGNED (TREE_TYPE (range)));\n-  if (! (*insn_data[(int) CODE_FOR_casesi].operand[2].predicate)\n-      (op2, op_mode))\n-    op2 = copy_to_mode_reg (op_mode, op2);\n-\n-  emit_jump_insn (gen_casesi (index, op1, op2,\n-\t\t\t      table_label, !default_label\n-\t\t\t\t\t   ? fallback_label : default_label));\n+  create_input_operand (&ops[0], index, index_mode);\n+  create_convert_operand_from_type (&ops[1], op1, TREE_TYPE (minval));\n+  create_convert_operand_from_type (&ops[2], op2, TREE_TYPE (range));\n+  create_fixed_operand (&ops[3], table_label);\n+  create_fixed_operand (&ops[4], (default_label\n+\t\t\t\t  ? default_label\n+\t\t\t\t  : fallback_label));\n+  expand_jump_insn (CODE_FOR_casesi, 5, ops);\n   return 1;\n }\n "}, {"sha": "d1cfd3a3f9b269ac50a0e271f6cb42a0bb30670e", "filename": "gcc/optabs.c", "status": "modified", "additions": 390, "deletions": 528, "changes": 918, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a5c7d693b920b650fb863e4b9a41b01c199f698f/gcc%2Foptabs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a5c7d693b920b650fb863e4b9a41b01c199f698f/gcc%2Foptabs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Foptabs.c?ref=a5c7d693b920b650fb863e4b9a41b01c199f698f", "patch": "@@ -501,133 +501,52 @@ rtx\n expand_widen_pattern_expr (sepops ops, rtx op0, rtx op1, rtx wide_op,\n \t\t\t   rtx target, int unsignedp)\n {\n+  struct expand_operand eops[4];\n   tree oprnd0, oprnd1, oprnd2;\n   enum machine_mode wmode = VOIDmode, tmode0, tmode1 = VOIDmode;\n   optab widen_pattern_optab;\n-  int icode;\n-  enum machine_mode xmode0, xmode1 = VOIDmode, wxmode = VOIDmode;\n-  rtx temp;\n-  rtx pat;\n-  rtx xop0, xop1, wxop;\n+  enum insn_code icode;\n   int nops = TREE_CODE_LENGTH (ops->code);\n+  int op;\n \n   oprnd0 = ops->op0;\n   tmode0 = TYPE_MODE (TREE_TYPE (oprnd0));\n   widen_pattern_optab =\n     optab_for_tree_code (ops->code, TREE_TYPE (oprnd0), optab_default);\n   if (ops->code == WIDEN_MULT_PLUS_EXPR\n       || ops->code == WIDEN_MULT_MINUS_EXPR)\n-    icode = (int) optab_handler (widen_pattern_optab,\n-\t\t\t\t TYPE_MODE (TREE_TYPE (ops->op2)));\n+    icode = optab_handler (widen_pattern_optab,\n+\t\t\t   TYPE_MODE (TREE_TYPE (ops->op2)));\n   else\n-    icode = (int) optab_handler (widen_pattern_optab, tmode0);\n+    icode = optab_handler (widen_pattern_optab, tmode0);\n   gcc_assert (icode != CODE_FOR_nothing);\n-  xmode0 = insn_data[icode].operand[1].mode;\n \n   if (nops >= 2)\n     {\n       oprnd1 = ops->op1;\n       tmode1 = TYPE_MODE (TREE_TYPE (oprnd1));\n-      xmode1 = insn_data[icode].operand[2].mode;\n     }\n \n   /* The last operand is of a wider mode than the rest of the operands.  */\n   if (nops == 2)\n-    {\n-      wmode = tmode1;\n-      wxmode = xmode1;\n-    }\n+    wmode = tmode1;\n   else if (nops == 3)\n     {\n       gcc_assert (tmode1 == tmode0);\n       gcc_assert (op1);\n       oprnd2 = ops->op2;\n       wmode = TYPE_MODE (TREE_TYPE (oprnd2));\n-      wxmode = insn_data[icode].operand[3].mode;\n     }\n \n-  if (!wide_op)\n-    wmode = wxmode = insn_data[icode].operand[0].mode;\n-\n-  if (!target\n-      || ! (*insn_data[icode].operand[0].predicate) (target, wmode))\n-    temp = gen_reg_rtx (wmode);\n-  else\n-    temp = target;\n-\n-  xop0 = op0;\n-  xop1 = op1;\n-  wxop = wide_op;\n-\n-  /* In case the insn wants input operands in modes different from\n-     those of the actual operands, convert the operands.  It would\n-     seem that we don't need to convert CONST_INTs, but we do, so\n-     that they're properly zero-extended, sign-extended or truncated\n-     for their mode.  */\n-\n-  if (GET_MODE (op0) != xmode0 && xmode0 != VOIDmode)\n-    xop0 = convert_modes (xmode0,\n-                          GET_MODE (op0) != VOIDmode\n-                          ? GET_MODE (op0)\n-                          : tmode0,\n-                          xop0, unsignedp);\n-\n+  op = 0;\n+  create_output_operand (&eops[op++], target, TYPE_MODE (ops->type));\n+  create_convert_operand_from (&eops[op++], op0, tmode0, unsignedp);\n   if (op1)\n-    if (GET_MODE (op1) != xmode1 && xmode1 != VOIDmode)\n-      xop1 = convert_modes (xmode1,\n-                            GET_MODE (op1) != VOIDmode\n-                            ? GET_MODE (op1)\n-                            : tmode1,\n-                            xop1, unsignedp);\n-\n+    create_convert_operand_from (&eops[op++], op1, tmode1, unsignedp);\n   if (wide_op)\n-    if (GET_MODE (wide_op) != wxmode && wxmode != VOIDmode)\n-      wxop = convert_modes (wxmode,\n-                            GET_MODE (wide_op) != VOIDmode\n-                            ? GET_MODE (wide_op)\n-                            : wmode,\n-                            wxop, unsignedp);\n-\n-  /* Now, if insn's predicates don't allow our operands, put them into\n-     pseudo regs.  */\n-\n-  if (! (*insn_data[icode].operand[1].predicate) (xop0, xmode0)\n-      && xmode0 != VOIDmode)\n-    xop0 = copy_to_mode_reg (xmode0, xop0);\n-\n-  if (op1)\n-    {\n-      if (! (*insn_data[icode].operand[2].predicate) (xop1, xmode1)\n-          && xmode1 != VOIDmode)\n-        xop1 = copy_to_mode_reg (xmode1, xop1);\n-\n-      if (wide_op)\n-        {\n-          if (! (*insn_data[icode].operand[3].predicate) (wxop, wxmode)\n-              && wxmode != VOIDmode)\n-            wxop = copy_to_mode_reg (wxmode, wxop);\n-\n-          pat = GEN_FCN (icode) (temp, xop0, xop1, wxop);\n-        }\n-      else\n-        pat = GEN_FCN (icode) (temp, xop0, xop1);\n-    }\n-  else\n-    {\n-      if (wide_op)\n-        {\n-          if (! (*insn_data[icode].operand[2].predicate) (wxop, wxmode)\n-              && wxmode != VOIDmode)\n-            wxop = copy_to_mode_reg (wxmode, wxop);\n-\n-          pat = GEN_FCN (icode) (temp, xop0, wxop);\n-        }\n-      else\n-        pat = GEN_FCN (icode) (temp, xop0);\n-    }\n-\n-  emit_insn (pat);\n-  return temp;\n+    create_convert_operand_from (&eops[op++], wide_op, wmode, unsignedp);\n+  expand_insn (icode, op, eops);\n+  return eops[0].value;\n }\n \n /* Generate code to perform an operation specified by TERNARY_OPTAB\n@@ -645,67 +564,17 @@ rtx\n expand_ternary_op (enum machine_mode mode, optab ternary_optab, rtx op0,\n \t\t   rtx op1, rtx op2, rtx target, int unsignedp)\n {\n-  int icode = (int) optab_handler (ternary_optab, mode);\n-  enum machine_mode mode0 = insn_data[icode].operand[1].mode;\n-  enum machine_mode mode1 = insn_data[icode].operand[2].mode;\n-  enum machine_mode mode2 = insn_data[icode].operand[3].mode;\n-  rtx temp;\n-  rtx pat;\n-  rtx xop0 = op0, xop1 = op1, xop2 = op2;\n+  struct expand_operand ops[4];\n+  enum insn_code icode = optab_handler (ternary_optab, mode);\n \n   gcc_assert (optab_handler (ternary_optab, mode) != CODE_FOR_nothing);\n \n-  if (!target || !insn_data[icode].operand[0].predicate (target, mode))\n-    temp = gen_reg_rtx (mode);\n-  else\n-    temp = target;\n-\n-  /* In case the insn wants input operands in modes different from\n-     those of the actual operands, convert the operands.  It would\n-     seem that we don't need to convert CONST_INTs, but we do, so\n-     that they're properly zero-extended, sign-extended or truncated\n-     for their mode.  */\n-\n-  if (GET_MODE (op0) != mode0 && mode0 != VOIDmode)\n-    xop0 = convert_modes (mode0,\n-                          GET_MODE (op0) != VOIDmode\n-                          ? GET_MODE (op0)\n-                          : mode,\n-                          xop0, unsignedp);\n-\n-  if (GET_MODE (op1) != mode1 && mode1 != VOIDmode)\n-    xop1 = convert_modes (mode1,\n-                          GET_MODE (op1) != VOIDmode\n-                          ? GET_MODE (op1)\n-                          : mode,\n-                          xop1, unsignedp);\n-\n-  if (GET_MODE (op2) != mode2 && mode2 != VOIDmode)\n-    xop2 = convert_modes (mode2,\n-                          GET_MODE (op2) != VOIDmode\n-                          ? GET_MODE (op2)\n-                          : mode,\n-                          xop2, unsignedp);\n-\n-  /* Now, if insn's predicates don't allow our operands, put them into\n-     pseudo regs.  */\n-\n-  if (!insn_data[icode].operand[1].predicate (xop0, mode0)\n-      && mode0 != VOIDmode)\n-    xop0 = copy_to_mode_reg (mode0, xop0);\n-\n-  if (!insn_data[icode].operand[2].predicate (xop1, mode1)\n-      && mode1 != VOIDmode)\n-    xop1 = copy_to_mode_reg (mode1, xop1);\n-\n-  if (!insn_data[icode].operand[3].predicate (xop2, mode2)\n-      && mode2 != VOIDmode)\n-    xop2 = copy_to_mode_reg (mode2, xop2);\n-\n-  pat = GEN_FCN (icode) (temp, xop0, xop1, xop2);\n-\n-  emit_insn (pat);\n-  return temp;\n+  create_output_operand (&ops[0], target, mode);\n+  create_convert_operand_from (&ops[1], op0, mode, unsignedp);\n+  create_convert_operand_from (&ops[2], op1, mode, unsignedp);\n+  create_convert_operand_from (&ops[3], op2, mode, unsignedp);\n+  expand_insn (icode, 4, ops);\n+  return ops[0].value;\n }\n \n \n@@ -751,15 +620,13 @@ force_expand_binop (enum machine_mode mode, optab binoptab,\n rtx\n expand_vec_shift_expr (sepops ops, rtx target)\n {\n+  struct expand_operand eops[3];\n   enum insn_code icode;\n   rtx rtx_op1, rtx_op2;\n-  enum machine_mode mode1;\n-  enum machine_mode mode2;\n   enum machine_mode mode = TYPE_MODE (ops->type);\n   tree vec_oprnd = ops->op0;\n   tree shift_oprnd = ops->op1;\n   optab shift_optab;\n-  rtx pat;\n \n   switch (ops->code)\n     {\n@@ -776,29 +643,15 @@ expand_vec_shift_expr (sepops ops, rtx target)\n   icode = optab_handler (shift_optab, mode);\n   gcc_assert (icode != CODE_FOR_nothing);\n \n-  mode1 = insn_data[icode].operand[1].mode;\n-  mode2 = insn_data[icode].operand[2].mode;\n-\n   rtx_op1 = expand_normal (vec_oprnd);\n-  if (!(*insn_data[icode].operand[1].predicate) (rtx_op1, mode1)\n-      && mode1 != VOIDmode)\n-    rtx_op1 = force_reg (mode1, rtx_op1);\n-\n   rtx_op2 = expand_normal (shift_oprnd);\n-  if (!(*insn_data[icode].operand[2].predicate) (rtx_op2, mode2)\n-      && mode2 != VOIDmode)\n-    rtx_op2 = force_reg (mode2, rtx_op2);\n \n-  if (!target\n-      || ! (*insn_data[icode].operand[0].predicate) (target, mode))\n-    target = gen_reg_rtx (mode);\n+  create_output_operand (&eops[0], target, mode);\n+  create_input_operand (&eops[1], rtx_op1, GET_MODE (rtx_op1));\n+  create_convert_operand_from_type (&eops[2], rtx_op2, TREE_TYPE (shift_oprnd));\n+  expand_insn (icode, 3, eops);\n \n-  /* Emit instruction */\n-  pat = GEN_FCN (icode) (target, rtx_op1, rtx_op2);\n-  gcc_assert (pat);\n-  emit_insn (pat);\n-\n-  return target;\n+  return eops[0].value;\n }\n \n /* This subroutine of expand_doubleword_shift handles the cases in which\n@@ -1389,21 +1242,16 @@ expand_binop_directly (enum machine_mode mode, optab binoptab,\n \t\t       rtx target, int unsignedp, enum optab_methods methods,\n \t\t       rtx last)\n {\n-  int icode = (int) optab_handler (binoptab, mode);\n-  enum machine_mode mode0 = insn_data[icode].operand[1].mode;\n-  enum machine_mode mode1 = insn_data[icode].operand[2].mode;\n+  enum insn_code icode = optab_handler (binoptab, mode);\n+  enum machine_mode mode0 = insn_data[(int) icode].operand[1].mode;\n+  enum machine_mode mode1 = insn_data[(int) icode].operand[2].mode;\n   enum machine_mode tmp_mode;\n+  struct expand_operand ops[3];\n   bool commutative_p;\n   rtx pat;\n   rtx xop0 = op0, xop1 = op1;\n-  rtx temp;\n   rtx swap;\n \n-  if (target)\n-    temp = target;\n-  else\n-    temp = gen_reg_rtx (mode);\n-\n   /* If it is a commutative operator and the modes would match\n      if we would swap the operands, we can save the conversions.  */\n   commutative_p = commutative_optab_p (binoptab);\n@@ -1421,49 +1269,9 @@ expand_binop_directly (enum machine_mode mode, optab binoptab,\n   if (!shift_optab_p (binoptab))\n     xop1 = avoid_expensive_constant (mode1, binoptab, xop1, unsignedp);\n \n-  /* In case the insn wants input operands in modes different from\n-     those of the actual operands, convert the operands.  It would\n-     seem that we don't need to convert CONST_INTs, but we do, so\n-     that they're properly zero-extended, sign-extended or truncated\n-     for their mode.  */\n-\n-  if (GET_MODE (xop0) != mode0 && mode0 != VOIDmode)\n-    xop0 = convert_modes (mode0,\n-\t\t\t  GET_MODE (xop0) != VOIDmode\n-\t\t\t  ? GET_MODE (xop0)\n-\t\t\t  : mode,\n-\t\t\t  xop0, unsignedp);\n-\n-  if (GET_MODE (xop1) != mode1 && mode1 != VOIDmode)\n-    xop1 = convert_modes (mode1,\n-\t\t\t  GET_MODE (xop1) != VOIDmode\n-\t\t\t  ? GET_MODE (xop1)\n-\t\t\t  : mode,\n-\t\t\t  xop1, unsignedp);\n-\n-  /* If operation is commutative,\n-     try to make the first operand a register.\n-     Even better, try to make it the same as the target.\n-     Also try to make the last operand a constant.  */\n-  if (commutative_p\n-      && swap_commutative_operands_with_target (target, xop0, xop1))\n-    {\n-      swap = xop1;\n-      xop1 = xop0;\n-      xop0 = swap;\n-    }\n-\n   /* Now, if insn's predicates don't allow our operands, put them into\n      pseudo regs.  */\n \n-  if (!insn_data[icode].operand[1].predicate (xop0, mode0)\n-      && mode0 != VOIDmode)\n-    xop0 = copy_to_mode_reg (mode0, xop0);\n-\n-  if (!insn_data[icode].operand[2].predicate (xop1, mode1)\n-      && mode1 != VOIDmode)\n-    xop1 = copy_to_mode_reg (mode1, xop1);\n-\n   if (binoptab == vec_pack_trunc_optab\n       || binoptab == vec_pack_usat_optab\n       || binoptab == vec_pack_ssat_optab\n@@ -1472,34 +1280,53 @@ expand_binop_directly (enum machine_mode mode, optab binoptab,\n     {\n       /* The mode of the result is different then the mode of the\n \t arguments.  */\n-      tmp_mode = insn_data[icode].operand[0].mode;\n+      tmp_mode = insn_data[(int) icode].operand[0].mode;\n       if (GET_MODE_NUNITS (tmp_mode) != 2 * GET_MODE_NUNITS (mode))\n-\treturn 0;\n+\t{\n+\t  delete_insns_since (last);\n+\t  return NULL_RTX;\n+\t}\n     }\n   else\n     tmp_mode = mode;\n \n-  if (!insn_data[icode].operand[0].predicate (temp, tmp_mode))\n-    temp = gen_reg_rtx (tmp_mode);\n-\n-  pat = GEN_FCN (icode) (temp, xop0, xop1);\n-  if (pat)\n-    {\n-      /* If PAT is composed of more than one insn, try to add an appropriate\n-\t REG_EQUAL note to it.  If we can't because TEMP conflicts with an\n-\t operand, call expand_binop again, this time without a target.  */\n-      if (INSN_P (pat) && NEXT_INSN (pat) != NULL_RTX\n-\t  && ! add_equal_note (pat, temp, binoptab->code, xop0, xop1))\n+  create_output_operand (&ops[0], target, tmp_mode);\n+  create_convert_operand_from (&ops[1], xop0, mode, unsignedp);\n+  create_convert_operand_from (&ops[2], xop1, mode, unsignedp);\n+  if (maybe_legitimize_operands (icode, 0, 3, ops))\n+    {\n+      /* If operation is commutative,\n+\t try to make the first operand a register.\n+\t Even better, try to make it the same as the target.\n+\t Also try to make the last operand a constant.  */\n+      if (commutative_p\n+\t  && swap_commutative_operands_with_target (ops[0].value, ops[1].value,\n+\t\t\t\t\t\t    ops[2].value))\n \t{\n-\t  delete_insns_since (last);\n-\t  return expand_binop (mode, binoptab, op0, op1, NULL_RTX,\n-\t\t\t       unsignedp, methods);\n+\t  swap = ops[2].value;\n+\t  ops[2].value = ops[1].value;\n+\t  ops[1].value = swap;\n \t}\n \n-      emit_insn (pat);\n-      return temp;\n-    }\n+      pat = GEN_FCN (icode) (ops[0].value, ops[1].value, ops[2].value);\n+      if (pat)\n+\t{\n+\t  /* If PAT is composed of more than one insn, try to add an appropriate\n+\t     REG_EQUAL note to it.  If we can't because TEMP conflicts with an\n+\t     operand, call expand_binop again, this time without a target.  */\n+\t  if (INSN_P (pat) && NEXT_INSN (pat) != NULL_RTX\n+\t      && ! add_equal_note (pat, ops[0].value, binoptab->code,\n+\t\t\t\t   ops[1].value, ops[2].value))\n+\t    {\n+\t      delete_insns_since (last);\n+\t      return expand_binop (mode, binoptab, op0, op1, NULL_RTX,\n+\t\t\t\t   unsignedp, methods);\n+\t    }\n \n+\t  emit_insn (pat);\n+\t  return ops[0].value;\n+\t}\n+    }\n   delete_insns_since (last);\n   return NULL_RTX;\n }\n@@ -2284,32 +2111,14 @@ expand_twoval_unop (optab unoptab, rtx op0, rtx targ0, rtx targ1,\n \n   if (optab_handler (unoptab, mode) != CODE_FOR_nothing)\n     {\n-      int icode = (int) optab_handler (unoptab, mode);\n-      enum machine_mode mode0 = insn_data[icode].operand[2].mode;\n-      rtx pat;\n-      rtx xop0 = op0;\n-\n-      if (GET_MODE (xop0) != VOIDmode\n-\t  && GET_MODE (xop0) != mode0)\n-\txop0 = convert_to_mode (mode0, xop0, unsignedp);\n+      struct expand_operand ops[3];\n+      enum insn_code icode = optab_handler (unoptab, mode);\n \n-      /* Now, if insn doesn't accept these operands, put them into pseudos.  */\n-      if (!insn_data[icode].operand[2].predicate (xop0, mode0))\n-\txop0 = copy_to_mode_reg (mode0, xop0);\n-\n-      /* We could handle this, but we should always be called with a pseudo\n-\t for our targets and all insns should take them as outputs.  */\n-      gcc_assert (insn_data[icode].operand[0].predicate (targ0, mode));\n-      gcc_assert (insn_data[icode].operand[1].predicate (targ1, mode));\n-\n-      pat = GEN_FCN (icode) (targ0, targ1, xop0);\n-      if (pat)\n-\t{\n-\t  emit_insn (pat);\n-\t  return 1;\n-\t}\n-      else\n-\tdelete_insns_since (last);\n+      create_fixed_operand (&ops[0], targ0);\n+      create_fixed_operand (&ops[1], targ1);\n+      create_convert_operand_from (&ops[2], op0, mode, unsignedp);\n+      if (maybe_expand_insn (icode, 3, ops))\n+\treturn 1;\n     }\n \n   /* It can't be done in this mode.  Can we do it in a wider mode?  */\n@@ -2376,56 +2185,23 @@ expand_twoval_binop (optab binoptab, rtx op0, rtx op1, rtx targ0, rtx targ1,\n \n   if (optab_handler (binoptab, mode) != CODE_FOR_nothing)\n     {\n-      int icode = (int) optab_handler (binoptab, mode);\n+      struct expand_operand ops[4];\n+      enum insn_code icode = optab_handler (binoptab, mode);\n       enum machine_mode mode0 = insn_data[icode].operand[1].mode;\n       enum machine_mode mode1 = insn_data[icode].operand[2].mode;\n-      rtx pat;\n       rtx xop0 = op0, xop1 = op1;\n \n       /* If we are optimizing, force expensive constants into a register.  */\n       xop0 = avoid_expensive_constant (mode0, binoptab, xop0, unsignedp);\n       xop1 = avoid_expensive_constant (mode1, binoptab, xop1, unsignedp);\n \n-      /* In case the insn wants input operands in modes different from\n-\t those of the actual operands, convert the operands.  It would\n-\t seem that we don't need to convert CONST_INTs, but we do, so\n-\t that they're properly zero-extended, sign-extended or truncated\n-\t for their mode.  */\n-\n-      if (GET_MODE (op0) != mode0 && mode0 != VOIDmode)\n-\txop0 = convert_modes (mode0,\n-\t\t\t      GET_MODE (op0) != VOIDmode\n-\t\t\t      ? GET_MODE (op0)\n-\t\t\t      : mode,\n-\t\t\t      xop0, unsignedp);\n-\n-      if (GET_MODE (op1) != mode1 && mode1 != VOIDmode)\n-\txop1 = convert_modes (mode1,\n-\t\t\t      GET_MODE (op1) != VOIDmode\n-\t\t\t      ? GET_MODE (op1)\n-\t\t\t      : mode,\n-\t\t\t      xop1, unsignedp);\n-\n-      /* Now, if insn doesn't accept these operands, put them into pseudos.  */\n-      if (!insn_data[icode].operand[1].predicate (xop0, mode0))\n-\txop0 = copy_to_mode_reg (mode0, xop0);\n-\n-      if (!insn_data[icode].operand[2].predicate (xop1, mode1))\n-\txop1 = copy_to_mode_reg (mode1, xop1);\n-\n-      /* We could handle this, but we should always be called with a pseudo\n-\t for our targets and all insns should take them as outputs.  */\n-      gcc_assert (insn_data[icode].operand[0].predicate (targ0, mode));\n-      gcc_assert (insn_data[icode].operand[3].predicate (targ1, mode));\n-\n-      pat = GEN_FCN (icode) (targ0, xop0, xop1, targ1);\n-      if (pat)\n-\t{\n-\t  emit_insn (pat);\n-\t  return 1;\n-\t}\n-      else\n-\tdelete_insns_since (last);\n+      create_fixed_operand (&ops[0], targ0);\n+      create_convert_operand_from (&ops[1], op0, mode, unsignedp);\n+      create_convert_operand_from (&ops[2], op1, mode, unsignedp);\n+      create_fixed_operand (&ops[3], targ1);\n+      if (maybe_expand_insn (icode, 4, ops))\n+\treturn 1;\n+      delete_insns_since (last);\n     }\n \n   /* It can't be done in this mode.  Can we do it in a wider mode?  */\n@@ -2985,45 +2761,28 @@ expand_unop_direct (enum machine_mode mode, optab unoptab, rtx op0, rtx target,\n {\n   if (optab_handler (unoptab, mode) != CODE_FOR_nothing)\n     {\n-      int icode = (int) optab_handler (unoptab, mode);\n-      enum machine_mode mode0 = insn_data[icode].operand[1].mode;\n-      rtx xop0 = op0;\n+      struct expand_operand ops[2];\n+      enum insn_code icode = optab_handler (unoptab, mode);\n       rtx last = get_last_insn ();\n-      rtx pat, temp;\n-\n-      if (target)\n-\ttemp = target;\n-      else\n-\ttemp = gen_reg_rtx (mode);\n-\n-      if (GET_MODE (xop0) != VOIDmode\n-\t  && GET_MODE (xop0) != mode0)\n-\txop0 = convert_to_mode (mode0, xop0, unsignedp);\n-\n-      /* Now, if insn doesn't accept our operand, put it into a pseudo.  */\n-\n-      if (!insn_data[icode].operand[1].predicate (xop0, mode0))\n-\txop0 = copy_to_mode_reg (mode0, xop0);\n-\n-      if (!insn_data[icode].operand[0].predicate (temp, mode))\n-\ttemp = gen_reg_rtx (mode);\n+      rtx pat;\n \n-      pat = GEN_FCN (icode) (temp, xop0);\n+      create_output_operand (&ops[0], target, mode);\n+      create_convert_operand_from (&ops[1], op0, mode, unsignedp);\n+      pat = maybe_gen_insn (icode, 2, ops);\n       if (pat)\n \t{\n \t  if (INSN_P (pat) && NEXT_INSN (pat) != NULL_RTX\n-\t      && ! add_equal_note (pat, temp, unoptab->code, xop0, NULL_RTX))\n+\t      && ! add_equal_note (pat, ops[0].value, unoptab->code,\n+\t\t\t\t   ops[1].value, NULL_RTX))\n \t    {\n \t      delete_insns_since (last);\n \t      return expand_unop (mode, unoptab, op0, NULL_RTX, unsignedp);\n \t    }\n \n \t  emit_insn (pat);\n \n-\t  return temp;\n+\t  return ops[0].value;\n \t}\n-      else\n-\tdelete_insns_since (last);\n     }\n   return 0;\n }\n@@ -3499,18 +3258,18 @@ expand_copysign_absneg (enum machine_mode mode, rtx op0, rtx op1, rtx target,\n \t\t        int bitpos, bool op0_is_abs)\n {\n   enum machine_mode imode;\n-  int icode;\n+  enum insn_code icode;\n   rtx sign, label;\n \n   if (target == op1)\n     target = NULL_RTX;\n \n   /* Check if the back end provides an insn that handles signbit for the\n      argument's mode. */\n-  icode = (int) optab_handler (signbit_optab, mode);\n+  icode = optab_handler (signbit_optab, mode);\n   if (icode != CODE_FOR_nothing)\n     {\n-      imode = insn_data[icode].operand[0].mode;\n+      imode = insn_data[(int) icode].operand[0].mode;\n       sign = gen_reg_rtx (imode);\n       emit_unop_insn (icode, sign, op1, UNKNOWN);\n     }\n@@ -3731,37 +3490,25 @@ expand_copysign (rtx op0, rtx op1, rtx target)\n    Return false if expansion failed.  */\n \n bool\n-maybe_emit_unop_insn (int icode, rtx target, rtx op0, enum rtx_code code)\n+maybe_emit_unop_insn (enum insn_code icode, rtx target, rtx op0,\n+\t\t      enum rtx_code code)\n {\n-  rtx temp;\n-  enum machine_mode mode0 = insn_data[icode].operand[1].mode;\n+  struct expand_operand ops[2];\n   rtx pat;\n-  rtx last = get_last_insn ();\n-\n-  temp = target;\n-\n-  /* Now, if insn does not accept our operands, put them into pseudos.  */\n-\n-  if (!insn_data[icode].operand[1].predicate (op0, mode0))\n-    op0 = copy_to_mode_reg (mode0, op0);\n \n-  if (!insn_data[icode].operand[0].predicate (temp, GET_MODE (temp)))\n-    temp = gen_reg_rtx (GET_MODE (temp));\n-\n-  pat = GEN_FCN (icode) (temp, op0);\n+  create_output_operand (&ops[0], target, GET_MODE (target));\n+  create_input_operand (&ops[1], op0, GET_MODE (op0));\n+  pat = maybe_gen_insn (icode, 2, ops);\n   if (!pat)\n-    {\n-      delete_insns_since (last);\n-      return false;\n-    }\n+    return false;\n \n   if (INSN_P (pat) && NEXT_INSN (pat) != NULL_RTX && code != UNKNOWN)\n-    add_equal_note (pat, temp, code, op0, NULL_RTX);\n+    add_equal_note (pat, ops[0].value, code, ops[1].value, NULL_RTX);\n \n   emit_insn (pat);\n \n-  if (temp != target)\n-    emit_move_insn (target, temp);\n+  if (ops[0].value != target)\n+    emit_move_insn (target, ops[0].value);\n   return true;\n }\n /* Generate an instruction whose insn-code is INSN_CODE,\n@@ -3771,7 +3518,7 @@ maybe_emit_unop_insn (int icode, rtx target, rtx op0, enum rtx_code code)\n    the value that is stored into TARGET.  */\n \n void\n-emit_unop_insn (int icode, rtx target, rtx op0, enum rtx_code code)\n+emit_unop_insn (enum insn_code icode, rtx target, rtx op0, enum rtx_code code)\n {\n   bool ok = maybe_emit_unop_insn (icode, target, op0, code);\n   gcc_assert (ok);\n@@ -4418,11 +4165,10 @@ prepare_float_lib_cmp (rtx x, rtx y, enum rtx_code comparison,\n void\n emit_indirect_jump (rtx loc)\n {\n-  if (!insn_data[(int) CODE_FOR_indirect_jump].operand[0].predicate\n-      (loc, Pmode))\n-    loc = copy_to_mode_reg (Pmode, loc);\n+  struct expand_operand ops[1];\n \n-  emit_jump_insn (gen_indirect_jump (loc));\n+  create_address_operand (&ops[0], loc);\n+  expand_jump_insn (CODE_FOR_indirect_jump, 1, ops);\n   emit_barrier ();\n }\n \f\n@@ -4447,7 +4193,7 @@ emit_conditional_move (rtx target, enum rtx_code code, rtx op0, rtx op1,\n \t\t       enum machine_mode cmode, rtx op2, rtx op3,\n \t\t       enum machine_mode mode, int unsignedp)\n {\n-  rtx tem, subtarget, comparison, insn;\n+  rtx tem, comparison, last;\n   enum insn_code icode;\n   enum rtx_code reversed;\n \n@@ -4494,24 +4240,6 @@ emit_conditional_move (rtx target, enum rtx_code code, rtx op0, rtx op1,\n   if (!target)\n     target = gen_reg_rtx (mode);\n \n-  subtarget = target;\n-\n-  /* If the insn doesn't accept these operands, put them in pseudos.  */\n-\n-  if (!insn_data[icode].operand[0].predicate\n-      (subtarget, insn_data[icode].operand[0].mode))\n-    subtarget = gen_reg_rtx (insn_data[icode].operand[0].mode);\n-\n-  if (!insn_data[icode].operand[2].predicate\n-      (op2, insn_data[icode].operand[2].mode))\n-    op2 = copy_to_mode_reg (insn_data[icode].operand[2].mode, op2);\n-\n-  if (!insn_data[icode].operand[3].predicate\n-      (op3, insn_data[icode].operand[3].mode))\n-    op3 = copy_to_mode_reg (insn_data[icode].operand[3].mode, op3);\n-\n-  /* Everything should now be in the suitable form.  */\n-\n   code = unsignedp ? unsigned_condition (code) : code;\n   comparison = simplify_gen_relational (code, VOIDmode, cmode, op0, op1);\n \n@@ -4522,30 +4250,27 @@ emit_conditional_move (rtx target, enum rtx_code code, rtx op0, rtx op1,\n     return NULL_RTX;\n \n   do_pending_stack_adjust ();\n-  start_sequence ();\n+  last = get_last_insn ();\n   prepare_cmp_insn (XEXP (comparison, 0), XEXP (comparison, 1),\n \t\t    GET_CODE (comparison), NULL_RTX, unsignedp, OPTAB_WIDEN,\n \t\t    &comparison, &cmode);\n-  if (!comparison)\n-    insn = NULL_RTX;\n-  else\n-    insn = GEN_FCN (icode) (subtarget, comparison, op2, op3);\n-\n-  /* If that failed, then give up.  */\n-  if (insn == 0)\n+  if (comparison)\n     {\n-      end_sequence ();\n-      return 0;\n-    }\n-\n-  emit_insn (insn);\n-  insn = get_insns ();\n-  end_sequence ();\n-  emit_insn (insn);\n-  if (subtarget != target)\n-    convert_move (target, subtarget, 0);\n+      struct expand_operand ops[4];\n \n-  return target;\n+      create_output_operand (&ops[0], target, mode);\n+      create_fixed_operand (&ops[1], comparison);\n+      create_input_operand (&ops[2], op2, mode);\n+      create_input_operand (&ops[3], op3, mode);\n+      if (maybe_expand_insn (icode, 4, ops))\n+\t{\n+\t  if (ops[0].value != target)\n+\t    convert_move (target, ops[0].value, false);\n+\t  return target;\n+\t}\n+    }\n+  delete_insns_since (last);\n+  return NULL_RTX;\n }\n \n /* Return nonzero if a conditional move of mode MODE is supported.\n@@ -4586,7 +4311,7 @@ emit_conditional_add (rtx target, enum rtx_code code, rtx op0, rtx op1,\n \t\t      enum machine_mode cmode, rtx op2, rtx op3,\n \t\t      enum machine_mode mode, int unsignedp)\n {\n-  rtx tem, subtarget, comparison, insn;\n+  rtx tem, comparison, last;\n   enum insn_code icode;\n   enum rtx_code reversed;\n \n@@ -4633,24 +4358,6 @@ emit_conditional_add (rtx target, enum rtx_code code, rtx op0, rtx op1,\n   if (!target)\n     target = gen_reg_rtx (mode);\n \n-  /* If the insn doesn't accept these operands, put them in pseudos.  */\n-\n-  if (!insn_data[icode].operand[0].predicate\n-      (target, insn_data[icode].operand[0].mode))\n-    subtarget = gen_reg_rtx (insn_data[icode].operand[0].mode);\n-  else\n-    subtarget = target;\n-\n-  if (!insn_data[icode].operand[2].predicate\n-      (op2, insn_data[icode].operand[2].mode))\n-    op2 = copy_to_mode_reg (insn_data[icode].operand[2].mode, op2);\n-\n-  if (!insn_data[icode].operand[3].predicate\n-      (op3, insn_data[icode].operand[3].mode))\n-    op3 = copy_to_mode_reg (insn_data[icode].operand[3].mode, op3);\n-\n-  /* Everything should now be in the suitable form.  */\n-\n   code = unsignedp ? unsigned_condition (code) : code;\n   comparison = simplify_gen_relational (code, VOIDmode, cmode, op0, op1);\n \n@@ -4661,30 +4368,27 @@ emit_conditional_add (rtx target, enum rtx_code code, rtx op0, rtx op1,\n     return NULL_RTX;\n \n   do_pending_stack_adjust ();\n-  start_sequence ();\n+  last = get_last_insn ();\n   prepare_cmp_insn (XEXP (comparison, 0), XEXP (comparison, 1),\n                     GET_CODE (comparison), NULL_RTX, unsignedp, OPTAB_WIDEN,\n                     &comparison, &cmode);\n-  if (!comparison)\n-    insn = NULL_RTX;\n-  else\n-    insn = GEN_FCN (icode) (subtarget, comparison, op2, op3);\n-\n-  /* If that failed, then give up.  */\n-  if (insn == 0)\n+  if (comparison)\n     {\n-      end_sequence ();\n-      return 0;\n-    }\n-\n-  emit_insn (insn);\n-  insn = get_insns ();\n-  end_sequence ();\n-  emit_insn (insn);\n-  if (subtarget != target)\n-    convert_move (target, subtarget, 0);\n+      struct expand_operand ops[4];\n \n-  return target;\n+      create_output_operand (&ops[0], target, mode);\n+      create_fixed_operand (&ops[1], comparison);\n+      create_input_operand (&ops[2], op2, mode);\n+      create_input_operand (&ops[3], op3, mode);\n+      if (maybe_expand_insn (icode, 4, ops))\n+\t{\n+\t  if (ops[0].value != target)\n+\t    convert_move (target, ops[0].value, false);\n+\t  return target;\n+\t}\n+    }\n+  delete_insns_since (last);\n+  return NULL_RTX;\n }\n \f\n /* These functions attempt to generate an insn body, rather than\n@@ -6713,6 +6417,7 @@ get_rtx_code (enum tree_code tcode, bool unsignedp)\n static rtx\n vector_compare_rtx (tree cond, bool unsignedp, enum insn_code icode)\n {\n+  struct expand_operand ops[2];\n   enum rtx_code rcode;\n   tree t_op0, t_op1;\n   rtx rtx_op0, rtx_op1;\n@@ -6731,15 +6436,11 @@ vector_compare_rtx (tree cond, bool unsignedp, enum insn_code icode)\n   rtx_op1 = expand_expr (t_op1, NULL_RTX, TYPE_MODE (TREE_TYPE (t_op1)),\n \t\t\t EXPAND_STACK_PARM);\n \n-  if (!insn_data[icode].operand[4].predicate (rtx_op0, GET_MODE (rtx_op0))\n-      && GET_MODE (rtx_op0) != VOIDmode)\n-    rtx_op0 = force_reg (GET_MODE (rtx_op0), rtx_op0);\n-\n-  if (!insn_data[icode].operand[5].predicate (rtx_op1, GET_MODE (rtx_op1))\n-      && GET_MODE (rtx_op1) != VOIDmode)\n-    rtx_op1 = force_reg (GET_MODE (rtx_op1), rtx_op1);\n-\n-  return gen_rtx_fmt_ee (rcode, VOIDmode, rtx_op0, rtx_op1);\n+  create_input_operand (&ops[0], rtx_op0, GET_MODE (rtx_op0));\n+  create_input_operand (&ops[1], rtx_op1, GET_MODE (rtx_op1));\n+  if (!maybe_legitimize_operands (icode, 4, 2, ops))\n+    gcc_unreachable ();\n+  return gen_rtx_fmt_ee (rcode, VOIDmode, ops[0].value, ops[1].value);\n }\n \n /* Return insn code for TYPE, the type of a VEC_COND_EXPR.  */\n@@ -6774,39 +6475,28 @@ rtx\n expand_vec_cond_expr (tree vec_cond_type, tree op0, tree op1, tree op2,\n \t\t      rtx target)\n {\n+  struct expand_operand ops[6];\n   enum insn_code icode;\n-  rtx comparison, rtx_op1, rtx_op2, cc_op0, cc_op1;\n+  rtx comparison, rtx_op1, rtx_op2;\n   enum machine_mode mode = TYPE_MODE (vec_cond_type);\n   bool unsignedp = TYPE_UNSIGNED (vec_cond_type);\n \n   icode = get_vcond_icode (vec_cond_type, mode);\n   if (icode == CODE_FOR_nothing)\n     return 0;\n \n-  if (!target || !insn_data[icode].operand[0].predicate (target, mode))\n-    target = gen_reg_rtx (mode);\n-\n-  /* Get comparison rtx.  First expand both cond expr operands.  */\n-  comparison = vector_compare_rtx (op0,\n-\t\t\t\t   unsignedp, icode);\n-  cc_op0 = XEXP (comparison, 0);\n-  cc_op1 = XEXP (comparison, 1);\n-  /* Expand both operands and force them in reg, if required.  */\n+  comparison = vector_compare_rtx (op0, unsignedp, icode);\n   rtx_op1 = expand_normal (op1);\n-  if (!insn_data[icode].operand[1].predicate (rtx_op1, mode)\n-      && mode != VOIDmode)\n-    rtx_op1 = force_reg (mode, rtx_op1);\n-\n   rtx_op2 = expand_normal (op2);\n-  if (!insn_data[icode].operand[2].predicate (rtx_op2, mode)\n-      && mode != VOIDmode)\n-    rtx_op2 = force_reg (mode, rtx_op2);\n-\n-  /* Emit instruction! */\n-  emit_insn (GEN_FCN (icode) (target, rtx_op1, rtx_op2,\n-\t\t\t      comparison, cc_op0,  cc_op1));\n \n-  return target;\n+  create_output_operand (&ops[0], target, mode);\n+  create_input_operand (&ops[1], rtx_op1, mode);\n+  create_input_operand (&ops[2], rtx_op2, mode);\n+  create_fixed_operand (&ops[3], comparison);\n+  create_fixed_operand (&ops[4], XEXP (comparison, 0));\n+  create_fixed_operand (&ops[5], XEXP (comparison, 1));\n+  expand_insn (icode, 6, ops);\n+  return ops[0].value;\n }\n \n \f\n@@ -6820,28 +6510,18 @@ static rtx\n expand_val_compare_and_swap_1 (rtx mem, rtx old_val, rtx new_val,\n \t\t\t       rtx target, enum insn_code icode)\n {\n+  struct expand_operand ops[4];\n   enum machine_mode mode = GET_MODE (mem);\n-  rtx insn;\n \n-  if (!target || !insn_data[icode].operand[0].predicate (target, mode))\n-    target = gen_reg_rtx (mode);\n-\n-  if (GET_MODE (old_val) != VOIDmode && GET_MODE (old_val) != mode)\n-    old_val = convert_modes (mode, GET_MODE (old_val), old_val, 1);\n-  if (!insn_data[icode].operand[2].predicate (old_val, mode))\n-    old_val = force_reg (mode, old_val);\n-\n-  if (GET_MODE (new_val) != VOIDmode && GET_MODE (new_val) != mode)\n-    new_val = convert_modes (mode, GET_MODE (new_val), new_val, 1);\n-  if (!insn_data[icode].operand[3].predicate (new_val, mode))\n-    new_val = force_reg (mode, new_val);\n-\n-  insn = GEN_FCN (icode) (target, mem, old_val, new_val);\n-  if (insn == NULL_RTX)\n-    return NULL_RTX;\n-  emit_insn (insn);\n-\n-  return target;\n+  create_output_operand (&ops[0], target, mode);\n+  create_fixed_operand (&ops[1], mem);\n+  /* OLD_VAL and NEW_VAL may have been promoted to a wider mode.\n+     Shrink them if so.  */\n+  create_convert_operand_to (&ops[2], old_val, mode, true);\n+  create_convert_operand_to (&ops[3], new_val, mode, true);\n+  if (maybe_expand_insn (icode, 4, ops))\n+    return ops[0].value;\n+  return NULL_RTX;\n }\n \n /* Expand a compare-and-swap operation and return its value.  */\n@@ -7046,17 +6726,13 @@ expand_sync_operation (rtx mem, rtx val, enum rtx_code code)\n   /* Generate the direct operation, if present.  */\n   if (icode != CODE_FOR_nothing)\n     {\n-      if (GET_MODE (val) != VOIDmode && GET_MODE (val) != mode)\n-\tval = convert_modes (mode, GET_MODE (val), val, 1);\n-      if (!insn_data[icode].operand[1].predicate (val, mode))\n-\tval = force_reg (mode, val);\n+      struct expand_operand ops[2];\n \n-      insn = GEN_FCN (icode) (mem, val);\n-      if (insn)\n-\t{\n-\t  emit_insn (insn);\n-\t  return const0_rtx;\n-\t}\n+      create_fixed_operand (&ops[0], mem);\n+      /* VAL may have been promoted to a wider mode.  Shrink it if so.  */\n+      create_convert_operand_to (&ops[1], val, mode, true);\n+      if (maybe_expand_insn (icode, 2, ops))\n+\treturn const0_rtx;\n     }\n \n   /* Failing that, generate a compare-and-swap loop in which we perform the\n@@ -7179,19 +6855,16 @@ expand_sync_fetch_operation (rtx mem, rtx val, enum rtx_code code,\n   /* If we found something supported, great.  */\n   if (icode != CODE_FOR_nothing)\n     {\n-      if (!target || !insn_data[icode].operand[0].predicate (target, mode))\n-\ttarget = gen_reg_rtx (mode);\n+      struct expand_operand ops[3];\n \n-      if (GET_MODE (val) != VOIDmode && GET_MODE (val) != mode)\n-\tval = convert_modes (mode, GET_MODE (val), val, 1);\n-      if (!insn_data[icode].operand[2].predicate (val, mode))\n-\tval = force_reg (mode, val);\n-\n-      insn = GEN_FCN (icode) (target, mem, val);\n-      if (insn)\n+      create_output_operand (&ops[0], target, mode);\n+      create_fixed_operand (&ops[1], mem);\n+      /* VAL may have been promoted to a wider mode.  Shrink it if so.  */\n+      create_convert_operand_to (&ops[2], val, mode, true);\n+      if (maybe_expand_insn (icode, 3, ops))\n \t{\n-\t  emit_insn (insn);\n-\n+\t  target = ops[0].value;\n+\t  val = ops[2].value;\n \t  /* If we need to compensate for using an operation with the\n \t     wrong return value, do so now.  */\n \t  if (compensate)\n@@ -7271,26 +6944,19 @@ expand_sync_lock_test_and_set (rtx mem, rtx val, rtx target)\n {\n   enum machine_mode mode = GET_MODE (mem);\n   enum insn_code icode;\n-  rtx insn;\n \n   /* If the target supports the test-and-set directly, great.  */\n   icode = direct_optab_handler (sync_lock_test_and_set_optab, mode);\n   if (icode != CODE_FOR_nothing)\n     {\n-      if (!target || !insn_data[icode].operand[0].predicate (target, mode))\n-\ttarget = gen_reg_rtx (mode);\n-\n-      if (GET_MODE (val) != VOIDmode && GET_MODE (val) != mode)\n-\tval = convert_modes (mode, GET_MODE (val), val, 1);\n-      if (!insn_data[icode].operand[2].predicate (val, mode))\n-\tval = force_reg (mode, val);\n+      struct expand_operand ops[3];\n \n-      insn = GEN_FCN (icode) (target, mem, val);\n-      if (insn)\n-\t{\n-\t  emit_insn (insn);\n-\t  return target;\n-\t}\n+      create_output_operand (&ops[0], target, mode);\n+      create_fixed_operand (&ops[1], mem);\n+      /* VAL may have been promoted to a wider mode.  Shrink it if so.  */\n+      create_convert_operand_to (&ops[2], val, mode, true);\n+      if (maybe_expand_insn (icode, 3, ops))\n+\treturn ops[0].value;\n     }\n \n   /* Otherwise, use a compare-and-swap loop for the exchange.  */\n@@ -7318,5 +6984,201 @@ insn_operand_matches (enum insn_code icode, unsigned int opno, rtx operand)\n \t  || (insn_data[(int) icode].operand[opno].predicate\n \t      (operand, insn_data[(int) icode].operand[opno].mode)));\n }\n+\f\n+/* Try to make OP match operand OPNO of instruction ICODE.  Return true\n+   on success, storing the new operand value back in OP.  */\n+\n+static bool\n+maybe_legitimize_operand (enum insn_code icode, unsigned int opno,\n+\t\t\t  struct expand_operand *op)\n+{\n+  enum machine_mode mode, imode;\n+  bool old_volatile_ok, result;\n+\n+  old_volatile_ok = volatile_ok;\n+  mode = op->mode;\n+  result = false;\n+  switch (op->type)\n+    {\n+    case EXPAND_FIXED:\n+      volatile_ok = true;\n+      break;\n+\n+    case EXPAND_OUTPUT:\n+      gcc_assert (mode != VOIDmode);\n+      if (!op->value\n+\t  || op->value == const0_rtx\n+\t  || GET_MODE (op->value) != mode\n+\t  || !insn_operand_matches (icode, opno, op->value))\n+\top->value = gen_reg_rtx (mode);\n+      break;\n+\n+    case EXPAND_INPUT:\n+    input:\n+      gcc_assert (mode != VOIDmode);\n+      gcc_assert (GET_MODE (op->value) == VOIDmode\n+\t\t  || GET_MODE (op->value) == mode);\n+      result = insn_operand_matches (icode, opno, op->value);\n+      if (!result)\n+\top->value = copy_to_mode_reg (mode, op->value);\n+      break;\n+\n+    case EXPAND_CONVERT_TO:\n+      gcc_assert (mode != VOIDmode);\n+      op->value = convert_to_mode (mode, op->value, op->unsigned_p);\n+      goto input;\n+\n+    case EXPAND_CONVERT_FROM:\n+      if (GET_MODE (op->value) != VOIDmode)\n+\tmode = GET_MODE (op->value);\n+      else\n+\t/* The caller must tell us what mode this value has.  */\n+\tgcc_assert (mode != VOIDmode);\n+\n+      imode = insn_data[(int) icode].operand[opno].mode;\n+      if (imode != VOIDmode && imode != mode)\n+\t{\n+\t  op->value = convert_modes (imode, mode, op->value, op->unsigned_p);\n+\t  mode = imode;\n+\t}\n+      goto input;\n+\n+    case EXPAND_ADDRESS:\n+      gcc_assert (mode != VOIDmode);\n+      op->value = convert_memory_address (mode, op->value);\n+      goto input;\n+\n+    case EXPAND_INTEGER:\n+      mode = insn_data[(int) icode].operand[opno].mode;\n+      if (mode != VOIDmode && const_int_operand (op->value, mode))\n+\tgoto input;\n+      break;\n+    }\n+  if (!result)\n+    result = insn_operand_matches (icode, opno, op->value);\n+  volatile_ok = old_volatile_ok;\n+  return result;\n+}\n+\n+/* Make OP describe an input operand that should have the same value\n+   as VALUE, after any mode conversion that the target might request.\n+   TYPE is the type of VALUE.  */\n+\n+void\n+create_convert_operand_from_type (struct expand_operand *op,\n+\t\t\t\t  rtx value, tree type)\n+{\n+  create_convert_operand_from (op, value, TYPE_MODE (type),\n+\t\t\t       TYPE_UNSIGNED (type));\n+}\n+\n+/* Try to make operands [OPS, OPS + NOPS) match operands [OPNO, OPNO + NOPS)\n+   of instruction ICODE.  Return true on success, leaving the new operand\n+   values in the OPS themselves.  Emit no code on failure.  */\n+\n+bool\n+maybe_legitimize_operands (enum insn_code icode, unsigned int opno,\n+\t\t\t   unsigned int nops, struct expand_operand *ops)\n+{\n+  rtx last;\n+  unsigned int i;\n+\n+  last = get_last_insn ();\n+  for (i = 0; i < nops; i++)\n+    if (!maybe_legitimize_operand (icode, opno + i, &ops[i]))\n+      {\n+\tdelete_insns_since (last);\n+\treturn false;\n+      }\n+  return true;\n+}\n+\n+/* Try to generate instruction ICODE, using operands [OPS, OPS + NOPS)\n+   as its operands.  Return the instruction pattern on success,\n+   and emit any necessary set-up code.  Return null and emit no\n+   code on failure.  */\n+\n+rtx\n+maybe_gen_insn (enum insn_code icode, unsigned int nops,\n+\t\tstruct expand_operand *ops)\n+{\n+  /* n_operands includes any automatically-generated match_scratches,\n+     so we can't check for equality here.  */\n+  gcc_assert (nops <= (unsigned int) insn_data[(int) icode].n_operands);\n+  if (!maybe_legitimize_operands (icode, 0, nops, ops))\n+    return NULL_RTX;\n+\n+  switch (nops)\n+    {\n+    case 1:\n+      return GEN_FCN (icode) (ops[0].value);\n+    case 2:\n+      return GEN_FCN (icode) (ops[0].value, ops[1].value);\n+    case 3:\n+      return GEN_FCN (icode) (ops[0].value, ops[1].value, ops[2].value);\n+    case 4:\n+      return GEN_FCN (icode) (ops[0].value, ops[1].value, ops[2].value,\n+\t\t\t      ops[3].value);\n+    case 5:\n+      return GEN_FCN (icode) (ops[0].value, ops[1].value, ops[2].value,\n+\t\t\t      ops[3].value, ops[4].value);\n+    case 6:\n+      return GEN_FCN (icode) (ops[0].value, ops[1].value, ops[2].value,\n+\t\t\t      ops[3].value, ops[4].value, ops[5].value);\n+    }\n+  gcc_unreachable ();\n+}\n+\n+/* Try to emit instruction ICODE, using operands [OPS, OPS + NOPS)\n+   as its operands.  Return true on success and emit no code on failure.  */\n+\n+bool\n+maybe_expand_insn (enum insn_code icode, unsigned int nops,\n+\t\t   struct expand_operand *ops)\n+{\n+  rtx pat = maybe_gen_insn (icode, nops, ops);\n+  if (pat)\n+    {\n+      emit_insn (pat);\n+      return true;\n+    }\n+  return false;\n+}\n+\n+/* Like maybe_expand_insn, but for jumps.  */\n+\n+bool\n+maybe_expand_jump_insn (enum insn_code icode, unsigned int nops,\n+\t\t\tstruct expand_operand *ops)\n+{\n+  rtx pat = maybe_gen_insn (icode, nops, ops);\n+  if (pat)\n+    {\n+      emit_jump_insn (pat);\n+      return true;\n+    }\n+  return false;\n+}\n+\n+/* Emit instruction ICODE, using operands [OPS, OPS + NOPS)\n+   as its operands.  */\n+\n+void\n+expand_insn (enum insn_code icode, unsigned int nops,\n+\t     struct expand_operand *ops)\n+{\n+  if (!maybe_expand_insn (icode, nops, ops))\n+    gcc_unreachable ();\n+}\n+\n+/* Like expand_insn, but for jumps.  */\n+\n+void\n+expand_jump_insn (enum insn_code icode, unsigned int nops,\n+\t\t  struct expand_operand *ops)\n+{\n+  if (!maybe_expand_jump_insn (icode, nops, ops))\n+    gcc_unreachable ();\n+}\n \n #include \"gt-optabs.h\""}, {"sha": "be61f549fd4ae6461d0b2b6b0d34c29b93369066", "filename": "gcc/optabs.h", "status": "modified", "additions": 144, "deletions": 2, "changes": 146, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a5c7d693b920b650fb863e4b9a41b01c199f698f/gcc%2Foptabs.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a5c7d693b920b650fb863e4b9a41b01c199f698f/gcc%2Foptabs.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Foptabs.h?ref=a5c7d693b920b650fb863e4b9a41b01c199f698f", "patch": "@@ -791,8 +791,8 @@ extern rtx expand_copysign (rtx, rtx, rtx);\n \n /* Generate an instruction with a given INSN_CODE with an output and\n    an input.  */\n-extern void emit_unop_insn (int, rtx, rtx, enum rtx_code);\n-extern bool maybe_emit_unop_insn (int, rtx, rtx, enum rtx_code);\n+extern void emit_unop_insn (enum insn_code, rtx, rtx, enum rtx_code);\n+extern bool maybe_emit_unop_insn (enum insn_code, rtx, rtx, enum rtx_code);\n \n /* An extra flag to control optab_for_tree_code's behavior.  This is needed to\n    distinguish between machines with a vector shift that takes a scalar for the\n@@ -926,6 +926,148 @@ extern rtx convert_optab_libfunc (convert_optab optab, enum machine_mode mode1,\n \n extern bool insn_operand_matches (enum insn_code icode, unsigned int opno,\n \t\t\t\t  rtx operand);\n+\n+/* Describes the type of an expand_operand.  Each value is associated\n+   with a create_*_operand function; see the comments above those\n+   functions for details.  */\n+enum expand_operand_type {\n+  EXPAND_FIXED,\n+  EXPAND_OUTPUT,\n+  EXPAND_INPUT,\n+  EXPAND_CONVERT_TO,\n+  EXPAND_CONVERT_FROM,\n+  EXPAND_ADDRESS,\n+  EXPAND_INTEGER\n+};\n+\n+/* Information about an operand for instruction expansion.  */\n+struct expand_operand {\n+  /* The type of operand.  */\n+  ENUM_BITFIELD (expand_operand_type) type : 8;\n+\n+  /* True if any conversion should treat VALUE as being unsigned\n+     rather than signed.  Only meaningful for certain types.  */\n+  unsigned int unsigned_p : 1;\n+\n+  /* Unused; available for future use.  */\n+  unsigned int unused : 7;\n+\n+  /* The mode passed to the convert_*_operand function.  It has a\n+     type-dependent meaning.  */\n+  ENUM_BITFIELD (machine_mode) mode : 16;\n+\n+  /* The value of the operand.  */\n+  rtx value;\n+};\n+\n+/* Initialize OP with the given fields.  Initialise the other fields\n+   to their default values.  */\n+\n+static inline void\n+create_expand_operand (struct expand_operand *op,\n+\t\t       enum expand_operand_type type,\n+\t\t       rtx value, enum machine_mode mode,\n+\t\t       bool unsigned_p)\n+{\n+  op->type = type;\n+  op->unsigned_p = unsigned_p;\n+  op->unused = 0;\n+  op->mode = mode;\n+  op->value = value;\n+}\n+\n+/* Make OP describe an operand that must use rtx X, even if X is volatile.  */\n+\n+static inline void\n+create_fixed_operand (struct expand_operand *op, rtx x)\n+{\n+  create_expand_operand (op, EXPAND_FIXED, x, VOIDmode, false);\n+}\n+\n+/* Make OP describe an output operand that must have mode MODE.\n+   X, if nonnull, is a suggestion for where the output should be stored.\n+   It is OK for VALUE to be inconsistent with MODE, although it will just\n+   be ignored in that case.  */\n+\n+static inline void\n+create_output_operand (struct expand_operand *op, rtx x,\n+\t\t       enum machine_mode mode)\n+{\n+  create_expand_operand (op, EXPAND_OUTPUT, x, mode, false);\n+}\n+\n+/* Make OP describe an input operand that must have mode MODE and\n+   value VALUE; MODE cannot be VOIDmode.  The backend may request that\n+   VALUE be copied into a different kind of rtx before being passed\n+   as an operand.  */\n+\n+static inline void\n+create_input_operand (struct expand_operand *op, rtx value,\n+\t\t      enum machine_mode mode)\n+{\n+  create_expand_operand (op, EXPAND_INPUT, value, mode, false);\n+}\n+\n+/* Like create_input_operand, except that VALUE must first be converted\n+   to mode MODE.  UNSIGNED_P says whether VALUE is unsigned.  */\n+\n+static inline void\n+create_convert_operand_to (struct expand_operand *op, rtx value,\n+\t\t\t   enum machine_mode mode, bool unsigned_p)\n+{\n+  create_expand_operand (op, EXPAND_CONVERT_TO, value, mode, unsigned_p);\n+}\n+\n+/* Make OP describe an input operand that should have the same value\n+   as VALUE, after any mode conversion that the backend might request.\n+   If VALUE is a CONST_INT, it should be treated as having mode MODE.\n+   UNSIGNED_P says whether VALUE is unsigned.  */\n+\n+static inline void\n+create_convert_operand_from (struct expand_operand *op, rtx value,\n+\t\t\t     enum machine_mode mode, bool unsigned_p)\n+{\n+  create_expand_operand (op, EXPAND_CONVERT_FROM, value, mode, unsigned_p);\n+}\n+\n+extern void create_convert_operand_from_type (struct expand_operand *op,\n+\t\t\t\t\t      rtx value, tree type);\n+\n+/* Make OP describe an input Pmode address operand.  VALUE is the value\n+   of the address, but it may need to be converted to Pmode first.  */\n+\n+static inline void\n+create_address_operand (struct expand_operand *op, rtx value)\n+{\n+  create_expand_operand (op, EXPAND_ADDRESS, value, Pmode, false);\n+}\n+\n+/* Make OP describe an input operand that has value INTVAL and that has\n+   no inherent mode.  This function should only be used for operands that\n+   are always expand-time constants.  The backend may request that INTVAL\n+   be copied into a different kind of rtx, but it must specify the mode\n+   of that rtx if so.  */\n+\n+static inline void\n+create_integer_operand (struct expand_operand *op, HOST_WIDE_INT intval)\n+{\n+  create_expand_operand (op, EXPAND_INTEGER, GEN_INT (intval), VOIDmode, false);\n+}\n+\n+extern bool maybe_legitimize_operands (enum insn_code icode,\n+\t\t\t\t       unsigned int opno, unsigned int nops,\n+\t\t\t\t       struct expand_operand *ops);\n+extern rtx maybe_gen_insn (enum insn_code icode, unsigned int nops,\n+\t\t\t   struct expand_operand *ops);\n+extern bool maybe_expand_insn (enum insn_code icode, unsigned int nops,\n+\t\t\t       struct expand_operand *ops);\n+extern bool maybe_expand_jump_insn (enum insn_code icode, unsigned int nops,\n+\t\t\t\t    struct expand_operand *ops);\n+extern void expand_insn (enum insn_code icode, unsigned int nops,\n+\t\t\t struct expand_operand *ops);\n+extern void expand_jump_insn (enum insn_code icode, unsigned int nops,\n+\t\t\t      struct expand_operand *ops);\n+\n extern rtx prepare_operand (enum insn_code, rtx, int, enum machine_mode,\n \t\t\t    enum machine_mode, int);\n "}]}