{"sha": "f3e9a059a74680325960aa3e6ebc629773c9e1f8", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjNlOWEwNTlhNzQ2ODAzMjU5NjBhYTNlNmViYzYyOTc3M2M5ZTFmOA==", "commit": {"author": {"name": "Nathan Sidwell", "email": "nathan@codesourcery.com", "date": "2015-07-20T16:17:57Z"}, "committer": {"name": "Nathan Sidwell", "email": "nathan@gcc.gnu.org", "date": "2015-07-20T16:17:57Z"}, "message": "plugin-nvptx.c (struct targ_fn_descriptor): Move later.\n\n\t* plugin/plugin-nvptx.c (struct targ_fn_descriptor): Move later.\n\t(struct ptx_image_data): Move earlier, add fns field.\n\t(struct ptx_device): Add images and image_lock fields.\n\t(ptx_images, ptx_image_lock): Delete.\n\t(nvptx_open_device): Initialize images and image_lock fields.\n\t(nvptx_close_device): Destroy image_lock.\n\t(GOMP_OFFLOAD_load_image): Register image to device-specific fields.\n\t(GOMP_OFFLOAD_unload_image): Unregister image from device-specific\n\tfields.\n\nFrom-SVN: r226004", "tree": {"sha": "d943e685a9d726c7ca9ffc74b7209156415e10fc", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d943e685a9d726c7ca9ffc74b7209156415e10fc"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f3e9a059a74680325960aa3e6ebc629773c9e1f8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f3e9a059a74680325960aa3e6ebc629773c9e1f8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f3e9a059a74680325960aa3e6ebc629773c9e1f8", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f3e9a059a74680325960aa3e6ebc629773c9e1f8/comments", "author": null, "committer": null, "parents": [{"sha": "dd5bc4becd7763fe34c80c944dd1597f02bbcd62", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dd5bc4becd7763fe34c80c944dd1597f02bbcd62", "html_url": "https://github.com/Rust-GCC/gccrs/commit/dd5bc4becd7763fe34c80c944dd1597f02bbcd62"}], "stats": {"total": 157, "additions": 89, "deletions": 68}, "files": [{"sha": "6c7b9421320881918b293087c66273232cbb3bb1", "filename": "libgomp/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f3e9a059a74680325960aa3e6ebc629773c9e1f8/libgomp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f3e9a059a74680325960aa3e6ebc629773c9e1f8/libgomp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2FChangeLog?ref=f3e9a059a74680325960aa3e6ebc629773c9e1f8", "patch": "@@ -1,3 +1,15 @@\n+2015-07-20  Nathan Sidwell  <nathan@codesourcery.com>\n+\n+\t* plugin/plugin-nvptx.c (struct targ_fn_descriptor): Move later.\n+\t(struct ptx_image_data): Move earlier, add fns field.\n+\t(struct ptx_device): Add images and image_lock fields.\n+\t(ptx_images, ptx_image_lock): Delete.\n+\t(nvptx_open_device): Initialize images and image_lock fields.\n+\t(nvptx_close_device): Destroy image_lock.\n+\t(GOMP_OFFLOAD_load_image): Register image to device-specific fields.\n+\t(GOMP_OFFLOAD_unload_image): Unregister image from device-specific\n+\tfields.\n+\n 2015-07-17  Nathan Sidwell  <nathan@codesourcery.com>\n \n \t* target.c (GOMP_offload_register): Use int for device type arg."}, {"sha": "fc296321812f76add1cdf1db9bb2f56e34066487", "filename": "libgomp/plugin/plugin-nvptx.c", "status": "modified", "additions": 77, "deletions": 68, "changes": 145, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f3e9a059a74680325960aa3e6ebc629773c9e1f8/libgomp%2Fplugin%2Fplugin-nvptx.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f3e9a059a74680325960aa3e6ebc629773c9e1f8/libgomp%2Fplugin%2Fplugin-nvptx.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Fplugin%2Fplugin-nvptx.c?ref=f3e9a059a74680325960aa3e6ebc629773c9e1f8", "patch": "@@ -127,12 +127,6 @@ cuda_error (CUresult r)\n   return &errmsg[0];\n }\n \n-struct targ_fn_descriptor\n-{\n-  CUfunction fn;\n-  const char *name;\n-};\n-\n static unsigned int instantiated_devices = 0;\n static pthread_mutex_t ptx_dev_lock = PTHREAD_MUTEX_INITIALIZER;\n \n@@ -288,6 +282,25 @@ map_push (struct ptx_stream *s, int async, size_t size, void **h, void **d)\n   return;\n }\n \n+/* Descriptor of a loaded function.  */\n+\n+struct targ_fn_descriptor\n+{\n+  CUfunction fn;\n+  const char *name;\n+};\n+\n+/* A loaded PTX image.  */\n+struct ptx_image_data\n+{\n+  const void *target_data;\n+  CUmodule module;\n+\n+  struct targ_fn_descriptor *fns;  /* Array of functions.  */\n+  \n+  struct ptx_image_data *next;\n+};\n+\n struct ptx_device\n {\n   CUcontext ctx;\n@@ -311,6 +324,9 @@ struct ptx_device\n   int  mode;\n   bool mkern;\n \n+  struct ptx_image_data *images;  /* Images loaded on device.  */\n+  pthread_mutex_t image_lock;     /* Lock for above list.  */\n+  \n   struct ptx_device *next;\n };\n \n@@ -332,21 +348,11 @@ struct ptx_event\n   struct ptx_event *next;\n };\n \n-struct ptx_image_data\n-{\n-  const void *target_data;\n-  CUmodule module;\n-  struct ptx_image_data *next;\n-};\n-\n static pthread_mutex_t ptx_event_lock;\n static struct ptx_event *ptx_events;\n \n static struct ptx_device **ptx_devices;\n \n-static struct ptx_image_data *ptx_images = NULL;\n-static pthread_mutex_t ptx_image_lock = PTHREAD_MUTEX_INITIALIZER;\n-\n #define _XSTR(s) _STR(s)\n #define _STR(s) #s\n \n@@ -590,6 +596,7 @@ select_stream_for_async (int async, pthread_t thread, bool create,\n \n /* Initialize the device.  Return TRUE on success, else FALSE.  PTX_DEV_LOCK\n    should be locked on entry and remains locked on exit.  */\n+\n static bool\n nvptx_init (void)\n {\n@@ -746,6 +753,9 @@ nvptx_open_device (int n)\n   if (r != CUDA_SUCCESS)\n     async_engines = 1;\n \n+  ptx_dev->images = NULL;\n+  pthread_mutex_init (&ptx_dev->image_lock, NULL);\n+\n   init_streams_for_device (ptx_dev, async_engines);\n \n   return ptx_dev;\n@@ -760,6 +770,8 @@ nvptx_close_device (struct ptx_device *ptx_dev)\n     return;\n \n   fini_streams_for_device (ptx_dev);\n+  \n+  pthread_mutex_destroy (&ptx_dev->image_lock);\n \n   if (!ptx_dev->ctx_shared)\n     {\n@@ -1632,6 +1644,9 @@ typedef struct nvptx_tdata\n   size_t fn_num;\n } nvptx_tdata_t;\n \n+/* Load the (partial) program described by TARGET_DATA to device\n+   number ORD.  Allocate and return TARGET_TABLE.  */\n+\n int\n GOMP_OFFLOAD_load_image (int ord, const void *target_data,\n \t\t\t struct addr_pair **target_table)\n@@ -1641,23 +1656,19 @@ GOMP_OFFLOAD_load_image (int ord, const void *target_data,\n   unsigned int fn_entries, var_entries, i, j;\n   CUresult r;\n   struct targ_fn_descriptor *targ_fns;\n+  struct addr_pair *targ_tbl;\n   const nvptx_tdata_t *img_header = (const nvptx_tdata_t *) target_data;\n   struct ptx_image_data *new_image;\n+  struct ptx_device *dev;\n \n   GOMP_OFFLOAD_init_device (ord);\n \n+  dev = ptx_devices[ord];\n+  \n   nvptx_attach_host_thread_to_device (ord);\n \n   link_ptx (&module, img_header->ptx_src);\n \n-  pthread_mutex_lock (&ptx_image_lock);\n-  new_image = GOMP_PLUGIN_malloc (sizeof (struct ptx_image_data));\n-  new_image->target_data = target_data;\n-  new_image->module = module;\n-  new_image->next = ptx_images;\n-  ptx_images = new_image;\n-  pthread_mutex_unlock (&ptx_image_lock);\n-\n   /* The mkoffload utility emits a struct of pointers/integers at the\n      start of each offload image.  The array of kernel names and the\n      functions addresses form a one-to-one correspondence.  */\n@@ -1667,27 +1678,39 @@ GOMP_OFFLOAD_load_image (int ord, const void *target_data,\n   fn_entries = img_header->fn_num;\n   fn_names = img_header->fn_names;\n \n-  *target_table = GOMP_PLUGIN_malloc (sizeof (struct addr_pair)\n-\t\t\t\t      * (fn_entries + var_entries));\n+  targ_tbl = GOMP_PLUGIN_malloc (sizeof (struct addr_pair)\n+\t\t\t\t * (fn_entries + var_entries));\n   targ_fns = GOMP_PLUGIN_malloc (sizeof (struct targ_fn_descriptor)\n \t\t\t\t * fn_entries);\n \n-  for (i = 0; i < fn_entries; i++)\n+  *target_table = targ_tbl;\n+\n+  new_image = GOMP_PLUGIN_malloc (sizeof (struct ptx_image_data));\n+  new_image->target_data = target_data;\n+  new_image->module = module;\n+  new_image->fns = targ_fns;\n+\n+  pthread_mutex_lock (&dev->image_lock);\n+  new_image->next = dev->images;\n+  dev->images = new_image;\n+  pthread_mutex_unlock (&dev->image_lock);\n+\n+  for (i = 0; i < fn_entries; i++, targ_fns++, targ_tbl++)\n     {\n       CUfunction function;\n \n       r = cuModuleGetFunction (&function, module, fn_names[i]);\n       if (r != CUDA_SUCCESS)\n \tGOMP_PLUGIN_fatal (\"cuModuleGetFunction error: %s\", cuda_error (r));\n \n-      targ_fns[i].fn = function;\n-      targ_fns[i].name = (const char *) fn_names[i];\n+      targ_fns->fn = function;\n+      targ_fns->name = (const char *) fn_names[i];\n \n-      (*target_table)[i].start = (uintptr_t) &targ_fns[i];\n-      (*target_table)[i].end = (*target_table)[i].start + 1;\n+      targ_tbl->start = (uintptr_t) targ_fns;\n+      targ_tbl->end = targ_tbl->start + 1;\n     }\n \n-  for (j = 0; j < var_entries; j++, i++)\n+  for (j = 0; j < var_entries; j++, targ_tbl++)\n     {\n       CUdeviceptr var;\n       size_t bytes;\n@@ -1696,47 +1719,33 @@ GOMP_OFFLOAD_load_image (int ord, const void *target_data,\n       if (r != CUDA_SUCCESS)\n         GOMP_PLUGIN_fatal (\"cuModuleGetGlobal error: %s\", cuda_error (r));\n \n-      (*target_table)[i].start = (uintptr_t) var;\n-      (*target_table)[i].end = (*target_table)[i].start + bytes;\n+      targ_tbl->start = (uintptr_t) var;\n+      targ_tbl->end = targ_tbl->start + bytes;\n     }\n \n-  return i;\n+  return fn_entries + var_entries;\n }\n \n-void\n-GOMP_OFFLOAD_unload_image (int tid __attribute__((unused)),\n-\t\t\t   const void *target_data)\n-{\n-  const void *const *img_header = (const void *const *) target_data;\n-  struct targ_fn_descriptor *targ_fns\n-    = (struct targ_fn_descriptor *) img_header[0];\n-  struct ptx_image_data *image, *prev = NULL, *newhd = NULL;\n-\n-  free (targ_fns);\n-\n-  pthread_mutex_lock (&ptx_image_lock);\n-  for (image = ptx_images; image != NULL;)\n-    {\n-      struct ptx_image_data *next = image->next;\n-\n-      if (image->target_data == target_data)\n-\t{\n-\t  cuModuleUnload (image->module);\n-\t  free (image);\n-\t  if (prev)\n-\t    prev->next = next;\n-\t}\n-      else\n-\t{\n-\t  prev = image;\n-\t  if (!newhd)\n-\t    newhd = image;\n-\t}\n+/* Unload the program described by TARGET_DATA.  DEV_DATA is the\n+   function descriptors allocated by G_O_load_image.  */\n \n-      image = next;\n-    }\n-  ptx_images = newhd;\n-  pthread_mutex_unlock (&ptx_image_lock);\n+void\n+GOMP_OFFLOAD_unload_image (int ord, const void *target_data)\n+{\n+  struct ptx_image_data *image, **prev_p;\n+  struct ptx_device *dev = ptx_devices[ord];\n+\n+  pthread_mutex_lock (&dev->image_lock);\n+  for (prev_p = &dev->images; (image = *prev_p) != 0; prev_p = &image->next)\n+    if (image->target_data == target_data)\n+      {\n+\t*prev_p = image->next;\n+\tcuModuleUnload (image->module);\n+\tfree (image->fns);\n+\tfree (image);\n+\tbreak;\n+      }\n+  pthread_mutex_unlock (&dev->image_lock);\n }\n \n void *"}]}