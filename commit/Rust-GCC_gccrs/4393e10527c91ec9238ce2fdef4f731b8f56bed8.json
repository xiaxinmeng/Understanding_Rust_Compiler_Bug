{"sha": "4393e10527c91ec9238ce2fdef4f731b8f56bed8", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDM5M2UxMDUyN2M5MWVjOTIzOGNlMmZkZWY0ZjczMWI4ZjU2YmVkOA==", "commit": {"author": {"name": "Mark Mitchell", "email": "mark@markmitchell.com", "date": "1999-02-16T11:32:51Z"}, "committer": {"name": "Mark Mitchell", "email": "mmitchel@gcc.gnu.org", "date": "1999-02-16T11:32:51Z"}, "message": "cp-tree.h (tsubst): Change prototype.\n\n\t* cp-tree.h (tsubst): Change prototype.\n\t(tsubst_expr): Likewise.\n\t(tsubst_copy): Likewise.\n\t(type_unification): Remove prototype.\n\t* call.c (convert_default_arg): Adjust call to tsubst_expr.\n\t* class.c (resolve_address_of_overloaded_function): Just use\n\tfn_type_unification.\n\t* decl.c (grokdeclarator): Adjust call to tsubst.\n\t* method.c (build_template_parm_names): Likewise.\n\t* pt.c (GTB_VIA_VIRTUAL): New macro.\n\t(GTB_IGNORE_TYPE): Likewise.\n\t(resolve_overloaded_unification): Add `complain' parameter.\n\t(try_one_overload): Likewise.\n\t(tsubst_template_arg_vector): Likewise.\n\t(tsubst_template_parms): Likewise.\n\t(tsubst_aggr_type): Likewise.\n\t(tsubst_arg_types): Likewise.\n\t(tsubst_call_declarator_parms): Likewise.\n\t(unify): Remove explicit_mask.\n\t(type_unification_real): Likewise.\n\t(get_template_base_recursive): Likewise.\n\t(coerce_template_template_parms): Provide prototype.\n\t(tsubst_function_type): Likewise.\n\t(try_class_unification): New function.\n\tAll callers changed to use new complain parameter.\n\t(get_template_base): Use try_class_unification.\n\t(unify): Adjust handling of classes derived from template types.\n\t(fn_type_unification): Substitute explicit arguments before\n\tunification.\n\nFrom-SVN: r25243", "tree": {"sha": "bc0020fd59d920a002297e4d2c3f25a2f54ef4e3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/bc0020fd59d920a002297e4d2c3f25a2f54ef4e3"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/4393e10527c91ec9238ce2fdef4f731b8f56bed8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4393e10527c91ec9238ce2fdef4f731b8f56bed8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4393e10527c91ec9238ce2fdef4f731b8f56bed8", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4393e10527c91ec9238ce2fdef4f731b8f56bed8/comments", "author": null, "committer": null, "parents": [{"sha": "0c20d3d607573ae0f71bf1289f9ba1fd69225981", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0c20d3d607573ae0f71bf1289f9ba1fd69225981", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0c20d3d607573ae0f71bf1289f9ba1fd69225981"}], "stats": {"total": 1520, "additions": 951, "deletions": 569}, "files": [{"sha": "a0a3a8fab5e28d55df0cb84cdb9306ba8a37d31d", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4393e10527c91ec9238ce2fdef4f731b8f56bed8/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4393e10527c91ec9238ce2fdef4f731b8f56bed8/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=4393e10527c91ec9238ce2fdef4f731b8f56bed8", "patch": "@@ -1,3 +1,35 @@\n+1999-02-16  Mark Mitchell  <mark@markmitchell.com>\n+\n+\t* cp-tree.h (tsubst): Change prototype.\n+\t(tsubst_expr): Likewise.\n+\t(tsubst_copy): Likewise.\n+\t(type_unification): Remove prototype.\n+\t* call.c (convert_default_arg): Adjust call to tsubst_expr.\n+\t* class.c (resolve_address_of_overloaded_function): Just use\n+\tfn_type_unification. \n+\t* decl.c (grokdeclarator): Adjust call to tsubst.\n+\t* method.c (build_template_parm_names): Likewise.\n+\t* pt.c (GTB_VIA_VIRTUAL): New macro.\n+\t(GTB_IGNORE_TYPE): Likewise.\n+\t(resolve_overloaded_unification): Add `complain' parameter.\n+\t(try_one_overload): Likewise.\n+\t(tsubst_template_arg_vector): Likewise.\n+\t(tsubst_template_parms): Likewise.\n+\t(tsubst_aggr_type): Likewise.\n+\t(tsubst_arg_types): Likewise.\n+\t(tsubst_call_declarator_parms): Likewise.\n+\t(unify): Remove explicit_mask.\n+\t(type_unification_real): Likewise.\n+\t(get_template_base_recursive): Likewise.\n+\t(coerce_template_template_parms): Provide prototype.\n+\t(tsubst_function_type): Likewise.\n+\t(try_class_unification): New function.\n+\tAll callers changed to use new complain parameter.\n+\t(get_template_base): Use try_class_unification.\n+\t(unify): Adjust handling of classes derived from template types.\n+\t(fn_type_unification): Substitute explicit arguments before\n+\tunification.\n+\t\n 1999-02-16  Kriang Lerdsuwanakij <lerdsuwa@scf-fs.usc.edu>\n \n \t* decl.c (pushdecl): Remove dead code."}, {"sha": "83e1d6997eb972d36d23eb059539538062b8f143", "filename": "gcc/cp/call.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4393e10527c91ec9238ce2fdef4f731b8f56bed8/gcc%2Fcp%2Fcall.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4393e10527c91ec9238ce2fdef4f731b8f56bed8/gcc%2Fcp%2Fcall.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcall.c?ref=4393e10527c91ec9238ce2fdef4f731b8f56bed8", "patch": "@@ -3205,7 +3205,7 @@ convert_default_arg (type, arg, fn)\n       if (DECL_CLASS_SCOPE_P (fn))\n \tpushclass (DECL_REAL_CONTEXT (fn), 2);\n \n-      arg = tsubst_expr (arg, DECL_TI_ARGS (fn), NULL_TREE);\n+      arg = tsubst_expr (arg, DECL_TI_ARGS (fn), /*complain=*/1, NULL_TREE);\n \n       if (DECL_CLASS_SCOPE_P (fn))\n \tpopclass (1);"}, {"sha": "afcc89a342629d69d0362e7796f81af0a81aa0db", "filename": "gcc/cp/class.c", "status": "modified", "additions": 9, "deletions": 25, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4393e10527c91ec9238ce2fdef4f731b8f56bed8/gcc%2Fcp%2Fclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4393e10527c91ec9238ce2fdef4f731b8f56bed8/gcc%2Fcp%2Fclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fclass.c?ref=4393e10527c91ec9238ce2fdef4f731b8f56bed8", "patch": "@@ -5106,17 +5106,12 @@ resolve_address_of_overloaded_function (target_type,\n       tree fns;\n \n       if (is_ptrmem)\n-\t{\n-\t  target_fn_type\n-\t    = TREE_TYPE (TYPE_PTRMEMFUNC_FN_TYPE (target_type));\n-\t  target_arg_types = TREE_CHAIN (TYPE_ARG_TYPES (target_fn_type));\n-\t}\n+\ttarget_fn_type\n+\t  = TREE_TYPE (TYPE_PTRMEMFUNC_FN_TYPE (target_type));\n       else\n-\t{\n-\t  target_fn_type = TREE_TYPE (target_type);\n-\t  target_arg_types = TYPE_ARG_TYPES (target_fn_type);\n-\t}\n-\n+\ttarget_fn_type = TREE_TYPE (target_type);\n+      target_arg_types = TYPE_ARG_TYPES (target_fn_type);\n+\t  \n       for (fns = overload; fns; fns = OVL_CHAIN (fns))\n \t{\n \t  tree fn = OVL_FUNCTION (fns);\n@@ -5131,26 +5126,15 @@ resolve_address_of_overloaded_function (target_type,\n \n \t  if ((TREE_CODE (TREE_TYPE (fn)) == METHOD_TYPE)\n \t      != is_ptrmem)\n-\t    /* We're looking for a non-static member, and this isn't\n+\t    /* We're not looking for a non-static member, and this is\n \t       one, or vice versa.  */\n \t    continue;\n \n-\t  /* We don't use the `this' argument to do argument deduction\n-\t     since that would prevent us from converting a base class\n-\t     pointer-to-member to a derived class pointer-to-member.  */\n-\t  fn_arg_types = TYPE_ARG_TYPES (TREE_TYPE (fn));\n-\t  if (is_ptrmem)\n-\t    fn_arg_types = TREE_CHAIN (fn_arg_types);\n-\n \t  /* Try to do argument deduction.  */\n \t  targs = make_scratch_vec (DECL_NTPARMS (fn));\n-\t  if (type_unification (DECL_INNERMOST_TEMPLATE_PARMS (fn),\n-\t\t\t\ttargs,\n-\t\t\t\tfn_arg_types,\n-\t\t\t\ttarget_arg_types,\n-\t\t\t\texplicit_targs,\n-\t\t\t\tDEDUCE_EXACT,\n-\t\t\t\t/*allow_incomplete=*/1) != 0)\n+\t  if (fn_type_unification (fn, explicit_targs, targs,\n+\t\t\t\t   target_arg_types, NULL_TREE,\n+\t\t\t\t   DEDUCE_EXACT, NULL_TREE) != 0)\n \t    /* Argument deduction failed.  */\n \t    continue;\n "}, {"sha": "bbb0adffffbe60c67ee714eade6640a8ae24aa15", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4393e10527c91ec9238ce2fdef4f731b8f56bed8/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4393e10527c91ec9238ce2fdef4f731b8f56bed8/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=4393e10527c91ec9238ce2fdef4f731b8f56bed8", "patch": "@@ -3041,9 +3041,9 @@ extern tree get_id_2\t\t\t\tPROTO((char *, tree));\n /* in pt.c */\n extern void check_template_shadow\t\tPROTO ((tree));\n extern tree innermost_args\t\t\tPROTO ((tree));\n-extern tree tsubst\t\t\t\tPROTO ((tree, tree, tree));\n-extern tree tsubst_expr\t\t\t\tPROTO ((tree, tree, tree));\n-extern tree tsubst_copy\t\t\t\tPROTO ((tree, tree, tree));\n+extern tree tsubst\t\t\t\tPROTO ((tree, tree, int, tree));\n+extern tree tsubst_expr\t\t\t\tPROTO ((tree, tree, int, tree));\n+extern tree tsubst_copy\t\t\t\tPROTO ((tree, tree, int, tree));\n extern void maybe_begin_member_template_processing PROTO((tree));\n extern void maybe_end_member_template_processing PROTO((void));\n extern tree finish_member_template_decl         PROTO((tree));\n@@ -3069,7 +3069,6 @@ extern tree instantiate_class_template\t\tPROTO((tree));\n extern tree instantiate_template\t\tPROTO((tree, tree));\n extern void overload_template_name\t\tPROTO((tree));\n extern int fn_type_unification                  PROTO((tree, tree, tree, tree, tree, unification_kind_t, tree));\n-extern int type_unification\t\t\tPROTO((tree, tree, tree, tree, tree, unification_kind_t, int));\n struct tinst_level *tinst_for_decl\t\tPROTO((void));\n extern void mark_decl_instantiated\t\tPROTO((tree, int));\n extern int more_specialized\t\t\tPROTO((tree, tree, tree));"}, {"sha": "3b6917cc1d909c2069f8e7341a64cc4026e1913e", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4393e10527c91ec9238ce2fdef4f731b8f56bed8/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4393e10527c91ec9238ce2fdef4f731b8f56bed8/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=4393e10527c91ec9238ce2fdef4f731b8f56bed8", "patch": "@@ -10397,7 +10397,7 @@ grokdeclarator (declarator, declspecs, decl_context, initialized, attrlist)\n \t\t    && uses_template_parms (current_class_type))\n \t\t  {\n \t\t    tree args = current_template_args ();\n-\t\t    type = tsubst (type, args, NULL_TREE);\n+\t\t    type = tsubst (type, args, /*complain=*/1, NULL_TREE);\n \t\t  }\n \n \t\t/* This pop_nested_class corresponds to the"}, {"sha": "abd37081adcf1ba812f68a7a481475cab5fd3a63", "filename": "gcc/cp/method.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4393e10527c91ec9238ce2fdef4f731b8f56bed8/gcc%2Fcp%2Fmethod.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4393e10527c91ec9238ce2fdef4f731b8f56bed8/gcc%2Fcp%2Fmethod.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fmethod.c?ref=4393e10527c91ec9238ce2fdef4f731b8f56bed8", "patch": "@@ -938,7 +938,7 @@ build_template_parm_names (parmlist, arglist)\n \t}\n       else\n \t{\n-\t  parm = tsubst (parm, arglist, NULL_TREE);\n+\t  parm = tsubst (parm, arglist, /*complain=*/1, NULL_TREE);\n \t  /* It's a PARM_DECL.  */\n \t  build_mangled_name_for_type (TREE_TYPE (parm));\n \t  build_overload_value (TREE_TYPE (parm), arg, "}, {"sha": "a951a8bb8e7210063d3cce088513867676d79e3a", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 835, "deletions": 534, "changes": 1369, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4393e10527c91ec9238ce2fdef4f731b8f56bed8/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4393e10527c91ec9238ce2fdef4f731b8f56bed8/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=4393e10527c91ec9238ce2fdef4f731b8f56bed8", "patch": "@@ -77,12 +77,17 @@ static tree saved_trees;\n #define UNIFY_ALLOW_DERIVED 4\n #define UNIFY_ALLOW_INTEGER 8\n \n+#define GTB_VIA_VIRTUAL 1 /* The base class we are examining is\n+\t\t\t     virtual, or a base class of a virtual\n+\t\t\t     base.  */\n+#define GTB_IGNORE_TYPE 2 /* We don't need to try to unify the current\n+\t\t\t     type with the desired type.  */\n+\n static int resolve_overloaded_unification PROTO((tree, tree, tree, tree,\n-\t\t\t\t\t\t unification_kind_t, int,\n-\t\t\t\t\t\t int*));\n+\t\t\t\t\t\t unification_kind_t, int));\n static int try_one_overload PROTO((tree, tree, tree, tree, tree,\n-\t\t\t\t   unification_kind_t, int, int*));\n-static int unify PROTO((tree, tree, tree, tree, int, int*));\n+\t\t\t\t   unification_kind_t, int));\n+static int unify PROTO((tree, tree, tree, tree, int));\n static void add_pending_template PROTO((tree));\n static int push_tinst_level PROTO((tree));\n static tree classtype_mangled_name PROTO((tree));\n@@ -97,7 +102,7 @@ static tree add_outermost_template_args PROTO((tree, tree));\n static void maybe_adjust_types_for_deduction PROTO((unification_kind_t, tree*,\n \t\t\t\t\t\t    tree*)); \n static int  type_unification_real PROTO((tree, tree, tree, tree,\n-\t\t\t\t\t int, unification_kind_t, int, int*));\n+\t\t\t\t\t int, unification_kind_t, int));\n static void note_template_header PROTO((int));\n static tree maybe_fold_nontype_arg PROTO((tree));\n static tree convert_nontype_argument PROTO((tree, tree));\n@@ -120,25 +125,29 @@ static tree get_bindings_real PROTO((tree, tree, tree, int));\n static int template_decl_level PROTO((tree));\n static tree maybe_get_template_decl_from_type_decl PROTO((tree));\n static int check_cv_quals_for_unify PROTO((int, tree, tree));\n-static tree tsubst_template_arg_vector PROTO((tree, tree));\n-static tree tsubst_template_parms PROTO((tree, tree));\n+static tree tsubst_template_arg_vector PROTO((tree, tree, int));\n+static tree tsubst_template_parms PROTO((tree, tree, int));\n static void regenerate_decl_from_template PROTO((tree, tree));\n static tree most_specialized PROTO((tree, tree, tree));\n static tree most_specialized_class PROTO((tree, tree));\n static tree most_general_template PROTO((tree));\n static void set_mangled_name_for_template_decl PROTO((tree));\n static int template_class_depth_real PROTO((tree, int));\n-static tree tsubst_aggr_type PROTO((tree, tree, tree, int));\n+static tree tsubst_aggr_type PROTO((tree, tree, int, tree, int));\n static tree tsubst_decl PROTO((tree, tree, tree, tree));\n-static tree tsubst_arg_types PROTO((tree, tree, tree));\n+static tree tsubst_arg_types PROTO((tree, tree, int, tree));\n+static tree tsubst_function_type PROTO((tree, tree, int, tree));\n static void check_specialization_scope PROTO((void));\n static tree process_partial_specialization PROTO((tree));\n static void set_current_access_from_decl PROTO((tree));\n static void check_default_tmpl_args PROTO((tree, tree, int, int));\n-static tree tsubst_call_declarator_parms PROTO((tree, tree, tree));\n-static tree get_template_base_recursive PROTO((tree, tree, tree, tree,\n-\t\t\t\t\t       tree, int)); \n+static tree tsubst_call_declarator_parms PROTO((tree, tree, int, tree));\n+static tree get_template_base_recursive PROTO((tree, tree,\n+\t\t\t\t\t       tree, tree, tree, int)); \n static tree get_template_base PROTO((tree, tree, tree, tree));\n+static tree try_class_unification PROTO((tree, tree, tree, tree));\n+static int coerce_template_template_parms PROTO((tree, tree, int,\n+\t\t\t\t\t\t tree, tree));\n \n /* We use TREE_VECs to hold template arguments.  If there is only one\n    level of template arguments, then the TREE_VEC contains the\n@@ -2776,8 +2785,11 @@ convert_nontype_argument (type, expr)\n    substitute the TT parameter.  */\n \n static int\n-coerce_template_template_parms (parm_parms, arg_parms, in_decl, outer_args)\n-     tree parm_parms, arg_parms, in_decl, outer_args;\n+coerce_template_template_parms (parm_parms, arg_parms, complain, \n+\t\t\t\tin_decl, outer_args)\n+     tree parm_parms, arg_parms;\n+     int complain;\n+     tree in_decl, outer_args;\n {\n   int nparms, nargs, i;\n   tree parm, arg;\n@@ -2820,7 +2832,8 @@ coerce_template_template_parms (parm_parms, arg_parms, in_decl, outer_args)\n \t    tree argparm = DECL_INNERMOST_TEMPLATE_PARMS (arg);\n \n \t    if (!coerce_template_template_parms (parmparm, argparm, \n-\t\t\t\t\t         in_decl, outer_args))\n+\t\t\t\t\t         complain, in_decl,\n+\t\t\t\t\t\t outer_args))\n \t      return 0;\n \t  }\n \t  break;\n@@ -2829,7 +2842,8 @@ coerce_template_template_parms (parm_parms, arg_parms, in_decl, outer_args)\n \t  /* The tsubst call is used to handle cases such as\n \t       template <class T, template <T> class TT> class D;  \n \t     i.e. the parameter list of TT depends on earlier parameters.  */\n-\t  if (!same_type_p (tsubst (TREE_TYPE (parm), outer_args, in_decl), \n+\t  if (!same_type_p (tsubst (TREE_TYPE (parm), outer_args, \n+\t\t\t\t    complain, in_decl),\n \t\t\t    TREE_TYPE (arg)))\n \t    return 0;\n \t  break;\n@@ -2953,7 +2967,7 @@ convert_template_argument (parm, arg, args, complain, i, in_decl)\n \t  tree parmparm = DECL_INNERMOST_TEMPLATE_PARMS (parm);\n \t  tree argparm = DECL_INNERMOST_TEMPLATE_PARMS (arg);\n \n-\t  if (coerce_template_template_parms (parmparm, argparm, \n+\t  if (coerce_template_template_parms (parmparm, argparm, complain,\n \t\t\t\t\t      in_decl, inner_args))\n \t    {\n \t      val = arg;\n@@ -3003,7 +3017,7 @@ convert_template_argument (parm, arg, args, complain, i, in_decl)\n     }\n   else\n     {\n-      tree t = tsubst (TREE_TYPE (parm), args, in_decl);\n+      tree t = tsubst (TREE_TYPE (parm), args, complain, in_decl);\n \n       if (processing_template_decl)\n \targ = maybe_fold_nontype_arg (arg);\n@@ -3110,9 +3124,10 @@ coerce_template_parms (parms, args, in_decl,\n \t  break;\n \t}\n       else if (TREE_CODE (TREE_VALUE (parm)) == TYPE_DECL)\n-\targ = tsubst (TREE_PURPOSE (parm), new_args, in_decl);\n+\targ = tsubst (TREE_PURPOSE (parm), new_args, complain, in_decl);\n       else\n-\targ = tsubst_expr (TREE_PURPOSE (parm), new_args, in_decl);\n+\targ = tsubst_expr (TREE_PURPOSE (parm), new_args, complain,\n+\t\t\t   in_decl);\n \n       /* Now, convert the Ith argument, as necessary.  */\n       if (arg == NULL_TREE)\n@@ -4227,12 +4242,14 @@ tsubst_friend_function (decl, args)\n \n       template_id\n \t= lookup_template_function (tsubst_expr (DECL_TI_TEMPLATE (decl),\n-\t\t\t\t\t\t args, NULL_TREE),\n+\t\t\t\t\t\t args, /*complain=*/1, \n+\t\t\t\t\t\t NULL_TREE),\n \t\t\t\t    tsubst (DECL_TI_ARGS (decl),\n-\t\t\t\t\t    args, NULL_TREE));\n+\t\t\t\t\t    args, /*complain=*/1, \n+\t\t\t\t\t    NULL_TREE));\n       /* FIXME: The decl we create via the next tsubst could be\n \t created on a temporary obstack.  */\n-      new_friend = tsubst (decl, args, NULL_TREE);\n+      new_friend = tsubst (decl, args, /*complain=*/1, NULL_TREE);\n       tmpl = determine_specialization (template_id, new_friend,\n \t\t\t\t       &new_args, \n \t\t\t\t       /*need_member_template=*/0, \n@@ -4241,7 +4258,7 @@ tsubst_friend_function (decl, args)\n       goto done;\n     }\n \n-  new_friend = tsubst (decl, args, NULL_TREE);\n+  new_friend = tsubst (decl, args, /*complain=*/1, NULL_TREE);\n \t\n   /* The NEW_FRIEND will look like an instantiation, to the\n      compiler, but is not an instantiation from the point of view of\n@@ -4436,7 +4453,7 @@ tsubst_friend_class (friend_tmpl, args)\n \t at.  */\n       tree parms \n \t= tsubst_template_parms (DECL_TEMPLATE_PARMS (friend_tmpl),\n-\t\t\t\t args);\n+\t\t\t\t args, /*complain=*/1);\n       redeclare_class_template (TREE_TYPE (tmpl), parms);\n       friend_type = TREE_TYPE (tmpl);\n     }\n@@ -4445,7 +4462,7 @@ tsubst_friend_class (friend_tmpl, args)\n       /* The friend template has not already been declared.  In this\n \t case, the instantiation of the template class will cause the\n \t injection of this template into the global scope.  */\n-      tmpl = tsubst (friend_tmpl, args, NULL_TREE);\n+      tmpl = tsubst (friend_tmpl, args, /*complain=*/1, NULL_TREE);\n \n       /* The new TMPL is not an instantiation of anything, so we\n  \t forget its origins.  We don't reset CLASSTYPE_TI_TEMPLATE for\n@@ -4686,7 +4703,8 @@ instantiate_class_template (type)\n \t    tree elt, basetype;\n \n \t    TREE_VEC_ELT (bases, i) = elt\n-\t      = tsubst (TREE_VEC_ELT (pbases, i), args, NULL_TREE);\n+\t      = tsubst (TREE_VEC_ELT (pbases, i), args,\n+\t\t\t/*complain=*/1, NULL_TREE);\n \t    BINFO_INHERITANCE_CHAIN (elt) = binfo;\n \n \t    basetype = TREE_TYPE (elt);\n@@ -4724,7 +4742,7 @@ instantiate_class_template (type)\n       tree name = TYPE_IDENTIFIER (tag);\n       tree newtag;\n \n-      newtag = tsubst (tag, args, NULL_TREE);\n+      newtag = tsubst (tag, args, /*complain=*/1, NULL_TREE);\n       if (TREE_CODE (newtag) != ENUMERAL_TYPE)\n \t{\n \t  if (TYPE_LANG_SPECIFIC (tag) && CLASSTYPE_IS_TEMPLATE (tag))\n@@ -4761,15 +4779,15 @@ instantiate_class_template (type)\n \tlineno = DECL_SOURCE_LINE (t);\n \tinput_filename = DECL_SOURCE_FILE (t);\n \n-\tr = tsubst (t, args, NULL_TREE);\n+\tr = tsubst (t, args, /*complain=*/1, NULL_TREE);\n \tif (TREE_CODE (r) == VAR_DECL)\n \t  {\n \t    pending_statics = perm_tree_cons (NULL_TREE, r, pending_statics);\n \t    /* Perhaps we should do more of grokfield here.  */\n \t    if (DECL_DEFINED_IN_CLASS_P (r))\n \t      /* Set up DECL_INITIAL, since tsubst doesn't.  */\n \t      DECL_INITIAL (r) = tsubst_expr (DECL_INITIAL (t), args,\n-\t\t\t\t\t      NULL_TREE);\n+\t\t\t\t\t      /*complain=*/1, NULL_TREE);\n \t    start_decl_1 (r);\n \t    DECL_IN_AGGR_P (r) = 1;\n \t    DECL_EXTERNAL (r) = 1;\n@@ -4794,7 +4812,7 @@ instantiate_class_template (type)\n      for this instantiation.  */\n   for (t = TYPE_METHODS (pattern); t; t = TREE_CHAIN (t))\n     {\n-      tree r = tsubst (t, args, NULL_TREE);\n+      tree r = tsubst (t, args, /*complain=*/1, NULL_TREE);\n       set_current_access_from_decl (r);\n       finish_member_declaration (r);\n     }\n@@ -4826,7 +4844,8 @@ instantiate_class_template (type)\n \t  else\n \t    {\n \t      TREE_VALUE (DECL_FRIENDLIST (typedecl))\n-\t\t= tree_cons (tsubst (TREE_PURPOSE (friends), args, NULL_TREE),\n+\t\t= tree_cons (tsubst (TREE_PURPOSE (friends), args, \n+\t\t\t\t     /*complain=*/1, NULL_TREE),\n \t\t\t     NULL_TREE,\n \t\t\t     TREE_VALUE (DECL_FRIENDLIST (typedecl)));\n \n@@ -4844,7 +4863,8 @@ instantiate_class_template (type)\n       if (TREE_CODE (friend_type) == TEMPLATE_DECL)\n \tnew_friend_type = tsubst_friend_class (friend_type, args);\n       else if (uses_template_parms (friend_type))\n-\tnew_friend_type = tsubst (friend_type, args, NULL_TREE);\n+\tnew_friend_type = tsubst (friend_type, args, /*complain=*/1,\n+\t\t\t\t  NULL_TREE);\n       else \n \t/* The call to xref_tag_from_type does injection for friend\n \t   classes.  */\n@@ -4869,7 +4889,8 @@ instantiate_class_template (type)\n   /* This does injection for friend functions. */\n   if (!processing_template_decl)\n     {\n-      t = tsubst (DECL_TEMPLATE_INJECT (template), args, NULL_TREE);\n+      t = tsubst (DECL_TEMPLATE_INJECT (template), args,\n+\t\t  /*complain=*/1, NULL_TREE);\n \n       for (; t; t = TREE_CHAIN (t))\n \t{\n@@ -4970,9 +4991,10 @@ innermost_args (args)\n /* Substitute ARGS into the vector of template arguments T.  */\n \n tree\n-tsubst_template_arg_vector (t, args)\n+tsubst_template_arg_vector (t, args, complain)\n      tree t;\n      tree args;\n+     int complain;\n {\n   int len = TREE_VEC_LENGTH (t), need_new = 0, i;\n   tree *elts = (tree *) alloca (len * sizeof (tree));\n@@ -4983,10 +5005,12 @@ tsubst_template_arg_vector (t, args)\n     {\n       if (TREE_VEC_ELT (t, i) != NULL_TREE\n \t  && TREE_CODE (TREE_VEC_ELT (t, i)) == TREE_VEC)\n-\telts[i] = tsubst_template_arg_vector (TREE_VEC_ELT (t, i), args);\n+\telts[i] = tsubst_template_arg_vector (TREE_VEC_ELT (t, i),\n+\t\t\t\t\t      args, complain);\n       else\n \telts[i] = maybe_fold_nontype_arg\n-\t  (tsubst_expr (TREE_VEC_ELT (t, i), args, NULL_TREE));\n+\t  (tsubst_expr (TREE_VEC_ELT (t, i), args, complain,\n+\t\t\tNULL_TREE));\n       \n       if (elts[i] != TREE_VEC_ELT (t, i))\n \tneed_new = 1;\n@@ -5010,9 +5034,10 @@ tsubst_template_arg_vector (t, args)\n    result will be `template <int*, double, class V>'.  */\n \n tree\n-tsubst_template_parms (parms, args)\n+tsubst_template_parms (parms, args, complain)\n      tree parms;\n      tree args;\n+     int complain;\n {\n   tree r;\n   tree* new_parms = &r;\n@@ -5034,9 +5059,10 @@ tsubst_template_parms (parms, args)\n \t    TREE_VALUE (TREE_VEC_ELT (TREE_VALUE (parms), i));\n \t  \n \t  TREE_VEC_ELT (new_vec, i)\n-\t    = build_tree_list (tsubst (default_value, args, NULL_TREE),\n-\t\t\t       tsubst (parm_decl, args, NULL_TREE));\n-\t  \n+\t    = build_tree_list (tsubst (default_value, args, complain,\n+\t\t\t\t       NULL_TREE), \n+\t\t\t       tsubst (parm_decl, args, complain,\n+\t\t\t\t       NULL_TREE));\n \t}\n       \n       *new_parms = \n@@ -5055,9 +5081,10 @@ tsubst_template_parms (parms, args)\n    we are presently tsubst'ing.  Return the subsituted value.  */\n \n tree\n-tsubst_aggr_type (t, args, in_decl, entering_scope)\n+tsubst_aggr_type (t, args, complain, in_decl, entering_scope)\n      tree t;\n      tree args;\n+     int complain;\n      tree in_decl;\n      int entering_scope;\n {\n@@ -5070,7 +5097,7 @@ tsubst_aggr_type (t, args, in_decl, entering_scope)\n       if (TYPE_PTRMEMFUNC_P (t))\n \t{\n \t  tree r = build_ptrmemfunc_type\n-\t    (tsubst (TYPE_PTRMEMFUNC_FN_TYPE (t), args, in_decl));\n+\t    (tsubst (TYPE_PTRMEMFUNC_FN_TYPE (t), args, complain, in_decl));\n \t  return cp_build_qualified_type (r, TYPE_QUALS (t));\n \t}\n \n@@ -5087,6 +5114,7 @@ tsubst_aggr_type (t, args, in_decl, entering_scope)\n \t     up.  */\n \t  if (TYPE_CONTEXT (t) != NULL_TREE)\n \t    context = tsubst_aggr_type (TYPE_CONTEXT (t), args,\n+\t\t\t\t\tcomplain,\n \t\t\t\t\tin_decl, /*entering_scope=*/1);\n \t  else\n \t    context = NULL_TREE;\n@@ -5101,7 +5129,8 @@ tsubst_aggr_type (t, args, in_decl, entering_scope)\n \t     then our ARGS will be {int, double}, but, when looking up\n \t     S we only want {double}.  */\n \t  push_momentary ();\n-\t  argvec = tsubst_template_arg_vector (TYPE_TI_ARGS (t), args);\n+\t  argvec = tsubst_template_arg_vector (TYPE_TI_ARGS (t), args,\n+\t\t\t\t\t       complain);\n \n   \t  r = lookup_template_class (t, argvec, in_decl, context,\n \t\t\t\t     entering_scope);\n@@ -5114,7 +5143,7 @@ tsubst_aggr_type (t, args, in_decl, entering_scope)\n \treturn t;\n \n     default:\n-      return tsubst (t, args, in_decl);\n+      return tsubst (t, args, complain, in_decl);\n     }\n }\n \n@@ -5162,7 +5191,8 @@ tsubst_decl (t, args, type, in_decl)\n \t    tree full_args;\n \t    \n \t    push_momentary ();\n-\t    full_args = tsubst_template_arg_vector (tmpl_args, args);\n+\t    full_args = tsubst_template_arg_vector (tmpl_args, args,\n+\t\t\t\t\t\t    /*complain=*/1);\n \n \t    /* tsubst_template_arg_vector doesn't copy the vector if\n \t       nothing changed.  But, *something* should have\n@@ -5190,31 +5220,33 @@ tsubst_decl (t, args, type, in_decl)\n \n \tif (is_template_template_parm)\n \t  {\n-\t    tree new_decl = tsubst (decl, args, in_decl);\n+\t    tree new_decl = tsubst (decl, args, /*complain=*/1, in_decl);\n \t    DECL_RESULT (r) = new_decl;\n \t    TREE_TYPE (r) = TREE_TYPE (new_decl);\n \t    break;\n \t  }\n \n \tDECL_CONTEXT (r) \n-\t  = tsubst_aggr_type (DECL_CONTEXT (t), args, in_decl,\n-\t\t\t      /*entering_scope=*/1);\n+\t  = tsubst_aggr_type (DECL_CONTEXT (t), args, /*complain=*/1,\n+\t\t\t      in_decl, /*entering_scope=*/1);\n \tDECL_CLASS_CONTEXT (r) \n-\t  = tsubst_aggr_type (DECL_CLASS_CONTEXT (t), args, in_decl,\n-\t\t\t      /*entering_scope=*/1);\n+\t  = tsubst_aggr_type (DECL_CLASS_CONTEXT (t), args, \n+\t\t\t      /*complain=*/1, in_decl, \n+\t\t\t      /*entering_scope=*/1); \n \tDECL_TEMPLATE_INFO (r) = build_tree_list (t, args);\n \n \tif (TREE_CODE (decl) == TYPE_DECL)\n \t  {\n-\t    tree new_type = tsubst (TREE_TYPE (t), args, in_decl);\n+\t    tree new_type = tsubst (TREE_TYPE (t), args,\n+\t\t\t\t    /*complain=*/1, in_decl);\n \t    TREE_TYPE (r) = new_type;\n \t    CLASSTYPE_TI_TEMPLATE (new_type) = r;\n \t    DECL_RESULT (r) = TYPE_MAIN_DECL (new_type);\n \t    DECL_TI_ARGS (r) = CLASSTYPE_TI_ARGS (new_type);\n \t  }\n \telse\n \t  {\n-\t    tree new_decl = tsubst (decl, args, in_decl);\n+\t    tree new_decl = tsubst (decl, args, /*complain=*/1, in_decl);\n \t    DECL_RESULT (r) = new_decl;\n \t    DECL_TI_TEMPLATE (new_decl) = r;\n \t    TREE_TYPE (r) = TREE_TYPE (new_decl);\n@@ -5229,7 +5261,8 @@ tsubst_decl (t, args, type, in_decl)\n \t   template parameters for the old template, except the\n \t   outermost level of parameters. */\n \tDECL_TEMPLATE_PARMS (r) \n-\t  = tsubst_template_parms (DECL_TEMPLATE_PARMS (t), args);\n+\t  = tsubst_template_parms (DECL_TEMPLATE_PARMS (t), args,\n+\t\t\t\t   /*complain=*/1);\n \n \tif (PRIMARY_TEMPLATE_P (t))\n \t  DECL_PRIMARY_TEMPLATE (r) = r;\n@@ -5283,9 +5316,10 @@ tsubst_decl (t, args, type, in_decl)\n \t\t that here.  */\n \t      continue;\n \n-\t    spec_args = tsubst (DECL_TI_ARGS (fn), args, in_decl); \n+\t    spec_args = tsubst (DECL_TI_ARGS (fn), args,\n+\t\t\t\t/*complain=*/1, in_decl); \n \t    new_fn = tsubst (DECL_RESULT (most_general_template (fn)), \n-\t\t\t     spec_args, in_decl); \n+\t\t\t     spec_args, /*complain=*/1, in_decl); \n \t    DECL_TI_TEMPLATE (new_fn) = fn;\n \t    register_specialization (new_fn, r, \n \t\t\t\t     innermost_args (spec_args));\n@@ -5325,7 +5359,7 @@ tsubst_decl (t, args, type, in_decl)\n \t    argvec \n \t      = tsubst_template_arg_vector (DECL_TI_ARGS \n \t\t\t\t\t    (DECL_TEMPLATE_RESULT (gen_tmpl)),\n-\t\t\t\t\t    args); \n+\t\t\t\t\t    args, /*complain=*/1); \n \n \t    /* Check to see if we already have this specialization.  */\n \t    spec = retrieve_specialization (gen_tmpl, argvec);\n@@ -5409,15 +5443,16 @@ tsubst_decl (t, args, type, in_decl)\n \t      member = 2;\n \t    else\n \t      member = 1;\n-\t    ctx = tsubst_aggr_type (DECL_CLASS_CONTEXT (t), args, t,\n+\t    ctx = tsubst_aggr_type (DECL_CLASS_CONTEXT (t), args, \n+\t\t\t\t    /*complain=*/1, t, \n \t\t\t\t    /*entering_scope=*/1);\n \t  }\n \telse\n \t  {\n \t    member = 0;\n \t    ctx = NULL_TREE;\n \t  }\n-\ttype = tsubst (type, args, in_decl);\n+\ttype = tsubst (type, args, /*complain=*/1, in_decl);\n \n \t/* We do NOT check for matching decls pushed separately at this\n            point, as they may not represent instantiations of this\n@@ -5430,15 +5465,17 @@ tsubst_decl (t, args, type, in_decl)\n \tTREE_TYPE (r) = type;\n \n \tDECL_CONTEXT (r)\n-\t  = tsubst_aggr_type (DECL_CONTEXT (t), args, t, /*entering_scope=*/1);\n+\t  = tsubst_aggr_type (DECL_CONTEXT (t), args, /*complain=*/1, t,\n+\t\t\t      /*entering_scope=*/1);\n \tDECL_CLASS_CONTEXT (r) = ctx;\n \n \tif (member && IDENTIFIER_TYPENAME_P (DECL_NAME (r)))\n \t  /* Type-conversion operator.  Reconstruct the name, in\n \t     case it's the name of one of the template's parameters.  */\n \t  DECL_NAME (r) = build_typename_overload (TREE_TYPE (type));\n \n-\tDECL_ARGUMENTS (r) = tsubst (DECL_ARGUMENTS (t), args, t);\n+\tDECL_ARGUMENTS (r) = tsubst (DECL_ARGUMENTS (t), args,\n+\t\t\t\t     /*complain=*/1, t);\n \tDECL_MAIN_VARIANT (r) = r;\n \tDECL_RESULT (r) = NULL_TREE;\n \n@@ -5515,7 +5552,8 @@ tsubst_decl (t, args, type, in_decl)\n \tif (TREE_CODE (DECL_INITIAL (r)) != TEMPLATE_PARM_INDEX)\n \t  DECL_INITIAL (r) = TREE_TYPE (r);\n \telse\n-\t  DECL_INITIAL (r) = tsubst (DECL_INITIAL (r), args, in_decl);\n+\t  DECL_INITIAL (r) = tsubst (DECL_INITIAL (r), args,\n+\t\t\t\t     /*complain=*/1, in_decl);\n \n \tDECL_CONTEXT (r) = NULL_TREE;\n #ifdef PROMOTE_PROTOTYPES\n@@ -5525,7 +5563,8 @@ tsubst_decl (t, args, type, in_decl)\n \t  DECL_ARG_TYPE (r) = integer_type_node;\n #endif\n \tif (TREE_CHAIN (t))\n-\t  TREE_CHAIN (r) = tsubst (TREE_CHAIN (t), args, TREE_CHAIN (t));\n+\t  TREE_CHAIN (r) = tsubst (TREE_CHAIN (t), args,\n+\t\t\t\t   /*complain=*/1, TREE_CHAIN (t));\n       }\n       break;\n \n@@ -5535,11 +5574,13 @@ tsubst_decl (t, args, type, in_decl)\n \tTREE_TYPE (r) = type;\n \tcopy_lang_decl (r);\n #if 0\n-\tDECL_FIELD_CONTEXT (r) = tsubst (DECL_FIELD_CONTEXT (t), args, in_decl);\n+\tDECL_FIELD_CONTEXT (r) = tsubst (DECL_FIELD_CONTEXT (t), args, \n+\t\t\t\t\t /*complain=*/1, in_decl);\n #endif\n-\tDECL_INITIAL (r) = tsubst_expr (DECL_INITIAL (t), args, in_decl);\n+\tDECL_INITIAL (r) = tsubst_expr (DECL_INITIAL (t), args,\n+\t\t\t\t\t/*complain=*/1, in_decl);\n \tTREE_CHAIN (r) = NULL_TREE;\n-\tif (TREE_CODE (type) == VOID_TYPE)\n+\tif (TREE_CODE (type) == VOID_TYPE) \n \t  cp_error_at (\"instantiation of `%D' as type void\", r);\n       }\n       break;\n@@ -5548,7 +5589,7 @@ tsubst_decl (t, args, type, in_decl)\n       {\n \tr = copy_node (t);\n \tDECL_INITIAL (r)\n-\t  = tsubst_copy (DECL_INITIAL (t), args, in_decl);\n+\t  = tsubst_copy (DECL_INITIAL (t), args, /*complain=*/1, in_decl);\n \tTREE_CHAIN (r) = NULL_TREE;\n       }\n       break;\n@@ -5559,8 +5600,9 @@ tsubst_decl (t, args, type, in_decl)\n \ttree gen_tmpl;\n \ttree spec;\n \ttree tmpl;\n-\ttree ctx = tsubst_aggr_type (DECL_CONTEXT (t), args, in_decl,\n-\t\t\t\t     /*entering_scope=*/1);\n+\ttree ctx = tsubst_aggr_type (DECL_CONTEXT (t), args, \n+\t\t\t\t     /*complain=*/1,\n+\t\t\t\t     in_decl, /*entering_scope=*/1);\n \t\n \t/* Nobody should be tsubst'ing into non-template variables.  */\n \tmy_friendly_assert (DECL_LANG_SPECIFIC (t) \n@@ -5569,7 +5611,7 @@ tsubst_decl (t, args, type, in_decl)\n \t/* Check to see if we already have this specialization.  */\n \ttmpl = DECL_TI_TEMPLATE (t);\n \tgen_tmpl = most_general_template (tmpl);\n-\targvec = tsubst (DECL_TI_ARGS (t), args, in_decl);\n+\targvec = tsubst (DECL_TI_ARGS (t), args, /*complain=*/1, in_decl);\n \tspec = retrieve_specialization (gen_tmpl, argvec);\n \t\n \tif (spec)\n@@ -5629,9 +5671,10 @@ tsubst_decl (t, args, type, in_decl)\n /* Substitue into the ARG_TYPES of a function type.  */\n \n tree\n-tsubst_arg_types (arg_types, args, in_decl)\n+tsubst_arg_types (arg_types, args, complain, in_decl)\n      tree arg_types;\n      tree args;\n+     int complain;\n      tree in_decl;\n {\n   tree remaining_arg_types;\n@@ -5641,13 +5684,17 @@ tsubst_arg_types (arg_types, args, in_decl)\n     return arg_types;\n   \n   remaining_arg_types = tsubst_arg_types (TREE_CHAIN (arg_types),\n-\t\t\t\t\t  args, in_decl);\n+\t\t\t\t\t  args, complain, in_decl);\n+  if (remaining_arg_types == error_mark_node)\n+    return error_mark_node;\n+\n+  type = tsubst (TREE_VALUE (arg_types), args, complain, in_decl);\n+  if (type == error_mark_node)\n+    return error_mark_node;\n \n-  /* We use TYPE_MAIN_VARIANT is because top-level qualifiers don't\n-     matter on function types.  */\n-  type = TYPE_MAIN_VARIANT (type_decays_to \n-\t\t\t    (tsubst (TREE_VALUE (arg_types),\n-\t\t\t\t     args, in_decl)));\n+  /* Do array-to-pointer, function-to-pointer conversion, and ignore\n+     top-level qualifiers as required.  */\n+  type = TYPE_MAIN_VARIANT (type_decays_to (type));\n \n   /* Note that we do not substitute into default arguments here.  The\n      standard mandates that they be instantiated only when needed,\n@@ -5657,12 +5704,84 @@ tsubst_arg_types (arg_types, args, in_decl)\n \t\t\t \n }\n \n+/* Substitute into a FUNCTION_TYPE or METHOD_TYPE.  This routine does\n+   *not* handle the exception-specification for FNTYPE, because the\n+   initial substitution of explicitly provided template parameters\n+   during argument deduction forbids substitution into the\n+   exception-specification:\n+\n+     [temp.deduct]\n+\n+     All references in the function type of the function template to  the\n+     corresponding template parameters are replaced by the specified tem-\n+     plate argument values.  If a substitution in a template parameter or\n+     in  the function type of the function template results in an invalid\n+     type, type deduction fails.  [Note: The equivalent  substitution  in\n+     exception specifications is done only when the function is instanti-\n+     ated, at which point a program is  ill-formed  if  the  substitution\n+     results in an invalid type.]  */\n+\n+static tree\n+tsubst_function_type (t, args, complain, in_decl)\n+     tree t;\n+     tree args;\n+     int complain;\n+     tree in_decl;\n+{\n+  tree return_type;\n+  tree arg_types;\n+  tree fntype;\n+\n+  /* The TYPE_CONTEXT is not used for function/method types.  */\n+  my_friendly_assert (TYPE_CONTEXT (t) == NULL_TREE, 0);\n+\n+  /* Substitue the return type.  */\n+  return_type = tsubst (TREE_TYPE (t), args, complain, in_decl);\n+  if (return_type == error_mark_node)\n+    return error_mark_node;\n+\n+  /* Substitue the argument types.  */\n+  arg_types = tsubst_arg_types (TYPE_ARG_TYPES (t), args,\n+\t\t\t\tcomplain, in_decl); \n+  if (arg_types == error_mark_node)\n+    return error_mark_node;\n+  \n+  /* Construct a new type node and return it.  */\n+  if (TREE_CODE (t) == FUNCTION_TYPE)\n+    fntype = build_function_type (return_type, arg_types);\n+  else\n+    {\n+      tree r = TREE_TYPE (TREE_VALUE (arg_types));\n+      if (! IS_AGGR_TYPE (r))\n+\t{\n+\t  /* [temp.deduct]\n+\t     \n+\t     Type deduction may fail for any of the following\n+\t     reasons:\n+\t     \n+\t     -- Attempting to create \"pointer to member of T\" when T\n+\t     is not a class type.  */\n+\t  if (complain)\n+\t    cp_error (\"creating pointer to member function of non-class type `%T'\",\n+\t\t      r);\n+\t  return error_mark_node;\n+\t}\n+      \n+      fntype = build_cplus_method_type (r, return_type, TREE_CHAIN\n+\t\t\t\t\t(arg_types));\n+    }\n+  fntype = build_qualified_type (fntype, TYPE_QUALS (t));\n+  \n+  return fntype;  \n+}\n+\n /* Substitute into the PARMS of a call-declarator.  */\n \n tree\n-tsubst_call_declarator_parms (parms, args, in_decl)\n+tsubst_call_declarator_parms (parms, args, complain, in_decl)\n      tree parms;\n      tree args;\n+     int complain;\n      tree in_decl;\n {\n   tree new_parms;\n@@ -5673,15 +5792,14 @@ tsubst_call_declarator_parms (parms, args, in_decl)\n     return parms;\n   \n   new_parms = tsubst_call_declarator_parms (TREE_CHAIN (parms),\n-\t\t\t\t\t    args, in_decl);\n+\t\t\t\t\t    args, complain, in_decl);\n \n   /* Figure out the type of this parameter.  */\n-  type = tsubst (TREE_VALUE (parms), args, in_decl);\n+  type = tsubst (TREE_VALUE (parms), args, complain, in_decl);\n   \n   /* Figure out the default argument as well.  Note that we use\n-     tsubst_copy since the default argument is really an \n-     expression.  */\n-  defarg = tsubst_expr (TREE_PURPOSE (parms), args, in_decl);\n+     tsubst_expr since the default argument is really an expression.  */\n+  defarg = tsubst_expr (TREE_PURPOSE (parms), args, complain, in_decl);\n \n   /* Chain this parameter on to the front of those we have already\n      processed.  We don't use hash_tree_cons because that function\n@@ -5694,16 +5812,26 @@ tsubst_call_declarator_parms (parms, args, in_decl)\n   return new_parms;\n }\n \n-/* Take the tree structure T and replace template parameters used therein\n-   with the argument vector ARGS.  IN_DECL is an associated decl for\n-   diagnostics.\n-\n-   tsubst is used for dealing with types, decls and the like; for\n-   expressions, use tsubst_expr or tsubst_copy.  */\n+/* Take the tree structure T and replace template parameters used\n+   therein with the argument vector ARGS.  IN_DECL is an associated\n+   decl for diagnostics.  If an error occurs, returns ERROR_MARK_NODE.\n+   An appropriate error message is issued only if COMPLAIN is\n+   non-zero.  Note that we must be relatively non-tolerant of\n+   extensions here, in order to preserve conformance; if we allow\n+   substitutions that should not be allowed, we may allow argument\n+   deductions that should not succeed, and therefore report ambiguous\n+   overload situations where there are none.  In theory, we could\n+   allow the substitution, but indicate that it should have failed,\n+   and allow our caller to make sure that the right thing happens, but\n+   we don't try to do this yet.\n+\n+   This function is used for dealing with types, decls and the like;\n+   for expressions, use tsubst_expr or tsubst_copy.  */\n \n tree\n-tsubst (t, args, in_decl)\n+tsubst (t, args, complain, in_decl)\n      tree t, args;\n+     int complain;\n      tree in_decl;\n {\n   tree type, r;\n@@ -5725,8 +5853,12 @@ tsubst (t, args, in_decl)\n   if (type && TREE_CODE (t) != FUNCTION_DECL\n       && TREE_CODE (t) != TYPENAME_TYPE\n       && TREE_CODE (t) != TEMPLATE_DECL\n-      && TREE_CODE (t) != IDENTIFIER_NODE)\n-    type = tsubst (type, args, in_decl);\n+      && TREE_CODE (t) != IDENTIFIER_NODE\n+      && TREE_CODE (t) != FUNCTION_TYPE\n+      && TREE_CODE (t) != METHOD_TYPE)\n+    type = tsubst (type, args, complain, in_decl);\n+  if (type == error_mark_node)\n+    return error_mark_node;\n \n   if (TREE_CODE_CLASS (TREE_CODE (t)) == 'd')\n     return tsubst_decl (t, args, type, in_decl);\n@@ -5736,7 +5868,8 @@ tsubst (t, args, in_decl)\n     case RECORD_TYPE:\n     case UNION_TYPE:\n     case ENUMERAL_TYPE:\n-      return tsubst_aggr_type (t, args, in_decl, /*entering_scope=*/0);\n+      return tsubst_aggr_type (t, args, complain, in_decl,\n+\t\t\t       /*entering_scope=*/0);\n \n     case ERROR_MARK:\n     case IDENTIFIER_NODE:\n@@ -5761,7 +5894,10 @@ tsubst (t, args, in_decl)\n       {\n \ttree max = TREE_OPERAND (TYPE_MAX_VALUE (t), 0);\n \n-\tmax = tsubst_expr (max, args, in_decl);\n+\tmax = tsubst_expr (max, args, complain, in_decl);\n+\tif (max == error_mark_node)\n+\t  return error_mark_node;\n+\n \tif (processing_template_decl)\n \t  {\n \t    tree itype = make_node (INTEGER_TYPE);\n@@ -5771,12 +5907,19 @@ tsubst (t, args, in_decl)\n \t    return itype;\n \t  }\n \n-\tif (pedantic && integer_zerop (max))\n-\t  pedwarn (\"creating array with size zero\");\n-\telse if (INT_CST_LT (max, integer_zero_node))\n+\tif (integer_zerop (max) || INT_CST_LT (max, integer_zero_node))\n \t  {\n-\t    cp_error (\"creating array with size `%E'\", max);\n-\t    max = integer_one_node;\n+\t    /* [temp.deduct]\n+\n+\t       Type deduction may fail for any of the following\n+\t       reasons:  \n+\n+\t         Attempting to create an array with a size that is\n+\t         zero or negative.  */\n+\t    if (complain)\n+\t      cp_error (\"creating array with size `%E'\", max);\n+\n+\t    return error_mark_node;\n \t  }\n \n \tmax = fold (build_binary_op (MINUS_EXPR, max, integer_one_node, 1));\n@@ -5833,8 +5976,10 @@ tsubst (t, args, in_decl)\n \t\t\t/* We are processing a type constructed from\n \t\t\t   a template template parameter */\n \t\t\ttree argvec = tsubst (TYPE_TI_ARGS (t),\n-\t\t\t\t\t      args, in_decl);\n-\n+\t\t\t\t\t      args, complain, in_decl);\n+\t\t\tif (argvec == error_mark_node)\n+\t\t\t  return error_mark_node;\n+\t\t\t\n \t\t\t/* We can get a TEMPLATE_TEMPLATE_PARM here when \n \t\t\t   we are resolving nested-types in the signature of \n \t\t\t   a member function templates.\n@@ -5885,7 +6030,11 @@ tsubst (t, args, in_decl)\n \t    if (TREE_CODE (t) == TEMPLATE_TEMPLATE_PARM\n \t\t&& TEMPLATE_TEMPLATE_PARM_TEMPLATE_INFO (t))\n \t      {\n-\t\ttree argvec = tsubst (TYPE_TI_ARGS (t), args, in_decl);\n+\t\ttree argvec = tsubst (TYPE_TI_ARGS (t), args,\n+\t\t\t\t      complain, in_decl); \n+\t\tif (argvec == error_mark_node)\n+\t\t  return error_mark_node;\n+\n \t\tTEMPLATE_TEMPLATE_PARM_TEMPLATE_INFO (r)\n \t\t  = perm_tree_cons (TYPE_NAME (t), argvec, NULL_TREE);\n \t      }\n@@ -5916,13 +6065,25 @@ tsubst (t, args, in_decl)\n \n \tpurpose = TREE_PURPOSE (t);\n \tif (purpose)\n-\t  purpose = tsubst (purpose, args, in_decl);\n+\t  {\n+\t    purpose = tsubst (purpose, args, complain, in_decl);\n+\t    if (purpose == error_mark_node)\n+\t      return error_mark_node;\n+\t  }\n \tvalue = TREE_VALUE (t);\n \tif (value)\n-\t  value = tsubst (value, args, in_decl);\n+\t  {\n+\t    value = tsubst (value, args, complain, in_decl);\n+\t    if (value == error_mark_node)\n+\t      return error_mark_node;\n+\t  }\n \tchain = TREE_CHAIN (t);\n \tif (chain && chain != void_type_node)\n-\t  chain = tsubst (chain, args, in_decl);\n+\t  {\n+\t    chain = tsubst (chain, args, complain, in_decl);\n+\t    if (chain == error_mark_node)\n+\t      return error_mark_node;\n+\t  }\n \tif (purpose == TREE_PURPOSE (t)\n \t    && value == TREE_VALUE (t)\n \t    && chain == TREE_CHAIN (t))\n@@ -5955,7 +6116,7 @@ tsubst (t, args, in_decl)\n \t}\n \n       /* Otherwise, a vector of template arguments.  */\n-      return tsubst_template_arg_vector (t, args);\n+      return tsubst_template_arg_vector (t, args, complain);\n \n     case POINTER_TYPE:\n     case REFERENCE_TYPE:\n@@ -5966,6 +6127,16 @@ tsubst (t, args, in_decl)\n \t  return t;\n \n \tcode = TREE_CODE (t);\n+\n+\n+\t/* [temp.deduct]\n+\t   \n+\t   Type deduction may fail for any of the following\n+\t   reasons:  \n+\n+\t   -- Attempting to create a pointer to reference type.\n+\t   -- Attempting to create a reference to a reference type or\n+\t      a reference to void.  */\n \tif (TREE_CODE (type) == REFERENCE_TYPE\n \t    || (code == REFERENCE_TYPE && TREE_CODE (type) == VOID_TYPE))\n \t  {\n@@ -5975,8 +6146,8 @@ tsubst (t, args, in_decl)\n \t    /* We keep track of the last time we issued this error\n \t       message to avoid spewing a ton of messages during a\n \t       single bad template instantiation.  */\n-\t    if (last_line != lineno ||\n-\t\tlast_file != input_filename)\n+\t    if (complain && (last_line != lineno ||\n+\t\t\t     last_file != input_filename))\n \t      {\n \t\tif (TREE_CODE (type) == VOID_TYPE)\n \t\t  cp_error (\"forming reference to void\");\n@@ -5988,13 +6159,7 @@ tsubst (t, args, in_decl)\n \t\tlast_file = input_filename;\n \t      }\n \n-\t    /* Use the underlying type in an attempt at error\n-\t       recovery; maybe the user meant vector<int> and wrote\n-\t       vector<int&>, or some such.  */\n-\t    if (code == REFERENCE_TYPE)\n-\t      r = type;\n-\t    else\n-\t      r = build_pointer_type (TREE_TYPE (type));\n+\t    return error_mark_node;\n \t  }\n \telse if (code == POINTER_TYPE)\n \t  r = build_pointer_type (type);\n@@ -6008,68 +6173,70 @@ tsubst (t, args, in_decl)\n       }\n     case OFFSET_TYPE:\n       {\n-\tr = tsubst (TYPE_OFFSET_BASETYPE (t), args, in_decl);\n-\tif (! IS_AGGR_TYPE (r))\n-\t  cp_error (\"creating pointer to member of non-class type `%T'\", r);\n+\tr = tsubst (TYPE_OFFSET_BASETYPE (t), args, complain, in_decl);\n+\tif (r == error_mark_node || !IS_AGGR_TYPE (r))\n+\t  {\n+\t    /* [temp.deduct]\n+\n+\t       Type deduction may fail for any of the following\n+\t       reasons:\n+\t       \n+\t       -- Attempting to create \"pointer to member of T\" when T\n+\t          is not a class type.  */\n+\t    if (complain)\n+\t      cp_error (\"creating pointer to member of non-class type `%T'\", \n+\t\t\tr);\n+\t    return error_mark_node;\n+\t  }\n \treturn build_offset_type (r, type);\n       }\n     case FUNCTION_TYPE:\n     case METHOD_TYPE:\n       {\n-\ttree arg_types;\n-\ttree raises;\n \ttree fntype;\n+\ttree raises;\n \n-\t/* The TYPE_CONTEXT is not used for function/method types.  */\n-\tmy_friendly_assert (TYPE_CONTEXT (t) == NULL_TREE, 0);\n-\t\n-\t/* Substitue the argument types.  */\n-\targ_types = tsubst_arg_types (TYPE_ARG_TYPES (t), args, in_decl);\n-\n-\t/* Construct a new type node and return it.  */\n-\tif (TREE_CODE (t) == FUNCTION_TYPE)\n-\t  fntype = build_function_type (type, arg_types);\n-\telse\n-\t  {\n-\t    r = TREE_TYPE (TREE_VALUE (arg_types));\n-\t    if (! IS_AGGR_TYPE (r))\n-\t      cp_error (\"creating pointer to member function of non-class type `%T'\",\n-\t\t\tr);\n-\t      \n-\t    fntype = build_cplus_method_type (r, type, TREE_CHAIN (arg_types));\n-\t  }\n-\tfntype = build_qualified_type (fntype, TYPE_QUALS (t));\n+\tfntype = tsubst_function_type (t, args, complain, in_decl);\n+\tif (fntype == error_mark_node)\n+\t  return error_mark_node;\n \n \t/* Substitue the exception specification. */\n \traises = TYPE_RAISES_EXCEPTIONS (t);\n \tif (raises)\n \t  {\n-\t    raises = tsubst (raises, args, in_decl);\n+\t    raises = tsubst (raises, args, complain, in_decl);\n+\t    if (raises == error_mark_node)\n+\t      return raises;\n \t    fntype = build_exception_variant (fntype, raises);\n \t  }\n \treturn fntype;\n       }\n     case ARRAY_TYPE:\n       {\n-\ttree domain = tsubst (TYPE_DOMAIN (t), args, in_decl);\n+\ttree domain = tsubst (TYPE_DOMAIN (t), args, complain, in_decl);\n+\tif (domain == error_mark_node)\n+\t  return error_mark_node;\n+\n+\t/* As an optimization, we avoid regenerating the array type if\n+\t   it will obviously be the same as T.  */\n \tif (type == TREE_TYPE (t) && domain == TYPE_DOMAIN (t))\n \t  return t;\n \n-\t/* These checks should match the ones in grokdeclarator.  */\n-\tif (TREE_CODE (type) == VOID_TYPE)\n-\t  {\n-\t    cp_error (\"creating array of void\");\n-\t    type = build_pointer_type (type);\n-\t  }\n-\telse if (TREE_CODE (type) == FUNCTION_TYPE)\n-\t  {\n-\t    cp_error (\"creating array of functions `%T'\", type);\n-\t    type = build_pointer_type (type);\n-\t  }\n-\telse if (TREE_CODE (type) == REFERENCE_TYPE)\n+\t/* These checks should match the ones in grokdeclarator.  \n+\n+\t   [temp.deduct] \n+\t\n+\t   The deduction may fail for any of the following reasons: \n+\n+\t   -- Attempting to create an array with an element type that\n+\t      is void, a function type, or a reference type.  */\n+\tif (TREE_CODE (type) == VOID_TYPE \n+\t    || TREE_CODE (type) == FUNCTION_TYPE\n+\t    || TREE_CODE (type) == REFERENCE_TYPE)\n \t  {\n-\t    cp_error (\"creating array of references `%T'\", type);\n-\t    type = TREE_TYPE (type);\n+\t    if (complain)\n+\t      cp_error (\"creating array of `%T'\", type);\n+\t    return error_mark_node;\n \t  }\n \n \tr = build_cplus_array_type (type, domain);\n@@ -6078,20 +6245,38 @@ tsubst (t, args, in_decl)\n \n     case PLUS_EXPR:\n     case MINUS_EXPR:\n-      return fold (build (TREE_CODE (t), TREE_TYPE (t),\n-\t\t\t  tsubst (TREE_OPERAND (t, 0), args, in_decl),\n-\t\t\t  tsubst (TREE_OPERAND (t, 1), args, in_decl)));\n+      {\n+\ttree e1 = tsubst (TREE_OPERAND (t, 0), args, complain,\n+\t\t\t  in_decl);\n+\ttree e2 = tsubst (TREE_OPERAND (t, 1), args, complain,\n+\t\t\t  in_decl);\n+\n+\tif (e1 == error_mark_node || e2 == error_mark_node)\n+\t  return error_mark_node;\n+\n+\treturn fold (build (TREE_CODE (t), TREE_TYPE (t), e1, e2));\n+      }\n \n     case NEGATE_EXPR:\n     case NOP_EXPR:\n-      return fold (build1 (TREE_CODE (t), TREE_TYPE (t),\n-\t\t\t   tsubst (TREE_OPERAND (t, 0), args, in_decl)));\n+      {\n+\ttree e = tsubst (TREE_OPERAND (t, 0), args, complain,\n+\t\t\t  in_decl);\n+\tif (e == error_mark_node)\n+\t  return error_mark_node;\n+\n+\treturn fold (build (TREE_CODE (t), TREE_TYPE (t), e));\n+      }\n \n     case TYPENAME_TYPE:\n       {\n-\ttree ctx = tsubst_aggr_type (TYPE_CONTEXT (t), args, in_decl,\n-\t\t\t\t     /*entering_scope=*/1);\n-\ttree f = tsubst_copy (TYPENAME_TYPE_FULLNAME (t), args, in_decl);\n+\ttree ctx = tsubst_aggr_type (TYPE_CONTEXT (t), args, complain,\n+\t\t\t\t     in_decl, /*entering_scope=*/1);\n+\ttree f = tsubst_copy (TYPENAME_TYPE_FULLNAME (t), args,\n+\t\t\t      complain, in_decl); \n+\n+\tif (ctx == error_mark_node || f == error_mark_node)\n+\t  return error_mark_node;\n \n \t/* Normally, make_typename_type does not require that the CTX\n \t   have complete type in order to allow things like:\n@@ -6101,10 +6286,16 @@ tsubst (t, args, in_decl)\n \t   But, such constructs have already been resolved by this\n \t   point, so here CTX really should have complete type, unless\n \t   it's a partial instantiation.  */\n-\tif (!uses_template_parms (ctx)\n-\t    && !TYPE_BEING_DEFINED (ctx)\n-\t    && !complete_type_or_else (ctx))\n-\t  return error_mark_node;\n+\tif (!uses_template_parms (ctx) && !TYPE_BEING_DEFINED (ctx))\n+\t  {\n+\t    ctx = complete_type (ctx);\n+\t    if (!TYPE_SIZE (ctx))\n+\t      {\n+\t\tif (complain)\n+\t\t  incomplete_type_error (NULL_TREE, ctx);\n+\t\treturn error_mark_node;\n+\t      }\n+\t  }\n \n \tf = make_typename_type (ctx, f);\n \treturn cp_build_qualified_type (f, \n@@ -6113,32 +6304,70 @@ tsubst (t, args, in_decl)\n       }\n \n     case INDIRECT_REF:\n-      return make_pointer_declarator\n-\t(type, tsubst (TREE_OPERAND (t, 0), args, in_decl));\n-      \n+      {\n+\ttree e = tsubst (TREE_OPERAND (t, 0), args, complain,\n+\t\t\t in_decl);\n+\tif (e == error_mark_node)\n+\t  return error_mark_node;\n+\treturn make_pointer_declarator (type, e);\n+      }\n+\n     case ADDR_EXPR:\n-      return make_reference_declarator\n-\t(type, tsubst (TREE_OPERAND (t, 0), args, in_decl));\n+      {\n+\ttree e = tsubst (TREE_OPERAND (t, 0), args, complain,\n+\t\t\t in_decl);\n+\tif (e == error_mark_node)\n+\t  return error_mark_node;\n+\treturn make_reference_declarator (type, e);\n+      }\n \n     case ARRAY_REF:\n-      return build_parse_node\n-\t(ARRAY_REF, tsubst (TREE_OPERAND (t, 0), args, in_decl),\n-\t tsubst_expr (TREE_OPERAND (t, 1), args, in_decl));\n+      {\n+\ttree e1 = tsubst (TREE_OPERAND (t, 0), args, complain,\n+\t\t\t  in_decl);\n+\ttree e2 = tsubst (TREE_OPERAND (t, 1), args, complain,\n+\t\t\t  in_decl);\n+\tif (e1 == error_mark_node || e2 == error_mark_node)\n+\t  return error_mark_node;\n+\n+\treturn build_parse_node (ARRAY_REF, e1, e2, tsubst_expr);\n+      }\n \n     case CALL_EXPR:\n-      return make_call_declarator\n-\t(tsubst (TREE_OPERAND (t, 0), args, in_decl),\n-\t tsubst_call_declarator_parms (TREE_OPERAND (t, 1), args, in_decl),\n-\t TREE_OPERAND (t, 2),\n-\t tsubst (TREE_TYPE (t), args, in_decl));\n+      {\n+\ttree e1 = tsubst (TREE_OPERAND (t, 0), args, complain,\n+\t\t\t  in_decl);\n+\ttree e2 = tsubst_call_declarator_parms (TREE_OPERAND (t, 1), args, \n+\t\t\t\t\t\tcomplain, in_decl);\n+\ttree e3 = tsubst (TREE_TYPE (t), args, complain, in_decl);\n+\n+\tif (e1 == error_mark_node || e2 == error_mark_node \n+\t    || e3 == error_mark_node)\n+\t  return error_mark_node;\n+\n+\treturn make_call_declarator (e1, e2, TREE_OPERAND (t, 2), e3);\n+      }\n \n     case SCOPE_REF:\n-      return build_parse_node\n-\t(TREE_CODE (t), tsubst (TREE_OPERAND (t, 0), args, in_decl),\n-\t tsubst (TREE_OPERAND (t, 1), args, in_decl));\n+      {\n+\ttree e1 = tsubst (TREE_OPERAND (t, 0), args, complain,\n+\t\t\t\t  in_decl);\n+\ttree e2 = tsubst (TREE_OPERAND (t, 1), args, complain, in_decl);\n+\tif (e1 == error_mark_node || e2 == error_mark_node)\n+\t  return error_mark_node;\n+\n+\treturn build_parse_node (TREE_CODE (t), e1, e2);\n+      }\n \n     case TYPEOF_TYPE:\n-      return TREE_TYPE (tsubst_expr (TYPE_FIELDS (t), args, in_decl));\n+      {\n+\ttree e1 = tsubst_expr (TYPE_FIELDS (t), args, complain,\n+\t\t\t       in_decl);\n+\tif (e1 == error_mark_node)\n+\t  return error_mark_node;\n+\n+\treturn TREE_TYPE (e1); \n+      }\n \n     default:\n       sorry (\"use of `%s' in template\",\n@@ -6181,8 +6410,9 @@ do_poplevel ()\n    tsubst_expr.  */\n \n tree\n-tsubst_copy (t, args, in_decl)\n+tsubst_copy (t, args, complain, in_decl)\n      tree t, args;\n+     int complain;\n      tree in_decl;\n {\n   enum tree_code code;\n@@ -6218,7 +6448,7 @@ tsubst_copy (t, args, in_decl)\n \t When we instantiate f<7>::S::g(), say, lookup_name is not\n \t clever enough to find f<7>::a.  */\n \tenum_type \n-\t  = tsubst_aggr_type (TREE_TYPE (t), args, in_decl, \n+\t  = tsubst_aggr_type (TREE_TYPE (t), args, complain, in_decl, \n \t\t\t      /*entering_scope=*/0);\n \n \tfor (v = TYPE_VALUES (enum_type); \n@@ -6239,7 +6469,7 @@ tsubst_copy (t, args, in_decl)\n \t{\n \t  tree ctx;\n \n-\t  ctx = tsubst_aggr_type (DECL_CONTEXT (t), args, in_decl,\n+\t  ctx = tsubst_aggr_type (DECL_CONTEXT (t), args, complain, in_decl,\n \t\t\t\t  /*entering_scope=*/1);\n \t  if (ctx != DECL_CONTEXT (t))\n \t    return lookup_field (ctx, DECL_NAME (t), 0, 0);\n@@ -6249,13 +6479,13 @@ tsubst_copy (t, args, in_decl)\n     case VAR_DECL:\n     case FUNCTION_DECL:\n       if (DECL_LANG_SPECIFIC (t) && DECL_TEMPLATE_INFO (t))\n-\tt = tsubst (t, args, in_decl);\n+\tt = tsubst (t, args, complain, in_decl);\n       mark_used (t);\n       return t;\n \n     case TEMPLATE_DECL:\n       if (is_member_template (t))\n-\treturn tsubst (t, args, in_decl);\n+\treturn tsubst (t, args, complain, in_decl);\n       else\n \treturn t;\n \n@@ -6266,7 +6496,7 @@ tsubst_copy (t, args, in_decl)\n \t   name will change.  We avoid making unnecessary copies,\n \t   however.  */\n \t\n-\ttree id = tsubst_copy (TREE_OPERAND (t, 0), args, in_decl);\n+\ttree id = tsubst_copy (TREE_OPERAND (t, 0), args, complain, in_decl);\n \n \tif (id != TREE_OPERAND (t, 0))\n \t  {\n@@ -6285,8 +6515,8 @@ tsubst_copy (t, args, in_decl)\n     case DYNAMIC_CAST_EXPR:\n     case NOP_EXPR:\n       return build1\n-\t(code, tsubst (TREE_TYPE (t), args, in_decl),\n-\t tsubst_copy (TREE_OPERAND (t, 0), args, in_decl));\n+\t(code, tsubst (TREE_TYPE (t), args, complain, in_decl),\n+\t tsubst_copy (TREE_OPERAND (t, 0), args, complain, in_decl));\n \n     case INDIRECT_REF:\n     case PREDECREMENT_EXPR:\n@@ -6305,7 +6535,7 @@ tsubst_copy (t, args, in_decl)\n     case TYPEID_EXPR:\n       return build1\n \t(code, NULL_TREE,\n-\t tsubst_copy (TREE_OPERAND (t, 0), args, in_decl));\n+\t tsubst_copy (TREE_OPERAND (t, 0), args, complain, in_decl));\n \n     case PLUS_EXPR:\n     case MINUS_EXPR:\n@@ -6344,19 +6574,20 @@ tsubst_copy (t, args, in_decl)\n     case DOTSTAR_EXPR:\n     case MEMBER_REF:\n       return build_nt\n-\t(code, tsubst_copy (TREE_OPERAND (t, 0), args, in_decl),\n-\t tsubst_copy (TREE_OPERAND (t, 1), args, in_decl));\n+\t(code, tsubst_copy (TREE_OPERAND (t, 0), args, complain, in_decl),\n+\t tsubst_copy (TREE_OPERAND (t, 1), args, complain, in_decl));\n \n     case CALL_EXPR:\n       {\n \ttree fn = TREE_OPERAND (t, 0);\n \tif (is_overloaded_fn (fn))\n-\t  fn = tsubst_copy (get_first_fn (fn), args, in_decl);\n+\t  fn = tsubst_copy (get_first_fn (fn), args, complain, in_decl);\n \telse\n \t  /* Sometimes FN is a LOOKUP_EXPR.  */\n-\t  fn = tsubst_copy (fn, args, in_decl);\n+\t  fn = tsubst_copy (fn, args, complain, in_decl);\n \treturn build_nt\n-\t  (code, fn, tsubst_copy (TREE_OPERAND (t, 1), args, in_decl),\n+\t  (code, fn, tsubst_copy (TREE_OPERAND (t, 1), args, complain,\n+\t\t\t\t  in_decl),\n \t   NULL_TREE);\n       }\n \n@@ -6365,23 +6596,27 @@ tsubst_copy (t, args, in_decl)\n \ttree name = TREE_OPERAND (t, 0);\n \tif (TREE_CODE (name) == BIT_NOT_EXPR)\n \t  {\n-\t    name = tsubst_copy (TREE_OPERAND (name, 0), args, in_decl);\n+\t    name = tsubst_copy (TREE_OPERAND (name, 0), args,\n+\t\t\t\tcomplain, in_decl);\n \t    name = build1 (BIT_NOT_EXPR, NULL_TREE, name);\n \t  }\n \telse if (TREE_CODE (name) == SCOPE_REF\n \t\t && TREE_CODE (TREE_OPERAND (name, 1)) == BIT_NOT_EXPR)\n \t  {\n-\t    tree base = tsubst_copy (TREE_OPERAND (name, 0), args, in_decl);\n+\t    tree base = tsubst_copy (TREE_OPERAND (name, 0), args,\n+\t\t\t\t     complain, in_decl);\n \t    name = TREE_OPERAND (name, 1);\n-\t    name = tsubst_copy (TREE_OPERAND (name, 0), args, in_decl);\n+\t    name = tsubst_copy (TREE_OPERAND (name, 0), args,\n+\t\t\t\tcomplain, in_decl);\n \t    name = build1 (BIT_NOT_EXPR, NULL_TREE, name);\n \t    name = build_nt (SCOPE_REF, base, name);\n \t  }\n \telse\n-\t  name = tsubst_copy (TREE_OPERAND (t, 0), args, in_decl);\n+\t  name = tsubst_copy (TREE_OPERAND (t, 0), args, complain, in_decl);\n \treturn build_nt\n-\t  (code, name, tsubst_copy (TREE_OPERAND (t, 1), args, in_decl),\n-\t   tsubst_copy (TREE_OPERAND (t, 2), args, in_decl),\n+\t  (code, name, tsubst_copy (TREE_OPERAND (t, 1), args,\n+\t\t\t\t    complain, in_decl),\n+\t   tsubst_copy (TREE_OPERAND (t, 2), args, complain, in_decl),\n \t   NULL_TREE);\n       }\n \n@@ -6390,9 +6625,9 @@ tsubst_copy (t, args, in_decl)\n     case MODOP_EXPR:\n       {\n \tr = build_nt\n-\t  (code, tsubst_copy (TREE_OPERAND (t, 0), args, in_decl),\n-\t   tsubst_copy (TREE_OPERAND (t, 1), args, in_decl),\n-\t   tsubst_copy (TREE_OPERAND (t, 2), args, in_decl));\n+\t  (code, tsubst_copy (TREE_OPERAND (t, 0), args, complain, in_decl),\n+\t   tsubst_copy (TREE_OPERAND (t, 1), args, complain, in_decl),\n+\t   tsubst_copy (TREE_OPERAND (t, 2), args, complain, in_decl));\n \n \tif (code == BIND_EXPR && !processing_template_decl)\n \t  {\n@@ -6403,7 +6638,8 @@ tsubst_copy (t, args, in_decl)\n \t       build_expr_from_tree.  So, we need to expand the\n \t       BIND_EXPR here.  */ \n \t    tree rtl_expr = begin_stmt_expr ();\n-\t    tree block = tsubst_expr (TREE_OPERAND (r, 1), args, in_decl);\n+\t    tree block = tsubst_expr (TREE_OPERAND (r, 1), args,\n+\t\t\t\t      complain, in_decl);\n \t    r = finish_stmt_expr (rtl_expr, block);\n \t  }\n \n@@ -6413,18 +6649,18 @@ tsubst_copy (t, args, in_decl)\n     case NEW_EXPR:\n       {\n \tr = build_nt\n-\t(code, tsubst_copy (TREE_OPERAND (t, 0), args, in_decl),\n-\t tsubst_copy (TREE_OPERAND (t, 1), args, in_decl),\n-\t tsubst_copy (TREE_OPERAND (t, 2), args, in_decl));\n+\t(code, tsubst_copy (TREE_OPERAND (t, 0), args, complain, in_decl),\n+\t tsubst_copy (TREE_OPERAND (t, 1), args, complain, in_decl),\n+\t tsubst_copy (TREE_OPERAND (t, 2), args, complain, in_decl));\n \tNEW_EXPR_USE_GLOBAL (r) = NEW_EXPR_USE_GLOBAL (t);\n \treturn r;\n       }\n \n     case DELETE_EXPR:\n       {\n \tr = build_nt\n-\t(code, tsubst_copy (TREE_OPERAND (t, 0), args, in_decl),\n-\t tsubst_copy (TREE_OPERAND (t, 1), args, in_decl));\n+\t(code, tsubst_copy (TREE_OPERAND (t, 0), args, complain, in_decl),\n+\t tsubst_copy (TREE_OPERAND (t, 1), args, complain, in_decl));\n \tDELETE_EXPR_USE_GLOBAL (r) = DELETE_EXPR_USE_GLOBAL (t);\n \tDELETE_EXPR_USE_VEC (r) = DELETE_EXPR_USE_VEC (t);\n \treturn r;\n@@ -6433,13 +6669,14 @@ tsubst_copy (t, args, in_decl)\n     case TEMPLATE_ID_EXPR:\n       {\n         /* Substituted template arguments */\n-\ttree targs = tsubst_copy (TREE_OPERAND (t, 1), args, in_decl);\n+\ttree targs = tsubst_copy (TREE_OPERAND (t, 1), args, complain,\n+\t\t\t\t  in_decl);\n \ttree chain;\n \tfor (chain = targs; chain; chain = TREE_CHAIN (chain))\n \t  TREE_VALUE (chain) = maybe_fold_nontype_arg (TREE_VALUE (chain));\n \n \treturn lookup_template_function\n-\t  (tsubst_copy (TREE_OPERAND (t, 0), args, in_decl), targs);\n+\t  (tsubst_copy (TREE_OPERAND (t, 0), args, complain, in_decl), targs);\n       }\n \n     case TREE_LIST:\n@@ -6451,13 +6688,13 @@ tsubst_copy (t, args, in_decl)\n \n \tpurpose = TREE_PURPOSE (t);\n \tif (purpose)\n-\t  purpose = tsubst_copy (purpose, args, in_decl);\n+\t  purpose = tsubst_copy (purpose, args, complain, in_decl);\n \tvalue = TREE_VALUE (t);\n \tif (value)\n-\t  value = tsubst_copy (value, args, in_decl);\n+\t  value = tsubst_copy (value, args, complain, in_decl);\n \tchain = TREE_CHAIN (t);\n \tif (chain && chain != void_type_node)\n-\t  chain = tsubst_copy (chain, args, in_decl);\n+\t  chain = tsubst_copy (chain, args, complain, in_decl);\n \tif (purpose == TREE_PURPOSE (t)\n \t    && value == TREE_VALUE (t)\n \t    && chain == TREE_CHAIN (t))\n@@ -6480,23 +6717,24 @@ tsubst_copy (t, args, in_decl)\n     case ARRAY_TYPE:\n     case TYPENAME_TYPE:\n     case TYPE_DECL:\n-      return tsubst (t, args, in_decl);\n+      return tsubst (t, args, complain, in_decl);\n \n     case IDENTIFIER_NODE:\n       if (IDENTIFIER_TYPENAME_P (t)\n \t  /* Make sure it's not just a variable named `__opr', for instance,\n \t     which can occur in some existing code.  */\n \t  && TREE_TYPE (t))\n \treturn build_typename_overload\n-\t  (tsubst (TREE_TYPE (t), args, in_decl));\n+\t  (tsubst (TREE_TYPE (t), args, complain, in_decl));\n       else\n \treturn t;\n \n     case CONSTRUCTOR:\n       {\n \tr = build\n-\t  (CONSTRUCTOR, tsubst (TREE_TYPE (t), args, in_decl), NULL_TREE,\n-\t   tsubst_copy (CONSTRUCTOR_ELTS (t), args, in_decl));\n+\t  (CONSTRUCTOR, tsubst (TREE_TYPE (t), args, complain, in_decl), \n+\t   NULL_TREE, tsubst_copy (CONSTRUCTOR_ELTS (t), args,\n+\t\t\t\t   complain, in_decl));\n \tTREE_HAS_CONSTRUCTOR (r) = TREE_HAS_CONSTRUCTOR (t);\n \treturn r;\n       }\n@@ -6509,28 +6747,29 @@ tsubst_copy (t, args, in_decl)\n /* Like tsubst_copy, but also does semantic processing and RTL expansion.  */\n \n tree\n-tsubst_expr (t, args, in_decl)\n+tsubst_expr (t, args, complain, in_decl)\n      tree t, args;\n+     int complain;\n      tree in_decl;\n {\n   if (t == NULL_TREE || t == error_mark_node)\n     return t;\n \n   if (processing_template_decl)\n-    return tsubst_copy (t, args, in_decl);\n+    return tsubst_copy (t, args, complain, in_decl);\n \n   switch (TREE_CODE (t))\n     {\n     case RETURN_STMT:\n       lineno = TREE_COMPLEXITY (t);\n       finish_return_stmt (tsubst_expr (RETURN_EXPR (t),\n-\t\t\t\t       args, in_decl));\n+\t\t\t\t       args, complain, in_decl));\n       break;\n \n     case EXPR_STMT:\n       lineno = TREE_COMPLEXITY (t);\n       finish_expr_stmt (tsubst_expr (EXPR_STMT_EXPR (t),\n-\t\t\t\t     args, in_decl));\n+\t\t\t\t     args, complain, in_decl));\n       break;\n \n     case DECL_STMT:\n@@ -6541,10 +6780,10 @@ tsubst_expr (t, args, in_decl)\n \tlineno = TREE_COMPLEXITY (t);\n \temit_line_note (input_filename, lineno);\n \tdcl = start_decl\n-\t  (tsubst (TREE_OPERAND (t, 0), args, in_decl),\n-\t   tsubst (TREE_OPERAND (t, 1), args, in_decl),\n+\t  (tsubst (TREE_OPERAND (t, 0), args, complain, in_decl),\n+\t   tsubst (TREE_OPERAND (t, 1), args, complain, in_decl),\n \t   TREE_OPERAND (t, 2) != 0, NULL_TREE, NULL_TREE);\n-\tinit = tsubst_expr (TREE_OPERAND (t, 2), args, in_decl);\n+\tinit = tsubst_expr (TREE_OPERAND (t, 2), args, complain, in_decl);\n \tcp_finish_decl\n \t  (dcl, init, NULL_TREE, 1, /*init ? LOOKUP_ONLYCONVERTING :*/ 0);\n \tresume_momentary (i);\n@@ -6558,14 +6797,14 @@ tsubst_expr (t, args, in_decl)\n \n \tbegin_for_stmt ();\n \tfor (tmp = FOR_INIT_STMT (t); tmp; tmp = TREE_CHAIN (tmp))\n-\t  tsubst_expr (tmp, args, in_decl);\n+\t  tsubst_expr (tmp, args, complain, in_decl);\n \tfinish_for_init_stmt (NULL_TREE);\n \tfinish_for_cond (tsubst_expr (FOR_COND (t), args,\n-\t\t\t\t      in_decl),\n+\t\t\t\t      complain, in_decl),\n \t\t\t NULL_TREE);\n-\ttmp = tsubst_expr (FOR_EXPR (t), args, in_decl);\n+\ttmp = tsubst_expr (FOR_EXPR (t), args, complain, in_decl);\n \tfinish_for_expr (tmp, NULL_TREE);\n-\ttsubst_expr (FOR_BODY (t), args, in_decl);\n+\ttsubst_expr (FOR_BODY (t), args, complain, in_decl);\n \tfinish_for_stmt (tmp, NULL_TREE);\n       }\n       break;\n@@ -6575,9 +6814,9 @@ tsubst_expr (t, args, in_decl)\n \tlineno = TREE_COMPLEXITY (t);\n \tbegin_while_stmt ();\n \tfinish_while_stmt_cond (tsubst_expr (WHILE_COND (t),\n-\t\t\t\t\t     args, in_decl),\n+\t\t\t\t\t     args, complain, in_decl),\n \t\t\t\tNULL_TREE);\n-\ttsubst_expr (WHILE_BODY (t), args, in_decl);\n+\ttsubst_expr (WHILE_BODY (t), args, complain, in_decl);\n \tfinish_while_stmt (NULL_TREE);\n       }\n       break;\n@@ -6586,10 +6825,10 @@ tsubst_expr (t, args, in_decl)\n       {\n \tlineno = TREE_COMPLEXITY (t);\n \tbegin_do_stmt ();\n-\ttsubst_expr (DO_BODY (t), args, in_decl);\n+\ttsubst_expr (DO_BODY (t), args, complain, in_decl);\n \tfinish_do_body (NULL_TREE);\n \tfinish_do_stmt (tsubst_expr (DO_COND (t), args,\n-\t\t\t\t     in_decl),\n+\t\t\t\t     complain, in_decl),\n \t\t\tNULL_TREE);\n       }\n       break;\n@@ -6601,19 +6840,19 @@ tsubst_expr (t, args, in_decl)\n \tlineno = TREE_COMPLEXITY (t);\n \tbegin_if_stmt ();\n \tfinish_if_stmt_cond (tsubst_expr (IF_COND (t),\n-\t\t\t\t\t  args, in_decl),\n+\t\t\t\t\t  args, complain, in_decl),\n \t\t\t     NULL_TREE);\n \n \tif (tmp = THEN_CLAUSE (t), tmp)\n \t  {\n-\t    tsubst_expr (tmp, args, in_decl);\n+\t    tsubst_expr (tmp, args, complain, in_decl);\n \t    finish_then_clause (NULL_TREE);\n \t  }\n \n \tif (tmp = ELSE_CLAUSE (t), tmp)\n \t  {\n \t    begin_else_clause ();\n-\t    tsubst_expr (tmp, args, in_decl);\n+\t    tsubst_expr (tmp, args, complain, in_decl);\n \t    finish_else_clause (NULL_TREE);\n \t  }\n \n@@ -6630,7 +6869,7 @@ tsubst_expr (t, args, in_decl)\n \tfor (substmt = COMPOUND_BODY (t); \n \t     substmt != NULL_TREE;\n \t     substmt = TREE_CHAIN (substmt))\n-\t  tsubst_expr (substmt, args, in_decl);\n+\t  tsubst_expr (substmt, args, complain, in_decl);\n \treturn finish_compound_stmt (COMPOUND_STMT_NO_SCOPE (t), \n \t\t\t\t     NULL_TREE);\n       }\n@@ -6652,19 +6891,19 @@ tsubst_expr (t, args, in_decl)\n \n \tlineno = TREE_COMPLEXITY (t);\n \tbegin_switch_stmt ();\n-\tval = tsubst_expr (SWITCH_COND (t), args, in_decl);\n+\tval = tsubst_expr (SWITCH_COND (t), args, complain, in_decl);\n \tfinish_switch_cond (val);\n \t\n \tif (tmp = TREE_OPERAND (t, 1), tmp)\n-\t  tsubst_expr (tmp, args, in_decl);\n+\t  tsubst_expr (tmp, args, complain, in_decl);\n \n \tfinish_switch_stmt (val, NULL_TREE);\n       }\n       break;\n \n     case CASE_LABEL:\n-      finish_case_label (tsubst_expr (CASE_LOW (t), args, in_decl),\n-\t\t\t tsubst_expr (CASE_HIGH (t), args, in_decl));\n+      finish_case_label (tsubst_expr (CASE_LOW (t), args, complain, in_decl),\n+\t\t\t tsubst_expr (CASE_HIGH (t), args, complain, in_decl));\n       break;\n \n     case LABEL_DECL:\n@@ -6681,28 +6920,29 @@ tsubst_expr (t, args, in_decl)\n \t/* Computed goto's must be tsubst'd into.  On the other hand,\n \t   non-computed gotos must not be; the identifier in question\n \t   will have no binding.  */\n-\tt = tsubst_expr (t, args, in_decl);\n+\tt = tsubst_expr (t, args, complain, in_decl);\n       finish_goto_stmt (t);\n       break;\n \n     case ASM_STMT:\n       lineno = TREE_COMPLEXITY (t);\n-      finish_asm_stmt (tsubst_expr (ASM_CV_QUAL (t), args, in_decl),\n-\t\t       tsubst_expr (ASM_STRING (t), args, in_decl),\n-\t\t       tsubst_expr (ASM_OUTPUTS (t), args, in_decl),\n-\t\t       tsubst_expr (ASM_INPUTS (t), args, in_decl), \n-\t\t       tsubst_expr (ASM_CLOBBERS (t), args, in_decl));\n+      finish_asm_stmt (tsubst_expr (ASM_CV_QUAL (t), args, complain, in_decl),\n+\t\t       tsubst_expr (ASM_STRING (t), args, complain, in_decl),\n+\t\t       tsubst_expr (ASM_OUTPUTS (t), args, complain, in_decl),\n+\t\t       tsubst_expr (ASM_INPUTS (t), args, complain, in_decl), \n+\t\t       tsubst_expr (ASM_CLOBBERS (t), args, complain,\n+\t\t\t\t    in_decl));\n       break;\n \n     case TRY_BLOCK:\n       lineno = TREE_COMPLEXITY (t);\n       begin_try_block ();\n-      tsubst_expr (TRY_STMTS (t), args, in_decl);\n+      tsubst_expr (TRY_STMTS (t), args, complain, in_decl);\n       finish_try_block (NULL_TREE);\n       {\n \ttree handler = TRY_HANDLERS (t);\n \tfor (; handler; handler = TREE_CHAIN (handler))\n-\t  tsubst_expr (handler, args, in_decl);\n+\t  tsubst_expr (handler, args, complain, in_decl);\n       }\n       finish_handler_sequence (NULL_TREE);\n       break;\n@@ -6714,25 +6954,25 @@ tsubst_expr (t, args, in_decl)\n \t{\n \t  tree d = HANDLER_PARMS (t);\n \t  expand_start_catch_block\n-\t    (tsubst (TREE_OPERAND (d, 1), args, in_decl),\n-\t     tsubst (TREE_OPERAND (d, 0), args, in_decl));\n+\t    (tsubst (TREE_OPERAND (d, 1), args, complain, in_decl),\n+\t     tsubst (TREE_OPERAND (d, 0), args, complain, in_decl));\n \t}\n       else\n \texpand_start_catch_block (NULL_TREE, NULL_TREE);\n       finish_handler_parms (NULL_TREE);\n-      tsubst_expr (HANDLER_BODY (t), args, in_decl);\n+      tsubst_expr (HANDLER_BODY (t), args, complain, in_decl);\n       finish_handler (NULL_TREE);\n       break;\n \n     case TAG_DEFN:\n       lineno = TREE_COMPLEXITY (t);\n       t = TREE_TYPE (t);\n       if (TREE_CODE (t) == ENUMERAL_TYPE)\n-\ttsubst (t, args, NULL_TREE);\n+\ttsubst (t, args, complain, NULL_TREE);\n       break;\n \n     default:\n-      return build_expr_from_tree (tsubst_copy (t, args, in_decl));\n+      return build_expr_from_tree (tsubst_copy (t, args, complain, in_decl));\n     }\n   return NULL_TREE;\n }\n@@ -6804,7 +7044,7 @@ instantiate_template (tmpl, targ_ptr)\n   targ_ptr = copy_to_permanent (targ_ptr);\n \n   /* substitute template parameters */\n-  fndecl = tsubst (DECL_RESULT (gen_tmpl), targ_ptr, gen_tmpl);\n+  fndecl = tsubst (DECL_RESULT (gen_tmpl), targ_ptr, /*complain=*/1, gen_tmpl);\n   /* The DECL_TI_TEMPLATE should always be the immediate parent\n      template, not the most general template.  */\n   DECL_TI_TEMPLATE (fndecl) = tmpl;\n@@ -6837,76 +7077,18 @@ overload_template_name (type)\n   pushdecl_class_level (decl);\n }\n \n-/* Like type_unification but designed specially to handle conversion\n-   operators.  \n-\n-   The FN is a TEMPLATE_DECL for a function.  The ARGS are the\n-   arguments that are being used when calling it.  \n-\n-   If FN is a conversion operator, RETURN_TYPE is the type desired as\n-   the result of the conversion operator.\n-\n-   The EXTRA_FN_ARG, if any, is the type of an additional\n-   parameter to be added to the beginning of FN's parameter list.  \n-\n-   The other arguments are as for type_unification.  */\n-\n-int\n-fn_type_unification (fn, explicit_targs, targs, args, return_type,\n-\t\t     strict, extra_fn_arg)\n-     tree fn, explicit_targs, targs, args, return_type;\n-     unification_kind_t strict;\n-     tree extra_fn_arg;\n-{\n-  tree parms;\n-\n-  my_friendly_assert (TREE_CODE (fn) == TEMPLATE_DECL, 0);\n-\n-  parms = TYPE_ARG_TYPES (TREE_TYPE (fn));\n-\n-  if (DECL_CONV_FN_P (fn))\n-    {\n-      /* This is a template conversion operator.  Use the return types\n-         as well as the argument types.  */\n-      parms = scratch_tree_cons (NULL_TREE, \n-\t\t\t\t TREE_TYPE (TREE_TYPE (fn)),\n-\t\t\t\t parms);\n-      args = scratch_tree_cons (NULL_TREE, return_type, args);\n-    }\n-\n-  if (extra_fn_arg != NULL_TREE)\n-    parms = scratch_tree_cons (NULL_TREE, extra_fn_arg, parms);\n-\n-  /* We allow incomplete unification without an error message here\n-     because the standard doesn't seem to explicitly prohibit it.  Our\n-     callers must be ready to deal with unification failures in any\n-     event.  */\n-  return type_unification (DECL_INNERMOST_TEMPLATE_PARMS (fn), \n-\t\t\t   targs,\n-\t\t\t   parms,\n-\t\t\t   args,\n-\t\t\t   explicit_targs,\n-\t\t\t   strict, 1);\n-}\n-\n-\n-/* Type unification.\n-\n-   We have a function template signature with one or more references to\n-   template parameters, and a parameter list we wish to fit to this\n-   template.  If possible, produce a list of parameters for the template\n-   which will cause it to fit the supplied parameter list.\n+/* The FN is a TEMPLATE_DECL for a function.  The ARGS are the\n+   arguments that are being used when calling it.  TARGS is a vector\n+   into which the deduced template arguments are placed.  \n \n    Return zero for success, 2 for an incomplete match that doesn't resolve\n    all the types, and 1 for complete failure.  An error message will be\n    printed only for an incomplete match.\n \n-   TPARMS[NTPARMS] is an array of template parameter types.\n+   If FN is a conversion operator, RETURN_TYPE is the type desired as\n+   the result of the conversion operator.\n \n-   TARGS[NTPARMS] is the array into which the deduced template\n-   parameter values are placed.  PARMS is the function template's\n-   signature (using TEMPLATE_PARM_IDX nodes), and ARGS is the argument\n-   list we're trying to match against it.\n+   TPARMS is a vector of template parameters.\n \n    The EXPLICIT_TARGS are explicit template arguments provided via a\n    template-id.\n@@ -6928,49 +7110,90 @@ fn_type_unification (fn, explicit_targs, targs, args, return_type,\n      when doing an explicit instantiation as in [temp.explicit],\n      when determining an explicit specialization as in\n      [temp.expl.spec], or when taking the address of a function\n-     template, as in [temp.deduct.funcaddr].  */\n+     template, as in [temp.deduct.funcaddr]. \n+\n+   The EXTRA_FN_ARG, if any, is the type of an additional\n+   parameter to be added to the beginning of FN's parameter list.  \n+\n+   The other arguments are as for type_unification.  */\n \n int\n-type_unification (tparms, targs, parms, args, explicit_targs,\n-\t\t  strict, allow_incomplete)\n-     tree tparms, targs, parms, args, explicit_targs;\n+fn_type_unification (fn, explicit_targs, targs, args, return_type,\n+\t\t     strict, extra_fn_arg)\n+     tree fn, explicit_targs, targs, args, return_type;\n      unification_kind_t strict;\n-     int allow_incomplete;\n+     tree extra_fn_arg;\n {\n-  int* explicit_mask;\n-  int i;\n-\n-  for (i = 0; i < TREE_VEC_LENGTH (tparms); i++)\n-    TREE_VEC_ELT (targs, i) = NULL_TREE;\n+  tree parms;\n+  tree fntype;\n \n-  if (explicit_targs != NULL_TREE)\n+  my_friendly_assert (TREE_CODE (fn) == TEMPLATE_DECL, 0);\n+  \n+  fntype = TREE_TYPE (fn);\n+  if (explicit_targs)\n     {\n-      tree arg_vec;\n-      arg_vec = coerce_template_parms (tparms, explicit_targs, NULL_TREE, 0,\n-\t\t\t\t       0);\n+      /* [temp.deduct]\n+\t  \n+\t The specified template arguments must match the template\n+\t parameters in kind (i.e., type, nontype, template), and there\n+\t must not be more arguments than there are parameters;\n+\t otherwise type deduction fails.\n+\n+\t Nontype arguments must match the types of the corresponding\n+\t nontype template parameters, or must be convertible to the\n+\t types of the corresponding nontype parameters as specified in\n+\t _temp.arg.nontype_, otherwise type deduction fails.\n+\n+\t All references in the function type of the function template\n+\t to the corresponding template parameters are replaced by the\n+\t specified template argument values.  If a substitution in a\n+\t template parameter or in the function type of the function\n+\t template results in an invalid type, type deduction fails.  */\n+      int i;\n+      tree converted_args;\n \n-      if (arg_vec == error_mark_node)\n+      converted_args\n+\t= (coerce_template_parms (DECL_INNERMOST_TEMPLATE_PARMS (fn), \n+\t\t\t\t  explicit_targs, NULL_TREE, /*complain=*/0, \n+\t\t\t\t  /*require_all_arguments=*/0));\n+      if (converted_args == error_mark_node)\n \treturn 1;\n \n-      explicit_mask = alloca (sizeof (int) * TREE_VEC_LENGTH (targs));\n-      bzero ((char *) explicit_mask, sizeof(int) * TREE_VEC_LENGTH (targs));\n+      fntype = tsubst (fntype, converted_args, /*complain=*/0, NULL_TREE);\n+      if (fntype == error_mark_node)\n+\treturn 1;\n \n-      for (i = 0; \n-\t   i < TREE_VEC_LENGTH (arg_vec) \n-\t     && TREE_VEC_ELT (arg_vec, i) != NULL_TREE;  \n-\t   ++i)\n-\t{\n-\t  TREE_VEC_ELT (targs, i) = TREE_VEC_ELT (arg_vec, i);\n-\t  /* Let unify know that this argument was explicit.  */\n-\t  explicit_mask [i] = 1;\n-\t}\n+      extra_fn_arg = tsubst (extra_fn_arg, converted_args,\n+\t\t\t     /*complain=*/0, NULL_TREE);\n+      if (extra_fn_arg == error_mark_node)\n+\treturn 1;\n+\n+      /* Place the explicitly specified arguments in TARGS.  */\n+      for (i = 0; i < TREE_VEC_LENGTH (targs); i++)\n+\tTREE_VEC_ELT (targs, i) = TREE_VEC_ELT (converted_args, i);\n     }\n-  else\n-    explicit_mask = 0;\n+     \n+  parms = TYPE_ARG_TYPES (fntype);\n \n-  return \n-    type_unification_real (tparms, targs, parms, args, 0,\n-\t\t\t   strict, allow_incomplete, explicit_mask); \n+  if (DECL_CONV_FN_P (fn))\n+    {\n+      /* This is a template conversion operator.  Use the return types\n+         as well as the argument types.  */\n+      parms = scratch_tree_cons (NULL_TREE, TREE_TYPE (fntype),\n+\t\t\t\t parms);\n+      args = scratch_tree_cons (NULL_TREE, return_type, args);\n+    }\n+\n+  if (extra_fn_arg != NULL_TREE)\n+    parms = scratch_tree_cons (NULL_TREE, extra_fn_arg, parms);\n+\n+  /* We allow incomplete unification without an error message here\n+     because the standard doesn't seem to explicitly prohibit it.  Our\n+     callers must be ready to deal with unification failures in any\n+     event.  */\n+  return type_unification_real (DECL_INNERMOST_TEMPLATE_PARMS (fn), \n+\t\t\t\ttargs, parms, args, /*subr=*/0,\n+\t\t\t\tstrict, /*allow_incomplete*/1);\n }\n \n /* Adjust types before performing type deduction, as described in\n@@ -7047,22 +7270,19 @@ maybe_adjust_types_for_deduction (strict, parm, arg)\n     *parm = TREE_TYPE (*parm);\n }\n \n-/* Like type_unfication.  EXPLICIT_MASK, if non-NULL, is an array of\n-   integers, with ones in positions corresponding to arguments in\n-   targs that were provided explicitly, and zeros elsewhere.  \n+/* Like type_unfication.\n \n    If SUBR is 1, we're being called recursively (to unify the\n    arguments of a function or method parameter of a function\n    template).  */\n \n static int\n type_unification_real (tparms, targs, parms, args, subr,\n-\t\t       strict, allow_incomplete, explicit_mask)\n+\t\t       strict, allow_incomplete)\n      tree tparms, targs, parms, args;\n      int subr;\n      unification_kind_t strict;\n      int allow_incomplete;\n-     int* explicit_mask;\n {\n   tree parm, arg;\n   int i;\n@@ -7143,12 +7363,6 @@ type_unification_real (tparms, targs, parms, args, subr,\n \t  return 1;\n \t}\n \t\n-#if 0\n-      if (TREE_CODE (arg) == VAR_DECL)\n-\targ = TREE_TYPE (arg);\n-      else if (TREE_CODE_CLASS (TREE_CODE (arg)) == 'e')\n-\targ = TREE_TYPE (arg);\n-#else\n       if (TREE_CODE_CLASS (TREE_CODE (arg)) != 't')\n \t{\n \t  my_friendly_assert (TREE_TYPE (arg) != NULL_TREE, 293);\n@@ -7161,19 +7375,18 @@ type_unification_real (tparms, targs, parms, args, subr,\n \t\t overloaded functions provides a unique match.  */\n \n \t      if (resolve_overloaded_unification\n-\t\t  (tparms, targs, parm, arg, strict, sub_strict, explicit_mask)\n+\t\t  (tparms, targs, parm, arg, strict, sub_strict)\n \t\t  != 0)\n \t\treturn 1;\n \t      continue;\n \t    }\n \t  arg = TREE_TYPE (arg);\n \t}\n-#endif\n+\n       if (!subr)\n \tmaybe_adjust_types_for_deduction (strict, &parm, &arg);\n \n-      switch (unify (tparms, targs, parm, arg, sub_strict,\n-\t\t     explicit_mask)) \n+      switch (unify (tparms, targs, parm, arg, sub_strict))\n \t{\n \tcase 0:\n \t  break;\n@@ -7208,11 +7421,10 @@ type_unification_real (tparms, targs, parms, args, subr,\n \n static int\n resolve_overloaded_unification (tparms, targs, parm, arg, strict,\n-\t\t\t\tsub_strict, explicit_mask)\n+\t\t\t\tsub_strict)\n      tree tparms, targs, parm, arg;\n      unification_kind_t strict;\n      int sub_strict;\n-     int* explicit_mask;\n {\n   tree tempargs = copy_node (targs);\n   int good = 0;\n@@ -7249,11 +7461,12 @@ resolve_overloaded_unification (tparms, targs, parm, arg, strict,\n \t  subargs = get_bindings_overload (fn, DECL_RESULT (fn), expl_subargs);\n \t  if (subargs)\n \t    {\n-\t      elem = tsubst (TREE_TYPE (fn), subargs, NULL_TREE);\n+\t      elem = tsubst (TREE_TYPE (fn), subargs, /*complain=*/0,\n+\t\t\t     NULL_TREE);\n \t      if (TREE_CODE (elem) == METHOD_TYPE)\n \t\telem = build_ptrmemfunc_type (build_pointer_type (elem));\n \t      good += try_one_overload (tparms, targs, tempargs, parm, elem,\n-\t\t\t\t\tstrict, sub_strict, explicit_mask);\n+\t\t\t\t\tstrict, sub_strict);\n \t    }\n \t}\n     }\n@@ -7266,7 +7479,7 @@ resolve_overloaded_unification (tparms, targs, parm, arg, strict,\n \t    type = build_ptrmemfunc_type (build_pointer_type (type));\n \t  good += try_one_overload (tparms, targs, tempargs, parm,\n \t\t\t\t    type,\n-\t\t\t\t    strict, sub_strict, explicit_mask);\n+\t\t\t\t    strict, sub_strict);\n \t}\n     }\n   else\n@@ -7300,11 +7513,10 @@ resolve_overloaded_unification (tparms, targs, parm, arg, strict,\n \n static int\n try_one_overload (tparms, orig_targs, targs, parm, arg, strict,\n-\t\t  sub_strict, explicit_mask)\n+\t\t  sub_strict)\n      tree tparms, orig_targs, targs, parm, arg;\n      unification_kind_t strict;\n      int sub_strict;\n-     int* explicit_mask;\n {\n   int nargs;\n   tree tempargs;\n@@ -7329,7 +7541,7 @@ try_one_overload (tparms, orig_targs, targs, parm, arg, strict,\n   nargs = TREE_VEC_LENGTH (targs);\n   tempargs = make_scratch_vec (nargs);\n \n-  if (unify (tparms, tempargs, parm, arg, sub_strict, explicit_mask) != 0)\n+  if (unify (tparms, tempargs, parm, arg, sub_strict) != 0)\n     return 0;\n \n   /* First make sure we didn't deduce anything that conflicts with\n@@ -7364,107 +7576,169 @@ try_one_overload (tparms, orig_targs, targs, parm, arg, strict,\n   return 1;\n }\n \n-/* Subroutine of get_template_base.  */\n+/* PARM is a template class (perhaps with unbound template\n+   parameters).  ARG is a fully instantiated type.  If ARG can be\n+   bound to PARM, return ARG, otherwise return NULL_TREE.  TPARMS and\n+   TARGS are as for unify.  */\n \n static tree\n-get_template_base_recursive (tparms, targs,\n-\t\t\t     binfo, rval, template,\n-\t\t\t     via_virtual)\n+try_class_unification (tparms, targs, parm, arg)\n      tree tparms;\n      tree targs;\n-     tree binfo;\n+     tree parm;\n+     tree arg;\n+{\n+  int i;\n+  tree copy_of_targs;\n+\n+  if (!CLASSTYPE_TEMPLATE_INFO (arg)\n+      || CLASSTYPE_TI_TEMPLATE (arg) != CLASSTYPE_TI_TEMPLATE (parm))\n+    return NULL_TREE;\n+\n+  /* We need to make a new template argument vector for the call to\n+     unify.  If we used TARGS, we'd clutter it up with the result of\n+     the attempted unification, even if this class didn't work out.\n+     We also don't want to commit ourselves to all the unifications\n+     we've already done, since unification is supposed to be done on\n+     an argument-by-argument basis.  In other words, consider the\n+     following pathological case:\n+\n+       template <int I, int J, int K>\n+       struct S {};\n+       \n+       template <int I, int J>\n+       struct S<I, J, 2> : public S<I, I, I>, S<J, J, J> {};\n+       \n+       template <int I, int J, int K>\n+       void f(S<I, J, K>, S<I, I, I>);\n+       \n+       void g() {\n+         S<0, 0, 0> s0;\n+         S<0, 1, 2> s2;\n+       \n+         f(s0, s2);\n+       }\n+\n+     Now, by the time we consider the unification involving `s2', we\n+     already know that we must have `f<0, 0, 0>'.  But, even though\n+     `S<0, 1, 2>' is derived from `S<0, 0, 0>', the code is not legal\n+     because there are two ways to unify base classes of S<0, 1, 2>\n+     with S<I, I, I>.  If we kept the already deduced knowledge, we\n+     would reject the possibility I=1.  */\n+  push_momentary ();\n+  copy_of_targs = make_temp_vec (TREE_VEC_LENGTH (targs));\n+  i = unify (tparms, copy_of_targs, CLASSTYPE_TI_ARGS (parm),\n+\t     CLASSTYPE_TI_ARGS (arg), UNIFY_ALLOW_NONE);\n+  pop_momentary ();\n+  \n+  /* If unification failed, we're done.  */\n+  if (i != 0)\n+    return NULL_TREE;\n+  else\n+    return arg;\n+}\n+\n+/* Subroutine of get_template_base.  RVAL, if non-NULL, is a base we\n+   have alreay discovered to be satisfactory.  ARG_BINFO is the binfo\n+   for the base class of ARG that we are currently examining.  */\n+\n+static tree\n+get_template_base_recursive (tparms, targs, parm,\n+\t\t\t     arg_binfo, rval, flags)\n+     tree tparms;\n+     tree targs;\n+     tree arg_binfo;\n      tree rval;\n-     tree template;\n-     int via_virtual;\n+     tree parm;\n+     int flags;\n {\n   tree binfos;\n   int i, n_baselinks;\n-  tree type = BINFO_TYPE (binfo);\n-  tree tmpl = CLASSTYPE_TI_TEMPLATE (template);\n+  tree arg = BINFO_TYPE (arg_binfo);\n \n-  if (CLASSTYPE_TEMPLATE_INFO (type)\n-      && CLASSTYPE_TI_TEMPLATE (type) == tmpl)\n+  if (!(flags & GTB_IGNORE_TYPE))\n     {\n-      push_momentary ();\n-      \n-      i = unify (tparms, \n-\t\t /* Use a temporary vector since we're doing\n-\t\t    speculative unification here.  */\n-\t\t make_temp_vec (TREE_VEC_LENGTH (targs)),\n-\t\t CLASSTYPE_TI_ARGS (template),\n-\t\t CLASSTYPE_TI_ARGS (type),\n-\t\t UNIFY_ALLOW_NONE, 0);\n+      tree r = try_class_unification (tparms, targs,\n+\t\t\t\t      parm, arg);\n \n-      pop_momentary ();\n+      /* If there is more than one satisfactory baseclass, then:\n \n-      if (i == 0)\n-\t{\n-\t  if (rval == NULL_TREE || rval == type)\n-\t    return type;\n-\t  else\n-\t    return error_mark_node;\n-\t}\n+\t   [temp.deduct.call]\n+\n+\t   If they yield more than one possible deduced A, the type\n+\t   deduction fails.\n+\n+\t   applies.  */\n+      if (r && rval && !same_type_p (r, rval))\n+\treturn error_mark_node;\n+      else if (r)\n+\trval = r;\n     }\n \n-  binfos = BINFO_BASETYPES (binfo);\n+  binfos = BINFO_BASETYPES (arg_binfo);\n   n_baselinks = binfos ? TREE_VEC_LENGTH (binfos) : 0;\n \n   /* Process base types.  */\n   for (i = 0; i < n_baselinks; i++)\n     {\n       tree base_binfo = TREE_VEC_ELT (binfos, i);\n+      int this_virtual;\n \n-      /* Find any specific instance of a virtual base, when searching with\n-\t a binfo...  */\n-      if (BINFO_MARKED (base_binfo) == 0)\n-\t{\n-\t  int this_virtual = via_virtual || TREE_VIA_VIRTUAL (base_binfo);\n-\n-\t  /* When searching for a non-virtual, we cannot mark\n-\t     virtually found binfos.  */\n-\t  if (! this_virtual)\n-\t    SET_BINFO_MARKED (base_binfo);\n-\n-\t  rval = get_template_base_recursive (tparms, targs,\n-\t\t\t\t\t      base_binfo, rval,\n-\t\t\t\t\t      template, this_virtual);\n-\t  if (rval == error_mark_node)\n-\t    return rval;\n-\t}\n+      /* Skip this base, if we've already seen it.  */\n+      if (BINFO_MARKED (base_binfo))\n+\tcontinue;\n+\n+      this_virtual = \n+\t(flags & GTB_VIA_VIRTUAL) || TREE_VIA_VIRTUAL (base_binfo);\n+      \n+      /* When searching for a non-virtual, we cannot mark virtually\n+\t found binfos.  */\n+      if (! this_virtual)\n+\tSET_BINFO_MARKED (base_binfo);\n+      \n+      rval = get_template_base_recursive (tparms, targs,\n+\t\t\t\t\t  parm,\n+\t\t\t\t\t  base_binfo, \n+\t\t\t\t\t  rval,\n+\t\t\t\t\t  GTB_VIA_VIRTUAL * this_virtual);\n+      \n+      /* If we discovered more than one matching base class, we can\n+\t stop now.  */\n+      if (rval == error_mark_node)\n+\treturn error_mark_node;\n     }\n \n   return rval;\n }\n \n-/* Given a template type TEMPLATE and a class type or binfo node BINFO,\n-   find the unique base type in BINFO that is an instance of TEMPLATE.\n-   If there are more than one, return error_mark_node.  TEMPLATE may\n-   be the type of a partial specialization, as well as a plain\n-   template type.  Used by unify.  */\n+/* Given a template type PARM and a class type ARG, find the unique\n+   base type in ARG that is an instance of PARM.  We do not examine\n+   ARG itself; only its base-classes.  If there is no appropriate base\n+   class, return NULL_TREE.  If there is more than one, return\n+   error_mark_node.  PARM may be the type of a partial specialization,\n+   as well as a plain template type.  Used by unify.  */\n \n static tree\n-get_template_base (tparms, targs, template, binfo)\n+get_template_base (tparms, targs, parm, arg)\n      tree tparms;\n      tree targs;\n-     tree template;\n-     tree binfo;\n+     tree parm;\n+     tree arg;\n {\n-  tree type = NULL_TREE, rval;\n+  tree rval;\n+  tree arg_binfo;\n \n-  if (TREE_CODE (binfo) == TREE_VEC)\n-    type = BINFO_TYPE (binfo);\n-  else if (IS_AGGR_TYPE_CODE (TREE_CODE (binfo)))\n-    {\n-      type = complete_type (binfo);\n-      binfo = TYPE_BINFO (type);\n-    }\n-  else\n-    my_friendly_abort (92);\n+  my_friendly_assert (IS_AGGR_TYPE_CODE (TREE_CODE (arg)), 92);\n+  \n+  arg_binfo = TYPE_BINFO (complete_type (arg));\n+  rval = get_template_base_recursive (tparms, targs,\n+\t\t\t\t      parm, arg_binfo, \n+\t\t\t\t      NULL_TREE,\n+\t\t\t\t      GTB_IGNORE_TYPE);\n \n-  rval = get_template_base_recursive (tparms, targs, \n-\t\t\t\t      binfo, NULL_TREE,\n-\t\t\t\t      template, 0); \n-  dfs_walk (binfo, dfs_unmark, markedp);\n+  /* Since get_template_base_recursive marks the bases classes, we\n+     must unmark them here.  */\n+  dfs_walk (arg_binfo, dfs_unmark, markedp);\n \n   return rval;\n }\n@@ -7525,10 +7799,9 @@ check_cv_quals_for_unify (strict, arg, parm)\n        case for more information.  */\n \n int\n-unify (tparms, targs, parm, arg, strict, explicit_mask)\n+unify (tparms, targs, parm, arg, strict)\n      tree tparms, targs, parm, arg;\n      int strict;\n-     int* explicit_mask;\n {\n   int idx;\n   tree targ;\n@@ -7596,13 +7869,6 @@ unify (tparms, targs, parm, arg, strict, explicit_mask)\n \t      && TREE_CODE (tparm) != TEMPLATE_DECL))\n \treturn 1;\n \n-      if (!strict && targ != NULL_TREE \n-\t  && explicit_mask && explicit_mask[idx])\n-\t/* An explicit template argument.  Don't even try to match\n-\t   here; the overload resolution code will manage check to\n-\t   see whether the call is legal.  */ \n-\treturn 0;\n-\n       if (TREE_CODE (parm) == TEMPLATE_TEMPLATE_PARM)\n \t{\n \t  if (TEMPLATE_TEMPLATE_PARM_TEMPLATE_INFO (parm))\n@@ -7644,7 +7910,7 @@ unify (tparms, targs, parm, arg, strict, explicit_mask)\n \n \t\t    if (unify (tparms, targs, t, \n \t\t\t       TREE_VEC_ELT (argvec, i), \n-\t\t\t       UNIFY_ALLOW_NONE, explicit_mask))\n+\t\t\t       UNIFY_ALLOW_NONE))\n \t\t      return 1;\n \t\t  }\n \t      }\n@@ -7670,9 +7936,7 @@ unify (tparms, targs, parm, arg, strict, explicit_mask)\n \t}\n \n       /* Simple cases: Value already set, does match or doesn't.  */\n-      if (targ != NULL_TREE \n-\t  && (same_type_p (targ, arg)\n-\t      || (explicit_mask && explicit_mask[idx])))\n+      if (targ != NULL_TREE && same_type_p (targ, arg))\n \treturn 0;\n       else if (targ)\n \treturn 1;\n@@ -7742,8 +8006,7 @@ unify (tparms, targs, parm, arg, strict, explicit_mask)\n \n \tif (TREE_CODE (arg) == RECORD_TYPE && TYPE_PTRMEMFUNC_FLAG (arg))\n \t  return (unify (tparms, targs, parm, \n-\t\t\t TYPE_PTRMEMFUNC_FN_TYPE (arg), strict,\n-\t\t\t explicit_mask)); \n+\t\t\t TYPE_PTRMEMFUNC_FN_TYPE (arg), strict));\n \t\n \tif (TREE_CODE (arg) != POINTER_TYPE)\n \t  return 1;\n@@ -7771,14 +8034,14 @@ unify (tparms, targs, parm, arg, strict, explicit_mask)\n \t  sub_strict &= ~UNIFY_ALLOW_DERIVED;\n \n \treturn unify (tparms, targs, TREE_TYPE (parm), TREE_TYPE\n-\t\t      (arg), sub_strict,  explicit_mask);\n+\t\t      (arg), sub_strict);\n       }\n \n     case REFERENCE_TYPE:\n       if (TREE_CODE (arg) != REFERENCE_TYPE)\n \treturn 1;\n       return unify (tparms, targs, TREE_TYPE (parm), TREE_TYPE (arg),\n-\t\t    UNIFY_ALLOW_NONE, explicit_mask);\n+\t\t    UNIFY_ALLOW_NONE);\n \n     case ARRAY_TYPE:\n       if (TREE_CODE (arg) != ARRAY_TYPE)\n@@ -7788,10 +8051,10 @@ unify (tparms, targs, parm, arg, strict, explicit_mask)\n \treturn 1;\n       if (TYPE_DOMAIN (parm) != NULL_TREE\n \t  && unify (tparms, targs, TYPE_DOMAIN (parm),\n-\t\t    TYPE_DOMAIN (arg), UNIFY_ALLOW_NONE, explicit_mask) != 0)\n+\t\t    TYPE_DOMAIN (arg), UNIFY_ALLOW_NONE) != 0)\n \treturn 1;\n       return unify (tparms, targs, TREE_TYPE (parm), TREE_TYPE (arg),\n-\t\t    UNIFY_ALLOW_NONE, explicit_mask);\n+\t\t    UNIFY_ALLOW_NONE);\n \n     case REAL_TYPE:\n     case COMPLEX_TYPE:\n@@ -7806,13 +8069,11 @@ unify (tparms, targs, parm, arg, strict, explicit_mask)\n \t{\n \t  if (TYPE_MIN_VALUE (parm) && TYPE_MIN_VALUE (arg)\n \t      && unify (tparms, targs, TYPE_MIN_VALUE (parm),\n-\t\t\tTYPE_MIN_VALUE (arg), UNIFY_ALLOW_INTEGER,\n-\t\t\texplicit_mask))\n+\t\t\tTYPE_MIN_VALUE (arg), UNIFY_ALLOW_INTEGER))\n \t    return 1;\n \t  if (TYPE_MAX_VALUE (parm) && TYPE_MAX_VALUE (arg)\n \t      && unify (tparms, targs, TYPE_MAX_VALUE (parm),\n-\t\t\tTYPE_MAX_VALUE (arg), UNIFY_ALLOW_INTEGER,\n-\t\t\texplicit_mask))\n+\t\t\tTYPE_MAX_VALUE (arg), UNIFY_ALLOW_INTEGER))\n \t    return 1;\n \t}\n       /* We use the TYPE_MAIN_VARIANT since we have already\n@@ -7846,7 +8107,7 @@ unify (tparms, targs, parm, arg, strict, explicit_mask)\n \tfor (i = TREE_VEC_LENGTH (parm) - 1; i >= 0; i--)\n \t  if (unify (tparms, targs,\n \t\t     TREE_VEC_ELT (parm, i), TREE_VEC_ELT (arg, i),\n-\t\t     UNIFY_ALLOW_NONE, explicit_mask))\n+\t\t     UNIFY_ALLOW_NONE))\n \t    return 1;\n \treturn 0;\n       }\n@@ -7855,40 +8116,51 @@ unify (tparms, targs, parm, arg, strict, explicit_mask)\n     case UNION_TYPE:\n       if (TYPE_PTRMEMFUNC_FLAG (parm))\n \treturn unify (tparms, targs, TYPE_PTRMEMFUNC_FN_TYPE (parm),\n-\t\t      arg, strict, explicit_mask);\n+\t\t      arg, strict);\n \n       if (TREE_CODE (arg) != TREE_CODE (parm))\n \treturn 1;\n   \n       if (CLASSTYPE_TEMPLATE_INFO (parm))\n \t{\n \t  tree t = NULL_TREE;\n+\n \t  if (strict & UNIFY_ALLOW_DERIVED)\n-\t    /* [temp.deduct.call]\n-\n-\t       If P is a class, and P has the form template-id, then A\n-\t       can be a derived class of the deduced A.  Likewise, if\n-\t       P is a pointer to a class of the form template-id, A\n-\t       can be a pointer to a derived class pointed to by the\n-\t       deduced A. \n-\n-\t       The call to get_template_base also handles the case\n-\t       where PARM and ARG are the same type, i.e., where no\n-\t       derivation is involved.  */\n-\t    t = get_template_base (tparms, targs, parm, arg);\n+\t    {\n+\t      /* First, we try to unify the PARM and ARG directly.  */\n+\t      t = try_class_unification (tparms, targs,\n+\t\t\t\t\t parm, arg);\n+\n+\t      if (!t)\n+\t\t{\n+\t\t  /* Fallback to the special case allowed in\n+\t\t     [temp.deduct.call]:\n+\t\t     \n+\t\t       If P is a class, and P has the form\n+\t\t       template-id, then A can be a derived class of\n+\t\t       the deduced A.  Likewise, if P is a pointer to\n+\t\t       a class of the form template-id, A can be a\n+\t\t       pointer to a derived class pointed to by the\n+\t\t       deduced A.  */\n+\t\t  t = get_template_base (tparms, targs,\n+\t\t\t\t\t parm, arg);\n+\n+\t\t  if (! t || t == error_mark_node)\n+\t\t    return 1;\n+\t\t}\n+\t    }\n \t  else if (CLASSTYPE_TEMPLATE_INFO (arg) \n \t\t   && (CLASSTYPE_TI_TEMPLATE (parm) \n \t\t       == CLASSTYPE_TI_TEMPLATE (arg)))\n \t    /* Perhaps PARM is something like S<U> and ARG is S<int>.\n \t       Then, we should unify `int' and `U'.  */\n \t    t = arg;\n-\n-\t  if (! t || t == error_mark_node)\n+\t  else\n+\t    /* There's no chance of unication succeeding.  */\n \t    return 1;\n \n \t  return unify (tparms, targs, CLASSTYPE_TI_ARGS (parm),\n-\t\t\tCLASSTYPE_TI_ARGS (t), UNIFY_ALLOW_NONE,\n-\t\t\texplicit_mask);\n+\t\t\tCLASSTYPE_TI_ARGS (t), UNIFY_ALLOW_NONE);\n \t}\n       else if (!same_type_p (TYPE_MAIN_VARIANT (parm),\n \t\t\t     TYPE_MAIN_VARIANT (arg)))\n@@ -7901,20 +8173,20 @@ unify (tparms, targs, parm, arg, strict, explicit_mask)\n \treturn 1;\n \n       if (unify (tparms, targs, TREE_TYPE (parm),\n-\t\t TREE_TYPE (arg), UNIFY_ALLOW_NONE, explicit_mask))\n+\t\t TREE_TYPE (arg), UNIFY_ALLOW_NONE))\n \treturn 1;\n       return type_unification_real (tparms, targs, TYPE_ARG_TYPES (parm),\n \t\t\t\t    TYPE_ARG_TYPES (arg), 1, \n-\t\t\t\t    DEDUCE_EXACT, 0, explicit_mask);\n+\t\t\t\t    DEDUCE_EXACT, 0);\n \n     case OFFSET_TYPE:\n       if (TREE_CODE (arg) != OFFSET_TYPE)\n \treturn 1;\n       if (unify (tparms, targs, TYPE_OFFSET_BASETYPE (parm),\n-\t\t TYPE_OFFSET_BASETYPE (arg), UNIFY_ALLOW_NONE, explicit_mask))\n+\t\t TYPE_OFFSET_BASETYPE (arg), UNIFY_ALLOW_NONE))\n \treturn 1;\n       return unify (tparms, targs, TREE_TYPE (parm), TREE_TYPE (arg),\n-\t\t    strict, explicit_mask);\n+\t\t    strict);\n \n     case CONST_DECL:\n       if (arg != decl_constant_value (parm)) \n@@ -7944,40 +8216,31 @@ unify (tparms, targs, parm, arg, strict, explicit_mask)\n \t\t\t\t\t     integer_type_node,\n \t\t\t\t\t     arg, t2));\n \n-\t  return unify (tparms, targs, t1, t, strict, explicit_mask);\n+\t  return unify (tparms, targs, t1, t, strict);\n \t}\n       /* else fall through */\n \n     default:\n       if (IS_EXPR_CODE_CLASS (TREE_CODE_CLASS (TREE_CODE (parm))))\n-\t{\n-\t  /* We're looking at an expression.  This can happen with\n-\t     something like:\n-\n-\t       template <int I>\n-\t       void foo(S<I>, S<I + 2>);\n+\t/* We're looking at an expression.  This can happen with\n+\t   something like: \n+\t   \n+\t     template <int I>\n+\t     void foo(S<I>, S<I + 2>);\n \n-             If the call looked like:\n+\t   This is a \"nondeduced context\":\n \n-               foo(S<2>(), S<4>());\n+\t     [deduct.type]\n+\t   \n+\t     The nondeduced contexts are:\n \n-\t     we would have already matched `I' with `2'.  Now, we'd\n-\t     like to know if `4' matches `I + 2'.  So, we substitute\n-\t     into that expression, and fold constants, in the hope of\n-\t     figuring it out.  */\n-\t  tree t = \n-\t    maybe_fold_nontype_arg (tsubst_expr (parm, targs, NULL_TREE)); \n-\t  tree a = maybe_fold_nontype_arg (arg);\n+\t     --A type that is a template-id in which one or more of\n+\t       the template-arguments is an expression that references\n+\t       a template-parameter.  \n \n-\t  if (!IS_EXPR_CODE_CLASS (TREE_CODE_CLASS (TREE_CODE (t))))\n-\t    /* Good, we mangaged to simplify the exression.  */\n-\t    return unify (tparms, targs, t, a, UNIFY_ALLOW_NONE,\n-\t\t\t  explicit_mask);\n-\t  else\n-\t    /* Bad, we couldn't simplify this.  Assume it doesn't\n-\t       unify.  */\n-\t    return 1;\n-\t}\n+\t   In these cases, we assume deduction succeeded, but don't\n+\t   actually infer any unifications.  */\n+\treturn 0;\n       else\n \tsorry (\"use of `%s' in template type unification\",\n \t       tree_code_name [(int) TREE_CODE (parm)]);\n@@ -8031,11 +8294,11 @@ more_specialized (pat1, pat2, explicit_args)\n   tree targs;\n   int winner = 0;\n \n-  targs = get_bindings_overload (pat1, pat2, explicit_args);\n+  targs = get_bindings_overload (pat1, DECL_RESULT (pat2), explicit_args);\n   if (targs)\n     --winner;\n \n-  targs = get_bindings_overload (pat2, pat1, explicit_args);\n+  targs = get_bindings_overload (pat2, DECL_RESULT (pat1), explicit_args);\n   if (targs)\n     ++winner;\n \n@@ -8071,7 +8334,8 @@ more_specialized_class (pat1, pat2)\n /* Return the template arguments that will produce the function signature\n    DECL from the function template FN, with the explicit template\n    arguments EXPLICIT_ARGS.  If CHECK_RETTYPE is 1, the return type must\n-   also match.  */\n+   also match.  Return NULL_TREE if no satisfactory arguments could be\n+   found.  */\n \n static tree\n get_bindings_real (fn, decl, explicit_args, check_rettype)\n@@ -8080,10 +8344,42 @@ get_bindings_real (fn, decl, explicit_args, check_rettype)\n {\n   int ntparms = DECL_NTPARMS (fn);\n   tree targs = make_scratch_vec (ntparms);\n-  tree decl_arg_types = TYPE_ARG_TYPES (TREE_TYPE (decl));\n+  tree decl_arg_types;\n   tree extra_fn_arg = NULL_TREE;\n+  tree decl_type;\n   int i;\n \n+  /* Substitute the explicit template arguments into the type of DECL.\n+     The call to fn_type_unification will handle substitution into the\n+     FN.  */\n+  decl_type = TREE_TYPE (decl);\n+  if (explicit_args && uses_template_parms (decl_type))\n+    {\n+      tree tmpl;\n+      tree converted_args;\n+\n+      if (DECL_TEMPLATE_INFO (decl))\n+\ttmpl = DECL_TI_TEMPLATE (decl);\n+      else\n+\t/* We can get here for some illegal specializations.  */\n+\treturn NULL_TREE;\n+\n+      converted_args\n+\t= (coerce_template_parms (DECL_INNERMOST_TEMPLATE_PARMS (tmpl),\n+\t\t\t\t  explicit_args, NULL_TREE,\n+\t\t\t\t  /*complain=*/0, \n+\t\t\t\t  /*require_all_arguments=*/0));\n+      if (converted_args == error_mark_node)\n+\treturn NULL_TREE;\n+      \n+      decl_type = tsubst (decl_type, converted_args, /*complain=*/0, \n+\t\t\t  NULL_TREE); \n+      if (decl_type == error_mark_node)\n+\treturn NULL_TREE;\n+    }\n+\n+  decl_arg_types = TYPE_ARG_TYPES (decl_type);\n+\n   if (DECL_STATIC_FUNCTION_P (fn) \n       && DECL_NONSTATIC_MEMBER_FUNCTION_P (decl))\n     {\n@@ -8105,8 +8401,7 @@ get_bindings_real (fn, decl, explicit_args, check_rettype)\n     }\n \n   i = fn_type_unification (fn, explicit_args, targs, \n-\t\t\t   decl_arg_types,\n-\t\t\t   TREE_TYPE (TREE_TYPE (decl)),\n+\t\t\t   decl_arg_types, TREE_TYPE (decl_type),\n \t\t\t   DEDUCE_EXACT,\n \t\t\t   extra_fn_arg);\n \n@@ -8117,7 +8412,7 @@ get_bindings_real (fn, decl, explicit_args, check_rettype)\n     {\n       /* Check to see that the resulting return type is also OK.  */\n       tree t = tsubst (TREE_TYPE (TREE_TYPE (fn)), targs,\n-\t\t       NULL_TREE);\n+\t\t       /*complain=*/0, NULL_TREE);\n \n       if (!same_type_p (t, TREE_TYPE (TREE_TYPE (decl))))\n \treturn NULL_TREE;\n@@ -8168,7 +8463,7 @@ get_class_bindings (tparms, parms, args)\n \n   args = innermost_args (args);\n \n-  if (unify (tparms, vec, parms, args, UNIFY_ALLOW_NONE, 0))\n+  if (unify (tparms, vec, parms, args, UNIFY_ALLOW_NONE))\n     return NULL_TREE;\n \n   for (i =  0; i < ntparms; ++i)\n@@ -8644,14 +8939,14 @@ regenerate_decl_from_template (decl, tmpl)\n     pushclass (DECL_CONTEXT (decl), 2);\n \n   /* Do the substitution to get the new declaration.  */\n-  new_decl = tsubst (code_pattern, args, NULL_TREE);\n+  new_decl = tsubst (code_pattern, args, /*complain=*/1, NULL_TREE);\n \n   if (TREE_CODE (decl) == VAR_DECL)\n     {\n       /* Set up DECL_INITIAL, since tsubst doesn't.  */\n       DECL_INITIAL (new_decl) = \n \ttsubst_expr (DECL_INITIAL (code_pattern), args, \n-\t\t     DECL_TI_TEMPLATE (decl));\n+\t\t     /*complain=*/1, DECL_TI_TEMPLATE (decl));\n       /* Pop the class context we pushed above.  */\n       popclass (1);\n     }\n@@ -8882,7 +9177,7 @@ instantiate_decl (d)\n \t{\n \t  store_return_init\n \t    (TREE_OPERAND (t, 0),\n-\t     tsubst_expr (TREE_OPERAND (t, 1), args, tmpl));\n+\t     tsubst_expr (TREE_OPERAND (t, 1), args, /*complain=*/1, tmpl));\n \t  t = TREE_CHAIN (t);\n \t}\n \n@@ -8902,7 +9197,7 @@ instantiate_decl (d)\n       keep_next_level ();\n \n       my_friendly_assert (TREE_CODE (t) == COMPOUND_STMT, 42);\n-      tsubst_expr (t, args, tmpl);\n+      tsubst_expr (t, args, /*complain=*/1, tmpl);\n \n       finish_function (lineno, 0, nested);\n     }\n@@ -8917,6 +9212,10 @@ instantiate_decl (d)\n   return d;\n }\n \n+/* Substitute ARGVEC into T, which is a TREE_LIST.  In particular, it\n+   is an initializer list: the TREE_PURPOSEs are DECLs, and the\n+   TREE_VALUEs are initializer values.  Used by instantiate_decl.  */\n+\n static tree\n tsubst_expr_values (t, argvec)\n      tree t, argvec;\n@@ -8926,8 +9225,10 @@ tsubst_expr_values (t, argvec)\n \n   for (; t; t = TREE_CHAIN (t))\n     {\n-      tree pur = tsubst_copy (TREE_PURPOSE (t), argvec, NULL_TREE);\n-      tree val = tsubst_expr (TREE_VALUE (t), argvec, NULL_TREE);\n+      tree pur = tsubst_copy (TREE_PURPOSE (t), argvec,\n+\t\t\t      /*complain=*/1, NULL_TREE);\n+      tree val = tsubst_expr (TREE_VALUE (t), argvec, /*complain=*/1, \n+\t\t\t      NULL_TREE);\n       *p = build_tree_list (pur, val);\n       p = &TREE_CHAIN (*p);\n     }\n@@ -9023,8 +9324,8 @@ tsubst_enum (tag, newtag, args)\n       /* Note that in a template enum, the TREE_VALUE is the\n \t CONST_DECL, not the corresponding INTEGER_CST.  */\n       value = tsubst_expr (DECL_INITIAL (TREE_VALUE (e)), \n-\t\t\t\t\t args,\n-\t\t\t\t\t NULL_TREE);\n+\t\t\t   args, /*complain=*/1,\n+\t\t\t   NULL_TREE);\n \n       /* Give this enumeration constant the correct access.  */\n       set_current_access_from_decl (TREE_VALUE (e));\n@@ -9129,16 +9430,16 @@ set_mangled_name_for_template_decl (decl)\n \n       /* Now, do the (partial) substitution to figure out the\n \t appropriate function type.  */\n-      fn_type = tsubst (fn_type, partial_args, NULL_TREE);\n+      fn_type = tsubst (fn_type, partial_args, /*complain=*/1, NULL_TREE);\n       if (DECL_STATIC_FUNCTION_P (decl))\n-\tcontext = tsubst (context, partial_args, NULL_TREE);\n+\tcontext = tsubst (context, partial_args, /*complain=*/1, NULL_TREE);\n \n       /* Substitute into the template parameters to obtain the real\n \t innermost set of parameters.  This step is important if the\n \t innermost set of template parameters contains value\n \t parameters whose types depend on outer template parameters.  */\n       TREE_VEC_LENGTH (partial_args)--;\n-      tparms = tsubst_template_parms (tparms, partial_args);\n+      tparms = tsubst_template_parms (tparms, partial_args, /*complain=*/1);\n     }\n \n   /* Now, get the innermost parameters and arguments, and figure out"}, {"sha": "0f06c53f8fc7ceb4466986fe5cfbd19411882b41", "filename": "gcc/testsuite/g++.old-deja/g++.pt/explicit22.C", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4393e10527c91ec9238ce2fdef4f731b8f56bed8/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Fexplicit22.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4393e10527c91ec9238ce2fdef4f731b8f56bed8/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Fexplicit22.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Fexplicit22.C?ref=4393e10527c91ec9238ce2fdef4f731b8f56bed8", "patch": "@@ -1,10 +1,10 @@\n // Build don't link:\n // GROUPS passed templates\n template <class T, class U>\n-T foo(T t, U* u); // ERROR - template candidate\n+T foo(T t, U* u);\n \n template <class T>\n-T foo(T t, T* t); // ERROR - template candidate\n+T foo(T t, T* u);\n \n template <>\n-int foo<int>(int, int*); // ERROR - ambiguous template specialization\n+int foo<int>(int, int*);"}, {"sha": "5a07f8e01686b7f36aba369530cb8e1d5ebfc764", "filename": "gcc/testsuite/g++.old-deja/g++.pt/explicit77.C", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4393e10527c91ec9238ce2fdef4f731b8f56bed8/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Fexplicit77.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4393e10527c91ec9238ce2fdef4f731b8f56bed8/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Fexplicit77.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Fexplicit77.C?ref=4393e10527c91ec9238ce2fdef4f731b8f56bed8", "patch": "@@ -0,0 +1,18 @@\n+// Build don't link:\n+\n+template <int I, int J, int K>\n+struct S {};\n+\n+template <int I, int J>\n+struct S<I, J, 2> : public S<I, I, I>, S<J, J, J> {};\n+\n+template <int I, int J, int K>\n+void f(S<I, J, K>, S<I, I, I>);\n+\n+void g() {\n+  S<0, 0, 0> s0;\n+  S<0, 1, 2> s2;\n+  \n+  f<0>(s0, s2);\n+  f(s0, s2); // ERROR - no matching function\n+}"}, {"sha": "2375816af87cdd33801b0065c60e5a7f8b0160d8", "filename": "gcc/testsuite/g++.old-deja/g++.pt/explicit78.C", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4393e10527c91ec9238ce2fdef4f731b8f56bed8/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Fexplicit78.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4393e10527c91ec9238ce2fdef4f731b8f56bed8/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Fexplicit78.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Fexplicit78.C?ref=4393e10527c91ec9238ce2fdef4f731b8f56bed8", "patch": "@@ -0,0 +1,28 @@\n+// Build don't link:\n+\n+template <int I>\n+struct A {\n+};\n+\n+template <int I, int J>\n+struct B {\n+  operator A<3> ();\n+  operator B<3, 7> ();\n+};\n+\n+\n+template <int I, int J>\n+void f(B<I, J>);\n+\n+template <int I>\n+void f(A<I>)\n+{\n+}\n+\n+int main()\n+{\n+  // Deduction fails with the first `f'.  Since `3' is explicitly\n+  // specified, we don't try any deduction with the second `f'.  So,\n+  // we call the second `f'.\n+  f<3>(B<2, 7>());\n+}"}, {"sha": "16429ba62139891b837ec9d0f7bf23b66067931c", "filename": "gcc/testsuite/g++.old-deja/g++.pt/explicit79.C", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4393e10527c91ec9238ce2fdef4f731b8f56bed8/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Fexplicit79.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4393e10527c91ec9238ce2fdef4f731b8f56bed8/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Fexplicit79.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Fexplicit79.C?ref=4393e10527c91ec9238ce2fdef4f731b8f56bed8", "patch": "@@ -0,0 +1,12 @@\n+// Build don't link:\n+\n+template <int I>\n+void f(int (*)[I] = 0);\n+\n+template <int J>\n+void f();\n+\n+void g()\n+{\n+  f<-1>();\n+}"}, {"sha": "5fb567b5b77a3c48acc9efc97f821ee07515761e", "filename": "gcc/testsuite/g++.old-deja/g++.pt/expr7.C", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4393e10527c91ec9238ce2fdef4f731b8f56bed8/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Fexpr7.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4393e10527c91ec9238ce2fdef4f731b8f56bed8/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Fexpr7.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Fexpr7.C?ref=4393e10527c91ec9238ce2fdef4f731b8f56bed8", "patch": "@@ -0,0 +1,8 @@\n+// Build don't link:\n+\n+template<int I> struct A { };\n+template<int I, int J> int f(A<I+J>);\n+int g() {\n+  A<3> a;\n+  return f<1,2>(a);\n+}"}]}