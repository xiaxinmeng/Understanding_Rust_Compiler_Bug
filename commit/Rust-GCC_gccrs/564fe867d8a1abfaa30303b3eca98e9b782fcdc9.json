{"sha": "564fe867d8a1abfaa30303b3eca98e9b782fcdc9", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTY0ZmU4NjdkOGExYWJmYWEzMDMwM2IzZWNhOThlOWI3ODJmY2RjOQ==", "commit": {"author": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2012-05-08T21:05:38Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2012-05-08T21:05:38Z"}, "message": "cgraph.c (cgraph_call_edge_duplication_hooks): Export.\n\n\n\t* cgraph.c (cgraph_call_edge_duplication_hooks): Export.\n\t(cgraph_create_node_1): Rename to ...\n\t(cgraph_create_empty_node): ... this one; export.\n\t(cgraph_create_node): Update.\n\t(cgraph_set_call_stmt_including_clones): Move to cgraphclones.c\n\t(cgraph_create_edge_including_clones): Likewise.\n\t(cgraph_find_replacement_node): Likewise.\n\t(cgraph_clone_edge): Likewise.\n\t(cgraph_clone_node): Likewise.\n\t(clone_function_name): Likewise.\n\t(cgraph_create_virtual_clone): Likewise.\n\t(cgraph_remove_node_and_inline_clones): Likewise.\n\t(cgraph_redirect_edge_call_stmt_to_callee): Move here from\n\tcgraphunit.c\n\t* cgraph.h: Reorder declarations so they match file of origin.\n\t(cgraph_create_empty_node): Declare.\n\t* cgraphunit.c (update_call_expr): Move to cgraphclones.c\n\t(cgraph_copy_node_for_versioning): Likewise.\n\t(cgraph_function_versioning): Likewise.\n\t(cgraph_materialize_clone): Likewise.\n\t(cgraph_redirect_edge_call_stmt_to_callee): Likewise.\n\t(cgraph_materialize_all_clones): Likewise.\n\t* cgraphclones.c: New file.\n\t* Makefile.in: Update for cgraphclones.\n\nFrom-SVN: r187296", "tree": {"sha": "bc7d9728e817152938f24dba9797ec7bf859c39b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/bc7d9728e817152938f24dba9797ec7bf859c39b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/564fe867d8a1abfaa30303b3eca98e9b782fcdc9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/564fe867d8a1abfaa30303b3eca98e9b782fcdc9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/564fe867d8a1abfaa30303b3eca98e9b782fcdc9", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/564fe867d8a1abfaa30303b3eca98e9b782fcdc9/comments", "author": null, "committer": null, "parents": [{"sha": "66a20fc2a7de31a268cfe5f87ffe42255d815c32", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/66a20fc2a7de31a268cfe5f87ffe42255d815c32", "html_url": "https://github.com/Rust-GCC/gccrs/commit/66a20fc2a7de31a268cfe5f87ffe42255d815c32"}], "stats": {"total": 876, "additions": 876, "deletions": 0}, "files": [{"sha": "eb4e55f8cbe5eb9f01afa6558d5b29c7a8381d6d", "filename": "gcc/cgraphclones.c", "status": "added", "additions": 876, "deletions": 0, "changes": 876, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/564fe867d8a1abfaa30303b3eca98e9b782fcdc9/gcc%2Fcgraphclones.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/564fe867d8a1abfaa30303b3eca98e9b782fcdc9/gcc%2Fcgraphclones.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraphclones.c?ref=564fe867d8a1abfaa30303b3eca98e9b782fcdc9", "patch": "@@ -0,0 +1,876 @@\n+/* Callgraph clones\n+   Copyright (C) 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010,\n+   2011, 2012 Free Software Foundation, Inc.\n+   Contributed by Jan Hubicka\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it under\n+the terms of the GNU General Public License as published by the Free\n+Software Foundation; either version 3, or (at your option) any later\n+version.\n+\n+GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING3.  If not see\n+<http://www.gnu.org/licenses/>.  */\n+\n+/* This module provide facilities for clonning functions. I.e. creating\n+   new functions based on existing functions with simple modifications,\n+   such as replacement of parameters.\n+\n+   To allow whole program optimization without actual presence of function\n+   bodies, an additional infrastructure is provided for so-called virtual\n+   clones\n+\n+   A virtual clone in the callgraph is a function that has no\n+   associated body, just a description of how to create its body based\n+   on a different function (which itself may be a virtual clone).\n+\n+   The description of function modifications includes adjustments to\n+   the function's signature (which allows, for example, removing or\n+   adding function arguments), substitutions to perform on the\n+   function body, and, for inlined functions, a pointer to the\n+   function that it will be inlined into.\n+\n+   It is also possible to redirect any edge of the callgraph from a\n+   function to its virtual clone.  This implies updating of the call\n+   site to adjust for the new function signature.\n+\n+   Most of the transformations performed by inter-procedural\n+   optimizations can be represented via virtual clones.  For\n+   instance, a constant propagation pass can produce a virtual clone\n+   of the function which replaces one of its arguments by a\n+   constant.  The inliner can represent its decisions by producing a\n+   clone of a function whose body will be later integrated into\n+   a given function.\n+\n+   Using virtual clones, the program can be easily updated\n+   during the Execute stage, solving most of pass interactions\n+   problems that would otherwise occur during Transform.\n+\n+   Virtual clones are later materialized in the LTRANS stage and\n+   turned into real functions.  Passes executed after the virtual\n+   clone were introduced also perform their Transform stage\n+   on new functions, so for a pass there is no significant\n+   difference between operating on a real function or a virtual\n+   clone introduced before its Execute stage.\n+\n+   Optimization passes then work on virtual clones introduced before\n+   their Execute stage as if they were real functions.  The\n+   only difference is that clones are not visible during the\n+   Generate Summary stage.  */\n+\n+#include \"config.h\"\n+#include \"system.h\"\n+#include \"coretypes.h\"\n+#include \"tm.h\"\n+#include \"tree.h\"\n+#include \"output.h\"\n+#include \"rtl.h\"\n+#include \"tree-flow.h\"\n+#include \"tree-inline.h\"\n+#include \"langhooks.h\"\n+#include \"pointer-set.h\"\n+#include \"toplev.h\"\n+#include \"flags.h\"\n+#include \"ggc.h\"\n+#include \"debug.h\"\n+#include \"target.h\"\n+#include \"cgraph.h\"\n+#include \"diagnostic.h\"\n+#include \"timevar.h\"\n+#include \"params.h\"\n+#include \"fibheap.h\"\n+#include \"intl.h\"\n+#include \"function.h\"\n+#include \"ipa-prop.h\"\n+#include \"gimple.h\"\n+#include \"tree-iterator.h\"\n+#include \"tree-pass.h\"\n+#include \"tree-dump.h\"\n+#include \"gimple-pretty-print.h\"\n+#include \"output.h\"\n+#include \"coverage.h\"\n+#include \"plugin.h\"\n+#include \"ipa-inline.h\"\n+#include \"ipa-utils.h\"\n+#include \"lto-streamer.h\"\n+#include \"except.h\"\n+\n+/* Create clone of E in the node N represented by CALL_EXPR the callgraph.  */\n+struct cgraph_edge *\n+cgraph_clone_edge (struct cgraph_edge *e, struct cgraph_node *n,\n+\t\t   gimple call_stmt, unsigned stmt_uid, gcov_type count_scale,\n+\t\t   int freq_scale, bool update_original)\n+{\n+  struct cgraph_edge *new_edge;\n+  gcov_type count = e->count * count_scale / REG_BR_PROB_BASE;\n+  gcov_type freq;\n+\n+  /* We do not want to ignore loop nest after frequency drops to 0.  */\n+  if (!freq_scale)\n+    freq_scale = 1;\n+  freq = e->frequency * (gcov_type) freq_scale / CGRAPH_FREQ_BASE;\n+  if (freq > CGRAPH_FREQ_MAX)\n+    freq = CGRAPH_FREQ_MAX;\n+\n+  if (e->indirect_unknown_callee)\n+    {\n+      tree decl;\n+\n+      if (call_stmt && (decl = gimple_call_fndecl (call_stmt)))\n+\t{\n+\t  struct cgraph_node *callee = cgraph_get_node (decl);\n+\t  gcc_checking_assert (callee);\n+\t  new_edge = cgraph_create_edge (n, callee, call_stmt, count, freq);\n+\t}\n+      else\n+\t{\n+\t  new_edge = cgraph_create_indirect_edge (n, call_stmt,\n+\t\t\t\t\t\t  e->indirect_info->ecf_flags,\n+\t\t\t\t\t\t  count, freq);\n+\t  *new_edge->indirect_info = *e->indirect_info;\n+\t}\n+    }\n+  else\n+    {\n+      new_edge = cgraph_create_edge (n, e->callee, call_stmt, count, freq);\n+      if (e->indirect_info)\n+\t{\n+\t  new_edge->indirect_info\n+\t    = ggc_alloc_cleared_cgraph_indirect_call_info ();\n+\t  *new_edge->indirect_info = *e->indirect_info;\n+\t}\n+    }\n+\n+  new_edge->inline_failed = e->inline_failed;\n+  new_edge->indirect_inlining_edge = e->indirect_inlining_edge;\n+  new_edge->lto_stmt_uid = stmt_uid;\n+  /* Clone flags that depend on call_stmt availability manually.  */\n+  new_edge->can_throw_external = e->can_throw_external;\n+  new_edge->call_stmt_cannot_inline_p = e->call_stmt_cannot_inline_p;\n+  if (update_original)\n+    {\n+      e->count -= new_edge->count;\n+      if (e->count < 0)\n+\te->count = 0;\n+    }\n+  cgraph_call_edge_duplication_hooks (e, new_edge);\n+  return new_edge;\n+}\n+\n+\n+/* Create node representing clone of N executed COUNT times.  Decrease\n+   the execution counts from original node too.\n+   The new clone will have decl set to DECL that may or may not be the same\n+   as decl of N.\n+\n+   When UPDATE_ORIGINAL is true, the counts are subtracted from the original\n+   function's profile to reflect the fact that part of execution is handled\n+   by node.  \n+   When CALL_DUPLICATOIN_HOOK is true, the ipa passes are acknowledged about\n+   the new clone. Otherwise the caller is responsible for doing so later.  */\n+\n+struct cgraph_node *\n+cgraph_clone_node (struct cgraph_node *n, tree decl, gcov_type count, int freq,\n+\t\t   bool update_original,\n+\t\t   VEC(cgraph_edge_p,heap) *redirect_callers,\n+\t\t   bool call_duplication_hook)\n+{\n+  struct cgraph_node *new_node = cgraph_create_empty_node ();\n+  struct cgraph_edge *e;\n+  gcov_type count_scale;\n+  unsigned i;\n+\n+  new_node->symbol.decl = decl;\n+  symtab_register_node ((symtab_node)new_node);\n+  new_node->origin = n->origin;\n+  if (new_node->origin)\n+    {\n+      new_node->next_nested = new_node->origin->nested;\n+      new_node->origin->nested = new_node;\n+    }\n+  new_node->analyzed = n->analyzed;\n+  new_node->local = n->local;\n+  new_node->symbol.externally_visible = false;\n+  new_node->local.local = true;\n+  new_node->global = n->global;\n+  new_node->rtl = n->rtl;\n+  new_node->count = count;\n+  new_node->frequency = n->frequency;\n+  new_node->clone = n->clone;\n+  new_node->clone.tree_map = 0;\n+  if (n->count)\n+    {\n+      if (new_node->count > n->count)\n+        count_scale = REG_BR_PROB_BASE;\n+      else\n+        count_scale = new_node->count * REG_BR_PROB_BASE / n->count;\n+    }\n+  else\n+    count_scale = 0;\n+  if (update_original)\n+    {\n+      n->count -= count;\n+      if (n->count < 0)\n+\tn->count = 0;\n+    }\n+\n+  FOR_EACH_VEC_ELT (cgraph_edge_p, redirect_callers, i, e)\n+    {\n+      /* Redirect calls to the old version node to point to its new\n+\t version.  */\n+      cgraph_redirect_edge_callee (e, new_node);\n+    }\n+\n+\n+  for (e = n->callees;e; e=e->next_callee)\n+    cgraph_clone_edge (e, new_node, e->call_stmt, e->lto_stmt_uid,\n+\t\t       count_scale, freq, update_original);\n+\n+  for (e = n->indirect_calls; e; e = e->next_callee)\n+    cgraph_clone_edge (e, new_node, e->call_stmt, e->lto_stmt_uid,\n+\t\t       count_scale, freq, update_original);\n+  ipa_clone_references ((symtab_node)new_node, &n->symbol.ref_list);\n+\n+  new_node->next_sibling_clone = n->clones;\n+  if (n->clones)\n+    n->clones->prev_sibling_clone = new_node;\n+  n->clones = new_node;\n+  new_node->clone_of = n;\n+\n+  if (call_duplication_hook)\n+    cgraph_call_node_duplication_hooks (n, new_node);\n+  return new_node;\n+}\n+\n+/* Create a new name for clone of DECL, add SUFFIX.  Returns an identifier.  */\n+\n+static GTY(()) unsigned int clone_fn_id_num;\n+\n+tree\n+clone_function_name (tree decl, const char *suffix)\n+{\n+  tree name = DECL_ASSEMBLER_NAME (decl);\n+  size_t len = IDENTIFIER_LENGTH (name);\n+  char *tmp_name, *prefix;\n+\n+  prefix = XALLOCAVEC (char, len + strlen (suffix) + 2);\n+  memcpy (prefix, IDENTIFIER_POINTER (name), len);\n+  strcpy (prefix + len + 1, suffix);\n+#ifndef NO_DOT_IN_LABEL\n+  prefix[len] = '.';\n+#elif !defined NO_DOLLAR_IN_LABEL\n+  prefix[len] = '$';\n+#else\n+  prefix[len] = '_';\n+#endif\n+  ASM_FORMAT_PRIVATE_NAME (tmp_name, prefix, clone_fn_id_num++);\n+  return get_identifier (tmp_name);\n+}\n+\n+/* Create callgraph node clone with new declaration.  The actual body will\n+   be copied later at compilation stage.\n+\n+   TODO: after merging in ipa-sra use function call notes instead of args_to_skip\n+   bitmap interface.\n+   */\n+struct cgraph_node *\n+cgraph_create_virtual_clone (struct cgraph_node *old_node,\n+\t\t\t     VEC(cgraph_edge_p,heap) *redirect_callers,\n+\t\t\t     VEC(ipa_replace_map_p,gc) *tree_map,\n+\t\t\t     bitmap args_to_skip,\n+\t\t\t     const char * suffix)\n+{\n+  tree old_decl = old_node->symbol.decl;\n+  struct cgraph_node *new_node = NULL;\n+  tree new_decl;\n+  size_t i;\n+  struct ipa_replace_map *map;\n+\n+  if (!flag_wpa)\n+    gcc_checking_assert  (tree_versionable_function_p (old_decl));\n+\n+  gcc_assert (old_node->local.can_change_signature || !args_to_skip);\n+\n+  /* Make a new FUNCTION_DECL tree node */\n+  if (!args_to_skip)\n+    new_decl = copy_node (old_decl);\n+  else\n+    new_decl = build_function_decl_skip_args (old_decl, args_to_skip, false);\n+  DECL_STRUCT_FUNCTION (new_decl) = NULL;\n+\n+  /* Generate a new name for the new version. */\n+  DECL_NAME (new_decl) = clone_function_name (old_decl, suffix);\n+  SET_DECL_ASSEMBLER_NAME (new_decl, DECL_NAME (new_decl));\n+  SET_DECL_RTL (new_decl, NULL);\n+\n+  new_node = cgraph_clone_node (old_node, new_decl, old_node->count,\n+\t\t\t\tCGRAPH_FREQ_BASE, false,\n+\t\t\t\tredirect_callers, false);\n+  /* Update the properties.\n+     Make clone visible only within this translation unit.  Make sure\n+     that is not weak also.\n+     ??? We cannot use COMDAT linkage because there is no\n+     ABI support for this.  */\n+  DECL_EXTERNAL (new_node->symbol.decl) = 0;\n+  if (DECL_ONE_ONLY (old_decl))\n+    DECL_SECTION_NAME (new_node->symbol.decl) = NULL;\n+  DECL_COMDAT_GROUP (new_node->symbol.decl) = 0;\n+  TREE_PUBLIC (new_node->symbol.decl) = 0;\n+  DECL_COMDAT (new_node->symbol.decl) = 0;\n+  DECL_WEAK (new_node->symbol.decl) = 0;\n+  DECL_STATIC_CONSTRUCTOR (new_node->symbol.decl) = 0;\n+  DECL_STATIC_DESTRUCTOR (new_node->symbol.decl) = 0;\n+  new_node->clone.tree_map = tree_map;\n+  new_node->clone.args_to_skip = args_to_skip;\n+  FOR_EACH_VEC_ELT (ipa_replace_map_p, tree_map, i, map)\n+    {\n+      tree var = map->new_tree;\n+      symtab_node ref_node;\n+\n+      STRIP_NOPS (var);\n+      if (TREE_CODE (var) != ADDR_EXPR)\n+\tcontinue;\n+      var = get_base_var (var);\n+      if (!var)\n+\tcontinue;\n+      if (TREE_CODE (var) != FUNCTION_DECL\n+\t  && TREE_CODE (var) != VAR_DECL)\n+\tcontinue;\n+\n+      /* Record references of the future statement initializing the constant\n+\t argument.  */\n+      ref_node = symtab_get_node (var);\n+      gcc_checking_assert (ref_node);\n+      ipa_record_reference ((symtab_node)new_node, (symtab_node)ref_node,\n+\t\t\t    IPA_REF_ADDR, NULL);\n+    }\n+  if (!args_to_skip)\n+    new_node->clone.combined_args_to_skip = old_node->clone.combined_args_to_skip;\n+  else if (old_node->clone.combined_args_to_skip)\n+    {\n+      int newi = 0, oldi = 0;\n+      tree arg;\n+      bitmap new_args_to_skip = BITMAP_GGC_ALLOC ();\n+      struct cgraph_node *orig_node;\n+      for (orig_node = old_node; orig_node->clone_of; orig_node = orig_node->clone_of)\n+        ;\n+      for (arg = DECL_ARGUMENTS (orig_node->symbol.decl);\n+\t   arg; arg = DECL_CHAIN (arg), oldi++)\n+\t{\n+\t  if (bitmap_bit_p (old_node->clone.combined_args_to_skip, oldi))\n+\t    {\n+\t      bitmap_set_bit (new_args_to_skip, oldi);\n+\t      continue;\n+\t    }\n+\t  if (bitmap_bit_p (args_to_skip, newi))\n+\t    bitmap_set_bit (new_args_to_skip, oldi);\n+\t  newi++;\n+\t}\n+      new_node->clone.combined_args_to_skip = new_args_to_skip;\n+    }\n+  else\n+    new_node->clone.combined_args_to_skip = args_to_skip;\n+  new_node->symbol.externally_visible = 0;\n+  new_node->local.local = 1;\n+  new_node->lowered = true;\n+\n+  cgraph_call_node_duplication_hooks (old_node, new_node);\n+\n+\n+  return new_node;\n+}\n+\n+/* NODE is being removed from symbol table; see if its entry can be replaced by\n+   other inline clone.  */\n+struct cgraph_node *\n+cgraph_find_replacement_node (struct cgraph_node *node)\n+{\n+  struct cgraph_node *next_inline_clone, *replacement;\n+\n+  for (next_inline_clone = node->clones;\n+       next_inline_clone\n+       && next_inline_clone->symbol.decl != node->symbol.decl;\n+       next_inline_clone = next_inline_clone->next_sibling_clone)\n+    ;\n+\n+  /* If there is inline clone of the node being removed, we need\n+     to put it into the position of removed node and reorganize all\n+     other clones to be based on it.  */\n+  if (next_inline_clone)\n+    {\n+      struct cgraph_node *n;\n+      struct cgraph_node *new_clones;\n+\n+      replacement = next_inline_clone;\n+\n+      /* Unlink inline clone from the list of clones of removed node.  */\n+      if (next_inline_clone->next_sibling_clone)\n+\tnext_inline_clone->next_sibling_clone->prev_sibling_clone\n+\t  = next_inline_clone->prev_sibling_clone;\n+      if (next_inline_clone->prev_sibling_clone)\n+\t{\n+\t  gcc_assert (node->clones != next_inline_clone);\n+\t  next_inline_clone->prev_sibling_clone->next_sibling_clone\n+\t    = next_inline_clone->next_sibling_clone;\n+\t}\n+      else\n+\t{\n+\t  gcc_assert (node->clones == next_inline_clone);\n+\t  node->clones = next_inline_clone->next_sibling_clone;\n+\t}\n+\n+      new_clones = node->clones;\n+      node->clones = NULL;\n+\n+      /* Copy clone info.  */\n+      next_inline_clone->clone = node->clone;\n+\n+      /* Now place it into clone tree at same level at NODE.  */\n+      next_inline_clone->clone_of = node->clone_of;\n+      next_inline_clone->prev_sibling_clone = NULL;\n+      next_inline_clone->next_sibling_clone = NULL;\n+      if (node->clone_of)\n+\t{\n+\t  if (node->clone_of->clones)\n+\t    node->clone_of->clones->prev_sibling_clone = next_inline_clone;\n+\t  next_inline_clone->next_sibling_clone = node->clone_of->clones;\n+\t  node->clone_of->clones = next_inline_clone;\n+\t}\n+\n+      /* Merge the clone list.  */\n+      if (new_clones)\n+\t{\n+\t  if (!next_inline_clone->clones)\n+\t    next_inline_clone->clones = new_clones;\n+\t  else\n+\t    {\n+\t      n = next_inline_clone->clones;\n+\t      while (n->next_sibling_clone)\n+\t\tn =  n->next_sibling_clone;\n+\t      n->next_sibling_clone = new_clones;\n+\t      new_clones->prev_sibling_clone = n;\n+\t    }\n+\t}\n+\n+      /* Update clone_of pointers.  */\n+      n = new_clones;\n+      while (n)\n+\t{\n+\t  n->clone_of = next_inline_clone;\n+\t  n = n->next_sibling_clone;\n+\t}\n+      return replacement;\n+    }\n+  else\n+    return NULL;\n+}\n+\n+/* Like cgraph_set_call_stmt but walk the clone tree and update all\n+   clones sharing the same function body.  */\n+\n+void\n+cgraph_set_call_stmt_including_clones (struct cgraph_node *orig,\n+\t\t\t\t       gimple old_stmt, gimple new_stmt)\n+{\n+  struct cgraph_node *node;\n+  struct cgraph_edge *edge = cgraph_edge (orig, old_stmt);\n+\n+  if (edge)\n+    cgraph_set_call_stmt (edge, new_stmt);\n+\n+  node = orig->clones;\n+  if (node)\n+    while (node != orig)\n+      {\n+\tstruct cgraph_edge *edge = cgraph_edge (node, old_stmt);\n+\tif (edge)\n+\t  cgraph_set_call_stmt (edge, new_stmt);\n+\tif (node->clones)\n+\t  node = node->clones;\n+\telse if (node->next_sibling_clone)\n+\t  node = node->next_sibling_clone;\n+\telse\n+\t  {\n+\t    while (node != orig && !node->next_sibling_clone)\n+\t      node = node->clone_of;\n+\t    if (node != orig)\n+\t      node = node->next_sibling_clone;\n+\t  }\n+      }\n+}\n+\n+/* Like cgraph_create_edge walk the clone tree and update all clones sharing\n+   same function body.  If clones already have edge for OLD_STMT; only\n+   update the edge same way as cgraph_set_call_stmt_including_clones does.\n+\n+   TODO: COUNT and LOOP_DEPTH should be properly distributed based on relative\n+   frequencies of the clones.  */\n+\n+void\n+cgraph_create_edge_including_clones (struct cgraph_node *orig,\n+\t\t\t\t     struct cgraph_node *callee,\n+\t\t\t\t     gimple old_stmt,\n+\t\t\t\t     gimple stmt, gcov_type count,\n+\t\t\t\t     int freq,\n+\t\t\t\t     cgraph_inline_failed_t reason)\n+{\n+  struct cgraph_node *node;\n+  struct cgraph_edge *edge;\n+\n+  if (!cgraph_edge (orig, stmt))\n+    {\n+      edge = cgraph_create_edge (orig, callee, stmt, count, freq);\n+      edge->inline_failed = reason;\n+    }\n+\n+  node = orig->clones;\n+  if (node)\n+    while (node != orig)\n+      {\n+\tstruct cgraph_edge *edge = cgraph_edge (node, old_stmt);\n+\n+        /* It is possible that clones already contain the edge while\n+\t   master didn't.  Either we promoted indirect call into direct\n+\t   call in the clone or we are processing clones of unreachable\n+\t   master where edges has been removed.  */\n+\tif (edge)\n+\t  cgraph_set_call_stmt (edge, stmt);\n+\telse if (!cgraph_edge (node, stmt))\n+\t  {\n+\t    edge = cgraph_create_edge (node, callee, stmt, count,\n+\t\t\t\t       freq);\n+\t    edge->inline_failed = reason;\n+\t  }\n+\n+\tif (node->clones)\n+\t  node = node->clones;\n+\telse if (node->next_sibling_clone)\n+\t  node = node->next_sibling_clone;\n+\telse\n+\t  {\n+\t    while (node != orig && !node->next_sibling_clone)\n+\t      node = node->clone_of;\n+\t    if (node != orig)\n+\t      node = node->next_sibling_clone;\n+\t  }\n+      }\n+}\n+\n+/* Remove the node from cgraph and all inline clones inlined into it.\n+   Skip however removal of FORBIDDEN_NODE and return true if it needs to be\n+   removed.  This allows to call the function from outer loop walking clone\n+   tree.  */\n+\n+bool\n+cgraph_remove_node_and_inline_clones (struct cgraph_node *node, struct cgraph_node *forbidden_node)\n+{\n+  struct cgraph_edge *e, *next;\n+  bool found = false;\n+\n+  if (node == forbidden_node)\n+    return true;\n+  for (e = node->callees; e; e = next)\n+    {\n+      next = e->next_callee;\n+      if (!e->inline_failed)\n+        found |= cgraph_remove_node_and_inline_clones (e->callee, forbidden_node);\n+    }\n+  cgraph_remove_node (node);\n+  return found;\n+}\n+\n+/* The edges representing the callers of the NEW_VERSION node were\n+   fixed by cgraph_function_versioning (), now the call_expr in their\n+   respective tree code should be updated to call the NEW_VERSION.  */\n+\n+static void\n+update_call_expr (struct cgraph_node *new_version)\n+{\n+  struct cgraph_edge *e;\n+\n+  gcc_assert (new_version);\n+\n+  /* Update the call expr on the edges to call the new version.  */\n+  for (e = new_version->callers; e; e = e->next_caller)\n+    {\n+      struct function *inner_function = DECL_STRUCT_FUNCTION (e->caller->symbol.decl);\n+      gimple_call_set_fndecl (e->call_stmt, new_version->symbol.decl);\n+      maybe_clean_eh_stmt_fn (inner_function, e->call_stmt);\n+    }\n+}\n+\n+\n+/* Create a new cgraph node which is the new version of\n+   OLD_VERSION node.  REDIRECT_CALLERS holds the callers\n+   edges which should be redirected to point to\n+   NEW_VERSION.  ALL the callees edges of OLD_VERSION\n+   are cloned to the new version node.  Return the new\n+   version node. \n+\n+   If non-NULL BLOCK_TO_COPY determine what basic blocks \n+   was copied to prevent duplications of calls that are dead\n+   in the clone.  */\n+\n+struct cgraph_node *\n+cgraph_copy_node_for_versioning (struct cgraph_node *old_version,\n+\t\t\t\t tree new_decl,\n+\t\t\t\t VEC(cgraph_edge_p,heap) *redirect_callers,\n+\t\t\t\t bitmap bbs_to_copy)\n+ {\n+   struct cgraph_node *new_version;\n+   struct cgraph_edge *e;\n+   unsigned i;\n+\n+   gcc_assert (old_version);\n+\n+   new_version = cgraph_create_node (new_decl);\n+\n+   new_version->analyzed = old_version->analyzed;\n+   new_version->local = old_version->local;\n+   new_version->symbol.externally_visible = false;\n+   new_version->local.local = old_version->analyzed;\n+   new_version->global = old_version->global;\n+   new_version->rtl = old_version->rtl;\n+   new_version->count = old_version->count;\n+\n+   for (e = old_version->callees; e; e=e->next_callee)\n+     if (!bbs_to_copy\n+\t || bitmap_bit_p (bbs_to_copy, gimple_bb (e->call_stmt)->index))\n+       cgraph_clone_edge (e, new_version, e->call_stmt,\n+\t\t\t  e->lto_stmt_uid, REG_BR_PROB_BASE,\n+\t\t\t  CGRAPH_FREQ_BASE,\n+\t\t\t  true);\n+   for (e = old_version->indirect_calls; e; e=e->next_callee)\n+     if (!bbs_to_copy\n+\t || bitmap_bit_p (bbs_to_copy, gimple_bb (e->call_stmt)->index))\n+       cgraph_clone_edge (e, new_version, e->call_stmt,\n+\t\t\t  e->lto_stmt_uid, REG_BR_PROB_BASE,\n+\t\t\t  CGRAPH_FREQ_BASE,\n+\t\t\t  true);\n+   FOR_EACH_VEC_ELT (cgraph_edge_p, redirect_callers, i, e)\n+     {\n+       /* Redirect calls to the old version node to point to its new\n+\t  version.  */\n+       cgraph_redirect_edge_callee (e, new_version);\n+     }\n+\n+   cgraph_call_node_duplication_hooks (old_version, new_version);\n+\n+   return new_version;\n+ }\n+\n+/* Perform function versioning.\n+   Function versioning includes copying of the tree and\n+   a callgraph update (creating a new cgraph node and updating\n+   its callees and callers).\n+\n+   REDIRECT_CALLERS varray includes the edges to be redirected\n+   to the new version.\n+\n+   TREE_MAP is a mapping of tree nodes we want to replace with\n+   new ones (according to results of prior analysis).\n+   OLD_VERSION_NODE is the node that is versioned.\n+\n+   If non-NULL ARGS_TO_SKIP determine function parameters to remove\n+   from new version.\n+   If SKIP_RETURN is true, the new version will return void.\n+   If non-NULL BLOCK_TO_COPY determine what basic blocks to copy.\n+   If non_NULL NEW_ENTRY determine new entry BB of the clone.\n+\n+   Return the new version's cgraph node.  */\n+\n+struct cgraph_node *\n+cgraph_function_versioning (struct cgraph_node *old_version_node,\n+\t\t\t    VEC(cgraph_edge_p,heap) *redirect_callers,\n+\t\t\t    VEC (ipa_replace_map_p,gc)* tree_map,\n+\t\t\t    bitmap args_to_skip,\n+\t\t\t    bool skip_return,\n+\t\t\t    bitmap bbs_to_copy,\n+\t\t\t    basic_block new_entry_block,\n+\t\t\t    const char *clone_name)\n+{\n+  tree old_decl = old_version_node->symbol.decl;\n+  struct cgraph_node *new_version_node = NULL;\n+  tree new_decl;\n+\n+  if (!tree_versionable_function_p (old_decl))\n+    return NULL;\n+\n+  gcc_assert (old_version_node->local.can_change_signature || !args_to_skip);\n+\n+  /* Make a new FUNCTION_DECL tree node for the new version. */\n+  if (!args_to_skip && !skip_return)\n+    new_decl = copy_node (old_decl);\n+  else\n+    new_decl\n+      = build_function_decl_skip_args (old_decl, args_to_skip, skip_return);\n+\n+  /* Generate a new name for the new version. */\n+  DECL_NAME (new_decl) = clone_function_name (old_decl, clone_name);\n+  SET_DECL_ASSEMBLER_NAME (new_decl, DECL_NAME (new_decl));\n+  SET_DECL_RTL (new_decl, NULL);\n+\n+  /* When the old decl was a con-/destructor make sure the clone isn't.  */\n+  DECL_STATIC_CONSTRUCTOR(new_decl) = 0;\n+  DECL_STATIC_DESTRUCTOR(new_decl) = 0;\n+\n+  /* Create the new version's call-graph node.\n+     and update the edges of the new node. */\n+  new_version_node =\n+    cgraph_copy_node_for_versioning (old_version_node, new_decl,\n+\t\t\t\t     redirect_callers, bbs_to_copy);\n+\n+  /* Copy the OLD_VERSION_NODE function tree to the new version.  */\n+  tree_function_versioning (old_decl, new_decl, tree_map, false, args_to_skip,\n+\t\t\t    skip_return, bbs_to_copy, new_entry_block);\n+\n+  /* Update the new version's properties.\n+     Make The new version visible only within this translation unit.  Make sure\n+     that is not weak also.\n+     ??? We cannot use COMDAT linkage because there is no\n+     ABI support for this.  */\n+  symtab_make_decl_local (new_version_node->symbol.decl);\n+  DECL_VIRTUAL_P (new_version_node->symbol.decl) = 0;\n+  new_version_node->symbol.externally_visible = 0;\n+  new_version_node->local.local = 1;\n+  new_version_node->lowered = true;\n+\n+  /* Update the call_expr on the edges to call the new version node. */\n+  update_call_expr (new_version_node);\n+\n+  cgraph_call_function_insertion_hooks (new_version_node);\n+  return new_version_node;\n+}\n+\n+/* Given virtual clone, turn it into actual clone.  */\n+\n+static void\n+cgraph_materialize_clone (struct cgraph_node *node)\n+{\n+  bitmap_obstack_initialize (NULL);\n+  node->former_clone_of = node->clone_of->symbol.decl;\n+  if (node->clone_of->former_clone_of)\n+    node->former_clone_of = node->clone_of->former_clone_of;\n+  /* Copy the OLD_VERSION_NODE function tree to the new version.  */\n+  tree_function_versioning (node->clone_of->symbol.decl, node->symbol.decl,\n+  \t\t\t    node->clone.tree_map, true,\n+\t\t\t    node->clone.args_to_skip, false,\n+\t\t\t    NULL, NULL);\n+  if (cgraph_dump_file)\n+    {\n+      dump_function_to_file (node->clone_of->symbol.decl, cgraph_dump_file, dump_flags);\n+      dump_function_to_file (node->symbol.decl, cgraph_dump_file, dump_flags);\n+    }\n+\n+  /* Function is no longer clone.  */\n+  if (node->next_sibling_clone)\n+    node->next_sibling_clone->prev_sibling_clone = node->prev_sibling_clone;\n+  if (node->prev_sibling_clone)\n+    node->prev_sibling_clone->next_sibling_clone = node->next_sibling_clone;\n+  else\n+    node->clone_of->clones = node->next_sibling_clone;\n+  node->next_sibling_clone = NULL;\n+  node->prev_sibling_clone = NULL;\n+  if (!node->clone_of->analyzed && !node->clone_of->clones)\n+    {\n+      cgraph_release_function_body (node->clone_of);\n+      cgraph_node_remove_callees (node->clone_of);\n+      ipa_remove_all_references (&node->clone_of->symbol.ref_list);\n+    }\n+  node->clone_of = NULL;\n+  bitmap_obstack_release (NULL);\n+}\n+\n+/* Once all functions from compilation unit are in memory, produce all clones\n+   and update all calls.  We might also do this on demand if we don't want to\n+   bring all functions to memory prior compilation, but current WHOPR\n+   implementation does that and it is is bit easier to keep everything right in\n+   this order.  */\n+\n+void\n+cgraph_materialize_all_clones (void)\n+{\n+  struct cgraph_node *node;\n+  bool stabilized = false;\n+\n+  if (cgraph_dump_file)\n+    fprintf (cgraph_dump_file, \"Materializing clones\\n\");\n+#ifdef ENABLE_CHECKING\n+  verify_cgraph ();\n+#endif\n+\n+  /* We can also do topological order, but number of iterations should be\n+     bounded by number of IPA passes since single IPA pass is probably not\n+     going to create clones of clones it created itself.  */\n+  while (!stabilized)\n+    {\n+      stabilized = true;\n+      FOR_EACH_FUNCTION (node)\n+        {\n+\t  if (node->clone_of && node->symbol.decl != node->clone_of->symbol.decl\n+\t      && !gimple_has_body_p (node->symbol.decl))\n+\t    {\n+\t      if (gimple_has_body_p (node->clone_of->symbol.decl))\n+\t        {\n+\t\t  if (cgraph_dump_file)\n+\t\t    {\n+\t\t      fprintf (cgraph_dump_file, \"cloning %s to %s\\n\",\n+\t\t\t       xstrdup (cgraph_node_name (node->clone_of)),\n+\t\t\t       xstrdup (cgraph_node_name (node)));\n+\t\t      if (node->clone.tree_map)\n+\t\t        {\n+\t\t\t  unsigned int i;\n+\t\t          fprintf (cgraph_dump_file, \"   replace map: \");\n+\t\t\t  for (i = 0; i < VEC_length (ipa_replace_map_p,\n+\t\t\t  \t\t\t      node->clone.tree_map);\n+\t\t\t\t\t\t      i++)\n+\t\t\t    {\n+\t\t\t      struct ipa_replace_map *replace_info;\n+\t\t\t      replace_info = VEC_index (ipa_replace_map_p,\n+\t\t\t      \t\t\t\tnode->clone.tree_map,\n+\t\t\t\t\t\t\ti);\n+\t\t\t      print_generic_expr (cgraph_dump_file, replace_info->old_tree, 0);\n+\t\t\t      fprintf (cgraph_dump_file, \" -> \");\n+\t\t\t      print_generic_expr (cgraph_dump_file, replace_info->new_tree, 0);\n+\t\t\t      fprintf (cgraph_dump_file, \"%s%s;\",\n+\t\t\t      \t       replace_info->replace_p ? \"(replace)\":\"\",\n+\t\t\t\t       replace_info->ref_p ? \"(ref)\":\"\");\n+\t\t\t    }\n+\t\t\t  fprintf (cgraph_dump_file, \"\\n\");\n+\t\t\t}\n+\t\t      if (node->clone.args_to_skip)\n+\t\t\t{\n+\t\t          fprintf (cgraph_dump_file, \"   args_to_skip: \");\n+\t\t          dump_bitmap (cgraph_dump_file, node->clone.args_to_skip);\n+\t\t\t}\n+\t\t      if (node->clone.args_to_skip)\n+\t\t\t{\n+\t\t          fprintf (cgraph_dump_file, \"   combined_args_to_skip:\");\n+\t\t          dump_bitmap (cgraph_dump_file, node->clone.combined_args_to_skip);\n+\t\t\t}\n+\t\t    }\n+\t\t  cgraph_materialize_clone (node);\n+\t\t  stabilized = false;\n+\t        }\n+\t    }\n+\t}\n+    }\n+  FOR_EACH_FUNCTION (node)\n+    if (!node->analyzed && node->callees)\n+      cgraph_node_remove_callees (node);\n+  if (cgraph_dump_file)\n+    fprintf (cgraph_dump_file, \"Materialization Call site updates done.\\n\");\n+#ifdef ENABLE_CHECKING\n+  verify_cgraph ();\n+#endif\n+  cgraph_remove_unreachable_nodes (false, cgraph_dump_file);\n+}\n+\n+#include \"gt-cgraphclones.h\""}]}