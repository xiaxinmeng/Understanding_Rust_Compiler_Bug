{"sha": "edaf1e005c90b311c39b46d85cea17befbece112", "node_id": "C_kwDOANBUbNoAKGVkYWYxZTAwNWM5MGIzMTFjMzliNDZkODVjZWExN2JlZmJlY2UxMTI", "commit": {"author": {"name": "Mikael Morin", "email": "mikael@gcc.gnu.org", "date": "2022-08-29T09:19:29Z"}, "committer": {"name": "Mikael Morin", "email": "mikael@gcc.gnu.org", "date": "2022-09-25T12:44:53Z"}, "message": "fortran: Fix invalid function decl clobber ICE [PR105012]\n\nThe fortran frontend, as result symbol for a function without\ndeclared result symbol, uses the function symbol itself.  This caused\nan invalid clobber of a function decl to be emitted, leading to an\nICE, whereas the intended behaviour was to clobber the function result\nvariable.  This change fixes the problem by getting the decl from the\njust-retrieved variable reference after the call to\ngfc_conv_expr_reference, instead of copying it from the frontend symbol.\n\n\tPR fortran/105012\n\ngcc/fortran/ChangeLog:\n\n\t* trans-expr.cc (gfc_conv_procedure_call): Retrieve variable\n\tfrom the just calculated variable reference.\n\ngcc/testsuite/ChangeLog:\n\n\t* gfortran.dg/intent_out_15.f90: New test.", "tree": {"sha": "f86ab7657d2735c7f2516afdee5ca0ef58b8f29b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f86ab7657d2735c7f2516afdee5ca0ef58b8f29b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/edaf1e005c90b311c39b46d85cea17befbece112", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/edaf1e005c90b311c39b46d85cea17befbece112", "html_url": "https://github.com/Rust-GCC/gccrs/commit/edaf1e005c90b311c39b46d85cea17befbece112", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/edaf1e005c90b311c39b46d85cea17befbece112/comments", "author": null, "committer": null, "parents": [{"sha": "2b393f6f83903cb836676bbd042c1b99a6e7e6f7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2b393f6f83903cb836676bbd042c1b99a6e7e6f7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2b393f6f83903cb836676bbd042c1b99a6e7e6f7"}], "stats": {"total": 30, "additions": 29, "deletions": 1}, "files": [{"sha": "8fb63359ba500c6c50c2b1f06c42b96584a618bc", "filename": "gcc/fortran/trans-expr.cc", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/edaf1e005c90b311c39b46d85cea17befbece112/gcc%2Ffortran%2Ftrans-expr.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/edaf1e005c90b311c39b46d85cea17befbece112/gcc%2Ffortran%2Ftrans-expr.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-expr.cc?ref=edaf1e005c90b311c39b46d85cea17befbece112", "patch": "@@ -6528,7 +6528,8 @@ gfc_conv_procedure_call (gfc_se * se, gfc_symbol * sym,\n \t\t\t  tree var;\n \t\t\t  /* FIXME: This fails if var is passed by reference, see PR\n \t\t\t     41453.  */\n-\t\t\t  var = e->symtree->n.sym->backend_decl;\n+\t\t\t  var = build_fold_indirect_ref_loc (input_location,\n+\t\t\t\t\t\t\t     parmse.expr);\n \t\t\t  tree clobber = build_clobber (TREE_TYPE (var));\n \t\t\t  gfc_add_modify (&se->pre, var, clobber);\n \t\t\t}"}, {"sha": "64334e6f0388ff3cf92fa0a20202fff8659f0a43", "filename": "gcc/testsuite/gfortran.dg/intent_out_15.f90", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/edaf1e005c90b311c39b46d85cea17befbece112/gcc%2Ftestsuite%2Fgfortran.dg%2Fintent_out_15.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/edaf1e005c90b311c39b46d85cea17befbece112/gcc%2Ftestsuite%2Fgfortran.dg%2Fintent_out_15.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fintent_out_15.f90?ref=edaf1e005c90b311c39b46d85cea17befbece112", "patch": "@@ -0,0 +1,27 @@\n+! { dg-do compile }\n+! { dg-additional-options \"-fdump-tree-original\" }\n+!\n+! PR fortran/105012\n+! The following case was triggering an ICE because of a clobber\n+! on the DERFC function decl instead of its result.\n+\n+module error_function\n+integer, parameter :: r8 = selected_real_kind(12) ! 8 byte real\n+contains\n+SUBROUTINE CALERF_r8(ARG, RESULT, JINT)\n+   integer, parameter :: rk = r8\n+   real(rk), intent(in)  :: arg\n+   real(rk), intent(out) :: result\n+   IF (Y .LE. THRESH) THEN\n+   END IF\n+end SUBROUTINE CALERF_r8\n+FUNCTION DERFC(X)\n+   integer, parameter :: rk = r8 ! 8 byte real\n+   real(rk), intent(in) :: X\n+   real(rk) :: DERFC\n+   CALL CALERF_r8(X, DERFC, JINT)\n+END FUNCTION DERFC\n+end module error_function\n+\n+! { dg-final { scan-tree-dump-times \"CLOBBER\" 1 \"original\" } }\n+! { dg-final { scan-tree-dump \"__result_derfc = {CLOBBER};\" \"original\" } }"}]}