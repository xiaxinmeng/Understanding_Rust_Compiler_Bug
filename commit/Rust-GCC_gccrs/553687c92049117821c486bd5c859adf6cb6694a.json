{"sha": "553687c92049117821c486bd5c859adf6cb6694a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTUzNjg3YzkyMDQ5MTE3ODIxYzQ4NmJkNWM4NTlhZGY2Y2I2Njk0YQ==", "commit": {"author": {"name": "Bernd Schmidt", "email": "bernds@cygnus.co.uk", "date": "1999-11-30T12:16:56Z"}, "committer": {"name": "Bernd Schmidt", "email": "crux@gcc.gnu.org", "date": "1999-11-30T12:16:56Z"}, "message": "Delete obsolete macros\n\nFrom-SVN: r30723", "tree": {"sha": "9ae5e20341fac9509fe1ee49a9b5a43669a5bdcb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/9ae5e20341fac9509fe1ee49a9b5a43669a5bdcb"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/553687c92049117821c486bd5c859adf6cb6694a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/553687c92049117821c486bd5c859adf6cb6694a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/553687c92049117821c486bd5c859adf6cb6694a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/553687c92049117821c486bd5c859adf6cb6694a/comments", "author": null, "committer": null, "parents": [{"sha": "c219ddf76d46bbea8a60dc8b261fd2b17d74f35a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c219ddf76d46bbea8a60dc8b261fd2b17d74f35a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c219ddf76d46bbea8a60dc8b261fd2b17d74f35a"}], "stats": {"total": 146, "additions": 16, "deletions": 130}, "files": [{"sha": "cbff89220b166b62219ba037845aa65462c91d4d", "filename": "gcc/ChangeLog", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/553687c92049117821c486bd5c859adf6cb6694a/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/553687c92049117821c486bd5c859adf6cb6694a/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=553687c92049117821c486bd5c859adf6cb6694a", "patch": "@@ -1,3 +1,17 @@\n+1999-11-30  Bernd Schmidt  <bernds@cygnus.co.uk>\n+\n+\t* cse.c (FIXED_REGNO_P): Delete tests for OVERLAPPING_REGNO_P.\n+\t* global.c (global_alloc): Delete [OVERLAPPING_REGNO_P] code.\n+\t* reload.c (find_dummy_reload): Likewise.\n+\t(find_equiv_reg): Likewise; also for INSN_CLOBBERS_REGNO_P.\n+\t* reload1.c (reload_as_needed): Likewise.\n+\t* stupid.c (stupid_find_reg): Likewise.\n+\t* tm.texi (Obsolete Register Macros): Delete section.\n+\t* gmicro.h: Remove all traces of the two macros.\n+\t* i386.h: Likewise.\n+\t* m88k.h: Likewise.\n+\t* mips.h: Likewise.\n+\n 1999-11-30  Brendan Kehoe  <brendan@cygnus.com>\n \n \t* sparc.h (MASK_FASTER_STRUCTS, TARGET_FASTER_STRUCTS): Define."}, {"sha": "fdfc2eb286f361ac434a2a2d95e7904e31af15ff", "filename": "gcc/config/gmicro/gmicro.h", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/553687c92049117821c486bd5c859adf6cb6694a/gcc%2Fconfig%2Fgmicro%2Fgmicro.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/553687c92049117821c486bd5c859adf6cb6694a/gcc%2Fconfig%2Fgmicro%2Fgmicro.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fgmicro%2Fgmicro.h?ref=553687c92049117821c486bd5c859adf6cb6694a", "patch": "@@ -237,11 +237,6 @@ extern int target_flags;\n /*  This Macro is not defined now.\n     #define CONDITIONAL_REGISTER_USAGE */\n \n-/* The Gmicro has no overlapping register */\n-/* #define OVERLAPPING_REGNO_P(REGNO) */\n-\n-/* #define INSN_CLOBBERS_REGNO_P(INSN,REGNO)  */\n-\n /* Return number of consecutive hard regs needed starting at reg REGNO\n    to hold something of mode MODE.\n    This is ordinarily the length in words of a value of mode MODE"}, {"sha": "1ecacfc0fa11a7f7e9bb1a03b1fa535664e724f8", "filename": "gcc/config/i386/i386.h", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/553687c92049117821c486bd5c859adf6cb6694a/gcc%2Fconfig%2Fi386%2Fi386.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/553687c92049117821c486bd5c859adf6cb6694a/gcc%2Fconfig%2Fi386%2Fi386.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.h?ref=553687c92049117821c486bd5c859adf6cb6694a", "patch": "@@ -909,11 +909,6 @@ enum reg_class\n #define CC_REG_P(X) (REG_P (X) && CC_REGNO_P (REGNO (X)))\n #define CC_REGNO_P(X) ((X) == FLAGS_REG || (X) == FPSR_REG)\n \n-/* 1 if register REGNO can magically overlap other regs.\n-   Note that nonzero values work only in very special circumstances. */\n-\n-/* #define OVERLAPPING_REGNO_P(REGNO) FP_REGNO_P (REGNO) */\n-\n /* The class value for index registers, and the one for base regs.  */\n \n #define INDEX_REG_CLASS INDEX_REGS"}, {"sha": "83c402e9ce82aba16367253d1b701fbcab925969", "filename": "gcc/config/m88k/m88k.h", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/553687c92049117821c486bd5c859adf6cb6694a/gcc%2Fconfig%2Fm88k%2Fm88k.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/553687c92049117821c486bd5c859adf6cb6694a/gcc%2Fconfig%2Fm88k%2Fm88k.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm88k%2Fm88k.h?ref=553687c92049117821c486bd5c859adf6cb6694a", "patch": "@@ -628,10 +628,6 @@ extern int flag_pic;\t\t\t\t/* -fpic */\n       }\t\t\t\t\t\t\t\\\n   }\n \n-/* These interfaces that don't apply to the m88000.  */\n-/* OVERLAPPING_REGNO_P(REGNO) 0 */\n-/* INSN_CLOBBERS_REGNO_P(INSN, REGNO) 0 */\n-\n /* True if register is an extended register.  */\n #define XRF_REGNO_P(N) ((N) < FIRST_PSEUDO_REGISTER && (N) >= FIRST_EXTENDED_REGISTER)\n  "}, {"sha": "e792226a623314aa28576b98c2eb8b9ff81965e3", "filename": "gcc/config/mips/mips.h", "status": "modified", "additions": 0, "deletions": 14, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/553687c92049117821c486bd5c859adf6cb6694a/gcc%2Fconfig%2Fmips%2Fmips.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/553687c92049117821c486bd5c859adf6cb6694a/gcc%2Fconfig%2Fmips%2Fmips.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips.h?ref=553687c92049117821c486bd5c859adf6cb6694a", "patch": "@@ -2022,20 +2022,6 @@ extern enum reg_class mips_char_to_class[];\n \n #define CLASS_CANNOT_CHANGE_SIZE\t\t\t\t\t\\\n   (TARGET_FLOAT64 && ! TARGET_64BIT ? FP_REGS : NO_REGS)\n-\n-/* If defined, this is a C expression whose value should be\n-   nonzero if the insn INSN has the effect of mysteriously\n-   clobbering the contents of hard register number REGNO.  By\n-   \"mysterious\" we mean that the insn's RTL expression doesn't\n-   describe such an effect.\n-\n-   If this macro is not defined, it means that no insn clobbers\n-   registers mysteriously.  This is the usual situation; all else\n-   being equal, it is best for the RTL expression to show all the\n-   activity.  */\n-\n-/* #define INSN_CLOBBERS_REGNO_P(INSN, REGNO) */\n-\n \f\n /* Stack layout; function entry, exit and calling.  */\n "}, {"sha": "86797087aea292afffe31882a75487ebc72706c2", "filename": "gcc/cse.c", "status": "modified", "additions": 1, "deletions": 9, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/553687c92049117821c486bd5c859adf6cb6694a/gcc%2Fcse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/553687c92049117821c486bd5c859adf6cb6694a/gcc%2Fcse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcse.c?ref=553687c92049117821c486bd5c859adf6cb6694a", "patch": "@@ -462,18 +462,10 @@ struct table_elt\n /* Determine whether register number N is considered a fixed register for CSE.\n    It is desirable to replace other regs with fixed regs, to reduce need for\n    non-fixed hard regs.\n-   A reg wins if it is either the frame pointer or designated as fixed,\n-   but not if it is an overlapping register.  */\n-#ifdef OVERLAPPING_REGNO_P\n-#define FIXED_REGNO_P(N)  \\\n-  (((N) == FRAME_POINTER_REGNUM || (N) == HARD_FRAME_POINTER_REGNUM \\\n-    || fixed_regs[N] || global_regs[N])\t  \\\n-   && ! OVERLAPPING_REGNO_P ((N)))\n-#else\n+   A reg wins if it is either the frame pointer or designated as fixed.  */\n #define FIXED_REGNO_P(N)  \\\n   ((N) == FRAME_POINTER_REGNUM || (N) == HARD_FRAME_POINTER_REGNUM \\\n    || fixed_regs[N] || global_regs[N])\n-#endif\n \n /* Compute cost of X, as stored in the `cost' field of a table_elt.  Fixed\n    hard registers and pointers into the frame are the cheapest with a cost"}, {"sha": "d9878d79c45a59e4a26d3bbd9ae8db4e100bc829", "filename": "gcc/global.c", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/553687c92049117821c486bd5c859adf6cb6694a/gcc%2Fglobal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/553687c92049117821c486bd5c859adf6cb6694a/gcc%2Fglobal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fglobal.c?ref=553687c92049117821c486bd5c859adf6cb6694a", "patch": "@@ -337,11 +337,6 @@ global_alloc (file)\n      are safe to use only within a basic block.  */\n \n   CLEAR_HARD_REG_SET (no_global_alloc_regs);\n-#ifdef OVERLAPPING_REGNO_P\n-  for (i = 0; i < FIRST_PSEUDO_REGISTER; i++)\n-    if (OVERLAPPING_REGNO_P (i))\n-      SET_HARD_REG_BIT (no_global_alloc_regs, i);\n-#endif\n \n   /* Build the regset of all eliminable registers and show we can't use those\n      that we already know won't be eliminated.  */"}, {"sha": "dba0aeed378767c2bdfaec905e32a2c920ca70e1", "filename": "gcc/reload.c", "status": "modified", "additions": 0, "deletions": 30, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/553687c92049117821c486bd5c859adf6cb6694a/gcc%2Freload.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/553687c92049117821c486bd5c859adf6cb6694a/gcc%2Freload.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freload.c?ref=553687c92049117821c486bd5c859adf6cb6694a", "patch": "@@ -1842,11 +1842,6 @@ find_dummy_reload (real_in, real_out, inloc, outloc,\n       *inloc = const0_rtx;\n \n       if (regno < FIRST_PSEUDO_REGISTER\n-\t  /* A fixed reg that can overlap other regs better not be used\n-\t     for reloading in any way.  */\n-#ifdef OVERLAPPING_REGNO_P\n-\t  && ! (fixed_regs[regno] && OVERLAPPING_REGNO_P (regno))\n-#endif\n \t  && ! refers_to_regno_for_reload_p (regno, regno + nwords,\n \t\t\t\t\t     PATTERN (this_insn), outloc))\n \t{\n@@ -6042,15 +6037,6 @@ find_equiv_reg (goal, insn, class, other, reload_reg_p, goalreg, mode)\n   else\n     return 0;\n \n-  /* On some machines, certain regs must always be rejected\n-     because they don't behave the way ordinary registers do.  */\n-\n-#ifdef OVERLAPPING_REGNO_P\n-  if (regno >= 0 && regno < FIRST_PSEUDO_REGISTER\n-      && OVERLAPPING_REGNO_P (regno))\n-    return 0;\n-#endif\n-\n   /* Scan insns back from INSN, looking for one that copies\n      a value into or out of GOAL.\n      Stop and give up if we reach a label.  */\n@@ -6189,14 +6175,6 @@ find_equiv_reg (goal, insn, class, other, reload_reg_p, goalreg, mode)\n       && reload_reg_p[valueno] >= 0)\n     return 0;\n \n-  /* On some machines, certain regs must always be rejected\n-     because they don't behave the way ordinary registers do.  */\n-\n-#ifdef OVERLAPPING_REGNO_P\n-  if (OVERLAPPING_REGNO_P (valueno))\n-    return 0;\n-#endif\n-\n   nregs = HARD_REGNO_NREGS (regno, mode);\n   valuenregs = HARD_REGNO_NREGS (valueno, mode);\n \n@@ -6252,14 +6230,6 @@ find_equiv_reg (goal, insn, class, other, reload_reg_p, goalreg, mode)\n \treturn 0;\n #endif\n \n-#ifdef INSN_CLOBBERS_REGNO_P\n-      if ((valueno >= 0 && valueno < FIRST_PSEUDO_REGISTER\n-\t   && INSN_CLOBBERS_REGNO_P (p, valueno))\n-\t  || (regno >= 0 && regno < FIRST_PSEUDO_REGISTER\n-\t      && INSN_CLOBBERS_REGNO_P (p, regno)))\n-\treturn 0;\n-#endif\n-\n       if (GET_RTX_CLASS (GET_CODE (p)) == 'i')\n \t{\n \t  pat = PATTERN (p);"}, {"sha": "214b41355cd76a9806ba2a52730eab40a8e7cc04", "filename": "gcc/reload1.c", "status": "modified", "additions": 1, "deletions": 11, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/553687c92049117821c486bd5c859adf6cb6694a/gcc%2Freload1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/553687c92049117821c486bd5c859adf6cb6694a/gcc%2Freload1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freload1.c?ref=553687c92049117821c486bd5c859adf6cb6694a", "patch": "@@ -4302,7 +4302,7 @@ reload_as_needed (live_known)\n      int live_known;\n {\n   struct insn_chain *chain;\n-#if defined (AUTO_INC_DEC) || defined (INSN_CLOBBERS_REGNO_P)\n+#if defined (AUTO_INC_DEC)\n   register int i;\n #endif\n   rtx x;\n@@ -4562,16 +4562,6 @@ reload_as_needed (live_known)\n \t if it is a call-used reg.  */\n       else if (GET_CODE (insn) == CALL_INSN)\n \tAND_COMPL_HARD_REG_SET(reg_reloaded_valid, call_used_reg_set);\n-\n-      /* In case registers overlap, allow certain insns to invalidate\n-\t particular hard registers.  */\n-\n-#ifdef INSN_CLOBBERS_REGNO_P\n-      for (i = 0 ; i < FIRST_PSEUDO_REGISTER; i++)\n-\tif (TEST_HARD_REG_BIT (reg_reloaded_valid, i)\n-\t    && INSN_CLOBBERS_REGNO_P (insn, i))\n-\t  CLEAR_HARD_REG_BIT (reg_reloaded_valid, i);\n-#endif\n     }\n \n   /* Clean up.  */"}, {"sha": "61bac12d597beab68b60be79dd8ca46c30a32774", "filename": "gcc/stupid.c", "status": "modified", "additions": 0, "deletions": 9, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/553687c92049117821c486bd5c859adf6cb6694a/gcc%2Fstupid.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/553687c92049117821c486bd5c859adf6cb6694a/gcc%2Fstupid.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fstupid.c?ref=553687c92049117821c486bd5c859adf6cb6694a", "patch": "@@ -542,15 +542,6 @@ stupid_find_reg (call_preserved, class, mode,\n       int regno = i;\n #endif\n \n-      /* If a register has screwy overlap problems,\n-\t don't use it at all if not optimizing.\n-\t Actually this is only for the 387 stack register,\n-\t and it's because subsequent code won't work.  */\n-#ifdef OVERLAPPING_REGNO_P\n-      if (OVERLAPPING_REGNO_P (regno))\n-\tcontinue;\n-#endif\n-\n       if (! TEST_HARD_REG_BIT (used, regno)\n \t  && HARD_REGNO_MODE_OK (regno, mode))\n \t{"}, {"sha": "4b8193d7565ceb666c0101702b971e2bda567060", "filename": "gcc/tm.texi", "status": "modified", "additions": 0, "deletions": 38, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/553687c92049117821c486bd5c859adf6cb6694a/gcc%2Ftm.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/553687c92049117821c486bd5c859adf6cb6694a/gcc%2Ftm.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftm.texi?ref=553687c92049117821c486bd5c859adf6cb6694a", "patch": "@@ -1307,7 +1307,6 @@ For returning values in registers, see @ref{Scalar Return}.\n * Values in Registers::\t\tWhat kinds of values each reg can hold.\n * Leaf Functions::\t\tRenumbering registers for leaf functions.\n * Stack Registers::\t\tHandling a register stack such as 80387.\n-* Obsolete Register Macros::\tMacros formerly used for the 80387.\n @end menu\n \n @node Register Basics\n@@ -1689,43 +1688,6 @@ The number of the last stack-like register.  This one is the bottom of\n the stack.\n @end table\n \n-@node Obsolete Register Macros\n-@subsection Obsolete Macros for Controlling Register Usage\n-\n-These features do not work very well.  They exist because they used to\n-be required to generate correct code for the 80387 coprocessor of the\n-80386.  They are no longer used by that machine description and may be\n-removed in a later version of the compiler.  Don't use them!\n-\n-@table @code\n-@findex OVERLAPPING_REGNO_P\n-@item OVERLAPPING_REGNO_P (@var{regno})\n-If defined, this is a C expression whose value is nonzero if hard\n-register number @var{regno} is an overlapping register.  This means a\n-hard register which overlaps a hard register with a different number.\n-(Such overlap is undesirable, but occasionally it allows a machine to\n-be supported which otherwise could not be.)  This macro must return\n-nonzero for @emph{all} the registers which overlap each other.  GCC\n-can use an overlapping register only in certain limited ways.  It can\n-be used for allocation within a basic block, and may be spilled for\n-reloading; that is all.\n-\n-If this macro is not defined, it means that none of the hard registers\n-overlap each other.  This is the usual situation.\n-\n-@findex INSN_CLOBBERS_REGNO_P\n-@item INSN_CLOBBERS_REGNO_P (@var{insn}, @var{regno})\n-If defined, this is a C expression whose value should be nonzero if\n-the insn @var{insn} has the effect of mysteriously clobbering the\n-contents of hard register number @var{regno}.  By ``mysterious'' we\n-mean that the insn's RTL expression doesn't describe such an effect.\n-\n-If this macro is not defined, it means that no insn clobbers registers\n-mysteriously.  This is the usual situation; all else being equal,\n-it is best for the RTL expression to show all the activity.\n-\n-@end table\n-\n @node Register Classes\n @section Register Classes\n @cindex register class definitions"}]}