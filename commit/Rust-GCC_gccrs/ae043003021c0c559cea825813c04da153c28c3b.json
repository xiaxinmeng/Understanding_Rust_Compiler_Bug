{"sha": "ae043003021c0c559cea825813c04da153c28c3b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YWUwNDMwMDMwMjFjMGM1NTljZWE4MjU4MTNjMDRkYTE1M2MyOGMzYg==", "commit": {"author": {"name": "Richard Sandiford", "email": "rsandifo@redhat.com", "date": "2004-08-19T18:44:32Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2004-08-19T18:44:32Z"}, "message": "re PR target/16446 (Irix calling conventions for complex numbers)\n\n\tPR target/16446\n\t* config/mips/mips.c (struct mips_arg_info): Delete num_bytes.\n\t(mips_arg_info): Update accordingly.  Remove common treatment of fpr_p;\n\ttreat each ABI separately.  Deal with n32/n64 complex float arguments.\n\t(function_arg): Add associated complex handling here.\n\nFrom-SVN: r86259", "tree": {"sha": "591262b9a14f5af77ebd7decb4f4e29345de89f0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/591262b9a14f5af77ebd7decb4f4e29345de89f0"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ae043003021c0c559cea825813c04da153c28c3b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ae043003021c0c559cea825813c04da153c28c3b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ae043003021c0c559cea825813c04da153c28c3b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ae043003021c0c559cea825813c04da153c28c3b/comments", "author": null, "committer": null, "parents": [{"sha": "e3f92d3b7d8ef96a9420223eac37c0ece1921e97", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e3f92d3b7d8ef96a9420223eac37c0ece1921e97", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e3f92d3b7d8ef96a9420223eac37c0ece1921e97"}], "stats": {"total": 157, "additions": 112, "deletions": 45}, "files": [{"sha": "cf8fd9253dd3415f83e51a1d74aee0f2d5f69af8", "filename": "gcc/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ae043003021c0c559cea825813c04da153c28c3b/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ae043003021c0c559cea825813c04da153c28c3b/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=ae043003021c0c559cea825813c04da153c28c3b", "patch": "@@ -1,3 +1,11 @@\n+2004-08-19  Richard Sandiford  <rsandifo@redhat.com>\n+\n+\tPR target/16446\n+\t* config/mips/mips.c (struct mips_arg_info): Delete num_bytes.\n+\t(mips_arg_info): Update accordingly.  Remove common treatment of fpr_p;\n+\ttreat each ABI separately.  Deal with n32/n64 complex float arguments.\n+\t(function_arg): Add associated complex handling here.\n+\n 2004-08-19  Richard Henderson  <rth@redhat.com>\n \n \t* config/arm/arm.c (arm_gen_load_multiple): Use"}, {"sha": "29bee9c7bcd29f758f2a7139eba8e8179b0a14e8", "filename": "gcc/config/mips/mips.c", "status": "modified", "additions": 104, "deletions": 45, "changes": 149, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ae043003021c0c559cea825813c04da153c28c3b/gcc%2Fconfig%2Fmips%2Fmips.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ae043003021c0c559cea825813c04da153c28c3b/gcc%2Fconfig%2Fmips%2Fmips.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips.c?ref=ae043003021c0c559cea825813c04da153c28c3b", "patch": "@@ -330,9 +330,6 @@ struct mips_arg_info\n      would have been if we hadn't run out of registers.  */\n   bool fpr_p;\n \n-  /* The argument's size, in bytes.  */\n-  unsigned int num_bytes;\n-\n   /* The number of words passed in registers, rounded up.  */\n   unsigned int reg_words;\n \n@@ -2957,50 +2954,96 @@ mips_arg_info (const CUMULATIVE_ARGS *cum, enum machine_mode mode,\n \t       tree type, int named, struct mips_arg_info *info)\n {\n   bool even_reg_p;\n-  unsigned int num_words, max_regs;\n+  unsigned int num_bytes, num_words, max_regs;\n \n-  /* Decide whether this argument should go in a floating-point register,\n-     assuming one is free.  Later code checks for availability.  */\n+  /* Work out the size of the argument.  */\n+  num_bytes = type ? int_size_in_bytes (type) : GET_MODE_SIZE (mode);\n+  num_words = (num_bytes + UNITS_PER_WORD - 1) / UNITS_PER_WORD;\n \n-  info->fpr_p = (GET_MODE_CLASS (mode) == MODE_FLOAT\n-\t\t && GET_MODE_SIZE (mode) <= UNITS_PER_FPVALUE);\n+  /* Decide whether it should go in a floating-point register, assuming\n+     one is free.  Later code checks for availability.\n \n-  if (info->fpr_p)\n-    switch (mips_abi)\n-      {\n-      case ABI_32:\n-      case ABI_O64:\n-\tinfo->fpr_p = (!cum->gp_reg_found\n-\t\t       && cum->arg_number < 2\n-\t\t       && (type == 0 || FLOAT_TYPE_P (type)));\n-\tbreak;\n+     The checks against UNITS_PER_FPVALUE handle the soft-float and\n+     single-float cases.  */\n+  switch (mips_abi)\n+    {\n+    case ABI_EABI:\n+      /* The EABI conventions have traditionally been defined in terms\n+\t of TYPE_MODE, regardless of the actual type.  */\n+      info->fpr_p = (GET_MODE_CLASS (mode) == MODE_FLOAT\n+\t\t     && GET_MODE_SIZE (mode) <= UNITS_PER_FPVALUE);\n+      break;\n \n-      case ABI_N32:\n-      case ABI_64:\n-\tinfo->fpr_p = (named && (type == 0 || FLOAT_TYPE_P (type)));\n-\tbreak;\n-      }\n+    case ABI_32:\n+    case ABI_O64:\n+      /* Only leading floating-point scalars are passed in\n+\t floating-point registers.  */\n+      info->fpr_p = (!cum->gp_reg_found\n+\t\t     && cum->arg_number < 2\n+\t\t     && (type == 0 || SCALAR_FLOAT_TYPE_P (type))\n+\t\t     && GET_MODE_CLASS (mode) == MODE_FLOAT\n+\t\t     && GET_MODE_SIZE (mode) <= UNITS_PER_FPVALUE);\n+      break;\n \n-  /* Now decide whether the argument must go in an even-numbered register.  */\n+    case ABI_N32:\n+    case ABI_64:\n+      /* Scalar and complex floating-point types are passed in\n+\t floating-point registers.  */\n+      info->fpr_p = (named\n+\t\t     && (type == 0 || FLOAT_TYPE_P (type))\n+\t\t     && (GET_MODE_CLASS (mode) == MODE_FLOAT\n+\t\t\t || GET_MODE_CLASS (mode) == MODE_COMPLEX_FLOAT)\n+\t\t     && GET_MODE_UNIT_SIZE (mode) <= UNITS_PER_FPVALUE);\n+\n+      /* ??? According to the ABI documentation, the real and imaginary\n+\t parts of complex floats should be passed in individual registers.\n+\t The real and imaginary parts of stack arguments are supposed\n+\t to be contiguous and there should be an extra word of padding\n+\t at the end.\n+\n+\t This has two problems.  First, it makes it impossible to use a\n+\t single \"void *\" va_list type, since register and stack arguments\n+\t are passed differently.  (At the time of writing, MIPSpro cannot\n+\t handle complex float varargs correctly.)  Second, it's unclear\n+\t hat should happen when there is only one register free.\n+\n+\t For now, we assume that named complex floats should go into FPRs\n+\t if there are two FPRs free, otherwise they should be passed in the\n+\t same way as a struct containing two floats.  */\n+      if (info->fpr_p\n+\t  && GET_MODE_CLASS (mode) == MODE_COMPLEX_FLOAT\n+\t  && GET_MODE_UNIT_SIZE (mode) < UNITS_PER_FPVALUE)\n+\t{\n+\t  if (cum->num_gprs >= MAX_ARGS_IN_REGISTERS - 1)\n+\t    info->fpr_p = false;\n+\t  else\n+\t    num_words = 2;\n+\t}\n+      break;\n \n-  even_reg_p = false;\n-  if (info->fpr_p)\n-    {\n-      /* Under the O64 ABI, the second float argument goes in $f13 if it\n-\t is a double, but $f14 if it is a single.  Otherwise, on a\n-\t 32-bit double-float machine, each FP argument must start in a\n-\t new register pair.  */\n-      even_reg_p = (GET_MODE_SIZE (mode) > UNITS_PER_HWFPVALUE\n-\t\t    || (mips_abi == ABI_O64 && mode == SFmode)\n-\t\t    || FP_INC > 1);\n+    default:\n+      abort ();\n     }\n-  else if (!TARGET_64BIT || LONG_DOUBLE_TYPE_SIZE == 128)\n-    {\n-      if (GET_MODE_CLASS (mode) == MODE_INT\n-\t  || GET_MODE_CLASS (mode) == MODE_FLOAT)\n-\teven_reg_p = (GET_MODE_SIZE (mode) > UNITS_PER_WORD);\n \n-      else if (type != NULL_TREE && TYPE_ALIGN (type) > BITS_PER_WORD)\n+  /* Now decide whether the argument must go in an even-numbered register.\n+     Usually this is determined by type alignment, but there are two\n+     exceptions:\n+\n+     - Under the O64 ABI, the second float argument goes in $f14 if it\n+       is single precision (doubles go in $f13 as expected).\n+\n+     - Floats passed in FPRs must be in an even-numbered register if\n+       we're using paired FPRs.  */\n+  if (type)\n+    even_reg_p = TYPE_ALIGN (type) > BITS_PER_WORD;\n+  else\n+    even_reg_p = GET_MODE_UNIT_SIZE (mode) > UNITS_PER_WORD;\n+\n+  if (info->fpr_p)\n+    {\n+      if (mips_abi == ABI_O64 && mode == SFmode)\n+\teven_reg_p = true;\n+      if (FP_INC > 1)\n \teven_reg_p = true;\n     }\n \n@@ -3019,12 +3062,6 @@ mips_arg_info (const CUMULATIVE_ARGS *cum, enum machine_mode mode,\n   if (even_reg_p)\n     info->stack_offset += info->stack_offset & 1;\n \n-  if (mode == BLKmode)\n-    info->num_bytes = int_size_in_bytes (type);\n-  else\n-    info->num_bytes = GET_MODE_SIZE (mode);\n-\n-  num_words = (info->num_bytes + UNITS_PER_WORD - 1) / UNITS_PER_WORD;\n   max_regs = MAX_ARGS_IN_REGISTERS - info->reg_offset;\n \n   /* Partition the argument between registers and stack.  */\n@@ -3154,6 +3191,28 @@ function_arg (const CUMULATIVE_ARGS *cum, enum machine_mode mode,\n \t}\n     }\n \n+  /* Handle the n32/n64 conventions for passing complex floating-point\n+     arguments in FPR pairs.  The real part goes in the lower register\n+     and the imaginary part goes in the upper register.  */\n+  if (TARGET_NEWABI\n+      && info.fpr_p\n+      && GET_MODE_CLASS (mode) == MODE_COMPLEX_FLOAT)\n+    {\n+      rtx real, imag;\n+      enum machine_mode inner;\n+      int reg;\n+\n+      inner = GET_MODE_INNER (mode);\n+      reg = FP_ARG_FIRST + info.reg_offset;\n+      real = gen_rtx_EXPR_LIST (VOIDmode,\n+\t\t\t\tgen_rtx_REG (inner, reg),\n+\t\t\t\tconst0_rtx);\n+      imag = gen_rtx_EXPR_LIST (VOIDmode,\n+\t\t\t\tgen_rtx_REG (inner, reg + info.reg_words / 2),\n+\t\t\t\tGEN_INT (GET_MODE_SIZE (inner)));\n+      return gen_rtx_PARALLEL (mode, gen_rtvec (2, real, imag));\n+    }\n+\n   if (info.fpr_p)\n     return gen_rtx_REG (mode, FP_ARG_FIRST + info.reg_offset);\n   else"}]}