{"sha": "876c09d3a83e228ad140f59c370098eff5bb052d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODc2YzA5ZDNhODNlMjI4YWQxNDBmNTljMzcwMDk4ZWZmNWJiMDUyZA==", "commit": {"author": {"name": "Jim Wilson", "email": "wilson@gcc.gnu.org", "date": "1994-01-13T23:51:54Z"}, "committer": {"name": "Jim Wilson", "email": "wilson@gcc.gnu.org", "date": "1994-01-13T23:51:54Z"}, "message": "(enum cmp_type): Add 64 bit support.\n\n(enum processor_type): Add PROCESSOR_R4600.\n(MASK_64BIT, TARGET_64BIT): New mask bit, to indicate 64 bit mode.\n(HAVE_64BIT_P, OPTIMIZATION_OPTIONS): Delete.\n(CPP_SPEC): Don't abort if not defined.\n(CC1_SPEC): -mips1 and -mips2 imply -mfp32. -mips3 implies -mfp64.\n(CPP_SPEC): Define __SIZE_TYPE__, __PTRDIFF_TYPE__, and __mips.\n(BITS_PER_WORD, UNITS_PER_WORD, INT_SIZE_TYPE, LONG_TYPE_SIZE,\nLONG_LONG_TYPE_SIZE, POINTER_SIZE, POINTER_BOUNDARY,\nPARM_BOUNDARY, EMPTY_FIELD_BOUNDARY, HARD_REGNO_NREGS,\nCONST_OK_FOR_LETTER_P, STACK_ARGS_ADJUST, FUNCTION_PROFILER,\nTRAMPOLINE_TEMPLATE, TRAMPOLINE_SIZE, TRAMPOLINE_ALIGNMENT,\nINITIALIZE_TRAMPOLINE, CASE_VECTOR_MODE, MOVE_MAX,\nTRULY_NOOP_TRUNCATION, Pmode, FUNCTION_MODE,\nASM_OUTPUT_ADDR_VEC_ELT, ASM_OUTPUT_ADDR_DIFF_ELT,\nASM_OUTPUT_REG_PUSH, ASM_OUTPUT_REG_POP): Add 64 bit support.\n(MAX_BITS_PER_WORD, MAX_UNITS_PER_WORD, UNITS_PER_FPREG,\nMAX_INT_TYPE_SIZE, MAX_WCHAR_TYPE_SIZE, MAX_LONG_TYPE_SIZE,\nMAX_MOVE_MAX): Define.\n(INDEX_REG_CLASS): NO_REGS not GR_REGS.\n(CONST_DOUBLE_OK_FOR_LETTER_P): Don't examine CONST_DOUBLE\ninternals.\n(PREFERRED_RELOAD_CLASS): Return CLASS if it isn't ALL_REGS.\n(TRANSFER_FROM_TRAMPOLINE, ASM_OUTPUT_CASE_LABEL): Delete.\n(REGNO_OK_FOR_INDEX_P, REG_OK_FOR_INDEX_P): Redefine to 0.\n(GO_IF_LEGITIMATE_ADDRESS): Delete redundant code0 == REG test.\n(ENCODE_SECTION_INFO): Don't test mips_section_threshold.\n(CONST_COSTS): CONST_INT have cost 0 not CONSTS_N_INSNS (0).  Pass\naddress not MEM to eliminate_constant_term.  Add 64 bit support.\n(MEMORY_MOVE_COST, ASM_OUTPUT_DOUBLE_INT): Define.\n(EXTRA_SECTIONS): Delete in_last_p1.\n(SELECT_RTX_SECTION): Delete division by BITS_PER_UNIT.\n(NO_BUILTIN_SIZE_TYPE, NO_BUILTIN_PTRDIFF_TYPE): Define.\n(SIZE_TYPE, PTRDIFF_TYPE): Add 64 bit support.\n\nFrom-SVN: r6392", "tree": {"sha": "afb44b9d22d9e980fac1dcce1ff2f6d463ef1d1d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/afb44b9d22d9e980fac1dcce1ff2f6d463ef1d1d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/876c09d3a83e228ad140f59c370098eff5bb052d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/876c09d3a83e228ad140f59c370098eff5bb052d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/876c09d3a83e228ad140f59c370098eff5bb052d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/876c09d3a83e228ad140f59c370098eff5bb052d/comments", "author": null, "committer": null, "parents": [{"sha": "147255d877091f864506da47ae1ff766725bfe06", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/147255d877091f864506da47ae1ff766725bfe06", "html_url": "https://github.com/Rust-GCC/gccrs/commit/147255d877091f864506da47ae1ff766725bfe06"}], "stats": {"total": 351, "additions": 197, "deletions": 154}, "files": [{"sha": "efd6d00c964649f13fd41d92b1af26b3cebe5a37", "filename": "gcc/config/mips/mips.h", "status": "modified", "additions": 197, "deletions": 154, "changes": 351, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/876c09d3a83e228ad140f59c370098eff5bb052d/gcc%2Fconfig%2Fmips%2Fmips.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/876c09d3a83e228ad140f59c370098eff5bb052d/gcc%2Fconfig%2Fmips%2Fmips.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips.h?ref=876c09d3a83e228ad140f59c370098eff5bb052d", "patch": "@@ -1,7 +1,9 @@\n /* Definitions of target machine for GNU compiler.  MIPS version.\n-   Copyright (C) 1989, 1990, 1991, 1992, 1993 Free Software Foundation, Inc.\n    Contributed by   A. Lichnewsky,\tlich@inria.inria.fr\n    Changed by Michael Meissner,\t\tmeissner@osf.org\n+   64 bit r4000 support by Ian Lance Taylor, ian@cygnus.com, and\n+   Brendan Eich, brendan@microunity.com.\n+   Copyright (C) 1989, 1990, 1991, 1992, 1993 Free Software Foundation, Inc.\n \n This file is part of GNU CC.\n \n@@ -44,7 +46,8 @@ extern char    *version_string;\n \n /* comparison type */\n enum cmp_type {\n-  CMP_SI,\t\t\t\t/* compare integers */\n+  CMP_SI,\t\t\t\t/* compare four byte integers */\n+  CMP_DI,\t\t\t\t/* compare eight byte integers */\n   CMP_SF,\t\t\t\t/* compare single precision floats */\n   CMP_DF,\t\t\t\t/* compare double precision floats */\n   CMP_MAX\t\t\t\t/* max comparison type */\n@@ -67,7 +70,8 @@ enum processor_type {\n   PROCESSOR_DEFAULT,\n   PROCESSOR_R3000,\n   PROCESSOR_R6000,\n-  PROCESSOR_R4000\n+  PROCESSOR_R4000,\n+  PROCESSOR_R4600\n };\n \n /* Recast the cpu class to be the cpu attribute.  */\n@@ -243,7 +247,7 @@ extern char\t       *mktemp ();\n \n \t\t\t\t\t/* Bits for real switches */\n #define MASK_INT64\t0x00000001\t/* ints are 64 bits */\n-#define MASK_LONG64\t0x00000002\t/* longs are 64 bits */\n+#define MASK_LONG64\t0x00000002\t/* longs and pointers are 64 bits */\n #define MASK_LLONG128\t0x00000004\t/* long longs are 128 bits */\n #define MASK_GPOPT\t0x00000008\t/* Optimize for global pointer */\n #define MASK_GAS\t0x00000010\t/* Gas used instead of MIPS as */\n@@ -255,13 +259,13 @@ extern char\t       *mktemp ();\n #define MASK_ABICALLS\t0x00000400\t/* emit .abicalls/.cprestore/.cpload */\n #define MASK_HALF_PIC\t0x00000800\t/* Emit OSF-style pic refs to externs*/\n #define MASK_LONG_CALLS\t0x00001000\t/* Always call through a register */\n-#define MASK_UNUSED1\t0x00002000\n-#define MASK_UNUSED2\t0x00004000\n-#define MASK_UNUSED3\t0x00008000\n-#define MASK_UNUSED4\t0x00010000\n-#define MASK_UNUSED5\t0x00020000\n-#define MASK_UNUSED6\t0x00040000\n-#define MASK_UNUSED7\t0x00080000\n+#define MASK_64BIT\t0x00002000\t/* Use 64 bit registers and insns */\n+#define MASK_UNUSED1\t0x00004000\n+#define MASK_UNUSED2\t0x00008000\n+#define MASK_UNUSED3\t0x00010000\n+#define MASK_UNUSED4\t0x00020000\n+#define MASK_UNUSED5\t0x00040000\n+#define MASK_UNUSED6\t0x00080000\n \n \t\t\t\t\t/* Dummy switches used only in spec's*/\n #define MASK_MIPS_TFILE\t0x00000000\t/* flag for mips-tfile usage */\n@@ -284,6 +288,7 @@ extern char\t       *mktemp ();\n #define TARGET_LONG64\t\t(target_flags & MASK_LONG64)\n #define TARGET_LLONG128\t\t(target_flags & MASK_LLONG128)\n #define TARGET_FLOAT64\t\t(target_flags & MASK_FLOAT64)\n+#define TARGET_64BIT\t\t(target_flags & MASK_64BIT)\n \n \t\t\t\t\t/* Mips vs. GNU assembler */\n #define TARGET_GAS\t\t(target_flags & MASK_GAS)\n@@ -414,9 +419,20 @@ extern char\t       *mktemp ();\n    depending on the instruction set architecture level.  */\n \n #define BRANCH_LIKELY_P()\t(mips_isa >= 2)\n-#define HAVE_64BIT_P()\t\t(mips_isa >= 3)\n #define HAVE_SQRT_P()\t\t(mips_isa >= 2)\n \n+/* If mips_isa >= 3, then override_options will set MASK_64BIT\n+   in target_flags.  This is in target_flags, not mips_isa, because\n+   the gen* programs link code that refers to it, and they don't have\n+   mips_isa.  They don't actually use the information in target_flags;\n+   they just refer to it.\n+\n+   Setting mips_isa >= 3 will cause gcc to assume that registers are\n+   64 bits wide.  int, long and void * will be 32 bit; this may be\n+   changed with -mint64 or -mlong64.\n+\n+   CC1_SPEC causes -mips3 to set -mfp64, and -mips1 or -mips2 to set -mfp32.\n+   This can be overridden by an explicit -mfp32 or -mfp64.  */\n \f\n /* Switch  Recognition by gcc.c.  Add -G xx support */\n \n@@ -477,23 +493,6 @@ do\t\t\t\t\t\t\t\t\t\\\n   }\t\t\t\t\t\t\t\t\t\\\n while (0)\n \n-\n-/* Some machines may desire to change what optimizations are\n-   performed for various optimization levels.   This macro, if\n-   defined, is executed once just after the optimization level is\n-   determined and before the remainder of the command options have\n-   been parsed.  Values set in this macro are used as the default\n-   values for the other command line options.\n-\n-   LEVEL is the optimization level specified; 2 if -O2 is\n-   specified, 1 if -O is specified, and 0 if neither is specified.  */\n-\n-#define OPTIMIZATION_OPTIONS(LEVEL)\t\t\t\t\t\\\n-{\t\t\t\t\t\t\t\t\t\\\n-  if (LEVEL)\t\t\t\t\t\t\t\t\\\n-    target_flags |= MASK_GPOPT;\t\t\t\t\t\\\n-}\n-\n /* Show we can debug even without a frame pointer.  */\n #define CAN_DEBUG_WITHOUT_FP\n \f\n@@ -513,10 +512,6 @@ while (0)\n \t#error \"Define CPP_PREDEFINES in the appropriate tm.h file\"\n #endif\n \n-#ifndef CPP_SPEC\n-\t#error \"Define CPP_SPEC in the appropriate tm.h file\"\n-#endif\n-\n #ifndef LINK_SPEC\n \t#error \"Define LINK_SPEC in the appropriate tm.h file\"\n #endif\n@@ -625,6 +620,7 @@ while (0)\n #ifndef CC1_SPEC\n #define CC1_SPEC \"\\\n %{gline:%{!g:%{!g0:%{!g1:%{!g2: -g1}}}}} \\\n+%{mips1:-mfp32}%{mips2:-mfp32}%{mips3:-mfp64} \\\n %{G*} \\\n %{pic-none:   -mno-half-pic} \\\n %{pic-lib:    -mhalf-pic} \\\n@@ -643,7 +639,10 @@ while (0)\n %{.m:\t-D__LANGUAGE_OBJECTIVE_C -D_LANGUAGE_OBJECTIVE_C} \\\n %{.S:\t-D__LANGUAGE_ASSEMBLY -D_LANGUAGE_ASSEMBLY %{!ansi:-DLANGUAGE_ASSEMBLY}} \\\n %{.s:\t-D__LANGUAGE_ASSEMBLY -D_LANGUAGE_ASSEMBLY %{!ansi:-DLANGUAGE_ASSEMBLY}} \\\n-%{!.S:%{!.s:\t-D__LANGUAGE_C -D_LANGUAGE_C %{!ansi:-DLANGUAGE_C}}}\"\n+%{!.S:%{!.s:\t-D__LANGUAGE_C -D_LANGUAGE_C %{!ansi:-DLANGUAGE_C}}} \\\n+%{mlong64:-D__SIZE_TYPE__=long\\\\ unsigned\\\\ int -D__PTRDIFF_TYPE__=long\\\\ int} \\\n+%{!mlong64:-D__SIZE_TYPE__=unsigned\\\\ int -D__PTRDIFF_TYPE=int} \\\n+%{mips3:-U__mips -D__mips=3}\"\n #endif\n \n /* If defined, this macro is an additional prefix to try after\n@@ -916,15 +915,28 @@ do {\t\t\t\t\t\t\t\\\n    Note that this is not necessarily the width of data type `int';\n    if using 16-bit ints on a 68000, this would still be 32.\n    But on a machine with 16-bit registers, this would be 16.  */\n-#define BITS_PER_WORD 32\n+#define BITS_PER_WORD (TARGET_64BIT ? 64 : 32)\n+#define MAX_BITS_PER_WORD 64\n \n /* Width of a word, in units (bytes).  */\n-#define UNITS_PER_WORD 4\n+#define UNITS_PER_WORD (TARGET_64BIT ? 8 : 4)\n+#define MAX_UNITS_PER_WORD 8\n+\n+/* For MIPS, width of a floating point register.  */\n+#define UNITS_PER_FPREG (TARGET_FLOAT64 ? 8 : 4)\n \n /* A C expression for the size in bits of the type `int' on the\n    target machine.  If you don't define this, the default is one\n    word.  */\n-#define INT_TYPE_SIZE 32\n+#define INT_TYPE_SIZE (TARGET_INT64 ? 64 : 32)\n+#define MAX_INT_TYPE_SIZE 64\n+\n+/* Tell the preprocessor the maximum size of wchar_t.  */\n+#ifndef MAX_WCHAR_TYPE_SIZE\n+#ifndef WCHAR_TYPE_SIZE\n+#define MAX_WCHAR_TYPE_SIZE MAX_INT_TYPE_SIZE\n+#endif\n+#endif\n \n /* A C expression for the size in bits of the type `short' on the\n    target machine.  If you don't define this, the default is half a\n@@ -935,12 +947,13 @@ do {\t\t\t\t\t\t\t\\\n /* A C expression for the size in bits of the type `long' on the\n    target machine.  If you don't define this, the default is one\n    word.  */\n-#define LONG_TYPE_SIZE 32\n+#define LONG_TYPE_SIZE (TARGET_LONG64 ? 64 : 32)\n+#define MAX_LONG_TYPE_SIZE 64\n \n /* A C expression for the size in bits of the type `long long' on the\n    target machine.  If you don't define this, the default is two\n    words.  */\n-#define LONG_LONG_TYPE_SIZE 64\n+#define LONG_LONG_TYPE_SIZE (TARGET_LLONG128 ? 128 : 64)\n \n /* A C expression for the size in bits of the type `char' on the\n    target machine.  If you don't define this, the default is one\n@@ -965,19 +978,19 @@ do {\t\t\t\t\t\t\t\\\n \n /* Width in bits of a pointer.\n    See also the macro `Pmode' defined below.  */\n-#define POINTER_SIZE 32\n+#define POINTER_SIZE (TARGET_LONG64 ? 64 : 32)\n \n /* Allocation boundary (in *bits*) for storing pointers in memory.  */\n-#define POINTER_BOUNDARY 32\n+#define POINTER_BOUNDARY (TARGET_LONG64 ? 64 : 32)\n \n /* Allocation boundary (in *bits*) for storing arguments in argument list.  */\n-#define PARM_BOUNDARY 32\n+#define PARM_BOUNDARY (TARGET_64BIT ? 64 : 32)\n \n /* Allocation boundary (in *bits*) for the code of a function.  */\n #define FUNCTION_BOUNDARY 32\n \n /* Alignment of field after `int : 0' in a structure.  */\n-#define EMPTY_FIELD_BOUNDARY 32\n+#define EMPTY_FIELD_BOUNDARY (TARGET_LONG64 ? 64 : 32)\n \n /* Every structure's size must be a multiple of this.  */\n /* 8 is observed right on a DECstation and on riscos 4.02.  */\n@@ -1166,14 +1179,13 @@ do {\t\t\t\t\t\t\t\\\n #define HARD_REGNO_NREGS(REGNO, MODE)\t\t\t\t\t\\\n   (! FP_REG_P (REGNO)\t\t\t\t\t\t\t\\\n \t? ((GET_MODE_SIZE (MODE) + UNITS_PER_WORD - 1) / UNITS_PER_WORD) \\\n-\t: (((GET_MODE_SIZE (MODE) + (2*UNITS_PER_WORD) - 1) / (2*UNITS_PER_WORD)) \\\n-\t\t<< (TARGET_FLOAT64 == 0)))\n+        : (((GET_MODE_SIZE (MODE) + 7) / 8) << (TARGET_FLOAT64 == 0)))\n \n /* Value is 1 if hard register REGNO can hold a value of machine-mode\n-   MODE.  Require that DImode and DFmode be in even registers.  For\n-   DImode, this makes some of the insns easier to write, since you\n-   don't have to worry about a DImode value in registers 3 & 4,\n-   producing a result in 4 & 5.\n+   MODE.  In 32 bit mode, require that DImode and DFmode be in even\n+   registers.  For DImode, this makes some of the insns easier to\n+   write, since you don't have to worry about a DImode value in\n+   registers 3 & 4, producing a result in 4 & 5.\n \n    To make the code simpler HARD_REGNO_MODE_OK now just references an\n    array built in override_options.  Because machmodes.h is not yet\n@@ -1357,7 +1369,7 @@ extern enum reg_class mips_regno_to_class[];\n    factor or added to another register (as well as added to a\n    displacement).  */\n \n-#define INDEX_REG_CLASS GR_REGS\n+#define INDEX_REG_CLASS NO_REGS\n \n \n /* REGISTER AND CONSTANT CLASSES */\n@@ -1413,10 +1425,14 @@ extern enum reg_class mips_char_to_class[];\n   ((C) == 'I' ? ((unsigned) ((VALUE) + 0x8000) < 0x10000)\t\t\\\n    : (C) == 'J' ? ((VALUE) == 0)\t\t\t\t\t\\\n    : (C) == 'K' ? ((unsigned) (VALUE) < 0x10000)\t\t\t\\\n-   : (C) == 'L' ? (((VALUE) & 0xffff0000) == (VALUE))\t\t\t\\\n+   : (C) == 'L' ? (((VALUE) & 0x0000ffff) == 0\t\t\t\t\\\n+\t\t   && (((VALUE) & ~2147483647) == 0\t\t\t\\\n+\t\t       || ((VALUE) & ~2147483647) == ~2147483647))\t\\\n    : (C) == 'M' ? ((((VALUE) & ~0x0000ffff) != 0)\t\t\t\\\n \t\t   && (((VALUE) & ~0x0000ffff) != ~0x0000ffff)\t\t\\\n-\t\t   && ((VALUE) & 0x0000ffff) != 0)\t\t\t\\\n+\t\t   && (((VALUE) & 0x0000ffff) != 0\t\t\t\\\n+\t\t       || (((VALUE) & ~2147483647) != 0\t\t\t\\\n+\t\t\t   && ((VALUE) & ~2147483647) != ~2147483647)))\t\\\n    : (C) == 'N' ? (((VALUE) & ~0x0000ffff) == ~0x0000ffff)\t\t\\\n    : (C) == 'O' ? (exact_log2 (VALUE) >= 0)\t\t\t\t\\\n    : (C) == 'P' ? ((VALUE) != 0 && (((VALUE) & ~0x0000ffff) == 0))\t\\\n@@ -1431,8 +1447,7 @@ extern enum reg_class mips_char_to_class[];\n \n #define CONST_DOUBLE_OK_FOR_LETTER_P(VALUE, C)\t\t\t\t\\\n   ((C) == 'G'\t\t\t\t\t\t\t\t\\\n-   && CONST_DOUBLE_HIGH (VALUE) == 0\t\t\t\t\t\\\n-   && CONST_DOUBLE_LOW (VALUE) == 0)\n+   && (VALUE) == CONST0_RTX (GET_MODE (VALUE)))\n \n /* Letters in the range `Q' through `U' may be defined in a\n    machine-dependent fashion to stand for arbitrary operand types. \n@@ -1458,12 +1473,15 @@ extern enum reg_class mips_char_to_class[];\n    in some cases it is preferable to use a more restrictive class.  */\n \n #define PREFERRED_RELOAD_CLASS(X,CLASS)\t\t\t\t\t\\\n-  ((GET_MODE_CLASS (GET_MODE (X)) == MODE_FLOAT\t\t\t\t\\\n-     || GET_MODE_CLASS (GET_MODE (X)) == MODE_COMPLEX_FLOAT)\t\t\\\n-\t    ? (TARGET_SOFT_FLOAT ? GR_REGS : FP_REGS)\t\t\t\\\n-\t    : ((GET_MODE (X) == VOIDmode)\t\t\t\t\\\n-\t\t? GR_REGS\t\t\t\t\t\t\\\n-\t\t: CLASS))\n+  ((CLASS) != ALL_REGS\t\t\t\t\t\t\t\\\n+   ? (CLASS)\t\t\t\t\t\t\t\t\\\n+   : ((GET_MODE_CLASS (GET_MODE (X)) == MODE_FLOAT\t\t\t\\\n+       || GET_MODE_CLASS (GET_MODE (X)) == MODE_COMPLEX_FLOAT)\t\t\\\n+      ? (TARGET_SOFT_FLOAT ? GR_REGS : FP_REGS)\t\t\t\t\\\n+      : ((GET_MODE_CLASS (GET_MODE (X)) == MODE_INT\t\t\t\\\n+\t  || GET_MODE (X) == VOIDmode)\t\t\t\t\t\\\n+\t ? GR_REGS\t\t\t\t\t\t\t\\\n+\t : (CLASS))))\n \n /* Certain machines have the property that some registers cannot be\n    copied to some other registers without using memory.  Define this\n@@ -1667,7 +1685,7 @@ extern struct mips_frame_info current_frame_info;\n    the first argument's address.\n \n    On the MIPS, we must skip the first argument position if we are\n-   returning a structure or a union, to account for it's address being\n+   returning a structure or a union, to account for its address being\n    passed in $4.  However, at the current time, this produces a compiler\n    that can't bootstrap, so comment it out for now.  */\n \n@@ -1704,13 +1722,13 @@ extern struct mips_frame_info current_frame_info;\n /* Align stack frames on 64 bits (Double Word ).  */\n #define STACK_BOUNDARY 64\n \n-/* Make sure 16 bytes are always allocated on the stack.  */\n+/* Make sure 4 words are always allocated on the stack.  */\n \n #ifndef STACK_ARGS_ADJUST\n #define STACK_ARGS_ADJUST(SIZE)\t\t\t\t\t\t\\\n {\t\t\t\t\t\t\t\t\t\\\n-  if (SIZE.constant < 16)\t\t\t\t\t\t\\\n-    SIZE.constant = 16;\t\t\t\t\t\t\t\\\n+  if (SIZE.constant < 4 * UNITS_PER_WORD)\t\t\t\t\\\n+    SIZE.constant = 4 * UNITS_PER_WORD;\t\t\t\t\t\\\n }\n #endif\n \n@@ -1941,9 +1959,12 @@ typedef struct mips_args {\n   fprintf (FILE, \"\\tmove\\t%s,%s\\t\\t# save current return address\\n\",\t\\\n \t   reg_names[GP_REG_FIRST + 1], reg_names[GP_REG_FIRST + 31]);\t\\\n   fprintf (FILE, \"\\tjal\\t_mcount\\n\");\t\t\t\t\t\\\n-  fprintf (FILE, \"\\tsubu\\t%s,%s,8\\t\\t# _mcount pops 2 words from  stack\\n\", \\\n+  fprintf (FILE,\t\t\t\t\t\t\t\\\n+\t   \"\\t%s\\t%s,%s,%d\\t\\t# _mcount pops 2 words from  stack\\n\",\t\\\n+\t   TARGET_64BIT ? \"dsubu\" : \"subu\",\t\t\t\t\\\n \t   reg_names[STACK_POINTER_REGNUM],\t\t\t\t\\\n-\t   reg_names[STACK_POINTER_REGNUM]);\t\t\t\t\\\n+\t   reg_names[STACK_POINTER_REGNUM],\t\t\t\t\\\n+\t   TARGET_LONG64 ? 16 : 8);\t\t\t\t\t\\\n   fprintf (FILE, \"\\t.set\\treorder\\n\");\t\t\t\t\t\\\n   fprintf (FILE, \"\\t.set\\tat\\n\");\t\t\t\t\t\\\n }\n@@ -1972,25 +1993,39 @@ typedef struct mips_args {\n   fprintf (STREAM, \"\\t.word\\t0x03e00821\\t\\t# move   $1,$31\\n\");\t\t\\\n   fprintf (STREAM, \"\\t.word\\t0x04110001\\t\\t# bgezal $0,.+8\\n\");\t\t\\\n   fprintf (STREAM, \"\\t.word\\t0x00000000\\t\\t# nop\\n\");\t\t\t\\\n-  fprintf (STREAM, \"\\t.word\\t0x8fe30010\\t\\t# lw     $3,16($31)\\n\");\t\\\n-  fprintf (STREAM, \"\\t.word\\t0x8fe20014\\t\\t# lw     $2,20($31)\\n\");\t\\\n+  if (TARGET_LONG64)\t\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\t\\\n+      fprintf (STREAM, \"\\t.word\\t0xdfe30014\\t\\t# ld     $3,20($31)\\n\");\t\\\n+      fprintf (STREAM, \"\\t.word\\t0xdfe2001c\\t\\t# ld     $2,28($31)\\n\");\t\\\n+    }\t\t\t\t\t\t\t\t\t\\\n+  else\t\t\t\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\t\\\n+      fprintf (STREAM, \"\\t.word\\t0x8fe30010\\t\\t# lw     $3,16($31)\\n\");\t\\\n+      fprintf (STREAM, \"\\t.word\\t0x8fe20014\\t\\t# lw     $2,20($31)\\n\");\t\\\n+    }\t\t\t\t\t\t\t\t\t\\\n   fprintf (STREAM, \"\\t.word\\t0x00600008\\t\\t# jr     $3\\n\");\t\t\\\n   fprintf (STREAM, \"\\t.word\\t0x0020f821\\t\\t# move   $31,$1\\n\");\t\t\\\n-  fprintf (STREAM, \"\\t.word\\t0x00000000\\t\\t# <function address>\\n\");\t\\\n-  fprintf (STREAM, \"\\t.word\\t0x00000000\\t\\t# <static chain value>\\n\");\t\\\n+  if (TARGET_LONG64)\t\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\t\\\n+      fprintf (STREAM, \"\\t.word\\t0x00000000\\t\\t# <alignment padding>\\n\"); \\\n+      fprintf (STREAM, \"\\t.dword\\t0x00000000\\t\\t# <function address>\\n\"); \\\n+      fprintf (STREAM, \"\\t.dword\\t0x00000000\\t\\t# <static chain value>\\n\"); \\\n+    }\t\t\t\t\t\t\t\t\t\\\n+  else\t\t\t\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\t\\\n+      fprintf (STREAM, \"\\t.word\\t0x00000000\\t\\t# <function address>\\n\"); \\\n+      fprintf (STREAM, \"\\t.word\\t0x00000000\\t\\t# <static chain value>\\n\"); \\\n+    }\t\t\t\t\t\t\t\t\t\\\n }\n \n /* A C expression for the size in bytes of the trampoline, as an\n    integer.  */\n \n-#define TRAMPOLINE_SIZE (9*4)\n-\n-/* Alignment required for trampolines, in bits.\n+#define TRAMPOLINE_SIZE (TARGET_LONG64 ? (8 * 4 + 2 * 8) : (9 * 4))\n \n-   If you don't define this macro, the value of `BIGGEST_ALIGNMENT'\n-   is used for aligning trampolines.  */\n+/* Alignment required for trampolines, in bits.  */\n \n-/* #define TRAMPOLINE_ALIGNMENT 32 */\n+#define TRAMPOLINE_ALIGNMENT (TARGET_LONG64 ? 64 : 32)\n \n /* A C statement to initialize the variable parts of a trampoline. \n    ADDR is an RTX for the address of the trampoline; FNADDR is an\n@@ -2001,24 +2036,24 @@ typedef struct mips_args {\n #define INITIALIZE_TRAMPOLINE(ADDR, FUNC, CHAIN)\t\t\t    \\\n {\t\t\t\t\t\t\t\t\t    \\\n   rtx addr = ADDR;\t\t\t\t\t\t\t    \\\n-  emit_move_insn (gen_rtx (MEM, SImode, plus_constant (addr, 28)), FUNC);   \\\n-  emit_move_insn (gen_rtx (MEM, SImode, plus_constant (addr, 32)), CHAIN);  \\\n+  if (TARGET_LONG64)\t\t\t\t\t\t\t    \\\n+    {\t\t\t\t\t\t\t\t\t    \\\n+      emit_move_insn (gen_rtx (MEM, DImode, plus_constant (addr, 32)), FUNC); \\\n+      emit_move_insn (gen_rtx (MEM, DImode, plus_constant (addr, 40)), CHAIN);\\\n+    }\t\t\t\t\t\t\t\t\t    \\\n+  else\t\t\t\t\t\t\t\t\t    \\\n+    {\t\t\t\t\t\t\t\t\t    \\\n+      emit_move_insn (gen_rtx (MEM, SImode, plus_constant (addr, 28)), FUNC); \\\n+      emit_move_insn (gen_rtx (MEM, SImode, plus_constant (addr, 32)), CHAIN);\\\n+    }\t\t\t\t\t\t\t\t\t    \\\n \t\t\t\t\t\t\t\t\t    \\\n   /* Flush the instruction cache.  */\t\t\t\t\t    \\\n-  emit_library_call (gen_rtx (SYMBOL_REF, Pmode, \"__gcc_flush_cache\"), \\\n-\t\t     0, VOIDmode, 1, addr, Pmode);\t\t\t    \\\n-}\n-\n-/* Flush the instruction cache.  */\n-\n-#define TRANSFER_FROM_TRAMPOLINE\t\t\t\t\t\\\n-\t\t\t\t\t\t\t\t\t\\\n-void\t\t\t\t\t\t\t\t\t\\\n-__gcc_flush_cache (addr)\t\t\t\t\t\t\\\n-     char *addr;\t\t\t\t\t\t\t\\\n-{\t\t\t\t\t\t\t\t\t\\\n-  if (cacheflush (addr, TRAMPOLINE_SIZE, 1) < 0)\t\t\t\\\n-    perror (\"cacheflush of trampoline code\");\t\t\t\t\\\n+  /* ??? Are the modes right? Maybe they should depend on -mint64/-mlong64? */\\\n+  /* ??? Should check the return value for errors.  */\t\t\t    \\\n+  emit_library_call (gen_rtx (SYMBOL_REF, Pmode, \"cacheflush\"),\t\t    \\\n+\t\t     0, VOIDmode, 3, addr, Pmode,\t\t\t    \\\n+\t\t     GEN_INT (TRAMPOLINE_SIZE), SImode,  \t\t    \\\n+\t\t     GEN_INT (1), SImode);\t\t\t\t    \\\n }\n \f\n /* Addressing modes, and classification of registers for them.  */\n@@ -2040,7 +2075,7 @@ __gcc_flush_cache (addr)\t\t\t\t\t\t\\\n #define GP_REG_OR_PSEUDO_NONSTRICT_P(regno) \\\n   (((regno) >= FIRST_PSEUDO_REGISTER) || (GP_REG_P (regno)))\n \n-#define REGNO_OK_FOR_INDEX_P(regno)\tGP_REG_OR_PSEUDO_STRICT_P (regno)\n+#define REGNO_OK_FOR_INDEX_P(regno)\t0\n #define REGNO_OK_FOR_BASE_P(regno)\tGP_REG_OR_PSEUDO_STRICT_P (regno)\n \n /* The macros REG_OK_FOR..._P assume that the arg is a REG rtx\n@@ -2057,13 +2092,13 @@ __gcc_flush_cache (addr)\t\t\t\t\t\t\\\n #ifndef REG_OK_STRICT\n \n #define REG_OK_STRICT_P 0\n-#define REG_OK_FOR_INDEX_P(X) GP_REG_OR_PSEUDO_NONSTRICT_P (REGNO (X))\n+#define REG_OK_FOR_INDEX_P(X) 0\n #define REG_OK_FOR_BASE_P(X)  GP_REG_OR_PSEUDO_NONSTRICT_P (REGNO (X))\n \n #else\n \n #define REG_OK_STRICT_P 1\n-#define REG_OK_FOR_INDEX_P(X) REGNO_OK_FOR_INDEX_P (REGNO (X))\n+#define REG_OK_FOR_INDEX_P(X) 0\n #define REG_OK_FOR_BASE_P(X)  REGNO_OK_FOR_BASE_P  (REGNO (X))\n \n #endif\n@@ -2168,14 +2203,10 @@ __gcc_flush_cache (addr)\t\t\t\t\t\t\\\n \t\t\t\t\t\t\t\t\t\\\n       if (code0 == REG && REG_OK_FOR_BASE_P (xplus0))\t\t\t\\\n \t{\t\t\t\t\t\t\t\t\\\n-\t  if (code1 == CONST_INT)\t\t\t\t\t\\\n-\t    {\t\t\t\t\t\t\t\t\\\n-\t      register unsigned adj_offset = INTVAL (xplus1) + 0x8000;\t\\\n-\t\t\t\t\t\t\t\t\t\\\n-\t      if ((adj_offset <= 0xffff)\t\t\t\t\\\n-\t\t  && (adj_offset + GET_MODE_SIZE (MODE) - 1 <= 0xffff))\t\\\n-\t\tgoto ADDR;\t\t\t\t\t\t\\\n-\t    }\t\t\t\t\t\t\t\t\\\n+\t  if (code1 == CONST_INT\t\t\t\t\t\\\n+\t      && INTVAL (xplus1) >= -32768\t\t\t\t\\\n+\t      && INTVAL (xplus1) + GET_MODE_SIZE (MODE) - 1 <= 32767)\t\\\n+\t    goto ADDR;\t\t\t\t\t\t\t\\\n \t\t\t\t\t\t\t\t\t\\\n \t  /* For some code sequences, you actually get better code by\t\\\n \t     pretending that the MIPS supports an address mode of a\t\\\n@@ -2190,7 +2221,6 @@ __gcc_flush_cache (addr)\t\t\t\t\t\t\\\n \t     appropriate relocation.  */\t\t\t\t\\\n \t\t\t\t\t\t\t\t\t\\\n \t  else if (!TARGET_DEBUG_A_MODE\t\t\t\t\t\\\n-\t\t   && code0 == REG\t\t\t\t\t\\\n \t\t   && CONSTANT_ADDRESS_P (xplus1))\t\t\t\\\n \t    goto ADDR;\t\t\t\t\t\t\t\\\n \t}\t\t\t\t\t\t\t\t\\\n@@ -2348,8 +2378,7 @@ __gcc_flush_cache (addr)\t\t\t\t\t\t\\\n #define ENCODE_SECTION_INFO(DECL)\t\t\t\t\t\\\n do\t\t\t\t\t\t\t\t\t\\\n   {\t\t\t\t\t\t\t\t\t\\\n-    if (optimize && mips_section_threshold > 0 && TARGET_GP_OPT\t\t\\\n-\t&& TREE_CODE (DECL) == VAR_DECL)\t\t\t\t\\\n+    if (TARGET_GP_OPT && TREE_CODE (DECL) == VAR_DECL)\t\t\t\\\n       {\t\t\t\t\t\t\t\t\t\\\n \tint size = int_size_in_bytes (TREE_TYPE (DECL));\t\t\\\n \t\t\t\t\t\t\t\t\t\\\n@@ -2365,7 +2394,7 @@ while (0)\n \f\n /* Specify the machine mode that this machine uses\n    for the index in the tablejump instruction.  */\n-#define CASE_VECTOR_MODE SImode\n+#define CASE_VECTOR_MODE (TARGET_LONG64 ? DImode : SImode)\n \n /* Define this if the tablejump instruction expects the table\n    to contain offsets from the address of the table.\n@@ -2385,7 +2414,8 @@ while (0)\n \n /* Max number of bytes we can move from memory to memory\n    in one reasonably fast instruction.  */\n-#define MOVE_MAX 4\n+#define MOVE_MAX (TARGET_64BIT ? 8 : 4)\n+#define MAX_MOVE_MAX 8\n \n /* Define this macro as a C expression which is nonzero if\n    accessing less than a word of memory (i.e. a `char' or a\n@@ -2411,7 +2441,14 @@ while (0)\n \n /* Value is 1 if truncating an integer of INPREC bits to OUTPREC bits\n    is done just by pretending it is already truncated.  */\n-#define TRULY_NOOP_TRUNCATION(OUTPREC, INPREC) 1\n+/* In 64 bit mode, 32 bit instructions require that register values be properly\n+   sign-extended to 64 bits.  As a result, a truncate is not a no-op if it\n+   converts a value >32 bits to a value <32 bits.  */\n+/* ??? This results in inefficient code for 64 bit to 32 conversions.\n+   Something needs to be done about this.  Perhaps not use any 32 bit\n+   instructions?  Perhaps use PROMOTE_MODE?  */\n+#define TRULY_NOOP_TRUNCATION(OUTPREC, INPREC) \\\n+  (TARGET_64BIT ? ((INPREC) <= 32 || (OUTPREC) > 32) : 1)\n \n /* Define this macro to control use of the character `$' in\n    identifier names.  The value should be 0, 1, or 2.  0 means `$'\n@@ -2427,13 +2464,14 @@ while (0)\n /* Specify the machine mode that pointers have.\n    After generation of rtl, the compiler makes no further distinction\n    between pointers and any other objects of this machine mode.  */\n-#define Pmode SImode\n+\n+#define Pmode (TARGET_LONG64 ? DImode : SImode)\n \n /* A function address in a call instruction\n    is a word address (for indexing purposes)\n    so give the MEM rtx a words's mode.  */\n \n-#define FUNCTION_MODE SImode\n+#define FUNCTION_MODE (TARGET_LONG64 ? DImode : SImode)\n \n /* Define TARGET_MEM_FUNCTIONS if we want to use calls to memcpy and\n    memset, instead of the BSD functions bcopy and bzero.  */\n@@ -2460,15 +2498,15 @@ while (0)\n     /* Always return 0, since we don't have different sized\t\t\\\n        instructions, hence different costs according to Richard\t\t\\\n        Kenner */\t\t\t\t\t\t\t\\\n-    return COSTS_N_INSNS (0);\t\t\t\t\t\t\\\n+    return 0;\t\t\t\t\t\t\t\t\\\n \t\t\t\t\t\t\t\t\t\\\n   case LABEL_REF:\t\t\t\t\t\t\t\\\n     return COSTS_N_INSNS (2);\t\t\t\t\t\t\\\n \t\t\t\t\t\t\t\t\t\\\n   case CONST:\t\t\t\t\t\t\t\t\\\n     {\t\t\t\t\t\t\t\t\t\\\n       rtx offset = const0_rtx;\t\t\t\t\t\t\\\n-      rtx symref = eliminate_constant_term (X, &offset);\t\t\\\n+      rtx symref = eliminate_constant_term (XEXP (X, 0), &offset);\t\\\n \t\t\t\t\t\t\t\t\t\\\n       if (GET_CODE (symref) == LABEL_REF)\t\t\t\t\\\n \treturn COSTS_N_INSNS (2);\t\t\t\t\t\\\n@@ -2518,34 +2556,22 @@ while (0)\n     return COSTS_N_INSNS (6);\t\t\t\t\t\t\\\n \t\t\t\t\t\t\t\t\t\\\n   case NOT:\t\t\t\t\t\t\t\t\\\n-    return COSTS_N_INSNS ((GET_MODE (X) == DImode) ? 2 : 1);\t\t\\\n+    return COSTS_N_INSNS ((GET_MODE (X) == DImode && !TARGET_64BIT) ? 2 : 1); \\\n \t\t\t\t\t\t\t\t\t\\\n   case AND:\t\t\t\t\t\t\t\t\\\n   case IOR:\t\t\t\t\t\t\t\t\\\n   case XOR:\t\t\t\t\t\t\t\t\\\n-    if (GET_MODE (X) == DImode)\t\t\t\t\t\t\\\n+    if (GET_MODE (X) == DImode && !TARGET_64BIT)\t\t\t\\\n       return COSTS_N_INSNS (2);\t\t\t\t\t\t\\\n \t\t\t\t\t\t\t\t\t\\\n-    if (GET_CODE (XEXP (X, 1)) == CONST_INT)\t\t\t\t\\\n-      {\t\t\t\t\t\t\t\t\t\\\n-\trtx number = XEXP (X, 1);\t\t\t\t\t\\\n-\tif (SMALL_INT_UNSIGNED (number))\t\t\t\t\\\n-\t  return COSTS_N_INSNS (1);\t\t\t\t\t\\\n-\t\t\t\t\t\t\t\t\t\\\n-\telse if (SMALL_INT (number))\t\t\t\t\t\\\n-\t  return COSTS_N_INSNS (2);\t\t\t\t\t\\\n-\t\t\t\t\t\t\t\t\t\\\n-\treturn COSTS_N_INSNS (3);\t\t\t\t\t\\\n-      }\t\t\t\t\t\t\t\t\t\\\n-\t\t\t\t\t\t\t\t\t\\\n     return COSTS_N_INSNS (1);\t\t\t\t\t\t\\\n \t\t\t\t\t\t\t\t\t\\\n   case ASHIFT:\t\t\t\t\t\t\t\t\\\n   case ASHIFTRT:\t\t\t\t\t\t\t\\\n   case LSHIFT:\t\t\t\t\t\t\t\t\\\n   case LSHIFTRT:\t\t\t\t\t\t\t\\\n-    if (GET_MODE (X) == DImode)\t\t\t\t\t\t\\\n-      return COSTS_N_INSNS ((GET_CODE (XEXP (X, 1)) == CONST_INT) ? 12 : 4); \\\n+    if (GET_MODE (X) == DImode && !TARGET_64BIT)\t\t\t\\\n+      return COSTS_N_INSNS ((GET_CODE (XEXP (X, 1)) == CONST_INT) ? 4 : 12); \\\n \t\t\t\t\t\t\t\t\t\\\n     return COSTS_N_INSNS (1);\t\t\t\t\t\t\\\n \t\t\t\t\t\t\t\t\t\\\n@@ -2565,14 +2591,14 @@ while (0)\n       if (xmode == SFmode || xmode == DFmode)\t\t\t\t\\\n \treturn COSTS_N_INSNS (2);\t\t\t\t\t\\\n \t\t\t\t\t\t\t\t\t\\\n-      if (xmode == DImode)\t\t\t\t\t\t\\\n+      if (xmode == DImode && !TARGET_64BIT)\t\t\t\t\\\n \treturn COSTS_N_INSNS (4);\t\t\t\t\t\\\n \t\t\t\t\t\t\t\t\t\\\n       return COSTS_N_INSNS (1);\t\t\t\t\t\t\\\n     }\t\t\t\t\t\t\t\t\t\\\n \t\t\t\t\t\t\t\t\t\\\n   case NEG:\t\t\t\t\t\t\t\t\\\n-    return COSTS_N_INSNS ((GET_MODE (X) == DImode) ? 4 : 1);\t\t\\\n+    return COSTS_N_INSNS ((GET_MODE (X) == DImode && !TARGET_64BIT) ? 4 : 1); \\\n \t\t\t\t\t\t\t\t\t\\\n   case MULT:\t\t\t\t\t\t\t\t\\\n     {\t\t\t\t\t\t\t\t\t\\\n@@ -2665,6 +2691,9 @@ while (0)\n \n #define REGISTER_MOVE_COST(FROM, TO) 4\t/* force reload to use constraints */\n \n+#define MEMORY_MOVE_COST(MODE) \\\n+  ((mips_cpu == PROCESSOR_R4000 || mips_cpu == PROCESSOR_R6000) ? 6 : 4)\n+\n /* A C expression for the cost of a branch instruction.  A value of\n    1 is the default; other values are interpreted relative to that.  */\n \n@@ -3105,7 +3134,7 @@ while (0)\n #define ASM_OUTPUT_SOURCE_LINE(STREAM, LINE)\t\t\t\t\\\n   mips_output_lineno (STREAM, LINE)\n \n-/* The MIPS implementation uses some labels for it's own purposed.  The\n+/* The MIPS implementation uses some labels for it's own purpose.  The\n    following lists what labels are created, and are all formed by the\n    pattern $L[a-z].*.  The machine independent portion of GCC creates\n    labels matching:  $L[A-Z][0-9]+ and $L[0-9]+.\n@@ -3242,7 +3271,24 @@ do {\t\t\t\t\t\t\t\t\t\\\n   fprintf (STREAM, \"\\n\");\t\t\t\t\t\t\\\n } while (0)\n \n-/* Likewise for `char' and `short' constants.  */\n+/* Likewise for 64 bit, `char' and `short' constants.  */\n+\n+#define ASM_OUTPUT_DOUBLE_INT(STREAM,VALUE)\t\t\t\t\\\n+do {\t\t\t\t\t\t\t\t\t\\\n+  if (TARGET_64BIT)\t\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\t\\\n+      fprintf (STREAM, \"\\t.dword\\t\");\t\t\t\t\t\\\n+      output_addr_const (STREAM, (VALUE));\t\t\t\t\\\n+      fprintf (STREAM, \"\\n\");\t\t\t\t\t\t\\\n+    }\t\t\t\t\t\t\t\t\t\\\n+  else\t\t\t\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\t\\\n+      assemble_integer (operand_subword ((VALUE), 0, 0, DImode),\t\\\n+\t\t\tUNITS_PER_WORD, 1);\t\t\t\t\\\n+      assemble_integer (operand_subword ((VALUE), 1, 0, DImode),\t\\\n+\t\t\tUNITS_PER_WORD, 1);\t\t\t\t\\\n+    }\t\t\t\t\t\t\t\t\t\\\n+} while (0)\n \n #define ASM_OUTPUT_SHORT(STREAM,VALUE)\t\t\t\t\t\\\n {\t\t\t\t\t\t\t\t\t\\\n@@ -3266,26 +3312,18 @@ do {\t\t\t\t\t\t\t\t\t\\\n /* This is how to output an element of a case-vector that is absolute.  */\n \n #define ASM_OUTPUT_ADDR_VEC_ELT(STREAM, VALUE)\t\t\t\t\\\n-  fprintf (STREAM, \"\\t.word\\t$L%d\\n\", VALUE)\n+  fprintf (STREAM, \"\\t%s\\t$L%d\\n\",\t\t\t\t\t\\\n+\t   TARGET_LONG64 ? \".dword\" : \".word\",\t\t\t\t\\\n+\t   VALUE)\n \n /* This is how to output an element of a case-vector that is relative.\n    (We  do not use such vectors,\n    but we must define this macro anyway.)  */\n \n #define ASM_OUTPUT_ADDR_DIFF_ELT(STREAM, VALUE, REL)\t\t\t\\\n-  fprintf (STREAM, \"\\t.word\\t$L%d-$L%d\\n\", VALUE, REL)\n-\n-/* This is how to emit the initial label for switch statements.  We\n-   need to put the switch labels somewhere else from the text section,\n-   because the MIPS assembler gets real confused about line numbers if\n-   .word's appear in the text section.  */\n-\n-#define ASM_OUTPUT_CASE_LABEL(STREAM, PREFIX, NUM, JUMPTABLE)\t\t\\\n-{\t\t\t\t\t\t\t\t\t\\\n-  rdata_section ();\t\t\t\t\t\t\t\\\n-  ASM_OUTPUT_ALIGN (STREAM, 2);\t\t\t\t\t\t\\\n-  ASM_OUTPUT_INTERNAL_LABEL (STREAM, PREFIX, NUM);\t\t\t\\\n-}\n+  fprintf (STREAM, \"\\t%s\\t$L%d-$L%d\\n\",\t\t\t\t\t\\\n+\t   TARGET_LONG64 ? \".dword\" : \".word\",\t\t\t\t\\\n+\t   VALUE, REL)\n \n /* This is how to output an assembler line\n    that says to advance the location counter\n@@ -3401,7 +3439,7 @@ do {\t\t\t\t\t\t\t\t\t\\\n \n /* What other sections we support other than the normal .data/.text.  */\n \n-#define EXTRA_SECTIONS in_sdata, in_rdata, in_last_p1\n+#define EXTRA_SECTIONS in_sdata, in_rdata\n \n /* Define the additional functions to select our additional sections.  */\n \n@@ -3439,7 +3477,7 @@ rdata_section ()\t\t\t\t\t\t\t\\\n \n #define SELECT_RTX_SECTION(MODE,RTX)\t\t\t\t\t\\\n {\t\t\t\t\t\t\t\t\t\\\n-  if ((GET_MODE_SIZE(MODE) / BITS_PER_UNIT) <= mips_section_threshold\t\\\n+  if (GET_MODE_SIZE (MODE) <= mips_section_threshold\t\t\t\\\n       && mips_section_threshold > 0)\t\t\t\t\t\\\n     sdata_section ();\t\t\t\t\t\t\t\\\n   else\t\t\t\t\t\t\t\t\t\\\n@@ -3486,9 +3524,11 @@ rdata_section ()\t\t\t\t\t\t\t\\\n #define ASM_OUTPUT_REG_PUSH(STREAM,REGNO)\t\t\t\t\\\n do\t\t\t\t\t\t\t\t\t\\\n   {\t\t\t\t\t\t\t\t\t\\\n-    fprintf (STREAM, \"\\tsubu\\t%s,%s,8\\n\\tsw\\t%s,0(%s)\\n\",\t\t\\\n+    fprintf (STREAM, \"\\t%s\\t%s,%s,8\\n\\t%s\\t%s,0(%s)\\n\",\t\t\t\\\n+\t     TARGET_64BIT ? \"dsubu\" : \"subu\",\t\t\t\t\\\n \t     reg_names[STACK_POINTER_REGNUM],\t\t\t\t\\\n \t     reg_names[STACK_POINTER_REGNUM],\t\t\t\t\\\n+\t     TARGET_64BIT ? \"sd\" : \"sw\",\t\t\t\t\\\n \t     reg_names[REGNO],\t\t\t\t\t\t\\\n \t     reg_names[STACK_POINTER_REGNUM]);\t\t\t\t\\\n   }\t\t\t\t\t\t\t\t\t\\\n@@ -3502,9 +3542,11 @@ do\t\t\t\t\t\t\t\t\t\\\n \t\t\t\t\t\t\t\t\t\\\n     dslots_load_total++;\t\t\t\t\t\t\\\n     dslots_load_filled++;\t\t\t\t\t\t\\\n-    fprintf (STREAM, \"\\tlw\\t%s,0(%s)\\n\\taddu\\t%s,%s,8\\n\",\t\t\\\n+    fprintf (STREAM, \"\\t%s\\t%s,0(%s)\\n\\t%s\\t%s,%s,8\\n\",\t\t\t\\\n+\t     TARGET_64BIT ? \"ld\" : \"lw\",\t\t\t\t\\\n \t     reg_names[REGNO],\t\t\t\t\t\t\\\n \t     reg_names[STACK_POINTER_REGNUM],\t\t\t\t\\\n+\t     TARGET_64BIT ? \"daddu\" : \"addu\",\t\t\t\t\\\n \t     reg_names[STACK_POINTER_REGNUM],\t\t\t\t\\\n \t     reg_names[STACK_POINTER_REGNUM]);\t\t\t\t\\\n \t\t\t\t\t\t\t\t\t\\\n@@ -3541,10 +3583,11 @@ while (0)\n /* Default definitions for size_t and ptrdiff_t.  */\n \n #ifndef SIZE_TYPE\n-#define SIZE_TYPE\t\"unsigned int\"\n+#define NO_BUILTIN_SIZE_TYPE\n+#define SIZE_TYPE (TARGET_LONG64 ? \"long unsigned int\" : \"unsigned int\")\n #endif\n \n #ifndef PTRDIFF_TYPE\n-#define PTRDIFF_TYPE\t\"int\"\n+#define NO_BUILTIN_PTRDIFF_TYPE\n+#define PTRDIFF_TYPE (TARGET_LONG64 ? \"long int\" : \"int\")\n #endif\n-"}]}