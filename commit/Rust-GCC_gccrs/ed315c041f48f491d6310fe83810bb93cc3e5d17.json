{"sha": "ed315c041f48f491d6310fe83810bb93cc3e5d17", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZWQzMTVjMDQxZjQ4ZjQ5MWQ2MzEwZmU4MzgxMGJiOTNjYzNlNWQxNw==", "commit": {"author": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2019-06-06T07:25:19Z"}, "committer": {"name": "Richard Biener", "email": "rguenth@gcc.gnu.org", "date": "2019-06-06T07:25:19Z"}, "message": "tree-ssa-structalias.c: Include tree-cfg.h.\n\n2019-06-06  Richard Biener  <rguenther@suse.de>\n\n\t* tree-ssa-structalias.c: Include tree-cfg.h.\n\t(make_heapvar): Do not make heap vars artificial.\n\t(find_func_aliases_for_builtin_call): Handle stack allocation\n\tfunctions.\n\t(find_func_aliases): Delay processing of simple enough returns\n\tin non-IPA mode.\n\t(set_uids_in_ptset): Adjust.\n\t(find_what_var_points_to): Likewise.\n\t(solve_constraints): Do not dump points-to sets here.\n\t(compute_points_to_sets): Post-process return statements,\n\tamending the escaped solution.  Dump points-to sets afterwards.\n\t(ipa_pta_execute): Dump points-to sets.\n\n\t* gcc.dg/tree-ssa/alias-37.c: New testcase.\n\t* gcc.dg/torture/20190604-1.c: Likewise.\n\t* gcc.dg/tree-ssa/pta-callused.c: Adjust.\n\nFrom-SVN: r271989", "tree": {"sha": "c39d72532d4b3cb1d9f09502f7a8087d40d9893a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c39d72532d4b3cb1d9f09502f7a8087d40d9893a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ed315c041f48f491d6310fe83810bb93cc3e5d17", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ed315c041f48f491d6310fe83810bb93cc3e5d17", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ed315c041f48f491d6310fe83810bb93cc3e5d17", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ed315c041f48f491d6310fe83810bb93cc3e5d17/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "c45c8424de8773ee4305a7932fb2a3ee878ea56a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c45c8424de8773ee4305a7932fb2a3ee878ea56a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c45c8424de8773ee4305a7932fb2a3ee878ea56a"}], "stats": {"total": 176, "additions": 164, "deletions": 12}, "files": [{"sha": "0cc05c765571fe0484b8b37774927a06f6600b73", "filename": "gcc/ChangeLog", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ed315c041f48f491d6310fe83810bb93cc3e5d17/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ed315c041f48f491d6310fe83810bb93cc3e5d17/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=ed315c041f48f491d6310fe83810bb93cc3e5d17", "patch": "@@ -1,3 +1,18 @@\n+2019-06-06  Richard Biener  <rguenther@suse.de>\n+\n+\t* tree-ssa-structalias.c: Include tree-cfg.h.\n+\t(make_heapvar): Do not make heap vars artificial.\n+\t(find_func_aliases_for_builtin_call): Handle stack allocation\n+\tfunctions.\n+\t(find_func_aliases): Delay processing of simple enough returns\n+\tin non-IPA mode.\n+\t(set_uids_in_ptset): Adjust.\n+\t(find_what_var_points_to): Likewise.\n+\t(solve_constraints): Do not dump points-to sets here.\n+\t(compute_points_to_sets): Post-process return statements,\n+\tamending the escaped solution.  Dump points-to sets afterwards.\n+\t(ipa_pta_execute): Dump points-to sets.\n+\n 2019-06-06  Martin Liska  <mliska@suse.cz>\n \n \tPR web/87933"}, {"sha": "8213e33ce25ee19551cda00d2e667deb12312407", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ed315c041f48f491d6310fe83810bb93cc3e5d17/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ed315c041f48f491d6310fe83810bb93cc3e5d17/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=ed315c041f48f491d6310fe83810bb93cc3e5d17", "patch": "@@ -1,3 +1,9 @@\n+2019-06-06  Richard Biener  <rguenther@suse.de>\n+\n+\t* gcc.dg/tree-ssa/alias-37.c: New testcase.\n+\t* gcc.dg/torture/20190604-1.c: Likewise.\n+\t* gcc.dg/tree-ssa/pta-callused.c: Adjust.\n+\n 2019-06-06  Claudiu Zissulescu  <claziss@synopsys.com>\n \n \t* gcc.target/arc/tmac-1.c: Reoreder dg-directives."}, {"sha": "884d3d58ce2d3d08798763818fb00e7caf73e236", "filename": "gcc/testsuite/gcc.dg/torture/20190604-1.c", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ed315c041f48f491d6310fe83810bb93cc3e5d17/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2F20190604-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ed315c041f48f491d6310fe83810bb93cc3e5d17/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2F20190604-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2F20190604-1.c?ref=ed315c041f48f491d6310fe83810bb93cc3e5d17", "patch": "@@ -0,0 +1,21 @@\n+/* { dg-do run } */\n+\n+struct S { int *mem; };\n+\n+struct S * __attribute__((noinline,noipa))\n+foo ()\n+{\n+  struct S *s = __builtin_malloc (sizeof (struct S));\n+  s->mem = __builtin_malloc (sizeof (int));\n+  s->mem[0] = 1;\n+  return s;\n+}\n+\n+int\n+main()\n+{\n+  struct S *s = foo();\n+  if (s->mem[0] != 1)\n+    __builtin_abort ();\n+  return 0;\n+}"}, {"sha": "37eaaa66a107226907320e13a8cde504928d7b9c", "filename": "gcc/testsuite/gcc.dg/tree-ssa/alias-37.c", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ed315c041f48f491d6310fe83810bb93cc3e5d17/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Falias-37.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ed315c041f48f491d6310fe83810bb93cc3e5d17/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Falias-37.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Falias-37.c?ref=ed315c041f48f491d6310fe83810bb93cc3e5d17", "patch": "@@ -0,0 +1,17 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -fdump-tree-dse1-details\" } */\n+\n+int i;\n+int *foo (int bogus, int n)\n+{\n+  int a[n];\n+  a[2] = bogus; /* Should elide this store since a cannot escape.  */\n+  int *p;\n+  if (bogus)\n+    p = &a[2];\n+  else\n+    p = &i;\n+  return p;\n+}\n+\n+/* { dg-final { scan-tree-dump \"Deleted dead store\" \"dse1\" } } */"}, {"sha": "cb85ec18bbcc6f6e56a631fe3e46b5cc734d23dc", "filename": "gcc/testsuite/gcc.dg/tree-ssa/pta-callused.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ed315c041f48f491d6310fe83810bb93cc3e5d17/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpta-callused.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ed315c041f48f491d6310fe83810bb93cc3e5d17/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpta-callused.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpta-callused.c?ref=ed315c041f48f491d6310fe83810bb93cc3e5d17", "patch": "@@ -22,5 +22,5 @@ int bar (int b)\n   return *foo (&q);\n }\n \n-/* { dg-final { scan-tree-dump \"CALLUSED\\\\(\\[0-9\\]+\\\\) = { ESCAPED NONLOCAL f.* i q }\" \"alias\" } } */\n+/* { dg-final { scan-tree-dump \"CALLUSED\\\\(\\[0-9\\]+\\\\) = { f.* i q }\" \"alias\" } } */\n "}, {"sha": "07791519c6cff0a395ee8b5267f201fde2230868", "filename": "gcc/tree-ssa-structalias.c", "status": "modified", "additions": 104, "deletions": 11, "changes": 115, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ed315c041f48f491d6310fe83810bb93cc3e5d17/gcc%2Ftree-ssa-structalias.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ed315c041f48f491d6310fe83810bb93cc3e5d17/gcc%2Ftree-ssa-structalias.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-structalias.c?ref=ed315c041f48f491d6310fe83810bb93cc3e5d17", "patch": "@@ -43,6 +43,7 @@\n #include \"stringpool.h\"\n #include \"attribs.h\"\n #include \"tree-ssa.h\"\n+#include \"tree-cfg.h\"\n \n /* The idea behind this analyzer is to generate set constraints from the\n    program, then solve the resulting constraints in order to generate the\n@@ -3854,7 +3855,6 @@ make_heapvar (const char *name, bool add_id)\n   DECL_EXTERNAL (heapvar) = 1;\n \n   vi = new_var_info (heapvar, name, add_id);\n-  vi->is_artificial_var = true;\n   vi->is_heap_var = true;\n   vi->is_unknown_size_var = true;\n   vi->offset = 0;\n@@ -4409,6 +4409,32 @@ find_func_aliases_for_builtin_call (struct function *fn, gcall *t)\n \t      process_constraint (new_constraint (*lhsp, ac));\n \t  return true;\n \t}\n+      case BUILT_IN_STACK_SAVE:\n+      case BUILT_IN_STACK_RESTORE:\n+        /* Nothing interesting happens.  */\n+        return true;\n+      case BUILT_IN_ALLOCA:\n+      case BUILT_IN_ALLOCA_WITH_ALIGN:\n+      case BUILT_IN_ALLOCA_WITH_ALIGN_AND_MAX:\n+\t{\n+\t  tree ptr = gimple_call_lhs (t);\n+\t  if (ptr == NULL_TREE)\n+\t    return true;\n+\t  get_constraint_for (ptr, &lhsc);\n+\t  varinfo_t vi = make_heapvar (\"HEAP\", true);\n+\t  /* Alloca storage is never global.  To exempt it from escaped\n+\t     handling make it a non-heap var.  */\n+\t  DECL_EXTERNAL (vi->decl) = 0;\n+\t  vi->is_global_var = 0;\n+\t  vi->is_heap_var = 0;\n+\t  struct constraint_expr tmpc;\n+\t  tmpc.var = vi->id;\n+\t  tmpc.offset = 0;\n+\t  tmpc.type = ADDRESSOF;\n+\t  rhsc.safe_push (tmpc);\n+\t  process_all_all_constraints (lhsc, rhsc);\n+\t  return true;\n+\t}\n       case BUILT_IN_POSIX_MEMALIGN:\n         {\n \t  tree ptrptr = gimple_call_arg (t, 0);\n@@ -4976,7 +5002,12 @@ find_func_aliases (struct function *fn, gimple *origt)\n       greturn *return_stmt = as_a <greturn *> (t);\n       fi = NULL;\n       if (!in_ipa_mode\n-\t  || !(fi = get_vi_for_tree (fn->decl)))\n+\t  && SSA_VAR_P (gimple_return_retval (return_stmt)))\n+\t{\n+\t  /* We handle simple returns by post-processing the solutions.  */\n+\t  ;\n+\t}\n+      if (!(fi = get_vi_for_tree (fn->decl)))\n \tmake_escape_constraint (gimple_return_retval (return_stmt));\n       else if (in_ipa_mode)\n \t{\n@@ -6422,9 +6453,7 @@ set_uids_in_ptset (bitmap into, bitmap from, struct pt_solution *pt,\n     {\n       varinfo_t vi = get_varinfo (i);\n \n-      /* The only artificial variables that are allowed in a may-alias\n-\t set are heap variables.  */\n-      if (vi->is_artificial_var && !vi->is_heap_var)\n+      if (vi->is_artificial_var)\n \tcontinue;\n \n       if (everything_escaped\n@@ -6544,9 +6573,6 @@ find_what_var_points_to (tree fndecl, varinfo_t orig_vi)\n \t    }\n \t  else if (vi->id == nonlocal_id)\n \t    pt->nonlocal = 1;\n-\t  else if (vi->is_heap_var)\n-\t    /* We represent heapvars in the points-to set properly.  */\n-\t    ;\n \t  else if (vi->id == string_id)\n \t    /* Nobody cares - STRING_CSTs are read-only entities.  */\n \t    ;\n@@ -7254,9 +7280,6 @@ solve_constraints (void)\n       dump_constraint_graph (dump_file);\n       fprintf (dump_file, \"\\n\\n\");\n     }\n-\n-  if (dump_file)\n-    dump_sa_points_to_info (dump_file);\n }\n \n /* Create points-to sets for the current function.  See the comments\n@@ -7304,6 +7327,73 @@ compute_points_to_sets (void)\n   /* From the constraints compute the points-to sets.  */\n   solve_constraints ();\n \n+  /* Post-process solutions for escapes through returns.  */\n+  edge_iterator ei;\n+  edge e;\n+  FOR_EACH_EDGE (e, ei, EXIT_BLOCK_PTR_FOR_FN (cfun)->preds)\n+    if (greturn *ret = safe_dyn_cast <greturn *> (last_stmt (e->src)))\n+      {\n+\ttree val = gimple_return_retval (ret);\n+\t/* ???  Easy to handle simple indirections with some work.\n+\t   Arbitrary references like foo.bar.baz are more difficult\n+\t   (but conservatively easy enough with just looking at the base).\n+\t   Mind to fixup find_func_aliases as well.  */\n+\tif (!val || !SSA_VAR_P (val))\n+\t  continue;\n+\t/* returns happen last in non-IPA so they only influence\n+\t   the ESCAPED solution and we can filter local variables.  */\n+\tvarinfo_t escaped_vi = get_varinfo (find (escaped_id));\n+\tvarinfo_t vi = lookup_vi_for_tree (val);\n+\tbitmap delta = BITMAP_ALLOC (&pta_obstack);\n+\tbitmap_iterator bi;\n+\tunsigned i;\n+\tfor (; vi; vi = vi_next (vi))\n+\t  {\n+\t    varinfo_t part_vi = get_varinfo (find (vi->id));\n+\t    EXECUTE_IF_AND_COMPL_IN_BITMAP (part_vi->solution,\n+\t\t\t\t\t    escaped_vi->solution, 0, i, bi)\n+\t      {\n+\t\tvarinfo_t pointed_to_vi = get_varinfo (i);\n+\t\tif (pointed_to_vi->is_global_var\n+\t\t    /* We delay marking of heap memory as global.  */\n+\t\t    || pointed_to_vi->is_heap_var)\n+\t\t  bitmap_set_bit (delta, i);\n+\t      }\n+\t  }\n+\n+\t/* Now compute the transitive closure.  */\n+\tbitmap_ior_into (escaped_vi->solution, delta);\n+\tbitmap new_delta = BITMAP_ALLOC (&pta_obstack);\n+\twhile (!bitmap_empty_p (delta))\n+\t  {\n+\t    EXECUTE_IF_SET_IN_BITMAP (delta, 0, i, bi)\n+\t      {\n+\t\tvarinfo_t pointed_to_vi = get_varinfo (i);\n+\t\tpointed_to_vi = get_varinfo (find (pointed_to_vi->id));\n+\t\tunsigned j;\n+\t\tbitmap_iterator bi2;\n+\t\tEXECUTE_IF_AND_COMPL_IN_BITMAP (pointed_to_vi->solution,\n+\t\t\t\t\t\tescaped_vi->solution,\n+\t\t\t\t\t\t0, j, bi2)\n+\t\t  {\n+\t\t    varinfo_t pointed_to_vi2 = get_varinfo (j);\n+\t\t    if (pointed_to_vi2->is_global_var\n+\t\t\t/* We delay marking of heap memory as global.  */\n+\t\t\t|| pointed_to_vi2->is_heap_var)\n+\t\t      bitmap_set_bit (new_delta, j);\n+\t\t  }\n+\t      }\n+\t    bitmap_ior_into (escaped_vi->solution, new_delta);\n+\t    bitmap_clear (delta);\n+\t    std::swap (delta, new_delta);\n+\t  }\n+\tBITMAP_FREE (delta);\n+\tBITMAP_FREE (new_delta);\n+      }\n+\n+  if (dump_file)\n+    dump_sa_points_to_info (dump_file);\n+\n   /* Compute the points-to set for ESCAPED used for call-clobber analysis.  */\n   cfun->gimple_df->escaped = find_what_var_points_to (cfun->decl,\n \t\t\t\t\t\t      get_varinfo (escaped_id));\n@@ -8109,6 +8199,9 @@ ipa_pta_execute (void)\n   /* From the constraints compute the points-to sets.  */\n   solve_constraints ();\n \n+  if (dump_file)\n+    dump_sa_points_to_info (dump_file);\n+\n   /* Now post-process solutions to handle locals from different\n      runtime instantiations coming in through recursive invocations.  */\n   unsigned shadow_var_cnt = 0;"}]}