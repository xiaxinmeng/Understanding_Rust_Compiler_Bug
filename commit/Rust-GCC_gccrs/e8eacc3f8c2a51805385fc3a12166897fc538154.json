{"sha": "e8eacc3f8c2a51805385fc3a12166897fc538154", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZThlYWNjM2Y4YzJhNTE4MDUzODVmYzNhMTIxNjY4OTdmYzUzODE1NA==", "commit": {"author": {"name": "Alexandre Oliva", "email": "aoliva@redhat.com", "date": "2001-02-12T06:18:44Z"}, "committer": {"name": "Alexandre Oliva", "email": "aoliva@gcc.gnu.org", "date": "2001-02-12T06:18:44Z"}, "message": "lcm.c (compute_earliest): Let EXIT_BLOCK be handled as a regular basic block.\n\n* lcm.c (compute_earliest): Let EXIT_BLOCK be handled as a regular\nbasic block.\n(optimize_mode_switching) [NORMAL_MODE]: Set up EXIT_BLOCK as a\nregular basic block, and arrange for all edges into it to switch\nto normal mode.\n\nFrom-SVN: r39594", "tree": {"sha": "6a6b6f5ad57996bef0e81235196d865cd6ca1648", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6a6b6f5ad57996bef0e81235196d865cd6ca1648"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e8eacc3f8c2a51805385fc3a12166897fc538154", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e8eacc3f8c2a51805385fc3a12166897fc538154", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e8eacc3f8c2a51805385fc3a12166897fc538154", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e8eacc3f8c2a51805385fc3a12166897fc538154/comments", "author": null, "committer": null, "parents": [{"sha": "79ff6e278e91d508b92455ec0be6ca6a300fff03", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/79ff6e278e91d508b92455ec0be6ca6a300fff03", "html_url": "https://github.com/Rust-GCC/gccrs/commit/79ff6e278e91d508b92455ec0be6ca6a300fff03"}], "stats": {"total": 128, "additions": 101, "deletions": 27}, "files": [{"sha": "ef0fe4296ce2930cb020d635b952ef8792060101", "filename": "gcc/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e8eacc3f8c2a51805385fc3a12166897fc538154/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e8eacc3f8c2a51805385fc3a12166897fc538154/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=e8eacc3f8c2a51805385fc3a12166897fc538154", "patch": "@@ -1,3 +1,11 @@\n+2001-02-12  Alexandre Oliva  <aoliva@redhat.com>\n+\n+\t* lcm.c (compute_earliest): Let EXIT_BLOCK be handled as a regular\n+\tbasic block.\n+\t(optimize_mode_switching) [NORMAL_MODE]: Set up EXIT_BLOCK as a\n+\tregular basic block, and arrange for all edges into it to switch\n+\tto normal mode.\n+\n 2001-02-11  Gerald Pfeifer  <pfeifer@dbai.tuwien.ac.at>\n \n \t* Makefile.in (distclean): Do not remove .gdbinit."}, {"sha": "43bebe74ece03695a8cc956130acad4164952f3b", "filename": "gcc/lcm.c", "status": "modified", "additions": 93, "deletions": 27, "changes": 120, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e8eacc3f8c2a51805385fc3a12166897fc538154/gcc%2Flcm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e8eacc3f8c2a51805385fc3a12166897fc538154/gcc%2Flcm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flcm.c?ref=e8eacc3f8c2a51805385fc3a12166897fc538154", "patch": "@@ -205,7 +205,11 @@ compute_earliest (edge_list, n_exprs, antin, antout, avout, kill, earliest)\n \tsbitmap_copy (earliest[x], antin[succ->index]);\n       else\n         {\n-\t  if (succ == EXIT_BLOCK_PTR)\n+\t  /* We refer to the EXIT_BLOCK index, instead of testing for\n+\t     EXIT_BLOCK_PTR, so that EXIT_BLOCK_PTR's index can be\n+\t     changed so as to pretend it's a regular block, so that\n+\t     its antin can be taken into account.  */\n+\t  if (succ->index == EXIT_BLOCK)\n \t    sbitmap_zero (earliest[x]);\n \t  else\n \t    {\n@@ -1019,6 +1023,11 @@ optimize_mode_switching (file)\n   int n_entities;\n   int max_num_modes = 0;\n \n+#ifdef NORMAL_MODE\n+  /* Increment n_basic_blocks before allocating bb_info.  */\n+  n_basic_blocks++;\n+#endif\n+\n   for (e = N_ENTITIES - 1, n_entities = 0; e >= 0; e--)\n     if (OPTIMIZE_MODE_SWITCHING (e))\n       {\n@@ -1030,9 +1039,27 @@ optimize_mode_switching (file)\n \t  max_num_modes = num_modes[e];\n       }\n \n+#ifdef NORMAL_MODE\n+  /* Decrement it back in case we return below.  */\n+  n_basic_blocks--;\n+#endif\n+\n   if (! n_entities)\n     return 0;\n \n+#ifdef NORMAL_MODE\n+  /* We're going to pretend the EXIT_BLOCK is a regular basic block,\n+     so that switching back to normal mode when entering the\n+     EXIT_BLOCK isn't optimized away.  We do this by incrementing the\n+     basic block count, growing the VARRAY of basic_block_info and\n+     appending the EXIT_BLOCK_PTR to it.  */\n+  n_basic_blocks++;\n+  if (VARRAY_SIZE (basic_block_info) < n_basic_blocks)\n+    VARRAY_GROW (basic_block_info, n_basic_blocks);\n+  BASIC_BLOCK (n_basic_blocks - 1) = EXIT_BLOCK_PTR;\n+  EXIT_BLOCK_PTR->index = n_basic_blocks - 1;\n+#endif\n+\n   /* Create the bitmap vectors.  */\n \n   antic = sbitmap_vector_alloc (n_basic_blocks, n_entities);\n@@ -1087,29 +1114,6 @@ optimize_mode_switching (file)\n \t\t}\n \t    }\n \n-\t  /* If this is a predecessor of the exit block, and we must \n-\t     force a mode on exit, make note of that.  */\n-#ifdef NORMAL_MODE\n-\t  if (NORMAL_MODE (e) != no_mode && last_mode != NORMAL_MODE (e))\n-\t    for (eg = BASIC_BLOCK (bb)->succ; eg; eg = eg->succ_next)\n-\t      if (eg->dest == EXIT_BLOCK_PTR)\n-\t\t{\n-\t\t  rtx insn = BLOCK_END (bb);\n-\n-\t\t  /* Find the last insn before a USE and/or JUMP.  */\n-\t\t  while ((GET_CODE (insn) == INSN \n-\t\t\t      && GET_CODE (PATTERN (insn)) == USE)\n-\t\t\t  || GET_CODE (insn) == JUMP_INSN)\n-\t\t    insn = PREV_INSN (insn);\n-\t\t  if (insn != BLOCK_END (bb) && NEXT_INSN (insn))\n-\t\t    insn = NEXT_INSN (insn);\n-\t\t  last_mode = NORMAL_MODE (e);\n-\t\t  add_seginfo (info + bb, \n-\t\t      new_seginfo (last_mode, insn, bb, live_now));\n-\t\t  RESET_BIT (transp[bb], j);\n-\t\t} \n-#endif\n-\n \t  info[bb].computing = last_mode;\n \t  /* Check for blocks without ANY mode requirements.  */\n \t  if (last_mode == no_mode)\n@@ -1149,6 +1153,9 @@ optimize_mode_switching (file)\n \t\t    info[bb].seginfo->mode = no_mode;\n \t\t  }\n \t      }\n+\n+\t    bb = n_basic_blocks - 1;\n+\t    info[bb].seginfo->mode = mode;\n \t  }\n       }\n #endif /* NORMAL_MODE */\n@@ -1223,14 +1230,27 @@ optimize_mode_switching (file)\n \t      mode_set = gen_sequence ();\n \t      end_sequence ();\n \n-\t      /* If this is an abnormal edge, we'll insert at the end of the\n-\t\t previous block.  */\n+\t      /* If this is an abnormal edge, we'll insert at the end\n+\t\t of the previous block.  */\n \t      if (eg->flags & EDGE_ABNORMAL)\n \t\t{\n \t\t  if (GET_CODE (src_bb->end) == JUMP_INSN)\n \t\t    emit_insn_before (mode_set, src_bb->end);\n-\t\t  else\n+\t\t  /* It doesn't make sense to switch to normal mode\n+\t\t     after a CALL_INSN, so we're going to abort if we\n+\t\t     find one.  The cases in which a CALL_INSN may\n+\t\t     have an abnormal edge are sibcalls and EH edges.\n+\t\t     In the case of sibcalls, the dest basic-block is\n+\t\t     the EXIT_BLOCK, that runs in normal mode; it is\n+\t\t     assumed that a sibcall insn requires normal mode\n+\t\t     itself, so no mode switch would be required after\n+\t\t     the call (it wouldn't make sense, anyway).  In\n+\t\t     the case of EH edges, EH entry points also start\n+\t\t     in normal mode, so a similar reasoning applies.  */\n+\t\t  else if (GET_CODE (src_bb->end) == INSN)\n \t\t    src_bb->end = emit_insn_after (mode_set, src_bb->end);\n+\t\t  else\n+\t\t    abort ();\n \t\t  bb_info[j][src_bb->index].computing = mode;\n \t\t  RESET_BIT (transp[src_bb->index], j);\n \t\t}\n@@ -1253,11 +1273,57 @@ optimize_mode_switching (file)\n       free_edge_list (edge_list);\n     }\n \n+#ifdef NORMAL_MODE\n+  /* Restore the special status of EXIT_BLOCK.  */\n+  n_basic_blocks--;\n+  VARRAY_POP (basic_block_info);\n+  EXIT_BLOCK_PTR->index = EXIT_BLOCK;\n+#endif\n+  \n   /* Now output the remaining mode sets in all the segments.  */\n   for (j = n_entities - 1; j >= 0; j--)\n     {\n       int no_mode = num_modes[entity_map[j]];\n \n+#ifdef NORMAL_MODE\n+      if (bb_info[j][n_basic_blocks].seginfo->mode != no_mode)\n+\t{\n+\t  edge eg;\n+\t  struct seginfo *ptr = bb_info[j][n_basic_blocks].seginfo;\n+\n+\t  for (eg = EXIT_BLOCK_PTR->pred; eg; eg = eg->pred_next)\n+\t    {\n+\t      rtx mode_set;\n+\n+\t      if (bb_info[j][eg->src->index].computing == ptr->mode)\n+\t\tcontinue;\n+\n+\t      start_sequence ();\n+\t      EMIT_MODE_SET (entity_map[j], ptr->mode, ptr->regs_live);\n+\t      mode_set = gen_sequence ();\n+\t      end_sequence ();\n+\n+\t      /* If this is an abnormal edge, we'll insert at the end of the\n+\t\t previous block.  */\n+\t      if (eg->flags & EDGE_ABNORMAL)\n+\t\t{\n+\t\t  if (GET_CODE (eg->src->end) == JUMP_INSN)\n+\t\t    emit_insn_before (mode_set, eg->src->end);\n+\t\t  else if (GET_CODE (eg->src->end) == INSN)\n+\t\t    eg->src->end = emit_insn_after (mode_set, eg->src->end);\n+\t\t  else\n+\t\t    abort ();\n+\t\t}\n+\t      else\n+\t\t{\n+\t\t  need_commit = 1;\n+\t\t  insert_insn_on_edge (mode_set, eg);\n+\t\t}\n+\t    }\n+\t  \n+\t}\n+#endif\n+\n       for (bb = n_basic_blocks - 1; bb >= 0; bb--)\n \t{\n \t  struct seginfo *ptr, *next;"}]}