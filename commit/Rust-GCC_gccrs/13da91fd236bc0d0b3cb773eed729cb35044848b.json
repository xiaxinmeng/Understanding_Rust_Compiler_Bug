{"sha": "13da91fd236bc0d0b3cb773eed729cb35044848b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTNkYTkxZmQyMzZiYzBkMGIzY2I3NzNlZWQ3MjljYjM1MDQ0ODQ4Yg==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@cygnus.com", "date": "2000-06-13T23:19:50Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2000-06-13T23:19:50Z"}, "message": "ia64.h (enum reg_class): Remove FR_INT_REGS, FR_FP_REGS, GR_AND_FR_INT_REGS, GR_AND_FR_FP_REGS.\n\n        * config/ia64/ia64.h (enum reg_class): Remove FR_INT_REGS, FR_FP_REGS,\n        GR_AND_FR_INT_REGS, GR_AND_FR_FP_REGS.\n        (REG_CLASS_NAMES): Likewise.\n        (REG_CLASS_CONTENTS): Likewise.\n        (FR_FP_REGNO_P, FR_INT_REGNO_P): Remove.\n        (HARD_REGNO_MODE_OK): Remove references to them.\n        (REGNO_REG_CLASS): Likewise.\n        (REG_CLASS_FROM_LETTER): Likewise.\n        (CLASS_MAX_NREGS): Likewise.\n        (REGISTER_MOVE_COST): Likewise.\n        * config/ia64/ia64.c (ia64_secondary_reload_class): Likewise.\n        * config/ia64/ia64.md (*): Replace \"e\" constraints with \"f\".\n        (movqi_internal): Special case moves from zero.\n        (movhi_internal, movsi_internal): Likewise.\n        (movdi_internal): Likewise.  Fill out \"f\" constraints.\n        (movsf_internal): Fill out \"r\" constraints.\n        (movdf_internal): Likewise.\n\nFrom-SVN: r34530", "tree": {"sha": "104194e76715dd66e67931e2b5aca5c7af9cd3d0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/104194e76715dd66e67931e2b5aca5c7af9cd3d0"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/13da91fd236bc0d0b3cb773eed729cb35044848b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/13da91fd236bc0d0b3cb773eed729cb35044848b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/13da91fd236bc0d0b3cb773eed729cb35044848b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/13da91fd236bc0d0b3cb773eed729cb35044848b/comments", "author": null, "committer": null, "parents": [{"sha": "ef3843807ecc4825706ae4277b81124ac3cd67eb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ef3843807ecc4825706ae4277b81124ac3cd67eb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ef3843807ecc4825706ae4277b81124ac3cd67eb"}], "stats": {"total": 284, "additions": 121, "deletions": 163}, "files": [{"sha": "299ffd66fea94dccccca7cad4daeb383ef1176b8", "filename": "gcc/ChangeLog", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/13da91fd236bc0d0b3cb773eed729cb35044848b/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/13da91fd236bc0d0b3cb773eed729cb35044848b/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=13da91fd236bc0d0b3cb773eed729cb35044848b", "patch": "@@ -1,3 +1,23 @@\n+2000-06-13  Richard Henderson  <rth@cygnus.com>\n+\n+\t* config/ia64/ia64.h (enum reg_class): Remove FR_INT_REGS, FR_FP_REGS,\n+\tGR_AND_FR_INT_REGS, GR_AND_FR_FP_REGS.\n+\t(REG_CLASS_NAMES): Likewise.\n+\t(REG_CLASS_CONTENTS): Likewise.\n+\t(FR_FP_REGNO_P, FR_INT_REGNO_P): Remove.\n+\t(HARD_REGNO_MODE_OK): Remove references to them.\n+\t(REGNO_REG_CLASS): Likewise.\n+\t(REG_CLASS_FROM_LETTER): Likewise.\n+\t(CLASS_MAX_NREGS): Likewise.\n+\t(REGISTER_MOVE_COST): Likewise.\n+\t* config/ia64/ia64.c (ia64_secondary_reload_class): Likewise.\n+\t* config/ia64/ia64.md (*): Replace \"e\" constraints with \"f\".\n+\t(movqi_internal): Special case moves from zero.\n+\t(movhi_internal, movsi_internal): Likewise.\n+\t(movdi_internal): Likewise.  Fill out \"f\" constraints.\n+\t(movsf_internal): Fill out \"r\" constraints.\n+\t(movdf_internal): Likewise.\n+\n 2000-06-13  Richard Henderson  <rth@cygnus.com>\n \n \t* flow.c (insn_dead_p): Keep sets to PIC_OFFSET_TABLE_REGNUM"}, {"sha": "8357e2ca6e577e1e7c18b91657af50f49b670b56", "filename": "gcc/config/ia64/ia64.c", "status": "modified", "additions": 2, "deletions": 10, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/13da91fd236bc0d0b3cb773eed729cb35044848b/gcc%2Fconfig%2Fia64%2Fia64.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/13da91fd236bc0d0b3cb773eed729cb35044848b/gcc%2Fconfig%2Fia64%2Fia64.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fia64%2Fia64.c?ref=13da91fd236bc0d0b3cb773eed729cb35044848b", "patch": "@@ -1969,7 +1969,7 @@ ia64_secondary_reload_class (class, mode, x)\n      because paradoxical subregs are not accepted by register_operand when\n      INSN_SCHEDULING is defined.  Or alternatively, stop the paradoxical subreg\n      stupidity in the *_operand functions in recog.c.  */\n-  if ((class == FR_REGS || class == FR_INT_REGS || class == FR_FP_REGS)\n+  if (class == FR_REGS\n       && GET_CODE (x) == MEM\n       && (GET_MODE (x) == SImode || GET_MODE (x) == HImode\n \t  || GET_MODE (x) == QImode))\n@@ -1978,15 +1978,7 @@ ia64_secondary_reload_class (class, mode, x)\n   /* This can happen because of the ior/and/etc patterns that accept FP\n      registers as operands.  If the third operand is a constant, then it\n      needs to be reloaded into a FP register.  */\n-  if ((class == FR_REGS || class == FR_INT_REGS || class == FR_FP_REGS)\n-      && GET_CODE (x) == CONST_INT)\n-    return GR_REGS;\n-\n-  /* Moving a integer from an FP register to memory requires a general register\n-     as an intermediary.  This is not necessary if we are moving a DImode\n-     subreg of a DFmode value from an FP register to memory, since stfd will\n-     do the right thing in this case.  */\n-  if (class == FR_INT_REGS && GET_CODE (x) == MEM && GET_MODE (x) == DImode)\n+  if (class == FR_REGS && GET_CODE (x) == CONST_INT)\n     return GR_REGS;\n \n   /* ??? This happens if we cse/gcse a CCmode value across a call, and the"}, {"sha": "08a2c8b9a05a00bb15fbacd1c76fe82ec4b4687f", "filename": "gcc/config/ia64/ia64.h", "status": "modified", "additions": 8, "deletions": 45, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/13da91fd236bc0d0b3cb773eed729cb35044848b/gcc%2Fconfig%2Fia64%2Fia64.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/13da91fd236bc0d0b3cb773eed729cb35044848b/gcc%2Fconfig%2Fia64%2Fia64.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fia64%2Fia64.h?ref=13da91fd236bc0d0b3cb773eed729cb35044848b", "patch": "@@ -545,10 +545,6 @@ while (0)\n /* Ranges for the various kinds of registers.  */\n #define ADDL_REGNO_P(REGNO) ((REGNO) >= 0 && (REGNO) <= 3)\n #define GR_REGNO_P(REGNO) ((REGNO) >= 0 && (REGNO) <= 127)\n-#define FR_FP_REGNO_P(REGNO) \\\n-  (((REGNO) >= 128 && (REGNO) <= 143) || ((REGNO) >= 152 && (REGNO) <= 223))\n-#define FR_INT_REGNO_P(REGNO) \\\n-  (((REGNO) >= 144 && (REGNO) <= 151) || ((REGNO) >= 224 && (REGNO) <= 255))\n #define FR_REGNO_P(REGNO) ((REGNO) >= 128 && (REGNO) <= 255)\n #define PR_REGNO_P(REGNO) ((REGNO) >= 256 && (REGNO) <= 319)\n #define BR_REGNO_P(REGNO) ((REGNO) >= 320 && (REGNO) <= 327)\n@@ -816,10 +812,7 @@ while (0)\n    that one).  */\n \n #define HARD_REGNO_MODE_OK(REGNO, MODE) \\\n-  (FR_FP_REGNO_P (REGNO) ? ! INTEGRAL_MODE_P (MODE)\t\t\t\\\n-   : FR_INT_REGNO_P (REGNO) ? ! FLOAT_MODE_P (MODE)\t\t\t\\\n-   : PR_REGNO_P (REGNO) ? (MODE) == CCmode\t\t\t\t\\\n-   : 1)\n+  (PR_REGNO_P (REGNO) ? (MODE) == CCmode : 1)\n \n /* A C expression that is nonzero if it is desirable to choose register\n    allocation so as to avoid move instructions between a value of mode MODE1\n@@ -861,11 +854,6 @@ while (0)\n    register class, followed by one more enumeral value, `LIM_REG_CLASSES',\n    which is not a register class but rather tells how many classes there\n    are.  */\n-/* ??? FP registers hold INT and FP values in different representations, so\n-   we can't just use a subreg to convert between the two.  We get around this\n-   problem by segmenting the FP register set into two parts.  One part (FR_INT)\n-   only holds integer values, and one part (FR_FP) only hold FP values.  Thus\n-   we always know which representation is being used.  */\n /* ??? When compiling without optimization, it is possible for the only use of\n    a pseudo to be a parameter load from the stack with a REG_EQUIV note.\n    Regclass handles this case specially and does not assign any costs to the\n@@ -879,11 +867,7 @@ enum reg_class\n   BR_REGS,\n   ADDL_REGS,\n   GR_REGS,\n-  FR_INT_REGS,\n-  FR_FP_REGS,\n   FR_REGS,\n-  GR_AND_FR_INT_REGS,\n-  GR_AND_FR_FP_REGS,\n   GR_AND_FR_REGS,\n   ALL_REGS,\n   LIM_REG_CLASSES\n@@ -897,9 +881,8 @@ enum reg_class\n /* An initializer containing the names of the register classes as C string\n    constants.  These names are used in writing some of the debugging dumps.  */\n #define REG_CLASS_NAMES \\\n-{ \"NO_REGS\", \"PR_REGS\", \"BR_REGS\", \"ADDL_REGS\", \"GR_REGS\", \"FR_INT_REGS\", \\\n-  \"FR_FP_REGS\", \"FR_REGS\", \"GR_AND_FR_INT_REGS\", \"GR_AND_FR_FP_REGS\",\t  \\\n-  \"GR_AND_FR_REGS\", \"ALL_REGS\" }\n+{ \"NO_REGS\", \"PR_REGS\", \"BR_REGS\", \"ADDL_REGS\", \"GR_REGS\", \\\n+  \"FR_REGS\", \"GR_AND_FR_REGS\", \"ALL_REGS\" }\n \n /* An initializer containing the contents of the register classes, as integers\n    which are bit masks.  The Nth integer specifies the contents of class N.\n@@ -927,26 +910,10 @@ enum reg_class\n   { 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF,\t\\\n     0x00000000, 0x00000000, 0x00000000, 0x00000000,\t\\\n     0x00000000, 0x00000000, 0x300 },\t\t\t\\\n-  /* FR_INT_REGS.  */\t\t\t\t\t\\\n-  { 0x00000000, 0x00000000, 0x00000000, 0x00000000,\t\\\n-    0x00FF0000, 0x00000000, 0x00000000, 0xFFFFFFFF,\t\\\n-    0x00000000, 0x00000000, 0x000 },\t\t\t\\\n-  /* FR_FP_REGS.  */\t\t\t\t\t\\\n-  { 0x00000000, 0x00000000, 0x00000000, 0x00000000,\t\\\n-    0xFF00FFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0x00000000,\t\\\n-    0x00000000, 0x00000000, 0x000 },\t\t\t\\\n   /* FR_REGS.  */\t\t\t\t\t\\\n   { 0x00000000, 0x00000000, 0x00000000, 0x00000000,\t\\\n     0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF,\t\\\n     0x00000000, 0x00000000, 0x000 },\t\t\t\\\n-  /* GR_AND_FR_INT_REGS.  */\t\t\t\t\\\n-  { 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF,\t\\\n-    0x00FF0000, 0x00000000, 0x00000000, 0xFFFFFFFF,\t\\\n-    0x00000000, 0x00000000, 0x300 },\t\t\t\\\n-  /* GR_AND_FR_FP_REGS.  */\t\t\t\t\\\n-  { 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF,\t\\\n-    0xFF00FFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0x00000000,\t\\\n-    0x00000000, 0x00000000, 0x300 },\t\t\t\\\n   /* GR_AND_FR_REGS.  */\t\t\t\t\\\n   { 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF,\t\\\n     0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF,\t\\\n@@ -966,8 +933,7 @@ enum reg_class\n #define REGNO_REG_CLASS(REGNO) \\\n (ADDL_REGNO_P (REGNO) ? ADDL_REGS\t\\\n  : GENERAL_REGNO_P (REGNO) ? GR_REGS\t\\\n- : FR_FP_REGNO_P (REGNO) ? FR_FP_REGS\t\\\n- : FR_INT_REGNO_P (REGNO) ? FR_INT_REGS\t\\\n+ : FR_REGNO_P (REGNO) ? FR_REGS\t\t\\\n  : PR_REGNO_P (REGNO) ? PR_REGS\t\t\\\n  : BR_REGNO_P (REGNO) ? BR_REGS\t\t\\\n  : NO_REGS)\n@@ -990,8 +956,7 @@ enum reg_class\n    will not be passed to this macro; you do not need to handle it.  */\n \n #define REG_CLASS_FROM_LETTER(CHAR) \\\n-((CHAR) == 'f' ? FR_FP_REGS\t\t\\\n- : (CHAR) == 'e' ? FR_INT_REGS\t\t\\\n+((CHAR) == 'f' ? FR_REGS\t\t\\\n  : (CHAR) == 'a' ? ADDL_REGS\t\t\\\n  : (CHAR) == 'b' ? BR_REGS\t\t\\\n  : (CHAR) == 'c' ? PR_REGS\t\t\\\n@@ -1041,9 +1006,8 @@ enum reg_class\n    This is closely related to the macro `HARD_REGNO_NREGS'.  */\n \n #define CLASS_MAX_NREGS(CLASS, MODE) \\\n-  ((MODE) == CCmode && (CLASS) == PR_REGS ? 2\t\t\t\t\\\n-   : (((CLASS) == FR_REGS || (CLASS) == FR_FP_REGS\t\t\t\\\n-       || (CLASS) == FR_INT_REGS) && (MODE) == XFmode) ? 1\t\t\\\n+  ((MODE) == CCmode && (CLASS) == PR_REGS ? 2\t\t\t\\\n+   : ((CLASS) == FR_REGS && (MODE) == XFmode) ? 1\t\t\\\n    : (GET_MODE_SIZE (MODE) + UNITS_PER_WORD - 1) / UNITS_PER_WORD)\n \n /* If defined, gives a class of registers that cannot be used as the\n@@ -1160,6 +1124,7 @@ enum reg_class\n    or a `MEM' representing a location in the stack.  This enables DWARF2\n    unwind info for C++ EH.  */\n #define INCOMING_RETURN_ADDR_RTX gen_rtx_REG (VOIDmode, BR_REG (0))\n+\n /* ??? This is not defined because of three problems.\n    1) dwarf2out.c assumes that DWARF_FRAME_RETURN_COLUMN fits in one byte.\n    The default value is FIRST_PSEUDO_REGISTER which doesn't.  This can be\n@@ -1925,8 +1890,6 @@ do {\t\t\t\t\t\t\t\t\t\\\n ((FROM) == BR_REGS && (TO) == BR_REGS ? 8\t\t\t\t\\\n  : (((FROM) == BR_REGS && (TO) != GENERAL_REGS)\t\t\t\t\\\n     || ((TO) == BR_REGS && (FROM) != GENERAL_REGS)) ? 6\t\t\t\\\n- : (((FROM) == FR_FP_REGS && (TO) == FR_INT_REGS)\t\t\t\\\n-    || ((FROM) == FR_INT_REGS && (TO) == FR_FP_REGS)) ? 4\t\t\\\n  : 2)\n \n /* A C expression for the cost of moving data of mode M between a register and"}, {"sha": "07adbe3be3ba3dc23462cd8114f7715bb2ba00ca", "filename": "gcc/config/ia64/ia64.md", "status": "modified", "additions": 91, "deletions": 108, "changes": 199, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/13da91fd236bc0d0b3cb773eed729cb35044848b/gcc%2Fconfig%2Fia64%2Fia64.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/13da91fd236bc0d0b3cb773eed729cb35044848b/gcc%2Fconfig%2Fia64%2Fia64.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fia64%2Fia64.md?ref=13da91fd236bc0d0b3cb773eed729cb35044848b", "patch": "@@ -177,18 +177,19 @@\n }\")\n \n (define_insn \"*movqi_internal\"\n-  [(set (match_operand:QI 0 \"nonimmediate_operand\" \"=r,r,r,m,r,*e\")\n-\t(match_operand:QI 1 \"move_operand\" \"r,J,m,r,*e,r\"))]\n+  [(set (match_operand:QI 0 \"nonimmediate_operand\" \"=r,r,r, m, r,*f,*f\")\n+\t(match_operand:QI 1 \"move_operand\"         \"rO,J,m,rO,*f,rO,*f\"))]\n   \"! memory_operand (operands[0], QImode)\n    || ! memory_operand (operands[1], QImode)\"\n   \"@\n-   mov %0 = %1\n+   mov %0 = %r1\n    addl %0 = %1, r0\n    ld1%O1 %0 = %1%P1\n-   st1%Q0 %0 = %1%P0\n+   st1%Q0 %0 = %r1%P0\n    getf.sig %0 = %1\n-   setf.sig %0 = %1\"\n-  [(set_attr \"type\" \"A,A,M,M,M,M\")])\n+   setf.sig %0 = %r1\n+   mov %0 = %1\"\n+  [(set_attr \"type\" \"A,A,M,M,M,M,F\")])\n \n (define_expand \"movhi\"\n   [(set (match_operand:HI 0 \"general_operand\" \"\")\n@@ -203,18 +204,19 @@\n }\")\n \n (define_insn \"*movhi_internal\"\n-  [(set (match_operand:HI 0 \"nonimmediate_operand\" \"=r,r,r,m,r,*e\")\n-\t(match_operand:HI 1 \"move_operand\" \"r,J,m,r,*e,r\"))]\n+  [(set (match_operand:HI 0 \"nonimmediate_operand\" \"=r,r,r, m, r,*f,*f\")\n+\t(match_operand:HI 1 \"move_operand\"         \"rO,J,m,rO,*f,rO,*f\"))]\n   \"! memory_operand (operands[0], HImode)\n    || !memory_operand (operands[1], HImode)\"\n   \"@\n-   mov %0 = %1\n+   mov %0 = %r1\n    addl %0 = %1, r0\n    ld2%O1 %0 = %1%P1\n-   st2%Q0 %0 = %1%P0\n+   st2%Q0 %0 = %r1%P0\n    getf.sig %0 = %1\n-   setf.sig %0 = %1\"\n-  [(set_attr \"type\" \"A,A,M,M,M,M\")])\n+   setf.sig %0 = %r1\n+   mov %0 = %1\"\n+  [(set_attr \"type\" \"A,A,M,M,M,M,F\")])\n \n (define_expand \"movsi\"\n   [(set (match_operand:SI 0 \"general_operand\" \"\")\n@@ -229,22 +231,20 @@\n }\")\n \n (define_insn \"*movsi_internal\"\n-  [(set (match_operand:SI 0 \"nonimmediate_operand\" \"=r,r,r,r,m,r,*e,*e,r,*f\")\n-\t(match_operand:SI 1 \"move_operand\"       \"r,J,i,m,r,*e,r,*e,*f,r\"))]\n+  [(set (match_operand:SI 0 \"nonimmediate_operand\" \"=r,r,r,r, m, r,*f,*f\")\n+\t(match_operand:SI 1 \"move_operand\"         \"rO,J,i,m,rO,*f,rO,*f\"))]\n   \"! memory_operand (operands[0], SImode)\n    || ! memory_operand (operands[1], SImode)\"\n   \"@\n-  mov %0 = %1\n+  mov %0 = %r1\n   addl %0 = %1, r0\n   movl %0 = %1\n   ld4%O1 %0 = %1%P1\n-  st4%Q0 %0 = %1%P0\n+  st4%Q0 %0 = %r1%P0\n   getf.sig %0 = %1\n-  setf.sig %0 = %1\n-  mov %0 = %1\n-  getf.s %0 = %1\n-  setf.s %0 = %1\"\n-  [(set_attr \"type\" \"A,A,L,M,M,M,M,F,M,M\")])\n+  setf.sig %0 = %r1\n+  mov %0 = %1\"\n+  [(set_attr \"type\" \"A,A,L,M,M,M,M,F\")])\n \n (define_expand \"movdi\"\n   [(set (match_operand:DI 0 \"general_operand\" \"\")\n@@ -287,25 +287,24 @@\n     operands[1] = copy_to_mode_reg (DImode, operands[1]);\n }\")\n \n-;; ??? Emit stf8 for m/*e constraint.\n (define_insn \"*movdi_internal\"\n-  [(set (match_operand:DI 0 \"nonimmediate_operand\" \"=r,r,r,r,m,r,*e,*e,r,*f,r,*b\")\n-\t(match_operand:DI 1 \"move_operand\"       \"r,J,i,m,r,*e,r,*e,*f,r,*b,r\"))]\n+  [(set (match_operand:DI 0 \"nonimmediate_operand\" \"=r,r,r,r, m, r,*f,*f,*f, m, r,*b\")\n+\t(match_operand:DI 1 \"move_operand\"         \"rO,J,i,m,rO,*f,rO,*f, m,*f,*b,rO\"))]\n   \"! memory_operand (operands[0], DImode)\n    || ! memory_operand (operands[1], DImode)\"\n   \"@\n-  mov %0 = %1\n+  mov %0 = %r1\n   addl %0 = %1, r0\n   movl %0 = %1\n   ld8%O1 %0 = %1%P1\n-  st8%Q0 %0 = %1%P0\n+  st8%Q0 %0 = %r1%P0\n   getf.sig %0 = %1\n-  setf.sig %0 = %1\n+  setf.sig %0 = %r1\n   mov %0 = %1\n-  getf.d %0 = %1\n-  setf.d %0 = %1\n+  ldf8%O1 %0 = %1%P1\n+  stf8%Q0 %0 = %1%P0\n   mov %0 = %1\n-  mov %0 = %1\"\n+  mov %0 = %r1\"\n   [(set_attr \"type\" \"A,A,L,M,M,M,M,F,M,M,I,I\")])\n \n (define_expand \"load_fptr\"\n@@ -392,12 +391,9 @@\n     operands[1] = copy_to_mode_reg (SFmode, operands[1]);\n }\")\n \n-;; ??? The r/m alternative is apparently needed because of paradoxical subregs,\n-;; so it may no longer be necessary after scheduling is enabled.\n-\n (define_insn \"*movsf_internal\"\n-  [(set (match_operand:SF 0 \"nonimmediate_operand\" \"=f,f,m,*r,f,*r,*r\")\n-\t(match_operand:SF 1 \"general_operand\" \"fG,m,fG,fG,*r,*r,m\"))]\n+  [(set (match_operand:SF 0 \"nonimmediate_operand\" \"=f,f, m,*r, f,*r,*r, m\")\n+\t(match_operand:SF 1 \"general_operand\"      \"fG,m,fG,fG,*r,*r, m,*r\"))]\n   \"! memory_operand (operands[0], SFmode)\n    || ! memory_operand (operands[1], SFmode)\"\n   \"@\n@@ -407,8 +403,9 @@\n   getf.s %0 = %F1\n   setf.s %0 = %1\n   mov %0 = %1\n-  ld4%O1 %0 = %1\"\n-  [(set_attr \"type\" \"F,M,M,M,M,A,M\")])\n+  ld4%O1 %0 = %1%P1\n+  st4%Q0 %0 = %1%P0\"\n+  [(set_attr \"type\" \"F,M,M,M,M,A,M,M\")])\n \n (define_expand \"movdf\"\n   [(set (match_operand:DF 0 \"general_operand\" \"\")\n@@ -422,11 +419,9 @@\n     operands[1] = copy_to_mode_reg (DFmode, operands[1]);\n }\")\n \n-;; ??? movsf has a r/m alternative, movdf doesn't.\n-\n (define_insn \"*movdf_internal\"\n-  [(set (match_operand:DF 0 \"nonimmediate_operand\" \"=f,f,m,*r,f,*r\")\n-\t(match_operand:DF 1 \"general_operand\" \"fG,m,fG,fG,*r,*r\"))]\n+  [(set (match_operand:DF 0 \"nonimmediate_operand\" \"=f,f, m,*r, f,*r,*r, m\")\n+\t(match_operand:DF 1 \"general_operand\"      \"fG,m,fG,fG,*r,*r, m,*r\"))]\n   \"! memory_operand (operands[0], DFmode)\n    || ! memory_operand (operands[1], DFmode)\"\n   \"@\n@@ -435,8 +430,10 @@\n   stfd %0 = %F1%P0\n   getf.d %0 = %F1\n   setf.d %0 = %1\n-  mov %0 = %1\"\n-  [(set_attr \"type\" \"F,M,M,M,M,A\")])\n+  mov %0 = %1\n+  ld8%O1 %0 = %1%P1\n+  st8%Q0 %0 = %1%P0\"\n+  [(set_attr \"type\" \"F,M,M,M,M,A,M,M\")])\n \n (define_expand \"movxf\"\n   [(set (match_operand:XF 0 \"general_operand\" \"\")\n@@ -451,8 +448,8 @@\n }\")\n \n (define_insn \"*movxf_internal\"\n-  [(set (match_operand:XF 0 \"nonimmediate_operand\" \"=f,f,m\")\n-\t(match_operand:XF 1 \"general_operand\" \"fG,m,fG\"))]\n+  [(set (match_operand:XF 0 \"nonimmediate_operand\" \"=f,f, m\")\n+\t(match_operand:XF 1 \"general_operand\"      \"fG,m,fG\"))]\n   \"! memory_operand (operands[0], XFmode)\n    || ! memory_operand (operands[1], XFmode)\"\n   \"@\n@@ -485,8 +482,8 @@\n   [(set_attr \"type\" \"I\")])\n \n (define_insn \"extendsidi2\"\n-  [(set (match_operand:DI 0 \"register_operand\" \"=r,*e\")\n-\t(sign_extend:DI (match_operand:SI 1 \"register_operand\" \"r,*e\")))]\n+  [(set (match_operand:DI 0 \"register_operand\" \"=r,*f\")\n+\t(sign_extend:DI (match_operand:SI 1 \"register_operand\" \"r,*f\")))]\n   \"\"\n   \"@\n    sxt4 %0 = %1\n@@ -514,8 +511,8 @@\n   [(set_attr \"type\" \"I,M\")])\n \n (define_insn \"zero_extendsidi2\"\n-  [(set (match_operand:DI 0 \"register_operand\" \"=r,r,*e\")\n-\t(zero_extend:DI (match_operand:SI 1 \"nonimmediate_operand\" \"r,m,*e\")))]\n+  [(set (match_operand:DI 0 \"register_operand\" \"=r,r,*f\")\n+\t(zero_extend:DI (match_operand:SI 1 \"nonimmediate_operand\" \"r,m,*f\")))]\n   \"\"\n   \"@\n    zxt4 %0 = %1\n@@ -565,20 +562,20 @@\n \n (define_insn \"floatdixf2\"\n   [(set (match_operand:XF 0 \"register_operand\" \"=f\")\n-\t(float:XF (match_operand:DI 1 \"register_operand\" \"e\")))]\n+\t(float:XF (match_operand:DI 1 \"register_operand\" \"f\")))]\n   \"\"\n   \"fcvt.xf %0 = %1\"\n   [(set_attr \"type\" \"F\")])\n \n (define_insn \"fix_truncsfdi2\"\n-  [(set (match_operand:DI 0 \"register_operand\" \"=e\")\n+  [(set (match_operand:DI 0 \"register_operand\" \"=f\")\n \t(fix:DI (match_operand:SF 1 \"register_operand\" \"f\")))]\n   \"\"\n   \"fcvt.fx.trunc %0 = %1%B0\"\n   [(set_attr \"type\" \"F\")])\n \n (define_insn \"fix_truncdfdi2\"\n-  [(set (match_operand:DI 0 \"register_operand\" \"=e\")\n+  [(set (match_operand:DI 0 \"register_operand\" \"=f\")\n \t(fix:DI (match_operand:DF 1 \"register_operand\" \"f\")))]\n   \"\"\n   \"fcvt.fx.trunc %0 = %1%B0\"\n@@ -588,27 +585,27 @@\n \n (define_insn \"floatunsdisf2\"\n   [(set (match_operand:SF 0 \"register_operand\" \"=f\")\n-\t(unsigned_float:SF (match_operand:DI 1 \"register_operand\" \"e\")))]\n+\t(unsigned_float:SF (match_operand:DI 1 \"register_operand\" \"f\")))]\n   \"\"\n   \"fcvt.xuf.s %0 = %1%B0\"\n   [(set_attr \"type\" \"F\")])\n \n (define_insn \"floatunsdidf2\"\n   [(set (match_operand:DF 0 \"register_operand\" \"=f\")\n-\t(unsigned_float:DF (match_operand:DI 1 \"register_operand\" \"e\")))]\n+\t(unsigned_float:DF (match_operand:DI 1 \"register_operand\" \"f\")))]\n   \"\"\n   \"fcvt.xuf.d %0 = %1%B0\"\n   [(set_attr \"type\" \"F\")])\n \n (define_insn \"fixuns_truncsfdi2\"\n-  [(set (match_operand:DI 0 \"register_operand\" \"=e\")\n+  [(set (match_operand:DI 0 \"register_operand\" \"=f\")\n \t(unsigned_fix:DI (match_operand:SF 1 \"register_operand\" \"f\")))]\n   \"\"\n   \"fcvt.fxu.trunc %0 = %1%B0\"\n   [(set_attr \"type\" \"F\")])\n \n (define_insn \"fixuns_truncdfdi2\"\n-  [(set (match_operand:DI 0 \"register_operand\" \"=e\")\n+  [(set (match_operand:DI 0 \"register_operand\" \"=f\")\n \t(unsigned_fix:DI (match_operand:DF 1 \"register_operand\" \"f\")))]\n   \"\"\n   \"fcvt.fxu.trunc %0 = %1%B0\"\n@@ -920,9 +917,9 @@\n ;; ??? Could add maddsi3 patterns patterned after the madddi3 patterns.\n \n (define_insn \"*mulsi3_internal\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=e\")\n-\t(mult:SI (match_operand:SI 1 \"register_operand\" \"e\")\n-\t\t (match_operand:SI 2 \"nonmemory_operand\" \"e\")))]\n+  [(set (match_operand:SI 0 \"register_operand\" \"=f\")\n+\t(mult:SI (match_operand:SI 1 \"register_operand\" \"f\")\n+\t\t (match_operand:SI 2 \"nonmemory_operand\" \"f\")))]\n   \"\"\n   \"xma.l %0 = %1, %2, f0%B0\"\n   [(set_attr \"type\" \"F\")])\n@@ -1065,9 +1062,9 @@\n   [(set_attr \"type\" \"A\")])\n \n (define_insn \"muldi3\"\n-  [(set (match_operand:DI 0 \"register_operand\" \"=e\")\n-\t(mult:DI (match_operand:DI 1 \"register_operand\" \"e\")\n-\t\t (match_operand:DI 2 \"register_operand\" \"e\")))]\n+  [(set (match_operand:DI 0 \"register_operand\" \"=f\")\n+\t(mult:DI (match_operand:DI 1 \"register_operand\" \"f\")\n+\t\t (match_operand:DI 2 \"register_operand\" \"f\")))]\n   \"\"\n   \"xma.l %0 = %1, %2, f0%B0\"\n   [(set_attr \"type\" \"F\")])\n@@ -1084,10 +1081,10 @@\n ;; ??? Maybe we should change how adds are canonicalized.\n \n (define_insn \"*madddi3\"\n-  [(set (match_operand:DI 0 \"register_operand\" \"=e\")\n-\t(plus:DI (mult:DI (match_operand:DI 1 \"register_operand\" \"e\")\n-\t\t\t  (match_operand:DI 2 \"register_operand\" \"e\"))\n-\t\t (match_operand:DI 3 \"register_operand\" \"e\")))\n+  [(set (match_operand:DI 0 \"register_operand\" \"=f\")\n+\t(plus:DI (mult:DI (match_operand:DI 1 \"register_operand\" \"f\")\n+\t\t\t  (match_operand:DI 2 \"register_operand\" \"f\"))\n+\t\t (match_operand:DI 3 \"register_operand\" \"f\")))\n    (clobber (match_scratch:DI 4 \"=X\"))]\n   \"\"\n   \"xma.l %0 = %1, %2, %3%B0\"\n@@ -1103,11 +1100,11 @@\n \n (define_insn \"*madddi3_elim\"\n   [(set (match_operand:DI 0 \"register_operand\" \"=&r\")\n-\t(plus:DI (plus:DI (mult:DI (match_operand:DI 1 \"register_operand\" \"e\")\n-\t\t\t\t   (match_operand:DI 2 \"register_operand\" \"e\"))\n-\t\t\t  (match_operand:DI 3 \"register_operand\" \"e\"))\n+\t(plus:DI (plus:DI (mult:DI (match_operand:DI 1 \"register_operand\" \"f\")\n+\t\t\t\t   (match_operand:DI 2 \"register_operand\" \"f\"))\n+\t\t\t  (match_operand:DI 3 \"register_operand\" \"f\"))\n \t\t (match_operand:DI 4 \"nonmemory_operand\" \"rI\")))\n-   (clobber (match_scratch:DI 5 \"=e\"))]\n+   (clobber (match_scratch:DI 5 \"=f\"))]\n   \"reload_in_progress\"\n   \"#\"\n   [(set_attr \"type\" \"unknown\")])\n@@ -1136,22 +1133,22 @@\n ;; to generate them.\n \n (define_insn \"smuldi3_highpart\"\n-  [(set (match_operand:DI 0 \"register_operand\" \"=e\")\n+  [(set (match_operand:DI 0 \"register_operand\" \"=f\")\n \t(truncate:DI\n \t (lshiftrt:TI\n-\t  (mult:TI (sign_extend:TI (match_operand:DI 1 \"register_operand\" \"e\"))\n-\t\t   (sign_extend:TI (match_operand:DI 2 \"register_operand\" \"e\")))\n+\t  (mult:TI (sign_extend:TI (match_operand:DI 1 \"register_operand\" \"f\"))\n+\t\t   (sign_extend:TI (match_operand:DI 2 \"register_operand\" \"f\")))\n \t  (const_int 64))))]\n   \"\"\n   \"xma.h %0 = %1, %2, f0%B0\"\n   [(set_attr \"type\" \"F\")])\n \n (define_insn \"umuldi3_highpart\"\n-  [(set (match_operand:DI 0 \"register_operand\" \"=e\")\n+  [(set (match_operand:DI 0 \"register_operand\" \"=f\")\n \t(truncate:DI\n \t (lshiftrt:TI\n-\t  (mult:TI (zero_extend:TI (match_operand:DI 1 \"register_operand\" \"e\"))\n-\t\t   (zero_extend:TI (match_operand:DI 2 \"register_operand\" \"e\")))\n+\t  (mult:TI (zero_extend:TI (match_operand:DI 1 \"register_operand\" \"f\"))\n+\t\t   (zero_extend:TI (match_operand:DI 2 \"register_operand\" \"f\")))\n \t  (const_int 64))))]\n   \"\"\n   \"xma.hu %0 = %1, %2, f0%B0\"\n@@ -1735,39 +1732,39 @@\n ;; ::::::::::::::::::::\n \n (define_insn \"anddi3\"\n-  [(set (match_operand:DI 0 \"register_operand\" \"=r,*e\")\n-\t(and:DI (match_operand:DI 1 \"register_operand\" \"%r,*e\")\n-\t\t(match_operand:DI 2 \"reg_or_8bit_operand\" \"rK,*e\")))]\n+  [(set (match_operand:DI 0 \"register_operand\" \"=r,*f\")\n+\t(and:DI (match_operand:DI 1 \"register_operand\" \"%r,*f\")\n+\t\t(match_operand:DI 2 \"reg_or_8bit_operand\" \"rK,*f\")))]\n   \"\"\n   \"@\n    and %0 = %2, %1\n    fand %0 = %2, %1%B0\"\n   [(set_attr \"type\" \"A,F\")])\n \n (define_insn \"*andnot\"\n-  [(set (match_operand:DI 0 \"register_operand\" \"=r,*e\")\n-\t(and:DI (not:DI (match_operand:DI 1 \"register_operand\" \"r,*e\"))\n-\t\t(match_operand:DI 2 \"reg_or_8bit_operand\" \"rK,*e\")))]\n+  [(set (match_operand:DI 0 \"register_operand\" \"=r,*f\")\n+\t(and:DI (not:DI (match_operand:DI 1 \"register_operand\" \"r,*f\"))\n+\t\t(match_operand:DI 2 \"reg_or_8bit_operand\" \"rK,*f\")))]\n   \"\"\n   \"@\n    andcm %0 = %2, %1\n    fandcm %0 = %2, %1%B0\"\n   [(set_attr \"type\" \"A,F\")])\n \n (define_insn \"iordi3\"\n-  [(set (match_operand:DI 0 \"register_operand\" \"=r,*e\")\n-\t(ior:DI (match_operand:DI 1 \"register_operand\" \"%r,*e\")\n-\t\t(match_operand:DI 2 \"reg_or_8bit_operand\" \"rK,*e\")))]\n+  [(set (match_operand:DI 0 \"register_operand\" \"=r,*f\")\n+\t(ior:DI (match_operand:DI 1 \"register_operand\" \"%r,*f\")\n+\t\t(match_operand:DI 2 \"reg_or_8bit_operand\" \"rK,*f\")))]\n   \"\"\n   \"@\n    or %0 = %2, %1\n    for %0 = %2, %1%B0\"\n   [(set_attr \"type\" \"A,F\")])\n \n (define_insn \"xordi3\"\n-  [(set (match_operand:DI 0 \"register_operand\" \"=r,*e\")\n-\t(xor:DI (match_operand:DI 1 \"register_operand\" \"%r,*e\")\n-\t\t(match_operand:DI 2 \"reg_or_8bit_operand\" \"rK,*e\")))]\n+  [(set (match_operand:DI 0 \"register_operand\" \"=r,*f\")\n+\t(xor:DI (match_operand:DI 1 \"register_operand\" \"%r,*f\")\n+\t\t(match_operand:DI 2 \"reg_or_8bit_operand\" \"rK,*f\")))]\n   \"\"\n   \"@\n    xor %0 = %2, %1\n@@ -3000,7 +2997,7 @@\n \t\t      (return)\n \t\t      (pc)))]\n   \"ia64_direct_return ()\"\n-  \"(%%J0) br.ret%+.many rp\"\n+  \"(%J0) br.ret%+.many rp\"\n   [(set_attr \"type\" \"B\")\n    (set_attr \"predicable\" \"no\")])\n \n@@ -3012,7 +3009,7 @@\n \t\t      (pc)\n \t\t      (return)))]\n   \"ia64_direct_return ()\"\n-  \"(%%j0) br.ret%+.many rp\"\n+  \"(%j0) br.ret%+.many rp\"\n   [(set_attr \"type\" \"B\")\n    (set_attr \"predicable\" \"no\")])\n \n@@ -3132,13 +3129,13 @@\n \n (define_insn \"fr_spill\"\n   [(set (match_operand:XF 0 \"memory_operand\" \"=m\")\n-\t(unspec:XF [(match_operand:XF 1 \"register_operand\" \"f*e\")] 3))]\n+\t(unspec:XF [(match_operand:XF 1 \"register_operand\" \"f\")] 3))]\n   \"\"\n   \"stf.spill %0 = %1%P0\"\n   [(set_attr \"type\" \"M\")])\n \n (define_insn \"fr_restore\"\n-  [(set (match_operand:XF 0 \"register_operand\" \"=f*e\")\n+  [(set (match_operand:XF 0 \"register_operand\" \"=f\")\n \t(unspec:XF [(match_operand:XF 1 \"memory_operand\" \"m\")] 4))]\n   \"\"\n   \"ldf.fill %0 = %1%P1\"\n@@ -3196,28 +3193,14 @@\n   [(unspec_volatile [(const_int 0)] 5)\n    (use (match_operand:DI 0 \"register_operand\" \"r\"))]\n   \"\"\n-  \"flushrs\\;\t\t\t\\\n-   mov r19=ar.rsc\\;\t\t\\\n-   ;;\\;\t\t\t\t\\\n-   and r19=0x1c,r19\\;\t\t\\\n-   ;;\\;\t\t\t\t\\\n-   mov ar.rsc=r19\\;\t\t\\\n-   ;;\\;\t\t\t\t\\\n-   mov ar.bspstore=%0\\;\t\t\\\n-   ;;\\;\t\t\t\t\\\n-   or r19=0x3,r19\\;\t\t\\\n-   ;;\\;\t\t\t\t\\\n-   loadrs\\;\t\t\t\\\n-   invala\\;\t\t\t\\\n-   ;;\\;\t\t\t\t\\\n-   mov ar.rsc=r19\\;\"\n+  \"flushrs\\;mov r19=ar.rsc\\;;;\\;and r19=0x1c,r19\\;;;\\;mov ar.rsc=r19\\;;;\\;mov ar.bspstore=%0\\;;;\\;or r19=0x3,r19\\;;;\\;loadrs\\;invala\\;;;\\;mov ar.rsc=r19\"\n   [(set_attr \"type\" \"unknown\")\n    (set_attr \"predicable\" \"no\")])\n \n (define_insn \"flushrs\"\n   [(unspec [(const_int 0)] 21)]\n   \"\"\n-  \";; \\; flushrs\"\n+  \";;\\;flushrs\"\n   [(set_attr \"type\" \"M\")])\n \f\n ;; ::::::::::::::::::::"}]}