{"sha": "2197a88a8c524354d687e395a355ee45938ac727", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MjE5N2E4OGE4YzUyNDM1NGQ2ODdlMzk1YTM1NWVlNDU5MzhhYzcyNw==", "commit": {"author": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1994-01-25T13:29:50Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1994-01-25T13:29:50Z"}, "message": "(HASHBITS): Removed.\n\n(HASH, struct set, canon_hash, safe_hash, remove_from_table):\nGenerate and use unsigned hash values, to avoid potential trouble\nwith signed shift/overflow.\nAlso name variables consistently: \"hash\", not \"hash_code\".\n(lookup, lookup_for_remove, insert, merge_equiv_classes): Likewise.\n(invalidate, rehash_using_reg, invalidate_for_call): Likewise.\n(find_best_addr, record_jump_cond, cse_insn):  Likewise.\n\nFrom-SVN: r6431", "tree": {"sha": "fc5e70df3460574ef38f8fd61c1896debe9cb19d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/fc5e70df3460574ef38f8fd61c1896debe9cb19d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2197a88a8c524354d687e395a355ee45938ac727", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2197a88a8c524354d687e395a355ee45938ac727", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2197a88a8c524354d687e395a355ee45938ac727", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2197a88a8c524354d687e395a355ee45938ac727/comments", "author": null, "committer": null, "parents": [{"sha": "bc8a0e39b7504b4aa23203353bb77136d487c101", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bc8a0e39b7504b4aa23203353bb77136d487c101", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bc8a0e39b7504b4aa23203353bb77136d487c101"}], "stats": {"total": 190, "additions": 92, "deletions": 98}, "files": [{"sha": "13de40cb34070befe418e5ae5741c7c7157042f7", "filename": "gcc/cse.c", "status": "modified", "additions": 92, "deletions": 98, "changes": 190, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2197a88a8c524354d687e395a355ee45938ac727/gcc%2Fcse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2197a88a8c524354d687e395a355ee45938ac727/gcc%2Fcse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcse.c?ref=2197a88a8c524354d687e395a355ee45938ac727", "patch": "@@ -418,8 +418,6 @@ struct table_elt\n   char flag;\n };\n \n-#define HASHBITS 16\n-\n /* We don't want a lot of buckets, because we rarely have very many\n    things stored in the hash table, and a lot of buckets slows\n    down a lot of loops that happen frequently.  */\n@@ -430,7 +428,7 @@ struct table_elt\n \n #define HASH(X, M)\t\\\n  (GET_CODE (X) == REG && REGNO (X) >= FIRST_PSEUDO_REGISTER\t\\\n-  ? ((((int) REG << 7) + reg_qty[REGNO (X)]) % NBUCKETS)\t\\\n+  ? (((unsigned) REG << 7) + (unsigned) reg_qty[REGNO (X)]) % NBUCKETS\t\\\n   : canon_hash (X, M) % NBUCKETS)\n \n /* Determine whether register number N is considered a fixed register for CSE.\n@@ -598,12 +596,12 @@ static void delete_reg_equiv\tPROTO((int));\n static int mention_regs\t\tPROTO((rtx));\n static int insert_regs\t\tPROTO((rtx, struct table_elt *, int));\n static void free_element\tPROTO((struct table_elt *));\n-static void remove_from_table\tPROTO((struct table_elt *, int));\n+static void remove_from_table\tPROTO((struct table_elt *, unsigned));\n static struct table_elt *get_element PROTO((void));\n-static struct table_elt *lookup\tPROTO((rtx, int, enum machine_mode)),\n-       *lookup_for_remove PROTO((rtx, int, enum machine_mode));\n+static struct table_elt *lookup\tPROTO((rtx, unsigned, enum machine_mode)),\n+       *lookup_for_remove PROTO((rtx, unsigned, enum machine_mode));\n static rtx lookup_as_function\tPROTO((rtx, enum rtx_code));\n-static struct table_elt *insert PROTO((rtx, struct table_elt *, int,\n+static struct table_elt *insert PROTO((rtx, struct table_elt *, unsigned,\n \t\t\t\t       enum machine_mode));\n static void merge_equiv_classes PROTO((struct table_elt *,\n \t\t\t\t       struct table_elt *));\n@@ -613,8 +611,8 @@ static void rehash_using_reg\tPROTO((rtx));\n static void invalidate_memory\tPROTO((struct write_data *));\n static void invalidate_for_call\tPROTO((void));\n static rtx use_related_value\tPROTO((rtx, struct table_elt *));\n-static int canon_hash\t\tPROTO((rtx, enum machine_mode));\n-static int safe_hash\t\tPROTO((rtx, enum machine_mode));\n+static unsigned canon_hash\tPROTO((rtx, enum machine_mode));\n+static unsigned safe_hash\tPROTO((rtx, enum machine_mode));\n static int exp_equiv_p\t\tPROTO((rtx, rtx, int, int));\n static void set_nonvarying_address_components PROTO((rtx, int, rtx *,\n \t\t\t\t\t\t     HOST_WIDE_INT *,\n@@ -1075,7 +1073,7 @@ get_element ()\n static void\n remove_from_table (elt, hash)\n      register struct table_elt *elt;\n-     int hash;\n+     unsigned hash;\n {\n   if (elt == 0)\n     return;\n@@ -1155,7 +1153,7 @@ remove_from_table (elt, hash)\n static struct table_elt *\n lookup (x, hash, mode)\n      rtx x;\n-     int hash;\n+     unsigned hash;\n      enum machine_mode mode;\n {\n   register struct table_elt *p;\n@@ -1174,7 +1172,7 @@ lookup (x, hash, mode)\n static struct table_elt *\n lookup_for_remove (x, hash, mode)\n      rtx x;\n-     int hash;\n+     unsigned hash;\n      enum machine_mode mode;\n {\n   register struct table_elt *p;\n@@ -1253,7 +1251,7 @@ static struct table_elt *\n insert (x, classp, hash, mode)\n      register rtx x;\n      register struct table_elt *classp;\n-     int hash;\n+     unsigned hash;\n      enum machine_mode mode;\n {\n   register struct table_elt *elt;\n@@ -1381,7 +1379,7 @@ insert (x, classp, hash, mode)\n   if (GET_CODE (x) == CONST)\n     {\n       rtx subexp = get_related_value (x);\n-      int subhash;\n+      unsigned subhash;\n       struct table_elt *subelt, *subelt_prev;\n \n       if (subexp != 0)\n@@ -1433,7 +1431,7 @@ merge_equiv_classes (class1, class2)\n \n   for (elt = class2; elt; elt = next)\n     {\n-      int hash;\n+      unsigned hash;\n       rtx exp = elt->exp;\n       enum machine_mode mode = elt->mode;\n \n@@ -1491,7 +1489,7 @@ invalidate (x)\n   if (GET_CODE (x) == REG)\n     {\n       register int regno = REGNO (x);\n-      register int hash = HASH (x, GET_MODE (x));\n+      register unsigned hash = HASH (x, GET_MODE (x));\n \n       /* Remove REGNO from any quantity list it might be on and indicate\n \t that it's value might have changed.  If it is a pseudo, remove its\n@@ -1609,7 +1607,7 @@ rehash_using_reg (x)\n {\n   int i;\n   struct table_elt *p, *next;\n-  int hash;\n+  unsigned hash;\n \n   if (GET_CODE (x) == SUBREG)\n     x = SUBREG_REG (x);\n@@ -1683,7 +1681,7 @@ invalidate_for_call ()\n {\n   int regno, endregno;\n   int i;\n-  int hash;\n+  unsigned hash;\n   struct table_elt *p, *next;\n   int in_table = 0;\n \n@@ -1818,13 +1816,13 @@ use_related_value (x, elt)\n    Note that cse_insn knows that the hash code of a MEM expression\n    is just (int) MEM plus the hash code of the address.  */\n \n-static int\n+static unsigned\n canon_hash (x, mode)\n      rtx x;\n      enum machine_mode mode;\n {\n   register int i, j;\n-  register int hash = 0;\n+  register unsigned hash = 0;\n   register enum rtx_code code;\n   register char *fmt;\n \n@@ -1859,37 +1857,37 @@ canon_hash (x, mode)\n \t    do_not_record = 1;\n \t    return 0;\n \t  }\n-\treturn hash + ((int) REG << 7) + reg_qty[regno];\n+\thash += ((unsigned) REG << 7) + (unsigned) reg_qty[regno];\n+\treturn hash;\n       }\n \n     case CONST_INT:\n-      hash += ((int) mode + ((int) CONST_INT << 7)\n-\t       + INTVAL (x) + (INTVAL (x) >> HASHBITS));\n-      return ((1 << HASHBITS) - 1) & hash;\n+      {\n+\tunsigned HOST_WIDE_INT tem = INTVAL (x);\n+\thash += ((unsigned) CONST_INT << 7) + (unsigned) mode + tem;\n+\treturn hash;\n+      }\n \n     case CONST_DOUBLE:\n       /* This is like the general case, except that it only counts\n \t the integers representing the constant.  */\n-      hash += (int) code + (int) GET_MODE (x);\n-      {\n-\tint i;\n-\tfor (i = 2; i < GET_RTX_LENGTH (CONST_DOUBLE); i++)\n-\t  {\n-\t    int tem = XINT (x, i);\n-\t    hash += ((1 << HASHBITS) - 1) & (tem + (tem >> HASHBITS));\n-\t  }\n-      }\n+      hash += (unsigned) code + (unsigned) GET_MODE (x);\n+      for (i = 2; i < GET_RTX_LENGTH (CONST_DOUBLE); i++)\n+\t{\n+\t  unsigned tem = XINT (x, i);\n+\t  hash += tem;\n+\t}\n       return hash;\n \n       /* Assume there is only one rtx object for any given label.  */\n     case LABEL_REF:\n       /* Use `and' to ensure a positive number.  */\n-      return (hash + ((HOST_WIDE_INT) LABEL_REF << 7)\n-\t      + ((HOST_WIDE_INT) XEXP (x, 0) & ((1 << HASHBITS) - 1)));\n+      hash += ((unsigned) LABEL_REF << 7) + (unsigned) XEXP (x, 0);\n+      return hash;\n \n     case SYMBOL_REF:\n-      return (hash + ((HOST_WIDE_INT) SYMBOL_REF << 7)\n-\t      + ((HOST_WIDE_INT) XEXP (x, 0) & ((1 << HASHBITS) - 1)));\n+      hash += ((unsigned) SYMBOL_REF << 7) + (unsigned) XEXP (x, 0);\n+      return hash;\n \n     case MEM:\n       if (MEM_VOLATILE_P (x))\n@@ -1904,7 +1902,7 @@ canon_hash (x, mode)\n \t}\n       /* Now that we have already found this special case,\n \t might as well speed it up as much as possible.  */\n-      hash += (int) MEM;\n+      hash += (unsigned) MEM;\n       x = XEXP (x, 0);\n       goto repeat;\n \n@@ -1928,7 +1926,7 @@ canon_hash (x, mode)\n     }\n \n   i = GET_RTX_LENGTH (code) - 1;\n-  hash += (int) code + (int) GET_MODE (x);\n+  hash += (unsigned) code + (unsigned) GET_MODE (x);\n   fmt = GET_RTX_FORMAT (code);\n   for (; i >= 0; i--)\n     {\n@@ -1962,18 +1960,15 @@ canon_hash (x, mode)\n \t  hash += canon_hash (XVECEXP (x, i, j), 0);\n       else if (fmt[i] == 's')\n \t{\n-\t  register char *p = XSTR (x, i);\n+\t  register unsigned char *p = (unsigned char *) XSTR (x, i);\n \t  if (p)\n \t    while (*p)\n-\t      {\n-\t\tregister int tem = *p++;\n-\t\thash += ((1 << HASHBITS) - 1) & (tem + (tem >> HASHBITS));\n-\t      }\n+\t      hash += *p++;\n \t}\n       else if (fmt[i] == 'i')\n \t{\n-\t  register int tem = XINT (x, i);\n-\t  hash += ((1 << HASHBITS) - 1) & (tem + (tem >> HASHBITS));\n+\t  register unsigned tem = XINT (x, i);\n+\t  hash += tem;\n \t}\n       else\n \tabort ();\n@@ -1983,15 +1978,15 @@ canon_hash (x, mode)\n \n /* Like canon_hash but with no side effects.  */\n \n-static int\n+static unsigned\n safe_hash (x, mode)\n      rtx x;\n      enum machine_mode mode;\n {\n   int save_do_not_record = do_not_record;\n   int save_hash_arg_in_memory = hash_arg_in_memory;\n   int save_hash_arg_in_struct = hash_arg_in_struct;\n-  int hash = canon_hash (x, mode);\n+  unsigned hash = canon_hash (x, mode);\n   hash_arg_in_memory = save_hash_arg_in_memory;\n   hash_arg_in_struct = save_hash_arg_in_struct;\n   do_not_record = save_do_not_record;\n@@ -2505,9 +2500,9 @@ find_best_addr (insn, loc)\n   int save_do_not_record = do_not_record;\n   int save_hash_arg_in_memory = hash_arg_in_memory;\n   int save_hash_arg_in_struct = hash_arg_in_struct;\n-  int hash_code;\n   int addr_volatile;\n   int regno;\n+  unsigned hash;\n \n   /* Do not try to replace constant addresses or addresses of local and\n      argument slots.  These MEM expressions are made only once and inserted\n@@ -2543,7 +2538,7 @@ find_best_addr (insn, loc)\n      of the whole address.  Also, ignore if volatile.  */\n \n   do_not_record = 0;\n-  hash_code = HASH (addr, Pmode);\n+  hash = HASH (addr, Pmode);\n   addr_volatile = do_not_record;\n   do_not_record = save_do_not_record;\n   hash_arg_in_memory = save_hash_arg_in_memory;\n@@ -2552,7 +2547,7 @@ find_best_addr (insn, loc)\n   if (addr_volatile)\n     return;\n \n-  elt = lookup (addr, hash_code, Pmode);\n+  elt = lookup (addr, hash, Pmode);\n \n #ifndef ADDRESS_COST\n   if (elt)\n@@ -2631,12 +2626,12 @@ find_best_addr (insn, loc)\n       rtx c = XEXP (*loc, 1);\n \n       do_not_record = 0;\n-      hash_code = HASH (XEXP (*loc, 0), Pmode);\n+      hash = HASH (XEXP (*loc, 0), Pmode);\n       do_not_record = save_do_not_record;\n       hash_arg_in_memory = save_hash_arg_in_memory;\n       hash_arg_in_struct = save_hash_arg_in_struct;\n \n-      elt = lookup (XEXP (*loc, 0), hash_code, Pmode);\n+      elt = lookup (XEXP (*loc, 0), hash, Pmode);\n       if (elt == 0)\n \treturn;\n \n@@ -5613,7 +5608,7 @@ record_jump_cond (code, mode, op0, op1, reversed_nonequality)\n      rtx op0, op1;\n      int reversed_nonequality;\n {\n-  int op0_hash_code, op1_hash_code;\n+  unsigned op0_hash, op1_hash;\n   int op0_in_memory, op0_in_struct, op1_in_memory, op1_in_struct;\n   struct table_elt *op0_elt, *op1_elt;\n \n@@ -5685,7 +5680,7 @@ record_jump_cond (code, mode, op0, op1, reversed_nonequality)\n   do_not_record = 0;\n   hash_arg_in_memory = 0;\n   hash_arg_in_struct = 0;\n-  op0_hash_code = HASH (op0, mode);\n+  op0_hash = HASH (op0, mode);\n   op0_in_memory = hash_arg_in_memory;\n   op0_in_struct = hash_arg_in_struct;\n \n@@ -5695,16 +5690,16 @@ record_jump_cond (code, mode, op0, op1, reversed_nonequality)\n   do_not_record = 0;\n   hash_arg_in_memory = 0;\n   hash_arg_in_struct = 0;\n-  op1_hash_code = HASH (op1, mode);\n+  op1_hash = HASH (op1, mode);\n   op1_in_memory = hash_arg_in_memory;\n   op1_in_struct = hash_arg_in_struct;\n   \n   if (do_not_record)\n     return;\n \n   /* Look up both operands.  */\n-  op0_elt = lookup (op0, op0_hash_code, mode);\n-  op1_elt = lookup (op1, op1_hash_code, mode);\n+  op0_elt = lookup (op0, op0_hash, mode);\n+  op1_elt = lookup (op1, op1_hash, mode);\n \n   /* If we aren't setting two things equal all we can do is save this\n      comparison.   Similarly if this is floating-point.  In the latter\n@@ -5732,16 +5727,16 @@ record_jump_cond (code, mode, op0, op1, reversed_nonequality)\n \t  if (insert_regs (op0, NULL_PTR, 0))\n \t    {\n \t      rehash_using_reg (op0);\n-\t      op0_hash_code = HASH (op0, mode);\n+\t      op0_hash = HASH (op0, mode);\n \n \t      /* If OP0 is contained in OP1, this changes its hash code\n \t\t as well.  Faster to rehash than to check, except\n \t\t for the simple case of a constant.  */\n \t      if (! CONSTANT_P (op1))\n-\t\top1_hash_code = HASH (op1,mode);\n+\t\top1_hash = HASH (op1,mode);\n \t    }\n \n-\t  op0_elt = insert (op0, NULL_PTR, op0_hash_code, mode);\n+\t  op0_elt = insert (op0, NULL_PTR, op0_hash, mode);\n \t  op0_elt->in_memory = op0_in_memory;\n \t  op0_elt->in_struct = op0_in_struct;\n \t}\n@@ -5750,18 +5745,18 @@ record_jump_cond (code, mode, op0, op1, reversed_nonequality)\n       if (GET_CODE (op1) == REG)\n \t{\n \t  /* Look it up again--in case op0 and op1 are the same.  */\n-\t  op1_elt = lookup (op1, op1_hash_code, mode);\n+\t  op1_elt = lookup (op1, op1_hash, mode);\n \n \t  /* Put OP1 in the hash table so it gets a new quantity number.  */\n \t  if (op1_elt == 0)\n \t    {\n \t      if (insert_regs (op1, NULL_PTR, 0))\n \t\t{\n \t\t  rehash_using_reg (op1);\n-\t\t  op1_hash_code = HASH (op1, mode);\n+\t\t  op1_hash = HASH (op1, mode);\n \t\t}\n \n-\t      op1_elt = insert (op1, NULL_PTR, op1_hash_code, mode);\n+\t      op1_elt = insert (op1, NULL_PTR, op1_hash, mode);\n \t      op1_elt->in_memory = op1_in_memory;\n \t      op1_elt->in_struct = op1_in_struct;\n \t    }\n@@ -5786,10 +5781,10 @@ record_jump_cond (code, mode, op0, op1, reversed_nonequality)\n       if (insert_regs (op0, NULL_PTR, 0))\n \t{\n \t  rehash_using_reg (op0);\n-\t  op0_hash_code = HASH (op0, mode);\n+\t  op0_hash = HASH (op0, mode);\n \t}\n \n-      op0_elt = insert (op0, NULL_PTR, op0_hash_code, mode);\n+      op0_elt = insert (op0, NULL_PTR, op0_hash, mode);\n       op0_elt->in_memory = op0_in_memory;\n       op0_elt->in_struct = op0_in_struct;\n     }\n@@ -5799,10 +5794,10 @@ record_jump_cond (code, mode, op0, op1, reversed_nonequality)\n       if (insert_regs (op1, NULL_PTR, 0))\n \t{\n \t  rehash_using_reg (op1);\n-\t  op1_hash_code = HASH (op1, mode);\n+\t  op1_hash = HASH (op1, mode);\n \t}\n \n-      op1_elt = insert (op1, NULL_PTR, op1_hash_code, mode);\n+      op1_elt = insert (op1, NULL_PTR, op1_hash, mode);\n       op1_elt->in_memory = op1_in_memory;\n       op1_elt->in_struct = op1_in_struct;\n     }\n@@ -5830,10 +5825,10 @@ struct set\n   rtx src;\n   /* The hash-table element for the SET_SRC of the SET.  */\n   struct table_elt *src_elt;\n-  /* Hash code for the SET_SRC.  */\n-  int src_hash_code;\n-  /* Hash code for the SET_DEST.  */\n-  int dest_hash_code;\n+  /* Hash value for the SET_SRC.  */\n+  unsigned src_hash;\n+  /* Hash value for the SET_DEST.  */\n+  unsigned dest_hash;\n   /* The SET_DEST, with SUBREG, etc., stripped.  */\n   rtx inner_dest;\n   /* Place where the pointer to the INNER_DEST was found.  */\n@@ -5849,8 +5844,8 @@ struct set\n   enum machine_mode mode;\n   /* A constant equivalent for SET_SRC, if any.  */\n   rtx src_const;\n-  /* Hash code of constant equivalent for SET_SRC.  */\n-  int src_const_hash_code;\n+  /* Hash value of constant equivalent for SET_SRC.  */\n+  unsigned src_const_hash;\n   /* Table entry for constant equivalent for SET_SRC, if any.  */\n   struct table_elt *src_const_elt;\n };\n@@ -5876,7 +5871,7 @@ cse_insn (insn, in_libcall_block)\n   int src_eqv_volatile;\n   int src_eqv_in_memory;\n   int src_eqv_in_struct;\n-  int src_eqv_hash_code;\n+  unsigned src_eqv_hash;\n \n   struct set *sets;\n \n@@ -6124,12 +6119,12 @@ cse_insn (insn, in_libcall_block)\n \t  hash_arg_in_memory = 0;\n \t  hash_arg_in_struct = 0;\n \t  src_eqv = fold_rtx (src_eqv, insn);\n-\t  src_eqv_hash_code = HASH (src_eqv, eqvmode);\n+\t  src_eqv_hash = HASH (src_eqv, eqvmode);\n \n \t  /* Find the equivalence class for the equivalent expression.  */\n \n \t  if (!do_not_record)\n-\t    src_eqv_elt = lookup (src_eqv, src_eqv_hash_code, eqvmode);\n+\t    src_eqv_elt = lookup (src_eqv, src_eqv_hash, eqvmode);\n \n \t  src_eqv_volatile = do_not_record;\n \t  src_eqv_in_memory = hash_arg_in_memory;\n@@ -6172,7 +6167,7 @@ cse_insn (insn, in_libcall_block)\n       hash_arg_in_struct = 0;\n \n       sets[i].src = src;\n-      sets[i].src_hash_code = HASH (src, mode);\n+      sets[i].src_hash = HASH (src, mode);\n       sets[i].src_volatile = do_not_record;\n       sets[i].src_in_memory = hash_arg_in_memory;\n       sets[i].src_in_struct = hash_arg_in_struct;\n@@ -6208,7 +6203,7 @@ cse_insn (insn, in_libcall_block)\n          REG_NOTE.  */\n \n       if (!sets[i].src_volatile)\n-\telt = lookup (src, sets[i].src_hash_code, mode);\n+\telt = lookup (src, sets[i].src_hash, mode);\n \n       sets[i].src_elt = elt;\n \n@@ -6219,8 +6214,8 @@ cse_insn (insn, in_libcall_block)\n \t      /* The REG_EQUAL is indicating that two formerly distinct\n \t\t classes are now equivalent.  So merge them.  */\n \t      merge_equiv_classes (elt, src_eqv_elt);\n-\t      src_eqv_hash_code = HASH (src_eqv, elt->mode);\n-\t      src_eqv_elt = lookup (src_eqv, src_eqv_hash_code, elt->mode);\n+\t      src_eqv_hash = HASH (src_eqv, elt->mode);\n+\t      src_eqv_elt = lookup (src_eqv, src_eqv_hash, elt->mode);\n \t    }\n \n           src_eqv_here = 0;\n@@ -6232,7 +6227,7 @@ cse_insn (insn, in_libcall_block)\n       /* Try to find a constant somewhere and record it in `src_const'.\n \t Record its table element, if any, in `src_const_elt'.  Look in\n \t any known equivalences first.  (If the constant is not in the\n-\t table, also set `sets[i].src_const_hash_code').  */\n+\t table, also set `sets[i].src_const_hash').  */\n       if (elt)\n         for (p = elt->first_same_value; p; p = p->next_same_value)\n \t  if (p->is_const)\n@@ -6258,9 +6253,8 @@ cse_insn (insn, in_libcall_block)\n \t hash code and look it up.  */\n       if (src_const && src_const_elt == 0)\n \t{\n-\t  sets[i].src_const_hash_code = HASH (src_const, mode);\n-\t  src_const_elt = lookup (src_const, sets[i].src_const_hash_code,\n-\t\t\t\t  mode);\n+\t  sets[i].src_const_hash = HASH (src_const, mode);\n+\t  src_const_elt = lookup (src_const, sets[i].src_const_hash, mode);\n \t}\n \n       sets[i].src_const = src_const;\n@@ -6607,11 +6601,11 @@ cse_insn (insn, in_libcall_block)\n           hash_arg_in_memory = 0;\n           hash_arg_in_struct = 0;\n \t  sets[i].src = src;\n-          sets[i].src_hash_code = HASH (src, mode);\n+          sets[i].src_hash = HASH (src, mode);\n           sets[i].src_volatile = do_not_record;\n           sets[i].src_in_memory = hash_arg_in_memory;\n           sets[i].src_in_struct = hash_arg_in_struct;\n-          sets[i].src_elt = lookup (src, sets[i].src_hash_code, mode);\n+          sets[i].src_elt = lookup (src, sets[i].src_hash, mode);\n         }\n \n       /* If this is a single SET, we are setting a register, and we have an\n@@ -6694,7 +6688,7 @@ cse_insn (insn, in_libcall_block)\n \t before the effects of this instruction are recorded,\n \t since the register values used in the address computation\n \t are those before this instruction.  */\n-      sets[i].dest_hash_code = HASH (dest, mode);\n+      sets[i].dest_hash = HASH (dest, mode);\n \n       /* Don't enter a bit-field in the hash table\n \t because the value in it after the store\n@@ -6818,7 +6812,7 @@ cse_insn (insn, in_libcall_block)\n \t}\n \n       if (sets[i].rtl != 0 && dest != SET_DEST (sets[i].rtl))\n-\tsets[i].dest_hash_code = HASH (SET_DEST (sets[i].rtl), mode);\n+\tsets[i].dest_hash = HASH (SET_DEST (sets[i].rtl), mode);\n \n #ifdef HAVE_cc0\n       /* If setting CC0, record what it was set to, or a constant, if it\n@@ -6859,8 +6853,8 @@ cse_insn (insn, in_libcall_block)\n \t  classp = 0;\n \t}\n       if (insert_regs (src_eqv, classp, 0))\n-\tsrc_eqv_hash_code = HASH (src_eqv, eqvmode);\n-      elt = insert (src_eqv, classp, src_eqv_hash_code, eqvmode);\n+\tsrc_eqv_hash = HASH (src_eqv, eqvmode);\n+      elt = insert (src_eqv, classp, src_eqv_hash, eqvmode);\n       elt->in_memory = src_eqv_in_memory;\n       elt->in_struct = src_eqv_in_struct;\n       src_eqv_elt = elt;\n@@ -6886,7 +6880,7 @@ cse_insn (insn, in_libcall_block)\n \t       This is a more interesting equivalence, so we arrange later\n \t       to treat the entire reg as the destination.  */\n \t    sets[i].src_elt = src_eqv_elt;\n-\t    sets[i].src_hash_code = src_eqv_hash_code;\n+\t    sets[i].src_hash = src_eqv_hash;\n \t  }\n \telse\n \t  {\n@@ -6906,8 +6900,8 @@ cse_insn (insn, in_libcall_block)\n \t\t   any of the src_elt's, because they would have failed to\n \t\t   match if not still valid.  */\n \t\tif (insert_regs (src, classp, 0))\n-\t\t  sets[i].src_hash_code = HASH (src, mode);\n-\t\telt = insert (src, classp, sets[i].src_hash_code, mode);\n+\t\t  sets[i].src_hash = HASH (src, mode);\n+\t\telt = insert (src, classp, sets[i].src_hash, mode);\n \t\telt->in_memory = sets[i].src_in_memory;\n \t\telt->in_struct = sets[i].src_in_struct;\n \t\tsets[i].src_elt = classp = elt;\n@@ -6917,7 +6911,7 @@ cse_insn (insn, in_libcall_block)\n \t\t&& src != sets[i].src_const\n \t\t&& ! rtx_equal_p (sets[i].src_const, src))\n \t      sets[i].src_elt = insert (sets[i].src_const, classp,\n-\t\t\t\t\tsets[i].src_const_hash_code, mode);\n+\t\t\t\t\tsets[i].src_const_hash, mode);\n \t  }\n       }\n     else if (sets[i].src_elt == 0)\n@@ -7030,10 +7024,10 @@ cse_insn (insn, in_libcall_block)\n \t  if (insert_regs (dest, sets[i].src_elt, 1))\n \t    /* If `insert_regs' changes something, the hash code must be\n \t       recalculated.  */\n-\t    sets[i].dest_hash_code = HASH (dest, GET_MODE (dest));\n+\t    sets[i].dest_hash = HASH (dest, GET_MODE (dest));\n \n \telt = insert (dest, sets[i].src_elt,\n-\t\t      sets[i].dest_hash_code, GET_MODE (dest));\n+\t\t      sets[i].dest_hash, GET_MODE (dest));\n \telt->in_memory = GET_CODE (sets[i].inner_dest) == MEM;\n \tif (elt->in_memory)\n \t  {\n@@ -7073,7 +7067,7 @@ cse_insn (insn, in_libcall_block)\n \t\t elt = elt->next_same_value)\n \t      {\n \t\trtx new_src = 0;\n-\t\tint src_hash;\n+\t\tunsigned src_hash;\n \t\tstruct table_elt *src_elt;\n \n \t\t/* Ignore invalid entries.  */"}]}