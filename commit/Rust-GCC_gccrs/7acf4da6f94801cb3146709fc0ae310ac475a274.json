{"sha": "7acf4da6f94801cb3146709fc0ae310ac475a274", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6N2FjZjRkYTZmOTQ4MDFjYjMxNDY3MDlmYzBhZTMxMGFjNDc1YTI3NA==", "commit": {"author": {"name": "DJ Delorie", "email": "dj@redhat.com", "date": "2009-06-24T04:16:25Z"}, "committer": {"name": "DJ Delorie", "email": "dj@gcc.gnu.org", "date": "2009-06-24T04:16:25Z"}, "message": "MAINTAINERS: Add myself as mep maintainer.\n\n[toplevel]\n\n\t* MAINTAINERS: Add myself as mep maintainer.\n\n[gcc]\n\n\tAdd MeP port.\n\t* config.gcc: Add mep support.\n\t* recog.c: Resurrect validate_replace_rtx_subexp().\n\t* recog.h: Likewise.\n\t* config/mep/: Add new port:\n\t* config/mep/constraints.md: New file.\n\t* config/mep/default.h: New file.\n\t* config/mep/intrinsics.h: New file.\n\t* config/mep/intrinsics.md: New file.\n\t* config/mep/ivc2-template.h: New file.\n\t* config/mep/mep-c5.cpu: New file.\n\t* config/mep/mep-core.cpu: New file.\n\t* config/mep/mep-default.cpu: New file.\n\t* config/mep/mep-ext-cop.cpu: New file.\n\t* config/mep/mep-intrin.h: New file.\n\t* config/mep/mep-ivc2.cpu: New file.\n\t* config/mep/mep-lib1.asm: New file.\n\t* config/mep/mep-lib2.c: New file.\n\t* config/mep/mep-pragma.c: New file.\n\t* config/mep/mep-protos.h: New file.\n\t* config/mep/mep-tramp.c: New file.\n\t* config/mep/mep.c: New file.\n\t* config/mep/mep.cpu: New file.\n\t* config/mep/mep.h: New file.\n\t* config/mep/mep.md: New file.\n\t* config/mep/mep.opt: New file.\n\t* config/mep/predicates.md: New file.\n\t* config/mep/t-mep: New file.\n\n[gcc/testsuite]\n\n\tAdd MeP port.\n\t* lib/target-supports.exp: Add mep support (no profiling).\n\n[libgcc]\n\n\tAdd MeP port.\n\t* config.host: Add mep support.\n\n[libstdc++-v3]\n\n\tAdd MeP port.\n\t* configure.host: Add mep support.\n\nFrom-SVN: r148890", "tree": {"sha": "43f723d14b2b85261e109309ad7df778f073cc92", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/43f723d14b2b85261e109309ad7df778f073cc92"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/7acf4da6f94801cb3146709fc0ae310ac475a274", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7acf4da6f94801cb3146709fc0ae310ac475a274", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7acf4da6f94801cb3146709fc0ae310ac475a274", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7acf4da6f94801cb3146709fc0ae310ac475a274/comments", "author": null, "committer": null, "parents": [{"sha": "00020c1638f4b23d9889cad741ef40b4997775bf", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/00020c1638f4b23d9889cad741ef40b4997775bf", "html_url": "https://github.com/Rust-GCC/gccrs/commit/00020c1638f4b23d9889cad741ef40b4997775bf"}], "stats": {"total": 64071, "additions": 64071, "deletions": 0}, "files": [{"sha": "f78f518d2f52ac8ef3e90b9a23454e52cb7ae6e3", "filename": "ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7acf4da6f94801cb3146709fc0ae310ac475a274/ChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7acf4da6f94801cb3146709fc0ae310ac475a274/ChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/ChangeLog?ref=7acf4da6f94801cb3146709fc0ae310ac475a274", "patch": "@@ -1,3 +1,7 @@\n+2009-06-23  DJ Delorie  <dj@redhat.com>\n+\n+\t* MAINTAINERS: Add myself as mep maintainer.\n+\n 2009-06-23  Ian Lance Taylor  <iant@google.com>\n \n \t* configure.ac: Add --enable-build-with-cxx.  When set, add c++ to"}, {"sha": "c5cc66b8fea13d0b9724709cc88909fe7f2e18b4", "filename": "MAINTAINERS", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7acf4da6f94801cb3146709fc0ae310ac475a274/MAINTAINERS", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7acf4da6f94801cb3146709fc0ae310ac475a274/MAINTAINERS", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/MAINTAINERS?ref=7acf4da6f94801cb3146709fc0ae310ac475a274", "patch": "@@ -69,6 +69,7 @@ m68k port (?)\t\tJeff Law\t\tlaw@redhat.com\n m68k port\t\tAndreas Schwab\t\tschwab@linux-m68k.org\n m68k-motorola-sysv port\tPhilippe De Muyter\tphdm@macqel.be\n mcore port\t\tNick Clifton\t\tnickc@redhat.com\n+mep port\t\tDJ Delorie\t\tdj@redhat.com\n mips port\t\tEric Christopher\techristo@apple.com\n mips port\t\tRichard Sandiford\trdsandiford@googlemail.com\n mmix port\t\tHans-Peter Nilsson\thp@bitrange.com"}, {"sha": "0d8c09d176343b29f48cc589386b1b6d9da21d81", "filename": "gcc/ChangeLog", "status": "modified", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7acf4da6f94801cb3146709fc0ae310ac475a274/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7acf4da6f94801cb3146709fc0ae310ac475a274/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=7acf4da6f94801cb3146709fc0ae310ac475a274", "patch": "@@ -1,3 +1,34 @@\n+2009-06-23  DJ Delorie  <dj@redhat.com>\n+\n+\tAdd MeP port.\n+\t* config.gcc: Add mep support.\n+\t* recog.c: Resurrect validate_replace_rtx_subexp().\n+\t* recog.h: Likewise.\n+\t* config/mep/: Add new port:\n+\t* config/mep/constraints.md: New file.\n+\t* config/mep/default.h: New file.\n+\t* config/mep/intrinsics.h: New file.\n+\t* config/mep/intrinsics.md: New file.\n+\t* config/mep/ivc2-template.h: New file.\n+\t* config/mep/mep-c5.cpu: New file.\n+\t* config/mep/mep-core.cpu: New file.\n+\t* config/mep/mep-default.cpu: New file.\n+\t* config/mep/mep-ext-cop.cpu: New file.\n+\t* config/mep/mep-intrin.h: New file.\n+\t* config/mep/mep-ivc2.cpu: New file.\n+\t* config/mep/mep-lib1.asm: New file.\n+\t* config/mep/mep-lib2.c: New file.\n+\t* config/mep/mep-pragma.c: New file.\n+\t* config/mep/mep-protos.h: New file.\n+\t* config/mep/mep-tramp.c: New file.\n+\t* config/mep/mep.c: New file.\n+\t* config/mep/mep.cpu: New file.\n+\t* config/mep/mep.h: New file.\n+\t* config/mep/mep.md: New file.\n+\t* config/mep/mep.opt: New file.\n+\t* config/mep/predicates.md: New file.\n+\t* config/mep/t-mep: New file.\n+\n 2009-06-23  Ian Lance Taylor  <iant@google.com>\n \n \t* configure.ac: Invoke AC_PROG_CXX.  Separate C specific warnings"}, {"sha": "e5787374b6e3a2389b01f78dbe500c6fff5b153d", "filename": "gcc/config.gcc", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7acf4da6f94801cb3146709fc0ae310ac475a274/gcc%2Fconfig.gcc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7acf4da6f94801cb3146709fc0ae310ac475a274/gcc%2Fconfig.gcc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig.gcc?ref=7acf4da6f94801cb3146709fc0ae310ac475a274", "patch": "@@ -1562,6 +1562,18 @@ mcore-*-pe*)\n \tinhibit_libc=true\n \tuse_gcc_stdint=wrap\n \t;;\n+mep-*-*)\n+\ttm_file=\"dbxelf.h elfos.h svr4.h ${tm_file}\"\n+\ttmake_file=mep/t-mep\n+\textra_parts=\"crtbegin.o crtend.o\"\n+\tc_target_objs=\"mep-pragma.o\"\n+\tcxx_target_objs=\"mep-pragma.o\"\n+\tif test -d \"${srcdir}/../newlib/libc/include\" &&\n+\t   test \"x$with_headers\" = x; then\n+\t\twith_headers=yes\n+\tfi\n+\tuse_gcc_stdint=wrap\n+\t;;\n mips-sgi-irix[56]*)\n \ttm_file=\"elfos.h ${tm_file} mips/iris.h\"\n \ttmake_file=\"mips/t-iris mips/t-slibgcc-irix\""}, {"sha": "5aa2de69c157ee63e7e520328b61a39fd9124148", "filename": "gcc/config/mep/constraints.md", "status": "added", "additions": 162, "deletions": 0, "changes": 162, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7acf4da6f94801cb3146709fc0ae310ac475a274/gcc%2Fconfig%2Fmep%2Fconstraints.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7acf4da6f94801cb3146709fc0ae310ac475a274/gcc%2Fconfig%2Fmep%2Fconstraints.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmep%2Fconstraints.md?ref=7acf4da6f94801cb3146709fc0ae310ac475a274", "patch": "@@ -0,0 +1,162 @@\n+;; Toshiba Media Processor Machine constraints\n+;; Copyright (C) 2009 Free Software Foundation, Inc.\n+;; Contributed by Red Hat Inc.\n+;;\n+;; This file is part of GCC.\n+;;\n+;; GCC is free software; you can redistribute it and/or modify it\n+;; under the terms of the GNU General Public License as published by\n+;; the Free Software Foundation; either version 3, or (at your option)\n+;; any later version.\n+;;\n+;; GCC is distributed in the hope that it will be useful, but WITHOUT\n+;; ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n+;; or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public\n+;; License for more details.\n+;;\n+;; You should have received a copy of the GNU General Public License\n+;; along with GCC; see the file COPYING3.  If not see\n+;; <http://www.gnu.org/licenses/>.  */\n+\n+\n+\n+(define_register_constraint \"a\" \"SP_REGS\"\n+  \"The $sp register.\")\n+\n+(define_register_constraint \"b\" \"TP_REGS\"\n+  \"The $tp register.\")\n+\n+(define_register_constraint \"c\" \"CONTROL_REGS\"\n+  \"Any control register.\")\n+\n+(define_register_constraint \"d\" \"HILO_REGS\"\n+  \"Either the $hi or the $lo register.\")\n+\n+(define_register_constraint \"em\" \"LOADABLE_CR_REGS\"\n+  \"Coprocessor registers that can be directly loaded ($c0-$c15).\")\n+\n+(define_register_constraint \"ex\" \"mep_have_copro_copro_moves_p ? CR_REGS : NO_REGS\"\n+  \"Coprocessor registers that can be moved to each other.\")\n+\n+(define_register_constraint \"er\" \"mep_have_core_copro_moves_p ? CR_REGS : NO_REGS\"\n+  \"Coprocessor registers that can be moved to core registers.\")\n+\n+(define_register_constraint \"h\" \"HI_REGS\"\n+  \"The $hi register.\")\n+\n+(define_register_constraint \"j\" \"RPC_REGS\"\n+  \"The $rpc register.\")\n+\n+(define_register_constraint \"l\" \"LO_REGS\"\n+  \"The $lo register.\")\n+\n+(define_register_constraint \"t\" \"TPREL_REGS\"\n+  \"Registers which can be used in $tp-relative addressing.\")\n+\n+(define_register_constraint \"v\" \"GP_REGS\"\n+  \"The $gp register.\")\n+\n+(define_register_constraint \"x\" \"CR_REGS\"\n+  \"The coprocessor registers.\")\n+\n+(define_register_constraint \"y\" \"CCR_REGS\"\n+  \"The coprocessor control registers.\")\n+\n+(define_register_constraint \"z\" \"R0_REGS\"\n+  \"The $0 register.\")\n+\n+(define_register_constraint \"A\" \"USER0_REGS\"\n+  \"User-defined register set A.\")\n+\n+(define_register_constraint \"B\" \"USER1_REGS\"\n+  \"User-defined register set B.\")\n+\n+(define_register_constraint \"C\" \"USER2_REGS\"\n+  \"User-defined register set C.\")\n+\n+(define_register_constraint \"D\" \"USER3_REGS\"\n+  \"User-defined register set D.\")\n+\n+\n+\n+(define_constraint \"I\"\n+  \"Offsets for $gp-rel addressing.\"\n+  (and (match_code \"const_int\")\n+       (match_test \"ival >= -32768 && ival < 32768\")))\n+\n+(define_constraint \"J\"\n+  \"Constants that can be used directly with boolean insns.\"\n+  (and (match_code \"const_int\")\n+       (match_test \"ival >= 0 && ival < 65536\")))\n+\n+(define_constraint \"K\"\n+  \"Constants that can be moved directly to registers.\"\n+  (and (match_code \"const_int\")\n+       (match_test \"ival >= 0 && ival < 0x01000000\")))\n+\n+(define_constraint \"L\"\n+  \"Small constants that can be added to registers.\"\n+  (and (match_code \"const_int\")\n+       (match_test \"ival >= -32 && ival < 32\")))\n+\n+(define_constraint \"M\"\n+  \"Long shift counts.\"\n+  (and (match_code \"const_int\")\n+       (match_test \"ival >= 0 && ival < 32\")))\n+\n+(define_constraint \"N\"\n+  \"Small constants that can be compared to registers.\"\n+  (and (match_code \"const_int\")\n+       (match_test \"ival >= 0 && ival < 16\")))\n+\n+(define_constraint \"O\"\n+  \"Constants that can be loaded into the top half of registers.\"\n+  (and (match_code \"const_int\")\n+       (match_test \"!(ival & 0xffff) && ival >= -2147483647-1 && ival <= 2147483647\")))\n+\n+(define_constraint \"S\"\n+  \"Signed 8-bit immediates.\"\n+  (and (match_code \"const_int\")\n+       (match_test \"ival >= -128 && ival < 127\")))\n+\n+\n+\n+;; This must only be used with mep_call_address_operand() as the predicate.\n+(define_constraint \"R\"\n+  \"@internal\n+Near symbols that can be used as addresses for CALL.\"\n+  (not (match_code \"reg\")))\n+\n+(define_constraint \"T\"\n+  \"Symbols encoded for $tp-rel or $gp-rel addressing.\"\n+  (ior (ior\n+\t(and (match_code \"unspec\")\n+\t     (match_code \"symbol_ref\" \"a\"))\n+\t(and (match_code \"const\")\n+\t     (and (match_code \"unspec\" \"0\")\n+\t\t  (match_code \"symbol_ref\" \"0a\"))))\n+       (and (match_code \"const\")\n+\t    (and (match_code \"plus\" \"0\")\n+\t\t (and (match_code \"unspec\" \"00\")\n+\t\t      (match_code \"symbol_ref\" \"00a\"))))))\n+\n+(define_constraint \"U\"\n+  \"Non-constant addresses for loading/saving coprocessor registers.\"\n+  (and (match_code \"mem\")\n+       (match_test \"! CONSTANT_P (XEXP (op, 0))\")))\n+\n+(define_constraint \"W\"\n+  \"The top half of a symbol's value.\"\n+  (and (match_code \"high\")\n+       (match_code \"symbol_ref\" \"0\")))\n+\n+(define_constraint \"Y\"\n+  \"A register indirect address without offset.\"\n+  (and (match_code \"mem\")\n+       (match_code \"reg\" \"0\")))\n+\n+(define_constraint \"Z\"\n+  \"Symbolic references to the control bus.\"\n+  (and (and (match_code \"mem\")\n+\t    (match_code \"symbol_ref\" \"0\"))\n+       (match_test \"mep_section_tag (op) == 'c'\")))"}, {"sha": "f5359721e6c81049114656aa0749d0a9b675ed9c", "filename": "gcc/config/mep/default.h", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7acf4da6f94801cb3146709fc0ae310ac475a274/gcc%2Fconfig%2Fmep%2Fdefault.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7acf4da6f94801cb3146709fc0ae310ac475a274/gcc%2Fconfig%2Fmep%2Fdefault.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmep%2Fdefault.h?ref=7acf4da6f94801cb3146709fc0ae310ac475a274", "patch": "@@ -0,0 +1,10 @@\n+/* Header created by MeP-Integrator */\n+#undef __section\n+#define __section(_secname) __attribute__((section(#_secname)))\n+#undef mep_nop\n+#define mep_nop() __asm__ volatile (\"nop\")\n+\n+#pragma GCC coprocessor available $c0...$c31\n+#pragma GCC coprocessor call_saved $c6...$c7\n+\n+#include <intrinsics.h>"}, {"sha": "e1b30e56a2f5d4bfd7be3480fbf4291244efaccb", "filename": "gcc/config/mep/intrinsics.h", "status": "added", "additions": 626, "deletions": 0, "changes": 626, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7acf4da6f94801cb3146709fc0ae310ac475a274/gcc%2Fconfig%2Fmep%2Fintrinsics.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7acf4da6f94801cb3146709fc0ae310ac475a274/gcc%2Fconfig%2Fmep%2Fintrinsics.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmep%2Fintrinsics.h?ref=7acf4da6f94801cb3146709fc0ae310ac475a274", "patch": "@@ -0,0 +1,626 @@\n+\n+\n+/* DO NOT EDIT: This file is automatically generated by CGEN.\n+   Any changes you make will be discarded when it is next regenerated.\n+*/\n+\n+/* GCC defines these internally, as follows... \n+#if __MEP_CONFIG_CP_DATA_BUS_WIDTH == 64\n+  typedef long long cp_data_bus_int;\n+#else\n+  typedef long cp_data_bus_int;\n+#endif\n+typedef          char  cp_v8qi  __attribute__((vector_size(8)));\n+typedef unsigned char  cp_v8uqi __attribute__((vector_size(8)));\n+typedef          short cp_v4hi  __attribute__((vector_size(8)));\n+typedef unsigned short cp_v4uhi __attribute__((vector_size(8)));\n+typedef          int   cp_v2si  __attribute__((vector_size(8)));\n+typedef unsigned int   cp_v2usi __attribute__((vector_size(8)));\n+*/\n+\n+\n+// default\n+void mep_cpfmadila1_h (cp_v4hi, cp_v4hi, long, long);\n+void mep_cpfmadiua1_h (cp_v4hi, cp_v4hi, long, long);\n+void mep_cpfmadia1_b (cp_v8qi, cp_v8qi, long, long);\n+void mep_cpfmadia1u_b (cp_v8uqi, cp_v8uqi, long, long);\n+void mep_cpfmulila1_h (cp_v4hi, cp_v4hi, long, long);\n+void mep_cpfmuliua1_h (cp_v4hi, cp_v4hi, long, long);\n+void mep_cpfmulia1_b (cp_v8qi, cp_v8qi, long, long);\n+void mep_cpfmulia1u_b (cp_v8uqi, cp_v8uqi, long, long);\n+void mep_cpamadila1_h (cp_v4hi, cp_v4hi, long);\n+void mep_cpamadiua1_h (cp_v4hi, cp_v4hi, long);\n+void mep_cpamadia1_b (cp_v8qi, cp_v8qi, long);\n+void mep_cpamadia1u_b (cp_v8uqi, cp_v8uqi, long);\n+void mep_cpamulila1_h (cp_v4hi, cp_v4hi, long);\n+void mep_cpamuliua1_h (cp_v4hi, cp_v4hi, long);\n+void mep_cpamulia1_b (cp_v8qi, cp_v8qi, long);\n+void mep_cpamulia1u_b (cp_v8uqi, cp_v8uqi, long);\n+void mep_cpfmadila1s1_h (cp_v4hi, cp_v4hi, long);\n+void mep_cpfmadiua1s1_h (cp_v4hi, cp_v4hi, long);\n+void mep_cpfmadia1s1_b (cp_v8qi, cp_v8qi, long);\n+void mep_cpfmadia1s1u_b (cp_v8uqi, cp_v8uqi, long);\n+void mep_cpfmulila1s1_h (cp_v4hi, cp_v4hi, long);\n+void mep_cpfmuliua1s1_h (cp_v4hi, cp_v4hi, long);\n+void mep_cpfmulia1s1_b (cp_v8qi, cp_v8qi, long);\n+void mep_cpfmulia1s1u_b (cp_v8uqi, cp_v8uqi, long);\n+void mep_cpfmadila1s0_h (cp_v4hi, cp_v4hi, long);\n+void mep_cpfmadiua1s0_h (cp_v4hi, cp_v4hi, long);\n+void mep_cpfmadia1s0_b (cp_v8qi, cp_v8qi, long);\n+void mep_cpfmadia1s0u_b (cp_v8uqi, cp_v8uqi, long);\n+void mep_cpfmulila1s0_h (cp_v4hi, cp_v4hi, long);\n+void mep_cpfmuliua1s0_h (cp_v4hi, cp_v4hi, long);\n+void mep_cpfmulia1s0_b (cp_v8qi, cp_v8qi, long);\n+void mep_cpfmulia1s0u_b (cp_v8uqi, cp_v8uqi, long);\n+void mep_cpacswp ();                    // volatile\n+void mep_cpaccpa1 ();\n+void mep_cpacsuma1 ();\n+void mep_c1nop ();                      // volatile\n+void mep_cpfacla0s1_h (cp_v4hi, cp_v4hi);\n+void mep_cpfacua0s1_h (cp_v4hi, cp_v4hi);\n+void mep_cpfaca0s1_b (cp_v8qi, cp_v8qi);\n+void mep_cpfaca0s1u_b (cp_v8uqi, cp_v8uqi);\n+void mep_cpfsftbla0s1_h (cp_v4hi, cp_v4hi);\n+void mep_cpfsftbua0s1_h (cp_v4hi, cp_v4hi);\n+void mep_cpfsftba0s1_b (cp_v8qi, cp_v8qi);\n+void mep_cpfsftba0s1u_b (cp_v8uqi, cp_v8uqi);\n+void mep_cpfacla0s0_h (cp_v4hi, cp_v4hi);\n+void mep_cpfacua0s0_h (cp_v4hi, cp_v4hi);\n+void mep_cpfaca0s0_b (cp_v8qi, cp_v8qi);\n+void mep_cpfaca0s0u_b (cp_v8uqi, cp_v8uqi);\n+void mep_cpfsftbla0s0_h (cp_v4hi, cp_v4hi);\n+void mep_cpfsftbua0s0_h (cp_v4hi, cp_v4hi);\n+void mep_cpfsftba0s0_b (cp_v8qi, cp_v8qi);\n+void mep_cpfsftba0s0u_b (cp_v8uqi, cp_v8uqi);\n+void mep_cpsllia0 (long);\n+void mep_cpsraia0 (long);\n+void mep_cpsrlia0 (long);\n+void mep_cpslla0 (cp_data_bus_int);\n+void mep_cpsraa0 (cp_data_bus_int);\n+void mep_cpsrla0 (cp_data_bus_int);\n+void mep_cpaccpa0 ();\n+void mep_cpacsuma0 ();\n+cp_v2si mep_cpmovhla0_w ();\n+cp_v2si mep_cpmovhua0_w ();\n+cp_v2si mep_cppackla0_w ();\n+cp_v2si mep_cppackua0_w ();\n+cp_v4hi mep_cppackla0_h ();\n+cp_v4hi mep_cppackua0_h ();\n+cp_v8qi mep_cppacka0_b ();\n+cp_v8uqi mep_cppacka0u_b ();\n+cp_v2si mep_cpmovlla0_w ();\n+cp_v2si mep_cpmovlua0_w ();\n+cp_v2si mep_cpmovula0_w ();\n+cp_v2si mep_cpmovuua0_w ();\n+cp_v4hi mep_cpmovla0_h ();\n+cp_v4hi mep_cpmovua0_h ();\n+cp_v8qi mep_cpmova0_b ();\n+void mep_cpsetla0_w (cp_v2si, cp_v2si);\n+void mep_cpsetua0_w (cp_v2si, cp_v2si);\n+void mep_cpseta0_h (cp_v4hi, cp_v4hi);\n+void mep_cpsadla0_h (cp_v4hi, cp_v4hi);\n+void mep_cpsadua0_h (cp_v4hi, cp_v4hi);\n+void mep_cpsada0_b (cp_v8qi, cp_v8qi);\n+void mep_cpsada0u_b (cp_v8uqi, cp_v8uqi);\n+void mep_cpabsla0_h (cp_v4hi, cp_v4hi);\n+void mep_cpabsua0_h (cp_v4hi, cp_v4hi);\n+void mep_cpabsa0_b (cp_v8qi, cp_v8qi);\n+void mep_cpabsa0u_b (cp_v8uqi, cp_v8uqi);\n+void mep_cpsubacla0_h (cp_v4hi, cp_v4hi);\n+void mep_cpsubacua0_h (cp_v4hi, cp_v4hi);\n+void mep_cpsubaca0_b (cp_v8qi, cp_v8qi);\n+void mep_cpsubaca0u_b (cp_v8uqi, cp_v8uqi);\n+void mep_cpsubla0_h (cp_v4hi, cp_v4hi);\n+void mep_cpsubua0_h (cp_v4hi, cp_v4hi);\n+void mep_cpsuba0_b (cp_v8qi, cp_v8qi);\n+void mep_cpsuba0u_b (cp_v8uqi, cp_v8uqi);\n+void mep_cpaddacla0_h (cp_v4hi, cp_v4hi);\n+void mep_cpaddacua0_h (cp_v4hi, cp_v4hi);\n+void mep_cpaddaca0_b (cp_v8qi, cp_v8qi);\n+void mep_cpaddaca0u_b (cp_v8uqi, cp_v8uqi);\n+void mep_cpaddla0_h (cp_v4hi, cp_v4hi);\n+void mep_cpaddua0_h (cp_v4hi, cp_v4hi);\n+void mep_cpadda0_b (cp_v8qi, cp_v8qi);\n+void mep_cpadda0u_b (cp_v8uqi, cp_v8uqi);\n+void mep_c0nop ();                      // volatile\n+void mep_cpsmsbslla1_w (cp_v2si, cp_v2si);\n+void mep_cpsmsbslua1_w (cp_v2si, cp_v2si);\n+void mep_cpsmsbslla1_h (cp_v4hi, cp_v4hi);\n+void mep_cpsmsbslua1_h (cp_v4hi, cp_v4hi);\n+void mep_cpsmadslla1_w (cp_v2si, cp_v2si);\n+void mep_cpsmadslua1_w (cp_v2si, cp_v2si);\n+void mep_cpsmadslla1_h (cp_v4hi, cp_v4hi);\n+void mep_cpsmadslua1_h (cp_v4hi, cp_v4hi);\n+void mep_cpmulslla1_w (cp_v2si, cp_v2si);\n+void mep_cpmulslua1_w (cp_v2si, cp_v2si);\n+void mep_cpmulslla1_h (cp_v4hi, cp_v4hi);\n+void mep_cpmulslua1_h (cp_v4hi, cp_v4hi);\n+void mep_cpsmsbla1_w (cp_v2si, cp_v2si);\n+void mep_cpsmsbua1_w (cp_v2si, cp_v2si);\n+void mep_cpsmsbla1_h (cp_v4hi, cp_v4hi);\n+void mep_cpsmsbua1_h (cp_v4hi, cp_v4hi);\n+void mep_cpsmadla1_w (cp_v2si, cp_v2si);\n+void mep_cpsmadua1_w (cp_v2si, cp_v2si);\n+void mep_cpsmadla1_h (cp_v4hi, cp_v4hi);\n+void mep_cpsmadua1_h (cp_v4hi, cp_v4hi);\n+void mep_cpmsbla1_w (cp_v2si, cp_v2si);\n+void mep_cpmsbua1_w (cp_v2si, cp_v2si);\n+void mep_cpmsbla1u_w (cp_v2usi, cp_v2usi);\n+void mep_cpmsbua1u_w (cp_v2usi, cp_v2usi);\n+void mep_cpmsbla1_h (cp_v4hi, cp_v4hi);\n+void mep_cpmsbua1_h (cp_v4hi, cp_v4hi);\n+void mep_cpmadla1_w (cp_v2si, cp_v2si);\n+void mep_cpmadua1_w (cp_v2si, cp_v2si);\n+void mep_cpmadla1u_w (cp_v2usi, cp_v2usi);\n+void mep_cpmadua1u_w (cp_v2usi, cp_v2usi);\n+void mep_cpmadla1_h (cp_v4hi, cp_v4hi);\n+void mep_cpmadua1_h (cp_v4hi, cp_v4hi);\n+void mep_cpmada1_b (cp_v8qi, cp_v8qi);\n+void mep_cpmada1u_b (cp_v8uqi, cp_v8uqi);\n+void mep_cpmulla1_w (cp_v2si, cp_v2si);\n+void mep_cpmulua1_w (cp_v2si, cp_v2si);\n+void mep_cpmulla1u_w (cp_v2usi, cp_v2usi);\n+void mep_cpmulua1u_w (cp_v2usi, cp_v2usi);\n+void mep_cpmulla1_h (cp_v4hi, cp_v4hi);\n+void mep_cpmulua1_h (cp_v4hi, cp_v4hi);\n+void mep_cpmula1_b (cp_v8qi, cp_v8qi);\n+void mep_cpmula1u_b (cp_v8uqi, cp_v8uqi);\n+void mep_cpssda1_b (cp_v8qi, cp_v8qi);\n+void mep_cpssda1u_b (cp_v8uqi, cp_v8uqi);\n+void mep_cpssqa1_b (cp_v8qi, cp_v8qi);\n+void mep_cpssqa1u_b (cp_v8uqi, cp_v8uqi);\n+void mep_cpsllia1 (long);\n+void mep_cpsraia1 (long);\n+void mep_cpsrlia1 (long);\n+void mep_cpslla1 (cp_data_bus_int);\n+void mep_cpsraa1 (cp_data_bus_int);\n+void mep_cpsrla1 (cp_data_bus_int);\n+cp_v2si mep_cpmovhla1_w ();\n+cp_v2si mep_cpmovhua1_w ();\n+cp_v2si mep_cppackla1_w ();\n+cp_v2si mep_cppackua1_w ();\n+cp_v4hi mep_cppackla1_h ();\n+cp_v4hi mep_cppackua1_h ();\n+cp_v8qi mep_cppacka1_b ();\n+cp_v8uqi mep_cppacka1u_b ();\n+cp_v2si mep_cpmovlla1_w ();\n+cp_v2si mep_cpmovlua1_w ();\n+cp_v2si mep_cpmovula1_w ();\n+cp_v2si mep_cpmovuua1_w ();\n+cp_v4hi mep_cpmovla1_h ();\n+cp_v4hi mep_cpmovua1_h ();\n+cp_v8qi mep_cpmova1_b ();\n+void mep_cpsetla1_w (cp_v2si, cp_v2si);\n+void mep_cpsetua1_w (cp_v2si, cp_v2si);\n+void mep_cpseta1_h (cp_v4hi, cp_v4hi);\n+void mep_cpsadla1_h (cp_v4hi, cp_v4hi);\n+void mep_cpsadua1_h (cp_v4hi, cp_v4hi);\n+void mep_cpsada1_b (cp_v8qi, cp_v8qi);\n+void mep_cpsada1u_b (cp_v8uqi, cp_v8uqi);\n+void mep_cpabsla1_h (cp_v4hi, cp_v4hi);\n+void mep_cpabsua1_h (cp_v4hi, cp_v4hi);\n+void mep_cpabsa1_b (cp_v8qi, cp_v8qi);\n+void mep_cpabsa1u_b (cp_v8uqi, cp_v8uqi);\n+void mep_cpsubacla1_h (cp_v4hi, cp_v4hi);\n+void mep_cpsubacua1_h (cp_v4hi, cp_v4hi);\n+void mep_cpsubaca1_b (cp_v8qi, cp_v8qi);\n+void mep_cpsubaca1u_b (cp_v8uqi, cp_v8uqi);\n+void mep_cpsubla1_h (cp_v4hi, cp_v4hi);\n+void mep_cpsubua1_h (cp_v4hi, cp_v4hi);\n+void mep_cpsuba1_b (cp_v8qi, cp_v8qi);\n+void mep_cpsuba1u_b (cp_v8uqi, cp_v8uqi);\n+void mep_cpaddacla1_h (cp_v4hi, cp_v4hi);\n+void mep_cpaddacua1_h (cp_v4hi, cp_v4hi);\n+void mep_cpaddaca1_b (cp_v8qi, cp_v8qi);\n+void mep_cpaddaca1u_b (cp_v8uqi, cp_v8uqi);\n+void mep_cpaddla1_h (cp_v4hi, cp_v4hi);\n+void mep_cpaddua1_h (cp_v4hi, cp_v4hi);\n+void mep_cpadda1_b (cp_v8qi, cp_v8qi);\n+void mep_cpadda1u_b (cp_v8uqi, cp_v8uqi);\n+cp_data_bus_int mep_cdmovi (long);\n+cp_data_bus_int mep_cdmoviu (long);\n+cp_v2si mep_cpmovi_w (long);\n+cp_v2usi mep_cpmoviu_w (long);\n+cp_v4hi mep_cpmovi_h (long);\n+cp_v4uhi mep_cpmoviu_h (long);\n+cp_v8qi mep_cpmovi_b (long);\n+cp_data_bus_int mep_cdclipi3 (cp_data_bus_int, long);\n+cp_data_bus_int mep_cdclipiu3 (cp_data_bus_int, long);\n+cp_v2si mep_cpclipi3_w (cp_v2si, long);\n+cp_v2si mep_cpclipiu3_w (cp_v2si, long);\n+cp_v2si mep_cpslai3_w (cp_v2si, long);\n+cp_v4hi mep_cpslai3_h (cp_v4hi, long);\n+cp_data_bus_int mep_cdslli3 (cp_data_bus_int, long);\n+cp_v2si mep_cpslli3_w (cp_v2si, long);\n+cp_v4hi mep_cpslli3_h (cp_v4hi, long);\n+cp_v8qi mep_cpslli3_b (cp_v8qi, long);\n+cp_data_bus_int mep_cdsrai3 (cp_data_bus_int, long);\n+cp_v2si mep_cpsrai3_w (cp_v2si, long);\n+cp_v4hi mep_cpsrai3_h (cp_v4hi, long);\n+cp_v8qi mep_cpsrai3_b (cp_v8qi, long);\n+cp_data_bus_int mep_cdsrli3 (cp_data_bus_int, long);\n+cp_v2si mep_cpsrli3_w (cp_v2si, long);\n+cp_v4hi mep_cpsrli3_h (cp_v4hi, long);\n+cp_v8qi mep_cpsrli3_b (cp_v8qi, long);\n+void mep_cpocmpge_w (cp_v2si, cp_v2si); // volatile\n+void mep_cpocmpgeu_w (cp_v2usi, cp_v2usi); // volatile\n+void mep_cpocmpge_h (cp_v4hi, cp_v4hi); // volatile\n+void mep_cpocmpge_b (cp_v8qi, cp_v8qi); // volatile\n+void mep_cpocmpgeu_b (cp_v8uqi, cp_v8uqi); // volatile\n+void mep_cpocmpgt_w (cp_v2si, cp_v2si); // volatile\n+void mep_cpocmpgtu_w (cp_v2usi, cp_v2usi); // volatile\n+void mep_cpocmpgt_h (cp_v4hi, cp_v4hi); // volatile\n+void mep_cpocmpgt_b (cp_v8qi, cp_v8qi); // volatile\n+void mep_cpocmpgtu_b (cp_v8uqi, cp_v8uqi); // volatile\n+void mep_cpocmpne_w (cp_v2si, cp_v2si); // volatile\n+void mep_cpocmpne_h (cp_v4hi, cp_v4hi); // volatile\n+void mep_cpocmpne_b (cp_v8qi, cp_v8qi); // volatile\n+void mep_cpocmpeq_w (cp_v2si, cp_v2si); // volatile\n+void mep_cpocmpeq_h (cp_v4hi, cp_v4hi); // volatile\n+void mep_cpocmpeq_b (cp_v8qi, cp_v8qi); // volatile\n+void mep_cpacmpge_w (cp_v2si, cp_v2si); // volatile\n+void mep_cpacmpgeu_w (cp_v2usi, cp_v2usi); // volatile\n+void mep_cpacmpge_h (cp_v4hi, cp_v4hi); // volatile\n+void mep_cpacmpge_b (cp_v8qi, cp_v8qi); // volatile\n+void mep_cpacmpgeu_b (cp_v8uqi, cp_v8uqi); // volatile\n+void mep_cpacmpgt_w (cp_v2si, cp_v2si); // volatile\n+void mep_cpacmpgtu_w (cp_v2usi, cp_v2usi); // volatile\n+void mep_cpacmpgt_h (cp_v4hi, cp_v4hi); // volatile\n+void mep_cpacmpgt_b (cp_v8qi, cp_v8qi); // volatile\n+void mep_cpacmpgtu_b (cp_v8uqi, cp_v8uqi); // volatile\n+void mep_cpacmpne_w (cp_v2si, cp_v2si); // volatile\n+void mep_cpacmpne_h (cp_v4hi, cp_v4hi); // volatile\n+void mep_cpacmpne_b (cp_v8qi, cp_v8qi); // volatile\n+void mep_cpacmpeq_w (cp_v2si, cp_v2si); // volatile\n+void mep_cpacmpeq_h (cp_v4hi, cp_v4hi); // volatile\n+void mep_cpacmpeq_b (cp_v8qi, cp_v8qi); // volatile\n+void mep_cpcmpge_w (cp_v2si, cp_v2si);\n+void mep_cpcmpgeu_w (cp_v2usi, cp_v2usi);\n+void mep_cpcmpge_h (cp_v4hi, cp_v4hi);\n+void mep_cpcmpge_b (cp_v8qi, cp_v8qi);\n+void mep_cpcmpgeu_b (cp_v8uqi, cp_v8uqi);\n+void mep_cpcmpgt_w (cp_v2si, cp_v2si);\n+void mep_cpcmpgtu_w (cp_v2usi, cp_v2usi);\n+void mep_cpcmpgt_h (cp_v4hi, cp_v4hi);\n+void mep_cpcmpgt_b (cp_v8qi, cp_v8qi);\n+void mep_cpcmpgtu_b (cp_v8uqi, cp_v8uqi);\n+void mep_cpcmpne_w (cp_v2si, cp_v2si);\n+void mep_cpcmpne_h (cp_v4hi, cp_v4hi);\n+void mep_cpcmpne_b (cp_v8qi, cp_v8qi);\n+void mep_cpcmpeq_w (cp_v2si, cp_v2si);\n+void mep_cpcmpeq_h (cp_v4hi, cp_v4hi);\n+void mep_cpcmpeq_b (cp_v8qi, cp_v8qi);\n+void mep_cpcmpeqz_b (cp_v8qi, cp_v8qi);\n+cp_data_bus_int mep_cdcastw (cp_data_bus_int);\n+cp_data_bus_int mep_cdcastuw (cp_data_bus_int);\n+cp_v2si mep_cpcasth_w (cp_v2si);\n+cp_v2si mep_cpcastuh_w (cp_v2si);\n+cp_v2si mep_cpcastb_w (cp_v2si);\n+cp_v2si mep_cpcastub_w (cp_v2si);\n+cp_v4hi mep_cpcastb_h (cp_v4hi);\n+cp_v4hi mep_cpcastub_h (cp_v4hi);\n+cp_v4hi mep_cpextl_h (cp_v4hi);\n+cp_v4uhi mep_cpextlu_h (cp_v4uhi);\n+cp_v8qi mep_cpextl_b (cp_v8qi);\n+cp_v8uqi mep_cpextlu_b (cp_v8uqi);\n+cp_v4uhi mep_cpextu_h (cp_v4uhi);\n+cp_v4uhi mep_cpextuu_h (cp_v4uhi);\n+cp_v8uqi mep_cpextu_b (cp_v8uqi);\n+cp_v8uqi mep_cpextuu_b (cp_v8uqi);\n+cp_v2si mep_cpbcast_w (cp_v2si);\n+cp_v4hi mep_cpbcast_h (cp_v4hi);\n+cp_v8qi mep_cpbcast_b (cp_v8qi);\n+void mep_cpccadd_b (cp_v8qi*);\n+cp_v2si mep_cphadd_w (cp_v2si);\n+cp_v4hi mep_cphadd_h (cp_v4hi);\n+cp_v8qi mep_cphadd_b (cp_v8qi);\n+cp_v8uqi mep_cphaddu_b (cp_v8uqi);\n+cp_v2si mep_cpnorm_w (cp_v2si);\n+cp_v4hi mep_cpnorm_h (cp_v4hi);\n+cp_v2si mep_cpldz_w (cp_v2si);\n+cp_v4hi mep_cpldz_h (cp_v4hi);\n+cp_v2si mep_cpabsz_w (cp_v2si);\n+cp_v4hi mep_cpabsz_h (cp_v4hi);\n+cp_v8qi mep_cpabsz_b (cp_v8qi);\n+void mep_cpmovtocc (cp_data_bus_int);   // volatile\n+void mep_cpmovtocsar1 (cp_data_bus_int); // volatile\n+void mep_cpmovtocsar0 (cp_data_bus_int); // volatile\n+cp_data_bus_int mep_cpmovfrcc ();\n+cp_data_bus_int mep_cpmovfrcsar1 ();\n+cp_data_bus_int mep_cpmovfrcsar0 ();\n+cp_v2si mep_cpmin3_w (cp_v2si, cp_v2si);\n+cp_v2si mep_cpminu3_w (cp_v2si, cp_v2si);\n+cp_v4hi mep_cpmin3_h (cp_v4hi, cp_v4hi);\n+cp_v8qi mep_cpmin3_b (cp_v8qi, cp_v8qi);\n+cp_v8qi mep_cpminu3_b (cp_v8qi, cp_v8qi);\n+cp_v2si mep_cpmax3_w (cp_v2si, cp_v2si);\n+cp_v2si mep_cpmaxu3_w (cp_v2si, cp_v2si);\n+cp_v4hi mep_cpmax3_h (cp_v4hi, cp_v4hi);\n+cp_v8qi mep_cpmax3_b (cp_v8qi, cp_v8qi);\n+cp_v8qi mep_cpmaxu3_b (cp_v8qi, cp_v8qi);\n+cp_v4hi mep_cpabs3_h (cp_v4hi, cp_v4hi);\n+cp_v8qi mep_cpabs3_b (cp_v8qi, cp_v8qi);\n+cp_v8qi mep_cpabsu3_b (cp_v8qi, cp_v8qi);\n+cp_v2si mep_cpaddsr3_w (cp_v2si, cp_v2si);\n+cp_v4hi mep_cpaddsr3_h (cp_v4hi, cp_v4hi);\n+cp_v8qi mep_cpaddsr3_b (cp_v8qi, cp_v8qi);\n+cp_v8qi mep_cpaddsru3_b (cp_v8qi, cp_v8qi);\n+cp_v2si mep_cpave3_w (cp_v2si, cp_v2si);\n+cp_v4hi mep_cpave3_h (cp_v4hi, cp_v4hi);\n+cp_v8qi mep_cpave3_b (cp_v8qi, cp_v8qi);\n+cp_v8qi mep_cpaveu3_b (cp_v8qi, cp_v8qi);\n+cp_v8qi mep_cpextlsub3_b (cp_v8qi, cp_v8qi);\n+cp_v8qi mep_cpextlsubu3_b (cp_v8qi, cp_v8qi);\n+cp_v8qi mep_cpextusub3_b (cp_v8qi, cp_v8qi);\n+cp_v8qi mep_cpextusubu3_b (cp_v8qi, cp_v8qi);\n+cp_v8qi mep_cpextladd3_b (cp_v8qi, cp_v8qi);\n+cp_v8qi mep_cpextladdu3_b (cp_v8qi, cp_v8qi);\n+cp_v8qi mep_cpextuadd3_b (cp_v8qi, cp_v8qi);\n+cp_v8qi mep_cpextuaddu3_b (cp_v8qi, cp_v8qi);\n+cp_v2si mep_cpssub3_w (cp_v2si, cp_v2si);\n+cp_v4hi mep_cpssub3_h (cp_v4hi, cp_v4hi);\n+cp_v2si mep_cpsadd3_w (cp_v2si, cp_v2si);\n+cp_v4hi mep_cpsadd3_h (cp_v4hi, cp_v4hi);\n+cp_v2si mep_cpsla3_w (cp_v2si, cp_v2si);\n+cp_v4hi mep_cpsla3_h (cp_v4hi, cp_v4hi);\n+cp_data_bus_int mep_cdsll3 (cp_data_bus_int, cp_data_bus_int);\n+cp_v2si mep_cpssll3_w (cp_v2si, cp_v2si);\n+cp_v2si mep_cpsll3_w (cp_v2si, cp_v2si);\n+cp_v4hi mep_cpssll3_h (cp_v4hi, cp_v4hi);\n+cp_v4hi mep_cpsll3_h (cp_v4hi, cp_v4hi);\n+cp_v8qi mep_cpssll3_b (cp_v8qi, cp_v8qi);\n+cp_v8qi mep_cpsll3_b (cp_v8qi, cp_v8qi);\n+cp_data_bus_int mep_cdsra3 (cp_data_bus_int, cp_data_bus_int);\n+cp_v2si mep_cpssra3_w (cp_v2si, cp_v2si);\n+cp_v2si mep_cpsra3_w (cp_v2si, cp_v2si);\n+cp_v4hi mep_cpssra3_h (cp_v4hi, cp_v4hi);\n+cp_v4hi mep_cpsra3_h (cp_v4hi, cp_v4hi);\n+cp_v8qi mep_cpssra3_b (cp_v8qi, cp_v8qi);\n+cp_v8qi mep_cpsra3_b (cp_v8qi, cp_v8qi);\n+cp_data_bus_int mep_cdsrl3 (cp_data_bus_int, cp_data_bus_int);\n+cp_v2si mep_cpssrl3_w (cp_v2si, cp_v2si);\n+cp_v2si mep_cpsrl3_w (cp_v2si, cp_v2si);\n+cp_v4hi mep_cpssrl3_h (cp_v4hi, cp_v4hi);\n+cp_v4hi mep_cpsrl3_h (cp_v4hi, cp_v4hi);\n+cp_v8qi mep_cpssrl3_b (cp_v8qi, cp_v8qi);\n+cp_v8qi mep_cpsrl3_b (cp_v8qi, cp_v8qi);\n+cp_v4hi mep_cppack_h (cp_v4hi, cp_v4hi);\n+cp_v8qi mep_cppack_b (cp_v8qi, cp_v8qi);\n+cp_v8uqi mep_cppacku_b (cp_v8uqi, cp_v8uqi);\n+cp_v2si mep_cpunpackl_w (cp_v2si, cp_v2si);\n+cp_v4hi mep_cpunpackl_h (cp_v4hi, cp_v4hi);\n+cp_v8qi mep_cpunpackl_b (cp_v8qi, cp_v8qi);\n+cp_v2usi mep_cpunpacku_w (cp_v2usi, cp_v2usi);\n+cp_v4uhi mep_cpunpacku_h (cp_v4uhi, cp_v4uhi);\n+cp_v8uqi mep_cpunpacku_b (cp_v8uqi, cp_v8uqi);\n+cp_data_bus_int mep_cpfsftbs1 (cp_data_bus_int, cp_data_bus_int);\n+cp_data_bus_int mep_cpfsftbs0 (cp_data_bus_int, cp_data_bus_int);\n+cp_data_bus_int mep_cpfsftbi (cp_data_bus_int, cp_data_bus_int, long);\n+cp_data_bus_int mep_cpsel (cp_data_bus_int, cp_data_bus_int);\n+cp_vector mep_cpxor3 (cp_vector, cp_vector);\n+cp_vector mep_cpnor3 (cp_vector, cp_vector);\n+cp_vector mep_cpor3 (cp_vector, cp_vector);\n+cp_vector mep_cpand3 (cp_vector, cp_vector);\n+cp_data_bus_int mep_cdsub3 (cp_data_bus_int, cp_data_bus_int);\n+cp_v2si mep_cpsub3_w (cp_v2si, cp_v2si);\n+cp_v4hi mep_cpsub3_h (cp_v4hi, cp_v4hi);\n+cp_v8qi mep_cpsub3_b (cp_v8qi, cp_v8qi);\n+cp_data_bus_int mep_cdadd3 (cp_data_bus_int, cp_data_bus_int);\n+cp_v2si mep_cpadd3_w (cp_v2si, cp_v2si);\n+cp_v4hi mep_cpadd3_h (cp_v4hi, cp_v4hi);\n+cp_v8qi mep_cpadd3_b (cp_v8qi, cp_v8qi);\n+void mep_cmovh_rn_crm_p0 (long, long);  // volatile\n+void mep_cmovh_crn_rm_p0 (long, long);  // volatile\n+void mep_cmovc_rn_ccrm_p0 (long, long); // volatile\n+void mep_cmovc_ccrn_rm_p0 (long, long); // volatile\n+void mep_cmov_rn_crm_p0 (long, long);   // volatile\n+void mep_cmov_crn_rm_p0 (long, long);   // volatile\n+void mep_bsrv (void *);\n+void mep_jsrv (long);\n+void mep_synccp ();                     // volatile\n+void mep_bcpaf (long, void *);\n+void mep_bcpat (long, void *);\n+void mep_bcpne (long, void *);\n+void mep_bcpeq (long, void *);\n+void mep_lmcpm1 (cp_data_bus_int*, long **, long);\n+void mep_smcpm1 (cp_data_bus_int, long **, long);\n+void mep_lwcpm1 (cp_data_bus_int*, long **, long);\n+void mep_swcpm1 (cp_data_bus_int, long **, long);\n+void mep_lhcpm1 (cp_data_bus_int*, long **, long);\n+void mep_shcpm1 (cp_data_bus_int, long **, long);\n+void mep_lbcpm1 (cp_data_bus_int*, long **, long);\n+void mep_sbcpm1 (cp_data_bus_int, long **, long);\n+void mep_lmcpm0 (cp_data_bus_int*, long **, long);\n+void mep_smcpm0 (cp_data_bus_int, long **, long);\n+void mep_lwcpm0 (cp_data_bus_int*, long **, long);\n+void mep_swcpm0 (cp_data_bus_int, long **, long);\n+void mep_lhcpm0 (cp_data_bus_int*, long **, long);\n+void mep_shcpm0 (cp_data_bus_int, long **, long);\n+void mep_lbcpm0 (cp_data_bus_int*, long **, long);\n+void mep_sbcpm0 (cp_data_bus_int, long **, long);\n+void mep_lmcpa (cp_data_bus_int*, long **, long);\n+void mep_smcpa (cp_data_bus_int, long **, long);\n+void mep_lwcpa (cp_data_bus_int*, long **, long);\n+void mep_swcpa (cp_data_bus_int, long **, long);\n+void mep_lhcpa (cp_data_bus_int*, long **, long);\n+void mep_shcpa (cp_data_bus_int, long **, long);\n+void mep_lbcpa (cp_data_bus_int*, long **, long);\n+void mep_sbcpa (cp_data_bus_int, long **, long);\n+void mep_lmcp16 (cp_data_bus_int*, long, long *);\n+void mep_smcp16 (cp_data_bus_int, long, long *); // volatile\n+void mep_lwcp16 (cp_data_bus_int*, long, long *);\n+void mep_swcp16 (cp_data_bus_int, long, long *);\n+void mep_lmcpi (cp_data_bus_int*, long **);\n+void mep_smcpi (cp_data_bus_int, long **);\n+void mep_lwcpi (cp_data_bus_int*, long **);\n+void mep_swcpi (cp_data_bus_int, long **);\n+void mep_lmcp (cp_data_bus_int*, long *);\n+void mep_smcp (cp_data_bus_int, long *); // volatile\n+void mep_lwcp (cp_data_bus_int*, long *);\n+void mep_swcp (cp_data_bus_int, long *);\n+void mep_ssubu (long*, long);\n+void mep_saddu (long*, long);\n+void mep_ssub (long*, long);\n+void mep_sadd (long*, long);\n+void mep_clipu (long*, long);\n+void mep_clip (long*, long);\n+void mep_maxu (long*, long);\n+void mep_minu (long*, long);\n+void mep_max (long*, long);\n+void mep_min (long*, long);\n+void mep_ave (long*, long);\n+void mep_abs (long*, long);\n+void mep_ldz (long*, long);\n+void mep_dbreak ();                     // volatile\n+void mep_dret ();\n+void mep_divu (long, long);\n+void mep_div (long, long);\n+void mep_maddru (long*, long);\n+void mep_maddr (long*, long);\n+void mep_maddu (long, long);\n+void mep_madd (long, long);\n+void mep_mulru (long*, long);\n+void mep_mulr (long*, long);\n+void mep_mulu (long, long);\n+void mep_mul (long, long);\n+void mep_cache (long, long *);          // volatile\n+void mep_tas (long*, long *);\n+void mep_btstm (long*, long *, long);\n+void mep_bnotm (long *, long);\n+void mep_bclrm (long *, long);\n+void mep_bsetm (long *, long);\n+void mep_ldcb (long*, long);            // volatile\n+void mep_stcb (long, long);             // volatile\n+void mep_syncm ();                      // volatile\n+void mep_break ();                      // volatile\n+void mep_swi (long);                    // volatile\n+void mep_sleep ();                      // volatile\n+void mep_halt ();                       // volatile\n+void mep_reti ();\n+void mep_ei ();                         // volatile\n+void mep_di ();                         // volatile\n+void mep_ldc (long*, long);             // volatile\n+void mep_ldc_lo (long*);\n+void mep_ldc_hi (long*);\n+void mep_ldc_lp (long*);\n+void mep_stc (long, long);              // volatile\n+void mep_stc_lo (long);\n+void mep_stc_hi (long);\n+void mep_stc_lp (long);\n+void mep_erepeat (void *);\n+void mep_repeat (long, void *);\n+void mep_ret ();\n+void mep_jsr (long);\n+void mep_jmp24 (void *);\n+void mep_jmp (long);\n+void mep_bsr24 (void *);\n+void mep_bsr12 (void *);\n+void mep_bne (long, long, void *);\n+void mep_beq (long, long, void *);\n+void mep_bgei (long, long, void *);\n+void mep_blti (long, long, void *);\n+void mep_bnei (long, long, void *);\n+void mep_beqi (long, long, void *);\n+void mep_bnez (long, void *);\n+void mep_beqz (long, void *);\n+void mep_bra (void *);\n+void mep_fsft (long*, long);\n+void mep_sll3 (long*, long, long);\n+void mep_slli (long*, long);\n+void mep_srli (long*, long);\n+void mep_srai (long*, long);\n+void mep_sll (long*, long);\n+void mep_srl (long*, long);\n+void mep_sra (long*, long);\n+void mep_xor3 (long*, long, long);\n+void mep_and3 (long*, long, long);\n+void mep_or3 (long*, long, long);\n+void mep_nor (long*, long);\n+void mep_xor (long*, long);\n+void mep_and (long*, long);\n+void mep_or (long*, long);\n+void mep_sltu3x (long*, long, long);\n+void mep_slt3x (long*, long, long);\n+void mep_add3x (long*, long, long);\n+void mep_sl2ad3 (long*, long, long);\n+void mep_sl1ad3 (long*, long, long);\n+void mep_sltu3i (long*, long, long);\n+void mep_slt3i (long*, long, long);\n+void mep_sltu3 (long*, long, long);\n+void mep_slt3 (long*, long, long);\n+void mep_neg (long*, long);\n+void mep_sbvck3 (long*, long, long);\n+void mep_sub (long*, long);\n+void mep_advck3 (long*, long, long);\n+void mep_add3i (long*, long);\n+void mep_add (long*, long);\n+void mep_add3 (long*, long, long);\n+void mep_movh (long*, long);\n+void mep_movu16 (long*, long);\n+void mep_movu24 (long*, long);\n+void mep_movi16 (long*, long);\n+void mep_movi8 (long*, long);\n+void mep_mov (long*, long);\n+void mep_ssarb (long, long);\n+void mep_extuh (long*);\n+void mep_extub (long*);\n+void mep_exth (long*);\n+void mep_extb (long*);\n+void mep_lw24 (long*, long);\n+void mep_sw24 (long, long);\n+void mep_lhu16 (long*, long, long *);\n+void mep_lbu16 (long*, long, long *);\n+void mep_lw16 (long*, long, long *);\n+void mep_lh16 (long*, long, long *);\n+void mep_lb16 (long*, long, long *);\n+void mep_sw16 (long, long, long *);\n+void mep_sh16 (long, long, long *);\n+void mep_sb16 (long, long, long *);\n+void mep_lhu_tp (long*, long);\n+void mep_lbu_tp (long*, long);\n+void mep_lw_tp (long*, long);\n+void mep_lh_tp (long*, long);\n+void mep_lb_tp (long*, long);\n+void mep_sw_tp (long, long);\n+void mep_sh_tp (long, long);\n+void mep_sb_tp (long, long);\n+void mep_lw_sp (long*, long);\n+void mep_sw_sp (long, long);\n+void mep_lhu (long*, long *);\n+void mep_lbu (long*, long *);\n+void mep_lw (long*, long *);\n+void mep_lh (long*, long *);\n+void mep_lb (long*, long *);\n+void mep_sw (long, long *);\n+void mep_sh (long, long *);\n+void mep_sb (long, long *);\n+void mep_dsp1 (long*, long);            // volatile\n+void mep_dsp0 (long);                   // volatile\n+void mep_dsp (long*, long, long);       // volatile\n+void mep_uci (long*, long, long);       // volatile\n+void mep_lhucpm1 (cp_data_bus_int*, long **, long);\n+void mep_lbucpm1 (cp_data_bus_int*, long **, long);\n+void mep_lhucpm0 (cp_data_bus_int*, long **, long);\n+void mep_lbucpm0 (cp_data_bus_int*, long **, long);\n+void mep_lhucpa (cp_data_bus_int*, long **, long);\n+void mep_lbucpa (cp_data_bus_int*, long **, long);\n+void mep_lhucp (cp_data_bus_int*, long, long *);\n+void mep_lhcp (cp_data_bus_int*, long, long *);\n+void mep_shcp (cp_data_bus_int, long, long *);\n+void mep_lbucp (cp_data_bus_int*, long, long *);\n+void mep_lbcp (cp_data_bus_int*, long, long *);\n+void mep_sbcp (cp_data_bus_int, long, long *);\n+void mep_casw3 (long*, long, long);     // volatile\n+void mep_cash3 (long*, long, long);     // volatile\n+void mep_casb3 (long*, long, long);     // volatile\n+void mep_prefd (long, long, long *);    // volatile\n+void mep_pref (long, long *);           // volatile\n+void mep_ldcb_r (long*, long *);        // volatile\n+void mep_stcb_r (long, long *);         // volatile\n+void mep_cmovh2 (long*, cp_data_bus_int);\n+void mep_cmovh1 (cp_data_bus_int*, long);\n+void mep_cmovc2 (long*, long);          // volatile\n+void mep_cmovc1 (long, long);           // volatile\n+void mep_cmov2 (long*, cp_data_bus_int);\n+void mep_cmov1 (cp_data_bus_int*, long);\n+cp_data_bus_int mep_cpmov (cp_data_bus_int);"}, {"sha": "aa036f8b602cc7072f8777262155954e866afec0", "filename": "gcc/config/mep/intrinsics.md", "status": "added", "additions": 29379, "deletions": 0, "changes": 29379, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7acf4da6f94801cb3146709fc0ae310ac475a274/gcc%2Fconfig%2Fmep%2Fintrinsics.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7acf4da6f94801cb3146709fc0ae310ac475a274/gcc%2Fconfig%2Fmep%2Fintrinsics.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmep%2Fintrinsics.md?ref=7acf4da6f94801cb3146709fc0ae310ac475a274"}, {"sha": "da0440c0dee8178eadf162845f04b5b6e9ae1a3c", "filename": "gcc/config/mep/ivc2-template.h", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7acf4da6f94801cb3146709fc0ae310ac475a274/gcc%2Fconfig%2Fmep%2Fivc2-template.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7acf4da6f94801cb3146709fc0ae310ac475a274/gcc%2Fconfig%2Fmep%2Fivc2-template.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmep%2Fivc2-template.h?ref=7acf4da6f94801cb3146709fc0ae310ac475a274", "patch": "@@ -0,0 +1,9 @@\n+#undef __section\n+#define __section(_secname) __attribute__((section(#_secname)))\n+#undef mep_nop\n+#define mep_nop() __asm__ volatile (\"nop\")\n+\n+#pragma GCC coprocessor available $c0...$c31\n+#pragma GCC coprocessor call_saved $c6...$c7\n+\n+#include <intrinsics.h>"}, {"sha": "e70cee89e8a474b6dc135a2bbcf7f7dfa6a05261", "filename": "gcc/config/mep/mep-c5.cpu", "status": "added", "additions": 260, "deletions": 0, "changes": 260, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7acf4da6f94801cb3146709fc0ae310ac475a274/gcc%2Fconfig%2Fmep%2Fmep-c5.cpu", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7acf4da6f94801cb3146709fc0ae310ac475a274/gcc%2Fconfig%2Fmep%2Fmep-c5.cpu", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmep%2Fmep-c5.cpu?ref=7acf4da6f94801cb3146709fc0ae310ac475a274", "patch": "@@ -0,0 +1,260 @@\n+; Insns introduced for the MeP-c5 core\n+;\n+\n+(dnf f-c5n4     \"extended field\"     (all-mep-core-isas)   16  4)\n+(dnf f-c5n5     \"extended field\"     (all-mep-core-isas)   20  4)\n+(dnf f-c5n6     \"extended field\"     (all-mep-core-isas)   24  4)\n+(dnf f-c5n7     \"extended field\"     (all-mep-core-isas)   28  4)\n+(dnf f-rl5      \"register l c5\"      (all-mep-core-isas)   20  4)\n+(df  f-12s20    \"extended field\"     (all-mep-core-isas)   20  12  INT #f #f)\n+\n+(dnop rl5       \"register Rl c5\"     (all-mep-core-isas) h-gpr   f-rl5)\n+(dnop cdisp12   \"copro addend (12 bits)\" (all-mep-core-isas) h-sint  f-12s20)\n+\n+(dnci stcb_r \"store in control bus space\" (VOLATILE (MACH c5))\n+     \"stcb $rn,($rma)\"\n+     (+ MAJ_7 rn rma (f-sub4 12))\n+     (c-call VOID \"do_stcb\" rn (and rma #xffff))\n+     ((mep (unit u-use-gpr (in usereg rn))\n+\t   (unit u-use-gpr (in usereg rma))\n+\t   (unit u-exec)\n+\t   (unit u-stcb))))\n+\n+(dnci ldcb_r \"load from control bus space\" (VOLATILE (MACH c5) (LATENCY 3))\n+     \"ldcb $rn,($rma)\"\n+     (+ MAJ_7 rn rma (f-sub4 13))\n+     (set rn (c-call SI \"do_ldcb\" (and rma #xffff)))\n+      ((mep (unit u-use-gpr (in usereg rma))\n+\t    (unit u-ldcb)\n+\t    (unit u-exec)\n+\t    (unit u-ldcb-gpr (out loadreg rn)))))\n+\n+(dnci pref \"cache prefetch\" ((MACH c5) VOLATILE)\n+     \"pref $cimm4,($rma)\"\n+     (+ MAJ_7 cimm4 rma (f-sub4 5))\n+     (sequence ()\n+\t       (c-call VOID \"check_option_dcache\" pc)\n+\t       (c-call VOID \"do_cache_prefetch\" cimm4 rma pc))\n+     ((mep (unit u-use-gpr (in usereg rma))\n+\t   (unit u-exec))))\n+\n+(dnci prefd \"cache prefetch\" ((MACH c5) VOLATILE)\n+     \"pref $cimm4,$sdisp16($rma)\"\n+     (+ MAJ_15 cimm4 rma (f-sub4 3) sdisp16)\n+     (sequence ()\n+\t       (c-call VOID \"check_option_dcache\" pc)\n+\t       (c-call VOID \"do_cache_prefetch\" cimm4 (add INT rma (ext SI sdisp16)) pc))\n+     ((mep (unit u-use-gpr (in usereg rma))\n+\t   (unit u-exec))))\n+\n+(dnci casb3 \"compare and swap byte 3\" ((MACH c5) VOLATILE OPTIONAL_BIT_INSN)\n+      \"casb3 $rl5,$rn,($rm)\"\n+      (+ MAJ_15 rn rm (f-sub4 #x1) (f-c5n4 #x2) rl5 (f-c5n6 #x0) (f-c5n7 #x0))\n+      (sequence ()\n+\t\t(c-call VOID \"do_casb3\" (index-of rl5) rn rm pc)\n+\t\t(set rl5 rl5)\n+\t\t)\n+      ((mep (unit u-use-gpr (in usereg rl5))\n+\t    (unit u-load-gpr (out loadreg rl5))\n+\t    (unit u-exec))))\n+\n+(dnci cash3 \"compare and swap halfword 3\" ((MACH c5) VOLATILE OPTIONAL_BIT_INSN)\n+      \"cash3 $rl5,$rn,($rm)\"\n+      (+ MAJ_15 rn rm (f-sub4 #x1) (f-c5n4 #x2) rl5 (f-c5n6 #x0) (f-c5n7 #x1))\n+      (sequence ()\n+\t\t(c-call VOID \"do_cash3\" (index-of rl5) rn rm pc)\n+\t\t(set rl5 rl5)\n+\t\t)\n+      ((mep (unit u-use-gpr (in usereg rl5))\n+\t    (unit u-load-gpr (out loadreg rl5))\n+\t    (unit u-exec))))\n+\n+(dnci casw3 \"compare and swap word 3\" ((MACH c5) VOLATILE OPTIONAL_BIT_INSN)\n+      \"casw3 $rl5,$rn,($rm)\"\n+      (+ MAJ_15 rn rm (f-sub4 #x1) (f-c5n4 #x2) rl5 (f-c5n6 #x0) (f-c5n7 #x2))\n+      (sequence ()\n+\t\t(c-call VOID \"do_casw3\" (index-of rl5) rn rm pc)\n+\t\t(set rl5 rl5)\n+\t\t)\n+      ((mep (unit u-use-gpr (in usereg rl5))\n+\t    (unit u-load-gpr (out loadreg rl5))\n+\t    (unit u-exec))))\n+\n+\n+\n+(dnci sbcp \"store byte coprocessor\" (OPTIONAL_CP_INSN (STALL STORE) (MACH c5))\n+     \"sbcp $crn,$cdisp12($rma)\"\n+     (+ MAJ_15 crn rma (f-sub4 6) (f-ext4 0) cdisp12)\n+     (sequence ()\n+\t       (c-call \"check_option_cp\" pc)\n+\t       (c-call VOID \"check_write_to_text\" (add rma (ext SI cdisp12)))\n+\t       (set (mem QI (add rma (ext SI cdisp12))) (and crn #xff)))\n+     ((mep (unit u-use-gpr (in usereg rma))\n+\t   (unit u-exec))))\n+\n+(dnci lbcp \"load byte coprocessor\" (OPTIONAL_CP_INSN (STALL STORE) (MACH c5))\n+     \"lbcp $crn,$cdisp12($rma)\"\n+     (+ MAJ_15 crn rma (f-sub4 6) (f-ext4 4) cdisp12)\n+     (sequence ()\n+\t       (c-call \"check_option_cp\" pc)\n+\t       (set crn (ext SI (mem QI (add rma (ext SI cdisp12))))))\n+     ((mep (unit u-use-gpr (in usereg rma))\n+\t   (unit u-exec))))\n+\n+(dnci lbucp \"load byte coprocessor\" (OPTIONAL_CP_INSN (STALL STORE) (MACH c5))\n+     \"lbucp $crn,$cdisp12($rma)\"\n+     (+ MAJ_15 crn rma (f-sub4 6) (f-ext4 12) cdisp12)\n+     (sequence ()\n+\t       (c-call \"check_option_cp\" pc)\n+\t       (set crn (zext SI (mem QI (add rma (ext SI cdisp12))))))\n+     ((mep (unit u-use-gpr (in usereg rma))\n+\t   (unit u-exec))))\n+\n+\n+(dnci shcp \"store half-word coprocessor\" (OPTIONAL_CP_INSN (STALL STORE) (MACH c5))\n+     \"shcp $crn,$cdisp12($rma)\"\n+     (+ MAJ_15 crn rma (f-sub4 6) (f-ext4 1) cdisp12)\n+     (sequence ()\n+\t       (c-call \"check_option_cp\" pc)\n+\t       (c-call VOID \"check_write_to_text\" (add rma (ext SI cdisp12)))\n+\t       (set (mem HI (add rma (ext SI cdisp12))) (and crn #xffff)))\n+     ((mep (unit u-use-gpr (in usereg rma))\n+\t   (unit u-exec))))\n+\n+(dnci lhcp \"load half-word coprocessor\" (OPTIONAL_CP_INSN (STALL STORE) (MACH c5))\n+     \"lhcp $crn,$cdisp12($rma)\"\n+     (+ MAJ_15 crn rma (f-sub4 6) (f-ext4 5) cdisp12)\n+     (sequence ()\n+\t       (c-call \"check_option_cp\" pc)\n+\t       (set crn (ext SI (mem HI (add rma (ext SI cdisp12))))))\n+     ((mep (unit u-use-gpr (in usereg rma))\n+\t   (unit u-exec))))\n+\n+(dnci lhucp \"load half-word coprocessor\" (OPTIONAL_CP_INSN (STALL STORE) (MACH c5))\n+     \"lhucp $crn,$cdisp12($rma)\"\n+     (+ MAJ_15 crn rma (f-sub4 6) (f-ext4 13) cdisp12)\n+     (sequence ()\n+\t       (c-call \"check_option_cp\" pc)\n+\t       (set crn (zext SI (mem HI (add rma (ext SI cdisp12))))))\n+     ((mep (unit u-use-gpr (in usereg rma))\n+\t   (unit u-exec))))\n+\n+\n+(dnci lbucpa \"load byte coprocessor\" (OPTIONAL_CP_INSN (STALL LOAD) (MACH c5))\n+     \"lbucpa $crn,($rma+),$cdisp10\"\n+     (+ MAJ_15 crn rma (f-sub4 5) (f-ext4 #xC) (f-ext62 #x0) cdisp10)\n+     (sequence ()\n+\t       (c-call \"check_option_cp\" pc)\n+\t       (set crn (zext SI (mem QI rma)))\n+\t       (set rma (add rma cdisp10)))\n+     ((mep (unit u-use-gpr (in usereg rma))\n+\t   (unit u-exec))))\n+\n+(dnci lhucpa \"load half-word coprocessor\" (OPTIONAL_CP_INSN (STALL LOAD) (MACH c5))\n+     \"lhucpa $crn,($rma+),$cdisp10a2\"\n+     (+ MAJ_15 crn rma (f-sub4 5) (f-ext4 #xD) (f-ext62 #x0) cdisp10a2)\n+     (sequence ()\n+\t       (c-call \"check_option_cp\" pc)\n+\t       (set crn (zext SI (mem HI (and rma (inv SI 1)))))\n+\t       (set rma (add rma (ext SI cdisp10a2))))\n+     ((mep (unit u-use-gpr (in usereg rma))\n+\t   (unit u-exec))))\n+\n+(dnci lbucpm0 \"lbucpm0\" (OPTIONAL_CP_INSN (MACH c5))\n+     \"lbucpm0 $crn,($rma+),$cdisp10\"\n+     (+ MAJ_15 crn rma (f-sub4 5) (f-ext4 #xc) (f-ext62 #x2) cdisp10)\n+     (sequence ()\n+\t       (c-call \"check_option_cp\" pc)\n+\t       (set crn (zext SI (mem QI rma)))\n+\t       (set rma (mod0 cdisp10)))\n+     ((mep (unit u-use-gpr (in usereg rma))\n+\t   (unit u-exec))))\n+\n+(dnci lhucpm0 \"lhucpm0\" (OPTIONAL_CP_INSN (MACH c5))\n+     \"lhucpm0 $crn,($rma+),$cdisp10a2\"\n+     (+ MAJ_15 crn rma (f-sub4 5) (f-ext4 #xd) (f-ext62 #x2) cdisp10a2)\n+     (sequence ()\n+\t       (c-call \"check_option_cp\" pc)\n+\t       (set crn (zext SI (mem HI (and rma (inv SI 1)))))\n+\t       (set rma (mod0 cdisp10a2)))\n+     ((mep (unit u-use-gpr (in usereg rma))\n+\t   (unit u-exec))))\n+\n+(dnci lbucpm1 \"lbucpm1\" (OPTIONAL_CP_INSN (MACH c5))\n+     \"lbucpm1 $crn,($rma+),$cdisp10\"\n+     (+ MAJ_15 crn rma (f-sub4 5) (f-ext4 #xc) (f-ext62 #x3) cdisp10)\n+     (sequence ()\n+\t       (c-call \"check_option_cp\" pc)\n+\t       (set crn (zext SI (mem QI rma)))\n+\t       (set rma (mod1 cdisp10)))\n+     ((mep (unit u-use-gpr (in usereg rma))\n+\t   (unit u-exec))))\n+\n+(dnci lhucpm1 \"lhucpm1\" (OPTIONAL_CP_INSN (MACH c5))\n+     \"lhucpm1 $crn,($rma+),$cdisp10a2\"\n+     (+ MAJ_15 crn rma (f-sub4 5) (f-ext4 #xd) (f-ext62 #x3) cdisp10a2)\n+     (sequence ()\n+\t       (c-call \"check_option_cp\" pc)\n+\t       (set crn (zext SI (mem HI (and rma (inv SI 1)))))\n+\t       (set rma (mod1 cdisp10a2)))\n+     ((mep (unit u-use-gpr (in usereg rma))\n+\t   (unit u-exec))))\n+\n+(dnci uci \"uci\" ((MACH c5) VOLATILE)\n+     \"uci $rn,$rm,$uimm16\"\n+     (+ MAJ_15 rn rm (f-sub4 2) simm16)\n+     (set rn (c-call SI \"do_UCI\" rn rm (zext SI uimm16) pc))\n+     ((mep (unit u-use-gpr (in usereg rm))\n+\t   (unit u-use-gpr (in usereg rn))\n+\t   (unit u-exec))))\n+\n+(dnf f-c5-rnm     \"register n/m\"              (all-mep-isas)    4  8)\n+(dnf f-c5-rm      \"register m\"              (all-mep-isas)    8  4)\n+(df  f-c5-16u16  \"general 16-bit u-val\"    (all-mep-isas) 16 16 UINT #f #f)\n+\n+(dnmf f-c5-rmuimm20 \"20-bit immediate in Rm/Imm16\" (all-mep-isas) UINT\n+      (f-c5-rm f-c5-16u16)\n+      (sequence () ; insert\n+\t\t(set (ifield f-c5-rm)    (srl (ifield f-c5-rmuimm20) 16))\n+\t\t(set (ifield f-c5-16u16) (and (ifield f-c5-rmuimm20) #xffff))\n+\t\t)\n+      (sequence () ; extract\n+\t\t(set (ifield f-c5-rmuimm20) (or (ifield f-c5-16u16)\n+\t\t\t\t\t\t(sll (ifield f-c5-rm) 16)))\n+\t\t)\n+      )\n+(dnop c5rmuimm20 \"20-bit immediate in rm and imm16\" (all-mep-core-isas) h-uint f-c5-rmuimm20)\n+\n+(dnmf f-c5-rnmuimm24 \"24-bit immediate in Rm/Imm16\" (all-mep-isas) UINT\n+      (f-c5-rnm f-c5-16u16)\n+      (sequence () ; insert\n+\t\t(set (ifield f-c5-rnm)    (srl (ifield f-c5-rnmuimm24) 16))\n+\t\t(set (ifield f-c5-16u16) (and (ifield f-c5-rnmuimm24) #xffff))\n+\t\t)\n+      (sequence () ; extract\n+\t\t(set (ifield f-c5-rnmuimm24) (or (ifield f-c5-16u16)\n+\t\t\t\t\t\t(sll (ifield f-c5-rnm) 16)))\n+\t\t)\n+      )\n+(dnop c5rnmuimm24 \"24-bit immediate in rn, rm, and imm16\" (all-mep-core-isas) h-uint f-c5-rnmuimm24)\n+\n+(dnci dsp \"dsp\" ((MACH c5) VOLATILE)\n+     \"dsp $rn,$rm,$uimm16\"\n+     (+ MAJ_15 rn rm (f-sub4 0) uimm16)\n+     (set rn (c-call SI \"do_DSP\" rn rm (zext SI uimm16) pc))\n+     ((mep (unit u-use-gpr (in usereg rm))\n+\t   (unit u-use-gpr (in usereg rn))\n+\t   (unit u-exec))))\n+\n+(dnci dsp0 \"dsp0\" ((MACH c5) VOLATILE NO-DIS ALIAS)\n+     \"dsp0 $c5rnmuimm24\"\n+     (+ MAJ_15 c5rnmuimm24 (f-sub4 0))\n+     (c-call VOID \"do_DSP\" (zext SI c5rnmuimm24) pc)\n+     ((mep (unit u-exec))))\n+\n+(dnci dsp1 \"dsp1\" ((MACH c5) VOLATILE NO-DIS ALIAS)\n+     \"dsp1 $rn,$c5rmuimm20\"\n+     (+ MAJ_15 rn (f-sub4 0) c5rmuimm20)\n+     (set rn (c-call SI \"do_DSP\" rn (zext SI c5rmuimm20) pc))\n+     ((mep (unit u-use-gpr (in usereg rn))\n+\t   (unit u-exec))))"}, {"sha": "f66aa6c8446197478aedd7f843e1f490eee3e318", "filename": "gcc/config/mep/mep-core.cpu", "status": "added", "additions": 3065, "deletions": 0, "changes": 3065, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7acf4da6f94801cb3146709fc0ae310ac475a274/gcc%2Fconfig%2Fmep%2Fmep-core.cpu", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7acf4da6f94801cb3146709fc0ae310ac475a274/gcc%2Fconfig%2Fmep%2Fmep-core.cpu", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmep%2Fmep-core.cpu?ref=7acf4da6f94801cb3146709fc0ae310ac475a274"}, {"sha": "d55b20ff7ecb6875dcd775ba0821c290daff0c70", "filename": "gcc/config/mep/mep-default.cpu", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7acf4da6f94801cb3146709fc0ae310ac475a274/gcc%2Fconfig%2Fmep%2Fmep-default.cpu", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7acf4da6f94801cb3146709fc0ae310ac475a274/gcc%2Fconfig%2Fmep%2Fmep-default.cpu", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmep%2Fmep-default.cpu?ref=7acf4da6f94801cb3146709fc0ae310ac475a274", "patch": "@@ -0,0 +1,10 @@\n+; Toshiba MeP Media Engine architecture description.  -*- Scheme -*-\n+; Copyright (C) 2001 Red Hat, Inc.\n+; This file is part of CGEN.\n+; See file COPYING.CGEN for details.\n+\n+; This file serves as a wrapper to bring in the core description plus\n+; sample implementations of the UCI and DSP instructions.\n+\n+(include \"mep-core.cpu\")\n+(include \"mep-ext-cop.cpu\")"}, {"sha": "e2450051561c4f75fba746763658255eaeb8293c", "filename": "gcc/config/mep/mep-ext-cop.cpu", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7acf4da6f94801cb3146709fc0ae310ac475a274/gcc%2Fconfig%2Fmep%2Fmep-ext-cop.cpu", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7acf4da6f94801cb3146709fc0ae310ac475a274/gcc%2Fconfig%2Fmep%2Fmep-ext-cop.cpu", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmep%2Fmep-ext-cop.cpu?ref=7acf4da6f94801cb3146709fc0ae310ac475a274", "patch": "@@ -0,0 +1,8 @@\n+; Toshiba MeP Media Engine architecture description.  -*- Scheme -*-\n+; Copyright (C) 2003 Red Hat, Inc.\n+; This file is part of CGEN.\n+; See file COPYING.CGEN for details.\n+\n+;; begin-user-isa-includes\n+(include \"mep-ivc2.cpu\")\n+;; end-user-isa-includes"}, {"sha": "8af4cb1ed029593506fcc78ddec7d5c8203982dd", "filename": "gcc/config/mep/mep-intrin.h", "status": "added", "additions": 8939, "deletions": 0, "changes": 8939, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7acf4da6f94801cb3146709fc0ae310ac475a274/gcc%2Fconfig%2Fmep%2Fmep-intrin.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7acf4da6f94801cb3146709fc0ae310ac475a274/gcc%2Fconfig%2Fmep%2Fmep-intrin.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmep%2Fmep-intrin.h?ref=7acf4da6f94801cb3146709fc0ae310ac475a274"}, {"sha": "815abfdfd36180eab1826c480739a5546b6c4fd9", "filename": "gcc/config/mep/mep-ivc2.cpu", "status": "added", "additions": 9755, "deletions": 0, "changes": 9755, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7acf4da6f94801cb3146709fc0ae310ac475a274/gcc%2Fconfig%2Fmep%2Fmep-ivc2.cpu", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7acf4da6f94801cb3146709fc0ae310ac475a274/gcc%2Fconfig%2Fmep%2Fmep-ivc2.cpu", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmep%2Fmep-ivc2.cpu?ref=7acf4da6f94801cb3146709fc0ae310ac475a274"}, {"sha": "0a18913f927640cae1ce4aa4293b19b3dbd98300", "filename": "gcc/config/mep/mep-lib1.asm", "status": "added", "additions": 125, "deletions": 0, "changes": 125, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7acf4da6f94801cb3146709fc0ae310ac475a274/gcc%2Fconfig%2Fmep%2Fmep-lib1.asm", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7acf4da6f94801cb3146709fc0ae310ac475a274/gcc%2Fconfig%2Fmep%2Fmep-lib1.asm", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmep%2Fmep-lib1.asm?ref=7acf4da6f94801cb3146709fc0ae310ac475a274", "patch": "@@ -0,0 +1,125 @@\n+/* libgcc routines for Toshiba Media Processor.\n+   Copyright (C) 2001, 2002, 2005, 2009 Free Software Foundation, Inc.\n+\n+This file is free software; you can redistribute it and/or modify it\n+under the terms of the GNU General Public License as published by the\n+Free Software Foundation; either version 3 of the License, or (at your\n+option) any later version.\n+  \n+This file is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+  \n+Under Section 7 of GPL version 3, you are granted additional\n+permissions described in the GCC Runtime Library Exception, version\n+3.1, as published by the Free Software Foundation.\n+\n+You should have received a copy of the GNU General Public License and\n+a copy of the GCC Runtime Library Exception along with this program;\n+see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#define SAVEALL \\\n+\tadd3\t$sp, $sp, -16*4 ; \\\n+\tsw\t$0, ($sp) ; \\\n+\tsw\t$1, 4($sp) ; \\\n+\tsw\t$2, 8($sp) ; \\\n+\tsw\t$3, 12($sp) ; \\\n+\tsw\t$4, 16($sp) ; \\\n+\tsw\t$5, 20($sp) ; \\\n+\tsw\t$6, 24($sp) ; \\\n+\tsw\t$7, 28($sp) ; \\\n+\tsw\t$8, 32($sp) ; \\\n+\tsw\t$9, 36($sp) ; \\\n+\tsw\t$10, 40($sp) ; \\\n+\tsw\t$11, 44($sp) ; \\\n+\tsw\t$12, 48($sp) ; \\\n+\tsw\t$13, 52($sp) ; \\\n+\tsw\t$14, 56($sp) ; \\\n+\tldc\t$5, $lp\t; \\\n+\tadd\t$5, 3 ; \\\n+\tmov\t$6, -4 ; \\\n+\tand\t$5, $6\n+\n+#define RESTOREALL \\\n+\tstc\t$5, $lp ; \\\n+\tlw\t$14, 56($sp) ; \\\n+\tlw\t$13, 52($sp) ; \\\n+\tlw\t$12, 48($sp) ; \\\n+\tlw\t$11, 44($sp) ; \\\n+\tlw\t$10, 40($sp) ; \\\n+\tlw\t$9, 36($sp) ; \\\n+\tlw\t$8, 32($sp) ; \\\n+\tlw\t$7, 28($sp) ; \\\n+\tlw\t$6, 24($sp) ; \\\n+\tlw\t$5, 20($sp) ; \\\n+\tlw\t$4, 16($sp) ; \\\n+\tlw\t$3, 12($sp) ; \\\n+\tlw\t$2, 8($sp) ; \\\n+\tlw\t$1, 4($sp) ; \\\n+\tlw\t$0, ($sp) ; \\\n+\tadd3\t$sp, $sp, 16*4 ; \\\n+\tret\n+\n+#ifdef L_mep_profile\n+\t.text\n+\t.global __mep_mcount\n+__mep_mcount:\n+\tSAVEALL\n+\tldc\t$1, $lp\n+\tmov\t$2, $0\n+\tbsr\t__mep_mcount_2\n+\tRESTOREALL\n+#endif\n+\n+#ifdef L_mep_bb_init_trace\n+\t.text\n+\t.global __mep_bb_init_trace_func\n+__mep_bb_init_trace_func:\n+\tSAVEALL\n+\tlw\t$1, ($5)\n+\tlw\t$2, 4($5)\n+\tadd\t$5, 8\n+\tbsr\t__bb_init_trace_func\n+\tRESTOREALL\n+#endif\n+\n+#ifdef L_mep_bb_init\n+\t.text\n+\t.global __mep_bb_init_func\n+__mep_bb_init_func:\n+\tSAVEALL\n+\tlw\t$1, ($5)\n+\tadd\t$5, 4\n+\tbsr\t__bb_init_func\n+\tRESTOREALL\n+#endif\n+\n+#ifdef L_mep_bb_trace\n+\t.text\n+\t.global __mep_bb_trace_func\n+__mep_bb_trace_func:\n+\tSAVEALL\n+\tmovu\t$3, __bb\n+\tlw\t$1, ($5)\n+\tsw\t$1, ($3)\n+\tlw\t$2, 4($5)\n+\tsw\t$2, 4($3)\n+\tadd\t$5, 8\n+\tbsr\t__bb_trace_func\n+\tRESTOREALL\n+#endif\n+\n+#ifdef L_mep_bb_increment\n+\t.text\n+\t.global __mep_bb_increment_func\n+__mep_bb_increment_func:\n+\tSAVEALL\n+\tlw\t$1, ($5)\n+\tlw\t$0, ($1)\n+\tadd\t$0, 1\n+\tsw\t$0, ($1)\n+\tadd\t$5, 4\n+\tRESTOREALL\n+#endif"}, {"sha": "1dbf57d953581b793479c47e79932fb97b908ac7", "filename": "gcc/config/mep/mep-lib2.c", "status": "added", "additions": 139, "deletions": 0, "changes": 139, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7acf4da6f94801cb3146709fc0ae310ac475a274/gcc%2Fconfig%2Fmep%2Fmep-lib2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7acf4da6f94801cb3146709fc0ae310ac475a274/gcc%2Fconfig%2Fmep%2Fmep-lib2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmep%2Fmep-lib2.c?ref=7acf4da6f94801cb3146709fc0ae310ac475a274", "patch": "@@ -0,0 +1,139 @@\n+/* libgcc routines for MeP.\n+   Copyright 2001, 2002, 2009 Free Software Foundation, Inc\n+\n+This file is free software; you can redistribute it and/or modify it\n+under the terms of the GNU General Public License as published by the\n+Free Software Foundation; either version 3 of the License, or (at your\n+option) any later version.\n+  \n+This file is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+  \n+Under Section 7 of GPL version 3, you are granted additional\n+permissions described in the GCC Runtime Library Exception, version\n+3.1, as published by the Free Software Foundation.\n+\n+You should have received a copy of the GNU General Public License and\n+a copy of the GCC Runtime Library Exception along with this program;\n+see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+<http://www.gnu.org/licenses/>.  */\n+\n+typedef\t\t int SItype\t\t__attribute__ ((mode (SI)));\n+typedef unsigned int USItype\t\t__attribute__ ((mode (SI)));\n+\n+typedef int word_type\t\t\t__attribute__ ((mode (__word__)));\n+\n+USItype\n+__mulsi3 (USItype a, USItype b)\n+{\n+  USItype c = 0;\n+\n+  while (a != 0)\n+    {\n+      if (a & 1)\n+\tc += b;\n+      a >>= 1;\n+      b <<= 1;\n+    }\n+\n+  return c;\n+}\n+\n+\n+\n+USItype\n+udivmodsi4(USItype num, USItype den, word_type modwanted)\n+{\n+  USItype bit = 1;\n+  USItype res = 0;\n+\n+  while (den < num && bit && !(den & (1L<<31)))\n+    {\n+      den <<=1;\n+      bit <<=1;\n+    }\n+  while (bit)\n+    {\n+      if (num >= den)\n+\t{\n+\t  num -= den;\n+\t  res |= bit;\n+\t}\n+      bit >>=1;\n+      den >>=1;\n+    }\n+  if (modwanted) return num;\n+  return res;\n+}\n+\n+\n+\n+SItype\n+__divsi3 (SItype a, SItype b)\n+{\n+  word_type neg = 0;\n+  SItype res;\n+\n+  if (a < 0)\n+    {\n+      a = -a;\n+      neg = !neg;\n+    }\n+\n+  if (b < 0)\n+    {\n+      b = -b;\n+      neg = !neg;\n+    }\n+\n+  res = udivmodsi4 (a, b, 0);\n+\n+  if (neg)\n+    res = -res;\n+\n+  return res;\n+}\n+\n+\n+\n+SItype\n+__modsi3 (SItype a, SItype b)\n+{\n+  word_type neg = 0;\n+  SItype res;\n+\n+  if (a < 0)\n+    {\n+      a = -a;\n+      neg = 1;\n+    }\n+\n+  if (b < 0)\n+    b = -b;\n+\n+  res = udivmodsi4 (a, b, 1);\n+\n+  if (neg)\n+    res = -res;\n+\n+  return res;\n+}\n+\n+\n+\n+\n+SItype\n+__udivsi3 (SItype a, SItype b)\n+{\n+  return udivmodsi4 (a, b, 0);\n+}\n+\n+\n+\n+SItype\n+__umodsi3 (SItype a, SItype b)\n+{\n+  return udivmodsi4 (a, b, 1);\n+}"}, {"sha": "3f9fc5a70715607f71519f0031956d9adeba0244", "filename": "gcc/config/mep/mep-pragma.c", "status": "added", "additions": 384, "deletions": 0, "changes": 384, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7acf4da6f94801cb3146709fc0ae310ac475a274/gcc%2Fconfig%2Fmep%2Fmep-pragma.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7acf4da6f94801cb3146709fc0ae310ac475a274/gcc%2Fconfig%2Fmep%2Fmep-pragma.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmep%2Fmep-pragma.c?ref=7acf4da6f94801cb3146709fc0ae310ac475a274", "patch": "@@ -0,0 +1,384 @@\n+/* Definitions of Toshiba Media Processor\n+   Copyright (C) 2001, 2002, 2003, 2005, 2006, 2007, 2009 Free\n+   Software Foundation, Inc.  Contributed by Red Hat, Inc.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it under\n+the terms of the GNU General Public License as published by the Free\n+Software Foundation; either version 3, or (at your option) any later\n+version.\n+\n+GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING3.  If not see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#include <stdio.h>\n+#include \"config.h\"\n+#include \"system.h\"\n+#include \"coretypes.h\"\n+#include \"tm.h\"\n+#include \"tree.h\"\n+#include \"rtl.h\"\n+#include \"toplev.h\"\n+#include \"c-pragma.h\"\n+#include \"cpplib.h\"\n+#include \"hard-reg-set.h\"\n+#include \"output.h\"\n+#include \"mep-protos.h\"\n+#include \"function.h\"\n+#define MAX_RECOG_OPERANDS 10\n+#include \"reload.h\"\n+#include \"target.h\"\n+\n+enum cw_which { CW_AVAILABLE, CW_CALL_SAVED };\n+\n+static enum cpp_ttype\n+mep_pragma_lex (tree *valp)\n+{\n+  enum cpp_ttype t = pragma_lex (valp);\n+  if (t == CPP_EOF)\n+    t = CPP_PRAGMA_EOL;\n+  return t;\n+}\n+\n+static void\n+mep_pragma_io_volatile (cpp_reader *reader ATTRIBUTE_UNUSED)\n+{\n+  /* On off.  */\n+  tree val;\n+  enum cpp_ttype type;\n+  const char * str;\n+\n+  type = mep_pragma_lex (&val);\n+  if (type == CPP_NAME)\n+    {\n+      str = IDENTIFIER_POINTER (val);\n+\n+      type = mep_pragma_lex (&val);\n+      if (type != CPP_PRAGMA_EOL)\n+\twarning (0, \"junk at end of #pragma io_volatile\");\n+\n+      if (strcmp (str, \"on\") == 0)\n+\t{\n+\t  target_flags |= MASK_IO_VOLATILE;\n+\t  return;\n+\t}\n+      if (strcmp (str, \"off\") == 0)\n+\t{\n+\t  target_flags &= ~ MASK_IO_VOLATILE;\n+\t  return;\n+\t}\n+    }\n+\n+  error (\"#pragma io_volatile takes only on or off\");\n+}\n+\n+static unsigned int\n+parse_cr_reg (const char * str)\n+{\n+  unsigned int regno;\n+\n+  regno = decode_reg_name (str);\n+  if (regno >= FIRST_PSEUDO_REGISTER)\n+    return INVALID_REGNUM;\n+\n+  /* Verify that the regno is in CR_REGS.  */\n+  if (! TEST_HARD_REG_BIT (reg_class_contents[CR_REGS], regno))\n+    return INVALID_REGNUM;\n+  return regno;\n+}\n+\n+static bool\n+parse_cr_set (HARD_REG_SET * set)\n+{\n+  tree val;\n+  enum cpp_ttype type;\n+  unsigned int last_regno = INVALID_REGNUM;\n+  bool do_range = false;\n+\n+  CLEAR_HARD_REG_SET (*set);\n+\n+  while ((type = mep_pragma_lex (&val)) != CPP_PRAGMA_EOL)\n+    {\n+      if (type == CPP_COMMA)\n+\t{\n+\t  last_regno = INVALID_REGNUM;\n+\t  do_range = false;\n+\t}\n+      else if (type == CPP_ELLIPSIS)\n+\t{\n+\t  if (last_regno == INVALID_REGNUM)\n+\t    {\n+\t      error (\"invalid coprocessor register range\");\n+\t      return false;\n+\t    }\n+\t  do_range = true;\n+\t}\n+      else if (type == CPP_NAME || type == CPP_STRING)\n+\t{\n+\t  const char *str;\n+\t  unsigned int regno, i;\n+\n+\t  if (TREE_CODE (val) == IDENTIFIER_NODE)\n+\t    str = IDENTIFIER_POINTER (val);\n+  \t  else if (TREE_CODE (val) == STRING_CST)\n+\t    str = TREE_STRING_POINTER (val);\n+\t  else\n+\t    gcc_unreachable ();\n+\n+\t  regno = parse_cr_reg (str);\n+\t  if (regno == INVALID_REGNUM)\n+\t    {\n+\t      error (\"invalid coprocessor register %qE\", val);\n+\t      return false;\n+\t    }\n+\n+\t  if (do_range)\n+\t    {\n+\t      if (last_regno > regno)\n+\t\ti = regno, regno = last_regno;\n+\t      else\n+\t\ti = last_regno;\n+\t      do_range = false;\n+\t    }\n+\t  else\n+\t    last_regno = i = regno;\n+\n+\t  while (i <= regno)\n+\t    {\n+\t      SET_HARD_REG_BIT (*set, i);\n+\t      i++;\n+\t    }\n+\t}\n+      else\n+\t{\n+\t  error (\"malformed coprocessor register\");\n+\t  return false;\n+\t}\n+    }\n+  return true;\n+}\n+\n+static void\n+mep_pragma_coprocessor_which (enum cw_which cw_which)\n+{\n+  HARD_REG_SET set;\n+\n+  /* Process the balance of the pragma and turn it into a hard reg set.  */\n+  if (! parse_cr_set (&set))\n+    return;\n+\n+  /* Process the collected hard reg set.  */\n+  switch (cw_which)\n+    {\n+    case CW_AVAILABLE:\n+      {\n+\tint i;\n+\tfor (i = 0; i < FIRST_PSEUDO_REGISTER; ++i)\n+\t  if (TEST_HARD_REG_BIT (set, i))\n+\t    fixed_regs[i] = 0;\n+      }\n+      break;\n+\n+    case CW_CALL_SAVED:\n+      {\n+\tint i;\n+\tfor (i = 0; i < FIRST_PSEUDO_REGISTER; ++i)\n+\t  if (TEST_HARD_REG_BIT (set, i))\n+\t    fixed_regs[i] = call_used_regs[i] = 0;\n+      }\n+      break;\n+\n+    default:\n+      gcc_unreachable ();\n+    }\n+\n+  /* Fix up register class hierarchy.  */\n+  save_register_info ();\n+  reinit_regs ();\n+\n+  if (cfun == 0)\n+    {\n+      init_dummy_function_start ();\n+      init_caller_save ();\n+      expand_dummy_function_end ();\n+    }\n+  else\n+    {\n+      init_caller_save ();\n+    }\n+}\n+\n+static void\n+mep_pragma_coprocessor_width (void)\n+{\n+  tree val;\n+  enum cpp_ttype type;\n+  HOST_WIDE_INT i;\n+\n+  type = mep_pragma_lex (&val);\n+  switch (type)\n+    {\n+    case CPP_NUMBER:\n+      if (! host_integerp (val, 1))\n+\tbreak;\n+      i = tree_low_cst (val, 1);\n+      /* This pragma no longer has any effect.  */\n+#if 0\n+      if (i == 32)\n+\ttarget_flags &= ~MASK_64BIT_CR_REGS;\n+      else if (i == 64)\n+\ttarget_flags |= MASK_64BIT_CR_REGS;\n+      else\n+\tbreak;\n+      targetm.init_builtins ();\n+#else\n+      if (i != 32 && i != 64)\n+\tbreak;\n+#endif\n+\n+      type = mep_pragma_lex (&val);\n+      if (type != CPP_PRAGMA_EOL)\n+\twarning (0, \"junk at end of #pragma GCC coprocessor width\");\n+      return;\n+\n+    default:\n+      break;\n+    }\n+\n+  error (\"#pragma GCC coprocessor width takes only 32 or 64\");\n+}\n+\n+static void\n+mep_pragma_coprocessor_subclass (void)\n+{\n+  tree val;\n+  enum cpp_ttype type;\n+  HARD_REG_SET set;\n+  int class_letter;\n+  enum reg_class class;\n+\n+  type = mep_pragma_lex (&val);\n+  if (type != CPP_CHAR)\n+    goto syntax_error;\n+  class_letter = tree_low_cst (val, 1);\n+  if (class_letter >= 'A' && class_letter <= 'D')\n+    class = class_letter - 'A' + USER0_REGS;\n+  else\n+    {\n+      error (\"#pragma GCC coprocessor subclass letter must be in [ABCD]\");\n+      return;\n+    }\n+  if (reg_class_size[class] > 0)\n+    {\n+      error (\"#pragma GCC coprocessor subclass '%c' already defined\",\n+\t     class_letter);\n+      return;\n+    }\n+\n+  type = mep_pragma_lex (&val);\n+  if (type != CPP_EQ)\n+    goto syntax_error;\n+\n+  if (! parse_cr_set (&set))\n+    return;\n+\n+  /* Fix up register class hierarchy.  */\n+  COPY_HARD_REG_SET (reg_class_contents[class], set);\n+  init_regs ();\n+  return;\n+\n+ syntax_error:\n+  error (\"malformed #pragma GCC coprocessor subclass\");\n+}\n+\n+static void\n+mep_pragma_disinterrupt (cpp_reader *reader ATTRIBUTE_UNUSED)\n+{\n+  tree val;\n+  enum cpp_ttype type;\n+  int saw_one = 0;\n+\n+  for (;;)\n+    {\n+      type = mep_pragma_lex (&val);\n+      if (type == CPP_COMMA)\n+\tcontinue;\n+      if (type != CPP_NAME)\n+\tbreak;\n+      mep_note_pragma_disinterrupt (IDENTIFIER_POINTER (val));\n+      saw_one = 1;\n+    }\n+  if (!saw_one || type != CPP_PRAGMA_EOL)\n+    {\n+      error (\"malformed #pragma disinterrupt\");\n+      return;\n+    }\n+}\n+\n+static void\n+mep_pragma_coprocessor (cpp_reader *reader ATTRIBUTE_UNUSED)\n+{\n+  tree val;\n+  enum cpp_ttype type;\n+\n+  type = mep_pragma_lex (&val);\n+  if (type != CPP_NAME)\n+    {\n+      error (\"malformed #pragma GCC coprocessor\");\n+      return;\n+    }\n+\n+  if (!TARGET_COP)\n+    error (\"coprocessor not enabled\");\n+\n+  if (strcmp (IDENTIFIER_POINTER (val), \"available\") == 0)\n+    mep_pragma_coprocessor_which (CW_AVAILABLE);\n+  else if (strcmp (IDENTIFIER_POINTER (val), \"call_saved\") == 0)\n+    mep_pragma_coprocessor_which (CW_CALL_SAVED);\n+  else if (strcmp (IDENTIFIER_POINTER (val), \"width\") == 0)\n+    mep_pragma_coprocessor_width ();\n+  else if (strcmp (IDENTIFIER_POINTER (val), \"subclass\") == 0)\n+    mep_pragma_coprocessor_subclass ();\n+  else\n+    error (\"unknown #pragma GCC coprocessor %E\", val);\n+}\n+\n+static void\n+mep_pragma_call (cpp_reader *reader ATTRIBUTE_UNUSED)\n+{\n+  tree val;\n+  enum cpp_ttype type;\n+  int saw_one = 0;\n+\n+  for (;;)\n+    {\n+      type = mep_pragma_lex (&val);\n+      if (type == CPP_COMMA)\n+\tcontinue;\n+      if (type != CPP_NAME)\n+\tbreak;\n+      mep_note_pragma_call (IDENTIFIER_POINTER (val));\n+      saw_one = 1;\n+    }\n+  if (!saw_one || type != CPP_PRAGMA_EOL)\n+    {\n+      error (\"malformed #pragma call\");\n+      return;\n+    }\n+}\n+\n+void\n+mep_register_pragmas (void)\n+{\n+  c_register_pragma (\"custom\", \"io_volatile\", mep_pragma_io_volatile);\n+  c_register_pragma (\"GCC\", \"coprocessor\", mep_pragma_coprocessor);\n+  c_register_pragma (0, \"disinterrupt\", mep_pragma_disinterrupt);\n+  c_register_pragma (0, \"call\", mep_pragma_call);\n+}"}, {"sha": "eb37702ddf40a42aad133eef07042c52925441d8", "filename": "gcc/config/mep/mep-protos.h", "status": "added", "additions": 131, "deletions": 0, "changes": 131, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7acf4da6f94801cb3146709fc0ae310ac475a274/gcc%2Fconfig%2Fmep%2Fmep-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7acf4da6f94801cb3146709fc0ae310ac475a274/gcc%2Fconfig%2Fmep%2Fmep-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmep%2Fmep-protos.h?ref=7acf4da6f94801cb3146709fc0ae310ac475a274", "patch": "@@ -0,0 +1,131 @@\n+/* Prototypes for exported functions defined in mep.c\n+   Copyright (C) 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2009 Free\n+   Software Foundation, Inc.\n+   Contributed by Red Hat Inc (dj@redhat.com)\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it under\n+the terms of the GNU General Public License as published by the Free\n+Software Foundation; either version 3, or (at your option) any later\n+version.\n+\n+GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING3.  If not see\n+<http://www.gnu.org/licenses/>.  */\n+\n+extern void mep_conditional_register_usage (char *, char *);\n+extern void mep_optimization_options (void);\n+extern void mep_override_options (void);\n+extern int mep_regno_reg_class (int);\n+extern int mep_reg_class_from_constraint (int, const char *);\n+extern bool mep_const_ok_for_letter_p (HOST_WIDE_INT, int);\n+extern bool mep_extra_constraint (rtx, int);\n+extern rtx mep_mulr_source (rtx, rtx, rtx, rtx);\n+extern bool mep_reuse_lo_p (rtx, rtx, rtx, bool);\n+extern bool mep_use_post_modify_p (rtx, rtx, rtx);\n+extern bool mep_allow_clip (rtx, rtx, int);\n+extern bool mep_bit_position_p (rtx, bool);\n+extern bool mep_split_mov (rtx *, int);\n+extern bool mep_vliw_mode_match (rtx);\n+extern bool mep_multi_slot (rtx);\n+extern bool mep_legitimate_address (enum machine_mode, rtx, int);\n+extern int mep_legitimize_address (rtx *, rtx, enum machine_mode);\n+#ifdef MAX_RELOADS\n+extern int mep_legitimize_reload_address (rtx *, enum machine_mode, int, enum reload_type, int);\n+#endif\n+extern int mep_core_address_length (rtx, int);\n+extern int mep_cop_address_length (rtx, int);\n+extern bool mep_expand_mov (rtx *, enum machine_mode);\n+extern bool mep_mov_ok (rtx *, enum machine_mode);\n+extern void mep_split_wide_move (rtx *, enum machine_mode);\n+#ifdef RTX_CODE\n+extern bool mep_expand_setcc (rtx *);\n+extern rtx mep_expand_cbranch (rtx *);\n+#endif\n+extern const char *mep_emit_cbranch (rtx *, int);\n+extern void mep_expand_call (rtx *, int);\n+extern rtx mep_find_base_term (rtx);\n+extern int mep_secondary_input_reload_class (enum reg_class, enum machine_mode, rtx);\n+extern int mep_secondary_output_reload_class (enum reg_class, enum machine_mode, rtx);\n+extern bool mep_secondary_memory_needed (enum reg_class, enum reg_class,\n+\t\t\t\t\t enum machine_mode);\n+extern void mep_expand_reload (rtx *, enum machine_mode);\n+extern enum reg_class mep_preferred_reload_class (rtx, enum reg_class);\n+extern int mep_register_move_cost (enum machine_mode, enum reg_class, enum reg_class);\n+extern void mep_init_expanders (void);\n+extern rtx mep_return_addr_rtx (int);\n+extern bool mep_epilogue_uses (int);\n+extern int mep_elimination_offset (int, int);\n+extern void mep_expand_prologue (void);\n+extern void mep_expand_epilogue (void);\n+extern void mep_expand_eh_return (rtx *);\n+extern void mep_emit_eh_epilogue (rtx *);\n+extern void mep_expand_sibcall_epilogue (void);\n+extern rtx mep_return_stackadj_rtx (void);\n+extern rtx mep_return_handler_rtx (void);\n+extern void mep_function_profiler (FILE *);\n+extern const char *mep_emit_bb_trace_ret (void);\n+extern void mep_print_operand_address (FILE *, rtx);\n+extern void mep_print_operand (FILE *, rtx, int);\n+extern void mep_final_prescan_insn (rtx, rtx *, int);\n+extern void mep_init_cumulative_args (CUMULATIVE_ARGS *, tree, rtx, tree);\n+extern rtx mep_function_arg (CUMULATIVE_ARGS, enum machine_mode, tree, int);\n+extern void mep_arg_advance (CUMULATIVE_ARGS *, enum machine_mode, tree, int);\n+extern bool mep_return_in_memory (const_tree, const_tree);\n+extern rtx mep_function_value (tree, tree);\n+extern rtx mep_libcall_value (enum machine_mode);\n+extern void mep_asm_output_opcode (FILE *, const char *);\n+extern void mep_note_pragma_disinterrupt (const char *);\n+extern void mep_note_pragma_call (const char *);\n+extern void mep_file_cleanups (void);\n+extern const char *mep_strip_name_encoding (const char *);\n+extern void mep_output_aligned_common (FILE *, tree, const char *,\n+\t\t\t\t       int, int, int);\n+extern void mep_init_trampoline (rtx, rtx, rtx);\n+extern void mep_emit_doloop (rtx *, int);\n+extern bool mep_vliw_function_p (tree);\n+extern bool mep_store_data_bypass_p (rtx, rtx);\n+extern bool mep_mul_hilo_bypass_p (rtx, rtx);\n+extern bool mep_ipipe_ldc_p (rtx);\n+extern bool mep_emit_intrinsic (int, const rtx *);\n+extern bool mep_expand_unary_intrinsic (int, rtx *);\n+extern bool mep_expand_binary_intrinsic (int, int, int, int, rtx *);\n+extern int mep_intrinsic_length (int);\n+\n+extern void mep_register_pragmas (void);\n+extern int mep_section_tag (rtx);\n+extern bool mep_lookup_pragma_call (const char *);\n+extern bool mep_have_core_copro_moves_p;\n+extern bool mep_have_copro_copro_moves_p;\n+\n+extern bool mep_cannot_change_mode_class (enum machine_mode, enum machine_mode,\n+\t\t\t\t\t  enum reg_class);\n+\n+extern int cgen_h_uint_6a1_immediate (rtx, enum machine_mode);\n+extern int cgen_h_uint_7a1_immediate (rtx, enum machine_mode);\n+extern int cgen_h_uint_8a1_immediate (rtx, enum machine_mode);\n+extern int cgen_h_uint_6a2_immediate (rtx, enum machine_mode);\n+extern int cgen_h_uint_22a4_immediate (rtx, enum machine_mode);\n+extern int cgen_h_sint_2a1_immediate (rtx, enum machine_mode);\n+extern int cgen_h_uint_24a1_immediate (rtx, enum machine_mode);\n+extern int cgen_h_sint_6a1_immediate (rtx, enum machine_mode);\n+extern int cgen_h_uint_5a4_immediate (rtx, enum machine_mode);\n+extern int cgen_h_uint_2a1_immediate (rtx, enum machine_mode);\n+extern int cgen_h_uint_16a1_immediate (rtx, enum machine_mode);\n+extern int cgen_h_uint_3a1_immediate (rtx, enum machine_mode);\n+extern int cgen_h_uint_5a1_immediate (rtx, enum machine_mode);\n+extern int cgen_h_sint_16a1_immediate (rtx, enum machine_mode);\n+extern int cgen_h_sint_8a1_immediate (rtx, enum machine_mode);\n+extern int cgen_h_sint_7a2_immediate (rtx, enum machine_mode);\n+extern int cgen_h_sint_6a4_immediate (rtx, enum machine_mode);\n+extern int cgen_h_sint_5a8_immediate (rtx, enum machine_mode);\n+extern int cgen_h_uint_4a1_immediate (rtx, enum machine_mode);\n+extern int cgen_h_sint_10a1_immediate (rtx, enum machine_mode);\n+extern int cgen_h_sint_12a1_immediate (rtx, enum machine_mode);\n+extern int cgen_h_uint_20a1_immediate (rtx, enum machine_mode);"}, {"sha": "bf484ca4e95178112acdf0c828c56ad27045b02d", "filename": "gcc/config/mep/mep-tramp.c", "status": "added", "additions": 103, "deletions": 0, "changes": 103, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7acf4da6f94801cb3146709fc0ae310ac475a274/gcc%2Fconfig%2Fmep%2Fmep-tramp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7acf4da6f94801cb3146709fc0ae310ac475a274/gcc%2Fconfig%2Fmep%2Fmep-tramp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmep%2Fmep-tramp.c?ref=7acf4da6f94801cb3146709fc0ae310ac475a274", "patch": "@@ -0,0 +1,103 @@\n+/* Trampoline support for MeP\n+   Copyright (C) 2004, 2007 Free Software Foundation, Inc.\n+   Contributed by Red Hat Inc.\n+\n+This file is free software; you can redistribute it and/or modify it\n+under the terms of the GNU General Public License as published by the\n+Free Software Foundation; either version 3 of the License, or (at your\n+option) any later version.\n+  \n+This file is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+  \n+Under Section 7 of GPL version 3, you are granted additional\n+permissions described in the GCC Runtime Library Exception, version\n+3.1, as published by the Free Software Foundation.\n+\n+You should have received a copy of the GNU General Public License and\n+a copy of the GCC Runtime Library Exception along with this program;\n+see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+<http://www.gnu.org/licenses/>.  */\n+\n+/*\n+  7a0a\t\tldc $10,$pc\n+  c0ae000a\tlw $0,10($10)\n+  caae000e\tlw $10,14($10)\n+  10ae\t\tjmp $10\n+  00000000\tstatic chain\n+  00000000\tfunction address\n+*/\n+\n+static inline int\n+cache_config_register(void) {\n+  int rv;\n+  asm (\"ldc\\t%0, $ccfg\" : \"=r\" (rv));\n+  return rv;\n+}\n+\n+#define ICACHE_SIZE ((cache_config_register() >> 16) & 0x7f)\n+#define DCACHE_SIZE (cache_config_register() & 0x7f)\n+\n+#define ICACHE_DATA_BASE 0x00300000\n+#define ICACHE_TAG_BASE  0x00310000\n+#define DCACHE_DATA_BASE 0x00320000\n+#define DCACHE_TAG_BASE  0x00330000\n+\n+static inline void\n+flush_dcache (int addr)\n+{\n+  asm volatile (\"cache\\t0, (%0)\" : : \"r\" (addr));\n+}\n+\n+void\n+__mep_trampoline_helper (unsigned long *tramp,\n+\t\t\t int function_address,\n+\t\t\t int static_chain);\n+\n+void\n+__mep_trampoline_helper (unsigned long *tramp,\n+\t\t\t int function_address,\n+\t\t\t int static_chain)\n+{\n+  int dsize, isize;\n+\n+#ifdef __LITTLE_ENDIAN__\n+  tramp[0] = 0xc0ae7a0a;\n+  tramp[1] = 0xcaae000a;\n+  tramp[2] = 0x10ae000e;\n+#else\n+  tramp[0] = 0x7a0ac0ae;\n+  tramp[1] = 0x000acaae;\n+  tramp[2] = 0x000e10ae;\n+#endif\n+  tramp[3] = static_chain;\n+  tramp[4] = function_address;\n+\n+  dsize = DCACHE_SIZE;\n+  isize = ICACHE_SIZE;\n+\n+  if (dsize)\n+    {\n+      flush_dcache ((int)tramp);\n+      flush_dcache ((int)tramp+16);\n+    }\n+\n+  if (isize)\n+    {\n+      int imask = (isize * 1024) - 1;\n+      int tmask = ~imask;\n+      unsigned int i;\n+      volatile unsigned int *tags;\n+\n+      imask &= 0xffe0;\n+\n+      for (i=(unsigned int)tramp; i<(unsigned int)tramp+20; i+=16)\n+\t{\n+\t  tags = (unsigned int *)(ICACHE_TAG_BASE + (i & imask));\n+\t  if ((*tags & tmask) == (i & tmask))\n+\t    *tags &= ~1;\n+\t}\n+    }\n+}"}, {"sha": "0ecfce278228d69c62749576095b17148e6cffc7", "filename": "gcc/config/mep/mep.c", "status": "added", "additions": 7311, "deletions": 0, "changes": 7311, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7acf4da6f94801cb3146709fc0ae310ac475a274/gcc%2Fconfig%2Fmep%2Fmep.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7acf4da6f94801cb3146709fc0ae310ac475a274/gcc%2Fconfig%2Fmep%2Fmep.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmep%2Fmep.c?ref=7acf4da6f94801cb3146709fc0ae310ac475a274"}, {"sha": "374e5b1e66d516c51f04b432e2c19ba56b7d2bda", "filename": "gcc/config/mep/mep.cpu", "status": "added", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7acf4da6f94801cb3146709fc0ae310ac475a274/gcc%2Fconfig%2Fmep%2Fmep.cpu", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7acf4da6f94801cb3146709fc0ae310ac475a274/gcc%2Fconfig%2Fmep%2Fmep.cpu", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmep%2Fmep.cpu?ref=7acf4da6f94801cb3146709fc0ae310ac475a274", "patch": "@@ -0,0 +1 @@\n+(include \"mep-default.cpu\")"}, {"sha": "511abfcfc2dca88d2820c65906e2a51c660697b5", "filename": "gcc/config/mep/mep.h", "status": "added", "additions": 860, "deletions": 0, "changes": 860, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7acf4da6f94801cb3146709fc0ae310ac475a274/gcc%2Fconfig%2Fmep%2Fmep.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7acf4da6f94801cb3146709fc0ae310ac475a274/gcc%2Fconfig%2Fmep%2Fmep.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmep%2Fmep.h?ref=7acf4da6f94801cb3146709fc0ae310ac475a274", "patch": "@@ -0,0 +1,860 @@\n+/* Definitions for Toshiba Media Processor\n+   Copyright (C) 2001, 2003, 2004, 2005, 2007, 2008, 2009\n+   Free Software Foundation, Inc.\n+   Contributed by Red Hat, Inc.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it under\n+the terms of the GNU General Public License as published by the Free\n+Software Foundation; either version 3, or (at your option) any later\n+version.\n+\n+GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING3.  If not see\n+<http://www.gnu.org/licenses/>.  */\n+\f\n+\n+#undef  CPP_SPEC\n+#define CPP_SPEC \"\\\n+-D__MEP__ -D__MeP__ \\\n+-D__section(_x)=__attribute__((section(_x))) \\\n+-D__align(_x)=__attribute__((aligned(_x))) \\\n+-D__io(_x)=__attribute__((io(_x))) \\\n+-D__cb(_x)=__attribute__((cb(_x))) \\\n+-D__based=__attribute__((based)) \\\n+-D__tiny=__attribute__((tiny)) \\\n+-D__near=__attribute__((near)) \\\n+-D__far=__attribute__((far)) \\\n+-D__vliw=__attribute__((vliw)) \\\n+-D__interrupt=__attribute__((interrupt)) \\\n+-D__disinterrupt=__attribute__((disinterrupt)) \\\n+-D__cop=__attribute__((cop)) \\\n+%{!meb:%{!mel:-D__BIG_ENDIAN__}} \\\n+%{meb:-U__LITTLE_ENDIAN__ -D__BIG_ENDIAN__} \\\n+%{mel:-U__BIG_ENDIAN__ -D__LITTLE_ENDIAN__} \\\n+%{mconfig=*:-D__MEP_CONFIG_%*} \\\n+%{mivc2:-D__MEP_CONFIG_CP_DATA_BUS_WIDTH=64} \\\n+\"\n+\n+#undef  CC1_SPEC\n+#define CC1_SPEC \"%{!mlibrary:%(config_cc_spec)} \\\n+%{!.cc:%{O2:%{!funroll*:--param max-completely-peeled-insns=10 \\\n+                        --param max-unrolled-insns=10 -funroll-loops}}}\"\n+\n+#undef  CC1PLUS_SPEC\n+#define CC1PLUS_SPEC \"%{!mlibrary:%(config_cc_spec)}\"\n+\n+#undef  ASM_SPEC\n+#define ASM_SPEC \"%{mconfig=*} %{meb:-EB} %{mel:-EL} \\\n+%{mno-satur} %{msatur} %{mno-clip} %{mclip} %{mno-minmax} %{mminmax} \\\n+%{mno-absdiff} %{mabsdiff} %{mno-leadz} %{mleadz} %{mno-bitops} %{mbitops} \\\n+%{mno-div} %{mdiv} %{mno-mult} %{mmult} %{mno-average} %{maverage} \\\n+%{mcop32} %{mno-debug} %{mdebug} %{mlibrary}\"\n+\n+/* The MeP config tool will edit this spec.  */\n+#undef  STARTFILE_SPEC\n+#define STARTFILE_SPEC \"%{msdram:%{msim:simsdram-crt0.o%s}} \\\n+%{mno-sdram:%{msim:sim-crt0.o%s}} \\\n+%{msdram:%{!msim*:sdram-crt0.o%s}} \\\n+%{mno-sdram:%{!msim*:crt0.o%s}} \\\n+%(config_start_spec) \\\n+%{msimnovec:simnovec-crt0.o%s} \\\n+crtbegin.o%s\"\n+\n+#undef  LIB_SPEC\n+#define LIB_SPEC \"-( -lc %{msim*:-lsim}%{!msim*:-lnosys} -) %(config_link_spec)\"\n+\n+#undef  LINK_SPEC\n+#define LINK_SPEC \"%{meb:-EB} %{mel:-EL}\"\n+\n+#undef  ENDFILE_SPEC\n+#define ENDFILE_SPEC \"crtend.o%s %{msim*:sim-crtn.o%s}%{!msim*:crtn.o%s}\"\n+\n+/* The MeP config tool will edit this spec.  */\n+#define CONFIG_CC_SPEC \"\\\n+%{mconfig=default: -mbitops -mleadz -mabsdiff -maverage -mminmax -mclip -msatur -mvl64 -mvliw -mcop64 -D__MEP_CONFIG_CP_DATA_BUS_WIDTH=64 -mivc2}\\\n+\"\n+/* end-config-cc-spec */\n+\n+/* The MeP config tool will edit this spec.  */\n+#define CONFIG_LINK_SPEC \"\\\n+%{mconfig=default: %{!T*:-Tdefault.ld}}\\\n+\"\n+/* end-config-link-spec */\n+\n+/* The MeP config tool will edit this spec.  */\n+#define CONFIG_START_SPEC \"\\\n+%{!msdram:%{!mno-sdram:%{!msim*:crt0.o%s}}} \\\n+%{!msdram:%{!mno-sdram:%{msim:sim-crt0.o%s}}} \\\n+\"\n+/* end-config-start-spec */\n+\n+#define EXTRA_SPECS \\\n+  { \"config_cc_spec\",  CONFIG_CC_SPEC }, \\\n+  { \"config_link_spec\",  CONFIG_LINK_SPEC }, \\\n+  { \"config_start_spec\",  CONFIG_START_SPEC },\n+\f\n+\n+#define TARGET_CPU_CPP_BUILTINS() \t\t\\\n+  do\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\\\n+      builtin_define_std (\"mep\");\t\t\\\n+      builtin_assert (\"machine=mep\");\t\t\\\n+    }\t\t\t\t\t\t\\\n+  while (0)\n+\n+extern int target_flags;\n+\n+/* Controlled by MeP-Integrator.  */\n+#define TARGET_H1\t\t0\n+\n+#define MEP_ALL_OPTS\t(MASK_OPT_AVERAGE\t\\\n+\t\t\t | MASK_OPT_MULT\t\\\n+\t\t\t | MASK_OPT_DIV\t\t\\\n+\t\t\t | MASK_OPT_BITOPS\t\\\n+\t\t\t | MASK_OPT_LEADZ\t\\\n+\t\t\t | MASK_OPT_ABSDIFF\t\\\n+\t\t\t | MASK_OPT_MINMAX\t\\\n+\t\t\t | MASK_OPT_CLIP\t\\\n+\t\t\t | MASK_OPT_SATUR )\n+\n+#define TARGET_DEFAULT\t\t(MASK_IO_VOLATILE | MASK_OPT_REPEAT | MEP_ALL_OPTS | MASK_LITTLE_ENDIAN)\n+\n+#define TARGET_IO_NO_VOLATILE\t(! (target_flags & MASK_IO_VOLATILE))\n+#define TARGET_OPT_NOREPEAT\t(! (target_flags & MASK_OPT_REPEAT))\n+#define TARGET_32BIT_CR_REGS\t(! (target_flags & MASK_64BIT_CR_REGS))\n+#define TARGET_BIG_ENDIAN\t(! (target_flags & MASK_LITTLE_ENDIAN))\n+\n+#define TARGET_COPRO_MULT\t0\n+\n+#define TARGET_VERSION fprintf (stderr, \" (Toshiba Media Processor (MeP))\");\n+\n+#define OVERRIDE_OPTIONS mep_override_options ();\n+\n+/* The MeP config tool will add TARGET_OPTION_TRANSLATE_TABLE here.  */\n+#define TARGET_OPTION_TRANSLATE_TABLE \\\n+  {\"-mall-opts\", \"-maverage -mmult -mdiv -mbitops -mleadz \\\n+                  -mabsdiff -mminmax -mclip -msatur -mdebug\" }, \\\n+  {\"-mno-opts\", \"-mno-average -mno-mult -mno-div -mno-bitops -mno-leadz \\\n+                  -mno-absdiff -mno-minmax -mno-clip -mno-satur -mno-debug\" }, \\\n+  {\"-mfar\", \"-ml -mtf -mc=far\" } \\\n+/* start-target-option-table */ \\\n+, {\"-mconfig=default\", \"-mconfig=default -mmult -mdiv -D__MEP_CONFIG_ISA=1\" } \\\n+/* end-target-option-table */\n+\n+/* The MeP config tool will replace this as appropriate.  */\n+#define DEFAULT_ENDIAN_SPEC \"%{!meb: -mel}\"\n+\n+/* The MeP config tool will replace this with an -mconfig= switch.  */\n+#define LIBRARY_CONFIG_SPEC \"-mconfig=default\"\n+\n+/* Don't add an endian option when building the libraries.  */\n+#define DRIVER_SELF_SPECS \\\n+  \"%{!mlibrary:\" DEFAULT_ENDIAN_SPEC \"}\", \\\n+  \"%{mlibrary: \" LIBRARY_CONFIG_SPEC \" %{!mel:-meb}}\"\n+\n+/* The MeP config tool will add COPROC_SELECTION_TABLE here.  */\n+/* start-coproc-selection-table */\n+#define COPROC_SELECTION_TABLE \\\n+{\"default\", ISA_EXT1}\n+/* end-coproc-selection-table */\n+\n+#define CAN_DEBUG_WITHOUT_FP\n+\n+#define OPTIMIZATION_OPTIONS(LEVEL, FOR_SIZE) mep_optimization_options ()\n+\f\n+\n+#define BITS_BIG_ENDIAN 0\n+#define BYTES_BIG_ENDIAN (TARGET_LITTLE_ENDIAN ? 0 : 1)\n+#define WORDS_BIG_ENDIAN (TARGET_LITTLE_ENDIAN ? 0 : 1)\n+\n+#ifdef __LITTLE_ENDIAN__\n+#define LIBGCC2_WORDS_BIG_ENDIAN 0\n+#else\n+#define LIBGCC2_WORDS_BIG_ENDIAN 1\n+#endif\n+\n+#define UNITS_PER_WORD 4\n+\n+#define PROMOTE_MODE(MODE, UNSIGNEDP, TYPE)\t\\\n+  do\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\\\n+      if (GET_MODE_CLASS (MODE) == MODE_INT\t\\\n+          && GET_MODE_SIZE (MODE) < 4)\t\t\\\n+        (MODE) = SImode;\t\t\\\n+    }\t\t\t\t\t\t\\\n+  while (0)\n+\n+#define PARM_BOUNDARY 32\n+#define STACK_BOUNDARY 32\n+#define PREFERRED_STACK_BOUNDARY 64\n+#define FUNCTION_BOUNDARY 16\n+#define BIGGEST_ALIGNMENT 64\n+\n+#define DATA_ALIGNMENT(TYPE, ALIGN)\t\t\\\n+  (TREE_CODE (TYPE) == ARRAY_TYPE\t\t\\\n+   && TYPE_MODE (TREE_TYPE (TYPE)) == QImode\t\\\n+   && (ALIGN) < BITS_PER_WORD ? BITS_PER_WORD : (ALIGN))\n+\n+#define CONSTANT_ALIGNMENT(EXP, ALIGN)  \\\n+  (TREE_CODE (EXP) == STRING_CST\t\\\n+   && (ALIGN) < BITS_PER_WORD ? BITS_PER_WORD : (ALIGN))\n+\n+#define STRICT_ALIGNMENT 1\n+\n+#define PCC_BITFIELD_TYPE_MATTERS 1\n+\n+#define DEFAULT_VTABLE_THUNKS 1\n+\n+\f\n+#define INT_TYPE_SIZE         32\n+#define SHORT_TYPE_SIZE       16\n+#define LONG_TYPE_SIZE        32\n+#define LONG_LONG_TYPE_SIZE   64\n+#define CHAR_TYPE_SIZE         8\n+#define FLOAT_TYPE_SIZE       32\n+#define DOUBLE_TYPE_SIZE      64\n+#define LONG_DOUBLE_TYPE_SIZE 64\n+#define DEFAULT_SIGNED_CHAR    1\n+\f\n+/* Register numbers:\n+ \t0..15\tcore registers\n+\t16..47\tcontrol registers\n+\t48..79\tcoprocessor registers\n+\t80..111\tcoprocessor control registers\n+\t112\tvirtual arg pointer register  */\n+\n+#define FIRST_PSEUDO_REGISTER (LAST_SHADOW_REGISTER + 1)\n+\n+  /* R12 is optionally FP.  R13 is TP, R14 is GP, R15 is SP. */\n+  /* hi and lo can be used as general registers.  Others have\n+     immutable bits.  */\n+/* A \"1\" here means the register is generally not available to gcc,\n+   and is assumed to remain unchanged or unused throughout.  */\n+#define FIXED_REGISTERS {\t\t\t\t\\\n+  /* core registers */\t\t\t\t\t\\\n+  0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 1,\t\\\n+  /* control registers */\t\t\t\t\\\n+  1, 1, 1, 1,  1, 1, 1, 0,  0, 1, 1, 1,  1, 1, 1, 1,\t\\\n+  1, 1, 1, 1,  1, 1, 1, 1,  1, 1, 1, 1,  1, 1, 1, 1,\t\\\n+  /* coprocessor registers */\t\t\t\t\\\n+  1, 1, 1, 1,  1, 1, 1, 1,  1, 1, 1, 1,  1, 1, 1, 1,\t\\\n+  1, 1, 1, 1,  1, 1, 1, 1,  1, 1, 1, 1,  1, 1, 1, 1,\t\\\n+  /* coprocessor control registers */\t\t\t\\\n+  1, 1, 1, 1,  1, 1, 1, 1,  1, 1, 1, 1,  1, 1, 1, 1,\t\\\n+  1, 1, 1, 1,  1, 1, 1, 1,  1, 1, 1, 1,  1, 1, 1, 1,\t\\\n+  /* virtual arg pointer */\t\t\t\t\\\n+  1, FIXED_SHADOW_REGISTERS\t\t\t\t\\\n+  }\n+\n+/* This is a call-clobbered reg not used for args or return value,\n+   that we use as a temp for saving control registers in the prolog\n+   and restoring them in the epilog. */\n+#define REGSAVE_CONTROL_TEMP\t11\n+\n+/* A \"1\" here means a register may be changed by a function without\n+   needing to preserve its previous value.  */\n+#define CALL_USED_REGISTERS {\t\t\t\t\\\n+  /* core registers */\t\t\t\t\t\\\n+  1, 1, 1, 1,  1, 0, 0, 0,  0, 1, 1, 1,  1, 0, 0, 1,\t\\\n+  /* control registers */\t\t\t\t\\\n+  1, 1, 1, 1,  1, 1, 1, 1,  1, 1, 1, 1,  1, 1, 1, 1,\t\\\n+  1, 1, 1, 1,  1, 1, 1, 1,  1, 1, 1, 1,  1, 1, 1, 1,\t\\\n+  /* coprocessor registers */\t\t\t\t\\\n+  1, 1, 1, 1,  1, 1, 1, 1,  1, 1, 1, 1,  1, 1, 1, 1,\t\\\n+  1, 1, 1, 1,  1, 1, 1, 1,  1, 1, 1, 1,  1, 1, 1, 1,\t\\\n+  /* coprocessor control registers */\t\t\t\\\n+  1, 1, 1, 1,  1, 1, 1, 1,  1, 1, 1, 1,  1, 1, 1, 1,\t\\\n+  1, 1, 1, 1,  1, 1, 1, 1,  1, 1, 1, 1,  1, 1, 1, 1,\t\\\n+  /* virtual arg pointer */\t\t\t\t\\\n+  1, CALL_USED_SHADOW_REGISTERS\t\t\t\t\\\n+  }\n+\n+#define CONDITIONAL_REGISTER_USAGE \\\n+\tmep_conditional_register_usage (fixed_regs, call_used_regs);\n+\n+#define REG_ALLOC_ORDER {\t\t\t\t\t\t\\\n+  /* core registers */\t\t\t\t\t\t\t\\\n+  3, 2, 1, 0, 9, 10, 11, 12, 4, 5, 6, 7, 8, 13, 14, 15, \t\t\\\n+  /* control registers */\t\t\t\t\t\t\\\n+  16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31,\t\\\n+  32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47,\t\\\n+  /* coprocessor registers */\t\t\t\t\t\t\\\n+  /* Prefer to use the non-loadable registers when looking for a\t\\\n+     member of CR_REGS (as opposed to LOADABLE_CR_REGS).  */\t\t\\\n+  64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 48, 49, 50, 51, 52, 58,\t\\\n+  59, 60, 61, 62, 63, 53, 54, 55, 56, 57, 74, 75, 76, 77, 78, 79,\t\\\n+  /* coprocessor control registers */\t\t\t\t\t\\\n+  80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95,\t\\\n+  96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, \\\n+  /* virtual arg pointer */\t\t\t\t\t\t\\\n+  112, SHADOW_REG_ALLOC_ORDER\t\t\t\t\t\t\\\n+  }\n+\n+/* We must somehow disable register remapping for interrupt functions.  */\n+extern char mep_leaf_registers[];\n+#define LEAF_REGISTERS mep_leaf_registers\n+#define LEAF_REG_REMAP(REG) (REG)\n+\n+\f\n+#define FIRST_GR_REGNO 0\n+#define FIRST_CONTROL_REGNO (FIRST_GR_REGNO + 16)\n+#define FIRST_CR_REGNO (FIRST_CONTROL_REGNO + 32)\n+#define FIRST_CCR_REGNO (FIRST_CR_REGNO + 32)\n+\n+#define GR_REGNO_P(REGNO) \\\n+  ((unsigned) ((REGNO) - FIRST_GR_REGNO) < 16)\n+\n+#define CONTROL_REGNO_P(REGNO) \\\n+  ((unsigned) ((REGNO) - FIRST_CONTROL_REGNO) < 32)\n+\n+#define LOADABLE_CR_REGNO_P(REGNO) \\\n+  ((unsigned) ((REGNO) - FIRST_CR_REGNO) < 16)\n+\n+#define CR_REGNO_P(REGNO) \\\n+  ((unsigned) ((REGNO) - FIRST_CR_REGNO) < 32)\n+\n+#define CCR_REGNO_P(REGNO) \\\n+  ((unsigned) ((REGNO) - FIRST_CCR_REGNO) < 32)\n+\n+#define ANY_CONTROL_REGNO_P(REGNO) \\\n+  (CONTROL_REGNO_P (REGNO) || CCR_REGNO_P (REGNO))\n+\n+#define HARD_REGNO_NREGS(REGNO, MODE)\t\t\\\n+  ((CR_REGNO_P (REGNO) && TARGET_64BIT_CR_REGS)\t\\\n+   ? (GET_MODE_SIZE (MODE) + 8 - 1) / 8\t\t\\\n+   : (GET_MODE_SIZE (MODE) + 4 - 1) / 4)\n+\n+#define HARD_REGNO_MODE_OK(REGNO, MODE) 1\n+\n+#define MODES_TIEABLE_P(MODE1, MODE2) 1\n+\n+#define CANNOT_CHANGE_MODE_CLASS(FROM, TO, CLASS) \\\n+  mep_cannot_change_mode_class (FROM, TO, CLASS)\n+\f\n+enum reg_class\n+{\n+  NO_REGS,\n+  SP_REGS,\n+  TP_REGS,\n+  GP_REGS,\n+  R0_REGS,\n+  RPC_REGS,\n+  HI_REGS,\n+  LO_REGS,\n+  HILO_REGS,\n+  TPREL_REGS,\n+  GENERAL_NOT_R0_REGS,\n+  GENERAL_REGS,\n+  CONTROL_REGS,\n+  CONTROL_OR_GENERAL_REGS,\n+  USER0_REGS,\n+  USER1_REGS,\n+  USER2_REGS,\n+  USER3_REGS,\n+  LOADABLE_CR_REGS,\n+  CR_REGS,\n+  CCR_REGS,\n+  ALL_REGS,\n+  LIM_REG_CLASSES\n+};\n+\n+#define N_REG_CLASSES ((int) LIM_REG_CLASSES)\n+\n+#define REG_CLASS_NAMES { \\\n+  \"NO_REGS\", \\\n+  \"SP_REGS\", \\\n+  \"TP_REGS\", \\\n+  \"GP_REGS\", \\\n+  \"R0_REGS\", \\\n+  \"RPC_REGS\", \\\n+  \"HI_REGS\", \\\n+  \"LO_REGS\", \\\n+  \"HILO_REGS\", \\\n+  \"TPREL_REGS\", \\\n+  \"GENERAL_NOT_R0_REGS\", \\\n+  \"GENERAL_REGS\", \\\n+  \"CONTROL_REGS\", \\\n+  \"CONTROL_OR_GENERAL_REGS\", \\\n+  \"USER0_REGS\", \\\n+  \"USER1_REGS\", \\\n+  \"USER2_REGS\", \\\n+  \"USER3_REGS\", \\\n+  \"LOADABLE_CR_REGS\", \\\n+  \"CR_REGS\", \\\n+  \"CCR_REGS\", \\\n+  \"ALL_REGS\" }\n+\n+#define REG_CLASS_CONTENTS { \\\n+  { 0x00000000, 0x00000000, 0x00000000, 0x00000000 }, /* NO_REGS */ \\\n+  { 0x00008000, 0x00000000, 0x00000000, 0x00000000 }, /* SP_REGS */ \\\n+  { 0x00002000, 0x00000000, 0x00000000, 0x00000000 }, /* TP_REGS */ \\\n+  { 0x00004000, 0x00000000, 0x00000000, 0x00000000 }, /* GP_REGS */ \\\n+  { 0x00000001, 0x00000000, 0x00000000, 0x00000000 }, /* R0_REGS */ \\\n+  { 0x00400000, 0x00000000, 0x00000000, 0x00000000 }, /* RPC_REGS */ \\\n+  { 0x00800000, 0x00000000, 0x00000000, 0x00000000 }, /* HI_REGS */ \\\n+  { 0x01000000, 0x00000000, 0x00000000, 0x00000000 }, /* LO_REGS */ \\\n+  { 0x01800000, 0x00000000, 0x00000000, 0x00000000 }, /* HILO_REGS */ \\\n+  { 0x000000ff, 0x00000000, 0x00000000, 0x00000000 }, /* TPREL_REGS */ \\\n+  { 0x0000fffe, 0x00000000, 0x00000000, 0x00000000 }, /* GENERAL_NOT_R0_REGS */ \\\n+  { 0x0000ffff, 0x00000000, 0x00000000, 0x00010000 }, /* GENERAL_REGS */ \\\n+  { 0xffff0000, 0x0000ffff, 0x00000000, 0x00000000 }, /* CONTROL_REGS */ \\\n+  { 0xffffffff, 0x0000ffff, 0x00000000, 0x00000000 }, /* CONTROL_OR_GENERAL_REGS */ \\\n+  { 0x00000000, 0x00000000, 0x00000000, 0x00000000 }, /* USER0_REGS */ \\\n+  { 0x00000000, 0x00000000, 0x00000000, 0x00000000 }, /* USER1_REGS */ \\\n+  { 0x00000000, 0x00000000, 0x00000000, 0x00000000 }, /* USER2_REGS */ \\\n+  { 0x00000000, 0x00000000, 0x00000000, 0x00000000 }, /* USER3_REGS */ \\\n+  { 0x00000000, 0xffff0000, 0x00000000, 0x00000000 }, /* LOADABLE_CR_REGS */ \\\n+  { 0x00000000, 0xffff0000, 0x0000ffff, 0x00000000 }, /* CR_REGS */ \\\n+  { 0x00000000, 0x00000000, 0xffff0000, 0x0000ffff }, /* CCR_REGS */ \\\n+  { 0xffffffff, 0xffffffff, 0xffffffff, 0x0001ffff }, /* ALL_REGS */ \\\n+  }\n+\n+#define REGNO_REG_CLASS(REGNO) mep_regno_reg_class (REGNO)\n+\n+#define IRA_COVER_CLASSES { GENERAL_REGS, CONTROL_REGS, CR_REGS, CCR_REGS, LIM_REG_CLASSES }\n+\n+#define BASE_REG_CLASS GENERAL_REGS\n+#define INDEX_REG_CLASS GENERAL_REGS\n+\n+#if 0\n+#define REG_CLASS_FROM_CONSTRAINT(CHAR, STRING) \\\n+\tmep_reg_class_from_constraint (CHAR, STRING)\n+#endif\n+\n+#define REGNO_OK_FOR_BASE_P(NUM) (GR_REGNO_P (NUM) \\\n+\t|| (NUM) == ARG_POINTER_REGNUM \\\n+\t|| (NUM) >= FIRST_PSEUDO_REGISTER)\n+\n+#define REGNO_OK_FOR_INDEX_P(NUM) REGNO_OK_FOR_BASE_P (NUM)\n+\n+#define PREFERRED_RELOAD_CLASS(X, CLASS) mep_preferred_reload_class (X, CLASS)\n+\n+#define SECONDARY_INPUT_RELOAD_CLASS(CLASS, MODE, X) \\\n+\tmep_secondary_input_reload_class (CLASS, MODE, X)\n+#define SECONDARY_OUTPUT_RELOAD_CLASS(CLASS, MODE, X) \\\n+\tmep_secondary_output_reload_class (CLASS, MODE, X)\n+#define SECONDARY_MEMORY_NEEDED(CLASS1, CLASS2, MODE) \\\n+\tmep_secondary_memory_needed (CLASS1, CLASS2, MODE)\n+\n+#define CLASS_MAX_NREGS(CLASS, MODE) \\\n+  ((GET_MODE_SIZE (MODE) + UNITS_PER_WORD - 1) / UNITS_PER_WORD)\n+\n+#if 0\n+#define CONST_OK_FOR_LETTER_P(VALUE, C) mep_const_ok_for_letter_p (VALUE, C)\n+\n+#define CONST_DOUBLE_OK_FOR_LETTER_P(VALUE, C) 0\n+\n+#define CONSTRAINT_LEN(C, STR) \\\n+\t((C) == 'e' ? 2 : DEFAULT_CONSTRAINT_LEN (C, STR))\n+#define EXTRA_CONSTRAINT(VALUE, C) mep_extra_constraint (VALUE, C)\n+#endif\n+\n+#define WANT_GCC_DECLARATIONS\n+#include \"mep-intrin.h\"\n+#undef WANT_GCC_DECLARATIONS\n+\n+extern int mep_intrinsic_insn[];\n+extern unsigned int mep_selected_isa;\n+\n+/* True if intrinsic X is available.  X is a mep_* value declared\n+   in mep-intrin.h.  */\n+#define MEP_INTRINSIC_AVAILABLE_P(X) (mep_intrinsic_insn[X] >= 0)\n+\n+/* Used to define CGEN_ENABLE_INTRINSIC_P in mep-intrin.h.  */\n+#define CGEN_CURRENT_ISAS mep_selected_isa\n+#define CGEN_CURRENT_GROUP \\\n+  (mep_vliw_function_p (cfun->decl) ? GROUP_VLIW : GROUP_NORMAL)\n+\n+\f\n+\n+#define STACK_GROWS_DOWNWARD       1\n+#define FRAME_GROWS_DOWNWARD\t   1\n+#define STARTING_FRAME_OFFSET      0\n+#define FIRST_PARM_OFFSET(FUNDECL) 0\n+#define INCOMING_FRAME_SP_OFFSET   0\n+\n+#define RETURN_ADDR_RTX(COUNT, FRAMEADDR) mep_return_addr_rtx (COUNT)\n+#define INCOMING_RETURN_ADDR_RTX          gen_rtx_REG (SImode, LP_REGNO)\n+#define DWARF_FRAME_RETURN_COLUMN         LP_REGNO\n+\n+#define STACK_POINTER_REGNUM          15\n+#define FRAME_POINTER_REGNUM           8\n+#define ARG_POINTER_REGNUM            112\n+#define RETURN_ADDRESS_POINTER_REGNUM 17\n+#define STATIC_CHAIN_REGNUM            0\n+\n+\f\n+\n+#define FRAME_POINTER_REQUIRED 0\n+\n+#define ELIMINABLE_REGS\t\t\t\t\t\t\\\n+{\t\t\t\t\t\t\t\t\\\n+  {ARG_POINTER_REGNUM,\t STACK_POINTER_REGNUM},\t\t\t\\\n+  {ARG_POINTER_REGNUM,\t FRAME_POINTER_REGNUM},\t\t\t\\\n+  {FRAME_POINTER_REGNUM, STACK_POINTER_REGNUM}\t\t\t\\\n+}\n+\n+#define CAN_ELIMINATE(FROM, TO)\t\t\t\t\t\\\n+ ((FROM) == ARG_POINTER_REGNUM && (TO) == STACK_POINTER_REGNUM\t\\\n+  ? ! frame_pointer_needed\t\t\t\t\t\\\n+  : 1)\n+\n+#define INITIAL_ELIMINATION_OFFSET(FROM, TO, OFFSET) \\\n+\t(OFFSET) = mep_elimination_offset (FROM, TO)\n+\n+#define ACCUMULATE_OUTGOING_ARGS 1\n+\n+#define RETURN_POPS_ARGS(FUNDECL, FUNTYPE, STACK_SIZE) 0\n+\n+\f\n+\n+/* The ABI is thus: Arguments are in $1, $2, $3, $4, stack.  Arguments\n+   larger than 4 bytes are passed indirectly.  Return value in 0,\n+   unless bigger than 4 bytes, then the caller passes a pointer as the\n+   first arg.  For varargs, we copy $1..$4 to the stack.  */\n+\n+#define FUNCTION_ARG(CUM, MODE, TYPE, NAMED) \\\n+\tmep_function_arg (CUM, MODE, TYPE, NAMED)\n+\n+#define FUNCTION_ARG_CALLEE_COPIES(CUM, MODE, TYPE, NAMED) 1\n+\n+typedef struct\n+{\n+  int nregs;\n+  int vliw;\n+} CUMULATIVE_ARGS;\n+\n+#define INIT_CUMULATIVE_ARGS(CUM, FNTYPE, LIBNAME, FNDECL, N_NAMED_ARGS) \\\n+\tmep_init_cumulative_args (& (CUM), FNTYPE, LIBNAME, FNDECL)\n+\n+#define FUNCTION_ARG_ADVANCE(CUM, MODE, TYPE, NAMED)\t\t\\\n+\tmep_arg_advance (& (CUM), MODE, TYPE, NAMED)\n+\n+#define FUNCTION_ARG_REGNO_P(REGNO) ((REGNO) >= 1 && (REGNO) <= 4)\n+\n+#define RETURN_VALUE_REGNUM\t 0\n+\n+#define FUNCTION_VALUE(VALTYPE, FUNC) mep_function_value (VALTYPE, FUNC)\n+#define LIBCALL_VALUE(MODE) mep_libcall_value (MODE)\n+\n+#define FUNCTION_VALUE_REGNO_P(REGNO)\t\t\t\t\\\n+  ((REGNO) == RETURN_VALUE_REGNUM)\n+\n+#define DEFAULT_PCC_STRUCT_RETURN 0\n+\n+#define STRUCT_VALUE 0\n+\n+#define FUNCTION_OK_FOR_SIBCALL(DECL) mep_function_ok_for_sibcall(DECL)\n+\f\n+/* Prologue and epilogues are all handled via RTL.  */\n+\n+#define EXIT_IGNORE_STACK 1\n+\n+#define EPILOGUE_USES(REGNO)  mep_epilogue_uses (REGNO)\n+\n+/* Profiling is supported.  */\n+     \n+#define FUNCTION_PROFILER(FILE, LABELNO) mep_function_profiler (FILE);\n+#undef TARGET_HAS_F_SETLKW\n+#define NO_PROFILE_COUNTERS 1\n+\f\n+/* Trampolines are built at run-time.  The cache is invalidated at\n+   run-time also.  */\n+\n+#define TRAMPOLINE_SIZE 20\n+\n+#define INITIALIZE_TRAMPOLINE(ADDR, FNADDR, STATIC_CHAIN) \\\n+\tmep_init_trampoline (ADDR, FNADDR, STATIC_CHAIN)\n+\n+\f\n+\n+#define CONSTANT_ADDRESS_P(X) CONSTANT_P (X)\n+\n+#define MAX_REGS_PER_ADDRESS 1\n+\n+#ifdef REG_OK_STRICT\n+#define GO_IF_LEGITIMATE_ADDRESS(MODE, X, LABEL) \t\t\\\n+\tif (mep_legitimate_address ((MODE), (X), 1)) goto LABEL\n+#else\n+#define GO_IF_LEGITIMATE_ADDRESS(MODE, X, LABEL) \t\t\\\n+\tif (mep_legitimate_address ((MODE), (X), 0)) goto LABEL\n+#endif\n+\n+#ifdef REG_OK_STRICT\n+#define REG_OK_FOR_BASE_P(X) GR_REGNO_P (REGNO (X))\n+#else\n+#define REG_OK_FOR_BASE_P(X) (GR_REGNO_P (REGNO (X)) \\\n+\t\t\t\t|| REGNO (X) == ARG_POINTER_REGNUM \\\n+\t\t\t\t|| REGNO (X) >= FIRST_PSEUDO_REGISTER)\n+#endif\n+\n+#define REG_OK_FOR_INDEX_P(X) REG_OK_FOR_BASE_P (X)\n+\n+#define LEGITIMIZE_RELOAD_ADDRESS(X, MODE, OPNUM, TYPE, IND_LEVELS, WIN) \\\n+  if (mep_legitimize_reload_address (&(X), (MODE), (OPNUM), (TYPE), (IND_LEVELS))) \\\n+    goto WIN\n+\n+#define GO_IF_MODE_DEPENDENT_ADDRESS(ADDR, LABEL)\n+\n+#define LEGITIMATE_CONSTANT_P(X) 1\n+\n+#define SELECT_CC_MODE(OP, X, Y)  CCmode\n+\f\n+\n+/* Moves between control regs need a scratch.  */\n+#define REGISTER_MOVE_COST(MODE, FROM, TO) mep_register_move_cost (MODE, FROM, TO)\n+\n+#define SLOW_BYTE_ACCESS 1\n+\n+/* Define this macro if it is as good or better to call a constant function\n+   address than to call an address kept in a register.  */\n+#define NO_FUNCTION_CSE \n+\n+\f\n+#define TEXT_SECTION_ASM_OP \"\\t.text\\n\\t.core\"\n+#define DATA_SECTION_ASM_OP \"\\t.data\"\n+#define BSS_SECTION_ASM_OP  \".bss\"\n+\n+#define TARGET_ASM_FILE_END mep_file_cleanups\n+\n+#define ASM_APP_ON \"#APP\\n\"\n+#define ASM_APP_OFF \"#NO_APP\\n\"\n+\n+#define ASM_OUTPUT_DOUBLE(FILE, VALUE)\t\t\t\t\\\n+  do\t\t\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\\\n+      long l[2];\t\t\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\\\n+      REAL_VALUE_TO_TARGET_DOUBLE (VALUE, l);\t\t\t\\\n+      fprintf (FILE, \"\\t.long\\t0x%lx,0x%lx\\n\", l[0], l[1]);\t\\\n+    }\t\t\t\t\t\t\t\t\\\n+  while (0)\n+\n+#define ASM_OUTPUT_FLOAT(FILE, VALUE)\t\t\\\n+  do\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\\\n+      long l;\t\t\t\t\t\\\n+\t\t\t\t\t\t\\\n+      REAL_VALUE_TO_TARGET_SINGLE (VALUE, l);\t\\\n+      fprintf ((FILE), \"\\t.long\\t0x%lx\\n\", l);\t\\\n+    }\t\t\t\t\t\t\\\n+  while (0)\n+\n+#define ASM_OUTPUT_CHAR(FILE, VALUE)\t\t\\\n+  do\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\\\n+      fprintf (FILE, \"\\t.byte\\t\");\t\t\\\n+      output_addr_const (FILE, (VALUE));\t\\\n+      fprintf (FILE, \"\\n\");\t\t\t\\\n+    }\t\t\t\t\t\t\\\n+  while (0)\n+\n+#define ASM_OUTPUT_SHORT(FILE, VALUE)\t\t\\\n+  do\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\\\n+      fprintf (FILE, \"\\t.hword\\t\");\t\t\\\n+      output_addr_const (FILE, (VALUE));\t\\\n+      fprintf (FILE, \"\\n\");\t\t\t\\\n+    }\t\t\t\t\t\t\\\n+  while (0)\n+\n+#define ASM_OUTPUT_INT(FILE, VALUE)\t\t\\\n+  do\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\\\n+      fprintf (FILE, \"\\t.word\\t\");\t\t\\\n+      output_addr_const (FILE, (VALUE));\t\\\n+      fprintf (FILE, \"\\n\");\t\t\t\\\n+    }\t\t\t\t\t\t\\\n+  while (0)\n+\n+#define ASM_OUTPUT_BYTE(STREAM, VALUE) \\\n+  fprintf (STREAM, \"\\t%s\\t0x%x\\n\", ASM_BYTE_OP, (VALUE))\n+\n+/* Most of these are here to support based/tiny/far/io attributes.  */\n+\n+#define ASM_OUTPUT_ALIGNED_DECL_COMMON(STREAM, DECL, NAME, SIZE, ALIGNMENT) \\\n+\tmep_output_aligned_common (STREAM, DECL, NAME, SIZE, ALIGNMENT, 1)\n+\n+#define ASM_OUTPUT_ALIGNED_DECL_LOCAL(STREAM, DECL, NAME, SIZE, ALIGNMENT) \\\n+\tmep_output_aligned_common (STREAM, DECL, NAME, SIZE, ALIGNMENT, 0)\n+\n+#define ASM_OUTPUT_LABEL(STREAM, NAME)\t\t\\\n+  do\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\\\n+      assemble_name (STREAM, NAME);\t\t\\\n+      fputs (\":\\n\", STREAM);\t\t\t\\\n+    }\t\t\t\t\t\t\\\n+  while (0)\n+\n+/* Globalizing directive for a label.  */\n+#define GLOBAL_ASM_OP \"\\t.globl \"\n+\n+#define ASM_OUTPUT_LABELREF(STREAM, NAME) \\\n+  asm_fprintf ((STREAM), \"%U%s\", mep_strip_name_encoding (NAME))\n+\n+#define ASM_FORMAT_PRIVATE_NAME(OUTVAR, NAME, NUMBER)\t\t\\\n+  do\t\t\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\\\n+      (OUTVAR) = (char *) alloca (strlen ((NAME)) + 12);\t\\\n+      sprintf ((OUTVAR), \"%s.%ld\", (NAME), (long)(NUMBER));\t\\\n+    }\t\t\t\t\t\t\t\t\\\n+  while (0)\n+\f\n+\n+#define REGISTER_NAMES\t\t\t\t\t\t\t\\\n+{\t\t\t\t\t\t\t\t\t\\\n+  /* Core registers.  */\t\t\t\t\t\t\\\n+  \"$0\", \"$1\", \"$2\", \"$3\", \"$4\", \"$5\", \"$6\", \"$7\",\t\t\t\\\n+  \"$8\", \"$9\", \"$10\", \"$11\", \"$12\", \"$tp\", \"$gp\", \"$sp\",\t\t\t\\\n+  /* Control registers.  */\t\t\t\t\t\t\\\n+  \"$pc\", \"$lp\", \"$sar\", \"3\", \"$rpb\", \"$rpe\", \"$rpc\", \"$hi\",\t\t\\\n+  \"$lo\", \"9\", \"10\", \"11\", \"$mb0\", \"$me0\", \"$mb1\", \"$me1\",\t\t\\\n+  \"$psw\", \"$id\", \"$tmp\", \"$epc\", \"$exc\", \"$cfg\", \"22\", \"$npc\",\t\t\\\n+  \"$dbg\", \"$depc\", \"$opt\", \"$rcfg\", \"$ccfg\", \"29\", \"30\", \"31\",\t\t\\\n+  /* Coprocessor registers.  */\t\t\t\t\t\t\\\n+  \"$c0\", \"$c1\", \"$c2\", \"$c3\", \"$c4\", \"$c5\", \"$c6\", \"$c7\",\t\t\\\n+  \"$c8\", \"$c9\", \"$c10\", \"$c11\", \"$c12\", \"$c13\", \"$c14\", \"$c15\",\t\t\\\n+  \"$c16\", \"$c17\", \"$c18\", \"$c19\", \"$c20\", \"$c21\", \"$c22\", \"$c23\",\t\\\n+  \"$c24\", \"$c25\", \"$c26\", \"$c27\", \"$c28\", \"$c29\", \"$c30\", \"$c31\",\t\\\n+  /* Coprocessor control registers.  */\t\t\t\t\t\\\n+  \"$ccr0\", \"$ccr1\", \"$ccr2\", \"$ccr3\", \"$ccr4\", \"$ccr5\", \"$ccr6\",\t\\\n+  \"$ccr7\", \"$ccr8\", \"$ccr9\", \"$ccr10\", \"$ccr11\", \"$ccr12\", \"$ccr13\",\t\\\n+  \"$ccr14\", \"$ccr15\", \"$ccr16\", \"$ccr17\", \"$ccr18\", \"$ccr19\", \"$ccr20\", \\\n+  \"$ccr21\", \"$ccr22\", \"$ccr23\", \"$ccr24\", \"$ccr25\", \"$ccr26\", \"$ccr27\", \\\n+  \"$ccr28\", \"$ccr29\", \"$ccr30\", \"$ccr31\",\t\t\t\t\\\n+  /* Virtual arg pointer.  */\t\t\t\t\t\t\\\n+  \"$argp\", SHADOW_REGISTER_NAMES\t\t\t\t\t\\\n+}\n+\n+/* We duplicate some of the above because we twiddle the above\n+   according to *how* the registers are used.  Likewise, we include\n+   the standard names for coprocessor control registers so that\n+   coprocessor options can rename them in the default table.  Note\n+   that these are compared to stripped names (see REGISTER_PREFIX\n+   below).  */\n+#define ADDITIONAL_REGISTER_NAMES\t\t\\\n+{\t\t\t\t\t\t\\\n+  {  \"8\",  8 }, { \"fp\",  8 },\t\t\t\\\n+  { \"13\", 13 }, { \"tp\", 13 },\t\t\t\\\n+  { \"14\", 14 }, { \"gp\", 14 },\t\t\t\\\n+  { \"15\", 15 }, { \"sp\", 15 },\t\t\t\\\n+  { \"ccr0\", FIRST_CCR_REGNO + 0 },\t\t\\\n+  { \"ccr1\", FIRST_CCR_REGNO + 1 },\t\t\\\n+  { \"ccr2\", FIRST_CCR_REGNO + 2 },\t\t\\\n+  { \"ccr3\", FIRST_CCR_REGNO + 3 },\t\t\\\n+  { \"ccr4\", FIRST_CCR_REGNO + 4 },\t\t\\\n+  { \"ccr5\", FIRST_CCR_REGNO + 5 },\t\t\\\n+  { \"ccr6\", FIRST_CCR_REGNO + 6 },\t\t\\\n+  { \"ccr7\", FIRST_CCR_REGNO + 7 },\t\t\\\n+  { \"ccr8\", FIRST_CCR_REGNO + 8 },\t\t\\\n+  { \"ccr9\", FIRST_CCR_REGNO + 9 },\t\t\\\n+  { \"ccr10\", FIRST_CCR_REGNO + 10 },\t\t\\\n+  { \"ccr11\", FIRST_CCR_REGNO + 11 },\t\t\\\n+  { \"ccr12\", FIRST_CCR_REGNO + 12 },\t\t\\\n+  { \"ccr13\", FIRST_CCR_REGNO + 13 },\t\t\\\n+  { \"ccr14\", FIRST_CCR_REGNO + 14 },\t\t\\\n+  { \"ccr15\", FIRST_CCR_REGNO + 15 },\t\t\\\n+  { \"ccr16\", FIRST_CCR_REGNO + 16 },\t\t\\\n+  { \"ccr17\", FIRST_CCR_REGNO + 17 },\t\t\\\n+  { \"ccr18\", FIRST_CCR_REGNO + 18 },\t\t\\\n+  { \"ccr19\", FIRST_CCR_REGNO + 19 },\t\t\\\n+  { \"ccr20\", FIRST_CCR_REGNO + 20 },\t\t\\\n+  { \"ccr21\", FIRST_CCR_REGNO + 21 },\t\t\\\n+  { \"ccr22\", FIRST_CCR_REGNO + 22 },\t\t\\\n+  { \"ccr23\", FIRST_CCR_REGNO + 23 },\t\t\\\n+  { \"ccr24\", FIRST_CCR_REGNO + 24 },\t\t\\\n+  { \"ccr25\", FIRST_CCR_REGNO + 25 },\t\t\\\n+  { \"ccr26\", FIRST_CCR_REGNO + 26 },\t\t\\\n+  { \"ccr27\", FIRST_CCR_REGNO + 27 },\t\t\\\n+  { \"ccr28\", FIRST_CCR_REGNO + 28 },\t\t\\\n+  { \"ccr29\", FIRST_CCR_REGNO + 29 },\t\t\\\n+  { \"ccr30\", FIRST_CCR_REGNO + 30 },\t\t\\\n+  { \"ccr31\", FIRST_CCR_REGNO + 31 }\t\t\\\n+}\n+\n+/* We watch for pipeline hazards with these */\n+#define ASM_OUTPUT_OPCODE(STREAM, PTR) mep_asm_output_opcode (STREAM, PTR)\n+#define FINAL_PRESCAN_INSN(INSN, OPVEC, NOPERANDS) mep_final_prescan_insn (INSN, OPVEC, NOPERANDS)\n+\n+#define PRINT_OPERAND(STREAM, X, CODE) mep_print_operand (STREAM, X, CODE)\n+\n+#define PRINT_OPERAND_PUNCT_VALID_P(CODE) ((CODE) == '!' || (CODE) == '<')\n+\n+#define PRINT_OPERAND_ADDRESS(STREAM, X) mep_print_operand_address (STREAM, X)\n+\n+#define REGISTER_PREFIX    \"$\"\n+#define LOCAL_LABEL_PREFIX \".\"\n+#define USER_LABEL_PREFIX  \"\"\n+#define IMMEDIATE_PREFIX   \"\"\n+\n+\f\n+\n+#define ASM_OUTPUT_ADDR_VEC_ELT(STREAM, VALUE) \\\n+  fprintf (STREAM, \"\\t.word .L%d\\n\", VALUE)\n+\n+\f\n+\n+#undef  PREFERRED_DEBUGGING_TYPE\n+#define PREFERRED_DEBUGGING_TYPE  DWARF2_DEBUG\n+#define DWARF2_DEBUGGING_INFO     1\n+#define DWARF2_UNWIND_INFO        1\n+\n+#define EH_RETURN_DATA_REGNO(N) ((N) < 2 ? (N) + 10 : INVALID_REGNUM)\n+\n+#define EH_RETURN_STACKADJ_RTX mep_return_stackadj_rtx ()\n+#define EH_RETURN_HANDLER_RTX  mep_return_handler_rtx ()\n+\n+#define DBX_REGISTER_NUMBER(REGNO) (REGNO)\n+\n+\f\n+\n+#define ASM_OUTPUT_ALIGN(STREAM, POWER) \\\n+  fprintf ((STREAM), \"\\t.p2align %d\\n\", (POWER))\n+\n+\f\n+\n+#define CASE_VECTOR_MODE SImode\n+\n+#define WORD_REGISTER_OPERATIONS\n+#define LOAD_EXTEND_OP(MODE) SIGN_EXTEND\n+\n+#define SHORT_IMMEDIATES_SIGN_EXTEND\n+\n+#define MOVE_MAX 4\n+\n+#define SHIFT_COUNT_TRUNCATED 1\n+\n+#define TRULY_NOOP_TRUNCATION(OUTPREC, INPREC) 1\n+\n+#define STORE_FLAG_VALUE 1\n+\n+#define Pmode SImode\n+\n+#define FUNCTION_MODE SImode\n+\n+#define REGISTER_TARGET_PRAGMAS()\t mep_register_pragmas ()\n+\n+#define HANDLE_PRAGMA_PACK_PUSH_POP 1\n+   \n+/* If defined, a C expression to determine the base term of address X.\n+   This macro is used in only one place: `find_base_term' in alias.c.\n+\n+   It is always safe for this macro to not be defined.  It exists so\n+   that alias analysis can understand machine-dependent addresses.\n+\n+   The typical use of this macro is to handle addresses containing\n+   a label_ref or symbol_ref within an UNSPEC.  */\n+#define FIND_BASE_TERM(X) mep_find_base_term (X)\n+\n+/* start-sanitize-never */\n+\n+#define INCLUDE_MEP_EEMBC\n+#define NO_GCSE_BACK_EDGE_INSERTIONS\n+/* end-sanitize-never */"}, {"sha": "2b6aa808526c2bd7588dd804e6ff072ce3276649", "filename": "gcc/config/mep/mep.md", "status": "added", "additions": 2258, "deletions": 0, "changes": 2258, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7acf4da6f94801cb3146709fc0ae310ac475a274/gcc%2Fconfig%2Fmep%2Fmep.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7acf4da6f94801cb3146709fc0ae310ac475a274/gcc%2Fconfig%2Fmep%2Fmep.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmep%2Fmep.md?ref=7acf4da6f94801cb3146709fc0ae310ac475a274", "patch": "@@ -0,0 +1,2258 @@\n+;; Toshiba Media Processor Machine description template\n+;; Copyright (C) 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2009 Free\n+;; Software Foundation, Inc.\n+;; Contributed by Red Hat Inc\n+;;\n+;; This file is part of GCC.\n+;;\n+;; GCC is free software; you can redistribute it and/or modify it\n+;; under the terms of the GNU General Public License as published by\n+;; the Free Software Foundation; either version 3, or (at your option)\n+;; any later version.\n+;;\n+;; GCC is distributed in the hope that it will be useful, but WITHOUT\n+;; ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n+;; or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public\n+;; License for more details.\n+;;\n+;; You should have received a copy of the GNU General Public License\n+;; along with GCC; see the file COPYING3.  If not see\n+;; <http://www.gnu.org/licenses/>.  */\n+\n+\f\n+\n+;; Constraints:\n+;;\n+;;  a   $sp\n+;;  b   $tp\n+;;  c   control regs\n+;;  h   $hi ($23)\n+;;  l   $lo ($24)\n+;;  d   $hi/$lo pair (DImode)\n+;;  j   $rpc ($22)\n+;;  r   $0..$15\n+;;  t   $0..$7\n+;;  v   $gp\n+;;  x\t$c0..$c31\n+;;  ex  coprocessor registers that can be moved to other coprocessor registers\n+;;  er  coprocessor registers that can be moved to and from core registers\n+;;  em  coprocessor registers that can be moves to and from memory\n+;;  y\t$ccr0..$ccr31\n+;;  z   $0\n+;;\n+;;  I   sign imm16\tmov/add\n+;;  J   zero imm16\tmov/add\n+;;  K   zero imm24\tmov\n+;;  L   sign imm6\tadd\n+;;  M   zero imm5\tslt,shifts\n+;;  N   zero imm4\tbCC\n+;;  O   high imm16\tmov\n+;;\n+;;  R   near symbol\n+;;  S   sign imm8\tmov\n+;;  T   tp or gp relative symbol\n+;;  U   non-absolute memory\n+;;  W   %hi(sym)\n+;;  Y   (Rn)\n+;;  Z   Control Bus Symbol\n+;;\n+;; Modifiers:\n+;;\n+;;  b   print unique bit in mask\n+;;  B   print bits required for value (for clip)\n+;;  h\tprint decimal >> 16.\n+;;  I   print decimal, with hex comment if more than 8 bits\n+;;  J   print unsigned hex\n+;;  L   print set, clr or not (for bitops)\n+;;  P\tprint memory as a post-inc with no increment\n+;;  U   print bits required for value (for clipu)\n+;;  x   print unsigned decimal or hex, depending on where set bits are\n+\n+(define_constants [\n+\t\t   (REGSAVE_CONTROL_TEMP 11)\n+\t\t   (FP_REGNO 8)\n+\t\t   (TP_REGNO 13)\n+\t\t   (GP_REGNO 14)\n+\t\t   (SP_REGNO 15)\n+\t\t   (PSW_REGNO 16)\n+\t\t   (LP_REGNO 17)\n+\t\t   (SAR_REGNO 18)\n+\t\t   (RPB_REGNO 20)\n+\t\t   (RPE_REGNO 21)\n+\t\t   (RPC_REGNO 22)\n+\t\t   (HI_REGNO 23)\n+\t\t   (LO_REGNO 24)\n+\t\t   (CBCR_REGNO 81)\n+\t\t   ])\n+\n+(define_constants [\n+\t\t   (UNS_BLOCKAGE 0)\n+\t\t   (UNS_TPREL 2)\n+\t\t   (UNS_GPREL 3)\n+\t\t   (UNS_REPEAT_BEG 4)\n+\t\t   (UNS_REPEAT_END 5)\n+\t\t   (UNS_EH_EPILOGUE 6)\n+\t\t   (UNS_EREPEAT_BEG 7)\n+\t\t   (UNS_EREPEAT_END 8)\n+\t\t   (UNS_BB_TRACE_RET 9)\n+\t\t   (UNS_DISABLE_INT 10)\n+\t\t   (UNS_ENABLE_INT 11)\n+\t\t   (UNS_RETI 12)\n+\t\t  ])\n+\f\n+;; This attribute determines the VLIW packing mechanism.  The IVC2\n+;; coprocessor has two pipelines (P0 and P1), and a MeP+IVC2 can issue\n+;; up to three insns at a time.  Most IVC2 insns can run on either\n+;; pipeline, however, scheduling some insns on P0 precludes packing a\n+;; core insn with it, and only 16-bit core insns can pack with any P0\n+;; insn.\n+(define_attr \"vliw\" \"basic,ivc2\"\n+  (const (symbol_ref \"TARGET_IVC2\")))\n+\n+;; This attribute describes the kind of memory operand present in the\n+;; instruction.  This is used to compute the length of the insn based\n+;; on the addressing mode used.\n+(define_attr \"memop\" \"none,core0,core1,cop0,cop1\"\n+  (const_string \"none\"))\n+\n+(define_attr \"intrinsic\" \"none,cmov,cmov1,cmov2,cmovc1,cmovc2,cmovh1,cmovh2\"\n+  (const_string \"none\"))\n+\n+;; This attribute describes how the instruction may be bundled in a\n+;; VLIW instruction.  Type MULTI is assumed to use both slots.\n+(define_attr \"slot\" \"core,cop,multi\"\n+  (cond [(eq_attr \"intrinsic\" \"!none\")\n+\t   (const_string \"cop\")]\n+\t(const_string \"core\")))\n+\n+;; This attribute describes the latency of the opcode (ready delay).\n+;; The 0 is used to indicate \"unspecified\".  An instruction that\n+;; completes immediately with no potential stalls would have a value\n+;; of 1, a one cycle stall would be 2, etc.\n+(define_attr \"latency\" \"\"\n+  (const_int 0))\n+\n+(define_attr \"shiftop\" \"none,operand2\"\n+  (const_string \"none\"))\n+\n+;; This attribute describes the size of the instruction in bytes.\n+;; This *must* be exact unless the pattern is SLOT_MULTI, as this\n+;; is used by the VLIW bundling code.\n+(define_attr \"length\" \"\"\n+  (cond [(eq_attr \"memop\" \"core0\")\n+\t   (symbol_ref \"mep_core_address_length (insn, 0)\")\n+\t (eq_attr \"memop\" \"core1\")\n+\t   (symbol_ref \"mep_core_address_length (insn, 1)\")\n+\t (eq_attr \"memop\" \"cop0\")\n+\t   (symbol_ref \"mep_cop_address_length (insn, 0)\")\n+\t (eq_attr \"memop\" \"cop1\")\n+\t   (symbol_ref \"mep_cop_address_length (insn, 1)\")\n+         ]\n+\t ; Catch patterns that don't define the length properly.\n+         (symbol_ref \"(abort (), 0)\")))\n+\n+;; This attribute describes a pipeline hazard seen in the insn.\n+(define_attr \"stall\" \"none,int2,ssarb,load,store,ldc,stc,ldcb,stcb,ssrab,fsft,ret,advck,mul,mulr,div\"\n+  (cond [(and (eq_attr \"shiftop\" \"operand2\")\n+\t      (not (match_operand:SI 2 \"mep_single_shift_operand\" \"\")))\n+\t (const_string \"int2\")]\n+\t(const_string \"none\")))\n+\n+(define_attr \"may_trap\" \"no,yes\"\n+  (const_string \"no\"))\n+\n+;; Describe a user's asm statement.\n+(define_asm_attributes\n+  [(set_attr \"length\" \"4\")\n+   (set_attr \"slot\" \"multi\")])\n+\n+;; Each IVC2 instruction uses one of these two pipelines.  P0S insns\n+;; use P0; C3 insns use P1.\n+(define_automaton \"mep_ivc2\")\n+(define_cpu_unit \"ivc2_core,ivc2_p0,ivc2_p1\" \"mep_ivc2\")\n+\n+;; Each core or IVC2 instruction is bundled into one of these slots.\n+;; Supported bundlings:\n+;; \n+;; Core mode:\n+;;\n+;;  C1\t[-----core-----]\n+;;  C2\t[-------------core-------------]\n+;;  C3\t[--------------c3--------------]\n+;;\n+;; VLIW mode:\n+;;\n+;;  V1\t[-----core-----][--------p0s-------][------------p1------------]\n+;;  V2  [-------------core-------------]xxxx[------------p1------------]\n+;;  V3\t1111[--p0--]0111[--------p0--------][------------p1------------]\n+\n+(define_attr \"slots\" \"core,c3,p0,p0_p0s,p0_p1,p0s,p0s_p1,p1\" (const_string \"core\"))\n+\n+(define_cpu_unit \"ivc2_slot_c16,ivc2_slot_c32,ivc2_slot_c3,ivc2_slot_p0s,ivc2_slot_p0,ivc2_slot_p1\" \"mep_ivc2\")\n+\n+(define_insn_reservation \"ivc2_insn_core16\" 1\n+  (and (eq_attr \"vliw\" \"ivc2\")\n+       (and (eq (symbol_ref \"get_attr_length(insn)\") (const_int 2))\n+\t    (and (eq_attr \"intrinsic\" \"none\")\n+\t\t (eq_attr \"slot\" \"!cop\"))))\n+  \"ivc2_core+ivc2_slot_c16\")\n+\n+(define_insn_reservation \"ivc2_insn_core32\" 1\n+  (and (eq_attr \"vliw\" \"ivc2\")\n+       (and (eq (symbol_ref \"get_attr_length(insn)\") (const_int 4))\n+\t    (and (eq_attr \"intrinsic\" \"none\")\n+\t\t (eq_attr \"slot\" \"!cop\"))))\n+  \"ivc2_core+ivc2_slot_c32\")\n+\n+;; These shouldn't happen when in VLIW mode.\n+(define_insn_reservation \"ivc2_insn_c3\" 1\n+  (and (eq_attr \"vliw\" \"ivc2\")\n+       (eq_attr \"slots\" \"c3\"))\n+  \"ivc2_p1+ivc2_slot_c3\")\n+\n+(define_insn_reservation \"ivc2_insn_p0\" 1\n+  (and (eq_attr \"vliw\" \"ivc2\")\n+       (eq_attr \"slots\" \"p0\"))\n+  \"ivc2_p0+ivc2_slot_p0\")\n+\n+(define_insn_reservation \"ivc2_insn_p0_p0s\" 1\n+  (and (eq_attr \"vliw\" \"ivc2\")\n+       (eq_attr \"slots\" \"p0_p0s\"))\n+  \"ivc2_p0+ivc2_slot_p0|ivc2_p0+ivc2_slot_p0s\")\n+\n+(define_insn_reservation \"ivc2_insn_p0_p1\" 1\n+  (and (eq_attr \"vliw\" \"ivc2\")\n+       (eq_attr \"slots\" \"p0_p1\"))\n+  \"ivc2_p0+ivc2_slot_p0|ivc2_p1+ivc2_slot_p1\")\n+\n+(define_insn_reservation \"ivc2_insn_p0s\" 1\n+  (and (eq_attr \"vliw\" \"ivc2\")\n+       (eq_attr \"slots\" \"p0s\"))\n+  \"ivc2_p0+ivc2_slot_p0s\")\n+\n+(define_insn_reservation \"ivc2_insn_p0s_p1\" 1\n+  (and (eq_attr \"vliw\" \"ivc2\")\n+       (eq_attr \"slots\" \"p0s_p1\"))\n+  \"ivc2_p0+ivc2_slot_p0s|ivc2_p1+ivc2_slot_p1\")\n+\n+(define_insn_reservation \"ivc2_insn_p1\" 1\n+  (and (eq_attr \"vliw\" \"ivc2\")\n+       (eq_attr \"slots\" \"p1\"))\n+  \"ivc2_p1+ivc2_slot_p1\")\n+\n+;; these run in C3 also, but when we're doing VLIW scheduling, they\n+;; only run in P0.\n+(define_insn_reservation \"ivc2_insn_cmov\" 1\n+  (and (eq_attr \"vliw\" \"ivc2\")\n+       (eq_attr \"intrinsic\" \"!none\"))\n+  \"ivc2_p0+ivc2_slot_p0\")\n+\n+\n+(exclusion_set \"ivc2_slot_c32\"\n+\t       \"ivc2_slot_p0,ivc2_slot_p0s\")\n+(exclusion_set \"ivc2_slot_p0\"\n+\t       \"ivc2_slot_p0s\")\n+(exclusion_set \"ivc2_slot_c16\"\n+\t       \"ivc2_slot_p0\")\n+(exclusion_set \"ivc2_slot_c16\"\n+\t       \"ivc2_slot_c32\")\n+\n+;; Non-IVC2 scheduling.\n+(define_automaton \"mep\")\n+(define_cpu_unit \"core,cop\" \"mep\")\n+\n+;; Latencies are the time between one insn entering the second pipeline\n+;; stage (E2, LD, A2 or V2) and the next instruction entering the same\n+;; stage.  When an instruction assigns to general registers, the default\n+;; latencies are for when the next instruction receives the register\n+;; through bypass 1.\n+\n+;; Arithmetic instructions that execute in a single stage.\n+(define_insn_reservation \"h1_int1\" 2\n+  (and (eq_attr \"slot\" \"!cop\")\n+       (eq_attr \"stall\" \"none\"))\n+  \"core\")\n+(define_bypass 1 \"h1_int1\" \"h1_int1,h1_ssarb\")\n+(define_bypass 1 \"h1_int1\" \"h1_store\" \"mep_store_data_bypass_p\")\n+\n+;; $sar can be read by an immediately following fsft or ldc.\n+(define_insn_reservation \"h1_ssarb\" 1\n+  (eq_attr \"stall\" \"ssarb\")\n+  \"core\")\n+\n+;; Arithmetic instructions that execute in two stages.\n+(define_insn_reservation \"h1_int2\" 2\n+  (eq_attr \"stall\" \"int2,fsft\")\n+  \"core\")\n+(define_bypass 1 \"h1_int2\" \"h1_int1,h1_ssarb\")\n+(define_bypass 1 \"h1_int2\" \"h1_store\" \"mep_store_data_bypass_p\")\n+\n+(define_insn_reservation \"h1_load\" 4\n+  (eq_attr \"stall\" \"load\")\n+  \"core\")\n+(define_bypass 3 \"h1_load\" \"h1_int1,h1_ssarb\")\n+(define_bypass 3 \"h1_load\" \"h1_store\" \"mep_store_data_bypass_p\")\n+\n+(define_insn_reservation \"h1_store\" 1\n+  (eq_attr \"stall\" \"store\")\n+  \"core\")\n+\n+(define_insn_reservation \"h1_ipipe_ldc\" 2\n+  (and (eq_attr \"stall\" \"ldc\")\n+       (ne (symbol_ref \"mep_ipipe_ldc_p(insn)\") (const_int 0)))\n+  \"core\")\n+(define_bypass 1 \"h1_ipipe_ldc\" \"h1_int1,h1_ssarb\")\n+(define_bypass 1 \"h1_ipipe_ldc\" \"h1_store\" \"mep_store_data_bypass_p\")\n+\n+(define_insn_reservation \"h1_apipe_ldc\" 2\n+  (and (eq_attr \"stall\" \"ldc\")\n+       (eq (symbol_ref \"mep_ipipe_ldc_p(insn)\") (const_int 0)))\n+  \"core\")\n+\n+;; 2 is correct for stc->ret and stc->fsft.  The most important remaining\n+;; case is stc->madd, which induces no stall.\n+(define_insn_reservation \"h1_stc\" 2\n+  (eq_attr \"stall\" \"stc\")\n+  \"core\")\n+(define_bypass 1 \"h1_stc\" \"h1_mul\")\n+\n+;; ??? Parameterised latency.\n+(define_insn_reservation \"h1_ldcb\" 5\n+  (eq_attr \"stall\" \"ldcb\")\n+  \"core\")\n+\n+(define_insn_reservation \"h1_stcb\" 1\n+  (eq_attr \"stall\" \"stcb\")\n+  \"core\")\n+\n+(define_insn_reservation \"h1_advck\" 6\n+  (eq_attr \"stall\" \"advck\")\n+  \"core\")\n+\n+(define_insn_reservation \"h1_mul\" 5\n+  (eq_attr \"stall\" \"mul,mulr\")\n+  \"core\")\n+(define_bypass 4 \"h1_mul\" \"h1_int1,h1_ssarb\")\n+(define_bypass 4 \"h1_mul\" \"h1_store\" \"mep_store_data_bypass_p\")\n+(define_bypass 1 \"h1_mul\" \"h1_mul\" \"mep_mul_hilo_bypass_p\")\n+\n+(define_insn_reservation \"h1_div\" 36\n+  (eq_attr \"stall\" \"div\")\n+  \"core\")\n+\n+(define_insn_reservation \"h1_cop\" 1\n+  (eq_attr \"slot\" \"cop\")\n+  \"cop\")\n+\f\n+(include \"predicates.md\")\n+(include \"constraints.md\")\n+(include \"intrinsics.md\")\n+\f\n+;; ::::::::::::::::::::\n+;; ::\n+;; :: Moves\n+;; ::\n+;; ::::::::::::::::::::\n+\n+(define_expand \"movqi\"\n+  [(set (match_operand:QI 0 \"general_operand\" \"\")\n+\t(match_operand:QI 1 \"general_operand\" \"\"))]\n+  \"\"\n+  \"\n+{\n+  if (mep_expand_mov (operands, QImode))\n+    DONE;\n+}\")\n+\n+;; The Idea here is to prefer the 16-bit tp-relative load, but to fall back\n+;; to the general 32-bit load rather than do silly things with spill regs.\n+(define_insn \"*movqi_tprel_load\"\n+  [(set (match_operand:QI 0 \"mep_tprel_operand\" \"=t,*r\")\n+\t(mem:QI (plus:SI (match_operand:SI 1 \"mep_tp_operand\" \"b,*r\")\n+\t\t\t (const:SI (unspec:SI [(match_operand:SI 2\n+\t\t\t\t\t\t\"symbolic_operand\" \"s,s\")]\n+\t\t\t\t\t      UNS_TPREL)))))]\n+  \"\"\n+  \"lb\\\\t%0, %%tpoff(%2)(%1)\"\n+  [(set_attr \"length\" \"2,4\")\n+   (set_attr \"stall\" \"load\")])\n+\n+(define_insn \"*movqi_tprel_store\"\n+  [(set (mem:QI (plus:SI (match_operand:SI 0 \"mep_tp_operand\" \"b,*r\")\n+\t\t\t (const:SI (unspec:SI [(match_operand:SI 1\n+\t\t\t\t\t\t\"symbolic_operand\" \"s,s\")]\n+\t\t\t\t\t      UNS_TPREL))))\n+\t(match_operand:QI 2 \"mep_tprel_operand\" \"t,*r\"))]\n+  \"\"\n+  \"sb\\\\t%2, %%tpoff(%1)(%0)\"\n+  [(set_attr \"length\" \"2,4\")\n+   (set_attr \"stall\" \"store\")])\n+\n+(define_insn \"*movqi_internal\"\n+  [(set (match_operand:QI 0 \"nonimmediate_operand\" \"=r,r, r,m,r,c,r,y,r,er,ex,em,Y\")\n+\t(match_operand:QI 1 \"general_operand\" \" r,n,rm,r,c,r,y,r,er,r,ex,Y,em\"))]\n+  \"mep_mov_ok (operands, QImode)\"\n+  \"@\n+   mov\\\\t%0, %1\n+   mov\\\\t%0, %1\n+   lb\\\\t%0, %1\n+   sb\\\\t%1, %0\n+   ldc\\\\t%0, %1\n+   stc\\\\t%1, %0\n+   cmovc\\\\t%0, %1\n+   cmovc\\\\t%0, %1\n+   cmov\\\\t%0, %1\n+   cmov\\\\t%0, %1\n+   %<\\\\t%0, %M1\n+   lbcpa\\\\t%0, %P1\n+   sbcpa\\\\t%1, %P0\"\n+  [(set_attr \"length\" \"2,2,*,*,2,2,4,4,4,4,*,4,4\")\n+   (set_attr \"intrinsic\" \"*,*,*,*,*,*,cmovc2,cmovc1,cmov2,cmov1,cmov,*,*\")\n+   (set_attr \"stall\"  \"*,*,load,store,ldc,stc,*,*,*,*,*,load,store\")\n+   (set_attr \"memop\"  \"*,*,core1,core0,*,*,*,*,*,*,*,*,*\")])\n+\n+(define_expand \"movhi\"\n+  [(set (match_operand:HI 0 \"general_operand\" \"\")\n+\t(match_operand:HI 1 \"general_operand\" \"\"))]\n+  \"\"\n+  \"\n+{\n+  if (mep_expand_mov (operands, HImode))\n+    DONE;\n+}\")\n+\n+(define_insn \"*movhi_tprel_load\"\n+  [(set (match_operand:HI 0 \"mep_tprel_operand\" \"=t,*r\")\n+\t(mem:HI (plus:SI (match_operand:SI 1 \"mep_tp_operand\" \"b,*r\")\n+\t\t\t (const:SI (unspec:SI [(match_operand:SI 2\n+\t\t\t\t\t\t\"symbolic_operand\" \"s,s\")]\n+\t\t\t\t\t      UNS_TPREL)))))]\n+  \"\"\n+  \"lh\\\\t%0, %%tpoff(%2)(%1)\"\n+  [(set_attr \"length\" \"2,4\")\n+   (set_attr \"stall\" \"load\")])\n+\n+(define_insn \"*movhi_tprel_store\"\n+  [(set (mem:HI (plus:SI (match_operand:SI 0 \"mep_tp_operand\" \"b,*r\")\n+\t\t\t (const:SI (unspec:SI [(match_operand:SI 1\n+\t\t\t\t\t\t\"symbolic_operand\" \"s,s\")]\n+\t\t\t\t\t      UNS_TPREL))))\n+\t(match_operand:HI 2 \"mep_tprel_operand\" \"t,*r\"))]\n+  \"\"\n+  \"sh\\\\t%2, %%tpoff(%1)(%0)\"\n+  [(set_attr \"length\" \"2,4\")\n+   (set_attr \"stall\" \"store\")])\n+\n+(define_insn \"*movhi_internal\"\n+  [(set (match_operand:HI 0 \"nonimmediate_operand\" \"=r,r,r,r,m,r,c,r,y,r,er,ex,em,Y\")\n+\t(match_operand:HI 1 \"general_operand\" \" r,S,n,m,r,c,r,y,r,er,r,ex,Y,em\"))]\n+  \"mep_mov_ok (operands, HImode)\"\n+  \"@\n+   mov\\\\t%0, %1\n+   mov\\\\t%0, %I1\n+   mov\\\\t%0, %I1\n+   lh\\\\t%0, %1\n+   sh\\\\t%1, %0\n+   ldc\\\\t%0, %1\n+   stc\\\\t%1, %0\n+   cmovc\\\\t%0, %1\n+   cmovc\\\\t%0, %1\n+   cmov\\\\t%0, %1\n+   cmov\\\\t%0, %1\n+   %<\\\\t%0, %M1\n+   lhcpa\\\\t%0, %P1\n+   shcpa\\\\t%1, %P0\"\n+  [(set_attr \"length\" \"2,2,4,*,*,2,2,4,4,4,4,*,4,4\")\n+   (set_attr \"intrinsic\" \"*,*,*,*,*,*,*,cmovc2,cmovc1,cmov2,cmov1,cmov,*,*\")\n+   (set_attr \"stall\"  \"*,*,*,load,store,ldc,stc,*,*,*,*,*,load,store\")\n+   (set_attr \"memop\"  \"*,*,*,core1,core0,*,*,*,*,*,*,*,*,*\")])\n+\n+(define_expand \"movsi\"\n+  [(set (match_operand:SI 0 \"nonimmediate_operand\" \"\")\n+\t(match_operand:SI 1 \"general_operand\" \"\"))]\n+  \"\"\n+  \"\n+{\n+  if (mep_expand_mov (operands, SImode))\n+    DONE;\n+}\")\n+\n+(define_insn \"*movsi_tprel_load\"\n+  [(set (match_operand:SI 0 \"mep_tprel_operand\" \"=t,*r\")\n+\t(mem:SI (plus:SI (match_operand:SI 1 \"mep_tp_operand\" \"b,*r\")\n+\t\t\t (const:SI (unspec:SI [(match_operand:SI 2\n+\t\t\t\t\t\t\"symbolic_operand\" \"s,s\")]\n+\t\t\t\t\t      UNS_TPREL)))))]\n+  \"\"\n+  \"lw\\\\t%0, %%tpoff(%2)(%1)\"\n+  [(set_attr \"length\" \"2,4\")\n+   (set_attr \"stall\" \"load\")])\n+\n+(define_insn \"*movsi_tprel_store\"\n+  [(set (mem:SI (plus:SI (match_operand:SI 0 \"mep_tp_operand\" \"b,*r\")\n+\t\t\t (const:SI (unspec:SI [(match_operand:SI 1\n+\t\t\t\t\t\t\"symbolic_operand\" \"s,s\")]\n+\t\t\t\t\t      UNS_TPREL))))\n+\t(match_operand:SI 2 \"mep_tprel_operand\" \"t,*r\"))]\n+  \"\"\n+  \"sw\\\\t%2, %%tpoff(%1)(%0)\"\n+  [(set_attr \"length\" \"2,4\")\n+   (set_attr \"stall\" \"store\")])\n+\n+(define_insn \"movsi_topsym_s\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+\t(high:SI (match_operand:SI 1 \"symbolic_operand\" \"s\")))]\n+  \"\"\n+  \"movh\\\\t%0, %%hi(%1)\"\n+  [(set_attr \"length\" \"4\")])\n+\n+(define_insn \"movsi_botsym_s\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+\t(lo_sum:SI (match_operand:SI 1 \"register_operand\" \"0\")\n+\t\t   (match_operand:SI 2 \"symbolic_operand\" \"s\")))]\n+  \"\"\n+  \"add3\\\\t%0, %1, %%lo(%2)\"\n+  [(set_attr \"length\" \"4\")])\n+\n+\n+\n+(define_insn \"cmovh_getsub\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+\t(subreg:SI (match_operand:DI 1 \"register_operand\" \"er\") 4))]\n+  \"0 && TARGET_64BIT_CR_REGS\"\n+  \"cmovh\\\\t%0, %1\"\n+  [(set_attr \"intrinsic\" \"cmovh2\")\n+   (set_attr \"length\" \"4\")])\n+\n+(define_insn \"*movsi_internal\"\n+  [(set (match_operand:SI 0 \"mep_movdest_operand\"\n+\t    \"=r,r,r,r,r, t,t,r,r,r,Z,m,r,c,r,y,r, er,ex,em,U \")\n+\t(match_operand:SI 1 \"general_operand\"\n+\t    \" r,S,I,J,OW,K,s,i,Z,m,r,r,c,r,y,r,er,r, ex,U, em\"))]\n+  \"mep_mov_ok (operands, SImode)\"\n+  \"@\n+   mov\\\\t%0, %1\n+   mov\\\\t%0, %I1\n+   mov\\\\t%0, %I1\n+   movu\\\\t%0, %J1\n+   movh\\\\t%0, %h1\n+   movu\\\\t%0, %x1\n+   movu\\\\t%0, %1\n+   #\n+   ldcb\\\\t%0, %1\n+   lw\\\\t%0, %1\n+   stcb\\\\t%1, %0\n+   sw\\\\t%1, %0\n+   ldc\\\\t%0, %1\n+   stc\\\\t%1, %0\n+   cmovc\\\\t%0, %1\n+   cmovc\\\\t%0, %1\n+   cmov\\\\t%0, %1\n+   cmov\\\\t%0, %1\n+   %<\\\\t%0, %M1\n+   lwcp\\\\t%0, %1\n+   swcp\\\\t%1, %0\"\n+  [(set_attr \"length\" \"2,2,4,4,4,4,4,*,4,*,4,*,2,2,4,4,4,4,4,*,*\")\n+   (set_attr \"intrinsic\" \"*,*,*,*,*,*,*,*,*,*,*,*,*,*,cmovc2,cmovc1,cmov2,cmov1,cmov,*,*\")\n+   (set_attr \"stall\"  \"*,*,*,*,*,*,*,*,ldcb,load,stcb,store,ldc,stc,*,*,*,*,*,load,store\")\n+   (set_attr \"memop\"  \"*,*,*,*,*,*,*,*,*,core1,*,core0,*,*,*,*,*,*,*,cop1,cop0\")\n+   (set_attr \"slot\"   \"*,*,*,*,*,*,*,multi,*,*,*,*,*,*,*,*,*,*,*,*,*\")])\n+\n+(define_split\n+  [(set (match_operand:SI 0 \"register_operand\" \"\")\n+        (match_operand:SI 1 \"const_int_operand\" \"\"))]\n+  \"mep_split_mov (operands, 0)\"\n+  [(set (match_dup 0) (match_dup 2))\n+   (set (match_dup 0) (ior:SI (match_dup 0) (match_dup 3)))]\n+  \"\n+{\n+  HOST_WIDE_INT value;\n+  int lo, hi;\n+\n+  value = INTVAL (operands[1]);\n+\n+  lo = value & 0xffff;\n+  hi = trunc_int_for_mode (value & 0xffff0000, SImode);\n+\n+  operands[2] = GEN_INT (hi);\n+  operands[3] = GEN_INT (lo);\n+}\")\n+\n+(define_split\n+  [(set (match_operand:SI 0 \"register_operand\" \"\")\n+        (match_operand:SI 1 \"immediate_operand\" \"\"))]\n+  \"mep_split_mov (operands, 1)\"\n+  [(set (match_dup 0) (high:SI (match_dup 1)))\n+   (set (match_dup 0) (lo_sum:SI (match_dup 0) (match_dup 1)))]\n+  \"\")\n+\n+;; ??? What purpose do these two serve that high+lo_sum do not?\n+(define_insn \"movsi_topsym_u\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+\t(and:SI (match_operand:SI 1 \"symbolic_operand\" \"s\")\n+\t\t(const_int -65536)))]\n+  \"\"\n+  \"movh\\\\t%0, %%uhi(%1)\"\n+  [(set_attr \"length\" \"4\")])\n+\n+(define_insn \"movsi_botsym_u\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+\t(ior:SI (match_operand:SI 1 \"register_operand\" \"0\")\n+\t\t(and:SI (match_operand:SI 2 \"symbolic_operand\" \"s\")\n+\t\t\t(const_int 65535))))]\n+  \"\"\n+  \"or3\\\\t%0, %1, %%lo(%2)\"\n+  [(set_attr \"length\" \"4\")])\n+\n+(define_expand \"movdi\"\n+  [(set (match_operand:DI 0 \"\" \"\")\n+\t(match_operand:DI 1 \"\" \"\"))]\n+  \"\"\n+  \"\n+{\n+  if (mep_expand_mov (operands, DImode))\n+    DONE;\n+}\")\n+\n+(define_insn \"*movdi_internal_32\"\n+  [(set (match_operand:DI 0 \"mep_movdest_operand\" \"= r,m,r,c,r,er,ex,em,U\")\n+\t(match_operand:DI 1 \"general_operand\"     \"rim,r,c,r,er,r,ex,U,em\"))]\n+  \"TARGET_32BIT_CR_REGS && mep_mov_ok (operands, DImode)\"\n+  \"#\"\n+  [(set_attr \"slot\" \"multi\")])\n+\n+(define_insn \"*movdi_internal_64\"\n+  [(set (match_operand:DI 0 \"mep_movdest_operand\" \"=r,r,m,r,c,r,er,ex,em,U\")\n+\t(match_operand:DI 1 \"general_operand\"     \"r,im,r,c,r,er,r,ex,U,em\"))]\n+  \"TARGET_64BIT_CR_REGS && mep_mov_ok (operands, DImode)\"\n+  \"@\n+   #\n+   #\n+   #\n+   #\n+   #\n+   #\n+   #\n+   %<\\\\t%0, %M1\n+   lmcp\\\\t%0, %1\n+   smcp\\\\t%1, %0\"\n+  [(set_attr \"slot\"  \"multi,multi,multi,multi,multi,multi,multi,*,*,*\")\n+   (set_attr \"intrinsic\" \"*,*,*,*,*,*,*,cmov,*,*\")\n+   (set_attr \"memop\" \"*,*,*,*,*,*,*,cop0,cop1,cop0\")\n+   (set_attr \"stall\" \"*,*,*,*,*,*,*,*,load,store\")])\n+\n+(define_insn \"*movdi_cop_postinc\"\n+  [(parallel [(set (match_operand:DI 0 \"register_operand\" \"=em\")\n+\t\t   (mem:DI (reg:SI SP_REGNO)))\n+\t      (set (reg:SI SP_REGNO)\n+\t\t   (plus:SI (reg:SI SP_REGNO)\n+\t\t\t    (const_int 8)))\n+\t      ]\n+\t     )]\n+  \"TARGET_COP\"\n+  \"lmcpi\\\\t%0,($sp+)\"\n+  [(set_attr \"length\" \"2\")])\n+\n+(define_insn \"*movdi_cop_postinc\"\n+  [(parallel [(set (match_operand:DI 0 \"register_operand\" \"=em\")\n+\t\t   (mem:DI (match_operand:SI 2 \"register_operand\" \"r\")))\n+\t      (set (match_operand:SI 1 \"register_operand\" \"=0\")\n+\t\t   (plus:SI (match_operand:SI 3 \"register_operand\" \"0\")\n+\t\t\t    (const_int 8)))\n+\t      ]\n+\t     )]\n+  \"TARGET_COP\"\n+  \"lmcpi\\\\t%0,(%1+)\"\n+  [(set_attr \"length\" \"2\")])\n+\n+(define_insn \"*cmovh_set\"\n+  [(set (zero_extract:SI (match_operand:DI 0 \"register_operand\" \"+er\")\n+\t\t\t (const_int 32)\n+\t\t\t (const_int 32))\n+\t(match_operand:SI 1 \"register_operand\" \"r\"))]\n+  \"TARGET_64BIT_CR_REGS\"\n+  \"cmovh\\\\t%0, %1\"\n+  [(set_attr \"intrinsic\" \"cmovh1\")\n+   (set_attr \"length\" \"4\")])\n+\n+(define_insn \"cmovh_get\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+\t(zero_extract:SI (match_operand:DI 1 \"register_operand\" \"er\")\n+\t\t\t (const_int 32)\n+\t\t\t (const_int 32)))]\n+  \"TARGET_64BIT_CR_REGS\"\n+  \"cmovh\\\\t%0, %1\"\n+  [(set_attr \"intrinsic\" \"cmovh2\")\n+   (set_attr \"length\" \"4\")])\n+\n+(define_split\n+  [(set (match_operand:DI 0 \"mep_movdest_operand\" \"\")\n+        (match_operand:DI 1 \"general_operand\" \"\"))]\n+  \"reload_completed && mep_multi_slot (insn)\"\n+  [(set (match_dup 2) (match_dup 3))\n+   (set (match_dup 4) (match_dup 5))]\n+  \"mep_split_wide_move (operands, DImode);\")\n+\n+;; Floating Point Moves\n+\n+(define_expand \"movsf\"\n+  [(set (match_operand:SF 0 \"nonimmediate_operand\" \"\")\n+\t(match_operand:SF 1 \"general_operand\" \"\"))]\n+  \"\"\n+  \"\n+{\n+  if (mep_expand_mov (operands, SFmode))\n+    DONE;\n+}\")\n+\n+(define_insn \"*movsf_tprel_load\"\n+  [(set (match_operand:SF 0 \"mep_tprel_operand\" \"=t,*r\")\n+\t(mem:SF (plus:SI (match_operand:SI 1 \"mep_tp_operand\" \"b,*r\")\n+\t\t\t (const:SI (unspec:SI [(match_operand:SI 2\n+\t\t\t\t\t\t\"symbolic_operand\" \"s,s\")]\n+\t\t\t\t\t      UNS_TPREL)))))]\n+  \"\"\n+  \"lw\\\\t%0, %%tpoff(%2)(%1)\"\n+  [(set_attr \"length\" \"2,4\")\n+   (set_attr \"stall\" \"load\")])\n+\n+(define_insn \"*movsf_tprel_store\"\n+  [(set (mem:SF (plus:SI (match_operand:SI 0 \"mep_tp_operand\" \"b,*r\")\n+\t\t\t (const:SI (unspec:SI [(match_operand:SI 1\n+\t\t\t\t\t\t\"symbolic_operand\" \"s,s\")]\n+\t\t\t\t\t      UNS_TPREL))))\n+\t(match_operand:SF 2 \"mep_tprel_operand\" \"t,*r\"))]\n+  \"\"\n+  \"sw\\\\t%2, %%tpoff(%1)(%0)\"\n+  [(set_attr \"length\" \"2,4\")\n+   (set_attr \"stall\" \"store\")])\n+\n+(define_insn \"*movsf_internal\"\n+  [(set (match_operand:SF 0 \"mep_movdest_operand\"\n+\t    \"=r,r,r,r,Z,m,r,c,r,y,r,er,ex,em,U\")\n+\t(match_operand:SF 1 \"general_operand\"\n+\t    \" r,F,Z,m,r,r,c,r,y,r,er,r,ex,U,em\"))]\n+  \"mep_mov_ok (operands, SFmode)\"\n+  \"@\n+   mov\\\\t%0, %1\n+   #\n+   ldcb\\\\t%0, %1\n+   lw\\\\t%0, %1\n+   stcb\\\\t%1, %0\n+   sw\\\\t%1, %0\n+   ldc\\\\t%0, %1\n+   stc\\\\t%1, %0\n+   cmovc\\\\t%0, %1\n+   cmovc\\\\t%0, %1\n+   cmov\\\\t%0, %1\n+   cmov\\\\t%0, %1\n+   %<\\\\t%0, %M1\n+   lwcp\\\\t%0, %1\n+   swcp\\\\t%1, %0\"\n+  [(set_attr \"length\" \"2,*,2,*,2,*,2,2,*,*,4,4,*,*,*\")\n+   (set_attr \"intrinsic\" \"*,*,*,*,*,*,*,*,cmovc2,cmovc1,cmov2,cmov1,cmov,*,*\")\n+   (set_attr \"stall\"  \"*,*,ldcb,load,stcb,store,ldc,stc,*,*,*,*,*,load,store\")\n+   (set_attr \"memop\"  \"*,*,*,core1,*,core0,*,*,*,*,*,*,*,cop1,cop0\")])\n+\n+(define_split\n+  [(set (match_operand:SF 0 \"register_operand\" \"\")\n+        (match_operand:SF 1 \"const_double_operand\" \"\"))]\n+  \"reload_completed\"\n+  [(const_int 0)]\n+  \"\n+{\n+  REAL_VALUE_TYPE rv;\n+  HOST_WIDE_INT value;\n+  HOST_WIDE_INT lo, hi;\n+  rtx out;\n+\n+  REAL_VALUE_FROM_CONST_DOUBLE (rv, operands[1]);\n+  REAL_VALUE_TO_TARGET_SINGLE (rv, value);\n+\n+  lo = value & 0xffff;\n+  hi = trunc_int_for_mode (value & 0xffff0000, SImode);\n+\n+  out = gen_rtx_REG (SImode, REGNO (operands[0]));\n+  emit_move_insn (out, GEN_INT (hi));\n+  if (lo != 0)\n+    emit_insn (gen_iorsi3 (out, out, GEN_INT (lo)));\n+  DONE;\n+}\")\n+\n+(define_expand \"movdf\"\n+  [(set (match_operand:DF 0 \"\" \"\")\n+\t(match_operand:DF 1 \"\" \"\"))]\n+  \"\"\n+  \"\n+{\n+  if (mep_expand_mov (operands, DFmode))\n+    DONE;\n+}\")\n+\n+(define_insn \"*movdf_internal_32\"\n+  [(set (match_operand:DF 0 \"mep_movdest_operand\" \"= r,m,r,c,r,er,ex,em,U\")\n+\t(match_operand:DF 1 \"general_operand\"     \"rFm,r,c,r,er,r,ex,U,em\"))]\n+  \"TARGET_32BIT_CR_REGS && mep_mov_ok (operands, DFmode)\"\n+  \"#\"\n+  [(set_attr \"slot\" \"multi\")])\n+\n+(define_insn \"*movdf_internal_64\"\n+  [(set (match_operand:DF 0 \"mep_movdest_operand\" \"= r,m,r,c,r,er,ex,em,U\")\n+\t(match_operand:DF 1 \"general_operand\"     \"rFm,r,c,r,er,r,ex,U,em\"))]\n+  \"TARGET_64BIT_CR_REGS && mep_mov_ok (operands, DFmode)\"\n+  \"@\n+   #\n+   #\n+   #\n+   #\n+   #\n+   #\n+   %<\\\\t%0, %M1\n+   lmcp\\\\t%0, %1\n+   smcp\\\\t%1, %0\"\n+  [(set_attr \"slot\"  \"multi,multi,multi,multi,multi,multi,*,*,*\")\n+   (set_attr \"intrinsic\" \"*,*,*,*,*,*,cmov,*,*\")\n+   (set_attr \"memop\" \"*,*,*,*,*,*,*,cop1,cop0\")\n+   (set_attr \"stall\" \"*,*,*,*,*,*,*,load,store\")])\n+\n+(define_split\n+  [(set (match_operand:DF 0 \"mep_movdest_operand\" \"\")\n+        (match_operand:DF 1 \"general_operand\" \"\"))]\n+  \"reload_completed && mep_multi_slot (insn)\"\n+  [(set (match_dup 2) (match_dup 3))\n+   (set (match_dup 4) (match_dup 5))]\n+  \"mep_split_wide_move (operands, DFmode);\")\n+\n+\f\n+(define_insn \"*lbcpa\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=em\")\n+\t(sign_extend:SI (mem:QI (match_operand:SI 2 \"register_operand\" \"1\"))))\n+   (set (match_operand:SI 1 \"register_operand\" \"=r\")\n+\t(plus:SI (match_dup 2)\n+\t\t (match_operand:SI 3 \"cgen_h_sint_8a1_immediate\" \"\")))]\n+  \"TARGET_COP && reload_completed\"\n+  \"lbcpa\\t%0, (%1+), %3\"\n+  [(set_attr \"length\" \"4\")\n+   (set_attr \"stall\" \"load\")])\n+\n+(define_insn \"*sbcpa\"\n+  [(set (mem:QI (match_operand:SI 1 \"register_operand\" \"0\"))\n+\t(match_operand:QI 2 \"register_operand\" \"em\"))\n+   (set (match_operand:SI 0 \"register_operand\" \"=r\")\n+\t(plus:SI (match_dup 1)\n+\t\t (match_operand:SI 3 \"cgen_h_sint_8a1_immediate\" \"\")))]\n+  \"TARGET_COP && reload_completed\"\n+  \"sbcpa\\t%2, (%0+), %3\"\n+  [(set_attr \"length\" \"4\")\n+   (set_attr \"stall\" \"store\")])\n+\n+(define_insn \"*lhcpa\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=em\")\n+\t(sign_extend:SI (mem:HI (match_operand:SI 2 \"register_operand\" \"1\"))))\n+   (set (match_operand:SI 1 \"register_operand\" \"=r\")\n+\t(plus:SI (match_dup 2)\n+\t\t (match_operand:SI 3 \"cgen_h_sint_7a2_immediate\" \"\")))]\n+  \"TARGET_COP && reload_completed\"\n+  \"lhcpa\\t%0, (%1+), %3\"\n+  [(set_attr \"length\" \"4\")\n+   (set_attr \"stall\" \"load\")])\n+\n+(define_insn \"*shcpa\"\n+  [(set (mem:HI (match_operand:SI 1 \"register_operand\" \"0\"))\n+\t(match_operand:HI 2 \"register_operand\" \"em\"))\n+   (set (match_operand:SI 0 \"register_operand\" \"=r\")\n+\t(plus:SI (match_dup 1)\n+\t\t (match_operand:SI 3 \"cgen_h_sint_7a2_immediate\" \"\")))]\n+  \"TARGET_COP && reload_completed\"\n+  \"shcpa\\t%2, (%0+), %3\"\n+  [(set_attr \"length\" \"4\")\n+   (set_attr \"stall\" \"store\")])\n+\n+(define_insn \"*lwcpi\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=em\")\n+\t(mem:SI (match_operand:SI 2 \"register_operand\" \"1\")))\n+   (set (match_operand:SI 1 \"register_operand\" \"=r\")\n+\t(plus:SI (match_dup 2)\n+\t\t (const_int 4)))]\n+  \"TARGET_COP && reload_completed\"\n+  \"lwcpi\\t%0, (%1+)\"\n+  [(set_attr \"length\" \"2\")\n+   (set_attr \"stall\" \"load\")])\n+\n+(define_insn \"*lwcpa\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=em\")\n+\t(mem:SI (match_operand:SI 2 \"register_operand\" \"1\")))\n+   (set (match_operand:SI 1 \"register_operand\" \"=r\")\n+\t(plus:SI (match_dup 2)\n+\t\t (match_operand:SI 3 \"cgen_h_sint_6a4_immediate\" \"\")))]\n+  \"TARGET_COP && reload_completed\"\n+  \"lwcpa\\t%0, (%1+), %3\"\n+  [(set_attr \"length\" \"4\")\n+   (set_attr \"stall\" \"load\")])\n+\n+(define_insn \"*swcpi\"\n+  [(set (mem:SI (match_operand:SI 1 \"register_operand\" \"0\"))\n+\t(match_operand:SI 2 \"register_operand\" \"em\"))\n+   (set (match_operand:SI 0 \"register_operand\" \"=r\")\n+\t(plus:SI (match_dup 1)\n+\t\t (const_int 4)))]\n+  \"TARGET_COP && reload_completed\"\n+  \"swcpi\\t%2, (%0+)\"\n+  [(set_attr \"length\" \"2\")\n+   (set_attr \"stall\" \"store\")])\n+\n+(define_insn \"*swcpa\"\n+  [(set (mem:SI (match_operand:SI 1 \"register_operand\" \"0\"))\n+\t(match_operand:SI 2 \"register_operand\" \"em\"))\n+   (set (match_operand:SI 0 \"register_operand\" \"=r\")\n+\t(plus:SI (match_dup 1)\n+\t\t (match_operand:SI 3 \"cgen_h_sint_6a4_immediate\" \"\")))]\n+  \"TARGET_COP && reload_completed\"\n+  \"swcpa\\t%2, (%0+), %3\"\n+  [(set_attr \"length\" \"4\")\n+   (set_attr \"stall\" \"store\")])\n+\n+(define_peephole2\n+  [(set (match_operand:SI 0 \"register_operand\" \"\")\n+\t(plus:SI (match_dup 0)\n+\t\t (match_operand:SI 1 \"cgen_h_sint_8a1_immediate\" \"\")))]\n+  \"TARGET_COP && mep_use_post_modify_p (insn, operands[0], operands[1])\"\n+  [(const_int 0)]\n+{\n+  emit_note (NOTE_INSN_DELETED);\n+  DONE;\n+})\n+\f\n+;; ::::::::::::::::::::\n+;; ::\n+;; :: Reloads\n+;; ::\n+;; ::::::::::::::::::::\n+\n+(define_expand \"reload_insi\"\n+  [(set (match_operand:SI 0 \"mep_reload_operand\" \"\")\n+        (match_operand:SI 1 \"mep_reload_operand\" \"r\"))\n+   (clobber (match_operand:SI 2 \"register_operand\" \"=&r\"))]\n+  \"\"\n+  \"\n+{\n+  mep_expand_reload (operands, SImode);\n+  DONE;\n+}\")\n+\n+(define_expand \"reload_outsi\"\n+  [(set (match_operand:SI 0 \"mep_reload_operand\" \"=r\")\n+        (match_operand:SI 1 \"mep_reload_operand\" \"\"))\n+   (clobber (match_operand:SI 2 \"register_operand\" \"=&r\"))]\n+  \"\"\n+  \"\n+{\n+  mep_expand_reload (operands, SImode);\n+  DONE;\n+}\")\n+\n+\f\n+;; ::::::::::::::::::::\n+;; ::\n+;; :: Conversions\n+;; ::\n+;; ::::::::::::::::::::\n+\n+(define_insn \"extendqisi2\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r,r,em\")\n+\t(sign_extend:SI\n+\t  (match_operand:QI 1 \"nonimmediate_operand\" \"0,m,Y\")))]\n+  \"\"\n+  \"@\n+   extb\\\\t%0\n+   lb\\\\t%0, %1\n+   lbcpa\\\\t%0, %P1\"\n+  [(set_attr \"length\" \"2,*,*\")\n+   (set_attr \"stall\"  \"*,load,load\")\n+   (set_attr \"memop\"  \"*,core1,cop1\")])\n+\n+(define_insn \"extendhisi2\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r,r,em\")\n+\t(sign_extend:SI\n+\t  (match_operand:HI 1 \"nonimmediate_operand\" \"0,m,Y\")))]\n+  \"\"\n+  \"@\n+   exth\\\\t%0\n+   lh\\\\t%0, %1\n+   lhcpa\\\\t%0, %P1\"\n+  [(set_attr \"length\" \"2,*,*\")\n+   (set_attr \"stall\"  \"*,load,load\")\n+   (set_attr \"memop\"  \"*,core1,cop1\")])\n+\n+(define_insn \"zero_extendqisi2\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r,r,r\")\n+\t(zero_extend:SI\n+\t  (match_operand:QI 1 \"nonimmediate_operand\" \"0,r,m\")))]\n+  \"\"\n+  \"@\n+   extub\\\\t%0\n+   and3\\\\t%0, %1, 255\n+   lbu\\\\t%0, %1\"\n+  [(set_attr \"length\" \"2,4,*\")\n+   (set_attr \"stall\" \"*,*,load\")\n+   (set_attr \"memop\"  \"*,*,core1\")])\n+\n+(define_insn \"zero_extendhisi2\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r,r,r\")\n+\t(zero_extend:SI\n+\t  (match_operand:HI 1 \"nonimmediate_operand\" \"0,r,m\")))]\n+  \"\"\n+  \"@\n+   extuh\\\\t%0\n+   and3\\\\t%0, %1, 65535\n+   lhu\\\\t%0, %1\"\n+  [(set_attr \"length\" \"2,4,*\")\n+   (set_attr \"stall\" \"*,*,load\")\n+   (set_attr \"memop\"  \"*,*,core1\")])\n+\f\n+;; ::::::::::::::::::::\n+;; ::\n+;; :: 32 bit Integer arithmetic\n+;; ::\n+;; ::::::::::::::::::::\n+\n+(define_insn \"addsi3\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r,r,r\")\n+\t(plus:SI (match_operand:SI 1 \"register_operand\" \"%r,0,r\")\n+\t\t (match_operand:SI 2 \"mep_add_operand\" \"r,L,IT\")))]\n+  \"\"\n+  \"@\n+   add3\\\\t%0, %1, %2\n+   add\\\\t%0, %2\n+   add3\\\\t%0, %1, %I2\"\n+  [(set (attr \"length\")\n+\t(if_then_else (eq_attr \"alternative\" \"2\")\n+\t  (if_then_else (and (match_operand:SI 1 \"mep_sp_operand\" \"\")\n+\t\t\t     (match_operand:SI 2 \"mep_imm7a4_operand\" \"\"))\n+\t    (const_int 2)\n+\t    (const_int 4))\n+\t  (const_int 2)))])\n+\n+;; The intention here is to combine the 16-bit add with the 16-bit\n+;; move to create a 32-bit add.  It's the same size, but takes one\n+;; less machine cycle.  It will happen to match a 32-bit add with a\n+;; 16-bit move also, but gcc shouldn't be doing that ;)\n+(define_peephole2\n+  [(set (match_operand:SI 0 \"register_operand\" \"\")\n+\t(plus:SI (match_operand:SI 1 \"register_operand\" \"\")\n+\t\t (match_operand:SI 2 \"immediate_operand\" \"\")))\n+   (set (match_operand:SI 3 \"register_operand\" \"\")\n+\t(match_operand:SI 4 \"register_operand\" \"\"))]\n+  \"REGNO (operands[0]) == REGNO (operands[1])\n+   && REGNO (operands[0]) == REGNO (operands[4])\n+   && GR_REGNO_P (REGNO (operands[3]))\n+   && dead_or_set_p (peep2_next_insn (1), operands[4])\"\n+  [(set (match_dup 3)\n+\t(plus:SI (match_dup 1)\n+\t\t (match_dup 2)))]\n+  \"\")\n+\n+(define_insn \"subsi3\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+\t(minus:SI (match_operand:SI 1 \"register_operand\" \"0\")\n+\t\t  (match_operand:SI 2 \"register_operand\" \"r\")))]\n+  \"\"\n+  \"sub\\\\t%0, %2\"\n+  [(set_attr \"length\" \"2\")])\n+\n+(define_expand \"mulsi3\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"\")\n+        (mult:SI (match_operand:SI 1 \"register_operand\" \"\")\n+                 (match_operand:SI 2 \"register_operand\" \"\")))]\n+  \"TARGET_OPT_MULT || TARGET_COPRO_MULT\"\n+{\n+  emit_insn (gen_mulsi3_1 (operands[0], operands[1], operands[2]));\n+  DONE;\n+})\n+\n+;; Generated by mep_reuse_lo_p when no GPR destination is needed.\n+(define_insn \"mulsi3_lo\"\n+  [(set (match_operand:SI 0 \"mep_lo_operand\" \"=l\")\n+\t(mult:SI (match_operand:SI 1 \"register_operand\" \"r\")\n+\t\t (match_operand:SI 2 \"register_operand\" \"r\")))\n+   (clobber (match_scratch:SI 3 \"=h\"))]\n+  \"TARGET_OPT_MULT && reload_completed\"\n+  \"mul\\\\t%1, %2\"\n+  [(set_attr \"length\" \"2\")\n+   (set_attr \"stall\" \"mul\")])\n+\n+;; Generated by mep_reuse_lo_p when both destinations of a mulr\n+;; are needed.\n+(define_insn \"mulsi3r\"\n+  [(set (match_operand:SI 0 \"mep_lo_operand\" \"=l\")\n+\t(mult:SI (match_operand:SI 2 \"register_operand\" \"1\")\n+\t\t (match_operand:SI 3 \"register_operand\" \"r\")))\n+   (set (match_operand:SI 1 \"register_operand\" \"=r\")\n+\t(mult:SI (match_dup 2)\n+\t\t (match_dup 3)))\n+   (clobber (match_scratch:SI 4 \"=h\"))]\n+  \"TARGET_OPT_MULT && reload_completed\"\n+  \"mulr\\\\t%2, %3\"\n+  [(set_attr \"length\" \"2\")\n+   (set_attr \"stall\" \"mulr\")])\n+\n+(define_insn \"mulsi3_1\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+\t(mult:SI (match_operand:SI 1 \"register_operand\" \"%0\")\n+\t\t (match_operand:SI 2 \"register_operand\" \"r\")))\n+   (clobber (match_scratch:SI 3 \"=l\"))\n+   (clobber (match_scratch:SI 4 \"=h\"))]\n+  \"TARGET_OPT_MULT\"\n+  \"mulr\\\\t%1, %2\"\n+  [(set_attr \"length\" \"2\")\n+   (set_attr \"stall\" \"mulr\")])\n+\n+(define_expand \"mulsidi3\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"\")\n+\t(mult:DI (sign_extend:DI (match_operand:SI 1 \"register_operand\" \"\"))\n+\t\t (sign_extend:DI (match_operand:SI 2 \"register_operand\" \"\"))))]\n+  \"TARGET_OPT_MULT\"\n+  \"\n+{\n+  rtx hi = gen_reg_rtx (SImode);\n+  rtx lo = gen_reg_rtx (SImode);\n+\n+  emit_insn (gen_mulsidi3_i (hi, lo, operands[1], operands[2]));\n+  emit_move_insn (gen_lowpart (SImode, operands[0]), lo);\n+  emit_move_insn (gen_highpart (SImode, operands[0]), hi);\n+  DONE;\n+}\")\n+\n+(define_insn \"mulsidi3_i\"\n+  [(set (match_operand:SI 0 \"mep_hi_operand\" \"=h\")\n+\t(truncate:SI\n+\t (lshiftrt:DI\n+\t  (mult:DI (sign_extend:DI\n+\t\t    (match_operand:SI 2 \"register_operand\" \"r\"))\n+\t\t   (sign_extend:DI\n+\t\t    (match_operand:SI 3 \"register_operand\" \"r\")))\n+\t  (const_int 32))))\n+   (set (match_operand:SI 1 \"mep_lo_operand\" \"=l\")\n+\t(mult:SI (match_dup 2)\n+\t\t (match_dup 3)))]\n+  \"TARGET_OPT_MULT\"\n+  \"mul\\\\t%2, %3\"\n+  [(set_attr \"length\" \"2\")\n+   (set_attr \"stall\" \"mul\")])\n+\n+(define_insn \"smulsi3_highpart\"\n+  [(set (match_operand:SI 0 \"mep_hi_operand\" \"=h\")\n+\t(truncate:SI\n+\t (lshiftrt:DI\n+\t  (mult:DI (sign_extend:DI\n+\t\t    (match_operand:SI 1 \"register_operand\" \"r\"))\n+\t\t   (sign_extend:DI\n+\t\t    (match_operand:SI 2 \"register_operand\" \"r\")))\n+\t  (const_int 32))))\n+   (clobber (reg:SI LO_REGNO))]\n+  \"TARGET_OPT_MULT\"\n+  \"mul\\\\t%1, %2\"\n+  [(set_attr \"length\" \"2\")\n+   (set_attr \"stall\" \"mul\")])\n+\n+(define_expand \"umulsidi3\"\n+  [(set (match_operand:DI 0 \"mep_hi_operand\" \"\")\n+\t(mult:DI (zero_extend:DI (match_operand:SI 1 \"register_operand\" \"\"))\n+\t\t (zero_extend:DI (match_operand:SI 2 \"register_operand\" \"\"))))]\n+  \"TARGET_OPT_MULT\"\n+  \"\n+{\n+  rtx hi = gen_reg_rtx (SImode);\n+  rtx lo = gen_reg_rtx (SImode);\n+\n+  emit_insn (gen_umulsidi3_i (hi, lo, operands[1], operands[2]));\n+  emit_move_insn (gen_lowpart (SImode, operands[0]), lo);\n+  emit_move_insn (gen_highpart (SImode, operands[0]), hi);\n+  DONE;\n+}\")\n+\n+(define_insn \"umulsidi3_i\"\n+  [(set (match_operand:SI 0 \"mep_hi_operand\" \"=h\")\n+\t(truncate:SI\n+\t (lshiftrt:DI\n+\t  (mult:DI (zero_extend:DI\n+\t\t    (match_operand:SI 2 \"register_operand\" \"r\"))\n+\t\t   (zero_extend:DI\n+\t\t    (match_operand:SI 3 \"register_operand\" \"r\")))\n+\t  (const_int 32))))\n+   (set (match_operand:SI 1 \"mep_lo_operand\" \"=l\")\n+\t(mult:SI (match_dup 2)\n+\t\t (match_dup 3)))]\n+  \"TARGET_OPT_MULT\"\n+  \"mulu\\\\t%2, %3\"\n+  [(set_attr \"length\" \"2\")\n+   (set_attr \"stall\" \"mul\")])\n+\n+(define_insn \"umulsi3_highpart\"\n+  [(set (match_operand:SI 0 \"mep_hi_operand\" \"=h\")\n+\t(truncate:SI\n+\t (lshiftrt:DI\n+\t  (mult:DI (zero_extend:DI\n+\t\t    (match_operand:SI 1 \"register_operand\" \"r\"))\n+\t\t   (zero_extend:DI\n+\t\t    (match_operand:SI 2 \"register_operand\" \"r\")))\n+\t  (const_int 32))))\n+   (clobber (reg:SI LO_REGNO))]\n+  \"TARGET_OPT_MULT\"\n+  \"mulu %1, %2\"\n+  [(set_attr \"length\" \"2\")\n+   (set_attr \"stall\" \"mul\")])\n+\n+;; These two don't currently match because we don't have an adddi3 pattern.\n+(define_insn \"*smultdi_and_add\"\n+  [(set (match_operand:DI 0 \"mep_hi_operand\" \"=d\")\n+\t(plus:DI (mult:DI (zero_extend:DI\n+\t\t\t   (match_operand:SI 1 \"register_operand\" \"r\"))\n+\t\t\t  (zero_extend:DI\n+\t\t\t   (match_operand:SI 2 \"register_operand\" \"r\")))\n+\t\t (match_operand:DI 3 \"mep_hi_operand\" \"0\")))]\n+  \"TARGET_OPT_MULT && TARGET_BIG_ENDIAN\"\n+  \"maddu\\\\t%1, %2\"\n+  [(set_attr \"length\" \"4\")\n+   (set_attr \"stall\" \"mul\")])\n+\n+(define_insn \"*umultdi_and_add\"\n+  [(set (match_operand:DI 0 \"mep_hi_operand\" \"=d\")\n+\t(plus:DI (mult:DI (sign_extend:DI\n+\t\t\t   (match_operand:SI 1 \"register_operand\" \"r\"))\n+\t\t\t  (sign_extend:DI\n+\t\t\t   (match_operand:SI 2 \"register_operand\" \"r\")))\n+\t\t (match_operand:DI 3 \"mep_hi_operand\" \"0\")))]\n+  \"TARGET_OPT_MULT && TARGET_BIG_ENDIAN\"\n+  \"madd\\\\t%1, %2\"\n+  [(set_attr \"length\" \"4\")\n+   (set_attr \"stall\" \"mul\")])\n+\n+;; A pattern for 'r1 = r2 * r3 + r4'.  There are three possible\n+;; implementations:\n+;;\n+;;    (1) 'mulr;add3'.  This is usually the best choice if the instruction\n+;;\t  is not part of a natural multiply-accumulate chain.  It has the\n+;;\t  same latency as 'stc;maddr' but doesn't tie up $lo for as long.\n+;;\n+;;    (2) 'madd'.  This is the best choice if the instruction is in the\n+;;\t  middle of a natural multiply-accumulate chain.  r4 will already\n+;;\t  be in $lo and r1 will also be needed in $lo.\n+;;\n+;;    (3) 'maddr'.  This is the best choice if the instruction is at the\n+;;\t  end of a natural multiply-accumulate chain.  r4 will be in $lo\n+;;\t  but r1 will be needed in a GPR.\n+;;\n+;; In theory, we could put all the alternatives into a single pattern and\n+;; leave the register allocator to choose between them.  However, this can\n+;; sometimes produce poor results in practice.\n+;;\n+;; This pattern therefore describes a general GPR-to-GPR operation that\n+;; has a slight preference for cases in which operands 0 and 1 are tied.\n+;; After reload, we try to rewrite the patterns using peephole2s (if\n+;; enabled), falling back on define_splits if that fails.  See also\n+;; mep_reuse_lo_p.\n+(define_insn \"maddsi3\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r,r\")\n+\t(plus:SI (mult:SI (match_operand:SI 1 \"register_operand\" \"%0,r\")\n+\t\t\t  (match_operand:SI 2 \"register_operand\" \"r,r\"))\n+\t\t (match_operand:SI 3 \"register_operand\" \"r,r\")))\n+   (clobber (match_scratch:SI 4 \"=l,l\"))\n+   (clobber (match_scratch:SI 5 \"=h,h\"))]\n+  \"TARGET_OPT_MULT\"\n+  \"#\"\n+  [(set_attr \"length\" \"8\")\n+   (set_attr \"stall\" \"mulr\")])\n+\n+;; Implement maddsi3s using maddr if operand 3 is already available in $lo.\n+(define_peephole2\n+  [(parallel\n+\t[(set (match_operand:SI 0 \"register_operand\" \"\")\n+\t      (plus:SI (mult:SI (match_operand:SI 1 \"register_operand\" \"\")\n+\t\t\t\t(match_operand:SI 2 \"register_operand\" \"\"))\n+\t\t       (match_operand:SI 3 \"register_operand\" \"\")))\n+\t (clobber (match_scratch:SI 4 \"\"))\n+\t (clobber (match_scratch:SI 5 \"\"))])]\n+  \"TARGET_OPT_MULT\n+   && reload_completed\n+   && mep_reuse_lo_p (operands[4], operands[3], insn,\n+\t\t      !rtx_equal_p (operands[1], operands[3])\n+\t\t      && !rtx_equal_p (operands[2], operands[3])\n+\t\t      && (rtx_equal_p (operands[0], operands[3])\n+\t\t\t  || peep2_reg_dead_p (1, operands[3])))\"\n+  [(parallel\n+\t[(set (match_dup 4)\n+\t      (plus:SI (mult:SI (match_dup 0)\n+\t\t\t        (match_dup 2))\n+\t\t       (match_dup 4)))\n+\t (set (match_dup 0)\n+\t      (plus:SI (mult:SI (match_dup 0)\n+\t\t\t\t(match_dup 2))\n+\t\t       (match_dup 4)))\n+\t (clobber (match_dup 5))])]\n+  \"operands[2] = mep_mulr_source (0, operands[0], operands[1], operands[2]);\")\n+\n+;; This splitter implements maddsi3 as \"mulr;add3\".  It only works if\n+;; operands 0 and 3 are distinct, since operand 0 is clobbered before\n+;; operand 3 is used.\n+(define_split\n+  [(set (match_operand:SI 0 \"register_operand\" \"\")\n+\t(plus:SI (mult:SI (match_operand:SI 1 \"register_operand\" \"\")\n+\t\t\t  (match_operand:SI 2 \"register_operand\" \"\"))\n+\t\t (match_operand:SI 3 \"register_operand\" \"\")))\n+   (clobber (match_scratch:SI 4 \"\"))\n+   (clobber (match_scratch:SI 5 \"\"))]\n+  \"TARGET_OPT_MULT\n+   && reload_completed\n+   && !rtx_equal_p (operands[0], operands[3])\"\n+  [(parallel [(set (match_dup 0)\n+\t\t   (mult:SI (match_dup 0)\n+\t\t\t    (match_dup 2)))\n+\t      (clobber (match_dup 4))\n+\t      (clobber (match_dup 5))])\n+   (set (match_dup 0)\n+\t(plus:SI (match_dup 0)\n+\t\t (match_dup 3)))]\n+  \"operands[2] = mep_mulr_source (0, operands[0], operands[1], operands[2]);\")\n+\n+;; This is the fallback splitter for maddsi3.  It moves operand 3 into\n+;; $lo and then uses maddr.\n+(define_split\n+  [(set (match_operand:SI 0 \"register_operand\" \"\")\n+\t(plus:SI (mult:SI (match_operand:SI 1 \"register_operand\" \"\")\n+\t\t\t  (match_operand:SI 2 \"register_operand\" \"\"))\n+\t\t (match_operand:SI 3 \"register_operand\" \"\")))\n+   (clobber (match_scratch:SI 4 \"\"))\n+   (clobber (match_scratch:SI 5 \"\"))]\n+  \"TARGET_OPT_MULT\n+   && reload_completed\"\n+  [(parallel [(set (match_dup 4)\n+\t\t   (plus:SI (mult:SI (match_dup 0)\n+\t\t\t\t     (match_dup 2))\n+\t\t\t    (match_dup 4)))\n+\t      (set (match_dup 0)\n+\t\t   (plus:SI (mult:SI (match_dup 0)\n+\t\t\t\t     (match_dup 2))\n+\t\t\t    (match_dup 4)))\n+\t      (clobber (match_dup 5))])]\n+{\n+  emit_move_insn (operands[4], operands[3]);\n+  operands[2] = mep_mulr_source (0, operands[0], operands[1], operands[2]);\n+})\n+\n+;; Remove unnecessary stcs to $lo.  This cleans up the moves generated\n+;; by earlier calls to mep_reuse_lo_p.\n+(define_peephole2\n+  [(set (match_operand:SI 0 \"mep_lo_operand\" \"\")\n+\t(match_operand:SI 1 \"register_operand\" \"\"))]\n+  \"TARGET_OPT_MULT\n+   && mep_reuse_lo_p (operands[0], operands[1], insn,\n+\t\t      peep2_reg_dead_p (1, operands[1]))\"\n+  [(const_int 0)]\n+{\n+  emit_note (NOTE_INSN_DELETED);\n+  DONE;\n+})\n+\n+(define_insn \"maddsi3_lo\"\n+  [(set (match_operand:SI 0 \"mep_lo_operand\" \"=l\")\n+\t(plus:SI (mult:SI (match_operand:SI 1 \"register_operand\" \"r\")\n+\t\t\t  (match_operand:SI 2 \"register_operand\" \"r\"))\n+\t\t (match_operand:SI 3 \"mep_lo_operand\" \"0\")))\n+   (clobber (match_scratch:SI 4 \"=h\"))]\n+  \"TARGET_OPT_MULT && reload_completed\"\n+  \"madd\\\\t%1, %2\"\n+  [(set_attr \"length\" \"4\")\n+   (set_attr \"stall\" \"mul\")])\n+\n+(define_insn \"maddsi3r\"\n+  [(set (match_operand:SI 0 \"mep_lo_operand\" \"=l\")\n+\t(plus:SI (mult:SI (match_operand:SI 2 \"register_operand\" \"1\")\n+\t\t\t  (match_operand:SI 3 \"register_operand\" \"r\"))\n+\t\t (match_operand:SI 4 \"register_operand\" \"0\")))\n+   (set (match_operand:SI 1 \"register_operand\" \"=r\")\n+\t(plus:SI (mult:SI (match_dup 2)\n+\t\t\t  (match_dup 3))\n+\t\t (match_dup 4)))\n+   (clobber (match_scratch:SI 5 \"=h\"))]\n+  \"TARGET_OPT_MULT && reload_completed\"\n+  \"maddr\\\\t%2, %3\"\n+  [(set_attr \"length\" \"4\")\n+   (set_attr \"stall\" \"mulr\")])\n+\n+(define_insn \"*shift_1_or_2_and_add\"\n+  [(set (match_operand:SI 0 \"mep_r0_operand\" \"=z\")\n+\t(plus:SI (mult:SI (match_operand:SI 1 \"register_operand\" \"r\")\n+\t\t\t  (match_operand:SI 2 \"mep_slad_operand\" \"n\"))\n+\t\t (match_operand:SI 3 \"register_operand\" \"r\")))]\n+  \"\"\n+  \"sl%b2ad3\\\\t%0, %1, %3\"\n+  [(set_attr \"length\" \"2\")\n+   (set_attr \"stall\" \"int2\")])\n+\n+(define_insn \"divmodsi4\"\n+  [(set (match_operand:SI 0 \"mep_lo_operand\" \"=l\")\n+\t(div:SI (match_operand:SI 1 \"register_operand\" \"r\")\n+\t\t(match_operand:SI 2 \"register_operand\" \"r\")))\n+   (set (match_operand:SI 3 \"mep_hi_operand\" \"=h\")\n+\t(mod:SI (match_dup 1)\n+\t\t(match_dup 2)))]\n+  \"TARGET_OPT_DIV\"\n+  \"div\\\\t%1, %2\"\n+  [(set_attr \"length\" \"2\")\n+   (set_attr \"stall\" \"div\")\n+   (set_attr \"may_trap\" \"yes\")])\n+\n+(define_insn \"udivmodsi4\"\n+  [(set (match_operand:SI 0 \"mep_lo_operand\" \"=l\")\n+\t(udiv:SI (match_operand:SI 1 \"register_operand\" \"r\")\n+\t\t (match_operand:SI 2 \"register_operand\" \"r\")))\n+   (set (match_operand:SI 3 \"mep_hi_operand\" \"=h\")\n+\t(umod:SI (match_dup 1)\n+\t\t(match_dup 2)))]\n+  \"TARGET_OPT_DIV\"\n+  \"divu\\\\t%1, %2\"\n+  [(set_attr \"length\" \"2\")\n+   (set_attr \"stall\" \"div\")\n+   (set_attr \"may_trap\" \"yes\")])\n+\n+(define_insn \"negsi2\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+\t(neg:SI (match_operand:SI 1 \"register_operand\" \"r\")))]\n+  \"\"\n+  \"neg\\\\t%0, %1\"\n+  [(set_attr \"length\" \"2\")])\n+\n+;; We have \"absolute difference between two regs\" which isn't quite\n+;; what gcc is expecting.\n+(define_expand \"abssi2\"\n+  [(set (match_dup 2) (const_int 0))\n+   (set (match_operand:SI 0 \"register_operand\" \"\")\n+\t(abs:SI (minus:SI (match_operand:SI 1 \"register_operand\" \"\")\n+\t\t\t  (match_dup 2))\n+\t\t))]\n+  \"TARGET_OPT_ABSDIFF\"\n+  \"operands[2] = gen_reg_rtx (SImode);\")\n+\n+(define_insn \"*absdiff\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+\t(abs:SI (minus:SI (match_operand:SI 1 \"register_operand\" \"0\")\n+\t\t\t  (match_operand:SI 2 \"register_operand\" \"r\"))))]\n+  \"TARGET_OPT_ABSDIFF\"\n+  \"abs\\\\t%0, %2\"\n+  [(set_attr \"length\" \"4\")])\n+\n+(define_split\n+  [(set (match_operand:SI 0 \"register_operand\" \"\")\n+\t(abs:SI (plus:SI (match_operand:SI 1 \"register_operand\" \"\")\n+\t\t\t (match_operand:SI 2 \"immediate_operand\" \"\"))))\n+   (clobber (match_operand:SI 3 \"register_operand\" \"\"))]\n+  \"!reload_completed\"\n+  [(set (match_dup 3)\n+\t(match_dup 4))\n+   (set (match_operand:SI 0 \"register_operand\" \"\")\n+\t(abs:SI (minus:SI (match_operand:SI 1 \"register_operand\" \"\")\n+\t\t\t  (match_dup 3))))]\n+  \"operands[4] = GEN_INT (-INTVAL (operands[2]));\")\n+\n+(define_insn \"sminsi3\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+\t(smin:SI (match_operand:SI 1 \"register_operand\" \"0\")\n+\t\t (match_operand:SI 2 \"nonmemory_operand\" \"r\")))]\n+  \"TARGET_OPT_MINMAX\"\n+  \"min\\\\t%0, %2\"\n+  [(set_attr \"length\" \"4\")])\n+\n+(define_insn \"smaxsi3\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+\t(smax:SI (match_operand:SI 1 \"register_operand\" \"0\")\n+\t\t (match_operand:SI 2 \"nonmemory_operand\" \"r\")))]\n+  \"TARGET_OPT_MINMAX\"\n+  \"max\\\\t%0, %2\"\n+  [(set_attr \"length\" \"4\")])\n+\n+(define_insn \"uminsi3\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+\t(umin:SI (match_operand:SI 1 \"register_operand\" \"0\")\n+\t\t (match_operand:SI 2 \"nonmemory_operand\" \"r\")))]\n+  \"TARGET_OPT_MINMAX\"\n+  \"minu\\\\t%0, %2\"\n+  [(set_attr \"length\" \"4\")])\n+\n+(define_insn \"umaxsi3\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+\t(umax:SI (match_operand:SI 1 \"register_operand\" \"0\")\n+\t\t (match_operand:SI 2 \"nonmemory_operand\" \"r\")))]\n+  \"TARGET_OPT_MINMAX\"\n+  \"maxu\\\\t%0, %2\"\n+  [(set_attr \"length\" \"4\")])\n+\n+;; Average:  a = (b+c+1)>>1\n+(define_insn \"*averagesi3\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+\t(ashiftrt:SI (plus:SI (plus:SI\n+\t\t\t\t(match_operand:SI 1 \"register_operand\" \"0\")\n+\t\t\t\t(match_operand:SI 2 \"register_operand\" \"r\"))\n+\t\t\t      (const_int 1))\n+\t\t     (const_int 1)))]\n+  \"TARGET_OPT_AVERAGE\"\n+  \"ave\\\\t%0, %2\"\n+  [(set_attr \"length\" \"4\")])\n+\n+;; clip support\n+\n+(define_insn \"clip_maxmin\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+\t(smax:SI (smin:SI (match_operand:SI 1 \"register_operand\" \"0\")\n+\t\t\t  (match_operand:SI 2 \"immediate_operand\" \"n\"))\n+\t\t (match_operand:SI 3 \"immediate_operand\" \"n\")))]\n+  \"mep_allow_clip (operands[2], operands[3], 1)\"\n+  \"clip\\\\t%0, %B2\"\n+  [(set_attr \"length\" \"4\")])\n+\n+(define_insn \"clip_minmax\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+\t(smin:SI (smax:SI (match_operand:SI 1 \"register_operand\" \"0\")\n+\t\t\t  (match_operand:SI 2 \"immediate_operand\" \"n\"))\n+\t\t (match_operand:SI 3 \"immediate_operand\" \"n\")))]\n+  \"mep_allow_clip (operands[3], operands[2], 1)\"\n+  \"clip\\\\t%0, %B3\"\n+  [(set_attr \"length\" \"4\")])\n+\n+(define_insn \"clipu_maxmin\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+\t(smax:SI (smin:SI (match_operand:SI 1 \"register_operand\" \"0\")\n+\t\t\t  (match_operand:SI 2 \"immediate_operand\" \"n\"))\n+\t\t (match_operand:SI 3 \"immediate_operand\" \"n\")))]\n+  \"mep_allow_clip (operands[2], operands[3], 0)\"\n+  \"clipu\\\\t%0, %U2\"\n+  [(set_attr \"length\" \"4\")])\n+\n+(define_insn \"clipu_minmax\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+\t(smin:SI (smax:SI (match_operand:SI 1 \"register_operand\" \"0\")\n+\t\t\t  (match_operand:SI 2 \"immediate_operand\" \"n\"))\n+\t\t (match_operand:SI 3 \"immediate_operand\" \"n\")))]\n+  \"mep_allow_clip (operands[3], operands[2], 0)\"\n+  \"clipu\\\\t%0, %U3\"\n+  [(set_attr \"length\" \"4\")])\n+\f\n+;; ::::::::::::::::::::\n+;; ::\n+;; :: 32 bit Integer Shifts and Rotates\n+;; ::\n+;; ::::::::::::::::::::\n+\n+(define_insn \"ashlsi3\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r,z\")\n+\t(ashift:SI (match_operand:SI 1 \"register_operand\" \"0,r\")\n+\t\t   (match_operand:SI 2 \"nonmemory_operand\" \"rM,M\")))]\n+  \"\"\n+  \"@\n+   sll\\\\t%0, %2\n+   sll3\\\\t%0, %1, %2\"\n+  [(set_attr \"length\" \"2,2\")\n+   (set_attr \"shiftop\" \"operand2\")])\n+\n+(define_insn \"ashrsi3\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+\t(ashiftrt:SI (match_operand:SI 1 \"register_operand\" \"0\")\n+\t\t     (match_operand:SI 2 \"nonmemory_operand\" \"rM\")))]\n+  \"\"\n+  \"sra\\\\t%0, %2\"\n+  [(set_attr \"length\" \"2\")\n+   (set_attr \"shiftop\" \"operand2\")])\n+\n+(define_insn \"lshrsi3\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+\t(lshiftrt:SI (match_operand:SI 1 \"register_operand\" \"0\")\n+\t\t     (match_operand:SI 2 \"nonmemory_operand\" \"rM\")))]\n+  \"\"\n+  \"srl\\\\t%0, %2\"\n+  [(set_attr \"length\" \"2\")\n+   (set_attr \"shiftop\" \"operand2\")])\n+\f\n+;; ::::::::::::::::::::\n+;; ::\n+;; :: 32 Bit Integer Logical operations\n+;; ::\n+;; ::::::::::::::::::::\n+\n+(define_insn \"andsi3\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r,r\")\n+\t(and:SI (match_operand:SI 1 \"register_operand\" \"%0,r\")\n+\t\t(match_operand:SI 2 \"nonmemory_operand\" \"r,J\")))]\n+  \"\"\n+  \"@\n+   and\\\\t%0, %2\n+   and3\\\\t%0, %1, %J2\"\n+  [(set_attr \"length\" \"2,4\")])\n+\n+(define_insn \"iorsi3\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r,r\")\n+\t(ior:SI (match_operand:SI 1 \"register_operand\" \"%0,r\")\n+\t\t(match_operand:SI 2 \"nonmemory_operand\" \"r,J\")))]\n+  \"\"\n+  \"@\n+   or\\\\t%0, %2\n+   or3\\\\t%0, %1, %J2\"\n+  [(set_attr \"length\" \"2,4\")])\n+\n+(define_insn \"xorsi3\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r,r\")\n+\t(xor:SI (match_operand:SI 1 \"register_operand\" \"%0,r\")\n+\t\t(match_operand:SI 2 \"nonmemory_operand\" \"r,J\")))]\n+  \"\"\n+  \"@\n+   xor\\\\t%0, %2\n+   xor3\\\\t%0, %1, %J2\"\n+  [(set_attr \"length\" \"2,4\")])\n+\n+(define_expand \"one_cmplsi2\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"\")\n+\t(not:SI (match_operand:SI 1 \"register_operand\" \"\")))]\n+  \"\"\n+  \"operands[2] = operands[1];\n+   \")\n+\n+;; No separate insn for this; use NOR\n+(define_insn \"*one_cmplsi3_internal\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+\t(not:SI (match_operand:SI 1 \"register_operand\" \"0\")))]\n+  \"\"\n+  \"nor\\\\t%0, %0\"\n+  [(set_attr \"length\" \"2\")])\n+\f\n+;; ::::::::::::::::::::\n+;; ::\n+;; :: Bit Manipulation\n+;; ::\n+;; ::::::::::::::::::::\n+\n+(define_insn \"*bitop_be\"\n+  [(set (match_operand:QI 0 \"mep_Y_operand\" \"=Y\")\n+\t(subreg:QI (match_operator:SI 3 \"mep_bit_operator\"\n+\t\t\t[(subreg:SI (match_operand:QI 1 \"mep_Y_operand\" \"0\") 0)\n+\t\t\t (match_operand 2 \"immediate_operand\" \"n\")])\n+\t\t   3)\n+\t)]\n+  \"TARGET_BIG_ENDIAN && TARGET_OPT_BITOPS\n+   && rtx_equal_p (operands[0], operands[1])\"\n+  \"b%L3m\\\\t%0, %b2\"\n+  [(set_attr \"length\" \"2\")])\n+\n+(define_insn \"*bitop_le\"\n+  [(set (match_operand:QI 0 \"mep_Y_operand\" \"=Y\")\n+\t(subreg:QI (match_operator:SI 3 \"mep_bit_operator\"\n+\t\t\t[(subreg:SI (match_operand:QI 1 \"mep_Y_operand\" \"0\") 0)\n+\t\t\t (match_operand 2 \"immediate_operand\" \"n\")])\n+\t\t   0)\n+\t)]\n+  \"!TARGET_BIG_ENDIAN && TARGET_OPT_BITOPS\n+   && rtx_equal_p (operands[0], operands[1])\"\n+  \"b%L3m\\\\t%0, %b2\"\n+  [(set_attr \"length\" \"2\")])\n+\n+(define_insn \"btstm\"\n+  [(set (match_operand:SI 0 \"mep_r0_operand\" \"=z\")\n+\t(and:SI (subreg:SI (match_operand:QI 1 \"mep_Y_operand\" \"Y\") 0)\n+\t\t(match_operand 2 \"immediate_operand\" \"n\"))\n+\t)]\n+  \"TARGET_OPT_BITOPS && mep_bit_position_p (operands[2], 1)\"\n+  \"btstm\\\\t%0, %1, %b2\"\n+  [(set_attr \"length\" \"2\")])\n+\n+(define_insn \"tas\"\n+  [(parallel [(set (match_operand:SI 0 \"mep_r0_operand\" \"=z\")\n+\t\t   (zero_extend:SI (match_operand:QI 1 \"mep_Y_operand\" \"+Y\")))\n+\t      (set (match_dup 1)\n+\t\t   (const_int 1))\n+\t      ]\n+\t     )]\n+  \"TARGET_OPT_BITOPS\"\n+  \"tas\\\\t%0, %1\"\n+  [(set_attr \"length\" \"2\")])\n+\n+(define_peephole2\n+  [(set (match_operand:SI 0 \"mep_r0_operand\" \"\")\n+\t(zero_extend:SI (match_operand:QI 1 \"mep_Y_operand\" \"\")))\n+   (set (match_operand:QI 2 \"register_operand\" \"\")\n+\t(const_int 1))\n+   (set (match_dup 1)\n+\t(match_dup 2))\n+   ]\n+  \"TARGET_OPT_BITOPS\"\n+  [(parallel [(set (match_dup 0)\n+\t\t   (zero_extend:SI (match_dup 1)))\n+\t      (set (match_dup 1)\n+\t\t   (const_int 1))\n+\t      ])]\n+  \"\")\n+\n+(define_peephole2\n+  [(set (match_operand:SI 0 \"mep_r0_operand\" \"\")\n+\t(sign_extend:SI (match_operand:QI 1 \"mep_Y_operand\" \"\")))\n+   (set (match_operand:QI 2 \"register_operand\" \"\")\n+\t(const_int 1))\n+   (set (match_dup 1)\n+\t(match_dup 2))\n+   ]\n+  \"TARGET_OPT_BITOPS\"\n+  [(parallel [(set (match_dup 0)\n+\t\t   (zero_extend:SI (match_dup 1)))\n+\t      (set (match_dup 1)\n+\t\t   (const_int 1))\n+\t      ])\n+   (set (match_dup 0)\n+\t(sign_extend:SI (match_dup 3)))]\n+  \"operands[3] = gen_lowpart (QImode, operands[0]);\")\n+\n+\f\n+;; ::::::::::::::::::::\n+;; ::\n+;; :: Conditional branches and stores\n+;; ::\n+;; ::::::::::::::::::::\n+\n+(define_expand \"cbranchsi4\"\n+  [(set (pc)\n+\t(if_then_else (match_operator 0 \"ordered_comparison_operator\"\n+\t\t\t\t      [(match_operand:SI 1 \"register_operand\" \"\")\n+\t\t\t\t       (match_operand:SI 2 \"nonmemory_operand\" \"\")])\n+\t\t      (label_ref (match_operand 3 \"\" \"\"))\n+\t\t      (pc)))]\n+  \"\"\n+  \"emit_jump_insn (gen_branch_true (operands[3],\n+\t\t\t       mep_expand_cbranch (operands)));\n+   DONE;\")\n+  \n+(define_expand \"branch_true\"\n+  [(set (pc)\n+\t(if_then_else (match_operand 1 \"\" \"\")\n+\t\t      (label_ref (match_operand 0 \"\" \"\"))\n+\t\t      (pc)))]\n+  \"\"\n+  \"\")\n+  \n+(define_expand \"cstoresi4\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"\")\n+\t(match_operator:SI 1 \"ordered_comparison_operator\"\n+\t\t\t   [(match_operand:SI 2 \"register_operand\" \"\")\n+\t\t\t    (match_operand:SI 3 \"nonmemory_operand\" \"\")]))]\n+  \"\"\n+  \"if (mep_expand_setcc (operands)) DONE; else FAIL;\")\n+\n+;; ------------------------------------------------------------\n+\n+(define_insn \"*slt\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=z,z,r\")\n+\t(lt:SI (match_operand:SI 1 \"register_operand\" \"r,r,r\")\n+\t    (match_operand:SI 2 \"nonmemory_operand\" \"r,M,I\")))]\n+  \"\"\n+  \"slt3\\\\t%0, %1, %2\"\n+  [(set_attr \"length\" \"2,2,4\")])\n+\n+(define_insn \"*sltu\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=z,z,r\")\n+\t(ltu:SI (match_operand:SI 1 \"register_operand\" \"r,r,r\")\n+\t     (match_operand:SI 2 \"nonmemory_operand\" \"r,M,J\")))]\n+  \"\"\n+  \"sltu3\\\\t%0, %1, %2\"\n+  [(set_attr \"length\" \"2,2,4\")])\n+\n+(define_insn \"*bcpeq_true\"\n+  [(set (pc)\n+\t(if_then_else (eq:SI (reg:SI CBCR_REGNO)\n+\t\t\t     (const_int 0))\n+\t\t      (label_ref (match_operand 0 \"\" \"\"))\n+\t\t      (pc)))]\n+  \"\"\n+  \"bcpeq\\t0, %l0\"\n+  [(set_attr \"length\" \"4\")])\n+\n+(define_insn \"*bcpeq_false\"\n+  [(set (pc)\n+\t(if_then_else (eq:SI (reg:SI CBCR_REGNO)\n+\t\t\t     (const_int 0))\n+\t\t      (pc)\n+\t\t      (label_ref (match_operand 0 \"\" \"\"))))]\n+  \"\"\n+  \"bcpne\\t0, %l0\"\n+  [(set_attr \"length\" \"4\")])\n+\n+(define_insn \"*bcpne_true\"\n+  [(set (pc)\n+\t(if_then_else (ne:SI (reg:SI CBCR_REGNO)\n+\t\t\t     (const_int 0))\n+\t\t      (label_ref (match_operand 0 \"\" \"\"))\n+\t\t      (pc)))]\n+  \"\"\n+  \"bcpne\\t0, %l0\"\n+  [(set_attr \"length\" \"4\")])\n+\n+(define_insn \"*bcpne_false\"\n+  [(set (pc)\n+\t(if_then_else (ne:SI (reg:SI CBCR_REGNO)\n+\t\t\t     (const_int 0))\n+\t\t      (pc)\n+\t\t      (label_ref (match_operand 0 \"\" \"\"))))]\n+  \"\"\n+  \"bcpeq\\t0, %l0\"\n+  [(set_attr \"length\" \"4\")])\n+\n+;; ??? The lengths here aren't correct, since no attempt it made to\n+;; find \"beqz\" in the 256-byte range.  However, this should not affect\n+;; bundling, since we never run core branches in parallel.\n+\n+(define_insn \"mep_beq_true\"\n+  [(set (pc)\n+\t(if_then_else (eq (match_operand:SI 0 \"register_operand\" \"r\")\n+\t\t\t  (match_operand:SI 1 \"mep_reg_or_imm4_operand\" \"rN\"))\n+\t\t      (label_ref (match_operand 2 \"\" \"\"))\n+\t\t      (pc)))]\n+  \"\"\n+  \"* return mep_emit_cbranch (operands, 0);\"\n+  [(set_attr \"length\" \"4\")]  )\n+\n+(define_insn \"*beq_false\"\n+  [(set (pc)\n+\t(if_then_else (eq (match_operand:SI 0 \"register_operand\" \"r\")\n+\t\t\t  (match_operand:SI 1 \"mep_reg_or_imm4_operand\" \"rN\"))\n+\t\t      (pc)\n+\t\t      (label_ref (match_operand 2 \"\" \"\"))))]\n+  \"\"\n+  \"* return mep_emit_cbranch (operands, 1);\"\n+  [(set_attr \"length\" \"4\")])\n+\n+(define_insn \"mep_bne_true\"\n+  [(set (pc)\n+\t(if_then_else (ne (match_operand:SI 0 \"register_operand\" \"r\")\n+\t\t\t  (match_operand:SI 1 \"mep_reg_or_imm4_operand\" \"rN\"))\n+\t\t      (label_ref (match_operand 2 \"\" \"\"))\n+\t\t      (pc)))]\n+  \"\"\n+  \"* return mep_emit_cbranch (operands, 1); \"\n+  [(set_attr \"length\" \"4\")])\n+\n+(define_insn \"*bne_false\"\n+  [(set (pc)\n+\t(if_then_else (ne (match_operand:SI 0 \"register_operand\" \"r\")\n+\t\t\t  (match_operand:SI 1 \"mep_reg_or_imm4_operand\" \"rN\"))\n+\t\t      (pc)\n+\t\t      (label_ref (match_operand 2 \"\" \"\"))))]\n+  \"\"\n+  \"* return mep_emit_cbranch (operands, 0); \"\n+  [(set_attr \"length\" \"4\")])\n+\n+(define_insn \"mep_blti\"\n+  [(set (pc)\n+\t(if_then_else (lt (match_operand:SI 0 \"register_operand\" \"r\")\n+\t\t\t  (match_operand:SI 1 \"mep_imm4_operand\" \"N\"))\n+\t\t      (label_ref (match_operand 2 \"\" \"\"))\n+\t\t      (pc)))]\n+  \"\"\n+  \"blti\\\\t%0, %1, %l2\"\n+  [(set_attr \"length\" \"4\")])\n+\n+(define_insn \"*bgei\"\n+  [(set (pc)\n+\t(if_then_else (ge (match_operand:SI 0 \"register_operand\" \"r\")\n+\t\t\t  (match_operand:SI 1 \"mep_imm4_operand\" \"N\"))\n+\t\t      (label_ref (match_operand 2 \"\" \"\"))\n+\t\t      (pc)))]\n+  \"\"\n+  \"bgei\\\\t%0, %1, %l2\"\n+  [(set_attr \"length\" \"4\")])\n+\f\n+;; ::::::::::::::::::::\n+;; ::\n+;; :: Call and branch instructions\n+;; ::\n+;; ::::::::::::::::::::\n+\n+(define_expand \"call\"\n+  [(parallel [(call (match_operand:QI 0 \"\" \"\")\n+\t\t    (match_operand:SI 1 \"\" \"\"))\n+\t      (use (match_operand:SI 2 \"\" \"\"))\n+\t      (clobber (reg:SI REGSAVE_CONTROL_TEMP))\n+\t      ])]\n+  \"\"\n+  \"\n+{\n+  mep_expand_call (operands, 0);\n+  DONE;\n+}\")\n+\n+(define_insn \"call_internal\"\n+  [(call (mem (match_operand:SI 0 \"mep_call_address_operand\" \"R,r\"))\n+\t (match_operand:SI 1 \"\" \"\"))\n+   (use (match_operand:SI 2 \"const_int_operand\" \"\"))\n+   (use (match_operand:SI 3 \"mep_tp_operand\" \"b,b\"))\n+   (use (match_operand:SI 4 \"mep_gp_operand\" \"v,v\"))\n+   (clobber (reg:SI LP_REGNO))\n+   (clobber (reg:SI REGSAVE_CONTROL_TEMP))\n+  ]\n+  \"\"\n+{\n+  static char const pattern[2][2][8] = \n+  {\n+    { \"bsrv\\t%0\", \"jsrv\\t%0\" },\n+    { \"bsr\\t%0\", \"jsr\\t%0\" }\n+  };\n+\n+  return pattern[mep_vliw_mode_match (operands[2])][which_alternative];\n+}\n+  [(set_attr \"length\" \"4,2\")])\n+\n+(define_expand \"sibcall\"\n+  [(parallel [(call (match_operand:QI 0 \"\" \"\")\n+\t\t    (match_operand:SI 1 \"\" \"\"))\n+\t      (use (match_operand:SI 2 \"\" \"\"))\n+\t      (use (reg:SI LP_REGNO))\n+\t      (clobber (reg:SI REGSAVE_CONTROL_TEMP))\n+\t      ])]\n+  \"\"\n+  \"\")\n+\n+(define_insn \"*sibcall_internal\"\n+  [(call (mem (match_operand:SI 0 \"mep_nearsym_operand\" \"s\"))\n+\t (match_operand:SI 1 \"\" \"\"))\n+   (use (match_operand:SI 2 \"const_int_operand\" \"\"))\n+   (use (reg:SI LP_REGNO))\n+   (clobber (reg:SI REGSAVE_CONTROL_TEMP))\n+  ]\n+  \"SIBLING_CALL_P (insn)\"\n+{\n+  if (mep_vliw_mode_match (operands[2]))\n+    return \"jmp\\t%0\";\n+  else\n+    return\n+\t\"ldc\t$12, $lp\\n\\\n+\tmovh\t$11, %%hi(%0)\\n\\\n+\txor3\t$12, $12, 1\\n\\\n+\tadd3\t$11, $11, %%lo(%0+1)\\n\\\n+\tstc\t$12, $lp\\n\\\n+\tjmp\t$11\";\n+}\n+  [(set_attr \"length\" \"48\")\n+   (set_attr \"slot\" \"multi\")])\n+\n+(define_expand \"call_value\"\n+  [(parallel [(set (match_operand 0 \"\" \"\")\n+\t\t   (call (match_operand:QI 1 \"\" \"\")\n+\t\t         (match_operand:SI 2 \"\" \"\")))\n+\t      (use (match_operand:SI 3 \"\" \"\"))\n+\t      (clobber (reg:SI REGSAVE_CONTROL_TEMP))\n+\t      ])]\n+  \"\"\n+  \"\n+{\n+  mep_expand_call (operands, 1);\n+  DONE;\n+}\")\n+\n+(define_insn \"call_value_internal\"\n+  [(set (match_operand 0 \"register_operand\" \"=rx,rx\")\n+\t(call (mem:SI (match_operand:SI 1 \"mep_call_address_operand\" \"R,r\"))\n+\t      (match_operand:SI 2 \"\" \"\")))\n+   (use (match_operand:SI 3 \"const_int_operand\" \"\"))\n+   (use (match_operand:SI 4 \"mep_tp_operand\" \"b,b\"))\n+   (use (match_operand:SI 5 \"mep_gp_operand\" \"v,v\"))\n+   (clobber (reg:SI LP_REGNO))\n+   (clobber (reg:SI REGSAVE_CONTROL_TEMP))\n+  ]\n+  \"\"\n+{\n+  static char const pattern[2][2][8] = \n+  {\n+    { \"bsrv\\t%1\", \"jsrv\\t%1\" },\n+    { \"bsr\\t%1\", \"jsr\\t%1\" }\n+  };\n+\n+  return pattern[mep_vliw_mode_match (operands[3])][which_alternative];\n+}\n+  [(set_attr \"length\" \"4,2\")])\n+\n+(define_expand \"sibcall_value\"\n+  [(parallel [(set (match_operand 0 \"\" \"\")\n+\t\t   (call (match_operand:QI 1 \"\" \"\")\n+\t\t         (match_operand:SI 2 \"\" \"\")))\n+\t      (use (match_operand:SI 3 \"\" \"\"))\n+\t      (use (reg:SI LP_REGNO))\n+\t      (clobber (reg:SI REGSAVE_CONTROL_TEMP))\n+\t      ])]\n+  \"\"\n+  \"\")\n+\n+(define_insn \"*sibcall_value_internal\"\n+  [(set (match_operand 0 \"register_operand\" \"=rx\")\n+\t(call (mem (match_operand:SI 1 \"mep_nearsym_operand\" \"s\"))\n+\t      (match_operand:SI 2 \"\" \"\")))\n+   (use (match_operand:SI 3 \"const_int_operand\" \"\"))\n+   (use (reg:SI LP_REGNO))\n+   (clobber (reg:SI REGSAVE_CONTROL_TEMP))\n+  ]\n+  \"SIBLING_CALL_P (insn)\"\n+{\n+  if (mep_vliw_mode_match (operands[3]))\n+    return \"jmp\\t%1\";\n+  else\n+    return\n+\t\"ldc\t$12, $lp\\n\\\n+\tmovh\t$11, %%hi(%1)\\n\\\n+\txor3\t$12, $12, 1\\n\\\n+\tadd3\t$11, $11, %%lo(%1+1)\\n\\\n+\tstc\t$12, $lp\\n\\\n+\tjmp\t$11\";\n+}\n+  [(set_attr \"length\" \"48\")\n+   (set_attr \"slot\" \"multi\")])\n+\n+(define_insn \"return_internal\"\n+  [(return)\n+   (use (match_operand:SI 0 \"register_operand\" \"\"))]\n+  \"\"\n+  \"* return (REGNO (operands[0]) == LP_REGNO) ? \\\"ret\\\" : \\\"jmp\\\\t%0\\\";\"\n+  [(set_attr \"length\" \"2\")\n+   (set_attr \"stall\" \"ret\")])\n+\n+(define_insn \"eh_return_internal\"\n+  [(return)\n+   (use (reg:SI 10))\n+   (use (reg:SI 11))\n+   (use (reg:SI LP_REGNO))\n+   (clobber (reg:SI REGSAVE_CONTROL_TEMP))\n+  ]\n+  \"\"\n+  \"ret\"\n+  [(set_attr \"length\" \"2\")\n+   (set_attr \"stall\" \"ret\")])\n+\n+;; The assembler replaces short jumps with long jumps as needed.\n+(define_insn \"jump\"\n+  [(set (pc) (label_ref (match_operand 0 \"\" \"\")))]\n+  \"\"\n+  \"bra\\\\t%l0\"\n+  [(set_attr \"length\" \"4\")])\n+\n+(define_insn \"indirect_jump\"\n+  [(set (pc) (match_operand:SI 0 \"register_operand\" \"r\"))]\n+  \"\"\n+  \"jmp\\\\t%0\"\n+  [(set_attr \"length\" \"2\")])\n+\n+(define_insn \"tablejump\"\n+  [(set (pc) (match_operand:SI 0 \"register_operand\" \"r\"))\n+   (use (label_ref (match_operand 1 \"\" \"\")))]\n+  \"\"\n+  \"jmp\\\\t%0\"\n+  [(set_attr \"length\" \"2\")])\n+\n+\f\n+;; ::::::::::::::::::::\n+;; ::\n+;; :: Low Overhead Looping\n+;; ::\n+;; ::::::::::::::::::::\n+\n+;; This insn is volatile because we'd like it to stay in its original\n+;; position, just before the loop header.  If it stays there, we might\n+;; be able to convert it into a \"repeat\" insn.\n+(define_insn \"doloop_begin_internal\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+\t(unspec_volatile:SI\n+\t [(match_operand:SI 1 \"register_operand\" \"0\")\n+\t  (match_operand 2 \"const_int_operand\" \"\")] UNS_REPEAT_BEG))]\n+  \"\"\n+  { gcc_unreachable (); }\n+  [(set_attr \"length\" \"4\")])\n+\n+(define_expand \"doloop_begin\"\n+  [(use (match_operand 0 \"register_operand\" \"\"))\n+   (use (match_operand:QI 1 \"const_int_operand\" \"\"))\n+   (use (match_operand:QI 2 \"const_int_operand\" \"\"))\n+   (use (match_operand:QI 3 \"const_int_operand\" \"\"))]\n+  \"!profile_arc_flag && TARGET_OPT_REPEAT\"\n+  \"if (INTVAL (operands[3]) > 1)\n+     FAIL;\n+   mep_emit_doloop (operands, 0);\n+   DONE;\n+  \")\n+\n+(define_insn \"doloop_end_internal\"\n+  [(set (pc)\n+\t(if_then_else (ne (match_operand:SI 0 \"nonimmediate_operand\" \"+r,cxy,*m\")\n+\t\t\t  (const_int 0))\n+\t\t      (label_ref (match_operand 1 \"\" \"\"))\n+\t\t      (pc)))\n+   (set (match_dup 0)\n+\t(plus:SI (match_dup 0)\n+\t\t (const_int -1)))\n+   (unspec [(match_operand 2 \"const_int_operand\" \"\")] UNS_REPEAT_END)\n+   (clobber (match_scratch:SI 3 \"=X,&r,&r\"))]\n+  \"\"\n+  { gcc_unreachable (); }\n+  ;; Worst case length:\n+  ;;\n+  ;;      lw <op3>,<op0>\t4\n+  ;;      add <op3>,-1\t\t2\n+  ;;      sw <op3>,<op0>\t4\n+  ;;      jmp <op1>\t\t4\n+  ;; 1f:\n+  [(set_attr \"length\" \"14\")\n+   (set_attr \"slot\" \"multi\")])\n+\n+(define_expand \"doloop_end\"\n+  [(use (match_operand 0 \"nonimmediate_operand\" \"\"))\n+   (use (match_operand:QI 1 \"const_int_operand\" \"\"))\n+   (use (match_operand:QI 2 \"const_int_operand\" \"\"))\n+   (use (match_operand:QI 3 \"const_int_operand\" \"\"))\n+   (use (label_ref (match_operand 4 \"\" \"\")))]\n+  \"!profile_arc_flag && TARGET_OPT_REPEAT\"\n+  \"if (INTVAL (operands[3]) > 1)\n+     FAIL;\n+   if (GET_CODE (operands[0]) == REG && GET_MODE (operands[0]) != SImode)\n+     FAIL;\n+   mep_emit_doloop (operands, 1);\n+   DONE;\n+  \")\n+\n+(define_insn \"repeat\"\n+  [(set (reg:SI RPC_REGNO)\n+\t(unspec:SI [(match_operand:SI 0 \"mep_r0_15_operand\" \"r\")\n+\t\t    (match_operand:SI 1 \"\" \"\")]\n+\t\t   UNS_REPEAT_BEG))]\n+  \"\"\n+  \"repeat\\\\t%0,%l1\"\n+  [(set_attr \"length\" \"4\")])\n+\n+(define_insn \"repeat_end\"\n+  [(unspec [(const_int 0)] UNS_REPEAT_END)]\n+  \"\"\n+  \"# repeat end\"\n+  [(set_attr \"length\" \"0\")])\n+\n+(define_insn \"erepeat\"\n+  [(unspec [(match_operand 0 \"\" \"\")] UNS_EREPEAT_BEG)]\n+  \"\"\n+  \"erepeat\\\\t%l0\"\n+  [(set_attr \"length\" \"4\")])\n+\n+(define_insn \"erepeat_end\"\n+  [(unspec [(const_int 0)] UNS_EREPEAT_END)]\n+  \"\"\n+  \"# erepeat end\"\n+  [(set_attr \"length\" \"0\")\n+   (set_attr \"slot\" \"multi\")])\n+\n+\f\n+;; ::::::::::::::::::::\n+;; ::\n+;; :: Prologue and Epilogue instructions\n+;; ::\n+;; ::::::::::::::::::::\n+\n+(define_expand \"prologue\"\n+  [(const_int 1)]\n+  \"\"\n+  \"\n+{\n+  mep_expand_prologue ();\n+  DONE;\n+}\")\n+\n+(define_expand \"epilogue\"\n+  [(return)]\n+  \"\"\n+  \"\n+{\n+  mep_expand_epilogue ();\n+  DONE;\n+}\")\n+\n+(define_expand \"eh_return\"\n+  [(use (match_operand:SI 0 \"register_operand\" \"r\"))]\n+  \"\"\n+  \"\n+{\n+  mep_expand_eh_return (operands);\n+  DONE;\n+}\")\n+\n+(define_insn_and_split \"eh_epilogue\"\n+  [(unspec [(match_operand:SI 0 \"register_operand\" \"r\")] UNS_EH_EPILOGUE)\n+   (use (reg:SI LP_REGNO))]\n+  \"\"\n+  \"#\"\n+  \"reload_completed\"\n+  [(const_int 1)]\n+  \"mep_emit_eh_epilogue (operands); DONE;\"\n+  [(set_attr \"slot\" \"multi\")])\n+\n+(define_expand \"sibcall_epilogue\"\n+  [(const_int 0)]\n+  \"\"\n+  \"\n+{\n+  mep_expand_sibcall_epilogue ();\n+  DONE;\n+}\")\n+\n+(define_insn \"mep_bb_trace_ret\"\n+  [(unspec_volatile [(const_int 0)] UNS_BB_TRACE_RET)]\n+  \"\"\n+  \"* return mep_emit_bb_trace_ret ();\"\n+  [(set_attr \"slot\" \"multi\")])\n+\n+(define_insn \"mep_disable_int\"\n+  [(unspec_volatile [(const_int 0)] UNS_DISABLE_INT)]\n+  \"\"\n+  \"di\"\n+  [(set_attr \"length\" \"2\")])\n+\n+(define_insn \"mep_enable_int\"\n+  [(unspec_volatile [(const_int 0)] UNS_ENABLE_INT)]\n+  \"\"\n+  \"ei\"\n+  [(set_attr \"length\" \"2\")])\n+\n+(define_insn \"mep_reti\"\n+  [(return)\n+   (unspec_volatile [(const_int 0)] UNS_RETI)]\n+  \"\"\n+  \"reti\"\n+  [(set_attr \"length\" \"2\")])\n+\f\n+;; ::::::::::::::::::::\n+;; ::\n+;; :: Miscellaneous instructions\n+;; ::\n+;; ::::::::::::::::::::\n+\n+(define_insn \"nop\"\n+  [(const_int 0)]\n+  \"\"\n+  \"nop\"\n+  [(set_attr \"length\" \"2\")])\n+\n+(define_insn \"nop32\"\n+  [(const_int 1)]\n+  \"\"\n+  \"or3\\\\t$0, $0, 0\"\n+  [(set_attr \"length\" \"4\")])\n+\n+(define_insn \"blockage\"\n+  [(unspec_volatile [(const_int 0)] UNS_BLOCKAGE)]\n+  \"\"\n+  \"\"\n+  [(set_attr \"length\" \"0\")\n+   (set_attr \"slot\" \"multi\")])\n+\n+\n+(define_insn \"djmark\"\n+  [(unspec_volatile [(const_int 0)] 999)]\n+  \"\"\n+  \"# dj\"\n+  [(set_attr \"length\" \"0\")\n+   (set_attr \"slot\" \"multi\")])\n+"}, {"sha": "d8b41345077e2523c794c81a52756c8cb293948a", "filename": "gcc/config/mep/mep.opt", "status": "added", "additions": 163, "deletions": 0, "changes": 163, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7acf4da6f94801cb3146709fc0ae310ac475a274/gcc%2Fconfig%2Fmep%2Fmep.opt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7acf4da6f94801cb3146709fc0ae310ac475a274/gcc%2Fconfig%2Fmep%2Fmep.opt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmep%2Fmep.opt?ref=7acf4da6f94801cb3146709fc0ae310ac475a274", "patch": "@@ -0,0 +1,163 @@\n+; Target specific command line options for the MEP port of the compiler.\n+; Copyright (C) 2005, 2007, 2009 Free Software Foundation, Inc.\n+; Contributed by Red Hat Inc.\n+;\n+; GCC is free software; you can redistribute it and/or modify it under\n+; the terms of the GNU General Public License as published by the Free\n+; Software Foundation; either version 3, or (at your option) any later\n+; version.\n+; \n+; GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+; WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+; FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+; for more details.\n+; \n+; You should have received a copy of the GNU General Public License\n+; along with GCC; see the file COPYING3.  If not see\n+; <http://www.gnu.org/licenses/>.  */\n+\n+mabsdiff\n+Target Mask(OPT_ABSDIFF)\n+Enable absolute difference instructions\n+\n+mall-opts\n+Target RejectNegative\n+Enable all optional instructions\n+\n+maverage\n+Target Mask(OPT_AVERAGE)\n+Enable average instructions\n+\n+mbased=\n+Target Joined Var(mep_based_cutoff) RejectNegative UInteger Init(0)\n+Variables this size and smaller go in the based section. (default 0)\n+\n+mbitops\n+Target Mask(OPT_BITOPS)\n+Enable bit manipulation instructions\n+\n+mc=\n+Target Joined Var(mep_const_section) RejectNegative\n+Section to put all const variables in (tiny, near, far) (no default)\n+\n+mclip\n+Target Mask(OPT_CLIP)\n+Enable clip instructions\n+\n+mconfig=\n+Target Joined Var(mep_config_string) RejectNegative\n+Configuration name\n+\n+mcop\n+Target Mask(COP)\n+Enable MeP Coprocessor\n+\n+mcop32\n+Target Mask(COP) MaskExists RejectNegative\n+Enable MeP Coprocessor with 32-bit registers\n+\n+mcop64\n+Target Mask(64BIT_CR_REGS) RejectNegative\n+Enable MeP Coprocessor with 64-bit registers\n+\n+mivc2\n+Target Mask(IVC2) RejectNegative\n+Enable IVC2 scheduling\n+\n+mdc\n+Target Mask(DC) RejectNegative\n+Const variables default to the near section\n+\n+mdebug\n+Target Disabled Undocumented\n+\n+mdiv\n+Target Mask(OPT_DIV)\n+Enable 32-bit divide instructions\n+\n+meb\n+Target InverseMask(LITTLE_ENDIAN) RejectNegative\n+Use big-endian byte order\n+\n+mel\n+Target Mask(LITTLE_ENDIAN) RejectNegative\n+Use little-endian byte order\n+\n+mfar\n+Target RejectNegative\n+Enable -ml, -mtf, and -mc=far\n+\n+mio-volatile\n+Target Mask(IO_VOLATILE) \n+__io vars are volatile by default\n+\n+ml\n+Target Mask(L) RejectNegative\n+All variables default to the far section\n+\n+mleadz\n+Target Mask(OPT_LEADZ)\n+Enable leading zero instructions\n+\n+mlibrary\n+Target Mask(LIBRARY) RejectNegative Undocumented\n+\n+mm\n+Target Mask(M) RejectNegative\n+All variables default to the near section\n+\n+mminmax\n+Target Mask(OPT_MINMAX)\n+Enable min/max instructions\n+\n+mmult\n+Target Mask(OPT_MULT)\n+Enable 32-bit multiply instructions\n+\n+mno-opts\n+Target RejectNegative\n+Disable all optional instructions\n+\n+mrand-tpgp\n+Target Mask(RAND_TPGP) RejectNegative Undocumented\n+\n+mrepeat\n+Target Mask(OPT_REPEAT)\n+Allow gcc to use the repeat/erepeat instructions\n+\n+ms\n+Target Mask(S) RejectNegative\n+All variables default to the tiny section\n+\n+msatur\n+Target Mask(OPT_SATUR)\n+Enable saturation instructions\n+\n+msdram\n+Target \n+Use sdram version of runtime\n+\n+msim\n+Target RejectNegative\n+Use simulator runtime\n+\n+msimnovec\n+Target RejectNegative\n+Use simulator runtime without vectors\n+\n+mtf\n+Target Mask(TF) RejectNegative\n+All functions default to the far section\n+\n+mtiny=\n+Target Joined Var(mep_tiny_cutoff) RejectNegative UInteger Init(4)\n+Variables this size and smaller go in the tiny section. (default 4)\n+\n+mvl32\n+Target InverseMask(OPT_VL64) Undocumented RejectNegative\n+\n+mvl64\n+Target Mask(OPT_VL64) Undocumented RejectNegative\n+\n+mvliw\n+Target Mask(VLIW) Undocumented"}, {"sha": "4ba3a6b82918ce703c5277f958d12a95627ccbab", "filename": "gcc/config/mep/predicates.md", "status": "added", "additions": 184, "deletions": 0, "changes": 184, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7acf4da6f94801cb3146709fc0ae310ac475a274/gcc%2Fconfig%2Fmep%2Fpredicates.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7acf4da6f94801cb3146709fc0ae310ac475a274/gcc%2Fconfig%2Fmep%2Fpredicates.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmep%2Fpredicates.md?ref=7acf4da6f94801cb3146709fc0ae310ac475a274", "patch": "@@ -0,0 +1,184 @@\n+;; Toshiba Media Processor Machine predicates\n+;; Copyright (C) 2009 Free Software Foundation, Inc.\n+;; Contributed by Red Hat Inc.\n+\n+;; This file is part of GCC.\n+;;\n+;; GCC is free software; you can redistribute it and/or modify it\n+;; under the terms of the GNU General Public License as published by\n+;; the Free Software Foundation; either version 3, or (at your option)\n+;; any later version.\n+;;\n+;; GCC is distributed in the hope that it will be useful, but WITHOUT\n+;; ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n+;; or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public\n+;; License for more details.\n+;;\n+;; You should have received a copy of the GNU General Public License\n+;; along with GCC; see the file COPYING3.  If not see\n+;; <http://www.gnu.org/licenses/>.  */\n+\n+;; (define_predicate \"cgen_h_uint_7a1_immediate\"\n+;;    (match_code \"const_int\"))\n+;; (define_predicate \"cgen_h_uint_6a2_immediate\"\n+;;    (match_code \"const_int\"))\n+;; (define_predicate \"cgen_h_uint_22a4_immediate\"\n+;;    (match_code \"const_int\"))\n+;; (define_predicate \"cgen_h_sint_2a1_immediate\"\n+;;    (match_code \"const_int\"))\n+;; (define_predicate \"cgen_h_uint_24a1_immediate\"\n+;;    (match_code \"const_int\"))\n+;; (define_predicate \"cgen_h_sint_6a1_immediate\"\n+;;    (match_code \"const_int\"))\n+;; (define_predicate \"cgen_h_uint_5a4_immediate\"\n+;;    (match_code \"const_int\"))\n+;; (define_predicate \"cgen_h_uint_2a1_immediate\"\n+;;    (match_code \"const_int\"))\n+;; (define_predicate \"cgen_h_uint_16a1_immediate\"\n+;;    (match_code \"const_int\"))\n+;; (define_predicate \"cgen_h_uint_3a1_immediate\"\n+;;    (match_code \"const_int\"))\n+;; (define_predicate \"cgen_h_uint_5a1_immediate\"\n+;;    (match_code \"const_int\"))\n+;; (define_predicate \"cgen_h_sint_16a1_immediate\"\n+;;    (match_code \"const_int\"))\n+;; (define_predicate \"cgen_h_sint_5a8_immediate\"\n+;;    (match_code \"const_int\"))\n+;; (define_predicate \"cgen_h_uint_4a1_immediate\"\n+;;    (match_code \"const_int\"))\n+\n+(define_predicate \"cgen_h_sint_7a2_immediate\"\n+   (match_code \"const_int\")\n+   { int i = INTVAL (op);\n+     return ((i & 1) == 0 && i >= -128 && i < 128);\n+   })\n+\n+(define_predicate \"cgen_h_sint_6a4_immediate\"\n+   (match_code \"const_int\")\n+   { int i = INTVAL (op);\n+     return ((i & 3) == 0 && i >= -256 && i < 256);\n+   })\n+\n+;; This is used below, to simplify things.\n+(define_predicate \"mep_subreg_operand\"\n+  (ior\n+   (and (and (and (match_code \"subreg\")\n+\t\t  (match_code \"reg\" \"0\"))\n+\t     (match_test \"REGNO (SUBREG_REG (op)) >= FIRST_PSEUDO_REGISTER\"))\n+\t(match_test \"!(reload_completed || reload_in_progress)\"))\n+   (and (match_code \"reg\")\n+\t(match_test \"REGNO (op) >= FIRST_PSEUDO_REGISTER\"))))\n+\n+(define_predicate \"symbolic_operand\"\n+  (match_code \"const,symbol_ref,label_ref\"))\n+\n+(define_predicate \"mep_farsym_operand\"\n+  (and (match_code \"const,symbol_ref\")\n+       (match_test \"mep_section_tag (op) == 'f'\")))\n+\n+(define_predicate \"mep_nearsym_operand\"\n+  (and (match_code \"const,symbol_ref,label_ref\")\n+       (match_test \"mep_section_tag (op) != 'f'\")))\n+\n+(define_predicate \"mep_movdest_operand\"\n+  (and (match_test \"mep_section_tag (op) != 'f'\")\n+       (match_operand 0 \"nonimmediate_operand\")))\n+\n+(define_predicate \"mep_r0_15_operand\"\n+  (ior (match_operand 0 \"mep_subreg_operand\")\n+       (and (match_code \"reg\")\n+\t    (match_test \"GR_REGNO_P (REGNO (op))\"))))\n+\n+(define_predicate \"mep_r0_operand\"\n+  (and (match_code \"reg\")\n+       (ior (match_test \"REGNO (op) == 0\")\n+\t    (match_test \"!(reload_completed || reload_in_progress)\n+\t\t         && REGNO (op) >= FIRST_PSEUDO_REGISTER\"))))\n+\n+(define_predicate \"mep_hi_operand\"\n+  (ior (match_operand 0 \"mep_subreg_operand\")\n+       (and (match_code \"reg\")\n+\t    (match_test \"REGNO (op) == HI_REGNO\"))))\n+\n+(define_predicate \"mep_lo_operand\"\n+  (ior (match_operand 0 \"mep_subreg_operand\")\n+       (and (match_code \"reg\")\n+\t    (match_test \"REGNO (op) == LO_REGNO\"))))\n+\n+(define_predicate \"mep_tp_operand\"\n+  (ior (match_operand 0 \"mep_subreg_operand\")\n+       (and (match_code \"reg\")\n+\t    (match_test \"REGNO (op) == TP_REGNO\"))))\n+\n+(define_predicate \"mep_gp_operand\"\n+  (ior (match_operand 0 \"mep_subreg_operand\")\n+       (and (match_code \"reg\")\n+\t    (match_test \"REGNO (op) == GP_REGNO\"))))\n+\n+(define_predicate \"mep_sp_operand\"\n+  (match_test \"op == stack_pointer_rtx\"))\n+\n+(define_predicate \"mep_tprel_operand\"\n+  (ior (match_operand 0 \"mep_subreg_operand\")\n+       (and (match_code \"reg\")\n+\t    (match_test \"REGNO (op) < 8\"))))\n+\n+(define_predicate \"mep_call_address_operand\"\n+  (and (match_test \"mep_section_tag (op) != 'f'\")\n+       (and (ior (not (match_code \"symbol_ref\"))\n+\t\t (match_test \"mep_section_tag (DECL_RTL (cfun->decl)) != 'f'\n+\t\t\t      && !mep_lookup_pragma_call (XSTR (op, 0))\"))\n+\t    (match_code \"symbol_ref,reg\"))))\n+\n+(define_predicate \"mep_Y_operand\"\n+  (and (match_code \"mem\")\n+       (match_code \"reg\" \"0\")))\n+\n+(define_predicate \"mep_imm4_operand\"\n+  (and (match_code \"const_int\")\n+       (match_test \"INTVAL (op) >= 0 && INTVAL (op) <= 15\")))\n+\n+(define_predicate \"mep_reg_or_imm4_operand\"\n+  (ior (match_code \"reg\")\n+       (and (match_code \"const_int\")\n+\t    (match_test \"INTVAL (op) >= 0 && INTVAL (op) <= 15\"))))\n+\n+(define_predicate \"mep_imm7a4_operand\"\n+  (and (match_code \"const_int\")\n+       (match_test \"INTVAL (op) >= 0 && INTVAL (op) < 128 && INTVAL (op) % 4 == 0\")))\n+\n+(define_predicate \"mep_slad_operand\"\n+  (and (match_code \"const_int\")\n+       (match_test \"INTVAL (op) == 2 || INTVAL (op) == 4\")))\n+\n+(define_predicate \"mep_add_operand\"\n+  (ior (and (match_code \"const\")\n+\t    (and (match_operand 0 \"symbolic_operand\")\n+\t\t (and (match_test \"mep_section_tag(op) == 'b' || mep_section_tag(op) == 't'\")\n+\t\t      (ior (match_code \"unspec\" \"0\")\n+\t\t\t   (and (match_code \"plus\" \"0\")\n+\t\t\t\t(match_code \"unspec\" \"00\"))))))\n+       (match_code \"const_int,reg\")))\n+\n+;; Return true if OP is an integer in the range 0..7 inclusive.\n+;; On the MeP-h1, shifts by such constants execute in a single stage\n+;; and shifts by larger values execute in two.\n+(define_predicate \"mep_single_shift_operand\"\n+  (and (match_code \"const_int\")\n+       (match_test \"INTVAL (op) >= 0 && INTVAL (op) <= 7\")))\n+\n+;; Return true if OP is an operation that can be performed using bsetm,\n+;; bclrm or bnotm.  The possibilities are:\n+\n+;; bsetm: (ior X Y), Y has one bit set\n+;; bclrm: (and X Y), Y has one bit clear\n+;; bnotm: (xor X Y), Y has one bit set.\n+(define_predicate \"mep_bit_operator\"\n+  (and (match_code \"and,ior,xor\")\n+       (match_test \"mep_bit_position_p (XEXP (op, 1), GET_CODE (op) != AND)\")))\n+\n+(define_predicate \"mep_reload_operand\"\n+  (ior (and (match_code \"reg\")\n+\t    (match_test \"!ANY_CONTROL_REGNO_P (REGNO (op))\"))\n+       (and (match_code \"mem,symbol_ref\")\n+\t    (match_test \"mep_section_tag (op) != 'f'\"))))"}, {"sha": "5fd7f94411676b874ee4848da07ff7c4c360267d", "filename": "gcc/config/mep/t-mep", "status": "added", "additions": 105, "deletions": 0, "changes": 105, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7acf4da6f94801cb3146709fc0ae310ac475a274/gcc%2Fconfig%2Fmep%2Ft-mep", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7acf4da6f94801cb3146709fc0ae310ac475a274/gcc%2Fconfig%2Fmep%2Ft-mep", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmep%2Ft-mep?ref=7acf4da6f94801cb3146709fc0ae310ac475a274", "patch": "@@ -0,0 +1,105 @@\n+# -*- makefile -*-\n+# GCC makefile fragment for MeP\n+# Copyright (C) 2001, 2002, 2003, 2005, 2007, 2009\n+# Free Software Foundation, Inc.\n+# Contributed by Red Hat Inc\n+#\n+# This file is part of GCC.\n+#\n+# GCC is free software; you can redistribute it and/or modify it\n+# under the terms of the GNU General Public License as published by\n+# the Free Software Foundation; either version 3, or (at your option)\n+# any later version.\n+#\n+# GCC is distributed in the hope that it will be useful, but WITHOUT\n+# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n+# or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public\n+# License for more details.\n+#\n+# You should have received a copy of the GNU General Public License\n+# along with GCC; see the file COPYING3.  If not see\n+# <http://www.gnu.org/licenses/>.  */\n+\n+# Force genpreds to be rebuilt in case MeP-Integrator changed the predicates\n+\n+GTM_H = tm.h $(tm_file_list) $(srcdir)/config/mep/mep-intrin.h\n+\n+# Use -O0 instead of -O2 so we don't get complex relocations\n+\n+CRTSTUFF_CFLAGS = -O0 $(GCC_CFLAGS) $(INCLUDES) $(MULTILIB_CFLAGS) -g0 \\\n+  -finhibit-size-directive -fno-inline-functions -fno-exceptions \\\n+  -fno-zero-initialized-in-bss -fno-unit-at-a-time\n+\n+TCFLAGS = -mlibrary\n+\n+mep-pragma.o: $(srcdir)/config/mep/mep-pragma.c $(CONFIG_H) $(SYSTEM_H) \\\n+\tcoretypes.h $(TM_H) $(TREE_H) $(RTL_H) toplev.h c-pragma.h \\\n+\t$(CPPLIB_H) hard-reg-set.h output.h $(srcdir)/config/mep/mep-protos.h \\\n+\tfunction.h insn-config.h reload.h $(TARGET_H)\n+\t$(CC) -c $(ALL_CFLAGS) $(ALL_CPPFLAGS) $(INCLUDES) $<\n+\n+# profiling support\n+\n+LIB1ASMSRC = mep/mep-lib1.asm\n+\n+LIB1ASMFUNCS = _mep_profile \\\n+\t       _mep_bb_init_trace \\\n+\t       _mep_bb_init \\\n+\t       _mep_bb_trace \\\n+\t       _mep_bb_increment\n+\n+# multiply and divide routines\n+\n+LIB2FUNCS_EXTRA = \\\n+\t$(srcdir)/config/mep/mep-lib2.c \\\n+\t$(srcdir)/config/mep/mep-tramp.c\n+\n+# floating point emulation libraries\n+\n+FPBIT = fp-bit.c\n+DPBIT = dp-bit.c\n+\n+fp-bit.c: $(srcdir)/config/fp-bit.c\n+\techo '#define FLOAT'\t\t\t\t> fp-bit.c\n+\tcat $(srcdir)/config/fp-bit.c\t\t\t>> fp-bit.c\n+\n+dp-bit.c: $(srcdir)/config/fp-bit.c\n+\tcat $(srcdir)/config/fp-bit.c > dp-bit.c\n+\n+MULTILIB_OPTIONS = mel mall-opts mfar\n+MULTILIB_DIRNAMES = el allopt far\n+\n+EXTRA_MULTILIB_PARTS = crtbegin.o crtend.o\n+\n+MD_INCLUDES = \\\n+\t$(srcdir)/config/mep/intrinsics.md \\\n+\t$(srcdir)/config/mep/predicates.md \\\n+\t$(srcdir)/config/mep/constraints.md\n+\n+mep.o : $(srcdir)/config/mep/mep-intrin.h\n+\n+# begin-isas\n+MEP_CORE = ext_core1\n+MEP_COPRO = ext_cop1_16,ext_cop1_32,ext_cop1_48,ext_cop1_64\n+# end-isas\n+\n+# To use this, you must have cgen and cgen/cpu in the same source tree as\n+# gcc.\n+cgen-maint :\n+\tS=`cd $(srcdir); pwd`; \\\n+\tcd $$S/config/mep && \\\n+\tguile -s $$S/../cgen/cgen-intrinsics.scm \\\n+\t\t-s $$S/../cgen \\\n+\t\t$(CGENFLAGS) \\\n+\t\t-a $$S/../cgen/cpu/mep.cpu \\\n+\t\t-m mep,c5 \\\n+\t\t-i mep,$(MEP_CORE),$(MEP_COPRO) \\\n+\t\t-K mep,$(MEP_CORE),$(MEP_COPRO) \\\n+\t\t-M intrinsics.md \\\n+\t\t-N mep-intrin.h \\\n+\t\t-P intrinsics.h\n+\n+# start-extra-headers\n+EXTRA_HEADERS = $(srcdir)/config/mep/intrinsics.h \\\n+\t$(srcdir)/config/mep/default.h\n+# end-extra-headers"}, {"sha": "138b03bcd19ec44540b1e2caf3d377de7519119e", "filename": "gcc/recog.c", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7acf4da6f94801cb3146709fc0ae310ac475a274/gcc%2Frecog.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7acf4da6f94801cb3146709fc0ae310ac475a274/gcc%2Frecog.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frecog.c?ref=7acf4da6f94801cb3146709fc0ae310ac475a274", "patch": "@@ -738,6 +738,17 @@ validate_replace_rtx_1 (rtx *loc, rtx from, rtx to, rtx object,\n     simplify_while_replacing (loc, to, object, op0_mode);\n }\n \n+/* Try replacing every occurrence of FROM in subexpression LOC of INSN\n+   with TO.  After all changes have been made, validate by seeing\n+   if INSN is still valid.  */\n+\n+int\n+validate_replace_rtx_subexp (rtx from, rtx to, rtx insn, rtx *loc)\n+{\n+  validate_replace_rtx_1 (loc, from, to, insn, true);\n+  return apply_change_group ();\n+}\n+\n /* Try replacing every occurrence of FROM in INSN with TO.  After all\n    changes have been made, validate by seeing if INSN is still valid.  */\n "}, {"sha": "4dce8d9a5ee96f05cba2f5a4125ce36aa559f18b", "filename": "gcc/recog.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7acf4da6f94801cb3146709fc0ae310ac475a274/gcc%2Frecog.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7acf4da6f94801cb3146709fc0ae310ac475a274/gcc%2Frecog.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frecog.h?ref=7acf4da6f94801cb3146709fc0ae310ac475a274", "patch": "@@ -86,6 +86,7 @@ extern int constrain_operands (int);\n extern int constrain_operands_cached (int);\n extern int memory_address_p (enum machine_mode, rtx);\n extern int strict_memory_address_p (enum machine_mode, rtx);\n+extern int validate_replace_rtx_subexp (rtx, rtx, rtx, rtx *);\n extern int validate_replace_rtx (rtx, rtx, rtx);\n extern int validate_replace_rtx_part (rtx, rtx, rtx *, rtx);\n extern int validate_replace_rtx_part_nosimplify (rtx, rtx, rtx *, rtx);"}, {"sha": "0c09e9d4dc7543d02366813d3482b2521c27c961", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7acf4da6f94801cb3146709fc0ae310ac475a274/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7acf4da6f94801cb3146709fc0ae310ac475a274/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=7acf4da6f94801cb3146709fc0ae310ac475a274", "patch": "@@ -1,3 +1,8 @@\n+2009-06-23  DJ Delorie  <dj@redhat.com>\n+\n+\tAdd MeP port.\n+\t* lib/target-supports.exp: Add mep support (no profiling).\n+\n 2009-06-23  Steve Ellcey  <sje@cup.hp.com>\n \n \tPR testsuite/39297"}, {"sha": "7c6d0eda63ecd004c574e4e154e1968ed514c579", "filename": "gcc/testsuite/lib/target-supports.exp", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7acf4da6f94801cb3146709fc0ae310ac475a274/gcc%2Ftestsuite%2Flib%2Ftarget-supports.exp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7acf4da6f94801cb3146709fc0ae310ac475a274/gcc%2Ftestsuite%2Flib%2Ftarget-supports.exp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Flib%2Ftarget-supports.exp?ref=7acf4da6f94801cb3146709fc0ae310ac475a274", "patch": "@@ -498,6 +498,7 @@ proc check_profiling_available { test_what } {\n \t     || [istarget m32c-*-elf]\n \t     || [istarget m68k-*-elf]\n \t     || [istarget m68k-*-uclinux*]\n+\t     || [istarget mep-*-elf]\n \t     || [istarget mips*-*-elf*]\n \t     || [istarget moxie-*-elf*]\n \t     || [istarget xstormy16-*]"}, {"sha": "01c35fc536688e323d4c666ec0c6bccdc4c9ec3c", "filename": "libgcc/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7acf4da6f94801cb3146709fc0ae310ac475a274/libgcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7acf4da6f94801cb3146709fc0ae310ac475a274/libgcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2FChangeLog?ref=7acf4da6f94801cb3146709fc0ae310ac475a274", "patch": "@@ -1,3 +1,8 @@\n+2009-06-23  DJ Delorie  <dj@redhat.com>\n+\n+\tAdd MeP port.\n+\t* config.host: Add mep support.\n+\n 2009-06-22  Kai Tietz  <kai.tietz@onevision.com>\n \n \t* config.host: Add i386/${host_address}/t-fprules-softfp and"}, {"sha": "7d70f772aea6e0e1859c047284458d7158f1ffd6", "filename": "libgcc/config.host", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7acf4da6f94801cb3146709fc0ae310ac475a274/libgcc%2Fconfig.host", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7acf4da6f94801cb3146709fc0ae310ac475a274/libgcc%2Fconfig.host", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig.host?ref=7acf4da6f94801cb3146709fc0ae310ac475a274", "patch": "@@ -102,6 +102,8 @@ m32r*-*-*)\n         ;;\n m68k-*-*)\n \t;;\n+mep*-*-*)\n+\t;;\n mips*-*-*)\n \tcpu_type=mips\n \t;;\n@@ -553,6 +555,8 @@ am33_2.0-*-linux*)\n \t;;\n m32c-*-elf*|m32c-*-rtems*)\n  \t;;\n+mep*-*-*)\n+\t;;\n *)\n \techo \"*** Configuration ${host} not supported\" 1>&2\n \texit 1"}, {"sha": "38f7f79dbfb594f634a51f5d08b28b234f1acd5f", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7acf4da6f94801cb3146709fc0ae310ac475a274/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7acf4da6f94801cb3146709fc0ae310ac475a274/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=7acf4da6f94801cb3146709fc0ae310ac475a274", "patch": "@@ -1,3 +1,8 @@\n+2009-06-23  DJ Delorie  <dj@redhat.com>\n+\n+\tAdd MeP port.\n+\t* configure.host: Add mep support.\n+\n 2009-06-23  Benjamin Kosnik  <bkoz@redhat.com>\n \n \t* doc/doxygen/user.cfg.in (PREDEFINED): Add _GLIBCXX_ATOMIC_BUILTINS_*."}, {"sha": "de7745a128646345336acb9665d3d950000e41aa", "filename": "libstdc++-v3/configure.host", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7acf4da6f94801cb3146709fc0ae310ac475a274/libstdc%2B%2B-v3%2Fconfigure.host", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7acf4da6f94801cb3146709fc0ae310ac475a274/libstdc%2B%2B-v3%2Fconfigure.host", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fconfigure.host?ref=7acf4da6f94801cb3146709fc0ae310ac475a274", "patch": "@@ -103,6 +103,10 @@ case \"${host_cpu}\" in\n   hppa*)\n     try_cpu=hppa\n     ;;\n+  mep*)\n+    EXTRA_CXX_FLAGS=-mm\n+    try_cpu=generic\n+    ;;\n   mips*)\n     try_cpu=mips\n     ;;"}]}