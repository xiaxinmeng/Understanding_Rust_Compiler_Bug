{"sha": "eeb0656f22538a0a3ca30b0761dc54ccda3837f5", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZWViMDY1NmYyMjUzOGEwYTNjYTMwYjA3NjFkYzU0Y2NkYTM4MzdmNQ==", "commit": {"author": {"name": "Mark Mitchell", "email": "mark@codesourcery.com", "date": "2000-04-24T00:51:08Z"}, "committer": {"name": "Mark Mitchell", "email": "mmitchel@gcc.gnu.org", "date": "2000-04-24T00:51:08Z"}, "message": "sort.c: New file.\n\n\t* sort.c: New file.\n\t* Makefile.in (CFILES): Add sort.c\n\t(REQUIRED_OFILES): Add sort.o.\n\t(sort.o): New target.\n\nFrom-SVN: r33364", "tree": {"sha": "c6ea8f9683750f0a500f0b4feebee9b5fee8540b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c6ea8f9683750f0a500f0b4feebee9b5fee8540b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/eeb0656f22538a0a3ca30b0761dc54ccda3837f5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/eeb0656f22538a0a3ca30b0761dc54ccda3837f5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/eeb0656f22538a0a3ca30b0761dc54ccda3837f5", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/eeb0656f22538a0a3ca30b0761dc54ccda3837f5/comments", "author": null, "committer": null, "parents": [{"sha": "8b2cfbe6ea278ca20073a496b52a21032a9913e7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8b2cfbe6ea278ca20073a496b52a21032a9913e7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8b2cfbe6ea278ca20073a496b52a21032a9913e7"}], "stats": {"total": 192, "additions": 188, "deletions": 4}, "files": [{"sha": "eb8ddfcce9e8027058e359ee8f32f41dee127034", "filename": "libiberty/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eeb0656f22538a0a3ca30b0761dc54ccda3837f5/libiberty%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eeb0656f22538a0a3ca30b0761dc54ccda3837f5/libiberty%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libiberty%2FChangeLog?ref=eeb0656f22538a0a3ca30b0761dc54ccda3837f5", "patch": "@@ -1,3 +1,10 @@\n+2000-04-23  Mark Mitchell  <mark@codesourcery.com>\n+\n+\t* sort.c: New file.\n+\t* Makefile.in (CFILES): Add sort.c\n+\t(REQUIRED_OFILES): Add sort.o.\n+\t(sort.o): New target.\n+\n 2000-04-21  Michael Sokolov  <msokolov@ivan.Harhan.ORG>\n \n \t* Makefile.in (*-subdir): Revamp slightly to avoid losing on"}, {"sha": "acb601193355749bd7f6beea5d3cc8b73def1307", "filename": "libiberty/Makefile.in", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eeb0656f22538a0a3ca30b0761dc54ccda3837f5/libiberty%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eeb0656f22538a0a3ca30b0761dc54ccda3837f5/libiberty%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libiberty%2FMakefile.in?ref=eeb0656f22538a0a3ca30b0761dc54ccda3837f5", "patch": "@@ -1,6 +1,6 @@\n #\n # Makefile\n-#   Copyright (C) 1990, 91 - 99, 2000\n+#   Copyright (C) 1990, 91, 91 - 99, 2000\n #   Free Software Foundation\n #\n # This file is part of the libiberty library.\n@@ -129,7 +129,7 @@ CFILES = asprintf.c alloca.c argv.c atexit.c basename.c bcmp.c bcopy.c\t      \\\n \tgetruntime.c floatformat.c hashtab.c hex.c index.c insque.c memchr.c  \\\n \tmemcmp.c memcpy.c memmove.c memset.c mkstemps.c objalloc.c obstack.c  \\\n \tpartition.c pexecute.c putenv.c random.c rename.c rindex.c\t      \\\n-\tsetenv.c sigsetmask.c spaces.c splay-tree.c strcasecmp.c\t      \\\n+\tsetenv.c sigsetmask.c sort.c spaces.c splay-tree.c strcasecmp.c\t      \\\n \tstrncasecmp.c strchr.c strdup.c strerror.c strrchr.c\t\t      \\\n \tstrsignal.c strstr.c strtod.c strtol.c strtoul.c tmpnam.c\t      \\\n \tvasprintf.c vfork.c vfprintf.c vprintf.c vsprintf.c waitpid.c\t      \\\n@@ -138,8 +138,8 @@ CFILES = asprintf.c alloca.c argv.c atexit.c basename.c bcmp.c bcopy.c\t      \\\n # These are always included in the library.\n REQUIRED_OFILES = argv.o choose-temp.o concat.o cplus-dem.o \\\n   fdmatch.o fnmatch.o getopt.o getopt1.o getpwd.o getruntime.o hashtab.o \\\n-  hex.o floatformat.o objalloc.o obstack.o partition.o pexecute.o spaces.o \\\n-  splay-tree.o strerror.o strsignal.o xatexit.o xexit.o xmalloc.o \\\n+  hex.o floatformat.o objalloc.o obstack.o partition.o pexecute.o sort.o \\\n+  spaces.o splay-tree.o strerror.o strsignal.o xatexit.o xexit.o xmalloc.o \\\n   xmemdup.o xstrdup.o xstrerror.o\n \n $(TARGETLIB): $(REQUIRED_OFILES) $(EXTRA_OFILES) $(LIBOBJS) $(ALLOCA)\n@@ -276,6 +276,7 @@ obstack.o: config.h $(INCDIR)/obstack.h\n partition.o: config.h $(INCDIR)/partition.h\n pexecute.o: config.h $(INCDIR)/libiberty.h\n setenv.o: config.h\n+sort.o: config.h $(INCDIR)/sort.h $(INCDIR)/ansidecl.h\n spaces.o: $(INCDIR)/libiberty.h\n splay-tree.o: config.h $(INCDIR)/libiberty.h $(INCDIR)/splay-tree.h $(INCDIR)/ansidecl.h\n strerror.o: config.h $(INCDIR)/libiberty.h"}, {"sha": "6dca09a9242e923dca8bd116b6ab6c0fceb76044", "filename": "libiberty/sort.c", "status": "added", "additions": 176, "deletions": 0, "changes": 176, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eeb0656f22538a0a3ca30b0761dc54ccda3837f5/libiberty%2Fsort.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eeb0656f22538a0a3ca30b0761dc54ccda3837f5/libiberty%2Fsort.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libiberty%2Fsort.c?ref=eeb0656f22538a0a3ca30b0761dc54ccda3837f5", "patch": "@@ -0,0 +1,176 @@\n+/* Sorting algorithms.\n+   Copyright (C) 2000 Free Software Foundation, Inc.\n+   Contributed by Mark Mitchell <mark@codesourcery.com>.\n+\n+This file is part of GNU CC.\n+   \n+GNU CC is free software; you can redistribute it and/or modify it\n+under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU CC is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU CC; see the file COPYING.  If not, write to\n+the Free Software Foundation, 59 Temple Place - Suite 330,\n+Boston, MA 02111-1307, USA.  */\n+\n+#ifdef HAVE_CONFIG_H\n+#include \"config.h\"\n+#endif\n+#include \"libiberty.h\"\n+#include \"sort.h\"\n+#include <limits.h>\n+#ifdef HAVE_STDLIB_H\n+#include <stdlib.h>\n+#endif\n+\n+/* POINTERSP and WORKP both point to arrays of N pointers.  When\n+   this function returns POINTERSP will point to a sorted version of\n+   the original array pointed to by POINTERSP.  */\n+\n+void sort_pointers (n, pointers, work)\n+     size_t n;\n+     void **pointers;\n+     void **work;\n+{\n+  /* The type of a single digit.  This can be any unsigned integral\n+     type.  When changing this, DIGIT_MAX should be changed as \n+     well.  */\n+  typedef unsigned char digit_t;\n+\n+  /* The maximum value a single digit can have.  */\n+#define DIGIT_MAX (UCHAR_MAX + 1)\n+\n+  /* The Ith entry is the number of elements in *POINTERSP that have I\n+     in the digit on which we are currently sorting.  */\n+  unsigned int count[DIGIT_MAX];\n+  /* Nonzero if we are running on a big-endian machine.  */\n+  int big_endian_p;\n+  size_t i;\n+  size_t j;\n+\n+  /* The algorithm used here is radix sort which takes time linear in\n+     the number of elements in the array.  */\n+\n+  /* The algorithm here depends on being able to swap the two arrays\n+     an even number of times.  */\n+  if ((sizeof (void *) / sizeof (digit_t)) % 2 != 0)\n+    abort ();\n+\n+  /* Figure out the endianness of the machine.  */\n+  for (i = 0; i < sizeof (size_t); ++i)\n+    ((char *)&j)[i] = i;\n+  big_endian_p = (((char *)&j)[0] == 0);\n+\n+  /* Move through the pointer values from least significant to most\n+     significant digits.  */\n+  for (i = 0; i < sizeof (void *) / sizeof (digit_t); ++i)\n+    {\n+      digit_t *digit;\n+      digit_t *bias;\n+      digit_t *top;\n+      unsigned int *countp;\n+      void **pointerp;\n+\n+      /* The offset from the start of the pointer will depend on the\n+\t endianness of the machine.  */\n+      if (big_endian_p)\n+\tj = sizeof (void *) / sizeof (digit_t) - i;\n+      else\n+\tj = i;\n+\t\n+      /* Now, perform a stable sort on this digit.  We use counting\n+\t sort.  */\n+      memset (count, 0, DIGIT_MAX * sizeof (unsigned int));\n+\n+      /* Compute the address of the appropriate digit in the first and\n+\t one-past-the-end elements of the array.  On a little-endian\n+\t machine, the least-significant digit is closest to the front.  */\n+      bias = ((digit_t *) pointers) + i;\n+      top = ((digit_t *) (pointers + n)) + i;\n+\n+      /* Count how many there are of each value.  At the end of this\n+\t loop, COUNT[K] will contain the number of pointers whose Ith\n+\t digit is K.  */\n+      for (digit = bias; \n+\t   digit < top; \n+\t   digit += sizeof (void *) / sizeof (digit_t))\n+\t++count[*digit];\n+\n+      /* Now, make COUNT[K] contain the number of pointers whose Ith\n+\t digit is less than or equal to K.  */\n+      for (countp = count + 1; countp < count + DIGIT_MAX; ++countp)\n+\t*countp += countp[-1];\n+\n+      /* Now, drop the pointers into their correct locations.  */\n+      for (pointerp = pointers + n - 1; pointerp >= pointers; --pointerp)\n+\twork[--count[((digit_t *) pointerp)[i]]] = *pointerp;\n+\n+      /* Swap WORK and POINTERS so that POINTERS contains the sorted\n+\t array.  */\n+      pointerp = pointers;\n+      pointers = work;\n+      work = pointerp;\n+    }\n+}\n+\n+/* Everything below here is a unit test for the routines in this\n+   file.  */\n+\n+#ifdef UNIT_TEST\n+\n+#include <stdio.h>\n+\n+void *xmalloc (n)\n+     size_t n;\n+{\n+  return malloc (n);\n+}\n+\n+int main (int argc, char **argv)\n+{\n+  int k;\n+  int result;\n+  size_t i;\n+  void **pointers;\n+  void **work;\n+\n+  if (argc > 1)\n+    k = atoi (argv[1]);\n+  else\n+    k = 10;\n+\n+  pointers = xmalloc (k * sizeof (void *));\n+  work = xmalloc (k * sizeof (void *));\n+\n+  for (i = 0; i < k; ++i)\n+    {\n+      pointers[i] = (void *) random ();\n+      printf (\"%x\\n\", pointers[i]);\n+    }\n+\n+  sort_pointers (k, pointers, work);\n+\n+  printf (\"\\nSorted\\n\\n\");\n+\n+  result = 0;\n+\n+  for (i = 0; i < k; ++i)\n+    {\n+      printf (\"%x\\n\", pointers[i]);\n+      if (i > 0 && (char*) pointers[i] < (char*) pointers[i - 1])\n+\tresult = 1;\n+    }\n+\n+  free (pointers);\n+  free (work);\n+\n+  return result;\n+}\n+\n+#endif"}]}