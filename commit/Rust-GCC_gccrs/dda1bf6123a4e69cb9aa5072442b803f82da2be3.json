{"sha": "dda1bf6123a4e69cb9aa5072442b803f82da2be3", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZGRhMWJmNjEyM2E0ZTY5Y2I5YWE1MDcyNDQyYjgwM2Y4MmRhMmJlMw==", "commit": {"author": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2016-04-15T12:24:18Z"}, "committer": {"name": "Jakub Jelinek", "email": "jakub@gcc.gnu.org", "date": "2016-04-15T12:24:18Z"}, "message": "re PR c/70436 (-Wparentheses missing ambiguous else warning)\n\n\tPR c/70436\nc/\n\t* c-parser.c (c_parser_pragma): Add IF_P argument, pass it down\n\twhere needed.\n\t(c_parser_external_declaration, c_parser_struct_or_union_specifier,\n\tc_parser_parameter_declaration, c_parser_compound_statement_nostart,\n\tc_parser_objc_class_instance_variables, c_parser_objc_methodprotolist):\n\tAdjust c_parser_pragma callers.\n\t(c_parser_statement_after_labels): Likewise.  Adjust c_parser_cilk_for\n\tcaller.\n\t(c_parser_omp_structured_block): Add IF_P argument, pass it down to\n\tc_parser_statement.\n\t(c_parser_oacc_data, c_parser_oacc_host_data, c_parser_oacc_loop,\n\tc_parser_oacc_kernels_parallel, c_parser_omp_critical,\n\tc_parser_omp_simd, c_parser_omp_for, c_parser_omp_master,\n\tc_parser_omp_ordered, c_parser_omp_parallel, c_parser_omp_single,\n\tc_parser_omp_task, c_parser_omp_taskgroup, c_parser_omp_distribute,\n\tc_parser_omp_teams, c_parser_omp_target_data, c_parser_omp_target,\n\tc_parser_omp_taskloop, c_parser_omp_construct, c_parser_cilk_grainsize,\n\tc_parser_cilk_simd, c_parser_cilk_for): Add IF_P argument, pass it\n\tdown where needed.\n\t(c_parser_omp_for_loop): Likewise.  Clear IF_P if nbraces.\n\t(c_parser_omp_sections_scope): Adjust c_parser_omp_structured_block\n\tcalls.\ncp/\n\t* parser.c (cp_parser_pragma): Add IF_P argument, pass it down\n\twhere needed.\n\t(cp_parser_declaration_seq_opt, cp_parser_member_specification_opt,\n\tcp_parser_objc_interstitial_code, cp_parser_omp_declare_simd,\n\tcp_parser_oacc_routine): Adjust cp_parser_pragma callers.\n\t(cp_parser_statement): Likewise.  Adjust cp_parser_cilk_for caller.\n\t(cp_parser_omp_structured_block): Add IF_P argument, pass it down to\n\tcp_parser_statement.\n\t(cp_parser_oacc_data, cp_parser_oacc_host_data, cp_parser_oacc_loop,\n\tcp_parser_oacc_kernels_parallel, cp_parser_omp_critical,\n\tcp_parser_omp_simd, cp_parser_omp_for, cp_parser_omp_master,\n\tcp_parser_omp_ordered, cp_parser_omp_parallel, cp_parser_omp_single,\n\tcp_parser_omp_task, cp_parser_omp_taskgroup, cp_parser_omp_distribute,\n\tcp_parser_omp_teams, cp_parser_omp_target_data, cp_parser_omp_target,\n\tcp_parser_omp_taskloop, cp_parser_omp_construct,\n\tcp_parser_cilk_grainsize, cp_parser_cilk_simd, cp_parser_cilk_for):\n\tAdd IF_P argument, pass it down where needed.\n\t(cp_parser_omp_for_loop): Likewise.  Clear IF_P if nbraces.\n\t(cp_parser_omp_sections_scope): Adjust cp_parser_omp_structured_block\n\tcalls.\ntestsuite/\n\t* c-c++-common/Wparentheses-1.c: New test.\n\t* c-c++-common/gomp/Wparentheses-1.c: New test.\n\t* c-c++-common/gomp/Wparentheses-2.c: New test.\n\t* c-c++-common/gomp/Wparentheses-3.c: New test.\n\t* c-c++-common/gomp/Wparentheses-4.c: New test.\n\t* c-c++-common/cilk-plus/PS/Wparentheses-1.c: New test.\n\t* c-c++-common/cilk-plus/CK/Wparentheses-1.c: New test.\n\t* c-c++-common/goacc/Wparentheses-1.c: New test.\n\nFrom-SVN: r235020", "tree": {"sha": "1a0514ea3a8182e7b4be92bcb5f3ff6734da03f9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1a0514ea3a8182e7b4be92bcb5f3ff6734da03f9"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/dda1bf6123a4e69cb9aa5072442b803f82da2be3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dda1bf6123a4e69cb9aa5072442b803f82da2be3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/dda1bf6123a4e69cb9aa5072442b803f82da2be3", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dda1bf6123a4e69cb9aa5072442b803f82da2be3/comments", "author": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "60cbb674776db42617d6f66487ff4074ee7862ba", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/60cbb674776db42617d6f66487ff4074ee7862ba", "html_url": "https://github.com/Rust-GCC/gccrs/commit/60cbb674776db42617d6f66487ff4074ee7862ba"}], "stats": {"total": 2438, "additions": 2228, "deletions": 210}, "files": [{"sha": "3ba3f4ea2d2cef7faa19df3f780b702471c9241a", "filename": "gcc/c/ChangeLog", "status": "modified", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dda1bf6123a4e69cb9aa5072442b803f82da2be3/gcc%2Fc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dda1bf6123a4e69cb9aa5072442b803f82da2be3/gcc%2Fc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc%2FChangeLog?ref=dda1bf6123a4e69cb9aa5072442b803f82da2be3", "patch": "@@ -1,3 +1,29 @@\n+2016-04-15  Jakub Jelinek  <jakub@redhat.com>\n+\n+\tPR c/70436\n+\t* c-parser.c (c_parser_pragma): Add IF_P argument, pass it down\n+\twhere needed.\n+\t(c_parser_external_declaration, c_parser_struct_or_union_specifier,\n+\tc_parser_parameter_declaration, c_parser_compound_statement_nostart,\n+\tc_parser_objc_class_instance_variables, c_parser_objc_methodprotolist):\n+\tAdjust c_parser_pragma callers.\n+\t(c_parser_statement_after_labels): Likewise.  Adjust c_parser_cilk_for\n+\tcaller.\n+\t(c_parser_omp_structured_block): Add IF_P argument, pass it down to\n+\tc_parser_statement.\n+\t(c_parser_oacc_data, c_parser_oacc_host_data, c_parser_oacc_loop,\n+\tc_parser_oacc_kernels_parallel, c_parser_omp_critical,\n+\tc_parser_omp_simd, c_parser_omp_for, c_parser_omp_master,\n+\tc_parser_omp_ordered, c_parser_omp_parallel, c_parser_omp_single,\n+\tc_parser_omp_task, c_parser_omp_taskgroup, c_parser_omp_distribute,\n+\tc_parser_omp_teams, c_parser_omp_target_data, c_parser_omp_target,\n+\tc_parser_omp_taskloop, c_parser_omp_construct, c_parser_cilk_grainsize,\n+\tc_parser_cilk_simd, c_parser_cilk_for): Add IF_P argument, pass it\n+\tdown where needed.\n+\t(c_parser_omp_for_loop): Likewise.  Clear IF_P if nbraces.\n+\t(c_parser_omp_sections_scope): Adjust c_parser_omp_structured_block\n+\tcalls.\n+\n 2016-04-13  Marek Polacek  <polacek@redhat.com>\n \n \tPR c/70436"}, {"sha": "1b6bacd7498fb8ec37dc4b76bcfa26eacc1c8e1b", "filename": "gcc/c/c-parser.c", "status": "modified", "additions": 136, "deletions": 108, "changes": 244, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dda1bf6123a4e69cb9aa5072442b803f82da2be3/gcc%2Fc%2Fc-parser.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dda1bf6123a4e69cb9aa5072442b803f82da2be3/gcc%2Fc%2Fc-parser.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc%2Fc-parser.c?ref=dda1bf6123a4e69cb9aa5072442b803f82da2be3", "patch": "@@ -1342,24 +1342,24 @@ static vec<tree, va_gc> *c_parser_expr_list (c_parser *, bool, bool,\n static void c_parser_oacc_declare (c_parser *);\n static void c_parser_oacc_enter_exit_data (c_parser *, bool);\n static void c_parser_oacc_update (c_parser *);\n-static void c_parser_omp_construct (c_parser *);\n+static void c_parser_omp_construct (c_parser *, bool *);\n static void c_parser_omp_threadprivate (c_parser *);\n static void c_parser_omp_barrier (c_parser *);\n static void c_parser_omp_flush (c_parser *);\n static tree c_parser_omp_for_loop (location_t, c_parser *, enum tree_code,\n-\t\t\t\t   tree, tree *);\n+\t\t\t\t   tree, tree *, bool *);\n static void c_parser_omp_taskwait (c_parser *);\n static void c_parser_omp_taskyield (c_parser *);\n static void c_parser_omp_cancel (c_parser *);\n static void c_parser_omp_cancellation_point (c_parser *);\n \n enum pragma_context { pragma_external, pragma_struct, pragma_param,\n \t\t      pragma_stmt, pragma_compound };\n-static bool c_parser_pragma (c_parser *, enum pragma_context);\n-static bool c_parser_omp_target (c_parser *, enum pragma_context);\n+static bool c_parser_pragma (c_parser *, enum pragma_context, bool *);\n+static bool c_parser_omp_target (c_parser *, enum pragma_context, bool *);\n static void c_parser_omp_end_declare_target (c_parser *);\n static void c_parser_omp_declare (c_parser *, enum pragma_context);\n-static bool c_parser_omp_ordered (c_parser *, enum pragma_context);\n+static bool c_parser_omp_ordered (c_parser *, enum pragma_context, bool *);\n static void c_parser_oacc_routine (c_parser *parser, enum pragma_context);\n \n /* These Objective-C parser functions are only ever called when\n@@ -1390,12 +1390,12 @@ static bool c_parser_objc_diagnose_bad_element_prefix\n   (c_parser *, struct c_declspecs *);\n \n /* Cilk Plus supporting routines.  */\n-static void c_parser_cilk_simd (c_parser *);\n-static void c_parser_cilk_for (c_parser *, tree);\n+static void c_parser_cilk_simd (c_parser *, bool *);\n+static void c_parser_cilk_for (c_parser *, tree, bool *);\n static bool c_parser_cilk_verify_simd (c_parser *, enum pragma_context);\n static tree c_parser_array_notation (location_t, c_parser *, tree, tree);\n static tree c_parser_cilk_clause_vectorlength (c_parser *, tree, bool);\n-static void c_parser_cilk_grainsize (c_parser *);\n+static void c_parser_cilk_grainsize (c_parser *, bool *);\n \n /* Parse a translation unit (C90 6.7, C99 6.9).\n \n@@ -1527,7 +1527,7 @@ c_parser_external_declaration (c_parser *parser)\n       break;\n     case CPP_PRAGMA:\n       mark_valid_location_for_stdc_pragma (true);\n-      c_parser_pragma (parser, pragma_external);\n+      c_parser_pragma (parser, pragma_external, NULL);\n       mark_valid_location_for_stdc_pragma (false);\n       break;\n     case CPP_PLUS:\n@@ -2927,7 +2927,7 @@ c_parser_struct_or_union_specifier (c_parser *parser)\n \t  /* Accept #pragmas at struct scope.  */\n \t  if (c_parser_next_token_is (parser, CPP_PRAGMA))\n \t    {\n-\t      c_parser_pragma (parser, pragma_struct);\n+\t      c_parser_pragma (parser, pragma_struct, NULL);\n \t      continue;\n \t    }\n \t  /* Parse some comma-separated declarations, but not the\n@@ -3796,7 +3796,7 @@ c_parser_parameter_declaration (c_parser *parser, tree attrs)\n \n   /* Accept #pragmas between parameter declarations.  */\n   while (c_parser_next_token_is (parser, CPP_PRAGMA))\n-    c_parser_pragma (parser, pragma_param);\n+    c_parser_pragma (parser, pragma_param, NULL);\n \n   if (!c_parser_next_token_starts_declspecs (parser))\n     {\n@@ -4824,7 +4824,8 @@ c_parser_compound_statement_nostart (c_parser *parser)\n \t     places that would turn into syntax errors if the directive\n \t     were ignored.  */\n \t  if (c_parser_pragma (parser,\n-\t\t\t       last_label ? pragma_stmt : pragma_compound))\n+\t\t\t       last_label ? pragma_stmt : pragma_compound,\n+\t\t\t       NULL))\n \t    last_label = false, last_stmt = true;\n \t}\n       else if (c_parser_next_token_is (parser, CPP_EOF))\n@@ -5156,7 +5157,7 @@ c_parser_statement_after_labels (c_parser *parser, bool *if_p,\n \t      c_parser_skip_to_end_of_block_or_statement (parser);\n \t    }\n \t  else\n-\t    c_parser_cilk_for (parser, integer_zero_node);\n+\t    c_parser_cilk_for (parser, integer_zero_node, if_p);\n \t  break;\n \tcase RID_CILK_SYNC:\n \t  c_parser_consume_token (parser);\n@@ -5276,7 +5277,7 @@ c_parser_statement_after_labels (c_parser *parser, bool *if_p,\n       c_parser_consume_token (parser);\n       break;\n     case CPP_PRAGMA:\n-      c_parser_pragma (parser, pragma_stmt);\n+      c_parser_pragma (parser, pragma_stmt, if_p);\n       break;\n     default:\n     expr_stmt:\n@@ -8787,7 +8788,7 @@ c_parser_objc_class_instance_variables (c_parser *parser)\n \t}\n       else if (c_parser_next_token_is (parser, CPP_PRAGMA))\n \t{\n-\t  c_parser_pragma (parser, pragma_external);\n+\t  c_parser_pragma (parser, pragma_external, NULL);\n \t  continue;\n \t}\n \n@@ -9058,7 +9059,7 @@ c_parser_objc_methodprotolist (c_parser *parser)\n \t  c_parser_objc_methodproto (parser);\n \t  break;\n \tcase CPP_PRAGMA:\n-\t  c_parser_pragma (parser, pragma_external);\n+\t  c_parser_pragma (parser, pragma_external, NULL);\n \t  break;\n \tcase CPP_EOF:\n \t  return;\n@@ -10019,7 +10020,7 @@ c_parser_objc_at_dynamic_declaration (c_parser *parser)\n    true if we actually parsed such a pragma.  */\n \n static bool\n-c_parser_pragma (c_parser *parser, enum pragma_context context)\n+c_parser_pragma (c_parser *parser, enum pragma_context context, bool *if_p)\n {\n   unsigned int id;\n \n@@ -10126,7 +10127,7 @@ c_parser_pragma (c_parser *parser, enum pragma_context context)\n       return false;\n \n     case PRAGMA_OMP_TARGET:\n-      return c_parser_omp_target (parser, context);\n+      return c_parser_omp_target (parser, context, if_p);\n \n     case PRAGMA_OMP_END_DECLARE_TARGET:\n       c_parser_omp_end_declare_target (parser);\n@@ -10144,7 +10145,7 @@ c_parser_pragma (c_parser *parser, enum pragma_context context)\n       return false;\n \n     case PRAGMA_OMP_ORDERED:\n-      return c_parser_omp_ordered (parser, context);\n+      return c_parser_omp_ordered (parser, context, if_p);\n \n     case PRAGMA_IVDEP:\n       c_parser_consume_pragma (parser);\n@@ -10157,9 +10158,9 @@ c_parser_pragma (c_parser *parser, enum pragma_context context)\n \t  return false;\n \t}\n       if (c_parser_next_token_is_keyword (parser, RID_FOR))\n-\tc_parser_for_statement (parser, true, NULL);\n+\tc_parser_for_statement (parser, true, if_p);\n       else if (c_parser_next_token_is_keyword (parser, RID_WHILE))\n-\tc_parser_while_statement (parser, true, NULL);\n+\tc_parser_while_statement (parser, true, if_p);\n       else\n \tc_parser_do_statement (parser, true);\n       return false;\n@@ -10173,7 +10174,7 @@ c_parser_pragma (c_parser *parser, enum pragma_context context)\n       if (!c_parser_cilk_verify_simd (parser, context))\n \treturn false;\n       c_parser_consume_pragma (parser);\n-      c_parser_cilk_simd (parser);\n+      c_parser_cilk_simd (parser, if_p);\n       return false;\n     case PRAGMA_CILK_GRAINSIZE:\n       if (!flag_cilkplus)\n@@ -10190,7 +10191,7 @@ c_parser_pragma (c_parser *parser, enum pragma_context context)\n \t  c_parser_skip_until_found (parser, CPP_PRAGMA_EOL, NULL);\n \t  return false;\n \t}\n-      c_parser_cilk_grainsize (parser);\n+      c_parser_cilk_grainsize (parser, if_p);\n       return false;\n \n     default:\n@@ -10203,7 +10204,7 @@ c_parser_pragma (c_parser *parser, enum pragma_context context)\n \t      c_parser_skip_until_found (parser, CPP_PRAGMA_EOL, NULL);\n \t      return false;\n \t    }\n-\t  c_parser_omp_construct (parser);\n+\t  c_parser_omp_construct (parser, if_p);\n \t  return true;\n \t}\n       break;\n@@ -13477,10 +13478,10 @@ c_parser_omp_all_clauses (c_parser *parser, omp_clause_mask mask,\n    c_parser_statement calls add_stmt.  */\n \n static tree\n-c_parser_omp_structured_block (c_parser *parser)\n+c_parser_omp_structured_block (c_parser *parser, bool *if_p)\n {\n   tree stmt = push_stmt_list ();\n-  c_parser_statement (parser, NULL);\n+  c_parser_statement (parser, if_p);\n   return pop_stmt_list (stmt);\n }\n \n@@ -13530,15 +13531,15 @@ c_parser_oacc_cache (location_t loc, c_parser *parser)\n \t| (OMP_CLAUSE_MASK_1 << PRAGMA_OACC_CLAUSE_PRESENT_OR_CREATE) )\n \n static tree\n-c_parser_oacc_data (location_t loc, c_parser *parser)\n+c_parser_oacc_data (location_t loc, c_parser *parser, bool *if_p)\n {\n   tree stmt, clauses, block;\n \n   clauses = c_parser_oacc_all_clauses (parser, OACC_DATA_CLAUSE_MASK,\n \t\t\t\t       \"#pragma acc data\");\n \n   block = c_begin_omp_parallel ();\n-  add_stmt (c_parser_omp_structured_block (parser));\n+  add_stmt (c_parser_omp_structured_block (parser, if_p));\n \n   stmt = c_finish_oacc_data (loc, clauses, block);\n \n@@ -13784,15 +13785,15 @@ c_parser_oacc_enter_exit_data (c_parser *parser, bool enter)\n \t( (OMP_CLAUSE_MASK_1 << PRAGMA_OACC_CLAUSE_USE_DEVICE) )\n \n static tree\n-c_parser_oacc_host_data (location_t loc, c_parser *parser)\n+c_parser_oacc_host_data (location_t loc, c_parser *parser, bool *if_p)\n {\n   tree stmt, clauses, block;\n \n   clauses = c_parser_oacc_all_clauses (parser, OACC_HOST_DATA_CLAUSE_MASK,\n \t\t\t\t       \"#pragma acc host_data\");\n \n   block = c_begin_omp_parallel ();\n-  add_stmt (c_parser_omp_structured_block (parser));\n+  add_stmt (c_parser_omp_structured_block (parser, if_p));\n   stmt = c_finish_oacc_host_data (loc, clauses, block);\n   return stmt;\n }\n@@ -13819,7 +13820,7 @@ c_parser_oacc_host_data (location_t loc, c_parser *parser)\n \t| (OMP_CLAUSE_MASK_1 << PRAGMA_OACC_CLAUSE_TILE) )\n static tree\n c_parser_oacc_loop (location_t loc, c_parser *parser, char *p_name,\n-\t\t    omp_clause_mask mask, tree *cclauses)\n+\t\t    omp_clause_mask mask, tree *cclauses, bool *if_p)\n {\n   strcat (p_name, \" loop\");\n   mask |= OACC_LOOP_CLAUSE_MASK;\n@@ -13836,7 +13837,8 @@ c_parser_oacc_loop (location_t loc, c_parser *parser, char *p_name,\n     }\n \n   tree block = c_begin_compound_stmt (true);\n-  tree stmt = c_parser_omp_for_loop (loc, parser, OACC_LOOP, clauses, NULL);\n+  tree stmt = c_parser_omp_for_loop (loc, parser, OACC_LOOP, clauses, NULL,\n+\t\t\t\t     if_p);\n   block = c_end_compound_stmt (loc, block, true);\n   add_stmt (block);\n \n@@ -13895,7 +13897,8 @@ c_parser_oacc_loop (location_t loc, c_parser *parser, char *p_name,\n \n static tree\n c_parser_oacc_kernels_parallel (location_t loc, c_parser *parser,\n-\t\t\t\tenum pragma_kind p_kind, char *p_name)\n+\t\t\t\tenum pragma_kind p_kind, char *p_name,\n+\t\t\t\tbool *if_p)\n {\n   omp_clause_mask mask;\n   enum tree_code code;\n@@ -13925,15 +13928,15 @@ c_parser_oacc_kernels_parallel (location_t loc, c_parser *parser,\n \n \t  tree block = c_begin_omp_parallel ();\n \t  tree clauses;\n-\t  c_parser_oacc_loop (loc, parser, p_name, mask, &clauses);\n+\t  c_parser_oacc_loop (loc, parser, p_name, mask, &clauses, if_p);\n \t  return c_finish_omp_construct (loc, code, block, clauses);\n \t}\n     }\n \n   tree clauses = c_parser_oacc_all_clauses (parser, mask, p_name);\n \n   tree block = c_begin_omp_parallel ();\n-  add_stmt (c_parser_omp_structured_block (parser));\n+  add_stmt (c_parser_omp_structured_block (parser, if_p));\n \n   return c_finish_omp_construct (loc, code, block, clauses);\n }\n@@ -14576,7 +14579,7 @@ c_parser_omp_barrier (c_parser *parser)\n \t( (OMP_CLAUSE_MASK_1 << PRAGMA_OMP_CLAUSE_HINT) )\n \n static tree\n-c_parser_omp_critical (location_t loc, c_parser *parser)\n+c_parser_omp_critical (location_t loc, c_parser *parser, bool *if_p)\n {\n   tree stmt, name = NULL_TREE, clauses = NULL_TREE;\n \n@@ -14603,7 +14606,7 @@ c_parser_omp_critical (location_t loc, c_parser *parser)\n       c_parser_skip_to_pragma_eol (parser);\n     }\n \n-  stmt = c_parser_omp_structured_block (parser);\n+  stmt = c_parser_omp_structured_block (parser, if_p);\n   return c_finish_omp_critical (loc, stmt, name, clauses);\n }\n \n@@ -14635,7 +14638,7 @@ c_parser_omp_flush (c_parser *parser)\n \n static tree\n c_parser_omp_for_loop (location_t loc, c_parser *parser, enum tree_code code,\n-\t\t       tree clauses, tree *cclauses)\n+\t\t       tree clauses, tree *cclauses, bool *if_p)\n {\n   tree decl, cond, incr, save_break, save_cont, body, init, stmt, cl;\n   tree declv, condv, incrv, initv, ret = NULL_TREE;\n@@ -14865,6 +14868,9 @@ c_parser_omp_for_loop (location_t loc, c_parser *parser, enum tree_code code,\n       nbraces += bracecount;\n     }\n \n+  if (nbraces)\n+    if_p = NULL;\n+\n   save_break = c_break_label;\n   if (code == CILK_SIMD)\n     c_break_label = build_int_cst (size_type_node, 2);\n@@ -14882,7 +14888,7 @@ c_parser_omp_for_loop (location_t loc, c_parser *parser, enum tree_code code,\n       add_stmt (c_end_compound_stmt (here, stmt, true));\n     }\n   else\n-    add_stmt (c_parser_c99_block_statement (parser, NULL));\n+    add_stmt (c_parser_c99_block_statement (parser, if_p));\n   if (c_cont_label)\n     {\n       tree t = build1 (LABEL_EXPR, void_type_node, c_cont_label);\n@@ -15025,7 +15031,8 @@ omp_split_clauses (location_t loc, enum tree_code code,\n \n static tree\n c_parser_omp_simd (location_t loc, c_parser *parser,\n-\t\t   char *p_name, omp_clause_mask mask, tree *cclauses)\n+\t\t   char *p_name, omp_clause_mask mask, tree *cclauses,\n+\t\t   bool *if_p)\n {\n   tree block, clauses, ret;\n \n@@ -15049,7 +15056,7 @@ c_parser_omp_simd (location_t loc, c_parser *parser,\n     }\n \n   block = c_begin_compound_stmt (true);\n-  ret = c_parser_omp_for_loop (loc, parser, OMP_SIMD, clauses, cclauses);\n+  ret = c_parser_omp_for_loop (loc, parser, OMP_SIMD, clauses, cclauses, if_p);\n   block = c_end_compound_stmt (loc, block, true);\n   add_stmt (block);\n \n@@ -15080,7 +15087,8 @@ c_parser_omp_simd (location_t loc, c_parser *parser,\n \n static tree\n c_parser_omp_for (location_t loc, c_parser *parser,\n-\t\t  char *p_name, omp_clause_mask mask, tree *cclauses)\n+\t\t  char *p_name, omp_clause_mask mask, tree *cclauses,\n+\t\t  bool *if_p)\n {\n   tree block, clauses, ret;\n \n@@ -15104,9 +15112,10 @@ c_parser_omp_for (location_t loc, c_parser *parser,\n \n \t  c_parser_consume_token (parser);\n \t  if (!flag_openmp)  /* flag_openmp_simd  */\n-\t    return c_parser_omp_simd (loc, parser, p_name, mask, cclauses);\n+\t    return c_parser_omp_simd (loc, parser, p_name, mask, cclauses,\n+\t\t\t\t      if_p);\n \t  block = c_begin_compound_stmt (true);\n-\t  ret = c_parser_omp_simd (loc, parser, p_name, mask, cclauses);\n+\t  ret = c_parser_omp_simd (loc, parser, p_name, mask, cclauses, if_p);\n \t  block = c_end_compound_stmt (loc, block, true);\n \t  if (ret == NULL_TREE)\n \t    return ret;\n@@ -15137,7 +15146,7 @@ c_parser_omp_for (location_t loc, c_parser *parser,\n     }\n \n   block = c_begin_compound_stmt (true);\n-  ret = c_parser_omp_for_loop (loc, parser, OMP_FOR, clauses, cclauses);\n+  ret = c_parser_omp_for_loop (loc, parser, OMP_FOR, clauses, cclauses, if_p);\n   block = c_end_compound_stmt (loc, block, true);\n   add_stmt (block);\n \n@@ -15152,10 +15161,11 @@ c_parser_omp_for (location_t loc, c_parser *parser,\n */\n \n static tree\n-c_parser_omp_master (location_t loc, c_parser *parser)\n+c_parser_omp_master (location_t loc, c_parser *parser, bool *if_p)\n {\n   c_parser_skip_to_pragma_eol (parser);\n-  return c_finish_omp_master (loc, c_parser_omp_structured_block (parser));\n+  return c_finish_omp_master (loc, c_parser_omp_structured_block (parser,\n+\t\t\t\t\t\t\t\t  if_p));\n }\n \n /* OpenMP 2.5:\n@@ -15176,7 +15186,8 @@ c_parser_omp_master (location_t loc, c_parser *parser)\n \t(OMP_CLAUSE_MASK_1 << PRAGMA_OMP_CLAUSE_DEPEND)\n \n static bool\n-c_parser_omp_ordered (c_parser *parser, enum pragma_context context)\n+c_parser_omp_ordered (c_parser *parser, enum pragma_context context,\n+\t\t      bool *if_p)\n {\n   location_t loc = c_parser_peek_token (parser)->location;\n   c_parser_consume_pragma (parser);\n@@ -15215,7 +15226,7 @@ c_parser_omp_ordered (c_parser *parser, enum pragma_context context)\n   tree clauses = c_parser_omp_all_clauses (parser, OMP_ORDERED_CLAUSE_MASK,\n \t\t\t\t\t   \"#pragma omp ordered\");\n   c_finish_omp_ordered (loc, clauses,\n-\t\t\tc_parser_omp_structured_block (parser));\n+\t\t\tc_parser_omp_structured_block (parser, if_p));\n   return true;\n }\n \n@@ -15249,7 +15260,7 @@ c_parser_omp_sections_scope (location_t sections_loc, c_parser *parser)\n \n   if (c_parser_peek_token (parser)->pragma_kind != PRAGMA_OMP_SECTION)\n     {\n-      substmt = c_parser_omp_structured_block (parser);\n+      substmt = c_parser_omp_structured_block (parser, NULL);\n       substmt = build1 (OMP_SECTION, void_type_node, substmt);\n       SET_EXPR_LOCATION (substmt, loc);\n       add_stmt (substmt);\n@@ -15275,7 +15286,7 @@ c_parser_omp_sections_scope (location_t sections_loc, c_parser *parser)\n \t  error_suppress = true;\n \t}\n \n-      substmt = c_parser_omp_structured_block (parser);\n+      substmt = c_parser_omp_structured_block (parser, NULL);\n       substmt = build1 (OMP_SECTION, void_type_node, substmt);\n       SET_EXPR_LOCATION (substmt, loc);\n       add_stmt (substmt);\n@@ -15363,7 +15374,8 @@ c_parser_omp_sections (location_t loc, c_parser *parser,\n \n static tree\n c_parser_omp_parallel (location_t loc, c_parser *parser,\n-\t\t       char *p_name, omp_clause_mask mask, tree *cclauses)\n+\t\t       char *p_name, omp_clause_mask mask, tree *cclauses,\n+\t\t       bool *if_p)\n {\n   tree stmt, clauses, block;\n \n@@ -15382,9 +15394,9 @@ c_parser_omp_parallel (location_t loc, c_parser *parser,\n \n       c_parser_consume_token (parser);\n       if (!flag_openmp)  /* flag_openmp_simd  */\n-\treturn c_parser_omp_for (loc, parser, p_name, mask, cclauses);\n+\treturn c_parser_omp_for (loc, parser, p_name, mask, cclauses, if_p);\n       block = c_begin_omp_parallel ();\n-      tree ret = c_parser_omp_for (loc, parser, p_name, mask, cclauses);\n+      tree ret = c_parser_omp_for (loc, parser, p_name, mask, cclauses, if_p);\n       stmt\n \t= c_finish_omp_parallel (loc, cclauses[C_OMP_CLAUSE_SPLIT_PARALLEL],\n \t\t\t\t block);\n@@ -15436,7 +15448,7 @@ c_parser_omp_parallel (location_t loc, c_parser *parser,\n     }\n \n   block = c_begin_omp_parallel ();\n-  c_parser_statement (parser, NULL);\n+  c_parser_statement (parser, if_p);\n   stmt = c_finish_omp_parallel (loc, clauses, block);\n \n   return stmt;\n@@ -15456,7 +15468,7 @@ c_parser_omp_parallel (location_t loc, c_parser *parser,\n \t| (OMP_CLAUSE_MASK_1 << PRAGMA_OMP_CLAUSE_NOWAIT))\n \n static tree\n-c_parser_omp_single (location_t loc, c_parser *parser)\n+c_parser_omp_single (location_t loc, c_parser *parser, bool *if_p)\n {\n   tree stmt = make_node (OMP_SINGLE);\n   SET_EXPR_LOCATION (stmt, loc);\n@@ -15465,7 +15477,7 @@ c_parser_omp_single (location_t loc, c_parser *parser)\n   OMP_SINGLE_CLAUSES (stmt)\n     = c_parser_omp_all_clauses (parser, OMP_SINGLE_CLAUSE_MASK,\n \t\t\t\t\"#pragma omp single\");\n-  OMP_SINGLE_BODY (stmt) = c_parser_omp_structured_block (parser);\n+  OMP_SINGLE_BODY (stmt) = c_parser_omp_structured_block (parser, if_p);\n \n   return add_stmt (stmt);\n }\n@@ -15489,15 +15501,15 @@ c_parser_omp_single (location_t loc, c_parser *parser)\n \t| (OMP_CLAUSE_MASK_1 << PRAGMA_OMP_CLAUSE_PRIORITY))\n \n static tree\n-c_parser_omp_task (location_t loc, c_parser *parser)\n+c_parser_omp_task (location_t loc, c_parser *parser, bool *if_p)\n {\n   tree clauses, block;\n \n   clauses = c_parser_omp_all_clauses (parser, OMP_TASK_CLAUSE_MASK,\n \t\t\t\t      \"#pragma omp task\");\n \n   block = c_begin_omp_task ();\n-  c_parser_statement (parser, NULL);\n+  c_parser_statement (parser, if_p);\n   return c_finish_omp_task (loc, clauses, block);\n }\n \n@@ -15534,11 +15546,12 @@ c_parser_omp_taskyield (c_parser *parser)\n */\n \n static tree\n-c_parser_omp_taskgroup (c_parser *parser)\n+c_parser_omp_taskgroup (c_parser *parser, bool *if_p)\n {\n   location_t loc = c_parser_peek_token (parser)->location;\n   c_parser_skip_to_pragma_eol (parser);\n-  return c_finish_omp_taskgroup (loc, c_parser_omp_structured_block (parser));\n+  return c_finish_omp_taskgroup (loc, c_parser_omp_structured_block (parser,\n+\t\t\t\t\t\t\t\t     if_p));\n }\n \n /* OpenMP 4.0:\n@@ -15622,7 +15635,8 @@ c_parser_omp_cancellation_point (c_parser *parser)\n \n static tree\n c_parser_omp_distribute (location_t loc, c_parser *parser,\n-\t\t\t char *p_name, omp_clause_mask mask, tree *cclauses)\n+\t\t\t char *p_name, omp_clause_mask mask, tree *cclauses,\n+\t\t\t bool *if_p)\n {\n   tree clauses, block, ret;\n \n@@ -15648,16 +15662,19 @@ c_parser_omp_distribute (location_t loc, c_parser *parser,\n \t  if (!flag_openmp)  /* flag_openmp_simd  */\n \t    {\n \t      if (simd)\n-\t\treturn c_parser_omp_simd (loc, parser, p_name, mask, cclauses);\n+\t\treturn c_parser_omp_simd (loc, parser, p_name, mask, cclauses,\n+\t\t\t\t\t  if_p);\n \t      else\n \t\treturn c_parser_omp_parallel (loc, parser, p_name, mask,\n-\t\t\t\t\t      cclauses);\n+\t\t\t\t\t      cclauses, if_p);\n \t    }\n \t  block = c_begin_compound_stmt (true);\n \t  if (simd)\n-\t    ret = c_parser_omp_simd (loc, parser, p_name, mask, cclauses);\n+\t    ret = c_parser_omp_simd (loc, parser, p_name, mask, cclauses,\n+\t\t\t\t     if_p);\n \t  else\n-\t    ret = c_parser_omp_parallel (loc, parser, p_name, mask, cclauses);\n+\t    ret = c_parser_omp_parallel (loc, parser, p_name, mask, cclauses,\n+\t\t\t\t\t if_p);\n \t  block = c_end_compound_stmt (loc, block, true);\n \t  if (ret == NULL)\n \t    return ret;\n@@ -15684,7 +15701,8 @@ c_parser_omp_distribute (location_t loc, c_parser *parser,\n     }\n \n   block = c_begin_compound_stmt (true);\n-  ret = c_parser_omp_for_loop (loc, parser, OMP_DISTRIBUTE, clauses, NULL);\n+  ret = c_parser_omp_for_loop (loc, parser, OMP_DISTRIBUTE, clauses, NULL,\n+\t\t\t       if_p);\n   block = c_end_compound_stmt (loc, block, true);\n   add_stmt (block);\n \n@@ -15706,7 +15724,8 @@ c_parser_omp_distribute (location_t loc, c_parser *parser,\n \n static tree\n c_parser_omp_teams (location_t loc, c_parser *parser,\n-\t\t    char *p_name, omp_clause_mask mask, tree *cclauses)\n+\t\t    char *p_name, omp_clause_mask mask, tree *cclauses,\n+\t\t    bool *if_p)\n {\n   tree clauses, block, ret;\n \n@@ -15724,9 +15743,11 @@ c_parser_omp_teams (location_t loc, c_parser *parser,\n \n \t  c_parser_consume_token (parser);\n \t  if (!flag_openmp)  /* flag_openmp_simd  */\n-\t    return c_parser_omp_distribute (loc, parser, p_name, mask, cclauses);\n+\t    return c_parser_omp_distribute (loc, parser, p_name, mask,\n+\t\t\t\t\t    cclauses, if_p);\n \t  block = c_begin_compound_stmt (true);\n-\t  ret = c_parser_omp_distribute (loc, parser, p_name, mask, cclauses);\n+\t  ret = c_parser_omp_distribute (loc, parser, p_name, mask, cclauses,\n+\t\t\t\t\t if_p);\n \t  block = c_end_compound_stmt (loc, block, true);\n \t  if (ret == NULL)\n \t    return ret;\n@@ -15755,7 +15776,7 @@ c_parser_omp_teams (location_t loc, c_parser *parser,\n   tree stmt = make_node (OMP_TEAMS);\n   TREE_TYPE (stmt) = void_type_node;\n   OMP_TEAMS_CLAUSES (stmt) = clauses;\n-  OMP_TEAMS_BODY (stmt) = c_parser_omp_structured_block (parser);\n+  OMP_TEAMS_BODY (stmt) = c_parser_omp_structured_block (parser, if_p);\n \n   return add_stmt (stmt);\n }\n@@ -15771,7 +15792,7 @@ c_parser_omp_teams (location_t loc, c_parser *parser,\n \t| (OMP_CLAUSE_MASK_1 << PRAGMA_OMP_CLAUSE_USE_DEVICE_PTR))\n \n static tree\n-c_parser_omp_target_data (location_t loc, c_parser *parser)\n+c_parser_omp_target_data (location_t loc, c_parser *parser, bool *if_p)\n {\n   tree clauses\n     = c_parser_omp_all_clauses (parser, OMP_TARGET_DATA_CLAUSE_MASK,\n@@ -15820,7 +15841,7 @@ c_parser_omp_target_data (location_t loc, c_parser *parser)\n   OMP_TARGET_DATA_CLAUSES (stmt) = clauses;\n   keep_next_level ();\n   tree block = c_begin_compound_stmt (true);\n-  add_stmt (c_parser_omp_structured_block (parser));\n+  add_stmt (c_parser_omp_structured_block (parser, if_p));\n   OMP_TARGET_DATA_BODY (stmt) = c_end_compound_stmt (loc, block, true);\n \n   SET_EXPR_LOCATION (stmt, loc);\n@@ -16060,7 +16081,7 @@ c_parser_omp_target_exit_data (location_t loc, c_parser *parser,\n \t| (OMP_CLAUSE_MASK_1 << PRAGMA_OMP_CLAUSE_IS_DEVICE_PTR))\n \n static bool\n-c_parser_omp_target (c_parser *parser, enum pragma_context context)\n+c_parser_omp_target (c_parser *parser, enum pragma_context context, bool *if_p)\n {\n   location_t loc = c_parser_peek_token (parser)->location;\n   c_parser_consume_pragma (parser);\n@@ -16100,17 +16121,17 @@ c_parser_omp_target (c_parser *parser, enum pragma_context context)\n \t\tcase OMP_TEAMS:\n \t\t  stmt = c_parser_omp_teams (loc, parser, p_name,\n \t\t\t\t\t     OMP_TARGET_CLAUSE_MASK,\n-\t\t\t\t\t     cclauses);\n+\t\t\t\t\t     cclauses, if_p);\n \t\t  break;\n \t\tcase OMP_PARALLEL:\n \t\t  stmt = c_parser_omp_parallel (loc, parser, p_name,\n \t\t\t\t\t\tOMP_TARGET_CLAUSE_MASK,\n-\t\t\t\t\t\tcclauses);\n+\t\t\t\t\t\tcclauses, if_p);\n \t\t  break;\n \t\tcase OMP_SIMD:\n \t\t  stmt = c_parser_omp_simd (loc, parser, p_name,\n \t\t\t\t\t    OMP_TARGET_CLAUSE_MASK,\n-\t\t\t\t\t    cclauses);\n+\t\t\t\t\t    cclauses, if_p);\n \t\t  break;\n \t\tdefault:\n \t\t  gcc_unreachable ();\n@@ -16123,15 +16144,18 @@ c_parser_omp_target (c_parser *parser, enum pragma_context context)\n \t    {\n \t    case OMP_TEAMS:\n \t      ret = c_parser_omp_teams (loc, parser, p_name,\n-\t\t\t\t\tOMP_TARGET_CLAUSE_MASK, cclauses);\n+\t\t\t\t\tOMP_TARGET_CLAUSE_MASK, cclauses,\n+\t\t\t\t\tif_p);\n \t      break;\n \t    case OMP_PARALLEL:\n \t      ret = c_parser_omp_parallel (loc, parser, p_name,\n-\t\t\t\t\t   OMP_TARGET_CLAUSE_MASK, cclauses);\n+\t\t\t\t\t   OMP_TARGET_CLAUSE_MASK, cclauses,\n+\t\t\t\t\t   if_p);\n \t      break;\n \t    case OMP_SIMD:\n \t      ret = c_parser_omp_simd (loc, parser, p_name,\n-\t\t\t\t       OMP_TARGET_CLAUSE_MASK, cclauses);\n+\t\t\t\t       OMP_TARGET_CLAUSE_MASK, cclauses,\n+\t\t\t\t       if_p);\n \t      break;\n \t    default:\n \t      gcc_unreachable ();\n@@ -16182,7 +16206,7 @@ c_parser_omp_target (c_parser *parser, enum pragma_context context)\n       else if (strcmp (p, \"data\") == 0)\n \t{\n \t  c_parser_consume_token (parser);\n-\t  c_parser_omp_target_data (loc, parser);\n+\t  c_parser_omp_target_data (loc, parser, if_p);\n \t  return true;\n \t}\n       else if (strcmp (p, \"enter\") == 0)\n@@ -16213,7 +16237,7 @@ c_parser_omp_target (c_parser *parser, enum pragma_context context)\n   pc = &OMP_TARGET_CLAUSES (stmt);\n   keep_next_level ();\n   block = c_begin_compound_stmt (true);\n-  add_stmt (c_parser_omp_structured_block (parser));\n+  add_stmt (c_parser_omp_structured_block (parser, if_p));\n   OMP_TARGET_BODY (stmt) = c_end_compound_stmt (loc, block, true);\n \n   SET_EXPR_LOCATION (stmt, loc);\n@@ -17022,7 +17046,8 @@ c_parser_omp_declare (c_parser *parser, enum pragma_context context)\n \n static tree\n c_parser_omp_taskloop (location_t loc, c_parser *parser,\n-\t\t       char *p_name, omp_clause_mask mask, tree *cclauses)\n+\t\t       char *p_name, omp_clause_mask mask, tree *cclauses,\n+\t\t       bool *if_p)\n {\n   tree clauses, block, ret;\n \n@@ -17041,9 +17066,10 @@ c_parser_omp_taskloop (location_t loc, c_parser *parser,\n \t  mask &= ~(OMP_CLAUSE_MASK_1 << PRAGMA_OMP_CLAUSE_REDUCTION);\n \t  c_parser_consume_token (parser);\n \t  if (!flag_openmp)  /* flag_openmp_simd  */\n-\t    return c_parser_omp_simd (loc, parser, p_name, mask, cclauses);\n+\t    return c_parser_omp_simd (loc, parser, p_name, mask, cclauses,\n+\t\t\t\t      if_p);\n \t  block = c_begin_compound_stmt (true);\n-\t  ret = c_parser_omp_simd (loc, parser, p_name, mask, cclauses);\n+\t  ret = c_parser_omp_simd (loc, parser, p_name, mask, cclauses, if_p);\n \t  block = c_end_compound_stmt (loc, block, true);\n \t  if (ret == NULL)\n \t    return ret;\n@@ -17070,7 +17096,7 @@ c_parser_omp_taskloop (location_t loc, c_parser *parser,\n     }\n \n   block = c_begin_compound_stmt (true);\n-  ret = c_parser_omp_for_loop (loc, parser, OMP_TASKLOOP, clauses, NULL);\n+  ret = c_parser_omp_for_loop (loc, parser, OMP_TASKLOOP, clauses, NULL, if_p);\n   block = c_end_compound_stmt (loc, block, true);\n   add_stmt (block);\n \n@@ -17080,7 +17106,7 @@ c_parser_omp_taskloop (location_t loc, c_parser *parser,\n /* Main entry point to parsing most OpenMP pragmas.  */\n \n static void\n-c_parser_omp_construct (c_parser *parser)\n+c_parser_omp_construct (c_parser *parser, bool *if_p)\n {\n   enum pragma_kind p_kind;\n   location_t loc;\n@@ -17102,19 +17128,20 @@ c_parser_omp_construct (c_parser *parser)\n       stmt = c_parser_oacc_cache (loc, parser);\n       break;\n     case PRAGMA_OACC_DATA:\n-      stmt = c_parser_oacc_data (loc, parser);\n+      stmt = c_parser_oacc_data (loc, parser, if_p);\n       break;\n     case PRAGMA_OACC_HOST_DATA:\n-      stmt = c_parser_oacc_host_data (loc, parser);\n+      stmt = c_parser_oacc_host_data (loc, parser, if_p);\n       break;\n     case PRAGMA_OACC_KERNELS:\n     case PRAGMA_OACC_PARALLEL:\n       strcpy (p_name, \"#pragma acc\");\n-      stmt = c_parser_oacc_kernels_parallel (loc, parser, p_kind, p_name);\n+      stmt = c_parser_oacc_kernels_parallel (loc, parser, p_kind, p_name,\n+\t\t\t\t\t     if_p);\n       break;\n     case PRAGMA_OACC_LOOP:\n       strcpy (p_name, \"#pragma acc\");\n-      stmt = c_parser_oacc_loop (loc, parser, p_name, mask, NULL);\n+      stmt = c_parser_oacc_loop (loc, parser, p_name, mask, NULL, if_p);\n       break;\n     case PRAGMA_OACC_WAIT:\n       strcpy (p_name, \"#pragma wait\");\n@@ -17124,47 +17151,47 @@ c_parser_omp_construct (c_parser *parser)\n       c_parser_omp_atomic (loc, parser);\n       return;\n     case PRAGMA_OMP_CRITICAL:\n-      stmt = c_parser_omp_critical (loc, parser);\n+      stmt = c_parser_omp_critical (loc, parser, if_p);\n       break;\n     case PRAGMA_OMP_DISTRIBUTE:\n       strcpy (p_name, \"#pragma omp\");\n-      stmt = c_parser_omp_distribute (loc, parser, p_name, mask, NULL);\n+      stmt = c_parser_omp_distribute (loc, parser, p_name, mask, NULL, if_p);\n       break;\n     case PRAGMA_OMP_FOR:\n       strcpy (p_name, \"#pragma omp\");\n-      stmt = c_parser_omp_for (loc, parser, p_name, mask, NULL);\n+      stmt = c_parser_omp_for (loc, parser, p_name, mask, NULL, if_p);\n       break;\n     case PRAGMA_OMP_MASTER:\n-      stmt = c_parser_omp_master (loc, parser);\n+      stmt = c_parser_omp_master (loc, parser, if_p);\n       break;\n     case PRAGMA_OMP_PARALLEL:\n       strcpy (p_name, \"#pragma omp\");\n-      stmt = c_parser_omp_parallel (loc, parser, p_name, mask, NULL);\n+      stmt = c_parser_omp_parallel (loc, parser, p_name, mask, NULL, if_p);\n       break;\n     case PRAGMA_OMP_SECTIONS:\n       strcpy (p_name, \"#pragma omp\");\n       stmt = c_parser_omp_sections (loc, parser, p_name, mask, NULL);\n       break;\n     case PRAGMA_OMP_SIMD:\n       strcpy (p_name, \"#pragma omp\");\n-      stmt = c_parser_omp_simd (loc, parser, p_name, mask, NULL);\n+      stmt = c_parser_omp_simd (loc, parser, p_name, mask, NULL, if_p);\n       break;\n     case PRAGMA_OMP_SINGLE:\n-      stmt = c_parser_omp_single (loc, parser);\n+      stmt = c_parser_omp_single (loc, parser, if_p);\n       break;\n     case PRAGMA_OMP_TASK:\n-      stmt = c_parser_omp_task (loc, parser);\n+      stmt = c_parser_omp_task (loc, parser, if_p);\n       break;\n     case PRAGMA_OMP_TASKGROUP:\n-      stmt = c_parser_omp_taskgroup (parser);\n+      stmt = c_parser_omp_taskgroup (parser, if_p);\n       break;\n     case PRAGMA_OMP_TASKLOOP:\n       strcpy (p_name, \"#pragma omp\");\n-      stmt = c_parser_omp_taskloop (loc, parser, p_name, mask, NULL);\n+      stmt = c_parser_omp_taskloop (loc, parser, p_name, mask, NULL, if_p);\n       break;\n     case PRAGMA_OMP_TEAMS:\n       strcpy (p_name, \"#pragma omp\");\n-      stmt = c_parser_omp_teams (loc, parser, p_name, mask, NULL);\n+      stmt = c_parser_omp_teams (loc, parser, p_name, mask, NULL, if_p);\n       break;\n     default:\n       gcc_unreachable ();\n@@ -17491,7 +17518,7 @@ c_parser_cilk_all_clauses (c_parser *parser)\n  */\n \n static void\n-c_parser_cilk_grainsize (c_parser *parser)\n+c_parser_cilk_grainsize (c_parser *parser, bool *if_p)\n {\n   extern tree convert_to_integer (tree, tree);\n \n@@ -17516,7 +17543,7 @@ c_parser_cilk_grainsize (c_parser *parser)\n \t{\n \t  if (grain == NULL_TREE || grain == error_mark_node)\n \t    grain = integer_zero_node;\n-\t  c_parser_cilk_for (parser, grain);\n+\t  c_parser_cilk_for (parser, grain, if_p);\n \t}\n       else\n \twarning (0, \"%<#pragma cilk grainsize%> is not followed by \"\n@@ -17529,12 +17556,12 @@ c_parser_cilk_grainsize (c_parser *parser)\n /* Main entry point for parsing Cilk Plus <#pragma simd> for loops.  */\n \n static void\n-c_parser_cilk_simd (c_parser *parser)\n+c_parser_cilk_simd (c_parser *parser, bool *if_p)\n {\n   tree clauses = c_parser_cilk_all_clauses (parser);\n   tree block = c_begin_compound_stmt (true);\n   location_t loc = c_parser_peek_token (parser)->location;\n-  c_parser_omp_for_loop (loc, parser, CILK_SIMD, clauses, NULL);\n+  c_parser_omp_for_loop (loc, parser, CILK_SIMD, clauses, NULL, if_p);\n   block = c_end_compound_stmt (loc, block, true);\n   add_stmt (block);\n }\n@@ -17559,7 +17586,7 @@ c_get_temp_regvar (tree type, tree init)\n   GRAIN is the grain value passed in through pragma or 0.  */\n \n static void\n-c_parser_cilk_for (c_parser *parser, tree grain)\n+c_parser_cilk_for (c_parser *parser, tree grain, bool *if_p)\n {\n   tree clauses = build_omp_clause (EXPR_LOCATION (grain), OMP_CLAUSE_SCHEDULE);\n   OMP_CLAUSE_SCHEDULE_KIND (clauses) = OMP_CLAUSE_SCHEDULE_CILKFOR;\n@@ -17569,7 +17596,8 @@ c_parser_cilk_for (c_parser *parser, tree grain)\n   tree block = c_begin_compound_stmt (true);\n   tree sb = push_stmt_list ();\n   location_t loc = c_parser_peek_token (parser)->location;\n-  tree omp_for = c_parser_omp_for_loop (loc, parser, CILK_FOR, clauses, NULL);\n+  tree omp_for = c_parser_omp_for_loop (loc, parser, CILK_FOR, clauses, NULL,\n+\t\t\t\t\tif_p);\n   sb = pop_stmt_list (sb);\n \n   if (omp_for)"}, {"sha": "d89b73b4e76ed4d78671d20cae8bec2d729c6757", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dda1bf6123a4e69cb9aa5072442b803f82da2be3/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dda1bf6123a4e69cb9aa5072442b803f82da2be3/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=dda1bf6123a4e69cb9aa5072442b803f82da2be3", "patch": "@@ -1,3 +1,27 @@\n+2016-04-15  Jakub Jelinek  <jakub@redhat.com>\n+\n+\tPR c/70436\n+\t* parser.c (cp_parser_pragma): Add IF_P argument, pass it down\n+\twhere needed.\n+\t(cp_parser_declaration_seq_opt, cp_parser_member_specification_opt,\n+\tcp_parser_objc_interstitial_code, cp_parser_omp_declare_simd,\n+\tcp_parser_oacc_routine): Adjust cp_parser_pragma callers.\n+\t(cp_parser_statement): Likewise.  Adjust cp_parser_cilk_for caller.\n+\t(cp_parser_omp_structured_block): Add IF_P argument, pass it down to\n+\tcp_parser_statement.\n+\t(cp_parser_oacc_data, cp_parser_oacc_host_data, cp_parser_oacc_loop,\n+\tcp_parser_oacc_kernels_parallel, cp_parser_omp_critical,\n+\tcp_parser_omp_simd, cp_parser_omp_for, cp_parser_omp_master,\n+\tcp_parser_omp_ordered, cp_parser_omp_parallel, cp_parser_omp_single,\n+\tcp_parser_omp_task, cp_parser_omp_taskgroup, cp_parser_omp_distribute,\n+\tcp_parser_omp_teams, cp_parser_omp_target_data, cp_parser_omp_target,\n+\tcp_parser_omp_taskloop, cp_parser_omp_construct,\n+\tcp_parser_cilk_grainsize, cp_parser_cilk_simd, cp_parser_cilk_for):\n+\tAdd IF_P argument, pass it down where needed.\n+\t(cp_parser_omp_for_loop): Likewise.  Clear IF_P if nbraces.\n+\t(cp_parser_omp_sections_scope): Adjust cp_parser_omp_structured_block\n+\tcalls.\n+\n 2016-04-14  Jason Merrill  <jason@redhat.com>\n \n \tPR c++/70494"}, {"sha": "54861298c84a0240aa1e3d8e4b5ae9edb8e7ed87", "filename": "gcc/cp/parser.c", "status": "modified", "additions": 127, "deletions": 102, "changes": 229, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dda1bf6123a4e69cb9aa5072442b803f82da2be3/gcc%2Fcp%2Fparser.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dda1bf6123a4e69cb9aa5072442b803f82da2be3/gcc%2Fcp%2Fparser.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparser.c?ref=dda1bf6123a4e69cb9aa5072442b803f82da2be3", "patch": "@@ -249,9 +249,9 @@ static tree cp_literal_operator_id\n   (const char *);\n \n static void cp_parser_cilk_simd\n-  (cp_parser *, cp_token *);\n+  (cp_parser *, cp_token *, bool *);\n static tree cp_parser_cilk_for\n-  (cp_parser *, tree);\n+  (cp_parser *, tree, bool *);\n static bool cp_parser_omp_declare_reduction_exprs\n   (tree, cp_parser *);\n static tree cp_parser_cilk_simd_vectorlength \n@@ -2434,7 +2434,7 @@ enum pragma_context {\n   pragma_compound\n };\n static bool cp_parser_pragma\n-  (cp_parser *, enum pragma_context);\n+  (cp_parser *, enum pragma_context, bool *);\n \n /* Objective-C++ Productions */\n \n@@ -10404,7 +10404,7 @@ cp_parser_statement (cp_parser* parser, tree in_statement_expr,\n \t      statement = error_mark_node;\n \t    }\n \t  else\n-\t    statement = cp_parser_cilk_for (parser, integer_zero_node);\n+\t    statement = cp_parser_cilk_for (parser, integer_zero_node, if_p);\n \t  break;\n \n \tcase RID_BREAK:\n@@ -10496,8 +10496,8 @@ cp_parser_statement (cp_parser* parser, tree in_statement_expr,\n \t return so that we can check for a close brace.  Otherwise we\n \t require a real statement and must go back and read one.  */\n       if (in_compound)\n-\tcp_parser_pragma (parser, pragma_compound);\n-      else if (!cp_parser_pragma (parser, pragma_stmt))\n+\tcp_parser_pragma (parser, pragma_compound, if_p);\n+      else if (!cp_parser_pragma (parser, pragma_stmt, if_p))\n \tgoto restart;\n       return;\n     }\n@@ -12016,7 +12016,7 @@ cp_parser_declaration_seq_opt (cp_parser* parser)\n \t     A nested declaration cannot, so this is done here and not\n \t     in cp_parser_declaration.  (A #pragma at block scope is\n \t     handled in cp_parser_statement.)  */\n-\t  cp_parser_pragma (parser, pragma_external);\n+\t  cp_parser_pragma (parser, pragma_external, NULL);\n \t  continue;\n \t}\n \n@@ -22145,7 +22145,7 @@ cp_parser_member_specification_opt (cp_parser* parser)\n \t  /* Accept #pragmas at class scope.  */\n \t  if (token->type == CPP_PRAGMA)\n \t    {\n-\t      cp_parser_pragma (parser, pragma_member);\n+\t      cp_parser_pragma (parser, pragma_member, NULL);\n \t      break;\n \t    }\n \n@@ -28481,7 +28481,7 @@ cp_parser_objc_interstitial_code (cp_parser* parser)\n     cp_parser_linkage_specification (parser);\n   /* Handle #pragma, if any.  */\n   else if (token->type == CPP_PRAGMA)\n-    cp_parser_pragma (parser, pragma_objc_icode);\n+    cp_parser_pragma (parser, pragma_objc_icode, NULL);\n   /* Allow stray semicolons.  */\n   else if (token->type == CPP_SEMICOLON)\n     cp_lexer_consume_token (parser->lexer);\n@@ -32609,12 +32609,12 @@ cp_parser_end_omp_structured_block (cp_parser *parser, unsigned save)\n }\n \n static tree\n-cp_parser_omp_structured_block (cp_parser *parser)\n+cp_parser_omp_structured_block (cp_parser *parser, bool *if_p)\n {\n   tree stmt = begin_omp_structured_block ();\n   unsigned int save = cp_parser_begin_omp_structured_block (parser);\n \n-  cp_parser_statement (parser, NULL_TREE, false, NULL);\n+  cp_parser_statement (parser, NULL_TREE, false, if_p);\n \n   cp_parser_end_omp_structured_block (parser, save);\n   return finish_omp_structured_block (stmt);\n@@ -33074,7 +33074,7 @@ cp_parser_omp_barrier (cp_parser *parser, cp_token *pragma_tok)\n \t( (OMP_CLAUSE_MASK_1 << PRAGMA_OMP_CLAUSE_HINT) )\n \n static tree\n-cp_parser_omp_critical (cp_parser *parser, cp_token *pragma_tok)\n+cp_parser_omp_critical (cp_parser *parser, cp_token *pragma_tok, bool *if_p)\n {\n   tree stmt, name = NULL_TREE, clauses = NULL_TREE;\n \n@@ -33099,7 +33099,7 @@ cp_parser_omp_critical (cp_parser *parser, cp_token *pragma_tok)\n   else\n     cp_parser_require_pragma_eol (parser, pragma_tok);\n \n-  stmt = cp_parser_omp_structured_block (parser);\n+  stmt = cp_parser_omp_structured_block (parser, if_p);\n   return c_finish_omp_critical (input_location, stmt, name, clauses);\n }\n \n@@ -33475,7 +33475,7 @@ cp_parser_omp_for_loop_init (cp_parser *parser,\n \n static tree\n cp_parser_omp_for_loop (cp_parser *parser, enum tree_code code, tree clauses,\n-\t\t\ttree *cclauses)\n+\t\t\ttree *cclauses, bool *if_p)\n {\n   tree init, orig_init, cond, incr, body, decl, pre_body = NULL_TREE, ret;\n   tree real_decl, initv, condv, incrv, declv;\n@@ -33734,6 +33734,9 @@ cp_parser_omp_for_loop (cp_parser *parser, enum tree_code code, tree clauses,\n \t}\n     }\n \n+  if (nbraces)\n+    if_p = NULL;\n+\n   /* Note that we saved the original contents of this flag when we entered\n      the structured block, and so we don't need to re-save it here.  */\n   if (code == CILK_SIMD || code == CILK_FOR)\n@@ -33744,7 +33747,7 @@ cp_parser_omp_for_loop (cp_parser *parser, enum tree_code code, tree clauses,\n   /* Note that the grammar doesn't call for a structured block here,\n      though the loop as a whole is a structured block.  */\n   body = push_stmt_list ();\n-  cp_parser_statement (parser, NULL_TREE, false, NULL);\n+  cp_parser_statement (parser, NULL_TREE, false, if_p);\n   body = pop_stmt_list (body);\n \n   if (declv == NULL_TREE)\n@@ -33813,7 +33816,8 @@ cp_omp_split_clauses (location_t loc, enum tree_code code,\n \n static tree\n cp_parser_omp_simd (cp_parser *parser, cp_token *pragma_tok,\n-\t\t    char *p_name, omp_clause_mask mask, tree *cclauses)\n+\t\t    char *p_name, omp_clause_mask mask, tree *cclauses,\n+\t\t    bool *if_p)\n {\n   tree clauses, sb, ret;\n   unsigned int save;\n@@ -33842,7 +33846,7 @@ cp_parser_omp_simd (cp_parser *parser, cp_token *pragma_tok,\n   sb = begin_omp_structured_block ();\n   save = cp_parser_begin_omp_structured_block (parser);\n \n-  ret = cp_parser_omp_for_loop (parser, OMP_SIMD, clauses, cclauses);\n+  ret = cp_parser_omp_for_loop (parser, OMP_SIMD, clauses, cclauses, if_p);\n \n   cp_parser_end_omp_structured_block (parser, save);\n   add_stmt (finish_omp_structured_block (sb));\n@@ -33871,7 +33875,8 @@ cp_parser_omp_simd (cp_parser *parser, cp_token *pragma_tok,\n \n static tree\n cp_parser_omp_for (cp_parser *parser, cp_token *pragma_tok,\n-\t\t   char *p_name, omp_clause_mask mask, tree *cclauses)\n+\t\t   char *p_name, omp_clause_mask mask, tree *cclauses,\n+\t\t   bool *if_p)\n {\n   tree clauses, sb, ret;\n   unsigned int save;\n@@ -33899,11 +33904,11 @@ cp_parser_omp_for (cp_parser *parser, cp_token *pragma_tok,\n \t  cp_lexer_consume_token (parser->lexer);\n \t  if (!flag_openmp)  /* flag_openmp_simd  */\n \t    return cp_parser_omp_simd (parser, pragma_tok, p_name, mask,\n-\t\t\t\t       cclauses);\n+\t\t\t\t       cclauses, if_p);\n \t  sb = begin_omp_structured_block ();\n \t  save = cp_parser_begin_omp_structured_block (parser);\n \t  ret = cp_parser_omp_simd (parser, pragma_tok, p_name, mask,\n-\t\t\t\t    cclauses);\n+\t\t\t\t    cclauses, if_p);\n \t  cp_parser_end_omp_structured_block (parser, save);\n \t  tree body = finish_omp_structured_block (sb);\n \t  if (ret == NULL)\n@@ -33938,7 +33943,7 @@ cp_parser_omp_for (cp_parser *parser, cp_token *pragma_tok,\n   sb = begin_omp_structured_block ();\n   save = cp_parser_begin_omp_structured_block (parser);\n \n-  ret = cp_parser_omp_for_loop (parser, OMP_FOR, clauses, cclauses);\n+  ret = cp_parser_omp_for_loop (parser, OMP_FOR, clauses, cclauses, if_p);\n \n   cp_parser_end_omp_structured_block (parser, save);\n   add_stmt (finish_omp_structured_block (sb));\n@@ -33951,11 +33956,11 @@ cp_parser_omp_for (cp_parser *parser, cp_token *pragma_tok,\n      structured-block  */\n \n static tree\n-cp_parser_omp_master (cp_parser *parser, cp_token *pragma_tok)\n+cp_parser_omp_master (cp_parser *parser, cp_token *pragma_tok, bool *if_p)\n {\n   cp_parser_require_pragma_eol (parser, pragma_tok);\n   return c_finish_omp_master (input_location,\n-\t\t\t      cp_parser_omp_structured_block (parser));\n+\t\t\t      cp_parser_omp_structured_block (parser, if_p));\n }\n \n /* OpenMP 2.5:\n@@ -33975,7 +33980,7 @@ cp_parser_omp_master (cp_parser *parser, cp_token *pragma_tok)\n \n static bool\n cp_parser_omp_ordered (cp_parser *parser, cp_token *pragma_tok,\n-\t\t       enum pragma_context context)\n+\t\t       enum pragma_context context, bool *if_p)\n {\n   location_t loc = pragma_tok->location;\n \n@@ -34014,7 +34019,7 @@ cp_parser_omp_ordered (cp_parser *parser, cp_token *pragma_tok,\n     = cp_parser_omp_all_clauses (parser, OMP_ORDERED_CLAUSE_MASK,\n \t\t\t\t \"#pragma omp ordered\", pragma_tok);\n   c_finish_omp_ordered (loc, clauses,\n-\t\t\tcp_parser_omp_structured_block (parser));\n+\t\t\tcp_parser_omp_structured_block (parser, if_p));\n   return true;\n }\n \n@@ -34042,7 +34047,7 @@ cp_parser_omp_sections_scope (cp_parser *parser)\n   if (cp_parser_pragma_kind (cp_lexer_peek_token (parser->lexer))\n       != PRAGMA_OMP_SECTION)\n     {\n-      substmt = cp_parser_omp_structured_block (parser);\n+      substmt = cp_parser_omp_structured_block (parser, NULL);\n       substmt = build1 (OMP_SECTION, void_type_node, substmt);\n       add_stmt (substmt);\n     }\n@@ -34067,7 +34072,7 @@ cp_parser_omp_sections_scope (cp_parser *parser)\n \t  error_suppress = true;\n \t}\n \n-      substmt = cp_parser_omp_structured_block (parser);\n+      substmt = cp_parser_omp_structured_block (parser, NULL);\n       substmt = build1 (OMP_SECTION, void_type_node, substmt);\n       add_stmt (substmt);\n     }\n@@ -34146,7 +34151,8 @@ cp_parser_omp_sections (cp_parser *parser, cp_token *pragma_tok,\n \n static tree\n cp_parser_omp_parallel (cp_parser *parser, cp_token *pragma_tok,\n-\t\t\tchar *p_name, omp_clause_mask mask, tree *cclauses)\n+\t\t\tchar *p_name, omp_clause_mask mask, tree *cclauses,\n+\t\t\tbool *if_p)\n {\n   tree stmt, clauses, block;\n   unsigned int save;\n@@ -34167,10 +34173,12 @@ cp_parser_omp_parallel (cp_parser *parser, cp_token *pragma_tok,\n \n       cp_lexer_consume_token (parser->lexer);\n       if (!flag_openmp)  /* flag_openmp_simd  */\n-\treturn cp_parser_omp_for (parser, pragma_tok, p_name, mask, cclauses);\n+\treturn cp_parser_omp_for (parser, pragma_tok, p_name, mask, cclauses,\n+\t\t\t\t  if_p);\n       block = begin_omp_parallel ();\n       save = cp_parser_begin_omp_structured_block (parser);\n-      tree ret = cp_parser_omp_for (parser, pragma_tok, p_name, mask, cclauses);\n+      tree ret = cp_parser_omp_for (parser, pragma_tok, p_name, mask, cclauses,\n+\t\t\t\t    if_p);\n       cp_parser_end_omp_structured_block (parser, save);\n       stmt = finish_omp_parallel (cclauses[C_OMP_CLAUSE_SPLIT_PARALLEL],\n \t\t\t\t  block);\n@@ -34224,7 +34232,7 @@ cp_parser_omp_parallel (cp_parser *parser, cp_token *pragma_tok,\n \n   block = begin_omp_parallel ();\n   save = cp_parser_begin_omp_structured_block (parser);\n-  cp_parser_statement (parser, NULL_TREE, false, NULL);\n+  cp_parser_statement (parser, NULL_TREE, false, if_p);\n   cp_parser_end_omp_structured_block (parser, save);\n   stmt = finish_omp_parallel (clauses, block);\n   return stmt;\n@@ -34241,15 +34249,15 @@ cp_parser_omp_parallel (cp_parser *parser, cp_token *pragma_tok,\n \t| (OMP_CLAUSE_MASK_1 << PRAGMA_OMP_CLAUSE_NOWAIT))\n \n static tree\n-cp_parser_omp_single (cp_parser *parser, cp_token *pragma_tok)\n+cp_parser_omp_single (cp_parser *parser, cp_token *pragma_tok, bool *if_p)\n {\n   tree stmt = make_node (OMP_SINGLE);\n   TREE_TYPE (stmt) = void_type_node;\n \n   OMP_SINGLE_CLAUSES (stmt)\n     = cp_parser_omp_all_clauses (parser, OMP_SINGLE_CLAUSE_MASK,\n \t\t\t\t \"#pragma omp single\", pragma_tok);\n-  OMP_SINGLE_BODY (stmt) = cp_parser_omp_structured_block (parser);\n+  OMP_SINGLE_BODY (stmt) = cp_parser_omp_structured_block (parser, if_p);\n \n   return add_stmt (stmt);\n }\n@@ -34271,7 +34279,7 @@ cp_parser_omp_single (cp_parser *parser, cp_token *pragma_tok)\n \t| (OMP_CLAUSE_MASK_1 << PRAGMA_OMP_CLAUSE_PRIORITY))\n \n static tree\n-cp_parser_omp_task (cp_parser *parser, cp_token *pragma_tok)\n+cp_parser_omp_task (cp_parser *parser, cp_token *pragma_tok, bool *if_p)\n {\n   tree clauses, block;\n   unsigned int save;\n@@ -34280,7 +34288,7 @@ cp_parser_omp_task (cp_parser *parser, cp_token *pragma_tok)\n \t\t\t\t       \"#pragma omp task\", pragma_tok);\n   block = begin_omp_task ();\n   save = cp_parser_begin_omp_structured_block (parser);\n-  cp_parser_statement (parser, NULL_TREE, false, NULL);\n+  cp_parser_statement (parser, NULL_TREE, false, if_p);\n   cp_parser_end_omp_structured_block (parser, save);\n   return finish_omp_task (clauses, block);\n }\n@@ -34310,11 +34318,12 @@ cp_parser_omp_taskyield (cp_parser *parser, cp_token *pragma_tok)\n      structured-block  */\n \n static tree\n-cp_parser_omp_taskgroup (cp_parser *parser, cp_token *pragma_tok)\n+cp_parser_omp_taskgroup (cp_parser *parser, cp_token *pragma_tok, bool *if_p)\n {\n   cp_parser_require_pragma_eol (parser, pragma_tok);\n   return c_finish_omp_taskgroup (input_location,\n-\t\t\t\t cp_parser_omp_structured_block (parser));\n+\t\t\t\t cp_parser_omp_structured_block (parser,\n+\t\t\t\t\t\t\t\t if_p));\n }\n \n \n@@ -34403,7 +34412,8 @@ cp_parser_omp_cancellation_point (cp_parser *parser, cp_token *pragma_tok)\n \n static tree\n cp_parser_omp_distribute (cp_parser *parser, cp_token *pragma_tok,\n-\t\t\t  char *p_name, omp_clause_mask mask, tree *cclauses)\n+\t\t\t  char *p_name, omp_clause_mask mask, tree *cclauses,\n+\t\t\t  bool *if_p)\n {\n   tree clauses, sb, ret;\n   unsigned int save;\n@@ -34433,19 +34443,19 @@ cp_parser_omp_distribute (cp_parser *parser, cp_token *pragma_tok,\n \t    {\n \t      if (simd)\n \t\treturn cp_parser_omp_simd (parser, pragma_tok, p_name, mask,\n-\t\t\t\t\t   cclauses);\n+\t\t\t\t\t   cclauses, if_p);\n \t      else\n \t\treturn cp_parser_omp_parallel (parser, pragma_tok, p_name, mask,\n-\t\t\t\t\t       cclauses);\n+\t\t\t\t\t       cclauses, if_p);\n \t    }\n \t  sb = begin_omp_structured_block ();\n \t  save = cp_parser_begin_omp_structured_block (parser);\n \t  if (simd)\n \t    ret = cp_parser_omp_simd (parser, pragma_tok, p_name, mask,\n-\t\t\t\t      cclauses);\n+\t\t\t\t      cclauses, if_p);\n \t  else\n \t    ret = cp_parser_omp_parallel (parser, pragma_tok, p_name, mask,\n-\t\t\t\t\t  cclauses);\n+\t\t\t\t\t  cclauses, if_p);\n \t  cp_parser_end_omp_structured_block (parser, save);\n \t  tree body = finish_omp_structured_block (sb);\n \t  if (ret == NULL)\n@@ -34476,7 +34486,7 @@ cp_parser_omp_distribute (cp_parser *parser, cp_token *pragma_tok,\n   sb = begin_omp_structured_block ();\n   save = cp_parser_begin_omp_structured_block (parser);\n \n-  ret = cp_parser_omp_for_loop (parser, OMP_DISTRIBUTE, clauses, NULL);\n+  ret = cp_parser_omp_for_loop (parser, OMP_DISTRIBUTE, clauses, NULL, if_p);\n \n   cp_parser_end_omp_structured_block (parser, save);\n   add_stmt (finish_omp_structured_block (sb));\n@@ -34499,7 +34509,8 @@ cp_parser_omp_distribute (cp_parser *parser, cp_token *pragma_tok,\n \n static tree\n cp_parser_omp_teams (cp_parser *parser, cp_token *pragma_tok,\n-\t\t     char *p_name, omp_clause_mask mask, tree *cclauses)\n+\t\t     char *p_name, omp_clause_mask mask, tree *cclauses,\n+\t\t     bool *if_p)\n {\n   tree clauses, sb, ret;\n   unsigned int save;\n@@ -34521,11 +34532,11 @@ cp_parser_omp_teams (cp_parser *parser, cp_token *pragma_tok,\n \t  cp_lexer_consume_token (parser->lexer);\n \t  if (!flag_openmp)  /* flag_openmp_simd  */\n \t    return cp_parser_omp_distribute (parser, pragma_tok, p_name, mask,\n-\t\t\t\t\t     cclauses);\n+\t\t\t\t\t     cclauses, if_p);\n \t  sb = begin_omp_structured_block ();\n \t  save = cp_parser_begin_omp_structured_block (parser);\n \t  ret = cp_parser_omp_distribute (parser, pragma_tok, p_name, mask,\n-\t\t\t\t\t  cclauses);\n+\t\t\t\t\t  cclauses, if_p);\n \t  cp_parser_end_omp_structured_block (parser, save);\n \t  tree body = finish_omp_structured_block (sb);\n \t  if (ret == NULL)\n@@ -34556,7 +34567,7 @@ cp_parser_omp_teams (cp_parser *parser, cp_token *pragma_tok,\n   tree stmt = make_node (OMP_TEAMS);\n   TREE_TYPE (stmt) = void_type_node;\n   OMP_TEAMS_CLAUSES (stmt) = clauses;\n-  OMP_TEAMS_BODY (stmt) = cp_parser_omp_structured_block (parser);\n+  OMP_TEAMS_BODY (stmt) = cp_parser_omp_structured_block (parser, if_p);\n \n   return add_stmt (stmt);\n }\n@@ -34572,7 +34583,7 @@ cp_parser_omp_teams (cp_parser *parser, cp_token *pragma_tok,\n \t| (OMP_CLAUSE_MASK_1 << PRAGMA_OMP_CLAUSE_USE_DEVICE_PTR))\n \n static tree\n-cp_parser_omp_target_data (cp_parser *parser, cp_token *pragma_tok)\n+cp_parser_omp_target_data (cp_parser *parser, cp_token *pragma_tok, bool *if_p)\n {\n   tree clauses\n     = cp_parser_omp_all_clauses (parser, OMP_TARGET_DATA_CLAUSE_MASK,\n@@ -34622,7 +34633,7 @@ cp_parser_omp_target_data (cp_parser *parser, cp_token *pragma_tok)\n   OMP_TARGET_DATA_CLAUSES (stmt) = clauses;\n \n   keep_next_level (true);\n-  OMP_TARGET_DATA_BODY (stmt) = cp_parser_omp_structured_block (parser);\n+  OMP_TARGET_DATA_BODY (stmt) = cp_parser_omp_structured_block (parser, if_p);\n \n   SET_EXPR_LOCATION (stmt, pragma_tok->location);\n   return add_stmt (stmt);\n@@ -34867,7 +34878,7 @@ cp_parser_omp_target_update (cp_parser *parser, cp_token *pragma_tok,\n \n static bool\n cp_parser_omp_target (cp_parser *parser, cp_token *pragma_tok,\n-\t\t      enum pragma_context context)\n+\t\t      enum pragma_context context, bool *if_p)\n {\n   tree *pc = NULL, stmt;\n \n@@ -34906,17 +34917,17 @@ cp_parser_omp_target (cp_parser *parser, cp_token *pragma_tok,\n \t\tcase OMP_TEAMS:\n \t\t  stmt = cp_parser_omp_teams (parser, pragma_tok, p_name,\n \t\t\t\t\t      OMP_TARGET_CLAUSE_MASK,\n-\t\t\t\t\t      cclauses);\n+\t\t\t\t\t      cclauses, if_p);\n \t\t  break;\n \t\tcase OMP_PARALLEL:\n \t\t  stmt = cp_parser_omp_parallel (parser, pragma_tok, p_name,\n \t\t\t\t\t\t OMP_TARGET_CLAUSE_MASK,\n-\t\t\t\t\t\t cclauses);\n+\t\t\t\t\t\t cclauses, if_p);\n \t\t  break;\n \t\tcase OMP_SIMD:\n \t\t  stmt = cp_parser_omp_simd (parser, pragma_tok, p_name,\n \t\t\t\t\t     OMP_TARGET_CLAUSE_MASK,\n-\t\t\t\t\t     cclauses);\n+\t\t\t\t\t     cclauses, if_p);\n \t\t  break;\n \t\tdefault:\n \t\t  gcc_unreachable ();\n@@ -34930,15 +34941,18 @@ cp_parser_omp_target (cp_parser *parser, cp_token *pragma_tok,\n \t    {\n \t    case OMP_TEAMS:\n \t      ret = cp_parser_omp_teams (parser, pragma_tok, p_name,\n-\t\t\t\t\t OMP_TARGET_CLAUSE_MASK, cclauses);\n+\t\t\t\t\t OMP_TARGET_CLAUSE_MASK, cclauses,\n+\t\t\t\t\t if_p);\n \t      break;\n \t    case OMP_PARALLEL:\n \t      ret = cp_parser_omp_parallel (parser, pragma_tok, p_name,\n-\t\t\t\t\t    OMP_TARGET_CLAUSE_MASK, cclauses);\n+\t\t\t\t\t    OMP_TARGET_CLAUSE_MASK, cclauses,\n+\t\t\t\t\t    if_p);\n \t      break;\n \t    case OMP_SIMD:\n \t      ret = cp_parser_omp_simd (parser, pragma_tok, p_name,\n-\t\t\t\t\tOMP_TARGET_CLAUSE_MASK, cclauses);\n+\t\t\t\t\tOMP_TARGET_CLAUSE_MASK, cclauses,\n+\t\t\t\t\tif_p);\n \t      break;\n \t    default:\n \t      gcc_unreachable ();\n@@ -34991,7 +35005,7 @@ cp_parser_omp_target (cp_parser *parser, cp_token *pragma_tok,\n       else if (strcmp (p, \"data\") == 0)\n \t{\n \t  cp_lexer_consume_token (parser->lexer);\n-\t  cp_parser_omp_target_data (parser, pragma_tok);\n+\t  cp_parser_omp_target_data (parser, pragma_tok, if_p);\n \t  return true;\n \t}\n       else if (strcmp (p, \"enter\") == 0)\n@@ -35021,7 +35035,7 @@ cp_parser_omp_target (cp_parser *parser, cp_token *pragma_tok,\n \t\t\t\t \"#pragma omp target\", pragma_tok);\n   pc = &OMP_TARGET_CLAUSES (stmt);\n   keep_next_level (true);\n-  OMP_TARGET_BODY (stmt) = cp_parser_omp_structured_block (parser);\n+  OMP_TARGET_BODY (stmt) = cp_parser_omp_structured_block (parser, if_p);\n \n   SET_EXPR_LOCATION (stmt, pragma_tok->location);\n   add_stmt (stmt);\n@@ -35097,7 +35111,7 @@ cp_parser_oacc_cache (cp_parser *parser, cp_token *pragma_tok)\n \t| (OMP_CLAUSE_MASK_1 << PRAGMA_OACC_CLAUSE_PRESENT_OR_CREATE))\n \n static tree\n-cp_parser_oacc_data (cp_parser *parser, cp_token *pragma_tok)\n+cp_parser_oacc_data (cp_parser *parser, cp_token *pragma_tok, bool *if_p)\n {\n   tree stmt, clauses, block;\n   unsigned int save;\n@@ -35107,7 +35121,7 @@ cp_parser_oacc_data (cp_parser *parser, cp_token *pragma_tok)\n \n   block = begin_omp_parallel ();\n   save = cp_parser_begin_omp_structured_block (parser);\n-  cp_parser_statement (parser, NULL_TREE, false, NULL);\n+  cp_parser_statement (parser, NULL_TREE, false, if_p);\n   cp_parser_end_omp_structured_block (parser, save);\n   stmt = finish_oacc_data (clauses, block);\n   return stmt;\n@@ -35121,7 +35135,7 @@ cp_parser_oacc_data (cp_parser *parser, cp_token *pragma_tok)\n   ( (OMP_CLAUSE_MASK_1 << PRAGMA_OACC_CLAUSE_USE_DEVICE) )\n \n static tree\n-cp_parser_oacc_host_data (cp_parser *parser, cp_token *pragma_tok)\n+cp_parser_oacc_host_data (cp_parser *parser, cp_token *pragma_tok, bool *if_p)\n {\n   tree stmt, clauses, block;\n   unsigned int save;\n@@ -35131,7 +35145,7 @@ cp_parser_oacc_host_data (cp_parser *parser, cp_token *pragma_tok)\n \n   block = begin_omp_parallel ();\n   save = cp_parser_begin_omp_structured_block (parser);\n-  cp_parser_statement (parser, NULL_TREE, false, NULL);\n+  cp_parser_statement (parser, NULL_TREE, false, if_p);\n   cp_parser_end_omp_structured_block (parser, save);\n   stmt = finish_oacc_host_data (clauses, block);\n   return stmt;\n@@ -35380,7 +35394,7 @@ cp_parser_oacc_enter_exit_data (cp_parser *parser, cp_token *pragma_tok,\n \n static tree\n cp_parser_oacc_loop (cp_parser *parser, cp_token *pragma_tok, char *p_name,\n-\t\t     omp_clause_mask mask, tree *cclauses)\n+\t\t     omp_clause_mask mask, tree *cclauses, bool *if_p)\n {\n   strcat (p_name, \" loop\");\n   mask |= OACC_LOOP_CLAUSE_MASK;\n@@ -35398,7 +35412,7 @@ cp_parser_oacc_loop (cp_parser *parser, cp_token *pragma_tok, char *p_name,\n \n   tree block = begin_omp_structured_block ();\n   int save = cp_parser_begin_omp_structured_block (parser);\n-  tree stmt = cp_parser_omp_for_loop (parser, OACC_LOOP, clauses, NULL);\n+  tree stmt = cp_parser_omp_for_loop (parser, OACC_LOOP, clauses, NULL, if_p);\n   cp_parser_end_omp_structured_block (parser, save);\n   add_stmt (finish_omp_structured_block (block));\n \n@@ -35455,7 +35469,7 @@ cp_parser_oacc_loop (cp_parser *parser, cp_token *pragma_tok, char *p_name,\n \n static tree\n cp_parser_oacc_kernels_parallel (cp_parser *parser, cp_token *pragma_tok,\n-\t\t\t\t char *p_name)\n+\t\t\t\t char *p_name, bool *if_p)\n {\n   omp_clause_mask mask;\n   enum tree_code code;\n@@ -35486,7 +35500,8 @@ cp_parser_oacc_kernels_parallel (cp_parser *parser, cp_token *pragma_tok,\n \n \t  tree block = begin_omp_parallel ();\n \t  tree clauses;\n-\t  cp_parser_oacc_loop (parser, pragma_tok, p_name, mask, &clauses);\n+\t  cp_parser_oacc_loop (parser, pragma_tok, p_name, mask, &clauses,\n+\t\t\t       if_p);\n \t  return finish_omp_construct (code, block, clauses);\n \t}\n     }\n@@ -35495,7 +35510,7 @@ cp_parser_oacc_kernels_parallel (cp_parser *parser, cp_token *pragma_tok,\n \n   tree block = begin_omp_parallel ();\n   unsigned int save = cp_parser_begin_omp_structured_block (parser);\n-  cp_parser_statement (parser, NULL_TREE, false, NULL);\n+  cp_parser_statement (parser, NULL_TREE, false, if_p);\n   cp_parser_end_omp_structured_block (parser, save);\n   return finish_omp_construct (code, block, clauses);\n }\n@@ -35599,7 +35614,7 @@ cp_parser_omp_declare_simd (cp_parser *parser, cp_token *pragma_tok,\n   if (first_p)\n     {\n       while (cp_lexer_next_token_is (parser->lexer, CPP_PRAGMA))\n-\tcp_parser_pragma (parser, context);\n+\tcp_parser_pragma (parser, context, NULL);\n       switch (context)\n \t{\n \tcase pragma_external:\n@@ -36322,7 +36337,8 @@ cp_parser_omp_declare (cp_parser *parser, cp_token *pragma_tok,\n \n static tree\n cp_parser_omp_taskloop (cp_parser *parser, cp_token *pragma_tok,\n-\t\t\tchar *p_name, omp_clause_mask mask, tree *cclauses)\n+\t\t\tchar *p_name, omp_clause_mask mask, tree *cclauses,\n+\t\t\tbool *if_p)\n {\n   tree clauses, sb, ret;\n   unsigned int save;\n@@ -36345,11 +36361,11 @@ cp_parser_omp_taskloop (cp_parser *parser, cp_token *pragma_tok,\n \t  cp_lexer_consume_token (parser->lexer);\n \t  if (!flag_openmp)  /* flag_openmp_simd  */\n \t    return cp_parser_omp_simd (parser, pragma_tok, p_name, mask,\n-\t\t\t\t       cclauses);\n+\t\t\t\t       cclauses, if_p);\n \t  sb = begin_omp_structured_block ();\n \t  save = cp_parser_begin_omp_structured_block (parser);\n \t  ret = cp_parser_omp_simd (parser, pragma_tok, p_name, mask,\n-\t\t\t\t    cclauses);\n+\t\t\t\t    cclauses, if_p);\n \t  cp_parser_end_omp_structured_block (parser, save);\n \t  tree body = finish_omp_structured_block (sb);\n \t  if (ret == NULL)\n@@ -36380,7 +36396,8 @@ cp_parser_omp_taskloop (cp_parser *parser, cp_token *pragma_tok,\n   sb = begin_omp_structured_block ();\n   save = cp_parser_begin_omp_structured_block (parser);\n \n-  ret = cp_parser_omp_for_loop (parser, OMP_TASKLOOP, clauses, cclauses);\n+  ret = cp_parser_omp_for_loop (parser, OMP_TASKLOOP, clauses, cclauses,\n+\t\t\t\tif_p);\n \n   cp_parser_end_omp_structured_block (parser, save);\n   add_stmt (finish_omp_structured_block (sb));\n@@ -36543,7 +36560,7 @@ cp_parser_oacc_routine (cp_parser *parser, cp_token *pragma_tok,\n \tparser->oacc_routine->clauses = c_head;\n \n       while (cp_lexer_next_token_is (parser->lexer, CPP_PRAGMA))\n-\tcp_parser_pragma (parser, context);\n+\tcp_parser_pragma (parser, context, NULL);\n \n       if (first_p)\n \t{\n@@ -36670,7 +36687,7 @@ cp_finalize_oacc_routine (cp_parser *parser, tree fndecl, bool is_defn)\n /* Main entry point to OpenMP statement pragmas.  */\n \n static void\n-cp_parser_omp_construct (cp_parser *parser, cp_token *pragma_tok)\n+cp_parser_omp_construct (cp_parser *parser, cp_token *pragma_tok, bool *if_p)\n {\n   tree stmt;\n   char p_name[sizeof \"#pragma omp teams distribute parallel for simd\"];\n@@ -36685,7 +36702,7 @@ cp_parser_omp_construct (cp_parser *parser, cp_token *pragma_tok)\n       stmt = cp_parser_oacc_cache (parser, pragma_tok);\n       break;\n     case PRAGMA_OACC_DATA:\n-      stmt = cp_parser_oacc_data (parser, pragma_tok);\n+      stmt = cp_parser_oacc_data (parser, pragma_tok, if_p);\n       break;\n     case PRAGMA_OACC_ENTER_DATA:\n       stmt = cp_parser_oacc_enter_exit_data (parser, pragma_tok, true);\n@@ -36694,16 +36711,18 @@ cp_parser_omp_construct (cp_parser *parser, cp_token *pragma_tok)\n       stmt = cp_parser_oacc_enter_exit_data (parser, pragma_tok, false);\n       break;\n     case PRAGMA_OACC_HOST_DATA:\n-      stmt = cp_parser_oacc_host_data (parser, pragma_tok);\n+      stmt = cp_parser_oacc_host_data (parser, pragma_tok, if_p);\n       break;\n     case PRAGMA_OACC_KERNELS:\n     case PRAGMA_OACC_PARALLEL:\n       strcpy (p_name, \"#pragma acc\");\n-      stmt = cp_parser_oacc_kernels_parallel (parser, pragma_tok, p_name);\n+      stmt = cp_parser_oacc_kernels_parallel (parser, pragma_tok, p_name,\n+\t\t\t\t\t      if_p);\n       break;\n     case PRAGMA_OACC_LOOP:\n       strcpy (p_name, \"#pragma acc\");\n-      stmt = cp_parser_oacc_loop (parser, pragma_tok, p_name, mask, NULL);\n+      stmt = cp_parser_oacc_loop (parser, pragma_tok, p_name, mask, NULL,\n+\t\t\t\t  if_p);\n       break;\n     case PRAGMA_OACC_UPDATE:\n       stmt = cp_parser_oacc_update (parser, pragma_tok);\n@@ -36715,47 +36734,53 @@ cp_parser_omp_construct (cp_parser *parser, cp_token *pragma_tok)\n       cp_parser_omp_atomic (parser, pragma_tok);\n       return;\n     case PRAGMA_OMP_CRITICAL:\n-      stmt = cp_parser_omp_critical (parser, pragma_tok);\n+      stmt = cp_parser_omp_critical (parser, pragma_tok, if_p);\n       break;\n     case PRAGMA_OMP_DISTRIBUTE:\n       strcpy (p_name, \"#pragma omp\");\n-      stmt = cp_parser_omp_distribute (parser, pragma_tok, p_name, mask, NULL);\n+      stmt = cp_parser_omp_distribute (parser, pragma_tok, p_name, mask, NULL,\n+\t\t\t\t       if_p);\n       break;\n     case PRAGMA_OMP_FOR:\n       strcpy (p_name, \"#pragma omp\");\n-      stmt = cp_parser_omp_for (parser, pragma_tok, p_name, mask, NULL);\n+      stmt = cp_parser_omp_for (parser, pragma_tok, p_name, mask, NULL,\n+\t\t\t\tif_p);\n       break;\n     case PRAGMA_OMP_MASTER:\n-      stmt = cp_parser_omp_master (parser, pragma_tok);\n+      stmt = cp_parser_omp_master (parser, pragma_tok, if_p);\n       break;\n     case PRAGMA_OMP_PARALLEL:\n       strcpy (p_name, \"#pragma omp\");\n-      stmt = cp_parser_omp_parallel (parser, pragma_tok, p_name, mask, NULL);\n+      stmt = cp_parser_omp_parallel (parser, pragma_tok, p_name, mask, NULL,\n+\t\t\t\t     if_p);\n       break;\n     case PRAGMA_OMP_SECTIONS:\n       strcpy (p_name, \"#pragma omp\");\n       stmt = cp_parser_omp_sections (parser, pragma_tok, p_name, mask, NULL);\n       break;\n     case PRAGMA_OMP_SIMD:\n       strcpy (p_name, \"#pragma omp\");\n-      stmt = cp_parser_omp_simd (parser, pragma_tok, p_name, mask, NULL);\n+      stmt = cp_parser_omp_simd (parser, pragma_tok, p_name, mask, NULL,\n+\t\t\t\t if_p);\n       break;\n     case PRAGMA_OMP_SINGLE:\n-      stmt = cp_parser_omp_single (parser, pragma_tok);\n+      stmt = cp_parser_omp_single (parser, pragma_tok, if_p);\n       break;\n     case PRAGMA_OMP_TASK:\n-      stmt = cp_parser_omp_task (parser, pragma_tok);\n+      stmt = cp_parser_omp_task (parser, pragma_tok, if_p);\n       break;\n     case PRAGMA_OMP_TASKGROUP:\n-      stmt = cp_parser_omp_taskgroup (parser, pragma_tok);\n+      stmt = cp_parser_omp_taskgroup (parser, pragma_tok, if_p);\n       break;\n     case PRAGMA_OMP_TASKLOOP:\n       strcpy (p_name, \"#pragma omp\");\n-      stmt = cp_parser_omp_taskloop (parser, pragma_tok, p_name, mask, NULL);\n+      stmt = cp_parser_omp_taskloop (parser, pragma_tok, p_name, mask, NULL,\n+\t\t\t\t     if_p);\n       break;\n     case PRAGMA_OMP_TEAMS:\n       strcpy (p_name, \"#pragma omp\");\n-      stmt = cp_parser_omp_teams (parser, pragma_tok, p_name, mask, NULL);\n+      stmt = cp_parser_omp_teams (parser, pragma_tok, p_name, mask, NULL,\n+\t\t\t\t  if_p);\n       break;\n     default:\n       gcc_unreachable ();\n@@ -37110,7 +37135,7 @@ cp_parser_initial_pragma (cp_token *first_token)\n    #pragma cilk grainsize = <VALUE>.  */\n \n static void\n-cp_parser_cilk_grainsize (cp_parser *parser, cp_token *pragma_tok)\n+cp_parser_cilk_grainsize (cp_parser *parser, cp_token *pragma_tok, bool *if_p)\n {\n   if (cp_parser_require (parser, CPP_EQ, RT_EQ))\n     {\n@@ -37125,7 +37150,7 @@ cp_parser_cilk_grainsize (cp_parser *parser, cp_token *pragma_tok)\n \n       /* Make sure the next token is _Cilk_for, it is invalid otherwise.  */\n       if (cp_lexer_next_token_is_keyword (parser->lexer, RID_CILK_FOR))\n-\tcp_parser_cilk_for (parser, exp);\n+\tcp_parser_cilk_for (parser, exp, if_p);\n       else\n \twarning_at (cp_lexer_peek_token (parser->lexer)->location, 0,\n \t\t    \"%<#pragma cilk grainsize%> is not followed by \"\n@@ -37139,7 +37164,7 @@ cp_parser_cilk_grainsize (cp_parser *parser, cp_token *pragma_tok)\n    regular lexer.  */\n \n static bool\n-cp_parser_pragma (cp_parser *parser, enum pragma_context context)\n+cp_parser_pragma (cp_parser *parser, enum pragma_context context, bool *if_p)\n {\n   cp_token *pragma_tok;\n   unsigned int id;\n@@ -37297,19 +37322,19 @@ cp_parser_pragma (cp_parser *parser, enum pragma_context context)\n       if (context != pragma_stmt && context != pragma_compound)\n \tgoto bad_stmt;\n       stmt = push_omp_privatization_clauses (false);\n-      cp_parser_omp_construct (parser, pragma_tok);\n+      cp_parser_omp_construct (parser, pragma_tok, if_p);\n       pop_omp_privatization_clauses (stmt);\n       return true;\n \n     case PRAGMA_OMP_ORDERED:\n       stmt = push_omp_privatization_clauses (false);\n-      ret = cp_parser_omp_ordered (parser, pragma_tok, context);\n+      ret = cp_parser_omp_ordered (parser, pragma_tok, context, if_p);\n       pop_omp_privatization_clauses (stmt);\n       return ret;\n \n     case PRAGMA_OMP_TARGET:\n       stmt = push_omp_privatization_clauses (false);\n-      ret = cp_parser_omp_target (parser, pragma_tok, context);\n+      ret = cp_parser_omp_target (parser, pragma_tok, context, if_p);\n       pop_omp_privatization_clauses (stmt);\n       return ret;\n \n@@ -37341,7 +37366,7 @@ cp_parser_pragma (cp_parser *parser, enum pragma_context context)\n \t    cp_parser_error (parser, \"for, while or do statement expected\");\n \t    return false;\n \t  }\n-\tcp_parser_iteration_statement (parser, NULL, true);\n+\tcp_parser_iteration_statement (parser, if_p, true);\n \treturn true;\n       }\n \n@@ -37353,7 +37378,7 @@ cp_parser_pragma (cp_parser *parser, enum pragma_context context)\n \t  break;\n \t}\n       stmt = push_omp_privatization_clauses (false);\n-      cp_parser_cilk_simd (parser, pragma_tok);\n+      cp_parser_cilk_simd (parser, pragma_tok, if_p);\n       pop_omp_privatization_clauses (stmt);\n       return true;\n \n@@ -37368,7 +37393,7 @@ cp_parser_pragma (cp_parser *parser, enum pragma_context context)\n       /* Ignore the pragma if Cilk Plus is not enabled.  */\n       if (flag_cilkplus)\n \t{\n-\t  cp_parser_cilk_grainsize (parser, pragma_tok);\n+\t  cp_parser_cilk_grainsize (parser, pragma_tok, if_p);\n \t  return true;\n \t}\n       else\n@@ -37695,7 +37720,7 @@ cp_parser_cilk_simd_all_clauses (cp_parser *parser, cp_token *pragma_token)\n /* Main entry-point for parsing Cilk Plus <#pragma simd> for loops.  */\n \n static void\n-cp_parser_cilk_simd (cp_parser *parser, cp_token *pragma_token)\n+cp_parser_cilk_simd (cp_parser *parser, cp_token *pragma_token, bool *if_p)\n {\n   tree clauses = cp_parser_cilk_simd_all_clauses (parser, pragma_token);\n \n@@ -37711,7 +37736,7 @@ cp_parser_cilk_simd (cp_parser *parser, cp_token *pragma_token)\n \n   tree sb = begin_omp_structured_block ();\n   int save = cp_parser_begin_omp_structured_block (parser);\n-  tree ret = cp_parser_omp_for_loop (parser, CILK_SIMD, clauses, NULL);\n+  tree ret = cp_parser_omp_for_loop (parser, CILK_SIMD, clauses, NULL, if_p);\n   if (ret)\n     cpp_validate_cilk_plus_loop (OMP_FOR_BODY (ret));\n   cp_parser_end_omp_structured_block (parser, save);\n@@ -37723,7 +37748,7 @@ cp_parser_cilk_simd (cp_parser *parser, cp_token *pragma_token)\n    when errors happen and CILK_FOR tree on success.  */\n \n static tree\n-cp_parser_cilk_for (cp_parser *parser, tree grain)\n+cp_parser_cilk_for (cp_parser *parser, tree grain, bool *if_p)\n {\n   if (cp_lexer_next_token_is_not_keyword (parser->lexer, RID_CILK_FOR))\n     gcc_unreachable ();\n@@ -37736,7 +37761,7 @@ cp_parser_cilk_for (cp_parser *parser, tree grain)\n   OMP_CLAUSE_SCHEDULE_CHUNK_EXPR (clauses) = grain;\n   clauses = finish_omp_clauses (clauses, false);\n \n-  tree ret = cp_parser_omp_for_loop (parser, CILK_FOR, clauses, NULL);\n+  tree ret = cp_parser_omp_for_loop (parser, CILK_FOR, clauses, NULL, if_p);\n   if (ret)\n     cpp_validate_cilk_plus_loop (ret);\n   else"}, {"sha": "4409f7fa1bcbba86798d8773f783767bda0906a9", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dda1bf6123a4e69cb9aa5072442b803f82da2be3/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dda1bf6123a4e69cb9aa5072442b803f82da2be3/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=dda1bf6123a4e69cb9aa5072442b803f82da2be3", "patch": "@@ -1,3 +1,15 @@\n+2016-04-15  Jakub Jelinek  <jakub@redhat.com>\n+\n+\tPR c/70436\n+\t* c-c++-common/Wparentheses-1.c: New test.\n+\t* c-c++-common/gomp/Wparentheses-1.c: New test.\n+\t* c-c++-common/gomp/Wparentheses-2.c: New test.\n+\t* c-c++-common/gomp/Wparentheses-3.c: New test.\n+\t* c-c++-common/gomp/Wparentheses-4.c: New test.\n+\t* c-c++-common/cilk-plus/PS/Wparentheses-1.c: New test.\n+\t* c-c++-common/cilk-plus/CK/Wparentheses-1.c: New test.\n+\t* c-c++-common/goacc/Wparentheses-1.c: New test.\n+\n 2016-04-15  Kirill Yukhin  <kirill.yukhin@intel.com>\n \n \tPR target/70662"}, {"sha": "ed5060838297d9eb48e5570c7fa1d3c09ae8e0b2", "filename": "gcc/testsuite/c-c++-common/Wparentheses-1.c", "status": "added", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dda1bf6123a4e69cb9aa5072442b803f82da2be3/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2FWparentheses-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dda1bf6123a4e69cb9aa5072442b803f82da2be3/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2FWparentheses-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2FWparentheses-1.c?ref=dda1bf6123a4e69cb9aa5072442b803f82da2be3", "patch": "@@ -0,0 +1,39 @@\n+/* PR c/70436 */\n+/* { dg-do compile } */\n+/* { dg-options \"-Wparentheses\" } */\n+\n+int a, b, c[101], d[101], e[101], f[101];\n+\n+void\n+f1 (void)\n+{\n+  int i;\n+\n+  if (a) /* { dg-warning \"ambiguous\" } */\n+    #pragma GCC ivdep\n+    for (i = 0; i < 100; i++)\n+      if (b)\n+\tc[i] = d[i] + e[i];\n+      else\n+\tf[i] = d[i] * e[i];\n+\n+  if (a)\n+    #pragma GCC ivdep\n+    for (i = 0; i < 100; i++)\n+      {\n+\tif (b)\n+\t  c[i] = d[i] + e[i];\n+\telse\n+\t  f[i] = d[i] * e[i];\n+      }\n+\n+  if (a)\n+    #pragma GCC ivdep\n+    for (i = 0; i < 100; i++)\n+      {\n+\tif (b)\n+\t  c[i] = d[i] + e[i];\n+      }\n+  else\n+    f[i] = d[i] * e[i];\n+}"}, {"sha": "f07b49a2775f7b8b8d6b98e682e5128266a230f9", "filename": "gcc/testsuite/c-c++-common/cilk-plus/CK/Wparentheses-1.c", "status": "added", "additions": 69, "deletions": 0, "changes": 69, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dda1bf6123a4e69cb9aa5072442b803f82da2be3/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcilk-plus%2FCK%2FWparentheses-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dda1bf6123a4e69cb9aa5072442b803f82da2be3/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcilk-plus%2FCK%2FWparentheses-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcilk-plus%2FCK%2FWparentheses-1.c?ref=dda1bf6123a4e69cb9aa5072442b803f82da2be3", "patch": "@@ -0,0 +1,69 @@\n+/* PR c/70436 */\n+/* { dg-do compile } */\n+/* { dg-options \"-fcilkplus -Wparentheses\" } */\n+/* { dg-additional-options \"-std=gnu99\" { target c } } */\n+\n+int a, b, c;\n+void bar (void);\n+void baz (void);\n+\n+void\n+f1 (void)\n+{\n+  if (a) /* { dg-warning \"ambiguous\" } */\n+    _Cilk_for (int i = 0; i < 10; i++)\n+      if (b)\n+\tbar ();\n+      else\n+\tbaz ();\n+\n+  if (a)\n+    _Cilk_for (int i = 0; i < 10; i++)\n+      {\n+\tif (b)\n+\t  bar ();\n+\telse\n+\t  baz ();\n+      }\n+\n+  if (a)\n+    _Cilk_for (int i = 0; i < 10; i++)\n+      {\n+\tif (b)\n+\t  bar ();\n+      }\n+  else\n+    baz ();\n+}\n+\n+void\n+f2 (void)\n+{\n+  if (a) /* { dg-warning \"ambiguous\" } */\n+    #pragma cilk grainsize = 2\n+    _Cilk_for (int i = 0; i < 10; i++)\n+      if (b)\n+\tbar ();\n+      else\n+\tbaz ();\n+\n+  if (a)\n+    #pragma cilk grainsize = 2\n+    _Cilk_for (int i = 0; i < 10; i++)\n+      {\n+\tif (b)\n+\t  bar ();\n+\telse\n+\t  baz ();\n+      }\n+\n+  if (a)\n+    #pragma cilk grainsize = 2\n+    _Cilk_for (int i = 0; i < 10; i++)\n+      {\n+\tif (b)\n+\t  bar ();\n+      }\n+  else\n+    baz ();\n+}"}, {"sha": "d391d7b1eed13a4d63e4eadaf4ee68c3ad9a61f0", "filename": "gcc/testsuite/c-c++-common/cilk-plus/PS/Wparentheses-1.c", "status": "added", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dda1bf6123a4e69cb9aa5072442b803f82da2be3/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcilk-plus%2FPS%2FWparentheses-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dda1bf6123a4e69cb9aa5072442b803f82da2be3/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcilk-plus%2FPS%2FWparentheses-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcilk-plus%2FPS%2FWparentheses-1.c?ref=dda1bf6123a4e69cb9aa5072442b803f82da2be3", "patch": "@@ -0,0 +1,41 @@\n+/* PR c/70436 */\n+/* { dg-do compile } */\n+/* { dg-options \"-fcilkplus -Wparentheses\" } */\n+\n+int a, b, c;\n+void bar (void);\n+void baz (void);\n+\n+void\n+f1 (void)\n+{\n+  int i;\n+\n+  if (a) /* { dg-warning \"ambiguous\" } */\n+    #pragma simd\n+    for (i = 0; i < 10; i++)\n+      if (b)\n+\tbar ();\n+      else\n+\tbaz ();\n+\n+  if (a)\n+    #pragma simd\n+    for (i = 0; i < 10; i++)\n+      {\n+\tif (b)\n+\t  bar ();\n+\telse\n+\t  baz ();\n+      }\n+\n+  if (a)\n+    #pragma simd\n+    for (i = 0; i < 10; i++)\n+      {\n+\tif (b)\n+\t  bar ();\n+      }\n+  else\n+    baz ();\n+}"}, {"sha": "08265b65e0bd0426c9dab2ddbab3992c7dc1f387", "filename": "gcc/testsuite/c-c++-common/goacc/Wparentheses-1.c", "status": "added", "additions": 174, "deletions": 0, "changes": 174, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dda1bf6123a4e69cb9aa5072442b803f82da2be3/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgoacc%2FWparentheses-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dda1bf6123a4e69cb9aa5072442b803f82da2be3/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgoacc%2FWparentheses-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgoacc%2FWparentheses-1.c?ref=dda1bf6123a4e69cb9aa5072442b803f82da2be3", "patch": "@@ -0,0 +1,174 @@\n+/* PR c/70436 */\n+/* { dg-additional-options \"-Wparentheses\" } */\n+\n+int a, b, c;\n+void bar (void);\n+void baz (void);\n+#pragma acc routine\n+void bar2 (void);\n+#pragma acc routine\n+void baz2 (void);\n+\n+void\n+f1 (void)\n+{\n+  int i, d[10] = { 0 };\n+\n+  if (a) /* { dg-warning \"ambiguous\" } */\n+    #pragma acc data copyin (d[0:10])\n+      if (b)\n+\tbar ();\n+      else\n+\tbaz ();\n+\n+  #pragma acc data copyin (d[0:10])\n+  if (a) /* { dg-warning \"ambiguous\" } */\n+    #pragma acc host_data use_device (d)\n+      if (b)\n+\tbar ();\n+      else\n+\tbaz ();\n+\n+  if (a) /* { dg-warning \"ambiguous\" } */\n+    #pragma acc kernels\n+      if (b)\n+\tbar2 ();\n+      else\n+\tbaz2 ();\n+\n+  if (a) /* { dg-warning \"ambiguous\" } */\n+    #pragma acc kernels\n+    for (i = 0; i < 10; i++)\n+      if (b)\n+\tbar2 ();\n+      else\n+\tbaz2 ();\n+\n+  if (a) /* { dg-warning \"ambiguous\" } */\n+    #pragma acc parallel\n+      if (b)\n+\tbar2 ();\n+      else\n+\tbaz2 ();\n+\n+  if (a) /* { dg-warning \"ambiguous\" } */\n+    #pragma acc parallel loop\n+    for (i = 0; i < 10; i++)\n+      if (b)\n+\tbar2 ();\n+      else\n+\tbaz2 ();\n+\n+  (void) d[0];\n+\n+  if (a)\n+    #pragma acc data copyin (d[0:10])\n+      {\n+\tif (b)\n+\t  bar ();\n+\telse\n+\t  baz ();\n+      }\n+\n+  if (a)\n+    #pragma acc data copyin (d[0:10])\n+      {\n+\tif (b)\n+\t  bar ();\n+      }\n+  else\n+    baz ();\n+\n+  #pragma acc data copyin (d[0:10])\n+  if (a)\n+    #pragma acc host_data use_device (d)\n+    {\n+      if (b)\n+\tbar ();\n+      else\n+\tbaz ();\n+    }\n+\n+  #pragma acc data copyin (d[0:10])\n+  if (a)\n+    #pragma acc host_data use_device (d)\n+    {\n+      if (b)\n+\tbar ();\n+    }\n+  else\n+    baz ();\n+\n+  if (a)\n+    #pragma acc kernels\n+    {\n+      if (b)\n+\tbar2 ();\n+      else\n+\tbaz2 ();\n+    }\n+\n+  if (a)\n+    #pragma acc kernels\n+    for (i = 0; i < 10; i++)\n+      {\n+\tif (b)\n+\t  bar2 ();\n+\telse\n+\t  baz2 ();\n+      }\n+\n+  if (a)\n+    #pragma acc parallel\n+      {\n+\tif (b)\n+\t  bar2 ();\n+\telse\n+\t  baz2 ();\n+      }\n+\n+  if (a)\n+    #pragma acc parallel loop\n+    for (i = 0; i < 10; i++)\n+      {\n+\tif (b)\n+\t  bar2 ();\n+\telse\n+\t  baz2 ();\n+      }\n+\n+  if (a)\n+    {\n+      #pragma acc parallel loop\n+      for (i = 0; i < 10; i++)\n+\tif (b)\n+\t  bar2 ();\n+\telse\n+\t  baz2 ();\n+    }\n+}\n+\n+#pragma acc routine vector\n+void\n+f2 (int *a, int b, int c)\n+{\n+  int i;\n+\n+  if (b) /* { dg-warning \"ambiguous\" } */\n+    #pragma acc loop vector\n+      for (i = 0; i < 10; i++)\n+\tif (c)\n+\t  a[i] = a[i] + 1;\n+\telse\n+\t  a[i] = a[i] + 2;\n+\n+  if (b)\n+    #pragma acc loop vector\n+      for (i = 0; i < 10; i++)\n+\t{\n+\t  if (c)\n+\t    a[i] = a[i] + 1;\n+\t  else\n+\t    a[i] = a[i] + 2;\n+\t}\n+}"}, {"sha": "4420d670bde321cbc4203beda6f0d667770b8632", "filename": "gcc/testsuite/c-c++-common/gomp/Wparentheses-1.c", "status": "added", "additions": 338, "deletions": 0, "changes": 338, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dda1bf6123a4e69cb9aa5072442b803f82da2be3/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2FWparentheses-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dda1bf6123a4e69cb9aa5072442b803f82da2be3/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2FWparentheses-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2FWparentheses-1.c?ref=dda1bf6123a4e69cb9aa5072442b803f82da2be3", "patch": "@@ -0,0 +1,338 @@\n+/* PR c/70436 */\n+/* { dg-additional-options \"-Wparentheses\" } */\n+\n+int a, b, c;\n+void bar (void);\n+void baz (void);\n+\n+void\n+f1 (void)\n+{\n+  int i, j;\n+\n+  if (a) /* { dg-warning \"ambiguous\" } */\n+    #pragma omp for\n+    for (i = 0; i < 10; i++)\n+      if (b)\n+\tbar ();\n+      else\n+\tbaz ();\n+\n+  if (a) /* { dg-warning \"ambiguous\" } */\n+    while (1)\n+      #pragma omp for\n+      for (i = 0; i < 10; i++)\n+\tif (b)\n+\t  bar ();\n+\telse\n+\t  baz ();\n+\n+  if (a) /* { dg-warning \"ambiguous\" } */\n+    for (i = 0; i < 10; i++)\n+      #pragma omp for\n+      for (j = 0; j < 10; j++)\n+\tif (b)\n+\t  bar ();\n+  else\n+    baz ();\n+\n+  if (a)\n+    #pragma omp for\n+    for (i = 0; i < 10; i++)\n+      if (b) /* { dg-warning \"ambiguous\" } */\n+\t#pragma omp parallel for\n+\tfor (j = 0; j < 10; j++)\n+\t  if (c)\n+\t    bar ();\n+      else\n+\tbaz ();\n+\n+  if (a) /* { dg-warning \"ambiguous\" } */\n+    #pragma omp taskloop\n+    for (i = 0; i < 10; i++)\n+      if (b)\n+\t#pragma omp parallel for\n+\tfor (j = 0; j < 10; j++)\n+\t  if (c)\n+\t    bar ();\n+\t  else\n+\t    baz ();\n+  else\n+    bar ();\n+\n+  if (a) /* { dg-warning \"ambiguous\" } */\n+    #pragma omp taskloop simd\n+    for (i = 0; i < 10; i++)\n+      if (b)\n+\tbar ();\n+      else\n+\tbaz ();\n+\n+  if (a) /* { dg-warning \"ambiguous\" } */\n+    #pragma omp for collapse(2)\n+    for (i = 0; i < 10; i++)\n+      for (j = 0; j < 10; j++)\n+\tif (b)\n+\t  bar ();\n+\telse\n+\t  baz ();\n+\n+  if (a) /* { dg-warning \"ambiguous\" } */\n+    #pragma omp critical\n+      if (b)\n+\tbar ();\n+      else\n+\tbaz ();\n+\n+  if (a) /* { dg-warning \"ambiguous\" } */\n+    for (i = 0; i < 10; i++)\n+      #pragma omp simd\n+      for (j = 0; j < 10; j++)\n+\tif (b)\n+\t  bar ();\n+  else\n+    baz ();\n+\n+  if (a) /* { dg-warning \"ambiguous\" } */\n+    #pragma omp for simd schedule(runtime)\n+    for (i = 0; i < 10; i++)\n+      if (b)\n+\tbar ();\n+      else\n+\tbaz ();\n+\n+  if (a) /* { dg-warning \"ambiguous\" } */\n+    #pragma omp master\n+      if (b)\n+\tbar ();\n+      else\n+\tbaz ();\n+\n+  if (a) /* { dg-warning \"ambiguous\" } */\n+    #pragma omp parallel\n+      if (b)\n+\tbar ();\n+      else\n+\tbaz ();\n+\n+  if (a) /* { dg-warning \"ambiguous\" } */\n+    for (i = 0; i < 10; i++)\n+      #pragma omp parallel for\n+      for (j = 0; j < 10; j++)\n+\tif (b)\n+\t  bar ();\n+  else\n+    baz ();\n+\n+  if (a) /* { dg-warning \"ambiguous\" } */\n+    for (i = 0; i < 10; i++)\n+      #pragma omp parallel for simd\n+      for (j = 0; j < 10; j++)\n+\tif (b)\n+\t  bar ();\n+  else\n+    baz ();\n+\n+  if (a) /* { dg-warning \"ambiguous\" } */\n+    #pragma omp single\n+      if (b)\n+\tbar ();\n+      else\n+\tbaz ();\n+\n+  if (a) /* { dg-warning \"ambiguous\" } */\n+    #pragma omp task\n+      if (b)\n+\tbar ();\n+      else\n+\tbaz ();\n+\n+  if (a) /* { dg-warning \"ambiguous\" } */\n+    #pragma omp taskgroup\n+      if (b)\n+\tbar ();\n+      else\n+\tbaz ();\n+\n+  if (a)\n+    #pragma omp for\n+    for (i = 0; i < 10; i++)\n+      {\n+\tif (b)\n+\t  bar ();\n+\telse\n+\t  baz ();\n+      }\n+\n+  if (a)\n+    {\n+      #pragma omp taskloop\n+      for (i = 0; i < 10; ++i)\n+\tif (b)\n+\t  bar ();\n+    }\n+  else baz ();\n+\n+  if (a)\n+    #pragma omp for collapse(2)\n+    for (i = 0; i < 10; i++)\n+      {\n+\tfor (j = 0; j < 10; j++)\n+\t  if (b)\n+\t    bar ();\n+\t  else\n+\t    baz ();\n+      }\n+\n+  if (a)\n+    #pragma omp critical\n+      {\n+\tif (b)\n+\t  bar ();\n+\telse\n+\t  baz ();\n+      }\n+\n+  if (a)\n+    for (i = 0; i < 10; i++)\n+      #pragma omp simd\n+      for (j = 0; j < 10; j++)\n+\t{\n+\t  if (b)\n+\t    bar ();\n+\t}\n+  else\n+    baz ();\n+\n+  if (a)\n+    #pragma omp for simd schedule(dynamic, 5)\n+    for (i = 0; i < 10; i++)\n+      {\n+\tif (b)\n+\t  bar ();\n+\telse\n+\t  baz ();\n+      }\n+\n+  if (a)\n+    #pragma omp master\n+      {\n+\tif (b)\n+\t  bar ();\n+\telse\n+\t  baz ();\n+      }\n+\n+  if (a)\n+    #pragma omp parallel\n+      {\n+\tif (b)\n+\t  bar ();\n+\telse\n+\t  baz ();\n+      }\n+\n+  if (a)\n+    {\n+      #pragma omp parallel\n+\tif (b)\n+\t  bar ();\n+\telse\n+\t  baz ();\n+    }\n+\n+  if (a)\n+    for (i = 0; i < 10; i++)\n+      #pragma omp parallel for\n+      for (j = 0; j < 10; j++)\n+\t{\n+\t  if (b)\n+\t    bar ();\n+\t}\n+  else\n+    baz ();\n+\n+  if (a)\n+    for (i = 0; i < 10; i++)\n+      #pragma omp parallel for simd\n+      for (j = 0; j < 10; j++)\n+\t{\n+\t  if (b)\n+\t    bar ();\n+\t}\n+  else\n+    baz ();\n+\n+  if (a)\n+    #pragma omp single\n+      {\n+\tif (b)\n+\t  bar ();\n+      }\n+  else\n+    baz ();\n+\n+  if (a)\n+    #pragma omp task\n+      {\n+\tif (b)\n+\t  bar ();\n+      }\n+  else\n+    baz ();\n+\n+  if (a)\n+    #pragma omp taskgroup\n+      {\n+\tif (b)\n+\t  bar ();\n+\telse\n+\t  baz ();\n+      }\n+\n+  if (a)\n+    #pragma omp taskloop simd\n+    for (i = 0; i < 10; i++)\n+      {\n+\tif (b)\n+\t  bar ();\n+\telse\n+\t  baz ();\n+      }\n+}\n+\n+void\n+f2 (int d, int e, int f)\n+{\n+  if (a) /* { dg-warning \"ambiguous\" } */\n+    #pragma omp ordered\n+      if (b)\n+\tbar ();\n+      else\n+\tbaz ();\n+\n+  if (d) /* { dg-warning \"ambiguous\" } */\n+    #pragma omp ordered threads\n+      if (b)\n+\tbar ();\n+      else\n+\tbaz ();\n+\n+  if (e)\n+    #pragma omp ordered\n+      {\n+\tif (b)\n+\t  bar ();\n+\telse\n+\t  baz ();\n+      }\n+\n+  if (f)\n+    #pragma omp ordered threads\n+      {\n+\tif (b)\n+\t  bar ();\n+\telse\n+\t  baz ();\n+      }\n+}"}, {"sha": "4341b22323669b6972a235201ef6c38f98c72150", "filename": "gcc/testsuite/c-c++-common/gomp/Wparentheses-2.c", "status": "added", "additions": 452, "deletions": 0, "changes": 452, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dda1bf6123a4e69cb9aa5072442b803f82da2be3/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2FWparentheses-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dda1bf6123a4e69cb9aa5072442b803f82da2be3/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2FWparentheses-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2FWparentheses-2.c?ref=dda1bf6123a4e69cb9aa5072442b803f82da2be3", "patch": "@@ -0,0 +1,452 @@\n+/* PR c/70436 */\n+/* { dg-additional-options \"-Wparentheses\" } */\n+\n+int a, b, c;\n+void bar (void);\n+void baz (void);\n+void f1 (void);\n+#pragma omp declare target to (bar, baz, f1, a, b, c)\n+\n+void\n+f1 (void)\n+{\n+  int i, j;\n+\n+  if (a) /* { dg-warning \"ambiguous\" } */\n+    #pragma omp distribute\n+    for (i = 0; i < 10; i++)\n+      if (b)\n+\tbar ();\n+      else\n+\tbaz ();\n+\n+  if (a) /* { dg-warning \"ambiguous\" } */\n+    for (i = 0; i < 10; i++)\n+      #pragma omp distribute simd\n+      for (j = 0; j < 10; j++)\n+\tif (b)\n+\t  bar ();\n+  else\n+    baz ();\n+\n+  if (a)\n+    #pragma omp distribute parallel for\n+    for (i = 0; i < 10; i++)\n+      if (b) /* { dg-warning \"ambiguous\" } */\n+\t#pragma omp parallel for\n+\tfor (j = 0; j < 10; j++)\n+\t  if (c)\n+\t    bar ();\n+      else\n+\tbaz ();\n+\n+  if (a) /* { dg-warning \"ambiguous\" } */\n+    #pragma omp distribute parallel for simd collapse(2)\n+    for (i = 0; i < 10; i++)\n+      for (j = 0; j < 10; j++)\n+\tif (b)\n+\t  bar ();\n+\telse\n+\t  baz ();\n+\n+  if (a)\n+    #pragma omp distribute\n+    for (i = 0; i < 10; i++)\n+      {\n+\tif (b)\n+\t  bar ();\n+\telse\n+\t  baz ();\n+      }\n+\n+  if (a)\n+    {\n+      #pragma omp distribute simd\n+      for (i = 0; i < 10; ++i)\n+\tif (b)\n+\t  bar ();\n+    }\n+  else baz ();\n+\n+  if (a)\n+    #pragma omp distribute parallel for collapse(2)\n+    for (i = 0; i < 10; i++)\n+      {\n+\tfor (j = 0; j < 10; j++)\n+\t  if (b)\n+\t    bar ();\n+\t  else\n+\t    baz ();\n+      }\n+\n+  if (a)\n+    for (i = 0; i < 10; i++)\n+      #pragma omp distribute parallel for simd\n+      for (j = 0; j < 10; j++)\n+\t{\n+\t  if (b)\n+\t    bar ();\n+\t}\n+  else\n+    baz ();\n+}\n+\n+void\n+f2 (void)\n+{\n+  int i, j;\n+\n+  if (a) /* { dg-warning \"ambiguous\" } */\n+    #pragma omp target teams distribute\n+    for (i = 0; i < 10; i++)\n+      if (b)\n+\tbar ();\n+      else\n+\tbaz ();\n+\n+  if (a) /* { dg-warning \"ambiguous\" } */\n+    for (i = 0; i < 10; i++)\n+      #pragma omp target teams distribute simd\n+      for (j = 0; j < 10; j++)\n+\tif (b)\n+\t  bar ();\n+  else\n+    baz ();\n+\n+  if (a)\n+    #pragma omp target teams distribute parallel for\n+    for (i = 0; i < 10; i++)\n+      if (b) /* { dg-warning \"ambiguous\" } */\n+\t#pragma omp parallel for\n+\tfor (j = 0; j < 10; j++)\n+\t  if (c)\n+\t    bar ();\n+      else\n+\tbaz ();\n+\n+  if (a) /* { dg-warning \"ambiguous\" } */\n+    #pragma omp target teams distribute parallel for simd collapse(2)\n+    for (i = 0; i < 10; i++)\n+      for (j = 0; j < 10; j++)\n+\tif (b)\n+\t  bar ();\n+\telse\n+\t  baz ();\n+\n+  if (a) /* { dg-warning \"ambiguous\" } */\n+    #pragma omp target teams\n+      if (b)\n+\tbar ();\n+      else\n+\tbaz ();\n+\n+  if (a) /* { dg-warning \"ambiguous\" } */\n+    #pragma omp target\n+    #pragma omp parallel\n+      if (b)\n+\tbar ();\n+      else\n+\tbaz ();\n+\n+  if (a) /* { dg-warning \"ambiguous\" } */\n+    #pragma omp target\n+      if (b)\n+\tbar ();\n+      else\n+\tbaz ();\n+\n+  if (a) /* { dg-warning \"ambiguous\" } */\n+    #pragma omp target parallel\n+      if (b)\n+\tbar ();\n+      else\n+\tbaz ();\n+\n+  if (a) /* { dg-warning \"ambiguous\" } */\n+    #pragma omp target simd\n+      for (i = 0; i < 10; i++)\n+\tif (b)\n+\t  bar ();\n+\telse\n+\t  baz ();\n+\n+  if (a) /* { dg-warning \"ambiguous\" } */\n+    #pragma omp target simd collapse(2)\n+      for (i = 0; i < 10; i++)\n+\tfor (j = 0; j < 10; j++)\n+\t  if (b)\n+\t    bar ();\n+\t  else\n+\t    baz ();\n+\n+  if (a)\n+    #pragma omp target teams distribute\n+    for (i = 0; i < 10; i++)\n+      {\n+\tif (b)\n+\t  bar ();\n+\telse\n+\t  baz ();\n+      }\n+\n+  if (a)\n+    {\n+      #pragma omp target teams distribute simd\n+      for (i = 0; i < 10; ++i)\n+\tif (b)\n+\t  bar ();\n+    }\n+  else baz ();\n+\n+  if (a)\n+    #pragma omp target teams distribute parallel for collapse(2)\n+    for (i = 0; i < 10; i++)\n+      {\n+\tfor (j = 0; j < 10; j++)\n+\t  if (b)\n+\t    bar ();\n+\t  else\n+\t    baz ();\n+      }\n+\n+  if (a)\n+    for (i = 0; i < 10; i++)\n+      #pragma omp target teams distribute parallel for simd\n+      for (j = 0; j < 10; j++)\n+\t{\n+\t  if (b)\n+\t    bar ();\n+\t}\n+  else\n+    baz ();\n+\n+  if (a)\n+    #pragma omp target teams\n+      {\n+\tif (b)\n+\t  bar ();\n+      }\n+  else\n+    baz ();\n+\n+  if (a)\n+    #pragma omp target\n+    #pragma omp parallel\n+      {\n+\tif (b)\n+\t  bar ();\n+\telse\n+\t  baz ();\n+      }\n+\n+  if (a)\n+    #pragma omp target\n+      {\n+\tif (b)\n+\t  bar ();\n+      }\n+  else\n+    baz ();\n+\n+  if (a)\n+    #pragma omp target parallel\n+      {\n+\tif (b)\n+\t  bar ();\n+      }\n+  else\n+    baz ();\n+\n+  if (a)\n+    #pragma omp target simd\n+      for (i = 0; i < 10; i++)\n+\t{\n+\t  if (b)\n+\t    bar ();\n+\t  else\n+\t    baz ();\n+\t}\n+\n+  if (a)\n+    #pragma omp target simd\n+      for (i = 0; i < 10; i++)\n+\t{\n+\t  if (b)\n+\t    bar ();\n+\t}\n+  else\n+    baz ();\n+\n+  if (a)\n+    #pragma omp target simd collapse(2)\n+      for (i = 0; i < 10; i++)\n+\t{ {\n+\t  for (j = 0; j < 10; j++)\n+\t    if (b)\n+\t      bar ();\n+\t    else\n+\t      baz ();\n+\t} }\n+\n+  if (a)\n+    #pragma omp target simd collapse(2)\n+      for (i = 0; i < 10; i++)\n+\t{ {\n+\t  for (j = 0; j < 10; j++)\n+\t    if (b)\n+\t      bar ();\n+\t  }\n+\t}\n+  else\n+    baz ();\n+}\n+\n+void\n+f3 (void)\n+{\n+  int i, j;\n+\n+  if (a) /* { dg-warning \"ambiguous\" } */\n+    #pragma omp target\n+    #pragma omp teams distribute\n+    for (i = 0; i < 10; i++)\n+      if (b)\n+\tbar ();\n+      else\n+\tbaz ();\n+\n+  if (a) /* { dg-warning \"ambiguous\" } */\n+    for (i = 0; i < 10; i++)\n+      #pragma omp target\n+      #pragma omp teams distribute simd\n+      for (j = 0; j < 10; j++)\n+\tif (b)\n+\t  bar ();\n+  else\n+    baz ();\n+\n+  if (a)\n+    #pragma omp target\n+    #pragma omp teams distribute parallel for\n+    for (i = 0; i < 10; i++)\n+      if (b) /* { dg-warning \"ambiguous\" } */\n+\t#pragma omp parallel for\n+\tfor (j = 0; j < 10; j++)\n+\t  if (c)\n+\t    bar ();\n+      else\n+\tbaz ();\n+\n+  if (a) /* { dg-warning \"ambiguous\" } */\n+    #pragma omp target\n+    #pragma omp teams distribute parallel for simd collapse(2)\n+    for (i = 0; i < 10; i++)\n+      for (j = 0; j < 10; j++)\n+\tif (b)\n+\t  bar ();\n+\telse\n+\t  baz ();\n+\n+  if (a) /* { dg-warning \"ambiguous\" } */\n+    #pragma omp target\n+    #pragma omp teams\n+      if (b)\n+\tbar ();\n+      else\n+\tbaz ();\n+\n+  if (a) /* { dg-warning \"ambiguous\" } */\n+    #pragma omp target\n+    #pragma omp teams\n+    #pragma omp parallel\n+      if (b)\n+\tbar ();\n+      else\n+\tbaz ();\n+\n+  if (a)\n+    #pragma omp target\n+    #pragma omp teams distribute\n+    for (i = 0; i < 10; i++)\n+      {\n+\tif (b)\n+\t  bar ();\n+\telse\n+\t  baz ();\n+      }\n+\n+  if (a)\n+    {\n+      #pragma omp target\n+      #pragma omp teams distribute simd\n+      for (i = 0; i < 10; ++i)\n+\tif (b)\n+\t  bar ();\n+    }\n+  else baz ();\n+\n+  if (a)\n+    #pragma omp target\n+    #pragma omp teams distribute parallel for collapse(2)\n+    for (i = 0; i < 10; i++)\n+      {\n+\tfor (j = 0; j < 10; j++)\n+\t  if (b)\n+\t    bar ();\n+\t  else\n+\t    baz ();\n+      }\n+\n+  if (a)\n+    for (i = 0; i < 10; i++)\n+      #pragma omp target\n+      #pragma omp teams distribute parallel for simd\n+      for (j = 0; j < 10; j++)\n+\t{\n+\t  if (b)\n+\t    bar ();\n+\t}\n+  else\n+    baz ();\n+\n+  if (a)\n+    #pragma omp target\n+    #pragma omp teams\n+      {\n+\tif (b)\n+\t  bar ();\n+      }\n+  else\n+    baz ();\n+\n+  if (a)\n+    #pragma omp target\n+    #pragma omp teams\n+    #pragma omp parallel\n+      {\n+\tif (b)\n+\t  bar ();\n+\telse\n+\t  baz ();\n+      }\n+}\n+\n+void\n+f4 (void)\n+{\n+  if (a) /* { dg-warning \"ambiguous\" } */\n+    #pragma omp target data map (tofrom: b)\n+      if (b)\n+\tbar ();\n+      else\n+\tbaz ();\n+\n+  if (a)\n+    #pragma omp target data map (tofrom: b)\n+      {\n+\tif (b)\n+\t  bar ();\n+\telse\n+\t  baz ();\n+      }\n+}"}, {"sha": "1688d1062d4da6e956d836c5672324cb9f354f96", "filename": "gcc/testsuite/c-c++-common/gomp/Wparentheses-3.c", "status": "added", "additions": 338, "deletions": 0, "changes": 338, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dda1bf6123a4e69cb9aa5072442b803f82da2be3/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2FWparentheses-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dda1bf6123a4e69cb9aa5072442b803f82da2be3/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2FWparentheses-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2FWparentheses-3.c?ref=dda1bf6123a4e69cb9aa5072442b803f82da2be3", "patch": "@@ -0,0 +1,338 @@\n+/* PR c/70436 */\n+/* { dg-additional-options \"-Wparentheses -fno-openmp\" } */\n+\n+int a, b, c;\n+void bar (void);\n+void baz (void);\n+\n+void\n+f1 (void)\n+{\n+  int i, j;\n+\n+  if (a) /* { dg-warning \"ambiguous\" } */\n+    #pragma omp for\n+    for (i = 0; i < 10; i++)\n+      if (b)\n+\tbar ();\n+      else\n+\tbaz ();\n+\n+  if (a) /* { dg-warning \"ambiguous\" } */\n+    while (1)\n+      #pragma omp for\n+      for (i = 0; i < 10; i++)\n+\tif (b)\n+\t  bar ();\n+\telse\n+\t  baz ();\n+\n+  if (a) /* { dg-warning \"ambiguous\" } */\n+    for (i = 0; i < 10; i++)\n+      #pragma omp for\n+      for (j = 0; j < 10; j++)\n+\tif (b)\n+\t  bar ();\n+  else\n+    baz ();\n+\n+  if (a)\n+    #pragma omp for\n+    for (i = 0; i < 10; i++)\n+      if (b) /* { dg-warning \"ambiguous\" } */\n+\t#pragma omp parallel for\n+\tfor (j = 0; j < 10; j++)\n+\t  if (c)\n+\t    bar ();\n+      else\n+\tbaz ();\n+\n+  if (a) /* { dg-warning \"ambiguous\" } */\n+    #pragma omp taskloop\n+    for (i = 0; i < 10; i++)\n+      if (b)\n+\t#pragma omp parallel for\n+\tfor (j = 0; j < 10; j++)\n+\t  if (c)\n+\t    bar ();\n+\t  else\n+\t    baz ();\n+  else\n+    bar ();\n+\n+  if (a) /* { dg-warning \"ambiguous\" } */\n+    #pragma omp taskloop simd\n+    for (i = 0; i < 10; i++)\n+      if (b)\n+\tbar ();\n+      else\n+\tbaz ();\n+\n+  if (a) /* { dg-warning \"ambiguous\" } */\n+    #pragma omp for collapse(2)\n+    for (i = 0; i < 10; i++)\n+      for (j = 0; j < 10; j++)\n+\tif (b)\n+\t  bar ();\n+\telse\n+\t  baz ();\n+\n+  if (a) /* { dg-warning \"ambiguous\" } */\n+    #pragma omp critical\n+      if (b)\n+\tbar ();\n+      else\n+\tbaz ();\n+\n+  if (a) /* { dg-warning \"ambiguous\" } */\n+    for (i = 0; i < 10; i++)\n+      #pragma omp simd\n+      for (j = 0; j < 10; j++)\n+\tif (b)\n+\t  bar ();\n+  else\n+    baz ();\n+\n+  if (a) /* { dg-warning \"ambiguous\" } */\n+    #pragma omp for simd schedule(runtime)\n+    for (i = 0; i < 10; i++)\n+      if (b)\n+\tbar ();\n+      else\n+\tbaz ();\n+\n+  if (a) /* { dg-warning \"ambiguous\" } */\n+    #pragma omp master\n+      if (b)\n+\tbar ();\n+      else\n+\tbaz ();\n+\n+  if (a) /* { dg-warning \"ambiguous\" } */\n+    #pragma omp parallel\n+      if (b)\n+\tbar ();\n+      else\n+\tbaz ();\n+\n+  if (a) /* { dg-warning \"ambiguous\" } */\n+    for (i = 0; i < 10; i++)\n+      #pragma omp parallel for\n+      for (j = 0; j < 10; j++)\n+\tif (b)\n+\t  bar ();\n+  else\n+    baz ();\n+\n+  if (a) /* { dg-warning \"ambiguous\" } */\n+    for (i = 0; i < 10; i++)\n+      #pragma omp parallel for simd\n+      for (j = 0; j < 10; j++)\n+\tif (b)\n+\t  bar ();\n+  else\n+    baz ();\n+\n+  if (a) /* { dg-warning \"ambiguous\" } */\n+    #pragma omp single\n+      if (b)\n+\tbar ();\n+      else\n+\tbaz ();\n+\n+  if (a) /* { dg-warning \"ambiguous\" } */\n+    #pragma omp task\n+      if (b)\n+\tbar ();\n+      else\n+\tbaz ();\n+\n+  if (a) /* { dg-warning \"ambiguous\" } */\n+    #pragma omp taskgroup\n+      if (b)\n+\tbar ();\n+      else\n+\tbaz ();\n+\n+  if (a)\n+    #pragma omp for\n+    for (i = 0; i < 10; i++)\n+      {\n+\tif (b)\n+\t  bar ();\n+\telse\n+\t  baz ();\n+      }\n+\n+  if (a)\n+    {\n+      #pragma omp taskloop\n+      for (i = 0; i < 10; ++i)\n+\tif (b)\n+\t  bar ();\n+    }\n+  else baz ();\n+\n+  if (a)\n+    #pragma omp for collapse(2)\n+    for (i = 0; i < 10; i++)\n+      {\n+\tfor (j = 0; j < 10; j++)\n+\t  if (b)\n+\t    bar ();\n+\t  else\n+\t    baz ();\n+      }\n+\n+  if (a)\n+    #pragma omp critical\n+      {\n+\tif (b)\n+\t  bar ();\n+\telse\n+\t  baz ();\n+      }\n+\n+  if (a)\n+    for (i = 0; i < 10; i++)\n+      #pragma omp simd\n+      for (j = 0; j < 10; j++)\n+\t{\n+\t  if (b)\n+\t    bar ();\n+\t}\n+  else\n+    baz ();\n+\n+  if (a)\n+    #pragma omp for simd schedule(dynamic, 5)\n+    for (i = 0; i < 10; i++)\n+      {\n+\tif (b)\n+\t  bar ();\n+\telse\n+\t  baz ();\n+      }\n+\n+  if (a)\n+    #pragma omp master\n+      {\n+\tif (b)\n+\t  bar ();\n+\telse\n+\t  baz ();\n+      }\n+\n+  if (a)\n+    #pragma omp parallel\n+      {\n+\tif (b)\n+\t  bar ();\n+\telse\n+\t  baz ();\n+      }\n+\n+  if (a)\n+    {\n+      #pragma omp parallel\n+\tif (b)\n+\t  bar ();\n+\telse\n+\t  baz ();\n+    }\n+\n+  if (a)\n+    for (i = 0; i < 10; i++)\n+      #pragma omp parallel for\n+      for (j = 0; j < 10; j++)\n+\t{\n+\t  if (b)\n+\t    bar ();\n+\t}\n+  else\n+    baz ();\n+\n+  if (a)\n+    for (i = 0; i < 10; i++)\n+      #pragma omp parallel for simd\n+      for (j = 0; j < 10; j++)\n+\t{\n+\t  if (b)\n+\t    bar ();\n+\t}\n+  else\n+    baz ();\n+\n+  if (a)\n+    #pragma omp single\n+      {\n+\tif (b)\n+\t  bar ();\n+      }\n+  else\n+    baz ();\n+\n+  if (a)\n+    #pragma omp task\n+      {\n+\tif (b)\n+\t  bar ();\n+      }\n+  else\n+    baz ();\n+\n+  if (a)\n+    #pragma omp taskgroup\n+      {\n+\tif (b)\n+\t  bar ();\n+\telse\n+\t  baz ();\n+      }\n+\n+  if (a)\n+    #pragma omp taskloop simd\n+    for (i = 0; i < 10; i++)\n+      {\n+\tif (b)\n+\t  bar ();\n+\telse\n+\t  baz ();\n+      }\n+}\n+\n+void\n+f2 (int d, int e, int f)\n+{\n+  if (a) /* { dg-warning \"ambiguous\" } */\n+    #pragma omp ordered\n+      if (b)\n+\tbar ();\n+      else\n+\tbaz ();\n+\n+  if (d) /* { dg-warning \"ambiguous\" } */\n+    #pragma omp ordered threads\n+      if (b)\n+\tbar ();\n+      else\n+\tbaz ();\n+\n+  if (e)\n+    #pragma omp ordered\n+      {\n+\tif (b)\n+\t  bar ();\n+\telse\n+\t  baz ();\n+      }\n+\n+  if (f)\n+    #pragma omp ordered threads\n+      {\n+\tif (b)\n+\t  bar ();\n+\telse\n+\t  baz ();\n+      }\n+}"}, {"sha": "d44cdcd5756275367b50abe930326a2d8df4d427", "filename": "gcc/testsuite/c-c++-common/gomp/Wparentheses-4.c", "status": "added", "additions": 452, "deletions": 0, "changes": 452, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dda1bf6123a4e69cb9aa5072442b803f82da2be3/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2FWparentheses-4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dda1bf6123a4e69cb9aa5072442b803f82da2be3/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2FWparentheses-4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2FWparentheses-4.c?ref=dda1bf6123a4e69cb9aa5072442b803f82da2be3", "patch": "@@ -0,0 +1,452 @@\n+/* PR c/70436 */\n+/* { dg-additional-options \"-Wparentheses -fno-openmp\" } */\n+\n+int a, b, c;\n+void bar (void);\n+void baz (void);\n+void f1 (void);\n+#pragma omp declare target to (bar, baz, f1, a, b, c)\n+\n+void\n+f1 (void)\n+{\n+  int i, j;\n+\n+  if (a) /* { dg-warning \"ambiguous\" } */\n+    #pragma omp distribute\n+    for (i = 0; i < 10; i++)\n+      if (b)\n+\tbar ();\n+      else\n+\tbaz ();\n+\n+  if (a) /* { dg-warning \"ambiguous\" } */\n+    for (i = 0; i < 10; i++)\n+      #pragma omp distribute simd\n+      for (j = 0; j < 10; j++)\n+\tif (b)\n+\t  bar ();\n+  else\n+    baz ();\n+\n+  if (a)\n+    #pragma omp distribute parallel for\n+    for (i = 0; i < 10; i++)\n+      if (b) /* { dg-warning \"ambiguous\" } */\n+\t#pragma omp parallel for\n+\tfor (j = 0; j < 10; j++)\n+\t  if (c)\n+\t    bar ();\n+      else\n+\tbaz ();\n+\n+  if (a) /* { dg-warning \"ambiguous\" } */\n+    #pragma omp distribute parallel for simd collapse(2)\n+    for (i = 0; i < 10; i++)\n+      for (j = 0; j < 10; j++)\n+\tif (b)\n+\t  bar ();\n+\telse\n+\t  baz ();\n+\n+  if (a)\n+    #pragma omp distribute\n+    for (i = 0; i < 10; i++)\n+      {\n+\tif (b)\n+\t  bar ();\n+\telse\n+\t  baz ();\n+      }\n+\n+  if (a)\n+    {\n+      #pragma omp distribute simd\n+      for (i = 0; i < 10; ++i)\n+\tif (b)\n+\t  bar ();\n+    }\n+  else baz ();\n+\n+  if (a)\n+    #pragma omp distribute parallel for collapse(2)\n+    for (i = 0; i < 10; i++)\n+      {\n+\tfor (j = 0; j < 10; j++)\n+\t  if (b)\n+\t    bar ();\n+\t  else\n+\t    baz ();\n+      }\n+\n+  if (a)\n+    for (i = 0; i < 10; i++)\n+      #pragma omp distribute parallel for simd\n+      for (j = 0; j < 10; j++)\n+\t{\n+\t  if (b)\n+\t    bar ();\n+\t}\n+  else\n+    baz ();\n+}\n+\n+void\n+f2 (void)\n+{\n+  int i, j;\n+\n+  if (a) /* { dg-warning \"ambiguous\" } */\n+    #pragma omp target teams distribute\n+    for (i = 0; i < 10; i++)\n+      if (b)\n+\tbar ();\n+      else\n+\tbaz ();\n+\n+  if (a) /* { dg-warning \"ambiguous\" } */\n+    for (i = 0; i < 10; i++)\n+      #pragma omp target teams distribute simd\n+      for (j = 0; j < 10; j++)\n+\tif (b)\n+\t  bar ();\n+  else\n+    baz ();\n+\n+  if (a)\n+    #pragma omp target teams distribute parallel for\n+    for (i = 0; i < 10; i++)\n+      if (b) /* { dg-warning \"ambiguous\" } */\n+\t#pragma omp parallel for\n+\tfor (j = 0; j < 10; j++)\n+\t  if (c)\n+\t    bar ();\n+      else\n+\tbaz ();\n+\n+  if (a) /* { dg-warning \"ambiguous\" } */\n+    #pragma omp target teams distribute parallel for simd collapse(2)\n+    for (i = 0; i < 10; i++)\n+      for (j = 0; j < 10; j++)\n+\tif (b)\n+\t  bar ();\n+\telse\n+\t  baz ();\n+\n+  if (a) /* { dg-warning \"ambiguous\" } */\n+    #pragma omp target teams\n+      if (b)\n+\tbar ();\n+      else\n+\tbaz ();\n+\n+  if (a) /* { dg-warning \"ambiguous\" } */\n+    #pragma omp target\n+    #pragma omp parallel\n+      if (b)\n+\tbar ();\n+      else\n+\tbaz ();\n+\n+  if (a) /* { dg-warning \"ambiguous\" } */\n+    #pragma omp target\n+      if (b)\n+\tbar ();\n+      else\n+\tbaz ();\n+\n+  if (a) /* { dg-warning \"ambiguous\" } */\n+    #pragma omp target parallel\n+      if (b)\n+\tbar ();\n+      else\n+\tbaz ();\n+\n+  if (a) /* { dg-warning \"ambiguous\" } */\n+    #pragma omp target simd\n+      for (i = 0; i < 10; i++)\n+\tif (b)\n+\t  bar ();\n+\telse\n+\t  baz ();\n+\n+  if (a) /* { dg-warning \"ambiguous\" } */\n+    #pragma omp target simd collapse(2)\n+      for (i = 0; i < 10; i++)\n+\tfor (j = 0; j < 10; j++)\n+\t  if (b)\n+\t    bar ();\n+\t  else\n+\t    baz ();\n+\n+  if (a)\n+    #pragma omp target teams distribute\n+    for (i = 0; i < 10; i++)\n+      {\n+\tif (b)\n+\t  bar ();\n+\telse\n+\t  baz ();\n+      }\n+\n+  if (a)\n+    {\n+      #pragma omp target teams distribute simd\n+      for (i = 0; i < 10; ++i)\n+\tif (b)\n+\t  bar ();\n+    }\n+  else baz ();\n+\n+  if (a)\n+    #pragma omp target teams distribute parallel for collapse(2)\n+    for (i = 0; i < 10; i++)\n+      {\n+\tfor (j = 0; j < 10; j++)\n+\t  if (b)\n+\t    bar ();\n+\t  else\n+\t    baz ();\n+      }\n+\n+  if (a)\n+    for (i = 0; i < 10; i++)\n+      #pragma omp target teams distribute parallel for simd\n+      for (j = 0; j < 10; j++)\n+\t{\n+\t  if (b)\n+\t    bar ();\n+\t}\n+  else\n+    baz ();\n+\n+  if (a)\n+    #pragma omp target teams\n+      {\n+\tif (b)\n+\t  bar ();\n+      }\n+  else\n+    baz ();\n+\n+  if (a)\n+    #pragma omp target\n+    #pragma omp parallel\n+      {\n+\tif (b)\n+\t  bar ();\n+\telse\n+\t  baz ();\n+      }\n+\n+  if (a)\n+    #pragma omp target\n+      {\n+\tif (b)\n+\t  bar ();\n+      }\n+  else\n+    baz ();\n+\n+  if (a)\n+    #pragma omp target parallel\n+      {\n+\tif (b)\n+\t  bar ();\n+      }\n+  else\n+    baz ();\n+\n+  if (a)\n+    #pragma omp target simd\n+      for (i = 0; i < 10; i++)\n+\t{\n+\t  if (b)\n+\t    bar ();\n+\t  else\n+\t    baz ();\n+\t}\n+\n+  if (a)\n+    #pragma omp target simd\n+      for (i = 0; i < 10; i++)\n+\t{\n+\t  if (b)\n+\t    bar ();\n+\t}\n+  else\n+    baz ();\n+\n+  if (a)\n+    #pragma omp target simd collapse(2)\n+      for (i = 0; i < 10; i++)\n+\t{ {\n+\t  for (j = 0; j < 10; j++)\n+\t    if (b)\n+\t      bar ();\n+\t    else\n+\t      baz ();\n+\t} }\n+\n+  if (a)\n+    #pragma omp target simd collapse(2)\n+      for (i = 0; i < 10; i++)\n+\t{ {\n+\t  for (j = 0; j < 10; j++)\n+\t    if (b)\n+\t      bar ();\n+\t  }\n+\t}\n+  else\n+    baz ();\n+}\n+\n+void\n+f3 (void)\n+{\n+  int i, j;\n+\n+  if (a) /* { dg-warning \"ambiguous\" } */\n+    #pragma omp target\n+    #pragma omp teams distribute\n+    for (i = 0; i < 10; i++)\n+      if (b)\n+\tbar ();\n+      else\n+\tbaz ();\n+\n+  if (a) /* { dg-warning \"ambiguous\" } */\n+    for (i = 0; i < 10; i++)\n+      #pragma omp target\n+      #pragma omp teams distribute simd\n+      for (j = 0; j < 10; j++)\n+\tif (b)\n+\t  bar ();\n+  else\n+    baz ();\n+\n+  if (a)\n+    #pragma omp target\n+    #pragma omp teams distribute parallel for\n+    for (i = 0; i < 10; i++)\n+      if (b) /* { dg-warning \"ambiguous\" } */\n+\t#pragma omp parallel for\n+\tfor (j = 0; j < 10; j++)\n+\t  if (c)\n+\t    bar ();\n+      else\n+\tbaz ();\n+\n+  if (a) /* { dg-warning \"ambiguous\" } */\n+    #pragma omp target\n+    #pragma omp teams distribute parallel for simd collapse(2)\n+    for (i = 0; i < 10; i++)\n+      for (j = 0; j < 10; j++)\n+\tif (b)\n+\t  bar ();\n+\telse\n+\t  baz ();\n+\n+  if (a) /* { dg-warning \"ambiguous\" } */\n+    #pragma omp target\n+    #pragma omp teams\n+      if (b)\n+\tbar ();\n+      else\n+\tbaz ();\n+\n+  if (a) /* { dg-warning \"ambiguous\" } */\n+    #pragma omp target\n+    #pragma omp teams\n+    #pragma omp parallel\n+      if (b)\n+\tbar ();\n+      else\n+\tbaz ();\n+\n+  if (a)\n+    #pragma omp target\n+    #pragma omp teams distribute\n+    for (i = 0; i < 10; i++)\n+      {\n+\tif (b)\n+\t  bar ();\n+\telse\n+\t  baz ();\n+      }\n+\n+  if (a)\n+    {\n+      #pragma omp target\n+      #pragma omp teams distribute simd\n+      for (i = 0; i < 10; ++i)\n+\tif (b)\n+\t  bar ();\n+    }\n+  else baz ();\n+\n+  if (a)\n+    #pragma omp target\n+    #pragma omp teams distribute parallel for collapse(2)\n+    for (i = 0; i < 10; i++)\n+      {\n+\tfor (j = 0; j < 10; j++)\n+\t  if (b)\n+\t    bar ();\n+\t  else\n+\t    baz ();\n+      }\n+\n+  if (a)\n+    for (i = 0; i < 10; i++)\n+      #pragma omp target\n+      #pragma omp teams distribute parallel for simd\n+      for (j = 0; j < 10; j++)\n+\t{\n+\t  if (b)\n+\t    bar ();\n+\t}\n+  else\n+    baz ();\n+\n+  if (a)\n+    #pragma omp target\n+    #pragma omp teams\n+      {\n+\tif (b)\n+\t  bar ();\n+      }\n+  else\n+    baz ();\n+\n+  if (a)\n+    #pragma omp target\n+    #pragma omp teams\n+    #pragma omp parallel\n+      {\n+\tif (b)\n+\t  bar ();\n+\telse\n+\t  baz ();\n+      }\n+}\n+\n+void\n+f4 (void)\n+{\n+  if (a) /* { dg-warning \"ambiguous\" } */\n+    #pragma omp target data map (tofrom: b)\n+      if (b)\n+\tbar ();\n+      else\n+\tbaz ();\n+\n+  if (a)\n+    #pragma omp target data map (tofrom: b)\n+      {\n+\tif (b)\n+\t  bar ();\n+\telse\n+\t  baz ();\n+      }\n+}"}]}