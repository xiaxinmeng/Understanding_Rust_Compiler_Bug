{"sha": "fa79946ef552152e732152ad7ffd127922ac9a60", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZmE3OTk0NmVmNTUyMTUyZTczMjE1MmFkN2ZmZDEyNzkyMmFjOWE2MA==", "commit": {"author": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2001-02-14T21:16:35Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2001-02-14T21:16:35Z"}, "message": "i386-protos.h (ix86_memory_move_cost): Move offline.\n\n\t* i386-protos.h (ix86_memory_move_cost): Move offline.\n\t* i386.c (ix86_register_move_cost): Compute properly cost of\n\tSSE, MMX and i387 instructions.\n\t(*_cost): Add costs of SSE/MMX moves.\n\t(ix86_memory_move_cost): Move offline from ....; Likewise.\n\t* i386.h (MEMORY_MOVE_COST): .... here;\n\t(struct processor costs): Add new fields to represent costs\n\tof SSE/MMX moves.\n\nFrom-SVN: r39689", "tree": {"sha": "50f6669a210386b4c272ed2036c5330206d8a126", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/50f6669a210386b4c272ed2036c5330206d8a126"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/fa79946ef552152e732152ad7ffd127922ac9a60", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fa79946ef552152e732152ad7ffd127922ac9a60", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fa79946ef552152e732152ad7ffd127922ac9a60", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fa79946ef552152e732152ad7ffd127922ac9a60/comments", "author": null, "committer": null, "parents": [{"sha": "6836e0240ee7235a72c236ed8fa688759ec15e47", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6836e0240ee7235a72c236ed8fa688759ec15e47", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6836e0240ee7235a72c236ed8fa688759ec15e47"}], "stats": {"total": 228, "additions": 200, "deletions": 28}, "files": [{"sha": "f7bb9a03019cb314fbae220263596bd5a7a37cbd", "filename": "gcc/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fa79946ef552152e732152ad7ffd127922ac9a60/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fa79946ef552152e732152ad7ffd127922ac9a60/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=fa79946ef552152e732152ad7ffd127922ac9a60", "patch": "@@ -1,3 +1,14 @@\n+Wed Feb 14 11:12:38 CET 2001  Jan Hubicka  <jh@suse.cz>\n+\n+\t* i386-protos.h (ix86_memory_move_cost): Move offline.\n+\t* i386.c (ix86_register_move_cost): Compute properly cost of\n+\tSSE, MMX and i387 instructions.\n+\t(*_cost): Add costs of SSE/MMX moves.\n+\t(ix86_memory_move_cost): Move offline from ....; Likewise.\n+\t* i386.h (MEMORY_MOVE_COST): .... here;\n+\t(struct processor costs): Add new fields to represent costs\n+\tof SSE/MMX moves.\n+\n Wed Feb 14 10:08:26 CET 2001  Jan Hubicka  <jh@suse.cz>\n \n \t* regclass.c (init_reg_sets_1): Reinstall the optimization of"}, {"sha": "0e0a520289d2ebbc9d93e767110a5b277858bf94", "filename": "gcc/config/i386/i386-protos.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fa79946ef552152e732152ad7ffd127922ac9a60/gcc%2Fconfig%2Fi386%2Fi386-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fa79946ef552152e732152ad7ffd127922ac9a60/gcc%2Fconfig%2Fi386%2Fi386-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386-protos.h?ref=fa79946ef552152e732152ad7ffd127922ac9a60", "patch": "@@ -139,6 +139,8 @@ extern int ix86_secondary_memory_needed PARAMS ((enum reg_class,\n \t\t\t\t\t\t enum machine_mode, int));\n extern enum reg_class ix86_preferred_reload_class PARAMS ((rtx,\n \t\t\t\t\t\t\t   enum reg_class));\n+extern int ix86_memory_move_cost PARAMS ((enum machine_mode, enum reg_class,\n+\t\t\t\t\t  int));\n \n #ifdef TREE_CODE\n extern void init_cumulative_args PARAMS ((CUMULATIVE_ARGS *, tree, rtx));"}, {"sha": "222dbf796a594f048130c16f8f9af32d4e988552", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 172, "deletions": 7, "changes": 179, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fa79946ef552152e732152ad7ffd127922ac9a60/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fa79946ef552152e732152ad7ffd127922ac9a60/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=fa79946ef552152e732152ad7ffd127922ac9a60", "patch": "@@ -65,7 +65,18 @@ struct processor_costs i386_cost = {\t/* 386 specific costs */\n   2,\t\t\t\t\t/* cost of reg,reg fld/fst */\n   {8, 8, 8},\t\t\t\t/* cost of loading fp registers\n \t\t\t\t\t   in SFmode, DFmode and XFmode */\n-  {8, 8, 8}\t\t\t\t/* cost of loading integer registers */\n+  {8, 8, 8},\t\t\t\t/* cost of loading integer registers */\n+  2,\t\t\t\t\t/* cost of moving MMX register */\n+  {4, 8},\t\t\t\t/* cost of loading MMX registers\n+\t\t\t\t\t   in SImode and DImode */\n+  {4, 8},\t\t\t\t/* cost of storing MMX registers\n+\t\t\t\t\t   in SImode and DImode */\n+  2,\t\t\t\t\t/* cost of moving SSE register */\n+  {4, 8, 16},\t\t\t\t/* cost of loading SSE registers\n+\t\t\t\t\t   in SImode, DImode and TImode */\n+  {4, 8, 16},\t\t\t\t/* cost of storing SSE registers\n+\t\t\t\t\t   in SImode, DImode and TImode */\n+  3,\t\t\t\t\t/* MMX or SSE register to integer */\n };\n \n struct processor_costs i486_cost = {\t/* 486 specific costs */\n@@ -86,7 +97,18 @@ struct processor_costs i486_cost = {\t/* 486 specific costs */\n   2,\t\t\t\t\t/* cost of reg,reg fld/fst */\n   {8, 8, 8},\t\t\t\t/* cost of loading fp registers\n \t\t\t\t\t   in SFmode, DFmode and XFmode */\n-  {8, 8, 8}\t\t\t\t/* cost of loading integer registers */\n+  {8, 8, 8},\t\t\t\t/* cost of loading integer registers */\n+  2,\t\t\t\t\t/* cost of moving MMX register */\n+  {4, 8},\t\t\t\t/* cost of loading MMX registers\n+\t\t\t\t\t   in SImode and DImode */\n+  {4, 8},\t\t\t\t/* cost of storing MMX registers\n+\t\t\t\t\t   in SImode and DImode */\n+  2,\t\t\t\t\t/* cost of moving SSE register */\n+  {4, 8, 16},\t\t\t\t/* cost of loading SSE registers\n+\t\t\t\t\t   in SImode, DImode and TImode */\n+  {4, 8, 16},\t\t\t\t/* cost of storing SSE registers\n+\t\t\t\t\t   in SImode, DImode and TImode */\n+  3\t\t\t\t\t/* MMX or SSE register to integer */\n };\n \n struct processor_costs pentium_cost = {\n@@ -107,7 +129,18 @@ struct processor_costs pentium_cost = {\n   2,\t\t\t\t\t/* cost of reg,reg fld/fst */\n   {2, 2, 6},\t\t\t\t/* cost of loading fp registers\n \t\t\t\t\t   in SFmode, DFmode and XFmode */\n-  {4, 4, 6}\t\t\t\t/* cost of loading integer registers */\n+  {4, 4, 6},\t\t\t\t/* cost of loading integer registers */\n+  8,\t\t\t\t\t/* cost of moving MMX register */\n+  {8, 8},\t\t\t\t/* cost of loading MMX registers\n+\t\t\t\t\t   in SImode and DImode */\n+  {8, 8},\t\t\t\t/* cost of storing MMX registers\n+\t\t\t\t\t   in SImode and DImode */\n+  2,\t\t\t\t\t/* cost of moving SSE register */\n+  {4, 8, 16},\t\t\t\t/* cost of loading SSE registers\n+\t\t\t\t\t   in SImode, DImode and TImode */\n+  {4, 8, 16},\t\t\t\t/* cost of storing SSE registers\n+\t\t\t\t\t   in SImode, DImode and TImode */\n+  3\t\t\t\t\t/* MMX or SSE register to integer */\n };\n \n struct processor_costs pentiumpro_cost = {\n@@ -128,7 +161,18 @@ struct processor_costs pentiumpro_cost = {\n   2,\t\t\t\t\t/* cost of reg,reg fld/fst */\n   {2, 2, 6},\t\t\t\t/* cost of loading fp registers\n \t\t\t\t\t   in SFmode, DFmode and XFmode */\n-  {4, 4, 6}\t\t\t\t/* cost of loading integer registers */\n+  {4, 4, 6},\t\t\t\t/* cost of loading integer registers */\n+  2,\t\t\t\t\t/* cost of moving MMX register */\n+  {2, 2},\t\t\t\t/* cost of loading MMX registers\n+\t\t\t\t\t   in SImode and DImode */\n+  {2, 2},\t\t\t\t/* cost of storing MMX registers\n+\t\t\t\t\t   in SImode and DImode */\n+  2,\t\t\t\t\t/* cost of moving SSE register */\n+  {2, 2, 8},\t\t\t\t/* cost of loading SSE registers\n+\t\t\t\t\t   in SImode, DImode and TImode */\n+  {2, 2, 8},\t\t\t\t/* cost of storing SSE registers\n+\t\t\t\t\t   in SImode, DImode and TImode */\n+  3\t\t\t\t\t/* MMX or SSE register to integer */\n };\n \n struct processor_costs k6_cost = {\n@@ -149,7 +193,18 @@ struct processor_costs k6_cost = {\n   4,\t\t\t\t\t/* cost of reg,reg fld/fst */\n   {6, 6, 6},\t\t\t\t/* cost of loading fp registers\n \t\t\t\t\t   in SFmode, DFmode and XFmode */\n-  {4, 4, 4}\t\t\t\t/* cost of loading integer registers */\n+  {4, 4, 4},\t\t\t\t/* cost of loading integer registers */\n+  2,\t\t\t\t\t/* cost of moving MMX register */\n+  {2, 2},\t\t\t\t/* cost of loading MMX registers\n+\t\t\t\t\t   in SImode and DImode */\n+  {2, 2},\t\t\t\t/* cost of storing MMX registers\n+\t\t\t\t\t   in SImode and DImode */\n+  2,\t\t\t\t\t/* cost of moving SSE register */\n+  {2, 2, 8},\t\t\t\t/* cost of loading SSE registers\n+\t\t\t\t\t   in SImode, DImode and TImode */\n+  {2, 2, 8},\t\t\t\t/* cost of storing SSE registers\n+\t\t\t\t\t   in SImode, DImode and TImode */\n+  6\t\t\t\t\t/* MMX or SSE register to integer */\n };\n \n struct processor_costs athlon_cost = {\n@@ -170,7 +225,18 @@ struct processor_costs athlon_cost = {\n   4,\t\t\t\t\t/* cost of reg,reg fld/fst */\n   {6, 6, 20},\t\t\t\t/* cost of loading fp registers\n \t\t\t\t\t   in SFmode, DFmode and XFmode */\n-  {4, 4, 16}\t\t\t\t/* cost of loading integer registers */\n+  {4, 4, 16},\t\t\t\t/* cost of loading integer registers */\n+  2,\t\t\t\t\t/* cost of moving MMX register */\n+  {2, 2},\t\t\t\t/* cost of loading MMX registers\n+\t\t\t\t\t   in SImode and DImode */\n+  {2, 2},\t\t\t\t/* cost of storing MMX registers\n+\t\t\t\t\t   in SImode and DImode */\n+  2,\t\t\t\t\t/* cost of moving SSE register */\n+  {2, 2, 8},\t\t\t\t/* cost of loading SSE registers\n+\t\t\t\t\t   in SImode, DImode and TImode */\n+  {2, 2, 8},\t\t\t\t/* cost of storing SSE registers\n+\t\t\t\t\t   in SImode, DImode and TImode */\n+  6\t\t\t\t\t/* MMX or SSE register to integer */\n };\n \n struct processor_costs *ix86_cost = &pentium_cost;\n@@ -8854,7 +8920,13 @@ ix86_register_move_cost (mode, class1, class2)\n      ??? We should make this cost CPU specific.  */\n   if (MMX_CLASS_P (class1) != MMX_CLASS_P (class2)\n       || SSE_CLASS_P (class1) != SSE_CLASS_P (class2))\n-    return 3;\n+    return ix86_cost->mmxsse_to_integer;\n+  if (MAYBE_FLOAT_CLASS_P (class1))\n+    return ix86_cost->fp_move;\n+  if (MAYBE_SSE_CLASS_P (class1))\n+    return ix86_cost->sse_move;\n+  if (MAYBE_MMX_CLASS_P (class1))\n+    return ix86_cost->mmx_move;\n   return 2;\n }\n \n@@ -8887,3 +8959,96 @@ ix86_hard_regno_mode_ok (regno, mode)\n     return 1;\n   return reload_in_progress || reload_completed || !TARGET_PARTIAL_REG_STALL;\n }\n+\n+/* Return the cost of moving data of mode M between a\n+   register and memory.  A value of 2 is the default; this cost is\n+   relative to those in `REGISTER_MOVE_COST'.\n+\n+   If moving between registers and memory is more expensive than\n+   between two registers, you should define this macro to express the\n+   relative cost.  \n+ \n+   Model also increased moving costs of QImode registers in non\n+   Q_REGS classes.\n+ */\n+int\n+ix86_memory_move_cost (mode, class, in)\n+     enum machine_mode mode;\n+     enum reg_class class;\n+     int in;\n+{\n+  if (FLOAT_CLASS_P (class))\n+    {\n+      int index;\n+      switch (mode)\n+\t{\n+\t  case SFmode:\n+\t    index = 0;\n+\t    break;\n+\t  case DFmode:\n+\t    index = 1;\n+\t    break;\n+\t  case XFmode:\n+\t  case TFmode:\n+\t    index = 2;\n+\t    break;\n+\t  default:\n+\t    return 100;\n+\t}\n+      return in ? ix86_cost->fp_load [index] : ix86_cost->fp_store [index];\n+    }\n+  if (SSE_CLASS_P (class))\n+    {\n+      int index;\n+      switch (GET_MODE_SIZE (mode))\n+\t{\n+\t  case 4:\n+\t    index = 0;\n+\t    break;\n+\t  case 8:\n+\t    index = 1;\n+\t    break;\n+\t  case 16:\n+\t    index = 2;\n+\t    break;\n+\t  default:\n+\t    return 100;\n+\t}\n+      return in ? ix86_cost->sse_load [index] : ix86_cost->sse_store [index];\n+    }\n+  if (MMX_CLASS_P (class))\n+    {\n+      int index;\n+      switch (GET_MODE_SIZE (mode))\n+\t{\n+\t  case 4:\n+\t    index = 0;\n+\t    break;\n+\t  case 8:\n+\t    index = 1;\n+\t    break;\n+\t  default:\n+\t    return 100;\n+\t}\n+      return in ? ix86_cost->mmx_load [index] : ix86_cost->mmx_store [index];\n+    }\n+  switch (GET_MODE_SIZE (mode))\n+    {\n+      case 1:\n+\tif (in)\n+\t  return (Q_CLASS_P (class) ? ix86_cost->int_load[0]\n+\t\t  : ix86_cost->movzbl_load);\n+\telse\n+\t  return (Q_CLASS_P (class) ? ix86_cost->int_store[0]\n+\t\t  : ix86_cost->int_store[0] + 4);\n+\tbreak;\n+      case 2:\n+\treturn in ? ix86_cost->int_load[1] : ix86_cost->int_store[1];\n+      default:\n+\t/* Compute number of 32bit moves needed.  TFmode is moved as XFmode.  */\n+\tif (mode == TFmode)\n+\t  mode = XFmode;\n+\treturn ((in ? ix86_cost->int_load[1] : ix86_cost->int_store[1])\n+\t\t* (int) GET_MODE_SIZE (mode) / 4);\n+    }\n+}"}, {"sha": "d97d9887a48d5941c54d56a23d8912f97b956945", "filename": "gcc/config/i386/i386.h", "status": "modified", "additions": 15, "deletions": 21, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fa79946ef552152e732152ad7ffd127922ac9a60/gcc%2Fconfig%2Fi386%2Fi386.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fa79946ef552152e732152ad7ffd127922ac9a60/gcc%2Fconfig%2Fi386%2Fi386.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.h?ref=fa79946ef552152e732152ad7ffd127922ac9a60", "patch": "@@ -72,6 +72,18 @@ struct processor_costs {\n \t\t\t\t   in SFmode, DFmode and XFmode */\n   int fp_store[3];\t\t/* cost of storing FP register\n \t\t\t\t   in SFmode, DFmode and XFmode */\n+  int mmx_move;\t\t\t/* cost of moving MMX register.  */\n+  int mmx_load[2];\t\t/* cost of loading MMX register\n+\t\t\t\t   in SImode and DImode */\n+  int mmx_store[2];\t\t/* cost of storing MMX register\n+\t\t\t\t   in SImode and DImode */\n+  int sse_move;\t\t\t/* cost of moving SSE register.  */\n+  int sse_load[3];\t\t/* cost of loading SSE register\n+\t\t\t\t   in SImode, DImode and TImode*/\n+  int sse_store[3];\t\t/* cost of storing SSE register\n+\t\t\t\t   in SImode, DImode and TImode*/\n+  int mmxsse_to_integer;\t/* cost of moving mmxsse register to\n+\t\t\t\t   integer and vice versa.  */\n };\n \n extern struct processor_costs *ix86_cost;\n@@ -2395,28 +2407,10 @@ while (0)\n \n    If moving between registers and memory is more expensive than\n    between two registers, you should define this macro to express the\n-   relative cost.  \n- \n-   Model also increased moving costs of QImode registers in non\n-   Q_REGS classes.\n- */\n+   relative cost.  */\n \n-#define MEMORY_MOVE_COST(MODE,CLASS,IN)\t\t\t\t\t\\\n-  (FLOAT_CLASS_P (CLASS)\t\t\t\t\t\t\\\n-   ? (GET_MODE_SIZE (MODE)==4\t\t\t\t\t\t\\\n-      ? (IN ? ix86_cost->fp_load[0] : ix86_cost->fp_store[0])\t\t\\\n-      : (GET_MODE_SIZE (MODE)==8\t\t\t\t\t\\\n-\t ? (IN ? ix86_cost->fp_load[1] : ix86_cost->fp_store[1])\t\\\n-\t : (IN ? ix86_cost->fp_load[2] : ix86_cost->fp_store[2])))\t\\\n-   : (GET_MODE_SIZE (MODE)==1\t\t\t\t\t\t\\\n-      ? (IN ? (Q_CLASS_P (CLASS) ? ix86_cost->int_load[0]\t\t\\\n-\t\t\t\t : ix86_cost->movzbl_load)\t\t\\\n-\t    : (Q_CLASS_P (CLASS) ? ix86_cost->int_store[0]\t\t\\\n-\t\t\t\t : ix86_cost->int_store[0] + 4))\t\\\n-      : (GET_MODE_SIZE (MODE)==2\t\t\t\t\t\\\n-\t ? (IN ? ix86_cost->int_load[1] : ix86_cost->int_store[1])\t\\\n-\t : ((IN ? ix86_cost->int_load[2] : ix86_cost->int_store[2])\t\\\n-\t    * (int) GET_MODE_SIZE (MODE) / 4))))\n+#define MEMORY_MOVE_COST(MODE,CLASS,IN)\t\\\n+  ix86_memory_move_cost (MODE, CLASS, IN)\n \n /* A C expression for the cost of a branch instruction.  A value of 1\n    is the default; other values are interpreted relative to that.  */"}]}