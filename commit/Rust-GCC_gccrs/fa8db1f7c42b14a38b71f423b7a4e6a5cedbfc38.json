{"sha": "fa8db1f7c42b14a38b71f423b7a4e6a5cedbfc38", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZmE4ZGIxZjdjNDJiMTRhMzhiNzFmNDIzYjdhNGU2YTVjZWRiZmMzOA==", "commit": {"author": {"name": "Andreas Jaeger", "email": "aj@gcc.gnu.org", "date": "2003-07-01T16:20:39Z"}, "committer": {"name": "Andreas Jaeger", "email": "aj@gcc.gnu.org", "date": "2003-07-01T16:20:39Z"}, "message": "fold-const.c: Convert prototypes to ISO C90.\n\n\n\t* fold-const.c: Convert prototypes to ISO C90.\n\t* function.c: Likewise.\n\t* function.h: Likewise.\n\nFrom-SVN: r68778", "tree": {"sha": "c4fdfb808acd844d04e1c3a2d4df899d5b42be60", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c4fdfb808acd844d04e1c3a2d4df899d5b42be60"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/fa8db1f7c42b14a38b71f423b7a4e6a5cedbfc38", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fa8db1f7c42b14a38b71f423b7a4e6a5cedbfc38", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fa8db1f7c42b14a38b71f423b7a4e6a5cedbfc38", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fa8db1f7c42b14a38b71f423b7a4e6a5cedbfc38/comments", "author": null, "committer": null, "parents": [{"sha": "b69cd3cfcf7b4ab21f8e4cd1250565667dc0a771", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b69cd3cfcf7b4ab21f8e4cd1250565667dc0a771", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b69cd3cfcf7b4ab21f8e4cd1250565667dc0a771"}], "stats": {"total": 1085, "additions": 365, "deletions": 720}, "files": [{"sha": "25069c58f12c10f08ba88b48c19637ca8c2ba6fe", "filename": "gcc/fold-const.c", "status": "modified", "additions": 148, "deletions": 312, "changes": 460, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fa8db1f7c42b14a38b71f423b7a4e6a5cedbfc38/gcc%2Ffold-const.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fa8db1f7c42b14a38b71f423b7a4e6a5cedbfc38/gcc%2Ffold-const.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffold-const.c?ref=fa8db1f7c42b14a38b71f423b7a4e6a5cedbfc38", "patch": "@@ -57,64 +57,56 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n #include \"hashtab.h\"\n #include \"langhooks.h\"\n \n-static void encode\t\tPARAMS ((HOST_WIDE_INT *,\n-\t\t\t\t\t unsigned HOST_WIDE_INT,\n-\t\t\t\t\t HOST_WIDE_INT));\n-static void decode\t\tPARAMS ((HOST_WIDE_INT *,\n-\t\t\t\t\t unsigned HOST_WIDE_INT *,\n-\t\t\t\t\t HOST_WIDE_INT *));\n-static bool negate_expr_p\tPARAMS ((tree));\n-static tree negate_expr\t\tPARAMS ((tree));\n-static tree split_tree\t\tPARAMS ((tree, enum tree_code, tree *, tree *,\n-\t\t\t\t\t tree *, int));\n-static tree associate_trees\tPARAMS ((tree, tree, enum tree_code, tree));\n-static tree int_const_binop\tPARAMS ((enum tree_code, tree, tree, int));\n-static tree const_binop\t\tPARAMS ((enum tree_code, tree, tree, int));\n-static hashval_t size_htab_hash\tPARAMS ((const void *));\n-static int size_htab_eq\t\tPARAMS ((const void *, const void *));\n-static tree fold_convert\tPARAMS ((tree, tree));\n-static enum tree_code invert_tree_comparison PARAMS ((enum tree_code));\n-static enum tree_code swap_tree_comparison PARAMS ((enum tree_code));\n-static int comparison_to_compcode PARAMS ((enum tree_code));\n-static enum tree_code compcode_to_comparison PARAMS ((int));\n-static int truth_value_p\tPARAMS ((enum tree_code));\n-static int operand_equal_for_comparison_p PARAMS ((tree, tree, tree));\n-static int twoval_comparison_p\tPARAMS ((tree, tree *, tree *, int *));\n-static tree eval_subst\t\tPARAMS ((tree, tree, tree, tree, tree));\n-static tree pedantic_omit_one_operand PARAMS ((tree, tree, tree));\n-static tree distribute_bit_expr PARAMS ((enum tree_code, tree, tree, tree));\n-static tree make_bit_field_ref\tPARAMS ((tree, tree, int, int, int));\n-static tree optimize_bit_field_compare PARAMS ((enum tree_code, tree,\n-\t\t\t\t\t\ttree, tree));\n-static tree decode_field_reference PARAMS ((tree, HOST_WIDE_INT *,\n-\t\t\t\t\t    HOST_WIDE_INT *,\n-\t\t\t\t\t    enum machine_mode *, int *,\n-\t\t\t\t\t    int *, tree *, tree *));\n-static int all_ones_mask_p\tPARAMS ((tree, int));\n-static tree sign_bit_p\t\tPARAMS ((tree, tree));\n-static int simple_operand_p\tPARAMS ((tree));\n-static tree range_binop\t\tPARAMS ((enum tree_code, tree, tree, int,\n-\t\t\t\t\t tree, int));\n-static tree make_range\t\tPARAMS ((tree, int *, tree *, tree *));\n-static tree build_range_check\tPARAMS ((tree, tree, int, tree, tree));\n-static int merge_ranges\t\tPARAMS ((int *, tree *, tree *, int, tree, tree,\n-\t\t\t\t       int, tree, tree));\n-static tree fold_range_test\tPARAMS ((tree));\n-static tree unextend\t\tPARAMS ((tree, int, int, tree));\n-static tree fold_truthop\tPARAMS ((enum tree_code, tree, tree, tree));\n-static tree optimize_minmax_comparison PARAMS ((tree));\n-static tree extract_muldiv\tPARAMS ((tree, tree, enum tree_code, tree));\n-static tree extract_muldiv_1\tPARAMS ((tree, tree, enum tree_code, tree));\n-static tree strip_compound_expr PARAMS ((tree, tree));\n-static int multiple_of_p\tPARAMS ((tree, tree, tree));\n-static tree constant_boolean_node PARAMS ((int, tree));\n-static int count_cond\t\tPARAMS ((tree, int));\n-static tree fold_binary_op_with_conditional_arg\n-  PARAMS ((enum tree_code, tree, tree, tree, int));\n-static bool fold_real_zero_addition_p\tPARAMS ((tree, tree, int));\n-static tree fold_mathfn_compare\tPARAMS ((enum built_in_function,\n-\t\t\t\t\t enum tree_code, tree, tree, tree));\n-static tree fold_inf_compare\tPARAMS ((enum tree_code, tree, tree, tree));\n+static void encode (HOST_WIDE_INT *, unsigned HOST_WIDE_INT, HOST_WIDE_INT);\n+static void decode (HOST_WIDE_INT *, unsigned HOST_WIDE_INT *, HOST_WIDE_INT *);\n+static bool negate_expr_p (tree);\n+static tree negate_expr (tree);\n+static tree split_tree (tree, enum tree_code, tree *, tree *, tree *, int);\n+static tree associate_trees (tree, tree, enum tree_code, tree);\n+static tree int_const_binop (enum tree_code, tree, tree, int);\n+static tree const_binop (enum tree_code, tree, tree, int);\n+static hashval_t size_htab_hash (const void *);\n+static int size_htab_eq (const void *, const void *);\n+static tree fold_convert (tree, tree);\n+static enum tree_code invert_tree_comparison (enum tree_code);\n+static enum tree_code swap_tree_comparison (enum tree_code);\n+static int comparison_to_compcode (enum tree_code);\n+static enum tree_code compcode_to_comparison (int);\n+static int truth_value_p (enum tree_code);\n+static int operand_equal_for_comparison_p (tree, tree, tree);\n+static int twoval_comparison_p (tree, tree *, tree *, int *);\n+static tree eval_subst (tree, tree, tree, tree, tree);\n+static tree pedantic_omit_one_operand (tree, tree, tree);\n+static tree distribute_bit_expr (enum tree_code, tree, tree, tree);\n+static tree make_bit_field_ref (tree, tree, int, int, int);\n+static tree optimize_bit_field_compare (enum tree_code, tree, tree, tree);\n+static tree decode_field_reference (tree, HOST_WIDE_INT *, HOST_WIDE_INT *,\n+\t\t\t\t    enum machine_mode *, int *, int *,\n+\t\t\t\t    tree *, tree *);\n+static int all_ones_mask_p (tree, int);\n+static tree sign_bit_p (tree, tree);\n+static int simple_operand_p (tree);\n+static tree range_binop (enum tree_code, tree, tree, int, tree, int);\n+static tree make_range (tree, int *, tree *, tree *);\n+static tree build_range_check (tree, tree, int, tree, tree);\n+static int merge_ranges (int *, tree *, tree *, int, tree, tree, int, tree,\n+\t\t\t tree);\n+static tree fold_range_test (tree);\n+static tree unextend (tree, int, int, tree);\n+static tree fold_truthop (enum tree_code, tree, tree, tree);\n+static tree optimize_minmax_comparison (tree);\n+static tree extract_muldiv (tree, tree, enum tree_code, tree);\n+static tree extract_muldiv_1 (tree, tree, enum tree_code, tree);\n+static tree strip_compound_expr (tree, tree);\n+static int multiple_of_p (tree, tree, tree);\n+static tree constant_boolean_node (int, tree);\n+static int count_cond (tree, int);\n+static tree fold_binary_op_with_conditional_arg (enum tree_code, tree, tree,\n+\t\t\t\t\t\t tree, int);\n+static bool fold_real_zero_addition_p (tree, tree, int);\n+static tree fold_mathfn_compare (enum built_in_function, enum tree_code,\n+\t\t\t\t tree, tree, tree);\n+static tree fold_inf_compare (enum tree_code, tree, tree, tree);\n \n /* The following constants represent a bit based encoding of GCC's\n    comparison operators.  This encoding simplifies transformations\n@@ -154,10 +146,7 @@ static tree fold_inf_compare\tPARAMS ((enum tree_code, tree, tree, tree));\n    WORDS points to the array of HOST_WIDE_INTs.  */\n \n static void\n-encode (words, low, hi)\n-     HOST_WIDE_INT *words;\n-     unsigned HOST_WIDE_INT low;\n-     HOST_WIDE_INT hi;\n+encode (HOST_WIDE_INT *words, unsigned HOST_WIDE_INT low, HOST_WIDE_INT hi)\n {\n   words[0] = LOWPART (low);\n   words[1] = HIGHPART (low);\n@@ -170,10 +159,7 @@ encode (words, low, hi)\n    The integer is stored into *LOW and *HI as two `HOST_WIDE_INT' pieces.  */\n \n static void\n-decode (words, low, hi)\n-     HOST_WIDE_INT *words;\n-     unsigned HOST_WIDE_INT *low;\n-     HOST_WIDE_INT *hi;\n+decode (HOST_WIDE_INT *words, unsigned HOST_WIDE_INT *low, HOST_WIDE_INT *hi)\n {\n   *low = words[0] + words[1] * BASE;\n   *hi = words[2] + words[3] * BASE;\n@@ -187,9 +173,7 @@ decode (words, low, hi)\n    propagate it.  */\n \n int\n-force_fit_type (t, overflow)\n-     tree t;\n-     int overflow;\n+force_fit_type (tree t, int overflow)\n {\n   unsigned HOST_WIDE_INT low;\n   HOST_WIDE_INT high;\n@@ -268,11 +252,8 @@ force_fit_type (t, overflow)\n    The value is stored as two `HOST_WIDE_INT' pieces in *LV and *HV.  */\n \n int\n-add_double (l1, h1, l2, h2, lv, hv)\n-     unsigned HOST_WIDE_INT l1, l2;\n-     HOST_WIDE_INT h1, h2;\n-     unsigned HOST_WIDE_INT *lv;\n-     HOST_WIDE_INT *hv;\n+add_double (unsigned HOST_WIDE_INT l1, HOST_WIDE_INT h1, unsigned HOST_WIDE_INT l2,\n+\t    HOST_WIDE_INT h2, unsigned HOST_WIDE_INT *lv, HOST_WIDE_INT *hv)\n {\n   unsigned HOST_WIDE_INT l;\n   HOST_WIDE_INT h;\n@@ -291,11 +272,8 @@ add_double (l1, h1, l2, h2, lv, hv)\n    The value is stored as two `HOST_WIDE_INT' pieces in *LV and *HV.  */\n \n int\n-neg_double (l1, h1, lv, hv)\n-     unsigned HOST_WIDE_INT l1;\n-     HOST_WIDE_INT h1;\n-     unsigned HOST_WIDE_INT *lv;\n-     HOST_WIDE_INT *hv;\n+neg_double (unsigned HOST_WIDE_INT l1, HOST_WIDE_INT h1, unsigned HOST_WIDE_INT *lv,\n+\t    HOST_WIDE_INT *hv)\n {\n   if (l1 == 0)\n     {\n@@ -318,11 +296,8 @@ neg_double (l1, h1, lv, hv)\n    The value is stored as two `HOST_WIDE_INT' pieces in *LV and *HV.  */\n \n int\n-mul_double (l1, h1, l2, h2, lv, hv)\n-     unsigned HOST_WIDE_INT l1, l2;\n-     HOST_WIDE_INT h1, h2;\n-     unsigned HOST_WIDE_INT *lv;\n-     HOST_WIDE_INT *hv;\n+mul_double (unsigned HOST_WIDE_INT l1, HOST_WIDE_INT h1, unsigned HOST_WIDE_INT l2,\n+\t    HOST_WIDE_INT h2, unsigned HOST_WIDE_INT *lv, HOST_WIDE_INT *hv)\n {\n   HOST_WIDE_INT arg1[4];\n   HOST_WIDE_INT arg2[4];\n@@ -378,13 +353,9 @@ mul_double (l1, h1, l2, h2, lv, hv)\n    Store the value as two `HOST_WIDE_INT' pieces in *LV and *HV.  */\n \n void\n-lshift_double (l1, h1, count, prec, lv, hv, arith)\n-     unsigned HOST_WIDE_INT l1;\n-     HOST_WIDE_INT h1, count;\n-     unsigned int prec;\n-     unsigned HOST_WIDE_INT *lv;\n-     HOST_WIDE_INT *hv;\n-     int arith;\n+lshift_double (unsigned HOST_WIDE_INT l1, HOST_WIDE_INT h1, HOST_WIDE_INT count,\n+\t       unsigned int prec, unsigned HOST_WIDE_INT *lv, HOST_WIDE_INT *hv,\n+\t       int arith)\n {\n   unsigned HOST_WIDE_INT signmask;\n \n@@ -446,13 +417,9 @@ lshift_double (l1, h1, count, prec, lv, hv, arith)\n    Store the value as two `HOST_WIDE_INT' pieces in *LV and *HV.  */\n \n void\n-rshift_double (l1, h1, count, prec, lv, hv, arith)\n-     unsigned HOST_WIDE_INT l1;\n-     HOST_WIDE_INT h1, count;\n-     unsigned int prec;\n-     unsigned HOST_WIDE_INT *lv;\n-     HOST_WIDE_INT *hv;\n-     int arith;\n+rshift_double (unsigned HOST_WIDE_INT l1, HOST_WIDE_INT h1, HOST_WIDE_INT count,\n+\t       unsigned int prec, unsigned HOST_WIDE_INT *lv, HOST_WIDE_INT *hv,\n+\t       int arith)\n {\n   unsigned HOST_WIDE_INT signmask;\n \n@@ -512,12 +479,8 @@ rshift_double (l1, h1, count, prec, lv, hv, arith)\n    Store the value as two `HOST_WIDE_INT' pieces in *LV and *HV.  */\n \n void\n-lrotate_double (l1, h1, count, prec, lv, hv)\n-     unsigned HOST_WIDE_INT l1;\n-     HOST_WIDE_INT h1, count;\n-     unsigned int prec;\n-     unsigned HOST_WIDE_INT *lv;\n-     HOST_WIDE_INT *hv;\n+lrotate_double (unsigned HOST_WIDE_INT l1, HOST_WIDE_INT h1, HOST_WIDE_INT count,\n+\t\tunsigned int prec, unsigned HOST_WIDE_INT *lv, HOST_WIDE_INT *hv)\n {\n   unsigned HOST_WIDE_INT s1l, s2l;\n   HOST_WIDE_INT s1h, s2h;\n@@ -537,12 +500,8 @@ lrotate_double (l1, h1, count, prec, lv, hv)\n    Store the value as two `HOST_WIDE_INT' pieces in *LV and *HV.  */\n \n void\n-rrotate_double (l1, h1, count, prec, lv, hv)\n-     unsigned HOST_WIDE_INT l1;\n-     HOST_WIDE_INT h1, count;\n-     unsigned int prec;\n-     unsigned HOST_WIDE_INT *lv;\n-     HOST_WIDE_INT *hv;\n+rrotate_double (unsigned HOST_WIDE_INT l1, HOST_WIDE_INT h1, HOST_WIDE_INT count,\n+\t\tunsigned int prec, unsigned HOST_WIDE_INT *lv, HOST_WIDE_INT *hv)\n {\n   unsigned HOST_WIDE_INT s1l, s2l;\n   HOST_WIDE_INT s1h, s2h;\n@@ -567,17 +526,13 @@ rrotate_double (l1, h1, count, prec, lv, hv)\n    UNS nonzero says do unsigned division.  */\n \n int\n-div_and_round_double (code, uns,\n-\t\t      lnum_orig, hnum_orig, lden_orig, hden_orig,\n-\t\t      lquo, hquo, lrem, hrem)\n-     enum tree_code code;\n-     int uns;\n-     unsigned HOST_WIDE_INT lnum_orig; /* num == numerator == dividend */\n-     HOST_WIDE_INT hnum_orig;\n-     unsigned HOST_WIDE_INT lden_orig; /* den == denominator == divisor */\n-     HOST_WIDE_INT hden_orig;\n-     unsigned HOST_WIDE_INT *lquo, *lrem;\n-     HOST_WIDE_INT *hquo, *hrem;\n+div_and_round_double (enum tree_code code, int uns,\n+\t\t      unsigned HOST_WIDE_INT lnum_orig, /* num == numerator == dividend */\n+\t\t      HOST_WIDE_INT hnum_orig,\n+\t\t      unsigned HOST_WIDE_INT lden_orig, /* den == denominator == divisor */\n+\t\t      HOST_WIDE_INT hden_orig, unsigned HOST_WIDE_INT *lquo,\n+\t\t      HOST_WIDE_INT *hquo, unsigned HOST_WIDE_INT *lrem,\n+\t\t      HOST_WIDE_INT *hrem)\n {\n   int quo_neg = 0;\n   HOST_WIDE_INT num[4 + 1];\t/* extra element for scaling.  */\n@@ -842,8 +797,7 @@ div_and_round_double (code, uns,\n    the function negate_expr.  */\n \n static bool\n-negate_expr_p (t)\n-     tree t;\n+negate_expr_p (tree t)\n {\n   unsigned HOST_WIDE_INT val;\n   unsigned int prec;\n@@ -891,8 +845,7 @@ negate_expr_p (t)\n    null, in which case return null.  */\n \n static tree\n-negate_expr (t)\n-     tree t;\n+negate_expr (tree t)\n {\n   tree type;\n   tree tem;\n@@ -953,11 +906,7 @@ negate_expr (t)\n    same type as IN, but they will have the same signedness and mode.  */\n \n static tree\n-split_tree (in, code, conp, litp, minus_litp, negate_p)\n-     tree in;\n-     enum tree_code code;\n-     tree *conp, *litp, *minus_litp;\n-     int negate_p;\n+split_tree (tree in, enum tree_code code, tree *conp, tree *litp, tree *minus_litp, int negate_p)\n {\n   tree var = 0;\n \n@@ -1035,10 +984,7 @@ split_tree (in, code, conp, litp, minus_litp, negate_p)\n    we build an operation, do it in TYPE and with CODE.  */\n \n static tree\n-associate_trees (t1, t2, code, type)\n-     tree t1, t2;\n-     enum tree_code code;\n-     tree type;\n+associate_trees (tree t1, tree t2, enum tree_code code, tree type)\n {\n   if (t1 == 0)\n     return t2;\n@@ -1072,10 +1018,7 @@ associate_trees (t1, t2, code, type)\n    If NOTRUNC is nonzero, do not truncate the result to fit the data type.  */\n \n static tree\n-int_const_binop (code, arg1, arg2, notrunc)\n-     enum tree_code code;\n-     tree arg1, arg2;\n-     int notrunc;\n+int_const_binop (enum tree_code code, tree arg1, tree arg2, int notrunc)\n {\n   unsigned HOST_WIDE_INT int1l, int2l;\n   HOST_WIDE_INT int1h, int2h;\n@@ -1267,10 +1210,7 @@ int_const_binop (code, arg1, arg2, notrunc)\n    If NOTRUNC is nonzero, do not truncate the result to fit the data type.  */\n \n static tree\n-const_binop (code, arg1, arg2, notrunc)\n-     enum tree_code code;\n-     tree arg1, arg2;\n-     int notrunc;\n+const_binop (enum tree_code code, tree arg1, tree arg2, int notrunc)\n {\n   STRIP_NOPS (arg1);\n   STRIP_NOPS (arg2);\n@@ -1395,8 +1335,7 @@ const_binop (code, arg1, arg2, notrunc)\n /* Return the hash code code X, an INTEGER_CST.  */\n \n static hashval_t\n-size_htab_hash (x)\n-     const void *x;\n+size_htab_hash (const void *x)\n {\n   tree t = (tree) x;\n \n@@ -1409,9 +1348,7 @@ size_htab_hash (x)\n    is the same as that given by *Y, which is the same.  */\n \n static int\n-size_htab_eq (x, y)\n-     const void *x;\n-     const void *y;\n+size_htab_eq (const void *x, const void *y)\n {\n   tree xt = (tree) x;\n   tree yt = (tree) y;\n@@ -1426,9 +1363,7 @@ size_htab_eq (x, y)\n    bits are given by NUMBER and of the sizetype represented by KIND.  */\n \n tree\n-size_int_wide (number, kind)\n-     HOST_WIDE_INT number;\n-     enum size_type_kind kind;\n+size_int_wide (HOST_WIDE_INT number, enum size_type_kind kind)\n {\n   return size_int_type_wide (number, sizetype_tab[(int) kind]);\n }\n@@ -1440,9 +1375,7 @@ static GTY ((if_marked (\"ggc_marked_p\"), param_is (union tree_node)))\n      htab_t size_htab;\n \n tree\n-size_int_type_wide (number, type)\n-     HOST_WIDE_INT number;\n-     tree type;\n+size_int_type_wide (HOST_WIDE_INT number, tree type)\n {\n   void **slot;\n \n@@ -1480,9 +1413,7 @@ size_int_type_wide (number, type)\n    If the operands are constant, so is the result.  */\n \n tree\n-size_binop (code, arg0, arg1)\n-     enum tree_code code;\n-     tree arg0, arg1;\n+size_binop (enum tree_code code, tree arg0, tree arg1)\n {\n   tree type = TREE_TYPE (arg0);\n \n@@ -1517,8 +1448,7 @@ size_binop (code, arg0, arg1)\n    in signed type corresponding to the type of the operands.  */\n \n tree\n-size_diffop (arg0, arg1)\n-     tree arg0, arg1;\n+size_diffop (tree arg0, tree arg1)\n {\n   tree type = TREE_TYPE (arg0);\n   tree ctype;\n@@ -1559,9 +1489,7 @@ size_diffop (arg0, arg1)\n    return a constant tree representing the result of conversion.  */\n \n static tree\n-fold_convert (t, arg1)\n-     tree t;\n-     tree arg1;\n+fold_convert (tree t, tree arg1)\n {\n   tree type = TREE_TYPE (t);\n   int overflow = 0;\n@@ -1680,8 +1608,7 @@ fold_convert (t, arg1)\n /* Return an expr equal to X but certainly not valid as an lvalue.  */\n \n tree\n-non_lvalue (x)\n-     tree x;\n+non_lvalue (tree x)\n {\n   tree result;\n \n@@ -1707,8 +1634,7 @@ int pedantic_lvalues;\n    pedantic lvalue.  Otherwise, return X.  */\n \n tree\n-pedantic_non_lvalue (x)\n-     tree x;\n+pedantic_non_lvalue (tree x)\n {\n   if (pedantic_lvalues)\n     return non_lvalue (x);\n@@ -1721,8 +1647,7 @@ pedantic_non_lvalue (x)\n    comparisons, except for NE_EXPR and EQ_EXPR.  */\n \n static enum tree_code\n-invert_tree_comparison (code)\n-     enum tree_code code;\n+invert_tree_comparison (enum tree_code code)\n {\n   switch (code)\n     {\n@@ -1747,8 +1672,7 @@ invert_tree_comparison (code)\n    swapped.  This is safe for floating-point.  */\n \n static enum tree_code\n-swap_tree_comparison (code)\n-     enum tree_code code;\n+swap_tree_comparison (enum tree_code code)\n {\n   switch (code)\n     {\n@@ -1774,8 +1698,7 @@ swap_tree_comparison (code)\n    compcode_to_comparison.  */\n \n static int\n-comparison_to_compcode (code)\n-     enum tree_code code;\n+comparison_to_compcode (enum tree_code code)\n {\n   switch (code)\n     {\n@@ -1801,8 +1724,7 @@ comparison_to_compcode (code)\n    inverse of comparison_to_compcode.  */\n \n static enum tree_code\n-compcode_to_comparison (code)\n-     int code;\n+compcode_to_comparison (int code)\n {\n   switch (code)\n     {\n@@ -1826,8 +1748,7 @@ compcode_to_comparison (code)\n /* Return nonzero if CODE is a tree code that represents a truth value.  */\n \n static int\n-truth_value_p (code)\n-     enum tree_code code;\n+truth_value_p (enum tree_code code)\n {\n   return (TREE_CODE_CLASS (code) == '<'\n \t  || code == TRUTH_AND_EXPR || code == TRUTH_ANDIF_EXPR\n@@ -1844,9 +1765,7 @@ truth_value_p (code)\n    (2) two NaNs may be indistinguishable, but NaN!=NaN.  */\n \n int\n-operand_equal_p (arg0, arg1, only_const)\n-     tree arg0, arg1;\n-     int only_const;\n+operand_equal_p (tree arg0, tree arg1, int only_const)\n {\n   /* If both types don't have the same signedness, then we can't consider\n      them equal.  We must check this before the STRIP_NOPS calls\n@@ -2067,9 +1986,7 @@ operand_equal_p (arg0, arg1, only_const)\n    When in doubt, return 0.  */\n \n static int\n-operand_equal_for_comparison_p (arg0, arg1, other)\n-     tree arg0, arg1;\n-     tree other;\n+operand_equal_for_comparison_p (tree arg0, tree arg1, tree other)\n {\n   int unsignedp1, unsignedpo;\n   tree primarg0, primarg1, primother;\n@@ -2130,10 +2047,7 @@ operand_equal_for_comparison_p (arg0, arg1, other)\n    If this is true, return 1.  Otherwise, return zero.  */\n \n static int\n-twoval_comparison_p (arg, cval1, cval2, save_p)\n-     tree arg;\n-     tree *cval1, *cval2;\n-     int *save_p;\n+twoval_comparison_p (tree arg, tree *cval1, tree *cval2, int *save_p)\n {\n   enum tree_code code = TREE_CODE (arg);\n   char class = TREE_CODE_CLASS (code);\n@@ -2225,9 +2139,7 @@ twoval_comparison_p (arg, cval1, cval2, save_p)\n    NEW1 and OLD1.  */\n \n static tree\n-eval_subst (arg, old0, new0, old1, new1)\n-     tree arg;\n-     tree old0, new0, old1, new1;\n+eval_subst (tree arg, tree old0, tree new0, tree old1, tree new1)\n {\n   tree type = TREE_TYPE (arg);\n   enum tree_code code = TREE_CODE (arg);\n@@ -2311,8 +2223,7 @@ eval_subst (arg, old0, new0, old1, new1)\n    the conversion of RESULT to TYPE.  */\n \n tree\n-omit_one_operand (type, result, omitted)\n-     tree type, result, omitted;\n+omit_one_operand (tree type, tree result, tree omitted)\n {\n   tree t = convert (type, result);\n \n@@ -2325,8 +2236,7 @@ omit_one_operand (type, result, omitted)\n /* Similar, but call pedantic_non_lvalue instead of non_lvalue.  */\n \n static tree\n-pedantic_omit_one_operand (type, result, omitted)\n-     tree type, result, omitted;\n+pedantic_omit_one_operand (tree type, tree result, tree omitted)\n {\n   tree t = convert (type, result);\n \n@@ -2341,8 +2251,7 @@ pedantic_omit_one_operand (type, result, omitted)\n    returns a truth value (0 or 1).  */\n \n tree\n-invert_truthvalue (arg)\n-     tree arg;\n+invert_truthvalue (tree arg)\n {\n   tree type = TREE_TYPE (arg);\n   enum tree_code code = TREE_CODE (arg);\n@@ -2455,16 +2364,13 @@ invert_truthvalue (arg)\n    operands are another bit-wise operation with a common input.  If so,\n    distribute the bit operations to save an operation and possibly two if\n    constants are involved.  For example, convert\n-   \t(A | B) & (A | C) into A | (B & C)\n+\t(A | B) & (A | C) into A | (B & C)\n    Further simplification will occur if B and C are constants.\n \n    If this optimization cannot be done, 0 will be returned.  */\n \n static tree\n-distribute_bit_expr (code, type, arg0, arg1)\n-     enum tree_code code;\n-     tree type;\n-     tree arg0, arg1;\n+distribute_bit_expr (enum tree_code code, tree type, tree arg0, tree arg1)\n {\n   tree common;\n   tree left, right;\n@@ -2510,11 +2416,7 @@ distribute_bit_expr (code, type, arg0, arg1)\n    starting at BITPOS.  The field is unsigned if UNSIGNEDP is nonzero.  */\n \n static tree\n-make_bit_field_ref (inner, type, bitsize, bitpos, unsignedp)\n-     tree inner;\n-     tree type;\n-     int bitsize, bitpos;\n-     int unsignedp;\n+make_bit_field_ref (tree inner, tree type, int bitsize, int bitpos, int unsignedp)\n {\n   tree result = build (BIT_FIELD_REF, type, inner,\n \t\t       size_int (bitsize), bitsize_int (bitpos));\n@@ -2545,10 +2447,7 @@ make_bit_field_ref (inner, type, bitsize, bitpos, unsignedp)\n    tree.  Otherwise we return zero.  */\n \n static tree\n-optimize_bit_field_compare (code, compare_type, lhs, rhs)\n-     enum tree_code code;\n-     tree compare_type;\n-     tree lhs, rhs;\n+optimize_bit_field_compare (enum tree_code code, tree compare_type, tree lhs, tree rhs)\n {\n   HOST_WIDE_INT lbitpos, lbitsize, rbitpos, rbitsize, nbitpos, nbitsize;\n   tree type = TREE_TYPE (lhs);\n@@ -2722,14 +2621,9 @@ optimize_bit_field_compare (code, compare_type, lhs, rhs)\n    do anything with.  */\n \n static tree\n-decode_field_reference (exp, pbitsize, pbitpos, pmode, punsignedp,\n-\t\t\tpvolatilep, pmask, pand_mask)\n-     tree exp;\n-     HOST_WIDE_INT *pbitsize, *pbitpos;\n-     enum machine_mode *pmode;\n-     int *punsignedp, *pvolatilep;\n-     tree *pmask;\n-     tree *pand_mask;\n+decode_field_reference (tree exp, HOST_WIDE_INT *pbitsize, HOST_WIDE_INT *pbitpos,\n+\t\t\tenum machine_mode *pmode, int *punsignedp, int *pvolatilep,\n+\t\t\ttree *pmask, tree *pand_mask)\n {\n   tree and_mask = 0;\n   tree mask, inner, offset;\n@@ -2784,9 +2678,7 @@ decode_field_reference (exp, pbitsize, pbitpos, pmode, punsignedp,\n    bit positions.  */\n \n static int\n-all_ones_mask_p (mask, size)\n-     tree mask;\n-     int size;\n+all_ones_mask_p (tree mask, int size)\n {\n   tree type = TREE_TYPE (mask);\n   unsigned int precision = TYPE_PRECISION (type);\n@@ -2811,9 +2703,7 @@ all_ones_mask_p (mask, size)\n    or NULL_TREE otherwise.  */\n \n static tree\n-sign_bit_p (exp, val)\n-     tree exp;\n-     tree val;\n+sign_bit_p (tree exp, tree val)\n {\n   unsigned HOST_WIDE_INT lo;\n   HOST_WIDE_INT hi;\n@@ -2857,8 +2747,7 @@ sign_bit_p (exp, val)\n    to be evaluated unconditionally.  */\n \n static int\n-simple_operand_p (exp)\n-     tree exp;\n+simple_operand_p (tree exp)\n {\n   /* Strip any conversions that don't change the machine mode.  */\n   while ((TREE_CODE (exp) == NOP_EXPR\n@@ -2886,9 +2775,9 @@ simple_operand_p (exp)\n    try to change a logical combination of comparisons into a range test.\n \n    For example, both\n-   \tX == 2 || X == 3 || X == 4 || X == 5\n+\tX == 2 || X == 3 || X == 4 || X == 5\n    and\n-   \tX >= 2 && X <= 5\n+\tX >= 2 && X <= 5\n    are converted to\n \t(unsigned) (X - 2) <= 3\n \n@@ -2918,11 +2807,8 @@ simple_operand_p (exp)\n    type if both are specified.  */\n \n static tree\n-range_binop (code, type, arg0, upper0_p, arg1, upper1_p)\n-     enum tree_code code;\n-     tree type;\n-     tree arg0, arg1;\n-     int upper0_p, upper1_p;\n+range_binop (enum tree_code code, tree type, tree arg0, int upper0_p, tree arg1,\n+\t     int upper1_p)\n {\n   tree tem;\n   int result;\n@@ -2986,10 +2872,7 @@ range_binop (code, type, arg0, upper0_p, arg1, upper1_p)\n    likely not be returning a useful value and range.  */\n \n static tree\n-make_range (exp, pin_p, plow, phigh)\n-     tree exp;\n-     int *pin_p;\n-     tree *plow, *phigh;\n+make_range (tree exp, int *pin_p, tree *plow, tree *phigh)\n {\n   enum tree_code code;\n   tree arg0 = NULL_TREE, arg1 = NULL_TREE, type = NULL_TREE;\n@@ -3254,11 +3137,7 @@ make_range (exp, pin_p, plow, phigh)\n    on IN_P) the range.  */\n \n static tree\n-build_range_check (type, exp, in_p, low, high)\n-     tree type;\n-     tree exp;\n-     int in_p;\n-     tree low, high;\n+build_range_check (tree type, tree exp, int in_p, tree low, tree high)\n {\n   tree etype = TREE_TYPE (exp);\n   tree value;\n@@ -3334,11 +3213,8 @@ build_range_check (type, exp, in_p, low, high)\n    can, 0 if we can't.  Set the output range into the specified parameters.  */\n \n static int\n-merge_ranges (pin_p, plow, phigh, in0_p, low0, high0, in1_p, low1, high1)\n-     int *pin_p;\n-     tree *plow, *phigh;\n-     int in0_p, in1_p;\n-     tree low0, high0, low1, high1;\n+merge_ranges (int *pin_p, tree *plow, tree *phigh, int in0_p, tree low0, tree high0,\n+\t      int in1_p, tree low1, tree high1)\n {\n   int no_overlap;\n   int subset;\n@@ -3474,8 +3350,7 @@ merge_ranges (pin_p, plow, phigh, in0_p, low0, high0, in1_p, low1, high1)\n    merge it into some range test.  Return the new tree if so.  */\n \n static tree\n-fold_range_test (exp)\n-     tree exp;\n+fold_range_test (tree exp)\n {\n   int or_op = (TREE_CODE (exp) == TRUTH_ORIF_EXPR\n \t       || TREE_CODE (exp) == TRUTH_OR_EXPR);\n@@ -3547,11 +3422,7 @@ fold_range_test (exp)\n    it is an INTEGER_CST that should be AND'ed with the extra bits.  */\n \n static tree\n-unextend (c, p, unsignedp, mask)\n-     tree c;\n-     int p;\n-     int unsignedp;\n-     tree mask;\n+unextend (tree c, int p, int unsignedp, tree mask)\n {\n   tree type = TREE_TYPE (c);\n   int modesize = GET_MODE_BITSIZE (TYPE_MODE (type));\n@@ -3611,14 +3482,12 @@ unextend (c, p, unsignedp, mask)\n    We return the simplified tree or 0 if no optimization is possible.  */\n \n static tree\n-fold_truthop (code, truth_type, lhs, rhs)\n-     enum tree_code code;\n-     tree truth_type, lhs, rhs;\n+fold_truthop (enum tree_code code, tree truth_type, tree lhs, tree rhs)\n {\n   /* If this is the \"or\" of two comparisons, we can do something if\n      the comparisons are NE_EXPR.  If this is the \"and\", we can do something\n      if the comparisons are EQ_EXPR.  I.e.,\n-     \t(a->b == 2 && a->c == 4) can become (a->new == NEW).\n+\t(a->b == 2 && a->c == 4) can become (a->new == NEW).\n \n      WANTED_CODE is this operation code.  For single bit fields, we can\n      convert EQ_EXPR to NE_EXPR so we need not reject the \"wrong\"\n@@ -4037,8 +3906,7 @@ fold_truthop (code, truth_type, lhs, rhs)\n    constant.  */\n \n static tree\n-optimize_minmax_comparison (t)\n-     tree t;\n+optimize_minmax_comparison (tree t)\n {\n   tree type = TREE_TYPE (t);\n   tree arg0 = TREE_OPERAND (t, 0);\n@@ -4149,11 +4017,7 @@ optimize_minmax_comparison (t)\n    original computation, but need not be in the original type.  */\n \n static tree\n-extract_muldiv (t, c, code, wide_type)\n-     tree t;\n-     tree c;\n-     enum tree_code code;\n-     tree wide_type;\n+extract_muldiv (tree t, tree c, enum tree_code code, tree wide_type)\n {\n   /* To avoid exponential search depth, refuse to allow recursion past\n      three levels.  Beyond that (1) it's highly unlikely that we'll find\n@@ -4174,11 +4038,7 @@ extract_muldiv (t, c, code, wide_type)\n }\n \n static tree\n-extract_muldiv_1 (t, c, code, wide_type)\n-     tree t;\n-     tree c;\n-     enum tree_code code;\n-     tree wide_type;\n+extract_muldiv_1 (tree t, tree c, enum tree_code code, tree wide_type)\n {\n   tree type = TREE_TYPE (t);\n   enum tree_code tcode = TREE_CODE (t);\n@@ -4464,9 +4324,7 @@ extract_muldiv_1 (t, c, code, wide_type)\n    that we may sometimes modify the tree.  */\n \n static tree\n-strip_compound_expr (t, s)\n-     tree t;\n-     tree s;\n+strip_compound_expr (tree t, tree s)\n {\n   enum tree_code code = TREE_CODE (t);\n \n@@ -4499,9 +4357,7 @@ strip_compound_expr (t, s)\n    1), and is of the indicated TYPE.  */\n \n static tree\n-constant_boolean_node (value, type)\n-     int value;\n-     tree type;\n+constant_boolean_node (int value, tree type)\n {\n   if (type == integer_type_node)\n     return value ? integer_one_node : integer_zero_node;\n@@ -4522,9 +4378,7 @@ constant_boolean_node (value, type)\n    we don't care (to avoid spending too much time on complex expressions.).  */\n \n static int\n-count_cond (expr, lim)\n-     tree expr;\n-     int lim;\n+count_cond (tree expr, int lim)\n {\n   int ctrue, cfalse;\n \n@@ -4547,12 +4401,7 @@ count_cond (expr, lim)\n    original expression.  */\n \n static tree\n-fold_binary_op_with_conditional_arg (code, type, cond, arg, cond_first_p)\n-     enum tree_code code;\n-     tree type;\n-     tree cond;\n-     tree arg;\n-     int cond_first_p;\n+fold_binary_op_with_conditional_arg (enum tree_code code, tree type, tree cond, tree arg, int cond_first_p)\n {\n   tree test, true_value, false_value;\n   tree lhs = NULL_TREE;\n@@ -4693,9 +4542,7 @@ fold_binary_op_with_conditional_arg (code, type, cond, arg, cond_first_p)\n    modes, X + 0 is not the same as X because -0 + 0 is 0.  */\n \n static bool\n-fold_real_zero_addition_p (type, addend, negate)\n-     tree type, addend;\n-     int negate;\n+fold_real_zero_addition_p (tree type, tree addend, int negate)\n {\n   if (!real_zerop (addend))\n     return false;\n@@ -4732,10 +4579,7 @@ fold_real_zero_addition_p (type, addend, negate)\n    can be made, and NULL_TREE otherwise.  */\n \n static tree\n-fold_mathfn_compare (fcode, code, type, arg0, arg1)\n-     enum built_in_function fcode;\n-     enum tree_code code;\n-     tree type, arg0, arg1;\n+fold_mathfn_compare (enum built_in_function fcode, enum tree_code code, tree type, tree arg0, tree arg1)\n {\n   REAL_VALUE_TYPE c;\n \n@@ -4869,9 +4713,7 @@ fold_mathfn_compare (fcode, code, type, arg0, arg1)\n    can be made, and NULL_TREE otherwise.  */\n \n static tree\n-fold_inf_compare (code, type, arg0, arg1)\n-     enum tree_code code;\n-     tree type, arg0, arg1;\n+fold_inf_compare (enum tree_code code, tree type, tree arg0, tree arg1)\n {\n   enum machine_mode mode;\n   REAL_VALUE_TYPE max;\n@@ -4950,8 +4792,7 @@ fold_inf_compare (code, type, arg0, arg1)\n    but we can constant-fold them if they have constant operands.  */\n \n tree\n-fold (expr)\n-     tree expr;\n+fold (tree expr)\n {\n   tree t = expr;\n   tree t1 = NULL_TREE;\n@@ -5342,7 +5183,7 @@ fold (expr)\n \t\t{\n \t\t  tree uns = (*lang_hooks.types.unsigned_type) (TREE_TYPE (and0));\n \t\t  and0 = convert (uns, and0);\n-\t  \t  and1 = convert (uns, and1);\n+\t\t  and1 = convert (uns, and1);\n \t\t}\n #endif\n \t    }\n@@ -5409,7 +5250,7 @@ fold (expr)\n \t  tree targ0 = strip_float_extensions (arg0);\n \t  if (targ0 != arg0)\n \t    return convert (type, build1 (NEGATE_EXPR, TREE_TYPE (targ0), targ0));\n-\t\t\t   \n+\n \t}\n \n       /* Convert - (a - b) to (b - a) for non-floating-point.  */\n@@ -5583,15 +5424,15 @@ fold (expr)\n \t      if (TREE_CODE (parg0) == MULT_EXPR\n \t\t  && TREE_CODE (parg1) != MULT_EXPR)\n \t\treturn fold (build (PLUS_EXPR, type,\n-\t\t\t\t    fold (build (PLUS_EXPR, type, \n-\t\t\t\t\t\t convert (type, parg0), \n+\t\t\t\t    fold (build (PLUS_EXPR, type,\n+\t\t\t\t\t\t convert (type, parg0),\n \t\t\t\t\t\t convert (type, marg))),\n \t\t\t\t    convert (type, parg1)));\n \t      if (TREE_CODE (parg0) != MULT_EXPR\n \t\t  && TREE_CODE (parg1) == MULT_EXPR)\n \t\treturn fold (build (PLUS_EXPR, type,\n-\t\t\t\t    fold (build (PLUS_EXPR, type, \n-\t\t\t\t\t\t convert (type, parg1), \n+\t\t\t\t    fold (build (PLUS_EXPR, type,\n+\t\t\t\t\t\t convert (type, parg1),\n \t\t\t\t\t\t convert (type, marg))),\n \t\t\t\t    convert (type, parg0)));\n \t    }\n@@ -6235,8 +6076,8 @@ fold (expr)\n \t{\n \t  return fold (build (MULT_EXPR, type,\n \t\t\t      build (RDIV_EXPR, type, arg0,\n-\t\t\t     \t     TREE_OPERAND (arg1, 0)),\n-\t \t\t      TREE_OPERAND (arg1, 1)));\n+\t\t\t\t     TREE_OPERAND (arg1, 0)),\n+\t\t\t      TREE_OPERAND (arg1, 1)));\n \t}\n \n       if (flag_unsafe_math_optimizations)\n@@ -7373,7 +7214,7 @@ fold (expr)\n \n       /* Optimize comparisons of strlen vs zero to a compare of the\n \t first character of the string vs zero.  To wit,\n-\t \tstrlen(ptr) == 0   =>  *ptr == 0\n+\t\tstrlen(ptr) == 0   =>  *ptr == 0\n \t\tstrlen(ptr) != 0   =>  *ptr != 0\n \t Other cases should reduce to one of these two (or a constant)\n \t due to the return value of strlen being unsigned.  */\n@@ -7969,10 +7810,7 @@ fold (expr)\n    transformed version).  */\n \n static int\n-multiple_of_p (type, top, bottom)\n-     tree type;\n-     tree top;\n-     tree bottom;\n+multiple_of_p (tree type, tree top, tree bottom)\n {\n   if (operand_equal_p (top, bottom, 0))\n     return 1;\n@@ -8039,8 +7877,7 @@ multiple_of_p (type, top, bottom)\n /* Return true if `t' is known to be non-negative.  */\n \n int\n-tree_expr_nonnegative_p (t)\n-     tree t;\n+tree_expr_nonnegative_p (tree t)\n {\n   switch (TREE_CODE (t))\n     {\n@@ -8238,8 +8075,7 @@ tree_expr_nonnegative_p (t)\n    Only handles constants at the moment.  */\n \n int\n-rtl_expr_nonnegative_p (r)\n-     rtx r;\n+rtl_expr_nonnegative_p (rtx r)\n {\n   switch (GET_CODE (r))\n     {"}, {"sha": "00455053844c9ecf01e84416a8379946e6de6e33", "filename": "gcc/function.c", "status": "modified", "additions": 193, "deletions": 384, "changes": 577, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fa8db1f7c42b14a38b71f423b7a4e6a5cedbfc38/gcc%2Ffunction.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fa8db1f7c42b14a38b71f423b7a4e6a5cedbfc38/gcc%2Ffunction.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffunction.c?ref=fa8db1f7c42b14a38b71f423b7a4e6a5cedbfc38", "patch": "@@ -137,7 +137,7 @@ static GTY(()) int funcdef_no;\n \n /* These variables hold pointers to functions to create and destroy\n    target specific, per-function data structures.  */\n-struct machine_function * (*init_machine_status) PARAMS ((void));\n+struct machine_function * (*init_machine_status) (void);\n \n /* The FUNCTION_DECL for an inline function currently being expanded.  */\n tree inline_function_decl;\n@@ -229,76 +229,65 @@ struct insns_for_mem_entry\n \n /* Forward declarations.  */\n \n-static rtx assign_stack_local_1 PARAMS ((enum machine_mode, HOST_WIDE_INT,\n-\t\t\t\t\t int, struct function *));\n-static struct temp_slot *find_temp_slot_from_address  PARAMS ((rtx));\n-static void put_reg_into_stack\tPARAMS ((struct function *, rtx, tree,\n-\t\t\t\t\t enum machine_mode, enum machine_mode,\n-\t\t\t\t\t int, unsigned int, int,\n-\t\t\t\t\t htab_t));\n-static void schedule_fixup_var_refs PARAMS ((struct function *, rtx, tree,\n-\t\t\t\t\t     enum machine_mode,\n-\t\t\t\t\t     htab_t));\n-static void fixup_var_refs\tPARAMS ((rtx, enum machine_mode, int, rtx,\n-\t\t\t\t\t htab_t));\n+static rtx assign_stack_local_1 (enum machine_mode, HOST_WIDE_INT, int,\n+\t\t\t\t struct function *);\n+static struct temp_slot *find_temp_slot_from_address (rtx);\n+static void put_reg_into_stack (struct function *, rtx, tree, enum machine_mode,\n+\t\t\t\tenum machine_mode, int, unsigned int, int, htab_t);\n+static void schedule_fixup_var_refs (struct function *, rtx, tree, enum machine_mode,\n+\t\t\t\t     htab_t);\n+static void fixup_var_refs (rtx, enum machine_mode, int, rtx, htab_t);\n static struct fixup_replacement\n-  *find_fixup_replacement\tPARAMS ((struct fixup_replacement **, rtx));\n-static void fixup_var_refs_insns PARAMS ((rtx, rtx, enum machine_mode,\n-\t\t\t\t\t  int, int, rtx));\n-static void fixup_var_refs_insns_with_hash\n-\t\t\t\tPARAMS ((htab_t, rtx,\n-\t\t\t\t\t enum machine_mode, int, rtx));\n-static void fixup_var_refs_insn PARAMS ((rtx, rtx, enum machine_mode,\n-\t\t\t\t\t int, int, rtx));\n-static void fixup_var_refs_1\tPARAMS ((rtx, enum machine_mode, rtx *, rtx,\n-\t\t\t\t\t struct fixup_replacement **, rtx));\n-static rtx fixup_memory_subreg\tPARAMS ((rtx, rtx, enum machine_mode, int));\n-static rtx walk_fixup_memory_subreg  PARAMS ((rtx, rtx, enum machine_mode,\n-\t\t\t\t\t      int));\n-static rtx fixup_stack_1\tPARAMS ((rtx, rtx));\n-static void optimize_bit_field\tPARAMS ((rtx, rtx, rtx *));\n-static void instantiate_decls\tPARAMS ((tree, int));\n-static void instantiate_decls_1\tPARAMS ((tree, int));\n-static void instantiate_decl\tPARAMS ((rtx, HOST_WIDE_INT, int));\n-static rtx instantiate_new_reg\tPARAMS ((rtx, HOST_WIDE_INT *));\n-static int instantiate_virtual_regs_1 PARAMS ((rtx *, rtx, int));\n-static void delete_handlers\tPARAMS ((void));\n-static void pad_to_arg_alignment PARAMS ((struct args_size *, int,\n-\t\t\t\t\t  struct args_size *));\n-static void pad_below\t\tPARAMS ((struct args_size *, enum machine_mode,\n-\t\t\t\t\t tree));\n-static rtx round_trampoline_addr PARAMS ((rtx));\n-static rtx adjust_trampoline_addr PARAMS ((rtx));\n-static tree *identify_blocks_1\tPARAMS ((rtx, tree *, tree *, tree *));\n-static void reorder_blocks_0\tPARAMS ((tree));\n-static void reorder_blocks_1\tPARAMS ((rtx, tree, varray_type *));\n-static void reorder_fix_fragments PARAMS ((tree));\n-static tree blocks_nreverse\tPARAMS ((tree));\n-static int all_blocks\t\tPARAMS ((tree, tree *));\n-static tree *get_block_vector   PARAMS ((tree, int *));\n-extern tree debug_find_var_in_block_tree PARAMS ((tree, tree));\n+  *find_fixup_replacement (struct fixup_replacement **, rtx);\n+static void fixup_var_refs_insns (rtx, rtx, enum machine_mode, int, int, rtx);\n+static void fixup_var_refs_insns_with_hash (htab_t, rtx, enum machine_mode, int, rtx);\n+static void fixup_var_refs_insn (rtx, rtx, enum machine_mode, int, int, rtx);\n+static void fixup_var_refs_1 (rtx, enum machine_mode, rtx *, rtx,\n+\t\t\t      struct fixup_replacement **, rtx);\n+static rtx fixup_memory_subreg (rtx, rtx, enum machine_mode, int);\n+static rtx walk_fixup_memory_subreg (rtx, rtx, enum machine_mode, int);\n+static rtx fixup_stack_1 (rtx, rtx);\n+static void optimize_bit_field (rtx, rtx, rtx *);\n+static void instantiate_decls (tree, int);\n+static void instantiate_decls_1 (tree, int);\n+static void instantiate_decl (rtx, HOST_WIDE_INT, int);\n+static rtx instantiate_new_reg (rtx, HOST_WIDE_INT *);\n+static int instantiate_virtual_regs_1 (rtx *, rtx, int);\n+static void delete_handlers (void);\n+static void pad_to_arg_alignment (struct args_size *, int, struct args_size *);\n+static void pad_below (struct args_size *, enum machine_mode, tree);\n+static rtx round_trampoline_addr (rtx);\n+static rtx adjust_trampoline_addr (rtx);\n+static tree *identify_blocks_1 (rtx, tree *, tree *, tree *);\n+static void reorder_blocks_0 (tree);\n+static void reorder_blocks_1 (rtx, tree, varray_type *);\n+static void reorder_fix_fragments (tree);\n+static tree blocks_nreverse (tree);\n+static int all_blocks (tree, tree *);\n+static tree *get_block_vector (tree, int *);\n+extern tree debug_find_var_in_block_tree (tree, tree);\n /* We always define `record_insns' even if its not used so that we\n    can always export `prologue_epilogue_contains'.  */\n-static void record_insns\tPARAMS ((rtx, varray_type *)) ATTRIBUTE_UNUSED;\n-static int contains\t\tPARAMS ((rtx, varray_type));\n+static void record_insns (rtx, varray_type *) ATTRIBUTE_UNUSED;\n+static int contains (rtx, varray_type);\n #ifdef HAVE_return\n-static void emit_return_into_block PARAMS ((basic_block, rtx));\n+static void emit_return_into_block (basic_block, rtx);\n #endif\n-static void put_addressof_into_stack PARAMS ((rtx, htab_t));\n-static bool purge_addressof_1 PARAMS ((rtx *, rtx, int, int, int, htab_t));\n-static void purge_single_hard_subreg_set PARAMS ((rtx));\n+static void put_addressof_into_stack (rtx, htab_t);\n+static bool purge_addressof_1 (rtx *, rtx, int, int, int, htab_t);\n+static void purge_single_hard_subreg_set (rtx);\n #if defined(HAVE_epilogue) && defined(INCOMING_RETURN_ADDR_RTX)\n-static rtx keep_stack_depressed PARAMS ((rtx));\n+static rtx keep_stack_depressed (rtx);\n #endif\n-static int is_addressof\t\tPARAMS ((rtx *, void *));\n-static hashval_t insns_for_mem_hash PARAMS ((const void *));\n-static int insns_for_mem_comp PARAMS ((const void *, const void *));\n-static int insns_for_mem_walk   PARAMS ((rtx *, void *));\n-static void compute_insns_for_mem PARAMS ((rtx, rtx, htab_t));\n-static void prepare_function_start PARAMS ((void));\n-static void do_clobber_return_reg PARAMS ((rtx, void *));\n-static void do_use_return_reg PARAMS ((rtx, void *));\n-static void instantiate_virtual_regs_lossage PARAMS ((rtx));\n+static int is_addressof (rtx *, void *);\n+static hashval_t insns_for_mem_hash (const void *);\n+static int insns_for_mem_comp (const void *, const void *);\n+static int insns_for_mem_walk (rtx *, void *);\n+static void compute_insns_for_mem (rtx, rtx, htab_t);\n+static void prepare_function_start (void);\n+static void do_clobber_return_reg (rtx, void *);\n+static void do_use_return_reg (rtx, void *);\n+static void instantiate_virtual_regs_lossage (rtx);\n static tree split_complex_args (tree);\n static void set_insn_locators (rtx, int) ATTRIBUTE_UNUSED;\n \f\n@@ -312,8 +301,7 @@ static rtx postponed_insns;\n    return the `struct function' for it.  */\n \n struct function *\n-find_function_data (decl)\n-     tree decl;\n+find_function_data (tree decl)\n {\n   struct function *p;\n \n@@ -331,8 +319,7 @@ find_function_data (decl)\n    variables.  */\n \n void\n-push_function_context_to (context)\n-     tree context;\n+push_function_context_to (tree context)\n {\n   struct function *p;\n \n@@ -361,7 +348,7 @@ push_function_context_to (context)\n }\n \n void\n-push_function_context ()\n+push_function_context (void)\n {\n   push_function_context_to (current_function_decl);\n }\n@@ -370,8 +357,7 @@ push_function_context ()\n    This function is called from language-specific code.  */\n \n void\n-pop_function_context_from (context)\n-     tree context ATTRIBUTE_UNUSED;\n+pop_function_context_from (tree context ATTRIBUTE_UNUSED)\n {\n   struct function *p = outer_function_chain;\n   struct var_refs_queue *queue;\n@@ -419,7 +405,7 @@ pop_function_context_from (context)\n }\n \n void\n-pop_function_context ()\n+pop_function_context (void)\n {\n   pop_function_context_from (current_function_decl);\n }\n@@ -429,8 +415,7 @@ pop_function_context ()\n    garbage collection reclaim the memory.  */\n \n void\n-free_after_parsing (f)\n-     struct function *f;\n+free_after_parsing (struct function *f)\n {\n   /* f->expr->forced_labels is used by code generation.  */\n   /* f->emit->regno_reg_rtx is used by code generation.  */\n@@ -446,8 +431,7 @@ free_after_parsing (f)\n    reclaim the memory.  */\n \n void\n-free_after_compilation (f)\n-     struct function *f;\n+free_after_compilation (struct function *f)\n {\n   f->eh = NULL;\n   f->expr = NULL;\n@@ -494,8 +478,7 @@ free_after_compilation (f)\n    the caller may have to do that.  */\n \n HOST_WIDE_INT\n-get_func_frame_size (f)\n-     struct function *f;\n+get_func_frame_size (struct function *f)\n {\n #ifdef FRAME_GROWS_DOWNWARD\n   return -f->x_frame_offset;\n@@ -508,7 +491,7 @@ get_func_frame_size (f)\n    This size counts from zero.  It is not rounded to PREFERRED_STACK_BOUNDARY;\n    the caller may have to do that.  */\n HOST_WIDE_INT\n-get_frame_size ()\n+get_frame_size (void)\n {\n   return get_func_frame_size (cfun);\n }\n@@ -526,11 +509,8 @@ get_frame_size ()\n    FUNCTION specifies the function to allocate in.  */\n \n static rtx\n-assign_stack_local_1 (mode, size, align, function)\n-     enum machine_mode mode;\n-     HOST_WIDE_INT size;\n-     int align;\n-     struct function *function;\n+assign_stack_local_1 (enum machine_mode mode, HOST_WIDE_INT size, int align,\n+\t\t      struct function *function)\n {\n   rtx x, addr;\n   int bigend_correction = 0;\n@@ -635,10 +615,7 @@ assign_stack_local_1 (mode, size, align, function)\n    current function.  */\n \n rtx\n-assign_stack_local (mode, size, align)\n-     enum machine_mode mode;\n-     HOST_WIDE_INT size;\n-     int align;\n+assign_stack_local (enum machine_mode mode, HOST_WIDE_INT size, int align)\n {\n   return assign_stack_local_1 (mode, size, align, cfun);\n }\n@@ -661,11 +638,8 @@ assign_stack_local (mode, size, align)\n    TYPE is the type that will be used for the stack slot.  */\n \n rtx\n-assign_stack_temp_for_type (mode, size, keep, type)\n-     enum machine_mode mode;\n-     HOST_WIDE_INT size;\n-     int keep;\n-     tree type;\n+assign_stack_temp_for_type (enum machine_mode mode, HOST_WIDE_INT size, int keep,\n+\t\t\t    tree type)\n {\n   unsigned int align;\n   struct temp_slot *p, *best_p = 0;\n@@ -829,7 +803,7 @@ assign_stack_temp_for_type (mode, size, keep, type)\n   /* If a type is specified, set the relevant flags.  */\n   if (type != 0)\n     {\n-      RTX_UNCHANGING_P (slot) = (lang_hooks.honor_readonly \n+      RTX_UNCHANGING_P (slot) = (lang_hooks.honor_readonly\n \t\t\t\t && TYPE_READONLY (type));\n       MEM_VOLATILE_P (slot) = TYPE_VOLATILE (type);\n       MEM_SET_IN_STRUCT_P (slot, AGGREGATE_TYPE_P (type));\n@@ -842,10 +816,7 @@ assign_stack_temp_for_type (mode, size, keep, type)\n    reuse.  First three arguments are same as in preceding function.  */\n \n rtx\n-assign_stack_temp (mode, size, keep)\n-     enum machine_mode mode;\n-     HOST_WIDE_INT size;\n-     int keep;\n+assign_stack_temp (enum machine_mode mode, HOST_WIDE_INT size, int keep)\n {\n   return assign_stack_temp_for_type (mode, size, keep, NULL_TREE);\n }\n@@ -861,11 +832,8 @@ assign_stack_temp (mode, size, keep)\n    to wider modes.  */\n \n rtx\n-assign_temp (type_or_decl, keep, memory_required, dont_promote)\n-     tree type_or_decl;\n-     int keep;\n-     int memory_required;\n-     int dont_promote ATTRIBUTE_UNUSED;\n+assign_temp (tree type_or_decl, int keep, int memory_required,\n+\t     int dont_promote ATTRIBUTE_UNUSED)\n {\n   tree type, decl;\n   enum machine_mode mode;\n@@ -932,7 +900,7 @@ assign_temp (type_or_decl, keep, memory_required, dont_promote)\n    problems in this case.  */\n \n void\n-combine_temp_slots ()\n+combine_temp_slots (void)\n {\n   struct temp_slot *p, *q;\n   struct temp_slot *prev_p, *prev_q;\n@@ -998,8 +966,7 @@ combine_temp_slots ()\n /* Find the temp slot corresponding to the object at address X.  */\n \n static struct temp_slot *\n-find_temp_slot_from_address (x)\n-     rtx x;\n+find_temp_slot_from_address (rtx x)\n {\n   struct temp_slot *p;\n   rtx next;\n@@ -1040,8 +1007,7 @@ find_temp_slot_from_address (x)\n    that previously was known by OLD.  */\n \n void\n-update_temp_slot_address (old, new)\n-     rtx old, new;\n+update_temp_slot_address (rtx old, rtx new)\n {\n   struct temp_slot *p;\n \n@@ -1097,8 +1063,7 @@ update_temp_slot_address (old, new)\n    address was taken.  */\n \n void\n-mark_temp_addr_taken (x)\n-     rtx x;\n+mark_temp_addr_taken (rtx x)\n {\n   struct temp_slot *p;\n \n@@ -1125,8 +1090,7 @@ mark_temp_addr_taken (x)\n    returns a value in memory.  */\n \n void\n-preserve_temp_slots (x)\n-     rtx x;\n+preserve_temp_slots (rtx x)\n {\n   struct temp_slot *p = 0;\n \n@@ -1194,8 +1158,7 @@ preserve_temp_slots (x)\n    RTL_EXPR.  */\n \n void\n-preserve_rtl_expr_result (x)\n-     rtx x;\n+preserve_rtl_expr_result (rtx x)\n {\n   struct temp_slot *p;\n \n@@ -1224,7 +1187,7 @@ preserve_rtl_expr_result (x)\n    worthwhile.  */\n \n void\n-free_temp_slots ()\n+free_temp_slots (void)\n {\n   struct temp_slot *p;\n \n@@ -1239,8 +1202,7 @@ free_temp_slots ()\n /* Free all temporary slots used in T, an RTL_EXPR node.  */\n \n void\n-free_temps_for_rtl_expr (t)\n-     tree t;\n+free_temps_for_rtl_expr (tree t)\n {\n   struct temp_slot *p;\n \n@@ -1264,7 +1226,7 @@ free_temps_for_rtl_expr (t)\n    for reuse until the current level is exited.  */\n \n void\n-mark_all_temps_used ()\n+mark_all_temps_used (void)\n {\n   struct temp_slot *p;\n \n@@ -1278,7 +1240,7 @@ mark_all_temps_used ()\n /* Push deeper into the nesting level for stack temporaries.  */\n \n void\n-push_temp_slots ()\n+push_temp_slots (void)\n {\n   temp_slot_level++;\n }\n@@ -1287,7 +1249,7 @@ push_temp_slots ()\n    are freed.  */\n \n void\n-pop_temp_slots ()\n+pop_temp_slots (void)\n {\n   struct temp_slot *p;\n \n@@ -1303,7 +1265,7 @@ pop_temp_slots ()\n /* Initialize temporary slots.  */\n \n void\n-init_temp_slots ()\n+init_temp_slots (void)\n {\n   /* We have not allocated any temporaries yet.  */\n   temp_slots = 0;\n@@ -1319,9 +1281,7 @@ init_temp_slots ()\n    addressable.  */\n \n void\n-put_var_into_stack (decl, rescan)\n-     tree decl;\n-     int rescan;\n+put_var_into_stack (tree decl, int rescan)\n {\n   rtx reg;\n   enum machine_mode promoted_mode, decl_mode;\n@@ -1463,16 +1423,9 @@ put_var_into_stack (decl, rescan)\n    USED_P is nonzero if this reg might have already been used in an insn.  */\n \n static void\n-put_reg_into_stack (function, reg, type, promoted_mode, decl_mode, volatile_p,\n-\t\t    original_regno, used_p, ht)\n-     struct function *function;\n-     rtx reg;\n-     tree type;\n-     enum machine_mode promoted_mode, decl_mode;\n-     int volatile_p;\n-     unsigned int original_regno;\n-     int used_p;\n-     htab_t ht;\n+put_reg_into_stack (struct function *function, rtx reg, tree type,\n+\t\t    enum machine_mode promoted_mode, enum machine_mode decl_mode,\n+\t\t    int volatile_p, unsigned int original_regno, int used_p, htab_t ht)\n {\n   struct function *func = function ? function : cfun;\n   rtx new = 0;\n@@ -1515,12 +1468,8 @@ put_reg_into_stack (function, reg, type, promoted_mode, decl_mode, volatile_p,\n    See function above for meaning of arguments.  */\n \n static void\n-schedule_fixup_var_refs (function, reg, type, promoted_mode, ht)\n-     struct function *function;\n-     rtx reg;\n-     tree type;\n-     enum machine_mode promoted_mode;\n-     htab_t ht;\n+schedule_fixup_var_refs (struct function *function, rtx reg, tree type,\n+\t\t\t enum machine_mode promoted_mode, htab_t ht)\n {\n   int unsigned_p = type ? TREE_UNSIGNED (type) : 0;\n \n@@ -1542,12 +1491,8 @@ schedule_fixup_var_refs (function, reg, type, promoted_mode, ht)\n }\n \f\n static void\n-fixup_var_refs (var, promoted_mode, unsignedp, may_share, ht)\n-     rtx var;\n-     enum machine_mode promoted_mode;\n-     int unsignedp;\n-     htab_t ht;\n-     rtx may_share;\n+fixup_var_refs (rtx var, enum machine_mode promoted_mode, int unsignedp,\n+\t\trtx may_share, htab_t ht)\n {\n   tree pending;\n   rtx first_insn = get_insns ();\n@@ -1598,9 +1543,7 @@ fixup_var_refs (var, promoted_mode, unsignedp, may_share, ht)\n    value is equal to X.  Allocate a new structure if no such entry exists.  */\n \n static struct fixup_replacement *\n-find_fixup_replacement (replacements, x)\n-     struct fixup_replacement **replacements;\n-     rtx x;\n+find_fixup_replacement (struct fixup_replacement **replacements, rtx x)\n {\n   struct fixup_replacement *p;\n \n@@ -1626,13 +1569,8 @@ find_fixup_replacement (replacements, x)\n    to be unshared or a list of them.  */\n \n static void\n-fixup_var_refs_insns (insn, var, promoted_mode, unsignedp, toplevel, may_share)\n-     rtx insn;\n-     rtx var;\n-     enum machine_mode promoted_mode;\n-     int unsignedp;\n-     int toplevel;\n-     rtx may_share;\n+fixup_var_refs_insns (rtx insn, rtx var, enum machine_mode promoted_mode,\n+\t\t      int unsignedp, int toplevel, rtx may_share)\n {\n   while (insn)\n     {\n@@ -1681,12 +1619,8 @@ fixup_var_refs_insns (insn, var, promoted_mode, unsignedp, toplevel, may_share)\n    (inside the CALL_PLACEHOLDER).  */\n \n static void\n-fixup_var_refs_insns_with_hash (ht, var, promoted_mode, unsignedp, may_share)\n-     htab_t ht;\n-     rtx var;\n-     enum machine_mode promoted_mode;\n-     int unsignedp;\n-     rtx may_share;\n+fixup_var_refs_insns_with_hash (htab_t ht, rtx var, enum machine_mode promoted_mode,\n+\t\t\t\tint unsignedp, rtx may_share)\n {\n   struct insns_for_mem_entry tmp;\n   struct insns_for_mem_entry *ime;\n@@ -1708,13 +1642,8 @@ fixup_var_refs_insns_with_hash (ht, var, promoted_mode, unsignedp, may_share)\n    function.  */\n \n static void\n-fixup_var_refs_insn (insn, var, promoted_mode, unsignedp, toplevel, no_share)\n-     rtx insn;\n-     rtx var;\n-     enum machine_mode promoted_mode;\n-     int unsignedp;\n-     int toplevel;\n-     rtx no_share;\n+fixup_var_refs_insn (rtx insn, rtx var, enum machine_mode promoted_mode,\n+\t\t     int unsignedp, int toplevel, rtx no_share)\n {\n   rtx call_dest = 0;\n   rtx set, prev, prev_set;\n@@ -1898,13 +1827,8 @@ fixup_var_refs_insn (insn, var, promoted_mode, unsignedp, toplevel, no_share)\n    or the SUBREG, as appropriate, to the pseudo.  */\n \n static void\n-fixup_var_refs_1 (var, promoted_mode, loc, insn, replacements, no_share)\n-     rtx var;\n-     enum machine_mode promoted_mode;\n-     rtx *loc;\n-     rtx insn;\n-     struct fixup_replacement **replacements;\n-     rtx no_share;\n+fixup_var_refs_1 (rtx var, enum machine_mode promoted_mode, rtx *loc, rtx insn,\n+\t\t  struct fixup_replacement **replacements, rtx no_share)\n {\n   int i;\n   rtx x = *loc;\n@@ -2523,11 +2447,7 @@ fixup_var_refs_1 (var, promoted_mode, loc, insn, replacements, no_share)\n    This is used for subregs found inside REG_NOTES.  */\n \n static rtx\n-fixup_memory_subreg (x, insn, promoted_mode, uncritical)\n-     rtx x;\n-     rtx insn;\n-     enum machine_mode promoted_mode;\n-     int uncritical;\n+fixup_memory_subreg (rtx x, rtx insn, enum machine_mode promoted_mode, int uncritical)\n {\n   int offset;\n   rtx mem = SUBREG_REG (x);\n@@ -2569,11 +2489,8 @@ fixup_memory_subreg (x, insn, promoted_mode, uncritical)\n    fixup_memory_subreg.  */\n \n static rtx\n-walk_fixup_memory_subreg (x, insn, promoted_mode, uncritical)\n-     rtx x;\n-     rtx insn;\n-     enum machine_mode promoted_mode;\n-     int uncritical;\n+walk_fixup_memory_subreg (rtx x, rtx insn, enum machine_mode promoted_mode,\n+\t\t\t  int uncritical)\n {\n   enum rtx_code code;\n   const char *fmt;\n@@ -2614,9 +2531,7 @@ walk_fixup_memory_subreg (x, insn, promoted_mode, uncritical)\n    Replace each such MEM rtx with a copy, to avoid clobberage.  */\n \n static rtx\n-fixup_stack_1 (x, insn)\n-     rtx x;\n-     rtx insn;\n+fixup_stack_1 (rtx x, rtx insn)\n {\n   int i;\n   RTX_CODE code = GET_CODE (x);\n@@ -2681,10 +2596,7 @@ fixup_stack_1 (x, insn)\n    is always 0.)  */\n \n static void\n-optimize_bit_field (body, insn, equiv_mem)\n-     rtx body;\n-     rtx insn;\n-     rtx *equiv_mem;\n+optimize_bit_field (rtx body, rtx insn, rtx *equiv_mem)\n {\n   rtx bitfield;\n   int destflag;\n@@ -2892,10 +2804,7 @@ static int cfa_offset;\n    been transformed.  */\n \n rtx\n-gen_mem_addressof (reg, decl, rescan)\n-     rtx reg;\n-     tree decl;\n-     int rescan;\n+gen_mem_addressof (rtx reg, tree decl, int rescan)\n {\n   rtx r = gen_rtx_ADDRESSOF (Pmode, gen_reg_rtx (GET_MODE (reg)),\n \t\t\t     REGNO (reg), decl);\n@@ -2933,7 +2842,7 @@ gen_mem_addressof (reg, decl, rescan)\n       if (DECL_P (decl) && decl_rtl == reg)\n \tSET_DECL_RTL (decl, reg);\n \n-      if (rescan \n+      if (rescan\n \t  && (TREE_USED (decl) || (DECL_P (decl) && DECL_INITIAL (decl) != 0)))\n \tfixup_var_refs (reg, GET_MODE (reg), TREE_UNSIGNED (type), reg, 0);\n     }\n@@ -2946,8 +2855,7 @@ gen_mem_addressof (reg, decl, rescan)\n /* If DECL has an RTL that is an ADDRESSOF rtx, put it into the stack.  */\n \n void\n-flush_addressof (decl)\n-     tree decl;\n+flush_addressof (tree decl)\n {\n   if ((TREE_CODE (decl) == PARM_DECL || TREE_CODE (decl) == VAR_DECL)\n       && DECL_RTL (decl) != 0\n@@ -2960,9 +2868,7 @@ flush_addressof (decl)\n /* Force the register pointed to by R, an ADDRESSOF rtx, into the stack.  */\n \n static void\n-put_addressof_into_stack (r, ht)\n-     rtx r;\n-     htab_t ht;\n+put_addressof_into_stack (rtx r, htab_t ht)\n {\n   tree decl, type;\n   int volatile_p, used_p;\n@@ -3011,11 +2917,8 @@ static rtx purge_addressof_replacements;\n    to stack, postpone processing of the insn.  */\n \n static bool\n-purge_addressof_1 (loc, insn, force, store, may_postpone, ht)\n-     rtx *loc;\n-     rtx insn;\n-     int force, store, may_postpone;\n-     htab_t ht;\n+purge_addressof_1 (rtx *loc, rtx insn, int force, int store, int may_postpone,\n+\t\t   htab_t ht)\n {\n   rtx x;\n   RTX_CODE code;\n@@ -3059,7 +2962,7 @@ purge_addressof_1 (loc, insn, force, store, may_postpone, ht)\n \n       start_sequence ();\n \n-      /* If SUB is a hard or virtual register, try it as a pseudo-register. \n+      /* If SUB is a hard or virtual register, try it as a pseudo-register.\n \t Otherwise, perhaps SUB is an expression, so generate code to compute\n \t it.  */\n       if (GET_CODE (sub) == REG && REGNO (sub) <= LAST_VIRTUAL_REGISTER)\n@@ -3332,8 +3235,7 @@ purge_addressof_1 (loc, insn, force, store, may_postpone, ht)\n /* Return a hash value for K, a REG.  */\n \n static hashval_t\n-insns_for_mem_hash (k)\n-     const void * k;\n+insns_for_mem_hash (const void *k)\n {\n   /* Use the address of the key for the hash value.  */\n   struct insns_for_mem_entry *m = (struct insns_for_mem_entry *) k;\n@@ -3343,9 +3245,7 @@ insns_for_mem_hash (k)\n /* Return nonzero if K1 and K2 (two REGs) are the same.  */\n \n static int\n-insns_for_mem_comp (k1, k2)\n-     const void * k1;\n-     const void * k2;\n+insns_for_mem_comp (const void *k1, const void *k2)\n {\n   struct insns_for_mem_entry *m1 = (struct insns_for_mem_entry *) k1;\n   struct insns_for_mem_entry *m2 = (struct insns_for_mem_entry *) k2;\n@@ -3372,9 +3272,7 @@ struct insns_for_mem_walk_info\n    insns_for_mem_walk_info structure).  */\n \n static int\n-insns_for_mem_walk (r, data)\n-     rtx *r;\n-     void *data;\n+insns_for_mem_walk (rtx *r, void *data)\n {\n   struct insns_for_mem_walk_info *ifmwi\n     = (struct insns_for_mem_walk_info *) data;\n@@ -3414,10 +3312,7 @@ insns_for_mem_walk (r, data)\n    which REGs in HT.  */\n \n static void\n-compute_insns_for_mem (insns, last_insn, ht)\n-     rtx insns;\n-     rtx last_insn;\n-     htab_t ht;\n+compute_insns_for_mem (rtx insns, rtx last_insn, htab_t ht)\n {\n   rtx insn;\n   struct insns_for_mem_walk_info ifmwi;\n@@ -3436,9 +3331,7 @@ compute_insns_for_mem (insns, last_insn, ht)\n    Returns true iff the rtl is an ADDRESSOF.  */\n \n static int\n-is_addressof (rtl, data)\n-     rtx *rtl;\n-     void *data ATTRIBUTE_UNUSED;\n+is_addressof (rtx *rtl, void *data ATTRIBUTE_UNUSED)\n {\n   return GET_CODE (*rtl) == ADDRESSOF;\n }\n@@ -3448,8 +3341,7 @@ is_addressof (rtl, data)\n    stack.  */\n \n void\n-purge_addressof (insns)\n-     rtx insns;\n+purge_addressof (rtx insns)\n {\n   rtx insn, tmp;\n   htab_t ht;\n@@ -3531,8 +3423,7 @@ purge_addressof (insns)\n    register.  A subroutine of purge_hard_subreg_sets.  */\n \n static void\n-purge_single_hard_subreg_set (pattern)\n-     rtx pattern;\n+purge_single_hard_subreg_set (rtx pattern)\n {\n   rtx reg = SET_DEST (pattern);\n   enum machine_mode mode = GET_MODE (SET_DEST (pattern));\n@@ -3564,8 +3455,7 @@ purge_single_hard_subreg_set (pattern)\n    of hard registers.  */\n \n void\n-purge_hard_subreg_sets (insn)\n-     rtx insn;\n+purge_hard_subreg_sets (rtx insn)\n {\n   for (; insn; insn = NEXT_INSN (insn))\n     {\n@@ -3601,9 +3491,7 @@ purge_hard_subreg_sets (insn)\n    references to hard register references.  */\n \n void\n-instantiate_virtual_regs (fndecl, insns)\n-     tree fndecl;\n-     rtx insns;\n+instantiate_virtual_regs (tree fndecl, rtx insns)\n {\n   rtx insn;\n   unsigned int i;\n@@ -3668,9 +3556,7 @@ instantiate_virtual_regs (fndecl, insns)\n    Otherwise, always do it.  */\n \n static void\n-instantiate_decls (fndecl, valid_only)\n-     tree fndecl;\n-     int valid_only;\n+instantiate_decls (tree fndecl, int valid_only)\n {\n   tree decl;\n \n@@ -3698,9 +3584,7 @@ instantiate_decls (fndecl, valid_only)\n    BLOCK node and all its subblocks.  */\n \n static void\n-instantiate_decls_1 (let, valid_only)\n-     tree let;\n-     int valid_only;\n+instantiate_decls_1 (tree let, int valid_only)\n {\n   tree t;\n \n@@ -3722,10 +3606,7 @@ instantiate_decls_1 (let, valid_only)\n    changed if the new address is valid.  */\n \n static void\n-instantiate_decl (x, size, valid_only)\n-     rtx x;\n-     HOST_WIDE_INT size;\n-     int valid_only;\n+instantiate_decl (rtx x, HOST_WIDE_INT size, int valid_only)\n {\n   enum machine_mode mode;\n   rtx addr;\n@@ -3787,9 +3668,7 @@ instantiate_decl (x, size, valid_only)\n    offset indirectly through the pointer.  Otherwise, return 0.  */\n \n static rtx\n-instantiate_new_reg (x, poffset)\n-     rtx x;\n-     HOST_WIDE_INT *poffset;\n+instantiate_new_reg (rtx x, HOST_WIDE_INT *poffset)\n {\n   rtx new;\n   HOST_WIDE_INT offset;\n@@ -3816,8 +3695,7 @@ instantiate_new_reg (x, poffset)\n    Usually this means that non-matching instruction has been emit, however for\n    asm statements it may be the problem in the constraints.  */\n static void\n-instantiate_virtual_regs_lossage (insn)\n-     rtx insn;\n+instantiate_virtual_regs_lossage (rtx insn)\n {\n   if (asm_noperands (PATTERN (insn)) >= 0)\n     {\n@@ -3842,10 +3720,7 @@ instantiate_virtual_regs_lossage (insn)\n    pseudos.  */\n \n static int\n-instantiate_virtual_regs_1 (loc, object, extra_insns)\n-     rtx *loc;\n-     rtx object;\n-     int extra_insns;\n+instantiate_virtual_regs_1 (rtx *loc, rtx object, int extra_insns)\n {\n   rtx x;\n   RTX_CODE code;\n@@ -4238,7 +4113,7 @@ instantiate_virtual_regs_1 (loc, object, extra_insns)\n    and disestablish them.  */\n \n static void\n-delete_handlers ()\n+delete_handlers (void)\n {\n   rtx insn;\n   for (insn = get_insns (); insn; insn = NEXT_INSN (insn))\n@@ -4289,7 +4164,7 @@ delete_handlers ()\n /* Return the first insn following those generated by `assign_parms'.  */\n \n rtx\n-get_first_nonparm_insn ()\n+get_first_nonparm_insn (void)\n {\n   if (last_parm_insn)\n     return NEXT_INSN (last_parm_insn);\n@@ -4302,8 +4177,7 @@ get_first_nonparm_insn ()\n    EXP may be a type node or an expression (whose type is tested).  */\n \n int\n-aggregate_value_p (exp)\n-     tree exp;\n+aggregate_value_p (tree exp)\n {\n   int i, regno, nregs;\n   rtx reg;\n@@ -4342,8 +4216,7 @@ aggregate_value_p (exp)\n    those registers as the RTL for them.  */\n \n void\n-assign_parms (fndecl)\n-     tree fndecl;\n+assign_parms (tree fndecl)\n {\n   tree parm;\n   CUMULATIVE_ARGS args_so_far;\n@@ -5206,7 +5079,7 @@ assign_parms (fndecl)\n       for (; parm; parm = TREE_CHAIN (parm))\n \t{\n \t  tree type = TREE_TYPE (parm);\n-\t  \n+\n \t  if (TREE_CODE (type) == COMPLEX_TYPE)\n \t    {\n \t      SET_DECL_RTL (parm,\n@@ -5241,12 +5114,12 @@ assign_parms (fndecl)\n       tree result = DECL_RESULT (fndecl);\n       rtx addr = DECL_RTL (function_result_decl);\n       rtx x;\n-      \n+\n #ifdef POINTERS_EXTEND_UNSIGNED\n       if (GET_MODE (addr) != Pmode)\n \taddr = convert_memory_address (Pmode, addr);\n #endif\n-      \n+\n       x = gen_rtx_MEM (DECL_MODE (result), addr);\n       set_mem_attributes (x, result, 1);\n       SET_DECL_RTL (result, x);\n@@ -5371,10 +5244,7 @@ split_complex_args (tree args)\n #ifdef PROMOTE_FUNCTION_ARGS\n \n rtx\n-promoted_input_arg (regno, pmode, punsignedp)\n-     unsigned int regno;\n-     enum machine_mode *pmode;\n-     int *punsignedp;\n+promoted_input_arg (unsigned int regno, enum machine_mode *pmode, int *punsignedp)\n {\n   tree arg;\n \n@@ -5435,15 +5305,10 @@ promoted_input_arg (regno, pmode, punsignedp)\n     INITIAL_OFFSET_PTR.  LOCATE->SIZE is always positive.  */\n \n void\n-locate_and_pad_parm (passed_mode, type, in_regs, partial, fndecl,\n-\t\t     initial_offset_ptr, locate)\n-     enum machine_mode passed_mode;\n-     tree type;\n-     int in_regs;\n-     int partial;\n-     tree fndecl ATTRIBUTE_UNUSED;\n-     struct args_size *initial_offset_ptr;\n-     struct locate_and_pad_arg_data *locate;\n+locate_and_pad_parm (enum machine_mode passed_mode, tree type, int in_regs,\n+\t\t     int partial, tree fndecl ATTRIBUTE_UNUSED,\n+\t\t     struct args_size *initial_offset_ptr,\n+\t\t     struct locate_and_pad_arg_data *locate)\n {\n   tree sizetree;\n   enum direction where_pad;\n@@ -5564,10 +5429,8 @@ locate_and_pad_parm (passed_mode, type, in_regs, partial, fndecl,\n    BOUNDARY is measured in bits, but must be a multiple of a storage unit.  */\n \n static void\n-pad_to_arg_alignment (offset_ptr, boundary, alignment_pad)\n-     struct args_size *offset_ptr;\n-     int boundary;\n-     struct args_size *alignment_pad;\n+pad_to_arg_alignment (struct args_size *offset_ptr, int boundary,\n+\t\t      struct args_size *alignment_pad)\n {\n   tree save_var = NULL_TREE;\n   HOST_WIDE_INT save_constant = 0;\n@@ -5616,10 +5479,7 @@ pad_to_arg_alignment (offset_ptr, boundary, alignment_pad)\n }\n \n static void\n-pad_below (offset_ptr, passed_mode, sizetree)\n-     struct args_size *offset_ptr;\n-     enum machine_mode passed_mode;\n-     tree sizetree;\n+pad_below (struct args_size *offset_ptr, enum machine_mode passed_mode, tree sizetree)\n {\n   if (passed_mode != BLKmode)\n     {\n@@ -5649,8 +5509,7 @@ pad_below (offset_ptr, passed_mode, sizetree)\n    clobbers the pseudo-regs to hard regs.  */\n \n void\n-uninitialized_vars_warning (block)\n-     tree block;\n+uninitialized_vars_warning (tree block)\n {\n   tree decl, sub;\n   for (decl = BLOCK_VARS (block); decl; decl = TREE_CHAIN (decl))\n@@ -5691,7 +5550,7 @@ uninitialized_vars_warning (block)\n    but for arguments instead of local variables.  */\n \n void\n-setjmp_args_warning ()\n+setjmp_args_warning (void)\n {\n   tree decl;\n   for (decl = DECL_ARGUMENTS (current_function_decl);\n@@ -5707,8 +5566,7 @@ setjmp_args_warning ()\n    unless they were declared `register'.  */\n \n void\n-setjmp_protect (block)\n-     tree block;\n+setjmp_protect (tree block)\n {\n   tree decl, sub;\n   for (decl = BLOCK_VARS (block); decl; decl = TREE_CHAIN (decl))\n@@ -5740,7 +5598,7 @@ setjmp_protect (block)\n /* Like the previous function, but for args instead of local variables.  */\n \n void\n-setjmp_protect_args ()\n+setjmp_protect_args (void)\n {\n   tree decl;\n   for (decl = DECL_ARGUMENTS (current_function_decl);\n@@ -5766,8 +5624,7 @@ setjmp_protect_args ()\n    or 0 if it does not need one.  */\n \n rtx\n-lookup_static_chain (decl)\n-     tree decl;\n+lookup_static_chain (tree decl)\n {\n   tree context = decl_function_context (decl);\n   tree link;\n@@ -5795,9 +5652,7 @@ lookup_static_chain (decl)\n    into an address valid in this function (using a static chain).  */\n \n rtx\n-fix_lexical_addr (addr, var)\n-     rtx addr;\n-     tree var;\n+fix_lexical_addr (rtx addr, tree var)\n {\n   rtx basereg;\n   HOST_WIDE_INT displacement;\n@@ -5878,8 +5733,7 @@ fix_lexical_addr (addr, var)\n    and emit rtl to initialize its contents (at entry to this function).  */\n \n rtx\n-trampoline_address (function)\n-     tree function;\n+trampoline_address (tree function)\n {\n   tree link;\n   tree rtlexp;\n@@ -5945,8 +5799,7 @@ trampoline_address (function)\n    round it to multiple of TRAMPOLINE_ALIGNMENT.  */\n \n static rtx\n-round_trampoline_addr (tramp)\n-     rtx tramp;\n+round_trampoline_addr (rtx tramp)\n {\n   /* Round address up to desired boundary.  */\n   rtx temp = gen_reg_rtx (Pmode);\n@@ -5966,8 +5819,7 @@ round_trampoline_addr (tramp)\n    function call .  */\n \n static rtx\n-adjust_trampoline_addr (tramp)\n-     rtx tramp;\n+adjust_trampoline_addr (rtx tramp)\n {\n   tramp = round_trampoline_addr (tramp);\n #ifdef TRAMPOLINE_ADJUST_ADDRESS\n@@ -5984,7 +5836,7 @@ adjust_trampoline_addr (tramp)\n    and INSNS, the insn chain of the function.  */\n \n void\n-identify_blocks ()\n+identify_blocks (void)\n {\n   int n_blocks;\n   tree *block_vector, *last_block_vector;\n@@ -6020,11 +5872,8 @@ identify_blocks ()\n    BLOCK_VECTOR is incremented for each block seen.  */\n \n static tree *\n-identify_blocks_1 (insns, block_vector, end_block_vector, orig_block_stack)\n-     rtx insns;\n-     tree *block_vector;\n-     tree *end_block_vector;\n-     tree *orig_block_stack;\n+identify_blocks_1 (rtx insns, tree *block_vector, tree *end_block_vector,\n+\t\t   tree *orig_block_stack)\n {\n   rtx insn;\n   tree *block_stack = orig_block_stack;\n@@ -6087,7 +5936,7 @@ identify_blocks_1 (insns, block_vector, end_block_vector, orig_block_stack)\n    on what optimization has been performed.  */\n \n void\n-reorder_blocks ()\n+reorder_blocks (void)\n {\n   tree block = DECL_INITIAL (current_function_decl);\n   varray_type block_stack;\n@@ -6115,8 +5964,7 @@ reorder_blocks ()\n /* Helper function for reorder_blocks.  Reset TREE_ASM_WRITTEN.  */\n \n static void\n-reorder_blocks_0 (block)\n-     tree block;\n+reorder_blocks_0 (tree block)\n {\n   while (block)\n     {\n@@ -6127,10 +5975,7 @@ reorder_blocks_0 (block)\n }\n \n static void\n-reorder_blocks_1 (insns, current_block, p_block_stack)\n-     rtx insns;\n-     tree current_block;\n-     varray_type *p_block_stack;\n+reorder_blocks_1 (rtx insns, tree current_block, varray_type *p_block_stack)\n {\n   rtx insn;\n \n@@ -6202,8 +6047,7 @@ reorder_blocks_1 (insns, current_block, p_block_stack)\n    the new origin block.  */\n \n static void\n-reorder_fix_fragments (block)\n-     tree block;\n+reorder_fix_fragments (tree block)\n {\n   while (block)\n     {\n@@ -6257,8 +6101,7 @@ reorder_fix_fragments (block)\n    and return the new head of the chain (old last element).  */\n \n static tree\n-blocks_nreverse (t)\n-     tree t;\n+blocks_nreverse (tree t)\n {\n   tree prev = 0, decl, next;\n   for (decl = t; decl; decl = next)\n@@ -6276,9 +6119,7 @@ blocks_nreverse (t)\n    blocks.  */\n \n static int\n-all_blocks (block, vector)\n-     tree block;\n-     tree *vector;\n+all_blocks (tree block, tree *vector)\n {\n   int n_blocks = 0;\n \n@@ -6307,9 +6148,7 @@ all_blocks (block, vector)\n    to call `free' on the pointer returned.  */\n \n static tree *\n-get_block_vector (block, n_blocks_p)\n-     tree block;\n-     int *n_blocks_p;\n+get_block_vector (tree block, int *n_blocks_p)\n {\n   tree *block_vector;\n \n@@ -6325,8 +6164,7 @@ static GTY(()) int next_block_index = 2;\n /* Set BLOCK_NUMBER for all the blocks in FN.  */\n \n void\n-number_blocks (fn)\n-     tree fn;\n+number_blocks (tree fn)\n {\n   int i;\n   int n_blocks;\n@@ -6355,9 +6193,7 @@ number_blocks (fn)\n /* If VAR is present in a subblock of BLOCK, return the subblock.  */\n \n tree\n-debug_find_var_in_block_tree (var, block)\n-     tree var;\n-     tree block;\n+debug_find_var_in_block_tree (tree var, tree block)\n {\n   tree t;\n \n@@ -6378,7 +6214,7 @@ debug_find_var_in_block_tree (var, block)\n /* Allocate a function structure and reset its contents to the defaults.  */\n \n static void\n-prepare_function_start ()\n+prepare_function_start (void)\n {\n   cfun = (struct function *) ggc_alloc_cleared (sizeof (struct function));\n \n@@ -6512,7 +6348,7 @@ prepare_function_start ()\n    like generate sequences.  This is used to provide a context during global\n    initialization of some passes.  */\n void\n-init_dummy_function_start ()\n+init_dummy_function_start (void)\n {\n   prepare_function_start ();\n }\n@@ -6522,8 +6358,7 @@ init_dummy_function_start ()\n    of the function.  */\n \n void\n-init_function_start (subr)\n-     tree subr;\n+init_function_start (tree subr)\n {\n   prepare_function_start ();\n \n@@ -6573,7 +6408,7 @@ init_function_start (subr)\n /* Make sure all values used by the optimization passes have sane\n    defaults.  */\n void\n-init_function_for_compilation ()\n+init_function_for_compilation (void)\n {\n   reg_renumber = 0;\n \n@@ -6591,7 +6426,7 @@ init_function_for_compilation ()\n #endif\n \n void\n-expand_main_function ()\n+expand_main_function (void)\n {\n #ifdef FORCE_PREFERRED_STACK_BOUNDARY_IN_MAIN\n   if (FORCE_PREFERRED_STACK_BOUNDARY_IN_MAIN)\n@@ -6641,8 +6476,7 @@ expand_main_function ()\n    TREE_VALUE of each node is a SAVE_EXPR.  */\n \n void\n-expand_pending_sizes (pending_sizes)\n-     tree pending_sizes;\n+expand_pending_sizes (tree pending_sizes)\n {\n   tree tem;\n \n@@ -6663,9 +6497,7 @@ expand_pending_sizes (pending_sizes)\n    the function's parameters, which must be run at any return statement.  */\n \n void\n-expand_function_start (subr, parms_have_cleanups)\n-     tree subr;\n-     int parms_have_cleanups;\n+expand_function_start (tree subr, int parms_have_cleanups)\n {\n   tree tem;\n   rtx last_ptr = NULL_RTX;\n@@ -6879,7 +6711,7 @@ expand_function_start (subr, parms_have_cleanups)\n \f\n /* Undo the effects of init_dummy_function_start.  */\n void\n-expand_dummy_function_end ()\n+expand_dummy_function_end (void)\n {\n   /* End any sequences that failed to be closed due to syntax errors.  */\n   while (in_sequence_p ())\n@@ -6897,9 +6729,7 @@ expand_dummy_function_end ()\n    the current function.  */\n \n void\n-diddle_return_value (doit, arg)\n-     void (*doit) PARAMS ((rtx, void *));\n-     void *arg;\n+diddle_return_value (void (*doit) (rtx, void *), void *arg)\n {\n   rtx outgoing = current_function_return_rtx;\n \n@@ -6923,15 +6753,13 @@ diddle_return_value (doit, arg)\n }\n \n static void\n-do_clobber_return_reg (reg, arg)\n-     rtx reg;\n-     void *arg ATTRIBUTE_UNUSED;\n+do_clobber_return_reg (rtx reg, void *arg ATTRIBUTE_UNUSED)\n {\n   emit_insn (gen_rtx_CLOBBER (VOIDmode, reg));\n }\n \n void\n-clobber_return_register ()\n+clobber_return_register (void)\n {\n   diddle_return_value (do_clobber_return_reg, NULL);\n \n@@ -6948,15 +6776,13 @@ clobber_return_register ()\n }\n \n static void\n-do_use_return_reg (reg, arg)\n-     rtx reg;\n-     void *arg ATTRIBUTE_UNUSED;\n+do_use_return_reg (rtx reg, void *arg ATTRIBUTE_UNUSED)\n {\n   emit_insn (gen_rtx_USE (VOIDmode, reg));\n }\n \n void\n-use_return_register ()\n+use_return_register (void)\n {\n   diddle_return_value (do_use_return_reg, NULL);\n }\n@@ -6966,7 +6792,7 @@ static GTY(()) rtx initial_trampoline;\n /* Generate RTL for the end of the current function.  */\n \n void\n-expand_function_end ()\n+expand_function_end (void)\n {\n   tree link;\n   rtx clobber_after;\n@@ -7092,7 +6918,7 @@ expand_function_end ()\n \n   /* Output a linenumber for the end of the function.\n      SDB depends on this.  */\n-  \n+\n   emit_line_note_force (input_filename, input_line);\n \n   /* Before the return label (if any), clobber the return\n@@ -7277,8 +7103,7 @@ expand_function_end ()\n }\n \n rtx\n-get_arg_pointer_save_area (f)\n-     struct function *f;\n+get_arg_pointer_save_area (struct function *f)\n {\n   rtx ret = f->x_arg_pointer_save_area;\n \n@@ -7312,9 +7137,7 @@ get_arg_pointer_save_area (f)\n    (a list of one or more insns).  */\n \n static void\n-record_insns (insns, vecp)\n-     rtx insns;\n-     varray_type *vecp;\n+record_insns (rtx insns, varray_type *vecp)\n {\n   int i, len;\n   rtx tmp;\n@@ -7340,9 +7163,7 @@ record_insns (insns, vecp)\n \n /* Set the specified locator to the insn chain.  */\n static void\n-set_insn_locators (insn, loc)\n-  rtx insn;\n-  int loc;\n+set_insn_locators (rtx insn, int loc)\n {\n   while (insn != NULL_RTX)\n     {\n@@ -7356,9 +7177,7 @@ set_insn_locators (insn, loc)\n    be running after reorg, SEQUENCE rtl is possible.  */\n \n static int\n-contains (insn, vec)\n-     rtx insn;\n-     varray_type vec;\n+contains (rtx insn, varray_type vec)\n {\n   int i, j;\n \n@@ -7382,8 +7201,7 @@ contains (insn, vec)\n }\n \n int\n-prologue_epilogue_contains (insn)\n-     rtx insn;\n+prologue_epilogue_contains (rtx insn)\n {\n   if (contains (insn, prologue))\n     return 1;\n@@ -7393,8 +7211,7 @@ prologue_epilogue_contains (insn)\n }\n \n int\n-sibcall_epilogue_contains (insn)\n-     rtx insn;\n+sibcall_epilogue_contains (rtx insn)\n {\n   if (sibcall_epilogue)\n     return contains (insn, sibcall_epilogue);\n@@ -7406,9 +7223,7 @@ sibcall_epilogue_contains (insn)\n    block_for_insn appropriately.  */\n \n static void\n-emit_return_into_block (bb, line_note)\n-     basic_block bb;\n-     rtx line_note;\n+emit_return_into_block (basic_block bb, rtx line_note)\n {\n   emit_jump_insn_after (gen_return (), bb->end);\n   if (line_note)\n@@ -7458,15 +7273,14 @@ struct epi_info\n \t\t\t\t   its value.  */\n };\n \n-static void handle_epilogue_set PARAMS ((rtx, struct epi_info *));\n-static void emit_equiv_load PARAMS ((struct epi_info *));\n+static void handle_epilogue_set (rtx, struct epi_info *);\n+static void emit_equiv_load (struct epi_info *);\n \n /* Modify INSN, a list of one or more insns that is part of the epilogue, to\n    no modifications to the stack pointer.  Return the new list of insns.  */\n \n static rtx\n-keep_stack_depressed (insns)\n-     rtx insns;\n+keep_stack_depressed (rtx insns)\n {\n   int j;\n   struct epi_info info;\n@@ -7646,9 +7460,7 @@ keep_stack_depressed (insns)\n    more insns.  */\n \n static void\n-handle_epilogue_set (set, p)\n-     rtx set;\n-     struct epi_info *p;\n+handle_epilogue_set (rtx set, struct epi_info *p)\n {\n   /* First handle the case where we are setting SP.  Record what it is being\n      set from.  If unknown, abort.  */\n@@ -7714,8 +7526,7 @@ handle_epilogue_set (set, p)\n /* Emit an insn to do the load shown in p->equiv_reg_src, if needed.  */\n \n static void\n-emit_equiv_load (p)\n-     struct epi_info *p;\n+emit_equiv_load (struct epi_info *p)\n {\n   if (p->equiv_reg_src != 0)\n     emit_move_insn (p->sp_equiv_reg, p->equiv_reg_src);\n@@ -7729,8 +7540,7 @@ emit_equiv_load (p)\n    the epilogue begins.  Update the basic block information when possible.  */\n \n void\n-thread_prologue_and_epilogue_insns (f)\n-     rtx f ATTRIBUTE_UNUSED;\n+thread_prologue_and_epilogue_insns (rtx f ATTRIBUTE_UNUSED)\n {\n   int inserted = 0;\n   edge e;\n@@ -8024,8 +7834,7 @@ thread_prologue_and_epilogue_insns (f)\n    scheduling and delayed branch scheduling.  */\n \n void\n-reposition_prologue_and_epilogue_notes (f)\n-     rtx f ATTRIBUTE_UNUSED;\n+reposition_prologue_and_epilogue_notes (rtx f ATTRIBUTE_UNUSED)\n {\n #if defined (HAVE_prologue) || defined (HAVE_epilogue)\n   rtx insn, last, note;\n@@ -8116,7 +7925,7 @@ reposition_prologue_and_epilogue_notes (f)\n /* Called once, at initialization, to initialize function.c.  */\n \n void\n-init_function_once ()\n+init_function_once (void)\n {\n   VARRAY_INT_INIT (prologue, 0, \"prologue\");\n   VARRAY_INT_INIT (epilogue, 0, \"epilogue\");"}, {"sha": "4f5b51f8d9c5df0601340129218143721479cae9", "filename": "gcc/function.h", "status": "modified", "additions": 24, "deletions": 24, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fa8db1f7c42b14a38b71f423b7a4e6a5cedbfc38/gcc%2Ffunction.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fa8db1f7c42b14a38b71f423b7a4e6a5cedbfc38/gcc%2Ffunction.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffunction.h?ref=fa8db1f7c42b14a38b71f423b7a4e6a5cedbfc38", "patch": "@@ -1,6 +1,6 @@\n /* Structure for saving state for a nested function.\n    Copyright (C) 1989, 1992, 1993, 1994, 1995, 1996, 1997, 1998,\n-   1999, 2000 Free Software Foundation, Inc.\n+   1999, 2000, 2003 Free Software Foundation, Inc.\n \n This file is part of GCC.\n \n@@ -62,7 +62,7 @@ struct emit_status GTY(())\n \n   /* The ends of the doubly-linked chain of rtl for the current function.\n      Both are reset to null at the start of rtl generation for the function.\n-   \n+\n      start_sequence saves both of these on `sequence_stack' along with\n      `sequence_rtl_expr' and then starts a new, nested sequence of insns.  */\n   rtx x_first_insn;\n@@ -100,7 +100,7 @@ struct emit_status GTY(())\n     regno_pointer_align;\n \n   /* Indexed by pseudo register number, gives the rtx for that pseudo.\n-     Allocated in parallel with regno_pointer_align. \n+     Allocated in parallel with regno_pointer_align.\n \n      Note MEM expressions can appear in this array due to the actions\n      of put_var_into_stack.  */\n@@ -350,7 +350,7 @@ struct function GTY(())\n      until no longer needed.  CLEANUP_POINT_EXPRs define the lifetime\n      of TARGET_EXPRs.  */\n   int x_target_temp_slot_level;\n-  \n+\n   /* This slot is initialized as 0 and is added to\n      during the nested function.  */\n   struct var_refs_queue *fixup_var_refs_queue;\n@@ -398,7 +398,7 @@ struct function GTY(())\n   /* Nonzero if function being compiled needs to\n      return the address of where it has put a structure value.  */\n   unsigned int returns_pcc_struct : 1;\n-  \n+\n   /* Nonzero if the current function returns a pointer type.  */\n   unsigned int returns_pointer : 1;\n \n@@ -410,7 +410,7 @@ struct function GTY(())\n \n   /* Nonzero if function being compiled can call longjmp.  */\n   unsigned int calls_longjmp : 1;\n-  \n+\n   /* Nonzero if function being compiled can call alloca,\n      either as a subroutine or builtin.  */\n   unsigned int calls_alloca : 1;\n@@ -446,7 +446,7 @@ struct function GTY(())\n      function, however, should be treated as throwing if any of its callees\n      can throw.  */\n   unsigned int all_throwers_are_sibcalls : 1;\n- \n+\n   /* Nonzero if instrumentation calls for function entry and exit should be\n      generated.  */\n   unsigned int instrument_entry_exit : 1;\n@@ -579,45 +579,45 @@ extern tree inline_function_decl;\n \n /* Given a function decl for a containing function,\n    return the `struct function' for it.  */\n-struct function *find_function_data PARAMS ((tree));\n+struct function *find_function_data (tree);\n \n /* Set NOTE_BLOCK for each block note in the current function.  */\n-extern void identify_blocks PARAMS ((void));\n+extern void identify_blocks (void);\n \n /* Identify BLOCKs referenced by more than one NOTE_INSN_BLOCK_{BEG,END},\n    and create duplicate blocks.  */\n-extern void reorder_blocks PARAMS ((void));\n+extern void reorder_blocks (void);\n \n /* Set BLOCK_NUMBER for all the blocks in FN.  */\n-extern void number_blocks PARAMS ((tree));\n+extern void number_blocks (tree);\n \n /* Return size needed for stack frame based on slots so far allocated.\n    This size counts from zero.  It is not rounded to STACK_BOUNDARY;\n    the caller may have to do that.  */\n-extern HOST_WIDE_INT get_frame_size\tPARAMS ((void));\n+extern HOST_WIDE_INT get_frame_size (void);\n /* Likewise, but for a different than the current function.  */\n-extern HOST_WIDE_INT get_func_frame_size\tPARAMS ((struct function *));\n+extern HOST_WIDE_INT get_func_frame_size (struct function *);\n \n /* A pointer to a function to create target specific, per-function\n    data structures.  */\n-extern struct machine_function * (*init_machine_status)\tPARAMS ((void));\n+extern struct machine_function * (*init_machine_status) (void);\n \n /* Save and restore status information for a nested function.  */\n-extern void restore_emit_status\t\tPARAMS ((struct function *));\n-extern void free_after_parsing\t\tPARAMS ((struct function *));\n-extern void free_after_compilation\tPARAMS ((struct function *));\n+extern void restore_emit_status (struct function *);\n+extern void free_after_parsing (struct function *);\n+extern void free_after_compilation (struct function *);\n \n-extern void init_varasm_status\t\tPARAMS ((struct function *));\n+extern void init_varasm_status (struct function *);\n \n #ifdef RTX_CODE\n-extern void diddle_return_value\t\tPARAMS ((void (*)(rtx, void*), void*));\n-extern void clobber_return_register\tPARAMS ((void));\n-extern void use_return_register\t\tPARAMS ((void));\n+extern void diddle_return_value (void (*)(rtx, void*), void*);\n+extern void clobber_return_register (void);\n+extern void use_return_register (void);\n #endif\n \n-extern rtx get_arg_pointer_save_area\tPARAMS ((struct function *));\n+extern rtx get_arg_pointer_save_area (struct function *);\n \n-extern void init_virtual_regs\t\tPARAMS ((struct emit_status *));\n+extern void init_virtual_regs (struct emit_status *);\n \n /* Called once, at initialization, to initialize function.c.  */\n-extern void init_function_once          PARAMS ((void));\n+extern void init_function_once (void);"}]}