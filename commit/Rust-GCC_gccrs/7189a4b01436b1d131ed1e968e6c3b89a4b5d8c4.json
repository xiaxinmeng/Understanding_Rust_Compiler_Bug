{"sha": "7189a4b01436b1d131ed1e968e6c3b89a4b5d8c4", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzE4OWE0YjAxNDM2YjFkMTMxZWQxZTk2OGU2YzNiODlhNGI1ZDhjNA==", "commit": {"author": {"name": "Geoff Keating", "email": "geoffk@cygnus.com", "date": "1999-12-30T19:44:13Z"}, "committer": {"name": "Geoffrey Keating", "email": "geoffk@gcc.gnu.org", "date": "1999-12-30T19:44:13Z"}, "message": "Make the Fortran front-end use garbage collection:\n\n\t* com.c (ffecom_init_0): Make double_ftype_double,\n\tfloat_ftype_float, ldouble_ftype_ldouble,\n\tffecom_tree_ptr_to_fun_type_void local.\n\t(tracker_head): New static variable.\n\t(mark_tracker_head): New, marker procedure for tracker_head.\n\t(ffecom_save_tree_forever): New procedure.\n\t(ffecom_init_zero_): Remove obstack use.\n\t(ffecom_make_gfrt_): Remove obstack use.\n\t(ffecom_sym_transform_): Remove obstack use, save appropriate trees.\n\t(ffecom_transform_common_): Remove obstack use, save appropriate\n\ttrees.\n\t(ffecom_type_namelist_): Remove obstack use, save appropriate\n\ttrees.\n\t(ffecom_type_vardesc_): Remove obstack use, save appropriate trees.\n\t(ffecom_lookup_label): Remove obstack use, save appropriate trees.\n\t(duplicate_decls): Remove obstack use.\n\t(finish_function): push & pop ggc context around\n\trest_of_compilation when building nested function.\n\t(mark_binding_level): New function.\n\t(init_decl_processing): Mark all the GC roots.\n\t(ggc_p): Set to 1.\n\t(lang_mark_tree): New function.\n\t(lang_mark_false_label_stack): New trivial function.\n\t* com.h (ffecom_save_tree_forever): Declare as external.\n\t* lex.c (ffelex_hash_): Use GC to allocate the filename string\n\teven when ffelex_kludge_flag_.\n\t* ste.c (ffeste_io_ialist_): Register a static root.\n\t(ffeste_io_inlist_): Likewise.\n\t(ffeste_io_icilist_): Likewise.\n\t(ffeste_io_cllist_): Likewise.\n\t(ffeste_io_cilist_): Likewise.\n\t(ffeste_io_olist_): Likewise.\n\t* Makefile.in (OBJS): Don't use ggc-callbacks.o.\n\t(OBJDEPS): Likewise.\n\t(GGC_H): New variable.\n\tUpdate dependencies.\n\t* where.c (ffewhere_head): New global.\n\t(mark_ffewhere_head): New marker procedure for ffewhere_head.\n\t(ffewhere_file_kill): Use GC to do memory management.\n\t(ffewhere_file_new): Use GC to do memory management.\n\t* ggc.j: New file.\n\nFrom-SVN: r31142", "tree": {"sha": "3de821afebf1959eed52df3f8f08652a0b875942", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/3de821afebf1959eed52df3f8f08652a0b875942"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/7189a4b01436b1d131ed1e968e6c3b89a4b5d8c4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7189a4b01436b1d131ed1e968e6c3b89a4b5d8c4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7189a4b01436b1d131ed1e968e6c3b89a4b5d8c4", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7189a4b01436b1d131ed1e968e6c3b89a4b5d8c4/comments", "author": null, "committer": null, "parents": [{"sha": "0deeec4e126bac98d710441418fb925406f1dfe6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0deeec4e126bac98d710441418fb925406f1dfe6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0deeec4e126bac98d710441418fb925406f1dfe6"}], "stats": {"total": 468, "additions": 340, "deletions": 128}, "files": [{"sha": "b1463dfbd9acf5cef9a5f856abb050072e92231c", "filename": "gcc/f/ChangeLog", "status": "modified", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7189a4b01436b1d131ed1e968e6c3b89a4b5d8c4/gcc%2Ff%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7189a4b01436b1d131ed1e968e6c3b89a4b5d8c4/gcc%2Ff%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ff%2FChangeLog?ref=7189a4b01436b1d131ed1e968e6c3b89a4b5d8c4", "patch": "@@ -1,3 +1,47 @@\n+Thu Dec 30 11:42:05 1999  Geoff Keating  <geoffk@cygnus.com>\n+\n+\t* com.c (ffecom_init_0): Make double_ftype_double,\n+\tfloat_ftype_float, ldouble_ftype_ldouble,\n+\tffecom_tree_ptr_to_fun_type_void local.\n+\t(tracker_head): New static variable.\n+\t(mark_tracker_head): New, marker procedure for tracker_head.\n+\t(ffecom_save_tree_forever): New procedure.\n+\t(ffecom_init_zero_): Remove obstack use.\n+\t(ffecom_make_gfrt_): Remove obstack use.\n+\t(ffecom_sym_transform_): Remove obstack use, save appropriate trees.\n+\t(ffecom_transform_common_): Remove obstack use, save appropriate \n+\ttrees.\n+\t(ffecom_type_namelist_): Remove obstack use, save appropriate \n+\ttrees.\n+\t(ffecom_type_vardesc_): Remove obstack use, save appropriate trees.\n+\t(ffecom_lookup_label): Remove obstack use, save appropriate trees.\n+\t(duplicate_decls): Remove obstack use.\n+\t(finish_function): push & pop ggc context around\n+\trest_of_compilation when building nested function.\n+\t(mark_binding_level): New function.\n+\t(init_decl_processing): Mark all the GC roots.\n+\t(ggc_p): Set to 1.\n+\t(lang_mark_tree): New function.\n+\t(lang_mark_false_label_stack): New trivial function.\n+\t* com.h (ffecom_save_tree_forever): Declare as external.\n+\t* lex.c (ffelex_hash_): Use GC to allocate the filename string\n+\teven when ffelex_kludge_flag_.\n+\t* ste.c (ffeste_io_ialist_): Register a static root.\n+\t(ffeste_io_inlist_): Likewise.\n+\t(ffeste_io_icilist_): Likewise.\n+\t(ffeste_io_cllist_): Likewise.\n+\t(ffeste_io_cilist_): Likewise.\n+\t(ffeste_io_olist_): Likewise.\n+\t* Makefile.in (OBJS): Don't use ggc-callbacks.o.\n+\t(OBJDEPS): Likewise.\n+\t(GGC_H): New variable.\n+\tUpdate dependencies.\n+\t* where.c (ffewhere_head): New global.\n+\t(mark_ffewhere_head): New marker procedure for ffewhere_head.\n+\t(ffewhere_file_kill): Use GC to do memory management.\n+\t(ffewhere_file_new): Use GC to do memory management.\n+\t* ggc.j: New file.\n+\n Wed Dec 29 19:29:26 1999  Gerald Pfeifer  <pfeifer@dbai.tuwien.ac.at>\n \n \t* g77.texi (C Interfacing Tools): Fix an incorrect link."}, {"sha": "e791f2d20f50a4d145be03b634c5b0a38c7be752", "filename": "gcc/f/Make-lang.in", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7189a4b01436b1d131ed1e968e6c3b89a4b5d8c4/gcc%2Ff%2FMake-lang.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7189a4b01436b1d131ed1e968e6c3b89a4b5d8c4/gcc%2Ff%2FMake-lang.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ff%2FMake-lang.in?ref=7189a4b01436b1d131ed1e968e6c3b89a4b5d8c4", "patch": "@@ -200,7 +200,7 @@ F77_SRCS = \\\n  $(srcdir)/f/where.c \\\n  $(srcdir)/f/where.h\n \n-f771$(exeext): $(P) $(F77_SRCS) $(LIBDEPS) ggc-callbacks.o stamp-objlist\n+f771$(exeext): $(P) $(F77_SRCS) $(LIBDEPS) stamp-objlist\n \ttouch lang-f77\n \tcd f; $(MAKE) $(FLAGS_TO_PASS) \\\n \t  HOST_CC=\"`case '$(HOST_CC)' in stage*) echo '$(HOST_CC)' | sed -e 's|stage|../stage|g';; *) echo '$(HOST_CC)';; esac`\" \\"}, {"sha": "77cc972ea355210b9e78a1b254f2b978a485d2c2", "filename": "gcc/f/Makefile.in", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7189a4b01436b1d131ed1e968e6c3b89a4b5d8c4/gcc%2Ff%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7189a4b01436b1d131ed1e968e6c3b89a4b5d8c4/gcc%2Ff%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ff%2FMakefile.in?ref=7189a4b01436b1d131ed1e968e6c3b89a4b5d8c4", "patch": "@@ -194,8 +194,8 @@ F77_OBJS = \\\n  where.o\n \n # Language-independent object files.\n-OBJS = `cat ../stamp-objlist` ../ggc-callbacks.o\n-OBJDEPS = ../stamp-objlist ../ggc-callbacks.o\n+OBJS = `cat ../stamp-objlist`\n+OBJDEPS = ../stamp-objlist\n \n compiler: ../f771$(exeext)\n ../f771$(exeext): $(P) $(F77_OBJS) $(OBJDEPS) $(LIBDEPS)\n@@ -225,6 +225,7 @@ ASSERT_H = $(srcdir)/assert.j $(srcdir)/../assert.h\n CONFIG_H = $(srcdir)/config.j ../config.h\n CONVERT_H = $(srcdir)/convert.j $(srcdir)/../convert.h\n FLAGS_H = $(srcdir)/flags.j $(srcdir)/../flags.h\n+GGC_H = $(srcdir)/ggc.j $(srcdir)/../ggc.h\n GLIMITS_H = $(srcdir)/glimits.j $(srcdir)/../glimits.h\n HCONFIG_H = $(srcdir)/hconfig.j ../hconfig.h\n INPUT_H = $(srcdir)/input.j $(srcdir)/../input.h\n@@ -265,7 +266,7 @@ com.o: com.c proj.h $(CONFIG_H) $(SYSTEM_H) $(ASSERT_H) $(FLAGS_H) $(RTL_H) $(TO\n  malloc.h info.h info-b.def info-k.def info-w.def target.h bad.h \\\n  bad.def where.h $(GLIMITS_H) top.h lex.h type.h intrin.h intrin.def \\\n  lab.h symbol.h symbol.def equiv.h storag.h global.h name.h expr.h \\\n- implic.h src.h st.h\n+ implic.h src.h st.h $(GGC_H)\n data.o: data.c proj.h $(CONFIG_H) $(SYSTEM_H) $(ASSERT_H) data.h bld.h \\\n  bld-op.def bit.h malloc.h com.h com-rt.def $(TREE_H) info.h info-b.def \\\n  info-k.def info-w.def target.h bad.h bad.def where.h $(GLIMITS_H) top.h \\\n@@ -311,7 +312,7 @@ lex.o: lex.c proj.h $(CONFIG_H) $(SYSTEM_H) $(ASSERT_H) top.h malloc.h where.h \\\n  $(GLIMITS_H) bad.h bad.def com.h com-rt.def $(TREE_H) bld.h bld-op.def \\\n  bit.h info.h info-b.def info-k.def info-w.def target.h lex.h type.h \\\n  intrin.h intrin.def lab.h symbol.h symbol.def equiv.h storag.h \\\n- global.h name.h src.h $(FLAGS_H) $(INPUT_H) $(TOPLEV_H) $(OUTPUT_H)\n+ global.h name.h src.h $(FLAGS_H) $(INPUT_H) $(TOPLEV_H) $(OUTPUT_H) $(GGC_H)\n malloc.o: malloc.c proj.h $(CONFIG_H) $(SYSTEM_H) $(ASSERT_H) malloc.h\n name.o: name.c proj.h $(CONFIG_H) $(SYSTEM_H) $(ASSERT_H) bad.h bad.def where.h \\\n  $(GLIMITS_H) top.h malloc.h name.h global.h info.h info-b.def info-k.def \\\n@@ -359,7 +360,7 @@ ste.o: ste.c proj.h $(CONFIG_H) $(SYSTEM_H) $(ASSERT_H) $(RTL_H) $(TOPLEV_H) ste\n  info-b.def info-k.def info-w.def target.h bad.h bad.def where.h \\\n  $(GLIMITS_H) top.h lex.h type.h lab.h storag.h symbol.h symbol.def \\\n  equiv.h global.h name.h intrin.h intrin.def stp.h stt.h stamp-str sts.h \\\n- stv.h stw.h expr.h sta.h\n+ stv.h stw.h expr.h sta.h $(GGC_H)\n storag.o: storag.c proj.h $(CONFIG_H) $(SYSTEM_H) $(ASSERT_H) storag.h bld.h \\\n  bld-op.def bit.h malloc.h com.h com-rt.def $(TREE_H) info.h info-b.def \\\n  info-k.def info-w.def target.h bad.h bad.def where.h $(GLIMITS_H) top.h \\\n@@ -413,7 +414,7 @@ top.o: top.c proj.h $(CONFIG_H) $(SYSTEM_H) $(ASSERT_H) top.h malloc.h where.h \\\n type.o: type.c proj.h $(CONFIG_H) $(SYSTEM_H) $(ASSERT_H) type.h malloc.h\n version.o: version.c\n where.o: where.c proj.h $(CONFIG_H) $(SYSTEM_H) $(ASSERT_H) where.h $(GLIMITS_H) \\\n- top.h malloc.h lex.h\n+ top.h malloc.h lex.h $(GGC_H)\n \n # The rest of this list (Fortran 77 language-specific files) is hand-generated.\n "}, {"sha": "69d7e4578f78ee6fc7bbf40b62e5eb06bb99a77f", "filename": "gcc/f/com.c", "status": "modified", "additions": 177, "deletions": 83, "changes": 260, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7189a4b01436b1d131ed1e968e6c3b89a4b5d8c4/gcc%2Ff%2Fcom.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7189a4b01436b1d131ed1e968e6c3b89a4b5d8c4/gcc%2Ff%2Fcom.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ff%2Fcom.c?ref=7189a4b01436b1d131ed1e968e6c3b89a4b5d8c4", "patch": "@@ -93,6 +93,7 @@ the Free Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n #include \"tree.j\"\n #include \"output.j\"  /* Must follow tree.j so TREE_CODE is defined! */\n #include \"convert.j\"\n+#include \"ggc.j\"\n #endif\t/* FFECOM_targetCURRENT == FFECOM_targetGCC */\n \n #define FFECOM_GCC_INCLUDE 1\t/* Enable -I. */\n@@ -238,17 +239,12 @@ FILE *finput;\n \n tree string_type_node;\n \n-static tree double_ftype_double;\n-static tree float_ftype_float;\n-static tree ldouble_ftype_ldouble;\n-\n /* The rest of these are inventions for g77, though there might be\n    similar things in the C front end.  As they are found, these\n    inventions should be renamed to be canonical.  Note that only\n    the ones currently required to be global are so.  */\n \n static tree ffecom_tree_fun_type_void;\n-static tree ffecom_tree_ptr_to_fun_type_void;\n \n tree ffecom_integer_type_node;\t/* Abbrev for _tree_type[blah][blah]. */\n tree ffecom_integer_zero_node;\t/* Like *_*_* with g77's integer type. */\n@@ -6433,6 +6429,56 @@ ffecom_gfrt_tree_ (ffecomGfrt ix)\n /* Return initialize-to-zero expression for this VAR_DECL.  */\n \n #if FFECOM_targetCURRENT == FFECOM_targetGCC\n+/* A somewhat evil way to prevent the garbage collector\n+   from collecting 'tree' structures.  */\n+#define NUM_TRACKED_CHUNK 63\n+static struct tree_ggc_tracker \n+{\n+  struct tree_ggc_tracker *next;\n+  tree trees[NUM_TRACKED_CHUNK];\n+} *tracker_head = NULL;\n+\n+static void \n+mark_tracker_head (arg)\n+     void *arg;\n+{\n+  struct tree_ggc_tracker *head;\n+  int i;\n+  \n+  for (head = * (struct tree_ggc_tracker **) arg;\n+       head != NULL;\n+       head = head->next)\n+  {\n+    ggc_mark (head);\n+    for (i = 0; i < NUM_TRACKED_CHUNK; i++)\n+      ggc_mark_tree (head->trees[i]);\n+  }\n+}\n+\n+void\n+ffecom_save_tree_forever (tree t)\n+{\n+  int i;\n+  if (tracker_head != NULL)\n+    for (i = 0; i < NUM_TRACKED_CHUNK; i++)\n+      if (tracker_head->trees[i] == NULL)\n+\t{\n+\t  tracker_head->trees[i] = t;\n+\t  return;\n+\t}\n+\n+  {\n+    /* Need to allocate a new block.  */\n+    struct tree_ggc_tracker *old_head = tracker_head;\n+    \n+    tracker_head = ggc_alloc (sizeof (*tracker_head));\n+    tracker_head->next = old_head;\n+    tracker_head->trees[0] = t;\n+    for (i = 1; i < NUM_TRACKED_CHUNK; i++)\n+      tracker_head->trees[i] = NULL;\n+  }\n+}\n+\n static tree\n ffecom_init_zero_ (tree decl)\n {\n@@ -6442,14 +6488,8 @@ ffecom_init_zero_ (tree decl)\n \n   if (incremental)\n     {\n-      int momentary = suspend_momentary ();\n-      push_obstacks_nochange ();\n-      if (TREE_PERMANENT (decl))\n-\tend_temporary_allocation ();\n       make_decl_rtl (decl, NULL, TREE_PUBLIC (decl) ? 1 : 0);\n       assemble_variable (decl, TREE_PUBLIC (decl) ? 1 : 0, 0, 1);\n-      pop_obstacks ();\n-      resume_momentary (momentary);\n     }\n \n   push_momentary ();\n@@ -6966,9 +7006,6 @@ ffecom_make_gfrt_ (ffecomGfrt ix)\n   tree t;\n   tree ttype;\n \n-  push_obstacks_nochange ();\n-  end_temporary_allocation ();\n-\n   switch (ffecom_gfrt_type_[ix])\n     {\n     case FFECOM_rttypeVOID_:\n@@ -7049,9 +7086,6 @@ ffecom_make_gfrt_ (ffecomGfrt ix)\n \n   finish_decl (t, NULL_TREE, TRUE);\n \n-  resume_temporary_allocation ();\n-  pop_obstacks ();\n-\n   ffecom_gfrt_[ix] = t;\n }\n \n@@ -7583,9 +7617,6 @@ ffecom_sym_transform_ (ffesymbol s)\n \t      break;\n \t    }\n \n-\t  push_obstacks_nochange ();\n-\t  end_temporary_allocation ();\n-\n \t  t = build_decl (FUNCTION_DECL,\n \t\t\t  ffecom_get_external_identifier_ (s),\n \t\t\t  ffecom_tree_subr_type);\t/* Assume subr. */\n@@ -7601,8 +7632,7 @@ ffecom_sym_transform_ (ffesymbol s)\n \t\t  || (ffeglobal_type (g) == FFEGLOBAL_typeEXT)))\n \t    ffeglobal_set_hook (g, t);\n \n-\t  resume_temporary_allocation ();\n-\t  pop_obstacks ();\n+\t  ffecom_save_tree_forever (t);\n \n \t  break;\n \n@@ -8247,9 +8277,6 @@ ffecom_sym_transform_ (ffesymbol s)\n \t      break;\n \t    }\n \n-\t  push_obstacks_nochange ();\n-\t  end_temporary_allocation ();\n-\n \t  if (ffesymbol_is_f2c (s)\n \t      && (ffesymbol_where (s) != FFEINFO_whereCONSTANT))\n \t    t = ffecom_tree_fun_type[bt][kt];\n@@ -8270,8 +8297,7 @@ ffecom_sym_transform_ (ffesymbol s)\n \t\t  || (ffeglobal_type (g) == FFEGLOBAL_typeEXT)))\n \t    ffeglobal_set_hook (g, t);\n \n-\t  resume_temporary_allocation ();\n-\t  pop_obstacks ();\n+\t  ffecom_save_tree_forever (t);\n \n \t  break;\n \n@@ -8334,9 +8360,6 @@ ffecom_sym_transform_ (ffesymbol s)\n \t      break;\n \t    }\n \n-\t  push_obstacks_nochange ();\n-\t  end_temporary_allocation ();\n-\n \t  t = build_decl (FUNCTION_DECL,\n \t\t\t  ffecom_get_external_identifier_ (s),\n \t\t\t  ffecom_tree_subr_type);\n@@ -8351,8 +8374,7 @@ ffecom_sym_transform_ (ffesymbol s)\n \t\t  || (ffeglobal_type (g) == FFEGLOBAL_typeEXT)))\n \t    ffeglobal_set_hook (g, t);\n \n-\t  resume_temporary_allocation ();\n-\t  pop_obstacks ();\n+\t  ffecom_save_tree_forever (t);\n \n \t  break;\n \n@@ -8421,9 +8443,6 @@ ffecom_sym_transform_ (ffesymbol s)\n \tcase FFEINFO_whereGLOBAL:\n \t  assert (!ffecom_transform_only_dummies_);\n \n-\t  push_obstacks_nochange ();\n-\t  end_temporary_allocation ();\n-\n \t  t = build_decl (FUNCTION_DECL,\n \t\t\t  ffecom_get_external_identifier_ (s),\n \t\t\t  ffecom_tree_blockdata_type);\n@@ -8433,8 +8452,7 @@ ffecom_sym_transform_ (ffesymbol s)\n \t  t = start_decl (t, FALSE);\n \t  finish_decl (t, NULL_TREE, FALSE);\n \n-\t  resume_temporary_allocation ();\n-\t  pop_obstacks ();\n+\t  ffecom_save_tree_forever (t);\n \n \t  break;\n \n@@ -8757,9 +8775,6 @@ ffecom_transform_common_ (ffesymbol s)\n   else\n     init = NULL_TREE;\n \n-  push_obstacks_nochange ();\n-  end_temporary_allocation ();\n-\n   /* cbtype must be permanently allocated!  */\n \n   /* Allocate the MAX of the areas so far, seen filewide.  */\n@@ -8831,8 +8846,7 @@ ffecom_transform_common_ (ffesymbol s)\n \n   ffestorag_set_hook (st, cbt);\n \n-  resume_temporary_allocation ();\n-  pop_obstacks ();\n+  ffecom_save_tree_forever (cbt);\n }\n \n #endif\n@@ -9482,9 +9496,6 @@ ffecom_type_namelist_ ()\n \n       vardesctype = ffecom_type_vardesc_ ();\n \n-      push_obstacks_nochange ();\n-      end_temporary_allocation ();\n-\n       type = make_node (RECORD_TYPE);\n \n       vardesctype = build_pointer_type (build_pointer_type (vardesctype));\n@@ -9498,8 +9509,7 @@ ffecom_type_namelist_ ()\n       TYPE_FIELDS (type) = namefield;\n       layout_type (type);\n \n-      resume_temporary_allocation ();\n-      pop_obstacks ();\n+      ggc_add_tree_root (&type, 1);\n     }\n \n   return type;\n@@ -9553,9 +9563,6 @@ ffecom_type_vardesc_ ()\n \n   if (type == NULL_TREE)\n     {\n-      push_obstacks_nochange ();\n-      end_temporary_allocation ();\n-\n       type = make_node (RECORD_TYPE);\n \n       namefield = ffecom_decl_field (type, NULL_TREE, \"name\",\n@@ -9570,8 +9577,7 @@ ffecom_type_vardesc_ ()\n       TYPE_FIELDS (type) = namefield;\n       layout_type (type);\n \n-      resume_temporary_allocation ();\n-      pop_obstacks ();\n+      ggc_add_tree_root (&type, 1);\n     }\n \n   return type;\n@@ -11566,6 +11572,10 @@ ffecom_init_0 ()\n   tree field;\n   ffetype type;\n   ffetype base_type;\n+  tree double_ftype_double;\n+  tree float_ftype_float;\n+  tree ldouble_ftype_ldouble;\n+  tree ffecom_tree_ptr_to_fun_type_void;\n \n   /* This block of code comes from the now-obsolete cktyps.c.  It checks\n      whether the compiler environment is buggy in known ways, some of which\n@@ -12392,9 +12402,6 @@ ffecom_lookup_label (ffelab label)\n \t  break;\n \n \tcase FFELAB_typeFORMAT:\n-\t  push_obstacks_nochange ();\n-\t  end_temporary_allocation ();\n-\n \t  glabel = build_decl (VAR_DECL,\n \t\t\t       ffecom_get_invented_identifier\n \t\t\t       (\"__g77_format_%d\", (int) ffelab_value (label)),\n@@ -12409,8 +12416,7 @@ ffecom_lookup_label (ffelab label)\n \t  make_decl_rtl (glabel, NULL, 0);\n \t  expand_decl (glabel);\n \n-\t  resume_temporary_allocation ();\n-\t  pop_obstacks ();\n+\t  ffecom_save_tree_forever (glabel);\n \n \t  break;\n \n@@ -13777,17 +13783,6 @@ duplicate_decls (tree newdecl, tree olddecl)\n \t  tree oldreturntype = TREE_TYPE (TREE_TYPE (olddecl));\n \t  tree newreturntype = TREE_TYPE (TREE_TYPE (newdecl));\n \n-\t  /* Make sure we put the new type in the same obstack as the old ones.\n-\t     If the old types are not both in the same obstack, use the\n-\t     permanent one.  */\n-\t  if (TYPE_OBSTACK (oldtype) == TYPE_OBSTACK (newtype))\n-\t    push_obstacks (TYPE_OBSTACK (oldtype), TYPE_OBSTACK (oldtype));\n-\t  else\n-\t    {\n-\t      push_obstacks_nochange ();\n-\t      end_temporary_allocation ();\n-\t    }\n-\n \t  if (TYPE_MODE (oldreturntype) == TYPE_MODE (newreturntype))\n \t    {\n \t      /* Function types may be shared, so we can't just modify\n@@ -13800,8 +13795,6 @@ duplicate_decls (tree newdecl, tree olddecl)\n \t      if (types_match)\n \t\tTREE_TYPE (olddecl) = newtype;\n \t    }\n-\n-\t  pop_obstacks ();\n \t}\n       if (!types_match)\n \treturn 0;\n@@ -13830,17 +13823,6 @@ duplicate_decls (tree newdecl, tree olddecl)\n \n   if (types_match)\n     {\n-      /* Make sure we put the new type in the same obstack as the old ones.\n-\t If the old types are not both in the same obstack, use the permanent\n-\t one.  */\n-      if (TYPE_OBSTACK (oldtype) == TYPE_OBSTACK (newtype))\n-\tpush_obstacks (TYPE_OBSTACK (oldtype), TYPE_OBSTACK (oldtype));\n-      else\n-\t{\n-\t  push_obstacks_nochange ();\n-\t  end_temporary_allocation ();\n-\t}\n-\n       /* Merge the data types specified in the two decls.  */\n       if (TREE_CODE (newdecl) != FUNCTION_DECL || !DECL_BUILT_IN (olddecl))\n \tTREE_TYPE (newdecl)\n@@ -13919,8 +13901,6 @@ duplicate_decls (tree newdecl, tree olddecl)\n \t  DECL_STATIC_DESTRUCTOR (newdecl) |= DECL_STATIC_DESTRUCTOR (olddecl);\n \t}\n #endif\n-\n-      pop_obstacks ();\n     }\n   /* If cannot merge, then use the new type and qualifiers,\n      and don't preserve the old rtl.  */\n@@ -14244,8 +14224,17 @@ finish_function (int nested)\n       /* So we can tell if jump_optimize sets it to 1.  */\n       can_reach_end = 0;\n \n+      /* If this is a nested function, protect the local variables in the stack\n+\t above us from being collected while we're compiling this function.  */\n+      if (ggc_p && nested)\n+\tggc_push_context ();\n+\n       /* Run the optimizers and output the assembler code for this function.  */\n       rest_of_compilation (fndecl);\n+\n+      /* Undo the GC context switch.  */\n+      if (ggc_p && nested)\n+\tggc_pop_context ();\n     }\n \n   /* Free all the tree nodes making up this function.  */\n@@ -14784,10 +14773,87 @@ incomplete_type_error (value, type)\n   assert (\"incomplete type?!?\" == NULL);\n }\n \n+/* Mark ARG for GC.  */\n+static void \n+mark_binding_level (arg)\n+     void *arg;\n+{\n+  struct binding_level *level = *(struct binding_level **) arg;\n+\n+  while (level)\n+    {\n+      ggc_mark_tree (level->names);\n+      ggc_mark_tree (level->blocks);\n+      ggc_mark_tree (level->this_block);\n+      level = level->level_chain;\n+    }\n+}\n+\n void\n init_decl_processing ()\n {\n+  static tree *const tree_roots[] = {\n+    &current_function_decl,\n+    &string_type_node,\n+    &ffecom_tree_fun_type_void,\n+    &ffecom_integer_zero_node,\n+    &ffecom_integer_one_node,\n+    &ffecom_tree_subr_type,\n+    &ffecom_tree_ptr_to_subr_type,\n+    &ffecom_tree_blockdata_type,\n+    &ffecom_tree_xargc_,\n+    &ffecom_f2c_integer_type_node,\n+    &ffecom_f2c_ptr_to_integer_type_node,\n+    &ffecom_f2c_address_type_node,\n+    &ffecom_f2c_real_type_node,\n+    &ffecom_f2c_ptr_to_real_type_node,\n+    &ffecom_f2c_doublereal_type_node,\n+    &ffecom_f2c_complex_type_node,\n+    &ffecom_f2c_doublecomplex_type_node,\n+    &ffecom_f2c_longint_type_node,\n+    &ffecom_f2c_logical_type_node,\n+    &ffecom_f2c_flag_type_node,\n+    &ffecom_f2c_ftnlen_type_node,\n+    &ffecom_f2c_ftnlen_zero_node,\n+    &ffecom_f2c_ftnlen_one_node,\n+    &ffecom_f2c_ftnlen_two_node,\n+    &ffecom_f2c_ptr_to_ftnlen_type_node,\n+    &ffecom_f2c_ftnint_type_node,\n+    &ffecom_f2c_ptr_to_ftnint_type_node,\n+    &ffecom_outer_function_decl_,\n+    &ffecom_previous_function_decl_,\n+    &ffecom_which_entrypoint_decl_,\n+    &ffecom_float_zero_,\n+    &ffecom_float_half_,\n+    &ffecom_double_zero_,\n+    &ffecom_double_half_,\n+    &ffecom_func_result_,\n+    &ffecom_func_length_,\n+    &ffecom_multi_type_node_,\n+    &ffecom_multi_retval_,\n+    &named_labels,\n+    &shadowed_labels\n+  };\n+  size_t i;\n+\n   malloc_init ();\n+\n+  /* Record our roots.  */\n+  for (i = 0; i < sizeof(tree_roots)/sizeof(tree_roots[0]); i++)\n+    ggc_add_tree_root (tree_roots[i], 1);\n+  ggc_add_tree_root (&ffecom_tree_type[0][0], \n+\t\t     FFEINFO_basictype*FFEINFO_kindtype);\n+  ggc_add_tree_root (&ffecom_tree_fun_type[0][0], \n+\t\t     FFEINFO_basictype*FFEINFO_kindtype);\n+  ggc_add_tree_root (&ffecom_tree_ptr_to_fun_type[0][0], \n+\t\t     FFEINFO_basictype*FFEINFO_kindtype);\n+  ggc_add_tree_root (ffecom_gfrt_, FFECOM_gfrt);\n+  ggc_add_root (&current_binding_level, 1, sizeof current_binding_level,\n+                mark_binding_level);\n+  ggc_add_root (&free_binding_level, 1, sizeof current_binding_level,\n+                mark_binding_level);\n+  ggc_add_root (&tracker_head, 1, sizeof tracker_head, mark_tracker_head);\n+\n   ffe_init_0 ();\n }\n \n@@ -15753,6 +15819,34 @@ unsigned_type (type)\n   return type;\n }\n \n+/* Callback routines for garbage collection.  */\n+\n+int ggc_p = 1;\n+\n+void \n+lang_mark_tree (t)\n+     union tree_node *t ATTRIBUTE_UNUSED;\n+{\n+  if (TREE_CODE (t) == IDENTIFIER_NODE)\n+    {\n+      struct lang_identifier *i = (struct lang_identifier *) t;\n+      ggc_mark_tree (IDENTIFIER_GLOBAL_VALUE (i));\n+      ggc_mark_tree (IDENTIFIER_LOCAL_VALUE (i));\n+      ggc_mark_tree (IDENTIFIER_LABEL_VALUE (i));\n+    }\n+  else if (TYPE_P (t) && TYPE_LANG_SPECIFIC (t))\n+    ggc_mark (TYPE_LANG_SPECIFIC (t));\n+}\n+\n+void\n+lang_mark_false_label_stack (l)\n+     struct label_node *l;\n+{\n+  /* Fortran doesn't use false_label_stack.  It better be NULL.  */\n+  if (l != NULL)\n+    abort();\n+}\n+\n #endif /* FFECOM_targetCURRENT == FFECOM_targetGCC */\n \f\n #if FFECOM_GCC_INCLUDE"}, {"sha": "84187a02bb08599a6016f92e0f30568dec022e26", "filename": "gcc/f/com.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7189a4b01436b1d131ed1e968e6c3b89a4b5d8c4/gcc%2Ff%2Fcom.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7189a4b01436b1d131ed1e968e6c3b89a4b5d8c4/gcc%2Ff%2Fcom.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ff%2Fcom.h?ref=7189a4b01436b1d131ed1e968e6c3b89a4b5d8c4", "patch": "@@ -318,6 +318,7 @@ tree ffecom_lookup_label (ffelab label);\n tree ffecom_make_tempvar (const char *commentary, tree type,\n \t\t\t  ffetargetCharacterSize size, int elements);\n tree ffecom_modify (tree newtype, tree lhs, tree rhs);\n+void ffecom_save_tree_forever (tree t);\n #endif\t/* FFECOM_targetCURRENT == FFECOM_targetGCC */\n void ffecom_file (const char *name);\n void ffecom_notify_init_storage (ffestorag st);"}, {"sha": "1689b415cd46f9cacf4a0786a51e552c00d33276", "filename": "gcc/f/ggc.j", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7189a4b01436b1d131ed1e968e6c3b89a4b5d8c4/gcc%2Ff%2Fggc.j", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7189a4b01436b1d131ed1e968e6c3b89a4b5d8c4/gcc%2Ff%2Fggc.j", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ff%2Fggc.j?ref=7189a4b01436b1d131ed1e968e6c3b89a4b5d8c4", "patch": "@@ -0,0 +1,29 @@\n+/* rtl.j -- Wrapper for GCC's rtl.h\n+   Copyright (C) 1995 Free Software Foundation, Inc.\n+   Contributed by James Craig Burley.\n+\n+This file is part of GNU Fortran.\n+\n+GNU Fortran is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU Fortran is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Fortran; see the file COPYING.  If not, write to\n+the Free Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n+02111-1307, USA.  */\n+\n+#ifndef MAKING_DEPENDENCIES\n+#ifndef _J_f_ggc\n+#define _J_f_ggc\n+#include \"system.j\"\n+#include \"config.j\"\n+#include \"ggc.h\"\n+#endif\n+#endif"}, {"sha": "cee6cabc4c434056c4b374b5eadfff4a512cee29", "filename": "gcc/f/lex.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7189a4b01436b1d131ed1e968e6c3b89a4b5d8c4/gcc%2Ff%2Flex.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7189a4b01436b1d131ed1e968e6c3b89a4b5d8c4/gcc%2Ff%2Flex.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ff%2Flex.c?ref=7189a4b01436b1d131ed1e968e6c3b89a4b5d8c4", "patch": "@@ -32,6 +32,7 @@ the Free Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n #include \"toplev.j\"\n #include \"tree.j\"\n #include \"output.j\"  /* Must follow tree.j so TREE_CODE is defined! */\n+#include \"ggc.j\"\n #endif\n \n #ifdef DWARF_DEBUGGING_INFO\n@@ -1320,7 +1321,7 @@ ffelex_hash_ (FILE *finput)\n       lineno = l;\n \n       if (ffelex_kludge_flag_)\n-\tinput_filename = ffelex_token_text (token);\n+\tinput_filename = ggc_alloc_string (ffelex_token_text (token), -1);\n       else\n \t{\n \t  wf = ffewhere_file_new (ffelex_token_text (token),"}, {"sha": "6db4d48cce2a0d310be24bf55361902d9f8cc5b4", "filename": "gcc/f/ste.c", "status": "modified", "additions": 7, "deletions": 30, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7189a4b01436b1d131ed1e968e6c3b89a4b5d8c4/gcc%2Ff%2Fste.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7189a4b01436b1d131ed1e968e6c3b89a4b5d8c4/gcc%2Ff%2Fste.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ff%2Fste.c?ref=7189a4b01436b1d131ed1e968e6c3b89a4b5d8c4", "patch": "@@ -35,6 +35,7 @@ the Free Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n #if FFECOM_targetCURRENT == FFECOM_targetGCC\n #include \"rtl.j\"\n #include \"toplev.j\"\n+#include \"ggc.j\"\n #endif\n \n #include \"ste.h\"\n@@ -1218,9 +1219,6 @@ ffeste_io_ialist_ (bool have_err,\n     {\n       tree ref;\n \n-      push_obstacks_nochange ();\n-      end_temporary_allocation ();\n-\n       ref = make_node (RECORD_TYPE);\n \n       errfield = ffecom_decl_field (ref, NULL_TREE, \"err\",\n@@ -1231,8 +1229,7 @@ ffeste_io_ialist_ (bool have_err,\n       TYPE_FIELDS (ref) = errfield;\n       layout_type (ref);\n \n-      resume_temporary_allocation ();\n-      pop_obstacks ();\n+      ggc_add_tree_root (&f2c_alist_struct, 1);\n \n       f2c_alist_struct = ref;\n     }\n@@ -1355,9 +1352,6 @@ ffeste_io_cilist_ (bool have_err,\n     {\n       tree ref;\n \n-      push_obstacks_nochange ();\n-      end_temporary_allocation ();\n-\n       ref = make_node (RECORD_TYPE);\n \n       errfield = ffecom_decl_field (ref, NULL_TREE, \"err\",\n@@ -1374,8 +1368,7 @@ ffeste_io_cilist_ (bool have_err,\n       TYPE_FIELDS (ref) = errfield;\n       layout_type (ref);\n \n-      resume_temporary_allocation ();\n-      pop_obstacks ();\n+      ggc_add_tree_root (&f2c_cilist_struct, 1);\n \n       f2c_cilist_struct = ref;\n     }\n@@ -1586,9 +1579,6 @@ ffeste_io_cllist_ (bool have_err,\n     {\n       tree ref;\n \n-      push_obstacks_nochange ();\n-      end_temporary_allocation ();\n-\n       ref = make_node (RECORD_TYPE);\n \n       errfield = ffecom_decl_field (ref, NULL_TREE, \"err\",\n@@ -1601,8 +1591,7 @@ ffeste_io_cllist_ (bool have_err,\n       TYPE_FIELDS (ref) = errfield;\n       layout_type (ref);\n \n-      resume_temporary_allocation ();\n-      pop_obstacks ();\n+      ggc_add_tree_root (&f2c_close_struct, 1);\n \n       f2c_close_struct = ref;\n     }\n@@ -1713,9 +1702,6 @@ ffeste_io_icilist_ (bool have_err,\n     {\n       tree ref;\n \n-      push_obstacks_nochange ();\n-      end_temporary_allocation ();\n-\n       ref = make_node (RECORD_TYPE);\n \n       errfield = ffecom_decl_field (ref, NULL_TREE, \"err\",\n@@ -1734,8 +1720,7 @@ ffeste_io_icilist_ (bool have_err,\n       TYPE_FIELDS (ref) = errfield;\n       layout_type (ref);\n \n-      resume_temporary_allocation ();\n-      pop_obstacks ();\n+      ggc_add_tree_root (&f2c_icilist_struct, 1);\n \n       f2c_icilist_struct = ref;\n     }\n@@ -1976,9 +1961,6 @@ ffeste_io_inlist_ (bool have_err,\n     {\n       tree ref;\n \n-      push_obstacks_nochange ();\n-      end_temporary_allocation ();\n-\n       ref = make_node (RECORD_TYPE);\n \n       errfield = ffecom_decl_field (ref, NULL_TREE, \"err\",\n@@ -2041,8 +2023,7 @@ ffeste_io_inlist_ (bool have_err,\n       TYPE_FIELDS (ref) = errfield;\n       layout_type (ref);\n \n-      resume_temporary_allocation ();\n-      pop_obstacks ();\n+      ggc_add_tree_root (&f2c_inquire_struct, 1);\n \n       f2c_inquire_struct = ref;\n     }\n@@ -2229,9 +2210,6 @@ ffeste_io_olist_ (bool have_err,\n     {\n       tree ref;\n \n-      push_obstacks_nochange ();\n-      end_temporary_allocation ();\n-\n       ref = make_node (RECORD_TYPE);\n \n       errfield = ffecom_decl_field (ref, NULL_TREE, \"err\",\n@@ -2256,8 +2234,7 @@ ffeste_io_olist_ (bool have_err,\n       TYPE_FIELDS (ref) = errfield;\n       layout_type (ref);\n \n-      resume_temporary_allocation ();\n-      pop_obstacks ();\n+      ggc_add_tree_root (&f2c_open_struct, 1);\n \n       f2c_open_struct = ref;\n     }"}, {"sha": "1779098c50e6c8c237537e5301cc0bfdca433092", "filename": "gcc/f/where.c", "status": "modified", "additions": 72, "deletions": 7, "changes": 79, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7189a4b01436b1d131ed1e968e6c3b89a4b5d8c4/gcc%2Ff%2Fwhere.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7189a4b01436b1d131ed1e968e6c3b89a4b5d8c4/gcc%2Ff%2Fwhere.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ff%2Fwhere.c?ref=7189a4b01436b1d131ed1e968e6c3b89a4b5d8c4", "patch": "@@ -33,6 +33,7 @@ the Free Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n #include \"where.h\"\n #include \"lex.h\"\n #include \"malloc.h\"\n+#include \"ggc.j\"\n \n /* Externals defined here. */\n \n@@ -108,6 +109,33 @@ ffewhere_ll_lookup_ (ffewhereLineNumber ln)\n   return NULL;\n }\n \n+/* A somewhat evil way to prevent the garbage collector\n+   from collecting 'file' structures.  */\n+#define NUM_FFEWHERE_HEAD_FILES 31\n+static struct ffewhere_ggc_tracker \n+{\n+  struct ffewhere_ggc_tracker *next;\n+  ffewhereFile files[NUM_FFEWHERE_HEAD_FILES];\n+} *ffewhere_head = NULL;\n+\n+static void \n+mark_ffewhere_head (arg)\n+     void *arg;\n+{\n+  struct ffewhere_ggc_tracker *head;\n+  int i;\n+  \n+  for (head = * (struct ffewhere_ggc_tracker **) arg;\n+       head != NULL;\n+       head = head->next)\n+  {\n+    ggc_mark (head);\n+    for (i = 0; i < NUM_FFEWHERE_HEAD_FILES; i++)\n+      ggc_mark (head->files[i]);\n+  }\n+}\n+\n+\n /* Kill file object.\n \n    Note that this object must not have been passed in a call\n@@ -117,9 +145,18 @@ ffewhere_ll_lookup_ (ffewhereLineNumber ln)\n void\n ffewhere_file_kill (ffewhereFile wf)\n {\n-  malloc_kill_ks (ffe_pool_file (), wf,\n-\t\t  offsetof (struct _ffewhere_file_, text)\n-\t\t  + wf->length + 1);\n+  struct ffewhere_ggc_tracker *head;\n+  int i;\n+  \n+  for (head = ffewhere_head; head != NULL; head = head->next)\n+    for (i = 0; i < NUM_FFEWHERE_HEAD_FILES; i++)\n+      if (head->files[i] == wf)\n+\t{\n+\t  head->files[i] = NULL;\n+\t  return;\n+\t}\n+  /* Called on a file that has already been deallocated... */\n+  abort();\n }\n \n /* Create file object.  */\n@@ -128,14 +165,42 @@ ffewhereFile\n ffewhere_file_new (char *name, size_t length)\n {\n   ffewhereFile wf;\n-\n-  wf = malloc_new_ks (ffe_pool_file (), \"ffewhereFile\",\n-\t\t      offsetof (struct _ffewhere_file_, text)\n-\t\t      + length + 1);\n+  int filepos;\n+ \n+  wf = ggc_alloc (offsetof (struct _ffewhere_file_, text)\n+\t\t  + length + 1);\n   wf->length = length;\n   memcpy (&wf->text[0], name, length);\n   wf->text[length] = '\\0';\n \n+  if (ffewhere_head == NULL)\n+    {\n+      ggc_add_root (&ffewhere_head, 1, sizeof ffewhere_head,\n+\t\t    mark_ffewhere_head);\n+      filepos = NUM_FFEWHERE_HEAD_FILES;\n+    }\n+  else\n+    {\n+      for (filepos = 0; filepos < NUM_FFEWHERE_HEAD_FILES; filepos++)\n+\tif (ffewhere_head->files[filepos] == NULL)\n+\t  {\n+\t    ffewhere_head->files[filepos] = wf;\n+\t    break;\n+\t  }\n+    }\n+  if (filepos == NUM_FFEWHERE_HEAD_FILES)\n+    {\n+      /* Need to allocate a new block.  */\n+      struct ffewhere_ggc_tracker *old_head = ffewhere_head;\n+      int i;\n+      \n+      ffewhere_head = ggc_alloc (sizeof (*ffewhere_head));\n+      ffewhere_head->next = old_head;\n+      ffewhere_head->files[0] = wf;\n+      for (i = 1; i < NUM_FFEWHERE_HEAD_FILES; i++)\n+\tffewhere_head->files[i] = NULL;\n+    }\n+\n   return wf;\n }\n "}]}