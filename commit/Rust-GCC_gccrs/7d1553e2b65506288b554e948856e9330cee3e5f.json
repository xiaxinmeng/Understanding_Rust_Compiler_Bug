{"sha": "7d1553e2b65506288b554e948856e9330cee3e5f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6N2QxNTUzZTJiNjU1MDYyODhiNTU0ZTk0ODg1NmU5MzMwY2VlM2U1Zg==", "commit": {"author": {"name": "Pascal Obry", "email": "obry@adacore.com", "date": "2018-01-11T08:52:39Z"}, "committer": {"name": "Pierre-Marie de Rodat", "email": "pmderodat@gcc.gnu.org", "date": "2018-01-11T08:52:39Z"}, "message": "[Ada] New implementation for Normalize_Pathname\n\nThis implementation fixes an issue on Windows where a single drive letter\nwas not followed by a directory separator. On Windows the following\nprogram:\n\n   with Ada.Text_IO; use Ada.Text_IO;\n   with GNAT.OS_Lib; use GNAT.OS_Lib;\n   procedure Main is\n   begin\n      Put_Line (Normalize_Pathname (\"c:\\\"));\n      Put_Line (Normalize_Pathname (\"c:\\toto\\..\"));\n   end Main;\n\nMust output:\n\nC:\\\nC:\\\n\n2018-01-11  Pascal Obry  <obry@adacore.com>\n\ngcc/ada/\n\n\t* libgnat/s-os_lib.adb (Normalize_Pathname): New implementation.\n\nFrom-SVN: r256501", "tree": {"sha": "9b32aa80d05dd8c033b23b465923bfa4d792a8e4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/9b32aa80d05dd8c033b23b465923bfa4d792a8e4"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/7d1553e2b65506288b554e948856e9330cee3e5f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7d1553e2b65506288b554e948856e9330cee3e5f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7d1553e2b65506288b554e948856e9330cee3e5f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7d1553e2b65506288b554e948856e9330cee3e5f/comments", "author": {"login": "TurboGit", "id": 467069, "node_id": "MDQ6VXNlcjQ2NzA2OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/467069?v=4", "gravatar_id": "", "url": "https://api.github.com/users/TurboGit", "html_url": "https://github.com/TurboGit", "followers_url": "https://api.github.com/users/TurboGit/followers", "following_url": "https://api.github.com/users/TurboGit/following{/other_user}", "gists_url": "https://api.github.com/users/TurboGit/gists{/gist_id}", "starred_url": "https://api.github.com/users/TurboGit/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/TurboGit/subscriptions", "organizations_url": "https://api.github.com/users/TurboGit/orgs", "repos_url": "https://api.github.com/users/TurboGit/repos", "events_url": "https://api.github.com/users/TurboGit/events{/privacy}", "received_events_url": "https://api.github.com/users/TurboGit/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "1646b09f3b917a135a15084ccd1a8ce41ddf3d38", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1646b09f3b917a135a15084ccd1a8ce41ddf3d38", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1646b09f3b917a135a15084ccd1a8ce41ddf3d38"}], "stats": {"total": 170, "additions": 66, "deletions": 104}, "files": [{"sha": "af01944f74003fed6d7c24899aca6d298835ff39", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7d1553e2b65506288b554e948856e9330cee3e5f/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7d1553e2b65506288b554e948856e9330cee3e5f/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=7d1553e2b65506288b554e948856e9330cee3e5f", "patch": "@@ -1,3 +1,7 @@\n+2018-01-11  Pascal Obry  <obry@adacore.com>\n+\n+\t* libgnat/s-os_lib.adb (Normalize_Pathname): New implementation.\n+\n 2018-01-11  Bob Duff  <duff@adacore.com>\n \n \t* doc/gnat_ugn/gnat_utility_programs.rst: Rewrite gnatpp documentation"}, {"sha": "94618343dcffc30739f15f6d4fe6291b2be4772a", "filename": "gcc/ada/libgnat/s-os_lib.adb", "status": "modified", "additions": 62, "deletions": 104, "changes": 166, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7d1553e2b65506288b554e948856e9330cee3e5f/gcc%2Fada%2Flibgnat%2Fs-os_lib.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7d1553e2b65506288b554e948856e9330cee3e5f/gcc%2Fada%2Flibgnat%2Fs-os_lib.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fs-os_lib.adb?ref=7d1553e2b65506288b554e948856e9330cee3e5f", "patch": "@@ -2085,12 +2085,6 @@ package body System.OS_Lib is\n          Bufsiz : size_t) return Integer;\n       pragma Import (C, Readlink, \"__gnat_readlink\");\n \n-      function To_Canonical_File_Spec\n-        (Host_File : System.Address) return System.Address;\n-      pragma Import\n-        (C, To_Canonical_File_Spec, \"__gnat_to_canonical_file_spec\");\n-      --  Convert possible foreign file syntax to canonical form\n-\n       Fold_To_Lower_Case : constant Boolean :=\n                              not Case_Sensitive\n                                and then Get_File_Names_Case_Sensitive = 0;\n@@ -2142,7 +2136,18 @@ package body System.OS_Lib is\n             end if;\n          end if;\n \n-         return S1 (1 .. Last);\n+         --  And ensure that there is a trailing directory separator if the\n+         --  path contains only a drive letter.\n+\n+         if On_Windows\n+           and then Last = 2\n+           and then S1 (1) /= Directory_Separator\n+           and then S1 (2) = ':'\n+         then\n+            return S1 (1 .. Last) & Directory_Separator;\n+         else\n+            return S1 (1 .. Last);\n+         end if;\n       end Final_Value;\n \n       -------------------\n@@ -2157,8 +2162,8 @@ package body System.OS_Lib is\n             declare\n                Result : String   :=\n                           Normalize_Pathname\n-                            (Dir, \"\", Resolve_Links, Case_Sensitive) &\n-                             Directory_Separator;\n+                            (Dir, \"\", Resolve_Links, Case_Sensitive)\n+                             & Directory_Separator;\n                Last   : Positive := Result'Last - 1;\n \n             begin\n@@ -2218,112 +2223,85 @@ package body System.OS_Lib is\n \n       Max_Iterations : constant := 500;\n \n-      Canonical_File_Addr : System.Address;\n-      Canonical_File_Len  : Integer;\n+      Cur_Dir     : constant String  := Get_Directory (Directory);\n+      Cur_Dir_Len : constant Natural := Cur_Dir'Length;\n \n-      End_Path    : Natural := 0;\n-      Finish      : Positive;\n-      Last        : Positive;\n+      End_Path    : Natural := Name'Length;\n+      Last        : Positive := 1;\n       Link_Buffer : String (1 .. Max_Path + 2);\n-      Path_Buffer : String (1 .. Max_Path + Max_Path + 2);\n-      Start       : Natural;\n-      Status      : Integer;\n-      The_Name    : String (1 .. Name'Length + 1);\n+      Path_Buffer : String (1 .. End_Path + Cur_Dir_Len + Max_Path + 2);\n+      --  We need to potentially store in this buffer the following elements:\n+      --  the path itself, the current directory if the path is relative,\n+      --  and additional fragments up to Max_Path in length in case\n+      --  there are any symlinks.\n+      Start, Finish : Positive;\n+      Status : Integer;\n \n    --  Start of processing for Normalize_Pathname\n \n    begin\n-      --  Special case, return null if name is null, or if it is bigger than\n-      --  the biggest name allowed.\n+      --  Special case, return null if name is null\n \n-      if Name'Length = 0 or else Name'Length > Max_Path then\n+      if End_Path = 0 then\n          return \"\";\n       end if;\n \n-      --  First, convert possible foreign file spec to Unix file spec. If no\n-      --  conversion is required, all this does is put Name at the beginning\n-      --  of Path_Buffer unchanged.\n-\n-      File_Name_Conversion : begin\n-         The_Name (1 .. Name'Length) := Name;\n-         The_Name (The_Name'Last) := ASCII.NUL;\n-\n-         Canonical_File_Addr := To_Canonical_File_Spec (The_Name'Address);\n-         Canonical_File_Len  := Integer (CRTL.strlen (Canonical_File_Addr));\n+      if Is_Absolute_Path (Name) then\n+         Path_Buffer (1 .. End_Path) := Name;\n \n-         --  If syntax conversion has failed, return an empty string to\n-         --  indicate the failure.\n-\n-         if Canonical_File_Len = 0 then\n-            return \"\";\n-         end if;\n+      else\n+         --  If this is a relative pathname, prepend current directory\n+         Path_Buffer (1 .. Cur_Dir_Len) := Cur_Dir;\n+         Path_Buffer (Cur_Dir_Len + 1 .. Cur_Dir_Len + End_Path) := Name;\n+         End_Path := Cur_Dir_Len + End_Path;\n+         Last := Cur_Dir_Len;\n+      end if;\n \n-         declare\n-            subtype Path_String is String (1 .. Canonical_File_Len);\n-            Canonical_File : Path_String;\n-            for Canonical_File'Address use Canonical_File_Addr;\n-            pragma Import (Ada, Canonical_File);\n+      --  Special handling for Windows:\n+      --    * Replace all '/' by '\\'\n+      --    * Check the drive letter\n+      --    * Remove all double-quotes\n \n-         begin\n-            Path_Buffer (1 .. Canonical_File_Len) := Canonical_File;\n-            End_Path := Canonical_File_Len;\n-            Last := 1;\n-         end;\n-      end File_Name_Conversion;\n+      if On_Windows then\n \n-      --  Replace all '/' by Directory Separators (this is for Windows)\n+         --  Replace all '/' by '\\'\n \n-      if Directory_Separator /= '/' then\n          for Index in 1 .. End_Path loop\n             if Path_Buffer (Index) = '/' then\n                Path_Buffer (Index) := Directory_Separator;\n             end if;\n          end loop;\n-      end if;\n-\n-      --  Resolve directory names for Windows\n-\n-      if On_Windows then\n \n-         --  On Windows, if we have an absolute path starting with a directory\n-         --  separator, we need to have the drive letter appended in front.\n-\n-         --  On Windows, Get_Current_Dir will return a suitable directory name\n-         --  (path starting with a drive letter on Windows). So we take this\n-         --  drive letter and prepend it to the current path.\n+         --  If we have an absolute path starting with a directory\n+         --  separator (but not a UNC path), we need to have the drive letter\n+         --  in front of the path. Get_Current_Dir returns a path starting\n+         --  with a drive letter. So we take this drive letter and prepend it\n+         --  to the current path.\n \n          if Path_Buffer (1) = Directory_Separator\n            and then Path_Buffer (2) /= Directory_Separator\n          then\n-            declare\n-               Cur_Dir : constant String := Get_Directory (\"\");\n-               --  Get the current directory to get the drive letter\n-\n-            begin\n-               if Cur_Dir'Length > 2\n-                 and then Cur_Dir (Cur_Dir'First + 1) = ':'\n-               then\n-                  Path_Buffer (3 .. End_Path + 2) :=\n-                    Path_Buffer (1 .. End_Path);\n-                  Path_Buffer (1 .. 2) :=\n-                    Cur_Dir (Cur_Dir'First .. Cur_Dir'First + 1);\n-                  End_Path := End_Path + 2;\n-               end if;\n-            end;\n+            if Cur_Dir'Length > 2\n+              and then Cur_Dir (Cur_Dir'First + 1) = ':'\n+            then\n+               Path_Buffer (3 .. End_Path + 2) :=\n+                 Path_Buffer (1 .. End_Path);\n+               Path_Buffer (1 .. 2) :=\n+                 Cur_Dir (Cur_Dir'First .. Cur_Dir'First + 1);\n+               End_Path := End_Path + 2;\n+            end if;\n \n-         --  We have a drive letter, ensure it is upper-case\n+         --  We have a drive letter already, ensure it is upper-case\n \n          elsif Path_Buffer (1) in 'a' .. 'z'\n            and then Path_Buffer (2) = ':'\n          then\n             System.Case_Util.To_Upper (Path_Buffer (1 .. 1));\n          end if;\n-      end if;\n \n-      --  On Windows, remove all double-quotes that are possibly part of the\n-      --  path but can cause problems with other methods.\n+         --  Remove all double-quotes that are possibly part of the\n+         --  path but can cause problems with other methods.\n \n-      if On_Windows then\n          declare\n             Index : Natural;\n \n@@ -2347,30 +2325,10 @@ package body System.OS_Lib is\n \n       for J in 1 .. Max_Iterations loop\n \n-         --  If we don't have an absolute pathname, prepend the directory\n-         --  Reference_Dir.\n-\n-         if Last = 1\n-           and then not Is_Absolute_Path (Path_Buffer (1 .. End_Path))\n-         then\n-            declare\n-               Reference_Dir : constant String  := Get_Directory (Directory);\n-               Ref_Dir_Len   : constant Natural := Reference_Dir'Length;\n-               --  Current directory name specified and its length\n-\n-            begin\n-               Path_Buffer (Ref_Dir_Len + 1 .. Ref_Dir_Len + End_Path) :=\n-                 Path_Buffer (1 .. End_Path);\n-               End_Path := Ref_Dir_Len + End_Path;\n-               Path_Buffer (1 .. Ref_Dir_Len) := Reference_Dir;\n-               Last := Ref_Dir_Len;\n-            end;\n-         end if;\n-\n          Start  := Last + 1;\n          Finish := Last;\n \n-         --  Ensure that Windows network drives are kept, e.g: \\\\server\\drive-c\n+         --  Ensure that Windows UNC path is preserved, e.g: \\\\server\\drive-c\n \n          if Start = 2\n            and then Directory_Separator = '\\'\n@@ -2434,11 +2392,11 @@ package body System.OS_Lib is\n             Start := Last;\n             loop\n                Start := Start - 1;\n-               exit when Start < 1\n+               exit when Start = 1\n                  or else Path_Buffer (Start) = Directory_Separator;\n             end loop;\n \n-            if Start <= 1 then\n+            if Start = 1 then\n                if Finish = End_Path then\n                   return (1 => Directory_Separator);\n "}]}