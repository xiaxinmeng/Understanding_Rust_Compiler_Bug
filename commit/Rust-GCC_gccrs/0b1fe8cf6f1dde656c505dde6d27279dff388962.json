{"sha": "0b1fe8cf6f1dde656c505dde6d27279dff388962", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MGIxZmU4Y2Y2ZjFkZGU2NTZjNTA1ZGRlNmQyNzI3OWRmZjM4ODk2Mg==", "commit": {"author": {"name": "Richard Sandiford", "email": "richard.sandiford@arm.com", "date": "2019-08-13T21:33:51Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2019-08-13T21:33:51Z"}, "message": "Optimise constant IFN_WHILE_ULTs\n\nThis patch is a combination of two changes that have to be\ncommitted as a single unit:\n\n(1) Try to fold IFN_WHILE_ULTs with constant arguments to a VECTOR_CST\n    (which is always possible for fixed-length vectors but is not\n    necessarily so for variable-length vectors)\n\n(2) Make the SVE port recognise constants that map to PTRUE VLn,\n    which includes those generated by the new fold.\n\n(2) can't be tested without (1) and (1) would be a significant\npessimisation without (2).\n\nThe target-specific parts also start moving towards doing predicate\nmanipulation in a canonical VNx16BImode form, using rtx_vector_builders.\n\n2019-08-13  Richard Sandiford  <richard.sandiford@arm.com>\n\ngcc/\n\t* tree.h (build_vector_a_then_b): Declare.\n\t* tree.c (build_vector_a_then_b): New function.\n\t* fold-const-call.c (fold_while_ult): Likewise.\n\t(fold_const_call): Use it to handle IFN_WHILE_ULT.\n\t* config/aarch64/aarch64-protos.h (AARCH64_FOR_SVPATTERN): New macro.\n\t(aarch64_svpattern): New enum.\n\t* config/aarch64/aarch64-sve.md (mov<PRED_ALL:mode>): Pass\n\tconstants through aarch64_expand_mov_immediate.\n\t(*aarch64_sve_mov<PRED_ALL:mode>): Use aarch64_mov_operand rather\n\tthan general_operand as the predicate for operand 1.\n\t(while_ult<GPI:mode><PRED_ALL:mode>): Add a '@' marker.\n\t* config/aarch64/aarch64.c (simd_immediate_info::PTRUE): New\n\tinsn_type.\n\t(simd_immediate_info::simd_immediate_info): New overload that\n\ttakes a scalar_int_mode and an svpattern.\n\t(simd_immediate_info::u): Add a \"pattern\" field.\n\t(svpattern_token): New function.\n\t(aarch64_get_sve_pred_bits, aarch64_widest_sve_pred_elt_size)\n\t(aarch64_partial_ptrue_length, aarch64_svpattern_for_vl)\n\t(aarch64_sve_move_pred_via_while): New functions.\n\t(aarch64_expand_mov_immediate): Try using\n\taarch64_sve_move_pred_via_while for predicates that contain N ones\n\tfollowed by M zeros but that do not correspond to a VLnnn pattern.\n\t(aarch64_sve_pred_valid_immediate): New function.\n\t(aarch64_simd_valid_immediate): Use it instead of dealing directly\n\twith PTRUE and PFALSE.\n\t(aarch64_output_sve_mov_immediate): Handle new simd_immediate_info\n\tforms.\n\ngcc/testsuite/\n\t* gcc.target/aarch64/sve/spill_2.c: Increase iteration counts\n\tbeyond the range of a PTRUE.\n\t* gcc.target/aarch64/sve/while_6.c: New test.\n\t* gcc.target/aarch64/sve/while_7.c: Likewise.\n\t* gcc.target/aarch64/sve/while_8.c: Likewise.\n\t* gcc.target/aarch64/sve/while_9.c: Likewise.\n\t* gcc.target/aarch64/sve/while_10.c: Likewise.\n\nFrom-SVN: r274402", "tree": {"sha": "a3eff991a44ccd4c0437b4c3b39690ba2caa10a3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a3eff991a44ccd4c0437b4c3b39690ba2caa10a3"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0b1fe8cf6f1dde656c505dde6d27279dff388962", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0b1fe8cf6f1dde656c505dde6d27279dff388962", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0b1fe8cf6f1dde656c505dde6d27279dff388962", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0b1fe8cf6f1dde656c505dde6d27279dff388962/comments", "author": {"login": "rsandifo-arm", "id": 28043039, "node_id": "MDQ6VXNlcjI4MDQzMDM5", "avatar_url": "https://avatars.githubusercontent.com/u/28043039?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rsandifo-arm", "html_url": "https://github.com/rsandifo-arm", "followers_url": "https://api.github.com/users/rsandifo-arm/followers", "following_url": "https://api.github.com/users/rsandifo-arm/following{/other_user}", "gists_url": "https://api.github.com/users/rsandifo-arm/gists{/gist_id}", "starred_url": "https://api.github.com/users/rsandifo-arm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rsandifo-arm/subscriptions", "organizations_url": "https://api.github.com/users/rsandifo-arm/orgs", "repos_url": "https://api.github.com/users/rsandifo-arm/repos", "events_url": "https://api.github.com/users/rsandifo-arm/events{/privacy}", "received_events_url": "https://api.github.com/users/rsandifo-arm/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "abb1d111f99fa2b480923e55dd74a974a62c9624", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/abb1d111f99fa2b480923e55dd74a974a62c9624", "html_url": "https://github.com/Rust-GCC/gccrs/commit/abb1d111f99fa2b480923e55dd74a974a62c9624"}], "stats": {"total": 551, "additions": 518, "deletions": 33}, "files": [{"sha": "307f5360ea0db2d124e9b8fb51f68fe8b4d91efe", "filename": "gcc/ChangeLog", "status": "modified", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0b1fe8cf6f1dde656c505dde6d27279dff388962/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0b1fe8cf6f1dde656c505dde6d27279dff388962/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=0b1fe8cf6f1dde656c505dde6d27279dff388962", "patch": "@@ -1,3 +1,34 @@\n+2019-08-13  Richard Sandiford  <richard.sandiford@arm.com>\n+\n+\t* tree.h (build_vector_a_then_b): Declare.\n+\t* tree.c (build_vector_a_then_b): New function.\n+\t* fold-const-call.c (fold_while_ult): Likewise.\n+\t(fold_const_call): Use it to handle IFN_WHILE_ULT.\n+\t* config/aarch64/aarch64-protos.h (AARCH64_FOR_SVPATTERN): New macro.\n+\t(aarch64_svpattern): New enum.\n+\t* config/aarch64/aarch64-sve.md (mov<PRED_ALL:mode>): Pass\n+\tconstants through aarch64_expand_mov_immediate.\n+\t(*aarch64_sve_mov<PRED_ALL:mode>): Use aarch64_mov_operand rather\n+\tthan general_operand as the predicate for operand 1.\n+\t(while_ult<GPI:mode><PRED_ALL:mode>): Add a '@' marker.\n+\t* config/aarch64/aarch64.c (simd_immediate_info::PTRUE): New\n+\tinsn_type.\n+\t(simd_immediate_info::simd_immediate_info): New overload that\n+\ttakes a scalar_int_mode and an svpattern.\n+\t(simd_immediate_info::u): Add a \"pattern\" field.\n+\t(svpattern_token): New function.\n+\t(aarch64_get_sve_pred_bits, aarch64_widest_sve_pred_elt_size)\n+\t(aarch64_partial_ptrue_length, aarch64_svpattern_for_vl)\n+\t(aarch64_sve_move_pred_via_while): New functions.\n+\t(aarch64_expand_mov_immediate): Try using\n+\taarch64_sve_move_pred_via_while for predicates that contain N ones\n+\tfollowed by M zeros but that do not correspond to a VLnnn pattern.\n+\t(aarch64_sve_pred_valid_immediate): New function.\n+\t(aarch64_simd_valid_immediate): Use it instead of dealing directly\n+\twith PTRUE and PFALSE.\n+\t(aarch64_output_sve_mov_immediate): Handle new simd_immediate_info\n+\tforms.\n+\n 2019-08-13 Iain Sandoe <iain@sandoe.co.uk>\n \n \t* config/darwin.c (machopic_indirect_call_target): Rename symbol stub"}, {"sha": "86d53c5ce1ea2e5f9cf5158eaa6380ed4102b12e", "filename": "gcc/config/aarch64/aarch64-protos.h", "status": "modified", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0b1fe8cf6f1dde656c505dde6d27279dff388962/gcc%2Fconfig%2Faarch64%2Faarch64-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0b1fe8cf6f1dde656c505dde6d27279dff388962/gcc%2Fconfig%2Faarch64%2Faarch64-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Faarch64-protos.h?ref=0b1fe8cf6f1dde656c505dde6d27279dff388962", "patch": "@@ -406,6 +406,33 @@ extern enum aarch64_key_type aarch64_ra_sign_key;\n \n extern struct tune_params aarch64_tune_params;\n \n+/* The available SVE predicate patterns, known in the ACLE as \"svpattern\".  */\n+#define AARCH64_FOR_SVPATTERN(T) \\\n+  T (POW2, pow2, 0) \\\n+  T (VL1, vl1, 1) \\\n+  T (VL2, vl2, 2) \\\n+  T (VL3, vl3, 3) \\\n+  T (VL4, vl4, 4) \\\n+  T (VL5, vl5, 5) \\\n+  T (VL6, vl6, 6) \\\n+  T (VL7, vl7, 7) \\\n+  T (VL8, vl8, 8) \\\n+  T (VL16, vl16, 9) \\\n+  T (VL32, vl32, 10) \\\n+  T (VL64, vl64, 11) \\\n+  T (VL128, vl128, 12) \\\n+  T (VL256, vl256, 13) \\\n+  T (MUL4, mul4, 29) \\\n+  T (MUL3, mul3, 30) \\\n+  T (ALL, all, 31)\n+\n+#define AARCH64_SVENUM(UPPER, LOWER, VALUE) AARCH64_SV_##UPPER = VALUE,\n+enum aarch64_svpattern {\n+  AARCH64_FOR_SVPATTERN (AARCH64_SVENUM)\n+  AARCH64_NUM_SVPATTERNS\n+};\n+#undef AARCH64_SVENUM\n+\n void aarch64_post_cfi_startproc (void);\n poly_int64 aarch64_initial_elimination_offset (unsigned, unsigned);\n int aarch64_get_condition_code (rtx);"}, {"sha": "53d93a367dbd998699b8fa89256bc220204709bb", "filename": "gcc/config/aarch64/aarch64-sve.md", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0b1fe8cf6f1dde656c505dde6d27279dff388962/gcc%2Fconfig%2Faarch64%2Faarch64-sve.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0b1fe8cf6f1dde656c505dde6d27279dff388962/gcc%2Fconfig%2Faarch64%2Faarch64-sve.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Faarch64-sve.md?ref=0b1fe8cf6f1dde656c505dde6d27279dff388962", "patch": "@@ -481,12 +481,18 @@\n   {\n     if (GET_CODE (operands[0]) == MEM)\n       operands[1] = force_reg (<MODE>mode, operands[1]);\n+\n+    if (CONSTANT_P (operands[1]))\n+      {\n+\taarch64_expand_mov_immediate (operands[0], operands[1]);\n+\tDONE;\n+      }\n   }\n )\n \n (define_insn \"*aarch64_sve_mov<mode>\"\n   [(set (match_operand:PRED_ALL 0 \"nonimmediate_operand\" \"=Upa, m, Upa, Upa\")\n-\t(match_operand:PRED_ALL 1 \"general_operand\" \"Upa, Upa, m, Dn\"))]\n+\t(match_operand:PRED_ALL 1 \"aarch64_mov_operand\" \"Upa, Upa, m, Dn\"))]\n   \"TARGET_SVE\n    && (register_operand (operands[0], <MODE>mode)\n        || register_operand (operands[1], <MODE>mode))\"\n@@ -2923,7 +2929,7 @@\n \n ;; Set element I of the result if operand1 + J < operand2 for all J in [0, I],\n ;; with the comparison being unsigned.\n-(define_insn \"while_ult<GPI:mode><PRED_ALL:mode>\"\n+(define_insn \"@while_ult<GPI:mode><PRED_ALL:mode>\"\n   [(set (match_operand:PRED_ALL 0 \"register_operand\" \"=Upa\")\n \t(unspec:PRED_ALL [(match_operand:GPI 1 \"aarch64_reg_or_zero\" \"rZ\")\n \t\t\t  (match_operand:GPI 2 \"aarch64_reg_or_zero\" \"rZ\")]"}, {"sha": "2b3ea9f164c208fb0bad3e9f060c443f8bffc6e1", "filename": "gcc/config/aarch64/aarch64.c", "status": "modified", "additions": 252, "deletions": 23, "changes": 275, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0b1fe8cf6f1dde656c505dde6d27279dff388962/gcc%2Fconfig%2Faarch64%2Faarch64.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0b1fe8cf6f1dde656c505dde6d27279dff388962/gcc%2Fconfig%2Faarch64%2Faarch64.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Faarch64.c?ref=0b1fe8cf6f1dde656c505dde6d27279dff388962", "patch": "@@ -83,7 +83,7 @@\n /* Information about a legitimate vector immediate operand.  */\n struct simd_immediate_info\n {\n-  enum insn_type { MOV, MVN, INDEX };\n+  enum insn_type { MOV, MVN, INDEX, PTRUE };\n   enum modifier_type { LSL, MSL };\n \n   simd_immediate_info () {}\n@@ -92,6 +92,7 @@ struct simd_immediate_info\n \t\t       insn_type = MOV, modifier_type = LSL,\n \t\t       unsigned int = 0);\n   simd_immediate_info (scalar_mode, rtx, rtx);\n+  simd_immediate_info (scalar_int_mode, aarch64_svpattern);\n \n   /* The mode of the elements.  */\n   scalar_mode elt_mode;\n@@ -120,6 +121,9 @@ struct simd_immediate_info\n \t subsequent element.  */\n       rtx base, step;\n     } index;\n+\n+    /* For PTRUE.  */\n+    aarch64_svpattern pattern;\n   } u;\n };\n \n@@ -159,6 +163,16 @@ ::simd_immediate_info (scalar_mode elt_mode_in, rtx base_in, rtx step_in)\n   u.index.step = step_in;\n }\n \n+/* Construct a predicate that controls elements of mode ELT_MODE_IN\n+   and has PTRUE pattern PATTERN_IN.  */\n+inline simd_immediate_info\n+::simd_immediate_info (scalar_int_mode elt_mode_in,\n+\t\t       aarch64_svpattern pattern_in)\n+  : elt_mode (elt_mode_in), insn (PTRUE)\n+{\n+  u.pattern = pattern_in;\n+}\n+\n /* The current code model.  */\n enum aarch64_code_model aarch64_cmodel;\n \n@@ -1334,6 +1348,22 @@ static const char *const aarch64_sve_condition_codes[] =\n   \"pmore\", \"plast\", \"tcont\", \"tstop\", \"gt\", \"le\", \"al\", \"nv\"\n };\n \n+/* Return the assembly token for svpattern value VALUE.  */\n+\n+static const char *\n+svpattern_token (enum aarch64_svpattern pattern)\n+{\n+  switch (pattern)\n+    {\n+#define CASE(UPPER, LOWER, VALUE) case AARCH64_SV_##UPPER: return #LOWER;\n+    AARCH64_FOR_SVPATTERN (CASE)\n+#undef CASE\n+    case AARCH64_NUM_SVPATTERNS:\n+      break;\n+    }\n+  gcc_unreachable ();\n+}\n+\n /* Generate code to enable conditional branches in functions over 1 MiB.  */\n const char *\n aarch64_gen_far_branch (rtx * operands, int pos_label, const char * dest,\n@@ -2529,6 +2559,146 @@ aarch64_force_temporary (machine_mode mode, rtx x, rtx value)\n     }\n }\n \n+/* Return true if predicate value X is a constant in which every element\n+   is a CONST_INT.  When returning true, describe X in BUILDER as a VNx16BI\n+   value, i.e. as a predicate in which all bits are significant.  */\n+\n+static bool\n+aarch64_get_sve_pred_bits (rtx_vector_builder &builder, rtx x)\n+{\n+  if (GET_CODE (x) != CONST_VECTOR)\n+    return false;\n+\n+  unsigned int factor = vector_element_size (GET_MODE_NUNITS (VNx16BImode),\n+\t\t\t\t\t     GET_MODE_NUNITS (GET_MODE (x)));\n+  unsigned int npatterns = CONST_VECTOR_NPATTERNS (x) * factor;\n+  unsigned int nelts_per_pattern = CONST_VECTOR_NELTS_PER_PATTERN (x);\n+  builder.new_vector (VNx16BImode, npatterns, nelts_per_pattern);\n+\n+  unsigned int nelts = const_vector_encoded_nelts (x);\n+  for (unsigned int i = 0; i < nelts; ++i)\n+    {\n+      rtx elt = CONST_VECTOR_ENCODED_ELT (x, i);\n+      if (!CONST_INT_P (elt))\n+\treturn false;\n+\n+      builder.quick_push (elt);\n+      for (unsigned int j = 1; j < factor; ++j)\n+\tbuilder.quick_push (const0_rtx);\n+    }\n+  builder.finalize ();\n+  return true;\n+}\n+\n+/* BUILDER contains a predicate constant of mode VNx16BI.  Return the\n+   widest predicate element size it can have (that is, the largest size\n+   for which each element would still be 0 or 1).  */\n+\n+unsigned int\n+aarch64_widest_sve_pred_elt_size (rtx_vector_builder &builder)\n+{\n+  /* Start with the most optimistic assumption: that we only need\n+     one bit per pattern.  This is what we will use if only the first\n+     bit in each pattern is ever set.  */\n+  unsigned int mask = GET_MODE_SIZE (DImode);\n+  mask |= builder.npatterns ();\n+\n+  /* Look for set bits.  */\n+  unsigned int nelts = builder.encoded_nelts ();\n+  for (unsigned int i = 1; i < nelts; ++i)\n+    if (INTVAL (builder.elt (i)) != 0)\n+      {\n+\tif (i & 1)\n+\t  return 1;\n+\tmask |= i;\n+      }\n+  return mask & -mask;\n+}\n+\n+/* BUILDER is a predicate constant of mode VNx16BI.  Consider the value\n+   that the constant would have with predicate element size ELT_SIZE\n+   (ignoring the upper bits in each element) and return:\n+\n+   * -1 if all bits are set\n+   * N if the predicate has N leading set bits followed by all clear bits\n+   * 0 if the predicate does not have any of these forms.  */\n+\n+int\n+aarch64_partial_ptrue_length (rtx_vector_builder &builder,\n+\t\t\t      unsigned int elt_size)\n+{\n+  /* If nelts_per_pattern is 3, we have set bits followed by clear bits\n+     followed by set bits.  */\n+  if (builder.nelts_per_pattern () == 3)\n+    return 0;\n+\n+  /* Skip over leading set bits.  */\n+  unsigned int nelts = builder.encoded_nelts ();\n+  unsigned int i = 0;\n+  for (; i < nelts; i += elt_size)\n+    if (INTVAL (builder.elt (i)) == 0)\n+      break;\n+  unsigned int vl = i / elt_size;\n+\n+  /* Check for the all-true case.  */\n+  if (i == nelts)\n+    return -1;\n+\n+  /* If nelts_per_pattern is 1, then either VL is zero, or we have a\n+     repeating pattern of set bits followed by clear bits.  */\n+  if (builder.nelts_per_pattern () != 2)\n+    return 0;\n+\n+  /* We have a \"foreground\" value and a duplicated \"background\" value.\n+     If the background might repeat and the last set bit belongs to it,\n+     we might have set bits followed by clear bits followed by set bits.  */\n+  if (i > builder.npatterns () && maybe_ne (nelts, builder.full_nelts ()))\n+    return 0;\n+\n+  /* Make sure that the rest are all clear.  */\n+  for (; i < nelts; i += elt_size)\n+    if (INTVAL (builder.elt (i)) != 0)\n+      return 0;\n+\n+  return vl;\n+}\n+\n+/* See if there is an svpattern that encodes an SVE predicate of mode\n+   PRED_MODE in which the first VL bits are set and the rest are clear.\n+   Return the pattern if so, otherwise return AARCH64_NUM_SVPATTERNS.\n+   A VL of -1 indicates an all-true vector.  */\n+\n+aarch64_svpattern\n+aarch64_svpattern_for_vl (machine_mode pred_mode, int vl)\n+{\n+  if (vl < 0)\n+    return AARCH64_SV_ALL;\n+\n+  if (maybe_gt (vl, GET_MODE_NUNITS (pred_mode)))\n+    return AARCH64_NUM_SVPATTERNS;\n+\n+  if (vl >= 1 && vl <= 8)\n+    return aarch64_svpattern (AARCH64_SV_VL1 + (vl - 1));\n+\n+  if (vl >= 16 && vl <= 256 && pow2p_hwi (vl))\n+    return aarch64_svpattern (AARCH64_SV_VL16 + (exact_log2 (vl) - 4));\n+\n+  int max_vl;\n+  if (GET_MODE_NUNITS (pred_mode).is_constant (&max_vl))\n+    {\n+      if (vl == (max_vl / 3) * 3)\n+\treturn AARCH64_SV_MUL3;\n+      /* These would only trigger for non-power-of-2 lengths.  */\n+      if (vl == (max_vl & -4))\n+\treturn AARCH64_SV_MUL4;\n+      if (vl == (1 << floor_log2 (max_vl)))\n+\treturn AARCH64_SV_POW2;\n+      if (vl == max_vl)\n+\treturn AARCH64_SV_ALL;\n+    }\n+  return AARCH64_NUM_SVPATTERNS;\n+}\n+\n /* Return an all-true predicate register of mode MODE.  */\n \n rtx\n@@ -3447,6 +3617,17 @@ aarch64_expand_sve_const_vector (rtx target, rtx src)\n   return target;\n }\n \n+/* Use WHILE to set predicate register DEST so that the first VL bits\n+   are set and the rest are clear.  */\n+\n+static void\n+aarch64_sve_move_pred_via_while (rtx dest, unsigned int vl)\n+{\n+  rtx limit = force_reg (DImode, gen_int_mode (vl, DImode));\n+  emit_insn (gen_while_ult (DImode, GET_MODE (dest),\n+\t\t\t    dest, const0_rtx, limit));\n+}\n+\n /* Set DEST to immediate IMM.  */\n \n void\n@@ -3580,6 +3761,19 @@ aarch64_expand_mov_immediate (rtx dest, rtx imm)\n \t  return;\n \t}\n \n+      rtx_vector_builder builder;\n+      if (GET_MODE_CLASS (GET_MODE (imm)) == MODE_VECTOR_BOOL\n+\t  && aarch64_get_sve_pred_bits (builder, imm))\n+\t{\n+\t  unsigned int elt_size = aarch64_widest_sve_pred_elt_size (builder);\n+\t  int vl = aarch64_partial_ptrue_length (builder, elt_size);\n+\t  if (vl > 0)\n+\t    {\n+\t      aarch64_sve_move_pred_via_while (dest, vl);\n+\t      return;\n+\t    }\n+\t}\n+\n       if (GET_CODE (imm) == CONST_VECTOR && aarch64_sve_data_mode_p (mode))\n \tif (rtx res = aarch64_expand_sve_const_vector (dest, imm))\n \t  {\n@@ -14776,6 +14970,44 @@ aarch64_sve_valid_immediate (unsigned HOST_WIDE_INT val64,\n   return false;\n }\n \n+/* Return true if X is a valid SVE predicate.  If INFO is nonnull, use\n+   it to describe valid immediates.  */\n+\n+static bool\n+aarch64_sve_pred_valid_immediate (rtx x, simd_immediate_info *info)\n+{\n+  if (x == CONST0_RTX (GET_MODE (x)))\n+    {\n+      if (info)\n+\t*info = simd_immediate_info (DImode, 0);\n+      return true;\n+    }\n+\n+  /* Analyze the value as a VNx16BImode.  This should be relatively\n+     efficient, since rtx_vector_builder has enough built-in capacity\n+     to store all VLA predicate constants without needing the heap.  */\n+  rtx_vector_builder builder;\n+  if (!aarch64_get_sve_pred_bits (builder, x))\n+    return false;\n+\n+  unsigned int elt_size = aarch64_widest_sve_pred_elt_size (builder);\n+  if (int vl = aarch64_partial_ptrue_length (builder, elt_size))\n+    {\n+      machine_mode mode = aarch64_sve_pred_mode (elt_size).require ();\n+      aarch64_svpattern pattern = aarch64_svpattern_for_vl (mode, vl);\n+      if (pattern != AARCH64_NUM_SVPATTERNS)\n+\t{\n+\t  if (info)\n+\t    {\n+\t      scalar_int_mode int_mode = aarch64_sve_element_int_mode (mode);\n+\t      *info = simd_immediate_info (int_mode, pattern);\n+\t    }\n+\t  return true;\n+\t}\n+    }\n+  return false;\n+}\n+\n /* Return true if OP is a valid SIMD immediate for the operation\n    described by WHICH.  If INFO is nonnull, use it to describe valid\n    immediates.  */\n@@ -14788,6 +15020,9 @@ aarch64_simd_valid_immediate (rtx op, simd_immediate_info *info,\n   if (vec_flags == 0 || vec_flags == (VEC_ADVSIMD | VEC_STRUCT))\n     return false;\n \n+  if (vec_flags & VEC_SVE_PRED)\n+    return aarch64_sve_pred_valid_immediate (op, info);\n+\n   scalar_mode elt_mode = GET_MODE_INNER (mode);\n   rtx base, step;\n   unsigned int n_elts;\n@@ -14812,21 +15047,6 @@ aarch64_simd_valid_immediate (rtx op, simd_immediate_info *info,\n   else\n     return false;\n \n-  /* Handle PFALSE and PTRUE.  */\n-  if (vec_flags & VEC_SVE_PRED)\n-    {\n-      if (op == CONST0_RTX (mode) || op == CONSTM1_RTX (mode))\n-\t{\n-\t  if (info)\n-\t    {\n-\t      scalar_int_mode int_mode = aarch64_sve_element_int_mode (mode);\n-\t      *info = simd_immediate_info (int_mode, op == CONSTM1_RTX (mode));\n-\t    }\n-\t  return true;\n-\t}\n-      return false;\n-    }\n-\n   scalar_float_mode elt_float_mode;\n   if (n_elts == 1\n       && is_a <scalar_float_mode> (elt_mode, &elt_float_mode))\n@@ -16570,14 +16790,23 @@ aarch64_output_sve_mov_immediate (rtx const_vector)\n   if (aarch64_sve_pred_mode_p (vec_mode))\n     {\n       static char buf[sizeof (\"ptrue\\t%0.N, vlNNNNN\")];\n-      unsigned int total_bytes;\n-      if (info.u.mov.value == const0_rtx)\n-\tsnprintf (buf, sizeof (buf), \"pfalse\\t%%0.b\");\n-      else if (BYTES_PER_SVE_VECTOR.is_constant (&total_bytes))\n-\tsnprintf (buf, sizeof (buf), \"ptrue\\t%%0.%c, vl%d\", element_char,\n-\t\t  total_bytes / GET_MODE_SIZE (info.elt_mode));\n+      if (info.insn == simd_immediate_info::MOV)\n+\t{\n+\t  gcc_assert (info.u.mov.value == const0_rtx);\n+\t  snprintf (buf, sizeof (buf), \"pfalse\\t%%0.b\");\n+\t}\n       else\n-\tsnprintf (buf, sizeof (buf), \"ptrue\\t%%0.%c, all\", element_char);\n+\t{\n+\t  gcc_assert (info.insn == simd_immediate_info::PTRUE);\n+\t  unsigned int total_bytes;\n+\t  if (info.u.pattern == AARCH64_SV_ALL\n+\t      && BYTES_PER_SVE_VECTOR.is_constant (&total_bytes))\n+\t    snprintf (buf, sizeof (buf), \"ptrue\\t%%0.%c, vl%d\", element_char,\n+\t\t      total_bytes / GET_MODE_SIZE (info.elt_mode));\n+\t  else\n+\t    snprintf (buf, sizeof (buf), \"ptrue\\t%%0.%c, %s\", element_char,\n+\t\t      svpattern_token (info.u.pattern));\n+\t}\n       return buf;\n     }\n "}, {"sha": "e21d8e110727227c2e44725442f22e232b5c5f9b", "filename": "gcc/fold-const-call.c", "status": "modified", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0b1fe8cf6f1dde656c505dde6d27279dff388962/gcc%2Ffold-const-call.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0b1fe8cf6f1dde656c505dde6d27279dff388962/gcc%2Ffold-const-call.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffold-const-call.c?ref=0b1fe8cf6f1dde656c505dde6d27279dff388962", "patch": "@@ -689,6 +689,36 @@ fold_const_vec_convert (tree ret_type, tree arg)\n   return elts.build ();\n }\n \n+/* Try to evaluate:\n+\n+      IFN_WHILE_ULT (ARG0, ARG1, (TYPE) { ... })\n+\n+   Return the value on success and null on failure.  */\n+\n+static tree\n+fold_while_ult (tree type, poly_uint64 arg0, poly_uint64 arg1)\n+{\n+  if (known_ge (arg0, arg1))\n+    return build_zero_cst (type);\n+\n+  if (maybe_ge (arg0, arg1))\n+    return NULL_TREE;\n+\n+  poly_uint64 diff = arg1 - arg0;\n+  poly_uint64 nelts = TYPE_VECTOR_SUBPARTS (type);\n+  if (known_ge (diff, nelts))\n+    return build_all_ones_cst (type);\n+\n+  unsigned HOST_WIDE_INT const_diff;\n+  if (known_le (diff, nelts) && diff.is_constant (&const_diff))\n+    {\n+      tree minus_one = build_minus_one_cst (TREE_TYPE (type));\n+      tree zero = build_zero_cst (TREE_TYPE (type));\n+      return build_vector_a_then_b (type, const_diff, minus_one, zero);\n+    }\n+  return NULL_TREE;\n+}\n+\n /* Try to evaluate:\n \n       *RESULT = FN (*ARG)\n@@ -1782,6 +1812,14 @@ fold_const_call (combined_fn fn, tree type, tree arg0, tree arg1, tree arg2)\n \t}\n       return NULL_TREE;\n \n+    case CFN_WHILE_ULT:\n+      {\n+\tpoly_uint64 parg0, parg1;\n+\tif (poly_int_tree_p (arg0, &parg0) && poly_int_tree_p (arg1, &parg1))\n+\t  return fold_while_ult (type, parg0, parg1);\n+\treturn NULL_TREE;\n+      }\n+\n     default:\n       return fold_const_call_1 (fn, type, arg0, arg1, arg2);\n     }"}, {"sha": "1147dc86a0ecce9dcf96afd32b1d57089e2de85b", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0b1fe8cf6f1dde656c505dde6d27279dff388962/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0b1fe8cf6f1dde656c505dde6d27279dff388962/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=0b1fe8cf6f1dde656c505dde6d27279dff388962", "patch": "@@ -1,3 +1,13 @@\n+2019-08-13  Richard Sandiford  <richard.sandiford@arm.com>\n+\n+\t* gcc.target/aarch64/sve/spill_2.c: Increase iteration counts\n+\tbeyond the range of a PTRUE.\n+\t* gcc.target/aarch64/sve/while_6.c: New test.\n+\t* gcc.target/aarch64/sve/while_7.c: Likewise.\n+\t* gcc.target/aarch64/sve/while_8.c: Likewise.\n+\t* gcc.target/aarch64/sve/while_9.c: Likewise.\n+\t* gcc.target/aarch64/sve/while_10.c: Likewise.\n+\n 2019-08-13  Steven G. Kargl  <kargl@gcc.gnu.org> \n \n \tPR fortran/88072"}, {"sha": "fcd481611ec96cbb5a35d51fdc30e980ed3e5efb", "filename": "gcc/testsuite/gcc.target/aarch64/sve/spill_2.c", "status": "modified", "additions": 9, "deletions": 8, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0b1fe8cf6f1dde656c505dde6d27279dff388962/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fspill_2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0b1fe8cf6f1dde656c505dde6d27279dff388962/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fspill_2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fspill_2.c?ref=0b1fe8cf6f1dde656c505dde6d27279dff388962", "patch": "@@ -9,29 +9,30 @@ void consumer (void *);\n   void\t\t\t\t\t\t\\\n   multi_loop_##TYPE (TYPE *x, TYPE val)\t\t\\\n   {\t\t\t\t\t\t\\\n-    for (int i = 0; i < 7; ++i)\t\t\t\\\n+    for (int i = 0; i < 9; ++i)\t\t\t\\\n       x[i] += val;\t\t\t\t\\\n     consumer (x);\t\t\t\t\\\n-    for (int i = 0; i < 7; ++i)\t\t\t\\\n+    for (int i = 0; i < 9; ++i)\t\t\t\\\n       x[i] += val;\t\t\t\t\\\n     consumer (x);\t\t\t\t\\\n-    for (int i = 0; i < 7; ++i)\t\t\t\\\n+    for (int i = 0; i < 9; ++i)\t\t\t\\\n       x[i] += val;\t\t\t\t\\\n     consumer (x);\t\t\t\t\\\n   }\n \n /* One iteration is enough.  */\n TEST_LOOP (uint8_t);\n+/* Two iterations are enough.  We specialize the second two loops based\n+   on whether the first executes once or twice.  */\n TEST_LOOP (uint16_t);\n-/* Two iterations are enough.  Complete unrolling makes sense\n-   even at -O2.  */\n+/* Three iterations are needed; ought to stay a loop.  */\n TEST_LOOP (uint32_t);\n-/* Four iterations are needed; ought to stay a loop.  */\n+/* Five iterations are needed; ought to stay a loop.  */\n TEST_LOOP (uint64_t);\n \n /* { dg-final { scan-assembler-times {\\twhilelo\\tp[0-9]\\.b} 3 } } */\n-/* { dg-final { scan-assembler-times {\\twhilelo\\tp[0-9]\\.h} 3 } } */\n-/* { dg-final { scan-assembler {\\twhilelo\\tp[0-9]\\.s} } } */\n+/* { dg-final { scan-assembler-times {\\twhilelo\\tp[0-9]\\.h} 8 } } */\n+/* { dg-final { scan-assembler-times {\\twhilelo\\tp[0-9]\\.s} 6 } } */\n /* { dg-final { scan-assembler-times {\\twhilelo\\tp[0-9]\\.d} 6 } } */\n /* { dg-final { scan-assembler-not {\\tldr\\tz[0-9]} } } */\n /* { dg-final { scan-assembler-not {\\tstr\\tz[0-9]} } } */"}, {"sha": "eaed326f99920ed95622b1106fdb9cc83c488ffb", "filename": "gcc/testsuite/gcc.target/aarch64/sve/while_10.c", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0b1fe8cf6f1dde656c505dde6d27279dff388962/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fwhile_10.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0b1fe8cf6f1dde656c505dde6d27279dff388962/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fwhile_10.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fwhile_10.c?ref=0b1fe8cf6f1dde656c505dde6d27279dff388962", "patch": "@@ -0,0 +1,25 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -ftree-vectorize -msve-vector-bits=512\" } */\n+\n+#include <stdint.h>\n+\n+#define ADD_LOOP(TYPE, COUNT)\t\t\t\\\n+  TYPE __attribute__ ((noinline, noclone))\t\\\n+  vec_while_##TYPE (TYPE *restrict a)\t\t\\\n+  {\t\t\t\t\t\t\\\n+    for (int i = 0; i < COUNT; ++i)\t       \t\\\n+      a[i] += 1;\t\t\t\t\\\n+  }\n+\n+#define TEST_ALL(T)\t\t\t\t\\\n+  T (int8_t, 63)\t\t\t\t\\\n+  T (int16_t, 30)\t\t\t\t\\\n+  T (int32_t, 15)\t\t\t\t\\\n+  T (int64_t, 6)\n+\n+TEST_ALL (ADD_LOOP)\n+\n+/* { dg-final { scan-assembler-times {\\tptrue\\tp[0-7]\\.b, mul3\\n} 1 } } */\n+/* { dg-final { scan-assembler-times {\\tptrue\\tp[0-7]\\.h, mul3\\n} 1 } } */\n+/* { dg-final { scan-assembler-times {\\tptrue\\tp[0-7]\\.s, mul3\\n} 1 } } */\n+/* { dg-final { scan-assembler-times {\\tptrue\\tp[0-7]\\.d, vl6\\n} 1 } } */"}, {"sha": "b4cc596efe74e8419e99be38f0d80dfebc196299", "filename": "gcc/testsuite/gcc.target/aarch64/sve/while_6.c", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0b1fe8cf6f1dde656c505dde6d27279dff388962/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fwhile_6.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0b1fe8cf6f1dde656c505dde6d27279dff388962/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fwhile_6.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fwhile_6.c?ref=0b1fe8cf6f1dde656c505dde6d27279dff388962", "patch": "@@ -0,0 +1,25 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -ftree-vectorize -msve-vector-bits=scalable\" } */\n+\n+#include <stdint.h>\n+\n+#define ADD_LOOP(TYPE)\t\t\t\t\\\n+  TYPE __attribute__ ((noinline, noclone))\t\\\n+  vec_while_##TYPE (TYPE *restrict a)\t\t\\\n+  {\t\t\t\t\t\t\\\n+    for (int i = 0; i < 7; ++i)\t\t\t\\\n+      a[i] += 1;\t\t\t\t\\\n+  }\n+\n+#define TEST_ALL(T)\t\t\t\t\\\n+  T (int8_t)\t\t\t\t\t\\\n+  T (int16_t)\t\t\t\t\t\\\n+  T (int32_t)\t\t\t\t\t\\\n+  T (int64_t)\n+\n+TEST_ALL (ADD_LOOP)\n+\n+/* { dg-final { scan-assembler-times {\\tptrue\\tp[0-7]\\.b, vl7\\n} 1 } } */\n+/* { dg-final { scan-assembler-times {\\tptrue\\tp[0-7]\\.h, vl7\\n} 1 } } */\n+/* { dg-final { scan-assembler-times {\\twhilelo\\tp[0-7]\\.s,} 2 } } */\n+/* { dg-final { scan-assembler-times {\\twhilelo\\tp[0-7]\\.d,} 2 } } */"}, {"sha": "d5ffb66a14237706386c5fd7da5c2a9ae21148b3", "filename": "gcc/testsuite/gcc.target/aarch64/sve/while_7.c", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0b1fe8cf6f1dde656c505dde6d27279dff388962/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fwhile_7.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0b1fe8cf6f1dde656c505dde6d27279dff388962/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fwhile_7.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fwhile_7.c?ref=0b1fe8cf6f1dde656c505dde6d27279dff388962", "patch": "@@ -0,0 +1,25 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -ftree-vectorize -msve-vector-bits=scalable\" } */\n+\n+#include <stdint.h>\n+\n+#define ADD_LOOP(TYPE)\t\t\t\t\\\n+  TYPE __attribute__ ((noinline, noclone))\t\\\n+  vec_while_##TYPE (TYPE *restrict a)\t\t\\\n+  {\t\t\t\t\t\t\\\n+    for (int i = 0; i < 8; ++i)\t\t\t\\\n+      a[i] += 1;\t\t\t\t\\\n+  }\n+\n+#define TEST_ALL(T)\t\t\t\t\\\n+  T (int8_t)\t\t\t\t\t\\\n+  T (int16_t)\t\t\t\t\t\\\n+  T (int32_t)\t\t\t\t\t\\\n+  T (int64_t)\n+\n+TEST_ALL (ADD_LOOP)\n+\n+/* { dg-final { scan-assembler-times {\\tptrue\\tp[0-7]\\.b, vl8\\n} 1 } } */\n+/* { dg-final { scan-assembler-times {\\tptrue\\tp[0-7]\\.h, vl8\\n} 1 } } */\n+/* { dg-final { scan-assembler-times {\\twhilelo\\tp[0-7]\\.s,} 2 } } */\n+/* { dg-final { scan-assembler-times {\\twhilelo\\tp[0-7]\\.d,} 2 } } */"}, {"sha": "1c11aa849a27ee9eb78238b679ee5a6565bd79d4", "filename": "gcc/testsuite/gcc.target/aarch64/sve/while_8.c", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0b1fe8cf6f1dde656c505dde6d27279dff388962/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fwhile_8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0b1fe8cf6f1dde656c505dde6d27279dff388962/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fwhile_8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fwhile_8.c?ref=0b1fe8cf6f1dde656c505dde6d27279dff388962", "patch": "@@ -0,0 +1,25 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -ftree-vectorize -msve-vector-bits=scalable\" } */\n+\n+#include <stdint.h>\n+\n+#define ADD_LOOP(TYPE)\t\t\t\t\\\n+  TYPE __attribute__ ((noinline, noclone))\t\\\n+  vec_while_##TYPE (TYPE *restrict a)\t\t\\\n+  {\t\t\t\t\t\t\\\n+    for (int i = 0; i < 9; ++i)\t\t\t\\\n+      a[i] += 1;\t\t\t\t\\\n+  }\n+\n+#define TEST_ALL(T)\t\t\t\t\\\n+  T (int8_t)\t\t\t\t\t\\\n+  T (int16_t)\t\t\t\t\t\\\n+  T (int32_t)\t\t\t\t\t\\\n+  T (int64_t)\n+\n+TEST_ALL (ADD_LOOP)\n+\n+/* { dg-final { scan-assembler-times {\\twhilelo\\tp[0-7]\\.b,} 1 } } */\n+/* { dg-final { scan-assembler-times {\\twhilelo\\tp[0-7]\\.h,} 2 } } */\n+/* { dg-final { scan-assembler-times {\\twhilelo\\tp[0-7]\\.s,} 2 } } */\n+/* { dg-final { scan-assembler-times {\\twhilelo\\tp[0-7]\\.d,} 2 } } */"}, {"sha": "9a8e5fe12fb1750e186e7fd4c34d991a2392b370", "filename": "gcc/testsuite/gcc.target/aarch64/sve/while_9.c", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0b1fe8cf6f1dde656c505dde6d27279dff388962/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fwhile_9.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0b1fe8cf6f1dde656c505dde6d27279dff388962/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fwhile_9.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fwhile_9.c?ref=0b1fe8cf6f1dde656c505dde6d27279dff388962", "patch": "@@ -0,0 +1,25 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -ftree-vectorize -msve-vector-bits=scalable\" } */\n+\n+#include <stdint.h>\n+\n+#define ADD_LOOP(TYPE)\t\t\t\t\\\n+  TYPE __attribute__ ((noinline, noclone))\t\\\n+  vec_while_##TYPE (TYPE *restrict a)\t\t\\\n+  {\t\t\t\t\t\t\\\n+    for (int i = 0; i < 16; ++i)\t       \t\\\n+      a[i] += 1;\t\t\t\t\\\n+  }\n+\n+#define TEST_ALL(T)\t\t\t\t\\\n+  T (int8_t)\t\t\t\t\t\\\n+  T (int16_t)\t\t\t\t\t\\\n+  T (int32_t)\t\t\t\t\t\\\n+  T (int64_t)\n+\n+TEST_ALL (ADD_LOOP)\n+\n+/* { dg-final { scan-assembler-times {\\tptrue\\tp[0-7]\\.b, vl16\\n} 1 } } */\n+/* { dg-final { scan-assembler-times {\\twhilelo\\tp[0-7]\\.h,} 2 } } */\n+/* { dg-final { scan-assembler-times {\\twhilelo\\tp[0-7]\\.s,} 2 } } */\n+/* { dg-final { scan-assembler-times {\\twhilelo\\tp[0-7]\\.d,} 2 } } */"}, {"sha": "ae292281b1f53dc2181dc63a31d7f3c969fe415f", "filename": "gcc/tree.c", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0b1fe8cf6f1dde656c505dde6d27279dff388962/gcc%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0b1fe8cf6f1dde656c505dde6d27279dff388962/gcc%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.c?ref=0b1fe8cf6f1dde656c505dde6d27279dff388962", "patch": "@@ -1981,6 +1981,23 @@ build_index_vector (tree vec_type, poly_uint64 base, poly_uint64 step)\n   return v.build ();\n }\n \n+/* Return a VECTOR_CST of type VEC_TYPE in which the first NUM_A\n+   elements are A and the rest are B.  */\n+\n+tree\n+build_vector_a_then_b (tree vec_type, unsigned int num_a, tree a, tree b)\n+{\n+  gcc_assert (known_le (num_a, TYPE_VECTOR_SUBPARTS (vec_type)));\n+  unsigned int count = constant_lower_bound (TYPE_VECTOR_SUBPARTS (vec_type));\n+  /* Optimize the constant case.  */\n+  if ((count & 1) == 0 && TYPE_VECTOR_SUBPARTS (vec_type).is_constant ())\n+    count /= 2;\n+  tree_vector_builder builder (vec_type, count, 2);\n+  for (unsigned int i = 0; i < count * 2; ++i)\n+    builder.quick_push (i < num_a ? a : b);\n+  return builder.build ();\n+}\n+\n /* Something has messed with the elements of CONSTRUCTOR C after it was built;\n    calculate TREE_CONSTANT and TREE_SIDE_EFFECTS.  */\n "}, {"sha": "dd54f4d2af5be51ad41d431dfbfebf5cd57d3bd4", "filename": "gcc/tree.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0b1fe8cf6f1dde656c505dde6d27279dff388962/gcc%2Ftree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0b1fe8cf6f1dde656c505dde6d27279dff388962/gcc%2Ftree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.h?ref=0b1fe8cf6f1dde656c505dde6d27279dff388962", "patch": "@@ -4314,6 +4314,7 @@ extern tree build_vector_from_val (tree, tree);\n extern tree build_uniform_cst (tree, tree);\n extern tree build_vec_series (tree, tree, tree);\n extern tree build_index_vector (tree, poly_uint64, poly_uint64);\n+extern tree build_vector_a_then_b (tree, unsigned int, tree, tree);\n extern void recompute_constructor_flags (tree);\n extern void verify_constructor_flags (tree);\n extern tree build_constructor (tree, vec<constructor_elt, va_gc> * CXX_MEM_STAT_INFO);"}]}