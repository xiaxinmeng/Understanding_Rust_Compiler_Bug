{"sha": "748bbe72024ab2840c6b8ab60cef124c4c83fbeb", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzQ4YmJlNzIwMjRhYjI4NDBjNmI4YWI2MGNlZjEyNGM0YzgzZmJlYg==", "commit": {"author": {"name": "Richard Sandiford", "email": "richard.sandiford@linaro.org", "date": "2017-05-31T12:05:10Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2017-05-31T12:05:10Z"}, "message": "Alternative check for vector refs with same alignment\n\nvect_find_same_alignment_drs uses the ddr dependence distance\nto tell whether two references have the same alignment.  Although\nthat's safe with the current code, there's no particular reason\nwhy a dependence distance of 0 should mean that the accesses start\non the same byte.  E.g. a reference to a full complex value could\nin principle depend on a reference to the imaginary component.\nA later patch adds support for this kind of dependence.\n\nOn the other side, checking modulo vf is pessimistic when the step\ndivided by the element size is a factor of 2.\n\nThis patch instead looks for cases in which the drs have the same\nbase, offset and step, and for which the difference in their constant\ninitial values is a multiple of the alignment.\n\n2017-05-03  Richard Sandiford  <richard.sandiford@linaro.org>\n\ngcc/\n\t* tree-vect-data-refs.c (vect_find_same_alignment_drs): Remove\n\tloop_vinfo argument and use of dependence distance vectors.\n\tCheck instead whether the two references differ only in their\n\tinitial value and assume that they have the same alignment if the\n\tdifference is a multiple of the vector alignment.\n\t(vect_analyze_data_refs_alignment): Update call accordingly.\n\ngcc/testsuite/\n\t* gcc.dg/vect/vect-103.c: Update wording of dump message.\n\nFrom-SVN: r248730", "tree": {"sha": "e197071263e0149c8d712d55d10e9c39086d8679", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e197071263e0149c8d712d55d10e9c39086d8679"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/748bbe72024ab2840c6b8ab60cef124c4c83fbeb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/748bbe72024ab2840c6b8ab60cef124c4c83fbeb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/748bbe72024ab2840c6b8ab60cef124c4c83fbeb", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/748bbe72024ab2840c6b8ab60cef124c4c83fbeb/comments", "author": null, "committer": null, "parents": [{"sha": "c9f161510200e1eae983102b6815c7eb8b4d18e4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c9f161510200e1eae983102b6815c7eb8b4d18e4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c9f161510200e1eae983102b6815c7eb8b4d18e4"}], "stats": {"total": 92, "additions": 43, "deletions": 49}, "files": [{"sha": "c6266526f48bfeac15dd64306f6f8759a1b6dcdc", "filename": "gcc/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/748bbe72024ab2840c6b8ab60cef124c4c83fbeb/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/748bbe72024ab2840c6b8ab60cef124c4c83fbeb/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=748bbe72024ab2840c6b8ab60cef124c4c83fbeb", "patch": "@@ -1,3 +1,12 @@\n+2017-05-31  Richard Sandiford  <richard.sandiford@linaro.org>\n+\n+\t* tree-vect-data-refs.c (vect_find_same_alignment_drs): Remove\n+\tloop_vinfo argument and use of dependence distance vectors.\n+\tCheck instead whether the two references differ only in their\n+\tinitial value and assume that they have the same alignment if the\n+\tdifference is a multiple of the vector alignment.\n+\t(vect_analyze_data_refs_alignment): Update call accordingly.\n+\n 2017-05-31  Martin Liska  <mliska@suse.cz>\n \n \tPR target/79155"}, {"sha": "cbad5692d3832bd99aabb628eaafb62555fd8aa6", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/748bbe72024ab2840c6b8ab60cef124c4c83fbeb/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/748bbe72024ab2840c6b8ab60cef124c4c83fbeb/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=748bbe72024ab2840c6b8ab60cef124c4c83fbeb", "patch": "@@ -1,3 +1,7 @@\n+2017-05-31  Richard Sandiford  <richard.sandiford@linaro.org>\n+\n+\t* gcc.dg/vect/vect-103.c: Update wording of dump message.\n+\n 2017-05-31  Bin Cheng  <bin.cheng@arm.com>\n \n \t* gcc.dg/vect/pr80815-3.c: New test."}, {"sha": "e0fd1b61e0235c763708504f87f78b64d1705320", "filename": "gcc/testsuite/gcc.dg/vect/vect-103.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/748bbe72024ab2840c6b8ab60cef124c4c83fbeb/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-103.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/748bbe72024ab2840c6b8ab60cef124c4c83fbeb/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-103.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-103.c?ref=748bbe72024ab2840c6b8ab60cef124c4c83fbeb", "patch": "@@ -55,5 +55,5 @@ int main (void)\n }\n \n /* { dg-final { scan-tree-dump-times \"vectorized 1 loops\" 1 \"vect\" } } */\n-/* { dg-final { scan-tree-dump-times \"dependence distance modulo vf == 0\" 1 \"vect\" } } */\n+/* { dg-final { scan-tree-dump-times \"accesses have the same alignment\" 1 \"vect\" } } */\n "}, {"sha": "e8e2658e2183f48c3895f9a52bc93a6f83016971", "filename": "gcc/tree-vect-data-refs.c", "status": "modified", "additions": 29, "deletions": 48, "changes": 77, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/748bbe72024ab2840c6b8ab60cef124c4c83fbeb/gcc%2Ftree-vect-data-refs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/748bbe72024ab2840c6b8ab60cef124c4c83fbeb/gcc%2Ftree-vect-data-refs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-data-refs.c?ref=748bbe72024ab2840c6b8ab60cef124c4c83fbeb", "patch": "@@ -2140,69 +2140,50 @@ vect_enhance_data_refs_alignment (loop_vec_info loop_vinfo)\n    vectorization factor.  */\n \n static void\n-vect_find_same_alignment_drs (struct data_dependence_relation *ddr,\n-\t\t\t      loop_vec_info loop_vinfo)\n+vect_find_same_alignment_drs (struct data_dependence_relation *ddr)\n {\n-  unsigned int i;\n-  struct loop *loop = LOOP_VINFO_LOOP (loop_vinfo);\n-  int vectorization_factor = LOOP_VINFO_VECT_FACTOR (loop_vinfo);\n   struct data_reference *dra = DDR_A (ddr);\n   struct data_reference *drb = DDR_B (ddr);\n   stmt_vec_info stmtinfo_a = vinfo_for_stmt (DR_STMT (dra));\n   stmt_vec_info stmtinfo_b = vinfo_for_stmt (DR_STMT (drb));\n-  int dra_size = GET_MODE_SIZE (TYPE_MODE (TREE_TYPE (DR_REF (dra))));\n-  int drb_size = GET_MODE_SIZE (TYPE_MODE (TREE_TYPE (DR_REF (drb))));\n-  lambda_vector dist_v;\n-  unsigned int loop_depth;\n \n   if (DDR_ARE_DEPENDENT (ddr) == chrec_known)\n     return;\n \n   if (dra == drb)\n     return;\n \n-  if (DDR_ARE_DEPENDENT (ddr) == chrec_dont_know)\n-    return;\n-\n-  /* Loop-based vectorization and known data dependence.  */\n-  if (DDR_NUM_DIST_VECTS (ddr) == 0)\n-    return;\n-\n-  /* Data-dependence analysis reports a distance vector of zero\n-     for data-references that overlap only in the first iteration\n-     but have different sign step (see PR45764).\n-     So as a sanity check require equal DR_STEP.  */\n-  if (!operand_equal_p (DR_STEP (dra), DR_STEP (drb), 0))\n+  if (!operand_equal_p (DR_BASE_OBJECT (dra), DR_BASE_OBJECT (drb),\n+\t\t\tOEP_ADDRESS_OF)\n+      || !operand_equal_p (DR_OFFSET (dra), DR_OFFSET (drb), 0)\n+      || !operand_equal_p (DR_STEP (dra), DR_STEP (drb), 0))\n     return;\n \n-  loop_depth = index_in_loop_nest (loop->num, DDR_LOOP_NEST (ddr));\n-  FOR_EACH_VEC_ELT (DDR_DIST_VECTS (ddr), i, dist_v)\n+  /* Two references with distance zero have the same alignment.  */\n+  offset_int diff = (wi::to_offset (DR_INIT (dra))\n+\t\t     - wi::to_offset (DR_INIT (drb)));\n+  if (diff != 0)\n     {\n-      int dist = dist_v[loop_depth];\n-\n-      if (dump_enabled_p ())\n-\tdump_printf_loc (MSG_NOTE, vect_location,\n-\t                 \"dependence distance  = %d.\\n\", dist);\n+      /* Get the wider of the two alignments.  */\n+      unsigned int align_a = TYPE_ALIGN_UNIT (STMT_VINFO_VECTYPE (stmtinfo_a));\n+      unsigned int align_b = TYPE_ALIGN_UNIT (STMT_VINFO_VECTYPE (stmtinfo_b));\n+      unsigned int max_align = MAX (align_a, align_b);\n+\n+      /* Require the gap to be a multiple of the larger vector alignment.  */\n+      if (!wi::multiple_of_p (diff, max_align, SIGNED))\n+\treturn;\n+    }\n \n-      /* Same loop iteration.  */\n-      if (dist == 0\n-\t  || (dist % vectorization_factor == 0 && dra_size == drb_size))\n-\t{\n-\t  /* Two references with distance zero have the same alignment.  */\n-\t  STMT_VINFO_SAME_ALIGN_REFS (stmtinfo_a).safe_push (drb);\n-\t  STMT_VINFO_SAME_ALIGN_REFS (stmtinfo_b).safe_push (dra);\n-\t  if (dump_enabled_p ())\n-\t    {\n-\t      dump_printf_loc (MSG_NOTE, vect_location,\n-\t                       \"accesses have the same alignment.\\n\");\n-\t      dump_printf (MSG_NOTE,\n-\t                   \"dependence distance modulo vf == 0 between \");\n-\t      dump_generic_expr (MSG_NOTE, TDF_SLIM, DR_REF (dra));\n-\t      dump_printf (MSG_NOTE,  \" and \");\n-\t      dump_generic_expr (MSG_NOTE, TDF_SLIM, DR_REF (drb));\n-\t      dump_printf (MSG_NOTE, \"\\n\");\n-\t    }\n-\t}\n+  STMT_VINFO_SAME_ALIGN_REFS (stmtinfo_a).safe_push (drb);\n+  STMT_VINFO_SAME_ALIGN_REFS (stmtinfo_b).safe_push (dra);\n+  if (dump_enabled_p ())\n+    {\n+      dump_printf_loc (MSG_NOTE, vect_location,\n+\t\t       \"accesses have the same alignment: \");\n+      dump_generic_expr (MSG_NOTE, TDF_SLIM, DR_REF (dra));\n+      dump_printf (MSG_NOTE,  \" and \");\n+      dump_generic_expr (MSG_NOTE, TDF_SLIM, DR_REF (drb));\n+      dump_printf (MSG_NOTE, \"\\n\");\n     }\n }\n \n@@ -2226,7 +2207,7 @@ vect_analyze_data_refs_alignment (loop_vec_info vinfo)\n   unsigned int i;\n \n   FOR_EACH_VEC_ELT (ddrs, i, ddr)\n-    vect_find_same_alignment_drs (ddr, vinfo);\n+    vect_find_same_alignment_drs (ddr);\n \n   vec<data_reference_p> datarefs = vinfo->datarefs;\n   struct data_reference *dr;"}]}