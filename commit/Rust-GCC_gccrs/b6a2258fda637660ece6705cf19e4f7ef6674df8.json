{"sha": "b6a2258fda637660ece6705cf19e4f7ef6674df8", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjZhMjI1OGZkYTYzNzY2MGVjZTY3MDVjZjE5ZTRmN2VmNjY3NGRmOA==", "commit": {"author": {"name": "Bin Cheng", "email": "bin.cheng@arm.com", "date": "2017-05-11T09:48:55Z"}, "committer": {"name": "Bin Cheng", "email": "amker@gcc.gnu.org", "date": "2017-05-11T09:48:55Z"}, "message": "tree-ssa-loop-ivopts.c (enum comp_iv_rewrite): New.\n\n\t* tree-ssa-loop-ivopts.c (enum comp_iv_rewrite): New.\n\t(extract_cond_operands): Detect condition comparing against non-\n\tinvariant bound and return appropriate enum value.\n\t(find_interesting_uses_cond): Update use of extract_cond_operands.\n\tHandle its return value accordingly.\n\t(determine_group_iv_cost_cond, rewrite_use_compare): Ditto.\n\nFrom-SVN: r247892", "tree": {"sha": "dc11aaf81c5aba8664bfdce011c774bf1ebfd849", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/dc11aaf81c5aba8664bfdce011c774bf1ebfd849"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b6a2258fda637660ece6705cf19e4f7ef6674df8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b6a2258fda637660ece6705cf19e4f7ef6674df8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b6a2258fda637660ece6705cf19e4f7ef6674df8", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b6a2258fda637660ece6705cf19e4f7ef6674df8/comments", "author": null, "committer": null, "parents": [{"sha": "014ef6e1323b3a2ac9ff1fd6a182698d78c7326a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/014ef6e1323b3a2ac9ff1fd6a182698d78c7326a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/014ef6e1323b3a2ac9ff1fd6a182698d78c7326a"}], "stats": {"total": 80, "additions": 55, "deletions": 25}, "files": [{"sha": "ab7b23b8453610b5ed3a4adb2c566d496392bf75", "filename": "gcc/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b6a2258fda637660ece6705cf19e4f7ef6674df8/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b6a2258fda637660ece6705cf19e4f7ef6674df8/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=b6a2258fda637660ece6705cf19e4f7ef6674df8", "patch": "@@ -1,3 +1,12 @@\n+2017-05-11  Bin Cheng  <bin.cheng@arm.com>\n+\n+\t* tree-ssa-loop-ivopts.c (enum comp_iv_rewrite): New.\n+\t(extract_cond_operands): Detect condition comparing against non-\n+\tinvariant bound and return appropriate enum value.\n+\t(find_interesting_uses_cond): Update use of extract_cond_operands.\n+\tHandle its return value accordingly.\n+\t(determine_group_iv_cost_cond, rewrite_use_compare): Ditto.\n+\n 2017-05-11  Bin Cheng  <bin.cheng@arm.com>\n \n \t* tree-ssa-loop-ivopts.c (rewrite_use_nonlinear_expr): Re-associate"}, {"sha": "2b080694aae47b241bf36a19530eb1a48ad31719", "filename": "gcc/tree-ssa-loop-ivopts.c", "status": "modified", "additions": 46, "deletions": 25, "changes": 71, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b6a2258fda637660ece6705cf19e4f7ef6674df8/gcc%2Ftree-ssa-loop-ivopts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b6a2258fda637660ece6705cf19e4f7ef6674df8/gcc%2Ftree-ssa-loop-ivopts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-ivopts.c?ref=b6a2258fda637660ece6705cf19e4f7ef6674df8", "patch": "@@ -1647,6 +1647,17 @@ find_interesting_uses_op (struct ivopts_data *data, tree op)\n   return use;\n }\n \n+/* Indicate how compare type iv_use can be handled.  */\n+enum comp_iv_rewrite\n+{\n+  COMP_IV_NA,\n+  /* We may rewrite compare type iv_use by expressing value of the iv_use.  */\n+  COMP_IV_EXPR,\n+  /* We may rewrite compare type iv_use by expressing value of the iv_use\n+     or by eliminating it with other iv_cand.  */\n+  COMP_IV_ELIM\n+};\n+\n /* Given a condition in statement STMT, checks whether it is a compare\n    of an induction variable and an invariant.  If this is the case,\n    CONTROL_VAR is set to location of the iv, BOUND to the location of\n@@ -1655,7 +1666,7 @@ find_interesting_uses_op (struct ivopts_data *data, tree op)\n    the case, CONTROL_VAR and BOUND are set to the arguments of the\n    condition and false is returned.  */\n \n-static bool\n+static enum comp_iv_rewrite\n extract_cond_operands (struct ivopts_data *data, gimple *stmt,\n \t\t       tree **control_var, tree **bound,\n \t\t       struct iv **iv_var, struct iv **iv_bound)\n@@ -1665,7 +1676,7 @@ extract_cond_operands (struct ivopts_data *data, gimple *stmt,\n   static tree zero;\n   tree *op0 = &zero, *op1 = &zero;\n   struct iv *iv0 = &const_iv, *iv1 = &const_iv;\n-  bool ret = false;\n+  enum comp_iv_rewrite rewrite_type = COMP_IV_NA;\n \n   if (gimple_code (stmt) == GIMPLE_COND)\n     {\n@@ -1687,18 +1698,27 @@ extract_cond_operands (struct ivopts_data *data, gimple *stmt,\n   if (TREE_CODE (*op1) == SSA_NAME)\n     iv1 = get_iv (data, *op1);\n \n-  /* Exactly one of the compared values must be an iv, and the other one must\n-     be an invariant.  */\n-  if (!iv0 || !iv1)\n+  /* If both sides of comparison are IVs.  */\n+  if (iv0 && iv1 && !integer_zerop (iv0->step) && !integer_zerop (iv1->step))\n     goto end;\n \n-  if (integer_zerop (iv0->step))\n+  /* If none side of comparison is IV.  */\n+  if ((!iv0 || integer_zerop (iv0->step))\n+      && (!iv1 || integer_zerop (iv1->step)))\n+    goto end;\n+\n+  /* Control variable may be on the other side.  */\n+  if (!iv0 || integer_zerop (iv0->step))\n     {\n-      /* Control variable may be on the other side.  */\n       std::swap (op0, op1);\n       std::swap (iv0, iv1);\n     }\n-  ret = !integer_zerop (iv0->step) && integer_zerop (iv1->step);\n+  /* If one side is IV and the other side isn't loop invariant.  */\n+  if (!iv1)\n+    rewrite_type = COMP_IV_EXPR;\n+  /* If one side is IV and the other side is loop invariant.  */\n+  else if (!integer_zerop (iv0->step) && integer_zerop (iv1->step))\n+    rewrite_type = COMP_IV_ELIM;\n \n end:\n   if (control_var)\n@@ -1710,7 +1730,7 @@ extract_cond_operands (struct ivopts_data *data, gimple *stmt,\n   if (iv_bound)\n     *iv_bound = iv1;\n \n-  return ret;\n+  return rewrite_type;\n }\n \n /* Checks whether the condition in STMT is interesting and if so,\n@@ -1721,15 +1741,17 @@ find_interesting_uses_cond (struct ivopts_data *data, gimple *stmt)\n {\n   tree *var_p, *bound_p;\n   struct iv *var_iv;\n+  enum comp_iv_rewrite ret;\n \n-  if (!extract_cond_operands (data, stmt, &var_p, &bound_p, &var_iv, NULL))\n+  ret = extract_cond_operands (data, stmt, &var_p, &bound_p, &var_iv, NULL);\n+  if (ret == COMP_IV_NA)\n     {\n       find_interesting_uses_op (data, *var_p);\n       find_interesting_uses_op (data, *bound_p);\n       return;\n     }\n \n-  record_group_use (data, NULL, var_iv, stmt, USE_COMPARE);\n+  record_group_use (data, var_p, var_iv, stmt, USE_COMPARE);\n }\n \n /* Returns the outermost loop EXPR is obviously invariant in\n@@ -5068,15 +5090,21 @@ determine_group_iv_cost_cond (struct ivopts_data *data,\n   struct iv *cmp_iv;\n   bitmap inv_exprs = NULL;\n   bitmap inv_vars_elim = NULL, inv_vars_express = NULL, inv_vars;\n-  comp_cost elim_cost, express_cost, cost, bound_cost;\n-  bool ok;\n+  comp_cost elim_cost = infinite_cost, express_cost, cost, bound_cost;\n+  enum comp_iv_rewrite rewrite_type;\n   iv_inv_expr_ent *inv_expr_elim = NULL, *inv_expr_express = NULL, *inv_expr;\n   tree *control_var, *bound_cst;\n   enum tree_code comp = ERROR_MARK;\n   struct iv_use *use = group->vuses[0];\n \n+  /* Extract condition operands.  */\n+  rewrite_type = extract_cond_operands (data, use->stmt, &control_var,\n+\t\t\t\t\t&bound_cst, NULL, &cmp_iv);\n+  gcc_assert (rewrite_type != COMP_IV_NA);\n+\n   /* Try iv elimination.  */\n-  if (may_eliminate_iv (data, use, cand, &bound, &comp))\n+  if (rewrite_type == COMP_IV_ELIM\n+      && may_eliminate_iv (data, use, cand, &bound, &comp))\n     {\n       elim_cost = force_var_cost (data, bound, &inv_vars_elim);\n       if (elim_cost.cost == 0)\n@@ -5098,14 +5126,6 @@ determine_group_iv_cost_cond (struct ivopts_data *data,\n \t once.  */\n       elim_cost.cost = adjust_setup_cost (data, elim_cost.cost);\n     }\n-  else\n-    elim_cost = infinite_cost;\n-\n-  /* Try expressing the original giv.  If it is compared with an invariant,\n-     note that we cannot get rid of it.  */\n-  ok = extract_cond_operands (data, use->stmt, &control_var, &bound_cst,\n-\t\t\t      NULL, &cmp_iv);\n-  gcc_assert (ok);\n \n   /* When the condition is a comparison of the candidate IV against\n      zero, prefer this IV.\n@@ -6938,7 +6958,7 @@ rewrite_use_compare (struct ivopts_data *data,\n   enum tree_code compare;\n   struct iv_group *group = data->vgroups[use->group_id];\n   struct cost_pair *cp = get_group_iv_cost (data, group, cand);\n-  bool ok;\n+  enum comp_iv_rewrite rewrite_type;\n \n   bound = cp->value;\n   if (bound)\n@@ -6972,8 +6992,9 @@ rewrite_use_compare (struct ivopts_data *data,\n   comp = get_computation_at (data->current_loop, use->stmt, use, cand);\n   gcc_assert (comp != NULL_TREE);\n \n-  ok = extract_cond_operands (data, use->stmt, &var_p, NULL, NULL, NULL);\n-  gcc_assert (ok);\n+  rewrite_type = extract_cond_operands (data, use->stmt,\n+\t\t\t\t\t&var_p, NULL, NULL, NULL);\n+  gcc_assert (rewrite_type != COMP_IV_NA);\n \n   *var_p = force_gimple_operand_gsi (&bsi, comp, true, SSA_NAME_VAR (*var_p),\n \t\t\t\t     true, GSI_SAME_STMT);"}]}