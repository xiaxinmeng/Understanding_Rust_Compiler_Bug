{"sha": "67b3acf8b79d87ed866e6c453f330e859fc009b4", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NjdiM2FjZjhiNzlkODdlZDg2NmU2YzQ1M2YzMzBlODU5ZmMwMDliNA==", "commit": {"author": {"name": "Robert Dewar", "email": "dewar@adacore.com", "date": "2009-07-13T08:17:02Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2009-07-13T08:17:02Z"}, "message": "freeze.adb (Check_Suspicious_Modulus): New procedure.\n\n2009-07-13  Robert Dewar  <dewar@adacore.com>\n\n\t* freeze.adb (Check_Suspicious_Modulus): New procedure.\n\nFrom-SVN: r149549", "tree": {"sha": "852c23fe7487606e430042627b39c8035b2a993a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/852c23fe7487606e430042627b39c8035b2a993a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/67b3acf8b79d87ed866e6c453f330e859fc009b4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/67b3acf8b79d87ed866e6c453f330e859fc009b4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/67b3acf8b79d87ed866e6c453f330e859fc009b4", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/67b3acf8b79d87ed866e6c453f330e859fc009b4/comments", "author": null, "committer": null, "parents": [{"sha": "cfb120b55dc31f9d6dc27a63747ec436fd6a80f2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cfb120b55dc31f9d6dc27a63747ec436fd6a80f2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cfb120b55dc31f9d6dc27a63747ec436fd6a80f2"}], "stats": {"total": 83, "additions": 83, "deletions": 0}, "files": [{"sha": "b41367816ce93704c5de3f7d837e7855635182cb", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/67b3acf8b79d87ed866e6c453f330e859fc009b4/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/67b3acf8b79d87ed866e6c453f330e859fc009b4/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=67b3acf8b79d87ed866e6c453f330e859fc009b4", "patch": "@@ -1,3 +1,7 @@\n+2009-07-13  Robert Dewar  <dewar@adacore.com>\n+\n+\t* freeze.adb (Check_Suspicious_Modulus): New procedure.\n+\n 2009-07-13  Robert Dewar  <dewar@adacore.com>\n \n \t* i-cobol.ads: Minor code fix (2**4 instead of 16 as modulus to avoid"}, {"sha": "61530e38867dc0b786e9875285189cf059993c97", "filename": "gcc/ada/freeze.adb", "status": "modified", "additions": 79, "deletions": 0, "changes": 79, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/67b3acf8b79d87ed866e6c453f330e859fc009b4/gcc%2Fada%2Ffreeze.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/67b3acf8b79d87ed866e6c453f330e859fc009b4/gcc%2Fada%2Ffreeze.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Ffreeze.adb?ref=67b3acf8b79d87ed866e6c453f330e859fc009b4", "patch": "@@ -1455,6 +1455,11 @@ package body Freeze is\n       --  which is the current instance type can only be applied when the type\n       --  is limited.\n \n+      procedure Check_Suspicious_Modulus (Utype : Entity_Id);\n+      --  Give warning for modulus of 8, 16, 32, or 64 given as an explicit\n+      --  integer literal without an explicit corresponding size clause. The\n+      --  caller has checked that Utype is a modular integer type.\n+\n       function After_Last_Declaration return Boolean;\n       --  If Loc is a freeze_entity that appears after the last declaration\n       --  in the scope, inhibit error messages on late completion.\n@@ -1547,6 +1552,76 @@ package body Freeze is\n          end if;\n       end Check_Current_Instance;\n \n+      ------------------------------\n+      -- Check_Suspicious_Modulus --\n+      ------------------------------\n+\n+      procedure Check_Suspicious_Modulus (Utype : Entity_Id) is\n+         Decl : constant Node_Id := Declaration_Node (Underlying_Type (Utype));\n+\n+      begin\n+         if Nkind (Decl) = N_Full_Type_Declaration then\n+            declare\n+               Tdef : constant Node_Id := Type_Definition (Decl);\n+            begin\n+               if Nkind (Tdef) = N_Modular_Type_Definition then\n+                  declare\n+                     Modulus : constant Node_Id :=\n+                                 Original_Node (Expression (Tdef));\n+                  begin\n+                     if Nkind (Modulus) = N_Integer_Literal then\n+                        declare\n+                           Modv : constant Uint := Intval (Modulus);\n+                           Sizv : constant Uint := RM_Size (Utype);\n+\n+                        begin\n+                           --  First case, modulus and size are the same. This\n+                           --  happens if you have something like mod 32, with\n+                           --  an explicit size of 32, this is for sure a case\n+                           --  where the warning is given, since it is seems\n+                           --  very unlikely that someone would want e.g. a\n+                           --  five bit type stored in 32 bits. It is much\n+                           --  more likely they wanted a 32-bit type.\n+\n+                           if Modv = Sizv then\n+                              null;\n+\n+                           --  Second case, the modulus is 32 or 64 and no\n+                           --  size clause is present. This is a less clear\n+                           --  case for giving the warning, but in the case\n+                           --  of 32/64 (5-bit or 6-bit types) these seem rare\n+                           --  enough that it is a likely error (and in any\n+                           --  case using 2**5 or 2**6 in these cases seems\n+                           --  clearer. We don't include 8 or 16 here, simply\n+                           --  because in practice 3-bit and 4-bit types are\n+                           --  more common and too many false positives if\n+                           --  we warn in these cases.\n+\n+                           elsif not Has_Size_Clause (Utype)\n+                             and then (Modv = Uint_32 or else Modv = Uint_64)\n+                           then\n+                              null;\n+\n+                           --  No warning needed\n+\n+                           else\n+                              return;\n+                           end if;\n+\n+                           --  If we fall through, give warning\n+\n+                           Error_Msg_Uint_1 := Modv;\n+                           Error_Msg_N\n+                             (\"?2 '*'*^' may have been intended here\",\n+                              Modulus);\n+                        end;\n+                     end if;\n+                  end;\n+               end if;\n+            end;\n+         end if;\n+      end Check_Suspicious_Modulus;\n+\n       ------------------------\n       -- Freeze_Record_Type --\n       ------------------------\n@@ -3617,6 +3692,10 @@ package body Freeze is\n          elsif Is_Integer_Type (E) then\n             Adjust_Esize_For_Alignment (E);\n \n+            if Is_Modular_Integer_Type (E) then\n+               Check_Suspicious_Modulus (E);\n+            end if;\n+\n          elsif Is_Access_Type (E) then\n \n             --  Check restriction for standard storage pool"}]}