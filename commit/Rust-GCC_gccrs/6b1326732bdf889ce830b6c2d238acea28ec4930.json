{"sha": "6b1326732bdf889ce830b6c2d238acea28ec4930", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NmIxMzI2NzMyYmRmODg5Y2U4MzBiNmMyZDIzOGFjZWEyOGVjNDkzMA==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@redhat.com", "date": "2004-12-02T18:31:26Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2004-12-02T18:31:26Z"}, "message": "optabs.c (lowpart_subreg_maybe_copy): New.\n\n        * optabs.c (lowpart_subreg_maybe_copy): New.\n        (expand_unop, expand_abs_nojump): Use it.\n\nFrom-SVN: r91650", "tree": {"sha": "4f3f14e10e3132e1dd06c628f3a496fb44bcf651", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/4f3f14e10e3132e1dd06c628f3a496fb44bcf651"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6b1326732bdf889ce830b6c2d238acea28ec4930", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6b1326732bdf889ce830b6c2d238acea28ec4930", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6b1326732bdf889ce830b6c2d238acea28ec4930", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6b1326732bdf889ce830b6c2d238acea28ec4930/comments", "author": null, "committer": null, "parents": [{"sha": "dea1c1c5366ffb20410328c725af453484fd8dcb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dea1c1c5366ffb20410328c725af453484fd8dcb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/dea1c1c5366ffb20410328c725af453484fd8dcb"}], "stats": {"total": 31, "additions": 29, "deletions": 2}, "files": [{"sha": "96ef779b2e608173cab91c9840ef3e4312005e57", "filename": "gcc/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6b1326732bdf889ce830b6c2d238acea28ec4930/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6b1326732bdf889ce830b6c2d238acea28ec4930/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=6b1326732bdf889ce830b6c2d238acea28ec4930", "patch": "@@ -1,3 +1,8 @@\n+2004-12-02  Richard Henderson  <rth@redhat.com>\n+\n+\t* optabs.c (lowpart_subreg_maybe_copy): New.\n+\t(expand_unop, expand_abs_nojump): Use it.\n+\n 2004-12-02  J\"orn Rennecke <joern.rennecke@st.com>\n \n \t* sh.md (extv, extzv): Add pattern predicate."}, {"sha": "abf8e296f24e1de17f57ab978a5b1b56383dca27", "filename": "gcc/optabs.c", "status": "modified", "additions": 24, "deletions": 2, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6b1326732bdf889ce830b6c2d238acea28ec4930/gcc%2Foptabs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6b1326732bdf889ce830b6c2d238acea28ec4930/gcc%2Foptabs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Foptabs.c?ref=6b1326732bdf889ce830b6c2d238acea28ec4930", "patch": "@@ -2131,6 +2131,26 @@ expand_parity (enum machine_mode mode, rtx op0, rtx target)\n   return 0;\n }\n \n+/* Extract the OMODE lowpart from VAL, which has IMODE.  Under certain \n+   conditions, VAL may already be a SUBREG against which we cannot generate\n+   a further SUBREG.  In this case, we expect forcing the value into a\n+   register will work around the situation.  */\n+\n+static rtx\n+lowpart_subreg_maybe_copy (enum machine_mode omode, rtx val,\n+\t\t\t   enum machine_mode imode)\n+{\n+  rtx ret;\n+  ret = lowpart_subreg (omode, val, imode);\n+  if (ret == NULL)\n+    {\n+      val = force_reg (imode, val);\n+      ret = lowpart_subreg (omode, val, imode);\n+      gcc_assert (ret != NULL);\n+    }\n+  return ret;\n+}\n+\n /* Generate code to perform an operation specified by UNOPTAB\n    on operand OP0, with result having machine-mode MODE.\n \n@@ -2322,7 +2342,8 @@ expand_unop (enum machine_mode mode, optab unoptab, rtx op0, rtx target,\n \t      rtx insn;\n \t      if (target == 0)\n \t\ttarget = gen_reg_rtx (mode);\n-\t      insn = emit_move_insn (target, gen_lowpart (mode, temp));\n+\t      temp = lowpart_subreg_maybe_copy (mode, temp, imode);\n+\t      insn = emit_move_insn (target, temp);\n \t      set_unique_reg_note (insn, REG_EQUAL,\n \t\t\t\t   gen_rtx_fmt_e (NEG, mode,\n \t\t\t\t\t\t  copy_rtx (op0)));\n@@ -2513,7 +2534,8 @@ expand_abs_nojump (enum machine_mode mode, rtx op0, rtx target,\n \t      rtx insn;\n \t      if (target == 0)\n \t\ttarget = gen_reg_rtx (mode);\n-\t      insn = emit_move_insn (target, gen_lowpart (mode, temp));\n+\t      temp = lowpart_subreg_maybe_copy (mode, temp, imode);\n+\t      insn = emit_move_insn (target, temp);\n \t      set_unique_reg_note (insn, REG_EQUAL,\n \t\t\t\t   gen_rtx_fmt_e (ABS, mode,\n \t\t\t\t\t\t  copy_rtx (op0)));"}]}