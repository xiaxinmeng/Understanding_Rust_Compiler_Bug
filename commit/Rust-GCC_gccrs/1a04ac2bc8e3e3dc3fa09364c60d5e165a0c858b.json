{"sha": "1a04ac2bc8e3e3dc3fa09364c60d5e165a0c858b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MWEwNGFjMmJjOGUzZTNkYzNmYTA5MzY0YzYwZDVlMTY1YTBjODU4Yg==", "commit": {"author": {"name": "John David Anglin", "email": "dave.anglin@nrc-cnrc.gc.ca", "date": "2013-02-03T19:52:37Z"}, "committer": {"name": "John David Anglin", "email": "danglin@gcc.gnu.org", "date": "2013-02-03T19:52:37Z"}, "message": "constraints.md: Adjust unused letters.\n\n\t* config/pa/constraints.md: Adjust unused letters.  Change \"T\"\n\tconstraint to match_test floating_point_store_memory_operand().\n\t* config/pa/predicates.md (reg_plus_base_memory_operand): New.\n\t(base14_operand): New.\n\t(floating_point_store_memory_operand): New.\n\t(integer_store_memory_operand): Revise to use base14_operand and\n\treg_plus_base_memory_operand.\n\t(move_dest_operand): Allow symbolic_memory_operands.\n\t(symbolic_memory_operand): Check for LO_SOM.\n\t(symbolic_operand): Change default case to break.\n\t* config/pa/pa.md: Remove unamed DFmode and SFmode patterns to force\n\tCONST_DOUBLE values to be reloaded by putting them into memory when\n\tthe destination is a floating point register.\n\t(movdf): Remove code to handle CONST_DOUBLE.\n\t(movsf): Likewise.\n\t(reload_indf_r1): New.\n\t(reload_insf_r1): New.\n\tConsistently use \"Q\" and \"T\" constraints with integer and floating\n\tpoint move instructions, respectively.\n\t(movdi): Remove FAIL.\n\tChange predicate for source operand unamed DImode move from\n\tgeneral_operand to move_src_operand.\n\t(umulsidi3): Change predicate for destination operand to\n\tregister_operand.\n\tLikewise for similar unamed patterns.\n\t* config/pa/pa-protos.h (pa_legitimize_reload_address): Declare.\n\t* config/pa/pa.c (pa_symbolic_expression_p): Remove extra parenthesis.\n\t(hppa_legitimize_address): Simplify mask calculation.\n\t(pa_emit_move_sequence): Revised handling of secondary reloads from\n\tREG+D addresses for floating point loads and stores.  Directly handle\n\tloading CONST0_RTX (mode) to a floating point register.\n\t(pa_secondary_reload): Handle reloading DF and SFmode constant values\n\tto floating point registers.  Don't restrict secondary reloads to\n\tfloating point registers to integer modes.  Revise some comments and\n\tcleanup some code.\n\t(TARGET_LEGITIMATE_ADDRESS_P): Define.\n\t(pa_legitimate_address_p): New.\n\t(pa_legitimize_reload_address): New.\n\t* config/pa/pa.h (STRICT_REG_OK_FOR_INDEX_P): New.\n\t(STRICT_REG_OK_FOR_BASE_P): New.\n\t(GO_IF_LEGITIMATE_ADDRESS): Delete.  Update some related comments.\n\t(LEGITIMIZE_RELOAD_ADDRESS): Revise to use pa_legitimize_reload_address.\n\nFrom-SVN: r195702", "tree": {"sha": "7a49ae3218a0594dad99ab926d440ac1c4de8224", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/7a49ae3218a0594dad99ab926d440ac1c4de8224"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/1a04ac2bc8e3e3dc3fa09364c60d5e165a0c858b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1a04ac2bc8e3e3dc3fa09364c60d5e165a0c858b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1a04ac2bc8e3e3dc3fa09364c60d5e165a0c858b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1a04ac2bc8e3e3dc3fa09364c60d5e165a0c858b/comments", "author": null, "committer": null, "parents": [{"sha": "405feeb871aeaab47856a361f8a65641b7e181b1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/405feeb871aeaab47856a361f8a65641b7e181b1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/405feeb871aeaab47856a361f8a65641b7e181b1"}], "stats": {"total": 958, "additions": 562, "deletions": 396}, "files": [{"sha": "103976fc83304b8bb312dc26c3827c26a5f09278", "filename": "gcc/ChangeLog", "status": "modified", "additions": 45, "deletions": 0, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a04ac2bc8e3e3dc3fa09364c60d5e165a0c858b/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a04ac2bc8e3e3dc3fa09364c60d5e165a0c858b/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=1a04ac2bc8e3e3dc3fa09364c60d5e165a0c858b", "patch": "@@ -1,3 +1,48 @@\n+2013-02-03  John David Anglin  <dave.anglin@nrc-cnrc.gc.ca>\n+\n+\t* config/pa/constraints.md: Adjust unused letters.  Change \"T\"\n+\tconstraint to match_test floating_point_store_memory_operand().\n+\t* config/pa/predicates.md (reg_plus_base_memory_operand): New.\n+\t(base14_operand): New.\n+\t(floating_point_store_memory_operand): New.\n+\t(integer_store_memory_operand): Revise to use base14_operand and\n+\treg_plus_base_memory_operand.\n+\t(move_dest_operand): Allow symbolic_memory_operands.\n+\t(symbolic_memory_operand): Check for LO_SOM.\n+\t(symbolic_operand): Change default case to break.\n+\t* config/pa/pa.md: Remove unamed DFmode and SFmode patterns to force\n+\tCONST_DOUBLE values to be reloaded by putting them into memory when\n+\tthe destination is a floating point register.\n+\t(movdf): Remove code to handle CONST_DOUBLE.\n+\t(movsf): Likewise.\n+\t(reload_indf_r1): New.\n+\t(reload_insf_r1): New.\n+\tConsistently use \"Q\" and \"T\" constraints with integer and floating\n+\tpoint move instructions, respectively.\n+\t(movdi): Remove FAIL.\n+\tChange predicate for source operand unamed DImode move from\n+\tgeneral_operand to move_src_operand.\n+\t(umulsidi3): Change predicate for destination operand to\n+\tregister_operand.\n+\tLikewise for similar unamed patterns.\n+\t* config/pa/pa-protos.h (pa_legitimize_reload_address): Declare.\n+\t* config/pa/pa.c (pa_symbolic_expression_p): Remove extra parenthesis.\n+\t(hppa_legitimize_address): Simplify mask calculation.\n+\t(pa_emit_move_sequence): Revised handling of secondary reloads from\n+\tREG+D addresses for floating point loads and stores.  Directly handle\n+\tloading CONST0_RTX (mode) to a floating point register.\n+\t(pa_secondary_reload): Handle reloading DF and SFmode constant values\n+\tto floating point registers.  Don't restrict secondary reloads to\n+\tfloating point registers to integer modes.  Revise some comments and\n+\tcleanup some code.\n+\t(TARGET_LEGITIMATE_ADDRESS_P): Define.\n+\t(pa_legitimate_address_p): New.\n+\t(pa_legitimize_reload_address): New.\n+\t* config/pa/pa.h (STRICT_REG_OK_FOR_INDEX_P): New.\n+\t(STRICT_REG_OK_FOR_BASE_P): New.\n+\t(GO_IF_LEGITIMATE_ADDRESS): Delete.  Update some related comments.\n+\t(LEGITIMIZE_RELOAD_ADDRESS): Revise to use pa_legitimize_reload_address.\n+\n 2013-02-03  David Edelsohn  <dje.gcc@gmail.com>\n \t    Andrew Dixie  <andrewd@gentrack.com>\n "}, {"sha": "bdc119e4d31b1a55ff2a551c0382c1e7647448bc", "filename": "gcc/config/pa/constraints.md", "status": "modified", "additions": 3, "deletions": 8, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a04ac2bc8e3e3dc3fa09364c60d5e165a0c858b/gcc%2Fconfig%2Fpa%2Fconstraints.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a04ac2bc8e3e3dc3fa09364c60d5e165a0c858b/gcc%2Fconfig%2Fpa%2Fconstraints.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpa%2Fconstraints.md?ref=1a04ac2bc8e3e3dc3fa09364c60d5e165a0c858b", "patch": "@@ -18,8 +18,8 @@\n ;; <http://www.gnu.org/licenses/>.\n \n ;;; Unused letters:\n-;;;    ABCDEF H             V  Y \n-;;;     bcde ghijklmnop  stuvw  z\n+;;;    ABCD   H                Y \n+;;;     bcde  h jkl       tuvw  z\n \n ;; Register constraints.\n (define_register_constraint \"a\" \"R1_REGS\"\n@@ -124,12 +124,7 @@\n \n (define_constraint \"T\"\n   \"A memory operand for floating-point loads and stores.\"\n-  (and (match_code \"mem\")\n-       (match_test \"!IS_LO_SUM_DLT_ADDR_P (XEXP (op, 0))\n-\t\t    && !IS_INDEX_ADDR_P (XEXP (op, 0))\n-\t\t    && memory_address_p ((GET_MODE_SIZE (mode) == 4\n-\t\t\t\t\t  ? SFmode : DFmode),\n-\t\t\t\t\t XEXP (op, 0))\")))\n+  (match_test \"floating_point_store_memory_operand (op, mode)\"))\n \n ;; We could allow short displacements but TARGET_LEGITIMATE_ADDRESS_P\n ;; can't tell when a long displacement is valid."}, {"sha": "ab1763a5d19b56324a11040f61aa37127b9404bd", "filename": "gcc/config/pa/pa-protos.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a04ac2bc8e3e3dc3fa09364c60d5e165a0c858b/gcc%2Fconfig%2Fpa%2Fpa-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a04ac2bc8e3e3dc3fa09364c60d5e165a0c858b/gcc%2Fconfig%2Fpa%2Fpa-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpa%2Fpa-protos.h?ref=1a04ac2bc8e3e3dc3fa09364c60d5e165a0c858b", "patch": "@@ -67,6 +67,8 @@ extern int pa_fpstore_bypass_p (rtx, rtx);\n extern int pa_attr_length_millicode_call (rtx);\n extern int pa_attr_length_call (rtx, int);\n extern int pa_attr_length_indirect_call (rtx);\n+extern rtx pa_legitimize_reload_address (rtx, enum machine_mode,\n+\t\t\t\t\t int, int, int);\n \n /* Declare functions defined in pa.c and used in templates.  */\n "}, {"sha": "36eba24d6234aa020140b01cd47b7f413f00f6e2", "filename": "gcc/config/pa/pa.c", "status": "modified", "additions": 326, "deletions": 56, "changes": 382, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a04ac2bc8e3e3dc3fa09364c60d5e165a0c858b/gcc%2Fconfig%2Fpa%2Fpa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a04ac2bc8e3e3dc3fa09364c60d5e165a0c858b/gcc%2Fconfig%2Fpa%2Fpa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpa%2Fpa.c?ref=1a04ac2bc8e3e3dc3fa09364c60d5e165a0c858b", "patch": "@@ -187,6 +187,7 @@ static section *pa_function_section (tree, enum node_frequency, bool, bool);\n static bool pa_cannot_force_const_mem (enum machine_mode, rtx);\n static bool pa_legitimate_constant_p (enum machine_mode, rtx);\n static unsigned int pa_section_type_flags (tree, const char *, int);\n+static bool pa_legitimate_address_p (enum machine_mode, rtx, bool);\n \n /* The following extra sections are only used for SOM.  */\n static GTY(()) section *som_readonly_data_section;\n@@ -384,6 +385,8 @@ static size_t n_deferred_plabels = 0;\n #define TARGET_LEGITIMATE_CONSTANT_P pa_legitimate_constant_p\n #undef TARGET_SECTION_TYPE_FLAGS\n #define TARGET_SECTION_TYPE_FLAGS pa_section_type_flags\n+#undef TARGET_LEGITIMATE_ADDRESS_P\n+#define TARGET_LEGITIMATE_ADDRESS_P pa_legitimate_address_p\n \n struct gcc_target targetm = TARGET_INITIALIZER;\n \f\n@@ -685,7 +688,7 @@ pa_symbolic_expression_p (rtx x)\n   if (GET_CODE (x) == HIGH)\n     x = XEXP (x, 0);\n \n-  return (symbolic_operand (x, VOIDmode));\n+  return symbolic_operand (x, VOIDmode);\n }\n \n /* Accept any constant that can be moved in one instruction into a\n@@ -1057,7 +1060,7 @@ hppa_legitimize_address (rtx x, rtx oldx ATTRIBUTE_UNUSED,\n       int mask;\n \n       mask = (GET_MODE_CLASS (mode) == MODE_FLOAT\n-\t      ? (INT14_OK_STRICT ? 0x3fff : 0x1f) : 0x3fff);\n+\t      && !INT14_OK_STRICT ? 0x1f : 0x3fff);\n \n       /* Choose which way to round the offset.  Round up if we\n \t are >= halfway to the next boundary.  */\n@@ -1393,7 +1396,7 @@ hppa_register_move_cost (enum machine_mode mode ATTRIBUTE_UNUSED,\n    PIC addresses are very expensive.\n \n    It is no coincidence that this has the same structure\n-   as GO_IF_LEGITIMATE_ADDRESS.  */\n+   as pa_legitimate_address_p.  */\n \n static int\n hppa_address_cost (rtx X, enum machine_mode mode ATTRIBUTE_UNUSED,\n@@ -1650,14 +1653,10 @@ pa_emit_move_sequence (rtx *operands, enum machine_mode mode, rtx scratch_reg)\n      (subreg (mem (addr))) cases.  */\n   if (scratch_reg\n       && fp_reg_operand (operand0, mode)\n-      && ((GET_CODE (operand1) == MEM\n-\t   && !memory_address_p ((GET_MODE_SIZE (mode) == 4 ? SFmode : DFmode),\n-\t\t\t\t XEXP (operand1, 0)))\n-\t  || ((GET_CODE (operand1) == SUBREG\n-\t       && GET_CODE (XEXP (operand1, 0)) == MEM\n-\t       && !memory_address_p ((GET_MODE_SIZE (mode) == 4\n-\t\t\t\t      ? SFmode : DFmode),\n-\t\t\t\t     XEXP (XEXP (operand1, 0), 0))))))\n+      && (MEM_P (operand1)\n+\t  || (GET_CODE (operand1) == SUBREG\n+\t      && MEM_P (XEXP (operand1, 0))))\n+      && !floating_point_store_memory_operand (operand1, mode))\n     {\n       if (GET_CODE (operand1) == SUBREG)\n \toperand1 = XEXP (operand1, 0);\n@@ -1669,7 +1668,10 @@ pa_emit_move_sequence (rtx *operands, enum machine_mode mode, rtx scratch_reg)\n \n       /* D might not fit in 14 bits either; for such cases load D into\n \t scratch reg.  */\n-      if (!memory_address_p (Pmode, XEXP (operand1, 0)))\n+      if (reg_plus_base_memory_operand (operand1, mode)\n+\t  && !(TARGET_PA_20\n+\t       && !TARGET_ELF32\n+\t       && INT_14_BITS (XEXP (XEXP (operand1, 0), 1))))\n \t{\n \t  emit_move_insn (scratch_reg, XEXP (XEXP (operand1, 0), 1));\n \t  emit_move_insn (scratch_reg,\n@@ -1686,15 +1688,10 @@ pa_emit_move_sequence (rtx *operands, enum machine_mode mode, rtx scratch_reg)\n     }\n   else if (scratch_reg\n \t   && fp_reg_operand (operand1, mode)\n-\t   && ((GET_CODE (operand0) == MEM\n-\t\t&& !memory_address_p ((GET_MODE_SIZE (mode) == 4\n-\t\t\t\t\t? SFmode : DFmode),\n-\t\t\t\t       XEXP (operand0, 0)))\n-\t       || ((GET_CODE (operand0) == SUBREG)\n-\t\t   && GET_CODE (XEXP (operand0, 0)) == MEM\n-\t\t   && !memory_address_p ((GET_MODE_SIZE (mode) == 4\n-\t\t\t\t\t  ? SFmode : DFmode),\n-\t\t\t   \t\t XEXP (XEXP (operand0, 0), 0)))))\n+\t   && (MEM_P (operand0)\n+\t       || (GET_CODE (operand0) == SUBREG\n+\t\t   && MEM_P (XEXP (operand0, 0))))\n+\t   && !floating_point_store_memory_operand (operand0, mode))\n     {\n       if (GET_CODE (operand0) == SUBREG)\n \toperand0 = XEXP (operand0, 0);\n@@ -1706,7 +1703,10 @@ pa_emit_move_sequence (rtx *operands, enum machine_mode mode, rtx scratch_reg)\n \n       /* D might not fit in 14 bits either; for such cases load D into\n \t scratch reg.  */\n-      if (!memory_address_p (Pmode, XEXP (operand0, 0)))\n+      if (reg_plus_base_memory_operand (operand0, mode)\n+\t  && !(TARGET_PA_20\n+\t       && !TARGET_ELF32\n+\t       && INT_14_BITS (XEXP (XEXP (operand0, 0), 1))))\n \t{\n \t  emit_move_insn (scratch_reg, XEXP (XEXP (operand0, 0), 1));\n \t  emit_move_insn (scratch_reg, gen_rtx_fmt_ee (GET_CODE (XEXP (operand0,\n@@ -1724,20 +1724,22 @@ pa_emit_move_sequence (rtx *operands, enum machine_mode mode, rtx scratch_reg)\n       return 1;\n     }\n   /* Handle secondary reloads for loads of FP registers from constant\n-     expressions by forcing the constant into memory.\n+     expressions by forcing the constant into memory.  For the most part,\n+     this is only necessary for SImode and DImode.\n \n-     Use scratch_reg to hold the address of the memory location.\n-\n-     The proper fix is to change TARGET_PREFERRED_RELOAD_CLASS to return\n-     NO_REGS when presented with a const_int and a register class\n-     containing only FP registers.  Doing so unfortunately creates\n-     more problems than it solves.   Fix this for 2.5.  */\n+     Use scratch_reg to hold the address of the memory location.  */\n   else if (scratch_reg\n \t   && CONSTANT_P (operand1)\n \t   && fp_reg_operand (operand0, mode))\n     {\n       rtx const_mem, xoperands[2];\n \n+      if (operand1 == CONST0_RTX (mode))\n+\t{\n+\t  emit_insn (gen_rtx_SET (VOIDmode, operand0, operand1));\n+\t  return 1;\n+\t}\n+\n       /* SCRATCH_REG will hold an address and maybe the actual data.  We want\n \t it in WORD_MODE regardless of what mode it was originally given\n \t to us.  */\n@@ -5341,7 +5343,7 @@ pa_print_operand (FILE *file, rtx x, int code)\n \t\t   && GET_CODE (XEXP (XEXP (x, 0), 1)) == REG)\n \t    {\n \t      /* Because the REG_POINTER flag can get lost during reload,\n-\t\t GO_IF_LEGITIMATE_ADDRESS canonicalizes the order of the\n+\t\t pa_legitimate_address_p canonicalizes the order of the\n \t\t index and base registers in the combined move patterns.  */\n \t      rtx base = XEXP (XEXP (x, 0), 1);\n \t      rtx index = XEXP (XEXP (x, 0), 0);\n@@ -5892,9 +5894,9 @@ pa_output_arg_descriptor (rtx call_insn)\n   fputc ('\\n', asm_out_file);\n }\n \f\n-/* Inform reload about cases where moving X with a mode MODE to a register in\n-   RCLASS requires an extra scratch or immediate register.  Return the class\n-   needed for the immediate register.  */\n+/* Inform reload about cases where moving X with a mode MODE to or from\n+   a register in RCLASS requires an extra scratch or immediate register.\n+   Return the class needed for the immediate register.  */\n \n static reg_class_t\n pa_secondary_reload (bool in_p, rtx x, reg_class_t rclass_i,\n@@ -5923,19 +5925,39 @@ pa_secondary_reload (bool in_p, rtx x, reg_class_t rclass_i,\n     return NO_REGS;\n \n   /* Trying to load a constant into a FP register during PIC code\n-     generation requires %r1 as a scratch register.  */\n+     generation requires %r1 as a scratch register.  For float modes,\n+     the only legitimate constant is CONST0_RTX.  However, there are\n+     a few patterns that accept constant double operands.  */\n   if (flag_pic\n-      && (mode == SImode || mode == DImode)\n       && FP_REG_CLASS_P (rclass)\n       && (GET_CODE (x) == CONST_INT || GET_CODE (x) == CONST_DOUBLE))\n     {\n-      sri->icode = (mode == SImode ? CODE_FOR_reload_insi_r1\n-\t\t    : CODE_FOR_reload_indi_r1);\n+      switch (mode)\n+\t{\n+\tcase SImode:\n+\t  sri->icode = CODE_FOR_reload_insi_r1;\n+\t  break;\n+\n+\tcase DImode:\n+\t  sri->icode = CODE_FOR_reload_indi_r1;\n+\t  break;\n+\n+\tcase SFmode:\n+\t  sri->icode = CODE_FOR_reload_insf_r1;\n+\t  break;\n+\n+\tcase DFmode:\n+\t  sri->icode = CODE_FOR_reload_indf_r1;\n+\t  break;\n+\n+\tdefault:\n+\t  gcc_unreachable ();\n+\t}\n       return NO_REGS;\n     }\n \n-  /* Secondary reloads of symbolic operands require %r1 as a scratch\n-     register when we're generating PIC code and when the operand isn't\n+  /* Secondary reloads of symbolic expressions require %r1 as a scratch\n+     register when we're generating PIC code or when the operand isn't\n      readonly.  */\n   if (pa_symbolic_expression_p (x))\n     {\n@@ -5944,9 +5966,19 @@ pa_secondary_reload (bool in_p, rtx x, reg_class_t rclass_i,\n \n       if (flag_pic || !read_only_operand (x, VOIDmode))\n \t{\n-\t  gcc_assert (mode == SImode || mode == DImode);\n-\t  sri->icode = (mode == SImode ? CODE_FOR_reload_insi_r1\n-\t\t\t: CODE_FOR_reload_indi_r1);\n+\t  switch (mode)\n+\t    {\n+\t    case SImode:\n+\t      sri->icode = CODE_FOR_reload_insi_r1;\n+\t      break;\n+\n+\t    case DImode:\n+\t      sri->icode = CODE_FOR_reload_indi_r1;\n+\t      break;\n+\n+\t    default:\n+\t      gcc_unreachable ();\n+\t    }\n \t  return NO_REGS;\n \t}\n     }\n@@ -5956,22 +5988,11 @@ pa_secondary_reload (bool in_p, rtx x, reg_class_t rclass_i,\n   if (regno >= FIRST_PSEUDO_REGISTER || GET_CODE (x) == SUBREG)\n     regno = true_regnum (x);\n \n-  /* In order to allow 14-bit displacements in integer loads and stores,\n-     we need to prevent reload from generating out of range integer mode\n-     loads and stores to the floating point registers.  Previously, we\n-     used to call for a secondary reload and have pa_emit_move_sequence()\n-     fix the instruction sequence.  However, reload occasionally wouldn't\n-     generate the reload and we would end up with an invalid REG+D memory\n-     address.  So, now we use an intermediate general register for most\n-     memory loads and stores.  */\n+  /* Handle reloads for floating point loads and stores.  */\n   if ((regno >= FIRST_PSEUDO_REGISTER || regno == -1)\n-      && GET_MODE_CLASS (mode) == MODE_INT\n       && FP_REG_CLASS_P (rclass))\n     {\n-      /* Reload passes (mem:SI (reg/f:DI 30 %r30) when it wants to check\n-\t the secondary reload needed for a pseudo.  It never passes a\n-\t REG+D address.  */\n-      if (GET_CODE (x) == MEM)\n+      if (MEM_P (x))\n \t{\n \t  x = XEXP (x, 0);\n \n@@ -5985,7 +6006,7 @@ pa_secondary_reload (bool in_p, rtx x, reg_class_t rclass_i,\n \t      || IS_LO_SUM_DLT_ADDR_P (x))\n \t    return NO_REGS;\n \n-\t  /* Otherwise, we need an intermediate general register.  */\n+\t  /* Request intermediate general register.  */\n \t  return GENERAL_REGS;\n \t}\n \n@@ -10406,4 +10427,253 @@ pa_section_type_flags (tree decl, const char *name, int reloc)\n   return flags;\n }\n \n+/* pa_legitimate_address_p recognizes an RTL expression that is a\n+   valid memory address for an instruction.  The MODE argument is the\n+   machine mode for the MEM expression that wants to use this address.\n+\n+   On HP PA-RISC, the legitimate address forms are REG+SMALLINT,\n+   REG+REG, and REG+(REG*SCALE).  The indexed address forms are only\n+   available with floating point loads and stores, and integer loads.\n+   We get better code by allowing indexed addresses in the initial\n+   RTL generation.\n+\n+   The acceptance of indexed addresses as legitimate implies that we\n+   must provide patterns for doing indexed integer stores, or the move\n+   expanders must force the address of an indexed store to a register.\n+   We have adopted the latter approach.\n+   \n+   Another function of pa_legitimate_address_p is to ensure that\n+   the base register is a valid pointer for indexed instructions.\n+   On targets that have non-equivalent space registers, we have to\n+   know at the time of assembler output which register in a REG+REG\n+   pair is the base register.  The REG_POINTER flag is sometimes lost\n+   in reload and the following passes, so it can't be relied on during\n+   code generation.  Thus, we either have to canonicalize the order\n+   of the registers in REG+REG indexed addresses, or treat REG+REG\n+   addresses separately and provide patterns for both permutations.\n+\n+   The latter approach requires several hundred additional lines of\n+   code in pa.md.  The downside to canonicalizing is that a PLUS\n+   in the wrong order can't combine to form to make a scaled indexed\n+   memory operand.  As we won't need to canonicalize the operands if\n+   the REG_POINTER lossage can be fixed, it seems better canonicalize.\n+\n+   We initially break out scaled indexed addresses in canonical order\n+   in pa_emit_move_sequence.  LEGITIMIZE_ADDRESS also canonicalizes\n+   scaled indexed addresses during RTL generation.  However, fold_rtx\n+   has its own opinion on how the operands of a PLUS should be ordered.\n+   If one of the operands is equivalent to a constant, it will make\n+   that operand the second operand.  As the base register is likely to\n+   be equivalent to a SYMBOL_REF, we have made it the second operand.\n+\n+   pa_legitimate_address_p accepts REG+REG as legitimate when the\n+   operands are in the order INDEX+BASE on targets with non-equivalent\n+   space registers, and in any order on targets with equivalent space\n+   registers.  It accepts both MULT+BASE and BASE+MULT for scaled indexing.\n+\n+   We treat a SYMBOL_REF as legitimate if it is part of the current\n+   function's constant-pool, because such addresses can actually be\n+   output as REG+SMALLINT.  */\n+\n+static bool\n+pa_legitimate_address_p (enum machine_mode mode, rtx x, bool strict)\n+{\n+  if ((REG_P (x)\n+       && (strict ? STRICT_REG_OK_FOR_BASE_P (x)\n+\t\t  : REG_OK_FOR_BASE_P (x)))\n+      || ((GET_CODE (x) == PRE_DEC || GET_CODE (x) == POST_DEC\n+\t   || GET_CODE (x) == PRE_INC || GET_CODE (x) == POST_INC)\n+\t  && REG_P (XEXP (x, 0))\n+\t  && (strict ? STRICT_REG_OK_FOR_BASE_P (XEXP (x, 0))\n+\t\t     : REG_OK_FOR_BASE_P (XEXP (x, 0)))))\n+    return true;\n+\n+  if (GET_CODE (x) == PLUS)\n+    {\n+      rtx base, index;\n+\n+      /* For REG+REG, the base register should be in XEXP (x, 1),\n+\t so check it first.  */\n+      if (REG_P (XEXP (x, 1))\n+\t  && (strict ? STRICT_REG_OK_FOR_BASE_P (XEXP (x, 1))\n+\t\t     : REG_OK_FOR_BASE_P (XEXP (x, 1))))\n+\tbase = XEXP (x, 1), index = XEXP (x, 0);\n+      else if (REG_P (XEXP (x, 0))\n+\t       && (strict ? STRICT_REG_OK_FOR_BASE_P (XEXP (x, 0))\n+\t\t\t  : REG_OK_FOR_BASE_P (XEXP (x, 0))))\n+\tbase = XEXP (x, 0), index = XEXP (x, 1);\n+      else\n+\treturn false;\n+\n+      if (GET_CODE (index) == CONST_INT)\n+\t{\n+\t  if (INT_5_BITS (index))\n+\t    return true;\n+\n+\t  /* When INT14_OK_STRICT is false, a secondary reload is needed\n+\t     to adjust the displacement of SImode and DImode floating point\n+\t     instructions.  So, we return false when STRICT is true.  We\n+\t     also reject long displacements for float mode addresses since\n+\t     the majority of accesses will use floating point instructions\n+\t     that don't support 14-bit offsets.  */\n+\t  if (!INT14_OK_STRICT\n+\t      && (GET_MODE_CLASS (mode) == MODE_FLOAT\n+\t\t  || (reload_in_progress\n+\t\t      && strict\n+\t\t      && (mode == SImode || mode == DImode))))\n+\t   return false;\n+\n+\t  if (INT_14_BITS (index)\n+\t      && (mode == BLKmode\n+\t\t  || mode == QImode\n+\t\t  || mode == HImode\n+\t\t  /* Displacement must be a multiple of its size.  */\n+\t\t  || (INTVAL (index) % GET_MODE_SIZE (mode)) == 0))\n+\t    return true;\n+\n+\t  return false;\n+\t}\n+\n+      if (!TARGET_DISABLE_INDEXING\n+\t  /* Only accept the \"canonical\" INDEX+BASE operand order\n+\t     on targets with non-equivalent space registers.  */\n+\t  && (TARGET_NO_SPACE_REGS\n+\t      ? REG_P (index)\n+\t      : (base == XEXP (x, 1) && REG_P (index)\n+\t\t && (reload_completed\n+\t\t     || (reload_in_progress && HARD_REGISTER_P (base))\n+\t\t     || REG_POINTER (base))\n+\t\t && (reload_completed\n+\t\t     || (reload_in_progress && HARD_REGISTER_P (index))\n+\t\t     || !REG_POINTER (index))))\n+\t  && MODE_OK_FOR_UNSCALED_INDEXING_P (mode)\n+\t  && (strict ? STRICT_REG_OK_FOR_INDEX_P (index)\n+\t\t     : REG_OK_FOR_INDEX_P (index))\n+\t  && borx_reg_operand (base, Pmode)\n+\t  && borx_reg_operand (index, Pmode))\n+\treturn true;\n+\n+      if (!TARGET_DISABLE_INDEXING\n+\t  && GET_CODE (index) == MULT\n+\t  && MODE_OK_FOR_SCALED_INDEXING_P (mode)\n+\t  && REG_P (XEXP (index, 0))\n+\t  && GET_MODE (XEXP (index, 0)) == Pmode\n+\t  && (strict ? STRICT_REG_OK_FOR_INDEX_P (XEXP (index, 0))\n+\t\t     : REG_OK_FOR_INDEX_P (XEXP (index, 0)))\n+\t  && GET_CODE (XEXP (index, 1)) == CONST_INT\n+\t  && INTVAL (XEXP (index, 1))\n+\t     == (HOST_WIDE_INT) GET_MODE_SIZE (mode)\n+\t  && borx_reg_operand (base, Pmode))\n+\treturn true;\n+\n+      return false;\n+    }\n+\n+  if (GET_CODE (x) == LO_SUM)\n+    {\n+      rtx y = XEXP (x, 0);\n+\n+      if (GET_CODE (y) == SUBREG)\n+\ty = SUBREG_REG (y);\n+\n+      if (REG_P (y)\n+\t  && (strict ? STRICT_REG_OK_FOR_BASE_P (y)\n+\t\t     : REG_OK_FOR_BASE_P (y)))\n+\t{\n+\t  /* Needed for -fPIC */\n+\t  if (mode == Pmode\n+\t      && GET_CODE (XEXP (x, 1)) == UNSPEC)\n+\t    return true;\n+\n+\t  if (!INT14_OK_STRICT\n+\t      && (GET_MODE_CLASS (mode) == MODE_FLOAT\n+\t\t  || (reload_in_progress\n+\t\t      && strict\n+\t\t      && (mode == SImode || mode == DImode))))\n+\t   return false;\n+\n+\t  if (CONSTANT_P (XEXP (x, 1)))\n+\t    return true;\n+\t}\n+      return false;\n+    }\n+\n+  if (GET_CODE (x) == CONST_INT && INT_5_BITS (x))\n+    return true;\n+\n+  return false;\n+}\n+\n+/* Look for machine dependent ways to make the invalid address AD a\n+   valid address.\n+\n+   For the PA, transform:\n+\n+        memory(X + <large int>)\n+\n+   into:\n+\n+        if (<large int> & mask) >= 16\n+          Y = (<large int> & ~mask) + mask + 1  Round up.\n+        else\n+          Y = (<large int> & ~mask)             Round down.\n+        Z = X + Y\n+        memory (Z + (<large int> - Y));\n+\n+   This makes reload inheritance and reload_cse work better since Z\n+   can be reused.\n+\n+   There may be more opportunities to improve code with this hook.  */\n+\n+rtx\n+pa_legitimize_reload_address (rtx ad, enum machine_mode mode,\n+\t\t\t      int opnum, int type,\n+\t\t\t      int ind_levels ATTRIBUTE_UNUSED)\n+{\n+  long offset, newoffset, mask;\n+  rtx new_rtx, temp = NULL_RTX;\n+\n+  mask = (GET_MODE_CLASS (mode) == MODE_FLOAT\n+\t  && !INT14_OK_STRICT ? 0x1f : 0x3fff);\n+\n+  if (optimize && GET_CODE (ad) == PLUS)\n+    temp = simplify_binary_operation (PLUS, Pmode,\n+\t\t\t\t      XEXP (ad, 0), XEXP (ad, 1));\n+\n+  new_rtx = temp ? temp : ad;\n+\n+  if (optimize\n+      && GET_CODE (new_rtx) == PLUS\n+      && GET_CODE (XEXP (new_rtx, 0)) == REG\n+      && GET_CODE (XEXP (new_rtx, 1)) == CONST_INT)\n+    {\n+      offset = INTVAL (XEXP ((new_rtx), 1));\n+\n+      /* Choose rounding direction.  Round up if we are >= halfway.  */\n+      if ((offset & mask) >= ((mask + 1) / 2))\n+\tnewoffset = (offset & ~mask) + mask + 1;\n+      else\n+\tnewoffset = offset & ~mask;\n+\n+      /* Ensure that long displacements are aligned.  */\n+      if (mask == 0x3fff\n+\t  && (GET_MODE_CLASS (mode) == MODE_FLOAT\n+\t      || (TARGET_64BIT && (mode) == DImode)))\n+\tnewoffset &= ~(GET_MODE_SIZE (mode) - 1);\n+\n+      if (newoffset != 0 && VAL_14_BITS_P (newoffset))\n+\t{\n+\t  temp = gen_rtx_PLUS (Pmode, XEXP (new_rtx, 0),\n+\t\t\t       GEN_INT (newoffset));\n+\t  ad = gen_rtx_PLUS (Pmode, temp, GEN_INT (offset - newoffset));\n+\t  push_reload (XEXP (ad, 0), 0, &XEXP (ad, 0), 0,\n+\t\t       BASE_REG_CLASS, Pmode, VOIDmode, 0, 0,\n+\t\t       opnum, (enum reload_type) type);\n+\t  return ad;\n+\t}\n+    }\n+\n+  return NULL_RTX;\n+}\n+\n #include \"gt-pa.h\""}, {"sha": "620768fb04d5b37eba209e43b601f0c4881354f8", "filename": "gcc/config/pa/pa.h", "status": "modified", "additions": 17, "deletions": 232, "changes": 249, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a04ac2bc8e3e3dc3fa09364c60d5e165a0c858b/gcc%2Fconfig%2Fpa%2Fpa.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a04ac2bc8e3e3dc3fa09364c60d5e165a0c858b/gcc%2Fconfig%2Fpa%2Fpa.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpa%2Fpa.h?ref=1a04ac2bc8e3e3dc3fa09364c60d5e165a0c858b", "patch": "@@ -846,9 +846,9 @@ extern int may_call_alloca;\n /* Nonzero if 14-bit offsets can be used for all loads and stores.\n    This is not possible when generating PA 1.x code as floating point\n    loads and stores only support 5-bit offsets.  Note that we do not\n-   forbid the use of 14-bit offsets in GO_IF_LEGITIMATE_ADDRESS.\n-   Instead, we use pa_secondary_reload() to reload integer mode\n-   REG+D memory addresses used in floating point loads and stores.\n+   forbid the use of 14-bit offsets for integer modes.  Instead, we\n+   use secondary reloads to fix REG+D memory addresses for integer\n+   mode floating-point loads and stores.\n \n    FIXME: the ELF32 linker clobbers the LSB of the FP register number\n    in PA 2.0 floating-point insns with long displacements.  This is\n@@ -866,16 +866,13 @@ extern int may_call_alloca;\n    We have two alternate definitions for each of them.\n    The usual definition accepts all pseudo regs; the other rejects\n    them unless they have been allocated suitable hard regs.\n-   The symbol REG_OK_STRICT causes the latter definition to be used.\n \n    Most source files want to accept pseudo regs in the hope that\n    they will get allocated to the class that the insn wants them to be in.\n    Source files for reload pass need to be strict.\n    After reload, it makes no difference, since pseudo regs have\n    been eliminated by then.  */\n \n-#ifndef REG_OK_STRICT\n-\n /* Nonzero if X is a hard reg that can be used as an index\n    or if it is a pseudo reg.  */\n #define REG_OK_FOR_INDEX_P(X) \\\n@@ -890,63 +887,11 @@ extern int may_call_alloca;\n    || REGNO (X) == FRAME_POINTER_REGNUM\t\t\t\t\\\n    || REGNO (X) >= FIRST_PSEUDO_REGISTER))\n \n-#else\n-\n /* Nonzero if X is a hard reg that can be used as an index.  */\n-#define REG_OK_FOR_INDEX_P(X) REGNO_OK_FOR_INDEX_P (REGNO (X))\n+#define STRICT_REG_OK_FOR_INDEX_P(X) REGNO_OK_FOR_INDEX_P (REGNO (X))\n \n /* Nonzero if X is a hard reg that can be used as a base reg.  */\n-#define REG_OK_FOR_BASE_P(X) REGNO_OK_FOR_BASE_P (REGNO (X))\n-\n-#endif\n-\f\n-/* GO_IF_LEGITIMATE_ADDRESS recognizes an RTL expression that is a\n-   valid memory address for an instruction.  The MODE argument is the\n-   machine mode for the MEM expression that wants to use this address.\n-\n-   On HP PA-RISC, the legitimate address forms are REG+SMALLINT,\n-   REG+REG, and REG+(REG*SCALE).  The indexed address forms are only\n-   available with floating point loads and stores, and integer loads.\n-   We get better code by allowing indexed addresses in the initial\n-   RTL generation.\n-\n-   The acceptance of indexed addresses as legitimate implies that we\n-   must provide patterns for doing indexed integer stores, or the move\n-   expanders must force the address of an indexed store to a register.\n-   We have adopted the latter approach.\n-   \n-   Another function of GO_IF_LEGITIMATE_ADDRESS is to ensure that\n-   the base register is a valid pointer for indexed instructions.\n-   On targets that have non-equivalent space registers, we have to\n-   know at the time of assembler output which register in a REG+REG\n-   pair is the base register.  The REG_POINTER flag is sometimes lost\n-   in reload and the following passes, so it can't be relied on during\n-   code generation.  Thus, we either have to canonicalize the order\n-   of the registers in REG+REG indexed addresses, or treat REG+REG\n-   addresses separately and provide patterns for both permutations.\n-\n-   The latter approach requires several hundred additional lines of\n-   code in pa.md.  The downside to canonicalizing is that a PLUS\n-   in the wrong order can't combine to form to make a scaled indexed\n-   memory operand.  As we won't need to canonicalize the operands if\n-   the REG_POINTER lossage can be fixed, it seems better canonicalize.\n-\n-   We initially break out scaled indexed addresses in canonical order\n-   in pa_emit_move_sequence.  LEGITIMIZE_ADDRESS also canonicalizes\n-   scaled indexed addresses during RTL generation.  However, fold_rtx\n-   has its own opinion on how the operands of a PLUS should be ordered.\n-   If one of the operands is equivalent to a constant, it will make\n-   that operand the second operand.  As the base register is likely to\n-   be equivalent to a SYMBOL_REF, we have made it the second operand.\n-\n-   GO_IF_LEGITIMATE_ADDRESS accepts REG+REG as legitimate when the\n-   operands are in the order INDEX+BASE on targets with non-equivalent\n-   space registers, and in any order on targets with equivalent space\n-   registers.  It accepts both MULT+BASE and BASE+MULT for scaled indexing.\n-\n-   We treat a SYMBOL_REF as legitimate if it is part of the current\n-   function's constant-pool, because such addresses can actually be\n-   output as REG+SMALLINT.  */\n+#define STRICT_REG_OK_FOR_BASE_P(X) REGNO_OK_FOR_BASE_P (REGNO (X))\n \n #define VAL_5_BITS_P(X) ((unsigned HOST_WIDE_INT)(X) + 0x10 < 0x20)\n #define INT_5_BITS(X) VAL_5_BITS_P (INTVAL (X))\n@@ -989,180 +934,20 @@ extern int may_call_alloca;\n    || (MODE) == SFmode\t\t\t\t\t\t\t\\\n    || (MODE) == DFmode)\n \n-#define GO_IF_LEGITIMATE_ADDRESS(MODE, X, ADDR) \\\n-{\t\t\t\t\t\t\t\t\t\\\n-  if ((REG_P (X) && REG_OK_FOR_BASE_P (X))\t\t\t\t\\\n-      || ((GET_CODE (X) == PRE_DEC || GET_CODE (X) == POST_DEC\t\t\\\n-\t   || GET_CODE (X) == PRE_INC || GET_CODE (X) == POST_INC)\t\\\n-\t  && REG_P (XEXP (X, 0))\t\t\t\t\t\\\n-\t  && REG_OK_FOR_BASE_P (XEXP (X, 0))))\t\t\t\t\\\n-    goto ADDR;\t\t\t\t\t\t\t\t\\\n-  else if (GET_CODE (X) == PLUS)\t\t\t\t\t\\\n-    {\t\t\t\t\t\t\t\t\t\\\n-      rtx base = 0, index = 0;\t\t\t\t\t\t\\\n-      if (REG_P (XEXP (X, 1))\t\t\t\t\t\t\\\n-\t  && REG_OK_FOR_BASE_P (XEXP (X, 1)))\t\t\t\t\\\n-\tbase = XEXP (X, 1), index = XEXP (X, 0);\t\t\t\\\n-      else if (REG_P (XEXP (X, 0))\t\t\t\t\t\\\n-\t       && REG_OK_FOR_BASE_P (XEXP (X, 0)))\t\t\t\\\n-\tbase = XEXP (X, 0), index = XEXP (X, 1);\t\t\t\\\n-      if (base\t\t\t\t\t\t\t\t\\\n-\t  && GET_CODE (index) == CONST_INT\t\t\t\t\\\n-\t  && ((INT_14_BITS (index)\t\t\t\t\t\\\n-\t       && (((MODE) != DImode\t\t\t\t\t\\\n-\t\t    && (MODE) != SFmode\t\t\t\t\t\\\n-\t\t    && (MODE) != DFmode)\t\t\t\t\\\n-\t\t   /* The base register for DImode loads and stores\t\\\n-\t\t      with long displacements must be aligned because\t\\\n-\t\t      the lower three bits in the displacement are\t\\\n-\t\t      assumed to be zero.  */\t\t\t\t\\\n-\t\t   || ((MODE) == DImode\t\t\t\t\t\\\n-\t\t       && (!TARGET_64BIT\t\t\t\t\\\n-\t\t\t   || (INTVAL (index) % 8) == 0))\t\t\\\n-\t\t   /* Similarly, the base register for SFmode/DFmode\t\\\n-\t\t      loads and stores with long displacements must\t\\\n-\t\t      be aligned.  */\t\t\t\t\t\\\n-\t\t   || (((MODE) == SFmode || (MODE) == DFmode)\t\t\\\n-\t\t       && INT14_OK_STRICT\t\t\t\t\\\n-\t\t       && (INTVAL (index) % GET_MODE_SIZE (MODE)) == 0))) \\\n-\t       || INT_5_BITS (index)))\t\t\t\t\t\\\n-\tgoto ADDR;\t\t\t\t\t\t\t\\\n-      if (!TARGET_DISABLE_INDEXING\t\t\t\t\t\\\n-\t  /* Only accept the \"canonical\" INDEX+BASE operand order\t\\\n-\t     on targets with non-equivalent space registers.  */\t\\\n-\t  && (TARGET_NO_SPACE_REGS\t\t\t\t\t\\\n-\t      ? (base && REG_P (index))\t\t\t\t\t\\\n-\t      : (base == XEXP (X, 1) && REG_P (index)\t\t\t\\\n-\t\t && (reload_completed\t\t\t\t\t\\\n-\t\t     || (reload_in_progress && HARD_REGISTER_P (base))\t\\\n-\t\t     || REG_POINTER (base))\t\t\t\t\\\n-\t\t && (reload_completed\t\t\t\t\t\\\n-\t\t     || (reload_in_progress && HARD_REGISTER_P (index))\t\\\n-\t\t     || !REG_POINTER (index))))\t\t\t\t\\\n-\t  && MODE_OK_FOR_UNSCALED_INDEXING_P (MODE)\t\t\t\\\n-\t  && REG_OK_FOR_INDEX_P (index)\t\t\t\t\t\\\n-\t  && borx_reg_operand (base, Pmode)\t\t\t\t\\\n-\t  && borx_reg_operand (index, Pmode))\t\t\t\t\\\n-\tgoto ADDR;\t\t\t\t\t\t\t\\\n-      if (!TARGET_DISABLE_INDEXING\t\t\t\t\t\\\n-\t  && base\t\t\t\t\t\t\t\\\n-\t  && GET_CODE (index) == MULT\t\t\t\t\t\\\n-\t  && MODE_OK_FOR_SCALED_INDEXING_P (MODE)\t\t\t\\\n-\t  && REG_P (XEXP (index, 0))\t\t\t\t\t\\\n-\t  && GET_MODE (XEXP (index, 0)) == Pmode\t\t\t\\\n-\t  && REG_OK_FOR_INDEX_P (XEXP (index, 0))\t\t\t\\\n-\t  && GET_CODE (XEXP (index, 1)) == CONST_INT\t\t\t\\\n-\t  && INTVAL (XEXP (index, 1))\t\t\t\t\t\\\n-\t     == (HOST_WIDE_INT) GET_MODE_SIZE (MODE)\t\t\t\\\n-\t  && borx_reg_operand (base, Pmode))\t\t\t\t\\\n-\tgoto ADDR;\t\t\t\t\t\t\t\\\n-    }\t\t\t\t\t\t\t\t\t\\\n-  else if (GET_CODE (X) == LO_SUM\t\t\t\t\t\\\n-\t   && GET_CODE (XEXP (X, 0)) == REG\t\t\t\t\\\n-\t   && REG_OK_FOR_BASE_P (XEXP (X, 0))\t\t\t\t\\\n-\t   && CONSTANT_P (XEXP (X, 1))\t\t\t\t\t\\\n-\t   && (TARGET_SOFT_FLOAT\t\t\t\t\t\\\n-\t       /* We can allow symbolic LO_SUM addresses for PA2.0.  */\t\\\n-\t       || (TARGET_PA_20\t\t\t\t\t\t\\\n-\t\t   && !TARGET_ELF32\t\t\t\t\t\\\n-\t           && GET_CODE (XEXP (X, 1)) != CONST_INT)\t\t\\\n-\t       || ((MODE) != SFmode\t\t\t\t\t\\\n-\t\t   && (MODE) != DFmode)))\t\t\t\t\\\n-    goto ADDR;\t\t\t\t\t\t\t\t\\\n-  else if (GET_CODE (X) == LO_SUM\t\t\t\t\t\\\n-\t   && GET_CODE (XEXP (X, 0)) == SUBREG\t\t\t\t\\\n-\t   && GET_CODE (SUBREG_REG (XEXP (X, 0))) == REG\t\t\\\n-\t   && REG_OK_FOR_BASE_P (SUBREG_REG (XEXP (X, 0)))\t\t\\\n-\t   && CONSTANT_P (XEXP (X, 1))\t\t\t\t\t\\\n-\t   && (TARGET_SOFT_FLOAT\t\t\t\t\t\\\n-\t       /* We can allow symbolic LO_SUM addresses for PA2.0.  */\t\\\n-\t       || (TARGET_PA_20\t\t\t\t\t\t\\\n-\t\t   && !TARGET_ELF32\t\t\t\t\t\\\n-\t           && GET_CODE (XEXP (X, 1)) != CONST_INT)\t\t\\\n-\t       || ((MODE) != SFmode\t\t\t\t\t\\\n-\t\t   && (MODE) != DFmode)))\t\t\t\t\\\n-    goto ADDR;\t\t\t\t\t\t\t\t\\\n-  else if (GET_CODE (X) == CONST_INT && INT_5_BITS (X))\t\t\t\\\n-    goto ADDR;\t\t\t\t\t\t\t\t\\\n-  /* Needed for -fPIC */\t\t\t\t\t\t\\\n-  else if (GET_CODE (X) == LO_SUM\t\t\t\t\t\\\n-\t   && GET_CODE (XEXP (X, 0)) == REG             \t\t\\\n-\t   && REG_OK_FOR_BASE_P (XEXP (X, 0))\t\t\t\t\\\n-\t   && GET_CODE (XEXP (X, 1)) == UNSPEC\t\t\t\t\\\n-\t   && (TARGET_SOFT_FLOAT\t\t\t\t\t\\\n-\t       || (TARGET_PA_20\t&& !TARGET_ELF32)\t\t\t\\\n-\t       || ((MODE) != SFmode\t\t\t\t\t\\\n-\t\t   && (MODE) != DFmode)))\t\t\t\t\\\n-    goto ADDR;\t\t\t\t\t\t\t\t\\\n-}\n-\n-/* Look for machine dependent ways to make the invalid address AD a\n-   valid address.\n-\n-   For the PA, transform:\n-\n-        memory(X + <large int>)\n-\n-   into:\n-\n-        if (<large int> & mask) >= 16\n-          Y = (<large int> & ~mask) + mask + 1  Round up.\n-        else\n-          Y = (<large int> & ~mask)             Round down.\n-        Z = X + Y\n-        memory (Z + (<large int> - Y));\n-\n-   This makes reload inheritance and reload_cse work better since Z\n-   can be reused.\n-\n-   There may be more opportunities to improve code with this hook.  */\n-#define LEGITIMIZE_RELOAD_ADDRESS(AD, MODE, OPNUM, TYPE, IND, WIN) \t\\\n-do { \t\t\t\t\t\t\t\t\t\\\n-  long offset, newoffset, mask;\t\t\t\t\t\t\\\n-  rtx new_rtx, temp = NULL_RTX;\t\t\t\t\t\t\\\n-\t\t\t\t\t\t\t\t\t\\\n-  mask = (GET_MODE_CLASS (MODE) == MODE_FLOAT\t\t\t\t\\\n-\t  ? (INT14_OK_STRICT ? 0x3fff : 0x1f) : 0x3fff);\t\t\\\n-\t\t\t\t\t\t\t\t\t\\\n-  if (optimize && GET_CODE (AD) == PLUS)\t\t\t\t\\\n-    temp = simplify_binary_operation (PLUS, Pmode,\t\t\t\\\n-\t\t\t\t      XEXP (AD, 0), XEXP (AD, 1));\t\\\n-\t\t\t\t\t\t\t\t\t\\\n-  new_rtx = temp ? temp : AD;\t\t\t\t\t\t\\\n-\t\t\t\t\t\t\t\t\t\\\n-  if (optimize\t\t\t\t\t\t\t\t\\\n-      && GET_CODE (new_rtx) == PLUS\t\t\t\t\t\t\\\n-      && GET_CODE (XEXP (new_rtx, 0)) == REG\t\t\t\t\\\n-      && GET_CODE (XEXP (new_rtx, 1)) == CONST_INT)\t\t\t\t\\\n-    {\t\t\t\t\t\t\t\t\t\\\n-      offset = INTVAL (XEXP ((new_rtx), 1));\t\t\t\t\\\n-\t\t\t\t\t\t\t\t\t\\\n-      /* Choose rounding direction.  Round up if we are >= halfway.  */\t\\\n-      if ((offset & mask) >= ((mask + 1) / 2))\t\t\t\t\\\n-\tnewoffset = (offset & ~mask) + mask + 1;\t\t\t\\\n-      else\t\t\t\t\t\t\t\t\\\n-\tnewoffset = offset & ~mask;\t\t\t\t\t\\\n-\t\t\t\t\t\t\t\t\t\\\n-      /* Ensure that long displacements are aligned.  */\t\t\\\n-      if (mask == 0x3fff\t\t\t\t\t\t\\\n-\t  && (GET_MODE_CLASS (MODE) == MODE_FLOAT\t\t\t\\\n-\t      || (TARGET_64BIT && (MODE) == DImode)))\t\t\t\\\n-\tnewoffset &= ~(GET_MODE_SIZE (MODE) - 1);\t\t\t\\\n-\t\t\t\t\t\t\t\t\t\\\n-      if (newoffset != 0 && VAL_14_BITS_P (newoffset))\t\t\t\\\n-\t{\t\t\t\t\t\t\t\t\\\n-\t  temp = gen_rtx_PLUS (Pmode, XEXP (new_rtx, 0),\t\t\t\\\n-\t\t\t       GEN_INT (newoffset));\t\t\t\\\n-\t  AD = gen_rtx_PLUS (Pmode, temp, GEN_INT (offset - newoffset));\\\n-\t  push_reload (XEXP (AD, 0), 0, &XEXP (AD, 0), 0,\t\t\\\n-\t\t       BASE_REG_CLASS, Pmode, VOIDmode, 0, 0,\t\t\\\n-\t\t       (OPNUM), (TYPE));\t\t\t\t\\\n-\t  goto WIN;\t\t\t\t\t\t\t\\\n-\t}\t\t\t\t\t\t\t\t\\\n-    }\t\t\t\t\t\t\t\t\t\\\n+/* Try a machine-dependent way of reloading an illegitimate address\n+   operand.  If we find one, push the reload and jump to WIN.  This\n+   macro is used in only one place: `find_reloads_address' in reload.c.  */\n+\n+#define LEGITIMIZE_RELOAD_ADDRESS(AD, MODE, OPNUM, TYPE, IND_L, WIN) \t     \\\n+do {\t\t\t\t\t\t\t\t\t     \\\n+  rtx new_ad = pa_legitimize_reload_address (AD, MODE, OPNUM, TYPE, IND_L);  \\\n+  if (new_ad)\t\t\t\t\t\t\t\t     \\\n+    {\t\t\t\t\t\t\t\t\t     \\\n+      AD = new_ad;\t\t\t\t\t\t\t     \\\n+      goto WIN;\t\t\t\t\t\t\t\t     \\\n+    }\t\t\t\t\t\t\t\t\t     \\\n } while (0)\n \n-\n \f\n #define TARGET_ASM_SELECT_SECTION  pa_select_section\n "}, {"sha": "d5696e908e080e0a876519e36a2c6a6dd416459b", "filename": "gcc/config/pa/pa.md", "status": "modified", "additions": 42, "deletions": 86, "changes": 128, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a04ac2bc8e3e3dc3fa09364c60d5e165a0c858b/gcc%2Fconfig%2Fpa%2Fpa.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a04ac2bc8e3e3dc3fa09364c60d5e165a0c858b/gcc%2Fconfig%2Fpa%2Fpa.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpa%2Fpa.md?ref=1a04ac2bc8e3e3dc3fa09364c60d5e165a0c858b", "patch": "@@ -3772,52 +3772,32 @@\n \f\n ;; Floating point move insns\n \n-;; This pattern forces (set (reg:DF ...) (const_double ...))\n-;; to be reloaded by putting the constant into memory when\n-;; reg is a floating point register.\n-;;\n-;; For integer registers we use ldil;ldo to set the appropriate\n-;; value.\n-;;\n-;; This must come before the movdf pattern, and it must be present\n-;; to handle obscure reloading cases.\n-(define_insn \"\"\n-  [(set (match_operand:DF 0 \"register_operand\" \"=?r,f\")\n-\t(match_operand:DF 1 \"\" \"?F,m\"))]\n-  \"GET_CODE (operands[1]) == CONST_DOUBLE\n-   && operands[1] != CONST0_RTX (DFmode)\n-   && !TARGET_64BIT\n-   && !TARGET_SOFT_FLOAT\"\n-  \"* return (which_alternative == 0 ? pa_output_move_double (operands)\n-\t\t\t\t    : \\\"fldd%F1 %1,%0\\\");\"\n-  [(set_attr \"type\" \"move,fpload\")\n-   (set_attr \"length\" \"16,4\")])\n-\n (define_expand \"movdf\"\n   [(set (match_operand:DF 0 \"general_operand\" \"\")\n \t(match_operand:DF 1 \"general_operand\" \"\"))]\n   \"\"\n   \"\n {\n-  if (GET_CODE (operands[1]) == CONST_DOUBLE\n-      && operands[1] != CONST0_RTX (DFmode))\n-    {\n-      /* Reject CONST_DOUBLE loads to all hard registers when\n-\t generating 64-bit code and to floating point registers\n-\t when generating 32-bit code.  */\n-      if (REG_P (operands[0])\n-\t  && HARD_REGISTER_P (operands[0])\n-\t  && (TARGET_64BIT || REGNO (operands[0]) >= 32))\n-\tFAIL;\n-\n-      if (TARGET_64BIT)\n-\toperands[1] = force_const_mem (DFmode, operands[1]);\n-    }\n-\n   if (pa_emit_move_sequence (operands, DFmode, 0))\n     DONE;\n }\")\n \n+;; Handle DFmode input reloads requiring %r1 as a scratch register.\n+(define_expand \"reload_indf_r1\"\n+  [(set (match_operand:DF 0 \"register_operand\" \"=Z\")\n+\t(match_operand:DF 1 \"non_hard_reg_operand\" \"\"))\n+   (clobber (match_operand:SI 2 \"register_operand\" \"=&a\"))]\n+  \"\"\n+  \"\n+{\n+  if (pa_emit_move_sequence (operands, DFmode, operands[2]))\n+    DONE;\n+\n+  /* We don't want the clobber emitted, so handle this ourselves.  */\n+  emit_insn (gen_rtx_SET (VOIDmode, operands[0], operands[1]));\n+  DONE;\n+}\")\n+\n ;; Handle DFmode input reloads requiring a general register as a\n ;; scratch register.\n (define_expand \"reload_indf\"\n@@ -3854,9 +3834,9 @@\n \n (define_insn \"\"\n   [(set (match_operand:DF 0 \"move_dest_operand\"\n-\t\t\t  \"=f,*r,Q,?o,?Q,f,*r,*r,?*r,?f\")\n+\t\t\t  \"=f,*r,T,?o,?Q,f,*r,*r,?*r,?f\")\n \t(match_operand:DF 1 \"reg_or_0_or_nonsymb_mem_operand\"\n-\t\t\t  \"fG,*rG,f,*r,*r,RQ,o,RQ,f,*r\"))]\n+\t\t\t  \"fG,*rG,f,*r,*r,RT,o,RQ,f,*r\"))]\n   \"(register_operand (operands[0], DFmode)\n     || reg_or_0_operand (operands[1], DFmode))\n    && !(GET_CODE (operands[1]) == CONST_DOUBLE\n@@ -4071,18 +4051,6 @@\n   \"\"\n   \"\n {\n-  /* Except for zero, we don't support loading a CONST_INT directly\n-     to a hard floating-point register since a scratch register is\n-     needed for the operation.  While the operation could be handled\n-     before register allocation, the simplest solution is to fail.  */\n-  if (TARGET_64BIT\n-      && GET_CODE (operands[1]) == CONST_INT\n-      && operands[1] != CONST0_RTX (DImode)\n-      && REG_P (operands[0])\n-      && HARD_REGISTER_P (operands[0])\n-      && REGNO (operands[0]) >= 32)\n-    FAIL;\n-\n   if (pa_emit_move_sequence (operands, DImode, 0))\n     DONE;\n }\")\n@@ -4190,7 +4158,7 @@\n (define_insn \"\"\n   [(set (match_operand:DI 0 \"move_dest_operand\"\n \t\t\t  \"=r,o,Q,r,r,r,*f,*f,T,?r,?*f\")\n-\t(match_operand:DI 1 \"general_operand\"\n+\t(match_operand:DI 1 \"move_src_operand\"\n \t\t\t  \"rM,r,r,o*R,Q,i,*fM,RT,*f,*f,r\"))]\n   \"(register_operand (operands[0], DImode)\n     || reg_or_0_operand (operands[1], DImode))\n@@ -4355,44 +4323,32 @@\n   [(set_attr \"type\" \"move,move\")\n    (set_attr \"length\" \"4,8\")])\n \n-;; This pattern forces (set (reg:SF ...) (const_double ...))\n-;; to be reloaded by putting the constant into memory when\n-;; reg is a floating point register.\n-;;\n-;; For integer registers we use ldil;ldo to set the appropriate\n-;; value.\n-;;\n-;; This must come before the movsf pattern, and it must be present\n-;; to handle obscure reloading cases.\n-(define_insn \"\"\n-  [(set (match_operand:SF 0 \"register_operand\" \"=?r,f\")\n-\t(match_operand:SF 1 \"\" \"?F,m\"))]\n-  \"GET_CODE (operands[1]) == CONST_DOUBLE\n-   && operands[1] != CONST0_RTX (SFmode)\n-   && ! TARGET_SOFT_FLOAT\"\n-  \"* return (which_alternative == 0 ? pa_singlemove_string (operands)\n-\t\t\t\t    : \\\" fldw%F1 %1,%0\\\");\"\n-  [(set_attr \"type\" \"move,fpload\")\n-   (set_attr \"length\" \"8,4\")])\n-\n (define_expand \"movsf\"\n   [(set (match_operand:SF 0 \"general_operand\" \"\")\n \t(match_operand:SF 1 \"general_operand\" \"\"))]\n   \"\"\n   \"\n {\n-  /* Reject CONST_DOUBLE loads to floating point registers.  */\n-  if (GET_CODE (operands[1]) == CONST_DOUBLE\n-      && operands[1] != CONST0_RTX (SFmode)\n-      && REG_P (operands[0])\n-      && HARD_REGISTER_P (operands[0])\n-      && REGNO (operands[0]) >= 32)\n-    FAIL;\n-\n   if (pa_emit_move_sequence (operands, SFmode, 0))\n     DONE;\n }\")\n \n+;; Handle SFmode input reloads requiring %r1 as a scratch register.\n+(define_expand \"reload_insf_r1\"\n+  [(set (match_operand:SF 0 \"register_operand\" \"=Z\")\n+\t(match_operand:SF 1 \"non_hard_reg_operand\" \"\"))\n+   (clobber (match_operand:SI 2 \"register_operand\" \"=&a\"))]\n+  \"\"\n+  \"\n+{\n+  if (pa_emit_move_sequence (operands, SFmode, operands[2]))\n+    DONE;\n+\n+  /* We don't want the clobber emitted, so handle this ourselves.  */\n+  emit_insn (gen_rtx_SET (VOIDmode, operands[0], operands[1]));\n+  DONE;\n+}\")\n+\n ;; Handle SFmode input reloads requiring a general register as a\n ;; scratch register.\n (define_expand \"reload_insf\"\n@@ -4429,9 +4385,9 @@\n \n (define_insn \"\"\n   [(set (match_operand:SF 0 \"move_dest_operand\"\n-\t\t\t  \"=f,!*r,f,*r,Q,Q,?*r,?f\")\n+\t\t\t  \"=f,!*r,f,*r,T,Q,?*r,?f\")\n \t(match_operand:SF 1 \"reg_or_0_or_nonsymb_mem_operand\"\n-\t\t\t  \"fG,!*rG,RQ,RQ,f,*rG,f,*r\"))]\n+\t\t\t  \"fG,!*rG,RT,RQ,f,*rG,f,*r\"))]\n   \"(register_operand (operands[0], SFmode)\n     || reg_or_0_operand (operands[1], SFmode))\n    && !TARGET_SOFT_FLOAT\n@@ -4451,9 +4407,9 @@\n \n (define_insn \"\"\n   [(set (match_operand:SF 0 \"move_dest_operand\"\n-\t\t\t  \"=f,!*r,f,*r,Q,Q\")\n+\t\t\t  \"=f,!*r,f,*r,T,Q\")\n \t(match_operand:SF 1 \"reg_or_0_or_nonsymb_mem_operand\"\n-\t\t\t  \"fG,!*rG,RQ,RQ,f,*rG\"))]\n+\t\t\t  \"fG,!*rG,RT,RQ,f,*rG\"))]\n   \"(register_operand (operands[0], SFmode)\n     || reg_or_0_operand (operands[1], SFmode))\n    && !TARGET_SOFT_FLOAT\n@@ -5408,7 +5364,7 @@\n }\")\n \n (define_insn \"umulsidi3\"\n-  [(set (match_operand:DI 0 \"nonimmediate_operand\" \"=f\")\n+  [(set (match_operand:DI 0 \"register_operand\" \"=f\")\n \t(mult:DI (zero_extend:DI (match_operand:SI 1 \"nonimmediate_operand\" \"f\"))\n \t\t (zero_extend:DI (match_operand:SI 2 \"nonimmediate_operand\" \"f\"))))]\n   \"TARGET_PA_11 && ! TARGET_DISABLE_FPREGS && ! TARGET_SOFT_FLOAT\"\n@@ -5417,7 +5373,7 @@\n    (set_attr \"length\" \"4\")])\n \n (define_insn \"\"\n-  [(set (match_operand:DI 0 \"nonimmediate_operand\" \"=f\")\n+  [(set (match_operand:DI 0 \"register_operand\" \"=f\")\n \t(mult:DI (zero_extend:DI (match_operand:SI 1 \"nonimmediate_operand\" \"f\"))\n \t\t (match_operand:DI 2 \"uint32_operand\" \"f\")))]\n   \"TARGET_PA_11 && ! TARGET_DISABLE_FPREGS && ! TARGET_SOFT_FLOAT && !TARGET_64BIT\"\n@@ -5426,7 +5382,7 @@\n    (set_attr \"length\" \"4\")])\n \n (define_insn \"\"\n-  [(set (match_operand:DI 0 \"nonimmediate_operand\" \"=f\")\n+  [(set (match_operand:DI 0 \"register_operand\" \"=f\")\n \t(mult:DI (zero_extend:DI (match_operand:SI 1 \"nonimmediate_operand\" \"f\"))\n \t\t (match_operand:DI 2 \"uint32_operand\" \"f\")))]\n   \"TARGET_PA_11 && ! TARGET_DISABLE_FPREGS && ! TARGET_SOFT_FLOAT && TARGET_64BIT\""}, {"sha": "8823706026b70e51adc95bf0b1fee3cfc3b9adea", "filename": "gcc/config/pa/predicates.md", "status": "modified", "additions": 127, "deletions": 14, "changes": 141, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a04ac2bc8e3e3dc3fa09364c60d5e165a0c858b/gcc%2Fconfig%2Fpa%2Fpredicates.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a04ac2bc8e3e3dc3fa09364c60d5e165a0c858b/gcc%2Fconfig%2Fpa%2Fpredicates.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpa%2Fpredicates.md?ref=1a04ac2bc8e3e3dc3fa09364c60d5e165a0c858b", "patch": "@@ -234,24 +234,134 @@\n   return IS_INDEX_ADDR_P (op) && memory_address_p (mode, op);\n })\n \n+;; True iff OP is a register plus base memory operand.\n+\n+(define_predicate \"reg_plus_base_memory_operand\"\n+  (match_code \"subreg,mem\")\n+{\n+  if (GET_MODE (op) != mode)\n+    return false;\n+\n+  /* Before reload, a (SUBREG (MEM...)) forces reloading into a register.  */\n+  if (reload_completed && GET_CODE (op) == SUBREG)\n+    op = SUBREG_REG (op);\n+\n+  if (! MEM_P (op))\n+    return false;\n+\n+  op = XEXP (op, 0);\n+  if (GET_CODE (op) != PLUS)\n+    return false;\n+\n+  if (REG_P (XEXP (op, 0)) && REG_OK_FOR_BASE_P (XEXP (op, 0)))\n+    return GET_CODE (XEXP (op, 1)) == CONST_INT;\n+\n+  return false;\n+})\n+\n+;; True iff OP is a base14 operand.\n+\n+(define_predicate \"base14_operand\"\n+  (match_code \"const_int\")\n+{\n+  if (!INT_14_BITS (op))\n+    return false;\n+\n+  /* Although this may not be necessary, we require that the\n+     base value is correctly aligned for its mode as this is\n+     assumed in the instruction encoding.  */\n+  switch (mode)\n+    {\n+    case QImode:\n+    case HImode:\n+      return true;\n+\n+    case SImode:\n+    case SFmode:\n+    case SCmode:\n+      return (INTVAL (op) % 4) == 0;\n+\n+    case DImode:\n+    case DFmode:\n+    case DCmode:\n+      return (INTVAL (op) % 8) == 0;\n+\n+    default:\n+      break;\n+    }\n+\n+  return false;\n+})\n+\n ;; True iff the operand OP can be used as the destination operand of\n ;; an integer store.  This also implies the operand could be used as\n-;; the source operand of an integer load.  Symbolic, lo_sum and indexed\n+;; the source operand of an integer load.  LO_SUM DLT and indexed\n ;; memory operands are not allowed.  We accept reloading pseudos and\n ;; other memory operands.\n \n (define_predicate \"integer_store_memory_operand\"\n   (match_code \"reg,mem\")\n {\n-  return ((reload_in_progress\n-           && REG_P (op)\n-           && REGNO (op) >= FIRST_PSEUDO_REGISTER\n-           && reg_renumber [REGNO (op)] < 0)\n-          || (MEM_P (op)\n-              && (reload_in_progress || memory_address_p (mode, XEXP (op, 0)))\n-              && !symbolic_memory_operand (op, VOIDmode)\n-              && !IS_LO_SUM_DLT_ADDR_P (XEXP (op, 0))\n-              && !IS_INDEX_ADDR_P (XEXP (op, 0))));\n+  if (reload_in_progress\n+      && REG_P (op)\n+      && REGNO (op) >= FIRST_PSEUDO_REGISTER\n+      && reg_renumber [REGNO (op)] < 0)\n+    return true;\n+\n+  if (reg_plus_base_memory_operand (op, mode))\n+    {\n+      /* Extract CONST_INT operand.  */\n+      if (GET_CODE (op) == SUBREG)\n+\top = SUBREG_REG (op);\n+      op = XEXP (op, 0);\n+      op = REG_P (XEXP (op, 0)) ? XEXP (op, 1) : XEXP (op, 0);\n+      return base14_operand (op, mode) || INT_5_BITS (op);\n+    }\n+\n+  if (!MEM_P (op))\n+    return false;\n+\n+  return ((reload_in_progress || memory_address_p (mode, XEXP (op, 0)))\n+\t  && !IS_LO_SUM_DLT_ADDR_P (XEXP (op, 0))\n+\t  && !IS_INDEX_ADDR_P (XEXP (op, 0)));\n+})\n+\n+;; True iff the operand OP can be used as the destination operand of\n+;; a floating point store.  This also implies the operand could be used as\n+;; the source operand of a floating point load.  LO_SUM DLT and indexed\n+;; memory operands are not allowed.  Symbolic operands are accepted if\n+;; INT14_OK_STRICT is true.  We accept reloading pseudos and other memory\n+;; operands.\n+\n+(define_predicate \"floating_point_store_memory_operand\"\n+  (match_code \"reg,mem\")\n+{\n+  if (reload_in_progress\n+      && REG_P (op)\n+      && REGNO (op) >= FIRST_PSEUDO_REGISTER\n+      && reg_renumber [REGNO (op)] < 0)\n+    return true;\n+\n+  if (reg_plus_base_memory_operand (op, mode))\n+    {\n+      /* Extract CONST_INT operand.  */\n+      if (GET_CODE (op) == SUBREG)\n+\top = SUBREG_REG (op);\n+      op = XEXP (op, 0);\n+      op = REG_P (XEXP (op, 0)) ? XEXP (op, 1) : XEXP (op, 0);\n+      return ((TARGET_PA_20\n+\t       && !TARGET_ELF32\n+\t       && base14_operand (op, mode))\n+\t      || INT_5_BITS (op));\n+    }\n+\n+  if (!MEM_P (op))\n+    return false;\n+\n+  return ((reload_in_progress || memory_address_p (mode, XEXP (op, 0)))\n+\t  && (INT14_OK_STRICT || !symbolic_memory_operand (op, VOIDmode))\n+\t  && !IS_LO_SUM_DLT_ADDR_P (XEXP (op, 0))\n+\t  && !IS_INDEX_ADDR_P (XEXP (op, 0)));\n })\n \n ;; Return true iff OP is an integer register.\n@@ -302,7 +412,7 @@\n   if (GET_CODE (op) == SUBREG)\n     op = SUBREG_REG (op);\n \n-  if (GET_CODE (op) != MEM || symbolic_memory_operand (op, mode))\n+  if (! MEM_P (op))\n     return false;\n \n   op = XEXP (op, 0);\n@@ -484,7 +594,10 @@\n     op = SUBREG_REG (op);\n   if (!MEM_P (op))\n     return false;\n-  return pa_symbolic_expression_p (XEXP (op, 0));\n+  op = XEXP (op, 0);\n+  if (GET_CODE (op) == LO_SUM)\n+    op = XEXP (op, 1);\n+  return pa_symbolic_expression_p (op);\n })\n \n ;; True iff OP is a symbolic operand.\n@@ -507,9 +620,9 @@\n \t\t  || GET_CODE (XEXP (op, 0)) == LABEL_REF)\n \t      && GET_CODE (XEXP (op, 1)) == CONST_INT);\n     default:\n-      gcc_unreachable ();\n+      break;\n     }\n-  return true;\n+  return false;\n })\n \n ;; Return true if OP is a symbolic operand for the TLS Global Dynamic model."}]}