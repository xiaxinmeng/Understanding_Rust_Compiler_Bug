{"sha": "91ff150410721f627691550dfe871907c6b0175e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTFmZjE1MDQxMDcyMWY2Mjc2OTE1NTBkZmU4NzE5MDdjNmIwMTc1ZQ==", "commit": {"author": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2015-06-18T09:39:13Z"}, "committer": {"name": "Richard Biener", "email": "rguenth@gcc.gnu.org", "date": "2015-06-18T09:39:13Z"}, "message": "re PR tree-optimization/66510 (gcc.target/arm/pr53636.c FAILs after r224221)\n\n2015-06-18  Richard Biener  <rguenther@suse.de>\n\n\tPR tree-optimization/66510\n\t* tree-vect-stmts.c (vectorizable_load): Properly compute the\n\tnumber of vector loads for SLP permuted loads.\n\t* tree-vect-data-refs.c (vect_compute_data_ref_alignment): Also\n\tcheck the stride for loop vectorization.\n\t(vect_enhance_data_refs_alignment): Deal with SLP adjusted\n\tvectorization factor.\n\t(vect_analyze_group_access): If the group size is not a power\n\tof two require a epilogue loop.\n\t* tree-vect-loop.c (vect_analyze_loop_2): Move alignment\n\tcompute and optimizing and alias test pruning after final\n\tvectorization factor computation.\n\t* tree-vect-slp.c (vect_build_slp_tree_1): Remove check on\n\tvector alignment.\n\t(vect_transform_slp_perm_load): Properly compute the original\n\tnumber of vector load stmts.\n\n\t* gcc.dg/vect/slp-perm-12.c: New testcase.\n\nFrom-SVN: r224598", "tree": {"sha": "da75024fa87089bd1e346a57d5ce2782e4667380", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/da75024fa87089bd1e346a57d5ce2782e4667380"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/91ff150410721f627691550dfe871907c6b0175e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/91ff150410721f627691550dfe871907c6b0175e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/91ff150410721f627691550dfe871907c6b0175e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/91ff150410721f627691550dfe871907c6b0175e/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "d38052e048a04a21beedcf61822f4a494be3a747", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d38052e048a04a21beedcf61822f4a494be3a747", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d38052e048a04a21beedcf61822f4a494be3a747"}], "stats": {"total": 211, "additions": 141, "deletions": 70}, "files": [{"sha": "22b3325fffff1f98935730148f456d3fba65d4e5", "filename": "gcc/ChangeLog", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/91ff150410721f627691550dfe871907c6b0175e/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/91ff150410721f627691550dfe871907c6b0175e/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=91ff150410721f627691550dfe871907c6b0175e", "patch": "@@ -1,3 +1,22 @@\n+2015-06-18  Richard Biener  <rguenther@suse.de>\n+\n+\tPR tree-optimization/66510\n+\t* tree-vect-stmts.c (vectorizable_load): Properly compute the\n+\tnumber of vector loads for SLP permuted loads.\n+\t* tree-vect-data-refs.c (vect_compute_data_ref_alignment): Also\n+\tcheck the stride for loop vectorization.\n+\t(vect_enhance_data_refs_alignment): Deal with SLP adjusted\n+\tvectorization factor.\n+\t(vect_analyze_group_access): If the group size is not a power\n+\tof two require a epilogue loop.\n+\t* tree-vect-loop.c (vect_analyze_loop_2): Move alignment\n+\tcompute and optimizing and alias test pruning after final\n+\tvectorization factor computation.\n+\t* tree-vect-slp.c (vect_build_slp_tree_1): Remove check on\n+\tvector alignment.\n+\t(vect_transform_slp_perm_load): Properly compute the original\n+\tnumber of vector load stmts.\n+\n 2015-06-18  Uros Bizjak  <ubizjak@gmail.com>\n \n \t* doc/invoke.texi (-fsanitize-sections): Split @var to avoid"}, {"sha": "80727d1620c8e3a58ac607b09f73ed88c6f8a565", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/91ff150410721f627691550dfe871907c6b0175e/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/91ff150410721f627691550dfe871907c6b0175e/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=91ff150410721f627691550dfe871907c6b0175e", "patch": "@@ -1,3 +1,8 @@\n+2015-06-18  Richard Biener  <rguenther@suse.de>\n+\n+\tPR tree-optimization/66510\n+\t* gcc.dg/vect/slp-perm-12.c: New testcase.\n+\n 2015-06-17  Uros Bizjak  <ubizjak@gmail.com>\n \n \t* gcc.target/i386/noplt-1.c (dg-do): Fix target selector."}, {"sha": "4d4c5344402e86a2c561647ee5b7dcf2e64f85ca", "filename": "gcc/testsuite/gcc.dg/vect/slp-perm-12.c", "status": "added", "additions": 52, "deletions": 0, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/91ff150410721f627691550dfe871907c6b0175e/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fslp-perm-12.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/91ff150410721f627691550dfe871907c6b0175e/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fslp-perm-12.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fslp-perm-12.c?ref=91ff150410721f627691550dfe871907c6b0175e", "patch": "@@ -0,0 +1,52 @@\n+/* { dg-require-effective-target vect_int } */\n+/* { dg-require-effective-target vect_pack_trunc } */\n+/* { dg-additional-options \"-msse4\" { target { i?86-*-* x86_64-*-* } } } */\n+\n+#include \"tree-vect.h\"\n+\n+extern void abort (void);\n+\n+unsigned char a[64];\n+short b[88];\n+\n+void __attribute__((noinline))\n+test(unsigned char * __restrict__ dst, short * __restrict__ tptr)\n+{\n+  int i;\n+  for (i = 0; i < 8; i++)\n+    {\n+      dst[0] = (tptr[0] - tptr[0 + 3]);\n+      dst[1] = (tptr[1] - tptr[1 + 3]);\n+      dst[2] = (tptr[2] - tptr[2 + 3]);\n+      dst[3] = (tptr[3] - tptr[3 + 3]);\n+      dst[4] = (tptr[4] - tptr[4 + 3]);\n+      dst[5] = (tptr[5] - tptr[5 + 3]);\n+      dst[6] = (tptr[6] - tptr[6 + 3]);\n+      dst[7] = (tptr[7] - tptr[7 + 3]);\n+      dst += 8;\n+      tptr += 11;\n+    }\n+}\n+\n+int main()\n+{\n+  int i;\n+\n+  check_vect ();\n+\n+  for (i = 0; i < 88; ++i)\n+    {\n+      b[i] = i;\n+      __asm__ volatile (\"\");\n+    }\n+\n+  test (a, b);\n+\n+  for (i = 0; i < 64; ++i)\n+    if (a[i] != 253)\n+      abort ();\n+\n+  return 0;\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"vectorizing stmts using SLP\" 1 \"vect\" { target vect_perm } } } */"}, {"sha": "b626e383f3b57f623636af784c358f85821b1306", "filename": "gcc/tree-vect-data-refs.c", "status": "modified", "additions": 23, "deletions": 12, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/91ff150410721f627691550dfe871907c6b0175e/gcc%2Ftree-vect-data-refs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/91ff150410721f627691550dfe871907c6b0175e/gcc%2Ftree-vect-data-refs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-data-refs.c?ref=91ff150410721f627691550dfe871907c6b0175e", "patch": "@@ -691,21 +691,22 @@ vect_compute_data_ref_alignment (struct data_reference *dr)\n \t}\n     }\n \n-  /* Similarly, if we're doing basic-block vectorization, we can only use\n-     base and misalignment information relative to an innermost loop if the\n-     misalignment stays the same throughout the execution of the loop.\n-     As above, this is the case if the stride of the dataref evenly divides\n-     by the vector size.  */\n-  if (!loop)\n+  /* Similarly we can only use base and misalignment information relative to\n+     an innermost loop if the misalignment stays the same throughout the\n+     execution of the loop.  As above, this is the case if the stride of\n+     the dataref evenly divides by the vector size.  */\n+  else\n     {\n       tree step = DR_STEP (dr);\n+      unsigned vf = loop ? LOOP_VINFO_VECT_FACTOR (loop_vinfo) : 1;\n \n       if (tree_fits_shwi_p (step)\n-\t  && tree_to_shwi (step) % GET_MODE_SIZE (TYPE_MODE (vectype)) != 0)\n+\t  && ((tree_to_shwi (step) * vf)\n+\t      % GET_MODE_SIZE (TYPE_MODE (vectype)) != 0))\n \t{\n \t  if (dump_enabled_p ())\n \t    dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n-\t                     \"SLP: step doesn't divide the vector-size.\\n\");\n+\t                     \"step doesn't divide the vector-size.\\n\");\n \t  misalign = NULL_TREE;\n \t}\n     }\n@@ -1440,7 +1441,13 @@ vect_enhance_data_refs_alignment (loop_vec_info loop_vinfo)\n                  We do this automtically for cost model, since we calculate cost\n                  for every peeling option.  */\n               if (unlimited_cost_model (LOOP_VINFO_LOOP (loop_vinfo)))\n-                possible_npeel_number = vf /nelements;\n+\t\t{\n+\t\t  if (STMT_SLP_TYPE (stmt_info))\n+\t\t    possible_npeel_number\n+\t\t      = (vf * GROUP_SIZE (stmt_info)) / nelements;\n+\t\t  else\n+\t\t    possible_npeel_number = vf / nelements;\n+\t\t}\n \n               /* Handle the aligned case. We may decide to align some other\n                  access, making DR unaligned.  */\n@@ -1453,7 +1460,6 @@ vect_enhance_data_refs_alignment (loop_vec_info loop_vinfo)\n \n               for (j = 0; j < possible_npeel_number; j++)\n                 {\n-                  gcc_assert (npeel_tmp <= vf);\n                   vect_peeling_hash_insert (loop_vinfo, dr, npeel_tmp);\n                   npeel_tmp += nelements;\n                 }\n@@ -2230,8 +2236,13 @@ vect_analyze_group_access (struct data_reference *dr)\n             BB_VINFO_GROUPED_STORES (bb_vinfo).safe_push (stmt);\n         }\n \n-      /* There is a gap in the end of the group.  */\n-      if (groupsize - last_accessed_element > 0 && loop_vinfo)\n+      /* If there is a gap in the end of the group or the group size cannot\n+         be made a multiple of the vector element count then we access excess\n+\t elements in the last iteration and thus need to peel that off.  */\n+      if (loop_vinfo\n+\t  && (groupsize - last_accessed_element > 0\n+\t      || exact_log2 (groupsize) == -1))\n+\n \t{\n \t  if (dump_enabled_p ())\n \t    dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,"}, {"sha": "4b01ade1398f0ec9843cf579795aa72e228234bc", "filename": "gcc/tree-vect-loop.c", "status": "modified", "additions": 25, "deletions": 23, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/91ff150410721f627691550dfe871907c6b0175e/gcc%2Ftree-vect-loop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/91ff150410721f627691550dfe871907c6b0175e/gcc%2Ftree-vect-loop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-loop.c?ref=91ff150410721f627691550dfe871907c6b0175e", "patch": "@@ -1791,6 +1791,22 @@ vect_analyze_loop_2 (loop_vec_info loop_vinfo)\n       return false;\n     }\n \n+  /* Check the SLP opportunities in the loop, analyze and build SLP trees.  */\n+  ok = vect_analyze_slp (loop_vinfo, NULL, n_stmts);\n+  if (!ok)\n+    return false;\n+\n+  /* If there are any SLP instances mark them as pure_slp.  */\n+  bool slp = vect_make_slp_decision (loop_vinfo);\n+  if (slp)\n+    {\n+      /* Find stmts that need to be both vectorized and SLPed.  */\n+      vect_detect_hybrid_slp (loop_vinfo);\n+\n+      /* Update the vectorization factor based on the SLP decision.  */\n+      vect_update_vf_for_slp (loop_vinfo);\n+    }\n+\n   /* Analyze the alignment of the data-refs in the loop.\n      Fail if a data reference is found that cannot be vectorized.  */\n \n@@ -1830,31 +1846,17 @@ vect_analyze_loop_2 (loop_vec_info loop_vinfo)\n       return false;\n     }\n \n-  /* Check the SLP opportunities in the loop, analyze and build SLP trees.  */\n-  ok = vect_analyze_slp (loop_vinfo, NULL, n_stmts);\n-  if (ok)\n+  if (slp)\n     {\n-      /* If there are any SLP instances mark them as pure_slp.  */\n-      if (vect_make_slp_decision (loop_vinfo))\n-\t{\n-\t  /* Find stmts that need to be both vectorized and SLPed.  */\n-\t  vect_detect_hybrid_slp (loop_vinfo);\n-\n-\t  /* Update the vectorization factor based on the SLP decision.  */\n-\t  vect_update_vf_for_slp (loop_vinfo);\n-\n-\t  /* Analyze operations in the SLP instances.  Note this may\n-\t     remove unsupported SLP instances which makes the above\n-\t     SLP kind detection invalid.  */\n-\t  unsigned old_size = LOOP_VINFO_SLP_INSTANCES (loop_vinfo).length ();\n-\t  vect_slp_analyze_operations (LOOP_VINFO_SLP_INSTANCES (loop_vinfo),\n-\t\t\t\t       LOOP_VINFO_TARGET_COST_DATA (loop_vinfo));\n-\t  if (LOOP_VINFO_SLP_INSTANCES (loop_vinfo).length () != old_size)\n-\t    return false;\n-\t}\n+      /* Analyze operations in the SLP instances.  Note this may\n+\t remove unsupported SLP instances which makes the above\n+\t SLP kind detection invalid.  */\n+      unsigned old_size = LOOP_VINFO_SLP_INSTANCES (loop_vinfo).length ();\n+      vect_slp_analyze_operations (LOOP_VINFO_SLP_INSTANCES (loop_vinfo),\n+\t\t\t\t   LOOP_VINFO_TARGET_COST_DATA (loop_vinfo));\n+      if (LOOP_VINFO_SLP_INSTANCES (loop_vinfo).length () != old_size)\n+\treturn false;\n     }\n-  else\n-    return false;\n \n   /* Scan all the remaining operations in the loop that are not subject\n      to SLP and make sure they are vectorizable.  */"}, {"sha": "47d8a42474e9786cbadb19a214798eda4f752a97", "filename": "gcc/tree-vect-slp.c", "status": "modified", "additions": 10, "deletions": 34, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/91ff150410721f627691550dfe871907c6b0175e/gcc%2Ftree-vect-slp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/91ff150410721f627691550dfe871907c6b0175e/gcc%2Ftree-vect-slp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-slp.c?ref=91ff150410721f627691550dfe871907c6b0175e", "patch": "@@ -485,9 +485,8 @@ vect_build_slp_tree_1 (loop_vec_info loop_vinfo, bb_vec_info bb_vinfo,\n   int icode;\n   machine_mode optab_op2_mode;\n   machine_mode vec_mode;\n-  struct data_reference *first_dr;\n   HOST_WIDE_INT dummy;\n-  gimple first_load = NULL, prev_first_load = NULL, old_first_load = NULL;\n+  gimple first_load = NULL, prev_first_load = NULL;\n   tree cond;\n \n   /* For every stmt in NODE find its def stmt/s.  */\n@@ -785,7 +784,6 @@ vect_build_slp_tree_1 (loop_vec_info loop_vinfo, bb_vec_info bb_vinfo,\n                   return false;\n                 }\n \n-\t      old_first_load = first_load;\n               first_load = GROUP_FIRST_ELEMENT (vinfo_for_stmt (stmt));\n               if (prev_first_load)\n                 {\n@@ -809,30 +807,6 @@ vect_build_slp_tree_1 (loop_vec_info loop_vinfo, bb_vec_info bb_vinfo,\n                 }\n               else\n                 prev_first_load = first_load;\n-\n-\t      /* In some cases a group of loads is just the same load\n-\t\t repeated N times.  Only analyze its cost once.  */\n-              if (first_load == stmt && old_first_load != first_load)\n-                {\n-                  first_dr = STMT_VINFO_DATA_REF (vinfo_for_stmt (stmt));\n-                  if (vect_supportable_dr_alignment (first_dr, false)\n-                      == dr_unaligned_unsupported)\n-                    {\n-                      if (dump_enabled_p ())\n-                        {\n-                          dump_printf_loc (MSG_MISSED_OPTIMIZATION,\n-\t\t\t\t\t   vect_location, \n-\t\t\t\t\t   \"Build SLP failed: unsupported \"\n-\t\t\t\t\t   \"unaligned load \");\n-                          dump_gimple_stmt (MSG_MISSED_OPTIMIZATION, TDF_SLIM,\n-\t\t\t\t\t    stmt, 0);\n-                          dump_printf (MSG_MISSED_OPTIMIZATION, \"\\n\");\n-                        }\n-\t\t      /* Fatal mismatch.  */\n-\t\t      matches[0] = false;\n-                      return false;\n-                    }\n-                }\n            }\n         } /* Grouped access.  */\n       else\n@@ -3201,6 +3175,11 @@ vect_transform_slp_perm_load (slp_tree node, vec<tree> dr_chain,\n   bool needs_first_vector = false;\n   machine_mode mode;\n \n+  if (!STMT_VINFO_GROUPED_ACCESS (stmt_info))\n+    return false;\n+\n+  stmt_info = vinfo_for_stmt (GROUP_FIRST_ELEMENT (stmt_info));\n+\n   mode = TYPE_MODE (vectype);\n \n   if (!can_vec_perm_p (mode, false, NULL))\n@@ -3226,20 +3205,17 @@ vect_transform_slp_perm_load (slp_tree node, vec<tree> dr_chain,\n \n   /* The number of vector stmts to generate based only on SLP_NODE_INSTANCE\n      unrolling factor.  */\n-  orig_vec_stmts_num = group_size *\n-                SLP_INSTANCE_UNROLLING_FACTOR (slp_node_instance) / nunits;\n+  orig_vec_stmts_num\n+    = (STMT_VINFO_GROUP_SIZE (stmt_info)\n+       * SLP_INSTANCE_UNROLLING_FACTOR (slp_node_instance)\n+       + nunits - 1) / nunits;\n   if (orig_vec_stmts_num == 1)\n     only_one_vec = true;\n \n   /* Number of copies is determined by the final vectorization factor\n      relatively to SLP_NODE_INSTANCE unrolling factor.  */\n   ncopies = vf / SLP_INSTANCE_UNROLLING_FACTOR (slp_node_instance);\n \n-  if (!STMT_VINFO_GROUPED_ACCESS (stmt_info))\n-    return false;\n-\n-  stmt_info = vinfo_for_stmt (GROUP_FIRST_ELEMENT (stmt_info));\n-\n   /* Generate permutation masks for every NODE. Number of masks for each NODE\n      is equal to GROUP_SIZE.\n      E.g., we have a group of three nodes with three loads from the same"}, {"sha": "d4d3b91dd99b47d011ba39d9ffb2d4b5d630b5ae", "filename": "gcc/tree-vect-stmts.c", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/91ff150410721f627691550dfe871907c6b0175e/gcc%2Ftree-vect-stmts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/91ff150410721f627691550dfe871907c6b0175e/gcc%2Ftree-vect-stmts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-stmts.c?ref=91ff150410721f627691550dfe871907c6b0175e", "patch": "@@ -6422,7 +6422,13 @@ vectorizable_load (gimple stmt, gimple_stmt_iterator *gsi, gimple *vec_stmt,\n       if (slp)\n \t{\n \t  grouped_load = false;\n-\t  vec_num = SLP_TREE_NUMBER_OF_VEC_STMTS (slp_node);\n+\t  /* For SLP permutation support we need to load the whole group,\n+\t     not only the number of vector stmts the permutation result\n+\t     fits in.  */\n+\t  if (slp_perm)\n+\t    vec_num = (group_size * vf + nunits - 1) / nunits;\n+\t  else\n+\t    vec_num = SLP_TREE_NUMBER_OF_VEC_STMTS (slp_node);\n \t  group_gap_adj = vf * group_size - nunits * vec_num;\n     \t}\n       else"}]}