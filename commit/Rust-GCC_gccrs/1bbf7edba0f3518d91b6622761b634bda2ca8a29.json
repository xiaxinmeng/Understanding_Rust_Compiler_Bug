{"sha": "1bbf7edba0f3518d91b6622761b634bda2ca8a29", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MWJiZjdlZGJhMGYzNTE4ZDkxYjY2MjI3NjFiNjM0YmRhMmNhOGEyOQ==", "commit": {"author": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2011-08-29T22:06:19Z"}, "committer": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2011-08-29T22:06:19Z"}, "message": "Lower calls to bound method expressions.\n\nFrom-SVN: r178264", "tree": {"sha": "723b92c72a0ba175df1059b88a1244ec013d0891", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/723b92c72a0ba175df1059b88a1244ec013d0891"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/1bbf7edba0f3518d91b6622761b634bda2ca8a29", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1bbf7edba0f3518d91b6622761b634bda2ca8a29", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1bbf7edba0f3518d91b6622761b634bda2ca8a29", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1bbf7edba0f3518d91b6622761b634bda2ca8a29/comments", "author": null, "committer": null, "parents": [{"sha": "273113346e85423e88d1352c4acafe41e7dd90b5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/273113346e85423e88d1352c4acafe41e7dd90b5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/273113346e85423e88d1352c4acafe41e7dd90b5"}], "stats": {"total": 417, "additions": 197, "deletions": 220}, "files": [{"sha": "8957acb0c8aa45c2a885f5d223371a3bc8725407", "filename": "gcc/go/gofrontend/expressions.cc", "status": "modified", "additions": 181, "deletions": 155, "changes": 336, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1bbf7edba0f3518d91b6622761b634bda2ca8a29/gcc%2Fgo%2Fgofrontend%2Fexpressions.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1bbf7edba0f3518d91b6622761b634bda2ca8a29/gcc%2Fgo%2Fgofrontend%2Fexpressions.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fexpressions.cc?ref=1bbf7edba0f3518d91b6622761b634bda2ca8a29", "patch": "@@ -3845,7 +3845,7 @@ Unsafe_type_conversion_expression::do_get_tree(Translate_context* context)\n     go_assert((et->points_to() != NULL\n \t\t&& et->points_to()->channel_type() != NULL)\n \t       || et->is_nil_type());\n-  else if (t->is_unsafe_pointer_type())\n+  else if (t->points_to() != NULL)\n     go_assert(et->points_to() != NULL || et->is_nil_type());\n   else if (et->is_unsafe_pointer_type())\n     go_assert(t->points_to() != NULL);\n@@ -3908,7 +3908,7 @@ class Unary_expression : public Expression\n  public:\n   Unary_expression(Operator op, Expression* expr, source_location location)\n     : Expression(EXPRESSION_UNARY, location),\n-      op_(op), escapes_(true), expr_(expr)\n+      op_(op), escapes_(true), create_temp_(false), expr_(expr)\n   { }\n \n   // Return the operator.\n@@ -3929,6 +3929,15 @@ class Unary_expression : public Expression\n     this->escapes_ = false;\n   }\n \n+  // Record that this is an address expression which should create a\n+  // temporary variable if necessary.  This is used for method calls.\n+  void\n+  set_create_temp()\n+  {\n+    go_assert(this->op_ == OPERATOR_AND);\n+    this->create_temp_ = true;\n+  }\n+\n   // Apply unary opcode OP to UVAL, setting VAL.  Return true if this\n   // could be done, false if not.\n   static bool\n@@ -4004,6 +4013,9 @@ class Unary_expression : public Expression\n   // Normally true.  False if this is an address expression which does\n   // not escape the current function.\n   bool escapes_;\n+  // True if this is an address expression which should create a\n+  // temporary variable if necessary.\n+  bool create_temp_;\n   // The operand.\n   Expression* expr_;\n };\n@@ -4428,7 +4440,10 @@ Unary_expression::do_check_types(Gogo*)\n \n     case OPERATOR_AND:\n       if (!this->expr_->is_addressable())\n-\tthis->report_error(_(\"invalid operand for unary %<&%>\"));\n+\t{\n+\t  if (!this->create_temp_)\n+\t    this->report_error(_(\"invalid operand for unary %<&%>\"));\n+\t}\n       else\n \tthis->expr_->address_taken(this->escapes_);\n       break;\n@@ -4486,12 +4501,15 @@ Unary_expression::do_get_tree(Translate_context* context)\n       return fold_build1_loc(loc, BIT_NOT_EXPR, TREE_TYPE(expr), expr);\n \n     case OPERATOR_AND:\n-      // We should not see a non-constant constructor here; cases\n-      // where we would see one should have been moved onto the heap\n-      // at parse time.  Taking the address of a nonconstant\n-      // constructor will not do what the programmer expects.\n-      go_assert(TREE_CODE(expr) != CONSTRUCTOR || TREE_CONSTANT(expr));\n-      go_assert(TREE_CODE(expr) != ADDR_EXPR);\n+      if (!this->create_temp_)\n+\t{\n+\t  // We should not see a non-constant constructor here; cases\n+\t  // where we would see one should have been moved onto the\n+\t  // heap at parse time.  Taking the address of a nonconstant\n+\t  // constructor will not do what the programmer expects.\n+\t  go_assert(TREE_CODE(expr) != CONSTRUCTOR || TREE_CONSTANT(expr));\n+\t  go_assert(TREE_CODE(expr) != ADDR_EXPR);\n+\t}\n \n       // Build a decl for a constant constructor.\n       if (TREE_CODE(expr) == CONSTRUCTOR && TREE_CONSTANT(expr))\n@@ -4510,6 +4528,22 @@ Unary_expression::do_get_tree(Translate_context* context)\n \t  expr = decl;\n \t}\n \n+      if (this->create_temp_\n+\t  && !TREE_ADDRESSABLE(TREE_TYPE(expr))\n+\t  && !DECL_P(expr)\n+\t  && TREE_CODE(expr) != INDIRECT_REF\n+\t  && TREE_CODE(expr) != COMPONENT_REF)\n+\t{\n+\t  tree tmp = create_tmp_var(TREE_TYPE(expr), get_name(expr));\n+\t  DECL_IGNORED_P(tmp) = 1;\n+\t  DECL_INITIAL(tmp) = expr;\n+\t  TREE_ADDRESSABLE(tmp) = 1;\n+\t  return build2_loc(loc, COMPOUND_EXPR,\n+\t\t\t    build_pointer_type(TREE_TYPE(expr)),\n+\t\t\t    build1_loc(loc, DECL_EXPR, void_type_node, tmp),\n+\t\t\t    build_fold_addr_expr_loc(loc, tmp));\n+\t}\n+\n       return build_fold_addr_expr_loc(loc, expr);\n \n     case OPERATOR_MULT:\n@@ -7223,7 +7257,7 @@ Builtin_call_expression::do_lower(Gogo* gogo, Named_object* function,\n \t  this->set_is_error();\n \t  return this;\n \t}\n-      return this->lower_varargs(gogo, function, inserter, slice_type, 2);\n+      this->lower_varargs(gogo, function, inserter, slice_type, 2);\n     }\n \n   return this;\n@@ -8805,20 +8839,22 @@ Expression*\n Call_expression::do_lower(Gogo* gogo, Named_object* function,\n \t\t\t  Statement_inserter* inserter, int)\n {\n+  source_location loc = this->location();\n+\n   // A type cast can look like a function call.\n   if (this->fn_->is_type_expression()\n       && this->args_ != NULL\n       && this->args_->size() == 1)\n     return Expression::make_cast(this->fn_->type(), this->args_->front(),\n-\t\t\t\t this->location());\n+\t\t\t\t loc);\n \n   // Recognize a call to a builtin function.\n   Func_expression* fne = this->fn_->func_expression();\n   if (fne != NULL\n       && fne->named_object()->is_function_declaration()\n       && fne->named_object()->func_declaration_value()->type()->is_builtin())\n     return new Builtin_call_expression(gogo, this->fn_, this->args_,\n-\t\t\t\t       this->is_varargs_, this->location());\n+\t\t\t\t       this->is_varargs_, loc);\n \n   // Handle an argument which is a call to a function which returns\n   // multiple results.\n@@ -8862,8 +8898,7 @@ Call_expression::do_lower(Gogo* gogo, Named_object* function,\n \t   ++p)\n \t{\n \t  Temporary_statement* temp = Statement::make_temporary(p->type(),\n-\t\t\t\t\t\t\t\tNULL,\n-\t\t\t\t\t\t\t\tp->location());\n+\t\t\t\t\t\t\t\tNULL, loc);\n \t  inserter->insert(temp);\n \t  temps->push_back(temp);\n \t}\n@@ -8879,8 +8914,58 @@ Call_expression::do_lower(Gogo* gogo, Named_object* function,\n       const Typed_identifier_list* parameters = fntype->parameters();\n       go_assert(parameters != NULL && !parameters->empty());\n       Type* varargs_type = parameters->back().type();\n-      return this->lower_varargs(gogo, function, inserter, varargs_type,\n-\t\t\t\t parameters->size());\n+      this->lower_varargs(gogo, function, inserter, varargs_type,\n+\t\t\t  parameters->size());\n+    }\n+\n+  // If this is call to a method, call the method directly passing the\n+  // object as the first parameter.\n+  Bound_method_expression* bme = this->fn_->bound_method_expression();\n+  if (bme != NULL)\n+    {\n+      Named_object* method = bme->method();\n+      Expression* first_arg = bme->first_argument();\n+\n+      // We always pass a pointer when calling a method.\n+      if (first_arg->type()->points_to() == NULL\n+\t  && !first_arg->type()->is_error())\n+\t{\n+\t  first_arg = Expression::make_unary(OPERATOR_AND, first_arg, loc);\n+\t  // We may need to create a temporary variable so that we can\n+\t  // take the address.  We can't do that here because it will\n+\t  // mess up the order of evaluation.\n+\t  Unary_expression* ue = static_cast<Unary_expression*>(first_arg);\n+\t  ue->set_create_temp();\n+\t}\n+\n+      // If we are calling a method which was inherited from an\n+      // embedded struct, and the method did not get a stub, then the\n+      // first type may be wrong.\n+      Type* fatype = bme->first_argument_type();\n+      if (fatype != NULL)\n+\t{\n+\t  if (fatype->points_to() == NULL)\n+\t    fatype = Type::make_pointer_type(fatype);\n+\t  first_arg = Expression::make_unsafe_cast(fatype, first_arg, loc);\n+\t}\n+\n+      Expression_list* new_args = new Expression_list();\n+      new_args->push_back(first_arg);\n+      if (this->args_ != NULL)\n+\t{\n+\t  for (Expression_list::const_iterator p = this->args_->begin();\n+\t       p != this->args_->end();\n+\t       ++p)\n+\t    new_args->push_back(*p);\n+\t}\n+\n+      // We have to change in place because this structure may be\n+      // referenced by Call_result_expressions.  We can't delete the\n+      // old arguments, because we may be traversing them up in some\n+      // caller.  FIXME.\n+      this->args_ = new_args;\n+      this->fn_ = Expression::make_func_reference(method, NULL,\n+\t\t\t\t\t\t  bme->location());\n     }\n \n   return this;\n@@ -8893,13 +8978,13 @@ Call_expression::do_lower(Gogo* gogo, Named_object* function,\n // calling; the last of these parameters will be the varargs\n // parameter.\n \n-Expression*\n+void\n Call_expression::lower_varargs(Gogo* gogo, Named_object* function,\n \t\t\t       Statement_inserter* inserter,\n \t\t\t       Type* varargs_type, size_t param_count)\n {\n   if (this->varargs_are_lowered_)\n-    return this;\n+    return;\n \n   source_location loc = this->location();\n \n@@ -8910,7 +8995,7 @@ Call_expression::lower_varargs(Gogo* gogo, Named_object* function,\n   if (arg_count < param_count - 1)\n     {\n       // Not enough arguments; will be caught in check_types.\n-      return this;\n+      return;\n     }\n \n   Expression_list* old_args = this->args_;\n@@ -8942,7 +9027,7 @@ Call_expression::lower_varargs(Gogo* gogo, Named_object* function,\n       else if (this->is_varargs_)\n \t{\n \t  this->report_error(_(\"too many arguments\"));\n-\t  return this;\n+\t  return;\n \t}\n       else\n \t{\n@@ -8960,6 +9045,7 @@ Call_expression::lower_varargs(Gogo* gogo, Named_object* function,\n \t    }\n \t  Expression* val =\n \t    Expression::make_slice_composite_literal(varargs_type, vals, loc);\n+\t  gogo->lower_expression(function, inserter, &val);\n \t  new_args->push_back(val);\n \t}\n     }\n@@ -8973,12 +9059,6 @@ Call_expression::lower_varargs(Gogo* gogo, Named_object* function,\n   // Builtin_call_expression which refer to them.  FIXME.\n   this->args_ = new_args;\n   this->varargs_are_lowered_ = true;\n-\n-  // Lower all the new subexpressions.\n-  Expression* ret = this;\n-  gogo->lower_expression(function, inserter, &ret);\n-  go_assert(ret == this);\n-  return ret;\n }\n \n // Get the function type.  This can return NULL in error cases.\n@@ -9102,10 +9182,28 @@ Call_expression::do_determine_type(const Type_context*)\n       Typed_identifier_list::const_iterator pt;\n       if (parameters != NULL)\n \tpt = parameters->begin();\n+      bool first = true;\n       for (Expression_list::const_iterator pa = this->args_->begin();\n \t   pa != this->args_->end();\n \t   ++pa)\n \t{\n+\t  if (first)\n+\t    {\n+\t      first = false;\n+\t      // If this is a method, the first argument is the\n+\t      // receiver.\n+\t      if (fntype != NULL && fntype->is_method())\n+\t\t{\n+\t\t  Type* rtype = fntype->receiver()->type();\n+\t\t  // The receiver is always passed as a pointer.\n+\t\t  if (rtype->points_to() == NULL)\n+\t\t    rtype = Type::make_pointer_type(rtype);\n+\t\t  Type_context subcontext(rtype, false);\n+\t\t  (*pa)->determine_type(&subcontext);\n+\t\t  continue;\n+\t\t}\n+\t    }\n+\n \t  if (parameters != NULL && pt != parameters->end())\n \t    {\n \t      Type_context subcontext(pt->type(), false);\n@@ -9172,35 +9270,28 @@ Call_expression::do_check_types(Gogo*)\n       return;\n     }\n \n-  if (fntype->is_method())\n+  bool is_method = fntype->is_method();\n+  if (is_method)\n     {\n-      // We don't support pointers to methods, so the function has to\n-      // be a bound method expression.\n-      Bound_method_expression* bme = this->fn_->bound_method_expression();\n-      if (bme == NULL)\n-\t{\n-\t  this->report_error(_(\"method call without object\"));\n-\t  return;\n-\t}\n-      Type* first_arg_type = bme->first_argument()->type();\n-      if (first_arg_type->points_to() == NULL)\n+      go_assert(this->args_ != NULL && !this->args_->empty());\n+      Type* rtype = fntype->receiver()->type();\n+      Expression* first_arg = this->args_->front();\n+      // The language permits copying hidden fields for a method\n+      // receiver.  We dereference the values since receivers are\n+      // always passed as pointers.\n+      std::string reason;\n+      if (!Type::are_assignable_hidden_ok(rtype->deref(),\n+\t\t\t\t\t  first_arg->type()->deref(),\n+\t\t\t\t\t  &reason))\n \t{\n-\t  // When passing a value, we need to check that we are\n-\t  // permitted to copy it.  The language permits copying\n-\t  // hidden fields for a method receiver.\n-\t  std::string reason;\n-\t  if (!Type::are_assignable_hidden_ok(fntype->receiver()->type(),\n-\t\t\t\t\t      first_arg_type, &reason))\n+\t  if (reason.empty())\n+\t    this->report_error(_(\"incompatible type for receiver\"));\n+\t  else\n \t    {\n-\t      if (reason.empty())\n-\t\tthis->report_error(_(\"incompatible type for receiver\"));\n-\t      else\n-\t\t{\n-\t\t  error_at(this->location(),\n-\t\t\t   \"incompatible type for receiver (%s)\",\n-\t\t\t   reason.c_str());\n-\t\t  this->set_is_error();\n-\t\t}\n+\t      error_at(this->location(),\n+\t\t       \"incompatible type for receiver (%s)\",\n+\t\t       reason.c_str());\n+\t      this->set_is_error();\n \t    }\n \t}\n     }\n@@ -9215,25 +9306,30 @@ Call_expression::do_check_types(Gogo*)\n \tthis->report_error(_(\"not enough arguments\"));\n     }\n   else if (parameters == NULL)\n-    this->report_error(_(\"too many arguments\"));\n+    {\n+      if (!is_method || this->args_->size() > 1)\n+\tthis->report_error(_(\"too many arguments\"));\n+    }\n   else\n     {\n       int i = 0;\n-      Typed_identifier_list::const_iterator pt = parameters->begin();\n-      for (Expression_list::const_iterator pa = this->args_->begin();\n-\t   pa != this->args_->end();\n-\t   ++pa, ++pt, ++i)\n-\t{\n-\t  if (pt == parameters->end())\n+      Expression_list::const_iterator pa = this->args_->begin();\n+      if (is_method)\n+\t++pa;\n+      for (Typed_identifier_list::const_iterator pt = parameters->begin();\n+\t   pt != parameters->end();\n+\t   ++pt, ++pa, ++i)\n+\t{\n+\t  if (pa == this->args_->end())\n \t    {\n-\t      this->report_error(_(\"too many arguments\"));\n+\t      this->report_error(_(\"not enough arguments\"));\n \t      return;\n \t    }\n \t  this->check_argument_type(i + 1, pt->type(), (*pa)->type(),\n \t\t\t\t    (*pa)->location(), false);\n \t}\n-      if (pt != parameters->end())\n-\tthis->report_error(_(\"not enough arguments\"));\n+      if (pa != this->args_->end())\n+\tthis->report_error(_(\"too many arguments\"));\n     }\n }\n \n@@ -9247,83 +9343,6 @@ Call_expression::do_must_eval_in_order() const\n   return this->result_count() > 0;\n }\n \n-// Get the function and the first argument to use when calling a bound\n-// method.\n-\n-tree\n-Call_expression::bound_method_function(Translate_context* context,\n-\t\t\t\t       Bound_method_expression* bound_method,\n-\t\t\t\t       tree* first_arg_ptr)\n-{\n-  Gogo* gogo = context->gogo();\n-  source_location loc = this->location();\n-\n-  Expression* first_argument = bound_method->first_argument();\n-  tree first_arg = first_argument->get_tree(context);\n-  if (first_arg == error_mark_node)\n-    return error_mark_node;\n-\n-  // We always pass a pointer to the first argument when calling a\n-  // method.\n-  if (first_argument->type()->points_to() == NULL)\n-    {\n-      tree pointer_to_arg_type = build_pointer_type(TREE_TYPE(first_arg));\n-      if (TREE_ADDRESSABLE(TREE_TYPE(first_arg))\n-\t  || DECL_P(first_arg)\n-\t  || TREE_CODE(first_arg) == INDIRECT_REF\n-\t  || TREE_CODE(first_arg) == COMPONENT_REF)\n-\t{\n-\t  first_arg = build_fold_addr_expr_loc(loc, first_arg);\n-\t  if (DECL_P(first_arg))\n-\t    TREE_ADDRESSABLE(first_arg) = 1;\n-\t}\n-      else\n-\t{\n-\t  tree tmp = create_tmp_var(TREE_TYPE(first_arg),\n-\t\t\t\t    get_name(first_arg));\n-\t  DECL_IGNORED_P(tmp) = 0;\n-\t  DECL_INITIAL(tmp) = first_arg;\n-\t  first_arg = build2_loc(loc, COMPOUND_EXPR, pointer_to_arg_type,\n-\t\t\t\t build1_loc(loc, DECL_EXPR, void_type_node,\n-\t\t\t\t\t    tmp),\n-\t\t\t\t build_fold_addr_expr_loc(loc, tmp));\n-\t  TREE_ADDRESSABLE(tmp) = 1;\n-\t}\n-      if (first_arg == error_mark_node)\n-\treturn error_mark_node;\n-    }\n-\n-  Type* fatype = bound_method->first_argument_type();\n-  if (fatype != NULL)\n-    {\n-      if (fatype->points_to() == NULL)\n-\tfatype = Type::make_pointer_type(fatype);\n-      Btype* bfatype = fatype->get_backend(gogo);\n-      first_arg = fold_convert_loc(loc, type_to_tree(bfatype), first_arg);\n-      if (first_arg == error_mark_node\n-\t  || TREE_TYPE(first_arg) == error_mark_node)\n-\treturn error_mark_node;\n-    }\n-\n-  *first_arg_ptr = first_arg;\n-\n-  Named_object* method = bound_method->method();\n-  tree id = method->get_id(gogo);\n-  if (id == error_mark_node)\n-    return error_mark_node;\n-\n-  tree fndecl;\n-  if (method->is_function())\n-    fndecl = method->func_value()->get_or_make_decl(gogo, method, id);\n-  else if (method->is_function_declaration())\n-    fndecl = method->func_declaration_value()->get_or_make_decl(gogo, method,\n-\t\t\t\t\t\t\t\tid);\n-  else\n-    go_unreachable();\n-\n-  return build_fold_addr_expr_loc(loc, fndecl);\n-}\n-\n // Get the function and the first argument to use when calling an\n // interface method.\n \n@@ -9363,35 +9382,46 @@ Call_expression::do_get_tree(Translate_context* context)\n   source_location location = this->location();\n \n   Func_expression* func = this->fn_->func_expression();\n-  Bound_method_expression* bound_method = this->fn_->bound_method_expression();\n   Interface_field_reference_expression* interface_method =\n     this->fn_->interface_field_reference_expression();\n   const bool has_closure = func != NULL && func->closure() != NULL;\n-  const bool is_method = bound_method != NULL || interface_method != NULL;\n-  go_assert(!fntype->is_method() || is_method);\n+  const bool is_interface_method = interface_method != NULL;\n \n   int nargs;\n   tree* args;\n   if (this->args_ == NULL || this->args_->empty())\n     {\n-      nargs = is_method ? 1 : 0;\n+      nargs = is_interface_method ? 1 : 0;\n       args = nargs == 0 ? NULL : new tree[nargs];\n     }\n+  else if (fntype->parameters() == NULL || fntype->parameters()->empty())\n+    {\n+      // Passing a receiver parameter.\n+      go_assert(!is_interface_method\n+\t\t&& fntype->is_method()\n+\t\t&& this->args_->size() == 1);\n+      nargs = 1;\n+      args = new tree[nargs];\n+      args[0] = this->args_->front()->get_tree(context);\n+    }\n   else\n     {\n       const Typed_identifier_list* params = fntype->parameters();\n-      go_assert(params != NULL);\n \n       nargs = this->args_->size();\n-      int i = is_method ? 1 : 0;\n+      int i = is_interface_method ? 1 : 0;\n       nargs += i;\n       args = new tree[nargs];\n \n       Typed_identifier_list::const_iterator pp = params->begin();\n-      Expression_list::const_iterator pe;\n-      for (pe = this->args_->begin();\n-\t   pe != this->args_->end();\n-\t   ++pe, ++pp, ++i)\n+      Expression_list::const_iterator pe = this->args_->begin();\n+      if (!is_interface_method && fntype->is_method())\n+\t{\n+\t  args[i] = (*pe)->get_tree(context);\n+\t  ++pe;\n+\t  ++i;\n+\t}\n+      for (; pe != this->args_->end(); ++pe, ++pp, ++i)\n \t{\n \t  go_assert(pp != params->end());\n \t  tree arg_val = (*pe)->get_tree(context);\n@@ -9420,14 +9450,10 @@ Call_expression::do_get_tree(Translate_context* context)\n   tree fn;\n   if (has_closure)\n     fn = func->get_tree_without_closure(gogo);\n-  else if (!is_method)\n+  else if (!is_interface_method)\n     fn = this->fn_->get_tree(context);\n-  else if (bound_method != NULL)\n-    fn = this->bound_method_function(context, bound_method, &args[0]);\n-  else if (interface_method != NULL)\n-    fn = this->interface_method_function(context, interface_method, &args[0]);\n   else\n-    go_unreachable();\n+    fn = this->interface_method_function(context, interface_method, &args[0]);\n \n   if (fn == error_mark_node || TREE_TYPE(fn) == error_mark_node)\n     {"}, {"sha": "bb4f23e5810a88d0eda127a3f6b08e344b0b8895", "filename": "gcc/go/gofrontend/expressions.h", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1bbf7edba0f3518d91b6622761b634bda2ca8a29/gcc%2Fgo%2Fgofrontend%2Fexpressions.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1bbf7edba0f3518d91b6622761b634bda2ca8a29/gcc%2Fgo%2Fgofrontend%2Fexpressions.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fexpressions.h?ref=1bbf7edba0f3518d91b6622761b634bda2ca8a29", "patch": "@@ -1244,6 +1244,11 @@ class Call_expression : public Expression\n   is_varargs() const\n   { return this->is_varargs_; }\n \n+  // Note that varargs have already been lowered.\n+  void\n+  set_varargs_are_lowered()\n+  { this->varargs_are_lowered_ = true; }\n+\n   // Whether this call is being deferred.\n   bool\n   is_deferred() const\n@@ -1307,7 +1312,7 @@ class Call_expression : public Expression\n   { this->args_ = args; }\n \n   // Let a builtin expression lower varargs.\n-  Expression*\n+  void\n   lower_varargs(Gogo*, Named_object* function, Statement_inserter* inserter,\n \t\tType* varargs_type, size_t param_count);\n \n@@ -1323,9 +1328,6 @@ class Call_expression : public Expression\n   bool\n   check_argument_type(int, const Type*, const Type*, source_location, bool);\n \n-  tree\n-  bound_method_function(Translate_context*, Bound_method_expression*, tree*);\n-\n   tree\n   interface_method_function(Translate_context*,\n \t\t\t    Interface_field_reference_expression*,"}, {"sha": "e6462274dffafe05f349a74f0374f87d0422f7a1", "filename": "gcc/go/gofrontend/statements.cc", "status": "modified", "additions": 10, "deletions": 61, "changes": 71, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1bbf7edba0f3518d91b6622761b634bda2ca8a29/gcc%2Fgo%2Fgofrontend%2Fstatements.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1bbf7edba0f3518d91b6622761b634bda2ca8a29/gcc%2Fgo%2Fgofrontend%2Fstatements.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fstatements.cc?ref=1bbf7edba0f3518d91b6622761b634bda2ca8a29", "patch": "@@ -1858,8 +1858,7 @@ Thunk_statement::is_simple(Function_type* fntype) const\n   // If this calls something which is not a simple function, then we\n   // need a thunk.\n   Expression* fn = this->call_->call_expression()->fn();\n-  if (fn->bound_method_expression() != NULL\n-      || fn->interface_field_reference_expression() != NULL)\n+  if (fn->interface_field_reference_expression() != NULL)\n     return false;\n \n   return true;\n@@ -1914,14 +1913,6 @@ Thunk_statement::do_check_types(Gogo*)\n \tthis->report_error(\"expected call expression\");\n       return;\n     }\n-  Function_type* fntype = ce->get_function_type();\n-  if (fntype != NULL && fntype->is_method())\n-    {\n-      Expression* fn = ce->fn();\n-      if (fn->bound_method_expression() == NULL\n-\t  && fn->interface_field_reference_expression() == NULL)\n-\tthis->report_error(_(\"no object for method call\"));\n-    }\n }\n \n // The Traverse class used to find and simplify thunk statements.\n@@ -2005,8 +1996,7 @@ Thunk_statement::is_constant_function() const\n   Expression* fn = ce->fn();\n   if (fn->func_expression() != NULL)\n     return fn->func_expression()->closure() == NULL;\n-  if (fn->bound_method_expression() != NULL\n-      || fn->interface_field_reference_expression() != NULL)\n+  if (fn->interface_field_reference_expression() != NULL)\n     return true;\n   return false;\n }\n@@ -2048,7 +2038,6 @@ Thunk_statement::simplify_statement(Gogo* gogo, Named_object* function,\n     return false;\n \n   Expression* fn = ce->fn();\n-  Bound_method_expression* bound_method = fn->bound_method_expression();\n   Interface_field_reference_expression* interface_method =\n     fn->interface_field_reference_expression();\n \n@@ -2071,30 +2060,6 @@ Thunk_statement::simplify_statement(Gogo* gogo, Named_object* function,\n   if (interface_method != NULL)\n     vals->push_back(interface_method->expr());\n \n-  if (bound_method != NULL)\n-    {\n-      Expression* first_arg = bound_method->first_argument();\n-\n-      // We always pass a pointer when calling a method.\n-      if (first_arg->type()->points_to() == NULL)\n-\tfirst_arg = Expression::make_unary(OPERATOR_AND, first_arg, location);\n-\n-      // If we are calling a method which was inherited from an\n-      // embedded struct, and the method did not get a stub, then the\n-      // first type may be wrong.\n-      Type* fatype = bound_method->first_argument_type();\n-      if (fatype != NULL)\n-\t{\n-\t  if (fatype->points_to() == NULL)\n-\t    fatype = Type::make_pointer_type(fatype);\n-\t  Type* unsafe = Type::make_pointer_type(Type::make_void_type());\n-\t  first_arg = Expression::make_cast(unsafe, first_arg, location);\n-\t  first_arg = Expression::make_cast(fatype, first_arg, location);\n-\t}\n-\n-      vals->push_back(first_arg);\n-    }\n-\n   if (ce->args() != NULL)\n     {\n       for (Expression_list::const_iterator p = ce->args()->begin();\n@@ -2186,19 +2151,6 @@ Thunk_statement::build_struct(Function_type* fntype)\n       fields->push_back(Struct_field(tid));\n     }\n \n-  // If this is a method call, pass down the expression we are\n-  // calling.\n-  if (fn->bound_method_expression() != NULL)\n-    {\n-      go_assert(fntype->is_method());\n-      Type* rtype = fntype->receiver()->type();\n-      // We always pass the receiver as a pointer.\n-      if (rtype->points_to() == NULL)\n-\trtype = Type::make_pointer_type(rtype);\n-      Typed_identifier tid(\"receiver\", rtype, location);\n-      fields->push_back(Struct_field(tid));\n-    }\n-\n   // The predeclared recover function has no argument.  However, we\n   // add an argument when building recover thunks.  Handle that here.\n   if (ce->is_recover_call())\n@@ -2317,7 +2269,6 @@ Thunk_statement::build_thunk(Gogo* gogo, const std::string& thunk_name)\n   thunk_parameter = Expression::make_unary(OPERATOR_MULT, thunk_parameter,\n \t\t\t\t\t   location);\n \n-  Bound_method_expression* bound_method = ce->fn()->bound_method_expression();\n   Interface_field_reference_expression* interface_method =\n     ce->fn()->interface_field_reference_expression();\n \n@@ -2335,16 +2286,7 @@ Thunk_statement::build_thunk(Gogo* gogo, const std::string& thunk_name)\n       next_index = 1;\n     }\n \n-  if (bound_method != NULL)\n-    {\n-      go_assert(next_index == 0);\n-      Expression* r = Expression::make_field_reference(thunk_parameter, 0,\n-\t\t\t\t\t\t       location);\n-      func_to_call = Expression::make_bound_method(r, bound_method->method(),\n-\t\t\t\t\t\t   location);\n-      next_index = 1;\n-    }\n-  else if (interface_method != NULL)\n+  if (interface_method != NULL)\n     {\n       // The main program passes the interface object.\n       go_assert(next_index == 0);\n@@ -2389,6 +2331,13 @@ Thunk_statement::build_thunk(Gogo* gogo, const std::string& thunk_name)\n \n   Call_expression* call = Expression::make_call(func_to_call, call_params,\n \t\t\t\t\t\tfalse, location);\n+\n+  // This call expression was already lowered before entering the\n+  // thunk statement.  Don't try to lower varargs again, as that will\n+  // cause confusion for, e.g., method calls which already have a\n+  // receiver parameter.\n+  call->set_varargs_are_lowered();\n+\n   Statement* call_statement = Statement::make_statement(call);\n \n   gogo->add_statement(call_statement);"}]}