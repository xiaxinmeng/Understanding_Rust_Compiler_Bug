{"sha": "4d8f3296a0d32cf3c8b3956c8c0c778703b494c0", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NGQ4ZjMyOTZhMGQzMmNmM2M4YjM5NTZjOGMwYzc3ODcwM2I0OTRjMA==", "commit": {"author": {"name": "Ed Schonberg", "email": "schonberg@adacore.com", "date": "2013-04-11T12:43:28Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2013-04-11T12:43:28Z"}, "message": "sem_ch6.adb (Analyze_Null_Procedure): New subprogram...\n\n2013-04-11  Ed Schonberg  <schonberg@adacore.com>\n\n\t* sem_ch6.adb (Analyze_Null_Procedure): New subprogram, mostly\n\textracted from Analyze_Subprogram_Declaration, to handle null\n\tprocedure declarations that in ada 2012 can be completions of\n\tprevious declarations.\n\nFrom-SVN: r197779", "tree": {"sha": "afa2f7f70f138e9bda5405af1466541b34606096", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/afa2f7f70f138e9bda5405af1466541b34606096"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/4d8f3296a0d32cf3c8b3956c8c0c778703b494c0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4d8f3296a0d32cf3c8b3956c8c0c778703b494c0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4d8f3296a0d32cf3c8b3956c8c0c778703b494c0", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4d8f3296a0d32cf3c8b3956c8c0c778703b494c0/comments", "author": {"login": "Edschonberg", "id": 6352375, "node_id": "MDQ6VXNlcjYzNTIzNzU=", "avatar_url": "https://avatars.githubusercontent.com/u/6352375?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Edschonberg", "html_url": "https://github.com/Edschonberg", "followers_url": "https://api.github.com/users/Edschonberg/followers", "following_url": "https://api.github.com/users/Edschonberg/following{/other_user}", "gists_url": "https://api.github.com/users/Edschonberg/gists{/gist_id}", "starred_url": "https://api.github.com/users/Edschonberg/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Edschonberg/subscriptions", "organizations_url": "https://api.github.com/users/Edschonberg/orgs", "repos_url": "https://api.github.com/users/Edschonberg/repos", "events_url": "https://api.github.com/users/Edschonberg/events{/privacy}", "received_events_url": "https://api.github.com/users/Edschonberg/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "d45bc240af9aaa2e0b80b6c266f340b06138fcda", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d45bc240af9aaa2e0b80b6c266f340b06138fcda", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d45bc240af9aaa2e0b80b6c266f340b06138fcda"}], "stats": {"total": 238, "additions": 162, "deletions": 76}, "files": [{"sha": "3fe0913d26d7b954ef541b27b35cab64f8c60f3d", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4d8f3296a0d32cf3c8b3956c8c0c778703b494c0/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4d8f3296a0d32cf3c8b3956c8c0c778703b494c0/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=4d8f3296a0d32cf3c8b3956c8c0c778703b494c0", "patch": "@@ -1,3 +1,10 @@\n+2013-04-11  Ed Schonberg  <schonberg@adacore.com>\n+\n+\t* sem_ch6.adb (Analyze_Null_Procedure): New subprogram, mostly\n+\textracted from Analyze_Subprogram_Declaration, to handle null\n+\tprocedure declarations that in ada 2012 can be completions of\n+\tprevious declarations.\n+\n 2013-04-11  Hristian Kirtchev  <kirtchev@adacore.com>\n \n \t* sem_prag.adb (Entity_Of): Moved to Exp_Util."}, {"sha": "8ac527d687ae1397588f2b484094478b0f96e35d", "filename": "gcc/ada/sem_ch6.adb", "status": "modified", "additions": 155, "deletions": 76, "changes": 231, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4d8f3296a0d32cf3c8b3956c8c0c778703b494c0/gcc%2Fada%2Fsem_ch6.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4d8f3296a0d32cf3c8b3956c8c0c778703b494c0/gcc%2Fada%2Fsem_ch6.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch6.adb?ref=4d8f3296a0d32cf3c8b3956c8c0c778703b494c0", "patch": "@@ -101,6 +101,11 @@ package body Sem_Ch6 is\n    -- Local Subprograms --\n    -----------------------\n \n+   procedure Analyze_Null_Procedure\n+     (N             : Node_Id;\n+      Is_Completion : out Boolean);\n+   --  A null procedure can be a declaration or (Ada 2012) a completion.\n+\n    procedure Analyze_Return_Statement (N : Node_Id);\n    --  Common processing for simple and extended return statements\n \n@@ -1213,6 +1218,137 @@ package body Sem_Ch6 is\n       End_Generic;\n    end Analyze_Generic_Subprogram_Body;\n \n+   ----------------------------\n+   -- Analyze_Null_Procedure --\n+   ----------------------------\n+\n+   procedure Analyze_Null_Procedure\n+     (N             : Node_Id;\n+      Is_Completion : out Boolean)\n+   is\n+      Loc        : constant Source_Ptr := Sloc (N);\n+      Spec       : constant Node_Id    := Specification (N);\n+      Designator : Entity_Id;\n+      Form       : Node_Id;\n+      Null_Body  : Node_Id := Empty;\n+      Prev       : Entity_Id;\n+\n+   begin\n+      --  Capture the profile of the null procedure before analysis, for\n+      --  expansion at the freeze point and at each point of call. The body is\n+      --  used if the procedure has preconditions, or if it is a completion. In\n+      --  the first case the body is analyzed at the freeze point, in the other\n+      --  it replaces the null procedure declaration.\n+\n+      Null_Body :=\n+        Make_Subprogram_Body (Loc,\n+          Specification => New_Copy_Tree (Spec),\n+          Declarations => New_List,\n+          Handled_Statement_Sequence =>\n+            Make_Handled_Sequence_Of_Statements (Loc,\n+              Statements => New_List (Make_Null_Statement (Loc))));\n+\n+      --  Create new entities for body and formals\n+\n+      Set_Defining_Unit_Name (Specification (Null_Body),\n+        Make_Defining_Identifier (Loc, Chars (Defining_Entity (N))));\n+\n+      Form := First (Parameter_Specifications (Specification (Null_Body)));\n+      while Present (Form) loop\n+         Set_Defining_Identifier (Form,\n+           Make_Defining_Identifier (Loc, Chars (Defining_Identifier (Form))));\n+         Next (Form);\n+      end loop;\n+\n+      --  Determine whether the null procedure may be a completion of a generic\n+      --  suprogram, in which case we use the new null body as the completion\n+      --  and set minimal semantic information on the original declaration,\n+      --  which is rewritten as a null statement.\n+\n+      Prev := Current_Entity_In_Scope (Defining_Entity (Spec));\n+\n+      if Present (Prev) and then Is_Generic_Subprogram (Prev) then\n+         Insert_Before (N, Null_Body);\n+         Set_Ekind (Defining_Entity (N), Ekind (Prev));\n+         Set_Contract (Defining_Entity (N), Make_Contract (Loc));\n+\n+         Rewrite (N, Make_Null_Statement (Loc));\n+         Analyze_Generic_Subprogram_Body (Null_Body, Prev);\n+         Is_Completion := True;\n+         return;\n+\n+      else\n+\n+         --  Resolve the types of the formals now, because the freeze point\n+         --  may appear in a different context, e.g. an instantiation.\n+\n+         Form := First (Parameter_Specifications (Specification (Null_Body)));\n+         while Present (Form) loop\n+            if Nkind (Parameter_Type (Form)) /= N_Access_Definition then\n+               Find_Type (Parameter_Type (Form));\n+\n+            elsif\n+              No (Access_To_Subprogram_Definition (Parameter_Type (Form)))\n+            then\n+               Find_Type (Subtype_Mark (Parameter_Type (Form)));\n+\n+            else\n+               --  The case of a null procedure with a formal that is an\n+               --  access_to_subprogram type, and that is used as an actual\n+               --  in an instantiation is left to the enthusiastic reader.\n+\n+               null;\n+            end if;\n+\n+            Next (Form);\n+         end loop;\n+      end if;\n+\n+      --  If there are previous overloadable entities with the same name,\n+      --  check whether any of them is completed by the null procedure.\n+\n+      if Present (Prev) and then Is_Overloadable (Prev) then\n+         Designator := Analyze_Subprogram_Specification (Spec);\n+         Prev       := Find_Corresponding_Spec (N);\n+      end if;\n+\n+      if No (Prev) or else not Comes_From_Source (Prev) then\n+         Designator := Analyze_Subprogram_Specification (Spec);\n+         Set_Has_Completion (Designator);\n+\n+         --  Signal to caller that this is a procedure declaration\n+\n+         Is_Completion := False;\n+\n+         --  Null procedures are always inlined, but generic formal subprograms\n+         --  which appear as such in the internal instance of formal packages,\n+         --  need no completion and are not marked Inline.\n+\n+         if Expander_Active\n+           and then Nkind (N) /= N_Formal_Concrete_Subprogram_Declaration\n+         then\n+            Set_Corresponding_Body (N, Defining_Entity (Null_Body));\n+            Set_Body_To_Inline (N, Null_Body);\n+            Set_Is_Inlined (Designator);\n+         end if;\n+\n+      else\n+         --  The null procedure is a completion\n+\n+         Is_Completion := True;\n+\n+         if Expander_Active then\n+            Rewrite (N, Null_Body);\n+            Analyze (N);\n+\n+         else\n+            Designator := Analyze_Subprogram_Specification (Spec);\n+            Set_Has_Completion (Designator);\n+            Set_Has_Completion (Prev);\n+         end if;\n+      end if;\n+   end Analyze_Null_Procedure;\n+\n    -----------------------------\n    -- Analyze_Operator_Symbol --\n    -----------------------------\n@@ -3194,13 +3330,10 @@ package body Sem_Ch6 is\n    ------------------------------------\n \n    procedure Analyze_Subprogram_Declaration (N : Node_Id) is\n-      Loc        : constant Source_Ptr := Sloc (N);\n       Scop       : constant Entity_Id  := Current_Scope;\n       Designator : Entity_Id;\n-      Form       : Node_Id;\n-      Null_Body  : Node_Id := Empty;\n-\n-   --  Start of processing for Analyze_Subprogram_Declaration\n+      Is_Completion : Boolean;\n+      --  Indicates whether a null procedure declaration is a completion\n \n    begin\n       --  Null procedures are not allowed in SPARK\n@@ -3209,63 +3342,18 @@ package body Sem_Ch6 is\n         and then Null_Present (Specification (N))\n       then\n          Check_SPARK_Restriction (\"null procedure is not allowed\", N);\n-      end if;\n-\n-      --  For a null procedure, capture the profile before analysis, for\n-      --  expansion at the freeze point and at each point of call. The body\n-      --  will only be used if the procedure has preconditions. In that case\n-      --  the body is analyzed at the freeze point.\n-\n-      if Nkind (Specification (N)) = N_Procedure_Specification\n-        and then Null_Present (Specification (N))\n-        and then Expander_Active\n-      then\n-         Null_Body :=\n-           Make_Subprogram_Body (Loc,\n-             Specification =>\n-               New_Copy_Tree (Specification (N)),\n-             Declarations =>\n-               New_List,\n-             Handled_Statement_Sequence =>\n-               Make_Handled_Sequence_Of_Statements (Loc,\n-                 Statements => New_List (Make_Null_Statement (Loc))));\n-\n-         --  Create new entities for body and formals\n-\n-         Set_Defining_Unit_Name (Specification (Null_Body),\n-           Make_Defining_Identifier (Loc, Chars (Defining_Entity (N))));\n-\n-         Form := First (Parameter_Specifications (Specification (Null_Body)));\n-         while Present (Form) loop\n-            Set_Defining_Identifier (Form,\n-              Make_Defining_Identifier (Loc,\n-                Chars (Defining_Identifier (Form))));\n-\n-            --  Resolve the types of the formals now, because the freeze point\n-            --  may appear in a different context, e.g. an instantiation.\n-\n-            if Nkind (Parameter_Type (Form)) /= N_Access_Definition then\n-               Find_Type (Parameter_Type (Form));\n-\n-            elsif\n-              No (Access_To_Subprogram_Definition (Parameter_Type (Form)))\n-            then\n-               Find_Type (Subtype_Mark (Parameter_Type (Form)));\n \n-            else\n+         if Is_Protected_Type (Current_Scope) then\n+            Error_Msg_N (\"protected operation cannot be a null procedure\", N);\n+         end if;\n \n-               --  the case of a null procedure with a formal that is an\n-               --  access_to_subprogram type, and that is used as an actual\n-               --  in an instantiation is left to the enthusiastic reader.\n+         Analyze_Null_Procedure (N, Is_Completion);\n \n-               null;\n-            end if;\n+         if Is_Completion then\n \n-            Next (Form);\n-         end loop;\n+            --  The null procedure acts as a body, nothing further is needed.\n \n-         if Is_Protected_Type (Current_Scope) then\n-            Error_Msg_N (\"protected operation cannot be a null procedure\", N);\n+            return;\n          end if;\n       end if;\n \n@@ -3286,30 +3374,12 @@ package body Sem_Ch6 is\n          Indent;\n       end if;\n \n-      if Nkind (Specification (N)) = N_Procedure_Specification\n-        and then Null_Present (Specification (N))\n-      then\n-         Set_Has_Completion (Designator);\n-\n-         --  Null procedures are always inlined, but generic formal subprograms\n-         --  which appear as such in the internal instance of formal packages,\n-         --  need no completion and are not marked Inline.\n-\n-         if Present (Null_Body)\n-           and then Nkind (N) /= N_Formal_Concrete_Subprogram_Declaration\n-         then\n-            Set_Corresponding_Body (N, Defining_Entity (Null_Body));\n-            Set_Body_To_Inline (N, Null_Body);\n-            Set_Is_Inlined (Designator);\n-         end if;\n-      end if;\n-\n       Validate_RCI_Subprogram_Declaration (N);\n       New_Overloaded_Entity (Designator);\n       Check_Delayed_Subprogram (Designator);\n \n       --  If the type of the first formal of the current subprogram is a\n-      --  nongeneric tagged private type, mark the subprogram as being a\n+      --  non-generic tagged private type, mark the subprogram as being a\n       --  private primitive. Ditto if this is a function with controlling\n       --  result, and the return type is currently private. In both cases,\n       --  the type of the controlling argument or result must be in the\n@@ -8346,6 +8416,15 @@ package body Sem_Ch6 is\n                then\n                   null;\n \n+               --  For null procedures coming from source that are completions,\n+               --  analysis of the generated body will establish the link.\n+\n+               elsif Comes_From_Source (E)\n+                 and then Nkind (Spec) = N_Procedure_Specification\n+                 and then Null_Present (Spec)\n+               then\n+                  return E;\n+\n                elsif not Has_Completion (E) then\n                   if Nkind (N) /= N_Subprogram_Body_Stub then\n                      Set_Corresponding_Spec (N, E);"}]}