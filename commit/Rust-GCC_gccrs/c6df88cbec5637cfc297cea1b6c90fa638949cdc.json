{"sha": "c6df88cbec5637cfc297cea1b6c90fa638949cdc", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YzZkZjg4Y2JlYzU2MzdjZmMyOTdjZWExYjZjOTBmYTYzODk0OWNkYw==", "commit": {"author": {"name": "Mark Mitchell", "email": "mark@markmitchell.com", "date": "1999-01-19T10:32:33Z"}, "committer": {"name": "Mark Mitchell", "email": "mmitchel@gcc.gnu.org", "date": "1999-01-19T10:32:33Z"}, "message": "rtl.h (rtx_def): Update documentation.\n\n\t* rtl.h (rtx_def): Update documentation.\n\t(MEM_IN_STRUCT_P): Likewise.\n\t(MEM_SCALAR_P): New macro.\n\t(MEM_COPY_ATTRIBUTES): Likewise.\n\t(MEM_SET_IN_STRUCT_P): Likewise.\n\t* rtl.texi (MEM_SCALAR_P): Document.\n\t* alias.c (canon_rtx): Use MEM_COPY_ATTRIBUTES.\n\t(fixed_scalar_and_varying_struct_p): New function.  Use\n\tMEM_SCALAR_P rather than !MEM_IN_STRUCT_P.\n\t(aliases_everything_p): Likewise.\n\t(true_dependence): Use them.\n\t(write_dependence_p): New function, containing code common to\n\tanti_dependence and output_dependence.\n\t(anti_dependence): Use it.\n\t(output_dependence): Likewise.\n\t* calls.c (save_fixed_argument_area): Don't clear\n\tMEM_IN_STRUCT_P.\n\t(expand_call): Use MEM_SET_IN_STRUCT_P.\n\t(emit_library_call): Don't clear MEM_IN_STRUCT_P.\n\t(emit_library_call_value): Likewise.\n\t(store_one_arg): Use MEM_SET_IN_STRUCT_P.\n\t* combine.c (simplify_rtx): Use MEM_COPY_ATTRIBUTES.\n\t(make_extraction): Likewise.\n\t(simplify_shift_const): Likewise.\n\t(gen_lowpart_for_combine): Likewise.\n\t* cse.c (gen_lowpart_if_possible): Use MEM_COPY_ATTRIBUTES.\n\t* emit-rtl.c (operand_subword): Likewise.\n\t(change_address): Likewise.\n\t* explow.c (stabilize): Use MEM_COPY_ATTRIBUTES.\n\t* expr.c (protect_from_queue): Use MEM_COPY_ATTRIBUTES.\n\t(emit_group_store): Use MEM_SET_IN_STRUCT_P.\n\t(copy_blkmode_from_reg): Likewise.\n\t(store_field): Likewise.\n\t(expand_expr): Remove bogus guesswork setting MEM_IN_STRUCT_P\n\theuristically.  Use MEM_SET_IN_STRUCT_P.\n\t(get_memory_rtx): Likewise.\n\t* final.c (alter_subreg): Use MEM_COPY_ATTRIBUTES.\n\t* function.c (assign_stack_temp): Clear MEM_SCALAR_P and\n\tMEM_ALIAS_SET on newly returned MEMs.\n\t(assign_temp): Use MEM_SET_IN_STRUCT_P.\n\t(put_reg_into_stack): Likewise.\n\t(fixup_var_refs1): Use MEM_COPY_ATTRIBUTES.\n\t(gen_mem_addressof): Use MEM_SET_IN_STRUCT_P.\n\t(assign_parms): Likewise.\n\t(expand_function): Likewise.\n\t* integrate.c (expand_inline_function): Likewise.\n\t(copy_rtx_and_substitute): Use MEM_COPY_ATTRIBUTES.\n\t* loop.c (note_addr_stored): Remove check on MEM_IN_STRUCT_P.\n\t* optabs.c (gen_move_insn): Use MEM_COPY_ATTRIBUTES.\n\t* print-rtl.c (print_rtx): Print /f for frame_related.\n\t* recog.c (validate_replace_rtx_1): Use MEM_COPY_ATTRIBUTES.\n\t* reload1.c (reload): Copy MEM_SCALAR_P as well.\n\t* stmt.c (expand_decl): Use MEM_SET_IN_STRUCT_P.\n\t(expand_anon_union_decl): Use MEM_COPY_ATTRIBUTES.\n\t* varasm.c (make_decl_rtl): Use MEM_SET_IN_STRUCT_P.\n\t(output_constant_def): Likewise.\n\t* a29k.c (a29k_set_memflags_1): Take scalar_p.\n\tSet MEM_SCALAR_P.\n\t(a29k_set_memflags): Use it.\n\t* alpha.c (get_aligned_mem): Use MEM_COPY_ATTRIBUTES.\n\t* c4x.c (c4x_scan_for_ld): Likewise.\n\t* h8300.c (fix_bit_operand): Likewise.\n\t* m88k.c (legitimize_address): Likewise.\n\t(block_move_loop): Likewise.\n\t(block_move_no_loop): Likewise.\n\t(block_move_sequence): Likewise.\n\t(m88k_builtin_saveregs): Use MEM_SET_IN_STRUCT_P.\n\t* mips/abi64.h (SETUP_INCOMING_VARARGS): Likewise.\n\t* rs6000.c (expand_block_move_insn): Use MEM_COPY_ATTRIBUTES.\n\t* sh.c (sh_builtin_saveregs): Use MEM_SET_IN_STRUCT_P.\n\t* arm.h (arm_gen_load_multiple): Take scalar_p.\n\t(arm_store_load_multiple): Likewise.\n\t* arm.c (arm_gen_load_multiple): Likewise.\n\t(arm_gen_store_multiple): Likewise.\n\t(arm_gen_movstrqi): Treat MEM_SCALAR_P like MEM_IN_STRUCT_P.\n\nFrom-SVN: r24759", "tree": {"sha": "328681183508c4b77ec5e404cc6511cbcea7a38f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/328681183508c4b77ec5e404cc6511cbcea7a38f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c6df88cbec5637cfc297cea1b6c90fa638949cdc", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c6df88cbec5637cfc297cea1b6c90fa638949cdc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c6df88cbec5637cfc297cea1b6c90fa638949cdc", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c6df88cbec5637cfc297cea1b6c90fa638949cdc/comments", "author": null, "committer": null, "parents": [{"sha": "d8fccff5e042cba03f1256ba0274528894a277be", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d8fccff5e042cba03f1256ba0274528894a277be", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d8fccff5e042cba03f1256ba0274528894a277be"}], "stats": {"total": 528, "additions": 331, "deletions": 197}, "files": [{"sha": "d52632316256dbc021225222170bbc28278aec17", "filename": "gcc/ChangeLog", "status": "modified", "additions": 78, "deletions": 0, "changes": 78, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c6df88cbec5637cfc297cea1b6c90fa638949cdc/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c6df88cbec5637cfc297cea1b6c90fa638949cdc/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=c6df88cbec5637cfc297cea1b6c90fa638949cdc", "patch": "@@ -1,3 +1,81 @@\n+Tue Jan 19 10:24:53 1999  Mark Mitchell  <mark@markmitchell.com>\n+\n+\t* rtl.h (rtx_def): Update documentation.\n+\t(MEM_IN_STRUCT_P): Likewise.\n+\t(MEM_SCALAR_P): New macro.\n+\t(MEM_COPY_ATTRIBUTES): Likewise.\n+\t(MEM_SET_IN_STRUCT_P): Likewise.\n+\t* rtl.texi (MEM_SCALAR_P): Document.\n+\t* alias.c (canon_rtx): Use MEM_COPY_ATTRIBUTES.\n+\t(fixed_scalar_and_varying_struct_p): New function.  Use\n+\tMEM_SCALAR_P rather than !MEM_IN_STRUCT_P.\n+\t(aliases_everything_p): Likewise.\n+\t(true_dependence): Use them.\n+\t(write_dependence_p): New function, containing code common to\n+\tanti_dependence and output_dependence.\n+\t(anti_dependence): Use it.\n+\t(output_dependence): Likewise.\n+\t* calls.c (save_fixed_argument_area): Don't clear\n+\tMEM_IN_STRUCT_P. \n+\t(expand_call): Use MEM_SET_IN_STRUCT_P.\n+\t(emit_library_call): Don't clear MEM_IN_STRUCT_P.\n+\t(emit_library_call_value): Likewise.\n+\t(store_one_arg): Use MEM_SET_IN_STRUCT_P.\n+\t* combine.c (simplify_rtx): Use MEM_COPY_ATTRIBUTES.\n+\t(make_extraction): Likewise.\n+\t(simplify_shift_const): Likewise.\n+\t(gen_lowpart_for_combine): Likewise.\n+\t* cse.c (gen_lowpart_if_possible): Use MEM_COPY_ATTRIBUTES.\n+\t* emit-rtl.c (operand_subword): Likewise.\n+\t(change_address): Likewise.\n+\t* explow.c (stabilize): Use MEM_COPY_ATTRIBUTES.\n+\t* expr.c (protect_from_queue): Use MEM_COPY_ATTRIBUTES.\n+\t(emit_group_store): Use MEM_SET_IN_STRUCT_P.\n+\t(copy_blkmode_from_reg): Likewise.\n+\t(store_field): Likewise.\n+\t(expand_expr): Remove bogus guesswork setting MEM_IN_STRUCT_P\n+\theuristically.  Use MEM_SET_IN_STRUCT_P.\n+\t(get_memory_rtx): Likewise.\n+\t* final.c (alter_subreg): Use MEM_COPY_ATTRIBUTES.\n+\t* function.c (assign_stack_temp): Clear MEM_SCALAR_P and\n+\tMEM_ALIAS_SET on newly returned MEMs.\n+\t(assign_temp): Use MEM_SET_IN_STRUCT_P.\n+\t(put_reg_into_stack): Likewise.\n+\t(fixup_var_refs1): Use MEM_COPY_ATTRIBUTES.\n+\t(gen_mem_addressof): Use MEM_SET_IN_STRUCT_P.\n+\t(assign_parms): Likewise.\n+\t(expand_function): Likewise.\n+\t* integrate.c (expand_inline_function): Likewise.\n+\t(copy_rtx_and_substitute): Use MEM_COPY_ATTRIBUTES.\n+\t* loop.c (note_addr_stored): Remove check on MEM_IN_STRUCT_P.\n+\t* optabs.c (gen_move_insn): Use MEM_COPY_ATTRIBUTES.\n+\t* print-rtl.c (print_rtx): Print /f for frame_related.\n+\t* recog.c (validate_replace_rtx_1): Use MEM_COPY_ATTRIBUTES.\n+\t* reload1.c (reload): Copy MEM_SCALAR_P as well.\n+\t* stmt.c (expand_decl): Use MEM_SET_IN_STRUCT_P.\n+\t(expand_anon_union_decl): Use MEM_COPY_ATTRIBUTES.\n+\t* varasm.c (make_decl_rtl): Use MEM_SET_IN_STRUCT_P.\n+\t(output_constant_def): Likewise.\n+\t* a29k.c (a29k_set_memflags_1): Take scalar_p.\n+\tSet MEM_SCALAR_P.\n+\t(a29k_set_memflags): Use it.\n+\t* alpha.c (get_aligned_mem): Use MEM_COPY_ATTRIBUTES.\n+\t* c4x.c (c4x_scan_for_ld): Likewise.\n+\t* h8300.c (fix_bit_operand): Likewise.\n+\t* m88k.c (legitimize_address): Likewise.\n+\t(block_move_loop): Likewise.\n+\t(block_move_no_loop): Likewise.\n+\t(block_move_sequence): Likewise.\n+\t(m88k_builtin_saveregs): Use MEM_SET_IN_STRUCT_P.\n+\t* mips/abi64.h (SETUP_INCOMING_VARARGS): Likewise.\n+\t* rs6000.c (expand_block_move_insn): Use MEM_COPY_ATTRIBUTES.\n+\t* sh.c (sh_builtin_saveregs): Use MEM_SET_IN_STRUCT_P.\n+\t* arm.h (arm_gen_load_multiple): Take scalar_p.\n+\t(arm_store_load_multiple): Likewise.\n+\t* arm.c (arm_gen_load_multiple): Likewise.\n+\t(arm_gen_store_multiple): Likewise.\n+\t(arm_gen_movstrqi): Treat MEM_SCALAR_P like MEM_IN_STRUCT_P.\n+\t\n Tue Jan 19 12:30:37 EST 1999  Andrew MacLeod  <amacleod@cygnus.com>\n \n \t* optabs.c (emit_libcall_block): Add a REG_EH_REGION reg note to all"}, {"sha": "4897cde25c5fcfaf6fd39ceefd738d574004c30c", "filename": "gcc/alias.c", "status": "modified", "additions": 90, "deletions": 58, "changes": 148, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c6df88cbec5637cfc297cea1b6c90fa638949cdc/gcc%2Falias.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c6df88cbec5637cfc297cea1b6c90fa638949cdc/gcc%2Falias.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Falias.c?ref=c6df88cbec5637cfc297cea1b6c90fa638949cdc", "patch": "@@ -88,6 +88,9 @@ static int alias_set_compare            PROTO((splay_tree_key,\n static int insert_subset_children       PROTO((splay_tree_node,\n \t\t\t\t\t       void*));\n static alias_set_entry get_alias_set_entry PROTO((int));\n+static rtx fixed_scalar_and_varying_struct_p PROTO((rtx, rtx, int (*)(rtx)));\n+static int aliases_everything_p         PROTO((rtx));\n+static int write_dependence_p           PROTO((rtx, rtx, int));\n \n /* Set up all info needed to perform alias analysis on memory references.  */\n \n@@ -588,9 +591,8 @@ canon_rtx (x)\n       if (addr != XEXP (x, 0))\n \t{\n \t  rtx new = gen_rtx_MEM (GET_MODE (x), addr);\n-\t  MEM_VOLATILE_P (new) = MEM_VOLATILE_P (x);\n \t  RTX_UNCHANGING_P (new) = RTX_UNCHANGING_P (x);\n-\t  MEM_IN_STRUCT_P (new) = MEM_IN_STRUCT_P (x);\n+\t  MEM_COPY_ATTRIBUTES (new, x);\n \t  MEM_ALIAS_SET (new) = MEM_ALIAS_SET (x);\n \t  x = new;\n \t}\n@@ -1137,6 +1139,56 @@ read_dependence (mem, x)\n   return MEM_VOLATILE_P (x) && MEM_VOLATILE_P (mem);\n }\n \n+/* Returns MEM1 if and only if MEM1 is a scalar at a fixed address and\n+   MEM2 is a reference to a structure at a varying address, or returns\n+   MEM2 if vice versa.  Otherwise, returns NULL_RTX.  If a non-NULL\n+   value is returned MEM1 and MEM2 can never alias.  VARIES_P is used\n+   to decide whether or not an address may vary; it should return\n+   nozero whenever variation is possible.  */\n+\n+rtx\n+fixed_scalar_and_varying_struct_p (mem1, mem2, varies_p)\n+     rtx mem1;\n+     rtx mem2;\n+     int (*varies_p) PROTO((rtx));\n+{\n+  rtx mem1_addr = XEXP (mem1, 0);\n+  rtx mem2_addr = XEXP (mem2, 0);\n+  \n+  if (MEM_SCALAR_P (mem1) && MEM_IN_STRUCT_P (mem2) \n+      && !varies_p (mem1_addr) && varies_p (mem2_addr))\n+    /* MEM1 is a scalar at a fixed address; MEM2 is a struct at a\n+       varying address.  */\n+    return mem1;\n+\n+  if (MEM_IN_STRUCT_P (mem1) && MEM_SCALAR_P (mem2) \n+      && varies_p (mem1_addr) && !varies_p (mem2_addr))\n+    /* MEM2 is a scalar at a fixed address; MEM1 is a struct at a\n+       varying address.  */\n+    return mem2;\n+\n+  return NULL_RTX;\n+}\n+\n+/* Returns nonzero if something about the mode or address format MEM1\n+   indicates that it might well alias *anything*.  */\n+\n+int\n+aliases_everything_p (mem)\n+     rtx mem;\n+{\n+  if (GET_MODE (mem) == QImode)\n+    /* ANSI C says that a `char*' can point to anything.  */\n+    return 1;\n+\n+  if (GET_CODE (XEXP (mem, 0)) == AND)\n+    /* If the address is an AND, its very hard to know at what it is\n+       actually pointing.  */\n+    return 1;\n+    \n+  return 0;\n+}\n+\n /* True dependence: X is read after store in MEM takes place.  */\n \n int\n@@ -1177,48 +1229,41 @@ true_dependence (mem, mem_mode, x, varies)\n \t\t\t    SIZE_FOR_MODE (x), x_addr, 0))\n     return 0;\n \n-  /* If both references are struct references, or both are not, nothing\n-     is known about aliasing.\n-\n-     If either reference is QImode or BLKmode, ANSI C permits aliasing.\n-\n-     If both addresses are constant, or both are not, nothing is known\n-     about aliasing.  */\n-  if (MEM_IN_STRUCT_P (x) == MEM_IN_STRUCT_P (mem)\n-      || mem_mode == QImode || mem_mode == BLKmode\n-      || GET_MODE (x) == QImode || GET_MODE (x) == BLKmode\n-      || GET_CODE (x_addr) == AND || GET_CODE (mem_addr) == AND\n-      || varies (x_addr) == varies (mem_addr))\n+  if (aliases_everything_p (x))\n     return 1;\n \n-  /* One memory reference is to a constant address, one is not.\n-     One is to a structure, the other is not.\n+  /* We cannot use aliases_everyting_p to test MEM, since we must look\n+     at MEM_MODE, rather than GET_MODE (MEM).  */\n+  if (mem_mode == QImode || GET_CODE (mem_addr) == AND)\n+    return 1;\n \n-     If either memory reference is a variable structure the other is a\n-     fixed scalar and there is no aliasing.  */\n-  if ((MEM_IN_STRUCT_P (mem) && varies (mem_addr))\n-      || (MEM_IN_STRUCT_P (x) && varies (x_addr)))\n-    return 0;\n+  /* In true_dependence we also allow BLKmode to alias anything.  Why\n+     don't we do this in anti_dependence and output_dependence?  */\n+  if (mem_mode == BLKmode || GET_MODE (x) == BLKmode)\n+    return 1;\n \n-  return 1;\n+  return !fixed_scalar_and_varying_struct_p (mem, x, varies);\n }\n \n-/* Anti dependence: X is written after read in MEM takes place.  */\n+/* Returns non-zero if a write to X might alias a previous read from\n+   (or, if WRITEP is non-zero, a write to) MEM.  */\n \n int\n-anti_dependence (mem, x)\n+write_dependence_p (mem, x, writep)\n      rtx mem;\n      rtx x;\n+     int writep;\n {\n   rtx x_addr, mem_addr;\n+  rtx fixed_scalar;\n \n   if (MEM_VOLATILE_P (x) && MEM_VOLATILE_P (mem))\n     return 1;\n \n   /* If MEM is an unchanging read, then it can't possibly conflict with\n      the store to X, because there is at most one store to MEM, and it must\n      have occurred somewhere before MEM.  */\n-  if (RTX_UNCHANGING_P (mem))\n+  if (!writep && RTX_UNCHANGING_P (mem))\n     return 0;\n \n   if (! base_alias_check (XEXP (x, 0), XEXP (mem, 0), GET_MODE (x),\n@@ -1234,16 +1279,25 @@ anti_dependence (mem, x)\n   x_addr = XEXP (x, 0);\n   mem_addr = XEXP (mem, 0);\n \n-  return (memrefs_conflict_p (SIZE_FOR_MODE (mem), mem_addr,\n-\t\t\t      SIZE_FOR_MODE (x), x_addr, 0)\n-\t  && ! (MEM_IN_STRUCT_P (mem) && rtx_addr_varies_p (mem)\n-\t\t&& GET_MODE (mem) != QImode\n-\t\t&& GET_CODE (mem_addr) != AND\n-\t\t&& ! MEM_IN_STRUCT_P (x) && ! rtx_addr_varies_p (x))\n-\t  && ! (MEM_IN_STRUCT_P (x) && rtx_addr_varies_p (x)\n-\t\t&& GET_MODE (x) != QImode\n-\t\t&& GET_CODE (x_addr) != AND\n-\t\t&& ! MEM_IN_STRUCT_P (mem) && ! rtx_addr_varies_p (mem)));\n+  if (!memrefs_conflict_p (SIZE_FOR_MODE (mem), mem_addr,\n+\t\t\t   SIZE_FOR_MODE (x), x_addr, 0))\n+    return 0;\n+\n+  fixed_scalar \n+    = fixed_scalar_and_varying_struct_p (mem, x, rtx_addr_varies_p);\n+  \n+  return (!(fixed_scalar == mem && !aliases_everything_p (x))\n+\t  && !(fixed_scalar == x && !aliases_everything_p (mem)));\n+}\n+\n+/* Anti dependence: X is written after read in MEM takes place.  */\n+\n+int\n+anti_dependence (mem, x)\n+     rtx mem;\n+     rtx x;\n+{\n+  return write_dependence_p (mem, x, /*writep=*/0);\n }\n \n /* Output dependence: X is written after store in MEM takes place.  */\n@@ -1253,29 +1307,7 @@ output_dependence (mem, x)\n      register rtx mem;\n      register rtx x;\n {\n-  if (MEM_VOLATILE_P (x) && MEM_VOLATILE_P (mem))\n-    return 1;\n-\n-  if (! base_alias_check (XEXP (x, 0), XEXP (mem, 0), GET_MODE (x),\n-\t\t\t  GET_MODE (mem)))\n-    return 0;\n-\n-  x = canon_rtx (x);\n-  mem = canon_rtx (mem);\n-\n-  if (DIFFERENT_ALIAS_SETS_P (x, mem))\n-    return 0;\n-\n-  return (memrefs_conflict_p (SIZE_FOR_MODE (mem), XEXP (mem, 0),\n-\t\t\t      SIZE_FOR_MODE (x), XEXP (x, 0), 0)\n-\t  && ! (MEM_IN_STRUCT_P (mem) && rtx_addr_varies_p (mem)\n-\t\t&& GET_MODE (mem) != QImode\n-\t\t&& GET_CODE (XEXP (mem, 0)) != AND\n-\t\t&& ! MEM_IN_STRUCT_P (x) && ! rtx_addr_varies_p (x))\n-\t  && ! (MEM_IN_STRUCT_P (x) && rtx_addr_varies_p (x)\n-\t\t&& GET_MODE (x) != QImode\n-\t\t&& GET_CODE (XEXP (x, 0)) != AND\n-\t\t&& ! MEM_IN_STRUCT_P (mem) && ! rtx_addr_varies_p (mem)));\n+  return write_dependence_p (mem, x, /*writep=*/1);\n }\n \n "}, {"sha": "751e9a5b8a09631f323e820bd8cf3971a13c2765", "filename": "gcc/calls.c", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c6df88cbec5637cfc297cea1b6c90fa638949cdc/gcc%2Fcalls.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c6df88cbec5637cfc297cea1b6c90fa638949cdc/gcc%2Fcalls.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcalls.c?ref=c6df88cbec5637cfc297cea1b6c90fa638949cdc", "patch": "@@ -705,7 +705,6 @@ save_fixed_argument_area (reg_parm_stack_space, argblock,\n       if (save_mode == BLKmode)\n \t{\n \t  save_area = assign_stack_temp (BLKmode, num_to_save, 0);\n-\t  MEM_IN_STRUCT_P (save_area) = 0;\n \t  emit_block_move (validize_mem (save_area), stack_area,\n \t\t\t   GEN_INT (num_to_save),\n \t\t\t   PARM_BOUNDARY / BITS_PER_UNIT);\n@@ -1386,7 +1385,7 @@ expand_call (exp, target, ignore)\n \t\t  copy = assign_stack_temp (TYPE_MODE (type), size, 0);\n \t\t}\n \n-\t      MEM_IN_STRUCT_P (copy) = AGGREGATE_TYPE_P (type);\n+\t      MEM_SET_IN_STRUCT_P (copy, AGGREGATE_TYPE_P (type));\n \n \t      store_expr (args[i].tree_value, copy, 0);\n \t      is_const = 0;\n@@ -1848,8 +1847,9 @@ expand_call (exp, target, ignore)\n \n \t  addr = plus_constant (addr, arg_offset);\n \t  args[i].stack = gen_rtx_MEM (args[i].mode, addr);\n-\t  MEM_IN_STRUCT_P (args[i].stack)\n-\t    = AGGREGATE_TYPE_P (TREE_TYPE (args[i].tree_value));\n+\t  MEM_SET_IN_STRUCT_P \n+\t    (args[i].stack,\n+\t     AGGREGATE_TYPE_P (TREE_TYPE (args[i].tree_value)));\n \n \t  if (GET_CODE (slot_offset) == CONST_INT)\n \t    addr = plus_constant (arg_reg, INTVAL (slot_offset));\n@@ -2186,7 +2186,8 @@ expand_call (exp, target, ignore)\n \t  target = gen_rtx_MEM (TYPE_MODE (TREE_TYPE (exp)),\n \t\t\t\tmemory_address (TYPE_MODE (TREE_TYPE (exp)),\n \t\t\t\t\t\tstructure_value_addr));\n-\t  MEM_IN_STRUCT_P (target) = AGGREGATE_TYPE_P (TREE_TYPE (exp));\n+\t  MEM_SET_IN_STRUCT_P (target,\n+\t\t\t       AGGREGATE_TYPE_P (TREE_TYPE (exp)));\n \t}\n     }\n   else if (pcc_struct_value)\n@@ -2196,7 +2197,7 @@ expand_call (exp, target, ignore)\n \t never use this value more than once in one expression.  */\n       target = gen_rtx_MEM (TYPE_MODE (TREE_TYPE (exp)),\n \t\t\t    copy_to_reg (valreg));\n-      MEM_IN_STRUCT_P (target) = AGGREGATE_TYPE_P (TREE_TYPE (exp));\n+      MEM_SET_IN_STRUCT_P (target, AGGREGATE_TYPE_P (TREE_TYPE (exp)));\n     }\n   /* Handle calls that return values in multiple non-contiguous locations.\n      The Irix 6 ABI has examples of this.  */\n@@ -2207,7 +2208,7 @@ expand_call (exp, target, ignore)\n       if (target == 0)\n \t{\n \t  target = assign_stack_temp (TYPE_MODE (TREE_TYPE (exp)), bytes, 0);\n-\t  MEM_IN_STRUCT_P (target) = AGGREGATE_TYPE_P (TREE_TYPE (exp));\n+\t  MEM_SET_IN_STRUCT_P (target, AGGREGATE_TYPE_P (TREE_TYPE (exp)));\n \t  preserve_temp_slots (target);\n \t}\n \n@@ -2623,7 +2624,6 @@ emit_library_call VPROTO((rtx orgfun, int no_queue, enum machine_mode outmode,\n       if (save_mode == BLKmode)\n \t{\n \t  save_area = assign_stack_temp (BLKmode, num_to_save, 0);\n-\t  MEM_IN_STRUCT_P (save_area) = 0;\n \t  emit_block_move (validize_mem (save_area), stack_area,\n \t\t\t   GEN_INT (num_to_save),\n \t\t\t   PARM_BOUNDARY / BITS_PER_UNIT);\n@@ -3187,7 +3187,6 @@ emit_library_call_value VPROTO((rtx orgfun, rtx value, int no_queue,\n       if (save_mode == BLKmode)\n \t{\n \t  save_area = assign_stack_temp (BLKmode, num_to_save, 0);\n-\t  MEM_IN_STRUCT_P (save_area) = 0;\n \t  emit_block_move (validize_mem (save_area), stack_area,\n \t\t\t   GEN_INT (num_to_save),\n \t\t\t   PARM_BOUNDARY / BITS_PER_UNIT);\n@@ -3527,8 +3526,9 @@ store_one_arg (arg, argblock, may_be_alloca, variable_size,\n \t    {\n \t      arg->save_area = assign_stack_temp (BLKmode,\n \t\t\t\t\t\t  arg->size.constant, 0);\n-\t      MEM_IN_STRUCT_P (arg->save_area)\n-\t\t= AGGREGATE_TYPE_P (TREE_TYPE (arg->tree_value));\n+\t      MEM_SET_IN_STRUCT_P (arg->save_area,\n+\t\t\t\t   AGGREGATE_TYPE_P (TREE_TYPE\n+\t\t\t\t\t\t     (arg->tree_value))); \n \t      preserve_temp_slots (arg->save_area);\n \t      emit_block_move (validize_mem (arg->save_area), stack_area,\n \t\t\t       GEN_INT (arg->size.constant),"}, {"sha": "d0e863c22a1466ebf2bd49fe5698cbdca805105a", "filename": "gcc/combine.c", "status": "modified", "additions": 5, "deletions": 10, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c6df88cbec5637cfc297cea1b6c90fa638949cdc/gcc%2Fcombine.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c6df88cbec5637cfc297cea1b6c90fa638949cdc/gcc%2Fcombine.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcombine.c?ref=c6df88cbec5637cfc297cea1b6c90fa638949cdc", "patch": "@@ -3502,9 +3502,8 @@ simplify_rtx (x, op0_mode, last, in_dest)\n \t\t\t   plus_constant (XEXP (inner, 0),\n \t\t\t\t\t  (SUBREG_WORD (x) * UNITS_PER_WORD\n \t\t\t\t\t   + endian_offset)));\n-\t  MEM_VOLATILE_P (x) = MEM_VOLATILE_P (inner);\n \t  RTX_UNCHANGING_P (x) = RTX_UNCHANGING_P (inner);\n-\t  MEM_IN_STRUCT_P (x) = MEM_IN_STRUCT_P (inner);\n+\t  MEM_COPY_ATTRIBUTES (x, inner);\n \t  return x;\n \t}\n \n@@ -5596,8 +5595,7 @@ make_extraction (mode, inner, pos, pos_rtx, len,\n \n \t  new = gen_rtx_MEM (tmode, plus_constant (XEXP (inner, 0), offset));\n \t  RTX_UNCHANGING_P (new) = RTX_UNCHANGING_P (inner);\n-\t  MEM_VOLATILE_P (new) = MEM_VOLATILE_P (inner);\n-\t  MEM_IN_STRUCT_P (new) = MEM_IN_STRUCT_P (inner);\n+\t  MEM_COPY_ATTRIBUTES (new, inner);\n \t}\n       else if (GET_CODE (inner) == REG)\n \t{\n@@ -5789,8 +5787,7 @@ make_extraction (mode, inner, pos, pos_rtx, len,\n \t  rtx newmem = gen_rtx_MEM (wanted_inner_mode,\n \t\t\t\t    plus_constant (XEXP (inner, 0), offset));\n \t  RTX_UNCHANGING_P (newmem) = RTX_UNCHANGING_P (inner);\n-\t  MEM_VOLATILE_P (newmem) = MEM_VOLATILE_P (inner);\n-\t  MEM_IN_STRUCT_P (newmem) = MEM_IN_STRUCT_P (inner);\n+\t  MEM_COPY_ATTRIBUTES (newmem, inner);\n \t  inner = newmem;\n \t}\n     }\n@@ -8502,8 +8499,7 @@ simplify_shift_const (x, code, result_mode, varop, count)\n \t\t\t\t   plus_constant (XEXP (varop, 0),\n \t\t\t\t\t\t  count / BITS_PER_UNIT));\n \t      RTX_UNCHANGING_P (new) = RTX_UNCHANGING_P (varop);\n-\t      MEM_VOLATILE_P (new) = MEM_VOLATILE_P (varop);\n-\t      MEM_IN_STRUCT_P (new) = MEM_IN_STRUCT_P (varop);\n+\t      MEM_COPY_ATTRIBUTES (new, varop);\n \t      varop = gen_rtx_combine (code == ASHIFTRT ? SIGN_EXTEND\n \t\t\t\t       : ZERO_EXTEND, mode, new);\n \t      count = 0;\n@@ -9262,8 +9258,7 @@ gen_lowpart_for_combine (mode, x)\n \t}\n       new = gen_rtx_MEM (mode, plus_constant (XEXP (x, 0), offset));\n       RTX_UNCHANGING_P (new) = RTX_UNCHANGING_P (x);\n-      MEM_VOLATILE_P (new) = MEM_VOLATILE_P (x);\n-      MEM_IN_STRUCT_P (new) = MEM_IN_STRUCT_P (x);\n+      MEM_COPY_ATTRIBUTES (new, x);\n       return new;\n     }\n "}, {"sha": "395a6ff8339c61f3d6e9a12a75536f7e2ae1bb3e", "filename": "gcc/config/a29k/a29k.c", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c6df88cbec5637cfc297cea1b6c90fa638949cdc/gcc%2Fconfig%2Fa29k%2Fa29k.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c6df88cbec5637cfc297cea1b6c90fa638949cdc/gcc%2Fconfig%2Fa29k%2Fa29k.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fa29k%2Fa29k.c?ref=c6df88cbec5637cfc297cea1b6c90fa638949cdc", "patch": "@@ -480,9 +480,9 @@ a29k_get_reloaded_address (op)\n    found in part of X.  */\n \n static void\n-a29k_set_memflags_1 (x, in_struct_p, volatile_p, unchanging_p)\n+a29k_set_memflags_1 (x, in_struct_p, scalar_p, volatile_p, unchanging_p)\n      rtx x;\n-     int in_struct_p, volatile_p, unchanging_p;\n+     int in_struct_p, scalar_p, volatile_p, unchanging_p;\n {\n   int i;\n \n@@ -508,6 +508,7 @@ a29k_set_memflags_1 (x, in_struct_p, volatile_p, unchanging_p)\n \n     case MEM:\n       MEM_IN_STRUCT_P (x) = in_struct_p;\n+      MEM_SCALAR_P (x) = scalar_p;\n       MEM_VOLATILE_P (x) = volatile_p;\n       RTX_UNCHANGING_P (x) = unchanging_p;\n       break;\n@@ -528,14 +529,15 @@ a29k_set_memflags (insn, ref)\n   /* Note that it is always safe to get these flags, though they won't\n      be what we think if REF is not a MEM.  */\n   int in_struct_p = MEM_IN_STRUCT_P (ref);\n+  int scalar_p = MEM_IN_SCALAR_P (ref);\n   int volatile_p = MEM_VOLATILE_P (ref);\n   int unchanging_p = RTX_UNCHANGING_P (ref);\n \n   if (GET_CODE (ref) != MEM\n       || (! in_struct_p && ! volatile_p && ! unchanging_p))\n     return;\n \n-  a29k_set_memflags_1 (insn, in_struct_p, volatile_p, unchanging_p);\n+  a29k_set_memflags_1 (insn, in_struct_p, scalar_p, volatile_p, unchanging_p);\n }\n \f\n /* Return 1 if OP is a comparison operator that we have in floating-point.  */"}, {"sha": "970f1d6f6469915b951ea73358a880b66e88c293", "filename": "gcc/config/alpha/alpha.c", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c6df88cbec5637cfc297cea1b6c90fa638949cdc/gcc%2Fconfig%2Falpha%2Falpha.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c6df88cbec5637cfc297cea1b6c90fa638949cdc/gcc%2Fconfig%2Falpha%2Falpha.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Falpha%2Falpha.c?ref=c6df88cbec5637cfc297cea1b6c90fa638949cdc", "patch": "@@ -890,8 +890,7 @@ get_aligned_mem (ref, paligned_mem, pbitnum)\n     offset += INTVAL (XEXP (base, 1)), base = XEXP (base, 0);\n \n   *paligned_mem = gen_rtx_MEM (SImode, plus_constant (base, offset & ~3));\n-  MEM_IN_STRUCT_P (*paligned_mem) = MEM_IN_STRUCT_P (ref);\n-  MEM_VOLATILE_P (*paligned_mem) = MEM_VOLATILE_P (ref);\n+  MEM_COPY_ATTRIBUTES (*paligned_mem, ref);\n   RTX_UNCHANGING_P (*paligned_mem) = RTX_UNCHANGING_P (ref);\n \n   /* Sadly, we cannot use alias sets here because we may overlap other"}, {"sha": "96ade94d82f48c7d0e57f95622512e515f1acb42", "filename": "gcc/config/arm/arm.c", "status": "modified", "additions": 23, "deletions": 7, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c6df88cbec5637cfc297cea1b6c90fa638949cdc/gcc%2Fconfig%2Farm%2Farm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c6df88cbec5637cfc297cea1b6c90fa638949cdc/gcc%2Fconfig%2Farm%2Farm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.c?ref=c6df88cbec5637cfc297cea1b6c90fa638949cdc", "patch": "@@ -2846,14 +2846,15 @@ arm_naked_function_p (func)\n \n rtx\n arm_gen_load_multiple (base_regno, count, from, up, write_back, unchanging_p,\n-\t\t       in_struct_p)\n+\t\t       in_struct_p, scalar_p)\n      int base_regno;\n      int count;\n      rtx from;\n      int up;\n      int write_back;\n      int unchanging_p;\n      int in_struct_p;\n+     int scalar_p;\n {\n   int i = 0, j;\n   rtx result;\n@@ -2876,7 +2877,7 @@ arm_gen_load_multiple (base_regno, count, from, up, write_back, unchanging_p,\n       mem = gen_rtx (MEM, SImode, plus_constant (from, j * 4 * sign));\n       RTX_UNCHANGING_P (mem) = unchanging_p;\n       MEM_IN_STRUCT_P (mem) = in_struct_p;\n-\n+      MEM_SCALAR_P (mem) = scalar_p;\n       XVECEXP (result, 0, i) = gen_rtx (SET, VOIDmode,\n \t\t\t\t\tgen_rtx (REG, SImode, base_regno + j),\n \t\t\t\t\tmem);\n@@ -2890,14 +2891,15 @@ arm_gen_load_multiple (base_regno, count, from, up, write_back, unchanging_p,\n \n rtx\n arm_gen_store_multiple (base_regno, count, to, up, write_back, unchanging_p,\n-\t\t\tin_struct_p)\n+\t\t\tin_struct_p, scalar_p)\n      int base_regno;\n      int count;\n      rtx to;\n      int up;\n      int write_back;\n      int unchanging_p;\n      int in_struct_p;\n+     int scalar_p;\n {\n   int i = 0, j;\n   rtx result;\n@@ -2920,6 +2922,7 @@ arm_gen_store_multiple (base_regno, count, to, up, write_back, unchanging_p,\n       mem = gen_rtx (MEM, SImode, plus_constant (to, j * 4 * sign));\n       RTX_UNCHANGING_P (mem) = unchanging_p;\n       MEM_IN_STRUCT_P (mem) = in_struct_p;\n+      MEM_SCALAR_P (mem) = scalar_p;\n \n       XVECEXP (result, 0, i) = gen_rtx (SET, VOIDmode, mem,\n \t\t\t\t\tgen_rtx (REG, SImode, base_regno + j));\n@@ -2942,6 +2945,7 @@ arm_gen_movstrqi (operands)\n   rtx part_bytes_reg = NULL;\n   rtx mem;\n   int dst_unchanging_p, dst_in_struct_p, src_unchanging_p, src_in_struct_p;\n+  int dst_scalar_p, src_scalar_p;\n \n   if (GET_CODE (operands[2]) != CONST_INT\n       || GET_CODE (operands[3]) != CONST_INT\n@@ -2954,8 +2958,10 @@ arm_gen_movstrqi (operands)\n \n   dst_unchanging_p = RTX_UNCHANGING_P (operands[0]);\n   dst_in_struct_p = MEM_IN_STRUCT_P (operands[0]);\n+  dst_scalar_p = MEM_SCALAR_P (operands[0]);\n   src_unchanging_p = RTX_UNCHANGING_P (operands[1]);\n   src_in_struct_p = MEM_IN_STRUCT_P (operands[1]);\n+  src_scalar_p = MEM_SCALAR_P (operands[1]);\n \n   fin_dst = dst = copy_to_mode_reg (SImode, st_dst);\n   fin_src = src = copy_to_mode_reg (SImode, st_src);\n@@ -2971,30 +2977,35 @@ arm_gen_movstrqi (operands)\n     {\n       if (in_words_to_go > 4)\n \temit_insn (arm_gen_load_multiple (0, 4, src, TRUE, TRUE,\n-\t\t\t\t\t  src_unchanging_p, src_in_struct_p));\n+\t\t\t\t\t  src_unchanging_p,\n+\t\t\t\t\t  src_in_struct_p,\n+\t\t\t\t\t  src_scalar_p));\n       else\n \temit_insn (arm_gen_load_multiple (0, in_words_to_go, src, TRUE, \n \t\t\t\t\t  FALSE, src_unchanging_p,\n-\t\t\t\t\t  src_in_struct_p));\n+\t\t\t\t\t  src_in_struct_p, src_scalar_p));\n \n       if (out_words_to_go)\n \t{\n \t  if (out_words_to_go > 4)\n \t    emit_insn (arm_gen_store_multiple (0, 4, dst, TRUE, TRUE,\n \t\t\t\t\t       dst_unchanging_p,\n-\t\t\t\t\t       dst_in_struct_p));\n+\t\t\t\t\t       dst_in_struct_p,\n+\t\t\t\t\t       dst_scalar_p));\n \t  else if (out_words_to_go != 1)\n \t    emit_insn (arm_gen_store_multiple (0, out_words_to_go,\n \t\t\t\t\t       dst, TRUE, \n \t\t\t\t\t       (last_bytes == 0\n \t\t\t\t\t\t? FALSE : TRUE),\n \t\t\t\t\t       dst_unchanging_p,\n-\t\t\t\t\t       dst_in_struct_p));\n+\t\t\t\t\t       dst_in_struct_p,\n+\t\t\t\t\t       dst_scalar_p));\n \t  else\n \t    {\n \t      mem = gen_rtx (MEM, SImode, dst);\n \t      RTX_UNCHANGING_P (mem) = dst_unchanging_p;\n \t      MEM_IN_STRUCT_P (mem) = dst_in_struct_p;\n+\t      MEM_SCALAR_P (mem) = dst_scalar_p;\n \t      emit_move_insn (mem, gen_rtx (REG, SImode, 0));\n \t      if (last_bytes != 0)\n \t\temit_insn (gen_addsi3 (dst, dst, GEN_INT (4)));\n@@ -3013,12 +3024,14 @@ arm_gen_movstrqi (operands)\n     mem = gen_rtx (MEM, SImode, src);\n     RTX_UNCHANGING_P (mem) = src_unchanging_p;\n     MEM_IN_STRUCT_P (mem) = src_in_struct_p;\n+    MEM_SCALAR_P (mem) = src_scalar_p;\n     emit_move_insn (sreg = gen_reg_rtx (SImode), mem);\n     emit_move_insn (fin_src = gen_reg_rtx (SImode), plus_constant (src, 4));\n \n     mem = gen_rtx (MEM, SImode, dst);\n     RTX_UNCHANGING_P (mem) = dst_unchanging_p;\n     MEM_IN_STRUCT_P (mem) = dst_in_struct_p;\n+    MEM_SCALAR_P (mem) = dst_scalar_p;\n     emit_move_insn (mem, sreg);\n     emit_move_insn (fin_dst = gen_reg_rtx (SImode), plus_constant (dst, 4));\n     in_words_to_go--;\n@@ -3035,6 +3048,7 @@ arm_gen_movstrqi (operands)\n       mem = gen_rtx (MEM, SImode, src);\n       RTX_UNCHANGING_P (mem) = src_unchanging_p;\n       MEM_IN_STRUCT_P (mem) = src_in_struct_p;\n+      MEM_SCALAR_P (mem) = src_scalar_p;\n       part_bytes_reg = copy_to_mode_reg (SImode, mem);\n     }\n \n@@ -3055,6 +3069,7 @@ arm_gen_movstrqi (operands)\n \t  mem = gen_rtx (MEM, QImode, plus_constant (dst, last_bytes - 1));\n \t  RTX_UNCHANGING_P (mem) = dst_unchanging_p;\n \t  MEM_IN_STRUCT_P (mem) = dst_in_struct_p;\n+\t  MEM_SCALAR_P (mem) = dst_scalar_p;\n \t  emit_move_insn (mem, gen_rtx (SUBREG, QImode, part_bytes_reg, 0));\n \t  if (--last_bytes)\n \t    {\n@@ -3075,6 +3090,7 @@ arm_gen_movstrqi (operands)\n \t  mem = gen_rtx (MEM, QImode, dst);\n \t  RTX_UNCHANGING_P (mem) = dst_unchanging_p;\n \t  MEM_IN_STRUCT_P (mem) = dst_in_struct_p;\n+\t  MEM_SCALAR_P (mem) = dst_scalar_p;\n \t  emit_move_insn (mem, gen_rtx (SUBREG, QImode, part_bytes_reg, 0));\n \t  if (--last_bytes)\n \t    {"}, {"sha": "a85c75c652c45f265640b8b0527592249c845619", "filename": "gcc/config/arm/arm.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c6df88cbec5637cfc297cea1b6c90fa638949cdc/gcc%2Fconfig%2Farm%2Farm.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c6df88cbec5637cfc297cea1b6c90fa638949cdc/gcc%2Fconfig%2Farm%2Farm.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.h?ref=c6df88cbec5637cfc297cea1b6c90fa638949cdc", "patch": "@@ -2113,9 +2113,9 @@ int arm_valid_machine_decl_attribute (/* union tree_node *, union tree_node *,\n \t\t\t\t\t union tree_node *,\n \t\t\t\t\t union tree_node * */);\n struct rtx_def *arm_gen_load_multiple (/* int, int, struct rtx_def *, \n-\t\t\t\t\t  int, int, int, int */);\n+\t\t\t\t\t  int, int, int, int, int */);\n struct rtx_def *arm_gen_store_multiple (/* int, int, struct rtx_def *,\n-\t\t\t\t\t   int, int, int, int */);\n+\t\t\t\t\t   int, int, int, int, int */);\n int arm_gen_movstrqi (/* struct rtx_def ** */);\n struct rtx_def *gen_rotated_half_load (/* struct rtx_def * */);\n enum machine_mode arm_select_cc_mode (/* enum rtx_code, struct rtx_def *,"}, {"sha": "abbfba1ba62f9956b11ab5dce562ee6f67dd4ae2", "filename": "gcc/config/c4x/c4x.c", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c6df88cbec5637cfc297cea1b6c90fa638949cdc/gcc%2Fconfig%2Fc4x%2Fc4x.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c6df88cbec5637cfc297cea1b6c90fa638949cdc/gcc%2Fconfig%2Fc4x%2Fc4x.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fc4x%2Fc4x.c?ref=c6df88cbec5637cfc297cea1b6c90fa638949cdc", "patch": "@@ -1898,9 +1898,8 @@ c4x_scan_for_ldp (newop, insn, operand0)\n \t\t\t\t\t      op0));\n \n \t  /* Use change_address?  */\n-\t  MEM_VOLATILE_P (*newop) = MEM_VOLATILE_P (operand);\n \t  RTX_UNCHANGING_P (*newop) = RTX_UNCHANGING_P (operand);\n-\t  MEM_IN_STRUCT_P (*newop) = MEM_IN_STRUCT_P (operand);\n+\t  MEM_COPY_ATTRIBUTES (*newop, operand);\n \t  break;\n \n \tdefault:"}, {"sha": "0870ede5daa7200eea94d8e4ac693bd659e01fd5", "filename": "gcc/config/h8300/h8300.c", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c6df88cbec5637cfc297cea1b6c90fa638949cdc/gcc%2Fconfig%2Fh8300%2Fh8300.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c6df88cbec5637cfc297cea1b6c90fa638949cdc/gcc%2Fconfig%2Fh8300%2Fh8300.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fh8300%2Fh8300.c?ref=c6df88cbec5637cfc297cea1b6c90fa638949cdc", "patch": "@@ -2792,8 +2792,7 @@ fix_bit_operand (operands, what, type)\n \t      mem = gen_rtx (MEM, GET_MODE (operands[0]),\n \t\t\t   copy_to_mode_reg (Pmode, XEXP (operands[0], 0)));\n \t      RTX_UNCHANGING_P (mem) = RTX_UNCHANGING_P (operands[0]);\n-\t      MEM_IN_STRUCT_P (mem) = MEM_IN_STRUCT_P (operands[0]);\n-\t      MEM_VOLATILE_P (mem) = MEM_VOLATILE_P (operands[0]);\n+\t      MEM_COPY_ATTRIBUTES (mem, operands[0]);\n \t      operands[0] = mem;\n \t    }\n \n@@ -2803,8 +2802,7 @@ fix_bit_operand (operands, what, type)\n \t      mem = gen_rtx (MEM, GET_MODE (operands[1]),\n \t\t\t   copy_to_mode_reg (Pmode, XEXP (operands[1], 0)));\n \t      RTX_UNCHANGING_P (mem) = RTX_UNCHANGING_P (operands[1]);\n-\t      MEM_IN_STRUCT_P (mem) = MEM_IN_STRUCT_P (operands[1]);\n-\t      MEM_VOLATILE_P (mem) = MEM_VOLATILE_P (operands[1]);\n+\t      MEM_COPY_ATTRIBUTES (mem, operands[0]);\n \t      operands[1] = mem;\n \t    }\n \t  return 0;"}, {"sha": "ef743cb10366f00ffd496e6e7d5230d7a81cfc40", "filename": "gcc/config/m88k/m88k.c", "status": "modified", "additions": 7, "deletions": 12, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c6df88cbec5637cfc297cea1b6c90fa638949cdc/gcc%2Fconfig%2Fm88k%2Fm88k.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c6df88cbec5637cfc297cea1b6c90fa638949cdc/gcc%2Fconfig%2Fm88k%2Fm88k.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm88k%2Fm88k.c?ref=c6df88cbec5637cfc297cea1b6c90fa638949cdc", "patch": "@@ -406,8 +406,7 @@ legitimize_address (pic, orig, reg, scratch)\n     {\n       new = gen_rtx (MEM, GET_MODE (orig), new);\n       RTX_UNCHANGING_P (new) = RTX_UNCHANGING_P (orig);\n-      MEM_VOLATILE_P (new) = MEM_VOLATILE_P (orig);\n-      MEM_IN_STRUCT_P (new) = MEM_IN_STRUCT_P (orig);\n+      MEM_COPY_ATTRIBUTES (new, orig);\n     }\n   return new;\n }\n@@ -603,8 +602,7 @@ block_move_loop (dest, dest_mem, src, src_mem, size, align)\n \t\t\t\tgen_rtx (REG, Pmode, 3),\n \t\t\t\toffset_rtx));\n   RTX_UNCHANGING_P (value_rtx) = RTX_UNCHANGING_P (src_mem);\n-  MEM_VOLATILE_P (value_rtx) = MEM_VOLATILE_P (src_mem);\n-  MEM_IN_STRUCT_P (value_rtx) = MEM_IN_STRUCT_P (src_mem);\n+  MEM_COPY_ATTRIBUTES (value_rtx, src_mem);\n \n   emit_insn (gen_call_movstrsi_loop\n \t     (gen_rtx (SYMBOL_REF, Pmode, IDENTIFIER_POINTER (entry_name)),\n@@ -660,8 +658,7 @@ block_move_no_loop (dest, dest_mem, src, src_mem, size, align)\n \t\t\t\tgen_rtx (REG, Pmode, 3),\n \t\t\t\toffset_rtx));\n   RTX_UNCHANGING_P (value_rtx) = RTX_UNCHANGING_P (src_mem);\n-  MEM_VOLATILE_P (value_rtx) = MEM_VOLATILE_P (src_mem);\n-  MEM_IN_STRUCT_P (value_rtx) = MEM_IN_STRUCT_P (src_mem);\n+  MEM_COPY_ATTRIBUTES (value_rtx, src_mem);\n \n   value_reg = ((((most - (size - remainder)) / align) & 1) == 0\n \t       ? (align == 8 ? 6 : 5) : 4);\n@@ -733,8 +730,7 @@ block_move_sequence (dest, dest_mem, src, src_mem, size, align, offset)\n \t\t\t  gen_rtx (PLUS, Pmode, src,\n \t\t\t\t   GEN_INT (offset_ld)));\n \t  RTX_UNCHANGING_P (srcp) = RTX_UNCHANGING_P (src_mem);\n-\t  MEM_VOLATILE_P (srcp) = MEM_VOLATILE_P (src_mem);\n-\t  MEM_IN_STRUCT_P (srcp) = MEM_IN_STRUCT_P (src_mem);\n+\t  MEM_COPY_ATTRIBUTES (srcp, src_mem);\n \t  emit_insn (gen_rtx (SET, VOIDmode, temp[next], srcp));\n \t  offset_ld += amount[next];\n \t  active[next] = TRUE;\n@@ -748,8 +744,7 @@ block_move_sequence (dest, dest_mem, src, src_mem, size, align, offset)\n \t\t\t  gen_rtx (PLUS, Pmode, dest,\n \t\t\t\t   GEN_INT (offset_st)));\n \t  RTX_UNCHANGING_P (dstp) = RTX_UNCHANGING_P (dest_mem);\n-\t  MEM_VOLATILE_P (dstp) = MEM_VOLATILE_P (dest_mem);\n-\t  MEM_IN_STRUCT_P (dstp) = MEM_IN_STRUCT_P (dest_mem);\n+\t  MEM_COPY_ATTRIBUTES (dstp, dest_mem);\n \t  emit_insn (gen_rtx (SET, VOIDmode, dstp, temp[phase]));\n \t  offset_st += amount[phase];\n \t}\n@@ -2611,7 +2606,7 @@ m88k_builtin_saveregs (arglist)\n \n   /* Allocate the va_list constructor */\n   block = assign_stack_local (BLKmode, 3 * UNITS_PER_WORD, BITS_PER_WORD);\n-  MEM_IN_STRUCT_P (block) = 1;\n+  MEM_SET_IN_STRUCT_P (block, 1);\n   RTX_UNCHANGING_P (block) = 1;\n   RTX_UNCHANGING_P (XEXP (block, 0)) = 1;\n \n@@ -2627,7 +2622,7 @@ m88k_builtin_saveregs (arglist)\n \n   /* Allocate the register space, and store it as the __va_reg member.  */\n   addr = assign_stack_local (BLKmode, 8 * UNITS_PER_WORD, -1);\n-  MEM_IN_STRUCT_P (addr) = 1;\n+  MEM_SET_IN_STRUCT_P (addr, 1);\n   RTX_UNCHANGING_P (addr) = 1;\n   RTX_UNCHANGING_P (XEXP (addr, 0)) = 1;\n   emit_move_insn (change_address (block, Pmode,"}, {"sha": "ddff4ab16197ee37b6aca2168930e1e1542f6fe6", "filename": "gcc/config/mips/abi64.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c6df88cbec5637cfc297cea1b6c90fa638949cdc/gcc%2Fconfig%2Fmips%2Fabi64.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c6df88cbec5637cfc297cea1b6c90fa638949cdc/gcc%2Fconfig%2Fmips%2Fabi64.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fabi64.h?ref=c6df88cbec5637cfc297cea1b6c90fa638949cdc", "patch": "@@ -139,7 +139,7 @@ extern struct rtx_def *mips_function_value ();\n \t\t so that the insn scheduler won't assume that these\t\\\n \t\t stores can't possibly overlap with the va_arg loads.  */ \\\n \t      if (mips_abi != ABI_EABI && BYTES_BIG_ENDIAN)\t\t\\\n-\t        MEM_IN_STRUCT_P (mem) = 1;\t\t\t\t\\\n+\t        MEM_SET_IN_STRUCT_P (mem, 1);\t\t\t\t\\\n \t      move_block_from_reg\t\t\t\t\t\\\n \t\t((CUM).arg_words + GP_ARG_FIRST + mips_off,\t\t\\\n \t\t mem,\t\t\t\t\t\t\t\\"}, {"sha": "806bbadda73431353aa89725f171df3a02e63ce9", "filename": "gcc/config/rs6000/rs6000.c", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c6df88cbec5637cfc297cea1b6c90fa638949cdc/gcc%2Fconfig%2Frs6000%2Frs6000.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c6df88cbec5637cfc297cea1b6c90fa638949cdc/gcc%2Fconfig%2Frs6000%2Frs6000.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.c?ref=c6df88cbec5637cfc297cea1b6c90fa638949cdc", "patch": "@@ -1706,8 +1706,7 @@ expand_block_move_mem (mode, addr, orig_mem)\n   rtx mem = gen_rtx_MEM (mode, addr);\n \n   RTX_UNCHANGING_P (mem) = RTX_UNCHANGING_P (orig_mem);\n-  MEM_VOLATILE_P (mem) = MEM_VOLATILE_P (orig_mem);\n-  MEM_IN_STRUCT_P (mem) = MEM_IN_STRUCT_P (orig_mem);\n+  MEM_COPY_ATTRIBUTES (mem, orig_mem);\n #ifdef MEM_UNALIGNED_P\n   MEM_UNALIGNED_P (mem) = MEM_UNALIGNED_P (orig_mem);\n #endif"}, {"sha": "984fd6f01616f241b1a0de3ca139c170aaeffb6d", "filename": "gcc/config/sh/sh.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c6df88cbec5637cfc297cea1b6c90fa638949cdc/gcc%2Fconfig%2Fsh%2Fsh.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c6df88cbec5637cfc297cea1b6c90fa638949cdc/gcc%2Fconfig%2Fsh%2Fsh.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fsh.c?ref=c6df88cbec5637cfc297cea1b6c90fa638949cdc", "patch": "@@ -3854,7 +3854,7 @@ sh_builtin_saveregs (arglist)\n   bufsize = (n_intregs * UNITS_PER_WORD) + (n_floatregs * UNITS_PER_WORD);\n \n   regbuf = assign_stack_local (BLKmode, bufsize, 0);\n-  MEM_IN_STRUCT_P (regbuf) = 1;\n+  MEM_SET_IN_STRUCT_P (regbuf, 1);\n \n   /* Save int args.\n      This is optimized to only save the regs that are necessary.  Explicitly"}, {"sha": "94f6f0add7a7b05b02772d0dbe07f7566d772eb3", "filename": "gcc/cse.c", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c6df88cbec5637cfc297cea1b6c90fa638949cdc/gcc%2Fcse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c6df88cbec5637cfc297cea1b6c90fa638949cdc/gcc%2Fcse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcse.c?ref=c6df88cbec5637cfc297cea1b6c90fa638949cdc", "patch": "@@ -5945,9 +5945,8 @@ gen_lowpart_if_possible (mode, x)\n       new = gen_rtx_MEM (mode, plus_constant (XEXP (x, 0), offset));\n       if (! memory_address_p (mode, XEXP (new, 0)))\n \treturn 0;\n-      MEM_VOLATILE_P (new) = MEM_VOLATILE_P (x);\n       RTX_UNCHANGING_P (new) = RTX_UNCHANGING_P (x);\n-      MEM_IN_STRUCT_P (new) = MEM_IN_STRUCT_P (x);\n+      MEM_COPY_ATTRIBUTES (new, x);\n       return new;\n     }\n   else"}, {"sha": "d676a97a715ac2aa4dce60509881e647a21b9170", "filename": "gcc/emit-rtl.c", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c6df88cbec5637cfc297cea1b6c90fa638949cdc/gcc%2Femit-rtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c6df88cbec5637cfc297cea1b6c90fa638949cdc/gcc%2Femit-rtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Femit-rtl.c?ref=c6df88cbec5637cfc297cea1b6c90fa638949cdc", "patch": "@@ -1199,8 +1199,7 @@ operand_subword (op, i, validate_address, mode)\n \n       new = gen_rtx_MEM (word_mode, addr);\n \n-      MEM_VOLATILE_P (new) = MEM_VOLATILE_P (op);\n-      MEM_IN_STRUCT_P (new) = MEM_IN_STRUCT_P (op);\n+      MEM_COPY_ATTRIBUTES (new, op);\n       RTX_UNCHANGING_P (new) = RTX_UNCHANGING_P (op);\n \n       return new;\n@@ -1499,9 +1498,8 @@ change_address (memref, mode, addr)\n     return memref;\n \n   new = gen_rtx_MEM (mode, addr);\n-  MEM_VOLATILE_P (new) = MEM_VOLATILE_P (memref);\n   RTX_UNCHANGING_P (new) = RTX_UNCHANGING_P (memref);\n-  MEM_IN_STRUCT_P (new) = MEM_IN_STRUCT_P (memref);\n+  MEM_COPY_ATTRIBUTES (new, memref);\n   return new;\n }\n \f"}, {"sha": "a95292960c72ea00dc4417bc34a50a37abc35080", "filename": "gcc/explow.c", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c6df88cbec5637cfc297cea1b6c90fa638949cdc/gcc%2Fexplow.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c6df88cbec5637cfc297cea1b6c90fa638949cdc/gcc%2Fexplow.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexplow.c?ref=c6df88cbec5637cfc297cea1b6c90fa638949cdc", "patch": "@@ -606,9 +606,10 @@ stabilize (x)\n       /* Mark returned memref with in_struct if it's in an array or\n \t structure.  Copy const and volatile from original memref.  */\n \n-      MEM_IN_STRUCT_P (mem) = MEM_IN_STRUCT_P (x) || GET_CODE (addr) == PLUS;\n       RTX_UNCHANGING_P (mem) = RTX_UNCHANGING_P (x);\n-      MEM_VOLATILE_P (mem) = MEM_VOLATILE_P (x);\n+      MEM_COPY_ATTRIBUTES (mem, x);\n+      if (GET_CODE (addr) == PLUS)\n+\tMEM_SET_IN_STRUCT_P (mem, 1);\n \n       /* Since the new MEM is just like the old X, it can alias only\n \t the things that X could.  */"}, {"sha": "d84849d63093367b43b834e76565c3c95435e142", "filename": "gcc/expr.c", "status": "modified", "additions": 10, "deletions": 30, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c6df88cbec5637cfc297cea1b6c90fa638949cdc/gcc%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c6df88cbec5637cfc297cea1b6c90fa638949cdc/gcc%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.c?ref=c6df88cbec5637cfc297cea1b6c90fa638949cdc", "patch": "@@ -419,9 +419,8 @@ protect_from_queue (x, modify)\n \t  register rtx y = XEXP (x, 0);\n \t  register rtx new = gen_rtx_MEM (GET_MODE (x), QUEUED_VAR (y));\n \n-\t  MEM_IN_STRUCT_P (new) = MEM_IN_STRUCT_P (x);\n \t  RTX_UNCHANGING_P (new) = RTX_UNCHANGING_P (x);\n-\t  MEM_VOLATILE_P (new) = MEM_VOLATILE_P (x);\n+\t  MEM_COPY_ATTRIBUTES (new, x);\n \t  MEM_ALIAS_SET (new) = MEM_ALIAS_SET (x);\n \n \t  if (QUEUED_INSN (y))\n@@ -2021,7 +2020,7 @@ emit_group_store (orig_dst, src, ssize, align)\n \t mem_in_struct_p set; we might not.  */\n \n       dst = copy_rtx (orig_dst);\n-      MEM_IN_STRUCT_P (dst) = 1;\n+      MEM_SET_IN_STRUCT_P (dst, 1);\n     }\n \n   /* Process the pieces.  */\n@@ -2091,7 +2090,7 @@ copy_blkmode_from_reg(tgtblk,srcreg,type)\n       if (tgtblk == 0)\n \t{\n \t  tgtblk = assign_stack_temp (BLKmode, bytes, 0);\n-\t  MEM_IN_STRUCT_P (tgtblk) = AGGREGATE_TYPE_P (type);\n+\t  MEM_SET_IN_STRUCT_P (tgtblk, AGGREGATE_TYPE_P (type));\n \t  preserve_temp_slots (tgtblk);\n \t}\n       \n@@ -4544,8 +4543,8 @@ store_field (target, bitsize, bitpos, mode, exp, value_mode,\n \t\t\t\t      GET_MODE_SIZE (GET_MODE (target)), 0);\n       rtx blk_object = copy_rtx (object);\n \n-      MEM_IN_STRUCT_P (object) = 1;\n-      MEM_IN_STRUCT_P (blk_object) = 1;\n+      MEM_SET_IN_STRUCT_P (object, 1);\n+      MEM_SET_IN_STRUCT_P (blk_object, 1);\n       PUT_MODE (blk_object, BLKmode);\n \n       if (bitsize != GET_MODE_BITSIZE (GET_MODE (target)))\n@@ -4666,7 +4665,7 @@ store_field (target, bitsize, bitpos, mode, exp, value_mode,\n \t\t\t\t\t plus_constant (addr,\n \t\t\t\t\t\t\t(bitpos\n \t\t\t\t\t\t\t / BITS_PER_UNIT))));\n-      MEM_IN_STRUCT_P (to_rtx) = 1;\n+      MEM_SET_IN_STRUCT_P (to_rtx, 1);\n       MEM_ALIAS_SET (to_rtx) = alias_set;\n \n       return store_expr (exp, to_rtx, value_mode != VOIDmode);\n@@ -6149,26 +6148,7 @@ expand_expr (exp, target, tmode, modifier)\n \t    || (TREE_CODE (exp1) == ADDR_EXPR\n \t\t&& (exp2 = TREE_OPERAND (exp1, 0))\n \t\t&& AGGREGATE_TYPE_P (TREE_TYPE (exp2))))\n-\t  MEM_IN_STRUCT_P (temp) = 1;\n-\n-\t/* If the pointer is actually a REFERENCE_TYPE, this could be pointing\n-\t   into some aggregate too.  In theory we could fold this into the\n-\t   previous check and use rtx_addr_varies_p there too.\n-\n-\t   However, this seems safer.  */\n-\tif (!MEM_IN_STRUCT_P (temp)\n-\t    && (TREE_CODE (TREE_TYPE (exp1)) == REFERENCE_TYPE\n-\t        /* This may have been an array reference to the first element\n-\t\t   that was optimized away from being an addition.  */\n-\t        || (TREE_CODE (exp1) == NOP_EXPR\n-\t\t    && ((TREE_CODE (TREE_TYPE (TREE_OPERAND (exp1, 0)))\n-\t\t\t == REFERENCE_TYPE)\n-\t\t        || ((TREE_CODE (TREE_TYPE (TREE_OPERAND (exp1, 0)))\n-\t\t\t     == POINTER_TYPE)\n-\t\t\t    && (AGGREGATE_TYPE_P\n-\t\t\t        (TREE_TYPE (TREE_TYPE\n-\t\t\t\t\t    (TREE_OPERAND (exp1, 0))))))))))\n-\t  MEM_IN_STRUCT_P (temp) = ! rtx_addr_varies_p (temp);\n+\t  MEM_SET_IN_STRUCT_P (temp, 1);\n \n \tMEM_VOLATILE_P (temp) = TREE_THIS_VOLATILE (exp) | flag_volatile;\n \tMEM_ALIAS_SET (temp) = get_alias_set (exp);\n@@ -6527,7 +6507,7 @@ expand_expr (exp, target, tmode, modifier)\n \t\temit_move_insn (new, op0);\n \t\top0 = copy_rtx (new);\n \t\tPUT_MODE (op0, BLKmode);\n-\t\tMEM_IN_STRUCT_P (op0) = 1;\n+\t\tMEM_SET_IN_STRUCT_P (op0, 1);\n \t      }\n \n \t    return op0;\n@@ -6554,7 +6534,7 @@ expand_expr (exp, target, tmode, modifier)\n \tif (GET_CODE (XEXP (op0, 0)) == REG)\n \t  mark_reg_pointer (XEXP (op0, 0), alignment);\n \n-\tMEM_IN_STRUCT_P (op0) = 1;\n+\tMEM_SET_IN_STRUCT_P (op0, 1);\n \tMEM_VOLATILE_P (op0) |= volatilep;\n \tif (mode == mode1 || mode1 == BLKmode || mode1 == tmode\n \t    || modifier == EXPAND_CONST_ADDRESS\n@@ -8573,7 +8553,7 @@ get_memory_rtx (exp)\n       is_aggregate = AGGREGATE_TYPE_P (type);\n     }\n \n-  MEM_IN_STRUCT_P (mem) = is_aggregate;\n+  MEM_SET_IN_STRUCT_P (mem, is_aggregate);\n   return mem;\n }\n "}, {"sha": "b82a0425574b0fc7893054b0a27f969be25b4ec7", "filename": "gcc/final.c", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c6df88cbec5637cfc297cea1b6c90fa638949cdc/gcc%2Ffinal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c6df88cbec5637cfc297cea1b6c90fa638949cdc/gcc%2Ffinal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffinal.c?ref=c6df88cbec5637cfc297cea1b6c90fa638949cdc", "patch": "@@ -3096,8 +3096,7 @@ alter_subreg (x)\n \toffset -= (MIN (UNITS_PER_WORD, GET_MODE_SIZE (GET_MODE (x)))\n \t\t   - MIN (UNITS_PER_WORD, GET_MODE_SIZE (GET_MODE (y))));\n       PUT_CODE (x, MEM);\n-      MEM_VOLATILE_P (x) = MEM_VOLATILE_P (y);\n-      MEM_IN_STRUCT_P (x) = MEM_IN_STRUCT_P (y);\n+      MEM_COPY_ATTRIBUTES (x, y);\n       MEM_ALIAS_SET (x) = MEM_ALIAS_SET (y);\n       XEXP (x, 0) = plus_constant (XEXP (y, 0), offset);\n     }"}, {"sha": "8a67457495b80175f147ffb6c490c58d640bb57e", "filename": "gcc/function.c", "status": "modified", "additions": 20, "deletions": 16, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c6df88cbec5637cfc297cea1b6c90fa638949cdc/gcc%2Ffunction.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c6df88cbec5637cfc297cea1b6c90fa638949cdc/gcc%2Ffunction.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffunction.c?ref=c6df88cbec5637cfc297cea1b6c90fa638949cdc", "patch": "@@ -968,6 +968,8 @@ assign_stack_temp (mode, size, keep)\n      set from before.  */\n   RTX_UNCHANGING_P (p->slot) = 0;\n   MEM_IN_STRUCT_P (p->slot) = 0;\n+  MEM_SCALAR_P (p->slot) = 0;\n+  MEM_ALIAS_SET (p->slot) = 0;\n   return p->slot;\n }\n \f\n@@ -1003,7 +1005,7 @@ assign_temp (type, keep, memory_required, dont_promote)\n \tsize = TREE_INT_CST_LOW (TYPE_ARRAY_MAX_SIZE (type));\n \n       tmp = assign_stack_temp (mode, size, keep);\n-      MEM_IN_STRUCT_P (tmp) = AGGREGATE_TYPE_P (type);\n+      MEM_SET_IN_STRUCT_P (tmp, AGGREGATE_TYPE_P (type));\n       return tmp;\n     }\n \n@@ -1561,7 +1563,8 @@ put_reg_into_stack (function, reg, type, promoted_mode, decl_mode, volatile_p,\n      previously generated stack slot, then we need to copy the bit in\n      case it was set for other reasons.  For instance, it is set for\n      __builtin_va_alist.  */\n-  MEM_IN_STRUCT_P (reg) = AGGREGATE_TYPE_P (type) | MEM_IN_STRUCT_P (new);\n+  MEM_SET_IN_STRUCT_P (reg,\n+\t\t       AGGREGATE_TYPE_P (type) || MEM_IN_STRUCT_P (new));\n   MEM_ALIAS_SET (reg) = get_alias_set (type);\n \n   /* Now make sure that all refs to the variable, previously made\n@@ -2025,8 +2028,7 @@ fixup_var_refs_1 (var, promoted_mode, loc, insn, replacements)\n \t\t  newmem = gen_rtx_MEM (wanted_mode,\n \t\t\t\t\tplus_constant (XEXP (tem, 0), offset));\n \t\t  RTX_UNCHANGING_P (newmem) = RTX_UNCHANGING_P (tem);\n-\t\t  MEM_VOLATILE_P (newmem) = MEM_VOLATILE_P (tem);\n-\t\t  MEM_IN_STRUCT_P (newmem) = MEM_IN_STRUCT_P (tem);\n+\t\t  MEM_COPY_ATTRIBUTES (newmem, tem);\n \n \t\t  /* Make the change and see if the insn remains valid.  */\n \t\t  INSN_CODE (insn) = -1;\n@@ -2217,8 +2219,7 @@ fixup_var_refs_1 (var, promoted_mode, loc, insn, replacements)\n \t\t    newmem = gen_rtx_MEM (wanted_mode,\n \t\t\t\t\t  plus_constant (XEXP (tem, 0), offset));\n \t\t    RTX_UNCHANGING_P (newmem) = RTX_UNCHANGING_P (tem);\n-\t\t    MEM_VOLATILE_P (newmem) = MEM_VOLATILE_P (tem);\n-\t\t    MEM_IN_STRUCT_P (newmem) = MEM_IN_STRUCT_P (tem);\n+\t\t    MEM_COPY_ATTRIBUTES (newmem, tem);\n \n \t\t    /* Make the change and see if the insn remains valid.  */\n \t\t    INSN_CODE (insn) = -1;\n@@ -2783,7 +2784,7 @@ gen_mem_addressof (reg, decl)\n   PUT_CODE (reg, MEM);\n   PUT_MODE (reg, DECL_MODE (decl));\n   MEM_VOLATILE_P (reg) = TREE_SIDE_EFFECTS (decl);\n-  MEM_IN_STRUCT_P (reg) = AGGREGATE_TYPE_P (type);\n+  MEM_SET_IN_STRUCT_P (reg, AGGREGATE_TYPE_P (type));\n   MEM_ALIAS_SET (reg) = get_alias_set (decl);\n \n   if (TREE_USED (decl) || DECL_INITIAL (decl) != 0)\n@@ -4114,7 +4115,7 @@ assign_parms (fndecl, second_time)\n \t  /* If this is a memory ref that contains aggregate components,\n \t     mark it as such for cse and loop optimize.  Likewise if it\n \t     is readonly.  */\n-\t  MEM_IN_STRUCT_P (stack_parm) = aggregate;\n+\t  MEM_SET_IN_STRUCT_P (stack_parm, aggregate);\n \t  RTX_UNCHANGING_P (stack_parm) = TREE_READONLY (parm);\n \t  MEM_ALIAS_SET (stack_parm) = get_alias_set (parm);\n \t}\n@@ -4254,7 +4255,7 @@ assign_parms (fndecl, second_time)\n \n \t  /* If this is a memory ref that contains aggregate components,\n \t     mark it as such for cse and loop optimize.  */\n-\t  MEM_IN_STRUCT_P (stack_parm) = aggregate;\n+\t  MEM_SET_IN_STRUCT_P (stack_parm, aggregate);\n \t}\n #endif /* 0 */\n \n@@ -4311,7 +4312,7 @@ assign_parms (fndecl, second_time)\n \n \t\t  /* If this is a memory ref that contains aggregate\n \t\t     components, mark it as such for cse and loop optimize.  */\n-\t\t  MEM_IN_STRUCT_P (stack_parm) = aggregate;\n+\t\t  MEM_SET_IN_STRUCT_P (stack_parm, aggregate);\n \t\t}\n \n \t      else if (PARM_BOUNDARY % BITS_PER_WORD != 0)\n@@ -4368,7 +4369,7 @@ assign_parms (fndecl, second_time)\n \t    {\n \t      DECL_RTL (parm)\n \t\t= gen_rtx_MEM (TYPE_MODE (TREE_TYPE (passed_type)), parmreg);\n-\t      MEM_IN_STRUCT_P (DECL_RTL (parm)) = aggregate;\n+\t      MEM_SET_IN_STRUCT_P (DECL_RTL (parm), aggregate);\n \t    }\n \t  else\n \t    DECL_RTL (parm) = parmreg;\n@@ -4469,7 +4470,7 @@ assign_parms (fndecl, second_time)\n \t      else\n \t\tcopy = assign_stack_temp (TYPE_MODE (type),\n \t\t\t\t\t  int_size_in_bytes (type), 1);\n-\t      MEM_IN_STRUCT_P (copy) = AGGREGATE_TYPE_P (type);\n+\t      MEM_SET_IN_STRUCT_P (copy, AGGREGATE_TYPE_P (type));\n \t      RTX_UNCHANGING_P (copy) = TREE_READONLY (parm);\n \n \t      store_expr (parm, copy, 0);\n@@ -4624,7 +4625,7 @@ assign_parms (fndecl, second_time)\n \t\t\t\t\t  GET_MODE_SIZE (GET_MODE (entry_parm)), 0);\n \t\t  /* If this is a memory ref that contains aggregate components,\n \t\t     mark it as such for cse and loop optimize.  */\n-\t\t  MEM_IN_STRUCT_P (stack_parm) = aggregate;\n+\t\t  MEM_SET_IN_STRUCT_P (stack_parm, aggregate);\n \t\t}\n \n \t      if (promoted_mode != nominal_mode)\n@@ -4666,7 +4667,8 @@ assign_parms (fndecl, second_time)\n \t  DECL_RTL (result)\n \t    = gen_rtx_MEM (DECL_MODE (result), DECL_RTL (parm));\n \n-\t  MEM_IN_STRUCT_P (DECL_RTL (result)) = AGGREGATE_TYPE_P (restype);\n+\t  MEM_SET_IN_STRUCT_P (DECL_RTL (result), \n+\t\t\t       AGGREGATE_TYPE_P (restype));\n \t}\n \n       if (TREE_THIS_VOLATILE (parm))\n@@ -5746,8 +5748,10 @@ expand_function_start (subr, parms_have_cleanups)\n \t{\n \t  DECL_RTL (DECL_RESULT (subr))\n \t    = gen_rtx_MEM (DECL_MODE (DECL_RESULT (subr)), value_address);\n-\t  MEM_IN_STRUCT_P (DECL_RTL (DECL_RESULT (subr)))\n-\t    = AGGREGATE_TYPE_P (TREE_TYPE (DECL_RESULT (subr)));\n+\t  MEM_SET_IN_STRUCT_P (DECL_RTL (DECL_RESULT (subr)),\n+\t\t\t       AGGREGATE_TYPE_P (TREE_TYPE\n+\t\t\t\t\t\t (DECL_RESULT\n+\t\t\t\t\t\t  (subr))));\n \t}\n     }\n   else if (DECL_MODE (DECL_RESULT (subr)) == VOIDmode)"}, {"sha": "3a658b0698b751927866f2060c0b33c84c4f7eb5", "filename": "gcc/loop.c", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c6df88cbec5637cfc297cea1b6c90fa638949cdc/gcc%2Floop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c6df88cbec5637cfc297cea1b6c90fa638949cdc/gcc%2Floop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Floop.c?ref=c6df88cbec5637cfc297cea1b6c90fa638949cdc", "patch": "@@ -2998,8 +2998,7 @@ note_addr_stored (x, y)\n     return;\n \n   for (i = 0; i < loop_store_mems_idx; i++)\n-    if (rtx_equal_p (XEXP (loop_store_mems[i], 0), XEXP (x, 0))\n-\t&& MEM_IN_STRUCT_P (x) == MEM_IN_STRUCT_P (loop_store_mems[i]))\n+    if (rtx_equal_p (XEXP (loop_store_mems[i], 0), XEXP (x, 0)))\n       {\n \t/* We are storing at the same address as previously noted.  Save the\n \t   wider reference.  */"}, {"sha": "83235f79ad0c26d7ce5692d3ff13c3e84ea26fb1", "filename": "gcc/optabs.c", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c6df88cbec5637cfc297cea1b6c90fa638949cdc/gcc%2Foptabs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c6df88cbec5637cfc297cea1b6c90fa638949cdc/gcc%2Foptabs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Foptabs.c?ref=c6df88cbec5637cfc297cea1b6c90fa638949cdc", "patch": "@@ -3458,8 +3458,7 @@ gen_move_insn (x, y)\n \t    {\n \t      x = gen_rtx_MEM (tmode, XEXP (x1, 0));\n \t      RTX_UNCHANGING_P (x) = RTX_UNCHANGING_P (x1);\n-\t      MEM_IN_STRUCT_P (x) = MEM_IN_STRUCT_P (x1);\n-\t      MEM_VOLATILE_P (x) = MEM_VOLATILE_P (x1);\n+\t      MEM_COPY_ATTRIBUTES (x, x1);\n \t      copy_replacements (x1, x);\n \t    }\n \n@@ -3468,8 +3467,7 @@ gen_move_insn (x, y)\n \t    {\n \t      y = gen_rtx_MEM (tmode, XEXP (y1, 0));\n \t      RTX_UNCHANGING_P (y) = RTX_UNCHANGING_P (y1);\n-\t      MEM_IN_STRUCT_P (y) = MEM_IN_STRUCT_P (y1);\n-\t      MEM_VOLATILE_P (y) = MEM_VOLATILE_P (y1);\n+\t      MEM_COPY_ATTRIBUTES (y, y1);\n \t      copy_replacements (y1, y);\n \t    }\n \t}"}, {"sha": "f7cb5c608fbce01395289a0b697f21896528f515", "filename": "gcc/print-rtl.c", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c6df88cbec5637cfc297cea1b6c90fa638949cdc/gcc%2Fprint-rtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c6df88cbec5637cfc297cea1b6c90fa638949cdc/gcc%2Fprint-rtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fprint-rtl.c?ref=c6df88cbec5637cfc297cea1b6c90fa638949cdc", "patch": "@@ -118,6 +118,9 @@ print_rtx (in_rtx)\n       if (in_rtx->integrated)\n \tfputs (\"/i\", outfile);\n \n+      if (in_rtx->frame_related)\n+\tfputs (\"/f\", outfile);\n+\n       if (GET_MODE (in_rtx) != VOIDmode)\n \t{\n \t  /* Print REG_NOTE names for EXPR_LIST and INSN_LIST.  */"}, {"sha": "da80b86465502a9a328cb93a4050f2fa3f1f9397", "filename": "gcc/recog.c", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c6df88cbec5637cfc297cea1b6c90fa638949cdc/gcc%2Frecog.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c6df88cbec5637cfc297cea1b6c90fa638949cdc/gcc%2Frecog.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frecog.c?ref=c6df88cbec5637cfc297cea1b6c90fa638949cdc", "patch": "@@ -539,9 +539,8 @@ validate_replace_rtx_1 (loc, from, to, object)\n \t\t       - MIN (UNITS_PER_WORD, GET_MODE_SIZE (mode)));\n \n \t  new = gen_rtx_MEM (mode, plus_constant (XEXP (to, 0), offset));\n-\t  MEM_VOLATILE_P (new) = MEM_VOLATILE_P (to);\n \t  RTX_UNCHANGING_P (new) = RTX_UNCHANGING_P (to);\n-\t  MEM_IN_STRUCT_P (new) = MEM_IN_STRUCT_P (to);\n+\t  MEM_COPY_ATTRIBUTES (new, to);\n \t  validate_change (object, loc, new, 1);\n \t  return;\n \t}\n@@ -599,8 +598,7 @@ validate_replace_rtx_1 (loc, from, to, object)\n \t      newmem = gen_rtx_MEM (wanted_mode,\n \t\t\t\t    plus_constant (XEXP (to, 0), offset));\n \t      RTX_UNCHANGING_P (newmem) = RTX_UNCHANGING_P (to);\n-\t      MEM_VOLATILE_P (newmem) = MEM_VOLATILE_P (to);\n-\t      MEM_IN_STRUCT_P (newmem) = MEM_IN_STRUCT_P (to);\n+\t      MEM_COPY_ATTRIBUTES (newmem, to);\n \n \t      validate_change (object, &XEXP (x, 2), GEN_INT (pos), 1);\n \t      validate_change (object, &XEXP (x, 0), newmem, 1);"}, {"sha": "d68fc8a5b7cf8169d0e47f071f7285b62d299d2a", "filename": "gcc/reload1.c", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c6df88cbec5637cfc297cea1b6c90fa638949cdc/gcc%2Freload1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c6df88cbec5637cfc297cea1b6c90fa638949cdc/gcc%2Freload1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freload1.c?ref=c6df88cbec5637cfc297cea1b6c90fa638949cdc", "patch": "@@ -1083,11 +1083,13 @@ reload (first, global, dumpfile)\n     {\n       rtx addr = 0;\n       int in_struct = 0;\n+      int is_scalar;\n       int is_readonly = 0;\n \n       if (reg_equiv_memory_loc[i])\n \t{\n \t  in_struct = MEM_IN_STRUCT_P (reg_equiv_memory_loc[i]);\n+\t  is_scalar = MEM_SCALAR_P (reg_equiv_memory_loc[i]);\n \t  is_readonly = RTX_UNCHANGING_P (reg_equiv_memory_loc[i]);\n \t}\n \n@@ -1106,6 +1108,7 @@ reload (first, global, dumpfile)\n \t      REG_USERVAR_P (reg) = 0;\n \t      RTX_UNCHANGING_P (reg) = is_readonly;\n \t      MEM_IN_STRUCT_P (reg) = in_struct;\n+\t      MEM_SCALAR_P (reg) = is_scalar;\n \t      /* We have no alias information about this newly created\n \t\t MEM.  */\n \t      MEM_ALIAS_SET (reg) = 0;"}, {"sha": "0fef1a75ed5fd64bc0890ee50d8cfff5a9958d4d", "filename": "gcc/rtl.h", "status": "modified", "additions": 26, "deletions": 4, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c6df88cbec5637cfc297cea1b6c90fa638949cdc/gcc%2Frtl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c6df88cbec5637cfc297cea1b6c90fa638949cdc/gcc%2Frtl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtl.h?ref=c6df88cbec5637cfc297cea1b6c90fa638949cdc", "patch": "@@ -163,9 +163,11 @@ typedef struct rtx_def\n      In a REG, nonzero means this reg refers to the return value\n      of the current function.  */\n   unsigned integrated : 1;\n-  /* Nonzero if this rtx is related to the call frame, either changing how\n-     we compute the frame address or saving and restoring registers in\n-     the prologue and epilogue.  */\n+  /* 1 in an INSN if this rtx is related to the call frame,\n+     either changing how we compute the frame address or saving and\n+     restoring registers in the prologue and epilogue.  \n+     1 in a MEM if the MEM refers to a scalar, rather than a member of\n+     an aggregate.  */\n   unsigned frame_related : 1;\n   /* The first element of the operands of this rtx.\n      The number of operands and their types are controlled\n@@ -568,9 +570,29 @@ extern char *note_insn_name[];\n    Also in an ASM_OPERANDS rtx.  */\n #define MEM_VOLATILE_P(RTX) ((RTX)->volatil)\n \n-/* For a MEM rtx, 1 if it refers to a field of an aggregate.  */\n+/* For a MEM rtx, 1 if it refers to a field of an aggregate.  If zero,\n+   RTX may or may not refer to a field of an aggregate.  */\n #define MEM_IN_STRUCT_P(RTX) ((RTX)->in_struct)\n \n+/* For a MEM rtx, 1 if it refers to a scalar.  If zero, RTX may or may\n+   not refer to a scalar.*/\n+#define MEM_SCALAR_P(RTX) ((RTX)->frame_related)\n+\n+/* Copy the MEM_VOLATILE_P, MEM_IN_STRUCT_P, and MEM_SCALAR_P\n+   attributes from RHS to LHS.  */\n+#define MEM_COPY_ATTRIBUTES(LHS, RHS)\t\t\t\\\n+  (MEM_VOLATILE_P (LHS) = MEM_VOLATILE_P (RHS),\t\t\\\n+   MEM_IN_STRUCT_P (LHS) = MEM_IN_STRUCT_P (RHS),\t\\\n+   MEM_SCALAR_P (LHS) = MEM_SCALAR_P (RHS))\t\t\\\n+\n+/* If VAL is non-zero, set MEM_IN_STRUCT_P and clear MEM_SCALAR_P in\n+   RTX.  Otherwise, vice versa.  Use this macro only when you are\n+   *sure* that you know that the MEM is in a structure, or is a\n+   scalar.  VAL is evaluated only once.  */\n+#define MEM_SET_IN_STRUCT_P(RTX, VAL) \t\t\t\t\\\n+  ((VAL) ? (MEM_IN_STRUCT_P (RTX) = 1, MEM_SCALAR_P (RTX) = 0)\t\\\n+   : (MEM_IN_STRUCT_P (RTX) = 0, MEM_SCALAR_P (RTX) = 1))\n+\n /* For a MEM rtx, the alias set.  If 0, this MEM is not in any alias\n    set, and may alias anything.  Otherwise, the MEM can only alias\n    MEMs in the same alias set.  This value is set in a"}, {"sha": "751e11ccd96ff83b6f1f600c20d72701d119ee85", "filename": "gcc/rtl.texi", "status": "modified", "additions": 18, "deletions": 4, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c6df88cbec5637cfc297cea1b6c90fa638949cdc/gcc%2Frtl.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c6df88cbec5637cfc297cea1b6c90fa638949cdc/gcc%2Frtl.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtl.texi?ref=c6df88cbec5637cfc297cea1b6c90fa638949cdc", "patch": "@@ -305,10 +305,24 @@ Stored in the @code{volatil} field and printed as @samp{/v}.\n @cindex @code{in_struct}, in @code{mem}\n @cindex @samp{/s} in RTL dump\n @item MEM_IN_STRUCT_P (@var{x})\n-In @code{mem} expressions, nonzero for reference to an entire\n-structure, union or array, or to a component of one.  Zero for\n-references to a scalar variable or through a pointer to a scalar.\n-Stored in the @code{in_struct} field and printed as @samp{/s}.\n+In @code{mem} expressions, nonzero for reference to an entire structure,\n+union or array, or to a component of one.  Zero for references to a\n+scalar variable or through a pointer to a scalar.  Stored in the\n+@code{in_struct} field and printed as @samp{/s}.  If both this flag and\n+MEM_SCALAR_P are clear, then we don't know whether this MEM is in a\n+structure or not.  Both flags should never be simultaneously set.\n+\n+@findex MEM_SCALAR_P\n+@cindex @code{mem} and @samp{/f}\n+@cindex @code{frame_related}, in@code{mem}\n+@cindex @samp{/f} in RTL dump\n+@item MEM_SCALAR_P (@var{x})\n+In @code{mem} expressions, nonzero for reference to a scalar known not\n+to be a member of a structure, union, or array.  Zero for such\n+references and for indirections through pointers, even pointers pointing\n+to scalar types.  If both this flag and MEM_STRUCT_P are clear, then we\n+don't know whether this MEM is in a structure or not.  Both flags should\n+never be simultaneously set.\n \n @findex MEM_ALIAS_SET\n @item MEM_ALIAS_SET (@var{x})"}, {"sha": "00d8d8828d32df515947fc395514b71358f75bbf", "filename": "gcc/stmt.c", "status": "modified", "additions": 8, "deletions": 5, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c6df88cbec5637cfc297cea1b6c90fa638949cdc/gcc%2Fstmt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c6df88cbec5637cfc297cea1b6c90fa638949cdc/gcc%2Fstmt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fstmt.c?ref=c6df88cbec5637cfc297cea1b6c90fa638949cdc", "patch": "@@ -3415,7 +3415,7 @@ expand_decl (decl)\n \t/* An initializer is going to decide the size of this array.\n \t   Until we know the size, represent its address with a reg.  */\n \tDECL_RTL (decl) = gen_rtx_MEM (BLKmode, gen_reg_rtx (Pmode));\n-      MEM_IN_STRUCT_P (DECL_RTL (decl)) = AGGREGATE_TYPE_P (type);\n+      MEM_SET_IN_STRUCT_P (DECL_RTL (decl), AGGREGATE_TYPE_P (type));\n     }\n   else if (DECL_MODE (decl) != BLKmode\n \t   /* If -ffloat-store, don't put explicit float vars\n@@ -3470,7 +3470,8 @@ expand_decl (decl)\n \t\t\t       + BITS_PER_UNIT - 1)\n \t\t\t      / BITS_PER_UNIT),\n \t\t\t     1);\n-      MEM_IN_STRUCT_P (DECL_RTL (decl)) = AGGREGATE_TYPE_P (TREE_TYPE (decl));\n+      MEM_SET_IN_STRUCT_P (DECL_RTL (decl),\n+\t\t\t   AGGREGATE_TYPE_P (TREE_TYPE (decl)));\n \n       /* Set alignment we actually gave this decl.  */\n       DECL_ALIGN (decl) = (DECL_MODE (decl) == BLKmode ? BIGGEST_ALIGNMENT\n@@ -3485,7 +3486,8 @@ expand_decl (decl)\n \n       /* If this is a memory ref that contains aggregate components,\n \t mark it as such for cse and loop optimize.  */\n-      MEM_IN_STRUCT_P (DECL_RTL (decl)) = AGGREGATE_TYPE_P (TREE_TYPE (decl));\n+      MEM_SET_IN_STRUCT_P (DECL_RTL (decl),\n+\t\t\t   AGGREGATE_TYPE_P (TREE_TYPE (decl)));\n #if 0\n       /* If this is in memory because of -ffloat-store,\n \t set the volatile bit, to prevent optimizations from\n@@ -3531,7 +3533,8 @@ expand_decl (decl)\n \n       /* If this is a memory ref that contains aggregate components,\n \t mark it as such for cse and loop optimize.  */\n-      MEM_IN_STRUCT_P (DECL_RTL (decl)) = AGGREGATE_TYPE_P (TREE_TYPE (decl));\n+      MEM_SET_IN_STRUCT_P (DECL_RTL (decl),\n+\t\t\t   AGGREGATE_TYPE_P (TREE_TYPE (decl)));\n \n       /* Indicate the alignment we actually gave this variable.  */\n #ifdef STACK_BOUNDARY\n@@ -3864,7 +3867,7 @@ expand_anon_union_decl (decl, cleanup, decl_elts)\n \t  else\n \t    {\n \t      DECL_RTL (decl_elt) = gen_rtx_MEM (mode, copy_rtx (XEXP (x, 0)));\n-\t      MEM_IN_STRUCT_P (DECL_RTL (decl_elt)) = MEM_IN_STRUCT_P (x);\n+\t      MEM_COPY_ATTRIBUTES (DECL_RTL (decl_elt), x);\n \t      RTX_UNCHANGING_P (DECL_RTL (decl_elt)) = RTX_UNCHANGING_P (x);\n \t    }\n \t}"}, {"sha": "748d0cbaa842a45edf4f46b1ec533e193b2d2875", "filename": "gcc/varasm.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c6df88cbec5637cfc297cea1b6c90fa638949cdc/gcc%2Fvarasm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c6df88cbec5637cfc297cea1b6c90fa638949cdc/gcc%2Fvarasm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvarasm.c?ref=c6df88cbec5637cfc297cea1b6c90fa638949cdc", "patch": "@@ -774,8 +774,8 @@ make_decl_rtl (decl, asmspec, top_level)\n \n \t  if (TREE_READONLY (decl))\n \t    RTX_UNCHANGING_P (DECL_RTL (decl)) = 1;\n-\t  MEM_IN_STRUCT_P (DECL_RTL (decl))\n-\t    = AGGREGATE_TYPE_P (TREE_TYPE (decl));\n+\t  MEM_SET_IN_STRUCT_P (DECL_RTL (decl),\n+\t\t\t       AGGREGATE_TYPE_P (TREE_TYPE (decl)));\n \n \t  /* Optionally set flags or add text to the name to record information\n \t     such as that it is a function name.\n@@ -2966,7 +2966,7 @@ output_constant_def (exp)\n     = gen_rtx_MEM (TYPE_MODE (TREE_TYPE (exp)), def);\n   RTX_UNCHANGING_P (TREE_CST_RTL (exp)) = 1;\n   if (AGGREGATE_TYPE_P (TREE_TYPE (exp)))\n-    MEM_IN_STRUCT_P (TREE_CST_RTL (exp)) = 1;\n+    MEM_SET_IN_STRUCT_P (TREE_CST_RTL (exp), 1);\n \n   pop_obstacks ();\n "}]}