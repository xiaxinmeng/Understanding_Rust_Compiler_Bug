{"sha": "f6f87dead4bf2da20bc3a22dc6ca7a373c9ed05c", "node_id": "C_kwDOANBUbNoAKGY2Zjg3ZGVhZDRiZjJkYTIwYmMzYTIyZGM2Y2E3YTM3M2M5ZWQwNWM", "commit": {"author": {"name": "Philip Herron", "email": "philip.herron@embecosm.com", "date": "2022-10-20T17:05:43Z"}, "committer": {"name": "Philip Herron", "email": "philip.herron@embecosm.com", "date": "2022-10-20T17:05:43Z"}, "message": "Add missing type resolution for function type segments", "tree": {"sha": "c2931e779547b7701ef663e4a6073f414cd5b5a9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c2931e779547b7701ef663e4a6073f414cd5b5a9"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f6f87dead4bf2da20bc3a22dc6ca7a373c9ed05c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f6f87dead4bf2da20bc3a22dc6ca7a373c9ed05c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f6f87dead4bf2da20bc3a22dc6ca7a373c9ed05c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f6f87dead4bf2da20bc3a22dc6ca7a373c9ed05c/comments", "author": {"login": "philberty", "id": 84585, "node_id": "MDQ6VXNlcjg0NTg1", "avatar_url": "https://avatars.githubusercontent.com/u/84585?v=4", "gravatar_id": "", "url": "https://api.github.com/users/philberty", "html_url": "https://github.com/philberty", "followers_url": "https://api.github.com/users/philberty/followers", "following_url": "https://api.github.com/users/philberty/following{/other_user}", "gists_url": "https://api.github.com/users/philberty/gists{/gist_id}", "starred_url": "https://api.github.com/users/philberty/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/philberty/subscriptions", "organizations_url": "https://api.github.com/users/philberty/orgs", "repos_url": "https://api.github.com/users/philberty/repos", "events_url": "https://api.github.com/users/philberty/events{/privacy}", "received_events_url": "https://api.github.com/users/philberty/received_events", "type": "User", "site_admin": false}, "committer": {"login": "philberty", "id": 84585, "node_id": "MDQ6VXNlcjg0NTg1", "avatar_url": "https://avatars.githubusercontent.com/u/84585?v=4", "gravatar_id": "", "url": "https://api.github.com/users/philberty", "html_url": "https://github.com/philberty", "followers_url": "https://api.github.com/users/philberty/followers", "following_url": "https://api.github.com/users/philberty/following{/other_user}", "gists_url": "https://api.github.com/users/philberty/gists{/gist_id}", "starred_url": "https://api.github.com/users/philberty/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/philberty/subscriptions", "organizations_url": "https://api.github.com/users/philberty/orgs", "repos_url": "https://api.github.com/users/philberty/repos", "events_url": "https://api.github.com/users/philberty/events{/privacy}", "received_events_url": "https://api.github.com/users/philberty/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d396692534019f1e80b821c9e483164f302679bf", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d396692534019f1e80b821c9e483164f302679bf", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d396692534019f1e80b821c9e483164f302679bf"}], "stats": {"total": 69, "additions": 62, "deletions": 7}, "files": [{"sha": "53eccb79d93b9ba3b4093154c307f179bb283a42", "filename": "gcc/rust/typecheck/rust-tyty-bounds.cc", "status": "modified", "additions": 62, "deletions": 7, "changes": 69, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f6f87dead4bf2da20bc3a22dc6ca7a373c9ed05c/gcc%2Frust%2Ftypecheck%2Frust-tyty-bounds.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f6f87dead4bf2da20bc3a22dc6ca7a373c9ed05c/gcc%2Frust%2Ftypecheck%2Frust-tyty-bounds.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-tyty-bounds.cc?ref=f6f87dead4bf2da20bc3a22dc6ca7a373c9ed05c", "patch": "@@ -84,16 +84,71 @@ TypeCheckBase::get_predicate_from_bound (HIR::TypePath &type_path)\n     = HIR::GenericArgs::create_empty (type_path.get_locus ());\n \n   auto &final_seg = type_path.get_final_segment ();\n-  if (final_seg->is_generic_segment ())\n+  switch (final_seg->get_type ())\n     {\n-      auto final_generic_seg\n-\t= static_cast<HIR::TypePathSegmentGeneric *> (final_seg.get ());\n-      if (final_generic_seg->has_generic_args ())\n-\t{\n-\t  args = final_generic_seg->get_generic_args ();\n-\t}\n+      case HIR::TypePathSegment::SegmentType::GENERIC: {\n+\tauto final_generic_seg\n+\t  = static_cast<HIR::TypePathSegmentGeneric *> (final_seg.get ());\n+\tif (final_generic_seg->has_generic_args ())\n+\t  {\n+\t    args = final_generic_seg->get_generic_args ();\n+\t  }\n+      }\n+      break;\n+\n+      case HIR::TypePathSegment::SegmentType::FUNCTION: {\n+\tauto final_function_seg\n+\t  = static_cast<HIR::TypePathSegmentFunction *> (final_seg.get ());\n+\tauto &fn = final_function_seg->get_function_path ();\n+\n+\t// we need to make implicit generic args which must be an implicit Tuple\n+\tauto crate_num = mappings->get_current_crate ();\n+\tHirId implicit_args_id = mappings->get_next_hir_id ();\n+\tAnalysis::NodeMapping mapping (crate_num,\n+\t\t\t\t       final_seg->get_mappings ().get_nodeid (),\n+\t\t\t\t       implicit_args_id, UNKNOWN_LOCAL_DEFID);\n+\n+\tstd::vector<std::unique_ptr<HIR::Type>> params_copy;\n+\tfor (auto &p : fn.get_params ())\n+\t  {\n+\t    params_copy.push_back (p->clone_type ());\n+\t  }\n+\n+\tHIR::TupleType *implicit_tuple\n+\t  = new HIR::TupleType (mapping, std::move (params_copy),\n+\t\t\t\tfinal_seg->get_locus ());\n+\n+\tstd::vector<std::unique_ptr<HIR::Type>> inputs;\n+\tinputs.push_back (std::unique_ptr<HIR::Type> (implicit_tuple));\n+\n+\targs = HIR::GenericArgs ({} /* lifetimes */,\n+\t\t\t\t std::move (inputs) /* type_args*/,\n+\t\t\t\t {} /* binding_args*/, {} /* const_args */,\n+\t\t\t\t final_seg->get_locus ());\n+\n+\t// resolve the fn_once_output type\n+\tTyTy::BaseType *fn_once_output_ty\n+\t  = fn.has_return_type ()\n+\t      ? TypeCheckType::Resolve (fn.get_return_type ().get ())\n+\t      : TyTy::TupleType::get_unit_type (\n+\t\tfinal_seg->get_mappings ().get_hirid ());\n+\tcontext->insert_implicit_type (final_seg->get_mappings ().get_hirid (),\n+\t\t\t\t       fn_once_output_ty);\n+\n+\t// setup the associated type.. ??\n+\t// fn_once_output_ty->debug ();\n+      }\n+      break;\n+\n+    default:\n+      /* nothing to do */\n+      break;\n     }\n \n+  // FIXME\n+  // I think this should really be just be if the !args.is_empty() because\n+  // someone might wrongly apply generic arguments where they should not and\n+  // they will be missing error diagnostics\n   if (predicate.requires_generic_args ())\n     {\n       // this is applying generic arguments to a trait reference"}]}