{"sha": "3e487b219e85b65965474f9b3784cc513ab2bc2a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6M2U0ODdiMjE5ZTg1YjY1OTY1NDc0ZjliMzc4NGNjNTEzYWIyYmMyYQ==", "commit": {"author": {"name": "Zack Weinberg", "email": "zack@gcc.gnu.org", "date": "2004-10-21T00:53:47Z"}, "committer": {"name": "Zack Weinberg", "email": "zack@gcc.gnu.org", "date": "2004-10-21T00:53:47Z"}, "message": "dbxout.c (asmfile): Delete.\n\n\t* dbxout.c (asmfile): Delete.  All uses changed to asm_out_file.\n\t(DBX_BLOCKS_FUNCTION_RELATIVE, DBX_LINES_FUNCTION_RELATIVE):\n\tDefault to 0.\n\t(dbxout_source_line): Use DBX_OUTPUT_SOURCE_LINE when defined.\n\tWhen it is not, but DBX_LINES_FUNCTION_RELATIVE is true, emit\n\tan internal label and an N_SLINE .stabn whose value is the\n\tdifference between that label and the function entry label.\n\t(dbxout_finish): If DBX_OUTPUT_MAIN_SOURCE_FILE_END is not defined,\n\tbut DBX_OUTPUT_NULL_N_SO_AT_MAIN_SOURCE_FILE_END is, emit a\n\tlabel and an N_SO stab with an empty string referring to it.\n\t(dbx_output_lbrac, dbx_output_rbrac): Use if statement instead\n\tof #ifdef directive to test DBX_BLOCKS_FUNCTION_RELATIVE.\n\t(dbxout_type_methods, dbxout_symbol): Remove #if 0 block.\n\t(dbxout_prepare_symbol): Remove #ifdef WINNING_GDB block, this\n\tmacro is never defined.\n\t* sdbout.c (sdbout_source_line_counter): Delete.\n\t(PUT_SDB_SRC_FILE): Delete.  Uses replaced with sole definition.\n\t(sdbout_source_line): Use SDB_OUTPUT_SOURCE_LINE, which takes\n\tonly two arguments.\n\t* xcoffout.c (ASM_OUTPUT_SOURCE_LINE): Rename ASM_OUTPUT_LINE.\n\n\t* config/dbxcoff.h, config/dbxelf.h: Remove unncessary #undefs.\n\t* config/c4x/c4x.h, config/pa/pa.h: Remove unnecessary macro\n\tdefinitions (identical to default).\n\t* config/darwin.h, config/dbxcoff.h, config/dbxelf.h, config/ptx4.h\n\t* config/h8300/coff.h, config/pa/som.h, config/sh/elf.h:\n\tDefine DBX_OUTPUT_NULL_N_SO_AT_MAIN_SOURCE_FILE_END, not\n\tDBX_OUTPUT_MAIN_SOURCE_FILE_END.\n\t* config/dbxcoff.h, config/dbxelf.h, config/ptx4.h\n\t* config/mcore/mcore-pe.h, config/pa/som.h, config/sh/elf.h:\n\tDefine DBX_LINES_FUNCTION_RELATIVE, not ASM_OUTPUT_SOURCE_LINE.\n\t* config/alpha/alpha-protos.h: Don't prototype alpha_output_lineno.\n\t* config/alpha/alpha.c: Move declaration of num_source_filenames up.\n\t(alpha_start_function): Use SDB_OUTPUT_SOURCE_LINE.\n\t(sym_lineno): Delete.\n\t(alpha_output_filename): Do not emit N_SOL stabs here.  Remove\n\tnow-unused variable.\n\t(alpha_output_lineno): Delete.\n\t* config/mips/mips-protos.h: Don't prototype mips_output_lineno.\n\t* config/mips/mips.c (mips_output_filename): Don't use\n\tASM_OUTPUT_FILENAME. Don't emit N_SOL stabs here.\n\t(mips_output_lineno): Delete.\n\t(mips_output_function_prologue: Use SDB_OUTPUT_SOURCE_LINE.\n\t* config/alpha/alpha.h: Define DBX_OUTPUT_SOURCE_LINE and\n\tSDB_OUTPUT_SOURCE_LINE, not ASM_OUTPUT_SOURCE_LINE.\n\t* config/mips/mips.h: Likewise.  Don't define ASM_OUTPUT_FILENAME.\n\t* config/mips/sdb.h: Use SDB_OUTPUT_SOURCE_LINE.\n\t* config/avr/avr.h: Don't define ASM_OUTPUT_SOURCE_LINE.\n\t* config/mmix/mmix.h: Likewise.\n\t* config/mmix/mmix.c (mmix_asm_output_source_line): Delete.\n\t* config/mmix/mmix-protos.h: Don't prototype it.\n\t* config/alpha/unicosmk.h: Also #undef PREFERRED_DEBUGGING_TYPE;\n\tno need to #undef ASM_OUTPUT_SOURCE_LINE.\n\t* config/arm/aout.h: Remove RISCiX-specific definition of\n\tDBX_OUTPUT_MAIN_SOURCE_FILENAME.\n\t* config/m32r/m32r.h: Define DBX_OUTPUT_SOURCE_LINE, not\n\tASM_OUTPUT_SOURCE_LINE.\n\t* config/rs6000/rs6000.h: (ASM_OUTPUT_SOURCE_LINE): Rename\n\tDBX_OUTPUT_SOURCE_LINE.  Don't use current_function_func_begin_label.\n\t* config/vax/elf.h: No need to define DBX_OUTPUT_FUNCTION_END.\n\n\t* doc/tm.texi: Update.\n\nFrom-SVN: r89357", "tree": {"sha": "ea17211112b44ee6bb2818eb53ac97aadff9e550", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ea17211112b44ee6bb2818eb53ac97aadff9e550"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3e487b219e85b65965474f9b3784cc513ab2bc2a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3e487b219e85b65965474f9b3784cc513ab2bc2a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3e487b219e85b65965474f9b3784cc513ab2bc2a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3e487b219e85b65965474f9b3784cc513ab2bc2a/comments", "author": null, "committer": null, "parents": [{"sha": "310ff87213aa41d1da0c47291694e6dd52b7d277", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/310ff87213aa41d1da0c47291694e6dd52b7d277", "html_url": "https://github.com/Rust-GCC/gccrs/commit/310ff87213aa41d1da0c47291694e6dd52b7d277"}], "stats": {"total": 1008, "additions": 430, "deletions": 578}, "files": [{"sha": "7b3b80ce1826dba88dc3422a2ef4cafab52cb51a", "filename": "gcc/ChangeLog", "status": "modified", "additions": 106, "deletions": 41, "changes": 147, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3e487b219e85b65965474f9b3784cc513ab2bc2a/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3e487b219e85b65965474f9b3784cc513ab2bc2a/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=3e487b219e85b65965474f9b3784cc513ab2bc2a", "patch": "@@ -1,3 +1,68 @@\n+2004-10-20  Zack Weinberg  <zack@codesourcery.com>\n+\n+\t* dbxout.c (asmfile): Delete.  All uses changed to asm_out_file.\n+\t(DBX_BLOCKS_FUNCTION_RELATIVE, DBX_LINES_FUNCTION_RELATIVE):\n+\tDefault to 0.\n+\t(dbxout_source_line): Use DBX_OUTPUT_SOURCE_LINE when defined.\n+\tWhen it is not, but DBX_LINES_FUNCTION_RELATIVE is true, emit\n+\tan internal label and an N_SLINE .stabn whose value is the\n+\tdifference between that label and the function entry label.\n+\t(dbxout_finish): If DBX_OUTPUT_MAIN_SOURCE_FILE_END is not defined,\n+\tbut DBX_OUTPUT_NULL_N_SO_AT_MAIN_SOURCE_FILE_END is, emit a\n+\tlabel and an N_SO stab with an empty string referring to it.\n+\t(dbx_output_lbrac, dbx_output_rbrac): Use if statement instead\n+\tof #ifdef directive to test DBX_BLOCKS_FUNCTION_RELATIVE.\n+\t(dbxout_type_methods, dbxout_symbol): Remove #if 0 block.\n+\t(dbxout_prepare_symbol): Remove #ifdef WINNING_GDB block, this\n+\tmacro is never defined.\n+\t* sdbout.c (sdbout_source_line_counter): Delete.\n+\t(PUT_SDB_SRC_FILE): Delete.  Uses replaced with sole definition.\n+\t(sdbout_source_line): Use SDB_OUTPUT_SOURCE_LINE, which takes\n+\tonly two arguments.\n+\t* xcoffout.c (ASM_OUTPUT_SOURCE_LINE): Rename ASM_OUTPUT_LINE.\n+\n+\t* config/dbxcoff.h, config/dbxelf.h: Remove unncessary #undefs.\n+\t* config/c4x/c4x.h, config/pa/pa.h: Remove unnecessary macro\n+\tdefinitions (identical to default).\n+\t* config/darwin.h, config/dbxcoff.h, config/dbxelf.h, config/ptx4.h\n+\t* config/h8300/coff.h, config/pa/som.h, config/sh/elf.h:\n+\tDefine DBX_OUTPUT_NULL_N_SO_AT_MAIN_SOURCE_FILE_END, not\n+\tDBX_OUTPUT_MAIN_SOURCE_FILE_END.\n+\t* config/dbxcoff.h, config/dbxelf.h, config/ptx4.h\n+\t* config/mcore/mcore-pe.h, config/pa/som.h, config/sh/elf.h:\n+\tDefine DBX_LINES_FUNCTION_RELATIVE, not ASM_OUTPUT_SOURCE_LINE.\n+\t* config/alpha/alpha-protos.h: Don't prototype alpha_output_lineno.\n+\t* config/alpha/alpha.c: Move declaration of num_source_filenames up.\n+\t(alpha_start_function): Use SDB_OUTPUT_SOURCE_LINE.\n+\t(sym_lineno): Delete.\n+\t(alpha_output_filename): Do not emit N_SOL stabs here.  Remove\n+\tnow-unused variable.\n+\t(alpha_output_lineno): Delete.\n+\t* config/mips/mips-protos.h: Don't prototype mips_output_lineno.\n+\t* config/mips/mips.c (mips_output_filename): Don't use\n+\tASM_OUTPUT_FILENAME. Don't emit N_SOL stabs here.\n+\t(mips_output_lineno): Delete.\n+\t(mips_output_function_prologue: Use SDB_OUTPUT_SOURCE_LINE.\n+\t* config/alpha/alpha.h: Define DBX_OUTPUT_SOURCE_LINE and\n+\tSDB_OUTPUT_SOURCE_LINE, not ASM_OUTPUT_SOURCE_LINE.\n+\t* config/mips/mips.h: Likewise.  Don't define ASM_OUTPUT_FILENAME.\n+\t* config/mips/sdb.h: Use SDB_OUTPUT_SOURCE_LINE.\n+\t* config/avr/avr.h: Don't define ASM_OUTPUT_SOURCE_LINE.\n+\t* config/mmix/mmix.h: Likewise.\n+\t* config/mmix/mmix.c (mmix_asm_output_source_line): Delete.\n+\t* config/mmix/mmix-protos.h: Don't prototype it.\n+\t* config/alpha/unicosmk.h: Also #undef PREFERRED_DEBUGGING_TYPE;\n+\tno need to #undef ASM_OUTPUT_SOURCE_LINE.\n+\t* config/arm/aout.h: Remove RISCiX-specific definition of\n+\tDBX_OUTPUT_MAIN_SOURCE_FILENAME.\n+\t* config/m32r/m32r.h: Define DBX_OUTPUT_SOURCE_LINE, not\n+\tASM_OUTPUT_SOURCE_LINE.\n+\t* config/rs6000/rs6000.h: (ASM_OUTPUT_SOURCE_LINE): Rename\n+\tDBX_OUTPUT_SOURCE_LINE.  Don't use current_function_func_begin_label.\n+\t* config/vax/elf.h: No need to define DBX_OUTPUT_FUNCTION_END.\n+\n+\t* doc/tm.texi: Update.\n+\n 2004-10-20  Richard Henderson  <rth@redhat.com>\n \n \t* tree-sra.c (instantiate_element): Copy DECL_IGNORED_P also.\n@@ -141,7 +206,7 @@\n \t* c-parse.in (reservedwords): Add OBJC_TYPE_QUAL as alternative.\n \n 2004-10-18  Eric Botcazou  <ebotcazou@libertysurf.fr>\n-            Roger Sayle  <roger@eyesopen.com>\n+\t    Roger Sayle  <roger@eyesopen.com>\n \n \tPR middle-end/17813\n \t* dojump.c (discard_pending_stack_adjust): New function.\n@@ -154,7 +219,7 @@\n \n 2004-10-18  Richard Henderson  <rth@redhat.com>\n \n-\t* c-common.c (handle_mode_attribute): Allow scalar->vector \n+\t* c-common.c (handle_mode_attribute): Allow scalar->vector\n \ttype changes yet.\n \n 2004-10-18  Kazu Hirata  <kazu@cs.umass.edu>\n@@ -303,7 +368,7 @@\n \t* params.def: Add parameter to restrict the number of expansions.\n \t* params.h: (MAX_VARIABLE_EXPANSIONS): New define to restrict\n \tthe number of expansions.\n-\t* common.opt: (fvariable-expansion-in-unroller): New flag. \n+\t* common.opt: (fvariable-expansion-in-unroller): New flag.\n \t* doc/invoke.texi: (fvariable-expansion-in-unroller): Document.\n \n 2004-10-18  Danny Smith  <dannysmith@users.sourceforge.net>\n@@ -333,9 +398,9 @@\n \tRevert:\n \t2004-10-17  Andrew Pinski  <pinskia@physics.uc.edu>\n \n-        * c-typeck.c (default_function_array_conversion): Always create\n-        &a[0] for array types.\n-        (build_unary_op): Do not fold &a[x] into a + x.\n+\t* c-typeck.c (default_function_array_conversion): Always create\n+\t&a[0] for array types.\n+\t(build_unary_op): Do not fold &a[x] into a + x.\n \n 2004-10-17  Andrew Pinski  <pinskia@physics.uc.edu>\n \n@@ -534,7 +599,7 @@\n \t* tree.h (struct pointer_set_t): Declare as opaque type.\n \t(tree_walk): Last argument is pointer_set_t* now.\n \t* tree-inline.c (WALK_SUBTREE): Convert from htab to pset.\n-\t(walk_type_fields): \n+\t(walk_type_fields):\n \t(walk_tree): Convert from htab_t to pointer_set_t for keeping\n \ttrack of which nodes have already been visited.\n \t(walk_tree_without_duplicates): Convert from htab_t to pointer_set_t.\n@@ -550,7 +615,7 @@\n \t(tree-inline.o): Depends on pointer-set.h\n \t(tree-dfa.o): Likewise\n \t(cgraphunit.o): Likewise\n-\t\n+\n 2004-10-14  Geoffrey Keating  <geoffk@apple.com>\n \n \t* config/rs6000/darwin.h (ASM_SPEC): Delete.\n@@ -601,7 +666,7 @@\n \tPR 17635\n \t* tree-if-conv.c (process_phi_nodes): Process latch block.\n \t(combine_blocks): Process latch block and update loop structure.\n-\t\n+\n 2004-10-14  Olga Golovanevsky  <olga@il.ibm.com>\n \n \t* tree-vectorizer.c (vect_generate_tmps_on_preheader):\n@@ -621,15 +686,15 @@\n \t(tree_duplicate_loop_to_edge_cfg):\n \t(add_loop_guard):\n \t(vect_analyze_loop_with_symbolic_num_of_iters):\n-\t(verify_loop_for_duplication): \n+\t(verify_loop_for_duplication):\n \t(vect_gen_niters_for_prolog_loop):\n \t(vect_update_niters_after_peeling):\n \t(vect_update_inits_of_dr):\n \t(vect_update_inits_of_drs):\n \t(vect_build_loop_niters):\n \t(vect_do_peeling_for_alignment): New functions.\n \t(vect_transform_loop): Add unknown and known but indivisible loop\n-\tbound support; add peeling for unalignment support. \n+\tbound support; add peeling for unalignment support.\n \t(vect_analyze_loop_form): Support symbolic number of iterations.\n \t(vect_transform_loop_bound): New input parameter.\n \t(vect_get_loop_niters): Change input parameter type.\n@@ -638,7 +703,7 @@\n \t(vectorize_loops): Add rewrite_into_loop_closed_ssa.\n \t(vect_analyze_data_refs_alignment): Allowed one unaligned\n \tstore.\n-\t* tree-vectorizer.h (LOOP_VINFO_NITERS_KNOWN_P): Redefined \n+\t* tree-vectorizer.h (LOOP_VINFO_NITERS_KNOWN_P): Redefined\n \tto use tree.\n \t(LOOP_VINFO_INT_NITERS): New macro.\n \t(MAX_NUMBER_OF_UNALIGNED_DATA_REFS): New define.\n@@ -738,18 +803,18 @@\n \n 2004-10-13  Richard Henderson  <rth@redhat.com>\n \n-        PR c/17384\n-        * c-common.c (handle_mode_attribute): Disallow mode changes that\n-        alter the CODE of the top-level type.\n- \n-        * crtstuff.c (__FRAME_END__): Remove mode attribute.  Find 32-bit\n-        integer from internal limits macros.\n-        * config/i386/mm3dnow.h (__v2sf): Fix base type.\n+\tPR c/17384\n+\t* c-common.c (handle_mode_attribute): Disallow mode changes that\n+\talter the CODE of the top-level type.\n+\n+\t* crtstuff.c (__FRAME_END__): Remove mode attribute.  Find 32-bit\n+\tinteger from internal limits macros.\n+\t* config/i386/mm3dnow.h (__v2sf): Fix base type.\n \n 2004-10-13  Richard Henderson  <rth@redhat.com>\n- \n-        PR debug/13841\n-        * function.c (instantiate_decl): Recurse for CONCAT.\n+\n+\tPR debug/13841\n+\t* function.c (instantiate_decl): Recurse for CONCAT.\n \n 2004-10-13  David Edelsohn  <edelsohn@gnu.org>\n \n@@ -848,56 +913,56 @@\n \n \t* Makefile.in (tree-ssa-loop-niter.o): Depends on tree-data-ref.h.\n \t* cfgloop.c (initialize_loops_parallel_p): New.\n-\t(flow_loops_find): Initialize the parallel_p field to true for all \n+\t(flow_loops_find): Initialize the parallel_p field to true for all\n \tthe loops.\n \t* tree-ssa-loop-niter.c: Include \"tree-data-ref.h\".\n-\t(estimate_numbers_of_iterations_loop): Infers the loop bounds from \n+\t(estimate_numbers_of_iterations_loop): Infers the loop bounds from\n \tthe size of the data accessed in the loop.\n-\t(struct nb_iter_bound): Moved... \n+\t(struct nb_iter_bound): Moved...\n \t* cfgloop.h (struct nb_iter_bound): ... here.\n \t(estimated_nb_iterations, parallel_p): New fields in struct loop.\n \t(record_estimate): Declare extern here.\n \t* tree-chrec.c: Fix comments.\n \t(nb_vars_in_chrec): New function.\n \t* tree-chrec.h (nb_vars_in_chrec): Declared here.\n-\t* tree-data-ref.c: Don't include lambda.h, that is already included \n+\t* tree-data-ref.c: Don't include lambda.h, that is already included\n \tin tree-data-ref.h.\n \t(tree_fold_divides_p): Don't check for integer_onep.\n \t(tree_fold_bezout): Removed.\n \t(gcd): New static duplicated function.\n \t(int_divides_p, dump_subscript): New.\n \t(dump_data_dependence_relation): Use dump_subscript.\n-\t(dump_dist_dir_vectors, dump_ddrs, compute_estimated_nb_iterations, \n+\t(dump_dist_dir_vectors, dump_ddrs, compute_estimated_nb_iterations,\n \testimate_niter_from_size_of_data): New.\n-\t(analyze_array_indexes, analyze_array): Call \n-\testimate_niter_from_size_of_data during\tthe detection of array \n-\treferences.  Pass in a pointer to the statement that contains the \n+\t(analyze_array_indexes, analyze_array): Call\n+\testimate_niter_from_size_of_data during\tthe detection of array\n+\treferences.  Pass in a pointer to the statement that contains the\n \tarray reference.\n \t(all_chrecs_equal_p): New.\n \t(compute_distance_vector): Renamed compute_subscript_distance.\n \tDeal with multivariate conflict functions.\n-\t(initialize_data_dependence_relation): Initialize DDR_AFFINE_P, \n+\t(initialize_data_dependence_relation): Initialize DDR_AFFINE_P,\n \tDDR_SIZE_VECT, DDR_DIST_VECT, and DDR_DIR_VECT.\n \t(non_affine_dependence_relation): New.\n-\t(analyze_ziv_subscript, analyze_siv_subscript_cst_affine, \n-\tanalyze_siv_subscript, analyze_miv_subscript, \n-\tanalyze_overlapping_iterations, subscript_dependence_tester): \n+\t(analyze_ziv_subscript, analyze_siv_subscript_cst_affine,\n+\tanalyze_siv_subscript, analyze_miv_subscript,\n+\tanalyze_overlapping_iterations, subscript_dependence_tester):\n \tInitialize and return last_conflicts function.\n \t(initialize_matrix_A, FLOOR, compute_overlap_steps_for_affine_univar,\n \tcompute_overlap_steps_for_affine_1_2): New.\n \t(analyze_siv_subscript_affine_cst): Removed.\n-\t(analyze_subscript_affine_affine): Disprove dependences based on the \n-\titeration domains.  Solve the univariate dependence case as before, \n+\t(analyze_subscript_affine_affine): Disprove dependences based on the\n+\titeration domains.  Solve the univariate dependence case as before,\n \tbut use lambda_matrix_right_hermite instead of tree_fold_bezout.\n \tImplement the multivariate case of 2 versus 1 variables.\n-\t(build_classic_dist_vector, build_classic_dir_vector): Implement some \n+\t(build_classic_dist_vector, build_classic_dir_vector): Implement some\n \tunhandled cases.\n-\t(find_data_references_in_loop): Compute and initialize \n+\t(find_data_references_in_loop): Compute and initialize\n \tloop->estimated_nb_iterations and loop->parallel_p.\n \t(analyze_all_data_dependences): Modify the debug dump order.\n \t* tree-data-ref.h (SUB_LAST_CONFLICT_IN_A, SUB_LAST_CONFLICT_IN_B,\n \tsubscript->last_conflict_in_a, subscript->last_conflict_in_b): Removed.\n-\t(SUB_LAST_CONFLICT, subscript->last_conflict, \n+\t(SUB_LAST_CONFLICT, subscript->last_conflict,\n \tdata_dependence_relation->affine_p, data_dependence_relation->size_vect,\n \tDDR_AFFINE_P, DDR_SIZE_VECT): New.\n \t(find_data_references_in_loop, initialize_data_dependence_relation,\n@@ -912,7 +977,7 @@\n \tPR 17892\n \t* tree-ssa-dom.c (unsafe_associative_fp_binop): New function.\n \t(simplify_rhs_and_lookup_avail_expr): Disallow associativity\n-\tand constant folding of floating point MULT_EXPR/PLUS_EXPR \n+\tand constant folding of floating point MULT_EXPR/PLUS_EXPR\n \texpressions.\n \n 2004-10-12  Ulrich Weigand  <uweigand@de.ibm.com>\n@@ -1054,7 +1119,7 @@\n \tPR middle-end/17657\n \t* stmt.c (add_case_node): Add additional type argument.  Declare\n \tas static to match prototype.  Convert the upper and lower bounds\n-\tto the specified index type.  Optimize away case ranges/values \n+\tto the specified index type.  Optimize away case ranges/values\n \tthat are outside the index type's bounds.  Truncate case ranges\n \tthat span the index type's bounds.\n \t(expand_case): Avoid unnessary computation and memory allocation"}, {"sha": "07d70649908fc89fb7776f6e39dd33cd75d67373", "filename": "gcc/config/alpha/alpha-protos.h", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3e487b219e85b65965474f9b3784cc513ab2bc2a/gcc%2Fconfig%2Falpha%2Falpha-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3e487b219e85b65965474f9b3784cc513ab2bc2a/gcc%2Fconfig%2Falpha%2Falpha-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Falpha%2Falpha-protos.h?ref=3e487b219e85b65965474f9b3784cc513ab2bc2a", "patch": "@@ -34,7 +34,6 @@ extern int alpha_using_fp (void);\n extern void alpha_expand_prologue (void);\n extern void alpha_expand_epilogue (void);\n extern void alpha_output_filename (FILE *, const char *);\n-extern void alpha_output_lineno (FILE *, int);\n \n extern bool alpha_const_ok_for_letter_p (HOST_WIDE_INT, int);\n extern bool alpha_const_double_ok_for_letter_p (rtx, int);"}, {"sha": "eeff191dd2ab4b46cbd00d5a906a13ce899e2d75", "filename": "gcc/config/alpha/alpha.c", "status": "modified", "additions": 8, "deletions": 34, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3e487b219e85b65965474f9b3784cc513ab2bc2a/gcc%2Fconfig%2Falpha%2Falpha.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3e487b219e85b65965474f9b3784cc513ab2bc2a/gcc%2Fconfig%2Falpha%2Falpha.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Falpha%2Falpha.c?ref=3e487b219e85b65965474f9b3784cc513ab2bc2a", "patch": "@@ -6547,6 +6547,9 @@ alpha_expand_prologue (void)\n     emit_insn (gen_blockage ());\n }\n \n+/* Count the number of .file directives, so that .loc is up to date.  */\n+static int num_source_filenames = 0;\n+\n /* Output the textual info surrounding the prologue.  */\n \n void\n@@ -6613,10 +6616,10 @@ alpha_start_function (FILE *file, const char *fnname,\n       ASM_OUTPUT_SOURCE_FILENAME (file,\n \t\t\t\t  DECL_SOURCE_FILE (current_function_decl));\n #endif\n-#ifdef ASM_OUTPUT_SOURCE_LINE\n+#ifdef SDB_OUTPUT_SOURCE_LINE\n       if (debug_info_level != DINFO_LEVEL_TERSE)\n-        ASM_OUTPUT_SOURCE_LINE (file,\n-\t\t\t\tDECL_SOURCE_LINE (current_function_decl), 0);\n+        SDB_OUTPUT_SOURCE_LINE (file,\n+\t\t\t\tDECL_SOURCE_LINE (current_function_decl));\n #endif\n     }\n \n@@ -7149,14 +7152,6 @@ alpha_output_mi_thunk_osf (FILE *file, tree thunk_fndecl ATTRIBUTE_UNUSED,\n \n int sdb_label_count = 0;\n \n-/* Next label # for each statement.  */\n-\n-static int sym_lineno = 0;\n-\n-/* Count the number of .file directives, so that .loc is up to date.  */\n-\n-static int num_source_filenames = 0;\n-\n /* Name of the file containing the current function.  */\n \n static const char *current_function_file = \"\";\n@@ -7172,7 +7167,6 @@ void\n alpha_output_filename (FILE *stream, const char *name)\n {\n   static int first_time = TRUE;\n-  char ltext_label_name[100];\n \n   if (first_time)\n     {\n@@ -7187,12 +7181,8 @@ alpha_output_filename (FILE *stream, const char *name)\n     }\n \n   else if (write_symbols == DBX_DEBUG)\n-    {\n-      ASM_GENERATE_INTERNAL_LABEL (ltext_label_name, \"Ltext\", 0);\n-      fprintf (stream, \"%s\", ASM_STABS_OP);\n-      output_quoted_string (stream, name);\n-      fprintf (stream, \",%d,0,0,%s\\n\", N_SOL, &ltext_label_name[1]);\n-    }\n+    /* dbxout.c will emit an appropriate .stabs directive.  */\n+    return;\n \n   else if (name != current_function_file\n \t   && strcmp (name, current_function_file) != 0)\n@@ -7210,22 +7200,6 @@ alpha_output_filename (FILE *stream, const char *name)\n       fprintf (stream, \"\\n\");\n     }\n }\n-\n-/* Emit a linenumber to a stream.  */\n-\n-void\n-alpha_output_lineno (FILE *stream, int line)\n-{\n-  if (write_symbols == DBX_DEBUG)\n-    {\n-      /* mips-tfile doesn't understand .stabd directives.  */\n-      ++sym_lineno;\n-      fprintf (stream, \"$LM%d:\\n%s%d,0,%d,$LM%d\\n\",\n-\t       sym_lineno, ASM_STABN_OP, N_SLINE, line, sym_lineno);\n-    }\n-  else\n-    fprintf (stream, \"\\n\\t.loc\\t%d %d\\n\", num_source_filenames, line);\n-}\n \f\n /* Structure to show the current status of registers and memory.  */\n "}, {"sha": "edda309d1beb14fc5bd1a91906d34ada961f9d61", "filename": "gcc/config/alpha/alpha.h", "status": "modified", "additions": 8, "deletions": 3, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3e487b219e85b65965474f9b3784cc513ab2bc2a/gcc%2Fconfig%2Falpha%2Falpha.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3e487b219e85b65965474f9b3784cc513ab2bc2a/gcc%2Fconfig%2Falpha%2Falpha.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Falpha%2Falpha.h?ref=3e487b219e85b65965474f9b3784cc513ab2bc2a", "patch": "@@ -1661,9 +1661,14 @@ extern long alpha_auto_offset;\n   ((GET_CODE (X) == PLUS ? INTVAL (XEXP (X, 1)) : 0) + alpha_auto_offset)\n #define DEBUGGER_ARG_OFFSET(OFFSET, X) (OFFSET + alpha_arg_offset)\n \n-\n-#define ASM_OUTPUT_SOURCE_LINE(STREAM, LINE, COUNTER)\t\t\t\\\n-  alpha_output_lineno (STREAM, LINE)\n+/* mips-tfile doesn't understand .stabd directives.  */\n+#define DBX_OUTPUT_SOURCE_LINE(STREAM, LINE, COUNTER)\t\t\t\\\n+  fprintf (STREAM, \"$LM%d:\\n%s%d,0,%d,$LM%d\\n\", COUNTER, ASM_STABN_OP,\t\\\n+           N_SLINE, LINE, COUNTER)\n+\n+/* We want to use MIPS-style .loc directives for SDB line numbers.  */\n+#define SDB_OUTPUT_SOURCE_LINE(STREAM, LINE)\t\\\n+  fprintf (STREAM, \"\\t.loc\\t%d %d\", num_source_filenames, LINE)\n \n #define ASM_OUTPUT_SOURCE_FILENAME(STREAM, NAME)\t\t\t\\\n   alpha_output_filename (STREAM, NAME)"}, {"sha": "1f6be35e09b0dd66236d46b63b729ceb2b482ff1", "filename": "gcc/config/alpha/unicosmk.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3e487b219e85b65965474f9b3784cc513ab2bc2a/gcc%2Fconfig%2Falpha%2Funicosmk.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3e487b219e85b65965474f9b3784cc513ab2bc2a/gcc%2Fconfig%2Falpha%2Funicosmk.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Falpha%2Funicosmk.h?ref=3e487b219e85b65965474f9b3784cc513ab2bc2a", "patch": "@@ -470,7 +470,7 @@ ssib_section (void)\t\t\\\n #undef DWARF2_DEBUGGING_INFO\n #undef DWARF2_UNWIND_INFO\n #undef INCOMING_RETURN_ADDR_RTX\n-#undef ASM_OUTPUT_SOURCE_LINE\n+#undef PREFERRED_DEBUGGING_TYPE\n \n /* We don't need a start file.  */\n "}, {"sha": "91fc6d266c17b348545b6f9376cb7ce23a0d3b8f", "filename": "gcc/config/arm/aout.h", "status": "modified", "additions": 0, "deletions": 13, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3e487b219e85b65965474f9b3784cc513ab2bc2a/gcc%2Fconfig%2Farm%2Faout.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3e487b219e85b65965474f9b3784cc513ab2bc2a/gcc%2Fconfig%2Farm%2Faout.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Faout.h?ref=3e487b219e85b65965474f9b3784cc513ab2bc2a", "patch": "@@ -193,19 +193,6 @@\n #define DBX_CONTIN_LENGTH  0\n #endif\n \n-/* Output a source filename for the debugger. RISCiX dbx insists that the\n-   ``desc'' field is set to compiler version number >= 315 (sic).  */\n-#define DBX_OUTPUT_MAIN_SOURCE_FILENAME(STREAM, NAME)\t\t\t\\\n-  do\t\t\t\t\t\t\t\t\t\\\n-    {\t\t\t\t\t\t\t\t\t\\\n-      fprintf (STREAM, \".stabs \");\t\t\t\t\t\\\n-      output_quoted_string (STREAM, NAME);\t\t\t\t\\\n-      fprintf (STREAM, \",%d,0,315,%s\\n\", N_SO, &ltext_label_name[1]);\t\\\n-      text_section ();\t\t\t\t\t\t\t\\\n-      (*targetm.asm_out.internal_label) (STREAM, \"Ltext\", 0);\t\t\t\\\n-    }\t\t\t\t\t\t\t\t\t\\\n-  while (0)\n-  \n /* Output a function label definition.  */\n #ifndef ASM_DECLARE_FUNCTION_NAME\n #define ASM_DECLARE_FUNCTION_NAME(STREAM, NAME, DECL)\t\\"}, {"sha": "669ca36d26a230d17a2a17b596c812c3f4d09ceb", "filename": "gcc/config/avr/avr.h", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3e487b219e85b65965474f9b3784cc513ab2bc2a/gcc%2Fconfig%2Favr%2Favr.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3e487b219e85b65965474f9b3784cc513ab2bc2a/gcc%2Fconfig%2Favr%2Favr.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Favr%2Favr.h?ref=3e487b219e85b65965474f9b3784cc513ab2bc2a", "patch": "@@ -557,9 +557,6 @@ progmem_section (void)\t\t\t\t\t\t\t      \\\n \n #define ASM_APP_OFF \"/* #NOAPP */\\n\"\n \n-#define ASM_OUTPUT_SOURCE_LINE(STREAM, LINE, COUNTER) \\\n-  fprintf (STREAM,\"/* line: %d */\\n\",LINE)\n-\n /* Switch into a generic section.  */\n #define TARGET_ASM_NAMED_SECTION default_elf_asm_named_section\n "}, {"sha": "d514e5aa80641b6573ab1fb3dc3dc9c98860e57f", "filename": "gcc/config/c4x/c4x.h", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3e487b219e85b65965474f9b3784cc513ab2bc2a/gcc%2Fconfig%2Fc4x%2Fc4x.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3e487b219e85b65965474f9b3784cc513ab2bc2a/gcc%2Fconfig%2Fc4x%2Fc4x.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fc4x%2Fc4x.h?ref=3e487b219e85b65965474f9b3784cc513ab2bc2a", "patch": "@@ -1452,8 +1452,6 @@ fini_section ()\t\t\t\t\t\t\t\\\n     }\t\t\t\t\t\t\t\t\\\n }\n \n-#define ASM_STABS_OP \"\\t.stabs\\t\"\n-\n /* Switch into a generic section.  */\n #define TARGET_ASM_NAMED_SECTION c4x_asm_named_section\n "}, {"sha": "554ae9f89ed96efffca3fd0865d14a9c27285de1", "filename": "gcc/config/darwin.h", "status": "modified", "additions": 1, "deletions": 6, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3e487b219e85b65965474f9b3784cc513ab2bc2a/gcc%2Fconfig%2Fdarwin.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3e487b219e85b65965474f9b3784cc513ab2bc2a/gcc%2Fconfig%2Fdarwin.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fdarwin.h?ref=3e487b219e85b65965474f9b3784cc513ab2bc2a", "patch": "@@ -362,12 +362,7 @@ extern const char *darwin_fix_and_continue_switch;\n \n /* gdb needs a null N_SO at the end of each file for scattered loading.  */\n \n-#undef\tDBX_OUTPUT_MAIN_SOURCE_FILE_END\n-#define DBX_OUTPUT_MAIN_SOURCE_FILE_END(FILE, FILENAME)\t\t\t\\\n-do { text_section ();\t\t\t\t\t\t\t\\\n-     fprintf (FILE,\t\t\t\t\t\t\t\\\n-\t      \"\\t.stabs \\\"%s\\\",%d,0,0,Letext\\nLetext:\\n\", \"\" , N_SO);\t\\\n-   } while (0)\n+#define DBX_OUTPUT_NULL_N_SO_AT_MAIN_SOURCE_FILE_END\n \n /* Making a symbols weak on Darwin requires more than just setting DECL_WEAK. */\n #define MAKE_DECL_ONE_ONLY(DECL) darwin_make_decl_one_only (DECL)"}, {"sha": "e9e9acaec75bbc1cdf4bcf7db8b0ee60a810f2ac", "filename": "gcc/config/dbxcoff.h", "status": "modified", "additions": 2, "deletions": 23, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3e487b219e85b65965474f9b3784cc513ab2bc2a/gcc%2Fconfig%2Fdbxcoff.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3e487b219e85b65965474f9b3784cc513ab2bc2a/gcc%2Fconfig%2Fdbxcoff.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fdbxcoff.h?ref=3e487b219e85b65965474f9b3784cc513ab2bc2a", "patch": "@@ -34,43 +34,22 @@ Boston, MA 02111-1307, USA.  */\n \n /* Be function-relative for block and source line stab directives.  */\n \n-#undef DBX_BLOCKS_FUNCTION_RELATIVE\n #define DBX_BLOCKS_FUNCTION_RELATIVE 1\n \n /* but, to make this work, functions must appear prior to line info.  */\n \n-#undef DBX_FUNCTION_FIRST\n #define DBX_FUNCTION_FIRST\n \n /* Generate a blank trailing N_SO to mark the end of the .o file, since\n    we can't depend upon the linker to mark .o file boundaries with\n    embedded stabs.  */\n \n-#undef DBX_OUTPUT_MAIN_SOURCE_FILE_END\n-#define DBX_OUTPUT_MAIN_SOURCE_FILE_END(FILE, FILENAME)\t\t\t\\\n-  asm_fprintf (FILE,\t\t\t\t\t\t\t\\\n-\t       \"\\t.text\\n\\t.stabs \\\"\\\",%d,0,0,%LLetext\\n%LLetext:\\n\", N_SO)\n+#define DBX_OUTPUT_NULL_N_SO_AT_MAIN_SOURCE_FILE_END\n \n /* Like block addresses, stabs line numbers are relative to the\n    current function.  */\n \n-#undef ASM_OUTPUT_SOURCE_LINE\n-#define ASM_OUTPUT_SOURCE_LINE(FILE, LINE, COUNTER)\t\t\\\n-{ if (write_symbols == SDB_DEBUG) {\t\t\t\t\\\n-    fprintf ((FILE), \"\\t.ln\\t%d\\n\",\t\t\t\t\\\n-\t     ((sdb_begin_function_line > -1)\t\t\t\\\n-\t      ? (LINE) - sdb_begin_function_line : 1));\t\t\\\n-  } else if (write_symbols == DBX_DEBUG) {\t\t\t\\\n-    char buffer[256];\t\t\t\t\t\t\\\n-    ASM_GENERATE_INTERNAL_LABEL (buffer, \"LM\", COUNTER);\t\\\n-    fprintf (FILE, \".stabn 68,0,%d,\", LINE);\t\t\t\\\n-    assemble_name (FILE, buffer);\t\t\t\t\\\n-    putc ('-', FILE);\t\t\t\t\t\t\\\n-    assemble_name (FILE,\t\t\t\t\t\\\n-\t\t   XSTR (XEXP (DECL_RTL (current_function_decl), 0), 0)); \\\n-    putc ('\\n', FILE);\t\t\t\t\t\t\\\n-    (*targetm.asm_out.internal_label) (FILE, \"LM\", COUNTER);\t\\\n-  } }\n+#define DBX_LINES_FUNCTION_RELATIVE 1\n \n /* When generating stabs debugging, use N_BINCL entries.  */\n "}, {"sha": "b26b005a8646e2457d7997d985332cd6c25a6ca5", "filename": "gcc/config/dbxelf.h", "status": "modified", "additions": 2, "deletions": 22, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3e487b219e85b65965474f9b3784cc513ab2bc2a/gcc%2Fconfig%2Fdbxelf.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3e487b219e85b65965474f9b3784cc513ab2bc2a/gcc%2Fconfig%2Fdbxelf.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fdbxelf.h?ref=3e487b219e85b65965474f9b3784cc513ab2bc2a", "patch": "@@ -34,17 +34,14 @@ Boston, MA 02111-1307, USA.  */\n    way, gdb expects it, and it reduces the number of relocation\n    entries...  */\n \n-#undef  DBX_BLOCKS_FUNCTION_RELATIVE\n #define DBX_BLOCKS_FUNCTION_RELATIVE 1\n \n /* ... but, to make this work, functions must appear prior to line info.  */\n \n-#undef  DBX_FUNCTION_FIRST\n #define DBX_FUNCTION_FIRST\n \n /* When generating stabs debugging, use N_BINCL entries.  */\n \n-#undef  DBX_USE_BINCL\n #define DBX_USE_BINCL\n \n /* There is no limit to the length of stabs strings.  */\n@@ -56,29 +53,12 @@ Boston, MA 02111-1307, USA.  */\n /* Like block addresses, stabs line numbers are relative to the\n    current function.  */\n \n-#undef  ASM_OUTPUT_SOURCE_LINE\n-#define ASM_OUTPUT_SOURCE_LINE(FILE, LINE, COUNTER)\t\t\t\\\n-do\t\t\t\t\t\t\t\t\t\\\n-  {\t\t\t\t\t\t\t\t\t\\\n-    char temp[256];\t\t\t\t\t\t\t\\\n-    ASM_GENERATE_INTERNAL_LABEL (temp, \"LM\", COUNTER);\t\t\t\\\n-    fprintf (FILE, \"\\t.stabn 68,0,%d,\", LINE);\t\t\t\t\\\n-    assemble_name (FILE, temp);\t\t\t\t\t\t\\\n-    putc ('-', FILE);\t\t\t\t\t\t\t\\\n-    assemble_name (FILE,\t\t\t\t\t\t\\\n-\t\t   XSTR (XEXP (DECL_RTL (current_function_decl), 0), 0));\\\n-    putc ('\\n', FILE);\t\t\t\t\t\t\t\\\n-    (*targetm.asm_out.internal_label) (FILE, \"LM\", COUNTER);\t\t\\\n-  }\t\t\t\t\t\t\t\t\t\\\n-while (0)\n+#define DBX_LINES_FUNCTION_RELATIVE 1\n \n /* Generate a blank trailing N_SO to mark the end of the .o file, since\n    we can't depend upon the linker to mark .o file boundaries with\n    embedded stabs.  */\n \n-#undef  DBX_OUTPUT_MAIN_SOURCE_FILE_END\n-#define DBX_OUTPUT_MAIN_SOURCE_FILE_END(FILE, FILENAME)\t\t\t\\\n-  asm_fprintf (FILE,\t\t\t\t\t\t\t\\\n-\t       \"\\t.text\\n\\t.stabs \\\"\\\",%d,0,0,%LLetext\\n%LLetext:\\n\", N_SO)\n+#define DBX_OUTPUT_NULL_N_SO_AT_MAIN_SOURCE_FILE_END\n \n #endif /* ! GCC_DBX_ELF_H */"}, {"sha": "0420277d0782049ee60d8dc7bc43682a91034fd0", "filename": "gcc/config/h8300/coff.h", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3e487b219e85b65965474f9b3784cc513ab2bc2a/gcc%2Fconfig%2Fh8300%2Fcoff.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3e487b219e85b65965474f9b3784cc513ab2bc2a/gcc%2Fconfig%2Fh8300%2Fcoff.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fh8300%2Fcoff.h?ref=3e487b219e85b65965474f9b3784cc513ab2bc2a", "patch": "@@ -27,15 +27,11 @@ Boston, MA 02111-1307, USA.  */\n #define SDB_DEBUGGING_INFO 1\n #define SDB_DELIM\t\"\\n\"\n \n-/* Override definition in dbxcoff.h.  */\n /* Generate a blank trailing N_SO to mark the end of the .o file, since\n    we can't depend upon the linker to mark .o file boundaries with\n    embedded stabs.  */\n \n-#undef DBX_OUTPUT_MAIN_SOURCE_FILE_END\n-#define DBX_OUTPUT_MAIN_SOURCE_FILE_END(FILE, FILENAME)\t\t\t\\\n-  fprintf (FILE,\t\t\t\t\t\t\t\\\n-\t   \"\\t.text\\n.stabs \\\"\\\",%d,0,0,.Letext\\n.Letext:\\n\", N_SO)\n+#define DBX_OUTPUT_NULL_N_SO_AT_MAIN_SOURCE_FILE_END\n \n /* This is how to output an assembler line\n    that says to advance the location counter by SIZE bytes.  */"}, {"sha": "5513feadfbb3d5014404ee7ed9afd473342f9823", "filename": "gcc/config/m32r/m32r.h", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3e487b219e85b65965474f9b3784cc513ab2bc2a/gcc%2Fconfig%2Fm32r%2Fm32r.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3e487b219e85b65965474f9b3784cc513ab2bc2a/gcc%2Fconfig%2Fm32r%2Fm32r.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm32r%2Fm32r.h?ref=3e487b219e85b65965474f9b3784cc513ab2bc2a", "patch": "@@ -1525,8 +1525,7 @@ L2:     .word STATIC\n    a word so don't ever force line number labels to begin at the beginning\n    of a word.  */\n \n-#undef\tASM_OUTPUT_SOURCE_LINE\n-#define ASM_OUTPUT_SOURCE_LINE(file, line, counter)\t\t\t\\\n+#define DBX_OUTPUT_SOURCE_LINE(file, line, counter)\t\t\t\\\n   do\t\t\t\t\t\t\t\t\t\\\n     {\t\t\t\t\t\t\t\t\t\\\n       fprintf (file, \".stabn 68,0,%d,.LM%d-\",\t\t\t\t\\"}, {"sha": "224f3423981ccb2cbebf4f2af33932d4ee8cad22", "filename": "gcc/config/mcore/mcore-pe.h", "status": "modified", "additions": 1, "deletions": 17, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3e487b219e85b65965474f9b3784cc513ab2bc2a/gcc%2Fconfig%2Fmcore%2Fmcore-pe.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3e487b219e85b65965474f9b3784cc513ab2bc2a/gcc%2Fconfig%2Fmcore%2Fmcore-pe.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmcore%2Fmcore-pe.h?ref=3e487b219e85b65965474f9b3784cc513ab2bc2a", "patch": "@@ -104,23 +104,7 @@ drectve_section ()\t\t\t\t\t\t\\\n \n #define TARGET_ASM_FILE_START_FILE_DIRECTIVE true\n \n-#undef  ASM_OUTPUT_SOURCE_LINE\n-#define ASM_OUTPUT_SOURCE_LINE(FILE, LINE, COUNTER)\t\t\t  \\\n-  {\t\t\t\t\t\t\t\t\t  \\\n-    if (write_symbols == DBX_DEBUG)\t\t\t\t\t  \\\n-      {\t\t\t\t\t\t\t\t\t  \\\n-        char buffer[256];\t\t\t\t\t\t  \\\n-\t\t\t\t\t\t\t\t\t  \\\n-        ASM_GENERATE_INTERNAL_LABEL (buffer, \"LM\", COUNTER);\t\t  \\\n-        fprintf (FILE, \".stabn 68,0,%d,\", LINE);\t\t\t  \\\n-        assemble_name (FILE, buffer);\t\t\t\t\t  \\\n-        putc ('-', FILE);\t\t\t\t\t\t  \\\n-        assemble_name (FILE,\t\t\t\t\t\t  \\\n-\t\t   XSTR (XEXP (DECL_RTL (current_function_decl), 0), 0)); \\\n-        putc ('\\n', FILE);\t\t\t\t\t\t  \\\n-        (*targetm.asm_out.internal_label) (FILE, \"LM\", COUNTER);\t  \\\n-      }\t\t\t\t\t\t\t\t\t  \\\n-  }\n+#define DBX_LINES_FUNCTION_RELATIVE 1\n \n #define STARTFILE_SPEC \"crt0.o%s\"\n #define ENDFILE_SPEC  \"%{!mno-lsim:-lsim}\""}, {"sha": "834c41d1a8ebd3342c8f81dc476304a9f420b6ed", "filename": "gcc/config/mips/mips-protos.h", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3e487b219e85b65965474f9b3784cc513ab2bc2a/gcc%2Fconfig%2Fmips%2Fmips-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3e487b219e85b65965474f9b3784cc513ab2bc2a/gcc%2Fconfig%2Fmips%2Fmips-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips-protos.h?ref=3e487b219e85b65965474f9b3784cc513ab2bc2a", "patch": "@@ -158,7 +158,6 @@ extern void print_operand (FILE *, rtx, int);\n extern void print_operand_address (FILE *, rtx);\n extern int mips_output_external (FILE *, tree, const char *);\n extern void mips_output_filename (FILE *, const char *);\n-extern void mips_output_lineno (FILE *, int);\n extern void mips_output_ascii (FILE *, const char *, size_t, const char *);\n extern void mips_output_aligned_bss (FILE *, tree, const char *,\n \t\t\t\t     unsigned HOST_WIDE_INT, int);"}, {"sha": "a109b82a099b64c5e2e6bfdf0e587c5dc60c6f92", "filename": "gcc/config/mips/mips.c", "status": "modified", "additions": 10, "deletions": 30, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3e487b219e85b65965474f9b3784cc513ab2bc2a/gcc%2Fconfig%2Fmips%2Fmips.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3e487b219e85b65965474f9b3784cc513ab2bc2a/gcc%2Fconfig%2Fmips%2Fmips.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips.c?ref=3e487b219e85b65965474f9b3784cc513ab2bc2a", "patch": "@@ -5069,44 +5069,24 @@ mips_output_filename (FILE *stream, const char *name)\n       mips_output_filename_first_time = 0;\n       num_source_filenames += 1;\n       current_function_file = name;\n-      ASM_OUTPUT_FILENAME (stream, num_source_filenames, name);\n+      fprintf (stream, \"\\t.file\\t%d \", num_source_filenames);\n+      output_quoted_string (stream, name);\n+      putc ('\\n', stream);\n     }\n \n+  /* If we are emitting stabs, let dbxout.c handle this (except for\n+     the mips_output_filename_first_time case).  */\n   else if (write_symbols == DBX_DEBUG)\n-    {\n-      ASM_GENERATE_INTERNAL_LABEL (ltext_label_name, \"Ltext\", 0);\n-      fputs (\"\\t.stabs\\t\", stream);\n-      output_quoted_string (stream, name);\n-      fprintf (stream, \",%d,0,0,%s\\n\", N_SOL, &ltext_label_name[1]);\n-    }\n+    return;\n \n   else if (name != current_function_file\n \t   && strcmp (name, current_function_file) != 0)\n     {\n       num_source_filenames += 1;\n       current_function_file = name;\n-      ASM_OUTPUT_FILENAME (stream, num_source_filenames, name);\n-    }\n-}\n-\f\n-/* Emit a linenumber.  For encapsulated stabs, we need to put out a stab\n-   as well as a .loc, since it is possible that MIPS ECOFF might not be\n-   able to represent the location for inlines that come from a different\n-   file.  */\n-\n-void\n-mips_output_lineno (FILE *stream, int line)\n-{\n-  if (write_symbols == DBX_DEBUG)\n-    {\n-      ++sym_lineno;\n-      fprintf (stream, \"%sLM%d:\\n\\t.stabn\\t%d,0,%d,%sLM%d\\n\",\n-\t       LOCAL_LABEL_PREFIX, sym_lineno, N_SLINE, line,\n-\t       LOCAL_LABEL_PREFIX, sym_lineno);\n-    }\n-  else\n-    {\n-      fprintf (stream, \"\\n\\t.loc\\t%d %d\\n\", num_source_filenames, line);\n+      fprintf (stream, \"\\t.file\\t%d \", num_source_filenames);\n+      output_quoted_string (stream, name);\n+      putc ('\\n', stream);\n     }\n }\n \f\n@@ -5963,7 +5943,7 @@ mips_output_function_prologue (FILE *file, HOST_WIDE_INT size ATTRIBUTE_UNUSED)\n \n #ifdef SDB_DEBUGGING_INFO\n   if (debug_info_level != DINFO_LEVEL_TERSE && write_symbols == SDB_DEBUG)\n-    ASM_OUTPUT_SOURCE_LINE (file, DECL_SOURCE_LINE (current_function_decl), 0);\n+    SDB_OUTPUT_SOURCE_LINE (file, DECL_SOURCE_LINE (current_function_decl));\n #endif\n \n   /* In mips16 mode, we may need to generate a 32 bit to handle"}, {"sha": "b35b7d9b3df752c5172efdd0684c8c4787caeb4d", "filename": "gcc/config/mips/mips.h", "status": "modified", "additions": 9, "deletions": 14, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3e487b219e85b65965474f9b3784cc513ab2bc2a/gcc%2Fconfig%2Fmips%2Fmips.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3e487b219e85b65965474f9b3784cc513ab2bc2a/gcc%2Fconfig%2Fmips%2Fmips.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips.h?ref=3e487b219e85b65965474f9b3784cc513ab2bc2a", "patch": "@@ -2790,20 +2790,15 @@ while (0)\n #define ASM_OUTPUT_SOURCE_FILENAME(STREAM, NAME)\t\t\t\\\n   mips_output_filename (STREAM, NAME)\n \n-/* This is defined so that it can be overridden in iris6.h.  */\n-#define ASM_OUTPUT_FILENAME(STREAM, NUM_SOURCE_FILENAMES, NAME) \\\n-do\t\t\t\t\t\t\t\t\\\n-  {\t\t\t\t\t\t\t\t\\\n-    fprintf (STREAM, \"\\t.file\\t%d \", NUM_SOURCE_FILENAMES);\t\\\n-    output_quoted_string (STREAM, NAME);\t\t\t\\\n-    fputs (\"\\n\", STREAM);\t\t\t\t\t\\\n-  }\t\t\t\t\t\t\t\t\\\n-while (0)\n-\n-#ifndef ASM_OUTPUT_SOURCE_LINE\n-#define ASM_OUTPUT_SOURCE_LINE(STREAM, LINE, COUNTER)\t\t\\\n-  mips_output_lineno (STREAM, LINE)\n-#endif\n+/* mips-tfile does not understand .stabd directives.  */\n+#define DBX_OUTPUT_SOURCE_LINE(STREAM, LINE, COUNTER)\t\t\\\n+  fprintf (STREAM, \"%sLM%d:\\n\\t.stabn\\t%d,0,%d,%sLM%d\\n\",\t\\\n+\t   LOCAL_LABEL_PREFIX, COUNTER, N_SLINE, LINE,\t\t\\\n+\t   LOCAL_LABEL_PREFIX, COUNTER)\n+\n+/* Use .loc directives for SDB line numbers.  */\n+#define SDB_OUTPUT_SOURCE_LINE(STREAM, LINE)\t\t\t\\\n+  fprintf (STREAM, \"\\t.loc\\t%d %d\", num_source_filenames, LINE)\n \n /* The MIPS implementation uses some labels for its own purpose.  The\n    following lists what labels are created, and are all formed by the"}, {"sha": "fe52c0dc88d78b5a7648abc6d379c9bf453d3fb1", "filename": "gcc/config/mips/sdb.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3e487b219e85b65965474f9b3784cc513ab2bc2a/gcc%2Fconfig%2Fmips%2Fsdb.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3e487b219e85b65965474f9b3784cc513ab2bc2a/gcc%2Fconfig%2Fmips%2Fsdb.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fsdb.h?ref=3e487b219e85b65965474f9b3784cc513ab2bc2a", "patch": "@@ -67,7 +67,7 @@ do {\t\t\t\t\t\t\t\\\n \n #define PUT_SDB_FUNCTION_END(LINE)\t\t\t\\\n do {\t\t\t\t\t\t\t\\\n-  ASM_OUTPUT_SOURCE_LINE (asm_out_file, LINE + sdb_begin_function_line, 0); \\\n+  SDB_OUTPUT_SOURCE_LINE (asm_out_file, LINE + sdb_begin_function_line); \\\n } while (0)\n \n #define PUT_SDB_EPILOGUE_END(NAME)"}, {"sha": "98d8d60fd3809d083736c19366bafa6c5aa36f47", "filename": "gcc/config/mmix/mmix.c", "status": "modified", "additions": 0, "deletions": 10, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3e487b219e85b65965474f9b3784cc513ab2bc2a/gcc%2Fconfig%2Fmmix%2Fmmix.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3e487b219e85b65965474f9b3784cc513ab2bc2a/gcc%2Fconfig%2Fmmix%2Fmmix.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmmix%2Fmmix.c?ref=3e487b219e85b65965474f9b3784cc513ab2bc2a", "patch": "@@ -1236,16 +1236,6 @@ mmix_output_quoted_string (FILE *stream, const char *string, int length)\n     }\n }\n \n-/* ASM_OUTPUT_SOURCE_LINE.  */\n-\n-void\n-mmix_asm_output_source_line  (FILE *stream, int lineno)\n-{\n-  fprintf (stream, \"# %d \", lineno);\n-  OUTPUT_QUOTED_STRING (stream, main_input_filename);\n-  fprintf (stream, \"\\n\");\n-}\n-\n /* Target hook for assembling integer objects.  Use mmix_print_operand\n    for WYDE and TETRA.  Use mmix_output_octa to output 8-byte\n    CONST_DOUBLEs.  */"}, {"sha": "501837ebf8572c2eab0163bda2f4bbc0422430f3", "filename": "gcc/config/mmix/mmix.h", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3e487b219e85b65965474f9b3784cc513ab2bc2a/gcc%2Fconfig%2Fmmix%2Fmmix.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3e487b219e85b65965474f9b3784cc513ab2bc2a/gcc%2Fconfig%2Fmmix%2Fmmix.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmmix%2Fmmix.h?ref=3e487b219e85b65965474f9b3784cc513ab2bc2a", "patch": "@@ -888,12 +888,8 @@ typedef struct { int regs; int lib; } CUMULATIVE_ARGS;\n #define OUTPUT_QUOTED_STRING(STREAM, STRING) \\\n  mmix_output_quoted_string (STREAM, STRING, strlen (STRING))\n \n-#define ASM_OUTPUT_SOURCE_LINE(STREAM, LINE, COUNTER) \\\n- mmix_asm_output_source_line  (STREAM, LINE)\n-\n #define TARGET_ASM_NAMED_SECTION default_elf_asm_named_section\n \n-\n /* Node: Data Output */\n \n #define ASM_OUTPUT_ASCII(STREAM, PTR, LEN) \\"}, {"sha": "e5c30b2c1477096184a8ebc3486c8260b4567b40", "filename": "gcc/config/pa/pa.h", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3e487b219e85b65965474f9b3784cc513ab2bc2a/gcc%2Fconfig%2Fpa%2Fpa.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3e487b219e85b65965474f9b3784cc513ab2bc2a/gcc%2Fconfig%2Fpa%2Fpa.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpa%2Fpa.h?ref=3e487b219e85b65965474f9b3784cc513ab2bc2a", "patch": "@@ -369,10 +369,6 @@ extern int target_flags;\n #undef DBX_CONTIN_LENGTH\n #define DBX_CONTIN_LENGTH 3000\n \n-/* Only labels should ever begin in column zero.  */\n-#define ASM_STABS_OP \"\\t.stabs\\t\"\n-#define ASM_STABN_OP \"\\t.stabn\\t\"\n-\n /* GDB always assumes the current function's frame begins at the value\n    of the stack pointer upon entry to the current function.  Accessing\n    local variables and parameters passed on the stack is done using the"}, {"sha": "ac01ca1de4ff7b7810445fb2bcaad92261242f93", "filename": "gcc/config/pa/som.h", "status": "modified", "additions": 2, "deletions": 24, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3e487b219e85b65965474f9b3784cc513ab2bc2a/gcc%2Fconfig%2Fpa%2Fsom.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3e487b219e85b65965474f9b3784cc513ab2bc2a/gcc%2Fconfig%2Fpa%2Fsom.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpa%2Fsom.h?ref=3e487b219e85b65965474f9b3784cc513ab2bc2a", "patch": "@@ -27,33 +27,11 @@ Boston, MA 02111-1307, USA.  */\n    from other embedded stabs implementations.  */\n #undef DBX_USE_BINCL\n \n-/* We make the first line stab special to avoid adding several\n-   gross hacks to GAS.  */\n-#undef  ASM_OUTPUT_SOURCE_LINE\n-#define ASM_OUTPUT_SOURCE_LINE(file, line, counter)\t\t\\\n-  { static tree last_function_decl = NULL;\t\t\t\\\n-    if (current_function_decl == last_function_decl)\t\t\\\n-      {\t\t\t\t\t\t\t\t\\\n-\trtx func = DECL_RTL (current_function_decl);\t\t\\\n-\tconst char *name = XSTR (XEXP (func, 0), 0);\t\t\\\n-\tfprintf (file, \"\\t.stabn 68,0,%d,L$M%d-%s\\nL$M%d:\\n\",\t\\\n-\t\t line, counter,\t\t\t\t\t\\\n-\t\t (* targetm.strip_name_encoding) (name),\t\\\n-\t\t counter);\t\t\t\t\t\\\n-      }\t\t\t\t\t\t\t\t\\\n-    else\t\t\t\t\t\t\t\\\n-      fprintf (file, \"\\t.stabn 68,0,%d,0\\n\", line);\t\t\\\n-    last_function_decl = current_function_decl;\t\t\t\\\n-  }\n+#define DBX_LINES_FUNCTION_RELATIVE 1\n \n /* gdb needs a null N_SO at the end of each file for scattered loading.  */\n \n-#undef\tDBX_OUTPUT_MAIN_SOURCE_FILE_END\n-#define DBX_OUTPUT_MAIN_SOURCE_FILE_END(FILE, FILENAME) \\\n-  text_section (); \\\n-  fputs (\"\\t.SPACE $TEXT$\\n\\t.NSUBSPA $CODE$,QUAD=0,ALIGN=8,ACCESS=44,CODE_ONLY\\n\", FILE); \\\n-  fprintf (FILE,\t\t\t\t\t\t\t\\\n-\t   \"\\t.stabs \\\"\\\",%d,0,0,L$text_end0000\\nL$text_end0000:\\n\", N_SO)\n+#define DBX_OUTPUT_NULL_N_SO_AT_MAIN_SOURCE_FILE_END\n \n /* Select a format to encode pointers in exception handling data.  CODE\n    is 0 for data, 1 for code labels, 2 for function pointers.  GLOBAL is"}, {"sha": "2b0fadcd69ab9a4c6cc5ea33619ec6f11f3ca5ce", "filename": "gcc/config/ptx4.h", "status": "modified", "additions": 2, "deletions": 15, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3e487b219e85b65965474f9b3784cc513ab2bc2a/gcc%2Fconfig%2Fptx4.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3e487b219e85b65965474f9b3784cc513ab2bc2a/gcc%2Fconfig%2Fptx4.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fptx4.h?ref=3e487b219e85b65965474f9b3784cc513ab2bc2a", "patch": "@@ -184,26 +184,13 @@ Boston, MA 02111-1307, USA.\n /* Like block addresses, stabs line numbers are relative to the\n    current function.  */\n \n-#undef ASM_OUTPUT_SOURCE_LINE\n-#define ASM_OUTPUT_SOURCE_LINE(file, line, counter)\t\t\t\\\n-do\t\t\t\t\t\t\t\t\t\\\n-  {\t\t\t\t\t\t\t\t\t\\\n-    fprintf (file, \".stabn 68,0,%d,.LM%d-\",\t\t\t\t\\\n-\t     line, counter);\t\t\t\t\t\t\\\n-    assemble_name (file,\t\t\t\t\t\t\\\n-\t\t   XSTR (XEXP (DECL_RTL (current_function_decl), 0), 0));\\\n-    fprintf (file, \"\\n.LM%d:\\n\", counter);\t\t\t\t\\\n-  }\t\t\t\t\t\t\t\t\t\\\n-while (0)\n+#define DBX_LINES_FUNCTION_RELATIVE 1\n \n /* Generate a blank trailing N_SO to mark the end of the .o file, since\n    we can't depend upon the linker to mark .o file boundaries with\n    embedded stabs.  */\n \n-#undef DBX_OUTPUT_MAIN_SOURCE_FILE_END\n-#define DBX_OUTPUT_MAIN_SOURCE_FILE_END(FILE, FILENAME)\t\t\t\\\n-  fprintf (FILE,\t\t\t\t\t\t\t\\\n-\t   \"\\t.text\\n\\t.stabs \\\"\\\",%d,0,0,.Letext\\n.Letext:\\n\", N_SO)\n+#define DBX_OUTPUT_NULL_N_SO_AT_MAIN_SOURCE_FILE_END\n \n /* Define the actual types of some ANSI-mandated types.  (These\n    definitions should work for most SVR4 systems).  */"}, {"sha": "02d5167c2d9c65ee1a1dbee7ed2f4e6fc83ee243", "filename": "gcc/config/rs6000/linux64.h", "status": "modified", "additions": 4, "deletions": 12, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3e487b219e85b65965474f9b3784cc513ab2bc2a/gcc%2Fconfig%2Frs6000%2Flinux64.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3e487b219e85b65965474f9b3784cc513ab2bc2a/gcc%2Fconfig%2Frs6000%2Flinux64.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Flinux64.h?ref=3e487b219e85b65965474f9b3784cc513ab2bc2a", "patch": "@@ -482,10 +482,9 @@ extern int dot_symbols;\n \t\t   && GET_MODE_CLASS (GET_MODE (X)) == MODE_FLOAT\t\\\n \t\t   && BITS_PER_WORD == HOST_BITS_PER_INT)))))\n \n-/* This is the same as the dbxelf.h version, except that we need to\n+/* This ABI cannot use DBX_LINES_FUNCTION_RELATIVE, because we must\n    use the function code label, not the function descriptor.  */\n-#undef\tASM_OUTPUT_SOURCE_LINE\n-#define\tASM_OUTPUT_SOURCE_LINE(FILE, LINE, COUNTER)\t\t\t\\\n+#define\tDBX_OUTPUT_SOURCE_LINE(FILE, LINE, COUNTER)\t\t\t\\\n do\t\t\t\t\t\t\t\t\t\\\n   {\t\t\t\t\t\t\t\t\t\\\n     char temp[256];\t\t\t\t\t\t\t\\\n@@ -509,15 +508,8 @@ while (0)\n       fprintf (FILE, \"%s%d,0,0,\", ASM_STABN_OP, BRAC);\t\t\t\\\n       assemble_name (FILE, NAME);\t\t\t\t\t\\\n       putc ('-', FILE);\t\t\t\t\t\t\t\\\n-      if (current_function_func_begin_label != NULL)\t\t\t\\\n-\t{\t\t\t\t\t\t\t\t\\\n-\t  assemble_name (FILE, current_function_func_begin_label);\t\\\n-\t}\t\t\t\t\t\t\t\t\\\n-      else\t\t\t\t\t\t\t\t\\\n-\t{\t\t\t\t\t\t\t\t\\\n-\t  s = XSTR (XEXP (DECL_RTL (current_function_decl), 0), 0);\t\\\n-\t  rs6000_output_function_entry (FILE, s);\t\t\t\\\n-\t}\t\t\t\t\t\t\t\t\\\n+      s = XSTR (XEXP (DECL_RTL (current_function_decl), 0), 0);\t\t\\\n+      rs6000_output_function_entry (FILE, s);\t\t\t\t\\\n       putc ('\\n', FILE);\t\t\t\t\t\t\\\n     }\t\t\t\t\t\t\t\t\t\\\n   while (0)"}, {"sha": "b069308ea8c449e0eff4a7a35c8f2cffb4bd284f", "filename": "gcc/config/sh/elf.h", "status": "modified", "additions": 2, "deletions": 18, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3e487b219e85b65965474f9b3784cc513ab2bc2a/gcc%2Fconfig%2Fsh%2Felf.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3e487b219e85b65965474f9b3784cc513ab2bc2a/gcc%2Fconfig%2Fsh%2Felf.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Felf.h?ref=3e487b219e85b65965474f9b3784cc513ab2bc2a", "patch": "@@ -83,24 +83,8 @@ Boston, MA 02111-1307, USA.  */\n #define ASM_GENERATE_INTERNAL_LABEL(STRING, PREFIX, NUM) \\\n   sprintf ((STRING), \"*%s%s%ld\", LOCAL_LABEL_PREFIX, (PREFIX), (long)(NUM))\n \n-#undef  ASM_OUTPUT_SOURCE_LINE\n-#define ASM_OUTPUT_SOURCE_LINE(file, line, counter)\t\t\t\\\n-do\t\t\t\t\t\t\t\t\t\\\n-  {\t\t\t\t\t\t\t\t\t\\\n-    asm_fprintf ((file), \".stabn 68,0,%d,%LLM%d-\",\t\t\t\\\n-\t     (line), (counter));\t\t\t\t\t\\\n-    assemble_name ((file),\t\t\t\t\t\t\\\n-\t\t   XSTR (XEXP (DECL_RTL (current_function_decl), 0), 0));\\\n-    asm_fprintf ((file), \"\\n%LLM%d:\\n\", (counter));\t\t\t\\\n-  }\t\t\t\t\t\t\t\t\t\\\n-while (0)\n-\n-#undef DBX_OUTPUT_MAIN_SOURCE_FILE_END\n-#define DBX_OUTPUT_MAIN_SOURCE_FILE_END(FILE, FILENAME)\t\t\t\\\n-do {\t\t\t\t\t\t\t\t\t\\\n-  text_section ();\t\t\t\t\t\t\t\\\n-  asm_fprintf ((FILE), \"\\t.stabs \\\"\\\",%d,0,0,%LLetext\\n%LLetext:\\n\", N_SO); \\\n-} while (0)\n+#define DBX_LINES_FUNCTION_RELATIVE 1\n+#define DBX_OUTPUT_NULL_N_SO_AT_MAIN_SOURCE_FILE_END\n \n #undef STARTFILE_SPEC\n #define STARTFILE_SPEC \\"}, {"sha": "43757ebdfee5d7beb600d09f8c7f1ae468090496", "filename": "gcc/config/vax/elf.h", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3e487b219e85b65965474f9b3784cc513ab2bc2a/gcc%2Fconfig%2Fvax%2Felf.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3e487b219e85b65965474f9b3784cc513ab2bc2a/gcc%2Fconfig%2Fvax%2Felf.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fvax%2Felf.h?ref=3e487b219e85b65965474f9b3784cc513ab2bc2a", "patch": "@@ -42,9 +42,6 @@ Boston, MA 02111-1307, USA.  */\n /*  Let's be re-entrant.  */\n #undef PCC_STATIC_STRUCT_RETURN\n \n-/* Make sure .stabs for a function are always the same section.  */\n-#define\tDBX_OUTPUT_FUNCTION_END(file,decl) function_section(decl)\n-\n /* Before the prologue, the top of the frame is below the argument\n    count pushed by the CALLS and before the start of the saved registers.  */\n #define INCOMING_FRAME_SP_OFFSET 0"}, {"sha": "df5b4b0b5b1746bf0e0aca95fa1e62c5212b0f95", "filename": "gcc/dbxout.c", "status": "modified", "additions": 227, "deletions": 237, "changes": 464, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3e487b219e85b65965474f9b3784cc513ab2bc2a/gcc%2Fdbxout.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3e487b219e85b65965474f9b3784cc513ab2bc2a/gcc%2Fdbxout.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdbxout.c?ref=3e487b219e85b65965474f9b3784cc513ab2bc2a", "patch": "@@ -79,7 +79,7 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n #include \"regs.h\"\n #include \"insn-config.h\"\n #include \"reload.h\"\n-#include \"output.h\" /* ASM_OUTPUT_SOURCE_LINE may refer to sdb functions.  */\n+#include \"output.h\"\n #include \"dbxout.h\"\n #include \"toplev.h\"\n #include \"tm_p.h\"\n@@ -154,6 +154,14 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n #define NO_DBX_BNSYM_ENSYM 0\n #endif\n \n+#ifndef DBX_BLOCKS_FUNCTION_RELATIVE\n+#define DBX_BLOCKS_FUNCTION_RELATIVE 0\n+#endif\n+\n+#ifndef DBX_LINES_FUNCTION_RELATIVE\n+#define DBX_LINES_FUNCTION_RELATIVE 0\n+#endif\n+\n enum typestatus {TYPE_UNSEEN, TYPE_XREF, TYPE_DEFINED};\n \n /* Structure recording information about a C data type.\n@@ -299,10 +307,6 @@ static const char *cwd;\n #define DEBUGGER_ARG_OFFSET(OFFSET, X) (OFFSET)\n #endif\n \n-/* Stream for writing to assembler file.  */\n-\n-static FILE *asmfile;\n-\n /* These variables are for dbxout_symbol to communicate to\n    dbxout_finish_symbol.\n    current_sym_code is the symbol-type-code, a symbol N_... define in stab.h.\n@@ -468,7 +472,7 @@ dbxout_function_end (void)\n      the system doesn't insert underscores in front of user generated\n      labels.  */\n   ASM_GENERATE_INTERNAL_LABEL (lscope_label_name, \"Lscope\", scope_labelno);\n-  targetm.asm_out.internal_label (asmfile, \"Lscope\", scope_labelno);\n+  targetm.asm_out.internal_label (asm_out_file, \"Lscope\", scope_labelno);\n   scope_labelno++;\n \n   /* The N_FUN tag at the end of the function is a GNU extension,\n@@ -482,17 +486,17 @@ dbxout_function_end (void)\n   /* By convention, GCC will mark the end of a function with an N_FUN\n      symbol and an empty string.  */\n #ifdef DBX_OUTPUT_NFUN\n-  DBX_OUTPUT_NFUN (asmfile, lscope_label_name, current_function_decl);\n+  DBX_OUTPUT_NFUN (asm_out_file, lscope_label_name, current_function_decl);\n #else\n-  fprintf (asmfile, \"%s\\\"\\\",%d,0,0,\", ASM_STABS_OP, N_FUN);\n-  assemble_name (asmfile, lscope_label_name);\n-  putc ('-', asmfile);\n-  assemble_name (asmfile, XSTR (XEXP (DECL_RTL (current_function_decl), 0), 0));\n-  fprintf (asmfile, \"\\n\");\n+  fprintf (asm_out_file, \"%s\\\"\\\",%d,0,0,\", ASM_STABS_OP, N_FUN);\n+  assemble_name (asm_out_file, lscope_label_name);\n+  putc ('-', asm_out_file);\n+  assemble_name (asm_out_file, XSTR (XEXP (DECL_RTL (current_function_decl), 0), 0));\n+  fprintf (asm_out_file, \"\\n\");\n #endif\n \n   if (!NO_DBX_BNSYM_ENSYM && !flag_debug_only_used_symbols)\n-    fprintf (asmfile, \"%s%d,0,0\\n\", ASM_STABD_OP, N_ENSYM);\n+    fprintf (asm_out_file, \"%s%d,0,0\\n\", ASM_STABD_OP, N_ENSYM);\n }\n #endif /* DBX_DEBUGGING_INFO */\n \n@@ -531,8 +535,6 @@ dbxout_init (const char *input_file_name)\n   char ltext_label_name[100];\n   tree syms = lang_hooks.decls.getdecls ();\n \n-  asmfile = asm_out_file;\n-\n   typevec_len = 100;\n   typevec = ggc_calloc (typevec_len, sizeof typevec[0]);\n \n@@ -550,37 +552,37 @@ dbxout_init (const char *input_file_name)\n       if (cwd)\n \t{\n #ifdef DBX_OUTPUT_MAIN_SOURCE_DIRECTORY\n-\t  DBX_OUTPUT_MAIN_SOURCE_DIRECTORY (asmfile, cwd);\n+\t  DBX_OUTPUT_MAIN_SOURCE_DIRECTORY (asm_out_file, cwd);\n #else /* no DBX_OUTPUT_MAIN_SOURCE_DIRECTORY */\n-\t  fprintf (asmfile, \"%s\", ASM_STABS_OP);\n-\t  output_quoted_string (asmfile, cwd);\n-\t  fprintf (asmfile, \",%d,0,%d,\", N_SO, get_lang_number ());\n-\t  assemble_name (asmfile, ltext_label_name);\n-\t  fputc ('\\n', asmfile);\n+\t  fprintf (asm_out_file, \"%s\", ASM_STABS_OP);\n+\t  output_quoted_string (asm_out_file, cwd);\n+\t  fprintf (asm_out_file, \",%d,0,%d,\", N_SO, get_lang_number ());\n+\t  assemble_name (asm_out_file, ltext_label_name);\n+\t  fputc ('\\n', asm_out_file);\n #endif /* no DBX_OUTPUT_MAIN_SOURCE_DIRECTORY */\n \t}\n     }\n \n #ifdef DBX_OUTPUT_MAIN_SOURCE_FILENAME\n-  DBX_OUTPUT_MAIN_SOURCE_FILENAME (asmfile, input_file_name);\n+  DBX_OUTPUT_MAIN_SOURCE_FILENAME (asm_out_file, input_file_name);\n #else /* no DBX_OUTPUT_MAIN_SOURCE_FILENAME */\n   /* We include outputting `Ltext:' here,\n      because that gives you a way to override it.  */\n   /* Used to put `Ltext:' before the reference, but that loses on sun 4.  */\n-  fprintf (asmfile, \"%s\", ASM_STABS_OP);\n-  output_quoted_string (asmfile, input_file_name);\n-  fprintf (asmfile, \",%d,0,%d,\", N_SO, get_lang_number ());\n-  assemble_name (asmfile, ltext_label_name);\n-  fputc ('\\n', asmfile);\n+  fprintf (asm_out_file, \"%s\", ASM_STABS_OP);\n+  output_quoted_string (asm_out_file, input_file_name);\n+  fprintf (asm_out_file, \",%d,0,%d,\", N_SO, get_lang_number ());\n+  assemble_name (asm_out_file, ltext_label_name);\n+  fputc ('\\n', asm_out_file);\n   text_section ();\n-  targetm.asm_out.internal_label (asmfile, \"Ltext\", 0);\n+  targetm.asm_out.internal_label (asm_out_file, \"Ltext\", 0);\n #endif /* no DBX_OUTPUT_MAIN_SOURCE_FILENAME */\n \n #ifdef DBX_OUTPUT_GCC_MARKER\n-  DBX_OUTPUT_GCC_MARKER (asmfile);\n+  DBX_OUTPUT_GCC_MARKER (asm_out_file);\n #else\n   /* Emit an N_OPT stab to indicate that this file was compiled by GCC.  */\n-  fprintf (asmfile, \"%s\\\"%s\\\",%d,0,0,0\\n\",\n+  fprintf (asm_out_file, \"%s\\\"%s\\\",%d,0,0,0\\n\",\n \t   ASM_STABS_OP, STABS_GCC_MARKER, N_OPT);\n #endif\n \n@@ -639,9 +641,9 @@ dbxout_typedefs (tree syms)\n static void\n emit_bincl_stab (const char *name)\n {\n-  fprintf (asmfile, \"%s\", ASM_STABS_OP);\n-  output_quoted_string (asmfile, name);\n-  fprintf (asmfile, \",%d,0,0,0\\n\", N_BINCL);\n+  fprintf (asm_out_file, \"%s\", ASM_STABS_OP);\n+  output_quoted_string (asm_out_file, name);\n+  fprintf (asm_out_file, \",%d,0,0,0\\n\", N_BINCL);\n }\n \n /* If there are pending bincls then it is time to emit all of them.  */\n@@ -723,7 +725,7 @@ dbxout_end_source_file (unsigned int line ATTRIBUTE_UNUSED)\n #ifdef DBX_USE_BINCL\n   /* Emit EINCL stab only if BINCL is not pending.  */\n   if (current_file->bincl_status == BINCL_PROCESSED)\n-    fprintf (asmfile, \"%s%d,0,0,0\\n\", ASM_STABN_OP, N_EINCL);\n+    fprintf (asm_out_file, \"%s%d,0,0,0\\n\", ASM_STABN_OP, N_EINCL);\n   current_file->bincl_status = BINCL_NOT_REQUIRED;\n   current_file = current_file->next;\n #endif\n@@ -774,9 +776,9 @@ dbxout_source_file (FILE *file, const char *filename)\n \t\t\t\t   source_label_number);\n       fprintf (file, \"%s\", ASM_STABS_OP);\n       output_quoted_string (file, filename);\n-      fprintf (asmfile, \",%d,0,0,\", N_SOL);\n-      assemble_name (asmfile, ltext_label_name);\n-      fputc ('\\n', asmfile);\n+      fprintf (asm_out_file, \",%d,0,0,\", N_SOL);\n+      assemble_name (asm_out_file, ltext_label_name);\n+      fputc ('\\n', asm_out_file);\n       if (current_function_decl != NULL_TREE\n \t  && DECL_SECTION_NAME (current_function_decl) != NULL_TREE)\n \t; /* Don't change section amid function.  */\n@@ -800,7 +802,7 @@ dbxout_begin_prologue (unsigned int lineno, const char *filename)\n       && !NO_DBX_FUNCTION_END\n       && !NO_DBX_BNSYM_ENSYM\n       && !flag_debug_only_used_symbols)\n-    fprintf (asmfile, \"%s%d,0,0\\n\", ASM_STABD_OP, N_BNSYM);\n+    fprintf (asm_out_file, \"%s%d,0,0\\n\", ASM_STABD_OP, N_BNSYM);\n \n   dbxout_source_line (lineno, filename);\n }\n@@ -811,13 +813,29 @@ dbxout_begin_prologue (unsigned int lineno, const char *filename)\n static void\n dbxout_source_line (unsigned int lineno, const char *filename)\n {\n-  dbxout_source_file (asmfile, filename);\n+  dbxout_source_file (asm_out_file, filename);\n \n-#ifdef ASM_OUTPUT_SOURCE_LINE\n+#ifdef DBX_OUTPUT_SOURCE_LINE\n   dbxout_source_line_counter += 1;\n-  ASM_OUTPUT_SOURCE_LINE (asmfile, lineno, dbxout_source_line_counter);\n+  DBX_OUTPUT_SOURCE_LINE (asm_out_file, lineno, dbxout_source_line_counter);\n #else\n-  fprintf (asmfile, \"%s%d,0,%d\\n\", ASM_STABD_OP, N_SLINE, lineno);\n+  if (DBX_LINES_FUNCTION_RELATIVE)\n+    {\n+      char label[100];\n+      dbxout_source_line_counter += 1;\n+\n+      ASM_GENERATE_INTERNAL_LABEL (label, \"LM\", dbxout_source_line_counter);\n+      fprintf (asm_out_file, \"%s%d,0,%d,\", ASM_STABN_OP, N_SLINE, lineno);\n+      assemble_name (asm_out_file, label);\n+      putc ('-', asm_out_file);\n+      assemble_name (asm_out_file,\n+\t\t     XSTR (XEXP (DECL_RTL (current_function_decl), 0), 0));\n+      putc ('\\n', asm_out_file);\n+      targetm.asm_out.internal_label (asm_out_file, \"LM\",\n+\t\t\t\t      dbxout_source_line_counter);\n+    }\n+  else\n+    fprintf (asm_out_file, \"%s%d,0,%d\\n\", ASM_STABD_OP, N_SLINE, lineno);\n #endif\n }\n \n@@ -827,7 +845,7 @@ static void\n dbxout_begin_block (unsigned int line ATTRIBUTE_UNUSED, unsigned int n)\n {\n   emit_pending_bincls_if_required ();\n-  targetm.asm_out.internal_label (asmfile, \"LBB\", n);\n+  targetm.asm_out.internal_label (asm_out_file, \"LBB\", n);\n }\n \n /* Describe the end line-number of an internal block within a function.  */\n@@ -836,7 +854,7 @@ static void\n dbxout_end_block (unsigned int line ATTRIBUTE_UNUSED, unsigned int n)\n {\n   emit_pending_bincls_if_required ();\n-  targetm.asm_out.internal_label (asmfile, \"LBE\", n);\n+  targetm.asm_out.internal_label (asm_out_file, \"LBE\", n);\n }\n \n /* Output dbx data for a function definition.\n@@ -854,7 +872,7 @@ dbxout_function_decl (tree decl)\n #endif\n   dbxout_block (DECL_INITIAL (decl), 0, DECL_ARGUMENTS (decl));\n #ifdef DBX_OUTPUT_FUNCTION_END\n-  DBX_OUTPUT_FUNCTION_END (asmfile, decl);\n+  DBX_OUTPUT_FUNCTION_END (asm_out_file, decl);\n #endif\n   dbxout_function_end ();\n }\n@@ -886,16 +904,23 @@ dbxout_type_decl (tree decl, int local)\n }\n \n /* At the end of compilation, finish writing the symbol table.\n-   Unless you define DBX_OUTPUT_MAIN_SOURCE_FILE_END, the default is\n-   to do nothing.  */\n+   The default is to call debug_free_queue but do nothing else.  */\n \n static void\n dbxout_finish (const char *filename ATTRIBUTE_UNUSED)\n {\n #ifdef DBX_OUTPUT_MAIN_SOURCE_FILE_END\n-  DBX_OUTPUT_MAIN_SOURCE_FILE_END (asmfile, filename);\n-#endif /* DBX_OUTPUT_MAIN_SOURCE_FILE_END */\n-\n+  DBX_OUTPUT_MAIN_SOURCE_FILE_END (asm_out_file, filename);\n+#elif defined DBX_OUTPUT_NULL_N_SO_AT_MAIN_SOURCE_FILE_END\n+ {\n+   char letext_label[100];\n+   ASM_GENERATE_INTERNAL_LABEL (letext_label, \"Letext\", 0);\n+   fprintf (asm_out_file, \"%s\\\"\\\",%d,0,0,\", ASM_STABS_OP, N_SO);\n+   assemble_name (asm_out_file, letext_label);\n+   putc ('\\n', asm_out_file);\n+   targetm.asm_out.internal_label (asm_out_file, \"Letext\", 0);\n+ }\n+#endif\n   debug_free_queue ();\n }\n \n@@ -905,11 +930,11 @@ static void\n dbxout_type_index (tree type)\n {\n #ifndef DBX_USE_BINCL\n-  fprintf (asmfile, \"%d\", TYPE_SYMTAB_ADDRESS (type));\n+  fprintf (asm_out_file, \"%d\", TYPE_SYMTAB_ADDRESS (type));\n   CHARS (3);\n #else\n   struct typeinfo *t = &typevec[TYPE_SYMTAB_ADDRESS (type)];\n-  fprintf (asmfile, \"(%d,%d)\", t->file_number, t->type_number);\n+  fprintf (asm_out_file, \"(%d,%d)\", t->file_number, t->type_number);\n   CHARS (9);\n #endif\n }\n@@ -926,12 +951,12 @@ dbxout_continue (void)\n {\n   emit_pending_bincls_if_required ();\n #ifdef DBX_CONTIN_CHAR\n-  fprintf (asmfile, \"%c\", DBX_CONTIN_CHAR);\n+  fprintf (asm_out_file, \"%c\", DBX_CONTIN_CHAR);\n #else\n-  fprintf (asmfile, \"\\\\\\\\\");\n+  fprintf (asm_out_file, \"\\\\\\\\\");\n #endif\n   dbxout_finish_symbol (NULL_TREE);\n-  fprintf (asmfile, \"%s\\\"\", ASM_STABS_OP);\n+  fprintf (asm_out_file, \"%s\\\"\", ASM_STABS_OP);\n   current_sym_nchars = 0;\n }\n #endif /* DBX_CONTIN_LENGTH > 0 */\n@@ -975,12 +1000,12 @@ dbxout_type_fields (tree type)\n \n \t  if (DECL_NAME (tem))\n \t    {\n-\t      fprintf (asmfile, \"%s:\", IDENTIFIER_POINTER (DECL_NAME (tem)));\n+\t      fprintf (asm_out_file, \"%s:\", IDENTIFIER_POINTER (DECL_NAME (tem)));\n \t      CHARS (2 + IDENTIFIER_LENGTH (DECL_NAME (tem)));\n \t    }\n \t  else\n \t    {\n-\t      fprintf (asmfile, \":\");\n+\t      fprintf (asm_out_file, \":\");\n \t      CHARS (1);\n \t    }\n \n@@ -989,10 +1014,10 @@ dbxout_type_fields (tree type)\n \t\t  || TREE_CODE (tem) != FIELD_DECL))\n \t    {\n \t      have_used_extensions = 1;\n-\t      putc ('/', asmfile);\n+\t      putc ('/', asm_out_file);\n \t      putc ((TREE_PRIVATE (tem) ? '0'\n \t\t     : TREE_PROTECTED (tem) ? '1' : '2'),\n-\t\t    asmfile);\n+\t\t    asm_out_file);\n \t      CHARS (2);\n \t    }\n \n@@ -1007,23 +1032,23 @@ dbxout_type_fields (tree type)\n \t\t  tree name = DECL_ASSEMBLER_NAME (tem);\n \n \t\t  have_used_extensions = 1;\n-\t\t  fprintf (asmfile, \":%s;\", IDENTIFIER_POINTER (name));\n+\t\t  fprintf (asm_out_file, \":%s;\", IDENTIFIER_POINTER (name));\n \t\t  CHARS (IDENTIFIER_LENGTH (name) + 2);\n \t\t}\n \t      else\n \t\t{\n \t\t  /* If TEM is non-static, GDB won't understand it.  */\n-\t\t  fprintf (asmfile, \",0,0;\");\n+\t\t  fprintf (asm_out_file, \",0,0;\");\n \t\t  CHARS (5);\n \t\t}\n \t    }\n \t  else\n \t    {\n-\t      putc (',', asmfile);\n+\t      putc (',', asm_out_file);\n \t      print_wide_int (int_bit_position (tem));\n-\t      putc (',', asmfile);\n+\t      putc (',', asm_out_file);\n \t      print_wide_int (tree_low_cst (DECL_SIZE (tem), 1));\n-\t      putc (';', asmfile);\n+\t      putc (';', asm_out_file);\n \t      CHARS (3);\n \t    }\n \t}\n@@ -1060,7 +1085,7 @@ dbxout_type_method_1 (tree decl, const char *debug_name)\n \tc2 = '.';\n     }\n \n-  fprintf (asmfile, \":%s;%c%c%c\", debug_name,\n+  fprintf (asm_out_file, \":%s;%c%c%c\", debug_name,\n \t   TREE_PRIVATE (decl) ? '0'\n \t   : TREE_PROTECTED (decl) ? '1' : '2', c1, c2);\n   CHARS (IDENTIFIER_LENGTH (DECL_ASSEMBLER_NAME (decl)) + 6\n@@ -1069,10 +1094,10 @@ dbxout_type_method_1 (tree decl, const char *debug_name)\n   if (DECL_VINDEX (decl) && host_integerp (DECL_VINDEX (decl), 0))\n     {\n       print_wide_int (tree_low_cst (DECL_VINDEX (decl), 0));\n-      putc (';', asmfile);\n+      putc (';', asm_out_file);\n       CHARS (1);\n       dbxout_type (DECL_CONTEXT (decl), 0);\n-      fprintf (asmfile, \";\");\n+      fprintf (asm_out_file, \";\");\n       CHARS (1);\n     }\n }\n@@ -1096,24 +1121,6 @@ dbxout_type_methods (tree type)\n \n   type_encoding = DECL_NAME (TYPE_NAME (type));\n \n-#if 0\n-  /* C++: Template classes break some assumptions made by this code about\n-     the class names, constructor names, and encodings for assembler\n-     label names.  For now, disable output of dbx info for them.  */\n-  {\n-    const char *ptr = IDENTIFIER_POINTER (type_encoding);\n-    /* This should use index.  (mrs) */\n-    while (*ptr && *ptr != '<') ptr++;\n-    if (*ptr != 0)\n-      {\n-\tstatic int warned;\n-\tif (!warned)\n-\t    warned = 1;\n-\treturn;\n-      }\n-  }\n-#endif\n-\n   type_identifier_length = IDENTIFIER_LENGTH (type_encoding);\n \n   sprintf (formatted_type_identifier_length, \"%d\", type_identifier_length);\n@@ -1164,7 +1171,7 @@ dbxout_type_methods (tree type)\n \t  if (need_prefix)\n \t    {\n \t      tree name = DECL_NAME (fndecl);\n-\t      fprintf (asmfile, \"%s::\", IDENTIFIER_POINTER (name));\n+\t      fprintf (asm_out_file, \"%s::\", IDENTIFIER_POINTER (name));\n \t      CHARS (IDENTIFIER_LENGTH (name) + 2);\n \t      need_prefix = 0;\n \t    }\n@@ -1175,7 +1182,7 @@ dbxout_type_methods (tree type)\n \t}\n       if (!need_prefix)\n \t{\n-\t  putc (';', asmfile);\n+\t  putc (';', asm_out_file);\n \t  CHARS (1);\n \t}\n     }\n@@ -1188,7 +1195,7 @@ dbxout_type_methods (tree type)\n static void\n dbxout_range_type (tree type)\n {\n-  fprintf (asmfile, \"r\");\n+  fprintf (asm_out_file, \"r\");\n   if (TREE_TYPE (type))\n     dbxout_type (TREE_TYPE (type), 0);\n   else if (TREE_CODE (type) != INTEGER_TYPE)\n@@ -1216,7 +1223,7 @@ dbxout_range_type (tree type)\n   if (TYPE_MIN_VALUE (type) != 0\n       && host_integerp (TYPE_MIN_VALUE (type), 0))\n     {\n-      putc (';', asmfile);\n+      putc (';', asm_out_file);\n       CHARS (1);\n       if (print_int_cst_bounds_in_octal_p (type))\n         print_int_cst_octal (TYPE_MIN_VALUE (type));\n@@ -1225,25 +1232,25 @@ dbxout_range_type (tree type)\n     }\n   else\n     {\n-      fprintf (asmfile, \";0\");\n+      fprintf (asm_out_file, \";0\");\n       CHARS (2);\n     }\n \n   if (TYPE_MAX_VALUE (type) != 0\n       && host_integerp (TYPE_MAX_VALUE (type), 0))\n     {\n-      putc (';', asmfile);\n+      putc (';', asm_out_file);\n       CHARS (1);\n       if (print_int_cst_bounds_in_octal_p (type))\n         print_int_cst_octal (TYPE_MAX_VALUE (type));\n       else\n         print_wide_int (tree_low_cst (TYPE_MAX_VALUE (type), 0));\n-      putc (';', asmfile);\n+      putc (';', asm_out_file);\n       CHARS (1);\n     }\n   else\n     {\n-      fprintf (asmfile, \";-1;\");\n+      fprintf (asm_out_file, \";-1;\");\n       CHARS (4);\n     }\n }\n@@ -1391,7 +1398,7 @@ dbxout_type (tree type, int full)\n \n   /* Output a definition now.  */\n \n-  fprintf (asmfile, \"=\");\n+  fprintf (asm_out_file, \"=\");\n   CHARS (1);\n \n   /* Mark it as defined, so that if it is self-referent\n@@ -1404,14 +1411,14 @@ dbxout_type (tree type, int full)\n      cv-qualified types if we're using extensions.  */\n   if (TYPE_READONLY (type) > TYPE_READONLY (main_variant))\n     {\n-      putc ('k', asmfile);\n+      putc ('k', asm_out_file);\n       CHARS (1);\n       dbxout_type (build_type_variant (type, 0, TYPE_VOLATILE (type)), 0);\n       return;\n     }\n   else if (TYPE_VOLATILE (type) > TYPE_VOLATILE (main_variant))\n     {\n-      putc ('B', asmfile);\n+      putc ('B', asm_out_file);\n       CHARS (1);\n       dbxout_type (build_type_variant (type, TYPE_READONLY (type), 0), 0);\n       return;\n@@ -1456,10 +1463,10 @@ dbxout_type (tree type, int full)\n \t     from the output of pcc.\n \t     This used to use `r2' explicitly and we used to\n \t     take care to make sure that `char' was type number 2.  */\n-\t  fprintf (asmfile, \"r\");\n+\t  fprintf (asm_out_file, \"r\");\n \t  CHARS (1);\n \t  dbxout_type_index (type);\n-\t  fprintf (asmfile, \";0;127;\");\n+\t  fprintf (asm_out_file, \";0;127;\");\n \t  CHARS (7);\n \t}\n \n@@ -1475,7 +1482,7 @@ dbxout_type (tree type, int full)\n \t      && TYPE_PRECISION (type) != TYPE_PRECISION (integer_type_node))\n \t    {\n \t      have_used_extensions = 1;\n-\t      fprintf (asmfile, \"@s%d;\", TYPE_PRECISION (type));\n+\t      fprintf (asm_out_file, \"@s%d;\", TYPE_PRECISION (type));\n \t      CHARS (5);\n \t    }\n \n@@ -1491,13 +1498,13 @@ dbxout_type (tree type, int full)\n \t      && TYPE_PRECISION (type) != TYPE_PRECISION (integer_type_node))\n \t    {\n \t      have_used_extensions = 1;\n-\t      fprintf (asmfile, \"@s%d;\", TYPE_PRECISION (type));\n+\t      fprintf (asm_out_file, \"@s%d;\", TYPE_PRECISION (type));\n \t      CHARS (5);\n \t    }\n \n \t  if (print_int_cst_bounds_in_octal_p (type))\n \t    {\n-\t      fprintf (asmfile, \"r\");\n+\t      fprintf (asm_out_file, \"r\");\n \t      CHARS (1);\n \n               /* If this type derives from another type, output type index of\n@@ -1510,13 +1517,13 @@ dbxout_type (tree type, int full)\n               else\n                 dbxout_type_index (type);\n \n-\t      fprintf (asmfile, \";\");\n+\t      fprintf (asm_out_file, \";\");\n \t      CHARS (1);\n \t      print_int_cst_octal (TYPE_MIN_VALUE (type));\n-\t      fprintf (asmfile, \";\");\n+\t      fprintf (asm_out_file, \";\");\n \t      CHARS (1);\n \t      print_int_cst_octal (TYPE_MAX_VALUE (type));\n-\t      fprintf (asmfile, \";\");\n+\t      fprintf (asm_out_file, \";\");\n \t      CHARS (1);\n \t    }\n \n@@ -1530,34 +1537,34 @@ dbxout_type (tree type, int full)\n     case REAL_TYPE:\n       /* This used to say `r1' and we used to take care\n \t to make sure that `int' was type number 1.  */\n-      fprintf (asmfile, \"r\");\n+      fprintf (asm_out_file, \"r\");\n       CHARS (1);\n       dbxout_type_index (integer_type_node);\n-      putc (';', asmfile);\n+      putc (';', asm_out_file);\n       CHARS (1);\n       print_wide_int (int_size_in_bytes (type));\n-      fputs (\";0;\", asmfile);\n+      fputs (\";0;\", asm_out_file);\n       CHARS (3);\n       break;\n \n     case CHAR_TYPE:\n       if (use_gnu_debug_info_extensions)\n \t{\n \t  have_used_extensions = 1;\n-\t  fputs (\"@s\", asmfile);\n+\t  fputs (\"@s\", asm_out_file);\n \t  CHARS (2);\n \t  print_wide_int (BITS_PER_UNIT * int_size_in_bytes (type));\n-\t  fputs (\";-20;\", asmfile);\n+\t  fputs (\";-20;\", asm_out_file);\n \t  CHARS (4);\n \t}\n       else\n \t{\n \t  /* Output the type `char' as a subrange of itself.\n \t     That is what pcc seems to do.  */\n-\t  fprintf (asmfile, \"r\");\n+\t  fprintf (asm_out_file, \"r\");\n \t  CHARS (1);\n \t  dbxout_type_index (char_type_node);\n-\t  fprintf (asmfile, \";0;%d;\", TYPE_UNSIGNED (type) ? 255 : 127);\n+\t  fprintf (asm_out_file, \";0;%d;\", TYPE_UNSIGNED (type) ? 255 : 127);\n \t  CHARS (7);\n \t}\n       break;\n@@ -1566,21 +1573,21 @@ dbxout_type (tree type, int full)\n       if (use_gnu_debug_info_extensions)\n \t{\n \t  have_used_extensions = 1;\n-\t  fputs (\"@s\", asmfile);\n+\t  fputs (\"@s\", asm_out_file);\n \t  CHARS (2);\n \t  print_wide_int (BITS_PER_UNIT * int_size_in_bytes (type));\n-\t  fputs (\";-16;\", asmfile);\n+\t  fputs (\";-16;\", asm_out_file);\n \t  CHARS (4);\n \t}\n       else /* Define as enumeral type (False, True) */\n \t{\n-\t  fprintf (asmfile, \"eFalse:0,True:1,;\");\n+\t  fprintf (asm_out_file, \"eFalse:0,True:1,;\");\n \t  CHARS (17);\n \t}\n       break;\n \n     case FILE_TYPE:\n-      putc ('d', asmfile);\n+      putc ('d', asm_out_file);\n       CHARS (1);\n       dbxout_type (TREE_TYPE (type), 0);\n       break;\n@@ -1592,29 +1599,29 @@ dbxout_type (tree type, int full)\n \n       if (TREE_CODE (TREE_TYPE (type)) == REAL_TYPE)\n \t{\n-\t  fputs (\"R3;\", asmfile);\n+\t  fputs (\"R3;\", asm_out_file);\n \t  CHARS (3);\n \t  print_wide_int (2 * int_size_in_bytes (TREE_TYPE (type)));\n-\t  fputs (\";0;\", asmfile);\n+\t  fputs (\";0;\", asm_out_file);\n \t  CHARS (3);\n \t}\n       else\n \t{\n \t  /* Output a complex integer type as a structure,\n \t     pending some other way to do it.  */\n-\t  putc ('s', asmfile);\n+\t  putc ('s', asm_out_file);\n \t  CHARS (1);\n \t  print_wide_int (int_size_in_bytes (type));\n-\t  fprintf (asmfile, \"real:\");\n+\t  fprintf (asm_out_file, \"real:\");\n \t  CHARS (5);\n \n \t  dbxout_type (TREE_TYPE (type), 0);\n-\t  fprintf (asmfile, \",0,%d;\", TYPE_PRECISION (TREE_TYPE (type)));\n+\t  fprintf (asm_out_file, \",0,%d;\", TYPE_PRECISION (TREE_TYPE (type)));\n \t  CHARS (7);\n-\t  fprintf (asmfile, \"imag:\");\n+\t  fprintf (asm_out_file, \"imag:\");\n \t  CHARS (5);\n \t  dbxout_type (TREE_TYPE (type), 0);\n-\t  fprintf (asmfile, \",%d,%d;;\", TYPE_PRECISION (TREE_TYPE (type)),\n+\t  fprintf (asm_out_file, \",%d,%d;;\", TYPE_PRECISION (TREE_TYPE (type)),\n \t\t   TYPE_PRECISION (TREE_TYPE (type)));\n \t  CHARS (10);\n \t}\n@@ -1624,21 +1631,21 @@ dbxout_type (tree type, int full)\n       if (use_gnu_debug_info_extensions)\n \t{\n \t  have_used_extensions = 1;\n-\t  fputs (\"@s\", asmfile);\n+\t  fputs (\"@s\", asm_out_file);\n \t  CHARS (2);\n \t  print_wide_int (BITS_PER_UNIT * int_size_in_bytes (type));\n-\t  putc (';', asmfile);\n+\t  putc (';', asm_out_file);\n \t  CHARS (1);\n \n \t  /* Check if a bitstring type, which in Chill is\n \t     different from a [power]set.  */\n \t  if (TYPE_STRING_FLAG (type))\n \t    {\n-\t      fprintf (asmfile, \"@S;\");\n+\t      fprintf (asm_out_file, \"@S;\");\n \t      CHARS (3);\n \t    }\n \t}\n-      putc ('S', asmfile);\n+      putc ('S', asm_out_file);\n       CHARS (1);\n       dbxout_type (TYPE_DOMAIN (type), 0);\n       break;\n@@ -1648,10 +1655,10 @@ dbxout_type (tree type, int full)\n       if (TYPE_PACKED (type) && use_gnu_debug_info_extensions)\n \t{\n \t  have_used_extensions = 1;\n-\t  fputs (\"@s\", asmfile);\n+\t  fputs (\"@s\", asm_out_file);\n \t  CHARS (2);\n \t  print_wide_int (BITS_PER_UNIT * int_size_in_bytes (type));\n-\t  fprintf (asmfile, \";@S;S\");\n+\t  fprintf (asm_out_file, \";@S;S\");\n \t  CHARS (5);\n \t  dbxout_type (TYPE_DOMAIN (type), 0);\n \t  break;\n@@ -1666,21 +1673,21 @@ dbxout_type (tree type, int full)\n       if (TYPE_STRING_FLAG (type) && use_gnu_debug_info_extensions)\n \t{\n \t  have_used_extensions = 1;\n-\t  fprintf (asmfile, \"@S;\");\n+\t  fprintf (asm_out_file, \"@S;\");\n \t  CHARS (3);\n \t}\n       tem = TYPE_DOMAIN (type);\n       if (tem == NULL)\n \t{\n-\t  fprintf (asmfile, \"ar\");\n+\t  fprintf (asm_out_file, \"ar\");\n \t  CHARS (2);\n \t  dbxout_type_index (integer_type_node);\n-\t  fprintf (asmfile, \";0;-1;\");\n+\t  fprintf (asm_out_file, \";0;-1;\");\n \t  CHARS (6);\n \t}\n       else\n \t{\n-\t  fprintf (asmfile, \"a\");\n+\t  fprintf (asm_out_file, \"a\");\n \t  CHARS (1);\n \t  dbxout_range_type (tem);\n \t}\n@@ -1711,30 +1718,24 @@ dbxout_type (tree type, int full)\n \t       If the type has a name, don't nest its definition within\n \t       another type's definition; instead, output an xref\n \t       and let the definition come when the name is defined.  */\n-\t    fputs ((TREE_CODE (type) == RECORD_TYPE) ? \"xs\" : \"xu\", asmfile);\n+\t    fputs ((TREE_CODE (type) == RECORD_TYPE) ? \"xs\" : \"xu\", asm_out_file);\n \t    CHARS (2);\n-#if 0 /* This assertion is legitimately false in C++.  */\n-\t    /* We shouldn't be outputting a reference to a type before its\n-\t       definition unless the type has a tag name.\n-\t       A typedef name without a tag name should be impossible.  */\n-\t    gcc_assert (TREE_CODE (TYPE_NAME (type)) == IDENTIFIER_NODE);\n-#endif\n \t    if (TYPE_NAME (type) != 0)\n \t      dbxout_type_name (type);\n \t    else\n \t      {\n-\t\tfprintf (asmfile, \"$$%d\", anonymous_type_number++);\n+\t\tfprintf (asm_out_file, \"$$%d\", anonymous_type_number++);\n \t\tCHARS (5);\n \t      }\n \n-\t    fprintf (asmfile, \":\");\n+\t    fprintf (asm_out_file, \":\");\n \t    CHARS (1);\n \t    typevec[TYPE_SYMTAB_ADDRESS (type)].status = TYPE_XREF;\n \t    break;\n \t  }\n \n \t/* Identify record or union, and print its size.  */\n-\tputc (((TREE_CODE (type) == RECORD_TYPE) ? 's' : 'u'), asmfile);\n+\tputc (((TREE_CODE (type) == RECORD_TYPE) ? 's' : 'u'), asm_out_file);\n \tCHARS (1);\n \tprint_wide_int (int_size_in_bytes (type));\n \n@@ -1749,7 +1750,7 @@ dbxout_type (tree type, int full)\n \t\tif (BINFO_N_BASE_BINFOS (binfo))\n \t\t  {\n \t\t    have_used_extensions = 1;\n-\t\t    fprintf (asmfile, \"!%u,\", BINFO_N_BASE_BINFOS (binfo));\n+\t\t    fprintf (asm_out_file, \"!%u,\", BINFO_N_BASE_BINFOS (binfo));\n \t\t    CHARS (8);\n \t\t  }\n \t      }\n@@ -1761,10 +1762,10 @@ dbxout_type (tree type, int full)\n \t\tif (use_gnu_debug_info_extensions)\n \t\t  {\n \t\t    have_used_extensions = 1;\n-\t\t    putc (BINFO_VIRTUAL_P (child) ? '1' : '0', asmfile);\n+\t\t    putc (BINFO_VIRTUAL_P (child) ? '1' : '0', asm_out_file);\n \t\t    putc (access == access_public_node ? '2' :\n \t\t\t  (access == access_protected_node ? '1' :'0'),\n-\t\t\t  asmfile);\n+\t\t\t  asm_out_file);\n \t\t    CHARS (2);\n \t\t    if (BINFO_VIRTUAL_P (child)\n \t\t\t&& strcmp (lang_hooks.name, \"GNU C++\") == 0)\n@@ -1777,10 +1778,10 @@ dbxout_type (tree type, int full)\n \t\t    else\n \t\t      print_wide_int (tree_low_cst (BINFO_OFFSET (child), 0)\n \t\t\t\t      * BITS_PER_UNIT);\n-\t\t    putc (',', asmfile);\n+\t\t    putc (',', asm_out_file);\n \t\t    CHARS (1);\n \t\t    dbxout_type (BINFO_TYPE (child), 0);\n-\t\t    putc (';', asmfile);\n+\t\t    putc (';', asm_out_file);\n \t\t    CHARS (1);\n \t\t  }\n \t\telse\n@@ -1789,19 +1790,19 @@ dbxout_type (tree type, int full)\n \t\t       fields which have the same names at the types\n \t\t       they hold.  */\n \t\t    dbxout_type_name (BINFO_TYPE (child));\n-\t\t    putc (':', asmfile);\n+\t\t    putc (':', asm_out_file);\n \t\t    CHARS (1);\n \t\t    dbxout_type (BINFO_TYPE (child), full);\n-\t\t    putc (',', asmfile);\n+\t\t    putc (',', asm_out_file);\n \t\t    CHARS (1);\n \t\t    print_wide_int (tree_low_cst (BINFO_OFFSET (child), 0)\n \t\t\t\t    * BITS_PER_UNIT);\n-\t\t    putc (',', asmfile);\n+\t\t    putc (',', asm_out_file);\n \t\t    CHARS (1);\n \t\t    print_wide_int\n \t\t      (tree_low_cst (TYPE_SIZE (BINFO_TYPE (child)), 0)\n \t\t       * BITS_PER_UNIT);\n-\t\t    putc (';', asmfile);\n+\t\t    putc (';', asm_out_file);\n \t\t    CHARS (1);\n \t\t  }\n \t      }\n@@ -1816,7 +1817,7 @@ dbxout_type (tree type, int full)\n \t  dbxout_type_methods (type);\n \t}\n \n-      putc (';', asmfile);\n+      putc (';', asm_out_file);\n       CHARS (1);\n \n       if (use_gnu_debug_info_extensions && TREE_CODE (type) == RECORD_TYPE\n@@ -1826,7 +1827,7 @@ dbxout_type (tree type, int full)\n \t  have_used_extensions = 1;\n \n \t  /* Tell GDB+ that it may keep reading.  */\n-\t  putc ('~', asmfile);\n+\t  putc ('~', asm_out_file);\n \t  CHARS (1);\n \n \t  /* We need to write out info about what field this class\n@@ -1835,12 +1836,12 @@ dbxout_type (tree type, int full)\n \t     figure out which field it's using in time.  */\n \t  if (TYPE_VFIELD (type))\n \t    {\n-\t      putc ('%', asmfile);\n+\t      putc ('%', asm_out_file);\n \t      CHARS (1);\n \t      dbxout_type (DECL_FCONTEXT (TYPE_VFIELD (type)), 0);\n \t    }\n \n-\t  putc (';', asmfile);\n+\t  putc (';', asm_out_file);\n \t  CHARS (1);\n \t}\n       break;\n@@ -1855,26 +1856,26 @@ dbxout_type (tree type, int full)\n \t   && !full)\n \t  || !COMPLETE_TYPE_P (type))\n \t{\n-\t  fprintf (asmfile, \"xe\");\n+\t  fprintf (asm_out_file, \"xe\");\n \t  CHARS (2);\n \t  dbxout_type_name (type);\n \t  typevec[TYPE_SYMTAB_ADDRESS (type)].status = TYPE_XREF;\n-\t  putc (':', asmfile);\n+\t  putc (':', asm_out_file);\n \t  CHARS (1);\n \t  return;\n \t}\n       if (use_gnu_debug_info_extensions\n \t  && TYPE_PRECISION (type) != TYPE_PRECISION (integer_type_node))\n \t{\n-\t  fprintf (asmfile, \"@s%d;\", TYPE_PRECISION (type));\n+\t  fprintf (asm_out_file, \"@s%d;\", TYPE_PRECISION (type));\n \t  CHARS (5);\n \t}\n \n-      putc ('e', asmfile);\n+      putc ('e', asm_out_file);\n       CHARS (1);\n       for (tem = TYPE_VALUES (type); tem; tem = TREE_CHAIN (tem))\n \t{\n-\t  fprintf (asmfile, \"%s:\", IDENTIFIER_POINTER (TREE_PURPOSE (tem)));\n+\t  fprintf (asm_out_file, \"%s:\", IDENTIFIER_POINTER (TREE_PURPOSE (tem)));\n \t  CHARS (IDENTIFIER_LENGTH (TREE_PURPOSE (tem)) + 1);\n \t  if (TREE_INT_CST_HIGH (TREE_VALUE (tem)) == 0)\n \t    print_wide_int (TREE_INT_CST_LOW (TREE_VALUE (tem)));\n@@ -1884,18 +1885,18 @@ dbxout_type (tree type, int full)\n \t  else\n \t    print_int_cst_octal (TREE_VALUE (tem));\n \n-\t  putc (',', asmfile);\n+\t  putc (',', asm_out_file);\n \t  CHARS (1);\n \t  if (TREE_CHAIN (tem) != 0)\n \t    CONTIN;\n \t}\n \n-      putc (';', asmfile);\n+      putc (';', asm_out_file);\n       CHARS (1);\n       break;\n \n     case POINTER_TYPE:\n-      putc ('*', asmfile);\n+      putc ('*', asm_out_file);\n       CHARS (1);\n       dbxout_type (TREE_TYPE (type), 0);\n       break;\n@@ -1904,16 +1905,16 @@ dbxout_type (tree type, int full)\n       if (use_gnu_debug_info_extensions)\n \t{\n \t  have_used_extensions = 1;\n-\t  putc ('#', asmfile);\n+\t  putc ('#', asm_out_file);\n \t  CHARS (1);\n \n \t  /* Write the argument types out longhand.  */\n \t  dbxout_type (TYPE_METHOD_BASETYPE (type), 0);\n-\t  putc (',', asmfile);\n+\t  putc (',', asm_out_file);\n \t  CHARS (1);\n \t  dbxout_type (TREE_TYPE (type), 0);\n \t  dbxout_args (TYPE_ARG_TYPES (type));\n-\t  putc (';', asmfile);\n+\t  putc (';', asm_out_file);\n \t  CHARS (1);\n \t}\n       else\n@@ -1925,10 +1926,10 @@ dbxout_type (tree type, int full)\n       if (use_gnu_debug_info_extensions)\n \t{\n \t  have_used_extensions = 1;\n-\t  putc ('@', asmfile);\n+\t  putc ('@', asm_out_file);\n \t  CHARS (1);\n \t  dbxout_type (TYPE_OFFSET_BASETYPE (type), 0);\n-\t  putc (',', asmfile);\n+\t  putc (',', asm_out_file);\n \t  CHARS (1);\n \t  dbxout_type (TREE_TYPE (type), 0);\n \t}\n@@ -1940,13 +1941,13 @@ dbxout_type (tree type, int full)\n     case REFERENCE_TYPE:\n       if (use_gnu_debug_info_extensions)\n \thave_used_extensions = 1;\n-      putc (use_gnu_debug_info_extensions ? '&' : '*', asmfile);\n+      putc (use_gnu_debug_info_extensions ? '&' : '*', asm_out_file);\n       CHARS (1);\n       dbxout_type (TREE_TYPE (type), 0);\n       break;\n \n     case FUNCTION_TYPE:\n-      putc ('f', asmfile);\n+      putc ('f', asm_out_file);\n       CHARS (1);\n       dbxout_type (TREE_TYPE (type), 0);\n       break;\n@@ -2012,7 +2013,7 @@ print_int_cst_octal (tree c)\n   else\n     high = 0, low &= (((HOST_WIDE_INT) 1 << width) - 1);\n \n-  fprintf (asmfile, \"0\");\n+  fprintf (asm_out_file, \"0\");\n   CHARS (1);\n \n   if (excess == 3)\n@@ -2031,7 +2032,7 @@ print_int_cst_octal (tree c)\n \t\t  << (HOST_BITS_PER_WIDE_INT / 3 * 3))\n \t\t - 1);\n \n-      fprintf (asmfile, \"%o%01o\", (int) beg, (int) middle);\n+      fprintf (asm_out_file, \"%o%01o\", (int) beg, (int) middle);\n       CHARS (2);\n       print_octal (end, HOST_BITS_PER_WIDE_INT / 3);\n     }\n@@ -2043,7 +2044,7 @@ print_octal (unsigned HOST_WIDE_INT value, int digits)\n   int i;\n \n   for (i = digits - 1; i >= 0; i--)\n-    fprintf (asmfile, \"%01o\", (int) ((value >> (3 * i)) & 7));\n+    fprintf (asm_out_file, \"%01o\", (int) ((value >> (3 * i)) & 7));\n \n   CHARS (digits);\n }\n@@ -2055,7 +2056,7 @@ print_wide_int (HOST_WIDE_INT c)\n {\n   int digs = 0;\n \n-  fprintf (asmfile, HOST_WIDE_INT_PRINT_DEC, c);\n+  fprintf (asm_out_file, HOST_WIDE_INT_PRINT_DEC, c);\n \n   if (c < 0)\n     digs++, c = -c;\n@@ -2087,7 +2088,7 @@ dbxout_type_name (tree type)\n       gcc_unreachable ();\n     }\n \n-  fprintf (asmfile, \"%s\", IDENTIFIER_POINTER (t));\n+  fprintf (asm_out_file, \"%s\", IDENTIFIER_POINTER (t));\n   CHARS (IDENTIFIER_LENGTH (t));\n }\n \n@@ -2114,7 +2115,7 @@ dbxout_class_name_qualifiers (tree decl)\n \t  dbxout_class_name_qualifiers (name);\n \t  name = DECL_NAME (name);\n \t}\n-      fprintf (asmfile, \"%s::\", IDENTIFIER_POINTER (name));\n+      fprintf (asm_out_file, \"%s::\", IDENTIFIER_POINTER (name));\n       CHARS (IDENTIFIER_LENGTH (name) + 2);\n     }\n }\n@@ -2236,7 +2237,7 @@ dbxout_symbol (tree decl, int local ATTRIBUTE_UNUSED)\n \tbreak;\n       FORCE_TEXT;\n \n-      fprintf (asmfile, \"%s\\\"%s:%c\", ASM_STABS_OP,\n+      fprintf (asm_out_file, \"%s\\\"%s:%c\", ASM_STABS_OP,\n \t       IDENTIFIER_POINTER (DECL_ASSEMBLER_NAME (decl)),\n \t       TREE_PUBLIC (decl) ? 'F' : 'f');\n       result = 1;\n@@ -2253,7 +2254,7 @@ dbxout_symbol (tree decl, int local ATTRIBUTE_UNUSED)\n \t mention the containing function name\n \t as well as (since dbx wants it) our own assembler-name.  */\n       if (context != 0)\n-\tfprintf (asmfile, \",%s,%s\",\n+\tfprintf (asm_out_file, \",%s,%s\",\n \t\t IDENTIFIER_POINTER (DECL_ASSEMBLER_NAME (decl)),\n \t\t IDENTIFIER_POINTER (DECL_NAME (context)));\n \n@@ -2320,14 +2321,14 @@ dbxout_symbol (tree decl, int local ATTRIBUTE_UNUSED)\n \t\tcurrent_sym_addr = 0;\n \t\tcurrent_sym_nchars = 2 + IDENTIFIER_LENGTH (name);\n \n-\t\tfprintf (asmfile, \"%s\\\"%s:T\", ASM_STABS_OP,\n+\t\tfprintf (asm_out_file, \"%s\\\"%s:T\", ASM_STABS_OP,\n \t\t\t IDENTIFIER_POINTER (name));\n \t\tdbxout_type (type, 1);\n \t\tdbxout_finish_symbol (NULL_TREE);\n \t      }\n \n \t    /* Output .stabs (or whatever) and leading double quote.  */\n-\t    fprintf (asmfile, \"%s\\\"\", ASM_STABS_OP);\n+\t    fprintf (asm_out_file, \"%s\\\"\", ASM_STABS_OP);\n \n \t    if (use_gnu_debug_info_extensions)\n \t      {\n@@ -2336,7 +2337,7 @@ dbxout_symbol (tree decl, int local ATTRIBUTE_UNUSED)\n \t      }\n \n \t    /* Output typedef name.  */\n-\t    fprintf (asmfile, \"%s:\", IDENTIFIER_POINTER (DECL_NAME (decl)));\n+\t    fprintf (asm_out_file, \"%s:\", IDENTIFIER_POINTER (DECL_NAME (decl)));\n \n \t    /* Short cut way to output a tag also.  */\n \t    if ((TREE_CODE (type) == RECORD_TYPE\n@@ -2349,16 +2350,12 @@ dbxout_symbol (tree decl, int local ATTRIBUTE_UNUSED)\n \t      {\n \t\tif (use_gnu_debug_info_extensions && have_used_extensions)\n \t\t  {\n-\t\t    putc ('T', asmfile);\n+\t\t    putc ('T', asm_out_file);\n \t\t    TREE_ASM_WRITTEN (TYPE_NAME (type)) = 1;\n \t\t  }\n-#if 0 /* Now we generate the tag for this case up above.  */\n-\t\telse\n-\t\t  tag_needed = 1;\n-#endif\n \t      }\n \n-\t    putc ('t', asmfile);\n+\t    putc ('t', asm_out_file);\n \t    current_sym_code = DBX_TYPE_DECL_STABS_CODE;\n \n \t    dbxout_type (type, 1);\n@@ -2389,7 +2386,7 @@ dbxout_symbol (tree decl, int local ATTRIBUTE_UNUSED)\n \t    current_sym_addr = 0;\n \t    current_sym_nchars = 2 + IDENTIFIER_LENGTH (name);\n \n-\t    fprintf (asmfile, \"%s\\\"%s:T\", ASM_STABS_OP,\n+\t    fprintf (asm_out_file, \"%s\\\"%s:T\", ASM_STABS_OP,\n \t\t     IDENTIFIER_POINTER (name));\n \t    dbxout_type (type, 1);\n \t    dbxout_finish_symbol (NULL_TREE);\n@@ -2408,7 +2405,7 @@ dbxout_symbol (tree decl, int local ATTRIBUTE_UNUSED)\n \n \t    /* Some debuggers fail when given NULL names, so give this a\n \t       harmless name of ` '.  */\n-\t    fprintf (asmfile, \"%s\\\" :T\", ASM_STABS_OP);\n+\t    fprintf (asm_out_file, \"%s\\\" :T\", ASM_STABS_OP);\n \t    dbxout_type (type, 1);\n \t    dbxout_finish_symbol (NULL_TREE);\n \t  }\n@@ -2451,7 +2448,7 @@ dbxout_symbol (tree decl, int local ATTRIBUTE_UNUSED)\n \t\t  || TREE_CODE (TREE_TYPE (decl)) == ENUMERAL_TYPE)\n \t\t{\n \t\t  HOST_WIDE_INT ival = tree_low_cst (DECL_INITIAL (decl), 0);\n-\t\t  fprintf (asmfile, \"%s\\\"%s:c=i\" HOST_WIDE_INT_PRINT_DEC\n+\t\t  fprintf (asm_out_file, \"%s\\\"%s:c=i\" HOST_WIDE_INT_PRINT_DEC\n \t\t\t   \"\\\",0x%x,0,0,0\\n\",\n \t\t\t   ASM_STABS_OP, name, ival, N_LSYM);\n \t\t  DBXOUT_DECR_NESTING;\n@@ -2718,15 +2715,15 @@ dbxout_symbol_location (tree decl, tree type, const char *suffix, rtx home)\n   FORCE_TEXT;\n \n #ifdef DBX_STATIC_BLOCK_START\n-  DBX_STATIC_BLOCK_START (asmfile, current_sym_code);\n+  DBX_STATIC_BLOCK_START (asm_out_file, current_sym_code);\n #endif\n \n   dbxout_symbol_name (decl, suffix, letter);\n   dbxout_type (type, 0);\n   dbxout_finish_symbol (decl);\n \n #ifdef DBX_STATIC_BLOCK_END\n-  DBX_STATIC_BLOCK_END (asmfile, current_sym_code);\n+  DBX_STATIC_BLOCK_END (asm_out_file, current_sym_code);\n #endif\n   return 1;\n }\n@@ -2754,22 +2751,16 @@ dbxout_symbol_name (tree decl, const char *suffix, int letter)\n \n   if (name == 0)\n     name = \"(anon)\";\n-  fprintf (asmfile, \"%s\\\"%s%s:\", ASM_STABS_OP, name,\n+  fprintf (asm_out_file, \"%s\\\"%s%s:\", ASM_STABS_OP, name,\n \t   (suffix ? suffix : \"\"));\n \n   if (letter)\n-    putc (letter, asmfile);\n+    putc (letter, asm_out_file);\n }\n \n static void\n dbxout_prepare_symbol (tree decl ATTRIBUTE_UNUSED)\n {\n-#ifdef WINNING_GDB\n-  const char *filename = DECL_SOURCE_FILE (decl);\n-\n-  dbxout_source_file (asmfile, filename);\n-#endif\n-\n   /* Initialize variables used to communicate each symbol's debug\n      information to dbxout_finish_symbol with zeroes.  */\n \n@@ -2789,12 +2780,12 @@ dbxout_finish_symbol (tree sym)\n   if (use_gnu_debug_info_extensions && sym != 0)\n     line = DECL_SOURCE_LINE (sym);\n \n-  fprintf (asmfile, \"\\\",%d,0,%d,\", current_sym_code, line);\n+  fprintf (asm_out_file, \"\\\",%d,0,%d,\", current_sym_code, line);\n   if (current_sym_addr)\n-    output_addr_const (asmfile, current_sym_addr);\n+    output_addr_const (asm_out_file, current_sym_addr);\n   else\n-    fprintf (asmfile, \"%d\", current_sym_value);\n-  putc ('\\n', asmfile);\n+    fprintf (asm_out_file, \"%d\", current_sym_value);\n+  putc ('\\n', asm_out_file);\n #endif\n }\n \n@@ -2875,14 +2866,14 @@ dbxout_parms (tree parms)\n \t      {\n \t\tcurrent_sym_nchars = 2 + IDENTIFIER_LENGTH (DECL_NAME (parms));\n \n-\t\tfprintf (asmfile, \"%s\\\"%s:%c\", ASM_STABS_OP,\n+\t\tfprintf (asm_out_file, \"%s\\\"%s:%c\", ASM_STABS_OP,\n \t\t\t IDENTIFIER_POINTER (DECL_NAME (parms)),\n \t\t\t DBX_MEMPARM_STABS_LETTER);\n \t      }\n \t    else\n \t      {\n \t\tcurrent_sym_nchars = 8;\n-\t\tfprintf (asmfile, \"%s\\\"(anon):%c\", ASM_STABS_OP,\n+\t\tfprintf (asm_out_file, \"%s\\\"(anon):%c\", ASM_STABS_OP,\n \t\t\t DBX_MEMPARM_STABS_LETTER);\n \t      }\n \n@@ -2940,14 +2931,14 @@ dbxout_parms (tree parms)\n \t    if (DECL_NAME (parms))\n \t      {\n \t\tcurrent_sym_nchars = 2 + IDENTIFIER_LENGTH (DECL_NAME (parms));\n-\t\tfprintf (asmfile, \"%s\\\"%s:%c\", ASM_STABS_OP,\n+\t\tfprintf (asm_out_file, \"%s\\\"%s:%c\", ASM_STABS_OP,\n \t\t\t IDENTIFIER_POINTER (DECL_NAME (parms)),\n \t\t\t regparm_letter);\n \t      }\n \t    else\n \t      {\n \t\tcurrent_sym_nchars = 8;\n-\t\tfprintf (asmfile, \"%s\\\"(anon):%c\", ASM_STABS_OP,\n+\t\tfprintf (asm_out_file, \"%s\\\"(anon):%c\", ASM_STABS_OP,\n \t\t\t regparm_letter);\n \t      }\n \n@@ -2994,14 +2985,14 @@ dbxout_parms (tree parms)\n \t\tcurrent_sym_nchars\n \t\t  = 2 + strlen (IDENTIFIER_POINTER (DECL_NAME (parms)));\n \n-\t\tfprintf (asmfile, \"%s\\\"%s:%c\", ASM_STABS_OP,\n+\t\tfprintf (asm_out_file, \"%s\\\"%s:%c\", ASM_STABS_OP,\n \t\t\t IDENTIFIER_POINTER (DECL_NAME (parms)),\n \t\t\t regparm_letter);\n \t      }\n \t    else\n \t      {\n \t\tcurrent_sym_nchars = 8;\n-\t\tfprintf (asmfile, \"%s\\\"(anon):%c\", ASM_STABS_OP,\n+\t\tfprintf (asm_out_file, \"%s\\\"(anon):%c\", ASM_STABS_OP,\n \t\t\t regparm_letter);\n \t      }\n \n@@ -3027,7 +3018,7 @@ dbxout_parms (tree parms)\n \t    current_sym_code = N_PSYM;\n \n \t    FORCE_TEXT;\n-\t    fprintf (asmfile, \"%s\\\"%s:v\", ASM_STABS_OP, decl_name);\n+\t    fprintf (asm_out_file, \"%s\\\"%s:v\", ASM_STABS_OP, decl_name);\n \n \t    current_sym_value\n \t      = DEBUGGER_ARG_OFFSET (current_sym_value,\n@@ -3074,14 +3065,14 @@ dbxout_parms (tree parms)\n \t\tcurrent_sym_nchars\n \t\t  = 2 + strlen (IDENTIFIER_POINTER (DECL_NAME (parms)));\n \n-\t\tfprintf (asmfile, \"%s\\\"%s:%c\", ASM_STABS_OP,\n+\t\tfprintf (asm_out_file, \"%s\\\"%s:%c\", ASM_STABS_OP,\n \t\t\t IDENTIFIER_POINTER (DECL_NAME (parms)),\n \t\t\t DBX_MEMPARM_STABS_LETTER);\n \t      }\n \t    else\n \t      {\n \t\tcurrent_sym_nchars = 8;\n-\t\tfprintf (asmfile, \"%s\\\"(anon):%c\", ASM_STABS_OP,\n+\t\tfprintf (asm_out_file, \"%s\\\"(anon):%c\", ASM_STABS_OP,\n \t\tDBX_MEMPARM_STABS_LETTER);\n \t      }\n \n@@ -3142,7 +3133,7 @@ dbxout_args (tree args)\n {\n   while (args)\n     {\n-      putc (',', asmfile);\n+      putc (',', asm_out_file);\n       dbxout_type (TREE_VALUE (args), 0);\n       CHARS (1);\n       args = TREE_CHAIN (args);\n@@ -3157,15 +3148,16 @@ dbx_output_lbrac (const char *label,\n \t\t  const char *begin_label ATTRIBUTE_UNUSED)\n {\n #ifdef DBX_OUTPUT_LBRAC\n-  DBX_OUTPUT_LBRAC (asmfile, label);\n+  DBX_OUTPUT_LBRAC (asm_out_file, label);\n #else\n-  fprintf (asmfile, \"%s%d,0,0,\", ASM_STABN_OP, N_LBRAC);\n-  assemble_name (asmfile, label);\n-#if DBX_BLOCKS_FUNCTION_RELATIVE\n-  putc ('-', asmfile);\n-  assemble_name (asmfile, begin_label);\n-#endif\n-  fprintf (asmfile, \"\\n\");\n+  fprintf (asm_out_file, \"%s%d,0,0,\", ASM_STABN_OP, N_LBRAC);\n+  assemble_name (asm_out_file, label);\n+  if (DBX_BLOCKS_FUNCTION_RELATIVE)\n+    {\n+      putc ('-', asm_out_file);\n+      assemble_name (asm_out_file, begin_label);\n+    }\n+  fprintf (asm_out_file, \"\\n\");\n #endif\n }\n \n@@ -3177,15 +3169,16 @@ dbx_output_rbrac (const char *label,\n \t\t  const char *begin_label ATTRIBUTE_UNUSED)\n {\n #ifdef DBX_OUTPUT_RBRAC\n-  DBX_OUTPUT_RBRAC (asmfile, label);\n+  DBX_OUTPUT_RBRAC (asm_out_file, label);\n #else\n-  fprintf (asmfile, \"%s%d,0,0,\", ASM_STABN_OP, N_RBRAC);\n-  assemble_name (asmfile, label);\n-#if DBX_BLOCKS_FUNCTION_RELATIVE\n-  putc ('-', asmfile);\n-  assemble_name (asmfile, begin_label);\n-#endif\n-  fprintf (asmfile, \"\\n\");\n+  fprintf (asm_out_file, \"%s%d,0,0,\", ASM_STABN_OP, N_RBRAC);\n+  assemble_name (asm_out_file, label);\n+  if (DBX_BLOCKS_FUNCTION_RELATIVE)\n+    {\n+      putc ('-', asm_out_file);\n+      assemble_name (asm_out_file, begin_label);\n+    }\n+  fprintf (asm_out_file, \"\\n\");\n #endif\n }\n \n@@ -3210,10 +3203,7 @@ static void\n dbxout_block (tree block, int depth, tree args)\n {\n   const char *begin_label;\n-  if (current_function_func_begin_label != NULL)\n-    begin_label = current_function_func_begin_label;\n-  else\n-    begin_label = XSTR (XEXP (DECL_RTL (current_function_decl), 0), 0);\n+  begin_label = XSTR (XEXP (DECL_RTL (current_function_decl), 0), 0);\n \n   while (block)\n     {\n@@ -3256,10 +3246,10 @@ dbxout_block (tree block, int depth, tree args)\n \t\t  tree decl = BLOCK_VARS (block);\n \t\t  while (decl)\n \t\t    {\n-\t\t      fprintf (asmfile, \"%s\\\"%s:C1\\\",%d,0,0,\", ASM_STABS_OP,\n+\t\t      fprintf (asm_out_file, \"%s\\\"%s:C1\\\",%d,0,0,\", ASM_STABS_OP,\n \t\t\t       IDENTIFIER_POINTER (DECL_NAME (decl)), N_CATCH);\n-\t\t      assemble_name (asmfile, scope_start);\n-\t\t      fprintf (asmfile, \"\\n\");\n+\t\t      assemble_name (asm_out_file, scope_start);\n+\t\t      fprintf (asm_out_file, \"\\n\");\n \t\t      decl = TREE_CHAIN (decl);\n \t\t    }\n \t\t}"}, {"sha": "adffe8f7d627a81d983cfcdbd20852fb760068c1", "filename": "gcc/doc/tm.texi", "status": "modified", "additions": 34, "deletions": 14, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3e487b219e85b65965474f9b3784cc513ab2bc2a/gcc%2Fdoc%2Ftm.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3e487b219e85b65965474f9b3784cc513ab2bc2a/gcc%2Fdoc%2Ftm.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Ftm.texi?ref=3e487b219e85b65965474f9b3784cc513ab2bc2a", "patch": "@@ -6259,17 +6259,6 @@ the assembler source.  So you can use it to canonicalize the format\n of the filename using this macro.\n @end defmac\n \n-@defmac ASM_OUTPUT_SOURCE_LINE (@var{stream}, @var{line}, @var{counter})\n-A C statement to output DBX or SDB debugging information before code\n-for line number @var{line} of the current source file to the\n-stdio stream @var{stream}. @var{counter} is the number of time the\n-macro was invoked, including the current invocation; it is intended\n-to generate unique labels in the assembly output.\n-\n-This macro need not be defined if the standard form of debugging\n-information for the debugger in use is appropriate.\n-@end defmac\n-\n @defmac ASM_OUTPUT_IDENT (@var{stream}, @var{string})\n A C statement to output something to the assembler file to handle a\n @samp{#ident} directive containing the text @var{string}.  If this\n@@ -7990,9 +7979,16 @@ code.\n @end defmac\n \n @defmac DBX_BLOCKS_FUNCTION_RELATIVE\n-Define this macro if the value of a symbol describing the scope of a\n-block (@code{N_LBRAC} or @code{N_RBRAC}) should be relative to the start\n-of the enclosing function.  Normally, GCC uses an absolute address.\n+Define this macro, with value 1, if the value of a symbol describing\n+the scope of a block (@code{N_LBRAC} or @code{N_RBRAC}) should be\n+relative to the start of the enclosing function.  Normally, GCC uses\n+an absolute address.\n+@end defmac\n+\n+@defmac DBX_LINES_FUNCTION_RELATIVE\n+Define this macro, with value 1, if the value of a symbol indicating\n+the current line number (@code{N_SLINE}) should be relative to the\n+start of the enclosing function.  Normally, GCC uses an absolute address.\n @end defmac\n \n @defmac DBX_USE_BINCL\n@@ -8026,6 +8022,17 @@ Define this macro if the target machine requires special handling to\n output an @code{N_FUN} entry for the function @var{decl}.\n @end defmac\n \n+@defmac DBX_OUTPUT_SOURCE_LINE (@var{stream}, @var{line}, @var{counter})\n+A C statement to output DBX debugging information before code for line\n+number @var{line} of the current source file to the stdio stream\n+@var{stream}. @var{counter} is the number of time the macro was\n+invoked, including the current invocation; it is intended to generate\n+unique labels in the assembly output.\n+\n+This macro should not be defined if the default output is correct, or\n+if it can be made correct by defining @code{DBX_LINES_FUNCTION_RELATIVE}.\n+@end defmac\n+\n @defmac DBX_OUTPUT_FUNCTION_END (@var{stream}, @var{function})\n Define this macro if the target machine requires special output at the\n end of the debugging information for a function.  The definition should\n@@ -8080,6 +8087,13 @@ If you don't define this macro, nothing special is output at the end\n of compilation, which is correct for most machines.\n @end defmac\n \n+@defmac DBX_OUTPUT_NULL_N_SO_AT_MAIN_SOURCE_FILE_END\n+Define this macro @emph{instead of} defining\n+@code{DBX_OUTPUT_MAIN_SOURCE_FILE_END}, if what needs to be output at\n+the end of compilation is a @code{N_SO} stab with an empty string,\n+whose value is the highest absolute text address in the file.\n+@end defmac\n+\n @need 2000\n @node SDB and DWARF\n @subsection Macros for SDB and DWARF Output\n@@ -8172,6 +8186,12 @@ enumeration tags that have not yet been seen to be handled.  Some\n assemblers choke if forward tags are used, while some require it.\n @end defmac\n \n+@defmac SDB_OUTPUT_SOURCE_LINE (@var{stream}, @var{line})\n+A C statement to output SDB debugging information before code for line\n+number @var{line} of the current source file to the stdio stream\n+@var{stream}.  The default is to emit an @code{.ln} directive.\n+@end defmac\n+\n @need 2000\n @node VMS Debug\n @subsection Macros for VMS Debug Format"}, {"sha": "a0f31fe065373a8f1b569c3b61710828d72556a0", "filename": "gcc/sdbout.c", "status": "modified", "additions": 4, "deletions": 14, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3e487b219e85b65965474f9b3784cc513ab2bc2a/gcc%2Fsdbout.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3e487b219e85b65965474f9b3784cc513ab2bc2a/gcc%2Fsdbout.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsdbout.c?ref=3e487b219e85b65965474f9b3784cc513ab2bc2a", "patch": "@@ -52,10 +52,6 @@ AT&T C compiler.  From the example below I would conclude the following:\n \n static GTY(()) tree anonymous_types;\n \n-/* Counter for sdbout_source_line.  */\n-\n-static GTY(()) int sdbout_source_line_counter;\n-\n /* Counter to generate unique \"names\" for nameless struct members.  */\n \n static GTY(()) int unnamed_struct_number;\n@@ -292,11 +288,6 @@ do { fprintf (asm_out_file, \"\\t.tag\\t\");\t\\\n \n #ifdef MIPS_DEBUGGING_INFO\n \n-#ifndef PUT_SDB_SRC_FILE\n-#define PUT_SDB_SRC_FILE(FILENAME) \\\n-output_file_directive (asm_out_file, (FILENAME))\n-#endif\n-\n /* ECOFF linkers have an optimization that does the same kind of thing as\n    N_BINCL/E_INCL in stabs: eliminate duplicate debug information in the\n    executable.  To achieve this, GCC must output a .file for each file\n@@ -1545,9 +1536,8 @@ sdbout_source_line (unsigned int line, const char *filename ATTRIBUTE_UNUSED)\n   /* COFF relative line numbers must be positive.  */\n   if ((int) line > sdb_begin_function_line)\n     {\n-#ifdef ASM_OUTPUT_SOURCE_LINE\n-      sdbout_source_line_counter += 1;\n-      ASM_OUTPUT_SOURCE_LINE (asm_out_file, line, sdbout_source_line_counter);\n+#ifdef SDB_OUTPUT_SOURCE_LINE\n+      SDB_OUTPUT_SOURCE_LINE (asm_out_file, line);\n #else\n       fprintf (asm_out_file, \"\\t.ln\\t%d\\n\",\n \t       ((sdb_begin_function_line > -1)\n@@ -1650,7 +1640,7 @@ sdbout_start_source_file (unsigned int line ATTRIBUTE_UNUSED,\n   n->next = current_file;\n   n->name = filename;\n   current_file = n;\n-  PUT_SDB_SRC_FILE (filename);\n+  output_file_directive (asm_out_file, filename);\n #endif\n }\n \n@@ -1665,7 +1655,7 @@ sdbout_end_source_file (unsigned int line ATTRIBUTE_UNUSED)\n   next = current_file->next;\n   free (current_file);\n   current_file = next;\n-  PUT_SDB_SRC_FILE (current_file->name);\n+  output_file_directive (asm_out_file, current_file->name);\n #endif\n }\n "}, {"sha": "f79755a58a869792a7a9f6f9ff1024b79b195454", "filename": "gcc/xcoffout.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3e487b219e85b65965474f9b3784cc513ab2bc2a/gcc%2Fxcoffout.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3e487b219e85b65965474f9b3784cc513ab2bc2a/gcc%2Fxcoffout.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fxcoffout.c?ref=3e487b219e85b65965474f9b3784cc513ab2bc2a", "patch": "@@ -77,8 +77,8 @@ const char *xcoff_lastfile;\n #define ABS_OR_RELATIVE_LINENO(LINENO)\t\t\\\n ((xcoff_inlining) ? (LINENO) : (LINENO) - xcoff_begin_function_line)\n \n-/* Output source line numbers via \".line\" rather than \".stabd\".  */\n-#define ASM_OUTPUT_SOURCE_LINE(FILE,LINENUM,COUNTER)\t\t\t   \\\n+/* Output source line numbers via \".line\".  */\n+#define ASM_OUTPUT_LINE(FILE,LINENUM)\t\t\t\t\t   \\\n   do\t\t\t\t\t\t\t\t\t   \\\n     {\t\t\t\t\t\t\t\t\t   \\\n       if (xcoff_begin_function_line >= 0)\t\t\t\t   \\\n@@ -327,7 +327,7 @@ xcoffout_source_line (unsigned int line, const char *filename)\n \n   xcoffout_source_file (asm_out_file, filename, inline_p);\n \n-  ASM_OUTPUT_SOURCE_LINE (asm_out_file, line, 0);\n+  ASM_OUTPUT_LINE (asm_out_file, line);\n }\n \f\n /* Output the symbols defined in block number DO_BLOCK.\n@@ -454,7 +454,7 @@ xcoffout_begin_prologue (unsigned int line,\n   xcoffout_block (DECL_INITIAL (current_function_decl), 0,\n \t\t  DECL_ARGUMENTS (current_function_decl));\n \n-  ASM_OUTPUT_SOURCE_LINE (asm_out_file, line, 0);\n+  ASM_OUTPUT_LINE (asm_out_file, line);\n }\n \n /* Called at end of function (before epilogue)."}]}