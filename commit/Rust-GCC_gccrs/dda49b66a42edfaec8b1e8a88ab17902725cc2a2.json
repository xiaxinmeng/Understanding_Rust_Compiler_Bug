{"sha": "dda49b66a42edfaec8b1e8a88ab17902725cc2a2", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZGRhNDliNjZhNDJlZGZhZWM4YjFlOGE4OGFiMTc5MDI3MjVjYzJhMg==", "commit": {"author": {"name": "Steven Bosscher", "email": "stevenb@suse.de", "date": "2004-11-10T09:28:29Z"}, "committer": {"name": "Steven Bosscher", "email": "steven@gcc.gnu.org", "date": "2004-11-10T09:28:29Z"}, "message": "basic-block.h (XMALLOC_REG_SET, [...]): New.\n\n\t* basic-block.h (XMALLOC_REG_SET, XFREE_REG_SET): New.\n\t(struct basic_block_def): Remove local_set and cond_local_set\n\tfields.  Update comment for global_live_at_start.\n\t* flow.c (calculate_global_regs_live): Allocate local_sets and\n\tcond_local_sets here as arrays of bitmaps previously stored in\n\tbb->local_set and bb->cond_local_set.  Use xmalloc instead of\n\tobstack allocated bitmaps.\n\nFrom-SVN: r90390", "tree": {"sha": "2efa314b6281d1e40cb30483e9f8f23f9c5ce242", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/2efa314b6281d1e40cb30483e9f8f23f9c5ce242"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/dda49b66a42edfaec8b1e8a88ab17902725cc2a2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dda49b66a42edfaec8b1e8a88ab17902725cc2a2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/dda49b66a42edfaec8b1e8a88ab17902725cc2a2", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dda49b66a42edfaec8b1e8a88ab17902725cc2a2/comments", "author": null, "committer": null, "parents": [{"sha": "780f9446a96b40740a25da0db150fa3e8184fbfc", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/780f9446a96b40740a25da0db150fa3e8184fbfc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/780f9446a96b40740a25da0db150fa3e8184fbfc"}], "stats": {"total": 109, "additions": 70, "deletions": 39}, "files": [{"sha": "a83ec6ebaedd0bb8b24c0a17474f59e560809ac0", "filename": "gcc/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dda49b66a42edfaec8b1e8a88ab17902725cc2a2/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dda49b66a42edfaec8b1e8a88ab17902725cc2a2/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=dda49b66a42edfaec8b1e8a88ab17902725cc2a2", "patch": "@@ -1,3 +1,13 @@\n+2004-11-10  Steven Bosscher  <stevenb@suse.de>\n+\n+\t* basic-block.h (XMALLOC_REG_SET, XFREE_REG_SET): New.\n+\t(struct basic_block_def): Remove local_set and cond_local_set\n+\tfields.  Update comment for global_live_at_start.\n+\t* flow.c (calculate_global_regs_live): Allocate local_sets and\n+\tcond_local_sets here as arrays of bitmaps previously stored in\n+\tbb->local_set and bb->cond_local_set.  Use xmalloc instead of\n+\tobstack allocated bitmaps.\n+\n 2004-11-09  H.J. Lu  <hongjiu.lu@intel.com>\n \n \tPR target/18380"}, {"sha": "7ef4a46cb3d51193875256084949c0c7cec2c791", "filename": "gcc/basic-block.h", "status": "modified", "additions": 8, "deletions": 13, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dda49b66a42edfaec8b1e8a88ab17902725cc2a2/gcc%2Fbasic-block.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dda49b66a42edfaec8b1e8a88ab17902725cc2a2/gcc%2Fbasic-block.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbasic-block.h?ref=dda49b66a42edfaec8b1e8a88ab17902725cc2a2", "patch": "@@ -110,6 +110,12 @@ typedef bitmap_iterator reg_set_iterator;\n /* Do any cleanup needed on a regset when it is no longer used.  */\n #define FREE_REG_SET(REGSET) BITMAP_FREE(REGSET)\n \n+/* Allocate a register set with xmalloc.  */\n+#define XMALLOC_REG_SET() BITMAP_XMALLOC ()\n+\n+/* Free a register set.  */\n+#define XFREE_REG_SET(REGSET) BITMAP_XFREE (REGSET)\n+\n /* Do any one-time initializations needed for regsets.  */\n #define INIT_ONCE_REG_SET() BITMAP_INIT_ONCE ()\n \n@@ -229,20 +235,9 @@ struct basic_block_def GTY((chain_next (\"%h.next_bb\"), chain_prev (\"%h.prev_bb\")\n   VEC(edge) *preds;\n   VEC(edge) *succs;\n \n-  /* Liveness info.  */\n-\n-  /* The registers that are modified within this in block.  */\n-  bitmap GTY ((skip (\"\"))) local_set;\n-  /* The registers that are conditionally modified within this block.\n-     In other words, registers that are set only as part of a\n-     COND_EXEC.  */\n-  bitmap GTY ((skip (\"\"))) cond_local_set;\n-  /* The registers that are live on entry to this block.\n-\n-     Note that in SSA form, global_live_at_start does not reflect the\n-     use of regs in phi functions, since the liveness of these regs\n-     may depend on which edge was taken into the block.  */\n+  /* The registers that are live on entry to this block.  */\n   bitmap GTY ((skip (\"\"))) global_live_at_start;\n+\n   /* The registers that are live on exit from this block.  */\n   bitmap GTY ((skip (\"\"))) global_live_at_end;\n "}, {"sha": "2ccd7554ca9316c726455b87b5c79e09bac56800", "filename": "gcc/flow.c", "status": "modified", "additions": 52, "deletions": 26, "changes": 78, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dda49b66a42edfaec8b1e8a88ab17902725cc2a2/gcc%2Fflow.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dda49b66a42edfaec8b1e8a88ab17902725cc2a2/gcc%2Fflow.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fflow.c?ref=dda49b66a42edfaec8b1e8a88ab17902725cc2a2", "patch": "@@ -112,7 +112,7 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n /* TODO:\n \n    Split out from life_analysis:\n-\t- local property discovery (bb->local_live, bb->local_set)\n+\t- local property discovery\n \t- global property computation\n \t- log links creation\n \t- pre/post modify transformation\n@@ -1018,6 +1018,14 @@ calculate_global_regs_live (sbitmap blocks_in, sbitmap blocks_out, int flags)\n   regset tmp, new_live_at_end, invalidated_by_call;\n   regset_head tmp_head, invalidated_by_call_head;\n   regset_head new_live_at_end_head;\n+\n+  /* The registers that are modified within this in block.  */\n+  regset *local_sets;\n+\n+  /* The registers that are conditionally modified within this block.\n+     In other words, regs that are set only as part of a COND_EXEC.  */\n+  regset *cond_local_sets;\n+\n   int i;\n \n   /* Some passes used to forget clear aux field of basic block causing\n@@ -1036,12 +1044,18 @@ calculate_global_regs_live (sbitmap blocks_in, sbitmap blocks_out, int flags)\n     if (TEST_HARD_REG_BIT (regs_invalidated_by_call, i))\n       SET_REGNO_REG_SET (invalidated_by_call, i);\n \n+  /* Allocate space for the sets of local properties.  */\n+  local_sets = xcalloc (last_basic_block - (INVALID_BLOCK + 1),\n+\t\t\tsizeof (regset));\n+  cond_local_sets = xcalloc (last_basic_block - (INVALID_BLOCK + 1),\n+\t\t\t     sizeof (regset));\n+\n   /* Create a worklist.  Allocate an extra slot for ENTRY_BLOCK, and one\n      because the `head == tail' style test for an empty queue doesn't\n      work with a full queue.  */\n-  queue = xmalloc ((n_basic_blocks + 2) * sizeof (*queue));\n+  queue = xmalloc ((n_basic_blocks - (INVALID_BLOCK + 1)) * sizeof (*queue));\n   qtail = queue;\n-  qhead = qend = queue + n_basic_blocks + 2;\n+  qhead = qend = queue + n_basic_blocks - (INVALID_BLOCK + 1);\n \n   /* Queue the blocks set in the initial mask.  Do this in reverse block\n      number order so that we are more likely for the first round to do\n@@ -1171,13 +1185,14 @@ calculate_global_regs_live (sbitmap blocks_in, sbitmap blocks_out, int flags)\n \t}\n \n       /* On our first pass through this block, we'll go ahead and continue.\n-\t Recognize first pass by local_set NULL.  On subsequent passes, we\n-\t get to skip out early if live_at_end wouldn't have changed.  */\n+\t Recognize first pass by checking if local_set is NULL for this\n+         basic block.  On subsequent passes, we get to skip out early if\n+\t live_at_end wouldn't have changed.  */\n \n-      if (bb->local_set == NULL)\n+      if (local_sets[bb->index - (INVALID_BLOCK + 1)] == NULL)\n \t{\n-\t  bb->local_set = OBSTACK_ALLOC_REG_SET (&flow_obstack);\n-\t  bb->cond_local_set = OBSTACK_ALLOC_REG_SET (&flow_obstack);\n+\t  local_sets[bb->index - (INVALID_BLOCK + 1)] = XMALLOC_REG_SET ();\n+\t  cond_local_sets[bb->index - (INVALID_BLOCK + 1)] = XMALLOC_REG_SET ();\n \t  rescan = 1;\n \t}\n       else\n@@ -1190,28 +1205,35 @@ calculate_global_regs_live (sbitmap blocks_in, sbitmap blocks_out, int flags)\n \t\t\t\t\t     new_live_at_end);\n \n \t  if (!rescan)\n-\t    /* If any of the registers in the new live_at_end set are\n-\t       conditionally set in this basic block, we must rescan.\n-\t       This is because conditional lifetimes at the end of the\n-\t       block do not just take the live_at_end set into\n-\t       account, but also the liveness at the start of each\n-\t       successor block.  We can miss changes in those sets if\n-\t       we only compare the new live_at_end against the\n-\t       previous one.  */\n-\t    rescan = bitmap_intersect_p (new_live_at_end,\n-\t\t\t\t\t bb->cond_local_set);\n+\t    {\n+\t      regset cond_local_set;\n+\n+\t       /* If any of the registers in the new live_at_end set are\n+\t\t  conditionally set in this basic block, we must rescan.\n+\t\t  This is because conditional lifetimes at the end of the\n+\t\t  block do not just take the live_at_end set into\n+\t\t  account, but also the liveness at the start of each\n+\t\t  successor block.  We can miss changes in those sets if\n+\t\t  we only compare the new live_at_end against the\n+\t\t  previous one.  */\n+\t      cond_local_set = cond_local_sets[bb->index - (INVALID_BLOCK + 1)];\n+\t      rescan = bitmap_intersect_p (new_live_at_end, cond_local_set);\n+\t    }\n \n \t  if (!rescan)\n \t    {\n+\t      regset local_set;\n+\n \t      /* Find the set of changed bits.  Take this opportunity\n \t\t to notice that this set is empty and early out.  */\n \t      bitmap_xor (tmp, bb->global_live_at_end, new_live_at_end);\n \t      if (bitmap_empty_p (tmp))\n \t\tcontinue;\n   \n-\t      /* If any of the changed bits overlap with local_set,\n+\t      /* If any of the changed bits overlap with local_sets[bb],\n  \t\t we'll have to rescan the block.  */\n-\t      rescan = bitmap_intersect_p (tmp, bb->local_set);\n+\t      local_set = local_sets[bb->index - (INVALID_BLOCK + 1)];\n+\t      rescan = bitmap_intersect_p (tmp, local_set);\n \t    }\n \t}\n \n@@ -1238,8 +1260,10 @@ calculate_global_regs_live (sbitmap blocks_in, sbitmap blocks_out, int flags)\n \n \t  /* Rescan the block insn by insn to turn (a copy of) live_at_end\n \t     into live_at_start.  */\n-\t  propagate_block (bb, new_live_at_end, bb->local_set,\n-\t\t\t   bb->cond_local_set, flags);\n+\t  propagate_block (bb, new_live_at_end,\n+\t\t\t   local_sets[bb->index - (INVALID_BLOCK + 1)],\n+\t\t\t   cond_local_sets[bb->index - (INVALID_BLOCK + 1)],\n+\t\t\t   flags);\n \n \t  /* If live_at start didn't change, no need to go farther.  */\n \t  if (REG_SET_EQUAL_P (bb->global_live_at_start, new_live_at_end))\n@@ -1272,20 +1296,22 @@ calculate_global_regs_live (sbitmap blocks_in, sbitmap blocks_out, int flags)\n       EXECUTE_IF_SET_IN_SBITMAP (blocks_out, 0, i,\n \t{\n \t  basic_block bb = BASIC_BLOCK (i);\n-\t  FREE_REG_SET (bb->local_set);\n-\t  FREE_REG_SET (bb->cond_local_set);\n+\t  XFREE_REG_SET (local_sets[bb->index - (INVALID_BLOCK + 1)]);\n+\t  XFREE_REG_SET (cond_local_sets[bb->index - (INVALID_BLOCK + 1)]);\n \t});\n     }\n   else\n     {\n       FOR_EACH_BB (bb)\n \t{\n-\t  FREE_REG_SET (bb->local_set);\n-\t  FREE_REG_SET (bb->cond_local_set);\n+\t  XFREE_REG_SET (local_sets[bb->index - (INVALID_BLOCK + 1)]);\n+\t  XFREE_REG_SET (cond_local_sets[bb->index - (INVALID_BLOCK + 1)]);\n \t}\n     }\n \n   free (queue);\n+  free (cond_local_sets);\n+  free (local_sets);\n }\n \n \f"}]}