{"sha": "a8fa1b3d08ea4cc31f858d2add1b22e62b8db5e1", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YThmYTFiM2QwOGVhNGNjMzFmODU4ZDJhZGQxYjIyZTYyYjhkYjVlMQ==", "commit": {"author": {"name": "Claire Dross", "email": "dross@adacore.com", "date": "2019-07-11T08:03:09Z"}, "committer": {"name": "Pierre-Marie de Rodat", "email": "pmderodat@gcc.gnu.org", "date": "2019-07-11T08:03:09Z"}, "message": "[Ada] Refactor ownership pointer checking in SPARK as a generic\n\nOwnership checking as done in SPARK should be applied only to SPARK\ncode, which requires GNATprove knowledge of the SPARK_Mode boundary.\nTransform the checking unit into a generic to allow passing in the\nknowledge from GNATprove to that unit in GNAT sources.\n\nKeeping the code in GNAT sources makes it possible in the future to\nadapt it further (or simply instantiate it differently) to be used on\nAda code, independently of GNATprove.\n\nThere is no impact on compilation.\n\n2019-07-11  Claire Dross  <dross@adacore.com>\n\ngcc/ada/\n\n\t* gnat1drv.adb: SPARK checking rules for pointer aliasing are\n\tmoved to GNATprove backend.\n\t* sem_spark.ads, sem_spark.adb (Sem_SPARK): Is now a generic\n\tunit. Takes as parameters:\n\t - Retysp which is used to query the most underlying type\n\t   visible in SPARK. We do not introduce aliasing checks for\n\t   types which are not visibly deep.\n\t - Component_Is_Visible_In_SPARK is used to avoid doing pointer\n\t   aliasing checks on components which are not visible in SPARK.\n\t - Emit_Messages returns True in the second phase of SPARK\n\t   analysis. Error messages for failed aliasing checks are only\n\t   output in this case.\n\tAdditionally, errors on constructs not supported in SPARK are\n\tremoved as duplicates of marking errors. Components are stored\n\tin the permission map using their original component to avoid\n\tinconsistencies between components of different views of the\n\tsame type.\n\t(Check_Expression): Handle delta constraints.\n\t(Is_Deep): Exported so that we can check for SPARK restrictions\n\ton deep types inside SPARK semantic checkings.\n\t(Is_Traversal_Function): Exported so that we can check for SPARK\n\trestrictions on traversal functions inside SPARK semantic\n\tcheckings.\n\t(Check_Call_Statement, Read_Indexes): Check wether we are\n\tdealing with a subprogram pointer type before querying called\n\tentity.\n\t(Is_Subpath_Expression): Image attribute can appear inside a\n\tpath.\n\t(Check_Loop_Statement): Correct order of statements in the loop.\n\t(Check_Node): Ignore raise nodes.\n\t(Check_Statement): Use Last_Non_Pragma to get the object\n\tdeclaration in an extended return statement.\n\nFrom-SVN: r273402", "tree": {"sha": "a0da9db4f43ba18258aaf14ea8051f7d8bb6c868", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a0da9db4f43ba18258aaf14ea8051f7d8bb6c868"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a8fa1b3d08ea4cc31f858d2add1b22e62b8db5e1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a8fa1b3d08ea4cc31f858d2add1b22e62b8db5e1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a8fa1b3d08ea4cc31f858d2add1b22e62b8db5e1", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a8fa1b3d08ea4cc31f858d2add1b22e62b8db5e1/comments", "author": {"login": "clairedross", "id": 8180017, "node_id": "MDQ6VXNlcjgxODAwMTc=", "avatar_url": "https://avatars.githubusercontent.com/u/8180017?v=4", "gravatar_id": "", "url": "https://api.github.com/users/clairedross", "html_url": "https://github.com/clairedross", "followers_url": "https://api.github.com/users/clairedross/followers", "following_url": "https://api.github.com/users/clairedross/following{/other_user}", "gists_url": "https://api.github.com/users/clairedross/gists{/gist_id}", "starred_url": "https://api.github.com/users/clairedross/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/clairedross/subscriptions", "organizations_url": "https://api.github.com/users/clairedross/orgs", "repos_url": "https://api.github.com/users/clairedross/repos", "events_url": "https://api.github.com/users/clairedross/events{/privacy}", "received_events_url": "https://api.github.com/users/clairedross/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "be04e8eda375765f5336316085f0c4bd4ef468d5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/be04e8eda375765f5336316085f0c4bd4ef468d5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/be04e8eda375765f5336316085f0c4bd4ef468d5"}], "stats": {"total": 478, "additions": 329, "deletions": 149}, "files": [{"sha": "95c898b3768d0163ec73cd776df841294f936a6e", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a8fa1b3d08ea4cc31f858d2add1b22e62b8db5e1/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a8fa1b3d08ea4cc31f858d2add1b22e62b8db5e1/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=a8fa1b3d08ea4cc31f858d2add1b22e62b8db5e1", "patch": "@@ -1,3 +1,38 @@\n+2019-07-11  Claire Dross  <dross@adacore.com>\n+\n+\t* gnat1drv.adb: SPARK checking rules for pointer aliasing are\n+\tmoved to GNATprove backend.\n+\t* sem_spark.ads, sem_spark.adb (Sem_SPARK): Is now a generic\n+\tunit. Takes as parameters:\n+\t - Retysp which is used to query the most underlying type\n+\t   visible in SPARK. We do not introduce aliasing checks for\n+\t   types which are not visibly deep.\n+\t - Component_Is_Visible_In_SPARK is used to avoid doing pointer\n+\t   aliasing checks on components which are not visible in SPARK.\n+\t - Emit_Messages returns True in the second phase of SPARK\n+\t   analysis. Error messages for failed aliasing checks are only\n+\t   output in this case.\n+\tAdditionally, errors on constructs not supported in SPARK are\n+\tremoved as duplicates of marking errors. Components are stored\n+\tin the permission map using their original component to avoid\n+\tinconsistencies between components of different views of the\n+\tsame type.\n+\t(Check_Expression): Handle delta constraints.\n+\t(Is_Deep): Exported so that we can check for SPARK restrictions\n+\ton deep types inside SPARK semantic checkings.\n+\t(Is_Traversal_Function): Exported so that we can check for SPARK\n+\trestrictions on traversal functions inside SPARK semantic\n+\tcheckings.\n+\t(Check_Call_Statement, Read_Indexes): Check wether we are\n+\tdealing with a subprogram pointer type before querying called\n+\tentity.\n+\t(Is_Subpath_Expression): Image attribute can appear inside a\n+\tpath.\n+\t(Check_Loop_Statement): Correct order of statements in the loop.\n+\t(Check_Node): Ignore raise nodes.\n+\t(Check_Statement): Use Last_Non_Pragma to get the object\n+\tdeclaration in an extended return statement.\n+\n 2019-07-11  Patrick Bernardi  <bernardi@adacore.com>\n \n \t* bindgen.adb (Gen_Main): Do not generate a reference to"}, {"sha": "ecb3ccdd39917639f32a6e632f1d0d773f9381d4", "filename": "gcc/ada/gnat1drv.adb", "status": "modified", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a8fa1b3d08ea4cc31f858d2add1b22e62b8db5e1/gcc%2Fada%2Fgnat1drv.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a8fa1b3d08ea4cc31f858d2add1b22e62b8db5e1/gcc%2Fada%2Fgnat1drv.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgnat1drv.adb?ref=a8fa1b3d08ea4cc31f858d2add1b22e62b8db5e1", "patch": "@@ -63,7 +63,6 @@ with Sem_Ch13;\n with Sem_Elim;\n with Sem_Eval;\n with Sem_Prag;\n-with Sem_SPARK; use Sem_SPARK;\n with Sem_Type;\n with Set_Targ;\n with Sinfo;     use Sinfo;\n@@ -1586,13 +1585,6 @@ begin\n \n       if GNATprove_Mode then\n \n-         --  Perform the new SPARK checking rules for pointer aliasing. This is\n-         --  only activated in GNATprove mode and on SPARK code.\n-\n-         if Debug_Flag_FF then\n-            Check_Safe_Pointers (Main_Unit_Node);\n-         end if;\n-\n          --  In GNATprove mode we're writing the ALI much earlier than usual\n          --  as flow analysis needs the file present in order to append its\n          --  own globals to it."}, {"sha": "67aa4537c1d4dbe77355e4080ee7598e138cfaa5", "filename": "gcc/ada/sem_spark.adb", "status": "modified", "additions": 272, "deletions": 141, "changes": 413, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a8fa1b3d08ea4cc31f858d2add1b22e62b8db5e1/gcc%2Fada%2Fsem_spark.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a8fa1b3d08ea4cc31f858d2add1b22e62b8db5e1/gcc%2Fada%2Fsem_spark.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_spark.adb?ref=a8fa1b3d08ea4cc31f858d2add1b22e62b8db5e1", "patch": "@@ -641,7 +641,8 @@ package body Sem_SPARK is\n    pragma Precondition (Nkind_In (Expr, N_Index_Or_Discriminant_Constraint,\n                                         N_Range_Constraint,\n                                         N_Subtype_Indication,\n-                                        N_Digits_Constraint)\n+                                        N_Digits_Constraint,\n+                                        N_Delta_Constraint)\n                         or else Nkind (Expr) in N_Subexpr);\n \n    procedure Check_Globals (Subp : Entity_Id);\n@@ -744,10 +745,6 @@ package body Sem_SPARK is\n    --  A procedure that is called when deep globals or aliased globals are used\n    --  without any global aspect.\n \n-   function Is_Deep (Typ : Entity_Id) return Boolean;\n-   --  A function that can tell if a type is deep or not. Returns true if the\n-   --  type passed as argument is deep.\n-\n    function Is_Path_Expression (Expr : Node_Id) return Boolean;\n    --  Return whether Expr corresponds to a path\n \n@@ -759,8 +756,6 @@ package body Sem_SPARK is\n    --  a prefix, in the sense that they could still refer to overlapping memory\n    --  locations.\n \n-   function Is_Traversal_Function (E : Entity_Id) return Boolean;\n-\n    function Is_Traversal_Function_Call (Expr : Node_Id) return Boolean;\n \n    function Loop_Of_Exit (N : Node_Id) return Entity_Id;\n@@ -959,7 +954,7 @@ package body Sem_SPARK is\n                null;\n             else\n                Handle_Parameter_Or_Global (Expr       => Item,\n-                                           Formal_Typ => Etype (Item),\n+                                           Formal_Typ => Retysp (Etype (Item)),\n                                            Param_Mode => Kind,\n                                            Subp       => Subp,\n                                            Global_Var => True);\n@@ -1076,9 +1071,12 @@ package body Sem_SPARK is\n            and then (Is_Traversal_Function_Call (Expr)\n                       or else Get_Root_Object (Borrowed) /= Var)\n          then\n-            Error_Msg_NE\n-              (\"source of assignment must have & as root (SPARK RM 3.10(8)))\",\n-               Expr, Var);\n+            if Emit_Messages then\n+               Error_Msg_NE\n+                 (\"source of assignment must have & as root\" &\n+                    \" (SPARK RM 3.10(8)))\",\n+                  Expr, Var);\n+            end if;\n             return;\n          end if;\n \n@@ -1105,9 +1103,12 @@ package body Sem_SPARK is\n            and then (Is_Traversal_Function_Call (Expr)\n                       or else Get_Root_Object (Observed) /= Var)\n          then\n-            Error_Msg_NE\n-              (\"source of assignment must have & as root (SPARK RM 3.10(8)))\",\n-               Expr, Var);\n+            if Emit_Messages then\n+               Error_Msg_NE\n+                 (\"source of assignment must have & as root\" &\n+                    \" (SPARK RM 3.10(8)))\",\n+                  Expr, Var);\n+            end if;\n             return;\n          end if;\n \n@@ -1197,15 +1198,19 @@ package body Sem_SPARK is\n \n             if not Is_Decl then\n                if not Is_Entity_Name (Target) then\n-                  Error_Msg_N\n-                    (\"target of borrow must be stand-alone variable\",\n-                     Target);\n+                  if Emit_Messages then\n+                     Error_Msg_N\n+                       (\"target of borrow must be stand-alone variable\",\n+                        Target);\n+                  end if;\n                   return;\n \n                elsif Target_Root /= Expr_Root then\n-                  Error_Msg_NE\n-                    (\"source of borrow must be variable &\",\n-                     Expr, Target);\n+                  if Emit_Messages then\n+                     Error_Msg_NE\n+                       (\"source of borrow must be variable &\",\n+                        Expr, Target);\n+                  end if;\n                   return;\n                end if;\n             end if;\n@@ -1220,7 +1225,9 @@ package body Sem_SPARK is\n             Check_Expression (Expr, Move);\n \n          else\n-            Error_Msg_N (\"expression not allowed as source of move\", Expr);\n+            if Emit_Messages then\n+               Error_Msg_N (\"expression not allowed as source of move\", Expr);\n+            end if;\n             return;\n          end if;\n \n@@ -1253,7 +1260,7 @@ package body Sem_SPARK is\n       begin\n          Check_Parameter_Or_Global\n            (Expr       => Actual,\n-            Typ        => Underlying_Type (Etype (Formal)),\n+            Typ        => Retysp (Etype (Formal)),\n             Kind       => Ekind (Formal),\n             Subp       => Subp,\n             Global_Var => False);\n@@ -1287,7 +1294,15 @@ package body Sem_SPARK is\n    begin\n       Inside_Procedure_Call := True;\n       Check_Params (Call);\n-      Check_Globals (Get_Called_Entity (Call));\n+      if Ekind (Get_Called_Entity (Call)) = E_Subprogram_Type then\n+         if Emit_Messages then\n+            Error_Msg_N\n+              (\"call through access to subprogram is not allowed in SPARK\",\n+               Call);\n+         end if;\n+      else\n+         Check_Globals (Get_Called_Entity (Call));\n+      end if;\n \n       Inside_Procedure_Call := False;\n       Update_Params (Call);\n@@ -1322,8 +1337,10 @@ package body Sem_SPARK is\n         and then Is_Anonymous_Access_Type (Etype (Spec_Id))\n         and then not Is_Traversal_Function (Spec_Id)\n       then\n-         Error_Msg_N (\"anonymous access type for result only allowed for \"\n-                      & \"traveral functions\", Spec_Id);\n+         if Emit_Messages then\n+            Error_Msg_N (\"anonymous access type for result only allowed for \"\n+                         & \"traversal functions\", Spec_Id);\n+         end if;\n          return;\n       end if;\n \n@@ -1585,7 +1602,10 @@ package body Sem_SPARK is\n \n       begin\n          if not Is_Subpath_Expression (Expr) then\n-            Error_Msg_N (\"name expected here for move/borrow/observe\", Expr);\n+            if Emit_Messages then\n+               Error_Msg_N\n+                 (\"name expected here for move/borrow/observe\", Expr);\n+            end if;\n             return;\n          end if;\n \n@@ -1617,7 +1637,15 @@ package body Sem_SPARK is\n \n             when N_Function_Call =>\n                Read_Params (Expr);\n-               Check_Globals (Get_Called_Entity (Expr));\n+               if Ekind (Get_Called_Entity (Expr)) = E_Subprogram_Type then\n+                  if Emit_Messages then\n+                     Error_Msg_N\n+                       (\"call through access to subprogram is not allowed in \"\n+                        & \"SPARK\", Expr);\n+                  end if;\n+               else\n+                  Check_Globals (Get_Called_Entity (Expr));\n+               end if;\n \n             when N_Op_Concat =>\n                Read_Expression (Left_Opnd (Expr));\n@@ -1664,9 +1692,10 @@ package body Sem_SPARK is\n                      --  There can be only one element for a value of deep type\n                      --  in order to avoid aliasing.\n \n-                     if not (Box_Present (Assoc))\n+                     if not Box_Present (Assoc)\n                        and then Is_Deep (Etype (Expression (Assoc)))\n                        and then not Is_Singleton_Choice (CL)\n+                       and then Emit_Messages\n                      then\n                         Error_Msg_F\n                           (\"singleton choice required to prevent aliasing\",\n@@ -1725,11 +1754,16 @@ package body Sem_SPARK is\n                  (Get_Attribute_Id (Attribute_Name (Expr)) =\n                     Attribute_Loop_Entry\n                   or else\n-                  Get_Attribute_Id (Attribute_Name (Expr)) = Attribute_Update);\n+                  Get_Attribute_Id (Attribute_Name (Expr)) = Attribute_Update\n+                  or else\n+                  Get_Attribute_Id (Attribute_Name (Expr)) = Attribute_Image);\n \n                Read_Expression (Prefix (Expr));\n \n                if Get_Attribute_Id (Attribute_Name (Expr)) = Attribute_Update\n+                 or else (Get_Attribute_Id (Attribute_Name (Expr)) =\n+                            Attribute_Image\n+                          and then Is_Type_Name (Prefix (Expr)))\n                then\n                   Read_Expression_List (Expressions (Expr));\n                end if;\n@@ -1761,7 +1795,9 @@ package body Sem_SPARK is\n       --  Read mode.\n \n       if Mode /= Read then\n-         Error_Msg_N (\"name expected here for move/borrow/observe\", Expr);\n+         if Emit_Messages then\n+            Error_Msg_N (\"name expected here for move/borrow/observe\", Expr);\n+         end if;\n          return;\n       end if;\n \n@@ -1804,6 +1840,13 @@ package body Sem_SPARK is\n             end if;\n             return;\n \n+         when N_Delta_Constraint =>\n+            Read_Expression (Delta_Expression (Expr));\n+            if Present (Range_Constraint (Expr)) then\n+               Read_Expression (Range_Constraint (Expr));\n+            end if;\n+            return;\n+\n          when others =>\n             null;\n       end case;\n@@ -1934,8 +1977,7 @@ package body Sem_SPARK is\n                      raise Program_Error;\n \n                   when others =>\n-                     Error_Msg_Name_1 := Aname;\n-                     Error_Msg_N (\"attribute % not allowed in SPARK\", Expr);\n+                     null;\n                end case;\n             end;\n \n@@ -1999,7 +2041,7 @@ package body Sem_SPARK is\n          when N_Delta_Aggregate\n             | N_Target_Name\n          =>\n-            Error_Msg_N (\"unsupported construct in SPARK\", Expr);\n+            null;\n \n          --  Procedure calls are handled in Check_Node\n \n@@ -2330,16 +2372,16 @@ package body Sem_SPARK is\n                         KeyO := Perm_Tree_Maps.Get_First_Key\n                           (Component (Orig_Tree));\n                         while KeyO.Present loop\n+                           CompN := Perm_Tree_Maps.Get\n+                             (Component (New_Tree), KeyO.K);\n+                           CompO := Perm_Tree_Maps.Get\n+                             (Component (Orig_Tree), KeyO.K);\n                            pragma Assert (CompO /= null);\n \n                            Check_Is_Less_Restrictive_Tree (CompN, CompO, E);\n \n                            KeyO := Perm_Tree_Maps.Get_Next_Key\n                              (Component (Orig_Tree));\n-                           CompN := Perm_Tree_Maps.Get\n-                             (Component (New_Tree), KeyO.K);\n-                           CompO := Perm_Tree_Maps.Get\n-                             (Component (Orig_Tree), KeyO.K);\n                         end loop;\n                      end;\n \n@@ -2362,12 +2404,15 @@ package body Sem_SPARK is\n          Expl       : Node_Id)\n       is\n       begin\n-         Error_Msg_Node_2 := Loop_Id;\n-         Error_Msg_N (\"insufficient permission for & when exiting loop &\", E);\n-         Perm_Mismatch (Exp_Perm => Perm,\n-                        Act_Perm => Found_Perm,\n-                        N        => Loop_Id,\n-                        Expl     => Expl);\n+         if Emit_Messages then\n+            Error_Msg_Node_2 := Loop_Id;\n+            Error_Msg_N\n+              (\"insufficient permission for & when exiting loop &\", E);\n+            Perm_Mismatch (Exp_Perm => Perm,\n+                           Act_Perm => Found_Perm,\n+                           N        => Loop_Id,\n+                           Expl     => Expl);\n+         end if;\n       end Perm_Error_Loop_Exit;\n \n       --  Local variables\n@@ -2543,6 +2588,7 @@ package body Sem_SPARK is\n             | N_Package_Instantiation\n             | N_Package_Renaming_Declaration\n             | N_Procedure_Instantiation\n+            | N_Raise_xxx_Error\n             | N_Record_Representation_Clause\n             | N_Subprogram_Declaration\n             | N_Subprogram_Renaming_Declaration\n@@ -2745,7 +2791,7 @@ package body Sem_SPARK is\n       Prag_Id : constant Pragma_Id := Get_Pragma_Id (Prag);\n       Arg1    : constant Node_Id :=\n         First (Pragma_Argument_Associations (Prag));\n-      Arg2    : Node_Id;\n+      Arg2    : Node_Id := Empty;\n \n    begin\n       if Present (Arg1) then\n@@ -2903,17 +2949,20 @@ package body Sem_SPARK is\n       --  function.\n \n       if No (Root) then\n-         if Nkind (Expr) = N_Function_Call then\n-            Error_Msg_N\n-              (\"incorrect borrow or observe (SPARK RM 3.10(3))\", Expr);\n-            Error_Msg_N\n-              (\"\\function called must be a traversal function\", Expr);\n-         else\n-            Error_Msg_N\n-              (\"incorrect borrow or observe (SPARK RM 3.10(3))\", Expr);\n-            Error_Msg_N\n-              (\"\\expression must be part of stand-alone object or parameter\",\n-               Expr);\n+         if Emit_Messages then\n+            if Nkind (Expr) = N_Function_Call then\n+               Error_Msg_N\n+                 (\"incorrect borrow or observe (SPARK RM 3.10(3))\", Expr);\n+               Error_Msg_N\n+                 (\"\\function called must be a traversal function\", Expr);\n+            else\n+               Error_Msg_N\n+                 (\"incorrect borrow or observe (SPARK RM 3.10(3))\", Expr);\n+               Error_Msg_N\n+                 (\"\\expression must be part of stand-alone object or \" &\n+                    \"parameter\",\n+                  Expr);\n+            end if;\n          end if;\n \n          Status := Error;\n@@ -2958,7 +3007,9 @@ package body Sem_SPARK is\n                if No (Get_Root_Object\n                        (Target, Through_Traversal => False))\n                then\n-                  Error_Msg_N (\"illegal target for assignment\", Target);\n+                  if Emit_Messages then\n+                     Error_Msg_N (\"illegal target for assignment\", Target);\n+                  end if;\n                   return;\n                end if;\n \n@@ -3064,7 +3115,7 @@ package body Sem_SPARK is\n                      if Is_Anonymous_Access_Type (Return_Typ) then\n                         pragma Assert (Is_Traversal_Function (Subp));\n \n-                        if Nkind (Expr) /= N_Null then\n+                        if Nkind (Expr) /= N_Null and then Emit_Messages then\n                            declare\n                               Expr_Root : constant Entity_Id :=\n                                 Get_Root_Object (Expr);\n@@ -3089,9 +3140,11 @@ package body Sem_SPARK is\n                            Check_Expression (Expr, Move);\n \n                         else\n-                           Error_Msg_N\n-                             (\"expression not allowed as source of move\",\n-                              Expr);\n+                           if Emit_Messages then\n+                              Error_Msg_N\n+                                (\"expression not allowed as source of move\",\n+                                 Expr);\n+                           end if;\n                            return;\n                         end if;\n \n@@ -3114,14 +3167,14 @@ package body Sem_SPARK is\n                Subp  : constant Entity_Id :=\n                  Return_Applies_To (Return_Statement_Entity (Stmt));\n                Decls : constant List_Id := Return_Object_Declarations (Stmt);\n-               Decl  : constant Node_Id := Last (Decls);\n+               Decl  : constant Node_Id := Last_Non_Pragma (Decls);\n                Obj   : constant Entity_Id := Defining_Identifier (Decl);\n                Perm  : Perm_Kind;\n \n             begin\n                --  SPARK RM 3.10(5): return statement of traversal function\n \n-               if Is_Traversal_Function (Subp) then\n+               if Is_Traversal_Function (Subp) and then Emit_Messages then\n                   Error_Msg_N\n                     (\"extended return cannot apply to a traversal function\",\n                      Stmt);\n@@ -3254,7 +3307,7 @@ package body Sem_SPARK is\n             | N_Selective_Accept\n             | N_Timed_Entry_Call\n          =>\n-            Error_Msg_N (\"unsupported construct in SPARK\", Stmt);\n+            null;\n \n          --  The following nodes are never generated in GNATprove mode\n \n@@ -3270,31 +3323,39 @@ package body Sem_SPARK is\n    ----------------\n \n    procedure Check_Type (Typ : Entity_Id) is\n-      Check_Typ : constant Entity_Id := Underlying_Type (Typ);\n+      Check_Typ : constant Entity_Id := Retysp (Typ);\n \n    begin\n       case Type_Kind'(Ekind (Check_Typ)) is\n          when Access_Kind =>\n-            case Access_Kind'(Ekind (Underlying_Type (Check_Typ))) is\n+            case Access_Kind'(Ekind (Check_Typ)) is\n                when E_Access_Type\n                   | E_Anonymous_Access_Type\n                =>\n                   null;\n                when E_Access_Subtype =>\n                   Check_Type (Base_Type (Check_Typ));\n                when E_Access_Attribute_Type =>\n-                  Error_Msg_N (\"access attribute not allowed in SPARK\",\n-                               Check_Typ);\n+                  if Emit_Messages then\n+                     Error_Msg_N (\"access attribute not allowed in SPARK\",\n+                                  Check_Typ);\n+                  end if;\n                when E_Allocator_Type =>\n-                  Error_Msg_N (\"missing type resolution\", Check_Typ);\n+                  if Emit_Messages then\n+                     Error_Msg_N (\"missing type resolution\", Check_Typ);\n+                  end if;\n                when E_General_Access_Type =>\n-                  Error_Msg_NE\n-                    (\"general access type & not allowed in SPARK\",\n-                     Check_Typ, Check_Typ);\n+                  if Emit_Messages then\n+                     Error_Msg_NE\n+                       (\"general access type & not allowed in SPARK\",\n+                        Check_Typ, Check_Typ);\n+                  end if;\n                when Access_Subprogram_Kind =>\n-                  Error_Msg_NE\n-                    (\"access to subprogram type & not allowed in SPARK\",\n-                     Check_Typ, Check_Typ);\n+                  if Emit_Messages then\n+                     Error_Msg_NE\n+                       (\"access to subprogram type & not allowed in SPARK\",\n+                        Check_Typ, Check_Typ);\n+                  end if;\n             end case;\n \n          when E_Array_Type\n@@ -3307,17 +3368,24 @@ package body Sem_SPARK is\n               and then (Is_Tagged_Type (Check_Typ)\n                         or else Is_Class_Wide_Type (Check_Typ))\n             then\n-               Error_Msg_NE\n-                 (\"tagged type & cannot be owning in SPARK\",\n-                  Check_Typ, Check_Typ);\n+               if Emit_Messages then\n+                  Error_Msg_NE\n+                    (\"tagged type & cannot be owning in SPARK\",\n+                     Check_Typ, Check_Typ);\n+               end if;\n \n             else\n                declare\n                   Comp : Entity_Id;\n                begin\n                   Comp := First_Component_Or_Discriminant (Check_Typ);\n                   while Present (Comp) loop\n-                     Check_Type (Etype (Comp));\n+\n+                     --  Ignore components which are not visible in SPARK\n+\n+                     if Component_Is_Visible_In_SPARK (Comp) then\n+                        Check_Type (Etype (Comp));\n+                     end if;\n                      Next_Component_Or_Discriminant (Comp);\n                   end loop;\n                end;\n@@ -3333,14 +3401,14 @@ package body Sem_SPARK is\n          =>\n             null;\n \n-         --  The following should not arise as underlying types\n+         --  Do not check type whose full view is not SPARK\n \n          when E_Private_Type\n             | E_Private_Subtype\n             | E_Limited_Private_Type\n             | E_Limited_Private_Subtype\n          =>\n-            raise Program_Error;\n+            null;\n       end case;\n    end Check_Type;\n \n@@ -3526,7 +3594,8 @@ package body Sem_SPARK is\n                            pragma Assert (Nkind (N) = N_Selected_Component);\n                            declare\n                               Comp : constant Entity_Id :=\n-                                Entity (Selector_Name (N));\n+                                Original_Record_Component\n+                                  (Entity (Selector_Name (N)));\n                               D : constant Perm_Tree_Access :=\n                                 Perm_Tree_Maps.Get\n                                   (Component (C.Tree_Access), Comp);\n@@ -3577,7 +3646,9 @@ package body Sem_SPARK is\n    is\n    begin\n       if not Is_Subpath_Expression (Expr) then\n-         Error_Msg_N (\"name expected here for path\", Expr);\n+         if Emit_Messages then\n+            Error_Msg_N (\"name expected here for path\", Expr);\n+         end if;\n          return Empty;\n       end if;\n \n@@ -3630,7 +3701,9 @@ package body Sem_SPARK is\n                  Attribute_Loop_Entry\n                or else\n                Get_Attribute_Id (Attribute_Name (Expr)) =\n-                 Attribute_Update);\n+                 Attribute_Update\n+               or else Get_Attribute_Id (Attribute_Name (Expr)) =\n+                 Attribute_Image);\n             return Empty;\n \n          when others =>\n@@ -3750,22 +3823,27 @@ package body Sem_SPARK is\n \n    function Is_Deep (Typ : Entity_Id) return Boolean is\n    begin\n-      case Type_Kind'(Ekind (Underlying_Type (Typ))) is\n+      case Type_Kind'(Ekind (Retysp (Typ))) is\n          when Access_Kind =>\n             return True;\n \n          when E_Array_Type\n             | E_Array_Subtype\n          =>\n-            return Is_Deep (Component_Type (Underlying_Type (Typ)));\n+            return Is_Deep (Component_Type (Retysp (Typ)));\n \n          when Record_Kind =>\n             declare\n                Comp : Entity_Id;\n             begin\n-               Comp := First_Component_Or_Discriminant (Typ);\n+               Comp := First_Component_Or_Discriminant (Retysp (Typ));\n                while Present (Comp) loop\n-                  if Is_Deep (Etype (Comp)) then\n+\n+                  --  Ignore components not visible in SPARK\n+\n+                  if Component_Is_Visible_In_SPARK (Comp)\n+                    and then Is_Deep (Etype (Comp))\n+                  then\n                      return True;\n                   end if;\n                   Next_Component_Or_Discriminant (Comp);\n@@ -3783,14 +3861,14 @@ package body Sem_SPARK is\n          =>\n             return False;\n \n-         --  The following should not arise as underlying types\n+         --  Ignore full view of types if it is not in SPARK\n \n          when E_Private_Type\n             | E_Private_Subtype\n             | E_Limited_Private_Type\n             | E_Limited_Private_Subtype\n          =>\n-            raise Program_Error;\n+            return False;\n       end case;\n    end Is_Deep;\n \n@@ -3910,8 +3988,10 @@ package body Sem_SPARK is\n \n                when N_Selected_Component =>\n                   if Nkind (Expr_Elt) /= N_Selected_Component\n-                    or else Entity (Selector_Name (Prefix_Elt))\n-                         /= Entity (Selector_Name (Expr_Elt))\n+                    or else Original_Record_Component\n+                              (Entity (Selector_Name (Prefix_Elt)))\n+                         /= Original_Record_Component\n+                              (Entity (Selector_Name (Expr_Elt)))\n                   then\n                      return False;\n                   end if;\n@@ -3962,7 +4042,10 @@ package body Sem_SPARK is\n                        Attribute_Update\n                      or else\n                      Get_Attribute_Id (Attribute_Name (Expr)) =\n-                       Attribute_Loop_Entry))\n+                       Attribute_Loop_Entry\n+                     or else\n+                     Get_Attribute_Id (Attribute_Name (Expr)) =\n+                       Attribute_Image))\n        or else Nkind (Expr) = N_Op_Concat;\n    end Is_Subpath_Expression;\n \n@@ -3985,7 +4068,7 @@ package body Sem_SPARK is\n \n         --  and the function's first parameter is of an access type.\n \n-        and then Is_Access_Type (Etype (First_Formal (E)));\n+        and then Is_Access_Type (Retysp (Etype (First_Formal (E))));\n    end Is_Traversal_Function;\n \n    --------------------------------\n@@ -4363,14 +4446,16 @@ package body Sem_SPARK is\n    begin\n       Set_Root_Object (N, Root, Is_Deref);\n \n-      if Is_Deref then\n-         Error_Msg_NE\n-           (\"insufficient permission on dereference from &\", N, Root);\n-      else\n-         Error_Msg_NE (\"insufficient permission for &\", N, Root);\n-      end if;\n+      if Emit_Messages then\n+         if Is_Deref then\n+            Error_Msg_NE\n+              (\"insufficient permission on dereference from &\", N, Root);\n+         else\n+            Error_Msg_NE (\"insufficient permission for &\", N, Root);\n+         end if;\n \n-      Perm_Mismatch (N, Perm, Found_Perm, Expl, Forbidden_Perm);\n+         Perm_Mismatch (N, Perm, Found_Perm, Expl, Forbidden_Perm);\n+      end if;\n    end Perm_Error;\n \n    -------------------------------\n@@ -4385,10 +4470,12 @@ package body Sem_SPARK is\n       Expl       : Node_Id)\n    is\n    begin\n-      Error_Msg_Node_2 := Subp;\n-      Error_Msg_NE (\"insufficient permission for & when returning from &\",\n-                    Subp, E);\n-      Perm_Mismatch (Subp, Perm, Found_Perm, Expl);\n+      if Emit_Messages then\n+         Error_Msg_Node_2 := Subp;\n+         Error_Msg_NE (\"insufficient permission for & when returning from &\",\n+                       Subp, E);\n+         Perm_Mismatch (Subp, Perm, Found_Perm, Expl);\n+      end if;\n    end Perm_Error_Subprogram_End;\n \n    ------------------\n@@ -4429,7 +4516,9 @@ package body Sem_SPARK is\n                Var := Key.K;\n                Borrowed := Get (Current_Borrowers, Var);\n \n-               if Is_Prefix_Or_Almost (Pref => Borrowed, Expr => Expr) then\n+               if Is_Prefix_Or_Almost (Pref => Borrowed, Expr => Expr)\n+                 and then Emit_Messages\n+               then\n                   Error_Msg_Sloc := Sloc (Borrowed);\n                   Error_Msg_N (\"object was borrowed #\", Expr);\n                end if;\n@@ -4465,7 +4554,9 @@ package body Sem_SPARK is\n                Var := Key.K;\n                Observed := Get (Current_Observers, Var);\n \n-               if Is_Prefix_Or_Almost (Pref => Observed, Expr => Expr) then\n+               if Is_Prefix_Or_Almost (Pref => Observed, Expr => Expr)\n+                 and then Emit_Messages\n+               then\n                   Error_Msg_Sloc := Sloc (Observed);\n                   Error_Msg_N (\"object was observed #\", Expr);\n                end if;\n@@ -4543,6 +4634,7 @@ package body Sem_SPARK is\n                if Is_Deep (Expr_Type)\n                  and then not Inside_Procedure_Call\n                  and then Present (Get_Root_Object (Expr))\n+                 and then Emit_Messages\n                then\n                   Error_Msg_N (\"illegal move during elaboration\", Expr);\n                end if;\n@@ -4587,7 +4679,7 @@ package body Sem_SPARK is\n             --  Forbidden during elaboration\n \n             if Inside_Elaboration then\n-               if not Inside_Procedure_Call then\n+               if not Inside_Procedure_Call and then Emit_Messages then\n                   Error_Msg_N (\"illegal borrow during elaboration\", Expr);\n                end if;\n \n@@ -4606,7 +4698,7 @@ package body Sem_SPARK is\n             --  Forbidden during elaboration\n \n             if Inside_Elaboration then\n-               if not Inside_Procedure_Call then\n+               if not Inside_Procedure_Call and then Emit_Messages then\n                   Error_Msg_N (\"illegal observe during elaboration\", Expr);\n                end if;\n \n@@ -4803,7 +4895,7 @@ package body Sem_SPARK is\n       while Present (Formal) loop\n          Return_Parameter_Or_Global\n            (Id         => Formal,\n-            Typ        => Underlying_Type (Etype (Formal)),\n+            Typ        => Retysp (Etype (Formal)),\n             Kind       => Ekind (Formal),\n             Subp       => Subp,\n             Global_Var => False);\n@@ -4876,6 +4968,7 @@ package body Sem_SPARK is\n       E    : Entity_Id;\n       Expl : Node_Id)\n    is\n+      Check_Ty : constant Entity_Id := Retysp (E);\n    begin\n       --  Shallow extensions are set to RW\n \n@@ -4894,7 +4987,7 @@ package body Sem_SPARK is\n          --  precision.\n \n          when Entire_Object =>\n-            case Ekind (E) is\n+            case Ekind (Check_Ty) is\n                when E_Array_Type\n                   | E_Array_Subtype\n                =>\n@@ -4908,7 +5001,8 @@ package body Sem_SPARK is\n                              Permission          => Read_Write,\n                              Children_Permission => Read_Write));\n                   begin\n-                     Set_Perm_Extensions_Move (C, Component_Type (E), Expl);\n+                     Set_Perm_Extensions_Move\n+                       (C, Component_Type (Check_Ty), Expl);\n                      T.all.Tree := (Kind         => Array_Component,\n                                     Is_Node_Deep => Is_Node_Deep (T),\n                                     Explanation  => Expl,\n@@ -4923,17 +5017,36 @@ package body Sem_SPARK is\n                      Hashtbl : Perm_Tree_Maps.Instance;\n \n                   begin\n-                     Comp := First_Component_Or_Discriminant (E);\n+                     Comp := First_Component_Or_Discriminant (Check_Ty);\n                      while Present (Comp) loop\n-                        C := new Perm_Tree_Wrapper'\n-                          (Tree =>\n-                             (Kind                => Entire_Object,\n-                              Is_Node_Deep        => Is_Deep (Etype (Comp)),\n-                              Explanation         => Expl,\n-                              Permission          => Read_Write,\n-                              Children_Permission => Read_Write));\n-                        Set_Perm_Extensions_Move (C, Etype (Comp), Expl);\n-                        Perm_Tree_Maps.Set (Hashtbl, Comp, C);\n+\n+                        --  Unfold components which are visible in SPARK\n+\n+                        if Component_Is_Visible_In_SPARK (Comp) then\n+                           C := new Perm_Tree_Wrapper'\n+                             (Tree =>\n+                                (Kind                => Entire_Object,\n+                                 Is_Node_Deep        => Is_Deep (Etype (Comp)),\n+                                 Explanation         => Expl,\n+                                 Permission          => Read_Write,\n+                                 Children_Permission => Read_Write));\n+                           Set_Perm_Extensions_Move (C, Etype (Comp), Expl);\n+\n+                        --  Hidden components are never deep\n+\n+                        else\n+                           C := new Perm_Tree_Wrapper'\n+                             (Tree =>\n+                                (Kind                => Entire_Object,\n+                                 Is_Node_Deep        => False,\n+                                 Explanation         => Expl,\n+                                 Permission          => Read_Write,\n+                                 Children_Permission => Read_Write));\n+                           Set_Perm_Extensions (C, Read_Write, Expl => Expl);\n+                        end if;\n+\n+                        Perm_Tree_Maps.Set\n+                          (Hashtbl, Original_Record_Component (Comp), C);\n                         Next_Component_Or_Discriminant (Comp);\n                      end loop;\n \n@@ -4955,19 +5068,32 @@ package body Sem_SPARK is\n             Set_Perm_Extensions (T, No_Access, Expl);\n \n          when Array_Component =>\n-            Set_Perm_Extensions_Move (Get_Elem (T), Component_Type (E), Expl);\n+            Set_Perm_Extensions_Move\n+              (Get_Elem (T), Component_Type (Check_Ty), Expl);\n \n          when Record_Component =>\n             declare\n                C    : Perm_Tree_Access;\n                Comp : Entity_Id;\n \n             begin\n-               Comp := First_Component_Or_Discriminant (E);\n+               Comp := First_Component_Or_Discriminant (Check_Ty);\n                while Present (Comp) loop\n-                  C := Perm_Tree_Maps.Get (Component (T), Comp);\n+                  C := Perm_Tree_Maps.Get\n+                    (Component (T), Original_Record_Component (Comp));\n                   pragma Assert (C /= null);\n-                  Set_Perm_Extensions_Move (C, Etype (Comp), Expl);\n+\n+                  --  Move visible components\n+\n+                  if Component_Is_Visible_In_SPARK (Comp) then\n+                     Set_Perm_Extensions_Move (C, Etype (Comp), Expl);\n+\n+                  --  Hidden components are never deep\n+\n+                  else\n+                     Set_Perm_Extensions (C, Read_Write, Expl => Expl);\n+                  end if;\n+\n                   Next_Component_Or_Discriminant (Comp);\n                end loop;\n             end;\n@@ -5073,7 +5199,9 @@ package body Sem_SPARK is\n \n                if Kind (C) = Record_Component then\n                   declare\n-                     Comp : constant Entity_Id := Entity (Selector_Name (N));\n+                     Comp : constant Entity_Id :=\n+                       Original_Record_Component\n+                         (Entity (Selector_Name (N)));\n                      D : constant Perm_Tree_Access :=\n                        Perm_Tree_Maps.Get (Component (C), Comp);\n                      pragma Assert (D /= null);\n@@ -5102,11 +5230,14 @@ package body Sem_SPARK is\n \n                   begin\n                      Comp :=\n-                       First_Component_Or_Discriminant (Etype (Prefix (N)));\n+                       First_Component_Or_Discriminant\n+                         (Retysp (Etype (Prefix (N))));\n \n                      while Present (Comp) loop\n                         if Perm /= None\n-                          and then Comp = Entity (Selector_Name (N))\n+                          and then Original_Record_Component (Comp) =\n+                          Original_Record_Component\n+                            (Entity (Selector_Name (N)))\n                         then\n                            P := Perm;\n                         else\n@@ -5116,15 +5247,22 @@ package body Sem_SPARK is\n                         D := new Perm_Tree_Wrapper'\n                           (Tree =>\n                              (Kind                => Entire_Object,\n-                              Is_Node_Deep        => Is_Deep (Etype (Comp)),\n+                              Is_Node_Deep        =>\n+                                --  Hidden components are never deep\n+                                Component_Is_Visible_In_SPARK (Comp)\n+                                  and then Is_Deep (Etype (Comp)),\n                               Explanation         => Expl,\n                               Permission          => P,\n                               Children_Permission => Child_P));\n-                        Perm_Tree_Maps.Set (Hashtbl, Comp, D);\n+                        Perm_Tree_Maps.Set\n+                          (Hashtbl, Original_Record_Component (Comp), D);\n \n                         --  Store the tree to return for this component\n \n-                        if Comp = Entity (Selector_Name (N)) then\n+                        if Original_Record_Component (Comp) =\n+                          Original_Record_Component\n+                            (Entity (Selector_Name (N)))\n+                        then\n                            D_This := D;\n                         end if;\n \n@@ -5380,14 +5518,6 @@ package body Sem_SPARK is\n             --  Functions cannot have outputs in SPARK\n \n             elsif Ekind (Subp) = E_Function then\n-               if Kind = E_Out_Parameter then\n-                  Error_Msg_N (\"function with OUT parameter is not \"\n-                               & \"allowed in SPARK\", Id);\n-               else\n-                  Error_Msg_N (\"function with `IN OUT` parameter is not \"\n-                               & \"allowed in SPARK\", Id);\n-               end if;\n-\n                return;\n \n             --  Deep types define a borrow or a move\n@@ -5424,7 +5554,7 @@ package body Sem_SPARK is\n       while Present (Formal) loop\n          Setup_Parameter_Or_Global\n            (Id         => Formal,\n-            Typ        => Underlying_Type (Etype (Formal)),\n+            Typ        => Retysp (Etype (Formal)),\n             Kind       => Ekind (Formal),\n             Subp       => Subp,\n             Global_Var => False,\n@@ -5457,11 +5587,12 @@ package body Sem_SPARK is\n       while Present (Comp) loop\n          Setup_Parameter_Or_Global\n            (Id         => Comp,\n-            Typ        => Underlying_Type (Etype (Comp)),\n+            Typ        => Retysp (Etype (Comp)),\n             Kind       => Kind,\n             Subp       => Subp,\n             Global_Var => False,\n             Expl       => Comp);\n+\n          Next_Component_Or_Discriminant (Comp);\n       end loop;\n    end Setup_Protected_Components;"}, {"sha": "0e8b29b41f7bf2176a9d98549fa00fe0f7d2607b", "filename": "gcc/ada/sem_spark.ads", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a8fa1b3d08ea4cc31f858d2add1b22e62b8db5e1/gcc%2Fada%2Fsem_spark.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a8fa1b3d08ea4cc31f858d2add1b22e62b8db5e1/gcc%2Fada%2Fsem_spark.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_spark.ads?ref=a8fa1b3d08ea4cc31f858d2add1b22e62b8db5e1", "patch": "@@ -132,12 +132,34 @@\n --  get read-write permission, which can be specified using the node's\n --  Children_Permission field.\n \n+--  The implementation is done as a generic, so that GNATprove can instantiate\n+--  it with suitable formal arguments that depend on the SPARK_Mode boundary\n+--  as well as the two-phase architecture of GNATprove (which runs the GNAT\n+--  front end twice, once for global generation and once for analysis).\n+\n with Types; use Types;\n \n+generic\n+   with function Retysp (X : Entity_Id) return Entity_Id;\n+   --  Return the representative type in SPARK for a type.\n+\n+   with function Component_Is_Visible_In_SPARK (C : Entity_Id) return Boolean;\n+   --  Return whether a component is visible in SPARK. No aliasing check is\n+   --  performed for a component that is visible.\n+\n+   with function Emit_Messages return Boolean;\n+   --  Return True when error messages should be emitted.\n+\n package Sem_SPARK is\n \n    procedure Check_Safe_Pointers (N : Node_Id);\n    --  The entry point of this package. It analyzes a node and reports errors\n    --  when there are violations of ownership rules.\n \n+   function Is_Deep (Typ : Entity_Id) return Boolean;\n+   --  A function that can tell whether a type is deep. Returns True if the\n+   --  type passed as argument is deep.\n+\n+   function Is_Traversal_Function (E : Entity_Id) return Boolean;\n+\n end Sem_SPARK;"}]}