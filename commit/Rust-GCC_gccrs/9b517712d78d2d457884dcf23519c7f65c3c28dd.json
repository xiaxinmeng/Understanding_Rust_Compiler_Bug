{"sha": "9b517712d78d2d457884dcf23519c7f65c3c28dd", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OWI1MTc3MTJkNzhkMmQ0NTc4ODRkY2YyMzUxOWM3ZjY1YzNjMjhkZA==", "commit": {"author": {"name": "David Malcolm", "email": "dmalcolm@redhat.com", "date": "2014-08-22T16:58:09Z"}, "committer": {"name": "David Malcolm", "email": "dmalcolm@gcc.gnu.org", "date": "2014-08-22T16:58:09Z"}, "message": "haifa-sched.c: Use rtx_insn\n\ngcc/\n\t* haifa-sched.c (bb_header): Strengthen from rtx * to rtx_insn **.\n\t(add_delay_dependencies): Strengthen local \"pro\" from rtx to\n\trtx_insn *.\n\t(recompute_todo_spec): Likewise.\n\t(dep_cost_1): Likewise for locals \"insn\", \"used\".\n\t(schedule_insn): Likewise for local \"dbg\".\n\t(schedule_insn): Likewise for locals \"pro\", \"next\".\n\t(unschedule_insns_until): Likewise for local \"con\".\n\t(restore_pattern): Likewise for local \"next\".\n\t(estimate_insn_tick): Likewise for local \"pro\".\n\t(resolve_dependencies): Likewise for local \"next\".\n\t(fix_inter_tick): Likewise.\n\t(fix_tick_ready): Likewise for local \"pro\".\n\t(add_to_speculative_block): Likewise for locals \"check\", \"twin\",\n\t\"pro\".\n\t(sched_extend_bb): Likewise for locals \"end\", \"insn\".\n\t(init_before_recovery): Likewise for local \"x\".\n\t(sched_create_recovery_block): Likewise for local \"barrier\".\n\t(create_check_block_twin): Likewise for local \"pro\".\n\t(fix_recovery_deps): Likewise for locals \"note\", \"insn\", \"jump\",\n\t\"consumer\".\n\t(unlink_bb_notes): Update for change to type of bb_header.\n\tStrengthen locals \"prev\", \"label\", \"note\", \"next\" from rtx to\n\trtx_insn *.\n\t(clear_priorities): Likewise for local \"pro\".\n\nFrom-SVN: r214332", "tree": {"sha": "3d88a2f7892e4231ad68ca15be2de11fa8659eb3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/3d88a2f7892e4231ad68ca15be2de11fa8659eb3"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/9b517712d78d2d457884dcf23519c7f65c3c28dd", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9b517712d78d2d457884dcf23519c7f65c3c28dd", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9b517712d78d2d457884dcf23519c7f65c3c28dd", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9b517712d78d2d457884dcf23519c7f65c3c28dd/comments", "author": {"login": "davidmalcolm", "id": 1553248, "node_id": "MDQ6VXNlcjE1NTMyNDg=", "avatar_url": "https://avatars.githubusercontent.com/u/1553248?v=4", "gravatar_id": "", "url": "https://api.github.com/users/davidmalcolm", "html_url": "https://github.com/davidmalcolm", "followers_url": "https://api.github.com/users/davidmalcolm/followers", "following_url": "https://api.github.com/users/davidmalcolm/following{/other_user}", "gists_url": "https://api.github.com/users/davidmalcolm/gists{/gist_id}", "starred_url": "https://api.github.com/users/davidmalcolm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/davidmalcolm/subscriptions", "organizations_url": "https://api.github.com/users/davidmalcolm/orgs", "repos_url": "https://api.github.com/users/davidmalcolm/repos", "events_url": "https://api.github.com/users/davidmalcolm/events{/privacy}", "received_events_url": "https://api.github.com/users/davidmalcolm/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "cf92a178334a034950ff9faac1a336a02374988b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cf92a178334a034950ff9faac1a336a02374988b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cf92a178334a034950ff9faac1a336a02374988b"}], "stats": {"total": 88, "additions": 59, "deletions": 29}, "files": [{"sha": "66642ffc28145cb174d6b1c753ac838d9cfa4cac", "filename": "gcc/ChangeLog", "status": "modified", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9b517712d78d2d457884dcf23519c7f65c3c28dd/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9b517712d78d2d457884dcf23519c7f65c3c28dd/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=9b517712d78d2d457884dcf23519c7f65c3c28dd", "patch": "@@ -1,3 +1,31 @@\n+2014-08-22  David Malcolm  <dmalcolm@redhat.com>\n+\n+\t* haifa-sched.c (bb_header): Strengthen from rtx * to rtx_insn **.\n+\t(add_delay_dependencies): Strengthen local \"pro\" from rtx to\n+\trtx_insn *.\n+\t(recompute_todo_spec): Likewise.\n+\t(dep_cost_1): Likewise for locals \"insn\", \"used\".\n+\t(schedule_insn): Likewise for local \"dbg\".\n+\t(schedule_insn): Likewise for locals \"pro\", \"next\".\n+\t(unschedule_insns_until): Likewise for local \"con\".\n+\t(restore_pattern): Likewise for local \"next\".\n+\t(estimate_insn_tick): Likewise for local \"pro\".\n+\t(resolve_dependencies): Likewise for local \"next\".\n+\t(fix_inter_tick): Likewise.\n+\t(fix_tick_ready): Likewise for local \"pro\".\n+\t(add_to_speculative_block): Likewise for locals \"check\", \"twin\",\n+\t\"pro\".\n+\t(sched_extend_bb): Likewise for locals \"end\", \"insn\".\n+\t(init_before_recovery): Likewise for local \"x\".\n+\t(sched_create_recovery_block): Likewise for local \"barrier\".\n+\t(create_check_block_twin): Likewise for local \"pro\".\n+\t(fix_recovery_deps): Likewise for locals \"note\", \"insn\", \"jump\",\n+\t\"consumer\".\n+\t(unlink_bb_notes): Update for change to type of bb_header.\n+\tStrengthen locals \"prev\", \"label\", \"note\", \"next\" from rtx to\n+\trtx_insn *.\n+\t(clear_priorities): Likewise for local \"pro\".\n+\n 2014-08-22  David Malcolm  <dmalcolm@redhat.com>\n \n \t* gcse.c (struct occr): Strengthen field \"insn\" from rtx to"}, {"sha": "34aa207d8dfd430e7b6c8f9cf2cf55dc7f7f7450", "filename": "gcc/haifa-sched.c", "status": "modified", "additions": 31, "deletions": 29, "changes": 60, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9b517712d78d2d457884dcf23519c7f65c3c28dd/gcc%2Fhaifa-sched.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9b517712d78d2d457884dcf23519c7f65c3c28dd/gcc%2Fhaifa-sched.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fhaifa-sched.c?ref=9b517712d78d2d457884dcf23519c7f65c3c28dd", "patch": "@@ -261,7 +261,7 @@ bool haifa_recovery_bb_ever_added_p;\n static int nr_begin_data, nr_be_in_data, nr_begin_control, nr_be_in_control;\n \n /* Array used in {unlink, restore}_bb_notes.  */\n-static rtx *bb_header = 0;\n+static rtx_insn **bb_header = 0;\n \n /* Basic block after which recovery blocks will be created.  */\n static basic_block before_recovery;\n@@ -798,7 +798,7 @@ add_delay_dependencies (rtx insn)\n \n   FOR_EACH_DEP (pair->i2, SD_LIST_BACK, sd_it, dep)\n     {\n-      rtx pro = DEP_PRO (dep);\n+      rtx_insn *pro = DEP_PRO (dep);\n       struct delay_pair *other_pair\n \t= delay_htab_i2->find_with_hash (pro, htab_hash_pointer (pro));\n       if (!other_pair || other_pair->stages)\n@@ -1208,7 +1208,7 @@ recompute_todo_spec (rtx next, bool for_backtrack)\n \n   FOR_EACH_DEP (next, SD_LIST_BACK, sd_it, dep)\n     {\n-      rtx pro = DEP_PRO (dep);\n+      rtx_insn *pro = DEP_PRO (dep);\n       ds_t ds = DEP_STATUS (dep) & SPECULATIVE;\n \n       if (DEBUG_INSN_P (pro) && !DEBUG_INSN_P (next))\n@@ -1414,8 +1414,8 @@ insn_cost (rtx insn)\n int\n dep_cost_1 (dep_t link, dw_t dw)\n {\n-  rtx insn = DEP_PRO (link);\n-  rtx used = DEP_CON (link);\n+  rtx_insn *insn = DEP_PRO (link);\n+  rtx_insn *used = DEP_CON (link);\n   int cost;\n \n   if (DEP_COST (link) != UNKNOWN_DEP_COST)\n@@ -3839,7 +3839,7 @@ schedule_insn (rtx insn)\n     for (sd_it = sd_iterator_start (insn, SD_LIST_BACK);\n \t sd_iterator_cond (&sd_it, &dep);)\n       {\n-\trtx dbg = DEP_PRO (dep);\n+\trtx_insn *dbg = DEP_PRO (dep);\n \tstruct reg_use_data *use, *next;\n \n \tif (DEP_STATUS (dep) & DEP_CANCELLED)\n@@ -3928,7 +3928,7 @@ schedule_insn (rtx insn)\n        sd_iterator_cond (&sd_it, &dep); sd_iterator_next (&sd_it))\n     {\n       struct dep_replacement *desc = DEP_REPLACE (dep);\n-      rtx pro = DEP_PRO (dep);\n+      rtx_insn *pro = DEP_PRO (dep);\n       if (QUEUE_INDEX (pro) != QUEUE_SCHEDULED\n \t  && desc != NULL && desc->insn == pro)\n \tapply_replacement (dep, false);\n@@ -3938,7 +3938,7 @@ schedule_insn (rtx insn)\n   for (sd_it = sd_iterator_start (insn, SD_LIST_FORW);\n        sd_iterator_cond (&sd_it, &dep);)\n     {\n-      rtx next = DEP_CON (dep);\n+      rtx_insn *next = DEP_CON (dep);\n       bool cancelled = (DEP_STATUS (dep) & DEP_CANCELLED) != 0;\n \n       /* Resolve the dependence between INSN and NEXT.\n@@ -4303,7 +4303,7 @@ unschedule_insns_until (rtx insn)\n       for (sd_it = sd_iterator_start (last, SD_LIST_RES_FORW);\n \t   sd_iterator_cond (&sd_it, &dep);)\n \t{\n-\t  rtx con = DEP_CON (dep);\n+\t  rtx_insn *con = DEP_CON (dep);\n \t  sd_unresolve_dep (sd_it);\n \t  if (!MUST_RECOMPUTE_SPEC_P (con))\n \t    {\n@@ -4548,7 +4548,7 @@ apply_replacement (dep_t dep, bool immediately)\n static void\n restore_pattern (dep_t dep, bool immediately)\n {\n-  rtx next = DEP_CON (dep);\n+  rtx_insn *next = DEP_CON (dep);\n   int tick = INSN_TICK (next);\n \n   /* If we already scheduled the insn, the modified version is\n@@ -4633,7 +4633,7 @@ estimate_insn_tick (bitmap processed, rtx insn, int budget)\n \n   FOR_EACH_DEP (insn, SD_LIST_BACK, sd_it, dep)\n     {\n-      rtx pro = DEP_PRO (dep);\n+      rtx_insn *pro = DEP_PRO (dep);\n       int t;\n \n       if (DEP_STATUS (dep) & DEP_CANCELLED)\n@@ -4710,7 +4710,7 @@ resolve_dependencies (rtx insn)\n   for (sd_it = sd_iterator_start (insn, SD_LIST_FORW);\n        sd_iterator_cond (&sd_it, &dep);)\n     {\n-      rtx next = DEP_CON (dep);\n+      rtx_insn *next = DEP_CON (dep);\n \n       if (sched_verbose >= 4)\n \tfprintf (sched_dump, \";;\\t\\tdep %d against %d\\n\", INSN_UID (insn),\n@@ -6987,7 +6987,7 @@ fix_inter_tick (rtx head, rtx tail)\n \n \t  FOR_EACH_DEP (head, SD_LIST_RES_FORW, sd_it, dep)\n \t    {\n-\t      rtx next;\n+\t      rtx_insn *next;\n \n \t      next = DEP_CON (dep);\n \t      tick = INSN_TICK (next);\n@@ -7173,7 +7173,7 @@ fix_tick_ready (rtx next)\n \n       FOR_EACH_DEP (next, SD_LIST_RES_BACK, sd_it, dep)\n         {\n-          rtx pro = DEP_PRO (dep);\n+          rtx_insn *pro = DEP_PRO (dep);\n           int tick1;\n \n \t  gcc_assert (INSN_TICK (pro) >= MIN_TICK);\n@@ -7441,7 +7441,7 @@ add_to_speculative_block (rtx insn)\n   for (sd_it = sd_iterator_start (insn, SD_LIST_SPEC_BACK);\n        sd_iterator_cond (&sd_it, &dep);)\n     {\n-      rtx check = DEP_PRO (dep);\n+      rtx_insn *check = DEP_PRO (dep);\n \n       if (IS_SPECULATION_SIMPLE_CHECK_P (check))\n \t{\n@@ -7460,7 +7460,7 @@ add_to_speculative_block (rtx insn)\n \n   while (1)\n     {\n-      rtx check, twin;\n+      rtx_insn *check, *twin;\n       basic_block rec;\n \n       /* Get the first backward dependency of INSN.  */\n@@ -7497,7 +7497,7 @@ add_to_speculative_block (rtx insn)\n \t instructions from REC.  */\n       FOR_EACH_DEP (insn, SD_LIST_SPEC_BACK, sd_it, dep)\n \t{\n-\t  rtx pro = DEP_PRO (dep);\n+\t  rtx_insn *pro = DEP_PRO (dep);\n \n \t  gcc_assert (DEP_TYPE (dep) == REG_DEP_TRUE);\n \n@@ -7519,7 +7519,7 @@ add_to_speculative_block (rtx insn)\n       for (sd_it = sd_iterator_start (insn, SD_LIST_SPEC_BACK);\n \t   sd_iterator_cond (&sd_it, &dep);)\n \t{\n-\t  rtx pro = DEP_PRO (dep);\n+\t  rtx_insn *pro = DEP_PRO (dep);\n \n \t  if (BLOCK_FOR_INSN (pro) == rec)\n \t    sd_delete_dep (sd_it);\n@@ -7602,8 +7602,8 @@ static void\n sched_extend_bb (void)\n {\n   /* The following is done to keep current_sched_info->next_tail non null.  */\n-  rtx end = BB_END (EXIT_BLOCK_PTR_FOR_FN (cfun)->prev_bb);\n-  rtx insn = DEBUG_INSN_P (end) ? prev_nondebug_insn (end) : end;\n+  rtx_insn *end = BB_END (EXIT_BLOCK_PTR_FOR_FN (cfun)->prev_bb);\n+  rtx_insn *insn = DEBUG_INSN_P (end) ? prev_nondebug_insn (end) : end;\n   if (NEXT_INSN (end) == 0\n       || (!NOTE_P (insn)\n \t  && !LABEL_P (insn)\n@@ -7643,7 +7643,8 @@ init_before_recovery (basic_block *before_recovery_ptr)\n          Between these two blocks recovery blocks will be emitted.  */\n \n       basic_block single, empty;\n-      rtx x, label;\n+      rtx_insn *x;\n+      rtx label;\n \n       /* If the fallthrough edge to exit we've found is from the block we've\n \t created before, don't do anything more.  */\n@@ -7707,7 +7708,7 @@ basic_block\n sched_create_recovery_block (basic_block *before_recovery_ptr)\n {\n   rtx label;\n-  rtx barrier;\n+  rtx_insn *barrier;\n   basic_block rec;\n \n   haifa_recovery_bb_recently_added_p = true;\n@@ -7916,7 +7917,7 @@ create_check_block_twin (rtx insn, bool mutate_p)\n   /* First, create dependencies between INSN's producers and CHECK & TWIN.  */\n   FOR_EACH_DEP (insn, SD_LIST_BACK, sd_it, dep)\n     {\n-      rtx pro = DEP_PRO (dep);\n+      rtx_insn *pro = DEP_PRO (dep);\n       ds_t ds;\n \n       /* If BEGIN_DATA: [insn ~~TRUE~~> producer]:\n@@ -8060,7 +8061,8 @@ create_check_block_twin (rtx insn, bool mutate_p)\n static void\n fix_recovery_deps (basic_block rec)\n {\n-  rtx note, insn, jump, ready_list = 0;\n+  rtx_insn *note, *insn, *jump;\n+  rtx ready_list = 0;\n   bitmap_head in_ready;\n   rtx link;\n \n@@ -8081,7 +8083,7 @@ fix_recovery_deps (basic_block rec)\n       for (sd_it = sd_iterator_start (insn, SD_LIST_FORW);\n \t   sd_iterator_cond (&sd_it, &dep);)\n \t{\n-\t  rtx consumer = DEP_CON (dep);\n+\t  rtx_insn *consumer = DEP_CON (dep);\n \n \t  if (BLOCK_FOR_INSN (consumer) != rec)\n \t    {\n@@ -8205,7 +8207,7 @@ unlink_bb_notes (basic_block first, basic_block last)\n   if (first == last)\n     return;\n \n-  bb_header = XNEWVEC (rtx, last_basic_block_for_fn (cfun));\n+  bb_header = XNEWVEC (rtx_insn *, last_basic_block_for_fn (cfun));\n \n   /* Make a sentinel.  */\n   if (last->next_bb != EXIT_BLOCK_PTR_FOR_FN (cfun))\n@@ -8214,7 +8216,7 @@ unlink_bb_notes (basic_block first, basic_block last)\n   first = first->next_bb;\n   do\n     {\n-      rtx prev, label, note, next;\n+      rtx_insn *prev, *label, *note, *next;\n \n       label = BB_HEAD (last);\n       if (LABEL_P (label))\n@@ -8255,7 +8257,7 @@ restore_bb_notes (basic_block first)\n   while (first != EXIT_BLOCK_PTR_FOR_FN (cfun)\n \t && bb_header[first->index])\n     {\n-      rtx prev, label, note, next;\n+      rtx_insn *prev, *label, *note, *next;\n \n       label = bb_header[first->index];\n       prev = PREV_INSN (label);\n@@ -8389,7 +8391,7 @@ clear_priorities (rtx insn, rtx_vec_t *roots_ptr)\n \n   FOR_EACH_DEP (insn, SD_LIST_BACK, sd_it, dep)\n     {\n-      rtx pro = DEP_PRO (dep);\n+      rtx_insn *pro = DEP_PRO (dep);\n \n       if (INSN_PRIORITY_STATUS (pro) >= 0\n \t  && QUEUE_INDEX (insn) != QUEUE_SCHEDULED)"}]}