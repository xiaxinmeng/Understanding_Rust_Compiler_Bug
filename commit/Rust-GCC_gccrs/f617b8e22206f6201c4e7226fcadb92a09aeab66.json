{"sha": "f617b8e22206f6201c4e7226fcadb92a09aeab66", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjYxN2I4ZTIyMjA2ZjYyMDFjNGU3MjI2ZmNhZGI5MmEwOWFlYWI2Ng==", "commit": {"author": {"name": "Neil Booth", "email": "neilb@earthling.net", "date": "2000-05-14T22:42:58Z"}, "committer": {"name": "Neil Booth", "email": "neil@gcc.gnu.org", "date": "2000-05-14T22:42:58Z"}, "message": "cpphash.c (trad_stringify, [...]): Make some pointers pointers to const.\n\n\t* cpphash.c (trad_stringify, warn_trad_stringify,\n\tcollect_params): Make some pointers pointers to const.\n\t* cpplex.c (auto_expand_name_space) Guaranteed to always\n\texpand by at least one character.\n\t(SPELL_CHAR, SPELL_NONE): Temporarily reverse order.\n\t(struct token_spelling): Use const U_CHAR * rather than PTR.\n\t(expand_name_space): Fix up token pointers if name space\n\tis moved when expanding.\n\t(INIT_NAME, cpp_scan_line, parse_name, parse_number,\n\tparse_string2, save_comment, spell_token, cpp_output_list):\n\tUpdate so the routines handle tokens with a direct pointer to\n\ttheir text, rather than an offset into the token's list's namebuf.\n\t(_cpp_lex_line): Rearrange for clarity.\n\n\t* cpplib.c (_cpp_check_directive): Similarly.\n\t(do_define): Make SYM a pointer to const.\n\t* cpplib.h (struct cpp_name): Replace offset with direct pointer.\n\t(CPP_INT, CPP_FLOAT): Spelling type should be SPELL_IDENT.\n\t(TOK_OFFSET): Delete.\n\t(TOK_NAME): Update.\n\nFrom-SVN: r33901", "tree": {"sha": "a0ba4aecb8e93ef8585a5f8c424191f55b6801a5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a0ba4aecb8e93ef8585a5f8c424191f55b6801a5"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f617b8e22206f6201c4e7226fcadb92a09aeab66", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f617b8e22206f6201c4e7226fcadb92a09aeab66", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f617b8e22206f6201c4e7226fcadb92a09aeab66", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f617b8e22206f6201c4e7226fcadb92a09aeab66/comments", "author": null, "committer": null, "parents": [{"sha": "05ef2698d02b5631c9cb1a4abeaca091ef7d9f9e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/05ef2698d02b5631c9cb1a4abeaca091ef7d9f9e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/05ef2698d02b5631c9cb1a4abeaca091ef7d9f9e"}], "stats": {"total": 173, "additions": 108, "deletions": 65}, "files": [{"sha": "cf71454239de5e10e88616faae2b987c5c3a5c68", "filename": "gcc/ChangeLog", "status": "modified", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f617b8e22206f6201c4e7226fcadb92a09aeab66/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f617b8e22206f6201c4e7226fcadb92a09aeab66/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=f617b8e22206f6201c4e7226fcadb92a09aeab66", "patch": "@@ -1,3 +1,26 @@\n+2000-05-15  Neil Booth  <NeilB@earthling.net>\n+\n+\t* cpphash.c (trad_stringify, warn_trad_stringify,\n+\tcollect_params): Make some pointers pointers to const.\n+\t* cpplex.c (auto_expand_name_space) Guaranteed to always\n+\texpand by at least one character.\n+\t(SPELL_CHAR, SPELL_NONE): Temporarily reverse order.\n+\t(struct token_spelling): Use const U_CHAR * rather than PTR.\n+\t(expand_name_space): Fix up token pointers if name space\n+\tis moved when expanding.\n+\t(INIT_NAME, cpp_scan_line, parse_name, parse_number,\n+\tparse_string2, save_comment, spell_token, cpp_output_list):\n+\tUpdate so the routines handle tokens with a direct pointer to\n+\ttheir text, rather than an offset into the token's list's namebuf.\n+\t(_cpp_lex_line): Rearrange for clarity.\n+\n+\t* cpplib.c (_cpp_check_directive): Similarly.\n+\t(do_define): Make SYM a pointer to const.\n+\t* cpplib.h (struct cpp_name): Replace offset with direct pointer.\n+\t(CPP_INT, CPP_FLOAT): Spelling type should be SPELL_IDENT.\n+\t(TOK_OFFSET): Delete.\n+\t(TOK_NAME): Update.\n+\n 2000-05-14  Geoffrey Keating  <geoffk@cygnus.com>\n \n \t* config/rs6000/rs6000.h (RETURN_ADDRESS_OFFSET): Correct for"}, {"sha": "21efb090ad4648bb7ba9ea413ed2916272ac66c6", "filename": "gcc/cpphash.c", "status": "modified", "additions": 11, "deletions": 8, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f617b8e22206f6201c4e7226fcadb92a09aeab66/gcc%2Fcpphash.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f617b8e22206f6201c4e7226fcadb92a09aeab66/gcc%2Fcpphash.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcpphash.c?ref=f617b8e22206f6201c4e7226fcadb92a09aeab66", "patch": "@@ -162,9 +162,10 @@ collect_funlike_expansion PARAMS ((cpp_reader *, cpp_toklist *,\n static unsigned int collect_params PARAMS ((cpp_reader *, cpp_toklist *,\n \t\t\t\t\t    struct arglist *));\n \n-static void warn_trad_stringify\tPARAMS ((cpp_reader *, U_CHAR *, size_t,\n+static void warn_trad_stringify\tPARAMS ((cpp_reader *, const U_CHAR *, size_t,\n \t\t\t\t\t unsigned int, const struct arg *));\n-static unsigned int trad_stringify PARAMS ((cpp_reader *, U_CHAR *, size_t,\n+static unsigned int trad_stringify PARAMS ((cpp_reader *, const U_CHAR *,\n+\t\t\t\t\t    size_t,\n \t\t\t\t\t    unsigned int, const struct arg *,\n \t\t\t\t\t    struct reflist **,\n \t\t\t\t\t    struct reflist **, unsigned int));\n@@ -371,12 +372,12 @@ add_pat (pat, endpat, nchars, argno, raw_before, raw_after, strize, rest)\n static void\n warn_trad_stringify (pfile, p, len, argc, argv)\n      cpp_reader *pfile;\n-     U_CHAR *p;\n+     const U_CHAR *p;\n      size_t len;\n      unsigned int argc;\n      const struct arg *argv;\n {\n-  U_CHAR *limit;\n+  const U_CHAR *limit;\n   unsigned int i;\n \n   limit = p + len;\n@@ -406,14 +407,14 @@ warn_trad_stringify (pfile, p, len, argc, argv)\n static unsigned int\n trad_stringify (pfile, base, len, argc, argv, pat, endpat, last)\n      cpp_reader *pfile;\n-     U_CHAR *base;\n+     const U_CHAR *base;\n      size_t len;\n      unsigned int argc;\n      const struct arg *argv;\n      struct reflist **pat, **endpat;\n      unsigned int last;\n {\n-  U_CHAR *p, *limit;\n+  const U_CHAR *p, *limit;\n   unsigned int i;\n \n   p = base;\n@@ -548,7 +549,8 @@ collect_funlike_expansion (pfile, list, arglist, replacement)\n   int j, argc;\n   size_t len;\n   const struct arg *argv;\n-  U_CHAR *tok, *exp;\n+  const U_CHAR *tok;\n+  U_CHAR *exp;\n   enum { START = 0, NORM, ARG, STRIZE, PASTE } last_token = START;\n \n   argv = arglist->argv;\n@@ -728,7 +730,8 @@ collect_params (pfile, list, arglist)\n      struct arglist *arglist;\n {\n   struct arg *argv = 0;\n-  U_CHAR *namebuf, *p, *tok;\n+  const U_CHAR *tok;\n+  U_CHAR *namebuf, *p;\n   unsigned int len, argslen;\n   unsigned int argc, a, i, j;\n "}, {"sha": "cf31d9199430a01d3ac154a7b399a156456cdb6b", "filename": "gcc/cpplex.c", "status": "modified", "additions": 68, "deletions": 50, "changes": 118, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f617b8e22206f6201c4e7226fcadb92a09aeab66/gcc%2Fcpplex.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f617b8e22206f6201c4e7226fcadb92a09aeab66/gcc%2Fcpplex.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcpplex.c?ref=f617b8e22206f6201c4e7226fcadb92a09aeab66", "patch": "@@ -60,7 +60,7 @@ static void pedantic_whitespace\tPARAMS ((cpp_reader *, U_CHAR *,\n \t\t\t\t\t unsigned int));\n \n #define auto_expand_name_space(list) \\\n-    expand_name_space ((list), (list)->name_cap / 2)\n+    expand_name_space ((list), 1 + (list)->name_cap / 2)\n \n #ifdef NEW_LEXER\n \n@@ -85,15 +85,15 @@ void _cpp_lex_line PARAMS ((cpp_reader *, cpp_toklist *));\n static void _cpp_output_list PARAMS ((cpp_reader *, cpp_toklist *));\n \n static unsigned char * spell_token PARAMS ((cpp_reader *, cpp_token *,\n-\t\t\t\t\t    cpp_toklist *, unsigned char *,\n-\t\t\t\t\t    int));\n+\t\t\t\t\t    unsigned char *, int));\n \n typedef unsigned int (* speller) PARAMS ((unsigned char *, cpp_toklist *,\n \t\t\t\t\t  cpp_token *));\n \n /* Macros on a cpp_name.  */\n #define INIT_NAME(list, name) \\\n-  do {(name).len = 0; (name).offset = (list)->name_used;} while (0)\n+  do {(name).len = 0; \\\n+      (name).text = (list)->namebuf + (list)->name_used;} while (0)\n \n #define IS_DIRECTIVE(list) (TOK_TYPE (list, 0) == CPP_HASH)\n #define COLUMN(cur) ((cur) - buffer->line_base)\n@@ -114,24 +114,37 @@ typedef unsigned int (* speller) PARAMS ((unsigned char *, cpp_toklist *,\n #define IMMED_TOKEN() (!(cur_token->flags & PREV_WHITESPACE))\n #define PREV_TOKEN_TYPE (cur_token[-1].type)\n \n+#define PUSH_TOKEN(ttype) cur_token++->type = ttype\n+#define REVISE_TOKEN(ttype) cur_token[-1].type = ttype\n+#define BACKUP_TOKEN(ttype) (--cur_token)->type = ttype\n+#define BACKUP_DIGRAPH(ttype) do { \\\n+  BACKUP_TOKEN(ttype); cur_token->flags |= DIGRAPH;} while (0)\n+\n+/* An upper bound on the number of bytes needed to spell a token,\n+   including preceding whitespace.  */\n+#define TOKEN_LEN(token) (5 + (token_spellings[token->type].type > \\\n+\t\t               SPELL_NONE ? token->val.name.len: 0))\n+\n+#endif\n+\n /* Order here matters.  Those beyond SPELL_NONE store their spelling\n    in the token list, and it's length in the token->val.name.len.  */\n #define SPELL_OPERATOR 0\n-#define SPELL_CHAR     1\n-#define SPELL_NONE     2\n+#define SPELL_CHAR     2\t/* FIXME: revert order after transition. */\n+#define SPELL_NONE     1\n #define SPELL_IDENT    3\n #define SPELL_STRING   4\n \n-#define T(e, s) {SPELL_OPERATOR, s},\n+#define T(e, s) {SPELL_OPERATOR, (const U_CHAR *) s},\n #define I(e, s) {SPELL_IDENT, s},\n #define S(e, s) {SPELL_STRING, s},\n #define C(e, s) {SPELL_CHAR, s},\n #define N(e, s) {SPELL_NONE, s},\n \n static const struct token_spelling\n {\n-  unsigned char type;\n-  PTR  speller;\n+  U_CHAR type;\n+  const U_CHAR *spelling;\n } token_spellings [N_TTYPES + 1] = {TTYPE_TABLE {0, 0} };\n \n #undef T\n@@ -140,19 +153,6 @@ static const struct token_spelling\n #undef C\n #undef N\n \n-#define PUSH_TOKEN(ttype) cur_token++->type = ttype\n-#define REVISE_TOKEN(ttype) cur_token[-1].type = ttype\n-#define BACKUP_TOKEN(ttype) (--cur_token)->type = ttype\n-#define BACKUP_DIGRAPH(ttype) do { \\\n-  BACKUP_TOKEN(ttype); cur_token->flags |= DIGRAPH;} while (0)\n-\n-/* An upper bound on the number of bytes needed to spell a token,\n-   including preceding whitespace.  */\n-#define TOKEN_LEN(token) (5 + (token_spellings[token->type].type > \\\n-\t\t               SPELL_NONE ? token->val.name.len: 0))\n-\n-#endif\n-\n /* Re-allocates PFILE->token_buffer so it will hold at least N more chars.  */\n \n void\n@@ -525,8 +525,23 @@ expand_name_space (list, len)\n      cpp_toklist *list;\n      unsigned int len;\n {\n+  const U_CHAR *old_namebuf;\n+  ptrdiff_t delta;\n+\n+  old_namebuf = list->namebuf;\n   list->name_cap += len;\n   list->namebuf = (unsigned char *) xrealloc (list->namebuf, list->name_cap);\n+\n+  /* Fix up token text pointers.  */\n+  delta = list->namebuf - old_namebuf;\n+  if (delta)\n+    {\n+      unsigned int i;\n+\n+      for (i = 0; i < list->tokens_used; i++)\n+\tif (token_spellings[list->tokens[i].type].type > SPELL_NONE)\n+\t  list->tokens[i].val.name.text += delta;\n+    }\n }\n \n /* Expand the number of tokens in a list.  */\n@@ -632,9 +647,14 @@ _cpp_scan_line (pfile, list)\n \tbreak;\n \n       TOK_LEN (list, i) = len;\n-      TOK_OFFSET (list, i) = list->name_used;\n-      memcpy (TOK_NAME (list, i), CPP_PWRITTEN (pfile), len);\n-      list->name_used += len;\n+      if (token_spellings[type].type > SPELL_NONE)\n+\t{\n+\t  memcpy (list->namebuf + list->name_used, CPP_PWRITTEN (pfile), len);\n+\t  TOK_NAME (list, i) = list->namebuf + list->name_used;\n+\t  list->name_used += len;\n+\t}\n+      else\n+\tTOK_NAME (list, i) = token_spellings[type].spelling;\n       i++;\n       space_before = 0;\n     }\n@@ -2563,7 +2583,7 @@ parse_name (pfile, list, name)\n \n  out:\n   buffer->cur = cur;\n-  name->len = namebuf - (list->namebuf + name->offset);\n+  name->len = namebuf - name->text;\n   list->name_used = namebuf - list->namebuf;\n }\n \n@@ -2613,7 +2633,7 @@ parse_number (pfile, list, name)\n   \n  out:\n   buffer->cur = cur;\n-  name->len = namebuf - (list->namebuf + name->offset);\n+  name->len = namebuf - name->text;\n   list->name_used = namebuf - list->namebuf;\n }\n \n@@ -2651,18 +2671,16 @@ parse_string2 (pfile, list, name, terminator)\n \tnull_count++;\n       else if (c == terminator || IS_NEWLINE (c))\n \t{\n-\t  unsigned char* name_start = list->namebuf + name->offset;\n-\n \t  /* Needed for trigraph_replace and multiline string warning.  */\n \t  buffer->cur = cur;\n \n \t  /* Scan for trigraphs before checking if backslash-escaped.  */\n \t  if (CPP_OPTION (pfile, trigraphs)\n \t      || CPP_OPTION (pfile, warn_trigraphs))\n \t    {\n-\t      namebuf = trigraph_replace (pfile, name_start + trigraphed_len,\n+\t      namebuf = trigraph_replace (pfile, name->text + trigraphed_len,\n \t\t\t\t\t    namebuf);\n-\t      trigraphed_len = namebuf - 2 - (name_start + trigraphed_len);\n+\t      trigraphed_len = namebuf - 2 - (name->text + trigraphed_len);\n \t      if (trigraphed_len < 0)\n \t\ttrigraphed_len = 0;\n \t    }\n@@ -2714,7 +2732,7 @@ parse_string2 (pfile, list, name, terminator)\n \t      /* An odd number of consecutive backslashes represents\n \t\t an escaped terminator.  */\n \t      temp = namebuf - 1;\n-\t      while (temp >= name_start && *temp == '\\\\')\n+\t      while (temp >= name->text && *temp == '\\\\')\n \t\ttemp--;\n \n \t      if ((namebuf - temp) & 1)\n@@ -2751,7 +2769,7 @@ parse_string2 (pfile, list, name, terminator)\n   \n  out:\n   buffer->cur = cur;\n-  name->len = namebuf - (list->namebuf + name->offset);\n+  name->len = namebuf - name->text;\n   list->name_used = namebuf - list->namebuf;\n \n   if (null_count > 0)\n@@ -2783,13 +2801,14 @@ save_comment (list, from, len, tok_no, type)\n   if (list->name_used + len > list->name_cap)\n     expand_name_space (list, len);\n \n+  buffer = list->namebuf + list->name_used;\n+\n   comment = &list->comments[list->comments_used++];\n   comment->type = CPP_COMMENT;\n   comment->aux = tok_no;\n   comment->val.name.len = len;\n-  comment->val.name.offset = list->name_used;\n+  comment->val.name.text = buffer;\n \n-  buffer = list->namebuf + list->name_used;\n   if (type == '*')\n     {\n       *buffer++ = '/';\n@@ -2863,20 +2882,20 @@ _cpp_lex_line (pfile, list)\n \t{\n \tcase '0': case '1': case '2': case '3': case '4':\n \tcase '5': case '6': case '7': case '8': case '9':\n-\t  /* Prepend an immediately previous CPP_DOT token.  */\n+\t  cur--;\t\t/* Backup character.  */\n \t  if (PREV_TOKEN_TYPE == CPP_DOT && IMMED_TOKEN ())\n \t    {\n+\t      /* Prepend an immediately previous CPP_DOT token.  */\n \t      cur_token--;\n \t      if (list->name_cap == list->name_used)\n \t\tauto_expand_name_space (list);\n \n \t      cur_token->val.name.len = 1;\n-\t      cur_token->val.name.offset = list->name_used;\n+\t      cur_token->val.name.text = list->namebuf + list->name_used;\n \t      list->namebuf[list->name_used++] = '.';\n \t    }\n \t  else\n \t    INIT_NAME (list, cur_token->val.name);\n-\t  cur--;\t\t/* Backup character.  */\n \n \tcontinue_number:\n \t  buffer->cur = cur;\n@@ -2898,8 +2917,8 @@ _cpp_lex_line (pfile, list)\n \tcase 'M': case 'N': case 'O': case 'P': case 'Q': case 'R':\n \tcase 'S': case 'T': case 'U': case 'V': case 'W': case 'X':\n \tcase 'Y': case 'Z':\n-\t  INIT_NAME (list, cur_token->val.name);\n \t  cur--;\t\t     /* Backup character.  */\n+\t  INIT_NAME (list, cur_token->val.name);\n \t  cur_token->type = CPP_NAME; /* Identifier, macro etc.  */\n \n \tcontinue_name:\n@@ -2920,7 +2939,7 @@ _cpp_lex_line (pfile, list)\n \t  /* Do we have a wide string?  */\n \t  if (cur_token[-1].type == CPP_NAME && IMMED_TOKEN ()\n \t      && cur_token[-1].val.name.len == 1\n-\t      && *(list->namebuf + cur_token[-1].val.name.offset) == 'L'\n+\t      && cur_token[-1].val.name.text[0] == 'L'\n \t      && !CPP_TRADITIONAL (pfile))\n \t    {\n \t      /* No need for 'L' any more.  */\n@@ -3006,9 +3025,10 @@ _cpp_lex_line (pfile, list)\n \t\t\t\t cur_token - 1 - list->tokens, c);\n \t\t  cur = buffer->cur;\n \n-\t\t  cur_token -= 2;\n+\t\t  cur_token--;\n \t\t  if (!CPP_OPTION (pfile, traditional))\n \t\t    flags = PREV_WHITESPACE;\n+\t\t  break;\n \t\t}\n \t      else if (CPP_OPTION (pfile, cplusplus))\n \t\t{\n@@ -3249,6 +3269,7 @@ _cpp_lex_line (pfile, list)\n \t  /* Fall through */\n \tdefault:\n \t  cur_token->aux = c;\n+\t  cur_token->val.name.len = 0; /* FIXME: needed for transition only */\n \t  PUSH_TOKEN (CPP_OTHER);\n \t  break;\n \t}\n@@ -3300,10 +3321,9 @@ _cpp_lex_line (pfile, list)\n    to the character after the last character written.  */\n \n static unsigned char *\n-spell_token (pfile, token, list, buffer, whitespace)\n+spell_token (pfile, token, buffer, whitespace)\n      cpp_reader *pfile;\t\t/* Would be nice to be rid of this...  */\n      cpp_token *token;\n-     cpp_toklist *list;\t\t/* FIXME: get rid of this...  */\n      unsigned char *buffer;\n      int whitespace;\n {\n@@ -3323,16 +3343,15 @@ spell_token (pfile, token, list, buffer, whitespace)\n \tif (token->flags & DIGRAPH)\n \t  spelling = digraph_spellings[token->type - CPP_FIRST_DIGRAPH];\n \telse\n-\t  spelling = token_spellings[token->type].speller;\n+\t  spelling = token_spellings[token->type].spelling;\n \t\n \twhile ((c = *spelling++) != '\\0')\n \t  *buffer++ = c;\n       }\n       break;\n \n     case SPELL_IDENT:\n-      memcpy (buffer, list->namebuf + token->val.name.offset,\n-\t      token->val.name.len);\n+      memcpy (buffer, token->val.name.text, token->val.name.len);\n       buffer += token->val.name.len;\n       break;\n \n@@ -3346,8 +3365,7 @@ spell_token (pfile, token, list, buffer, whitespace)\n \tif (token->type == CPP_STRING || token->type == CPP_WSTRING)\n \t  c = '\"';\n \t*buffer++ = c;\n-\tmemcpy (buffer, list->namebuf + token->val.name.offset,\n-\t\ttoken->val.name.len);\n+\tmemcpy (buffer, token->val.name.text, token->val.name.len);\n \tbuffer += token->val.name.len;\n \t*buffer++ = c;\n       }\n@@ -3420,7 +3438,7 @@ _cpp_output_list (pfile, list)\n \t{\n \t  /* Make space for the comment, and copy it out.  */\n \t  CPP_RESERVE (pfile, TOKEN_LEN (comment));\n-\t  pfile->limit = spell_token (pfile, comment, list, pfile->limit, 0);\n+\t  pfile->limit = spell_token (pfile, comment, pfile->limit, 0);\n \n \t  /* Stop if no comments left, or no more comments appear\n              before the current token.  */\n@@ -3431,7 +3449,7 @@ _cpp_output_list (pfile, list)\n \t}\n \n       CPP_RESERVE (pfile, TOKEN_LEN (token));\n-      pfile->limit = spell_token (pfile, token, list, pfile->limit, 1);\n+      pfile->limit = spell_token (pfile, token, pfile->limit, 1);\n     }\n   while (token++->type != CPP_VSPACE);\n }"}, {"sha": "457cc218c28b53a8680d1d9d4bc973c902f2cd18", "filename": "gcc/cpplib.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f617b8e22206f6201c4e7226fcadb92a09aeab66/gcc%2Fcpplib.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f617b8e22206f6201c4e7226fcadb92a09aeab66/gcc%2Fcpplib.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcpplib.c?ref=f617b8e22206f6201c4e7226fcadb92a09aeab66", "patch": "@@ -156,7 +156,7 @@ _cpp_check_directive (list, token)\n      cpp_toklist *list;\n      cpp_token *token;\n {\n-  const U_CHAR *name = list->namebuf + token->val.name.offset;\n+  const U_CHAR *name = token->val.name.text;\n   size_t len = token->val.name.len;\n   unsigned int i;\n \n@@ -339,7 +339,7 @@ do_define (pfile)\n {\n   HASHNODE *node;\n   int len;\n-  U_CHAR *sym;\n+  const U_CHAR *sym;\n   cpp_toklist *list = &pfile->directbuf;\n \n   pfile->no_macro_expand++;"}, {"sha": "7a09252a5d698123a09bb7b6d99e72a831aba49b", "filename": "gcc/cpplib.h", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f617b8e22206f6201c4e7226fcadb92a09aeab66/gcc%2Fcpplib.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f617b8e22206f6201c4e7226fcadb92a09aeab66/gcc%2Fcpplib.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcpplib.h?ref=f617b8e22206f6201c4e7226fcadb92a09aeab66", "patch": "@@ -110,8 +110,8 @@ typedef struct cpp_name cpp_name;\n   C(CPP_OTHER,\t\t0)\t/* stray punctuation */ \\\n \\\n   I(CPP_NAME,\t\t0)\t/* word */\t\\\n-  N(CPP_INT,\t\t0)\t/* 23 */\t\\\n-  N(CPP_FLOAT,\t\t0)\t/* 3.14159 */\t\\\n+  I(CPP_INT,\t\t0)\t/* 23 */\t\\\n+  I(CPP_FLOAT,\t\t0)\t/* 3.14159 */\t\\\n   I(CPP_NUMBER,\t\t0)\t/* 34_be+ta  */\t\\\n   S(CPP_CHAR,\t\t0)\t/* 'char' */\t\\\n   S(CPP_WCHAR,\t\t0)\t/* L'char' */\t\\\n@@ -151,7 +151,7 @@ enum cpp_ttype\n struct cpp_name\n {\n   unsigned int len;\n-  unsigned int offset;\t\t/* from list->namebuf */\n+  const unsigned char *text;\n };\n \n /* Accessor macros for token lists - all expect you have a\n@@ -162,8 +162,7 @@ struct cpp_name\n #define TOK_AUX(l_, i_)    ((l_)->tokens[i_].aux)\n #define TOK_COL(l_, i_)    ((l_)->tokens[i_].col)\n #define TOK_INT(l_, i_)    ((l_)->tokens[i_].val.integer)\n-#define TOK_OFFSET(l_, i_) ((l_)->tokens[i_].val.name.offset)\n-#define TOK_NAME(l_, i_)   ((l_)->tokens[i_].val.name.offset + (l_)->namebuf)\n+#define TOK_NAME(l_, i_)   ((l_)->tokens[i_].val.name.text)\n #define TOK_LEN(l_, i_)    ((l_)->tokens[i_].val.name.len)\n \n #define TOK_PREV_WHITE(l_, i_) (TOK_FLAGS(l_, i_) & PREV_WHITESPACE)"}]}