{"sha": "3070bab4c9421f35fd4149a238768befd2717ddb", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzA3MGJhYjRjOTQyMWYzNWZkNDE0OWEyMzg3NjhiZWZkMjcxN2RkYg==", "commit": {"author": {"name": "Janus Weil", "email": "janus@gcc.gnu.org", "date": "2009-04-09T09:39:09Z"}, "committer": {"name": "Janus Weil", "email": "janus@gcc.gnu.org", "date": "2009-04-09T09:39:09Z"}, "message": "re PR fortran/36704 (Procedure pointer as function result)\n\n2009-04-09  Janus Weil  <janus@gcc.gnu.org>\n\n\tPR fortran/36704\n\t* decl.c (add_hidden_procptr_result): New function for handling\n\tprocedure pointer return values by adding a hidden result variable.\n\t(variable_decl,match_procedure_decl,gfc_match_function_decl,\n\tgfc_match_subroutine,gfc_match_end,attr_decl1): Handle procedure pointer\n\treturn values.\n\t* parse.c (parse_interface): Add EXTERNAL attribute only after\n\tFUNCTION/SUBROUTINE declaration is complete.\n\t* primary.c (replace_hidden_procptr_result): New function for replacing\n\tfunction symbol by hidden result variable.\n\t(gfc_match_rvalue,match_variable): Replace symbol by hidden result\n\tvariable.\n\t* resolve.c (resolve_contained_fntype,resolve_function,resolve_variable,\n\tresolve_symbol): Allow for procedure pointer function results.\n\t(resolve_fl_procedure): Conflict detection moved here from\n\t'check_conflict'.\n\t* symbol.c (gfc_check_function_type): Allow for procedure pointer\n\tfunction results.\n\t(check_conflict): Move some conflict detection to resolution stage.\n\t* trans-types.c (gfc_sym_type,gfc_get_function_type): Handle hidden\n\tresult variables.\n\n\n2009-04-09  Janus Weil  <janus@gcc.gnu.org>\n\n\tPR fortran/36704\n\t* gfortran.dg/external_procedures_1.f90: Modified.\n\t* gfortran.dg/proc_ptr_result_1.f90: New.\n\t* gfortran.dg/proc_ptr_result_2.f90: New.\n\t* gfortran.dg/proc_ptr_result_3.f90: New.\n\nFrom-SVN: r145815", "tree": {"sha": "281a4a95643d1f27ef18644d79406042326b0862", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/281a4a95643d1f27ef18644d79406042326b0862"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3070bab4c9421f35fd4149a238768befd2717ddb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3070bab4c9421f35fd4149a238768befd2717ddb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3070bab4c9421f35fd4149a238768befd2717ddb", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3070bab4c9421f35fd4149a238768befd2717ddb/comments", "author": {"login": "janusw", "id": 484108, "node_id": "MDQ6VXNlcjQ4NDEwOA==", "avatar_url": "https://avatars.githubusercontent.com/u/484108?v=4", "gravatar_id": "", "url": "https://api.github.com/users/janusw", "html_url": "https://github.com/janusw", "followers_url": "https://api.github.com/users/janusw/followers", "following_url": "https://api.github.com/users/janusw/following{/other_user}", "gists_url": "https://api.github.com/users/janusw/gists{/gist_id}", "starred_url": "https://api.github.com/users/janusw/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/janusw/subscriptions", "organizations_url": "https://api.github.com/users/janusw/orgs", "repos_url": "https://api.github.com/users/janusw/repos", "events_url": "https://api.github.com/users/janusw/events{/privacy}", "received_events_url": "https://api.github.com/users/janusw/received_events", "type": "User", "site_admin": false}, "committer": {"login": "janusw", "id": 484108, "node_id": "MDQ6VXNlcjQ4NDEwOA==", "avatar_url": "https://avatars.githubusercontent.com/u/484108?v=4", "gravatar_id": "", "url": "https://api.github.com/users/janusw", "html_url": "https://github.com/janusw", "followers_url": "https://api.github.com/users/janusw/followers", "following_url": "https://api.github.com/users/janusw/following{/other_user}", "gists_url": "https://api.github.com/users/janusw/gists{/gist_id}", "starred_url": "https://api.github.com/users/janusw/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/janusw/subscriptions", "organizations_url": "https://api.github.com/users/janusw/orgs", "repos_url": "https://api.github.com/users/janusw/repos", "events_url": "https://api.github.com/users/janusw/events{/privacy}", "received_events_url": "https://api.github.com/users/janusw/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b61ee1aa7b06fe0c5d970a943aa8451c1e04c97d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b61ee1aa7b06fe0c5d970a943aa8451c1e04c97d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b61ee1aa7b06fe0c5d970a943aa8451c1e04c97d"}], "stats": {"total": 579, "additions": 531, "deletions": 48}, "files": [{"sha": "d24afdf7cd10581aba3d06ea1019fd88367ea336", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3070bab4c9421f35fd4149a238768befd2717ddb/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3070bab4c9421f35fd4149a238768befd2717ddb/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=3070bab4c9421f35fd4149a238768befd2717ddb", "patch": "@@ -1,3 +1,27 @@\n+2009-04-09  Janus Weil  <janus@gcc.gnu.org>\n+\n+\tPR fortran/36704\n+\t* decl.c (add_hidden_procptr_result): New function for handling\n+\tprocedure pointer return values by adding a hidden result variable.\n+\t(variable_decl,match_procedure_decl,gfc_match_function_decl,\n+\tgfc_match_subroutine,gfc_match_end,attr_decl1): Handle procedure pointer\n+\treturn values.\n+\t* parse.c (parse_interface): Add EXTERNAL attribute only after\n+\tFUNCTION/SUBROUTINE declaration is complete.\n+\t* primary.c (replace_hidden_procptr_result): New function for replacing\n+\tfunction symbol by hidden result variable.\n+\t(gfc_match_rvalue,match_variable): Replace symbol by hidden result\n+\tvariable.\n+\t* resolve.c (resolve_contained_fntype,resolve_function,resolve_variable,\n+\tresolve_symbol): Allow for procedure pointer function results.\n+\t(resolve_fl_procedure): Conflict detection moved here from\n+\t'check_conflict'.\n+\t* symbol.c (gfc_check_function_type): Allow for procedure pointer\n+\tfunction results.\n+\t(check_conflict): Move some conflict detection to resolution stage.\n+\t* trans-types.c (gfc_sym_type,gfc_get_function_type): Handle hidden\n+\tresult variables.\n+\n 2009-04-08  Jakub Jelinek  <jakub@redhat.com>\n \n \t* trans-types.c (gfc_init_types): Ensure gfc_integer_types doesn't"}, {"sha": "27fe8ff18fd8b7dd2b49f89d1b9e1b4add72626f", "filename": "gcc/fortran/decl.c", "status": "modified", "additions": 95, "deletions": 1, "changes": 96, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3070bab4c9421f35fd4149a238768befd2717ddb/gcc%2Ffortran%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3070bab4c9421f35fd4149a238768befd2717ddb/gcc%2Ffortran%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fdecl.c?ref=3070bab4c9421f35fd4149a238768befd2717ddb", "patch": "@@ -1667,6 +1667,17 @@ variable_decl (int elem)\n \t}\n     }\n \n+  /* Procedure pointer as function result.  */\n+  if (gfc_current_state () == COMP_FUNCTION\n+      && strcmp (\"ppr@\", gfc_current_block ()->name) == 0\n+      && strcmp (name, gfc_current_block ()->ns->proc_name->name) == 0)\n+    strcpy (name, \"ppr@\");\n+\n+  if (gfc_current_state () == COMP_FUNCTION\n+      && strcmp (name, gfc_current_block ()->name) == 0\n+      && gfc_current_block ()->result\n+      && strcmp (\"ppr@\", gfc_current_block ()->result->name) == 0)\n+    strcpy (name, \"ppr@\");\n \n   /* OK, we've successfully matched the declaration.  Now put the\n      symbol in the current namespace, because it might be used in the\n@@ -4069,6 +4080,66 @@ gfc_match_suffix (gfc_symbol *sym, gfc_symbol **result)\n }\n \n \n+/* Procedure pointer return value without RESULT statement:\n+   Add \"hidden\" result variable named \"ppr@\".  */\n+\n+static gfc_try\n+add_hidden_procptr_result (gfc_symbol *sym)\n+{\n+  bool case1,case2;\n+\n+  if (gfc_notification_std (GFC_STD_F2003) == ERROR)\n+    return FAILURE;\n+\n+  /* First usage case: PROCEDURE and EXTERNAL statements.  */\n+  case1 = gfc_current_state () == COMP_FUNCTION && gfc_current_block ()\n+\t  && strcmp (gfc_current_block ()->name, sym->name) == 0\n+\t  && sym->attr.external;\n+  /* Second usage case: INTERFACE statements.  */\n+  case2 = gfc_current_state () == COMP_INTERFACE && gfc_state_stack->previous\n+\t  && gfc_state_stack->previous->state == COMP_FUNCTION\n+\t  && strcmp (gfc_state_stack->previous->sym->name, sym->name) == 0;\n+\n+  if (case1 || case2)\n+    {\n+      gfc_symtree *stree;\n+      if (case1)\n+        gfc_get_sym_tree (\"ppr@\", gfc_current_ns, &stree);\n+      else if (case2)\n+        gfc_get_sym_tree (\"ppr@\", gfc_current_ns->parent, &stree);\n+      sym->result = stree->n.sym;\n+\n+      sym->result->attr.proc_pointer = sym->attr.proc_pointer;\n+      sym->result->attr.pointer = sym->attr.pointer;\n+      sym->result->attr.external = sym->attr.external;\n+      sym->result->attr.referenced = sym->attr.referenced;\n+      sym->attr.proc_pointer = 0;\n+      sym->attr.pointer = 0;\n+      sym->attr.external = 0;\n+      if (sym->result->attr.external && sym->result->attr.pointer)\n+\t{\n+\t  sym->result->attr.pointer = 0;\n+\t  sym->result->attr.proc_pointer = 1;\n+\t}\n+\n+      return gfc_add_result (&sym->result->attr, sym->result->name, NULL);\n+    }\n+  /* POINTER after PROCEDURE/EXTERNAL/INTERFACE statement.  */\n+  else if (sym->attr.function && !sym->attr.external && sym->attr.pointer\n+\t   && sym->result && sym->result != sym && sym->result->attr.external\n+\t   && sym == gfc_current_ns->proc_name\n+\t   && sym == sym->result->ns->proc_name\n+\t   && strcmp (\"ppr@\", sym->result->name) == 0)\n+    {\n+      sym->result->attr.proc_pointer = 1;\n+      sym->attr.pointer = 0;\n+      return SUCCESS;\n+    }\n+  else\n+    return FAILURE;\n+}\n+\n+\n /* Match a PROCEDURE declaration (R1211).  */\n \n static match\n@@ -4201,6 +4272,10 @@ match_procedure_decl (void)\n \n       if (gfc_add_external (&sym->attr, NULL) == FAILURE)\n \treturn MATCH_ERROR;\n+\n+      if (add_hidden_procptr_result (sym) == SUCCESS)\n+\tsym = sym->result;\n+\n       if (gfc_add_proc (&sym->attr, sym->name, NULL) == FAILURE)\n \treturn MATCH_ERROR;\n \n@@ -4415,6 +4490,10 @@ gfc_match_function_decl (void)\n     }\n   if (get_proc_name (name, &sym, false))\n     return MATCH_ERROR;\n+\n+  if (add_hidden_procptr_result (sym) == SUCCESS)\n+    sym = sym->result;\n+\n   gfc_new_block = sym;\n \n   m = gfc_match_formal_arglist (sym, 0, 0);\n@@ -4812,6 +4891,10 @@ gfc_match_subroutine (void)\n \n   if (get_proc_name (name, &sym, false))\n     return MATCH_ERROR;\n+\n+  if (add_hidden_procptr_result (sym) == SUCCESS)\n+    sym = sym->result;\n+\n   gfc_new_block = sym;\n \n   /* Check what next non-whitespace character is so we can tell if there\n@@ -5259,12 +5342,21 @@ gfc_match_end (gfc_statement *st)\n   if (block_name == NULL)\n     goto syntax;\n \n-  if (strcmp (name, block_name) != 0)\n+  if (strcmp (name, block_name) != 0 && strcmp (block_name, \"ppr@\") != 0)\n     {\n       gfc_error (\"Expected label '%s' for %s statement at %C\", block_name,\n \t\t gfc_ascii_statement (*st));\n       goto cleanup;\n     }\n+  /* Procedure pointer as function result.  */\n+  else if (strcmp (block_name, \"ppr@\") == 0\n+\t   && strcmp (name, gfc_current_block ()->ns->proc_name->name) != 0)\n+    {\n+      gfc_error (\"Expected label '%s' for %s statement at %C\",\n+\t\t gfc_current_block ()->ns->proc_name->name,\n+\t\t gfc_ascii_statement (*st));\n+      goto cleanup;\n+    }\n \n   if (gfc_match_eos () == MATCH_YES)\n     return MATCH_YES;\n@@ -5375,6 +5467,8 @@ attr_decl1 (void)\n       goto cleanup;\n     }\n \n+  add_hidden_procptr_result (sym);\n+\n   return MATCH_YES;\n \n cleanup:"}, {"sha": "81e4591b9be4bf7ffee0292a03c8862597937d49", "filename": "gcc/fortran/parse.c", "status": "modified", "additions": 4, "deletions": 8, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3070bab4c9421f35fd4149a238768befd2717ddb/gcc%2Ffortran%2Fparse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3070bab4c9421f35fd4149a238768befd2717ddb/gcc%2Ffortran%2Fparse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fparse.c?ref=3070bab4c9421f35fd4149a238768befd2717ddb", "patch": "@@ -2113,14 +2113,6 @@ parse_interface (void)\n \t  gfc_free_namespace (gfc_current_ns);\n \t  goto loop;\n \t}\n-      if (current_interface.type != INTERFACE_ABSTRACT &&\n-\t !gfc_new_block->attr.dummy &&\n-\t gfc_add_external (&gfc_new_block->attr, &gfc_current_locus) == FAILURE)\n-\t{\n-\t  reject_statement ();\n-\t  gfc_free_namespace (gfc_current_ns);\n-\t  goto loop;\n-\t}\n       break;\n \n     case ST_PROCEDURE:\n@@ -2213,6 +2205,10 @@ parse_interface (void)\n       goto decl;\n     }\n \n+  /* Add EXTERNAL attribute to function or subroutine.  */\n+  if (current_interface.type != INTERFACE_ABSTRACT && !prog_unit->attr.dummy)\n+    gfc_add_external (&prog_unit->attr, &gfc_current_locus);\n+\n   current_interface = save;\n   gfc_add_interface (prog_unit);\n   pop_state ();"}, {"sha": "cab8f82edfbd44d009a8a70d36e0391b96ff1526", "filename": "gcc/fortran/primary.c", "status": "modified", "additions": 30, "deletions": 1, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3070bab4c9421f35fd4149a238768befd2717ddb/gcc%2Ffortran%2Fprimary.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3070bab4c9421f35fd4149a238768befd2717ddb/gcc%2Ffortran%2Fprimary.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fprimary.c?ref=3070bab4c9421f35fd4149a238768befd2717ddb", "patch": "@@ -2358,6 +2358,30 @@ check_for_implicit_index (gfc_symtree **st, gfc_symbol **sym)\n }\n \n \n+/* Procedure pointer as function result: Replace the function symbol by the\n+   auto-generated hidden result variable named \"ppr@\".  */\n+\n+static gfc_try\n+replace_hidden_procptr_result (gfc_symbol **sym, gfc_symtree **st)\n+{\n+  /* Check for procedure pointer result variable.  */\n+  if ((*sym)->attr.function && !(*sym)->attr.external\n+      && (*sym)->result && (*sym)->result != *sym\n+      && (*sym)->result->attr.proc_pointer\n+      && (*sym) == gfc_current_ns->proc_name\n+      && (*sym) == (*sym)->result->ns->proc_name\n+      && strcmp (\"ppr@\", (*sym)->result->name) == 0)\n+    {\n+      /* Automatic replacement with \"hidden\" result variable.  */\n+      (*sym)->result->attr.referenced = (*sym)->attr.referenced;\n+      *sym = (*sym)->result;\n+      *st = gfc_find_symtree ((*sym)->ns->sym_root, (*sym)->name);\n+      return SUCCESS;\n+    }\n+  return FAILURE;\n+}\n+\n+\n /* Matches a variable name followed by anything that might follow it--\n    array reference, argument list of a function, etc.  */\n \n@@ -2394,6 +2418,8 @@ gfc_match_rvalue (gfc_expr **result)\n   e = NULL;\n   where = gfc_current_locus;\n \n+  replace_hidden_procptr_result (&sym, &symtree);\n+\n   /* If this is an implicit do loop index and implicitly typed,\n      it should not be host associated.  */\n   m = check_for_implicit_index (&symtree, &sym);\n@@ -2583,6 +2609,8 @@ gfc_match_rvalue (gfc_expr **result)\n       gfc_get_ha_sym_tree (name, &symtree);\t/* Can't fail */\n       sym = symtree->n.sym;\n \n+      replace_hidden_procptr_result (&sym, &symtree);\n+\n       e = gfc_get_expr ();\n       e->symtree = symtree;\n       e->expr_type = EXPR_FUNCTION;\n@@ -2912,7 +2940,8 @@ match_variable (gfc_expr **result, int equiv_flag, int host_flag)\n \t  break;\n \t}\n \n-      if (sym->attr.proc_pointer)\n+      if (sym->attr.proc_pointer\n+\t  || replace_hidden_procptr_result (&sym, &st) == SUCCESS)\n \tbreak;\n \n       /* Fall through to error */"}, {"sha": "438b0d642ec6e7e7899cf69805041ea7ad790559", "filename": "gcc/fortran/resolve.c", "status": "modified", "additions": 50, "deletions": 19, "changes": 69, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3070bab4c9421f35fd4149a238768befd2717ddb/gcc%2Ffortran%2Fresolve.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3070bab4c9421f35fd4149a238768befd2717ddb/gcc%2Ffortran%2Fresolve.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fresolve.c?ref=3070bab4c9421f35fd4149a238768befd2717ddb", "patch": "@@ -344,7 +344,7 @@ resolve_contained_fntype (gfc_symbol *sym, gfc_namespace *ns)\n \t  if (sym->result == sym)\n \t    gfc_error (\"Contained function '%s' at %L has no IMPLICIT type\",\n \t\t       sym->name, &sym->declared_at);\n-\t  else\n+\t  else if (!sym->result->attr.proc_pointer)\n \t    gfc_error (\"Result '%s' of contained function '%s' at %L has \"\n \t\t       \"no IMPLICIT type\", sym->result->name, sym->name,\n \t\t       &sym->result->declared_at);\n@@ -2530,7 +2530,8 @@ resolve_function (gfc_expr *expr)\n   if (expr->ts.type == BT_UNKNOWN)\n     {\n       if (expr->symtree->n.sym->result\n-\t    && expr->symtree->n.sym->result->ts.type != BT_UNKNOWN)\n+\t    && expr->symtree->n.sym->result->ts.type != BT_UNKNOWN\n+\t    && !expr->symtree->n.sym->result->attr.proc_pointer)\n \texpr->ts = expr->symtree->n.sym->result->ts;\n     }\n \n@@ -4196,7 +4197,11 @@ resolve_variable (gfc_expr *e)\n     return FAILURE;\n \n   sym = e->symtree->n.sym;\n-  if (sym->attr.flavor == FL_PROCEDURE && !sym->attr.function)\n+  if (sym->attr.flavor == FL_PROCEDURE\n+      && (!sym->attr.function\n+\t  || (sym->attr.function && sym->result\n+\t      && sym->result->attr.proc_pointer\n+\t      && !sym->result->attr.function)))\n     {\n       e->ts.type = BT_PROCEDURE;\n       goto resolve_procedure;\n@@ -8034,18 +8039,41 @@ resolve_fl_procedure (gfc_symbol *sym, int mp_flag)\n \t}\n     }\n   \n-  if (sym->attr.save == SAVE_EXPLICIT && !sym->attr.proc_pointer)\n-    {\n-      gfc_error (\"PROCEDURE attribute conflicts with SAVE attribute \"\n-\t\t \"in '%s' at %L\", sym->name, &sym->declared_at);\n-      return FAILURE;\n-    }\n-\n-  if (sym->attr.intent && !sym->attr.proc_pointer)\n+  if (!sym->attr.proc_pointer)\n     {\n-      gfc_error (\"PROCEDURE attribute conflicts with INTENT attribute \"\n-\t\t \"in '%s' at %L\", sym->name, &sym->declared_at);\n-      return FAILURE;\n+      if (sym->attr.save == SAVE_EXPLICIT)\n+\t{\n+\t  gfc_error (\"PROCEDURE attribute conflicts with SAVE attribute \"\n+\t\t     \"in '%s' at %L\", sym->name, &sym->declared_at);\n+\t  return FAILURE;\n+\t}\n+      if (sym->attr.intent)\n+\t{\n+\t  gfc_error (\"PROCEDURE attribute conflicts with INTENT attribute \"\n+\t\t     \"in '%s' at %L\", sym->name, &sym->declared_at);\n+\t  return FAILURE;\n+\t}\n+      if (sym->attr.subroutine && sym->attr.result)\n+\t{\n+\t  gfc_error (\"PROCEDURE attribute conflicts with RESULT attribute \"\n+\t\t     \"in '%s' at %L\", sym->name, &sym->declared_at);\n+\t  return FAILURE;\n+\t}\n+      if (sym->attr.external && sym->attr.function\n+\t  && ((sym->attr.if_source == IFSRC_DECL && !sym->attr.procedure)\n+\t      || sym->attr.contained))\n+\t{\n+\t  gfc_error (\"EXTERNAL attribute conflicts with FUNCTION attribute \"\n+\t\t     \"in '%s' at %L\", sym->name, &sym->declared_at);\n+\t  return FAILURE;\n+\t}\n+      if (strcmp (\"ppr@\", sym->name) == 0)\n+\t{\n+\t  gfc_error (\"Procedure pointer result '%s' at %L \"\n+\t\t     \"is missing the pointer attribute\",\n+\t\t     sym->ns->proc_name->name, &sym->declared_at);\n+\t  return FAILURE;\n+\t}\n     }\n \n   return SUCCESS;\n@@ -9310,11 +9338,14 @@ resolve_symbol (gfc_symbol *sym)\n \t      /* Result may be in another namespace.  */\n \t      resolve_symbol (sym->result);\n \n-\t      sym->ts = sym->result->ts;\n-\t      sym->as = gfc_copy_array_spec (sym->result->as);\n-\t      sym->attr.dimension = sym->result->attr.dimension;\n-\t      sym->attr.pointer = sym->result->attr.pointer;\n-\t      sym->attr.allocatable = sym->result->attr.allocatable;\n+\t      if (!sym->result->attr.proc_pointer)\n+\t\t{\n+\t\t  sym->ts = sym->result->ts;\n+\t\t  sym->as = gfc_copy_array_spec (sym->result->as);\n+\t\t  sym->attr.dimension = sym->result->attr.dimension;\n+\t\t  sym->attr.pointer = sym->result->attr.pointer;\n+\t\t  sym->attr.allocatable = sym->result->attr.allocatable;\n+\t\t}\n \t    }\n \t}\n     }"}, {"sha": "a4f43a5f6700ebb182ba97f7cc07556fca9495ff", "filename": "gcc/fortran/symbol.c", "status": "modified", "additions": 4, "deletions": 8, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3070bab4c9421f35fd4149a238768befd2717ddb/gcc%2Ffortran%2Fsymbol.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3070bab4c9421f35fd4149a238768befd2717ddb/gcc%2Ffortran%2Fsymbol.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fsymbol.c?ref=3070bab4c9421f35fd4149a238768befd2717ddb", "patch": "@@ -320,7 +320,7 @@ gfc_check_function_type (gfc_namespace *ns)\n \t      proc->attr.allocatable = proc->result->attr.allocatable;\n \t    }\n \t}\n-      else\n+      else if (!proc->result->attr.proc_pointer)\n \t{\n \t  gfc_error (\"Function result '%s' at %L has no IMPLICIT type\",\n \t\t     proc->result->name, &proc->result->declared_at);\n@@ -453,10 +453,7 @@ check_conflict (symbol_attribute *attr, const char *name, locus *where)\n   conf (entry, intrinsic);\n \n   if ((attr->if_source == IFSRC_DECL && !attr->procedure) || attr->contained)\n-    {\n-      conf (external, subroutine);\n-      conf (external, function);\n-    }\n+    conf (external, subroutine);\n \n   conf (allocatable, pointer);\n   conf_std (allocatable, dummy, GFC_STD_F2003);\n@@ -626,14 +623,13 @@ check_conflict (symbol_attribute *attr, const char *name, locus *where)\n       break;\n \n     case FL_PROCEDURE:\n-      /* Conflicts with INTENT will be checked at resolution stage,\n-\t see \"resolve_fl_procedure\".  */\n+      /* Conflicts with INTENT, SAVE and RESULT will be checked\n+\t at resolution stage, see \"resolve_fl_procedure\".  */\n \n       if (attr->subroutine)\n \t{\n \t  conf2 (target);\n \t  conf2 (allocatable);\n-\t  conf2 (result);\n \t  conf2 (in_namelist);\n \t  conf2 (dimension);\n \t  conf2 (function);"}, {"sha": "e83215c068628df50aa120434e9de641a4da9a5a", "filename": "gcc/fortran/trans-types.c", "status": "modified", "additions": 14, "deletions": 3, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3070bab4c9421f35fd4149a238768befd2717ddb/gcc%2Ffortran%2Ftrans-types.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3070bab4c9421f35fd4149a238768befd2717ddb/gcc%2Ffortran%2Ftrans-types.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-types.c?ref=3070bab4c9421f35fd4149a238768befd2717ddb", "patch": "@@ -1616,8 +1616,8 @@ gfc_sym_type (gfc_symbol * sym)\n   tree type;\n   int byref;\n \n-  /* Procedure Pointers inside COMMON blocks or as function result.  */\n-  if (sym->attr.proc_pointer && (sym->attr.in_common || sym->attr.result))\n+  /* Procedure Pointers inside COMMON blocks.  */\n+  if (sym->attr.proc_pointer && sym->attr.in_common)\n     {\n       /* Unset proc_pointer as gfc_get_function_type calls gfc_sym_type.  */\n       sym->attr.proc_pointer = 0;\n@@ -2156,7 +2156,18 @@ gfc_get_function_type (gfc_symbol * sym)\n     }\n   else if (sym->result && sym->result->attr.proc_pointer)\n     /* Procedure pointer return values.  */\n-    type = gfc_sym_type (sym->result);\n+    {\n+      if (sym->result->attr.result && strcmp (sym->name,\"ppr@\") != 0)\n+\t{\n+\t  /* Unset proc_pointer as gfc_get_function_type\n+\t     is called recursively.  */\n+\t  sym->result->attr.proc_pointer = 0;\n+\t  type = build_pointer_type (gfc_get_function_type (sym->result));\n+\t  sym->result->attr.proc_pointer = 1;\n+\t}\n+      else\n+       type = gfc_sym_type (sym->result);\n+    }\n   else\n     type = gfc_sym_type (sym);\n "}, {"sha": "de58d166f2bf0ce0fa5f535bb1e72ca78cb0140e", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3070bab4c9421f35fd4149a238768befd2717ddb/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3070bab4c9421f35fd4149a238768befd2717ddb/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=3070bab4c9421f35fd4149a238768befd2717ddb", "patch": "@@ -1,3 +1,11 @@\n+2009-04-09  Janus Weil  <janus@gcc.gnu.org>\n+\n+\tPR fortran/36704\n+\t* gfortran.dg/external_procedures_1.f90: Modified.\n+\t* gfortran.dg/proc_ptr_result_1.f90: New.\n+\t* gfortran.dg/proc_ptr_result_2.f90: New.\n+\t* gfortran.dg/proc_ptr_result_3.f90: New.\n+\n 2009-04-09  Richard Guenther  <rguenther@suse.de>\n \n \t* gcc.dg/vect/vect-54.c: Make constant input data file-scope"}, {"sha": "de273d52ea0aae02281f1ab8aa8ef3504da99630", "filename": "gcc/testsuite/gfortran.dg/external_procedures_1.f90", "status": "modified", "additions": 11, "deletions": 8, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3070bab4c9421f35fd4149a238768befd2717ddb/gcc%2Ftestsuite%2Fgfortran.dg%2Fexternal_procedures_1.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3070bab4c9421f35fd4149a238768befd2717ddb/gcc%2Ftestsuite%2Fgfortran.dg%2Fexternal_procedures_1.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fexternal_procedures_1.f90?ref=3070bab4c9421f35fd4149a238768befd2717ddb", "patch": "@@ -1,14 +1,17 @@\n ! { dg-do compile }\n+! { dg-options \"-std=f95\" }\n+!\n ! This tests the patch for PR25024.\n \n ! PR25024 - The external attribute for subroutine a would cause an ICE.\n   subroutine A ()\n     EXTERNAL A  ! { dg-error \"EXTERNAL attribute conflicts with SUBROUTINE\" }\n   END\n-function ext (y)\n+\n+function ext (y)  ! { dg-error \"EXTERNAL attribute conflicts with FUNCTION\" }\n   real ext, y\n-  external ext      ! { dg-error \"EXTERNAL attribute conflicts with FUNCTION\" }\n-  ext = y * y\n+  external ext\n+  !ext = y * y\n end function ext\n \n function ext1 (y)\n@@ -24,18 +27,18 @@ program main\n   interface\n     function ext1 (y)\n       real ext1, y\n-      external ext1  ! { dg-error \"Duplicate EXTERNAL attribute\" }\n-    end function ext1\n+      external ext1\n+    end function ext1  ! { dg-error \"Duplicate EXTERNAL attribute\" }\n   end interface\n   inval = 1.0\n   print *, ext(inval)\n   print *, ext1(inval)\n   print *, inv(inval)\n contains\n-  function inv (y)\n+  function inv (y)  ! { dg-error \"EXTERNAL attribute conflicts with FUNCTION\" }\n     real inv, y\n-    external inv     ! { dg-error \"EXTERNAL attribute conflicts with FUNCTION\" }\n-    inv = y * y * y\n+    external inv\n+    !inv = y * y * y\n   end function inv\n end program main\n "}, {"sha": "dc09f04204f5eafd4d226dbaa1eadba4e5d5d998", "filename": "gcc/testsuite/gfortran.dg/proc_ptr_result_1.f90", "status": "added", "additions": 173, "deletions": 0, "changes": 173, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3070bab4c9421f35fd4149a238768befd2717ddb/gcc%2Ftestsuite%2Fgfortran.dg%2Fproc_ptr_result_1.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3070bab4c9421f35fd4149a238768befd2717ddb/gcc%2Ftestsuite%2Fgfortran.dg%2Fproc_ptr_result_1.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fproc_ptr_result_1.f90?ref=3070bab4c9421f35fd4149a238768befd2717ddb", "patch": "@@ -0,0 +1,173 @@\n+! { dg-do run }\n+!\n+! PR 36704: Procedure pointer as function result\n+!\n+! Contributed by Janus Weil <janus@gcc.gnu.org>\n+\n+module mo\n+contains\n+\n+  function j()\n+    procedure(),pointer :: j\n+    intrinsic iabs\n+    j => iabs\n+  end function\n+\n+  subroutine sub(y)\n+    integer,intent(inout) :: y\n+    y = y**2\n+  end subroutine\n+\n+end module\n+\n+\n+program proc_ptr_14\n+use mo\n+implicit none\n+intrinsic :: iabs\n+integer :: x\n+procedure(integer),pointer :: p,p2\n+procedure(sub),pointer :: ps\n+\n+p => a()\n+if (p(-1)/=1) call abort()\n+p => b()\n+if (p(-2)/=2) call abort()\n+p => c()\n+if (p(-3)/=3) call abort()\n+p => d()\n+if (p(-4)/=4) call abort()\n+p => dd()\n+if (p(-4)/=4) call abort()\n+p => e(iabs)\n+if (p(-5)/=5) call abort()\n+p => ee()\n+if (p(-5)/=5) call abort()\n+p => f()\n+if (p(-6)/=6) call abort()\n+p => g()\n+if (p(-7)/=7) call abort()\n+\n+ps => h(sub)\n+x = 2\n+call ps(x)\n+if (x/=4) call abort()\n+\n+p => i()\n+if (p(-8)/=8) call abort()\n+p => j()\n+if (p(-9)/=9) call abort()\n+\n+p => k(p2)\n+if (p(-10)/=p2(-10)) call abort()\n+\n+p => l()\n+if (p(-11)/=11) call abort()\n+\n+contains\n+\n+  function a()\n+    procedure(integer),pointer :: a\n+    a => iabs\n+  end function\n+\n+  function b()\n+    procedure(integer) :: b\n+    pointer :: b\n+    b => iabs\n+  end function\n+\n+  function c()\n+    pointer :: c\n+    procedure(integer) :: c\n+    c => iabs\n+  end function\n+\n+  function d()\n+    pointer :: d\n+    external d\n+    d => iabs\n+  end function\n+\n+  function dd()\n+    pointer :: dd\n+    external :: dd\n+    integer :: dd\n+    dd => iabs\n+  end function\n+\n+  function e(arg)\n+    external :: e,arg\n+    pointer :: e\n+    e => arg\n+  end function\n+\n+  function ee()\n+    integer :: ee\n+    external :: ee\n+    pointer :: ee\n+    ee => iabs\n+  end function\n+\n+  function f()\n+    pointer :: f\n+    interface\n+      integer function f(x)\n+        integer :: x\n+      end function\n+    end interface\n+    f => iabs\n+  end function\n+\n+  function g()\n+    interface\n+      integer function g(x)\n+        integer :: x\n+      end function g\n+    end interface\n+    pointer :: g\n+    g => iabs\n+  end function\n+\n+  function h(arg)\n+    interface\n+      subroutine arg(b)\n+        integer :: b\n+      end subroutine arg\n+    end interface\n+    pointer :: h\n+    interface\n+      subroutine h(a)\n+        integer :: a\n+      end subroutine h\n+    end interface\n+    h => arg\n+  end function\n+\n+  function i()\n+    pointer :: i\n+    interface\n+      function i(x)\n+        integer :: i,x\n+      end function i\n+    end interface\n+    i => iabs\n+  end function\n+\n+  function k(arg)\n+    procedure(),pointer :: k,arg\n+    k => iabs\n+    arg => k\n+  end function\n+\n+  function l()\n+    procedure(iabs),pointer :: l\n+    integer :: i\n+    l => iabs\n+    if (l(-11)/=11) call abort()\n+  end function \n+\n+end\n+\n+! { dg-final { cleanup-modules \"mo\" } }\n+"}, {"sha": "362a1f7f84859c1fb8226e153ab88ed8977aad07", "filename": "gcc/testsuite/gfortran.dg/proc_ptr_result_2.f90", "status": "added", "additions": 62, "deletions": 0, "changes": 62, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3070bab4c9421f35fd4149a238768befd2717ddb/gcc%2Ftestsuite%2Fgfortran.dg%2Fproc_ptr_result_2.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3070bab4c9421f35fd4149a238768befd2717ddb/gcc%2Ftestsuite%2Fgfortran.dg%2Fproc_ptr_result_2.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fproc_ptr_result_2.f90?ref=3070bab4c9421f35fd4149a238768befd2717ddb", "patch": "@@ -0,0 +1,62 @@\n+! { dg-do compile }\n+!\n+! PR 36704: Procedure pointer as function result\n+!\n+! Contributed by Janus Weil <janus@gcc.gnu.org>\n+\n+module proc_ptr_15\n+\n+  interface\n+    function e(x)\n+      real :: x\n+      procedure(), pointer :: e\n+    end function e\n+  end interface\n+\n+  interface\n+    function f(x)\n+      real :: x\n+      external :: f\n+      pointer :: f\n+    end function\n+  end interface\n+\n+  interface\n+    function g(x)\n+      real :: x\n+      pointer :: g\n+      external :: g\n+    end function\n+  end interface\n+\n+contains\n+\n+  subroutine point_fun()\n+    call set_fun(aux)\n+  end subroutine\n+\n+  subroutine set_fun(y)\n+    external :: y\n+  end subroutine\n+\n+  function aux()\n+    external aux\n+    pointer aux\n+    intrinsic sin\n+    aux => sin\n+  end function\n+\n+  function foo(x)\n+    real :: x\n+    interface\n+      subroutine foo(i)  ! { dg-error \"attribute conflicts with\" }\n+        integer :: i\n+      end subroutine\n+    end interface\n+    !pointer :: foo\n+  end function\n+\n+end\n+\n+! { dg-final { cleanup-modules \"proc_ptr_15\" } }\n+"}, {"sha": "a84ff2420bab2604a650f79f0ea49410c07e9171", "filename": "gcc/testsuite/gfortran.dg/proc_ptr_result_3.f90", "status": "added", "additions": 56, "deletions": 0, "changes": 56, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3070bab4c9421f35fd4149a238768befd2717ddb/gcc%2Ftestsuite%2Fgfortran.dg%2Fproc_ptr_result_3.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3070bab4c9421f35fd4149a238768befd2717ddb/gcc%2Ftestsuite%2Fgfortran.dg%2Fproc_ptr_result_3.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fproc_ptr_result_3.f90?ref=3070bab4c9421f35fd4149a238768befd2717ddb", "patch": "@@ -0,0 +1,56 @@\n+!{ dg-do run }\n+!\n+! PR 36704: Procedure pointer as function result\n+!\n+! Original test case from James Van Buskirk.\n+!\n+! Adapted by Janus Weil <janus@gcc.gnu.org>\n+\n+module store_subroutine\n+   implicit none\n+\n+   abstract interface\n+      subroutine sub(i)\n+        integer, intent(inout) :: i\n+      end subroutine sub\n+   end interface\n+\n+   procedure(sub), pointer, private :: psub => NULL()\n+\n+contains\n+\n+   subroutine set_sub(x)\n+      procedure(sub) x\n+      psub => x\n+   end subroutine set_sub\n+\n+   function get_sub()\n+      procedure(sub), pointer :: get_sub\n+      get_sub => psub\n+   end function get_sub\n+\n+end module store_subroutine\n+\n+program test\n+   use store_subroutine\n+   implicit none\n+   procedure(sub), pointer :: qsub\n+   integer :: k = 1\n+\n+   call my_sub(k)\n+   if (k/=3) call abort\n+   qsub => get_sub()\n+   call qsub(k)\n+   if (k/=9) call abort\n+end program test\n+\n+recursive subroutine my_sub(j)\n+   use store_subroutine\n+   implicit none\n+   integer, intent(inout) :: j\n+   j = j*3\n+   call set_sub(my_sub)\n+end subroutine my_sub\n+\n+! { dg-final { cleanup-modules \"store_subroutine\" } }\n+"}]}