{"sha": "d687413849f10f957c782eb4de2a54f3e78a7aae", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDY4NzQxMzg0OWYxMGY5NTdjNzgyZWI0ZGUyYTU0ZjNlNzhhN2FhZQ==", "commit": {"author": {"name": "Kai Tietz", "email": "kai.tietz@onevision.com", "date": "2010-09-29T18:18:38Z"}, "committer": {"name": "Kai Tietz", "email": "ktietz@gcc.gnu.org", "date": "2010-09-29T18:18:38Z"}, "message": "re PR preprocessor/45362 (Dangling reference about saved cpp_macro for push/pop macro)\n\n2010-09-29  Kai Tietz  <kai.tietz@onevision.com>\n\n\tPR preprocessor/45362\n\t* directives.c (cpp_pop_definition): Make static.\n\t(do_pragma_push_macro): Reworked to store text\n\tdefinition.\n\t(do_pragma_pop_macro): Add free text definition.\n\t(cpp_push_definition): Removed.\n\t* include/cpplib.h (cpp_push_definition): Removed.\n\t(cpp_pop_definition): Likewise.\n\t* internal.h (def_pragma_macro): Remove member 'value'\n\tand add new members 'definition', 'line',\n\t'syshdr', 'sued' and 'is_undef'.\n\t* pch.c (_cpp_restore_pushed_macros): Rework to work\n\ton text definition and store additional macro flags.\n\t(_cpp_save_pushed_macros): Likewise.\n\nFrom-SVN: r164729", "tree": {"sha": "a94ac27b289fa25455ae4117a0a74ade6430a227", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a94ac27b289fa25455ae4117a0a74ade6430a227"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d687413849f10f957c782eb4de2a54f3e78a7aae", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d687413849f10f957c782eb4de2a54f3e78a7aae", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d687413849f10f957c782eb4de2a54f3e78a7aae", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d687413849f10f957c782eb4de2a54f3e78a7aae/comments", "author": null, "committer": null, "parents": [{"sha": "a0c6102d2935c97d834296038b1485f8841aa708", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a0c6102d2935c97d834296038b1485f8841aa708", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a0c6102d2935c97d834296038b1485f8841aa708"}], "stats": {"total": 204, "additions": 123, "deletions": 81}, "files": [{"sha": "cabe7ce91a8c5d49f0877708a9b7c3ca37d0335f", "filename": "libcpp/ChangeLog", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d687413849f10f957c782eb4de2a54f3e78a7aae/libcpp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d687413849f10f957c782eb4de2a54f3e78a7aae/libcpp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libcpp%2FChangeLog?ref=d687413849f10f957c782eb4de2a54f3e78a7aae", "patch": "@@ -1,3 +1,20 @@\n+2010-09-29  Kai Tietz  <kai.tietz@onevision.com>\n+\n+\tPR preprocessor/45362\n+\t* directives.c (cpp_pop_definition): Make static.\n+\t(do_pragma_push_macro): Reworked to store text\n+\tdefinition.\n+\t(do_pragma_pop_macro): Add free text definition.\n+\t(cpp_push_definition): Removed.\n+\t* include/cpplib.h (cpp_push_definition): Removed.\n+\t(cpp_pop_definition): Likewise.\n+\t* internal.h (def_pragma_macro): Remove member 'value'\n+\tand add new members 'definition', 'line',\n+\t'syshdr', 'sued' and 'is_undef'.\n+\t* pch.c (_cpp_restore_pushed_macros): Rework to work\n+\ton text definition and store additional macro flags.\n+\t(_cpp_save_pushed_macros): Likewise.\n+\n 2010-09-29  Joseph Myers  <joseph@codesourcery.com>\n \n \t* include/cpplib.h (cpp_options): Rename warn_deprecated,"}, {"sha": "6462605c3f40247f86c1bf92108ebc9492eff9c6", "filename": "libcpp/directives.c", "status": "modified", "additions": 57, "deletions": 28, "changes": 85, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d687413849f10f957c782eb4de2a54f3e78a7aae/libcpp%2Fdirectives.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d687413849f10f957c782eb4de2a54f3e78a7aae/libcpp%2Fdirectives.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libcpp%2Fdirectives.c?ref=d687413849f10f957c782eb4de2a54f3e78a7aae", "patch": "@@ -128,6 +128,7 @@ static struct answer ** find_answer (cpp_hashnode *, const struct answer *);\n static void handle_assertion (cpp_reader *, const char *, int);\n static void do_pragma_push_macro (cpp_reader *);\n static void do_pragma_pop_macro (cpp_reader *);\n+static void cpp_pop_definition (cpp_reader *, struct def_pragma_macro *);\n \n /* This is the table of directive handlers.  It is ordered by\n    frequency of occurrence; the numbers at the end are directive\n@@ -1436,6 +1437,9 @@ do_pragma_once (cpp_reader *pfile)\n static void\n do_pragma_push_macro (cpp_reader *pfile)\n {\n+  cpp_hashnode *node;\n+  size_t defnlen;\n+  const uchar *defn = NULL;\n   char *macroname, *dest;\n   const char *limit, *src;\n   const cpp_token *txt;\n@@ -1465,10 +1469,26 @@ do_pragma_push_macro (cpp_reader *pfile)\n   check_eol (pfile, false);\n   skip_rest_of_line (pfile);\n   c = XNEW (struct def_pragma_macro);\n+  memset (c, 0, sizeof (struct def_pragma_macro));\n   c->name = XNEWVAR (char, strlen (macroname) + 1);\n   strcpy (c->name, macroname);\n   c->next = pfile->pushed_macros;\n-  c->value = cpp_push_definition (pfile, c->name);\n+  node = _cpp_lex_identifier (pfile, c->name);\n+  if (node->type == NT_VOID)\n+    c->is_undef = 1;\n+  else\n+    {\n+      defn = cpp_macro_definition (pfile, node);\n+      defnlen = ustrlen (defn);\n+      c->definition = XNEWVEC (uchar, defnlen + 2);\n+      c->definition[defnlen] = '\\n';\n+      c->definition[defnlen + 1] = 0;\n+      c->line = node->value.macro->line;\n+      c->syshdr = node->value.macro->syshdr;\n+      c->used = node->value.macro->used;\n+      memcpy (c->definition, defn, defnlen);\n+    }\n+\n   pfile->pushed_macros = c;\n }\n \n@@ -1512,7 +1532,8 @@ do_pragma_pop_macro (cpp_reader *pfile)\n \t    pfile->pushed_macros = c->next;\n \t  else\n \t    l->next = c->next;\n-\t  cpp_pop_definition (pfile, c->name, c->value);\n+\t  cpp_pop_definition (pfile, c);\n+\t  free (c->definition);\n \t  free (c->name);\n \t  free (c);\n \t  break;\n@@ -2334,23 +2355,12 @@ cpp_undef (cpp_reader *pfile, const char *macro)\n   run_directive (pfile, T_UNDEF, buf, len);\n }\n \n-/* If STR is a defined macro, return its definition node, else return NULL.  */\n-cpp_macro *\n-cpp_push_definition (cpp_reader *pfile, const char *str)\n-{\n-  cpp_hashnode *node = _cpp_lex_identifier (pfile, str);\n-  if (node && node->type == NT_MACRO)\n-    return node->value.macro;\n-  else\n-    return NULL;\n-}\n-\n-/* Replace a previous definition DFN of the macro STR.  If DFN is NULL,\n-   then the macro should be undefined.  */\n-void\n-cpp_pop_definition (cpp_reader *pfile, const char *str, cpp_macro *dfn)\n+/* Replace a previous definition DEF of the macro STR.  If DEF is NULL,\n+   or first element is zero, then the macro should be undefined.  */\n+static void\n+cpp_pop_definition (cpp_reader *pfile, struct def_pragma_macro *c)\n {\n-  cpp_hashnode *node = _cpp_lex_identifier (pfile, str);\n+  cpp_hashnode *node = _cpp_lex_identifier (pfile, c->name);\n   if (node == NULL)\n     return;\n \n@@ -2367,16 +2377,35 @@ cpp_pop_definition (cpp_reader *pfile, const char *str, cpp_macro *dfn)\n   if (node->type != NT_VOID)\n     _cpp_free_definition (node);\n \n-  if (dfn)\n-    {\n-      node->type = NT_MACRO;\n-      node->value.macro = dfn;\n-      if (! ustrncmp (NODE_NAME (node), DSC (\"__STDC_\")))\n-\tnode->flags |= NODE_WARN;\n-\n-      if (pfile->cb.define)\n-\tpfile->cb.define (pfile, pfile->directive_line, node);\n-    }\n+  if (c->is_undef)\n+    return;\n+  {\n+    size_t namelen;\n+    const uchar *dn;\n+    cpp_hashnode *h = NULL;\n+    cpp_buffer *nbuf;\n+\n+    namelen = ustrcspn (c->definition, \"( \\n\");\n+    h = cpp_lookup (pfile, c->definition, namelen);\n+    dn = c->definition + namelen;\n+\n+    h->type = NT_VOID;\n+    h->flags &= ~(NODE_POISONED|NODE_BUILTIN|NODE_DISABLED|NODE_USED);\n+    nbuf = cpp_push_buffer (pfile, dn, ustrchr (dn, '\\n') - dn, true);\n+    if (nbuf != NULL)\n+      {\n+\t_cpp_clean_line (pfile);\n+\tnbuf->sysp = 1;\n+\tif (!_cpp_create_definition (pfile, h))\n+\t  abort ();\n+\t_cpp_pop_buffer (pfile);\n+      }\n+    else\n+      abort ();\n+    h->value.macro->line = c->line;\n+    h->value.macro->syshdr = c->syshdr;\n+    h->value.macro->used = c->used;\n+  }\n }\n \n /* Process the string STR as if it appeared as the body of a #assert.  */"}, {"sha": "8fa28819bed24c4402f88acff423f688b93beaa5", "filename": "libcpp/include/cpplib.h", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d687413849f10f957c782eb4de2a54f3e78a7aae/libcpp%2Finclude%2Fcpplib.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d687413849f10f957c782eb4de2a54f3e78a7aae/libcpp%2Finclude%2Fcpplib.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libcpp%2Finclude%2Fcpplib.h?ref=d687413849f10f957c782eb4de2a54f3e78a7aae", "patch": "@@ -758,9 +758,6 @@ extern void cpp_assert (cpp_reader *, const char *);\n extern void cpp_undef (cpp_reader *, const char *);\n extern void cpp_unassert (cpp_reader *, const char *);\n \n-extern cpp_macro *cpp_push_definition (cpp_reader *, const char *);\n-extern void cpp_pop_definition (cpp_reader *, const char *, cpp_macro *);\n-\n /* Undefine all macros and assertions.  */\n extern void cpp_undef_all (cpp_reader *);\n "}, {"sha": "d2872c4a11fbf7cb1156506a6f8e5467e5cb8892", "filename": "libcpp/internal.h", "status": "modified", "additions": 11, "deletions": 1, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d687413849f10f957c782eb4de2a54f3e78a7aae/libcpp%2Finternal.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d687413849f10f957c782eb4de2a54f3e78a7aae/libcpp%2Finternal.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libcpp%2Finternal.h?ref=d687413849f10f957c782eb4de2a54f3e78a7aae", "patch": "@@ -313,7 +313,17 @@ struct def_pragma_macro {\n   /* Name of the macro.  */\n   char *name;\n   /* The stored macro content.  */\n-  cpp_macro *value;\n+  unsigned char *definition;\n+\n+  /* Definition line number.  */\n+  source_location line;\n+  /* If macro defined in system header.  */\n+  unsigned int syshdr   : 1;\n+  /* Nonzero if it has been expanded or had its existence tested.  */\n+  unsigned int used     : 1;\n+\n+  /* Mark if we save an undefined macro.  */\n+  unsigned int is_undef : 1;\n };\n \n /* A cpp_reader encapsulates the \"state\" of a pre-processor run."}, {"sha": "653e5c96adfbd1414f443023d3047a2c1406d109", "filename": "libcpp/pch.c", "status": "modified", "additions": 38, "deletions": 49, "changes": 87, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d687413849f10f957c782eb4de2a54f3e78a7aae/libcpp%2Fpch.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d687413849f10f957c782eb4de2a54f3e78a7aae/libcpp%2Fpch.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libcpp%2Fpch.c?ref=d687413849f10f957c782eb4de2a54f3e78a7aae", "patch": "@@ -399,8 +399,6 @@ _cpp_restore_pushed_macros (cpp_reader *r, FILE *f)\n   size_t i;\n   struct def_pragma_macro *p;\n   size_t nlen;\n-  cpp_hashnode *h = NULL;\n-  cpp_macro *m;\n   uchar *defn;\n   size_t defnlen;\n \n@@ -413,49 +411,35 @@ _cpp_restore_pushed_macros (cpp_reader *r, FILE *f)\n       if (fread (&nlen, sizeof (nlen), 1, f) != 1)\n \treturn 0;\n       p = XNEW (struct def_pragma_macro);\n+      memset (p, 0, sizeof (struct def_pragma_macro));\n       p->name = XNEWVAR (char, nlen + 1);\n       p->name[nlen] = 0;\n       if (fread (p->name, nlen, 1, f) != 1)\n \treturn 0;\n-      /* Save old state.  */\n-      m = cpp_push_definition (r, p->name);\n       if (fread (&defnlen, sizeof (defnlen), 1, f) != 1)\n \treturn 0;\n-      defn = XNEWVAR (uchar, defnlen + 2);\n-      defn[defnlen] = '\\n';\n-      defn[defnlen + 1] = 0;\n-\n-      if (fread (defn, defnlen, 1, f) != 1)\n-\treturn 0;\n-      cpp_pop_definition (r, p->name, NULL);\n-      {\n-\tsize_t namelen;\n-\tuchar *dn;\n+      if (defnlen == 0)\n+        p->is_undef = 1;\n+      else\n+        {\n+\t  defn = XNEWVEC (uchar, defnlen + 1);\n+\t  defn[defnlen] = 0;\n \n-\tnamelen = ustrcspn (defn, \"( \\n\");\n-\th = cpp_lookup (r, defn, namelen);\n-\tdn = defn + namelen;\n+\t  if (fread (defn, defnlen, 1, f) != 1)\n+\t    return 0;\n \n-\th->type = NT_VOID;\n-\th->flags &= ~(NODE_POISONED|NODE_BUILTIN|NODE_DISABLED|NODE_USED);\n-\tif (cpp_push_buffer (r, dn, ustrchr (dn, '\\n') - dn, true)\n-\t    != NULL)\n-\t  {\n-\t    _cpp_clean_line (r);\n-\t    if (!_cpp_create_definition (r, h))\n-\t      abort ();\n-\t    _cpp_pop_buffer (r);\n-\t  }\n-\telse\n-\t  abort ();\n-      }\n-      p->value = cpp_push_definition (r, p->name);\n+\t  p->definition = defn;\n+\t  if (fread (&(p->line), sizeof (source_location), 1, f) != 1)\n+\t    return 0;\n+\t  defnlen = 0;\n+\t  if (fread (&defnlen, sizeof (defnlen), 1, f) != 1)\n+\t    return 0;\n+\t  p->syshdr = ((defnlen & 1) != 0 ? 1 : 0);\n+\t  p->used =  ((defnlen & 2) != 0 ? 1 : 0);\n+\t}\n \n-      free (defn);\n       p->next = r->pushed_macros;\n       r->pushed_macros = p;\n-      /* Restore current state.  */\n-      cpp_pop_definition (r, p->name, m);\n     }\n   return 1;\n }\n@@ -466,10 +450,7 @@ _cpp_save_pushed_macros (cpp_reader *r, FILE *f)\n   size_t count_saved = 0;\n   size_t i;\n   struct def_pragma_macro *p,**pp;\n-  cpp_hashnode *node;\n-  cpp_macro *m;\n   size_t defnlen;\n-  const uchar *defn;\n \n   /* Get count. */\n   p = r->pushed_macros;\n@@ -496,22 +477,30 @@ _cpp_save_pushed_macros (cpp_reader *r, FILE *f)\n     }\n   for (i = 0; i < count_saved; i++)\n     {\n-      /* Save old state.  */\n-      m = cpp_push_definition (r, pp[i]->name);\n-      /* Set temporary macro name to saved state.  */\n-      cpp_pop_definition (r, pp[i]->name, pp[i]->value);\n-      node = _cpp_lex_identifier (r, pp[i]->name);\n       defnlen = strlen (pp[i]->name);\n       if (fwrite (&defnlen, sizeof (size_t), 1, f) != 1\n \t  || fwrite (pp[i]->name, defnlen, 1, f) != 1)\n \treturn 0;\n-      defn = cpp_macro_definition (r, node);\n-      defnlen = ustrlen (defn);\n-      if (fwrite (&defnlen, sizeof (size_t), 1, f) != 1\n-\t  || fwrite (defn, defnlen, 1, f) != 1)\n-\treturn 0;\n-      /* Restore current state.  */\n-      cpp_pop_definition (r, pp[i]->name, m);\n+      if (pp[i]->is_undef)\n+\t{\n+\t  defnlen = 0;\n+\t  if (fwrite (&defnlen, sizeof (size_t), 1, f) != 1)\n+\t    return 0;\n+\t}\n+      else\n+        {\n+\t  defnlen = ustrlen (pp[i]->definition);\n+\t  if (fwrite (&defnlen, sizeof (size_t), 1, f) != 1\n+\t      || fwrite (pp[i]->definition, defnlen, 1, f) != 1)\n+\t    return 0;\n+\t  if (fwrite (&(pp[i]->line), sizeof (source_location), 1, f) != 1)\n+\t    return 0;\n+\t  defnlen = 0;\n+\t  defnlen |= (pp[i]->syshdr != 0 ? 1 : 0);\n+\t  defnlen |= (pp[i]->used != 0 ? 2 : 0);\n+\t  if (fwrite (&defnlen, sizeof (defnlen), 1, f) != 1)\n+\t    return 0;\n+\t}\n     }\n   return 1;\n }"}]}