{"sha": "eb8b347423582a66758699748ffc3c499f6bdde2", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZWI4YjM0NzQyMzU4MmE2Njc1ODY5OTc0OGZmYzNjNDk5ZjZiZGRlMg==", "commit": {"author": {"name": "Alexandre Oliva", "email": "aoliva@redhat.com", "date": "2017-12-12T02:15:44Z"}, "committer": {"name": "Alexandre Oliva", "email": "aoliva@gcc.gnu.org", "date": "2017-12-12T02:15:44Z"}, "message": "[SFN] stabilize find_bb_boundaries\n\nIf find_bb_boundaries is given a block with zero or one nondebug insn\nbeside debug insns, it shouldn't purge dead edges, because without\ndebug insns we wouldn't purge them at that point.  Doing so may change\nthe order in which edges are processed, and ultimately lead to\ndifferent transformations to the CFG and then to different\noptimizations.\n\nWe shouldn't, however, retain debug insns after control flow insns, so\nif we find debug insns after a single insn that happens to be a\ncontrol flow insn, do the debug insn cleanups, but still refrain from\npurging dead edges at that point.\n\n\nfor  gcc/ChangeLog\n\n\t* cfgbuild.c (find_bb_boundaries): Don't purge dead edges if,\n\twithout debug insns, we wouldn't, but clean up debug insns\n\tafter a control flow insn nevertheless.\n\nFrom-SVN: r255567", "tree": {"sha": "95241bed540bcd201bd588ac089b1c96ac706147", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/95241bed540bcd201bd588ac089b1c96ac706147"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/eb8b347423582a66758699748ffc3c499f6bdde2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/eb8b347423582a66758699748ffc3c499f6bdde2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/eb8b347423582a66758699748ffc3c499f6bdde2", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/eb8b347423582a66758699748ffc3c499f6bdde2/comments", "author": null, "committer": null, "parents": [{"sha": "65f4b8759bda30d63404acb381b24a2ec960e667", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/65f4b8759bda30d63404acb381b24a2ec960e667", "html_url": "https://github.com/Rust-GCC/gccrs/commit/65f4b8759bda30d63404acb381b24a2ec960e667"}], "stats": {"total": 44, "additions": 43, "deletions": 1}, "files": [{"sha": "3c1add62c94470c6c0396a7ec5b12e47cf09c572", "filename": "gcc/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eb8b347423582a66758699748ffc3c499f6bdde2/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eb8b347423582a66758699748ffc3c499f6bdde2/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=eb8b347423582a66758699748ffc3c499f6bdde2", "patch": "@@ -1,5 +1,9 @@\n 2017-12-12  Alexandre Oliva <aoliva@redhat.com>\n \n+\t* cfgbuild.c (find_bb_boundaries): Don't purge dead edges if,\n+\twithout debug insns, we wouldn't, but clean up debug insns\n+\tafter a control flow insn nevertheless.\n+\n \t* cfgcleanup.c (delete_unreachable_blocks): Use alternate\n \tblock removal order if MAY_HAVE_DEBUG_BIND_INSNS.\n \t* cfgexpand.c (label_rtx_for_bb): Skip debug insns."}, {"sha": "7b57589f1dfac4019445e2d332b8add2a3042e5f", "filename": "gcc/cfgbuild.c", "status": "modified", "additions": 39, "deletions": 1, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eb8b347423582a66758699748ffc3c499f6bdde2/gcc%2Fcfgbuild.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eb8b347423582a66758699748ffc3c499f6bdde2/gcc%2Fcfgbuild.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgbuild.c?ref=eb8b347423582a66758699748ffc3c499f6bdde2", "patch": "@@ -444,10 +444,43 @@ find_bb_boundaries (basic_block bb)\n   rtx_insn *flow_transfer_insn = NULL;\n   rtx_insn *debug_insn = NULL;\n   edge fallthru = NULL;\n+  bool skip_purge;\n \n   if (insn == end)\n     return;\n \n+  if (DEBUG_INSN_P (insn) || DEBUG_INSN_P (end))\n+    {\n+      /* Check whether, without debug insns, the insn==end test above\n+\t would have caused us to return immediately, and behave the\n+\t same way even with debug insns.  If we don't do this, debug\n+\t insns could cause us to purge dead edges at different times,\n+\t which could in turn change the cfg and affect codegen\n+\t decisions in subtle but undesirable ways.  */\n+      while (insn != end && DEBUG_INSN_P (insn))\n+\tinsn = NEXT_INSN (insn);\n+      rtx_insn *e = end;\n+      while (insn != e && DEBUG_INSN_P (e))\n+\te = PREV_INSN (e);\n+      if (insn == e)\n+\t{\n+\t  /* If there are debug insns after a single insn that is a\n+\t     control flow insn in the block, we'd have left right\n+\t     away, but we should clean up the debug insns after the\n+\t     control flow insn, because they can't remain in the same\n+\t     block.  So, do the debug insn cleaning up, but then bail\n+\t     out without purging dead edges as we would if the debug\n+\t     insns hadn't been there.  */\n+\t  if (e != end && !DEBUG_INSN_P (e) && control_flow_insn_p (e))\n+\t    {\n+\t      skip_purge = true;\n+\t      flow_transfer_insn = e;\n+\t      goto clean_up_debug_after_control_flow;\n+\t    }\n+\t  return;\n+\t}\n+    }\n+\n   if (LABEL_P (insn))\n     insn = NEXT_INSN (insn);\n \n@@ -475,7 +508,6 @@ find_bb_boundaries (basic_block bb)\n \t  if (debug_insn && code != CODE_LABEL && code != BARRIER)\n \t    prev = PREV_INSN (debug_insn);\n \t  fallthru = split_block (bb, prev);\n-\n \t  if (flow_transfer_insn)\n \t    {\n \t      BB_END (bb) = flow_transfer_insn;\n@@ -527,6 +559,9 @@ find_bb_boundaries (basic_block bb)\n      ordinary jump, we need to take care and move basic block boundary.  */\n   if (flow_transfer_insn && flow_transfer_insn != end)\n     {\n+      skip_purge = false;\n+\n+    clean_up_debug_after_control_flow:\n       BB_END (bb) = flow_transfer_insn;\n \n       /* Clean up the bb field for the insns that do not belong to BB.  */\n@@ -543,6 +578,9 @@ find_bb_boundaries (basic_block bb)\n \t  if (x == end)\n \t    break;\n \t}\n+\n+      if (skip_purge)\n+\treturn;\n     }\n \n   /* We've possibly replaced the conditional jump by conditional jump"}]}