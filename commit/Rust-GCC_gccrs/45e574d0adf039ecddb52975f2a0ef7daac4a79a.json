{"sha": "45e574d0adf039ecddb52975f2a0ef7daac4a79a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDVlNTc0ZDBhZGYwMzllY2RkYjUyOTc1ZjJhMGVmN2RhYWM0YTc5YQ==", "commit": {"author": {"name": "John David Anglin", "email": "danglin@gcc.gnu.org", "date": "2002-07-23T17:43:01Z"}, "committer": {"name": "John David Anglin", "email": "danglin@gcc.gnu.org", "date": "2002-07-23T17:43:01Z"}, "message": "real.c (REAL_WORDS_BIG_ENDIAN): Make 1 for DEC.\n\n\t* real.c (REAL_WORDS_BIG_ENDIAN): Make 1 for DEC.\n\t(LARGEST_EXPONENT_IS_NORMAL): Ditto.\n\t(VAX_HALFWORD_ORDER): Define (1 for DEC VAX, 0 otherwise).\n\t(TARGET_G_FLOAT): Default to 0 if not defined.\n\t(ieeetoe): New, common routine to convert target format floats\n\tto internal form.\n\t(e24toe, e53toe): Change to use ieeetoe, distinguish DEC\n\tvs. others.\n\t(e113toe): Change to use ieeetoe.\n\t(REAL_WORDS_BIG_ENDIAN): Make sure it is 0 for DEC and 1 for\n\tIBM.\n\t(e53toe): Assume IEEE if non of DEC, IBM and C4X is defined.\n\t(e64toe): Remove special cases for DEC and IBM. Remove support for\n\tARM_EXTENDED_IEEE_FORMAT.\n\t(e24toe): Remove special cases for DEC.\n\t(significand_size): Simplify. Indent.\n\t(ieee_format, ieee_24, ieee_53, ieee_64, ieee_113): New.\n\t(etoieee, toieee): New.\n\t(etoe113, toe113, etoe64, toe64, etoe53, toe53, etoe24, toe24): Use\n\tetoieee and toieee for IEEE arithmetic.\n\nFrom-SVN: r55683", "tree": {"sha": "6a0f04a2216b011ed8487563e27e0bb88ec8829e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6a0f04a2216b011ed8487563e27e0bb88ec8829e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/45e574d0adf039ecddb52975f2a0ef7daac4a79a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/45e574d0adf039ecddb52975f2a0ef7daac4a79a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/45e574d0adf039ecddb52975f2a0ef7daac4a79a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/45e574d0adf039ecddb52975f2a0ef7daac4a79a/comments", "author": null, "committer": null, "parents": [{"sha": "b5dec7da321cf2c08c4088ef91afdbe158cde2b3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b5dec7da321cf2c08c4088ef91afdbe158cde2b3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b5dec7da321cf2c08c4088ef91afdbe158cde2b3"}], "stats": {"total": 1226, "additions": 483, "deletions": 743}, "files": [{"sha": "caed89593bca19e196c3a6d2832152f7ec00600e", "filename": "gcc/ChangeLog", "status": "modified", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/45e574d0adf039ecddb52975f2a0ef7daac4a79a/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/45e574d0adf039ecddb52975f2a0ef7daac4a79a/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=45e574d0adf039ecddb52975f2a0ef7daac4a79a", "patch": "@@ -1,3 +1,29 @@\n+2002-07-23\tPaul Koning\t<pkoning@equallogic.com>\n+\n+\t* real.c (REAL_WORDS_BIG_ENDIAN): Make 1 for DEC.\n+\t(LARGEST_EXPONENT_IS_NORMAL): Ditto.\n+\t(VAX_HALFWORD_ORDER): Define (1 for DEC VAX, 0 otherwise).\n+\t(TARGET_G_FLOAT): Default to 0 if not defined.\n+\t(ieeetoe): New, common routine to convert target format floats \n+\tto internal form.\n+\t(e24toe, e53toe): Change to use ieeetoe, distinguish DEC\n+\tvs. others.\n+\t(e113toe): Change to use ieeetoe.\n+\n+2002-07-23  Roman Lechtchinsky  <rl@cs.tu-berlin.de>\n+\n+\t* real.c (REAL_WORDS_BIG_ENDIAN): Make sure it is 0 for DEC and 1 for\n+\tIBM.\n+\t(e53toe): Assume IEEE if non of DEC, IBM and C4X is defined.\n+\t(e64toe): Remove special cases for DEC and IBM. Remove support for\n+\tARM_EXTENDED_IEEE_FORMAT.\n+\t(e24toe): Remove special cases for DEC.\n+\t(significand_size): Simplify. Indent.\n+\t(ieee_format, ieee_24, ieee_53, ieee_64, ieee_113): New.\n+\t(etoieee, toieee): New.\n+\t(etoe113, toe113, etoe64, toe64, etoe53, toe53, etoe24, toe24): Use\n+\tetoieee and toieee for IEEE arithmetic.\n+\n 2002-07-23  Gabriel Dos Reis  <gdr@nerim.net>\n \n \t* doc/extend.texi: Say ISO C90, not ISO C89."}, {"sha": "4dcd0363534278f96a78b3ce3546d73b3dd41be9", "filename": "gcc/real.c", "status": "modified", "additions": 457, "deletions": 743, "changes": 1200, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/45e574d0adf039ecddb52975f2a0ef7daac4a79a/gcc%2Freal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/45e574d0adf039ecddb52975f2a0ef7daac4a79a/gcc%2Freal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freal.c?ref=45e574d0adf039ecddb52975f2a0ef7daac4a79a", "patch": "@@ -129,6 +129,31 @@ unknown arithmetic type\n \n #define REAL_WORDS_BIG_ENDIAN FLOAT_WORDS_BIG_ENDIAN\n \n+/* Make sure that the endianness is correct for IBM and DEC. */\n+#if defined(DEC)\n+#undef LARGEST_EXPONENT_IS_NORMAL\n+#define LARGEST_EXPONENT_IS_NORMAL(x) 1\n+#undef REAL_WORDS_BIG_ENDIAN\n+/* Strangely enough, DEC float most closely resembles big endian IEEE */\n+#define REAL_WORDS_BIG_ENDIAN 1\n+/* ... but the halfwords are reversed from IEEE big endian. */\n+#ifndef VAX_HALFWORD_ORDER\n+#define VAX_HALFWORD_ORDER 1\n+#endif\n+#else\n+#if defined(IBM) && !REAL_WORDS_BIG_ENDIAN\n+  #error \"Little-endian representations are not supported for IBM.\"\n+#endif\n+#endif\n+\n+#if defined(DEC) && !defined (TARGET_G_FLOAT)\n+#define TARGET_G_FLOAT 0\n+#endif\n+\n+#ifndef VAX_HALFWORD_ORDER\n+#define VAX_HALFWORD_ORDER 0\n+#endif\n+\n /* Define INFINITY for support of infinity.\n    Define NANS for support of Not-a-Number's (NaN's).  */\n #if !defined(DEC) && !defined(IBM) && !defined(C4X)\n@@ -276,6 +301,106 @@ struct compile_test_dummy {\n #define CHARMASK 0x7f\n #endif\n \n+/* Information about the various IEEE precisions. At the moment, we only\n+   support exponents of 15 bits or less.  */\n+struct ieee_format\n+{\n+  /* Precision.  */\n+  int precision;\n+\n+  /* Size of the exponent in bits.  */\n+  int expbits;\n+\n+  /* Overall size of the value in bits.  */\n+  int bits;\n+\n+  /* Mode used for representing the value.  */\n+  enum machine_mode mode;\n+\n+  /* Exponent adjustment for offsets.  */\n+  EMULONG adjustment;\n+};\n+\n+/* IEEE float (24 bits).  */\n+static const struct ieee_format ieee_24 =\n+{\n+  24,\n+  8,\n+  32,\n+  SFmode,\n+  EXONE - 0x7f\n+};\n+\n+/* IEEE double (53 bits).  */\n+static const struct ieee_format ieee_53 =\n+{\n+  53,\n+  11,\n+  64,\n+  DFmode,\n+  EXONE - 0x3ff\n+};\n+\n+/* IEEE extended double (64 bits).  */\n+static const struct ieee_format ieee_64 =\n+{\n+  64,\n+  15,\n+  80,\n+  XFmode,\n+  0\n+};\n+\n+/* IEEE long double (113 bits).  */\n+static const struct ieee_format ieee_113 =\n+{\n+  113,\n+  15,\n+  128,\n+  TFmode,\n+  0\n+};\n+\n+/* DEC F float (24 bits).  */\n+static const struct ieee_format dec_f =\n+{\n+  24,\n+  8,\n+  32,\n+  SFmode,\n+  EXONE - 0201\n+};\n+\n+/* DEC D float (56 bits).  */\n+static const struct ieee_format dec_d =\n+{\n+  56,\n+  8,\n+  64,\n+  DFmode,\n+  EXONE - 0201\n+};\n+\n+/* DEC G float (53 bits).  */\n+static const struct ieee_format dec_g =\n+{\n+  53,\n+  11,\n+  64,\n+  DFmode,\n+  EXONE - 1025\n+};\n+\n+/* DEC H float (113 bits).  (not yet used) */\n+static const struct ieee_format dec_h =\n+{\n+  113,\n+  15,\n+  128,\n+  TFmode,\n+  EXONE - 16385\n+};\n+\n extern int extra_warnings;\n extern const UEMUSHORT ezero[NE], ehalf[NE], eone[NE], etwo[NE];\n extern const UEMUSHORT elog2[NE], esqrt2[NE];\n@@ -350,6 +475,12 @@ static void etoe53\tPARAMS ((const UEMUSHORT *, UEMUSHORT *));\n static void toe53\tPARAMS ((UEMUSHORT *, UEMUSHORT *));\n static void etoe24\tPARAMS ((const UEMUSHORT *, UEMUSHORT *));\n static void toe24\tPARAMS ((UEMUSHORT *, UEMUSHORT *));\n+static void ieeetoe\tPARAMS ((const UEMUSHORT *, UEMUSHORT *,\n+\t\t\t\t const struct ieee_format *));\n+static void etoieee\tPARAMS ((const UEMUSHORT *, UEMUSHORT *,\n+\t\t\t\t const struct ieee_format *));\n+static void toieee\tPARAMS ((UEMUSHORT *, UEMUSHORT *,\n+\t\t\t\t const struct ieee_format *));\n static int ecmp\t\tPARAMS ((const UEMUSHORT *, const UEMUSHORT *));\n #if 0\n static void eround\tPARAMS ((const UEMUSHORT *, UEMUSHORT *));\n@@ -430,7 +561,7 @@ endian (e, x, mode)\n {\n   unsigned long th, t;\n \n-  if (REAL_WORDS_BIG_ENDIAN)\n+  if (REAL_WORDS_BIG_ENDIAN && !VAX_HALFWORD_ORDER)\n     {\n       switch (mode)\n \t{\n@@ -3072,90 +3203,9 @@ e53toe (pe, y)\n   c4xtoe (pe, y, HFmode);\n \n #else\n-  UEMUSHORT r;\n-  const UEMUSHORT *e;\n-  UEMUSHORT *p;\n-  UEMUSHORT yy[NI];\n-  int denorm, k;\n-\n-  e = pe;\n-  denorm = 0;\t\t\t/* flag if denormalized number */\n-  ecleaz (yy);\n-  if (! REAL_WORDS_BIG_ENDIAN)\n-    e += 3;\n-  r = *e;\n-  yy[0] = 0;\n-  if (r & 0x8000)\n-    yy[0] = 0xffff;\n-  yy[M] = (r & 0x0f) | 0x10;\n-  r &= ~0x800f;\t\t\t/* strip sign and 4 significand bits */\n-#ifdef INFINITY\n-  if (r == 0x7ff0)\n-    {\n-#ifdef NANS\n-      if (! REAL_WORDS_BIG_ENDIAN)\n-\t{\n-\t  if (((pe[3] & 0xf) != 0) || (pe[2] != 0)\n-\t      || (pe[1] != 0) || (pe[0] != 0))\n-\t    {\n-\t      enan (y, yy[0] != 0);\n-\t      return;\n-\t    }\n-\t}\n-      else\n-\t{\n-\t  if (((pe[0] & 0xf) != 0) || (pe[1] != 0)\n-\t      || (pe[2] != 0) || (pe[3] != 0))\n-\t    {\n-\t      enan (y, yy[0] != 0);\n-\t      return;\n-\t    }\n-\t}\n-#endif  /* NANS */\n-      eclear (y);\n-      einfin (y);\n-      if (yy[0])\n-\teneg (y);\n-      return;\n-    }\n-#endif  /* INFINITY */\n-  r >>= 4;\n-  /* If zero exponent, then the significand is denormalized.\n-     So take back the understood high significand bit.  */\n \n-  if (r == 0)\n-    {\n-      denorm = 1;\n-      yy[M] &= ~0x10;\n-    }\n-  r += EXONE - 01777;\n-  yy[E] = r;\n-  p = &yy[M + 1];\n-#ifdef IEEE\n-  if (! REAL_WORDS_BIG_ENDIAN)\n-    {\n-      *p++ = *(--e);\n-      *p++ = *(--e);\n-      *p++ = *(--e);\n-    }\n-  else\n-    {\n-      ++e;\n-      *p++ = *e++;\n-      *p++ = *e++;\n-      *p++ = *e++;\n-    }\n-#endif\n-  eshift (yy, -5);\n-  if (denorm)\n-    {\n-\t/* If zero exponent, then normalize the significand.  */\n-      if ((k = enormlz (yy)) > NBITS)\n-\tecleazs (yy);\n-      else\n-\tyy[E] -= (UEMUSHORT) (k - 1);\n-    }\n-  emovo (yy, y);\n+  ieeetoe (pe, y, &ieee_53);\n+  \n #endif /* not C4X */\n #endif /* not IBM */\n #endif /* not DEC */\n@@ -3177,24 +3227,15 @@ e64toe (pe, y)\n   p = yy;\n   for (i = 0; i < NE - 5; i++)\n     *p++ = 0;\n-/* This precision is not ordinarily supported on DEC or IBM.  */\n-#ifdef DEC\n-  for (i = 0; i < 5; i++)\n-    *p++ = *e++;\n-#endif\n-#ifdef IBM\n-  p = &yy[0] + (NE - 1);\n-  *p-- = *e++;\n-  ++e;\n-  for (i = 0; i < 5; i++)\n-    *p-- = *e++;\n-#endif\n-#ifdef IEEE\n+#ifndef C4X\n+  /* REAL_WORDS_BIG_ENDIAN is always 0 for DEC and 1 for IBM.\n+     This precision is not ordinarily supported on DEC or IBM.  */\n   if (! REAL_WORDS_BIG_ENDIAN)\n     {\n       for (i = 0; i < 5; i++)\n \t*p++ = *e++;\n \n+#ifdef IEEE\n       /* For denormal long double Intel format, shift significand up one\n \t -- but only if the top significand bit is zero.  A top bit of 1\n \t is \"pseudodenormal\" when the exponent is zero.  */\n@@ -3207,22 +3248,17 @@ e64toe (pe, y)\n \t  emovo (temp,y);\n \t  return;\n \t}\n+#endif /* IEEE */\n     }\n   else\n     {\n       p = &yy[0] + (NE - 1);\n-#ifdef ARM_EXTENDED_IEEE_FORMAT\n-      /* For ARMs, the exponent is in the lowest 15 bits of the word.  */\n-      *p-- = (e[0] & 0x8000) | (e[1] & 0x7ffff);\n-      e += 2;\n-#else\n       *p-- = *e++;\n       ++e;\n-#endif\n       for (i = 0; i < 4; i++)\n \t*p-- = *e++;\n     }\n-#endif\n+#endif  /* not C4X */\n #ifdef INFINITY\n   /* Point to the exponent field and check max exponent cases.  */\n   p = &yy[NE - 1];\n@@ -3244,16 +3280,6 @@ e64toe (pe, y)\n \t}\n       else\n \t{\n-#ifdef ARM_EXTENDED_IEEE_FORMAT\n-\t  for (i = 2; i <= 5; i++)\n-\t    {\n-\t      if (pe[i] != 0)\n-\t\t{\n-\t\t  enan (y, (*p & 0x8000) != 0);\n-\t\t  return;\n-\t\t}\n-\t    }\n-#else /* not ARM */\n \t  /* In Motorola extended precision format, the most significant\n \t     bit of an infinity mantissa could be either 1 or 0.  It is\n \t     the lower order bits that tell whether the value is a NaN.  */\n@@ -3269,7 +3295,6 @@ e64toe (pe, y)\n \t\t  return;\n \t\t}\n \t    }\n-#endif /* not ARM */\n \t}\n #endif /* NANS */\n       eclear (y);\n@@ -3293,86 +3318,9 @@ e113toe (pe, y)\n      const UEMUSHORT *pe;\n      UEMUSHORT *y;\n {\n-  UEMUSHORT r;\n-  const UEMUSHORT *e;\n-  UEMUSHORT *p;\n-  UEMUSHORT yy[NI];\n-  int denorm, i;\n-\n-  e = pe;\n-  denorm = 0;\n-  ecleaz (yy);\n-#ifdef IEEE\n-  if (! REAL_WORDS_BIG_ENDIAN)\n-    e += 7;\n-#endif\n-  r = *e;\n-  yy[0] = 0;\n-  if (r & 0x8000)\n-    yy[0] = 0xffff;\n-  r &= 0x7fff;\n-#ifdef INFINITY\n-  if (r == 0x7fff)\n-    {\n-#ifdef NANS\n-      if (! REAL_WORDS_BIG_ENDIAN)\n-\t{\n-\t  for (i = 0; i < 7; i++)\n-\t    {\n-\t      if (pe[i] != 0)\n-\t\t{\n-\t\t  enan (y, yy[0] != 0);\n-\t\t  return;\n-\t\t}\n-\t    }\n-\t}\n-      else\n-\t{\n-\t  for (i = 1; i < 8; i++)\n-\t    {\n-\t      if (pe[i] != 0)\n-\t\t{\n-\t\t  enan (y, yy[0] != 0);\n-\t\t  return;\n-\t\t}\n-\t    }\n-\t}\n-#endif /* NANS */\n-      eclear (y);\n-      einfin (y);\n-      if (yy[0])\n-\teneg (y);\n-      return;\n-    }\n-#endif  /* INFINITY */\n-  yy[E] = r;\n-  p = &yy[M + 1];\n-#ifdef IEEE\n-  if (! REAL_WORDS_BIG_ENDIAN)\n-    {\n-      for (i = 0; i < 7; i++)\n-\t*p++ = *(--e);\n-    }\n-  else\n-    {\n-      ++e;\n-      for (i = 0; i < 7; i++)\n-\t*p++ = *e++;\n-    }\n-#endif\n-/* If denormal, remove the implied bit; else shift down 1.  */\n-  if (r == 0)\n-    {\n-      yy[M] = 0;\n-    }\n-  else\n-    {\n-      yy[M] = 1;\n-      eshift (yy, -1);\n-    }\n-  emovo (yy, y);\n+  ieeetoe (pe, y, &ieee_113);\n }\n-#endif\n+#endif  /* INTEL_EXTENDED_IEEE_FORMAT == 0 */\n \n /* Convert single precision float PE to e type Y.  */\n \n@@ -3392,91 +3340,129 @@ e24toe (pe, y)\n   c4xtoe (pe, y, QFmode);\n \n #else\n+#ifdef DEC\n+\n+  ieeetoe (pe, y, &dec_f);\n+  \n+#else\n+\n+  ieeetoe (pe, y, &ieee_24);\n+\n+#endif /* not DEC */\n+#endif /* not C4X */\n+#endif /* not IBM */\n+}\n+\n+/* Convert machine format float of specified format PE to e type Y.  */\n \n+static void\n+ieeetoe (pe, y, fmt)\n+     const UEMUSHORT *pe;\n+     UEMUSHORT *y;\n+     const struct ieee_format *fmt;\n+{\n   UEMUSHORT r;\n   const UEMUSHORT *e;\n   UEMUSHORT *p;\n   UEMUSHORT yy[NI];\n-  int denorm, k;\n-\n+  int denorm, i, k;\n+  int shortsm1 = fmt->bits / 16 - 1;\n+#ifdef INFINITY\n+  int expmask = (1 << fmt->expbits) - 1;\n+#endif\n+int expshift = (fmt->precision - 1) & 0x0f;\n+  int highbit = 1 << expshift;\n+  \n   e = pe;\n-  denorm = 0;\t\t\t/* flag if denormalized number */\n+  denorm = 0;\n   ecleaz (yy);\n-#ifdef IEEE\n   if (! REAL_WORDS_BIG_ENDIAN)\n-    e += 1;\n-#endif\n-#ifdef DEC\n-  e += 1;\n-#endif\n+    e += shortsm1;\n   r = *e;\n   yy[0] = 0;\n   if (r & 0x8000)\n     yy[0] = 0xffff;\n-  yy[M] = (r & 0x7f) | 0200;\n-  r &= ~0x807f;\t\t\t/* strip sign and 7 significand bits */\n+  yy[M] = (r & (highbit - 1)) | highbit;\n+  r = (r & 0x7fff) >> expshift;\n #ifdef INFINITY\n-  if (!LARGEST_EXPONENT_IS_NORMAL (32) && r == 0x7f80)\n+  if (!LARGEST_EXPONENT_IS_NORMAL (fmt->precision) && r == expmask)\n     {\n #ifdef NANS\n-      if (REAL_WORDS_BIG_ENDIAN)\n+      /* First check the word where high order mantissa and exponent live */\n+      if ((*e & (highbit - 1)) != 0)\n+\t{\n+\t  enan (y, yy[0] != 0);\n+\t  return;\n+\t}\n+      if (! REAL_WORDS_BIG_ENDIAN)\n \t{\n-\t  if (((pe[0] & 0x7f) != 0) || (pe[1] != 0))\n+\t  for (i = 0; i < shortsm1; i++)\n \t    {\n-\t      enan (y, yy[0] != 0);\n-\t      return;\n+\t      if (pe[i] != 0)\n+\t\t{\n+\t\t  enan (y, yy[0] != 0);\n+\t\t  return;\n+\t\t}\n \t    }\n \t}\n       else\n \t{\n-\t  if (((pe[1] & 0x7f) != 0) || (pe[0] != 0))\n+\t  for (i = 1; i < shortsm1 + 1; i++)\n \t    {\n-\t      enan (y, yy[0] != 0);\n-\t      return;\n+\t      if (pe[i] != 0)\n+\t\t{\n+\t\t  enan (y, yy[0] != 0);\n+\t\t  return;\n+\t\t}\n \t    }\n \t}\n-#endif  /* NANS */\n+#endif /* NANS */\n       eclear (y);\n       einfin (y);\n       if (yy[0])\n \teneg (y);\n       return;\n     }\n #endif  /* INFINITY */\n-  r >>= 7;\n   /* If zero exponent, then the significand is denormalized.\n      So take back the understood high significand bit.  */\n   if (r == 0)\n     {\n       denorm = 1;\n-      yy[M] &= ~0200;\n+      yy[M] &= ~highbit;\n     }\n-  r += EXONE - 0177;\n+  r += fmt->adjustment;\n   yy[E] = r;\n   p = &yy[M + 1];\n-#ifdef DEC\n-  *p++ = *(--e);\n-#endif\n-#ifdef IEEE\n   if (! REAL_WORDS_BIG_ENDIAN)\n-    *p++ = *(--e);\n+    {\n+      for (i = 0; i < shortsm1; i++)\n+\t*p++ = *(--e);\n+    }\n   else\n     {\n       ++e;\n-      *p++ = *e++;\n+      for (i = 0; i < shortsm1; i++)\n+\t*p++ = *e++;\n     }\n-#endif\n-  eshift (yy, -8);\n-  if (denorm)\n-    {\t\t\t\t/* if zero exponent, then normalize the significand */\n-      if ((k = enormlz (yy)) > NBITS)\n-\tecleazs (yy);\n-      else\n-\tyy[E] -= (UEMUSHORT) (k - 1);\n+  if (fmt->precision == 113)\n+    {\n+      /* denorm is left alone in 113 bit format */\n+      if (!denorm)\n+\teshift (yy, -1);\n+    }\n+  else\n+    {\n+      eshift (yy, -(expshift + 1));\n+      if (denorm)\n+\t{ /* if zero exponent, then normalize the significand */\n+\t  if ((k = enormlz (yy)) > NBITS)\n+\t    ecleazs (yy);\n+\t  else\n+\t    yy[E] -= (UEMUSHORT) (k - 1);\n+\t}\n     }\n   emovo (yy, y);\n-#endif /* not C4X */\n-#endif /* not IBM */\n }\n \n #if (INTEL_EXTENDED_IEEE_FORMAT == 0)\n@@ -3487,93 +3473,20 @@ etoe113 (x, e)\n      const UEMUSHORT *x;\n      UEMUSHORT *e;\n {\n-  UEMUSHORT xi[NI];\n-  EMULONG exp;\n-  int rndsav;\n-\n-#ifdef NANS\n-  if (eisnan (x))\n-    {\n-      make_nan (e, eisneg (x), TFmode);\n-      return;\n-    }\n-#endif\n-  emovi (x, xi);\n-  exp = (EMULONG) xi[E];\n-#ifdef INFINITY\n-  if (eisinf (x))\n-    goto nonorm;\n-#endif\n-  /* round off to nearest or even */\n-  rndsav = rndprc;\n-  rndprc = 113;\n-  emdnorm (xi, 0, 0, exp, !ROUND_TOWARDS_ZERO);\n-  rndprc = rndsav;\n-#ifdef INFINITY\n- nonorm:\n-#endif\n-  toe113 (xi, e);\n-}\n+  etoieee (x, e, &ieee_113);\n+}\n \n /* Convert exploded e-type X, that has already been rounded to\n    113-bit precision, to IEEE 128-bit long double format Y.  */\n \n static void\n-toe113 (a, b)\n-     UEMUSHORT *a, *b;\n+toe113 (x, y)\n+     UEMUSHORT *x, *y;\n {\n-  UEMUSHORT *p, *q;\n-  UEMUSHORT i;\n-\n-#ifdef NANS\n-  if (eiisnan (a))\n-    {\n-      make_nan (b, eiisneg (a), TFmode);\n-      return;\n-    }\n-#endif\n-  p = a;\n-  if (REAL_WORDS_BIG_ENDIAN)\n-    q = b;\n-  else\n-    q = b + 7;\t\t\t/* point to output exponent */\n-\n-  /* If not denormal, delete the implied bit.  */\n-  if (a[E] != 0)\n-    {\n-      eshup1 (a);\n-    }\n-  /* combine sign and exponent */\n-  i = *p++;\n-  if (REAL_WORDS_BIG_ENDIAN)\n-    {\n-      if (i)\n-\t*q++ = *p++ | 0x8000;\n-      else\n-\t*q++ = *p++;\n-    }\n-  else\n-    {\n-      if (i)\n-\t*q-- = *p++ | 0x8000;\n-      else\n-\t*q-- = *p++;\n-    }\n-  /* skip over guard word */\n-  ++p;\n-  /* move the significand */\n-  if (REAL_WORDS_BIG_ENDIAN)\n-    {\n-      for (i = 0; i < 7; i++)\n-\t*q++ = *p++;\n-    }\n-  else\n-    {\n-      for (i = 0; i < 7; i++)\n-\t*q-- = *p++;\n-    }\n+  toieee (x, y, &ieee_113);\n }\n-#endif\n+\n+#endif  /* INTEL_EXTENDED_IEEE_FORMAT == 0 */\n \n /* Convert e-type X to IEEE double extended format E.  */\n \n@@ -3582,148 +3495,17 @@ etoe64 (x, e)\n      const UEMUSHORT *x;\n      UEMUSHORT *e;\n {\n-  UEMUSHORT xi[NI];\n-  EMULONG exp;\n-  int rndsav;\n-\n-#ifdef NANS\n-  if (eisnan (x))\n-    {\n-      make_nan (e, eisneg (x), XFmode);\n-      return;\n-    }\n-#endif\n-  emovi (x, xi);\n-  /* adjust exponent for offset */\n-  exp = (EMULONG) xi[E];\n-#ifdef INFINITY\n-  if (eisinf (x))\n-    goto nonorm;\n-#endif\n-  /* round off to nearest or even */\n-  rndsav = rndprc;\n-  rndprc = 64;\n-  emdnorm (xi, 0, 0, exp, !ROUND_TOWARDS_ZERO);\n-  rndprc = rndsav;\n-#ifdef INFINITY\n- nonorm:\n-#endif\n-  toe64 (xi, e);\n+  etoieee (x, e, &ieee_64);\n }\n \n /* Convert exploded e-type X, that has already been rounded to\n    64-bit precision, to IEEE double extended format Y.  */\n \n static void\n-toe64 (a, b)\n-     UEMUSHORT *a, *b;\n+toe64 (x, y)\n+     UEMUSHORT *x, *y;\n {\n-  UEMUSHORT *p, *q;\n-  UEMUSHORT i;\n-\n-#ifdef NANS\n-  if (eiisnan (a))\n-    {\n-      make_nan (b, eiisneg (a), XFmode);\n-      return;\n-    }\n-#endif\n-  /* Shift denormal long double Intel format significand down one bit.  */\n-  if ((a[E] == 0) && ! REAL_WORDS_BIG_ENDIAN)\n-    eshdn1 (a);\n-  p = a;\n-#ifdef IBM\n-  q = b;\n-#endif\n-#ifdef DEC\n-  q = b + 4;\n-#endif\n-#ifdef IEEE\n-  if (REAL_WORDS_BIG_ENDIAN)\n-    q = b;\n-  else\n-    {\n-      q = b + 4;\t\t\t/* point to output exponent */\n-      /* Clear the last two bytes of 12-byte Intel format.  q is pointing\n-\t into an array of size 6 (e.g. x[NE]), so the last two bytes are\n-\t always there, and there are never more bytes, even when we are using\n-\t INTEL_EXTENDED_IEEE_FORMAT.  */\n-      *(q+1) = 0;\n-    }\n-#endif\n-\n-  /* combine sign and exponent */\n-  i = *p++;\n-#ifdef IBM\n-  if (i)\n-    *q++ = *p++ | 0x8000;\n-  else\n-    *q++ = *p++;\n-  *q++ = 0;\n-#endif\n-#ifdef DEC\n-  if (i)\n-    *q-- = *p++ | 0x8000;\n-  else\n-    *q-- = *p++;\n-#endif\n-#ifdef IEEE\n-  if (REAL_WORDS_BIG_ENDIAN)\n-    {\n-#ifdef ARM_EXTENDED_IEEE_FORMAT\n-      /* The exponent is in the lowest 15 bits of the first word.  */\n-      *q++ = i ? 0x8000 : 0;\n-      *q++ = *p++;\n-#else\n-      if (i)\n-\t*q++ = *p++ | 0x8000;\n-      else\n-\t*q++ = *p++;\n-      *q++ = 0;\n-#endif\n-    }\n-  else\n-    {\n-      if (i)\n-\t*q-- = *p++ | 0x8000;\n-      else\n-\t*q-- = *p++;\n-    }\n-#endif\n-  /* skip over guard word */\n-  ++p;\n-  /* move the significand */\n-#ifdef IBM\n-  for (i = 0; i < 4; i++)\n-    *q++ = *p++;\n-#endif\n-#ifdef DEC\n-  for (i = 0; i < 4; i++)\n-    *q-- = *p++;\n-#endif\n-#ifdef IEEE\n-  if (REAL_WORDS_BIG_ENDIAN)\n-    {\n-      for (i = 0; i < 4; i++)\n-\t*q++ = *p++;\n-    }\n-  else\n-    {\n-#ifdef INFINITY\n-      if (eiisinf (a))\n-\t{\n-\t  /* Intel long double infinity significand.  */\n-\t  *q-- = 0x8000;\n-\t  *q-- = 0;\n-\t  *q-- = 0;\n-\t  *q = 0;\n-\t  return;\n-\t}\n-#endif\n-      for (i = 0; i < 4; i++)\n-\t*q-- = *p++;\n-    }\n-#endif\n+  toieee (x, y, &ieee_64);\n }\n \n /* e type to double precision.  */\n@@ -3736,7 +3518,7 @@ etoe53 (x, e)\n      const UEMUSHORT *x;\n      UEMUSHORT *e;\n {\n-  etodec (x, e);\t\t/* see etodec.c */\n+  etodec (x, e);\n }\n \n /* Convert exploded e-type X, that has already been rounded to\n@@ -3799,36 +3581,10 @@ toe53 (x, y)\n \n static void\n etoe53 (x, e)\n-     const UEMUSHORT *x;\n-     UEMUSHORT *e;\n+      const UEMUSHORT *x;\n+      UEMUSHORT *e;\n {\n-  UEMUSHORT xi[NI];\n-  EMULONG exp;\n-  int rndsav;\n-\n-#ifdef NANS\n-  if (eisnan (x))\n-    {\n-      make_nan (e, eisneg (x), DFmode);\n-      return;\n-    }\n-#endif\n-  emovi (x, xi);\n-  /* adjust exponent for offsets */\n-  exp = (EMULONG) xi[E] - (EXONE - 0x3ff);\n-#ifdef INFINITY\n-  if (eisinf (x))\n-    goto nonorm;\n-#endif\n-  /* round off to nearest or even */\n-  rndsav = rndprc;\n-  rndprc = 53;\n-  emdnorm (xi, 0, 0, exp, !ROUND_TOWARDS_ZERO);\n-  rndprc = rndsav;\n-#ifdef INFINITY\n- nonorm:\n-#endif\n-  toe53 (xi, e);\n+  etoieee (x, e, &ieee_53);\n }\n \n /* Convert exploded e-type X, that has already been rounded to\n@@ -3838,91 +3594,7 @@ static void\n toe53 (x, y)\n      UEMUSHORT *x, *y;\n {\n-  UEMUSHORT i;\n-  UEMUSHORT *p;\n-\n-#ifdef NANS\n-  if (eiisnan (x))\n-    {\n-      make_nan (y, eiisneg (x), DFmode);\n-      return;\n-    }\n-#endif\n-  if (LARGEST_EXPONENT_IS_NORMAL (64) && x[1] > 2047)\n-    {\n-      saturate (y, eiisneg (x), 64, 1);\n-      return;\n-    }\n-  p = &x[0];\n-#ifdef IEEE\n-  if (! REAL_WORDS_BIG_ENDIAN)\n-    y += 3;\n-#endif\n-  *y = 0;\t\t\t/* output high order */\n-  if (*p++)\n-    *y = 0x8000;\t\t/* output sign bit */\n-\n-  i = *p++;\n-  if (i >= (unsigned int) 2047)\n-    {\n-      /* Saturate at largest number less than infinity.  */\n-#ifdef INFINITY\n-      *y |= 0x7ff0;\n-      if (! REAL_WORDS_BIG_ENDIAN)\n-\t{\n-\t  *(--y) = 0;\n-\t  *(--y) = 0;\n-\t  *(--y) = 0;\n-\t}\n-      else\n-\t{\n-\t  ++y;\n-\t  *y++ = 0;\n-\t  *y++ = 0;\n-\t  *y++ = 0;\n-\t}\n-#else\n-      *y |= (UEMUSHORT) 0x7fef;\n-      if (! REAL_WORDS_BIG_ENDIAN)\n-\t{\n-\t  *(--y) = 0xffff;\n-\t  *(--y) = 0xffff;\n-\t  *(--y) = 0xffff;\n-\t}\n-      else\n-\t{\n-\t  ++y;\n-\t  *y++ = 0xffff;\n-\t  *y++ = 0xffff;\n-\t  *y++ = 0xffff;\n-\t}\n-#endif\n-      return;\n-    }\n-  if (i == 0)\n-    {\n-      eshift (x, 4);\n-    }\n-  else\n-    {\n-      i <<= 4;\n-      eshift (x, 5);\n-    }\n-  i |= *p++ & (UEMUSHORT) 0x0f;\t/* *p = xi[M] */\n-  *y |= (UEMUSHORT) i;\t/* high order output already has sign bit set */\n-  if (! REAL_WORDS_BIG_ENDIAN)\n-    {\n-      *(--y) = *p++;\n-      *(--y) = *p++;\n-      *(--y) = *p;\n-    }\n-  else\n-    {\n-      ++y;\n-      *y++ = *p++;\n-      *y++ = *p++;\n-      *y++ = *p++;\n-    }\n+  toieee (x, y, &ieee_53);\n }\n \n #endif /* not C4X */\n@@ -3954,7 +3626,7 @@ toe24 (x, y)\n   toibm (x, y, SFmode);\n }\n \n-#else\n+#else /* it's not IBM */\n \n #ifdef C4X\n /* Convert e-type X to C4X float E.  */\n@@ -3977,143 +3649,242 @@ toe24 (x, y)\n   toc4x (x, y, QFmode);\n }\n \n+#else /* it's neither IBM nor C4X */\n+\n+#ifdef DEC\n+\n+/* Convert e-type X to DEC F-float E.  */\n+\n+static void\n+etoe24 (x, e)\n+      const UEMUSHORT *x;\n+      UEMUSHORT *e;\n+{\n+  etoieee (x, e, &dec_f);\n+}\n+\n+/* Convert exploded e-type X, that has already been rounded to\n+   float precision, to DEC F-float Y.  */\n+\n+static void\n+toe24 (x, y)\n+      UEMUSHORT *x, *y;\n+{\n+  toieee (x, y, &dec_f);\n+}\n+\n #else\n \n-/* Convert e-type X to IEEE float E.  DEC float is the same as IEEE float.  */\n+/* Convert e-type X to IEEE float E.  */\n \n static void\n etoe24 (x, e)\n-     const UEMUSHORT *x;\n-     UEMUSHORT *e;\n+      const UEMUSHORT *x;\n+      UEMUSHORT *e;\n+{\n+  etoieee (x, e, &ieee_24);\n+}\n+\n+/* Convert exploded e-type X, that has already been rounded to\n+   float precision, to IEEE float Y.  */\n+\n+static void\n+toe24 (x, y)\n+      UEMUSHORT *x, *y;\n+{\n+  toieee (x, y, &ieee_24);\n+}\n+\n+#endif  /* not DEC */\n+#endif  /* not C4X */\n+#endif  /* not IBM */\n+\n+\n+/* Convert e-type X to the IEEE format described by FMT.  */\n+\n+static void\n+etoieee (x, e, fmt)\n+      const UEMUSHORT *x;\n+      UEMUSHORT *e;\n+      const struct ieee_format *fmt;\n {\n-  EMULONG exp;\n   UEMUSHORT xi[NI];\n+  EMULONG exp;\n   int rndsav;\n \n #ifdef NANS\n   if (eisnan (x))\n     {\n-      make_nan (e, eisneg (x), SFmode);\n+      make_nan (e, eisneg (x), fmt->mode);\n       return;\n     }\n #endif\n+\n   emovi (x, xi);\n-  /* adjust exponent for offsets */\n-  exp = (EMULONG) xi[E] - (EXONE - 0177);\n+\n #ifdef INFINITY\n   if (eisinf (x))\n     goto nonorm;\n #endif\n-  /* round off to nearest or even */\n+  /* Adjust exponent for offset.  */\n+  exp = (EMULONG) xi[E] - fmt->adjustment;\n+  \n+  /* Round off to nearest or even.  */\n   rndsav = rndprc;\n-  rndprc = 24;\n+  rndprc = fmt->precision;\n   emdnorm (xi, 0, 0, exp, !ROUND_TOWARDS_ZERO);\n   rndprc = rndsav;\n #ifdef INFINITY\n  nonorm:\n #endif\n-  toe24 (xi, e);\n+  toieee (xi, e, fmt);\n }\n \n /* Convert exploded e-type X, that has already been rounded to\n-   float precision, to IEEE float Y.  */\n+   the necessary precision, to the IEEE format described by FMT.  */\n \n static void\n-toe24 (x, y)\n-     UEMUSHORT *x, *y;\n+toieee (x, y, fmt)\n+      UEMUSHORT *x, *y;\n+      const struct ieee_format *fmt;\n {\n-  UEMUSHORT i;\n-  UEMUSHORT *p;\n+  UEMUSHORT maxexp;\n+  UEMUSHORT *q;\n+  int words;\n+  int i;\n \n+  maxexp = (1 << fmt->expbits) - 1;\n+  words = (fmt->bits - fmt->expbits) / EMUSHORT_SIZE;\n+  \n #ifdef NANS\n   if (eiisnan (x))\n     {\n-      make_nan (y, eiisneg (x), SFmode);\n+      make_nan (y, eiisneg (x), fmt->mode);\n       return;\n     }\n #endif\n-  if (LARGEST_EXPONENT_IS_NORMAL (32) && x[1] > 255)\n+\n+  if (fmt->expbits < 15\n+      && LARGEST_EXPONENT_IS_NORMAL (fmt->bits)\n+      && x[E] > maxexp)\n     {\n-      saturate (y, eiisneg (x), 32, 1);\n+      saturate (y, eiisneg (x), fmt->bits, 1);\n       return;\n     }\n-  p = &x[0];\n-#ifdef IEEE\n-  if (! REAL_WORDS_BIG_ENDIAN)\n-    y += 1;\n-#endif\n-#ifdef DEC\n-  y += 1;\n-#endif\n-  *y = 0;\t\t\t/* output high order */\n-  if (*p++)\n-    *y = 0x8000;\t\t/* output sign bit */\n \n-  i = *p++;\n-/* Handle overflow cases.  */\n-  if (!LARGEST_EXPONENT_IS_NORMAL (32) && i >= 255)\n+  /* Point to the exponent.  */\n+  if (REAL_WORDS_BIG_ENDIAN)\n+    q = y;\n+  else\n+    q = y + words;\n+\n+  /* Copy the sign.  */\n+  if (x[0])\n+    *q = 0x8000;\n+  else\n+    *q = 0;\n+\n+  if (fmt->expbits < 15\n+      && !LARGEST_EXPONENT_IS_NORMAL (fmt->bits)\n+      && x[E] >= maxexp)\n     {\n+      /* Saturate at largest number less that infinity.  */\n+      UEMUSHORT fill;\n #ifdef INFINITY\n-      *y |= (UEMUSHORT) 0x7f80;\n-#ifdef DEC\n-      *(--y) = 0;\n+      *q |= maxexp << (15 - fmt->expbits);\n+      fill = 0;\n+#else\n+      *q |= (maxexp << (15 - fmt->expbits)) - 1;\n+      fill = 0xffff;\n #endif\n-#ifdef IEEE\n-      if (! REAL_WORDS_BIG_ENDIAN)\n-\t*(--y) = 0;\n-      else\n+\n+      if (!REAL_WORDS_BIG_ENDIAN)\n \t{\n-\t  ++y;\n-\t  *y = 0;\n+\t  for (i = 0; i < words; i++)\n+\t    *(--q) = fill;\n \t}\n-#endif\n-#else  /* no INFINITY */\n-      *y |= (UEMUSHORT) 0x7f7f;\n-#ifdef DEC\n-      *(--y) = 0xffff;\n-#endif\n-#ifdef IEEE\n-      if (! REAL_WORDS_BIG_ENDIAN)\n-\t*(--y) = 0xffff;\n       else\n \t{\n-\t  ++y;\n-\t  *y = 0xffff;\n+\t  for (i = 0; i < words; i++)\n+\t    *(++q) = fill;\n \t}\n-#endif\n-#ifdef ERANGE\n+#if defined(INFINITY) && defined(ERANGE)\n       errno = ERANGE;\n #endif\n-#endif  /* no INFINITY */\n       return;\n     }\n-  if (i == 0)\n+\n+  /* If denormal and DEC float, return zero (DEC has no denormals) */\n+#ifdef DEC\n+  if (x[E] == 0)\n+    {\n+      for (i = 0; i < fmt->bits / EMUSHORT_SIZE ; i++)\n+\tq[i] = 0;\n+      return;\n+    }\n+#endif /* DEC */\n+\n+  /* Delete the implied bit unless denormal, except for\n+     64-bit precision.  */\n+  if (fmt->precision != 64 && x[E] != 0)\n     {\n-      eshift (x, 7);\n+      eshup1 (x);\n+    }\n+\n+  /* Shift denormal double extended Intel format significand down\n+     one bit. */\n+  if (fmt->precision == 64 && x[E] == 0 && ! REAL_WORDS_BIG_ENDIAN)\n+    eshdn1 (x);\n+\n+  if (fmt->expbits < 15)\n+    {\n+      /* Shift the significand.  */\n+      eshift (x, 15 - fmt->expbits);\n+\n+      /* Combine the exponent and upper bits of the significand.  */\n+      *q |= x[E] << (15 - fmt->expbits);\n+      *q |= x[M] & (UEMUSHORT) ~((maxexp << (15 - fmt->expbits)) | 0x8000);\n     }\n   else\n     {\n-      i <<= 7;\n-      eshift (x, 8);\n+      /* Copy the exponent.  */\n+      *q |= x[E];\n+    }\n+\n+  /* Add padding after the exponent. At the moment, this is only necessary for\n+     64-bit precision; in this case, the padding is 16 bits.  */\n+  if (fmt->precision == 64)\n+    {\n+      *(q + 1) = 0;\n+\n+      /* Skip padding.  */\n+      if (REAL_WORDS_BIG_ENDIAN)\n+\t++q;\n+    }\n+\n+  /* Copy the significand.  */\n+  if (REAL_WORDS_BIG_ENDIAN)\n+    {\n+      for (i = 0; i < words; i++)\n+\t*(++q) = x[i + M + 1];\n+    }\n+#ifdef INFINITY\n+  else if (fmt->precision == 64 && eiisinf (x))\n+    {\n+      /* Intel double extended infinity significand.  */\n+      *(--q) = 0x8000;\n+      *(--q) = 0;\n+      *(--q) = 0;\n+      *(--q) = 0;\n     }\n-  i |= *p++ & (UEMUSHORT) 0x7f;\t/* *p = xi[M] */\n-  /* High order output already has sign bit set.  */\n-  *y |= i;\n-#ifdef DEC\n-  *(--y) = *p;\n #endif\n-#ifdef IEEE\n-  if (! REAL_WORDS_BIG_ENDIAN)\n-    *(--y) = *p;\n   else\n     {\n-      ++y;\n-      *y = *p;\n+      for (i = 0; i < words; i++)\n+\t*(--q) = x[i + M + 1];\n     }\n-#endif\n }\n-#endif  /* not C4X */\n-#endif  /* not IBM */\n+\n \n /* Compare two e type numbers.\n    Return +1 if a > b\n@@ -5436,14 +5207,22 @@ asctoeg (ss, y, oprec)\n   else if (oprec == 24 || oprec == 56)\n     lexp -= EXONE - (0x41 << 2);\n #else\n+#ifdef DEC\n   else if (oprec == 24)\n+    lexp -= dec_f.adjustment;\n+  else if (oprec == 56)\n+    {\n+      if (TARGET_G_FLOAT)\n+\tlexp -= dec_g.adjustment;\n+      else\n+\tlexp -= dec_d.adjustment;\n+    }\n+#else\n+else if (oprec == 24)\n     lexp -= EXONE - 0177;\n+#endif /* DEC */\n #endif /* IBM */\n #endif /* C4X */\n-#ifdef DEC\n-  else if (oprec == 56)\n-    lexp -= EXONE - 0201;\n-#endif\n   rndprc = oprec;\n   emdnorm (yy, lost, 0, lexp, 64);\n \n@@ -5455,7 +5234,7 @@ asctoeg (ss, y, oprec)\n     {\n #ifdef DEC\n     case 56:\n-      todec (yy, y);\t\t/* see etodec.c */\n+      todec (yy, y);\n       break;\n #endif\n #ifdef IBM\n@@ -5754,37 +5533,10 @@ dectoe (d, e)\n      const UEMUSHORT *d;\n      UEMUSHORT *e;\n {\n-  UEMUSHORT y[NI];\n-  UEMUSHORT r, *p;\n-\n-  ecleaz (y);\t\t\t/* start with a zero */\n-  p = y;\t\t\t/* point to our number */\n-  r = *d;\t\t\t/* get DEC exponent word */\n-  if (*d & (unsigned int) 0x8000)\n-    *p = 0xffff;\t\t/* fill in our sign */\n-  ++p;\t\t\t\t/* bump pointer to our exponent word */\n-  r &= 0x7fff;\t\t\t/* strip the sign bit */\n-  if (r == 0)\t\t\t/* answer = 0 if high order DEC word = 0 */\n-    goto done;\n-\n-\n-  r >>= 7;\t\t\t/* shift exponent word down 7 bits */\n-  r += EXONE - 0201;\t\t/* subtract DEC exponent offset */\n-  /* add our e type exponent offset */\n-  *p++ = r;\t\t\t/* to form our exponent */\n-\n-  r = *d++;\t\t\t/* now do the high order mantissa */\n-  r &= 0177;\t\t\t/* strip off the DEC exponent and sign bits */\n-  r |= 0200;\t\t\t/* the DEC understood high order mantissa bit */\n-  *p++ = r;\t\t\t/* put result in our high guard word */\n-\n-  *p++ = *d++;\t\t\t/* fill in the rest of our mantissa */\n-  *p++ = *d++;\n-  *p = *d;\n-\n-  eshdn8 (y);\t\t\t/* shift our mantissa down 8 bits */\n- done:\n-  emovo (y, e);\n+  if (TARGET_G_FLOAT)\n+    ieeetoe (d, e, &dec_g);\n+  else\n+    ieeetoe (d, e, &dec_d);\n }\n \n /* Convert e type X to DEC double precision D.  */\n@@ -5797,13 +5549,19 @@ etodec (x, d)\n   UEMUSHORT xi[NI];\n   EMULONG exp;\n   int rndsav;\n+  const struct ieee_format *fmt;\n+\n+  if (TARGET_G_FLOAT)\n+    fmt = &dec_g;\n+  else\n+    fmt = &dec_d;\n \n   emovi (x, xi);\n   /* Adjust exponent for offsets.  */\n-  exp = (EMULONG) xi[E] - (EXONE - 0201);\n+  exp = (EMULONG) xi[E] - fmt->adjustment;\n   /* Round off to nearest or even.  */\n   rndsav = rndprc;\n-  rndprc = 56;\n+  rndprc = fmt->precision;\n   emdnorm (xi, 0, 0, exp, !ROUND_TOWARDS_ZERO);\n   rndprc = rndsav;\n   todec (xi, d);\n@@ -5816,42 +5574,10 @@ static void\n todec (x, y)\n      UEMUSHORT *x, *y;\n {\n-  UEMUSHORT i;\n-  UEMUSHORT *p;\n-\n-  p = x;\n-  *y = 0;\n-  if (*p++)\n-    *y = 0100000;\n-  i = *p++;\n-  if (i == 0)\n-    {\n-      *y++ = 0;\n-      *y++ = 0;\n-      *y++ = 0;\n-      *y++ = 0;\n-      return;\n-    }\n-  if (i > 0377)\n-    {\n-      *y++ |= 077777;\n-      *y++ = 0xffff;\n-      *y++ = 0xffff;\n-      *y++ = 0xffff;\n-#ifdef ERANGE\n-      errno = ERANGE;\n-#endif\n-      return;\n-    }\n-  i &= 0377;\n-  i <<= 7;\n-  eshup8 (x);\n-  x[M] &= 0177;\n-  i |= x[M];\n-  *y++ |= i;\n-  *y++ = x[M + 1];\n-  *y++ = x[M + 2];\n-  *y++ = x[M + 3];\n+  if (TARGET_G_FLOAT)\n+    toieee (x, y, &dec_g);\n+  else\n+    toieee (x, y, &dec_d);\n }\n #endif /* DEC */\n \n@@ -6904,49 +6630,37 @@ significand_size (mode)\n      enum machine_mode mode;\n {\n \n-/* Don't test the modes, but their sizes, lest this\n-   code won't work for BITS_PER_UNIT != 8 .  */\n+  /* Don't test the modes, but their sizes, lest this\n+     code won't work for BITS_PER_UNIT != 8 .  */\n \n-switch (GET_MODE_BITSIZE (mode))\n-  {\n-  case 32:\n+  switch (GET_MODE_BITSIZE (mode))\n+    {\n+     case 32:\n \n-#if TARGET_FLOAT_FORMAT == C4X_FLOAT_FORMAT\n-    return 56;\n+#ifdef C4X\n+       return 56;\n+#else\n+       return 24;\n #endif\n \n-    return 24;\n-\n-  case 64:\n-#if TARGET_FLOAT_FORMAT == IEEE_FLOAT_FORMAT\n-    return 53;\n-#else\n-#if TARGET_FLOAT_FORMAT == IBM_FLOAT_FORMAT\n-    return 56;\n-#else\n-#if TARGET_FLOAT_FORMAT == VAX_FLOAT_FORMAT\n-    return 56;\n-#else\n-#if TARGET_FLOAT_FORMAT == C4X_FLOAT_FORMAT\n-    return 56;\n+     case 64:\n+#ifdef IEEE\n+       return 53;\n #else\n-    abort ();\n-#endif\n-#endif\n-#endif\n+       return 56;\n #endif\n \n-  case 96:\n-    return 64;\n+     case 96:\n+       return 64;\n \n-  case 128:\n+     case 128:\n #if (INTEL_EXTENDED_IEEE_FORMAT == 0)\n-    return 113;\n+       return 113;\n #else\n-    return 64;\n+       return 64;\n #endif\n \n-  default:\n-    abort ();\n-  }\n+     default:\n+       abort ();\n+    }\n }"}]}