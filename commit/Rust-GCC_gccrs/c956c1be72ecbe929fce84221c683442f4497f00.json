{"sha": "c956c1be72ecbe929fce84221c683442f4497f00", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Yzk1NmMxYmU3MmVjYmU5MjlmY2U4NDIyMWM2ODM0NDJmNDQ5N2YwMA==", "commit": {"author": {"name": "Matthew Gingell", "email": "gingell@adacore.com", "date": "2007-06-06T10:50:30Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2007-06-06T10:50:30Z"}, "message": "s-stchop-vxworks.adb (Set_Stack_Info): Instead of trying to map the VxWorks task descriptor in the Ada run time...\n\n2007-04-20  Matthew Gingell  <gingell@adacore.com>\n\t    Jose Ruiz  <ruiz@adacore.com>\n\n\t* s-stchop-vxworks.adb (Set_Stack_Info): Instead of trying to map the\n\tVxWorks task descriptor in the Ada run time, call a C subprogram\n\t(__gnat_get_stack_info) that extracts the required information.\n\n\t* sysdep.c: Back out temporary lynxos workaround.\n\t(__gnat_get_stack_info): Add this procedure that passes to the Ada run\n\ttime the stack information associated to the currently executing task.\n\tOnly VxWorks systems require this function.\n\nFrom-SVN: r125471", "tree": {"sha": "b9ec064df236278e82d16c0d220b357e26f258e4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b9ec064df236278e82d16c0d220b357e26f258e4"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c956c1be72ecbe929fce84221c683442f4497f00", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c956c1be72ecbe929fce84221c683442f4497f00", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c956c1be72ecbe929fce84221c683442f4497f00", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c956c1be72ecbe929fce84221c683442f4497f00/comments", "author": null, "committer": null, "parents": [{"sha": "c7f0bdd2f88d0182bf1d17dbe073754d08cb3ec3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c7f0bdd2f88d0182bf1d17dbe073754d08cb3ec3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c7f0bdd2f88d0182bf1d17dbe073754d08cb3ec3"}], "stats": {"total": 96, "additions": 38, "deletions": 58}, "files": [{"sha": "e198fb07b72c06913e07f91185d1ba5615ce0928", "filename": "gcc/ada/s-stchop-vxworks.adb", "status": "modified", "additions": 17, "deletions": 39, "changes": 56, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c956c1be72ecbe929fce84221c683442f4497f00/gcc%2Fada%2Fs-stchop-vxworks.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c956c1be72ecbe929fce84221c683442f4497f00/gcc%2Fada%2Fs-stchop-vxworks.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-stchop-vxworks.adb?ref=c956c1be72ecbe929fce84221c683442f4497f00", "patch": "@@ -45,7 +45,6 @@ with System.Storage_Elements; use System.Storage_Elements;\n with System.Parameters; use System.Parameters;\n with System.Soft_Links;\n with Interfaces.C;\n-with System.OS_Interface;\n \n package body System.Stack_Checking.Operations is\n \n@@ -79,10 +78,9 @@ package body System.Stack_Checking.Operations is\n \n    --  Note: This function must be compiled with Polling turned off\n \n-   --  Note: on systems like VxWorks and OS/2 with real thread-local storage,\n+   --  Note: on systems like VxWorks and Linux with real thread-local storage,\n    --        Set_Stack_Info should return an access value for such local\n    --        storage. In those cases the cache will always be up-to-date.\n-   --        Fix examples??? Linux???\n \n    --  The following constants should be imported from some system-specific\n    --  constants package. The constants must be static for performance reasons.\n@@ -104,41 +102,22 @@ package body System.Stack_Checking.Operations is\n    function Set_Stack_Info\n      (Stack : not null access Stack_Access) return Stack_Access\n    is\n-      --  Task descriptor that is handled internally by the VxWorks kernel\n-\n-      type Td_Events_Storage is array (1 .. 4) of Interfaces.C.int;\n-      pragma Convention (C, Td_Events_Storage);\n-\n-      type Task_Descriptor is record\n-         T_Id            : Interfaces.C.int; -- task identifier\n-         Td_Name         : System.Address; -- task name\n-         Td_Priority     : Interfaces.C.int; -- task priority\n-         Td_Status       : Interfaces.C.int; -- task status\n-         Td_Options      : Interfaces.C.int; -- task option bits (see below)\n-         Td_Entry        : System.Address; -- original entry point of task\n-         Td_Sp           : System.Address; -- saved stack pointer\n-         Td_PStackBase   : System.Address; -- the bottom of the stack\n-         Td_PStackLimit  : System.Address; -- the effective end of the stack\n-         Td_PStackEnd    : System.Address; -- the actual end of the stack\n-         Td_StackSize    : Interfaces.C.int; -- size of stack in bytes\n-         Td_StackCurrent : Interfaces.C.int; -- current stack usage in bytes\n-         Td_StackHigh    : Interfaces.C.int; -- maximum stack usage in bytes\n-         Td_StackMargin  : Interfaces.C.int; -- current stack margin in bytes\n-         Td_ErrorStatus  : Interfaces.C.int; -- most recent task error status\n-         Td_Delay        : Interfaces.C.int; -- delay/timeout ticks\n-         Td_Events       : Td_Events_Storage; -- task events, post t2.0\n+      type OS_Stack_Info is record\n+         Size  : Interfaces.C.int;\n+         Base  : System.Address;\n+         Limit : System.Address;\n       end record;\n-      pragma Convention (C, Task_Descriptor);\n+      pragma Convention (C, OS_Stack_Info);\n+      --  Type representing the information that we want to extract from the\n+      --  underlying kernel.\n \n-      --  This VxWorks procedure fills in a specified task descriptor\n-      --  for a specified task.\n-      procedure TaskInfoGet\n-        (T_Id      : System.OS_Interface.t_id;\n-         Task_Desc : not null access Task_Descriptor);\n-      pragma Import (C, TaskInfoGet, \"taskInfoGet\");\n+      procedure Get_Stack_Info (Stack : not null access OS_Stack_Info);\n+      pragma Import (C, Get_Stack_Info, \"__gnat_get_stack_info\");\n+      --  Procedure that fills the stack information associated to the\n+      --  currently executing task.\n \n       My_Stack  : Stack_Access;\n-      Task_Desc : aliased Task_Descriptor;\n+      Task_Info : aliased OS_Stack_Info;\n \n    begin\n       --  The order of steps 1 .. 3 is important, see specification.\n@@ -151,12 +130,11 @@ package body System.Stack_Checking.Operations is\n \n          --  First invocation. Ask the VxWorks kernel about stack values\n \n-         TaskInfoGet (System.OS_Interface.taskIdSelf, Task_Desc'Access);\n+         Get_Stack_Info (Task_Info'Access);\n \n-         My_Stack.Size :=\n-           System.Storage_Elements.Storage_Offset (Task_Desc.Td_StackSize);\n-         My_Stack.Base := Task_Desc.Td_PStackBase;\n-         My_Stack.Limit := Task_Desc.Td_PStackLimit;\n+         My_Stack.Size  := Storage_Elements.Storage_Offset (Task_Info.Size);\n+         My_Stack.Base  := Task_Info.Base;\n+         My_Stack.Limit := Task_Info.Limit;\n \n       end if;\n "}, {"sha": "cde8e544eb7e496e0c07c058d36bcaf917a341be", "filename": "gcc/ada/sysdep.c", "status": "modified", "additions": 21, "deletions": 19, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c956c1be72ecbe929fce84221c683442f4497f00/gcc%2Fada%2Fsysdep.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c956c1be72ecbe929fce84221c683442f4497f00/gcc%2Fada%2Fsysdep.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsysdep.c?ref=c956c1be72ecbe929fce84221c683442f4497f00", "patch": "@@ -872,28 +872,30 @@ __gnat_get_task_options (void)\n #endif\n }\n \n-#endif\n+typedef struct\n+{\n+  int  size;\n+  char *base;\n+  char *end;\n+} stack_info;\n \n-#ifdef __Lynx__\n+/* __gnat_get_stack_info is used by s-stchop.adb only for VxWorks. This\n+   procedure fills the stack information associated to the currently\n+   executing task. */\n+extern void __gnat_get_stack_info (stack_info *vxworks_stack_info);\n \n-/*\n-   The following code works around a problem in LynxOS version 4.2. As\n-   of that version, the symbol pthread_mutex_lock has been removed\n-   from libc and replaced with an inline C function in a system\n-   header.\n-\n-   LynuxWorks has indicated that this is a bug and that they intend to\n-   put that symbol back in libc in a future patch level, following\n-   which this patch can be removed. However, for the time being we use\n-   a wrapper which can be imported from the runtime.\n-*/\n+void\n+__gnat_get_stack_info (stack_info *vxworks_stack_info)\n+{\n+  TASK_DESC descriptor;\n \n-#include <pthread.h>\n+  /* Ask the VxWorks kernel about stack values */\n+  taskInfoGet (taskIdSelf (), &descriptor);\n \n-int\n-__gnat_pthread_mutex_lock (pthread_mutex_t *mutex)\n-{\n-  return pthread_mutex_lock (mutex);\n+  /* Fill the stack data with the information provided by the kernel */\n+  vxworks_stack_info->size = descriptor.td_stackSize;\n+  vxworks_stack_info->base = descriptor.td_pStackBase;\n+  vxworks_stack_info->end  = descriptor.td_pStackEnd;\n }\n \n-#endif /* __Lynx__ */\n+#endif"}]}