{"sha": "dbbc379eaa586bae7a5f374fb6e294810af2ae80", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZGJiYzM3OWVhYTU4NmJhZTdhNWYzNzRmYjZlMjk0ODEwYWYyYWU4MA==", "commit": {"author": {"name": "Jason Merrill", "email": "jason@redhat.com", "date": "2011-09-12T18:04:31Z"}, "committer": {"name": "Jason Merrill", "email": "jason@gcc.gnu.org", "date": "2011-09-12T18:04:31Z"}, "message": "cp-tree.h (LOOKUP_NO_RVAL_BIND): New.\n\n\t* cp-tree.h (LOOKUP_NO_RVAL_BIND): New.\n\t* call.c (conditional_conversion): Use it.\n\t(reference_binding): Fix handling of xvalues.\n\nFrom-SVN: r178787", "tree": {"sha": "5110c2a484935a0f9da3e71b1aca5b87046c7c63", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5110c2a484935a0f9da3e71b1aca5b87046c7c63"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/dbbc379eaa586bae7a5f374fb6e294810af2ae80", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dbbc379eaa586bae7a5f374fb6e294810af2ae80", "html_url": "https://github.com/Rust-GCC/gccrs/commit/dbbc379eaa586bae7a5f374fb6e294810af2ae80", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dbbc379eaa586bae7a5f374fb6e294810af2ae80/comments", "author": {"login": "jicama", "id": 266146, "node_id": "MDQ6VXNlcjI2NjE0Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/266146?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jicama", "html_url": "https://github.com/jicama", "followers_url": "https://api.github.com/users/jicama/followers", "following_url": "https://api.github.com/users/jicama/following{/other_user}", "gists_url": "https://api.github.com/users/jicama/gists{/gist_id}", "starred_url": "https://api.github.com/users/jicama/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jicama/subscriptions", "organizations_url": "https://api.github.com/users/jicama/orgs", "repos_url": "https://api.github.com/users/jicama/repos", "events_url": "https://api.github.com/users/jicama/events{/privacy}", "received_events_url": "https://api.github.com/users/jicama/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "4ce1e77017b289c619d22c1bcbb120aae271098b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4ce1e77017b289c619d22c1bcbb120aae271098b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4ce1e77017b289c619d22c1bcbb120aae271098b"}], "stats": {"total": 69, "additions": 44, "deletions": 25}, "files": [{"sha": "c72d9d07d1753c7e8eef0fa1bec71fc94be3c6f9", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dbbc379eaa586bae7a5f374fb6e294810af2ae80/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dbbc379eaa586bae7a5f374fb6e294810af2ae80/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=dbbc379eaa586bae7a5f374fb6e294810af2ae80", "patch": "@@ -1,3 +1,9 @@\n+2011-09-12  Jason Merrill  <jason@redhat.com>\n+\n+\t* cp-tree.h (LOOKUP_NO_RVAL_BIND): New.\n+\t* call.c (conditional_conversion): Use it.\n+\t(reference_binding): Fix handling of xvalues.\n+\n 2011-09-09  Jason Merrill  <jason@redhat.com>\n \n \t* call.c (implicit_conversion): Check BRACE_ENCLOSED_INITIALIZER_P"}, {"sha": "81c8a908c41195e7cf3b48787faa496576ad0d81", "filename": "gcc/cp/call.c", "status": "modified", "additions": 36, "deletions": 25, "changes": 61, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dbbc379eaa586bae7a5f374fb6e294810af2ae80/gcc%2Fcp%2Fcall.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dbbc379eaa586bae7a5f374fb6e294810af2ae80/gcc%2Fcp%2Fcall.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcall.c?ref=dbbc379eaa586bae7a5f374fb6e294810af2ae80", "patch": "@@ -1564,7 +1564,8 @@ reference_binding (tree rto, tree rfrom, tree expr, bool c_cast_p, int flags)\n   tree tfrom;\n   bool related_p;\n   bool compatible_p;\n-  cp_lvalue_kind is_lvalue = clk_none;\n+  cp_lvalue_kind gl_kind;\n+  bool is_lvalue;\n \n   if (TREE_CODE (to) == FUNCTION_TYPE && expr && type_unknown_p (expr))\n     {\n@@ -1574,14 +1575,6 @@ reference_binding (tree rto, tree rfrom, tree expr, bool c_cast_p, int flags)\n       from = TREE_TYPE (expr);\n     }\n \n-  if (TREE_CODE (from) == REFERENCE_TYPE)\n-    {\n-      from = TREE_TYPE (from);\n-      if (!TYPE_REF_IS_RVALUE (rfrom)\n-\t  || TREE_CODE (from) == FUNCTION_TYPE)\n-\tis_lvalue = clk_ordinary;\n-    }\n-\n   if (expr && BRACE_ENCLOSED_INITIALIZER_P (expr))\n     {\n       maybe_warn_cpp0x (CPP0X_INITIALIZER_LISTS);\n@@ -1597,11 +1590,28 @@ reference_binding (tree rto, tree rfrom, tree expr, bool c_cast_p, int flags)\n \t}\n     }\n \n-  if (is_lvalue == clk_none && expr)\n-    is_lvalue = real_lvalue_p (expr);\n+  if (TREE_CODE (from) == REFERENCE_TYPE)\n+    {\n+      from = TREE_TYPE (from);\n+      if (!TYPE_REF_IS_RVALUE (rfrom)\n+\t  || TREE_CODE (from) == FUNCTION_TYPE)\n+\tgl_kind = clk_ordinary;\n+      else\n+\tgl_kind = clk_rvalueref;\n+    }\n+  else if (expr)\n+    {\n+      gl_kind = lvalue_kind (expr);\n+      if (gl_kind & clk_class)\n+\t/* A class prvalue is not a glvalue.  */\n+\tgl_kind = clk_none;\n+    }\n+  else\n+    gl_kind = clk_none;\n+  is_lvalue = gl_kind && !(gl_kind & clk_rvalueref);\n \n   tfrom = from;\n-  if ((is_lvalue & clk_bitfield) != 0)\n+  if ((gl_kind & clk_bitfield) != 0)\n     tfrom = unlowered_expr_type (expr);\n \n   /* Figure out whether or not the types are reference-related and\n@@ -1619,16 +1629,16 @@ reference_binding (tree rto, tree rfrom, tree expr, bool c_cast_p, int flags)\n      the reference and expression is an lvalue. In DR391, the wording in\n      [8.5.3/5 dcl.init.ref] is changed to also require direct bindings for\n      const and rvalue references to rvalues of compatible class type.\n-     We should also do direct bindings for non-class \"rvalues\" derived from\n-     rvalue references.  */\n+     We should also do direct bindings for non-class xvalues.  */\n   if (compatible_p\n       && (is_lvalue\n \t  || (((CP_TYPE_CONST_NON_VOLATILE_P (to)\n-\t\t&& !(flags & LOOKUP_NO_TEMP_BIND))\n+\t\t&& !(flags & LOOKUP_NO_RVAL_BIND))\n \t       || TYPE_REF_IS_RVALUE (rto))\n-\t      && (CLASS_TYPE_P (from)\n-\t\t  || TREE_CODE (from) == ARRAY_TYPE\n-\t\t  || (expr && lvalue_p (expr))))))\n+\t      && (gl_kind\n+\t\t  || (!(flags & LOOKUP_NO_TEMP_BIND)\n+\t\t      && (CLASS_TYPE_P (from)\n+\t\t\t  || TREE_CODE (from) == ARRAY_TYPE))))))\n     {\n       /* [dcl.init.ref]\n \n@@ -1661,8 +1671,8 @@ reference_binding (tree rto, tree rfrom, tree expr, bool c_cast_p, int flags)\n \tconv->rvaluedness_matches_p \n           = (TYPE_REF_IS_RVALUE (rto) == !is_lvalue);\n \n-      if ((is_lvalue & clk_bitfield) != 0\n-\t  || ((is_lvalue & clk_packed) != 0 && !TYPE_PACKED (to)))\n+      if ((gl_kind & clk_bitfield) != 0\n+\t  || ((gl_kind & clk_packed) != 0 && !TYPE_PACKED (to)))\n \t/* For the purposes of overload resolution, we ignore the fact\n \t   this expression is a bitfield or packed field. (In particular,\n \t   [over.ics.ref] says specifically that a function with a\n@@ -3575,8 +3585,8 @@ build_user_type_conversion_1 (tree totype, tree expr, int flags)\n       struct z_candidate *old_candidates;\n \n       /* If we are called to convert to a reference type, we are trying to\n-\t find an lvalue binding, so don't even consider temporaries.  If\n-\t we don't find an lvalue binding, the caller will try again to\n+\t find a direct binding, so don't even consider temporaries.  If\n+\t we don't find a direct binding, the caller will try again to\n \t look for a temporary binding.  */\n       if (TREE_CODE (totype) == REFERENCE_TYPE)\n \tconvflags |= LOOKUP_NO_TEMP_BIND;\n@@ -4297,16 +4307,17 @@ conditional_conversion (tree e1, tree e2)\n   /* [expr.cond]\n \n      If E2 is an lvalue: E1 can be converted to match E2 if E1 can be\n-     implicitly converted (clause _conv_) to the type \"reference to\n+     implicitly converted (clause _conv_) to the type \"lvalue reference to\n      T2\", subject to the constraint that in the conversion the\n-     reference must bind directly (_dcl.init.ref_) to E1.  */\n+     reference must bind directly (_dcl.init.ref_) to an lvalue.  */\n   if (real_lvalue_p (e2))\n     {\n       conv = implicit_conversion (build_reference_type (t2),\n \t\t\t\t  t1,\n \t\t\t\t  e1,\n \t\t\t\t  /*c_cast_p=*/false,\n-\t\t\t\t  LOOKUP_NO_TEMP_BIND|LOOKUP_ONLYCONVERTING);\n+\t\t\t\t  LOOKUP_NO_TEMP_BIND|LOOKUP_NO_RVAL_BIND\n+\t\t\t\t  |LOOKUP_ONLYCONVERTING);\n       if (conv)\n \treturn conv;\n     }"}, {"sha": "06572fd1f7c1cb40145becb84f609679e6482227", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dbbc379eaa586bae7a5f374fb6e294810af2ae80/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dbbc379eaa586bae7a5f374fb6e294810af2ae80/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=dbbc379eaa586bae7a5f374fb6e294810af2ae80", "patch": "@@ -4294,6 +4294,8 @@ enum overload_flags { NO_SPECIAL = 0, DTOR_FLAG, TYPENAME_FLAG };\n #define LOOKUP_ALREADY_DIGESTED (LOOKUP_DEFAULTED << 1)\n /* An instantiation with explicit template arguments.  */\n #define LOOKUP_EXPLICIT_TMPL_ARGS (LOOKUP_ALREADY_DIGESTED << 1)\n+/* Like LOOKUP_NO_TEMP_BIND, but also prevent binding to xvalues.  */\n+#define LOOKUP_NO_RVAL_BIND (LOOKUP_EXPLICIT_TMPL_ARGS << 1)\n \n #define LOOKUP_NAMESPACES_ONLY(F)  \\\n   (((F) & LOOKUP_PREFER_NAMESPACES) && !((F) & LOOKUP_PREFER_TYPES))"}]}