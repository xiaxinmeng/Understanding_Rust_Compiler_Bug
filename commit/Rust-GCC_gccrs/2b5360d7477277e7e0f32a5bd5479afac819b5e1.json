{"sha": "2b5360d7477277e7e0f32a5bd5479afac819b5e1", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MmI1MzYwZDc0NzcyNzdlN2UwZjMyYTViZDU0NzlhZmFjODE5YjVlMQ==", "commit": {"author": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2019-05-31T19:45:37Z"}, "committer": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2019-05-31T19:45:37Z"}, "message": "compiler: handle int-to-string conversion with large integer constant\n    \n    Currently, Type_conversion_expression::do_is_constant thinks the\n    int-to-string conversion is constant if the integer operand is\n    constant, but Type_conversion_expression::do_get_backend actually\n    generates a call to runtime.intstring if the integer does not fit\n    in a \"ushort\", which makes it not suitable in constant context,\n    such as static initializer.\n    \n    This CL makes it handle all constant integer input as constant,\n    generating constant string.\n    \n    Fixes golang/go#32347.\n    \n    Reviewed-on: https://go-review.googlesource.com/c/gofrontend/+/179777\n\nFrom-SVN: r271821", "tree": {"sha": "1aca42d25ab0d81d4d8e4f34c8d820152a3a2958", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1aca42d25ab0d81d4d8e4f34c8d820152a3a2958"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2b5360d7477277e7e0f32a5bd5479afac819b5e1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2b5360d7477277e7e0f32a5bd5479afac819b5e1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2b5360d7477277e7e0f32a5bd5479afac819b5e1", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2b5360d7477277e7e0f32a5bd5479afac819b5e1/comments", "author": null, "committer": null, "parents": [{"sha": "f2c2c4e30200463abd0ff1677daf16d49ad4f122", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f2c2c4e30200463abd0ff1677daf16d49ad4f122", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f2c2c4e30200463abd0ff1677daf16d49ad4f122"}], "stats": {"total": 17, "additions": 13, "deletions": 4}, "files": [{"sha": "420248b6262e44b0c5cd1faad74a247a1576784e", "filename": "gcc/go/gofrontend/MERGE", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2b5360d7477277e7e0f32a5bd5479afac819b5e1/gcc%2Fgo%2Fgofrontend%2FMERGE", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2b5360d7477277e7e0f32a5bd5479afac819b5e1/gcc%2Fgo%2Fgofrontend%2FMERGE", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2FMERGE?ref=2b5360d7477277e7e0f32a5bd5479afac819b5e1", "patch": "@@ -1,4 +1,4 @@\n-8402f6ac021ba20163ab4fcdb10ab7bb642de6dc\n+e521123b23494148d534755e2f3d7806b42c96ad\n \n The first line of this file holds the git revision number of the last\n merge done from the gofrontend repository."}, {"sha": "f0c12f42ce3aa331457195112eaf863fa5105335", "filename": "gcc/go/gofrontend/expressions.cc", "status": "modified", "additions": 12, "deletions": 3, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2b5360d7477277e7e0f32a5bd5479afac819b5e1/gcc%2Fgo%2Fgofrontend%2Fexpressions.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2b5360d7477277e7e0f32a5bd5479afac819b5e1/gcc%2Fgo%2Fgofrontend%2Fexpressions.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fexpressions.cc?ref=2b5360d7477277e7e0f32a5bd5479afac819b5e1", "patch": "@@ -3842,11 +3842,20 @@ Type_conversion_expression::do_get_backend(Translate_context* context)\n       mpz_t intval;\n       Numeric_constant nc;\n       if (this->expr_->numeric_constant_value(&nc)\n-\t  && nc.to_int(&intval)\n-\t  && mpz_fits_ushort_p(intval))\n+\t  && nc.to_int(&intval))\n \t{\n \t  std::string s;\n-\t  Lex::append_char(mpz_get_ui(intval), true, &s, loc);\n+          unsigned int x;\n+          if (mpz_fits_uint_p(intval))\n+            x = mpz_get_ui(intval);\n+          else\n+            {\n+              char* s = mpz_get_str(NULL, 16, intval);\n+              go_warning_at(loc, 0,\n+                            \"unicode code point 0x%s out of range in string\", s);\n+              x = 0xfffd;\n+            }\n+\t  Lex::append_char(x, true, &s, loc);\n \t  mpz_clear(intval);\n \t  Expression* se = Expression::make_string(s, loc);\n \t  return se->get_backend(context);"}]}