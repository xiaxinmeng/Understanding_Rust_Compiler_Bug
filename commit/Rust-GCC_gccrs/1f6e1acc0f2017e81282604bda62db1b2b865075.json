{"sha": "1f6e1acc0f2017e81282604bda62db1b2b865075", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MWY2ZTFhY2MwZjIwMTdlODEyODI2MDRiZGE2MmRiMWIyYjg2NTA3NQ==", "commit": {"author": {"name": "Alex Samuel", "email": "samuel@codesourcery.com", "date": "2000-06-04T21:12:27Z"}, "committer": {"name": "Mark Mitchell", "email": "mmitchel@gcc.gnu.org", "date": "2000-06-04T21:12:27Z"}, "message": "Make-lang.in (CXX_SRCS): Add mangle.c.\n\n\t* Make-lang.in (CXX_SRCS): Add mangle.c.\n\t* Makefile.in (CXX_OBJS): Add mangle.o.\n\t(mangle.o): New rule.\n\nCo-Authored-By: Mark Mitchell <mark@codesourcery.com>\n\nFrom-SVN: r34394", "tree": {"sha": "124eda5b35f374513ef2c08290e80077a8dcc1c0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/124eda5b35f374513ef2c08290e80077a8dcc1c0"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/1f6e1acc0f2017e81282604bda62db1b2b865075", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1f6e1acc0f2017e81282604bda62db1b2b865075", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1f6e1acc0f2017e81282604bda62db1b2b865075", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1f6e1acc0f2017e81282604bda62db1b2b865075/comments", "author": null, "committer": null, "parents": [{"sha": "031926e2a3b8593caea2941bdaf06b04042ef598", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/031926e2a3b8593caea2941bdaf06b04042ef598", "html_url": "https://github.com/Rust-GCC/gccrs/commit/031926e2a3b8593caea2941bdaf06b04042ef598"}], "stats": {"total": 2953, "additions": 2616, "deletions": 337}, "files": [{"sha": "ce7b48e6d432d70b9b2efbaff608f7d8f03d0254", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 74, "deletions": 62, "changes": 136, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1f6e1acc0f2017e81282604bda62db1b2b865075/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1f6e1acc0f2017e81282604bda62db1b2b865075/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=1f6e1acc0f2017e81282604bda62db1b2b865075", "patch": "@@ -1,66 +1,78 @@\n-2000-06-03  Mark Mitchell  <mark@codesourcery.com>\n-\n-\t* cp-tree.h (TMPL_ARGS_LEVEL): Clarify comment.\n-\t(INNERMOST_TEMPLATE_ARGS): New macro.\n-\t(innermost_args): Remove.\n-\t(get_innermost_template_args): New function.\n-\t* decl2.c (arg_assoc_class): Use INNERMOST_TEMPLATE_ARGS.\n-\t* error.c (dump_function_decl): Be caution when using\n-\tmost_general_template.\n-\t* method.c (build_template_parm_names):  Use\n-\tINNERMOST_TEMPLATE_ARGS.\n-\t* pt.c (add_to_template_args): Tidy comment\n-\t(get_innermost_template_args): New function.\n-\t(check_explicit_specialization): Clear DECL_INITIAL for a new\n-\tspecialization.\n-\t(process_partial_specialization): Use INNERMOST_TEMPLATE_ARGS.\n-\tTidy.\n-\t(push_template_decl): Always register specializations of the most\n-\tgeneral template.\n-\t(convert_template_argument): Use INNERMOST_TEMPLATE_ARGS.\n-\t(coerce_template_parms): Likewise.\n-\t(lookup_template_class): Likewise.\n-\t(innermost_args): Remove.\n-\t(tsubst_decl): Use INNERMOST_TEMPLATE_ARGS.\n-\t(tsubst_decl): Handle tricky specializations.  Use\n-\tget_innermost_template_args.\n-\t(instantiate_template): Simplify handling of partial\n-\tinstantiations.\n-\t(get_class_bindings): Use INNERMOST_TEMPLATE_ARGS.\n-\t(most_general_template): Reimplement, in a more straightforward\n-\tmanner.\n-\t(regenerate_decl_from_template): Tweak formatting.  Use\n-\tTMPL_ARGS_DEPTH for clarity.\n-\t(set_mangled_name_for_template_decl): Use INNERMOST_ARGS.\n-\t\n-\t* dump.c (dequeue_and_dump): Dump information about thunks.\n-\n-2000-06-02  Jason Merrill  <jason@casey.soma.redhat.com>\n-\n-\t* exception.cc (__cp_pop_exception): If we aren't popping or\n-\trethrowing, push down past any uncaught exceptions.\n-\t(__uncatch_exception): Rethrow the currently handled exception.\n-\tMove it to the top of the exception stack.\n-\n-Fri Jun  2 19:38:57 2000  Richard Kenner  <kenner@vlsi1.ultra.nyu.edu>\n-\n-\t* cp-tree.h: Use struct tree_common instead of a char array.\n-\t* decl.c (grokdeclarator): Set DECL_NONADDRESSABLE_P instead\n-\tof TREE_ADDRESSABLE.\n-\n-2000-06-02  Richard Henderson  <rth@cygnus.com>\n-\n-\t* decl.c (init_decl_processing): Don't set lang_get_alias_set.\n-\n-2000-06-02  Jason Merrill  <jason@casey.soma.redhat.com>\n-\n-\t* decl.c (store_return_init): Call put_var_into_stack.\n-\n-2000-06-01  Mark Mitchell  <mark@codesourcery.com>\n-\n-\t* cp-tree.h (lang_decl_flags): Add anticipated_p.\n-\t(DECL_ANTICIPATED): Use it.\n+2000-06-03  Alex Samuel    <samuel@codesourcery.com>\n+\t    Mark Mitchell  <mark@codesourcery.com>\n \n+\t* Make-lang.in (CXX_SRCS): Add mangle.c.\n+\t* Makefile.in (CXX_OBJS): Add mangle.o.\n+\t(mangle.o): New rule.\n+\n+\t* class.c (local_classes): New variable.\n+\t* class.c (get_vtable_name): Use mangle_vtable_for_type for new ABI.\n+\t(get_vtt_name): Use mangle_vtt_name for new ABI.\n+\t(init_class_processing): Initialize local_classes.\n+\t(build_ctor_vtbl_group): Use mangle_ctor_vtbl_for_type for new ABI.\n+\t* cp-tree.h (cp_tree_index): Add CPTI_STD_IDENTIFIER.\n+\t(std_identifier): New macro.\n+\t(DECL_VOLATILE_MEMFUNC_P): New macro.\n+\t(DECL_NAMESPACE_STD_P): Likewise.\n+\t(local_classes): Declare.\n+\t(get_mostly_instantiated_function_type): Declare.\n+\t(init_mangle): Declare.\n+\t(mangle_decl): Likewise.\n+\t(mangle_type_string): Likewise.\n+\t(mangle_type): Likewise.\n+\t(mangle_typeinfo_for_type): Likewise.\n+\t(mangle_typeinfo_string_for_type): Likewise.\n+\t(mangle_vtbl_for_type): Likewise.\n+\t(mangle_vtt_for_type): Likewise.\n+\t(mangle_ctor_vtbl_for_type): Likewise.\n+\t(mangle_thunk): Likewise.\n+\t(mangle_conv_op_name_for_type): Likewise.\n+\t(mangle_guard_variable): Likewise.\n+\t* decl.c (pushtag): Keep track of local classes.\n+\t(initialize_predefined_identifiers): Initialize std_identifier.\n+\t(init_decl_processing): Use std_identifier.\n+\t(start_decl): Don't treat instantiations as specializations.\n+\t(grokdeclarator): Likewise.\n+\t(grokvardecl): Call mangle_decl for new ABI.  Only set mangled\n+\tname for fully-instantiated templates.\n+\t* decl2.c (grokclassfn): Use set_mangled_name_for_decl for\n+\tdestructors with the new ABI.\t\n+\t(finish_static_data_member_decl): Use mangle_decl under the new ABI.\n+\t(grokfield): Use mangle_type for new ABI.\n+\t(grokoptypename): Use mangle_conv_op_for_type for new ABI.\n+\t(get_sentry): Use mangle_guard_variable for new ABI.\n+\t(start_static_initialization_or_destruction): Likewise.\n+\t* expr.c (extract_aggr_init): Remove.\n+\t(extract_scalar_init): Likewise.\n+\t(extract_init): Remove #if 0'd code.\n+\t* mangle.c: New function.\n+\t* method.c (build_mangled_name): Assert not flag_new_abi.\n+\t(build_static_name): Likewise.\n+\t(build_decl_overload_real): Likewise.\n+\t(build_typename_overload): Likewise.\n+\t(build_overload_with_type): Likewise.\n+\t(build_overload_name): Likewise.\n+\t(get_ctor_vtbl_name): Likewise.\n+\t(start_squangling): Likewise.\n+\t(get_id_2): Likewise.\n+\t(set_mangled_name_for_decl): Call mangle_decl for new ABI.\n+\t(init_method): Call init_mangle for new ABI.\n+\t(make_thunk): Call mangle_thunk for new ABI.\n+\t* operators.def: Correct new ABI manglings for the `%' operator.\n+\tAdd `::' operator.\n+\t* pt.c (build_template_decl): Copy DECL_OVERLOADED_OPERATOR_P and\n+\tDECL_ASSIGNMENT_OPERATOR_P to the TEMPLATE_DECL.\n+\t(lookup_template_class): Call mangle_decl for new ABI.\n+\t(get_mostly_instantiated_function_type): New function.\n+\t(set_mangled_name_for_template_decl): Use it.\n+\t(tsubst_decl): Use set_mangled_name_for_decl for destructors with\n+\tthe new ABI.  Use mangle_conv_op_name_for_type for instantiated\n+\tconversion op names.\n+\t* rtti.c (tinfo_name): Call mangle_type_string for new ABI.\n+\t(get_tinfo_decl): Call mangle_typeinfo_for_type for new\tABI.\n+\t(tinfo_base_init):  Likewise.  Mangle typeinfo string name with\n+\tmangle_typeinfo_string_for_type.\n+\t\n 2000-06-01  Richard Henderson  <rth@cygnus.com>\n \n \t* decl.c (init_decl_processing): Set lang_get_alias_set first thing."}, {"sha": "92ade94309c75248bdc03d1780bf562da063b5da", "filename": "gcc/cp/Make-lang.in", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1f6e1acc0f2017e81282604bda62db1b2b865075/gcc%2Fcp%2FMake-lang.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1f6e1acc0f2017e81282604bda62db1b2b865075/gcc%2Fcp%2FMake-lang.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FMake-lang.in?ref=1f6e1acc0f2017e81282604bda62db1b2b865075", "patch": "@@ -115,11 +115,11 @@ CXX_SRCS = $(srcdir)/cp/call.c $(srcdir)/cp/class.c $(srcdir)/cp/cp-tree.def \\\n  $(srcdir)/cp/errfn.c $(srcdir)/cp/error.c $(srcdir)/cp/except.c \\\n  $(srcdir)/cp/expr.c $(srcdir)/cp/friend.c $(srcdir)/cp/init.c \\\n  $(srcdir)/cp/input.c $(srcdir)/cp/lex.c $(srcdir)/cp/lex.h \\\n- $(srcdir)/cp/method.c $(srcdir)/cp/optimize.c $(srcdir)/cp/parse.y \\\n- $(srcdir)/cp/pt.c $(srcdir)/cp/ptree.c $(srcdir)/cp/repo.c \\\n- $(srcdir)/cp/rtti.c $(srcdir)/cp/search.c $(srcdir)/cp/semantics.c \\\n- $(srcdir)/cp/spew.c $(srcdir)/cp/tree.c $(srcdir)/cp/typeck.c \\\n- $(srcdir)/cp/typeck2.c $(srcdir)/cp/xref.c\n+ $(srcdir)/cp/mangle.c $(srcdir)/cp/method.c $(srcdir)/cp/optimize.c \\\n+ $(srcdir)/cp/parse.y $(srcdir)/cp/pt.c $(srcdir)/cp/ptree.c \\\n+ $(srcdir)/cp/repo.c $(srcdir)/cp/rtti.c $(srcdir)/cp/search.c \\\n+ $(srcdir)/cp/semantics.c $(srcdir)/cp/spew.c $(srcdir)/cp/tree.c \\\n+ $(srcdir)/cp/typeck.c $(srcdir)/cp/typeck2.c $(srcdir)/cp/xref.c\n \n cc1plus$(exeext): $(P) $(CXX_SRCS) $(LIBDEPS) stamp-objlist c-common.o \\\n         c-pragma.o $(srcdir)/cp/cp-tree.h $(srcdir)/cp/cp-tree.def \\"}, {"sha": "6d9a6a97f8bd8470b58a8cfa1133407002b48e0f", "filename": "gcc/cp/Makefile.in", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1f6e1acc0f2017e81282604bda62db1b2b865075/gcc%2Fcp%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1f6e1acc0f2017e81282604bda62db1b2b865075/gcc%2Fcp%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FMakefile.in?ref=1f6e1acc0f2017e81282604bda62db1b2b865075", "patch": "@@ -176,7 +176,7 @@ INCLUDES = -I. -I.. -I$(srcdir) -I$(srcdir)/.. -I$(srcdir)/../config -I$(srcdir)\n CXX_OBJS = call.o decl.o errfn.o expr.o pt.o typeck2.o \\\n  class.o decl2.o error.o lex.o parse.o ptree.o rtti.o spew.o typeck.o cvt.o \\\n  except.o friend.o init.o method.o search.o semantics.o tree.o xref.o \\\n- repo.o dump.o optimize.o @extra_cxx_objs@\n+ repo.o dump.o optimize.o mangle.o @extra_cxx_objs@\n \n # Language-independent object files.\n OBJS = `cat ../stamp-objlist` ../c-common.o ../c-pragma.o\n@@ -311,6 +311,7 @@ dump.o: dump.c $(CXX_TREE_H)\n optimize.o: optimize.c $(CXX_TREE_H) \\\n   $(srcdir)/../rtl.h $(srcdir)/../integrate.h ../insn-config.h \\\n   $(srcdir)/../input.h\n+mangle.o: mangle.c $(CXX_TREE_H) $(srcdir)/../toplev.h\n \n #\f\n # These exist for maintenance purposes."}, {"sha": "8d74b4426d59a42e5c692de7d0e2319e7edc0ed2", "filename": "gcc/cp/class.c", "status": "modified", "additions": 20, "deletions": 5, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1f6e1acc0f2017e81282604bda62db1b2b865075/gcc%2Fcp%2Fclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1f6e1acc0f2017e81282604bda62db1b2b865075/gcc%2Fcp%2Fclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fclass.c?ref=1f6e1acc0f2017e81282604bda62db1b2b865075", "patch": "@@ -83,6 +83,10 @@ typedef struct vcall_offset_data_s\n static int current_class_stack_size;\n static class_stack_node_t current_class_stack;\n \n+/* An array of all local classes present in this translation unit, in\n+   declaration order.  */\n+varray_type local_classes;\n+\n static tree get_vfield_name PARAMS ((tree));\n static void finish_struct_anon PARAMS ((tree));\n static tree build_vbase_pointer PARAMS ((tree, tree));\n@@ -630,8 +634,11 @@ static tree\n get_vtable_name (type)\n      tree type;\n {\n-  return build_overload_with_type (get_identifier (VTABLE_NAME_PREFIX),\n-\t\t\t\t   type);\n+  if (flag_new_abi)\n+    return mangle_vtbl_for_type (type);\n+  else\n+    return build_overload_with_type (get_identifier (VTABLE_NAME_PREFIX),\n+\t\t\t\t     type);\n }\n \n /* Return an IDENTIFIER_NODE for the name of the virtual table table\n@@ -641,8 +648,11 @@ tree\n get_vtt_name (type)\n      tree type;\n {\n-  return build_overload_with_type (get_identifier (VTT_NAME_PREFIX),\n-\t\t\t\t   type);\n+  if (flag_new_abi)\n+    return mangle_vtt_for_type (type);\n+  else\n+    return build_overload_with_type (get_identifier (VTT_NAME_PREFIX),\n+\t\t\t\t     type);\n }\n \n /* Return the offset to the main vtable for a given base BINFO.  */\n@@ -5296,6 +5306,8 @@ init_class_processing ()\n   current_class_stack \n     = (class_stack_node_t) xmalloc (current_class_stack_size \n \t\t\t\t    * sizeof (struct class_stack_node));\n+  VARRAY_TREE_INIT (local_classes, 8, \"local_classes\");\n+  ggc_add_tree_varray_root (&local_classes, 1);\n \n   access_default_node = build_int_2 (0, 0);\n   access_public_node = build_int_2 (ak_public, 0);\n@@ -6698,7 +6710,10 @@ build_ctor_vtbl_group (binfo, t)\n   tree id;\n \n   /* See if we've already create this construction vtable group.  */\n-  id = get_ctor_vtbl_name (t, binfo);\n+  if (flag_new_abi)\n+    id = mangle_ctor_vtbl_for_type (t, binfo);\n+  else\n+    id = get_ctor_vtbl_name (t, binfo);\n   if (IDENTIFIER_GLOBAL_VALUE (id))\n     return;\n "}, {"sha": "fa03358cf4a893b420d148438f8f258076893d86", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 37, "deletions": 4, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1f6e1acc0f2017e81282604bda62db1b2b865075/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1f6e1acc0f2017e81282604bda62db1b2b865075/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=1f6e1acc0f2017e81282604bda62db1b2b865075", "patch": "@@ -588,6 +588,7 @@ enum cp_tree_index\n     CPTI_PFN_OR_DELTA2_IDENTIFIER,\n     CPTI_VPTR_IDENTIFIER,\n     CPTI_PUSH_EXCEPTION_IDENTIFIER,\n+    CPTI_STD_IDENTIFIER,\n \n     CPTI_LANG_NAME_C,\n     CPTI_LANG_NAME_CPLUSPLUS,\n@@ -707,6 +708,8 @@ extern tree cp_global_trees[CPTI_MAX];\n /* The name of the function to call to push an exception onto the\n    exception stack.  */\n #define cp_push_exception_identifier    cp_global_trees[CPTI_PUSH_EXCEPTION_IDENTIFIER]\n+/* The name of the std namespace.  */\n+#define std_identifier                  cp_global_trees[CPTI_STD_IDENTIFIER]\n \n #define lang_name_c                     cp_global_trees[CPTI_LANG_NAME_C]\n #define lang_name_cplusplus             cp_global_trees[CPTI_LANG_NAME_CPLUSPLUS]\n@@ -1968,8 +1971,7 @@ struct lang_decl\n #define DECL_COPY_CONSTRUCTOR_P(NODE) \\\n   (DECL_CONSTRUCTOR_P (NODE) && copy_args_p (NODE))\n \n-/* There ought to be a better way to find out whether or not something is\n-   a destructor.  */\n+/* Nonzero if NODE is a destructor.  */\n #define DECL_DESTRUCTOR_P(NODE)\t\t\t\t\\\n   (DECL_LANG_SPECIFIC (NODE)->decl_flags.destructor_attr)\n \n@@ -2118,6 +2120,13 @@ struct lang_decl\n    && CP_TYPE_CONST_P (TREE_TYPE (TREE_VALUE \t\t\t\t \\\n \t\t\t\t  (TYPE_ARG_TYPES (TREE_TYPE (NODE))))))\n \n+/* Nonzero for FUNCTION_DECL means that this member function\n+   has `this' as volatile X *const.  */\n+#define DECL_VOLATILE_MEMFUNC_P(NODE)\t\t\t\t\t \\\n+  (DECL_NONSTATIC_MEMBER_FUNCTION_P (NODE)\t\t\t\t \\\n+   && CP_TYPE_VOLATILE_P (TREE_TYPE (TREE_VALUE\t\t\t\t \\\n+\t\t\t\t  (TYPE_ARG_TYPES (TREE_TYPE (NODE))))))\n+\n /* Nonzero for a DECL means that this member is a non-static member.  */\n #define DECL_NONSTATIC_MEMBER_P(NODE) \t\t\\\n   ((TREE_CODE (NODE) == FUNCTION_DECL \t\t\\\n@@ -2209,7 +2218,7 @@ struct lang_decl\n #define DECL_FUNCTION_SCOPE_P(NODE) \\\n   (DECL_CONTEXT (NODE) \\\n    && TREE_CODE (DECL_CONTEXT (NODE)) == FUNCTION_DECL)\n-     \n+\n /* For a NAMESPACE_DECL: the list of using namespace directives\n    The PURPOSE is the used namespace, the value is the namespace\n    that is the common ancestor. */\n@@ -2226,6 +2235,12 @@ struct lang_decl\n #define ORIGINAL_NAMESPACE(NODE)  \\\n   (DECL_NAMESPACE_ALIAS (NODE) ? DECL_NAMESPACE_ALIAS (NODE) : (NODE))\n \n+/* Non-zero if NODE is the std namespace.  */\n+#define DECL_NAMESPACE_STD_P(NODE)\t\t\t\\\n+  (TREE_CODE (NODE) == NAMESPACE_DECL\t\t\t\\\n+   && CP_DECL_CONTEXT (NODE) == global_namespace\t\\\n+   && DECL_NAME (NODE) == std_identifier)\n+\n /* In a non-local VAR_DECL with static storage duration, this is the\n    initialization priority.  If this value is zero, the NODE will be\n    initialized at the DEFAULT_INIT_PRIORITY.  */\n@@ -3396,6 +3411,10 @@ extern int current_class_depth;\n /* Points to the name of that function. May not be the DECL_NAME\n    of CURRENT_FUNCTION_DECL due to overloading */\n extern tree original_function_name;\n+\n+/* An array of all local classes present in this translation unit, in\n+   declaration order.  */\n+extern varray_type local_classes;\n \f\n /* Here's where we control how name mangling takes place.  */\n \n@@ -4355,7 +4374,7 @@ extern void print_candidates                    PARAMS ((tree));\n extern int instantiate_pending_templates        PARAMS ((void));\n extern tree tsubst_default_argument             PARAMS ((tree, tree, tree));\n extern tree most_general_template\t\tPARAMS ((tree));\n-\n+extern tree get_mostly_instantiated_function_type PARAMS ((tree, tree *, tree *));\n extern int processing_template_parmlist;\n \n /* in repo.c */\n@@ -4718,6 +4737,20 @@ extern void GNU_xref_member\t\t\tPARAMS ((tree, tree));\n /* in dump.c */\n extern void dump_node_to_file                   PARAMS ((tree, const char *));\n \n+/* in mangle.c */\n+extern void init_mangle                         PARAMS ((void));\n+extern tree mangle_decl                         PARAMS ((tree));\n+extern const char *mangle_type_string           PARAMS ((tree));\n+extern tree mangle_type                         PARAMS ((tree));\n+extern tree mangle_typeinfo_for_type            PARAMS ((tree));\n+extern tree mangle_typeinfo_string_for_type     PARAMS ((tree));\n+extern tree mangle_vtbl_for_type                PARAMS ((tree));\n+extern tree mangle_vtt_for_type                 PARAMS ((tree));\n+extern tree mangle_ctor_vtbl_for_type           PARAMS ((tree, tree));\n+extern tree mangle_thunk                        PARAMS ((tree, int, int)); \n+extern tree mangle_conv_op_name_for_type        PARAMS ((tree));\n+extern tree mangle_guard_variable               PARAMS ((tree));\n+\n /* -- end of C++ */\n \n #endif /* not _CP_TREE_H */"}, {"sha": "5aff843f539dba7924dc607f4922d8ada8e31a2e", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 57, "deletions": 20, "changes": 77, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1f6e1acc0f2017e81282604bda62db1b2b865075/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1f6e1acc0f2017e81282604bda62db1b2b865075/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=1f6e1acc0f2017e81282604bda62db1b2b865075", "patch": "@@ -2881,9 +2881,24 @@ pushtag (name, type, globalize)\n \n \t  TYPE_CONTEXT (type) = DECL_CONTEXT (d);\n \t  DECL_ASSEMBLER_NAME (d) = DECL_NAME (d);\n-\t  if (!uses_template_parms (type))\n-\t    DECL_ASSEMBLER_NAME (d)\n-\t      = get_identifier (build_overload_name (type, 1, 1));\n+\n+\t  /* If this is a local class, keep track of it.  We need this\n+\t     information for name-mangling, and so that it is possible to find\n+\t     all function definitions in a translation unit in a convenient\n+\t     way.  (It's otherwise tricky to find a member function definition\n+\t     it's only pointed to from within a local class.)  */\n+\t  if (TYPE_CONTEXT (type) \n+\t      && TREE_CODE (TYPE_CONTEXT (type)) == FUNCTION_DECL)\n+\t    VARRAY_PUSH_TREE (local_classes, type);\n+\n+\t  if (!uses_template_parms (type)) \n+\t    {\n+\t      if (flag_new_abi)\n+\t\tDECL_ASSEMBLER_NAME (d) = mangle_type (type);\n+\t      else\n+\t\tDECL_ASSEMBLER_NAME (d)\n+\t\t  = get_identifier (build_overload_name (type, 1, 1));\n+\t    }\n         }\n       if (b->parm_flag == 2)\n \t{\n@@ -6229,6 +6244,7 @@ initialize_predefined_identifiers ()\n     { \"_vptr\", &vptr_identifier, 0 },\n     { \"__cp_push_exception\", &cp_push_exception_identifier, 0 },\n     { \"__vtt_parm\", &vtt_parm_identifier, 0 },\n+    { \"std\", &std_identifier, 0 },\n     { NULL, NULL, 0 }\n   };\n \n@@ -6577,7 +6593,8 @@ init_decl_processing ()\n   record_builtin_type (RID_MAX, NULL_PTR, vtbl_ptr_type_node);\n \n   std_node = build_decl (NAMESPACE_DECL,\n-\t\t\t get_identifier (flag_honor_std ? \"fake std\":\"std\"),\n+\t\t\t flag_honor_std \n+\t\t\t ? get_identifier (\"fake std\") : std_identifier,\n \t\t\t void_type_node);\n   pushdecl (std_node);\n   \n@@ -7246,7 +7263,7 @@ start_decl (declarator, declspecs, initialized, attributes, prefix_attributes)\n       /* cp_finish_decl sets DECL_EXTERNAL if DECL_IN_AGGR_P is set.  */\n       DECL_IN_AGGR_P (decl) = 0;\n       if ((DECL_LANG_SPECIFIC (decl) && DECL_USE_TEMPLATE (decl))\n-\t  || CLASSTYPE_USE_TEMPLATE (context))\n+\t  || CLASSTYPE_TEMPLATE_INSTANTIATION (context))\n \t{\n \t  SET_DECL_TEMPLATE_SPECIALIZATION (decl);\n \t  /* [temp.expl.spec] An explicit specialization of a static data\n@@ -9086,7 +9103,16 @@ grokvardecl (type, declarator, specbits_in, initialized, constp, in_namespace)\n       type = TREE_TYPE (type);\n       decl = build_lang_decl (VAR_DECL, declarator, type);\n       DECL_CONTEXT (decl) = basetype;\n-      DECL_ASSEMBLER_NAME (decl) = build_static_name (basetype, declarator);\n+      /* DECL_ASSEMBLER_NAME is needed only for full-instantiated\n+\t templates.  */\n+      if (!uses_template_parms (decl))\n+\t{\n+\t  if (flag_new_abi)\n+\t    DECL_ASSEMBLER_NAME (decl) = mangle_decl (decl);\n+\t  else\n+\t    DECL_ASSEMBLER_NAME (decl) = build_static_name (basetype,\n+\t\t\t\t\t\t\t    declarator);\n+\t}\n     }\n   else\n     {\n@@ -9110,8 +9136,14 @@ grokvardecl (type, declarator, specbits_in, initialized, constp, in_namespace)\n \tset_decl_namespace (decl, context, 0);\n \n       context = DECL_CONTEXT (decl);\n-      if (declarator && context && current_lang_name != lang_name_c)\n-\tDECL_ASSEMBLER_NAME (decl) = build_static_name (context, declarator);\n+      if (declarator && context && current_lang_name != lang_name_c) \n+\t{\n+\t  if (flag_new_abi)\n+\t    DECL_ASSEMBLER_NAME (decl) = mangle_decl (decl);\n+\t  else\n+\t    DECL_ASSEMBLER_NAME (decl) \n+\t      = build_static_name (context, declarator);\n+\t}\n     }\n \n   if (in_namespace)\n@@ -11146,19 +11178,24 @@ grokdeclarator (declarator, declspecs, decl_context, initialized, attrlist)\n \t    DECL_NAME (CLASSTYPE_TI_TEMPLATE (type))\n \t      = TYPE_IDENTIFIER (type);\n \n-\t  /* XXX Temporarily set the scope.\n-\t     When returning, start_decl expects it as NULL_TREE,\n-\t     and will then then set it using pushdecl. */\n-\t  my_friendly_assert (DECL_CONTEXT (decl) == NULL_TREE, 980404);\n-\t  if (current_class_type)\n-\t    DECL_CONTEXT (decl) = current_class_type;\n+\t  if (flag_new_abi) \n+\t    DECL_ASSEMBLER_NAME (decl) = mangle_type (type);\n \t  else\n-\t    DECL_CONTEXT (decl) = FROB_CONTEXT (current_namespace);\n-\n-\t  DECL_ASSEMBLER_NAME (decl) = DECL_NAME (decl);\n-\t  DECL_ASSEMBLER_NAME (decl)\n-\t    = get_identifier (build_overload_name (type, 1, 1));\n-\t  DECL_CONTEXT (decl) = NULL_TREE;\n+\t    {\n+\t      /* XXX Temporarily set the scope.\n+\t\t When returning, start_decl expects it as NULL_TREE,\n+\t\t and will then then set it using pushdecl. */\n+\t      my_friendly_assert (DECL_CONTEXT (decl) == NULL_TREE, 980404);\n+\t      if (current_class_type)\n+\t\tDECL_CONTEXT (decl) = current_class_type;\n+\t      else\n+\t\tDECL_CONTEXT (decl) = FROB_CONTEXT (current_namespace);\n+\t      \n+\t      DECL_ASSEMBLER_NAME (decl) = DECL_NAME (decl);\n+\t      DECL_ASSEMBLER_NAME (decl)\n+\t\t= get_identifier (build_overload_name (type, 1, 1));\n+\t      DECL_CONTEXT (decl) = NULL_TREE;\n+\t    }\n \n \t  /* FIXME remangle member functions; member functions of a\n \t     type with external linkage have external linkage.  */"}, {"sha": "95702d60d6f93d393a898afd7871d794fa740b5a", "filename": "gcc/cp/decl2.c", "status": "modified", "additions": 43, "deletions": 15, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1f6e1acc0f2017e81282604bda62db1b2b865075/gcc%2Fcp%2Fdecl2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1f6e1acc0f2017e81282604bda62db1b2b865075/gcc%2Fcp%2Fdecl2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl2.c?ref=1f6e1acc0f2017e81282604bda62db1b2b865075", "patch": "@@ -1116,7 +1116,12 @@ grokclassfn (ctype, function, flags, quals)\n   if (flags == DTOR_FLAG)\n     {\n       DECL_DESTRUCTOR_P (function) = 1;\n-      DECL_ASSEMBLER_NAME (function) = build_destructor_name (ctype);\n+\n+      if (flag_new_abi) \n+\tset_mangled_name_for_decl (function);\n+      else\n+\tDECL_ASSEMBLER_NAME (function) = build_destructor_name (ctype);\n+\n       TYPE_HAS_DESTRUCTOR (ctype) = 1;\n     }\n   else\n@@ -1578,15 +1583,20 @@ finish_static_data_member_decl (decl, init, asmspec_tree, flags)\n \n   my_friendly_assert (TREE_PUBLIC (decl), 0);\n \n+  DECL_CONTEXT (decl) = current_class_type;\n+\n   /* We cannot call pushdecl here, because that would fill in the\n      decl of our TREE_CHAIN.  Instead, we modify cp_finish_decl to do\n      the right thing, namely, to put this decl out straight away.  */\n   /* current_class_type can be NULL_TREE in case of error.  */\n   if (!asmspec && current_class_type)\n     {\n       DECL_INITIAL (decl) = error_mark_node;\n-      DECL_ASSEMBLER_NAME (decl)\n-\t= build_static_name (current_class_type, DECL_NAME (decl));\n+      if (flag_new_abi)\n+\tDECL_ASSEMBLER_NAME (decl) = mangle_decl (decl);\n+      else\n+\tDECL_ASSEMBLER_NAME (decl) \n+\t  = build_static_name (current_class_type, DECL_NAME (decl));\n     }\n   if (! processing_template_decl)\n     {\n@@ -1611,7 +1621,6 @@ finish_static_data_member_decl (decl, init, asmspec_tree, flags)\n     TREE_USED (decl) = 1;\n   DECL_INITIAL (decl) = init;\n   DECL_IN_AGGR_P (decl) = 1;\n-  DECL_CONTEXT (decl) = current_class_type;\n \n   cp_finish_decl (decl, init, asmspec_tree, flags);\n }\n@@ -1717,9 +1726,14 @@ grokfield (declarator, declspecs, init, asmspec_tree, attrlist)\n       /* Now that we've updated the context, we need to remangle the\n \t name for this TYPE_DECL.  */\n       DECL_ASSEMBLER_NAME (value) = DECL_NAME (value);\n-      if (!uses_template_parms (value))\n-\tDECL_ASSEMBLER_NAME (value) =\n-\t  get_identifier (build_overload_name (TREE_TYPE (value), 1, 1));\n+      if (!uses_template_parms (value)) \n+\t{\n+\t  if (flag_new_abi)\n+\t    DECL_ASSEMBLER_NAME (value) = mangle_type (TREE_TYPE (value));\n+\t  else\n+\t    DECL_ASSEMBLER_NAME (value) =\n+\t      get_identifier (build_overload_name (TREE_TYPE (value), 1, 1));\n+\t}\n \n       if (processing_template_decl)\n \tvalue = push_template_decl (value);\n@@ -1905,7 +1919,10 @@ grokoptypename (declspecs, declarator)\n      tree declspecs, declarator;\n {\n   tree t = grokdeclarator (declarator, declspecs, TYPENAME, 0, NULL_TREE);\n-  return build_typename_overload (t);\n+  if (flag_new_abi)\n+    return mangle_conv_op_name_for_type (t);\n+  else\n+    return build_typename_overload (t);\n }\n \n /* When a function is declared with an initializer,\n@@ -2856,16 +2873,25 @@ build_cleanup (decl)\n   return temp;\n }\n \n+/* Returns the initialization guard variable for the non-local\n+   variable DECL.  */\n+\n static tree\n-get_sentry (base)\n-     tree base;\n+get_sentry (decl)\n+     tree decl;\n {\n-  tree sname = get_id_2 (\"__sn\", base);\n+  tree sname;\n+  tree sentry;\n+\n+  if (!flag_new_abi)\n+    sname = get_id_2 (\"__sn\", DECL_ASSEMBLER_NAME (decl));\n+  else\n+    sname = mangle_guard_variable (decl);\n+\n   /* For struct X foo __attribute__((weak)), there is a counter\n      __snfoo. Since base is already an assembler name, sname should\n      be globally unique */\n-  tree sentry = IDENTIFIER_GLOBAL_VALUE (sname);\n-\n+  sentry = IDENTIFIER_GLOBAL_VALUE (sname);\n   if (! sentry)\n     {\n       sentry = build_decl (VAR_DECL, sname, integer_type_node);\n@@ -3239,15 +3265,17 @@ start_static_initialization_or_destruction (decl, initp)\n   cond = build_binary_op (TRUTH_ANDIF_EXPR, cond, init_cond);\n \n   /* We need a sentry if this is an object with external linkage that\n-     might be initialized in more than one place.  */\n+     might be initialized in more than one place.  (For example, a\n+     static data member of a template, when the data member requires\n+     construction.)  */\n   if (TREE_PUBLIC (decl) && (DECL_COMMON (decl) \n \t\t\t     || DECL_ONE_ONLY (decl)\n \t\t\t     || DECL_WEAK (decl)))\n     {\n       tree sentry;\n       tree sentry_cond;\n \n-      sentry = get_sentry (DECL_ASSEMBLER_NAME (decl));\n+      sentry = get_sentry (decl);\n \n       /* We do initializations only if the SENTRY is zero, i.e., if we\n \t are the first to initialize the variable.  We do destructions"}, {"sha": "42a53903ee315dbd84115874500e271706a559a9", "filename": "gcc/cp/expr.c", "status": "modified", "additions": 0, "deletions": 79, "changes": 79, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1f6e1acc0f2017e81282604bda62db1b2b865075/gcc%2Fcp%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1f6e1acc0f2017e81282604bda62db1b2b865075/gcc%2Fcp%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fexpr.c?ref=1f6e1acc0f2017e81282604bda62db1b2b865075", "patch": "@@ -32,10 +32,6 @@ Boston, MA 02111-1307, USA.  */\n #include \"except.h\"\n #include \"tm_p.h\"\n \n-#if 0\n-static tree extract_aggr_init PARAMS ((tree, tree));\n-static tree extract_scalar_init PARAMS ((tree, tree));\n-#endif\n static rtx cplus_expand_expr PARAMS ((tree, rtx, enum machine_mode,\n \t\t\t\t    enum expand_modifier));\n \n@@ -202,86 +198,11 @@ fixup_result_decl (decl, result)\n     }\n }\n \n-#if 0\n-/* Expand this initialization inline and see if it's simple enough that\n-   it can be done at compile-time.  */\n-\n-static tree\n-extract_aggr_init (decl, init)\n-     tree decl, init;\n-{\n-  return 0;\n-}\n-\n-static tree\n-extract_scalar_init (decl, init)\n-     tree decl, init;\n-{\n-  rtx value, insns, insn;\n-  extern struct obstack temporary_obstack;\n-  tree t = NULL_TREE;\n-\n-  start_sequence ();\n-  value = expand_expr (init, NULL_RTX, VOIDmode, 0);\n-  insns = get_insns ();\n-  end_sequence ();\n-  reg_scan (insns, max_reg_num (), 0);\n-  jump_optimize (insns, 0, 0, 1);\n-\n-  for (insn = insns; insn; insn = NEXT_INSN (insn))\n-    {\n-      rtx r, to;\n-\n-      if (GET_CODE (insn) == NOTE)\n-\tcontinue;\n-      else if (GET_CODE (insn) != INSN)\n-\treturn 0;\n-\n-      r = PATTERN (insn);\n-      if (GET_CODE (r) != SET)\n-\treturn 0;\n-\n-      to = XEXP (r, 0);\n-\n-      if (! (to == value\n-\t     || (GET_CODE (to) == SUBREG && XEXP (to, 0) == value)))\n-\treturn 0;\n-\n-      r = XEXP (r, 1);\n-\n-      switch (GET_CODE (r))\n-\t{\n-\tcase CONST_INT:\n-\t  t = build_int_2 (XEXP (r, 0), 0);\n-\t  break;\n-\tdefault:\n-\t  return 0;\n-\t}\n-    }\n-\n-  return t; \n-}\n-#endif\n-\n int\n extract_init (decl, init)\n      tree decl ATTRIBUTE_UNUSED, init ATTRIBUTE_UNUSED;\n {\n   return 0;\n-\n-#if 0\n-  if (IS_AGGR_TYPE (TREE_TYPE (decl))\n-      || TREE_CODE (TREE_TYPE (decl)) == ARRAY_TYPE)\n-    init = extract_aggr_init (decl, init);\n-  else\n-    init = extract_scalar_init (decl, init);\n-\n-  if (init == NULL_TREE)\n-    return 0;\n-\n-  DECL_INITIAL (decl) = init;\n-  return 1;\n-#endif\n }\n \n void"}, {"sha": "d4bd066cd0990610819743f4f785e4c4a4be5802", "filename": "gcc/cp/mangle.c", "status": "added", "additions": 2128, "deletions": 0, "changes": 2128, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1f6e1acc0f2017e81282604bda62db1b2b865075/gcc%2Fcp%2Fmangle.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1f6e1acc0f2017e81282604bda62db1b2b865075/gcc%2Fcp%2Fmangle.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fmangle.c?ref=1f6e1acc0f2017e81282604bda62db1b2b865075", "patch": "@@ -0,0 +1,2128 @@\n+/* Name mangling for the new standard C++ ABI.\n+   Copyright (C) 2000 Free Software Foundation, Inc.\n+   Written by Alex Samuel <sameul@codesourcery.com>\n+\n+   This file is part of GNU CC.\n+\n+   GNU CC is free software; you can redistribute it and/or modify it\n+   under the terms of the GNU General Public License as published by\n+   the Free Software Foundation; either version 2, or (at your option)\n+   any later version.\n+\n+   GNU CC is distributed in the hope that it will be useful, but\n+   WITHOUT ANY WARRANTY; without even the implied warranty of\n+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+   General Public License for more details.\n+\n+   You should have received a copy of the GNU General Public License\n+   along with GNU CC; see the file COPYING.  If not, write to the Free\n+   Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n+   02111-1307, USA.  */\n+\n+/* This file implements mangling of C++ names according to the IA64\n+   C++ ABI specification.  A mangled name encodes a function or\n+   variable's name, scope, type, and/or template arguments into a text\n+   identifier.  This identifier is used as the function's or\n+   variable's linkage name, to preserve compatibility between C++'s\n+   language features (templates, scoping, and overloading) and C\n+   linkers.\n+\n+   Additionally, g++ uses mangled names internally.  To support this,\n+   mangling of types is allowed, even though the mangled name of a\n+   type should not appear by itself as an exported name.  Ditto for\n+   uninstantiated templates.\n+\n+   The primary entry point for this module is mangle_decl, which\n+   returns an identifier containing the mangled name for a decl.\n+   Additional entry points are provided to build mangled names of\n+   particular constructs when the appropriate decl for that construct\n+   is not available.  These are:\n+\n+     mangle_typeinfo_for_type:        typeinfo data\n+     mangle_typeinfo_string_for_type: typeinfo type name\n+     mangle_vtbl_for_type:            virtual table data\n+     mangle_vtt_for_type:             VTT data\n+     mangle_ctor_vtbl_for_type:       `C-in-B' constructor virtual table data\n+     mangle_thunk:                    thunk function or entry\n+\n+*/\n+\n+#include \"config.h\"\n+#include \"system.h\"\n+#include \"tree.h\"\n+#include \"cp-tree.h\"\n+#include \"obstack.h\"\n+#include \"toplev.h\"\n+#include \"varray.h\"\n+\n+/* Debugging support.  */\n+\n+/* Define DEBUG_MANGLE to enable very verbose trace messages.  */\n+#ifndef DEBUG_MANGLE\n+#define DEBUG_MANGLE 0\n+#endif\n+\n+/* Macros for tracing the write_* functions.  */\n+#if DEBUG_MANGLE\n+# define MANGLE_TRACE(FN, INPUT) \\\n+  fprintf (stderr, \"  %-24s: %-24s\\n\", FN, INPUT)\n+# define MANGLE_TRACE_TREE(FN, NODE) \\\n+  fprintf (stderr, \"  %-24s: %-24s (%p)\\n\", \\\n+           FN, tree_code_name[TREE_CODE (NODE)], (void *) NODE)\n+#else\n+# define MANGLE_TRACE(FN, INPUT)\n+# define MANGLE_TRACE_TREE(FN, NODE)\n+#endif\n+\n+/* Non-zero if NODE is a template-id.  */\n+#define DECL_TEMPLATE_ID_P(NODE)\t\t\t\t\\\n+  (DECL_LANG_SPECIFIC (NODE) != NULL \t\t\t\t\\\n+   && DECL_USE_TEMPLATE (NODE)\t\t\t\t\t\\\n+   && PRIMARY_TEMPLATE_P (DECL_TI_TEMPLATE (NODE)))\n+\n+/* Non-zero if NODE is a class template-id.  */\n+#define CLASSTYPE_TEMPLATE_ID_P(NODE)\t\t\t\t\\\n+  (TYPE_LANG_SPECIFIC (NODE) != NULL \t\t\t\t\\\n+   && CLASSTYPE_USE_TEMPLATE (NODE)\t\t\t\t\\\n+   && PRIMARY_TEMPLATE_P (CLASSTYPE_TI_TEMPLATE (NODE)))\n+\n+/* Things we only need one of.  This module is not reentrant.  */\n+static struct globals\n+{\n+  /* The name in which we're building the mangled name.  */\n+  struct obstack name_obstack;\n+\n+  /* The current innermost template args.  */\n+  tree template_args;\n+\n+  /* An array of the current substitution candidates, in the order\n+     we've seen them.  */\n+  varray_type substitutions;\n+} G;\n+\n+/* Indices into subst_identifiers.  These are identifiers used in\n+   special substitution rules.  */\n+typedef enum\n+{\n+  SUBID_ALLOCATOR,\n+  SUBID_BASIC_STRING,\n+  SUBID_CHAR_TRAITS,\n+  SUBID_BASIC_ISTREAM,\n+  SUBID_BASIC_OSTREAM,\n+  SUBID_BASIC_IOSTREAM,\n+  SUBID_MAX\n+}\n+substitution_identifier_index_t;\n+\n+/* For quick substitution checks, look up these common identifiers\n+   once only.  */\n+static tree subst_identifiers[SUBID_MAX];\n+\n+/* Single-letter codes for builtin integer types, defined in\n+   <builtin-type>.  These are indexed by integer_type_kind values.  */\n+static char\n+integer_type_codes[itk_none] =\n+{\n+  'c',  /* itk_char */\n+  'a',  /* itk_signed_char */\n+  'h',  /* itk_unsigned_char */\n+  's',  /* itk_short */\n+  't',  /* itk_unsigned_short */\n+  'i',  /* itk_int */\n+  'j',  /* itk_unsigned_int */\n+  'l',  /* itk_long */\n+  'm',  /* itk_unsigned_long */\n+  'x',  /* itk_long_long */\n+  'y'   /* itk_unsigned_long_long */\n+};\n+\n+/* Functions for handling substitutions.  */\n+\n+static inline tree canonicalize_for_substitution PARAMS ((tree));\n+static void add_substitution PARAMS ((tree));\n+static inline int is_std_substitution PARAMS ((tree, substitution_identifier_index_t));\n+static inline int is_std_substitution_char PARAMS ((tree, substitution_identifier_index_t));\n+static int find_substitution PARAMS ((tree));\n+\n+/* Functions for emitting mangled representations of things.  */\n+\n+static void write_mangled_name PARAMS ((tree));\n+static void write_encoding PARAMS ((tree));\n+static void write_name PARAMS ((tree));\n+static void write_unscoped_name PARAMS ((tree));\n+static void write_unscoped_template_name PARAMS ((tree));\n+static void write_nested_name PARAMS ((tree));\n+static void write_prefix PARAMS ((tree));\n+static void write_template_prefix PARAMS ((tree));\n+static void write_component PARAMS ((tree));\n+static void write_unqualified_name PARAMS ((tree));\n+static void write_source_name PARAMS ((tree));\n+static void write_number PARAMS ((int, int));\n+static void write_integer_cst PARAMS ((tree));\n+static void write_identifier PARAMS ((char *));\n+static void write_special_name_constructor PARAMS ((tree));\n+static void write_special_name_destructor PARAMS ((tree));\n+static void write_type PARAMS ((tree));\n+static int write_CV_qualifiers_for_type PARAMS ((tree));\n+static void write_builtin_type PARAMS ((tree));\n+static void write_function_type PARAMS ((tree, int));\n+static void write_bare_function_type PARAMS ((tree, int));\n+static void write_method_parms PARAMS ((tree, int));\n+static void write_class_enum_type PARAMS ((tree));\n+static void write_template_args PARAMS ((tree));\n+static void write_expression PARAMS ((tree));\n+static void write_template_arg_literal PARAMS ((tree));\n+static void write_template_arg PARAMS ((tree));\n+static void write_template_template_arg PARAMS ((tree));\n+static void write_array_type PARAMS ((tree));\n+static void write_pointer_to_member_type PARAMS ((tree));\n+static void write_template_param PARAMS ((tree));\n+static void write_template_template_param PARAMS ((tree));\n+static void write_substitution PARAMS ((int));\n+static int discriminator_for_local_entity PARAMS ((tree));\n+static int discriminator_for_string_literal PARAMS ((tree, tree));\n+static void write_discriminator PARAMS ((int));\n+static void write_local_name PARAMS ((tree, tree));\n+static void dump_substitution_candidates PARAMS ((void));\n+static const char *mangle_decl_string PARAMS ((tree));\n+\n+/* Control functions.  */\n+\n+static inline void start_mangling PARAMS ((void));\n+static inline const char *finish_mangling PARAMS ((void));\n+static tree mangle_special_for_type PARAMS ((tree, const char *));\n+\n+/* Append a single character to the end of the mangled\n+   representation.  */\n+#define write_char(CHAR)                                              \\\n+  obstack_1grow (&G.name_obstack, (CHAR))\n+\n+/* Append a NUL-terminated string to the end of the mangled\n+   representation.  */\n+#define write_string(STRING)                                          \\\n+  obstack_grow (&G.name_obstack, (STRING), strlen (STRING))\n+\n+/* Return the position at which the next character will be appended to\n+   the mangled representation.  */\n+#define mangled_position()                                              \\\n+  obstack_object_size (&G.name_obstack)\n+\n+/* Non-zero if NODE1__ and NODE2__ are both TREE_LIST nodes and have\n+   the same purpose (context, which may be a type) and value (template\n+   decl).  See write_template_prefix for more information on what this\n+   is used for.  */\n+#define NESTED_TEMPLATE_MATCH(NODE1, NODE2)                         \\\n+  (TREE_CODE (NODE1) == TREE_LIST                                     \\\n+   && TREE_CODE (NODE2) == TREE_LIST                                  \\\n+   && ((TYPE_P (TREE_PURPOSE (NODE1))                                 \\\n+        && same_type_p (TREE_PURPOSE (NODE1), TREE_PURPOSE (NODE2)))\\\n+       || TREE_PURPOSE (NODE1) == TREE_PURPOSE (NODE2))             \\\n+   && TREE_VALUE (NODE1) == TREE_VALUE (NODE2))\n+\n+/* Produce debugging output of current substitution candidates.  */\n+\n+static void\n+dump_substitution_candidates ()\n+{\n+  unsigned i;\n+\n+  fprintf (stderr, \"  ++ substitutions  \");\n+  for (i = 0; i < VARRAY_ACTIVE_SIZE (G.substitutions); ++i)\n+    {\n+      tree el = VARRAY_TREE (G.substitutions, i);\n+      const char *name = \"???\";\n+\n+      if (i > 0)\n+\tfprintf (stderr, \"                    \");\n+      if (DECL_P (el))\n+\tname = IDENTIFIER_POINTER (DECL_NAME (el));\n+      else if (TREE_CODE (el) == TREE_LIST)\n+\tname = IDENTIFIER_POINTER (DECL_NAME (TREE_VALUE (el)));\n+      else if (TYPE_NAME (el))\n+\tname = IDENTIFIER_POINTER (DECL_NAME (TYPE_NAME (el)));\n+      fprintf (stderr, \" S%d_ = \", i - 1);\n+      if (TYPE_P (el) && \n+\t  (CP_TYPE_RESTRICT_P (el) \n+\t   || CP_TYPE_VOLATILE_P (el) \n+\t   || CP_TYPE_CONST_P (el)))\n+\tfprintf (stderr, \"CV-\");\n+      fprintf (stderr, \"%s (%s at %p)\\n\", \n+\t       name, tree_code_name[TREE_CODE (el)], (void *) el);\n+    }\n+}\n+\n+/* Both decls and types can be substitution candidates, but sometimes\n+   they refer to the same thing.  For instance, a TYPE_DECL and\n+   RECORD_TYPE for the same class refer to the same thing, and should\n+   be treated accordinginly in substitutions.  This function returns a\n+   canonicalized tree node representing NODE that is used when adding\n+   and substitution candidates and finding matches.  */\n+\n+static inline tree\n+canonicalize_for_substitution (node)\n+     tree node;\n+{\n+  /* For a TYPE_DECL, use the type instead.  */\n+  if (TREE_CODE (node) == TYPE_DECL)\n+    node = TREE_TYPE (node);\n+\n+  return node;\n+}\n+\n+/* Add NODE as a substitution candidate.  NODE must not already be on\n+   the list of candidates.  */\n+\n+static void\n+add_substitution (node)\n+     tree node;\n+{\n+  tree c;\n+\n+  if (DEBUG_MANGLE)\n+    fprintf (stderr, \"  ++ add_substitution (%s at %10p)\\n\", \n+\t     tree_code_name[TREE_CODE (node)], (void *) node);\n+\n+  /* Get the canonicalized substitution candidate for NODE.  */\n+  c = canonicalize_for_substitution (node);\n+  if (DEBUG_MANGLE && c != node)\n+    fprintf (stderr, \"  ++ using candidate (%s at %10p)\\n\",\n+\t     tree_code_name[TREE_CODE (node)], (void *) node);\n+  node = c;\n+\n+#if ENABLE_CHECKING\n+  /* Make sure NODE isn't already a candidate.  */\n+  {\n+    int i;\n+    for (i = VARRAY_ACTIVE_SIZE (G.substitutions); --i >= 0; )\n+      {\n+\ttree candidate = VARRAY_TREE (G.substitutions, i);\n+\tif ((DECL_P (node) \n+\t     && node == candidate)\n+\t    || (TYPE_P (node) \n+\t\t&& TYPE_P (candidate) \n+\t\t&& same_type_p (node, candidate)))\n+\t  my_friendly_abort (20000524);\n+      }\n+  }\n+#endif /* ENABLE_CHECKING */\n+\n+  /* Put the decl onto the varray of substitution candidates.  */\n+  VARRAY_PUSH_TREE (G.substitutions, node);\n+\n+  if (DEBUG_MANGLE)\n+    dump_substitution_candidates ();\n+}\n+\n+/* Helper function for find_substitution.  Returns non-zero if NODE,\n+   which may be a decl or a CLASS_TYPE, is a template-id with template\n+   name of substitution_index[INDEX] in the ::std namespace.  */\n+\n+static inline int \n+is_std_substitution (node, index)\n+     tree node;\n+     substitution_identifier_index_t index;\n+{\n+  tree type = NULL;\n+  tree decl = NULL;\n+\n+  if (DECL_P (node))\n+    {\n+      type = TREE_TYPE (node);\n+      decl = node;\n+    }\n+  else if (CLASS_TYPE_P (node))\n+    {\n+      type = node;\n+      decl = TYPE_NAME (node);\n+    }\n+  else \n+    /* These are not the droids you're looking for.  */\n+    return 0;\n+\n+  return \n+    DECL_NAMESPACE_STD_P (CP_DECL_CONTEXT (decl))\n+    && TYPE_LANG_SPECIFIC (type) \n+    && CLASSTYPE_USE_TEMPLATE (type)\n+    && (DECL_NAME (CLASSTYPE_TI_TEMPLATE (type)) \n+\t== subst_identifiers[index]);\n+}\n+\n+/* Helper function for find_substitution.  Returns non-zero if NODE,\n+   which may be a decl or a CLASS_TYPE, is the template-id\n+   ::std::identifier<char>, where identifier is\n+   substitution_index[INDEX].  */\n+\n+static inline int\n+is_std_substitution_char (node, index)\n+     tree node;\n+     substitution_identifier_index_t index;\n+{\n+  tree args;\n+  /* Check NODE's name is ::std::identifier.  */\n+  if (!is_std_substitution (node, index))\n+    return 0;\n+  /* Figure out its template args.  */\n+  if (DECL_P (node))\n+    args = DECL_TI_ARGS (node);  \n+  else if (CLASS_TYPE_P (node))\n+    args = CLASSTYPE_TI_ARGS (node);\n+  else\n+    /* Oops, not a template.  */\n+    return 0;\n+  /* NODE's template arg list should be <char>.  */\n+  return \n+    TREE_VEC_LENGTH (args) == 1\n+    && TREE_VEC_ELT (args, 0) == char_type_node;\n+}\n+\n+/* Check whether a substitution should be used to represent NODE in\n+   the mangling.\n+\n+   First, check standard special-case substitutions.\n+\n+     <substitution> ::= St     \n+         # ::std\n+\n+                    ::= Sa     \n+\t # ::std::allocator\n+\n+                    ::= Sb     \n+         # ::std::basic_string\n+\n+                    ::= Ss \n+         # ::std::basic_string<char,\n+\t\t\t       ::std::char_traits<char>,\n+\t\t\t       ::std::allocator<char> >\n+\n+                    ::= Si \n+         # ::std::basic_istream<char, ::std::char_traits<char> >\n+\n+                    ::= So \n+         # ::std::basic_ostream<char, ::std::char_traits<char> >\n+\n+                    ::= Sd \n+         # ::std::basic_iostream<char, ::std::char_traits<char> >   \n+\n+   Then examine the stack of currently available substitution\n+   candidates for entities appearing earlier in the same mangling\n+\n+   If a substitution is found, write its mangled representation and\n+   return non-zero.  If none is found, just return zero.  */\n+\n+static int\n+find_substitution (node)\n+     tree node;\n+{\n+  int i;\n+  int size = VARRAY_ACTIVE_SIZE (G.substitutions);\n+  tree decl;\n+  tree type;\n+\n+  if (DEBUG_MANGLE)\n+    fprintf (stderr, \"  ++ find_substitution (%s at %p)\\n\",\n+\t     tree_code_name[TREE_CODE (node)], (void *) node);\n+\n+  /* Obtain the canonicalized substitution representation for NODE.\n+     This is what we'll compare against.  */\n+  node = canonicalize_for_substitution (node);\n+\n+  /* Check for builtin substitutions.  */\n+\n+  decl = TYPE_P (node) ? TYPE_NAME (node) : node;\n+  type = TYPE_P (node) ? node : TREE_TYPE (node);\n+\n+  /* Check for std::allocator.  */\n+  if (decl && is_std_substitution (decl, SUBID_ALLOCATOR))\n+    {\n+      write_string (\"Sa\");\n+      return 1;\n+    }\n+\n+  /* Check for std::basic_string.  */\n+  if (decl && is_std_substitution (decl, SUBID_BASIC_STRING))\n+    {\n+      if (type)\n+\t{\n+\t  /* If this is a type (i.e. a fully-qualified template-id), \n+\t     check for \n+  \t         std::basic_string <char,\n+\t\t \t\t    std::char_traits<char>,\n+\t\t\t\t    std::allocator<char> > .  */\n+\t  if (CP_TYPE_QUALS (type) == TYPE_UNQUALIFIED\n+\t      && CLASSTYPE_USE_TEMPLATE (type))\n+\t    {\n+\t      tree args = CLASSTYPE_TI_ARGS (type);\n+\t      if (TREE_VEC_LENGTH (args) == 3\n+\t\t  && TREE_VEC_ELT (args, 0) == char_type_node\n+\t\t  && is_std_substitution_char (TREE_VEC_ELT (args, 1),\n+\t\t\t\t\t       SUBID_CHAR_TRAITS)\n+\t\t  && is_std_substitution_char (TREE_VEC_ELT (args, 2),\n+\t\t\t\t\t       SUBID_ALLOCATOR))\n+\t\t{\n+\t\t  write_string (\"Ss\");\n+\t\t  return 1;\n+\t\t}\n+\t    }\n+\t}\n+      else\n+\t/* Substitute for the template name only if this isn't a type.  */\n+\t{\n+\t  write_string (\"Sb\");\n+\t  return 1;\n+\t}\n+    }\n+\n+  /* Check for basic_{i,o,io}stream.  */\n+  if (type\n+      && CP_TYPE_QUALS (type) == TYPE_UNQUALIFIED\n+      && CLASS_TYPE_P (type)\n+      && CLASSTYPE_USE_TEMPLATE (type)\n+      && CLASSTYPE_TEMPLATE_INFO (type) != NULL)\n+    {\n+      /* First, check for the template \n+\t args <char, std::char_traits<char> > .  */\n+      tree args = CLASSTYPE_TI_ARGS (type);\n+      if (TREE_VEC_LENGTH (args) == 2\n+\t  && TREE_VEC_ELT (args, 0) == char_type_node\n+\t  && is_std_substitution_char (TREE_VEC_ELT (args, 1),\n+\t\t\t\t       SUBID_CHAR_TRAITS))\n+\t{\n+\t  /* Got them.  Is this basic_istream?  */\n+\t  tree name = DECL_NAME (CLASSTYPE_TI_TEMPLATE (type));\n+\t  if (name == subst_identifiers[SUBID_BASIC_ISTREAM])\n+\t    {\n+\t      write_string (\"Si\");\n+\t      return 1;\n+\t    }\n+\t  /* Or basic_ostream?  */\n+\t  else if (name == subst_identifiers[SUBID_BASIC_OSTREAM])\n+\t    {\n+\t      write_string (\"So\");\n+\t      return 1;\n+\t    }\n+\t  /* Or basic_iostream?  */\n+\t  else if (name == subst_identifiers[SUBID_BASIC_IOSTREAM])\n+\t    {\n+\t      write_string (\"Sd\");\n+\t      return 1;\n+\t    }\n+\t}\n+    }\n+\n+  /* Check for namespace std.  */\n+  if (decl&& DECL_NAMESPACE_STD_P (decl))\n+    {\n+      write_string (\"St\");\n+      return 1;\n+    }\n+\n+  /* Now check the list of available substitutions for this mangling\n+     operation.    */\n+\n+  for (i = 0; i < size; ++i)\n+    {\n+      tree candidate = VARRAY_TREE (G.substitutions, i);\n+      /* NODE is a matched to a candidate if it's the same decl node or\n+\t if it's the same type.  */\n+      if (decl == candidate\n+\t  || (TYPE_P (candidate) && type && TYPE_P (type)\n+\t      && same_type_p (type, candidate))\n+\t  || NESTED_TEMPLATE_MATCH (node, candidate))\n+\t{\n+\t  write_substitution (i);\n+\t  return 1;\n+\t}\n+    }\n+\n+  /* No substitution found.  */\n+  return 0;\n+}\n+\n+\n+/*  <mangled-name>      ::= _Z <encoding>  */\n+\n+static inline void\n+write_mangled_name (decl)\n+     tree decl;\n+{\n+  MANGLE_TRACE_TREE (\"mangled-name\", decl);\n+\n+  if (DECL_LANG_SPECIFIC (decl) && DECL_EXTERN_C_FUNCTION_P (decl))\n+    /* The standard notes:\n+         \"The <encoding> of an extern \"C\" function is treated like\n+\t global-scope data, i.e. as its <source-name> without a type.\"  */\n+    write_source_name (DECL_NAME (decl));\n+  else\n+    /* C++ name; needs to be mangled.  */\n+    {\n+      write_string (\"_Z\");\n+      write_encoding (decl);\n+    }\n+}\n+\n+/*   <encoding>\t\t::= <function name> <bare-function-type>\n+\t\t\t::= <data name>\n+\t\t\t::= <substitution>  */\n+\n+static void\n+write_encoding (decl)\n+     tree decl;\n+{\n+  MANGLE_TRACE_TREE (\"encoding\", decl);\n+\n+  if (find_substitution (decl))\n+    return;\n+\n+  if (DECL_LANG_SPECIFIC (decl) && DECL_EXTERN_C_FUNCTION_P (decl))\n+    {\n+      write_source_name (DECL_NAME (decl));\n+      return;\n+    }\n+\n+  write_name (decl);\n+  if (TREE_CODE (decl) == FUNCTION_DECL)\n+    {\n+      tree fn_type;\n+\n+      if (DECL_TEMPLATE_ID_P (decl))\n+\tfn_type = get_mostly_instantiated_function_type (decl, NULL, NULL);\n+      else\n+\tfn_type = TREE_TYPE (decl);\n+\n+      write_bare_function_type (fn_type, DECL_TEMPLATE_ID_P (decl));\n+    }\n+\n+  add_substitution (decl);\n+}\n+\n+/* <name> ::= <unscoped-name>\n+          ::= <unscoped-template-name> <template-args>\n+\t  ::= <nested-name>\n+\t  ::= <local-name>  */\n+\n+static void\n+write_name (decl)\n+     tree decl;\n+{\n+  tree context = CP_DECL_CONTEXT (decl);\n+\n+  MANGLE_TRACE_TREE (\"name\", decl);\n+\n+  /* Decls in :: or ::std scope are treated specially.  */\n+  if (context == global_namespace || DECL_NAMESPACE_STD_P (context))\n+    {\n+      if (decl && DECL_TEMPLATE_ID_P (decl))\n+\t{\n+\t  /* Templated decls get an <unqualified-template-name>.  */\n+\t  write_unscoped_template_name (DECL_TI_TEMPLATE (decl));\n+\t  write_template_args (DECL_TI_ARGS (decl));\n+\t}\n+      else if (TREE_CODE (decl) == TYPE_DECL \n+\t       && CLASSTYPE_TEMPLATE_ID_P (TREE_TYPE (decl)))\n+\t{\n+\t  tree type;\n+\n+\t  /* Templated decls get an <unqualified-template-name>.  */\n+\t  type = TREE_TYPE (decl);\n+\t  write_unscoped_template_name (TYPE_TI_TEMPLATE (type));\n+\t  write_template_args (TYPE_TI_ARGS (type));\n+\t}\n+      else\n+\t/* Everything else gets an <unqualified-name>.  */\n+\twrite_unscoped_name (decl);\n+    }\n+  /* Handle local names.  */\n+  else if (TREE_CODE (context) == FUNCTION_DECL)\n+    write_local_name (context, decl);\n+  /* Other decls get a <nested-name> to encode their scope.  */\n+  else\n+    write_nested_name (decl);\n+}\n+\n+/* <unscoped-name> ::= <unqualified-name>\n+                   ::= St <unqualified-name>   # ::std::  */\n+\n+static void\n+write_unscoped_name (decl)\n+     tree decl;\n+{\n+  tree context = CP_DECL_CONTEXT (decl);\n+\n+  MANGLE_TRACE_TREE (\"unscoped-name\", decl);\n+\n+  /* Is DECL in ::std?  */\n+  if (DECL_NAMESPACE_STD_P (context))\n+    {\n+      write_string (\"St\");\n+      write_unqualified_name (decl);\n+    }\n+  /* If not, it should be in the global namespace.  */\n+  else if (context == global_namespace || context == NULL)\n+    write_unqualified_name (decl);\n+  else \n+    my_friendly_abort (20000521);\n+}\n+\n+/* <unscoped-template-name> ::= <unscoped-name>\n+                            ::= <substitution>  */\n+\n+static void\n+write_unscoped_template_name (decl)\n+     tree decl;\n+{\n+  MANGLE_TRACE_TREE (\"unscoped-template-name\", decl);\n+\n+  if (find_substitution (decl))\n+    return;\n+  write_unscoped_name (decl);\n+  add_substitution (decl);\n+}\n+\n+/* Write the nested name, including CV-qualifiers, of DECL.\n+\n+   <nested-name> ::= N [<CV-qualifiers>] <prefix> <component> E  \n+                 ::= N [<CV-qualifiers>] <template-prefix> <template-args> E\n+\n+   <CV-qualifiers> ::= [r] [V] [K]  */\n+\n+static void\n+write_nested_name (decl)\n+     tree decl;\n+{\n+  MANGLE_TRACE_TREE (\"nested-name\", decl);\n+\n+  write_char ('N');\n+  \n+  /* Write CV-qualifiers, if this is a member function.  */\n+  if (TREE_CODE (decl) == FUNCTION_DECL \n+      && DECL_NONSTATIC_MEMBER_FUNCTION_P (decl))\n+    {\n+      if (DECL_VOLATILE_MEMFUNC_P (decl))\n+\twrite_char ('V');\n+      if (DECL_CONST_MEMFUNC_P (decl))\n+\twrite_char ('K');\n+    }\n+\n+  if (DECL_TEMPLATE_ID_P (decl))\n+    {\n+      write_template_prefix (decl);\n+      write_template_args (DECL_TI_ARGS (decl));\n+    }\n+  else if (CLASSTYPE_TEMPLATE_ID_P (TREE_TYPE (decl)))\n+    {\n+      write_template_prefix (decl);\n+      write_template_args (CLASSTYPE_TI_ARGS (TREE_TYPE (decl)));\n+    }\n+  else\n+    {\n+      write_prefix (DECL_CONTEXT (decl));\n+      write_component (decl);\n+    }\n+  write_char ('E');\n+}\n+\n+/* <prefix> ::= <prefix> <component>\n+            ::= <template-prefix> <template-args>\n+\t    ::= # empty\n+\t    ::= <substitution>  */\n+\n+static void\n+write_prefix (node)\n+     tree node;\n+{\n+  tree decl;\n+  tree type;\n+  tree context;\n+\n+  if (node == NULL\n+      || node == global_namespace)\n+    return;\n+\n+  MANGLE_TRACE_TREE (\"prefix\", node);\n+\n+  decl = DECL_P (node) ? node : TYPE_NAME (node);\n+  type = DECL_P (node) ? TREE_TYPE (node) : node;\n+  context = CP_DECL_CONTEXT (decl);\n+\n+  if (find_substitution (node))\n+    return;\n+\n+  /* Check if this is a template-id.  For a template member, the\n+     template info will be hanging off the decl.  */\n+  if (DECL_TEMPLATE_ID_P (decl))\n+    {\n+      write_template_prefix (decl);\n+      write_template_args (DECL_TI_ARGS (decl));\n+    }\n+  /* For a template class, the template info will be hanging off the\n+     type.  */\n+  else if (type && CLASSTYPE_TEMPLATE_ID_P (type))\n+    {\n+      write_template_prefix (type);\n+      write_template_args (CLASSTYPE_TI_ARGS (type));\n+    }\n+  else\n+    /* Not templated.  */\n+    {\n+      write_prefix (context);\n+      write_component (decl);\n+    }\n+\n+  add_substitution (node);\n+}\n+\n+/* <template-prefix> ::= <prefix> <template component>\n+                     ::= <substitution>  \n+\n+   Names of templates are substitution candidates.  For a nested\n+   template, though, the template name for the innermost name must\n+   have all the outer template levels instantiated.  For instance,\n+   consider\n+\n+     template<typename T> struct Outer\n+     {\n+       template<typename U> struct Inner {};\n+     };\n+\n+   The template name for `Inner' in `Outer<int>::Inner<float>' is\n+   `Outer<int>::Inner<U>'.  In g++, we don't instantiate the template\n+   levels separately, so there's no TEMPLATE_DECL available for this\n+   (there's only `Outer<T>::Inner<U>').\n+\n+   In order to get the substitutions right, we create a special\n+   TREE_LIST to represent the substitution candidate for a nested\n+   template.  The TREE_PURPOSE is the tempate's context, fully\n+   instantiated, and the TREE_VALUE is the TEMPLATE_DECL for the inner\n+   template.  \n+\n+   So, for the example above, `Inner' is represented as a substitution\n+   candidate by a TREE_LIST whose purpose is `Outer<int>' and whose\n+   value is `Outer<T>::Inner<U>'.  */\n+\n+static void\n+write_template_prefix (node)\n+     tree node;\n+{\n+  tree decl = DECL_P (node) ? node : TYPE_NAME (node);\n+  tree type = DECL_P (node) ? TREE_TYPE (node) : node;\n+  tree context = CP_DECL_CONTEXT (decl);\n+  tree template;\n+  tree substitution;\n+\n+  MANGLE_TRACE_TREE (\"template-prefix\", node);\n+\n+  /* Find the template decl.  */\n+  if (DECL_TEMPLATE_ID_P (decl))\n+    template = DECL_TI_TEMPLATE (decl);\n+  else if (CLASSTYPE_TEMPLATE_ID_P (type))\n+    template = CLASSTYPE_TI_TEMPLATE (type);\n+  else\n+    /* Oops, not a template.  */\n+    my_friendly_abort (20000524);\n+\n+  /* Build the substitution candidate TREE_LIST.  */\n+  substitution = build_tree_list (context, template);\n+\n+  if (find_substitution (substitution))\n+    return;\n+\n+  write_prefix (context);\n+  write_component (decl);\n+\n+  add_substitution (substitution);\n+}\n+\n+/* <component> ::= <unqualified-name>\n+               ::= <local-name> */\n+\n+static void\n+write_component (decl)\n+     tree decl;\n+{\n+  MANGLE_TRACE_TREE (\"component\", decl);\n+\n+  switch (TREE_CODE (decl))\n+    {\n+    case TEMPLATE_DECL:\n+    case NAMESPACE_DECL:\n+    case VAR_DECL:\n+    case TYPE_DECL:\n+    case FUNCTION_DECL:\n+    case FIELD_DECL:\n+      if (TREE_CODE (CP_DECL_CONTEXT (decl)) == FUNCTION_DECL)\n+\twrite_local_name (CP_DECL_CONTEXT (decl), decl);\n+      else\n+\twrite_unqualified_name (decl);\n+      break;\n+\n+    default:\n+      my_friendly_abort (2000509);\n+    }\n+}\n+\n+/* We don't need to handle thunks, vtables, or VTTs here.  Those are\n+   mangled through special entry points.  \n+\n+    <unqualified-name>  ::= <operator-name>\n+\t\t\t::= <special-name>  \n+\t\t\t::= <source-name>  */\n+\n+static void\n+write_unqualified_name (decl)\n+     tree decl;\n+{\n+  MANGLE_TRACE_TREE (\"unqualified-name\", decl);\n+\n+  if (DECL_LANG_SPECIFIC (decl) != NULL && DECL_CONSTRUCTOR_P (decl))\n+    write_special_name_constructor (decl);\n+  else if (DECL_LANG_SPECIFIC (decl) != NULL && DECL_DESTRUCTOR_P (decl))\n+    write_special_name_destructor (decl);\n+  else if (DECL_CONV_FN_P (decl)) \n+    {\n+      /* Conversion operator. Handle it right here.  \n+           <operator> ::= cv <type>  */\n+      write_string (\"cv\");\n+      write_type (TREE_TYPE (DECL_NAME (decl)));\n+    }\n+  else if (DECL_OVERLOADED_OPERATOR_P (decl))\n+    {\n+      operator_name_info_t *oni;\n+      if (DECL_ASSIGNMENT_OPERATOR_P (decl))\n+\toni = assignment_operator_name_info;\n+      else\n+\toni = operator_name_info;\n+      \n+      write_string (oni[DECL_OVERLOADED_OPERATOR_P (decl)].mangled_name);\n+    }\n+  else\n+    write_source_name (DECL_NAME (decl));\n+}\n+\n+/* Non-termial <source-name>.  IDENTIFIER is an IDENTIFIER_NODE.  \n+\n+     <source-name> ::= </length/ number> <identifier>  */\n+\n+static void\n+write_source_name (identifier)\n+     tree identifier;\n+{\n+  MANGLE_TRACE_TREE (\"source-name\", identifier);\n+\n+  /* Never write the whole template-id name including the template\n+     arguments; we only want the template name.  */\n+  if (IDENTIFIER_TEMPLATE (identifier))\n+    identifier = IDENTIFIER_TEMPLATE (identifier);\n+\n+  write_number (IDENTIFIER_LENGTH (identifier), 10);\n+  write_identifier (IDENTIFIER_POINTER (identifier));\n+}\n+\n+/* Non-terminal <number>.\n+\n+     <number> ::= [n] </decimal integer/>  */\n+\n+static void\n+write_number (number, base)\n+     int number;\n+     int base;\n+{\n+  static const char digits[] = \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ\";\n+  int n;\n+  int m = 1;\n+\n+  if (number < 0)\n+    {\n+      write_char ('n');\n+      number = -number;\n+    }\n+  \n+  n = number;\n+  while (n >= base)\n+    {\n+      n /= base;\n+      m *= base;\n+    }\n+\n+  while (m > 0)\n+    {\n+      int digit = number / m;\n+      write_char (digits[digit]);\n+      number -= digit * m;\n+      m /= base;\n+    }\n+\n+  my_friendly_assert (number == 0, 20000407);\n+}\n+\n+/* Write out an integeral CST in decimal.  */\n+\n+static inline void\n+write_integer_cst (cst)\n+     tree cst;\n+{\n+  write_number (tree_low_cst (cst, TREE_UNSIGNED (TREE_TYPE (cst))), 10);\n+}\n+\n+/* Non-terminal <identifier>.\n+\n+     <identifier> ::= </unqualified source code identifier>  */\n+\n+static void\n+write_identifier (identifier)\n+     char *identifier;\n+{\n+  MANGLE_TRACE (\"identifier\", identifier);\n+  write_string (identifier);\n+}\n+\n+/* Handle constructor productions of non-terminal <special-name>.\n+   CTOR is a constructor FUNCTION_DECL. \n+\n+     <special-name> ::= C1   # complete object constructor\n+                    ::= C2   # base object constructor\n+                    ::= C3   # complete object allocating constructor\n+                    ::= C4   # base object allocating constructor  \n+\n+   Currently, allocating constructors are never used. \n+\n+   We also need to provide unique mangled names (which should never be\n+   exported) for the constructor that takes an in-charge parameter,\n+   and for a constructor whose name is the same as its class's name.\n+   We use \"C*INTERNAL*\" for these.  */\n+\n+static void\n+write_special_name_constructor (ctor)\n+     tree ctor;\n+{\n+  if (DECL_COMPLETE_CONSTRUCTOR_P (ctor))\n+    write_string (\"C1\");\n+  else if (DECL_BASE_CONSTRUCTOR_P (ctor))\n+    write_string (\"C2\");\n+  else\n+    write_string (\"C*INTERNAL*\");\n+}\n+\n+/* Handle destructor productions of non-terminal <special-name>.\n+   DTOR is a denstructor FUNCTION_DECL. \n+\n+     <special-name> ::= D0 # deleting (in-charge) destructor\n+                    ::= D1 # complete object (in-charge) destructor\n+                    ::= D2 # base object (not-in-charge) destructor \n+\n+   We also need to provide unique mngled names for old-ABI\n+   destructors, sometimes.  These should only be used internally.  We\n+   use \"D*INTERNAL*\" for these.  */\n+\n+static void\n+write_special_name_destructor (dtor)\n+     tree dtor;\n+{\n+  if (DECL_DELETING_DESTRUCTOR_P (dtor))\n+    write_string (\"D0\");\n+  else if (DECL_COMPLETE_DESTRUCTOR_P (dtor))\n+    write_string (\"D1\");\n+  else if (DECL_BASE_DESTRUCTOR_P (dtor))\n+    write_string (\"D2\");\n+  else\n+    /* Old-ABI destructor.   */\n+    write_string (\"D*INTERNAL*\");\n+}\n+\n+/* Return the discriminator for ENTITY appearing inside\n+   FUNCTION.  The discriminator is the lexical ordinal of VAR among\n+   entities with the same name in the same FUNCTION.  */\n+\n+static int\n+discriminator_for_local_entity (entity)\n+     tree entity;\n+{\n+  tree *type;\n+  int discriminator;\n+\n+  /* Assume this is the only local entity with this name.  */\n+  discriminator = 0;\n+\n+  /* For now, we don't discriminate amongst local variables.  */\n+  if (TREE_CODE (entity) != TYPE_DECL)\n+    return 0;\n+\n+  /* Scan the list of local classes.  */\n+  entity = TREE_TYPE (entity);\n+  for (type = &VARRAY_TREE (local_classes, 0); *type != entity; ++type)\n+    if (TYPE_IDENTIFIER (*type) == TYPE_IDENTIFIER (entity)\n+\t&& TYPE_CONTEXT (*type) == TYPE_CONTEXT (entity))\n+      ++discriminator;\n+\n+  return discriminator;\n+}\n+\n+/* Return the discriminator for STRING, a string literal used inside\n+   FUNCTION.  The disciminator is the lexical ordinal of STRING among\n+   string literals used in FUNCTION.  */\n+\n+static int\n+discriminator_for_string_literal (function, string)\n+     tree function ATTRIBUTE_UNUSED;\n+     tree string ATTRIBUTE_UNUSED;\n+{\n+  /* For now, we don't discriminate amongst string literals.  */\n+  return 0;\n+}\n+\n+/*   <discriminator> := _ <number>   \n+\n+   The discriminator is used only for the second and later occurrences\n+   of the same name within a single function. In this case <number> is\n+   n - 2, if this is the nth occurrence, in lexical order.  */\n+\n+static void\n+write_discriminator (discriminator)\n+     int discriminator;\n+{\n+  /* If discriminator is zero, don't write anything.  Otherwise... */\n+  if (discriminator > 0)\n+    {\n+      write_char ('_');\n+      /* The number is omitted for discriminator == 1.  Beyond 1, the\n+\t numbering starts at 0.  */\n+      if (discriminator > 1)\n+\twrite_number (discriminator - 2, 10);\n+    }\n+}\n+\n+/* Mangle the name of a function-scope entity.  FUNCTION is the\n+   FUNCTION_DECL for the enclosing function.  ENTITY is the decl for\n+   the entity itself.\n+\n+     <local-name> := Z <function encoding> E <entity name> [<discriminator>]\n+                  := Z <function encoding> E s [<discriminator>]  */\n+\n+static void\n+write_local_name (function, entity)\n+     tree function;\n+     tree entity;\n+{\n+  MANGLE_TRACE_TREE (\"local-name\", entity);\n+\n+  write_char ('Z');\n+  write_encoding (function);\n+  write_char ('E');\n+  if (TREE_CODE (entity) == STRING_CST)\n+    {\n+      write_char ('s');\n+      write_discriminator (discriminator_for_string_literal (function, \n+\t\t\t\t\t\t\t     entity));\n+    }\n+  else\n+    {\n+      write_unqualified_name (entity);\n+      write_discriminator (discriminator_for_local_entity (entity));\n+    }\n+}\n+\n+/* Non-terminals <type> and <CV-qualifier>.  \n+\n+     <type> ::= <builtin-type>\n+            ::= <function-type>\n+            ::= <class-enum-type>\n+            ::= <array-type>\n+            ::= <pointer-to-member-type>\n+            ::= <template-param>\n+            ::= <substitution>\n+            ::= <CV-qualifier>\n+            ::= P <type>    # pointer-to\n+            ::= R <type>    # reference-to\n+            ::= C <type>    # complex pair (C 2000)  [not supported]\n+            ::= G <type>    # imaginary (C 2000)     [not supported]\n+            ::= U <source-name> <type>   # vendor extended type qualifier \n+                                                     [not supported]\n+\n+   TYPE is a type node.  */\n+\n+static void \n+write_type (type)\n+     tree type;\n+{\n+  /* This gets set to non-zero if TYPE turns out to be a (possibly\n+     CV-qualified) builtin type.  */\n+  int is_builtin_type = 0;\n+\n+  MANGLE_TRACE_TREE (\"type\", type);\n+\n+  if (find_substitution (type))\n+    return;\n+\n+  if (write_CV_qualifiers_for_type (type) > 0)\n+    /* If TYPE was CV-qualified, we just wrote the qualifiers; now\n+       mangle the unqualified type.  The recursive call is needed here\n+       since both the qualified and uqualified types are substitution\n+       candidates.  */\n+    write_type (TYPE_MAIN_VARIANT (type));\n+  else\n+    switch (TREE_CODE (type))\n+      {\n+      case VOID_TYPE:\n+      case BOOLEAN_TYPE:\n+      case INTEGER_TYPE:  /* Includes wchar_t.  */\n+      case REAL_TYPE:\n+\t/* If this is a typedef, TYPE may not be one of\n+\t   the standard builtin type nodes, but an alias of one.  Use\n+\t   TYPE_MAIN_VARIANT to get to the underlying builtin type.  */\n+\twrite_builtin_type (TYPE_MAIN_VARIANT (type));\n+\t++is_builtin_type;\n+\tbreak;\n+\n+      case COMPLEX_TYPE:\n+\twrite_char ('C');\n+\twrite_type (TREE_TYPE (type));\n+\tbreak;\n+\n+      case FUNCTION_TYPE:\n+      case METHOD_TYPE:\n+\twrite_function_type (type, 1);\n+\tbreak;\n+\n+      case UNION_TYPE:\n+      case RECORD_TYPE:\n+      case ENUMERAL_TYPE:\n+\t/* A pointer-to-member function is represented as a special\n+\t   RECORD_TYPE, so check for this first.  */\n+\tif (TYPE_PTRMEMFUNC_P (type))\n+\t  write_pointer_to_member_type (type);\n+\telse\n+\t  write_class_enum_type (type);\n+\tbreak;\n+\n+      case TYPENAME_TYPE:\n+\t/* We handle TYPENAME_TYPEs like ordinary nested names.  */\n+\twrite_nested_name (TYPE_STUB_DECL (type));\n+\tbreak;\n+\n+      case ARRAY_TYPE:\n+\twrite_array_type (type);\n+\tbreak;\n+\n+      case POINTER_TYPE:\n+\t/* A pointer-to-member variable is represented by a POINTER_TYPE\n+\t   to an OFFSET_TYPE, so check for this first.  */\n+\tif (TYPE_PTRMEM_P (type))\n+\t  write_pointer_to_member_type (type);\n+\telse\n+\t  {\n+\t    write_char ('P');\n+\t    write_type (TREE_TYPE (type));\n+\t  }\n+\tbreak;\n+\n+      case REFERENCE_TYPE:\n+\twrite_char ('R');\n+\twrite_type (TREE_TYPE (type));\n+\tbreak;\n+\n+      case TEMPLATE_TYPE_PARM:\n+      case TEMPLATE_PARM_INDEX:\n+\twrite_template_param (type);\n+\tbreak;\n+\n+      case TEMPLATE_TEMPLATE_PARM:\n+\twrite_template_template_param (type);\n+\tif (TEMPLATE_TEMPLATE_PARM_TEMPLATE_INFO (type))\n+\t  write_template_args \n+\t    (TI_ARGS (TEMPLATE_TEMPLATE_PARM_TEMPLATE_INFO (type)));\n+\tbreak;\n+\n+      case OFFSET_TYPE:\n+\twrite_pointer_to_member_type (build_pointer_type (type));\n+\tbreak;\n+\n+      default:\n+\tmy_friendly_abort (20000409);\n+      }\n+\n+  /* Types other than builtin types are substitution candidates.  */\n+  if (!is_builtin_type)\n+    add_substitution (type);\n+}\n+\n+/* Non-terminal <CV-qualifiers> for type nodes.  Returns the number of\n+   CV-qualifiers written for TYPE.\n+\n+     <CV-qualifiers> ::= [r] [V] [K]  */\n+\n+static int\n+write_CV_qualifiers_for_type (type)\n+     tree type;\n+{\n+  int num_qualifiers = 0;\n+\n+  /* The order is specified by:\n+\n+       \"In cases where multiple order-insensitive qualifiers are\n+       present, they should be ordered 'K' (closest to the base type),\n+       'V', 'r', and 'U' (farthest from the base type) ...\"  */\n+\n+  if (CP_TYPE_RESTRICT_P (type))\n+    {\n+      write_char ('r');\n+      ++num_qualifiers;\n+    }\n+  if (CP_TYPE_VOLATILE_P (type))\n+    {\n+      write_char ('V');\n+      ++num_qualifiers;\n+    }\n+  if (CP_TYPE_CONST_P (type))\n+    {\n+      write_char ('K');\n+      ++num_qualifiers;\n+    }\n+\n+  return num_qualifiers;\n+}\n+\n+/* Non-terminal <builtin-type>. \n+\n+     <builtin-type> ::= v   # void \n+                    ::= b   # bool\n+                    ::= w   # wchar_t\n+                    ::= c   # char\n+                    ::= a   # signed char\n+                    ::= h   # unsigned char\n+                    ::= s   # short\n+                    ::= t   # unsigned short\n+                    ::= i   # int\n+                    ::= j   # unsigned int\n+                    ::= l   # long\n+                    ::= m   # unsigned long\n+                    ::= x   # long long, __int64\n+                    ::= y   # unsigned long long, __int64  \n+                    ::= n   # __int128            [not supported]\n+                    ::= o   # unsigned __int128   [not supported] \n+                    ::= f   # float\n+                    ::= d   # double\n+                    ::= e   # long double, __float80 \n+                    ::= g   # __float128          [not supported]  */\n+\n+static void \n+write_builtin_type (type)\n+     tree type;\n+{\n+  switch (TREE_CODE (type))\n+    {\n+    case VOID_TYPE:\n+      write_char ('v');\n+      break;\n+\n+    case BOOLEAN_TYPE:\n+      write_char ('b');\n+      break;\n+\n+    case INTEGER_TYPE:\n+      /* If this is size_t, get the underlying int type.  */\n+      if (TYPE_IS_SIZETYPE (type))\n+\ttype = TYPE_DOMAIN (type);\n+\n+      /* TYPE may still be wchar_t, since that isn't in\n+\t integer_type_nodes.  */\n+      if (type == wchar_type_node)\n+\twrite_char ('w');\n+      else\n+\t{\n+\t  size_t itk;\n+\t  /* Assume TYPE is one of the shared integer type nodes.  Find\n+\t     it in the array of these nodes.  */\n+\t  for (itk = 0; itk < itk_none; ++itk)\n+\t    if (type == integer_types[itk])\n+\t      {\n+\t\t/* Print the corresponding single-letter code.  */\n+\t\twrite_char (integer_type_codes[itk]);\n+\t\tbreak;\n+\t      }\n+\t  \n+\t  if (itk == itk_none)\n+\t    /* Couldn't find this type.  */\n+\t    my_friendly_abort (20000408);\n+\t}\n+      break;\n+\n+    case REAL_TYPE:\n+      if (type == float_type_node)\n+\twrite_char ('f');\n+      else if (type == double_type_node)\n+\twrite_char ('d');\n+      else if (type == long_double_type_node)\n+\twrite_char ('e');\n+      else\n+\tmy_friendly_abort (20000409);\n+      break;\n+\n+    default:\n+      my_friendly_abort (20000509);\n+    }\n+}\n+\n+/* Non-terminal <function-type>.  NODE is a FUNCTION_TYPE or\n+   METHOD_TYPE.  If INCLUDE_RETURN_TYPE is non-zero, the return type\n+   is mangled before the parameter types.\n+\n+     <function-type> ::= F [Y] <bare-function-type> E   */\n+\n+static void\n+write_function_type (type, include_return_type)\n+     tree type;\n+     int include_return_type;\n+{\n+  MANGLE_TRACE_TREE (\"function-type\", type);\n+\n+  write_char ('F');\n+  /* We don't track whether or not a type is `extern \"C\"'.  Note that\n+     you can have an `extern \"C\"' function that does not have\n+     `extern \"C\"' type, and vice versa:\n+\n+       extern \"C\" typedef void function_t();\n+       function_t f; // f has C++ linkage, but its type is\n+                     // `extern \"C\"'\n+\n+       typedef void function_t();\n+       extern \"C\" function_t f; // Vice versa.\n+\n+     See [dcl.link].  */\n+  write_bare_function_type (type, include_return_type);\n+  write_char ('E');\n+}\n+\n+/* Non-terminal <bare-function-type>.  NODE is a FUNCTION_DECL or a\n+   METHOD_TYPE.  If INCLUDE_RETURN_TYPE is non-zero, the return value\n+   is mangled before the parameter types.\n+\n+     <bare-function-type> ::= </signature/ type>+  */\n+\n+static void\n+write_bare_function_type (type, include_return_type_p)\n+     tree type;\n+     int include_return_type_p;\n+{\n+  MANGLE_TRACE_TREE (\"bare-function-type\", type);\n+\n+  /* Mangle the return type, if requested.  */\n+  if (include_return_type_p)\n+    write_type (TREE_TYPE (type));\n+\n+  /* Now mangle the types of the arguments.  */\n+  write_method_parms (TYPE_ARG_TYPES (type), \n+\t\t      TREE_CODE (type) == METHOD_TYPE);\n+}\n+\n+/* Write the mangled representation of a method parameter list of\n+   types given in PARM_LIST.  If METHOD_P is non-zero, the function is \n+   considered a non-static method, and the this parameter is omitted.\n+   If VARARGS_P is non-zero, an additional token designating varargs\n+   is appended.  */\n+\n+static void\n+write_method_parms (parm_list, method_p)\n+     tree parm_list;\n+     int method_p;\n+{\n+  tree first_parm;\n+  /* Assume this parameter type list is variable-length.  If it ends\n+     with a void type, then it's not.  */\n+  int varargs_p = 1;\n+\n+  /* If this is a member function, skip the first arg, which is the\n+     this pointer.  \n+       \"Member functions do not encode the type of their implicit this\n+       parameter.\"  */\n+  if (method_p)\n+    parm_list = TREE_CHAIN (parm_list);\n+\n+  for (first_parm = parm_list; \n+       parm_list; \n+       parm_list = TREE_CHAIN (parm_list))\n+    {\n+      tree parm = TREE_VALUE (parm_list);\n+\n+      if (same_type_p (parm, void_type_node))\n+\t{\n+\t  /* \"Empty parameter lists, whether declared as () or\n+\t     conventionally as (void), are encoded with a void parameter\n+\t     (v).\"  */\n+\t  if (parm_list == first_parm)\n+\t    write_type (parm);\n+\t  /* If the parm list is terminated with a void type, it's\n+\t     fixed-length.  */\n+\t  varargs_p = 0;\n+\t  /* A void type better be the last one.  */\n+\t  my_friendly_assert (TREE_CHAIN (parm_list) == NULL, 20000523);\n+\t}\n+      else\n+\twrite_type (parm);\n+    }\n+\n+  if (varargs_p)\n+    /* <builtin-type> ::= z  # ellipsis  */\n+    write_char ('z');\n+}\n+\n+/* <class-enum-type> ::= <name>  */\n+\n+static void \n+write_class_enum_type (type)\n+     tree type;\n+{\n+  write_name (TYPE_NAME (type));\n+}\n+\n+/* Non-terminal <template-args>.  ARGS is a TREE_VEC of template\n+   arguments.\n+\n+     <template-args> ::= I <template-arg>+ E  */\n+\n+static void\n+write_template_args (args)\n+     tree args;\n+{\n+  int i;\n+  int length = TREE_VEC_LENGTH (args);\n+\n+  MANGLE_TRACE_TREE (\"template-args\", args);\n+\n+  my_friendly_assert (length > 0, 20000422);\n+\n+  if (TREE_CODE (TREE_VEC_ELT (args, 0)) == TREE_VEC)\n+    {\n+      /* We have nested template args.  We want the innermost template\n+\t argument list.  */\n+      args = TREE_VEC_ELT (args, length - 1);\n+      length = TREE_VEC_LENGTH (args);\n+    }\n+\n+  write_char ('I');\n+  for (i = 0; i < length; ++i)\n+    write_template_arg (TREE_VEC_ELT (args, i));\n+  write_char ('E');\n+}\n+\n+/* <expression> ::= <unary operator-name> <expression>\n+\t\t::= <binary operator-name> <expression> <expression>\n+\t\t::= <expr-primary>\n+\n+   <expr-primary> ::= <template-param>\n+\t\t  ::= L <type> <value number> E  # literal\n+\t\t  ::= L <mangled-name> E         # external name  */\n+\n+static void\n+write_expression (expr)\n+     tree expr;\n+{\n+  enum tree_code code;\n+\n+  code = TREE_CODE (expr);\n+\n+  /* Handle pointers-to-members by making them look like expression\n+     nodes.  */\n+  if (code == PTRMEM_CST)\n+    {\n+      expr = build_nt (ADDR_EXPR,\n+\t\t       build_nt (SCOPE_REF,\n+\t\t\t\t PTRMEM_CST_CLASS (expr),\n+\t\t\t\t PTRMEM_CST_MEMBER (expr)));\n+      code = TREE_CODE (expr);\n+    }\n+\n+  /* Handle template parameters. */\n+  if (code == TEMPLATE_TYPE_PARM \n+      || code == TEMPLATE_TEMPLATE_PARM\n+      ||  code == TEMPLATE_PARM_INDEX)\n+    write_template_param (expr);\n+  /* Handle literals.  */\n+  else if (TREE_CODE_CLASS (code) == 'c')\n+    write_template_arg_literal (expr);\n+  else if (DECL_P (expr))\n+    {\n+      write_char ('L');\n+      write_mangled_name (expr);\n+      write_char ('E');\n+    }\n+  else\n+    {\n+      int i;\n+\n+      /* Skip NOP_EXPRs.  They can occur when (say) a pointer argument\n+\t is converted (via qualification conversions) to another\n+\t type.  */\n+      while (TREE_CODE (expr) == NOP_EXPR)\n+\t{\n+\t  expr = TREE_OPERAND (expr, 0);\n+\t  code = TREE_CODE (expr);\n+\t}\n+\n+      /* If it wasn't any of those, recursively expand the expression.  */\n+      write_string (operator_name_info[(int) code].mangled_name);\n+\n+      /* Handle pointers-to-members specially.  */\n+      if (code == SCOPE_REF)\n+\t{\n+\t  write_type (TREE_OPERAND (expr, 0));\n+\t  if (TREE_CODE (TREE_OPERAND (expr, 1)) == IDENTIFIER_NODE)\n+\t    write_source_name (TREE_OPERAND (expr, 1));\n+\t  else\n+\t    write_encoding (TREE_OPERAND (expr, 1));\n+\t}\n+      else\n+\tfor (i = 0; i < TREE_CODE_LENGTH (code); ++i)\n+\t  write_expression (TREE_OPERAND (expr, i));\n+    }\n+}\n+\n+/* Literal subcase of non-terminal <template-arg>.  \n+\n+     \"Literal arguments, e.g. \"A<42L>\", are encoded with their type\n+     and value. Negative integer values are preceded with \"n\"; for\n+     example, \"A<-42L>\" becomes \"1AILln42EE\". The bool value false is\n+     encoded as 0, true as 1. If floating-point arguments are accepted\n+     as an extension, their values should be encoded using a\n+     fixed-length lowercase hexadecimal string corresponding to the\n+     internal representation (IEEE on IA-64), high-order bytes first,\n+     without leading zeroes. For example: \"Lfbff000000E\" is -1.0f.\"  */\n+\n+static void\n+write_template_arg_literal (value)\n+     tree value;\n+{\n+  tree type = TREE_TYPE (value);\n+  write_char ('L');\n+  write_type (type);\n+\n+  if (TREE_CODE (value) == CONST_DECL)\n+    write_integer_cst (DECL_INITIAL (value));\n+  else if (TREE_CODE (value) == INTEGER_CST)\n+    {\n+      if (same_type_p (type, boolean_type_node))\n+\t{\n+\t  if (value == boolean_false_node || integer_zerop (value))\n+\t    write_number (0, 10);\n+\t  else if (value == boolean_true_node)\n+\t    write_number (1, 10);\n+\t  else \n+\t    my_friendly_abort (20000412);\n+\t}\n+      else\n+\twrite_integer_cst (value);\n+    }\n+  else if (TREE_CODE (value) == REAL_CST)\n+    {\n+#ifdef CROSS_COMPILE\n+      static int explained;\n+\n+      if (!explained) \n+\t{\n+\t  sorry (\"real-valued template parameters when cross-compiling\");\n+\t  explained = 1;\n+\t}\n+#else\n+      size_t i;\n+      for (i = 0; i < sizeof (TREE_REAL_CST (value)); ++i)\n+\twrite_number (((unsigned char *) \n+\t\t       &TREE_REAL_CST (value))[i], 16);\n+#endif\n+    }\n+  else\n+    my_friendly_abort (20000412);\n+\n+  write_char ('E');\n+}\n+\n+/* Non-terminal <tempalate-arg>.  \n+\n+     <template-arg> ::= <type>                        # type\n+                    ::= L <type> </value/ number> E   # literal\n+                    ::= LZ <name> E                   # external name\n+                    ::= X <expression> E              # expression  */\n+\n+static void\n+write_template_arg (node)\n+     tree node;\n+{\n+  enum tree_code code = TREE_CODE (node);\n+\n+  MANGLE_TRACE_TREE (\"template-arg\", node);\n+\n+  /* A template template paramter's argument list contains TREE_LIST\n+     nodes of which the value field is the the actual argument.  */\n+  if (code == TREE_LIST)\n+    {\n+      node = TREE_VALUE (node);\n+      /* If it's a decl, deal with its type instead.  */\n+      if (DECL_P (node))\n+\t{\n+\t  node = TREE_TYPE (node);\n+\t  code = TREE_CODE (node);\n+\t}\n+    }\n+\n+  if (TYPE_P (node))\n+    write_type (node);\n+  else if (code == TEMPLATE_DECL)\n+    /* A template appearing as a template arg is a template template arg.  */\n+    write_template_template_arg (node);\n+  else if (DECL_P (node))\n+    {\n+      write_char ('L');\n+      write_char ('Z');\n+      write_encoding (node);\n+      write_char ('E');\n+    }\n+  else if (TREE_CODE_CLASS (code) == 'c' && code != PTRMEM_CST)\n+    write_template_arg_literal (node);\n+  else\n+    {\n+      /* Template arguments may be expressions.  */\n+      write_char ('X');\n+      write_expression (node);\n+      write_char ('E');\n+    }\n+}\n+\n+/*  <template-template-arg>\n+\t\t\t::= <name>\n+\t\t\t::= <substitution>  */\n+\n+void\n+write_template_template_arg (tree decl)\n+{\n+  MANGLE_TRACE_TREE (\"template-template-arg\", decl);\n+\n+  if (find_substitution (decl))\n+    return;\n+  write_name (decl);\n+  add_substitution (decl);\n+}\n+\n+\n+/* Non-terminal <array-type>.  TYPE is an ARRAY_TYPE.  \n+\n+     <array-type> ::= A [</dimension/ number>] _ </element/ type>  \n+\n+     \"Array types encode the dimension (number of elements) and the\n+     element type. For variable length arrays, the dimension (but not\n+     the '_' separator) is omitted.\"  */\n+\n+static void \n+write_array_type (type)\n+  tree type;\n+{\n+  write_char ('A');\n+  if (TYPE_DOMAIN (type))\n+    {\n+      tree index_type;\n+      tree max;\n+\n+      index_type = TYPE_DOMAIN (type);\n+      /* The INDEX_TYPE gives the upper and lower bounds of the\n+\t array.  */\n+      max = TYPE_MAX_VALUE (index_type);\n+      if (TREE_CODE (max) == INTEGER_CST)\n+\twrite_number (TREE_INT_CST_LOW (max) + 1, 10);\n+      else\n+\twrite_expression (TREE_OPERAND (max, 0));\n+    }\n+  write_char ('_');\n+  write_type (TREE_TYPE (type));\n+}\n+\n+/* Non-terminal <pointer-to-member-type> for pointer-to-member\n+   variables.  TYPE is a pointer-to-member POINTER_TYPE.\n+\n+     <pointer-to-member-type> ::= M </class/ type> </member/ type>  */\n+\n+static void\n+write_pointer_to_member_type (type)\n+     tree type;\n+{\n+  write_char ('M');\n+  write_type (TYPE_PTRMEM_CLASS_TYPE (type));\n+  write_type (TYPE_PTRMEM_POINTED_TO_TYPE (type));\n+}\n+\n+/* Non-terminal <template-param>.  PARM is a TEMPLATE_TYPE_PARM,\n+   TEMPLATE_TEMPLATE_PARM, or a TEMPLATE_PARM_INDEX.\n+\n+     <template-param> ::= T </parameter/ number> _  */\n+\n+static void\n+write_template_param (parm)\n+     tree parm;\n+{\n+  int parm_index;\n+\n+  MANGLE_TRACE_TREE (\"template-parm\", parm);\n+\n+  switch (TREE_CODE (parm))\n+    {\n+    case TEMPLATE_TYPE_PARM:\n+    case TEMPLATE_TEMPLATE_PARM:\n+      parm_index = TEMPLATE_TYPE_IDX (parm);\n+      break;\n+\n+    case TEMPLATE_PARM_INDEX:\n+      parm_index = TEMPLATE_PARM_IDX (parm);\n+      break;\n+\n+    default:\n+      my_friendly_abort (20000523);\n+    }\n+\n+  write_char ('T');\n+  /* NUMBER as it appears in the mangling is (-1)-indexed, with the\n+     earliest template param denoted by `_'.  */\n+  if (parm_index > 0)\n+    write_number (parm_index - 1, 10);\n+  write_char ('_');\n+}\n+\n+/*  <template-template-param>\n+                        ::= <template-param> \n+\t\t\t::= <substitution>  */\n+\n+static void\n+write_template_template_param (parm)\n+     tree parm;\n+{\n+  tree template = NULL_TREE;\n+\n+  /* PARM, a TEMPLATE_TEMPLATE_PARM, is an instantiation of the\n+     template template parameter.  The substitution candidate here is\n+     only the template.  */\n+  if (TEMPLATE_TEMPLATE_PARM_TEMPLATE_INFO (parm))\n+    {\n+      template \n+\t= TI_TEMPLATE (TEMPLATE_TEMPLATE_PARM_TEMPLATE_INFO (parm));\n+      if (find_substitution (template))\n+\treturn;\n+    }\n+\n+  /* <template-param> encodes only the template parameter position,\n+     not its template arguments, which is fine here.  */\n+  write_template_param (parm);\n+  if (template)\n+    add_substitution (template);\n+}\n+\n+/* Non-terminal <substitution>.  \n+\n+      <substitution> ::= S <seq-id> _\n+                     ::= S_  */\n+\n+static void\n+write_substitution (seq_id)\n+     int seq_id;\n+{\n+  MANGLE_TRACE (\"substitution\", \"\");\n+\n+  write_char ('S');\n+  if (seq_id > 0)\n+    write_number (seq_id - 1, 36);\n+  write_char ('_');\n+}\n+\n+/* Start mangling a new name or type.  */\n+\n+static inline void\n+start_mangling ()\n+{\n+  obstack_free (&G.name_obstack, obstack_base (&G.name_obstack));\n+}\n+\n+/* Done with mangling.  Return the generated mangled name.  */\n+\n+static inline const char *\n+finish_mangling ()\n+{\n+  /* Clear all the substitutions.  */\n+  VARRAY_POP_ALL (G.substitutions);\n+\n+  /* Null-terminate the string.  */\n+  write_char ('\\0');\n+\n+  return (const char *) obstack_base (&G.name_obstack);\n+}\n+\n+/* Initialize data structures for mangling.  */\n+\n+void\n+init_mangle ()\n+{\n+  gcc_obstack_init (&G.name_obstack);\n+  VARRAY_TREE_INIT (G.substitutions, 1, \"mangling substitutions\");\n+\n+  /* Cache these identifiers for quick comparison when checking for\n+     standard substitutions.  */\n+  subst_identifiers[SUBID_ALLOCATOR] = get_identifier (\"allocator\");\n+  subst_identifiers[SUBID_BASIC_STRING] = get_identifier (\"basic_string\");\n+  subst_identifiers[SUBID_CHAR_TRAITS] = get_identifier (\"char_traits\");\n+  subst_identifiers[SUBID_BASIC_ISTREAM] = get_identifier (\"basic_istream\");\n+  subst_identifiers[SUBID_BASIC_OSTREAM] = get_identifier (\"basic_ostream\");\n+  subst_identifiers[SUBID_BASIC_IOSTREAM] = get_identifier (\"basic_iostream\");\n+}\n+\n+/* Generate the mangled name of DECL.  */\n+\n+static const char *\n+mangle_decl_string (decl)\n+     tree decl;\n+{\n+  const char *result;\n+\n+  start_mangling ();\n+\n+  if (TREE_CODE (decl) == TYPE_DECL)\n+    write_type (TREE_TYPE (decl));\n+  else\n+    write_mangled_name (decl);\n+\n+  result = finish_mangling ();\n+  if (DEBUG_MANGLE)\n+    fprintf (stderr, \"mangle_decl_string = '%s'\\n\\n\", result);\n+  return result;\n+}\n+\n+/* Create an identifier for the external mangled name of DECL.  */\n+\n+tree\n+mangle_decl (decl)\n+     tree decl;\n+{\n+  return get_identifier (mangle_decl_string (decl));\n+}\n+\n+/* Generate the mangled representation of TYPE.  */\n+\n+const char *\n+mangle_type_string (type)\n+     tree type;\n+{\n+  const char *result;\n+\n+  start_mangling ();\n+  write_type (type);\n+  result = finish_mangling ();\n+  if (DEBUG_MANGLE)\n+    fprintf (stderr, \"mangle_type_string = '%s'\\n\\n\", result);\n+  return result;\n+}\n+\n+/* Create an identifier for the mangled representation of TYPE.  */\n+\n+tree\n+mangle_type (type)\n+     tree type;\n+{\n+  return get_identifier (mangle_type_string (type));\n+}\n+\n+/* Create an identifier for the mangled name of a special component\n+   for belonging to TYPE.  CODE is the ABI-specified code for this\n+   component.  */\n+\n+static tree\n+mangle_special_for_type (type, code)\n+     tree type;\n+     const char *code;\n+{\n+  const char *result;\n+\n+  /* We don't have an actual decl here for the special component, so\n+     we can't just process the <encoded-name>.  Instead, fake it.  */\n+  start_mangling ();\n+\n+  /* Start the mangling.  */\n+  write_string (\"_Z\");\n+  write_string (code);\n+\n+  /* Add the type.  */\n+  write_type (type);\n+  result = finish_mangling ();\n+\n+  if (DEBUG_MANGLE)\n+    fprintf (stderr, \"mangle_special_for_type = %s\\n\\n\", result);\n+\n+  return get_identifier (result);\n+}\n+\n+/* Create an identifier for the mangled representation of the typeinfo\n+   structure for TYPE.  */\n+\n+tree\n+mangle_typeinfo_for_type (type)\n+     tree type;\n+{\n+  return mangle_special_for_type (type, \"TI\");\n+}\n+\n+/* Create an identifier for the mangled name of the NTBS containing\n+   the mangled name of TYPE.  */\n+\n+tree\n+mangle_typeinfo_string_for_type (type)\n+     tree type;\n+{\n+  return mangle_special_for_type (type, \"TS\");\n+}\n+\n+/* Create an identifier for the mangled name of the vtable for TYPE.  */\n+\n+tree\n+mangle_vtbl_for_type (type)\n+     tree type;\n+{\n+  return mangle_special_for_type (type, \"TV\");\n+}\n+\n+/* Returns an identifier for the mangled name of the VTT for TYPE.  */\n+\n+tree\n+mangle_vtt_for_type (type)\n+     tree type;\n+{\n+  return mangle_special_for_type (type, \"TT\");\n+}\n+\n+/* Return an identifier for a construction vtable group.  TYPE is\n+   the most derived class in the hierarchy; BINFO is the base\n+   subobject for which this construction vtable group will be used.  \n+\n+   This mangling isn't part of the ABI specification; in the ABI\n+   specification, the vtable group is dumped in the same COMDAT as the\n+   main vtable, and is referenced only from that vtable, so it doesn't\n+   need an external name.  For binary formats without COMDAT sections,\n+   though, we need external names for the vtable groups.  \n+\n+   We use the production\n+\n+    <special-name> ::= CT <type> <offset number> _ <base type>  */\n+\n+tree\n+mangle_ctor_vtbl_for_type (type, binfo)\n+     tree type;\n+     tree binfo;\n+{\n+  const char *result;\n+\n+  start_mangling ();\n+\n+  write_string (\"_Z\");\n+  write_string (\"TC\");\n+  write_type (type);\n+  write_integer_cst (BINFO_OFFSET (binfo));\n+  write_char ('_');\n+  write_type (BINFO_TYPE (binfo));\n+\n+  result = finish_mangling ();\n+  if (DEBUG_MANGLE)\n+    fprintf (stderr, \"mangle_ctor_vtbl_for_type = %s\\n\\n\", result);\n+  return get_identifier (result);\n+}\n+\n+/* Return an identifier for the mangled name of a thunk to FN_DECL.\n+   OFFSET is the initial adjustment to this used to find the vptr.  If\n+   VCALL_OFFSET is non-zero, this is a virtual thunk, and it is the\n+   vtbl offset in bytes.  \n+\n+    <special-name> ::= Th <offset number> _ <base encoding>\n+                   ::= Tv <offset number> _ <vcall offset number> _\n+\t\t                                            <base encoding>\n+*/\n+\n+tree\n+mangle_thunk (fn_decl, offset, vcall_offset)\n+     tree fn_decl;\n+     int offset;\n+     int vcall_offset;\n+{\n+  const char *result;\n+  \n+  start_mangling ();\n+\n+  write_string (\"_Z\");\n+  /* The <special-name> for virtual thunks is Tv, for non-virtual\n+     thunks Th.  */\n+  write_char ('T');\n+  if (vcall_offset != 0)\n+    write_char ('v');\n+  else\n+    write_char ('h');\n+\n+  /* For either flavor, write the offset to this.  */\n+  write_number (offset, 10);\n+  write_char ('_');\n+\n+  /* For a virtual thunk, add the vcall offset.  */\n+  if (vcall_offset != 0)\n+    {\n+      /* Virtual thunk.  Write the vcall offset and base type name.  */\n+      write_number (vcall_offset, 10);\n+      write_char ('_');\n+    }\n+\n+  /* Scoped name.  */\n+  write_encoding (fn_decl);\n+\n+  result = finish_mangling ();\n+  if (DEBUG_MANGLE)\n+    fprintf (stderr, \"mangle_thunk = %s\\n\\n\", result);\n+  return get_identifier (result);\n+}\n+\n+/* Return an identifier for the mangled unqualified name for a\n+   conversion operator to TYPE.  This mangling is not specified by the\n+   ABI spec; it is only used internally.\n+\n+   For compatibility with existing conversion operator mechanisms,\n+   the mangled form is `__op<type>' where <type> is the mangled\n+   representation of TYPE.  \n+\n+   FIXME: Though identifiers with starting with __op are reserved for\n+   the implementation, it would eventually be nice to use inaccessible\n+   names for these operators.  */\n+\n+tree\n+mangle_conv_op_name_for_type (type)\n+     tree type;\n+{\n+  tree identifier;\n+\n+  /* Build the mangling for TYPE.  */\n+  const char *mangled_type = mangle_type_string (type);\n+  /* Allocate a temporary buffer for the complete name.  */\n+  char *op_name = (char *) xmalloc (strlen (OPERATOR_TYPENAME_FORMAT) \n+\t\t\t\t    + strlen (mangled_type) + 1);\n+  /* Assemble the mangling.  */\n+  strcpy (op_name, OPERATOR_TYPENAME_FORMAT);\n+  strcat (op_name, mangled_type);\n+  /* Find or create an identifier.  */\n+  identifier = get_identifier (op_name);\n+  /* Done with the temporary buffer.  */\n+  free (op_name);\n+  /* Set bits on the identifier so we know later it's a conversion.  */\n+  IDENTIFIER_OPNAME_P (identifier) = 1;\n+  IDENTIFIER_TYPENAME_P (identifier) = 1;\n+  /* Hang TYPE off the identifier so it can be found easily later when\n+     performing conversions.  */\n+  TREE_TYPE (identifier) = type;\n+\n+  return identifier;\n+}\n+\n+/* Return an identifier for the name of an initialization guard\n+   variable for indicated VARIABLE.  */\n+\n+tree\n+mangle_guard_variable (variable)\n+     tree variable;\n+{\n+  start_mangling ();\n+  write_string (\"_ZGV\");\n+  write_name (variable);\n+  return get_identifier (finish_mangling ());\n+}"}, {"sha": "f6c006a08600a68eef9a27f3ac06df9f29c3785a", "filename": "gcc/cp/method.c", "status": "modified", "additions": 62, "deletions": 16, "changes": 78, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1f6e1acc0f2017e81282604bda62db1b2b865075/gcc%2Fcp%2Fmethod.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1f6e1acc0f2017e81282604bda62db1b2b865075/gcc%2Fcp%2Fmethod.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fmethod.c?ref=1f6e1acc0f2017e81282604bda62db1b2b865075", "patch": "@@ -137,6 +137,8 @@ init_method ()\n   ggc_add_tree_varray_root (&btypelist, 1);\n   ggc_add_tree_varray_root (&ktypelist, 1);\n   ggc_add_tree_varray_root (&typevec, 1);\n+  if (flag_new_abi)\n+    init_mangle ();\n }\n \n /* This must be large enough to hold any printed integer or floating-point\n@@ -156,6 +158,9 @@ static int numeric_output_need_bar;\n static inline void\n start_squangling ()\n {\n+  /* This function is obsoleted by the new ABI.  */\n+  my_friendly_assert (!flag_new_abi, 200005222);\n+\n   if (flag_do_squangling)\n     {\n       nofold = 0;\n@@ -1125,6 +1130,10 @@ build_overload_name (parmtypes, begin, end)\n      int begin, end;\n {\n   char *ret;\n+\n+  /* This function is obsoleted by the new ABI.  */\n+  my_friendly_assert (!flag_new_abi, 200005221);\n+\n   start_squangling ();\n   ret = build_mangled_name (parmtypes, begin, end);\n   end_squangling ();\n@@ -1140,6 +1149,9 @@ build_mangled_name (parmtypes, begin, end)\n      tree parmtypes;\n      int begin, end;\n {\n+  /* This function is obsoleted by the new ABI.  */\n+  my_friendly_assert (!flag_new_abi, 200004105);\n+\n   if (begin) \n     OB_INIT ();\n \n@@ -1549,6 +1561,9 @@ tree\n build_static_name (context, name)\n      tree context, name;\n {\n+  /* This function is obsoleted by the new ABI.  */\n+  my_friendly_assert (!flag_new_abi, 200004106);\n+\n   OB_INIT ();\n   numeric_output_need_bar = 0;\n   start_squangling ();\n@@ -1584,6 +1599,9 @@ build_decl_overload_real (decl, parms, ret_type, tparms, targs,\n   const char *name;\n   enum tree_code operator_code;\n \n+  /* This function is obsoleted by the new ABI.  */\n+  my_friendly_assert (!flag_new_abi, 20000410);\n+\n   operator_code = DECL_OVERLOADED_OPERATOR_P (decl);\n   if (!DECL_CONV_FN_P (decl) && operator_code)\n     {\n@@ -1719,6 +1737,12 @@ set_mangled_name_for_decl (decl)\n     /* There's no need to mangle the name of a template function.  */\n     return;\n \n+  if (flag_new_abi)\n+    {\n+      DECL_ASSEMBLER_NAME (decl) = mangle_decl (decl);\n+      return;\n+    }\n+\n   parm_types = TYPE_ARG_TYPES (TREE_TYPE (decl));\n \n   if (DECL_STATIC_FUNCTION_P (decl))\n@@ -1748,6 +1772,9 @@ build_typename_overload (type)\n {\n   tree id;\n \n+  /* This function is obsoleted by the new ABI.  */\n+  my_friendly_assert (!flag_new_abi, 200004108);\n+\n   OB_INIT ();\n   OB_PUTS (OPERATOR_TYPENAME_FORMAT);\n   nofold = 1;\n@@ -1765,6 +1792,9 @@ tree\n build_overload_with_type (name, type)\n      tree name, type;\n {\n+  /* This function is obsoleted by the new ABI.  */\n+  my_friendly_assert (!flag_new_abi, 200004109);\n+\n   OB_INIT ();\n   OB_PUTID (name);\n   nofold = 1;\n@@ -1780,6 +1810,9 @@ get_id_2 (name, name2)\n      const char *name;\n      tree name2;\n {\n+  /* This function is obsoleted by the new ABI.  */\n+  my_friendly_assert (!flag_new_abi, 20000411);\n+\n   OB_INIT ();\n   OB_PUTCP (name);\n   OB_PUTID (name2);\n@@ -1796,6 +1829,9 @@ get_ctor_vtbl_name (type, binfo)\n      tree type;\n      tree binfo;\n {\n+  /* This function is obsoleted by the new ABI.  */\n+  my_friendly_assert (!flag_new_abi, 200005220);\n+\n   start_squangling ();\n   OB_INIT ();\n   OB_PUTCP (CTOR_VTBL_NAME_PREFIX);\n@@ -2019,6 +2055,11 @@ hack_identifier (value, name)\n }\n \n \f\n+/* Return a thunk to FUNCTION.  For a virtual thunk, DELTA is the\n+   offset to this used to locate the vptr, and VCALL_INDEX is used to\n+   look up the eventual subobject location.  For a non-virtual thunk,\n+   DELTA is the offset to this and VCALL_INDEX is zero.  */\n+\n tree\n make_thunk (function, delta, vcall_index)\n      tree function;\n@@ -2028,31 +2069,37 @@ make_thunk (function, delta, vcall_index)\n   tree thunk_id;\n   tree thunk;\n   tree func_decl;\n+  int vcall_offset = vcall_index * int_size_in_bytes (vtable_entry_type);\n \n   if (TREE_CODE (function) != ADDR_EXPR)\n     abort ();\n   func_decl = TREE_OPERAND (function, 0);\n   if (TREE_CODE (func_decl) != FUNCTION_DECL)\n     abort ();\n \n-  OB_INIT ();\n-  OB_PUTS (\"__thunk_\");\n-  if (delta > 0)\n-    {\n-      OB_PUTC ('n');\n-      icat (delta);\n-    }\n+  if (flag_new_abi) \n+    thunk_id = mangle_thunk (TREE_OPERAND (function, 0),  delta, vcall_offset);\n   else\n-    icat (-delta);\n-  OB_PUTC ('_');\n-  if (vcall_index)\n     {\n-      icat (vcall_index);\n+      OB_INIT ();\n+      OB_PUTS (\"__thunk_\");\n+      if (delta > 0)\n+\t{\n+\t  OB_PUTC ('n');\n+\t  icat (delta);\n+\t}\n+      else\n+\ticat (-delta);\n       OB_PUTC ('_');\n+      if (vcall_index)\n+\t{\n+\t  icat (vcall_index);\n+\t  OB_PUTC ('_');\n+\t}\n+      OB_PUTID (DECL_ASSEMBLER_NAME (func_decl));\n+      OB_FINISH ();\n+      thunk_id = get_identifier (obstack_base (&scratch_obstack));\n     }\n-  OB_PUTID (DECL_ASSEMBLER_NAME (func_decl));\n-  OB_FINISH ();\n-  thunk_id = get_identifier (obstack_base (&scratch_obstack));\n \n   thunk = IDENTIFIER_GLOBAL_VALUE (thunk_id);\n   if (thunk && !DECL_THUNK_P (thunk))\n@@ -2073,8 +2120,7 @@ make_thunk (function, delta, vcall_index)\n       SET_DECL_THUNK_P (thunk);\n       DECL_INITIAL (thunk) = function;\n       THUNK_DELTA (thunk) = delta;\n-      THUNK_VCALL_OFFSET (thunk) \n-\t= vcall_index * int_size_in_bytes (vtable_entry_type);\n+      THUNK_VCALL_OFFSET (thunk) = vcall_offset;\n       /* The thunk itself is not a constructor or destructor, even if\n        the thing it is thunking to is.  */\n       DECL_INTERFACE_KNOWN (thunk) = 1;"}, {"sha": "ec0838c29172cb4fc8496a235f4cafde163256ab", "filename": "gcc/cp/operators.def", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1f6e1acc0f2017e81282604bda62db1b2b865075/gcc%2Fcp%2Foperators.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1f6e1acc0f2017e81282604bda62db1b2b865075/gcc%2Fcp%2Foperators.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Foperators.def?ref=1f6e1acc0f2017e81282604bda62db1b2b865075", "patch": "@@ -108,7 +108,7 @@ DEF_SIMPLE_OPERATOR (\"+\", PLUS_EXPR, \"pl\", \"__pl\", 2)\n DEF_SIMPLE_OPERATOR (\"-\", MINUS_EXPR, \"mi\", \"__mi\", 2)\n DEF_SIMPLE_OPERATOR (\"*\", MULT_EXPR, \"ml\", \"__ml\", 2)\n DEF_SIMPLE_OPERATOR (\"/\", TRUNC_DIV_EXPR, \"dv\", \"__dv\", 2)\n-DEF_SIMPLE_OPERATOR (\"%\", TRUNC_MOD_EXPR, \"md\", \"__md\", 2)\n+DEF_SIMPLE_OPERATOR (\"%\", TRUNC_MOD_EXPR, \"rm\", \"__md\", 2)\n DEF_SIMPLE_OPERATOR (\"&\", BIT_AND_EXPR, \"an\", \"__ad\", 2)\n DEF_SIMPLE_OPERATOR (\"|\", BIT_IOR_EXPR, \"or\", \"__or\", 2)\n DEF_SIMPLE_OPERATOR (\"^\", BIT_XOR_EXPR, \"eo\", \"__er\", 2)\n@@ -131,14 +131,16 @@ DEF_SIMPLE_OPERATOR (\"--\", POSTDECREMENT_EXPR, \"mm\", \"__mm\", 2)\n /* These are extensions.  */\n DEF_SIMPLE_OPERATOR (\"<?\", MIN_EXPR, \"vx3min\", \"__mn\", 2)\n DEF_SIMPLE_OPERATOR (\">?\", MAX_EXPR, \"vx3max\", \"__mx\", 2)\n+/* This one is needed for mangling.  */\n+DEF_SIMPLE_OPERATOR (\"::\", SCOPE_REF, \"sr\", NULL, 2);\n \n /* Assignment operators.  */\n DEF_ASSN_OPERATOR (\"=\", NOP_EXPR, \"aS\", \"__as\", 2)\n DEF_ASSN_OPERATOR (\"+=\", PLUS_EXPR, \"pL\", \"__apl\", 2)\n DEF_ASSN_OPERATOR (\"-=\", MINUS_EXPR, \"mI\", \"__ami\", 2)\n DEF_ASSN_OPERATOR (\"*=\", MULT_EXPR, \"mL\", \"__aml\", 2)\n DEF_ASSN_OPERATOR (\"/=\", TRUNC_DIV_EXPR, \"dV\", \"__adv\", 2)\n-DEF_ASSN_OPERATOR (\"%=\", TRUNC_MOD_EXPR, \"mD\", \"__amd\", 2)\n+DEF_ASSN_OPERATOR (\"%=\", TRUNC_MOD_EXPR, \"rM\", \"__amd\", 2)\n DEF_ASSN_OPERATOR (\"&=\", BIT_AND_EXPR, \"aN\", \"__aad\", 2)\n DEF_ASSN_OPERATOR (\"|=\", BIT_IOR_EXPR, \"oR\", \"__aor\", 2)\n DEF_ASSN_OPERATOR (\"^=\", BIT_XOR_EXPR, \"eO\", \"__aer\", 2)\n@@ -150,4 +152,3 @@ DEF_SIMPLE_OPERATOR (\"?:\", COND_EXPR, \"qu\", \"__cn\", 3)\n \n /* Miscellaneous.  */\n DEF_SIMPLE_OPERATOR (\"()\", CALL_EXPR, \"cl\", \"__cl\", -1)\n-"}, {"sha": "f3c7989b13b1b71c4842e69d520c91130bb08d25", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 116, "deletions": 57, "changes": 173, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1f6e1acc0f2017e81282604bda62db1b2b865075/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1f6e1acc0f2017e81282604bda62db1b2b865075/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=1f6e1acc0f2017e81282604bda62db1b2b865075", "patch": "@@ -1984,6 +1984,10 @@ build_template_decl (decl, parms)\n       DECL_STATIC_FUNCTION_P (tmpl) = DECL_STATIC_FUNCTION_P (decl);\n       DECL_CONSTRUCTOR_P (tmpl) = DECL_CONSTRUCTOR_P (decl);\n       DECL_NONCONVERTING_P (tmpl) = DECL_NONCONVERTING_P (decl);\n+      DECL_ASSIGNMENT_OPERATOR_P (tmpl) = DECL_ASSIGNMENT_OPERATOR_P (decl);\n+      if (DECL_OVERLOADED_OPERATOR_P (decl))\n+\tSET_OVERLOADED_OPERATOR_CODE (tmpl, \n+\t\t\t\t      DECL_OVERLOADED_OPERATOR_P (decl));\n     }\n \n   return tmpl;\n@@ -4047,8 +4051,11 @@ lookup_template_class (d1, arglist, in_decl, context, entering_scope)\n       DECL_ASSEMBLER_NAME (type_decl) = DECL_NAME (type_decl);\n       if (!is_partial_instantiation)\n \t{\n-\t  DECL_ASSEMBLER_NAME (type_decl)\n-\t    = get_identifier (build_overload_name (t, 1, 1));\n+\t  if (flag_new_abi)\n+\t    DECL_ASSEMBLER_NAME (type_decl) = mangle_decl (type_decl);\n+\t  else\n+\t    DECL_ASSEMBLER_NAME (type_decl)\n+\t      = get_identifier (build_overload_name (t, 1, 1));\n \n \t  /* For backwards compatibility; code that uses\n \t     -fexternal-templates expects looking up a template to\n@@ -5708,10 +5715,15 @@ tsubst_decl (t, args, type, in_decl)\n \t\t\t      /*complain=*/1, t,\n \t\t\t      /*entering_scope=*/1);\n \n-\tif (member && DECL_CONV_FN_P (r))\n-\t  /* Type-conversion operator.  Reconstruct the name, in\n-\t     case it's the name of one of the template's parameters.  */\n-\t  DECL_NAME (r) = build_typename_overload (TREE_TYPE (type));\n+\tif (member && DECL_CONV_FN_P (r)) \n+\t  {\n+\t    /* Type-conversion operator.  Reconstruct the name, in\n+\t       case it's the name of one of the template's parameters.  */\n+\t    if (flag_new_abi)\n+\t      DECL_NAME (r) = mangle_conv_op_name_for_type (TREE_TYPE (type));\n+\t    else\n+\t      DECL_NAME (r) = build_typename_overload (TREE_TYPE (type));\n+\t  }\n \n \tDECL_ARGUMENTS (r) = tsubst (DECL_ARGUMENTS (t), args,\n \t\t\t\t     /*complain=*/1, t);\n@@ -5745,8 +5757,13 @@ tsubst_decl (t, args, type, in_decl)\n \t    register_specialization (r, gen_tmpl, argvec);\n \n \t    /* Set the mangled name for R.  */\n-\t    if (DECL_DESTRUCTOR_P (t))\n-\t      DECL_ASSEMBLER_NAME (r) = build_destructor_name (ctx);\n+\t    if (DECL_DESTRUCTOR_P (t)) \n+\t      {\n+\t\tif (flag_new_abi)\n+\t\t  set_mangled_name_for_decl (r);\n+\t\telse\n+\t\t  DECL_ASSEMBLER_NAME (r) = build_destructor_name (ctx);\n+\t      }\n \t    else \n \t      {\n \t\t/* Instantiations of template functions must be mangled\n@@ -7078,8 +7095,13 @@ tsubst_copy (t, args, complain, in_decl)\n \n     case IDENTIFIER_NODE:\n       if (IDENTIFIER_TYPENAME_P (t))\n-\treturn (build_typename_overload\n-\t\t(tsubst (TREE_TYPE (t), args, complain, in_decl)));\n+\t{\n+\t  tree new_type = tsubst (TREE_TYPE (t), args, complain, in_decl);\n+\t  if (flag_new_abi)\n+\t    return mangle_conv_op_name_for_type (new_type);\n+\t  else\n+\t    return (build_typename_overload (new_type));\n+\t}\n       else\n \treturn t;\n \n@@ -9911,6 +9933,80 @@ tsubst_enum (tag, newtag, args)\n   finish_enum (newtag);\n }\n \n+/* DECL is a FUNCTION_DECL that is a template specialization.  Return\n+   its type -- but without substituting the innermost set of template\n+   arguments.  So, innermost set of template parameters will appear in\n+   the type.  If CONTEXTP is non-NULL, then the partially substituted\n+   DECL_CONTEXT (if any) will also be filled in.  Similarly, TPARMSP\n+   will be filled in with the substituted template parameters, if it\n+   is non-NULL.  */\n+\n+tree \n+get_mostly_instantiated_function_type (decl, contextp, tparmsp)\n+     tree decl;\n+     tree *contextp;\n+     tree *tparmsp;\n+{\n+  tree context = NULL_TREE;\n+  tree fn_type;\n+  tree tmpl;\n+  tree targs;\n+  tree tparms;\n+  int parm_depth;\n+\n+  tmpl = most_general_template (DECL_TI_TEMPLATE (decl));\n+  targs = DECL_TI_ARGS (decl);\n+  tparms = DECL_TEMPLATE_PARMS (tmpl);\n+  parm_depth = TMPL_PARMS_DEPTH (tparms);\n+\n+  /* There should be as many levels of arguments as there are levels\n+     of parameters.  */\n+  my_friendly_assert (parm_depth == TMPL_ARGS_DEPTH (targs), 0);\n+\n+  fn_type = TREE_TYPE (tmpl);\n+  if (DECL_STATIC_FUNCTION_P (decl))\n+    context = DECL_CONTEXT (decl);\n+\n+  if (parm_depth == 1)\n+    /* No substitution is necessary.  */\n+    ;\n+  else\n+    {\n+      int i;\n+      tree partial_args;\n+\n+      /* Replace the innermost level of the TARGS with NULL_TREEs to\n+\t let tsubst know not to subsitute for those parameters.  */\n+      partial_args = make_tree_vec (TREE_VEC_LENGTH (targs));\n+      for (i = 1; i < TMPL_ARGS_DEPTH (targs); ++i)\n+\tSET_TMPL_ARGS_LEVEL (partial_args, i,\n+\t\t\t     TMPL_ARGS_LEVEL (targs, i));\n+      SET_TMPL_ARGS_LEVEL (partial_args,\n+\t\t\t   TMPL_ARGS_DEPTH (targs),\n+\t\t\t   make_tree_vec (DECL_NTPARMS (tmpl)));\n+\n+      /* Now, do the (partial) substitution to figure out the\n+\t appropriate function type.  */\n+      fn_type = tsubst (fn_type, partial_args, /*complain=*/1, NULL_TREE);\n+      if (DECL_STATIC_FUNCTION_P (decl))\n+\tcontext = tsubst (context, partial_args, /*complain=*/1, NULL_TREE);\n+\n+      /* Substitute into the template parameters to obtain the real\n+\t innermost set of parameters.  This step is important if the\n+\t innermost set of template parameters contains value\n+\t parameters whose types depend on outer template parameters.  */\n+      TREE_VEC_LENGTH (partial_args)--;\n+      tparms = tsubst_template_parms (tparms, partial_args, /*complain=*/1);\n+    }\n+\n+  if (contextp)\n+    *contextp = context;\n+  if (tparmsp)\n+    *tparmsp = tparms;\n+\n+  return fn_type;\n+}\n+\n /* Set the DECL_ASSEMBLER_NAME for DECL, which is a FUNCTION_DECL that\n    is either an instantiation or specialization of a template\n    function.  */\n@@ -9925,12 +10021,17 @@ set_mangled_name_for_template_decl (decl)\n   tree parm_types;\n   tree tparms;\n   tree targs;\n-  tree tmpl;\n-  int parm_depth;\n \n   my_friendly_assert (TREE_CODE (decl) == FUNCTION_DECL, 0);\n   my_friendly_assert (DECL_TEMPLATE_INFO (decl) != NULL_TREE, 0);\n \n+  /* Under the new ABI, we don't need special machinery.  */\n+  if (flag_new_abi)\n+    {\n+      set_mangled_name_for_decl (decl);\n+      return;\n+    }\n+\n   /* The names of template functions must be mangled so as to indicate\n      what template is being specialized with what template arguments.\n      For example, each of the following three functions must get\n@@ -9946,14 +10047,6 @@ set_mangled_name_for_template_decl (decl)\n        mangle the name of such an entity.  */\n     return;\n \n-  tmpl = most_general_template (DECL_TI_TEMPLATE (decl));\n-  tparms = DECL_TEMPLATE_PARMS (tmpl);\n-  parm_depth = TMPL_PARMS_DEPTH (tparms);\n-\n-  /* There should be as many levels of arguments as there are levels\n-     of parameters.  */\n-  my_friendly_assert (parm_depth == TMPL_ARGS_DEPTH (targs), 0);\n-\n   /* We now compute the PARMS and RET_TYPE to give to\n      build_decl_overload_real.  The PARMS and RET_TYPE are the\n      parameter and return types of the template, after all but the\n@@ -9972,41 +10065,7 @@ set_mangled_name_for_template_decl (decl)\n      {int, U}.  Thus, the args that we want to subsitute into the\n      return and parameter type for the function are those in TARGS,\n      with the innermost level omitted.  */\n-  fn_type = TREE_TYPE (tmpl);\n-  if (DECL_STATIC_FUNCTION_P (decl))\n-    context = DECL_CONTEXT (decl);\n-\n-  if (parm_depth == 1)\n-    /* No substitution is necessary.  */\n-    ;\n-  else\n-    {\n-      int i;\n-      tree partial_args;\n-\n-      /* Replace the innermost level of the TARGS with NULL_TREEs to\n-\t let tsubst know not to subsitute for those parameters.  */\n-      partial_args = make_tree_vec (TMPL_ARGS_DEPTH (targs));\n-      for (i = 1; i < TMPL_ARGS_DEPTH (targs); ++i)\n-\tSET_TMPL_ARGS_LEVEL (partial_args, i,\n-\t\t\t     TMPL_ARGS_LEVEL (targs, i));\n-      SET_TMPL_ARGS_LEVEL (partial_args,\n-\t\t\t   TMPL_ARGS_DEPTH (targs),\n-\t\t\t   make_tree_vec (DECL_NTPARMS (tmpl)));\n-\n-      /* Now, do the (partial) substitution to figure out the\n-\t appropriate function type.  */\n-      fn_type = tsubst (fn_type, partial_args, /*complain=*/1, NULL_TREE);\n-      if (DECL_STATIC_FUNCTION_P (decl))\n-\tcontext = tsubst (context, partial_args, /*complain=*/1, NULL_TREE);\n-\n-      /* Substitute into the template parameters to obtain the real\n-\t innermost set of parameters.  This step is important if the\n-\t innermost set of template parameters contains value\n-\t parameters whose types depend on outer template parameters.  */\n-      TREE_VEC_LENGTH (partial_args)--;\n-      tparms = tsubst_template_parms (tparms, partial_args, /*complain=*/1);\n-    }\n+  fn_type = get_mostly_instantiated_function_type (decl, &context, &tparms);\n \n   /* Now, get the innermost parameters and arguments, and figure out\n      the parameter and return types.  */\n@@ -10034,10 +10093,10 @@ set_mangled_name_for_template_decl (decl)\n   my_friendly_assert (TREE_VEC_LENGTH (tparms) == TREE_VEC_LENGTH (targs),\n \t\t      0);\n \n-  /* Actually set the DCL_ASSEMBLER_NAME.  */\n+  /* Actually set the DECL_ASSEMBLER_NAME.  */\n   DECL_ASSEMBLER_NAME (decl)\n     = build_decl_overload_real (decl, parm_types, ret_type,\n \t\t\t\ttparms, targs, \n \t\t\t\tDECL_FUNCTION_MEMBER_P (decl) \n-\t\t\t\t+ DECL_MAYBE_IN_CHARGE_CONSTRUCTOR_P (decl));\n+\t\t\t        + DECL_MAYBE_IN_CHARGE_CONSTRUCTOR_P (decl));\n }"}, {"sha": "45c4c64d12e130b888481f724e8b6aaf757cef24", "filename": "gcc/cp/rtti.c", "status": "modified", "additions": 28, "deletions": 7, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1f6e1acc0f2017e81282604bda62db1b2b865075/gcc%2Fcp%2Frtti.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1f6e1acc0f2017e81282604bda62db1b2b865075/gcc%2Fcp%2Frtti.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Frtti.c?ref=1f6e1acc0f2017e81282604bda62db1b2b865075", "patch": "@@ -377,8 +377,14 @@ static tree\n tinfo_name (type)\n      tree type;\n {\n-  const char *name = build_overload_name (type, 1, 1);\n-  tree name_string = combine_strings (build_string (strlen (name) + 1, name));\n+  const char *name;\n+  tree name_string;\n+\n+  if (flag_new_abi)\n+    name = mangle_type_string (type);\n+  else\n+    name = build_overload_name (type, 1, 1);\n+  name_string = combine_strings (build_string (strlen (name) + 1, name));\n   return name_string;\n }\n \n@@ -403,15 +409,18 @@ get_tinfo_decl (type)\n     type = build_function_type (TREE_TYPE (type),\n \t\t\t\tTREE_CHAIN (TYPE_ARG_TYPES (type)));\n \n-  name = build_overload_with_type (tinfo_decl_id, type);\n+  if (flag_new_abi)\n+    name = mangle_typeinfo_for_type (type);\n+  else\n+    name = build_overload_with_type (tinfo_decl_id, type);\n \n   d = IDENTIFIER_GLOBAL_VALUE (name);\n   if (d)\n     /* OK */;\n   else if (!new_abi_rtti_p ())\n     {\n-      /* The tinfo decl is a function returning a reference to the type_info\n-         object.  */\n+      /* The tinfo decl is a function returning a reference to the\n+\t type_info object.  */\n       d = push_library_fn (name, tinfo_decl_type);\n       DECL_NOT_REALLY_EXTERN (d) = 1;\n       SET_DECL_TINFO_FN_P (d);\n@@ -1298,12 +1307,18 @@ tinfo_base_init (desc, target)\n   tree name_decl;\n   \n   {\n+    tree name_name;\n+    \n     /* Generate the NTBS array variable.  */\n-    tree name_name = build_overload_with_type (tinfo_var_id, target);\n     tree name_type = build_cplus_array_type\n                      (build_qualified_type (char_type_node, TYPE_QUAL_CONST),\n                      NULL_TREE);\n     tree name_string = tinfo_name (target);\n+\n+    if (flag_new_abi)\n+      name_name = mangle_typeinfo_for_type (target);\n+    else\n+      name_name = build_overload_with_type (tinfo_var_id, target);\n     name_decl = build_lang_decl (VAR_DECL, name_name, name_type);\n     \n     DECL_ARTIFICIAL (name_decl) = 1;\n@@ -1312,7 +1327,13 @@ tinfo_base_init (desc, target)\n     DECL_EXTERNAL (name_decl) = 0;\n     TREE_PUBLIC (name_decl) = 1;\n     comdat_linkage (name_decl);\n-    DECL_ASSEMBLER_NAME (name_decl) = DECL_NAME (name_decl);\n+    if (flag_new_abi)\n+      /* The new ABI specifies the external name of the string\n+\t containing the type's name.  */\n+      DECL_ASSEMBLER_NAME (name_decl) \n+\t= mangle_typeinfo_string_for_type (target);\n+    else\n+      DECL_ASSEMBLER_NAME (name_decl) = DECL_NAME (name_decl);\n     DECL_INITIAL (name_decl) = name_string;\n     cp_finish_decl (name_decl, name_string, NULL_TREE, 0);\n   }"}, {"sha": "282fae609b51a0148bf5d563f34febe958a2a0a4", "filename": "gcc/testsuite/g++.old-deja/g++.abi/ptrmem.C", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1f6e1acc0f2017e81282604bda62db1b2b865075/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.abi%2Fptrmem.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1f6e1acc0f2017e81282604bda62db1b2b865075/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.abi%2Fptrmem.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.abi%2Fptrmem.C?ref=1f6e1acc0f2017e81282604bda62db1b2b865075", "patch": "@@ -26,9 +26,9 @@ struct T : public S\n // Provide access to the raw function pointers.  This is\n // mangling-dependent.\n \n-extern \"C\" void f__1T ();\n-extern \"C\" void g__1T ();\n-extern \"C\" void h__1T ();\n+extern \"C\" void _ZN1T1fEv ();\n+extern \"C\" void _ZN1T1gEv ();\n+extern \"C\" void _ZN1T1hEv ();\n \n // This structure is a C representation of a pointer-to-member.\n \n@@ -72,12 +72,12 @@ main ()\n   // There should be no adjustment for the `T' version, and an\n   // appropriate adjustment for the `S' version.\n   y = &T::f;\n-  if (yp->ptr != &f__1T)\n+  if (yp->ptr != &_ZN1T1fEv)\n     return 5;\n   if (yp->adj != 0)\n     return 6;\n   x = (sp) y;\n-  if (xp->ptr != &f__1T)\n+  if (xp->ptr != &_ZN1T1fEv)\n     return 7;\n   if (xp->adj != delta)\n     return 8;"}, {"sha": "b719c70a533d40b22592b7ca702527b58978147b", "filename": "gcc/testsuite/g++.old-deja/g++.abi/vtable2.C", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1f6e1acc0f2017e81282604bda62db1b2b865075/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.abi%2Fvtable2.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1f6e1acc0f2017e81282604bda62db1b2b865075/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.abi%2Fvtable2.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.abi%2Fvtable2.C?ref=1f6e1acc0f2017e81282604bda62db1b2b865075", "patch": "@@ -122,8 +122,8 @@ void S4::s1 ()\n // These are tricks to allow us to get raw function pointers for\n // member functions.\n extern \"C\" {\n-void s3__2S3 ();\n-void s1__2S4 ();\n+void _ZN2S32s3Ev ();\n+void _ZN2S42s1Ev ();\n }\n \n int main ()\n@@ -147,9 +147,9 @@ int main ()\n     return 4;\n   // Skip the RTTI entry.\n   vtbl++;\n-  if (*vtbl++ != (ptrdiff_t) &s3__2S3)\n+  if (*vtbl++ != (ptrdiff_t) &_ZN2S32s3Ev)\n     return 5;\n-  if (*vtbl++ != (ptrdiff_t) &s1__2S4)\n+  if (*vtbl++ != (ptrdiff_t) &_ZN2S42s1Ev)\n     return 6;\n   // The S1 vbase offset.\n   if (*vtbl++ != 0)"}, {"sha": "21e7b32d9a0278a5f5e0f9bde87a9c64a71b8f9c", "filename": "gcc/testsuite/g++.old-deja/g++.other/mangle1.C", "status": "modified", "additions": 24, "deletions": 11, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1f6e1acc0f2017e81282604bda62db1b2b865075/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.other%2Fmangle1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1f6e1acc0f2017e81282604bda62db1b2b865075/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.other%2Fmangle1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.other%2Fmangle1.C?ref=1f6e1acc0f2017e81282604bda62db1b2b865075", "patch": "@@ -1,45 +1,58 @@\n // Test for proper mangling by setting up name clashes.\n // Special g++ Options: -fno-squangle\n \n+#if (!defined (__GXX_ABI_VERSION) || __GXX_ABI_VERSION < 100)\n+#define NAME(OLD, NEW) OLD\n+#else\n+#define NAME(OLD, NEW) NEW\n+#endif /* (!defined (__GXX_ABI_VERSION) || __GXX_ABI_VERSION < 100) */\n+\n class A { };\n typedef A A2;\n typedef int I;\n typedef void V;\n typedef I I2;\n \n void f (const A2&, int, const A2&, const A&) { } // ERROR - name clash\n-int f__FRC1AiT0T0 = 0; // ERROR - name clash\n+int NAME (f__FRC1AiT0T0, _Z1fRK1AiS1_S1_) = 0; // ERROR - name clash\n \n void f (int, long, int, I) { } // ERROR - name clash\n-int f__Filii = 0; // ERROR - name clash\n+int NAME (f__Filii, _Z1filii) = 0; // ERROR - name clash\n \n void f (I, float, I, I2) { } // ERROR - name clash\n-int f__Fifii = 0; // ERROR - name clash\n+int NAME (f__Fifii, _Z1fifii) = 0; // ERROR - name clash\n \n void f (void*, float, void*, V*) { } // ERROR - name clash\n-int f__FPvfT0T0 = 0; // ERROR - name clash\n+int NAME (f__FPvfT0T0, _Z1fPvfS_S_) = 0; // ERROR - name clash\n \n void f (wchar_t) { } // ERROR - name clash\n-int f__Fw = 0; // ERROR - name clash\n+int NAME (f__Fw, _Z1fw) = 0; // ERROR - name clash\n \n void f(int, A, A2, A) { } // ERROR - name clash\n-int f__FiG1AN21 = 0; // ERROR - name clash\n+int NAME (f__FiG1AN21, _Z1fi1AS_S_) = 0; // ERROR - name clash\n \n void f(const A2&, const A2&, const A2&, const A2&,\n        int&) { } // ERROR - name clash\n-int f__FRC1AN30Ri = 0; // ERROR - name clash\n+int NAME (f__FRC1AN30Ri, _Z1fRK1AS1_S1_S1_Ri) = 0; // ERROR - name clash\n \n void f(const A2&, int, const A2&, const A2&, const A2&,\n        int&) { } // ERROR - name clash\n-int f__FRC1AiT0N20Ri = 0; // ERROR - name clash\n+int NAME (f__FRC1AiT0N20Ri, _Z1fRK1AiS1_S1_S1_Ri) = 0; // ERROR - name clash\n \n void f(const A2&, int, const A2&, const A2&, const A2&, int&, int&,\n        int&) { } // ERROR - name clash\n-int f__FRC1AiT0N20RiN25 = 0; // ERROR - name clash\n+int NAME (f__FRC1AiT0N20RiN25, _Z1fRK1AiS1_S1_S1_RiS2_S2_) = 0; // ERROR - name clash\n \n void f(const A2&, int, const A2&, const A2&, const A2&, int, int,\n        int) { } // ERROR - name clash\n-int f__FRC1AiT0N20iii = 0; // ERROR - name clash\n+int NAME (f__FRC1AiT0N20iii, _Z1fRK1AiS1_S1_S1_iii) = 0; // ERROR - name clash\n \n void f(bool, bool) {} // ERROR - name clash\n-int f__FbT0 = 0; // ERROR - name clash\n+int NAME (f__FbT0, _Z1fbb) = 0; // ERROR - name clash\n+\n+int\n+main ()\n+{\n+  return 0;\n+}\n+"}, {"sha": "873cb369e76eaf1d78122f7b9ab1ab1549ca2204", "filename": "gcc/testsuite/g++.old-deja/g++.other/mangle2.C", "status": "removed", "additions": 0, "deletions": 42, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/031926e2a3b8593caea2941bdaf06b04042ef598/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.other%2Fmangle2.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/031926e2a3b8593caea2941bdaf06b04042ef598/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.other%2Fmangle2.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.other%2Fmangle2.C?ref=031926e2a3b8593caea2941bdaf06b04042ef598", "patch": "@@ -1,42 +0,0 @@\n-// Test for proper mangling by setting up name clashes.\n-// Special g++ Options: -fsquangle\n-\n-class A;\n-typedef A A2;\n-typedef int I;\n-typedef void V;\n-typedef I I2;\n-\n-void f (const A2&, int, const A2&, const A&) { } // ERROR - name clash\n-int f__FRC1AiRCB0n1 = 0; // ERROR - name clash\n-\n-void f (int, long, int, I) { } // ERROR - name clash\n-int f__Filii = 0; // ERROR - name clash\n-\n-void f (I, float, I, I2) { } // ERROR - name clash\n-int f__Fifii = 0; // ERROR - name clash\n-\n-void f (void*, float, void*, V*) { } // ERROR - name clash\n-int f__FPvfPvn1 = 0; // ERROR - name clash\n-\n-void f (wchar_t) { } // ERROR - name clash\n-int f__Fw = 0; // ERROR - name clash\n-\n-void f(int, A, A2, A) { } // ERROR - name clash\n-int f__FiG1An2 = 0; // ERROR - name clash\n-\n-void f(const A2&, const A2&, const A2&, const A2&,\n-       int&) { } // ERROR - name clash\n-int f__FRC1An3Ri = 0; // ERROR - name clash\n-\n-void f(const A2&, int, const A2&, const A2&, const A2&,\n-       int&) { } // ERROR - name clash\n-int f__FRC1AiRCB0n2Ri = 0; // ERROR - name clash\n-\n-void f(const A2&, int, const A2&, const A2&, const A2&, int&, int&,\n-       int&) { } // ERROR - name clash\n-int f__FRC1AiRCB0n2Rin2 = 0; // ERROR - name clash\n-\n-void f(const A2&, int, const A2&, const A2&, const A2&, int, int,\n-       int) { } // ERROR - name clash\n-int f__FRC1AiRCB0n2in2 = 0; // ERROR - name clash"}, {"sha": "6158f50299d04e28bdc3bbb5d5b5130783f3e1a2", "filename": "gcc/testsuite/g++.old-deja/g++.other/static8.C", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1f6e1acc0f2017e81282604bda62db1b2b865075/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.other%2Fstatic8.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1f6e1acc0f2017e81282604bda62db1b2b865075/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.other%2Fstatic8.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.other%2Fstatic8.C?ref=1f6e1acc0f2017e81282604bda62db1b2b865075", "patch": "@@ -2,6 +2,12 @@\n // Special g++ Options: -fno-squangle\n // Origin: Mark Mitchell <mark@codesourcery.com>\n \n+#if (!defined (__GXX_ABI_VERSION) || __GXX_ABI_VERSION < 100)\n+#define NAME(OLD, NEW) OLD\n+#else\n+#define NAME(OLD, NEW) NEW\n+#endif /* (!defined (__GXX_ABI_VERSION) || __GXX_ABI_VERSION < 100) */\n+\n static unsigned int strlen (const char*) {} // ERROR - previous declaration\n \n-int strlen__FPCc = 0; // ERROR - duplicate declaration\n+int NAME (strlen__FPCc, _Z6strlenPKc) = 0; // ERROR - duplicate declaration"}]}