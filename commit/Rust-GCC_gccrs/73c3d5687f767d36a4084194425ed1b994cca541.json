{"sha": "73c3d5687f767d36a4084194425ed1b994cca541", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzNjM2Q1Njg3Zjc2N2QzNmE0MDg0MTk0NDI1ZWQxYjk5NGNjYTU0MQ==", "commit": {"author": {"name": "Frank Ch. Eigler", "email": "fche@redhat.com", "date": "2004-08-03T13:40:21Z"}, "committer": {"name": "Frank Ch. Eigler", "email": "fche@gcc.gnu.org", "date": "2004-08-03T13:40:21Z"}, "message": "mf-runtime.c (compare_uintptr_t): Remove function.\n\n2004-08-03  Frank Ch. Eigler  <fche@redhat.com>\n\n\t* mf-runtime.c (compare_uintptr_t): Remove function.  Inline\n\tsimplified contents in all former callers.\n\nFrom-SVN: r85475", "tree": {"sha": "01c9fe801ca923d2a57f06a82d7e0bdcecc46974", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/01c9fe801ca923d2a57f06a82d7e0bdcecc46974"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/73c3d5687f767d36a4084194425ed1b994cca541", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/73c3d5687f767d36a4084194425ed1b994cca541", "html_url": "https://github.com/Rust-GCC/gccrs/commit/73c3d5687f767d36a4084194425ed1b994cca541", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/73c3d5687f767d36a4084194425ed1b994cca541/comments", "author": {"login": "fche", "id": 588885, "node_id": "MDQ6VXNlcjU4ODg4NQ==", "avatar_url": "https://avatars.githubusercontent.com/u/588885?v=4", "gravatar_id": "", "url": "https://api.github.com/users/fche", "html_url": "https://github.com/fche", "followers_url": "https://api.github.com/users/fche/followers", "following_url": "https://api.github.com/users/fche/following{/other_user}", "gists_url": "https://api.github.com/users/fche/gists{/gist_id}", "starred_url": "https://api.github.com/users/fche/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/fche/subscriptions", "organizations_url": "https://api.github.com/users/fche/orgs", "repos_url": "https://api.github.com/users/fche/repos", "events_url": "https://api.github.com/users/fche/events{/privacy}", "received_events_url": "https://api.github.com/users/fche/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "1e45521fdb99c13c4c0bcdb2252d98539b928666", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1e45521fdb99c13c4c0bcdb2252d98539b928666", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1e45521fdb99c13c4c0bcdb2252d98539b928666"}], "stats": {"total": 39, "additions": 16, "deletions": 23}, "files": [{"sha": "72359100deec01c0e1275b610b5095238aa0ab9d", "filename": "libmudflap/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/73c3d5687f767d36a4084194425ed1b994cca541/libmudflap%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/73c3d5687f767d36a4084194425ed1b994cca541/libmudflap%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libmudflap%2FChangeLog?ref=73c3d5687f767d36a4084194425ed1b994cca541", "patch": "@@ -1,3 +1,8 @@\n+2004-08-03  Frank Ch. Eigler  <fche@redhat.com>\n+\n+\t* mf-runtime.c (compare_uintptr_t): Remove function.  Inline\n+\tsimplified contents in all former callers.\n+\n 2004-07-27  Ulrich Weigand  <weigand@informatik.uni-erlangen.de>\n \n \t* mf-runtime.c (__mf_fini): Set mudflap_mode to mode_nop in"}, {"sha": "d8ba77531cf95781af286167806171ae904d3492", "filename": "libmudflap/mf-runtime.c", "status": "modified", "additions": 11, "deletions": 23, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/73c3d5687f767d36a4084194425ed1b994cca541/libmudflap%2Fmf-runtime.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/73c3d5687f767d36a4084194425ed1b994cca541/libmudflap%2Fmf-runtime.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libmudflap%2Fmf-runtime.c?ref=73c3d5687f767d36a4084194425ed1b994cca541", "patch": "@@ -2247,22 +2247,6 @@ static mfsplay_tree_node mfsplay_tree_splay_helper (mfsplay_tree,\n                                                 mfsplay_tree_node *,\n                                                 mfsplay_tree_node *,\n                                                 mfsplay_tree_node *);\n-static void *mfsplay_tree_xmalloc (size_t size);\n-static void mfsplay_tree_free (void *object);\n-\n-\n-\n-/* Inline comparison function specialized for libmudflap's key type.  */\n-static inline int\n-compare_uintptr_t (mfsplay_tree_key k1, mfsplay_tree_key k2)\n-{\n-  if ((uintptr_t) k1 < (uintptr_t) k2)\n-    return -1;\n-  else if ((uintptr_t) k1 > (uintptr_t) k2)\n-    return 1;\n-  else\n-    return 0;\n-}\n \n \n /* Help splay SP around KEY.  PARENT and GRANDPARENT are the parent\n@@ -2284,7 +2268,7 @@ mfsplay_tree_splay_helper (mfsplay_tree sp,\n   if (!n)\n     return *parent;\n \n-  comparison = compare_uintptr_t (key, n->key);\n+  comparison = ((key > n->key) ? 1 : ((key < n->key) ? -1 : 0));\n \n   if (comparison == 0)\n     /* We've found the target.  */\n@@ -2454,7 +2438,7 @@ mfsplay_tree_splay (mfsplay_tree sp, mfsplay_tree_key key)\n \n   /* If we just splayed the tree with the same key, do nothing.  */\n   if (sp->last_splayed_key_p &&\n-      compare_uintptr_t (sp->last_splayed_key, key) == 0)\n+      (sp->last_splayed_key == key))\n     return;\n \n   /* Compute a maximum recursion depth for a splay tree with NUM nodes.\n@@ -2514,7 +2498,8 @@ mfsplay_tree_insert (mfsplay_tree sp, mfsplay_tree_key key, mfsplay_tree_value v\n   mfsplay_tree_splay (sp, key);\n \n   if (sp->root)\n-    comparison = compare_uintptr_t (sp->root->key, key);\n+    comparison = ((sp->root->key > key) ? 1 :\n+                  ((sp->root->key < key) ? -1 : 0));\n \n   if (sp->root && comparison == 0)\n     {\n@@ -2560,7 +2545,7 @@ mfsplay_tree_remove (mfsplay_tree sp, mfsplay_tree_key key)\n {\n   mfsplay_tree_splay (sp, key);\n   sp->last_splayed_key_p = 0;\n-  if (sp->root && compare_uintptr_t (sp->root->key, key) == 0)\n+  if (sp->root && (sp->root->key == key))\n     {\n       mfsplay_tree_node left, right;\n       left = sp->root->left;\n@@ -2594,7 +2579,7 @@ static mfsplay_tree_node\n mfsplay_tree_lookup (mfsplay_tree sp, mfsplay_tree_key key)\n {\n   mfsplay_tree_splay (sp, key);\n-  if (sp->root && compare_uintptr_t (sp->root->key, key) == 0)\n+  if (sp->root && (sp->root->key == key))\n     return sp->root;\n   else\n     return 0;\n@@ -2615,7 +2600,9 @@ mfsplay_tree_predecessor (mfsplay_tree sp, mfsplay_tree_key key)\n   /* Splay the tree around KEY.  That will leave either the KEY\n      itself, its predecessor, or its successor at the root.  */\n   mfsplay_tree_splay (sp, key);\n-  comparison = compare_uintptr_t (sp->root->key, key);\n+  comparison = ((sp->root->key > key) ? 1 :\n+                ((sp->root->key < key) ? -1 : 0));\n+\n   /* If the predecessor is at the root, just return it.  */\n   if (comparison < 0)\n     return sp->root;\n@@ -2641,7 +2628,8 @@ mfsplay_tree_successor (mfsplay_tree sp, mfsplay_tree_key key)\n   /* Splay the tree around KEY.  That will leave either the KEY\n      itself, its predecessor, or its successor at the root.  */\n   mfsplay_tree_splay (sp, key);\n-  comparison = compare_uintptr_t (sp->root->key, key);\n+  comparison = ((sp->root->key > key) ? 1 :\n+                ((sp->root->key < key) ? -1 : 0));\n   /* If the successor is at the root, just return it.  */\n   if (comparison > 0)\n     return sp->root;"}]}