{"sha": "f0df84ab4a058d5ad3a75a37cb04816c49638aa8", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjBkZjg0YWI0YTA1OGQ1YWQzYTc1YTM3Y2IwNDgxNmM0OTYzOGFhOA==", "commit": {"author": {"name": "Hans-Peter Nilsson", "email": "hp@axis.com", "date": "2012-07-13T08:58:46Z"}, "committer": {"name": "Hans-Peter Nilsson", "email": "hp@gcc.gnu.org", "date": "2012-07-13T08:58:46Z"}, "message": "re PR rtl-optimization/53908 (csa removes needed memory load)\n\n\tPR rtl-optimization/53908\n\t* gcc.dg/torture/pr53908.c: New test.\n\nFrom-SVN: r189455", "tree": {"sha": "e408266eb2bc72e5cd9cb46d1b3a54782a26c0de", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e408266eb2bc72e5cd9cb46d1b3a54782a26c0de"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f0df84ab4a058d5ad3a75a37cb04816c49638aa8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f0df84ab4a058d5ad3a75a37cb04816c49638aa8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f0df84ab4a058d5ad3a75a37cb04816c49638aa8", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f0df84ab4a058d5ad3a75a37cb04816c49638aa8/comments", "author": {"login": "hpataxisdotcom", "id": 80339731, "node_id": "MDQ6VXNlcjgwMzM5NzMx", "avatar_url": "https://avatars.githubusercontent.com/u/80339731?v=4", "gravatar_id": "", "url": "https://api.github.com/users/hpataxisdotcom", "html_url": "https://github.com/hpataxisdotcom", "followers_url": "https://api.github.com/users/hpataxisdotcom/followers", "following_url": "https://api.github.com/users/hpataxisdotcom/following{/other_user}", "gists_url": "https://api.github.com/users/hpataxisdotcom/gists{/gist_id}", "starred_url": "https://api.github.com/users/hpataxisdotcom/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/hpataxisdotcom/subscriptions", "organizations_url": "https://api.github.com/users/hpataxisdotcom/orgs", "repos_url": "https://api.github.com/users/hpataxisdotcom/repos", "events_url": "https://api.github.com/users/hpataxisdotcom/events{/privacy}", "received_events_url": "https://api.github.com/users/hpataxisdotcom/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "b1435931f280564bd885cf17f84ea3ea2ef90826", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b1435931f280564bd885cf17f84ea3ea2ef90826", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b1435931f280564bd885cf17f84ea3ea2ef90826"}], "stats": {"total": 293, "additions": 293, "deletions": 0}, "files": [{"sha": "0e2b8f30a5bcd41f1c7049bdb1795105b73a4791", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f0df84ab4a058d5ad3a75a37cb04816c49638aa8/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f0df84ab4a058d5ad3a75a37cb04816c49638aa8/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=f0df84ab4a058d5ad3a75a37cb04816c49638aa8", "patch": "@@ -1,3 +1,8 @@\n+2012-07-13  Hans-Peter Nilsson  <hp@axis.com>\n+\n+\tPR rtl-optimization/53908\n+\t* gcc.dg/torture/pr53908.c: New test.\n+\n 2012-07-13  Jonathan Wakely  <jwakely.gcc@gmail.com>\n \n \tPR c++/53531"}, {"sha": "e96b635223228f5042c56f9821af68ad3e787d3c", "filename": "gcc/testsuite/gcc.dg/torture/pr53908.c", "status": "added", "additions": 288, "deletions": 0, "changes": 288, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f0df84ab4a058d5ad3a75a37cb04816c49638aa8/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Fpr53908.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f0df84ab4a058d5ad3a75a37cb04816c49638aa8/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Fpr53908.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Fpr53908.c?ref=f0df84ab4a058d5ad3a75a37cb04816c49638aa8", "patch": "@@ -0,0 +1,288 @@\n+/* { dg-do run } */\n+/* SEGV at comment below.  */\n+typedef unsigned int size_t;\n+typedef enum har {\n+  he_fatal = (-199),\n+  he_not_initialized,\n+  he_bad_input,\n+  he_memory_too_small,\n+  he_bad_action,\n+  he_duplicate,\n+  he_bad_nonce,\n+  he_stale_nonce,\n+  he_bad_credentials,\n+  he_bad_user,\n+  he_no_such_user,\n+  he_bad_passwd,\n+  he_unknown_auth_scheme,\n+  he_not_found,\n+  he_failed_digest_file_check,\n+  he_failed_digest_file_save,\n+  he_process_not_privileged,\n+  he_other,\n+  he_end_of_range,\n+  ha_no_error = 0,\n+  ha_no_value = 1\n+} har;\n+typedef enum realm_type\n+{\n+  axis_realm = 0,\n+  ws_realm\n+} realm_type;\n+\n+__attribute__((__noclone__, __noinline__))\n+har has_www_auth(char *, size_t, realm_type, har);\n+\n+__attribute__((__noclone__, __noinline__))\n+har has_auth_user(const char *, const char *, realm_type, char *, size_t);\n+\n+__attribute__((__noclone__, __noinline__))\n+char *ha_get_string_value(void);\n+\n+typedef struct\n+{\n+  unsigned int track_id;\n+  char* user;\n+  char* realm;\n+  char* authent;\n+  int internal_realm;\n+} request;\n+enum user_response {\n+  file_not_found_user_response = -3,\n+  access_denied_user_response = -2,\n+  no_user_response = -1,\n+  ok_user_response = 0\n+};\n+struct realm_group {\n+  char *name;\n+  int id;\n+  struct realm_group *next;\n+};\n+struct realm {\n+  char *name;\n+  char *space;\n+  struct realm_group *groups;\n+  struct realm *next;\n+};\n+struct user_info {\n+  char *name;\n+  int no_groups;\n+  int groups[128];\n+  struct user_info *next;\n+};\n+static struct user_info *find_user(const char *user_name);\n+static int is_member_of_groups(const struct user_info *user_item,\n+                                const struct realm_group *groups);\n+int authent_author(request *req);\n+struct realm *realms = ((void *)0);\n+struct user_info *users = ((void *)0);\n+static struct user_info*\n+find_user(const char *user_name)\n+{\n+  struct user_info *user_item;\n+  user_item = users;\n+  while (user_item != ((void *)0)) {\n+    /* SEGV due to NULL access here on user_name.  See also comment below.  */\n+    if ((__builtin_strcmp(user_item->name, user_name) == 0))\n+      break;\n+    user_item = user_item->next;\n+  }\n+  return user_item;\n+}\n+static int\n+is_member_of_groups(const struct user_info *user_item,\n+                    const struct realm_group *groups)\n+{\n+  const struct realm_group *group_item;\n+  int i;\n+  group_item = groups;\n+  while (group_item != ((void *)0)) {\n+    for (i = 0; i < user_item->no_groups; i++)\n+      if (user_item->groups[i] == group_item->id)\n+\treturn 0;\n+    group_item = group_item->next;\n+  }\n+  return -1;\n+}\n+char *foo (void) __attribute__((__noclone__, __noinline__));\n+char* g_strdup (const char *str) __attribute__((__malloc__, __noclone__, __noinline__));\n+int g_strcmp0 (const char *str1, const char *str2);\n+static int\n+is_basic(char **user)\n+{\n+  char *passwd_ptr;\n+  char *authent = foo();\n+  passwd_ptr = __builtin_strchr(authent, ':');\n+  if (passwd_ptr != ((void *)0)) {\n+    *user = g_strdup(authent);\n+    return 0;\n+  }\n+  return -1;\n+}\n+static int\n+is_digest(char **user)\n+{\n+  int ret_val = -1;\n+  char *authent;\n+  authent = ha_get_string_value();\n+  if (authent) {\n+    *user = g_strdup(authent);\n+    ret_val = 0;\n+  }\n+  return ret_val;\n+}\n+__attribute__((__noclone__, __noinline__))\n+void g_free (void * mem);\n+static enum user_response\n+get_user_info_from_header(const realm_type type,\n+                          char **user_name,\n+                          struct user_info **user_item)\n+{\n+  int ret_val = no_user_response;\n+  if ((type == ws_realm)) {\n+    if (is_basic(user_name) == 0)\n+      ret_val = access_denied_user_response;\n+    if (is_digest(user_name) == 0)\n+      ret_val = ok_user_response;\n+  } else {\n+    if (is_basic(user_name) < 0 &&\n+\t/* Load of *user_name here, but not after the is_digest call.  */\n+\tis_digest(user_name) < 0)\n+      ;\n+    else if ((*user_item = find_user(*user_name)) != ((void *)0))\n+      ret_val = ok_user_response;\n+    else\n+      ret_val = access_denied_user_response;\n+    if (ret_val != ok_user_response)\n+      g_free(*user_name);\n+  }\n+  return ret_val;\n+}\n+static enum user_response\n+authenticate_user(request *req,\n+                  char **user_name,\n+                  struct user_info **user_item)\n+{\n+  char *authent = ((void *)0);\n+  har resp = ha_no_value;\n+  enum user_response user_resp;\n+  int ret_val = no_user_response;\n+  if (req->authent && __builtin_strlen(req->authent)) {\n+    authent = req->authent;\n+    user_resp = get_user_info_from_header(req->internal_realm,\n+                                          user_name,\n+                                          user_item);\n+    if (user_resp == ok_user_response) {\n+      resp = has_auth_user(authent, 0, req->internal_realm, \"\", 1);\n+      if (resp == ha_no_error)\n+\tret_val = ok_user_response;\n+      else if (resp != he_stale_nonce)\n+\tret_val = access_denied_user_response;\n+    } else if (user_resp == access_denied_user_response)\n+      ret_val = access_denied_user_response;\n+  }\n+  if (resp != he_memory_too_small && resp != ha_no_error)\n+    resp = has_www_auth(\"\", 1, req->internal_realm, resp);\n+  return ret_val;\n+}\n+\n+int __attribute__ ((__noinline__, __noclone__))\n+authent_author(request *req)\n+{\n+  struct realm *realm;\n+  char *user_name = ((void *)0);\n+  struct user_info *user_item = ((void *)0);\n+  int res = 0;\n+  asm (\"\");\n+  realm = realms;\n+  if (__builtin_strcmp(\"Wsd\", realm->name) == 0) {\n+    req->internal_realm = ws_realm;\n+    is_digest(&user_name);\n+  }\n+  if (authenticate_user(req, &user_name, &user_item) < 0) {\n+    if (user_name != ((void *)0))\n+      req->user = user_name;\n+    res = -2;\n+    goto authent_author_return;\n+  }\n+  if (is_member_of_groups(user_item, realm->groups) < 0)\n+    res = -1;\n+authent_author_return:\n+  return res;\n+}\n+\n+int good0, good1, good2;\n+\n+__attribute__ ((__noinline__, __noclone__))\n+char *foo(void)\n+{\n+  asm (\"\");\n+  good0++;\n+  return \"\";\n+}\n+\n+__attribute__ ((__noinline__, __noclone__))\n+char *ha_get_string_value(void)\n+{\n+  asm (\"\");\n+  good1++;\n+  return \"f\";\n+}\n+\n+__attribute__ ((__noinline__, __noclone__))\n+har has_auth_user(const char *a, const char *b, realm_type c, char *d, size_t e)\n+{\n+  asm (\"\");\n+  if (*a != 'z' || a[1] != 0 || b != 0 || c != axis_realm || *d != 0\n+      || e != 1)\n+    __builtin_abort ();\n+  return ha_no_error;\n+}\n+\n+__attribute__ ((__noinline__, __noclone__))\n+har has_www_auth(char *a, size_t b, realm_type c, har d)\n+{\n+  (void)(*a+b+c+d);\n+  asm (\"\");\n+  __builtin_abort ();\n+}\n+\n+\n+char *strdupped_user = \"me\";\n+__attribute__((__malloc__, __noclone__, __noinline__))\n+char* g_strdup (const char *str)\n+{\n+  asm (\"\");\n+  if (*str != 'f')\n+    __builtin_abort ();\n+  good2++;\n+  return strdupped_user;\n+}\n+\n+__attribute__((__noclone__, __noinline__))\n+void g_free (void * mem)\n+{\n+  (void)mem;\n+  asm (\"\");\n+  __builtin_abort ();\n+}\n+\n+struct user_info me = { .name = \"me\", .no_groups = 1, .groups = {42}, .next = 0};\n+struct user_info you = { .name = \"you\", .next = &me};\n+struct realm_group xgroups = { .name = \"*\", .id = 42, .next = 0};\n+\n+int main(void)\n+{\n+  char *orig_user = \"?\";\n+  struct realm r = { .name = \"x\", .space = \"space?\", .groups = &xgroups, .next = 0};\n+  request req = { .user = orig_user, .realm = \"!\", .authent = \"z\",\n+\t\t  .internal_realm = axis_realm};\n+  realms = &r;\n+  users = &you;\n+  if (authent_author (&req) != 0 || good0 != 1 || good1 != 1 || good2 != 1\n+      || req.user != orig_user\n+      || req.internal_realm != axis_realm)\n+    __builtin_abort ();\n+  __builtin_exit (0);\n+}\n+"}]}