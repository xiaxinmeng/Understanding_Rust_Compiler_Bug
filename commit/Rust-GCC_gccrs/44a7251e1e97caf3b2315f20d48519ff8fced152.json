{"sha": "44a7251e1e97caf3b2315f20d48519ff8fced152", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDRhNzI1MWUxZTk3Y2FmM2IyMzE1ZjIwZDQ4NTE5ZmY4ZmNlZDE1Mg==", "commit": {"author": {"name": "Richard Earnshaw", "email": "rearnsha@arm.com", "date": "2019-01-22T14:03:22Z"}, "committer": {"name": "Richard Earnshaw", "email": "rearnsha@gcc.gnu.org", "date": "2019-01-22T14:03:22Z"}, "message": "[arm] PR target/88469 fix incorrect argument passing with 64-bit bitfields\n\nUnfortunately another PCS bug has come to light with the layout of\nstructs whose alignment is dominated by a 64-bit bitfield element.\nSuch fields in the type list appear to have alignment 1, but in\nreality, for the purposes of alignment of the underlying structure,\nthe alignment is derived from the underlying bitfield's type.  We've\nbeen getting this wrong since support for over-aligned record types\nwas added several releases back.  Worse still, the existing code may\ngenerate unaligned memory accesses that may fault on some versions of\nthe architecture.\n\nI've taken the opportunity to add a few more tests that check the\npassing arguments with overalignment in the PCS.  Looking through the\nexisting tests it looked like they were really only checking\nself-consistency and not the precise location of the arguments.\n\nPR target/88469\n\ngcc:\n\t* config/arm/arm.c (arm_needs_doubleword_align): Return 2 if a record's\n\talignment is dominated by a bitfield with 64-bit aligned base type.\n\t(arm_function_arg): Emit a warning if the alignment has changed since\n\tearlier GCC releases.\n\t(arm_function_arg_boundary): Likewise.\n\t(arm_setup_incoming_varargs): Likewise.\n\ngcc/testsuite:\n\t* gcc.target/arm/aapcs/bitfield1.c: New test.\n\t* gcc.target/arm/aapcs/overalign_rec1.c: New test.\n\t* gcc.target/arm/aapcs/overalign_rec2.c: New test.\n\t* gcc.target/arm/aapcs/overalign_rec3.c: New test.\n\nFrom-SVN: r268151", "tree": {"sha": "89fa63d90fea36afcd59db535729092fc47a2e5d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/89fa63d90fea36afcd59db535729092fc47a2e5d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/44a7251e1e97caf3b2315f20d48519ff8fced152", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/44a7251e1e97caf3b2315f20d48519ff8fced152", "html_url": "https://github.com/Rust-GCC/gccrs/commit/44a7251e1e97caf3b2315f20d48519ff8fced152", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/44a7251e1e97caf3b2315f20d48519ff8fced152/comments", "author": null, "committer": null, "parents": [{"sha": "50d6ec8cff304c6176b58fa1c44c17d057caa058", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/50d6ec8cff304c6176b58fa1c44c17d057caa058", "html_url": "https://github.com/Rust-GCC/gccrs/commit/50d6ec8cff304c6176b58fa1c44c17d057caa058"}], "stats": {"total": 154, "additions": 150, "deletions": 4}, "files": [{"sha": "2409e7f59a138916741065262f8d716822a84e7c", "filename": "gcc/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/44a7251e1e97caf3b2315f20d48519ff8fced152/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/44a7251e1e97caf3b2315f20d48519ff8fced152/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=44a7251e1e97caf3b2315f20d48519ff8fced152", "patch": "@@ -1,3 +1,13 @@\n+2019-01-22  Richard Earnshaw  <rearnsha@arm.com>\n+\n+\tPR target/88469\n+\t* config/arm/arm.c (arm_needs_doubleword_align): Return 2 if a record's\n+\talignment is dominated by a bitfield with 64-bit aligned base type.\n+\t(arm_function_arg): Emit a warning if the alignment has changed since\n+\tearlier GCC releases.\n+\t(arm_function_arg_boundary): Likewise.\n+\t(arm_setup_incoming_varargs): Likewise.\n+\n 2019-01-22  Richard Biener  <rguenther@suse.de>\n \n \tPR tree-optimization/88862"}, {"sha": "c6fbda25e9635bbc871160f65e71ac4c2c75192e", "filename": "gcc/config/arm/arm.c", "status": "modified", "additions": 28, "deletions": 4, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/44a7251e1e97caf3b2315f20d48519ff8fced152/gcc%2Fconfig%2Farm%2Farm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/44a7251e1e97caf3b2315f20d48519ff8fced152/gcc%2Fconfig%2Farm%2Farm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.c?ref=44a7251e1e97caf3b2315f20d48519ff8fced152", "patch": "@@ -6598,7 +6598,9 @@ arm_init_cumulative_args (CUMULATIVE_ARGS *pcum, tree fntype,\n     }\n }\n \n-/* Return 1 if double word alignment is required for argument passing.\n+/* Return 2 if double word alignment is required for argument passing,\n+   but wasn't required before the fix for PR88469.\n+   Return 1 if double word alignment is required for argument passing.\n    Return -1 if double word alignment used to be required for argument\n    passing before PR77728 ABI fix, but is not required anymore.\n    Return 0 if double word alignment is not required and wasn't requried\n@@ -6618,7 +6620,8 @@ arm_needs_doubleword_align (machine_mode mode, const_tree type)\n     return TYPE_ALIGN (TREE_TYPE (type)) > PARM_BOUNDARY;\n \n   int ret = 0;\n-  /* Record/aggregate types: Use greatest member alignment of any member.  */ \n+  int ret2 = 0;\n+  /* Record/aggregate types: Use greatest member alignment of any member.  */\n   for (tree field = TYPE_FIELDS (type); field; field = DECL_CHAIN (field))\n     if (DECL_ALIGN (field) > PARM_BOUNDARY)\n       {\n@@ -6630,6 +6633,13 @@ arm_needs_doubleword_align (machine_mode mode, const_tree type)\n \t     Make sure we can warn about that with -Wpsabi.  */\n \t  ret = -1;\n       }\n+    else if (TREE_CODE (field) == FIELD_DECL\n+\t     && DECL_BIT_FIELD (field)\n+\t     && TYPE_ALIGN (DECL_BIT_FIELD_TYPE (field)) > PARM_BOUNDARY)\n+      ret2 = 1;\n+\n+  if (ret2)\n+    return 2;\n \n   return ret;\n }\n@@ -6695,7 +6705,12 @@ arm_function_arg (cumulative_args_t pcum_v, machine_mode mode,\n \tinform (input_location, \"parameter passing for argument of type \"\n \t\t\"%qT changed in GCC 7.1\", type);\n       else if (res > 0)\n-\tpcum->nregs++;\n+\t{\n+\t  pcum->nregs++;\n+\t  if (res > 1 && warn_psabi)\n+\t    inform (input_location, \"parameter passing for argument of type \"\n+\t\t    \"%qT changed in GCC 9.1\", type);\n+\t}\n     }\n \n   /* Only allow splitting an arg between regs and memory if all preceding\n@@ -6722,6 +6737,9 @@ arm_function_arg_boundary (machine_mode mode, const_tree type)\n   if (res < 0 && warn_psabi)\n     inform (input_location, \"parameter passing for argument of type %qT \"\n \t    \"changed in GCC 7.1\", type);\n+  if (res > 1 && warn_psabi)\n+    inform (input_location, \"parameter passing for argument of type \"\n+\t    \"%qT changed in GCC 9.1\", type);\n \n   return res > 0 ? DOUBLEWORD_ALIGNMENT : PARM_BOUNDARY;\n }\n@@ -26999,7 +27017,13 @@ arm_setup_incoming_varargs (cumulative_args_t pcum_v,\n \t    inform (input_location, \"parameter passing for argument of \"\n \t\t    \"type %qT changed in GCC 7.1\", type);\n \t  else if (res > 0)\n-\t    nregs++;\n+\t    {\n+\t      nregs++;\n+\t      if (res > 1 && warn_psabi)\n+\t\tinform (input_location,\n+\t\t\t\"parameter passing for argument of type \"\n+\t\t\t\"%qT changed in GCC 9.1\", type);\n+\t    }\n \t}\n     }\n   else"}, {"sha": "50705fe6bb08358bc91fc39d4fefab7d04647501", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/44a7251e1e97caf3b2315f20d48519ff8fced152/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/44a7251e1e97caf3b2315f20d48519ff8fced152/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=44a7251e1e97caf3b2315f20d48519ff8fced152", "patch": "@@ -1,3 +1,11 @@\n+2019-01-22  Richard Earnshaw  <rearnsha@arm.com>\n+\n+\tPR target/88469\n+\t* gcc.target/arm/aapcs/bitfield1.c: New test.\n+\t* gcc.target/arm/aapcs/overalign_rec1.c: New test.\n+\t* gcc.target/arm/aapcs/overalign_rec2.c: New test.\n+\t* gcc.target/arm/aapcs/overalign_rec3.c: New test.\n+\n 2019-01-22  Manfred Schwarb  <manfred99@gmx.ch>\n \n \t* gfortran.dg/array_function_5.f90: Fix a dg directive."}, {"sha": "cac786eec373964d8b081e3eb55e04c5afcf185d", "filename": "gcc/testsuite/gcc.target/arm/aapcs/bitfield1.c", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/44a7251e1e97caf3b2315f20d48519ff8fced152/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Faapcs%2Fbitfield1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/44a7251e1e97caf3b2315f20d48519ff8fced152/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Faapcs%2Fbitfield1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Faapcs%2Fbitfield1.c?ref=44a7251e1e97caf3b2315f20d48519ff8fced152", "patch": "@@ -0,0 +1,24 @@\n+/* Test AAPCS layout (alignment).  */\n+\n+/* { dg-do run { target arm_eabi } } */\n+/* { dg-require-effective-target arm32 } */\n+/* { dg-options \"-O\" } */\n+\n+#ifndef IN_FRAMEWORK\n+#define TESTFILE \"bitfield1.c\"\n+\n+struct bf\n+{\n+  unsigned long long a: 61;\n+  unsigned b: 3;\n+} v = {1, 1};\n+\n+#include \"abitest.h\"\n+#else\n+  ARG (int, 7, R0)\n+  ARG (int, 9, R1)\n+  ARG (int, 11, R2)\n+  /* Alignment of the bitfield type should affect alignment of the overall\n+     type, so R3 not used.  */\n+  LAST_ARG (struct bf, v, STACK)\n+#endif"}, {"sha": "1d33da42bdf6461aec8f0a5c2f5afd23ed3585ae", "filename": "gcc/testsuite/gcc.target/arm/aapcs/overalign_rec1.c", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/44a7251e1e97caf3b2315f20d48519ff8fced152/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Faapcs%2Foveralign_rec1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/44a7251e1e97caf3b2315f20d48519ff8fced152/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Faapcs%2Foveralign_rec1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Faapcs%2Foveralign_rec1.c?ref=44a7251e1e97caf3b2315f20d48519ff8fced152", "patch": "@@ -0,0 +1,27 @@\n+/* Test AAPCS layout (alignment).  */\n+\n+/* { dg-do run { target arm_eabi } } */\n+/* { dg-require-effective-target arm32 } */\n+/* { dg-options \"-O\" } */\n+\n+#ifndef IN_FRAMEWORK\n+#define TESTFILE \"overalign_rec1.c\"\n+\n+typedef struct __attribute__((aligned(8)))\n+{\n+  int a;\n+  int b;\n+} overaligned;\n+\n+overaligned v = {1, 3};\n+overaligned w = {33, 99};\n+\n+#include \"abitest.h\"\n+#else\n+  ARG (int, 7, R0)\n+  /* Overalignment is ignored for the purposes of parameter passing.  */\n+  ARG (overaligned, v, R1)\n+  ARG (int, 11, R3)\n+  ARG (int, 9, STACK)\n+  LAST_ARG (overaligned, w, STACK+4)\n+#endif"}, {"sha": "b19fa70c591b0fbe655b07221e7f2afe15063208", "filename": "gcc/testsuite/gcc.target/arm/aapcs/overalign_rec2.c", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/44a7251e1e97caf3b2315f20d48519ff8fced152/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Faapcs%2Foveralign_rec2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/44a7251e1e97caf3b2315f20d48519ff8fced152/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Faapcs%2Foveralign_rec2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Faapcs%2Foveralign_rec2.c?ref=44a7251e1e97caf3b2315f20d48519ff8fced152", "patch": "@@ -0,0 +1,25 @@\n+/* Test AAPCS layout (alignment).  */\n+\n+/* { dg-do run { target arm_eabi } } */\n+/* { dg-require-effective-target arm32 } */\n+/* { dg-options \"-O\" } */\n+\n+#ifndef IN_FRAMEWORK\n+#define TESTFILE \"overalign_rec2.c\"\n+\n+typedef struct\n+{\n+  int  __attribute__((aligned(8))) a;\n+  int b;\n+} overaligned;\n+\n+overaligned v = {1, 3};\n+overaligned w = {33, 99};\n+\n+#include \"abitest.h\"\n+#else\n+  ARG (int, 7, R0)\n+  ARG (overaligned, v, R2)\n+  ARG (int, 9, STACK)\n+  LAST_ARG (overaligned, w, STACK+8)\n+#endif"}, {"sha": "b1c793e04e6e4a89bcc7ec33704c4cbb3eaa5eb4", "filename": "gcc/testsuite/gcc.target/arm/aapcs/overalign_rec3.c", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/44a7251e1e97caf3b2315f20d48519ff8fced152/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Faapcs%2Foveralign_rec3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/44a7251e1e97caf3b2315f20d48519ff8fced152/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Faapcs%2Foveralign_rec3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Faapcs%2Foveralign_rec3.c?ref=44a7251e1e97caf3b2315f20d48519ff8fced152", "patch": "@@ -0,0 +1,28 @@\n+/* Test AAPCS layout (alignment).  */\n+\n+/* { dg-do run { target arm_eabi } } */\n+/* { dg-require-effective-target arm32 } */\n+/* { dg-options \"-O\" } */\n+\n+#ifndef IN_FRAMEWORK\n+#define TESTFILE \"overalign_rec3.c\"\n+\n+typedef struct\n+{\n+  int  __attribute__((aligned(16))) a;\n+  int b;\n+} overaligned;\n+\n+overaligned v = {1, 3};\n+overaligned w = {33, 99};\n+\n+#include \"abitest.h\"\n+#else\n+  ARG (int, 7, R0)\n+  /* Objects with alignment > 8 are passed with alignment 8.  */\n+  ARG (overaligned, v, R2)\n+  ARG (int, 9, STACK+8)\n+  ARG (int, 10, STACK+12)\n+  ARG (int, 11, STACK+16)\n+  LAST_ARG (overaligned, w, STACK+24)\n+#endif"}]}