{"sha": "106b3d40e77897e85c6e041b88b74b8a3222417e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTA2YjNkNDBlNzc4OTdlODVjNmUwNDFiODhiNzRiOGEzMjIyNDE3ZQ==", "commit": {"author": {"name": "Richard Sandiford", "email": "richard@codesourcery.com", "date": "2007-07-06T09:20:46Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2007-07-06T09:20:46Z"}, "message": "mips.c (mips16e_save_restore_pattern_p): Check that the topmost argument register is not also included in the save mask.\n\ngcc/\n\t* config/mips/mips.c (mips16e_save_restore_pattern_p): Check that\n\tthe topmost argument register is not also included in the save mask.\n\t(mips16e_collect_argument_save_p): Take a pointer to the argument\n\tregister, rather than a pointer to the number of arguments.\n\t(mips16e_collect_argument_saves): Only include argument saves\n\tthat aren't in the register mask.\n\ngcc/testsuite/\n\t* gcc.target/mips/save-restore-5.c: New test.\n\nFrom-SVN: r126404", "tree": {"sha": "65deb1084ccb4af1ca38acc779b5acb34622854f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/65deb1084ccb4af1ca38acc779b5acb34622854f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/106b3d40e77897e85c6e041b88b74b8a3222417e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/106b3d40e77897e85c6e041b88b74b8a3222417e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/106b3d40e77897e85c6e041b88b74b8a3222417e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/106b3d40e77897e85c6e041b88b74b8a3222417e/comments", "author": null, "committer": null, "parents": [{"sha": "56d17681225aa3b26dd0ca0958fe9c4a329b07f4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/56d17681225aa3b26dd0ca0958fe9c4a329b07f4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/56d17681225aa3b26dd0ca0958fe9c4a329b07f4"}], "stats": {"total": 61, "additions": 49, "deletions": 12}, "files": [{"sha": "240d5e783ab8b66406e43ea083a64850107c7cca", "filename": "gcc/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/106b3d40e77897e85c6e041b88b74b8a3222417e/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/106b3d40e77897e85c6e041b88b74b8a3222417e/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=106b3d40e77897e85c6e041b88b74b8a3222417e", "patch": "@@ -1,3 +1,12 @@\n+2007-07-06  Richard Sandiford  <richard@codesourcery.com>\n+\n+\t* config/mips/mips.c (mips16e_save_restore_pattern_p): Check that\n+\tthe topmost argument register is not also included in the save mask.\n+\t(mips16e_collect_argument_save_p): Take a pointer to the argument\n+\tregister, rather than a pointer to the number of arguments.\n+\t(mips16e_collect_argument_saves): Only include argument saves\n+\tthat aren't in the register mask.\n+\n 2007-07-06  Uros Bizjak  <ubizjak@gmail.com>\n \n \tPR rtl_optimization/32450"}, {"sha": "8c7b70c2485f8c4a3156e90dba30d066a57b94ba", "filename": "gcc/config/mips/mips.c", "status": "modified", "additions": 20, "deletions": 12, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/106b3d40e77897e85c6e041b88b74b8a3222417e/gcc%2Fconfig%2Fmips%2Fmips.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/106b3d40e77897e85c6e041b88b74b8a3222417e/gcc%2Fconfig%2Fmips%2Fmips.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips.c?ref=106b3d40e77897e85c6e041b88b74b8a3222417e", "patch": "@@ -7334,6 +7334,12 @@ mips16e_save_restore_pattern_p (rtx pattern, HOST_WIDE_INT adjust,\n   if (extra != 0)\n     return false;\n \n+  /* Make sure that the topmost argument register is not saved twice.\n+     The checks above ensure that the same is then true for the other\n+     argument registers.  */\n+  if (nargs > 0 && BITSET_P (mask, GP_ARG_FIRST + nargs - 1))\n+    return false;\n+\n   /* Pass back information, if requested.  */\n   if (info)\n     {\n@@ -7458,14 +7464,13 @@ mips16e_collect_propagate_value (rtx x, rtx *reg_values)\n }\n \n /* Return true if (set DEST SRC) stores an argument register into its\n-   caller-allocated save slot.  If the register is not included in\n-   [GP_ARG_FIRST, GP_ARG_LAST + *NARGS_PTR), destructively modify\n-   *NARGS_PTR such that this condition holds.  REG_VALUES is as for\n+   caller-allocated save slot, storing the number of that argument\n+   register in *REGNO_PTR if so.  REG_VALUES is as for\n    mips16e_collect_propagate_value.  */\n \n static bool\n-mips16e_collect_argument_save (rtx dest, rtx src, rtx *reg_values,\n-\t\t\t       unsigned int *nargs_ptr)\n+mips16e_collect_argument_save_p (rtx dest, rtx src, rtx *reg_values,\n+\t\t\t\t unsigned int *regno_ptr)\n {\n   unsigned int argno, regno;\n   HOST_WIDE_INT offset, required_offset;\n@@ -7495,10 +7500,7 @@ mips16e_collect_argument_save (rtx dest, rtx src, rtx *reg_values,\n   if (offset != required_offset)\n     return false;\n \n-  /* Make sure that *NARGS_PTR is big enough.  */\n-  if (*nargs_ptr <= argno)\n-    *nargs_ptr = argno + 1;\n-\n+  *regno_ptr = regno;\n   return true;\n }\n \n@@ -7514,7 +7516,7 @@ mips16e_collect_argument_saves (void)\n {\n   rtx reg_values[FIRST_PSEUDO_REGISTER];\n   rtx insn, next, set, dest, src;\n-  unsigned int nargs;\n+  unsigned int nargs, regno;\n \n   push_topmost_sequence ();\n   nargs = 0;\n@@ -7534,8 +7536,14 @@ mips16e_collect_argument_saves (void)\n \n       dest = SET_DEST (set);\n       src = SET_SRC (set);\n-      if (mips16e_collect_argument_save (dest, src, reg_values, &nargs))\n-\tdelete_insn (insn);\n+      if (mips16e_collect_argument_save_p (dest, src, reg_values, &regno))\n+\t{\n+\t  if (!BITSET_P (cfun->machine->frame.mask, regno))\n+\t    {\n+\t      delete_insn (insn);\n+\t      nargs = MAX (nargs, (regno - GP_ARG_FIRST) + 1);\n+\t    }\n+\t}\n       else if (REG_P (dest) && GET_MODE (dest) == word_mode)\n \treg_values[REGNO (dest)]\n \t  = mips16e_collect_propagate_value (src, reg_values);"}, {"sha": "a630290063c0b225e05686a27e9dd1f768124c55", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/106b3d40e77897e85c6e041b88b74b8a3222417e/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/106b3d40e77897e85c6e041b88b74b8a3222417e/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=106b3d40e77897e85c6e041b88b74b8a3222417e", "patch": "@@ -1,3 +1,7 @@\n+2007-07-06  Richard Sandiford  <richard@codesourcery.com>\n+\n+\t* gcc.target/mips/save-restore-5.c: New test.\n+\n 2007-07-06  Uros Bizjak  <ubizjak@gmail.com>\n \n \tPR rtl_optimization/32450"}, {"sha": "6c2f37c20fe6b052824b2014ab7e867269349212", "filename": "gcc/testsuite/gcc.target/mips/save-restore-5.c", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/106b3d40e77897e85c6e041b88b74b8a3222417e/gcc%2Ftestsuite%2Fgcc.target%2Fmips%2Fsave-restore-5.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/106b3d40e77897e85c6e041b88b74b8a3222417e/gcc%2Ftestsuite%2Fgcc.target%2Fmips%2Fsave-restore-5.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fmips%2Fsave-restore-5.c?ref=106b3d40e77897e85c6e041b88b74b8a3222417e", "patch": "@@ -0,0 +1,16 @@\n+/* Check that we don't try to save the same register twice.  */\n+/* { dg-mips-options \"-mips32r2 -mgp32 -mips16 -O2\" } */\n+/* { dg-do assemble } */\n+\n+int bar (int, int, int, int);\n+void frob (void);\n+\n+void\n+foo (int a1, int a2, int a3, int a4)\n+{\n+  asm volatile (\"\" ::: \"$2\", \"$3\", \"$4\", \"$5\", \"$6\", \"$7\", \"$8\",\n+\t\t\"$9\", \"$10\", \"$11\", \"$12\", \"$13\", \"$14\", \"$15\", \"$16\",\n+\t\t\"$18\", \"$19\", \"$20\", \"$21\", \"$22\", \"$23\", \"$24\",\n+\t\t\"$25\", \"$30\", \"$31\", \"memory\");\n+  __builtin_eh_return (bar (a1, a2, a3, a4), frob);\n+}"}]}