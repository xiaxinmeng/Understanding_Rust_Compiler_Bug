{"sha": "7263c6d715f45580abda86e3617804524d28853b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzI2M2M2ZDcxNWY0NTU4MGFiZGE4NmUzNjE3ODA0NTI0ZDI4ODUzYg==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@redhat.com", "date": "2011-07-11T19:30:56Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2011-07-11T19:30:56Z"}, "message": "dwarf2cfi.c (DW_STACK_POINTER_REGNUM): New.\n\n        * dwarf2cfi.c (DW_STACK_POINTER_REGNUM): New.\n        (DW_FRAME_POINTER_REGNUM): New.\n        (expand_builtin_init_dwarf_reg_sizes): Use unsigned for rnum.\n        (def_cfa_1): Do not convert reg to DWARF_FRAME_REGNUM here.\n        (dwf_regno): New.\n        (dwarf2out_flush_queued_reg_saves, dwarf2out_frame_debug_def_cfa,\n        dwarf2out_frame_debug_adjust_cfa, dwarf2out_frame_debug_cfa_register,\n        dwarf2out_frame_debug_cfa_expression, dwarf2out_frame_debug_expr):\n        Use it.\n        * dwarf2out.c (based_loc_descr): Use dwarf_frame_regnum.\n        * dwarf2out.h (dwarf_frame_regnum): New.\n        (struct cfa_loc): Document the domain of the reg member.\n\nFrom-SVN: r176178", "tree": {"sha": "265c21b5e028fad7b1f5c8a73b733d4ee8f96336", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/265c21b5e028fad7b1f5c8a73b733d4ee8f96336"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/7263c6d715f45580abda86e3617804524d28853b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7263c6d715f45580abda86e3617804524d28853b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7263c6d715f45580abda86e3617804524d28853b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7263c6d715f45580abda86e3617804524d28853b/comments", "author": null, "committer": null, "parents": [{"sha": "5fb8060d5b57061e6b683aebdd04a915473963f6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5fb8060d5b57061e6b683aebdd04a915473963f6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5fb8060d5b57061e6b683aebdd04a915473963f6"}], "stats": {"total": 183, "additions": 108, "deletions": 75}, "files": [{"sha": "b523aadd9d5e4e735afb6e11e6d54701dd0807e3", "filename": "gcc/ChangeLog", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7263c6d715f45580abda86e3617804524d28853b/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7263c6d715f45580abda86e3617804524d28853b/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=7263c6d715f45580abda86e3617804524d28853b", "patch": "@@ -1,3 +1,18 @@\n+2011-07-11  Richard Henderson  <rth@redhat.com>\n+\n+\t* dwarf2cfi.c (DW_STACK_POINTER_REGNUM): New.\n+\t(DW_FRAME_POINTER_REGNUM): New.\n+\t(expand_builtin_init_dwarf_reg_sizes): Use unsigned for rnum.\n+\t(def_cfa_1): Do not convert reg to DWARF_FRAME_REGNUM here.\n+\t(dwf_regno): New.\n+\t(dwarf2out_flush_queued_reg_saves, dwarf2out_frame_debug_def_cfa,\n+\tdwarf2out_frame_debug_adjust_cfa, dwarf2out_frame_debug_cfa_register,\n+\tdwarf2out_frame_debug_cfa_expression, dwarf2out_frame_debug_expr):\n+\tUse it.\n+\t* dwarf2out.c (based_loc_descr): Use dwarf_frame_regnum.\n+\t* dwarf2out.h (dwarf_frame_regnum): New.\n+\t(struct cfa_loc): Document the domain of the reg member.\n+\n 2011-07-11  Uros Bizjak  <ubizjak@gmail.com>\n \n \t* config/i386/i386.c (ix86_trampoline_init): Switch arms of if expr."}, {"sha": "1c76b3f71b93a56fc4c07e20cb732de8a4ff8857", "filename": "gcc/dwarf2cfi.c", "status": "modified", "additions": 81, "deletions": 73, "changes": 154, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7263c6d715f45580abda86e3617804524d28853b/gcc%2Fdwarf2cfi.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7263c6d715f45580abda86e3617804524d28853b/gcc%2Fdwarf2cfi.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdwarf2cfi.c?ref=7263c6d715f45580abda86e3617804524d28853b", "patch": "@@ -57,6 +57,10 @@ along with GCC; see the file COPYING3.  If not see\n \n /* Maximum size (in bytes) of an artificially generated label.  */\n #define MAX_ARTIFICIAL_LABEL_BYTES\t30\n+\n+/* Short-hand for commonly used register numbers.  */\n+#define DW_STACK_POINTER_REGNUM  dwarf_frame_regnum (STACK_POINTER_REGNUM)\n+#define DW_FRAME_POINTER_REGNUM  dwarf_frame_regnum (HARD_FRAME_POINTER_REGNUM)\n \f\n /* A vector of call frame insns for the CIE.  */\n cfi_vec cie_cfi_vec;\n@@ -85,7 +89,7 @@ static void dwarf2out_frame_debug_restore_state (void);\n rtx\n expand_builtin_dwarf_sp_column (void)\n {\n-  unsigned int dwarf_regnum = DWARF_FRAME_REGNUM (STACK_POINTER_REGNUM);\n+  unsigned int dwarf_regnum = DW_STACK_POINTER_REGNUM;\n   return GEN_INT (DWARF2_FRAME_REG_OUT (dwarf_regnum, 1));\n }\n \n@@ -113,7 +117,7 @@ expand_builtin_init_dwarf_reg_sizes (tree address)\n \n   for (i = 0; i < FIRST_PSEUDO_REGISTER; i++)\n     {\n-      int rnum = DWARF2_FRAME_REG_OUT (DWARF_FRAME_REGNUM (i), 1);\n+      unsigned int rnum = DWARF2_FRAME_REG_OUT (dwarf_frame_regnum (i), 1);\n \n       if (rnum < DWARF_FRAME_REGISTERS)\n \t{\n@@ -123,7 +127,7 @@ expand_builtin_init_dwarf_reg_sizes (tree address)\n \n \t  if (HARD_REGNO_CALL_PART_CLOBBERED (i, save_mode))\n \t    save_mode = choose_hard_reg_mode (i, 1, true);\n-\t  if (DWARF_FRAME_REGNUM (i) == DWARF_FRAME_RETURN_COLUMN)\n+\t  if (dwarf_frame_regnum (i) == DWARF_FRAME_RETURN_COLUMN)\n \t    {\n \t      if (save_mode == VOIDmode)\n \t\tcontinue;\n@@ -415,8 +419,6 @@ def_cfa_1 (dw_cfa_location *loc_p)\n   if (cfa_store.reg == loc.reg && loc.indirect == 0)\n     cfa_store.offset = loc.offset;\n \n-  loc.reg = DWARF_FRAME_REGNUM (loc.reg);\n-\n   /* If nothing changed, no need to issue any call frame instructions.  */\n   if (cfa_equal_p (&loc, &old_cfa))\n     return;\n@@ -810,10 +812,10 @@ dwarf2out_args_size (HOST_WIDE_INT size)\n static void\n dwarf2out_stack_adjust (HOST_WIDE_INT offset)\n {\n-  if (cfa.reg == STACK_POINTER_REGNUM)\n+  if (cfa.reg == DW_STACK_POINTER_REGNUM)\n     cfa.offset += offset;\n \n-  if (cfa_store.reg == STACK_POINTER_REGNUM)\n+  if (cfa_store.reg == DW_STACK_POINTER_REGNUM)\n     cfa_store.offset += offset;\n \n   if (ACCUMULATE_OUTGOING_ARGS)\n@@ -859,7 +861,7 @@ dwarf2out_notice_stack_adjust (rtx insn, bool after_p)\n \n   /* If only calls can throw, and we have a frame pointer,\n      save up adjustments until we see the CALL_INSN.  */\n-  if (!flag_asynchronous_unwind_tables && cfa.reg != STACK_POINTER_REGNUM)\n+  if (!flag_asynchronous_unwind_tables && cfa.reg != DW_STACK_POINTER_REGNUM)\n     {\n       if (CALL_P (insn) && !after_p)\n \t{\n@@ -952,6 +954,16 @@ static GTY(()) VEC(reg_saved_in_data, gc) *regs_saved_in_regs;\n \n static GTY(()) reg_saved_in_data *cie_return_save;\n \n+/* Short-hand inline for the very common D_F_R (REGNO (x)) operation.  */\n+/* ??? This ought to go into dwarf2out.h alongside dwarf_frame_regnum,\n+   except that dwarf2out.h is used in places where rtl is prohibited.  */\n+\n+static inline unsigned\n+dwf_regno (const_rtx reg)\n+{\n+  return dwarf_frame_regnum (REGNO (reg));\n+}\n+\n /* Compare X and Y for equivalence.  The inputs may be REGs or PC_RTX.  */\n \n static bool\n@@ -1031,9 +1043,9 @@ dwarf2out_flush_queued_reg_saves (void)\n       if (q->reg == pc_rtx)\n \treg = DWARF_FRAME_RETURN_COLUMN;\n       else\n-        reg = DWARF_FRAME_REGNUM (REGNO (q->reg));\n+        reg = dwf_regno (q->reg);\n       if (q->saved_reg)\n-\tsreg = DWARF_FRAME_REGNUM (REGNO (q->saved_reg));\n+\tsreg = dwf_regno (q->saved_reg);\n       else\n \tsreg = INVALID_REGNUM;\n       reg_save (reg, sreg, q->cfa_offset);\n@@ -1106,12 +1118,12 @@ dwarf2out_frame_debug_def_cfa (rtx pat)\n   switch (GET_CODE (pat))\n     {\n     case PLUS:\n-      cfa.reg = REGNO (XEXP (pat, 0));\n+      cfa.reg = dwf_regno (XEXP (pat, 0));\n       cfa.offset = INTVAL (XEXP (pat, 1));\n       break;\n \n     case REG:\n-      cfa.reg = REGNO (pat);\n+      cfa.reg = dwf_regno (pat);\n       break;\n \n     case MEM:\n@@ -1122,7 +1134,7 @@ dwarf2out_frame_debug_def_cfa (rtx pat)\n \t  cfa.base_offset = INTVAL (XEXP (pat, 1));\n \t  pat = XEXP (pat, 0);\n \t}\n-      cfa.reg = REGNO (pat);\n+      cfa.reg = dwf_regno (pat);\n       break;\n \n     default:\n@@ -1147,7 +1159,7 @@ dwarf2out_frame_debug_adjust_cfa (rtx pat)\n   switch (GET_CODE (src))\n     {\n     case PLUS:\n-      gcc_assert (REGNO (XEXP (src, 0)) == cfa.reg);\n+      gcc_assert (dwf_regno (XEXP (src, 0)) == cfa.reg);\n       cfa.offset -= INTVAL (XEXP (src, 1));\n       break;\n \n@@ -1158,7 +1170,7 @@ dwarf2out_frame_debug_adjust_cfa (rtx pat)\n \tgcc_unreachable ();\n     }\n \n-  cfa.reg = REGNO (dest);\n+  cfa.reg = dwf_regno (dest);\n   gcc_assert (cfa.indirect == 0);\n \n   def_cfa_1 (&cfa);\n@@ -1182,11 +1194,11 @@ dwarf2out_frame_debug_cfa_offset (rtx set)\n   switch (GET_CODE (addr))\n     {\n     case REG:\n-      gcc_assert (REGNO (addr) == cfa.reg);\n+      gcc_assert (dwf_regno (addr) == cfa.reg);\n       offset = -cfa.offset;\n       break;\n     case PLUS:\n-      gcc_assert (REGNO (XEXP (addr, 0)) == cfa.reg);\n+      gcc_assert (dwf_regno (XEXP (addr, 0)) == cfa.reg);\n       offset = INTVAL (XEXP (addr, 1)) - cfa.offset;\n       break;\n     default:\n@@ -1201,7 +1213,7 @@ dwarf2out_frame_debug_cfa_offset (rtx set)\n   else \n     {\n       span = targetm.dwarf_register_span (src);\n-      sregno = DWARF_FRAME_REGNUM (REGNO (src));\n+      sregno = dwf_regno (src);\n     }\n \n   /* ??? We'd like to use queue_reg_save, but we need to come up with\n@@ -1223,7 +1235,7 @@ dwarf2out_frame_debug_cfa_offset (rtx set)\n \t{\n \t  rtx elem = XVECEXP (span, 0, par_index);\n \n-\t  sregno = DWARF_FRAME_REGNUM (REGNO (src));\n+\t  sregno = dwf_regno (src);\n \t  reg_save (sregno, INVALID_REGNUM, span_offset);\n \t  span_offset += GET_MODE_SIZE (GET_MODE (elem));\n \t}\n@@ -1245,9 +1257,9 @@ dwarf2out_frame_debug_cfa_register (rtx set)\n   if (src == pc_rtx)\n     sregno = DWARF_FRAME_RETURN_COLUMN;\n   else\n-    sregno = DWARF_FRAME_REGNUM (REGNO (src));\n+    sregno = dwf_regno (src);\n \n-  dregno = DWARF_FRAME_REGNUM (REGNO (dest));\n+  dregno = dwf_regno (dest);\n \n   /* ??? We'd like to use queue_reg_save, but we need to come up with\n      a different flushing heuristic for epilogues.  */\n@@ -1272,7 +1284,7 @@ dwarf2out_frame_debug_cfa_expression (rtx set)\n   gcc_assert (!span);\n \n   cfi->dw_cfi_opc = DW_CFA_expression;\n-  cfi->dw_cfi_oprnd1.dw_cfi_reg_num = DWARF_FRAME_REGNUM (REGNO (src));\n+  cfi->dw_cfi_oprnd1.dw_cfi_reg_num = dwf_regno (src);\n   cfi->dw_cfi_oprnd2.dw_cfi_loc\n     = mem_loc_descriptor (XEXP (dest, 0), get_address_mode (dest),\n \t\t\t  GET_MODE (dest), VAR_INIT_STATUS_INITIALIZED);\n@@ -1288,7 +1300,7 @@ static void\n dwarf2out_frame_debug_cfa_restore (rtx reg)\n {\n   dw_cfi_ref cfi = new_cfi ();\n-  unsigned int regno = DWARF_FRAME_REGNUM (REGNO (reg));\n+  unsigned int regno = dwf_regno (reg);\n \n   cfi->dw_cfi_opc = (regno & ~0x3f ? DW_CFA_restore_extended : DW_CFA_restore);\n   cfi->dw_cfi_oprnd1.dw_cfi_reg_num = regno;\n@@ -1580,7 +1592,7 @@ dwarf2out_frame_debug_expr (rtx expr)\n \t{\n \t  /* Setting FP from SP.  */\n \tcase REG:\n-\t  if (cfa.reg == (unsigned) REGNO (src))\n+\t  if (cfa.reg == dwf_regno (src))\n \t    {\n \t      /* Rule 1 */\n \t      /* Update the CFA rule wrt SP or FP.  Make sure src is\n@@ -1590,7 +1602,7 @@ dwarf2out_frame_debug_expr (rtx expr)\n \t\t ARM copies SP to a temporary register, and from there to\n \t\t FP.  So we just rely on the backends to only set\n \t\t RTX_FRAME_RELATED_P on appropriate insns.  */\n-\t      cfa.reg = REGNO (dest);\n+\t      cfa.reg = dwf_regno (dest);\n \t      cfa_temp.reg = cfa.reg;\n \t      cfa_temp.offset = cfa.offset;\n \t    }\n@@ -1599,8 +1611,7 @@ dwarf2out_frame_debug_expr (rtx expr)\n \t      /* Saving a register in a register.  */\n \t      gcc_assert (!fixed_regs [REGNO (dest)]\n \t\t\t  /* For the SPARC and its register window.  */\n-\t\t\t  || (DWARF_FRAME_REGNUM (REGNO (src))\n-\t\t\t      == DWARF_FRAME_RETURN_COLUMN));\n+\t\t\t  || (dwf_regno (src) == DWARF_FRAME_RETURN_COLUMN));\n \n               /* After stack is aligned, we can only save SP in FP\n \t\t if drap register is used.  In this case, we have\n@@ -1611,7 +1622,7 @@ dwarf2out_frame_debug_expr (rtx expr)\n \t\t  && REGNO (src) == STACK_POINTER_REGNUM)\n \t\tgcc_assert (REGNO (dest) == HARD_FRAME_POINTER_REGNUM\n \t\t\t    && fde->drap_reg != INVALID_REGNUM\n-\t\t\t    && cfa.reg != REGNO (src));\n+\t\t\t    && cfa.reg != dwf_regno (src));\n \t      else\n \t\tqueue_reg_save (src, dest, 0);\n \t    }\n@@ -1630,8 +1641,7 @@ dwarf2out_frame_debug_expr (rtx expr)\n \t\t  offset = INTVAL (XEXP (src, 1));\n \t\t  break;\n \t\tcase REG:\n-\t\t  gcc_assert ((unsigned) REGNO (XEXP (src, 1))\n-\t\t\t      == cfa_temp.reg);\n+\t\t  gcc_assert (dwf_regno (XEXP (src, 1)) == cfa_temp.reg);\n \t\t  offset = cfa_temp.offset;\n \t\t  break;\n \t\tdefault:\n@@ -1641,8 +1651,8 @@ dwarf2out_frame_debug_expr (rtx expr)\n \t      if (XEXP (src, 0) == hard_frame_pointer_rtx)\n \t\t{\n \t\t  /* Restoring SP from FP in the epilogue.  */\n-\t\t  gcc_assert (cfa.reg == (unsigned) HARD_FRAME_POINTER_REGNUM);\n-\t\t  cfa.reg = STACK_POINTER_REGNUM;\n+\t\t  gcc_assert (cfa.reg == DW_FRAME_POINTER_REGNUM);\n+\t\t  cfa.reg = DW_STACK_POINTER_REGNUM;\n \t\t}\n \t      else if (GET_CODE (src) == LO_SUM)\n \t\t/* Assume we've set the source reg of the LO_SUM from sp.  */\n@@ -1652,9 +1662,9 @@ dwarf2out_frame_debug_expr (rtx expr)\n \n \t      if (GET_CODE (src) != MINUS)\n \t\toffset = -offset;\n-\t      if (cfa.reg == STACK_POINTER_REGNUM)\n+\t      if (cfa.reg == DW_STACK_POINTER_REGNUM)\n \t\tcfa.offset += offset;\n-\t      if (cfa_store.reg == STACK_POINTER_REGNUM)\n+\t      if (cfa_store.reg == DW_STACK_POINTER_REGNUM)\n \t\tcfa_store.offset += offset;\n \t    }\n \t  else if (dest == hard_frame_pointer_rtx)\n@@ -1665,50 +1675,50 @@ dwarf2out_frame_debug_expr (rtx expr)\n \t      gcc_assert (frame_pointer_needed);\n \n \t      gcc_assert (REG_P (XEXP (src, 0))\n-\t\t\t  && (unsigned) REGNO (XEXP (src, 0)) == cfa.reg\n+\t\t\t  && dwf_regno (XEXP (src, 0)) == cfa.reg\n \t\t\t  && CONST_INT_P (XEXP (src, 1)));\n \t      offset = INTVAL (XEXP (src, 1));\n \t      if (GET_CODE (src) != MINUS)\n \t\toffset = -offset;\n \t      cfa.offset += offset;\n-\t      cfa.reg = HARD_FRAME_POINTER_REGNUM;\n+\t      cfa.reg = DW_FRAME_POINTER_REGNUM;\n \t    }\n \t  else\n \t    {\n \t      gcc_assert (GET_CODE (src) != MINUS);\n \n \t      /* Rule 4 */\n \t      if (REG_P (XEXP (src, 0))\n-\t\t  && REGNO (XEXP (src, 0)) == cfa.reg\n+\t\t  && dwf_regno (XEXP (src, 0)) == cfa.reg\n \t\t  && CONST_INT_P (XEXP (src, 1)))\n \t\t{\n \t\t  /* Setting a temporary CFA register that will be copied\n \t\t     into the FP later on.  */\n \t\t  offset = - INTVAL (XEXP (src, 1));\n \t\t  cfa.offset += offset;\n-\t\t  cfa.reg = REGNO (dest);\n+\t\t  cfa.reg = dwf_regno (dest);\n \t\t  /* Or used to save regs to the stack.  */\n \t\t  cfa_temp.reg = cfa.reg;\n \t\t  cfa_temp.offset = cfa.offset;\n \t\t}\n \n \t      /* Rule 5 */\n \t      else if (REG_P (XEXP (src, 0))\n-\t\t       && REGNO (XEXP (src, 0)) == cfa_temp.reg\n+\t\t       && dwf_regno (XEXP (src, 0)) == cfa_temp.reg\n \t\t       && XEXP (src, 1) == stack_pointer_rtx)\n \t\t{\n \t\t  /* Setting a scratch register that we will use instead\n \t\t     of SP for saving registers to the stack.  */\n-\t\t  gcc_assert (cfa.reg == STACK_POINTER_REGNUM);\n-\t\t  cfa_store.reg = REGNO (dest);\n+\t\t  gcc_assert (cfa.reg == DW_STACK_POINTER_REGNUM);\n+\t\t  cfa_store.reg = dwf_regno (dest);\n \t\t  cfa_store.offset = cfa.offset - cfa_temp.offset;\n \t\t}\n \n \t      /* Rule 9 */\n \t      else if (GET_CODE (src) == LO_SUM\n \t\t       && CONST_INT_P (XEXP (src, 1)))\n \t\t{\n-\t\t  cfa_temp.reg = REGNO (dest);\n+\t\t  cfa_temp.reg = dwf_regno (dest);\n \t\t  cfa_temp.offset = INTVAL (XEXP (src, 1));\n \t\t}\n \t      else\n@@ -1718,18 +1728,17 @@ dwarf2out_frame_debug_expr (rtx expr)\n \n \t  /* Rule 6 */\n \tcase CONST_INT:\n-\t  cfa_temp.reg = REGNO (dest);\n+\t  cfa_temp.reg = dwf_regno (dest);\n \t  cfa_temp.offset = INTVAL (src);\n \t  break;\n \n \t  /* Rule 7 */\n \tcase IOR:\n \t  gcc_assert (REG_P (XEXP (src, 0))\n-\t\t      && (unsigned) REGNO (XEXP (src, 0)) == cfa_temp.reg\n+\t\t      && dwf_regno (XEXP (src, 0)) == cfa_temp.reg\n \t\t      && CONST_INT_P (XEXP (src, 1)));\n \n-\t  if ((unsigned) REGNO (dest) != cfa_temp.reg)\n-\t    cfa_temp.reg = REGNO (dest);\n+\t  cfa_temp.reg = dwf_regno (dest);\n \t  cfa_temp.offset |= INTVAL (XEXP (src, 1));\n \t  break;\n \n@@ -1757,13 +1766,13 @@ dwarf2out_frame_debug_expr (rtx expr)\n \t\t Thus we must flush whatever we have queued first.  */\n \t      dwarf2out_flush_queued_reg_saves ();\n \n-              gcc_assert (cfa_store.reg == REGNO (XEXP (src, 0)));\n+              gcc_assert (cfa_store.reg == dwf_regno (XEXP (src, 0)));\n               fde->stack_realign = 1;\n               fde->stack_realignment = INTVAL (XEXP (src, 1));\n               cfa_store.offset = 0;\n \n-\t      if (cfa.reg != STACK_POINTER_REGNUM\n-\t\t  && cfa.reg != HARD_FRAME_POINTER_REGNUM)\n+\t      if (cfa.reg != DW_STACK_POINTER_REGNUM\n+\t\t  && cfa.reg != DW_FRAME_POINTER_REGNUM)\n \t\tfde->drap_reg = cfa.reg;\n             }\n           return;\n@@ -1791,10 +1800,10 @@ dwarf2out_frame_debug_expr (rtx expr)\n \t  offset = -INTVAL (XEXP (XEXP (XEXP (dest, 0), 1), 1));\n \n \t  gcc_assert (REGNO (XEXP (XEXP (dest, 0), 0)) == STACK_POINTER_REGNUM\n-\t\t      && cfa_store.reg == STACK_POINTER_REGNUM);\n+\t\t      && cfa_store.reg == DW_STACK_POINTER_REGNUM);\n \n \t  cfa_store.offset += offset;\n-\t  if (cfa.reg == STACK_POINTER_REGNUM)\n+\t  if (cfa.reg == DW_STACK_POINTER_REGNUM)\n \t    cfa.offset = cfa_store.offset;\n \n \t  if (GET_CODE (XEXP (dest, 0)) == POST_MODIFY)\n@@ -1813,7 +1822,7 @@ dwarf2out_frame_debug_expr (rtx expr)\n \n \t  gcc_assert ((REGNO (XEXP (XEXP (dest, 0), 0))\n \t\t       == STACK_POINTER_REGNUM)\n-\t\t      && cfa_store.reg == STACK_POINTER_REGNUM);\n+\t\t      && cfa_store.reg == DW_STACK_POINTER_REGNUM);\n \n \t  cfa_store.offset += offset;\n \n@@ -1824,11 +1833,11 @@ dwarf2out_frame_debug_expr (rtx expr)\n               && fde->stack_realign\n               && src == hard_frame_pointer_rtx)\n \t    {\n-\t      gcc_assert (cfa.reg != HARD_FRAME_POINTER_REGNUM);\n+\t      gcc_assert (cfa.reg != DW_FRAME_POINTER_REGNUM);\n \t      cfa_store.offset = 0;\n \t    }\n \n-\t  if (cfa.reg == STACK_POINTER_REGNUM)\n+\t  if (cfa.reg == DW_STACK_POINTER_REGNUM)\n \t    cfa.offset = cfa_store.offset;\n \n \t  if (GET_CODE (XEXP (dest, 0)) == POST_DEC)\n@@ -1843,23 +1852,23 @@ dwarf2out_frame_debug_expr (rtx expr)\n \tcase MINUS:\n \tcase LO_SUM:\n \t  {\n-\t    int regno;\n+\t    unsigned int regno;\n \n \t    gcc_assert (CONST_INT_P (XEXP (XEXP (dest, 0), 1))\n \t\t\t&& REG_P (XEXP (XEXP (dest, 0), 0)));\n \t    offset = INTVAL (XEXP (XEXP (dest, 0), 1));\n \t    if (GET_CODE (XEXP (dest, 0)) == MINUS)\n \t      offset = -offset;\n \n-\t    regno = REGNO (XEXP (XEXP (dest, 0), 0));\n+\t    regno = dwf_regno (XEXP (XEXP (dest, 0), 0));\n \n-\t    if (cfa.reg == (unsigned) regno)\n+\t    if (cfa.reg == regno)\n \t      offset -= cfa.offset;\n-\t    else if (cfa_store.reg == (unsigned) regno)\n+\t    else if (cfa_store.reg == regno)\n \t      offset -= cfa_store.offset;\n \t    else\n \t      {\n-\t\tgcc_assert (cfa_temp.reg == (unsigned) regno);\n+\t\tgcc_assert (cfa_temp.reg == regno);\n \t\toffset -= cfa_temp.offset;\n \t      }\n \t  }\n@@ -1869,24 +1878,23 @@ dwarf2out_frame_debug_expr (rtx expr)\n \t  /* Without an offset.  */\n \tcase REG:\n \t  {\n-\t    int regno = REGNO (XEXP (dest, 0));\n+\t    unsigned int regno = dwf_regno (XEXP (dest, 0));\n \n-\t    if (cfa.reg == (unsigned) regno)\n+\t    if (cfa.reg == regno)\n \t      offset = -cfa.offset;\n-\t    else if (cfa_store.reg == (unsigned) regno)\n+\t    else if (cfa_store.reg == regno)\n \t      offset = -cfa_store.offset;\n \t    else\n \t      {\n-\t\tgcc_assert (cfa_temp.reg == (unsigned) regno);\n+\t\tgcc_assert (cfa_temp.reg == regno);\n \t\toffset = -cfa_temp.offset;\n \t      }\n \t  }\n \t  break;\n \n \t  /* Rule 14 */\n \tcase POST_INC:\n-\t  gcc_assert (cfa_temp.reg\n-\t\t      == (unsigned) REGNO (XEXP (XEXP (dest, 0), 0)));\n+\t  gcc_assert (cfa_temp.reg == dwf_regno (XEXP (XEXP (dest, 0), 0)));\n \t  offset = -cfa_temp.offset;\n \t  cfa_temp.offset -= GET_MODE_SIZE (GET_MODE (dest));\n \t  break;\n@@ -1904,7 +1912,7 @@ dwarf2out_frame_debug_expr (rtx expr)\n       if (REG_P (src)\n \t  && REGNO (src) != STACK_POINTER_REGNUM\n \t  && REGNO (src) != HARD_FRAME_POINTER_REGNUM\n-\t  && (unsigned) REGNO (src) == cfa.reg)\n+\t  && dwf_regno (src) == cfa.reg)\n \t{\n \t  /* We're storing the current CFA reg into the stack.  */\n \n@@ -1919,14 +1927,14 @@ dwarf2out_frame_debug_expr (rtx expr)\n               if (fde\n                   && fde->stack_realign\n                   && cfa.indirect == 0\n-                  && cfa.reg != HARD_FRAME_POINTER_REGNUM)\n+                  && cfa.reg != DW_FRAME_POINTER_REGNUM)\n                 {\n \t\t  dw_cfa_location cfa_exp;\n \n \t\t  gcc_assert (fde->drap_reg == cfa.reg);\n \n \t\t  cfa_exp.indirect = 1;\n-\t\t  cfa_exp.reg = HARD_FRAME_POINTER_REGNUM;\n+\t\t  cfa_exp.reg = DW_FRAME_POINTER_REGNUM;\n \t\t  cfa_exp.base_offset = offset;\n \t\t  cfa_exp.offset = 0;\n \n@@ -1953,7 +1961,7 @@ dwarf2out_frame_debug_expr (rtx expr)\n \t\tx = XEXP (x, 0);\n \t      gcc_assert (REG_P (x));\n \n-\t      cfa.reg = REGNO (x);\n+\t      cfa.reg = dwf_regno (x);\n \t      cfa.base_offset = offset;\n \t      cfa.indirect = 1;\n \t      def_cfa_1 (&cfa);\n@@ -2096,7 +2104,7 @@ dwarf2out_frame_debug (rtx insn, bool after_p)\n \t      {\n \t\tgcc_assert (fde->vdrap_reg == INVALID_REGNUM);\n \t\tif (REG_P (n))\n-\t\t  fde->vdrap_reg = REGNO (n);\n+\t\t  fde->vdrap_reg = dwf_regno (n);\n \t      }\n \t  }\n \thandled_one = true;\n@@ -2418,7 +2426,7 @@ initial_return_save (rtx rtl)\n     {\n     case REG:\n       /* RA is in a register.  */\n-      reg = DWARF_FRAME_REGNUM (REGNO (rtl));\n+      reg = dwf_regno (rtl);\n       break;\n \n     case MEM:\n@@ -2486,7 +2494,7 @@ execute_dwarf2_frame (void)\n \n       /* On entry, the Canonical Frame Address is at SP.  */\n       memset(&loc, 0, sizeof (loc));\n-      loc.reg = STACK_POINTER_REGNUM;\n+      loc.reg = DW_STACK_POINTER_REGNUM;\n       loc.offset = INCOMING_FRAME_SP_OFFSET;\n       def_cfa_1 (&loc);\n \n@@ -2526,7 +2534,7 @@ execute_dwarf2_frame (void)\n   gcc_checking_assert (regs_saved_in_regs == NULL);\n \n   memset (&cfa, 0, sizeof(cfa));\n-  cfa.reg = STACK_POINTER_REGNUM;\n+  cfa.reg = DW_STACK_POINTER_REGNUM;\n   cfa.offset = INCOMING_FRAME_SP_OFFSET;\n \n   old_cfa = cfa;"}, {"sha": "835e4ecd88405133af7370959c17604d791a9791", "filename": "gcc/dwarf2out.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7263c6d715f45580abda86e3617804524d28853b/gcc%2Fdwarf2out.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7263c6d715f45580abda86e3617804524d28853b/gcc%2Fdwarf2out.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdwarf2out.c?ref=7263c6d715f45580abda86e3617804524d28853b", "patch": "@@ -10408,8 +10408,8 @@ based_loc_descr (rtx reg, HOST_WIDE_INT offset,\n     }\n   else if (!optimize\n \t   && fde\n-\t   && (fde->drap_reg == REGNO (reg)\n-\t       || fde->vdrap_reg == REGNO (reg)))\n+\t   && (fde->drap_reg == dwarf_frame_regnum (REGNO (reg))\n+\t       || fde->vdrap_reg == dwarf_frame_regnum (REGNO (reg))))\n     {\n       /* Use cfa+offset to represent the location of arguments passed\n \t on the stack when drap is used to align stack."}, {"sha": "912a100153acb1e20edecba4a45eb0fceac6f44d", "filename": "gcc/dwarf2out.h", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7263c6d715f45580abda86e3617804524d28853b/gcc%2Fdwarf2out.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7263c6d715f45580abda86e3617804524d28853b/gcc%2Fdwarf2out.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdwarf2out.h?ref=7263c6d715f45580abda86e3617804524d28853b", "patch": "@@ -121,6 +121,7 @@ dw_fde_node;\n typedef struct cfa_loc {\n   HOST_WIDE_INT offset;\n   HOST_WIDE_INT base_offset;\n+  /* REG is in DWARF_FRAME_REGNUM space, *not* normal REGNO space.  */\n   unsigned int reg;\n   BOOL_BITFIELD indirect : 1;  /* 1 if CFA is accessed via a dereference.  */\n   BOOL_BITFIELD in_use : 1;    /* 1 if a saved cfa is stored here.  */\n@@ -261,6 +262,15 @@ extern void dwarf2out_set_demangle_name_func (const char *(*) (const char *));\n extern void dwarf2out_vms_debug_main_pointer (void);\n #endif\n \n+/* Unfortunately, DWARF_FRAME_REGNUM is not universally defined in such a\n+   way as to force an unsigned return type.  Do that via inline wrapper.  */\n+\n+static inline unsigned\n+dwarf_frame_regnum (unsigned regnum)\n+{\n+  return DWARF_FRAME_REGNUM (regnum);\n+}\n+  \n struct array_descr_info\n {\n   int ndimensions;"}]}