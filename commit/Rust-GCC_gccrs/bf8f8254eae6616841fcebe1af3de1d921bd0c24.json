{"sha": "bf8f8254eae6616841fcebe1af3de1d921bd0c24", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YmY4ZjgyNTRlYWU2NjE2ODQxZmNlYmUxYWYzZGUxZDkyMWJkMGMyNA==", "commit": {"author": {"name": "Bernd Schmidt", "email": "bernd.schmidt@analog.com", "date": "2005-06-02T08:39:06Z"}, "committer": {"name": "Bernd Schmidt", "email": "bernds@gcc.gnu.org", "date": "2005-06-02T08:39:06Z"}, "message": "reload1.c (reload): Undo 2005-04-20 change.\n\n\t* reload1.c (reload): Undo 2005-04-20 change.  Make sure we detect\n\tthe correct set of init_insns that need deletion.\n\nFrom-SVN: r100481", "tree": {"sha": "1690bbaff25f12d9831a1516662c851a5e636123", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1690bbaff25f12d9831a1516662c851a5e636123"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/bf8f8254eae6616841fcebe1af3de1d921bd0c24", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bf8f8254eae6616841fcebe1af3de1d921bd0c24", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bf8f8254eae6616841fcebe1af3de1d921bd0c24", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bf8f8254eae6616841fcebe1af3de1d921bd0c24/comments", "author": null, "committer": null, "parents": [{"sha": "d29e107f39c435fd575e35d4aabd3984ede245cd", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d29e107f39c435fd575e35d4aabd3984ede245cd", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d29e107f39c435fd575e35d4aabd3984ede245cd"}], "stats": {"total": 24, "additions": 13, "deletions": 11}, "files": [{"sha": "9891a770fd687b4c0fd17deda9dfed7efda623f2", "filename": "gcc/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bf8f8254eae6616841fcebe1af3de1d921bd0c24/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bf8f8254eae6616841fcebe1af3de1d921bd0c24/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=bf8f8254eae6616841fcebe1af3de1d921bd0c24", "patch": "@@ -1,3 +1,8 @@\n+2005-06-02  Bernd Schmidt  <bernd.schmidt@analog.com>\n+\n+\t* reload1.c (reload): Undo 2005-04-20 change.  Make sure we detect\n+\tthe correct set of init_insns that need deletion.\n+\n 2005-06-02  Kaz Kojima  <kkojima@gcc.gnu.org>\n \n \t* config/sh/sh.h (TARGET_FPU_DOUBLE): Use MASK_SH4."}, {"sha": "78484aa75361bafdbc91b0ef4bd13cf1fdb7b5d8", "filename": "gcc/reload1.c", "status": "modified", "additions": 8, "deletions": 11, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bf8f8254eae6616841fcebe1af3de1d921bd0c24/gcc%2Freload1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bf8f8254eae6616841fcebe1af3de1d921bd0c24/gcc%2Freload1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freload1.c?ref=bf8f8254eae6616841fcebe1af3de1d921bd0c24", "patch": "@@ -752,7 +752,7 @@ reload (rtx first, int global)\n \t\t     for equivalences.  This is overly conservative as\n \t\t     we could find all sets of the destination pseudo\n \t\t     and remove them as they should be redundant.  */\n-\t\t  if (memory_operand (x, VOIDmode) && ! MEM_READONLY_P (x))\n+\t\t  if (memory_operand (x, VOIDmode))\n \t\t    {\n \t\t      /* Always unshare the equivalence, so we can\n \t\t\t substitute into this insn without touching the\n@@ -787,14 +787,8 @@ reload (rtx first, int global)\n \t\t  else\n \t\t    continue;\n \n-\t\t  /* If this register is being made equivalent to a MEM\n-\t\t     and the MEM is not SET_SRC, the equivalencing insn\n-\t\t     is one with the MEM as a SET_DEST and it occurs later.\n-\t\t     So don't mark this insn now.  */\n-\t\t  if (!MEM_P (x)\n-\t\t      || rtx_equal_p (SET_SRC (set), x))\n-\t\t    reg_equiv_init[i]\n-\t\t      = gen_rtx_INSN_LIST (VOIDmode, insn, reg_equiv_init[i]);\n+\t\t  reg_equiv_init[i]\n+\t\t    = gen_rtx_INSN_LIST (VOIDmode, insn, reg_equiv_init[i]);\n \t\t}\n \t    }\n \t}\n@@ -806,9 +800,12 @@ reload (rtx first, int global)\n \t       && reg_equiv_memory_loc[REGNO (SET_SRC (set))]\n \t       && rtx_equal_p (SET_DEST (set),\n \t\t\t       reg_equiv_memory_loc[REGNO (SET_SRC (set))]))\n+\t/* Equivalences made this way only have one initializing insn.\n+\t   Previously, we may have set reg_equiv_init when encountering a\n+\t   SET of this pseudo; discard that insn since it does not set up\n+\t   an equivalence.  */\n \treg_equiv_init[REGNO (SET_SRC (set))]\n-\t  = gen_rtx_INSN_LIST (VOIDmode, insn,\n-\t\t\t       reg_equiv_init[REGNO (SET_SRC (set))]);\n+\t  = gen_rtx_INSN_LIST (VOIDmode, insn, NULL_RTX);\n \n       if (INSN_P (insn))\n \tscan_paradoxical_subregs (PATTERN (insn));"}]}