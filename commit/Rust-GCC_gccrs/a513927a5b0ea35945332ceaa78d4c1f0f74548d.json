{"sha": "a513927a5b0ea35945332ceaa78d4c1f0f74548d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTUxMzkyN2E1YjBlYTM1OTQ1MzMyY2VhYTc4ZDRjMWYwZjc0NTQ4ZA==", "commit": {"author": {"name": "Steven G. Kargl", "email": "kargl@gcc.gnu.org", "date": "2009-05-13T20:49:13Z"}, "committer": {"name": "Steven G. Kargl", "email": "kargl@gcc.gnu.org", "date": "2009-05-13T20:49:13Z"}, "message": "gfortran.h (gfc_code): Rename struct member expr to expr1.\n\n2009-05-13  Steven G. Kargl  <kargl@gcc.gnu.org>\n\n\t* gfortran.h (gfc_code): Rename struct member expr to expr1.\n\t* openmp.c (resolve_omp_atomic): Update expr to expr1.\n\t* interface.c (gfc_extend_assign): Ditto.\n\t* trans-expr.c (gfc_conv_expr_reference, gfc_trans_assignment,\n\tgfc_trans_init_assign): Ditto.\n\t* dump-parse-tree.c (show_code_node): Ditto.\n\t* trans-openmp.c (gfc_trans_omp_atomic): Ditto.\n\t* trans-stmt.c ( gfc_trans_label_assign, gfc_trans_goto, gfc_trans_call,\n\tgfc_trans_return, gfc_trans_pause, gfc_trans_stop, gfc_trans_if_1,\n\tgfc_trans_arithmetic_if, gfc_trans_do_while, gfc_trans_integer_select,\n\tgfc_trans_logical_select, gfc_trans_character_select\n\tforall_make_variable_temp, check_forall_dependencies\n\tgfc_trans_forall_1, gfc_trans_where_2, gfc_trans_where_3\n\tgfc_trans_where, gfc_trans_allocate, gfc_trans_deallocate): Ditto.\n\t* io.c (match_io_element, gfc_match_inquire): Ditto.\n\t* resolve.c (resolve_typebound_call, resolve_ppc_call,\n\tresolve_allocate_expr, resolve_allocate_deallocate, resolve_select,\n\tresolve_transfer, resolve_where, gfc_resolve_assign_in_forall,\n\tgfc_resolve_blocks, resolve_code, build_init_assign): Ditto.\n\t* st.c (gfc_free_statement): Ditto.\n\t* match.c (gfc_match_assignment, gfc_match_pointer_assignment,\n\tmatch_arithmetic_if, gfc_match_if, gfc_match_elseif\n\tgfc_match_stopcode, gfc_match_assign, gfc_match_goto,\n\tgfc_match_nullify, match_typebound_call, gfc_match_call\n\tgfc_match_select, match_simple_where, gfc_match_where\n\tgfc_match_elsewhere, match_simple_forall, gfc_match_forall): Ditto.\n\t* trans-io.c (gfc_trans_transfer): Ditto.\n\t* parse.c (parse_where_block, parse_if_block): Ditto.\n\nFrom-SVN: r147497", "tree": {"sha": "335e16f0f2fd0f0c5c136815bc01e0d49a283422", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/335e16f0f2fd0f0c5c136815bc01e0d49a283422"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a513927a5b0ea35945332ceaa78d4c1f0f74548d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a513927a5b0ea35945332ceaa78d4c1f0f74548d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a513927a5b0ea35945332ceaa78d4c1f0f74548d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a513927a5b0ea35945332ceaa78d4c1f0f74548d/comments", "author": null, "committer": null, "parents": [{"sha": "42657b0761ec0781663bb0d001d37fafbb23df88", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/42657b0761ec0781663bb0d001d37fafbb23df88", "html_url": "https://github.com/Rust-GCC/gccrs/commit/42657b0761ec0781663bb0d001d37fafbb23df88"}], "stats": {"total": 513, "additions": 272, "deletions": 241}, "files": [{"sha": "079840719886dd3c77cdc7bef48bd243e05e6751", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a513927a5b0ea35945332ceaa78d4c1f0f74548d/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a513927a5b0ea35945332ceaa78d4c1f0f74548d/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=a513927a5b0ea35945332ceaa78d4c1f0f74548d", "patch": "@@ -1,3 +1,34 @@\n+2009-05-13  Steven G. Kargl  <kargl@gcc.gnu.org>\n+\n+\t* gfortran.h (gfc_code): Rename struct member expr to expr1.\n+\t* openmp.c (resolve_omp_atomic): Update expr to expr1.\n+\t* interface.c (gfc_extend_assign): Ditto.\n+\t* trans-expr.c (gfc_conv_expr_reference, gfc_trans_assignment,\n+\tgfc_trans_init_assign): Ditto.\n+\t* dump-parse-tree.c (show_code_node): Ditto.\n+\t* trans-openmp.c (gfc_trans_omp_atomic): Ditto.\n+\t* trans-stmt.c ( gfc_trans_label_assign, gfc_trans_goto, gfc_trans_call,\n+\tgfc_trans_return, gfc_trans_pause, gfc_trans_stop, gfc_trans_if_1,\n+\tgfc_trans_arithmetic_if, gfc_trans_do_while, gfc_trans_integer_select,\n+\tgfc_trans_logical_select, gfc_trans_character_select\n+\tforall_make_variable_temp, check_forall_dependencies\n+\tgfc_trans_forall_1, gfc_trans_where_2, gfc_trans_where_3\n+\tgfc_trans_where, gfc_trans_allocate, gfc_trans_deallocate): Ditto.\n+\t* io.c (match_io_element, gfc_match_inquire): Ditto.\n+\t* resolve.c (resolve_typebound_call, resolve_ppc_call,\n+\tresolve_allocate_expr, resolve_allocate_deallocate, resolve_select,\n+\tresolve_transfer, resolve_where, gfc_resolve_assign_in_forall,\n+\tgfc_resolve_blocks, resolve_code, build_init_assign): Ditto.\n+\t* st.c (gfc_free_statement): Ditto.\n+\t* match.c (gfc_match_assignment, gfc_match_pointer_assignment,\n+\tmatch_arithmetic_if, gfc_match_if, gfc_match_elseif\n+\tgfc_match_stopcode, gfc_match_assign, gfc_match_goto,\n+\tgfc_match_nullify, match_typebound_call, gfc_match_call\n+\tgfc_match_select, match_simple_where, gfc_match_where\n+\tgfc_match_elsewhere, match_simple_forall, gfc_match_forall): Ditto.\n+\t* trans-io.c (gfc_trans_transfer): Ditto.\n+\t* parse.c (parse_where_block, parse_if_block): Ditto.\n+\n 2009-05-13  Steven G. Kargl  <kargl@gcc.gnu.org>\n \n \t* gfortran.h (gfc_code): Rename struct member label to label1."}, {"sha": "eb747c1bd6aec0b72f4b270a1981020a8c744370", "filename": "gcc/fortran/dump-parse-tree.c", "status": "modified", "additions": 28, "deletions": 28, "changes": 56, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a513927a5b0ea35945332ceaa78d4c1f0f74548d/gcc%2Ffortran%2Fdump-parse-tree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a513927a5b0ea35945332ceaa78d4c1f0f74548d/gcc%2Ffortran%2Fdump-parse-tree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fdump-parse-tree.c?ref=a513927a5b0ea35945332ceaa78d4c1f0f74548d", "patch": "@@ -1166,20 +1166,20 @@ show_code_node (int level, gfc_code *c)\n     case EXEC_INIT_ASSIGN:\n     case EXEC_ASSIGN:\n       fputs (\"ASSIGN \", dumpfile);\n-      show_expr (c->expr);\n+      show_expr (c->expr1);\n       fputc (' ', dumpfile);\n       show_expr (c->expr2);\n       break;\n \n     case EXEC_LABEL_ASSIGN:\n       fputs (\"LABEL ASSIGN \", dumpfile);\n-      show_expr (c->expr);\n+      show_expr (c->expr1);\n       fprintf (dumpfile, \" %d\", c->label1->value);\n       break;\n \n     case EXEC_POINTER_ASSIGN:\n       fputs (\"POINTER ASSIGN \", dumpfile);\n-      show_expr (c->expr);\n+      show_expr (c->expr1);\n       fputc (' ', dumpfile);\n       show_expr (c->expr2);\n       break;\n@@ -1190,7 +1190,7 @@ show_code_node (int level, gfc_code *c)\n \tfprintf (dumpfile, \"%d\", c->label1->value);\n       else\n \t{\n-\t  show_expr (c->expr);\n+\t  show_expr (c->expr1);\n \t  d = c->block;\n \t  if (d != NULL)\n \t    {\n@@ -1221,26 +1221,26 @@ show_code_node (int level, gfc_code *c)\n \n     case EXEC_COMPCALL:\n       fputs (\"CALL \", dumpfile);\n-      show_compcall (c->expr);\n+      show_compcall (c->expr1);\n       break;\n \n     case EXEC_CALL_PPC:\n       fputs (\"CALL \", dumpfile);\n-      show_expr (c->expr);\n+      show_expr (c->expr1);\n       show_actual_arglist (c->ext.actual);\n       break;\n \n     case EXEC_RETURN:\n       fputs (\"RETURN \", dumpfile);\n-      if (c->expr)\n-\tshow_expr (c->expr);\n+      if (c->expr1)\n+\tshow_expr (c->expr1);\n       break;\n \n     case EXEC_PAUSE:\n       fputs (\"PAUSE \", dumpfile);\n \n-      if (c->expr != NULL)\n-\tshow_expr (c->expr);\n+      if (c->expr1 != NULL)\n+\tshow_expr (c->expr1);\n       else\n \tfprintf (dumpfile, \"%d\", c->ext.stop_code);\n \n@@ -1249,24 +1249,24 @@ show_code_node (int level, gfc_code *c)\n     case EXEC_STOP:\n       fputs (\"STOP \", dumpfile);\n \n-      if (c->expr != NULL)\n-\tshow_expr (c->expr);\n+      if (c->expr1 != NULL)\n+\tshow_expr (c->expr1);\n       else\n \tfprintf (dumpfile, \"%d\", c->ext.stop_code);\n \n       break;\n \n     case EXEC_ARITHMETIC_IF:\n       fputs (\"IF \", dumpfile);\n-      show_expr (c->expr);\n+      show_expr (c->expr1);\n       fprintf (dumpfile, \" %d, %d, %d\",\n \t\t  c->label1->value, c->label2->value, c->label3->value);\n       break;\n \n     case EXEC_IF:\n       d = c->block;\n       fputs (\"IF \", dumpfile);\n-      show_expr (d->expr);\n+      show_expr (d->expr1);\n       fputc ('\\n', dumpfile);\n       show_code (level + 1, d->next);\n \n@@ -1275,12 +1275,12 @@ show_code_node (int level, gfc_code *c)\n \t{\n \t  code_indent (level, 0);\n \n-\t  if (d->expr == NULL)\n+\t  if (d->expr1 == NULL)\n \t    fputs (\"ELSE\\n\", dumpfile);\n \t  else\n \t    {\n \t      fputs (\"ELSE IF \", dumpfile);\n-\t      show_expr (d->expr);\n+\t      show_expr (d->expr1);\n \t      fputc ('\\n', dumpfile);\n \t    }\n \n@@ -1295,7 +1295,7 @@ show_code_node (int level, gfc_code *c)\n     case EXEC_SELECT:\n       d = c->block;\n       fputs (\"SELECT CASE \", dumpfile);\n-      show_expr (c->expr);\n+      show_expr (c->expr1);\n       fputc ('\\n', dumpfile);\n \n       for (; d; d = d->block)\n@@ -1325,7 +1325,7 @@ show_code_node (int level, gfc_code *c)\n       fputs (\"WHERE \", dumpfile);\n \n       d = c->block;\n-      show_expr (d->expr);\n+      show_expr (d->expr1);\n       fputc ('\\n', dumpfile);\n \n       show_code (level + 1, d->next);\n@@ -1334,7 +1334,7 @@ show_code_node (int level, gfc_code *c)\n \t{\n \t  code_indent (level, 0);\n \t  fputs (\"ELSE WHERE \", dumpfile);\n-\t  show_expr (d->expr);\n+\t  show_expr (d->expr1);\n \t  fputc ('\\n', dumpfile);\n \t  show_code (level + 1, d->next);\n \t}\n@@ -1360,10 +1360,10 @@ show_code_node (int level, gfc_code *c)\n \t    fputc (',', dumpfile);\n \t}\n \n-      if (c->expr != NULL)\n+      if (c->expr1 != NULL)\n \t{\n \t  fputc (',', dumpfile);\n-\t  show_expr (c->expr);\n+\t  show_expr (c->expr1);\n \t}\n       fputc ('\\n', dumpfile);\n \n@@ -1393,7 +1393,7 @@ show_code_node (int level, gfc_code *c)\n \n     case EXEC_DO_WHILE:\n       fputs (\"DO WHILE \", dumpfile);\n-      show_expr (c->expr);\n+      show_expr (c->expr1);\n       fputc ('\\n', dumpfile);\n \n       show_code (level + 1, c->block->next);\n@@ -1416,10 +1416,10 @@ show_code_node (int level, gfc_code *c)\n \n     case EXEC_ALLOCATE:\n       fputs (\"ALLOCATE \", dumpfile);\n-      if (c->expr)\n+      if (c->expr1)\n \t{\n \t  fputs (\" STAT=\", dumpfile);\n-\t  show_expr (c->expr);\n+\t  show_expr (c->expr1);\n \t}\n \n       for (a = c->ext.alloc_list; a; a = a->next)\n@@ -1432,10 +1432,10 @@ show_code_node (int level, gfc_code *c)\n \n     case EXEC_DEALLOCATE:\n       fputs (\"DEALLOCATE \", dumpfile);\n-      if (c->expr)\n+      if (c->expr1)\n \t{\n \t  fputs (\" STAT=\", dumpfile);\n-\t  show_expr (c->expr);\n+\t  show_expr (c->expr1);\n \t}\n \n       for (a = c->ext.alloc_list; a; a = a->next)\n@@ -1798,7 +1798,7 @@ show_code_node (int level, gfc_code *c)\n \n     case EXEC_IOLENGTH:\n       fputs (\"IOLENGTH \", dumpfile);\n-      show_expr (c->expr);\n+      show_expr (c->expr1);\n       goto show_dt_code;\n       break;\n \n@@ -1907,7 +1907,7 @@ show_code_node (int level, gfc_code *c)\n \n     case EXEC_TRANSFER:\n       fputs (\"TRANSFER \", dumpfile);\n-      show_expr (c->expr);\n+      show_expr (c->expr1);\n       break;\n \n     case EXEC_DT_END:"}, {"sha": "86f2c5bf25289deac885cb1da3347247516460b3", "filename": "gcc/fortran/gfortran.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a513927a5b0ea35945332ceaa78d4c1f0f74548d/gcc%2Ffortran%2Fgfortran.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a513927a5b0ea35945332ceaa78d4c1f0f74548d/gcc%2Ffortran%2Fgfortran.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fgfortran.h?ref=a513927a5b0ea35945332ceaa78d4c1f0f74548d", "patch": "@@ -1915,7 +1915,7 @@ typedef struct gfc_code\n \n   gfc_st_label *here, *label1, *label2, *label3;\n   gfc_symtree *symtree;\n-  gfc_expr *expr, *expr2;\n+  gfc_expr *expr1, *expr2;\n   /* A name isn't sufficient to identify a subroutine, we need the actual\n      symbol for the interface definition.\n   const char *sub_name;  */"}, {"sha": "ee1f5286309c8cdffb4767e4866c3238a054a15d", "filename": "gcc/fortran/interface.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a513927a5b0ea35945332ceaa78d4c1f0f74548d/gcc%2Ffortran%2Finterface.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a513927a5b0ea35945332ceaa78d4c1f0f74548d/gcc%2Ffortran%2Finterface.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Finterface.c?ref=a513927a5b0ea35945332ceaa78d4c1f0f74548d", "patch": "@@ -2591,7 +2591,7 @@ gfc_extend_assign (gfc_code *c, gfc_namespace *ns)\n   gfc_expr *lhs, *rhs;\n   gfc_symbol *sym;\n \n-  lhs = c->expr;\n+  lhs = c->expr1;\n   rhs = c->expr2;\n \n   /* Don't allow an intrinsic assignment to be replaced.  */\n@@ -2626,7 +2626,7 @@ gfc_extend_assign (gfc_code *c, gfc_namespace *ns)\n   /* Replace the assignment with the call.  */\n   c->op = EXEC_ASSIGN_CALL;\n   c->symtree = gfc_find_sym_in_symtree (sym);\n-  c->expr = NULL;\n+  c->expr1 = NULL;\n   c->expr2 = NULL;\n   c->ext.actual = actual;\n "}, {"sha": "eb0e3ae6b28bb3001853eeeef44b2572b4208972", "filename": "gcc/fortran/io.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a513927a5b0ea35945332ceaa78d4c1f0f74548d/gcc%2Ffortran%2Fio.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a513927a5b0ea35945332ceaa78d4c1f0f74548d/gcc%2Ffortran%2Fio.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fio.c?ref=a513927a5b0ea35945332ceaa78d4c1f0f74548d", "patch": "@@ -2830,7 +2830,7 @@ match_io_element (io_kind k, gfc_code **cpp)\n \n   cp = gfc_get_code ();\n   cp->op = EXEC_TRANSFER;\n-  cp->expr = expr;\n+  cp->expr1 = expr;\n \n   *cpp = cp;\n   return MATCH_YES;\n@@ -3662,7 +3662,7 @@ gfc_match_inquire (void)\n \tgoto syntax;\n \n       new_st.op = EXEC_IOLENGTH;\n-      new_st.expr = inquire->iolength;\n+      new_st.expr1 = inquire->iolength;\n       new_st.ext.inquire = inquire;\n \n       if (gfc_pure (NULL))"}, {"sha": "ed7bf58bb8618efa58551dd893370c1fd88cea1a", "filename": "gcc/fortran/match.c", "status": "modified", "additions": 30, "deletions": 30, "changes": 60, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a513927a5b0ea35945332ceaa78d4c1f0f74548d/gcc%2Ffortran%2Fmatch.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a513927a5b0ea35945332ceaa78d4c1f0f74548d/gcc%2Ffortran%2Fmatch.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fmatch.c?ref=a513927a5b0ea35945332ceaa78d4c1f0f74548d", "patch": "@@ -1306,7 +1306,7 @@ gfc_match_assignment (void)\n   gfc_set_sym_referenced (lvalue->symtree->n.sym);\n \n   new_st.op = EXEC_ASSIGN;\n-  new_st.expr = lvalue;\n+  new_st.expr1 = lvalue;\n   new_st.expr2 = rvalue;\n \n   gfc_check_do_variable (lvalue->symtree);\n@@ -1346,7 +1346,7 @@ gfc_match_pointer_assignment (void)\n     goto cleanup;\n \n   new_st.op = EXEC_POINTER_ASSIGN;\n-  new_st.expr = lvalue;\n+  new_st.expr1 = lvalue;\n   new_st.expr2 = rvalue;\n \n   return MATCH_YES;\n@@ -1388,7 +1388,7 @@ match_arithmetic_if (void)\n     return MATCH_ERROR;\n \n   new_st.op = EXEC_ARITHMETIC_IF;\n-  new_st.expr = expr;\n+  new_st.expr1 = expr;\n   new_st.label1 = l1;\n   new_st.label2 = l2;\n   new_st.label3 = l3;\n@@ -1469,7 +1469,7 @@ gfc_match_if (gfc_statement *if_type)\n \treturn MATCH_ERROR;\n \n       new_st.op = EXEC_ARITHMETIC_IF;\n-      new_st.expr = expr;\n+      new_st.expr1 = expr;\n       new_st.label1 = l1;\n       new_st.label2 = l2;\n       new_st.label3 = l3;\n@@ -1481,7 +1481,7 @@ gfc_match_if (gfc_statement *if_type)\n   if (gfc_match (\" then%t\") == MATCH_YES)\n     {\n       new_st.op = EXEC_IF;\n-      new_st.expr = expr;\n+      new_st.expr1 = expr;\n       *if_type = ST_IF_BLOCK;\n       return MATCH_YES;\n     }\n@@ -1601,7 +1601,7 @@ gfc_match_if (gfc_statement *if_type)\n   *p->next = new_st;\n   p->next->loc = gfc_current_locus;\n \n-  p->expr = expr;\n+  p->expr1 = expr;\n   p->op = EXEC_IF;\n \n   gfc_clear_new_st ();\n@@ -1677,7 +1677,7 @@ gfc_match_elseif (void)\n \n done:\n   new_st.op = EXEC_IF;\n-  new_st.expr = expr;\n+  new_st.expr1 = expr;\n   return MATCH_YES;\n \n cleanup:\n@@ -1792,7 +1792,7 @@ gfc_match_do (void)\n   new_st.label1 = label;\n \n   if (new_st.op == EXEC_DO_WHILE)\n-    new_st.expr = iter.end;\n+    new_st.expr1 = iter.end;\n   else\n     {\n       new_st.ext.iterator = ip = gfc_get_iterator ();\n@@ -1952,7 +1952,7 @@ gfc_match_stopcode (gfc_statement st)\n     }\n \n   new_st.op = st == ST_STOP ? EXEC_STOP : EXEC_PAUSE;\n-  new_st.expr = e;\n+  new_st.expr1 = e;\n   new_st.ext.stop_code = stop_code;\n \n   return MATCH_YES;\n@@ -2034,7 +2034,7 @@ gfc_match_assign (void)\n \n \t  new_st.op = EXEC_LABEL_ASSIGN;\n \t  new_st.label1 = label;\n-\t  new_st.expr = expr;\n+\t  new_st.expr1 = expr;\n \t  return MATCH_YES;\n \t}\n     }\n@@ -2077,7 +2077,7 @@ gfc_match_goto (void)\n \treturn MATCH_ERROR;\n \n       new_st.op = EXEC_GOTO;\n-      new_st.expr = expr;\n+      new_st.expr1 = expr;\n \n       if (gfc_match_eos () == MATCH_YES)\n \treturn MATCH_YES;\n@@ -2184,7 +2184,7 @@ gfc_match_goto (void)\n      equivalent SELECT statement constructed.  */\n \n   new_st.op = EXEC_SELECT;\n-  new_st.expr = NULL;\n+  new_st.expr1 = NULL;\n \n   /* Hack: For a \"real\" SELECT, the expression is in expr. We put\n      it in expr2 so we can distinguish then and produce the correct\n@@ -2337,7 +2337,7 @@ gfc_match_allocate (void)\n     goto syntax;\n \n   new_st.op = EXEC_ALLOCATE;\n-  new_st.expr = stat;\n+  new_st.expr1 = stat;\n   new_st.expr2 = errmsg;\n   new_st.ext.alloc_list = head;\n \n@@ -2402,7 +2402,7 @@ gfc_match_nullify (void)\n \t}\n \n       tail->op = EXEC_POINTER_ASSIGN;\n-      tail->expr = p;\n+      tail->expr1 = p;\n       tail->expr2 = e;\n \n       if (gfc_match (\" )%t\") == MATCH_YES)\n@@ -2538,7 +2538,7 @@ gfc_match_deallocate (void)\n     goto syntax;\n \n   new_st.op = EXEC_DEALLOCATE;\n-  new_st.expr = stat;\n+  new_st.expr1 = stat;\n   new_st.expr2 = errmsg;\n   new_st.ext.alloc_list = head;\n \n@@ -2606,7 +2606,7 @@ gfc_match_return (void)\n       return MATCH_ERROR;\n \n   new_st.op = EXEC_RETURN;\n-  new_st.expr = e;\n+  new_st.expr1 = e;\n \n   return MATCH_YES;\n }\n@@ -2652,7 +2652,7 @@ match_typebound_call (gfc_symtree* varst)\n \t\t \"at %C\");\n       return MATCH_ERROR;\n     }\n-  new_st.expr = base;\n+  new_st.expr1 = base;\n \n   return MATCH_YES;\n }\n@@ -2755,11 +2755,11 @@ gfc_match_call (void)\n       select_sym->ts.type = BT_INTEGER;\n       select_sym->ts.kind = gfc_default_integer_kind;\n       gfc_set_sym_referenced (select_sym);\n-      c->expr = gfc_get_expr ();\n-      c->expr->expr_type = EXPR_VARIABLE;\n-      c->expr->symtree = select_st;\n-      c->expr->ts = select_sym->ts;\n-      c->expr->where = gfc_current_locus;\n+      c->expr1 = gfc_get_expr ();\n+      c->expr1->expr_type = EXPR_VARIABLE;\n+      c->expr1->symtree = select_st;\n+      c->expr1->ts = select_sym->ts;\n+      c->expr1->where = gfc_current_locus;\n \n       i = 0;\n       for (a = arglist; a; a = a->next)\n@@ -3655,7 +3655,7 @@ gfc_match_select (void)\n     return m;\n \n   new_st.op = EXEC_SELECT;\n-  new_st.expr = expr;\n+  new_st.expr1 = expr;\n \n   return MATCH_YES;\n }\n@@ -3760,7 +3760,7 @@ match_simple_where (void)\n   c = gfc_get_code ();\n \n   c->op = EXEC_WHERE;\n-  c->expr = expr;\n+  c->expr1 = expr;\n   c->next = gfc_get_code ();\n \n   *c->next = new_st;\n@@ -3801,7 +3801,7 @@ gfc_match_where (gfc_statement *st)\n     {\n       *st = ST_WHERE_BLOCK;\n       new_st.op = EXEC_WHERE;\n-      new_st.expr = expr;\n+      new_st.expr1 = expr;\n       return MATCH_YES;\n     }\n \n@@ -3820,7 +3820,7 @@ gfc_match_where (gfc_statement *st)\n   c = gfc_get_code ();\n \n   c->op = EXEC_WHERE;\n-  c->expr = expr;\n+  c->expr1 = expr;\n   c->next = gfc_get_code ();\n \n   *c->next = new_st;\n@@ -3890,7 +3890,7 @@ gfc_match_elsewhere (void)\n     }\n \n   new_st.op = EXEC_WHERE;\n-  new_st.expr = expr;\n+  new_st.expr1 = expr;\n   return MATCH_YES;\n \n syntax:\n@@ -4107,7 +4107,7 @@ match_simple_forall (void)\n \n   gfc_clear_new_st ();\n   new_st.op = EXEC_FORALL;\n-  new_st.expr = mask;\n+  new_st.expr1 = mask;\n   new_st.ext.forall_iterator = head;\n   new_st.block = gfc_get_code ();\n \n@@ -4159,7 +4159,7 @@ gfc_match_forall (gfc_statement *st)\n     {\n       *st = ST_FORALL_BLOCK;\n       new_st.op = EXEC_FORALL;\n-      new_st.expr = mask;\n+      new_st.expr1 = mask;\n       new_st.ext.forall_iterator = head;\n       return MATCH_YES;\n     }\n@@ -4182,7 +4182,7 @@ gfc_match_forall (gfc_statement *st)\n \n   gfc_clear_new_st ();\n   new_st.op = EXEC_FORALL;\n-  new_st.expr = mask;\n+  new_st.expr1 = mask;\n   new_st.ext.forall_iterator = head;\n   new_st.block = gfc_get_code ();\n   new_st.block->op = EXEC_FORALL;"}, {"sha": "0e9dda80ce68d74bccec6c9f4c7fc19598573aee", "filename": "gcc/fortran/openmp.c", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a513927a5b0ea35945332ceaa78d4c1f0f74548d/gcc%2Ffortran%2Fopenmp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a513927a5b0ea35945332ceaa78d4c1f0f74548d/gcc%2Ffortran%2Fopenmp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fopenmp.c?ref=a513927a5b0ea35945332ceaa78d4c1f0f74548d", "patch": "@@ -1072,20 +1072,20 @@ resolve_omp_atomic (gfc_code *code)\n   gcc_assert (code->op == EXEC_ASSIGN);\n   gcc_assert (code->next == NULL);\n \n-  if (code->expr->expr_type != EXPR_VARIABLE\n-      || code->expr->symtree == NULL\n-      || code->expr->rank != 0\n-      || (code->expr->ts.type != BT_INTEGER\n-\t  && code->expr->ts.type != BT_REAL\n-\t  && code->expr->ts.type != BT_COMPLEX\n-\t  && code->expr->ts.type != BT_LOGICAL))\n+  if (code->expr1->expr_type != EXPR_VARIABLE\n+      || code->expr1->symtree == NULL\n+      || code->expr1->rank != 0\n+      || (code->expr1->ts.type != BT_INTEGER\n+\t  && code->expr1->ts.type != BT_REAL\n+\t  && code->expr1->ts.type != BT_COMPLEX\n+\t  && code->expr1->ts.type != BT_LOGICAL))\n     {\n       gfc_error (\"!$OMP ATOMIC statement must set a scalar variable of \"\n \t\t \"intrinsic type at %L\", &code->loc);\n       return;\n     }\n \n-  var = code->expr->symtree->n.sym;\n+  var = code->expr1->symtree->n.sym;\n   expr2 = is_conversion (code->expr2, false);\n   if (expr2 == NULL)\n     expr2 = code->expr2;"}, {"sha": "0b2cbf3cb0e316203af03b6bb26142d92d981733", "filename": "gcc/fortran/parse.c", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a513927a5b0ea35945332ceaa78d4c1f0f74548d/gcc%2Ffortran%2Fparse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a513927a5b0ea35945332ceaa78d4c1f0f74548d/gcc%2Ffortran%2Fparse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fparse.c?ref=a513927a5b0ea35945332ceaa78d4c1f0f74548d", "patch": "@@ -2508,10 +2508,10 @@ parse_where_block (void)\n   push_state (&s, COMP_WHERE, gfc_new_block);\n \n   d = add_statement ();\n-  d->expr = top->expr;\n+  d->expr1 = top->expr1;\n   d->op = EXEC_WHERE;\n \n-  top->expr = NULL;\n+  top->expr1 = NULL;\n   top->block = d;\n \n   seen_empty_else = 0;\n@@ -2541,12 +2541,12 @@ parse_where_block (void)\n \t      break;\n \t    }\n \n-\t  if (new_st.expr == NULL)\n+\t  if (new_st.expr1 == NULL)\n \t    seen_empty_else = 1;\n \n \t  d = new_level (gfc_state_stack->head);\n \t  d->op = EXEC_WHERE;\n-\t  d->expr = new_st.expr;\n+\t  d->expr1 = new_st.expr1;\n \n \t  accept_statement (st);\n \n@@ -2651,8 +2651,8 @@ parse_if_block (void)\n   new_st.op = EXEC_IF;\n   d = add_statement ();\n \n-  d->expr = top->expr;\n-  top->expr = NULL;\n+  d->expr1 = top->expr1;\n+  top->expr1 = NULL;\n   top->block = d;\n \n   do\n@@ -2676,7 +2676,7 @@ parse_if_block (void)\n \n \t  d = new_level (gfc_state_stack->head);\n \t  d->op = EXEC_IF;\n-\t  d->expr = new_st.expr;\n+\t  d->expr1 = new_st.expr1;\n \n \t  accept_statement (st);\n "}, {"sha": "dbca1752b55fcba846d3c246b8b27ea1aa62b324", "filename": "gcc/fortran/resolve.c", "status": "modified", "additions": 71, "deletions": 71, "changes": 142, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a513927a5b0ea35945332ceaa78d4c1f0f74548d/gcc%2Ffortran%2Fresolve.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a513927a5b0ea35945332ceaa78d4c1f0f74548d/gcc%2Ffortran%2Fresolve.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fresolve.c?ref=a513927a5b0ea35945332ceaa78d4c1f0f74548d", "patch": "@@ -4738,31 +4738,31 @@ resolve_typebound_call (gfc_code* c)\n   gfc_symtree* target;\n \n   /* Check that's really a SUBROUTINE.  */\n-  if (!c->expr->value.compcall.tbp->subroutine)\n+  if (!c->expr1->value.compcall.tbp->subroutine)\n     {\n       gfc_error (\"'%s' at %L should be a SUBROUTINE\",\n-\t\t c->expr->value.compcall.name, &c->loc);\n+\t\t c->expr1->value.compcall.name, &c->loc);\n       return FAILURE;\n     }\n \n-  if (check_typebound_baseobject (c->expr) == FAILURE)\n+  if (check_typebound_baseobject (c->expr1) == FAILURE)\n     return FAILURE;\n \n-  if (resolve_typebound_generic_call (c->expr) == FAILURE)\n+  if (resolve_typebound_generic_call (c->expr1) == FAILURE)\n     return FAILURE;\n \n   /* Transform into an ordinary EXEC_CALL for now.  */\n \n-  if (resolve_typebound_static (c->expr, &target, &newactual) == FAILURE)\n+  if (resolve_typebound_static (c->expr1, &target, &newactual) == FAILURE)\n     return FAILURE;\n \n   c->ext.actual = newactual;\n   c->symtree = target;\n   c->op = EXEC_CALL;\n \n-  gcc_assert (!c->expr->ref && !c->expr->value.compcall.actual);\n-  gfc_free_expr (c->expr);\n-  c->expr = NULL;\n+  gcc_assert (!c->expr1->ref && !c->expr1->value.compcall.actual);\n+  gfc_free_expr (c->expr1);\n+  c->expr1 = NULL;\n \n   return resolve_call (c);\n }\n@@ -4819,22 +4819,22 @@ static gfc_try\n resolve_ppc_call (gfc_code* c)\n {\n   gfc_component *comp;\n-  gcc_assert (is_proc_ptr_comp (c->expr, &comp));\n+  gcc_assert (is_proc_ptr_comp (c->expr1, &comp));\n \n-  c->resolved_sym = c->expr->symtree->n.sym;\n-  c->expr->expr_type = EXPR_VARIABLE;\n-  c->ext.actual = c->expr->value.compcall.actual;\n+  c->resolved_sym = c->expr1->symtree->n.sym;\n+  c->expr1->expr_type = EXPR_VARIABLE;\n+  c->ext.actual = c->expr1->value.compcall.actual;\n \n   if (!comp->attr.subroutine)\n-    gfc_add_subroutine (&comp->attr, comp->name, &c->expr->where);\n+    gfc_add_subroutine (&comp->attr, comp->name, &c->expr1->where);\n \n   if (resolve_actual_arglist (c->ext.actual, comp->attr.proc,\n \t\t\t      comp->formal == NULL) == FAILURE)\n     return FAILURE;\n \n   /* TODO: Check actual arguments.\n-     gfc_procedure_use (stree->n.sym, &c->expr->value.compcall.actual,\n-\t\t\t&c->expr->where);*/\n+     gfc_procedure_use (stree->n.sym, &c->expr1->value.compcall.actual,\n+\t\t\t&c->expr1->where);*/\n \n   return SUCCESS;\n }\n@@ -5412,7 +5412,7 @@ resolve_allocate_expr (gfc_expr *e, gfc_code *code)\n       init_st = gfc_get_code ();\n       init_st->loc = code->loc;\n       init_st->op = EXEC_INIT_ASSIGN;\n-      init_st->expr = expr_to_initialize (e);\n+      init_st->expr1 = expr_to_initialize (e);\n       init_st->expr2 = init_e;\n       init_st->next = code->next;\n       code->next = init_st;\n@@ -5492,7 +5492,7 @@ resolve_allocate_deallocate (gfc_code *code, const char *fcn)\n   gfc_expr *stat, *errmsg, *pe, *qe;\n   gfc_alloc *a, *p, *q;\n \n-  stat = code->expr ? code->expr : NULL;\n+  stat = code->expr1 ? code->expr1 : NULL;\n \n   errmsg = code->expr2 ? code->expr2 : NULL;\n \n@@ -5843,7 +5843,7 @@ resolve_select (gfc_code *code)\n   bt type;\n   gfc_try t;\n \n-  if (code->expr == NULL)\n+  if (code->expr1 == NULL)\n     {\n       /* This was actually a computed GOTO statement.  */\n       case_expr = code->expr2;\n@@ -5856,12 +5856,12 @@ resolve_select (gfc_code *code)\n \t by the compiler, so it should always be OK.  Just move the\n \t case_expr from expr2 to expr so that we can handle computed\n \t GOTOs as normal SELECTs from here on.  */\n-      code->expr = code->expr2;\n+      code->expr1 = code->expr2;\n       code->expr2 = NULL;\n       return;\n     }\n \n-  case_expr = code->expr;\n+  case_expr = code->expr1;\n \n   type = case_expr->ts.type;\n   if (type != BT_LOGICAL && type != BT_INTEGER && type != BT_CHARACTER)\n@@ -6114,7 +6114,7 @@ resolve_transfer (gfc_code *code)\n   gfc_ref *ref;\n   gfc_expr *exp;\n \n-  exp = code->expr;\n+  exp = code->expr1;\n \n   if (exp->expr_type != EXPR_VARIABLE && exp->expr_type != EXPR_FUNCTION)\n     return;\n@@ -6123,7 +6123,7 @@ resolve_transfer (gfc_code *code)\n   ts = &sym->ts;\n \n   /* Go to actual component transferred.  */\n-  for (ref = code->expr->ref; ref; ref = ref->next)\n+  for (ref = code->expr1->ref; ref; ref = ref->next)\n     if (ref->type == REF_COMPONENT)\n       ts = &ref->u.c.component->ts;\n \n@@ -6319,19 +6319,19 @@ resolve_where (gfc_code *code, gfc_expr *mask)\n   /* Store the first WHERE mask-expr of the WHERE statement or construct.\n      In case of nested WHERE, only the outmost one is stored.  */\n   if (mask == NULL) /* outmost WHERE */\n-    e = cblock->expr;\n+    e = cblock->expr1;\n   else /* inner WHERE */\n     e = mask;\n \n   while (cblock)\n     {\n-      if (cblock->expr)\n+      if (cblock->expr1)\n \t{\n \t  /* Check if the mask-expr has a consistent shape with the\n \t     outmost WHERE mask-expr.  */\n-\t  if (resolve_where_shape (cblock->expr, e) == FAILURE)\n+\t  if (resolve_where_shape (cblock->expr1, e) == FAILURE)\n \t    gfc_error (\"WHERE mask at %L has inconsistent shape\",\n-\t\t       &cblock->expr->where);\n+\t\t       &cblock->expr1->where);\n \t }\n \n       /* the assignment statement of a WHERE statement, or the first\n@@ -6345,9 +6345,9 @@ resolve_where (gfc_code *code, gfc_expr *mask)\n \t    case EXEC_ASSIGN:\n \n \t      /* Check shape consistent for WHERE assignment target.  */\n-\t      if (e && resolve_where_shape (cnext->expr, e) == FAILURE)\n+\t      if (e && resolve_where_shape (cnext->expr1, e) == FAILURE)\n \t       gfc_error (\"WHERE assignment target at %L has \"\n-\t\t\t  \"inconsistent shape\", &cnext->expr->where);\n+\t\t\t  \"inconsistent shape\", &cnext->expr1->where);\n \t      break;\n \n   \n@@ -6393,21 +6393,21 @@ gfc_resolve_assign_in_forall (gfc_code *code, int nvar, gfc_expr **var_expr)\n \n       /* Check whether the assignment target is one of the FORALL index\n \t variable.  */\n-      if ((code->expr->expr_type == EXPR_VARIABLE)\n-\t  && (code->expr->symtree->n.sym == forall_index))\n+      if ((code->expr1->expr_type == EXPR_VARIABLE)\n+\t  && (code->expr1->symtree->n.sym == forall_index))\n \tgfc_error (\"Assignment to a FORALL index variable at %L\",\n-\t\t   &code->expr->where);\n+\t\t   &code->expr1->where);\n       else\n \t{\n \t  /* If one of the FORALL index variables doesn't appear in the\n \t     assignment variable, then there could be a many-to-one\n \t     assignment.  Emit a warning rather than an error because the\n \t     mask could be resolving this problem.  */\n-\t  if (find_forall_index (code->expr, forall_index, 0) == FAILURE)\n+\t  if (find_forall_index (code->expr1, forall_index, 0) == FAILURE)\n \t    gfc_warning (\"The FORALL with index '%s' is not used on the \"\n \t\t\t \"left side of the assignment at %L and so might \"\n \t\t\t \"cause multiple assignment to this object\",\n-\t\t\t var_expr[n]->symtree->name, &code->expr->where);\n+\t\t\t var_expr[n]->symtree->name, &code->expr1->where);\n \t}\n     }\n }\n@@ -6623,25 +6623,25 @@ gfc_resolve_blocks (gfc_code *b, gfc_namespace *ns)\n \n   for (; b; b = b->block)\n     {\n-      t = gfc_resolve_expr (b->expr);\n+      t = gfc_resolve_expr (b->expr1);\n       if (gfc_resolve_expr (b->expr2) == FAILURE)\n \tt = FAILURE;\n \n       switch (b->op)\n \t{\n \tcase EXEC_IF:\n-\t  if (t == SUCCESS && b->expr != NULL\n-\t      && (b->expr->ts.type != BT_LOGICAL || b->expr->rank != 0))\n+\t  if (t == SUCCESS && b->expr1 != NULL\n+\t      && (b->expr1->ts.type != BT_LOGICAL || b->expr1->rank != 0))\n \t    gfc_error (\"IF clause at %L requires a scalar LOGICAL expression\",\n-\t\t       &b->expr->where);\n+\t\t       &b->expr1->where);\n \t  break;\n \n \tcase EXEC_WHERE:\n \t  if (t == SUCCESS\n-\t      && b->expr != NULL\n-\t      && (b->expr->ts.type != BT_LOGICAL || b->expr->rank == 0))\n+\t      && b->expr1 != NULL\n+\t      && (b->expr1->ts.type != BT_LOGICAL || b->expr1->rank == 0))\n \t    gfc_error (\"WHERE/ELSEWHERE clause at %L requires a LOGICAL array\",\n-\t\t       &b->expr->where);\n+\t\t       &b->expr1->where);\n \t  break;\n \n \tcase EXEC_GOTO:\n@@ -6719,7 +6719,7 @@ resolve_ordinary_assign (gfc_code *code, gfc_namespace *ns)\n       return true;\n     }\n \n-  lhs = code->expr;\n+  lhs = code->expr1;\n   rhs = code->expr2;\n \n   if (rhs->is_boz\n@@ -6888,7 +6888,7 @@ resolve_code (gfc_code *code, gfc_namespace *ns)\n \n       t = SUCCESS;\n       if (code->op != EXEC_COMPCALL && code->op != EXEC_CALL_PPC)\n-\tt = gfc_resolve_expr (code->expr);\n+\tt = gfc_resolve_expr (code->expr1);\n       forall_flag = forall_save;\n \n       if (gfc_resolve_expr (code->expr2) == FAILURE)\n@@ -6916,25 +6916,25 @@ resolve_code (gfc_code *code, gfc_namespace *ns)\n \t  break;\n \n \tcase EXEC_GOTO:\n-\t  if (code->expr != NULL)\n+\t  if (code->expr1 != NULL)\n \t    {\n-\t      if (code->expr->ts.type != BT_INTEGER)\n+\t      if (code->expr1->ts.type != BT_INTEGER)\n \t\tgfc_error (\"ASSIGNED GOTO statement at %L requires an \"\n-\t\t\t   \"INTEGER variable\", &code->expr->where);\n-\t      else if (code->expr->symtree->n.sym->attr.assign != 1)\n+\t\t\t   \"INTEGER variable\", &code->expr1->where);\n+\t      else if (code->expr1->symtree->n.sym->attr.assign != 1)\n \t\tgfc_error (\"Variable '%s' has not been assigned a target \"\n-\t\t\t   \"label at %L\", code->expr->symtree->n.sym->name,\n-\t\t\t   &code->expr->where);\n+\t\t\t   \"label at %L\", code->expr1->symtree->n.sym->name,\n+\t\t\t   &code->expr1->where);\n \t    }\n \t  else\n \t    resolve_branch (code->label1, code);\n \t  break;\n \n \tcase EXEC_RETURN:\n-\t  if (code->expr != NULL\n-\t\t&& (code->expr->ts.type != BT_INTEGER || code->expr->rank))\n+\t  if (code->expr1 != NULL\n+\t\t&& (code->expr1->ts.type != BT_INTEGER || code->expr1->rank))\n \t    gfc_error (\"Alternate RETURN statement at %L requires a SCALAR-\"\n-\t\t       \"INTEGER return specifier\", &code->expr->where);\n+\t\t       \"INTEGER return specifier\", &code->expr1->where);\n \t  break;\n \n \tcase EXEC_INIT_ASSIGN:\n@@ -6955,40 +6955,40 @@ resolve_code (gfc_code *code, gfc_namespace *ns)\n \t    gfc_error (\"Label %d referenced at %L is never defined\",\n \t\t       code->label1->value, &code->label1->where);\n \t  if (t == SUCCESS\n-\t      && (code->expr->expr_type != EXPR_VARIABLE\n-\t\t  || code->expr->symtree->n.sym->ts.type != BT_INTEGER\n-\t\t  || code->expr->symtree->n.sym->ts.kind\n+\t      && (code->expr1->expr_type != EXPR_VARIABLE\n+\t\t  || code->expr1->symtree->n.sym->ts.type != BT_INTEGER\n+\t\t  || code->expr1->symtree->n.sym->ts.kind\n \t\t     != gfc_default_integer_kind\n-\t\t  || code->expr->symtree->n.sym->as != NULL))\n+\t\t  || code->expr1->symtree->n.sym->as != NULL))\n \t    gfc_error (\"ASSIGN statement at %L requires a scalar \"\n-\t\t       \"default INTEGER variable\", &code->expr->where);\n+\t\t       \"default INTEGER variable\", &code->expr1->where);\n \t  break;\n \n \tcase EXEC_POINTER_ASSIGN:\n \t  if (t == FAILURE)\n \t    break;\n \n-\t  gfc_check_pointer_assign (code->expr, code->expr2);\n+\t  gfc_check_pointer_assign (code->expr1, code->expr2);\n \t  break;\n \n \tcase EXEC_ARITHMETIC_IF:\n \t  if (t == SUCCESS\n-\t      && code->expr->ts.type != BT_INTEGER\n-\t      && code->expr->ts.type != BT_REAL)\n+\t      && code->expr1->ts.type != BT_INTEGER\n+\t      && code->expr1->ts.type != BT_REAL)\n \t    gfc_error (\"Arithmetic IF statement at %L requires a numeric \"\n-\t\t       \"expression\", &code->expr->where);\n+\t\t       \"expression\", &code->expr1->where);\n \n \t  resolve_branch (code->label1, code);\n \t  resolve_branch (code->label2, code);\n \t  resolve_branch (code->label3, code);\n \t  break;\n \n \tcase EXEC_IF:\n-\t  if (t == SUCCESS && code->expr != NULL\n-\t      && (code->expr->ts.type != BT_LOGICAL\n-\t\t  || code->expr->rank != 0))\n+\t  if (t == SUCCESS && code->expr1 != NULL\n+\t      && (code->expr1->ts.type != BT_LOGICAL\n+\t\t  || code->expr1->rank != 0))\n \t    gfc_error (\"IF clause at %L requires a scalar LOGICAL expression\",\n-\t\t       &code->expr->where);\n+\t\t       &code->expr1->where);\n \t  break;\n \n \tcase EXEC_CALL:\n@@ -7020,13 +7020,13 @@ resolve_code (gfc_code *code, gfc_namespace *ns)\n \t  break;\n \n \tcase EXEC_DO_WHILE:\n-\t  if (code->expr == NULL)\n+\t  if (code->expr1 == NULL)\n \t    gfc_internal_error (\"resolve_code(): No expression on DO WHILE\");\n \t  if (t == SUCCESS\n-\t      && (code->expr->rank != 0\n-\t\t  || code->expr->ts.type != BT_LOGICAL))\n+\t      && (code->expr1->rank != 0\n+\t\t  || code->expr1->ts.type != BT_LOGICAL))\n \t    gfc_error (\"Exit condition of DO WHILE loop at %L must be \"\n-\t\t       \"a scalar LOGICAL expression\", &code->expr->where);\n+\t\t       \"a scalar LOGICAL expression\", &code->expr1->where);\n \t  break;\n \n \tcase EXEC_ALLOCATE:\n@@ -7106,9 +7106,9 @@ resolve_code (gfc_code *code, gfc_namespace *ns)\n \tcase EXEC_FORALL:\n \t  resolve_forall_iterators (code->ext.forall_iterator);\n \n-\t  if (code->expr != NULL && code->expr->ts.type != BT_LOGICAL)\n+\t  if (code->expr1 != NULL && code->expr1->ts.type != BT_LOGICAL)\n \t    gfc_error (\"FORALL mask clause at %L requires a LOGICAL \"\n-\t\t       \"expression\", &code->expr->where);\n+\t\t       \"expression\", &code->expr1->where);\n \t  break;\n \n \tcase EXEC_OMP_ATOMIC:\n@@ -7479,7 +7479,7 @@ build_init_assign (gfc_symbol *sym, gfc_expr *init)\n   /* Assign the default initializer to the l-value.  */\n   init_st->loc = sym->declared_at;\n   init_st->op = EXEC_INIT_ASSIGN;\n-  init_st->expr = lval;\n+  init_st->expr1 = lval;\n   init_st->expr2 = init;\n }\n "}, {"sha": "d77ef81822c8afd3a70269c8d30a37c991b5947f", "filename": "gcc/fortran/st.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a513927a5b0ea35945332ceaa78d4c1f0f74548d/gcc%2Ffortran%2Fst.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a513927a5b0ea35945332ceaa78d4c1f0f74548d/gcc%2Ffortran%2Fst.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fst.c?ref=a513927a5b0ea35945332ceaa78d4c1f0f74548d", "patch": "@@ -80,8 +80,8 @@ gfc_append_code (gfc_code *tail, gfc_code *new_code)\n void\n gfc_free_statement (gfc_code *p)\n {\n-  if (p->expr)\n-    gfc_free_expr (p->expr);\n+  if (p->expr1)\n+    gfc_free_expr (p->expr1);\n   if (p->expr2)\n     gfc_free_expr (p->expr2);\n "}, {"sha": "70c44f32968959561ce5f82d79463e1333b84b73", "filename": "gcc/fortran/trans-expr.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a513927a5b0ea35945332ceaa78d4c1f0f74548d/gcc%2Ffortran%2Ftrans-expr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a513927a5b0ea35945332ceaa78d4c1f0f74548d/gcc%2Ffortran%2Ftrans-expr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-expr.c?ref=a513927a5b0ea35945332ceaa78d4c1f0f74548d", "patch": "@@ -4014,7 +4014,7 @@ gfc_conv_expr_reference (gfc_se * se, gfc_expr * expr)\n tree\n gfc_trans_pointer_assign (gfc_code * code)\n {\n-  return gfc_trans_pointer_assignment (code->expr, code->expr2);\n+  return gfc_trans_pointer_assignment (code->expr1, code->expr2);\n }\n \n \n@@ -4839,11 +4839,11 @@ gfc_trans_assignment (gfc_expr * expr1, gfc_expr * expr2, bool init_flag)\n tree\n gfc_trans_init_assign (gfc_code * code)\n {\n-  return gfc_trans_assignment (code->expr, code->expr2, true);\n+  return gfc_trans_assignment (code->expr1, code->expr2, true);\n }\n \n tree\n gfc_trans_assign (gfc_code * code)\n {\n-  return gfc_trans_assignment (code->expr, code->expr2, false);\n+  return gfc_trans_assignment (code->expr1, code->expr2, false);\n }"}, {"sha": "09f35b79c90641459562a7d9476d75b704310926", "filename": "gcc/fortran/trans-io.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a513927a5b0ea35945332ceaa78d4c1f0f74548d/gcc%2Ffortran%2Ftrans-io.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a513927a5b0ea35945332ceaa78d4c1f0f74548d/gcc%2Ffortran%2Ftrans-io.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-io.c?ref=a513927a5b0ea35945332ceaa78d4c1f0f74548d", "patch": "@@ -2149,7 +2149,7 @@ gfc_trans_transfer (gfc_code * code)\n   gfc_start_block (&block);\n   gfc_init_block (&body);\n \n-  expr = code->expr;\n+  expr = code->expr1;\n   ss = gfc_walk_expr (expr);\n \n   ref = NULL;\n@@ -2209,7 +2209,7 @@ gfc_trans_transfer (gfc_code * code)\n \n       /* Initialize the loop.  */\n       gfc_conv_ss_startstride (&loop);\n-      gfc_conv_loop_setup (&loop, &code->expr->where);\n+      gfc_conv_loop_setup (&loop, &code->expr1->where);\n \n       /* The main loop body.  */\n       gfc_mark_ss_chain_used (ss, 1);"}, {"sha": "88bfe3c4bf2f2f70a1a793a725f68db14ba94386", "filename": "gcc/fortran/trans-openmp.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a513927a5b0ea35945332ceaa78d4c1f0f74548d/gcc%2Ffortran%2Ftrans-openmp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a513927a5b0ea35945332ceaa78d4c1f0f74548d/gcc%2Ffortran%2Ftrans-openmp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-openmp.c?ref=a513927a5b0ea35945332ceaa78d4c1f0f74548d", "patch": "@@ -952,13 +952,13 @@ gfc_trans_omp_atomic (gfc_code *code)\n   code = code->block->next;\n   gcc_assert (code->op == EXEC_ASSIGN);\n   gcc_assert (code->next == NULL);\n-  var = code->expr->symtree->n.sym;\n+  var = code->expr1->symtree->n.sym;\n \n   gfc_init_se (&lse, NULL);\n   gfc_init_se (&rse, NULL);\n   gfc_start_block (&block);\n \n-  gfc_conv_expr (&lse, code->expr);\n+  gfc_conv_expr (&lse, code->expr1);\n   gfc_add_block_to_block (&block, &lse.pre);\n   type = TREE_TYPE (lse.expr);\n   lhsaddr = gfc_build_addr_expr (NULL, lse.expr);"}, {"sha": "1a1352de8ddf2a5ee47c84eaf3050db5e0434c7a", "filename": "gcc/fortran/trans-stmt.c", "status": "modified", "additions": 83, "deletions": 83, "changes": 166, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a513927a5b0ea35945332ceaa78d4c1f0f74548d/gcc%2Ffortran%2Ftrans-stmt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a513927a5b0ea35945332ceaa78d4c1f0f74548d/gcc%2Ffortran%2Ftrans-stmt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-stmt.c?ref=a513927a5b0ea35945332ceaa78d4c1f0f74548d", "patch": "@@ -104,7 +104,7 @@ gfc_trans_label_assign (gfc_code * code)\n   /* Start a new block.  */\n   gfc_init_se (&se, NULL);\n   gfc_start_block (&se.pre);\n-  gfc_conv_label_variable (&se, code->expr);\n+  gfc_conv_label_variable (&se, code->expr1);\n \n   len = GFC_DECL_STRING_LEN (se.expr);\n   addr = GFC_DECL_ASSIGN_ADDR (se.expr);\n@@ -150,7 +150,7 @@ gfc_trans_goto (gfc_code * code)\n   /* ASSIGNED GOTO.  */\n   gfc_init_se (&se, NULL);\n   gfc_start_block (&se.pre);\n-  gfc_conv_label_variable (&se, code->expr);\n+  gfc_conv_label_variable (&se, code->expr1);\n   tmp = GFC_DECL_STRING_LEN (se.expr);\n   tmp = fold_build2 (NE_EXPR, boolean_type_node, tmp,\n \t\t     build_int_cst (TREE_TYPE (tmp), -1));\n@@ -363,7 +363,7 @@ gfc_trans_call (gfc_code * code, bool dependency_check,\n       /* Translate the call.  */\n       has_alternate_specifier\n \t= gfc_conv_procedure_call (&se, code->resolved_sym, code->ext.actual,\n-\t\t\t\t  code->expr, NULL_TREE);\n+\t\t\t\t  code->expr1, NULL_TREE);\n \n       /* A subroutine without side-effect, by definition, does nothing!  */\n       TREE_SIDE_EFFECTS (se.expr) = 1;\n@@ -375,7 +375,7 @@ gfc_trans_call (gfc_code * code, bool dependency_check,\n \t  gfc_symbol *sym;\n \t  select_code = code->next;\n \t  gcc_assert(select_code->op == EXEC_SELECT);\n-\t  sym = select_code->expr->symtree->n.sym;\n+\t  sym = select_code->expr1->symtree->n.sym;\n \t  se.expr = convert (gfc_typenode_for_spec (&sym->ts), se.expr);\n \t  if (sym->backend_decl == NULL)\n \t    sym->backend_decl = gfc_get_symbol_decl (sym);\n@@ -411,7 +411,7 @@ gfc_trans_call (gfc_code * code, bool dependency_check,\n \t subscripts.  This could be prevented in the elemental case  \n \t as temporaries are handled separatedly \n \t (below in gfc_conv_elemental_dependencies).  */\n-      gfc_conv_loop_setup (&loop, &code->expr->where);\n+      gfc_conv_loop_setup (&loop, &code->expr1->where);\n       gfc_mark_ss_chain_used (ss, 1);\n \n       /* Convert the arguments, checking for dependencies.  */\n@@ -447,7 +447,7 @@ gfc_trans_call (gfc_code * code, bool dependency_check,\n \n       /* Add the subroutine call to the block.  */\n       gfc_conv_procedure_call (&loopse, code->resolved_sym,\n-\t\t\t       code->ext.actual, code->expr,\n+\t\t\t       code->ext.actual, code->expr1,\n \t\t\t       NULL_TREE);\n \n       if (mask && count1)\n@@ -483,7 +483,7 @@ gfc_trans_call (gfc_code * code, bool dependency_check,\n tree\n gfc_trans_return (gfc_code * code ATTRIBUTE_UNUSED)\n {\n-  if (code->expr)\n+  if (code->expr1)\n     {\n       gfc_se se;\n       tree tmp;\n@@ -497,15 +497,15 @@ gfc_trans_return (gfc_code * code ATTRIBUTE_UNUSED)\n       if (!result)\n         {\n           gfc_warning (\"An alternate return at %L without a * dummy argument\",\n-                        &code->expr->where);\n+                        &code->expr1->where);\n           return build1_v (GOTO_EXPR, gfc_get_return_label ());\n         }\n \n       /* Start a new block for this statement.  */\n       gfc_init_se (&se, NULL);\n       gfc_start_block (&se.pre);\n \n-      gfc_conv_expr (&se, code->expr);\n+      gfc_conv_expr (&se, code->expr1);\n \n       tmp = fold_build2 (MODIFY_EXPR, TREE_TYPE (result), result,\n \t\t\t fold_convert (TREE_TYPE (result), se.expr));\n@@ -536,14 +536,14 @@ gfc_trans_pause (gfc_code * code)\n   gfc_start_block (&se.pre);\n \n \n-  if (code->expr == NULL)\n+  if (code->expr1 == NULL)\n     {\n       tmp = build_int_cst (gfc_int4_type_node, code->ext.stop_code);\n       tmp = build_call_expr (gfor_fndecl_pause_numeric, 1, tmp);\n     }\n   else\n     {\n-      gfc_conv_expr_reference (&se, code->expr);\n+      gfc_conv_expr_reference (&se, code->expr1);\n       tmp = build_call_expr (gfor_fndecl_pause_string, 2,\n \t\t\t     se.expr, se.string_length);\n     }\n@@ -571,14 +571,14 @@ gfc_trans_stop (gfc_code * code)\n   gfc_start_block (&se.pre);\n \n \n-  if (code->expr == NULL)\n+  if (code->expr1 == NULL)\n     {\n       tmp = build_int_cst (gfc_int4_type_node, code->ext.stop_code);\n       tmp = build_call_expr (gfor_fndecl_stop_numeric, 1, tmp);\n     }\n   else\n     {\n-      gfc_conv_expr_reference (&se, code->expr);\n+      gfc_conv_expr_reference (&se, code->expr1);\n       tmp = build_call_expr (gfor_fndecl_stop_string, 2,\n \t\t\t     se.expr, se.string_length);\n     }\n@@ -638,15 +638,15 @@ gfc_trans_if_1 (gfc_code * code)\n   tree stmt, elsestmt;\n \n   /* Check for an unconditional ELSE clause.  */\n-  if (!code->expr)\n+  if (!code->expr1)\n     return gfc_trans_code (code->next);\n \n   /* Initialize a statement builder for each block. Puts in NULL_TREEs.  */\n   gfc_init_se (&if_se, NULL);\n   gfc_start_block (&if_se.pre);\n \n   /* Calculate the IF condition expression.  */\n-  gfc_conv_expr_val (&if_se, code->expr);\n+  gfc_conv_expr_val (&if_se, code->expr1);\n \n   /* Translate the THEN clause.  */\n   stmt = gfc_trans_code (code->next);\n@@ -713,7 +713,7 @@ gfc_trans_arithmetic_if (gfc_code * code)\n   gfc_start_block (&se.pre);\n \n   /* Pre-evaluate COND.  */\n-  gfc_conv_expr_val (&se, code->expr);\n+  gfc_conv_expr_val (&se, code->expr1);\n   se.expr = gfc_evaluate_now (se.expr, &se.pre);\n \n   /* Build something to compare with.  */\n@@ -1160,7 +1160,7 @@ gfc_trans_do_while (gfc_code * code)\n \n   /* Create a GIMPLE version of the exit condition.  */\n   gfc_init_se (&cond, NULL);\n-  gfc_conv_expr_val (&cond, code->expr);\n+  gfc_conv_expr_val (&cond, code->expr1);\n   gfc_add_block_to_block (&block, &cond.pre);\n   cond.expr = fold_build1 (TRUTH_NOT_EXPR, boolean_type_node, cond.expr);\n \n@@ -1258,7 +1258,7 @@ gfc_trans_integer_select (gfc_code * code)\n \n   /* Calculate the switch expression.  */\n   gfc_init_se (&se, NULL);\n-  gfc_conv_expr_val (&se, code->expr);\n+  gfc_conv_expr_val (&se, code->expr1);\n   gfc_add_block_to_block (&block, &se.pre);\n \n   end_label = gfc_build_label_decl (NULL_TREE);\n@@ -1399,7 +1399,7 @@ gfc_trans_logical_select (gfc_code * code)\n   /* Calculate the switch expression.  We always need to do this\n      because it may have side effects.  */\n   gfc_init_se (&se, NULL);\n-  gfc_conv_expr_val (&se, code->expr);\n+  gfc_conv_expr_val (&se, code->expr1);\n   gfc_add_block_to_block (&block, &se.pre);\n \n   if (t == f && t != NULL)\n@@ -1472,11 +1472,11 @@ gfc_trans_character_select (gfc_code *code)\n   static tree ss_string2[2], ss_string2_len[2];\n   static tree ss_target[2];\n \n-  tree pchartype = gfc_get_pchar_type (code->expr->ts.kind);\n+  tree pchartype = gfc_get_pchar_type (code->expr1->ts.kind);\n \n-  if (code->expr->ts.kind == 1)\n+  if (code->expr1->ts.kind == 1)\n     k = 0;\n-  else if (code->expr->ts.kind == 4)\n+  else if (code->expr1->ts.kind == 4)\n     k = 1;\n   else\n     gcc_unreachable ();\n@@ -1485,9 +1485,9 @@ gfc_trans_character_select (gfc_code *code)\n     {\n       select_struct[k] = make_node (RECORD_TYPE);\n \n-      if (code->expr->ts.kind == 1)\n+      if (code->expr1->ts.kind == 1)\n \tTYPE_NAME (select_struct[k]) = get_identifier (\"_jump_struct_char1\");\n-      else if (code->expr->ts.kind == 4)\n+      else if (code->expr1->ts.kind == 4)\n \tTYPE_NAME (select_struct[k]) = get_identifier (\"_jump_struct_char4\");\n       else\n \tgcc_unreachable ();\n@@ -1603,13 +1603,13 @@ gfc_trans_character_select (gfc_code *code)\n   init = gfc_build_addr_expr (pvoid_type_node, init);\n \n   gfc_init_se (&se, NULL);\n-  gfc_conv_expr_reference (&se, code->expr);\n+  gfc_conv_expr_reference (&se, code->expr1);\n \n   gfc_add_block_to_block (&block, &se.pre);\n \n-  if (code->expr->ts.kind == 1)\n+  if (code->expr1->ts.kind == 1)\n     fndecl = gfor_fndecl_select_string;\n-  else if (code->expr->ts.kind == 4)\n+  else if (code->expr1->ts.kind == 4)\n     fndecl = gfor_fndecl_select_string_char4;\n   else\n     gcc_unreachable ();\n@@ -1649,14 +1649,14 @@ gfc_trans_character_select (gfc_code *code)\n tree\n gfc_trans_select (gfc_code * code)\n {\n-  gcc_assert (code && code->expr);\n+  gcc_assert (code && code->expr1);\n \n   /* Empty SELECT constructs are legal.  */\n   if (code->block == NULL)\n     return build_empty_stmt ();\n \n   /* Select the correct translation function.  */\n-  switch (code->expr->ts.type)\n+  switch (code->expr1->ts.type)\n     {\n     case BT_LOGICAL:\treturn gfc_trans_logical_select (code);\n     case BT_INTEGER:\treturn gfc_trans_integer_select (code);\n@@ -1732,7 +1732,7 @@ forall_make_variable_temp (gfc_code *c, stmtblock_t *pre, stmtblock_t *post)\n   tree tmp;\n \n   /* Build a copy of the lvalue.  */\n-  old_symtree = c->expr->symtree;\n+  old_symtree = c->expr1->symtree;\n   old_sym = old_symtree->n.sym;\n   e = gfc_lval_expr_from_sym (old_sym);\n   if (old_sym->attr.dimension)\n@@ -1797,7 +1797,7 @@ forall_make_variable_temp (gfc_code *c, stmtblock_t *pre, stmtblock_t *post)\n \n   /* Go through the expression reference replacing the old_symtree\n      with the new.  */\n-  forall_replace_symtree (c->expr, old_sym, 2);\n+  forall_replace_symtree (c->expr1, old_sym, 2);\n \n   /* Now we have made this temporary, we might as well use it for\n   the right hand side.  */\n@@ -1814,8 +1814,8 @@ check_forall_dependencies (gfc_code *c, stmtblock_t *pre, stmtblock_t *post)\n   int need_temp;\n   gfc_symbol *lsym;\n \n-  lsym = c->expr->symtree->n.sym;\n-  need_temp = gfc_check_dependency (c->expr, c->expr2, 0);\n+  lsym = c->expr1->symtree->n.sym;\n+  need_temp = gfc_check_dependency (c->expr1, c->expr2, 0);\n \n   /* Now check for dependencies within the 'variable'\n      expression itself.  These are treated by making a complete\n@@ -1829,20 +1829,20 @@ check_forall_dependencies (gfc_code *c, stmtblock_t *pre, stmtblock_t *post)\n     return need_temp;\n \n   new_symtree = NULL;\n-  if (find_forall_index (c->expr, lsym, 2) == SUCCESS)\n+  if (find_forall_index (c->expr1, lsym, 2) == SUCCESS)\n     {\n       forall_make_variable_temp (c, pre, post);\n       need_temp = 0;\n     }\n \n   /* Substrings with dependencies are treated in the same\n      way.  */\n-  if (c->expr->ts.type == BT_CHARACTER\n-\t&& c->expr->ref\n+  if (c->expr1->ts.type == BT_CHARACTER\n+\t&& c->expr1->ref\n \t&& c->expr2->expr_type == EXPR_VARIABLE\n \t&& lsym == c->expr2->symtree->n.sym)\n     {\n-      for (lref = c->expr->ref; lref; lref = lref->next)\n+      for (lref = c->expr1->ref; lref; lref = lref->next)\n \tif (lref->type == REF_SUBSTRING)\n \t  break;\n       for (rref = c->expr2->ref; rref; rref = rref->next)\n@@ -1863,7 +1863,7 @@ check_forall_dependencies (gfc_code *c, stmtblock_t *pre, stmtblock_t *post)\n static void\n cleanup_forall_symtrees (gfc_code *c)\n {\n-  forall_restore_symtree (c->expr);\n+  forall_restore_symtree (c->expr1);\n   forall_restore_symtree (c->expr2);\n   gfc_free (new_symtree->n.sym);\n   gfc_free (new_symtree);\n@@ -2813,9 +2813,9 @@ gfc_trans_forall_1 (gfc_code * code, forall_info * nested_forall_info)\n   bool need_mask;\n \n   /* Do nothing if the mask is false.  */\n-  if (code->expr\n-      && code->expr->expr_type == EXPR_CONSTANT\n-      && !code->expr->value.logical)\n+  if (code->expr1\n+      && code->expr1->expr_type == EXPR_CONSTANT\n+      && !code->expr1->value.logical)\n     return build_empty_stmt ();\n \n   n = 0;\n@@ -2918,11 +2918,11 @@ gfc_trans_forall_1 (gfc_code * code, forall_info * nested_forall_info)\n   info->nvar = nvar;\n   info->size = size;\n \n-  if (code->expr)\n+  if (code->expr1)\n     {\n       /* If the mask is .true., consider the FORALL unconditional.  */\n-      if (code->expr->expr_type == EXPR_CONSTANT\n-\t  && code->expr->value.logical)\n+      if (code->expr1->expr_type == EXPR_CONSTANT\n+\t  && code->expr1->value.logical)\n \tneed_mask = false;\n       else\n \tneed_mask = true;\n@@ -2968,7 +2968,7 @@ gfc_trans_forall_1 (gfc_code * code, forall_info * nested_forall_info)\n \n       /* Evaluate the mask expression.  */\n       gfc_init_se (&se, NULL);\n-      gfc_conv_expr_val (&se, code->expr);\n+      gfc_conv_expr_val (&se, code->expr1);\n       gfc_add_block_to_block (&body, &se.pre);\n \n       /* Store the mask.  */\n@@ -3005,12 +3005,12 @@ gfc_trans_forall_1 (gfc_code * code, forall_info * nested_forall_info)\n           /* Temporaries due to array assignment data dependencies introduce\n              no end of problems.  */\n \t  if (need_temp)\n-            gfc_trans_assign_need_temp (c->expr, c->expr2, NULL, false,\n+            gfc_trans_assign_need_temp (c->expr1, c->expr2, NULL, false,\n                                         nested_forall_info, &block);\n           else\n             {\n               /* Use the normal assignment copying routines.  */\n-              assign = gfc_trans_assignment (c->expr, c->expr2, false);\n+              assign = gfc_trans_assignment (c->expr1, c->expr2, false);\n \n               /* Generate body and loops.  */\n               tmp = gfc_trans_nested_forall_loop (nested_forall_info,\n@@ -3032,14 +3032,14 @@ gfc_trans_forall_1 (gfc_code * code, forall_info * nested_forall_info)\n \n         /* Pointer assignment inside FORALL.  */\n \tcase EXEC_POINTER_ASSIGN:\n-          need_temp = gfc_check_dependency (c->expr, c->expr2, 0);\n+          need_temp = gfc_check_dependency (c->expr1, c->expr2, 0);\n           if (need_temp)\n-            gfc_trans_pointer_assign_need_temp (c->expr, c->expr2,\n+            gfc_trans_pointer_assign_need_temp (c->expr1, c->expr2,\n                                                 nested_forall_info, &block);\n           else\n             {\n               /* Use the normal assignment copying routines.  */\n-              assign = gfc_trans_pointer_assignment (c->expr, c->expr2);\n+              assign = gfc_trans_pointer_assignment (c->expr1, c->expr2);\n \n               /* Generate body and loops.  */\n               tmp = gfc_trans_nested_forall_loop (nested_forall_info,\n@@ -3519,7 +3519,7 @@ gfc_trans_where_2 (gfc_code * code, tree mask, bool invert,\n   /* Two clauses, the first empty, the second non-empty.  */\n   else if (mask)\n     {\n-      need_cmask = (cblock->block->expr != 0);\n+      need_cmask = (cblock->block->expr1 != 0);\n       need_pmask = true;\n     }\n   else\n@@ -3532,7 +3532,7 @@ gfc_trans_where_2 (gfc_code * code, tree mask, bool invert,\n     {\n       /* Calculate the size of temporary needed by the mask-expr.  */\n       gfc_init_block (&inner_size_body);\n-      inner_size = compute_inner_temp_size (cblock->expr, cblock->expr,\n+      inner_size = compute_inner_temp_size (cblock->expr1, cblock->expr1,\n \t\t\t\t\t    &inner_size_body, &lss, &rss);\n \n       /* Calculate the total size of temporary needed.  */\n@@ -3564,21 +3564,21 @@ gfc_trans_where_2 (gfc_code * code, tree mask, bool invert,\n \t bottom of the loop.  */\n \n       /* Has mask-expr.  */\n-      if (cblock->expr)\n+      if (cblock->expr1)\n         {\n           /* Ensure that the WHERE mask will be evaluated exactly once.\n \t     If there are no statements in this WHERE/ELSEWHERE clause,\n \t     then we don't need to update the control mask (cmask).\n \t     If this is the last clause of the WHERE construct, then\n \t     we don't need to update the pending control mask (pmask).  */\n \t  if (mask)\n-\t    gfc_evaluate_where_mask (cblock->expr, nested_forall_info,\n+\t    gfc_evaluate_where_mask (cblock->expr1, nested_forall_info,\n \t\t\t\t     mask, invert,\n \t\t\t\t     cblock->next  ? cmask : NULL_TREE,\n \t\t\t\t     cblock->block ? pmask : NULL_TREE,\n \t\t\t\t     mask_type, block);\n \t  else\n-\t    gfc_evaluate_where_mask (cblock->expr, nested_forall_info,\n+\t    gfc_evaluate_where_mask (cblock->expr1, nested_forall_info,\n \t\t\t\t     NULL_TREE, false,\n \t\t\t\t     (cblock->next || cblock->block)\n \t\t\t\t     ? cmask : NULL_TREE,\n@@ -3617,7 +3617,7 @@ gfc_trans_where_2 (gfc_code * code, tree mask, bool invert,\n \t      goto evaluate;\n \n             case EXEC_ASSIGN:\n-              expr1 = cnext->expr;\n+              expr1 = cnext->expr1;\n               expr2 = cnext->expr2;\n     evaluate:\n               if (nested_forall_info != NULL)\n@@ -3729,10 +3729,10 @@ gfc_trans_where_3 (gfc_code * cblock, gfc_code * eblock)\n   if (ompws_flags & OMPWS_WORKSHARE_FLAG)\n     ompws_flags |= OMPWS_SCALARIZER_WS;\n \n-  cond = cblock->expr;\n-  tdst = cblock->next->expr;\n+  cond = cblock->expr1;\n+  tdst = cblock->next->expr1;\n   tsrc = cblock->next->expr2;\n-  edst = eblock ? eblock->next->expr : NULL;\n+  edst = eblock ? eblock->next->expr1 : NULL;\n   esrc = eblock ? eblock->next->expr2 : NULL;\n \n   gfc_start_block (&block);\n@@ -3868,13 +3868,13 @@ gfc_trans_where (gfc_code * code)\n           /* A simple \"WHERE (cond) x = y\" statement or block is\n \t     dependence free if cond is not dependent upon writing x,\n \t     and the source y is unaffected by the destination x.  */\n-\t  if (!gfc_check_dependency (cblock->next->expr,\n-\t\t\t\t     cblock->expr, 0)\n-\t      && !gfc_check_dependency (cblock->next->expr,\n+\t  if (!gfc_check_dependency (cblock->next->expr1,\n+\t\t\t\t     cblock->expr1, 0)\n+\t      && !gfc_check_dependency (cblock->next->expr1,\n \t\t\t\t\tcblock->next->expr2, 0))\n \t    return gfc_trans_where_3 (cblock, NULL);\n \t}\n-      else if (!eblock->expr\n+      else if (!eblock->expr1\n \t       && !eblock->block\n \t       && eblock->next\n \t       && eblock->next->op == EXEC_ASSIGN\n@@ -3890,22 +3890,22 @@ gfc_trans_where (gfc_code * code)\n \t     are the same.  In short, this is VERY conservative and this\n \t     is needed because the two loops, required by the standard\n \t     are coalesced in gfc_trans_where_3.  */\n-\t  if (!gfc_check_dependency(cblock->next->expr,\n-\t\t\t\t    cblock->expr, 0)\n-\t      && !gfc_check_dependency(eblock->next->expr,\n-\t\t\t\t       cblock->expr, 0)\n-\t      && !gfc_check_dependency(cblock->next->expr,\n+\t  if (!gfc_check_dependency(cblock->next->expr1,\n+\t\t\t\t    cblock->expr1, 0)\n+\t      && !gfc_check_dependency(eblock->next->expr1,\n+\t\t\t\t       cblock->expr1, 0)\n+\t      && !gfc_check_dependency(cblock->next->expr1,\n \t\t\t\t       eblock->next->expr2, 1)\n-\t      && !gfc_check_dependency(eblock->next->expr,\n+\t      && !gfc_check_dependency(eblock->next->expr1,\n \t\t\t\t       cblock->next->expr2, 1)\n-\t      && !gfc_check_dependency(cblock->next->expr,\n+\t      && !gfc_check_dependency(cblock->next->expr1,\n \t\t\t\t       cblock->next->expr2, 1)\n-\t      && !gfc_check_dependency(eblock->next->expr,\n+\t      && !gfc_check_dependency(eblock->next->expr1,\n \t\t\t\t       eblock->next->expr2, 1)\n-\t      && !gfc_check_dependency(cblock->next->expr,\n-\t\t\t\t       eblock->next->expr, 0)\n-\t      && !gfc_check_dependency(eblock->next->expr,\n-\t\t\t\t       cblock->next->expr, 0))\n+\t      && !gfc_check_dependency(cblock->next->expr1,\n+\t\t\t\t       eblock->next->expr1, 0)\n+\t      && !gfc_check_dependency(eblock->next->expr1,\n+\t\t\t\t       cblock->next->expr1, 0))\n \t    return gfc_trans_where_3 (cblock, eblock);\n \t}\n     }\n@@ -3971,7 +3971,7 @@ gfc_trans_allocate (gfc_code * code)\n   gfc_start_block (&block);\n \n   /* Either STAT= and/or ERRMSG is present.  */\n-  if (code->expr || code->expr2)\n+  if (code->expr1 || code->expr2)\n     {\n       tree gfc_int4_type_node = gfc_get_int_type (4);\n \n@@ -4006,7 +4006,7 @@ gfc_trans_allocate (gfc_code * code)\n \t\t\t     fold_convert (TREE_TYPE (se.expr), tmp));\n \t  gfc_add_expr_to_block (&se.pre, tmp);\n \n-\t  if (code->expr || code->expr2)\n+\t  if (code->expr1 || code->expr2)\n \t    {\n \t      tmp = build1_v (GOTO_EXPR, error_label);\n \t      parm = fold_build2 (NE_EXPR, boolean_type_node,\n@@ -4030,13 +4030,13 @@ gfc_trans_allocate (gfc_code * code)\n     }\n \n   /* STAT block.  */\n-  if (code->expr)\n+  if (code->expr1)\n     {\n       tmp = build1_v (LABEL_EXPR, error_label);\n       gfc_add_expr_to_block (&block, tmp);\n \n       gfc_init_se (&se, NULL);\n-      gfc_conv_expr_lhs (&se, code->expr);\n+      gfc_conv_expr_lhs (&se, code->expr1);\n       tmp = convert (TREE_TYPE (se.expr), stat);\n       gfc_add_modify (&block, se.expr, tmp);\n     }\n@@ -4094,7 +4094,7 @@ gfc_trans_deallocate (gfc_code *code)\n   /* Count the number of failed deallocations.  If deallocate() was\n      called with STAT= , then set STAT to the count.  If deallocate\n      was called with ERRMSG, then set ERRMG to a string.  */\n-  if (code->expr || code->expr2)\n+  if (code->expr1 || code->expr2)\n     {\n       tree gfc_int4_type_node = gfc_get_int_type (4);\n \n@@ -4155,7 +4155,7 @@ gfc_trans_deallocate (gfc_code *code)\n \n       /* Keep track of the number of failed deallocations by adding stat\n \t of the last deallocation to the running total.  */\n-      if (code->expr || code->expr2)\n+      if (code->expr1 || code->expr2)\n \t{\n \t  apstat = fold_build2 (PLUS_EXPR, TREE_TYPE (stat), astat, stat);\n \t  gfc_add_modify (&se.pre, astat, apstat);\n@@ -4167,10 +4167,10 @@ gfc_trans_deallocate (gfc_code *code)\n     }\n \n   /* Set STAT.  */\n-  if (code->expr)\n+  if (code->expr1)\n     {\n       gfc_init_se (&se, NULL);\n-      gfc_conv_expr_lhs (&se, code->expr);\n+      gfc_conv_expr_lhs (&se, code->expr1);\n       tmp = convert (TREE_TYPE (se.expr), astat);\n       gfc_add_modify (&block, se.expr, tmp);\n     }"}]}