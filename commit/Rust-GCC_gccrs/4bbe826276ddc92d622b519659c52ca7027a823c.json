{"sha": "4bbe826276ddc92d622b519659c52ca7027a823c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NGJiZTgyNjI3NmRkYzkyZDYyMmI1MTk2NTljNTJjYTcwMjdhODIzYw==", "commit": {"author": {"name": "Ira Rosen", "email": "irar@il.ibm.com", "date": "2009-07-20T11:59:10Z"}, "committer": {"name": "Ira Rosen", "email": "irar@gcc.gnu.org", "date": "2009-07-20T11:59:10Z"}, "message": "tree-vectorizer.h (vectorizable_condition): Add parameters.\n\n\n\t* tree-vectorizer.h (vectorizable_condition): Add parameters.\n\t* tree-vect-loop.c (vect_is_simple_reduction): Support COND_EXPR.\n\t(get_initial_def_for_reduction): Likewise.\n\t(vectorizable_reduction): Skip the check of first operand in case\n\tof COND_EXPR. Add check that it is outer loop vectorization if\n\tnested cycle was detected. Call vectorizable_condition() for \n\tCOND_EXPR. If reduction epilogue cannot be created do not fail for\n\tnested cycles (if it is not double reduction). Assert that there\n\tis only one type in the loop in case of COND_EXPR. Call\n\tvectorizable_condition() to vectorize COND_EXPR.\n\t* tree-vect-stmts.c (vectorizable_condition): Update comment.\n\tAdd parameters. Allow nested cycles if called from \n\tvectorizable_reduction(). Use reduction vector variable if provided.\n\t(vect_analyze_stmt): Call vectorizable_reduction() before\n\tvectorizable_condition().\n\t(vect_transform_stmt): Update call to vectorizable_condition().\n\nFrom-SVN: r149806", "tree": {"sha": "b5c54f986ec049e40252b92d71e7729a749daaa7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b5c54f986ec049e40252b92d71e7729a749daaa7"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/4bbe826276ddc92d622b519659c52ca7027a823c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4bbe826276ddc92d622b519659c52ca7027a823c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4bbe826276ddc92d622b519659c52ca7027a823c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4bbe826276ddc92d622b519659c52ca7027a823c/comments", "author": {"login": "irar2", "id": 16818592, "node_id": "MDQ6VXNlcjE2ODE4NTky", "avatar_url": "https://avatars.githubusercontent.com/u/16818592?v=4", "gravatar_id": "", "url": "https://api.github.com/users/irar2", "html_url": "https://github.com/irar2", "followers_url": "https://api.github.com/users/irar2/followers", "following_url": "https://api.github.com/users/irar2/following{/other_user}", "gists_url": "https://api.github.com/users/irar2/gists{/gist_id}", "starred_url": "https://api.github.com/users/irar2/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/irar2/subscriptions", "organizations_url": "https://api.github.com/users/irar2/orgs", "repos_url": "https://api.github.com/users/irar2/repos", "events_url": "https://api.github.com/users/irar2/events{/privacy}", "received_events_url": "https://api.github.com/users/irar2/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "9e7c935a29fe3d44f60a40960ee4791aab285423", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9e7c935a29fe3d44f60a40960ee4791aab285423", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9e7c935a29fe3d44f60a40960ee4791aab285423"}], "stats": {"total": 704, "additions": 598, "deletions": 106}, "files": [{"sha": "7e349d5f2021cf88a18210fbe99217f14839cbec", "filename": "gcc/ChangeLog", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4bbe826276ddc92d622b519659c52ca7027a823c/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4bbe826276ddc92d622b519659c52ca7027a823c/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=4bbe826276ddc92d622b519659c52ca7027a823c", "patch": "@@ -1,3 +1,22 @@\n+2009-07-20  Ira Rosen  <irar@il.ibm.com>\n+\n+\t* tree-vectorizer.h (vectorizable_condition): Add parameters.\n+\t* tree-vect-loop.c (vect_is_simple_reduction): Support COND_EXPR.\n+\t(get_initial_def_for_reduction): Likewise.\n+\t(vectorizable_reduction): Skip the check of first operand in case\n+\tof COND_EXPR. Add check that it is outer loop vectorization if\n+\tnested cycle was detected. Call vectorizable_condition() for \n+\tCOND_EXPR. If reduction epilogue cannot be created do not fail for\n+\tnested cycles (if it is not double reduction). Assert that there\n+\tis only one type in the loop in case of COND_EXPR. Call\n+\tvectorizable_condition() to vectorize COND_EXPR.\n+\t* tree-vect-stmts.c (vectorizable_condition): Update comment.\n+\tAdd parameters. Allow nested cycles if called from \n+\tvectorizable_reduction(). Use reduction vector variable if provided.\n+\t(vect_analyze_stmt): Call vectorizable_reduction() before\n+\tvectorizable_condition().\n+\t(vect_transform_stmt): Update call to vectorizable_condition().\n+\n 2009-07-20  Christian Bruel  <christian.bruel@st.com>\n \t\n \t* config/sh/sh.opt (-mfmovd): Resurrect and document."}, {"sha": "daac3e82e4e90fb2d104e1bf961525a43d2671f5", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4bbe826276ddc92d622b519659c52ca7027a823c/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4bbe826276ddc92d622b519659c52ca7027a823c/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=4bbe826276ddc92d622b519659c52ca7027a823c", "patch": "@@ -1,3 +1,9 @@\n+2009-07-20  Ira Rosen  <irar@il.ibm.com>\n+\n+\t* gcc.dg/vect/vect-cond-1.c, gcc.dg/vect/vect-cond-2.c,\n+\tgcc.dg/vect/vect-cond-3.c, gcc.dg/vect/vect-cond-4.c,\n+\tgcc.dg/vect/vect-cond-5.c, gcc.dg/vect/vect-cond-6.c: New tests.\n+\n 2009-07-20  Christian Bruel  <christian.bruel@st.com>\n \t\n \t* gcc.target/sh/mfmovd.c: New test."}, {"sha": "4ee67132a82f3991b477e476c70de0b83b9b0e96", "filename": "gcc/testsuite/gcc.dg/vect/vect-cond-1.c", "status": "added", "additions": 58, "deletions": 0, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4bbe826276ddc92d622b519659c52ca7027a823c/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-cond-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4bbe826276ddc92d622b519659c52ca7027a823c/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-cond-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-cond-1.c?ref=4bbe826276ddc92d622b519659c52ca7027a823c", "patch": "@@ -0,0 +1,58 @@\n+/* { dg-require-effective-target vect_condition } */\n+\n+#include <stdlib.h> \n+#include <stdio.h> \n+#include \"tree-vect.h\"\n+\n+#define M 32\n+#define N 16\n+\n+int x_in[M];\n+int x_out[M];\n+int c[N] = {3,2,1,10,1,42,3,4,50,9,32,8,11,10,1,2};\n+int a[N+1] = {0,16,32,48,64,128,256,512,0,16,32,48,64,128,256,512,1024};\n+int check_result[M] = {1024,1024,1024,256,256,256,256,256,256,256,256,128,48,48,48,48,48,48,48,48,48,48,48,48,48,48,48,48,48,48,48,48};\n+\n+__attribute__ ((noinline)) void \n+foo ()\n+{\n+  int j, i, x;\n+  int curr_a, next_a;\n+\n+  for (j = 0; j < M; j++) \n+    {\n+      x = x_in[j];\n+      curr_a = a[0];\n+\n+      for (i = 0; i < N; i++) \n+        {\n+          next_a = a[i+1];\n+          curr_a = x > c[i] ? curr_a : next_a;\n+        }\n+\n+      x_out[j] = curr_a;\n+    }\n+}\n+\n+int main (void)\n+{\n+  int i,j;\n+\n+  check_vect ();\n+\n+  for (j = 0; j < M; j++) \n+    x_in[j] = j;\n+\n+  foo ();\n+\n+  for (j = 0; j < M; j++)\n+    if (x_out[j] != check_result[j])\n+      abort ();\n+\n+  return 0;\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"OUTER LOOP VECTORIZED\" 1 \"vect\" { xfail vect_no_align } } } */\n+/* { dg-final { cleanup-tree-dump \"vect\" } } */\n+\n+"}, {"sha": "c4dc5abaabc3fadd85d32b50a5ea9b33c38dfc85", "filename": "gcc/testsuite/gcc.dg/vect/vect-cond-2.c", "status": "added", "additions": 49, "deletions": 0, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4bbe826276ddc92d622b519659c52ca7027a823c/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-cond-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4bbe826276ddc92d622b519659c52ca7027a823c/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-cond-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-cond-2.c?ref=4bbe826276ddc92d622b519659c52ca7027a823c", "patch": "@@ -0,0 +1,49 @@\n+/* { dg-require-effective-target vect_condition } */\n+\n+#include <stdlib.h> \n+#include <stdio.h> \n+#include \"tree-vect.h\"\n+\n+#define N 16\n+\n+int c[N] = {3,2,1,10,1,42,3,4,50,9,32,8,11,10,1,2};\n+int a[N+1] = {0,16,32,48,64,128,256,512,0,16,32,48,64,128,256,512,1024};\n+\n+__attribute__ ((noinline)) void \n+foo (int *x)\n+{\n+  int i;\n+  int curr_a, flag, next_a;\n+\n+  curr_a = a[0];\n+\n+  for (i = 0; i < N; i++) \n+    {\n+      flag = *x > c[i];\n+      next_a = a[i+1];\n+      curr_a = flag ? curr_a : next_a;\n+    }\n+\n+  *x = curr_a;\n+}\n+\n+int main (void)\n+{\n+  int x = 7;\n+\n+  check_vect ();\n+\n+  foo (&x);\n+\n+  if (x != 256)\n+    abort ();\n+\n+  return 0;\n+}\n+\n+/* The order of computation should not be changed for cond_expr, therefore, \n+   it cannot be vectorized in reduction.  */\n+/* { dg-final { scan-tree-dump-times \"vectorized 1 loops\" 1 \"vect\" { xfail *-*-* } } } */\n+/* { dg-final { cleanup-tree-dump \"vect\" } } */\n+\n+"}, {"sha": "56cfbb2e068f9b23cb2b82f9382002ddbab0a6c2", "filename": "gcc/testsuite/gcc.dg/vect/vect-cond-3.c", "status": "added", "additions": 66, "deletions": 0, "changes": 66, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4bbe826276ddc92d622b519659c52ca7027a823c/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-cond-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4bbe826276ddc92d622b519659c52ca7027a823c/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-cond-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-cond-3.c?ref=4bbe826276ddc92d622b519659c52ca7027a823c", "patch": "@@ -0,0 +1,66 @@\n+/* { dg-require-effective-target vect_condition } */\n+\n+#include <stdlib.h> \n+#include <stdio.h> \n+#include \"tree-vect.h\"\n+\n+#define M 32\n+#define N 16\n+\n+int x_in[M];\n+int x_out_a[M], x_out_b[M];\n+int c[N] = {3,2,1,10,1,42,3,4,50,9,32,8,11,10,1,2};\n+int a[N+1] = {0,16,32,48,64,128,256,512,0,16,32,48,64,128,256,512,1024};\n+int b[N+1] = {17,16,15,14,13,12,11,10,9,8,7,6,5,4,3,2,1};\n+int check_result_a[M] = {1024,1024,1024,256,256,256,256,256,256,256,256,128,48,48,48,48,48,48,48,48,48,48,48,48,48,48,48,48,48,48,48,48};\n+int check_result_b[M] = {17,17,2,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1};\n+\n+__attribute__ ((noinline)) void \n+foo ()\n+{\n+  int j, i, x;\n+  int curr_a, flag, next_a, curr_b, next_b;\n+\n+  for (j = 0; j < M; j++) \n+    {\n+      x = x_in[j];\n+      curr_a = a[0];\n+      curr_b = b[0];\n+\n+      for (i = 0; i < N; i++) \n+        {\n+          flag = x > c[i];\n+          next_a = a[i+1];\n+          next_b = b[i+1];\n+          curr_a = flag ? curr_a : next_a;\n+          curr_b = flag ? next_b : curr_b;\n+        }\n+\n+      x_out_a[j] = curr_a;\n+      x_out_b[j] = curr_b;\n+    }\n+}\n+\n+int main (void)\n+{\n+  int i,j;\n+\n+  check_vect ();\n+\n+  for (j = 0; j < M; j++) \n+    x_in[j] = j;\n+\n+  foo ();\n+\n+  for (j = 0; j < M; j++)\n+    if (x_out_a[j] != check_result_a[j]\n+        || x_out_b[j] != check_result_b[j])\n+      abort ();\n+\n+  return 0;\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"OUTER LOOP VECTORIZED\" 1 \"vect\" { xfail vect_no_align } } } */\n+/* { dg-final { cleanup-tree-dump \"vect\" } } */\n+\n+"}, {"sha": "c3a1585839c4ef436cf459c4a0c30fedca3b4573", "filename": "gcc/testsuite/gcc.dg/vect/vect-cond-4.c", "status": "added", "additions": 63, "deletions": 0, "changes": 63, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4bbe826276ddc92d622b519659c52ca7027a823c/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-cond-4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4bbe826276ddc92d622b519659c52ca7027a823c/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-cond-4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-cond-4.c?ref=4bbe826276ddc92d622b519659c52ca7027a823c", "patch": "@@ -0,0 +1,63 @@\n+/* { dg-require-effective-target vect_condition } */\n+\n+#include <stdlib.h> \n+#include <stdio.h> \n+#include \"tree-vect.h\"\n+\n+#define M 32\n+#define N 16\n+\n+int x_in[M];\n+int x_out_a[M], x_out_b[M];\n+int c[N] = {3,2,1,10,1,42,3,4,50,9,32,8,11,10,1,2};\n+int a[N+1] = {0,16,32,48,64,128,256,512,0,16,32,48,64,128,256,512,1024};\n+int b[N+1] = {17,16,15,14,13,12,11,10,9,8,7,6,5,4,3,2,1};\n+int check_result_a[M] = {1024,1024,1024,256,256,256,256,256,256,256,256,128,48,48,48,48,48,48,48,48,48,48,48,48,48,48,48,48,48,48,48,48};\n+int check_result_b[M] = {17,17,2,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1};\n+\n+__attribute__ ((noinline)) void \n+foo (int z)\n+{\n+  int j, i, x;\n+  int curr_a, flag, next_a, curr_b, next_b;\n+\n+  for (j = 0; j < M; j++) \n+    {\n+      x = x_in[j];\n+      curr_a = a[0];\n+      curr_b = b[0];\n+\n+      for (i = 0; i < N; i++) \n+        {\n+          curr_a = x > c[i] ? curr_a : z;\n+          curr_b = x > c[i] ? next_b : 5;\n+        }\n+\n+      x_out_a[j] = curr_a;\n+      x_out_b[j] = curr_b;\n+    }\n+}\n+\n+int main (void)\n+{\n+  int i,j;\n+\n+  check_vect ();\n+\n+  for (j = 0; j < M; j++) \n+    x_in[j] = j;\n+\n+  foo (125);\n+\n+  for (j = 0; j < M; j++)\n+    if (x_out_a[j] != 125\n+        || x_out_b[j] != 5)\n+      abort ();\n+\n+  return 0;\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"OUTER LOOP VECTORIZED\" 1 \"vect\" { xfail vect_no_align } } } */\n+/* { dg-final { cleanup-tree-dump \"vect\" } } */\n+\n+"}, {"sha": "0996a92d18d6cc87c19979548aec231f772eb2d8", "filename": "gcc/testsuite/gcc.dg/vect/vect-cond-5.c", "status": "added", "additions": 62, "deletions": 0, "changes": 62, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4bbe826276ddc92d622b519659c52ca7027a823c/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-cond-5.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4bbe826276ddc92d622b519659c52ca7027a823c/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-cond-5.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-cond-5.c?ref=4bbe826276ddc92d622b519659c52ca7027a823c", "patch": "@@ -0,0 +1,62 @@\n+/* { dg-require-effective-target vect_condition } */\n+\n+#include <stdarg.h>\n+#include <stdio.h>\n+#include \"tree-vect.h\"\n+\n+#define K 32\n+\n+int cond_array[2*K][K] __attribute__ ((__aligned__(__BIGGEST_ALIGNMENT__)));\n+int a[K][K] __attribute__ ((__aligned__(__BIGGEST_ALIGNMENT__)));\n+int out[K];\n+int check_result[K] = {2,2,2,2,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0};\n+\n+__attribute__ ((noinline)) void \n+foo (int c)\n+{\n+  int res, i, j, k, next;\n+\n+  for (k = 0; k < K; k++)\n+    {\n+      res = 0;\n+      for (j = 0; j < K; j++) \n+        for (i = 0; i < K; i++)\n+          { \n+            next = a[i][j]; \n+            res = c > cond_array[i+k][j] ? next : res;\n+          }\n+ \n+      out[k] = res;\n+    }\n+}\n+\n+int main ()\n+{\n+  int i, j, k;\n+\n+  check_vect ();\n+\n+  for  (j = 0; j < K; j++)\n+    {\n+      for (i = 0; i < 2*K; i++)\n+        cond_array[i][j] = i+j;\n+\n+      for (i = 0; i < K; i++)\n+        a[i][j] = i+2;\n+    }\n+\n+  foo(5);\n+\n+  for (k = 0; k < K; k++)\n+    if (out[k] != check_result[k])\n+      abort ();\n+\n+  return 0;\n+}\n+\n+/* Double reduction with cond_expr is not supported, since eventhough the order \n+   of computation is the same, but vector results should be reduced to scalar\n+   result, which can'be done for cond_expr.  */\n+/* { dg-final { scan-tree-dump-times \"OUTER LOOP VECTORIZED\" 1 \"vect\" { xfail *-*-* } } } */\n+/* { dg-final { cleanup-tree-dump \"vect\" } } */\n+      "}, {"sha": "e5e93919b3abc097ec7029865e8e19a5f0e346c0", "filename": "gcc/testsuite/gcc.dg/vect/vect-cond-6.c", "status": "added", "additions": 60, "deletions": 0, "changes": 60, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4bbe826276ddc92d622b519659c52ca7027a823c/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-cond-6.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4bbe826276ddc92d622b519659c52ca7027a823c/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-cond-6.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-cond-6.c?ref=4bbe826276ddc92d622b519659c52ca7027a823c", "patch": "@@ -0,0 +1,60 @@\n+/* { dg-require-effective-target vect_condition } */\n+\n+#include <stdarg.h>\n+#include <stdio.h>\n+#include \"tree-vect.h\"\n+\n+#define K 32\n+\n+int cond_array[2*K][K] __attribute__ ((__aligned__(__BIGGEST_ALIGNMENT__)));\n+int a[K][K] __attribute__ ((__aligned__(__BIGGEST_ALIGNMENT__)));\n+int out[K];\n+\n+__attribute__ ((noinline)) void \n+foo (int c)\n+{\n+  int res, i, j, k, next;\n+\n+  for (k = 0; k < K; k++)\n+    {\n+      for (j = 0; j < K; j++) \n+        {\n+          res = 0;\n+          for (i = 0; i < K; i++)\n+            { \n+              next = a[i][j]; \n+              res = c > cond_array[i+k][j] ? next : res;\n+            }\n+ \n+          out[j] = res;\n+        }\n+    }\n+}\n+\n+int main ()\n+{\n+  int i, j, k;\n+\n+  check_vect ();\n+\n+  for  (j = 0; j < K; j++)\n+    {\n+      for (i = 0; i < 2*K; i++)\n+        cond_array[i][j] = i+j;\n+\n+      for (i = 0; i < K; i++)\n+        a[i][j] = i+2;\n+    }\n+\n+  foo(125);\n+\n+  for (k = 0; k < K; k++) \n+    if (out[k] != 33)\n+      abort ();\n+\n+  return 0;\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"OUTER LOOP VECTORIZED\" 1 \"vect\" } } */\n+/* { dg-final { cleanup-tree-dump \"vect\" } } */\n+      "}, {"sha": "b7b9d7893e5038dd2f27ecb1fe819bbd30cc48ed", "filename": "gcc/tree-vect-loop.c", "status": "modified", "additions": 190, "deletions": 95, "changes": 285, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4bbe826276ddc92d622b519659c52ca7027a823c/gcc%2Ftree-vect-loop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4bbe826276ddc92d622b519659c52ca7027a823c/gcc%2Ftree-vect-loop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-loop.c?ref=4bbe826276ddc92d622b519659c52ca7027a823c", "patch": "@@ -1568,9 +1568,9 @@ vect_is_simple_reduction (loop_vec_info loop_info, gimple phi,\n   struct loop *vect_loop = LOOP_VINFO_LOOP (loop_info);\n   edge latch_e = loop_latch_edge (loop);\n   tree loop_arg = PHI_ARG_DEF_FROM_EDGE (phi, latch_e);\n-  gimple def_stmt, def1, def2;\n+  gimple def_stmt, def1 = NULL, def2 = NULL;\n   enum tree_code code;\n-  tree op1, op2;\n+  tree op1, op2, op3 = NULL_TREE, op4 = NULL_TREE;\n   tree type;\n   int nloop_uses;\n   tree name;\n@@ -1695,25 +1695,52 @@ vect_is_simple_reduction (loop_vec_info loop_info, gimple phi,\n       return NULL;\n     }\n \n-  if (get_gimple_rhs_class (code) != GIMPLE_BINARY_RHS)\n+  if (get_gimple_rhs_class (code) != GIMPLE_BINARY_RHS) \n     {\n-      if (vect_print_dump_info (REPORT_DETAILS))\n-\treport_vect_op (def_stmt, \"reduction: not binary operation: \");\n-      return NULL;\n-    }\n+      if (code != COND_EXPR)\n+        {\n+          if (vect_print_dump_info (REPORT_DETAILS))\n+\t    report_vect_op (def_stmt, \"reduction: not binary operation: \");\n \n-  op1 = gimple_assign_rhs1 (def_stmt);\n-  op2 = gimple_assign_rhs2 (def_stmt);\n-  if (TREE_CODE (op1) != SSA_NAME || TREE_CODE (op2) != SSA_NAME)\n-    {\n-      if (vect_print_dump_info (REPORT_DETAILS))\n-\treport_vect_op (def_stmt, \"reduction: uses not ssa_names: \");\n-      return NULL;\n+          return NULL;\n+        }\n+\n+      op3 = TREE_OPERAND (TREE_OPERAND (gimple_assign_rhs1 (def_stmt), 0), 0);\n+      op4 = TREE_OPERAND (TREE_OPERAND (gimple_assign_rhs1 (def_stmt), 0), 1);\n+      op1 = TREE_OPERAND (gimple_assign_rhs1 (def_stmt), 1);\n+      op2 = TREE_OPERAND (gimple_assign_rhs1 (def_stmt), 2);\n+\n+      if (TREE_CODE (op1) != SSA_NAME && TREE_CODE (op2) != SSA_NAME)\n+        {\n+          if (vect_print_dump_info (REPORT_DETAILS))\n+            report_vect_op (def_stmt, \"reduction: uses not ssa_names: \");\n+\n+          return NULL;\n+        }\n     }\n+  else\n+    {\n+      op1 = gimple_assign_rhs1 (def_stmt);\n+      op2 = gimple_assign_rhs2 (def_stmt);\n+\n+      if (TREE_CODE (op1) != SSA_NAME || TREE_CODE (op2) != SSA_NAME)\n+        {\n+          if (vect_print_dump_info (REPORT_DETAILS))\n+\t    report_vect_op (def_stmt, \"reduction: uses not ssa_names: \");\n+\n+          return NULL;\n+        }\n+   }\n \n   type = TREE_TYPE (gimple_assign_lhs (def_stmt));\n-  if (TYPE_MAIN_VARIANT (type) != TYPE_MAIN_VARIANT (TREE_TYPE (op1))\n-      || TYPE_MAIN_VARIANT (type) != TYPE_MAIN_VARIANT (TREE_TYPE (op2)))\n+  if ((TREE_CODE (op1) == SSA_NAME\n+       && TYPE_MAIN_VARIANT (type) != TYPE_MAIN_VARIANT (TREE_TYPE (op1)))\n+      || (TREE_CODE (op2) == SSA_NAME\n+          && TYPE_MAIN_VARIANT (type) != TYPE_MAIN_VARIANT (TREE_TYPE (op2)))\n+      || (op3 && TREE_CODE (op3) == SSA_NAME\n+          && TYPE_MAIN_VARIANT (type) != TYPE_MAIN_VARIANT (TREE_TYPE (op3)))\n+      || (op4 && TREE_CODE (op4) == SSA_NAME\n+          && TYPE_MAIN_VARIANT (type) != TYPE_MAIN_VARIANT (TREE_TYPE (op4))))\n     {\n       if (vect_print_dump_info (REPORT_DETAILS))\n         {\n@@ -1723,7 +1750,15 @@ vect_is_simple_reduction (loop_vec_info loop_info, gimple phi,\n           print_generic_expr (vect_dump, TREE_TYPE (op1), TDF_SLIM);\n           fprintf (vect_dump, \",\");\n           print_generic_expr (vect_dump, TREE_TYPE (op2), TDF_SLIM);\n+          if (op3 && op4)\n+            {\n+              fprintf (vect_dump, \",\");\n+              print_generic_expr (vect_dump, TREE_TYPE (op3), TDF_SLIM);\n+              fprintf (vect_dump, \",\");\n+              print_generic_expr (vect_dump, TREE_TYPE (op4), TDF_SLIM);\n+            }\n         }\n+\n       return NULL;\n     }\n \n@@ -1765,9 +1800,14 @@ vect_is_simple_reduction (loop_vec_info loop_info, gimple phi,\n      1) integer arithmetic and no trapv\n      2) floating point arithmetic, and special flags permit this optimization\n      3) nested cycle (i.e., outer loop vectorization).  */\n-  def1 = SSA_NAME_DEF_STMT (op1);\n-  def2 = SSA_NAME_DEF_STMT (op2);\n-  if (!def1 || !def2 || gimple_nop_p (def1) || gimple_nop_p (def2))\n+  if (TREE_CODE (op1) == SSA_NAME)\n+    def1 = SSA_NAME_DEF_STMT (op1);\n+\n+  if (TREE_CODE (op2) == SSA_NAME)\n+    def2 = SSA_NAME_DEF_STMT (op2);\n+\n+  if (code != COND_EXPR \n+      && (!def1 || !def2 || gimple_nop_p (def1) || gimple_nop_p (def2)))\n     {\n       if (vect_print_dump_info (REPORT_DETAILS))\n \treport_vect_op (def_stmt, \"reduction: no defs for operands: \");\n@@ -1778,28 +1818,31 @@ vect_is_simple_reduction (loop_vec_info loop_info, gimple phi,\n      the other def is either defined in the loop (\"vect_internal_def\"),\n      or it's an induction (defined by a loop-header phi-node).  */\n \n-  if (def2 == phi\n-      && flow_bb_inside_loop_p (loop, gimple_bb (def1))\n-      && (is_gimple_assign (def1)\n-\t  || STMT_VINFO_DEF_TYPE (vinfo_for_stmt (def1)) == vect_induction_def\n-\t  || (gimple_code (def1) == GIMPLE_PHI\n-\t      && STMT_VINFO_DEF_TYPE (vinfo_for_stmt (def1)) \n-                  == vect_internal_def\n-\t      && !is_loop_header_bb_p (gimple_bb (def1)))))\n+  if (def2 && def2 == phi\n+      && (code == COND_EXPR\n+          || (def1 && flow_bb_inside_loop_p (loop, gimple_bb (def1))\n+              && (is_gimple_assign (def1)\n+  \t          || STMT_VINFO_DEF_TYPE (vinfo_for_stmt (def1)) \n+                      == vect_induction_def\n+   \t          || (gimple_code (def1) == GIMPLE_PHI\n+\t              && STMT_VINFO_DEF_TYPE (vinfo_for_stmt (def1)) \n+                          == vect_internal_def\n+ \t              && !is_loop_header_bb_p (gimple_bb (def1)))))))\n     {\n       if (vect_print_dump_info (REPORT_DETAILS))\n \treport_vect_op (def_stmt, \"detected reduction: \");\n       return def_stmt;\n     }\n-  else if (def1 == phi\n-\t   && flow_bb_inside_loop_p (loop, gimple_bb (def2))\n-\t   && (is_gimple_assign (def2)\n-\t       || STMT_VINFO_DEF_TYPE (vinfo_for_stmt (def2))\n-                    == vect_induction_def\n-\t       || (gimple_code (def2) == GIMPLE_PHI\n-\t\t   && STMT_VINFO_DEF_TYPE (vinfo_for_stmt (def2)) \n-                    == vect_internal_def\n-\t\t   && !is_loop_header_bb_p (gimple_bb (def2)))))\n+  else if (def1 && def1 == phi\n+\t   && (code == COND_EXPR\n+               || (def2 && flow_bb_inside_loop_p (loop, gimple_bb (def2))\n+ \t           && (is_gimple_assign (def2)\n+\t               || STMT_VINFO_DEF_TYPE (vinfo_for_stmt (def2))\n+                           == vect_induction_def\n+ \t               || (gimple_code (def2) == GIMPLE_PHI\n+\t\t           && STMT_VINFO_DEF_TYPE (vinfo_for_stmt (def2)) \n+                               == vect_internal_def\n+\t\t           && !is_loop_header_bb_p (gimple_bb (def2)))))))\n     {\n       if (check_reduction)\n         {\n@@ -2584,16 +2627,16 @@ get_initial_def_for_induction (gimple iv_phi)\n         vector of partial results.\n \n    Option1 (adjust in epilog): Initialize the vector as follows:\n-     add/bit or/xor: [0,0,...,0,0]\n-     mult/bit and:   [1,1,...,1,1]\n-     min/max:        [init_val,init_val,..,init_val,init_val]\n+     add/bit or/xor:    [0,0,...,0,0]\n+     mult/bit and:      [1,1,...,1,1]\n+     min/max/cond_expr: [init_val,init_val,..,init_val,init_val]\n    and when necessary (e.g. add/mult case) let the caller know\n    that it needs to adjust the result by init_val.\n \n    Option2: Initialize the vector as follows:\n-     add/bit or/xor: [init_val,0,0,...,0]\n-     mult/bit and:   [init_val,1,1,...,1]\n-     min/max:        [init_val,init_val,...,init_val]\n+     add/bit or/xor:    [init_val,0,0,...,0]\n+     mult/bit and:      [init_val,1,1,...,1]\n+     min/max/cond_expr: [init_val,init_val,...,init_val]\n    and no adjustments are needed.\n \n    For example, for the following code:\n@@ -2726,6 +2769,7 @@ get_initial_def_for_reduction (gimple stmt, tree init_val,\n \n       case MIN_EXPR:\n       case MAX_EXPR:\n+      case COND_EXPR:\n         if (adjustment_def)\n           {\n             *adjustment_def = NULL_TREE;\n@@ -3413,7 +3457,7 @@ vectorizable_reduction (gimple stmt, gimple_stmt_iterator *gsi,\n   stmt_vec_info prev_stmt_info, prev_phi_info;\n   gimple first_phi = NULL;\n   bool single_defuse_cycle = false;\n-  tree reduc_def;\n+  tree reduc_def = NULL_TREE;\n   gimple new_stmt = NULL;\n   int j;\n   tree ops[3];\n@@ -3522,14 +3566,18 @@ vectorizable_reduction (gimple stmt, gimple_stmt_iterator *gsi,\n      reduction variable.  */\n   for (i = 0; i < op_type-1; i++)\n     {\n+      /* The condition of COND_EXPR is checked in vectorizable_condition().  */\n+      if (i == 0 && code == COND_EXPR)\n+        continue;\n+\n       is_simple_use = vect_is_simple_use (ops[i], loop_vinfo, NULL, &def_stmt,\n \t\t\t\t\t  &def, &dt);\n       gcc_assert (is_simple_use);\n       if (dt != vect_internal_def\n \t  && dt != vect_external_def\n \t  && dt != vect_constant_def\n \t  && dt != vect_induction_def\n-          && dt != vect_nested_cycle)\n+          && !(dt == vect_nested_cycle && nested_cycle))\n \treturn false;\n \n       if (dt == vect_nested_cycle)\n@@ -3564,37 +3612,56 @@ vectorizable_reduction (gimple stmt, gimple_stmt_iterator *gsi,\n   if (STMT_VINFO_LIVE_P (vinfo_for_stmt (reduc_def_stmt)))\n     return false;\n \n-  /* 4. Supportable by target?  */\n+  vec_mode = TYPE_MODE (vectype);\n \n-  /* 4.1. check support for the operation in the loop  */\n-  optab = optab_for_tree_code (code, vectype, optab_default);\n-  if (!optab)\n+  if (code == COND_EXPR)\n     {\n-      if (vect_print_dump_info (REPORT_DETAILS))\n-        fprintf (vect_dump, \"no optab.\");\n-      return false;\n+      if (!vectorizable_condition (stmt, gsi, NULL, ops[reduc_index], 0))\n+        {\n+          if (vect_print_dump_info (REPORT_DETAILS))\n+            fprintf (vect_dump, \"unsupported condition in reduction\");\n+\n+            return false;\n+        }\n     }\n-  vec_mode = TYPE_MODE (vectype);\n-  if (optab_handler (optab, vec_mode)->insn_code == CODE_FOR_nothing)\n+  else\n     {\n-      if (vect_print_dump_info (REPORT_DETAILS))\n-        fprintf (vect_dump, \"op not supported by target.\");\n-      if (GET_MODE_SIZE (vec_mode) != UNITS_PER_WORD\n-          || LOOP_VINFO_VECT_FACTOR (loop_vinfo)\n-\t     < vect_min_worthwhile_factor (code))\n-        return false;\n-      if (vect_print_dump_info (REPORT_DETAILS))\n-\tfprintf (vect_dump, \"proceeding using word mode.\");\n-    }\n+      /* 4. Supportable by target?  */\n \n-  /* Worthwhile without SIMD support?  */\n-  if (!VECTOR_MODE_P (TYPE_MODE (vectype))\n-      && LOOP_VINFO_VECT_FACTOR (loop_vinfo)\n-\t < vect_min_worthwhile_factor (code))\n-    {\n-      if (vect_print_dump_info (REPORT_DETAILS))\n-\tfprintf (vect_dump, \"not worthwhile without SIMD support.\");\n-      return false;\n+      /* 4.1. check support for the operation in the loop  */\n+      optab = optab_for_tree_code (code, vectype, optab_default);\n+      if (!optab)\n+        {\n+          if (vect_print_dump_info (REPORT_DETAILS))\n+            fprintf (vect_dump, \"no optab.\");\n+\n+          return false;\n+        }\n+\n+      if (optab_handler (optab, vec_mode)->insn_code == CODE_FOR_nothing)\n+        {\n+          if (vect_print_dump_info (REPORT_DETAILS))\n+            fprintf (vect_dump, \"op not supported by target.\");\n+\n+          if (GET_MODE_SIZE (vec_mode) != UNITS_PER_WORD\n+              || LOOP_VINFO_VECT_FACTOR (loop_vinfo)\n+\t          < vect_min_worthwhile_factor (code))\n+            return false;\n+\n+          if (vect_print_dump_info (REPORT_DETAILS))\n+  \t    fprintf (vect_dump, \"proceeding using word mode.\");\n+        }\n+\n+      /* Worthwhile without SIMD support?  */\n+      if (!VECTOR_MODE_P (TYPE_MODE (vectype))\n+          && LOOP_VINFO_VECT_FACTOR (loop_vinfo)\n+   \t     < vect_min_worthwhile_factor (code))\n+        {\n+          if (vect_print_dump_info (REPORT_DETAILS))\n+\t    fprintf (vect_dump, \"not worthwhile without SIMD support.\");\n+\n+          return false;\n+        }\n     }\n \n   /* 4.2. Check support for the epilog operation.\n@@ -3656,26 +3723,6 @@ vectorizable_reduction (gimple stmt, gimple_stmt_iterator *gsi,\n       orig_code = code;\n     }\n \n-  if (!reduction_code_for_scalar_code (orig_code, &epilog_reduc_code))\n-    return false;\n-\n-  reduc_optab = optab_for_tree_code (epilog_reduc_code, vectype, \n-                                     optab_default);\n-  if (!reduc_optab)\n-    {\n-      if (vect_print_dump_info (REPORT_DETAILS))\n-        fprintf (vect_dump, \"no optab for reduction.\");\n-      epilog_reduc_code = ERROR_MARK;\n-    }\n-\n-  if (reduc_optab\n-      && optab_handler (reduc_optab, vec_mode)->insn_code == CODE_FOR_nothing)\n-    {\n-      if (vect_print_dump_info (REPORT_DETAILS))\n-        fprintf (vect_dump, \"reduc op not supported by target.\");\n-      epilog_reduc_code = ERROR_MARK;\n-    }\n-\n   if (nested_cycle)\n     {\n       def_bb = gimple_bb (reduc_def_stmt);\n@@ -3692,6 +3739,40 @@ vectorizable_reduction (gimple stmt, gimple_stmt_iterator *gsi,\n         double_reduc = true;\n     }\n \n+  epilog_reduc_code = ERROR_MARK;\n+  if (reduction_code_for_scalar_code (orig_code, &epilog_reduc_code))\n+    {\n+      reduc_optab = optab_for_tree_code (epilog_reduc_code, vectype, \n+                                         optab_default);\n+      if (!reduc_optab)\n+        {\n+          if (vect_print_dump_info (REPORT_DETAILS))\n+            fprintf (vect_dump, \"no optab for reduction.\");\n+\n+          epilog_reduc_code = ERROR_MARK;\n+        }\n+\n+      if (reduc_optab\n+          && optab_handler (reduc_optab, vec_mode)->insn_code \n+              == CODE_FOR_nothing)\n+        {\n+          if (vect_print_dump_info (REPORT_DETAILS))\n+            fprintf (vect_dump, \"reduc op not supported by target.\");\n+ \n+          epilog_reduc_code = ERROR_MARK;\n+        }\n+    }\n+  else\n+    {\n+      if (!nested_cycle || double_reduc)\n+        {\n+          if (vect_print_dump_info (REPORT_DETAILS))\n+            fprintf (vect_dump, \"no reduc code for scalar code.\");\n+\n+          return false;\n+        }\n+    }\n+\n   if (double_reduc && ncopies > 1)\n     {\n       if (vect_print_dump_info (REPORT_DETAILS))\n@@ -3713,6 +3794,10 @@ vectorizable_reduction (gimple stmt, gimple_stmt_iterator *gsi,\n   if (vect_print_dump_info (REPORT_DETAILS))\n     fprintf (vect_dump, \"transform reduction.\");\n \n+  /* FORNOW: Multiple types are not supported for condition.  */\n+  if (code == COND_EXPR)\n+    gcc_assert (ncopies == 1);\n+\n   /* Create the destination vector  */\n   vec_dest = vect_create_destination_var (scalar_dest, vectype);\n \n@@ -3761,8 +3846,19 @@ vectorizable_reduction (gimple stmt, gimple_stmt_iterator *gsi,\n \t  new_phi = create_phi_node (vec_dest, loop->header);\n \t  set_vinfo_for_stmt (new_phi, new_stmt_vec_info (new_phi, loop_vinfo, \n \t                                                  NULL));\n+          /* Get the vector def for the reduction variable from the phi\n+             node.  */\n+          reduc_def = PHI_RESULT (new_phi);\n \t}\n \n+      if (code == COND_EXPR)\n+        {\n+          first_phi = new_phi;\n+          vectorizable_condition (stmt, gsi, vec_stmt, reduc_def, reduc_index);\n+          /* Multiple types are not supported for condition.  */\n+          break;\n+        }\n+\n       /* Handle uses.  */\n       if (j == 0)\n         {\n@@ -3780,7 +3876,6 @@ vectorizable_reduction (gimple stmt, gimple_stmt_iterator *gsi,\n \n           /* Get the vector def for the reduction variable from the phi \n              node.  */\n-          reduc_def = PHI_RESULT (new_phi);\n \t  first_phi = new_phi;\n         }\n       else\n@@ -3798,8 +3893,7 @@ vectorizable_reduction (gimple stmt, gimple_stmt_iterator *gsi,\n \t  STMT_VINFO_RELATED_STMT (prev_phi_info) = new_phi;\n         }\n \n-      \n-      /* Arguments are ready. create the new vector stmt.  */\n+      /* Arguments are ready. Create the new vector stmt.  */\n       if (op_type == binary_op)\n         {\n           if (reduc_index == 0)\n@@ -3827,18 +3921,19 @@ vectorizable_reduction (gimple stmt, gimple_stmt_iterator *gsi,\n       new_temp = make_ssa_name (vec_dest, new_stmt);\n       gimple_assign_set_lhs (new_stmt, new_temp);\n       vect_finish_stmt_generation (stmt, new_stmt, gsi);\n-\n+        \n       if (j == 0)\n \tSTMT_VINFO_VEC_STMT (stmt_info) = *vec_stmt = new_stmt;\n       else\n \tSTMT_VINFO_RELATED_STMT (prev_stmt_info) = new_stmt;\n+\n       prev_stmt_info = vinfo_for_stmt (new_stmt);\n       prev_phi_info = vinfo_for_stmt (new_phi);\n     }\n \n   /* Finalize the reduction-phi (set its arguments) and create the\n      epilog reduction code.  */\n-  if (!single_defuse_cycle)\n+  if (!single_defuse_cycle || code == COND_EXPR)\n     new_temp = gimple_assign_lhs (*vec_stmt);\n \n   vect_create_epilog_for_reduction (new_temp, stmt, epilog_copies,"}, {"sha": "8e1c973bba7bad4d2db3ea9ff82e505af6faf105", "filename": "gcc/tree-vect-stmts.c", "status": "modified", "additions": 22, "deletions": 10, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4bbe826276ddc92d622b519659c52ca7027a823c/gcc%2Ftree-vect-stmts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4bbe826276ddc92d622b519659c52ca7027a823c/gcc%2Ftree-vect-stmts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-stmts.c?ref=4bbe826276ddc92d622b519659c52ca7027a823c", "patch": "@@ -3775,13 +3775,17 @@ vect_is_simple_cond (tree cond, loop_vec_info loop_vinfo)\n    Check if STMT is conditional modify expression that can be vectorized. \n    If VEC_STMT is also passed, vectorize the STMT: create a vectorized \n    stmt using VEC_COND_EXPR  to replace it, put it in VEC_STMT, and insert it \n-   at BSI.\n+   at GSI.\n+\n+   When STMT is vectorized as nested cycle, REDUC_DEF is the vector variable\n+   to be used at REDUC_INDEX (in then clause if REDUC_INDEX is 1, and in\n+   else caluse if it is 2).\n \n    Return FALSE if not a vectorizable STMT, TRUE otherwise.  */\n \n-static bool\n+bool\n vectorizable_condition (gimple stmt, gimple_stmt_iterator *gsi,\n-\t\t\tgimple *vec_stmt)\n+\t\t\tgimple *vec_stmt, tree reduc_def, int reduc_index)\n {\n   tree scalar_dest = NULL_TREE;\n   tree vec_dest = NULL_TREE;\n@@ -3810,15 +3814,17 @@ vectorizable_condition (gimple stmt, gimple_stmt_iterator *gsi,\n   if (!STMT_VINFO_RELEVANT_P (stmt_info))\n     return false;\n \n-  if (STMT_VINFO_DEF_TYPE (stmt_info) != vect_internal_def)\n+  if (STMT_VINFO_DEF_TYPE (stmt_info) != vect_internal_def\n+      && !(STMT_VINFO_DEF_TYPE (stmt_info) == vect_nested_cycle\n+           && reduc_def))\n     return false;\n \n   /* FORNOW: SLP not supported.  */\n   if (STMT_SLP_TYPE (stmt_info))\n     return false;\n \n   /* FORNOW: not yet supported.  */\n-  if (STMT_VINFO_LIVE_P (stmt_info))\n+  if (STMT_VINFO_LIVE_P (stmt_info)) \n     {\n       if (vect_print_dump_info (REPORT_DETAILS))\n         fprintf (vect_dump, \"value used after loop.\");\n@@ -3892,8 +3898,14 @@ vectorizable_condition (gimple stmt, gimple_stmt_iterator *gsi,\n     vect_get_vec_def_for_operand (TREE_OPERAND (cond_expr, 0), stmt, NULL);\n   vec_cond_rhs = \n     vect_get_vec_def_for_operand (TREE_OPERAND (cond_expr, 1), stmt, NULL);\n-  vec_then_clause = vect_get_vec_def_for_operand (then_clause, stmt, NULL);\n-  vec_else_clause = vect_get_vec_def_for_operand (else_clause, stmt, NULL);\n+  if (reduc_index == 1)\n+    vec_then_clause = reduc_def;\n+  else\n+    vec_then_clause = vect_get_vec_def_for_operand (then_clause, stmt, NULL);\n+  if (reduc_index == 2)\n+    vec_else_clause = reduc_def;\n+  else\n+    vec_else_clause = vect_get_vec_def_for_operand (else_clause, stmt, NULL);\n \n   /* Arguments are ready. Create the new vector stmt.  */\n   vec_compare = build2 (TREE_CODE (cond_expr), vectype, \n@@ -4023,8 +4035,8 @@ vect_analyze_stmt (gimple stmt, bool *need_to_vectorize, slp_tree node)\n             || vectorizable_load (stmt, NULL, NULL, NULL, NULL)\n             || vectorizable_call (stmt, NULL, NULL)\n             || vectorizable_store (stmt, NULL, NULL, NULL)\n-            || vectorizable_condition (stmt, NULL, NULL)\n-            || vectorizable_reduction (stmt, NULL, NULL));\n+            || vectorizable_reduction (stmt, NULL, NULL)\n+            || vectorizable_condition (stmt, NULL, NULL, NULL, 0));\n     else\n       {\n         if (bb_vinfo)\n@@ -4165,7 +4177,7 @@ vect_transform_stmt (gimple stmt, gimple_stmt_iterator *gsi,\n \n     case condition_vec_info_type:\n       gcc_assert (!slp_node);\n-      done = vectorizable_condition (stmt, gsi, &vec_stmt);\n+      done = vectorizable_condition (stmt, gsi, &vec_stmt, NULL, 0);\n       gcc_assert (done);\n       break;\n "}, {"sha": "31e9c18500526248292d69f16ce5ecb3c30dad92", "filename": "gcc/tree-vectorizer.h", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4bbe826276ddc92d622b519659c52ca7027a823c/gcc%2Ftree-vectorizer.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4bbe826276ddc92d622b519659c52ca7027a823c/gcc%2Ftree-vectorizer.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vectorizer.h?ref=4bbe826276ddc92d622b519659c52ca7027a823c", "patch": "@@ -786,7 +786,9 @@ extern bool vect_transform_stmt (gimple, gimple_stmt_iterator *,\n                                  bool *, slp_tree, slp_instance);\n extern void vect_remove_stores (gimple);\n extern bool vect_analyze_stmt (gimple, bool *, slp_tree);\n-\n+extern bool vectorizable_condition (gimple, gimple_stmt_iterator *, gimple *, \n+                                    tree, int);\n+                        \n /* In tree-vect-data-refs.c.  */\n extern bool vect_can_force_dr_alignment_p (const_tree, unsigned int);\n extern enum dr_alignment_support vect_supportable_dr_alignment"}]}