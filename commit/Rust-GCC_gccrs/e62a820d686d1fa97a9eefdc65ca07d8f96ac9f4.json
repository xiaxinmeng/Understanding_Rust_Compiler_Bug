{"sha": "e62a820d686d1fa97a9eefdc65ca07d8f96ac9f4", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTYyYTgyMGQ2ODZkMWZhOTdhOWVlZmRjNjVjYTA3ZDhmOTZhYzlmNA==", "commit": {"author": {"name": "Richard Sandiford", "email": "richard.sandiford@arm.com", "date": "2020-04-28T07:04:29Z"}, "committer": {"name": "Richard Sandiford", "email": "richard.sandiford@arm.com", "date": "2020-04-28T07:04:29Z"}, "message": "vect: Fix COND_EXPRs involving variant booleans [PR94727]\n\nThe previous patch for this PR handled separate comparisons.\nHowever, as arm targets show, the same fix is needed when\nhandling comparisons embedded in a VEC_COND_EXPR.\n\nHere too, the problem is that vect_get_constant_vectors will\ncalculate its own vector type, using truth_type_for on the\nSTMT_VINFO_VECTYPE, and the vectoriable_* routines need to be\nconsistent with that.\n\n2020-04-28  Richard Sandiford  <richard.sandiford@arm.com>\n\ngcc/\n\tPR tree-optimization/94727\n\t* tree-vect-stmts.c (vect_is_simple_cond): If both comparison\n\toperands are invariant booleans, use the mask type associated with the\n\tSTMT_VINFO_VECTYPE.  Use !slp_node instead of !vectype to exclude SLP.\n\t(vectorizable_condition): Pass vectype unconditionally to\n\tvect_is_simple_cond.", "tree": {"sha": "1af5cafdf0ce540b2ae36aca7145bd9901b64b65", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1af5cafdf0ce540b2ae36aca7145bd9901b64b65"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e62a820d686d1fa97a9eefdc65ca07d8f96ac9f4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e62a820d686d1fa97a9eefdc65ca07d8f96ac9f4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e62a820d686d1fa97a9eefdc65ca07d8f96ac9f4", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e62a820d686d1fa97a9eefdc65ca07d8f96ac9f4/comments", "author": {"login": "rsandifo-arm", "id": 28043039, "node_id": "MDQ6VXNlcjI4MDQzMDM5", "avatar_url": "https://avatars.githubusercontent.com/u/28043039?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rsandifo-arm", "html_url": "https://github.com/rsandifo-arm", "followers_url": "https://api.github.com/users/rsandifo-arm/followers", "following_url": "https://api.github.com/users/rsandifo-arm/following{/other_user}", "gists_url": "https://api.github.com/users/rsandifo-arm/gists{/gist_id}", "starred_url": "https://api.github.com/users/rsandifo-arm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rsandifo-arm/subscriptions", "organizations_url": "https://api.github.com/users/rsandifo-arm/orgs", "repos_url": "https://api.github.com/users/rsandifo-arm/repos", "events_url": "https://api.github.com/users/rsandifo-arm/events{/privacy}", "received_events_url": "https://api.github.com/users/rsandifo-arm/received_events", "type": "User", "site_admin": false}, "committer": {"login": "rsandifo-arm", "id": 28043039, "node_id": "MDQ6VXNlcjI4MDQzMDM5", "avatar_url": "https://avatars.githubusercontent.com/u/28043039?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rsandifo-arm", "html_url": "https://github.com/rsandifo-arm", "followers_url": "https://api.github.com/users/rsandifo-arm/followers", "following_url": "https://api.github.com/users/rsandifo-arm/following{/other_user}", "gists_url": "https://api.github.com/users/rsandifo-arm/gists{/gist_id}", "starred_url": "https://api.github.com/users/rsandifo-arm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rsandifo-arm/subscriptions", "organizations_url": "https://api.github.com/users/rsandifo-arm/orgs", "repos_url": "https://api.github.com/users/rsandifo-arm/repos", "events_url": "https://api.github.com/users/rsandifo-arm/events{/privacy}", "received_events_url": "https://api.github.com/users/rsandifo-arm/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f5edc76acac7bbadd8d1b00c4cc5994b2a088542", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f5edc76acac7bbadd8d1b00c4cc5994b2a088542", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f5edc76acac7bbadd8d1b00c4cc5994b2a088542"}], "stats": {"total": 36, "additions": 25, "deletions": 11}, "files": [{"sha": "fe1ddac16eb35efca1a52cacb71610212af453f5", "filename": "gcc/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e62a820d686d1fa97a9eefdc65ca07d8f96ac9f4/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e62a820d686d1fa97a9eefdc65ca07d8f96ac9f4/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=e62a820d686d1fa97a9eefdc65ca07d8f96ac9f4", "patch": "@@ -1,3 +1,12 @@\n+2020-04-28  Richard Sandiford  <richard.sandiford@arm.com>\n+\n+\tPR tree-optimization/94727\n+\t* tree-vect-stmts.c (vect_is_simple_cond): If both comparison\n+\toperands are invariant booleans, use the mask type associated with the\n+\tSTMT_VINFO_VECTYPE.  Use !slp_node instead of !vectype to exclude SLP.\n+\t(vectorizable_condition): Pass vectype unconditionally to\n+\tvect_is_simple_cond.\n+\n 2020-04-27  Jakub Jelinek  <jakub@redhat.com>\n \n \tPR target/94780"}, {"sha": "1984787bac46df86a92098f8f141acfe831f7d7e", "filename": "gcc/tree-vect-stmts.c", "status": "modified", "additions": 16, "deletions": 11, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e62a820d686d1fa97a9eefdc65ca07d8f96ac9f4/gcc%2Ftree-vect-stmts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e62a820d686d1fa97a9eefdc65ca07d8f96ac9f4/gcc%2Ftree-vect-stmts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-stmts.c?ref=e62a820d686d1fa97a9eefdc65ca07d8f96ac9f4", "patch": "@@ -9942,16 +9942,21 @@ vect_is_simple_cond (tree cond, vec_info *vinfo, slp_tree slp_node,\n   if (! *comp_vectype)\n     {\n       tree scalar_type = TREE_TYPE (lhs);\n-      /* If we can widen the comparison to match vectype do so.  */\n-      if (INTEGRAL_TYPE_P (scalar_type)\n-\t  && vectype\n-\t  && tree_int_cst_lt (TYPE_SIZE (scalar_type),\n-\t\t\t      TYPE_SIZE (TREE_TYPE (vectype))))\n-\tscalar_type = build_nonstandard_integer_type\n-\t  (tree_to_uhwi (TYPE_SIZE (TREE_TYPE (vectype))),\n-\t   TYPE_UNSIGNED (scalar_type));\n-      *comp_vectype = get_vectype_for_scalar_type (vinfo, scalar_type,\n-\t\t\t\t\t\t   slp_node);\n+      if (VECT_SCALAR_BOOLEAN_TYPE_P (scalar_type))\n+\t*comp_vectype = truth_type_for (vectype);\n+      else\n+\t{\n+\t  /* If we can widen the comparison to match vectype do so.  */\n+\t  if (INTEGRAL_TYPE_P (scalar_type)\n+\t      && !slp_node\n+\t      && tree_int_cst_lt (TYPE_SIZE (scalar_type),\n+\t\t\t\t  TYPE_SIZE (TREE_TYPE (vectype))))\n+\t    scalar_type = build_nonstandard_integer_type\n+\t      (tree_to_uhwi (TYPE_SIZE (TREE_TYPE (vectype))),\n+\t       TYPE_UNSIGNED (scalar_type));\n+\t  *comp_vectype = get_vectype_for_scalar_type (vinfo, scalar_type,\n+\t\t\t\t\t\t       slp_node);\n+\t}\n     }\n \n   return true;\n@@ -10066,7 +10071,7 @@ vectorizable_condition (stmt_vec_info stmt_info, gimple_stmt_iterator *gsi,\n   else_clause = gimple_assign_rhs3 (stmt);\n \n   if (!vect_is_simple_cond (cond_expr, stmt_info->vinfo, slp_node,\n-\t\t\t    &comp_vectype, &dts[0], slp_node ? NULL : vectype)\n+\t\t\t    &comp_vectype, &dts[0], vectype)\n       || !comp_vectype)\n     return false;\n "}]}