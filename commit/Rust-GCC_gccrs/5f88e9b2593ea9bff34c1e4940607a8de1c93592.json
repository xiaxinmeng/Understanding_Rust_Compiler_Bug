{"sha": "5f88e9b2593ea9bff34c1e4940607a8de1c93592", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NWY4OGU5YjI1OTNlYTliZmYzNGMxZTQ5NDA2MDdhOGRlMWM5MzU5Mg==", "commit": {"author": {"name": "Fritz Reese", "email": "fritzoreese@gmail.com", "date": "2016-08-29T12:24:25Z"}, "committer": {"name": "Fritz Reese", "email": "foreese@gcc.gnu.org", "date": "2016-08-29T12:24:25Z"}, "message": "Fix, reorganize, and clarify comparisons of anonymous types/components.\n\n2016-08-29  Fritz Reese  <fritzoreese@gmail.com>\n\n\tFix, reorganize, and clarify comparisons of anonymous types/components.\n\n\tPR fortran/77327\n\t* interface.c (is_anonymous_component, is_anonymous_dt): New functions.\n\t* interface.c (compare_components, gfc_compare_derived_types): Use new\n\tfunctions.\n\n\t* gfortran.dg/dec_structure_13.f90: New testcase.\n\nFrom-SVN: r239819", "tree": {"sha": "6b870619e7501616a01107c2522b0f45b8ff853a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6b870619e7501616a01107c2522b0f45b8ff853a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5f88e9b2593ea9bff34c1e4940607a8de1c93592", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5f88e9b2593ea9bff34c1e4940607a8de1c93592", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5f88e9b2593ea9bff34c1e4940607a8de1c93592", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5f88e9b2593ea9bff34c1e4940607a8de1c93592/comments", "author": {"login": "fritzr", "id": 2230564, "node_id": "MDQ6VXNlcjIyMzA1NjQ=", "avatar_url": "https://avatars.githubusercontent.com/u/2230564?v=4", "gravatar_id": "", "url": "https://api.github.com/users/fritzr", "html_url": "https://github.com/fritzr", "followers_url": "https://api.github.com/users/fritzr/followers", "following_url": "https://api.github.com/users/fritzr/following{/other_user}", "gists_url": "https://api.github.com/users/fritzr/gists{/gist_id}", "starred_url": "https://api.github.com/users/fritzr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/fritzr/subscriptions", "organizations_url": "https://api.github.com/users/fritzr/orgs", "repos_url": "https://api.github.com/users/fritzr/repos", "events_url": "https://api.github.com/users/fritzr/events{/privacy}", "received_events_url": "https://api.github.com/users/fritzr/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "468d95c82cff4d16e5384b1f878d1050cb3deb32", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/468d95c82cff4d16e5384b1f878d1050cb3deb32", "html_url": "https://github.com/Rust-GCC/gccrs/commit/468d95c82cff4d16e5384b1f878d1050cb3deb32"}], "stats": {"total": 158, "additions": 133, "deletions": 25}, "files": [{"sha": "899cd32e93e739637983c1577430971e78f0b6b7", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5f88e9b2593ea9bff34c1e4940607a8de1c93592/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5f88e9b2593ea9bff34c1e4940607a8de1c93592/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=5f88e9b2593ea9bff34c1e4940607a8de1c93592", "patch": "@@ -1,3 +1,12 @@\n+2016-08-29  Fritz Reese  <fritzoreese@gmail.com>\n+\n+\tFix, reorganize, and clarify comparisons of anonymous types/components.\n+\n+\tPR fortran/77327\n+\t* interface.c (is_anonymous_component, is_anonymous_dt): New functions.\n+\t* interface.c (compare_components, gfc_compare_derived_types): Use new\n+\tfunctions.\n+\n 2016-08-27  Steven G. Kargl <kargl@gcc.gnu.org>\n \n \tPR fortran/77380"}, {"sha": "eba0454458eca0cd0c491412555dbd5b534d3366", "filename": "gcc/fortran/interface.c", "status": "modified", "additions": 37, "deletions": 25, "changes": 62, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5f88e9b2593ea9bff34c1e4940607a8de1c93592/gcc%2Ffortran%2Finterface.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5f88e9b2593ea9bff34c1e4940607a8de1c93592/gcc%2Ffortran%2Finterface.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Finterface.c?ref=5f88e9b2593ea9bff34c1e4940607a8de1c93592", "patch": "@@ -387,26 +387,46 @@ gfc_match_end_interface (void)\n }\n \n \n+/* Return whether the component was defined anonymously.  */\n+\n+static bool\n+is_anonymous_component (gfc_component *cmp)\n+{\n+  /* Only UNION and MAP components are anonymous.  In the case of a MAP,\n+     the derived type symbol is FL_STRUCT and the component name looks like mM*.\n+     This is the only case in which the second character of a component name is\n+     uppercase.  */\n+  return cmp->ts.type == BT_UNION\n+    || (cmp->ts.type == BT_DERIVED\n+        && cmp->ts.u.derived->attr.flavor == FL_STRUCT\n+        && cmp->name[0] && cmp->name[1] && ISUPPER (cmp->name[1]));\n+}\n+\n+\n+/* Return whether the derived type was defined anonymously.  */\n+\n+static bool\n+is_anonymous_dt (gfc_symbol *derived)\n+{\n+  /* UNION and MAP types are always anonymous. Otherwise, only nested STRUCTURE\n+     types can be anonymous.  For anonymous MAP/STRUCTURE, we have FL_STRUCT\n+     and the type name looks like XX*.  This is the only case in which the\n+     second character of a type name is uppercase.  */\n+  return derived->attr.flavor == FL_UNION\n+    || (derived->attr.flavor == FL_STRUCT\n+        && derived->name[0] && derived->name[1] && ISUPPER (derived->name[1]));\n+}\n+\n+\n /* Compare components according to 4.4.2 of the Fortran standard.  */\n \n static int\n compare_components (gfc_component *cmp1, gfc_component *cmp2,\n     gfc_symbol *derived1, gfc_symbol *derived2)\n {\n-  gfc_symbol *d1, *d2;\n-  bool anonymous = false;\n-\n-  /* Unions, maps, and anonymous structures all have names like \"[xX]X$\\d+\"\n-     which should not be compared.  */\n-  d1 = cmp1->ts.u.derived;\n-  d2 = cmp2->ts.u.derived;\n-  if (   (d1 && (d1->attr.flavor == FL_STRUCT || d1->attr.flavor == FL_UNION)\n-          && ISUPPER (cmp1->name[1]))\n-      || (d2 && (d2->attr.flavor == FL_STRUCT || d2->attr.flavor == FL_UNION)\n-          && ISUPPER (cmp2->name[1])))\n-    anonymous = true;\n-\n-  if (!anonymous && strcmp (cmp1->name, cmp2->name) != 0)\n+  /* Compare names, but not for anonymous components such as UNION or MAP.  */\n+  if (!is_anonymous_component (cmp1) && !is_anonymous_component (cmp2)\n+      && strcmp (cmp1->name, cmp2->name) != 0)\n     return 0;\n \n   if (cmp1->attr.access != cmp2->attr.access)\n@@ -512,22 +532,12 @@ int\n gfc_compare_derived_types (gfc_symbol *derived1, gfc_symbol *derived2)\n {\n   gfc_component *cmp1, *cmp2;\n-  bool anonymous = false;\n \n   if (derived1 == derived2)\n     return 1;\n \n   gcc_assert (derived1 && derived2);\n \n-  /* MAP and anonymous STRUCTURE types have internal names of the form\n-     mM* and sS* (we can get away this this because source names are converted\n-     to lowerase). Compare anonymous type names specially because each\n-     gets a unique name when it is declared. */\n-  anonymous = (derived1->name[0] == derived2->name[0]\n-      && derived1->name[1] && derived2->name[1] && derived2->name[2]\n-      && derived1->name[1] == (char) TOUPPER (derived1->name[0])\n-      && derived2->name[2] == (char) TOUPPER (derived2->name[0]));\n-\n   /* Special case for comparing derived types across namespaces.  If the\n      true names and module names are the same and the module name is\n      nonnull, then they are equal.  */\n@@ -541,7 +551,9 @@ gfc_compare_derived_types (gfc_symbol *derived1, gfc_symbol *derived2)\n      because they can be anonymous; therefore two structures with different\n      names may be equal.  */\n \n-  if (strcmp (derived1->name, derived2->name) != 0 && !anonymous)\n+  /* Compare names, but not for anonymous types such as UNION or MAP.  */\n+  if (!is_anonymous_dt (derived1) && !is_anonymous_dt (derived2)\n+      && strcmp (derived1->name, derived2->name) != 0)\n     return 0;\n \n   if (derived1->component_access == ACCESS_PRIVATE"}, {"sha": "6d2a1a11f070652e112f7e5a2e74747268e35645", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5f88e9b2593ea9bff34c1e4940607a8de1c93592/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5f88e9b2593ea9bff34c1e4940607a8de1c93592/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=5f88e9b2593ea9bff34c1e4940607a8de1c93592", "patch": "@@ -1,3 +1,9 @@\n+2016-08-29  Fritz Reese  <fritzoreese@gmail.com>\n+\n+\tFix, reorganize, and clarify comparisons of anonymous types/components.\n+\n+\t* gfortran.dg/dec_structure_13.f90: New testcase.\n+\n 2016-08-29  Janne Blomqvist  <jb@gcc.gnu.org>\n \n \tPR fortran/77261"}, {"sha": "6963ddc3c26209a2bff9b77558f37e1f952bdb54", "filename": "gcc/testsuite/gfortran.dg/dec_structure_13.f90", "status": "added", "additions": 81, "deletions": 0, "changes": 81, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5f88e9b2593ea9bff34c1e4940607a8de1c93592/gcc%2Ftestsuite%2Fgfortran.dg%2Fdec_structure_13.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5f88e9b2593ea9bff34c1e4940607a8de1c93592/gcc%2Ftestsuite%2Fgfortran.dg%2Fdec_structure_13.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fdec_structure_13.f90?ref=5f88e9b2593ea9bff34c1e4940607a8de1c93592", "patch": "@@ -0,0 +1,81 @@\n+! { dg-do compile }\n+! { dg-options \"-fdec-structure\" }\n+!\n+! Verify that the comparisons in gfc_compare_derived_types can correctly\n+! match nested anonymous subtypes.\n+!\n+\n+subroutine sub0 (u)\n+  structure /t/\n+    structure sub\n+      integer i\n+    end structure\n+  endstructure\n+  record /t/ u\n+  u.sub.i = 0\n+end subroutine sub0\n+\n+subroutine sub1 ()\n+  structure /t/\n+    structure sub\n+      integer i\n+    end structure\n+  endstructure\n+  record /t/ u\n+\n+  interface\n+    subroutine sub0 (u) ! regression: Interface mismatch.*Type mismatch\n+      structure /t/\n+        structure sub\n+          integer i\n+        end structure\n+      endstructure\n+        record /t/ u\n+    end subroutine\n+  end interface\n+\n+  call sub0(u) ! regression: Type mismatch in argument\n+end subroutine\n+\n+subroutine sub2(u)\n+  structure /tu/\n+    union\n+      map\n+        integer i\n+      end map\n+      map\n+        real r\n+      end map\n+    end union\n+  end structure\n+  record /tu/ u\n+  u.r = 1.0\n+end subroutine\n+\n+implicit none\n+\n+structure /t/\n+  structure sub\n+    integer i\n+  end structure\n+endstructure\n+\n+structure /tu/\n+  union\n+    map\n+      integer i\n+    end map\n+    map\n+      real r\n+    end map\n+  end union\n+end structure\n+\n+record /t/ u\n+record /tu/ u2\n+\n+call sub0(u) ! regression: Type mismatch in argument\n+call sub1()\n+call sub2(u2)\n+\n+end"}]}