{"sha": "6f3ab30d8b7bfa0ab2e5a370f1196602960c271c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NmYzYWIzMGQ4YjdiZmEwYWIyZTVhMzcwZjExOTY2MDI5NjBjMjcxYw==", "commit": {"author": {"name": "Janus Weil", "email": "janus@gcc.gnu.org", "date": "2012-06-22T21:05:51Z"}, "committer": {"name": "Janus Weil", "email": "janus@gcc.gnu.org", "date": "2012-06-22T21:05:51Z"}, "message": "re PR fortran/47710 ([OOP] Improve ambiguity check for GENERIC TBP w/ PASS and NOPASS)\n\n2012-06-22  Janus Weil  <janus@gcc.gnu.org>\n\n\tPR fortran/47710\n\tPR fortran/53328\n\t* interface.c (count_types_test, generic_correspondence,\n\tgfc_compare_interfaces): Ignore PASS arguments.\n\t(check_interface1, compare_parameter): Pass NULL arguments to\n\tgfc_compare_interfaces.\n\t* gfortran.h (gfc_compare_interfaces): Modified prototype.\n\t* expr.c (gfc_check_pointer_assign): Pass NULL arguments to\n\tgfc_compare_interfaces.\n\t* resolve.c (resolve_structure_cons): Ditto.\n\t(check_generic_tbp_ambiguity): Determine PASS arguments and pass them\n\tto gfc_compare_interfaces.\n\n\n2012-06-22  Janus Weil  <janus@gcc.gnu.org>\n\n\tPR fortran/47710\n\tPR fortran/53328\n\t* gfortran.dg/typebound_generic_12.f03: New.\n\t* gfortran.dg/typebound_generic_13.f03: New.\n\nFrom-SVN: r188902", "tree": {"sha": "39c3ebe36c82e2ea4b612953d5ff90a3518c0b65", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/39c3ebe36c82e2ea4b612953d5ff90a3518c0b65"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6f3ab30d8b7bfa0ab2e5a370f1196602960c271c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6f3ab30d8b7bfa0ab2e5a370f1196602960c271c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6f3ab30d8b7bfa0ab2e5a370f1196602960c271c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6f3ab30d8b7bfa0ab2e5a370f1196602960c271c/comments", "author": {"login": "janusw", "id": 484108, "node_id": "MDQ6VXNlcjQ4NDEwOA==", "avatar_url": "https://avatars.githubusercontent.com/u/484108?v=4", "gravatar_id": "", "url": "https://api.github.com/users/janusw", "html_url": "https://github.com/janusw", "followers_url": "https://api.github.com/users/janusw/followers", "following_url": "https://api.github.com/users/janusw/following{/other_user}", "gists_url": "https://api.github.com/users/janusw/gists{/gist_id}", "starred_url": "https://api.github.com/users/janusw/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/janusw/subscriptions", "organizations_url": "https://api.github.com/users/janusw/orgs", "repos_url": "https://api.github.com/users/janusw/repos", "events_url": "https://api.github.com/users/janusw/events{/privacy}", "received_events_url": "https://api.github.com/users/janusw/received_events", "type": "User", "site_admin": false}, "committer": {"login": "janusw", "id": 484108, "node_id": "MDQ6VXNlcjQ4NDEwOA==", "avatar_url": "https://avatars.githubusercontent.com/u/484108?v=4", "gravatar_id": "", "url": "https://api.github.com/users/janusw", "html_url": "https://github.com/janusw", "followers_url": "https://api.github.com/users/janusw/followers", "following_url": "https://api.github.com/users/janusw/following{/other_user}", "gists_url": "https://api.github.com/users/janusw/gists{/gist_id}", "starred_url": "https://api.github.com/users/janusw/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/janusw/subscriptions", "organizations_url": "https://api.github.com/users/janusw/orgs", "repos_url": "https://api.github.com/users/janusw/repos", "events_url": "https://api.github.com/users/janusw/events{/privacy}", "received_events_url": "https://api.github.com/users/janusw/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "42533d77ac86ef73fe89ec5daf9c5d7fbb59cf55", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/42533d77ac86ef73fe89ec5daf9c5d7fbb59cf55", "html_url": "https://github.com/Rust-GCC/gccrs/commit/42533d77ac86ef73fe89ec5daf9c5d7fbb59cf55"}], "stats": {"total": 165, "additions": 135, "deletions": 30}, "files": [{"sha": "a804e263ef2b7a599b6949b8cccfcad1a0f3410e", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6f3ab30d8b7bfa0ab2e5a370f1196602960c271c/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6f3ab30d8b7bfa0ab2e5a370f1196602960c271c/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=6f3ab30d8b7bfa0ab2e5a370f1196602960c271c", "patch": "@@ -1,3 +1,18 @@\n+2012-06-22  Janus Weil  <janus@gcc.gnu.org>\n+\n+\tPR fortran/47710\n+\tPR fortran/53328\n+\t* interface.c (count_types_test, generic_correspondence,\n+\tgfc_compare_interfaces): Ignore PASS arguments.\n+\t(check_interface1, compare_parameter): Pass NULL arguments to\n+\tgfc_compare_interfaces.\n+\t* gfortran.h (gfc_compare_interfaces): Modified prototype.\n+\t* expr.c (gfc_check_pointer_assign): Pass NULL arguments to\n+\tgfc_compare_interfaces.\n+\t* resolve.c (resolve_structure_cons): Ditto.\n+\t(check_generic_tbp_ambiguity): Determine PASS arguments and pass them\n+\tto gfc_compare_interfaces.\n+\n 2012-06-21  Janne Blomqvist  <jb@gcc.gnu.org>\n \n \tPR fortran/39654"}, {"sha": "0b38cacad9447ad4bd63a3f293acb8af2cbfa181", "filename": "gcc/fortran/expr.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6f3ab30d8b7bfa0ab2e5a370f1196602960c271c/gcc%2Ffortran%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6f3ab30d8b7bfa0ab2e5a370f1196602960c271c/gcc%2Ffortran%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fexpr.c?ref=6f3ab30d8b7bfa0ab2e5a370f1196602960c271c", "patch": "@@ -3498,7 +3498,7 @@ gfc_check_pointer_assign (gfc_expr *lvalue, gfc_expr *rvalue)\n \t}\n \n       if (s1 && s2 && !gfc_compare_interfaces (s1, s2, name, 0, 1,\n-\t\t\t\t\t       err, sizeof(err)))\n+\t\t\t\t\t       err, sizeof(err), NULL, NULL))\n \t{\n \t  gfc_error (\"Interface mismatch in procedure pointer assignment \"\n \t\t     \"at %L: %s\", &rvalue->where, err);"}, {"sha": "43904e956a0ab6549583051f7b8327c0be6023a3", "filename": "gcc/fortran/gfortran.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6f3ab30d8b7bfa0ab2e5a370f1196602960c271c/gcc%2Ffortran%2Fgfortran.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6f3ab30d8b7bfa0ab2e5a370f1196602960c271c/gcc%2Ffortran%2Fgfortran.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fgfortran.h?ref=6f3ab30d8b7bfa0ab2e5a370f1196602960c271c", "patch": "@@ -2842,7 +2842,7 @@ void gfc_free_interface (gfc_interface *);\n int gfc_compare_derived_types (gfc_symbol *, gfc_symbol *);\n int gfc_compare_types (gfc_typespec *, gfc_typespec *);\n int gfc_compare_interfaces (gfc_symbol*, gfc_symbol*, const char *, int, int,\n-\t\t\t    char *, int);\n+\t\t\t    char *, int, const char *, const char *);\n void gfc_check_interfaces (gfc_namespace *);\n void gfc_procedure_use (gfc_symbol *, gfc_actual_arglist **, locus *);\n void gfc_ppc_use (gfc_component *, gfc_actual_arglist **, locus *);"}, {"sha": "7a63f696f5457be2e672bcd77ea7a21b830ee91a", "filename": "gcc/fortran/interface.c", "status": "modified", "additions": 41, "deletions": 24, "changes": 65, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6f3ab30d8b7bfa0ab2e5a370f1196602960c271c/gcc%2Ffortran%2Finterface.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6f3ab30d8b7bfa0ab2e5a370f1196602960c271c/gcc%2Ffortran%2Finterface.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Finterface.c?ref=6f3ab30d8b7bfa0ab2e5a370f1196602960c271c", "patch": "@@ -826,12 +826,13 @@ gfc_check_operator_interface (gfc_symbol *sym, gfc_intrinsic_op op,\n    a given type/rank in f1 and seeing if there are less then that\n    number of those arguments in f2 (including optional arguments).\n    Since this test is asymmetric, it has to be called twice to make it\n-   symmetric.  Returns nonzero if the argument lists are incompatible\n-   by this test.  This subroutine implements rule 1 of section\n-   14.1.2.3 in the Fortran 95 standard.  */\n+   symmetric. Returns nonzero if the argument lists are incompatible\n+   by this test. This subroutine implements rule 1 of section F03:16.2.3.\n+   'p1' and 'p2' are the PASS arguments of both procedures (if applicable).  */\n \n static int\n-count_types_test (gfc_formal_arglist *f1, gfc_formal_arglist *f2)\n+count_types_test (gfc_formal_arglist *f1, gfc_formal_arglist *f2,\n+\t\t  const char *p1, const char *p2)\n {\n   int rc, ac1, ac2, i, j, k, n1;\n   gfc_formal_arglist *f;\n@@ -868,14 +869,17 @@ count_types_test (gfc_formal_arglist *f1, gfc_formal_arglist *f2)\n       if (arg[i].flag != -1)\n \tcontinue;\n \n-      if (arg[i].sym && arg[i].sym->attr.optional)\n-\tcontinue;\t\t/* Skip optional arguments.  */\n+      if (arg[i].sym && (arg[i].sym->attr.optional\n+\t\t\t || (p1 && strcmp (arg[i].sym->name, p1) == 0)))\n+\tcontinue;\t\t/* Skip OPTIONAL and PASS arguments.  */\n \n       arg[i].flag = k;\n \n-      /* Find other nonoptional arguments of the same type/rank.  */\n+      /* Find other non-optional, non-pass arguments of the same type/rank.  */\n       for (j = i + 1; j < n1; j++)\n-\tif ((arg[j].sym == NULL || !arg[j].sym->attr.optional)\n+\tif ((arg[j].sym == NULL\n+\t     || !(arg[j].sym->attr.optional\n+\t\t  || (p1 && strcmp (arg[j].sym->name, p1) == 0)))\n \t    && (compare_type_rank_if (arg[i].sym, arg[j].sym)\n \t        || compare_type_rank_if (arg[j].sym, arg[i].sym)))\n \t  arg[j].flag = k;\n@@ -897,13 +901,14 @@ count_types_test (gfc_formal_arglist *f1, gfc_formal_arglist *f2)\n \tif (arg[j].flag == k)\n \t  ac1++;\n \n-      /* Count the number of arguments in f2 with that type, including\n-\t those that are optional.  */\n+      /* Count the number of non-pass arguments in f2 with that type,\n+\t including those that are optional.  */\n       ac2 = 0;\n \n       for (f = f2; f; f = f->next)\n-\tif (compare_type_rank_if (arg[i].sym, f->sym)\n-\t    || compare_type_rank_if (f->sym, arg[i].sym))\n+\tif ((!p2 || strcmp (f->sym->name, p2) != 0)\n+\t    && (compare_type_rank_if (arg[i].sym, f->sym)\n+\t\t|| compare_type_rank_if (f->sym, arg[i].sym)))\n \t  ac2++;\n \n       if (ac1 > ac2)\n@@ -921,9 +926,10 @@ count_types_test (gfc_formal_arglist *f1, gfc_formal_arglist *f2)\n }\n \n \n-/* Perform the correspondence test in rule 2 of section 14.1.2.3.\n-   Returns zero if no argument is found that satisfies rule 2, nonzero\n-   otherwise.\n+/* Perform the correspondence test in rule 3 of section F03:16.2.3.\n+   Returns zero if no argument is found that satisfies rule 3, nonzero\n+   otherwise. 'p1' and 'p2' are the PASS arguments of both procedures\n+   (if applicable).\n \n    This test is also not symmetric in f1 and f2 and must be called\n    twice.  This test finds problems caused by sorting the actual\n@@ -942,7 +948,8 @@ count_types_test (gfc_formal_arglist *f1, gfc_formal_arglist *f2)\n    At this point, 'CALL FOO(A=1, B=1.0)' is ambiguous.  */\n \n static int\n-generic_correspondence (gfc_formal_arglist *f1, gfc_formal_arglist *f2)\n+generic_correspondence (gfc_formal_arglist *f1, gfc_formal_arglist *f2,\n+\t\t\tconst char *p1, const char *p2)\n {\n   gfc_formal_arglist *f2_save, *g;\n   gfc_symbol *sym;\n@@ -954,6 +961,11 @@ generic_correspondence (gfc_formal_arglist *f1, gfc_formal_arglist *f2)\n       if (f1->sym->attr.optional)\n \tgoto next;\n \n+      if (p1 && strcmp (f1->sym->name, p1) == 0)\n+\tf1 = f1->next;\n+      if (f2 && p2 && strcmp (f2->sym->name, p2) == 0)\n+\tf2 = f2->next;\n+\n       if (f2 != NULL && (compare_type_rank (f1->sym, f2->sym)\n \t\t\t || compare_type_rank (f2->sym, f1->sym)))\n \tgoto next;\n@@ -962,7 +974,7 @@ generic_correspondence (gfc_formal_arglist *f1, gfc_formal_arglist *f2)\n \t the current non-match.  */\n       for (g = f1; g; g = g->next)\n \t{\n-\t  if (g->sym->attr.optional)\n+\t  if (g->sym->attr.optional || (p1 && strcmp (g->sym->name, p1) == 0))\n \t    continue;\n \n \t  sym = find_keyword_arg (g->sym->name, f2_save);\n@@ -971,7 +983,8 @@ generic_correspondence (gfc_formal_arglist *f1, gfc_formal_arglist *f2)\n \t}\n \n     next:\n-      f1 = f1->next;\n+      if (f1 != NULL)\n+\tf1 = f1->next;\n       if (f2 != NULL)\n \tf2 = f2->next;\n     }\n@@ -1129,12 +1142,14 @@ check_dummy_characteristics (gfc_symbol *s1, gfc_symbol *s2,\n    We return nonzero if there exists an actual argument list that\n    would be ambiguous between the two interfaces, zero otherwise.\n    'strict_flag' specifies whether all the characteristics are\n-   required to match, which is not the case for ambiguity checks.*/\n+   required to match, which is not the case for ambiguity checks.\n+   'p1' and 'p2' are the PASS arguments of both procedures (if applicable).  */\n \n int\n gfc_compare_interfaces (gfc_symbol *s1, gfc_symbol *s2, const char *name2,\n \t\t\tint generic_flag, int strict_flag,\n-\t\t\tchar *errmsg, int err_len)\n+\t\t\tchar *errmsg, int err_len,\n+\t\t\tconst char *p1, const char *p2)\n {\n   gfc_formal_arglist *f1, *f2;\n \n@@ -1200,9 +1215,11 @@ gfc_compare_interfaces (gfc_symbol *s1, gfc_symbol *s2, const char *name2,\n \n   if (generic_flag)\n     {\n-      if (count_types_test (f1, f2) || count_types_test (f2, f1))\n+      if (count_types_test (f1, f2, p1, p2)\n+\t  || count_types_test (f2, f1, p2, p1))\n \treturn 0;\n-      if (generic_correspondence (f1, f2) || generic_correspondence (f2, f1))\n+      if (generic_correspondence (f1, f2, p1, p2)\n+\t  || generic_correspondence (f2, f1, p2, p1))\n \treturn 0;\n     }\n   else\n@@ -1349,7 +1366,7 @@ check_interface1 (gfc_interface *p, gfc_interface *q0,\n \tif (p->sym->attr.flavor != FL_DERIVED\n \t    && q->sym->attr.flavor != FL_DERIVED\n \t    && gfc_compare_interfaces (p->sym, q->sym, q->sym->name,\n-\t\t\t\t       generic_flag, 0, NULL, 0))\n+\t\t\t\t       generic_flag, 0, NULL, 0, NULL, NULL))\n \t  {\n \t    if (referenced)\n \t      gfc_error (\"Ambiguous interfaces '%s' and '%s' in %s at %L\",\n@@ -1676,7 +1693,7 @@ compare_parameter (gfc_symbol *formal, gfc_expr *actual,\n \t}\n \n       if (!gfc_compare_interfaces (formal, act_sym, act_sym->name, 0, 1, err,\n-\t\t\t\t   sizeof(err)))\n+\t\t\t\t   sizeof(err), NULL, NULL))\n \t{\n \t  if (where)\n \t    gfc_error (\"Interface mismatch in dummy procedure '%s' at %L: %s\","}, {"sha": "4595f76c9a4ec72a806f1609008c296b9c63879f", "filename": "gcc/fortran/resolve.c", "status": "modified", "additions": 16, "deletions": 4, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6f3ab30d8b7bfa0ab2e5a370f1196602960c271c/gcc%2Ffortran%2Fresolve.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6f3ab30d8b7bfa0ab2e5a370f1196602960c271c/gcc%2Ffortran%2Fresolve.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fresolve.c?ref=6f3ab30d8b7bfa0ab2e5a370f1196602960c271c", "patch": "@@ -1152,7 +1152,7 @@ resolve_structure_cons (gfc_expr *expr, int init)\n \t    }\n \n \t  if (s2 && !gfc_compare_interfaces (comp->ts.interface, s2, name, 0, 1,\n-\t\t\t\t\t     err, sizeof (err)))\n+\t\t\t\t\t     err, sizeof (err), NULL, NULL))\n \t    {\n \t      gfc_error (\"Interface mismatch for procedure-pointer component \"\n \t\t\t \"'%s' in structure constructor at %L: %s\",\n@@ -11020,8 +11020,8 @@ static gfc_try\n check_generic_tbp_ambiguity (gfc_tbp_generic* t1, gfc_tbp_generic* t2,\n \t\t\t     const char* generic_name, locus where)\n {\n-  gfc_symbol* sym1;\n-  gfc_symbol* sym2;\n+  gfc_symbol *sym1, *sym2;\n+  const char *pass1, *pass2;\n \n   gcc_assert (t1->specific && t2->specific);\n   gcc_assert (!t1->specific->is_generic);\n@@ -11045,8 +11045,20 @@ check_generic_tbp_ambiguity (gfc_tbp_generic* t1, gfc_tbp_generic* t2,\n     }\n \n   /* Compare the interfaces.  */\n+  if (t1->specific->nopass)\n+    pass1 = NULL;\n+  else if (t1->specific->pass_arg)\n+    pass1 = t1->specific->pass_arg;\n+  else\n+    pass1 = t1->specific->u.specific->n.sym->formal->sym->name;\n+  if (t2->specific->nopass)\n+    pass2 = NULL;\n+  else if (t2->specific->pass_arg)\n+    pass2 = t2->specific->pass_arg;\n+  else\n+    pass2 = t2->specific->u.specific->n.sym->formal->sym->name;  \n   if (gfc_compare_interfaces (sym1, sym2, sym2->name, !t1->is_operator, 0,\n-\t\t\t      NULL, 0))\n+\t\t\t      NULL, 0, pass1, pass2))\n     {\n       gfc_error (\"'%s' and '%s' for GENERIC '%s' at %L are ambiguous\",\n \t\t sym1->name, sym2->name, generic_name, &where);"}, {"sha": "0e67aa0f590fbb5ee4b53cb12391b5baf036f80b", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6f3ab30d8b7bfa0ab2e5a370f1196602960c271c/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6f3ab30d8b7bfa0ab2e5a370f1196602960c271c/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=6f3ab30d8b7bfa0ab2e5a370f1196602960c271c", "patch": "@@ -1,3 +1,10 @@\n+2012-06-22  Janus Weil  <janus@gcc.gnu.org>\n+\n+\tPR fortran/47710\n+\tPR fortran/53328\n+\t* gfortran.dg/typebound_generic_12.f03: New.\n+\t* gfortran.dg/typebound_generic_13.f03: New.\n+\n 2012-06-22  Eric Botcazou  <ebotcazou@adacore.com>\n \n \t* gnat.dg/lto15.ad[sb]: New test."}, {"sha": "061a41a07f3413b47d22440ed610c2eb2dc718a5", "filename": "gcc/testsuite/gfortran.dg/typebound_generic_12.f03", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6f3ab30d8b7bfa0ab2e5a370f1196602960c271c/gcc%2Ftestsuite%2Fgfortran.dg%2Ftypebound_generic_12.f03", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6f3ab30d8b7bfa0ab2e5a370f1196602960c271c/gcc%2Ftestsuite%2Fgfortran.dg%2Ftypebound_generic_12.f03", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Ftypebound_generic_12.f03?ref=6f3ab30d8b7bfa0ab2e5a370f1196602960c271c", "patch": "@@ -0,0 +1,26 @@\n+! { dg-do compile }\n+!\n+! PR 53328: [OOP] Ambiguous check for type-bound GENERIC shall ignore PASSed arguments\n+!\n+! Contributed by Salvatore Filippone <filippone.salvatore@gmail.com>\n+\n+module m\n+  type t\n+  contains\n+    procedure, pass(this) :: sub1\n+    procedure, pass(this) :: sub2\n+    generic :: gen => sub1, sub2   ! { dg-error \"are ambiguous\" }\n+  end type t\n+contains\n+  subroutine sub1 (x, this)\n+    integer :: i\n+    class(t) :: this\n+  end subroutine sub1\n+\n+  subroutine sub2 (this, y)\n+    integer :: i\n+    class(t) :: this\n+  end subroutine sub2\n+end module m \n+\n+! { dg-final { cleanup-modules \"m\" } }"}, {"sha": "c2116e965a8cb392d462d680c38a8633b982d7ea", "filename": "gcc/testsuite/gfortran.dg/typebound_generic_13.f03", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6f3ab30d8b7bfa0ab2e5a370f1196602960c271c/gcc%2Ftestsuite%2Fgfortran.dg%2Ftypebound_generic_13.f03", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6f3ab30d8b7bfa0ab2e5a370f1196602960c271c/gcc%2Ftestsuite%2Fgfortran.dg%2Ftypebound_generic_13.f03", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Ftypebound_generic_13.f03?ref=6f3ab30d8b7bfa0ab2e5a370f1196602960c271c", "patch": "@@ -0,0 +1,28 @@\n+! { dg-do compile }\n+!\n+! PR 47710: [OOP] Improve ambiguity check for GENERIC TBP w/ PASS and NOPASS\n+!\n+! Contributed by Janus Weil <janus@gcc.gnu.org>\n+\n+module m\n+\n+  type base_t\n+  contains\n+    procedure, nopass :: baseproc_nopass => baseproc1\n+    procedure, pass   :: baseproc_pass => baseproc2\n+    generic           :: some_proc => baseproc_pass, baseproc_nopass   ! { dg-error \"are ambiguous\" }\n+  end type\n+\n+contains\n+\n+  subroutine baseproc1 (this)\n+    class(base_t) :: this\n+  end subroutine\n+\n+  subroutine baseproc2 (this, that)\n+    class(base_t) :: this, that\n+  end subroutine\n+\n+end module\n+\n+! { dg-final { cleanup-modules \"m\" } }"}]}