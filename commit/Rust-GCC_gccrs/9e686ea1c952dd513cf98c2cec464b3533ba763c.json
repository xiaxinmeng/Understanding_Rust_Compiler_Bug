{"sha": "9e686ea1c952dd513cf98c2cec464b3533ba763c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OWU2ODZlYTFjOTUyZGQ1MTNjZjk4YzJjZWM0NjRiMzUzM2JhNzYzYw==", "commit": {"author": {"name": "Alexander Monakov", "email": "amonakov@ispras.ru", "date": "2017-09-29T16:00:15Z"}, "committer": {"name": "Alexander Monakov", "email": "amonakov@gcc.gnu.org", "date": "2017-09-29T16:00:15Z"}, "message": "qsort comparator consistency checking\n\n\t* genmodes.c (calc_wider_mode): Suppress qsort macro.\n\t* system.h [CHECKING_P] (qsort): Redirect to qsort_chk.\n\t(qsort_chk): Declare.\n\t* vec.c [CHECKING_P] (qsort_chk_error): New static function.\n\t(qsort_chk): New function.\n\nFrom-SVN: r253295", "tree": {"sha": "1cfc0484d5e64853823c1322638c2787aa3877ce", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1cfc0484d5e64853823c1322638c2787aa3877ce"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/9e686ea1c952dd513cf98c2cec464b3533ba763c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9e686ea1c952dd513cf98c2cec464b3533ba763c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9e686ea1c952dd513cf98c2cec464b3533ba763c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9e686ea1c952dd513cf98c2cec464b3533ba763c/comments", "author": {"login": "amonakov", "id": 1997391, "node_id": "MDQ6VXNlcjE5OTczOTE=", "avatar_url": "https://avatars.githubusercontent.com/u/1997391?v=4", "gravatar_id": "", "url": "https://api.github.com/users/amonakov", "html_url": "https://github.com/amonakov", "followers_url": "https://api.github.com/users/amonakov/followers", "following_url": "https://api.github.com/users/amonakov/following{/other_user}", "gists_url": "https://api.github.com/users/amonakov/gists{/gist_id}", "starred_url": "https://api.github.com/users/amonakov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/amonakov/subscriptions", "organizations_url": "https://api.github.com/users/amonakov/orgs", "repos_url": "https://api.github.com/users/amonakov/repos", "events_url": "https://api.github.com/users/amonakov/events{/privacy}", "received_events_url": "https://api.github.com/users/amonakov/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "cd644ae2bc0ce62b88f786ce5a68ad0ba2509ec6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cd644ae2bc0ce62b88f786ce5a68ad0ba2509ec6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cd644ae2bc0ce62b88f786ce5a68ad0ba2509ec6"}], "stats": {"total": 113, "additions": 112, "deletions": 1}, "files": [{"sha": "dfabde55a1c00d36cade190b0ce3292ba3187ed4", "filename": "gcc/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9e686ea1c952dd513cf98c2cec464b3533ba763c/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9e686ea1c952dd513cf98c2cec464b3533ba763c/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=9e686ea1c952dd513cf98c2cec464b3533ba763c", "patch": "@@ -1,3 +1,11 @@\n+2017-09-29  Alexander Monakov  <amonakov@ispras.ru>\n+\n+\t* genmodes.c (calc_wider_mode): Suppress qsort macro.\n+\t* system.h [CHECKING_P] (qsort): Redirect to qsort_chk.\n+\t(qsort_chk): Declare.\n+\t* vec.c [CHECKING_P] (qsort_chk_error): New static function.\n+\t(qsort_chk): New function.\n+\n 2017-09-29  Bill Schmidt  <wschmidt@linux.vnet.ibm.com>\n \n \tPR tree-optimization/82337"}, {"sha": "4eb8ee56d8808fd59298cdc26ed83b055af2bd2b", "filename": "gcc/genmodes.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9e686ea1c952dd513cf98c2cec464b3533ba763c/gcc%2Fgenmodes.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9e686ea1c952dd513cf98c2cec464b3533ba763c/gcc%2Fgenmodes.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgenmodes.c?ref=9e686ea1c952dd513cf98c2cec464b3533ba763c", "patch": "@@ -880,7 +880,7 @@ calc_wider_mode (void)\n \t  for (i = 0, m = modes[c]; m; i++, m = m->next)\n \t    sortbuf[i] = m;\n \n-\t  qsort (sortbuf, i, sizeof (struct mode_data *), cmp_modes);\n+\t  (qsort) (sortbuf, i, sizeof (struct mode_data *), cmp_modes);\n \n \t  sortbuf[i] = 0;\n \t  for (j = 0; j < i; j++)"}, {"sha": "f0664e93fc88ca5aebfa6c6619e638dd7e62e346", "filename": "gcc/system.h", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9e686ea1c952dd513cf98c2cec464b3533ba763c/gcc%2Fsystem.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9e686ea1c952dd513cf98c2cec464b3533ba763c/gcc%2Fsystem.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsystem.h?ref=9e686ea1c952dd513cf98c2cec464b3533ba763c", "patch": "@@ -1181,4 +1181,14 @@ helper_const_non_const_cast (const char *p)\n /* Get definitions of HOST_WIDE_INT.  */\n #include \"hwint.h\"\n \n+/* qsort comparator consistency checking: except in release-checking compilers,\n+   redirect 4-argument qsort calls to qsort_chk; keep 1-argument invocations\n+   corresponding to vec::qsort (cmp): they use C qsort internally anyway.  */\n+#if CHECKING_P\n+#define PP_5th(a1, a2, a3, a4, a5, ...) a5\n+#undef qsort\n+#define qsort(...) PP_5th (__VA_ARGS__, qsort_chk, 3, 2, qsort, 0) (__VA_ARGS__)\n+void qsort_chk (void *, size_t, size_t, int (*)(const void *, const void *));\n+#endif\n+\n #endif /* ! GCC_SYSTEM_H */"}, {"sha": "9a80f3421dbe685b8eea02200ea2459c94223bad", "filename": "gcc/vec.c", "status": "modified", "additions": 93, "deletions": 0, "changes": 93, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9e686ea1c952dd513cf98c2cec464b3533ba763c/gcc%2Fvec.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9e686ea1c952dd513cf98c2cec464b3533ba763c/gcc%2Fvec.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvec.c?ref=9e686ea1c952dd513cf98c2cec464b3533ba763c", "patch": "@@ -31,6 +31,12 @@ along with GCC; see the file COPYING3.  If not see\n #include \"coretypes.h\"\n #include \"hash-table.h\"\n #include \"selftest.h\"\n+#ifdef GENERATOR_FILE\n+#include \"errors.h\"\n+#else\n+#include \"input.h\"\n+#include \"diagnostic-core.h\"\n+#endif\n \n /* vNULL is an empty type with a template cast operation that returns\n    a zero-initialized vec<T, A, L> instance.  Use this when you want\n@@ -190,6 +196,93 @@ dump_vec_loc_statistics (void)\n   vec_mem_desc.dump (VEC_ORIGIN);\n }\n \n+#if CHECKING_P\n+/* Report qsort comparator CMP consistency check failure with P1, P2, P3 as\n+   witness elements.  */\n+ATTRIBUTE_NORETURN ATTRIBUTE_COLD\n+static void\n+qsort_chk_error (const void *p1, const void *p2, const void *p3,\n+\t\t int (*cmp) (const void *, const void *))\n+{\n+  if (!p3)\n+    {\n+      int r1 = cmp (p1, p2), r2 = cmp (p2, p1);\n+      error (\"qsort comparator not anti-commutative: %d, %d\", r1, r2);\n+    }\n+  else if (p1 == p2)\n+    {\n+      int r = cmp (p1, p3);\n+      error (\"qsort comparator non-negative on sorted output: %d\", r);\n+    }\n+  else\n+    {\n+      int r1 = cmp (p1, p2), r2 = cmp (p2, p3), r3 = cmp (p1, p3);\n+      error (\"qsort comparator not transitive: %d, %d, %d\", r1, r2, r3);\n+    }\n+  internal_error (\"qsort checking failed\");\n+}\n+\n+/* Wrapper around qsort with checking that CMP is consistent on given input.\n+\n+   Strictly speaking, passing invalid (non-transitive, non-anti-commutative)\n+   comparators to libc qsort can result in undefined behavior.  Therefore we\n+   should ideally perform consistency checks prior to invoking qsort, but in\n+   order to do that optimally we'd need to sort the array ourselves beforehand\n+   with a sorting routine known to be \"safe\".  Instead, we expect that most\n+   implementations in practice will still produce some permutation of input\n+   array even for invalid comparators, which enables us to perform checks on\n+   the output array.  */\n+void\n+qsort_chk (void *base, size_t n, size_t size,\n+\t   int (*cmp)(const void *, const void *))\n+{\n+  (qsort) (base, n, size, cmp);\n+#if 0\n+#define LIM(n) (n)\n+#else\n+  /* Limit overall time complexity to O(n log n).  */\n+#define LIM(n) ((n) <= 16 ? (n) : 12 + floor_log2 (n))\n+#endif\n+#define ELT(i) ((const char *) base + (i) * size)\n+#define CMP(i, j) cmp (ELT (i), ELT (j))\n+#define ERR2(i, j) qsort_chk_error (ELT (i), ELT (j), NULL, cmp)\n+#define ERR3(i, j, k) qsort_chk_error (ELT (i), ELT (j), ELT (k), cmp)\n+  size_t i1, i2, i, j;\n+  /* This outer loop iterates over maximum spans [i1, i2) such that\n+     elements within each span compare equal to each other.  */\n+  for (i1 = 0; i1 < n; i1 = i2)\n+    {\n+      /* Position i2 one past last element that compares equal to i1'th.  */\n+      for (i2 = i1 + 1; i2 < n; i2++)\n+\tif (CMP (i1, i2))\n+\t  break;\n+\telse if (CMP (i2, i1))\n+\t  return ERR2 (i1, i2);\n+      size_t lim1 = LIM (i2 - i1), lim2 = LIM (n - i2);\n+      /* Verify that other pairs within current span compare equal.  */\n+      for (i = i1 + 1; i + 1 < i2; i++)\n+\tfor (j = i + 1; j < i1 + lim1; j++)\n+\t  if (CMP (i, j))\n+\t    return ERR3 (i, i1, j);\n+\t  else if (CMP (j, i))\n+\t    return ERR2 (i, j);\n+      /* Verify that elements within this span compare less than\n+         elements beyond the span.  */\n+      for (i = i1; i < i2; i++)\n+\tfor (j = i2; j < i2 + lim2; j++)\n+\t  if (CMP (i, j) >= 0)\n+\t    return ERR3 (i, i1, j);\n+\t  else if (CMP (j, i) <= 0)\n+\t    return ERR2 (i, j);\n+    }\n+#undef ERR3\n+#undef ERR2\n+#undef CMP\n+#undef ELT\n+#undef LIM\n+}\n+#endif /* #if CHECKING_P */\n+\n #ifndef GENERATOR_FILE\n #if CHECKING_P\n "}]}