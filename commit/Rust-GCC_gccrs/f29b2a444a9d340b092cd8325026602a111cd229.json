{"sha": "f29b2a444a9d340b092cd8325026602a111cd229", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjI5YjJhNDQ0YTlkMzQwYjA5MmNkODMyNTAyNjYwMmExMTFjZDIyOQ==", "commit": {"author": {"name": "Richard Stallman", "email": "rms@gnu.org", "date": "1993-03-31T20:39:19Z"}, "committer": {"name": "Richard Stallman", "email": "rms@gnu.org", "date": "1993-03-31T20:39:19Z"}, "message": "(PRINT_OPERAND, ASM_OUTPUT_FLOAT, ASM_OUTPUT_DOUBLE):\n\nUse new REAL_VALUE... macros.\n(CHECK_FLOAT_VALUE): Call check_float_value.\n\nFrom-SVN: r3957", "tree": {"sha": "f1d2ca9f8f67419f864257dd5edaf323385b8e41", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f1d2ca9f8f67419f864257dd5edaf323385b8e41"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f29b2a444a9d340b092cd8325026602a111cd229", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f29b2a444a9d340b092cd8325026602a111cd229", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f29b2a444a9d340b092cd8325026602a111cd229", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f29b2a444a9d340b092cd8325026602a111cd229/comments", "author": null, "committer": null, "parents": [{"sha": "c42cb1965dd5a96e2f599bc5d35048f2cc60f58f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c42cb1965dd5a96e2f599bc5d35048f2cc60f58f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c42cb1965dd5a96e2f599bc5d35048f2cc60f58f"}], "stats": {"total": 49, "additions": 23, "deletions": 26}, "files": [{"sha": "351a2f689749dc5a0ae925b3871b0ce916e1b13a", "filename": "gcc/config/vax/vax.h", "status": "modified", "additions": 23, "deletions": 26, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f29b2a444a9d340b092cd8325026602a111cd229/gcc%2Fconfig%2Fvax%2Fvax.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f29b2a444a9d340b092cd8325026602a111cd229/gcc%2Fconfig%2Fvax%2Fvax.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fvax%2Fvax.h?ref=f29b2a444a9d340b092cd8325026602a111cd229", "patch": "@@ -1,5 +1,5 @@\n /* Definitions of target machine for GNU compiler.  Vax version.\n-   Copyright (C) 1987, 1988, 1991 Free Software Foundation, Inc.\n+   Copyright (C) 1987, 1988, 1991, 1993 Free Software Foundation, Inc.\n \n This file is part of GNU CC.\n \n@@ -79,6 +79,10 @@ extern int target_flags;\n \f\n /* Target machine storage layout */\n \n+/* Define for software floating point emulation of VAX format\n+   when cross compiling from a non-VAX host. */\n+/* #define REAL_ARITHMETIC */\n+\n /* Define this if most significant bit is lowest numbered\n    in instructions that operate on numbered bit-fields.\n    This is not true on the vax.  */\n@@ -898,22 +902,8 @@ gen_rtx (PLUS, Pmode, frame, gen_rtx (CONST_INT, VOIDmode, 12))\n \n /* note that it is very hard to accidentally create a number that fits in a\n    double but not in a float, since their ranges are almost the same */\n-#define CHECK_FLOAT_VALUE(mode, d) \\\n-  if ((mode) == SFmode) \\\n-    { \\\n-      if ((d) > 1.7014117331926444e+38) \\\n-\t{ error (\"magnitude of constant too large for `float'\"); \\\n-\t  (d) = 1.7014117331926444e+38; } \\\n-      else if ((d) < -1.7014117331926444e+38) \\\n-\t{ error (\"magnitude of constant too large for `float'\"); \\\n-\t  (d) = -1.7014117331926444e+38; } \\\n-      else if (((d) > 0) && ((d) < 2.9387358770557188e-39)) \\\n-\t{ warning (\"`float' constant truncated to zero\"); \\\n-\t  (d) = 0.0; } \\\n-      else if (((d) < 0) && ((d) > -2.9387358770557188e-39)) \\\n-\t{ warning (\"`float' constant truncated to zero\"); \\\n-\t  (d) = 0.0; } \\\n-    }\n+\n+#define CHECK_FLOAT_VALUE(mode, d) (check_float_value (mode, &d))\n \n /* For future reference:\n    D Float: 9 bit, sign magnitude, excess 128 binary exponent\n@@ -1075,13 +1065,18 @@ gen_rtx (PLUS, Pmode, frame, gen_rtx (CONST_INT, VOIDmode, 12))\n    It is .dfloat or .gfloat, depending.  */\n \n #define ASM_OUTPUT_DOUBLE(FILE,VALUE)  \\\n-  fprintf (FILE, \"\\t.%cfloat 0%c%.20e\\n\", ASM_DOUBLE_CHAR, \\\n-\t\t\t\t\t  ASM_DOUBLE_CHAR, (VALUE))\n+do { char dstr[30];\t\t\t\t\t\t\t\\\n+     REAL_VALUE_TO_DECIMAL (VALUE, \"%.20e\", dstr);\t\t\t\\\n+     fprintf (FILE, \"\\t.%cfloat 0%c%s\\n\", ASM_DOUBLE_CHAR, \t\t\\\n+\t\t\t\t\t  ASM_DOUBLE_CHAR, dstr);\t\\\n+   } while (0);\n \n /* This is how to output an assembler line defining a `float' constant.  */\n \n #define ASM_OUTPUT_FLOAT(FILE,VALUE)  \\\n-  fprintf (FILE, \"\\t.float 0f%.20e\\n\", (VALUE))\n+  do { char dstr[30];\t\t\t\t\t\t\\\n+       REAL_VALUE_TO_DECIMAL (VALUE, \"%.20e\", dstr);\t\t\\\n+       fprintf (FILE, \"\\t.float 0f%s\\n\", dstr); } while (0);\n \n /* This is how to output an assembler line defining an `int' constant.  */\n \n@@ -1238,13 +1233,15 @@ VAX operand formatting codes:\n   else if (GET_CODE (X) == MEM)\t\t\t\t\t\t\\\n     output_address (XEXP (X, 0));\t\t\t\t\t\\\n   else if (GET_CODE (X) == CONST_DOUBLE && GET_MODE (X) == SFmode)\t\\\n-    { union { double d; int i[2]; } u;\t\t\t\t\t\\\n-      u.i[0] = CONST_DOUBLE_LOW (X); u.i[1] = CONST_DOUBLE_HIGH (X);\t\\\n-      fprintf (FILE, \"$0f%.20e\", u.d); }\t\t\t\t\\\n+    { REAL_VALUE_TYPE r; char dstr[30];\t\t\t\t\t\\\n+      REAL_VALUE_FROM_CONST_DOUBLE (r, X);\t\t\t\t\\\n+      REAL_VALUE_TO_DECIMAL (r, \"%.20e\", dstr);\t\t\t\t\\\n+      fprintf (FILE, \"$0f%s\", dstr); }\t\t\t\t\t\\\n   else if (GET_CODE (X) == CONST_DOUBLE && GET_MODE (X) == DFmode)\t\\\n-    { union { double d; int i[2]; } u;\t\t\t\t\t\\\n-      u.i[0] = CONST_DOUBLE_LOW (X); u.i[1] = CONST_DOUBLE_HIGH (X);\t\\\n-      fprintf (FILE, \"$0%c%.20e\", ASM_DOUBLE_CHAR, u.d); }\t\t\\\n+    { REAL_VALUE_TYPE r; char dstr[30];\t\t\t\t\t\\\n+      REAL_VALUE_FROM_CONST_DOUBLE (r, X);\t\t\t\t\\\n+      REAL_VALUE_TO_DECIMAL (r, \"%.20e\", dstr);\t\t\t\t\\\n+      fprintf (FILE, \"$0%c%s\", ASM_DOUBLE_CHAR, dstr); }\t\t\\\n   else { putc ('$', FILE); output_addr_const (FILE, X); }}\n \n /* Print a memory operand whose address is X, on file FILE."}]}