{"sha": "9200ac720c5fe547870939a0a1ec5c8d72ad7aff", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTIwMGFjNzIwYzVmZTU0Nzg3MDkzOWEwYTFlYzVjOGQ3MmFkN2FmZg==", "commit": {"author": {"name": "Uros Bizjak", "email": "ubizjak@gmail.com", "date": "2010-04-11T14:04:35Z"}, "committer": {"name": "Uros Bizjak", "email": "uros@gcc.gnu.org", "date": "2010-04-11T14:04:35Z"}, "message": "i386.md (lshr<mode>3): Macroize expander from lshr{qi,hi,si,di,ti}3_1 using SDWIM mode iterator.\n\n\t* config/i386/i386.md (lshr<mode>3): Macroize expander from\n\tlshr{qi,hi,si,di,ti}3_1 using SDWIM mode iterator.\n\t(*lshr<mode>3_doubleword): New insn_and_split_pattern.  Macroize\n\tpattern from *lshr{di,ti}3_1 and corresponding splitters using\n\tDWI mode iterator.\n\t(*lshr<mode>3_doubleword peephole2): Macroize peephole2 pattern\n\tfrom corresponding peephole2 patterns.\n\t(*lshr<mode>3_1): Merge with *lshr{qi,hi,si}3_1_one_bit and\n\t*lshrdi3_1_one_bit_rex64. Macroize insn from *lshr{qi,hi,si}3_cmp\n\tand *lshrdi3_cmp_rex64 using SWI mode iterator.\n\t(*lshrqi3_1_slp): Merge with *lshrqi3_1_one_bit_slp.\n\t(*lshr<mode>3_cmp): Merge with *lshr{qi,hi,si}3_one_bit_cmp and\n\t*lshrdi3_one_bit_cmp_rex64. Macroize insn from *lshr{qi,hi,si}3_cmp\n\tand *lshrdi3_cmp_rex64 using SWI mode iterator.\n\t(*lshrsi3_cmp_zext): Merge with *lshrsi3_cmp_one_bit_zext.\n\t(*lshr<mode>3_cconly): Merge with *lshr{qi,hi,si}3_one_bit_cconly and\n\t*lshrdi3_one_bit_cconly_rex64. Macroize insn from\n\t*lshr{qi,hi,si}3_cconly and *lshrdi3_cconly_rex64 using\n\tSWI mode iterator.\n\nFrom-SVN: r158203", "tree": {"sha": "1310b7db4bf0320909f3f68257d451e4be53c585", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1310b7db4bf0320909f3f68257d451e4be53c585"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/9200ac720c5fe547870939a0a1ec5c8d72ad7aff", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9200ac720c5fe547870939a0a1ec5c8d72ad7aff", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9200ac720c5fe547870939a0a1ec5c8d72ad7aff", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9200ac720c5fe547870939a0a1ec5c8d72ad7aff/comments", "author": {"login": "ubizjak", "id": 55479990, "node_id": "MDQ6VXNlcjU1NDc5OTkw", "avatar_url": "https://avatars.githubusercontent.com/u/55479990?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ubizjak", "html_url": "https://github.com/ubizjak", "followers_url": "https://api.github.com/users/ubizjak/followers", "following_url": "https://api.github.com/users/ubizjak/following{/other_user}", "gists_url": "https://api.github.com/users/ubizjak/gists{/gist_id}", "starred_url": "https://api.github.com/users/ubizjak/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ubizjak/subscriptions", "organizations_url": "https://api.github.com/users/ubizjak/orgs", "repos_url": "https://api.github.com/users/ubizjak/repos", "events_url": "https://api.github.com/users/ubizjak/events{/privacy}", "received_events_url": "https://api.github.com/users/ubizjak/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "3cd64bab882b6bebb364ba7df6da511552124feb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3cd64bab882b6bebb364ba7df6da511552124feb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3cd64bab882b6bebb364ba7df6da511552124feb"}], "stats": {"total": 709, "additions": 197, "deletions": 512}, "files": [{"sha": "f718ae0d62c42011fe0f728b87d9a9652d350a7b", "filename": "gcc/ChangeLog", "status": "modified", "additions": 24, "deletions": 2, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9200ac720c5fe547870939a0a1ec5c8d72ad7aff/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9200ac720c5fe547870939a0a1ec5c8d72ad7aff/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=9200ac720c5fe547870939a0a1ec5c8d72ad7aff", "patch": "@@ -1,3 +1,25 @@\n+2010-04-11  Uros Bizjak  <ubizjak@gmail.com>\n+\n+\t* config/i386/i386.md (lshr<mode>3): Macroize expander from\n+\tlshr{qi,hi,si,di,ti}3_1 using SDWIM mode iterator.\n+\t(*lshr<mode>3_doubleword): New insn_and_split_pattern.  Macroize\n+\tpattern from *lshr{di,ti}3_1 and corresponding splitters using\n+\tDWI mode iterator.\n+\t(*lshr<mode>3_doubleword peephole2): Macroize peephole2 pattern\n+\tfrom corresponding peephole2 patterns.\n+\t(*lshr<mode>3_1): Merge with *lshr{qi,hi,si}3_1_one_bit and\n+\t*lshrdi3_1_one_bit_rex64. Macroize insn from *lshr{qi,hi,si}3_cmp\n+\tand *lshrdi3_cmp_rex64 using SWI mode iterator.\n+\t(*lshrqi3_1_slp): Merge with *lshrqi3_1_one_bit_slp.\n+\t(*lshr<mode>3_cmp): Merge with *lshr{qi,hi,si}3_one_bit_cmp and\n+\t*lshrdi3_one_bit_cmp_rex64. Macroize insn from *lshr{qi,hi,si}3_cmp\n+\tand *lshrdi3_cmp_rex64 using SWI mode iterator.\n+\t(*lshrsi3_cmp_zext): Merge with *lshrsi3_cmp_one_bit_zext.\n+\t(*lshr<mode>3_cconly): Merge with *lshr{qi,hi,si}3_one_bit_cconly and\n+\t*lshrdi3_one_bit_cconly_rex64. Macroize insn from\n+\t*lshr{qi,hi,si}3_cconly and *lshrdi3_cconly_rex64 using\n+\tSWI mode iterator.\n+\n 2010-04-10  Uros Bizjak  <ubizjak@gmail.com>\n \n \t* config/i386/i386.md (ashr<mode>3): Macroize expander from\n@@ -24,9 +46,9 @@\n \t*ashrdi3_one_bit_cconly_rex64. Macroize insn from\n \t*ashr{qi,hi,si}3_cconly and *ashrdi3_cconly_rex64 using\n \tSWI mode iterator.\n-\t(sign_extend splitters): Update for renamed ashr{di,si}3_patterns.\n+\t(sign_extend splitters): Update for renamed ashr{di,si}3_31 patterns.\n \t* config/i386/i386.c (ix86_split_ashr): Update for renamed\n-\tx86_shift<mode>_adj_3 expander.\n+\tx86_shift<mode>_adj_3 expanders.\n \n 2010-04-10  Wei Guozhi  <carrot@google.com>\n "}, {"sha": "03e4f38f9fde51036ba63a0cdd65cf256345def3", "filename": "gcc/config/i386/i386.md", "status": "modified", "additions": 173, "deletions": 510, "changes": 683, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9200ac720c5fe547870939a0a1ec5c8d72ad7aff/gcc%2Fconfig%2Fi386%2Fi386.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9200ac720c5fe547870939a0a1ec5c8d72ad7aff/gcc%2Fconfig%2Fi386%2Fi386.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.md?ref=9200ac720c5fe547870939a0a1ec5c8d72ad7aff", "patch": "@@ -10290,35 +10290,35 @@\n    (set_attr \"modrm\" \"0,1\")\n    (set_attr \"mode\" \"DI\")])\n \n-(define_insn \"*ashrsi3_cvt_zext\"\n-  [(set (match_operand:DI 0 \"register_operand\" \"=*d,r\")\n-\t(zero_extend:DI\n-\t  (ashiftrt:SI (match_operand:SI 1 \"register_operand\" \"*a,0\")\n-\t\t       (match_operand:QI 2 \"const_int_operand\" \"\"))))\n+(define_insn \"ashrsi3_cvt\"\n+  [(set (match_operand:SI 0 \"nonimmediate_operand\" \"=*d,rm\")\n+\t(ashiftrt:SI (match_operand:SI 1 \"nonimmediate_operand\" \"*a,0\")\n+\t\t     (match_operand:QI 2 \"const_int_operand\" \"\")))\n    (clobber (reg:CC FLAGS_REG))]\n-  \"TARGET_64BIT && INTVAL (operands[2]) == 31\n+  \"INTVAL (operands[2]) == 31\n    && (TARGET_USE_CLTD || optimize_function_for_size_p (cfun))\n    && ix86_binary_operator_ok (ASHIFTRT, SImode, operands)\"\n   \"@\n    {cltd|cdq}\n-   sar{l}\\t{%2, %k0|%k0, %2}\"\n+   sar{l}\\t{%2, %0|%0, %2}\"\n   [(set_attr \"type\" \"imovx,ishift\")\n    (set_attr \"prefix_0f\" \"0,*\")\n    (set_attr \"length_immediate\" \"0,*\")\n    (set_attr \"modrm\" \"0,1\")\n    (set_attr \"mode\" \"SI\")])\n \n-(define_insn \"ashrsi3_cvt\"\n-  [(set (match_operand:SI 0 \"nonimmediate_operand\" \"=*d,rm\")\n-\t(ashiftrt:SI (match_operand:SI 1 \"nonimmediate_operand\" \"*a,0\")\n-\t\t     (match_operand:QI 2 \"const_int_operand\" \"\")))\n+(define_insn \"*ashrsi3_cvt_zext\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"=*d,r\")\n+\t(zero_extend:DI\n+\t  (ashiftrt:SI (match_operand:SI 1 \"register_operand\" \"*a,0\")\n+\t\t       (match_operand:QI 2 \"const_int_operand\" \"\"))))\n    (clobber (reg:CC FLAGS_REG))]\n-  \"INTVAL (operands[2]) == 31\n+  \"TARGET_64BIT && INTVAL (operands[2]) == 31\n    && (TARGET_USE_CLTD || optimize_function_for_size_p (cfun))\n    && ix86_binary_operator_ok (ASHIFTRT, SImode, operands)\"\n   \"@\n    {cltd|cdq}\n-   sar{l}\\t{%2, %0|%0, %2}\"\n+   sar{l}\\t{%2, %k0|%k0, %2}\"\n   [(set_attr \"type\" \"imovx,ishift\")\n    (set_attr \"prefix_0f\" \"0,*\")\n    (set_attr \"length_immediate\" \"0,*\")\n@@ -10533,552 +10533,215 @@\n \n ;; See comment above `ashldi3' about how this works.\n \n-(define_expand \"lshrti3\"\n-  [(set (match_operand:TI 0 \"register_operand\" \"\")\n-\t(lshiftrt:TI (match_operand:TI 1 \"register_operand\" \"\")\n-\t\t     (match_operand:QI 2 \"nonmemory_operand\" \"\")))]\n-  \"TARGET_64BIT\"\n-  \"ix86_expand_binary_operator (LSHIFTRT, TImode, operands); DONE;\")\n-\n-(define_insn \"*lshrti3_1\"\n-  [(set (match_operand:TI 0 \"register_operand\" \"=r\")\n-\t(lshiftrt:TI (match_operand:TI 1 \"register_operand\" \"0\")\n-\t\t     (match_operand:QI 2 \"nonmemory_operand\" \"Oc\")))\n-   (clobber (reg:CC FLAGS_REG))]\n-  \"TARGET_64BIT\"\n-  \"#\"\n-  [(set_attr \"type\" \"multi\")])\n-\n-(define_peephole2\n-  [(match_scratch:DI 3 \"r\")\n-   (parallel [(set (match_operand:TI 0 \"register_operand\" \"\")\n-\t\t   (lshiftrt:TI (match_operand:TI 1 \"register_operand\" \"\")\n-\t\t\t        (match_operand:QI 2 \"nonmemory_operand\" \"\")))\n-\t      (clobber (reg:CC FLAGS_REG))])\n-   (match_dup 3)]\n-  \"TARGET_64BIT\"\n-  [(const_int 0)]\n-  \"ix86_split_lshr (operands, operands[3], TImode); DONE;\")\n-\n-(define_split\n-  [(set (match_operand:TI 0 \"register_operand\" \"\")\n-\t(lshiftrt:TI (match_operand:TI 1 \"register_operand\" \"\")\n-\t\t     (match_operand:QI 2 \"nonmemory_operand\" \"\")))\n-   (clobber (reg:CC FLAGS_REG))]\n-  \"TARGET_64BIT && ((optimize > 0 && flag_peephole2)\n-\t\t    ? epilogue_completed : reload_completed)\"\n-  [(const_int 0)]\n-  \"ix86_split_lshr (operands, NULL_RTX, TImode); DONE;\")\n-\n-(define_expand \"lshrdi3\"\n-  [(set (match_operand:DI 0 \"shiftdi_operand\" \"\")\n-\t(lshiftrt:DI (match_operand:DI 1 \"shiftdi_operand\" \"\")\n-\t\t     (match_operand:QI 2 \"nonmemory_operand\" \"\")))]\n+(define_expand \"lshr<mode>3\"\n+  [(set (match_operand:SDWIM 0 \"<shift_operand>\" \"\")\n+\t(lshiftrt:SDWIM (match_operand:SDWIM 1 \"<shift_operand>\" \"\")\n+\t\t\t(match_operand:QI 2 \"nonmemory_operand\" \"\")))]\n   \"\"\n-  \"ix86_expand_binary_operator (LSHIFTRT, DImode, operands); DONE;\")\n-\n-(define_insn \"*lshrdi3_1_one_bit_rex64\"\n-  [(set (match_operand:DI 0 \"nonimmediate_operand\" \"=rm\")\n-\t(lshiftrt:DI (match_operand:DI 1 \"nonimmediate_operand\" \"0\")\n-\t\t     (match_operand:QI 2 \"const1_operand\" \"\")))\n-   (clobber (reg:CC FLAGS_REG))]\n-  \"TARGET_64BIT\n-   && (TARGET_SHIFT1 || optimize_function_for_size_p (cfun))\n-   && ix86_binary_operator_ok (LSHIFTRT, HImode, operands)\"\n-  \"shr{q}\\t%0\"\n-  [(set_attr \"type\" \"ishift\")\n-   (set_attr \"length_immediate\" \"0\")\n-   (set_attr \"mode\" \"DI\")])\n-\n-(define_insn \"*lshrdi3_1_rex64\"\n-  [(set (match_operand:DI 0 \"nonimmediate_operand\" \"=rm,rm\")\n-\t(lshiftrt:DI (match_operand:DI 1 \"nonimmediate_operand\" \"0,0\")\n-\t\t     (match_operand:QI 2 \"nonmemory_operand\" \"J,c\")))\n-   (clobber (reg:CC FLAGS_REG))]\n-  \"TARGET_64BIT && ix86_binary_operator_ok (LSHIFTRT, HImode, operands)\"\n-  \"@\n-   shr{q}\\t{%2, %0|%0, %2}\n-   shr{q}\\t{%b2, %0|%0, %b2}\"\n-  [(set_attr \"type\" \"ishift\")\n-   (set_attr \"mode\" \"DI\")])\n-\n-;; This pattern can't accept a variable shift count, since shifts by\n-;; zero don't affect the flags.  We assume that shifts by constant\n-;; zero are optimized away.\n-(define_insn \"*lshrdi3_cmp_one_bit_rex64\"\n-  [(set (reg FLAGS_REG)\n-\t(compare\n-\t  (lshiftrt:DI (match_operand:DI 1 \"nonimmediate_operand\" \"0\")\n-\t\t       (match_operand:QI 2 \"const1_operand\" \"\"))\n-\t  (const_int 0)))\n-   (set (match_operand:DI 0 \"nonimmediate_operand\" \"=rm\")\n-\t(lshiftrt:DI (match_dup 1) (match_dup 2)))]\n-  \"TARGET_64BIT\n-   && (TARGET_SHIFT1 || optimize_function_for_size_p (cfun))\n-   && ix86_match_ccmode (insn, CCGOCmode)\n-   && ix86_binary_operator_ok (LSHIFTRT, HImode, operands)\"\n-  \"shr{q}\\t%0\"\n-  [(set_attr \"type\" \"ishift\")\n-   (set_attr \"length_immediate\" \"0\")\n-   (set_attr \"mode\" \"DI\")])\n-\n-(define_insn \"*lshrdi3_cconly_one_bit_rex64\"\n-  [(set (reg FLAGS_REG)\n-\t(compare\n-\t  (lshiftrt:DI (match_operand:DI 1 \"nonimmediate_operand\" \"0\")\n-\t\t       (match_operand:QI 2 \"const1_operand\" \"\"))\n-\t  (const_int 0)))\n-   (clobber (match_scratch:DI 0 \"=r\"))]\n-  \"TARGET_64BIT\n-   && (TARGET_SHIFT1 || optimize_function_for_size_p (cfun))\n-   && ix86_match_ccmode (insn, CCGOCmode)\n-   && ix86_binary_operator_ok (LSHIFTRT, HImode, operands)\"\n-  \"shr{q}\\t%0\"\n-  [(set_attr \"type\" \"ishift\")\n-   (set_attr \"length_immediate\" \"0\")\n-   (set_attr \"mode\" \"DI\")])\n-\n-;; This pattern can't accept a variable shift count, since shifts by\n-;; zero don't affect the flags.  We assume that shifts by constant\n-;; zero are optimized away.\n-(define_insn \"*lshrdi3_cmp_rex64\"\n-  [(set (reg FLAGS_REG)\n-\t(compare\n-\t  (lshiftrt:DI (match_operand:DI 1 \"nonimmediate_operand\" \"0\")\n-\t\t       (match_operand:QI 2 \"const_1_to_63_operand\" \"J\"))\n-\t  (const_int 0)))\n-   (set (match_operand:DI 0 \"nonimmediate_operand\" \"=rm\")\n-\t(lshiftrt:DI (match_dup 1) (match_dup 2)))]\n-  \"TARGET_64BIT\n-   && (optimize_function_for_size_p (cfun) || !TARGET_PARTIAL_FLAG_REG_STALL)\n-   && ix86_match_ccmode (insn, CCGOCmode)\n-   && ix86_binary_operator_ok (LSHIFTRT, HImode, operands)\"\n-  \"shr{q}\\t{%2, %0|%0, %2}\"\n-  [(set_attr \"type\" \"ishift\")\n-   (set_attr \"mode\" \"DI\")])\n-\n-(define_insn \"*lshrdi3_cconly_rex64\"\n-  [(set (reg FLAGS_REG)\n-\t(compare\n-\t  (lshiftrt:DI (match_operand:DI 1 \"nonimmediate_operand\" \"0\")\n-\t\t       (match_operand:QI 2 \"const_1_to_63_operand\" \"J\"))\n-\t  (const_int 0)))\n-   (clobber (match_scratch:DI 0 \"=r\"))]\n-  \"TARGET_64BIT\n-   && (optimize_function_for_size_p (cfun) || !TARGET_PARTIAL_FLAG_REG_STALL)\n-   && ix86_match_ccmode (insn, CCGOCmode)\n-   && ix86_binary_operator_ok (LSHIFTRT, HImode, operands)\"\n-  \"shr{q}\\t{%2, %0|%0, %2}\"\n-  [(set_attr \"type\" \"ishift\")\n-   (set_attr \"mode\" \"DI\")])\n+  \"ix86_expand_binary_operator (LSHIFTRT, <MODE>mode, operands); DONE;\")\n \n-(define_insn \"*lshrdi3_1\"\n-  [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n-\t(lshiftrt:DI (match_operand:DI 1 \"register_operand\" \"0\")\n-\t\t     (match_operand:QI 2 \"nonmemory_operand\" \"Jc\")))\n+(define_insn_and_split \"*lshr<mode>3_doubleword\"\n+  [(set (match_operand:DWI 0 \"register_operand\" \"=r\")\n+\t(lshiftrt:DWI (match_operand:DWI 1 \"register_operand\" \"0\")\n+\t\t      (match_operand:QI 2 \"nonmemory_operand\" \"<S>c\")))\n    (clobber (reg:CC FLAGS_REG))]\n-  \"!TARGET_64BIT\"\n+  \"\"\n   \"#\"\n+  \"(optimize && flag_peephole2) ? epilogue_completed : reload_completed\"\n+  [(const_int 0)]\n+  \"ix86_split_lshr (operands, NULL_RTX, <MODE>mode); DONE;\"\n   [(set_attr \"type\" \"multi\")])\n \n-;; By default we don't ask for a scratch register, because when DImode\n+;; By default we don't ask for a scratch register, because when DWImode\n ;; values are manipulated, registers are already at a premium.  But if\n ;; we have one handy, we won't turn it away.\n+\n (define_peephole2\n-  [(match_scratch:SI 3 \"r\")\n-   (parallel [(set (match_operand:DI 0 \"register_operand\" \"\")\n-\t\t   (lshiftrt:DI (match_operand:DI 1 \"register_operand\" \"\")\n-\t\t\t        (match_operand:QI 2 \"nonmemory_operand\" \"\")))\n+  [(match_scratch:DWIH 3 \"r\")\n+   (parallel [(set (match_operand:<DWI> 0 \"register_operand\" \"\")\n+\t\t   (lshiftrt:<DWI>\n+\t\t     (match_operand:<DWI> 1 \"register_operand\" \"\")\n+\t\t     (match_operand:QI 2 \"nonmemory_operand\" \"\")))\n \t      (clobber (reg:CC FLAGS_REG))])\n    (match_dup 3)]\n-  \"!TARGET_64BIT && TARGET_CMOVE\"\n-  [(const_int 0)]\n-  \"ix86_split_lshr (operands, operands[3], DImode); DONE;\")\n-\n-(define_split\n-  [(set (match_operand:DI 0 \"register_operand\" \"\")\n-\t(lshiftrt:DI (match_operand:DI 1 \"register_operand\" \"\")\n-\t\t     (match_operand:QI 2 \"nonmemory_operand\" \"\")))\n-   (clobber (reg:CC FLAGS_REG))]\n-  \"!TARGET_64BIT && ((optimize > 0 && flag_peephole2)\n-\t\t     ? epilogue_completed : reload_completed)\"\n+  \"TARGET_CMOVE\"\n   [(const_int 0)]\n-  \"ix86_split_lshr (operands, NULL_RTX, DImode); DONE;\")\n-\n-(define_expand \"lshrsi3\"\n-  [(set (match_operand:SI 0 \"nonimmediate_operand\" \"\")\n-\t(lshiftrt:SI (match_operand:SI 1 \"nonimmediate_operand\" \"\")\n-\t\t     (match_operand:QI 2 \"nonmemory_operand\" \"\")))]\n-  \"\"\n-  \"ix86_expand_binary_operator (LSHIFTRT, SImode, operands); DONE;\")\n-\n-(define_insn \"*lshrsi3_1_one_bit\"\n-  [(set (match_operand:SI 0 \"nonimmediate_operand\" \"=rm\")\n-\t(lshiftrt:SI (match_operand:SI 1 \"nonimmediate_operand\" \"0\")\n-\t\t     (match_operand:QI 2 \"const1_operand\" \"\")))\n-   (clobber (reg:CC FLAGS_REG))]\n-  \"(TARGET_SHIFT1 || optimize_function_for_size_p (cfun))\n-   && ix86_binary_operator_ok (LSHIFTRT, HImode, operands)\"\n-  \"shr{l}\\t%0\"\n-  [(set_attr \"type\" \"ishift\")\n-   (set_attr \"length_immediate\" \"0\")\n-   (set_attr \"mode\" \"SI\")])\n-\n-(define_insn \"*lshrsi3_1_one_bit_zext\"\n-  [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n-\t(lshiftrt:DI (zero_extend:DI (match_operand:SI 1 \"register_operand\" \"0\"))\n-\t\t     (match_operand:QI 2 \"const1_operand\" \"\")))\n-   (clobber (reg:CC FLAGS_REG))]\n-  \"TARGET_64BIT\n-   && (TARGET_SHIFT1 || optimize_function_for_size_p (cfun))\n-   && ix86_binary_operator_ok (LSHIFTRT, HImode, operands)\"\n-  \"shr{l}\\t%k0\"\n-  [(set_attr \"type\" \"ishift\")\n-   (set_attr \"length_immediate\" \"0\")\n-   (set_attr \"mode\" \"SI\")])\n+  \"ix86_split_lshr (operands, operands[3], <DWI>mode); DONE;\")\n \n-(define_insn \"*lshrsi3_1\"\n-  [(set (match_operand:SI 0 \"nonimmediate_operand\" \"=rm,rm\")\n-\t(lshiftrt:SI (match_operand:SI 1 \"nonimmediate_operand\" \"0,0\")\n-\t\t     (match_operand:QI 2 \"nonmemory_operand\" \"I,c\")))\n+(define_insn \"*lshr<mode>3_1\"\n+  [(set (match_operand:SWI 0 \"nonimmediate_operand\" \"=<r>m\")\n+\t(lshiftrt:SWI (match_operand:SWI 1 \"nonimmediate_operand\" \"0\")\n+\t\t      (match_operand:QI 2 \"nonmemory_operand\" \"c<S>\")))\n    (clobber (reg:CC FLAGS_REG))]\n-  \"ix86_binary_operator_ok (LSHIFTRT, HImode, operands)\"\n-  \"@\n-   shr{l}\\t{%2, %0|%0, %2}\n-   shr{l}\\t{%b2, %0|%0, %b2}\"\n+  \"ix86_binary_operator_ok (LSHIFTRT, <MODE>mode, operands)\"\n+{\n+  if (REG_P (operands[2]))\n+    return \"shr{<imodesuffix>}\\t{%b2, %0|%0, %b2}\";\n+  else if (operands[2] == const1_rtx\n+\t   && (TARGET_SHIFT1 || optimize_function_for_size_p (cfun)))\n+    return \"shr{<imodesuffix>}\\t%0\";\n+  else\n+    return \"shr{<imodesuffix>}\\t{%2, %0|%0, %2}\";\n+}\n   [(set_attr \"type\" \"ishift\")\n-   (set_attr \"mode\" \"SI\")])\n+   (set (attr \"length_immediate\")\n+     (if_then_else\n+       (and (match_operand 2 \"const1_operand\" \"\")\n+\t    (ne (symbol_ref \"TARGET_SHIFT1 || optimize_function_for_size_p (cfun)\")\n+\t\t(const_int 0)))\n+       (const_string \"0\")\n+       (const_string \"*\")))\n+   (set_attr \"mode\" \"<MODE>\")])\n \n (define_insn \"*lshrsi3_1_zext\"\n-  [(set (match_operand:DI 0 \"register_operand\" \"=r,r\")\n+  [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n \t(zero_extend:DI\n-\t  (lshiftrt:SI (match_operand:SI 1 \"nonimmediate_operand\" \"0,0\")\n-\t\t       (match_operand:QI 2 \"nonmemory_operand\" \"I,c\"))))\n-   (clobber (reg:CC FLAGS_REG))]\n-  \"TARGET_64BIT && ix86_binary_operator_ok (LSHIFTRT, HImode, operands)\"\n-  \"@\n-   shr{l}\\t{%2, %k0|%k0, %2}\n-   shr{l}\\t{%b2, %k0|%k0, %b2}\"\n-  [(set_attr \"type\" \"ishift\")\n-   (set_attr \"mode\" \"SI\")])\n-\n-;; This pattern can't accept a variable shift count, since shifts by\n-;; zero don't affect the flags.  We assume that shifts by constant\n-;; zero are optimized away.\n-(define_insn \"*lshrsi3_one_bit_cmp\"\n-  [(set (reg FLAGS_REG)\n-\t(compare\n-\t  (lshiftrt:SI (match_operand:SI 1 \"nonimmediate_operand\" \"0\")\n-\t\t       (match_operand:QI 2 \"const1_operand\" \"\"))\n-\t  (const_int 0)))\n-   (set (match_operand:SI 0 \"nonimmediate_operand\" \"=rm\")\n-\t(lshiftrt:SI (match_dup 1) (match_dup 2)))]\n-  \"(TARGET_SHIFT1 || optimize_function_for_size_p (cfun))\n-   && ix86_match_ccmode (insn, CCGOCmode)\n-   && ix86_binary_operator_ok (LSHIFTRT, HImode, operands)\"\n-  \"shr{l}\\t%0\"\n-  [(set_attr \"type\" \"ishift\")\n-   (set_attr \"length_immediate\" \"0\")\n-   (set_attr \"mode\" \"SI\")])\n-\n-(define_insn \"*lshrsi3_one_bit_cconly\"\n-  [(set (reg FLAGS_REG)\n-\t(compare\n-\t  (lshiftrt:SI (match_operand:SI 1 \"nonimmediate_operand\" \"0\")\n-\t\t       (match_operand:QI 2 \"const1_operand\" \"\"))\n-\t  (const_int 0)))\n-   (clobber (match_scratch:SI 0 \"=r\"))]\n-  \"(TARGET_SHIFT1 || optimize_function_for_size_p (cfun))\n-   && ix86_match_ccmode (insn, CCGOCmode)\n-   && ix86_binary_operator_ok (LSHIFTRT, HImode, operands)\"\n-  \"shr{l}\\t%0\"\n-  [(set_attr \"type\" \"ishift\")\n-   (set_attr \"length_immediate\" \"0\")\n-   (set_attr \"mode\" \"SI\")])\n-\n-(define_insn \"*lshrsi3_cmp_one_bit_zext\"\n-  [(set (reg FLAGS_REG)\n-\t(compare\n-\t  (lshiftrt:SI (match_operand:SI 1 \"register_operand\" \"0\")\n-\t\t       (match_operand:QI 2 \"const1_operand\" \"\"))\n-\t  (const_int 0)))\n-   (set (match_operand:DI 0 \"register_operand\" \"=r\")\n-\t(lshiftrt:DI (zero_extend:DI (match_dup 1)) (match_dup 2)))]\n-  \"TARGET_64BIT\n-   && (TARGET_SHIFT1 || optimize_function_for_size_p (cfun))\n-   && ix86_match_ccmode (insn, CCGOCmode)\n-   && ix86_binary_operator_ok (LSHIFTRT, HImode, operands)\"\n-  \"shr{l}\\t%k0\"\n-  [(set_attr \"type\" \"ishift\")\n-   (set_attr \"length_immediate\" \"0\")\n-   (set_attr \"mode\" \"SI\")])\n-\n-;; This pattern can't accept a variable shift count, since shifts by\n-;; zero don't affect the flags.  We assume that shifts by constant\n-;; zero are optimized away.\n-(define_insn \"*lshrsi3_cmp\"\n-  [(set (reg FLAGS_REG)\n-\t(compare\n-\t  (lshiftrt:SI (match_operand:SI 1 \"nonimmediate_operand\" \"0\")\n-\t\t       (match_operand:QI 2 \"const_1_to_31_operand\" \"I\"))\n-\t  (const_int 0)))\n-   (set (match_operand:SI 0 \"nonimmediate_operand\" \"=rm\")\n-\t(lshiftrt:SI (match_dup 1) (match_dup 2)))]\n-  \"(optimize_function_for_size_p (cfun) || !TARGET_PARTIAL_FLAG_REG_STALL)\n-   && ix86_match_ccmode (insn, CCGOCmode)\n-   && ix86_binary_operator_ok (LSHIFTRT, HImode, operands)\"\n-  \"shr{l}\\t{%2, %0|%0, %2}\"\n-  [(set_attr \"type\" \"ishift\")\n-   (set_attr \"mode\" \"SI\")])\n-\n-(define_insn \"*lshrsi3_cconly\"\n-  [(set (reg FLAGS_REG)\n-      (compare\n-\t(lshiftrt:SI (match_operand:SI 1 \"nonimmediate_operand\" \"0\")\n-\t\t     (match_operand:QI 2 \"const_1_to_31_operand\" \"I\"))\n-        (const_int 0)))\n-   (clobber (match_scratch:SI 0 \"=r\"))]\n-  \"(optimize_function_for_size_p (cfun) || !TARGET_PARTIAL_FLAG_REG_STALL)\n-   && ix86_match_ccmode (insn, CCGOCmode)\n-   && ix86_binary_operator_ok (LSHIFTRT, HImode, operands)\"\n-  \"shr{l}\\t{%2, %0|%0, %2}\"\n-  [(set_attr \"type\" \"ishift\")\n-   (set_attr \"mode\" \"SI\")])\n-\n-(define_insn \"*lshrsi3_cmp_zext\"\n-  [(set (reg FLAGS_REG)\n-\t(compare\n \t  (lshiftrt:SI (match_operand:SI 1 \"register_operand\" \"0\")\n-\t\t       (match_operand:QI 2 \"const_1_to_31_operand\" \"I\"))\n-\t  (const_int 0)))\n-   (set (match_operand:DI 0 \"register_operand\" \"=r\")\n-\t(lshiftrt:DI (zero_extend:DI (match_dup 1)) (match_dup 2)))]\n-  \"TARGET_64BIT\n-   && (optimize_function_for_size_p (cfun) || !TARGET_PARTIAL_FLAG_REG_STALL)\n-   && ix86_match_ccmode (insn, CCGOCmode)\n-   && ix86_binary_operator_ok (LSHIFTRT, HImode, operands)\"\n-  \"shr{l}\\t{%2, %k0|%k0, %2}\"\n-  [(set_attr \"type\" \"ishift\")\n-   (set_attr \"mode\" \"SI\")])\n-\n-(define_expand \"lshrhi3\"\n-  [(set (match_operand:HI 0 \"nonimmediate_operand\" \"\")\n-\t(lshiftrt:HI (match_operand:HI 1 \"nonimmediate_operand\" \"\")\n-\t\t     (match_operand:QI 2 \"nonmemory_operand\" \"\")))]\n-  \"TARGET_HIMODE_MATH\"\n-  \"ix86_expand_binary_operator (LSHIFTRT, HImode, operands); DONE;\")\n-\n-(define_insn \"*lshrhi3_1_one_bit\"\n-  [(set (match_operand:HI 0 \"nonimmediate_operand\" \"=rm\")\n-\t(lshiftrt:HI (match_operand:HI 1 \"nonimmediate_operand\" \"0\")\n-\t\t     (match_operand:QI 2 \"const1_operand\" \"\")))\n-   (clobber (reg:CC FLAGS_REG))]\n-  \"(TARGET_SHIFT1 || optimize_function_for_size_p (cfun))\n-   && ix86_binary_operator_ok (LSHIFTRT, HImode, operands)\"\n-  \"shr{w}\\t%0\"\n-  [(set_attr \"type\" \"ishift\")\n-   (set_attr \"length_immediate\" \"0\")\n-   (set_attr \"mode\" \"HI\")])\n-\n-(define_insn \"*lshrhi3_1\"\n-  [(set (match_operand:HI 0 \"nonimmediate_operand\" \"=rm,rm\")\n-\t(lshiftrt:HI (match_operand:HI 1 \"nonimmediate_operand\" \"0,0\")\n-\t\t     (match_operand:QI 2 \"nonmemory_operand\" \"I,c\")))\n-   (clobber (reg:CC FLAGS_REG))]\n-  \"ix86_binary_operator_ok (LSHIFTRT, HImode, operands)\"\n-  \"@\n-   shr{w}\\t{%2, %0|%0, %2}\n-   shr{w}\\t{%b2, %0|%0, %b2}\"\n-  [(set_attr \"type\" \"ishift\")\n-   (set_attr \"mode\" \"HI\")])\n-\n-;; This pattern can't accept a variable shift count, since shifts by\n-;; zero don't affect the flags.  We assume that shifts by constant\n-;; zero are optimized away.\n-(define_insn \"*lshrhi3_one_bit_cmp\"\n-  [(set (reg FLAGS_REG)\n-\t(compare\n-\t  (lshiftrt:HI (match_operand:HI 1 \"nonimmediate_operand\" \"0\")\n-\t\t       (match_operand:QI 2 \"const1_operand\" \"\"))\n-\t  (const_int 0)))\n-   (set (match_operand:HI 0 \"nonimmediate_operand\" \"=rm\")\n-\t(lshiftrt:HI (match_dup 1) (match_dup 2)))]\n-  \"(TARGET_SHIFT1 || optimize_function_for_size_p (cfun))\n-   && ix86_match_ccmode (insn, CCGOCmode)\n-   && ix86_binary_operator_ok (LSHIFTRT, HImode, operands)\"\n-  \"shr{w}\\t%0\"\n-  [(set_attr \"type\" \"ishift\")\n-   (set_attr \"length_immediate\" \"0\")\n-   (set_attr \"mode\" \"HI\")])\n-\n-(define_insn \"*lshrhi3_one_bit_cconly\"\n-  [(set (reg FLAGS_REG)\n-\t(compare\n-\t  (lshiftrt:HI (match_operand:HI 1 \"nonimmediate_operand\" \"0\")\n-\t\t       (match_operand:QI 2 \"const1_operand\" \"\"))\n-\t  (const_int 0)))\n-   (clobber (match_scratch:HI 0 \"=r\"))]\n-  \"(TARGET_SHIFT1 || optimize_function_for_size_p (cfun))\n-   && ix86_match_ccmode (insn, CCGOCmode)\n-   && ix86_binary_operator_ok (LSHIFTRT, HImode, operands)\"\n-  \"shr{w}\\t%0\"\n-  [(set_attr \"type\" \"ishift\")\n-   (set_attr \"length_immediate\" \"0\")\n-   (set_attr \"mode\" \"HI\")])\n-\n-;; This pattern can't accept a variable shift count, since shifts by\n-;; zero don't affect the flags.  We assume that shifts by constant\n-;; zero are optimized away.\n-(define_insn \"*lshrhi3_cmp\"\n-  [(set (reg FLAGS_REG)\n-\t(compare\n-\t  (lshiftrt:HI (match_operand:HI 1 \"nonimmediate_operand\" \"0\")\n-\t\t       (match_operand:QI 2 \"const_1_to_31_operand\" \"I\"))\n-\t  (const_int 0)))\n-   (set (match_operand:HI 0 \"nonimmediate_operand\" \"=rm\")\n-\t(lshiftrt:HI (match_dup 1) (match_dup 2)))]\n-  \"(optimize_function_for_size_p (cfun) || !TARGET_PARTIAL_FLAG_REG_STALL)\n-   && ix86_match_ccmode (insn, CCGOCmode)\n-   && ix86_binary_operator_ok (LSHIFTRT, HImode, operands)\"\n-  \"shr{w}\\t{%2, %0|%0, %2}\"\n-  [(set_attr \"type\" \"ishift\")\n-   (set_attr \"mode\" \"HI\")])\n-\n-(define_insn \"*lshrhi3_cconly\"\n-  [(set (reg FLAGS_REG)\n-\t(compare\n-\t  (lshiftrt:HI (match_operand:HI 1 \"nonimmediate_operand\" \"0\")\n-\t\t       (match_operand:QI 2 \"const_1_to_31_operand\" \"I\"))\n-\t  (const_int 0)))\n-   (clobber (match_scratch:HI 0 \"=r\"))]\n-  \"(optimize_function_for_size_p (cfun) || !TARGET_PARTIAL_FLAG_REG_STALL)\n-   && ix86_match_ccmode (insn, CCGOCmode)\n-   && ix86_binary_operator_ok (LSHIFTRT, HImode, operands)\"\n-  \"shr{w}\\t{%2, %0|%0, %2}\"\n-  [(set_attr \"type\" \"ishift\")\n-   (set_attr \"mode\" \"HI\")])\n-\n-(define_expand \"lshrqi3\"\n-  [(set (match_operand:QI 0 \"nonimmediate_operand\" \"\")\n-\t(lshiftrt:QI (match_operand:QI 1 \"nonimmediate_operand\" \"\")\n-\t\t     (match_operand:QI 2 \"nonmemory_operand\" \"\")))]\n-  \"TARGET_QIMODE_MATH\"\n-  \"ix86_expand_binary_operator (LSHIFTRT, QImode, operands); DONE;\")\n-\n-(define_insn \"*lshrqi3_1_one_bit\"\n-  [(set (match_operand:QI 0 \"nonimmediate_operand\" \"=qm\")\n-\t(lshiftrt:QI (match_operand:QI 1 \"nonimmediate_operand\" \"0\")\n-\t\t     (match_operand:QI 2 \"const1_operand\" \"\")))\n-   (clobber (reg:CC FLAGS_REG))]\n-  \"(TARGET_SHIFT1 || optimize_function_for_size_p (cfun))\n-   && ix86_binary_operator_ok (LSHIFTRT, QImode, operands)\"\n-  \"shr{b}\\t%0\"\n-  [(set_attr \"type\" \"ishift\")\n-   (set_attr \"length_immediate\" \"0\")\n-   (set_attr \"mode\" \"QI\")])\n-\n-(define_insn \"*lshrqi3_1_one_bit_slp\"\n-  [(set (strict_low_part (match_operand:QI 0 \"nonimmediate_operand\" \"+qm\"))\n-\t(lshiftrt:QI (match_dup 0)\n-\t\t     (match_operand:QI 1 \"const1_operand\" \"\")))\n-   (clobber (reg:CC FLAGS_REG))]\n-  \"(! TARGET_PARTIAL_REG_STALL || optimize_function_for_size_p (cfun))\n-   && (TARGET_SHIFT1 || optimize_function_for_size_p (cfun))\"\n-  \"shr{b}\\t%0\"\n-  [(set_attr \"type\" \"ishift1\")\n-   (set_attr \"length_immediate\" \"0\")\n-   (set_attr \"mode\" \"QI\")])\n-\n-(define_insn \"*lshrqi3_1\"\n-  [(set (match_operand:QI 0 \"nonimmediate_operand\" \"=qm,qm\")\n-\t(lshiftrt:QI (match_operand:QI 1 \"nonimmediate_operand\" \"0,0\")\n-\t\t     (match_operand:QI 2 \"nonmemory_operand\" \"I,c\")))\n+\t\t       (match_operand:QI 2 \"nonmemory_operand\" \"cI\"))))\n    (clobber (reg:CC FLAGS_REG))]\n-  \"ix86_binary_operator_ok (LSHIFTRT, QImode, operands)\"\n-  \"@\n-   shr{b}\\t{%2, %0|%0, %2}\n-   shr{b}\\t{%b2, %0|%0, %b2}\"\n+  \"TARGET_64BIT && ix86_binary_operator_ok (LSHIFTRT, SImode, operands)\"\n+{\n+  if (REG_P (operands[2]))\n+    return \"shr{l}\\t{%b2, %k0|%k0, %b2}\";\n+  else if (operands[2] == const1_rtx\n+\t   && (TARGET_SHIFT1 || optimize_function_for_size_p (cfun)))\n+    return \"shr{l}\\t%k0\";\n+  else\n+    return \"shr{l}\\t{%2, %k0|%k0, %2}\";\n+}\n   [(set_attr \"type\" \"ishift\")\n-   (set_attr \"mode\" \"QI\")])\n+   (set (attr \"length_immediate\")\n+     (if_then_else\n+       (and (match_operand 2 \"const1_operand\" \"\")\n+\t    (ne (symbol_ref \"TARGET_SHIFT1 || optimize_function_for_size_p (cfun)\")\n+\t\t(const_int 0)))\n+       (const_string \"0\")\n+       (const_string \"*\")))\n+   (set_attr \"mode\" \"SI\")])\n \n (define_insn \"*lshrqi3_1_slp\"\n-  [(set (strict_low_part (match_operand:QI 0 \"nonimmediate_operand\" \"+qm,qm\"))\n+  [(set (strict_low_part (match_operand:QI 0 \"nonimmediate_operand\" \"+qm\"))\n \t(lshiftrt:QI (match_dup 0)\n-\t\t     (match_operand:QI 1 \"nonmemory_operand\" \"I,c\")))\n+\t\t     (match_operand:QI 1 \"nonmemory_operand\" \"cI\")))\n    (clobber (reg:CC FLAGS_REG))]\n-  \"(! TARGET_PARTIAL_REG_STALL || optimize_function_for_size_p (cfun))\n-   && !(MEM_P (operands[0]) && MEM_P (operands[1]))\"\n-  \"@\n-   shr{b}\\t{%1, %0|%0, %1}\n-   shr{b}\\t{%b1, %0|%0, %b1}\"\n+  \"(optimize_function_for_size_p (cfun)\n+    || !TARGET_PARTIAL_REG_STALL\n+    || (operands[1] == const1_rtx\n+\t&& TARGET_SHIFT1))\"\n+{\n+  if (REG_P (operands[1]))\n+    return \"shr{b}\\t{%b1, %0|%0, %b1}\";\n+  else if (operands[1] == const1_rtx\n+\t   && (TARGET_SHIFT1 || optimize_function_for_size_p (cfun)))\n+    return \"shr{b}\\t%0\";\n+  else\n+    return \"shr{b}\\t{%1, %0|%0, %1}\";\n+}\n   [(set_attr \"type\" \"ishift1\")\n+   (set (attr \"length_immediate\")\n+     (if_then_else\n+       (and (match_operand 1 \"const1_operand\" \"\")\n+\t    (ne (symbol_ref \"TARGET_SHIFT1 || optimize_function_for_size_p (cfun)\")\n+\t\t(const_int 0)))\n+       (const_string \"0\")\n+       (const_string \"*\")))\n    (set_attr \"mode\" \"QI\")])\n \n ;; This pattern can't accept a variable shift count, since shifts by\n ;; zero don't affect the flags.  We assume that shifts by constant\n ;; zero are optimized away.\n-(define_insn \"*lshrqi2_one_bit_cmp\"\n-  [(set (reg FLAGS_REG)\n-\t(compare\n-\t  (lshiftrt:QI (match_operand:QI 1 \"nonimmediate_operand\" \"0\")\n-\t\t       (match_operand:QI 2 \"const1_operand\" \"\"))\n-\t  (const_int 0)))\n-   (set (match_operand:QI 0 \"nonimmediate_operand\" \"=qm\")\n-\t(lshiftrt:QI (match_dup 1) (match_dup 2)))]\n-  \"(TARGET_SHIFT1 || optimize_function_for_size_p (cfun))\n-   && ix86_match_ccmode (insn, CCGOCmode)\n-   && ix86_binary_operator_ok (LSHIFTRT, QImode, operands)\"\n-  \"shr{b}\\t%0\"\n-  [(set_attr \"type\" \"ishift\")\n-   (set_attr \"length_immediate\" \"0\")\n-   (set_attr \"mode\" \"QI\")])\n-\n-(define_insn \"*lshrqi2_one_bit_cconly\"\n+(define_insn \"*lshr<mode>3_cmp\"\n   [(set (reg FLAGS_REG)\n \t(compare\n-\t  (lshiftrt:QI (match_operand:QI 1 \"nonimmediate_operand\" \"0\")\n-\t\t       (match_operand:QI 2 \"const1_operand\" \"\"))\n+\t  (lshiftrt:SWI (match_operand:SWI 1 \"nonimmediate_operand\" \"0\")\n+\t\t\t(match_operand:QI 2 \"<shift_immediate_operand>\" \"<S>\"))\n \t  (const_int 0)))\n-   (clobber (match_scratch:QI 0 \"=q\"))]\n-  \"(TARGET_SHIFT1 || optimize_function_for_size_p (cfun))\n+   (set (match_operand:SWI 0 \"nonimmediate_operand\" \"=<r>m\")\n+\t(lshiftrt:SWI (match_dup 1) (match_dup 2)))]\n+  \"(optimize_function_for_size_p (cfun)\n+    || !TARGET_PARTIAL_FLAG_REG_STALL\n+    || (operands[2] == const1_rtx\n+\t&& TARGET_SHIFT1))\n    && ix86_match_ccmode (insn, CCGOCmode)\n-   && ix86_binary_operator_ok (LSHIFTRT, QImode, operands)\"\n-  \"shr{b}\\t%0\"\n+   && ix86_binary_operator_ok (LSHIFTRT, <MODE>mode, operands)\"\n+{\n+  if (operands[2] == const1_rtx\n+      && (TARGET_SHIFT1 || optimize_function_for_size_p (cfun)))\n+    return \"shr{<imodesuffix>}\\t%0\";\n+  else\n+    return \"shr{<imodesuffix>}\\t{%2, %0|%0, %2}\";\n+}\n   [(set_attr \"type\" \"ishift\")\n-   (set_attr \"length_immediate\" \"0\")\n-   (set_attr \"mode\" \"QI\")])\n+   (set (attr \"length_immediate\")\n+     (if_then_else\n+       (and (match_operand 2 \"const1_operand\" \"\")\n+\t    (ne (symbol_ref \"TARGET_SHIFT1 || optimize_function_for_size_p (cfun)\")\n+\t\t(const_int 0)))\n+       (const_string \"0\")\n+       (const_string \"*\")))\n+   (set_attr \"mode\" \"<MODE>\")])\n \n-;; This pattern can't accept a variable shift count, since shifts by\n-;; zero don't affect the flags.  We assume that shifts by constant\n-;; zero are optimized away.\n-(define_insn \"*lshrqi2_cmp\"\n+(define_insn \"*lshrsi3_cmp_zext\"\n   [(set (reg FLAGS_REG)\n \t(compare\n-\t  (lshiftrt:QI (match_operand:QI 1 \"nonimmediate_operand\" \"0\")\n+\t  (lshiftrt:SI (match_operand:SI 1 \"register_operand\" \"0\")\n \t\t       (match_operand:QI 2 \"const_1_to_31_operand\" \"I\"))\n \t  (const_int 0)))\n-   (set (match_operand:QI 0 \"nonimmediate_operand\" \"=qm\")\n-\t(lshiftrt:QI (match_dup 1) (match_dup 2)))]\n-  \"(optimize_function_for_size_p (cfun) || !TARGET_PARTIAL_FLAG_REG_STALL)\n+   (set (match_operand:DI 0 \"register_operand\" \"=r\")\n+\t(zero_extend:DI (lshiftrt:SI (match_dup 1) (match_dup 2))))]\n+  \"TARGET_64BIT\n+   && (optimize_function_for_size_p (cfun)\n+       || !TARGET_PARTIAL_FLAG_REG_STALL\n+       || (operands[2] == const1_rtx\n+\t   && TARGET_SHIFT1))\n    && ix86_match_ccmode (insn, CCGOCmode)\n-   && ix86_binary_operator_ok (LSHIFTRT, QImode, operands)\"\n-  \"shr{b}\\t{%2, %0|%0, %2}\"\n+   && ix86_binary_operator_ok (LSHIFTRT, SImode, operands)\"\n+{\n+  if (operands[2] == const1_rtx\n+      && (TARGET_SHIFT1 || optimize_function_for_size_p (cfun)))\n+    return \"shr{l}\\t%k0\";\n+  else\n+    return \"shr{l}\\t{%2, %k0|%k0, %2}\";\n+}\n   [(set_attr \"type\" \"ishift\")\n-   (set_attr \"mode\" \"QI\")])\n+   (set (attr \"length_immediate\")\n+     (if_then_else\n+       (and (match_operand 2 \"const1_operand\" \"\")\n+\t    (ne (symbol_ref \"TARGET_SHIFT1 || optimize_function_for_size_p (cfun)\")\n+\t\t(const_int 0)))\n+       (const_string \"0\")\n+       (const_string \"*\")))\n+   (set_attr \"mode\" \"SI\")])\n \n-(define_insn \"*lshrqi2_cconly\"\n+(define_insn \"*lshr<mode>3_cconly\"\n   [(set (reg FLAGS_REG)\n \t(compare\n-\t  (lshiftrt:QI (match_operand:QI 1 \"nonimmediate_operand\" \"0\")\n-\t\t       (match_operand:QI 2 \"const_1_to_31_operand\" \"I\"))\n+\t  (lshiftrt:SWI (match_operand:SWI 1 \"nonimmediate_operand\" \"0\")\n+\t\t\t(match_operand:QI 2 \"<shift_immediate_operand>\" \"<S>\"))\n \t  (const_int 0)))\n-   (clobber (match_scratch:QI 0 \"=q\"))]\n-  \"(optimize_function_for_size_p (cfun) || !TARGET_PARTIAL_FLAG_REG_STALL)\n+   (clobber (match_scratch:DI 0 \"=<r>\"))]\n+  \"(optimize_function_for_size_p (cfun)\n+    || !TARGET_PARTIAL_FLAG_REG_STALL\n+    || (operands[2] == const1_rtx\n+\t&& TARGET_SHIFT1))\n    && ix86_match_ccmode (insn, CCGOCmode)\n-   && ix86_binary_operator_ok (LSHIFTRT, QImode, operands)\"\n-  \"shr{b}\\t{%2, %0|%0, %2}\"\n+   && ix86_binary_operator_ok (LSHIFTRT, <MODE>mode, operands)\"\n+{\n+  if (operands[2] == const1_rtx\n+      && (TARGET_SHIFT1 || optimize_function_for_size_p (cfun)))\n+    return \"shr{<imodesuffix>}\\t%0\";\n+  else\n+    return \"shr{<imodesuffix>}\\t{%2, %0|%0, %2}\";\n+}\n   [(set_attr \"type\" \"ishift\")\n-   (set_attr \"mode\" \"QI\")])\n+   (set (attr \"length_immediate\")\n+     (if_then_else\n+       (and (match_operand 2 \"const1_operand\" \"\")\n+\t    (ne (symbol_ref \"TARGET_SHIFT1 || optimize_function_for_size_p (cfun)\")\n+\t\t(const_int 0)))\n+       (const_string \"0\")\n+       (const_string \"*\")))\n+   (set_attr \"mode\" \"<MODE>\")])\n \f\n ;; Rotate instructions\n "}]}