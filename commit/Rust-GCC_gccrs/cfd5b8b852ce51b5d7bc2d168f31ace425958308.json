{"sha": "cfd5b8b852ce51b5d7bc2d168f31ace425958308", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Y2ZkNWI4Yjg1MmNlNTFiNWQ3YmMyZDE2OGYzMWFjZTQyNTk1ODMwOA==", "commit": {"author": {"name": "Neil Booth", "email": "neilb@earthling.net", "date": "2000-04-27T00:58:50Z"}, "committer": {"name": "Neil Booth", "email": "neil@gcc.gnu.org", "date": "2000-04-27T00:58:50Z"}, "message": "cpplex.c (spell_other, spell_char): Remove.\n\n\t* cpplex.c (spell_other, spell_char): Remove.\n\t(SPELL_CHAR): New.\n\t(token_spelling, trigraph_map): Use unsigned chars.\n\t(_cpp_lex_line): Tidy up the switch statement.\n\t* cpplib.h: Implement spell_char with spell_string.\n\t(C): New.\n\nFrom-SVN: r33454", "tree": {"sha": "7abe614eb0bc0abac0f8818cf0cfdfcc6ca1dece", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/7abe614eb0bc0abac0f8818cf0cfdfcc6ca1dece"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/cfd5b8b852ce51b5d7bc2d168f31ace425958308", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cfd5b8b852ce51b5d7bc2d168f31ace425958308", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cfd5b8b852ce51b5d7bc2d168f31ace425958308", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cfd5b8b852ce51b5d7bc2d168f31ace425958308/comments", "author": null, "committer": null, "parents": [{"sha": "72a107fe0a444e4b1b656f598fae711294edfe55", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/72a107fe0a444e4b1b656f598fae711294edfe55", "html_url": "https://github.com/Rust-GCC/gccrs/commit/72a107fe0a444e4b1b656f598fae711294edfe55"}], "stats": {"total": 105, "additions": 42, "deletions": 63}, "files": [{"sha": "e348a88b19784dd5a1418c077c8c417c9d0f2924", "filename": "gcc/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cfd5b8b852ce51b5d7bc2d168f31ace425958308/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cfd5b8b852ce51b5d7bc2d168f31ace425958308/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=cfd5b8b852ce51b5d7bc2d168f31ace425958308", "patch": "@@ -1,3 +1,12 @@\n+2000-04-26  <NeilB@earthling.net>\n+\n+\t* cpplex.c (spell_other, spell_char): Remove.\n+\t(SPELL_CHAR): New.\n+\t(token_spelling, trigraph_map): Use unsigned chars.\n+\t(_cpp_lex_line): Tidy up the switch statement.\n+\t* cpplib.h: Implement spell_char with spell_string.\n+\t(C): New.\n+\n 2000-04-26  <RodneyBrown@pmsc.com>\n \t\n \t* pa/pa32-regs.h (HARD_REGNO_MODE_OK): Warning removal."}, {"sha": "1f9a3594261d0909328c0589254a67c59e0a8e69", "filename": "gcc/cpplex.c", "status": "modified", "additions": 28, "deletions": 60, "changes": 88, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cfd5b8b852ce51b5d7bc2d168f31ace425958308/gcc%2Fcpplex.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cfd5b8b852ce51b5d7bc2d168f31ace425958308/gcc%2Fcpplex.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcpplex.c?ref=cfd5b8b852ce51b5d7bc2d168f31ace425958308", "patch": "@@ -2161,16 +2161,12 @@ void _cpp_lex_line PARAMS ((cpp_reader *, cpp_toklist *));\n \n static void _cpp_output_list PARAMS ((cpp_reader *, cpp_toklist *));\n \n-unsigned int spell_char PARAMS ((unsigned char *, cpp_toklist *,\n-\t\t\t\t cpp_token *token));\n unsigned int spell_string PARAMS ((unsigned char *, cpp_toklist *,\n \t\t\t\t   cpp_token *token));\n unsigned int spell_comment PARAMS ((unsigned char *, cpp_toklist *,\n \t\t\t\t    cpp_token *token));\n unsigned int spell_name PARAMS ((unsigned char *, cpp_toklist *,\n \t\t\t\t cpp_token *token));\n-unsigned int spell_other PARAMS ((unsigned char *, cpp_toklist *,\n-\t\t\t\t  cpp_token *token));\n \n typedef unsigned int (* speller) PARAMS ((unsigned char *, cpp_toklist *,\n \t\t\t\t\t  cpp_token *));\n@@ -2200,22 +2196,25 @@ typedef unsigned int (* speller) PARAMS ((unsigned char *, cpp_toklist *,\n \n #define SPELL_TEXT     0\n #define SPELL_HANDLER  1\n-#define SPELL_NONE     2\n-#define SPELL_EOL      3\n+#define SPELL_CHAR     2\n+#define SPELL_NONE     3\n+#define SPELL_EOL      4\n \n #define T(e, s) {SPELL_TEXT, s},\n #define H(e, s) {SPELL_HANDLER, s},\n+#define C(e, s) {SPELL_CHAR, s},\n #define N(e, s) {SPELL_NONE, s},\n #define E(e, s) {SPELL_EOL, s},\n \n static const struct token_spelling\n {\n-  char type;\n+  unsigned char type;\n   PTR  speller;\n } token_spellings [N_TTYPES + 1] = {TTYPE_TABLE {0, 0} };\n \n #undef T\n #undef H\n+#undef C\n #undef N\n #undef E\n \n@@ -2246,12 +2245,12 @@ cpp_free_token_list (list)\n {\n   if (list->comments)\n     free (list->comments);\n-  free (list->tokens - 1);\n+  free (list->tokens - 1);\t/* Backup over dummy token.  */\n   free (list->namebuf);\n   free (list);\n }\n \n-static char trigraph_map[256];\n+static unsigned char trigraph_map[256];\n \n void\n init_trigraph_map ()\n@@ -3120,10 +3119,6 @@ _cpp_lex_line (pfile, list)\n \t  cur_token++;\n \t  break;\n \n-\tcase ')':\n-\t  PUSH_TOKEN (CPP_CLOSE_PAREN);\n-\t  break;\n-\n \tcase '(':\n \t  /* Is this the beginning of an assertion string?  */\n \t  if (list->dir_flags & SYNTAX_ASSERT)\n@@ -3135,11 +3130,6 @@ _cpp_lex_line (pfile, list)\n \t  PUSH_TOKEN (CPP_OPEN_PAREN);\n \t  break;\n \n-\tmake_complement:\n-\tcase '~':\n-\t  PUSH_TOKEN (CPP_COMPL);\n-\t  break;\n-\n \tcase '?':\n \t  if (cur + 1 < buffer->rlimit && *cur == '?'\n \t      && trigraph_map[cur[1]] && trigraph_ok (pfile, cur + 1))\n@@ -3188,6 +3178,8 @@ _cpp_lex_line (pfile, list)\n \t    PUSH_TOKEN (CPP_DOT);\n \t  break;\n \n+\tmake_complement:\n+\tcase '~': PUSH_TOKEN (CPP_COMPL); break;\n \tmake_xor:\n \tcase '^': PUSH_TOKEN (CPP_XOR); break;\n \tmake_open_brace:\n@@ -3203,6 +3195,7 @@ _cpp_lex_line (pfile, list)\n \tcase '!': PUSH_TOKEN (CPP_NOT); break;\n \tcase ',': PUSH_TOKEN (CPP_COMMA); break;\n \tcase ';': PUSH_TOKEN (CPP_SEMICOLON); break;\n+\tcase ')': PUSH_TOKEN (CPP_CLOSE_PAREN); break;\n \n \tcase '$':\n \t  if (CPP_OPTION (pfile, dollars_in_ident))\n@@ -3258,45 +3251,25 @@ _cpp_lex_line (pfile, list)\n    stringizing and token pasting.  They all assume sufficient buffer\n    is allocated, and return exactly how much they used.  */\n \n-/* Needs buffer of 3 + len.  */\n-unsigned int\n-spell_char (buffer, list, token)\n-     unsigned char *buffer;\n-     cpp_toklist *list;\n-     cpp_token *token;\n-{\n-  unsigned char* orig_buff = buffer;\n-  size_t len;\n-\n-  if (token->type == CPP_WCHAR)\n-    *buffer++ = 'L';\n-  *buffer++ = '\\'';\n-\n-  len = token->val.name.len;\n-  memcpy (buffer, TOK_NAME (list, token), len);\n-  buffer += len;\n-  *buffer++ = '\\'';\n-  return buffer - orig_buff;\n-}\n-\n /* Needs buffer of 3 + len.  */\n unsigned int\n spell_string (buffer, list, token)\n      unsigned char *buffer;\n      cpp_toklist *list;\n      cpp_token *token;\n {\n-  unsigned char* orig_buff = buffer;\n+  unsigned char c, *orig_buff = buffer;\n   size_t len;\n \n-  if (token->type == CPP_WSTRING)\n+  if (token->type == CPP_WSTRING || token->type == CPP_WCHAR)\n     *buffer++ = 'L';\n-  *buffer++ = '\"';\n+  c = token->type == CPP_STRING || token->type == CPP_WSTRING ? '\"': '\\'';\n+  *buffer++ = c;\n \n   len = token->val.name.len;\n   memcpy (buffer, TOK_NAME (list, token), len);\n   buffer += len;\n-  *buffer++ = '\"';\n+  *buffer++ = c;\n   return buffer - orig_buff;\n }\n \n@@ -3347,17 +3320,6 @@ spell_name (buffer, list, token)\n   return len;\n }\n \n-/* Needs buffer of 1.  */\n-unsigned int\n-spell_other (buffer, list, token)\n-     unsigned char *buffer;\n-     cpp_toklist *list ATTRIBUTE_UNUSED;\n-     cpp_token *token;\n-{\n-  *buffer++ = token->aux;\n-  return 1;\n-}\n-\n void\n _cpp_lex_file (pfile)\n      cpp_reader* pfile;\n@@ -3390,6 +3352,11 @@ _cpp_lex_file (pfile)\n     }\n }\n \n+/* This could be useful to other routines.  If you allocate this many\n+   bytes, you have enough room to spell the token.  */\n+#define TOKEN_LEN(token) (4 + (token_spellings[token->type].type == \\\n+\t\t\t       SPELL_HANDLER ? token->val.name.len: 0))\n+\n static void\n _cpp_output_list (pfile, list)\n      cpp_reader *pfile;\n@@ -3412,8 +3379,7 @@ _cpp_output_list (pfile, list)\n \t      cpp_token *comment = &list->comments[comment_no];\n \t      do\n \t\t{\n-\t\t  /* Longest wrapper is 4.  */\n-\t\t  CPP_RESERVE (pfile, 4 + 2 + comment->val.name.len);\n+\t\t  CPP_RESERVE (pfile, 2 + TOKEN_LEN (comment));\n \t\t  pfile->limit += spell_comment (pfile->limit, list, comment);\n \t\t  comment_no++, comment++;\n \t\t  if (comment_no == list->comments_used)\n@@ -3426,16 +3392,16 @@ _cpp_output_list (pfile, list)\n \t    CPP_PUTC_Q (pfile, ' ');\n \t}\n \n+      CPP_RESERVE (pfile, 2 + TOKEN_LEN (token));\n       switch (token_spellings[token->type].type)\n \t{\n \tcase SPELL_TEXT:\n \t  {\n \t    const unsigned char *spelling;\n \t    unsigned char c;\n \n-\t    CPP_RESERVE (pfile, 4 + 2); /* Longest is 4.  */\n \t    if (token->flags & DIGRAPH)\n-\t      spelling = digraph_spellings [token->type - CPP_FIRST_DIGRAPH];\n+\t      spelling = digraph_spellings[token->type - CPP_FIRST_DIGRAPH];\n \t    else\n \t      spelling = token_spellings[token->type].speller;\n \n@@ -3449,12 +3415,14 @@ _cpp_output_list (pfile, list)\n \t    speller s;\n \n \t    s = (speller) token_spellings[token->type].speller;\n-\t    /* Longest wrapper is 4.  */\n-\t    CPP_RESERVE (pfile, 4 + 2 + token->val.name.len);\n \t    pfile->limit += s (pfile->limit, list, token);\n \t  }\n \t  break;\n \n+\tcase SPELL_CHAR:\n+\t  *pfile->limit++ = token->aux;\n+\t  break;\n+\n \tcase SPELL_EOL:\n \t  CPP_PUTC_Q (pfile, '\\n');\n \t  return;"}, {"sha": "0ddbba3642c084b4d78d6febd9501e30133d5191", "filename": "gcc/cpplib.h", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cfd5b8b852ce51b5d7bc2d168f31ace425958308/gcc%2Fcpplib.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cfd5b8b852ce51b5d7bc2d168f31ace425958308/gcc%2Fcpplib.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcpplib.h?ref=cfd5b8b852ce51b5d7bc2d168f31ace425958308", "patch": "@@ -108,14 +108,14 @@ typedef struct cpp_name cpp_name;\n   T(CPP_DOT_STAR,\t\".*\")\t\t\t\\\n   T(CPP_MIN,\t\t\"<?\")\t/* extension */\t\\\n   T(CPP_MAX,\t\t\">?\")\t\t\t\\\n-  H(CPP_OTHER,\t\tspell_other) /* stray punctuation */ \\\n+  C(CPP_OTHER,\t\t0)\t/* stray punctuation */ \\\n \\\n   H(CPP_NAME,\t\tspell_name)\t/* word */\t\\\n   N(CPP_INT,\t\t0)\t\t/* 23 */\t\\\n   N(CPP_FLOAT,\t\t0)\t\t/* 3.14159 */\t\\\n   H(CPP_NUMBER,\t\tspell_name)\t/* 34_be+ta  */\t\\\n-  H(CPP_CHAR,\t\tspell_char)\t/* 'char' */\t\\\n-  H(CPP_WCHAR,\t\tspell_char)\t/* L'char' */\t\\\n+  H(CPP_CHAR,\t\tspell_string)\t/* 'char' */\t\\\n+  H(CPP_WCHAR,\t\tspell_string)\t/* L'char' */\t\\\n   H(CPP_STRING,\t\tspell_string)\t/* \"string\" */\t\\\n   H(CPP_WSTRING,\tspell_string)\t/* L\"string\" */\t\\\n \\\n@@ -138,6 +138,7 @@ typedef struct cpp_name cpp_name;\n \n #define T(e, s) e,\n #define H(e, s) e,\n+#define C(e, s) e,\n #define N(e, s) e,\n #define E(e, s) e,\n enum cpp_ttype\n@@ -147,6 +148,7 @@ enum cpp_ttype\n };\n #undef T\n #undef H\n+#undef C\n #undef N\n #undef E\n "}]}