{"sha": "765828d5a8a3eb8e9c1abbad04de6d9784a03b92", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzY1ODI4ZDVhOGEzZWI4ZTljMWFiYmFkMDRkZTZkOTc4NGEwM2I5Mg==", "commit": {"author": {"name": "Andrew Haley", "email": "aph@redhat.com", "date": "2002-12-03T13:53:27Z"}, "committer": {"name": "Andrew Haley", "email": "aph@gcc.gnu.org", "date": "2002-12-03T13:53:27Z"}, "message": "natClassLoader.cc (_Jv_PrepareCompiledClass): Call _Jv_PushClass.\n\n2002-12-03  Andrew Haley  <aph@redhat.com>\n\n        * java/lang/natClassLoader.cc (_Jv_PrepareCompiledClass): Call\n\t_Jv_PushClass.\n        (_Jv_InitNewClassFields): Set protectionDomain and chain = NULL.\n        (_Jv_PopClass): New.\n        (_Jv_PushClass): New.\n        * java/lang/natClass.cc (forName (jstring)): Use a StackTrace to\n        discover the ClassLoader of our caller.\n        (_Jv_CheckArrayStore): Don't check that a class is assignment\n        compatible with Object.\n        * java/lang/natVMTHrowable.cc: Delete.\n        * gnu/gcj/runtime/StackTrace.java: New, partly copied from\n\tjava.lang.VMThrowable.\n        (StackTrace(), StackTrace(int)): New constructors.\n        (classAt, methodAt, update, methodAtAddress): New methods.\n        (map): New field.\n\t* java/lang/VMThrowable.java: Use StackTrace instead of\n\tnatVMTHrowable.\n\t* java/lang/Class.h (getClassLoaderInternal): New.\n        (class Class): Be friendly with _Jv_PopClass and _Jv_PushClass.\n        Be friendly with gnu::gcj::runtime::StackTrace.\n        (Object.chain): New field.\n        * include/java-interp.h (class _Jv_InterpMethod): Be friendly with\n        gnu::gcj::runtime::StackTrace.\n\t* gnu/gcj/runtime/natStackTrace.cc: New file.\n\t* gnu/gcj/runtime/MethodRef.java: New file.\n        * prims.cc (_Jv_NewObjectArray): Use getClassLoaderInternal()\n        instead of getClassLoader().\n        * verify.cc (class _Jv_BytecodeVerifier): Likewise.\n        java::lang::VMThrowable.\n        * Makefile.am (core_java_source_files): Add MethodRef.java,\n\tStackTrace.java.\n        (nat_source_files): Remove natVMThrowable.cc; add natStackTrace.cc.\n        * Makefile.in: Rebuild.\n\nFrom-SVN: r59771", "tree": {"sha": "5865e5119308160d0363f05e376c74f261fc5355", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5865e5119308160d0363f05e376c74f261fc5355"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/765828d5a8a3eb8e9c1abbad04de6d9784a03b92", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/765828d5a8a3eb8e9c1abbad04de6d9784a03b92", "html_url": "https://github.com/Rust-GCC/gccrs/commit/765828d5a8a3eb8e9c1abbad04de6d9784a03b92", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/765828d5a8a3eb8e9c1abbad04de6d9784a03b92/comments", "author": {"login": "theRealAph", "id": 254637, "node_id": "MDQ6VXNlcjI1NDYzNw==", "avatar_url": "https://avatars.githubusercontent.com/u/254637?v=4", "gravatar_id": "", "url": "https://api.github.com/users/theRealAph", "html_url": "https://github.com/theRealAph", "followers_url": "https://api.github.com/users/theRealAph/followers", "following_url": "https://api.github.com/users/theRealAph/following{/other_user}", "gists_url": "https://api.github.com/users/theRealAph/gists{/gist_id}", "starred_url": "https://api.github.com/users/theRealAph/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/theRealAph/subscriptions", "organizations_url": "https://api.github.com/users/theRealAph/orgs", "repos_url": "https://api.github.com/users/theRealAph/repos", "events_url": "https://api.github.com/users/theRealAph/events{/privacy}", "received_events_url": "https://api.github.com/users/theRealAph/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "f3f110d5d1a748bf3b8a71c30fb0e786140d82ad", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f3f110d5d1a748bf3b8a71c30fb0e786140d82ad", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f3f110d5d1a748bf3b8a71c30fb0e786140d82ad"}], "stats": {"total": 419, "additions": 419, "deletions": 0}, "files": [{"sha": "66fcfc71137f3cc024967e335a153c659438cec9", "filename": "libjava/ChangeLog", "status": "modified", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/765828d5a8a3eb8e9c1abbad04de6d9784a03b92/libjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/765828d5a8a3eb8e9c1abbad04de6d9784a03b92/libjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FChangeLog?ref=765828d5a8a3eb8e9c1abbad04de6d9784a03b92", "patch": "@@ -1,3 +1,39 @@\n+2002-12-03  Andrew Haley  <aph@redhat.com>\n+\n+        * java/lang/natClassLoader.cc (_Jv_PrepareCompiledClass): Call\n+\t_Jv_PushClass.\n+        (_Jv_InitNewClassFields): Set protectionDomain and chain = NULL.\n+        (_Jv_PopClass): New.\n+        (_Jv_PushClass): New.\n+        * java/lang/natClass.cc (forName (jstring)): Use a StackTrace to\n+        discover the ClassLoader of our caller.\n+        (_Jv_CheckArrayStore): Don't check that a class is assignment\n+        compatible with Object.\n+        * java/lang/natVMTHrowable.cc: Delete.\n+        * gnu/gcj/runtime/StackTrace.java: New, partly copied from\n+\tjava.lang.VMThrowable.\n+        (StackTrace(), StackTrace(int)): New constructors.\n+        (classAt, methodAt, update, methodAtAddress): New methods.\n+        (map): New field.\n+\t* java/lang/VMThrowable.java: Use StackTrace instead of\n+\tnatVMTHrowable.        \n+\t* java/lang/Class.h (getClassLoaderInternal): New.\n+        (class Class): Be friendly with _Jv_PopClass and _Jv_PushClass.\n+        Be friendly with gnu::gcj::runtime::StackTrace.\n+        (Object.chain): New field.\n+        * include/java-interp.h (class _Jv_InterpMethod): Be friendly with\n+        gnu::gcj::runtime::StackTrace.\n+\t* gnu/gcj/runtime/natStackTrace.cc: New file.\n+\t* gnu/gcj/runtime/MethodRef.java: New file.\n+        * prims.cc (_Jv_NewObjectArray): Use getClassLoaderInternal()\n+        instead of getClassLoader().\n+        * verify.cc (class _Jv_BytecodeVerifier): Likewise.\n+        java::lang::VMThrowable.\n+        * Makefile.am (core_java_source_files): Add MethodRef.java,\n+\tStackTrace.java.\n+        (nat_source_files): Remove natVMThrowable.cc; add natStackTrace.cc.\n+        * Makefile.in: Rebuild.\n+\n 2002-12-02  Tom Tromey  <tromey@redhat.com>\n \n \t* jni.cc: Added `name' argument."}, {"sha": "f15746164a6b5568571e9b06afec0e205e95a9d7", "filename": "libjava/gnu/gcj/runtime/MethodRef.java", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/765828d5a8a3eb8e9c1abbad04de6d9784a03b92/libjava%2Fgnu%2Fgcj%2Fruntime%2FMethodRef.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/765828d5a8a3eb8e9c1abbad04de6d9784a03b92/libjava%2Fgnu%2Fgcj%2Fruntime%2FMethodRef.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fgnu%2Fgcj%2Fruntime%2FMethodRef.java?ref=765828d5a8a3eb8e9c1abbad04de6d9784a03b92", "patch": "@@ -0,0 +1,25 @@\n+// gnu.gcj.runtime.MethodRef -- used by StackTrace.\n+\n+/* Copyright (C) 2002  Free Software Foundation\n+\n+   This file is part of libgcj.\n+\n+This software is copyrighted work licensed under the terms of the\n+Libgcj License.  Please consult the file \"LIBGCJ_LICENSE\" for\n+details.  */\n+\n+package gnu.gcj.runtime;\n+\n+import gnu.gcj.RawData;\n+\n+class MethodRef\n+{\n+  MethodRef(RawData /* Actually _Jv_Method */ m, Class k)\n+  {\n+    klass = k;\n+    method = m;\n+  }\n+\n+  public RawData method; // Actually a raw pointer to _Jv_Method\n+  public Class klass;\n+}"}, {"sha": "5faaa1495ae0c9aef8a86dbb0e4de1287b8d590f", "filename": "libjava/gnu/gcj/runtime/StackTrace.java", "status": "added", "additions": 164, "deletions": 0, "changes": 164, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/765828d5a8a3eb8e9c1abbad04de6d9784a03b92/libjava%2Fgnu%2Fgcj%2Fruntime%2FStackTrace.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/765828d5a8a3eb8e9c1abbad04de6d9784a03b92/libjava%2Fgnu%2Fgcj%2Fruntime%2FStackTrace.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fgnu%2Fgcj%2Fruntime%2FStackTrace.java?ref=765828d5a8a3eb8e9c1abbad04de6d9784a03b92", "patch": "@@ -0,0 +1,164 @@\n+/* gnu.gcj.runtime.StackTrace -- VM support methods for walking the\n+   stack.\n+   Copyright (C) 1998, 1999, 2002 Free Software Foundation, Inc.\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+\n+Linking this library statically or dynamically with other modules is\n+making a combined work based on this library.  Thus, the terms and\n+conditions of the GNU General Public License cover the whole\n+combination.\n+\n+As a special exception, the copyright holders of this library give you\n+permission to link this library with independent modules to produce an\n+executable, regardless of the license terms of these independent\n+modules, and to copy and distribute the resulting executable under\n+terms of your choice, provided that you also meet, for each linked\n+independent module, the terms and conditions of the license of that\n+module.  An independent module is a module which is not derived from\n+or based on this library.  If you modify this library, you may extend\n+this exception to your version of the library, but you are not\n+obligated to do so.  If you do not wish to do so, delete this\n+exception statement from your version. */\n+\n+package gnu.gcj.runtime;\n+\n+import gnu.gcj.RawData;\n+import java.util.TreeMap;\n+import java.util.IdentityHashMap;\n+import java.util.SortedMap;\n+import gnu.gcj.runtime.NameFinder;\n+import java.util.NoSuchElementException;\n+\n+/**\n+ * VM dependent state and support methods for walking the stack.\n+ * <p>\n+ * This is the version used by libgcj (http://gcc.gnu.org/java/).\n+ *\n+ * @author Mark Wielaard (mark@klomp.org)\n+ * @author Andrew Haley (aph@redhat.com)\n+ */\n+public final class StackTrace\n+{\n+  /**\n+   * Fill in the stack trace with the top n frames on current\n+   * execution stack.  Can return null if the VM does not support\n+   * capturing the VM execution state.\n+   *\n+   * @see Throwable#fillInStackTrace()\n+   */\n+  public StackTrace(int n)\n+  {\n+    fillInStackTrace(n, 1);\n+  }\n+\n+  /**\n+   * Fill in the stack trace with state of the entire execution stack,\n+   * starting from frame <code>offset</code>.  Can return null if the\n+   * VM does not support capturing the VM execution state.\n+   *\n+   * This can be very expensive.  If you only want part of the stack,\n+   * see <code>Throwable.fillInStackTrace(int)</code>\n+   *\n+   * @see Throwable#fillInStackTrace()\n+   */\n+  public StackTrace()\n+  {\n+    int n = 64;\n+    \n+    do\n+      {\n+\tn *= 4;\n+\tfillInStackTrace(n, 1);\n+      }\n+    while (len >= n);\n+  }\n+\n+  /**\n+   * Return the class containing the execution point represented by\n+   * the Nth frame down the stack.  The zeroth frame represents the\n+   * top of the stack, which is the method that called classAt().\n+   *\n+   * If the Nth frame down the stack was not create by a method\n+   * invocation, return null.\n+   *\n+   * It is not necessary to call <code>fillInStackTrace()</code> with\n+   * a size greater than N before calling this method; if the current\n+   * stack trace is insufficiently large, it will be expanded as\n+   * required.  This requires some caution if\n+   * <code>fillInStackTrace()</code> is called from a different\n+   * invocation to the one that calls <code>classAt()</code>.\n+   * classAt() will not call <code>fillInStackTrace()</code> unless N\n+   * is greater than the current length.\n+   *\n+   */\n+  public native Class classAt(int n);\n+\n+  /**\n+   * Return the name of the method containing the execution point\n+   * represented by the Nth frame down the stack.  The zeroth frame\n+   * represents the top of the stack, which is the method that called\n+   * classAt().\n+   *\n+   * If the Nth frame down the stack was not create by a method\n+   * invocation, return null.\n+   *\n+   * It is not necessary to call <code>fillInStackTrace()</code> with\n+   * a size greater than N before calling this method; if the current\n+   * stack trace is insufficiently large, it will be expanded as\n+   * required.  This requires some caution if\n+   * <code>fillInStackTrace()</code> is called from a different\n+   * invocation to the one that calls <code>classAt()</code>.\n+   * classAt() will not call <code>fillInStackTrace()</code> unless N\n+   * is greater than the current length.\n+   *\n+   */\n+  public native String methodAt(int n);\n+\n+  /**\n+   * Return the length of this stack trace.\n+   *\n+   */\n+  public int length ()\n+  {\n+    return len;\n+  }\n+\n+  private static native void update();\n+  private static MethodRef methodAtAddress(RawData addr)\n+  {\n+    update();\n+    synchronized (map)\n+      {\n+\treturn (MethodRef) map.get (addr);\n+      }\n+  }\n+\n+  gnu.gcj.RawData stackTraceAddrs()\n+  {\n+    return addrs;\n+  }\n+  \n+  private native void fillInStackTrace(int n, int offset);\n+\n+  private static native MethodRef getCompiledMethodRef(RawData addr);\n+  private static IdentityHashMap map = new IdentityHashMap();\n+\n+  private gnu.gcj.RawData addrs;\n+  private int len;\n+}"}, {"sha": "5cd89e31a6f581a1095255d8d9b0a2b2c7b2b8e9", "filename": "libjava/gnu/gcj/runtime/natStackTrace.cc", "status": "added", "additions": 194, "deletions": 0, "changes": 194, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/765828d5a8a3eb8e9c1abbad04de6d9784a03b92/libjava%2Fgnu%2Fgcj%2Fruntime%2FnatStackTrace.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/765828d5a8a3eb8e9c1abbad04de6d9784a03b92/libjava%2Fgnu%2Fgcj%2Fruntime%2FnatStackTrace.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fgnu%2Fgcj%2Fruntime%2FnatStackTrace.cc?ref=765828d5a8a3eb8e9c1abbad04de6d9784a03b92", "patch": "@@ -0,0 +1,194 @@\n+// natStackTrace.cc - native helper methods for Throwable\n+\n+/* Copyright (C) 2000, 2002  Free Software Foundation, Inc\n+\n+   This file is part of libgcj.\n+\n+This software is copyrighted work licensed under the terms of the\n+Libgcj License.  Please consult the file \"LIBGCJ_LICENSE\" for\n+details.  */\n+\n+/**\n+ * @author Andrew Haley <aph@cygnus.com>\n+ * @author Mark Wielaard <mark@klomp.org>\n+ *\n+ * Native helper methods for VM specific Throwable support.\n+ */\n+\n+#include <config.h>\n+\n+#include <string.h>\n+\n+#include <jvm.h>\n+#include <gcj/cni.h>\n+#include <gnu/gcj/RawData.h>\n+#include <java/lang/Object.h>\n+#include <java-threads.h>\n+#include <gnu/gcj/runtime/MethodRef.h>\n+#include <gnu/gcj/runtime/StackTrace.h>\n+#include <java/lang/Thread.h>\n+#include <java-interp.h>\n+#include <java/util/IdentityHashMap.h>\n+#include <java/lang/ArrayIndexOutOfBoundsException.h>\n+\n+#include <sys/types.h>\n+\n+#include <stdlib.h>\n+\n+#include <unistd.h>\n+\n+#ifdef HAVE_EXECINFO_H\n+#include <execinfo.h>\n+#endif\n+\n+#include <unwind.h>\n+\n+\n+// Fill in this stack trace with N elements starting at offset.\n+void\n+gnu::gcj::runtime::StackTrace::fillInStackTrace (jint maxlen, jint offset)\n+{\n+#if defined (HAVE_BACKTRACE)\n+  offset += 1;\n+  void *_p[maxlen + offset];\n+  len = backtrace (_p, maxlen + offset) - offset;\n+  void **p = _p + offset;\n+#endif\n+  _Jv_frame_info *frame;\n+  if (len > 0)\n+    {\n+#ifdef INTERPRETER\n+      extern void _Jv_StartOfInterpreter (void);\n+      extern void _Jv_EndOfInterpreter (void);\n+\n+      java::lang::Thread *thread = java::lang::Thread::currentThread();\n+      _Jv_MethodChain *interp_frame\n+\t= (thread ? reinterpret_cast<_Jv_MethodChain *> (thread->interp_frame)\n+\t   : NULL);\n+#endif // INTERPRETER\n+\n+      frame = (_Jv_frame_info *) _Jv_Malloc (len * sizeof (_Jv_frame_info));\n+      for (int n = 0; n < len; n++)\n+\t{\n+\t  frame[n].addr = p[n];\n+#ifdef INTERPRETER\n+\t  if (p[n] >= &_Jv_StartOfInterpreter && p[n] <= &_Jv_EndOfInterpreter)\n+\t    {\n+\t      frame[n].interp = (void *) interp_frame->self;\n+\t      interp_frame = interp_frame->next;\n+\t    }\n+\t  else\n+\t    frame[n].interp = 0;\n+#endif // INTERPRETER\n+\t}\n+    }\n+  else\n+    frame = NULL;\n+\n+  addrs = reinterpret_cast<gnu::gcj::RawData *> (frame);\n+}\n+\n+/* Obtain the next power-of-2 of some integer.  */\n+static inline jint\n+nextpowerof2 (jint n)\n+{\n+  n |= (n >> 1);\n+  n |= (n >> 2);\n+  n |= (n >> 4);\n+  n |= (n >> 8);\n+  n |= (n >> 16);\n+  return n+1;\n+}\n+\n+#define GET_FRAME(N)\t\t\t\t\t\t\\\n+({\t\t\t\t\t\t\t\t\\\n+  if ((N) >= len)\t\t\t\t\t\t\\\n+    fillInStackTrace (nextpowerof2 (N), 1);\t\t\t\\\n+  if ((N) < 0 || (N) >= len)\t\t\t\t\t\\\n+    throw new ::java::lang::ArrayIndexOutOfBoundsException ();\t\\\n+\t\t\t\t\t\t\t\t\\\n+  _Jv_frame_info *frame = (_Jv_frame_info *)addrs;\t\t\\\n+  &frame[N];\t\t\t\t\t\t\t\\\n+})\n+\n+gnu::gcj::runtime::MethodRef *\n+gnu::gcj::runtime::StackTrace::getCompiledMethodRef (gnu::gcj::RawData *addr)\n+{\n+  void *p = _Unwind_FindEnclosingFunction (addr);\n+  return gnu::gcj::runtime::StackTrace\n+    ::methodAtAddress ((gnu::gcj::RawData *)p);\n+}\n+\n+java::lang::Class *\n+gnu::gcj::runtime::StackTrace::classAt (jint n)\n+{\n+  _Jv_frame_info *frame = GET_FRAME (n);\n+\n+#ifdef INTERPRETER\n+  if (frame->interp)\n+    {\n+      _Jv_InterpMethod *meth\n+\t= reinterpret_cast<_Jv_InterpMethod *> (frame->interp);\n+      return meth->defining_class;\n+    }\n+#endif // INTERPRETER\n+  \n+  gnu::gcj::runtime::MethodRef *ref \n+    = getCompiledMethodRef ((gnu::gcj::RawData *)frame->addr);\n+  if (ref)\n+    return ref->klass;\n+  else\n+    return NULL;\n+}\n+\n+java::lang::String*\n+gnu::gcj::runtime::StackTrace::methodAt (jint n)\n+{\n+  _Jv_frame_info *frame = GET_FRAME (n);\n+  _Jv_Method *meth = NULL;\n+\n+#ifdef INTERPRETER\n+  if (frame->interp)\n+    {\n+      meth\n+\t= reinterpret_cast<_Jv_InterpMethod *> (frame->interp)\n+\t->get_method();\n+    }\n+#endif // INTERPRETER\n+  \n+  if (! meth)\n+    {\n+      gnu::gcj::runtime::MethodRef *ref\n+\t= getCompiledMethodRef ((gnu::gcj::RawData *)frame->addr);\n+      if (ref)\n+\tmeth = (_Jv_Method *)ref->method;\n+    }\n+\n+  return meth \n+    ? _Jv_NewStringUtf8Const (meth->name)\n+    : NULL ;\n+}\n+\n+void\n+gnu::gcj::runtime::StackTrace::update(void)\n+{\n+  jclass klass;\n+\n+  while ((klass = _Jv_PopClass ()))\n+    {\n+      for (int i=0; i<klass->method_count; i++)\n+\t{\n+\t  JvSynchronize sync (map);\n+\t  _Jv_Method *meth = &(klass->methods[i]);\n+\t  if (meth->ncode) // i.e. if p is not abstract\n+\t    {\n+\t      gnu::gcj::runtime::MethodRef *ref\n+\t\t= new gnu::gcj::runtime::MethodRef \n+\t\t((gnu::gcj::RawData *)meth, klass);\n+\t      map->put ((java::lang::Object*)(meth->ncode), ref);\n+\t    }\n+\t}\n+    }\n+}\n+\n+"}]}