{"sha": "666b023ed56c877369cf22f53081e6fc1d6c744b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NjY2YjAyM2VkNTZjODc3MzY5Y2YyMmY1MzA4MWU2ZmMxZDZjNzQ0Yg==", "commit": {"author": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1994-02-22T13:09:58Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1994-02-22T13:09:58Z"}, "message": "(FUNCTION_{PROLOGUE,EPILOGUE}): %$ is not supported in fprintf.\n\n(ADJSP): New macro to resolve %$.\n\n(output_move_dconst): New declaration.\n\n(OVERRIDE_OPTIONS): New macro to support PIC.\n(FUNCTION_PROLOGUE): Save/Load sb when compiling PIC.\n(FUNCTION_EPILOGUE): Restore sb when compiling PIC.\n(INITIAL_FRAME_POINTER_OFFSET): Take saved sb into account when PIC.\n(LEGITIMATE_CONSTANT_P, GO_IF_LEGITIMATE_ADDRESS): Set\ncurrent_function_uses_pic_offset_table if P uses a global symbolic reference.\n(ENCODE_SECTION_INFO): New macro to support PIC.\n\nFrom-SVN: r6603", "tree": {"sha": "c30fd1d3fe058e1cd4f607f38a6385889861f186", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c30fd1d3fe058e1cd4f607f38a6385889861f186"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/666b023ed56c877369cf22f53081e6fc1d6c744b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/666b023ed56c877369cf22f53081e6fc1d6c744b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/666b023ed56c877369cf22f53081e6fc1d6c744b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/666b023ed56c877369cf22f53081e6fc1d6c744b/comments", "author": null, "committer": null, "parents": [{"sha": "98ff4808a08a68bd3cc410ec1b2b22e39b104ce7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/98ff4808a08a68bd3cc410ec1b2b22e39b104ce7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/98ff4808a08a68bd3cc410ec1b2b22e39b104ce7"}], "stats": {"total": 73, "additions": 68, "deletions": 5}, "files": [{"sha": "c3d0621559e64eb47da99140c37e72ae8c4cd98f", "filename": "gcc/config/ns32k/ns32k.h", "status": "modified", "additions": 68, "deletions": 5, "changes": 73, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/666b023ed56c877369cf22f53081e6fc1d6c744b/gcc%2Fconfig%2Fns32k%2Fns32k.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/666b023ed56c877369cf22f53081e6fc1d6c744b/gcc%2Fconfig%2Fns32k%2Fns32k.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fns32k%2Fns32k.h?ref=666b023ed56c877369cf22f53081e6fc1d6c744b", "patch": "@@ -1,5 +1,5 @@\n /* Definitions of target machine for GNU compiler.  NS32000 version.\n-   Copyright (C) 1988, 1993 Free Software Foundation, Inc.\n+   Copyright (C) 1988, 1993, 1994 Free Software Foundation, Inc.\n    Contributed by Michael Tiemann (tiemann@mcc.com)\n \n This file is part of GNU CC.\n@@ -103,6 +103,15 @@ extern int target_flags;\n     { \"nosb\", 32},\t\t\t\t\\\n     { \"\", TARGET_DEFAULT}}\n /* TARGET_DEFAULT is defined in encore.h, pc532.h, etc.  */\n+\n+/* When we are generating PIC, the sb is used as a pointer\n+   to the GOT.  */\n+\n+#define OVERRIDE_OPTIONS\t\t\\\n+{\t\t\t\t\t\\\n+  if (flag_pic) target_flags |= 32;\t\\\n+}\n+\n \f\n /* target machine storage layout */\n \n@@ -524,12 +533,20 @@ enum reg_class { NO_REGS, GENERAL_REGS, FLOAT_REGS, GEN_AND_FP_REGS,\n  *  .\n  *  .\n  */\n+#if defined(IMMEDIATE_PREFIX) && IMMEDIATE_PREFIX\n+#define ADJSP(FILE, n) \\\n+        fprintf (FILE, \"\\tadjspd %c%d\\n\", IMMEDIATE_PREFIX, (n))\n+#else\n+#define ADJSP(FILE, n) \\\n+        fprintf (FILE, \"\\tadjspd %d\\n\", (n))\n+#endif\n \n #define FUNCTION_PROLOGUE(FILE, SIZE)     \\\n { register int regno, g_regs_used = 0;\t\t\t\t\\\n   int used_regs_buf[8], *bufp = used_regs_buf;\t\t\t\\\n   int used_fregs_buf[8], *fbufp = used_fregs_buf;\t\t\\\n   extern char call_used_regs[];\t\t\t\t\t\\\n+  extern int current_function_uses_pic_offset_table, flag_pic;\t\\\n   MAIN_FUNCTION_PROLOGUE;\t\t\t\t\t\\\n   for (regno = 0; regno < 8; regno++)\t\t\t\t\\\n     if (regs_ever_live[regno]\t\t\t\t\t\\\n@@ -550,7 +567,7 @@ enum reg_class { NO_REGS, GENERAL_REGS, FLOAT_REGS, GEN_AND_FP_REGS,\n   else\t\t\t\t\t\t\t\t\\\n     {\t\t\t\t\t\t\t\t\\\n       if (SIZE)\t\t\t\t\t\t\t\\\n-        fprintf (FILE, \"\\tadjspd %$%d\\n\", SIZE + 4);\t\t\\\n+        ADJSP (FILE, SIZE + 4);\t\t\t\t\t\\\n       if (g_regs_used && g_regs_used > 4)\t\t\t\\\n         fprintf (FILE, \"\\tsave [\");\t\t\t\t\\\n       else\t\t\t\t\t\t\t\\\n@@ -581,6 +598,12 @@ enum reg_class { NO_REGS, GENERAL_REGS, FLOAT_REGS, GEN_AND_FP_REGS,\n \t  fbufp += 2;\t\t\t\t\t\t\\\n \t}\t\t\t\t\t\t\t\\\n     }\t\t\t\t\t\t\t\t\\\n+  if (flag_pic && current_function_uses_pic_offset_table)\t\\\n+    {\t\t\t\t\t\t\t\t\\\n+      fprintf (FILE, \"\\tsprd sb,tos\\n\");\t\t\t\\\n+      fprintf (FILE, \"\\taddr _GLOBAL_OFFSET_TABLE_(pc),tos\\n\");\t\\\n+      fprintf (FILE, \"\\tlprd sb,tos\\n\");\t\t\t\\\n+    }\t\t\t\t\t\t\t\t\\\n }\n \n /* Output assembler code to FILE to increment profiler label # LABELNO\n@@ -639,6 +662,9 @@ enum reg_class { NO_REGS, GENERAL_REGS, FLOAT_REGS, GEN_AND_FP_REGS,\n   int used_regs_buf[8], *bufp = used_regs_buf;\t\t\t\\\n   int used_fregs_buf[8], *fbufp = used_fregs_buf;\t\t\\\n   extern char call_used_regs[];\t\t\t\t\t\\\n+  extern int current_function_uses_pic_offset_table, flag_pic;\t\\\n+  if (flag_pic && current_function_uses_pic_offset_table)\t\\\n+    fprintf (FILE, \"\\tlprd sb,tos\\n\");\t\t\t\t\\\n   *fbufp++ = -2;\t\t\t\t\t\t\\\n   for (regno = 8; regno < 16; regno++)\t\t\t\t\\\n     if (regs_ever_live[regno] && !call_used_regs[regno])\t\\\n@@ -683,7 +709,7 @@ enum reg_class { NO_REGS, GENERAL_REGS, FLOAT_REGS, GEN_AND_FP_REGS,\n   if (g_regs_used || frame_pointer_needed)\t\t\t\\\n     fprintf (FILE, \"]\\n\");\t\t\t\t\t\\\n   if (SIZE && !frame_pointer_needed)\t\t\t\t\\\n-    fprintf (FILE, \"\\tadjspd %$%d\\n\", -(SIZE + 4));\t\t\\\n+    ADJSP (FILE, -(SIZE + 4));\t\t\t\t\t\\\n   if (current_function_pops_args)\t\t\t\t\\\n     fprintf (FILE, \"\\tret %d\\n\", current_function_pops_args);\t\\\n   else fprintf (FILE, \"\\tret 0\\n\"); }\n@@ -697,9 +723,12 @@ enum reg_class { NO_REGS, GENERAL_REGS, FLOAT_REGS, GEN_AND_FP_REGS,\n {\t\t\t\t\t\t\t\t\\\n   int regno;\t\t\t\t\t\t\t\\\n   int offset = -4;\t\t\t\t\t\t\\\n+  extern int current_function_uses_pic_offset_table, flag_pic;\t\\\n   for (regno = 0; regno < 16; regno++)\t\t\t\t\\\n     if (regs_ever_live[regno] && ! call_used_regs[regno])\t\\\n       offset += 4;\t\t\t\t\t\t\\\n+  if (flag_pic && current_function_uses_pic_offset_table)\t\\\n+    offset += 4;\t\t\t\t\t\t\\\n   (DEPTH) = (offset + get_frame_size ()\t\t\t\t\\\n \t     + (get_frame_size () == 0 ? 0 : 4));\t\t\\\n }\n@@ -814,7 +843,12 @@ __transfer_from_trampoline ()\t\t\\\n /* Nonzero if the constant value X is a legitimate general operand.\n    It is given that X satisfies CONSTANT_P or is a CONST_DOUBLE.  */\n \n-#define LEGITIMATE_CONSTANT_P(X) 1\n+extern int current_function_uses_pic_offset_table, flag_pic;\n+#define LEGITIMATE_CONSTANT_P(X) \\\n+  (((flag_pic && ! current_function_uses_pic_offset_table\t\\\n+     && global_symbolic_reference_mentioned_p (X))?\t\t\\\n+      (current_function_uses_pic_offset_table = 1):0\t\t\\\n+   ), 1)\n \n /* The macros REG_OK_FOR..._P assume that the arg is a REG rtx\n    and check its validity for a certain class.\n@@ -944,10 +978,14 @@ __transfer_from_trampoline ()\t\t\\\n    ((xfoo2 < 4 && xfoo2 != 2) || xfoo2 == 7))\n \n /* Note that xfoo0, xfoo1, xfoo2 are used in some of the submacros above.  */\n-#define GO_IF_LEGITIMATE_ADDRESS(MODE, X, ADDR)  \\\n+#define GO_IF_LEGITIMATE_ADDRESS(MODE, X, ADDR) \\\n { register rtx xfooy, xfoo0, xfoo1;\t\t\t\t\t\\\n   unsigned xfoo2;\t\t\t\t\t\t\t\\\n+  extern int current_function_uses_pic_offset_table, flag_pic;\t\t\\\n   xfooy = X;\t\t\t\t\t\t\t\t\\\n+  if (flag_pic && ! current_function_uses_pic_offset_table\t\t\\\n+      && global_symbolic_reference_mentioned_p (X))\t\t\t\\\n+    current_function_uses_pic_offset_table = 1;\t\t\t\t\\\n   GO_IF_NONINDEXED_ADDRESS (xfooy, ADDR);\t\t\t\t\\\n   if (GET_CODE (xfooy) == PLUS)\t\t\t\t\t\t\\\n     {\t\t\t\t\t\t\t\t\t\\\n@@ -983,6 +1021,30 @@ __transfer_from_trampoline ()\t\t\\\n \n #define LEGITIMIZE_ADDRESS(X,OLDX,MODE,WIN)   {}\n \n+/* Define this macro if references to a symbol must be treated\n+   differently depending on something about the variable or\n+   function named by the symbol (such as what section it is in).\n+\n+   On the ns32k, if using PIC, mark a SYMBOL_REF for a non-global\n+   symbol or a code symbol. These symbols are referenced via pc\n+   and not via sb. */\n+\n+#define ENCODE_SECTION_INFO(DECL) \\\n+do\t\t\t\t\t\t\t\t\t\\\n+  {\t\t\t\t\t\t\t\t\t\\\n+    extern int flag_pic;\t\t\t\t\t\t\\\n+    if (flag_pic)\t\t\t\t\t\t\t\\\n+      {\t\t\t\t\t\t\t\t\t\\\n+\trtx rtl = (TREE_CODE_CLASS (TREE_CODE (DECL)) != 'd'\t\t\\\n+\t\t   ? TREE_CST_RTL (DECL) : DECL_RTL (DECL));\t\t\\\n+\tSYMBOL_REF_FLAG (XEXP (rtl, 0))\t\t\t\t\t\\\n+\t  = (TREE_CODE_CLASS (TREE_CODE (DECL)) != 'd'\t\t\t\\\n+\t     || TREE_CODE (DECL) == FUNCTION_DECL\t\t\t\\\n+\t     || ! TREE_PUBLIC (DECL));\t\t\t\t\t\\\n+      }\t\t\t\t\t\t\t\t\t\\\n+  }\t\t\t\t\t\t\t\t\t\\\n+while (0)\n+\n /* Go to LABEL if ADDR (a legitimate address expression)\n    has an effect that depends on the machine mode it is used for.\n    On the ns32k, only predecrement and postincrement address depend thus\n@@ -1380,6 +1442,7 @@ do {\t\t\t\t\t\t\t\t\t\\\n \n extern char *output_move_double ();\n extern char *output_shift_insn ();\n+extern char *output_move_dconst ();\n \n /*\n Local variables:"}]}