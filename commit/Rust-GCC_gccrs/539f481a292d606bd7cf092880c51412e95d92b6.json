{"sha": "539f481a292d606bd7cf092880c51412e95d92b6", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTM5ZjQ4MWEyOTJkNjA2YmQ3Y2YwOTI4ODBjNTE0MTJlOTVkOTJiNg==", "commit": {"author": {"name": "Nathan Sidwell", "email": "nathan@acm.org", "date": "2017-05-17T15:41:23Z"}, "committer": {"name": "Nathan Sidwell", "email": "nathan@gcc.gnu.org", "date": "2017-05-17T15:41:23Z"}, "message": "cp-tree.h (default_hash_traits <lang_identifier *>): New specialization.\n\n\t* cp-tree.h (default_hash_traits <lang_identifier *>): New\n\tspecialization.\n\t* name-lookup.c (lookup_extern_c_fun_in_all_ns): Delete.\n\t(extern_c_fns): New hash table.\n\t(check_extern_c_conflict): New, broken out of ...\n\t(pushdecl_maybe_friend_1): ... here.  Call it.\n\t(c_linkage_bindings): Just look in hash table.\n\nFrom-SVN: r248159", "tree": {"sha": "53aba9673ac838d39acb0850e6b131d32bdb8607", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/53aba9673ac838d39acb0850e6b131d32bdb8607"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/539f481a292d606bd7cf092880c51412e95d92b6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/539f481a292d606bd7cf092880c51412e95d92b6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/539f481a292d606bd7cf092880c51412e95d92b6", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/539f481a292d606bd7cf092880c51412e95d92b6/comments", "author": {"login": "urnathan", "id": 13103001, "node_id": "MDQ6VXNlcjEzMTAzMDAx", "avatar_url": "https://avatars.githubusercontent.com/u/13103001?v=4", "gravatar_id": "", "url": "https://api.github.com/users/urnathan", "html_url": "https://github.com/urnathan", "followers_url": "https://api.github.com/users/urnathan/followers", "following_url": "https://api.github.com/users/urnathan/following{/other_user}", "gists_url": "https://api.github.com/users/urnathan/gists{/gist_id}", "starred_url": "https://api.github.com/users/urnathan/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/urnathan/subscriptions", "organizations_url": "https://api.github.com/users/urnathan/orgs", "repos_url": "https://api.github.com/users/urnathan/repos", "events_url": "https://api.github.com/users/urnathan/events{/privacy}", "received_events_url": "https://api.github.com/users/urnathan/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "e5b1f5a1d11f73ff289ffebfeccbc0650531367b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e5b1f5a1d11f73ff289ffebfeccbc0650531367b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e5b1f5a1d11f73ff289ffebfeccbc0650531367b"}], "stats": {"total": 228, "additions": 102, "deletions": 126}, "files": [{"sha": "c404cedc7833e80ab3ab1ff7a889aef3fea457cd", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/539f481a292d606bd7cf092880c51412e95d92b6/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/539f481a292d606bd7cf092880c51412e95d92b6/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=539f481a292d606bd7cf092880c51412e95d92b6", "patch": "@@ -1,3 +1,13 @@\n+2017-05-17  Nathan Sidwell  <nathan@acm.org>\n+\n+\t* cp-tree.h (default_hash_traits <lang_identifier *>): New\n+\tspecialization.\n+\t* name-lookup.c (lookup_extern_c_fun_in_all_ns): Delete.\n+\t(extern_c_fns): New hash table.\n+\t(check_extern_c_conflict): New, broken out of ...\n+\t(pushdecl_maybe_friend_1): ... here.  Call it.\n+\t(c_linkage_bindings): Just look in hash table.\n+\n 2017-05-17  Ville Voutilainen  <ville.voutilainen@gmail.com>\n \n \tPR c++/80654"}, {"sha": "25b05ef6cd0a7486ef44a6072ce25b718b6ec257", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/539f481a292d606bd7cf092880c51412e95d92b6/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/539f481a292d606bd7cf092880c51412e95d92b6/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=539f481a292d606bd7cf092880c51412e95d92b6", "patch": "@@ -535,6 +535,26 @@ identifier_p (tree t)\n   return NULL;\n }\n \n+/* Hash trait specialization for lang_identifiers.  This allows\n+   PCH-safe maps keyed by DECL_NAME.  If it wasn't for PCH, we could\n+   just use a regular tree key.  */\n+\n+template <>\n+struct default_hash_traits <lang_identifier *>\n+  : pointer_hash <tree_node>, ggc_remove <tree>\n+{\n+  /* Use a regular tree as the type, to make using the hash table\n+     simpler.  We'll get dynamic type checking with the hash function\n+     itself.  */\n+  GTY((skip)) typedef tree value_type;\n+  GTY((skip)) typedef tree compare_type;\n+\n+  static hashval_t hash (const value_type &id)\n+  {\n+    return IDENTIFIER_HASH_VALUE (id);\n+  }\n+};\n+\n /* In an IDENTIFIER_NODE, nonzero if this identifier is actually a\n    keyword.  C_RID_CODE (node) is then the RID_* value of the keyword.  */\n "}, {"sha": "83ef7c7423013d3588b781b57f9ebaf57af974ac", "filename": "gcc/cp/name-lookup.c", "status": "modified", "additions": 72, "deletions": 126, "changes": 198, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/539f481a292d606bd7cf092880c51412e95d92b6/gcc%2Fcp%2Fname-lookup.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/539f481a292d606bd7cf092880c51412e95d92b6/gcc%2Fcp%2Fname-lookup.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fname-lookup.c?ref=539f481a292d606bd7cf092880c51412e95d92b6", "patch": "@@ -60,7 +60,6 @@ static void consider_binding_level (tree name,\n \t\t\t\t    enum lookup_name_fuzzy_kind kind);\n static tree lookup_type_current_level (tree);\n static tree push_using_directive (tree);\n-static tree lookup_extern_c_fun_in_all_ns (tree);\n static void diagnose_name_conflict (tree, tree);\n \n /* Add DECL to the list of things declared in B.  */\n@@ -1184,6 +1183,75 @@ supplement_binding (cxx_binding *binding, tree decl)\n   return ret;\n }\n \n+/* Map of identifiers to extern C functions (or LISTS thereof).  */\n+\n+static GTY(()) hash_map<lang_identifier *, tree> *extern_c_fns;\n+\n+/* DECL has C linkage. If we have an existing instance, make sure it\n+   has the same exception specification [7.5, 7.6].  If there's no\n+   instance, add DECL to the map.  */\n+\n+static void\n+check_extern_c_conflict (tree decl)\n+{\n+  /* Ignore artificial or system header decls.  */\n+  if (DECL_ARTIFICIAL (decl) || DECL_IN_SYSTEM_HEADER (decl))\n+    return;\n+\n+  if (!extern_c_fns)\n+    extern_c_fns = hash_map<lang_identifier *,tree>::create_ggc (127);\n+\n+  bool existed;\n+  tree *slot = &extern_c_fns->get_or_insert (DECL_NAME (decl), &existed);\n+  if (!existed)\n+    *slot = decl;\n+  else\n+    {\n+      tree old = *slot;\n+      if (TREE_CODE (old) == TREE_LIST)\n+\told = TREE_VALUE (old);\n+\n+      int mismatch = 0;\n+      if (DECL_CONTEXT (old) == DECL_CONTEXT (decl))\n+\t; /* If they're in the same context, we'll have already complained\n+\t     about a (possible) mismatch, when inserting the decl.  */\n+      else if (!decls_match (decl, old))\n+\tmismatch = 1;\n+      else if (!comp_except_specs (TYPE_RAISES_EXCEPTIONS (TREE_TYPE (old)),\n+\t\t\t\t   TYPE_RAISES_EXCEPTIONS (TREE_TYPE (decl)),\n+\t\t\t\t   ce_normal))\n+\tmismatch = -1;\n+      else if (DECL_ASSEMBLER_NAME_SET_P (old))\n+\tSET_DECL_ASSEMBLER_NAME (decl, DECL_ASSEMBLER_NAME (old));\n+\n+      if (mismatch)\n+\t{\n+\t  pedwarn (input_location, 0,\n+\t\t   \"declaration of %q#D with C language linkage\", decl);\n+\t  pedwarn (DECL_SOURCE_LOCATION (old), 0,\n+\t\t   \"conflicts with previous declaration %q#D\", old);\n+\t  if (mismatch < 0)\n+\t    pedwarn (input_location, 0,\n+\t\t     \"due to different exception specifications\");\n+\t}\n+      else\n+\t/* Chain it on for c_linkage_binding's use.  */\n+\t*slot = tree_cons (NULL_TREE, decl, *slot);\n+    }\n+}\n+\n+/* Returns a list of C-linkage decls with the name NAME.  Used in\n+   c-family/c-pragma.c to implement redefine_extname pragma.  */\n+\n+tree\n+c_linkage_bindings (tree name)\n+{\n+  if (extern_c_fns)\n+    if (tree *slot = extern_c_fns->get (name))\n+      return *slot;\n+  return NULL_TREE;\n+}\n+\n /* DECL is being declared at a local scope.  Emit suitable shadow\n    warnings.  */\n \n@@ -1591,63 +1659,6 @@ pushdecl_maybe_friend_1 (tree x, bool is_friend)\n \t    }\n \t}\n \n-      /* If x has C linkage-specification, (extern \"C\"),\n-\t lookup its binding, in case it's already bound to an object.\n-\t The lookup is done in all namespaces.\n-\t If we find an existing binding, make sure it has the same\n-\t exception specification as x, otherwise, bail in error [7.5, 7.6].  */\n-      if ((TREE_CODE (x) == FUNCTION_DECL)\n-\t  && DECL_EXTERN_C_P (x)\n-          /* We should ignore declarations happening in system headers.  */\n-\t  && !DECL_ARTIFICIAL (x)\n-\t  && !DECL_IN_SYSTEM_HEADER (x))\n-\t{\n-\t  tree previous = lookup_extern_c_fun_in_all_ns (x);\n-\t  if (previous\n-\t      && !DECL_ARTIFICIAL (previous)\n-              && !DECL_IN_SYSTEM_HEADER (previous)\n-\t      && DECL_CONTEXT (previous) != DECL_CONTEXT (x))\n-\t    {\n-\t      /* In case either x or previous is declared to throw an exception,\n-\t         make sure both exception specifications are equal.  */\n-\t      if (decls_match (x, previous))\n-\t\t{\n-\t\t  tree x_exception_spec = NULL_TREE;\n-\t\t  tree previous_exception_spec = NULL_TREE;\n-\n-\t\t  x_exception_spec =\n-\t\t\t\tTYPE_RAISES_EXCEPTIONS (TREE_TYPE (x));\n-\t\t  previous_exception_spec =\n-\t\t\t\tTYPE_RAISES_EXCEPTIONS (TREE_TYPE (previous));\n-\t\t  if (!comp_except_specs (previous_exception_spec,\n-\t\t\t\t\t  x_exception_spec,\n-\t\t\t\t\t  ce_normal))\n-\t\t    {\n-\t\t      pedwarn (input_location, 0,\n-                               \"declaration of %q#D with C language linkage\",\n-\t\t\t       x);\n-\t\t      pedwarn (DECL_SOURCE_LOCATION (previous), 0,\n-                               \"conflicts with previous declaration %q#D\",\n-\t\t\t       previous);\n-\t\t      pedwarn (input_location, 0,\n-                               \"due to different exception specifications\");\n-\t\t      return error_mark_node;\n-\t\t    }\n-\t\t  if (DECL_ASSEMBLER_NAME_SET_P (previous))\n-\t\t    SET_DECL_ASSEMBLER_NAME (x,\n-\t\t\t\t\t     DECL_ASSEMBLER_NAME (previous));\n-\t\t}\n-\t      else\n-\t\t{\n-\t\t  pedwarn (input_location, 0,\n-\t\t\t   \"declaration of %q#D with C language linkage\", x);\n-\t\t  pedwarn (DECL_SOURCE_LOCATION (previous), 0,\n-\t\t\t   \"conflicts with previous declaration %q#D\",\n-\t\t\t   previous);\n-\t\t}\n-\t    }\n-\t}\n-\n       check_template_shadow (x);\n \n       /* If this is a function conjured up by the back end, massage it\n@@ -1848,6 +1859,9 @@ pushdecl_maybe_friend_1 (tree x, bool is_friend)\n \n       if (VAR_P (x))\n \tmaybe_register_incomplete_var (x);\n+      if (TREE_CODE (x) == FUNCTION_DECL && DECL_EXTERN_C_P (x))\n+\t/* We need to check and register the fn now.  */\n+\tcheck_extern_c_conflict (x);\n     }\n \n   if (need_new_binding)\n@@ -2722,74 +2736,6 @@ binding_for_name (cp_binding_level *scope, tree name)\n   return result;\n }\n \n-/* Walk through the bindings associated to the name of FUNCTION,\n-   and return the first declaration of a function with a\n-   \"C\" linkage specification, a.k.a 'extern \"C\"'.\n-   This function looks for the binding, regardless of which scope it\n-   has been defined in. It basically looks in all the known scopes.\n-   Note that this function does not lookup for bindings of builtin functions\n-   or for functions declared in system headers.  */\n-static tree\n-lookup_extern_c_fun_in_all_ns (tree function)\n-{\n-  tree name;\n-  cxx_binding *iter;\n-\n-  gcc_assert (function && TREE_CODE (function) == FUNCTION_DECL);\n-\n-  name = DECL_NAME (function);\n-  gcc_assert (name && identifier_p (name));\n-\n-  for (iter = IDENTIFIER_NAMESPACE_BINDINGS (name);\n-       iter;\n-       iter = iter->previous)\n-    {\n-      tree ovl;\n-      for (ovl = iter->value; ovl; ovl = OVL_NEXT (ovl))\n-\t{\n-\t  tree decl = OVL_CURRENT (ovl);\n-\t  if (decl\n-\t      && TREE_CODE (decl) == FUNCTION_DECL\n-\t      && DECL_EXTERN_C_P (decl)\n-\t      && !DECL_ARTIFICIAL (decl))\n-\t    {\n-\t      return decl;\n-\t    }\n-\t}\n-    }\n-  return NULL;\n-}\n-\n-/* Returns a list of C-linkage decls with the name NAME.  */\n-\n-tree\n-c_linkage_bindings (tree name)\n-{\n-  tree decls = NULL_TREE;\n-  cxx_binding *iter;\n-\n-  for (iter = IDENTIFIER_NAMESPACE_BINDINGS (name);\n-       iter;\n-       iter = iter->previous)\n-    {\n-      tree ovl;\n-      for (ovl = iter->value; ovl; ovl = OVL_NEXT (ovl))\n-\t{\n-\t  tree decl = OVL_CURRENT (ovl);\n-\t  if (decl\n-\t      && DECL_EXTERN_C_P (decl)\n-\t      && !DECL_ARTIFICIAL (decl))\n-\t    {\n-\t      if (decls == NULL_TREE)\n-\t\tdecls = decl;\n-\t      else\n-\t\tdecls = tree_cons (NULL_TREE, decl, decls);\n-\t    }\n-\t}\n-    }\n-  return decls;\n-}\n-\n /* Insert another USING_DECL into the current binding level, returning\n    this declaration. If this is a redeclaration, do nothing, and\n    return NULL_TREE if this not in namespace scope (in namespace"}]}