{"sha": "ca1ae7e38dc2cfbb9e62e49ad6bbcc35f6038a7c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Y2ExYWU3ZTM4ZGMyY2ZiYjllNjJlNDlhZDZiYmNjMzVmNjAzOGE3Yw==", "commit": {"author": {"name": "Bernd Schmidt", "email": "bernds@codesourcery.com", "date": "2011-09-07T17:38:29Z"}, "committer": {"name": "Bernd Schmidt", "email": "bernds@gcc.gnu.org", "date": "2011-09-07T17:38:29Z"}, "message": "bb-reorder.c (insert_section_boundary_note): Don't check optimize_function_for_speed_p.\n\n\t* bb-reorder.c (insert_section_boundary_note): Don't check\n\toptimize_function_for_speed_p.\n\t(gate_handle_partition_blocks): Do it here instead.\n\t(gate_handle_reorder_blocks): Move preliminary checks here ...\n\t(rest_of_handle_reorder_blocks): ... from here.\n\nFrom-SVN: r178657", "tree": {"sha": "100018d65570ea82bfb6bb98f81863956490c2cd", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/100018d65570ea82bfb6bb98f81863956490c2cd"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ca1ae7e38dc2cfbb9e62e49ad6bbcc35f6038a7c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ca1ae7e38dc2cfbb9e62e49ad6bbcc35f6038a7c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ca1ae7e38dc2cfbb9e62e49ad6bbcc35f6038a7c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ca1ae7e38dc2cfbb9e62e49ad6bbcc35f6038a7c/comments", "author": null, "committer": null, "parents": [{"sha": "d14e12290a84760c3c8c02f3fb2be067cc1d2fe7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d14e12290a84760c3c8c02f3fb2be067cc1d2fe7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d14e12290a84760c3c8c02f3fb2be067cc1d2fe7"}], "stats": {"total": 39, "additions": 23, "deletions": 16}, "files": [{"sha": "550c051d02c260edd3e8e19f180212573e3d3820", "filename": "gcc/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ca1ae7e38dc2cfbb9e62e49ad6bbcc35f6038a7c/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ca1ae7e38dc2cfbb9e62e49ad6bbcc35f6038a7c/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=ca1ae7e38dc2cfbb9e62e49ad6bbcc35f6038a7c", "patch": "@@ -29,6 +29,12 @@\n \tstatic inline functions.\n \t* vec.h (FOR_EACH_VEC_ELT_FROM): New macro.\n \n+\t* bb-reorder.c (insert_section_boundary_note): Don't check\n+\toptimize_function_for_speed_p.\n+\t(gate_handle_partition_blocks): Do it here instead.\n+\t(gate_handle_reorder_blocks): Move preliminary checks here ...\n+\t(rest_of_handle_reorder_blocks): ... from here.\n+\n 2011-09-07  Martin Jambor  <mjambor@suse.cz>\n \n \tPR middle-end/50301"}, {"sha": "874ece2a9adad8efb2b5eb27b6f583d8907fa783", "filename": "gcc/bb-reorder.c", "status": "modified", "additions": 17, "deletions": 16, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ca1ae7e38dc2cfbb9e62e49ad6bbcc35f6038a7c/gcc%2Fbb-reorder.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ca1ae7e38dc2cfbb9e62e49ad6bbcc35f6038a7c/gcc%2Fbb-reorder.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbb-reorder.c?ref=ca1ae7e38dc2cfbb9e62e49ad6bbcc35f6038a7c", "patch": "@@ -1965,8 +1965,7 @@ insert_section_boundary_note (void)\n   rtx new_note;\n   int first_partition = 0;\n \n-  if (!flag_reorder_blocks_and_partition\n-      || !optimize_function_for_speed_p (cfun))\n+  if (!flag_reorder_blocks_and_partition)\n     return;\n \n   FOR_EACH_BB (bb)\n@@ -2296,7 +2295,17 @@ gate_handle_reorder_blocks (void)\n {\n   if (targetm.cannot_modify_jumps_p ())\n     return false;\n-  return (optimize > 0);\n+  /* Don't reorder blocks when optimizing for size because extra jump insns may\n+     be created; also barrier may create extra padding.\n+\n+     More correctly we should have a block reordering mode that tried to\n+     minimize the combined size of all the jumps.  This would more or less\n+     automatically remove extra jumps, but would also try to use more short\n+     jumps instead of long jumps.  */\n+  if (!optimize_function_for_speed_p (cfun))\n+    return false;\n+  return (optimize > 0\n+\t  && (flag_reorder_blocks || flag_reorder_blocks_and_partition));\n }\n \n \n@@ -2310,19 +2319,8 @@ rest_of_handle_reorder_blocks (void)\n      splitting possibly introduced more crossjumping opportunities.  */\n   cfg_layout_initialize (CLEANUP_EXPENSIVE);\n \n-  if ((flag_reorder_blocks || flag_reorder_blocks_and_partition)\n-      /* Don't reorder blocks when optimizing for size because extra jump insns may\n-\t be created; also barrier may create extra padding.\n-\n-\t More correctly we should have a block reordering mode that tried to\n-\t minimize the combined size of all the jumps.  This would more or less\n-\t automatically remove extra jumps, but would also try to use more short\n-\t jumps instead of long jumps.  */\n-      && optimize_function_for_speed_p (cfun))\n-    {\n-      reorder_basic_blocks ();\n-      cleanup_cfg (CLEANUP_EXPENSIVE);\n-    }\n+  reorder_basic_blocks ();\n+  cleanup_cfg (CLEANUP_EXPENSIVE);\n \n   FOR_EACH_BB (bb)\n     if (bb->next_bb != EXIT_BLOCK_PTR)\n@@ -2362,6 +2360,9 @@ gate_handle_partition_blocks (void)\n      arises.  */\n   return (flag_reorder_blocks_and_partition\n           && optimize\n+\t  /* See gate_handle_reorder_blocks.  We should not partition if\n+\t     we are going to omit the reordering.  */\n+\t  && optimize_function_for_speed_p (cfun)\n \t  && !DECL_ONE_ONLY (current_function_decl)\n \t  && !user_defined_section_attribute);\n }"}]}