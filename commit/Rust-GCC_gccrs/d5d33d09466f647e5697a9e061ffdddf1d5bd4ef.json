{"sha": "d5d33d09466f647e5697a9e061ffdddf1d5bd4ef", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDVkMzNkMDk0NjZmNjQ3ZTU2OTdhOWUwNjFmZmRkZGYxZDViZDRlZg==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2008-08-04T09:40:33Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2008-08-04T09:40:33Z"}, "message": "Minor reformatting.\n\nFrom-SVN: r138595", "tree": {"sha": "bf2263eb9342379c3f43892a48f79f5cf3f50971", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/bf2263eb9342379c3f43892a48f79f5cf3f50971"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d5d33d09466f647e5697a9e061ffdddf1d5bd4ef", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d5d33d09466f647e5697a9e061ffdddf1d5bd4ef", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d5d33d09466f647e5697a9e061ffdddf1d5bd4ef", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d5d33d09466f647e5697a9e061ffdddf1d5bd4ef/comments", "author": null, "committer": null, "parents": [{"sha": "819fad69b2dd553d635c8d713ec9994aea7de635", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/819fad69b2dd553d635c8d713ec9994aea7de635", "html_url": "https://github.com/Rust-GCC/gccrs/commit/819fad69b2dd553d635c8d713ec9994aea7de635"}], "stats": {"total": 380, "additions": 187, "deletions": 193}, "files": [{"sha": "d4dcd3cb201a4147b25f1d6f64ca4ad5e1a030fd", "filename": "gcc/ada/layout.adb", "status": "modified", "additions": 187, "deletions": 193, "changes": 380, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d5d33d09466f647e5697a9e061ffdddf1d5bd4ef/gcc%2Fada%2Flayout.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d5d33d09466f647e5697a9e061ffdddf1d5bd4ef/gcc%2Fada%2Flayout.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flayout.adb?ref=d5d33d09466f647e5697a9e061ffdddf1d5bd4ef", "patch": "@@ -83,16 +83,16 @@ package body Layout is\n       Left_Opnd  : Node_Id;\n       Right_Opnd : Node_Id) return Node_Id;\n    --  This is like Make_Op_Multiply except that it optimizes some cases\n-   --  knowing that associative rearrangement is allowed for constant\n-   --  folding if one of the operands is a compile time known value\n+   --  knowing that associative rearrangement is allowed for constant folding\n+   --  if one of the operands is a compile time known value\n \n    function Assoc_Subtract\n      (Loc        : Source_Ptr;\n       Left_Opnd  : Node_Id;\n       Right_Opnd : Node_Id) return Node_Id;\n    --  This is like Make_Op_Subtract except that it optimizes some cases\n-   --  knowing that associative rearrangement is allowed for constant\n-   --  folding if one of the operands is a compile time known value\n+   --  knowing that associative rearrangement is allowed for constant folding\n+   --  if one of the operands is a compile time known value\n \n    function Bits_To_SU (N : Node_Id) return Node_Id;\n    --  This is used when we cross the boundary from static sizes in bits to\n@@ -159,21 +159,20 @@ package body Layout is\n    --  Front-end layout of record type\n \n    procedure Rewrite_Integer (N : Node_Id; V : Uint);\n-   --  Rewrite node N with an integer literal whose value is V. The Sloc\n-   --  for the new node is taken from N, and the type of the literal is\n-   --  set to a copy of the type of N on entry.\n+   --  Rewrite node N with an integer literal whose value is V. The Sloc for\n+   --  the new node is taken from N, and the type of the literal is set to a\n+   --  copy of the type of N on entry.\n \n    procedure Set_And_Check_Static_Size\n      (E      : Entity_Id;\n       Esiz   : SO_Ref;\n       RM_Siz : SO_Ref);\n-   --  This procedure is called to check explicit given sizes (possibly\n-   --  stored in the Esize and RM_Size fields of E) against computed\n-   --  Object_Size (Esiz) and Value_Size (RM_Siz) values. Appropriate\n-   --  errors and warnings are posted if specified sizes are inconsistent\n-   --  with specified sizes. On return, the Esize and RM_Size fields of\n-   --  E are set (either from previously given values, or from the newly\n-   --  computed values, as appropriate).\n+   --  This procedure is called to check explicit given sizes (possibly stored\n+   --  in the Esize and RM_Size fields of E) against computed Object_Size\n+   --  (Esiz) and Value_Size (RM_Siz) values. Appropriate errors and warnings\n+   --  are posted if specified sizes are inconsistent with specified sizes. On\n+   --  return, Esize and RM_Size fields of E are set (either from previously\n+   --  given values, or from the newly computed values, as appropriate).\n \n    procedure Set_Composite_Alignment (E : Entity_Id);\n    --  This procedure is called for record types and subtypes, and also for\n@@ -200,8 +199,8 @@ package body Layout is\n       --  which must be obeyed. If so, we cannot increase the size in this\n       --  routine.\n \n-      --  For a type, the issue is whether an object size clause has been\n-      --  set. A normal size clause constrains only the value size (RM_Size)\n+      --  For a type, the issue is whether an object size clause has been set.\n+      --  A normal size clause constrains only the value size (RM_Size)\n \n       if Is_Type (E) then\n          Esize_Set := Has_Object_Size_Clause (E);\n@@ -247,14 +246,14 @@ package body Layout is\n          return;\n       end if;\n \n-      --  Here we have a situation where the Esize is not a multiple of\n-      --  the alignment. We must either increase Esize or reduce the\n-      --  alignment to correct this situation.\n+      --  Here we have a situation where the Esize is not a multiple of the\n+      --  alignment. We must either increase Esize or reduce the alignment to\n+      --  correct this situation.\n \n       --  The case in which we can decrease the alignment is where the\n       --  alignment was not set by an alignment clause, and the type in\n-      --  question is a discrete type, where it is definitely safe to\n-      --  reduce the alignment. For example:\n+      --  question is a discrete type, where it is definitely safe to reduce\n+      --  the alignment. For example:\n \n       --    t : integer range 1 .. 2;\n       --    for t'size use 8;\n@@ -275,8 +274,8 @@ package body Layout is\n          return;\n       end if;\n \n-      --  Now the only possible approach left is to increase the Esize\n-      --  but we can't do that if the size was set by a specific clause.\n+      --  Now the only possible approach left is to increase the Esize but we\n+      --  can't do that if the size was set by a specific clause.\n \n       if Esize_Set then\n          Error_Msg_NE\n@@ -606,9 +605,10 @@ package body Layout is\n          Ent := Get_Dynamic_SO_Entity (D);\n \n          if Is_Discrim_SO_Function (Ent) then\n-            --  If a component is passed in whose type matches the type\n-            --  of the function formal, then select that component from\n-            --  the \"V\" parameter rather than passing \"V\" directly.\n+\n+            --  If a component is passed in whose type matches the type of\n+            --  the function formal, then select that component from the \"V\"\n+            --  parameter rather than passing \"V\" directly.\n \n             if Present (Comp)\n                and then Base_Type (Etype (Comp))\n@@ -661,18 +661,18 @@ package body Layout is\n                when Dynamic => Nod : Node_Id;\n             end case;\n          end record;\n-      --  Shows the status of the value so far. Const means that the value\n-      --  is constant, and Val is the current constant value. Dynamic means\n-      --  that the value is dynamic, and in this case Nod is the Node_Id of\n-      --  the expression to compute the value.\n+      --  Shows the status of the value so far. Const means that the value is\n+      --  constant, and Val is the current constant value. Dynamic means that\n+      --  the value is dynamic, and in this case Nod is the Node_Id of the\n+      --  expression to compute the value.\n \n       Size : Val_Type;\n       --  Calculated value so far if Size.Status = Const,\n       --  or expression value so far if Size.Status = Dynamic.\n \n       SU_Convert_Required : Boolean := False;\n-      --  This is set to True if the final result must be converted from\n-      --  bits to storage units (rounding up to a storage unit boundary).\n+      --  This is set to True if the final result must be converted from bits\n+      --  to storage units (rounding up to a storage unit boundary).\n \n       -----------------------\n       -- Local Subprograms --\n@@ -799,9 +799,9 @@ package body Layout is\n                     (Dynamic, Make_Integer_Literal (Loc, Size.Val / SSU));\n                   SU_Convert_Required := False;\n \n-               --  Otherwise, we go ahead and convert the value in bits,\n-               --  and set SU_Convert_Required to True to ensure that the\n-               --  final value is indeed properly converted.\n+               --  Otherwise, we go ahead and convert the value in bits, and\n+               --  set SU_Convert_Required to True to ensure that the final\n+               --  value is indeed properly converted.\n \n                else\n                   Size := (Dynamic, Make_Integer_Literal (Loc, Size.Val));\n@@ -827,8 +827,8 @@ package body Layout is\n \n                Len := Convert_To (Standard_Unsigned, Len);\n \n-               --  If we cannot verify that range cannot be super-flat,\n-               --  we need a max with zero, since length must be non-neg.\n+               --  If we cannot verify that range cannot be super-flat, we need\n+               --  a max with zero, since length must be non-negative.\n \n                if not OK or else LLo < 0 then\n                   Len :=\n@@ -846,8 +846,8 @@ package body Layout is\n          Next_Index (Indx);\n       end loop;\n \n-      --  Here after processing all bounds to set sizes. If the value is\n-      --  a constant, then it is bits, so we convert to storage units.\n+      --  Here after processing all bounds to set sizes. If the value is a\n+      --  constant, then it is bits, so we convert to storage units.\n \n       if Size.Status = Const then\n          return Bits_To_SU (Make_Integer_Literal (Loc, Size.Val));\n@@ -900,10 +900,10 @@ package body Layout is\n       -- How An Array Type is Laid Out --\n       ------------------------------------\n \n-      --  Here is what goes on. We need to multiply the component size of\n-      --  the array (which has already been set) by the length of each of\n-      --  the indexes. If all these values are known at compile time, then\n-      --  the resulting size of the array is the appropriate constant value.\n+      --  Here is what goes on. We need to multiply the component size of the\n+      --  array (which has already been set) by the length of each of the\n+      --  indexes. If all these values are known at compile time, then the\n+      --  resulting size of the array is the appropriate constant value.\n \n       --  If the component size or at least one bound is dynamic (but no\n       --  discriminants are present), then the size will be computed as an\n@@ -941,8 +941,8 @@ package body Layout is\n       --  Value of size computed so far. See comments above\n \n       Vtyp : Entity_Id := Empty;\n-      --  Variant record type for the formal parameter of the\n-      --  discriminant function V if Status = Discrim.\n+      --  Variant record type for the formal parameter of the discriminant\n+      --  function V if Status = Discrim.\n \n       SU_Convert_Required : Boolean := False;\n       --  This is set to True if the final result must be converted from\n@@ -1064,7 +1064,7 @@ package body Layout is\n       while Present (Indx) loop\n          Ityp := Etype (Indx);\n \n-         --  If an index of the array is a generic formal type then there's\n+         --  If an index of the array is a generic formal type then there is\n          --  no point in determining a size for the array type.\n \n          if Is_Generic_Type (Ityp) then\n@@ -1139,18 +1139,18 @@ package body Layout is\n                     (Dynamic, Make_Integer_Literal (Loc, Size.Val / SSU));\n                   SU_Convert_Required := False;\n \n-               --  If the current value is a factor of the storage unit,\n-               --  then we can use a value of one for the size and reduce\n-               --  the strength of the later division.\n+               --  If the current value is a factor of the storage unit, then\n+               --  we can use a value of one for the size and reduce the\n+               --  strength of the later division.\n \n                elsif SSU mod Size.Val = 0 then\n                   Storage_Divisor := SSU / Size.Val;\n                   Size := (Dynamic, Make_Integer_Literal (Loc, Uint_1));\n                   SU_Convert_Required := True;\n \n-               --  Otherwise, we go ahead and convert the value in bits,\n-               --  and set SU_Convert_Required to True to ensure that the\n-               --  final value is indeed properly converted.\n+               --  Otherwise, we go ahead and convert the value in bits, and\n+               --  set SU_Convert_Required to True to ensure that the final\n+               --  value is indeed properly converted.\n \n                else\n                   Size := (Dynamic, Make_Integer_Literal (Loc, Size.Val));\n@@ -1165,8 +1165,8 @@ package body Layout is\n \n             Len := Compute_Length (Lo, Hi);\n \n-            --  If Len isn't a Length attribute, then its range needs to\n-            --  be checked a possible Max with zero needs to be computed.\n+            --  If Len isn't a Length attribute, then its range needs to be\n+            --  checked a possible Max with zero needs to be computed.\n \n             if Nkind (Len) /= N_Attribute_Reference\n               or else Attribute_Name (Len) /= Name_Length\n@@ -1193,9 +1193,8 @@ package body Layout is\n                      return;\n                   end if;\n \n-                  --  If we cannot verify that range cannot be super-flat,\n-                  --  we need a maximum with zero, since length cannot be\n-                  --  negative.\n+                  --  If we cannot verify that range cannot be super-flat, we\n+                  --  need a max with zero, since length cannot be negative.\n \n                   if not OK or else LLo < 0 then\n                      Len :=\n@@ -1221,9 +1220,9 @@ package body Layout is\n          Next_Index (Indx);\n       end loop;\n \n-      --  Here after processing all bounds to set sizes. If the value is\n-      --  a constant, then it is bits, and the only thing we need to do\n-      --  is to check against explicit given size and do alignment adjust.\n+      --  Here after processing all bounds to set sizes. If the value is a\n+      --  constant, then it is bits, and the only thing we need to do is to\n+      --  check against explicit given size and do alignment adjust.\n \n       if Size.Status = Const then\n          Set_And_Check_Static_Size (E, Size.Val, Size.Val);\n@@ -1303,8 +1302,8 @@ package body Layout is\n          return;\n       end if;\n \n-      --  Set size if not set for object and known for type. Use the\n-      --  RM_Size if that is known for the type and Esize is not.\n+      --  Set size if not set for object and known for type. Use the RM_Size if\n+      --  that is known for the type and Esize is not.\n \n       if Unknown_Esize (E) then\n          if Known_Esize (T) then\n@@ -1325,9 +1324,9 @@ package body Layout is\n \n       Adjust_Esize_Alignment (E);\n \n-      --  Final adjustment, if we don't know the alignment, and the Esize\n-      --  was not set by an explicit Object_Size attribute clause, then\n-      --  we reset the Esize to unknown, since we really don't know it.\n+      --  Final adjustment, if we don't know the alignment, and the Esize was\n+      --  not set by an explicit Object_Size attribute clause, then we reset\n+      --  the Esize to unknown, since we really don't know it.\n \n       if Unknown_Alignment (E)\n         and then not Has_Size_Clause (E)\n@@ -1505,8 +1504,8 @@ package body Layout is\n                   New_Fbit := (New_Fbit + SSU - 1) / SSU * SSU;\n                end if;\n \n-               --  If old normalized position is static, we can go ahead\n-               --  and compute the new normalized position directly.\n+               --  If old normalized position is static, we can go ahead and\n+               --  compute the new normalized position directly.\n \n                if Known_Static_Normalized_Position (Prev_Comp) then\n                   New_Npos := Old_Npos;\n@@ -1619,11 +1618,11 @@ package body Layout is\n             return;\n          end if;\n \n-         --  Check case of type of component has a scope of the record we\n-         --  are laying out. When this happens, the type in question is an\n-         --  Itype that has not yet been laid out (that's because such\n-         --  types do not get frozen in the normal manner, because there\n-         --  is no place for the freeze nodes).\n+         --  Check case of type of component has a scope of the record we are\n+         --  laying out. When this happens, the type in question is an Itype\n+         --  that has not yet been laid out (that's because such types do not\n+         --  get frozen in the normal manner, because there is no place for\n+         --  the freeze nodes).\n \n          if Scope (Ctyp) = E then\n             Layout_Type (Ctyp);\n@@ -1636,9 +1635,8 @@ package body Layout is\n          end if;\n \n          --  Set size of component from type. We use the Esize except in a\n-         --  packed record, where we use the RM_Size (since that is exactly\n-         --  what the RM_Size value, as distinct from the Object_Size is\n-         --  useful for!)\n+         --  packed record, where we use the RM_Size (since that is what the\n+         --  RM_Size value, as distinct from the Object_Size is useful for!)\n \n          if Is_Packed (E) then\n             Set_Esize (Comp, RM_Size (Ctyp));\n@@ -1915,10 +1913,10 @@ package body Layout is\n \n          RM_Siz_Expr : Node_Id := Empty;\n          --  Expression for the evolving RM_Siz value. This is typically a\n-         --  conditional expression which involves tests of discriminant\n-         --  values that are formed as references to the entity V. At\n-         --  the end of scanning all the components, a suitable function\n-         --  is constructed in which V is the parameter.\n+         --  conditional expression which involves tests of discriminant values\n+         --  that are formed as references to the entity V. At the end of\n+         --  scanning all the components, a suitable function is constructed\n+         --  in which V is the parameter.\n \n          -----------------------\n          -- Local Subprograms --\n@@ -1928,14 +1926,14 @@ package body Layout is\n            (Clist       : Node_Id;\n             Esiz        : out SO_Ref;\n             RM_Siz_Expr : out Node_Id);\n-         --  Recursive procedure, called to lay out one component list\n-         --  Esiz and RM_Siz_Expr are set to the Object_Size and Value_Size\n-         --  values respectively representing the record size up to and\n-         --  including the last component in the component list (including\n-         --  any variants in this component list). RM_Siz_Expr is returned\n-         --  as an expression which may in the general case involve some\n-         --  references to the discriminants of the current record value,\n-         --  referenced by selecting from the entity V.\n+         --  Recursive procedure, called to lay out one component list Esiz\n+         --  and RM_Siz_Expr are set to the Object_Size and Value_Size values\n+         --  respectively representing the record size up to and including the\n+         --  last component in the component list (including any variants in\n+         --  this component list). RM_Siz_Expr is returned as an expression\n+         --  which may in the general case involve some references to the\n+         --  discriminants of the current record value, referenced by selecting\n+         --  from the entity V.\n \n          ---------------------------\n          -- Layout_Component_List --\n@@ -1982,9 +1980,9 @@ package body Layout is\n                else\n                   RMS_Ent := Get_Dynamic_SO_Entity (RM_Siz);\n \n-                  --  If the size is represented by a function, then we\n-                  --  create an appropriate function call using V as\n-                  --  the parameter to the call.\n+                  --  If the size is represented by a function, then we create\n+                  --  an appropriate function call using V as the parameter to\n+                  --  the call.\n \n                   if Is_Discrim_SO_Function (RMS_Ent) then\n                      RM_Siz_Expr :=\n@@ -2080,9 +2078,9 @@ package body Layout is\n                      --  individual variants, and xxDx are the discriminant\n                      --  checking functions generated for the variant type.\n \n-                     --  If this is the first variant, we simply set the\n-                     --  result as the expression. Note that this takes\n-                     --  care of the others case.\n+                     --  If this is the first variant, we simply set the result\n+                     --  as the expression. Note that this takes care of the\n+                     --  others case.\n \n                      if No (RM_Siz_Expr) then\n                         RM_Siz_Expr := Bits_To_SU (RM_SizV);\n@@ -2236,17 +2234,17 @@ package body Layout is\n       --  All other cases\n \n       else\n-         --  Initialize alignment conservatively to 1. This value will\n-         --  be increased as necessary during processing of the record.\n+         --  Initialize alignment conservatively to 1. This value will be\n+         --  increased as necessary during processing of the record.\n \n          if Unknown_Alignment (E) then\n             Set_Alignment (E, Uint_1);\n          end if;\n \n-         --  Initialize previous component. This is Empty unless there\n-         --  are components which have already been laid out by component\n-         --  clauses. If there are such components, we start our lay out of\n-         --  the remaining components following the last such component.\n+         --  Initialize previous component. This is Empty unless there are\n+         --  components which have already been laid out by component clauses.\n+         --  If there are such components, we start our lay out of the\n+         --  remaining components following the last such component.\n \n          Prev_Comp := Empty;\n \n@@ -2303,23 +2301,23 @@ package body Layout is\n       Desig_Type : Entity_Id;\n \n    begin\n-      --  For string literal types, for now, kill the size always, this\n-      --  is because gigi does not like or need the size to be set ???\n+      --  For string literal types, for now, kill the size always, this is\n+      --  because gigi does not like or need the size to be set ???\n \n       if Ekind (E) = E_String_Literal_Subtype then\n          Set_Esize (E, Uint_0);\n          Set_RM_Size (E, Uint_0);\n          return;\n       end if;\n \n-      --  For access types, set size/alignment. This is system address\n-      --  size, except for fat pointers (unconstrained array access types),\n-      --  where the size is two times the address size, to accommodate the\n-      --  two pointers that are required for a fat pointer (data and\n-      --  template). Note that E_Access_Protected_Subprogram_Type is not\n-      --  an access type for this purpose since it is not a pointer but is\n-      --  equivalent to a record. For access subtypes, copy the size from\n-      --  the base type since Gigi represents them the same way.\n+      --  For access types, set size/alignment. This is system address size,\n+      --  except for fat pointers (unconstrained array access types), where the\n+      --  size is two times the address size, to accommodate the two pointers\n+      --  that are required for a fat pointer (data and template). Note that\n+      --  E_Access_Protected_Subprogram_Type is not an access type for this\n+      --  purpose since it is not a pointer but is equivalent to a record. For\n+      --  access subtypes, copy the size from the base type since Gigi\n+      --  represents them the same way.\n \n       if Is_Access_Type (E) then\n \n@@ -2335,15 +2333,15 @@ package body Layout is\n             Desig_Type := Non_Limited_View (Designated_Type (E));\n          end if;\n \n-         --  If Esize already set (e.g. by a size clause), then nothing\n-         --  further to be done here.\n+         --  If Esize already set (e.g. by a size clause), then nothing further\n+         --  to be done here.\n \n          if Known_Esize (E) then\n             null;\n \n-         --  Access to subprogram is a strange beast, and we let the\n-         --  backend figure out what is needed (it may be some kind\n-         --  of fat pointer, including the static link for example.\n+         --  Access to subprogram is a strange beast, and we let the backend\n+         --  figure out what is needed (it may be some kind of fat pointer,\n+         --  including the static link for example.\n \n          elsif Is_Access_Protected_Subprogram_Type (E) then\n             null;\n@@ -2354,9 +2352,9 @@ package body Layout is\n             Set_Size_Info (E, Base_Type (E));\n             Set_RM_Size   (E, RM_Size (Base_Type (E)));\n \n-         --  For other access types, we use either address size, or, if\n-         --  a fat pointer is used (pointer-to-unconstrained array case),\n-         --  twice the address size to accommodate a fat pointer.\n+         --  For other access types, we use either address size, or, if a fat\n+         --  pointer is used (pointer-to-unconstrained array case), twice the\n+         --  address size to accommodate a fat pointer.\n \n          elsif Present (Desig_Type)\n             and then Is_Array_Type (Desig_Type)\n@@ -2378,9 +2376,9 @@ package body Layout is\n                  (\"?this access type does not correspond to C pointer\", E);\n             end if;\n \n-         --  If the designated type is a limited view it is unanalyzed. We\n-         --  can examine the declaration itself to determine whether it will\n-         --  need a fat pointer.\n+         --  If the designated type is a limited view it is unanalyzed. We can\n+         --  examine the declaration itself to determine whether it will need a\n+         --  fat pointer.\n \n          elsif Present (Desig_Type)\n             and then Present (Parent (Desig_Type))\n@@ -2392,9 +2390,9 @@ package body Layout is\n             Init_Size (E, 2 * System_Address_Size);\n \n          --  When the target is AAMP, access-to-subprogram types are fat\n-         --  pointers consisting of the subprogram address and a static\n-         --  link (with the exception of library-level access types,\n-         --  where a simple subprogram address is used).\n+         --  pointers consisting of the subprogram address and a static link\n+         --  (with the exception of library-level access types, where a simple\n+         --  subprogram address is used).\n \n          elsif AAMP_On_Target\n            and then\n@@ -2411,15 +2409,14 @@ package body Layout is\n          --  On VMS, reset size to 32 for convention C access type if no\n          --  explicit size clause is given and the default size is 64. Really\n          --  we do not know the size, since depending on options for the VMS\n-         --  compiler, the size of a pointer type can be 32 or 64, but\n-         --  choosing 32 as the default improves compatibility with legacy\n-         --  VMS code.\n+         --  compiler, the size of a pointer type can be 32 or 64, but choosing\n+         --  32 as the default improves compatibility with legacy VMS code.\n \n          --  Note: we do not use Has_Size_Clause in the test below, because we\n-         --  want to catch the case of a derived type inheriting a size\n-         --  clause.  We want to consider this to be an explicit size clause\n-         --  for this purpose, since it would be weird not to inherit the size\n-         --  in this case.\n+         --  want to catch the case of a derived type inheriting a size clause.\n+         --  We want to consider this to be an explicit size clause for this\n+         --  purpose, since it would be weird not to inherit the size in this\n+         --  case.\n \n          --  We do NOT do this if we are in -gnatdm mode on a non-VMS target\n          --  since in that case we want the normal pointer representation.\n@@ -2440,12 +2437,11 @@ package body Layout is\n \n       elsif Is_Scalar_Type (E) then\n \n-         --  For discrete types, the RM_Size and Esize must be set\n-         --  already, since this is part of the earlier processing\n-         --  and the front end is always required to lay out the\n-         --  sizes of such types (since they are available as static\n-         --  attributes). All we do is to check that this rule is\n-         --  indeed obeyed!\n+         --  For discrete types, the RM_Size and Esize must be set already,\n+         --  since this is part of the earlier processing and the front end is\n+         --  always required to lay out the sizes of such types (since they are\n+         --  available as static attributes). All we do is to check that this\n+         --  rule is indeed obeyed!\n \n          if Is_Discrete_Type (E) then\n \n@@ -2472,10 +2468,10 @@ package body Layout is\n                         Init_Esize (E, S);\n                         exit;\n \n-                     --  If the RM_Size is greater than 64 (happens only\n-                     --  when strange values are specified by the user,\n-                     --  then Esize is simply a copy of RM_Size, it will\n-                     --  be further refined later on)\n+                     --  If the RM_Size is greater than 64 (happens only when\n+                     --  strange values are specified by the user, then Esize\n+                     --  is simply a copy of RM_Size, it will be further\n+                     --  refined later on)\n \n                      elsif S = 64 then\n                         Set_Esize (E, RM_Size (E));\n@@ -2490,8 +2486,8 @@ package body Layout is\n                end;\n             end if;\n \n-         --  For non-discrete scalar types, if the RM_Size is not set,\n-         --  then set it now to a copy of the Esize if the Esize is set.\n+         --  For non-discrete scalar types, if the RM_Size is not set, then set\n+         --  it now to a copy of the Esize if the Esize is set.\n \n          else\n             if Known_Esize (E) and then Unknown_RM_Size (E) then\n@@ -2508,8 +2504,8 @@ package body Layout is\n \n          if Known_RM_Size (E) and then Unknown_Esize (E) then\n \n-            --  If the alignment is known, we bump the Esize up to the\n-            --  next alignment boundary if it is not already on one.\n+            --  If the alignment is known, we bump the Esize up to the next\n+            --  alignment boundary if it is not already on one.\n \n             if Known_Alignment (E) then\n                declare\n@@ -2520,18 +2516,17 @@ package body Layout is\n                end;\n             end if;\n \n-         --  If Esize is set, and RM_Size is not, RM_Size is copied from\n-         --  Esize at least for now this seems reasonable, and is in any\n-         --  case needed for compatibility with old versions of gigi.\n-         --  look to be unknown.\n+         --  If Esize is set, and RM_Size is not, RM_Size is copied from Esize.\n+         --  At least for now this seems reasonable, and is in any case needed\n+         --  for compatibility with old versions of gigi.\n \n          elsif Known_Esize (E) and then Unknown_RM_Size (E) then\n             Set_RM_Size (E, Esize (E));\n          end if;\n \n-         --  For array base types, set component size if object size of\n-         --  the component type is known and is a small power of 2 (8,\n-         --  16, 32, 64), since this is what will always be used.\n+         --  For array base types, set component size if object size of the\n+         --  component type is known and is a small power of 2 (8, 16, 32, 64),\n+         --  since this is what will always be used.\n \n          if Ekind (E) = E_Array_Type\n            and then Unknown_Component_Size (E)\n@@ -2540,8 +2535,8 @@ package body Layout is\n                CT : constant Entity_Id := Component_Type (E);\n \n             begin\n-               --  For some reasons, access types can cause trouble,\n-               --  So let's just do this for discrete types ???\n+               --  For some reasons, access types can cause trouble, So let's\n+               --  just do this for discrete types ???\n \n                if Present (CT)\n                  and then Is_Discrete_Type (CT)\n@@ -2646,9 +2641,9 @@ package body Layout is\n             begin\n                Set_Esize (E, RM_Size (E));\n \n-               --  For scalar types, increase Object_Size to power of 2,\n-               --  but not less than a storage unit in any case (i.e.,\n-               --  normally this means it will be storage-unit addressable).\n+               --  For scalar types, increase Object_Size to power of 2, but\n+               --  not less than a storage unit in any case (i.e., normally\n+               --  this means it will be storage-unit addressable).\n \n                if Is_Scalar_Type (E) then\n                   if Size <= System_Storage_Unit then\n@@ -2700,16 +2695,15 @@ package body Layout is\n       SC : Node_Id;\n \n       procedure Check_Size_Too_Small (Spec : Uint; Min : Uint);\n-      --  Spec is the number of bit specified in the size clause, and\n-      --  Min is the minimum computed size. An error is given that the\n-      --  specified size is too small if Spec < Min, and in this case\n-      --  both Esize and RM_Size are set to unknown in E. The error\n-      --  message is posted on node SC.\n+      --  Spec is the number of bit specified in the size clause, and Min is\n+      --  the minimum computed size. An error is given that the specified size\n+      --  is too small if Spec < Min, and in this case both Esize and RM_Size\n+      --  are set to unknown in E. The error message is posted on node SC.\n \n       procedure Check_Unused_Bits (Spec : Uint; Max : Uint);\n-      --  Spec is the number of bits specified in the size clause, and\n-      --  Max is the maximum computed size. A warning is given about\n-      --  unused bits if Spec > Max. This warning is posted on node SC.\n+      --  Spec is the number of bits specified in the size clause, and Max is\n+      --  the maximum computed size. A warning is given about unused bits if\n+      --  Spec > Max. This warning is posted on node SC.\n \n       --------------------------\n       -- Check_Size_Too_Small --\n@@ -2758,10 +2752,10 @@ package body Layout is\n          end if;\n       end if;\n \n-      --  Case where Value_Size (RM_Size) is set by specific Value_Size\n-      --  clause (we do not need to worry about Value_Size being set by\n-      --  a Size clause, since that will have set Esize as well, and we\n-      --  already took care of that case).\n+      --  Case where Value_Size (RM_Size) is set by specific Value_Size clause\n+      --  (we do not need to worry about Value_Size being set by a Size clause,\n+      --  since that will have set Esize as well, and we already took care of\n+      --  that case).\n \n       if Known_Static_RM_Size (E) then\n          SC := Get_Attribute_Definition_Clause (E, Attribute_Value_Size);\n@@ -2949,8 +2943,8 @@ package body Layout is\n          end if;\n       end if;\n \n-      --  Set chosen alignment, and increase Esize if necessary to match\n-      --  the chosen alignment.\n+      --  Set chosen alignment, and increase Esize if necessary to match the\n+      --  chosen alignment.\n \n       Set_Alignment (E, UI_From_Int (Align));\n \n@@ -2969,31 +2963,31 @@ package body Layout is\n       FST : constant Entity_Id := First_Subtype (Def_Id);\n \n    begin\n-      --  All discrete types except for the base types in standard\n-      --  are constrained, so indicate this by setting Is_Constrained.\n+      --  All discrete types except for the base types in standard are\n+      --  constrained, so indicate this by setting Is_Constrained.\n \n       Set_Is_Constrained (Def_Id);\n \n-      --  We set generic types to have an unknown size, since the\n-      --  representation of a generic type is irrelevant, in view\n-      --  of the fact that they have nothing to do with code.\n+      --  Set generic types to have an unknown size, since the representation\n+      --  of a generic type is irrelevant, in view of the fact that they have\n+      --  nothing to do with code.\n \n       if Is_Generic_Type (Root_Type (FST)) then\n          Set_RM_Size (Def_Id, Uint_0);\n \n-      --  If the subtype statically matches the first subtype, then\n-      --  it is required to have exactly the same layout. This is\n-      --  required by aliasing considerations.\n+      --  If the subtype statically matches the first subtype, then it is\n+      --  required to have exactly the same layout. This is required by\n+      --  aliasing considerations.\n \n       elsif Def_Id /= FST and then\n         Subtypes_Statically_Match (Def_Id, FST)\n       then\n          Set_RM_Size   (Def_Id, RM_Size (FST));\n          Set_Size_Info (Def_Id, FST);\n \n-      --  In all other cases the RM_Size is set to the minimum size.\n-      --  Note that this routine is never called for subtypes for which\n-      --  the RM_Size is set explicitly by an attribute clause.\n+      --  In all other cases the RM_Size is set to the minimum size. Note that\n+      --  this routine is never called for subtypes for which the RM_Size is\n+      --  set explicitly by an attribute clause.\n \n       else\n          Set_RM_Size (Def_Id, UI_From_Int (Minimum_Size (Def_Id)));\n@@ -3033,9 +3027,9 @@ package body Layout is\n          return;\n       end if;\n \n-      --  Here we calculate the alignment as the largest power of two\n-      --  multiple of System.Storage_Unit that does not exceed either\n-      --  the actual size of the type, or the maximum allowed alignment.\n+      --  Here we calculate the alignment as the largest power of two multiple\n+      --  of System.Storage_Unit that does not exceed either the actual size of\n+      --  the type, or the maximum allowed alignment.\n \n       declare\n          S : constant Int :=\n@@ -3050,18 +3044,18 @@ package body Layout is\n             A := 2 * A;\n          end loop;\n \n-         --  Now we think we should set the alignment to A, but we\n-         --  skip this if an alignment is already set to a value\n-         --  greater than A (happens for derived types).\n+         --  Now we think we should set the alignment to A, but we skip this if\n+         --  an alignment is already set to a value greater than A (happens for\n+         --  derived types).\n \n-         --  However, if the alignment is known and too small it\n-         --  must be increased, this happens in a case like:\n+         --  However, if the alignment is known and too small it must be\n+         --  increased, this happens in a case like:\n \n          --     type R is new Character;\n          --     for R'Size use 16;\n \n-         --  Here the alignment inherited from Character is 1, but\n-         --  it must be increased to 2 to reflect the increased size.\n+         --  Here the alignment inherited from Character is 1, but it must be\n+         --  increased to 2 to reflect the increased size.\n \n          if Unknown_Alignment (E) or else Alignment (E) < A then\n             Init_Alignment (E, A);\n@@ -3170,8 +3164,8 @@ package body Layout is\n                    Make_Simple_Return_Statement (Loc,\n                      Expression => Expr))));\n \n-      --  The caller requests that the expression be encapsulated in\n-      --  a parameterless function.\n+      --  The caller requests that the expression be encapsulated in a\n+      --  parameterless function.\n \n       elsif Make_Func then\n          Decl :="}]}