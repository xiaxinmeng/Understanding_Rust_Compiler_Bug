{"sha": "9207099bd3b168003016ab76e5aa56c7653803f7", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTIwNzA5OWJkM2IxNjgwMDMwMTZhYjc2ZTVhYTU2Yzc2NTM4MDNmNw==", "commit": {"author": {"name": "Jason Merrill", "email": "jason@redhat.com", "date": "2009-03-07T16:21:05Z"}, "committer": {"name": "Jason Merrill", "email": "jason@gcc.gnu.org", "date": "2009-03-07T16:21:05Z"}, "message": "re PR c++/39367 (ICE at tree-inline.c:1042 with -O)\n\n        PR c++/39367\n        * init.c (build_new_1): Don't use a VLA type.\n        (build_vec_init): Handle getting a pointer for BASE.\n\nFrom-SVN: r144697", "tree": {"sha": "1ead560651b9192652ee6e5795102c95a6c1982b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1ead560651b9192652ee6e5795102c95a6c1982b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/9207099bd3b168003016ab76e5aa56c7653803f7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9207099bd3b168003016ab76e5aa56c7653803f7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9207099bd3b168003016ab76e5aa56c7653803f7", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9207099bd3b168003016ab76e5aa56c7653803f7/comments", "author": {"login": "jicama", "id": 266146, "node_id": "MDQ6VXNlcjI2NjE0Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/266146?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jicama", "html_url": "https://github.com/jicama", "followers_url": "https://api.github.com/users/jicama/followers", "following_url": "https://api.github.com/users/jicama/following{/other_user}", "gists_url": "https://api.github.com/users/jicama/gists{/gist_id}", "starred_url": "https://api.github.com/users/jicama/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jicama/subscriptions", "organizations_url": "https://api.github.com/users/jicama/orgs", "repos_url": "https://api.github.com/users/jicama/repos", "events_url": "https://api.github.com/users/jicama/events{/privacy}", "received_events_url": "https://api.github.com/users/jicama/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "3a695389b367b19c3987d050908c6e7fb58225f0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3a695389b367b19c3987d050908c6e7fb58225f0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3a695389b367b19c3987d050908c6e7fb58225f0"}], "stats": {"total": 196, "additions": 121, "deletions": 75}, "files": [{"sha": "368843fd3a037762efed81d942254fc54d12f2b2", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9207099bd3b168003016ab76e5aa56c7653803f7/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9207099bd3b168003016ab76e5aa56c7653803f7/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=9207099bd3b168003016ab76e5aa56c7653803f7", "patch": "@@ -1,3 +1,9 @@\n+2009-03-07  Jason Merrill  <jason@redhat.com>\n+\n+\tPR c++/39367\n+\t* init.c (build_new_1): Don't use a VLA type.\n+\t(build_vec_init): Handle getting a pointer for BASE.\n+\n 2009-03-06  H.J. Lu  <hongjiu.lu@intel.com>\n \n \tPR c++/37520"}, {"sha": "8e3e4895264de7a3b79ad06ceec2f639715a30d7", "filename": "gcc/cp/init.c", "status": "modified", "additions": 39, "deletions": 75, "changes": 114, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9207099bd3b168003016ab76e5aa56c7653803f7/gcc%2Fcp%2Finit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9207099bd3b168003016ab76e5aa56c7653803f7/gcc%2Fcp%2Finit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Finit.c?ref=9207099bd3b168003016ab76e5aa56c7653803f7", "patch": "@@ -1787,23 +1787,14 @@ build_new_1 (tree placement, tree type, tree nelts, tree init,\n   /* True iff this is a call to \"operator new[]\" instead of just\n      \"operator new\".  */\n   bool array_p = false;\n-  /* True iff ARRAY_P is true and the bound of the array type is\n-     not necessarily a compile time constant.  For example, VLA_P is\n-     true for \"new int[f()]\".  */\n-  bool vla_p = false;\n-  /* The type being allocated.  If ARRAY_P is true, this will be an\n-     ARRAY_TYPE.  */\n-  tree full_type;\n-  /* If ARRAY_P is true, the element type of the array.  This is an\n-     never ARRAY_TYPE; for something like \"new int[3][4]\", the\n+  /* If ARRAY_P is true, the element type of the array.  This is never\n+     an ARRAY_TYPE; for something like \"new int[3][4]\", the\n      ELT_TYPE is \"int\".  If ARRAY_P is false, this is the same type as\n-     FULL_TYPE.  */\n+     TYPE.  */\n   tree elt_type;\n   /* The type of the new-expression.  (This type is always a pointer\n      type.)  */\n   tree pointer_type;\n-  /* A pointer type pointing to the FULL_TYPE.  */\n-  tree full_pointer_type;\n   tree outer_nelts = NULL_TREE;\n   tree alloc_call, alloc_expr;\n   /* The address returned by the call to \"operator new\".  This node is\n@@ -1834,35 +1825,15 @@ build_new_1 (tree placement, tree type, tree nelts, tree init,\n \n   if (nelts)\n     {\n-      tree index;\n-\n       outer_nelts = nelts;\n       array_p = true;\n-\n-      /* ??? The middle-end will error on us for building a VLA outside a\n-\t function context.  Methinks that's not it's purvey.  So we'll do\n-\t our own VLA layout later.  */\n-      vla_p = true;\n-      index = convert (sizetype, nelts);\n-      index = size_binop (MINUS_EXPR, index, size_one_node);\n-      index = build_index_type (index);\n-      full_type = build_cplus_array_type (type, NULL_TREE);\n-      /* We need a copy of the type as build_array_type will return a shared copy\n-         of the incomplete array type.  */\n-      full_type = build_distinct_type_copy (full_type);\n-      TYPE_DOMAIN (full_type) = index;\n-      SET_TYPE_STRUCTURAL_EQUALITY (full_type);\n     }\n-  else\n+  else if (TREE_CODE (type) == ARRAY_TYPE)\n     {\n-      full_type = type;\n-      if (TREE_CODE (type) == ARRAY_TYPE)\n-\t{\n-\t  array_p = true;\n-\t  nelts = array_type_nelts_top (type);\n-\t  outer_nelts = nelts;\n-\t  type = TREE_TYPE (type);\n-\t}\n+      array_p = true;\n+      nelts = array_type_nelts_top (type);\n+      outer_nelts = nelts;\n+      type = TREE_TYPE (type);\n     }\n \n   /* If our base type is an array, then make sure we know how many elements\n@@ -1897,21 +1868,7 @@ build_new_1 (tree placement, tree type, tree nelts, tree init,\n \n   size = size_in_bytes (elt_type);\n   if (array_p)\n-    {\n-      size = size_binop (MULT_EXPR, size, convert (sizetype, nelts));\n-      if (vla_p)\n-\t{\n-\t  tree n, bitsize;\n-\n-\t  /* Do our own VLA layout.  Setting TYPE_SIZE/_UNIT is\n-\t     necessary in order for the <INIT_EXPR <*foo> <CONSTRUCTOR\n-\t     ...>> to be valid.  */\n-\t  TYPE_SIZE_UNIT (full_type) = size;\n-\t  n = convert (bitsizetype, nelts);\n-\t  bitsize = size_binop (MULT_EXPR, TYPE_SIZE (elt_type), n);\n-\t  TYPE_SIZE (full_type) = bitsize;\n-\t}\n-    }\n+    size = size_binop (MULT_EXPR, size, convert (sizetype, nelts));\n \n   alloc_fn = NULL_TREE;\n \n@@ -2139,8 +2096,9 @@ build_new_1 (tree placement, tree type, tree nelts, tree init,\n     }\n \n   /* Now use a pointer to the type we've actually allocated.  */\n-  full_pointer_type = build_pointer_type (full_type);\n-  data_addr = fold_convert (full_pointer_type, data_addr);\n+  data_addr = fold_convert (pointer_type, data_addr);\n+  /* Any further uses of alloc_node will want this type, too.  */\n+  alloc_node = fold_convert (pointer_type, alloc_node);\n \n   /* Now initialize the allocated object.  Note that we preevaluate the\n      initialization expression, apart from the actual constructor call or\n@@ -2152,8 +2110,6 @@ build_new_1 (tree placement, tree type, tree nelts, tree init,\n       bool stable;\n       bool explicit_value_init_p = false;\n \n-      init_expr = cp_build_indirect_ref (data_addr, NULL, complain);\n-\n       if (init == void_zero_node)\n \t{\n \t  init = NULL_TREE;\n@@ -2170,7 +2126,7 @@ build_new_1 (tree placement, tree type, tree nelts, tree init,\n                 return error_mark_node;\n             }\n \t  init_expr\n-\t    = build_vec_init (init_expr,\n+\t    = build_vec_init (data_addr,\n \t\t\t      cp_build_binary_op (input_location,\n \t\t\t\t\t\t  MINUS_EXPR, outer_nelts,\n \t\t\t\t\t\t  integer_one_node,\n@@ -2187,6 +2143,8 @@ build_new_1 (tree placement, tree type, tree nelts, tree init,\n \t}\n       else\n \t{\n+\t  init_expr = cp_build_indirect_ref (data_addr, NULL, complain);\n+\n \t  if (TYPE_NEEDS_CONSTRUCTING (type) && !explicit_value_init_p)\n \t    {\n \t      init_expr = build_special_member_call (init_expr,\n@@ -2198,8 +2156,8 @@ build_new_1 (tree placement, tree type, tree nelts, tree init,\n \t  else if (explicit_value_init_p)\n \t    {\n \t      /* Something like `new int()'.  */\n-\t      init_expr = build2 (INIT_EXPR, full_type,\n-\t\t\t\t  init_expr, build_value_init (full_type));\n+\t      init_expr = build2 (INIT_EXPR, type,\n+\t\t\t\t  init_expr, build_value_init (type));\n \t    }\n \t  else\n \t    {\n@@ -2240,7 +2198,7 @@ build_new_1 (tree placement, tree type, tree nelts, tree init,\n \t     functions that we use for finding allocation functions.  */\n \t  cleanup = (build_op_delete_call\n \t\t     (dcode,\n-\t\t      fold_convert (full_pointer_type, alloc_node),\n+\t\t      alloc_node,\n \t\t      size,\n \t\t      globally_qualified_p,\n \t\t      placement_allocation_fn_p ? alloc_call : NULL_TREE,\n@@ -2323,9 +2281,6 @@ build_new_1 (tree placement, tree type, tree nelts, tree init,\n   if (init_preeval_expr)\n     rval = build2 (COMPOUND_EXPR, TREE_TYPE (rval), init_preeval_expr, rval);\n \n-  /* Convert to the final type.  */\n-  rval = build_nop (pointer_type, rval);\n-\n   /* A new-expression is never an lvalue.  */\n   gcc_assert (!lvalue_p (rval));\n \n@@ -2665,9 +2620,10 @@ get_temp_regvar (tree type, tree init)\n /* `build_vec_init' returns tree structure that performs\n    initialization of a vector of aggregate types.\n \n-   BASE is a reference to the vector, of ARRAY_TYPE.\n+   BASE is a reference to the vector, of ARRAY_TYPE, or a pointer\n+     to the first element, of POINTER_TYPE.\n    MAXINDEX is the maximum index of the array (one less than the\n-     number of elements).  It is only used if\n+     number of elements).  It is only used if BASE is a pointer or\n      TYPE_DOMAIN (TREE_TYPE (BASE)) == NULL_TREE.\n \n    INIT is the (possibly NULL) initializer.\n@@ -2692,7 +2648,7 @@ build_vec_init (tree base, tree maxindex, tree init,\n   tree size;\n   tree itype = NULL_TREE;\n   tree iterator;\n-  /* The type of the array.  */\n+  /* The type of BASE.  */\n   tree atype = TREE_TYPE (base);\n   /* The type of an element in the array.  */\n   tree type = TREE_TYPE (atype);\n@@ -2708,7 +2664,7 @@ build_vec_init (tree base, tree maxindex, tree init,\n   int num_initialized_elts = 0;\n   bool is_global;\n \n-  if (TYPE_DOMAIN (atype))\n+  if (TREE_CODE (atype) == ARRAY_TYPE && TYPE_DOMAIN (atype))\n     maxindex = array_type_nelts (atype);\n \n   if (maxindex == NULL_TREE || maxindex == error_mark_node)\n@@ -2717,7 +2673,7 @@ build_vec_init (tree base, tree maxindex, tree init,\n   if (explicit_value_init_p)\n     gcc_assert (!init);\n \n-  inner_elt_type = strip_array_types (atype);\n+  inner_elt_type = strip_array_types (type);\n   if (init\n       && (from_array == 2\n \t  ? (!CLASS_TYPE_P (inner_elt_type)\n@@ -2734,15 +2690,20 @@ build_vec_init (tree base, tree maxindex, tree init,\n \t brace-enclosed initializers.  In this case, digest_init and\n \t store_constructor will handle the semantics for us.  */\n \n+      gcc_assert (TREE_CODE (atype) == ARRAY_TYPE);\n       stmt_expr = build2 (INIT_EXPR, atype, base, init);\n       return stmt_expr;\n     }\n \n   maxindex = cp_convert (ptrdiff_type_node, maxindex);\n-  ptype = build_pointer_type (type);\n   size = size_in_bytes (type);\n-  if (TREE_CODE (TREE_TYPE (base)) == ARRAY_TYPE)\n-    base = cp_convert (ptype, decay_conversion (base));\n+  if (TREE_CODE (atype) == ARRAY_TYPE)\n+    {\n+      ptype = build_pointer_type (type);\n+      base = cp_convert (ptype, decay_conversion (base));\n+    }\n+  else\n+    ptype = atype;\n \n   /* The code we are generating looks like:\n      ({\n@@ -2954,10 +2915,13 @@ build_vec_init (tree base, tree maxindex, tree init,\n \n   stmt_expr = finish_init_stmts (is_global, stmt_expr, compound_stmt);\n \n-  /* Now convert make the result have the correct type.  */\n-  atype = build_pointer_type (atype);\n-  stmt_expr = build1 (NOP_EXPR, atype, stmt_expr);\n-  stmt_expr = cp_build_indirect_ref (stmt_expr, NULL, complain);\n+  /* Now make the result have the correct type.  */\n+  if (TREE_CODE (atype) == ARRAY_TYPE)\n+    {\n+      atype = build_pointer_type (atype);\n+      stmt_expr = build1 (NOP_EXPR, atype, stmt_expr);\n+      stmt_expr = cp_build_indirect_ref (stmt_expr, NULL, complain);\n+    }\n \n   current_stmt_tree ()->stmts_are_full_exprs_p = destroy_temps;\n   return stmt_expr;"}, {"sha": "f424f37e88f8d7e3ca99148e6a64cb95199d0b0e", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9207099bd3b168003016ab76e5aa56c7653803f7/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9207099bd3b168003016ab76e5aa56c7653803f7/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=9207099bd3b168003016ab76e5aa56c7653803f7", "patch": "@@ -1,3 +1,8 @@\n+2009-03-07  Jason Merrill  <jason@redhat.com>\n+\n+\tPR c++/39367\n+\t* g++.dg/opt/new1.C: New.\n+\n 2009-03-06  Paolo Carlini  <paolo.carlini@oracle.com>\n \n \tPR c++/33492"}, {"sha": "dbcc0f8517a6a4c0d2a7db1275d950bbeb9dd306", "filename": "gcc/testsuite/g++.dg/opt/new1.C", "status": "added", "additions": 71, "deletions": 0, "changes": 71, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9207099bd3b168003016ab76e5aa56c7653803f7/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fopt%2Fnew1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9207099bd3b168003016ab76e5aa56c7653803f7/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fopt%2Fnew1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fopt%2Fnew1.C?ref=9207099bd3b168003016ab76e5aa56c7653803f7", "patch": "@@ -0,0 +1,71 @@\n+// PR c++/39367\n+// { dg-options \"-O\" }\n+\n+class QScriptEnginePrivate;\n+class QScriptClassInfo;\n+namespace QScript {\n+    enum Type { InvalidType };\n+};\n+class QScriptValueImpl {\n+public:\n+    inline QScriptValueImpl();\n+    QScript::Type m_type;\n+};\n+namespace QScript {\n+    namespace Ecma {\n+        class Core {\n+        public:\n+            inline QScriptEnginePrivate *engine() const     { }\n+            inline QScriptClassInfo *classInfo() const     { }\n+            QScriptValueImpl publicPrototype;\n+        };\n+        class Boolean: public Core {\n+            void newBoolean(QScriptValueImpl *result, bool value = false);\n+        };\n+    }\n+    template <typename T> class Buffer     {\n+    public:\n+        inline void reserve(int num);\n+        inline void resize(int s);\n+        T *m_data;\n+        int m_capacity;\n+        int m_size;\n+    };\n+}\n+template <typename T> void QScript::Buffer<T>::resize(int s) {\n+    if (m_capacity < s)\n+      reserve (s << 1);\n+}\n+template <typename T> void QScript::Buffer<T>::reserve(int x) {\n+    T *new_data = new T[m_capacity];\n+    for (int i=0; i<m_size; ++i)\n+      new_data[i] = m_data[i];\n+}\n+class QScriptObject {\n+public:\n+    inline void reset();\n+    QScript::Buffer<QScriptValueImpl> m_values;\n+};\n+class QScriptEnginePrivate {\n+public:\n+  inline QScriptObject *allocObject() { return 0; }\n+    inline void newObject(QScriptValueImpl *o, const QScriptValueImpl &proto,\n+                          QScriptClassInfo *oc = 0);\n+};\n+inline void QScriptEnginePrivate::newObject(QScriptValueImpl *o,\n+                                            const QScriptValueImpl &proto,\n+                                            QScriptClassInfo *oc)\n+{\n+  QScriptObject *od = allocObject();\n+  od->reset();\n+}\n+inline QScriptValueImpl::QScriptValueImpl() : m_type(QScript::InvalidType) { }\n+inline void QScriptObject::reset() { m_values.resize(0); }\n+namespace QScript {\n+    namespace Ecma {\n+        void Boolean::newBoolean(QScriptValueImpl *result, bool value)\n+          {\n+            engine()->newObject(result, publicPrototype, classInfo());\n+          }\n+    }\n+}"}]}