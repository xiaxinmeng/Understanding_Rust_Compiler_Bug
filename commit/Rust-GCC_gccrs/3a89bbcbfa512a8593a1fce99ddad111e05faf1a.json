{"sha": "3a89bbcbfa512a8593a1fce99ddad111e05faf1a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6M2E4OWJiY2JmYTUxMmE4NTkzYTFmY2U5OWRkYWQxMTFlMDVmYWYxYQ==", "commit": {"author": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1995-11-05T15:49:06Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1995-11-05T15:49:06Z"}, "message": "(emit_move_sequence): Add a scratch register to multi-reg stores.\n\n(i960_output_move_{double,quad}): New functions.\n(i960_print_operand): Handle new operand types E, F.\n\nFrom-SVN: r10552", "tree": {"sha": "386236d8b1887627c564c50ebe9a01b0e6d6baf5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/386236d8b1887627c564c50ebe9a01b0e6d6baf5"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3a89bbcbfa512a8593a1fce99ddad111e05faf1a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3a89bbcbfa512a8593a1fce99ddad111e05faf1a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3a89bbcbfa512a8593a1fce99ddad111e05faf1a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3a89bbcbfa512a8593a1fce99ddad111e05faf1a/comments", "author": null, "committer": null, "parents": [{"sha": "7f2e00db7b5b50383431ffee7a5545481879a629", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7f2e00db7b5b50383431ffee7a5545481879a629", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7f2e00db7b5b50383431ffee7a5545481879a629"}], "stats": {"total": 177, "additions": 171, "deletions": 6}, "files": [{"sha": "fde2e43e7869cc3d710f6656149dc88c8a30f35e", "filename": "gcc/config/i960/i960.c", "status": "modified", "additions": 171, "deletions": 6, "changes": 177, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3a89bbcbfa512a8593a1fce99ddad111e05faf1a/gcc%2Fconfig%2Fi960%2Fi960.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3a89bbcbfa512a8593a1fce99ddad111e05faf1a/gcc%2Fconfig%2Fi960%2Fi960.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi960%2Fi960.c?ref=3a89bbcbfa512a8593a1fce99ddad111e05faf1a", "patch": "@@ -560,16 +560,171 @@ emit_move_sequence (operands, mode)\n      rtx *operands;\n      enum machine_mode mode;\n {\n-  register rtx operand0 = operands[0];\n-  register rtx operand1 = operands[1];\n-\n   /* We can only store registers to memory.  */\n \n-  if (GET_CODE (operand0) == MEM && GET_CODE (operand1) != REG)\n-    operands[1] = force_reg (mode, operand1);\n+  if (GET_CODE (operands[0]) == MEM && GET_CODE (operands[1]) != REG)\n+    operands[1] = force_reg (mode, operands[1]);\n+\n+  /* Storing multi-word values in unaligned hard registers to memory may\n+     require a scratch since we have to store them a register at a time and\n+     adding 4 to the memory address may not yield a valid insn.  */\n+  /* ??? We don't always need the scratch, but that would complicate things.\n+     Maybe later.  */\n+  if (GET_MODE_SIZE (mode) > UNITS_PER_WORD\n+      && GET_CODE (operands[0]) == MEM\n+      && GET_CODE (operands[1]) == REG\n+      && REGNO (operands[1]) < FIRST_PSEUDO_REGISTER\n+      && ! HARD_REGNO_MODE_OK (REGNO (operands[1]), mode))\n+    {\n+      emit_insn (gen_rtx (PARALLEL, VOIDmode,\n+\t\t\t  gen_rtvec (2,\n+\t\t\t\t     gen_rtx (SET, VOIDmode,\n+\t\t\t\t\t      operands[0], operands[1]),\n+\t\t\t\t     gen_rtx (CLOBBER, VOIDmode,\n+\t\t\t\t\t      gen_rtx (SCRATCH, Pmode)))));\n+      return 1;\n+    }\n \n   return 0;\n }\n+\n+/* Output assembler to move a double word value.  */\n+\n+char *\n+i960_output_move_double (dst, src)\n+     rtx dst, src;\n+{\n+  rtx operands[5];\n+\n+  if (GET_CODE (dst) == REG\n+      && GET_CODE (src) == REG)\n+    {\n+      if ((REGNO (src) & 1)\n+\t  || (REGNO (dst) & 1))\n+\t{\n+\t  /* We normally copy the low-numbered register first.  However, if\n+\t     the second source register is the same as the first destination\n+\t     register, we must copy in the opposite order.  */\n+\t  if (REGNO (src) + 1 == REGNO (dst))\n+\t    return \"mov\t%D1,%D0\\n\\tmov\t%1,%0\";\n+\t  else\n+\t    return \"mov\t%1,%0\\n\\tmov\t%D1,%D0\";\n+\t}\n+      else\n+\treturn \"movl\t%1,%0\";\n+    }\n+  else if (GET_CODE (dst) == REG\n+\t   && GET_CODE (src) == CONST_INT\n+\t   && CONST_OK_FOR_LETTER_P (INTVAL (src), 'I'))\n+    {\n+      if (REGNO (dst) & 1)\n+\treturn \"mov\t%1,%0\\n\\tmov\t0,%D0\";\n+      else\n+\treturn \"movl\t%1,%0\";\n+    }\n+  else if (GET_CODE (dst) == REG\n+\t   && GET_CODE (src) == MEM)\n+    {\n+      if (REGNO (dst) & 1)\n+\t{\n+\t  /* One can optimize a few cases here, but you have to be\n+\t     careful of clobbering registers used in the address and\n+\t     edge conditions.  */\n+\t  operands[0] = dst;\n+\t  operands[1] = src;\n+\t  operands[2] = gen_rtx (REG, Pmode, REGNO (dst) + 1);\n+\t  operands[3] = gen_rtx (MEM, word_mode, operands[2]);\n+\t  operands[4] = adj_offsettable_operand (operands[3], UNITS_PER_WORD);\n+\t  output_asm_insn (\"lda\t%1,%2\\n\\tld\t%3,%0\\n\\tld\t%4,%D0\", operands);\n+\t  return \"\";\n+\t}\n+      else\n+\treturn \"ldl\t%1,%0\";\n+    }\n+  else if (GET_CODE (dst) == MEM\n+\t   && GET_CODE (src) == REG)\n+    {\n+      if (REGNO (src) & 1)\n+\t{\n+\t  /* This is handled by emit_move_sequence so we shouldn't get here.  */\n+\t  abort ();\n+\t}\n+      return \"stl\t%1,%0\";\n+    }\n+  else\n+    abort ();\n+}\n+\n+/* Output assembler to move a quad word value.  */\n+\n+char *\n+i960_output_move_quad (dst, src)\n+     rtx dst, src;\n+{\n+  rtx operands[7];\n+\n+  if (GET_CODE (dst) == REG\n+      && GET_CODE (src) == REG)\n+    {\n+      if ((REGNO (src) & 3)\n+\t  || (REGNO (dst) & 3))\n+\t{\n+\t  /* We normally copy starting with the low numbered register.\n+\t     However, if there is an overlap such that the first dest reg\n+\t     is <= the last source reg but not < the first source reg, we\n+\t     must copy in the opposite order.  */\n+\t  if (REGNO (dst) <= REGNO (src) + 3\n+\t      && REGNO (dst) >= REGNO (src))\n+\t    return \"mov\t%F1,%F0\\n\\tmov\t%E1,%E0\\n\\tmov\t%D1,%D0\\n\\tmov\t%1,%0\";\n+\t  else\n+\t    return \"mov\t%1,%0\\n\\tmov\t%D1,%D0\\n\\tmov\t%E1,%E0\\n\\tmov\t%F1,%F0\";\n+\t}\n+      else\n+\treturn \"movq\t%1,%0\";\n+    }\n+  else if (GET_CODE (dst) == REG\n+\t   && GET_CODE (src) == CONST_INT\n+\t   && CONST_OK_FOR_LETTER_P (INTVAL (src), 'I'))\n+    {\n+      if (REGNO (dst) & 3)\n+\treturn \"mov\t%1,%0\\n\\tmov\t0,%D0\\n\\tmov\t0,%E0\\n\\tmov\t0,%F0\";\n+      else\n+\treturn \"movq\t%1,%0\";\n+    }\n+  else if (GET_CODE (dst) == REG\n+\t   && GET_CODE (src) == MEM)\n+    {\n+      if (REGNO (dst) & 3)\n+\t{\n+\t  /* One can optimize a few cases here, but you have to be\n+\t     careful of clobbering registers used in the address and\n+\t     edge conditions.  */\n+\t  operands[0] = dst;\n+\t  operands[1] = src;\n+\t  operands[2] = gen_rtx (REG, Pmode, REGNO (dst) + 3);\n+\t  operands[3] = gen_rtx (MEM, word_mode, operands[2]);\n+\t  operands[4] = adj_offsettable_operand (operands[3], UNITS_PER_WORD);\n+\t  operands[5] = adj_offsettable_operand (operands[4], UNITS_PER_WORD);\n+\t  operands[6] = adj_offsettable_operand (operands[5], UNITS_PER_WORD);\n+\t  output_asm_insn (\"lda\t%1,%2\\n\\tld\t%3,%0\\n\\tld\t%4,%D0\\n\\tld\t%5,%E0\\n\\tld\t%6,%F0\", operands);\n+\t  return \"\";\n+\t}\n+      else\n+\treturn \"ldq\t%1,%0\";\n+    }\n+  else if (GET_CODE (dst) == MEM\n+\t   && GET_CODE (src) == REG)\n+    {\n+      if (REGNO (src) & 3)\n+\t{\n+\t  /* This is handled by emit_move_sequence so we shouldn't get here.  */\n+\t  abort ();\n+\t}\n+      return \"stq\t%1,%0\";\n+    }\n+  else\n+    abort ();\n+}\n \f\n /* Emit insns to load a constant to non-floating point registers.\n    Uses several strategies to try to use as few insns as possible.  */\n@@ -1453,10 +1608,20 @@ i960_print_operand (file, x, code)\n       switch (code)\n \t{\n \tcase 'D':\n-\t  /* Second reg of a double.  */\n+\t  /* Second reg of a double or quad.  */\n \t  fprintf (file, \"%s\", reg_names[REGNO (x)+1]);\n \t  break;\n \n+\tcase 'E':\n+\t  /* Third reg of a quad.  */\n+\t  fprintf (file, \"%s\", reg_names[REGNO (x)+2]);\n+\t  break;\n+\n+\tcase 'F':\n+\t  /* Fourth reg of a quad.  */\n+\t  fprintf (file, \"%s\", reg_names[REGNO (x)+3]);\n+\t  break;\n+\n \tcase 0:\n \t  fprintf (file, \"%s\", reg_names[REGNO (x)]);\n \t  break;"}]}