{"sha": "511ed59d0b0404577b7fec9b4fcaeb6a8f0c0d34", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTExZWQ1OWQwYjA0MDQ1NzdiN2ZlYzliNGZjYWViNmE4ZjBjMGQzNA==", "commit": {"author": {"name": "Wilco Dijkstra", "email": "wdijkstr@arm.com", "date": "2019-06-03T13:55:15Z"}, "committer": {"name": "Wilco Dijkstra", "email": "wilco@gcc.gnu.org", "date": "2019-06-03T13:55:15Z"}, "message": "Fix PR64242 - Longjmp expansion incorrect\n\nImprove the fix for PR64242.  Various optimizations can change a memory\nreference into a frame access.  Given there are multiple virtual frame pointers\nwhich may be replaced by multiple hard frame pointers, there are no checks for\nwrites to the various frame pointers.  So updates to a frame pointer tends to\ngenerate incorrect code.  Improve the previous fix to also add clobbers of\nseveral frame pointers and add a scheduling barrier.  This should work in most\ncases until GCC supports a generic \"don't optimize across this instruction\"\nfeature.\n\nBootstrap OK. Testcase passes on AArch64 and x86-64.  Inspected x86, Arm,\nThumb-1 and Thumb-2 assembler which looks correct. \n\n    gcc/\n\tPR middle-end/64242\n\t* builtins.c (expand_builtin_longjmp): Add frame clobbers and schedule\n\tblock.\n\t(expand_builtin_nonlocal_goto): Likewise.\n\n    testsuite/\n\tPR middle-end/64242\n\t* gcc.c-torture/execute/pr64242.c: Update test.\n\nFrom-SVN: r271870", "tree": {"sha": "2518077c50198015ff9073805bf48a9eb1f535d1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/2518077c50198015ff9073805bf48a9eb1f535d1"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/511ed59d0b0404577b7fec9b4fcaeb6a8f0c0d34", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/511ed59d0b0404577b7fec9b4fcaeb6a8f0c0d34", "html_url": "https://github.com/Rust-GCC/gccrs/commit/511ed59d0b0404577b7fec9b4fcaeb6a8f0c0d34", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/511ed59d0b0404577b7fec9b4fcaeb6a8f0c0d34/comments", "author": null, "committer": null, "parents": [{"sha": "b07fc91cc47769f1fdabf31a3c8f942caf49d873", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b07fc91cc47769f1fdabf31a3c8f942caf49d873", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b07fc91cc47769f1fdabf31a3c8f942caf49d873"}], "stats": {"total": 63, "additions": 35, "deletions": 28}, "files": [{"sha": "d6dd1bd5605a3bad8ea22d64730ec3833b1aeacc", "filename": "gcc/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/511ed59d0b0404577b7fec9b4fcaeb6a8f0c0d34/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/511ed59d0b0404577b7fec9b4fcaeb6a8f0c0d34/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=511ed59d0b0404577b7fec9b4fcaeb6a8f0c0d34", "patch": "@@ -1,3 +1,10 @@\n+2019-06-03  Wilco Dijkstra  <wdijkstr@arm.com>\n+\n+\tPR middle-end/64242\n+\t* builtins.c (expand_builtin_longjmp): Add frame clobbers and schedule\n+\tblock.\n+\t(expand_builtin_nonlocal_goto): Likewise.\n+\n 2019-06-03  Szabolcs Nagy  <szabolcs.nagy@arm.com>\n \n \t* config/aarch64/aarch64-protos.h (aarch64_asm_output_alias): Declare."}, {"sha": "3463ffb153914a58e5baa3896a244842a28eef09", "filename": "gcc/builtins.c", "status": "modified", "additions": 14, "deletions": 4, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/511ed59d0b0404577b7fec9b4fcaeb6a8f0c0d34/gcc%2Fbuiltins.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/511ed59d0b0404577b7fec9b4fcaeb6a8f0c0d34/gcc%2Fbuiltins.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbuiltins.c?ref=511ed59d0b0404577b7fec9b4fcaeb6a8f0c0d34", "patch": "@@ -1137,15 +1137,20 @@ expand_builtin_longjmp (rtx buf_addr, rtx value)\n \temit_insn (targetm.gen_nonlocal_goto (value, lab, stack, fp));\n       else\n \t{\n-\t  lab = copy_to_reg (lab);\n-\n \t  emit_clobber (gen_rtx_MEM (BLKmode, gen_rtx_SCRATCH (VOIDmode)));\n \t  emit_clobber (gen_rtx_MEM (BLKmode, hard_frame_pointer_rtx));\n \n+\t  lab = copy_to_reg (lab);\n+\n \t  /* Restore the frame pointer and stack pointer.  We must use a\n \t     temporary since the setjmp buffer may be a local.  */\n \t  fp = copy_to_reg (fp);\n \t  emit_stack_restore (SAVE_NONLOCAL, stack);\n+\n+\t  /* Ensure the frame pointer move is not optimized.  */\n+\t  emit_insn (gen_blockage ());\n+\t  emit_clobber (hard_frame_pointer_rtx);\n+\t  emit_clobber (frame_pointer_rtx);\n \t  emit_move_insn (hard_frame_pointer_rtx, fp);\n \n \t  emit_use (hard_frame_pointer_rtx);\n@@ -1284,15 +1289,20 @@ expand_builtin_nonlocal_goto (tree exp)\n     emit_insn (targetm.gen_nonlocal_goto (const0_rtx, r_label, r_sp, r_fp));\n   else\n     {\n-      r_label = copy_to_reg (r_label);\n-\n       emit_clobber (gen_rtx_MEM (BLKmode, gen_rtx_SCRATCH (VOIDmode)));\n       emit_clobber (gen_rtx_MEM (BLKmode, hard_frame_pointer_rtx));\n \n+      r_label = copy_to_reg (r_label);\n+\n       /* Restore the frame pointer and stack pointer.  We must use a\n \t temporary since the setjmp buffer may be a local.  */\n       r_fp = copy_to_reg (r_fp);\n       emit_stack_restore (SAVE_NONLOCAL, r_sp);\n+\n+      /* Ensure the frame pointer move is not optimized.  */\n+      emit_insn (gen_blockage ());\n+      emit_clobber (hard_frame_pointer_rtx);\n+      emit_clobber (frame_pointer_rtx);\n       emit_move_insn (hard_frame_pointer_rtx, r_fp);\n \n       /* USE of hard_frame_pointer_rtx added for consistency;"}, {"sha": "f0faea0daa1244ef4f79c15a4ed06742064fa471", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/511ed59d0b0404577b7fec9b4fcaeb6a8f0c0d34/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/511ed59d0b0404577b7fec9b4fcaeb6a8f0c0d34/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=511ed59d0b0404577b7fec9b4fcaeb6a8f0c0d34", "patch": "@@ -1,3 +1,8 @@\n+2019-06-03  Wilco Dijkstra  <wdijkstr@arm.com>\n+\n+\tPR middle-end/64242\n+\t* gcc.c-torture/execute/pr64242.c: Update test.\n+\n 2019-06-03  Szabolcs Nagy  <szabolcs.nagy@arm.com>\n \n \t* gcc.target/aarch64/pcs_attribute-2.c: New test."}, {"sha": "e6139ede3f34d587ac53d04e286e5d75fd2ca76c", "filename": "gcc/testsuite/gcc.c-torture/execute/pr64242.c", "status": "modified", "additions": 9, "deletions": 24, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/511ed59d0b0404577b7fec9b4fcaeb6a8f0c0d34/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fpr64242.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/511ed59d0b0404577b7fec9b4fcaeb6a8f0c0d34/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fpr64242.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fpr64242.c?ref=511ed59d0b0404577b7fec9b4fcaeb6a8f0c0d34", "patch": "@@ -5,46 +5,31 @@ extern void abort (void);\n __attribute ((noinline)) void\n broken_longjmp (void *p)\n {\n-  void *buf[5];\n+  void *buf[32];\n   __builtin_memcpy (buf, p, 5 * sizeof (void*));\n   /* Corrupts stack pointer...  */\n   __builtin_longjmp (buf, 1);\n }\n \n-__attribute ((noipa)) __UINTPTR_TYPE__\n-foo (void *p)\n-{\n-  return (__UINTPTR_TYPE__) p;\n-}\n-\n-__attribute ((noipa)) void\n-bar (void *p)\n-{\n-  asm volatile (\"\" : : \"r\" (p));\n-}\n-\n volatile int x = 0;\n-void *volatile p;\n-void *volatile q;\n+char *volatile p;\n+char *volatile q;\n \n int\n main ()\n {\n   void *buf[5];\n-  struct __attribute__((aligned (32))) S { int a[4]; } s;\n-  bar (&s);\n   p = __builtin_alloca (x);\n+  q = __builtin_alloca (x);\n   if (!__builtin_setjmp (buf))\n     broken_longjmp (buf);\n \n+  /* Compute expected next alloca offset - some targets don't align properly\n+     and allocate too much.  */\n+  p = q + (q - p);\n+\n   /* Fails if stack pointer corrupted.  */\n-  q = __builtin_alloca (x);\n-  if (foo (p) < foo (q))\n-    {\n-      if (foo (q) - foo (p) >= 1024)\n-\tabort ();\n-    }\n-  else if (foo (p) - foo (q) >= 1024)\n+  if (p != __builtin_alloca (x))\n     abort ();\n \n   return 0;"}]}