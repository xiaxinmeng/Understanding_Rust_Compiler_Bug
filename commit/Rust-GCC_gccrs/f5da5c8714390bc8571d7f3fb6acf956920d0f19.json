{"sha": "f5da5c8714390bc8571d7f3fb6acf956920d0f19", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjVkYTVjODcxNDM5MGJjODU3MWQ3ZjNmYjZhY2Y5NTY5MjBkMGYxOQ==", "commit": {"author": {"name": "Jan Hubicka", "email": "hubicka@freesoft.cz", "date": "1999-11-02T16:37:23Z"}, "committer": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "1999-11-02T16:37:23Z"}, "message": "jump.c (jump_optimize_1): Swap the incscc and the conditional mode detection code\n\n        * jump.c (jump_optimize_1): Swap the incscc and the conditional mode\n        detection code\n\n        * unroll.c (unroll_loop): Remove LOOP notes when loop is\n        completely unrolled.\n\nFrom-SVN: r30352", "tree": {"sha": "c2d3e87bda7c4504bd6e24dc9dd801f9f58ac597", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c2d3e87bda7c4504bd6e24dc9dd801f9f58ac597"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f5da5c8714390bc8571d7f3fb6acf956920d0f19", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f5da5c8714390bc8571d7f3fb6acf956920d0f19", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f5da5c8714390bc8571d7f3fb6acf956920d0f19", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f5da5c8714390bc8571d7f3fb6acf956920d0f19/comments", "author": null, "committer": null, "parents": [{"sha": "c3dfacf03a2092fa3cfc485e7a7bdd10804dd543", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c3dfacf03a2092fa3cfc485e7a7bdd10804dd543", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c3dfacf03a2092fa3cfc485e7a7bdd10804dd543"}], "stats": {"total": 280, "additions": 156, "deletions": 124}, "files": [{"sha": "efc7f418afd789105227833c0bf8f686cab10ed6", "filename": "gcc/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f5da5c8714390bc8571d7f3fb6acf956920d0f19/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f5da5c8714390bc8571d7f3fb6acf956920d0f19/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=f5da5c8714390bc8571d7f3fb6acf956920d0f19", "patch": "@@ -1,3 +1,11 @@\n+Tue Nov  2 04:10:24 1999  Jan Hubicka  <hubicka@freesoft.cz>\n+\n+\t* jump.c (jump_optimize_1): Swap the incscc and the conditional mode\n+\tdetection code\n+\n+\t* unroll.c (unroll_loop): Remove LOOP notes when loop is\n+\tcompletely unrolled.\n+\n Tue Nov  2 16:57:22 1999  Bernd Schmidt  <bernds@cygnus.co.uk>\n \n \t* cse.c (simplify_plus_minus, check_fold_const): Delete declarations."}, {"sha": "538460945d47b4653eecec25f2220175310d6f98", "filename": "gcc/jump.c", "status": "modified", "additions": 124, "deletions": 124, "changes": 248, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f5da5c8714390bc8571d7f3fb6acf956920d0f19/gcc%2Fjump.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f5da5c8714390bc8571d7f3fb6acf956920d0f19/gcc%2Fjump.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjump.c?ref=f5da5c8714390bc8571d7f3fb6acf956920d0f19", "patch": "@@ -1116,6 +1116,130 @@ jump_optimize_1 (f, cross_jump, noop_moves, after_regscan, mark_labels_only)\n \t\t}\n \t    }\n #endif\n+\t  /* If branches are expensive, convert\n+\t        if (foo) bar++;    to    bar += (foo != 0);\n+\t     and similarly for \"bar--;\" \n+\n+\t     INSN is the conditional branch around the arithmetic.  We set:\n+\n+\t     TEMP is the arithmetic insn.\n+\t     TEMP1 is the SET doing the arithmetic.\n+\t     TEMP2 is the operand being incremented or decremented.\n+\t     TEMP3 to the condition being tested.\n+\t     TEMP4 to the earliest insn used to find the condition.  */\n+\n+\t  if ((BRANCH_COST >= 2\n+#ifdef HAVE_incscc\n+\t       || HAVE_incscc\n+#endif\n+#ifdef HAVE_decscc\n+\t       || HAVE_decscc\n+#endif\n+\t      )\n+\t      && ! reload_completed\n+\t      && this_is_condjump && ! this_is_simplejump\n+\t      && (temp = next_nonnote_insn (insn)) != 0\n+\t      && (temp1 = single_set (temp)) != 0\n+\t      && (temp2 = SET_DEST (temp1),\n+\t\t  GET_MODE_CLASS (GET_MODE (temp2)) == MODE_INT)\n+\t      && GET_CODE (SET_SRC (temp1)) == PLUS\n+\t      && (XEXP (SET_SRC (temp1), 1) == const1_rtx\n+\t\t  || XEXP (SET_SRC (temp1), 1) == constm1_rtx)\n+\t      && rtx_equal_p (temp2, XEXP (SET_SRC (temp1), 0))\n+\t      && ! side_effects_p (temp2)\n+\t      && ! may_trap_p (temp2)\n+\t      /* INSN must either branch to the insn after TEMP or the insn\n+\t\t after TEMP must branch to the same place as INSN.  */\n+\t      && (reallabelprev == temp\n+\t\t  || ((temp3 = next_active_insn (temp)) != 0\n+\t\t      && simplejump_p (temp3)\n+\t\t      && JUMP_LABEL (temp3) == JUMP_LABEL (insn)))\n+\t      && (temp3 = get_condition (insn, &temp4)) != 0\n+\t      /* We must be comparing objects whose modes imply the size.\n+\t\t We could handle BLKmode if (1) emit_store_flag could\n+\t\t and (2) we could find the size reliably.  */\n+\t      && GET_MODE (XEXP (temp3, 0)) != BLKmode\n+\t      && can_reverse_comparison_p (temp3, insn))\n+\t    {\n+\t      rtx temp6, target = 0, seq, init_insn = 0, init = temp2;\n+\t      enum rtx_code code = reverse_condition (GET_CODE (temp3));\n+\n+\t      start_sequence ();\n+\n+\t      /* It must be the case that TEMP2 is not modified in the range\n+\t\t [TEMP4, INSN).  The one exception we make is if the insn\n+\t\t before INSN sets TEMP2 to something which is also unchanged\n+\t\t in that range.  In that case, we can move the initialization\n+\t\t into our sequence.  */\n+\n+\t      if ((temp5 = prev_active_insn (insn)) != 0\n+\t\t  && no_labels_between_p (temp5, insn)\n+\t\t  && GET_CODE (temp5) == INSN\n+\t\t  && (temp6 = single_set (temp5)) != 0\n+\t\t  && rtx_equal_p (temp2, SET_DEST (temp6))\n+\t\t  && (CONSTANT_P (SET_SRC (temp6))\n+\t\t      || GET_CODE (SET_SRC (temp6)) == REG\n+\t\t      || GET_CODE (SET_SRC (temp6)) == SUBREG))\n+\t\t{\n+\t\t  emit_insn (PATTERN (temp5));\n+\t\t  init_insn = temp5;\n+\t\t  init = SET_SRC (temp6);\n+\t\t}\n+\n+\t      if (CONSTANT_P (init)\n+\t\t  || ! reg_set_between_p (init, PREV_INSN (temp4), insn))\n+\t\ttarget = emit_store_flag (gen_reg_rtx (GET_MODE (temp2)), code,\n+\t\t\t\t\t  XEXP (temp3, 0), XEXP (temp3, 1),\n+\t\t\t\t\t  VOIDmode,\n+\t\t\t\t\t  (code == LTU || code == LEU\n+\t\t\t\t\t   || code == GTU || code == GEU), 1);\n+\n+\t      /* If we can do the store-flag, do the addition or\n+\t\t subtraction.  */\n+\n+\t      if (target)\n+\t\ttarget = expand_binop (GET_MODE (temp2),\n+\t\t\t\t       (XEXP (SET_SRC (temp1), 1) == const1_rtx\n+\t\t\t\t\t? add_optab : sub_optab),\n+\t\t\t\t       temp2, target, temp2, 0, OPTAB_WIDEN);\n+\n+\t      if (target != 0)\n+\t\t{\n+\t\t  /* Put the result back in temp2 in case it isn't already.\n+\t\t     Then replace the jump, possible a CC0-setting insn in\n+\t\t     front of the jump, and TEMP, with the sequence we have\n+\t\t     made.  */\n+\n+\t\t  if (target != temp2)\n+\t\t    emit_move_insn (temp2, target);\n+\n+\t\t  seq = get_insns ();\n+\t\t  end_sequence ();\n+\n+\t\t  emit_insns_before (seq, temp4);\n+\t\t  delete_insn (temp);\n+\n+\t\t  if (init_insn)\n+\t\t    delete_insn (init_insn);\n+\n+\t\t  next = NEXT_INSN (insn);\n+#ifdef HAVE_cc0\n+\t\t  delete_insn (prev_nonnote_insn (insn));\n+#endif\n+\t\t  delete_insn (insn);\n+\n+\t\t  if (after_regscan)\n+\t\t    {\n+\t\t      reg_scan_update (seq, NEXT_INSN (next), old_max_reg);\n+\t\t      old_max_reg = max_reg_num ();\n+\t\t    }\n+\n+\t\t  changed = 1;\n+\t\t  continue;\n+\t\t}\n+\t      else\n+\t\tend_sequence ();\n+\t    }\n \n \t  /* Try to use a conditional move (if the target has them), or a\n \t     store-flag insn.  If the target has conditional arithmetic as\n@@ -1505,130 +1629,6 @@ jump_optimize_1 (f, cross_jump, noop_moves, after_regscan, mark_labels_only)\n \t\t}\n \t    }\n \n-\t  /* If branches are expensive, convert\n-\t        if (foo) bar++;    to    bar += (foo != 0);\n-\t     and similarly for \"bar--;\" \n-\n-\t     INSN is the conditional branch around the arithmetic.  We set:\n-\n-\t     TEMP is the arithmetic insn.\n-\t     TEMP1 is the SET doing the arithmetic.\n-\t     TEMP2 is the operand being incremented or decremented.\n-\t     TEMP3 to the condition being tested.\n-\t     TEMP4 to the earliest insn used to find the condition.  */\n-\n-\t  if ((BRANCH_COST >= 2\n-#ifdef HAVE_incscc\n-\t       || HAVE_incscc\n-#endif\n-#ifdef HAVE_decscc\n-\t       || HAVE_decscc\n-#endif\n-\t      )\n-\t      && ! reload_completed\n-\t      && this_is_condjump && ! this_is_simplejump\n-\t      && (temp = next_nonnote_insn (insn)) != 0\n-\t      && (temp1 = single_set (temp)) != 0\n-\t      && (temp2 = SET_DEST (temp1),\n-\t\t  GET_MODE_CLASS (GET_MODE (temp2)) == MODE_INT)\n-\t      && GET_CODE (SET_SRC (temp1)) == PLUS\n-\t      && (XEXP (SET_SRC (temp1), 1) == const1_rtx\n-\t\t  || XEXP (SET_SRC (temp1), 1) == constm1_rtx)\n-\t      && rtx_equal_p (temp2, XEXP (SET_SRC (temp1), 0))\n-\t      && ! side_effects_p (temp2)\n-\t      && ! may_trap_p (temp2)\n-\t      /* INSN must either branch to the insn after TEMP or the insn\n-\t\t after TEMP must branch to the same place as INSN.  */\n-\t      && (reallabelprev == temp\n-\t\t  || ((temp3 = next_active_insn (temp)) != 0\n-\t\t      && simplejump_p (temp3)\n-\t\t      && JUMP_LABEL (temp3) == JUMP_LABEL (insn)))\n-\t      && (temp3 = get_condition (insn, &temp4)) != 0\n-\t      /* We must be comparing objects whose modes imply the size.\n-\t\t We could handle BLKmode if (1) emit_store_flag could\n-\t\t and (2) we could find the size reliably.  */\n-\t      && GET_MODE (XEXP (temp3, 0)) != BLKmode\n-\t      && can_reverse_comparison_p (temp3, insn))\n-\t    {\n-\t      rtx temp6, target = 0, seq, init_insn = 0, init = temp2;\n-\t      enum rtx_code code = reverse_condition (GET_CODE (temp3));\n-\n-\t      start_sequence ();\n-\n-\t      /* It must be the case that TEMP2 is not modified in the range\n-\t\t [TEMP4, INSN).  The one exception we make is if the insn\n-\t\t before INSN sets TEMP2 to something which is also unchanged\n-\t\t in that range.  In that case, we can move the initialization\n-\t\t into our sequence.  */\n-\n-\t      if ((temp5 = prev_active_insn (insn)) != 0\n-\t\t  && no_labels_between_p (temp5, insn)\n-\t\t  && GET_CODE (temp5) == INSN\n-\t\t  && (temp6 = single_set (temp5)) != 0\n-\t\t  && rtx_equal_p (temp2, SET_DEST (temp6))\n-\t\t  && (CONSTANT_P (SET_SRC (temp6))\n-\t\t      || GET_CODE (SET_SRC (temp6)) == REG\n-\t\t      || GET_CODE (SET_SRC (temp6)) == SUBREG))\n-\t\t{\n-\t\t  emit_insn (PATTERN (temp5));\n-\t\t  init_insn = temp5;\n-\t\t  init = SET_SRC (temp6);\n-\t\t}\n-\n-\t      if (CONSTANT_P (init)\n-\t\t  || ! reg_set_between_p (init, PREV_INSN (temp4), insn))\n-\t\ttarget = emit_store_flag (gen_reg_rtx (GET_MODE (temp2)), code,\n-\t\t\t\t\t  XEXP (temp3, 0), XEXP (temp3, 1),\n-\t\t\t\t\t  VOIDmode,\n-\t\t\t\t\t  (code == LTU || code == LEU\n-\t\t\t\t\t   || code == GTU || code == GEU), 1);\n-\n-\t      /* If we can do the store-flag, do the addition or\n-\t\t subtraction.  */\n-\n-\t      if (target)\n-\t\ttarget = expand_binop (GET_MODE (temp2),\n-\t\t\t\t       (XEXP (SET_SRC (temp1), 1) == const1_rtx\n-\t\t\t\t\t? add_optab : sub_optab),\n-\t\t\t\t       temp2, target, temp2, 0, OPTAB_WIDEN);\n-\n-\t      if (target != 0)\n-\t\t{\n-\t\t  /* Put the result back in temp2 in case it isn't already.\n-\t\t     Then replace the jump, possible a CC0-setting insn in\n-\t\t     front of the jump, and TEMP, with the sequence we have\n-\t\t     made.  */\n-\n-\t\t  if (target != temp2)\n-\t\t    emit_move_insn (temp2, target);\n-\n-\t\t  seq = get_insns ();\n-\t\t  end_sequence ();\n-\n-\t\t  emit_insns_before (seq, temp4);\n-\t\t  delete_insn (temp);\n-\n-\t\t  if (init_insn)\n-\t\t    delete_insn (init_insn);\n-\n-\t\t  next = NEXT_INSN (insn);\n-#ifdef HAVE_cc0\n-\t\t  delete_insn (prev_nonnote_insn (insn));\n-#endif\n-\t\t  delete_insn (insn);\n-\n-\t\t  if (after_regscan)\n-\t\t    {\n-\t\t      reg_scan_update (seq, NEXT_INSN (next), old_max_reg);\n-\t\t      old_max_reg = max_reg_num ();\n-\t\t    }\n-\n-\t\t  changed = 1;\n-\t\t  continue;\n-\t\t}\n-\t      else\n-\t\tend_sequence ();\n-\t    }\n \n \t  /* Simplify   if (...) x = 1; else {...}  if (x) ...\n \t     We recognize this case scanning backwards as well."}, {"sha": "fac8873caef92adf33c4e35bd491b8bd238de864", "filename": "gcc/unroll.c", "status": "modified", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f5da5c8714390bc8571d7f3fb6acf956920d0f19/gcc%2Funroll.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f5da5c8714390bc8571d7f3fb6acf956920d0f19/gcc%2Funroll.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Funroll.c?ref=f5da5c8714390bc8571d7f3fb6acf956920d0f19", "patch": "@@ -354,6 +354,17 @@ unroll_loop (loop_end, insn_count, loop_start, end_insert_before,\n \t    delete_insn (prev);\n #endif\n \t}\n+\n+      /* Remove the loop notes since this is no longer a loop.  */\n+      if (loop_info->vtop)\n+\tdelete_insn (loop_info->vtop);\n+      if (loop_info->cont)\n+\tdelete_insn (loop_info->cont);\n+      if (loop_start)\n+\tdelete_insn (loop_start);\n+      if (loop_end)\n+\tdelete_insn (loop_end);\n+\n       return;\n     }\n   else if (loop_info->n_iterations > 0\n@@ -1282,6 +1293,19 @@ unroll_loop (loop_end, insn_count, loop_start, end_insert_before,\n     emit_label_after (exit_label, loop_end);\n \n  egress:\n+  if (unroll_type == UNROLL_COMPLETELY)\n+    {\n+      /* Remove the loop notes since this is no longer a loop.  */\n+      if (loop_info->vtop)\n+\tdelete_insn (loop_info->vtop);\n+      if (loop_info->cont)\n+\tdelete_insn (loop_info->cont);\n+      if (loop_start)\n+\tdelete_insn (loop_start);\n+      if (loop_end)\n+\tdelete_insn (loop_end);\n+    }\n+\n   if (map->const_equiv_varray)\n     VARRAY_FREE (map->const_equiv_varray);\n   if (map->label_map)"}]}