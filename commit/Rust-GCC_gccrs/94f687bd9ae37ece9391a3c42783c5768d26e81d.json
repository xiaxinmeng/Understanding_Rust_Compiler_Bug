{"sha": "94f687bd9ae37ece9391a3c42783c5768d26e81d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTRmNjg3YmQ5YWUzN2VjZTkzOTFhM2M0Mjc4M2M1NzY4ZDI2ZTgxZA==", "commit": {"author": {"name": "Uros Bizjak", "email": "ubizjak@gmail.com", "date": "2020-05-18T15:25:39Z"}, "committer": {"name": "Uros Bizjak", "email": "ubizjak@gmail.com", "date": "2020-05-18T15:25:39Z"}, "message": "i386: Improve vector mode and TFmode ABS and NEG patterns\n\ngcc/ChangeLog:\n\n2020-05-18  Uro\u0161 Bizjak  <ubizjak@gmail.com>\n\n\t* config/i386/i386-expand.c (ix86_expand_fp_absneg_operator):\n\tDo not emit FLAGS_REG clobber for TFmode.\n\t* config/i386/i386.md (*<code>tf2_1): Rewrite as\n\tdefine_insn_and_split.  Mark operands 1 and 2 commutative.\n\t(*nabstf2_1): Ditto.\n\t(absneg SSE splitter): Use MODEF mode iterator instead of SSEMODEF.\n\tDo not swap memory operands.  Simplify RTX generation.\n\t(neg abs SSE splitter): Ditto.\n\t* config/i386/sse.md (*<code><mode>2): Mark operands 1 and 2\n\tcommutative.  Do not swap operands.  Simplify RTX generation.\n\t(*nabs<mode>2): Ditto.", "tree": {"sha": "42209d4d1b062a500ce4c4dcfd76ef4e2b836f6f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/42209d4d1b062a500ce4c4dcfd76ef4e2b836f6f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/94f687bd9ae37ece9391a3c42783c5768d26e81d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/94f687bd9ae37ece9391a3c42783c5768d26e81d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/94f687bd9ae37ece9391a3c42783c5768d26e81d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/94f687bd9ae37ece9391a3c42783c5768d26e81d/comments", "author": {"login": "ubizjak", "id": 55479990, "node_id": "MDQ6VXNlcjU1NDc5OTkw", "avatar_url": "https://avatars.githubusercontent.com/u/55479990?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ubizjak", "html_url": "https://github.com/ubizjak", "followers_url": "https://api.github.com/users/ubizjak/followers", "following_url": "https://api.github.com/users/ubizjak/following{/other_user}", "gists_url": "https://api.github.com/users/ubizjak/gists{/gist_id}", "starred_url": "https://api.github.com/users/ubizjak/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ubizjak/subscriptions", "organizations_url": "https://api.github.com/users/ubizjak/orgs", "repos_url": "https://api.github.com/users/ubizjak/repos", "events_url": "https://api.github.com/users/ubizjak/events{/privacy}", "received_events_url": "https://api.github.com/users/ubizjak/received_events", "type": "User", "site_admin": false}, "committer": {"login": "ubizjak", "id": 55479990, "node_id": "MDQ6VXNlcjU1NDc5OTkw", "avatar_url": "https://avatars.githubusercontent.com/u/55479990?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ubizjak", "html_url": "https://github.com/ubizjak", "followers_url": "https://api.github.com/users/ubizjak/followers", "following_url": "https://api.github.com/users/ubizjak/following{/other_user}", "gists_url": "https://api.github.com/users/ubizjak/gists{/gist_id}", "starred_url": "https://api.github.com/users/ubizjak/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ubizjak/subscriptions", "organizations_url": "https://api.github.com/users/ubizjak/orgs", "repos_url": "https://api.github.com/users/ubizjak/repos", "events_url": "https://api.github.com/users/ubizjak/events{/privacy}", "received_events_url": "https://api.github.com/users/ubizjak/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "cfaf0edbb123958e84d296354152294f167db9f3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cfaf0edbb123958e84d296354152294f167db9f3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cfaf0edbb123958e84d296354152294f167db9f3"}], "stats": {"total": 192, "additions": 80, "deletions": 112}, "files": [{"sha": "580b3cda64cd1bef40fa5513488243f6962e3cc9", "filename": "gcc/ChangeLog", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94f687bd9ae37ece9391a3c42783c5768d26e81d/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94f687bd9ae37ece9391a3c42783c5768d26e81d/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=94f687bd9ae37ece9391a3c42783c5768d26e81d", "patch": "@@ -1,3 +1,17 @@\n+2020-05-18  Uro\u0161 Bizjak  <ubizjak@gmail.com>\n+\n+\t* config/i386/i386-expand.c (ix86_expand_fp_absneg_operator):\n+\tDo not emit FLAGS_REG clobber for TFmode.\n+\t* config/i386/i386.md (*<code>tf2_1): Rewrite as\n+\tdefine_insn_and_split.  Mark operands 1 and 2 commutative.\n+\t(*nabstf2_1): Ditto.\n+\t(absneg SSE splitter): Use MODEF mode iterator instead of SSEMODEF.\n+\tDo not swap memory operands.  Simplify RTX generation.\n+\t(neg abs SSE splitter): Ditto.\n+\t* config/i386/sse.md (*<code><mode>2): Mark operands 1 and 2\n+\tcommutative.  Do not swap operands.  Simplify RTX generation.\n+\t(*nabs<mode>2): Ditto.\n+\n 2020-05-18  Richard Biener  <rguenther@suse.de>\n \n \t* tree-vect-slp.c (vect_slp_bb): Start after labels."}, {"sha": "2865cced66cda96a872aee9e008b2346e1a22f96", "filename": "gcc/config/i386/i386-expand.c", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94f687bd9ae37ece9391a3c42783c5768d26e81d/gcc%2Fconfig%2Fi386%2Fi386-expand.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94f687bd9ae37ece9391a3c42783c5768d26e81d/gcc%2Fconfig%2Fi386%2Fi386-expand.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386-expand.c?ref=94f687bd9ae37ece9391a3c42783c5768d26e81d", "patch": "@@ -1716,9 +1716,7 @@ ix86_expand_fp_absneg_operator (enum rtx_code code, machine_mode mode,\n   machine_mode vmode = mode;\n   rtvec par;\n \n-  if (vector_mode)\n-    use_sse = true;\n-  else if (mode == TFmode)\n+  if (vector_mode || mode == TFmode)\n     use_sse = true;\n   else if (TARGET_SSE_MATH)\n     {\n@@ -1743,7 +1741,7 @@ ix86_expand_fp_absneg_operator (enum rtx_code code, machine_mode mode,\n \t Create the appropriate mask now.  */\n       mask = ix86_build_signbit_mask (vmode, vector_mode, code == ABS);\n       use = gen_rtx_USE (VOIDmode, mask);\n-      if (vector_mode)\n+      if (vector_mode || mode == TFmode)\n \tpar = gen_rtvec (2, set, use);\n       else\n \t{"}, {"sha": "aa4f25b7065cc2f3f04f48c71c82b52030732e73", "filename": "gcc/config/i386/i386.md", "status": "modified", "additions": 50, "deletions": 66, "changes": 116, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94f687bd9ae37ece9391a3c42783c5768d26e81d/gcc%2Fconfig%2Fi386%2Fi386.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94f687bd9ae37ece9391a3c42783c5768d26e81d/gcc%2Fconfig%2Fi386%2Fi386.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.md?ref=94f687bd9ae37ece9391a3c42783c5768d26e81d", "patch": "@@ -10005,32 +10005,6 @@\n   [(set_attr \"type\" \"negnot\")\n    (set_attr \"mode\" \"<MODE>\")])\n \n-(define_expand \"<code>tf2\"\n-  [(set (match_operand:TF 0 \"register_operand\")\n-\t(absneg:TF (match_operand:TF 1 \"register_operand\")))]\n-  \"TARGET_SSE\"\n-  \"ix86_expand_fp_absneg_operator (<CODE>, TFmode, operands); DONE;\")\n-\n-(define_insn \"*<code>tf2_1\"\n-  [(set (match_operand:TF 0 \"register_operand\" \"=x,x,Yv,Yv\")\n-\t(absneg:TF\n-\t  (match_operand:TF 1 \"vector_operand\" \"0,xBm,Yv,m\")))\n-   (use (match_operand:TF 2 \"vector_operand\" \"xBm,0,Yvm,Yv\"))\n-   (clobber (reg:CC FLAGS_REG))]\n-  \"TARGET_SSE\"\n-  \"#\"\n-  [(set_attr \"isa\" \"noavx,noavx,avx,avx\")])\n-\n-(define_insn \"*nabstf2_1\"\n-  [(set (match_operand:TF 0 \"register_operand\" \"=x,x,Yv,Yv\")\n-\t(neg:TF\n-\t  (abs:TF\n-\t    (match_operand:TF 1 \"vector_operand\" \"0,xBm,Yv,m\"))))\n-   (use (match_operand:TF 2 \"vector_operand\" \"xBm,0,Yvm,Yv\"))]\n-  \"TARGET_SSE\"\n-  \"#\"\n-  [(set_attr \"isa\" \"noavx,noavx,avx,avx\")])\n-\n ;; Special expand pattern to handle integer mode abs\n \n (define_expand \"abs<mode>2\"\n@@ -10056,6 +10030,39 @@\n     DONE;\n   })\n \n+(define_expand \"<code>tf2\"\n+  [(set (match_operand:TF 0 \"register_operand\")\n+\t(absneg:TF (match_operand:TF 1 \"register_operand\")))]\n+  \"TARGET_SSE\"\n+  \"ix86_expand_fp_absneg_operator (<CODE>, TFmode, operands); DONE;\")\n+\n+(define_insn_and_split \"*<code>tf2_1\"\n+  [(set (match_operand:TF 0 \"register_operand\" \"=x,Yv\")\n+\t(absneg:TF\n+\t  (match_operand:TF 1 \"vector_operand\" \"%0,Yv\")))\n+   (use (match_operand:TF 2 \"vector_operand\" \"xBm,Yvm\"))]\n+  \"TARGET_SSE\"\n+  \"#\"\n+  \"&& reload_completed\"\n+  [(set (match_dup 0)\n+\t(<absneg_op>:TF (match_dup 1) (match_dup 2)))]\n+  \"\"\n+  [(set_attr \"isa\" \"noavx,avx\")])\n+\n+(define_insn_and_split \"*nabstf2_1\"\n+  [(set (match_operand:TF 0 \"register_operand\" \"=x,Yv\")\n+\t(neg:TF\n+\t  (abs:TF\n+\t    (match_operand:TF 1 \"vector_operand\" \"%0,Yv\"))))\n+   (use (match_operand:TF 2 \"vector_operand\" \"xBm,Yvm\"))]\n+  \"TARGET_SSE\"\n+  \"#\"\n+  \"&& reload_completed\"\n+  [(set (match_dup 0)\n+\t(ior:TF (match_dup 1) (match_dup 2)))]\n+  \"\"\n+  [(set_attr \"isa\" \"noavx,avx\")])\n+\n (define_expand \"<code><mode>2\"\n   [(set (match_operand:X87MODEF 0 \"register_operand\")\n \t(absneg:X87MODEF (match_operand:X87MODEF 1 \"register_operand\")))]\n@@ -10108,36 +10115,24 @@\n \t (symbol_ref \"false\"))))])\n \n (define_split\n-  [(set (match_operand:SSEMODEF 0 \"sse_reg_operand\")\n-\t(absneg:SSEMODEF\n-\t  (match_operand:SSEMODEF 1 \"vector_operand\")))\n+  [(set (match_operand:MODEF 0 \"sse_reg_operand\")\n+\t(absneg:MODEF\n+\t  (match_operand:MODEF 1 \"vector_operand\")))\n    (use (match_operand:<ssevecmodef> 2 \"vector_operand\"))\n    (clobber (reg:CC FLAGS_REG))]\n-  \"((SSE_FLOAT_MODE_P (<MODE>mode) && TARGET_SSE_MATH)\n-    || (TARGET_SSE && (<MODE>mode == TFmode)))\n+  \"SSE_FLOAT_MODE_P (<MODE>mode) && TARGET_SSE_MATH\n    && reload_completed\"\n-  [(set (match_dup 0) (match_dup 3))]\n+  [(set (match_dup 0)\n+\t(<absneg_op>:<ssevecmodef> (match_dup 1) (match_dup 2)))]\n {\n   machine_mode mode = <MODE>mode;\n   machine_mode vmode = <ssevecmodef>mode;\n-  enum rtx_code absneg_op = <CODE> == ABS ? AND : XOR;\n \n   operands[0] = lowpart_subreg (vmode, operands[0], mode);\n   operands[1] = lowpart_subreg (vmode, operands[1], mode);\n \n-  if (TARGET_AVX)\n-    {\n-      if (MEM_P (operands[1]))\n-        std::swap (operands[1], operands[2]);\n-    }\n-  else\n-   {\n-     if (operands_match_p (operands[0], operands[2]))\n-       std::swap (operands[1], operands[2]);\n-   }\n-\n-  operands[3]\n-    = gen_rtx_fmt_ee (absneg_op, vmode, operands[1], operands[2]);\n+  if (!TARGET_AVX && operands_match_p (operands[0], operands[2]))\n+    std::swap (operands[1], operands[2]);\n })\n \n (define_split\n@@ -10168,35 +10163,24 @@\n   [(set_attr \"isa\" \"noavx,noavx,avx\")])\n \n (define_split\n-  [(set (match_operand:SSEMODEF 0 \"sse_reg_operand\")\n-\t(neg:SSEMODEF\n-\t  (abs:SSEMODEF\n-\t    (match_operand:SSEMODEF 1 \"vector_operand\"))))\n+  [(set (match_operand:MODEF 0 \"sse_reg_operand\")\n+\t(neg:MODEF\n+\t  (abs:MODEF\n+\t    (match_operand:MODEF 1 \"vector_operand\"))))\n    (use (match_operand:<ssevecmodef> 2 \"vector_operand\"))]\n-  \"((SSE_FLOAT_MODE_P (<MODE>mode) && TARGET_SSE_MATH)\n-    || (TARGET_SSE && (<MODE>mode == TFmode)))\n+  \"SSE_FLOAT_MODE_P (<MODE>mode) && TARGET_SSE_MATH\n    && reload_completed\"\n-  [(set (match_dup 0) (match_dup 3))]\n+  [(set (match_dup 0)\n+\t(ior:<ssevecmodef> (match_dup 1) (match_dup 2)))]\n {\n   machine_mode mode = <MODE>mode;\n   machine_mode vmode = <ssevecmodef>mode;\n \n   operands[0] = lowpart_subreg (vmode, operands[0], mode);\n   operands[1] = lowpart_subreg (vmode, operands[1], mode);\n \n-  if (TARGET_AVX)\n-    {\n-      if (MEM_P (operands[1]))\n-        std::swap (operands[1], operands[2]);\n-    }\n-  else\n-   {\n-     if (operands_match_p (operands[0], operands[2]))\n-       std::swap (operands[1], operands[2]);\n-   }\n-\n-  operands[3]\n-    = gen_rtx_fmt_ee (IOR, vmode, operands[1], operands[2]);\n+  if (!TARGET_AVX && operands_match_p (operands[0], operands[2]))\n+    std::swap (operands[1], operands[2]);\n })\n \n ;; Conditionalize these after reload. If they match before reload, we"}, {"sha": "153982c9f12d5988e41bca652024cbace011fe07", "filename": "gcc/config/i386/sse.md", "status": "modified", "additions": 14, "deletions": 42, "changes": 56, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94f687bd9ae37ece9391a3c42783c5768d26e81d/gcc%2Fconfig%2Fi386%2Fsse.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94f687bd9ae37ece9391a3c42783c5768d26e81d/gcc%2Fconfig%2Fi386%2Fsse.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fsse.md?ref=94f687bd9ae37ece9391a3c42783c5768d26e81d", "patch": "@@ -1638,59 +1638,31 @@\n   \"ix86_expand_fp_absneg_operator (<CODE>, <MODE>mode, operands); DONE;\")\n \n (define_insn_and_split \"*<code><mode>2\"\n-  [(set (match_operand:VF 0 \"register_operand\" \"=x,x,v,v\")\n+  [(set (match_operand:VF 0 \"register_operand\" \"=x,v\")\n \t(absneg:VF\n-\t  (match_operand:VF 1 \"vector_operand\" \"0,  xBm,v, m\")))\n-   (use (match_operand:VF 2 \"vector_operand\"    \"xBm,0,  vm,v\"))]\n+\t  (match_operand:VF 1 \"vector_operand\" \"%0,v\")))\n+   (use (match_operand:VF 2 \"vector_operand\" \"xBm,vm\"))]\n   \"TARGET_SSE\"\n   \"#\"\n   \"&& reload_completed\"\n-  [(set (match_dup 0) (match_dup 3))]\n-{\n-  enum rtx_code absneg_op = <CODE> == ABS ? AND : XOR;\n-\n-  if (TARGET_AVX)\n-    {\n-      if (MEM_P (operands[1]))\n-        std::swap (operands[1], operands[2]);\n-    }\n-  else\n-   {\n-     if (operands_match_p (operands[0], operands[2]))\n-       std::swap (operands[1], operands[2]);\n-   }\n-\n-  operands[3]\n-    = gen_rtx_fmt_ee (absneg_op, <MODE>mode, operands[1], operands[2]);\n-}\n-  [(set_attr \"isa\" \"noavx,noavx,avx,avx\")])\n+  [(set (match_dup 0)\n+\t(<absneg_op>:VF (match_dup 1) (match_dup 2)))]\n+  \"\"\n+  [(set_attr \"isa\" \"noavx,avx\")])\n \n (define_insn_and_split \"*nabs<mode>2\"\n-  [(set (match_operand:VF 0 \"register_operand\" \"=x,x,v,v\")\n+  [(set (match_operand:VF 0 \"register_operand\" \"=x,v\")\n \t(neg:VF\n \t  (abs:VF\n-\t    (match_operand:VF 1 \"vector_operand\" \"0,xBm,v,m\"))))\n-   (use (match_operand:VF 2 \"vector_operand\"    \"xBm,0,vm,v\"))]\n+\t    (match_operand:VF 1 \"vector_operand\" \"%0,v\"))))\n+   (use (match_operand:VF 2 \"vector_operand\" \"xBm,vm\"))]\n   \"TARGET_SSE\"\n   \"#\"\n   \"&& reload_completed\"\n-  [(set (match_dup 0) (match_dup 3))]\n-{\n-  if (TARGET_AVX)\n-    {\n-      if (MEM_P (operands[1]))\n-        std::swap (operands[1], operands[2]);\n-    }\n-  else\n-   {\n-     if (operands_match_p (operands[0], operands[2]))\n-       std::swap (operands[1], operands[2]);\n-   }\n-\n-  operands[3]\n-    = gen_rtx_fmt_ee (IOR, <MODE>mode, operands[1], operands[2]);\n-}\n-  [(set_attr \"isa\" \"noavx,noavx,avx,avx\")])\n+  [(set (match_dup 0)\n+\t(ior:VF (match_dup 1) (match_dup 2)))]\n+  \"\"\n+  [(set_attr \"isa\" \"noavx,avx\")])\n \n (define_expand \"<plusminus_insn><mode>3<mask_name><round_name>\"\n   [(set (match_operand:VF 0 \"register_operand\")"}]}