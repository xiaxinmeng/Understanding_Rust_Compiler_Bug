{"sha": "24d304eb56b89020178b2e20df89a7d13131cc07", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MjRkMzA0ZWI1NmI4OTAyMDE3OGIyZTIwZGY4OWE3ZDEzMTMxY2MwNw==", "commit": {"author": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1995-09-11T23:20:44Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1995-09-11T23:20:44Z"}, "message": "(output_option{,s}): New functions to write -f, -m, and -W options to the asm file.\n\n(output_option{,s}): New functions to write -f, -m, and -W options to the\nasm file.\n(rs6000_float_const): New function to generate floating point constants\nportably used in signed,unsigned -> double conversions.\n(rs6000_stack_info,debug_stack_info): Use ABI enumeration instead\nof AIX vs. V.4 boolean.\n\nFrom-SVN: r10317", "tree": {"sha": "72fed10b6b9697f80e5f1f2be94cf4684ef11913", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/72fed10b6b9697f80e5f1f2be94cf4684ef11913"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/24d304eb56b89020178b2e20df89a7d13131cc07", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/24d304eb56b89020178b2e20df89a7d13131cc07", "html_url": "https://github.com/Rust-GCC/gccrs/commit/24d304eb56b89020178b2e20df89a7d13131cc07", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/24d304eb56b89020178b2e20df89a7d13131cc07/comments", "author": null, "committer": null, "parents": [{"sha": "6b67933e965d074b68c38e0abab68f310fc646f0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6b67933e965d074b68c38e0abab68f310fc646f0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6b67933e965d074b68c38e0abab68f310fc646f0"}], "stats": {"total": 149, "additions": 135, "deletions": 14}, "files": [{"sha": "9abfef12b0dbde8722f0ba27b3b2fa4f98c02d91", "filename": "gcc/config/rs6000/rs6000.c", "status": "modified", "additions": 135, "deletions": 14, "changes": 149, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/24d304eb56b89020178b2e20df89a7d13131cc07/gcc%2Fconfig%2Frs6000%2Frs6000.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/24d304eb56b89020178b2e20df89a7d13131cc07/gcc%2Fconfig%2Frs6000%2Frs6000.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.c?ref=24d304eb56b89020178b2e20df89a7d13131cc07", "patch": "@@ -73,6 +73,100 @@ int rs6000_pic_labelno;\n \n /* Whether a System V.4 varargs area was created.  */\n int rs6000_sysv_varargs_p;\n+\f\n+/* Print the options used in the assembly file.  */\n+\n+extern char *version_string, *language_string;\n+\n+struct option\n+{\n+  char *string;\n+  int *variable;\n+  int on_value;\n+};\n+\n+#define MAX_LINE 79\n+\n+static int\n+output_option (file, type, name, pos)\n+     FILE *file;\n+     char *type;\n+     char *name;\n+     int pos;\n+{\n+  int type_len = strlen (type);\n+  int name_len = strlen (name);\n+\n+  if (1 + type_len + name_len + pos > MAX_LINE)\n+    {\n+      fprintf (file, \"\\n # %s%s\", type, name);\n+      return 3 + type_len + name_len;\n+    }\n+  fprintf (file, \" %s%s\", type, name);\n+  return pos + 1 + type_len + name_len;\n+}\n+\n+static struct { char *name; int value; } m_options[] = TARGET_SWITCHES;\n+\n+void\n+output_options (file, f_options, f_len, W_options, W_len)\n+     FILE *file;\n+     struct option *f_options;\n+     int f_len;\n+     struct option *W_options;\n+     int W_len;\n+{\n+  int j;\n+  int flags = target_flags;\n+  int pos = 32767;\n+\n+  fprintf (file, \" # %s %s\", language_string, version_string);\n+\n+  if (optimize)\n+    {\n+      char opt_string[20];\n+      sprintf (opt_string, \"%d\", optimize);\n+      pos = output_option (file, \"-O\", opt_string, pos);\n+    }\n+\n+  if (profile_flag)\n+    pos = output_option (file, \"-p\", \"\", pos);\n+\n+  if (profile_block_flag)\n+    pos = output_option (file, \"-a\", \"\", pos);\n+\n+  if (inhibit_warnings)\n+    pos = output_option (file, \"-w\", \"\", pos);\n+\n+  for (j = 0; j < f_len; j++)\n+    {\n+      if (*f_options[j].variable == f_options[j].on_value)\n+\tpos = output_option (file, \"-f\", f_options[j].string, pos);\n+    }\n+\n+  for (j = 0; j < W_len; j++)\n+    {\n+      if (*W_options[j].variable == W_options[j].on_value)\n+\tpos = output_option (file, \"-W\", W_options[j].string, pos);\n+    }\n+\n+  for (j = 0; j < sizeof m_options / sizeof m_options[0]; j++)\n+    {\n+      if (m_options[j].name[0] != '\\0'\n+\t  && m_options[j].value > 0\n+\t  && ((m_options[j].value & flags) == m_options[j].value))\n+\t{\n+\t  pos = output_option (file, \"-m\", m_options[j].name, pos);\n+\t  flags &= ~ m_options[j].value;\n+\t}\n+    }\n+\n+  if (rs6000_cpu_string != (char *)0)\n+    pos = output_option (file, \"-mcpu=\", rs6000_cpu_string, pos);\n+\n+  fputs (\"\\n\\n\", file);\n+}\n+\n \f\n /* Override command line options.  Mostly we process the processor\n    type and sometimes adjust other TARGET_ options.  */\n@@ -194,6 +288,18 @@ rs6000_override_options ()\n   SUBTARGET_OVERRIDE_OPTIONS;\n #endif\n }\n+\f\n+/* Create a CONST_DOUBLE from a string.  */\n+\n+struct rtx_def *\n+rs6000_float_const (string, mode)\n+     char *string;\n+     enum machine_mode mode;\n+{\n+  REAL_VALUE_TYPE value = REAL_VALUE_ATOF (string, mode);\n+  return immed_real_const_1 (value, mode);\n+}\n+\n \f\n /* Create a CONST_DOUBLE like immed_double_const, except reverse the\n    two parts of the constant if the target is little endian.  */\n@@ -2193,16 +2299,20 @@ rs6000_stack_info ()\n   static rs6000_stack_t info, zero_info;\n   rs6000_stack_t *info_ptr = &info;\n   int reg_size = TARGET_64BIT ? 8 : 4;\n-  int v4_call_p = 0;\n+  enum rs6000_abi abi;\n \n   /* Zero all fields portably */\n   info = zero_info;\n \n   /* Select which calling sequence */\n #ifdef TARGET_V4_CALLS\n   if (TARGET_V4_CALLS)\n-    info_ptr->v4_call_p = v4_call_p = 1;\n+    abi = ABI_V4;\n+  else\n #endif\n+    abi = ABI_AIX;\n+\n+  info_ptr->abi = abi;\n \n   /* Calculate which registers need to be saved & save area size */\n   info_ptr->first_gp_reg_save = first_reg_to_save ();\n@@ -2221,7 +2331,7 @@ rs6000_stack_info ()\n #endif\n       || (info_ptr->first_fp_reg_save != 64\n \t  && !FP_SAVE_INLINE (info_ptr->first_fp_reg_save))\n-      || (v4_call_p && current_function_calls_alloca)\n+      || (abi == ABI_V4 && current_function_calls_alloca)\n       || info_ptr->calls_p)\n     {\n       info_ptr->lr_save_p = 1;\n@@ -2232,7 +2342,7 @@ rs6000_stack_info ()\n   if (regs_ever_live[70] || regs_ever_live[71] || regs_ever_live[72])\n     {\n       info_ptr->cr_save_p = 1;\n-      if (v4_call_p)\n+      if (abi == ABI_V4)\n \tinfo_ptr->cr_size = reg_size;\n     }\n \n@@ -2260,7 +2370,7 @@ rs6000_stack_info ()\n   if (info_ptr->calls_p)\n     info_ptr->push_p = 1;\n \n-  else if (v4_call_p)\n+  else if (abi == ABI_V4)\n     info_ptr->push_p = (info_ptr->total_size > info_ptr->fixed_size\n \t\t\t|| info_ptr->lr_save_p);\n \n@@ -2272,15 +2382,17 @@ rs6000_stack_info ()\n   /* Calculate the offsets */\n   info_ptr->fp_save_offset = - info_ptr->fp_size;\n   info_ptr->gp_save_offset = info_ptr->fp_save_offset - info_ptr->gp_size;\n-  if (v4_call_p)\n-    {\n-      info_ptr->cr_save_offset = info_ptr->gp_save_offset - reg_size;\n-      info_ptr->lr_save_offset = reg_size;\n-    }\n-  else\n+  switch (abi)\n     {\n+    default:\n       info_ptr->cr_save_offset = 4;\n       info_ptr->lr_save_offset = 8;\n+      break;\n+\n+    case ABI_V4:\n+      info_ptr->cr_save_offset = info_ptr->gp_save_offset - reg_size;\n+      info_ptr->lr_save_offset = reg_size;\n+      break;\n     }\n \n   /* Zero offsets if we're not saving those registers */\n@@ -2303,6 +2415,8 @@ void\n debug_stack_info (info)\n      rs6000_stack_t *info;\n {\n+  char *abi_string;\n+\n   if (!info)\n     info = rs6000_stack_info ();\n \n@@ -2311,6 +2425,16 @@ debug_stack_info (info)\n \t    ? IDENTIFIER_POINTER (DECL_NAME (current_function_decl))\n \t    : \"<unknown>\"));\n \n+  switch (info->abi)\n+    {\n+    default:\t   abi_string = \"Unknown\";\tbreak;\n+    case ABI_NONE: abi_string = \"NONE\";\t\tbreak;\n+    case ABI_AIX:  abi_string = \"AIX\";\t\tbreak;\n+    case ABI_V4:   abi_string = \"V.4\";\t\tbreak;\n+    }\n+\n+  fprintf (stderr, \"\\tABI                 = %5s\\n\", abi_string);\n+\n   if (info->first_gp_reg_save != 32)\n     fprintf (stderr, \"\\tfirst_gp_reg_save   = %5d\\n\", info->first_gp_reg_save);\n \n@@ -2329,9 +2453,6 @@ debug_stack_info (info)\n   if (info->calls_p)\n     fprintf (stderr, \"\\tcalls_p             = %5d\\n\", info->calls_p);\n \n-  if (info->v4_call_p)\n-    fprintf (stderr, \"\\tv4_call_p           = %5d\\n\", info->v4_call_p);\n-\n   if (info->gp_save_offset)\n     fprintf (stderr, \"\\tgp_save_offset      = %5d\\n\", info->gp_save_offset);\n "}]}