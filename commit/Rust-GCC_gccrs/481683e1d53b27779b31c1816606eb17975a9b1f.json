{"sha": "481683e1d53b27779b31c1816606eb17975a9b1f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDgxNjgzZTFkNTNiMjc3NzliMzFjMTgxNjYwNmViMTc5NzVhOWIxZg==", "commit": {"author": {"name": "Shujing Zhao", "email": "pearly.zhao@oracle.com", "date": "2009-06-22T10:29:13Z"}, "committer": {"name": "Paolo Carlini", "email": "paolo@gcc.gnu.org", "date": "2009-06-22T10:29:13Z"}, "message": "alias.c: Use REG_P...\n\n2009-06-22  Shujing Zhao  <pearly.zhao@oracle.com>\n\n\t* alias.c: Use REG_P, MEM_P, CONST_INT_P, LABEL_P, CALL_P, NOTE_P and\n\tJUMP_TABLE_DATA_P predicates where applicable.\n\t* auto-inc-dec.c: Ditto.\n\t* builtins.c: Ditto.\n\t* caller-save.c: Ditto.\n\t* calls.c: Ditto.\n\t* cfgcleanup.c: Ditto.\n\t* cfglayout.c: Ditto.\n\t* cfgrtl.c: Ditto.\n\t* combine.c: Ditto.\n\t* combine-stack-adj.c: Ditto.\n\t* cse.c: Ditto.\n\t* cselib.c: Ditto.\n\t* dbxout.c: Ditto.\n\t* df-scan.c: Ditto.\n\t* dse.c: Ditto.\n\t* dwarf2asm.c: Ditto.\n\t* dwarf2out.c: Ditto.\n\t* emit-rtl.c: Ditto.\n\t* except.c: Ditto.\n\t* explow.c: Ditto.\n\t* expmed.c: Ditto.\n\t* expr.c: Ditto.\n\t* final.c: Ditto.\n\t* function.c: Ditto.\n\t* fwprop.c: Ditto.\n\t* gcse.c: Ditto.\n\t* genpreds.c: Ditto.\n\t* genrecog.c: Ditto.\n\t* ifcvt.c: Ditto.\n\t* ira-costs.c: Ditto.\n\t* ira-lives.c: Ditto.\n\t* jump.c: Ditto.\n\t* loop-iv.c: Ditto.\n\t* lower-subreg.c: Ditto.\n\t* modulo-sched.c: Ditto.\n\t* optabs.c: Ditto.\n\t* postreload.c: Ditto.\n\t* print-rtl.c: Ditto.\n\t* recog.c: Ditto.\n\t* reginfo.c: Ditto.\n\t* regmove.c: Ditto.\n\t* reload1.c: Ditto.\n\t* reload.c: Ditto.\n\t* reorg.c: Ditto.\n\t* rtlanal.c: Ditto.\n\t* rtl.c: Ditto.\n\t* sched-vis.c: Ditto.\n\t* sdbout.c: Ditto.\n\t* sel-sched-ir.c: Ditto.\n\t* simplify-rtx.c: Ditto.\n\t* targhooks.c: Ditto.\n\t* var-tracking.c: Ditto.\n\t* vmsdbgout.c: Ditto.\n\nFrom-SVN: r148786", "tree": {"sha": "11fcb232ab948e07b794c4b08b2ffbb2030069f7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/11fcb232ab948e07b794c4b08b2ffbb2030069f7"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/481683e1d53b27779b31c1816606eb17975a9b1f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/481683e1d53b27779b31c1816606eb17975a9b1f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/481683e1d53b27779b31c1816606eb17975a9b1f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/481683e1d53b27779b31c1816606eb17975a9b1f/comments", "author": null, "committer": null, "parents": [{"sha": "eee37e909a5c74641d08eff71739ca9e089861f4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/eee37e909a5c74641d08eff71739ca9e089861f4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/eee37e909a5c74641d08eff71739ca9e089861f4"}], "stats": {"total": 1168, "additions": 602, "deletions": 566}, "files": [{"sha": "07451871546c8b2fc0ea28019c16ca65530ed61a", "filename": "gcc/ChangeLog", "status": "modified", "additions": 57, "deletions": 0, "changes": 57, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/481683e1d53b27779b31c1816606eb17975a9b1f/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/481683e1d53b27779b31c1816606eb17975a9b1f/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=481683e1d53b27779b31c1816606eb17975a9b1f", "patch": "@@ -1,3 +1,60 @@\n+2009-06-22  Shujing Zhao  <pearly.zhao@oracle.com>\n+\n+\t* alias.c: Use REG_P, MEM_P, CONST_INT_P, LABEL_P, CALL_P, NOTE_P and\n+\tJUMP_TABLE_DATA_P predicates where applicable.\n+\t* auto-inc-dec.c: Ditto.\n+\t* builtins.c: Ditto.\n+\t* caller-save.c: Ditto.\n+\t* calls.c: Ditto.\n+\t* cfgcleanup.c: Ditto.\n+\t* cfglayout.c: Ditto.\n+\t* cfgrtl.c: Ditto.\n+\t* combine.c: Ditto.\n+\t* combine-stack-adj.c: Ditto.\n+\t* cse.c: Ditto.\n+\t* cselib.c: Ditto.\n+\t* dbxout.c: Ditto.\n+\t* df-scan.c: Ditto.\n+\t* dse.c: Ditto.\n+\t* dwarf2asm.c: Ditto.\n+\t* dwarf2out.c: Ditto.\n+\t* emit-rtl.c: Ditto.\n+\t* except.c: Ditto.\n+\t* explow.c: Ditto.\n+\t* expmed.c: Ditto.\n+\t* expr.c: Ditto.\n+\t* final.c: Ditto.\n+\t* function.c: Ditto.\n+\t* fwprop.c: Ditto.\n+\t* gcse.c: Ditto.\n+\t* genpreds.c: Ditto.\n+\t* genrecog.c: Ditto.\n+\t* ifcvt.c: Ditto.\n+\t* ira-costs.c: Ditto.\n+\t* ira-lives.c: Ditto.\n+\t* jump.c: Ditto.\n+\t* loop-iv.c: Ditto.\n+\t* lower-subreg.c: Ditto.\n+\t* modulo-sched.c: Ditto.\n+\t* optabs.c: Ditto.\n+\t* postreload.c: Ditto.\n+\t* print-rtl.c: Ditto.\n+\t* recog.c: Ditto.\n+\t* reginfo.c: Ditto.\n+\t* regmove.c: Ditto.\n+\t* reload1.c: Ditto.\n+\t* reload.c: Ditto.\n+\t* reorg.c: Ditto.\n+\t* rtlanal.c: Ditto.\n+\t* rtl.c: Ditto.\n+\t* sched-vis.c: Ditto.\n+\t* sdbout.c: Ditto.\n+\t* sel-sched-ir.c: Ditto.\n+\t* simplify-rtx.c: Ditto.\n+\t* targhooks.c: Ditto.\n+\t* var-tracking.c: Ditto.\n+\t* vmsdbgout.c: Ditto.\n+\n 2009-06-22  Matthias Klose  <doko@ubuntu.com>\n \n \t* Makefile.in (install-plugin): Always use DESTDIR."}, {"sha": "7d9faf2c9206d79c2478fe28463e997b4ddb778c", "filename": "gcc/alias.c", "status": "modified", "additions": 21, "deletions": 21, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/481683e1d53b27779b31c1816606eb17975a9b1f/gcc%2Falias.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/481683e1d53b27779b31c1816606eb17975a9b1f/gcc%2Falias.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Falias.c?ref=481683e1d53b27779b31c1816606eb17975a9b1f", "patch": "@@ -1018,9 +1018,9 @@ find_base_value (rtx src)\n \t/* Guess which operand is the base address:\n \t   If either operand is a symbol, then it is the base.  If\n \t   either operand is a CONST_INT, then the other is the base.  */\n-\tif (GET_CODE (src_1) == CONST_INT || CONSTANT_P (src_0))\n+\tif (CONST_INT_P (src_1) || CONSTANT_P (src_0))\n \t  return find_base_value (src_0);\n-\telse if (GET_CODE (src_0) == CONST_INT || CONSTANT_P (src_1))\n+\telse if (CONST_INT_P (src_0) || CONSTANT_P (src_1))\n \t  return find_base_value (src_1);\n \n \treturn 0;\n@@ -1034,7 +1034,7 @@ find_base_value (rtx src)\n     case AND:\n       /* If the second operand is constant set the base\n \t address to the first operand.  */\n-      if (GET_CODE (XEXP (src, 1)) == CONST_INT && INTVAL (XEXP (src, 1)) != 0)\n+      if (CONST_INT_P (XEXP (src, 1)) && INTVAL (XEXP (src, 1)) != 0)\n \treturn find_base_value (XEXP (src, 0));\n       return 0;\n \n@@ -1176,7 +1176,7 @@ record_set (rtx dest, const_rtx set, void *data ATTRIBUTE_UNUSED)\n \t  break;\n \t}\n       case AND:\n-\tif (XEXP (src, 0) != dest || GET_CODE (XEXP (src, 1)) != CONST_INT)\n+\tif (XEXP (src, 0) != dest || !CONST_INT_P (XEXP (src, 1)))\n \t  new_reg_base_value[regno] = 0;\n \tbreak;\n       default:\n@@ -1269,9 +1269,9 @@ canon_rtx (rtx x)\n \n       if (x0 != XEXP (x, 0) || x1 != XEXP (x, 1))\n \t{\n-\t  if (GET_CODE (x0) == CONST_INT)\n+\t  if (CONST_INT_P (x0))\n \t    return plus_constant (x1, INTVAL (x0));\n-\t  else if (GET_CODE (x1) == CONST_INT)\n+\t  else if (CONST_INT_P (x1))\n \t    return plus_constant (x0, INTVAL (x1));\n \t  return gen_rtx_PLUS (GET_MODE (x), x0, x1);\n \t}\n@@ -1553,7 +1553,7 @@ find_base_term (rtx x)\n       }\n \n     case AND:\n-      if (GET_CODE (XEXP (x, 1)) == CONST_INT && INTVAL (XEXP (x, 1)) != 0)\n+      if (CONST_INT_P (XEXP (x, 1)) && INTVAL (XEXP (x, 1)) != 0)\n \treturn find_base_term (XEXP (x, 0));\n       return 0;\n \n@@ -1616,11 +1616,11 @@ base_alias_check (rtx x, rtx y, enum machine_mode x_mode,\n   if (GET_CODE (x) == AND && GET_CODE (y) == AND)\n     return 1;\n   if (GET_CODE (x) == AND\n-      && (GET_CODE (XEXP (x, 1)) != CONST_INT\n+      && (!CONST_INT_P (XEXP (x, 1))\n \t  || (int) GET_MODE_UNIT_SIZE (y_mode) < -INTVAL (XEXP (x, 1))))\n     return 1;\n   if (GET_CODE (y) == AND\n-      && (GET_CODE (XEXP (y, 1)) != CONST_INT\n+      && (!CONST_INT_P (XEXP (y, 1))\n \t  || (int) GET_MODE_UNIT_SIZE (x_mode) < -INTVAL (XEXP (y, 1))))\n     return 1;\n \n@@ -1781,21 +1781,21 @@ memrefs_conflict_p (int xsize, rtx x, int ysize, rtx y, HOST_WIDE_INT c)\n \t    return memrefs_conflict_p (xsize, x0, ysize, y0, c);\n \t  if (rtx_equal_for_memref_p (x0, y0))\n \t    return memrefs_conflict_p (xsize, x1, ysize, y1, c);\n-\t  if (GET_CODE (x1) == CONST_INT)\n+\t  if (CONST_INT_P (x1))\n \t    {\n-\t      if (GET_CODE (y1) == CONST_INT)\n+\t      if (CONST_INT_P (y1))\n \t\treturn memrefs_conflict_p (xsize, x0, ysize, y0,\n \t\t\t\t\t   c - INTVAL (x1) + INTVAL (y1));\n \t      else\n \t\treturn memrefs_conflict_p (xsize, x0, ysize, y,\n \t\t\t\t\t   c - INTVAL (x1));\n \t    }\n-\t  else if (GET_CODE (y1) == CONST_INT)\n+\t  else if (CONST_INT_P (y1))\n \t    return memrefs_conflict_p (xsize, x, ysize, y0, c + INTVAL (y1));\n \n \t  return 1;\n \t}\n-      else if (GET_CODE (x1) == CONST_INT)\n+      else if (CONST_INT_P (x1))\n \treturn memrefs_conflict_p (xsize, x0, ysize, y, c - INTVAL (x1));\n     }\n   else if (GET_CODE (y) == PLUS)\n@@ -1805,7 +1805,7 @@ memrefs_conflict_p (int xsize, rtx x, int ysize, rtx y, HOST_WIDE_INT c)\n       rtx y0 = XEXP (y, 0);\n       rtx y1 = XEXP (y, 1);\n \n-      if (GET_CODE (y1) == CONST_INT)\n+      if (CONST_INT_P (y1))\n \treturn memrefs_conflict_p (xsize, x, ysize, y0, c + INTVAL (y1));\n       else\n \treturn 1;\n@@ -1831,7 +1831,7 @@ memrefs_conflict_p (int xsize, rtx x, int ysize, rtx y, HOST_WIDE_INT c)\n \t\t    || (c >= 0 && xsize > c) || (c < 0 && ysize+c > 0));\n \n \t  /* Can't properly adjust our sizes.  */\n-\t  if (GET_CODE (x1) != CONST_INT)\n+\t  if (!CONST_INT_P (x1))\n \t    return 1;\n \t  xsize /= INTVAL (x1);\n \t  ysize /= INTVAL (x1);\n@@ -1847,13 +1847,13 @@ memrefs_conflict_p (int xsize, rtx x, int ysize, rtx y, HOST_WIDE_INT c)\n      as an access with indeterminate size.  Assume that references\n      besides AND are aligned, so if the size of the other reference is\n      at least as large as the alignment, assume no other overlap.  */\n-  if (GET_CODE (x) == AND && GET_CODE (XEXP (x, 1)) == CONST_INT)\n+  if (GET_CODE (x) == AND && CONST_INT_P (XEXP (x, 1)))\n     {\n       if (GET_CODE (y) == AND || ysize < -INTVAL (XEXP (x, 1)))\n \txsize = -1;\n       return memrefs_conflict_p (xsize, canon_rtx (XEXP (x, 0)), ysize, y, c);\n     }\n-  if (GET_CODE (y) == AND && GET_CODE (XEXP (y, 1)) == CONST_INT)\n+  if (GET_CODE (y) == AND && CONST_INT_P (XEXP (y, 1)))\n     {\n       /* ??? If we are indexing far enough into the array/structure, we\n \t may yet be able to determine that we can not overlap.  But we\n@@ -1866,7 +1866,7 @@ memrefs_conflict_p (int xsize, rtx x, int ysize, rtx y, HOST_WIDE_INT c)\n \n   if (CONSTANT_P (x))\n     {\n-      if (GET_CODE (x) == CONST_INT && GET_CODE (y) == CONST_INT)\n+      if (CONST_INT_P (x) && CONST_INT_P (y))\n \t{\n \t  c += (INTVAL (y) - INTVAL (x));\n \t  return (xsize <= 0 || ysize <= 0\n@@ -2169,11 +2169,11 @@ nonoverlapping_memrefs_p (const_rtx x, const_rtx y)\n      we can avoid overlap is if we can deduce that they are nonoverlapping\n      pieces of that decl, which is very rare.  */\n   basex = MEM_P (rtlx) ? XEXP (rtlx, 0) : rtlx;\n-  if (GET_CODE (basex) == PLUS && GET_CODE (XEXP (basex, 1)) == CONST_INT)\n+  if (GET_CODE (basex) == PLUS && CONST_INT_P (XEXP (basex, 1)))\n     offsetx = INTVAL (XEXP (basex, 1)), basex = XEXP (basex, 0);\n \n   basey = MEM_P (rtly) ? XEXP (rtly, 0) : rtly;\n-  if (GET_CODE (basey) == PLUS && GET_CODE (XEXP (basey, 1)) == CONST_INT)\n+  if (GET_CODE (basey) == PLUS && CONST_INT_P (XEXP (basey, 1)))\n     offsety = INTVAL (XEXP (basey, 1)), basey = XEXP (basey, 0);\n \n   /* If the bases are different, we know they do not overlap if both\n@@ -2627,7 +2627,7 @@ init_alias_analysis (void)\n \t\t\t   && GET_CODE (src) == PLUS\n \t\t\t   && REG_P (XEXP (src, 0))\n \t\t\t   && (t = get_reg_known_value (REGNO (XEXP (src, 0))))\n-\t\t\t   && GET_CODE (XEXP (src, 1)) == CONST_INT)\n+\t\t\t   && CONST_INT_P (XEXP (src, 1)))\n \t\t    {\n \t\t      t = plus_constant (t, INTVAL (XEXP (src, 1)));\n \t\t      set_reg_known_value (regno, t);"}, {"sha": "1e6c564d0ab689864b7f7c65d4ed5b00bf8e6e98", "filename": "gcc/auto-inc-dec.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/481683e1d53b27779b31c1816606eb17975a9b1f/gcc%2Fauto-inc-dec.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/481683e1d53b27779b31c1816606eb17975a9b1f/gcc%2Fauto-inc-dec.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fauto-inc-dec.c?ref=481683e1d53b27779b31c1816606eb17975a9b1f", "patch": "@@ -813,7 +813,7 @@ parse_add_or_inc (rtx insn, bool before_mem)\n   else \n     inc_insn.form = before_mem ? FORM_PRE_ADD : FORM_POST_ADD;\n \n-  if (GET_CODE (XEXP (SET_SRC (pat), 1)) == CONST_INT)\n+  if (CONST_INT_P (XEXP (SET_SRC (pat), 1)))\n     {\n       /* Process a = b + c where c is a const.  */\n       inc_insn.reg1_is_const = true;\n@@ -891,7 +891,7 @@ find_address (rtx *address_of_x)\n       mem_insn.reg0 = inc_insn.reg_res;\n       mem_insn.reg1 = b;\n       mem_insn.reg1_is_const = inc_insn.reg1_is_const;\n-      if (GET_CODE (b) == CONST_INT)\n+      if (CONST_INT_P (b))\n \t{\n \t  /* Match with *(reg0 + reg1) where reg1 is a const. */\n \t  HOST_WIDE_INT val = INTVAL (b);\n@@ -1279,7 +1279,7 @@ find_mem (rtx *address_of_x)\n       mem_insn.mem_loc = address_of_x;\n       mem_insn.reg0 = XEXP (XEXP (x, 0), 0);\n       mem_insn.reg1 = reg1;\n-      if (GET_CODE (reg1) == CONST_INT)\n+      if (CONST_INT_P (reg1))\n \t{\n \t  mem_insn.reg1_is_const = true;\n \t  /* Match with *(reg0 + c) where c is a const. */"}, {"sha": "8476f00e42296f58688957af6102ab143d2005a5", "filename": "gcc/builtins.c", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/481683e1d53b27779b31c1816606eb17975a9b1f/gcc%2Fbuiltins.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/481683e1d53b27779b31c1816606eb17975a9b1f/gcc%2Fbuiltins.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbuiltins.c?ref=481683e1d53b27779b31c1816606eb17975a9b1f", "patch": "@@ -1169,7 +1169,7 @@ get_memory_rtx (tree exp, tree len)\n \t  gcc_assert (TREE_CODE (inner) == COMPONENT_REF);\n \n \t  if (MEM_OFFSET (mem)\n-\t      && GET_CODE (MEM_OFFSET (mem)) == CONST_INT)\n+\t      && CONST_INT_P (MEM_OFFSET (mem)))\n \t    offset = INTVAL (MEM_OFFSET (mem));\n \n \t  if (offset >= 0 && len && host_integerp (len, 0))\n@@ -1532,7 +1532,7 @@ expand_builtin_apply (rtx function, rtx arguments, rtx argsize)\n \n   dest = virtual_outgoing_args_rtx;\n #ifndef STACK_GROWS_DOWNWARD\n-  if (GET_CODE (argsize) == CONST_INT)\n+  if (CONST_INT_P (argsize))\n     dest = plus_constant (dest, -INTVAL (argsize));\n   else\n     dest = gen_rtx_PLUS (Pmode, dest, negate_rtx (Pmode, argsize));\n@@ -3403,7 +3403,7 @@ expand_builtin_memcpy (tree exp, rtx target, enum machine_mode mode)\n \t by pieces, we can avoid loading the string from memory\n \t and only stored the computed constants.  */\n       if (src_str\n-\t  && GET_CODE (len_rtx) == CONST_INT\n+\t  && CONST_INT_P (len_rtx)\n \t  && (unsigned HOST_WIDE_INT) INTVAL (len_rtx) <= strlen (src_str) + 1\n \t  && can_store_by_pieces (INTVAL (len_rtx), builtin_memcpy_read_str,\n \t\t\t\t  CONST_CAST (char *, src_str),\n@@ -3521,7 +3521,7 @@ expand_builtin_mempcpy_args (tree dest, tree src, tree len, tree type,\n \t by pieces, we can avoid loading the string from memory\n \t and only stored the computed constants.  */\n       if (src_str\n-\t  && GET_CODE (len_rtx) == CONST_INT\n+\t  && CONST_INT_P (len_rtx)\n \t  && (unsigned HOST_WIDE_INT) INTVAL (len_rtx) <= strlen (src_str) + 1\n \t  && can_store_by_pieces (INTVAL (len_rtx), builtin_memcpy_read_str,\n \t\t\t\t  CONST_CAST (char *, src_str),\n@@ -3538,7 +3538,7 @@ expand_builtin_mempcpy_args (tree dest, tree src, tree len, tree type,\n \t  return dest_mem;\n \t}\n \n-      if (GET_CODE (len_rtx) == CONST_INT\n+      if (CONST_INT_P (len_rtx)\n \t  && can_move_by_pieces (INTVAL (len_rtx),\n \t\t\t\t MIN (dest_align, src_align)))\n \t{\n@@ -3786,7 +3786,7 @@ expand_builtin_stpcpy (tree exp, rtx target, enum machine_mode mode)\n \t{\n \t  rtx len_rtx = expand_normal (len);\n \n-\t  if (GET_CODE (len_rtx) == CONST_INT)\n+\t  if (CONST_INT_P (len_rtx))\n \t    {\n \t      ret = expand_builtin_strcpy_args (get_callee_fndecl (exp),\n \t\t\t\t\t\tdst, src, target, mode);\n@@ -4194,7 +4194,7 @@ expand_builtin_memcmp (tree exp, rtx target, enum machine_mode mode)\n     arg3_rtx = expand_normal (fold_convert (sizetype, len));\n \n     /* Set MEM_SIZE as appropriate.  */\n-    if (GET_CODE (arg3_rtx) == CONST_INT)\n+    if (CONST_INT_P (arg3_rtx))\n       {\n \tset_mem_size (arg1_rtx, arg3_rtx);\n \tset_mem_size (arg2_rtx, arg3_rtx);"}, {"sha": "e610329fba92942e09f81e6fc275c9e15e9de1a6", "filename": "gcc/caller-save.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/481683e1d53b27779b31c1816606eb17975a9b1f/gcc%2Fcaller-save.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/481683e1d53b27779b31c1816606eb17975a9b1f/gcc%2Fcaller-save.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcaller-save.c?ref=481683e1d53b27779b31c1816606eb17975a9b1f", "patch": "@@ -471,7 +471,7 @@ setup_save_areas (void)\n \t{\n \t  insn = chain->insn;\n \t  next = chain->next;\n-\t  if (GET_CODE (insn) != CALL_INSN\n+\t  if (!CALL_P (insn)\n \t      || find_reg_note (insn, REG_NORETURN, NULL))\n \t    continue;\n \t  freq = REG_FREQ_FROM_BB (BLOCK_FOR_INSN (insn));\n@@ -531,7 +531,7 @@ setup_save_areas (void)\n \t  call_saved_regs_num = 0;\n \t  insn = chain->insn;\n \t  next = chain->next;\n-\t  if (GET_CODE (insn) != CALL_INSN\n+\t  if (!CALL_P (insn)\n \t      || find_reg_note (insn, REG_NORETURN, NULL))\n \t    continue;\n \t  REG_SET_TO_HARD_REG_SET (hard_regs_to_save,"}, {"sha": "c3d7639e4e28078a42e9d193e829135f2d29d78a", "filename": "gcc/calls.c", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/481683e1d53b27779b31c1816606eb17975a9b1f/gcc%2Fcalls.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/481683e1d53b27779b31c1816606eb17975a9b1f/gcc%2Fcalls.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcalls.c?ref=481683e1d53b27779b31c1816606eb17975a9b1f", "patch": "@@ -1431,7 +1431,7 @@ compute_argument_addresses (struct arg_data *args, rtx argblock, int num_actuals\n \t      && args[i].partial == 0)\n \t    continue;\n \n-\t  if (GET_CODE (offset) == CONST_INT)\n+\t  if (CONST_INT_P (offset))\n \t    addr = plus_constant (arg_reg, INTVAL (offset));\n \t  else\n \t    addr = gen_rtx_PLUS (Pmode, arg_reg, offset);\n@@ -1458,14 +1458,14 @@ compute_argument_addresses (struct arg_data *args, rtx argblock, int num_actuals\n \t  boundary = args[i].locate.boundary;\n \t  if (args[i].locate.where_pad != downward)\n \t    align = boundary;\n-\t  else if (GET_CODE (offset) == CONST_INT)\n+\t  else if (CONST_INT_P (offset))\n \t    {\n \t      align = INTVAL (offset) * BITS_PER_UNIT | boundary;\n \t      align = align & -align;\n \t    }\n \t  set_mem_align (args[i].stack, align);\n \n-\t  if (GET_CODE (slot_offset) == CONST_INT)\n+\t  if (CONST_INT_P (slot_offset))\n \t    addr = plus_constant (arg_reg, INTVAL (slot_offset));\n \t  else\n \t    addr = gen_rtx_PLUS (Pmode, arg_reg, slot_offset);\n@@ -1549,7 +1549,7 @@ mem_overlaps_already_clobbered_arg_p (rtx addr, unsigned HOST_WIDE_INT size)\n     i = 0;\n   else if (GET_CODE (addr) == PLUS\n \t   && XEXP (addr, 0) == crtl->args.internal_arg_pointer\n-\t   && GET_CODE (XEXP (addr, 1)) == CONST_INT)\n+\t   && CONST_INT_P (XEXP (addr, 1)))\n     i = INTVAL (XEXP (addr, 1));\n   /* Return true for arg pointer based indexed addressing.  */\n   else if (GET_CODE (addr) == PLUS\n@@ -4264,15 +4264,15 @@ store_one_arg (struct arg_data *arg, rtx argblock, int flags,\n \t      || (GET_CODE (XEXP (x, 0)) == PLUS\n \t\t  && XEXP (XEXP (x, 0), 0) ==\n \t\t     crtl->args.internal_arg_pointer\n-\t\t  && GET_CODE (XEXP (XEXP (x, 0), 1)) == CONST_INT))\n+\t\t  && CONST_INT_P (XEXP (XEXP (x, 0), 1))))\n \t    {\n \t      if (XEXP (x, 0) != crtl->args.internal_arg_pointer)\n \t\ti = INTVAL (XEXP (XEXP (x, 0), 1));\n \n \t      /* expand_call should ensure this.  */\n \t      gcc_assert (!arg->locate.offset.var\n \t\t\t  && arg->locate.size.var == 0\n-\t\t\t  && GET_CODE (size_rtx) == CONST_INT);\n+\t\t\t  && CONST_INT_P (size_rtx));\n \n \t      if (arg->locate.offset.constant > i)\n \t\t{"}, {"sha": "757a0ffe4ca86bfda3c1d6c1fced86ef8cc6c43e", "filename": "gcc/cfgcleanup.c", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/481683e1d53b27779b31c1816606eb17975a9b1f/gcc%2Fcfgcleanup.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/481683e1d53b27779b31c1816606eb17975a9b1f/gcc%2Fcfgcleanup.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgcleanup.c?ref=481683e1d53b27779b31c1816606eb17975a9b1f", "patch": "@@ -2064,9 +2064,7 @@ delete_dead_jumptables (void)\n \t  next = NEXT_INSN (insn);\n \t  if (LABEL_P (insn)\n \t      && LABEL_NUSES (insn) == LABEL_PRESERVE_P (insn)\n-\t      && JUMP_P (next)\n-\t      && (GET_CODE (PATTERN (next)) == ADDR_VEC\n-\t\t  || GET_CODE (PATTERN (next)) == ADDR_DIFF_VEC))\n+\t      && JUMP_TABLE_DATA_P (next))\n \t    {\n \t      rtx label = insn, jump = next;\n "}, {"sha": "f718f1e10dd4c57a4287ddc051958b4dec50ac30", "filename": "gcc/cfglayout.c", "status": "modified", "additions": 2, "deletions": 6, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/481683e1d53b27779b31c1816606eb17975a9b1f/gcc%2Fcfglayout.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/481683e1d53b27779b31c1816606eb17975a9b1f/gcc%2Fcfglayout.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfglayout.c?ref=481683e1d53b27779b31c1816606eb17975a9b1f", "patch": "@@ -112,9 +112,7 @@ skip_insns_after_block (basic_block bb)\n \n \tcase CODE_LABEL:\n \t  if (NEXT_INSN (insn)\n-\t      && JUMP_P (NEXT_INSN (insn))\n-\t      && (GET_CODE (PATTERN (NEXT_INSN (insn))) == ADDR_VEC\n-\t\t  || GET_CODE (PATTERN (NEXT_INSN (insn))) == ADDR_DIFF_VEC))\n+\t      && JUMP_TABLE_DATA_P (NEXT_INSN (insn)))\n \t    {\n \t      insn = NEXT_INSN (insn);\n \t      last_insn = insn;\n@@ -585,9 +583,7 @@ reemit_insn_block_notes (void)\n       tree this_block;\n \n       /* Avoid putting scope notes between jump table and its label.  */\n-      if (JUMP_P (insn)\n-\t  && (GET_CODE (PATTERN (insn)) == ADDR_VEC\n-\t      || GET_CODE (PATTERN (insn)) == ADDR_DIFF_VEC))\n+      if (JUMP_TABLE_DATA_P (insn))\n \tcontinue;\n \n       this_block = insn_scope (insn);"}, {"sha": "78df3ffca73ba7d34717305bd3e6ac4d79356db5", "filename": "gcc/cfgrtl.c", "status": "modified", "additions": 2, "deletions": 6, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/481683e1d53b27779b31c1816606eb17975a9b1f/gcc%2Fcfgrtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/481683e1d53b27779b31c1816606eb17975a9b1f/gcc%2Fcfgrtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgrtl.c?ref=481683e1d53b27779b31c1816606eb17975a9b1f", "patch": "@@ -170,9 +170,7 @@ delete_insn (rtx insn)\n       remove_note (insn, note);\n     }\n \n-  if (JUMP_P (insn)\n-      && (GET_CODE (PATTERN (insn)) == ADDR_VEC\n-\t  || GET_CODE (PATTERN (insn)) == ADDR_DIFF_VEC))\n+  if (JUMP_TABLE_DATA_P (insn))\n     {\n       rtx pat = PATTERN (insn);\n       int diff_vec_p = GET_CODE (PATTERN (insn)) == ADDR_DIFF_VEC;\n@@ -2124,9 +2122,7 @@ rtl_verify_flow_info (void)\n \t    case CODE_LABEL:\n \t      /* An addr_vec is placed outside any basic block.  */\n \t      if (NEXT_INSN (x)\n-\t\t  && JUMP_P (NEXT_INSN (x))\n-\t\t  && (GET_CODE (PATTERN (NEXT_INSN (x))) == ADDR_DIFF_VEC\n-\t\t      || GET_CODE (PATTERN (NEXT_INSN (x))) == ADDR_VEC))\n+\t\t  && JUMP_TABLE_DATA_P (NEXT_INSN (x)))\n \t\tx = NEXT_INSN (x);\n \n \t      /* But in any case, non-deletable labels can appear anywhere.  */"}, {"sha": "1f1759e104921f727e7c00fbc45b73dce075934b", "filename": "gcc/combine-stack-adj.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/481683e1d53b27779b31c1816606eb17975a9b1f/gcc%2Fcombine-stack-adj.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/481683e1d53b27779b31c1816606eb17975a9b1f/gcc%2Fcombine-stack-adj.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcombine-stack-adj.c?ref=481683e1d53b27779b31c1816606eb17975a9b1f", "patch": "@@ -116,7 +116,7 @@ stack_memref_p (rtx x)\n     return 1;\n   if (GET_CODE (x) == PLUS\n       && XEXP (x, 0) == stack_pointer_rtx\n-      && GET_CODE (XEXP (x, 1)) == CONST_INT)\n+      && CONST_INT_P (XEXP (x, 1)))\n     return 1;\n \n   return 0;\n@@ -298,7 +298,7 @@ adjust_frame_related_expr (rtx last_sp_set, rtx insn,\n \t  && SET_DEST (last) == stack_pointer_rtx\n \t  && GET_CODE (SET_SRC (last)) == PLUS\n \t  && XEXP (SET_SRC (last), 0) == stack_pointer_rtx\n-\t  && GET_CODE (XEXP (SET_SRC (last), 1)) == CONST_INT)\n+\t  && CONST_INT_P (XEXP (SET_SRC (last), 1)))\n \t{\n \t  XEXP (SET_SRC (last), 1)\n \t    = GEN_INT (INTVAL (XEXP (SET_SRC (last), 1)) + this_adjust);\n@@ -366,7 +366,7 @@ combine_stack_adjustments_for_block (basic_block bb)\n \t  if (dest == stack_pointer_rtx\n \t      && GET_CODE (src) == PLUS\n \t      && XEXP (src, 0) == stack_pointer_rtx\n-\t      && GET_CODE (XEXP (src, 1)) == CONST_INT)\n+\t      && CONST_INT_P (XEXP (src, 1)))\n \t    {\n \t      HOST_WIDE_INT this_adjust = INTVAL (XEXP (src, 1));\n "}, {"sha": "b7c4f1cc231d8386af422aa2cdfcf26838dbfc0a", "filename": "gcc/combine.c", "status": "modified", "additions": 125, "deletions": 125, "changes": 250, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/481683e1d53b27779b31c1816606eb17975a9b1f/gcc%2Fcombine.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/481683e1d53b27779b31c1816606eb17975a9b1f/gcc%2Fcombine.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcombine.c?ref=481683e1d53b27779b31c1816606eb17975a9b1f", "patch": "@@ -673,7 +673,7 @@ do_SUBST (rtx *into, rtx newval)\n      little gain doing the checks here.  Focus on catching invalid\n      transformations involving integer constants.  */\n   if (GET_MODE_CLASS (GET_MODE (oldval)) == MODE_INT\n-      && GET_CODE (newval) == CONST_INT)\n+      && CONST_INT_P (newval))\n     {\n       /* Sanity check that we're replacing oldval with a CONST_INT\n \t that is a valid sign-extension for the original mode.  */\n@@ -687,9 +687,9 @@ do_SUBST (rtx *into, rtx newval)\n \t perform this test on oldval instead, checking whether an\n \t invalid replacement took place before we got here.  */\n       gcc_assert (!(GET_CODE (oldval) == SUBREG\n-\t\t    && GET_CODE (SUBREG_REG (oldval)) == CONST_INT));\n+\t\t    && CONST_INT_P (SUBREG_REG (oldval))));\n       gcc_assert (!(GET_CODE (oldval) == ZERO_EXTEND\n-\t\t    && GET_CODE (XEXP (oldval, 0)) == CONST_INT));\n+\t\t    && CONST_INT_P (XEXP (oldval, 0))));\n     }\n \n   if (undobuf.frees)\n@@ -1490,7 +1490,7 @@ set_nonzero_bits_and_sign_copies (rtx x, const_rtx set, void *data)\n \t     instead of this kludge.  */\n \n \t  if (GET_MODE_BITSIZE (GET_MODE (x)) < BITS_PER_WORD\n-\t      && GET_CODE (src) == CONST_INT\n+\t      && CONST_INT_P (src)\n \t      && INTVAL (src) > 0\n \t      && 0 != (INTVAL (src)\n \t\t       & ((HOST_WIDE_INT) 1\n@@ -1962,7 +1962,7 @@ contains_muldiv (rtx x)\n       return 1;\n \n     case MULT:\n-      return ! (GET_CODE (XEXP (x, 1)) == CONST_INT\n+      return ! (CONST_INT_P (XEXP (x, 1))\n \t\t&& exact_log2 (INTVAL (XEXP (x, 1))) >= 0);\n     default:\n       if (BINARY_P (x))\n@@ -2346,10 +2346,10 @@ try_combine (rtx i3, rtx i2, rtx i1, int *new_direct_jump_p)\n      constant.  */\n   if (i1 == 0\n       && (temp = single_set (i2)) != 0\n-      && (GET_CODE (SET_SRC (temp)) == CONST_INT\n+      && (CONST_INT_P (SET_SRC (temp))\n \t  || GET_CODE (SET_SRC (temp)) == CONST_DOUBLE)\n       && GET_CODE (PATTERN (i3)) == SET\n-      && (GET_CODE (SET_SRC (PATTERN (i3))) == CONST_INT\n+      && (CONST_INT_P (SET_SRC (PATTERN (i3)))\n \t  || GET_CODE (SET_SRC (PATTERN (i3))) == CONST_DOUBLE)\n       && reg_subword_p (SET_DEST (PATTERN (i3)), SET_DEST (temp)))\n     {\n@@ -2359,8 +2359,8 @@ try_combine (rtx i3, rtx i2, rtx i1, int *new_direct_jump_p)\n \n       if (GET_CODE (dest) == ZERO_EXTRACT)\n \t{\n-\t  if (GET_CODE (XEXP (dest, 1)) == CONST_INT\n-\t      && GET_CODE (XEXP (dest, 2)) == CONST_INT)\n+\t  if (CONST_INT_P (XEXP (dest, 1))\n+\t      && CONST_INT_P (XEXP (dest, 2)))\n \t    {\n \t      width = INTVAL (XEXP (dest, 1));\n \t      offset = INTVAL (XEXP (dest, 2));\n@@ -2400,7 +2400,7 @@ try_combine (rtx i3, rtx i2, rtx i1, int *new_direct_jump_p)\n \t  rtx inner = SET_SRC (PATTERN (i3));\n \t  rtx outer = SET_SRC (temp);\n \n-\t  if (GET_CODE (outer) == CONST_INT)\n+\t  if (CONST_INT_P (outer))\n \t    {\n \t      olo = INTVAL (outer);\n \t      ohi = olo < 0 ? -1 : 0;\n@@ -2411,7 +2411,7 @@ try_combine (rtx i3, rtx i2, rtx i1, int *new_direct_jump_p)\n \t      ohi = CONST_DOUBLE_HIGH (outer);\n \t    }\n \n-\t  if (GET_CODE (inner) == CONST_INT)\n+\t  if (CONST_INT_P (inner))\n \t    {\n \t      ilo = INTVAL (inner);\n \t      ihi = ilo < 0 ? -1 : 0;\n@@ -3109,7 +3109,7 @@ try_combine (rtx i3, rtx i2, rtx i1, int *new_direct_jump_p)\n \t     an ASHIFT.  This can occur if it was inside a PLUS and hence\n \t     appeared to be a memory address.  This is a kludge.  */\n \t  if (split_code == MULT\n-\t      && GET_CODE (XEXP (*split, 1)) == CONST_INT\n+\t      && CONST_INT_P (XEXP (*split, 1))\n \t      && INTVAL (XEXP (*split, 1)) > 0\n \t      && (i = exact_log2 (INTVAL (XEXP (*split, 1)))) >= 0)\n \t    {\n@@ -3917,7 +3917,7 @@ find_split_point (rtx *loc, rtx insn)\n \t the first pseudo-reg (one of the virtual regs) as a placeholder;\n \t it will not remain in the result.  */\n       if (GET_CODE (XEXP (x, 0)) == PLUS\n-\t  && GET_CODE (XEXP (XEXP (x, 0), 1)) == CONST_INT\n+\t  && CONST_INT_P (XEXP (XEXP (x, 0), 1))\n \t  && ! memory_address_p (GET_MODE (x), XEXP (x, 0)))\n \t{\n \t  rtx reg = regno_reg_rtx[FIRST_PSEUDO_REGISTER];\n@@ -4019,9 +4019,9 @@ find_split_point (rtx *loc, rtx insn)\n       if (GET_CODE (SET_DEST (x)) == ZERO_EXTRACT\n \t  && (GET_MODE_BITSIZE (GET_MODE (XEXP (SET_DEST (x), 0)))\n \t      <= HOST_BITS_PER_WIDE_INT)\n-\t  && GET_CODE (XEXP (SET_DEST (x), 1)) == CONST_INT\n-\t  && GET_CODE (XEXP (SET_DEST (x), 2)) == CONST_INT\n-\t  && GET_CODE (SET_SRC (x)) == CONST_INT\n+\t  && CONST_INT_P (XEXP (SET_DEST (x), 1))\n+\t  && CONST_INT_P (XEXP (SET_DEST (x), 2))\n+\t  && CONST_INT_P (SET_SRC (x))\n \t  && ((INTVAL (XEXP (SET_DEST (x), 1))\n \t       + INTVAL (XEXP (SET_DEST (x), 2)))\n \t      <= GET_MODE_BITSIZE (GET_MODE (XEXP (SET_DEST (x), 0))))\n@@ -4075,7 +4075,7 @@ find_split_point (rtx *loc, rtx insn)\n \t     this is no worse, but if it took more than one insn, it will\n \t     be better.  */\n \n-\t  if (GET_CODE (XEXP (SET_SRC (x), 1)) == CONST_INT\n+\t  if (CONST_INT_P (XEXP (SET_SRC (x), 1))\n \t      && REG_P (XEXP (SET_SRC (x), 0))\n \t      && (pos = exact_log2 (INTVAL (XEXP (SET_SRC (x), 1)))) >= 7\n \t      && REG_P (SET_DEST (x))\n@@ -4135,8 +4135,8 @@ find_split_point (rtx *loc, rtx insn)\n \n \tcase SIGN_EXTRACT:\n \tcase ZERO_EXTRACT:\n-\t  if (GET_CODE (XEXP (SET_SRC (x), 1)) == CONST_INT\n-\t      && GET_CODE (XEXP (SET_SRC (x), 2)) == CONST_INT)\n+\t  if (CONST_INT_P (XEXP (SET_SRC (x), 1))\n+\t      && CONST_INT_P (XEXP (SET_SRC (x), 2)))\n \t    {\n \t      inner = XEXP (SET_SRC (x), 0);\n \t      len = INTVAL (XEXP (SET_SRC (x), 1));\n@@ -4512,7 +4512,7 @@ subst (rtx x, rtx from, rtx to, int in_dest, int unique_copy)\n \t\treturn new_rtx;\n \n \t      if (GET_CODE (x) == SUBREG\n-\t\t  && (GET_CODE (new_rtx) == CONST_INT\n+\t\t  && (CONST_INT_P (new_rtx)\n \t\t      || GET_CODE (new_rtx) == CONST_DOUBLE))\n \t\t{\n \t\t  enum machine_mode mode = GET_MODE (x);\n@@ -4523,7 +4523,7 @@ subst (rtx x, rtx from, rtx to, int in_dest, int unique_copy)\n \t\t  if (! x)\n \t\t    x = gen_rtx_CLOBBER (mode, const0_rtx);\n \t\t}\n-\t      else if (GET_CODE (new_rtx) == CONST_INT\n+\t      else if (CONST_INT_P (new_rtx)\n \t\t       && GET_CODE (x) == ZERO_EXTEND)\n \t\t{\n \t\t  x = simplify_unary_operation (ZERO_EXTEND, GET_MODE (x),\n@@ -4662,15 +4662,15 @@ combine_simplify_rtx (rtx x, enum machine_mode op0_mode, int in_dest)\n \n \t      /* Likewise, we can make the negate of a comparison operation\n \t\t if the result values are - STORE_FLAG_VALUE and zero.  */\n-\t      else if (GET_CODE (true_rtx) == CONST_INT\n+\t      else if (CONST_INT_P (true_rtx)\n \t\t       && INTVAL (true_rtx) == - STORE_FLAG_VALUE\n \t\t       && false_rtx == const0_rtx)\n \t\tx = simplify_gen_unary (NEG, mode,\n \t\t\t\t\tsimplify_gen_relational (cond_code,\n \t\t\t\t\t\t\t\t mode, VOIDmode,\n \t\t\t\t\t\t\t\t cond, cop1),\n \t\t\t\t\tmode);\n-\t      else if (GET_CODE (false_rtx) == CONST_INT\n+\t      else if (CONST_INT_P (false_rtx)\n \t\t       && INTVAL (false_rtx) == - STORE_FLAG_VALUE\n \t\t       && true_rtx == const0_rtx\n \t\t       && ((reversed = reversed_comparison_code_parts\n@@ -4849,7 +4849,7 @@ combine_simplify_rtx (rtx x, enum machine_mode op0_mode, int in_dest)\n \t (neg (sign_extract X 1 Y)) to (zero_extract X 1 Y).  */\n \n       if (GET_CODE (temp) == ASHIFTRT\n-\t  && GET_CODE (XEXP (temp, 1)) == CONST_INT\n+\t  && CONST_INT_P (XEXP (temp, 1))\n \t  && INTVAL (XEXP (temp, 1)) == GET_MODE_BITSIZE (mode) - 1)\n \treturn simplify_shift_const (NULL_RTX, LSHIFTRT, mode, XEXP (temp, 0),\n \t\t\t\t     INTVAL (XEXP (temp, 1)));\n@@ -4932,14 +4932,14 @@ combine_simplify_rtx (rtx x, enum machine_mode op0_mode, int in_dest)\n \t sign_extract.  The `and' may be a zero_extend and the two\n \t <c>, -<c> constants may be reversed.  */\n       if (GET_CODE (XEXP (x, 0)) == XOR\n-\t  && GET_CODE (XEXP (x, 1)) == CONST_INT\n-\t  && GET_CODE (XEXP (XEXP (x, 0), 1)) == CONST_INT\n+\t  && CONST_INT_P (XEXP (x, 1))\n+\t  && CONST_INT_P (XEXP (XEXP (x, 0), 1))\n \t  && INTVAL (XEXP (x, 1)) == -INTVAL (XEXP (XEXP (x, 0), 1))\n \t  && ((i = exact_log2 (INTVAL (XEXP (XEXP (x, 0), 1)))) >= 0\n \t      || (i = exact_log2 (INTVAL (XEXP (x, 1)))) >= 0)\n \t  && GET_MODE_BITSIZE (mode) <= HOST_BITS_PER_WIDE_INT\n \t  && ((GET_CODE (XEXP (XEXP (x, 0), 0)) == AND\n-\t       && GET_CODE (XEXP (XEXP (XEXP (x, 0), 0), 1)) == CONST_INT\n+\t       && CONST_INT_P (XEXP (XEXP (XEXP (x, 0), 0), 1))\n \t       && (INTVAL (XEXP (XEXP (XEXP (x, 0), 0), 1))\n \t\t   == ((HOST_WIDE_INT) 1 << (i + 1)) - 1))\n \t      || (GET_CODE (XEXP (XEXP (x, 0), 0)) == ZERO_EXTEND\n@@ -4992,7 +4992,7 @@ combine_simplify_rtx (rtx x, enum machine_mode op0_mode, int in_dest)\n       /* (minus <foo> (and <foo> (const_int -pow2))) becomes\n \t (and <foo> (const_int pow2-1))  */\n       if (GET_CODE (XEXP (x, 1)) == AND\n-\t  && GET_CODE (XEXP (XEXP (x, 1), 1)) == CONST_INT\n+\t  && CONST_INT_P (XEXP (XEXP (x, 1), 1))\n \t  && exact_log2 (-INTVAL (XEXP (XEXP (x, 1), 1))) >= 0\n \t  && rtx_equal_p (XEXP (XEXP (x, 1), 0), XEXP (x, 0)))\n \treturn simplify_and_const_int (NULL_RTX, mode, XEXP (x, 0),\n@@ -5026,7 +5026,7 @@ combine_simplify_rtx (rtx x, enum machine_mode op0_mode, int in_dest)\n     case UDIV:\n       /* If this is a divide by a power of two, treat it as a shift if\n \t its first operand is a shift.  */\n-      if (GET_CODE (XEXP (x, 1)) == CONST_INT\n+      if (CONST_INT_P (XEXP (x, 1))\n \t  && (i = exact_log2 (INTVAL (XEXP (x, 1)))) >= 0\n \t  && (GET_CODE (XEXP (x, 0)) == ASHIFT\n \t      || GET_CODE (XEXP (x, 0)) == LSHIFTRT\n@@ -5220,7 +5220,7 @@ combine_simplify_rtx (rtx x, enum machine_mode op0_mode, int in_dest)\n     case ROTATE:\n     case ROTATERT:\n       /* If this is a shift by a constant amount, simplify it.  */\n-      if (GET_CODE (XEXP (x, 1)) == CONST_INT)\n+      if (CONST_INT_P (XEXP (x, 1)))\n \treturn simplify_shift_const (x, code, mode, XEXP (x, 0),\n \t\t\t\t     INTVAL (XEXP (x, 1)));\n \n@@ -5339,7 +5339,7 @@ simplify_if_then_else (rtx x)\n       && reversed_comparison_code (cond, NULL) != UNKNOWN\n       && (true_rtx == pc_rtx\n \t  || (CONSTANT_P (true_rtx)\n-\t      && GET_CODE (false_rtx) != CONST_INT && false_rtx != pc_rtx)\n+\t      && !CONST_INT_P (false_rtx) && false_rtx != pc_rtx)\n \t  || true_rtx == const0_rtx\n \t  || (OBJECT_P (true_rtx) && !OBJECT_P (false_rtx))\n \t  || (GET_CODE (true_rtx) == SUBREG && OBJECT_P (SUBREG_REG (true_rtx))\n@@ -5556,7 +5556,7 @@ simplify_if_then_else (rtx x)\n      can actually do this more generally, but it doesn't seem worth it.  */\n \n   if (true_code == NE && XEXP (cond, 1) == const0_rtx\n-      && false_rtx == const0_rtx && GET_CODE (true_rtx) == CONST_INT\n+      && false_rtx == const0_rtx && CONST_INT_P (true_rtx)\n       && ((1 == nonzero_bits (XEXP (cond, 0), mode)\n \t   && (i = exact_log2 (INTVAL (true_rtx))) >= 0)\n \t  || ((num_sign_bit_copies (XEXP (cond, 0), mode)\n@@ -5568,7 +5568,7 @@ simplify_if_then_else (rtx x)\n \n   /* (IF_THEN_ELSE (NE REG 0) (0) (8)) is REG for nonzero_bits (REG) == 8.  */\n   if (true_code == NE && XEXP (cond, 1) == const0_rtx\n-      && false_rtx == const0_rtx && GET_CODE (true_rtx) == CONST_INT\n+      && false_rtx == const0_rtx && CONST_INT_P (true_rtx)\n       && GET_MODE (XEXP (cond, 0)) == mode\n       && (INTVAL (true_rtx) & GET_MODE_MASK (mode))\n \t  == nonzero_bits (XEXP (cond, 0), mode)\n@@ -5935,7 +5935,7 @@ simplify_logical (rtx x)\n       /* We can call simplify_and_const_int only if we don't lose\n \t any (sign) bits when converting INTVAL (op1) to\n \t \"unsigned HOST_WIDE_INT\".  */\n-      if (GET_CODE (op1) == CONST_INT\n+      if (CONST_INT_P (op1)\n \t  && (GET_MODE_BITSIZE (mode) <= HOST_BITS_PER_WIDE_INT\n \t      || INTVAL (op1) > 0))\n \t{\n@@ -6024,7 +6024,7 @@ expand_compound_operation (rtx x)\n \t Even for a mode that is no wider than a const_int,\n \t we can't win, because we need to sign extend one of its bits through\n \t the rest of it, and we don't know which bit.  */\n-      if (GET_CODE (XEXP (x, 0)) == CONST_INT)\n+      if (CONST_INT_P (XEXP (x, 0)))\n \treturn x;\n \n       /* Return if (subreg:MODE FROM 0) is not a safe replacement for\n@@ -6064,8 +6064,8 @@ expand_compound_operation (rtx x)\n       if (GET_CODE (XEXP (x, 0)) == CLOBBER)\n \treturn XEXP (x, 0);\n \n-      if (GET_CODE (XEXP (x, 1)) != CONST_INT\n-\t  || GET_CODE (XEXP (x, 2)) != CONST_INT\n+      if (!CONST_INT_P (XEXP (x, 1))\n+\t  || !CONST_INT_P (XEXP (x, 2))\n \t  || GET_MODE (XEXP (x, 0)) == VOIDmode)\n \treturn x;\n \n@@ -6236,24 +6236,24 @@ expand_field_assignment (const_rtx x)\n \t  pos = GEN_INT (subreg_lsb (XEXP (SET_DEST (x), 0)));\n \t}\n       else if (GET_CODE (SET_DEST (x)) == ZERO_EXTRACT\n-\t       && GET_CODE (XEXP (SET_DEST (x), 1)) == CONST_INT)\n+\t       && CONST_INT_P (XEXP (SET_DEST (x), 1)))\n \t{\n \t  inner = XEXP (SET_DEST (x), 0);\n \t  len = INTVAL (XEXP (SET_DEST (x), 1));\n \t  pos = XEXP (SET_DEST (x), 2);\n \n \t  /* A constant position should stay within the width of INNER.  */\n-\t  if (GET_CODE (pos) == CONST_INT\n+\t  if (CONST_INT_P (pos)\n \t      && INTVAL (pos) + len > GET_MODE_BITSIZE (GET_MODE (inner)))\n \t    break;\n \n \t  if (BITS_BIG_ENDIAN)\n \t    {\n-\t      if (GET_CODE (pos) == CONST_INT)\n+\t      if (CONST_INT_P (pos))\n \t\tpos = GEN_INT (GET_MODE_BITSIZE (GET_MODE (inner)) - len\n \t\t\t       - INTVAL (pos));\n \t      else if (GET_CODE (pos) == MINUS\n-\t\t       && GET_CODE (XEXP (pos, 1)) == CONST_INT\n+\t\t       && CONST_INT_P (XEXP (pos, 1))\n \t\t       && (INTVAL (XEXP (pos, 1))\n \t\t\t   == GET_MODE_BITSIZE (GET_MODE (inner)) - len))\n \t\t/* If position is ADJUST - X, new position is X.  */\n@@ -6390,7 +6390,7 @@ make_extraction (enum machine_mode mode, rtx inner, HOST_WIDE_INT pos,\n       inner = SUBREG_REG (inner);\n     }\n   else if (GET_CODE (inner) == ASHIFT\n-\t   && GET_CODE (XEXP (inner, 1)) == CONST_INT\n+\t   && CONST_INT_P (XEXP (inner, 1))\n \t   && pos_rtx == 0 && pos == 0\n \t   && len > (unsigned HOST_WIDE_INT) INTVAL (XEXP (inner, 1)))\n     {\n@@ -6407,7 +6407,7 @@ make_extraction (enum machine_mode mode, rtx inner, HOST_WIDE_INT pos,\n \n   inner_mode = GET_MODE (inner);\n \n-  if (pos_rtx && GET_CODE (pos_rtx) == CONST_INT)\n+  if (pos_rtx && CONST_INT_P (pos_rtx))\n     pos = INTVAL (pos_rtx), pos_rtx = 0;\n \n   /* See if this can be done without an extraction.  We never can if the\n@@ -6515,7 +6515,7 @@ make_extraction (enum machine_mode mode, rtx inner, HOST_WIDE_INT pos,\n       if (mode == tmode)\n \treturn new_rtx;\n \n-      if (GET_CODE (new_rtx) == CONST_INT)\n+      if (CONST_INT_P (new_rtx))\n \treturn gen_int_mode (INTVAL (new_rtx), mode);\n \n       /* If we know that no extraneous bits are set, and that the high\n@@ -6773,7 +6773,7 @@ extract_left_shift (rtx x, int count)\n       /* This is the shift itself.  If it is wide enough, we will return\n \t either the value being shifted if the shift count is equal to\n \t COUNT or a shift for the difference.  */\n-      if (GET_CODE (XEXP (x, 1)) == CONST_INT\n+      if (CONST_INT_P (XEXP (x, 1))\n \t  && INTVAL (XEXP (x, 1)) >= count)\n \treturn simplify_shift_const (NULL_RTX, ASHIFT, mode, XEXP (x, 0),\n \t\t\t\t     INTVAL (XEXP (x, 1)) - count);\n@@ -6788,7 +6788,7 @@ extract_left_shift (rtx x, int count)\n     case PLUS:  case IOR:  case XOR:  case AND:\n       /* If we can safely shift this constant and we find the inner shift,\n \t make a new operation.  */\n-      if (GET_CODE (XEXP (x, 1)) == CONST_INT\n+      if (CONST_INT_P (XEXP (x, 1))\n \t  && (INTVAL (XEXP (x, 1)) & ((((HOST_WIDE_INT) 1 << count)) - 1)) == 0\n \t  && (tem = extract_left_shift (XEXP (x, 0), count)) != 0)\n \treturn simplify_gen_binary (code, mode, tem,\n@@ -6851,7 +6851,7 @@ make_compound_operation (rtx x, enum rtx_code in_code)\n     case ASHIFT:\n       /* Convert shifts by constants into multiplications if inside\n \t an address.  */\n-      if (in_code == MEM && GET_CODE (XEXP (x, 1)) == CONST_INT\n+      if (in_code == MEM && CONST_INT_P (XEXP (x, 1))\n \t  && INTVAL (XEXP (x, 1)) < HOST_BITS_PER_WIDE_INT\n \t  && INTVAL (XEXP (x, 1)) >= 0)\n \t{\n@@ -6865,7 +6865,7 @@ make_compound_operation (rtx x, enum rtx_code in_code)\n     case AND:\n       /* If the second operand is not a constant, we can't do anything\n \t with it.  */\n-      if (GET_CODE (XEXP (x, 1)) != CONST_INT)\n+      if (!CONST_INT_P (XEXP (x, 1)))\n \tbreak;\n \n       /* If the constant is a power of two minus one and the first operand\n@@ -6910,7 +6910,7 @@ make_compound_operation (rtx x, enum rtx_code in_code)\n \t of bits in M, this is an extraction.  */\n \n       else if (GET_CODE (XEXP (x, 0)) == ROTATE\n-\t       && GET_CODE (XEXP (XEXP (x, 0), 1)) == CONST_INT\n+\t       && CONST_INT_P (XEXP (XEXP (x, 0), 1))\n \t       && (i = exact_log2 (INTVAL (XEXP (x, 1)) + 1)) >= 0\n \t       && i <= INTVAL (XEXP (XEXP (x, 0), 1)))\n \t{\n@@ -6927,7 +6927,7 @@ make_compound_operation (rtx x, enum rtx_code in_code)\n       else if (GET_CODE (XEXP (x, 0)) == LSHIFTRT\n \t       && !have_insn_for (LSHIFTRT, mode)\n \t       && have_insn_for (ASHIFTRT, mode)\n-\t       && GET_CODE (XEXP (XEXP (x, 0), 1)) == CONST_INT\n+\t       && CONST_INT_P (XEXP (XEXP (x, 0), 1))\n \t       && INTVAL (XEXP (XEXP (x, 0), 1)) >= 0\n \t       && INTVAL (XEXP (XEXP (x, 0), 1)) < HOST_BITS_PER_WIDE_INT\n \t       && mode_width <= HOST_BITS_PER_WIDE_INT)\n@@ -6987,9 +6987,9 @@ make_compound_operation (rtx x, enum rtx_code in_code)\n \n       /* If we have (ashiftrt (ashift foo C1) C2) with C2 >= C1,\n \t this is a SIGN_EXTRACT.  */\n-      if (GET_CODE (rhs) == CONST_INT\n+      if (CONST_INT_P (rhs)\n \t  && GET_CODE (lhs) == ASHIFT\n-\t  && GET_CODE (XEXP (lhs, 1)) == CONST_INT\n+\t  && CONST_INT_P (XEXP (lhs, 1))\n \t  && INTVAL (rhs) >= INTVAL (XEXP (lhs, 1))\n \t  && INTVAL (rhs) < mode_width)\n \t{\n@@ -7009,7 +7009,7 @@ make_compound_operation (rtx x, enum rtx_code in_code)\n       if (!OBJECT_P (lhs)\n \t  && ! (GET_CODE (lhs) == SUBREG\n \t\t&& (OBJECT_P (SUBREG_REG (lhs))))\n-\t  && GET_CODE (rhs) == CONST_INT\n+\t  && CONST_INT_P (rhs)\n \t  && INTVAL (rhs) < HOST_BITS_PER_WIDE_INT\n \t  && INTVAL (rhs) < mode_width\n \t  && (new_rtx = extract_left_shift (lhs, INTVAL (rhs))) != 0)\n@@ -7300,7 +7300,7 @@ force_to_mode (rtx x, enum machine_mode mode, unsigned HOST_WIDE_INT mask,\n \n   /* If X is a CONST_INT, return a new one.  Do this here since the\n      test below will fail.  */\n-  if (GET_CODE (x) == CONST_INT)\n+  if (CONST_INT_P (x))\n     {\n       if (SCALAR_INT_MODE_P (mode))\n \treturn gen_int_mode (INTVAL (x) & mask, mode);\n@@ -7355,7 +7355,7 @@ force_to_mode (rtx x, enum machine_mode mode, unsigned HOST_WIDE_INT mask,\n \t whose constant is the AND of that constant with MASK.  If it\n \t remains an AND of MASK, delete it since it is redundant.  */\n \n-      if (GET_CODE (XEXP (x, 1)) == CONST_INT)\n+      if (CONST_INT_P (XEXP (x, 1)))\n \t{\n \t  x = simplify_and_const_int (x, op_mode, XEXP (x, 0),\n \t\t\t\t      mask & INTVAL (XEXP (x, 1)));\n@@ -7364,7 +7364,7 @@ force_to_mode (rtx x, enum machine_mode mode, unsigned HOST_WIDE_INT mask,\n \t     is just some low-order bits.  If so, and it is MASK, we don't\n \t     need it.  */\n \n-\t  if (GET_CODE (x) == AND && GET_CODE (XEXP (x, 1)) == CONST_INT\n+\t  if (GET_CODE (x) == AND && CONST_INT_P (XEXP (x, 1))\n \t      && ((INTVAL (XEXP (x, 1)) & GET_MODE_MASK (GET_MODE (x)))\n \t\t  == mask))\n \t    x = XEXP (x, 0);\n@@ -7374,7 +7374,7 @@ force_to_mode (rtx x, enum machine_mode mode, unsigned HOST_WIDE_INT mask,\n \t     constant in the AND is wide enough, this might make a\n \t     cheaper constant.  */\n \n-\t  if (GET_CODE (x) == AND && GET_CODE (XEXP (x, 1)) == CONST_INT\n+\t  if (GET_CODE (x) == AND && CONST_INT_P (XEXP (x, 1))\n \t      && GET_MODE_MASK (GET_MODE (x)) != mask\n \t      && GET_MODE_BITSIZE (GET_MODE (x)) <= HOST_BITS_PER_WIDE_INT)\n \t    {\n@@ -7418,7 +7418,7 @@ force_to_mode (rtx x, enum machine_mode mode, unsigned HOST_WIDE_INT mask,\n \t    && (smask & ((HOST_WIDE_INT) 1 << (width - 1))) != 0)\n \t  smask |= (HOST_WIDE_INT) -1 << width;\n \n-\tif (GET_CODE (XEXP (x, 1)) == CONST_INT\n+\tif (CONST_INT_P (XEXP (x, 1))\n \t    && exact_log2 (- smask) >= 0\n \t    && (nonzero_bits (XEXP (x, 0), mode) & ~smask) == 0\n \t    && (INTVAL (XEXP (x, 1)) & ~smask) != 0)\n@@ -7439,7 +7439,7 @@ force_to_mode (rtx x, enum machine_mode mode, unsigned HOST_WIDE_INT mask,\n     case MINUS:\n       /* If X is (minus C Y) where C's least set bit is larger than any bit\n \t in the mask, then we may replace with (neg Y).  */\n-      if (GET_CODE (XEXP (x, 0)) == CONST_INT\n+      if (CONST_INT_P (XEXP (x, 0))\n \t  && (((unsigned HOST_WIDE_INT) (INTVAL (XEXP (x, 0))\n \t\t\t\t\t& -INTVAL (XEXP (x, 0))))\n \t      > mask))\n@@ -7451,7 +7451,7 @@ force_to_mode (rtx x, enum machine_mode mode, unsigned HOST_WIDE_INT mask,\n \n       /* Similarly, if C contains every bit in the fuller_mask, then we may\n \t replace with (not Y).  */\n-      if (GET_CODE (XEXP (x, 0)) == CONST_INT\n+      if (CONST_INT_P (XEXP (x, 0))\n \t  && ((INTVAL (XEXP (x, 0)) | (HOST_WIDE_INT) fuller_mask)\n \t      == INTVAL (XEXP (x, 0))))\n \t{\n@@ -7471,10 +7471,10 @@ force_to_mode (rtx x, enum machine_mode mode, unsigned HOST_WIDE_INT mask,\n \t constant we form is not wider than the mode of X.  */\n \n       if (GET_CODE (XEXP (x, 0)) == LSHIFTRT\n-\t  && GET_CODE (XEXP (XEXP (x, 0), 1)) == CONST_INT\n+\t  && CONST_INT_P (XEXP (XEXP (x, 0), 1))\n \t  && INTVAL (XEXP (XEXP (x, 0), 1)) >= 0\n \t  && INTVAL (XEXP (XEXP (x, 0), 1)) < HOST_BITS_PER_WIDE_INT\n-\t  && GET_CODE (XEXP (x, 1)) == CONST_INT\n+\t  && CONST_INT_P (XEXP (x, 1))\n \t  && ((INTVAL (XEXP (XEXP (x, 0), 1))\n \t       + floor_log2 (INTVAL (XEXP (x, 1))))\n \t      < GET_MODE_BITSIZE (GET_MODE (x)))\n@@ -7512,7 +7512,7 @@ force_to_mode (rtx x, enum machine_mode mode, unsigned HOST_WIDE_INT mask,\n \t because such a count will have a different meaning in a\n \t wider mode.  */\n \n-      if (! (GET_CODE (XEXP (x, 1)) == CONST_INT\n+      if (! (CONST_INT_P (XEXP (x, 1))\n \t     && INTVAL (XEXP (x, 1)) >= 0\n \t     && INTVAL (XEXP (x, 1)) < GET_MODE_BITSIZE (mode))\n \t  && ! (GET_MODE (XEXP (x, 1)) != VOIDmode\n@@ -7523,7 +7523,7 @@ force_to_mode (rtx x, enum machine_mode mode, unsigned HOST_WIDE_INT mask,\n       /* If the shift count is a constant and we can do arithmetic in\n \t the mode of the shift, refine which bits we need.  Otherwise, use the\n \t conservative form of the mask.  */\n-      if (GET_CODE (XEXP (x, 1)) == CONST_INT\n+      if (CONST_INT_P (XEXP (x, 1))\n \t  && INTVAL (XEXP (x, 1)) >= 0\n \t  && INTVAL (XEXP (x, 1)) < GET_MODE_BITSIZE (op_mode)\n \t  && GET_MODE_BITSIZE (op_mode) <= HOST_BITS_PER_WIDE_INT)\n@@ -7544,7 +7544,7 @@ force_to_mode (rtx x, enum machine_mode mode, unsigned HOST_WIDE_INT mask,\n \t this shift constant is valid for the host, and we can do arithmetic\n \t in OP_MODE.  */\n \n-      if (GET_CODE (XEXP (x, 1)) == CONST_INT\n+      if (CONST_INT_P (XEXP (x, 1))\n \t  && INTVAL (XEXP (x, 1)) < HOST_BITS_PER_WIDE_INT\n \t  && GET_MODE_BITSIZE (op_mode) <= HOST_BITS_PER_WIDE_INT)\n \t{\n@@ -7571,7 +7571,7 @@ force_to_mode (rtx x, enum machine_mode mode, unsigned HOST_WIDE_INT mask,\n \t than a power of two), we can do this with just a shift.  */\n \n       if (GET_CODE (x) == LSHIFTRT\n-\t  && GET_CODE (XEXP (x, 1)) == CONST_INT\n+\t  && CONST_INT_P (XEXP (x, 1))\n \t  /* The shift puts one of the sign bit copies in the least significant\n \t     bit.  */\n \t  && ((INTVAL (XEXP (x, 1))\n@@ -7606,7 +7606,7 @@ force_to_mode (rtx x, enum machine_mode mode, unsigned HOST_WIDE_INT mask,\n \t those bits, we are requesting a copy of the sign bit and hence can\n \t shift the sign bit to the appropriate location.  */\n \n-      if (GET_CODE (XEXP (x, 1)) == CONST_INT && INTVAL (XEXP (x, 1)) >= 0\n+      if (CONST_INT_P (XEXP (x, 1)) && INTVAL (XEXP (x, 1)) >= 0\n \t  && INTVAL (XEXP (x, 1)) < HOST_BITS_PER_WIDE_INT)\n \t{\n \t  int i;\n@@ -7668,7 +7668,7 @@ force_to_mode (rtx x, enum machine_mode mode, unsigned HOST_WIDE_INT mask,\n \t something that is still a shift.  */\n \n       if ((GET_CODE (x) == LSHIFTRT || GET_CODE (x) == ASHIFTRT)\n-\t  && GET_CODE (XEXP (x, 1)) == CONST_INT\n+\t  && CONST_INT_P (XEXP (x, 1))\n \t  && INTVAL (XEXP (x, 1)) >= 0\n \t  && (INTVAL (XEXP (x, 1))\n \t      <= GET_MODE_BITSIZE (GET_MODE (x)) - (floor_log2 (mask) + 1))\n@@ -7685,13 +7685,13 @@ force_to_mode (rtx x, enum machine_mode mode, unsigned HOST_WIDE_INT mask,\n \t in the mode of X, compute where the bits we care about are.\n \t Otherwise, we can't do anything.  Don't change the mode of\n \t the shift or propagate MODE into the shift, though.  */\n-      if (GET_CODE (XEXP (x, 1)) == CONST_INT\n+      if (CONST_INT_P (XEXP (x, 1))\n \t  && INTVAL (XEXP (x, 1)) >= 0)\n \t{\n \t  temp = simplify_binary_operation (code == ROTATE ? ROTATERT : ROTATE,\n \t\t\t\t\t    GET_MODE (x), GEN_INT (mask),\n \t\t\t\t\t    XEXP (x, 1));\n-\t  if (temp && GET_CODE (temp) == CONST_INT)\n+\t  if (temp && CONST_INT_P (temp))\n \t    SUBST (XEXP (x, 0),\n \t\t   force_to_mode (XEXP (x, 0), GET_MODE (x),\n \t\t\t\t  INTVAL (temp), next_select));\n@@ -7716,7 +7716,7 @@ force_to_mode (rtx x, enum machine_mode mode, unsigned HOST_WIDE_INT mask,\n \t wider than the mode of X.  */\n \n       if (GET_CODE (XEXP (x, 0)) == LSHIFTRT\n-\t  && GET_CODE (XEXP (XEXP (x, 0), 1)) == CONST_INT\n+\t  && CONST_INT_P (XEXP (XEXP (x, 0), 1))\n \t  && INTVAL (XEXP (XEXP (x, 0), 1)) >= 0\n \t  && (INTVAL (XEXP (XEXP (x, 0), 1)) + floor_log2 (mask)\n \t      < GET_MODE_BITSIZE (GET_MODE (x)))\n@@ -8205,7 +8205,7 @@ make_field_assignment (rtx x)\n      for a SUBREG.  */\n \n   if (GET_CODE (src) == AND && GET_CODE (XEXP (src, 0)) == ROTATE\n-      && GET_CODE (XEXP (XEXP (src, 0), 0)) == CONST_INT\n+      && CONST_INT_P (XEXP (XEXP (src, 0), 0))\n       && INTVAL (XEXP (XEXP (src, 0), 0)) == -2\n       && rtx_equal_for_field_assignment_p (dest, XEXP (src, 1)))\n     {\n@@ -8221,7 +8221,7 @@ make_field_assignment (rtx x)\n       && (GET_MODE_SIZE (GET_MODE (XEXP (src, 0)))\n \t  < GET_MODE_SIZE (GET_MODE (SUBREG_REG (XEXP (src, 0)))))\n       && GET_CODE (SUBREG_REG (XEXP (src, 0))) == ROTATE\n-      && GET_CODE (XEXP (SUBREG_REG (XEXP (src, 0)), 0)) == CONST_INT\n+      && CONST_INT_P (XEXP (SUBREG_REG (XEXP (src, 0)), 0))\n       && INTVAL (XEXP (SUBREG_REG (XEXP (src, 0)), 0)) == -2\n       && rtx_equal_for_field_assignment_p (dest, XEXP (src, 1)))\n     {\n@@ -8250,9 +8250,9 @@ make_field_assignment (rtx x)\n      SRC is an AND with all bits of that field set, then we can discard\n      the AND.  */\n   if (GET_CODE (dest) == ZERO_EXTRACT\n-      && GET_CODE (XEXP (dest, 1)) == CONST_INT\n+      && CONST_INT_P (XEXP (dest, 1))\n       && GET_CODE (src) == AND\n-      && GET_CODE (XEXP (src, 1)) == CONST_INT)\n+      && CONST_INT_P (XEXP (src, 1)))\n     {\n       HOST_WIDE_INT width = INTVAL (XEXP (dest, 1));\n       unsigned HOST_WIDE_INT and_mask = INTVAL (XEXP (src, 1));\n@@ -8292,11 +8292,11 @@ make_field_assignment (rtx x)\n   lhs = expand_compound_operation (XEXP (src, 1));\n \n   if (GET_CODE (rhs) == AND\n-      && GET_CODE (XEXP (rhs, 1)) == CONST_INT\n+      && CONST_INT_P (XEXP (rhs, 1))\n       && rtx_equal_for_field_assignment_p (XEXP (rhs, 0), dest))\n     c1 = INTVAL (XEXP (rhs, 1)), other = lhs;\n   else if (GET_CODE (lhs) == AND\n-\t   && GET_CODE (XEXP (lhs, 1)) == CONST_INT\n+\t   && CONST_INT_P (XEXP (lhs, 1))\n \t   && rtx_equal_for_field_assignment_p (XEXP (lhs, 0), dest))\n     c1 = INTVAL (XEXP (lhs, 1)), other = rhs;\n   else\n@@ -8333,10 +8333,10 @@ make_field_assignment (rtx x)\n   /* If SRC is masked by an AND that does not make a difference in\n      the value being stored, strip it.  */\n   if (GET_CODE (assign) == ZERO_EXTRACT\n-      && GET_CODE (XEXP (assign, 1)) == CONST_INT\n+      && CONST_INT_P (XEXP (assign, 1))\n       && INTVAL (XEXP (assign, 1)) < HOST_BITS_PER_WIDE_INT\n       && GET_CODE (src) == AND\n-      && GET_CODE (XEXP (src, 1)) == CONST_INT\n+      && CONST_INT_P (XEXP (src, 1))\n       && ((unsigned HOST_WIDE_INT) INTVAL (XEXP (src, 1))\n \t  == ((unsigned HOST_WIDE_INT) 1 << INTVAL (XEXP (assign, 1))) - 1))\n     src = XEXP (src, 0);\n@@ -8576,7 +8576,7 @@ simplify_and_const_int_1 (enum machine_mode mode, rtx varop,\n \n   /* If VAROP is a CONST_INT, then we need to apply the mask in CONSTOP\n      to VAROP and return the new constant.  */\n-  if (GET_CODE (varop) == CONST_INT)\n+  if (CONST_INT_P (varop))\n     return gen_int_mode (INTVAL (varop) & constop, mode);\n \n   /* See what bits may be nonzero in VAROP.  Unlike the general case of\n@@ -8732,7 +8732,7 @@ reg_nonzero_bits_for_combine (const_rtx x, enum machine_mode mode,\n \t instead of this kludge.  */\n \n       if (GET_MODE_BITSIZE (GET_MODE (x)) < GET_MODE_BITSIZE (mode)\n-\t  && GET_CODE (tem) == CONST_INT\n+\t  && CONST_INT_P (tem)\n \t  && INTVAL (tem) > 0\n \t  && 0 != (INTVAL (tem)\n \t\t   & ((HOST_WIDE_INT) 1\n@@ -9151,7 +9151,7 @@ simplify_shift_const_1 (enum rtx_code code, enum machine_mode result_mode,\n \t  /* Some machines use MULT instead of ASHIFT because MULT\n \t     is cheaper.  But it is still better on those machines to\n \t     merge two shifts into one.  */\n-\t  if (GET_CODE (XEXP (varop, 1)) == CONST_INT\n+\t  if (CONST_INT_P (XEXP (varop, 1))\n \t      && exact_log2 (INTVAL (XEXP (varop, 1))) >= 0)\n \t    {\n \t      varop\n@@ -9165,7 +9165,7 @@ simplify_shift_const_1 (enum rtx_code code, enum machine_mode result_mode,\n \n \tcase UDIV:\n \t  /* Similar, for when divides are cheaper.  */\n-\t  if (GET_CODE (XEXP (varop, 1)) == CONST_INT\n+\t  if (CONST_INT_P (XEXP (varop, 1))\n \t      && exact_log2 (INTVAL (XEXP (varop, 1))) >= 0)\n \t    {\n \t      varop\n@@ -9199,7 +9199,7 @@ simplify_shift_const_1 (enum rtx_code code, enum machine_mode result_mode,\n \tcase ROTATE:\n \t  /* Here we have two nested shifts.  The result is usually the\n \t     AND of a new shift with a mask.  We compute the result below.  */\n-\t  if (GET_CODE (XEXP (varop, 1)) == CONST_INT\n+\t  if (CONST_INT_P (XEXP (varop, 1))\n \t      && INTVAL (XEXP (varop, 1)) >= 0\n \t      && INTVAL (XEXP (varop, 1)) < GET_MODE_BITSIZE (GET_MODE (varop))\n \t      && GET_MODE_BITSIZE (result_mode) <= HOST_BITS_PER_WIDE_INT\n@@ -9307,7 +9307,7 @@ simplify_shift_const_1 (enum rtx_code code, enum machine_mode result_mode,\n \n \t      /* Give up if we can't compute an outer operation to use.  */\n \t      if (mask_rtx == 0\n-\t\t  || GET_CODE (mask_rtx) != CONST_INT\n+\t\t  || !CONST_INT_P (mask_rtx)\n \t\t  || ! merge_outer_ops (&outer_op, &outer_const, AND,\n \t\t\t\t\tINTVAL (mask_rtx),\n \t\t\t\t\tresult_mode, &complement_p))\n@@ -9341,8 +9341,8 @@ simplify_shift_const_1 (enum rtx_code code, enum machine_mode result_mode,\n \t     B is not a constant.  */\n \n \t  else if (GET_CODE (varop) == code\n-\t\t   && GET_CODE (XEXP (varop, 0)) == CONST_INT\n-\t\t   && GET_CODE (XEXP (varop, 1)) != CONST_INT)\n+\t\t   && CONST_INT_P (XEXP (varop, 0))\n+\t\t   && !CONST_INT_P (XEXP (varop, 1)))\n \t    {\n \t      rtx new_rtx = simplify_const_binary_operation (code, mode,\n \t\t\t\t\t\t\t XEXP (varop, 0),\n@@ -9395,7 +9395,7 @@ simplify_shift_const_1 (enum rtx_code code, enum machine_mode result_mode,\n \t     what a ZERO_EXTRACT looks like.  Also, some machines have\n \t     (and (shift)) insns.  */\n \n-\t  if (GET_CODE (XEXP (varop, 1)) == CONST_INT\n+\t  if (CONST_INT_P (XEXP (varop, 1))\n \t      /* We can't do this if we have (ashiftrt (xor))  and the\n \t\t constant has its sign bit set in shift_mode.  */\n \t      && !(code == ASHIFTRT && GET_CODE (varop) == XOR\n@@ -9404,7 +9404,7 @@ simplify_shift_const_1 (enum rtx_code code, enum machine_mode result_mode,\n \t      && (new_rtx = simplify_const_binary_operation (code, result_mode,\n \t\t\t\t\t\t\t XEXP (varop, 1),\n \t\t\t\t\t\t\t GEN_INT (count))) != 0\n-\t      && GET_CODE (new_rtx) == CONST_INT\n+\t      && CONST_INT_P (new_rtx)\n \t      && merge_outer_ops (&outer_op, &outer_const, GET_CODE (varop),\n \t\t\t\t  INTVAL (new_rtx), result_mode, &complement_p))\n \t    {\n@@ -9416,7 +9416,7 @@ simplify_shift_const_1 (enum rtx_code code, enum machine_mode result_mode,\n \t     logical expression, make a new logical expression, and apply\n \t     the inverse distributive law.  This also can't be done\n \t     for some (ashiftrt (xor)).  */\n-\t  if (GET_CODE (XEXP (varop, 1)) == CONST_INT\n+\t  if (CONST_INT_P (XEXP (varop, 1))\n \t     && !(code == ASHIFTRT && GET_CODE (varop) == XOR\n \t\t  && 0 > trunc_int_for_mode (INTVAL (XEXP (varop, 1)),\n \t\t\t\t\t     shift_mode)))\n@@ -9528,11 +9528,11 @@ simplify_shift_const_1 (enum rtx_code code, enum machine_mode result_mode,\n \n \t  /* (ashift (plus foo C) N) is (plus (ashift foo N) C').  */\n \t  if (code == ASHIFT\n-\t      && GET_CODE (XEXP (varop, 1)) == CONST_INT\n+\t      && CONST_INT_P (XEXP (varop, 1))\n \t      && (new_rtx = simplify_const_binary_operation (ASHIFT, result_mode,\n \t\t\t\t\t\t\t XEXP (varop, 1),\n \t\t\t\t\t\t\t GEN_INT (count))) != 0\n-\t      && GET_CODE (new_rtx) == CONST_INT\n+\t      && CONST_INT_P (new_rtx)\n \t      && merge_outer_ops (&outer_op, &outer_const, PLUS,\n \t\t\t\t  INTVAL (new_rtx), result_mode, &complement_p))\n \t    {\n@@ -9546,12 +9546,12 @@ simplify_shift_const_1 (enum rtx_code code, enum machine_mode result_mode,\n \t     leg for shift(logical). See details in logical handling above\n \t     for reasoning in doing so.  */\n \t  if (code == LSHIFTRT\n-\t      && GET_CODE (XEXP (varop, 1)) == CONST_INT\n+\t      && CONST_INT_P (XEXP (varop, 1))\n \t      && mode_signbit_p (result_mode, XEXP (varop, 1))\n \t      && (new_rtx = simplify_const_binary_operation (code, result_mode,\n \t\t\t\t\t\t\t XEXP (varop, 1),\n \t\t\t\t\t\t\t GEN_INT (count))) != 0\n-\t      && GET_CODE (new_rtx) == CONST_INT\n+\t      && CONST_INT_P (new_rtx)\n \t      && merge_outer_ops (&outer_op, &outer_const, XOR,\n \t\t\t\t  INTVAL (new_rtx), result_mode, &complement_p))\n \t    {\n@@ -9573,7 +9573,7 @@ simplify_shift_const_1 (enum rtx_code code, enum machine_mode result_mode,\n \t      && GET_CODE (XEXP (varop, 0)) == ASHIFTRT\n \t      && count == (GET_MODE_BITSIZE (GET_MODE (varop)) - 1)\n \t      && (code == LSHIFTRT || code == ASHIFTRT)\n-\t      && GET_CODE (XEXP (XEXP (varop, 0), 1)) == CONST_INT\n+\t      && CONST_INT_P (XEXP (XEXP (varop, 0), 1))\n \t      && INTVAL (XEXP (XEXP (varop, 0), 1)) == count\n \t      && rtx_equal_p (XEXP (XEXP (varop, 0), 0), XEXP (varop, 1)))\n \t    {\n@@ -9593,7 +9593,7 @@ simplify_shift_const_1 (enum rtx_code code, enum machine_mode result_mode,\n \t     if the truncate does not affect the value.  */\n \t  if (code == LSHIFTRT\n \t      && GET_CODE (XEXP (varop, 0)) == LSHIFTRT\n-\t      && GET_CODE (XEXP (XEXP (varop, 0), 1)) == CONST_INT\n+\t      && CONST_INT_P (XEXP (XEXP (varop, 0), 1))\n \t      && (INTVAL (XEXP (XEXP (varop, 0), 1))\n \t\t  >= (GET_MODE_BITSIZE (GET_MODE (XEXP (varop, 0)))\n \t\t      - GET_MODE_BITSIZE (GET_MODE (varop)))))\n@@ -9881,7 +9881,7 @@ gen_lowpart_for_combine (enum machine_mode omode, rtx x)\n      constant integer or has a mode the same size.  */\n   if (GET_MODE_SIZE (omode) > UNITS_PER_WORD\n       && ! ((imode == VOIDmode\n-\t     && (GET_CODE (x) == CONST_INT\n+\t     && (CONST_INT_P (x)\n \t\t || GET_CODE (x) == CONST_DOUBLE))\n \t    || isize == osize))\n     goto fail;\n@@ -9999,7 +9999,7 @@ simplify_comparison (enum rtx_code code, rtx *pop0, rtx *pop1)\n \t  && GET_CODE (XEXP (XEXP (op1, 0), 0)) == SUBREG\n \t  && (GET_MODE (SUBREG_REG (XEXP (XEXP (op0, 0), 0)))\n \t      == GET_MODE (SUBREG_REG (XEXP (XEXP (op1, 0), 0))))\n-\t  && GET_CODE (XEXP (op0, 1)) == CONST_INT\n+\t  && CONST_INT_P (XEXP (op0, 1))\n \t  && XEXP (op0, 1) == XEXP (op1, 1)\n \t  && XEXP (op0, 1) == XEXP (XEXP (op0, 0), 1)\n \t  && XEXP (op0, 1) == XEXP (XEXP (op1, 0), 1)\n@@ -10025,7 +10025,7 @@ simplify_comparison (enum rtx_code code, rtx *pop0, rtx *pop1)\n \t      || (GET_CODE (op0) == ASHIFTRT\n \t\t  && (code != GTU && code != LTU\n \t\t      && code != GEU && code != LEU)))\n-\t  && GET_CODE (XEXP (op0, 1)) == CONST_INT\n+\t  && CONST_INT_P (XEXP (op0, 1))\n \t  && INTVAL (XEXP (op0, 1)) >= 0\n \t  && INTVAL (XEXP (op0, 1)) < HOST_BITS_PER_WIDE_INT\n \t  && XEXP (op0, 1) == XEXP (op1, 1))\n@@ -10060,8 +10060,8 @@ simplify_comparison (enum rtx_code code, rtx *pop0, rtx *pop1)\n \t present.  */\n \n       else if (GET_CODE (op0) == AND && GET_CODE (op1) == AND\n-\t       && GET_CODE (XEXP (op0, 1)) == CONST_INT\n-\t       && GET_CODE (XEXP (op1, 1)) == CONST_INT)\n+\t       && CONST_INT_P (XEXP (op0, 1))\n+\t       && CONST_INT_P (XEXP (op1, 1)))\n \t{\n \t  rtx inner_op0 = XEXP (op0, 0);\n \t  rtx inner_op1 = XEXP (op1, 0);\n@@ -10134,7 +10134,7 @@ simplify_comparison (enum rtx_code code, rtx *pop0, rtx *pop1)\n      but some things may really be comparisons with zero but not start\n      out looking that way.  */\n \n-  while (GET_CODE (op1) == CONST_INT)\n+  while (CONST_INT_P (op1))\n     {\n       enum machine_mode mode = GET_MODE (op0);\n       unsigned int mode_width = GET_MODE_BITSIZE (mode);\n@@ -10358,7 +10358,7 @@ simplify_comparison (enum rtx_code code, rtx *pop0, rtx *pop1)\n \t  /* Except we can't if SHIFT_COUNT_TRUNCATED is set, since we might\n \t     have already reduced the shift count modulo the word size.  */\n \t  if (!SHIFT_COUNT_TRUNCATED\n-\t      && GET_CODE (XEXP (op0, 0)) == CONST_INT\n+\t      && CONST_INT_P (XEXP (op0, 0))\n \t      && XEXP (op0, 1) == const1_rtx\n \t      && equality_comparison_p && const_op == 0\n \t      && (i = exact_log2 (INTVAL (XEXP (op0, 0)))) >= 0)\n@@ -10457,7 +10457,7 @@ simplify_comparison (enum rtx_code code, rtx *pop0, rtx *pop1)\n \tcase ROTATE:\n \t  /* If we are testing equality and our count is a constant, we\n \t     can perform the inverse operation on our RHS.  */\n-\t  if (equality_comparison_p && GET_CODE (XEXP (op0, 1)) == CONST_INT\n+\t  if (equality_comparison_p && CONST_INT_P (XEXP (op0, 1))\n \t      && (tem = simplify_binary_operation (ROTATERT, mode,\n \t\t\t\t\t\t   op1, XEXP (op0, 1))) != 0)\n \t    {\n@@ -10470,7 +10470,7 @@ simplify_comparison (enum rtx_code code, rtx *pop0, rtx *pop1)\n \t     a particular bit.  Convert it to an AND of a constant of that\n \t     bit.  This will be converted into a ZERO_EXTRACT.  */\n \t  if (const_op == 0 && sign_bit_comparison_p\n-\t      && GET_CODE (XEXP (op0, 1)) == CONST_INT\n+\t      && CONST_INT_P (XEXP (op0, 1))\n \t      && mode_width <= HOST_BITS_PER_WIDE_INT)\n \t    {\n \t      op0 = simplify_and_const_int (NULL_RTX, mode, XEXP (op0, 0),\n@@ -10540,7 +10540,7 @@ simplify_comparison (enum rtx_code code, rtx *pop0, rtx *pop1)\n \t      && subreg_lowpart_p (op0)\n \t      && GET_MODE_BITSIZE (GET_MODE (SUBREG_REG (op0))) > mode_width\n \t      && GET_CODE (SUBREG_REG (op0)) == PLUS\n-\t      && GET_CODE (XEXP (SUBREG_REG (op0), 1)) == CONST_INT)\n+\t      && CONST_INT_P (XEXP (SUBREG_REG (op0), 1)))\n \t    {\n \t      enum machine_mode inner_mode = GET_MODE (SUBREG_REG (op0));\n \t      rtx a = XEXP (SUBREG_REG (op0), 0);\n@@ -10650,7 +10650,7 @@ simplify_comparison (enum rtx_code code, rtx *pop0, rtx *pop1)\n \t  /* The sign bit of (minus (ashiftrt X C) X), where C is the number\n \t     of bits in X minus 1, is one iff X > 0.  */\n \t  if (sign_bit_comparison_p && GET_CODE (XEXP (op0, 0)) == ASHIFTRT\n-\t      && GET_CODE (XEXP (XEXP (op0, 0), 1)) == CONST_INT\n+\t      && CONST_INT_P (XEXP (XEXP (op0, 0), 1))\n \t      && (unsigned HOST_WIDE_INT) INTVAL (XEXP (XEXP (op0, 0), 1))\n \t\t == mode_width - 1\n \t      && rtx_equal_p (XEXP (XEXP (op0, 0), 0), XEXP (op0, 1)))\n@@ -10751,9 +10751,9 @@ simplify_comparison (enum rtx_code code, rtx *pop0, rtx *pop1)\n \t     in STORE_FLAG_VALUE, we can compare with X.  */\n \t  if (const_op == 0 && equality_comparison_p\n \t      && mode_width <= HOST_BITS_PER_WIDE_INT\n-\t      && GET_CODE (XEXP (op0, 1)) == CONST_INT\n+\t      && CONST_INT_P (XEXP (op0, 1))\n \t      && GET_CODE (XEXP (op0, 0)) == LSHIFTRT\n-\t      && GET_CODE (XEXP (XEXP (op0, 0), 1)) == CONST_INT\n+\t      && CONST_INT_P (XEXP (XEXP (op0, 0), 1))\n \t      && INTVAL (XEXP (XEXP (op0, 0), 1)) >= 0\n \t      && INTVAL (XEXP (XEXP (op0, 0), 1)) < HOST_BITS_PER_WIDE_INT)\n \t    {\n@@ -10774,7 +10774,7 @@ simplify_comparison (enum rtx_code code, rtx *pop0, rtx *pop1)\n \t     the underlying value.  */\n \t  if (equality_comparison_p\n \t      && const_op == 0\n-\t      && GET_CODE (XEXP (op0, 1)) == CONST_INT\n+\t      && CONST_INT_P (XEXP (op0, 1))\n \t      && mode_width <= HOST_BITS_PER_WIDE_INT\n \t      && ((INTVAL (XEXP (op0, 1)) & GET_MODE_MASK (mode))\n \t\t  == (unsigned HOST_WIDE_INT) 1 << (mode_width - 1)))\n@@ -10798,7 +10798,7 @@ simplify_comparison (enum rtx_code code, rtx *pop0, rtx *pop1)\n \t     known to hold a value of the required mode the\n \t     transformation is invalid.  */\n \t  if ((equality_comparison_p || unsigned_comparison_p)\n-\t      && GET_CODE (XEXP (op0, 1)) == CONST_INT\n+\t      && CONST_INT_P (XEXP (op0, 1))\n \t      && (i = exact_log2 ((INTVAL (XEXP (op0, 1))\n \t\t\t\t   & GET_MODE_MASK (mode))\n \t\t\t\t  + 1)) >= 0\n@@ -10838,7 +10838,7 @@ simplify_comparison (enum rtx_code code, rtx *pop0, rtx *pop1)\n #endif\n \t\t      || (mode_width <= GET_MODE_BITSIZE (tmode)\n \t\t\t  && subreg_lowpart_p (XEXP (op0, 0))))\n-\t\t  && GET_CODE (XEXP (op0, 1)) == CONST_INT\n+\t\t  && CONST_INT_P (XEXP (op0, 1))\n \t\t  && mode_width <= HOST_BITS_PER_WIDE_INT\n \t\t  && GET_MODE_BITSIZE (tmode) <= HOST_BITS_PER_WIDE_INT\n \t\t  && ((c1 = INTVAL (XEXP (op0, 1))) & ~mask) == 0\n@@ -10877,8 +10877,8 @@ simplify_comparison (enum rtx_code code, rtx *pop0, rtx *pop1)\n \n \t      if (GET_CODE (shift_op) == NOT\n \t\t  || (GET_CODE (shift_op) == XOR\n-\t\t      && GET_CODE (XEXP (shift_op, 1)) == CONST_INT\n-\t\t      && GET_CODE (shift_count) == CONST_INT\n+\t\t      && CONST_INT_P (XEXP (shift_op, 1))\n+\t\t      && CONST_INT_P (shift_count)\n \t\t      && GET_MODE_BITSIZE (mode) <= HOST_BITS_PER_WIDE_INT\n \t\t      && (INTVAL (XEXP (shift_op, 1))\n \t\t\t  == (HOST_WIDE_INT) 1 << INTVAL (shift_count))))\n@@ -10899,7 +10899,7 @@ simplify_comparison (enum rtx_code code, rtx *pop0, rtx *pop1)\n \t     are known to be zero, we can do this by comparing FOO with C\n \t     shifted right N bits so long as the low-order N bits of C are\n \t     zero.  */\n-\t  if (GET_CODE (XEXP (op0, 1)) == CONST_INT\n+\t  if (CONST_INT_P (XEXP (op0, 1))\n \t      && INTVAL (XEXP (op0, 1)) >= 0\n \t      && ((INTVAL (XEXP (op0, 1)) + ! equality_comparison_p)\n \t\t  < HOST_BITS_PER_WIDE_INT)\n@@ -10922,7 +10922,7 @@ simplify_comparison (enum rtx_code code, rtx *pop0, rtx *pop1)\n \n \t  /* If we are doing a sign bit comparison, it means we are testing\n \t     a particular bit.  Convert it to the appropriate AND.  */\n-\t  if (sign_bit_comparison_p && GET_CODE (XEXP (op0, 1)) == CONST_INT\n+\t  if (sign_bit_comparison_p && CONST_INT_P (XEXP (op0, 1))\n \t      && mode_width <= HOST_BITS_PER_WIDE_INT)\n \t    {\n \t      op0 = simplify_and_const_int (NULL_RTX, mode, XEXP (op0, 0),\n@@ -10937,7 +10937,7 @@ simplify_comparison (enum rtx_code code, rtx *pop0, rtx *pop1)\n \t     the low bit to the sign bit, we can convert this to an AND of the\n \t     low-order bit.  */\n \t  if (const_op == 0 && equality_comparison_p\n-\t      && GET_CODE (XEXP (op0, 1)) == CONST_INT\n+\t      && CONST_INT_P (XEXP (op0, 1))\n \t      && (unsigned HOST_WIDE_INT) INTVAL (XEXP (op0, 1))\n \t\t == mode_width - 1)\n \t    {\n@@ -10951,7 +10951,7 @@ simplify_comparison (enum rtx_code code, rtx *pop0, rtx *pop1)\n \t  /* If this is an equality comparison with zero, we can do this\n \t     as a logical shift, which might be much simpler.  */\n \t  if (equality_comparison_p && const_op == 0\n-\t      && GET_CODE (XEXP (op0, 1)) == CONST_INT)\n+\t      && CONST_INT_P (XEXP (op0, 1)))\n \t    {\n \t      op0 = simplify_shift_const (NULL_RTX, LSHIFTRT, mode,\n \t\t\t\t\t  XEXP (op0, 0),\n@@ -10962,7 +10962,7 @@ simplify_comparison (enum rtx_code code, rtx *pop0, rtx *pop1)\n \t  /* If OP0 is a sign extension and CODE is not an unsigned comparison,\n \t     do the comparison in a narrower mode.  */\n \t  if (! unsigned_comparison_p\n-\t      && GET_CODE (XEXP (op0, 1)) == CONST_INT\n+\t      && CONST_INT_P (XEXP (op0, 1))\n \t      && GET_CODE (XEXP (op0, 0)) == ASHIFT\n \t      && XEXP (op0, 1) == XEXP (XEXP (op0, 0), 1)\n \t      && (tmode = mode_for_size (mode_width - INTVAL (XEXP (op0, 1)),\n@@ -10979,9 +10979,9 @@ simplify_comparison (enum rtx_code code, rtx *pop0, rtx *pop1)\n \t     constant, which is usually represented with the PLUS\n \t     between the shifts.  */\n \t  if (! unsigned_comparison_p\n-\t      && GET_CODE (XEXP (op0, 1)) == CONST_INT\n+\t      && CONST_INT_P (XEXP (op0, 1))\n \t      && GET_CODE (XEXP (op0, 0)) == PLUS\n-\t      && GET_CODE (XEXP (XEXP (op0, 0), 1)) == CONST_INT\n+\t      && CONST_INT_P (XEXP (XEXP (op0, 0), 1))\n \t      && GET_CODE (XEXP (XEXP (op0, 0), 0)) == ASHIFT\n \t      && XEXP (op0, 1) == XEXP (XEXP (XEXP (op0, 0), 0), 1)\n \t      && (tmode = mode_for_size (mode_width - INTVAL (XEXP (op0, 1)),\n@@ -11007,7 +11007,7 @@ simplify_comparison (enum rtx_code code, rtx *pop0, rtx *pop1)\n \t     the low order N bits of FOO are known to be zero, we can do this\n \t     by comparing FOO with C shifted left N bits so long as no\n \t     overflow occurs.  */\n-\t  if (GET_CODE (XEXP (op0, 1)) == CONST_INT\n+\t  if (CONST_INT_P (XEXP (op0, 1))\n \t      && INTVAL (XEXP (op0, 1)) >= 0\n \t      && INTVAL (XEXP (op0, 1)) < HOST_BITS_PER_WIDE_INT\n \t      && mode_width <= HOST_BITS_PER_WIDE_INT\n@@ -11035,7 +11035,7 @@ simplify_comparison (enum rtx_code code, rtx *pop0, rtx *pop1)\n \t     can replace this with an LT or GE comparison.  */\n \t  if (const_op == 0\n \t      && (equality_comparison_p || sign_bit_comparison_p)\n-\t      && GET_CODE (XEXP (op0, 1)) == CONST_INT\n+\t      && CONST_INT_P (XEXP (op0, 1))\n \t      && (unsigned HOST_WIDE_INT) INTVAL (XEXP (op0, 1))\n \t\t == mode_width - 1)\n \t    {\n@@ -11134,7 +11134,7 @@ simplify_comparison (enum rtx_code code, rtx *pop0, rtx *pop1)\n \t\t\t    || code == LEU || code == LTU)\n \t\t\t   && (nonzero_bits (op0, tmode)\n \t\t\t       & ~GET_MODE_MASK (mode)) == 0\n-\t\t\t   && ((GET_CODE (op1) == CONST_INT\n+\t\t\t   && ((CONST_INT_P (op1)\n \t\t\t\t|| (nonzero_bits (op1, tmode)\n \t\t\t\t    & ~GET_MODE_MASK (mode)) == 0)));\n \n@@ -11157,7 +11157,7 @@ simplify_comparison (enum rtx_code code, rtx *pop0, rtx *pop1)\n \t\t\t\t\t\t\tXEXP (op0, 1)));\n \n \t      op0 = gen_lowpart (tmode, op0);\n-\t      if (zero_extended && GET_CODE (op1) == CONST_INT)\n+\t      if (zero_extended && CONST_INT_P (op1))\n \t\top1 = GEN_INT (INTVAL (op1) & GET_MODE_MASK (mode));\n \t      op1 = gen_lowpart (tmode, op1);\n \t      break;"}, {"sha": "5f83892c79fe6aecaf224d4e769fb9b7d3b6cf56", "filename": "gcc/cse.c", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/481683e1d53b27779b31c1816606eb17975a9b1f/gcc%2Fcse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/481683e1d53b27779b31c1816606eb17975a9b1f/gcc%2Fcse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcse.c?ref=481683e1d53b27779b31c1816606eb17975a9b1f", "patch": "@@ -643,7 +643,7 @@ fixed_base_plus_p (rtx x)\n       return false;\n \n     case PLUS:\n-      if (GET_CODE (XEXP (x, 1)) != CONST_INT)\n+      if (!CONST_INT_P (XEXP (x, 1)))\n \treturn false;\n       return fixed_base_plus_p (XEXP (x, 0));\n \n@@ -2813,7 +2813,7 @@ cse_rtx_varies_p (const_rtx x, bool from_alias)\n     }\n \n   if (GET_CODE (x) == PLUS\n-      && GET_CODE (XEXP (x, 1)) == CONST_INT\n+      && CONST_INT_P (XEXP (x, 1))\n       && REG_P (XEXP (x, 0))\n       && REGNO_QTY_VALID_P (REGNO (XEXP (x, 0))))\n     {\n@@ -3525,7 +3525,7 @@ fold_rtx (rtx x, rtx insn)\n \n \t  if (y != 0\n \t      && (inner_const = equiv_constant (XEXP (y, 1))) != 0\n-\t      && GET_CODE (inner_const) == CONST_INT\n+\t      && CONST_INT_P (inner_const)\n \t      && INTVAL (inner_const) != 0)\n \t    folded_arg0 = gen_rtx_IOR (mode_arg0, XEXP (y, 0), inner_const);\n \t}\n@@ -3595,7 +3595,7 @@ fold_rtx (rtx x, rtx insn)\n \t     the smallest negative number this would overflow: depending\n \t     on the mode, this would either just be the same value (and\n \t     hence not save anything) or be incorrect.  */\n-\t  if (const_arg1 != 0 && GET_CODE (const_arg1) == CONST_INT\n+\t  if (const_arg1 != 0 && CONST_INT_P (const_arg1)\n \t      && INTVAL (const_arg1) < 0\n \t      /* This used to test\n \n@@ -3623,10 +3623,10 @@ fold_rtx (rtx x, rtx insn)\n \tcase MINUS:\n \t  /* If we have (MINUS Y C), see if Y is known to be (PLUS Z C2).\n \t     If so, produce (PLUS Z C2-C).  */\n-\t  if (const_arg1 != 0 && GET_CODE (const_arg1) == CONST_INT)\n+\t  if (const_arg1 != 0 && CONST_INT_P (const_arg1))\n \t    {\n \t      rtx y = lookup_as_function (XEXP (x, 0), PLUS);\n-\t      if (y && GET_CODE (XEXP (y, 1)) == CONST_INT)\n+\t      if (y && CONST_INT_P (XEXP (y, 1)))\n \t\treturn fold_rtx (plus_constant (copy_rtx (y),\n \t\t\t\t\t\t-INTVAL (const_arg1)),\n \t\t\t\t NULL_RTX);\n@@ -3647,7 +3647,7 @@ fold_rtx (rtx x, rtx insn)\n \t     if the intermediate operation's result has only one reference.  */\n \n \t  if (REG_P (folded_arg0)\n-\t      && const_arg1 && GET_CODE (const_arg1) == CONST_INT)\n+\t      && const_arg1 && CONST_INT_P (const_arg1))\n \t    {\n \t      int is_shift\n \t\t= (code == ASHIFT || code == ASHIFTRT || code == LSHIFTRT);\n@@ -3680,7 +3680,7 @@ fold_rtx (rtx x, rtx insn)\n \t\tbreak;\n \n \t      inner_const = equiv_constant (fold_rtx (XEXP (y, 1), 0));\n-\t      if (!inner_const || GET_CODE (inner_const) != CONST_INT)\n+\t      if (!inner_const || !CONST_INT_P (inner_const))\n \t\tbreak;\n \n \t      /* Don't associate these operations if they are a PLUS with the\n@@ -3734,7 +3734,7 @@ fold_rtx (rtx x, rtx insn)\n \t\t of shifts.  */\n \n \t      if (is_shift\n-\t\t  && GET_CODE (new_const) == CONST_INT\n+\t\t  && CONST_INT_P (new_const)\n \t\t  && INTVAL (new_const) >= GET_MODE_BITSIZE (mode))\n \t\t{\n \t\t  /* As an exception, we can turn an ASHIFTRT of this\n@@ -4506,8 +4506,8 @@ cse_insn (rtx insn)\n \t{\n \t  rtx width = XEXP (SET_DEST (sets[i].rtl), 1);\n \n-\t  if (GET_CODE (src) == CONST_INT\n-\t      && GET_CODE (width) == CONST_INT\n+\t  if (CONST_INT_P (src)\n+\t      && CONST_INT_P (width)\n \t      && INTVAL (width) < HOST_BITS_PER_WIDE_INT\n \t      && (INTVAL (src) & ((HOST_WIDE_INT) (-1) << INTVAL (width))))\n \t    src_folded\n@@ -4668,7 +4668,7 @@ cse_insn (rtx insn)\n       /* See if we have a CONST_INT that is already in a register in a\n \t wider mode.  */\n \n-      if (src_const && src_related == 0 && GET_CODE (src_const) == CONST_INT\n+      if (src_const && src_related == 0 && CONST_INT_P (src_const)\n \t  && GET_MODE_CLASS (mode) == MODE_INT\n \t  && GET_MODE_BITSIZE (mode) < BITS_PER_WORD)\n \t{\n@@ -4703,7 +4703,7 @@ cse_insn (rtx insn)\n \t value.  */\n \n       if (flag_expensive_optimizations && ! src_related\n-\t  && GET_CODE (src) == AND && GET_CODE (XEXP (src, 1)) == CONST_INT\n+\t  && GET_CODE (src) == AND && CONST_INT_P (XEXP (src, 1))\n \t  && GET_MODE_SIZE (mode) < UNITS_PER_WORD)\n \t{\n \t  enum machine_mode tmode;\n@@ -5226,8 +5226,8 @@ cse_insn (rtx insn)\n \t{\n \t  rtx width = XEXP (SET_DEST (sets[i].rtl), 1);\n \n-\t  if (src_const != 0 && GET_CODE (src_const) == CONST_INT\n-\t      && GET_CODE (width) == CONST_INT\n+\t  if (src_const != 0 && CONST_INT_P (src_const)\n+\t      && CONST_INT_P (width)\n \t      && INTVAL (width) < HOST_BITS_PER_WIDE_INT\n \t      && ! (INTVAL (src_const)\n \t\t    & ((HOST_WIDE_INT) (-1) << INTVAL (width))))"}, {"sha": "456f1359b6f993b43fb68bfe7ded546174e41c41", "filename": "gcc/cselib.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/481683e1d53b27779b31c1816606eb17975a9b1f/gcc%2Fcselib.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/481683e1d53b27779b31c1816606eb17975a9b1f/gcc%2Fcselib.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcselib.c?ref=481683e1d53b27779b31c1816606eb17975a9b1f", "patch": "@@ -236,15 +236,15 @@ entry_and_rtx_equal_p (const void *entry, const void *x_arg)\n   rtx x = CONST_CAST_RTX ((const_rtx)x_arg);\n   enum machine_mode mode = GET_MODE (x);\n \n-  gcc_assert (GET_CODE (x) != CONST_INT && GET_CODE (x) != CONST_FIXED\n+  gcc_assert (!CONST_INT_P (x) && GET_CODE (x) != CONST_FIXED\n \t      && (mode != VOIDmode || GET_CODE (x) != CONST_DOUBLE));\n   \n   if (mode != GET_MODE (v->val_rtx))\n     return 0;\n \n   /* Unwrap X if necessary.  */\n   if (GET_CODE (x) == CONST\n-      && (GET_CODE (XEXP (x, 0)) == CONST_INT\n+      && (CONST_INT_P (XEXP (x, 0))\n \t  || GET_CODE (XEXP (x, 0)) == CONST_FIXED\n \t  || GET_CODE (XEXP (x, 0)) == CONST_DOUBLE))\n     x = XEXP (x, 0);\n@@ -555,7 +555,7 @@ rtx_equal_for_cselib_p (rtx x, rtx y)\n static rtx\n wrap_constant (enum machine_mode mode, rtx x)\n {\n-  if (GET_CODE (x) != CONST_INT && GET_CODE (x) != CONST_FIXED\n+  if (!CONST_INT_P (x) && GET_CODE (x) != CONST_FIXED\n       && (GET_CODE (x) != CONST_DOUBLE || GET_MODE (x) != VOIDmode))\n     return x;\n   gcc_assert (mode != VOIDmode);"}, {"sha": "df11628329b235014874180454ae40b6745fbf5c", "filename": "gcc/dbxout.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/481683e1d53b27779b31c1816606eb17975a9b1f/gcc%2Fdbxout.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/481683e1d53b27779b31c1816606eb17975a9b1f/gcc%2Fdbxout.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdbxout.c?ref=481683e1d53b27779b31c1816606eb17975a9b1f", "patch": "@@ -3032,7 +3032,7 @@ dbxout_symbol_location (tree decl, tree type, const char *suffix, rtx home)\n     }\n   else if (MEM_P (home)\n \t   && GET_CODE (XEXP (home, 0)) == PLUS\n-\t   && GET_CODE (XEXP (XEXP (home, 0), 1)) == CONST_INT)\n+\t   && CONST_INT_P (XEXP (XEXP (home, 0), 1)))\n     {\n       code = N_LSYM;\n       /* RTL looks like (MEM (PLUS (REG...) (CONST_INT...)))\n@@ -3218,7 +3218,7 @@ dbxout_common_check (tree decl, int *value)\n       switch (GET_CODE (sym_addr))\n         {\n         case PLUS:\n-          if (GET_CODE (XEXP (sym_addr, 0)) == CONST_INT)\n+          if (CONST_INT_P (XEXP (sym_addr, 0)))\n             {\n               name =\n                 targetm.strip_name_encoding(XSTR (XEXP (sym_addr, 1), 0));\n@@ -3351,7 +3351,7 @@ dbxout_parms (tree parms)\n \t       If that is not true, we produce meaningless results,\n \t       but do not crash.  */\n \t    if (GET_CODE (inrtl) == PLUS\n-\t\t&& GET_CODE (XEXP (inrtl, 1)) == CONST_INT)\n+\t\t&& CONST_INT_P (XEXP (inrtl, 1)))\n \t      number = INTVAL (XEXP (inrtl, 1));\n \t    else\n \t      number = 0;"}, {"sha": "393c74ca64b734dddcaeda0c6cc0876fe9a47e07", "filename": "gcc/df-scan.c", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/481683e1d53b27779b31c1816606eb17975a9b1f/gcc%2Fdf-scan.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/481683e1d53b27779b31c1816606eb17975a9b1f/gcc%2Fdf-scan.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdf-scan.c?ref=481683e1d53b27779b31c1816606eb17975a9b1f", "patch": "@@ -2964,8 +2964,8 @@ df_def_record_1 (struct df_collection_rec *collection_rec,\n     {\n       flags |= DF_REF_READ_WRITE | DF_REF_PARTIAL | DF_REF_ZERO_EXTRACT;\n       \n-      if (GET_CODE (XEXP (dst, 1)) == CONST_INT\n-\t  && GET_CODE (XEXP (dst, 2)) == CONST_INT)\n+      if (CONST_INT_P (XEXP (dst, 1))\n+\t  && CONST_INT_P (XEXP (dst, 2)))\n \t{\n \t  width = INTVAL (XEXP (dst, 1));\n \t  offset = INTVAL (XEXP (dst, 2));\n@@ -3120,8 +3120,8 @@ df_uses_record (enum df_ref_class cl, struct df_collection_rec *collection_rec,\n \t/* If the parameters to the zero or sign extract are\n \t   constants, strip them off and recurse, otherwise there is\n \t   no information that we can gain from this operation.  */\n-\tif (GET_CODE (XEXP (x, 1)) == CONST_INT\n-\t    && GET_CODE (XEXP (x, 2)) == CONST_INT)\n+\tif (CONST_INT_P (XEXP (x, 1))\n+\t    && CONST_INT_P (XEXP (x, 2)))\n \t  {\n \t    width = INTVAL (XEXP (x, 1));\n \t    offset = INTVAL (XEXP (x, 2));\n@@ -3186,8 +3186,8 @@ df_uses_record (enum df_ref_class cl, struct df_collection_rec *collection_rec,\n \t      break;\n \t    case ZERO_EXTRACT:\n \t      {\n-\t\tif (GET_CODE (XEXP (dst, 1)) == CONST_INT\n-\t\t    && GET_CODE (XEXP (dst, 2)) == CONST_INT)\n+\t\tif (CONST_INT_P (XEXP (dst, 1))\n+\t\t    && CONST_INT_P (XEXP (dst, 2)))\n \t\t  {\n \t\t    width = INTVAL (XEXP (dst, 1));\n \t\t    offset = INTVAL (XEXP (dst, 2));"}, {"sha": "0fc2aa9c1bf3e3341f7109e4ccd1597612155f6e", "filename": "gcc/dse.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/481683e1d53b27779b31c1816606eb17975a9b1f/gcc%2Fdse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/481683e1d53b27779b31c1816606eb17975a9b1f/gcc%2Fdse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdse.c?ref=481683e1d53b27779b31c1816606eb17975a9b1f", "patch": "@@ -1150,7 +1150,7 @@ canon_address (rtx mem,\n   if (GET_CODE (address) == CONST)\n     address = XEXP (address, 0);\n \n-  if (GET_CODE (address) == PLUS && GET_CODE (XEXP (address, 1)) == CONST_INT)\n+  if (GET_CODE (address) == PLUS && CONST_INT_P (XEXP (address, 1)))\n     {\n       *offset = INTVAL (XEXP (address, 1));\n       address = XEXP (address, 0);"}, {"sha": "6f21ff67d52f01e60682f335552466a4f964615a", "filename": "gcc/dwarf2asm.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/481683e1d53b27779b31c1816606eb17975a9b1f/gcc%2Fdwarf2asm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/481683e1d53b27779b31c1816606eb17975a9b1f/gcc%2Fdwarf2asm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdwarf2asm.c?ref=481683e1d53b27779b31c1816606eb17975a9b1f", "patch": "@@ -52,7 +52,7 @@ dw2_assemble_integer (int size, rtx x)\n   if (op)\n     {\n       fputs (op, asm_out_file);\n-      if (GET_CODE (x) == CONST_INT)\n+      if (CONST_INT_P (x))\n \tfprintf (asm_out_file, HOST_WIDE_INT_PRINT_HEX,\n \t\t (unsigned HOST_WIDE_INT) INTVAL (x));\n       else"}, {"sha": "310c2e23fc672a7274362208fa2225f377139ad7", "filename": "gcc/dwarf2out.c", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/481683e1d53b27779b31c1816606eb17975a9b1f/gcc%2Fdwarf2out.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/481683e1d53b27779b31c1816606eb17975a9b1f/gcc%2Fdwarf2out.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdwarf2out.c?ref=481683e1d53b27779b31c1816606eb17975a9b1f", "patch": "@@ -1197,7 +1197,7 @@ initial_return_save (rtx rtl)\n       /* The return address is at some offset from any value we can\n \t actually load.  For instance, on the SPARC it is in %i7+8. Just\n \t ignore the offset for now; it doesn't matter for unwinding frames.  */\n-      gcc_assert (GET_CODE (XEXP (rtl, 1)) == CONST_INT);\n+      gcc_assert (CONST_INT_P (XEXP (rtl, 1)));\n       initial_return_save (XEXP (rtl, 0));\n       return;\n \n@@ -1239,7 +1239,7 @@ stack_adjust_offset (const_rtx pattern, HOST_WIDE_INT cur_args_size,\n \n       if (! (code == PLUS || code == MINUS)\n \t  || XEXP (src, 0) != stack_pointer_rtx\n-\t  || GET_CODE (XEXP (src, 1)) != CONST_INT)\n+\t  || !CONST_INT_P (XEXP (src, 1)))\n \treturn 0;\n \n       /* (set (reg sp) (plus (reg sp) (const_int))) */\n@@ -1266,7 +1266,7 @@ stack_adjust_offset (const_rtx pattern, HOST_WIDE_INT cur_args_size,\n \t      rtx val = XEXP (XEXP (src, 1), 1);\n \t      /* We handle only adjustments by constant amount.  */\n \t      gcc_assert (GET_CODE (XEXP (src, 1)) == PLUS\n-\t\t\t  && GET_CODE (val) == CONST_INT);\n+\t\t\t  && CONST_INT_P (val));\n \t      offset = -INTVAL (val);\n \t      break;\n \t    }\n@@ -2185,17 +2185,17 @@ dwarf2out_frame_debug_expr (rtx expr, const char *label)\n \n   fde = current_fde ();\n \n-  if (GET_CODE (src) == REG\n+  if (REG_P (src)\n       && fde\n       && fde->drap_reg == REGNO (src)\n       && (fde->drap_reg_saved\n-\t  || GET_CODE (dest) == REG))\n+\t  || REG_P (dest)))\n     {\n       /* Rule 20 */\n       /* If we are saving dynamic realign argument pointer to a\n \t register, the destination is virtual dynamic realign\n \t argument pointer.  It may be used to access argument.  */\n-      if (GET_CODE (dest) == REG)\n+      if (REG_P (dest))\n \t{\n \t  gcc_assert (fde->vdrap_reg == INVALID_REGNUM);\n \t  fde->vdrap_reg = REGNO (dest);\n@@ -2296,7 +2296,7 @@ dwarf2out_frame_debug_expr (rtx expr, const char *label)\n \n \t      gcc_assert (REG_P (XEXP (src, 0))\n \t\t\t  && (unsigned) REGNO (XEXP (src, 0)) == cfa.reg\n-\t\t\t  && GET_CODE (XEXP (src, 1)) == CONST_INT);\n+\t\t\t  && CONST_INT_P (XEXP (src, 1)));\n \t      offset = INTVAL (XEXP (src, 1));\n \t      if (GET_CODE (src) != MINUS)\n \t\toffset = -offset;\n@@ -2310,7 +2310,7 @@ dwarf2out_frame_debug_expr (rtx expr, const char *label)\n \t      /* Rule 4 */\n \t      if (REG_P (XEXP (src, 0))\n \t\t  && REGNO (XEXP (src, 0)) == cfa.reg\n-\t\t  && GET_CODE (XEXP (src, 1)) == CONST_INT)\n+\t\t  && CONST_INT_P (XEXP (src, 1)))\n \t\t{\n \t\t  /* Setting a temporary CFA register that will be copied\n \t\t     into the FP later on.  */\n@@ -2336,7 +2336,7 @@ dwarf2out_frame_debug_expr (rtx expr, const char *label)\n \n \t      /* Rule 9 */\n \t      else if (GET_CODE (src) == LO_SUM\n-\t\t       && GET_CODE (XEXP (src, 1)) == CONST_INT)\n+\t\t       && CONST_INT_P (XEXP (src, 1)))\n \t\t{\n \t\t  cfa_temp.reg = REGNO (dest);\n \t\t  cfa_temp.offset = INTVAL (XEXP (src, 1));\n@@ -2356,7 +2356,7 @@ dwarf2out_frame_debug_expr (rtx expr, const char *label)\n \tcase IOR:\n \t  gcc_assert (REG_P (XEXP (src, 0))\n \t\t      && (unsigned) REGNO (XEXP (src, 0)) == cfa_temp.reg\n-\t\t      && GET_CODE (XEXP (src, 1)) == CONST_INT);\n+\t\t      && CONST_INT_P (XEXP (src, 1)));\n \n \t  if ((unsigned) REGNO (dest) != cfa_temp.reg)\n \t    cfa_temp.reg = REGNO (dest);\n@@ -2463,7 +2463,7 @@ dwarf2out_frame_debug_expr (rtx expr, const char *label)\n \t  {\n \t    int regno;\n \n-\t    gcc_assert (GET_CODE (XEXP (XEXP (dest, 0), 1)) == CONST_INT\n+\t    gcc_assert (CONST_INT_P (XEXP (XEXP (dest, 0), 1))\n \t\t\t&& REG_P (XEXP (XEXP (dest, 0), 0)));\n \t    offset = INTVAL (XEXP (XEXP (dest, 0), 1));\n \t    if (GET_CODE (XEXP (dest, 0)) == MINUS)\n@@ -10277,7 +10277,7 @@ is_based_loc (const_rtx rtl)\n   return (GET_CODE (rtl) == PLUS\n \t  && ((REG_P (XEXP (rtl, 0))\n \t       && REGNO (XEXP (rtl, 0)) < FIRST_PSEUDO_REGISTER\n-\t       && GET_CODE (XEXP (rtl, 1)) == CONST_INT)));\n+\t       && CONST_INT_P (XEXP (rtl, 1)))));\n }\n \n /* Return a descriptor that describes the concatenation of N locations\n@@ -10498,7 +10498,7 @@ mem_loc_descriptor (rtx rtl, enum machine_mode mode,\n \t  if (mem_loc_result == 0)\n \t    break;\n \n-\t  if (GET_CODE (XEXP (rtl, 1)) == CONST_INT)\n+\t  if (CONST_INT_P (XEXP (rtl, 1)))\n \t    loc_descr_plus_const (&mem_loc_result, INTVAL (XEXP (rtl, 1)));\n \t  else\n \t    {\n@@ -10832,7 +10832,7 @@ loc_descriptor_from_tree_1 (tree loc, int want_address)\n \n \tif (rtl == NULL_RTX)\n \t  return 0;\n-\telse if (GET_CODE (rtl) == CONST_INT)\n+\telse if (CONST_INT_P (rtl))\n \t  {\n \t    HOST_WIDE_INT val = INTVAL (rtl);\n \t    if (TYPE_UNSIGNED (TREE_TYPE (loc)))"}, {"sha": "df2b4b749b3bac01db34c72d4343d69b832911dd", "filename": "gcc/emit-rtl.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/481683e1d53b27779b31c1816606eb17975a9b1f/gcc%2Femit-rtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/481683e1d53b27779b31c1816606eb17975a9b1f/gcc%2Femit-rtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Femit-rtl.c?ref=481683e1d53b27779b31c1816606eb17975a9b1f", "patch": "@@ -975,7 +975,7 @@ set_reg_attrs_from_value (rtx reg, rtx x)\n   offset = byte_lowpart_offset (GET_MODE (reg), GET_MODE (x));\n   if (MEM_P (x))\n     {\n-      if (MEM_OFFSET (x) && GET_CODE (MEM_OFFSET (x)) == CONST_INT)\n+      if (MEM_OFFSET (x) && CONST_INT_P (MEM_OFFSET (x)))\n \tREG_ATTRS (reg)\n \t  = get_reg_attrs (MEM_EXPR (x), INTVAL (MEM_OFFSET (x)) + offset);\n       if (MEM_POINTER (x))\n@@ -1181,7 +1181,7 @@ gen_lowpart_common (enum machine_mode mode, rtx x)\n   /* Unfortunately, this routine doesn't take a parameter for the mode of X,\n      so we have to make one up.  Yuk.  */\n   innermode = GET_MODE (x);\n-  if (GET_CODE (x) == CONST_INT\n+  if (CONST_INT_P (x)\n       && msize * BITS_PER_UNIT <= HOST_BITS_PER_WIDE_INT)\n     innermode = mode_for_size (HOST_BITS_PER_WIDE_INT, MODE_INT, 0);\n   else if (innermode == VOIDmode)\n@@ -1226,7 +1226,7 @@ gen_lowpart_common (enum machine_mode mode, rtx x)\n     }\n   else if (GET_CODE (x) == SUBREG || REG_P (x)\n \t   || GET_CODE (x) == CONCAT || GET_CODE (x) == CONST_VECTOR\n-\t   || GET_CODE (x) == CONST_DOUBLE || GET_CODE (x) == CONST_INT)\n+\t   || GET_CODE (x) == CONST_DOUBLE || CONST_INT_P (x))\n     return simplify_gen_subreg (mode, x, innermode, offset);\n \n   /* Otherwise, we can't do this.  */\n@@ -2281,7 +2281,7 @@ set_mem_attrs_for_spill (rtx mem)\n   addr = XEXP (mem, 0);\n   offset = const0_rtx;\n   if (GET_CODE (addr) == PLUS\n-      && GET_CODE (XEXP (addr, 1)) == CONST_INT)\n+      && CONST_INT_P (XEXP (addr, 1)))\n     offset = XEXP (addr, 1);\n \n   MEM_ATTRS (mem) = get_mem_attrs (alias, expr, offset,"}, {"sha": "95163cc356b6f07a5895e2db7069ac03993340c1", "filename": "gcc/except.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/481683e1d53b27779b31c1816606eb17975a9b1f/gcc%2Fexcept.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/481683e1d53b27779b31c1816606eb17975a9b1f/gcc%2Fexcept.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexcept.c?ref=481683e1d53b27779b31c1816606eb17975a9b1f", "patch": "@@ -2820,7 +2820,7 @@ for_each_eh_label (void (*callback) (rtx))\n     {\n       struct eh_region_d *r = VEC_index (eh_region, cfun->eh->region_array, i);\n       if (r && r->region_number == i && r->label\n-          && GET_CODE (r->label) == CODE_LABEL)\n+          && LABEL_P (r->label))\n \t(*callback) (r->label);\n     }\n }\n@@ -4408,19 +4408,19 @@ dump_eh_tree (FILE * out, struct function *fun)\n       if (i->landing_pad)\n \t{\n           fprintf (out, \" landing_pad:%i\", INSN_UID (i->landing_pad));\n-\t  if (GET_CODE (i->landing_pad) == NOTE)\n+\t  if (NOTE_P (i->landing_pad))\n \t    fprintf (out, \" (deleted)\");\n         }\n       if (i->post_landing_pad)\n \t{\n           fprintf (out, \" post_landing_pad:%i\", INSN_UID (i->post_landing_pad));\n-\t  if (GET_CODE (i->post_landing_pad) == NOTE)\n+\t  if (NOTE_P (i->post_landing_pad))\n \t    fprintf (out, \" (deleted)\");\n \t}\n       if (i->resume)\n \t{\n           fprintf (out, \" resume:%i\", INSN_UID (i->resume));\n-\t  if (GET_CODE (i->resume) == NOTE)\n+\t  if (NOTE_P (i->resume))\n \t    fprintf (out, \" (deleted)\");\n \t}\n       if (i->may_contain_throw)"}, {"sha": "198df220fbd951e5e67b26289ed44fd213dea3af", "filename": "gcc/explow.c", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/481683e1d53b27779b31c1816606eb17975a9b1f/gcc%2Fexplow.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/481683e1d53b27779b31c1816606eb17975a9b1f/gcc%2Fexplow.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexplow.c?ref=481683e1d53b27779b31c1816606eb17975a9b1f", "patch": "@@ -153,7 +153,7 @@ plus_constant (rtx x, HOST_WIDE_INT c)\n \t We may not immediately return from the recursive call here, lest\n \t all_constant gets lost.  */\n \n-      if (GET_CODE (XEXP (x, 1)) == CONST_INT)\n+      if (CONST_INT_P (XEXP (x, 1)))\n \t{\n \t  c += INTVAL (XEXP (x, 1));\n \n@@ -211,10 +211,10 @@ eliminate_constant_term (rtx x, rtx *constptr)\n     return x;\n \n   /* First handle constants appearing at this level explicitly.  */\n-  if (GET_CODE (XEXP (x, 1)) == CONST_INT\n+  if (CONST_INT_P (XEXP (x, 1))\n       && 0 != (tem = simplify_binary_operation (PLUS, GET_MODE (x), *constptr,\n \t\t\t\t\t\tXEXP (x, 1)))\n-      && GET_CODE (tem) == CONST_INT)\n+      && CONST_INT_P (tem))\n     {\n       *constptr = tem;\n       return eliminate_constant_term (XEXP (x, 0), constptr);\n@@ -226,7 +226,7 @@ eliminate_constant_term (rtx x, rtx *constptr)\n   if ((x1 != XEXP (x, 1) || x0 != XEXP (x, 0))\n       && 0 != (tem = simplify_binary_operation (PLUS, GET_MODE (x),\n \t\t\t\t\t\t*constptr, tem))\n-      && GET_CODE (tem) == CONST_INT)\n+      && CONST_INT_P (tem))\n     {\n       *constptr = tem;\n       return gen_rtx_PLUS (GET_MODE (x), x0, x1);\n@@ -388,7 +388,7 @@ convert_memory_address (enum machine_mode to_mode ATTRIBUTE_UNUSED,\n \t narrower.  */\n       if (GET_MODE_SIZE (to_mode) < GET_MODE_SIZE (from_mode)\n \t  || (GET_CODE (x) == PLUS\n-\t      && GET_CODE (XEXP (x, 1)) == CONST_INT\n+\t      && CONST_INT_P (XEXP (x, 1))\n \t      && (XEXP (x, 1) == convert_memory_address (to_mode, XEXP (x, 1))\n                  || POINTERS_EXTEND_UNSIGNED < 0)))\n \treturn gen_rtx_fmt_ee (GET_CODE (x), to_mode,\n@@ -504,7 +504,7 @@ memory_address (enum machine_mode mode, rtx x)\n     mark_reg_pointer (x, BITS_PER_UNIT);\n   else if (GET_CODE (x) == PLUS\n \t   && REG_P (XEXP (x, 0))\n-\t   && GET_CODE (XEXP (x, 1)) == CONST_INT)\n+\t   && CONST_INT_P (XEXP (x, 1)))\n     mark_reg_pointer (XEXP (x, 0), BITS_PER_UNIT);\n \n   /* OLDX may have been the address on a temporary.  Update the address\n@@ -551,7 +551,7 @@ use_anchored_address (rtx x)\n   offset = 0;\n   if (GET_CODE (base) == CONST\n       && GET_CODE (XEXP (base, 0)) == PLUS\n-      && GET_CODE (XEXP (XEXP (base, 0), 1)) == CONST_INT)\n+      && CONST_INT_P (XEXP (XEXP (base, 0), 1)))\n     {\n       offset += INTVAL (XEXP (XEXP (base, 0), 1));\n       base = XEXP (XEXP (base, 0), 0);\n@@ -689,7 +689,7 @@ force_reg (enum machine_mode mode, rtx x)\n     else if (GET_CODE (x) == CONST\n \t     && GET_CODE (XEXP (x, 0)) == PLUS\n \t     && GET_CODE (XEXP (XEXP (x, 0), 0)) == SYMBOL_REF\n-\t     && GET_CODE (XEXP (XEXP (x, 0), 1)) == CONST_INT)\n+\t     && CONST_INT_P (XEXP (XEXP (x, 0), 1)))\n       {\n \trtx s = XEXP (XEXP (x, 0), 0);\n \trtx c = XEXP (XEXP (x, 0), 1);\n@@ -820,7 +820,7 @@ adjust_stack (rtx adjust)\n \n   /* We expect all variable sized adjustments to be multiple of\n      PREFERRED_STACK_BOUNDARY.  */\n-  if (GET_CODE (adjust) == CONST_INT)\n+  if (CONST_INT_P (adjust))\n     stack_pointer_delta -= INTVAL (adjust);\n \n   temp = expand_binop (Pmode,\n@@ -849,7 +849,7 @@ anti_adjust_stack (rtx adjust)\n \n   /* We expect all variable sized adjustments to be multiple of\n      PREFERRED_STACK_BOUNDARY.  */\n-  if (GET_CODE (adjust) == CONST_INT)\n+  if (CONST_INT_P (adjust))\n     stack_pointer_delta += INTVAL (adjust);\n \n   temp = expand_binop (Pmode,\n@@ -876,7 +876,7 @@ round_push (rtx size)\n   if (align == 1)\n     return size;\n \n-  if (GET_CODE (size) == CONST_INT)\n+  if (CONST_INT_P (size))\n     {\n       HOST_WIDE_INT new_size = (INTVAL (size) + align - 1) / align * align;\n \n@@ -1138,7 +1138,7 @@ allocate_dynamic_stack_space (rtx size, rtx target, int known_align)\n \t alignment.  This constraint may be too strong.  */\n       gcc_assert (PREFERRED_STACK_BOUNDARY == BIGGEST_ALIGNMENT);\n \n-      if (GET_CODE (size) == CONST_INT)\n+      if (CONST_INT_P (size))\n \t{\n \t  HOST_WIDE_INT new_size = INTVAL (size) / align * align;\n \n@@ -1376,7 +1376,7 @@ probe_stack_range (HOST_WIDE_INT first, rtx size)\n \n   /* If we have to generate explicit probes, see if we have a constant\n      small number of them to generate.  If so, that's the easy case.  */\n-  else if (GET_CODE (size) == CONST_INT\n+  else if (CONST_INT_P (size)\n \t   && INTVAL (size) < 10 * STACK_CHECK_PROBE_INTERVAL)\n     {\n       HOST_WIDE_INT offset;"}, {"sha": "a579c7c4829c86a586548cffb47b682e95ca7628", "filename": "gcc/expmed.c", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/481683e1d53b27779b31c1816606eb17975a9b1f/gcc%2Fexpmed.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/481683e1d53b27779b31c1816606eb17975a9b1f/gcc%2Fexpmed.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpmed.c?ref=481683e1d53b27779b31c1816606eb17975a9b1f", "patch": "@@ -543,7 +543,7 @@ store_bit_field_1 (rtx str_rtx, unsigned HOST_WIDE_INT bitsize,\n       rtx arg0 = op0;\n \n       /* Get appropriate low part of the value being stored.  */\n-      if (GET_CODE (value) == CONST_INT || REG_P (value))\n+      if (CONST_INT_P (value) || REG_P (value))\n \tvalue = gen_lowpart (fieldmode, value);\n       else if (!(GET_CODE (value) == SYMBOL_REF\n \t\t || GET_CODE (value) == LABEL_REF\n@@ -737,7 +737,7 @@ store_bit_field_1 (rtx str_rtx, unsigned HOST_WIDE_INT bitsize,\n \t      else\n \t\tvalue1 = gen_lowpart (op_mode, value1);\n \t    }\n-\t  else if (GET_CODE (value) == CONST_INT)\n+\t  else if (CONST_INT_P (value))\n \t    value1 = gen_int_mode (INTVAL (value), op_mode);\n \t  else\n \t    /* Parse phase is supposed to make VALUE's data type\n@@ -946,7 +946,7 @@ store_fixed_bit_field (rtx op0, unsigned HOST_WIDE_INT offset,\n   /* Shift VALUE left by BITPOS bits.  If VALUE is not constant,\n      we must first convert its mode to MODE.  */\n \n-  if (GET_CODE (value) == CONST_INT)\n+  if (CONST_INT_P (value))\n     {\n       HOST_WIDE_INT v = INTVAL (value);\n \n@@ -1036,7 +1036,7 @@ store_split_bit_field (rtx op0, unsigned HOST_WIDE_INT bitsize,\n   /* If VALUE is a constant other than a CONST_INT, get it into a register in\n      WORD_MODE.  If we can do this using gen_lowpart_common, do so.  Note\n      that VALUE might be a floating-point constant.  */\n-  if (CONSTANT_P (value) && GET_CODE (value) != CONST_INT)\n+  if (CONSTANT_P (value) && !CONST_INT_P (value))\n     {\n       rtx word = gen_lowpart_common (word_mode, value);\n \n@@ -1078,7 +1078,7 @@ store_split_bit_field (rtx op0, unsigned HOST_WIDE_INT bitsize,\n \t    total_bits = GET_MODE_BITSIZE (GET_MODE (value));\n \n \t  /* Fetch successively less significant portions.  */\n-\t  if (GET_CODE (value) == CONST_INT)\n+\t  if (CONST_INT_P (value))\n \t    part = GEN_INT (((unsigned HOST_WIDE_INT) (INTVAL (value))\n \t\t\t     >> (bitsize - bitsdone - thissize))\n \t\t\t    & (((HOST_WIDE_INT) 1 << thissize) - 1));\n@@ -1093,7 +1093,7 @@ store_split_bit_field (rtx op0, unsigned HOST_WIDE_INT bitsize,\n       else\n \t{\n \t  /* Fetch successively more significant portions.  */\n-\t  if (GET_CODE (value) == CONST_INT)\n+\t  if (CONST_INT_P (value))\n \t    part = GEN_INT (((unsigned HOST_WIDE_INT) (INTVAL (value))\n \t\t\t     >> bitsdone)\n \t\t\t    & (((HOST_WIDE_INT) 1 << thissize) - 1));\n@@ -2138,7 +2138,7 @@ expand_shift (enum tree_code code, enum machine_mode mode, rtx shifted,\n \n   if (SHIFT_COUNT_TRUNCATED)\n     {\n-      if (GET_CODE (op1) == CONST_INT\n+      if (CONST_INT_P (op1)\n \t  && ((unsigned HOST_WIDE_INT) INTVAL (op1) >=\n \t      (unsigned HOST_WIDE_INT) GET_MODE_BITSIZE (mode)))\n \top1 = GEN_INT ((unsigned HOST_WIDE_INT) INTVAL (op1)\n@@ -2155,7 +2155,7 @@ expand_shift (enum tree_code code, enum machine_mode mode, rtx shifted,\n   /* Check whether its cheaper to implement a left shift by a constant\n      bit count by a sequence of additions.  */\n   if (code == LSHIFT_EXPR\n-      && GET_CODE (op1) == CONST_INT\n+      && CONST_INT_P (op1)\n       && INTVAL (op1) > 0\n       && INTVAL (op1) < GET_MODE_BITSIZE (mode)\n       && INTVAL (op1) < MAX_BITS_PER_WORD\n@@ -3144,7 +3144,7 @@ expand_mult (enum machine_mode mode, rtx op0, rtx op1, rtx target,\n \t any truncation.  This means that multiplying by negative values does\n \t not work; results are off by 2^32 on a 32 bit machine.  */\n \n-      if (GET_CODE (op1) == CONST_INT)\n+      if (CONST_INT_P (op1))\n \t{\n \t  /* Attempt to handle multiplication of DImode values by negative\n \t     coefficients, by performing the multiplication by a positive\n@@ -3846,7 +3846,7 @@ expand_divmod (int rem_flag, enum tree_code code, enum machine_mode mode,\n   static HOST_WIDE_INT ext_op1;\n   bool speed = optimize_insn_for_speed_p ();\n \n-  op1_is_constant = GET_CODE (op1) == CONST_INT;\n+  op1_is_constant = CONST_INT_P (op1);\n   if (op1_is_constant)\n     {\n       ext_op1 = INTVAL (op1);\n@@ -3990,7 +3990,7 @@ expand_divmod (int rem_flag, enum tree_code code, enum machine_mode mode,\n \n       /* convert_modes may have placed op1 into a register, so we\n \t must recompute the following.  */\n-      op1_is_constant = GET_CODE (op1) == CONST_INT;\n+      op1_is_constant = CONST_INT_P (op1);\n       op1_is_pow2 = (op1_is_constant\n \t\t     && ((EXACT_POWER_OF_2_OR_ZERO_P (INTVAL (op1))\n \t\t\t  || (! unsignedp"}, {"sha": "4a8a4ca1d0780dad25a6cbf72a12cd22aba0b637", "filename": "gcc/expr.c", "status": "modified", "additions": 24, "deletions": 24, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/481683e1d53b27779b31c1816606eb17975a9b1f/gcc%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/481683e1d53b27779b31c1816606eb17975a9b1f/gcc%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.c?ref=481683e1d53b27779b31c1816606eb17975a9b1f", "patch": "@@ -772,7 +772,7 @@ convert_modes (enum machine_mode mode, enum machine_mode oldmode, rtx x, int uns\n \n   if (unsignedp && GET_MODE_CLASS (mode) == MODE_INT\n       && GET_MODE_BITSIZE (mode) == 2 * HOST_BITS_PER_WIDE_INT\n-      && GET_CODE (x) == CONST_INT && INTVAL (x) < 0)\n+      && CONST_INT_P (x) && INTVAL (x) < 0)\n     {\n       HOST_WIDE_INT val = INTVAL (x);\n \n@@ -793,7 +793,7 @@ convert_modes (enum machine_mode mode, enum machine_mode oldmode, rtx x, int uns\n      non-volatile MEM.  Except for the constant case where MODE is no\n      wider than HOST_BITS_PER_WIDE_INT, we must be narrowing the operand.  */\n \n-  if ((GET_CODE (x) == CONST_INT\n+  if ((CONST_INT_P (x)\n        && GET_MODE_BITSIZE (mode) <= HOST_BITS_PER_WIDE_INT)\n       || (GET_MODE_CLASS (mode) == MODE_INT\n \t  && GET_MODE_CLASS (oldmode) == MODE_INT\n@@ -810,7 +810,7 @@ convert_modes (enum machine_mode mode, enum machine_mode oldmode, rtx x, int uns\n       /* ?? If we don't know OLDMODE, we have to assume here that\n \t X does not need sign- or zero-extension.   This may not be\n \t the case, but it's the best we can do.  */\n-      if (GET_CODE (x) == CONST_INT && oldmode != VOIDmode\n+      if (CONST_INT_P (x) && oldmode != VOIDmode\n \t  && GET_MODE_SIZE (mode) > GET_MODE_SIZE (oldmode))\n \t{\n \t  HOST_WIDE_INT val = INTVAL (x);\n@@ -1199,7 +1199,7 @@ emit_block_move_hints (rtx x, rtx y, rtx size, enum block_op_methods method,\n \n   /* Set MEM_SIZE as appropriate for this block copy.  The main place this\n      can be incorrect is coming from __builtin_memcpy.  */\n-  if (GET_CODE (size) == CONST_INT)\n+  if (CONST_INT_P (size))\n     {\n       if (INTVAL (size) == 0)\n \treturn 0;\n@@ -1210,7 +1210,7 @@ emit_block_move_hints (rtx x, rtx y, rtx size, enum block_op_methods method,\n       set_mem_size (y, size);\n     }\n \n-  if (GET_CODE (size) == CONST_INT && MOVE_BY_PIECES_P (INTVAL (size), align))\n+  if (CONST_INT_P (size) && MOVE_BY_PIECES_P (INTVAL (size), align))\n     move_by_pieces (x, y, INTVAL (size), align, 0);\n   else if (emit_block_move_via_movmem (x, y, size, align,\n \t\t\t\t       expected_align, expected_size))\n@@ -1313,7 +1313,7 @@ emit_block_move_via_movmem (rtx x, rtx y, rtx size, unsigned int align,\n \t     here because if SIZE is less than the mode mask, as it is\n \t     returned by the macro, it will definitely be less than the\n \t     actual mode mask.  */\n-\t  && ((GET_CODE (size) == CONST_INT\n+\t  && ((CONST_INT_P (size)\n \t       && ((unsigned HOST_WIDE_INT) INTVAL (size)\n \t\t   <= (GET_MODE_MASK (mode) >> 1)))\n \t      || GET_MODE_BITSIZE (mode) >= BITS_PER_WORD)\n@@ -2608,7 +2608,7 @@ clear_storage_hints (rtx object, rtx size, enum block_op_methods method,\n   /* If OBJECT is not BLKmode and SIZE is the same size as its mode,\n      just move a zero.  Otherwise, do this a piece at a time.  */\n   if (mode != BLKmode\n-      && GET_CODE (size) == CONST_INT\n+      && CONST_INT_P (size)\n       && INTVAL (size) == (HOST_WIDE_INT) GET_MODE_SIZE (mode))\n     {\n       rtx zero = CONST0_RTX (mode);\n@@ -2635,7 +2635,7 @@ clear_storage_hints (rtx object, rtx size, enum block_op_methods method,\n \n   align = MEM_ALIGN (object);\n \n-  if (GET_CODE (size) == CONST_INT\n+  if (CONST_INT_P (size)\n       && CLEAR_BY_PIECES_P (INTVAL (size), align))\n     clear_by_pieces (object, INTVAL (size), align);\n   else if (set_storage_via_setmem (object, size, const0_rtx, align,\n@@ -2681,7 +2681,7 @@ set_storage_via_libcall (rtx object, rtx size, rtx val, bool tailcall)\n      for returning pointers, we could end up generating incorrect code.  */\n \n   object_tree = make_tree (ptr_type_node, object);\n-  if (GET_CODE (val) != CONST_INT)\n+  if (!CONST_INT_P (val))\n     val = convert_to_mode (TYPE_MODE (integer_type_node), val, 1);\n   size_tree = make_tree (sizetype, size);\n   val_tree = make_tree (integer_type_node, val);\n@@ -2774,7 +2774,7 @@ set_storage_via_setmem (rtx object, rtx size, rtx val, unsigned int align,\n \t     BITS_PER_HOST_WIDE_INT here because if SIZE is less than\n \t     the mode mask, as it is returned by the macro, it will\n \t     definitely be less than the actual mode mask.  */\n-\t  && ((GET_CODE (size) == CONST_INT\n+\t  && ((CONST_INT_P (size)\n \t       && ((unsigned HOST_WIDE_INT) INTVAL (size)\n \t\t   <= (GET_MODE_MASK (mode) >> 1)))\n \t      || GET_MODE_BITSIZE (mode) >= BITS_PER_WORD)\n@@ -3046,7 +3046,7 @@ emit_move_resolve_push (enum machine_mode mode, rtx x)\n       HOST_WIDE_INT val;\n \n       gcc_assert (GET_CODE (expr) == PLUS || GET_CODE (expr) == MINUS);\n-      gcc_assert (GET_CODE (XEXP (expr, 1)) == CONST_INT);\n+      gcc_assert (CONST_INT_P (XEXP (expr, 1)));\n       val = INTVAL (XEXP (expr, 1));\n       if (GET_CODE (expr) == MINUS)\n \tval = -val;\n@@ -3572,7 +3572,7 @@ push_block (rtx size, int extra, int below)\n     }\n   else\n     {\n-      if (GET_CODE (size) == CONST_INT)\n+      if (CONST_INT_P (size))\n \ttemp = plus_constant (virtual_outgoing_args_rtx,\n \t\t\t      -INTVAL (size) - (below ? 0 : extra));\n       else if (extra != 0 && !below)\n@@ -3783,7 +3783,7 @@ emit_push_insn (rtx x, enum machine_mode mode, tree type, rtx size,\n \t on the stack for alignment purposes.  */\n       if (args_addr == 0\n \t  && PUSH_ARGS\n-\t  && GET_CODE (size) == CONST_INT\n+\t  && CONST_INT_P (size)\n \t  && skip == 0\n \t  && MEM_ALIGN (xinner) >= align\n \t  && (MOVE_BY_PIECES_P ((unsigned) INTVAL (size) - used, align))\n@@ -3816,7 +3816,7 @@ emit_push_insn (rtx x, enum machine_mode mode, tree type, rtx size,\n \t  /* Deduct words put into registers from the size we must copy.  */\n \t  if (partial != 0)\n \t    {\n-\t      if (GET_CODE (size) == CONST_INT)\n+\t      if (CONST_INT_P (size))\n \t\tsize = GEN_INT (INTVAL (size) - used);\n \t      else\n \t\tsize = expand_binop (GET_MODE (size), sub_optab, size,\n@@ -3832,7 +3832,7 @@ emit_push_insn (rtx x, enum machine_mode mode, tree type, rtx size,\n \t      temp = push_block (size, extra, where_pad == downward);\n \t      extra = 0;\n \t    }\n-\t  else if (GET_CODE (args_so_far) == CONST_INT)\n+\t  else if (CONST_INT_P (args_so_far))\n \t    temp = memory_address (BLKmode,\n \t\t\t\t   plus_constant (args_addr,\n \t\t\t\t\t\t  skip + INTVAL (args_so_far)));\n@@ -3948,7 +3948,7 @@ emit_push_insn (rtx x, enum machine_mode mode, tree type, rtx size,\n       else\n #endif\n \t{\n-\t  if (GET_CODE (args_so_far) == CONST_INT)\n+\t  if (CONST_INT_P (args_so_far))\n \t    addr\n \t      = memory_address (mode,\n \t\t\t\tplus_constant (args_addr,\n@@ -4732,7 +4732,7 @@ store_expr (tree exp, rtx target, int call_param_p, bool nontemporal)\n \t     type of the string, which is actually the size of the target.  */\n \t  rtx size = expr_size (exp);\n \n-\t  if (GET_CODE (size) == CONST_INT\n+\t  if (CONST_INT_P (size)\n \t      && INTVAL (size) < TREE_STRING_LENGTH (exp))\n \t    emit_block_move (target, temp, size,\n \t\t\t     (call_param_p\n@@ -4759,7 +4759,7 @@ store_expr (tree exp, rtx target, int call_param_p, bool nontemporal)\n \n \t      /* Figure out how much is left in TARGET that we have to clear.\n \t\t Do all calculations in ptr_mode.  */\n-\t      if (GET_CODE (copy_size_rtx) == CONST_INT)\n+\t      if (CONST_INT_P (copy_size_rtx))\n \t\t{\n \t\t  size = plus_constant (size, -INTVAL (copy_size_rtx));\n \t\t  target = adjust_address (target, BLKmode,\n@@ -6343,7 +6343,7 @@ force_operand (rtx value, rtx target)\n       op2 = XEXP (value, 1);\n       if (!CONSTANT_P (op2) && !(REG_P (op2) && op2 != subtarget))\n \tsubtarget = 0;\n-      if (code == MINUS && GET_CODE (op2) == CONST_INT)\n+      if (code == MINUS && CONST_INT_P (op2))\n \t{\n \t  code = PLUS;\n \t  op2 = negate_rtx (GET_MODE (value), op2);\n@@ -6355,7 +6355,7 @@ force_operand (rtx value, rtx target)\n          constant first and then add the other value.  This allows virtual\n          register instantiation to simply modify the constant rather than\n          creating another one around this addition.  */\n-      if (code == PLUS && GET_CODE (op2) == CONST_INT\n+      if (code == PLUS && CONST_INT_P (op2)\n \t  && GET_CODE (XEXP (value, 0)) == PLUS\n \t  && REG_P (XEXP (XEXP (value, 0), 0))\n \t  && REGNO (XEXP (XEXP (value, 0), 0)) >= FIRST_VIRTUAL_REGISTER\n@@ -8640,7 +8640,7 @@ expand_expr_real_1 (tree exp, rtx target, enum machine_mode tmode,\n \n \t  /* If the last operand is a CONST_INT, use plus_constant of\n \t     the negated constant.  Else make the MINUS.  */\n-\t  if (GET_CODE (op1) == CONST_INT)\n+\t  if (CONST_INT_P (op1))\n \t    return REDUCE_BIT_FIELD (plus_constant (op0, - INTVAL (op1)));\n \t  else\n \t    return REDUCE_BIT_FIELD (gen_rtx_MINUS (mode, op0, op1));\n@@ -8658,7 +8658,7 @@ expand_expr_real_1 (tree exp, rtx target, enum machine_mode tmode,\n \t\t       subtarget, &op0, &op1, modifier);\n \n       /* Convert A - const to A + (-const).  */\n-      if (GET_CODE (op1) == CONST_INT)\n+      if (CONST_INT_P (op1))\n \t{\n \t  op1 = negate_rtx (mode, op1);\n \t  return REDUCE_BIT_FIELD (simplify_gen_binary (PLUS, mode, op0, op1));\n@@ -9123,7 +9123,7 @@ expand_expr_real_1 (tree exp, rtx target, enum machine_mode tmode,\n \t\t\t      VOIDmode, EXPAND_NORMAL);\n \n \t  /* If temp is constant, we can just compute the result.  */\n-\t  if (GET_CODE (temp) == CONST_INT)\n+\t  if (CONST_INT_P (temp))\n \t    {\n \t      if (INTVAL (temp) != 0)\n \t        emit_move_insn (target, const1_rtx);\n@@ -9567,7 +9567,7 @@ reduce_to_bit_field_precision (rtx exp, rtx target, tree type)\n   if (target && GET_MODE (target) != GET_MODE (exp))\n     target = 0;\n   /* For constant values, reduce using build_int_cst_type. */\n-  if (GET_CODE (exp) == CONST_INT)\n+  if (CONST_INT_P (exp))\n     {\n       HOST_WIDE_INT value = INTVAL (exp);\n       tree t = build_int_cst_type (type, value);"}, {"sha": "baf5f3c67960d4040330a8530910704e2e5d93b0", "filename": "gcc/final.c", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/481683e1d53b27779b31c1816606eb17975a9b1f/gcc%2Ffinal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/481683e1d53b27779b31c1816606eb17975a9b1f/gcc%2Ffinal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffinal.c?ref=481683e1d53b27779b31c1816606eb17975a9b1f", "patch": "@@ -3127,7 +3127,7 @@ get_mem_expr_from_op (rtx op, int *paddressp)\n \t   && (expr = get_mem_expr_from_op (XEXP (op, 1), &inner_addressp)))\n     return expr;\n \n-  while (GET_RTX_CLASS (GET_CODE (op)) == RTX_UNARY\n+  while (UNARY_P (op)\n \t || GET_RTX_CLASS (GET_CODE (op)) == RTX_BIN_ARITH)\n     op = XEXP (op, 0);\n \n@@ -3330,7 +3330,7 @@ output_asm_insn (const char *templ, rtx *operands)\n \t      }\n \t    else if (letter == 'n')\n \t      {\n-\t\tif (GET_CODE (operands[opnum]) == CONST_INT)\n+\t\tif (CONST_INT_P (operands[opnum]))\n \t\t  fprintf (asm_out_file, HOST_WIDE_INT_PRINT_DEC,\n \t\t\t   - INTVAL (operands[opnum]));\n \t\telse\n@@ -3562,7 +3562,7 @@ output_addr_const (FILE *file, rtx x)\n \n     case PLUS:\n       /* Some assemblers need integer constants to appear last (eg masm).  */\n-      if (GET_CODE (XEXP (x, 0)) == CONST_INT)\n+      if (CONST_INT_P (XEXP (x, 0)))\n \t{\n \t  output_addr_const (file, XEXP (x, 1));\n \t  if (INTVAL (XEXP (x, 0)) >= 0)\n@@ -3572,7 +3572,7 @@ output_addr_const (FILE *file, rtx x)\n       else\n \t{\n \t  output_addr_const (file, XEXP (x, 0));\n-\t  if (GET_CODE (XEXP (x, 1)) != CONST_INT\n+\t  if (!CONST_INT_P (XEXP (x, 1))\n \t      || INTVAL (XEXP (x, 1)) >= 0)\n \t    fprintf (file, \"+\");\n \t  output_addr_const (file, XEXP (x, 1));\n@@ -3588,7 +3588,7 @@ output_addr_const (FILE *file, rtx x)\n \n       output_addr_const (file, XEXP (x, 0));\n       fprintf (file, \"-\");\n-      if ((GET_CODE (XEXP (x, 1)) == CONST_INT && INTVAL (XEXP (x, 1)) >= 0)\n+      if ((CONST_INT_P (XEXP (x, 1)) && INTVAL (XEXP (x, 1)) >= 0)\n \t  || GET_CODE (XEXP (x, 1)) == PC\n \t  || GET_CODE (XEXP (x, 1)) == SYMBOL_REF)\n \toutput_addr_const (file, XEXP (x, 1));\n@@ -3796,7 +3796,7 @@ asm_fprintf (FILE *file, const char *p, ...)\n void\n split_double (rtx value, rtx *first, rtx *second)\n {\n-  if (GET_CODE (value) == CONST_INT)\n+  if (CONST_INT_P (value))\n     {\n       if (HOST_BITS_PER_WIDE_INT >= (2 * BITS_PER_WORD))\n \t{"}, {"sha": "a0c45de2a1bef71fa1472d52790aae7515cd52ee", "filename": "gcc/function.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/481683e1d53b27779b31c1816606eb17975a9b1f/gcc%2Ffunction.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/481683e1d53b27779b31c1816606eb17975a9b1f/gcc%2Ffunction.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffunction.c?ref=481683e1d53b27779b31c1816606eb17975a9b1f", "patch": "@@ -654,7 +654,7 @@ find_temp_slot_from_address (rtx x)\n   /* Last resort: Address is a virtual stack var address.  */\n   if (GET_CODE (x) == PLUS\n       && XEXP (x, 0) == virtual_stack_vars_rtx\n-      && GET_CODE (XEXP (x, 1)) == CONST_INT)\n+      && CONST_INT_P (XEXP (x, 1)))\n     {\n       int i;\n       for (i = max_slot_level (); i >= 0; i--)\n@@ -1457,7 +1457,7 @@ instantiate_virtual_regs_in_insn (rtx insn)\n \t  && recog_data.n_operands >= 3\n \t  && recog_data.operand_loc[1] == &XEXP (SET_SRC (set), 0)\n \t  && recog_data.operand_loc[2] == &XEXP (SET_SRC (set), 1)\n-\t  && GET_CODE (recog_data.operand[2]) == CONST_INT\n+\t  && CONST_INT_P (recog_data.operand[2])\n \t  && (new_rtx = instantiate_new_reg (recog_data.operand[1], &offset)))\n \t{\n \t  offset += INTVAL (recog_data.operand[2]);\n@@ -1783,7 +1783,7 @@ instantiate_virtual_regs (void)\n \tfor_each_rtx (&REG_NOTES (insn), instantiate_virtual_regs_in_rtx, NULL);\n \n \t/* Instantiate any virtual registers in CALL_INSN_FUNCTION_USAGE.  */\n-\tif (GET_CODE (insn) == CALL_INSN)\n+\tif (CALL_P (insn))\n \t  for_each_rtx (&CALL_INSN_FUNCTION_USAGE (insn),\n \t\t\tinstantiate_virtual_regs_in_rtx, NULL);\n       }\n@@ -2458,7 +2458,7 @@ assign_parm_find_stack_rtl (tree parm, struct assign_parm_data_one *data)\n      up with a guess at the alignment based on OFFSET_RTX.  */\n   if (data->locate.where_pad != downward || data->entry_parm)\n     align = boundary;\n-  else if (GET_CODE (offset_rtx) == CONST_INT)\n+  else if (CONST_INT_P (offset_rtx))\n     {\n       align = INTVAL (offset_rtx) * BITS_PER_UNIT | boundary;\n       align = align & -align;"}, {"sha": "58cc9b0b5529946a88845cd640dff285aa02208f", "filename": "gcc/fwprop.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/481683e1d53b27779b31c1816606eb17975a9b1f/gcc%2Ffwprop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/481683e1d53b27779b31c1816606eb17975a9b1f/gcc%2Ffwprop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffwprop.c?ref=481683e1d53b27779b31c1816606eb17975a9b1f", "patch": "@@ -254,7 +254,7 @@ canonicalize_address (rtx x)\n     switch (GET_CODE (x))\n       {\n       case ASHIFT:\n-        if (GET_CODE (XEXP (x, 1)) == CONST_INT\n+        if (CONST_INT_P (XEXP (x, 1))\n             && INTVAL (XEXP (x, 1)) < GET_MODE_BITSIZE (GET_MODE (x))\n             && INTVAL (XEXP (x, 1)) >= 0)\n \t  {\n@@ -574,7 +574,7 @@ propagate_rtx (rtx x, enum machine_mode mode, rtx old_rtx, rtx new_rtx,\n \n   /* gen_lowpart_common will not be able to process VOIDmode entities other\n      than CONST_INTs.  */\n-  if (GET_MODE (tem) == VOIDmode && GET_CODE (tem) != CONST_INT)\n+  if (GET_MODE (tem) == VOIDmode && !CONST_INT_P (tem))\n     return NULL_RTX;\n \n   if (GET_MODE (tem) == VOIDmode)"}, {"sha": "5c427ce571995420884bfe10409552f391628c6c", "filename": "gcc/gcse.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/481683e1d53b27779b31c1816606eb17975a9b1f/gcc%2Fgcse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/481683e1d53b27779b31c1816606eb17975a9b1f/gcc%2Fgcse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgcse.c?ref=481683e1d53b27779b31c1816606eb17975a9b1f", "patch": "@@ -1287,8 +1287,8 @@ gcse_constant_p (const_rtx x)\n {\n   /* Consider a COMPARE of two integers constant.  */\n   if (GET_CODE (x) == COMPARE\n-      && GET_CODE (XEXP (x, 0)) == CONST_INT\n-      && GET_CODE (XEXP (x, 1)) == CONST_INT)\n+      && CONST_INT_P (XEXP (x, 0))\n+      && CONST_INT_P (XEXP (x, 1)))\n     return true;\n \n   /* Consider a COMPARE of the same registers is a constant"}, {"sha": "7f76270c66c9ea0504ce53c710ee33a780a4854c", "filename": "gcc/genpreds.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/481683e1d53b27779b31c1816606eb17975a9b1f/gcc%2Fgenpreds.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/481683e1d53b27779b31c1816606eb17975a9b1f/gcc%2Fgenpreds.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgenpreds.c?ref=481683e1d53b27779b31c1816606eb17975a9b1f", "patch": "@@ -1115,7 +1115,7 @@ write_tm_constrs_h (void)\n \t  puts (\"  const REAL_VALUE_TYPE *rval = 0;\");\n \n \tif (needs_ival)\n-\t  puts (\"  if (GET_CODE (op) == CONST_INT)\\n\"\n+\t  puts (\"  if (CONST_INT_P (op))\\n\"\n \t\t\"    ival = INTVAL (op);\");\n \tif (needs_hval)\n \t  puts (\"  if (GET_CODE (op) == CONST_DOUBLE && mode == VOIDmode)\""}, {"sha": "6e82584cf9f7bb3b4cc4c0338fd8fea76004eec4", "filename": "gcc/genrecog.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/481683e1d53b27779b31c1816606eb17975a9b1f/gcc%2Fgenrecog.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/481683e1d53b27779b31c1816606eb17975a9b1f/gcc%2Fgenrecog.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgenrecog.c?ref=481683e1d53b27779b31c1816606eb17975a9b1f", "patch": "@@ -795,7 +795,7 @@ validate_pattern (rtx pattern, rtx insn, rtx set, int set_code)\n \t\t && GET_CODE (dest) != CC0\n \t\t && GET_CODE (src) != PC\n \t\t && GET_CODE (src) != CC0\n-\t\t && GET_CODE (src) != CONST_INT\n+\t\t && !CONST_INT_P (src)\n \t\t && GET_CODE (src) != CALL)\n \t  {\n \t    const char *which;"}, {"sha": "fee72e7b61418358e6e4a6825287d7bfaa29ebe8", "filename": "gcc/ifcvt.c", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/481683e1d53b27779b31c1816606eb17975a9b1f/gcc%2Fifcvt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/481683e1d53b27779b31c1816606eb17975a9b1f/gcc%2Fifcvt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fifcvt.c?ref=481683e1d53b27779b31c1816606eb17975a9b1f", "patch": "@@ -905,12 +905,12 @@ noce_try_store_flag (struct noce_if_info *if_info)\n   int reversep;\n   rtx target, seq;\n \n-  if (GET_CODE (if_info->b) == CONST_INT\n+  if (CONST_INT_P (if_info->b)\n       && INTVAL (if_info->b) == STORE_FLAG_VALUE\n       && if_info->a == const0_rtx)\n     reversep = 0;\n   else if (if_info->b == const0_rtx\n-\t   && GET_CODE (if_info->a) == CONST_INT\n+\t   && CONST_INT_P (if_info->a)\n \t   && INTVAL (if_info->a) == STORE_FLAG_VALUE\n \t   && (reversed_comparison_code (if_info->cond, if_info->jump)\n \t       != UNKNOWN))\n@@ -952,8 +952,8 @@ noce_try_store_flag_constants (struct noce_if_info *if_info)\n   int normalize, can_reverse;\n   enum machine_mode mode;\n \n-  if (GET_CODE (if_info->a) == CONST_INT\n-      && GET_CODE (if_info->b) == CONST_INT)\n+  if (CONST_INT_P (if_info->a)\n+      && CONST_INT_P (if_info->b))\n     {\n       mode = GET_MODE (if_info->x);\n       ifalse = INTVAL (if_info->a);\n@@ -1538,7 +1538,7 @@ noce_get_alt_condition (struct noce_if_info *if_info, rtx target,\n \tmake equivalent types of changes) to get the constants we need\n \tif they're off by one in the right direction.  */\n \n-  if (GET_CODE (target) == CONST_INT)\n+  if (CONST_INT_P (target))\n     {\n       enum rtx_code code = GET_CODE (if_info->cond);\n       rtx op_a = XEXP (if_info->cond, 0);\n@@ -1555,14 +1555,14 @@ noce_get_alt_condition (struct noce_if_info *if_info, rtx target,\n \t  rtx src = find_reg_equal_equiv_note (prev_insn);\n \t  if (!src)\n \t    src = SET_SRC (PATTERN (prev_insn));\n-\t  if (GET_CODE (src) == CONST_INT)\n+\t  if (CONST_INT_P (src))\n \t    {\n \t      if (rtx_equal_p (op_a, SET_DEST (PATTERN (prev_insn))))\n \t\top_a = src;\n \t      else if (rtx_equal_p (op_b, SET_DEST (PATTERN (prev_insn))))\n \t\top_b = src;\n \n-\t      if (GET_CODE (op_a) == CONST_INT)\n+\t      if (CONST_INT_P (op_a))\n \t\t{\n \t\t  rtx tmp = op_a;\n \t\t  op_a = op_b;\n@@ -1574,7 +1574,7 @@ noce_get_alt_condition (struct noce_if_info *if_info, rtx target,\n \n       /* Now, look to see if we can get the right constant by\n \t adjusting the conditional.  */\n-      if (GET_CODE (op_b) == CONST_INT)\n+      if (CONST_INT_P (op_b))\n \t{\n \t  HOST_WIDE_INT desired_val = INTVAL (target);\n \t  HOST_WIDE_INT actual_val = INTVAL (op_b);\n@@ -1973,7 +1973,7 @@ noce_try_bitop (struct noce_if_info *if_info)\n   if (GET_CODE (cond) == ZERO_EXTRACT)\n     {\n       if (XEXP (cond, 1) != const1_rtx\n-\t  || GET_CODE (XEXP (cond, 2)) != CONST_INT\n+\t  || !CONST_INT_P (XEXP (cond, 2))\n \t  || ! rtx_equal_p (x, XEXP (cond, 0)))\n \treturn FALSE;\n       bitnum = INTVAL (XEXP (cond, 2));\n@@ -1991,7 +1991,7 @@ noce_try_bitop (struct noce_if_info *if_info)\n     {\n       /* Check for \"if (X & C) x = x op C\".  */\n       if (! rtx_equal_p (x, XEXP (a, 0))\n-          || GET_CODE (XEXP (a, 1)) != CONST_INT\n+          || !CONST_INT_P (XEXP (a, 1))\n \t  || (INTVAL (XEXP (a, 1)) & GET_MODE_MASK (mode))\n \t     != (unsigned HOST_WIDE_INT) 1 << bitnum)\n         return FALSE;\n@@ -2017,7 +2017,7 @@ noce_try_bitop (struct noce_if_info *if_info)\n     {\n       /* Check for \"if (X & C) x &= ~C\".  */\n       if (! rtx_equal_p (x, XEXP (a, 0))\n-\t  || GET_CODE (XEXP (a, 1)) != CONST_INT\n+\t  || !CONST_INT_P (XEXP (a, 1))\n \t  || (INTVAL (XEXP (a, 1)) & GET_MODE_MASK (mode))\n \t     != (~((HOST_WIDE_INT) 1 << bitnum) & GET_MODE_MASK (mode)))\n         return FALSE;\n@@ -2142,7 +2142,7 @@ noce_mem_write_may_trap_or_fault_p (const_rtx mem)\n \taddr = XEXP (addr, 1);\n \tbreak;\n       case PLUS:\n-\tif (GET_CODE (XEXP (addr, 1)) == CONST_INT)\n+\tif (CONST_INT_P (XEXP (addr, 1)))\n \t  addr = XEXP (addr, 0);\n \telse\n \t  return false;\n@@ -2298,8 +2298,8 @@ noce_process_if_block (struct noce_if_info *if_info)\n \treturn FALSE;\n \n       if (GET_CODE (x) == ZERO_EXTRACT\n-\t  && (GET_CODE (XEXP (x, 1)) != CONST_INT\n-\t      || GET_CODE (XEXP (x, 2)) != CONST_INT))\n+\t  && (!CONST_INT_P (XEXP (x, 1))\n+\t      || !CONST_INT_P (XEXP (x, 2))))\n \treturn FALSE;\n \n       x = gen_reg_rtx (GET_MODE (GET_CODE (x) == STRICT_LOW_PART"}, {"sha": "4dd7003adebf2b3552421ba73906f99e0947f11e", "filename": "gcc/ira-costs.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/481683e1d53b27779b31c1816606eb17975a9b1f/gcc%2Fira-costs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/481683e1d53b27779b31c1816606eb17975a9b1f/gcc%2Fira-costs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fira-costs.c?ref=481683e1d53b27779b31c1816606eb17975a9b1f", "patch": "@@ -429,7 +429,7 @@ record_reg_classes (int n_alts, int n_ops, rtx *ops,\n \t\t  break;\n \n \t\tcase 's':\n-\t\t  if (GET_CODE (op) == CONST_INT\n+\t\t  if (CONST_INT_P (op)\n \t\t      || (GET_CODE (op) == CONST_DOUBLE\n \t\t\t  && GET_MODE (op) == VOIDmode))\n \t\t    break;\n@@ -441,7 +441,7 @@ record_reg_classes (int n_alts, int n_ops, rtx *ops,\n \t\t  break;\n \n \t\tcase 'n':\n-\t\t  if (GET_CODE (op) == CONST_INT\n+\t\t  if (CONST_INT_P (op)\n \t\t      || (GET_CODE (op) == CONST_DOUBLE\n \t\t\t  && GET_MODE (op) == VOIDmode))\n \t\t    win = 1;\n@@ -455,7 +455,7 @@ record_reg_classes (int n_alts, int n_ops, rtx *ops,\n \t\tcase 'N':\n \t\tcase 'O':\n \t\tcase 'P':\n-\t\t  if (GET_CODE (op) == CONST_INT\n+\t\t  if (CONST_INT_P (op)\n \t\t      && CONST_OK_FOR_CONSTRAINT_P (INTVAL (op), c, p))\n \t\t    win = 1;\n \t\t  break;"}, {"sha": "0812c840634f362534cc4f30fd5c1c07929e3333", "filename": "gcc/ira-lives.c", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/481683e1d53b27779b31c1816606eb17975a9b1f/gcc%2Fira-lives.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/481683e1d53b27779b31c1816606eb17975a9b1f/gcc%2Fira-lives.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fira-lives.c?ref=481683e1d53b27779b31c1816606eb17975a9b1f", "patch": "@@ -630,21 +630,21 @@ single_reg_class (const char *constraints, rtx op, rtx equiv_const)\n \t  break;\n \n \tcase 'n':\n-\t  if (GET_CODE (op) == CONST_INT\n+\t  if (CONST_INT_P (op)\n \t      || (GET_CODE (op) == CONST_DOUBLE && GET_MODE (op) == VOIDmode)\n \t      || (equiv_const != NULL_RTX\n-\t\t  && (GET_CODE (equiv_const) == CONST_INT\n+\t\t  && (CONST_INT_P (equiv_const)\n \t\t      || (GET_CODE (equiv_const) == CONST_DOUBLE\n \t\t\t  && GET_MODE (equiv_const) == VOIDmode))))\n \t    return NO_REGS;\n \t  break;\n \t  \n \tcase 's':\n-\t  if ((CONSTANT_P (op) && GET_CODE (op) != CONST_INT\n+\t  if ((CONSTANT_P (op) && !CONST_INT_P (op)\n \t       && (GET_CODE (op) != CONST_DOUBLE || GET_MODE (op) != VOIDmode))\n \t      || (equiv_const != NULL_RTX\n \t\t  && CONSTANT_P (equiv_const)\n-\t\t  && GET_CODE (equiv_const) != CONST_INT\n+\t\t  && !CONST_INT_P (equiv_const)\n \t\t  && (GET_CODE (equiv_const) != CONST_DOUBLE\n \t\t      || GET_MODE (equiv_const) != VOIDmode)))\n \t    return NO_REGS;\n@@ -658,10 +658,10 @@ single_reg_class (const char *constraints, rtx op, rtx equiv_const)\n \tcase 'N':\n \tcase 'O':\n \tcase 'P':\n-\t  if ((GET_CODE (op) == CONST_INT\n+\t  if ((CONST_INT_P (op)\n \t       && CONST_OK_FOR_CONSTRAINT_P (INTVAL (op), c, constraints))\n \t      || (equiv_const != NULL_RTX\n-\t\t  && GET_CODE (equiv_const) == CONST_INT\n+\t\t  && CONST_INT_P (equiv_const)\n \t\t  && CONST_OK_FOR_CONSTRAINT_P (INTVAL (equiv_const),\n \t\t\t\t\t\tc, constraints)))\n \t    return NO_REGS;"}, {"sha": "533f11cab5ab992b9129dbd181dbd089fbbf109a", "filename": "gcc/jump.c", "status": "modified", "additions": 3, "deletions": 7, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/481683e1d53b27779b31c1816606eb17975a9b1f/gcc%2Fjump.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/481683e1d53b27779b31c1816606eb17975a9b1f/gcc%2Fjump.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjump.c?ref=481683e1d53b27779b31c1816606eb17975a9b1f", "patch": "@@ -391,7 +391,7 @@ reversed_comparison_code_parts (enum rtx_code code, const_rtx arg0,\n \n   /* Test for an integer condition, or a floating-point comparison\n      in which NaNs can be ignored.  */\n-  if (GET_CODE (arg0) == CONST_INT\n+  if (CONST_INT_P (arg0)\n       || (GET_MODE (arg0) != VOIDmode\n \t  && GET_MODE_CLASS (mode) != MODE_CC\n \t  && !HONOR_NANS (mode)))\n@@ -1205,9 +1205,7 @@ delete_related_insns (rtx insn)\n \n   /* Likewise if we're deleting a dispatch table.  */\n \n-  if (JUMP_P (insn)\n-      && (GET_CODE (PATTERN (insn)) == ADDR_VEC\n-\t  || GET_CODE (PATTERN (insn)) == ADDR_DIFF_VEC))\n+  if (JUMP_TABLE_DATA_P (insn))\n     {\n       rtx pat = PATTERN (insn);\n       int i, diff_vec_p = GET_CODE (pat) == ADDR_DIFF_VEC;\n@@ -1241,9 +1239,7 @@ delete_related_insns (rtx insn)\n \n   if (was_code_label\n       && NEXT_INSN (insn) != 0\n-      && JUMP_P (NEXT_INSN (insn))\n-      && (GET_CODE (PATTERN (NEXT_INSN (insn))) == ADDR_VEC\n-\t  || GET_CODE (PATTERN (NEXT_INSN (insn))) == ADDR_DIFF_VEC))\n+      && JUMP_TABLE_DATA_P (NEXT_INSN (insn)))\n     next = delete_related_insns (NEXT_INSN (insn));\n \n   /* If INSN was a label, delete insns following it if now unreachable.  */"}, {"sha": "44ded9d0479078811ef9874b985fdbfbb0fe7bf3", "filename": "gcc/loop-iv.c", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/481683e1d53b27779b31c1816606eb17975a9b1f/gcc%2Floop-iv.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/481683e1d53b27779b31c1816606eb17975a9b1f/gcc%2Floop-iv.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Floop-iv.c?ref=481683e1d53b27779b31c1816606eb17975a9b1f", "patch": "@@ -1567,11 +1567,11 @@ implies_p (rtx a, rtx b)\n \n   /* A != N is equivalent to A - (N + 1) <u -1.  */\n   if (GET_CODE (a) == NE\n-      && GET_CODE (op1) == CONST_INT\n+      && CONST_INT_P (op1)\n       && GET_CODE (b) == LTU\n       && opb1 == constm1_rtx\n       && GET_CODE (opb0) == PLUS\n-      && GET_CODE (XEXP (opb0, 1)) == CONST_INT\n+      && CONST_INT_P (XEXP (opb0, 1))\n       /* Avoid overflows.  */\n       && ((unsigned HOST_WIDE_INT) INTVAL (XEXP (opb0, 1))\n \t  != ((unsigned HOST_WIDE_INT)1\n@@ -1581,12 +1581,12 @@ implies_p (rtx a, rtx b)\n \n   /* Likewise, A != N implies A - N > 0.  */\n   if (GET_CODE (a) == NE\n-      && GET_CODE (op1) == CONST_INT)\n+      && CONST_INT_P (op1))\n     {\n       if (GET_CODE (b) == GTU\n \t  && GET_CODE (opb0) == PLUS\n \t  && opb1 == const0_rtx\n-\t  && GET_CODE (XEXP (opb0, 1)) == CONST_INT\n+\t  && CONST_INT_P (XEXP (opb0, 1))\n \t  /* Avoid overflows.  */\n \t  && ((unsigned HOST_WIDE_INT) INTVAL (XEXP (opb0, 1))\n \t      != ((unsigned HOST_WIDE_INT) 1 << (HOST_BITS_PER_WIDE_INT - 1)))\n@@ -1595,7 +1595,7 @@ implies_p (rtx a, rtx b)\n       if (GET_CODE (b) == GEU\n \t  && GET_CODE (opb0) == PLUS\n \t  && opb1 == const1_rtx\n-\t  && GET_CODE (XEXP (opb0, 1)) == CONST_INT\n+\t  && CONST_INT_P (XEXP (opb0, 1))\n \t  /* Avoid overflows.  */\n \t  && ((unsigned HOST_WIDE_INT) INTVAL (XEXP (opb0, 1))\n \t      != ((unsigned HOST_WIDE_INT) 1 << (HOST_BITS_PER_WIDE_INT - 1)))\n@@ -1605,11 +1605,11 @@ implies_p (rtx a, rtx b)\n \n   /* A >s X, where X is positive, implies A <u Y, if Y is negative.  */\n   if ((GET_CODE (a) == GT || GET_CODE (a) == GE)\n-      && GET_CODE (op1) == CONST_INT\n+      && CONST_INT_P (op1)\n       && ((GET_CODE (a) == GT && op1 == constm1_rtx)\n \t  || INTVAL (op1) >= 0)\n       && GET_CODE (b) == LTU\n-      && GET_CODE (opb1) == CONST_INT\n+      && CONST_INT_P (opb1)\n       && rtx_equal_p (op0, opb0))\n     return INTVAL (opb1) < 0;\n \n@@ -1648,7 +1648,7 @@ canon_condition (rtx cond)\n     mode = GET_MODE (op1);\n   gcc_assert (mode != VOIDmode);\n \n-  if (GET_CODE (op1) == CONST_INT\n+  if (CONST_INT_P (op1)\n       && GET_MODE_CLASS (mode) != MODE_CC\n       && GET_MODE_BITSIZE (mode) <= HOST_BITS_PER_WIDE_INT)\n     {\n@@ -2202,7 +2202,7 @@ determine_max_iter (struct loop *loop, struct niter_desc *desc, rtx old_niter)\n   unsigned HOST_WIDEST_INT nmax, inc;\n \n   if (GET_CODE (niter) == AND\n-      && GET_CODE (XEXP (niter, 0)) == CONST_INT)\n+      && CONST_INT_P (XEXP (niter, 0)))\n     {\n       nmax = INTVAL (XEXP (niter, 0));\n       if (!(nmax & (nmax + 1)))\n@@ -2217,7 +2217,7 @@ determine_max_iter (struct loop *loop, struct niter_desc *desc, rtx old_niter)\n \n   if (GET_CODE (niter) == UDIV)\n     {\n-      if (GET_CODE (XEXP (niter, 1)) != CONST_INT)\n+      if (!CONST_INT_P (XEXP (niter, 1)))\n \t{\n \t  desc->niter_max = nmax;\n \t  return nmax;\n@@ -2345,7 +2345,7 @@ iv_number_of_iterations (struct loop *loop, rtx insn, rtx condition,\n   mode_mmin = lowpart_subreg (mode, mmin, comp_mode);\n   mode_mmax = lowpart_subreg (mode, mmax, comp_mode);\n \n-  if (GET_CODE (iv0.step) != CONST_INT || GET_CODE (iv1.step) != CONST_INT)\n+  if (!CONST_INT_P (iv0.step) || !CONST_INT_P (iv1.step))\n     goto fail;\n \n   /* We can take care of the case of two induction variables chasing each other\n@@ -2476,7 +2476,7 @@ iv_number_of_iterations (struct loop *loop, rtx insn, rtx condition,\n       may_xform = const0_rtx;\n       may_not_xform = const_true_rtx;\n \n-      if (GET_CODE (delta) == CONST_INT)\n+      if (CONST_INT_P (delta))\n \t{\n \t  if (was_sharp && INTVAL (delta) == INTVAL (step) - 1)\n \t    {\n@@ -2539,11 +2539,11 @@ iv_number_of_iterations (struct loop *loop, rtx insn, rtx condition,\n \t     number of iterations in this step, so record the information\n \t     here.  */\n \t  inc = INTVAL (iv0.step) - INTVAL (iv1.step);\n-\t  if (GET_CODE (iv1.base) == CONST_INT)\n+\t  if (CONST_INT_P (iv1.base))\n \t    up = INTVAL (iv1.base);\n \t  else\n \t    up = INTVAL (mode_mmax) - inc;\n-\t  down = INTVAL (GET_CODE (iv0.base) == CONST_INT\n+\t  down = INTVAL (CONST_INT_P (iv0.base)\n \t\t\t ? iv0.base\n \t\t\t : mode_mmin);\n \t  desc->niter_max = (up - down) / inc + 1;\n@@ -2752,7 +2752,7 @@ iv_number_of_iterations (struct loop *loop, rtx insn, rtx condition,\n       && XEXP (desc->noloop_assumptions, 0) == const_true_rtx)\n     goto zero_iter;\n \n-  if (GET_CODE (desc->niter_expr) == CONST_INT)\n+  if (CONST_INT_P (desc->niter_expr))\n     {\n       unsigned HOST_WIDEST_INT val = INTVAL (desc->niter_expr);\n "}, {"sha": "c8947f9d36ad633da6d7d169c77df0fc69164d30", "filename": "gcc/lower-subreg.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/481683e1d53b27779b31c1816606eb17975a9b1f/gcc%2Flower-subreg.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/481683e1d53b27779b31c1816606eb17975a9b1f/gcc%2Flower-subreg.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flower-subreg.c?ref=481683e1d53b27779b31c1816606eb17975a9b1f", "patch": "@@ -922,7 +922,7 @@ find_decomposable_shift_zext (rtx insn)\n     }\n   else /* left or right shift */\n     {\n-      if (GET_CODE (XEXP (op, 1)) != CONST_INT\n+      if (!CONST_INT_P (XEXP (op, 1))\n \t  || INTVAL (XEXP (op, 1)) < BITS_PER_WORD\n \t  || GET_MODE_BITSIZE (GET_MODE (op_operand)) != 2 * BITS_PER_WORD)\n \treturn 0;"}, {"sha": "6089580ed4d9325e8403beaeee3ac4029584a6c1", "filename": "gcc/modulo-sched.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/481683e1d53b27779b31c1816606eb17975a9b1f/gcc%2Fmodulo-sched.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/481683e1d53b27779b31c1816606eb17975a9b1f/gcc%2Fmodulo-sched.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fmodulo-sched.c?ref=481683e1d53b27779b31c1816606eb17975a9b1f", "patch": "@@ -353,7 +353,7 @@ const_iteration_count (rtx count_reg, basic_block pre_header,\n       {\n \trtx pat = single_set (insn);\n \n-\tif (GET_CODE (SET_SRC (pat)) == CONST_INT)\n+\tif (CONST_INT_P (SET_SRC (pat)))\n \t  {\n \t    *count = INTVAL (SET_SRC (pat));\n \t    return insn;"}, {"sha": "d76d41e4b5b7324b4f3b650d463ef119266df19b", "filename": "gcc/optabs.c", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/481683e1d53b27779b31c1816606eb17975a9b1f/gcc%2Foptabs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/481683e1d53b27779b31c1816606eb17975a9b1f/gcc%2Foptabs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Foptabs.c?ref=481683e1d53b27779b31c1816606eb17975a9b1f", "patch": "@@ -1093,7 +1093,7 @@ expand_doubleword_shift (enum machine_mode op1_mode, optab binoptab,\n   /* If we can compute the condition at compile time, pick the\n      appropriate subroutine.  */\n   tmp = simplify_relational_operation (cmp_code, SImode, op1_mode, cmp1, cmp2);\n-  if (tmp != 0 && GET_CODE (tmp) == CONST_INT)\n+  if (tmp != 0 && CONST_INT_P (tmp))\n     {\n       if (tmp == const0_rtx)\n \treturn expand_superword_shift (binoptab, outof_input, superword_op1,\n@@ -1395,7 +1395,7 @@ avoid_expensive_constant (enum machine_mode mode, optab binoptab,\n       && rtx_cost (x, binoptab->code, optimize_insn_for_speed_p ())\n                    > COSTS_N_INSNS (1))\n     {\n-      if (GET_CODE (x) == CONST_INT)\n+      if (CONST_INT_P (x))\n \t{\n \t  HOST_WIDE_INT intval = trunc_int_for_mode (INTVAL (x), mode);\n \t  if (intval != INTVAL (x))\n@@ -1562,7 +1562,7 @@ expand_binop (enum machine_mode mode, optab binoptab, rtx op0, rtx op1,\n   /* If subtracting an integer constant, convert this into an addition of\n      the negated constant.  */\n \n-  if (binoptab == sub_optab && GET_CODE (op1) == CONST_INT)\n+  if (binoptab == sub_optab && CONST_INT_P (op1))\n     {\n       op1 = negate_rtx (mode, op1);\n       binoptab = add_optab;\n@@ -1594,7 +1594,7 @@ expand_binop (enum machine_mode mode, optab binoptab, rtx op0, rtx op1,\n       rtx newop1;\n       unsigned int bits = GET_MODE_BITSIZE (mode);\n \n-      if (GET_CODE (op1) == CONST_INT)\n+      if (CONST_INT_P (op1))\n \tnewop1 = GEN_INT (bits - INTVAL (op1));\n       else if (targetm.shift_truncation_mask (mode) == bits - 1)\n \tnewop1 = negate_rtx (mode, op1);\n@@ -1765,7 +1765,7 @@ expand_binop (enum machine_mode mode, optab binoptab, rtx op0, rtx op1,\n   if ((binoptab == lshr_optab || binoptab == ashl_optab\n        || binoptab == ashr_optab)\n       && mclass == MODE_INT\n-      && (GET_CODE (op1) == CONST_INT || optimize_insn_for_speed_p ())\n+      && (CONST_INT_P (op1) || optimize_insn_for_speed_p ())\n       && GET_MODE_SIZE (mode) == 2 * UNITS_PER_WORD\n       && optab_handler (binoptab, word_mode)->insn_code != CODE_FOR_nothing\n       && optab_handler (ashl_optab, word_mode)->insn_code != CODE_FOR_nothing\n@@ -1779,7 +1779,7 @@ expand_binop (enum machine_mode mode, optab binoptab, rtx op0, rtx op1,\n       op1_mode = GET_MODE (op1) != VOIDmode ? GET_MODE (op1) : word_mode;\n \n       /* Apply the truncation to constant shifts.  */\n-      if (double_shift_mask > 0 && GET_CODE (op1) == CONST_INT)\n+      if (double_shift_mask > 0 && CONST_INT_P (op1))\n \top1 = GEN_INT (INTVAL (op1) & double_shift_mask);\n \n       if (op1 == CONST0_RTX (op1_mode))\n@@ -1835,7 +1835,7 @@ expand_binop (enum machine_mode mode, optab binoptab, rtx op0, rtx op1,\n   /* Synthesize double word rotates from single word shifts.  */\n   if ((binoptab == rotl_optab || binoptab == rotr_optab)\n       && mclass == MODE_INT\n-      && GET_CODE (op1) == CONST_INT\n+      && CONST_INT_P (op1)\n       && GET_MODE_SIZE (mode) == 2 * UNITS_PER_WORD\n       && optab_handler (ashl_optab, word_mode)->insn_code != CODE_FOR_nothing\n       && optab_handler (lshr_optab, word_mode)->insn_code != CODE_FOR_nothing)\n@@ -4068,7 +4068,7 @@ prepare_cmp_insn (rtx x, rtx y, enum rtx_code comparison, rtx size,\n \t    continue;\n \n \t  /* Must make sure the size fits the insn's mode.  */\n-\t  if ((GET_CODE (size) == CONST_INT\n+\t  if ((CONST_INT_P (size)\n \t       && INTVAL (size) >= (1 << GET_MODE_BITSIZE (cmp_mode)))\n \t      || (GET_MODE_BITSIZE (GET_MODE (size))\n \t\t  > GET_MODE_BITSIZE (cmp_mode)))"}, {"sha": "01e1f17ce040d02c2b04efafe31e0001d5a03330", "filename": "gcc/postreload.c", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/481683e1d53b27779b31c1816606eb17975a9b1f/gcc%2Fpostreload.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/481683e1d53b27779b31c1816606eb17975a9b1f/gcc%2Fpostreload.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpostreload.c?ref=481683e1d53b27779b31c1816606eb17975a9b1f", "patch": "@@ -284,7 +284,7 @@ reload_cse_simplify_set (rtx set, rtx insn)\n \n \t      /* ??? I'm lazy and don't wish to handle CONST_DOUBLE.  Other\n \t\t constants, such as SYMBOL_REF, cannot be extended.  */\n-\t      if (GET_CODE (this_rtx) != CONST_INT)\n+\t      if (!CONST_INT_P (this_rtx))\n \t\tcontinue;\n \n \t      this_val = INTVAL (this_rtx);\n@@ -570,7 +570,7 @@ reload_cse_simplify_operands (rtx insn, rtx testreg)\n \t\t     a cheap CONST_INT.  */\n \t\t  if (op_alt_regno[i][j] == -1\n \t\t      && reg_fits_class_p (testreg, rclass, 0, mode)\n-\t\t      && (GET_CODE (recog_data.operand[i]) != CONST_INT\n+\t\t      && (!CONST_INT_P (recog_data.operand[i])\n \t\t\t  || (rtx_cost (recog_data.operand[i], SET,\n \t\t\t  \t\toptimize_bb_for_speed_p (BLOCK_FOR_INSN (insn)))\n \t\t\t      > rtx_cost (testreg, SET,\n@@ -860,7 +860,7 @@ reload_combine (void)\n \t     (REGY), i.e. BASE, is not clobbered before the last use we'll\n \t     create.  */\n \t  if (prev_set != 0\n-\t      && GET_CODE (SET_SRC (prev_set)) == CONST_INT\n+\t      && CONST_INT_P (SET_SRC (prev_set))\n \t      && rtx_equal_p (SET_DEST (prev_set), reg)\n \t      && reg_state[regno].use_index >= 0\n \t      && (reg_state[REGNO (base)].store_ruid\n@@ -1074,7 +1074,7 @@ reload_combine_note_use (rtx *xp, rtx insn)\n     case PLUS:\n       /* We are interested in (plus (reg) (const_int)) .  */\n       if (!REG_P (XEXP (x, 0))\n-\t  || GET_CODE (XEXP (x, 1)) != CONST_INT)\n+\t  || !CONST_INT_P (XEXP (x, 1)))\n \tbreak;\n       offset = XEXP (x, 1);\n       x = XEXP (x, 0);\n@@ -1239,7 +1239,7 @@ reload_cse_move2add (rtx first)\n \t\t\t\t  (set (STRICT_LOW_PART (REGX)) (CONST_INT B))\n \t      */\n \n-\t      if (GET_CODE (src) == CONST_INT && reg_base_reg[regno] < 0)\n+\t      if (CONST_INT_P (src) && reg_base_reg[regno] < 0)\n \t\t{\n \t\t  rtx new_src = gen_int_mode (INTVAL (src) - reg_offset[regno],\n \t\t\t\t\t      GET_MODE (reg));\n@@ -1325,7 +1325,7 @@ reload_cse_move2add (rtx first)\n \t\t      && SET_DEST (set) == reg\n \t\t      && GET_CODE (SET_SRC (set)) == PLUS\n \t\t      && XEXP (SET_SRC (set), 0) == reg\n-\t\t      && GET_CODE (XEXP (SET_SRC (set), 1)) == CONST_INT)\n+\t\t      && CONST_INT_P (XEXP (SET_SRC (set), 1)))\n \t\t    {\n \t\t      rtx src3 = XEXP (SET_SRC (set), 1);\n \t\t      HOST_WIDE_INT added_offset = INTVAL (src3);\n@@ -1398,7 +1398,7 @@ reload_cse_move2add (rtx first)\n \t\t allocation if possible.  */\n \t      && SCALAR_INT_MODE_P (GET_MODE (XEXP (cnd, 0)))\n \t      && hard_regno_nregs[REGNO (XEXP (cnd, 0))][GET_MODE (XEXP (cnd, 0))] == 1\n-\t      && GET_CODE (XEXP (cnd, 1)) == CONST_INT)\n+\t      && CONST_INT_P (XEXP (cnd, 1)))\n \t    {\n \t      rtx implicit_set =\n \t\tgen_rtx_SET (VOIDmode, XEXP (cnd, 0), XEXP (cnd, 1));\n@@ -1479,7 +1479,7 @@ move2add_note_store (rtx dst, const_rtx set, void *data ATTRIBUTE_UNUSED)\n \t    {\n \t      base_reg = XEXP (src, 0);\n \n-\t      if (GET_CODE (XEXP (src, 1)) == CONST_INT)\n+\t      if (CONST_INT_P (XEXP (src, 1)))\n \t\toffset = INTVAL (XEXP (src, 1));\n \t      else if (REG_P (XEXP (src, 1))\n \t\t       && (reg_set_luid[REGNO (XEXP (src, 1))]"}, {"sha": "7f8a6c9b50168adcf06d4373735843b48313c503", "filename": "gcc/print-rtl.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/481683e1d53b27779b31c1816606eb17975a9b1f/gcc%2Fprint-rtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/481683e1d53b27779b31c1816606eb17975a9b1f/gcc%2Fprint-rtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fprint-rtl.c?ref=481683e1d53b27779b31c1816606eb17975a9b1f", "patch": "@@ -175,7 +175,7 @@ print_rtx (const_rtx in_rtx)\n   else\n     {\n       /* Print name of expression code.  */\n-      if (flag_simple && GET_CODE (in_rtx) == CONST_INT)\n+      if (flag_simple && CONST_INT_P (in_rtx))\n \tfputc ('(', outfile);\n       else\n \tfprintf (outfile, \"(%s\", GET_RTX_NAME (GET_CODE (in_rtx)));"}, {"sha": "9b88c66e2a8af0e440234596944f979383b88e96", "filename": "gcc/recog.c", "status": "modified", "additions": 24, "deletions": 24, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/481683e1d53b27779b31c1816606eb17975a9b1f/gcc%2Frecog.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/481683e1d53b27779b31c1816606eb17975a9b1f/gcc%2Frecog.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frecog.c?ref=481683e1d53b27779b31c1816606eb17975a9b1f", "patch": "@@ -550,13 +550,13 @@ simplify_while_replacing (rtx *loc, rtx to, rtx object,\n          simplify_gen_binary to try to simplify it.\n          ??? We may want later to remove this, once simplification is\n          separated from this function.  */\n-      if (GET_CODE (XEXP (x, 1)) == CONST_INT && XEXP (x, 1) == to)\n+      if (CONST_INT_P (XEXP (x, 1)) && XEXP (x, 1) == to)\n \tvalidate_change (object, loc,\n \t\t\t simplify_gen_binary\n \t\t\t (PLUS, GET_MODE (x), XEXP (x, 0), XEXP (x, 1)), 1);\n       break;\n     case MINUS:\n-      if (GET_CODE (XEXP (x, 1)) == CONST_INT\n+      if (CONST_INT_P (XEXP (x, 1))\n \t  || GET_CODE (XEXP (x, 1)) == CONST_DOUBLE)\n \tvalidate_change (object, loc,\n \t\t\t simplify_gen_binary\n@@ -597,8 +597,8 @@ simplify_while_replacing (rtx *loc, rtx to, rtx object,\n          happen, we might just fail in some cases).  */\n \n       if (MEM_P (XEXP (x, 0))\n-\t  && GET_CODE (XEXP (x, 1)) == CONST_INT\n-\t  && GET_CODE (XEXP (x, 2)) == CONST_INT\n+\t  && CONST_INT_P (XEXP (x, 1))\n+\t  && CONST_INT_P (XEXP (x, 2))\n \t  && !mode_dependent_address_p (XEXP (XEXP (x, 0), 0))\n \t  && !MEM_VOLATILE_P (XEXP (x, 0)))\n \t{\n@@ -901,7 +901,7 @@ general_operand (rtx op, enum machine_mode mode)\n       && GET_MODE_CLASS (mode) != MODE_PARTIAL_INT)\n     return 0;\n \n-  if (GET_CODE (op) == CONST_INT\n+  if (CONST_INT_P (op)\n       && mode != VOIDmode\n       && trunc_int_for_mode (INTVAL (op), mode) != INTVAL (op))\n     return 0;\n@@ -1078,7 +1078,7 @@ immediate_operand (rtx op, enum machine_mode mode)\n       && GET_MODE_CLASS (mode) != MODE_PARTIAL_INT)\n     return 0;\n \n-  if (GET_CODE (op) == CONST_INT\n+  if (CONST_INT_P (op)\n       && mode != VOIDmode\n       && trunc_int_for_mode (INTVAL (op), mode) != INTVAL (op))\n     return 0;\n@@ -1095,7 +1095,7 @@ immediate_operand (rtx op, enum machine_mode mode)\n int\n const_int_operand (rtx op, enum machine_mode mode)\n {\n-  if (GET_CODE (op) != CONST_INT)\n+  if (!CONST_INT_P (op))\n     return 0;\n \n   if (mode != VOIDmode\n@@ -1118,7 +1118,7 @@ const_double_operand (rtx op, enum machine_mode mode)\n       && GET_MODE_CLASS (mode) != MODE_PARTIAL_INT)\n     return 0;\n \n-  return ((GET_CODE (op) == CONST_DOUBLE || GET_CODE (op) == CONST_INT)\n+  return ((GET_CODE (op) == CONST_DOUBLE || CONST_INT_P (op))\n \t  && (mode == VOIDmode || GET_MODE (op) == mode\n \t      || GET_MODE (op) == VOIDmode));\n }\n@@ -1145,7 +1145,7 @@ nonmemory_operand (rtx op, enum machine_mode mode)\n \t  && GET_MODE_CLASS (mode) != MODE_PARTIAL_INT)\n \treturn 0;\n \n-      if (GET_CODE (op) == CONST_INT\n+      if (CONST_INT_P (op)\n \t  && mode != VOIDmode\n \t  && trunc_int_for_mode (INTVAL (op), mode) != INTVAL (op))\n \treturn 0;\n@@ -1212,7 +1212,7 @@ push_operand (rtx op, enum machine_mode mode)\n       if (GET_CODE (op) != PRE_MODIFY\n \t  || GET_CODE (XEXP (op, 1)) != PLUS\n \t  || XEXP (XEXP (op, 1), 0) != XEXP (op, 0)\n-\t  || GET_CODE (XEXP (XEXP (op, 1), 1)) != CONST_INT\n+\t  || !CONST_INT_P (XEXP (XEXP (op, 1), 1))\n #ifdef STACK_GROWS_DOWNWARD\n \t  || INTVAL (XEXP (XEXP (op, 1), 1)) != - (int) rounded_size\n #else\n@@ -1313,7 +1313,7 @@ indirect_operand (rtx op, enum machine_mode mode)\n \n       return ((offset == 0 && general_operand (XEXP (inner, 0), Pmode))\n \t      || (GET_CODE (XEXP (inner, 0)) == PLUS\n-\t\t  && GET_CODE (XEXP (XEXP (inner, 0), 1)) == CONST_INT\n+\t\t  && CONST_INT_P (XEXP (XEXP (inner, 0), 1))\n \t\t  && INTVAL (XEXP (XEXP (inner, 0), 1)) == -offset\n \t\t  && general_operand (XEXP (XEXP (inner, 0), 0), Pmode)));\n     }\n@@ -1696,7 +1696,7 @@ asm_operand_ok (rtx op, const char *constraint, const char **constraints)\n \t  break;\n \n \tcase 's':\n-\t  if (GET_CODE (op) == CONST_INT\n+\t  if (CONST_INT_P (op)\n \t      || (GET_CODE (op) == CONST_DOUBLE\n \t\t  && GET_MODE (op) == VOIDmode))\n \t    break;\n@@ -1708,49 +1708,49 @@ asm_operand_ok (rtx op, const char *constraint, const char **constraints)\n \t  break;\n \n \tcase 'n':\n-\t  if (GET_CODE (op) == CONST_INT\n+\t  if (CONST_INT_P (op)\n \t      || (GET_CODE (op) == CONST_DOUBLE\n \t\t  && GET_MODE (op) == VOIDmode))\n \t    result = 1;\n \t  break;\n \n \tcase 'I':\n-\t  if (GET_CODE (op) == CONST_INT\n+\t  if (CONST_INT_P (op)\n \t      && CONST_OK_FOR_CONSTRAINT_P (INTVAL (op), 'I', constraint))\n \t    result = 1;\n \t  break;\n \tcase 'J':\n-\t  if (GET_CODE (op) == CONST_INT\n+\t  if (CONST_INT_P (op)\n \t      && CONST_OK_FOR_CONSTRAINT_P (INTVAL (op), 'J', constraint))\n \t    result = 1;\n \t  break;\n \tcase 'K':\n-\t  if (GET_CODE (op) == CONST_INT\n+\t  if (CONST_INT_P (op)\n \t      && CONST_OK_FOR_CONSTRAINT_P (INTVAL (op), 'K', constraint))\n \t    result = 1;\n \t  break;\n \tcase 'L':\n-\t  if (GET_CODE (op) == CONST_INT\n+\t  if (CONST_INT_P (op)\n \t      && CONST_OK_FOR_CONSTRAINT_P (INTVAL (op), 'L', constraint))\n \t    result = 1;\n \t  break;\n \tcase 'M':\n-\t  if (GET_CODE (op) == CONST_INT\n+\t  if (CONST_INT_P (op)\n \t      && CONST_OK_FOR_CONSTRAINT_P (INTVAL (op), 'M', constraint))\n \t    result = 1;\n \t  break;\n \tcase 'N':\n-\t  if (GET_CODE (op) == CONST_INT\n+\t  if (CONST_INT_P (op)\n \t      && CONST_OK_FOR_CONSTRAINT_P (INTVAL (op), 'N', constraint))\n \t    result = 1;\n \t  break;\n \tcase 'O':\n-\t  if (GET_CODE (op) == CONST_INT\n+\t  if (CONST_INT_P (op)\n \t      && CONST_OK_FOR_CONSTRAINT_P (INTVAL (op), 'O', constraint))\n \t    result = 1;\n \t  break;\n \tcase 'P':\n-\t  if (GET_CODE (op) == CONST_INT\n+\t  if (CONST_INT_P (op)\n \t      && CONST_OK_FOR_CONSTRAINT_P (INTVAL (op), 'P', constraint))\n \t    result = 1;\n \t  break;\n@@ -2536,7 +2536,7 @@ constrain_operands (int strict)\n \t\tbreak;\n \n \t      case 's':\n-\t\tif (GET_CODE (op) == CONST_INT\n+\t\tif (CONST_INT_P (op)\n \t\t    || (GET_CODE (op) == CONST_DOUBLE\n \t\t\t&& GET_MODE (op) == VOIDmode))\n \t\t  break;\n@@ -2546,7 +2546,7 @@ constrain_operands (int strict)\n \t\tbreak;\n \n \t      case 'n':\n-\t\tif (GET_CODE (op) == CONST_INT\n+\t\tif (CONST_INT_P (op)\n \t\t    || (GET_CODE (op) == CONST_DOUBLE\n \t\t\t&& GET_MODE (op) == VOIDmode))\n \t\t  win = 1;\n@@ -2560,7 +2560,7 @@ constrain_operands (int strict)\n \t      case 'N':\n \t      case 'O':\n \t      case 'P':\n-\t\tif (GET_CODE (op) == CONST_INT\n+\t\tif (CONST_INT_P (op)\n \t\t    && CONST_OK_FOR_CONSTRAINT_P (INTVAL (op), c, p))\n \t\t  win = 1;\n \t\tbreak;"}, {"sha": "d5da41aeae1c51547cc0f044ca333b6995d56ba2", "filename": "gcc/reginfo.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/481683e1d53b27779b31c1816606eb17975a9b1f/gcc%2Freginfo.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/481683e1d53b27779b31c1816606eb17975a9b1f/gcc%2Freginfo.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freginfo.c?ref=481683e1d53b27779b31c1816606eb17975a9b1f", "patch": "@@ -1126,7 +1126,7 @@ reg_scan_mark_refs (rtx x, rtx insn)\n \t       && REG_POINTER (SET_SRC (x)))\n \t      || ((GET_CODE (SET_SRC (x)) == PLUS\n \t\t   || GET_CODE (SET_SRC (x)) == LO_SUM)\n-\t\t  && GET_CODE (XEXP (SET_SRC (x), 1)) == CONST_INT\n+\t\t  && CONST_INT_P (XEXP (SET_SRC (x), 1))\n \t\t  && REG_P (XEXP (SET_SRC (x), 0))\n \t\t  && REG_POINTER (XEXP (SET_SRC (x), 0)))\n \t      || GET_CODE (SET_SRC (x)) == CONST"}, {"sha": "3341d3f159df9d8fcce9146e6ed7e44e17d981c6", "filename": "gcc/regmove.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/481683e1d53b27779b31c1816606eb17975a9b1f/gcc%2Fregmove.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/481683e1d53b27779b31c1816606eb17975a9b1f/gcc%2Fregmove.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fregmove.c?ref=481683e1d53b27779b31c1816606eb17975a9b1f", "patch": "@@ -105,7 +105,7 @@ find_use_as_address (rtx x, rtx reg, HOST_WIDE_INT plusconst)\n \n   if (code == MEM && GET_CODE (XEXP (x, 0)) == PLUS\n       && XEXP (XEXP (x, 0), 0) == reg\n-      && GET_CODE (XEXP (XEXP (x, 0), 1)) == CONST_INT\n+      && CONST_INT_P (XEXP (XEXP (x, 0), 1))\n       && INTVAL (XEXP (XEXP (x, 0), 1)) == plusconst)\n     return x;\n \n@@ -774,7 +774,7 @@ fixup_match_2 (rtx insn, rtx dst, rtx src, rtx offset)\n       if (pset && SET_DEST (pset) == dst\n \t  && GET_CODE (SET_SRC (pset)) == PLUS\n \t  && XEXP (SET_SRC (pset), 0) == src\n-\t  && GET_CODE (XEXP (SET_SRC (pset), 1)) == CONST_INT)\n+\t  && CONST_INT_P (XEXP (SET_SRC (pset), 1)))\n \t{\n \t  HOST_WIDE_INT newconst\n \t    = INTVAL (offset) - INTVAL (XEXP (SET_SRC (pset), 1));\n@@ -1015,7 +1015,7 @@ regmove_backward_pass (void)\n \t      if (REGNO (src) < FIRST_PSEUDO_REGISTER)\n \t\t{\n \t\t  if (GET_CODE (SET_SRC (set)) == PLUS\n-\t\t      && GET_CODE (XEXP (SET_SRC (set), 1)) == CONST_INT\n+\t\t      && CONST_INT_P (XEXP (SET_SRC (set), 1))\n \t\t      && XEXP (SET_SRC (set), 0) == src\n \t\t      && fixup_match_2 (insn, dst, src,\n \t\t\t\t\tXEXP (SET_SRC (set), 1)))"}, {"sha": "889a07f13698f3d5c798e0d1495abf069bcefdc9", "filename": "gcc/reload.c", "status": "modified", "additions": 20, "deletions": 20, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/481683e1d53b27779b31c1816606eb17975a9b1f/gcc%2Freload.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/481683e1d53b27779b31c1816606eb17975a9b1f/gcc%2Freload.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freload.c?ref=481683e1d53b27779b31c1816606eb17975a9b1f", "patch": "@@ -2393,12 +2393,12 @@ decompose (rtx x)\n \t  offset = XEXP (offset, 0);\n \tif (GET_CODE (offset) == PLUS)\n \t  {\n-\t    if (GET_CODE (XEXP (offset, 0)) == CONST_INT)\n+\t    if (CONST_INT_P (XEXP (offset, 0)))\n \t      {\n \t\tbase = gen_rtx_PLUS (GET_MODE (base), base, XEXP (offset, 1));\n \t\toffset = XEXP (offset, 0);\n \t      }\n-\t    else if (GET_CODE (XEXP (offset, 1)) == CONST_INT)\n+\t    else if (CONST_INT_P (XEXP (offset, 1)))\n \t      {\n \t\tbase = gen_rtx_PLUS (GET_MODE (base), base, XEXP (offset, 0));\n \t\toffset = XEXP (offset, 1);\n@@ -2409,7 +2409,7 @@ decompose (rtx x)\n \t\toffset = const0_rtx;\n \t      }\n \t  }\n-\telse if (GET_CODE (offset) != CONST_INT)\n+\telse if (!CONST_INT_P (offset))\n \t  {\n \t    base = gen_rtx_PLUS (GET_MODE (base), base, offset);\n \t    offset = const0_rtx;\n@@ -2418,7 +2418,7 @@ decompose (rtx x)\n \tif (all_const && GET_CODE (base) == PLUS)\n \t  base = gen_rtx_CONST (GET_MODE (base), base);\n \t\n-\tgcc_assert (GET_CODE (offset) == CONST_INT);\n+\tgcc_assert (CONST_INT_P (offset));\n \t\n \tval.start = INTVAL (offset);\n \tval.end = val.start + GET_MODE_SIZE (GET_MODE (x));\n@@ -3322,7 +3322,7 @@ find_reloads (rtx insn, int replace, int ind_levels, int live_known,\n \t\tbreak;\n \n \t      case 's':\n-\t\tif (GET_CODE (operand) == CONST_INT\n+\t\tif (CONST_INT_P (operand)\n \t\t    || (GET_CODE (operand) == CONST_DOUBLE\n \t\t\t&& GET_MODE (operand) == VOIDmode))\n \t\t  break;\n@@ -3333,7 +3333,7 @@ find_reloads (rtx insn, int replace, int ind_levels, int live_known,\n \t\tbreak;\n \n \t      case 'n':\n-\t\tif (GET_CODE (operand) == CONST_INT\n+\t\tif (CONST_INT_P (operand)\n \t\t    || (GET_CODE (operand) == CONST_DOUBLE\n \t\t\t&& GET_MODE (operand) == VOIDmode))\n \t\t  win = 1;\n@@ -3347,7 +3347,7 @@ find_reloads (rtx insn, int replace, int ind_levels, int live_known,\n \t      case 'N':\n \t      case 'O':\n \t      case 'P':\n-\t\tif (GET_CODE (operand) == CONST_INT\n+\t\tif (CONST_INT_P (operand)\n \t\t    && CONST_OK_FOR_CONSTRAINT_P (INTVAL (operand), c, p))\n \t\t  win = 1;\n \t\tbreak;\n@@ -4233,7 +4233,7 @@ find_reloads (rtx insn, int replace, int ind_levels, int live_known,\n   /* If we detected error and replaced asm instruction by USE, forget about the\n      reloads.  */\n   if (GET_CODE (PATTERN (insn)) == USE\n-      && GET_CODE (XEXP (PATTERN (insn), 0)) == CONST_INT)\n+      && CONST_INT_P (XEXP (PATTERN (insn), 0)))\n     n_reloads = 0;\n \n   /* Perhaps an output reload can be combined with another\n@@ -4934,7 +4934,7 @@ find_reloads_address (enum machine_mode mode, rtx *memrefloc, rtx ad,\n \n       /* But first quickly dispose of a common case.  */\n       if (GET_CODE (ad) == PLUS\n-\t  && GET_CODE (XEXP (ad, 1)) == CONST_INT\n+\t  && CONST_INT_P (XEXP (ad, 1))\n \t  && REG_P (XEXP (ad, 0))\n \t  && reg_equiv_constant[REGNO (XEXP (ad, 0))] == 0)\n \treturn 0;\n@@ -5014,7 +5014,7 @@ find_reloads_address (enum machine_mode mode, rtx *memrefloc, rtx ad,\n \t  || ! (REG_P (XEXP (tem, 0))\n \t\t|| (GET_CODE (XEXP (tem, 0)) == PLUS\n \t\t    && REG_P (XEXP (XEXP (tem, 0), 0))\n-\t\t    && GET_CODE (XEXP (XEXP (tem, 0), 1)) == CONST_INT)))\n+\t\t    && CONST_INT_P (XEXP (XEXP (tem, 0), 1)))))\n \t{\n \t  /* Must use TEM here, not AD, since it is the one that will\n \t     have any subexpressions reloaded, if needed.  */\n@@ -5036,7 +5036,7 @@ find_reloads_address (enum machine_mode mode, rtx *memrefloc, rtx ad,\n   else if (GET_CODE (ad) == PLUS\n \t   && REG_P (XEXP (ad, 0))\n \t   && REGNO (XEXP (ad, 0)) < FIRST_PSEUDO_REGISTER\n-\t   && GET_CODE (XEXP (ad, 1)) == CONST_INT\n+\t   && CONST_INT_P (XEXP (ad, 1))\n \t   && regno_ok_for_base_p (REGNO (XEXP (ad, 0)), mode, PLUS,\n \t\t\t\t   CONST_INT))\n \n@@ -5110,7 +5110,7 @@ find_reloads_address (enum machine_mode mode, rtx *memrefloc, rtx ad,\n \n       inner_code = GET_CODE (XEXP (ad, 0));\n       if (!(GET_CODE (ad) == PLUS \n-\t    && GET_CODE (XEXP (ad, 1)) == CONST_INT\n+\t    && CONST_INT_P (XEXP (ad, 1))\n \t    && (inner_code == PLUS || inner_code == LO_SUM)))\n \tcontinue;\n \n@@ -5266,7 +5266,7 @@ subst_reg_equivs (rtx ad, rtx insn)\n     case PLUS:\n       /* Quickly dispose of a common case.  */\n       if (XEXP (ad, 0) == frame_pointer_rtx\n-\t  && GET_CODE (XEXP (ad, 1)) == CONST_INT)\n+\t  && CONST_INT_P (XEXP (ad, 1)))\n \treturn ad;\n       break;\n \n@@ -5300,9 +5300,9 @@ form_sum (rtx x, rtx y)\n   if (mode == VOIDmode)\n     mode = Pmode;\n \n-  if (GET_CODE (x) == CONST_INT)\n+  if (CONST_INT_P (x))\n     return plus_constant (y, INTVAL (x));\n-  else if (GET_CODE (y) == CONST_INT)\n+  else if (CONST_INT_P (y))\n     return plus_constant (x, INTVAL (y));\n   else if (CONSTANT_P (x))\n     tem = x, x = y, y = tem;\n@@ -6111,7 +6111,7 @@ find_reloads_subreg_address (rtx x, int force_replace, int opnum,\n \t\t  base = XEXP (tem, 0);\n \t\t  if (GET_CODE (base) == PLUS)\n \t\t    {\n-\t\t      if (GET_CODE (XEXP (base, 1)) == CONST_INT\n+\t\t      if (CONST_INT_P (XEXP (base, 1))\n \t\t\t  && INTVAL (XEXP (base, 1)) % outer_size != 0)\n \t\t\treturn x;\n \t\t      base = XEXP (base, 0);\n@@ -6547,7 +6547,7 @@ reg_overlap_mentioned_for_reload_p (rtx x, rtx in)\n   /* If either argument is a constant, then modifying X can not affect IN.  */\n   if (CONSTANT_P (x) || CONSTANT_P (in))\n     return 0;\n-  else if (GET_CODE (x) == SUBREG && GET_CODE (SUBREG_REG (x)) == MEM)\n+  else if (GET_CODE (x) == SUBREG && MEM_P (SUBREG_REG (x)))\n     return refers_to_mem_for_reload_p (in);\n   else if (GET_CODE (x) == SUBREG)\n     {\n@@ -6781,7 +6781,7 @@ find_equiv_reg (rtx goal, rtx insn, enum reg_class rclass, int other,\n \t\t\t  || (REG_P (SET_DEST (pat))\n \t\t\t      && GET_CODE (XEXP (tem, 0)) == CONST_DOUBLE\n \t\t\t      && SCALAR_FLOAT_MODE_P (GET_MODE (XEXP (tem, 0)))\n-\t\t\t      && GET_CODE (goal) == CONST_INT\n+\t\t\t      && CONST_INT_P (goal)\n \t\t\t      && 0 != (goaltry\n \t\t\t\t       = operand_subword (XEXP (tem, 0), 0, 0,\n \t\t\t\t\t\t\t  VOIDmode))\n@@ -6795,7 +6795,7 @@ find_equiv_reg (rtx goal, rtx insn, enum reg_class rclass, int other,\n \t\t      && REG_P (SET_DEST (pat))\n \t\t      && GET_CODE (XEXP (tem, 0)) == CONST_DOUBLE\n \t\t      && SCALAR_FLOAT_MODE_P (GET_MODE (XEXP (tem, 0)))\n-\t\t      && GET_CODE (goal) == CONST_INT\n+\t\t      && CONST_INT_P (goal)\n \t\t      && 0 != (goaltry = operand_subword (XEXP (tem, 0), 1, 0,\n \t\t\t\t\t\t\t  VOIDmode))\n \t\t      && rtx_equal_p (goal, goaltry)\n@@ -7123,7 +7123,7 @@ find_inc_amount (rtx x, rtx inced)\n \t       && GET_CODE (XEXP (addr, 1)) == PLUS\n \t       && XEXP (addr, 0) == XEXP (XEXP (addr, 1), 0)\n \t       && XEXP (addr, 0) == inced\n-\t       && GET_CODE (XEXP (XEXP (addr, 1), 1)) == CONST_INT)\n+\t       && CONST_INT_P (XEXP (XEXP (addr, 1), 1)))\n \t{\n \t  i = INTVAL (XEXP (XEXP (addr, 1), 1));\n \t  return i < 0 ? -i : i;"}, {"sha": "064166fd13fa2a2f2afb8e38e62abd2ed078ed34", "filename": "gcc/reload1.c", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/481683e1d53b27779b31c1816606eb17975a9b1f/gcc%2Freload1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/481683e1d53b27779b31c1816606eb17975a9b1f/gcc%2Freload1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freload1.c?ref=481683e1d53b27779b31c1816606eb17975a9b1f", "patch": "@@ -2566,7 +2566,7 @@ eliminate_regs_1 (rtx x, enum machine_mode mem_mode, rtx insn,\n \t\t   We special-case the commonest situation in\n \t\t   eliminate_regs_in_insn, so just replace a PLUS with a\n \t\t   PLUS here, unless inside a MEM.  */\n-\t\tif (mem_mode != 0 && GET_CODE (XEXP (x, 1)) == CONST_INT\n+\t\tif (mem_mode != 0 && CONST_INT_P (XEXP (x, 1))\n \t\t    && INTVAL (XEXP (x, 1)) == - ep->previous_offset)\n \t\t  return ep->to_rtx;\n \t\telse\n@@ -2632,7 +2632,7 @@ eliminate_regs_1 (rtx x, enum machine_mode mem_mode, rtx insn,\n \t We ignore the possibility of overflow here.  */\n       if (REG_P (XEXP (x, 0))\n \t  && REGNO (XEXP (x, 0)) < FIRST_PSEUDO_REGISTER\n-\t  && GET_CODE (XEXP (x, 1)) == CONST_INT)\n+\t  && CONST_INT_P (XEXP (x, 1)))\n \tfor (ep = reg_eliminate; ep < &reg_eliminate[NUM_ELIMINABLE_REGS];\n \t     ep++)\n \t  if (ep->from_rtx == XEXP (x, 0) && ep->can_eliminate)\n@@ -3044,7 +3044,7 @@ elimination_effects (rtx x, enum machine_mode mem_mode)\n \n \t\tif (GET_CODE (src) == PLUS\n \t\t    && XEXP (src, 0) == SET_DEST (x)\n-\t\t    && GET_CODE (XEXP (src, 1)) == CONST_INT)\n+\t\t    && CONST_INT_P (XEXP (src, 1)))\n \t\t  ep->offset -= INTVAL (XEXP (src, 1));\n \t\telse\n \t\t  ep->can_eliminate = 0;\n@@ -3179,7 +3179,7 @@ eliminate_regs_in_insn (rtx insn, int replace)\n \t\t    rtx prev_insn, prev_set;\n \n \t\t    if (GET_CODE (base) == PLUS\n-\t\t        && GET_CODE (XEXP (base, 1)) == CONST_INT)\n+\t\t        && CONST_INT_P (XEXP (base, 1)))\n \t\t      {\n \t\t        offset += INTVAL (XEXP (base, 1));\n \t\t        base = XEXP (base, 0);\n@@ -3254,7 +3254,7 @@ eliminate_regs_in_insn (rtx insn, int replace)\n \tplus_src = SET_SRC (old_set);\n       /* First see if the source is of the form (plus (...) CST).  */\n       if (plus_src\n-\t  && GET_CODE (XEXP (plus_src, 1)) == CONST_INT)\n+\t  && CONST_INT_P (XEXP (plus_src, 1)))\n \tplus_cst_src = plus_src;\n       else if (REG_P (SET_SRC (old_set))\n \t       || plus_src)\n@@ -3267,7 +3267,7 @@ eliminate_regs_in_insn (rtx insn, int replace)\n \t      if ((REG_NOTE_KIND (links) == REG_EQUAL\n \t\t   || REG_NOTE_KIND (links) == REG_EQUIV)\n \t\t  && GET_CODE (XEXP (links, 0)) == PLUS\n-\t\t  && GET_CODE (XEXP (XEXP (links, 0), 1)) == CONST_INT)\n+\t\t  && CONST_INT_P (XEXP (XEXP (links, 0), 1)))\n \t\t{\n \t\t  plus_cst_src = XEXP (links, 0);\n \t\t  break;\n@@ -3579,7 +3579,7 @@ mark_not_eliminable (rtx dest, const_rtx x, void *data ATTRIBUTE_UNUSED)\n \t&& (GET_CODE (x) != SET\n \t    || GET_CODE (SET_SRC (x)) != PLUS\n \t    || XEXP (SET_SRC (x), 0) != dest\n-\t    || GET_CODE (XEXP (SET_SRC (x), 1)) != CONST_INT))\n+\t    || !CONST_INT_P (XEXP (SET_SRC (x), 1))))\n       {\n \treg_eliminate[i].can_eliminate_previous\n \t  = reg_eliminate[i].can_eliminate = 0;\n@@ -8577,8 +8577,8 @@ delete_address_reloads (rtx dead_insn, rtx current_insn)\n   set2 = single_set (prev);\n   if (! set || ! set2\n       || GET_CODE (SET_SRC (set)) != PLUS || GET_CODE (SET_SRC (set2)) != PLUS\n-      || GET_CODE (XEXP (SET_SRC (set), 1)) != CONST_INT\n-      || GET_CODE (XEXP (SET_SRC (set2), 1)) != CONST_INT)\n+      || !CONST_INT_P (XEXP (SET_SRC (set), 1))\n+      || !CONST_INT_P (XEXP (SET_SRC (set2), 1)))\n     return;\n   dst = SET_DEST (set);\n   if (! rtx_equal_p (dst, SET_DEST (set2))\n@@ -8803,7 +8803,7 @@ inc_for_reload (rtx reloadreg, rtx in, rtx value, int inc_amount)\n \n       emit_insn (gen_add2_insn (reloadreg, inc));\n       store = emit_insn (gen_move_insn (incloc, reloadreg));\n-      if (GET_CODE (inc) == CONST_INT)\n+      if (CONST_INT_P (inc))\n \temit_insn (gen_add2_insn (reloadreg, GEN_INT (-INTVAL (inc))));\n       else\n \temit_insn (gen_sub2_insn (reloadreg, inc));"}, {"sha": "4453ccabca6e678a8c9f451bd8d4b4401a3a80e6", "filename": "gcc/reorg.c", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/481683e1d53b27779b31c1816606eb17975a9b1f/gcc%2Freorg.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/481683e1d53b27779b31c1816606eb17975a9b1f/gcc%2Freorg.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freorg.c?ref=481683e1d53b27779b31c1816606eb17975a9b1f", "patch": "@@ -2931,7 +2931,7 @@ fill_slots_from_thread (rtx insn, rtx condition, rtx thread,\n \t  /* If this is a constant adjustment, use the same code with\n \t     the negated constant.  Otherwise, reverse the sense of the\n \t     arithmetic.  */\n-\t  if (GET_CODE (other) == CONST_INT)\n+\t  if (CONST_INT_P (other))\n \t    new_arith = gen_rtx_fmt_ee (GET_CODE (src), GET_MODE (src), dest,\n \t\t\t\t\tnegate_rtx (GET_MODE (src), other));\n \t  else\n@@ -3856,9 +3856,7 @@ dbr_schedule (rtx first)\n       INSN_FROM_TARGET_P (insn) = 0;\n \n       /* Skip vector tables.  We can't get attributes for them.  */\n-      if (JUMP_P (insn)\n-\t  && (GET_CODE (PATTERN (insn)) == ADDR_VEC\n-\t      || GET_CODE (PATTERN (insn)) == ADDR_DIFF_VEC))\n+      if (JUMP_TABLE_DATA_P (insn))\n \tcontinue;\n \n       if (num_delay_slots (insn) > 0)"}, {"sha": "fa4dddd17908e13eb059cbfc5282c66877dceea1", "filename": "gcc/rtl.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/481683e1d53b27779b31c1816606eb17975a9b1f/gcc%2Frtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/481683e1d53b27779b31c1816606eb17975a9b1f/gcc%2Frtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtl.c?ref=481683e1d53b27779b31c1816606eb17975a9b1f", "patch": "@@ -211,7 +211,7 @@ shared_const_p (const_rtx orig)\n      a LABEL_REF, it isn't sharable.  */\n   return (GET_CODE (XEXP (orig, 0)) == PLUS\n \t  && GET_CODE (XEXP (XEXP (orig, 0), 0)) == SYMBOL_REF\n-\t  && GET_CODE (XEXP (XEXP (orig, 0), 1)) == CONST_INT);\n+\t  && CONST_INT_P(XEXP (XEXP (orig, 0), 1)));\n }\n \n "}, {"sha": "49289b65c37566d4df23e3e033c957e1d2af4318", "filename": "gcc/rtlanal.c", "status": "modified", "additions": 20, "deletions": 22, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/481683e1d53b27779b31c1816606eb17975a9b1f/gcc%2Frtlanal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/481683e1d53b27779b31c1816606eb17975a9b1f/gcc%2Frtlanal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtlanal.c?ref=481683e1d53b27779b31c1816606eb17975a9b1f", "patch": "@@ -341,7 +341,7 @@ rtx_addr_can_trap_p_1 (const_rtx x, HOST_WIDE_INT offset, HOST_WIDE_INT size,\n       /* - or it is an address that can't trap plus a constant integer,\n \t   with the proper remainder modulo the mode size if we are\n \t   considering unaligned memory references.  */\n-      if (GET_CODE (XEXP (x, 1)) == CONST_INT\n+      if (CONST_INT_P (XEXP (x, 1))\n \t  && !rtx_addr_can_trap_p_1 (XEXP (x, 0), offset + INTVAL (XEXP (x, 1)),\n \t\t\t\t     size, mode, unaligned_mems))\n \treturn 0;\n@@ -408,7 +408,7 @@ nonzero_address_p (const_rtx x)\n       return nonzero_address_p (XEXP (x, 0));\n \n     case PLUS:\n-      if (GET_CODE (XEXP (x, 1)) == CONST_INT)\n+      if (CONST_INT_P (XEXP (x, 1)))\n         return nonzero_address_p (XEXP (x, 0));\n       /* Handle PIC references.  */\n       else if (XEXP (x, 0) == pic_offset_table_rtx\n@@ -420,7 +420,7 @@ nonzero_address_p (const_rtx x)\n       /* Similar to the above; allow positive offsets.  Further, since\n \t auto-inc is only allowed in memories, the register must be a\n \t pointer.  */\n-      if (GET_CODE (XEXP (x, 1)) == CONST_INT\n+      if (CONST_INT_P (XEXP (x, 1))\n \t  && INTVAL (XEXP (x, 1)) > 0)\n \treturn true;\n       return nonzero_address_p (XEXP (x, 0));\n@@ -495,10 +495,10 @@ get_integer_term (const_rtx x)\n     x = XEXP (x, 0);\n \n   if (GET_CODE (x) == MINUS\n-      && GET_CODE (XEXP (x, 1)) == CONST_INT)\n+      && CONST_INT_P (XEXP (x, 1)))\n     return - INTVAL (XEXP (x, 1));\n   if (GET_CODE (x) == PLUS\n-      && GET_CODE (XEXP (x, 1)) == CONST_INT)\n+      && CONST_INT_P (XEXP (x, 1)))\n     return INTVAL (XEXP (x, 1));\n   return 0;\n }\n@@ -514,10 +514,10 @@ get_related_value (const_rtx x)\n     return 0;\n   x = XEXP (x, 0);\n   if (GET_CODE (x) == PLUS\n-      && GET_CODE (XEXP (x, 1)) == CONST_INT)\n+      && CONST_INT_P (XEXP (x, 1)))\n     return XEXP (x, 0);\n   else if (GET_CODE (x) == MINUS\n-\t   && GET_CODE (XEXP (x, 1)) == CONST_INT)\n+\t   && CONST_INT_P (XEXP (x, 1)))\n     return XEXP (x, 0);\n   return 0;\n }\n@@ -566,7 +566,7 @@ split_const (rtx x, rtx *base_out, rtx *offset_out)\n   if (GET_CODE (x) == CONST)\n     {\n       x = XEXP (x, 0);\n-      if (GET_CODE (x) == PLUS && GET_CODE (XEXP (x, 1)) == CONST_INT)\n+      if (GET_CODE (x) == PLUS && CONST_INT_P (XEXP (x, 1)))\n \t{\n \t  *base_out = XEXP (x, 0);\n \t  *offset_out = XEXP (x, 1);\n@@ -2495,7 +2495,7 @@ replace_rtx (rtx x, rtx from, rtx to)\n     {\n       rtx new_rtx = replace_rtx (SUBREG_REG (x), from, to);\n \n-      if (GET_CODE (new_rtx) == CONST_INT)\n+      if (CONST_INT_P (new_rtx))\n \t{\n \t  x = simplify_subreg (GET_MODE (x), new_rtx,\n \t\t\t       GET_MODE (SUBREG_REG (x)),\n@@ -2511,7 +2511,7 @@ replace_rtx (rtx x, rtx from, rtx to)\n     {\n       rtx new_rtx = replace_rtx (XEXP (x, 0), from, to);\n \n-      if (GET_CODE (new_rtx) == CONST_INT)\n+      if (CONST_INT_P (new_rtx))\n \t{\n \t  x = simplify_unary_operation (ZERO_EXTEND, GET_MODE (x),\n \t\t\t\t\tnew_rtx, GET_MODE (XEXP (x, 0)));\n@@ -2641,9 +2641,7 @@ tablejump_p (const_rtx insn, rtx *labelp, rtx *tablep)\n   if (JUMP_P (insn)\n       && (label = JUMP_LABEL (insn)) != NULL_RTX\n       && (table = next_active_insn (label)) != NULL_RTX\n-      && JUMP_P (table)\n-      && (GET_CODE (PATTERN (table)) == ADDR_VEC\n-\t  || GET_CODE (PATTERN (table)) == ADDR_DIFF_VEC))\n+      && JUMP_TABLE_DATA_P (table))\n     {\n       if (labelp)\n \t*labelp = label;\n@@ -3995,7 +3993,7 @@ nonzero_bits1 (const_rtx x, enum machine_mode mode, const_rtx known_x,\n       break;\n \n     case ZERO_EXTRACT:\n-      if (GET_CODE (XEXP (x, 1)) == CONST_INT\n+      if (CONST_INT_P (XEXP (x, 1))\n \t  && INTVAL (XEXP (x, 1)) < HOST_BITS_PER_WIDE_INT)\n \tnonzero &= ((HOST_WIDE_INT) 1 << INTVAL (XEXP (x, 1))) - 1;\n       break;\n@@ -4053,7 +4051,7 @@ nonzero_bits1 (const_rtx x, enum machine_mode mode, const_rtx known_x,\n \t the shift when shifted the appropriate number of bits.  This\n \t shows that high-order bits are cleared by the right shift and\n \t low-order bits by left shifts.  */\n-      if (GET_CODE (XEXP (x, 1)) == CONST_INT\n+      if (CONST_INT_P (XEXP (x, 1))\n \t  && INTVAL (XEXP (x, 1)) >= 0\n \t  && INTVAL (XEXP (x, 1)) < HOST_BITS_PER_WIDE_INT\n \t  && INTVAL (XEXP (x, 1)) < GET_MODE_BITSIZE (GET_MODE (x)))\n@@ -4348,7 +4346,7 @@ num_sign_bit_copies1 (const_rtx x, enum machine_mode mode, const_rtx known_x,\n       break;\n \n     case SIGN_EXTRACT:\n-      if (GET_CODE (XEXP (x, 1)) == CONST_INT)\n+      if (CONST_INT_P (XEXP (x, 1)))\n \treturn MAX (1, (int) bitwidth - INTVAL (XEXP (x, 1)));\n       break;\n \n@@ -4372,7 +4370,7 @@ num_sign_bit_copies1 (const_rtx x, enum machine_mode mode, const_rtx known_x,\n       /* If we are rotating left by a number of bits less than the number\n \t of sign bit copies, we can just subtract that amount from the\n \t number.  */\n-      if (GET_CODE (XEXP (x, 1)) == CONST_INT\n+      if (CONST_INT_P (XEXP (x, 1))\n \t  && INTVAL (XEXP (x, 1)) >= 0\n \t  && INTVAL (XEXP (x, 1)) < (int) bitwidth)\n \t{\n@@ -4418,15 +4416,15 @@ num_sign_bit_copies1 (const_rtx x, enum machine_mode mode, const_rtx known_x,\n       if (code == AND\n \t  && num1 > 1\n \t  && bitwidth <= HOST_BITS_PER_WIDE_INT\n-\t  && GET_CODE (XEXP (x, 1)) == CONST_INT\n+\t  && CONST_INT_P (XEXP (x, 1))\n \t  && !(INTVAL (XEXP (x, 1)) & ((HOST_WIDE_INT) 1 << (bitwidth - 1))))\n \treturn num1;\n \n       /* Similarly for IOR when setting high-order bits.  */\n       if (code == IOR\n \t  && num1 > 1\n \t  && bitwidth <= HOST_BITS_PER_WIDE_INT\n-\t  && GET_CODE (XEXP (x, 1)) == CONST_INT\n+\t  && CONST_INT_P (XEXP (x, 1))\n \t  && (INTVAL (XEXP (x, 1)) & ((HOST_WIDE_INT) 1 << (bitwidth - 1))))\n \treturn num1;\n \n@@ -4536,7 +4534,7 @@ num_sign_bit_copies1 (const_rtx x, enum machine_mode mode, const_rtx known_x,\n \t sign bit.  */\n       num0 = cached_num_sign_bit_copies (XEXP (x, 0), mode,\n \t\t\t\t\t known_x, known_mode, known_ret);\n-      if (GET_CODE (XEXP (x, 1)) == CONST_INT\n+      if (CONST_INT_P (XEXP (x, 1))\n \t  && INTVAL (XEXP (x, 1)) > 0\n \t  && INTVAL (XEXP (x, 1)) < GET_MODE_BITSIZE (GET_MODE (x)))\n \tnum0 = MIN ((int) bitwidth, num0 + INTVAL (XEXP (x, 1)));\n@@ -4545,7 +4543,7 @@ num_sign_bit_copies1 (const_rtx x, enum machine_mode mode, const_rtx known_x,\n \n     case ASHIFT:\n       /* Left shifts destroy copies.  */\n-      if (GET_CODE (XEXP (x, 1)) != CONST_INT\n+      if (!CONST_INT_P (XEXP (x, 1))\n \t  || INTVAL (XEXP (x, 1)) < 0\n \t  || INTVAL (XEXP (x, 1)) >= (int) bitwidth\n \t  || INTVAL (XEXP (x, 1)) >= GET_MODE_BITSIZE (GET_MODE (x)))\n@@ -4857,7 +4855,7 @@ canonicalize_condition (rtx insn, rtx cond, int reverse, rtx *earliest,\n      overflow.  */\n \n   if (GET_MODE_CLASS (GET_MODE (op0)) != MODE_CC\n-      && GET_CODE (op1) == CONST_INT\n+      && CONST_INT_P (op1)\n       && GET_MODE (op0) != VOIDmode\n       && GET_MODE_BITSIZE (GET_MODE (op0)) <= HOST_BITS_PER_WIDE_INT)\n     {"}, {"sha": "b54f47e43376d17a508365bc12c8fd7376deefaa", "filename": "gcc/sched-vis.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/481683e1d53b27779b31c1816606eb17975a9b1f/gcc%2Fsched-vis.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/481683e1d53b27779b31c1816606eb17975a9b1f/gcc%2Fsched-vis.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsched-vis.c?ref=481683e1d53b27779b31c1816606eb17975a9b1f", "patch": "@@ -81,7 +81,7 @@ print_exp (char *buf, const_rtx x, int verbose)\n     {\n     case PLUS:\n       op[0] = XEXP (x, 0);\n-      if (GET_CODE (XEXP (x, 1)) == CONST_INT\n+      if (CONST_INT_P (XEXP (x, 1))\n \t  && INTVAL (XEXP (x, 1)) < 0)\n \t{\n \t  st[1] = \"-\";\n@@ -750,7 +750,7 @@ print_rtl_slim (FILE *f, rtx first, rtx last, int count, int flags)\n        insn = NEXT_INSN (insn))\n     {\n       if ((flags & TDF_BLOCKS)\n-\t  && (INSN_P (insn) || GET_CODE (insn) == NOTE)\n+\t  && (INSN_P (insn) || NOTE_P (insn))\n \t  && BLOCK_FOR_INSN (insn)\n \t  && !current_bb)\n \t{"}, {"sha": "3ef8292e1b2904d301bfa5d8f70a0dbe3a4ef746", "filename": "gcc/sdbout.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/481683e1d53b27779b31c1816606eb17975a9b1f/gcc%2Fsdbout.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/481683e1d53b27779b31c1816606eb17975a9b1f/gcc%2Fsdbout.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsdbout.c?ref=481683e1d53b27779b31c1816606eb17975a9b1f", "patch": "@@ -898,7 +898,7 @@ sdbout_symbol (tree decl, int local)\n       else if (MEM_P (value)\n \t       && ((GET_CODE (XEXP (value, 0)) == PLUS\n \t\t    && REG_P (XEXP (XEXP (value, 0), 0))\n-\t\t    && GET_CODE (XEXP (XEXP (value, 0), 1)) == CONST_INT)\n+\t\t    && CONST_INT_P (XEXP (XEXP (value, 0), 1)))\n \t\t   /* This is for variables which are at offset zero from\n \t\t      the frame pointer.  This happens on the Alpha.\n \t\t      Non-frame pointer registers are excluded above.  */\n@@ -1285,7 +1285,7 @@ sdbout_parms (tree parms)\n \t       If that is not true, we produce meaningless results,\n \t       but do not crash.  */\n \t    if (GET_CODE (addr) == PLUS\n-\t\t&& GET_CODE (XEXP (addr, 1)) == CONST_INT)\n+\t\t&& CONST_INT_P (XEXP (addr, 1)))\n \t      current_sym_value = INTVAL (XEXP (addr, 1));\n \t    else\n \t      current_sym_value = 0;\n@@ -1413,7 +1413,7 @@ sdbout_reg_parms (tree parms)\n \t/* Report parms that live in memory but not where they were passed.  */\n \telse if (MEM_P (DECL_RTL (parms))\n \t\t && GET_CODE (XEXP (DECL_RTL (parms), 0)) == PLUS\n-\t\t && GET_CODE (XEXP (XEXP (DECL_RTL (parms), 0), 1)) == CONST_INT\n+\t\t && CONST_INT_P (XEXP (XEXP (DECL_RTL (parms), 0), 1))\n \t\t && PARM_PASSED_IN_MEMORY (parms)\n \t\t && ! rtx_equal_p (DECL_RTL (parms), DECL_INCOMING_RTL (parms)))\n \t  {"}, {"sha": "698612fb9a23b1b88b23455648320e086b76d278", "filename": "gcc/sel-sched-ir.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/481683e1d53b27779b31c1816606eb17975a9b1f/gcc%2Fsel-sched-ir.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/481683e1d53b27779b31c1816606eb17975a9b1f/gcc%2Fsel-sched-ir.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsel-sched-ir.c?ref=481683e1d53b27779b31c1816606eb17975a9b1f", "patch": "@@ -2527,7 +2527,7 @@ setup_id_lhs_rhs (idata_t id, insn_t insn, bool force_unique_p)\n {\n   rtx pat = PATTERN (insn);\n   \n-  if (GET_CODE (insn) == INSN\n+  if (NONJUMP_INSN_P (insn)\n       && GET_CODE (pat) == SET \n       && !force_unique_p)\n     {"}, {"sha": "782d7172091b1276efe8f06df4465118ad6ce7b3", "filename": "gcc/simplify-rtx.c", "status": "modified", "additions": 99, "deletions": 99, "changes": 198, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/481683e1d53b27779b31c1816606eb17975a9b1f/gcc%2Fsimplify-rtx.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/481683e1d53b27779b31c1816606eb17975a9b1f/gcc%2Fsimplify-rtx.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsimplify-rtx.c?ref=481683e1d53b27779b31c1816606eb17975a9b1f", "patch": "@@ -88,7 +88,7 @@ mode_signbit_p (enum machine_mode mode, const_rtx x)\n     return false;\n   \n   if (width <= HOST_BITS_PER_WIDE_INT\n-      && GET_CODE (x) == CONST_INT)\n+      && CONST_INT_P (x))\n     val = INTVAL (x);\n   else if (width <= 2 * HOST_BITS_PER_WIDE_INT\n \t   && GET_CODE (x) == CONST_DOUBLE\n@@ -169,7 +169,7 @@ avoid_constant_pool_reference (rtx x)\n   /* Split the address into a base and integer offset.  */\n   if (GET_CODE (addr) == CONST\n       && GET_CODE (XEXP (addr, 0)) == PLUS\n-      && GET_CODE (XEXP (XEXP (addr, 0), 1)) == CONST_INT)\n+      && CONST_INT_P (XEXP (XEXP (addr, 0), 1)))\n     {\n       offset = INTVAL (XEXP (XEXP (addr, 0), 1));\n       addr = XEXP (XEXP (addr, 0), 0);\n@@ -413,14 +413,14 @@ simplify_unary_operation_1 (enum rtx_code code, enum machine_mode mode, rtx op)\n \n       /* (not (xor X C)) for C constant is (xor X D) with D = ~C.  */\n       if (GET_CODE (op) == XOR\n-\t  && GET_CODE (XEXP (op, 1)) == CONST_INT\n+\t  && CONST_INT_P (XEXP (op, 1))\n \t  && (temp = simplify_unary_operation (NOT, mode,\n \t\t\t\t\t       XEXP (op, 1), mode)) != 0)\n \treturn simplify_gen_binary (XOR, mode, XEXP (op, 0), temp);\n \n       /* (not (plus X C)) for signbit C is (xor X D) with D = ~C.  */\n       if (GET_CODE (op) == PLUS\n-\t  && GET_CODE (XEXP (op, 1)) == CONST_INT\n+\t  && CONST_INT_P (XEXP (op, 1))\n \t  && mode_signbit_p (mode, XEXP (op, 1))\n \t  && (temp = simplify_unary_operation (NOT, mode,\n \t\t\t\t\t       XEXP (op, 1), mode)) != 0)\n@@ -445,7 +445,7 @@ simplify_unary_operation_1 (enum rtx_code code, enum machine_mode mode, rtx op)\n  \n       if (STORE_FLAG_VALUE == -1\n \t  && GET_CODE (op) == ASHIFTRT\n-\t  && GET_CODE (XEXP (op, 1)) == CONST_INT\n+\t  && GET_CODE (XEXP (op, 1))\n \t  && INTVAL (XEXP (op, 1)) == GET_MODE_BITSIZE (mode) - 1)\n \treturn simplify_gen_relational (GE, mode, VOIDmode,\n \t\t\t\t\tXEXP (op, 0), const0_rtx);\n@@ -526,7 +526,7 @@ simplify_unary_operation_1 (enum rtx_code code, enum machine_mode mode, rtx op)\n \t  && !HONOR_SIGN_DEPENDENT_ROUNDING (mode))\n \t{\n \t  /* (neg (plus A C)) is simplified to (minus -C A).  */\n-\t  if (GET_CODE (XEXP (op, 1)) == CONST_INT\n+\t  if (CONST_INT_P (XEXP (op, 1))\n \t      || GET_CODE (XEXP (op, 1)) == CONST_DOUBLE)\n \t    {\n \t      temp = simplify_unary_operation (NEG, mode, XEXP (op, 1), mode);\n@@ -561,15 +561,15 @@ simplify_unary_operation_1 (enum rtx_code code, enum machine_mode mode, rtx op)\n       /* (neg (ashiftrt X C)) can be replaced by (lshiftrt X C) when\n \t C is equal to the width of MODE minus 1.  */\n       if (GET_CODE (op) == ASHIFTRT\n-\t  && GET_CODE (XEXP (op, 1)) == CONST_INT\n+\t  && CONST_INT_P (XEXP (op, 1))\n \t  && INTVAL (XEXP (op, 1)) == GET_MODE_BITSIZE (mode) - 1)\n \treturn simplify_gen_binary (LSHIFTRT, mode,\n \t\t\t\t    XEXP (op, 0), XEXP (op, 1));\n \n       /* (neg (lshiftrt X C)) can be replaced by (ashiftrt X C) when\n \t C is equal to the width of MODE minus 1.  */\n       if (GET_CODE (op) == LSHIFTRT\n-\t  && GET_CODE (XEXP (op, 1)) == CONST_INT\n+\t  && CONST_INT_P (XEXP (op, 1))\n \t  && INTVAL (XEXP (op, 1)) == GET_MODE_BITSIZE (mode) - 1)\n \treturn simplify_gen_binary (ASHIFTRT, mode,\n \t\t\t\t    XEXP (op, 0), XEXP (op, 1));\n@@ -923,7 +923,7 @@ simplify_const_unary_operation (enum rtx_code code, enum machine_mode mode,\n \t  gcc_assert (GET_MODE_INNER (mode) == GET_MODE_INNER\n \t\t\t\t\t\t(GET_MODE (op)));\n       }\n-      if (GET_CODE (op) == CONST_INT || GET_CODE (op) == CONST_DOUBLE\n+      if (CONST_INT_P (op) || GET_CODE (op) == CONST_DOUBLE\n \t  || GET_CODE (op) == CONST_VECTOR)\n \t{\n           int elt_size = GET_MODE_SIZE (GET_MODE_INNER (mode));\n@@ -977,12 +977,12 @@ simplify_const_unary_operation (enum rtx_code code, enum machine_mode mode,\n      such as FIX.  At some point, this should be simplified.  */\n \n   if (code == FLOAT && GET_MODE (op) == VOIDmode\n-      && (GET_CODE (op) == CONST_DOUBLE || GET_CODE (op) == CONST_INT))\n+      && (GET_CODE (op) == CONST_DOUBLE || CONST_INT_P (op)))\n     {\n       HOST_WIDE_INT hv, lv;\n       REAL_VALUE_TYPE d;\n \n-      if (GET_CODE (op) == CONST_INT)\n+      if (CONST_INT_P (op))\n \tlv = INTVAL (op), hv = HWI_SIGN_EXTEND (lv);\n       else\n \tlv = CONST_DOUBLE_LOW (op),  hv = CONST_DOUBLE_HIGH (op);\n@@ -993,12 +993,12 @@ simplify_const_unary_operation (enum rtx_code code, enum machine_mode mode,\n     }\n   else if (code == UNSIGNED_FLOAT && GET_MODE (op) == VOIDmode\n \t   && (GET_CODE (op) == CONST_DOUBLE\n-\t       || GET_CODE (op) == CONST_INT))\n+\t       || CONST_INT_P (op)))\n     {\n       HOST_WIDE_INT hv, lv;\n       REAL_VALUE_TYPE d;\n \n-      if (GET_CODE (op) == CONST_INT)\n+      if (CONST_INT_P (op))\n \tlv = INTVAL (op), hv = HWI_SIGN_EXTEND (lv);\n       else\n \tlv = CONST_DOUBLE_LOW (op),  hv = CONST_DOUBLE_HIGH (op);\n@@ -1020,7 +1020,7 @@ simplify_const_unary_operation (enum rtx_code code, enum machine_mode mode,\n       return CONST_DOUBLE_FROM_REAL_VALUE (d, mode);\n     }\n \n-  if (GET_CODE (op) == CONST_INT\n+  if (CONST_INT_P (op)\n       && width <= HOST_BITS_PER_WIDE_INT && width > 0)\n     {\n       HOST_WIDE_INT arg0 = INTVAL (op);\n@@ -1164,7 +1164,7 @@ simplify_const_unary_operation (enum rtx_code code, enum machine_mode mode,\n   else if (GET_MODE (op) == VOIDmode\n \t   && width <= HOST_BITS_PER_WIDE_INT * 2\n \t   && (GET_CODE (op) == CONST_DOUBLE\n-\t       || GET_CODE (op) == CONST_INT))\n+\t       || CONST_INT_P (op)))\n     {\n       unsigned HOST_WIDE_INT l1, lv;\n       HOST_WIDE_INT h1, hv;\n@@ -1597,12 +1597,12 @@ simplify_binary_operation_1 (enum rtx_code code, enum machine_mode mode,\n       if ((GET_CODE (op0) == CONST\n \t   || GET_CODE (op0) == SYMBOL_REF\n \t   || GET_CODE (op0) == LABEL_REF)\n-\t  && GET_CODE (op1) == CONST_INT)\n+\t  && CONST_INT_P (op1))\n \treturn plus_constant (op0, INTVAL (op1));\n       else if ((GET_CODE (op1) == CONST\n \t\t|| GET_CODE (op1) == SYMBOL_REF\n \t\t|| GET_CODE (op1) == LABEL_REF)\n-\t       && GET_CODE (op0) == CONST_INT)\n+\t       && CONST_INT_P (op0))\n \treturn plus_constant (op1, INTVAL (op0));\n \n       /* See if this is something like X * C - X or vice versa or\n@@ -1624,14 +1624,14 @@ simplify_binary_operation_1 (enum rtx_code code, enum machine_mode mode,\n \t      lhs = XEXP (lhs, 0);\n \t    }\n \t  else if (GET_CODE (lhs) == MULT\n-\t\t   && GET_CODE (XEXP (lhs, 1)) == CONST_INT)\n+\t\t   && CONST_INT_P (XEXP (lhs, 1)))\n \t    {\n \t      coeff0l = INTVAL (XEXP (lhs, 1));\n \t      coeff0h = INTVAL (XEXP (lhs, 1)) < 0 ? -1 : 0;\n \t      lhs = XEXP (lhs, 0);\n \t    }\n \t  else if (GET_CODE (lhs) == ASHIFT\n-\t\t   && GET_CODE (XEXP (lhs, 1)) == CONST_INT\n+\t\t   && CONST_INT_P (XEXP (lhs, 1))\n \t\t   && INTVAL (XEXP (lhs, 1)) >= 0\n \t\t   && INTVAL (XEXP (lhs, 1)) < HOST_BITS_PER_WIDE_INT)\n \t    {\n@@ -1647,14 +1647,14 @@ simplify_binary_operation_1 (enum rtx_code code, enum machine_mode mode,\n \t      rhs = XEXP (rhs, 0);\n \t    }\n \t  else if (GET_CODE (rhs) == MULT\n-\t\t   && GET_CODE (XEXP (rhs, 1)) == CONST_INT)\n+\t\t   && CONST_INT_P (XEXP (rhs, 1)))\n \t    {\n \t      coeff1l = INTVAL (XEXP (rhs, 1));\n \t      coeff1h = INTVAL (XEXP (rhs, 1)) < 0 ? -1 : 0;\n \t      rhs = XEXP (rhs, 0);\n \t    }\n \t  else if (GET_CODE (rhs) == ASHIFT\n-\t\t   && GET_CODE (XEXP (rhs, 1)) == CONST_INT\n+\t\t   && CONST_INT_P (XEXP (rhs, 1))\n \t\t   && INTVAL (XEXP (rhs, 1)) >= 0\n \t\t   && INTVAL (XEXP (rhs, 1)) < HOST_BITS_PER_WIDE_INT)\n \t    {\n@@ -1681,10 +1681,10 @@ simplify_binary_operation_1 (enum rtx_code code, enum machine_mode mode,\n \t}\n \n       /* (plus (xor X C1) C2) is (xor X (C1^C2)) if C2 is signbit.  */\n-      if ((GET_CODE (op1) == CONST_INT\n+      if ((CONST_INT_P (op1)\n \t   || GET_CODE (op1) == CONST_DOUBLE)\n \t  && GET_CODE (op0) == XOR\n-\t  && (GET_CODE (XEXP (op0, 1)) == CONST_INT\n+\t  && (CONST_INT_P (XEXP (op0, 1))\n \t      || GET_CODE (XEXP (op0, 1)) == CONST_DOUBLE)\n \t  && mode_signbit_p (mode, op1))\n \treturn simplify_gen_binary (XOR, mode, XEXP (op0, 0),\n@@ -1807,14 +1807,14 @@ simplify_binary_operation_1 (enum rtx_code code, enum machine_mode mode,\n \t      lhs = XEXP (lhs, 0);\n \t    }\n \t  else if (GET_CODE (lhs) == MULT\n-\t\t   && GET_CODE (XEXP (lhs, 1)) == CONST_INT)\n+\t\t   && CONST_INT_P (XEXP (lhs, 1)))\n \t    {\n \t      coeff0l = INTVAL (XEXP (lhs, 1));\n \t      coeff0h = INTVAL (XEXP (lhs, 1)) < 0 ? -1 : 0;\n \t      lhs = XEXP (lhs, 0);\n \t    }\n \t  else if (GET_CODE (lhs) == ASHIFT\n-\t\t   && GET_CODE (XEXP (lhs, 1)) == CONST_INT\n+\t\t   && CONST_INT_P (XEXP (lhs, 1))\n \t\t   && INTVAL (XEXP (lhs, 1)) >= 0\n \t\t   && INTVAL (XEXP (lhs, 1)) < HOST_BITS_PER_WIDE_INT)\n \t    {\n@@ -1830,14 +1830,14 @@ simplify_binary_operation_1 (enum rtx_code code, enum machine_mode mode,\n \t      rhs = XEXP (rhs, 0);\n \t    }\n \t  else if (GET_CODE (rhs) == MULT\n-\t\t   && GET_CODE (XEXP (rhs, 1)) == CONST_INT)\n+\t\t   && CONST_INT_P (XEXP (rhs, 1)))\n \t    {\n \t      negcoeff1l = -INTVAL (XEXP (rhs, 1));\n \t      negcoeff1h = INTVAL (XEXP (rhs, 1)) <= 0 ? 0 : -1;\n \t      rhs = XEXP (rhs, 0);\n \t    }\n \t  else if (GET_CODE (rhs) == ASHIFT\n-\t\t   && GET_CODE (XEXP (rhs, 1)) == CONST_INT\n+\t\t   && CONST_INT_P (XEXP (rhs, 1))\n \t\t   && INTVAL (XEXP (rhs, 1)) >= 0\n \t\t   && INTVAL (XEXP (rhs, 1)) < HOST_BITS_PER_WIDE_INT)\n \t    {\n@@ -1869,7 +1869,7 @@ simplify_binary_operation_1 (enum rtx_code code, enum machine_mode mode,\n \n       /* (-x - c) may be simplified as (-c - x).  */\n       if (GET_CODE (op0) == NEG\n-\t  && (GET_CODE (op1) == CONST_INT\n+\t  && (CONST_INT_P (op1)\n \t      || GET_CODE (op1) == CONST_DOUBLE))\n \t{\n \t  tem = simplify_unary_operation (NEG, mode, op1, mode);\n@@ -1878,7 +1878,7 @@ simplify_binary_operation_1 (enum rtx_code code, enum machine_mode mode,\n \t}\n \n       /* Don't let a relocatable value get a negative coeff.  */\n-      if (GET_CODE (op1) == CONST_INT && GET_MODE (op0) != VOIDmode)\n+      if (CONST_INT_P (op1) && GET_MODE (op0) != VOIDmode)\n \treturn simplify_gen_binary (PLUS, mode,\n \t\t\t\t    op0,\n \t\t\t\t    neg_const_int (mode, op1));\n@@ -1975,7 +1975,7 @@ simplify_binary_operation_1 (enum rtx_code code, enum machine_mode mode,\n \n       /* Convert multiply by constant power of two into shift unless\n \t we are still generating RTL.  This test is a kludge.  */\n-      if (GET_CODE (trueop1) == CONST_INT\n+      if (CONST_INT_P (trueop1)\n \t  && (val = exact_log2 (INTVAL (trueop1))) >= 0\n \t  /* If the mode is larger than the host word size, and the\n \t     uppermost bit is set, then this isn't a power of two due\n@@ -2040,7 +2040,7 @@ simplify_binary_operation_1 (enum rtx_code code, enum machine_mode mode,\n     case IOR:\n       if (trueop1 == const0_rtx)\n \treturn op0;\n-      if (GET_CODE (trueop1) == CONST_INT\n+      if (CONST_INT_P (trueop1)\n \t  && ((INTVAL (trueop1) & GET_MODE_MASK (mode))\n \t      == GET_MODE_MASK (mode)))\n \treturn op1;\n@@ -2054,15 +2054,15 @@ simplify_binary_operation_1 (enum rtx_code code, enum machine_mode mode,\n \treturn constm1_rtx;\n \n       /* (ior A C) is C if all bits of A that might be nonzero are on in C.  */\n-      if (GET_CODE (op1) == CONST_INT\n+      if (CONST_INT_P (op1)\n \t  && GET_MODE_BITSIZE (mode) <= HOST_BITS_PER_WIDE_INT\n \t  && (nonzero_bits (op0, mode) & ~INTVAL (op1)) == 0)\n \treturn op1;\n  \n       /* Canonicalize (X & C1) | C2.  */\n       if (GET_CODE (op0) == AND\n-\t  && GET_CODE (trueop1) == CONST_INT\n-\t  && GET_CODE (XEXP (op0, 1)) == CONST_INT)\n+\t  && CONST_INT_P (trueop1)\n+\t  && CONST_INT_P (XEXP (op0, 1)))\n \t{\n \t  HOST_WIDE_INT mask = GET_MODE_MASK (mode);\n \t  HOST_WIDE_INT c1 = INTVAL (XEXP (op0, 1));\n@@ -2111,8 +2111,8 @@ simplify_binary_operation_1 (enum rtx_code code, enum machine_mode mode,\n \n       if (GET_CODE (opleft) == ASHIFT && GET_CODE (opright) == LSHIFTRT\n           && rtx_equal_p (XEXP (opleft, 0), XEXP (opright, 0))\n-          && GET_CODE (XEXP (opleft, 1)) == CONST_INT\n-          && GET_CODE (XEXP (opright, 1)) == CONST_INT\n+          && CONST_INT_P (XEXP (opleft, 1))\n+          && CONST_INT_P (XEXP (opright, 1))\n           && (INTVAL (XEXP (opleft, 1)) + INTVAL (XEXP (opright, 1))\n               == GET_MODE_BITSIZE (mode)))\n         return gen_rtx_ROTATE (mode, XEXP (opright, 0), XEXP (opleft, 1));\n@@ -2130,21 +2130,21 @@ simplify_binary_operation_1 (enum rtx_code code, enum machine_mode mode,\n               < GET_MODE_SIZE (GET_MODE (SUBREG_REG (opleft))))\n           && rtx_equal_p (XEXP (SUBREG_REG (opleft), 0),\n                           SUBREG_REG (XEXP (opright, 0)))\n-          && GET_CODE (XEXP (SUBREG_REG (opleft), 1)) == CONST_INT\n-          && GET_CODE (XEXP (opright, 1)) == CONST_INT\n+          && CONST_INT_P (XEXP (SUBREG_REG (opleft), 1))\n+          && CONST_INT_P (XEXP (opright, 1))\n           && (INTVAL (XEXP (SUBREG_REG (opleft), 1)) + INTVAL (XEXP (opright, 1))\n               == GET_MODE_BITSIZE (mode)))\n         return gen_rtx_ROTATE (mode, XEXP (opright, 0),\n                                XEXP (SUBREG_REG (opleft), 1));\n \n       /* If we have (ior (and (X C1) C2)), simplify this by making\n \t C1 as small as possible if C1 actually changes.  */\n-      if (GET_CODE (op1) == CONST_INT\n+      if (CONST_INT_P (op1)\n \t  && (GET_MODE_BITSIZE (mode) <= HOST_BITS_PER_WIDE_INT\n \t      || INTVAL (op1) > 0)\n \t  && GET_CODE (op0) == AND\n-\t  && GET_CODE (XEXP (op0, 1)) == CONST_INT\n-\t  && GET_CODE (op1) == CONST_INT\n+\t  && CONST_INT_P (XEXP (op0, 1))\n+\t  && CONST_INT_P (op1)\n \t  && (INTVAL (XEXP (op0, 1)) & INTVAL (op1)) != 0)\n \treturn simplify_gen_binary (IOR, mode,\n \t\t\t\t    simplify_gen_binary\n@@ -2158,10 +2158,10 @@ simplify_binary_operation_1 (enum rtx_code code, enum machine_mode mode,\n \t the PLUS does not affect any of the bits in OP1: then we can do\n \t the IOR as a PLUS and we can associate.  This is valid if OP1\n          can be safely shifted left C bits.  */\n-      if (GET_CODE (trueop1) == CONST_INT && GET_CODE (op0) == ASHIFTRT\n+      if (CONST_INT_P (trueop1) && GET_CODE (op0) == ASHIFTRT\n           && GET_CODE (XEXP (op0, 0)) == PLUS\n-          && GET_CODE (XEXP (XEXP (op0, 0), 1)) == CONST_INT\n-          && GET_CODE (XEXP (op0, 1)) == CONST_INT\n+          && CONST_INT_P (XEXP (XEXP (op0, 0), 1))\n+          && CONST_INT_P (XEXP (op0, 1))\n           && INTVAL (XEXP (op0, 1)) < HOST_BITS_PER_WIDE_INT)\n         {\n           int count = INTVAL (XEXP (op0, 1));\n@@ -2182,7 +2182,7 @@ simplify_binary_operation_1 (enum rtx_code code, enum machine_mode mode,\n     case XOR:\n       if (trueop1 == const0_rtx)\n \treturn op0;\n-      if (GET_CODE (trueop1) == CONST_INT\n+      if (CONST_INT_P (trueop1)\n \t  && ((INTVAL (trueop1) & GET_MODE_MASK (mode))\n \t      == GET_MODE_MASK (mode)))\n \treturn simplify_gen_unary (NOT, mode, op0, mode);\n@@ -2192,15 +2192,15 @@ simplify_binary_operation_1 (enum rtx_code code, enum machine_mode mode,\n \t return CONST0_RTX (mode);\n \n       /* Canonicalize XOR of the most significant bit to PLUS.  */\n-      if ((GET_CODE (op1) == CONST_INT\n+      if ((CONST_INT_P (op1)\n \t   || GET_CODE (op1) == CONST_DOUBLE)\n \t  && mode_signbit_p (mode, op1))\n \treturn simplify_gen_binary (PLUS, mode, op0, op1);\n       /* (xor (plus X C1) C2) is (xor X (C1^C2)) if C1 is signbit.  */\n-      if ((GET_CODE (op1) == CONST_INT\n+      if ((CONST_INT_P (op1)\n \t   || GET_CODE (op1) == CONST_DOUBLE)\n \t  && GET_CODE (op0) == PLUS\n-\t  && (GET_CODE (XEXP (op0, 1)) == CONST_INT\n+\t  && (CONST_INT_P (XEXP (op0, 1))\n \t      || GET_CODE (XEXP (op0, 1)) == CONST_DOUBLE)\n \t  && mode_signbit_p (mode, XEXP (op0, 1)))\n \treturn simplify_gen_binary (XOR, mode, XEXP (op0, 0),\n@@ -2270,7 +2270,7 @@ simplify_binary_operation_1 (enum rtx_code code, enum machine_mode mode,\n       if (STORE_FLAG_VALUE == 1\n \t  && trueop1 == const1_rtx\n \t  && GET_CODE (op0) == LSHIFTRT\n-\t  && GET_CODE (XEXP (op0, 1)) == CONST_INT\n+\t  && CONST_INT_P (XEXP (op0, 1))\n \t  && INTVAL (XEXP (op0, 1)) == GET_MODE_BITSIZE (mode) - 1)\n \treturn gen_rtx_GE (mode, XEXP (op0, 0), const0_rtx);\n \n@@ -2296,7 +2296,7 @@ simplify_binary_operation_1 (enum rtx_code code, enum machine_mode mode,\n \t{\n \t  HOST_WIDE_INT nzop0 = nonzero_bits (trueop0, mode);\n \t  HOST_WIDE_INT nzop1;\n-\t  if (GET_CODE (trueop1) == CONST_INT)\n+\t  if (CONST_INT_P (trueop1))\n \t    {\n \t      HOST_WIDE_INT val1 = INTVAL (trueop1);\n \t      /* If we are turning off bits already known off in OP0, we need\n@@ -2324,7 +2324,7 @@ simplify_binary_operation_1 (enum rtx_code code, enum machine_mode mode,\n \t there are no nonzero bits of C outside of X's mode.  */\n       if ((GET_CODE (op0) == SIGN_EXTEND\n \t   || GET_CODE (op0) == ZERO_EXTEND)\n-\t  && GET_CODE (trueop1) == CONST_INT\n+\t  && CONST_INT_P (trueop1)\n \t  && GET_MODE_BITSIZE (mode) <= HOST_BITS_PER_WIDE_INT\n \t  && (~GET_MODE_MASK (GET_MODE (XEXP (op0, 0)))\n \t      & INTVAL (trueop1)) == 0)\n@@ -2338,8 +2338,8 @@ simplify_binary_operation_1 (enum rtx_code code, enum machine_mode mode,\n \n       /* Canonicalize (A | C1) & C2 as (A & C2) | (C1 & C2).  */\n       if (GET_CODE (op0) == IOR\n-\t  && GET_CODE (trueop1) == CONST_INT\n-\t  && GET_CODE (XEXP (op0, 1)) == CONST_INT)\n+\t  && CONST_INT_P (trueop1)\n+\t  && CONST_INT_P (XEXP (op0, 1)))\n \t{\n \t  HOST_WIDE_INT tmp = INTVAL (trueop1) & INTVAL (XEXP (op0, 1));\n \t  return simplify_gen_binary (IOR, mode,\n@@ -2394,7 +2394,7 @@ simplify_binary_operation_1 (enum rtx_code code, enum machine_mode mode,\n \t and for - instead of + and/or ^ instead of |.\n          Also, if (N & M) == 0, then\n \t (A +- N) & M -> A & M.  */\n-      if (GET_CODE (trueop1) == CONST_INT\n+      if (CONST_INT_P (trueop1)\n \t  && GET_MODE_BITSIZE (mode) <= HOST_BITS_PER_WIDE_INT\n \t  && ~INTVAL (trueop1)\n \t  && (INTVAL (trueop1) & (INTVAL (trueop1) + 1)) == 0\n@@ -2406,7 +2406,7 @@ simplify_binary_operation_1 (enum rtx_code code, enum machine_mode mode,\n \t  pmop[0] = XEXP (op0, 0);\n \t  pmop[1] = XEXP (op0, 1);\n \n-\t  if (GET_CODE (pmop[1]) == CONST_INT\n+\t  if (CONST_INT_P (pmop[1])\n \t      && (INTVAL (pmop[1]) & INTVAL (trueop1)) == 0)\n \t    return simplify_gen_binary (AND, mode, pmop[0], op1);\n \n@@ -2416,14 +2416,14 @@ simplify_binary_operation_1 (enum rtx_code code, enum machine_mode mode,\n \t      switch (GET_CODE (tem))\n \t\t{\n \t\tcase AND:\n-\t\t  if (GET_CODE (XEXP (tem, 1)) == CONST_INT\n+\t\t  if (CONST_INT_P (XEXP (tem, 1))\n \t\t      && (INTVAL (XEXP (tem, 1)) & INTVAL (trueop1))\n \t\t      == INTVAL (trueop1))\n \t\t    pmop[which] = XEXP (tem, 0);\n \t\t  break;\n \t\tcase IOR:\n \t\tcase XOR:\n-\t\t  if (GET_CODE (XEXP (tem, 1)) == CONST_INT\n+\t\t  if (CONST_INT_P (XEXP (tem, 1))\n \t\t      && (INTVAL (XEXP (tem, 1)) & INTVAL (trueop1)) == 0)\n \t\t    pmop[which] = XEXP (tem, 0);\n \t\t  break;\n@@ -2469,7 +2469,7 @@ simplify_binary_operation_1 (enum rtx_code code, enum machine_mode mode,\n       if (trueop1 == CONST1_RTX (mode))\n \treturn rtl_hooks.gen_lowpart_no_emit (mode, op0);\n       /* Convert divide by power of two into shift.  */\n-      if (GET_CODE (trueop1) == CONST_INT\n+      if (CONST_INT_P (trueop1)\n \t  && (val = exact_log2 (INTVAL (trueop1))) > 0)\n \treturn simplify_gen_binary (LSHIFTRT, mode, op0, GEN_INT (val));\n       break;\n@@ -2551,7 +2551,7 @@ simplify_binary_operation_1 (enum rtx_code code, enum machine_mode mode,\n \t  return CONST0_RTX (mode);\n \t}\n       /* Implement modulus by power of two as AND.  */\n-      if (GET_CODE (trueop1) == CONST_INT\n+      if (CONST_INT_P (trueop1)\n \t  && exact_log2 (INTVAL (trueop1)) > 0)\n \treturn simplify_gen_binary (AND, mode, op0,\n \t\t\t\t    GEN_INT (INTVAL (op1) - 1));\n@@ -2582,12 +2582,12 @@ simplify_binary_operation_1 (enum rtx_code code, enum machine_mode mode,\n       if (trueop0 == CONST0_RTX (mode) && ! side_effects_p (op1))\n \treturn op0;\n       /* Rotating ~0 always results in ~0.  */\n-      if (GET_CODE (trueop0) == CONST_INT && width <= HOST_BITS_PER_WIDE_INT\n+      if (CONST_INT_P (trueop0) && width <= HOST_BITS_PER_WIDE_INT\n \t  && (unsigned HOST_WIDE_INT) INTVAL (trueop0) == GET_MODE_MASK (mode)\n \t  && ! side_effects_p (op1))\n \treturn op0;\n     canonicalize_shift:\n-      if (SHIFT_COUNT_TRUNCATED && GET_CODE (op1) == CONST_INT)\n+      if (SHIFT_COUNT_TRUNCATED && CONST_INT_P (op1))\n \t{\n \t  val = INTVAL (op1) & (GET_MODE_BITSIZE (mode) - 1);\n \t  if (val != INTVAL (op1))\n@@ -2611,7 +2611,7 @@ simplify_binary_operation_1 (enum rtx_code code, enum machine_mode mode,\n \treturn op0;\n       /* Optimize (lshiftrt (clz X) C) as (eq X 0).  */\n       if (GET_CODE (op0) == CLZ\n-\t  && GET_CODE (trueop1) == CONST_INT\n+\t  && CONST_INT_P (trueop1)\n \t  && STORE_FLAG_VALUE == 1\n \t  && INTVAL (trueop1) < (HOST_WIDE_INT)width)\n \t{\n@@ -2628,7 +2628,7 @@ simplify_binary_operation_1 (enum rtx_code code, enum machine_mode mode,\n \n     case SMIN:\n       if (width <= HOST_BITS_PER_WIDE_INT\n-\t  && GET_CODE (trueop1) == CONST_INT\n+\t  && CONST_INT_P (trueop1)\n \t  && INTVAL (trueop1) == (HOST_WIDE_INT) 1 << (width -1)\n \t  && ! side_effects_p (op0))\n \treturn op1;\n@@ -2641,7 +2641,7 @@ simplify_binary_operation_1 (enum rtx_code code, enum machine_mode mode,\n \n     case SMAX:\n       if (width <= HOST_BITS_PER_WIDE_INT\n-\t  && GET_CODE (trueop1) == CONST_INT\n+\t  && CONST_INT_P (trueop1)\n \t  && ((unsigned HOST_WIDE_INT) INTVAL (trueop1)\n \t      == (unsigned HOST_WIDE_INT) GET_MODE_MASK (mode) >> 1)\n \t  && ! side_effects_p (op0))\n@@ -2691,7 +2691,7 @@ simplify_binary_operation_1 (enum rtx_code code, enum machine_mode mode,\n \t  gcc_assert (mode == GET_MODE_INNER (GET_MODE (trueop0)));\n \t  gcc_assert (GET_CODE (trueop1) == PARALLEL);\n \t  gcc_assert (XVECLEN (trueop1, 0) == 1);\n-\t  gcc_assert (GET_CODE (XVECEXP (trueop1, 0, 0)) == CONST_INT);\n+\t  gcc_assert (CONST_INT_P (XVECEXP (trueop1, 0, 0)));\n \n \t  if (GET_CODE (trueop0) == CONST_VECTOR)\n \t    return CONST_VECTOR_ELT (trueop0, INTVAL (XVECEXP\n@@ -2795,7 +2795,7 @@ simplify_binary_operation_1 (enum rtx_code code, enum machine_mode mode,\n \t\t{\n \t\t  rtx x = XVECEXP (trueop1, 0, i);\n \n-\t\t  gcc_assert (GET_CODE (x) == CONST_INT);\n+\t\t  gcc_assert (CONST_INT_P (x));\n \t\t  RTVEC_ELT (v, i) = CONST_VECTOR_ELT (trueop0,\n \t\t\t\t\t\t       INTVAL (x));\n \t\t}\n@@ -2805,7 +2805,7 @@ simplify_binary_operation_1 (enum rtx_code code, enum machine_mode mode,\n \t}\n \n       if (XVECLEN (trueop1, 0) == 1\n-\t  && GET_CODE (XVECEXP (trueop1, 0, 0)) == CONST_INT\n+\t  && CONST_INT_P (XVECEXP (trueop1, 0, 0))\n \t  && GET_CODE (trueop0) == VEC_CONCAT)\n \t{\n \t  rtx vec = trueop0;\n@@ -2857,10 +2857,10 @@ simplify_binary_operation_1 (enum rtx_code code, enum machine_mode mode,\n \t  gcc_assert (GET_MODE_INNER (mode) == op1_mode);\n \n \tif ((GET_CODE (trueop0) == CONST_VECTOR\n-\t     || GET_CODE (trueop0) == CONST_INT\n+\t     || CONST_INT_P (trueop0)\n \t     || GET_CODE (trueop0) == CONST_DOUBLE)\n \t    && (GET_CODE (trueop1) == CONST_VECTOR\n-\t\t|| GET_CODE (trueop1) == CONST_INT\n+\t\t|| CONST_INT_P (trueop1)\n \t\t|| GET_CODE (trueop1) == CONST_DOUBLE))\n \t  {\n \t    int elt_size = GET_MODE_SIZE (GET_MODE_INNER (mode));\n@@ -3102,8 +3102,8 @@ simplify_const_binary_operation (enum rtx_code code, enum machine_mode mode,\n   /* We can fold some multi-word operations.  */\n   if (GET_MODE_CLASS (mode) == MODE_INT\n       && width == HOST_BITS_PER_WIDE_INT * 2\n-      && (GET_CODE (op0) == CONST_DOUBLE || GET_CODE (op0) == CONST_INT)\n-      && (GET_CODE (op1) == CONST_DOUBLE || GET_CODE (op1) == CONST_INT))\n+      && (GET_CODE (op0) == CONST_DOUBLE || CONST_INT_P (op0))\n+      && (GET_CODE (op1) == CONST_DOUBLE || CONST_INT_P (op1)))\n     {\n       unsigned HOST_WIDE_INT l1, l2, lv, lt;\n       HOST_WIDE_INT h1, h2, hv, ht;\n@@ -3238,7 +3238,7 @@ simplify_const_binary_operation (enum rtx_code code, enum machine_mode mode,\n       return immed_double_const (lv, hv, mode);\n     }\n \n-  if (GET_CODE (op0) == CONST_INT && GET_CODE (op1) == CONST_INT\n+  if (CONST_INT_P (op0) && CONST_INT_P (op1)\n       && width <= HOST_BITS_PER_WIDE_INT && width != 0)\n     {\n       /* Get the integer argument values in two forms:\n@@ -3617,8 +3617,8 @@ simplify_plus_minus (enum rtx_code code, enum machine_mode mode, rtx op0,\n \t\telse if (swap_commutative_operands_p (lhs, rhs))\n \t\t  tem = lhs, lhs = rhs, rhs = tem;\n \n-\t\tif ((GET_CODE (lhs) == CONST || GET_CODE (lhs) == CONST_INT)\n-\t\t    && (GET_CODE (rhs) == CONST || GET_CODE (rhs) == CONST_INT))\n+\t\tif ((GET_CODE (lhs) == CONST || CONST_INT_P (lhs))\n+\t\t    && (GET_CODE (rhs) == CONST || CONST_INT_P (rhs)))\n \t\t  {\n \t\t    rtx tem_lhs, tem_rhs;\n \n@@ -3645,7 +3645,7 @@ simplify_plus_minus (enum rtx_code code, enum machine_mode mode, rtx op0,\n \t\t    lneg &= rneg;\n \t\t    if (GET_CODE (tem) == NEG)\n \t\t      tem = XEXP (tem, 0), lneg = !lneg;\n-\t\t    if (GET_CODE (tem) == CONST_INT && lneg)\n+\t\t    if (CONST_INT_P (tem) && lneg)\n \t\t      tem = neg_const_int (mode, tem), lneg = 0;\n \n \t\t    ops[i].op = tem;\n@@ -3674,7 +3674,7 @@ simplify_plus_minus (enum rtx_code code, enum machine_mode mode, rtx op0,\n \n   /* Create (minus -C X) instead of (neg (const (plus X C))).  */\n   if (n_ops == 2\n-      && GET_CODE (ops[1].op) == CONST_INT\n+      && CONST_INT_P (ops[1].op)\n       && CONSTANT_P (ops[0].op)\n       && ops[0].neg)\n     return gen_rtx_fmt_ee (MINUS, mode, ops[1].op, ops[0].op);\n@@ -3686,7 +3686,7 @@ simplify_plus_minus (enum rtx_code code, enum machine_mode mode, rtx op0,\n      in the array and that any other constant will be next-to-last.  */\n \n   if (n_ops > 1\n-      && GET_CODE (ops[n_ops - 1].op) == CONST_INT\n+      && CONST_INT_P (ops[n_ops - 1].op)\n       && CONSTANT_P (ops[n_ops - 2].op))\n     {\n       rtx value = ops[n_ops - 1].op;\n@@ -3853,7 +3853,7 @@ simplify_relational_operation_1 (enum rtx_code code, enum machine_mode mode,\n      (GEU/LTU a -C).  Likewise for (LTU/GEU (PLUS a C) a).  */\n   if ((code == LTU || code == GEU)\n       && GET_CODE (op0) == PLUS\n-      && GET_CODE (XEXP (op0, 1)) == CONST_INT\n+      && CONST_INT_P (XEXP (op0, 1))\n       && (rtx_equal_p (op1, XEXP (op0, 0))\n \t  || rtx_equal_p (op1, XEXP (op0, 1))))\n     {\n@@ -3970,9 +3970,9 @@ simplify_relational_operation_1 (enum rtx_code code, enum machine_mode mode,\n   /* (eq/ne (xor x C1) C2) simplifies to (eq/ne x (C1^C2)).  */\n   if ((code == EQ || code == NE)\n       && op0code == XOR\n-      && (GET_CODE (op1) == CONST_INT\n+      && (CONST_INT_P (op1)\n \t  || GET_CODE (op1) == CONST_DOUBLE)\n-      && (GET_CODE (XEXP (op0, 1)) == CONST_INT\n+      && (CONST_INT_P (XEXP (op0, 1))\n \t  || GET_CODE (XEXP (op0, 1)) == CONST_DOUBLE))\n     return simplify_gen_relational (code, mode, cmp_mode, XEXP (op0, 0),\n \t\t\t\t    simplify_gen_binary (XOR, cmp_mode,\n@@ -4122,8 +4122,8 @@ simplify_const_relational_operation (enum rtx_code code,\n \n   if (INTEGRAL_MODE_P (mode) && trueop1 != const0_rtx\n       && (code == EQ || code == NE)\n-      && ! ((REG_P (op0) || GET_CODE (trueop0) == CONST_INT)\n-\t    && (REG_P (op1) || GET_CODE (trueop1) == CONST_INT))\n+      && ! ((REG_P (op0) || CONST_INT_P (trueop0))\n+\t    && (REG_P (op1) || CONST_INT_P (trueop1)))\n       && 0 != (tem = simplify_binary_operation (MINUS, mode, op0, op1))\n       /* We cannot do this if tem is a nonzero address.  */\n       && ! nonzero_address_p (tem))\n@@ -4191,9 +4191,9 @@ simplify_const_relational_operation (enum rtx_code code,\n   /* Otherwise, see if the operands are both integers.  */\n   if ((GET_MODE_CLASS (mode) == MODE_INT || mode == VOIDmode)\n        && (GET_CODE (trueop0) == CONST_DOUBLE\n-\t   || GET_CODE (trueop0) == CONST_INT)\n+\t   || CONST_INT_P (trueop0))\n        && (GET_CODE (trueop1) == CONST_DOUBLE\n-\t   || GET_CODE (trueop1) == CONST_INT))\n+\t   || CONST_INT_P (trueop1)))\n     {\n       int width = GET_MODE_BITSIZE (mode);\n       HOST_WIDE_INT l0s, h0s, l1s, h1s;\n@@ -4252,7 +4252,7 @@ simplify_const_relational_operation (enum rtx_code code,\n   /* Optimize comparisons with upper and lower bounds.  */\n   if (SCALAR_INT_MODE_P (mode)\n       && GET_MODE_BITSIZE (mode) <= HOST_BITS_PER_WIDE_INT\n-      && GET_CODE (trueop1) == CONST_INT)\n+      && CONST_INT_P (trueop1))\n     {\n       int sign;\n       unsigned HOST_WIDE_INT nonzero = nonzero_bits (trueop0, mode);\n@@ -4382,7 +4382,7 @@ simplify_const_relational_operation (enum rtx_code code,\n       if (GET_CODE (op0) == IOR)\n \t{\n \t  rtx inner_const = avoid_constant_pool_reference (XEXP (op0, 1));\n-\t  if (GET_CODE (inner_const) == CONST_INT && inner_const != const0_rtx)\n+\t  if (CONST_INT_P (inner_const) && inner_const != const0_rtx)\n \t    {\n \t      int sign_bitnum = GET_MODE_BITSIZE (mode) - 1;\n \t      int has_sign = (HOST_BITS_PER_WIDE_INT >= sign_bitnum\n@@ -4485,9 +4485,9 @@ simplify_ternary_operation (enum rtx_code code, enum machine_mode mode,\n     {\n     case SIGN_EXTRACT:\n     case ZERO_EXTRACT:\n-      if (GET_CODE (op0) == CONST_INT\n-\t  && GET_CODE (op1) == CONST_INT\n-\t  && GET_CODE (op2) == CONST_INT\n+      if (CONST_INT_P (op0)\n+\t  && CONST_INT_P (op1)\n+\t  && CONST_INT_P (op2)\n \t  && ((unsigned) INTVAL (op1) + (unsigned) INTVAL (op2) <= width)\n \t  && width <= (unsigned) HOST_BITS_PER_WIDE_INT)\n \t{\n@@ -4524,7 +4524,7 @@ simplify_ternary_operation (enum rtx_code code, enum machine_mode mode,\n       break;\n \n     case IF_THEN_ELSE:\n-      if (GET_CODE (op0) == CONST_INT)\n+      if (CONST_INT_P (op0))\n \treturn op0 != const0_rtx ? op1 : op2;\n \n       /* Convert c ? a : a into \"a\".  */\n@@ -4561,7 +4561,7 @@ simplify_ternary_operation (enum rtx_code code, enum machine_mode mode,\n \t  rtx temp;\n \n \t  /* Look for happy constants in op1 and op2.  */\n-\t  if (GET_CODE (op1) == CONST_INT && GET_CODE (op2) == CONST_INT)\n+\t  if (CONST_INT_P (op1) && CONST_INT_P (op2))\n \t    {\n \t      HOST_WIDE_INT t = INTVAL (op1);\n \t      HOST_WIDE_INT f = INTVAL (op2);\n@@ -4592,7 +4592,7 @@ simplify_ternary_operation (enum rtx_code code, enum machine_mode mode,\n \t  /* See if any simplifications were possible.  */\n \t  if (temp)\n \t    {\n-\t      if (GET_CODE (temp) == CONST_INT)\n+\t      if (CONST_INT_P (temp))\n \t\treturn temp == const0_rtx ? op2 : op1;\n \t      else if (temp)\n \t        return gen_rtx_IF_THEN_ELSE (mode, temp, op1, op2);\n@@ -4605,7 +4605,7 @@ simplify_ternary_operation (enum rtx_code code, enum machine_mode mode,\n       gcc_assert (GET_MODE (op1) == mode);\n       gcc_assert (VECTOR_MODE_P (mode));\n       op2 = avoid_constant_pool_reference (op2);\n-      if (GET_CODE (op2) == CONST_INT)\n+      if (CONST_INT_P (op2))\n \t{\n           int elt_size = GET_MODE_SIZE (GET_MODE_INNER (mode));\n \t  unsigned n_elts = (GET_MODE_SIZE (mode) / elt_size);\n@@ -4672,7 +4672,7 @@ simplify_immed_subreg (enum machine_mode outermode, rtx op,\n   enum machine_mode outer_submode;\n \n   /* Some ports misuse CCmode.  */\n-  if (GET_MODE_CLASS (outermode) == MODE_CC && GET_CODE (op) == CONST_INT)\n+  if (GET_MODE_CLASS (outermode) == MODE_CC && CONST_INT_P (op))\n     return op;\n \n   /* We have no way to represent a complex constant at the rtl level.  */\n@@ -4971,7 +4971,7 @@ simplify_subreg (enum machine_mode outermode, rtx op,\n   if (outermode == innermode && !byte)\n     return op;\n \n-  if (GET_CODE (op) == CONST_INT\n+  if (CONST_INT_P (op)\n       || GET_CODE (op) == CONST_DOUBLE\n       || GET_CODE (op) == CONST_FIXED\n       || GET_CODE (op) == CONST_VECTOR)\n@@ -5204,7 +5204,7 @@ simplify_subreg (enum machine_mode outermode, rtx op,\n \t than the sign extension's sign_bit_copies and introduces zeros\n \t into the high bits of the result.  */\n       && (2 * GET_MODE_BITSIZE (outermode)) <= GET_MODE_BITSIZE (innermode)\n-      && GET_CODE (XEXP (op, 1)) == CONST_INT\n+      && CONST_INT_P (XEXP (op, 1))\n       && GET_CODE (XEXP (op, 0)) == SIGN_EXTEND\n       && GET_MODE (XEXP (XEXP (op, 0), 0)) == outermode\n       && INTVAL (XEXP (op, 1)) < GET_MODE_BITSIZE (outermode)\n@@ -5219,7 +5219,7 @@ simplify_subreg (enum machine_mode outermode, rtx op,\n        || GET_CODE (op) == ASHIFTRT)\n       && SCALAR_INT_MODE_P (outermode)\n       && GET_MODE_BITSIZE (outermode) < GET_MODE_BITSIZE (innermode)\n-      && GET_CODE (XEXP (op, 1)) == CONST_INT\n+      && CONST_INT_P (XEXP (op, 1))\n       && GET_CODE (XEXP (op, 0)) == ZERO_EXTEND\n       && GET_MODE (XEXP (XEXP (op, 0), 0)) == outermode\n       && INTVAL (XEXP (op, 1)) < GET_MODE_BITSIZE (outermode)\n@@ -5233,7 +5233,7 @@ simplify_subreg (enum machine_mode outermode, rtx op,\n   if (GET_CODE (op) == ASHIFT\n       && SCALAR_INT_MODE_P (outermode)\n       && GET_MODE_BITSIZE (outermode) < GET_MODE_BITSIZE (innermode)\n-      && GET_CODE (XEXP (op, 1)) == CONST_INT\n+      && CONST_INT_P (XEXP (op, 1))\n       && (GET_CODE (XEXP (op, 0)) == ZERO_EXTEND\n \t  || GET_CODE (XEXP (op, 0)) == SIGN_EXTEND)\n       && GET_MODE (XEXP (XEXP (op, 0), 0)) == outermode\n@@ -5248,7 +5248,7 @@ simplify_subreg (enum machine_mode outermode, rtx op,\n       && SCALAR_INT_MODE_P (outermode)\n       && GET_MODE_BITSIZE (outermode) >= BITS_PER_WORD\n       && GET_MODE_BITSIZE (innermode) >= (2 * GET_MODE_BITSIZE (outermode))\n-      && GET_CODE (XEXP (op, 1)) == CONST_INT\n+      && CONST_INT_P (XEXP (op, 1))\n       && (INTVAL (XEXP (op, 1)) & (GET_MODE_BITSIZE (outermode) - 1)) == 0\n       && INTVAL (XEXP (op, 1)) < GET_MODE_BITSIZE (innermode)      \n       && byte == subreg_lowpart_offset (outermode, innermode))"}, {"sha": "50a82f47fafdf915868208d57900e5ce7b572cf8", "filename": "gcc/targhooks.c", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/481683e1d53b27779b31c1816606eb17975a9b1f/gcc%2Ftarghooks.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/481683e1d53b27779b31c1816606eb17975a9b1f/gcc%2Ftarghooks.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftarghooks.c?ref=481683e1d53b27779b31c1816606eb17975a9b1f", "patch": "@@ -387,9 +387,7 @@ default_invalid_within_doloop (const_rtx insn)\n   if (CALL_P (insn))\n     return \"Function call in loop.\";\n   \n-  if (JUMP_P (insn)\n-      && (GET_CODE (PATTERN (insn)) == ADDR_DIFF_VEC\n-\t  || GET_CODE (PATTERN (insn)) == ADDR_VEC))\n+  if (JUMP_TABLE_DATA_P (insn))\n     return \"Computed branch in the loop.\";\n   \n   return NULL;"}, {"sha": "79bdce6417f8b62aa7239e2010b59789a6468c7b", "filename": "gcc/var-tracking.c", "status": "modified", "additions": 9, "deletions": 10, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/481683e1d53b27779b31c1816606eb17975a9b1f/gcc%2Fvar-tracking.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/481683e1d53b27779b31c1816606eb17975a9b1f/gcc%2Fvar-tracking.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvar-tracking.c?ref=481683e1d53b27779b31c1816606eb17975a9b1f", "patch": "@@ -406,7 +406,7 @@ stack_adjust_offset_pre_post (rtx pattern, HOST_WIDE_INT *pre,\n       code = GET_CODE (src);\n       if (! (code == PLUS || code == MINUS)\n \t  || XEXP (src, 0) != stack_pointer_rtx\n-\t  || GET_CODE (XEXP (src, 1)) != CONST_INT)\n+\t  || !CONST_INT_P (XEXP (src, 1)))\n \treturn;\n \n       if (code == MINUS)\n@@ -429,7 +429,7 @@ stack_adjust_offset_pre_post (rtx pattern, HOST_WIDE_INT *pre,\n \t      rtx val = XEXP (XEXP (src, 1), 1);\n \t      /* We handle only adjustments by constant amount.  */\n \t      gcc_assert (GET_CODE (XEXP (src, 1)) == PLUS &&\n-\t\t\t  GET_CODE (val) == CONST_INT);\n+\t\t\t  CONST_INT_P (val));\n \t      \n \t      if (code == PRE_MODIFY)\n \t\t*pre -= INTVAL (val);\n@@ -2220,9 +2220,9 @@ compute_bb_dataflow (basic_block bb)\n \t      if (! flag_var_tracking_uninit)\n \t\tstatus = VAR_INIT_STATUS_INITIALIZED;\n \n-\t      if (GET_CODE (loc) == REG)\n+\t      if (REG_P (loc))\n \t\tvar_reg_set (out, loc, status, NULL);\n-\t      else if (GET_CODE (loc) == MEM)\n+\t      else if (MEM_P (loc))\n \t\tvar_mem_set (out, loc, status, NULL);\n \t    }\n \t    break;\n@@ -2953,17 +2953,16 @@ emit_note_insn_var_location (void **varp, void *data)\n \t    }\n \t  else if (MEM_P (loc[n_var_parts])\n \t\t   && GET_CODE (XEXP (loc2, 0)) == PLUS\n-\t\t   && GET_CODE (XEXP (XEXP (loc2, 0), 0)) == REG\n-\t\t   && GET_CODE (XEXP (XEXP (loc2, 0), 1)) == CONST_INT)\n+\t\t   && REG_P (XEXP (XEXP (loc2, 0), 0))\n+\t\t   && CONST_INT_P (XEXP (XEXP (loc2, 0), 1)))\n \t    {\n-\t      if ((GET_CODE (XEXP (loc[n_var_parts], 0)) == REG\n+\t      if ((REG_P (XEXP (loc[n_var_parts], 0))\n \t\t   && rtx_equal_p (XEXP (loc[n_var_parts], 0),\n \t\t\t\t   XEXP (XEXP (loc2, 0), 0))\n \t\t   && INTVAL (XEXP (XEXP (loc2, 0), 1))\n \t\t      == GET_MODE_SIZE (mode))\n \t\t  || (GET_CODE (XEXP (loc[n_var_parts], 0)) == PLUS\n-\t\t      && GET_CODE (XEXP (XEXP (loc[n_var_parts], 0), 1))\n-\t\t\t == CONST_INT\n+\t\t      && CONST_INT_P (XEXP (XEXP (loc[n_var_parts], 0), 1))\n \t\t      && rtx_equal_p (XEXP (XEXP (loc[n_var_parts], 0), 0),\n \t\t\t\t      XEXP (XEXP (loc2, 0), 0))\n \t\t      && INTVAL (XEXP (XEXP (loc[n_var_parts], 0), 1))\n@@ -3152,7 +3151,7 @@ emit_notes_in_bb (basic_block bb)\n \t      enum var_init_status status = VAR_INIT_STATUS_UNINITIALIZED;\n \t      if (! flag_var_tracking_uninit)\n \t\tstatus = VAR_INIT_STATUS_INITIALIZED;\n-\t      if (GET_CODE (loc) == REG)\n+\t      if (REG_P (loc))\n \t\tvar_reg_set (&set, loc, status, NULL);\n \t      else\n \t\tvar_mem_set (&set, loc, status, NULL);"}, {"sha": "d133a777bdad4aa1bb13a919fd17a1fcf1fec082", "filename": "gcc/vmsdbgout.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/481683e1d53b27779b31c1816606eb17975a9b1f/gcc%2Fvmsdbgout.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/481683e1d53b27779b31c1816606eb17975a9b1f/gcc%2Fvmsdbgout.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvmsdbgout.c?ref=481683e1d53b27779b31c1816606eb17975a9b1f", "patch": "@@ -490,7 +490,7 @@ addr_const_to_string (char *str, rtx x)\n \n     case PLUS:\n       /* Some assemblers need integer constants to appear last (eg masm).  */\n-      if (GET_CODE (XEXP (x, 0)) == CONST_INT)\n+      if (CONST_INT_P (XEXP (x, 0)))\n \t{\n \t  addr_const_to_string (buf1, XEXP (x, 1));\n \t  strcat (str, buf1);\n@@ -520,7 +520,7 @@ addr_const_to_string (char *str, rtx x)\n       addr_const_to_string (buf1, XEXP (x, 0));\n       strcat (str, buf1);\n       strcat (str, \"-\");\n-      if (GET_CODE (XEXP (x, 1)) == CONST_INT\n+      if (CONST_INT_P (XEXP (x, 1))\n \t  && INTVAL (XEXP (x, 1)) < 0)\n \t{\n \t  strcat (str, \"(\");"}]}