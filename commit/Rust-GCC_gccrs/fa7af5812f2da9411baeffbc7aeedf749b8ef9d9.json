{"sha": "fa7af5812f2da9411baeffbc7aeedf749b8ef9d9", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZmE3YWY1ODEyZjJkYTk0MTFiYWVmZmJjN2FlZWRmNzQ5YjhlZjlkOQ==", "commit": {"author": {"name": "David Malcolm", "email": "dmalcolm@redhat.com", "date": "2014-08-22T16:26:36Z"}, "committer": {"name": "David Malcolm", "email": "dmalcolm@gcc.gnu.org", "date": "2014-08-22T16:26:36Z"}, "message": "final.c: Use rtx_insn (also touches output.c and config/arc/arc.c)\n\ngcc/\n\t* output.h (final_scan_insn): Strengthen return type from rtx to\n\trtx_insn *.\n\t(final_forward_branch_p): Likewise for param.\n\t(current_output_insn): Likewise for this global.\n\n\t* final.c (rtx debug_insn): Likewise for this variable.\n\t(current_output_insn): Likewise.\n\t(get_attr_length_1): Rename param \"insn\" to \"uncast_insn\",\n\tadding \"insn\" back in as an rtx_insn * with a checked cast, so\n\tthat macro ADJUST_INSN_LENGTH can be passed an rtx_insn * as the\n\tfirst param.\n\t(compute_alignments): Strengthen local \"label\" from rtx to\n\trtx_insn *.\n\t(shorten_branches): Rename param from \"first\" to \"uncast_first\",\n\tintroducing a new local rtx_insn * \"first\" using a checked cast to\n\teffectively strengthen \"first\" from rtx to rtx_insn * without\n\taffecting the type signature.  Strengthen locals \"insn\", \"seq\",\n\t\"next\", \"label\" from rtx to rtx_insn *.\n\t(change_scope): Strengthen param \"orig_insn\" and local \"insn\" from\n\trtx to rtx_insn *.\n\t(final_start_function): Rename param from \"first\" to \"uncast_first\",\n\tintroducing a new local rtx_insn * \"first\" using a checked cast to\n\teffectively strengthen \"first\" from rtx to rtx_insn * without\n\taffecting the type signature.  Strengthen local \"insn\" from rtx to\n\trtx_insn *.\n\t(dump_basic_block_info): Strengthen param \"insn\" from rtx to\n\trtx_insn *.\n\t(final): Rename param from \"first\" to \"uncast_first\",\n\tintroducing a new local rtx_insn * \"first\" using a checked cast to\n\teffectively strengthen \"first\" from rtx to rtx_insn * without\n\taffecting the type signature.  Strengthen locals \"insn\", \"next\"\n\tfrom rtx to rtx_insn *.\n\t(output_alternate_entry_point): Strengthen param \"insn\" from rtx to\n\trtx_insn *.\n\t(call_from_call_insn): Strengthen param \"insn\" from rtx to\n\trtx_call_insn *.\n\t(final_scan_insn): Rename param from \"insn\" to \"uncast_insn\",\n\tintroducing a new local rtx_insn * \"insn\" using a checked cast to\n\teffectively strengthen \"insn\" from rtx to rtx_insn * without\n\taffecting the type signature.  Strengthen return type and locals\n\t\"next\", \"note\", \"prev\", \"new_rtx\" from rtx to rtx_insn *.  Remove\n\tnow-redundant checked cast to rtx_insn * from both invocations of\n\tdebug_hooks->var_location.  Convert CALL_P into a dyn_cast,\n\tintroducing a local \"call_insn\" for use when invoking\n\tcall_from_call_insn.\n\t(notice_source_line): Strengthen param \"insn\" from rtx to\n\trtx_insn *.\n\t(leaf_function_p): Likewise for local \"insn\".\n\t(final_forward_branch_p): Likewise.\n\t(leaf_renumber_regs): Likewise for param \"first\".\n\t(rest_of_clean_state): Likewise for locals \"insn\" and \"next\".\n\t(self_recursive_call_p): Likewise for param \"insn\".\n\t(collect_fn_hard_reg_usage): Likewise for local \"insn\".\n\t(get_call_fndecl): Likewise for param \"insn\".\n\t(get_call_cgraph_rtl_info): Likewise.\n\t(get_call_reg_set_usage): Rename param from \"insn\" to \"uncast_insn\",\n\tintroducing a new local rtx_insn * \"insn\" using a checked cast to\n\teffectively strengthen \"insn\" from rtx to rtx_insn * without\n\taffecting the type signature.\n\n\t* config/arc/arc.c (arc_final_prescan_insn): For now, add checked\n\tcast when assigning from param \"insn\" to current_output_insn.\n\t(arc_pad_return): Strengthen local \"insn\" from rtx to rtx_insn *\n\tso that we can assign it back to current_output_insn.\n\nFrom-SVN: r214326", "tree": {"sha": "4987759877150c5c1172a14e650d93626bf6d7d5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/4987759877150c5c1172a14e650d93626bf6d7d5"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/fa7af5812f2da9411baeffbc7aeedf749b8ef9d9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fa7af5812f2da9411baeffbc7aeedf749b8ef9d9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fa7af5812f2da9411baeffbc7aeedf749b8ef9d9", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fa7af5812f2da9411baeffbc7aeedf749b8ef9d9/comments", "author": {"login": "davidmalcolm", "id": 1553248, "node_id": "MDQ6VXNlcjE1NTMyNDg=", "avatar_url": "https://avatars.githubusercontent.com/u/1553248?v=4", "gravatar_id": "", "url": "https://api.github.com/users/davidmalcolm", "html_url": "https://github.com/davidmalcolm", "followers_url": "https://api.github.com/users/davidmalcolm/followers", "following_url": "https://api.github.com/users/davidmalcolm/following{/other_user}", "gists_url": "https://api.github.com/users/davidmalcolm/gists{/gist_id}", "starred_url": "https://api.github.com/users/davidmalcolm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/davidmalcolm/subscriptions", "organizations_url": "https://api.github.com/users/davidmalcolm/orgs", "repos_url": "https://api.github.com/users/davidmalcolm/repos", "events_url": "https://api.github.com/users/davidmalcolm/events{/privacy}", "received_events_url": "https://api.github.com/users/davidmalcolm/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "836fca28a3fde96f8470d8d401e9ceadb7386bd5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/836fca28a3fde96f8470d8d401e9ceadb7386bd5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/836fca28a3fde96f8470d8d401e9ceadb7386bd5"}], "stats": {"total": 180, "additions": 127, "deletions": 53}, "files": [{"sha": "e2ef86e3a826a1daaf055c585245566b0c0b5846", "filename": "gcc/ChangeLog", "status": "modified", "additions": 67, "deletions": 0, "changes": 67, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fa7af5812f2da9411baeffbc7aeedf749b8ef9d9/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fa7af5812f2da9411baeffbc7aeedf749b8ef9d9/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=fa7af5812f2da9411baeffbc7aeedf749b8ef9d9", "patch": "@@ -1,3 +1,70 @@\n+2014-08-22  David Malcolm  <dmalcolm@redhat.com>\n+\n+\t* output.h (final_scan_insn): Strengthen return type from rtx to\n+\trtx_insn *.\n+\t(final_forward_branch_p): Likewise for param.\n+\t(current_output_insn): Likewise for this global.\n+\n+\t* final.c (rtx debug_insn): Likewise for this variable.\n+\t(current_output_insn): Likewise.\n+\t(get_attr_length_1): Rename param \"insn\" to \"uncast_insn\",\n+\tadding \"insn\" back in as an rtx_insn * with a checked cast, so\n+\tthat macro ADJUST_INSN_LENGTH can be passed an rtx_insn * as the\n+\tfirst param.\n+\t(compute_alignments): Strengthen local \"label\" from rtx to\n+\trtx_insn *.\n+\t(shorten_branches): Rename param from \"first\" to \"uncast_first\",\n+\tintroducing a new local rtx_insn * \"first\" using a checked cast to\n+\teffectively strengthen \"first\" from rtx to rtx_insn * without\n+\taffecting the type signature.  Strengthen locals \"insn\", \"seq\",\n+\t\"next\", \"label\" from rtx to rtx_insn *.\n+\t(change_scope): Strengthen param \"orig_insn\" and local \"insn\" from\n+\trtx to rtx_insn *.\n+\t(final_start_function): Rename param from \"first\" to \"uncast_first\",\n+\tintroducing a new local rtx_insn * \"first\" using a checked cast to\n+\teffectively strengthen \"first\" from rtx to rtx_insn * without\n+\taffecting the type signature.  Strengthen local \"insn\" from rtx to\n+\trtx_insn *.\n+\t(dump_basic_block_info): Strengthen param \"insn\" from rtx to\n+\trtx_insn *.\n+\t(final): Rename param from \"first\" to \"uncast_first\",\n+\tintroducing a new local rtx_insn * \"first\" using a checked cast to\n+\teffectively strengthen \"first\" from rtx to rtx_insn * without\n+\taffecting the type signature.  Strengthen locals \"insn\", \"next\"\n+\tfrom rtx to rtx_insn *.\n+\t(output_alternate_entry_point): Strengthen param \"insn\" from rtx to\n+\trtx_insn *.\n+\t(call_from_call_insn): Strengthen param \"insn\" from rtx to\n+\trtx_call_insn *.\n+\t(final_scan_insn): Rename param from \"insn\" to \"uncast_insn\",\n+\tintroducing a new local rtx_insn * \"insn\" using a checked cast to\n+\teffectively strengthen \"insn\" from rtx to rtx_insn * without\n+\taffecting the type signature.  Strengthen return type and locals\n+\t\"next\", \"note\", \"prev\", \"new_rtx\" from rtx to rtx_insn *.  Remove\n+\tnow-redundant checked cast to rtx_insn * from both invocations of\n+\tdebug_hooks->var_location.  Convert CALL_P into a dyn_cast,\n+\tintroducing a local \"call_insn\" for use when invoking\n+\tcall_from_call_insn.\n+\t(notice_source_line): Strengthen param \"insn\" from rtx to\n+\trtx_insn *.\n+\t(leaf_function_p): Likewise for local \"insn\".\n+\t(final_forward_branch_p): Likewise.\n+\t(leaf_renumber_regs): Likewise for param \"first\".\n+\t(rest_of_clean_state): Likewise for locals \"insn\" and \"next\".\n+\t(self_recursive_call_p): Likewise for param \"insn\".\n+\t(collect_fn_hard_reg_usage): Likewise for local \"insn\".\n+\t(get_call_fndecl): Likewise for param \"insn\".\n+\t(get_call_cgraph_rtl_info): Likewise.\n+\t(get_call_reg_set_usage): Rename param from \"insn\" to \"uncast_insn\",\n+\tintroducing a new local rtx_insn * \"insn\" using a checked cast to\n+\teffectively strengthen \"insn\" from rtx to rtx_insn * without\n+\taffecting the type signature.\n+\n+\t* config/arc/arc.c (arc_final_prescan_insn): For now, add checked\n+\tcast when assigning from param \"insn\" to current_output_insn.\n+\t(arc_pad_return): Strengthen local \"insn\" from rtx to rtx_insn *\n+\tso that we can assign it back to current_output_insn.\n+\n 2014-08-20  Pitchumani Sivanupandi <pitchumani.s@atmel.com>\n \n \t* config/avr/avr-mcus.def: Remove atmega26hvg, atmega64rfa2,"}, {"sha": "f0e8419285a0ea52e4ae7bbc5e3c936cdfebd9a0", "filename": "gcc/config/arc/arc.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fa7af5812f2da9411baeffbc7aeedf749b8ef9d9/gcc%2Fconfig%2Farc%2Farc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fa7af5812f2da9411baeffbc7aeedf749b8ef9d9/gcc%2Fconfig%2Farc%2Farc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farc%2Farc.c?ref=fa7af5812f2da9411baeffbc7aeedf749b8ef9d9", "patch": "@@ -3943,7 +3943,7 @@ arc_final_prescan_insn (rtx insn, rtx *opvec ATTRIBUTE_UNUSED,\n       current_output_insn =\n \temit_insn_before (gen_nop (), NEXT_INSN (PREV_INSN (insn)));\n       final_scan_insn (current_output_insn, asm_out_file, optimize, 1, NULL);\n-      current_output_insn = insn;\n+      current_output_insn = as_a <rtx_insn *> (insn);\n     }\n   /* Restore extraction data which might have been clobbered by arc_hazard.  */\n   extract_constrain_insn_cached (insn);\n@@ -8651,7 +8651,7 @@ arc_branch_size_unknown_p (void)\n void\n arc_pad_return (void)\n {\n-  rtx insn = current_output_insn;\n+  rtx_insn *insn = current_output_insn;\n   rtx prev = prev_active_insn (insn);\n   int want_long;\n "}, {"sha": "3208220194b6e519132a778bff694a031dd4e8e8", "filename": "gcc/final.c", "status": "modified", "additions": 55, "deletions": 48, "changes": 103, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fa7af5812f2da9411baeffbc7aeedf749b8ef9d9/gcc%2Ffinal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fa7af5812f2da9411baeffbc7aeedf749b8ef9d9/gcc%2Ffinal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffinal.c?ref=fa7af5812f2da9411baeffbc7aeedf749b8ef9d9", "patch": "@@ -117,8 +117,8 @@ along with GCC; see the file COPYING3.  If not see\n #define SEEN_EMITTED\t2\n \n /* Last insn processed by final_scan_insn.  */\n-static rtx debug_insn;\n-rtx current_output_insn;\n+static rtx_insn *debug_insn;\n+rtx_insn *current_output_insn;\n \n /* Line number of last NOTE.  */\n static int last_linenum;\n@@ -208,14 +208,14 @@ static bool need_profile_function;\n static int asm_insn_count (rtx);\n static void profile_function (FILE *);\n static void profile_after_prologue (FILE *);\n-static bool notice_source_line (rtx, bool *);\n+static bool notice_source_line (rtx_insn *, bool *);\n static rtx walk_alter_subreg (rtx *, bool *);\n static void output_asm_name (void);\n-static void output_alternate_entry_point (FILE *, rtx);\n+static void output_alternate_entry_point (FILE *, rtx_insn *);\n static tree get_mem_expr_from_op (rtx, int *);\n static void output_asm_operand_names (rtx *, int *, int);\n #ifdef LEAF_REGISTERS\n-static void leaf_renumber_regs (rtx);\n+static void leaf_renumber_regs (rtx_insn *);\n #endif\n #ifdef HAVE_cc0\n static int alter_cond (rtx);\n@@ -225,7 +225,7 @@ static int final_addr_vec_align (rtx);\n #endif\n static int align_fuzz (rtx, rtx, int, unsigned);\n static void collect_fn_hard_reg_usage (void);\n-static tree get_call_fndecl (rtx);\n+static tree get_call_fndecl (rtx_insn *);\n \f\n /* Initialize data in final at the beginning of a compilation.  */\n \n@@ -374,8 +374,9 @@ init_insn_lengths (void)\n    get its actual length.  Otherwise, use FALLBACK_FN to calculate the\n    length.  */\n static int\n-get_attr_length_1 (rtx insn, int (*fallback_fn) (rtx))\n+get_attr_length_1 (rtx uncast_insn, int (*fallback_fn) (rtx))\n {\n+  rtx_insn *insn = as_a <rtx_insn *> (uncast_insn);\n   rtx body;\n   int i;\n   int length = 0;\n@@ -711,7 +712,7 @@ compute_alignments (void)\n     fprintf (dump_file, \"freq_max: %i\\n\",freq_max);\n   FOR_EACH_BB_FN (bb, cfun)\n     {\n-      rtx label = BB_HEAD (bb);\n+      rtx_insn *label = BB_HEAD (bb);\n       int fallthru_frequency = 0, branch_frequency = 0, has_fallthru = 0;\n       edge e;\n       edge_iterator ei;\n@@ -898,15 +899,16 @@ make_pass_compute_alignments (gcc::context *ctxt)\n    slots.  */\n \n void\n-shorten_branches (rtx first)\n+shorten_branches (rtx uncast_first)\n {\n-  rtx insn;\n+  rtx_insn *first = safe_as_a <rtx_insn *> (uncast_first);\n+  rtx_insn *insn;\n   int max_uid;\n   int i;\n   int max_log;\n   int max_skip;\n #define MAX_CODE_ALIGN 16\n-  rtx seq;\n+  rtx_insn *seq;\n   int something_changed = 1;\n   char *varying_length;\n   rtx body;\n@@ -943,7 +945,7 @@ shorten_branches (rtx first)\n \n       if (LABEL_P (insn))\n \t{\n-\t  rtx next;\n+\t  rtx_insn *next;\n \t  bool next_is_jumptable;\n \n \t  /* Merge in alignments computed by compute_alignments.  */\n@@ -985,7 +987,7 @@ shorten_branches (rtx first)\n \t}\n       else if (BARRIER_P (insn))\n \t{\n-\t  rtx label;\n+\t  rtx_insn *label;\n \n \t  for (label = insn; label && ! INSN_P (label);\n \t       label = NEXT_INSN (label))\n@@ -1230,7 +1232,7 @@ shorten_branches (rtx first)\n #ifdef CASE_VECTOR_SHORTEN_MODE\n \t      /* If the mode of a following jump table was changed, we\n \t\t may need to update the alignment of this label.  */\n-\t      rtx next;\n+\t      rtx_insn *next;\n \t      bool next_is_jumptable;\n \n \t      next = next_nonnote_insn (insn);\n@@ -1605,9 +1607,9 @@ choose_inner_scope (tree s1, tree s2)\n /* Emit lexical block notes needed to change scope from S1 to S2.  */\n \n static void\n-change_scope (rtx orig_insn, tree s1, tree s2)\n+change_scope (rtx_insn *orig_insn, tree s1, tree s2)\n {\n-  rtx insn = orig_insn;\n+  rtx_insn *insn = orig_insn;\n   tree com = NULL_TREE;\n   tree ts1 = s1, ts2 = s2;\n   tree s;\n@@ -1728,9 +1730,10 @@ reemit_insn_block_notes (void)\n      test and compare insns.  */\n \n void\n-final_start_function (rtx first, FILE *file,\n+final_start_function (rtx uncast_first, FILE *file,\n \t\t      int optimize_p ATTRIBUTE_UNUSED)\n {\n+  rtx_insn *first = safe_as_a <rtx_insn *> (uncast_first);\n   block_depth = 0;\n \n   this_is_asm_operands = 0;\n@@ -1768,11 +1771,11 @@ final_start_function (rtx first, FILE *file,\n #endif\n \t )\n \t{\n-\t  rtx insn;\n+\t  rtx_insn *insn;\n \t  for (insn = first; insn; insn = NEXT_INSN (insn))\n \t    if (!NOTE_P (insn))\n \t      {\n-\t\tinsn = NULL_RTX;\n+\t\tinsn = NULL;\n \t\tbreak;\n \t      }\n \t    else if (NOTE_KIND (insn) == NOTE_INSN_BASIC_BLOCK\n@@ -1783,7 +1786,7 @@ final_start_function (rtx first, FILE *file,\n \t      continue;\n \t    else\n \t      {\n-\t\tinsn = NULL_RTX;\n+\t\tinsn = NULL;\n \t\tbreak;\n \t      }\n \n@@ -1909,7 +1912,7 @@ final_end_function (void)\n    output file, and INSN is the instruction being emitted.  */\n \n static void\n-dump_basic_block_info (FILE *file, rtx insn, basic_block *start_to_bb,\n+dump_basic_block_info (FILE *file, rtx_insn *insn, basic_block *start_to_bb,\n                        basic_block *end_to_bb, int bb_map_size, int *bb_seqn)\n {\n   basic_block bb;\n@@ -1956,9 +1959,10 @@ dump_basic_block_info (FILE *file, rtx insn, basic_block *start_to_bb,\n    For description of args, see `final_start_function', above.  */\n \n void\n-final (rtx first, FILE *file, int optimize_p)\n+final (rtx uncast_first, FILE *file, int optimize_p)\n {\n-  rtx insn, next;\n+  rtx_insn *first = safe_as_a <rtx_insn *> (uncast_first);\n+  rtx_insn *insn, *next;\n   int seen = 0;\n \n   /* Used for -dA dump.  */\n@@ -2069,7 +2073,7 @@ get_insn_template (int code, rtx insn)\n \n    The case fall-through in this function is intentional.  */\n static void\n-output_alternate_entry_point (FILE *file, rtx insn)\n+output_alternate_entry_point (FILE *file, rtx_insn *insn)\n {\n   const char *name = LABEL_NAME (insn);\n \n@@ -2096,7 +2100,7 @@ output_alternate_entry_point (FILE *file, rtx insn)\n \n /* Given a CALL_INSN, find and return the nested CALL. */\n static rtx\n-call_from_call_insn (rtx insn)\n+call_from_call_insn (rtx_call_insn *insn)\n {\n   rtx x;\n   gcc_assert (CALL_P (insn));\n@@ -2134,14 +2138,16 @@ call_from_call_insn (rtx insn)\n    debug information.  We force the emission of a line note after\n    both NOTE_INSN_PROLOGUE_END and NOTE_INSN_FUNCTION_BEG.  */\n \n-rtx\n-final_scan_insn (rtx insn, FILE *file, int optimize_p ATTRIBUTE_UNUSED,\n+rtx_insn *\n+final_scan_insn (rtx uncast_insn, FILE *file, int optimize_p ATTRIBUTE_UNUSED,\n \t\t int nopeepholes ATTRIBUTE_UNUSED, int *seen)\n {\n #ifdef HAVE_cc0\n   rtx set;\n #endif\n-  rtx next;\n+  rtx_insn *next;\n+\n+  rtx_insn *insn = as_a <rtx_insn *> (uncast_insn);\n \n   insn_counter++;\n \n@@ -2343,7 +2349,7 @@ final_scan_insn (rtx insn, FILE *file, int optimize_p ATTRIBUTE_UNUSED,\n \tcase NOTE_INSN_VAR_LOCATION:\n \tcase NOTE_INSN_CALL_ARG_LOCATION:\n \t  if (!DECL_IGNORED_P (current_function_decl))\n-\t    debug_hooks->var_location (as_a <rtx_insn *> (insn));\n+\t    debug_hooks->var_location (insn);\n \t  break;\n \n \tdefault:\n@@ -2633,7 +2639,7 @@ final_scan_insn (rtx insn, FILE *file, int optimize_p ATTRIBUTE_UNUSED,\n \t    for (i = 1; i < XVECLEN (body, 0); i++)\n \t      {\n \t\trtx insn = XVECEXP (body, 0, i);\n-\t\trtx next = NEXT_INSN (insn);\n+\t\trtx_insn *next = NEXT_INSN (insn);\n \t\t/* We loop in case any instruction in a delay slot gets\n \t\t   split.  */\n \t\tdo\n@@ -2842,12 +2848,12 @@ final_scan_insn (rtx insn, FILE *file, int optimize_p ATTRIBUTE_UNUSED,\n \n \tif (optimize_p && !flag_no_peephole && !nopeepholes)\n \t  {\n-\t    rtx next = peephole (insn);\n+\t    rtx_insn *next = peephole (insn);\n \t    /* When peepholing, if there were notes within the peephole,\n \t       emit them before the peephole.  */\n \t    if (next != 0 && next != NEXT_INSN (insn))\n \t      {\n-\t\trtx note, prev = PREV_INSN (insn);\n+\t\trtx_insn *note, *prev = PREV_INSN (insn);\n \n \t\tfor (note = NEXT_INSN (insn); note != next;\n \t\t     note = NEXT_INSN (note))\n@@ -2927,7 +2933,7 @@ final_scan_insn (rtx insn, FILE *file, int optimize_p ATTRIBUTE_UNUSED,\n \t   needs to be reinserted.  */\n \tif (templ == 0)\n \t  {\n-\t    rtx prev;\n+\t    rtx_insn *prev;\n \n \t    gcc_assert (prev_nonnote_insn (insn) == last_ignored_compare);\n \n@@ -2950,7 +2956,7 @@ final_scan_insn (rtx insn, FILE *file, int optimize_p ATTRIBUTE_UNUSED,\n \t   be split.  */\n \tif (templ[0] == '#' && templ[1] == '\\0')\n \t  {\n-\t    rtx new_rtx = try_split (body, insn, 0);\n+\t    rtx_insn *new_rtx = try_split (body, insn, 0);\n \n \t    /* If we didn't split the insn, go away.  */\n \t    if (new_rtx == insn && PATTERN (new_rtx) == body)\n@@ -2971,9 +2977,9 @@ final_scan_insn (rtx insn, FILE *file, int optimize_p ATTRIBUTE_UNUSED,\n \t    && targetm.asm_out.unwind_emit)\n \t  targetm.asm_out.unwind_emit (asm_out_file, insn);\n \n-\tif (CALL_P (insn))\n+\tif (rtx_call_insn *call_insn = dyn_cast <rtx_call_insn *> (insn))\n \t  {\n-\t    rtx x = call_from_call_insn (insn);\n+\t    rtx x = call_from_call_insn (call_insn);\n \t    x = XEXP (x, 0);\n \t    if (x && MEM_P (x) && GET_CODE (XEXP (x, 0)) == SYMBOL_REF)\n \t      {\n@@ -2984,7 +2990,7 @@ final_scan_insn (rtx insn, FILE *file, int optimize_p ATTRIBUTE_UNUSED,\n \t\t  assemble_external (t);\n \t      }\n \t    if (!DECL_IGNORED_P (current_function_decl))\n-\t      debug_hooks->var_location (as_a <rtx_insn *> (insn));\n+\t      debug_hooks->var_location (insn);\n \t  }\n \n \t/* Output assembler code from the template.  */\n@@ -3011,7 +3017,7 @@ final_scan_insn (rtx insn, FILE *file, int optimize_p ATTRIBUTE_UNUSED,\n    breakpoint location.  */\n \n static bool\n-notice_source_line (rtx insn, bool *is_stmt)\n+notice_source_line (rtx_insn *insn, bool *is_stmt)\n {\n   const char *filename;\n   int linenum;\n@@ -4262,7 +4268,7 @@ asm_fprintf (FILE *file, const char *p, ...)\n int\n leaf_function_p (void)\n {\n-  rtx insn;\n+  rtx_insn *insn;\n \n   /* Some back-ends (e.g. s390) want leaf functions to stay leaf\n      functions even if they call mcount.  */\n@@ -4289,7 +4295,7 @@ leaf_function_p (void)\n    output templates to customary add branch prediction hints.\n  */\n int\n-final_forward_branch_p (rtx insn)\n+final_forward_branch_p (rtx_insn *insn)\n {\n   int insn_id, label_id;\n \n@@ -4339,9 +4345,9 @@ only_leaf_regs_used (void)\n    available in leaf functions.  */\n \n static void\n-leaf_renumber_regs (rtx first)\n+leaf_renumber_regs (rtx_insn *first)\n {\n-  rtx insn;\n+  rtx_insn *insn;\n \n   /* Renumber only the actual patterns.\n      The reg-notes can contain frame pointer refs,\n@@ -4588,7 +4594,7 @@ make_pass_shorten_branches (gcc::context *ctxt)\n static unsigned int\n rest_of_clean_state (void)\n {\n-  rtx insn, next;\n+  rtx_insn *insn, *next;\n   FILE *final_output = NULL;\n   int save_unnumbered = flag_dump_unnumbered;\n   int save_noaddr = flag_dump_noaddr;\n@@ -4752,7 +4758,7 @@ make_pass_clean_state (gcc::context *ctxt)\n /* Return true if INSN is a call to the the current function.  */\n \n static bool\n-self_recursive_call_p (rtx insn)\n+self_recursive_call_p (rtx_insn *insn)\n {\n   tree fndecl = get_call_fndecl (insn);\n   return (fndecl == current_function_decl\n@@ -4764,7 +4770,7 @@ self_recursive_call_p (rtx insn)\n static void\n collect_fn_hard_reg_usage (void)\n {\n-  rtx insn;\n+  rtx_insn *insn;\n #ifdef STACK_REGS\n   int i;\n #endif\n@@ -4824,7 +4830,7 @@ collect_fn_hard_reg_usage (void)\n /* Get the declaration of the function called by INSN.  */\n \n static tree\n-get_call_fndecl (rtx insn)\n+get_call_fndecl (rtx_insn *insn)\n {\n   rtx note, datum;\n \n@@ -4843,7 +4849,7 @@ get_call_fndecl (rtx insn)\n    call targets that can be overwritten.  */\n \n static struct cgraph_rtl_info *\n-get_call_cgraph_rtl_info (rtx insn)\n+get_call_cgraph_rtl_info (rtx_insn *insn)\n {\n   tree fndecl;\n \n@@ -4862,9 +4868,10 @@ get_call_cgraph_rtl_info (rtx insn)\n    in REG_SET.  Return DEFAULT_SET in REG_SET if not found.  */\n \n bool\n-get_call_reg_set_usage (rtx insn, HARD_REG_SET *reg_set,\n+get_call_reg_set_usage (rtx uncast_insn, HARD_REG_SET *reg_set,\n \t\t\tHARD_REG_SET default_set)\n {\n+  rtx_insn *insn = safe_as_a <rtx_insn *> (uncast_insn);\n   if (flag_use_caller_save)\n     {\n       struct cgraph_rtl_info *node = get_call_cgraph_rtl_info (insn);"}, {"sha": "e4799cfa6a118285701979be7926552eb8701d0e", "filename": "gcc/output.h", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fa7af5812f2da9411baeffbc7aeedf749b8ef9d9/gcc%2Foutput.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fa7af5812f2da9411baeffbc7aeedf749b8ef9d9/gcc%2Foutput.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Foutput.h?ref=fa7af5812f2da9411baeffbc7aeedf749b8ef9d9", "patch": "@@ -70,7 +70,7 @@ extern void final (rtx, FILE *, int);\n /* The final scan for one insn, INSN.  Args are same as in `final', except\n    that INSN is the insn being scanned.  Value returned is the next insn to\n    be scanned.  */\n-extern rtx final_scan_insn (rtx, FILE *, int, int, int *);\n+extern rtx_insn *final_scan_insn (rtx, FILE *, int, int, int *);\n \n /* Replace a SUBREG with a REG or a MEM, based on the thing it is a\n    subreg of.  */\n@@ -136,7 +136,7 @@ extern int leaf_function_p (void);\n /* Return 1 if branch is a forward branch.\n    Uses insn_shuid array, so it works only in the final pass.  May be used by\n    output templates to add branch prediction hints, for example.  */\n-extern int final_forward_branch_p (rtx);\n+extern int final_forward_branch_p (rtx_insn *);\n \n /* Return 1 if this function uses only the registers that can be\n    safely renumbered.  */\n@@ -321,7 +321,7 @@ extern const char *weak_global_object_name;\n extern rtx current_insn_predicate;\n \n /* Last insn processed by final_scan_insn.  */\n-extern rtx current_output_insn;\n+extern rtx_insn *current_output_insn;\n \n /* Nonzero while outputting an `asm' with operands.\n    This means that inconsistencies are the user's fault, so don't die."}]}