{"sha": "10154ff81b1951a085df3fd7ed32b69350e93e6f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTAxNTRmZjgxYjE5NTFhMDg1ZGYzZmQ3ZWQzMmI2OTM1MGU5M2U2Zg==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2003-01-28T18:14:42Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2003-01-28T18:14:42Z"}, "message": "target.h (targetm.address_cost): New.\n\n\t* target.h (targetm.address_cost): New.\n\t* target-def.h (TARGET_ADDRESS_COST): New.\n\t(TARGET_RTX_COSTS): Uncomment.  Oops.\n\t* cse.c (address_cost): Use new target hook.\n\t(default_address_cost): New.\n\t* output.h (default_address_cost): Declare.\n\t* hooks.c (hook_int_rtx_0): New.\n\t* hooks.h (hook_int_rtx_0): Declare.\n\t* loop.c (combine_givs_p): Remove if 0 code.\n\t* system.h (ADDRESS_COST): Poison.\n\n\t* config/alpha/alpha.c, config/alpha/alpha.h, config/d30v/d30v.c,\n\tconfig/d30v/d30v.h, config/ia64/ia64.c, config/ia64/ia64.h,\n\tconfig/m32r/m32r.c, config/m32r/m32r.h, config/mcore/mcore.c,\n\tconfig/mcore/mcore.h, config/mmix/mmix.c, config/mmix/mmix.h,\n\tconfig/rs6000/rs6000.c, config/rs6000/rs6000.h, config/sparc/sparc.c,\n\tconfig/sparc/sparc.h, config/v850/v850.c, config/v850/v850.h,\n\tconfig/xtensa/xtensa.c, config/xtensa/xtensa.h\n\t(TARGET_ADDRESS_COST): Define as hook_int_rtx_0.\n\t(ADDRESS_COST): Remove.\n\n\t* config/arc/arc-protos.h, config/arc/arc.c, config/arc/arc.h,\n\tconfig/avr/avr-protos.h, config/avr/avr.c, config/avr/avr.h,\n\tconfig/c4x/c4x-protos.h, config/c4x/c4x.c, config/c4x/c4x.h,\n\tconfig/dsp16xx/dsp16xx-protos.h, config/dsp16xx/dsp16xx.c,\n\tconfig/dsp16xx/dsp16xx.h, config/i386/i386-protos.h,\n\tconfig/i386/i386.c, config/i386/i386.h, config/i960/i960-protos.h,\n\tconfig/i960/i960.c, config/i960/i960.h, config/ip2k/ip2k-protos.h,\n\tconfig/ip2k/ip2k.c, config/ip2k/ip2k.h, config/mips/mips-protos.h,\n\tconfig/mips/mips.c, config/mips/mips.h,\n\tconfig/m68hc11/m68hc11-protos.h, config/m68hc11/m68hc11.c,\n\tconfig/m68hc11/m68hc11.h, config/ns32k/ns32k-protos.h,\n\tconfig/ns32k/ns32k.c, config/ns32k/ns32k.h, config/pa/pa-protos.h,\n\tconfig/pa/pa.c, config/pa/pa.h, config/s390/s390-protos.h,\n\tconfig/s390/s390.c, config/s390/s390.h, config/vax/vax-protos.h,\n\tconfig/vax/vax.c, config/vax/vax.h\n\t(foo_address_cost): Make static.\n\t(TARGET_ADDRESS_COST): New.\n\t(ADDRESS_COST): Remove.\n\n\t* config/arm/arm.h, config/arm/arm.c, config/m88k/m88k.h,\n\tconfig/m88k/m88k.c, config/romp/romp.h, config/romp/romp.c,\n\tconfig/sh/sh.c, config/sh/sh.h, config/stormy16/stormy16.c,\n\tconfig/stormy16/stormy16.h\n\t(ADDRESS_COST): Move code ...\n\t(foo_address_cost): ... here.\n\t(TARGET_ADDRESS_COST): New.\n\n\t* config/m32r/m32r.c (m32r_address_cost): Remove.\n\t* config/m32r/m32r-protos.h: Update.\n\n\t* config/mmix/mmix.c (mmix_address_cost): Remove.\n\t* config/mmix/mmix-protos.h: Update.\n\n\t* config/mn10300/mn10300.c (mn10300_address_cost_1): Rename from\n\tmn10300_address_cost; move unsig allocation ...\n\t(mn10300_address_cost): ... here.\n\t(TARGET_ADDRESS_COST): New.\n\t* config/mn10300/mn10300-protos.h: Update.\n\t* config/mn10300/mn10300.h (ADDRESS_COST): Remove.\n\nFrom-SVN: r61989", "tree": {"sha": "0084305789a6364711b743c72667675c987030e5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/0084305789a6364711b743c72667675c987030e5"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/10154ff81b1951a085df3fd7ed32b69350e93e6f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/10154ff81b1951a085df3fd7ed32b69350e93e6f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/10154ff81b1951a085df3fd7ed32b69350e93e6f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/10154ff81b1951a085df3fd7ed32b69350e93e6f/comments", "author": null, "committer": null, "parents": [{"sha": "dcefdf6717c42e30b0058fe26780188ff5978821", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dcefdf6717c42e30b0058fe26780188ff5978821", "html_url": "https://github.com/Rust-GCC/gccrs/commit/dcefdf6717c42e30b0058fe26780188ff5978821"}], "stats": {"total": 77, "additions": 35, "deletions": 42}, "files": [{"sha": "382df86688c9fa2b57cf8d37f47ca7343e569d11", "filename": "gcc/doc/tm.texi", "status": "modified", "additions": 35, "deletions": 42, "changes": 77, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/10154ff81b1951a085df3fd7ed32b69350e93e6f/gcc%2Fdoc%2Ftm.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/10154ff81b1951a085df3fd7ed32b69350e93e6f/gcc%2Fdoc%2Ftm.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Ftm.texi?ref=10154ff81b1951a085df3fd7ed32b69350e93e6f", "patch": "@@ -5264,48 +5264,6 @@ These macros let you describe the relative speed of various operations\n on the target machine.\n \n @table @code\n-@findex ADDRESS_COST\n-@item ADDRESS_COST (@var{address})\n-An expression giving the cost of an addressing mode that contains\n-@var{address}.  If not defined, the cost is computed from\n-the @var{address} expression and the @code{CONST_COSTS} values.\n-\n-For most CISC machines, the default cost is a good approximation of the\n-true cost of the addressing mode.  However, on RISC machines, all\n-instructions normally have the same length and execution time.  Hence\n-all addresses will have equal costs.\n-\n-In cases where more than one form of an address is known, the form with\n-the lowest cost will be used.  If multiple forms have the same, lowest,\n-cost, the one that is the most complex will be used.\n-\n-For example, suppose an address that is equal to the sum of a register\n-and a constant is used twice in the same basic block.  When this macro\n-is not defined, the address will be computed in a register and memory\n-references will be indirect through that register.  On machines where\n-the cost of the addressing mode containing the sum is no higher than\n-that of a simple indirect reference, this will produce an additional\n-instruction and possibly require an additional register.  Proper\n-specification of this macro eliminates this overhead for such machines.\n-\n-Similar use of this macro is made in strength reduction of loops.\n-\n-@var{address} need not be valid as an address.  In such a case, the cost\n-is not relevant and can be any value; invalid addresses need not be\n-assigned a different cost.\n-\n-On machines where an address involving more than one register is as\n-cheap as an address computation involving only one register, defining\n-@code{ADDRESS_COST} to reflect this can cause two registers to be live\n-over a region of code where only one would have been if\n-@code{ADDRESS_COST} were not defined in that manner.  This effect should\n-be considered in the definition of this macro.  Equivalent costs should\n-probably only be given to addresses with different numbers of registers\n-on machines with lots of registers.\n-\n-This macro will normally either not be defined or be defined as a\n-constant.\n-\n @findex REGISTER_MOVE_COST\n @item REGISTER_MOVE_COST (@var{mode}, @var{from}, @var{to})\n A C expression for the cost of moving data of mode @var{mode} from a\n@@ -5529,6 +5487,41 @@ The hook returns true when all subexpressions of @var{x} have been\n processed, and false when @code{rtx_cost} should recurse.\n @end deftypefn\n \n+@deftypefn {Target Hook} int TARGET_ADDRESS_COST (rtx @var{address})\n+This hook computes the cost of an addressing mode that contains\n+@var{address}.  If not defined, the cost is computed from\n+the @var{address} expression and the @code{TARGET_RTX_COST} hook.\n+\n+For most CISC machines, the default cost is a good approximation of the\n+true cost of the addressing mode.  However, on RISC machines, all\n+instructions normally have the same length and execution time.  Hence\n+all addresses will have equal costs.\n+\n+In cases where more than one form of an address is known, the form with\n+the lowest cost will be used.  If multiple forms have the same, lowest,\n+cost, the one that is the most complex will be used.\n+\n+For example, suppose an address that is equal to the sum of a register\n+and a constant is used twice in the same basic block.  When this macro\n+is not defined, the address will be computed in a register and memory\n+references will be indirect through that register.  On machines where\n+the cost of the addressing mode containing the sum is no higher than\n+that of a simple indirect reference, this will produce an additional\n+instruction and possibly require an additional register.  Proper\n+specification of this macro eliminates this overhead for such machines.\n+\n+This hook is never called with an invalid address.\n+\n+On machines where an address involving more than one register is as\n+cheap as an address computation involving only one register, defining\n+@code{TARGET_ADDRESS_COST} to reflect this can cause two registers to\n+be live over a region of code where only one would have been if\n+@code{TARGET_ADDRESS_COST} were not defined in that manner.  This effect\n+should be considered in the definition of this macro.  Equivalent costs\n+should probably only be given to addresses with different numbers of\n+registers on machines with lots of registers.\n+@end deftypefn\n+\n @node Scheduling\n @section Adjusting the Instruction Scheduler\n "}]}