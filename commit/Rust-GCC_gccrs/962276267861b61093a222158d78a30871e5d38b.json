{"sha": "962276267861b61093a222158d78a30871e5d38b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTYyMjc2MjY3ODYxYjYxMDkzYTIyMjE1OGQ3OGEzMDg3MWU1ZDM4Yg==", "commit": {"author": {"name": "Tom Tromey", "email": "tromey@gcc.gnu.org", "date": "2001-05-10T18:13:17Z"}, "committer": {"name": "Tom Tromey", "email": "tromey@gcc.gnu.org", "date": "2001-05-10T18:13:17Z"}, "message": "[multiple changes]\n\n2001-05-10  Tom Tromey  <tromey@redhat.com>\n\n\t* java/util/GregorianCalendar.java: Imported from Classpath.\n\t* gnu/java/locale/LocaleInformation_nl.java: New file from\n\tClasspath.\n\t* gnu/java/locale/LocaleInformation_en.java: Likewise.\n\t* gnu/java/locale/LocaleInformation_de.java: Likewise.\n\t* gnu/java/locale/LocaleInformation.java: Likewise.\n\t* natGregorianCalendar.cc: Removed.\n\t* Makefile.in: Rebuilt.\n\t* Makefile.am (nat_source_files): Removed\n\tnatGregorianCalendar.cc.\n\n2001-05-10  Tom Tromey  <tromey@redhat.com>\n\n\t* java/text/SimpleDateFormat.java (computeCenturyStart): New\n\tmethod.\n\t(defaultCenturyStart): Use it.\n\t(readObject): Likewise.\n\t(SimpleDateFormat): Clear the calendar.  Set the grouping on the\n\tnumber format.\n\t(parse): Copy the calendar before modifying it.  Correctly handle\n\tthe time zone.\n\n\t* java/util/Calendar.java (clear): Set field value(s) to 0.\n\n2001-05-10  Jeff Sturm  <jsturm@one-point.com>\n\n\t* Calendar.java (get): Clear areFieldsSet if requested field\n\tis not set.\n\t(set): Unset fields that depend on new value.\n\nFrom-SVN: r41942", "tree": {"sha": "be72e5f9af087633db647f380105f2fe59d2eb9e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/be72e5f9af087633db647f380105f2fe59d2eb9e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/962276267861b61093a222158d78a30871e5d38b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/962276267861b61093a222158d78a30871e5d38b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/962276267861b61093a222158d78a30871e5d38b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/962276267861b61093a222158d78a30871e5d38b/comments", "author": null, "committer": null, "parents": [{"sha": "b0089a92a30ae851e8bad7ca8da8b33dba4a5a95", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b0089a92a30ae851e8bad7ca8da8b33dba4a5a95", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b0089a92a30ae851e8bad7ca8da8b33dba4a5a95"}], "stats": {"total": 2484, "additions": 2085, "deletions": 399}, "files": [{"sha": "c803cd672b040c1ab35e0109a3428d357fe85668", "filename": "libjava/ChangeLog", "status": "modified", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/962276267861b61093a222158d78a30871e5d38b/libjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/962276267861b61093a222158d78a30871e5d38b/libjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FChangeLog?ref=962276267861b61093a222158d78a30871e5d38b", "patch": "@@ -1,3 +1,35 @@\n+2001-05-10  Tom Tromey  <tromey@redhat.com>\n+\n+\t* java/util/GregorianCalendar.java: Imported from Classpath.\n+\t* gnu/java/locale/LocaleInformation_nl.java: New file from\n+\tClasspath.\n+\t* gnu/java/locale/LocaleInformation_en.java: Likewise.\n+\t* gnu/java/locale/LocaleInformation_de.java: Likewise.\n+\t* gnu/java/locale/LocaleInformation.java: Likewise.\n+\t* natGregorianCalendar.cc: Removed.\n+\t* Makefile.in: Rebuilt.\n+\t* Makefile.am (nat_source_files): Removed\n+\tnatGregorianCalendar.cc.\n+\n+2001-05-10  Tom Tromey  <tromey@redhat.com>\n+\n+\t* java/text/SimpleDateFormat.java (computeCenturyStart): New\n+\tmethod.\n+\t(defaultCenturyStart): Use it.\n+\t(readObject): Likewise.\n+\t(SimpleDateFormat): Clear the calendar.  Set the grouping on the\n+\tnumber format.\n+\t(parse): Copy the calendar before modifying it.  Correctly handle\n+\tthe time zone.\n+\n+\t* java/util/Calendar.java (clear): Set field value(s) to 0.\n+\n+2001-05-10  Jeff Sturm  <jsturm@one-point.com>\n+\n+\t* Calendar.java (get): Clear areFieldsSet if requested field\n+\tis not set.\n+\t(set): Unset fields that depend on new value.\n+\n 2001-05-06  Bryce McKinlay  <bryce@waitaki.otago.ac.nz>\n \n \t* java/lang/Class.h (_Jv_Self): New union type."}, {"sha": "d5644a1590df43c1f88d69cf93b5aba28cdabb94", "filename": "libjava/Makefile.am", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/962276267861b61093a222158d78a30871e5d38b/libjava%2FMakefile.am", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/962276267861b61093a222158d78a30871e5d38b/libjava%2FMakefile.am", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FMakefile.am?ref=962276267861b61093a222158d78a30871e5d38b", "patch": "@@ -1335,7 +1335,6 @@ java/net/natInetAddress.cc \\\n java/net/natPlainDatagramSocketImpl.cc \\\n java/net/natPlainSocketImpl.cc \\\n java/text/natCollator.cc \\\n-java/util/natGregorianCalendar.cc \\\n java/util/zip/natDeflater.cc \\\n java/util/zip/natInflater.cc\n "}, {"sha": "d4435b6d8d3f332ead3d21fb65d91261a5c2848b", "filename": "libjava/Makefile.in", "status": "modified", "additions": 40, "deletions": 24, "changes": 64, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/962276267861b61093a222158d78a30871e5d38b/libjava%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/962276267861b61093a222158d78a30871e5d38b/libjava%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FMakefile.in?ref=962276267861b61093a222158d78a30871e5d38b", "patch": "@@ -73,6 +73,7 @@ CXXCPP = @CXXCPP@\n DIRLTDL = @DIRLTDL@\n DIVIDESPEC = @DIVIDESPEC@\n DLLTOOL = @DLLTOOL@\n+EXCEPTIONSPEC = @EXCEPTIONSPEC@\n EXEEXT = @EXEEXT@\n GCDEPS = @GCDEPS@\n GCINCS = @GCINCS@\n@@ -119,29 +120,43 @@ here = @here@\n libgcj_basedir = @libgcj_basedir@\n \n AUTOMAKE_OPTIONS = foreign\n-@TESTSUBDIR_TRUE@SUBDIRS = @TESTSUBDIR_TRUE@$(DIRLTDL) testsuite gcj include\n-@TESTSUBDIR_FALSE@SUBDIRS = @TESTSUBDIR_FALSE@$(DIRLTDL) gcj include\n-@USE_LIBDIR_TRUE@toolexeclibdir = @USE_LIBDIR_TRUE@$(libdir)$(MULTISUBDIR)\n-@USE_LIBDIR_FALSE@toolexeclibdir = @USE_LIBDIR_FALSE@$(toolexecdir)/lib$(MULTISUBDIR)\n-@USE_LIBDIR_FALSE@toolexecdir = @USE_LIBDIR_FALSE@$(exec_prefix)/$(target_alias)\n-@XLIB_AWT_TRUE@cond_x_ltlibrary = @XLIB_AWT_TRUE@libgcjx.la\n-@XLIB_AWT_FALSE@cond_x_ltlibrary = \n+@TESTSUBDIR_TRUE@SUBDIRS = \\\n+@TESTSUBDIR_TRUE@$(DIRLTDL) testsuite gcj include\n+@TESTSUBDIR_FALSE@SUBDIRS = \\\n+@TESTSUBDIR_FALSE@$(DIRLTDL) gcj include\n+@USE_LIBDIR_TRUE@toolexeclibdir = \\\n+@USE_LIBDIR_TRUE@$(libdir)$(MULTISUBDIR)\n+@USE_LIBDIR_FALSE@toolexeclibdir = \\\n+@USE_LIBDIR_FALSE@$(toolexecdir)/lib$(MULTISUBDIR)\n+@USE_LIBDIR_FALSE@toolexecdir = \\\n+@USE_LIBDIR_FALSE@$(exec_prefix)/$(target_alias)\n+@XLIB_AWT_TRUE@cond_x_ltlibrary = \\\n+@XLIB_AWT_TRUE@libgcjx.la\n+@XLIB_AWT_FALSE@cond_x_ltlibrary = \\\n \n toolexeclib_LTLIBRARIES = libgcj.la $(cond_x_ltlibrary)\n toolexeclib_DATA = libgcj.spec\n data_DATA = libgcj.jar\n \n-@NEEDS_DATA_START_TRUE@toolexeclib_LIBRARIES = @NEEDS_DATA_START_TRUE@libgcjdata.a\n-@NEEDS_DATA_START_TRUE@libgcjdata_a_SOURCES = @NEEDS_DATA_START_TRUE@libgcjdata.c\n+@NEEDS_DATA_START_TRUE@toolexeclib_LIBRARIES = \\\n+@NEEDS_DATA_START_TRUE@libgcjdata.a\n+@NEEDS_DATA_START_TRUE@libgcjdata_a_SOURCES = \\\n+@NEEDS_DATA_START_TRUE@libgcjdata.c\n \n-@NATIVE_TRUE@bin_PROGRAMS = @NATIVE_TRUE@jv-convert gij\n+@NATIVE_TRUE@bin_PROGRAMS = \\\n+@NATIVE_TRUE@jv-convert gij\n \n bin_SCRIPTS = addr2name.awk\n-@CANADIAN_TRUE@@NULL_TARGET_TRUE@ZIP = @CANADIAN_TRUE@@NULL_TARGET_TRUE@$(MULTIBUILDTOP)../$(COMPPATH)/fastjar/fastjar$(EXEEXT)\n-@CANADIAN_TRUE@@NULL_TARGET_FALSE@ZIP = @CANADIAN_TRUE@@NULL_TARGET_FALSE@fastjar\n-@CANADIAN_FALSE@ZIP = @CANADIAN_FALSE@$(MULTIBUILDTOP)../$(COMPPATH)/fastjar/fastjar$(EXEEXT)\n-@CANADIAN_TRUE@GCJH = @CANADIAN_TRUE@gcjh\n-@CANADIAN_FALSE@GCJH = @CANADIAN_FALSE@$(MULTIBUILDTOP)../$(COMPPATH)/gcc/gcjh$(EXEEXT)\n+@CANADIAN_TRUE@@NULL_TARGET_TRUE@ZIP = \\\n+@CANADIAN_TRUE@@NULL_TARGET_TRUE@$(MULTIBUILDTOP)../$(COMPPATH)/fastjar/fastjar$(EXEEXT)\n+@CANADIAN_TRUE@@NULL_TARGET_FALSE@ZIP = \\\n+@CANADIAN_TRUE@@NULL_TARGET_FALSE@fastjar\n+@CANADIAN_FALSE@ZIP = \\\n+@CANADIAN_FALSE@$(MULTIBUILDTOP)../$(COMPPATH)/fastjar/fastjar$(EXEEXT)\n+@CANADIAN_TRUE@GCJH = \\\n+@CANADIAN_TRUE@gcjh\n+@CANADIAN_FALSE@GCJH = \\\n+@CANADIAN_FALSE@$(MULTIBUILDTOP)../$(COMPPATH)/gcc/gcjh$(EXEEXT)\n \n GCJ_WITH_FLAGS = $(GCJ) --encoding=UTF-8\n \n@@ -160,8 +175,10 @@ AM_CXXFLAGS = -fno-rtti -fvtable-thunks -fnon-call-exceptions \\\n \t-fdollars-in-identifiers \\\n \t@LIBGCJ_CXXFLAGS@ @X_CFLAGS@ $(WARNINGS) -D_GNU_SOURCE\n \n-@USING_GCC_TRUE@AM_CFLAGS = @USING_GCC_TRUE@@LIBGCJ_CFLAGS@ $(WARNINGS)\n-@USING_GCC_FALSE@AM_CFLAGS = @USING_GCC_FALSE@@LIBGCJ_CFLAGS@\n+@USING_GCC_TRUE@AM_CFLAGS = \\\n+@USING_GCC_TRUE@@LIBGCJ_CFLAGS@ $(WARNINGS)\n+@USING_GCC_FALSE@AM_CFLAGS = \\\n+@USING_GCC_FALSE@@LIBGCJ_CFLAGS@\n \n JCFLAGS = -g\n JC1FLAGS = @LIBGCJ_JAVAFLAGS@ $(GCJFLAGS)\n@@ -229,7 +246,8 @@ extra_headers = java/lang/Object.h java/lang/Class.h\n \n NM = nm\n \n-@NATIVE_TRUE@@MAINTAINER_MODE_TRUE@noinst_PROGRAMS = @NATIVE_TRUE@@MAINTAINER_MODE_TRUE@gen-from-JIS\n+@NATIVE_TRUE@@MAINTAINER_MODE_TRUE@noinst_PROGRAMS = \\\n+@NATIVE_TRUE@@MAINTAINER_MODE_TRUE@gen-from-JIS\n \n CONVERT_DIR = gnu/gcj/convert\n \n@@ -1060,7 +1078,6 @@ java/net/natInetAddress.cc \\\n java/net/natPlainDatagramSocketImpl.cc \\\n java/net/natPlainSocketImpl.cc \\\n java/text/natCollator.cc \\\n-java/util/natGregorianCalendar.cc \\\n java/util/zip/natDeflater.cc \\\n java/util/zip/natInflater.cc\n \n@@ -1212,8 +1229,7 @@ java/lang/reflect/natArray.lo java/lang/reflect/natConstructor.lo \\\n java/lang/reflect/natField.lo java/lang/reflect/natMethod.lo \\\n java/net/natInetAddress.lo java/net/natPlainDatagramSocketImpl.lo \\\n java/net/natPlainSocketImpl.lo java/text/natCollator.lo \\\n-java/util/natGregorianCalendar.lo java/util/zip/natDeflater.lo \\\n-java/util/zip/natInflater.lo\n+java/util/zip/natDeflater.lo java/util/zip/natInflater.lo\n libgcjx_la_OBJECTS =  gnu/gcj/xlib/natClip.lo \\\n gnu/gcj/xlib/natColormap.lo gnu/gcj/xlib/natDisplay.lo \\\n gnu/gcj/xlib/natDrawable.lo gnu/gcj/xlib/natFont.lo \\\n@@ -1813,8 +1829,8 @@ DEP_FILES =  .deps/$(srcdir)/$(CONVERT_DIR)/gen-from-JIS.P \\\n .deps/java/util/jar/JarEntry.P .deps/java/util/jar/JarException.P \\\n .deps/java/util/jar/JarFile.P .deps/java/util/jar/JarInputStream.P \\\n .deps/java/util/jar/JarOutputStream.P .deps/java/util/jar/Manifest.P \\\n-.deps/java/util/natGregorianCalendar.P .deps/java/util/zip/Adler32.P \\\n-.deps/java/util/zip/CRC32.P .deps/java/util/zip/CheckedInputStream.P \\\n+.deps/java/util/zip/Adler32.P .deps/java/util/zip/CRC32.P \\\n+.deps/java/util/zip/CheckedInputStream.P \\\n .deps/java/util/zip/CheckedOutputStream.P \\\n .deps/java/util/zip/Checksum.P \\\n .deps/java/util/zip/DataFormatException.P \\\n@@ -2199,7 +2215,7 @@ distdir: $(DISTFILES)\n \t@for file in $(DISTFILES); do \\\n \t  d=$(srcdir); \\\n \t  if test -d $$d/$$file; then \\\n-\t    cp -pr $$d/$$file $(distdir)/$$file; \\\n+\t    cp -pr $$/$$file $(distdir)/$$file; \\\n \t  else \\\n \t    test -f $(distdir)/$$file \\\n \t    || ln $$d/$$file $(distdir)/$$file 2> /dev/null \\"}, {"sha": "452820a18f66568de9bff833e3fc4b85db603c75", "filename": "libjava/gnu/java/locale/LocaleInformation.java", "status": "added", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/962276267861b61093a222158d78a30871e5d38b/libjava%2Fgnu%2Fjava%2Flocale%2FLocaleInformation.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/962276267861b61093a222158d78a30871e5d38b/libjava%2Fgnu%2Fjava%2Flocale%2FLocaleInformation.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fgnu%2Fjava%2Flocale%2FLocaleInformation.java?ref=962276267861b61093a222158d78a30871e5d38b", "patch": "@@ -0,0 +1,37 @@\n+/* LocaleInformation.java -- Default locale information\n+   Copyright (C) 1998 Free Software Foundation, Inc.\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+ \n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+\n+As a special exception, if you link this library with other files to\n+produce an executable, this library does not by itself cause the\n+resulting executable to be covered by the GNU General Public License.\n+This exception does not however invalidate any other reasons why the\n+executable file might be covered by the GNU General Public License. */\n+\n+\n+package gnu.java.locale;\n+\n+/**\n+  * This is the resource bundle for the default locale, which right now is \n+  * hardcoded to US English.\n+  */\n+public class LocaleInformation extends LocaleInformation_en\n+{\n+}\n+"}, {"sha": "5eea9057cf4c22adfaac6122df6dffc6bf9d31b3", "filename": "libjava/gnu/java/locale/LocaleInformation_de.java", "status": "added", "additions": 220, "deletions": 0, "changes": 220, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/962276267861b61093a222158d78a30871e5d38b/libjava%2Fgnu%2Fjava%2Flocale%2FLocaleInformation_de.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/962276267861b61093a222158d78a30871e5d38b/libjava%2Fgnu%2Fjava%2Flocale%2FLocaleInformation_de.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fgnu%2Fjava%2Flocale%2FLocaleInformation_de.java?ref=962276267861b61093a222158d78a30871e5d38b", "patch": "@@ -0,0 +1,220 @@\n+/* LocaleInformation_de.java -- German locale data\n+   Copyright (C) 1999 Free Software Foundation, Inc.\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+ \n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+\n+As a special exception, if you link this library with other files to\n+produce an executable, this library does not by itself cause the\n+resulting executable to be covered by the GNU General Public License.\n+This exception does not however invalidate any other reasons why the\n+executable file might be covered by the GNU General Public License. */\n+\n+\n+package gnu.java.locale;\n+\n+import java.util.ListResourceBundle;\n+import java.util.Calendar;\n+\n+/**\n+  * This class contains locale data for the German locale\n+  * @author Jochen Hoenicke\n+  */\n+public class LocaleInformation_de extends ListResourceBundle\n+{\n+\n+/*\n+ * This area is used for defining object values\n+ */\n+\n+/**\n+  * This is the set of collation rules used by java.text.RuleBasedCollator \n+  * to sort strings properly.  See the documentation of that class for the \n+  * proper format.\n+  */\n+private static final String collation_rules = \n+  \"-<0,1<2<3<4<5<6<7<8<9<A,a<b,B<c,C<d,D<e,E<f,F<g,G<h,H<i,I<j,J<j,K\" +\n+  \"<l,L<m,M<n,N<o,O<p,P<q,Q<r,R<s,S<t,T<u,U<v,V<w,W<x,X<y,Y,z<Z\" + \n+  \"&ae,\\u00e4&Ae,\\u00c4&oe,\\u00f6&Oe,\\u00d6&ue,\\u00fc&Ue,\\u00dc&ss,\\u00df\";\n+\n+/**\n+  * This is the list of months, fully spelled out\n+  */\n+private static final String[] months = { \"Januar\", \"Februar\", \"M\\u00e4rz\", \n+  \"April\", \"Mai\", \"Juni\", \"Juli\", \"August\", \"September\", \"Oktober\",\n+  \"November\", \"Dezember\", null };\n+\n+/**\n+  * This is the list of abbreviated month names\n+  */\n+private static final String[] shortMonths = { \n+  \"Jan\", \"Feb\", \"M\\u00e4r\", \"Apr\", \"Mai\",\n+  \"Jun\", \"Jul\", \"Aug\", \"Sep\", \"Okt\", \"Nov\", \"Dez\", null \n+};\n+\n+/**\n+  * This is the list of weekdays, fully spelled out\n+  */\n+private static final String[] weekdays = { \n+  null, \"Sonntag\", \"Montag\", \"Dienstag\",\n+  \"Mittwoch\", \"Donnerstag\", \"Freitag\", \"Samstag\" \n+};\n+\n+/**\n+  * This is the list of abbreviated weekdays\n+  */\n+private static final String[] shortWeekdays = { \n+  null, \"So\", \"Mo\", \"Di\", \"Mi\", \"Do\", \"Fr\", \"Sa\" \n+};\n+\n+/**\n+  * This is the list of era identifiers\n+  */\n+private static final String[] eras = { \"v. Chr.\", \"n. Chr.\" };\n+\n+/**\n+  * This is the list of timezone strings.  The JDK appears to include a\n+  * city name as the sixth element.\n+  */\n+private static final String[][] zoneStrings =\n+{\n+  // European time zones.  The city names are a little bit random.\n+  { \"WET\", \"Westeurop\\u00e4ische Zeit\", \"WEZ\", \"Westeurop\\u00e4ische Sommerzeit\", \"WESZ\", \"London\" },\n+  { \"CET\", \"Mitteleurop\\u00e4ische Zeit\", \"MEZ\", \"Mitteleurop\\u00e4ische Sommerzeit\", \"MESZ\", \"Berlin\" },\n+  { \"EET\", \"Osteurop\\u00e4ische Zeit\", \"OEZ\", \"Mitteleurop\\u00e4ische Sommerzeit\", \"OESZ\", \"Istanbul\" },\n+};\n+\n+/**\n+  * This is the DateFormat.SHORT date format\n+  */\n+private static final String shortDateFormat = \"dd.MM.yy\";\n+\n+/**\n+  * This is the DateFormat.MEDIUM format\n+  */\n+private static final String mediumDateFormat = \"d. MMM yy\";\n+\n+/**\n+  * This is the DateFormat.LONG format\n+  */\n+private static final String longDateFormat = \"d. MMMM yyyy\";\n+\n+/**\n+  * This is the DateFormat.FULL format\n+  */\n+private static final String fullDateFormat = \"EEEE, d. MMMM yyyy\";\n+\n+/**\n+  * This is the DateFormat.DEFAULT format\n+  */\n+private static final String defaultDateFormat = \"dd.MM.yy\";\n+\n+/**\n+  * This is the DateFormat.SHORT format\n+  */\n+private static final String shortTimeFormat = \"H:mm\";\n+\n+/**\n+  * This is the DateFormat.MEDIUM format\n+  */\n+private static final String mediumTimeFormat = \"H:mm:ss\";\n+\n+/**\n+  * This is the DateFormat.LONG format\n+  */\n+private static final String longTimeFormat = \"H:mm:ss z\";\n+\n+/**\n+  * This is the DateFormat.FULL format\n+  */\n+private static final String fullTimeFormat = \"H:mm:ss 'Uhr' z\";\n+\n+/**\n+  * This is the DateFormat.DEFAULT format\n+  */\n+private static final String defaultTimeFormat = \"H:mm:ss\";\n+\n+/**\n+  * This is the currency symbol\n+  */\n+private static final String currencySymbol = \"DM\";\n+\n+/**\n+  * This is the international currency symbol. \n+  */\n+private static final String intlCurrencySymbol = \"DEM\";\n+\n+/**\n+  * This is the decimal point.\n+  */\n+private static final String decimalSeparator = \",\";\n+\n+/**\n+  * This is the decimal separator in monetary values.\n+  */\n+private static final String monetarySeparator = \",\";\n+\n+/*************************************************************************/\n+\n+/**\n+  * This is the object array used to hold the keys and values\n+  * for this bundle\n+  */\n+\n+private static final Object[][] contents =\n+{\n+  // For RuleBasedCollator\n+  { \"collation_rules\", collation_rules },\n+  // For SimpleDateFormat/DateFormatSymbols\n+  { \"months\", months },\n+  { \"shortMonths\", shortMonths },\n+  { \"weekdays\", weekdays },\n+  { \"shortWeekdays\", shortWeekdays },\n+  { \"eras\", eras },\n+  { \"zoneStrings\", zoneStrings },\n+  { \"shortDateFormat\", shortDateFormat },\n+  { \"mediumDateFormat\", mediumDateFormat },\n+  { \"longDateFormat\", longDateFormat },\n+  { \"fullDateFormat\", fullDateFormat },\n+  { \"defaultDateFormat\", defaultDateFormat },\n+  { \"shortTimeFormat\", shortTimeFormat },\n+  { \"mediumTimeFormat\", mediumTimeFormat },\n+  { \"longTimeFormat\", longTimeFormat },\n+  { \"fullTimeFormat\", fullTimeFormat },\n+  { \"defaultTimeFormat\", defaultTimeFormat },\n+  // For DecimalFormat/DecimalFormatSymbols\n+  { \"currencySymbol\", currencySymbol },\n+  { \"intlCurrencySymbol\", intlCurrencySymbol },\n+  { \"decimalSeparator\", decimalSeparator },\n+  { \"monetarySeparator\", monetarySeparator },\n+};\n+\n+/*************************************************************************/\n+\n+/**\n+  * This method returns the object array of key, value pairs containing\n+  * the data for this bundle.\n+  *\n+  * @return The key, value information.\n+  */\n+public Object[][]\n+getContents()\n+{\n+  return(contents);\n+}\n+\n+} // class LocaleInformation_de"}, {"sha": "22e7371e52ac1e64cdc688cd008a440028837627", "filename": "libjava/gnu/java/locale/LocaleInformation_en.java", "status": "added", "additions": 332, "deletions": 0, "changes": 332, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/962276267861b61093a222158d78a30871e5d38b/libjava%2Fgnu%2Fjava%2Flocale%2FLocaleInformation_en.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/962276267861b61093a222158d78a30871e5d38b/libjava%2Fgnu%2Fjava%2Flocale%2FLocaleInformation_en.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fgnu%2Fjava%2Flocale%2FLocaleInformation_en.java?ref=962276267861b61093a222158d78a30871e5d38b", "patch": "@@ -0,0 +1,332 @@\n+/* LocaleInformation_en.java -- US English locale data\n+   Copyright (C) 1998, 1999 Free Software Foundation, Inc.\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+ \n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+\n+As a special exception, if you link this library with other files to\n+produce an executable, this library does not by itself cause the\n+resulting executable to be covered by the GNU General Public License.\n+This exception does not however invalidate any other reasons why the\n+executable file might be covered by the GNU General Public License. */\n+\n+\n+package gnu.java.locale;\n+\n+import java.util.ListResourceBundle;\n+import java.util.Calendar;\n+import java.util.Date;\n+\n+/**\n+  * This class contains locale data for the US English locale\n+  */\n+\n+public class LocaleInformation_en extends ListResourceBundle\n+{\n+\n+/*\n+ * This area is used for defining object values\n+ */\n+\n+/**\n+  * This is the set of collation rules used by java.text.RuleBasedCollator \n+  * to sort strings properly.  See the documentation of that class for the \n+  * proper format.\n+  */\n+private static final String collation_rules = \n+  \"-<0,1<2<3<4<5<6<7<8<9A,a<b,B<c,C<d,D<e,E<f,F<g,G<h,H<i,I<j,J<j,K\" +\n+  \"<l,L<m,M<n,N<o,O<p,P<q,Q<r,R<s,S<t,T<u,U<v,V<w,W<x,X<y,Y,z<Z\";\n+\n+/*\n+ * For the followings lists, strings that are subsets of other break strigns\n+ * must be listed first.  For example, if \"\\r\" and \"\\r\\n\" are sequences,\n+ * the \"\\r\" must be first or it will never be used.\n+ */\n+\n+/**\n+  * This is the list of word separator characters used by \n+  * java.text.BreakIterator \n+  */\n+private static final String[] word_breaks = { \" \", \"\\t\", \"\\r\\n\", \"\\n\" }; \n+\n+/**\n+  * This is the list of sentence break sequences used by \n+  * java.text.BreakIterator\n+  */\n+private static final String[] sentence_breaks = { \". \" };\n+\n+/**\n+  * This is the list of potential line break locations.\n+  */\n+private static final String[] line_breaks = { \"\\t\", \"-\", \"\\r\\n\", \n+  \"\\n\", \".  \", \". \", \".\",  \"?  \", \"? \", \"?\",  \"!  \", \"! \", \"!\", \", \", \" \" };\n+\n+/**\n+  * This is the list of months, fully spelled out\n+  */\n+private static final String[] months = { \"January\", \"February\", \"March\", \n+  \"April\", \"May\", \"June\", \"July\", \"August\", \"September\", \"October\",\n+  \"November\", \"December\", null };\n+\n+/**\n+  * This is the list of abbreviated month names\n+  */\n+private static final String[] shortMonths = { \"Jan\", \"Feb\", \"Mar\", \"Apr\", \"May\",\n+  \"Jun\", \"Jul\", \"Aug\", \"Sep\", \"Oct\", \"Nov\", \"Dec\", null };\n+\n+/**\n+  * This is the list of weekdays, fully spelled out\n+  */\n+private static final String[] weekdays = { null, \"Sunday\", \"Monday\", \"Tuesday\",\n+  \"Wednesday\", \"Thursday\", \"Friday\", \"Saturday\" };\n+\n+/**\n+  * This is the list of abbreviated weekdays\n+  */\n+private static final String[] shortWeekdays = { null, \"Sun\", \"Mon\", \"Tue\", \"Wed\",\n+  \"Thu\", \"Fri\", \"Sat\" };\n+\n+/**\n+  * This is the list of AM/PM strings\n+  */\n+private static final String[] ampms = { \"AM\", \"PM\" };\n+\n+/**\n+  * This is the list of era identifiers\n+  */\n+private static final String[] eras = { \"BC\", \"AD\" };\n+\n+/**\n+  * This is the list of timezone strings.  The JDK appears to include a\n+  * city name as the sixth element.\n+  */\n+private static final String[][] zoneStrings =\n+{\n+  { \"EST6EDT\", \"Eastern Standard Time\", \"EST\", \"Eastern Daylight Time\", \"EDT\",\n+    \"New York\" },\n+  { \"EST6\", \"Eastern Standard Time\", \"EST\", \"Eastern Standard Time\", \"EST\",\n+    \"Indianapolis\" },\n+  { \"CST6CDT\", \"Central Standard Time\", \"CST\", \"Central Daylight Time\", \"CDT\",\n+    \"Chicago\" },\n+  { \"MST6MDT\", \"Mountain Standard Time\", \"MST\", \"Mountain Daylight Time\", \n+    \"MDT\", \"Denver\" },\n+  { \"MST6\", \"Mountain Standard Time\", \"MST\", \"Mountain Standard Time\", \"MST\",\n+    \"Phoenix\" },\n+  { \"PST6PDT\", \"Pacific Standard Time\", \"PDT\", \"Pacific Daylight Time\", \"PDT\",\n+    \"San Francisco\" },\n+  { \"AST6ADT\", \"Alaska Standard Time\", \"AST\", \"Alaska Daylight Time\", \"ADT\",\n+    \"Anchorage\" },\n+  { \"HST6HDT\", \"Hawaii Standard Time\", \"HST\", \"Hawaii Daylight Time\", \"HDT\",\n+    \"Honolulu\" },\n+  // European time zones.  The city names are a little bit random.\n+  { \"WET\", \"Western European Time\", \"WET\", \"Western European Savings Time\", \"WEST\", \"London\" },\n+  { \"CET\", \"Central European Time\", \"CET\", \"Central European Savings Time\", \"CEST\", \"Berlin\" },\n+  { \"EET\", \"Eastern European Time\", \"EET\", \"Eastern European Savings Time\", \"EEST\", \"Istanbul\" },\n+};\n+\n+/**\n+  * This is the list of pattern characters for formatting dates\n+  */\n+private static final String localPatternChars = \"GyMdkHmsSEDFwWahKz\"; // Not a mistake!\n+\n+/**\n+  * This is the DateFormat.SHORT date format\n+  */\n+private static final String shortDateFormat = \"M/d/yy\";\n+\n+/**\n+  * This is the DateFormat.MEDIUM format\n+  */\n+private static final String mediumDateFormat = \"dd-MMM-yy\";\n+\n+/**\n+  * This is the DateFormat.LONG format\n+  */\n+private static final String longDateFormat = \"MMMM d, yyyy\";\n+\n+/**\n+  * This is the DateFormat.FULL format\n+  */\n+private static final String fullDateFormat = \"EEEE, MMMM d, yyyy\";\n+\n+/**\n+  * This is the DateFormat.DEFAULT format\n+  */\n+private static final String defaultDateFormat = \"dd-MMM-yy\";\n+\n+/**\n+  * This is the DateFormat.SHORT format\n+  */\n+private static final String shortTimeFormat = \"h:mm a\";\n+\n+/**\n+  * This is the DateFormat.MEDIUM format\n+  */\n+private static final String mediumTimeFormat = \"h:mm:ss a\";\n+\n+/**\n+  * This is the DateFormat.LONG format\n+  */\n+private static final String longTimeFormat = \"h:mm:ss a z\";\n+\n+/**\n+  * This is the DateFormat.FULL format\n+  */\n+private static final String fullTimeFormat = \"h:mm:ss 'o''clock' a z\";\n+\n+/**\n+  * This is the DateFormat.DEFAULT format\n+  */\n+private static final String defaultTimeFormat = \"h:mm:ss a\";\n+\n+/**\n+  * This is the currency symbol\n+  */\n+private static final String currencySymbol = \"$\";\n+\n+/**\n+  * This is the international currency symbol. \n+  */\n+private static final String intlCurrencySymbol = \"US$\";\n+\n+/**\n+  * This is the decimal point.\n+  */\n+private static final String decimalSeparator = \".\";\n+\n+/**\n+  * This is the exponential symbol\n+  */\n+private static final String exponential = \"E\";\n+\n+/**\n+  * This is the char used for digits in format strings\n+  */\n+private static final String digit = \"#\";\n+\n+/**\n+  * This is the grouping separator symbols\n+  */\n+private static final String groupingSeparator = \",\";\n+\n+/**\n+  * This is the symbols for infinity\n+  */\n+private static final String infinity = \"\\u221e\";\n+\n+/**\n+  * This is the symbol for the not a number value\n+  */\n+private static final String NaN = \"\\ufffd\";\n+\n+/**\n+  * This is the minus sign symbol.\n+  */\n+private static final String minusSign = \"-\";\n+\n+/**\n+  * This is the decimal separator in monetary values.\n+  */\n+private static final String monetarySeparator = \".\";\n+\n+/**\n+  * This is the separator between positive and negative subpatterns.\n+  */\n+private static final String patternSeparator = \";\";\n+\n+/**\n+  * This is the percent sign\n+  */\n+private static final String percent = \"%\";\n+\n+/**\n+  * This is the per mille sign\n+  */\n+private static final String perMill = \"\\u2030\";\n+\n+/**\n+  * This is the character for zero.\n+  */\n+private static final String zeroDigit = \"0\";\n+\n+/*************************************************************************/\n+\n+/**\n+  * This is the object array used to hold the keys and values\n+  * for this bundle\n+  */\n+\n+private static final Object[][] contents =\n+{\n+  // For RuleBasedCollator\n+  { \"collation_rules\", collation_rules },\n+  // For BreakIterator\n+  { \"word_breaks\", word_breaks },\n+  { \"sentence_breaks\", sentence_breaks },\n+  { \"line_breaks\", line_breaks },\n+  // For SimpleDateFormat/DateFormatSymbols\n+  { \"months\", months },\n+  { \"shortMonths\", shortMonths },\n+  { \"weekdays\", weekdays },\n+  { \"shortWeekdays\", shortWeekdays },\n+  { \"ampms\", ampms },\n+  { \"eras\", eras },\n+  { \"zoneStrings\", zoneStrings },\n+  { \"localPatternChars\", localPatternChars },\n+  { \"shortDateFormat\", shortDateFormat },\n+  { \"mediumDateFormat\", mediumDateFormat },\n+  { \"longDateFormat\", longDateFormat },\n+  { \"fullDateFormat\", fullDateFormat },\n+  { \"defaultDateFormat\", defaultDateFormat },\n+  { \"shortTimeFormat\", shortTimeFormat },\n+  { \"mediumTimeFormat\", mediumTimeFormat },\n+  { \"longTimeFormat\", longTimeFormat },\n+  { \"fullTimeFormat\", fullTimeFormat },\n+  { \"defaultTimeFormat\", defaultTimeFormat },\n+  // For DecimalFormat/DecimalFormatSymbols\n+  { \"currencySymbol\", currencySymbol },\n+  { \"intlCurrencySymbol\", intlCurrencySymbol },\n+  { \"decimalSeparator\", decimalSeparator },\n+  { \"digit\", digit },\n+  { \"exponential\", exponential },\n+  { \"groupingSeparator\", groupingSeparator },\n+  { \"infinity\", infinity },\n+  { \"NaN\", NaN },\n+  { \"minusSign\", minusSign },\n+  { \"monetarySeparator\", monetarySeparator },\n+  { \"patternSeparator\", patternSeparator },\n+  { \"percent\", percent },\n+  { \"perMill\", perMill },\n+  { \"zeroDigit\", zeroDigit },\n+};\n+\n+/*************************************************************************/\n+\n+/**\n+  * This method returns the object array of key, value pairs containing\n+  * the data for this bundle.\n+  *\n+  * @return The key, value information.\n+  */\n+public Object[][]\n+getContents()\n+{\n+  return(contents);\n+}\n+\n+} // class LocaleInformation_en\n+"}, {"sha": "8b74c5bc7ddd83920ae40d92e544f78be72c5951", "filename": "libjava/gnu/java/locale/LocaleInformation_nl.java", "status": "added", "additions": 338, "deletions": 0, "changes": 338, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/962276267861b61093a222158d78a30871e5d38b/libjava%2Fgnu%2Fjava%2Flocale%2FLocaleInformation_nl.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/962276267861b61093a222158d78a30871e5d38b/libjava%2Fgnu%2Fjava%2Flocale%2FLocaleInformation_nl.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fgnu%2Fjava%2Flocale%2FLocaleInformation_nl.java?ref=962276267861b61093a222158d78a30871e5d38b", "patch": "@@ -0,0 +1,338 @@\n+/* LocaleInformation_nl.java -- Dutch locale data\n+   Copyright (C) 1999 Free Software Foundation, Inc.\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+ \n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+\n+As a special exception, if you link this library with other files to\n+produce an executable, this library does not by itself cause the\n+resulting executable to be covered by the GNU General Public License.\n+This exception does not however invalidate any other reasons why the\n+executable file might be covered by the GNU General Public License. */\n+\n+\n+package gnu.java.locale;\n+\n+import java.util.ListResourceBundle;\n+import java.util.Calendar;\n+import java.util.Date;\n+\n+/**\n+  * This class contains locale data for the Dutch locale\n+  */\n+\n+public class LocaleInformation_nl extends ListResourceBundle\n+{\n+\n+/*\n+ * This area is used for defining object values\n+ */\n+\n+/**\n+  * This is the set of collation rules used by java.text.RuleBasedCollator \n+  * to sort strings properly.  See the documentation of that class for the \n+  * proper format.\n+  * <p>\n+  * This is the same rule as used in the English locale.\n+  */\n+private static final String collation_rules = \n+  \"-<0,1<2<3<4<5<6<7<8<9A,a<b,B<c,C<d,D<e,E<f,F<g,G<h,H<i,I<j,J<j,K\" +\n+  \"<l,L<m,M<n,N<o,O<p,P<q,Q<r,R<s,S<t,T<u,U<v,V<w,W<x,X<y,Y,z<Z\";\n+\n+/*\n+ * For the followings lists, strings that are subsets of other break strings\n+ * must be listed first.  For example, if \"\\r\" and \"\\r\\n\" are sequences,\n+ * the \"\\r\" must be first or it will never be used.\n+ */\n+\n+/**\n+  * This is the list of word separator characters used by \n+  * java.text.BreakIterator \n+  * <p>\n+  * This is the same list as used in the English local\n+  */\n+private static final String[] word_breaks = { \" \", \"\\t\", \"\\r\\n\", \"\\n\" }; \n+\n+/**\n+  * This is the list of sentence break sequences used by \n+  * java.text.BreakIterator\n+  * <p>\n+  * This is the same list as used in the English local\n+  */\n+private static final String[] sentence_breaks = { \". \" };\n+\n+/**\n+  * This is the list of potential line break locations.\n+  * <p>\n+  * This is the same list as used in the English local\n+  */\n+private static final String[] line_breaks = { \"\\t\", \"-\", \"\\r\\n\", \n+  \"\\n\", \".  \", \". \", \".\",  \"?  \", \"? \", \"?\",  \"!  \", \"! \", \"!\", \", \", \" \" };\n+\n+/**\n+  * This is the list of months, fully spelled out\n+  */\n+private static final String[] months = { \"januari\", \"februari\", \"maart\", \n+  \"april\", \"mei\", \"juni\", \"juli\", \"augustus\", \"september\", \"october\",\n+  \"november\", \"december\", null };\n+\n+/**\n+  * This is the list of abbreviated month names\n+  */\n+private static final String[] shortMonths = { \"jan\", \"feb\", \"mrt\", \"apr\", \"mei\",\n+  \"jun\", \"jul\", \"aug\", \"sep\", \"oct\", \"nov\", \"dec\", null };\n+\n+/**\n+  * This is the list of weekdays, fully spelled out\n+  */\n+private static final String[] weekdays = { null, \"zondag\", \"maandag\", \"dinsdag\",\n+  \"woensdag\", \"donderdag\", \"vrijdag\", \"zaterdag\" };\n+\n+/**\n+  * This is the list of abbreviated weekdays\n+  */\n+private static final String[] shortWeekdays = { null, \"zo\", \"ma\", \"di\", \"wo\",\n+  \"do\", \"vr\", \"za\" };\n+\n+/**\n+  * This is the list of AM/PM strings\n+  * <p>\n+  * Is there a real equivalent in Dutch? \"Voormiddag\"/\"Namiddag\"?\n+  * Just using the Latin names for now.\n+  */\n+private static final String[] ampms = { \"AM\", \"PM\" };\n+\n+/**\n+  * This is the list of era identifiers\n+  * <p>\n+  * Is there a real equivalent in Dutch? \"voor Christus\"/\"na Christus\"?\n+  * Just use the Latin/English names for now.\n+  */\n+private static final String[] eras = { \"BC\", \"AD\" };\n+\n+/**\n+  * This is the list of timezone strings.  The JDK appears to include a\n+  * city name as the sixth element.\n+  * XXX - TODO - FIXME - Which timezones should be included here and how are\n+  * they called?\n+  */\n+private static final String[][] zoneStrings =\n+{\n+  // European time zones.  The city names are a little bit random.\n+  { \"WET\", \"West Europese Tijd\", \"WET\", \"West Europese Zomertijd\", \"WEST\", \"London\" },\n+  { \"CET\", \"Centraal Europese Tijd\", \"CET\", \"Centraal Europese Zomertijd\", \"CEST\", \"Amsterdam\" },\n+  { \"EET\", \"Oost Europese Tijd\", \"EET\", \"Oost Europese Zomertijd\", \"EEST\", \"Istanbul\" },\n+};\n+\n+/**\n+  * This is the list of pattern characters for formatting dates\n+  * <p>\n+  * This is the same as the English locale uses: era (G), year (y), month (M),\n+  * month (d), hour from 1-12 (h), hour 0-23 (H), minute (m), second (s),\n+  * millisecond (S), date of week (E), date of year (D),\n+  * day of week in month (F), week in year (w), week in month (W), am/pm (a),\n+  * hour from 1-24 (k), hour from 0-11 (K), time zone (z).\n+  * Why would you use others?\n+  */\n+private static final String localPatternChars = \"GyMdhHmsSEDFwWakKz\"; // Not a mistake!\n+\n+/**\n+  * This is the DateFormat.SHORT date format\n+  */\n+private static final String shortDateFormat = \"dd-MM-yy\";\n+\n+/**\n+  * This is the DateFormat.MEDIUM format\n+  */\n+private static final String mediumDateFormat = \"dd-MMM-yy\";\n+\n+/**\n+  * This is the DateFormat.LONG format\n+  */\n+private static final String longDateFormat = \"dd MMMM yyyy\";\n+\n+/**\n+  * This is the DateFormat.FULL format\n+  */\n+private static final String fullDateFormat = \"EEEE dd MMMM yyyy\";\n+\n+/**\n+  * This is the DateFormat.DEFAULT format\n+  */\n+private static final String defaultDateFormat = mediumDateFormat;\n+\n+/**\n+  * This is the TimeFormat.SHORT format\n+  */\n+private static final String shortTimeFormat = \"HH:mm\";\n+\n+/**\n+  * This is the TimeFormat.MEDIUM format\n+  */\n+private static final String mediumTimeFormat = \"HH:mm:ss\";\n+\n+/**\n+  * This is the TimeFormat.LONG format\n+  */\n+private static final String longTimeFormat = \"HH:mm:ss\";\n+\n+/**\n+  * This is the TimeFormat.FULL format\n+  */\n+private static final String fullTimeFormat = \"HH:mm:ss z\";\n+\n+/**\n+  * This is the TimeFormat.DEFAULT format\n+  */\n+private static final String defaultTimeFormat = shortTimeFormat;\n+\n+/**\n+  * This is the currency symbol\n+  */\n+private static final String currencySymbol = \"fl\";\n+\n+/**\n+  * This is the international currency symbol. \n+  */\n+private static final String intlCurrencySymbol = \"NLG\";\n+\n+/**\n+  * This is the decimal point.\n+  */\n+private static final String decimalSeparator = \",\";\n+\n+/**\n+  * This is the exponential symbol\n+  */\n+private static final String exponential = \"E\";\n+\n+/**\n+  * This is the char used for digits in format strings\n+  */\n+private static final String digit = \"#\";\n+\n+/**\n+  * This is the grouping separator symbols\n+  */\n+private static final String groupingSeparator = \",\";\n+\n+/**\n+  * This is the symbols for infinity\n+  */\n+private static final String infinity = \"\\u221e\";\n+\n+/**\n+  * This is the symbol for the not a number value\n+  */\n+private static final String NaN = \"\\ufffd\";\n+\n+/**\n+  * This is the minus sign symbol.\n+  */\n+private static final String minusSign = \"-\";\n+\n+/**\n+  * This is the decimal separator in monetary values.\n+  */\n+private static final String monetarySeparator = \",\";\n+\n+/**\n+  * This is the separator between positive and negative subpatterns.\n+  */\n+private static final String patternSeparator = \";\";\n+\n+/**\n+  * This is the percent sign\n+  */\n+private static final String percent = \"%\";\n+\n+/**\n+  * This is the per mille sign\n+  */\n+private static final String perMill = \"\\u2030\";\n+\n+/**\n+  * This is the character for zero.\n+  */\n+private static final String zeroDigit = \"0\";\n+\n+/*************************************************************************/\n+\n+/**\n+  * This is the object array used to hold the keys and values\n+  * for this bundle\n+  */\n+\n+private static final Object[][] contents =\n+{\n+  // For RuleBasedCollator\n+  { \"collation_rules\", collation_rules },\n+  // For BreakIterator\n+  { \"word_breaks\", word_breaks },\n+  { \"sentence_breaks\", sentence_breaks },\n+  { \"line_breaks\", line_breaks },\n+  // For SimpleDateFormat/DateFormatSymbols\n+  { \"months\", months },\n+  { \"shortMonths\", shortMonths },\n+  { \"weekdays\", weekdays },\n+  { \"shortWeekdays\", shortWeekdays },\n+  { \"ampms\", ampms },\n+  { \"eras\", eras },\n+  { \"zoneStrings\", zoneStrings },\n+  { \"localPatternChars\", localPatternChars },\n+  { \"shortDateFormat\", shortDateFormat },\n+  { \"mediumDateFormat\", mediumDateFormat },\n+  { \"longDateFormat\", longDateFormat },\n+  { \"fullDateFormat\", fullDateFormat },\n+  { \"defaultDateFormat\", defaultDateFormat },\n+  { \"shortTimeFormat\", shortTimeFormat },\n+  { \"mediumTimeFormat\", mediumTimeFormat },\n+  { \"longTimeFormat\", longTimeFormat },\n+  { \"fullTimeFormat\", fullTimeFormat },\n+  { \"defaultTimeFormat\", defaultTimeFormat },\n+  // For DecimalFormat/DecimalFormatSymbols\n+  { \"currencySymbol\", currencySymbol },\n+  { \"intlCurrencySymbol\", intlCurrencySymbol },\n+  { \"decimalSeparator\", decimalSeparator },\n+  { \"digit\", digit },\n+  { \"exponential\", exponential },\n+  { \"groupingSeparator\", groupingSeparator },\n+  { \"infinity\", infinity },\n+  { \"NaN\", NaN },\n+  { \"minusSign\", minusSign },\n+  { \"monetarySeparator\", monetarySeparator },\n+  { \"patternSeparator\", patternSeparator },\n+  { \"percent\", percent },\n+  { \"perMill\", perMill },\n+  { \"zeroDigit\", zeroDigit },\n+};\n+\n+/*************************************************************************/\n+\n+/**\n+  * This method returns the object array of key, value pairs containing\n+  * the data for this bundle.\n+  *\n+  * @return The key, value information.\n+  */\n+public Object[][]\n+getContents()\n+{\n+  return(contents);\n+}\n+\n+} // class LocaleInformation_nl"}, {"sha": "f0976054c632909f31a779cf0da2adee024914e3", "filename": "libjava/java/text/SimpleDateFormat.java", "status": "modified", "additions": 45, "deletions": 17, "changes": 62, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/962276267861b61093a222158d78a30871e5d38b/libjava%2Fjava%2Ftext%2FSimpleDateFormat.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/962276267861b61093a222158d78a30871e5d38b/libjava%2Fjava%2Ftext%2FSimpleDateFormat.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Ftext%2FSimpleDateFormat.java?ref=962276267861b61093a222158d78a30871e5d38b", "patch": "@@ -62,8 +62,7 @@ public FieldSizePair(int f, int s) {\n \n   private transient Vector tokens;\n   private DateFormatSymbols formatData;  // formatData\n-  private Date defaultCenturyStart = \n-    new Date(System.currentTimeMillis() - (80*365*24*60*60*1000));\n+  private Date defaultCenturyStart = computeCenturyStart ();\n   private String pattern;\n   private int serialVersionOnStream = 1; // 0 indicates JDK1.1.3 or earlier\n   private static final long serialVersionUID = 4774881970558875024L;\n@@ -79,8 +78,7 @@ private void readObject(ObjectInputStream stream)\n     stream.defaultReadObject();\n     if (serialVersionOnStream < 1)\n       {\n-        defaultCenturyStart =\n-\t  new Date(System.currentTimeMillis() - (80*365*24*60*60*1000));\n+        defaultCenturyStart = computeCenturyStart ();\n \tserialVersionOnStream = 1;\n       }\n \n@@ -161,11 +159,14 @@ public SimpleDateFormat()\n     super();\n     Locale locale = Locale.getDefault();\n     calendar = new GregorianCalendar(locale);\n+    calendar.clear ();\n     tokens = new Vector();\n     formatData = new DateFormatSymbols(locale);\n-    pattern = formatData.dateFormats[DEFAULT]+' '+formatData.timeFormats[DEFAULT];\n+    pattern = (formatData.dateFormats[DEFAULT] + ' '\n+\t       + formatData.timeFormats[DEFAULT]);\n     compileFormat(pattern);\n     numberFormat = NumberFormat.getInstance(locale);\n+    numberFormat.setGroupingUsed (false);\n   }\n   \n   /**\n@@ -185,20 +186,24 @@ public SimpleDateFormat(String pattern, Locale locale)\n   {\n     super();\n     calendar = new GregorianCalendar(locale);\n+    calendar.clear ();\n     tokens = new Vector();\n     formatData = new DateFormatSymbols(locale);\n     compileFormat(pattern);\n     this.pattern = pattern;\n     numberFormat = NumberFormat.getInstance(locale);\n+    numberFormat.setGroupingUsed (false);\n   }\n \n   /**\n    * Creates a date formatter using the specified pattern. The\n    * specified DateFormatSymbols will be used when formatting.\n    */\n-  public SimpleDateFormat(String pattern, DateFormatSymbols formatData) {\n+  public SimpleDateFormat(String pattern, DateFormatSymbols formatData)\n+  {\n     super();\n     calendar = new GregorianCalendar();\n+    calendar.clear ();\n     // FIXME: XXX: Is it really necessary to set the timezone?\n     // The Calendar constructor is supposed to take care of this.\n     calendar.setTimeZone(TimeZone.getDefault());\n@@ -207,6 +212,7 @@ public SimpleDateFormat(String pattern, DateFormatSymbols formatData) {\n     compileFormat(pattern);\n     this.pattern = pattern;\n     numberFormat = NumberFormat.getInstance();\n+    numberFormat.setGroupingUsed (false);\n   }\n \n   // What is the difference between localized and unlocalized?  The\n@@ -377,7 +383,8 @@ public boolean equals(Object o)\n    * appending to the specified StringBuffer.  The input StringBuffer\n    * is returned as output for convenience.\n    */\n-  public StringBuffer format(Date date, StringBuffer buffer, FieldPosition pos) {\n+  public StringBuffer format(Date date, StringBuffer buffer, FieldPosition pos)\n+  {\n     String temp;\n     Calendar theCalendar = (Calendar) calendar.clone();\n     theCalendar.setTime(date);\n@@ -507,7 +514,10 @@ public Date parse (String dateStr, ParsePosition pos)\n     int fmt_index = 0;\n     int fmt_max = pattern.length();\n \n-    calendar.clear();\n+    // We copy the Calendar because if we don't we will modify it and\n+    // then this.equals() will no longer have the desired result.\n+    Calendar theCalendar = (Calendar) calendar.clone ();\n+    theCalendar.clear();\n     int quote_start = -1;\n     for (; fmt_index < fmt_max; ++fmt_index)\n       {\n@@ -553,7 +563,6 @@ public Date parse (String dateStr, ParsePosition pos)\n \tboolean is_numeric = true;\n \tString[] match = null;\n \tint offset = 0;\n-\tint zone_number = 0;\n \tswitch (ch)\n \t  {\n \t  case 'd':\n@@ -626,6 +635,7 @@ public Date parse (String dateStr, ParsePosition pos)\n \t    // We need a special case for the timezone, because it\n \t    // uses a different data structure than the other cases.\n \t    is_numeric = false;\n+\t    // We don't actually use this; see below.\n \t    calendar_field = Calendar.DST_OFFSET;\n \t    String[][] zoneStrings = formatData.getZoneStrings();\n \t    int zoneCount = zoneStrings.length;\n@@ -642,11 +652,11 @@ public Date parse (String dateStr, ParsePosition pos)\n \t\t  }\n \t\tif (k != strings.length)\n \t\t  {\n-\t\t    if (k > 2)\n-\t\t      ;\t\t// FIXME: dst.\n-\t\t    zone_number = 0; // FIXME: dst.\n-\t\t    // FIXME: raw offset to SimpleTimeZone const.\n-\t\t    calendar.setTimeZone(new SimpleTimeZone (1, strings[0]));\n+\t\t    found_zone = true;\n+\t\t    TimeZone tz = TimeZone.getTimeZone (strings[0]);\n+\t\t    theCalendar.setTimeZone (tz);\n+\t\t    theCalendar.clear (Calendar.DST_OFFSET);\n+\t\t    theCalendar.clear (Calendar.ZONE_OFFSET);\n \t\t    pos.setIndex(index + strings[k].length());\n \t\t    break;\n \t\t  }\n@@ -690,20 +700,38 @@ else if (match != null)\n \t    value = i;\n \t  }\n \telse\n-\t  value = zone_number;\n+\t  value = 0;\n \n \t// Assign the value and move on.\n-\tcalendar.set(calendar_field, value);\n+\tif (calendar_field != Calendar.DST_OFFSET)\n+\t  theCalendar.set(calendar_field, value);\n       }\n \n     try\n       {\n-        return calendar.getTime();\n+        return theCalendar.getTime();\n       }\n     catch (IllegalArgumentException x)\n       {\n         pos.setErrorIndex(pos.getIndex());\n \treturn null;\n       }\n   }\n+\n+  // Compute the start of the current century as defined by\n+  // get2DigitYearStart.\n+  private Date computeCenturyStart ()\n+  {\n+    // Compute the current year.  We assume a year has 365 days.  Then\n+    // compute 80 years ago, and finally reconstruct the number of\n+    // milliseconds.  We do this computation in this strange way\n+    // because it lets us easily truncate the milliseconds, seconds,\n+    // etc, which don't matter and which confuse\n+    // SimpleDateFormat.equals().\n+    long now = System.currentTimeMillis ();\n+    now /= 365L * 24L * 60L * 60L * 1000L;\n+    now -= 80;\n+    now *= 365L * 24L * 60L * 60L * 1000L;\n+    return new Date (now);\n+  }\n }"}, {"sha": "17f4c7756e597a1119e8278d3f9b7912be2ed3ba", "filename": "libjava/java/util/Calendar.java", "status": "modified", "additions": 51, "deletions": 14, "changes": 65, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/962276267861b61093a222158d78a30871e5d38b/libjava%2Fjava%2Futil%2FCalendar.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/962276267861b61093a222158d78a30871e5d38b/libjava%2Fjava%2Futil%2FCalendar.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Futil%2FCalendar.java?ref=962276267861b61093a222158d78a30871e5d38b", "patch": "@@ -1,5 +1,5 @@\n /* java.util.Calendar\n-   Copyright (C) 1998, 1999, 2000 Free Software Foundation, Inc.\n+   Copyright (C) 1998, 1999, 2000, 2001 Free Software Foundation, Inc.\n \n This file is part of GNU Classpath.\n \n@@ -54,7 +54,7 @@\n  *\n  * When computing the date from time fields, it may happen, that there\n  * are either two few fields set, or some fields are inconsistent.  This\n- * cases will handled in a calender specific way.  Missing fields are\n+ * cases will handled in a calendar specific way.  Missing fields are\n  * replaced by the fields of the epoch: 1970 January 1 00:00. <br>\n  *\n  * To understand, how the day of year is computed out of the fields\n@@ -356,7 +356,7 @@ public abstract class Calendar implements Serializable, Cloneable\n   private static final String bundleName = \"gnu.java.locale.Calendar\";\n \n   /**\n-   * Constructs a new Calender with the default time zone and the default\n+   * Constructs a new Calendar with the default time zone and the default\n    * locale.\n    */\n   protected Calendar()\n@@ -365,7 +365,7 @@ protected Calendar()\n   }\n \n   /**\n-   * Constructs a new Calender with the given time zone and the given\n+   * Constructs a new Calendar with the given time zone and the given\n    * locale.\n    * @param zone a time zone.\n    * @param locale a locale.\n@@ -483,7 +483,7 @@ public final Date getTime()\n   }\n \n   /**\n-   * Sets this Calender's time to the given Date.  All time fields\n+   * Sets this Calendar's time to the given Date.  All time fields\n    * are invalidated by this method.\n    */\n   public final void setTime(Date date)\n@@ -503,7 +503,7 @@ protected long getTimeInMillis()\n   }\n \n   /**\n-   * Sets this Calender's time to the given Time.  All time fields\n+   * Sets this Calendar's time to the given Time.  All time fields\n    * are invalidated by this method.\n    * @param time the time in milliseconds since the epoch\n    */\n@@ -522,6 +522,9 @@ protected void setTimeInMillis(long time)\n    */\n   public final int get(int field)\n   {\n+    // If the requested field is invalid, force all fields to be recomputed.\n+    if (!isSet[field])\n+      areFieldsSet = false;\n     complete();\n     return fields[field];\n   }\n@@ -551,6 +554,29 @@ public final void set(int field, int value)\n     isTimeSet = false;\n     fields[field] = value;\n     isSet[field] = true;\n+    switch (field)\n+      {\n+      case YEAR:\n+      case MONTH:\n+      case DATE:\n+\tisSet[WEEK_OF_YEAR] = false;\n+\tisSet[DAY_OF_YEAR] = false;\n+\tisSet[WEEK_OF_MONTH] = false;\n+\tisSet[DAY_OF_WEEK] = false;\n+\tisSet[DAY_OF_WEEK_IN_MONTH] = false;\n+\tbreak;\n+      case AM_PM:\n+\tisSet[HOUR_OF_DAY] = false;\n+\tbreak;\n+      case HOUR_OF_DAY:\n+\tisSet[AM_PM] = false;\n+\tisSet[HOUR] = false;\n+\tbreak;\n+      case HOUR:\n+\tisSet[AM_PM] = false;\n+\tisSet[HOUR_OF_DAY] = false;\n+\tbreak;\n+      }\n   }\n \n   /**\n@@ -568,6 +594,11 @@ public final void set(int year, int month, int date)\n     fields[MONTH] = month;\n     fields[DATE] = date;\n     isSet[YEAR] = isSet[MONTH] = isSet[DATE] = true;\n+    isSet[WEEK_OF_YEAR] = false;\n+    isSet[DAY_OF_YEAR] = false;\n+    isSet[WEEK_OF_MONTH] = false;\n+    isSet[DAY_OF_WEEK] = false;\n+    isSet[DAY_OF_WEEK_IN_MONTH] = false;\n   }\n \n   /**\n@@ -584,6 +615,8 @@ public final void set(int year, int month, int date, int hour, int minute)\n     fields[HOUR_OF_DAY] = hour;\n     fields[MINUTE] = minute;\n     isSet[HOUR_OF_DAY] = isSet[MINUTE] = true;\n+    isSet[AM_PM] = false;\n+    isSet[HOUR] = false;\n   }\n \n   /**\n@@ -611,7 +644,10 @@ public final void clear()\n     isTimeSet = false;\n     areFieldsSet = false;\n     for (int i = 0; i < FIELD_COUNT; i++)\n-      isSet[i] = false;\n+      {\n+\tisSet[i] = false;\n+\tfields[i] = 0;\n+      }\n   }\n \n   /**\n@@ -623,6 +659,7 @@ public final void clear(int field)\n     isTimeSet = false;\n     areFieldsSet = false;\n     isSet[field] = false;\n+    fields[field] = 0;\n   }\n \n   /**\n@@ -647,7 +684,7 @@ protected void complete()\n   }\n \n   /**\n-   * Compares the given calender with this.  \n+   * Compares the given calendar with this.  \n    * @param o the object to that we should compare.\n    * @return true, if the given object is a calendar, that represents\n    * the same time (but doesn't neccessary have the same fields).\n@@ -670,10 +707,10 @@ public int hashCode()\n   }\n \n   /**\n-   * Compares the given calender with this.  \n+   * Compares the given calendar with this.  \n    * @param o the object to that we should compare.\n    * @return true, if the given object is a calendar, and this calendar\n-   * represents a smaller time than the calender o.\n+   * represents a smaller time than the calendar o.\n    * @exception ClassCastException if o is not an calendar.\n    * @since JDK1.2 you don't need to override this method\n    */\n@@ -683,10 +720,10 @@ public boolean before(Object o)\n   }\n \n   /**\n-   * Compares the given calender with this.  \n+   * Compares the given calendar with this.  \n    * @param o the object to that we should compare.\n    * @return true, if the given object is a calendar, and this calendar\n-   * represents a bigger time than the calender o.\n+   * represents a bigger time than the calendar o.\n    * @exception ClassCastException if o is not an calendar.\n    * @since JDK1.2 you don't need to override this method\n    */\n@@ -866,7 +903,7 @@ public int getMinimalDaysInFirstWeek()\n    * @since jdk1.2\n    */\n   // FIXME: XXX: Not abstract in JDK 1.2.\n-  // public abstract int getActualMinimum(int field);\n+  public abstract int getActualMinimum(int field);\n \n   /**\n    * Gets the actual maximum value that is allowed for the specified field.\n@@ -876,7 +913,7 @@ public int getMinimalDaysInFirstWeek()\n    * @since jdk1.2\n    */\n   // FIXME: XXX: Not abstract in JDK 1.2.\n-  // public abstract int getActualMaximum(int field);\n+  public abstract int getActualMaximum(int field);\n \n   /**\n    * Return a clone of this object."}, {"sha": "912efdf7eb8473e0b48a4d0e35c472cd5cc0bad8", "filename": "libjava/java/util/GregorianCalendar.java", "status": "modified", "additions": 990, "deletions": 184, "changes": 1174, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/962276267861b61093a222158d78a30871e5d38b/libjava%2Fjava%2Futil%2FGregorianCalendar.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/962276267861b61093a222158d78a30871e5d38b/libjava%2Fjava%2Futil%2FGregorianCalendar.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Futil%2FGregorianCalendar.java?ref=962276267861b61093a222158d78a30871e5d38b", "patch": "@@ -1,265 +1,1071 @@\n-/* Copyright (C) 1998, 1999, 2000  Free Software Foundation\n+/* java.util.GregorianCalendar\n+   Copyright (C) 1998, 1999, 2001 Free Software Foundation, Inc.\n \n-   This file is part of libgcj.\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+\n+As a special exception, if you link this library with other files to\n+produce an executable, this library does not by itself cause the\n+resulting executable to be covered by the GNU General Public License.\n+This exception does not however invalidate any other reasons why the\n+executable file might be covered by the GNU General Public License. */\n \n-This software is copyrighted work licensed under the terms of the\n-Libgcj License.  Please consult the file \"LIBGCJ_LICENSE\" for\n-details.  */\n \n package java.util;\n \n /**\n- * @author Per Bothner <bothner@cygnus.com>\n- * @date October 24, 1998.\n- */\n-\n-/* Written using \"Java Class Libraries\", 2nd edition, ISBN 0-201-31002-3,\n- * and \"The Java Language Specification\", ISBN 0-201-63451-1.\n- * Status:  \"leniency\" is not handled, and neither is roll-over in\n- *   add and roll.  This is partly because of unclear specification.\n- *   hashCode has no spec.\n+ * This class represents the Gregorian calendar, that is used in most\n+ * countries all over the world.  It does also handle the Julian calendar\n+ * for dates smaller than the date of the change to the Gregorian calendar.\n+ * This change date is different from country to country, you can set it with\n+ * <code>setGregorianChange</code>\n+ *\n+ * The Gregorian calendar differs from the Julian calendar by a different\n+ * leap year rule (no leap year every 100 years, except if year is divisible\n+ * by 400).  The non existing days that were omited when the change took\n+ * place are interpreted as gregorian date\n+ *\n+ * There are to eras available for the Gregorian calendar, namely BC and AD.\n+ *\n+ * @see Calendar\n+ * @see TimeZone\n  */\n-\n-public class GregorianCalendar extends Calendar {\n+public class GregorianCalendar extends Calendar\n+{\n+  /**\n+   * Constant representing the era BC (before Christ).\n+   */\n   public static final int BC = 0;\n+  \n+  /**\n+   * Constant representing the era AD (Anno Domini).\n+   */\n   public static final int AD = 1;\n \n-  // The fields are as specified in Sun's \"Serialized Form\"\n-  // in the JDK 1.2 beta 4 API specification.\n-  // Value from a simple test program (getGregorianChange.getTime()).\n-  long gregorianCutover = -12219292800000L;\n-\n-  private final static int[] mins = {\n-    0 /* ERA */,\n-    1 /* YEAR */,\n-    0 /* MONTH */,\n-    0 /* WEEK_OF_YEAR */,\n-    0 /* WEEK_OF_MONTH */,\n-    1 /* DATE */,\n-    1 /* DAY_OF_YEAR */,\n-    1 /* DAY_OF_WEEK */,\n-    -1 /* DAY_OF_WEEK_IN_MONTH */,\n-    0 /* AM_PM */,\n-    0 /* HOUR */,\n-    0 /* HOUR_OF_DAY */,\n-    0 /* MINUTE */,\n-    0 /* SECOND */,\n-    0 /* MILLISECOND */,\n-    -43200000 /* ZONE_OFFSET */,\n-    0 /* DST_OFFSET */\n-  };\n-\n-  private final static int[] maxs = {\n-    1 /* ERA */,\n-    5000000 /* YEAR */,\n-    11 /* MONTH */,\n-    54 /* WEEK_OF_YEAR */,\n-    6 /* WEEK_OF_MONTH */,\n-    31 /* DATE */,\n-    366 /* DAY_OF_YEAR */,\n-    7 /* DAY_OF_WEEK */,\n-    6 /* DAY_OF_WEEK_IN_MONTH */,\n-    1 /* AM_PM */,\n-    12 /* HOUR */,\n-    23 /* HOUR_OF_DAY */,\n-    59 /* MINUTE */,\n-    59 /* SECOND */,\n-    999 /* MILLISECOND */,\n-    43200000 /* ZONE_OFFSET */,\n-    3600000 /* DST_OFFSET */\n-  };\n-\n-  private final static int[] leastMaximums = {\n-    1 /* ERA */,\n-    5000000 /* YEAR */,\n-    11 /* MONTH */,\n-    53 /* WEEK_OF_YEAR */,\n-    6 /* WEEK_OF_MONTH */,\n-    28 /* DATE */,\n-    365 /* DAY_OF_YEAR */,\n-    7 /* DAY_OF_WEEK */,\n-    4 /* DAY_OF_WEEK_IN_MONTH */,\n-    1 /* AM_PM */,\n-    11 /* HOUR */,\n-    23 /* HOUR_OF_DAY */,\n-    59 /* MINUTE */,\n-    59 /* SECOND */,\n-    999 /* MILLISECOND */,\n-    43200000 /* ZONE_OFFSET */,\n-    3600000 /* DST_OFFSET */\n-  };\n-\n-  private static final long serialVersionUID = -8125100834729963327L;\n-\n-  public GregorianCalendar ()\n+  /**\n+   * The point at which the Gregorian calendar rules were used.\n+   * This is locale dependent; the default for most catholic\n+   * countries is midnight (UTC) on October 5, 1582 (Julian),\n+   * or October 15, 1582 (Gregorian).\n+   */\n+  private long gregorianCutover;\n+\n+  static final long serialVersionUID = -8125100834729963327L;\n+\n+  /**\n+   * The name of the resource bundle.\n+   */\n+  private static final String bundleName = \"gnu.java.locale.Calendar\";\n+\n+  /**\n+   * Constructs a new GregorianCalender representing the current\n+   * time, using the default time zone and the default locale.  \n+   */\n+  public GregorianCalendar()\n+  {\n+    this(TimeZone.getDefault(), Locale.getDefault());\n+  }\n+  \n+  /**\n+   * Constructs a new GregorianCalender representing the current\n+   * time, using the specified time zone and the default locale.  \n+   * @param zone a time zone.\n+   */\n+  public GregorianCalendar(TimeZone zone)\n+  {\n+    this(zone, Locale.getDefault());\n+  }\n+  \n+  /**\n+   * Constructs a new GregorianCalender representing the current\n+   * time, using the default time zone and the specified locale.  \n+   * @param locale a locale.\n+   */\n+  public GregorianCalendar(Locale locale)\n+  {\n+    this(TimeZone.getDefault(), locale);\n+  }\n+\n+  /**\n+   * Constructs a new GregorianCalender representing the current\n+   * time with the given time zone and the given locale.\n+   * @param zone a time zone.  \n+   * @param locale a locale.  \n+   */\n+  public GregorianCalendar(TimeZone zone, Locale locale)\n+  {\n+    super(zone, locale);\n+    ResourceBundle rb = ResourceBundle.getBundle(bundleName, locale);\n+    gregorianCutover = ((Date) rb.getObject(\"gregorianCutOver\")).getTime();\n+    time = System.currentTimeMillis();\n+    isTimeSet = true;\n+    areFieldsSet = false;\n+  }\n+\n+  /**\n+   * Constructs a new GregorianCalendar representing midnight on the\n+   * given date with the default time zone and locale.\n+   * @param year corresponds to the YEAR time field.\n+   * @param month corresponds to the MONTH time field.\n+   * @param day corresponds to the DAY time field.\n+   */\n+  public GregorianCalendar(int year, int month, int day)\n+  {\n+    super();\n+    set(year, month, day);\n+  }\n+\n+  /**\n+   * Constructs a new GregorianCalendar representing midnight on the\n+   * given date with the default time zone and locale.\n+   * @param year corresponds to the YEAR time field.\n+   * @param month corresponds to the MONTH time field.\n+   * @param day corresponds to the DAY time field.\n+   * @param hour corresponds to the HOUR_OF_DAY time field.\n+   * @param minute corresponds to the MINUTE time field.\n+   */\n+  public GregorianCalendar(int year, int month, int day, int hour, int minute)\n   {\n-    this(TimeZone.getDefault (), Locale.getDefault ());\n+    super();\n+    set(year, month, day, hour, minute);\n   }\n \n-  public GregorianCalendar (TimeZone zone)\n+  /**\n+   * Constructs a new GregorianCalendar representing midnight on the\n+   * given date with the default time zone and locale.\n+   * @param year corresponds to the YEAR time field.\n+   * @param month corresponds to the MONTH time field.\n+   * @param day corresponds to the DAY time field.\n+   * @param hour corresponds to the HOUR_OF_DAY time field.\n+   * @param minute corresponds to the MINUTE time field.\n+   * @param second corresponds to the SECOND time field.\n+   */\n+  public GregorianCalendar(int year, int month, int day,\n+\t\t\t   int hour, int minute, int second)\n   {\n-    this (zone, Locale.getDefault ());\n+    super();\n+    set(year, month, day, hour, minute, second);\n   }\n \n-  public GregorianCalendar (Locale locale)\n+  /**\n+   * Sets the date of the switch from Julian dates to Gregorian dates.\n+   * You can use <code>new Date(Long.MAX_VALUE)</code> to use a pure\n+   * Julian calendar, or <code>Long.MIN_VALUE</code> for a pure Gregorian\n+   * calendar.\n+   * @param date the date of the change.\n+   */\n+  public void setGregorianChange(Date date)\n   {\n-    this (TimeZone.getDefault (), locale);\n+    gregorianCutover = date.getTime();\n   }\n \n-  public GregorianCalendar (TimeZone zone, Locale locale)\n+  /**\n+   * Gets the date of the switch from Julian dates to Gregorian dates.\n+   * @return the date of the change.\n+   */\n+  public final Date getGregorianChange(Date date)\n   {\n-    super (zone, locale);\n-    setDefaultTime ();\n+    return new Date(gregorianCutover);\n   }\n \n-  public GregorianCalendar (int year, int month, int date)\n+  /**\n+   * Determines if the given year is a leap year.  The result is\n+   * undefined if the gregorian change took place in 1800, so that\n+   * the end of february is skiped and you give that year\n+   * (well...).<br>\n+   *\n+   * The year should be positive and you can't give an ERA.  But\n+   * remember that before 4 BC there wasn't a consistent leap year\n+   * rule, so who cares.\n+   *\n+   * @param year a year use nonnegative value for BC.\n+   * @return true, if the given year is a leap year, false otherwise.  */\n+  public boolean isLeapYear(int year)\n   {\n-    this();\n-    set (year, month, date, 0, 0, 0);\n+    if ((year & 3) != 0)\n+      // Only years divisible by 4 can be leap years\n+      return false;\n+\n+    // compute the linear day of the 29. February of that year.\n+    // The 13 is the number of days, that were omitted in the Gregorian\n+    // Calender until the epoch.\n+    int julianDay = (((year-1) * (365*4+1)) >> 2) + (31+29 - \n+        (((1970-1) * (365*4+1)) / 4 + 1 - 13));\n+    \n+    // If that day is smaller than the gregorianChange the julian\n+    // rule applies:  This is a leap year since it is divisible by 4.\n+    if (julianDay * (24 * 60 * 60 * 1000L) < gregorianCutover)\n+      return true;\n+\n+    return ((year % 100) != 0 || (year % 400) == 0);\n+  }\n+\n+  /**\n+   * Get the linear time in milliseconds since the epoch.  If you\n+   * specify a nonpositive year it is interpreted as BC as\n+   * following: 0 is 1 BC, -1 is 2 BC and so on.  The date is\n+   * interpreted as gregorian if the change occured before that date.\n+   *\n+   * @param year the year of the date.\n+   * @param dayOfYear the day of year of the date; 1 based.\n+   * @param millis the millisecond in that day.\n+   * @return the days since the epoch, may be negative.  */\n+  private long getLinearTime(int year, int dayOfYear, int millis)\n+  {\n+    // The 13 is the number of days, that were omitted in the Gregorian\n+    // Calender until the epoch.\n+    // We shift right by 2 instead of dividing by 4, to get correct\n+    // results for negative years (and this is even more efficient).\n+    int julianDay = ((year * (365 * 4 + 1)) >> 2) + dayOfYear -\n+      ((1970 * (365 * 4 + 1)) / 4 + 1 - 13);\n+    long time = julianDay * (24 * 60 * 60 * 1000L) + millis;\n+\n+    if (time >= gregorianCutover)\n+      {\n+\t// subtract the days that are missing in gregorian calendar\n+\t// with respect to julian calendar.\n+\t//\n+\t// Okay, here we rely on the fact that the gregorian\n+\t// calendar was introduced in the AD era.  This doesn't work\n+\t// with negative years.\n+\t//\n+\t// The additional leap year factor accounts for the fact that\n+\t// a leap day is not seen on Jan 1 of the leap year.\n+\tint gregOffset = (year / 400) - (year / 100) + 2;\n+\tif (isLeapYear (year, true) && dayOfYear < 31 + 29)\n+\t  --gregOffset;\n+\ttime += gregOffset * (24 * 60 * 60 * 1000L);\n+      }\n+    return time;\n   }\n \n-  public GregorianCalendar (int year, int month, int date,\n-\t\t\t    int hour, int minute)\n+  private int getWeekDay(int year, int dayOfYear)\n   {\n-    this();\n-    set (year, month, date, hour, minute, 0);\n+    int day =\n+      (int) (getLinearTime(year, dayOfYear, 0) / (24 * 60 * 60 * 1000L));\n+\n+    // The epoch was a thursday.\n+    int weekday = (day + THURSDAY) % 7;\n+    if (weekday <= 0)\n+      weekday += 7;\n+    return weekday;\n   }\n \n-  public GregorianCalendar (int year, int month, int date,\n-\t\t\t    int hour, int minute, int second)\n+  /**\n+   * Calculate the dayOfYear from the fields array.  \n+   * The relativeDays is used, to account for weeks that begin before\n+   * the gregorian change and end after it.<br>\n+   *\n+   * We return two values, the first is used to determine, if we\n+   * should use Gregorian calendar or Julian calendar, in case of\n+   * the change year, the second is a relative day after the given\n+   * day.  This is necessary for week calculation in the year in\n+   * which gregorian change occurs. <br>\n+   *\n+   * @param year the year, negative for BC.\n+   * @return an array of two int values, the first containing a reference\n+   * day of current year, the second a relative count since this reference\n+   * day.  */\n+  private int[] getDayOfYear(int year)\n   {\n-    this();\n-    set (year, month, date, hour, minute, second);\n+    if (isSet[MONTH])\n+      {\n+\tint dayOfYear;\n+\tif (fields[MONTH] > FEBRUARY)\n+\t  {\n+\n+\t    // The months after February are regular:\n+\t    // 9 is an offset found by try and error.\n+\t    dayOfYear = (fields[MONTH] * (31 + 30 + 31 + 30 + 31) - 9) / 5;\n+\t    if (isLeapYear(year))\n+\t      dayOfYear++;\n+\t  }\n+\telse\n+\t    dayOfYear = 31 * fields[MONTH];\n+\n+\tif (isSet[DAY_OF_MONTH])\n+\t  {\n+\t    return new int[]\n+\t    {\n+\t    dayOfYear + fields[DAY_OF_MONTH], 0};\n+\t  }\n+\tif (isSet[WEEK_OF_MONTH] && isSet[DAY_OF_WEEK])\n+\t  {\n+\t    // the weekday of the first day in that month is:\n+\t    int weekday = getWeekDay(year, ++dayOfYear);\n+\n+\t    return new int[]\n+\t    {\n+\t      dayOfYear,\n+\t\t// the day of week in the first week\n+\t\t// (weeks starting on sunday) is:\n+\t      fields[DAY_OF_WEEK] - weekday +\n+\t\t// Now jump to the right week and correct the possible\n+\t\t// error made by assuming sunday is the first week day.\n+\t      7 * (fields[WEEK_OF_MONTH]\n+\t\t   + (fields[DAY_OF_WEEK] < getFirstDayOfWeek()? 0 : -1)\n+\t\t   + (weekday < getFirstDayOfWeek()? -1 : 0))};\n+\t  }\n+\tif (isSet[DAY_OF_WEEK] && isSet[DAY_OF_WEEK_IN_MONTH])\n+\t  {\n+\t    // the weekday of the first day in that month is:\n+\t    int weekday = getWeekDay(year, ++dayOfYear);\n+\t    return new int[] { \n+\t\t  dayOfYear,\n+\t\t  fields[DAY_OF_WEEK] - weekday +\n+\t\t  7 * (fields[DAY_OF_WEEK_IN_MONTH]\n+\t\t       + (fields[DAY_OF_WEEK] < weekday ? 0 : -1))};\n+\t  }\n+      }\n+\n+    // MONTH + something did not succeed.\n+    if (isSet[DAY_OF_YEAR])\n+      {\n+\treturn new int[] {0, fields[DAY_OF_YEAR]};\n+      }\n+      \n+    if (isSet[DAY_OF_WEEK] && isSet[WEEK_OF_YEAR])\n+      {\n+\tint dayOfYear = getMinimalDaysInFirstWeek();\n+\t// the weekday of the day, that begins the first week \n+\t// in that year is:\n+\tint weekday = getWeekDay(year, dayOfYear);\n+\n+\treturn new int[] { \n+\t    dayOfYear,\n+\t      // the day of week in the first week\n+\t      // (weeks starting on sunday) is:\n+\t    fields[DAY_OF_WEEK] - weekday\n+\t      // Now jump to the right week and correct the possible\n+\t      // error made by assuming sunday is the first week day.\n+\t    + 7 * (fields[WEEK_OF_YEAR]\n+\t\t   + (fields[DAY_OF_WEEK] < getFirstDayOfWeek()? 0 : -1)\n+\t\t   + (weekday < getFirstDayOfWeek()? -1 : 0))};\n+      }\n+\n+    // As last resort return Jan, 1st.\n+    return new int[] {1, 0};\n   }\n \n-  private final void setDefaultTime ()\n+  /**\n+   * Converts the time field values (<code>fields</code>) to\n+   * milliseconds since the epoch UTC (<code>time</code>). \n+   */\n+  protected synchronized void computeTime()\n   {\n-    setTimeInMillis (System.currentTimeMillis());\n+    int era = isSet[ERA] ? fields[ERA] : AD;\n+    int year = isSet[YEAR] ? fields[YEAR] : 1970;\n+    if (era == BC)\n+      year = 1 - year;\n+\n+    int[] daysOfYear = getDayOfYear(year);\n+    int hour = isSet[HOUR_OF_DAY] ? fields[HOUR_OF_DAY]\n+      : (isSet[HOUR] && isSet[AM_PM]\n+\t ? fields[AM_PM] * 12 + (fields[HOUR] % 12) : 0);\n+    int minute = isSet[MINUTE] ? fields[MINUTE] : 0;\n+    int second = isSet[SECOND] ? fields[SECOND] : 0;\n+    int millis = isSet[MILLISECOND] ? fields[MILLISECOND] : 0;\n+    int millisInDay;\n+\n+    if (isLenient())\n+      {\n+\t// prevent overflow\n+\tlong allMillis = (((hour * 60L) + minute) * 60L + second) * 1000L\n+\t  + millis;\n+\tdaysOfYear[1] += allMillis / (24 * 60 * 60 * 1000L);\n+\tmillisInDay = (int) (allMillis % (24 * 60 * 60 * 1000L));\n+      }\n+    else\n+      {\n+\tif (hour < 0 || hour >= 24 || minute < 0 || minute > 59\n+\t    || second < 0 || second > 59 || millis < 0 || millis >= 1000)\n+\t  throw new IllegalArgumentException();\n+\tmillisInDay = (((hour * 60) + minute) * 60 + second) * 1000 + millis;\n+      }\n+    time = getLinearTime(year, daysOfYear[0], millisInDay);\n+\n+    // Add the relative days after calculating the linear time, to\n+    // get right behaviour when jumping over the gregorianCutover.\n+    time += daysOfYear[1] * (24 * 60 * 60 * 1000L);\n+\n+\n+    TimeZone zone = getTimeZone();\n+    int rawOffset = isSet[ZONE_OFFSET]\n+      ? fields[ZONE_OFFSET] : getTimeZone().getRawOffset();\n+\n+    int dayOfYear = daysOfYear[0] + daysOfYear[1];\n+    int month = (dayOfYear * 5 + 3) / (31 + 30 + 31 + 30 + 31);\n+    int day = (6 + (dayOfYear * 5 + 3) % (31 + 30 + 31 + 30 + 31)) / 5;\n+    int weekday = ((int) (time / (24 * 60 * 60 * 1000L)) + THURSDAY) % 7;\n+    if (weekday <= 0)\n+      weekday += 7;\n+    int dstOffset = isSet[DST_OFFSET]\n+      ? fields[DST_OFFSET] : (zone.getOffset((year < 0) ? BC : AD,\n+\t\t\t\t\t     (year < 0) ? 1 - year : year,\n+\t\t\t\t\t     month, day, weekday, millisInDay)\n+\t\t\t      - zone.getRawOffset());\n+    time -= rawOffset + dstOffset;\n+    isTimeSet = true;\n   }\n \n-  public int getMinimum(int calfield) { return mins[calfield]; }\n-  public int getGreatestMinimum(int calfield) { return mins[calfield]; }\n-  public int getMaximum(int calfield) { return maxs[calfield]; }\n-  public int getLeastMaximum(int calfield) { return leastMaximums[calfield]; }\n+  /**\n+   * Determines if the given year is a leap year.  \n+   *\n+   * The year should be positive and you can't give an ERA.  But\n+   * remember that before 4 BC there wasn't a consistent leap year\n+   * rule, so who cares.\n+   *\n+   * @param year a year use nonnegative value for BC.\n+   * @param gregorian if true, use gregorian leap year rule.\n+   * @return true, if the given year is a leap year, false otherwise.  */\n+  private boolean isLeapYear(int year, boolean gregorian)\n+  {\n+    if ((year & 3) != 0)\n+      // Only years divisible by 4 can be leap years\n+      return false;\n \n-  protected native void computeFields();\n+    if (!gregorian)\n+      return true;\n \n-  protected native void computeTime();\n+    // We rely on AD area here.\n+    return ((year % 100) != 0 || (year % 400) == 0);\n+  }\n \n-  public void add (int fld, int amount)\n+  /**\n+   * Get the linear day in days since the epoch, using the\n+   * Julian or Gregorian calendar as specified.  If you specify a\n+   * nonpositive year it is interpreted as BC as following: 0 is 1\n+   * BC, -1 is 2 BC and so on.  \n+   *\n+   * @param year the year of the date.\n+   * @param dayOfYear the day of year of the date; 1 based.\n+   * @param gregorian True, if we should use Gregorian rules.\n+   * @return the days since the epoch, may be negative.  */\n+  private int getLinearDay(int year, int dayOfYear, boolean gregorian)\n   {\n-    if (fld >= ZONE_OFFSET)\n-      throw new IllegalArgumentException(\"bad field to add\");\n-    fields[fld] += amount;\n-    adjust(fld);\n+    // The 13 is the number of days, that were omitted in the Gregorian\n+    // Calender until the epoch.\n+    // We shift right by 2 instead of dividing by 4, to get correct\n+    // results for negative years (and this is even more efficient).\n+    int julianDay = ((year * (365 * 4 + 1)) >> 2) + dayOfYear -\n+      ((1970 * (365 * 4 + 1)) / 4 + 1 - 13);\n+\n+    if (gregorian)\n+      {\n+\t// subtract the days that are missing in gregorian calendar\n+\t// with respect to julian calendar.\n+\t//\n+\t// Okay, here we rely on the fact that the gregorian\n+\t// calendar was introduced in the AD era.  This doesn't work\n+\t// with negative years.\n+\t//\n+\t// The additional leap year factor accounts for the fact that\n+\t// a leap day is not seen on Jan 1 of the leap year.\n+\tint gregOffset = (year / 400) - (year / 100) + 2;\n+\tif (isLeapYear (year, true) && dayOfYear < 31 + 29)\n+\t  --gregOffset;\n+\tjulianDay += gregOffset;\n+      }\n+    return julianDay;\n   }\n \n-  public void roll (int fld, boolean up)\n+  /**\n+   * Converts the given linear day into era, year, month,\n+   * day_of_year, day_of_month, day_of_week, and writes the result\n+   * into the fields array.\n+   * @param day the linear day.  \n+   */\n+  private void calculateDay(int day, boolean gregorian)\n   {\n-    if (fld >= ZONE_OFFSET)\n-      throw new IllegalArgumentException(\"bad field to roll\");\n+    // the epoch is a Thursday.\n+    int weekday = (day + THURSDAY) % 7;\n+    if (weekday <= 0)\n+      weekday += 7;\n+    fields[DAY_OF_WEEK] = weekday;\n+\n+    // get a first approximation of the year.  This may be one \n+    // year to big.\n+    int year = 1970 + (gregorian\n+\t\t       ? ((day - 100) * 400) / (365 * 400 + 100 - 4 + 1)\n+\t\t       : ((day - 100) * 4) / (365 * 4 + 1));\n+    if (day >= 0)\n+      year++;\n+\n+    int firstDayOfYear = getLinearDay(year, 1, gregorian);\n+\n+    // Now look in which year day really lies.\n+    if (day < firstDayOfYear)\n+      {\n+\tyear--;\n+\tfirstDayOfYear = getLinearDay(year, 1, gregorian);\n+      }\n+\n+    day -= firstDayOfYear - 1;\t// day of year,  one based.\n \n-    int old = fields[fld];\n-    if (up)\n+    fields[DAY_OF_YEAR] = day;\n+    if (year <= 0)\n       {\n-\tfields[fld] = old == getMaximum(fld) ? getMinimum(fld)\n-\t  : old + 1;\n+\tfields[ERA] = BC;\n+\tfields[YEAR] = 1 - year;\n       }\n     else\n       {\n-\tfields[fld] = old == getMinimum(fld) ? getMaximum(fld)\n-\t  : old - 1;\n+\tfields[ERA] = AD;\n+\tfields[YEAR] = year;\n+      }\n+\n+    int leapday = isLeapYear(year, gregorian) ? 1 : 0;\n+    if (day <= 31 + 28 + leapday)\n+      {\n+\tfields[MONTH] = day / 32;\t// 31->JANUARY, 32->FEBRUARY\n+\tfields[DAY_OF_MONTH] = day - 31 * fields[MONTH];\n+      }\n+    else\n+      {\n+\t// A few more magic formulas\n+\tint scaledDay = (day - leapday) * 5 + 8;\n+\tfields[MONTH] = scaledDay / (31 + 30 + 31 + 30 + 31);\n+\tfields[DAY_OF_MONTH] = (scaledDay % (31 + 30 + 31 + 30 + 31)) / 5 + 1;\n       }\n   }\n \n-  private void adjust (int fld)\n+  /**\n+   * Converts the milliseconds since the epoch UTC\n+   * (<code>time</code>) to time fields\n+   * (<code>fields</code>). \n+   */\n+  protected synchronized void computeFields()\n   {\n-    int value = fields[fld];\n-    int radix = maxs[fld] + 1;\n-    switch (fld)\n+    boolean gregorian = (time >= gregorianCutover);\n+\n+    TimeZone zone = getTimeZone();\n+    fields[ZONE_OFFSET] = zone.getRawOffset();\n+    long localTime = time + fields[ZONE_OFFSET];\n+\n+    int day = (int) (localTime / (24 * 60 * 60 * 1000L));\n+    int millisInDay = (int) (localTime % (24 * 60 * 60 * 1000L));\n+    if (millisInDay < 0)\n       {\n+\tmillisInDay += (24 * 60 * 60 * 1000);\n+\tday--;\n+      }\n+\n+    calculateDay(day, gregorian);\n+    fields[DST_OFFSET] =\n+      zone.getOffset(fields[ERA], fields[YEAR], fields[MONTH],\n+\t\t     fields[DAY_OF_MONTH], fields[DAY_OF_WEEK],\n+\t\t     millisInDay) - fields[ZONE_OFFSET];\n+\n+    millisInDay += fields[DST_OFFSET];\n+    if (millisInDay >= 24 * 60 * 60 * 1000)\n+      {\n+\tmillisInDay -= 24 * 60 * 60 * 1000;\n+\tcalculateDay(++day, gregorian);\n+      }\n+\n+    fields[DAY_OF_WEEK_IN_MONTH] = (fields[DAY_OF_MONTH] + 6) / 7;\n+\n+    // which day of the week are we (0..6), relative to getFirstDayOfWeek\n+    int relativeWeekday = (7 + fields[DAY_OF_WEEK] - getFirstDayOfWeek()) % 7;\n+\n+    fields[WEEK_OF_MONTH] = (fields[DAY_OF_MONTH] - relativeWeekday + 6) / 7;\n+\n+    int weekOfYear = (fields[DAY_OF_YEAR] - relativeWeekday + 6) / 7;\n+\n+    // Do the Correction: getMinimalDaysInFirstWeek() is always in the \n+    // first week.\n+    int minDays = getMinimalDaysInFirstWeek();\n+    int firstWeekday =\n+      (7 + getWeekDay(fields[YEAR], minDays) - getFirstDayOfWeek()) % 7;\n+    if (minDays - firstWeekday < 1)\n+      weekOfYear++;\n+    fields[WEEK_OF_YEAR] = weekOfYear;\n+\n+\n+    int hourOfDay = millisInDay / (60 * 60 * 1000);\n+    fields[AM_PM] = (hourOfDay < 12) ? AM : PM;\n+    int hour = hourOfDay % 12;\n+    fields[HOUR] = (hour == 0) ? 12 : hour;\n+    fields[HOUR_OF_DAY] = hourOfDay;\n+    millisInDay %= (60 * 60 * 1000);\n+    fields[MINUTE] = millisInDay / (60 * 1000);\n+    millisInDay %= (60 * 1000);\n+    fields[SECOND] = millisInDay / (1000);\n+    fields[MILLISECOND] = millisInDay % 1000;\n+\n+\n+    areFieldsSet = isSet[ERA] = isSet[YEAR] = isSet[MONTH] =\n+      isSet[WEEK_OF_YEAR] = isSet[WEEK_OF_MONTH] =\n+      isSet[DAY_OF_MONTH] = isSet[DAY_OF_YEAR] = isSet[DAY_OF_WEEK] =\n+      isSet[DAY_OF_WEEK_IN_MONTH] = isSet[AM_PM] = isSet[HOUR] =\n+      isSet[HOUR_OF_DAY] = isSet[MINUTE] = isSet[SECOND] =\n+      isSet[MILLISECOND] = isSet[ZONE_OFFSET] = isSet[DST_OFFSET] = true;\n+\n+  }\n+\n+  /**\n+   * Compares the given calender with this.  \n+   * @param o the object to that we should compare.\n+   * @return true, if the given object is a calendar, that represents\n+   * the same time (but doesn't neccessary have the same fields).\n+   * @XXX Should we check if time zones, locale, cutover etc. are equal?\n+   */\n+  public boolean equals(Object o)\n+  {\n+    if (!(o instanceof GregorianCalendar))\n+      return false;\n+\n+    GregorianCalendar cal = (GregorianCalendar) o;\n+    return (cal.getTimeInMillis() == getTimeInMillis());\n+  }\n+\n+//     /**\n+//      * Compares the given calender with this.  \n+//      * @param o the object to that we should compare.\n+//      * @return true, if the given object is a calendar, and this calendar\n+//      * represents a smaller time than the calender o.\n+//      */\n+//     public boolean before(Object o) {\n+//         if (!(o instanceof GregorianCalendar))\n+//             return false;\n+\n+//         GregorianCalendar cal = (GregorianCalendar) o;\n+//         return (cal.getTimeInMillis() < getTimeInMillis());\n+//     }\n+\n+//     /**\n+//      * Compares the given calender with this.  \n+//      * @param o the object to that we should compare.\n+//      * @return true, if the given object is a calendar, and this calendar\n+//      * represents a bigger time than the calender o.\n+//      */\n+//     public boolean after(Object o) {\n+//         if (!(o instanceof GregorianCalendar))\n+//             return false;\n+\n+//         GregorianCalendar cal = (GregorianCalendar) o;\n+//         return (cal.getTimeInMillis() > getTimeInMillis());\n+//     }\n+\n+  /**\n+   * Adds the specified amount of time to the given time field.  The\n+   * amount may be negative to subtract the time.  If the field overflows\n+   * it does what you expect: Jan, 25 + 10 Days is Feb, 4.\n+   * @param field the time field. One of the time field constants.\n+   * @param amount the amount of time.\n+   */\n+  public void add(int field, int amount)\n+  {\n+    switch (field)\n+      {\n+      case YEAR:\n+\tcomplete();\n+\tfields[YEAR] += amount;\n+\tisTimeSet = false;\n+\tbreak;\n       case MONTH:\n-      case SECOND:\n-      case MILLISECOND:\n-\tif (value >= radix)\n+\tcomplete();\n+\tint months = fields[MONTH] + amount;\n+\tfields[YEAR] += months / 12;\n+\tfields[MONTH] = months % 12;\n+\tif (fields[MONTH] < 0)\n \t  {\n-\t    int next = value / radix;\n-\t    fields[fld] = value - radix * next;\n-\t    fields[fld - 1] += next;\n-\t    adjust(fld - 1);\n+\t    fields[MONTH] += 12;\n+\t    fields[YEAR]--;\n \t  }\n-\telse if (value < 0) // min[fld]\n+\tisTimeSet = false;\n+\tint maxDay = getActualMaximum(DAY_OF_MONTH);\n+\tif (fields[DAY_OF_MONTH] > maxDay)\n \t  {\n-\t    int next = (value - radix - 1) / radix;\n-\t    fields[fld] = value - radix * next;\n-\t    fields[fld - 1] += next;\n-            adjust(fld - 1);\n+\t    fields[DAY_OF_MONTH] = maxDay;\n+\t    isTimeSet = false;\n \t  }\n \tbreak;\n+      case DAY_OF_MONTH:\n+      case DAY_OF_YEAR:\n+      case DAY_OF_WEEK:\n+\tif (!isTimeSet)\n+\t  computeTime();\n+\ttime += amount * (24 * 60 * 60 * 1000L);\n+\tareFieldsSet = false;\n+\tbreak;\n+      case WEEK_OF_YEAR:\n+      case WEEK_OF_MONTH:\n+      case DAY_OF_WEEK_IN_MONTH:\n+\tif (!isTimeSet)\n+\t  computeTime();\n+\ttime += amount * (7 * 24 * 60 * 60 * 1000L);\n+\tareFieldsSet = false;\n+\tbreak;\n+      case AM_PM:\n+\tif (!isTimeSet)\n+\t  computeTime();\n+\ttime += amount * (12 * 60 * 60 * 1000L);\n+\tareFieldsSet = false;\n+\tbreak;\n+      case HOUR:\n+      case HOUR_OF_DAY:\n+\tif (!isTimeSet)\n+\t  computeTime();\n+\ttime += amount * (60 * 60 * 1000L);\n+\tareFieldsSet = false;\n+\tbreak;\n+      case MINUTE:\n+\tif (!isTimeSet)\n+\t  computeTime();\n+\ttime += amount * (60 * 1000L);\n+\tareFieldsSet = false;\n+\tbreak;\n+      case SECOND:\n+\tif (!isTimeSet)\n+\t  computeTime();\n+\ttime += amount * (1000L);\n+\tareFieldsSet = false;\n+\tbreak;\n+      case MILLISECOND:\n+\tif (!isTimeSet)\n+\t  computeTime();\n+\ttime += amount;\n+\tareFieldsSet = false;\n+\tbreak;\n+      case ZONE_OFFSET:\n+\tcomplete();\n+\tfields[ZONE_OFFSET] += amount;\n+\ttime -= amount;\n+\tbreak;\n+      case DST_OFFSET:\n+\tcomplete();\n+\tfields[DST_OFFSET] += amount;\n+\tisTimeSet = false;\n+\tbreak;\n+      default:\n+\tthrow new IllegalArgumentException\n+\t  (\"Unknown Calendar field: \" + field);\n       }\n   }\n \n-  public final Date getGregorianChange() { return new Date(gregorianCutover); }\n-  public void setGregorianChange (Date date)\n-  { gregorianCutover = date.getTime(); }\n \n-  public boolean isLeapYear(int year)\n+  /**\n+   * Rolls the specified time field up or down.  This means add one\n+   * to the specified field, but don't change the other fields.  If\n+   * the maximum for this field is reached, start over with the \n+   * minimum value.  \n+   *\n+   * <strong>Note:</strong> There may be situation, where the other\n+   * fields must be changed, e.g rolling the month on May, 31. \n+   * The date June, 31 is automatically converted to July, 1. \n+   * This requires lenient settings.\n+   *\n+   * @param field the time field. One of the time field constants.\n+   * @param up the direction, true for up, false for down.\n+   */\n+  public void roll(int field, boolean up)\n   {\n-    if ((year % 4) != 0)\n-      return false;\n-    if ((year % 100) != 0 || (year % 400) == 0)\n-      return true;\n-    // year divisible by 100 but not 400.\n-    GregorianCalendar date = new GregorianCalendar(year, FEBRUARY, 28);\n-    return gregorianCutover < date.getTimeInMillis();\n+    roll(field, up ? 1 : -1);\n   }\n \n-  public boolean after (Object cal)\n+  private void cleanUpAfterRoll(int field, int delta)\n   {\n-    return cal instanceof Calendar\n-      && getTimeInMillis() > ((Calendar) cal).getTimeInMillis();\n+    switch (field)\n+      {\n+      case ERA:\n+      case YEAR:\n+      case MONTH:\n+\t// check that day of month is still in correct range\n+\tif (fields[DAY_OF_MONTH] > getActualMaximum(DAY_OF_MONTH))\n+\t  fields[DAY_OF_MONTH] = getActualMaximum(DAY_OF_MONTH);\n+\tisTimeSet = false;\n+\tisSet[WEEK_OF_MONTH] = false;\n+\tisSet[DAY_OF_WEEK] = false;\n+\tisSet[DAY_OF_WEEK_IN_MONTH] = false;\n+\tisSet[DAY_OF_YEAR] = false;\n+\tisSet[WEEK_OF_YEAR] = false;\n+\tbreak;\n+\n+      case DAY_OF_MONTH:\n+\tisSet[WEEK_OF_MONTH] = false;\n+\tisSet[DAY_OF_WEEK] = false;\n+\tisSet[DAY_OF_WEEK_IN_MONTH] = false;\n+\tisSet[DAY_OF_YEAR] = false;\n+\tisSet[WEEK_OF_YEAR] = false;\n+\ttime += delta * (24 * 60 * 60 * 1000L);\n+\tbreak;\n+\n+      case WEEK_OF_MONTH:\n+\tisSet[DAY_OF_MONTH] = false;\n+\tisSet[DAY_OF_WEEK_IN_MONTH] = false;\n+\tisSet[DAY_OF_YEAR] = false;\n+\tisSet[WEEK_OF_YEAR] = false;\n+\ttime += delta * (7 * 24 * 60 * 60 * 1000L);\n+\tbreak;\n+      case DAY_OF_WEEK_IN_MONTH:\n+\tisSet[DAY_OF_MONTH] = false;\n+\tisSet[WEEK_OF_MONTH] = false;\n+\tisSet[DAY_OF_YEAR] = false;\n+\tisSet[WEEK_OF_YEAR] = false;\n+\ttime += delta * (7 * 24 * 60 * 60 * 1000L);\n+\tbreak;\n+      case DAY_OF_YEAR:\n+\tisSet[MONTH] = false;\n+\tisSet[DAY_OF_MONTH] = false;\n+\tisSet[WEEK_OF_MONTH] = false;\n+\tisSet[DAY_OF_WEEK_IN_MONTH] = false;\n+\tisSet[DAY_OF_WEEK] = false;\n+\tisSet[WEEK_OF_YEAR] = false;\n+\ttime += delta * (24 * 60 * 60 * 1000L);\n+\tbreak;\n+      case WEEK_OF_YEAR:\n+\tisSet[MONTH] = false;\n+\tisSet[DAY_OF_MONTH] = false;\n+\tisSet[WEEK_OF_MONTH] = false;\n+\tisSet[DAY_OF_WEEK_IN_MONTH] = false;\n+\tisSet[DAY_OF_YEAR] = false;\n+\ttime += delta * (7 * 24 * 60 * 60 * 1000L);\n+\tbreak;\n+\n+      case AM_PM:\n+\tisSet[HOUR_OF_DAY] = false;\n+\ttime += delta * (12 * 60 * 60 * 1000L);\n+\tbreak;\n+      case HOUR:\n+\tisSet[HOUR_OF_DAY] = false;\n+\ttime += delta * (60 * 60 * 1000L);\n+\tbreak;\n+      case HOUR_OF_DAY:\n+\tisSet[HOUR] = false;\n+\tisSet[AM_PM] = false;\n+\ttime += delta * (60 * 60 * 1000L);\n+\tbreak;\n+\n+      case MINUTE:\n+\ttime += delta * (60 * 1000L);\n+\tbreak;\n+      case SECOND:\n+\ttime += delta * (1000L);\n+\tbreak;\n+      case MILLISECOND:\n+\ttime += delta;\n+\tbreak;\n+      }\n   }\n \n-  public boolean before (Object cal)\n+  /**\n+   * Rolls the specified time field by the given amount.  This means\n+   * add amount to the specified field, but don't change the other\n+   * fields.  If the maximum for this field is reached, start over\n+   * with the minimum value and vice versa for negative amounts.\n+   *\n+   * <strong>Note:</strong> There may be situation, where the other\n+   * fields must be changed, e.g rolling the month on May, 31. \n+   * The date June, 31 is automatically corrected to June, 30.\n+   *\n+   * @param field the time field. One of the time field constants.\n+   * @param amount the amount by which we should roll.\n+   */\n+  public void roll(int field, int amount)\n   {\n-    return cal instanceof Calendar\n-      && getTimeInMillis() < ((Calendar) cal).getTimeInMillis();\n+    switch (field)\n+      {\n+      case DAY_OF_WEEK:\n+\t// day of week is special: it rolls automatically\n+\tadd(field, amount);\n+\treturn;\n+      case ZONE_OFFSET:\n+      case DST_OFFSET:\n+\tthrow new IllegalArgumentException(\"Can't roll time zone\");\n+      }\n+    complete();\n+    int min = getActualMinimum(field);\n+    int range = getActualMaximum(field) - min + 1;\n+    int oldval = fields[field];\n+    int newval = (oldval - min + range + amount) % range + min;\n+    if (newval < min)\n+      newval += range;\n+    fields[field] = newval;\n+    cleanUpAfterRoll(field, newval - oldval);\n   }\n \n-  public boolean equals (Object obj)\n+  private static final int[] minimums =\n+      { BC,       1,  1,  0, 1,  1,   1,   SUNDAY, 1, \n+        AM,  1,  0,  1,  1,   1, -(12*60*60*1000),               0 };\n+\n+  private static final int[] maximums =\n+      { AD, 5000000, 12, 53, 5, 31, 366, SATURDAY, 5, \n+        PM, 12, 23, 59, 59, 999, +(12*60*60*1000), (12*60*60*1000) };\n+\n+  /**\n+   * Gets the smallest value that is allowed for the specified field.\n+   * @param field the time field. One of the time field constants.\n+   * @return the smallest value.\n+   */\n+  public int getMinimum(int field)\n   {\n-    if (obj == null || ! (obj instanceof GregorianCalendar))\n-      return false;\n-    GregorianCalendar other = (GregorianCalendar) obj;\n+    return minimums[field];\n+  }\n \n-    for (int i = FIELD_COUNT;  --i >= 0; )\n+  /**\n+   * Gets the biggest value that is allowed for the specified field.\n+   * @param field the time field. One of the time field constants.\n+   * @return the biggest value.\n+   */\n+  public int getMaximum(int field)\n+  {\n+    return maximums[field];\n+  }\n+\n+\n+  /**\n+   * Gets the greatest minimum value that is allowed for the specified field.\n+   * @param field the time field. One of the time field constants.\n+   * @return the greatest minimum value.\n+   */\n+  public int getGreatestMinimum(int field)\n+  {\n+    if (field == WEEK_OF_YEAR)\n+      return 1;\n+    return minimums[field];\n+  }\n+\n+  /**\n+   * Gets the smallest maximum value that is allowed for the\n+   * specified field.  For example this is 28 for DAY_OF_MONTH.\n+   * @param field the time field. One of the time field constants.\n+   * @return the least maximum value.  \n+   * @since jdk1.2\n+   */\n+  public int getLeastMaximum(int field)\n+  {\n+    switch (field)\n       {\n-\tboolean set = isSet[i];\n-\tif (set != other.isSet[i]\n-\t    || (set && fields[i] != other.fields[i]))\n-\t  return false;\n+      case WEEK_OF_YEAR:\n+\treturn 52;\n+      case DAY_OF_MONTH:\n+\treturn 28;\n+      case DAY_OF_YEAR:\n+\treturn 365;\n+      case DAY_OF_WEEK_IN_MONTH:\n+      case WEEK_OF_MONTH:\n+\treturn 4;\n+      default:\n+\treturn maximums[field];\n       }\n-    if (areFieldsSet != other.areFieldsSet\n-\t|| isTimeSet != other.isTimeSet\n-\t|| (isTimeSet && time != other.time)\n-\t|| getFirstDayOfWeek() != other.getFirstDayOfWeek()\n-\t|| getMinimalDaysInFirstWeek() != other.getMinimalDaysInFirstWeek()\n-\t|| isLenient() != other.isLenient()\n-\t|| ! getTimeZone().equals(other.getTimeZone()))\n-      return false;\n-    return true;\n   }\n \n-  public int hashCode ()\n+  /**\n+   * Gets the actual minimum value that is allowed for the specified field.\n+   * This value is dependant on the values of the other fields.  Note that\n+   * this calls <code>complete()</code> if not enough fields are set.  This\n+   * can have ugly side effects.\n+   * @param field the time field. One of the time field constants.\n+   * @return the actual minimum value.\n+   * @since jdk1.2\n+   */\n+  public int getActualMinimum(int field)\n+  {\n+    if (field == WEEK_OF_YEAR)\n+      {\n+\tint min = getMinimalDaysInFirstWeek();\n+\tif (min == 0)\n+\t  return 1;\n+\tif (!areFieldsSet || !isSet[ERA] || !isSet[YEAR])\n+\t  complete();\n+\n+\tint year = fields[ERA] == AD ? fields[YEAR] : 1 - fields[YEAR];\n+\tint weekday = getWeekDay(year, min);\n+\tif ((7 + weekday - getFirstDayOfWeek()) % 7 >= min - 1)\n+\t  return 1;\n+\treturn 0;\n+      }\n+    return minimums[field];\n+  }\n+\n+  /**\n+   * Gets the actual maximum value that is allowed for the specified field.\n+   * This value is dependant on the values of the other fields.  Note that\n+   * this calls <code>complete()</code> if not enough fields are set.  This\n+   * can have ugly side effects.\n+   * @param field the time field. One of the time field constants.\n+   * @return the actual maximum value.  \n+   */\n+  public int getActualMaximum(int field)\n   {\n-    int hashcode = 0;\n-    for (int i = FIELD_COUNT;  --i >= 0; )\n+    switch (field)\n       {\n-\tif (isSet[i])\n-\t  hashcode += 37 * fields[i];\n+      case WEEK_OF_YEAR:\n+\t{\n+\t  if (!areFieldsSet || !isSet[ERA] || !isSet[YEAR])\n+\t    complete();\n+\t  // This is wrong for the year that contains the gregorian change.\n+\t  // I.e it gives the weeks in the julian year or in the gregorian\n+\t  // year in that case.\n+\t  int year = fields[ERA] == AD ? fields[YEAR] : 1 - fields[YEAR];\n+\t  int lastDay = isLeapYear(year) ? 366 : 365;\n+\t  int weekday = getWeekDay(year, lastDay);\n+\t  int week = (lastDay + 6\n+\t\t      - (7 + weekday - getFirstDayOfWeek()) % 7) / 7;\n+\n+\t  int minimalDays = getMinimalDaysInFirstWeek();\n+\t  int firstWeekday = getWeekDay(year, minimalDays);\n+\t  if (minimalDays - (7 + firstWeekday - getFirstDayOfWeek()) % 7 < 1)\n+\t    return week + 1;\n+\t}\n+\tcase DAY_OF_MONTH:\n+\t{\n+\t  if (!areFieldsSet || !isSet[MONTH])\n+\t    complete();\n+\t  int month = fields[MONTH];\n+\t  // If you change this, you should also change \n+\t  // SimpleTimeZone.getDaysInMonth();\n+\t  if (month == FEBRUARY)\n+\t    {\n+\t      if (!isSet[YEAR] || !isSet[ERA])\n+\t\tcomplete();\n+\t      int year = fields[ERA] == AD ? fields[YEAR] : 1 - fields[YEAR];\n+\t      return isLeapYear(year) ? 29 : 28;\n+\t    }\n+\t  else if (month < AUGUST)\n+\t    return 31 - (month & 1);\n+\t  else\n+\t    return 30 + (month & 1);\n+\t}\n+      case DAY_OF_YEAR:\n+\t{\n+\t  if (!areFieldsSet || !isSet[ERA] || !isSet[YEAR])\n+\t    complete();\n+\t  int year = fields[ERA] == AD ? fields[YEAR] : 1 - fields[YEAR];\n+\t  return isLeapYear(year) ? 366 : 365;\n+\t}\n+      case DAY_OF_WEEK_IN_MONTH:\n+\t{\n+\t  // This is wrong for the month that contains the gregorian change.\n+\t  int daysInMonth = getActualMaximum(DAY_OF_MONTH);\n+\t  // That's black magic, I know\n+\t  return (daysInMonth - (fields[DAY_OF_MONTH] - 1) % 7 + 6) / 7;\n+\t}\n+      case WEEK_OF_MONTH:\n+\t{\n+\t  int daysInMonth = getActualMaximum(DAY_OF_MONTH);\n+\t  int weekday = (daysInMonth - fields[DAY_OF_MONTH]\n+\t\t\t + fields[DAY_OF_WEEK] - SUNDAY) % 7 + SUNDAY;\n+\t  return (daysInMonth + 6\n+\t\t  - (7 + weekday - getFirstDayOfWeek()) % 7) / 7;\n+\t}\n+      default:\n+\treturn maximums[field];\n       }\n-    if (isTimeSet)\n-      hashcode += 89 * time;\n-    return hashcode;\n   }\n }"}, {"sha": "34b49969b457d70a01c8c2bf4189c3dd71c86181", "filename": "libjava/java/util/natGregorianCalendar.cc", "status": "removed", "additions": 0, "deletions": 159, "changes": 159, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b0089a92a30ae851e8bad7ca8da8b33dba4a5a95/libjava%2Fjava%2Futil%2FnatGregorianCalendar.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b0089a92a30ae851e8bad7ca8da8b33dba4a5a95/libjava%2Fjava%2Futil%2FnatGregorianCalendar.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Futil%2FnatGregorianCalendar.cc?ref=b0089a92a30ae851e8bad7ca8da8b33dba4a5a95", "patch": "@@ -1,159 +0,0 @@\n-/* Copyright (C) 1998, 1999, 2000, 2001  Free Software Foundation\n-\n-   This file is part of libgcj.\n-\n-This software is copyrighted work licensed under the terms of the\n-Libgcj License.  Please consult the file \"LIBGCJ_LICENSE\" for\n-details.  */\n-\n-#include <config.h>\n-\n-#ifdef ECOS\n-#include <string.h>\n-#endif\n-\n-#include <gcj/cni.h>\n-#include <java/util/TimeZone.h>\n-#include <java/util/GregorianCalendar.h>\n-#include <java/lang/IllegalArgumentException.h>\n-#include <time.h>\n-\n-void\n-java::util::GregorianCalendar::computeTime ()\n-{\n-  struct tm tim;\n-  tim.tm_sec = elements(fields)[SECOND];\n-  tim.tm_min = elements(fields)[MINUTE];\n-  tim.tm_hour = elements(fields)[HOUR_OF_DAY];\n-  tim.tm_mday = elements(fields)[DATE];\n-  tim.tm_mon = elements(fields)[MONTH];\n-  tim.tm_year = elements(fields)[YEAR] - 1900;\n-  tim.tm_isdst = 0;\n-#ifndef ECOS\n-  // FIXME: None of the standard C library access to the ECOS calendar\n-  // is yet available.\n-  time_t t = mktime (&tim);\n-\n-  if (!isLenient ())\n-    {\n-      // mktime will correct for any time leniencies (e.g. 31-Apr becomes\n-      // 1-May).\n-      // Daylight savings time is a special case since times in hour 23\n-      // will compute to hour 0 of the next day.\n-      if (tim.tm_isdst == 0 || elements(fields)[HOUR_OF_DAY] != 23)\n-        {\n-\t  if (tim.tm_sec != elements(fields)[SECOND] ||\n-\t      tim.tm_min != elements(fields)[MINUTE] ||\n-\t      tim.tm_hour != elements(fields)[HOUR_OF_DAY] +\n-\t      \t\t     (tim.tm_isdst > 0 ? 1 : 0) ||\n-\t      tim.tm_mday != elements(fields)[DATE] ||\n-\t      tim.tm_mon != elements(fields)[MONTH] ||\n-\t      tim.tm_year != elements(fields)[YEAR] - 1900)\n-\t    throw new java::lang::IllegalArgumentException ();\n-        }\n-      else\n-        {\n-\t  // The easiest thing to do is to temporarily shift the clock\n-\t  // back from the 23th hour so mktime doesn't cause the extra\n-\t  // hour for DST to roll the date to the next day.\n-\t  struct tm tmp_tim;\n-\t  tmp_tim.tm_sec = elements(fields)[SECOND];\n-\t  tmp_tim.tm_min = elements(fields)[MINUTE];\n-\t  tmp_tim.tm_hour = elements(fields)[HOUR_OF_DAY] - 1;\n-\t  tmp_tim.tm_mday = elements(fields)[DATE];\n-\t  tmp_tim.tm_mon = elements(fields)[MONTH];\n-\t  tmp_tim.tm_year = elements(fields)[YEAR] - 1900;\n-\t  tmp_tim.tm_isdst = 0;\n-\t  mktime (&tmp_tim);\n-\t  if (tmp_tim.tm_sec != elements(fields)[SECOND] ||\n-\t      tmp_tim.tm_min != elements(fields)[MINUTE] ||\n-\t      tmp_tim.tm_hour != elements(fields)[HOUR_OF_DAY] ||\n-\t      tmp_tim.tm_mday != elements(fields)[DATE] ||\n-\t      tmp_tim.tm_mon != elements(fields)[MONTH] ||\n-\t      tmp_tim.tm_year != elements(fields)[YEAR] - 1900)\n-\t    throw new java::lang::IllegalArgumentException ();\n-\t}\n-    }\n-#else\n-  time_t t = 0;\n-#endif\n-\n-  // Adjust for local timezone (introduced by mktime) and our\n-  // timezone.\n-#if defined (STRUCT_TM_HAS_GMTOFF)\n-  t -= tim.tm_gmtoff;\n-#elif defined (HAVE_TIMEZONE)\n-  t += timezone;\n-#endif\n-  // Adjust for milliseconds.\n-  time = t * (jlong) 1000 + elements(fields)[MILLISECOND];\n-\n-  // Now adjust for the real timezone, i.e. our timezone, which is in millis.\n-  java::util::TimeZone *zone = getTimeZone ();\n-  time += zone->getRawOffset();\n-\n-  isTimeSet = true;\n-}\n-\n-void\n-java::util::GregorianCalendar::computeFields ()\n-{\n-  time_t t = time / 1000;\n-  int millis = time % 1000;\n-  if (t < 0 && millis != 0)\n-    {\n-      t--;\n-      millis = t - 1000 * t;\n-    }\n-  elements(fields)[MILLISECOND] = millis;\n-  struct tm tim;\n-  java::util::TimeZone *zone = getTimeZone ();\n-\n-  // FIXME: None of the standard C library access to the ECOS calendar\n-  // is yet available.\n-#ifdef ECOS\n-  memset (&tim, 0, sizeof tim); \n-#else\n-  if (zone->getRawOffset() == 0 || ! zone->useDaylightTime())\n-    {\n-#if defined(__JV_POSIX_THREADS__) && defined(HAVE_GMTIME_R)\n-      gmtime_r (&t, &tim);\n-#else\n-      // Get global lock (because gmtime uses a global buffer).  FIXME\n-      tim = *(struct tm*) gmtime (&t);\n-      // Release global lock.  FIXME\n-#endif\n-    }\n-  else\n-    {\n-#if defined(__JV_POSIX_THREADS__) && defined(HAVE_LOCALTIME_R)\n-      localtime_r (&t, &tim);\n-#else\n-      // Get global lock (because localtime uses a global buffer).  FIXME\n-      tim = *(struct tm*) localtime (&t);\n-      // Release global lock.  FIXME\n-#endif\n-    }\n-#endif /* ECOS */\n-  elements(fields)[SECOND] = tim.tm_sec;\n-  elements(fields)[MINUTE] = tim.tm_min;\n-  elements(fields)[HOUR_OF_DAY] = tim.tm_hour;\n-  elements(fields)[AM_PM] = tim.tm_hour < 12 ? AM : PM;\n-  elements(fields)[HOUR] = tim.tm_hour % 12;\n-  elements(fields)[DATE] = tim.tm_mday;\n-  elements(fields)[MONTH] = tim.tm_mon;\n-  elements(fields)[YEAR] = 1900 + tim.tm_year;\n-  elements(fields)[DAY_OF_WEEK] = tim.tm_wday + 1;\n-  elements(fields)[DAY_OF_WEEK_IN_MONTH] = ((tim.tm_mday - 1) / 7) + 1;\n-  elements(fields)[DAY_OF_YEAR] = tim.tm_yday + 1;\n-  elements(fields)[WEEK_OF_MONTH]\n-    = (tim.tm_mday + 6 + (5 - tim.tm_wday + getFirstDayOfWeek()) % 7) / 7;\n-  elements(fields)[WEEK_OF_YEAR]\n-    = (tim.tm_yday + 7 + (5 - tim.tm_wday + getFirstDayOfWeek()) % 7) / 7;\n-  elements(fields)[ERA] = AD;\n-  elements(fields)[DST_OFFSET] = tim.tm_isdst <= 0 ? 0 : 60*60*1000;\n-  elements(fields)[ZONE_OFFSET] = getTimeZone()->getRawOffset();\n-  areFieldsSet = true;\n-  for (int i = 0; i < FIELD_COUNT; i++)\n-    elements(isSet__)[i] = true;\n-}"}]}