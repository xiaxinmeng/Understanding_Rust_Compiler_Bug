{"sha": "c4039eb00f3e9c46979dd4b027bd6f744f654a81", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YzQwMzllYjAwZjNlOWM0Njk3OWRkNGIwMjdiZDZmNzQ0ZjY1NGE4MQ==", "commit": {"author": {"name": "Joel Sherrill", "email": "joel@OARcorp.com", "date": "2003-01-29T17:43:57Z"}, "committer": {"name": "Joel Sherrill", "email": "joel@gcc.gnu.org", "date": "2003-01-29T17:43:57Z"}, "message": "5rosinte.ads: Add SIGXCPU.\n\n2003-01-29\tJoel Sherrill <joel@OARcorp.com>\n\n\t* 5rosinte.ads: Add SIGXCPU.\n\t* 5rtpopsp.adb: New file.\n\t* Make-lang.in: Do not build gnatpsta and gnatpsys when cross.\n\t* Makefile.in: Recognize more RTEMS targets and add the RTEMS\n\tspecific file 5rtpopsp.adb.\n\t* adaint.h: Add include of <stdio.h> when target is RTEMS.  This\n\tis likely needed for all newlib targets.\n\t* init.c: Add RTEMS specific version of __gnat_initialize().\n\nFrom-SVN: r62098", "tree": {"sha": "023559e3762c5cba547806f0f5a3f5dc0cc36717", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/023559e3762c5cba547806f0f5a3f5dc0cc36717"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c4039eb00f3e9c46979dd4b027bd6f744f654a81", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c4039eb00f3e9c46979dd4b027bd6f744f654a81", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c4039eb00f3e9c46979dd4b027bd6f744f654a81", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c4039eb00f3e9c46979dd4b027bd6f744f654a81/comments", "author": null, "committer": null, "parents": [{"sha": "204c43d6428292fd317ff16f79bbecdc37657dee", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/204c43d6428292fd317ff16f79bbecdc37657dee", "html_url": "https://github.com/Rust-GCC/gccrs/commit/204c43d6428292fd317ff16f79bbecdc37657dee"}], "stats": {"total": 308, "additions": 303, "deletions": 5}, "files": [{"sha": "649499aae1bde4b690b98bce34c2329fff91ea36", "filename": "gcc/ada/5rosinte.ads", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c4039eb00f3e9c46979dd4b027bd6f744f654a81/gcc%2Fada%2F5rosinte.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c4039eb00f3e9c46979dd4b027bd6f744f654a81/gcc%2Fada%2F5rosinte.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2F5rosinte.ads?ref=c4039eb00f3e9c46979dd4b027bd6f744f654a81", "patch": "@@ -7,7 +7,7 @@\n --                                   S p e c                                --\n --                                                                          --\n --                                                                          --\n---          Copyright (C) 1997-2001 Free Software Foundation, Inc.          --\n+--          Copyright (C) 1997-2003 Free Software Foundation, Inc.          --\n --                                                                          --\n -- GNARL is free software; you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -106,6 +106,7 @@ package System.OS_Interface is\n    SIGTERM     : constant := 15; --  software termination signal from kill\n    SIGUSR1     : constant := 16; --  user defined signal 1\n    SIGUSR2     : constant := 17; --  user defined signal 2\n+   SIGXCPU     : constant := 0; --  XCPU\n \n    SIGADAABORT : constant := SIGABRT;\n "}, {"sha": "cdc3c844e64c13b12207f81b295a5c99f842a270", "filename": "gcc/ada/5rtpopsp.adb", "status": "added", "additions": 266, "deletions": 0, "changes": 266, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c4039eb00f3e9c46979dd4b027bd6f744f654a81/gcc%2Fada%2F5rtpopsp.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c4039eb00f3e9c46979dd4b027bd6f744f654a81/gcc%2Fada%2F5rtpopsp.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2F5rtpopsp.adb?ref=c4039eb00f3e9c46979dd4b027bd6f744f654a81", "patch": "@@ -0,0 +1,266 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                GNU ADA RUN-TIME LIBRARY (GNARL) COMPONENTS               --\n+--                                                                          --\n+--    S Y S T E M . T A S K _ P R I M I T I V E S . O P E R A T I O N S .   --\n+--                              S P E C I F I C                             --\n+--                                                                          --\n+--                                  B o d y                                 --\n+--                                                                          --\n+--                             $Revision: 1.7 $\n+--                                                                          --\n+--            Copyright (C) 1991-2003, Florida State University             --\n+--                                                                          --\n+-- GNARL is free software; you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 2,  or (at your option) any later ver- --\n+-- sion. GNARL is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n+-- for  more details.  You should have  received  a copy of the GNU General --\n+-- Public License  distributed with GNARL; see file COPYING.  If not, write --\n+-- to  the Free Software Foundation,  59 Temple Place - Suite 330,  Boston, --\n+-- MA 02111-1307, USA.                                                      --\n+--                                                                          --\n+-- As a special exception,  if other files  instantiate  generics from this --\n+-- unit, or you link  this unit with other files  to produce an executable, --\n+-- this  unit  does not  by itself cause  the resulting  executable  to  be --\n+-- covered  by the  GNU  General  Public  License.  This exception does not --\n+-- however invalidate  any other reasons why  the executable file  might be --\n+-- covered by the  GNU Public License.                                      --\n+--                                                                          --\n+-- GNARL was developed by the GNARL team at Florida State University. It is --\n+-- now maintained by Ada Core Technologies Inc. in cooperation with Florida --\n+-- State University (http://www.gnat.com).                                  --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+--  This is a POSIX version of this package where foreign threads are\n+--  recognized.\n+--  Currently, DEC Unix, SCO UnixWare 7 and RTEMS use this version.\n+\n+with System.Soft_Links;\n+--  used to initialize TSD for a C thread, in function Self\n+\n+separate (System.Task_Primitives.Operations)\n+package body Specific is\n+\n+   ------------------\n+   --  Local Data  --\n+   ------------------\n+\n+   --  The followings are logically constants, but need to be initialized\n+   --  at run time.\n+\n+   --  The following gives the Ada run-time direct access to a variable\n+   --  context switched by RTEMS at the lowest level.\n+\n+   RTEMS_Ada_Self : System.Address;\n+   pragma Import (C, RTEMS_Ada_Self, \"rtems_ada_self\");\n+\n+   --  The following are used to allow the Self function to\n+   --  automatically generate ATCB's for C threads that happen to call\n+   --  Ada procedure, which in turn happen to call the Ada runtime system.\n+\n+   type Fake_ATCB;\n+   type Fake_ATCB_Ptr is access Fake_ATCB;\n+   type Fake_ATCB is record\n+      Stack_Base : Interfaces.C.unsigned := 0;\n+      --  A value of zero indicates the node is not in use.\n+      Next : Fake_ATCB_Ptr;\n+      Real_ATCB : aliased Ada_Task_Control_Block (0);\n+   end record;\n+\n+   Fake_ATCB_List : Fake_ATCB_Ptr;\n+   --  A linear linked list.\n+   --  The list is protected by All_Tasks_L;\n+   --  Nodes are added to this list from the front.\n+   --  Once a node is added to this list, it is never removed.\n+\n+   Fake_Task_Elaborated : aliased Boolean := True;\n+   --  Used to identified fake tasks (i.e., non-Ada Threads).\n+\n+   Next_Fake_ATCB : Fake_ATCB_Ptr;\n+   --  Used to allocate one Fake_ATCB in advance. See comment in New_Fake_ATCB\n+\n+   -----------------------\n+   -- Local Subprograms --\n+   -----------------------\n+\n+   ---------------------------------\n+   --  Support for New_Fake_ATCB  --\n+   ---------------------------------\n+\n+   function New_Fake_ATCB return Task_ID;\n+   --  Allocate and Initialize a new ATCB. This code can safely be called from\n+   --  a foreign thread, as it doesn't access implicitely or explicitely\n+   --  \"self\" before having initialized the new ATCB.\n+\n+   -------------------\n+   -- New_Fake_ATCB --\n+   -------------------\n+\n+   function New_Fake_ATCB return Task_ID is\n+      Self_ID   : Task_ID;\n+      P, Q      : Fake_ATCB_Ptr;\n+      Succeeded : Boolean;\n+\n+   begin\n+      --  This section is ticklish.\n+      --  We dare not call anything that might require an ATCB, until\n+      --  we have the new ATCB in place.\n+\n+      Write_Lock (All_Tasks_L'Access);\n+      Q := null;\n+      P := Fake_ATCB_List;\n+\n+      while P /= null loop\n+         if P.Stack_Base = 0 then\n+            Q := P;\n+         end if;\n+\n+         P := P.Next;\n+      end loop;\n+\n+      if Q = null then\n+\n+         --  Create a new ATCB with zero entries.\n+\n+         Self_ID := Next_Fake_ATCB.Real_ATCB'Access;\n+         Next_Fake_ATCB.Stack_Base := 1;\n+         Next_Fake_ATCB.Next := Fake_ATCB_List;\n+         Fake_ATCB_List := Next_Fake_ATCB;\n+         Next_Fake_ATCB := null;\n+\n+      else\n+         --  Reuse an existing fake ATCB.\n+\n+         Self_ID := Q.Real_ATCB'Access;\n+         Q.Stack_Base := 1;\n+      end if;\n+\n+      --  Record this as the Task_ID for the current thread.\n+\n+      Self_ID.Common.LL.Thread := pthread_self;\n+\n+      RTEMS_Ada_Self := To_Address (Self_ID);\n+\n+      --  Do the standard initializations\n+\n+      System.Tasking.Initialize_ATCB\n+        (Self_ID, null, Null_Address, Null_Task, Fake_Task_Elaborated'Access,\n+         System.Priority'First, Task_Info.Unspecified_Task_Info, 0, Self_ID,\n+         Succeeded);\n+      pragma Assert (Succeeded);\n+\n+      --  Finally, it is safe to use an allocator in this thread.\n+\n+      if Next_Fake_ATCB = null then\n+         Next_Fake_ATCB := new Fake_ATCB;\n+      end if;\n+\n+      Self_ID.Common.State := Runnable;\n+      Self_ID.Awake_Count := 1;\n+\n+      --  Since this is not an ordinary Ada task, we will start out undeferred\n+\n+      Self_ID.Deferral_Level := 0;\n+\n+      System.Soft_Links.Create_TSD (Self_ID.Common.Compiler_Data);\n+\n+      --  ????\n+      --  The following call is commented out to avoid dependence on\n+      --  the System.Tasking.Initialization package.\n+      --  It seems that if we want Ada.Task_Attributes to work correctly\n+      --  for C threads we will need to raise the visibility of this soft\n+      --  link to System.Soft_Links.\n+      --  We are putting that off until this new functionality is otherwise\n+      --  stable.\n+      --  System.Tasking.Initialization.Initialize_Attributes_Link.all (T);\n+\n+      for J in Known_Tasks'Range loop\n+         if Known_Tasks (J) = null then\n+            Known_Tasks (J) := Self_ID;\n+            Self_ID.Known_Tasks_Index := J;\n+            exit;\n+         end if;\n+      end loop;\n+\n+      --  Must not unlock until Next_ATCB is again allocated.\n+\n+      Unlock (All_Tasks_L'Access);\n+      return Self_ID;\n+   end New_Fake_ATCB;\n+\n+   ----------------\n+   -- Initialize --\n+   ----------------\n+\n+   procedure Initialize (Environment_Task : Task_ID) is\n+\n+   begin\n+      RTEMS_Ada_Self := To_Address (Environment_Task);\n+\n+      --  Create a free ATCB for use on the Fake_ATCB_List.\n+\n+      Next_Fake_ATCB := new Fake_ATCB;\n+   end Initialize;\n+\n+   ---------\n+   -- Set --\n+   ---------\n+\n+   procedure Set (Self_Id : Task_ID) is\n+\n+   begin\n+      RTEMS_Ada_Self := To_Address (Self_Id);\n+   end Set;\n+\n+   ----------\n+   -- Self --\n+   ----------\n+\n+   --  To make Ada tasks and C threads interoperate better, we have\n+   --  added some functionality to Self.  Suppose a C main program\n+   --  (with threads) calls an Ada procedure and the Ada procedure\n+   --  calls the tasking runtime system.  Eventually, a call will be\n+   --  made to self.  Since the call is not coming from an Ada task,\n+   --  there will be no corresponding ATCB.\n+\n+   --  (The entire Ada run-time system may not have been elaborated,\n+   --  either, but that is a different problem, that we will need to\n+   --  solve another way.)\n+\n+   --  What we do in Self is to catch references that do not come\n+   --  from recognized Ada tasks, and create an ATCB for the calling\n+   --  thread.\n+\n+   --  The new ATCB will be \"detached\" from the normal Ada task\n+   --  master hierarchy, much like the existing implicitly created\n+   --  signal-server tasks.\n+\n+   --  We will also use such points to poll for disappearance of the\n+   --  threads associated with any implicit ATCBs that we created\n+   --  earlier, and take the opportunity to recover them.\n+\n+   --  A nasty problem here is the limitations of the compilation\n+   --  order dependency, and in particular the GNARL/GNULLI layering.\n+   --  To initialize an ATCB we need to assume System.Tasking has\n+   --  been elaborated.\n+\n+   function Self return Task_ID is\n+      Result : System.Address;\n+\n+   begin\n+      Result := RTEMS_Ada_Self;\n+\n+      --  If the key value is Null, then it is a non-Ada task.\n+\n+      if Result = System.Null_Address then\n+         return New_Fake_ATCB;\n+      end if;\n+\n+      return To_Task_ID (Result);\n+   end Self;\n+\n+end Specific;"}, {"sha": "5efe3bbf317d77c1622be5c5f4de44dce574ea23", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c4039eb00f3e9c46979dd4b027bd6f744f654a81/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c4039eb00f3e9c46979dd4b027bd6f744f654a81/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=c4039eb00f3e9c46979dd4b027bd6f744f654a81", "patch": "@@ -1,3 +1,14 @@\n+2003-01-29\tJoel Sherrill <joel@OARcorp.com>\n+\n+\t* 5rosinte.ads: Add SIGXCPU.\n+\t* 5rtpopsp.adb: New file.\n+\t* Make-lang.in: Do not build gnatpsta and gnatpsys when cross.\n+\t* Makefile.in: Recognize more RTEMS targets and add the RTEMS\n+\tspecific file 5rtpopsp.adb.\n+\t* adaint.h: Add include of <stdio.h> when target is RTEMS.  This\n+\tis likely needed for all newlib targets.\n+\t* init.c: Add RTEMS specific version of __gnat_initialize().\n+\n 2003-01-28  Rainer Orth  <ro@TechFak.Uni-Bielefeld.DE>\n \n \t* adaint.c, adaint.h, gmem.c, init.c: Update copyright year."}, {"sha": "76431a7002b413c0677ce2d5ba1b386d29dd8a81", "filename": "gcc/ada/Make-lang.in", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c4039eb00f3e9c46979dd4b027bd6f744f654a81/gcc%2Fada%2FMake-lang.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c4039eb00f3e9c46979dd4b027bd6f744f654a81/gcc%2Fada%2FMake-lang.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FMake-lang.in?ref=c4039eb00f3e9c46979dd4b027bd6f744f654a81", "patch": "@@ -1,5 +1,5 @@\n # Top level makefile fragment for GNU Ada (GNAT).\n-#   Copyright (C) 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002\n+#   Copyright (C) 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003\n #   Free Software Foundation, Inc.\n \n #This file is part of GNU CC."}, {"sha": "664da56bd29ec0cd36e92524dd370da5ea085b16", "filename": "gcc/ada/Makefile.in", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c4039eb00f3e9c46979dd4b027bd6f744f654a81/gcc%2Fada%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c4039eb00f3e9c46979dd4b027bd6f744f654a81/gcc%2Fada%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FMakefile.in?ref=c4039eb00f3e9c46979dd4b027bd6f744f654a81", "patch": "@@ -1,5 +1,5 @@\n # Makefile for GNU Ada Compiler (GNAT).\n-#   Copyright (C) 1994-2002 Free Software Foundation, Inc.\n+#   Copyright (C) 1994-2003 Free Software Foundation, Inc.\n \n #This file is part of GNU CC.\n \n@@ -875,7 +875,7 @@ ifeq ($(strip $(filter-out lynxos,$(osys))),)\n   endif\n endif\n \n-ifeq ($(strip $(filter-out rtems,$(osys))),)\n+ifeq ($(strip $(filter-out rtems rtemself rtemsaout rtemscoff,$(osys))),)\n   LIBGNAT_TARGET_PAIRS = \\\n   a-intnam.ads<4rintnam.ads \\\n   s-inmaop.adb<7sinmaop.adb \\\n@@ -886,7 +886,7 @@ ifeq ($(strip $(filter-out rtems,$(osys))),)\n   s-parame.adb<5rparame.adb \\\n   s-taprop.adb<7staprop.adb \\\n   s-taspri.ads<7staspri.ads \\\n-  s-tpopsp.adb<5atpopsp.adb\n+  s-tpopsp.adb<5rtpopsp.adb\n endif\n \n ifeq ($(strip $(filter-out go32 msdos,$(osys))),)"}, {"sha": "edfd25d367745524ecc8ae3070fc1d978af3237b", "filename": "gcc/ada/adaint.h", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c4039eb00f3e9c46979dd4b027bd6f744f654a81/gcc%2Fada%2Fadaint.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c4039eb00f3e9c46979dd4b027bd6f744f654a81/gcc%2Fada%2Fadaint.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fadaint.h?ref=c4039eb00f3e9c46979dd4b027bd6f744f654a81", "patch": "@@ -31,6 +31,10 @@\n  *                                                                          *\n  ****************************************************************************/\n \n+#if defined(__rtems__)\n+#include <stdio.h>\n+#endif\n+\n #include <dirent.h>\n \n extern int    __gnat_max_path_len;"}, {"sha": "2f3ad1d80df797930a255ca31c0172e0f8df12b7", "filename": "gcc/ada/init.c", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c4039eb00f3e9c46979dd4b027bd6f744f654a81/gcc%2Fada%2Finit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c4039eb00f3e9c46979dd4b027bd6f744f654a81/gcc%2Fada%2Finit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Finit.c?ref=c4039eb00f3e9c46979dd4b027bd6f744f654a81", "patch": "@@ -1635,6 +1635,22 @@ __gnat_initialize ()\n #endif\n }\n \n+/***************************************/\n+/* __gnat_initialize (RTEMS version) */\n+/***************************************/\n+\n+#elif defined(__rtems__)\n+\n+extern void __gnat_install_handler ();\n+\n+/* For RTEMS, each bsp will provide a custom __gnat_install_handler (). */\n+\n+void\n+__gnat_initialize ()\n+{\n+   __gnat_install_handler ();\n+}\n+\n #else\n \n /* For all other versions of GNAT, the initialize routine and handler"}]}