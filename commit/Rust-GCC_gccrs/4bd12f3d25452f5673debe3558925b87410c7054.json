{"sha": "4bd12f3d25452f5673debe3558925b87410c7054", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NGJkMTJmM2QyNTQ1MmY1NjczZGViZTM1NTg5MjViODc0MTBjNzA1NA==", "commit": {"author": {"name": "Maxim Kuvyrkov", "email": "maxim.kuvyrkov@linaro.org", "date": "2014-08-07T11:16:29Z"}, "committer": {"name": "Maxim Kuvyrkov", "email": "mkuvyrkov@gcc.gnu.org", "date": "2014-08-07T11:16:29Z"}, "message": "Add statistical printout of rank_for_schedule decisions\n\n\t* haifa-sched.c (SCHED_SORT): Delete.  Macro used exactly once.\n\t(enum rfs_decition:RFS_*): New constants wrapped in an enum.\n\t(rfs_str): String corresponding to RFS_* constants.\n\t(rank_for_schedule_stats_t): New typedef.\n\t(rank_for_schedule_stats): New static variable.\n\t(rfs_result): New static function.\n\t(rank_for_schedule): Track statistics for deciding heuristics.\n\t(rank_for_schedule_stats_diff, print_rank_for_schedule_stats): New\n\tstatic functions.\n\t(ready_sort): Use them for debug printouts.\n\t(schedule_block): Init statistics state.  Print statistics on\n\trank_for_schedule decisions.\n\nFrom-SVN: r213709", "tree": {"sha": "5dea20825fcf191f7c6f5d261341ae5b9122baa4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5dea20825fcf191f7c6f5d261341ae5b9122baa4"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/4bd12f3d25452f5673debe3558925b87410c7054", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4bd12f3d25452f5673debe3558925b87410c7054", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4bd12f3d25452f5673debe3558925b87410c7054", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4bd12f3d25452f5673debe3558925b87410c7054/comments", "author": {"login": "maxim-kuvyrkov", "id": 12545699, "node_id": "MDQ6VXNlcjEyNTQ1Njk5", "avatar_url": "https://avatars.githubusercontent.com/u/12545699?v=4", "gravatar_id": "", "url": "https://api.github.com/users/maxim-kuvyrkov", "html_url": "https://github.com/maxim-kuvyrkov", "followers_url": "https://api.github.com/users/maxim-kuvyrkov/followers", "following_url": "https://api.github.com/users/maxim-kuvyrkov/following{/other_user}", "gists_url": "https://api.github.com/users/maxim-kuvyrkov/gists{/gist_id}", "starred_url": "https://api.github.com/users/maxim-kuvyrkov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/maxim-kuvyrkov/subscriptions", "organizations_url": "https://api.github.com/users/maxim-kuvyrkov/orgs", "repos_url": "https://api.github.com/users/maxim-kuvyrkov/repos", "events_url": "https://api.github.com/users/maxim-kuvyrkov/events{/privacy}", "received_events_url": "https://api.github.com/users/maxim-kuvyrkov/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "88366b18d690e8cd41dd4c47e96c5595ffcad8a2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/88366b18d690e8cd41dd4c47e96c5595ffcad8a2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/88366b18d690e8cd41dd4c47e96c5595ffcad8a2"}], "stats": {"total": 132, "additions": 105, "deletions": 27}, "files": [{"sha": "53d77cad5792269931eca57c7a33c986b8952821", "filename": "gcc/ChangeLog", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4bd12f3d25452f5673debe3558925b87410c7054/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4bd12f3d25452f5673debe3558925b87410c7054/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=4bd12f3d25452f5673debe3558925b87410c7054", "patch": "@@ -1,3 +1,18 @@\n+2014-08-07  Maxim Kuvyrkov  <maxim.kuvyrkov@linaro.org>\n+\n+\t* haifa-sched.c (SCHED_SORT): Delete.  Macro used exactly once.\n+\t(enum rfs_decition:RFS_*): New constants wrapped in an enum.\n+\t(rfs_str): String corresponding to RFS_* constants.\n+\t(rank_for_schedule_stats_t): New typedef.\n+\t(rank_for_schedule_stats): New static variable.\n+\t(rfs_result): New static function.\n+\t(rank_for_schedule): Track statistics for deciding heuristics.\n+\t(rank_for_schedule_stats_diff, print_rank_for_schedule_stats): New\n+\tstatic functions.\n+\t(ready_sort): Use them for debug printouts.\n+\t(schedule_block): Init statistics state.  Print statistics on\n+\trank_for_schedule decisions.\n+\n 2014-08-07  Maxim Kuvyrkov  <maxim.kuvyrkov@linaro.org>\n \n \t* haifa-sched.c (rank_for_schedule): Fix INSN_TICK-based heuristics."}, {"sha": "aada6e479cc96dc395272170eacb3c4340421de0", "filename": "gcc/haifa-sched.c", "status": "modified", "additions": 90, "deletions": 27, "changes": 117, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4bd12f3d25452f5673debe3558925b87410c7054/gcc%2Fhaifa-sched.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4bd12f3d25452f5673debe3558925b87410c7054/gcc%2Fhaifa-sched.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fhaifa-sched.c?ref=4bd12f3d25452f5673debe3558925b87410c7054", "patch": "@@ -1683,13 +1683,6 @@ priority (rtx insn)\n /* Macros and functions for keeping the priority queue sorted, and\n    dealing with queuing and dequeuing of instructions.  */\n \n-#define SCHED_SORT(READY, N_READY)                                   \\\n-do { if ((N_READY) == 2)\t\t\t\t             \\\n-       swap_sort (READY, N_READY);\t\t\t             \\\n-     else if ((N_READY) > 2)                                         \\\n-         qsort (READY, N_READY, sizeof (rtx), rank_for_schedule); }  \\\n-while (0)\n-\n /* For each pressure class CL, set DEATH[CL] to the number of registers\n    in that class that die in INSN.  */\n \n@@ -2525,6 +2518,34 @@ model_set_excess_costs (rtx *insns, int count)\n     }\n }\n \f\n+\n+/* Enum of rank_for_schedule heuristic decisions.  */\n+enum rfs_decision {\n+  RFS_DEBUG, RFS_LIVE_RANGE_SHRINK1, RFS_LIVE_RANGE_SHRINK2,\n+  RFS_SCHED_GROUP, RFS_PRESSURE_DELAY, RFS_PRESSURE_TICK,\n+  RFS_FEEDS_BACKTRACK_INSN, RFS_PRIORITY, RFS_SPECULATION,\n+  RFS_SCHED_RANK, RFS_LAST_INSN, RFS_PRESSURE_INDEX,\n+  RFS_DEP_COUNT, RFS_TIE, RFS_N };\n+\n+/* Corresponding strings for print outs.  */\n+static const char *rfs_str[RFS_N] = {\n+  \"RFS_DEBUG\", \"RFS_LIVE_RANGE_SHRINK1\", \"RFS_LIVE_RANGE_SHRINK2\",\n+  \"RFS_SCHED_GROUP\", \"RFS_PRESSURE_DELAY\", \"RFS_PRESSURE_TICK\",\n+  \"RFS_FEEDS_BACKTRACK_INSN\", \"RFS_PRIORITY\", \"RFS_SPECULATION\",\n+  \"RFS_SCHED_RANK\", \"RFS_LAST_INSN\", \"RFS_PRESSURE_INDEX\",\n+  \"RFS_DEP_COUNT\", \"RFS_TIE\" };\n+\n+/* Statistical breakdown of rank_for_schedule decisions.  */\n+typedef struct { unsigned stats[RFS_N]; } rank_for_schedule_stats_t;\n+static rank_for_schedule_stats_t rank_for_schedule_stats;\n+\n+static int\n+rfs_result (enum rfs_decision decision, int result)\n+{\n+  ++rank_for_schedule_stats.stats[decision];\n+  return result;\n+}\n+\n /* Returns a positive value if x is preferred; returns a negative value if\n    y is preferred.  Should never return 0, since that will make the sort\n    unstable.  */\n@@ -2541,11 +2562,11 @@ rank_for_schedule (const void *x, const void *y)\n     {\n       /* Schedule debug insns as early as possible.  */\n       if (DEBUG_INSN_P (tmp) && !DEBUG_INSN_P (tmp2))\n-\treturn -1;\n+\treturn rfs_result (RFS_DEBUG, -1);\n       else if (!DEBUG_INSN_P (tmp) && DEBUG_INSN_P (tmp2))\n-\treturn 1;\n+\treturn rfs_result (RFS_DEBUG, 1);\n       else if (DEBUG_INSN_P (tmp) && DEBUG_INSN_P (tmp2))\n-\treturn INSN_LUID (tmp) - INSN_LUID (tmp2);\n+\treturn rfs_result (RFS_DEBUG, INSN_LUID (tmp) - INSN_LUID (tmp2));\n     }\n \n   if (live_range_shrinkage_p)\n@@ -2557,17 +2578,18 @@ rank_for_schedule (const void *x, const void *y)\n \t   || INSN_REG_PRESSURE_EXCESS_COST_CHANGE (tmp2) < 0)\n \t  && (diff = (INSN_REG_PRESSURE_EXCESS_COST_CHANGE (tmp)\n \t\t      - INSN_REG_PRESSURE_EXCESS_COST_CHANGE (tmp2))) != 0)\n-\treturn diff;\n+\treturn rfs_result (RFS_LIVE_RANGE_SHRINK1, diff);\n       /* Sort by INSN_LUID (original insn order), so that we make the\n \t sort stable.  This minimizes instruction movement, thus\n \t minimizing sched's effect on debugging and cross-jumping.  */\n-      return INSN_LUID (tmp) - INSN_LUID (tmp2);\n+      return rfs_result (RFS_LIVE_RANGE_SHRINK2,\n+\t\t\t INSN_LUID (tmp) - INSN_LUID (tmp2));\n     }\n \n   /* The insn in a schedule group should be issued the first.  */\n   if (flag_sched_group_heuristic &&\n       SCHED_GROUP_P (tmp) != SCHED_GROUP_P (tmp2))\n-    return SCHED_GROUP_P (tmp2) ? 1 : -1;\n+    return rfs_result (RFS_SCHED_GROUP, SCHED_GROUP_P (tmp2) ? 1 : -1);\n \n   /* Make sure that priority of TMP and TMP2 are initialized.  */\n   gcc_assert (INSN_PRIORITY_KNOWN (tmp) && INSN_PRIORITY_KNOWN (tmp2));\n@@ -2580,15 +2602,15 @@ rank_for_schedule (const void *x, const void *y)\n \t\t   + insn_delay (tmp)\n \t\t   - INSN_REG_PRESSURE_EXCESS_COST_CHANGE (tmp2)\n \t\t   - insn_delay (tmp2))))\n-\treturn diff;\n+\treturn rfs_result (RFS_PRESSURE_DELAY, diff);\n     }\n \n   if (sched_pressure != SCHED_PRESSURE_NONE\n       && (INSN_TICK (tmp2) > clock_var || INSN_TICK (tmp) > clock_var)\n       && INSN_TICK (tmp2) != INSN_TICK (tmp))\n     {\n       diff = INSN_TICK (tmp) - INSN_TICK (tmp2);\n-      return diff;\n+      return rfs_result (RFS_PRESSURE_TICK, diff);\n     }\n \n   /* If we are doing backtracking in this schedule, prefer insns that\n@@ -2598,14 +2620,14 @@ rank_for_schedule (const void *x, const void *y)\n     {\n       priority_val = FEEDS_BACKTRACK_INSN (tmp2) - FEEDS_BACKTRACK_INSN (tmp);\n       if (priority_val)\n-\treturn priority_val;\n+\treturn rfs_result (RFS_FEEDS_BACKTRACK_INSN, priority_val);\n     }\n \n   /* Prefer insn with higher priority.  */\n   priority_val = INSN_PRIORITY (tmp2) - INSN_PRIORITY (tmp);\n \n   if (flag_sched_critical_path_heuristic && priority_val)\n-    return priority_val;\n+    return rfs_result (RFS_PRIORITY, priority_val);\n \n   /* Prefer speculative insn with greater dependencies weakness.  */\n   if (flag_sched_spec_insn_heuristic && spec_info)\n@@ -2628,12 +2650,12 @@ rank_for_schedule (const void *x, const void *y)\n \n       dw = dw2 - dw1;\n       if (dw > (NO_DEP_WEAK / 8) || dw < -(NO_DEP_WEAK / 8))\n-\treturn dw;\n+\treturn rfs_result (RFS_SPECULATION, dw);\n     }\n \n   info_val = (*current_sched_info->rank) (tmp, tmp2);\n   if (flag_sched_rank_heuristic && info_val)\n-    return info_val;\n+    return rfs_result (RFS_SCHED_RANK, info_val);\n \n   /* Compare insns based on their relation to the last scheduled\n      non-debug insn.  */\n@@ -2669,16 +2691,16 @@ rank_for_schedule (const void *x, const void *y)\n \ttmp2_class = 2;\n \n       if ((val = tmp2_class - tmp_class))\n-\treturn val;\n+\treturn rfs_result (RFS_LAST_INSN, val);\n     }\n \n   /* Prefer instructions that occur earlier in the model schedule.  */\n   if (sched_pressure == SCHED_PRESSURE_MODEL\n       && INSN_BB (tmp) == target_bb && INSN_BB (tmp2) == target_bb)\n     {\n       diff = model_index (tmp) - model_index (tmp2);\n-      if (diff != 0)\n-\treturn diff;\n+      gcc_assert (diff != 0);\n+      return rfs_result (RFS_PRESSURE_INDEX, diff);\n     }\n \n   /* Prefer the insn which has more later insns that depend on it.\n@@ -2689,12 +2711,12 @@ rank_for_schedule (const void *x, const void *y)\n \t - dep_list_size (tmp, SD_LIST_FORW));\n \n   if (flag_sched_dep_count_heuristic && val != 0)\n-    return val;\n+    return rfs_result (RFS_DEP_COUNT, val);\n \n   /* If insns are equally good, sort by INSN_LUID (original insn order),\n      so that we make the sort stable.  This minimizes instruction movement,\n      thus minimizing sched's effect on debugging and cross-jumping.  */\n-  return INSN_LUID (tmp) - INSN_LUID (tmp2);\n+  return rfs_result (RFS_TIE, INSN_LUID (tmp) - INSN_LUID (tmp2));\n }\n \n /* Resort the array A in which only element at index N may be out of order.  */\n@@ -2899,6 +2921,26 @@ ready_remove_insn (rtx insn)\n   gcc_unreachable ();\n }\n \n+/* Calculate difference of two statistics set WAS and NOW.\n+   Result returned in WAS.  */\n+static void\n+rank_for_schedule_stats_diff (rank_for_schedule_stats_t *was,\n+\t\t\t      const rank_for_schedule_stats_t *now)\n+{\n+  for (int i = 0; i < RFS_N; ++i)\n+    was->stats[i] = now->stats[i] - was->stats[i];\n+}\n+\n+/* Print rank_for_schedule statistics.  */\n+static void\n+print_rank_for_schedule_stats (const char *prefix,\n+\t\t\t       const rank_for_schedule_stats_t *stats)\n+{\n+  for (int i = 0; i < RFS_N; ++i)\n+    if (stats->stats[i])\n+      fprintf (sched_dump, \"%s%20s: %u\\n\", prefix, rfs_str[i], stats->stats[i]);\n+}\n+\n /* Sort the ready list READY by ascending priority, using the SCHED_SORT\n    macro.  */\n \n@@ -2917,7 +2959,21 @@ ready_sort (struct ready_list *ready)\n   if (sched_pressure == SCHED_PRESSURE_MODEL\n       && model_curr_point < model_num_insns)\n     model_set_excess_costs (first, ready->n_ready);\n-  SCHED_SORT (first, ready->n_ready);\n+\n+  rank_for_schedule_stats_t stats1;\n+  if (sched_verbose >= 4)\n+    stats1 = rank_for_schedule_stats;\n+\n+  if (ready->n_ready == 2)\n+    swap_sort (first, ready->n_ready);\n+  else if (ready->n_ready > 2)\n+    qsort (first, ready->n_ready, sizeof (rtx), rank_for_schedule);\n+\n+  if (sched_verbose >= 4)\n+    {\n+      rank_for_schedule_stats_diff (&stats1, &rank_for_schedule_stats);\n+      print_rank_for_schedule_stats (\";;\\t\\t\", &stats1);\n+    }\n }\n \n /* PREV is an insn that is ready to execute.  Adjust its priority if that\n@@ -5942,7 +5998,11 @@ schedule_block (basic_block *target_bb, state_t init_state)\n       dump_new_block_header (0, *target_bb, head, tail);\n \n       if (sched_verbose >= 2)\n-\tdump_insn_stream (head, tail);\n+\t{\n+\t  dump_insn_stream (head, tail);\n+\t  memset (&rank_for_schedule_stats, 0,\n+\t\t  sizeof (rank_for_schedule_stats));\n+\t}\n     }\n \n   if (init_state == NULL)\n@@ -6540,7 +6600,10 @@ schedule_block (basic_block *target_bb, state_t init_state)\n \t       INSN_UID (head), INSN_UID (tail));\n \n       if (sched_verbose >= 2)\n-\tdump_insn_stream (head, tail);\n+\t{\n+\t  dump_insn_stream (head, tail);\n+\t  print_rank_for_schedule_stats (\";; TOTAL \", &rank_for_schedule_stats);\n+\t}\n \n       fprintf (sched_dump, \"\\n\");\n     }"}]}