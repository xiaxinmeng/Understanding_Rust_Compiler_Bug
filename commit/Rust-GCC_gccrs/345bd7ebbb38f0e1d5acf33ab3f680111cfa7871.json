{"sha": "345bd7ebbb38f0e1d5acf33ab3f680111cfa7871", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzQ1YmQ3ZWJiYjM4ZjBlMWQ1YWNmMzNhYjNmNjgwMTExY2ZhNzg3MQ==", "commit": {"author": {"name": "Paul Thomas", "email": "pault@gcc.gnu.org", "date": "2016-12-09T11:55:27Z"}, "committer": {"name": "Paul Thomas", "email": "pault@gcc.gnu.org", "date": "2016-12-09T11:55:27Z"}, "message": "re PR fortran/44265 (Link error with reference to parameter array in specification expression)\n\n2016-12-09  Paul Thomas  <pault@gcc.gnu.org>\n\n\tPR fortran/44265\n\t* gfortran.h : Add fn_result_spec bitfield to gfc_symbol.\n\t* resolve.c (flag_fn_result_spec): New function.\n\t(resolve_fntype): Call it for character result lengths.\n\t* symbol.c (gfc_new_symbol): Set fn_result_spec to zero.\n\t* trans-decl.c (gfc_sym_mangled_identifier): Include the\n\tprocedure name in the mangled name for symbols with the\n\tfn_result_spec bit set.\n\t(gfc_finish_var_decl): Mark the decls of these symbols\n\tappropriately for the case where the function is external.\n\t(gfc_get_symbol_decl): Mangle the name of these symbols.\n\t(gfc_create_module_variable): Allow them through the assert.\n\t(gfc_generate_function_code): Remove the assert before the\n\tinitialization of sym->tlink because the frontend no longer\n\tuses this field.\n\t* trans-expr.c (gfc_map_intrinsic_function): Add a case to\n\ttreat the LEN_TRIM intrinsic.\n\t(gfc_trans_string_copy): Deal with Wstringop-overflow warning\n\tthat can occur with constant source lengths at -O3.\n\n2016-12-09  Paul Thomas  <pault@gcc.gnu.org>\n\n\tPR fortran/44265\n\t* gfortran.dg/char_result_14.f90: New test.\n\t* gfortran.dg/char_result_15.f90: New test.\n\nFrom-SVN: r243478", "tree": {"sha": "85abf9edc9eb9b2f0cb506bc7cd1750b31bf4c29", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/85abf9edc9eb9b2f0cb506bc7cd1750b31bf4c29"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/345bd7ebbb38f0e1d5acf33ab3f680111cfa7871", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/345bd7ebbb38f0e1d5acf33ab3f680111cfa7871", "html_url": "https://github.com/Rust-GCC/gccrs/commit/345bd7ebbb38f0e1d5acf33ab3f680111cfa7871", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/345bd7ebbb38f0e1d5acf33ab3f680111cfa7871/comments", "author": null, "committer": null, "parents": [{"sha": "cdecc83f3e0c71790841630597c5ab1303c39742", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cdecc83f3e0c71790841630597c5ab1303c39742", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cdecc83f3e0c71790841630597c5ab1303c39742"}], "stats": {"total": 315, "additions": 303, "deletions": 12}, "files": [{"sha": "b27c1e36787cba702337176b3efc4b622991b376", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/345bd7ebbb38f0e1d5acf33ab3f680111cfa7871/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/345bd7ebbb38f0e1d5acf33ab3f680111cfa7871/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=345bd7ebbb38f0e1d5acf33ab3f680111cfa7871", "patch": "@@ -1,3 +1,25 @@\n+2016-12-09  Paul Thomas  <pault@gcc.gnu.org>\n+\n+\tPR fortran/44265\n+\t* gfortran.h : Add fn_result_spec bitfield to gfc_symbol.\n+\t* resolve.c (flag_fn_result_spec): New function.\n+\t(resolve_fntype): Call it for character result lengths.\n+\t* symbol.c (gfc_new_symbol): Set fn_result_spec to zero.\n+\t* trans-decl.c (gfc_sym_mangled_identifier): Include the\n+\tprocedure name in the mangled name for symbols with the\n+\tfn_result_spec bit set.\n+\t(gfc_finish_var_decl): Mark the decls of these symbols\n+\tappropriately for the case where the function is external.\n+\t(gfc_get_symbol_decl): Mangle the name of these symbols.\n+\t(gfc_create_module_variable): Allow them through the assert.\n+\t(gfc_generate_function_code): Remove the assert before the\n+\tinitialization of sym->tlink because the frontend no longer\n+\tuses this field.\n+\t* trans-expr.c (gfc_map_intrinsic_function): Add a case to\n+\ttreat the LEN_TRIM intrinsic.\n+\t(gfc_trans_string_copy): Deal with Wstringop-overflow warning\n+\tthat can occur with constant source lengths at -O3.\n+\n 2016-12-08  Steven G. Kargl  <kargl@gcc.gnu.org>\n \n \tPR fortran/65173"}, {"sha": "670c13afa642ca6a4c3cf27b7867844d607c6c44", "filename": "gcc/fortran/gfortran.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/345bd7ebbb38f0e1d5acf33ab3f680111cfa7871/gcc%2Ffortran%2Fgfortran.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/345bd7ebbb38f0e1d5acf33ab3f680111cfa7871/gcc%2Ffortran%2Fgfortran.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fgfortran.h?ref=345bd7ebbb38f0e1d5acf33ab3f680111cfa7871", "patch": "@@ -1545,6 +1545,8 @@ typedef struct gfc_symbol\n   unsigned equiv_built:1;\n   /* Set if this variable is used as an index name in a FORALL.  */\n   unsigned forall_index:1;\n+  /* Set if the symbol is used in a function result specification .  */\n+  unsigned fn_result_spec:1;\n   /* Used to avoid multiple resolutions of a single symbol.  */\n   unsigned resolved:1;\n   /* Set if this is a module function or subroutine with the"}, {"sha": "2093de91c206ec86a5601db4b8eaa1fe1864b777", "filename": "gcc/fortran/resolve.c", "status": "modified", "additions": 59, "deletions": 0, "changes": 59, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/345bd7ebbb38f0e1d5acf33ab3f680111cfa7871/gcc%2Ffortran%2Fresolve.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/345bd7ebbb38f0e1d5acf33ab3f680111cfa7871/gcc%2Ffortran%2Fresolve.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fresolve.c?ref=345bd7ebbb38f0e1d5acf33ab3f680111cfa7871", "patch": "@@ -566,6 +566,14 @@ resolve_contained_fntype (gfc_symbol *sym, gfc_namespace *ns)\n {\n   bool t;\n \n+  if (sym && sym->attr.flavor == FL_PROCEDURE\n+      && sym->ns->parent\n+      && sym->ns->parent->proc_name\n+      && sym->ns->parent->proc_name->attr.flavor == FL_PROCEDURE\n+      && !strcmp (sym->name, sym->ns->parent->proc_name->name))\n+    gfc_error (\"Contained procedure %qs at %L has the same name as its \"\n+\t       \"encompassing procedure\", sym->name, &sym->declared_at);\n+\n   /* If this namespace is not a function or an entry master function,\n      ignore it.  */\n   if (! sym || !(sym->attr.function || sym->attr.flavor == FL_VARIABLE)\n@@ -15747,6 +15755,54 @@ resolve_equivalence (gfc_equiv *eq)\n }\n \n \n+/* Function called by resolve_fntype to flag other symbol used in the\n+   length type parameter specification of function resuls.  */\n+\n+static bool\n+flag_fn_result_spec (gfc_expr *expr,\n+                     gfc_symbol *sym ATTRIBUTE_UNUSED,\n+                     int *f ATTRIBUTE_UNUSED)\n+{\n+  gfc_namespace *ns;\n+  gfc_symbol *s;\n+\n+  if (expr->expr_type == EXPR_VARIABLE)\n+    {\n+      s = expr->symtree->n.sym;\n+      for (ns = s->ns; ns; ns = ns->parent)\n+\tif (!ns->parent)\n+\t  break;\n+\n+      if (!s->fn_result_spec\n+\t  && s->attr.flavor == FL_PARAMETER)\n+\t{\n+\t  /* Function contained in a module.... */\n+\t  if (ns->proc_name && ns->proc_name->attr.flavor == FL_MODULE)\n+\t    {\n+\t      gfc_symtree *st;\n+\t      s->fn_result_spec = 1;\n+\t      /* Make sure that this symbol is translated as a module\n+\t\t variable.  */\n+\t      st = gfc_get_unique_symtree (ns);\n+\t      st->n.sym = s;\n+\t      s->refs++;\n+\t    }\n+\t  /* ... which is use associated and called.  */\n+\t  else if (s->attr.use_assoc || s->attr.used_in_submodule\n+\t\t\t||\n+\t\t  /* External function matched with an interface.  */\n+\t\t  (s->ns->proc_name\n+\t\t   && ((s->ns == ns\n+\t\t\t && s->ns->proc_name->attr.if_source == IFSRC_DECL)\n+\t\t       || s->ns->proc_name->attr.if_source == IFSRC_IFBODY)\n+\t\t   && s->ns->proc_name->attr.function))\n+\t    s->fn_result_spec = 1;\n+\t}\n+    }\n+  return false;\n+}\n+\n+\n /* Resolve function and ENTRY types, issue diagnostics if needed.  */\n \n static void\n@@ -15797,6 +15853,9 @@ resolve_fntype (gfc_namespace *ns)\n \t    el->sym->attr.untyped = 1;\n \t  }\n       }\n+\n+  if (sym->ts.type == BT_CHARACTER)\n+    gfc_traverse_expr (sym->ts.u.cl->length, NULL, flag_fn_result_spec, 0);\n }\n \n "}, {"sha": "f16e6262b2e44557ffda87b441e1726ee8ee700b", "filename": "gcc/fortran/symbol.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/345bd7ebbb38f0e1d5acf33ab3f680111cfa7871/gcc%2Ffortran%2Fsymbol.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/345bd7ebbb38f0e1d5acf33ab3f680111cfa7871/gcc%2Ffortran%2Fsymbol.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fsymbol.c?ref=345bd7ebbb38f0e1d5acf33ab3f680111cfa7871", "patch": "@@ -2965,6 +2965,7 @@ gfc_new_symbol (const char *name, gfc_namespace *ns)\n   p->common_block = NULL;\n   p->f2k_derived = NULL;\n   p->assoc = NULL;\n+  p->fn_result_spec = 0;\n   \n   return p;\n }"}, {"sha": "f659a486ec98b1b619bc74b2fa92efa546984f92", "filename": "gcc/fortran/trans-decl.c", "status": "modified", "additions": 45, "deletions": 9, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/345bd7ebbb38f0e1d5acf33ab3f680111cfa7871/gcc%2Ffortran%2Ftrans-decl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/345bd7ebbb38f0e1d5acf33ab3f680111cfa7871/gcc%2Ffortran%2Ftrans-decl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-decl.c?ref=345bd7ebbb38f0e1d5acf33ab3f680111cfa7871", "patch": "@@ -356,12 +356,36 @@ gfc_sym_mangled_identifier (gfc_symbol * sym)\n   if (sym->attr.is_bind_c == 1 && sym->binding_label)\n     return get_identifier (sym->binding_label);\n \n-  if (sym->module == NULL)\n-    return gfc_sym_identifier (sym);\n+  if (!sym->fn_result_spec)\n+    {\n+      if (sym->module == NULL)\n+\treturn gfc_sym_identifier (sym);\n+      else\n+\t{\n+\t  snprintf (name, sizeof name, \"__%s_MOD_%s\", sym->module, sym->name);\n+\t  return get_identifier (name);\n+\t}\n+    }\n   else\n     {\n-      snprintf (name, sizeof name, \"__%s_MOD_%s\", sym->module, sym->name);\n-      return get_identifier (name);\n+      /* This is an entity that is actually local to a module procedure\n+\t that appears in the result specification expression.  Since\n+\t sym->module will be a zero length string, we use ns->proc_name\n+\t instead. */\n+      if (sym->ns->proc_name && sym->ns->proc_name->module)\n+\t{\n+\t  snprintf (name, sizeof name, \"__%s_MOD__%s_PROC_%s\",\n+\t\t    sym->ns->proc_name->module,\n+\t\t    sym->ns->proc_name->name,\n+\t\t    sym->name);\n+\t  return get_identifier (name);\n+\t}\n+      else\n+\t{\n+\t  snprintf (name, sizeof name, \"__%s_PROC_%s\",\n+\t\t    sym->ns->proc_name->name, sym->name);\n+\t  return get_identifier (name);\n+\t}\n     }\n }\n \n@@ -615,6 +639,16 @@ gfc_finish_var_decl (tree decl, gfc_symbol * sym)\n       DECL_EXTERNAL (decl) = 1;\n       TREE_PUBLIC (decl) = 1;\n     }\n+  else if (sym->fn_result_spec && !sym->ns->proc_name->module)\n+    {\n+\n+      if (sym->ns->proc_name->attr.if_source != IFSRC_DECL)\n+\tDECL_EXTERNAL (decl) = 1;\n+      else\n+\tTREE_STATIC (decl) = 1;\n+\n+      TREE_PUBLIC (decl) = 1;\n+    }\n   else if (sym->module && !sym->attr.result && !sym->attr.dummy)\n     {\n       /* TODO: Don't set sym->module for result or dummy variables.  */\n@@ -1632,7 +1666,7 @@ gfc_get_symbol_decl (gfc_symbol * sym)\n   /* Create string length decl first so that they can be used in the\n      type declaration.  For associate names, the target character\n      length is used. Set 'length' to a constant so that if the\n-     string lenght is a variable, it is not finished a second time.  */\n+     string length is a variable, it is not finished a second time.  */\n   if (sym->ts.type == BT_CHARACTER)\n     {\n       if (sym->attr.associate_var\n@@ -1654,7 +1688,7 @@ gfc_get_symbol_decl (gfc_symbol * sym)\n   /* Symbols from modules should have their assembler names mangled.\n      This is done here rather than in gfc_finish_var_decl because it\n      is different for string length variables.  */\n-  if (sym->module)\n+  if (sym->module || sym->fn_result_spec)\n     {\n       gfc_set_decl_assembler_name (decl, gfc_sym_mangled_identifier (sym));\n       if (sym->attr.use_assoc && !intrinsic_array_parameter)\n@@ -4766,7 +4800,9 @@ gfc_create_module_variable (gfc_symbol * sym)\n \n   /* Create the variable.  */\n   pushdecl (decl);\n-  gcc_assert (sym->ns->proc_name->attr.flavor == FL_MODULE);\n+  gcc_assert (sym->ns->proc_name->attr.flavor == FL_MODULE\n+\t      || (sym->ns->parent->proc_name->attr.flavor == FL_MODULE\n+\t\t  && sym->fn_result_spec));\n   DECL_CONTEXT (decl) = sym->ns->proc_name->backend_decl;\n   rest_of_decl_compilation (decl, 1, 0);\n   gfc_module_add_decl (cur_module, decl);\n@@ -6153,8 +6189,8 @@ gfc_generate_function_code (gfc_namespace * ns)\n   previous_procedure_symbol = current_procedure_symbol;\n   current_procedure_symbol = sym;\n \n-  /* Check that the frontend isn't still using this.  */\n-  gcc_assert (sym->tlink == NULL);\n+  /* Initialize sym->tlink so that gfc_trans_deferred_vars does not get\n+     lost or worse.  */\n   sym->tlink = sym;\n \n   /* Create the declaration for functions with global scope.  */"}, {"sha": "8cb0f1c7129ad9446357d3d98758c8c9a4b8e5f9", "filename": "gcc/fortran/trans-expr.c", "status": "modified", "additions": 21, "deletions": 3, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/345bd7ebbb38f0e1d5acf33ab3f680111cfa7871/gcc%2Ffortran%2Ftrans-expr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/345bd7ebbb38f0e1d5acf33ab3f680111cfa7871/gcc%2Ffortran%2Ftrans-expr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-expr.c?ref=345bd7ebbb38f0e1d5acf33ab3f680111cfa7871", "patch": "@@ -4116,6 +4116,16 @@ gfc_map_intrinsic_function (gfc_expr *expr, gfc_interface_mapping *mapping)\n       new_expr = gfc_copy_expr (arg1->ts.u.cl->length);\n       break;\n \n+    case GFC_ISYM_LEN_TRIM:\n+      new_expr = gfc_copy_expr (arg1);\n+      gfc_apply_interface_mapping_to_expr (mapping, new_expr);\n+\n+      if (!new_expr)\n+\treturn false;\n+\n+      gfc_replace_expr (arg1, new_expr);\n+      return true;\n+\n     case GFC_ISYM_SIZE:\n       if (!sym->as || sym->as->rank == 0)\n \treturn false;\n@@ -6484,10 +6494,18 @@ gfc_trans_string_copy (stmtblock_t * block, tree dlength, tree dest,\n \t\t\t      builtin_decl_explicit (BUILT_IN_MEMMOVE),\n \t\t\t      3, dest, src, slen);\n \n+  /* Wstringop-overflow appears at -O3 even though this warning is not\n+     explicitly available in fortran nor can it be switched off. If the\n+     source length is a constant, its negative appears as a very large\n+     postive number and triggers the warning in BUILTIN_MEMSET. Fixing\n+     the result of the MINUS_EXPR suppresses this spurious warning.  */\n+  tmp = fold_build2_loc (input_location, MINUS_EXPR,\n+\t\t\t TREE_TYPE(dlen), dlen, slen);\n+  if (slength && TREE_CONSTANT (slength))\n+    tmp = gfc_evaluate_now (tmp, block);\n+\n   tmp4 = fold_build_pointer_plus_loc (input_location, dest, slen);\n-  tmp4 = fill_with_spaces (tmp4, chartype,\n-\t\t\t   fold_build2_loc (input_location, MINUS_EXPR,\n-\t\t\t\t\t    TREE_TYPE(dlen), dlen, slen));\n+  tmp4 = fill_with_spaces (tmp4, chartype, tmp);\n \n   gfc_init_block (&tempblock);\n   gfc_add_expr_to_block (&tempblock, tmp3);"}, {"sha": "843ee9f928dd53849b57cb6cd637251625965a47", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/345bd7ebbb38f0e1d5acf33ab3f680111cfa7871/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/345bd7ebbb38f0e1d5acf33ab3f680111cfa7871/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=345bd7ebbb38f0e1d5acf33ab3f680111cfa7871", "patch": "@@ -1,3 +1,9 @@\n+2016-12-09  Paul Thomas  <pault@gcc.gnu.org>\n+\n+\tPR fortran/44265\n+\t* gfortran.dg/char_result_14.f90: New test.\n+\t* gfortran.dg/char_result_15.f90: New test.\n+\n 2016-12-09  Martin Liska  <mliska@suse.cz>\n \n \t* gcc.dg/tree-ssa/dump-3.c: New test."}, {"sha": "3083ecce4c59921ace552338daabcd8657383c42", "filename": "gcc/testsuite/gfortran.dg/char_result_14.f90", "status": "added", "additions": 103, "deletions": 0, "changes": 103, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/345bd7ebbb38f0e1d5acf33ab3f680111cfa7871/gcc%2Ftestsuite%2Fgfortran.dg%2Fchar_result_14.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/345bd7ebbb38f0e1d5acf33ab3f680111cfa7871/gcc%2Ftestsuite%2Fgfortran.dg%2Fchar_result_14.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fchar_result_14.f90?ref=345bd7ebbb38f0e1d5acf33ab3f680111cfa7871", "patch": "@@ -0,0 +1,103 @@\n+! { dg-do run }\n+!\n+! Tests the fix for PR44265. This is the original test with the addition\n+! of the check of the issue found in comment #1 of the PR.\n+!\n+! Contributed by Ian Harvey  <ian_harvey@bigpond.com>\n+! Ian also contributed the first version of the fix.\n+!\n+! The original version of the bug\n+MODULE Fruits0\n+  IMPLICIT NONE\n+  PRIVATE\n+  PUBLIC :: Get0\n+CONTAINS\n+  FUNCTION Get0(i) RESULT(s)\n+    CHARACTER(*), PARAMETER :: names(3) = [  &\n+        'Apple  ',  &\n+        'Orange ',  &\n+        'Mango  ' ];\n+    INTEGER, INTENT(IN) :: i\n+    CHARACTER(LEN_TRIM(names(i))) :: s\n+    !****\n+    s = names(i)\n+  END FUNCTION Get0\n+END MODULE Fruits0\n+!\n+! Version that came about from sorting other issues.\n+MODULE Fruits\n+  IMPLICIT NONE\n+  PRIVATE\n+    character (20) :: buffer\n+    CHARACTER(*), PARAMETER :: names(4) = [  &\n+        'Apple  ',  &\n+        'Orange ',  &\n+        'Mango  ',  &\n+        'Pear   ' ];\n+  PUBLIC :: Get, SGet, fruity2, fruity3, buffer\n+CONTAINS\n+! This worked previously\n+  subroutine fruity3\n+    write (buffer, '(i2,a)') len (Get (4)), Get (4)\n+  end\n+! Original function in the PR\n+  FUNCTION Get(i) RESULT(s)\n+    INTEGER, INTENT(IN) :: i\n+    CHARACTER(LEN_trim(names(i))) :: s\n+    !****\n+    s = names(i)\n+  END FUNCTION Get\n+! Check that dummy is OK\n+  Subroutine Sget(i, s)\n+    CHARACTER(*), PARAMETER :: names(4) = [  &\n+        'Apple  ',  &\n+        'Orange ',  &\n+        'Mango  ',  &\n+        'Pear   ' ];\n+    INTEGER, INTENT(IN) :: i\n+    CHARACTER(LEN_trim(names(i))), intent(out) :: s\n+    !****\n+    s = names(i)\n+    write (buffer, '(i2,a)') len (s), s\n+  END subroutine SGet\n+! This would fail with undefined references to mangled 'names' during linking\n+  subroutine fruity2\n+    write (buffer, '(i2,a)') len (Get (3)), Get (3)\n+  end\n+END MODULE Fruits\n+\n+PROGRAM WheresThatbLinkingConstantGone\n+  use Fruits0\n+  USE Fruits\n+  IMPLICIT NONE\n+  character(7) :: arg = \"\"\n+  integer :: i\n+\n+! Test the fix for the original bug\n+  if (len (Get0(1)) .ne. 5) call abort\n+  if (Get0(2) .ne. \"Orange\") call abort\n+\n+! Test the fix for the subsequent issues\n+  call fruity\n+  if (trim (buffer) .ne. \" 6Orange\") call abort\n+  call fruity2\n+  if (trim (buffer) .ne. \" 5Mango\") call abort\n+  call fruity3\n+  if (trim (buffer) .ne. \" 4Pear\") call abort\n+  do i = 3, 4\n+    call Sget (i, arg)\n+    if (i == 3) then\n+      if (trim (buffer) .ne. \" 5Mango\") call abort\n+      if (trim (arg) .ne. \"Mango\") call abort\n+    else\n+      if (trim (buffer) .ne. \" 4Pear\") call abort\n+! Since arg is fixed length in this scope, it gets over-written\n+! by s, which in this case is length 4. Thus, the 'o' remains.\n+      if (trim (arg) .ne. \"Pearo\") call abort\n+    end if\n+  enddo\n+contains\n+  subroutine fruity\n+      write (buffer, '(i2,a)') len (Get (2)), Get (2)\n+  end\n+END PROGRAM WheresThatbLinkingConstantGone"}, {"sha": "3c9a879d359a6ca676d95719266774924e51589c", "filename": "gcc/testsuite/gfortran.dg/char_result_15.f90", "status": "added", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/345bd7ebbb38f0e1d5acf33ab3f680111cfa7871/gcc%2Ftestsuite%2Fgfortran.dg%2Fchar_result_15.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/345bd7ebbb38f0e1d5acf33ab3f680111cfa7871/gcc%2Ftestsuite%2Fgfortran.dg%2Fchar_result_15.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fchar_result_15.f90?ref=345bd7ebbb38f0e1d5acf33ab3f680111cfa7871", "patch": "@@ -0,0 +1,44 @@\n+! { dg-do run }\n+!\n+! Tests the fix for PR44265. This test arose because of an issue found\n+! during the development of the fix; namely the clash between the normal\n+! module parameter and that found in the specification expression for\n+! 'Get'.\n+!\n+! Contributed by Paul Thomas  <pault@gcc.gnu.org>\n+!\n+MODULE Fruits\n+  IMPLICIT NONE\n+  PRIVATE\n+  character (20) :: buffer\n+  PUBLIC :: Get, names, fruity, buffer\n+    CHARACTER(len=7), PARAMETER :: names(3) = [  &\n+        'Pomme  ',  &\n+        'Orange ',  &\n+        'Mangue ' ];\n+CONTAINS\n+  FUNCTION Get(i) RESULT(s)\n+    CHARACTER(len=7), PARAMETER :: names(3) = [  &\n+        'Apple  ',  &\n+        'Orange ',  &\n+        'Mango  ' ];\n+    INTEGER, INTENT(IN) :: i\n+    CHARACTER(LEN_TRIM(names(i))) :: s\n+    s = names(i)\n+  END FUNCTION Get\n+  subroutine fruity (i)\n+    integer :: i\n+  write (buffer, '(i2,a)') len (Get (i)), Get (i)\n+  end subroutine\n+END MODULE Fruits\n+\n+PROGRAM WheresThatbLinkingConstantGone\n+  USE Fruits\n+  IMPLICIT NONE\n+  integer :: i\n+  write (buffer, '(i2,a)') len (Get (1)), Get (1)\n+  if (trim (buffer) .ne. \" 5Apple\") call abort\n+  call fruity(3)\n+  if (trim (buffer) .ne. \" 5Mango\") call abort\n+  if (trim (names(3)) .ne. \"Mangue\") Call abort\n+END PROGRAM WheresThatbLinkingConstantGone"}]}