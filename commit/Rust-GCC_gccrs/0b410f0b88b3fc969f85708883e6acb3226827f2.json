{"sha": "0b410f0b88b3fc969f85708883e6acb3226827f2", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MGI0MTBmMGI4OGIzZmM5NjlmODU3MDg4ODNlNmFjYjMyMjY4MjdmMg==", "commit": {"author": {"name": "Joseph Myers", "email": "jsm@polyomino.org.uk", "date": "2004-08-26T21:30:26Z"}, "committer": {"name": "Joseph Myers", "email": "jsm28@gcc.gnu.org", "date": "2004-08-26T21:30:26Z"}, "message": "re PR c/13801 (Decls should regain old type at end of scope)\n\n\tPR c/13801\n\t* c-decl.c (struct c_binding): Add type and inner_comp fields.\n\t(bind): Set type and inner_comp fields.\n\t(pop_scope): Restore type of decl to the correct type from an\n\touter scope.  Give error when popping file scope for incomplete\n\tarrays completed incompatibly with default initialization in an\n\tinner scope.\n\t(diagnose_mismatched_decls): Handle externs with initializers at\n\tblock scope.\n\t(pushdecl): Set type of external declaration at block scope based\n\tonly on the visible declarations.  Save type when changing the\n\ttype of a declaration.  Merge an external declaration at block\n\tscope with a visible static declaration at file scope.\n\t(implicitly_declare): Give recycled old declaration the new type\n\texcept for incompatible declarations of built-in functions, saving\n\tthe old type.\n\ntestsuite:\n\t* gcc.dg/redecl-3.c, gcc.dg/redecl-4.c, gcc.dg/redecl-6.c,\n\tgcc.dg/redecl-7.c, gcc.dg/redecl-8.c, gcc.dg/redecl-9.c,\n\tgcc.dg/redecl-10.c, gcc.dg/debug/redecl-1.c,\n\tgcc.dg/debug/redecl-2.c, gcc.dg/debug/redecl-3.c,\n\tgcc.dg/debug/redecl-4.c, gcc.dg/debug/redecl-5.c: New tests.\n\nFrom-SVN: r86636", "tree": {"sha": "73149f504f957d92e288572227263a1e93f7495d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/73149f504f957d92e288572227263a1e93f7495d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0b410f0b88b3fc969f85708883e6acb3226827f2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0b410f0b88b3fc969f85708883e6acb3226827f2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0b410f0b88b3fc969f85708883e6acb3226827f2", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0b410f0b88b3fc969f85708883e6acb3226827f2/comments", "author": {"login": "jsm28", "id": 10537793, "node_id": "MDQ6VXNlcjEwNTM3Nzkz", "avatar_url": "https://avatars.githubusercontent.com/u/10537793?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jsm28", "html_url": "https://github.com/jsm28", "followers_url": "https://api.github.com/users/jsm28/followers", "following_url": "https://api.github.com/users/jsm28/following{/other_user}", "gists_url": "https://api.github.com/users/jsm28/gists{/gist_id}", "starred_url": "https://api.github.com/users/jsm28/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jsm28/subscriptions", "organizations_url": "https://api.github.com/users/jsm28/orgs", "repos_url": "https://api.github.com/users/jsm28/repos", "events_url": "https://api.github.com/users/jsm28/events{/privacy}", "received_events_url": "https://api.github.com/users/jsm28/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jsm28", "id": 10537793, "node_id": "MDQ6VXNlcjEwNTM3Nzkz", "avatar_url": "https://avatars.githubusercontent.com/u/10537793?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jsm28", "html_url": "https://github.com/jsm28", "followers_url": "https://api.github.com/users/jsm28/followers", "following_url": "https://api.github.com/users/jsm28/following{/other_user}", "gists_url": "https://api.github.com/users/jsm28/gists{/gist_id}", "starred_url": "https://api.github.com/users/jsm28/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jsm28/subscriptions", "organizations_url": "https://api.github.com/users/jsm28/orgs", "repos_url": "https://api.github.com/users/jsm28/repos", "events_url": "https://api.github.com/users/jsm28/events{/privacy}", "received_events_url": "https://api.github.com/users/jsm28/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "df6e87bf752c78351c8a40c5c824f312e2199621", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/df6e87bf752c78351c8a40c5c824f312e2199621", "html_url": "https://github.com/Rust-GCC/gccrs/commit/df6e87bf752c78351c8a40c5c824f312e2199621"}], "stats": {"total": 1952, "additions": 1938, "deletions": 14}, "files": [{"sha": "e7d5e8bfd4498f3cb8b1773ae3005d904c0fb991", "filename": "gcc/ChangeLog", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0b410f0b88b3fc969f85708883e6acb3226827f2/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0b410f0b88b3fc969f85708883e6acb3226827f2/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=0b410f0b88b3fc969f85708883e6acb3226827f2", "patch": "@@ -1,3 +1,22 @@\n+2004-08-26  Joseph S. Myers  <jsm@polyomino.org.uk>\n+\n+\tPR c/13801\n+\t* c-decl.c (struct c_binding): Add type and inner_comp fields.\n+\t(bind): Set type and inner_comp fields.\n+\t(pop_scope): Restore type of decl to the correct type from an\n+\touter scope.  Give error when popping file scope for incomplete\n+\tarrays completed incompatibly with default initialization in an\n+\tinner scope.\n+\t(diagnose_mismatched_decls): Handle externs with initializers at\n+\tblock scope.\n+\t(pushdecl): Set type of external declaration at block scope based\n+\tonly on the visible declarations.  Save type when changing the\n+\ttype of a declaration.  Merge an external declaration at block\n+\tscope with a visible static declaration at file scope.\n+\t(implicitly_declare): Give recycled old declaration the new type\n+\texcept for incompatible declarations of built-in functions, saving\n+\tthe old type.\n+\n 2004-08-26  Ziemowit Laski  <zlaski@apple.com>\n \n \t* c-parse.in (OBJC_TYPE_QUAL): New %token for ObjC use."}, {"sha": "a8f25304c794565246144f2637b469018e86c6df", "filename": "gcc/c-decl.c", "status": "modified", "additions": 137, "deletions": 14, "changes": 151, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0b410f0b88b3fc969f85708883e6acb3226827f2/gcc%2Fc-decl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0b410f0b88b3fc969f85708883e6acb3226827f2/gcc%2Fc-decl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-decl.c?ref=0b410f0b88b3fc969f85708883e6acb3226827f2", "patch": "@@ -164,6 +164,16 @@ bool c_override_global_bindings_to_false;\n    suppress further errors about that identifier in the current\n    function.\n \n+   The ->type field stores the type of the declaration in this scope;\n+   if NULL, the type is the type of the ->decl field.  This is only of\n+   relevance for objects with external or internal linkage which may\n+   be redeclared in inner scopes, forming composite types that only\n+   persist for the duration of those scopes.  In the external scope,\n+   this stores the composite of all the types declared for this\n+   object, visible or not.  The ->inner_comp field (used only at file\n+   scope) stores whether an incomplete array type at file scope was\n+   completed at an inner scope to an array size other than 1.\n+\n    The depth field is copied from the scope structure that holds this\n    decl.  It is used to preserve the proper ordering of the ->shadowed\n    field (see bind()) and also for a handful of special-case checks.\n@@ -176,13 +186,15 @@ bool c_override_global_bindings_to_false;\n struct c_binding GTY((chain_next (\"%h.prev\")))\n {\n   tree decl;\t\t\t/* the decl bound */\n+  tree type;\t\t\t/* the type in this scope */\n   tree id;\t\t\t/* the identifier it's bound to */\n   struct c_binding *prev;\t/* the previous decl in this scope */\n   struct c_binding *shadowed;\t/* the innermost decl shadowed by this one */\n   unsigned int depth : 28;      /* depth of this scope */\n   BOOL_BITFIELD invisible : 1;  /* normal lookup should ignore this binding */\n   BOOL_BITFIELD nested : 1;     /* do not set DECL_CONTEXT when popping */\n-  /* two free bits */\n+  BOOL_BITFIELD inner_comp : 1; /* incomplete array completed in inner scope */\n+  /* one free bit */\n };\n #define B_IN_SCOPE(b1, b2) ((b1)->depth == (b2)->depth)\n #define B_IN_CURRENT_SCOPE(b) ((b)->depth == current_scope->depth)\n@@ -436,6 +448,9 @@ bind (tree name, tree decl, struct c_scope *scope, bool invisible, bool nested)\n   b->depth = scope->depth;\n   b->invisible = invisible;\n   b->nested = nested;\n+  b->inner_comp = 0;\n+\n+  b->type = 0;\n \n   b->prev = scope->bindings;\n   scope->bindings = b;\n@@ -758,6 +773,12 @@ pop_scope (void)\n \t      && scope != external_scope)\n \t    warning (\"%Junused variable `%D'\", p, p);\n \n+\t  if (b->inner_comp)\n+\t    {\n+\t      error (\"%Jtype of array %qD completed incompatibly with\"\n+\t\t     \" implicit initialization\", p, p);\n+\t    }\n+\n \t  /* Fall through.  */\n \tcase TYPE_DECL:\n \tcase CONST_DECL:\n@@ -797,6 +818,8 @@ pop_scope (void)\n \t      if (I_SYMBOL_BINDING (b->id) != b) abort ();\n #endif\n \t      I_SYMBOL_BINDING (b->id) = b->shadowed;\n+\t      if (b->shadowed && b->shadowed->type)\n+\t\tTREE_TYPE (b->shadowed->decl) = b->shadowed->type;\n \t    }\n \t  break;\n \n@@ -1357,15 +1380,23 @@ diagnose_mismatched_decls (tree newdecl, tree olddecl,\n       else if (!DECL_FILE_SCOPE_P (newdecl))\n \t{\n \t  if (DECL_EXTERNAL (newdecl))\n-\t    abort ();\n+\t    {\n+\t      /* Extern with initializer at block scope, which will\n+\t\t already have received an error.  */\n+\t    }\n \t  else if (DECL_EXTERNAL (olddecl))\n-\t    error (\"%Jdeclaration of '%D' with no linkage follows \"\n-\t\t   \"extern declaration\", newdecl, newdecl);\n+\t    {\n+\t      error (\"%Jdeclaration of '%D' with no linkage follows \"\n+\t\t     \"extern declaration\", newdecl, newdecl);\n+\t      locate_old_decl (olddecl, error);\n+\t    }\n \t  else\n-\t    error (\"%Jredeclaration of '%D' with no linkage\",\n-\t\t   newdecl, newdecl);\n+\t    {\n+\t      error (\"%Jredeclaration of '%D' with no linkage\",\n+\t\t     newdecl, newdecl);\n+\t      locate_old_decl (olddecl, error);\n+\t    }\n \n-\t  locate_old_decl (olddecl, error);\n \t  return false;\n \t}\n     }\n@@ -1895,6 +1926,9 @@ pushdecl (tree x)\n   b = I_SYMBOL_BINDING (name);\n   if (b && B_IN_SCOPE (b, scope))\n     {\n+      if (TREE_CODE (TREE_TYPE (x)) == ARRAY_TYPE\n+\t  && COMPLETE_TYPE_P (TREE_TYPE (x)))\n+\tb->inner_comp = false;\n       if (duplicate_decls (x, b->decl))\n \treturn b->decl;\n       else\n@@ -1915,13 +1949,63 @@ pushdecl (tree x)\n      have compatible type; otherwise, the behavior is undefined.)  */\n   if (DECL_EXTERNAL (x) || scope == file_scope)\n     {\n+      tree type = TREE_TYPE (x);\n+      tree vistype = 0;\n+      tree visdecl = 0;\n+      bool type_saved = false;\n+      if (b && !B_IN_EXTERNAL_SCOPE (b)\n+\t  && (TREE_CODE (b->decl) == FUNCTION_DECL\n+\t      || TREE_CODE (b->decl) == VAR_DECL)\n+\t  && DECL_FILE_SCOPE_P (b->decl))\n+\t{\n+\t  visdecl = b->decl;\n+\t  vistype = TREE_TYPE (visdecl);\n+\t}\n       if (warn_nested_externs\n \t  && scope != file_scope\n \t  && !DECL_IN_SYSTEM_HEADER (x))\n \twarning (\"nested extern declaration of '%D'\", x);\n \n       while (b && !B_IN_EXTERNAL_SCOPE (b))\n-\tb = b->shadowed;\n+\t{\n+\t  /* If this decl might be modified, save its type.  This is\n+\t     done here rather than when the decl is first bound\n+\t     because the type may change after first binding, through\n+\t     being completed or through attributes being added.  If we\n+\t     encounter multiple such decls, only the first should have\n+\t     its type saved; the others will already have had their\n+\t     proper types saved and the types will not have changed as\n+\t     their scopes will not have been re-entered.  */\n+\t  if (DECL_FILE_SCOPE_P (b->decl) && !type_saved)\n+\t    {\n+\t      b->type = TREE_TYPE (b->decl);\n+\t      type_saved = true;\n+\t    }\n+\t  if (B_IN_FILE_SCOPE (b)\n+\t      && TREE_CODE (b->decl) == VAR_DECL\n+\t      && TREE_STATIC (b->decl)\n+\t      && TREE_CODE (TREE_TYPE (b->decl)) == ARRAY_TYPE\n+\t      && !TYPE_DOMAIN (TREE_TYPE (b->decl))\n+\t      && TREE_CODE (type) == ARRAY_TYPE\n+\t      && TYPE_DOMAIN (type)\n+\t      && TYPE_MAX_VALUE (TYPE_DOMAIN (type))\n+\t      && !integer_zerop (TYPE_MAX_VALUE (TYPE_DOMAIN (type))))\n+\t    {\n+\t      /* Array type completed in inner scope, which should be\n+\t\t diagnosed if the completion does not have size 1 and\n+\t\t it does not get completed in the file scope.  */\n+\t      b->inner_comp = true;\n+\t    }\n+\t  b = b->shadowed;\n+\t}\n+\n+      /* If a matching external declaration has been found, set its\n+\t type to the composite of all the types of that declaration.\n+\t After the consistency checks, it will be reset to the\n+\t composite of the visible types only.  */\n+      if (b && (TREE_PUBLIC (x) || same_translation_unit_p (x, b->decl))\n+\t  && b->type)\n+\tTREE_TYPE (b->decl) = b->type;\n \n       /* The point of the same_translation_unit_p check here is,\n \t we want to detect a duplicate decl for a construct like\n@@ -1932,13 +2016,34 @@ pushdecl (tree x)\n \t  && (TREE_PUBLIC (x) || same_translation_unit_p (x, b->decl))\n \t  && duplicate_decls (x, b->decl))\n \t{\n+\t  tree thistype;\n+\t  thistype = (vistype ? composite_type (vistype, type) : type);\n+\t  b->type = TREE_TYPE (b->decl);\n+\t  if (TREE_CODE (b->decl) == FUNCTION_DECL && DECL_BUILT_IN (b->decl))\n+\t    thistype\n+\t      = build_type_attribute_variant (thistype,\n+\t\t\t\t\t      TYPE_ATTRIBUTES (b->type));\n+\t  TREE_TYPE (b->decl) = thistype;\n \t  bind (name, b->decl, scope, /*invisible=*/false, /*nested=*/true);\n \t  return b->decl;\n \t}\n       else if (TREE_PUBLIC (x))\n \t{\n-\t  bind (name, x, external_scope, /*invisible=*/true, /*nested=*/false);\n-\t  nested = true;\n+\t  if (visdecl && !b && duplicate_decls (x, visdecl))\n+\t    {\n+\t      /* An external declaration at block scope referring to a\n+\t\t visible entity with internal linkage.  The composite\n+\t\t type will already be correct for this scope, so we\n+\t\t just need to fall through to make the declaration in\n+\t\t this scope.  */\n+\t      nested = true;\n+\t    }\n+\t  else\n+\t    {\n+\t      bind (name, x, external_scope, /*invisible=*/true,\n+\t\t    /*nested=*/false);\n+\t      nested = true;\n+\t    }\n \t}\n     }\n   /* Similarly, a declaration of a function with static linkage at\n@@ -2056,7 +2161,16 @@ implicit_decl_warning (tree id, tree olddecl)\n tree\n implicitly_declare (tree functionid)\n {\n-  tree decl = lookup_name_in_scope (functionid, external_scope);\n+  struct c_binding *b;\n+  tree decl = 0;\n+  for (b = I_SYMBOL_BINDING (functionid); b; b = b->shadowed)\n+    {\n+      if (B_IN_SCOPE (b, external_scope))\n+\t{\n+\t  decl = b->decl;\n+\t  break;\n+\t}\n+    }\n \n   if (decl)\n     {\n@@ -2073,32 +2187,41 @@ implicitly_declare (tree functionid)\n \t}\n       else\n \t{\n+\t  tree newtype = default_function_type;\n+\t  if (b->type)\n+\t    TREE_TYPE (decl) = b->type;\n \t  /* Implicit declaration of a function already declared\n \t     (somehow) in a different scope, or as a built-in.\n \t     If this is the first time this has happened, warn;\n-\t     then recycle the old declaration.  */\n+\t     then recycle the old declaration but with the new type.  */\n \t  if (!C_DECL_IMPLICIT (decl))\n \t    {\n \t      implicit_decl_warning (functionid, decl);\n \t      C_DECL_IMPLICIT (decl) = 1;\n \t    }\n \t  if (DECL_BUILT_IN (decl))\n \t    {\n-\t      if (!comptypes (default_function_type, TREE_TYPE (decl)))\n+\t      newtype = build_type_attribute_variant (newtype,\n+\t\t\t\t\t\t      TYPE_ATTRIBUTES\n+\t\t\t\t\t\t      (TREE_TYPE (decl)));\n+\t      if (!comptypes (newtype, TREE_TYPE (decl)))\n \t\t{\n \t\t  warning (\"incompatible implicit declaration of built-in\"\n \t\t\t   \" function %qD\", decl);\n+\t\t  newtype = TREE_TYPE (decl);\n \t\t}\n \t    }\n \t  else\n \t    {\n-\t      if (!comptypes (default_function_type, TREE_TYPE (decl)))\n+\t      if (!comptypes (newtype, TREE_TYPE (decl)))\n \t\t{\n \t\t  error (\"incompatible implicit declaration of function %qD\",\n \t\t\t decl);\n \t\t  locate_old_decl (decl, error);\n \t\t}\n \t    }\n+\t  b->type = TREE_TYPE (decl);\n+\t  TREE_TYPE (decl) = newtype;\n \t  bind (functionid, decl, current_scope,\n \t\t/*invisible=*/false, /*nested=*/true);\n \t  return decl;"}, {"sha": "9b73b6dea53a30c6211432b56c7e24cbcb6a0a9a", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0b410f0b88b3fc969f85708883e6acb3226827f2/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0b410f0b88b3fc969f85708883e6acb3226827f2/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=0b410f0b88b3fc969f85708883e6acb3226827f2", "patch": "@@ -1,3 +1,12 @@\n+2004-08-26  Joseph S. Myers  <jsm@polyomino.org.uk>\n+\n+\tPR c/13801\n+\t* gcc.dg/redecl-3.c, gcc.dg/redecl-4.c, gcc.dg/redecl-6.c,\n+\tgcc.dg/redecl-7.c, gcc.dg/redecl-8.c, gcc.dg/redecl-9.c,\n+\tgcc.dg/redecl-10.c, gcc.dg/debug/redecl-1.c,\n+\tgcc.dg/debug/redecl-2.c, gcc.dg/debug/redecl-3.c,\n+\tgcc.dg/debug/redecl-4.c, gcc.dg/debug/redecl-5.c: New tests.\n+\n 2004-08-26  Nick Clifton  <nickc@redhat.com>\n \n \t* gcc.c-torture/compile/pr17119.c: New test."}, {"sha": "14a453e042bf69904925884ee86e14b14195e966", "filename": "gcc/testsuite/gcc.dg/debug/redecl-1.c", "status": "added", "additions": 352, "deletions": 0, "changes": 352, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0b410f0b88b3fc969f85708883e6acb3226827f2/gcc%2Ftestsuite%2Fgcc.dg%2Fdebug%2Fredecl-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0b410f0b88b3fc969f85708883e6acb3226827f2/gcc%2Ftestsuite%2Fgcc.dg%2Fdebug%2Fredecl-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fdebug%2Fredecl-1.c?ref=0b410f0b88b3fc969f85708883e6acb3226827f2", "patch": "@@ -0,0 +1,352 @@\n+/* Test for multiple declarations and composite types.  As in bug\n+   13801.  Test no problems in debug information generation.  */\n+/* Origin: Joseph Myers <jsm@polyomino.org.uk> */\n+/* { dg-do compile } */\n+/* { dg-options \"\" } */\n+\n+typedef int IA[];\n+typedef int A10[10];\n+\n+/* Test all combinations of: a variable declared at file scope (no\n+   type specifiers, or extern, or static), or just inside a function\n+   (with extern), redeclared in an inner scope (with extern), and\n+   redeclared in an inner scope when the previous declaration is\n+   hidden (with extern, and not if the original declaration was\n+   static).  Test three times: incomplete variable types; pointers to\n+   incomplete types; functions returning such pointers.\n+\n+   This test only includes the valid code cases, to test debug info\n+   generation.  (Incomplete static at file scope is not permitted by\n+   ISO C, but is accepted by GCC as an extension without\n+   -pedantic.)  */\n+\n+A10 a5;\n+void\n+f5 (void)\n+{\n+  sizeof(a5);\n+  {\n+    extern IA a5;\n+    sizeof(a5);\n+    {\n+      int a5;\n+      {\n+        extern A10 a5;\n+        sizeof(a5);\n+      }\n+    }\n+    sizeof(a5);\n+  }\n+  sizeof(a5);\n+}\n+extern A10 a5;\n+\n+A10 a7;\n+void\n+f7 (void)\n+{\n+  sizeof(a7);\n+  {\n+    extern A10 a7;\n+    sizeof(a7);\n+    {\n+      int a7;\n+      {\n+        extern A10 a7;\n+        sizeof(a7);\n+      }\n+    }\n+    sizeof(a7);\n+  }\n+  sizeof(a7);\n+}\n+extern A10 a7;\n+\n+extern A10 a13;\n+void\n+f13 (void)\n+{\n+  sizeof(a13);\n+  {\n+    extern IA a13;\n+    sizeof(a13);\n+    {\n+      int a13;\n+      {\n+        extern A10 a13;\n+        sizeof(a13);\n+      }\n+    }\n+    sizeof(a13);\n+  }\n+  sizeof(a13);\n+}\n+extern A10 a13;\n+\n+extern A10 a15;\n+void\n+f15 (void)\n+{\n+  sizeof(a15);\n+  {\n+    extern A10 a15;\n+    sizeof(a15);\n+    {\n+      int a15;\n+      {\n+        extern A10 a15;\n+        sizeof(a15);\n+      }\n+    }\n+    sizeof(a15);\n+  }\n+  sizeof(a15);\n+}\n+extern A10 a15;\n+\n+\n+static A10 a18;\n+void\n+f18 (void)\n+{\n+  sizeof(a18);\n+  {\n+    extern IA a18;\n+    sizeof(a18);\n+  }\n+  sizeof(a18);\n+}\n+extern A10 a18;\n+\n+static A10 a19;\n+void\n+f19 (void)\n+{\n+  sizeof(a19);\n+  {\n+    extern A10 a19;\n+    sizeof(a19);\n+  }\n+  sizeof(a19);\n+}\n+extern A10 a19;\n+\n+A10 *b5;\n+void\n+g5 (void)\n+{\n+  sizeof(*b5);\n+  {\n+    extern IA *b5;\n+    sizeof(*b5);\n+    {\n+      int b5;\n+      {\n+        extern A10 *b5;\n+        sizeof(*b5);\n+      }\n+    }\n+    sizeof(*b5);\n+  }\n+  sizeof(*b5);\n+}\n+extern A10 *b5;\n+\n+A10 *b7;\n+void\n+g7 (void)\n+{\n+  sizeof(*b7);\n+  {\n+    extern A10 *b7;\n+    sizeof(*b7);\n+    {\n+      int b7;\n+      {\n+        extern A10 *b7;\n+        sizeof(*b7);\n+      }\n+    }\n+    sizeof(*b7);\n+  }\n+  sizeof(*b7);\n+}\n+extern A10 *b7;\n+\n+extern A10 *b13;\n+void\n+g13 (void)\n+{\n+  sizeof(*b13);\n+  {\n+    extern IA *b13;\n+    sizeof(*b13);\n+    {\n+      int b13;\n+      {\n+        extern A10 *b13;\n+        sizeof(*b13);\n+      }\n+    }\n+    sizeof(*b13);\n+  }\n+  sizeof(*b13);\n+}\n+extern A10 *b13;\n+\n+extern A10 *b15;\n+void\n+g15 (void)\n+{\n+  sizeof(*b15);\n+  {\n+    extern A10 *b15;\n+    sizeof(*b15);\n+    {\n+      int b15;\n+      {\n+        extern A10 *b15;\n+        sizeof(*b15);\n+      }\n+    }\n+    sizeof(*b15);\n+  }\n+  sizeof(*b15);\n+}\n+extern A10 *b15;\n+\n+static A10 *b18;\n+void\n+g18 (void)\n+{\n+  sizeof(*b18);\n+  {\n+    extern IA *b18;\n+    sizeof(*b18);\n+  }\n+  sizeof(*b18);\n+}\n+extern A10 *b18;\n+\n+static A10 *b19;\n+void\n+g19 (void)\n+{\n+  sizeof(*b19);\n+  {\n+    extern A10 *b19;\n+    sizeof(*b19);\n+  }\n+  sizeof(*b19);\n+}\n+extern A10 *b19;\n+\n+A10 *c5 (void);\n+void\n+h5 (void)\n+{\n+  sizeof(*c5());\n+  {\n+    extern IA *c5 (void);\n+    sizeof(*c5());\n+    {\n+      int c5;\n+      {\n+        extern A10 *c5 (void);\n+        sizeof(*c5());\n+      }\n+    }\n+    sizeof(*c5());\n+  }\n+  sizeof(*c5());\n+}\n+A10 *c5 (void) { return 0; }\n+\n+A10 *c7 (void);\n+void\n+h7 (void)\n+{\n+  sizeof(*c7());\n+  {\n+    extern A10 *c7 (void);\n+    sizeof(*c7());\n+    {\n+      int c7;\n+      {\n+        extern A10 *c7 (void);\n+        sizeof(*c7());\n+      }\n+    }\n+    sizeof(*c7());\n+  }\n+  sizeof(*c7());\n+}\n+A10 *c7 (void) { return 0; }\n+\n+extern A10 *c13 (void);\n+void\n+h13 (void)\n+{\n+  sizeof(*c13());\n+  {\n+    extern IA *c13 (void);\n+    sizeof(*c13());\n+    {\n+      int c13;\n+      {\n+        extern A10 *c13 (void);\n+        sizeof(*c13());\n+      }\n+    }\n+    sizeof(*c13());\n+  }\n+  sizeof(*c13());\n+}\n+extern A10 *c13 (void) { return 0; }\n+\n+extern A10 *c15 (void);\n+void\n+h15 (void)\n+{\n+  sizeof(*c15());\n+  {\n+    extern A10 *c15 (void);\n+    sizeof(*c15());\n+    {\n+      int c15;\n+      {\n+        extern A10 *c15 (void);\n+        sizeof(*c15());\n+      }\n+    }\n+    sizeof(*c15());\n+  }\n+  sizeof(*c15());\n+}\n+extern A10 *c15 (void) { return 0; }\n+\n+static A10 *c18 (void);\n+void\n+h18 (void)\n+{\n+  sizeof(*c18());\n+  {\n+    extern IA *c18 (void);\n+    sizeof(*c18());\n+  }\n+  sizeof(*c18());\n+}\n+static A10 *c18 (void) { return 0; }\n+\n+static A10 *c19 (void);\n+void\n+h19 (void)\n+{\n+  sizeof(*c19());\n+  {\n+    extern A10 *c19 (void);\n+    sizeof(*c19());\n+  }\n+  sizeof(*c19());\n+}\n+static A10 *c19 (void) { return 0; }"}, {"sha": "2bf661fdcf0f479600e70604ab6e61a98471e2a3", "filename": "gcc/testsuite/gcc.dg/debug/redecl-2.c", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0b410f0b88b3fc969f85708883e6acb3226827f2/gcc%2Ftestsuite%2Fgcc.dg%2Fdebug%2Fredecl-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0b410f0b88b3fc969f85708883e6acb3226827f2/gcc%2Ftestsuite%2Fgcc.dg%2Fdebug%2Fredecl-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fdebug%2Fredecl-2.c?ref=0b410f0b88b3fc969f85708883e6acb3226827f2", "patch": "@@ -0,0 +1,24 @@\n+/* Test for multiple declarations and composite types.  As in bug\n+   13801.  Illustrates how bug causes correct code to be wrongly\n+   diagnosed.  Debug test: avoid ICE.  */\n+/* Origin: Joseph Myers <jsm@polyomino.org.uk> */\n+/* { dg-do compile } */\n+/* { dg-options \"\" } */\n+\n+typedef int IA[];\n+typedef int A5[5];\n+typedef int A10[10];\n+\n+A10 array10;\n+\n+A5 *ap;\n+void\n+f (void)\n+{\n+  int ap;\n+  {\n+    extern IA *ap;\n+    /* This assignment is valid.  */\n+    ap = &array10;\n+  }\n+}"}, {"sha": "3f0c053a21de30909c5567a6af28696b9f0f3252", "filename": "gcc/testsuite/gcc.dg/debug/redecl-3.c", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0b410f0b88b3fc969f85708883e6acb3226827f2/gcc%2Ftestsuite%2Fgcc.dg%2Fdebug%2Fredecl-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0b410f0b88b3fc969f85708883e6acb3226827f2/gcc%2Ftestsuite%2Fgcc.dg%2Fdebug%2Fredecl-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fdebug%2Fredecl-3.c?ref=0b410f0b88b3fc969f85708883e6acb3226827f2", "patch": "@@ -0,0 +1,12 @@\n+/* Test for multiple declarations and composite types.  */\n+\n+/* Origin: Joseph Myers <jsm@polyomino.org.uk> */\n+/* { dg-do compile } */\n+/* { dg-options \"\" } */\n+\n+int y[];\n+void\n+g (void)\n+{\n+  extern int y[1];\n+}"}, {"sha": "aac4ee7d4d5f275caf1033a23ff4825fb47de296", "filename": "gcc/testsuite/gcc.dg/debug/redecl-4.c", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0b410f0b88b3fc969f85708883e6acb3226827f2/gcc%2Ftestsuite%2Fgcc.dg%2Fdebug%2Fredecl-4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0b410f0b88b3fc969f85708883e6acb3226827f2/gcc%2Ftestsuite%2Fgcc.dg%2Fdebug%2Fredecl-4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fdebug%2Fredecl-4.c?ref=0b410f0b88b3fc969f85708883e6acb3226827f2", "patch": "@@ -0,0 +1,12 @@\n+/* Test for multiple declarations and composite types.  */\n+\n+/* Origin: Joseph Myers <jsm@polyomino.org.uk> */\n+/* { dg-do compile } */\n+/* { dg-options \"\" } */\n+\n+static int y[];\n+void\n+g (void)\n+{\n+  extern int y[1];\n+}"}, {"sha": "b915b3fdf5eb106aaf15eada14a84eba9736e27d", "filename": "gcc/testsuite/gcc.dg/debug/redecl-5.c", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0b410f0b88b3fc969f85708883e6acb3226827f2/gcc%2Ftestsuite%2Fgcc.dg%2Fdebug%2Fredecl-5.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0b410f0b88b3fc969f85708883e6acb3226827f2/gcc%2Ftestsuite%2Fgcc.dg%2Fdebug%2Fredecl-5.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fdebug%2Fredecl-5.c?ref=0b410f0b88b3fc969f85708883e6acb3226827f2", "patch": "@@ -0,0 +1,31 @@\n+/* Test for multiple declarations and composite types, as in bug\n+   13801.  Test types saved from outer scopes are up to date.  Debug\n+   test.  */\n+/* Origin: Joseph Myers <jsm@polyomino.org.uk> */\n+/* { dg-do compile } */\n+/* { dg-options \"\" } */\n+\n+int x[];\n+\n+void\n+f (void)\n+{\n+  extern int x[];\n+}\n+\n+int x[10];\n+\n+void\n+g (void)\n+{\n+  int x;\n+  {\n+    extern int x[10];\n+  }\n+}\n+\n+void\n+h (void)\n+{\n+  sizeof (x);\n+}"}, {"sha": "88d804e6cfd67f1e898a1444c71beebf9eee8c9d", "filename": "gcc/testsuite/gcc.dg/redecl-10.c", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0b410f0b88b3fc969f85708883e6acb3226827f2/gcc%2Ftestsuite%2Fgcc.dg%2Fredecl-10.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0b410f0b88b3fc969f85708883e6acb3226827f2/gcc%2Ftestsuite%2Fgcc.dg%2Fredecl-10.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fredecl-10.c?ref=0b410f0b88b3fc969f85708883e6acb3226827f2", "patch": "@@ -0,0 +1,34 @@\n+/* Test for multiple declarations and composite types.  Check we don't\n+   ICE with nested initializers.  */\n+\n+/* Origin: Joseph Myers <jsm@polyomino.org.uk> */\n+/* { dg-do compile } */\n+/* { dg-options \"-g\" } */\n+\n+static int w[];\n+void\n+f (void)\n+{\n+  extern int w[] = { 1, 2 }; /* { dg-error \"has both\" } */\n+}\n+\n+int x[];\n+void\n+g (void)\n+{\n+  extern int x[] = { 3, 4, 5 }; /* { dg-error \"has both\" } */\n+}\n+\n+static int y[];\n+void\n+h (void)\n+{\n+  extern int y[] = { 6 }; /* { dg-error \"has both\" } */\n+}\n+\n+int z[];\n+void\n+i (void)\n+{\n+  extern int z[] = { 7 }; /* { dg-error \"has both\" } */\n+}"}, {"sha": "3181712f0c9e0ba894c5b8a33a0950dc15dfd354", "filename": "gcc/testsuite/gcc.dg/redecl-3.c", "status": "added", "additions": 1180, "deletions": 0, "changes": 1180, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0b410f0b88b3fc969f85708883e6acb3226827f2/gcc%2Ftestsuite%2Fgcc.dg%2Fredecl-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0b410f0b88b3fc969f85708883e6acb3226827f2/gcc%2Ftestsuite%2Fgcc.dg%2Fredecl-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fredecl-3.c?ref=0b410f0b88b3fc969f85708883e6acb3226827f2", "patch": "@@ -0,0 +1,1180 @@\n+/* Test for multiple declarations and composite types.  Includes bug\n+   13801.  */\n+/* Origin: Joseph Myers <jsm@polyomino.org.uk> */\n+/* { dg-do compile } */\n+/* { dg-options \"-g\" } */\n+\n+typedef int IA[];\n+typedef int A10[10];\n+\n+/* Test all combinations of: a variable declared at file scope (no\n+   type specifiers, or extern, or static), or just inside a function\n+   (with extern), redeclared in an inner scope (with extern), and\n+   redeclared in an inner scope when the previous declaration is\n+   hidden (with extern, and not if the original declaration was\n+   static).  Test three times: incomplete variable types; pointers to\n+   incomplete types; functions returning such pointers.  */\n+\n+IA a0;\n+void\n+f0 (void)\n+{\n+  sizeof(a0); /* { dg-error \"incomplete\" } */\n+  {\n+    extern IA a0;\n+    sizeof(a0); /* { dg-error \"incomplete\" } */\n+    {\n+      int a0;\n+      {\n+        extern IA a0;\n+        sizeof(a0); /* { dg-error \"incomplete\" } */\n+      }\n+    }\n+    sizeof(a0); /* { dg-error \"incomplete\" } */\n+  }\n+  sizeof(a0); /* { dg-error \"incomplete\" } */\n+}\n+extern A10 a0;\n+\n+IA a1;\n+void\n+f1 (void)\n+{\n+  sizeof(a1); /* { dg-error \"incomplete\" } */\n+  {\n+    extern IA a1;\n+    sizeof(a1); /* { dg-error \"incomplete\" } */\n+    {\n+      int a1;\n+      {\n+        extern A10 a1;\n+        sizeof(a1);\n+      }\n+    }\n+    sizeof(a1); /* { dg-error \"incomplete\" } */\n+  }\n+  sizeof(a1); /* { dg-error \"incomplete\" } */\n+}\n+extern A10 a1;\n+\n+IA a2;\n+void\n+f2 (void)\n+{\n+  sizeof(a2); /* { dg-error \"incomplete\" } */\n+  {\n+    extern A10 a2;\n+    sizeof(a2);\n+    {\n+      int a2;\n+      {\n+        extern IA a2;\n+        sizeof(a2); /* { dg-error \"incomplete\" } */\n+      }\n+    }\n+    sizeof(a2);\n+  }\n+  sizeof(a2); /* { dg-error \"incomplete\" } */\n+}\n+extern A10 a2;\n+\n+IA a3;\n+void\n+f3 (void)\n+{\n+  sizeof(a3); /* { dg-error \"incomplete\" } */\n+  {\n+    extern A10 a3;\n+    sizeof(a3);\n+    {\n+      int a3;\n+      {\n+        extern A10 a3;\n+        sizeof(a3);\n+      }\n+    }\n+    sizeof(a3);\n+  }\n+  sizeof(a3); /* { dg-error \"incomplete\" } */\n+}\n+extern A10 a3;\n+\n+A10 a4;\n+void\n+f4 (void)\n+{\n+  sizeof(a4);\n+  {\n+    extern IA a4;\n+    sizeof(a4);\n+    {\n+      int a4;\n+      {\n+        extern IA a4;\n+        sizeof(a4); /* { dg-error \"incomplete\" } */\n+      }\n+    }\n+    sizeof(a4);\n+  }\n+  sizeof(a4);\n+}\n+extern A10 a4;\n+\n+A10 a5;\n+void\n+f5 (void)\n+{\n+  sizeof(a5);\n+  {\n+    extern IA a5;\n+    sizeof(a5);\n+    {\n+      int a5;\n+      {\n+        extern A10 a5;\n+        sizeof(a5);\n+      }\n+    }\n+    sizeof(a5);\n+  }\n+  sizeof(a5);\n+}\n+extern A10 a5;\n+\n+A10 a6;\n+void\n+f6 (void)\n+{\n+  sizeof(a6);\n+  {\n+    extern A10 a6;\n+    sizeof(a6);\n+    {\n+      int a6;\n+      {\n+        extern IA a6;\n+        sizeof(a6); /* { dg-error \"incomplete\" } */\n+      }\n+    }\n+    sizeof(a6);\n+  }\n+  sizeof(a6);\n+}\n+extern A10 a6;\n+\n+A10 a7;\n+void\n+f7 (void)\n+{\n+  sizeof(a7);\n+  {\n+    extern A10 a7;\n+    sizeof(a7);\n+    {\n+      int a7;\n+      {\n+        extern A10 a7;\n+        sizeof(a7);\n+      }\n+    }\n+    sizeof(a7);\n+  }\n+  sizeof(a7);\n+}\n+extern A10 a7;\n+\n+extern IA a8;\n+void\n+f8 (void)\n+{\n+  sizeof(a8); /* { dg-error \"incomplete\" } */\n+  {\n+    extern IA a8;\n+    sizeof(a8); /* { dg-error \"incomplete\" } */\n+    {\n+      int a8;\n+      {\n+        extern IA a8;\n+        sizeof(a8); /* { dg-error \"incomplete\" } */\n+      }\n+    }\n+    sizeof(a8); /* { dg-error \"incomplete\" } */\n+  }\n+  sizeof(a8); /* { dg-error \"incomplete\" } */\n+}\n+extern A10 a8;\n+\n+extern IA a9;\n+void\n+f9 (void)\n+{\n+  sizeof(a9); /* { dg-error \"incomplete\" } */\n+  {\n+    extern IA a9;\n+    sizeof(a9); /* { dg-error \"incomplete\" } */\n+    {\n+      int a9;\n+      {\n+        extern A10 a9;\n+        sizeof(a9);\n+      }\n+    }\n+    sizeof(a9); /* { dg-error \"incomplete\" } */\n+  }\n+  sizeof(a9); /* { dg-error \"incomplete\" } */\n+}\n+extern A10 a9;\n+\n+extern IA a10;\n+void\n+f10 (void)\n+{\n+  sizeof(a10); /* { dg-error \"incomplete\" } */\n+  {\n+    extern A10 a10;\n+    sizeof(a10);\n+    {\n+      int a10;\n+      {\n+        extern IA a10;\n+        sizeof(a10); /* { dg-error \"incomplete\" } */\n+      }\n+    }\n+    sizeof(a10);\n+  }\n+  sizeof(a10); /* { dg-error \"incomplete\" } */\n+}\n+extern A10 a10;\n+\n+extern IA a11;\n+void\n+f11 (void)\n+{\n+  sizeof(a11); /* { dg-error \"incomplete\" } */\n+  {\n+    extern A10 a11;\n+    sizeof(a11);\n+    {\n+      int a11;\n+      {\n+        extern A10 a11;\n+        sizeof(a11);\n+      }\n+    }\n+    sizeof(a11);\n+  }\n+  sizeof(a11); /* { dg-error \"incomplete\" } */\n+}\n+extern A10 a11;\n+\n+extern A10 a12;\n+void\n+f12 (void)\n+{\n+  sizeof(a12);\n+  {\n+    extern IA a12;\n+    sizeof(a12);\n+    {\n+      int a12;\n+      {\n+        extern IA a12;\n+        sizeof(a12); /* { dg-error \"incomplete\" } */\n+      }\n+    }\n+    sizeof(a12);\n+  }\n+  sizeof(a12);\n+}\n+extern A10 a12;\n+\n+extern A10 a13;\n+void\n+f13 (void)\n+{\n+  sizeof(a13);\n+  {\n+    extern IA a13;\n+    sizeof(a13);\n+    {\n+      int a13;\n+      {\n+        extern A10 a13;\n+        sizeof(a13);\n+      }\n+    }\n+    sizeof(a13);\n+  }\n+  sizeof(a13);\n+}\n+extern A10 a13;\n+\n+extern A10 a14;\n+void\n+f14 (void)\n+{\n+  sizeof(a14);\n+  {\n+    extern A10 a14;\n+    sizeof(a14);\n+    {\n+      int a14;\n+      {\n+        extern IA a14;\n+        sizeof(a14); /* { dg-error \"incomplete\" } */\n+      }\n+    }\n+    sizeof(a14);\n+  }\n+  sizeof(a14);\n+}\n+extern A10 a14;\n+\n+extern A10 a15;\n+void\n+f15 (void)\n+{\n+  sizeof(a15);\n+  {\n+    extern A10 a15;\n+    sizeof(a15);\n+    {\n+      int a15;\n+      {\n+        extern A10 a15;\n+        sizeof(a15);\n+      }\n+    }\n+    sizeof(a15);\n+  }\n+  sizeof(a15);\n+}\n+extern A10 a15;\n+\n+static IA a16;\n+void\n+f16 (void)\n+{\n+  sizeof(a16); /* { dg-error \"incomplete\" } */\n+  {\n+    extern IA a16;\n+    sizeof(a16); /* { dg-error \"incomplete\" } */\n+  }\n+  sizeof(a16); /* { dg-error \"incomplete\" } */\n+}\n+extern A10 a16;\n+\n+static IA a17;\n+void\n+f17 (void)\n+{\n+  sizeof(a17); /* { dg-error \"incomplete\" } */\n+  {\n+    extern A10 a17;\n+    sizeof(a17);\n+  }\n+  sizeof(a17); /* { dg-error \"incomplete\" } */\n+}\n+extern A10 a17;\n+\n+static A10 a18;\n+void\n+f18 (void)\n+{\n+  sizeof(a18);\n+  {\n+    extern IA a18;\n+    sizeof(a18);\n+  }\n+  sizeof(a18);\n+}\n+extern A10 a18;\n+\n+static A10 a19;\n+void\n+f19 (void)\n+{\n+  sizeof(a19);\n+  {\n+    extern A10 a19;\n+    sizeof(a19);\n+  }\n+  sizeof(a19);\n+}\n+extern A10 a19;\n+\n+IA *b0;\n+void\n+g0 (void)\n+{\n+  sizeof(*b0); /* { dg-error \"incomplete\" } */\n+  {\n+    extern IA *b0;\n+    sizeof(*b0); /* { dg-error \"incomplete\" } */\n+    {\n+      int b0;\n+      {\n+        extern IA *b0;\n+        sizeof(*b0); /* { dg-error \"incomplete\" } */\n+      }\n+    }\n+    sizeof(*b0); /* { dg-error \"incomplete\" } */\n+  }\n+  sizeof(*b0); /* { dg-error \"incomplete\" } */\n+}\n+extern A10 *b0;\n+\n+IA *b1;\n+void\n+g1 (void)\n+{\n+  sizeof(*b1); /* { dg-error \"incomplete\" } */\n+  {\n+    extern IA *b1;\n+    sizeof(*b1); /* { dg-error \"incomplete\" } */\n+    {\n+      int b1;\n+      {\n+        extern A10 *b1;\n+        sizeof(*b1);\n+      }\n+    }\n+    sizeof(*b1); /* { dg-error \"incomplete\" } */\n+  }\n+  sizeof(*b1); /* { dg-error \"incomplete\" } */\n+}\n+extern A10 *b1;\n+\n+IA *b2;\n+void\n+g2 (void)\n+{\n+  sizeof(*b2); /* { dg-error \"incomplete\" } */\n+  {\n+    extern A10 *b2;\n+    sizeof(*b2);\n+    {\n+      int b2;\n+      {\n+        extern IA *b2;\n+        sizeof(*b2); /* { dg-error \"incomplete\" } */\n+      }\n+    }\n+    sizeof(*b2);\n+  }\n+  sizeof(*b2); /* { dg-error \"incomplete\" } */\n+}\n+extern A10 *b2;\n+\n+IA *b3;\n+void\n+g3 (void)\n+{\n+  sizeof(*b3); /* { dg-error \"incomplete\" } */\n+  {\n+    extern A10 *b3;\n+    sizeof(*b3);\n+    {\n+      int b3;\n+      {\n+        extern A10 *b3;\n+        sizeof(*b3);\n+      }\n+    }\n+    sizeof(*b3);\n+  }\n+  sizeof(*b3); /* { dg-error \"incomplete\" } */\n+}\n+extern A10 *b3;\n+\n+A10 *b4;\n+void\n+g4 (void)\n+{\n+  sizeof(*b4);\n+  {\n+    extern IA *b4;\n+    sizeof(*b4);\n+    {\n+      int b4;\n+      {\n+        extern IA *b4;\n+        sizeof(*b4); /* { dg-error \"incomplete\" } */\n+      }\n+    }\n+    sizeof(*b4);\n+  }\n+  sizeof(*b4);\n+}\n+extern A10 *b4;\n+\n+A10 *b5;\n+void\n+g5 (void)\n+{\n+  sizeof(*b5);\n+  {\n+    extern IA *b5;\n+    sizeof(*b5);\n+    {\n+      int b5;\n+      {\n+        extern A10 *b5;\n+        sizeof(*b5);\n+      }\n+    }\n+    sizeof(*b5);\n+  }\n+  sizeof(*b5);\n+}\n+extern A10 *b5;\n+\n+A10 *b6;\n+void\n+g6 (void)\n+{\n+  sizeof(*b6);\n+  {\n+    extern A10 *b6;\n+    sizeof(*b6);\n+    {\n+      int b6;\n+      {\n+        extern IA *b6;\n+        sizeof(*b6); /* { dg-error \"incomplete\" } */\n+      }\n+    }\n+    sizeof(*b6);\n+  }\n+  sizeof(*b6);\n+}\n+extern A10 *b6;\n+\n+A10 *b7;\n+void\n+g7 (void)\n+{\n+  sizeof(*b7);\n+  {\n+    extern A10 *b7;\n+    sizeof(*b7);\n+    {\n+      int b7;\n+      {\n+        extern A10 *b7;\n+        sizeof(*b7);\n+      }\n+    }\n+    sizeof(*b7);\n+  }\n+  sizeof(*b7);\n+}\n+extern A10 *b7;\n+\n+extern IA *b8;\n+void\n+g8 (void)\n+{\n+  sizeof(*b8); /* { dg-error \"incomplete\" } */\n+  {\n+    extern IA *b8;\n+    sizeof(*b8); /* { dg-error \"incomplete\" } */\n+    {\n+      int b8;\n+      {\n+        extern IA *b8;\n+        sizeof(*b8); /* { dg-error \"incomplete\" } */\n+      }\n+    }\n+    sizeof(*b8); /* { dg-error \"incomplete\" } */\n+  }\n+  sizeof(*b8); /* { dg-error \"incomplete\" } */\n+}\n+extern A10 *b8;\n+\n+extern IA *b9;\n+void\n+g9 (void)\n+{\n+  sizeof(*b9); /* { dg-error \"incomplete\" } */\n+  {\n+    extern IA *b9;\n+    sizeof(*b9); /* { dg-error \"incomplete\" } */\n+    {\n+      int b9;\n+      {\n+        extern A10 *b9;\n+        sizeof(*b9);\n+      }\n+    }\n+    sizeof(*b9); /* { dg-error \"incomplete\" } */\n+  }\n+  sizeof(*b9); /* { dg-error \"incomplete\" } */\n+}\n+extern A10 *b9;\n+\n+extern IA *b10;\n+void\n+g10 (void)\n+{\n+  sizeof(*b10); /* { dg-error \"incomplete\" } */\n+  {\n+    extern A10 *b10;\n+    sizeof(*b10);\n+    {\n+      int b10;\n+      {\n+        extern IA *b10;\n+        sizeof(*b10); /* { dg-error \"incomplete\" } */\n+      }\n+    }\n+    sizeof(*b10);\n+  }\n+  sizeof(*b10); /* { dg-error \"incomplete\" } */\n+}\n+extern A10 *b10;\n+\n+extern IA *b11;\n+void\n+g11 (void)\n+{\n+  sizeof(*b11); /* { dg-error \"incomplete\" } */\n+  {\n+    extern A10 *b11;\n+    sizeof(*b11);\n+    {\n+      int b11;\n+      {\n+        extern A10 *b11;\n+        sizeof(*b11);\n+      }\n+    }\n+    sizeof(*b11);\n+  }\n+  sizeof(*b11); /* { dg-error \"incomplete\" } */\n+}\n+extern A10 *b11;\n+\n+extern A10 *b12;\n+void\n+g12 (void)\n+{\n+  sizeof(*b12);\n+  {\n+    extern IA *b12;\n+    sizeof(*b12);\n+    {\n+      int b12;\n+      {\n+        extern IA *b12;\n+        sizeof(*b12); /* { dg-error \"incomplete\" } */\n+      }\n+    }\n+    sizeof(*b12);\n+  }\n+  sizeof(*b12);\n+}\n+extern A10 *b12;\n+\n+extern A10 *b13;\n+void\n+g13 (void)\n+{\n+  sizeof(*b13);\n+  {\n+    extern IA *b13;\n+    sizeof(*b13);\n+    {\n+      int b13;\n+      {\n+        extern A10 *b13;\n+        sizeof(*b13);\n+      }\n+    }\n+    sizeof(*b13);\n+  }\n+  sizeof(*b13);\n+}\n+extern A10 *b13;\n+\n+extern A10 *b14;\n+void\n+g14 (void)\n+{\n+  sizeof(*b14);\n+  {\n+    extern A10 *b14;\n+    sizeof(*b14);\n+    {\n+      int b14;\n+      {\n+        extern IA *b14;\n+        sizeof(*b14); /* { dg-error \"incomplete\" } */\n+      }\n+    }\n+    sizeof(*b14);\n+  }\n+  sizeof(*b14);\n+}\n+extern A10 *b14;\n+\n+extern A10 *b15;\n+void\n+g15 (void)\n+{\n+  sizeof(*b15);\n+  {\n+    extern A10 *b15;\n+    sizeof(*b15);\n+    {\n+      int b15;\n+      {\n+        extern A10 *b15;\n+        sizeof(*b15);\n+      }\n+    }\n+    sizeof(*b15);\n+  }\n+  sizeof(*b15);\n+}\n+extern A10 *b15;\n+\n+static IA *b16;\n+void\n+g16 (void)\n+{\n+  sizeof(*b16); /* { dg-error \"incomplete\" } */\n+  {\n+    extern IA *b16;\n+    sizeof(*b16); /* { dg-error \"incomplete\" } */\n+  }\n+  sizeof(*b16); /* { dg-error \"incomplete\" } */\n+}\n+extern A10 *b16;\n+\n+static IA *b17;\n+void\n+g17 (void)\n+{\n+  sizeof(*b17); /* { dg-error \"incomplete\" } */\n+  {\n+    extern A10 *b17;\n+    sizeof(*b17);\n+  }\n+  sizeof(*b17); /* { dg-error \"incomplete\" } */\n+}\n+extern A10 *b17;\n+\n+static A10 *b18;\n+void\n+g18 (void)\n+{\n+  sizeof(*b18);\n+  {\n+    extern IA *b18;\n+    sizeof(*b18);\n+  }\n+  sizeof(*b18);\n+}\n+extern A10 *b18;\n+\n+static A10 *b19;\n+void\n+g19 (void)\n+{\n+  sizeof(*b19);\n+  {\n+    extern A10 *b19;\n+    sizeof(*b19);\n+  }\n+  sizeof(*b19);\n+}\n+extern A10 *b19;\n+\n+IA *c0 (void);\n+void\n+h0 (void)\n+{\n+  sizeof(*c0()); /* { dg-error \"incomplete\" } */\n+  {\n+    extern IA *c0 (void);\n+    sizeof(*c0()); /* { dg-error \"incomplete\" } */\n+    {\n+      int c0;\n+      {\n+        extern IA *c0 (void);\n+        sizeof(*c0()); /* { dg-error \"incomplete\" } */\n+      }\n+    }\n+    sizeof(*c0()); /* { dg-error \"incomplete\" } */\n+  }\n+  sizeof(*c0()); /* { dg-error \"incomplete\" } */\n+}\n+A10 *c0 (void) { return 0; }\n+\n+IA *c1 (void);\n+void\n+h1 (void)\n+{\n+  sizeof(*c1()); /* { dg-error \"incomplete\" } */\n+  {\n+    extern IA *c1 (void);\n+    sizeof(*c1()); /* { dg-error \"incomplete\" } */\n+    {\n+      int c1;\n+      {\n+        extern A10 *c1 (void);\n+        sizeof(*c1());\n+      }\n+    }\n+    sizeof(*c1()); /* { dg-error \"incomplete\" } */\n+  }\n+  sizeof(*c1()); /* { dg-error \"incomplete\" } */\n+}\n+A10 *c1 (void) { return 0; }\n+\n+IA *c2 (void);\n+void\n+h2 (void)\n+{\n+  sizeof(*c2()); /* { dg-error \"incomplete\" } */\n+  {\n+    extern A10 *c2 (void);\n+    sizeof(*c2());\n+    {\n+      int c2;\n+      {\n+        extern IA *c2 (void);\n+        sizeof(*c2()); /* { dg-error \"incomplete\" } */\n+      }\n+    }\n+    sizeof(*c2());\n+  }\n+  sizeof(*c2()); /* { dg-error \"incomplete\" } */\n+}\n+A10 *c2 (void) { return 0; }\n+\n+IA *c3 (void);\n+void\n+h3 (void)\n+{\n+  sizeof(*c3()); /* { dg-error \"incomplete\" } */\n+  {\n+    extern A10 *c3 (void);\n+    sizeof(*c3());\n+    {\n+      int c3;\n+      {\n+        extern A10 *c3 (void);\n+        sizeof(*c3());\n+      }\n+    }\n+    sizeof(*c3());\n+  }\n+  sizeof(*c3()); /* { dg-error \"incomplete\" } */\n+}\n+A10 *c3 (void) { return 0; }\n+\n+A10 *c4 (void);\n+void\n+h4 (void)\n+{\n+  sizeof(*c4());\n+  {\n+    extern IA *c4 (void);\n+    sizeof(*c4());\n+    {\n+      int c4;\n+      {\n+        extern IA *c4 (void);\n+        sizeof(*c4()); /* { dg-error \"incomplete\" } */\n+      }\n+    }\n+    sizeof(*c4());\n+  }\n+  sizeof(*c4());\n+}\n+A10 *c4 (void) { return 0; }\n+\n+A10 *c5 (void);\n+void\n+h5 (void)\n+{\n+  sizeof(*c5());\n+  {\n+    extern IA *c5 (void);\n+    sizeof(*c5());\n+    {\n+      int c5;\n+      {\n+        extern A10 *c5 (void);\n+        sizeof(*c5());\n+      }\n+    }\n+    sizeof(*c5());\n+  }\n+  sizeof(*c5());\n+}\n+A10 *c5 (void) { return 0; }\n+\n+A10 *c6 (void);\n+void\n+h6 (void)\n+{\n+  sizeof(*c6());\n+  {\n+    extern A10 *c6 (void);\n+    sizeof(*c6());\n+    {\n+      int c6;\n+      {\n+        extern IA *c6 (void);\n+        sizeof(*c6()); /* { dg-error \"incomplete\" } */\n+      }\n+    }\n+    sizeof(*c6());\n+  }\n+  sizeof(*c6());\n+}\n+A10 *c6 (void) { return 0; }\n+\n+A10 *c7 (void);\n+void\n+h7 (void)\n+{\n+  sizeof(*c7());\n+  {\n+    extern A10 *c7 (void);\n+    sizeof(*c7());\n+    {\n+      int c7;\n+      {\n+        extern A10 *c7 (void);\n+        sizeof(*c7());\n+      }\n+    }\n+    sizeof(*c7());\n+  }\n+  sizeof(*c7());\n+}\n+A10 *c7 (void) { return 0; }\n+\n+extern IA *c8 (void);\n+void\n+h8 (void)\n+{\n+  sizeof(*c8()); /* { dg-error \"incomplete\" } */\n+  {\n+    extern IA *c8 (void);\n+    sizeof(*c8()); /* { dg-error \"incomplete\" } */\n+    {\n+      int c8;\n+      {\n+        extern IA *c8 (void);\n+        sizeof(*c8()); /* { dg-error \"incomplete\" } */\n+      }\n+    }\n+    sizeof(*c8()); /* { dg-error \"incomplete\" } */\n+  }\n+  sizeof(*c8()); /* { dg-error \"incomplete\" } */\n+}\n+extern A10 *c8 (void) { return 0; }\n+\n+extern IA *c9 (void);\n+void\n+h9 (void)\n+{\n+  sizeof(*c9()); /* { dg-error \"incomplete\" } */\n+  {\n+    extern IA *c9 (void);\n+    sizeof(*c9()); /* { dg-error \"incomplete\" } */\n+    {\n+      int c9;\n+      {\n+        extern A10 *c9 (void);\n+        sizeof(*c9());\n+      }\n+    }\n+    sizeof(*c9()); /* { dg-error \"incomplete\" } */\n+  }\n+  sizeof(*c9()); /* { dg-error \"incomplete\" } */\n+}\n+extern A10 *c9 (void) { return 0; }\n+\n+extern IA *c10 (void);\n+void\n+h10 (void)\n+{\n+  sizeof(*c10()); /* { dg-error \"incomplete\" } */\n+  {\n+    extern A10 *c10 (void);\n+    sizeof(*c10());\n+    {\n+      int c10;\n+      {\n+        extern IA *c10 (void);\n+        sizeof(*c10()); /* { dg-error \"incomplete\" } */\n+      }\n+    }\n+    sizeof(*c10());\n+  }\n+  sizeof(*c10()); /* { dg-error \"incomplete\" } */\n+}\n+extern A10 *c10 (void) { return 0; }\n+\n+extern IA *c11 (void);\n+void\n+h11 (void)\n+{\n+  sizeof(*c11()); /* { dg-error \"incomplete\" } */\n+  {\n+    extern A10 *c11 (void);\n+    sizeof(*c11());\n+    {\n+      int c11;\n+      {\n+        extern A10 *c11 (void);\n+        sizeof(*c11());\n+      }\n+    }\n+    sizeof(*c11());\n+  }\n+  sizeof(*c11()); /* { dg-error \"incomplete\" } */\n+}\n+extern A10 *c11 (void) { return 0; }\n+\n+extern A10 *c12 (void);\n+void\n+h12 (void)\n+{\n+  sizeof(*c12());\n+  {\n+    extern IA *c12 (void);\n+    sizeof(*c12());\n+    {\n+      int c12;\n+      {\n+        extern IA *c12 (void);\n+        sizeof(*c12()); /* { dg-error \"incomplete\" } */\n+      }\n+    }\n+    sizeof(*c12());\n+  }\n+  sizeof(*c12());\n+}\n+extern A10 *c12 (void) { return 0; }\n+\n+extern A10 *c13 (void);\n+void\n+h13 (void)\n+{\n+  sizeof(*c13());\n+  {\n+    extern IA *c13 (void);\n+    sizeof(*c13());\n+    {\n+      int c13;\n+      {\n+        extern A10 *c13 (void);\n+        sizeof(*c13());\n+      }\n+    }\n+    sizeof(*c13());\n+  }\n+  sizeof(*c13());\n+}\n+extern A10 *c13 (void) { return 0; }\n+\n+extern A10 *c14 (void);\n+void\n+h14 (void)\n+{\n+  sizeof(*c14());\n+  {\n+    extern A10 *c14 (void);\n+    sizeof(*c14());\n+    {\n+      int c14;\n+      {\n+        extern IA *c14 (void);\n+        sizeof(*c14()); /* { dg-error \"incomplete\" } */\n+      }\n+    }\n+    sizeof(*c14());\n+  }\n+  sizeof(*c14());\n+}\n+extern A10 *c14 (void) { return 0; }\n+\n+extern A10 *c15 (void);\n+void\n+h15 (void)\n+{\n+  sizeof(*c15());\n+  {\n+    extern A10 *c15 (void);\n+    sizeof(*c15());\n+    {\n+      int c15;\n+      {\n+        extern A10 *c15 (void);\n+        sizeof(*c15());\n+      }\n+    }\n+    sizeof(*c15());\n+  }\n+  sizeof(*c15());\n+}\n+extern A10 *c15 (void) { return 0; }\n+\n+static IA *c16 (void);\n+void\n+h16 (void)\n+{\n+  sizeof(*c16()); /* { dg-error \"incomplete\" } */\n+  {\n+    extern IA *c16 (void);\n+    sizeof(*c16()); /* { dg-error \"incomplete\" } */\n+  }\n+  sizeof(*c16()); /* { dg-error \"incomplete\" } */\n+}\n+static A10 *c16 (void) { return 0; }\n+\n+static IA *c17 (void);\n+void\n+h17 (void)\n+{\n+  sizeof(*c17()); /* { dg-error \"incomplete\" } */\n+  {\n+    extern A10 *c17 (void);\n+    sizeof(*c17());\n+  }\n+  sizeof(*c17()); /* { dg-error \"incomplete\" } */\n+}\n+static A10 *c17 (void) { return 0; }\n+\n+static A10 *c18 (void);\n+void\n+h18 (void)\n+{\n+  sizeof(*c18());\n+  {\n+    extern IA *c18 (void);\n+    sizeof(*c18());\n+  }\n+  sizeof(*c18());\n+}\n+static A10 *c18 (void) { return 0; }\n+\n+static A10 *c19 (void);\n+void\n+h19 (void)\n+{\n+  sizeof(*c19());\n+  {\n+    extern A10 *c19 (void);\n+    sizeof(*c19());\n+  }\n+  sizeof(*c19());\n+}\n+static A10 *c19 (void) { return 0; }"}, {"sha": "80f678ec29d8cac6bcbe86eb5790ce72a6ebe40b", "filename": "gcc/testsuite/gcc.dg/redecl-4.c", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0b410f0b88b3fc969f85708883e6acb3226827f2/gcc%2Ftestsuite%2Fgcc.dg%2Fredecl-4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0b410f0b88b3fc969f85708883e6acb3226827f2/gcc%2Ftestsuite%2Fgcc.dg%2Fredecl-4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fredecl-4.c?ref=0b410f0b88b3fc969f85708883e6acb3226827f2", "patch": "@@ -0,0 +1,28 @@\n+/* Test for multiple declarations and composite types, with built-in\n+   functions.  */\n+/* Origin: Joseph Myers <jsm@polyomino.org.uk> */\n+/* { dg-do compile } */\n+/* { dg-options \"-std=c89 -Wformat -g\" } */\n+\n+void\n+f (void)\n+{\n+  int printf;\n+  int strcmp;\n+  {\n+    int printf (const char *, ...);\n+    int strcmp ();\n+    /* Should get format warnings even though the built-in declaration\n+       isn't \"visible\".  */\n+    printf (\"%s\", 1); /* { dg-warning \"format\" } */\n+    /* The type of strcmp here should have no prototype.  */\n+    if (0)\n+      strcmp (1);\n+    /* Likewise, implicitly declared memcmp.  */\n+    if (0)\n+      memcmp (1);\n+  }\n+}\n+\n+/* Should still diagnose incompatible prototype for strcmp.  */\n+int strcmp (void); /* { dg-error \"conflict\" } */"}, {"sha": "164ec974d104e6c88df59eba4489963a04d16e6a", "filename": "gcc/testsuite/gcc.dg/redecl-6.c", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0b410f0b88b3fc969f85708883e6acb3226827f2/gcc%2Ftestsuite%2Fgcc.dg%2Fredecl-6.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0b410f0b88b3fc969f85708883e6acb3226827f2/gcc%2Ftestsuite%2Fgcc.dg%2Fredecl-6.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fredecl-6.c?ref=0b410f0b88b3fc969f85708883e6acb3226827f2", "patch": "@@ -0,0 +1,24 @@\n+/* Test for multiple declarations and composite types.  As in bug\n+   13801.  Illustrates how bug causes correct code to be wrongly\n+   diagnosed.  */\n+/* Origin: Joseph Myers <jsm@polyomino.org.uk> */\n+/* { dg-do compile } */\n+/* { dg-options \"\" } */\n+\n+typedef int IA[];\n+typedef int A5[5];\n+typedef int A10[10];\n+\n+A10 array10;\n+\n+A5 *ap;\n+void\n+f (void)\n+{\n+  int ap;\n+  {\n+    extern IA *ap;\n+    /* This assignment is valid.  */\n+    ap = &array10;\n+  }\n+}"}, {"sha": "6168562ca521d702a06799c1179639bc3de7a01a", "filename": "gcc/testsuite/gcc.dg/redecl-7.c", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0b410f0b88b3fc969f85708883e6acb3226827f2/gcc%2Ftestsuite%2Fgcc.dg%2Fredecl-7.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0b410f0b88b3fc969f85708883e6acb3226827f2/gcc%2Ftestsuite%2Fgcc.dg%2Fredecl-7.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fredecl-7.c?ref=0b410f0b88b3fc969f85708883e6acb3226827f2", "patch": "@@ -0,0 +1,23 @@\n+/* Test for multiple declarations and composite types.  Diagnosis of\n+   completion incompatible with implicit initializer.  */\n+\n+/* Origin: Joseph Myers <jsm@polyomino.org.uk> */\n+/* { dg-do compile } */\n+/* { dg-options \"-g\" } */\n+\n+int x[];\n+\n+void\n+f (void)\n+{\n+  extern int x[2]; /* { dg-error \"completed incompatibly\" } */\n+}\n+\n+/* The following is OK.  */\n+\n+int y[];\n+void\n+g (void)\n+{\n+  extern int y[1];\n+}"}, {"sha": "9145b9fddb5ee188abc6be6205ee88c75a96b8a3", "filename": "gcc/testsuite/gcc.dg/redecl-8.c", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0b410f0b88b3fc969f85708883e6acb3226827f2/gcc%2Ftestsuite%2Fgcc.dg%2Fredecl-8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0b410f0b88b3fc969f85708883e6acb3226827f2/gcc%2Ftestsuite%2Fgcc.dg%2Fredecl-8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fredecl-8.c?ref=0b410f0b88b3fc969f85708883e6acb3226827f2", "patch": "@@ -0,0 +1,23 @@\n+/* Test for multiple declarations and composite types.  Diagnosis of\n+   completion incompatible with implicit initializer.  */\n+\n+/* Origin: Joseph Myers <jsm@polyomino.org.uk> */\n+/* { dg-do compile } */\n+/* { dg-options \"-g\" } */\n+\n+static int x[];\n+\n+void\n+f (void)\n+{\n+  extern int x[2]; /* { dg-error \"completed incompatibly\" } */\n+}\n+\n+/* The following is OK.  */\n+\n+static int y[];\n+void\n+g (void)\n+{\n+  extern int y[1];\n+}"}, {"sha": "6fe25800e18745923639324d61e601655f376836", "filename": "gcc/testsuite/gcc.dg/redecl-9.c", "status": "added", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0b410f0b88b3fc969f85708883e6acb3226827f2/gcc%2Ftestsuite%2Fgcc.dg%2Fredecl-9.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0b410f0b88b3fc969f85708883e6acb3226827f2/gcc%2Ftestsuite%2Fgcc.dg%2Fredecl-9.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fredecl-9.c?ref=0b410f0b88b3fc969f85708883e6acb3226827f2", "patch": "@@ -0,0 +1,30 @@\n+/* Test for multiple declarations and composite types, as in bug\n+   13801.  Test types saved from outer scopes are up to date.  */\n+/* Origin: Joseph Myers <jsm@polyomino.org.uk> */\n+/* { dg-do compile } */\n+/* { dg-options \"\" } */\n+\n+int x[];\n+\n+void\n+f (void)\n+{\n+  extern int x[];\n+}\n+\n+int x[10];\n+\n+void\n+g (void)\n+{\n+  int x;\n+  {\n+    extern int x[10];\n+  }\n+}\n+\n+void\n+h (void)\n+{\n+  sizeof (x);\n+}"}]}