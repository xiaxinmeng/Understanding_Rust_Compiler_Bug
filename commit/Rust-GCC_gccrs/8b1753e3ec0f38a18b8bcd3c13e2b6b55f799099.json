{"sha": "8b1753e3ec0f38a18b8bcd3c13e2b6b55f799099", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OGIxNzUzZTNlYzBmMzhhMThiOGJjZDNjMTNlMmI2YjU1Zjc5OTA5OQ==", "commit": {"author": {"name": "Tom Tromey", "email": "tromey@redhat.com", "date": "2006-02-08T20:07:29Z"}, "committer": {"name": "Tom Tromey", "email": "tromey@gcc.gnu.org", "date": "2006-02-08T20:07:29Z"}, "message": "PR libgcj/26063, PR libgcj/17978, PR libgcj/10598:\n\n\t* defineclass.cc (parse): Use _Jv_AllocRawObj.\n\t(read_constpool): Likewise.\n\t(read_one_code_attribute): Use internal function name.\n\t(handleConstantPool): Use _Jv_AllocRawObj.\n\t(handleInterfacesBegin): Likewise.\n\t(handleFieldsBegin): Likewise.\n\t(handleMethodsBegin): Likewise.\n\t(handleCodeAttribute): Likewise.\n\t(handleMethodsEnd): Likewise.\n\t* include/jvm.h (new_vtable): Use _Jv_AllocRawObj.\n\t* interpret.cc (do_allocate_static_fields): Use _Jv_AllocRawObj.\n\tAllocate reference fields separately.\n\t* link.cc (prepare_constant_time_tables): Use _Jv_AllocRawObj.\n\t(add_miranda_methods): Likewise.\n\t(generate_itable): Use _Jv_AllocBytes.\n\t(find_iindex): Likewise.\n\t(struct method_closure): New structure.\n\t(create_error_method): Use struct method_closure; allocate with\n\t_Jv_AllocBytes.\n\t(ensure_fields_laid_out): Separate reference fields from\n\tnon-reference fields.\n\t* boehm.cc (_Jv_MarkObj): Mark vtable.  Only mark direct fields\n\tof Class.\n\t(_Jv_MarkArray): Mark vtable.\n\t(_Jv_AllocRawObj): Don't allocate objects of size 0.\n\t* include/execution.h\n\t(_Jv_ExecutionEngine::allocate_static_fields): Added 'int'\n\tparameter.\n\t(struct _Jv_CompiledEngine): Updated.\n\t(class _Jv_InterpreterEngine): Updated.\n\nFrom-SVN: r110763", "tree": {"sha": "dad7dc41d043dce968c02f6043b92ddb8c7cbff7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/dad7dc41d043dce968c02f6043b92ddb8c7cbff7"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/8b1753e3ec0f38a18b8bcd3c13e2b6b55f799099", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8b1753e3ec0f38a18b8bcd3c13e2b6b55f799099", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8b1753e3ec0f38a18b8bcd3c13e2b6b55f799099", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8b1753e3ec0f38a18b8bcd3c13e2b6b55f799099/comments", "author": null, "committer": null, "parents": [{"sha": "b5642e202974f356bc85dafe0dfb4ab79736a48e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b5642e202974f356bc85dafe0dfb4ab79736a48e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b5642e202974f356bc85dafe0dfb4ab79736a48e"}], "stats": {"total": 418, "additions": 157, "deletions": 261}, "files": [{"sha": "c04f560913b25c3ec794ce2ffc5a476e08708f39", "filename": "libjava/ChangeLog", "status": "modified", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8b1753e3ec0f38a18b8bcd3c13e2b6b55f799099/libjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8b1753e3ec0f38a18b8bcd3c13e2b6b55f799099/libjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FChangeLog?ref=8b1753e3ec0f38a18b8bcd3c13e2b6b55f799099", "patch": "@@ -1,3 +1,37 @@\n+2006-02-08  Tom Tromey  <tromey@redhat.com>\n+\n+\tPR libgcj/26063, PR libgcj/17978, PR libgcj/10598:\n+\t* defineclass.cc (parse): Use _Jv_AllocRawObj.\n+\t(read_constpool): Likewise.\n+\t(read_one_code_attribute): Use internal function name.\n+\t(handleConstantPool): Use _Jv_AllocRawObj.\n+\t(handleInterfacesBegin): Likewise.\n+\t(handleFieldsBegin): Likewise.\n+\t(handleMethodsBegin): Likewise.\n+\t(handleCodeAttribute): Likewise.\n+\t(handleMethodsEnd): Likewise.\n+\t* include/jvm.h (new_vtable): Use _Jv_AllocRawObj.\n+\t* interpret.cc (do_allocate_static_fields): Use _Jv_AllocRawObj.\n+\tAllocate reference fields separately.\n+\t* link.cc (prepare_constant_time_tables): Use _Jv_AllocRawObj.\n+\t(add_miranda_methods): Likewise.\n+\t(generate_itable): Use _Jv_AllocBytes.\n+\t(find_iindex): Likewise.\n+\t(struct method_closure): New structure.\n+\t(create_error_method): Use struct method_closure; allocate with\n+\t_Jv_AllocBytes.\n+\t(ensure_fields_laid_out): Separate reference fields from\n+\tnon-reference fields.\n+\t* boehm.cc (_Jv_MarkObj): Mark vtable.  Only mark direct fields\n+\tof Class.\n+\t(_Jv_MarkArray): Mark vtable.\n+\t(_Jv_AllocRawObj): Don't allocate objects of size 0.\n+\t* include/execution.h\n+\t(_Jv_ExecutionEngine::allocate_static_fields): Added 'int'\n+\tparameter.\n+\t(struct _Jv_CompiledEngine): Updated.\n+\t(class _Jv_InterpreterEngine): Updated.\n+\n 2006-02-08  Tom Tromey  <tromey@redhat.com>\n \n \tPR java/22578:"}, {"sha": "fc75bdb70055f76ea031a6acc94f8d1eaf329f2d", "filename": "libjava/boehm.cc", "status": "modified", "additions": 15, "deletions": 168, "changes": 183, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8b1753e3ec0f38a18b8bcd3c13e2b6b55f799099/libjava%2Fboehm.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8b1753e3ec0f38a18b8bcd3c13e2b6b55f799099/libjava%2Fboehm.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fboehm.cc?ref=8b1753e3ec0f38a18b8bcd3c13e2b6b55f799099", "patch": "@@ -1,6 +1,6 @@\n // boehm.cc - interface between libjava and Boehm GC.\n \n-/* Copyright (C) 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005\n+/* Copyright (C) 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006\n    Free Software Foundation\n \n    This file is part of libgcj.\n@@ -85,6 +85,9 @@ _Jv_MarkObj (void *addr, void *msp, void *msl, void *env)\n   jclass klass = dt->clas;\n   GC_PTR p;\n \n+  p = (GC_PTR) dt;\n+  MAYBE_MARK (p, mark_stack_ptr, mark_stack_limit, obj);\n+\n # ifndef JV_HASH_SYNCHRONIZATION\n     // Every object has a sync_info pointer.\n     p = (GC_PTR) obj->sync_info;\n@@ -114,25 +117,10 @@ _Jv_MarkObj (void *addr, void *msp, void *msl, void *env)\n       MAYBE_MARK (p, mark_stack_ptr, mark_stack_limit, c);\n       p = (GC_PTR) c->superclass;\n       MAYBE_MARK (p, mark_stack_ptr, mark_stack_limit, c);\n-      for (int i = 0; i < c->constants.size; ++i)\n-\t{\n-\t  /* FIXME: We could make this more precise by using the tags -KKT */\n-\t  p = (GC_PTR) c->constants.data[i].p;\n-\t  MAYBE_MARK (p, mark_stack_ptr, mark_stack_limit, c);\n-\t}\n-\n-#ifdef INTERPRETER\n-      if (_Jv_IsInterpretedClass (c))\n-\t{\n-\t  p = (GC_PTR) c->constants.tags;\n-\t  MAYBE_MARK (p, mark_stack_ptr, mark_stack_limit, c);\n-\t  p = (GC_PTR) c->constants.data;\n-\t  MAYBE_MARK (p, mark_stack_ptr, mark_stack_limit, c);\n-\t}\n-#endif\n \n-      // The vtable might be allocated even for compiled code.\n-      p = (GC_PTR) c->vtable;\n+      p = (GC_PTR) c->constants.tags;\n+      MAYBE_MARK (p, mark_stack_ptr, mark_stack_limit, c);\n+      p = (GC_PTR) c->constants.data;\n       MAYBE_MARK (p, mark_stack_ptr, mark_stack_limit, c);\n \n       // If the class is an array, then the methods field holds a\n@@ -141,101 +129,24 @@ _Jv_MarkObj (void *addr, void *msp, void *msl, void *env)\n       p = (GC_PTR) c->methods;\n       MAYBE_MARK (p, mark_stack_ptr, mark_stack_limit, c);\n \n-      // The vtable might have been set, but the rest of the class\n-      // could still be uninitialized.  If this is the case, then\n-      // c.isArray will SEGV.  We check for this, and if it is the\n-      // case we just return.\n-      if (__builtin_expect (c->name == NULL, false))\n-\treturn mark_stack_ptr;\n-\n-      if (! c->isArray() && ! c->isPrimitive())\n-\t{\n-\t  // Scan each method in the cases where `methods' really\n-\t  // points to a methods structure.\n-\t  for (int i = 0; i < c->method_count; ++i)\n-\t    {\n-\t      p = (GC_PTR) c->methods[i].name;\n-\t      MAYBE_MARK (p, mark_stack_ptr, mark_stack_limit, c);\n-\t      p = (GC_PTR) c->methods[i].signature;\n-\t      MAYBE_MARK (p, mark_stack_ptr, mark_stack_limit, c);\n-\n-\t      // Note that we don't have to mark each individual throw\n-\t      // separately, as these are stored in the constant pool.\n-\t      p = (GC_PTR) c->methods[i].throws;\n-\t      MAYBE_MARK (p, mark_stack_ptr, mark_stack_limit, c);\n-\t    }\n-\t}\n-\n-      // Mark all the fields.\n       p = (GC_PTR) c->fields;\n       MAYBE_MARK (p, mark_stack_ptr, mark_stack_limit, c);\n-      for (int i = 0; i < c->field_count; ++i)\n-\t{\n-\t  _Jv_Field* field = &c->fields[i];\n-\n-\t  p = (GC_PTR) field->name;\n-\t  MAYBE_MARK (p, mark_stack_ptr, mark_stack_limit, c);\n-\t  p = (GC_PTR) field->type;\n-\t  MAYBE_MARK (p, mark_stack_ptr, mark_stack_limit, c);\n-\n-\t  // For the interpreter, we also need to mark the memory\n-\t  // containing static members\n-\t  if ((field->flags & java::lang::reflect::Modifier::STATIC))\n-\t    {\n-\t      p = (GC_PTR) field->u.addr;\n-\t      MAYBE_MARK (p, mark_stack_ptr, mark_stack_limit, c);\n-\n-\t      // also, if the static member is a reference,\n-\t      // mark also the value pointed to.  We check for isResolved\n-\t      // since marking can happen before memory is allocated for\n-\t      // static members.\n-\t      // Note that field->u.addr may be null if the class c is\n-\t      // JV_STATE_LOADED but not JV_STATE_PREPARED (initialized).\n-\t      // Note also that field->type could be NULL in some\n-\t      // situations, for instance if the class has state\n-\t      // JV_STATE_ERROR.\n-\t      if (field->type && JvFieldIsRef (field)\n-\t\t  && p && field->isResolved()) \n-\t\t{\n-\t\t  jobject val = *(jobject*) p;\n-\t\t  p = (GC_PTR) val;\n-\t\t  MAYBE_MARK (p, mark_stack_ptr, mark_stack_limit, c);\n-\t\t}\n-\t    }\n-\t}\n \n+      // The vtable might be allocated even for compiled code.\n       p = (GC_PTR) c->vtable;\n       MAYBE_MARK (p, mark_stack_ptr, mark_stack_limit, c);\n+\n       p = (GC_PTR) c->interfaces;\n       MAYBE_MARK (p, mark_stack_ptr, mark_stack_limit, c);\n-      for (int i = 0; i < c->interface_count; ++i)\n-\t{\n-\t  p = (GC_PTR) c->interfaces[i];\n-\t  MAYBE_MARK (p, mark_stack_ptr, mark_stack_limit, c);\n-\t}\n       p = (GC_PTR) c->loader;\n       MAYBE_MARK (p, mark_stack_ptr, mark_stack_limit, c);\n \n       // The dispatch tables can be allocated at runtime.\n       p = (GC_PTR) c->ancestors;\n       MAYBE_MARK (p, mark_stack_ptr, mark_stack_limit, c);\n-      if (c->idt)\n-\t{\n-\t  p = (GC_PTR) c->idt;\n-\t  MAYBE_MARK (p, mark_stack_ptr, mark_stack_limit, c);\n \n-\t  if (c->isInterface())\n-\t    {\n-\t      p = (GC_PTR) c->idt->iface.ioffsets;\n-\t      MAYBE_MARK (p, mark_stack_ptr, mark_stack_limit, c->idt);\n-\t    }\n-\t  else if (! c->isPrimitive())\n-\t    {\n-\t      // This field is only valid for ordinary classes.\n-\t      p = (GC_PTR) c->idt->cls.itable;\n-\t      MAYBE_MARK (p, mark_stack_ptr, mark_stack_limit, c->idt);\n-\t    }\n-\t}\n+      p = (GC_PTR) c->idt;\n+      MAYBE_MARK (p, mark_stack_ptr, mark_stack_limit, c);\n \n       p = (GC_PTR) c->arrayclass;\n       MAYBE_MARK (p, mark_stack_ptr, mark_stack_limit, c);\n@@ -245,73 +156,6 @@ _Jv_MarkObj (void *addr, void *msp, void *msl, void *env)\n       MAYBE_MARK (p, mark_stack_ptr, mark_stack_limit, c);\n       p = (GC_PTR) c->aux_info;\n       MAYBE_MARK (p, mark_stack_ptr, mark_stack_limit, c);\n-\n-#ifdef INTERPRETER\n-      if (_Jv_IsInterpretedClass (c) && c->aux_info)\n-\t{\n-\t  _Jv_InterpClass* ic = (_Jv_InterpClass*) c->aux_info;\n-\n-\t  p = (GC_PTR) ic->interpreted_methods;\n-\t  MAYBE_MARK (p, mark_stack_ptr, mark_stack_limit, ic);\n-\n-\t  p = (GC_PTR) ic->source_file_name;\n-\t  MAYBE_MARK (p, mark_stack_ptr, mark_stack_limit, ic);\n-\n-\t  for (int i = 0; i < c->method_count; i++)\n-\t    {\n-\t      // The interpreter installs a heap-allocated trampoline\n-\t      // here, so we'll mark it.\n-\t      p = (GC_PTR) c->methods[i].ncode;\n-\t      MAYBE_MARK (p, mark_stack_ptr, mark_stack_limit, c);\n-\n-\t      using namespace java::lang::reflect;\n-\n-\t      // Mark the direct-threaded code.  Note a subtlety here:\n-\t      // when we add Miranda methods to a class, we don't\n-\t      // resize its interpreted_methods array.  If we try to\n-\t      // reference one of these methods, we may crash.\n-\t      // However, we know these are all abstract, and we know\n-\t      // that abstract methods have nothing useful in this\n-\t      // array.  So, we skip all abstract methods to avoid the\n-\t      // problem.  FIXME: this is pretty obscure, it may be\n-\t      // better to add a methods to the execution engine and\n-\t      // resize the array.\n-\t      if ((c->methods[i].accflags & Modifier::ABSTRACT) != 0)\n-\t\tcontinue;\n-\n-\t      p = (GC_PTR) ic->interpreted_methods[i];\n-\t      MAYBE_MARK (p, mark_stack_ptr, mark_stack_limit, ic);\n-\n-\t      if ((c->methods[i].accflags & Modifier::NATIVE) != 0)\n-\t\t{\n-\t\t  _Jv_JNIMethod *jm\n-\t\t    = (_Jv_JNIMethod *) ic->interpreted_methods[i];\n-\t\t  if (jm)\n-\t\t    {\n-\t\t      p = (GC_PTR) jm->jni_arg_types;\n-\t\t      MAYBE_MARK (p, mark_stack_ptr, mark_stack_limit, p);\n-\t\t    }\n-\t\t}\n-\t      else\n-\t\t{\n-\t\t  _Jv_InterpMethod *im\n-\t\t    = (_Jv_InterpMethod *) ic->interpreted_methods[i];\n-\t\t  if (im)\n-\t\t    {\n-                      p = (GC_PTR) im->line_table;\n-                      MAYBE_MARK (p, mark_stack_ptr, mark_stack_limit, ic);\n-\t\t      p = (GC_PTR) im->prepared;\n-\t\t      MAYBE_MARK (p, mark_stack_ptr, mark_stack_limit, ic);\n-\t\t    }\n-\t\t}\n-\t    }\n-\n-\t  p = (GC_PTR) ic->field_initializers;\n-\t  MAYBE_MARK (p, mark_stack_ptr, mark_stack_limit, ic);\n-\t  \n-\t}\n-#endif\n-\n     }\n   else\n     {\n@@ -367,6 +211,9 @@ _Jv_MarkArray (void *addr, void *msp, void *msl, void *env)\n   jclass klass = dt->clas;\n   GC_PTR p;\n \n+  p = (GC_PTR) dt;\n+  MAYBE_MARK (p, mark_stack_ptr, mark_stack_limit, array);\n+\n # ifndef JV_HASH_SYNCHRONIZATION\n     // Every object has a sync_info pointer.\n     p = (GC_PTR) array->sync_info;\n@@ -515,7 +362,7 @@ _Jv_AllocArray (jsize size, jclass klass)\n void *\n _Jv_AllocRawObj (jsize size)\n {\n-  return (void *) GC_MALLOC (size);\n+  return (void *) GC_MALLOC (size ? size : 1);\n }\n \n static void"}, {"sha": "c15cc2265d60e98c7975b54a6baadb4e4af07651", "filename": "libjava/defineclass.cc", "status": "modified", "additions": 16, "deletions": 19, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8b1753e3ec0f38a18b8bcd3c13e2b6b55f799099/libjava%2Fdefineclass.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8b1753e3ec0f38a18b8bcd3c13e2b6b55f799099/libjava%2Fdefineclass.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fdefineclass.cc?ref=8b1753e3ec0f38a18b8bcd3c13e2b6b55f799099", "patch": "@@ -1,6 +1,6 @@\n // defineclass.cc - defining a class from .class format.\n \n-/* Copyright (C) 1999, 2000, 2001, 2002, 2003, 2004, 2005  Free Software Foundation\n+/* Copyright (C) 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006  Free Software Foundation\n \n    This file is part of libgcj.\n \n@@ -350,7 +350,7 @@ _Jv_ClassReader::parse ()\n \n   // Allocate our aux_info here, after the name is set, to fulfill our\n   // contract with the collector interface.\n-  def->aux_info = (void *) _Jv_AllocBytes (sizeof (_Jv_InterpClass));\n+  def->aux_info = (void *) _Jv_AllocRawObj (sizeof (_Jv_InterpClass));\n   def_interp = (_Jv_InterpClass *) def->aux_info;\n \n   int interfaces_count = read2u (); \n@@ -387,8 +387,7 @@ _Jv_ClassReader::parse ()\n void _Jv_ClassReader::read_constpool ()\n {\n   tags    = (unsigned char*) _Jv_AllocBytes (pool_count);\n-  offsets = (unsigned int *) _Jv_AllocBytes (sizeof (int)\n-\t\t\t\t\t\t    * pool_count) ;\n+  offsets = (unsigned int *) _Jv_AllocBytes (sizeof (int) * pool_count) ;\n \n   /** first, we scan the constant pool, collecting tags and offsets */\n   tags[0]   = JV_CONSTANT_Undefined;\n@@ -656,8 +655,8 @@ void _Jv_ClassReader::read_one_code_attribute (int method_index)\n \n       int table_len = read2u ();\n       _Jv_LineTableEntry* table\n-\t= (_Jv_LineTableEntry *) JvAllocBytes (table_len\n-\t\t\t\t\t    * sizeof (_Jv_LineTableEntry));\n+\t= (_Jv_LineTableEntry *) _Jv_AllocBytes (table_len\n+\t\t\t\t\t\t * sizeof (_Jv_LineTableEntry));\n       for (int i = 0; i < table_len; i++)\n        {\n \t table[i].bytecode_pc = read2u ();\n@@ -702,11 +701,10 @@ void _Jv_ClassReader::handleConstantPool ()\n {\n   /** now, we actually define the class' constant pool */\n \n-  // the pool is scanned explicitly by the collector\n   jbyte *pool_tags = (jbyte*) _Jv_AllocBytes (pool_count);\n   _Jv_word *pool_data\n-    = (_Jv_word*) _Jv_AllocBytes (pool_count * sizeof (_Jv_word));\n-  \n+    = (_Jv_word*) _Jv_AllocRawObj (pool_count * sizeof (_Jv_word));\n+\n   def->constants.tags = pool_tags;\n   def->constants.data = pool_data;\n   def->constants.size = pool_count;\n@@ -1046,7 +1044,7 @@ _Jv_ClassReader::checkExtends (jclass sub, jclass super)\n \n void _Jv_ClassReader::handleInterfacesBegin (int count)\n {\n-  def->interfaces = (jclass*) _Jv_AllocBytes (count*sizeof (jclass));\n+  def->interfaces = (jclass*) _Jv_AllocRawObj (count*sizeof (jclass));\n   def->interface_count = count;\n }\n \n@@ -1112,11 +1110,10 @@ _Jv_ClassReader::checkImplements (jclass sub, jclass super)\n \n void _Jv_ClassReader::handleFieldsBegin (int count)\n {\n-  def->fields = (_Jv_Field*) \n-    _Jv_AllocBytes (count * sizeof (_Jv_Field));\n+  def->fields = (_Jv_Field*) _Jv_AllocRawObj (count * sizeof (_Jv_Field));\n   def->field_count = count;\n-  def_interp->field_initializers = (_Jv_ushort*)\n-    _Jv_AllocBytes (count * sizeof (_Jv_ushort));\n+  def_interp->field_initializers\n+    = (_Jv_ushort*) _Jv_AllocRawObj (count * sizeof (_Jv_ushort));\n   for (int i = 0; i < count; i++)\n     def_interp->field_initializers[i] = (_Jv_ushort) 0;\n }\n@@ -1256,11 +1253,11 @@ void _Jv_ClassReader::handleFieldsEnd ()\n void\n _Jv_ClassReader::handleMethodsBegin (int count)\n {\n-  def->methods = (_Jv_Method *) _Jv_AllocBytes (sizeof (_Jv_Method) * count);\n+  def->methods = (_Jv_Method *) _Jv_AllocRawObj (sizeof (_Jv_Method) * count);\n \n   def_interp->interpreted_methods\n-    = (_Jv_MethodBase **) _Jv_AllocBytes (sizeof (_Jv_MethodBase *)\n-\t\t\t\t\t  * count);\n+    = (_Jv_MethodBase **) _Jv_AllocRawObj (sizeof (_Jv_MethodBase *)\n+\t\t\t\t\t   * count);\n \n   for (int i = 0; i < count; i++)\n     {\n@@ -1331,7 +1328,7 @@ void _Jv_ClassReader::handleCodeAttribute\n {\n   int size = _Jv_InterpMethod::size (exc_table_length, code_length);\n   _Jv_InterpMethod *method = \n-    (_Jv_InterpMethod*) (_Jv_AllocBytes (size));\n+    (_Jv_InterpMethod*) (_Jv_AllocRawObj (size));\n \n   method->max_stack      = max_stack;\n   method->max_locals     = max_locals;\n@@ -1390,7 +1387,7 @@ void _Jv_ClassReader::handleMethodsEnd ()\n \t  else\n \t    {\n \t      _Jv_JNIMethod *m = (_Jv_JNIMethod *)\n-\t\t_Jv_AllocBytes (sizeof (_Jv_JNIMethod));\n+\t\t_Jv_AllocRawObj (sizeof (_Jv_JNIMethod));\n \t      m->defining_class = def;\n \t      m->self = method;\n \t      m->function = NULL;"}, {"sha": "88189f6449ec263646df103ff12e9477e03ab308", "filename": "libjava/include/execution.h", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8b1753e3ec0f38a18b8bcd3c13e2b6b55f799099/libjava%2Finclude%2Fexecution.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8b1753e3ec0f38a18b8bcd3c13e2b6b55f799099/libjava%2Finclude%2Fexecution.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Finclude%2Fexecution.h?ref=8b1753e3ec0f38a18b8bcd3c13e2b6b55f799099", "patch": "@@ -1,6 +1,6 @@\n // execution.h - Execution engines. -*- c++ -*-\n \n-/* Copyright (C) 2004  Free Software Foundation\n+/* Copyright (C) 2004, 2006  Free Software Foundation\n \n    This file is part of libgcj.\n \n@@ -23,7 +23,7 @@ struct _Jv_ExecutionEngine\n   // interpreter does it.\n   bool (*need_resolve_string_fields) ();\n   void (*verify) (jclass);\n-  void (*allocate_static_fields) (jclass, int);\n+  void (*allocate_static_fields) (jclass, int, int);\n   void (*create_ncode) (jclass);\n   _Jv_ResolvedMethod *(*resolve_method) (_Jv_Method *, jclass,\n \t\t\t\t\t jboolean, jint);\n@@ -55,7 +55,7 @@ struct _Jv_CompiledEngine : public _Jv_ExecutionEngine\n     return NULL;\n   }\n \n-  static void do_allocate_static_fields (jclass, int)\n+  static void do_allocate_static_fields (jclass, int, int)\n   {\n     // Compiled classes don't need this.\n   }\n@@ -99,7 +99,7 @@ class _Jv_InterpreterEngine : public _Jv_ExecutionEngine\n  public:\n \n   static void do_verify (jclass);\n-  static void do_allocate_static_fields (jclass, int);\n+  static void do_allocate_static_fields (jclass, int, int);\n   static void do_create_ncode (jclass);\n   static _Jv_ResolvedMethod *do_resolve_method (_Jv_Method *, jclass,\n \t\t\t\t\t\tjboolean, jint);"}, {"sha": "e5187f4d3f07d49199e9d5993a3ad742e910d654", "filename": "libjava/include/jvm.h", "status": "modified", "additions": 4, "deletions": 7, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8b1753e3ec0f38a18b8bcd3c13e2b6b55f799099/libjava%2Finclude%2Fjvm.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8b1753e3ec0f38a18b8bcd3c13e2b6b55f799099/libjava%2Finclude%2Fjvm.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Finclude%2Fjvm.h?ref=8b1753e3ec0f38a18b8bcd3c13e2b6b55f799099", "patch": "@@ -1,6 +1,6 @@\n // jvm.h - Header file for private implementation information. -*- c++ -*-\n \n-/* Copyright (C) 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005  Free Software Foundation\n+/* Copyright (C) 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006  Free Software Foundation\n \n    This file is part of libgcj.\n \n@@ -72,6 +72,7 @@ struct _Jv_VTable\n   {\n     return (2 * sizeof (void *)) + (index * vtable_elt_size ());\n   }\n+\n   static _Jv_VTable *new_vtable (int count);\n };\n \n@@ -374,16 +375,12 @@ void _Jv_RunMain (jclass klass, const char *name, int argc, const char **argv,\n void _Jv_RunMain (struct _Jv_VMInitArgs *vm_args, jclass klass,\n                   const char *name, int argc, const char **argv, bool is_jar);\n \n-// Delayed until after _Jv_AllocBytes is declared.\n-//\n-// Note that we allocate this as unscanned memory -- the vtables\n-// are handled specially by the GC.\n-\n+// Delayed until after _Jv_AllocRawObj is declared.\n inline _Jv_VTable *\n _Jv_VTable::new_vtable (int count)\n {\n   size_t size = sizeof(_Jv_VTable) + (count - 1) * vtable_elt_size ();\n-  return (_Jv_VTable *) _Jv_AllocBytes (size);\n+  return (_Jv_VTable *) _Jv_AllocRawObj (size);\n }\n \n // Determine if METH gets an entry in a VTable."}, {"sha": "f95671d267bb9da3ac3eafd3ee0420da3ace1b27", "filename": "libjava/interpret.cc", "status": "modified", "additions": 15, "deletions": 10, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8b1753e3ec0f38a18b8bcd3c13e2b6b55f799099/libjava%2Finterpret.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8b1753e3ec0f38a18b8bcd3c13e2b6b55f799099/libjava%2Finterpret.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Finterpret.cc?ref=8b1753e3ec0f38a18b8bcd3c13e2b6b55f799099", "patch": "@@ -3877,25 +3877,30 @@ _Jv_InterpreterEngine::do_create_ncode (jclass klass)\n \n void\n _Jv_InterpreterEngine::do_allocate_static_fields (jclass klass,\n-\t\t\t\t\t\t  int static_size)\n+\t\t\t\t\t\t  int pointer_size,\n+\t\t\t\t\t\t  int other_size)\n {\n   _Jv_InterpClass *iclass = (_Jv_InterpClass *) klass->aux_info;\n \n-  char *static_data = (char *) _Jv_AllocBytes (static_size);\n+  // Splitting the allocations here lets us scan reference fields and\n+  // avoid scanning non-reference fields.\n+  char *reference_fields = (char *) _Jv_AllocRawObj (pointer_size);\n+  char *non_reference_fields = (char *) _Jv_AllocBytes (other_size);\n \n   for (int i = 0; i < klass->field_count; i++)\n     {\n       _Jv_Field *field = &klass->fields[i];\n \n-      if ((field->flags & java::lang::reflect::Modifier::STATIC) != 0)\n+      if ((field->flags & java::lang::reflect::Modifier::STATIC) == 0)\n+\tcontinue;\n+\n+      char *base = field->isRef() ? reference_fields : non_reference_fields;\n+      field->u.addr  = base + field->u.boffset;\n+\n+      if (iclass->field_initializers[i] != 0)\n \t{\n-\t  field->u.addr  = static_data + field->u.boffset;\n-\t      \n-\t  if (iclass->field_initializers[i] != 0)\n-\t    {\n-\t      _Jv_Linker::resolve_field (field, klass->loader);\n-\t      _Jv_InitField (0, klass, i);\n-\t    }\n+\t  _Jv_Linker::resolve_field (field, klass->loader);\n+\t  _Jv_InitField (0, klass, i);\n \t}\n     }\n "}, {"sha": "26bf8984e24fcf9cecf48c7732a94c6e18c10176", "filename": "libjava/link.cc", "status": "modified", "additions": 69, "deletions": 53, "changes": 122, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8b1753e3ec0f38a18b8bcd3c13e2b6b55f799099/libjava%2Flink.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8b1753e3ec0f38a18b8bcd3c13e2b6b55f799099/libjava%2Flink.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Flink.cc?ref=8b1753e3ec0f38a18b8bcd3c13e2b6b55f799099", "patch": "@@ -1,6 +1,6 @@\n // link.cc - Code for linking and resolving classes and pool entries.\n \n-/* Copyright (C) 1999, 2000, 2001, 2002, 2003, 2004, 2005 Free Software Foundation\n+/* Copyright (C) 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006 Free Software Foundation\n \n    This file is part of libgcj.\n \n@@ -588,10 +588,10 @@ _Jv_Linker::prepare_constant_time_tables (jclass klass)\n   // a pointer to the current class, and the rest are pointers to the \n   // classes ancestors, ordered from the current class down by decreasing \n   // depth. We do not include java.lang.Object in the table of ancestors, \n-  // since it is redundant.\n+  // since it is redundant.  Note that the classes pointed to by\n+  // 'ancestors' will always be reachable by other paths.\n \n-  // FIXME: _Jv_AllocBytes\n-  klass->ancestors = (jclass *) _Jv_Malloc (klass->depth\n+  klass->ancestors = (jclass *) _Jv_AllocBytes (klass->depth\n \t\t\t\t\t\t* sizeof (jclass));\n   klass0 = klass;\n   for (int index = 0; index < klass->depth; index++)\n@@ -611,9 +611,8 @@ _Jv_Linker::prepare_constant_time_tables (jclass klass)\n       return;\n     }\n \n-  // FIXME: _Jv_AllocBytes\n   klass->idt = \n-    (_Jv_IDispatchTable *) _Jv_Malloc (sizeof (_Jv_IDispatchTable));\n+    (_Jv_IDispatchTable *) _Jv_AllocRawObj (sizeof (_Jv_IDispatchTable));\n \n   _Jv_ifaces ifaces;\n   ifaces.count = 0;\n@@ -624,9 +623,10 @@ _Jv_Linker::prepare_constant_time_tables (jclass klass)\n \n   if (ifaces.count > 0)\n     {\n+      // The classes pointed to by the itable will always be reachable\n+      // via other paths.\n       klass->idt->cls.itable = \n-\t// FIXME: _Jv_AllocBytes\n-\t(void **) _Jv_Malloc (itable_size * sizeof (void *));\n+\t(void **) _Jv_AllocBytes (itable_size * sizeof (void *));\n       klass->idt->cls.itable_length = itable_size;\n \n       jshort *itable_offsets = \n@@ -725,14 +725,12 @@ _Jv_Linker::generate_itable (jclass klass, _Jv_ifaces *ifaces,\n       /* Create interface dispatch table for iface */\n       if (iface->idt == NULL)\n \t{\n-\t  // FIXME: _Jv_AllocBytes\n \t  iface->idt\n-\t    = (_Jv_IDispatchTable *) _Jv_Malloc (sizeof (_Jv_IDispatchTable));\n+\t    = (_Jv_IDispatchTable *) _Jv_AllocRawObj (sizeof (_Jv_IDispatchTable));\n \n \t  // The first element of ioffsets is its length (itself included).\n-\t  // FIXME: _Jv_AllocBytes\n-\t  jshort *ioffsets = (jshort *) _Jv_Malloc (INITIAL_IOFFSETS_LEN\n-\t\t\t\t\t\t    * sizeof (jshort));\n+\t  jshort *ioffsets = (jshort *) _Jv_AllocBytes (INITIAL_IOFFSETS_LEN\n+\t\t\t\t\t\t\t* sizeof (jshort));\n \t  ioffsets[0] = INITIAL_IOFFSETS_LEN;\n \t  for (int i = 1; i < INITIAL_IOFFSETS_LEN; i++)\n \t    ioffsets[i] = -1;\n@@ -934,9 +932,8 @@ _Jv_Linker::find_iindex (jclass *ifaces, jshort *offsets, jshort num)\n \t  if (i >= newlen)\n \t    newlen = i + 3;\n \t  jshort *old_ioffsets = ifaces[j]->idt->iface.ioffsets;\n-\t  // FIXME: _Jv_AllocBytes\n-\t  jshort *new_ioffsets = (jshort *) _Jv_Malloc (newlen\n-\t\t\t\t\t\t\t* sizeof(jshort));\n+\t  jshort *new_ioffsets = (jshort *) _Jv_AllocBytes (newlen\n+\t\t\t\t\t\t\t    * sizeof(jshort));\n \t  memcpy (&new_ioffsets[1], &old_ioffsets[1],\n \t\t  (len - 1) * sizeof (jshort));\n \t  new_ioffsets[0] = newlen;\n@@ -954,42 +951,47 @@ _Jv_Linker::find_iindex (jclass *ifaces, jshort *offsets, jshort num)\n   return i;\n }\n \n+#ifdef USE_LIBFFI\n+\n+// We use a structure of this type to store the closure that\n+// represents a missing method.\n+struct method_closure\n+{\n+  // This field must come first, since the address of this field will\n+  // be the same as the address of the overall structure.  This is due\n+  // to disabling interior pointers in the GC.\n+  ffi_closure closure;\n+  ffi_cif cif;\n+  ffi_type *arg_types[1];\n+};\n+\n+#endif // USE_LIBFFI\n \n void *\n _Jv_Linker::create_error_method (_Jv_Utf8Const *class_name)\n {\n #ifdef USE_LIBFFI\n-  // TODO: The following structs/objects are heap allocated are\n-  // unreachable by the garbage collector:\n-  // - cif, arg_types\n-\n-  ffi_closure *closure = (ffi_closure *) _Jv_Malloc( sizeof( ffi_closure ));\n-  ffi_cif *cif = (ffi_cif *) _Jv_Malloc( sizeof( ffi_cif ));\n-\n-  // Pretends that we want to call a void (*) (void) function via\n-  // ffi_call.\n-  ffi_type **arg_types = (ffi_type **) _Jv_Malloc( sizeof( ffi_type * ));\n-  arg_types[0] = &ffi_type_void;\n-\n-  // Initializes the cif and the closure. If that worked the closure is\n-  // returned and can be used as a function pointer in a class' atable.\n-  if (ffi_prep_cif (\n-        cif, FFI_DEFAULT_ABI, 1, &ffi_type_void, arg_types) == FFI_OK\n-      && (ffi_prep_closure (\n-            closure, cif, _Jv_ThrowNoClassDefFoundErrorTrampoline,\n-            class_name) == FFI_OK))\n-    {\n-      return closure;\n-    }\n-    else\n+  method_closure *closure\n+    = (method_closure *) _Jv_AllocBytes(sizeof (method_closure));\n+\n+  closure->arg_types[0] = &ffi_type_void;\n+\n+  // Initializes the cif and the closure.  If that worked the closure\n+  // is returned and can be used as a function pointer in a class'\n+  // atable.\n+  if (ffi_prep_cif (&closure->cif, FFI_DEFAULT_ABI, 1, &ffi_type_void,\n+\t\t    closure->arg_types) == FFI_OK\n+      && ffi_prep_closure (&closure->closure, &closure->cif,\n+\t\t\t   _Jv_ThrowNoClassDefFoundErrorTrampoline,\n+\t\t\t   class_name) == FFI_OK)\n+    return &closure->closure;\n+  else\n     {\n       java::lang::StringBuffer *buffer = new java::lang::StringBuffer();\n-      buffer->append(\n-        JvNewStringLatin1(\"Error setting up FFI closure\"\n-                          \" for static method of missing class: \"));\n-      \n+      buffer->append(JvNewStringLatin1(\"Error setting up FFI closure\"\n+\t\t\t\t       \" for static method of\"\n+\t\t\t\t       \" missing class: \"));\n       buffer->append (_Jv_NewStringUtf8Const(class_name));\n-\n       throw new java::lang::InternalError(buffer->toString());\n     }\n #else\n@@ -1484,7 +1486,11 @@ _Jv_Linker::ensure_fields_laid_out (jclass klass)\n     }\n \n   int instance_size;\n-  int static_size = 0;\n+  // This is the size of the 'static' non-reference fields.\n+  int non_reference_size = 0;\n+  // This is the size of the 'static' reference fields.  We count\n+  // these separately to make it simpler for the GC to scan them.\n+  int reference_size = 0;\n \n   // Although java.lang.Object is never interpreted, an interface can\n   // have a null superclass.  Note that we have to lay out an\n@@ -1523,11 +1529,20 @@ _Jv_Linker::ensure_fields_laid_out (jclass klass)\n \t  if (field->u.addr == NULL)\n \t    {\n \t      // This computes an offset into a region we'll allocate\n-\t      // shortly, and then add this offset to the start\n+\t      // shortly, and then adds this offset to the start\n \t      // address.\n-\t      static_size       = ROUND (static_size, field_align);\n-\t      field->u.boffset   = static_size;\n-\t      static_size       += field_size;\n+\t      if (field->isRef())\n+\t\t{\n+\t\t  reference_size = ROUND (reference_size, field_align);\n+\t\t  field->u.boffset = reference_size;\n+\t\t  reference_size += field_size;\n+\t\t}\n+\t      else\n+\t\t{\n+\t\t  non_reference_size = ROUND (non_reference_size, field_align);\n+\t\t  field->u.boffset = non_reference_size;\n+\t\t  non_reference_size += field_size;\n+\t\t}\n \t    }\n \t}\n       else\n@@ -1540,8 +1555,9 @@ _Jv_Linker::ensure_fields_laid_out (jclass klass)\n \t}\n     }\n \n-  if (static_size != 0)\n-    klass->engine->allocate_static_fields (klass, static_size);\n+  if (reference_size != 0 || non_reference_size != 0)\n+    klass->engine->allocate_static_fields (klass, reference_size,\n+\t\t\t\t\t   non_reference_size);\n \n   // Set the instance size for the class.  Note that first we round it\n   // to the alignment required for this object; this keeps us in sync\n@@ -1696,8 +1712,8 @@ _Jv_Linker::add_miranda_methods (jclass base, jclass iface_class)\n \t      // found is really unique among all superinterfaces.\n \t      int new_count = base->method_count + 1;\n \t      _Jv_Method *new_m\n-\t\t= (_Jv_Method *) _Jv_AllocBytes (sizeof (_Jv_Method)\n-\t\t\t\t\t\t * new_count);\n+\t\t= (_Jv_Method *) _Jv_AllocRawObj (sizeof (_Jv_Method)\n+\t\t\t\t\t\t  * new_count);\n \t      memcpy (new_m, base->methods,\n \t\t      sizeof (_Jv_Method) * base->method_count);\n "}]}