{"sha": "2f3e5814284494e67d761eb0e68e8b7f1a130966", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MmYzZTU4MTQyODQ0OTRlNjdkNzYxZWIwZTY4ZThiN2YxYTEzMDk2Ng==", "commit": {"author": {"name": "David Edelsohn", "email": "edelsohn@gnu.org", "date": "1996-01-26T17:06:45Z"}, "committer": {"name": "David Edelsohn", "email": "edelsohn@gnu.org", "date": "1996-01-26T17:06:45Z"}, "message": "TARGET_32BIT bias and LEGITIMATE ADDRESS 64bit stuff\n\nFrom-SVN: r11109", "tree": {"sha": "f3610b9b43703b8eae0a65e9d1e4a254fce6c2c0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f3610b9b43703b8eae0a65e9d1e4a254fce6c2c0"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2f3e5814284494e67d761eb0e68e8b7f1a130966", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2f3e5814284494e67d761eb0e68e8b7f1a130966", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2f3e5814284494e67d761eb0e68e8b7f1a130966", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2f3e5814284494e67d761eb0e68e8b7f1a130966/comments", "author": null, "committer": null, "parents": [{"sha": "cc5ec3fcaa7ca1f94ea01de28a5059827d37f2c4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cc5ec3fcaa7ca1f94ea01de28a5059827d37f2c4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cc5ec3fcaa7ca1f94ea01de28a5059827d37f2c4"}], "stats": {"total": 54, "additions": 33, "deletions": 21}, "files": [{"sha": "b263d916583d5c4a46caea9894a148bb9564fb10", "filename": "gcc/config/rs6000/rs6000.h", "status": "modified", "additions": 33, "deletions": 21, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2f3e5814284494e67d761eb0e68e8b7f1a130966/gcc%2Fconfig%2Frs6000%2Frs6000.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2f3e5814284494e67d761eb0e68e8b7f1a130966/gcc%2Fconfig%2Frs6000%2Frs6000.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.h?ref=2f3e5814284494e67d761eb0e68e8b7f1a130966", "patch": "@@ -289,6 +289,7 @@ extern int target_flags;\n #define\tTARGET_DEBUG_STACK\t(target_flags & MASK_DEBUG_STACK)\n #define\tTARGET_DEBUG_ARG\t(target_flags & MASK_DEBUG_ARG)\n \n+#define TARGET_32BIT\t\t(! TARGET_64BIT)\n #define TARGET_HARD_FLOAT\t(! TARGET_SOFT_FLOAT)\n \n /* Pseudo target to indicate whether the object format is ELF\n@@ -496,11 +497,11 @@ extern struct rs6000_cpu_select rs6000_select[];\n    Note that this is not necessarily the width of data type `int';\n    if using 16-bit ints on a 68000, this would still be 32.\n    But on a machine with 16-bit registers, this would be 16.  */\n-#define BITS_PER_WORD (TARGET_POWERPC64 ? 64 : 32)\n+#define BITS_PER_WORD (! TARGET_POWERPC64 ? 32 : 64)\n #define MAX_BITS_PER_WORD 64\n \n /* Width of a word, in units (bytes).  */\n-#define UNITS_PER_WORD (TARGET_POWERPC64 ? 8 : 4)\n+#define UNITS_PER_WORD (! TARGET_POWERPC64 ? 4 : 8)\n #define MIN_UNITS_PER_WORD 4\n #define UNITS_PER_FP_WORD 8\n \n@@ -527,7 +528,7 @@ extern struct rs6000_cpu_select rs6000_select[];\n /* A C expression for the size in bits of the type `long' on the\n    target machine.  If you don't define this, the default is one\n    word.  */\n-#define LONG_TYPE_SIZE (TARGET_64BIT ? 64 : 32)\n+#define LONG_TYPE_SIZE (TARGET_32BIT ? 32 : 64)\n #define MAX_LONG_TYPE_SIZE 64\n \n /* A C expression for the size in bits of the type `long long' on the\n@@ -558,10 +559,10 @@ extern struct rs6000_cpu_select rs6000_select[];\n \n /* Width in bits of a pointer.\n    See also the macro `Pmode' defined below.  */\n-#define POINTER_SIZE (TARGET_64BIT ? 64 : 32)\n+#define POINTER_SIZE (TARGET_32BIT ? 32 : 64)\n \n /* Allocation boundary (in *bits*) for storing arguments in argument list.  */\n-#define PARM_BOUNDARY (TARGET_64BIT ? 64 : 32)\n+#define PARM_BOUNDARY (TARGET_32BIT ? 32 : 64)\n \n /* Boundary (in *bits*) on which stack pointer should be aligned.  */\n #define STACK_BOUNDARY 64\n@@ -1123,10 +1124,10 @@ typedef struct rs6000_stack {\n /* #define FRAME_GROWS_DOWNWARD */\n \n /* Size of the outgoing register save area */\n-#define RS6000_REG_SAVE (TARGET_64BIT ? 64 : 32)\n+#define RS6000_REG_SAVE (TARGET_32BIT ? 32 : 64)\n \n /* Size of the fixed area on the stack */\n-#define RS6000_SAVE_AREA (TARGET_64BIT ? 48 : 24)\n+#define RS6000_SAVE_AREA (TARGET_32BIT ? 24 : 48)\n \n /* Address to save the TOC register */\n #define RS6000_SAVE_TOC plus_constant (stack_pointer_rtx, 20)\n@@ -1145,7 +1146,7 @@ extern int rs6000_sysv_varargs_p;\n \n /* Size of V.4 varargs area in bytes */\n #define RS6000_VARARGS_SIZE \\\n-  ((GP_ARG_NUM_REG * (TARGET_64BIT ? 8 : 4)) + (FP_ARG_NUM_REG * 8) + 8)\n+  ((GP_ARG_NUM_REG * (TARGET_32BIT ? 4 : 8)) + (FP_ARG_NUM_REG * 8) + 8)\n \n /* Offset of V.4 varargs area */\n #define RS6000_VARARGS_OFFSET \\\n@@ -1509,7 +1510,7 @@ typedef struct rs6000_args\n #define RETURN_ADDRESS_OFFSET\t\t\t\t\t\t\\\n  ((DEFAULT_ABI == ABI_AIX\t\t\t\t\t\t\\\n    || DEFAULT_ABI == ABI_AIX_NODESC)\t? 8 :\t\t\t\t\\\n-  (DEFAULT_ABI == ABI_V4)\t\t? (TARGET_64BIT ? 8 : 4) :\t\\\n+  (DEFAULT_ABI == ABI_V4)\t\t? (TARGET_32BIT ? 4 : 8) :\t\\\n   (DEFAULT_ABI == ABI_NT)\t\t? -4 :\t\t\t\t\\\n   (fatal (\"RETURN_ADDRESS_OFFSET not supported\"), 0))\n \n@@ -1674,13 +1675,15 @@ typedef struct rs6000_args\n    plus a constant), a short (16-bit signed) constant plus a register,\n    the sum of two registers, or a register indirect, possibly with an\n    auto-increment.  For DFmode and DImode with an constant plus register,\n-   we must ensure that both words are addressable.  */\n+   we must ensure that both words are addressable or PowerPC64 with offset\n+   word aligned.  */\n \n #define LEGITIMATE_CONSTANT_POOL_BASE_P(X)\t\t\t\t\\\n   (TARGET_TOC && GET_CODE (X) == SYMBOL_REF\t\t\t\t\\\n    && CONSTANT_POOL_ADDRESS_P (X)\t\t\t\t\t\\\n    && ASM_OUTPUT_SPECIAL_POOL_ENTRY_P (get_pool_constant (X)))\n \n+/* TARGET_64BIT TOC64 guaranteed to have 64 bit alignment.  */\n #define LEGITIMATE_CONSTANT_POOL_ADDRESS_P(X)\t\t\t\t\\\n   (LEGITIMATE_CONSTANT_POOL_BASE_P (X)\t\t\t\t\t\\\n    || (TARGET_TOC\t\t\t\t\t\t\t\\\n@@ -1703,7 +1706,13 @@ typedef struct rs6000_args\n   && REG_OK_FOR_BASE_P (XEXP (X, 0))\t\t\t\\\n   && LEGITIMATE_ADDRESS_INTEGER_P (XEXP (X, 1), 0)\t\\\n   && (((MODE) != DFmode && (MODE) != DImode)\t\t\\\n-      || LEGITIMATE_ADDRESS_INTEGER_P (XEXP (X, 1), 4)))\n+      || (TARGET_32BIT\t\t\t\t\t\\\n+        ? LEGITIMATE_ADDRESS_INTEGER_P (XEXP (X, 1), 4) \\\n+        : ! (INTVAL (XEXP (X, 1)) & 3)))\t\t\\\n+  && ((MODE) != TImode\t\t\t\t\t\\\n+      || (TARGET_64BIT\t\t\t\t\t\\\n+        && ! (INTVAL (XEXP (X, 1)) & 3)\t\t\t\\\n+        && LEGITIMATE_ADDRESS_INTEGER_P (XEXP (X, 1), 8))))\n \n #define LEGITIMATE_INDEXED_ADDRESS_P(X)\t\t\\\n  (GET_CODE (X) == PLUS\t\t\t\t\\\n@@ -1739,8 +1748,9 @@ typedef struct rs6000_args\n     goto ADDR;\t\t\t\t\t\t\\\n   if (LEGITIMATE_OFFSET_ADDRESS_P (MODE, X))\t\t\\\n     goto ADDR;\t\t\t\t\t\t\\\n-  if ((MODE) != DImode && (MODE) != TImode\t\t\\\n-      && (TARGET_HARD_FLOAT || (MODE) != DFmode)\t\\\n+  if ((MODE) != TImode\t\t\t\t\t\\\n+      && (TARGET_HARD_FLOAT || TARGET_64BIT || (MODE) != DFmode) \\\n+      && (TARGET_64BIT || (MODE) != DImode)\t\t\\\n       && LEGITIMATE_INDEXED_ADDRESS_P (X))\t\t\\\n     goto ADDR;\t\t\t\t\t\t\\\n   if (LEGITIMATE_LO_SUM_ADDRESS_P (MODE, X))\t\t\\\n@@ -1787,14 +1797,15 @@ typedef struct rs6000_args\n     }\t\t\t\t\t\t\t\t\t\\\n   else if (GET_CODE (X) == PLUS && GET_CODE (XEXP (X, 0)) == REG\t\\\n \t   && GET_CODE (XEXP (X, 1)) != CONST_INT\t\t\t\\\n-\t   && (TARGET_HARD_FLOAT || (MODE) != DFmode)\t\t\t\\\n-\t   && (MODE) != DImode && (MODE) != TImode)\t\t\t\\\n+\t   && (TARGET_HARD_FLOAT || TARGET_64BIT || (MODE) != DFmode)\t\\\n+\t   && (TARGET_64BIT || (MODE) != DImode)\t\t\t\\\n+\t   && (MODE) != TImode)\t\t\t\t\t\t\\\n     {\t\t\t\t\t\t\t\t\t\\\n       (X) = gen_rtx (PLUS, Pmode, XEXP (X, 0),\t\t\t\t\\\n \t\t     force_reg (Pmode, force_operand (XEXP (X, 1), 0))); \\\n       goto WIN;\t\t\t\t\t\t\t\t\\\n     }\t\t\t\t\t\t\t\t\t\\\n-  else if (TARGET_ELF && !TARGET_64BIT && TARGET_NO_TOC\t\t\t\\\n+  else if (TARGET_ELF && TARGET_32BIT && TARGET_NO_TOC\t\t\t\\\n \t   && GET_CODE (X) != CONST_INT\t\t\t\t\t\\\n \t   && GET_CODE (X) != CONST_DOUBLE && CONSTANT_P (X)\t\t\\\n \t   && (TARGET_HARD_FLOAT || (MODE) != DFmode)\t\t\t\\\n@@ -1818,7 +1829,8 @@ typedef struct rs6000_args\n #define GO_IF_MODE_DEPENDENT_ADDRESS(ADDR,LABEL)\t\t\\\n { if (GET_CODE (ADDR) == PLUS\t\t\t\t\t\\\n       && LEGITIMATE_ADDRESS_INTEGER_P (XEXP (ADDR, 1), 0)\t\\\n-      && ! LEGITIMATE_ADDRESS_INTEGER_P (XEXP (ADDR, 1), 4))\t\\\n+      && ! LEGITIMATE_ADDRESS_INTEGER_P (XEXP (ADDR, 1),\t\\\n+\t\t\t\t\t (TARGET_32BIT ? 4 : 8))) \\\n     goto LABEL;\t\t\t\t\t\t\t\\\n   if (GET_CODE (ADDR) == PRE_INC)\t\t\t\t\\\n     goto LABEL;\t\t\t\t\t\t\t\\\n@@ -1835,7 +1847,7 @@ typedef struct rs6000_args\n \n /* Specify the machine mode that this machine uses\n    for the index in the tablejump instruction.  */\n-#define CASE_VECTOR_MODE (TARGET_64BIT ? DImode : SImode)\n+#define CASE_VECTOR_MODE (TARGET_32BIT ? SImode : DImode)\n \n /* Define this if the tablejump instruction expects the table\n    to contain offsets from the address of the table.\n@@ -1858,7 +1870,7 @@ typedef struct rs6000_args\n \n /* Max number of bytes we can move from memory to memory\n    in one reasonably fast instruction.  */\n-#define MOVE_MAX (TARGET_POWERPC64 ? 8 : 4)\n+#define MOVE_MAX (! TARGET_POWERPC64 ? 4 : 8)\n #define MAX_MOVE_MAX 8\n \n /* Nonzero if access to memory by bytes is no faster than for words.\n@@ -1913,12 +1925,12 @@ typedef struct rs6000_args\n /* Specify the machine mode that pointers have.\n    After generation of rtl, the compiler makes no further distinction\n    between pointers and any other objects of this machine mode.  */\n-#define Pmode (TARGET_64BIT ? DImode : SImode)\n+#define Pmode (TARGET_32BIT ? SImode : DImode)\n \n /* Mode of a function address in a call instruction (for indexing purposes).\n \n    Doesn't matter on RS/6000.  */\n-#define FUNCTION_MODE (TARGET_64BIT ? DImode : SImode)\n+#define FUNCTION_MODE (TARGET_32BIT ? SImode : DImode)\n \n /* Define this if addresses of constant functions\n    shouldn't be put through pseudo regs where they can be cse'd."}]}