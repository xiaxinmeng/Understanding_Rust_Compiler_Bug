{"sha": "947430d5feb1e7b6fab4fe22155fcd899f85e3f2", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTQ3NDMwZDVmZWIxZTdiNmZhYjRmZTIyMTU1ZmNkODk5Zjg1ZTNmMg==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2010-10-05T10:26:07Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2010-10-05T10:26:07Z"}, "message": "[multiple changes]\n\n2010-10-05  Robert Dewar  <dewar@adacore.com>\n\n\t* sem_ch4.adb: Minor reformatting.\n\t* a-direct.ads: Minor comment update.\n\n2010-10-05  Javier Miranda  <miranda@adacore.com>\n\n\t* sem_ch3.adb (Add_Internal_Interface_Entities): Removing code that is\n\tno longer required after change in New_Overloaded_Entity.\n\t* sem_ch6.adb (New_Overloaded_Entity): Code reorganization to isolate\n\tthe fragment of code that handles derivations of interface primitives.\n\tAdd missing dependence on global variable Inside_Freezing_Actions to\n\tensure the correct management of internal interface entities.\n\t* sem_ch13.adb (Analyze_Freeze_Entity): Add missing increase/decrease\n\tof the global variable Inside_Freezing_Actions to ensure that internal\n\tinterface entities are well handled by New_Overloaded_Entity.\n\t* sem_disp.adb (Find_Primitive_Covering_Interface): Add documentation\n\tand complete the algorithm to catch hidden primitives derived of\n\tprivate type that covers the interface.\n\t* sem_disp.ads (Find_Primitive_Covering_Interface): Add missing\n\tdocumentation.\n\nFrom-SVN: r164982", "tree": {"sha": "e42b065ee52cc45c4afe204b9806634fb1d09d2b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e42b065ee52cc45c4afe204b9806634fb1d09d2b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/947430d5feb1e7b6fab4fe22155fcd899f85e3f2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/947430d5feb1e7b6fab4fe22155fcd899f85e3f2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/947430d5feb1e7b6fab4fe22155fcd899f85e3f2", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/947430d5feb1e7b6fab4fe22155fcd899f85e3f2/comments", "author": null, "committer": null, "parents": [{"sha": "22b77f6852d433ba17fe169004a085298f636041", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/22b77f6852d433ba17fe169004a085298f636041", "html_url": "https://github.com/Rust-GCC/gccrs/commit/22b77f6852d433ba17fe169004a085298f636041"}], "stats": {"total": 194, "additions": 127, "deletions": 67}, "files": [{"sha": "db244c2e037fba4a111d75fbab933cd103e00ad1", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/947430d5feb1e7b6fab4fe22155fcd899f85e3f2/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/947430d5feb1e7b6fab4fe22155fcd899f85e3f2/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=947430d5feb1e7b6fab4fe22155fcd899f85e3f2", "patch": "@@ -1,3 +1,25 @@\n+2010-10-05  Robert Dewar  <dewar@adacore.com>\n+\n+\t* sem_ch4.adb: Minor reformatting.\n+\t* a-direct.ads: Minor comment update.\n+\n+2010-10-05  Javier Miranda  <miranda@adacore.com>\n+\n+\t* sem_ch3.adb (Add_Internal_Interface_Entities): Removing code that is\n+\tno longer required after change in New_Overloaded_Entity.\n+\t* sem_ch6.adb (New_Overloaded_Entity): Code reorganization to isolate\n+\tthe fragment of code that handles derivations of interface primitives.\n+\tAdd missing dependence on global variable Inside_Freezing_Actions to\n+\tensure the correct management of internal interface entities.\n+\t* sem_ch13.adb (Analyze_Freeze_Entity): Add missing increase/decrease\n+\tof the global variable Inside_Freezing_Actions to ensure that internal\n+\tinterface entities are well handled by New_Overloaded_Entity.\n+\t* sem_disp.adb (Find_Primitive_Covering_Interface): Add documentation\n+\tand complete the algorithm to catch hidden primitives derived of\n+\tprivate type that covers the interface.\n+\t* sem_disp.ads (Find_Primitive_Covering_Interface): Add missing\n+\tdocumentation.\n+\n 2010-10-05  Robert Dewar  <dewar@adacore.com>\n \n \t* prj-util.adb, prj-util.ads, prj.ads, s-vxwext-rtp.adb, sem_ch4.adb,"}, {"sha": "4ad429992575173cdb4d1fd3e3af46fa23742ae3", "filename": "gcc/ada/a-direct.ads", "status": "modified", "additions": 5, "deletions": 7, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/947430d5feb1e7b6fab4fe22155fcd899f85e3f2/gcc%2Fada%2Fa-direct.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/947430d5feb1e7b6fab4fe22155fcd899f85e3f2/gcc%2Fada%2Fa-direct.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-direct.ads?ref=947430d5feb1e7b6fab4fe22155fcd899f85e3f2", "patch": "@@ -200,34 +200,32 @@ package Ada.Directories is\n    --        timestamps:     Preserve the timestamp of the copied file, but not\n    --                        the other file attributes.\n    --\n-   --\n    --      The allowed values for mode= are:\n    --\n    --        copy:           Only copy if the destination file does not already\n    --                        exist. If it already exists, Copy_File will fail.\n    --\n    --        overwrite:      Copy the file in all cases. Overwite an already\n-   --                        existing destination file.\n+   --                        existing destination file. This is the default if\n+   --                        no mode= is found in Form.\n    --\n    --        append:         Append the original file to the destination file.\n    --                        If the destination file does not exist, the\n    --                        destination file is a copy of the source file.\n    --                        When mode=append, the field preserve=, if it\n    --                        exists, is not taken into account.\n    --\n-   --    What is the default value for mode=???\n-   --\n    --    If the Form parameter includes one or both of the fields and the value\n-   --    or values are incorrect, Copy_file fails with Use_Error.\n+   --    or values are incorrect, Copy_File fails with Use_Error.\n    --\n    --    Examples of correct Forms:\n    --       Form => \"preserve=no_attributes,mode=overwrite\" (the default)\n    --       Form => \"mode=append\"\n-   --       Form => \"mode=copy, preserve=all_attributes\"\n+   --       Form => \"mode=copy,preserve=all_attributes\"\n    --\n    --    Examples of incorrect Forms:\n    --       Form => \"preserve=junk\"\n-   --       Form => \"mode=internal, preserve=timestamps\"\n+   --       Form => \"mode=internal,preserve=timestamps\"\n \n    ----------------------------------------\n    -- File and directory name operations --"}, {"sha": "e5d174bec4d514198afbcd51c48170b1d379e420", "filename": "gcc/ada/sem_ch13.adb", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/947430d5feb1e7b6fab4fe22155fcd899f85e3f2/gcc%2Fada%2Fsem_ch13.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/947430d5feb1e7b6fab4fe22155fcd899f85e3f2/gcc%2Fada%2Fsem_ch13.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch13.adb?ref=947430d5feb1e7b6fab4fe22155fcd899f85e3f2", "patch": "@@ -2396,9 +2396,14 @@ package body Sem_Ch13 is\n       E : constant Entity_Id := Entity (N);\n \n    begin\n+      --  Remember that we are processing a freezing entity. Required to\n+      --  ensure correct decoration of internal entities associated with\n+      --  interfaces (see New_Overloaded_Entity).\n+\n+      Inside_Freezing_Actions := Inside_Freezing_Actions + 1;\n+\n       --  For tagged types covering interfaces add internal entities that link\n       --  the primitives of the interfaces with the primitives that cover them.\n-\n       --  Note: These entities were originally generated only when generating\n       --  code because their main purpose was to provide support to initialize\n       --  the secondary dispatch tables. They are now generated also when\n@@ -2485,6 +2490,8 @@ package body Sem_Ch13 is\n             end loop;\n          end;\n       end if;\n+\n+      Inside_Freezing_Actions := Inside_Freezing_Actions - 1;\n    end Analyze_Freeze_Entity;\n \n    ------------------------------------------"}, {"sha": "2192fcda2fcc002599f80eefa1cac0f400e38c1a", "filename": "gcc/ada/sem_ch3.adb", "status": "modified", "additions": 1, "deletions": 17, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/947430d5feb1e7b6fab4fe22155fcd899f85e3f2/gcc%2Fada%2Fsem_ch3.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/947430d5feb1e7b6fab4fe22155fcd899f85e3f2/gcc%2Fada%2Fsem_ch3.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch3.adb?ref=947430d5feb1e7b6fab4fe22155fcd899f85e3f2", "patch": "@@ -1550,22 +1550,7 @@ package body Sem_Ch3 is\n                    (Tagged_Type => Tagged_Type,\n                     Iface_Prim  => Iface_Prim);\n \n-               --  Handle cases where the type has no primitive covering this\n-               --  interface primitive.\n-\n-               if No (Prim) then\n-\n-                  --  Skip non-overridden null interface primitives because\n-                  --  their wrappers will be generated later.\n-\n-                  if Is_Null_Interface_Primitive (Iface_Prim) then\n-                     goto Continue;\n-\n-                  else\n-                     pragma Assert (False);\n-                     raise Program_Error;\n-                  end if;\n-               end if;\n+               pragma Assert (Present (Prim));\n \n                Derive_Subprogram\n                  (New_Subp     => New_Subp,\n@@ -1605,7 +1590,6 @@ package body Sem_Ch3 is\n                Set_Has_Delayed_Freeze (New_Subp);\n             end if;\n \n-            <<Continue>>\n             Next_Elmt (Elmt);\n          end loop;\n "}, {"sha": "050a9d7cbe5add6c5c8d9f479fa92cb466346cb9", "filename": "gcc/ada/sem_ch4.adb", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/947430d5feb1e7b6fab4fe22155fcd899f85e3f2/gcc%2Fada%2Fsem_ch4.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/947430d5feb1e7b6fab4fe22155fcd899f85e3f2/gcc%2Fada%2Fsem_ch4.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch4.adb?ref=947430d5feb1e7b6fab4fe22155fcd899f85e3f2", "patch": "@@ -891,8 +891,8 @@ package body Sem_Ch4 is\n \n          --  If this is an indirect call, the return type of the access_to\n          --  subprogram may be an incomplete type. At the point of the call,\n-         --  use the full type if available, and at the same time update\n-         --  the return type of the access_to_subprogram.\n+         --  use the full type if available, and at the same time update the\n+         --  return type of the access_to_subprogram.\n \n          if Success\n            and then Nkind (Nam) = N_Explicit_Dereference\n@@ -920,12 +920,12 @@ package body Sem_Ch4 is\n \n             --  Name may be call that returns an access to subprogram, or more\n             --  generally an overloaded expression one of whose interpretations\n-            --  yields an access to subprogram. If the name is an entity, we\n-            --  do not dereference, because the node is a call that returns\n-            --  the access type: note difference between f(x), where the call\n-            --  may return an access subprogram type, and f(x)(y), where the\n-            --  type returned by the call to f is implicitly dereferenced to\n-            --  analyze the outer call.\n+            --  yields an access to subprogram. If the name is an entity, we do\n+            --  not dereference, because the node is a call that returns the\n+            --  access type: note difference between f(x), where the call may\n+            --  return an access subprogram type, and f(x)(y), where the type\n+            --  returned by the call to f is implicitly dereferenced to analyze\n+            --  the outer call.\n \n             if Is_Access_Type (Nam_Ent) then\n                Nam_Ent := Designated_Type (Nam_Ent);"}, {"sha": "8478b7e0254d1918bc0193e8f03a946a3ca54aba", "filename": "gcc/ada/sem_ch6.adb", "status": "modified", "additions": 47, "deletions": 27, "changes": 74, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/947430d5feb1e7b6fab4fe22155fcd899f85e3f2/gcc%2Fada%2Fsem_ch6.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/947430d5feb1e7b6fab4fe22155fcd899f85e3f2/gcc%2Fada%2Fsem_ch6.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch6.adb?ref=947430d5feb1e7b6fab4fe22155fcd899f85e3f2", "patch": "@@ -7542,6 +7542,53 @@ package body Sem_Ch6 is\n \n       E := Current_Entity_In_Scope (S);\n \n+      --  Ada 2005 (AI-251): Derivation of abstract interface primitives.\n+      --  They are directly added to the list of primitive operations of\n+      --  Derived_Type, unless this is a rederivation in the private part\n+      --  of an operation that was already derived in the visible part of\n+      --  the current package.\n+\n+      if Ada_Version >= Ada_05\n+        and then Present (Derived_Type)\n+        and then Present (Alias (S))\n+        and then Is_Dispatching_Operation (Alias (S))\n+        and then Present (Find_Dispatching_Type (Alias (S)))\n+        and then Is_Interface (Find_Dispatching_Type (Alias (S)))\n+      then\n+         --  For private types, when the full-view is processed we propagate to\n+         --  the full view the non-overridden entities whose attribute \"alias\"\n+         --  references an interface primitive. These entities were added by\n+         --  Derive_Subprograms to ensure that interface primitives are\n+         --  covered.\n+\n+         --  Inside_Freeze_Actions is non zero when S corresponds with an\n+         --  internal entity that links an interface primitive with its\n+         --  covering primitive through attribute Interface_Alias (see\n+         --  Add_Internal_Interface_Entities)\n+\n+         if Inside_Freezing_Actions = 0\n+           and then Is_Package_Or_Generic_Package (Current_Scope)\n+           and then In_Private_Part (Current_Scope)\n+           and then Nkind (Parent (E)) = N_Private_Extension_Declaration\n+           and then Nkind (Parent (S)) = N_Full_Type_Declaration\n+           and then Full_View (Defining_Identifier (Parent (E)))\n+                      = Defining_Identifier (Parent (S))\n+           and then Alias (E) = Alias (S)\n+         then\n+            Check_Operation_From_Private_View (S, E);\n+            Set_Is_Dispatching_Operation (S);\n+\n+         --  Common case\n+\n+         else\n+            Enter_Overloaded_Entity (S);\n+            Check_Dispatching_Operation (S, Empty);\n+            Check_For_Primitive_Subprogram (Is_Primitive_Subp);\n+         end if;\n+\n+         return;\n+      end if;\n+\n       --  If there is no homonym then this is definitely not overriding\n \n       if No (E) then\n@@ -7617,31 +7664,6 @@ package body Sem_Ch6 is\n       --  E exists and is overloadable\n \n       else\n-         --  Ada 2005 (AI-251): Derivation of abstract interface primitives.\n-         --  They are directly added to the list of primitive operations of\n-         --  Derived_Type, unless this is a rederivation in the private part\n-         --  of an operation that was already derived in the visible part of\n-         --  the current package.\n-\n-         if Ada_Version >= Ada_05\n-           and then Present (Derived_Type)\n-           and then Present (Alias (S))\n-           and then Is_Dispatching_Operation (Alias (S))\n-           and then Present (Find_Dispatching_Type (Alias (S)))\n-           and then Is_Interface (Find_Dispatching_Type (Alias (S)))\n-         then\n-            if Type_Conformant (E, S)\n-              and then Is_Package_Or_Generic_Package (Current_Scope)\n-              and then In_Private_Part (Current_Scope)\n-              and then Parent (E) /= Parent (S)\n-              and then Alias (E) = Alias (S)\n-            then\n-               Check_Operation_From_Private_View (S, E);\n-            else\n-               goto Add_New_Entity;\n-            end if;\n-         end if;\n-\n          Check_Synchronized_Overriding (S, Overridden_Subp);\n \n          --  Loop through E and its homonyms to determine if any of them is\n@@ -7999,8 +8021,6 @@ package body Sem_Ch6 is\n             E := Homonym (E);\n          end loop;\n \n-         <<Add_New_Entity>>\n-\n          --  On exit, we know that S is a new entity\n \n          Enter_Overloaded_Entity (S);"}, {"sha": "3c295f94ca33f265e48311717c35b94182b258dd", "filename": "gcc/ada/sem_disp.adb", "status": "modified", "additions": 31, "deletions": 6, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/947430d5feb1e7b6fab4fe22155fcd899f85e3f2/gcc%2Fada%2Fsem_disp.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/947430d5feb1e7b6fab4fe22155fcd899f85e3f2/gcc%2Fada%2Fsem_disp.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_disp.adb?ref=947430d5feb1e7b6fab4fe22155fcd899f85e3f2", "patch": "@@ -1661,7 +1661,9 @@ package body Sem_Disp is\n                      Is_Interface\n                        (Find_Dispatching_Type (Ultimate_Alias (Iface_Prim)))));\n \n-      --  Search in the homonym chain\n+      --  Search in the homonym chain. Done to speed up locating visible\n+      --  entities and required to catch primitives associated with the partial\n+      --  view of private types when processing the corresponding full view.\n \n       E := Current_Entity (Iface_Prim);\n       while Present (E) loop\n@@ -1675,16 +1677,39 @@ package body Sem_Disp is\n          E := Homonym (E);\n       end loop;\n \n-      --  Search in the list of primitives of the type\n+      --  Search in the list of primitives of the type. Required to locate the\n+      --  covering primitive if the covering primitive is not visible (for\n+      --  example, non-visible inherited primitive of private type).\n \n       El := First_Elmt (Primitive_Operations (Tagged_Type));\n       while Present (El) loop\n          E := Node (El);\n \n-         if No (Interface_Alias (E))\n-           and then Alias (E) = Iface_Prim\n-         then\n-            return Node (El);\n+         --  Keep separate the management of internal entities that link\n+         --  primitives with interface primitives from tagged type primitives.\n+\n+         if No (Interface_Alias (E)) then\n+            if Present (Alias (E)) then\n+\n+               --  This interface primitive has not been covered yet\n+\n+               if Alias (E) = Iface_Prim then\n+                  return E;\n+\n+               --  The covering primitive was inherited\n+\n+               elsif Overridden_Operation (Ultimate_Alias (E))\n+                       = Iface_Prim\n+               then\n+                  return E;\n+               end if;\n+            end if;\n+\n+         --  Use the internal entity that links the interface primitive with\n+         --  the covering primitive to locate the entity\n+\n+         elsif Interface_Alias (E) = Iface_Prim then\n+            return Alias (E);\n          end if;\n \n          Next_Elmt (El);"}, {"sha": "64f7e20dc17d3820af5f811a02ce8b59d19c836e", "filename": "gcc/ada/sem_disp.ads", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/947430d5feb1e7b6fab4fe22155fcd899f85e3f2/gcc%2Fada%2Fsem_disp.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/947430d5feb1e7b6fab4fe22155fcd899f85e3f2/gcc%2Fada%2Fsem_disp.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_disp.ads?ref=947430d5feb1e7b6fab4fe22155fcd899f85e3f2", "patch": "@@ -87,7 +87,11 @@ package Sem_Disp is\n    --  associated with the partial view of private types when processing the\n    --  corresponding full view. If the entity is not found then search for it\n    --  in the list of primitives of Tagged_Type. This latter search is needed\n-   --  when the interface primitive is covered by a private subprogram.\n+   --  when the interface primitive is covered by a private subprogram. If the\n+   --  primitive has not been covered yet then return the entity that will be\n+   --  overriden when the primitive is covered (that is, return the entity\n+   --  whose alias attribute references the interface primitive). If none of\n+   --  these entities is found then return Empty.\n \n    function Is_Dynamically_Tagged (N : Node_Id) return Boolean;\n    --  Used to determine whether a call is dispatching, i.e. if is an"}]}