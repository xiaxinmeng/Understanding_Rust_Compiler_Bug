{"sha": "1a6daf15e25e04346c5cb0017c86c5732e3d9a7e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MWE2ZGFmMTVlMjVlMDQzNDZjNWNiMDAxN2M4NmM1NzMyZTNkOWE3ZQ==", "commit": {"author": {"name": "Gabriel Dos Reis", "email": "gdr@integrable-solutions.net", "date": "2003-09-26T15:21:30Z"}, "committer": {"name": "Gabriel Dos Reis", "email": "gdr@gcc.gnu.org", "date": "2003-09-26T15:21:30Z"}, "message": "decl.c (pop_binding_level, [...]): Merge into leave_scope.\n\n        * decl.c (pop_binding_level, suspend_binding_level,\n        find_class_binding_level): Merge into leave_scope.  Remove.\n        (leave_scope):  New function.\n        (poplevel): Update.\n        (poplevel_class): Likewise.\n        (pop_namespace): Likewise.\n\nFrom-SVN: r71821", "tree": {"sha": "8aeb7b0818f32e36a0cc41f62e8ada42104c630f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8aeb7b0818f32e36a0cc41f62e8ada42104c630f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/1a6daf15e25e04346c5cb0017c86c5732e3d9a7e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1a6daf15e25e04346c5cb0017c86c5732e3d9a7e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1a6daf15e25e04346c5cb0017c86c5732e3d9a7e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1a6daf15e25e04346c5cb0017c86c5732e3d9a7e/comments", "author": {"login": "cxx-undef", "id": 5528103, "node_id": "MDQ6VXNlcjU1MjgxMDM=", "avatar_url": "https://avatars.githubusercontent.com/u/5528103?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cxx-undef", "html_url": "https://github.com/cxx-undef", "followers_url": "https://api.github.com/users/cxx-undef/followers", "following_url": "https://api.github.com/users/cxx-undef/following{/other_user}", "gists_url": "https://api.github.com/users/cxx-undef/gists{/gist_id}", "starred_url": "https://api.github.com/users/cxx-undef/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cxx-undef/subscriptions", "organizations_url": "https://api.github.com/users/cxx-undef/orgs", "repos_url": "https://api.github.com/users/cxx-undef/repos", "events_url": "https://api.github.com/users/cxx-undef/events{/privacy}", "received_events_url": "https://api.github.com/users/cxx-undef/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "a366f4aa321d825dac8b85eb78b7ea9dd343836d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a366f4aa321d825dac8b85eb78b7ea9dd343836d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a366f4aa321d825dac8b85eb78b7ea9dd343836d"}], "stats": {"total": 117, "additions": 52, "deletions": 65}, "files": [{"sha": "ff621d2e10dc2e4fd46d2b239e8af45a6aa7e173", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a6daf15e25e04346c5cb0017c86c5732e3d9a7e/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a6daf15e25e04346c5cb0017c86c5732e3d9a7e/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=1a6daf15e25e04346c5cb0017c86c5732e3d9a7e", "patch": "@@ -1,3 +1,12 @@\n+2003-09-26  Gabriel Dos Reis  <gdr@integrable-solutions.net>\n+\n+\t* decl.c (pop_binding_level, suspend_binding_level,\n+\tfind_class_binding_level): Merge into leave_scope.  Remove.\n+\t(leave_scope):  New function.\n+\t(poplevel): Update.\n+\t(poplevel_class): Likewise.\n+\t(pop_namespace): Likewise.\n+\n 2003-09-25  Kriang Lerdsuwanakij  <lerdsuwa@users.sourceforge.net>\n \n \tPR c++/5655"}, {"sha": "52b3b60054910d431d2ce1603bd2caf9d2d1829d", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 43, "deletions": 65, "changes": 108, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a6daf15e25e04346c5cb0017c86c5732e3d9a7e/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a6daf15e25e04346c5cb0017c86c5732e3d9a7e/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=1a6daf15e25e04346c5cb0017c86c5732e3d9a7e", "patch": "@@ -55,8 +55,6 @@ Boston, MA 02111-1307, USA.  */\n static tree grokparms (tree);\n static const char *redeclaration_error_message (tree, tree);\n \n-static void pop_binding_level (void);\n-static void suspend_binding_level (void);\n static void resume_binding_level (struct cp_binding_level *);\n static int decl_jump_unsafe (tree);\n static void storedecls (tree);\n@@ -98,7 +96,6 @@ static int lookup_flags (int, int);\n static tree qualify_lookup (tree, int);\n static tree record_builtin_java_type (const char *, int);\n static const char *tag_name (enum tag_types code);\n-static void find_class_binding_level (void);\n static struct cp_binding_level *innermost_nonclass_level (void);\n static int walk_namespaces_r (tree, walk_namespaces_fn, void *);\n static int walk_globals_r (tree, void*);\n@@ -566,81 +563,62 @@ begin_scope (scope_kind kind, tree entity)\n   return scope;\n }\n \n-/* Find the innermost enclosing class scope, and reset\n-   CLASS_BINDING_LEVEL appropriately.  */\n+/* We're about to leave current scope.  Pop the top of the stack of\n+   currently active scopes.  Return the enclosing scope, now active.  */\n \n-static void\n-find_class_binding_level (void)\n+static cxx_scope *\n+leave_scope (void)\n {\n-  struct cp_binding_level *level = current_binding_level;\n+  cxx_scope *scope = current_binding_level;\n \n-  while (level && level->kind != sk_class)\n-    level = level->level_chain;\n-  if (level && level->kind == sk_class)\n-    class_binding_level = level;\n-  else\n-    class_binding_level = 0;\n-}\n+  if (scope->kind == sk_namespace && class_binding_level)\n+    current_binding_level = class_binding_level;\n \n-static void\n-pop_binding_level (void)\n-{\n+  /* We cannot leave a scope, if there are none left.  */\n   if (NAMESPACE_LEVEL (global_namespace))\n-    /* Cannot pop a level, if there are none left to pop.  */\n-    my_friendly_assert (!global_scope_p (current_binding_level), 20030527);\n-  /* Pop the current level, and free the structure for reuse.  */\n+    my_friendly_assert (!global_scope_p (scope), 20030527);\n+  \n   if (ENABLE_SCOPE_CHECKING)\n     {\n       indent (--binding_depth);\n-      cxx_scope_debug (current_binding_level, input_location.line, \"pop\");\n-      if (is_class_level != (current_binding_level == class_binding_level))\n+      cxx_scope_debug (scope, input_location.line, \"leave\");\n+      if (is_class_level != (scope == class_binding_level))\n         {\n           indent (binding_depth);\n-          verbatim (\"XXX is_class_level != (current_binding_level \"\n-                    \"== class_binding_level)\\n\");\n+          verbatim (\"XXX is_class_level != (current_scope == class_scope)\\n\");\n         }\n       is_class_level = 0;\n     }\n-  {\n-    register struct cp_binding_level *level = current_binding_level;\n-    current_binding_level = current_binding_level->level_chain;\n-    level->level_chain = free_binding_level;\n-    if (level->kind == sk_class)\n-      level->type_decls = NULL;\n-    else\n-      binding_table_free (level->type_decls);\n-    my_friendly_assert (!ENABLE_SCOPE_CHECKING\n-                        || level->binding_depth == binding_depth,\n-                        20030529);\n-    free_binding_level = level;\n-    find_class_binding_level ();\n-  }\n-}\n \n-static void\n-suspend_binding_level (void)\n-{\n-  if (class_binding_level)\n-    current_binding_level = class_binding_level;\n+  /* Move one nesting level up.  */\n+  current_binding_level = scope->level_chain;\n \n-  if (NAMESPACE_LEVEL (global_namespace))\n-    /* Cannot suspend a level, if there are none left to suspend.  */\n-    my_friendly_assert (!global_scope_p (current_binding_level), 20030527);\n-  /* Suspend the current level.  */\n-  if (ENABLE_SCOPE_CHECKING)\n+  /* Namespace-scopes are left most probably temporarily, not completely;\n+     they can be reopen later, e.g. in namespace-extension or any name\n+     binding acttivity that requires us to resume a namespace.  For other\n+     scopes, we just make the structure available for reuse.  */\n+  if (scope->kind != sk_namespace)\n     {\n-      indent (--binding_depth);\n-      cxx_scope_debug (current_binding_level, input_location.line, \"suspend\");\n-      if (is_class_level != (current_binding_level == class_binding_level))\n-        {\n-          indent (binding_depth);\n-          verbatim (\"XXX is_class_level != (current_binding_level \"\n-                    \"== class_binding_level)\\n\");\n-        }\n-      is_class_level = 0;\n-    }\n-  current_binding_level = current_binding_level->level_chain;\n-  find_class_binding_level ();\n+      scope->level_chain = free_binding_level;\n+      if (scope->kind == sk_class)\n+        scope->type_decls = NULL;\n+      else\n+        binding_table_free (scope->type_decls);\n+      my_friendly_assert (!ENABLE_SCOPE_CHECKING\n+                          || scope->binding_depth == binding_depth,\n+                          20030529);\n+      free_binding_level = scope;\n+    }\n+\n+  /* Find the innermost enclosing class scope, and reset\n+     CLASS_BINDING_LEVEL appropriately.  */\n+  for (scope = current_binding_level;\n+       scope && scope->kind != sk_class;\n+       scope = scope->level_chain)\n+    ;\n+  class_binding_level = scope && scope->kind == sk_class ? scope : NULL;\n+\n+  return current_binding_level;\n }\n \n static void\n@@ -1387,7 +1365,7 @@ poplevel (int keep, int reverse, int functionbody)\n \n   kind = current_binding_level->kind;\n \n-  pop_binding_level ();\n+  leave_scope ();\n   if (functionbody)\n     DECL_INITIAL (current_function_decl) = block;\n   else if (block)\n@@ -1555,7 +1533,7 @@ poplevel_class (void)\n   if (ENABLE_SCOPE_CHECKING)\n     is_class_level = 1;\n \n-  pop_binding_level ();\n+  leave_scope ();\n   timevar_pop (TV_NAME_LOOKUP);\n }\n \n@@ -1967,7 +1945,7 @@ pop_namespace (void)\n   my_friendly_assert (current_namespace != global_namespace, 20010801);\n   current_namespace = CP_DECL_CONTEXT (current_namespace);\n   /* The binding level is not popped, as it might be re-opened later.  */\n-  suspend_binding_level ();\n+  leave_scope ();\n }\n \n /* Push into the scope of the namespace NS, even if it is deeply"}]}