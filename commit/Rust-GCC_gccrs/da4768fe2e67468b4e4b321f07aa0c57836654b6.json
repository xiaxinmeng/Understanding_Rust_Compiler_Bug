{"sha": "da4768fe2e67468b4e4b321f07aa0c57836654b6", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZGE0NzY4ZmUyZTY3NDY4YjRlNGIzMjFmMDdhYTBjNTc4MzY2NTRiNg==", "commit": {"author": {"name": "Jason Merrill", "email": "jason@yorick.cygnus.com", "date": "1997-11-15T08:36:38Z"}, "committer": {"name": "Jason Merrill", "email": "jason@gcc.gnu.org", "date": "1997-11-15T08:36:38Z"}, "message": "call.c (build_new_op): Fix copy error.\n\n\t* call.c (build_new_op): Fix copy error.\n\t(build_op_new_call): New fn.\n\t(build_op_delete_call): New fn.\n\t* cp-tree.h: Declare them.\n\t* init.c (build_new): Use them.  Support placement delete.\n\t(build_x_delete): Use build_op_delete_call.\n\t(build_delete): Likewise.\n\t* decl2.c (delete_sanity): Likewise.\n\t(coerce_delete_type): Don't complain about placement delete.\n\nSupport placement delete.\n\nFrom-SVN: r16501", "tree": {"sha": "aa307cb343792fb4339282298c362fcbc97b48dc", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/aa307cb343792fb4339282298c362fcbc97b48dc"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/da4768fe2e67468b4e4b321f07aa0c57836654b6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/da4768fe2e67468b4e4b321f07aa0c57836654b6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/da4768fe2e67468b4e4b321f07aa0c57836654b6", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/da4768fe2e67468b4e4b321f07aa0c57836654b6/comments", "author": null, "committer": null, "parents": [{"sha": "df4791b95d453db88e1db9ffb9315b6fa00d69f6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/df4791b95d453db88e1db9ffb9315b6fa00d69f6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/df4791b95d453db88e1db9ffb9315b6fa00d69f6"}], "stats": {"total": 242, "additions": 187, "deletions": 55}, "files": [{"sha": "0349d52a92e8621fe929a582a8579afa34c8041e", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/da4768fe2e67468b4e4b321f07aa0c57836654b6/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/da4768fe2e67468b4e4b321f07aa0c57836654b6/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=da4768fe2e67468b4e4b321f07aa0c57836654b6", "patch": "@@ -1,3 +1,15 @@\n+Sat Nov 15 00:30:51 1997  Jason Merrill  <jason@yorick.cygnus.com>\n+\n+\t* call.c (build_new_op): Fix copy error.\n+\t(build_op_new_call): New fn.\n+\t(build_op_delete_call): New fn.\n+\t* cp-tree.h: Declare them.\n+\t* init.c (build_new): Use them.  Support placement delete.\n+\t(build_x_delete): Use build_op_delete_call.\n+\t(build_delete): Likewise.\n+\t* decl2.c (delete_sanity): Likewise.\n+\t(coerce_delete_type): Don't complain about placement delete.\n+\n Thu Nov 13 01:52:36 1997  Jason Merrill  <jason@yorick.cygnus.com>\n \n \t* call.c (build_new_function_call): Remove unused 'obj' parm."}, {"sha": "ed40a073452aebbeb1992315fedbb0e9cd6af59c", "filename": "gcc/cp/call.c", "status": "modified", "additions": 139, "deletions": 2, "changes": 141, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/da4768fe2e67468b4e4b321f07aa0c57836654b6/gcc%2Fcp%2Fcall.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/da4768fe2e67468b4e4b321f07aa0c57836654b6/gcc%2Fcp%2Fcall.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcall.c?ref=da4768fe2e67468b4e4b321f07aa0c57836654b6", "patch": "@@ -4861,8 +4861,8 @@ build_new_op (code, flags, arg1, arg2, arg3)\n \t      templates = scratch_tree_cons (NULL_TREE, fn, templates);\n \t      candidates \n \t\t= add_template_candidate (candidates, fn, NULL_TREE,\n-\t\t\t\t\t  this_arglist,  TREE_TYPE\n-\t\t\t\t\t  (fnname), LOOKUP_NORMAL); \n+\t\t\t\t\t  this_arglist,  TREE_TYPE (fnname),\n+\t\t\t\t\t  flags); \n \t    }\n \t  else\n \t    candidates = add_function_candidate\n@@ -5071,6 +5071,143 @@ build_new_op (code, flags, arg1, arg2, arg3)\n     }\n }\n \n+/* Build up a call to operator new.  This has to be handled differently\n+   from other operators in the way lookup is handled; first members are\n+   considered, then globals.  CODE is either NEW_EXPR or VEC_NEW_EXPR.\n+   TYPE is the type to be created.  ARGS are any new-placement args.\n+   FLAGS are the usual overloading flags.  */\n+\n+tree\n+build_op_new_call (code, type, args, flags)\n+     enum tree_code code;\n+     tree type, args;\n+     int flags;\n+{\n+  tree fnname = ansi_opname[code];\n+\n+  if (IS_AGGR_TYPE (type) && ! (flags & LOOKUP_GLOBAL)\n+      && (TYPE_GETS_NEW (type) & (1 << (code == VEC_NEW_EXPR))))\n+    {\n+      tree dummy = build1 (NOP_EXPR, build_pointer_type (type),\n+\t\t\t   error_mark_node);\n+      dummy = build_indirect_ref (dummy, \"new\");\n+      return build_method_call (dummy, fnname, args, NULL_TREE, flags);\n+    }\n+  else\n+    return build_new_function_call (lookup_name_nonclass (fnname), args);\n+}\n+\n+/* Build a call to operator delete.  This has to be handled very specially,\n+   because the restrictions on what signatures match are different from all\n+   other call instances.  For a normal delete, only a delete taking (void *)\n+   or (void *, size_t) is accepted.  For a placement delete, only an exact\n+   match with the placement new is accepted.\n+\n+   CODE is either DELETE_EXPR or VEC_DELETE_EXPR.\n+   ADDR is the pointer to be deleted.  For placement delete, it is also\n+     used to determine what the corresponding new looked like.\n+   SIZE is the size of the memory block to be deleted.\n+   FLAGS are the usual overloading flags.  */\n+\n+tree\n+build_op_delete_call (code, addr, size, flags)\n+     enum tree_code code;\n+     tree addr, size;\n+     int flags;\n+{\n+  tree fn, fns, fnname, fntype, argtypes, args, type;\n+  int placement;\n+\n+  if (addr == error_mark_node)\n+    return error_mark_node;\n+\n+  type = TREE_TYPE (TREE_TYPE (addr));\n+  fnname = ansi_opname[code];\n+\n+  if (IS_AGGR_TYPE (type) && ! (flags & LOOKUP_GLOBAL))\n+    /* Here we make assumptions about how instantiate_type works.  This comes\n+       out as a simple TREE_LIST, so it looks like overloaded globals to\n+       instantiate_type; this works out fine.  If something changes we\n+       might have to build this up like build_offset_ref does.  */\n+    fns = lookup_fnfields (TYPE_BINFO (type), fnname, 0);\n+  else\n+    fns = NULL_TREE;\n+\n+  if (fns == NULL_TREE)\n+    fns = lookup_name_nonclass (fnname);\n+\n+  /* We can recognize a placement delete because of LOOKUP_SPECULATIVELY;\n+     if we are doing placement delete we do nothing if we don't find a\n+     matching op delete.  */\n+  placement = !!(flags & LOOKUP_SPECULATIVELY);\n+  if (placement)\n+    {\n+      /* If placement, we are coming from build_new, and we know that addr\n+\t is the allocation expression, so extract the info we need from it.\n+\t Obviously, if the build_new process changes this may have to\n+\t change as well.  */\n+      /* The SAVE_EXPR.  */\n+      tree t = TREE_OPERAND (addr, 0);\n+      /* The CALL_EXPR.  */\n+      t = TREE_OPERAND (t, 0);\n+      /* The function.  */\n+      argtypes = TREE_OPERAND (TREE_OPERAND (t, 0), 0);\n+      /* The second parm type.  */\n+      argtypes = TREE_CHAIN (TYPE_ARG_TYPES (TREE_TYPE (argtypes)));\n+      /* The second argument.  */\n+      args = TREE_CHAIN (TREE_OPERAND (t, 1));\n+    }\n+  else\n+    {\n+      /* First try it without the size argument.  */\n+      argtypes = void_list_node;\n+      args = NULL_TREE;\n+    }\n+\n+  argtypes = tree_cons (NULL_TREE, ptr_type_node, argtypes);\n+  fntype = build_function_type (void_type_node, argtypes);\n+\n+  /* Strip const and volatile from addr.  */\n+  if (type != TYPE_MAIN_VARIANT (type))\n+    addr = cp_convert (build_pointer_type (TYPE_MAIN_VARIANT (type)), addr);\n+\n+  /* instantiate_type will always return a plain function; pretend it's\n+     overloaded.  */\n+  if (TREE_CODE (fns) == FUNCTION_DECL)\n+    fns = scratch_tree_cons (NULL_TREE, fns, NULL_TREE);\n+\n+  fn = instantiate_type (fntype, fns, 0);\n+\n+  if (fn != error_mark_node)\n+    {\n+      if (TREE_PURPOSE (fns))\n+\t/* TREE_PURPOSE is only set for lists of member functions.  */\n+\tenforce_access (TREE_PURPOSE (fns), fn);\n+      return build_function_call (fn, expr_tree_cons (NULL_TREE, addr, args));\n+    }\n+\n+  if (placement)\n+    return NULL_TREE;\n+\n+  /* Normal delete; now try to find a match including the size argument.  */\n+  argtypes = tree_cons (NULL_TREE, ptr_type_node,\n+\t\t\ttree_cons (NULL_TREE, sizetype, void_list_node));\n+  fntype = build_function_type (void_type_node, argtypes);\n+\n+  fn = instantiate_type (fntype, fns, 0);\n+\n+  if (fn != error_mark_node)\n+    return build_function_call\n+      (fn, expr_tree_cons (NULL_TREE, addr,\n+\t\t\t   build_expr_list (NULL_TREE, size)));\n+\n+  cp_error (\"no suitable operator delete for `%T'\", type);\n+  return error_mark_node;\n+}\n+\n+/* If the current scope isn't allowed to access FUNCTION along\n+   BASETYPE_PATH, give an error.  */\n+\n static void\n enforce_access (basetype_path, function)\n      tree basetype_path, function;"}, {"sha": "47b9fe6062eff0a2b3980010f5815eb7f346d64d", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/da4768fe2e67468b4e4b321f07aa0c57836654b6/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/da4768fe2e67468b4e4b321f07aa0c57836654b6/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=da4768fe2e67468b4e4b321f07aa0c57836654b6", "patch": "@@ -1957,6 +1957,8 @@ extern tree type_decays_to\t\t\tPROTO((tree));\n extern tree build_user_type_conversion\t\tPROTO((tree, tree, int));\n extern tree build_new_function_call\t\tPROTO((tree, tree));\n extern tree build_new_op\t\t\tPROTO((enum tree_code, int, tree, tree, tree));\n+extern tree build_op_new_call\t\t\tPROTO((enum tree_code, tree, tree, int));\n+extern tree build_op_delete_call\t\tPROTO((enum tree_code, tree, tree, int));\n extern int can_convert\t\t\t\tPROTO((tree, tree));\n extern int can_convert_arg\t\t\tPROTO((tree, tree, tree));\n "}, {"sha": "9ee0287c954152ff22ee7c849c8231594315acc1", "filename": "gcc/cp/decl2.c", "status": "modified", "additions": 8, "deletions": 3, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/da4768fe2e67468b4e4b321f07aa0c57836654b6/gcc%2Fcp%2Fdecl2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/da4768fe2e67468b4e4b321f07aa0c57836654b6/gcc%2Fcp%2Fdecl2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl2.c?ref=da4768fe2e67468b4e4b321f07aa0c57836654b6", "patch": "@@ -1310,8 +1310,8 @@ delete_sanity (exp, size, doing_vec, use_global_delete)\n \t{\n \t  /* Only do access checking here; we'll be calling op delete\n \t     from the destructor.  */\n-\t  tree tmp = build_opfncall (DELETE_EXPR, LOOKUP_NORMAL, t,\n-\t\t\t\t     size_zero_node, NULL_TREE);\n+\t  tree tmp = build_op_delete_call (DELETE_EXPR, t,\n+\t\t\t\t\t   size_zero_node, LOOKUP_NORMAL);\n \t  if (tmp == error_mark_node)\n \t    return error_mark_node;\n \t}\n@@ -2403,6 +2403,7 @@ coerce_delete_type (type)\n       || TREE_VALUE (arg_types) != ptr_type_node)\n     e2 = 1, error (\"`operator delete' takes type `void *' as first parameter\");\n \n+#if 0\n   if (arg_types\n       && TREE_CHAIN (arg_types)\n       && TREE_CHAIN (arg_types) != void_list_node)\n@@ -2434,8 +2435,12 @@ coerce_delete_type (type)\n \targ_types = tree_cons (NULL_TREE, ptr_type_node, TREE_CHAIN (arg_types));\n     }\n   else e3 |= e1;\n+#endif\n \n-  if (e3)\n+  if (e2)\n+    arg_types = tree_cons (NULL_TREE, ptr_type_node,\n+\t\t\t   arg_types ? TREE_CHAIN (arg_types): NULL_TREE);\n+  if (e2 || e1)\n     type = build_function_type (void_type_node, arg_types);\n \n   return type;"}, {"sha": "c5604e14681d6fc14b31d4c57aefd949bfc222ef", "filename": "gcc/cp/init.c", "status": "modified", "additions": 26, "deletions": 50, "changes": 76, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/da4768fe2e67468b4e4b321f07aa0c57836654b6/gcc%2Fcp%2Finit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/da4768fe2e67468b4e4b321f07aa0c57836654b6/gcc%2Fcp%2Finit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Finit.c?ref=da4768fe2e67468b4e4b321f07aa0c57836654b6", "patch": "@@ -2493,18 +2493,9 @@ build_new (placement, decl, init, use_global_new)\n     }\n \n   /* Allocate the object.  */\n-  if (! use_global_new && TYPE_LANG_SPECIFIC (true_type)\n-      && (TYPE_GETS_NEW (true_type) & (1 << has_array)))\n-    rval = build_opfncall (code, LOOKUP_NORMAL,\n-\t\t\t   build_pointer_type (true_type), size, placement);\n-  else if (placement)\n-    {\n-      rval = build_opfncall (code, LOOKUP_GLOBAL|LOOKUP_COMPLAIN,\n-\t\t\t     ptr_type_node, size, placement);\n-      rval = cp_convert (build_pointer_type (true_type), rval);\n-    }\n-  else if (! has_array && flag_this_is_variable > 0\n-\t   && TYPE_NEEDS_CONSTRUCTING (true_type) && init != void_type_node)\n+  \n+  if (! has_array && ! placement && flag_this_is_variable > 0\n+      && TYPE_NEEDS_CONSTRUCTING (true_type) && init != void_type_node)\n     {\n       if (init == NULL_TREE || TREE_CODE (init) == TREE_LIST)\n \trval = NULL_TREE;\n@@ -2516,10 +2507,10 @@ build_new (placement, decl, init, use_global_new)\n     }\n   else\n     {\n-      rval = build_builtin_call (build_pointer_type (true_type),\n-\t\t\t\t has_array ? BIVN : BIN,\n-\t\t\t\t build_expr_list (NULL_TREE, size));\n-      TREE_CALLS_NEW (rval) = 1;\n+      rval = build_op_new_call\n+\t(code, true_type, expr_tree_cons (NULL_TREE, size, placement),\n+\t LOOKUP_NORMAL | (use_global_new * LOOKUP_GLOBAL));\n+      rval = cp_convert (build_pointer_type (true_type), rval);\n     }\n \n   if (flag_exceptions && rval)\n@@ -2719,27 +2710,27 @@ build_new (placement, decl, init, use_global_new)\n \t an exception and the new-expression does not contain a\n \t new-placement, then the deallocation function is called to free\n \t the memory in which the object was being constructed.  */\n-      /* FIXME: handle placement delete.  */\n-      if (flag_exceptions && ! placement)\n+      if (flag_exceptions && alloc_expr)\n \t{\n-\t  tree cleanup = alloc_expr;\n+\t  enum tree_code dcode = has_array? VEC_DELETE_EXPR : DELETE_EXPR;\n+\t  tree cleanup, args = NULL_TREE;\n+\t  int flags = LOOKUP_NORMAL | (use_global_new * LOOKUP_GLOBAL);\n \n \t  /* All cleanups must last longer than normal.  */\n \t  int yes = suspend_momentary ();\n \n-\t  if (! use_global_new && TYPE_LANG_SPECIFIC (true_type)\n-\t      && (TYPE_GETS_DELETE (true_type) & (1 << has_array)))\n-\t    cleanup = build_opfncall (has_array? VEC_DELETE_EXPR : DELETE_EXPR,\n-\t\t\t\t      LOOKUP_NORMAL, cleanup, size, NULL_TREE);\n-\t  else\n-\t    cleanup = build_builtin_call\n-\t      (void_type_node, has_array ? BIVD : BID,\n-\t       build_expr_list (NULL_TREE, cleanup));\n+\t  if (placement)\n+\t    flags |= LOOKUP_SPECULATIVELY;\n+\n+\t  cleanup = build_op_delete_call (dcode, alloc_expr, size, flags);\n \n \t  resume_momentary (yes);\n-\t\t\t\t\t \n-\t  rval = build (TRY_CATCH_EXPR, TREE_TYPE (rval), rval, cleanup);\n-\t  rval = build (COMPOUND_EXPR, TREE_TYPE (rval), alloc_expr, rval);\n+\n+\t  if (cleanup)\n+\t    {\n+\t      rval = build (TRY_CATCH_EXPR, TREE_TYPE (rval), rval, cleanup);\n+\t      rval = build (COMPOUND_EXPR, TREE_TYPE (rval), alloc_expr, rval);\n+\t    }\n \t}\n     }\n   else if (TYPE_READONLY (true_type))\n@@ -3196,16 +3187,10 @@ build_x_delete (type, addr, which_delete, virtual_size)\n {\n   int use_global_delete = which_delete & 1;\n   int use_vec_delete = !!(which_delete & 2);\n-  tree rval;\n   enum tree_code code = use_vec_delete ? VEC_DELETE_EXPR : DELETE_EXPR;\n+  int flags = LOOKUP_NORMAL | (use_global_delete * LOOKUP_GLOBAL);\n \n-  if (! use_global_delete && TYPE_LANG_SPECIFIC (TREE_TYPE (type))\n-      && (TYPE_GETS_DELETE (TREE_TYPE (type)) & (1 << use_vec_delete)))\n-    rval = build_opfncall (code, LOOKUP_NORMAL, addr, virtual_size, NULL_TREE);\n-  else\n-    rval = build_builtin_call (void_type_node, use_vec_delete ? BIVD : BID,\n-\t\t\t       build_expr_list (NULL_TREE, addr));\n-  return rval;\n+  return build_op_delete_call (code, addr, virtual_size, flags);\n }\n \n /* Generate a call to a destructor. TYPE is the type to cast ADDR to.\n@@ -3302,18 +3287,9 @@ build_delete (type, addr, auto_delete, flags, use_global_delete)\n       if (auto_delete == integer_zero_node)\n \treturn void_zero_node;\n \n-      /* Pass the size of the object down to the operator delete() in\n-\t addition to the ADDR.  */\n-      if (TYPE_GETS_REG_DELETE (type) && !use_global_delete)\n-\t{\n-\t  tree virtual_size = c_sizeof_nowarn (type);\n-\t  return build_opfncall (DELETE_EXPR, LOOKUP_NORMAL, addr,\n-\t\t\t\t virtual_size, NULL_TREE);\n-\t}\n-\n-      /* Call the builtin operator delete.  */\n-      return build_builtin_call (void_type_node, BID,\n-\t\t\t\t build_expr_list (NULL_TREE, addr));\n+      return build_op_delete_call\n+\t(DELETE_EXPR, addr, c_sizeof_nowarn (type),\n+\t LOOKUP_NORMAL | (use_global_delete * LOOKUP_GLOBAL));\n     }\n \n   /* Below, we will reverse the order in which these calls are made."}]}