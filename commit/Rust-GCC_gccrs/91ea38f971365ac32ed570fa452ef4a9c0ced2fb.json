{"sha": "91ea38f971365ac32ed570fa452ef4a9c0ced2fb", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTFlYTM4Zjk3MTM2NWFjMzJlZDU3MGZhNDUyZWY0YTljMGNlZDJmYg==", "commit": {"author": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2002-05-31T11:54:11Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2002-05-31T11:54:11Z"}, "message": "i386.c (classify_argument): Properly handle base types.\n\n\t* i386.c (classify_argument): Properly handle base types.\n\n\t* dwarf2out.c (expand_builin_init_dwarf_reg_sizes):\n\tStore first DWARF_FRAME_REGISTERS dwarf registers, not pseudo\n\tregisters.\n\nFrom-SVN: r54106", "tree": {"sha": "28744d928e0ef04dd9c080224821167555ad523f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/28744d928e0ef04dd9c080224821167555ad523f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/91ea38f971365ac32ed570fa452ef4a9c0ced2fb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/91ea38f971365ac32ed570fa452ef4a9c0ced2fb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/91ea38f971365ac32ed570fa452ef4a9c0ced2fb", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/91ea38f971365ac32ed570fa452ef4a9c0ced2fb/comments", "author": null, "committer": null, "parents": [{"sha": "10d1bb3675d063e88ada643bdaa8f51e01f47e5f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/10d1bb3675d063e88ada643bdaa8f51e01f47e5f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/10d1bb3675d063e88ada643bdaa8f51e01f47e5f"}], "stats": {"total": 84, "additions": 74, "deletions": 10}, "files": [{"sha": "4a0d837cac6fc3b3e1eb8eeeaad747e9d3088e17", "filename": "gcc/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/91ea38f971365ac32ed570fa452ef4a9c0ced2fb/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/91ea38f971365ac32ed570fa452ef4a9c0ced2fb/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=91ea38f971365ac32ed570fa452ef4a9c0ced2fb", "patch": "@@ -1,3 +1,11 @@\n+Fri May 31 13:50:19 CEST 2002  Jan Hubicka  <jh@suse.cz>\n+\n+\t* i386.c (classify_argument): Properly handle base types.\n+\n+\t* dwarf2out.c (expand_builin_init_dwarf_reg_sizes):\n+\tStore first DWARF_FRAME_REGISTERS dwarf registers, not pseudo\n+\tregisters.\n+\n Fri May 31 13:37:54 CEST 2002  Jan Hubicka  <jh@suse.cz>\n \n \t* gcse.c (gcse_emit_move_after): New."}, {"sha": "d512646fdc52a5f497b315e175dab4bdf685e017", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 57, "deletions": 2, "changes": 59, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/91ea38f971365ac32ed570fa452ef4a9c0ced2fb/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/91ea38f971365ac32ed570fa452ef4a9c0ced2fb/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=91ea38f971365ac32ed570fa452ef4a9c0ced2fb", "patch": "@@ -1721,6 +1721,34 @@ classify_argument (mode, type, classes, bit_offset)\n       /* Classify each field of record and merge classes.  */\n       if (TREE_CODE (type) == RECORD_TYPE)\n \t{\n+\t  /* For classes first merge in the field of the subclasses.  */\n+\t  if (TYPE_BINFO (type) != NULL && TYPE_BINFO_BASETYPES (type) != NULL)\n+\t    {\n+\t      tree bases = TYPE_BINFO_BASETYPES (type);\n+\t      int n_bases = TREE_VEC_LENGTH (bases);\n+\t      int i;\n+\n+\t      for (i = 0; i < n_bases; ++i)\n+\t\t{\n+\t\t   tree binfo = TREE_VEC_ELT (bases, i);\n+\t\t   int num;\n+\t\t   int offset = tree_low_cst (BINFO_OFFSET (binfo), 0) * 8;\n+\t\t   tree type = BINFO_TYPE (binfo);\n+\n+\t\t   num = classify_argument (TYPE_MODE (type),\n+\t\t\t\t\t    type, subclasses,\n+\t\t\t\t\t    (offset + bit_offset) % 256);\n+\t\t   if (!num)\n+\t\t     return 0;\n+\t\t   for (i = 0; i < num; i++)\n+\t\t     {\n+\t\t       int pos = (offset + bit_offset) / 8 / 8;\n+\t\t       classes[i + pos] =\n+\t\t\t merge_classes (subclasses[i], classes[i + pos]);\n+\t\t     }\n+\t\t}\n+\t    }\n+\t  /* And now merge the fields of structure.   */\n \t  for (field = TYPE_FIELDS (type); field; field = TREE_CHAIN (field))\n \t    {\n \t      if (TREE_CODE (field) == FIELD_DECL)\n@@ -1781,6 +1809,33 @@ classify_argument (mode, type, classes, bit_offset)\n       else if (TREE_CODE (type) == UNION_TYPE\n \t       || TREE_CODE (type) == QUAL_UNION_TYPE)\n \t{\n+\t  /* For classes first merge in the field of the subclasses.  */\n+\t  if (TYPE_BINFO (type) != NULL && TYPE_BINFO_BASETYPES (type) != NULL)\n+\t    {\n+\t      tree bases = TYPE_BINFO_BASETYPES (type);\n+\t      int n_bases = TREE_VEC_LENGTH (bases);\n+\t      int i;\n+\n+\t      for (i = 0; i < n_bases; ++i)\n+\t\t{\n+\t\t   tree binfo = TREE_VEC_ELT (bases, i);\n+\t\t   int num;\n+\t\t   int offset = tree_low_cst (BINFO_OFFSET (binfo), 0) * 8;\n+\t\t   tree type = BINFO_TYPE (binfo);\n+\n+\t\t   num = classify_argument (TYPE_MODE (type),\n+\t\t\t\t\t    type, subclasses,\n+\t\t\t\t\t    (offset + bit_offset) % 256);\n+\t\t   if (!num)\n+\t\t     return 0;\n+\t\t   for (i = 0; i < num; i++)\n+\t\t     {\n+\t\t       int pos = (offset + bit_offset) / 8 / 8;\n+\t\t       classes[i + pos] =\n+\t\t\t merge_classes (subclasses[i], classes[i + pos]);\n+\t\t     }\n+\t\t}\n+\t    }\n \t  for (field = TYPE_FIELDS (type); field; field = TREE_CHAIN (field))\n \t    {\n \t      if (TREE_CODE (field) == FIELD_DECL)\n@@ -2213,11 +2268,11 @@ function_arg (cum, mode, type, named)\n   if (TARGET_DEBUG_ARG)\n     {\n       fprintf (stderr,\n-\t       \"function_arg (size=%d, wds=%2d, nregs=%d, mode=%4s, named=%d\",\n+\t       \"function_arg (size=%d, wds=%2d, nregs=%d, mode=%4s, named=%d, \",\n \t       words, cum->words, cum->nregs, GET_MODE_NAME (mode), named);\n \n       if (ret)\n-\tfprintf (stderr, \", reg=%%e%s\", reg_names[ REGNO (ret) ]);\n+\tprint_simple_rtl (stderr, ret);\n       else\n \tfprintf (stderr, \", stack\");\n "}, {"sha": "f4b0ee7ff5d93b3e4bcbe08eebaa645969a2a81e", "filename": "gcc/dwarf2out.c", "status": "modified", "additions": 9, "deletions": 8, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/91ea38f971365ac32ed570fa452ef4a9c0ced2fb/gcc%2Fdwarf2out.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/91ea38f971365ac32ed570fa452ef4a9c0ced2fb/gcc%2Fdwarf2out.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdwarf2out.c?ref=91ea38f971365ac32ed570fa452ef4a9c0ced2fb", "patch": "@@ -420,16 +420,17 @@ expand_builtin_init_dwarf_reg_sizes (address)\n   rtx addr = expand_expr (address, NULL_RTX, VOIDmode, 0);\n   rtx mem = gen_rtx_MEM (BLKmode, addr);\n \n-  for (i = 0; i < DWARF_FRAME_REGISTERS; i++)\n-    {\n-      HOST_WIDE_INT offset = DWARF_FRAME_REGNUM (i) * GET_MODE_SIZE (mode);\n-      HOST_WIDE_INT size = GET_MODE_SIZE (reg_raw_mode[i]);\n+  for (i = 0; i < FIRST_PSEUDO_REGISTER; i++)\n+    if (DWARF_FRAME_REGNUM (i) < DWARF_FRAME_REGISTERS)\n+      {\n+\tHOST_WIDE_INT offset = DWARF_FRAME_REGNUM (i) * GET_MODE_SIZE (mode);\n+\tHOST_WIDE_INT size = GET_MODE_SIZE (reg_raw_mode[i]);\n \n-      if (offset < 0)\n-\tcontinue;\n+\tif (offset < 0)\n+\t  continue;\n \n-      emit_move_insn (adjust_address (mem, mode, offset), GEN_INT (size));\n-    }\n+\temit_move_insn (adjust_address (mem, mode, offset), GEN_INT (size));\n+      }\n }\n \n /* Convert a DWARF call frame info. operation to its string name */"}]}