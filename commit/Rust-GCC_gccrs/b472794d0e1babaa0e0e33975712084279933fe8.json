{"sha": "b472794d0e1babaa0e0e33975712084279933fe8", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjQ3Mjc5NGQwZTFiYWJhYTBlMGUzMzk3NTcxMjA4NDI3OTkzM2ZlOA==", "commit": {"author": {"name": "Andrew MacLeod", "email": "amacleod@cygnus.com", "date": "1999-01-19T09:39:37Z"}, "committer": {"name": "Andrew Macleod", "email": "amacleod@gcc.gnu.org", "date": "1999-01-19T09:39:37Z"}, "message": "optabs.c (emit_libcall_block): Add a REG_EH_REGION reg note to all calls within a libcall block to indicate no...\n\n\t* optabs.c (emit_libcall_block): Add a REG_EH_REGION reg note to all\n\tcalls within a libcall block to indicate no throws are possible.\n\t* flow.c (find_basic_blocks, find_basic_blocks_1): Don't look for\n\tlibcall blocks. Don't add edges to exception handlers if we see\n\ta REG_EH_REGION note with a value of 0.\n\t(make_edges): Override active_eh_region vector if the call has a note\n\tindicating the call does not throw.\n\nFrom-SVN: r24757", "tree": {"sha": "78fafd43b4dbc569ee78f3f8754835b0bd6960e4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/78fafd43b4dbc569ee78f3f8754835b0bd6960e4"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b472794d0e1babaa0e0e33975712084279933fe8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b472794d0e1babaa0e0e33975712084279933fe8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b472794d0e1babaa0e0e33975712084279933fe8", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b472794d0e1babaa0e0e33975712084279933fe8/comments", "author": null, "committer": null, "parents": [{"sha": "35a6fc82940b2f9eb35d6b1c73b02c9f565168c1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/35a6fc82940b2f9eb35d6b1c73b02c9f565168c1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/35a6fc82940b2f9eb35d6b1c73b02c9f565168c1"}], "stats": {"total": 92, "additions": 56, "deletions": 36}, "files": [{"sha": "bc064c4e5b8e4acc41a281da7e25c6678f86ae72", "filename": "gcc/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b472794d0e1babaa0e0e33975712084279933fe8/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b472794d0e1babaa0e0e33975712084279933fe8/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=b472794d0e1babaa0e0e33975712084279933fe8", "patch": "@@ -1,3 +1,13 @@\n+Tue Jan 19 12:30:37 EST 1999  Andrew MacLeod  <amacleod@cygnus.com>\n+\n+\t* optabs.c (emit_libcall_block): Add a REG_EH_REGION reg note to all\n+\tcalls within a libcall block to indicate no throws are possible.\n+\t* flow.c (find_basic_blocks, find_basic_blocks_1): Don't look for \n+\tlibcall blocks. Don't add edges to exception handlers if we see \n+\ta REG_EH_REGION note with a value of 0.\n+\t(make_edges): Override active_eh_region vector if the call has a note\n+\tindicating the call does not throw.\n+\n 1999-01-19  Vladimir N. Makarov  <vmakarov@cygnus.com>\n \n \t* config/rs6000/sysv4.h (CC1_SPEC): Fix correct numbers of {}."}, {"sha": "aa72c6a966f1ee645f58ee90b158fe35ff6052e5", "filename": "gcc/flow.c", "status": "modified", "additions": 31, "deletions": 36, "changes": 67, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b472794d0e1babaa0e0e33975712084279933fe8/gcc%2Fflow.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b472794d0e1babaa0e0e33975712084279933fe8/gcc%2Fflow.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fflow.c?ref=b472794d0e1babaa0e0e33975712084279933fe8", "patch": "@@ -309,7 +309,6 @@ find_basic_blocks (f, nregs, file)\n   register rtx insn;\n   register int i;\n   rtx nonlocal_label_list = nonlocal_label_rtx_list ();\n-  int in_libcall_block = 0;\n \n   /* Avoid leaking memory if this is called multiple times per compiled\n      function.  */\n@@ -326,11 +325,6 @@ find_basic_blocks (f, nregs, file)\n \n     for (insn = f, i = 0; insn; insn = NEXT_INSN (insn))\n       {\n-\t/* Track when we are inside in LIBCALL block.  */\n-\tif (GET_RTX_CLASS (GET_CODE (insn)) == 'i'\n-\t    && find_reg_note (insn, REG_LIBCALL, NULL_RTX))\n-\t  in_libcall_block = 1;\n-\n \tcode = GET_CODE (insn);\n \n \t/* A basic block starts at label, or after something that can jump.  */\n@@ -354,17 +348,23 @@ find_basic_blocks (f, nregs, file)\n \t\temit_insn_after (nop, prev_call);\n \t      }\n \t  }\n-\t/* We change the code of the CALL_INSN, so that it won't start a\n-\t   new block.  */\n-\tif (code == CALL_INSN && in_libcall_block)\n-\t  code = INSN;\n \n-\t/* Record whether this call created an edge.  */\n \tif (code == CALL_INSN)\n-\t  {\n-\t    prev_call = insn;\n-\t    call_had_abnormal_edge = (nonlocal_label_list != 0 || eh_region);\n-\t  }\n+          {\n+            rtx note = find_reg_note(insn, REG_EH_REGION, NULL_RTX);\n+\n+            /* We change the code of the CALL_INSN, so that it won't start a\n+               new block.  */\n+            if (note && XINT (XEXP (note, 0), 0) == 0)\n+              code = INSN;\n+            else\n+              {\n+                prev_call = insn;\n+                call_had_abnormal_edge = (nonlocal_label_list != 0\n+                                          || eh_region);\n+              }\n+          }\n+\n \telse if (code != NOTE && code != BARRIER)\n \t  prev_call = 0;\n \n@@ -374,10 +374,6 @@ find_basic_blocks (f, nregs, file)\n \t  ++eh_region;\n \telse if (NOTE_LINE_NUMBER (insn) == NOTE_INSN_EH_REGION_END)\n \t  --eh_region;\n-\n-\tif (GET_RTX_CLASS (GET_CODE (insn)) == 'i'\n-\t    && find_reg_note (insn, REG_RETVAL, NULL_RTX))\n-\t  in_libcall_block = 0;\n       }\n   }\n \n@@ -447,7 +443,6 @@ find_basic_blocks_1 (f, nonlocal_labels)\n   rtx note, eh_note;\n   enum rtx_code prev_code, code;\n   int depth;\n-  int in_libcall_block = 0;\n   int call_had_abnormal_edge = 0;\n \n   active_eh_region = (int *) alloca ((max_uid_for_flow + 1) * sizeof (int));\n@@ -475,12 +470,6 @@ find_basic_blocks_1 (f, nonlocal_labels)\n   for (eh_note = NULL_RTX, insn = f, i = -1, prev_code = JUMP_INSN, depth = 1;\n        insn; insn = NEXT_INSN (insn))\n     {\n-\n-      /* Track when we are inside in LIBCALL block.  */\n-      if (GET_RTX_CLASS (GET_CODE (insn)) == 'i'\n-\t  && find_reg_note (insn, REG_LIBCALL, NULL_RTX))\n-\tin_libcall_block = 1;\n-\n       code = GET_CODE (insn);\n       if (code == NOTE)\n \t{\n@@ -550,16 +539,19 @@ find_basic_blocks_1 (f, nonlocal_labels)\n \t for every insn, since most insns can throw.  */\n       else if (eh_note\n \t       && (asynchronous_exceptions\n-\t\t   || (GET_CODE (insn) == CALL_INSN\n-\t\t       && ! in_libcall_block)))\n+\t\t   || (GET_CODE (insn) == CALL_INSN)))\n \tactive_eh_region[INSN_UID (insn)] =\n                                         NOTE_BLOCK_NUMBER (XEXP (eh_note, 0));\n       BLOCK_NUM (insn) = i;\n \n       /* We change the code of the CALL_INSN, so that it won't start a\n-\t new block.  */\n-      if (code == CALL_INSN && in_libcall_block)\n-\tcode = INSN;\n+\t new block if it doesn't throw.  */\n+      if (code == CALL_INSN)\n+        {\n+          rtx rnote = find_reg_note(insn, REG_EH_REGION, NULL_RTX);\n+          if (rnote && XINT (XEXP (rnote, 0), 0) == 0)\n+            code = INSN;\n+        }\n \n       /* Record whether this call created an edge.  */\n       if (code == CALL_INSN)\n@@ -568,9 +560,6 @@ find_basic_blocks_1 (f, nonlocal_labels)\n       if (code != NOTE)\n \tprev_code = code;\n \n-      if (GET_RTX_CLASS (GET_CODE (insn)) == 'i'\n-\t  && find_reg_note (insn, REG_RETVAL, NULL_RTX))\n-\tin_libcall_block = 0;\n     }\n \n   if (i + 1 != n_basic_blocks)\n@@ -839,9 +828,15 @@ make_edges (i)\n \t\t   || (GET_CODE (insn) == CALL_INSN\n \t\t       && ! find_reg_note (insn, REG_RETVAL, NULL_RTX)))\n \t    {\n-\t      if (active_eh_region[INSN_UID (insn)]) \n+              int region = active_eh_region[INSN_UID (insn)];\n+              note = find_reg_note(insn, REG_EH_REGION, NULL_RTX);\n+\n+              /* Override region if we see a REG_EH_REGION note. */\n+              if (note)\n+                region = XINT (XEXP (note, 0), 0);\n+\n+\t      if (region)\n \t\t{\n-\t\t  int region;\n \t\t  handler_info *ptr;\n \t\t  region = active_eh_region[INSN_UID (insn)];\n \t\t  for ( ; region; region = nested_eh_region[region])"}, {"sha": "8780f4eb4410891059d0e104b61880197528592b", "filename": "gcc/optabs.c", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b472794d0e1babaa0e0e33975712084279933fe8/gcc%2Foptabs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b472794d0e1babaa0e0e33975712084279933fe8/gcc%2Foptabs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Foptabs.c?ref=b472794d0e1babaa0e0e33975712084279933fe8", "patch": "@@ -2596,6 +2596,21 @@ emit_libcall_block (insns, target, result, equiv)\n {\n   rtx prev, next, first, last, insn;\n \n+  /* look for any CALL_INSNs in this sequence, and attach a REG_EH_REGION\n+     reg note to indicate that this call cannot throw. (Unless there is\n+     already a REG_EH_REGION note.) */\n+\n+  for (insn = insns; insn; insn = NEXT_INSN (insn))\n+    {\n+      if (GET_CODE (insn) == CALL_INSN)\n+        {\n+          rtx note = find_reg_note (insn, REG_EH_REGION, NULL_RTX);\n+          if (note == NULL_RTX)\n+            REG_NOTES (insn) = gen_rtx_EXPR_LIST (REG_EH_REGION, GEN_INT (0),\n+                                                  REG_NOTES (insn));\n+        }\n+    }\n+\n   /* First emit all insns that set pseudos.  Remove them from the list as\n      we go.  Avoid insns that set pseudos which were referenced in previous\n      insns.  These can be generated by move_by_pieces, for example,"}]}