{"sha": "084c1779088967df7cde7aef1ac91587d68ab3bb", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDg0YzE3NzkwODg5NjdkZjdjZGU3YWVmMWFjOTE1ODdkNjhhYjNiYg==", "commit": {"author": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2003-07-09T00:31:20Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2003-07-09T00:31:20Z"}, "message": "java-tree.h (DECL_NUM_STMTS): Rename to...\n\n\n\t* java-tree.h (DECL_NUM_STMTS): Rename to...\n\t(DECL_ESTIMATED_INSNS): ... this.\n\t* lang.c (java_estimate_num_insns, java_estimate_num_insns_1):\n\tNew static functions.\n\t(LANG_HOOKS_TREE_INLINING_ESTIMATE_NUM_INSNS): Define.\n\t* parser.y (add_stmt_to_compound): Do not account statements.\n\n\t* cp-lang.c (LANG_HOOKS_TREE_INLINING_ESTIMATE_NUM_INSNS): New.\n\t* decl.c (duplicate_decls): Use DECL_ESTIMATED_INSNS.\n\t(start_function): Use DECL_ESTIMATED_INSNS.\n\t* optimize.c (maybe_clone_body): Use DECL_ESTIMATED_INSNS.\n\n\t* decl2.c (maybe_emit_vtables): Fix marking vtables as needed in\n\tunit-at-a-time\n\n\t* c-common.c (c_estimate_num_insns_1): New static function.\n\t(c_estimate_num_insns): New global function.\n\t* c-common.h (DECL_NUM_STMTS): Rename to...\n\t(DECL_ESTIMATED_INSNS): ... this.\n\t(c_estimate_num_insns): Declare.\n\t* c-decl.c (duplicate_decls): Use DECL_ESTIMATED_INSNS.\n\t* c-lang.c (LANG_HOOKS_TREE_INLINING_ESTIMATE_NUM_INSNS): New.\n\t* c-semantics.c (add_stmt): Do not account statements.\n\t* langhooks-def.h (LANG_HOOKS_TREE_INLINING_ESTIMATE_NUM_INSNS):\n\tNew.\n\t* langhooks.h (lang_hooks_for_tree_inlining): Add\n\testimate_num_insns\n\t* params.def (max-inline-insns-auto, max-inline-insns-auto): set\n\tto 100.\n\t(max-inline-insns): set to 300.\n\t(min-inline-insns): set to 10.\n\t* tree-inline.c (struct inline_data): Rename inlined_stmts to\n\tinlined-insns.\n\t(INSNS_PER_STMT): Kill.\n\t(inlinable_function_p): Compute and store body size.\n\t(expand_call_inline): Likewise.\n\t(optimize_inline_calls): Likewise.\n\nFrom-SVN: r69113", "tree": {"sha": "5029eb04a9f787f6958b11882444a0e5bc409cfb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5029eb04a9f787f6958b11882444a0e5bc409cfb"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/084c1779088967df7cde7aef1ac91587d68ab3bb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/084c1779088967df7cde7aef1ac91587d68ab3bb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/084c1779088967df7cde7aef1ac91587d68ab3bb", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/084c1779088967df7cde7aef1ac91587d68ab3bb/comments", "author": null, "committer": null, "parents": [{"sha": "1b1838b64cf2ee0cc35ddf75020894de2a84ee38", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1b1838b64cf2ee0cc35ddf75020894de2a84ee38", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1b1838b64cf2ee0cc35ddf75020894de2a84ee38"}], "stats": {"total": 354, "additions": 309, "deletions": 45}, "files": [{"sha": "261d8c78683a04459c640d262892d921713f5684", "filename": "gcc/ChangeLog", "status": "modified", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/084c1779088967df7cde7aef1ac91587d68ab3bb/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/084c1779088967df7cde7aef1ac91587d68ab3bb/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=084c1779088967df7cde7aef1ac91587d68ab3bb", "patch": "@@ -1,3 +1,28 @@\n+Wed Jul  9 02:25:39 CEST 2003  Jan Hubicka  <jh@suse.cz>\n+\n+\t* c-common.c (c_estimate_num_insns_1): New static function.\n+\t(c_estimate_num_insns): New global function.\n+\t* c-common.h (DECL_NUM_STMTS): Rename to...\n+\t(DECL_ESTIMATED_INSNS): ... this.\n+\t(c_estimate_num_insns): Declare.\n+\t* c-decl.c (duplicate_decls): Use DECL_ESTIMATED_INSNS.\n+\t* c-lang.c (LANG_HOOKS_TREE_INLINING_ESTIMATE_NUM_INSNS): New.\n+\t* c-semantics.c (add_stmt): Do not account statements.\n+\t* langhooks-def.h (LANG_HOOKS_TREE_INLINING_ESTIMATE_NUM_INSNS):\n+\tNew.\n+\t* langhooks.h (lang_hooks_for_tree_inlining): Add\n+\testimate_num_insns\n+\t* params.def (max-inline-insns-auto, max-inline-insns-auto): set\n+\tto 100.\n+\t(max-inline-insns): set to 300.\n+\t(min-inline-insns): set to 10.\n+\t* tree-inline.c (struct inline_data): Rename inlined_stmts to\n+\tinlined-insns.\n+\t(INSNS_PER_STMT): Kill.\n+\t(inlinable_function_p): Compute and store body size.\n+\t(expand_call_inline): Likewise.\n+\t(optimize_inline_calls): Likewise.\n+\n 2003-07-08  James E Wilson  <wilson@tuliptree.org>\n \n \tPR target/10021"}, {"sha": "49ff8707e272a241144fccc9d6b9751e7eea70c2", "filename": "gcc/c-common.c", "status": "modified", "additions": 110, "deletions": 0, "changes": 110, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/084c1779088967df7cde7aef1ac91587d68ab3bb/gcc%2Fc-common.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/084c1779088967df7cde7aef1ac91587d68ab3bb/gcc%2Fc-common.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-common.c?ref=084c1779088967df7cde7aef1ac91587d68ab3bb", "patch": "@@ -5881,4 +5881,114 @@ check_function_arguments_recurse (void (*callback)\n   (*callback) (ctx, param, param_num);\n }\n \n+/* Used by estimate_num_insns.  Estimate number of instructions seen\n+   by given statement.  */\n+static tree\n+c_estimate_num_insns_1 (tree *tp, int *walk_subtrees, void *data)\n+{\n+  int *count = data;\n+  tree x = *tp;\n+\n+  if (TYPE_P (x) || DECL_P (x))\n+    {\n+      *walk_subtrees = 0;\n+      return NULL;\n+    }\n+  /* Assume that constants and references counts nothing.  These should\n+     be majorized by amount of operations amoung them we count later\n+     and are common target of CSE and similar optimizations.  */\n+  if (TREE_CODE_CLASS (TREE_CODE (x)) == 'c'\n+      || TREE_CODE_CLASS (TREE_CODE (x)) == 'r')\n+    return NULL;\n+  switch (TREE_CODE (x))\n+    { \n+    /* Reconginze assignments of large structures and constructors of\n+       big arrays.  */\n+    case MODIFY_EXPR:\n+    case CONSTRUCTOR:\n+      {\n+\tint size = int_size_in_bytes (TREE_TYPE (x));\n+\n+\tif (!size || size > MOVE_MAX_PIECES)\n+\t  *count += 10;\n+\telse\n+\t  *count += 2 * (size + MOVE_MAX - 1) / MOVE_MAX;\n+\treturn NULL;\n+      }\n+      break;\n+    /* Few special cases of expensive operations.  This is usefull\n+       to avoid inlining on functions having too many of these.  */\n+    case TRUNC_DIV_EXPR:\n+    case CEIL_DIV_EXPR:\n+    case FLOOR_DIV_EXPR:\n+    case ROUND_DIV_EXPR:\n+    case TRUNC_MOD_EXPR:\n+    case CEIL_MOD_EXPR:\n+    case FLOOR_MOD_EXPR:\n+    case ROUND_MOD_EXPR:\n+    case RDIV_EXPR:\n+    case CALL_EXPR:\n+    case METHOD_CALL_EXPR:\n+      *count += 10;\n+      break;\n+    /* Various containers that will produce no code themselves.  */\n+    case INIT_EXPR:\n+    case TARGET_EXPR:\n+    case BIND_EXPR:\n+    case BLOCK:\n+    case TREE_LIST:\n+    case TREE_VEC:\n+    case IDENTIFIER_NODE:\n+    case PLACEHOLDER_EXPR:\n+    case WITH_CLEANUP_EXPR:\n+    case CLEANUP_POINT_EXPR:\n+    case NOP_EXPR:\n+    case VIEW_CONVERT_EXPR:\n+    case SAVE_EXPR:\n+    case UNSAVE_EXPR:\n+    case COMPLEX_EXPR:\n+    case REALPART_EXPR:\n+    case IMAGPART_EXPR:\n+    case TRY_CATCH_EXPR:\n+    case TRY_FINALLY_EXPR:\n+    case LABEL_EXPR:\n+    case EXIT_EXPR:\n+    case LABELED_BLOCK_EXPR:\n+    case EXIT_BLOCK_EXPR:\n+    case EXPR_WITH_FILE_LOCATION:\n+\n+    case EXPR_STMT:\n+    case COMPOUND_STMT:\n+    case RETURN_STMT:\n+    case LABEL_STMT:\n+    case SCOPE_STMT:\n+    case FILE_STMT:\n+    case CASE_LABEL:\n+    case STMT_EXPR:\n+    case CLEANUP_STMT:\n+\n+    case SIZEOF_EXPR:\n+    case ARROW_EXPR:\n+    case ALIGNOF_EXPR:\n+      break;\n+    case DECL_STMT:\n+      /* Do not account static initializers.  */\n+      if (TREE_STATIC (TREE_OPERAND (x, 0)))\n+\t*walk_subtrees = 0;\n+      break;\n+    default:\n+      (*count)++;\n+    }\n+  return NULL;\n+}\n+\n+/*  Estimate number of instructions that will be created by expanding the body.  */\n+int\n+c_estimate_num_insns (tree decl)\n+{\n+  int num = 0;\n+  walk_tree_without_duplicates (&DECL_SAVED_TREE (decl), c_estimate_num_insns_1, &num);\n+  return num;\n+}\n+\n #include \"gt-c-common.h\""}, {"sha": "7fdd80969b9c512ee4fb2846d181ae476a5f3d32", "filename": "gcc/c-common.h", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/084c1779088967df7cde7aef1ac91587d68ab3bb/gcc%2Fc-common.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/084c1779088967df7cde7aef1ac91587d68ab3bb/gcc%2Fc-common.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-common.h?ref=084c1779088967df7cde7aef1ac91587d68ab3bb", "patch": "@@ -357,7 +357,7 @@ struct c_lang_decl GTY(()) {\n      the approximate number of statements in this function.  There is\n      no need for this number to be exact; it is only used in various\n      heuristics regarding optimization.  */\n-#define DECL_NUM_STMTS(NODE) \\\n+#define DECL_ESTIMATED_INSNS(NODE) \\\n   (FUNCTION_DECL_CHECK (NODE)->decl.u1.i)\n \n /* Nonzero if we can read a PCH file now.  */\n@@ -1296,6 +1296,7 @@ extern void c_common_write_pch (void);\n extern void builtin_define_with_value (const char *, const char *, int);\n extern void c_stddef_cpp_builtins (void);\n extern void fe_file_change (const struct line_map *);\n+extern int c_estimate_num_insns (tree decl);\n \n /* In c-ppoutput.c  */\n extern void init_pp_output (FILE *);"}, {"sha": "fbe0b02a810edd4555bf6a28466af151d8d28a4f", "filename": "gcc/c-decl.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/084c1779088967df7cde7aef1ac91587d68ab3bb/gcc%2Fc-decl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/084c1779088967df7cde7aef1ac91587d68ab3bb/gcc%2Fc-decl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-decl.c?ref=084c1779088967df7cde7aef1ac91587d68ab3bb", "patch": "@@ -1471,7 +1471,7 @@ duplicate_decls (tree newdecl, tree olddecl, int different_binding_level)\n \t    DECL_INITIAL (newdecl) = DECL_INITIAL (olddecl);\n \t  DECL_SAVED_INSNS (newdecl) = DECL_SAVED_INSNS (olddecl);\n \t  DECL_SAVED_TREE (newdecl) = DECL_SAVED_TREE (olddecl);\n-\t  DECL_NUM_STMTS (newdecl) = DECL_NUM_STMTS (olddecl);\n+\t  DECL_ESTIMATED_INSNS (newdecl) = DECL_ESTIMATED_INSNS (olddecl);\n \t  DECL_ARGUMENTS (newdecl) = DECL_ARGUMENTS (olddecl);\n \n \t  /* Set DECL_INLINE on the declaration if we've got a body"}, {"sha": "815a72f1a200ada67ba2cd581ec7ea86bd4de95d", "filename": "gcc/c-lang.c", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/084c1779088967df7cde7aef1ac91587d68ab3bb/gcc%2Fc-lang.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/084c1779088967df7cde7aef1ac91587d68ab3bb/gcc%2Fc-lang.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-lang.c?ref=084c1779088967df7cde7aef1ac91587d68ab3bb", "patch": "@@ -102,6 +102,8 @@ enum c_language_kind c_language = clk_c;\n #undef LANG_HOOKS_TREE_INLINING_CONVERT_PARM_FOR_INLINING\n #define LANG_HOOKS_TREE_INLINING_CONVERT_PARM_FOR_INLINING \\\n   c_convert_parm_for_inlining\n+#undef LANG_HOOKS_TREE_INLINING_ESTIMATE_NUM_INSNS\n+#define LANG_HOOKS_TREE_INLINING_ESTIMATE_NUM_INSNS c_estimate_num_insns\n #undef LANG_HOOKS_TREE_DUMP_DUMP_TREE_FN\n #define LANG_HOOKS_TREE_DUMP_DUMP_TREE_FN c_dump_tree\n "}, {"sha": "438b3fba808f938e45b908c28b16936924ab6bcc", "filename": "gcc/c-objc-common.c", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/084c1779088967df7cde7aef1ac91587d68ab3bb/gcc%2Fc-objc-common.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/084c1779088967df7cde7aef1ac91587d68ab3bb/gcc%2Fc-objc-common.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-objc-common.c?ref=084c1779088967df7cde7aef1ac91587d68ab3bb", "patch": "@@ -211,8 +211,7 @@ c_cannot_inline_tree_fn (tree *fnp)\n \treturn 0;\n     }\n \n-  if (walk_tree_without_duplicates (&DECL_SAVED_TREE (fn),\n-\t\t\t\t    inline_forbidden_p, fn))\n+  if (walk_tree (&DECL_SAVED_TREE (fn), inline_forbidden_p, fn, NULL))\n     goto cannot_inline;\n \n   return 0;"}, {"sha": "933ed50f27fce7bcec8439d62ea1c362f39ceaab", "filename": "gcc/c-semantics.c", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/084c1779088967df7cde7aef1ac91587d68ab3bb/gcc%2Fc-semantics.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/084c1779088967df7cde7aef1ac91587d68ab3bb/gcc%2Fc-semantics.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-semantics.c?ref=084c1779088967df7cde7aef1ac91587d68ab3bb", "patch": "@@ -102,10 +102,6 @@ add_stmt (tree t)\n      statements are full-expressions.  We record that fact here.  */\n   STMT_IS_FULL_EXPR_P (last_tree) = stmts_are_full_exprs_p ();\n \n-  /* Keep track of the number of statements in this function.  */\n-  if (current_function_decl)\n-    ++DECL_NUM_STMTS (current_function_decl);\n-\n   return t;\n }\n "}, {"sha": "a4b9aea45351a32a8497941ed84c79708a898c1c", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/084c1779088967df7cde7aef1ac91587d68ab3bb/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/084c1779088967df7cde7aef1ac91587d68ab3bb/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=084c1779088967df7cde7aef1ac91587d68ab3bb", "patch": "@@ -1,3 +1,13 @@\n+Wed Jul  9 02:28:39 CEST 2003  Jan Hubicka  <jh@suse.cz>\n+\n+\t* cp-lang.c (LANG_HOOKS_TREE_INLINING_ESTIMATE_NUM_INSNS): New.\n+\t* decl.c (duplicate_decls): Use DECL_ESTIMATED_INSNS.\n+\t(start_function): Use DECL_ESTIMATED_INSNS.\n+\t* optimize.c (maybe_clone_body): Use DECL_ESTIMATED_INSNS.\n+\n+\t* decl2.c (maybe_emit_vtables): Fix marking vtables as needed in\n+\tunit-at-a-time\n+\n 2003-07-08  Kriang Lerdsuwanakij  <lerdsuwa@users.sourceforge.net>\n \n \tPR c++/11030"}, {"sha": "741a0cc7747e425146bd3a47b0e6f86b6adef233", "filename": "gcc/cp/cp-lang.c", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/084c1779088967df7cde7aef1ac91587d68ab3bb/gcc%2Fcp%2Fcp-lang.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/084c1779088967df7cde7aef1ac91587d68ab3bb/gcc%2Fcp%2Fcp-lang.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-lang.c?ref=084c1779088967df7cde7aef1ac91587d68ab3bb", "patch": "@@ -144,6 +144,8 @@ static bool cp_var_mod_type_p (tree);\n #define LANG_HOOKS_TREE_INLINING_START_INLINING cp_start_inlining\n #undef LANG_HOOKS_TREE_INLINING_END_INLINING\n #define LANG_HOOKS_TREE_INLINING_END_INLINING cp_end_inlining\n+#undef LANG_HOOKS_TREE_INLINING_ESTIMATE_NUM_INSNS\n+#define LANG_HOOKS_TREE_INLINING_ESTIMATE_NUM_INSNS c_estimate_num_insns\n #undef LANG_HOOKS_TREE_DUMP_DUMP_TREE_FN\n #define LANG_HOOKS_TREE_DUMP_DUMP_TREE_FN cp_dump_tree\n #undef LANG_HOOKS_TREE_DUMP_TYPE_QUALS_FN"}, {"sha": "4534a7622b967257ff476ce4dd1bc4307633ee14", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/084c1779088967df7cde7aef1ac91587d68ab3bb/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/084c1779088967df7cde7aef1ac91587d68ab3bb/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=084c1779088967df7cde7aef1ac91587d68ab3bb", "patch": "@@ -3530,7 +3530,7 @@ duplicate_decls (tree newdecl, tree olddecl)\n \t      SET_DECL_RTL (newdecl, DECL_RTL (olddecl));\n \t    }\n \t  else\n-\t    DECL_NUM_STMTS (newdecl) = DECL_NUM_STMTS (olddecl);\n+\t    DECL_ESTIMATED_INSNS (newdecl) = DECL_ESTIMATED_INSNS (olddecl);\n \n \t  DECL_RESULT (newdecl) = DECL_RESULT (olddecl);\n \t  /* Don't clear out the arguments if we're redefining a function.  */\n@@ -13518,7 +13518,7 @@ start_function (tree declspecs, tree declarator, tree attrs, int flags)\n   begin_stmt_tree (&DECL_SAVED_TREE (decl1));\n \n   /* Don't double-count statements in templates.  */\n-  DECL_NUM_STMTS (decl1) = 0;\n+  DECL_ESTIMATED_INSNS (decl1) = 0;\n \n   /* Let the user know we're compiling this function.  */\n   announce_function (decl1);"}, {"sha": "7a2399a6016d7865325d47c9e94ba260ac7c934a", "filename": "gcc/cp/decl2.c", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/084c1779088967df7cde7aef1ac91587d68ab3bb/gcc%2Fcp%2Fdecl2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/084c1779088967df7cde7aef1ac91587d68ab3bb/gcc%2Fcp%2Fdecl2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl2.c?ref=084c1779088967df7cde7aef1ac91587d68ab3bb", "patch": "@@ -1634,6 +1634,7 @@ maybe_emit_vtables (tree ctype)\n {\n   tree vtbl;\n   tree primary_vtbl;\n+  bool needed = false;\n \n   /* If the vtables for this class have already been emitted there is\n      nothing more to do.  */\n@@ -1651,7 +1652,6 @@ maybe_emit_vtables (tree ctype)\n   for (vtbl = CLASSTYPE_VTABLES (ctype); vtbl; vtbl = TREE_CHAIN (vtbl))\n     if (!DECL_EXTERNAL (vtbl) && DECL_NEEDED_P (vtbl))\n       break;\n-  \n   if (!vtbl)\n     {\n       /* If the references to this class' vtables are optimized away,\n@@ -1662,6 +1662,9 @@ maybe_emit_vtables (tree ctype)\n \tnote_debug_info_needed (ctype);\n       return false;\n     }\n+  else if (TREE_PUBLIC (vtbl) && !DECL_COMDAT (vtbl))\n+    needed = true;\n+  \n \n   /* The ABI requires that we emit all of the vtables if we emit any\n      of them.  */\n@@ -1672,7 +1675,7 @@ maybe_emit_vtables (tree ctype)\n       mark_vtable_entries (vtbl);\n \n       /* If we know that DECL is needed, mark it as such for the varpool.  */\n-      if (CLASSTYPE_EXPLICIT_INSTANTIATION (ctype))\n+      if (needed)\n \tcgraph_varpool_mark_needed_node (cgraph_varpool_node (vtbl));\n \n       if (TREE_TYPE (DECL_INITIAL (vtbl)) == 0)"}, {"sha": "c52970fd4b69a44758dcad2581a3830cecc3f760", "filename": "gcc/cp/optimize.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/084c1779088967df7cde7aef1ac91587d68ab3bb/gcc%2Fcp%2Foptimize.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/084c1779088967df7cde7aef1ac91587d68ab3bb/gcc%2Fcp%2Foptimize.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Foptimize.c?ref=084c1779088967df7cde7aef1ac91587d68ab3bb", "patch": "@@ -254,7 +254,7 @@ maybe_clone_body (tree fn)\n \n       /* There are as many statements in the clone as in the\n \t original.  */\n-      DECL_NUM_STMTS (clone) = DECL_NUM_STMTS (fn);\n+      DECL_ESTIMATED_INSNS (clone) = DECL_ESTIMATED_INSNS (fn);\n \n       /* Clean up.  */\n       splay_tree_delete (decl_map);"}, {"sha": "ade4e1f6b5ecaaf3d9c6997e8f3e7180b2bd0342", "filename": "gcc/doc/invoke.texi", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/084c1779088967df7cde7aef1ac91587d68ab3bb/gcc%2Fdoc%2Finvoke.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/084c1779088967df7cde7aef1ac91587d68ab3bb/gcc%2Fdoc%2Finvoke.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Finvoke.texi?ref=084c1779088967df7cde7aef1ac91587d68ab3bb", "patch": "@@ -4532,15 +4532,15 @@ This number sets the maximum number of instructions (counted in gcc's\n internal representation) in a single function that the tree inliner \n will consider for inlining.  This only affects functions declared\n inline and methods implemented in a class declaration (C++).\n-The default value is 300.\n+The default value is 100.\n \n @item max-inline-insns-auto\n When you use @option{-finline-functions} (included in @option{-O3}),\n a lot of functions that would otherwise not be considered for inlining\n by the compiler will be investigated.  To those functions, a different\n (more restrictive) limit compared to functions declared inline can\n be applied.\n-The default value is 300.\n+The default value is 100.\n \n @item max-inline-insns\n The tree inliner does decrease the allowable size for single functions \n@@ -4551,7 +4551,7 @@ Higher numbers result in better runtime performance, but incur higher\n compile-time resource (CPU time, memory) requirements and result in\n larger binaries.  Very high values are not advisable, as too large\n binaries may adversely affect runtime performance.\n-The default value is 600.\n+The default value is 200.\n \n @item max-inline-slope\n After exceeding the maximum number of inlined instructions by repeated\n@@ -4565,7 +4565,7 @@ The repeated inlining is throttled more and more by the linear function\n after exceeding the limit.  To avoid too much throttling, a minimum for\n this function is specified here to allow repeated inlining for very small\n functions even when a lot of repeated inlining already has been done.\n-The default value is 130.\n+The default value is 10.\n \n @item max-inline-insns-rtl\n For languages that use the RTL inliner (this happens at a later stage"}, {"sha": "fba4f04110b7031c1d47b1c80f2d366961acc84e", "filename": "gcc/java/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/084c1779088967df7cde7aef1ac91587d68ab3bb/gcc%2Fjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/084c1779088967df7cde7aef1ac91587d68ab3bb/gcc%2Fjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2FChangeLog?ref=084c1779088967df7cde7aef1ac91587d68ab3bb", "patch": "@@ -1,3 +1,12 @@\n+Wed Jul  9 02:29:15 CEST 2003  Jan Hubicka  <jh@suse.cz>\n+\n+\t* java-tree.h (DECL_NUM_STMTS): Rename to...\n+\t(DECL_ESTIMATED_INSNS): ... this.\n+\t* lang.c (java_estimate_num_insns, java_estimate_num_insns_1):\n+\tNew static functions.\n+\t(LANG_HOOKS_TREE_INLINING_ESTIMATE_NUM_INSNS): Define.\n+\t* parser.y (add_stmt_to_compound): Do not account statements.\n+\n 2003-07-08  Mark Wielaard  <mark@klomp.org>\n \n \t* gcj.texi: CNI now expands to Compiled Native Interface."}, {"sha": "357f349317053fcbc4a50e1a8293b883a8351bab", "filename": "gcc/java/java-tree.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/084c1779088967df7cde7aef1ac91587d68ab3bb/gcc%2Fjava%2Fjava-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/084c1779088967df7cde7aef1ac91587d68ab3bb/gcc%2Fjava%2Fjava-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fjava-tree.h?ref=084c1779088967df7cde7aef1ac91587d68ab3bb", "patch": "@@ -922,10 +922,10 @@ union lang_tree_node\n #define DECL_FIELD_FINAL_WFL(NODE) \\\n   (DECL_LANG_SPECIFIC(NODE)->u.v.wfl)\n /* In a FUNCTION_DECL for which DECL_BUILT_IN does not hold, this is\n-     the approximate number of statements in this function.  There is\n+     the approximate number of instructions in this function.  There is\n      no need for this number to be exact; it is only used in various\n      heuristics regarding optimization.  */\n-#define DECL_NUM_STMTS(NODE) \\\n+#define DECL_ESTIMATED_INSNS(NODE) \\\n   (FUNCTION_DECL_CHECK (NODE)->decl.u1.i)\n /* True if NODE is a local variable final. */\n #define LOCAL_FINAL_P(NODE) (DECL_LANG_SPECIFIC (NODE) && DECL_FINAL (NODE))"}, {"sha": "1f9470627fae995fc324f7bbd18fff27df0b05bc", "filename": "gcc/java/lang.c", "status": "modified", "additions": 107, "deletions": 0, "changes": 107, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/084c1779088967df7cde7aef1ac91587d68ab3bb/gcc%2Fjava%2Flang.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/084c1779088967df7cde7aef1ac91587d68ab3bb/gcc%2Fjava%2Flang.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Flang.c?ref=084c1779088967df7cde7aef1ac91587d68ab3bb", "patch": "@@ -66,6 +66,7 @@ static bool java_can_use_bit_fields_p (void);\n static bool java_dump_tree (void *, tree);\n static void dump_compound_expr (dump_info_p, tree);\n static bool java_decl_ok_for_sibcall (tree);\n+static int java_estimate_num_insns (tree);\n \n #ifndef TARGET_OBJECT_SUFFIX\n # define TARGET_OBJECT_SUFFIX \".o\"\n@@ -249,6 +250,9 @@ struct language_function GTY(())\n #undef LANG_HOOKS_TREE_INLINING_WALK_SUBTREES\n #define LANG_HOOKS_TREE_INLINING_WALK_SUBTREES java_tree_inlining_walk_subtrees\n \n+#undef LANG_HOOKS_TREE_INLINING_ESTIMATE_NUM_INSNS\n+#define LANG_HOOKS_TREE_INLINING_ESTIMATE_NUM_INSNS java_estimate_num_insns\n+\n #undef LANG_HOOKS_TREE_DUMP_DUMP_TREE_FN\n #define LANG_HOOKS_TREE_DUMP_DUMP_TREE_FN java_dump_tree\n \n@@ -1076,4 +1080,107 @@ java_decl_ok_for_sibcall (tree decl)\n   return decl != NULL && DECL_CONTEXT (decl) == current_class;\n }\n \n+/* Used by estimate_num_insns.  Estimate number of instructions seen\n+   by given statement.  */\n+static tree\n+java_estimate_num_insns_1 (tree *tp, int *walk_subtrees, void *data)\n+{\n+  int *count = data;\n+  tree x = *tp;\n+\n+  if (TYPE_P (x) || DECL_P (x))\n+    {\n+      *walk_subtrees = 0;\n+      return NULL;\n+    }\n+  /* Assume that constants and references counts nothing.  These should\n+     be majorized by amount of operations amoung them we count later\n+     and are common target of CSE and similar optimizations.  */\n+  if (TREE_CODE_CLASS (TREE_CODE (x)) == 'c'\n+      || TREE_CODE_CLASS (TREE_CODE (x)) == 'r')\n+    return NULL;\n+  switch (TREE_CODE (x))\n+    { \n+    /* Reconginze assignments of large structures and constructors of\n+       big arrays.  */\n+    case MODIFY_EXPR:\n+    case CONSTRUCTOR:\n+      {\n+\tint size = int_size_in_bytes (TREE_TYPE (x));\n+\n+\tif (!size || size > MOVE_MAX_PIECES)\n+\t  *count += 10;\n+\telse\n+\t  *count += 2 * (size + MOVE_MAX - 1) / MOVE_MAX;\n+\treturn NULL;\n+      }\n+      break;\n+    /* Few special cases of expensive operations.  This is usefull\n+       to avoid inlining on functions having too many of these.  */\n+    case TRUNC_DIV_EXPR:\n+    case CEIL_DIV_EXPR:\n+    case FLOOR_DIV_EXPR:\n+    case ROUND_DIV_EXPR:\n+    case TRUNC_MOD_EXPR:\n+    case CEIL_MOD_EXPR:\n+    case FLOOR_MOD_EXPR:\n+    case ROUND_MOD_EXPR:\n+    case RDIV_EXPR:\n+    case CALL_EXPR:\n+    case METHOD_CALL_EXPR:\n+\n+    case NEW_ARRAY_EXPR:\n+    case NEW_ANONYMOUS_ARRAY_EXPR:\n+    case NEW_CLASS_EXPR:\n+      *count += 10;\n+      break;\n+    /* Various containers that will produce no code themselves.  */\n+    case INIT_EXPR:\n+    case TARGET_EXPR:\n+    case BIND_EXPR:\n+    case BLOCK:\n+    case TREE_LIST:\n+    case TREE_VEC:\n+    case IDENTIFIER_NODE:\n+    case PLACEHOLDER_EXPR:\n+    case WITH_CLEANUP_EXPR:\n+    case CLEANUP_POINT_EXPR:\n+    case NOP_EXPR:\n+    case VIEW_CONVERT_EXPR:\n+    case SAVE_EXPR:\n+    case UNSAVE_EXPR:\n+    case COMPLEX_EXPR:\n+    case REALPART_EXPR:\n+    case IMAGPART_EXPR:\n+    case TRY_CATCH_EXPR:\n+    case TRY_FINALLY_EXPR:\n+    case LABEL_EXPR:\n+    case EXIT_EXPR:\n+    case LABELED_BLOCK_EXPR:\n+    case EXIT_BLOCK_EXPR:\n+    case EXPR_WITH_FILE_LOCATION:\n+    case UNARY_PLUS_EXPR:\n+    case THIS_EXPR:\n+    case DEFAULT_EXPR:\n+    case TRY_EXPR:\n+\n+      break;\n+    case CLASS_LITERAL:\n+      *walk_subtrees = 0;\n+      break;\n+    default:\n+      (*count)++;\n+    }\n+  return NULL;\n+}\n+\n+/*  Estimate number of instructions that will be created by expanding the body.  */\n+static int\n+java_estimate_num_insns (tree decl)\n+{\n+  int num = 0;\n+  walk_tree (&DECL_SAVED_TREE (decl), java_estimate_num_insns_1, &num, NULL);\n+  return num;\n+}\n+\n #include \"gt-java-lang.h\""}, {"sha": "cbb4297f96297b3d99a38e76f622b0b5b85dfe2d", "filename": "gcc/java/parse.y", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/084c1779088967df7cde7aef1ac91587d68ab3bb/gcc%2Fjava%2Fparse.y", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/084c1779088967df7cde7aef1ac91587d68ab3bb/gcc%2Fjava%2Fparse.y", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fparse.y?ref=084c1779088967df7cde7aef1ac91587d68ab3bb", "patch": "@@ -7429,10 +7429,6 @@ add_stmt_to_block (tree b, tree type, tree stmt)\n static tree\n add_stmt_to_compound (tree existing, tree type, tree stmt)\n {\n-  /* Keep track of this for inlining.  */\n-  if (current_function_decl)\n-    ++DECL_NUM_STMTS (current_function_decl);\n-\n   if (existing)\n     return build (COMPOUND_EXPR, type, existing, stmt);\n   else"}, {"sha": "12da91c5c45f3ca371ba37b8f92012fa956574d7", "filename": "gcc/langhooks-def.h", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/084c1779088967df7cde7aef1ac91587d68ab3bb/gcc%2Flanghooks-def.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/084c1779088967df7cde7aef1ac91587d68ab3bb/gcc%2Flanghooks-def.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flanghooks-def.h?ref=084c1779088967df7cde7aef1ac91587d68ab3bb", "patch": "@@ -152,6 +152,8 @@ extern void write_global_declarations (void);\n   lhd_tree_inlining_end_inlining\n #define LANG_HOOKS_TREE_INLINING_CONVERT_PARM_FOR_INLINING \\\n   lhd_tree_inlining_convert_parm_for_inlining\n+#define LANG_HOOKS_TREE_INLINING_ESTIMATE_NUM_INSNS \\\n+  NULL\n \n #define LANG_HOOKS_TREE_INLINING_INITIALIZER { \\\n   LANG_HOOKS_TREE_INLINING_WALK_SUBTREES, \\\n@@ -165,7 +167,8 @@ extern void write_global_declarations (void);\n   LANG_HOOKS_TREE_INLINING_VAR_MOD_TYPE_P, \\\n   LANG_HOOKS_TREE_INLINING_START_INLINING, \\\n   LANG_HOOKS_TREE_INLINING_END_INLINING, \\\n-  LANG_HOOKS_TREE_INLINING_CONVERT_PARM_FOR_INLINING \\\n+  LANG_HOOKS_TREE_INLINING_CONVERT_PARM_FOR_INLINING, \\\n+  LANG_HOOKS_TREE_INLINING_ESTIMATE_NUM_INSNS \\\n } \\\n \n #define LANG_HOOKS_CALLGRAPH_LOWER_FUNCTION NULL"}, {"sha": "0ab10e05cbceded89cc41f80d9a7497b4d40faa5", "filename": "gcc/langhooks.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/084c1779088967df7cde7aef1ac91587d68ab3bb/gcc%2Flanghooks.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/084c1779088967df7cde7aef1ac91587d68ab3bb/gcc%2Flanghooks.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flanghooks.h?ref=084c1779088967df7cde7aef1ac91587d68ab3bb", "patch": "@@ -53,6 +53,7 @@ struct lang_hooks_for_tree_inlining\n   union tree_node *(*convert_parm_for_inlining) (union tree_node *,\n \t\t\t\t\t\t union tree_node *,\n \t\t\t\t\t\t union tree_node *);\n+  int (*estimate_num_insns) (union tree_node *);\n };\n \n struct lang_hooks_for_callgraph"}, {"sha": "3f1d94b6bea2d6353c37a8499721acb7c04938c7", "filename": "gcc/params.def", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/084c1779088967df7cde7aef1ac91587d68ab3bb/gcc%2Fparams.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/084c1779088967df7cde7aef1ac91587d68ab3bb/gcc%2Fparams.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fparams.def?ref=084c1779088967df7cde7aef1ac91587d68ab3bb", "patch": "@@ -39,7 +39,7 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n    of a function counted in internal gcc instructions (not in\n    real machine instructions) that is eligible for inlining\n    by the tree inliner.\n-   The default value is 300.\n+   The default value is 100.\n    Only functions marked inline (or methods defined in the class\n    definition for C++) are affected by this, unless you set the\n    -finline-functions (included in -O3) compiler option.\n@@ -51,19 +51,19 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n DEFPARAM (PARAM_MAX_INLINE_INSNS_SINGLE,\n \t  \"max-inline-insns-single\",\n \t  \"The maximum number of instructions in a single function eligible for inlining\",\n-\t  300)\n+\t  100)\n \n /* The single function inlining limit for functions that are\n    inlined by virtue of -finline-functions (-O3).\n    This limit should be chosen to be below or equal to the limit\n    that is applied to functions marked inlined (or defined in the\n    class declaration in C++) given by the \"max-inline-insns-single\"\n    parameter.\n-   The default value is 300.  */\n+   The default value is 100.  */\n DEFPARAM (PARAM_MAX_INLINE_INSNS_AUTO,\n \t  \"max-inline-insns-auto\",\n \t  \"The maximum number of instructions when automatically inlining\",\n-\t  300)\n+\t  100)\n \n /* The repeated inlining limit.  After this number of instructions \n    (in the internal gcc representation, not real machine instructions)\n@@ -74,15 +74,15 @@ DEFPARAM (PARAM_MAX_INLINE_INSNS_AUTO,\n    could otherwise become very high.\n    It is recommended to set this value to twice the value of the single\n    function limit (set by the \"max-inline-insns-single\" parameter) or\n-   higher.  The default value is 600.\n+   higher.  The default value is 200.\n    Higher values mean that more inlining is done, resulting in\n    better performance of the code, at the expense of higher \n    compile-time resource (time, memory) requirements and larger\n    binaries.  */\n DEFPARAM (PARAM_MAX_INLINE_INSNS,\n \t  \"max-inline-insns\",\n \t  \"The maximum number of instructions by repeated inlining before gcc starts to throttle inlining\",\n-\t  600)\n+\t  200)\n \n /* After the repeated inline limit has been exceeded (see\n    \"max-inline-insns\" parameter), a linear function is used to\n@@ -108,7 +108,7 @@ DEFPARAM (PARAM_MAX_INLINE_SLOPE,\n DEFPARAM (PARAM_MIN_INLINE_INSNS,\n \t  \"min-inline-insns\",\n \t  \"The number of instructions in a single functions still eligible to inlining after a lot recursive inlining\",\n-\t  130)\n+\t  10)\n \n /* For languages that (still) use the RTL inliner, we can specify\n    limits for the RTL inliner separately."}, {"sha": "3e68983fe3fa3851204ab50c772bf405f7a02e17", "filename": "gcc/tree-inline.c", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/084c1779088967df7cde7aef1ac91587d68ab3bb/gcc%2Ftree-inline.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/084c1779088967df7cde7aef1ac91587d68ab3bb/gcc%2Ftree-inline.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-inline.c?ref=084c1779088967df7cde7aef1ac91587d68ab3bb", "patch": "@@ -93,9 +93,9 @@ typedef struct inline_data\n   int in_target_cleanup_p;\n   /* A list of the functions current function has inlined.  */\n   varray_type inlined_fns;\n-  /* The approximate number of statements we have inlined in the\n+  /* The approximate number of instructions we have inlined in the\n      current call stack.  */\n-  int inlined_stmts;\n+  int inlined_insns;\n   /* We use the same mechanism to build clones that we do to perform\n      inlining.  However, there are a few places where we need to\n      distinguish between those two situations.  This flag is true if\n@@ -131,11 +131,6 @@ static tree find_alloca_call (tree);\n static tree find_builtin_longjmp_call_1 (tree *, int *, void *);\n static tree find_builtin_longjmp_call (tree);\n \n-/* The approximate number of instructions per statement.  This number\n-   need not be particularly accurate; it is used only to make\n-   decisions about when a function is too big to inline.  */\n-#define INSNS_PER_STMT (10)\n-\n /* Remap DECL during the copying of the BLOCK tree for the function.  */\n \n static tree\n@@ -939,7 +934,7 @@ static int\n inlinable_function_p (tree fn, inline_data *id, int nolimit)\n {\n   int inlinable;\n-  int currfn_insns;\n+  int currfn_insns = 0;\n   int max_inline_insns_single = MAX_INLINE_INSNS_SINGLE;\n \n   /* If we've already decided this function shouldn't be inlined,\n@@ -959,7 +954,10 @@ inlinable_function_p (tree fn, inline_data *id, int nolimit)\n     max_inline_insns_single = MAX_INLINE_INSNS_AUTO;\n \n   /* The number of instructions (estimated) of current function.  */\n-  currfn_insns = DECL_NUM_STMTS (fn) * INSNS_PER_STMT;\n+  if (!nolimit && !DECL_ESTIMATED_INSNS (fn))\n+    DECL_ESTIMATED_INSNS (fn)\n+      = (*lang_hooks.tree_inlining.estimate_num_insns) (fn);\n+  currfn_insns = DECL_ESTIMATED_INSNS (fn);\n \n   /* If we're not inlining things, then nothing is inlinable.  */\n   if (! flag_inline_trees)\n@@ -1008,8 +1006,7 @@ inlinable_function_p (tree fn, inline_data *id, int nolimit)\n   if (! (*lang_hooks.tree_inlining.disregard_inline_limits) (fn)\n       && inlinable && !nolimit)\n     {\n-      int sum_insns = (id ? id->inlined_stmts : 0) * INSNS_PER_STMT\n-\t\t     + currfn_insns;\n+      int sum_insns = (id ? id->inlined_insns : 0) + currfn_insns;\n       /* In the extreme case that we have exceeded the recursive inlining\n          limit by a huge factor (128), we just say no. Should not happen\n          in real life.  */\n@@ -1394,9 +1391,9 @@ expand_call_inline (tree *tp, int *walk_subtrees, void *data)\n   TREE_USED (*tp) = 1;\n \n   /* Our function now has more statements than it did before.  */\n-  DECL_NUM_STMTS (VARRAY_TREE (id->fns, 0)) += DECL_NUM_STMTS (fn);\n+  DECL_ESTIMATED_INSNS (VARRAY_TREE (id->fns, 0)) += DECL_ESTIMATED_INSNS (fn);\n   /* For accounting, subtract one for the saved call/ret.  */\n-  id->inlined_stmts += DECL_NUM_STMTS (fn) - 1;\n+  id->inlined_insns += DECL_ESTIMATED_INSNS (fn) - 1;\n \n   /* Update callgraph if needed.  */\n   if (id->decl && flag_unit_at_a_time)\n@@ -1412,7 +1409,7 @@ expand_call_inline (tree *tp, int *walk_subtrees, void *data)\n   /* If we've returned to the top level, clear out the record of how\n      much inlining has been done.  */\n   if (VARRAY_ACTIVE_SIZE (id->fns) == id->first_inlined_fn)\n-    id->inlined_stmts = 0;\n+    id->inlined_insns = 0;\n \n   /* Don't walk into subtrees.  We've already handled them above.  */\n   *walk_subtrees = 0;\n@@ -1452,6 +1449,9 @@ optimize_inline_calls (tree fn)\n   /* Don't allow recursion into FN.  */\n   VARRAY_TREE_INIT (id.fns, 32, \"fns\");\n   VARRAY_PUSH_TREE (id.fns, fn);\n+  if (!DECL_ESTIMATED_INSNS (fn))\n+    DECL_ESTIMATED_INSNS (fn) \n+      = (*lang_hooks.tree_inlining.estimate_num_insns) (fn);\n   /* Or any functions that aren't finished yet.  */\n   prev_fn = NULL_TREE;\n   if (current_function_decl)"}]}