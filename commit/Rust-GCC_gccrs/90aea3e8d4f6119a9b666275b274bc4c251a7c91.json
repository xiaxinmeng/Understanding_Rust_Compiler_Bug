{"sha": "90aea3e8d4f6119a9b666275b274bc4c251a7c91", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTBhZWEzZThkNGY2MTE5YTliNjY2Mjc1YjI3NGJjNGMyNTFhN2M5MQ==", "commit": {"author": {"name": "Eric Botcazou", "email": "ebotcazou@gcc.gnu.org", "date": "2020-05-12T11:14:20Z"}, "committer": {"name": "Eric Botcazou", "email": "ebotcazou@gcc.gnu.org", "date": "2020-05-12T11:15:48Z"}, "message": "Fix incorrect scalar storage order handling\n\nThis fixes an oversight in the new canonicalization code for packable\ntypes: it does not take into account the scalar storage order.\n\n\tPR ada/95035\n\t* gcc-interface/utils.c (packable_type_hasher::equal): Also compare\n\tthe scalar storage order.\n\t(hash_packable_type): Also hash the scalar storage order.\n\t(hash_pad_type): Likewise.", "tree": {"sha": "2617a3277265d8007a7c5c7a612fbcc5b5d0aff0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/2617a3277265d8007a7c5c7a612fbcc5b5d0aff0"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/90aea3e8d4f6119a9b666275b274bc4c251a7c91", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/90aea3e8d4f6119a9b666275b274bc4c251a7c91", "html_url": "https://github.com/Rust-GCC/gccrs/commit/90aea3e8d4f6119a9b666275b274bc4c251a7c91", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/90aea3e8d4f6119a9b666275b274bc4c251a7c91/comments", "author": null, "committer": null, "parents": [{"sha": "5e3c2d4b238f10e6e6db36810469483334d4bcb0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5e3c2d4b238f10e6e6db36810469483334d4bcb0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5e3c2d4b238f10e6e6db36810469483334d4bcb0"}], "stats": {"total": 23, "additions": 18, "deletions": 5}, "files": [{"sha": "3502eb83d5e2c65575bee478ad118b0cfbb31825", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/90aea3e8d4f6119a9b666275b274bc4c251a7c91/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/90aea3e8d4f6119a9b666275b274bc4c251a7c91/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=90aea3e8d4f6119a9b666275b274bc4c251a7c91", "patch": "@@ -1,3 +1,11 @@\n+2020-05-12  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\tPR ada/95035\n+\t* gcc-interface/utils.c (packable_type_hasher::equal): Also compare\n+\tthe scalar storage order.\n+\t(hash_packable_type): Also hash the scalar storage order.\n+\t(hash_pad_type): Likewise.\n+\n 2020-05-09  Eric Botcazou  <ebotcazou@adacore.com>\n \n \t* gcc-interface/*.[ch]: Update copyright year."}, {"sha": "1527be4f6d1107ba5ec8432b41b1dce4613c21c5", "filename": "gcc/ada/gcc-interface/utils.c", "status": "modified", "additions": 10, "deletions": 5, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/90aea3e8d4f6119a9b666275b274bc4c251a7c91/gcc%2Fada%2Fgcc-interface%2Futils.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/90aea3e8d4f6119a9b666275b274bc4c251a7c91/gcc%2Fada%2Fgcc-interface%2Futils.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Futils.c?ref=90aea3e8d4f6119a9b666275b274bc4c251a7c91", "patch": "@@ -1026,14 +1026,15 @@ packable_type_hasher::equal (packable_type_hash *t1, packable_type_hash *t2)\n   type1 = t1->type;\n   type2 = t2->type;\n \n-  /* We consider that packable types are equivalent if they have the same\n-     name, size, alignment and RM size.  Taking the mode into account is\n-     redundant since it is determined by the others.  */\n+  /* We consider that packable types are equivalent if they have the same name,\n+     size, alignment, RM size and storage order. Taking the mode into account\n+     is redundant since it is determined by the others.  */\n   return\n     TYPE_NAME (type1) == TYPE_NAME (type2)\n     && TYPE_SIZE (type1) == TYPE_SIZE (type2)\n     && TYPE_ALIGN (type1) == TYPE_ALIGN (type2)\n-    && TYPE_ADA_SIZE (type1) == TYPE_ADA_SIZE (type2);\n+    && TYPE_ADA_SIZE (type1) == TYPE_ADA_SIZE (type2)\n+    && TYPE_REVERSE_STORAGE_ORDER (type1) == TYPE_REVERSE_STORAGE_ORDER (type2);\n }\n \n /* Compute the hash value for the packable TYPE.  */\n@@ -1047,6 +1048,8 @@ hash_packable_type (tree type)\n   hashcode = iterative_hash_expr (TYPE_SIZE (type), hashcode);\n   hashcode = iterative_hash_hashval_t (TYPE_ALIGN (type), hashcode);\n   hashcode = iterative_hash_expr (TYPE_ADA_SIZE (type), hashcode);\n+  hashcode\n+    = iterative_hash_hashval_t (TYPE_REVERSE_STORAGE_ORDER (type), hashcode);\n \n   return hashcode;\n }\n@@ -1402,7 +1405,7 @@ pad_type_hasher::equal (pad_type_hash *t1, pad_type_hash *t2)\n   type1 = t1->type;\n   type2 = t2->type;\n \n-  /* We consider that the padded types are equivalent if they pad the same type\n+  /* We consider that padded types are equivalent if they pad the same type\n      and have the same size, alignment, RM size and storage order.  Taking the\n      mode into account is redundant since it is determined by the others.  */\n   return\n@@ -1425,6 +1428,8 @@ hash_pad_type (tree type)\n   hashcode = iterative_hash_expr (TYPE_SIZE (type), hashcode);\n   hashcode = iterative_hash_hashval_t (TYPE_ALIGN (type), hashcode);\n   hashcode = iterative_hash_expr (TYPE_ADA_SIZE (type), hashcode);\n+  hashcode\n+    = iterative_hash_hashval_t (TYPE_REVERSE_STORAGE_ORDER (type), hashcode);\n \n   return hashcode;\n }"}]}