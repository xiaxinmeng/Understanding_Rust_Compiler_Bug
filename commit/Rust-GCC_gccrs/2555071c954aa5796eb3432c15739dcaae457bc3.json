{"sha": "2555071c954aa5796eb3432c15739dcaae457bc3", "node_id": "C_kwDOANBUbNoAKDI1NTUwNzFjOTU0YWE1Nzk2ZWIzNDMyYzE1NzM5ZGNhYWU0NTdiYzM", "commit": {"author": {"name": "Jeff Law", "email": "jeffreyalaw@gmail.com", "date": "2022-10-01T04:42:15Z"}, "committer": {"name": "Jeff Law", "email": "jeffreyalaw@gmail.com", "date": "2022-10-01T04:49:55Z"}, "message": "Improve Z flag handling on H8\n\nThis patch improves handling of the Z bit in the status register in a\nvariety of ways to improve either the code size or code speed on various\nH8 subtargets.\n\nFor example, we can test the zero/nonzero status of the upper byte of a\n16 bit register using mov.b, we can move the Z or an inverted Z into a\nQImode register profitably on some subtargets.  We can move Z or an\ninverted Z into the sign bit on the H8/SX profitably, etc.\n\ngcc/\n\n\t* config/h8300/h8300.md (HSI2): New iterator.\n\t(eqne_invert): Similarly.\n\t* config/h8300/testcompare.md (testhi_upper_z): New pattern.\n\t(cmpqi_z, cmphi_z, cmpsi_z): Likewise.\n\t(store_z_qi, store_z_i_qi, store_z_hi, store_z_hi_sb): New\n\tdefine_insn_and_splits and/or define_insns.\n\t(store_z_hi_neg, store_z_hi_and, store_z_<mode>): Likewise.\n\t(store_z_<mode>_neg, store_z_<mode>_and, store_z): Likewise.", "tree": {"sha": "7727cc058c0692134cc2038dd0aa602e7e74bebe", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/7727cc058c0692134cc2038dd0aa602e7e74bebe"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2555071c954aa5796eb3432c15739dcaae457bc3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2555071c954aa5796eb3432c15739dcaae457bc3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2555071c954aa5796eb3432c15739dcaae457bc3", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2555071c954aa5796eb3432c15739dcaae457bc3/comments", "author": {"login": "JeffreyALaw", "id": 14062506, "node_id": "MDQ6VXNlcjE0MDYyNTA2", "avatar_url": "https://avatars.githubusercontent.com/u/14062506?v=4", "gravatar_id": "", "url": "https://api.github.com/users/JeffreyALaw", "html_url": "https://github.com/JeffreyALaw", "followers_url": "https://api.github.com/users/JeffreyALaw/followers", "following_url": "https://api.github.com/users/JeffreyALaw/following{/other_user}", "gists_url": "https://api.github.com/users/JeffreyALaw/gists{/gist_id}", "starred_url": "https://api.github.com/users/JeffreyALaw/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/JeffreyALaw/subscriptions", "organizations_url": "https://api.github.com/users/JeffreyALaw/orgs", "repos_url": "https://api.github.com/users/JeffreyALaw/repos", "events_url": "https://api.github.com/users/JeffreyALaw/events{/privacy}", "received_events_url": "https://api.github.com/users/JeffreyALaw/received_events", "type": "User", "site_admin": false}, "committer": {"login": "JeffreyALaw", "id": 14062506, "node_id": "MDQ6VXNlcjE0MDYyNTA2", "avatar_url": "https://avatars.githubusercontent.com/u/14062506?v=4", "gravatar_id": "", "url": "https://api.github.com/users/JeffreyALaw", "html_url": "https://github.com/JeffreyALaw", "followers_url": "https://api.github.com/users/JeffreyALaw/followers", "following_url": "https://api.github.com/users/JeffreyALaw/following{/other_user}", "gists_url": "https://api.github.com/users/JeffreyALaw/gists{/gist_id}", "starred_url": "https://api.github.com/users/JeffreyALaw/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/JeffreyALaw/subscriptions", "organizations_url": "https://api.github.com/users/JeffreyALaw/orgs", "repos_url": "https://api.github.com/users/JeffreyALaw/repos", "events_url": "https://api.github.com/users/JeffreyALaw/events{/privacy}", "received_events_url": "https://api.github.com/users/JeffreyALaw/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "dd9c8f644f0f1ac2000108ac369b991664946304", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dd9c8f644f0f1ac2000108ac369b991664946304", "html_url": "https://github.com/Rust-GCC/gccrs/commit/dd9c8f644f0f1ac2000108ac369b991664946304"}], "stats": {"total": 269, "additions": 269, "deletions": 0}, "files": [{"sha": "f592af1d5f7ccb7c9aa1c9863096db62ff959a03", "filename": "gcc/config/h8300/h8300.md", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2555071c954aa5796eb3432c15739dcaae457bc3/gcc%2Fconfig%2Fh8300%2Fh8300.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2555071c954aa5796eb3432c15739dcaae457bc3/gcc%2Fconfig%2Fh8300%2Fh8300.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fh8300%2Fh8300.md?ref=2555071c954aa5796eb3432c15739dcaae457bc3", "patch": "@@ -221,6 +221,7 @@\n (define_mode_iterator QHI [QI HI])\n \n (define_mode_iterator HSI [HI SI])\n+(define_mode_iterator HSI2 [HI SI])\n \n (define_mode_iterator QHSI [QI HI SI])\n (define_mode_iterator QHSI2 [QI HI SI])\n@@ -236,6 +237,7 @@\n (define_code_iterator ors [ior xor])\n \n (define_code_iterator eqne [eq ne])\n+(define_code_attr eqne_invert [(eq \"ne\") (ne \"eq\")])\n \n ;; For storing the C flag, map from the unsigned comparison to the right\n ;; code for testing the C bit."}, {"sha": "81dce1d0bc1feaf9f014871005f4c699a1647039", "filename": "gcc/config/h8300/testcompare.md", "status": "modified", "additions": 267, "deletions": 0, "changes": 267, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2555071c954aa5796eb3432c15739dcaae457bc3/gcc%2Fconfig%2Fh8300%2Ftestcompare.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2555071c954aa5796eb3432c15739dcaae457bc3/gcc%2Fconfig%2Fh8300%2Ftestcompare.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fh8300%2Ftestcompare.md?ref=2555071c954aa5796eb3432c15739dcaae457bc3", "patch": "@@ -61,6 +61,15 @@\n   \"mov.b\t%t0,%t0\"\n   [(set_attr \"length\" \"2\")])\n \n+(define_insn \"*tsthi_upper_z\"\n+  [(set (reg:CCZ CC_REG)\n+\t(compare (and:HI (match_operand:HI 0 \"register_operand\" \"r\")\n+\t\t\t (const_int -256))\n+\t\t (const_int 0)))]\n+  \"reload_completed\"\n+  \"mov.b\t%t0,%t0\"\n+  [(set_attr \"length\" \"2\")])\n+\n (define_insn \"*tstsi_upper\"\n   [(set (reg:CCZN CC_REG)\n \t(compare (and:SI (match_operand:SI 0 \"register_operand\" \"r\")\n@@ -86,6 +95,30 @@\n   }\n   [(set_attr \"length_table\" \"add\")])\n \n+(define_insn \"*cmpqi_z\"\n+  [(set (reg:CCZ CC_REG)\n+\t(eq (match_operand:QI 0 \"h8300_dst_operand\" \"rQ\")\n+\t    (match_operand:QI 1 \"h8300_src_operand\" \"rQi\")))]\n+  \"reload_completed\"\n+  { return \"cmp.b\t%X1,%X0\"; }\n+  [(set_attr \"length_table\" \"add\")])\n+\n+(define_insn \"*cmphi_z\"\n+  [(set (reg:CCZ CC_REG)\n+\t(eq (match_operand:HI 0 \"h8300_dst_operand\" \"rQ\")\n+\t    (match_operand:HI 1 \"h8300_src_operand\" \"rQi\")))]\n+  \"reload_completed\"\n+  { return \"cmp.w\t%T1,%T0\"; }\n+  [(set_attr \"length_table\" \"add\")])\n+\n+(define_insn \"*cmpsi_z\"\n+  [(set (reg:CCZ CC_REG)\n+\t(eq (match_operand:SI 0 \"h8300_dst_operand\" \"rQ\")\n+\t    (match_operand:SI 1 \"h8300_src_operand\" \"rQi\")))]\n+  \"reload_completed\"\n+  { return \"cmp.l\t%S1,%S0\"; }\n+  [(set_attr \"length_table\" \"add\")])\n+\n (define_insn \"*cmpqi\"\n   [(set (reg:CC CC_REG)\n \t(compare (match_operand:QI 0 \"h8300_dst_operand\" \"rQ\")\n@@ -209,6 +242,8 @@\n \t  return \"xor.l\\t%S0,%S0\\;bist\\t#0,%w0\";\n \tgcc_unreachable ();\n       }\n+    else\n+      gcc_unreachable ();\n   }\n   [(set (attr \"length\") (symbol_ref \"<MODE>mode == SImode ? 6 : 4\"))])\n \n@@ -340,3 +375,235 @@\n \t(ashift:QHSI (<geultu_to_c>:QHSI (reg:CCC CC_REG) (const_int 0))\n \t\t     (match_dup 3)))])\n \n+;; Storing Z into a QImode destination is fairly easy on the H8/S and\n+;; newer as the stc; shift; mask is just 3 insns/6 bytes.  On the H8/300H\n+;; it is 4 insns/8 bytes which is a speed improvement, but a size\n+;; regression relative to the branchy sequence\n+;;\n+;; Storing inverted Z in QImode is not profitable on the H8/300H, but\n+;; is a speed improvement on the H8S.\n+(define_insn_and_split \"*store_z_qi\"\n+  [(set (match_operand:QI 0 \"register_operand\" \"=r\")\n+\t(eq:QI (match_operand:HI 1 \"register_operand\" \"r\")\n+\t       (match_operand:HI 2 \"register_operand\" \"r\")))]\n+  \"TARGET_H8300S || !optimize_size\"\n+  \"#\"\n+  \"&& reload_completed\"\n+  [(set (reg:CCZ CC_REG)\n+\t(eq:CCZ (match_dup 1) (match_dup 2)))\n+   (set (match_dup 0)\n+\t(ne:QI (reg:CCZ CC_REG) (const_int 0)))])\n+\n+(define_insn_and_split \"*store_z_i_qi\"\n+  [(set (match_operand:QI 0 \"register_operand\" \"=r\")\n+\t(ne:QI (match_operand:HI 1 \"register_operand\" \"r\")\n+\t       (match_operand:HI 2 \"register_operand\" \"r\")))]\n+  \"TARGET_H8300S\"\n+  \"#\"\n+  \"&& reload_completed\"\n+  [(set (reg:CCZ CC_REG)\n+\t(eq:CCZ (match_dup 1) (match_dup 2)))\n+   (set (match_dup 0)\n+\t(eq:QI (reg:CCZ CC_REG) (const_int 0)))])\n+\n+(define_insn \"*store_z_qi\"\n+  [(set (match_operand:QI 0 \"register_operand\" \"=r\")\n+\t(ne:QI (reg:CCZ CC_REG) (const_int 0)))]\n+  \"(TARGET_H8300S || !optimize_size) && reload_completed\"\n+  {\n+    if (TARGET_H8300S)\n+      return \"stc\\tccr,%X0\\;shar\\t#2,%X0\\;and\\t#0x1,%X0\";\n+    else\n+      return \"stc\\tccr,%X0\\;shar\\t%X0\\;shar\\t%X0\\;and\\t#0x1,%X0\";\n+  }\n+  [(set (attr \"length\") (symbol_ref \"TARGET_H8300S ? 6 : 8\"))])\n+\n+(define_insn \"*store_z_i_qi\"\n+  [(set (match_operand:QI 0 \"register_operand\" \"=r\")\n+\t(eq:QI (reg:CCZ CC_REG) (const_int 0)))]\n+  \"(TARGET_H8300S || !optimize_size) && reload_completed\"\n+  \"stc\\tccr,%X0\\;bld\\t#2,%X0\\;xor.w\\t%T0,%T0\\;bist\\t#0,%X0\";\n+  [(set_attr \"length\" \"8\")])\n+\n+;; Storing Z or an inverted Z into a HImode destination is\n+;; profitable on the H8/S and older variants, but not on the\n+;; H8/SX where the branchy sequence can use the two-byte\n+;; mov-immediate that is specific to the H8/SX\n+(define_insn_and_split \"*store_z_hi\"\n+  [(set (match_operand:HSI 0 \"register_operand\" \"=r\")\n+\t(eqne:HSI (match_operand:HSI2 1 \"register_operand\" \"r\")\n+\t\t  (match_operand:HSI2 2 \"register_operand\" \"r\")))]\n+  \"!TARGET_H8300SX\"\n+  \"#\"\n+  \"&& reload_completed\"\n+  [(set (reg:CCZ CC_REG)\n+\t(eq:CCZ (match_dup 1) (match_dup 2)))\n+   (set (match_dup 0)\n+\t(<eqne_invert>:HSI (reg:CCZ CC_REG) (const_int 0)))])\n+\n+;; Similar, but putting the result into the sign bit\n+(define_insn_and_split \"*store_z_hi_sb\"\n+  [(set (match_operand:HSI 0 \"register_operand\" \"=r\")\n+\t(ashift:HSI (eqne:HSI (match_operand:HSI2 1 \"register_operand\" \"r\")\n+\t\t\t      (match_operand:HSI2 2 \"register_operand\" \"r\"))\n+\t\t     (const_int 15)))]\n+  \"!TARGET_H8300SX\"\n+  \"#\"\n+  \"&& reload_completed\"\n+  [(set (reg:CCZ CC_REG)\n+\t(eq:CCZ (match_dup 1) (match_dup 2)))\n+   (set (match_dup 0)\n+\t(ashift:HSI (<eqne_invert>:HSI (reg:CCZ CC_REG) (const_int 0))\n+\t\t    (const_int 15)))])\n+\n+;; Similar, but negating the result\n+(define_insn_and_split \"*store_z_hi_neg\"\n+  [(set (match_operand:HSI 0 \"register_operand\" \"=r\")\n+\t(neg:HSI (eqne:HSI (match_operand:HSI2 1 \"register_operand\" \"r\")\n+\t\t\t   (match_operand:HSI2 2 \"register_operand\" \"r\"))))]\n+  \"!TARGET_H8300SX\"\n+  \"#\"\n+  \"&& reload_completed\"\n+  [(set (reg:CCZ CC_REG)\n+\t(eq:CCZ (match_dup 1) (match_dup 2)))\n+   (set (match_dup 0)\n+\t(neg:HSI (<eqne_invert>:HSI (reg:CCZ CC_REG) (const_int 0))))])\n+\n+(define_insn_and_split \"*store_z_hi_and\"\n+  [(set (match_operand:HSI 0 \"register_operand\" \"=r\")\n+\t(and:HSI (eqne:HSI (match_operand:HSI2 1 \"register_operand\" \"r\")\n+\t\t\t   (match_operand:HSI2 2 \"register_operand\" \"r\"))\n+\t\t (match_operand:HSI 3 \"register_operand\" \"r\")))]\n+  \"!TARGET_H8300SX\"\n+  \"#\"\n+  \"&& reload_completed\"\n+  [(set (reg:CCZ CC_REG)\n+\t(eq:CCZ (match_dup 1) (match_dup 2)))\n+   (set (match_dup 0)\n+\t(and:HSI (<eqne_invert>:HSI (reg:CCZ CC_REG) (const_int 0))\n+\t\t (match_dup 3)))])\n+\n+(define_insn \"*store_z_<mode>\"\n+  [(set (match_operand:HSI 0 \"register_operand\" \"=r\")\n+\t(eqne:HSI (reg:CCZ CC_REG) (const_int 0)))]\n+  \"!TARGET_H8300SX\"\n+  {\n+    if (<MODE>mode == HImode)\n+      {\n+\tif (<CODE> == NE)\n+\t  {\n+\t    if (TARGET_H8300S)\n+\t      return \"stc\\tccr,%X0\\;shlr.b\\t#2,%X0\\;and.w\\t#1,%T0\";\n+\t    return \"stc\\tccr,%X0\\;bld\\t#2,%X0\\;xor.w\\t%T0,%T0\\;bst\\t#0,%X0\";\n+\t  }\n+\telse\n+\t  return \"stc\\tccr,%X0\\;bld\\t#2,%X0\\;xor.w\\t%T0,%T0\\;bist\\t#0,%X0\";\n+      }\n+    else if (<MODE>mode == SImode)\n+      {\n+\tif (<CODE> == NE)\n+\t  {\n+\t    if (TARGET_H8300S)\n+\t      return \"stc\\tccr,%X0\\;shlr.b\\t#2,%X0\\;and.l\\t#1,%S0\";\n+\t    return \"stc\\tccr,%X0\\;bld\\t#2,%X0\\;xor.l\\t%S0,%S0\\;bst\\t#0,%X0\";\n+\t  }\n+\telse\n+\t  return \"stc\\tccr,%X0\\;bld\\t#2,%X0\\;xor.l\\t%S0,%S0\\;bist\\t#0,%X0\";\n+      }\n+    gcc_unreachable ();\n+  }\n+;; XXXSImode is 2 bytes longer\n+  [(set_attr \"length\" \"8\")])\n+\n+(define_insn \"*store_z_<mode>_sb\"\n+  [(set (match_operand:HSI 0 \"register_operand\" \"=r\")\n+\t(ashift:HSI (eqne:HSI (reg:CCZ CC_REG) (const_int 0))\n+\t\t    (const_int 15)))]\n+  \"!TARGET_H8300SX\"\n+  {\n+    if (<MODE>mode == HImode)\n+      {\n+\tif (<CODE> == NE)\n+\t  return \"stc\\tccr,%X0\\;bld\\t#2,%X0\\;xor.w\\t%T0,%T0\\;bst\\t#7,%t0\";\n+\telse\n+\t  return \"stc\\tccr,%X0\\;bld\\t#2,%X0\\;xor.w\\t%T0,%T0\\;bist\\t#7,%t0\";\n+      }\n+    else if (<MODE>mode == SImode)\n+      {\n+\tif (<CODE> == NE)\n+\t  return \"stc\\tccr,%X0\\;bld\\t#2,%X0\\;xor.l\\t%T0,%T0\\;rotxr.l\\t%S0\";\n+\telse\n+\t  return \"stc\\tccr,%X0\\;bild\\t#2,%X0\\;xor.l\\t%T0,%T0\\;rotxr.l\\t%S0\";\n+      }\n+    gcc_unreachable ();\n+  }\n+  ;; XXX SImode is larger\n+  [(set_attr \"length\" \"8\")])\n+\n+(define_insn \"*store_z_<mode>_neg\"\n+  [(set (match_operand:HSI 0 \"register_operand\" \"=r\")\n+\t(neg:HSI (eqne:HSI (reg:CCZ CC_REG) (const_int 0))))]\n+  \"!TARGET_H8300SX\"\n+  {\n+    if (<MODE>mode == HImode)\n+      {\n+\tif (<CODE> == NE)\n+\t  return \"stc\\tccr,%X0\\;bld\\t#2,%X0\\;subx.b\\t%X0,%X0\\;exts.w\\t%T0\";\n+\telse\n+\t  return \"stc\\tccr,%X0\\;bild\\t#2,%X0\\;subx.b\\t%X0,%X0\\;exts.w\\t%T0\";\n+      }\n+    else if (<MODE>mode == SImode)\n+      {\n+\tif (<CODE> == NE)\n+\t  return \"stc\\tccr,%X0\\;bld\\t#2,%X0\\;subx.b\\t%X0,%X0\\;exts.w\\t%T0\\;exts.l\\t%S0\";\n+\telse\n+\t  return \"stc\\tccr,%X0\\;bild\\t#2,%X0\\;subx.b\\t%X0,%X0\\;exts.w\\t%T0\\;exts.l\\t%S0\";\n+      }\n+    gcc_unreachable ();\n+  }\n+  ;; XXX simode is an instruction longer\n+  [(set_attr \"length\" \"8\")])\n+\n+(define_insn \"*store_z_<mode>_and\"\n+  [(set (match_operand:HSI 0 \"register_operand\" \"=r\")\n+\t(and:HSI (eqne:HSI (reg:CCZ CC_REG) (const_int 0))\n+\t\t (match_operand:HSI 1 \"register_operand\" \"r\")))]\n+  \"!TARGET_H8300SX\"\n+  {\n+    if (<MODE>mode == HImode)\n+      {\n+\tif (<CODE> == NE)\n+\t  return \"bld\\t#0,%X1\\;stc\\tccr,%X0\\;band\\t#2,%X0\\;xor.w\\t%T0,%T0\\;bst\\t#0,%X0\";\n+\telse\n+\t  return \"bild\\t#0,%X1\\;stc\\tccr,%X0\\;band\\t#2,%X0\\;xor.w\\t%T0,%T0\\;bist\\t#0,X0\";\n+      }\n+    else if (<MODE>mode == SImode)\n+      {\n+\tif (<CODE> == NE)\n+\t  return \"bld\\t#0,%X1\\;stc\\tccr,%X0\\;band\\t#2,%X0\\;xor.l\\t%S0,%S0\\;bst\\t#0,%X0\";\n+\telse\n+\t  return \"bild\\t#0,%X1\\;stc\\tccr,%X0\\;band\\t#2,%X0\\;xor.l\\t%S0,%S0\\;bist\\t#0,X0\";\n+      }\n+    gcc_unreachable ();\n+  }\n+  ;; XXX simode is an instruction longer\n+  [(set_attr \"length\" \"8\")])\n+\n+;; We can test the upper byte of a HImode register and the upper word\n+;; of a SImode register\n+\n+;; We can test the upper byte of a HImode register and the upper word\n+;; of a SImode register\n+(define_insn_and_split \"*store_z\"\n+  [(set (match_operand:HI 0 \"register_operand\" \"=r\")\n+\t(eqne:HI (and:HI (match_operand:HI 1 \"register_operand\" \"r\")\n+\t\t\t (const_int -256))\n+\t\t (const_int 0)))]\n+  \"!TARGET_H8300SX\"\n+  \"#\"\n+  \"&& reload_completed\"\n+  [(set (reg:CCZ CC_REG)\n+\t(compare (and:HI (match_dup 1) (const_int -256))\n+\t\t (const_int 0)))\n+   (set (match_dup 0)\n+\t(<eqne_invert>:HI (reg:CCZ CC_REG) (const_int 0)))])"}]}