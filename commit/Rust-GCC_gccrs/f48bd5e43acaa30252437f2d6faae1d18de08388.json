{"sha": "f48bd5e43acaa30252437f2d6faae1d18de08388", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjQ4YmQ1ZTQzYWNhYTMwMjUyNDM3ZjJkNmZhYWUxZDE4ZGUwODM4OA==", "commit": {"author": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2018-10-05T12:54:51Z"}, "committer": {"name": "Richard Biener", "email": "rguenth@gcc.gnu.org", "date": "2018-10-05T12:54:51Z"}, "message": "re PR middle-end/63155 (memory hog)\n\n2018-10-05  Richard Biener  <rguenther@suse.de>\n\n\tPR tree-optimization/63155\n\t* tree-ssa-ccp.c (ccp_propagate::visit_phi): Avoid excess\n\tvertical space in dumpfiles.\n\t* tree-ssa-propagate.h\n\t(ssa_propagation_engine::process_ssa_edge_worklist): Remove.\n\t* tree-ssa-propagate.c (cfg_blocks_back): New global.\n\t(ssa_edge_worklist_back): Likewise.\n\t(curr_order): Likewise.\n\t(cfg_blocks_get): Remove abstraction.\n\t(cfg_blocks_add): Likewise.\n\t(cfg_blocks_empty_p): Likewise.\n\t(add_ssa_edge): Add to current or next worklist based on\n\tRPO index.\n\t(add_control_edge): Likewise.\n\t(ssa_propagation_engine::process_ssa_edge_worklist): Fold\n\tinto ...\n\t(ssa_propagation_engine::ssa_propagate): ... here.  Unify\n\titeration from CFG and SSA edge worklist so we process\n\teverything in RPO order, prioritizing forward progress\n\tover iteration.\n\t(ssa_prop_init): Allocate new worklists, do not dump\n\timmediate uses.\n\t(ssa_prop_fini): Free new worklists.\n\nFrom-SVN: r264869", "tree": {"sha": "42392c5fdf3eff60fc7e87cd88eea90da756698e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/42392c5fdf3eff60fc7e87cd88eea90da756698e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f48bd5e43acaa30252437f2d6faae1d18de08388", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f48bd5e43acaa30252437f2d6faae1d18de08388", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f48bd5e43acaa30252437f2d6faae1d18de08388", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f48bd5e43acaa30252437f2d6faae1d18de08388/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "700adeb6fd65528758f9dbcd0aaf6345e14d312c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/700adeb6fd65528758f9dbcd0aaf6345e14d312c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/700adeb6fd65528758f9dbcd0aaf6345e14d312c"}], "stats": {"total": 187, "additions": 106, "deletions": 81}, "files": [{"sha": "ad2283099a2a05a9987c16325825429f001ad94c", "filename": "gcc/ChangeLog", "status": "modified", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f48bd5e43acaa30252437f2d6faae1d18de08388/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f48bd5e43acaa30252437f2d6faae1d18de08388/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=f48bd5e43acaa30252437f2d6faae1d18de08388", "patch": "@@ -1,3 +1,29 @@\n+2018-10-05  Richard Biener  <rguenther@suse.de>\n+\n+\tPR tree-optimization/63155\n+\t* tree-ssa-ccp.c (ccp_propagate::visit_phi): Avoid excess\n+\tvertical space in dumpfiles.\n+\t* tree-ssa-propagate.h\n+\t(ssa_propagation_engine::process_ssa_edge_worklist): Remove.\n+\t* tree-ssa-propagate.c (cfg_blocks_back): New global.\n+\t(ssa_edge_worklist_back): Likewise.\n+\t(curr_order): Likewise.\n+\t(cfg_blocks_get): Remove abstraction.\n+\t(cfg_blocks_add): Likewise.\n+\t(cfg_blocks_empty_p): Likewise.\n+\t(add_ssa_edge): Add to current or next worklist based on\n+\tRPO index.\n+\t(add_control_edge): Likewise.\n+\t(ssa_propagation_engine::process_ssa_edge_worklist): Fold\n+\tinto ...\n+\t(ssa_propagation_engine::ssa_propagate): ... here.  Unify\n+\titeration from CFG and SSA edge worklist so we process\n+\teverything in RPO order, prioritizing forward progress\n+\tover iteration.\n+\t(ssa_prop_init): Allocate new worklists, do not dump\n+\timmediate uses.\n+\t(ssa_prop_fini): Free new worklists.\n+\n 2018-10-05  Richard Biener  <rguenther@suse.de>\n \n \t* tree-core.h (tree_block::abstract_flag): Remove."}, {"sha": "d8a069be5293bfcb0c330e04ab07661f4fa0b34b", "filename": "gcc/tree-ssa-ccp.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f48bd5e43acaa30252437f2d6faae1d18de08388/gcc%2Ftree-ssa-ccp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f48bd5e43acaa30252437f2d6faae1d18de08388/gcc%2Ftree-ssa-ccp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-ccp.c?ref=f48bd5e43acaa30252437f2d6faae1d18de08388", "patch": "@@ -1119,7 +1119,7 @@ ccp_propagate::visit_phi (gphi *phi)\n       if (dump_file && (dump_flags & TDF_DETAILS))\n \t{\n \t  fprintf (dump_file,\n-\t      \"\\n    Argument #%d (%d -> %d %sexecutable)\\n\",\n+\t      \"\\tArgument #%d (%d -> %d %sexecutable)\\n\",\n \t      i, e->src->index, e->dest->index,\n \t      (e->flags & EDGE_EXECUTABLE) ? \"\" : \"not \");\n \t}"}, {"sha": "4cb0fbaed15510807c04b86d1369135a43668beb", "filename": "gcc/tree-ssa-propagate.c", "status": "modified", "additions": 79, "deletions": 78, "changes": 157, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f48bd5e43acaa30252437f2d6faae1d18de08388/gcc%2Ftree-ssa-propagate.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f48bd5e43acaa30252437f2d6faae1d18de08388/gcc%2Ftree-ssa-propagate.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-propagate.c?ref=f48bd5e43acaa30252437f2d6faae1d18de08388", "patch": "@@ -108,51 +108,26 @@\n      [3] Advanced Compiler Design and Implementation,\n \t Steven Muchnick, Morgan Kaufmann, 1997, Section 12.6  */\n \n-/* Worklist of control flow edge destinations.  This contains\n+/* Worklists of control flow edge destinations.  This contains\n    the CFG order number of the blocks so we can iterate in CFG\n-   order by visiting in bit-order.  */\n+   order by visiting in bit-order.  We use two worklists to\n+   first make forward progress before iterating.  */\n static bitmap cfg_blocks;\n+static bitmap cfg_blocks_back;\n static int *bb_to_cfg_order;\n static int *cfg_order_to_bb;\n \n-/* Worklist of SSA edges which will need reexamination as their\n+/* Worklists of SSA edges which will need reexamination as their\n    definition has changed.  SSA edges are def-use edges in the SSA\n    web.  For each D-U edge, we store the target statement or PHI node\n-   UID in a bitmap.  UIDs order stmts in execution order.   */\n+   UID in a bitmap.  UIDs order stmts in execution order.  We use\n+   two worklists to first make forward progress before iterating.  */\n static bitmap ssa_edge_worklist;\n+static bitmap ssa_edge_worklist_back;\n static vec<gimple *> uid_to_stmt;\n \n-/* Return true if the block worklist empty.  */\n-\n-static inline bool\n-cfg_blocks_empty_p (void)\n-{\n-  return bitmap_empty_p (cfg_blocks);\n-}\n-\n-\n-/* Add a basic block to the worklist.  The block must not be the ENTRY\n-   or EXIT block.  */\n-\n-static void\n-cfg_blocks_add (basic_block bb)\n-{\n-  gcc_assert (bb != ENTRY_BLOCK_PTR_FOR_FN (cfun)\n-\t      && bb != EXIT_BLOCK_PTR_FOR_FN (cfun));\n-  bitmap_set_bit (cfg_blocks, bb_to_cfg_order[bb->index]);\n-}\n-\n-\n-/* Remove a block from the worklist.  */\n-\n-static basic_block\n-cfg_blocks_get (void)\n-{\n-  gcc_assert (!cfg_blocks_empty_p ());\n-  int order_index = bitmap_first_set_bit (cfg_blocks);\n-  bitmap_clear_bit (cfg_blocks, order_index);\n-  return BASIC_BLOCK_FOR_FN (cfun, cfg_order_to_bb [order_index]);\n-}\n+/* Current RPO index in the iteration.  */\n+static int curr_order;\n \n \n /* We have just defined a new value for VAR.  If IS_VARYING is true,\n@@ -182,8 +157,15 @@ add_ssa_edge (tree var)\n \t       & EDGE_EXECUTABLE))\n \tcontinue;\n \n-      if (prop_simulate_again_p (use_stmt)\n-\t  && bitmap_set_bit (ssa_edge_worklist, gimple_uid (use_stmt)))\n+      if (!prop_simulate_again_p (use_stmt))\n+\tcontinue;\n+\n+      bitmap worklist;\n+      if (bb_to_cfg_order[gimple_bb (use_stmt)->index] < curr_order)\n+\tworklist = ssa_edge_worklist_back;\n+      else\n+\tworklist = ssa_edge_worklist;\n+      if (bitmap_set_bit (worklist, gimple_uid (use_stmt)))\n \t{\n \t  uid_to_stmt[gimple_uid (use_stmt)] = use_stmt;\n \t  if (dump_file && (dump_flags & TDF_DETAILS))\n@@ -211,7 +193,11 @@ add_control_edge (edge e)\n \n   e->flags |= EDGE_EXECUTABLE;\n \n-  cfg_blocks_add (bb);\n+  int bb_order = bb_to_cfg_order[bb->index];\n+  if (bb_order < curr_order)\n+    bitmap_set_bit (cfg_blocks_back, bb_order);\n+  else\n+    bitmap_set_bit (cfg_blocks, bb_order);\n \n   if (dump_file && (dump_flags & TDF_DETAILS))\n     fprintf (dump_file, \"Adding destination of edge (%d -> %d) to worklist\\n\",\n@@ -318,33 +304,6 @@ ssa_propagation_engine::simulate_stmt (gimple *stmt)\n     }\n }\n \n-/* Process an SSA edge worklist.  WORKLIST is the SSA edge worklist to\n-   drain.  This pops statements off the given WORKLIST and processes\n-   them until one statement was simulated or there are no more statements\n-   on WORKLIST.  We take a pointer to WORKLIST because it may be reallocated\n-   when an SSA edge is added to it in simulate_stmt.  Return true if a stmt\n-   was simulated.  */\n-\n-void\n-ssa_propagation_engine::process_ssa_edge_worklist (void)\n-{\n-  /* Process the next entry from the worklist.  */\n-  unsigned stmt_uid = bitmap_first_set_bit (ssa_edge_worklist);\n-  bitmap_clear_bit (ssa_edge_worklist, stmt_uid);\n-  gimple *stmt = uid_to_stmt[stmt_uid];\n-\n-  /* We should not have stmts in not yet simulated BBs on the worklist.  */\n-  gcc_assert (gimple_bb (stmt)->flags & BB_VISITED);\n-\n-  if (dump_file && (dump_flags & TDF_DETAILS))\n-    {\n-      fprintf (dump_file, \"\\nSimulating statement: \");\n-      print_gimple_stmt (dump_file, stmt, 0, dump_flags);\n-    }\n-\n-  simulate_stmt (stmt);\n-}\n-\n \n /* Simulate the execution of BLOCK.  Evaluate the statement associated\n    with each variable reference inside the block.  */\n@@ -422,6 +381,7 @@ ssa_prop_init (void)\n \n   /* Worklists of SSA edges.  */\n   ssa_edge_worklist = BITMAP_ALLOC (NULL);\n+  ssa_edge_worklist_back = BITMAP_ALLOC (NULL);\n \n   /* Worklist of basic-blocks.  */\n   bb_to_cfg_order = XNEWVEC (int, last_basic_block_for_fn (cfun) + 1);\n@@ -431,9 +391,7 @@ ssa_prop_init (void)\n   for (int i = 0; i < n; ++i)\n     bb_to_cfg_order[cfg_order_to_bb[i]] = i;\n   cfg_blocks = BITMAP_ALLOC (NULL);\n-\n-  if (dump_file && (dump_flags & TDF_DETAILS))\n-    dump_immediate_uses (dump_file);\n+  cfg_blocks_back = BITMAP_ALLOC (NULL);\n \n   /* Initially assume that every edge in the CFG is not executable.\n      (including the edges coming out of the entry block).  Mark blocks\n@@ -479,9 +437,11 @@ static void\n ssa_prop_fini (void)\n {\n   BITMAP_FREE (cfg_blocks);\n+  BITMAP_FREE (cfg_blocks_back);\n   free (bb_to_cfg_order);\n   free (cfg_order_to_bb);\n   BITMAP_FREE (ssa_edge_worklist);\n+  BITMAP_FREE (ssa_edge_worklist_back);\n   uid_to_stmt.release ();\n }\n \n@@ -796,21 +756,62 @@ ssa_propagation_engine::ssa_propagate (void)\n {\n   ssa_prop_init ();\n \n-  /* Iterate until the worklists are empty.  */\n-  while (! cfg_blocks_empty_p ()\n-\t || ! bitmap_empty_p (ssa_edge_worklist))\n+  curr_order = 0;\n+\n+  /* Iterate until the worklists are empty.  We iterate both blocks\n+     and stmts in RPO order, using sets of two worklists to first\n+     complete the current iteration before iterating over backedges.  */\n+  while (1)\n     {\n-      /* First simulate whole blocks.  */\n-      if (! cfg_blocks_empty_p ())\n+      int next_block_order = (bitmap_empty_p (cfg_blocks)\n+\t\t\t      ? -1 : bitmap_first_set_bit (cfg_blocks));\n+      int next_stmt_uid = (bitmap_empty_p (ssa_edge_worklist)\n+\t\t\t   ? -1 : bitmap_first_set_bit (ssa_edge_worklist));\n+      if (next_block_order == -1 && next_stmt_uid == -1)\n \t{\n-\t  /* Pull the next block to simulate off the worklist.  */\n-\t  basic_block dest_block = cfg_blocks_get ();\n-\t  simulate_block (dest_block);\n+\t  if (bitmap_empty_p (cfg_blocks_back)\n+\t      && bitmap_empty_p (ssa_edge_worklist_back))\n+\t    break;\n+\n+\t  if (dump_file && (dump_flags & TDF_DETAILS))\n+\t    fprintf (dump_file, \"Regular worklists empty, now processing \"\n+\t\t     \"backedge destinations\\n\");\n+\t  std::swap (cfg_blocks, cfg_blocks_back);\n+\t  std::swap (ssa_edge_worklist, ssa_edge_worklist_back);\n \t  continue;\n \t}\n \n-      /* Then simulate from the SSA edge worklist.  */\n-      process_ssa_edge_worklist ();\n+      int next_stmt_bb_order = -1;\n+      gimple *next_stmt = NULL;\n+      if (next_stmt_uid != -1)\n+\t{\n+\t  next_stmt = uid_to_stmt[next_stmt_uid];\n+\t  next_stmt_bb_order = bb_to_cfg_order[gimple_bb (next_stmt)->index];\n+\t}\n+\n+      /* Pull the next block to simulate off the worklist if it comes first.  */\n+      if (next_block_order != -1\n+\t  && (next_stmt_bb_order == -1\n+\t      || next_block_order <= next_stmt_bb_order))\n+\t{\n+\t  curr_order = next_block_order;\n+\t  bitmap_clear_bit (cfg_blocks, next_block_order);\n+\t  basic_block bb\n+\t    = BASIC_BLOCK_FOR_FN (cfun, cfg_order_to_bb [next_block_order]);\n+\t  simulate_block (bb);\n+\t}\n+      /* Else simulate from the SSA edge worklist.  */\n+      else\n+\t{\n+\t  curr_order = next_stmt_bb_order;\n+\t  bitmap_clear_bit (ssa_edge_worklist, next_stmt_uid);\n+\t  if (dump_file && (dump_flags & TDF_DETAILS))\n+\t    {\n+\t      fprintf (dump_file, \"\\nSimulating statement: \");\n+\t      print_gimple_stmt (dump_file, next_stmt, 0, dump_flags);\n+\t    }\n+\t  simulate_stmt (next_stmt);\n+\t}\n     }\n \n   ssa_prop_fini ();"}, {"sha": "56e1b1c13794b51543c8a7a1cc113471fb4de82a", "filename": "gcc/tree-ssa-propagate.h", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f48bd5e43acaa30252437f2d6faae1d18de08388/gcc%2Ftree-ssa-propagate.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f48bd5e43acaa30252437f2d6faae1d18de08388/gcc%2Ftree-ssa-propagate.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-propagate.h?ref=f48bd5e43acaa30252437f2d6faae1d18de08388", "patch": "@@ -94,9 +94,7 @@ class ssa_propagation_engine\n  private:\n   /* Internal implementation details.  */\n   void simulate_stmt (gimple *stmt);\n-  void process_ssa_edge_worklist (void);\n   void simulate_block (basic_block);\n-\n };\n \n class substitute_and_fold_engine"}]}