{"sha": "1d1b732865a2dd3a97b8a8e605d7c5906ab0df0e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MWQxYjczMjg2NWEyZGQzYTk3YjhhOGU2MDVkN2M1OTA2YWIwZGYwZQ==", "commit": {"author": {"name": "Jonathan Wakely", "email": "jwakely@redhat.com", "date": "2018-08-07T16:10:29Z"}, "committer": {"name": "Jonathan Wakely", "email": "redi@gcc.gnu.org", "date": "2018-08-07T16:10:29Z"}, "message": "PR libstdc++/86861 Meet precondition for Solaris memalign\n\nSolaris memalign requires alignment to be at least sizeof(int), so\nincrease it as needed.\n\nAlso move the check for valid alignments from the fallback\nimplementation of aligned_alloc into operator new, as it's required for\nall of aligned_alloc, memalign, posix_memalign and __aligned_malloc.\nThis adds a branch to check for undefined behaviour which we could just\nignore, so the check could just be removed. It should certainly be\nremoved if PR 86878 is implemented to issue a warning about calls with\ninvalid alignments.\n\n\tPR libstdc++/86861\n\t* libsupc++/new_opa.cc [_GLIBCXX_HAVE_MEMALIGN] (aligned_alloc):\n\tReplace macro with inline function.\n\t[__sun]: Increase alignment to meet memalign precondition.\n\t[!HAVE__ALIGNED_MALLOC && !HAVE_POSIX_MEMALIGN && !HAVE_MEMALIGN]\n\t(aligned_alloc): Move check for valid alignment to operator new.\n\tRemove redundant check for non-zero size, it's enforced by the caller.\n\t(operator new): Move check for valid alignment here. Use\n\t__builtin_expect on check for zero size.\n\nFrom-SVN: r263360", "tree": {"sha": "2eca860ce69658e282f224ed7764199fd83d39ba", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/2eca860ce69658e282f224ed7764199fd83d39ba"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/1d1b732865a2dd3a97b8a8e605d7c5906ab0df0e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1d1b732865a2dd3a97b8a8e605d7c5906ab0df0e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1d1b732865a2dd3a97b8a8e605d7c5906ab0df0e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1d1b732865a2dd3a97b8a8e605d7c5906ab0df0e/comments", "author": {"login": "jwakely", "id": 1254480, "node_id": "MDQ6VXNlcjEyNTQ0ODA=", "avatar_url": "https://avatars.githubusercontent.com/u/1254480?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jwakely", "html_url": "https://github.com/jwakely", "followers_url": "https://api.github.com/users/jwakely/followers", "following_url": "https://api.github.com/users/jwakely/following{/other_user}", "gists_url": "https://api.github.com/users/jwakely/gists{/gist_id}", "starred_url": "https://api.github.com/users/jwakely/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jwakely/subscriptions", "organizations_url": "https://api.github.com/users/jwakely/orgs", "repos_url": "https://api.github.com/users/jwakely/repos", "events_url": "https://api.github.com/users/jwakely/events{/privacy}", "received_events_url": "https://api.github.com/users/jwakely/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jwakely", "id": 1254480, "node_id": "MDQ6VXNlcjEyNTQ0ODA=", "avatar_url": "https://avatars.githubusercontent.com/u/1254480?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jwakely", "html_url": "https://github.com/jwakely", "followers_url": "https://api.github.com/users/jwakely/followers", "following_url": "https://api.github.com/users/jwakely/following{/other_user}", "gists_url": "https://api.github.com/users/jwakely/gists{/gist_id}", "starred_url": "https://api.github.com/users/jwakely/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jwakely/subscriptions", "organizations_url": "https://api.github.com/users/jwakely/orgs", "repos_url": "https://api.github.com/users/jwakely/repos", "events_url": "https://api.github.com/users/jwakely/events{/privacy}", "received_events_url": "https://api.github.com/users/jwakely/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e81c3c1e9cc642160749ad7a0577e1d18698438e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e81c3c1e9cc642160749ad7a0577e1d18698438e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e81c3c1e9cc642160749ad7a0577e1d18698438e"}], "stats": {"total": 38, "additions": 29, "deletions": 9}, "files": [{"sha": "ce410ed2e0df95adc083d03703d0fad5beec0a38", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1d1b732865a2dd3a97b8a8e605d7c5906ab0df0e/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1d1b732865a2dd3a97b8a8e605d7c5906ab0df0e/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=1d1b732865a2dd3a97b8a8e605d7c5906ab0df0e", "patch": "@@ -1,5 +1,15 @@\n 2018-08-07  Jonathan Wakely  <jwakely@redhat.com>\n \n+\tPR libstdc++/86861\n+\t* libsupc++/new_opa.cc [_GLIBCXX_HAVE_MEMALIGN] (aligned_alloc):\n+\tReplace macro with inline function.\n+\t[__sun]: Increase alignment to meet memalign precondition.\n+\t[!HAVE__ALIGNED_MALLOC && !HAVE_POSIX_MEMALIGN && !HAVE_MEMALIGN]\n+\t(aligned_alloc): Move check for valid alignment to operator new.\n+\tRemove redundant check for non-zero size, it's enforced by the caller.\n+\t(operator new): Move check for valid alignment here. Use\n+\t__builtin_expect on check for zero size.\n+\n \t* config/abi/pre/gnu.ver: Export monotonic_buffer_resource members.\n \t* include/std/memory_resource (monotonic_buffer_resource::release):\n \tCall _M_release_buffers to free buffers."}, {"sha": "5be0cc2ca6516d86f19e25f40575f2a9245adebc", "filename": "libstdc++-v3/libsupc++/new_opa.cc", "status": "modified", "additions": 19, "deletions": 9, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1d1b732865a2dd3a97b8a8e605d7c5906ab0df0e/libstdc%2B%2B-v3%2Flibsupc%2B%2B%2Fnew_opa.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1d1b732865a2dd3a97b8a8e605d7c5906ab0df0e/libstdc%2B%2B-v3%2Flibsupc%2B%2B%2Fnew_opa.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Flibsupc%2B%2B%2Fnew_opa.cc?ref=1d1b732865a2dd3a97b8a8e605d7c5906ab0df0e", "patch": "@@ -39,6 +39,7 @@ static inline void*\n aligned_alloc (std::size_t al, std::size_t sz)\n {\n   void *ptr;\n+  // posix_memalign has additional requirement, not present on aligned_alloc:\n   // The value of alignment shall be a power of two multiple of sizeof(void *).\n   if (al < sizeof(void*))\n     al = sizeof(void*);\n@@ -53,20 +54,24 @@ aligned_alloc (std::size_t al, std::size_t sz)\n #else\n extern \"C\" void *memalign(std::size_t boundary, std::size_t size);\n #endif\n-#define aligned_alloc memalign\n-#else\n+static inline void*\n+aligned_alloc (std::size_t al, std::size_t sz)\n+{\n+#ifdef __sun\n+  // Solaris 10 memalign requires that alignment is greater than or equal to\n+  // the size of a word.\n+  if (al < sizeof(int))\n+    al = sizeof(int);\n+#endif\n+  return memalign (al, sz);\n+}\n+#else // !HAVE__ALIGNED_MALLOC && !HAVE_POSIX_MEMALIGN && !HAVE_MEMALIGN\n #include <stdint.h>\n // The C library doesn't provide any aligned allocation functions, define one.\n // This is a modified version of code from gcc/config/i386/gmm_malloc.h\n static inline void*\n aligned_alloc (std::size_t al, std::size_t sz)\n {\n-  // Alignment must be a power of two.\n-  if (al & (al - 1))\n-    return nullptr;\n-  else if (!sz)\n-    return nullptr;\n-\n   // We need extra bytes to store the original value returned by malloc.\n   if (al < sizeof(void*))\n     al = sizeof(void*);\n@@ -90,8 +95,13 @@ operator new (std::size_t sz, std::align_val_t al)\n   void *p;\n   std::size_t align = (std::size_t)al;\n \n+  /* Alignment must be a power of two.  */\n+  /* XXX This should be checked by the compiler (PR 86878).  */\n+  if (__builtin_expect (align & (align - 1), false))\n+    _GLIBCXX_THROW_OR_ABORT(bad_alloc());\n+\n   /* malloc (0) is unpredictable; avoid it.  */\n-  if (sz == 0)\n+  if (__builtin_expect (sz == 0, false))\n     sz = 1;\n \n #if _GLIBCXX_HAVE_ALIGNED_ALLOC"}]}