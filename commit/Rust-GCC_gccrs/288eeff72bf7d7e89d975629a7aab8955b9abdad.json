{"sha": "288eeff72bf7d7e89d975629a7aab8955b9abdad", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Mjg4ZWVmZjcyYmY3ZDdlODlkOTc1NjI5YTdhYWI4OTU1YjlhYmRhZA==", "commit": {"author": {"name": "Jan Hubicka", "email": "hubicka@ucw.cz", "date": "2014-06-28T23:40:46Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2014-06-28T23:40:46Z"}, "message": "tree-streamer-out.c (pack_ts_type_common_value_fields): Stream if type is complete.\n\n\t* tree-streamer-out.c (pack_ts_type_common_value_fields): Stream if type\n\tis complete.\n\t(write_ts_type_common_tree_pointers): Do not stream fields not set for incomplete\n\ttypes; do not stream duplicated fields for variants; sanity check that variant\n\tand type match.\n\t(write_ts_type_non_common_tree_pointers): Likewise.\n\t* tree-streamer-in.c (unpack_ts_type_common_value_fields): Mark in TYPE_SIZE whether\n\ttype is complete.\n\t(lto_input_ts_type_common_tree_pointers): Do same changes as in\n\twrite_ts_type_common_tree_pointers\n\t(lto_input_ts_type_non_common_tree_pointers): Likewise.\n\n\t* lto.c (lto_copy_fields_not_streamed): New function.\n\t(compare_tree_sccs_1): Do not compare fields shared in between type\n\tand variant.\n\t(lto_read_decls): Fixup types first before inserting into hash.\n\nFrom-SVN: r212114", "tree": {"sha": "f3c4a53238ef28b739928c59842c9abb54cb0f82", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f3c4a53238ef28b739928c59842c9abb54cb0f82"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/288eeff72bf7d7e89d975629a7aab8955b9abdad", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/288eeff72bf7d7e89d975629a7aab8955b9abdad", "html_url": "https://github.com/Rust-GCC/gccrs/commit/288eeff72bf7d7e89d975629a7aab8955b9abdad", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/288eeff72bf7d7e89d975629a7aab8955b9abdad/comments", "author": null, "committer": null, "parents": [{"sha": "d0bd8245b26cd1e6e6540e5f0697c96703707c02", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d0bd8245b26cd1e6e6540e5f0697c96703707c02", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d0bd8245b26cd1e6e6540e5f0697c96703707c02"}], "stats": {"total": 338, "additions": 281, "deletions": 57}, "files": [{"sha": "34e7c931333b0de9b7e1304504932fc8b97b8ef7", "filename": "gcc/ChangeLog", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/288eeff72bf7d7e89d975629a7aab8955b9abdad/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/288eeff72bf7d7e89d975629a7aab8955b9abdad/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=288eeff72bf7d7e89d975629a7aab8955b9abdad", "patch": "@@ -1,3 +1,17 @@\n+2014-06-28  Jan Hubicka  <hubicka@ucw.cz>\n+\n+\t* tree-streamer-out.c (pack_ts_type_common_value_fields): Stream if type\n+\tis complete.\n+\t(write_ts_type_common_tree_pointers): Do not stream fields not set for incomplete\n+\ttypes; do not stream duplicated fields for variants; sanity check that variant\n+\tand type match.\n+\t(write_ts_type_non_common_tree_pointers): Likewise.\n+\t* tree-streamer-in.c (unpack_ts_type_common_value_fields): Mark in TYPE_SIZE whether\n+\ttype is complete.\n+\t(lto_input_ts_type_common_tree_pointers): Do same changes as in\n+\twrite_ts_type_common_tree_pointers\n+\t(lto_input_ts_type_non_common_tree_pointers): Likewise.\n+\n 2014-06-28  Jan Hubicka  <hubicka@ucw.cz>\n \n \t* cgraph.c (dump_cgraph_node): Dump init&fini priorities."}, {"sha": "63ebdebc877fb206564234e911201762176acba4", "filename": "gcc/lto/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/288eeff72bf7d7e89d975629a7aab8955b9abdad/gcc%2Flto%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/288eeff72bf7d7e89d975629a7aab8955b9abdad/gcc%2Flto%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto%2FChangeLog?ref=288eeff72bf7d7e89d975629a7aab8955b9abdad", "patch": "@@ -1,3 +1,10 @@\n+2014-06-28  Jan Hubicka  <hubicka@ucw.cz>\n+\n+\t* lto.c (lto_copy_fields_not_streamed): New function.\n+\t(compare_tree_sccs_1): Do not compare fields shared in between type\n+\tand variant.\n+\t(lto_read_decls): Fixup types first before inserting into hash.\n+\n 2014-06-25  Martin Liska  <mliska@suse.cz>\n \n \t* lto/lto-partition.c (add_references_to_partition): New IPA REF function"}, {"sha": "701447c680272a5f688a00bb10bd4df08aff0c13", "filename": "gcc/lto/lto.c", "status": "modified", "additions": 93, "deletions": 17, "changes": 110, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/288eeff72bf7d7e89d975629a7aab8955b9abdad/gcc%2Flto%2Flto.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/288eeff72bf7d7e89d975629a7aab8955b9abdad/gcc%2Flto%2Flto.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto%2Flto.c?ref=288eeff72bf7d7e89d975629a7aab8955b9abdad", "patch": "@@ -1050,6 +1050,57 @@ lto_register_function_decl_in_symtab (struct data_in *data_in, tree decl,\n \t\t\t decl, get_resolution (data_in, ix));\n }\n \n+/* Copy fields that are not streamed but copied from other nodes.  */\n+static void\n+lto_copy_fields_not_streamed (tree t)\n+{\n+  if (TYPE_P (t) && TYPE_MAIN_VARIANT (t) != t)\n+    {\n+      tree mv = TYPE_MAIN_VARIANT (t);\n+\n+      if (COMPLETE_TYPE_P (t))\n+\t{\n+\t  TYPE_SIZE (t) = TYPE_SIZE (mv);\n+\t  TYPE_SIZE_UNIT (t) = TYPE_SIZE_UNIT (mv);\n+\t}\n+      TYPE_ATTRIBUTES (t) = TYPE_ATTRIBUTES (mv);\n+\n+      if (CODE_CONTAINS_STRUCT (TREE_CODE (t), TS_TYPE_NON_COMMON))\n+\t{\n+\t  if (TREE_CODE (t) == ENUMERAL_TYPE && COMPLETE_TYPE_P (t))\n+\t    TYPE_VALUES (t) = TYPE_VALUES (mv);\n+\t  else if (TREE_CODE (t) == ARRAY_TYPE)\n+\t    TYPE_DOMAIN (t) = TYPE_DOMAIN (mv);\n+\n+          if (RECORD_OR_UNION_TYPE_P (t) && COMPLETE_TYPE_P (t))\n+\t    TYPE_VFIELD (t) = TYPE_VFIELD (mv);\n+\t  else if ((TREE_CODE (t) == ENUMERAL_TYPE && COMPLETE_TYPE_P (t))\n+\t\t   || TREE_CODE (t) == INTEGER_TYPE\n+\t\t   || TREE_CODE (t) == BOOLEAN_TYPE\n+\t\t   || TREE_CODE (t) == REAL_TYPE\n+\t\t   || TREE_CODE (t) == FIXED_POINT_TYPE)\n+\t    TYPE_MIN_VALUE (t) = TYPE_MIN_VALUE (mv);\n+\n+\t  if (TREE_CODE (t) == METHOD_TYPE)\n+\t    TYPE_METHOD_BASETYPE (t) = TYPE_METHOD_BASETYPE (mv);\n+\t  else if (RECORD_OR_UNION_TYPE_P (t) && COMPLETE_TYPE_P (t))\n+\t    TYPE_METHODS (t) = TYPE_METHODS (mv);\n+\t  else if (TREE_CODE (t) == OFFSET_TYPE)\n+\t    TYPE_OFFSET_BASETYPE (t) = TYPE_OFFSET_BASETYPE (mv);\n+\t  else if (TREE_CODE (t) == ARRAY_TYPE)\n+\t    TYPE_ARRAY_MAX_SIZE (t) = TYPE_ARRAY_MAX_SIZE (mv);\n+\t  else if ((TREE_CODE (t) == ENUMERAL_TYPE && COMPLETE_TYPE_P (t))\n+\t\t   || TREE_CODE (t) == INTEGER_TYPE\n+\t\t   || TREE_CODE (t) == BOOLEAN_TYPE\n+\t\t   || TREE_CODE (t) == REAL_TYPE\n+\t\t   || TREE_CODE (t) == FIXED_POINT_TYPE)\n+\t    TYPE_MAX_VALUE (t) = TYPE_MAX_VALUE (mv);\n+\n+\t  if (RECORD_OR_UNION_TYPE_P (t) && COMPLETE_TYPE_P (t))\n+\t    TYPE_BINFO (t) = TYPE_BINFO (mv);\n+\t}\n+    }\n+}\n \n /* For the type T re-materialize it in the type variant list and\n    the pointer/reference-to chains.  */\n@@ -1546,15 +1597,28 @@ compare_tree_sccs_1 (tree t1, tree t2, tree **map)\n \n   if (CODE_CONTAINS_STRUCT (code, TS_TYPE_COMMON))\n     {\n-      compare_tree_edges (TYPE_SIZE (t1), TYPE_SIZE (t2));\n-      compare_tree_edges (TYPE_SIZE_UNIT (t1), TYPE_SIZE_UNIT (t2));\n-      compare_tree_edges (TYPE_ATTRIBUTES (t1), TYPE_ATTRIBUTES (t2));\n-      compare_tree_edges (TYPE_NAME (t1), TYPE_NAME (t2));\n+      /* See if type is the main variant.  */\n+      if (TYPE_MAIN_VARIANT (t1) == t1)\n+\t{\n+\t  /* Main variant can match only another main variant.  */\n+\t  if (TYPE_MAIN_VARIANT (t2) != t2)\n+\t    return false;\n+\n+\t  compare_tree_edges (TYPE_SIZE (t1), TYPE_SIZE (t2));\n+\t  compare_tree_edges (TYPE_SIZE_UNIT (t1), TYPE_SIZE_UNIT (t2));\n+\t  compare_tree_edges (TYPE_ATTRIBUTES (t1), TYPE_ATTRIBUTES (t2));\n+\t}\n+      else\n+\t/* Compare main variant pointers, but do not compare fields that are\n+\t   shared in between type and the main variant since those are not\n+\t   streamed and not copied yet.  */\n+        compare_tree_edges (TYPE_MAIN_VARIANT (t1), TYPE_MAIN_VARIANT (t2));\n+\n       /* Do not compare TYPE_POINTER_TO or TYPE_REFERENCE_TO.  They will be\n \t reconstructed during fixup.  */\n       /* Do not compare TYPE_NEXT_VARIANT, we reconstruct the variant lists\n \t during fixup.  */\n-      compare_tree_edges (TYPE_MAIN_VARIANT (t1), TYPE_MAIN_VARIANT (t2));\n+      compare_tree_edges (TYPE_NAME (t1), TYPE_NAME (t2));\n       /* ???  Global types from different TUs have non-matching\n \t TRANSLATION_UNIT_DECLs.  Still merge them if they are otherwise\n \t equal.  */\n@@ -1569,25 +1633,31 @@ compare_tree_sccs_1 (tree t1, tree t2, tree **map)\n \n   if (CODE_CONTAINS_STRUCT (code, TS_TYPE_NON_COMMON))\n     {\n-      if (code == ENUMERAL_TYPE)\n-\tcompare_tree_edges (TYPE_VALUES (t1), TYPE_VALUES (t2));\n-      else if (code == ARRAY_TYPE)\n-\tcompare_tree_edges (TYPE_DOMAIN (t1), TYPE_DOMAIN (t2));\n-      else if (RECORD_OR_UNION_TYPE_P (t1))\n+      if (TYPE_MAIN_VARIANT (t1) == t1)\n+\t{\n+\t  if (code == ENUMERAL_TYPE)\n+\t    compare_tree_edges (TYPE_VALUES (t1), TYPE_VALUES (t2));\n+\t  else if (code == ARRAY_TYPE)\n+\t    compare_tree_edges (TYPE_DOMAIN (t1), TYPE_DOMAIN (t2));\n+\t  else if (RECORD_OR_UNION_TYPE_P (t1))\n+\t    compare_tree_edges (TYPE_BINFO (t1), TYPE_BINFO (t2));\n+\t  if (!POINTER_TYPE_P (t1))\n+\t    compare_tree_edges (TYPE_MINVAL (t1), TYPE_MINVAL (t2));\n+\t  compare_tree_edges (TYPE_MAXVAL (t1), TYPE_MAXVAL (t2));\n+\t}\n+      if (RECORD_OR_UNION_TYPE_P (t1)\n+\t  && TYPE_FIELDS (t1) != TYPE_FIELDS (t2))\n \t{\n \t  tree f1, f2;\n+\n \t  for (f1 = TYPE_FIELDS (t1), f2 = TYPE_FIELDS (t2);\n \t       f1 || f2;\n \t       f1 = TREE_CHAIN (f1), f2 = TREE_CHAIN (f2))\n \t    compare_tree_edges (f1, f2);\n-\t  compare_tree_edges (TYPE_BINFO (t1), TYPE_BINFO (t2));\n \t}\n-      else if (code == FUNCTION_TYPE\n-\t       || code == METHOD_TYPE)\n+      if (code == FUNCTION_TYPE\n+\t  || code == METHOD_TYPE)\n \tcompare_tree_edges (TYPE_ARG_TYPES (t1), TYPE_ARG_TYPES (t2));\n-      if (!POINTER_TYPE_P (t1))\n-\tcompare_tree_edges (TYPE_MINVAL (t1), TYPE_MINVAL (t2));\n-      compare_tree_edges (TYPE_MAXVAL (t1), TYPE_MAXVAL (t2));\n     }\n \n   if (CODE_CONTAINS_STRUCT (code, TS_LIST))\n@@ -1888,13 +1958,19 @@ lto_read_decls (struct lto_file_decl_data *decl_data, const void *data,\n \t\t  || streamer_handle_as_builtin_p (first)))\n \t    continue;\n \n+\t  /* Copy fileds we do not stream before unification so we can compare them\n+\t     without being worried if they are already initialized.  */\n+\t  for (unsigned i = 0; i < len; ++i)\n+\t    lto_copy_fields_not_streamed\n+\t       (streamer_tree_cache_get_tree (data_in->reader_cache, from + i));\n+\n \t  /* Try to unify the SCC with already existing ones.  */\n \t  if (!flag_ltrans\n \t      && unify_scc (data_in->reader_cache, from,\n \t\t\t    len, scc_entry_len, scc_hash))\n \t    continue;\n \n-\t  /* Do remaining fixup tasks for prevailing nodes.  */\n+\t  /* /* Do remaining fixup tasks for prevailing nodes.  */\n \t  bool seen_type = false;\n \t  for (unsigned i = 0; i < len; ++i)\n \t    {"}, {"sha": "93d30605ea79e95a43a4604f4423d8aa9b9be3d6", "filename": "gcc/tree-streamer-in.c", "status": "modified", "additions": 62, "deletions": 18, "changes": 80, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/288eeff72bf7d7e89d975629a7aab8955b9abdad/gcc%2Ftree-streamer-in.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/288eeff72bf7d7e89d975629a7aab8955b9abdad/gcc%2Ftree-streamer-in.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-streamer-in.c?ref=288eeff72bf7d7e89d975629a7aab8955b9abdad", "patch": "@@ -357,6 +357,13 @@ unpack_ts_type_common_value_fields (struct bitpack_d *bp, tree expr)\n   TYPE_RESTRICT (expr) = (unsigned) bp_unpack_value (bp, 1);\n   TYPE_USER_ALIGN (expr) = (unsigned) bp_unpack_value (bp, 1);\n   TYPE_READONLY (expr) = (unsigned) bp_unpack_value (bp, 1);\n+  /* This bit represent if type is complete, or if the TYPE_SIZE\n+     is non-NULL.  Mark this fact into TYPE_SIZE. The actual values\n+     will be filled in later.  */\n+  if ((unsigned) bp_unpack_value (bp, 1))\n+    TYPE_SIZE (expr) = error_mark_node;\n+  else\n+    TYPE_SIZE (expr) = NULL_TREE;\n   TYPE_PRECISION (expr) = bp_unpack_var_len_unsigned (bp);\n   TYPE_ALIGN (expr) = bp_unpack_var_len_unsigned (bp);\n   TYPE_ALIAS_SET (expr) = bp_unpack_var_len_int (bp);\n@@ -794,19 +801,29 @@ static void\n lto_input_ts_type_common_tree_pointers (struct lto_input_block *ib,\n \t\t\t\t\tstruct data_in *data_in, tree expr)\n {\n-  TYPE_SIZE (expr) = stream_read_tree (ib, data_in);\n-  TYPE_SIZE_UNIT (expr) = stream_read_tree (ib, data_in);\n-  TYPE_ATTRIBUTES (expr) = stream_read_tree (ib, data_in);\n+  TYPE_MAIN_VARIANT (expr) = stream_read_tree (ib, data_in);\n+\n+  /* Variants share most the properties with the main variant.  */\n+  if (TYPE_MAIN_VARIANT (expr) == expr)\n+    {\n+      if (COMPLETE_TYPE_P (expr))\n+\t{\n+\t  TYPE_SIZE (expr) = stream_read_tree (ib, data_in);\n+\t  TYPE_SIZE_UNIT (expr) = stream_read_tree (ib, data_in);\n+\t}\n+      TYPE_ATTRIBUTES (expr) = stream_read_tree (ib, data_in);\n+    }\n+  /* The fileds not streamed will be copied by\n+     lto_copy_fields_not_streamed.  */\n   TYPE_NAME (expr) = stream_read_tree (ib, data_in);\n+  TYPE_CONTEXT (expr) = stream_read_tree (ib, data_in);\n+  TYPE_STUB_DECL (expr) = stream_read_tree (ib, data_in);\n   /* Do not stream TYPE_POINTER_TO or TYPE_REFERENCE_TO.  They will be\n      reconstructed during fixup.  */\n   /* Do not stream TYPE_NEXT_VARIANT, we reconstruct the variant lists\n      during fixup.  */\n-  TYPE_MAIN_VARIANT (expr) = stream_read_tree (ib, data_in);\n-  TYPE_CONTEXT (expr) = stream_read_tree (ib, data_in);\n   /* TYPE_CANONICAL gets re-computed during type merging.  */\n   TYPE_CANONICAL (expr) = NULL_TREE;\n-  TYPE_STUB_DECL (expr) = stream_read_tree (ib, data_in);\n }\n \n /* Read all pointer fields in the TS_TYPE_NON_COMMON structure of EXPR\n@@ -818,21 +835,48 @@ lto_input_ts_type_non_common_tree_pointers (struct lto_input_block *ib,\n \t\t\t\t\t    struct data_in *data_in,\n \t\t\t\t\t    tree expr)\n {\n-  if (TREE_CODE (expr) == ENUMERAL_TYPE)\n-    TYPE_VALUES (expr) = stream_read_tree (ib, data_in);\n-  else if (TREE_CODE (expr) == ARRAY_TYPE)\n-    TYPE_DOMAIN (expr) = stream_read_tree (ib, data_in);\n-  else if (RECORD_OR_UNION_TYPE_P (expr))\n+  if (TYPE_MAIN_VARIANT (expr) == expr)\n+    {\n+      if (TREE_CODE (expr) == ENUMERAL_TYPE && COMPLETE_TYPE_P (expr))\n+\tTYPE_VALUES (expr) = stream_read_tree (ib, data_in);\n+      else if (TREE_CODE (expr) == ARRAY_TYPE)\n+\tTYPE_DOMAIN (expr) = stream_read_tree (ib, data_in);\n+\n+      /* TYPE_NEXT_PTR_TO and TYPE_NEXT_REF_TO is recomputed.  */\n+      if (RECORD_OR_UNION_TYPE_P (expr) && COMPLETE_TYPE_P (expr))\n+\tTYPE_VFIELD (expr) = stream_read_tree (ib, data_in);\n+      else if ((TREE_CODE (expr) == ENUMERAL_TYPE && COMPLETE_TYPE_P (expr))\n+\t       || TREE_CODE (expr) == INTEGER_TYPE\n+\t       || TREE_CODE (expr) == BOOLEAN_TYPE\n+\t       || TREE_CODE (expr) == REAL_TYPE\n+\t       || TREE_CODE (expr) == FIXED_POINT_TYPE)\n+\tTYPE_MIN_VALUE (expr) = stream_read_tree (ib, data_in);\n+\n+      if (TREE_CODE (expr) == METHOD_TYPE)\n+\tTYPE_METHOD_BASETYPE (expr) = stream_read_tree (ib, data_in);\n+      else if (RECORD_OR_UNION_TYPE_P (expr) && COMPLETE_TYPE_P (expr))\n+\tTYPE_METHODS (expr) = stream_read_tree (ib, data_in);\n+      else if (TREE_CODE (expr) == OFFSET_TYPE)\n+\tTYPE_OFFSET_BASETYPE (expr) = stream_read_tree (ib, data_in);\n+      else if (TREE_CODE (expr) == ARRAY_TYPE)\n+\tTYPE_ARRAY_MAX_SIZE (expr) = stream_read_tree (ib, data_in);\n+      else if ((TREE_CODE (expr) == ENUMERAL_TYPE && COMPLETE_TYPE_P (expr))\n+\t       || TREE_CODE (expr) == INTEGER_TYPE\n+\t       || TREE_CODE (expr) == BOOLEAN_TYPE\n+\t       || TREE_CODE (expr) == REAL_TYPE\n+\t       || TREE_CODE (expr) == FIXED_POINT_TYPE)\n+\tTYPE_MAX_VALUE (expr) = stream_read_tree (ib, data_in);\n+\n+      if (RECORD_OR_UNION_TYPE_P (expr) && COMPLETE_TYPE_P (expr))\n+\tTYPE_BINFO (expr) = stream_read_tree (ib, data_in);\n+    }\n+  /* The fileds not streamed will be copied by\n+     lto_copy_fields_not_streamed.  */\n+  if (RECORD_OR_UNION_TYPE_P (expr) && COMPLETE_TYPE_P (expr))\n     TYPE_FIELDS (expr) = streamer_read_chain (ib, data_in);\n   else if (TREE_CODE (expr) == FUNCTION_TYPE\n-\t   || TREE_CODE (expr) == METHOD_TYPE)\n+           || TREE_CODE (expr) == METHOD_TYPE)\n     TYPE_ARG_TYPES (expr) = stream_read_tree (ib, data_in);\n-\n-  if (!POINTER_TYPE_P (expr))\n-    TYPE_MINVAL (expr) = stream_read_tree (ib, data_in);\n-  TYPE_MAXVAL (expr) = stream_read_tree (ib, data_in);\n-  if (RECORD_OR_UNION_TYPE_P (expr))\n-    TYPE_BINFO (expr) = stream_read_tree (ib, data_in);\n }\n \n "}, {"sha": "287deb75c19af7aa9203a7eb18b498d7c84c4b23", "filename": "gcc/tree-streamer-out.c", "status": "modified", "additions": 105, "deletions": 22, "changes": 127, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/288eeff72bf7d7e89d975629a7aab8955b9abdad/gcc%2Ftree-streamer-out.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/288eeff72bf7d7e89d975629a7aab8955b9abdad/gcc%2Ftree-streamer-out.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-streamer-out.c?ref=288eeff72bf7d7e89d975629a7aab8955b9abdad", "patch": "@@ -313,6 +313,7 @@ pack_ts_type_common_value_fields (struct bitpack_d *bp, tree expr)\n   bp_pack_value (bp, TYPE_RESTRICT (expr), 1);\n   bp_pack_value (bp, TYPE_USER_ALIGN (expr), 1);\n   bp_pack_value (bp, TYPE_READONLY (expr), 1);\n+  bp_pack_value (bp, COMPLETE_TYPE_P (expr), 1);\n   bp_pack_var_len_unsigned (bp, TYPE_PRECISION (expr));\n   bp_pack_var_len_unsigned (bp, TYPE_ALIGN (expr));\n   /* Make sure to preserve the fact whether the frontend would assign\n@@ -698,19 +699,37 @@ static void\n write_ts_type_common_tree_pointers (struct output_block *ob, tree expr,\n \t\t\t\t    bool ref_p)\n {\n-  stream_write_tree (ob, TYPE_SIZE (expr), ref_p);\n-  stream_write_tree (ob, TYPE_SIZE_UNIT (expr), ref_p);\n-  stream_write_tree (ob, TYPE_ATTRIBUTES (expr), ref_p);\n-  stream_write_tree (ob, TYPE_NAME (expr), ref_p);\n-  /* Do not stream TYPE_POINTER_TO or TYPE_REFERENCE_TO.  They will be\n-     reconstructed during fixup.  */\n   /* Do not stream TYPE_NEXT_VARIANT, we reconstruct the variant lists\n      during fixup.  */\n   stream_write_tree (ob, TYPE_MAIN_VARIANT (expr), ref_p);\n+  if (TYPE_MAIN_VARIANT (expr) == expr)\n+    {\n+      if (COMPLETE_TYPE_P (expr))\n+\t{\n+\t  stream_write_tree (ob, TYPE_SIZE (expr), ref_p);\n+\t  stream_write_tree (ob, TYPE_SIZE_UNIT (expr), ref_p);\n+\t}\n+      stream_write_tree (ob, TYPE_ATTRIBUTES (expr), ref_p);\n+    }\n+  else\n+    {\n+      tree mv = TYPE_MAIN_VARIANT (expr);\n+\n+      gcc_checking_assert (TYPE_MAIN_VARIANT (mv) == mv);\n+      if (COMPLETE_TYPE_P (expr))\n+\t{\n+\t  gcc_checking_assert (TYPE_SIZE (expr) == TYPE_SIZE (mv));\n+\t  gcc_checking_assert (TYPE_SIZE_UNIT (expr) == TYPE_SIZE_UNIT (mv));\n+\t}\n+      gcc_checking_assert (TYPE_ATTRIBUTES (expr) == TYPE_ATTRIBUTES (mv));\n+    }\n+  stream_write_tree (ob, TYPE_NAME (expr), ref_p);\n   stream_write_tree (ob, TYPE_CONTEXT (expr), ref_p);\n+  stream_write_tree (ob, TYPE_STUB_DECL (expr), ref_p);\n+  /* Do not stream TYPE_POINTER_TO or TYPE_REFERENCE_TO.  They will be\n+     reconstructed during fixup.  */\n   /* TYPE_CANONICAL is re-computed during type merging, so no need\n      to stream it here.  */\n-  stream_write_tree (ob, TYPE_STUB_DECL (expr), ref_p);\n }\n \n /* Write all pointer fields in the TS_TYPE_NON_COMMON structure of EXPR\n@@ -721,21 +740,85 @@ static void\n write_ts_type_non_common_tree_pointers (struct output_block *ob, tree expr,\n \t\t\t\t\tbool ref_p)\n {\n-  if (TREE_CODE (expr) == ENUMERAL_TYPE)\n-    stream_write_tree (ob, TYPE_VALUES (expr), ref_p);\n-  else if (TREE_CODE (expr) == ARRAY_TYPE)\n-    stream_write_tree (ob, TYPE_DOMAIN (expr), ref_p);\n-  else if (RECORD_OR_UNION_TYPE_P (expr))\n-    streamer_write_chain (ob, TYPE_FIELDS (expr), ref_p);\n-  else if (TREE_CODE (expr) == FUNCTION_TYPE\n-\t   || TREE_CODE (expr) == METHOD_TYPE)\n-    stream_write_tree (ob, TYPE_ARG_TYPES (expr), ref_p);\n-\n-  if (!POINTER_TYPE_P (expr))\n-    stream_write_tree (ob, TYPE_MINVAL (expr), ref_p);\n-  stream_write_tree (ob, TYPE_MAXVAL (expr), ref_p);\n-  if (RECORD_OR_UNION_TYPE_P (expr))\n-    stream_write_tree (ob, TYPE_BINFO (expr), ref_p);\n+  if (TYPE_MAIN_VARIANT (expr) == expr)\n+    {\n+      if (TREE_CODE (expr) == ENUMERAL_TYPE && COMPLETE_TYPE_P (expr))\n+\tstream_write_tree (ob, TYPE_VALUES (expr), ref_p);\n+      else if (TREE_CODE (expr) == ARRAY_TYPE)\n+\tstream_write_tree (ob, TYPE_DOMAIN (expr), ref_p);\n+\n+      /* TYPE_NEXT_PTR_TO and TYPE_NEXT_REF_TO is recomputed.  */\n+      if (RECORD_OR_UNION_TYPE_P (expr) && COMPLETE_TYPE_P (expr))\n+\tstream_write_tree (ob, TYPE_VFIELD (expr), ref_p);\n+      else if ((TREE_CODE (expr) == ENUMERAL_TYPE && COMPLETE_TYPE_P (expr))\n+\t       || TREE_CODE (expr) == INTEGER_TYPE\n+\t       || TREE_CODE (expr) == BOOLEAN_TYPE\n+\t       || TREE_CODE (expr) == REAL_TYPE\n+\t       || TREE_CODE (expr) == FIXED_POINT_TYPE)\n+\tstream_write_tree (ob, TYPE_MIN_VALUE (expr), ref_p);\n+\n+      if (TREE_CODE (expr) == METHOD_TYPE)\n+\tstream_write_tree (ob, TYPE_METHOD_BASETYPE (expr), ref_p);\n+      else if (RECORD_OR_UNION_TYPE_P (expr) && COMPLETE_TYPE_P (expr))\n+\tstream_write_tree (ob, TYPE_METHODS (expr), ref_p);\n+      else if (TREE_CODE (expr) == OFFSET_TYPE)\n+\tstream_write_tree (ob, TYPE_OFFSET_BASETYPE (expr), ref_p);\n+      else if (TREE_CODE (expr) == ARRAY_TYPE)\n+\tstream_write_tree (ob, TYPE_ARRAY_MAX_SIZE (expr), ref_p);\n+      else if ((TREE_CODE (expr) == ENUMERAL_TYPE && COMPLETE_TYPE_P (expr))\n+\t       || TREE_CODE (expr) == INTEGER_TYPE\n+\t       || TREE_CODE (expr) == BOOLEAN_TYPE\n+\t       || TREE_CODE (expr) == REAL_TYPE\n+\t       || TREE_CODE (expr) == FIXED_POINT_TYPE)\n+\tstream_write_tree (ob, TYPE_MAX_VALUE (expr), ref_p);\n+\n+      if (RECORD_OR_UNION_TYPE_P (expr) && COMPLETE_TYPE_P (expr))\n+\tstream_write_tree (ob, TYPE_BINFO (expr), ref_p);\n+    }\n+  else\n+    {\n+      tree mv = TYPE_MAIN_VARIANT (expr);\n+\n+      if (TREE_CODE (expr) == ENUMERAL_TYPE)\n+        gcc_checking_assert (TYPE_VALUES (expr) == TYPE_VALUES (mv));\n+      else if (TREE_CODE (expr) == ARRAY_TYPE)\n+        gcc_checking_assert (TYPE_DOMAIN (expr) == TYPE_DOMAIN (mv));\n+\n+      if (RECORD_OR_UNION_TYPE_P (expr) && COMPLETE_TYPE_P (expr))\n+        gcc_checking_assert (TYPE_VFIELD (expr) == TYPE_VFIELD (mv));\n+      else if ((TREE_CODE (expr) == ENUMERAL_TYPE && COMPLETE_TYPE_P (expr))\n+\t       || TREE_CODE (expr) == INTEGER_TYPE\n+\t       || TREE_CODE (expr) == BOOLEAN_TYPE\n+\t       || TREE_CODE (expr) == REAL_TYPE\n+\t       || TREE_CODE (expr) == FIXED_POINT_TYPE)\n+        gcc_checking_assert (TYPE_MINVAL (expr) == TYPE_MINVAL (mv));\n+\n+      if (TREE_CODE (expr) == METHOD_TYPE)\n+        gcc_checking_assert (TYPE_METHOD_BASETYPE (expr) == TYPE_METHOD_BASETYPE (mv));\n+      else if (RECORD_OR_UNION_TYPE_P (expr) && COMPLETE_TYPE_P (expr))\n+        gcc_checking_assert (TYPE_METHODS (expr) == TYPE_METHODS (mv));\n+      else if (TREE_CODE (expr) == OFFSET_TYPE)\n+        gcc_checking_assert (TYPE_OFFSET_BASETYPE (expr) == TYPE_OFFSET_BASETYPE (mv));\n+      else if (TREE_CODE (expr) == ARRAY_TYPE)\n+        gcc_checking_assert (TYPE_ARRAY_MAX_SIZE (expr) == TYPE_ARRAY_MAX_SIZE (mv));\n+      else if ((TREE_CODE (expr) == ENUMERAL_TYPE && COMPLETE_TYPE_P (expr))\n+\t       || TREE_CODE (expr) == INTEGER_TYPE\n+\t       || TREE_CODE (expr) == BOOLEAN_TYPE\n+\t       || TREE_CODE (expr) == REAL_TYPE\n+\t       || TREE_CODE (expr) == FIXED_POINT_TYPE)\n+        gcc_checking_assert (TYPE_MAX_VALUE (expr) == TYPE_MAX_VALUE (mv));\n+\n+      if (RECORD_OR_UNION_TYPE_P (expr) && COMPLETE_TYPE_P (expr))\n+        gcc_checking_assert (TYPE_BINFO (expr) == TYPE_BINFO (mv));\n+    }\n+   /* Fortran's gfc_nonrestricted_type may build variant that has different fields.  */\n+   if (RECORD_OR_UNION_TYPE_P (expr) && COMPLETE_TYPE_P (expr))\n+      streamer_write_chain (ob, TYPE_FIELDS (expr), ref_p);\n+   /* Parameters of variant may by modified in case ipa-prop decides to remove\n+      some.  */\n+   else if (TREE_CODE (expr) == FUNCTION_TYPE\n+       || TREE_CODE (expr) == METHOD_TYPE)\n+     stream_write_tree (ob, TYPE_ARG_TYPES (expr), ref_p);\n }\n \n "}]}