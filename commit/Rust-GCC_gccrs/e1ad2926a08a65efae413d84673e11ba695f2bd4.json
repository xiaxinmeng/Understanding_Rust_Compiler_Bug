{"sha": "e1ad2926a08a65efae413d84673e11ba695f2bd4", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTFhZDI5MjZhMDhhNjVlZmFlNDEzZDg0NjczZTExYmE2OTVmMmJkNA==", "commit": {"author": {"name": "Alexandre Oliva", "email": "aoliva@redhat.com", "date": "2017-05-10T10:16:54Z"}, "committer": {"name": "Alexandre Oliva", "email": "aoliva@gcc.gnu.org", "date": "2017-05-10T10:16:54Z"}, "message": "avoid remove&reinsert of call when splitting block for inlining\n\nWe used to split the inlined-into block at (= after) the call, and then\nremove the call from the first block to insert it in the second.\n\nThe removal may cause unnecessary and unrecoverable resetting of debug\ninsns: we do not generate debug temps for calls.\n\nAvoid the remove-and-reinsert dance by splitting the block before the\ncall.\n\nfor  gcc/ChangeLog\n\n\t* tree-inline.c (expand_call_inline): Split block at stmt\n\tbefore the call.\n\nfor  gcc/testsuite/ChangeLog\n\n\t* gcc.dg/guality/inline-params-2.c: New.\n\nFrom-SVN: r247830", "tree": {"sha": "97c8067510e1da022eb7b05fa24ef82a66880abf", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/97c8067510e1da022eb7b05fa24ef82a66880abf"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e1ad2926a08a65efae413d84673e11ba695f2bd4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e1ad2926a08a65efae413d84673e11ba695f2bd4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e1ad2926a08a65efae413d84673e11ba695f2bd4", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e1ad2926a08a65efae413d84673e11ba695f2bd4/comments", "author": null, "committer": null, "parents": [{"sha": "f00b411f5437114d7ee7107be1d150b7d893dfc7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f00b411f5437114d7ee7107be1d150b7d893dfc7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f00b411f5437114d7ee7107be1d150b7d893dfc7"}], "stats": {"total": 72, "additions": 53, "deletions": 19}, "files": [{"sha": "454203cde920d96859e86f8b4986a1794d9d7eb9", "filename": "gcc/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e1ad2926a08a65efae413d84673e11ba695f2bd4/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e1ad2926a08a65efae413d84673e11ba695f2bd4/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=e1ad2926a08a65efae413d84673e11ba695f2bd4", "patch": "@@ -1,3 +1,8 @@\n+2017-05-10  Alexandre Oliva <aoliva@redhat.com>\n+\n+\t* tree-inline.c (expand_call_inline): Split block at stmt\n+\tbefore the call.\n+\n 2017-05-09  Michael Meissner  <meissner@linux.vnet.ibm.com>\n \n \tPR target/68163"}, {"sha": "0fc75a3c1a215ff14a4325ccdac5f28cd29525af", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e1ad2926a08a65efae413d84673e11ba695f2bd4/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e1ad2926a08a65efae413d84673e11ba695f2bd4/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=e1ad2926a08a65efae413d84673e11ba695f2bd4", "patch": "@@ -1,3 +1,7 @@\n+2017-05-10  Alexandre Oliva <aoliva@redhat.com>\n+\n+\t* gcc.dg/guality/inline-params-2.c: New.\n+\n 2017-05-10  Paolo Carlini  <paolo.carlini@oracle.com>\n \n \tPR c++/80145"}, {"sha": "e00188ca01d932b910d149733b5403d584d0a31c", "filename": "gcc/testsuite/gcc.dg/guality/inline-params-2.c", "status": "added", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e1ad2926a08a65efae413d84673e11ba695f2bd4/gcc%2Ftestsuite%2Fgcc.dg%2Fguality%2Finline-params-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e1ad2926a08a65efae413d84673e11ba695f2bd4/gcc%2Ftestsuite%2Fgcc.dg%2Fguality%2Finline-params-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fguality%2Finline-params-2.c?ref=e1ad2926a08a65efae413d84673e11ba695f2bd4", "patch": "@@ -0,0 +1,38 @@\n+/* { dg-do run } */\n+/* tree inline used to split the block for inlining after the call,\n+   then move the call to the after-the-call block.  This move\n+   temporarily deletes the assignment to the result, which in turn\n+   resets any debug bind stmts referencing the result.  Make sure we\n+   don't do that, verifying that the result is visible after the call,\n+   and when passed to another inline function.  */\n+/* { dg-options \"-g\" } */\n+/* { dg-xfail-run-if \"\" { \"*-*-*\" } { \"-fno-fat-lto-objects\" } } */\n+\n+#define GUALITY_DONT_FORCE_LIVE_AFTER -1\n+\n+#ifndef STATIC_INLINE\n+#define STATIC_INLINE /*static*/\n+#endif\n+\n+\n+#include \"guality.h\"\n+\n+__attribute__ ((always_inline)) static inline int\n+t1 (int i)\n+{\n+  GUALCHKVAL (i);\n+  return i;\n+}\n+__attribute__ ((always_inline)) static inline int\n+t2 (int i)\n+{\n+  GUALCHKVAL (i);\n+  return i - 42;\n+}\n+int\n+main (int argc, char *argv[])\n+{\n+  int i = t1(42);\n+  GUALCHKVAL (i);\n+  return t2(i);\n+}"}, {"sha": "db3e08fe0b08d41bcecf030623fe456780ff5d30", "filename": "gcc/tree-inline.c", "status": "modified", "additions": 6, "deletions": 19, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e1ad2926a08a65efae413d84673e11ba695f2bd4/gcc%2Ftree-inline.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e1ad2926a08a65efae413d84673e11ba695f2bd4/gcc%2Ftree-inline.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-inline.c?ref=e1ad2926a08a65efae413d84673e11ba695f2bd4", "patch": "@@ -4542,33 +4542,20 @@ expand_call_inline (basic_block bb, gimple *stmt, copy_body_data *id)\n     DECL_FUNCTION_PERSONALITY (cg_edge->caller->decl)\n       = DECL_FUNCTION_PERSONALITY (cg_edge->callee->decl);\n \n-  /* Split the block holding the GIMPLE_CALL.  */\n-  e = split_block (bb, stmt);\n+  /* Split the block before the GIMPLE_CALL.  */\n+  stmt_gsi = gsi_for_stmt (stmt);\n+  gsi_prev (&stmt_gsi);\n+  e = split_block (bb, gsi_end_p (stmt_gsi) ? NULL : gsi_stmt (stmt_gsi));\n   bb = e->src;\n   return_block = e->dest;\n   remove_edge (e);\n \n-  /* split_block splits after the statement; work around this by\n-     moving the call into the second block manually.  Not pretty,\n-     but seems easier than doing the CFG manipulation by hand\n-     when the GIMPLE_CALL is in the last statement of BB.  */\n-  stmt_gsi = gsi_last_bb (bb);\n-  gsi_remove (&stmt_gsi, false);\n-\n   /* If the GIMPLE_CALL was in the last statement of BB, it may have\n      been the source of abnormal edges.  In this case, schedule\n      the removal of dead abnormal edges.  */\n   gsi = gsi_start_bb (return_block);\n-  if (gsi_end_p (gsi))\n-    {\n-      gsi_insert_after (&gsi, stmt, GSI_NEW_STMT);\n-      purge_dead_abnormal_edges = true;\n-    }\n-  else\n-    {\n-      gsi_insert_before (&gsi, stmt, GSI_NEW_STMT);\n-      purge_dead_abnormal_edges = false;\n-    }\n+  gsi_next (&gsi);\n+  purge_dead_abnormal_edges = gsi_end_p (gsi);\n \n   stmt_gsi = gsi_start_bb (return_block);\n "}]}