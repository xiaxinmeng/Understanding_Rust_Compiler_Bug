{"sha": "18abb35edfc9f88c783813982e568978c2cb51cc", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MThhYmIzNWVkZmM5Zjg4Yzc4MzgxMzk4MmU1Njg5NzhjMmNiNTFjYw==", "commit": {"author": {"name": "Richard Guenther", "email": "rguenther@suse.de", "date": "2010-04-28T11:51:31Z"}, "committer": {"name": "Richard Biener", "email": "rguenth@gcc.gnu.org", "date": "2010-04-28T11:51:31Z"}, "message": "re PR tree-optimization/43879 (-fipa-pta causes various miscompilations)\n\n2010-04-28  Richard Guenther  <rguenther@suse.de>\n\n\tPR tree-optimization/43879\n\tPR tree-optimization/43909\n\t* tree-ssa-structalias.c (struct variable_info): Add\n\tonly_restrict_pointers flag.\n\t(new_var_info): Initialize it.  Increment stats.total_vars here.\n\t(create_function_info_for): Do not increment stats.total_vars\n\there.\n\t(get_function_part_constraint): Fix build with C++.\n\t(insert_into_field_list): Remove.\n\t(push_fields_onto_fieldstack): Properly merge fields.\n\t(create_variable_info_for): Split and simplify.\n\t(create_variable_info_for_1): New piece.\n\t(intra_create_variable_infos): Properly make restrict constraints\n\tfrom parameters.\n\n\t* gcc.dg/ipa/ipa-pta-14.c: Adjust.\n\nFrom-SVN: r158825", "tree": {"sha": "0ace7a08cf72fdb2e7076ab8e3c98f7a7d554c4b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/0ace7a08cf72fdb2e7076ab8e3c98f7a7d554c4b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/18abb35edfc9f88c783813982e568978c2cb51cc", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/18abb35edfc9f88c783813982e568978c2cb51cc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/18abb35edfc9f88c783813982e568978c2cb51cc", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/18abb35edfc9f88c783813982e568978c2cb51cc/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "c718820a974fa2cbd5a181e02d8d19ac2b3dd8f6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c718820a974fa2cbd5a181e02d8d19ac2b3dd8f6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c718820a974fa2cbd5a181e02d8d19ac2b3dd8f6"}], "stats": {"total": 336, "additions": 168, "deletions": 168}, "files": [{"sha": "c8e5f7815e7489e3a92c606c149730c131ccd6a0", "filename": "gcc/ChangeLog", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/18abb35edfc9f88c783813982e568978c2cb51cc/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/18abb35edfc9f88c783813982e568978c2cb51cc/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=18abb35edfc9f88c783813982e568978c2cb51cc", "patch": "@@ -1,3 +1,20 @@\n+2010-04-28  Richard Guenther  <rguenther@suse.de>\n+\n+\tPR tree-optimization/43879\n+\tPR tree-optimization/43909\n+\t* tree-ssa-structalias.c (struct variable_info): Add\n+\tonly_restrict_pointers flag.\n+\t(new_var_info): Initialize it.  Increment stats.total_vars here.\n+\t(create_function_info_for): Do not increment stats.total_vars\n+\there.\n+\t(get_function_part_constraint): Fix build with C++.\n+\t(insert_into_field_list): Remove.\n+\t(push_fields_onto_fieldstack): Properly merge fields.\n+\t(create_variable_info_for): Split and simplify.\n+\t(create_variable_info_for_1): New piece.\n+\t(intra_create_variable_infos): Properly make restrict constraints\n+\tfrom parameters.\n+\n 2010-04-28  Richard Guenther  <rguenther@suse.de>\n \n \tPR c++/43880"}, {"sha": "afe65f7aa88882d2c601f1427678634bcd93c836", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/18abb35edfc9f88c783813982e568978c2cb51cc/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/18abb35edfc9f88c783813982e568978c2cb51cc/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=18abb35edfc9f88c783813982e568978c2cb51cc", "patch": "@@ -1,3 +1,9 @@\n+2010-04-28  Richard Guenther  <rguenther@suse.de>\n+\n+\tPR tree-optimization/43879\n+\tPR tree-optimization/43909\n+\t* gcc.dg/ipa/ipa-pta-14.c: Adjust.\n+\n 2010-04-28  Richard Guenther  <rguenther@suse.de>\n \n \tPR c++/43880"}, {"sha": "074f44a6d68468ca0d786e64c66d14f367373748", "filename": "gcc/testsuite/gcc.dg/ipa/ipa-pta-14.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/18abb35edfc9f88c783813982e568978c2cb51cc/gcc%2Ftestsuite%2Fgcc.dg%2Fipa%2Fipa-pta-14.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/18abb35edfc9f88c783813982e568978c2cb51cc/gcc%2Ftestsuite%2Fgcc.dg%2Fipa%2Fipa-pta-14.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fipa%2Fipa-pta-14.c?ref=18abb35edfc9f88c783813982e568978c2cb51cc", "patch": "@@ -21,8 +21,8 @@ int main()\n   void *p;\n   a.p = (void *)&c;\n   p = foo(&a, &a);\n-  /* { dg-final { scan-ipa-dump \"foo.result = { NULL a c }\" \"pta\" { xfail *-*-* } } } */\n-  /* { dg-final { scan-ipa-dump \"foo.result = { NULL a a\\[^ \\]* c }\" \"pta\" } } */\n+  /* { dg-final { scan-ipa-dump \"foo.result = { NULL a\\[^ \\]* c\\[^ \\]* }\" \"pta\" { xfail *-*-* } } } */\n+  /* { dg-final { scan-ipa-dump \"foo.result = { NULL a\\[^ \\]* a\\[^ \\]* c\\[^ \\]* }\" \"pta\" } } */\n   ((struct X *)p)->p = (void *)0;\n   if (a.p != (void *)0)\n     abort ();"}, {"sha": "08d3fa7e15b2f5034590525ffaec1af9746ea27d", "filename": "gcc/tree-ssa-structalias.c", "status": "modified", "additions": 143, "deletions": 166, "changes": 309, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/18abb35edfc9f88c783813982e568978c2cb51cc/gcc%2Ftree-ssa-structalias.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/18abb35edfc9f88c783813982e568978c2cb51cc/gcc%2Ftree-ssa-structalias.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-structalias.c?ref=18abb35edfc9f88c783813982e568978c2cb51cc", "patch": "@@ -275,6 +275,9 @@ struct variable_info\n   /* True if this field may contain pointers.  */\n   unsigned int may_have_pointers : 1;\n \n+  /* True if this field has only restrict qualified pointers.  */\n+  unsigned int only_restrict_pointers : 1;\n+\n   /* True if this represents a global variable.  */\n   unsigned int is_global_var : 1;\n \n@@ -412,6 +415,7 @@ new_var_info (tree t, const char *name)\n   ret->is_heap_var = false;\n   ret->is_restrict_var = false;\n   ret->may_have_pointers = true;\n+  ret->only_restrict_pointers = false;\n   ret->is_global_var = (t == NULL_TREE);\n   ret->is_fn_info = false;\n   if (t && DECL_P (t))\n@@ -420,6 +424,8 @@ new_var_info (tree t, const char *name)\n   ret->oldsolution = BITMAP_ALLOC (&oldpta_obstack);\n   ret->next = NULL;\n \n+  stats.total_vars++;\n+\n   VEC_safe_push (varinfo_t, heap, varmap, ret);\n \n   return ret;\n@@ -3641,7 +3647,10 @@ get_function_part_constraint (varinfo_t fi, unsigned part)\n   else if (TREE_CODE (fi->decl) == FUNCTION_DECL)\n     {\n       varinfo_t ai = first_vi_for_offset (fi, part);\n-      c.var = ai ? ai->id : anything_id;\n+      if (ai)\n+\tc.var = ai->id;\n+      else\n+\tc.var = anything_id;\n       c.offset = 0;\n       c.type = SCALAR;\n     }\n@@ -4723,19 +4732,6 @@ first_or_preceding_vi_for_offset (varinfo_t start,\n }\n \n \n-/* Insert the varinfo FIELD into the field list for BASE, at the front\n-   of the list.  */\n-\n-static void\n-insert_into_field_list (varinfo_t base, varinfo_t field)\n-{\n-  varinfo_t prev = base;\n-  varinfo_t curr = base->next;\n-\n-  field->next = curr;\n-  prev->next = field;\n-}\n-\n /* This structure is used during pushing fields onto the fieldstack\n    to track the offset of the field, since bitpos_of_field gives it\n    relative to its immediate containing type, and we want it relative\n@@ -4821,37 +4817,37 @@ var_can_have_subvars (const_tree v)\n \n    OFFSET is used to keep track of the offset in this entire\n    structure, rather than just the immediately containing structure.\n-   Returns the number of fields pushed.  */\n+   Returns false if the caller is supposed to handle the field we\n+   recursed for.  */\n \n-static int\n+static bool\n push_fields_onto_fieldstack (tree type, VEC(fieldoff_s,heap) **fieldstack,\n \t\t\t     HOST_WIDE_INT offset)\n {\n   tree field;\n-  int count = 0;\n+  bool empty_p = true;\n \n   if (TREE_CODE (type) != RECORD_TYPE)\n-    return 0;\n+    return false;\n \n   /* If the vector of fields is growing too big, bail out early.\n      Callers check for VEC_length <= MAX_FIELDS_FOR_FIELD_SENSITIVE, make\n      sure this fails.  */\n   if (VEC_length (fieldoff_s, *fieldstack) > MAX_FIELDS_FOR_FIELD_SENSITIVE)\n-    return 0;\n+    return false;\n \n   for (field = TYPE_FIELDS (type); field; field = TREE_CHAIN (field))\n     if (TREE_CODE (field) == FIELD_DECL)\n       {\n \tbool push = false;\n-\tint pushed = 0;\n \tHOST_WIDE_INT foff = bitpos_of_field (field);\n \n \tif (!var_can_have_subvars (field)\n \t    || TREE_CODE (TREE_TYPE (field)) == QUAL_UNION_TYPE\n \t    || TREE_CODE (TREE_TYPE (field)) == UNION_TYPE)\n \t  push = true;\n-\telse if (!(pushed = push_fields_onto_fieldstack\n-\t\t   (TREE_TYPE (field), fieldstack, offset + foff))\n+\telse if (!push_fields_onto_fieldstack\n+\t\t    (TREE_TYPE (field), fieldstack, offset + foff)\n \t\t && (DECL_SIZE (field)\n \t\t     && !integer_zerop (DECL_SIZE (field))))\n \t  /* Empty structures may have actual size, like in C++.  So\n@@ -4874,12 +4870,11 @@ push_fields_onto_fieldstack (tree type, VEC(fieldoff_s,heap) **fieldstack,\n \t    /* If adjacent fields do not contain pointers merge them.  */\n \t    if (pair\n \t\t&& !pair->may_have_pointers\n-\t\t&& !could_have_pointers (field)\n \t\t&& !pair->has_unknown_size\n \t\t&& !has_unknown_size\n-\t\t&& pair->offset + (HOST_WIDE_INT)pair->size == offset + foff)\n+\t\t&& pair->offset + (HOST_WIDE_INT)pair->size == offset + foff\n+\t\t&& !could_have_pointers (field))\n \t      {\n-\t\tpair = VEC_last (fieldoff_s, *fieldstack);\n \t\tpair->size += TREE_INT_CST_LOW (DECL_SIZE (field));\n \t      }\n \t    else\n@@ -4896,14 +4891,13 @@ push_fields_onto_fieldstack (tree type, VEC(fieldoff_s,heap) **fieldstack,\n \t\t  = (!has_unknown_size\n \t\t     && POINTER_TYPE_P (TREE_TYPE (field))\n \t\t     && TYPE_RESTRICT (TREE_TYPE (field)));\n-\t\tcount++;\n \t      }\n \t  }\n-\telse\n-\t  count += pushed;\n+\n+\tempty_p = false;\n       }\n \n-  return count;\n+  return !empty_p;\n }\n \n /* Count the number of arguments DECL has, and set IS_VARARGS to true\n@@ -4955,8 +4949,6 @@ create_function_info_for (tree decl, const char *name)\n     vi->fullsize = ~0;\n   insert_vi_for_tree (vi->decl, vi);\n \n-  stats.total_vars++;\n-\n   prev_vi = vi;\n \n   /* Create a variable for things the function clobbers and one for\n@@ -4979,7 +4971,6 @@ create_function_info_for (tree decl, const char *name)\n       gcc_assert (prev_vi->offset < clobbervi->offset);\n       prev_vi->next = clobbervi;\n       prev_vi = clobbervi;\n-      stats.total_vars++;\n \n       asprintf (&tempname, \"%s.use\", name);\n       newname = ggc_strdup (tempname);\n@@ -4994,7 +4985,6 @@ create_function_info_for (tree decl, const char *name)\n       gcc_assert (prev_vi->offset < usevi->offset);\n       prev_vi->next = usevi;\n       prev_vi = usevi;\n-      stats.total_vars++;\n     }\n \n   /* And one for the static chain.  */\n@@ -5017,7 +5007,6 @@ create_function_info_for (tree decl, const char *name)\n       gcc_assert (prev_vi->offset < chainvi->offset);\n       prev_vi->next = chainvi;\n       prev_vi = chainvi;\n-      stats.total_vars++;\n       insert_vi_for_tree (fn->static_chain_decl, chainvi);\n     }\n \n@@ -5047,7 +5036,6 @@ create_function_info_for (tree decl, const char *name)\n       gcc_assert (prev_vi->offset < resultvi->offset);\n       prev_vi->next = resultvi;\n       prev_vi = resultvi;\n-      stats.total_vars++;\n       if (DECL_RESULT (decl))\n \tinsert_vi_for_tree (DECL_RESULT (decl), resultvi);\n     }\n@@ -5078,7 +5066,6 @@ create_function_info_for (tree decl, const char *name)\n       gcc_assert (prev_vi->offset < argvi->offset);\n       prev_vi->next = argvi;\n       prev_vi = argvi;\n-      stats.total_vars++;\n       if (arg)\n \t{\n \t  insert_vi_for_tree (arg, argvi);\n@@ -5111,7 +5098,6 @@ create_function_info_for (tree decl, const char *name)\n       gcc_assert (prev_vi->offset < argvi->offset);\n       prev_vi->next = argvi;\n       prev_vi = argvi;\n-      stats.total_vars++;\n     }\n \n   return vi->id;\n@@ -5141,48 +5127,135 @@ check_for_overlaps (VEC (fieldoff_s,heap) *fieldstack)\n    This will also create any varinfo structures necessary for fields\n    of DECL.  */\n \n-static unsigned int\n-create_variable_info_for (tree decl, const char *name)\n+static varinfo_t\n+create_variable_info_for_1 (tree decl, const char *name)\n {\n-  varinfo_t vi;\n+  varinfo_t vi, newvi;\n   tree decl_type = TREE_TYPE (decl);\n   tree declsize = DECL_P (decl) ? DECL_SIZE (decl) : TYPE_SIZE (decl_type);\n   VEC (fieldoff_s,heap) *fieldstack = NULL;\n+  fieldoff_s *fo;\n+  unsigned int i;\n \n-  if (var_can_have_subvars (decl) && use_field_sensitive)\n-    push_fields_onto_fieldstack (decl_type, &fieldstack, 0);\n-\n-  /* If the variable doesn't have subvars, we may end up needing to\n-     sort the field list and create fake variables for all the\n-     fields.  */\n-  vi = new_var_info (decl, name);\n-  vi->offset = 0;\n-  vi->may_have_pointers = could_have_pointers (decl);\n   if (!declsize\n       || !host_integerp (declsize, 1))\n     {\n-      vi->is_unknown_size_var = true;\n-      vi->fullsize = ~0;\n+      vi = new_var_info (decl, name);\n+      vi->offset = 0;\n       vi->size = ~0;\n+      vi->fullsize = ~0;\n+      vi->is_unknown_size_var = true;\n+      vi->is_full_var = true;\n+      vi->may_have_pointers = could_have_pointers (decl);\n+      return vi;\n     }\n-  else\n+\n+  /* Collect field information.  */\n+  if (use_field_sensitive\n+      && var_can_have_subvars (decl)\n+      /* ???  Force us to not use subfields for global initializers\n+\t in IPA mode.  Else we'd have to parse arbitrary initializers.  */\n+      && !(in_ipa_mode\n+\t   && is_global_var (decl)\n+\t   && DECL_INITIAL (decl)))\n+    {\n+      fieldoff_s *fo = NULL;\n+      bool notokay = false;\n+      unsigned int i;\n+\n+      push_fields_onto_fieldstack (decl_type, &fieldstack, 0);\n+\n+      for (i = 0; !notokay && VEC_iterate (fieldoff_s, fieldstack, i, fo); i++)\n+\tif (fo->has_unknown_size\n+\t    || fo->offset < 0)\n+\t  {\n+\t    notokay = true;\n+\t    break;\n+\t  }\n+\n+      /* We can't sort them if we have a field with a variable sized type,\n+\t which will make notokay = true.  In that case, we are going to return\n+\t without creating varinfos for the fields anyway, so sorting them is a\n+\t waste to boot.  */\n+      if (!notokay)\n+\t{\n+\t  sort_fieldstack (fieldstack);\n+\t  /* Due to some C++ FE issues, like PR 22488, we might end up\n+\t     what appear to be overlapping fields even though they,\n+\t     in reality, do not overlap.  Until the C++ FE is fixed,\n+\t     we will simply disable field-sensitivity for these cases.  */\n+\t  notokay = check_for_overlaps (fieldstack);\n+\t}\n+\n+      if (notokay)\n+\tVEC_free (fieldoff_s, heap, fieldstack);\n+    }\n+\n+  /* If we didn't end up collecting sub-variables create a full\n+     variable for the decl.  */\n+  if (VEC_length (fieldoff_s, fieldstack) <= 1\n+      || VEC_length (fieldoff_s, fieldstack) > MAX_FIELDS_FOR_FIELD_SENSITIVE)\n     {\n+      vi = new_var_info (decl, name);\n+      vi->offset = 0;\n+      vi->may_have_pointers = could_have_pointers (decl);\n       vi->fullsize = TREE_INT_CST_LOW (declsize);\n       vi->size = vi->fullsize;\n+      vi->is_full_var = true;\n+      VEC_free (fieldoff_s, heap, fieldstack);\n+      return vi;\n     }\n \n-  insert_vi_for_tree (vi->decl, vi);\n+  vi = new_var_info (decl, name);\n+  vi->fullsize = TREE_INT_CST_LOW (declsize);\n+  for (i = 0, newvi = vi;\n+       VEC_iterate (fieldoff_s, fieldstack, i, fo);\n+       ++i, newvi = newvi->next)\n+    {\n+      const char *newname = \"NULL\";\n+      char *tempname;\n \n-  /* ???  The setting of vi->may_have_pointers is too conservative here\n-     and may get refined below.  Thus we have superfluous constraints\n-     here sometimes which triggers the commented assert in\n-     dump_sa_points_to_info.  */\n-  if (vi->is_global_var\n-      && vi->may_have_pointers)\n+      if (dump_file)\n+\t{\n+\t  asprintf (&tempname, \"%s.\" HOST_WIDE_INT_PRINT_DEC\n+\t\t    \"+\" HOST_WIDE_INT_PRINT_DEC, name, fo->offset, fo->size);\n+\t  newname = ggc_strdup (tempname);\n+\t  free (tempname);\n+\t}\n+      newvi->name = newname;\n+      newvi->offset = fo->offset;\n+      newvi->size = fo->size;\n+      newvi->fullsize = vi->fullsize;\n+      newvi->may_have_pointers = fo->may_have_pointers;\n+      newvi->only_restrict_pointers = fo->only_restrict_pointers;\n+      if (i + 1 < VEC_length (fieldoff_s, fieldstack))\n+\tnewvi->next = new_var_info (decl, name);\n+    }\n+\n+  VEC_free (fieldoff_s, heap, fieldstack);\n+\n+  return vi;\n+}\n+\n+static unsigned int\n+create_variable_info_for (tree decl, const char *name)\n+{\n+  varinfo_t vi = create_variable_info_for_1 (decl, name);\n+  unsigned int id = vi->id;\n+\n+  insert_vi_for_tree (decl, vi);\n+\n+  /* Create initial constraints for globals.  */\n+  for (; vi; vi = vi->next)\n     {\n+      if (!vi->may_have_pointers\n+\t  || !vi->is_global_var)\n+\tcontinue;\n+\n       /* Mark global restrict qualified pointers.  */\n-      if (POINTER_TYPE_P (TREE_TYPE (decl))\n-\t  && TYPE_RESTRICT (TREE_TYPE (decl)))\n+      if ((POINTER_TYPE_P (TREE_TYPE (decl))\n+\t   && TYPE_RESTRICT (TREE_TYPE (decl)))\n+\t  || vi->only_restrict_pointers)\n \tmake_constraint_from_restrict (vi, \"GLOBAL_RESTRICT\");\n \n       /* For escaped variables initialize them from nonlocal.  */\n@@ -5194,12 +5267,12 @@ create_variable_info_for (tree decl, const char *name)\n \t IPA mode generate constraints for it.  In non-IPA mode\n \t the initializer from nonlocal is all we need.  */\n       if (in_ipa_mode\n-\t  && DECL_INITIAL (vi->decl))\n+\t  && DECL_INITIAL (decl))\n \t{\n \t  VEC (ce_s, heap) *rhsc = NULL;\n \t  struct constraint_expr lhs, *rhsp;\n \t  unsigned i;\n-\t  get_constraint_for (DECL_INITIAL (vi->decl), &rhsc);\n+\t  get_constraint_for (DECL_INITIAL (decl), &rhsc);\n \t  lhs.var = vi->id;\n \t  lhs.offset = 0;\n \t  lhs.type = SCALAR;\n@@ -5216,110 +5289,10 @@ create_variable_info_for (tree decl, const char *name)\n \t\tprocess_constraint (new_constraint (lhs, *rhsp));\n \t    }\n \t  VEC_free (ce_s, heap, rhsc);\n-\t  /* ???  Force us to not use subfields.  Else we'd have to parse\n-\t     arbitrary initializers.  */\n-\t  VEC_free (fieldoff_s, heap, fieldstack);\n \t}\n     }\n \n-  stats.total_vars++;\n-  if (use_field_sensitive\n-      && !vi->is_unknown_size_var\n-      && var_can_have_subvars (decl)\n-      && VEC_length (fieldoff_s, fieldstack) > 1\n-      && VEC_length (fieldoff_s, fieldstack) <= MAX_FIELDS_FOR_FIELD_SENSITIVE)\n-    {\n-      fieldoff_s *fo = NULL;\n-      bool notokay = false;\n-      unsigned int i;\n-\n-      for (i = 0; !notokay && VEC_iterate (fieldoff_s, fieldstack, i, fo); i++)\n-\t{\n-\t  if (fo->has_unknown_size\n-\t      || fo->offset < 0)\n-\t    {\n-\t      notokay = true;\n-\t      break;\n-\t    }\n-\t}\n-\n-      /* We can't sort them if we have a field with a variable sized type,\n-\t which will make notokay = true.  In that case, we are going to return\n-\t without creating varinfos for the fields anyway, so sorting them is a\n-\t waste to boot.  */\n-      if (!notokay)\n-\t{\n-\t  sort_fieldstack (fieldstack);\n-\t  /* Due to some C++ FE issues, like PR 22488, we might end up\n-\t     what appear to be overlapping fields even though they,\n-\t     in reality, do not overlap.  Until the C++ FE is fixed,\n-\t     we will simply disable field-sensitivity for these cases.  */\n-\t  notokay = check_for_overlaps (fieldstack);\n-\t}\n-\n-\n-      if (VEC_length (fieldoff_s, fieldstack) != 0)\n-\tfo = VEC_index (fieldoff_s, fieldstack, 0);\n-\n-      if (fo == NULL || notokay)\n-\t{\n-\t  vi->is_unknown_size_var = 1;\n-\t  vi->fullsize = ~0;\n-\t  vi->size = ~0;\n-\t  vi->is_full_var = true;\n-\t  VEC_free (fieldoff_s, heap, fieldstack);\n-\t  return vi->id;\n-\t}\n-\n-      vi->size = fo->size;\n-      vi->offset = fo->offset;\n-      vi->may_have_pointers = fo->may_have_pointers;\n-      if (vi->is_global_var\n-\t  && vi->may_have_pointers)\n-\t{\n-\t  if (fo->only_restrict_pointers)\n-\t    make_constraint_from_restrict (vi, \"GLOBAL_RESTRICT\");\n-\t}\n-      for (i = VEC_length (fieldoff_s, fieldstack) - 1;\n-\t   i >= 1 && VEC_iterate (fieldoff_s, fieldstack, i, fo);\n-\t   i--)\n-\t{\n-\t  varinfo_t newvi;\n-\t  const char *newname = \"NULL\";\n-\t  char *tempname;\n-\n-\t  if (dump_file)\n-\t    {\n-\t      asprintf (&tempname, \"%s.\" HOST_WIDE_INT_PRINT_DEC\n-\t\t\t\"+\" HOST_WIDE_INT_PRINT_DEC,\n-\t\t\tvi->name, fo->offset, fo->size);\n-\t      newname = ggc_strdup (tempname);\n-\t      free (tempname);\n-\t    }\n-\t  newvi = new_var_info (decl, newname);\n-\t  newvi->offset = fo->offset;\n-\t  newvi->size = fo->size;\n-\t  newvi->fullsize = vi->fullsize;\n-\t  newvi->may_have_pointers = fo->may_have_pointers;\n-\t  insert_into_field_list (vi, newvi);\n-\t  if ((newvi->is_global_var || TREE_CODE (decl) == PARM_DECL)\n-\t      && newvi->may_have_pointers)\n-\t    {\n-\t       if (fo->only_restrict_pointers)\n-\t\t make_constraint_from_restrict (newvi, \"GLOBAL_RESTRICT\");\n-\t       if (newvi->is_global_var && !in_ipa_mode)\n-\t\t make_copy_constraint (newvi, nonlocal_id);\n-\t    }\n-\n-\t  stats.total_vars++;\n-\t}\n-    }\n-  else\n-    vi->is_full_var = true;\n-\n-  VEC_free (fieldoff_s, heap, fieldstack);\n-\n-  return vi->id;\n+  return id;\n }\n \n /* Print out the points-to solution for VAR to FILE.  */\n@@ -5405,8 +5378,12 @@ intra_create_variable_infos (void)\n \t}\n \n       for (p = get_vi_for_tree (t); p; p = p->next)\n-\tif (p->may_have_pointers)\n-\t  make_constraint_from (p, nonlocal_id);\n+\t{\n+\t  if (p->may_have_pointers)\n+\t    make_constraint_from (p, nonlocal_id);\n+\t  if (p->only_restrict_pointers)\n+\t    make_constraint_from_restrict (p, \"PARM_RESTRICT\");\n+\t}\n       if (POINTER_TYPE_P (TREE_TYPE (t))\n \t  && TYPE_RESTRICT (TREE_TYPE (t)))\n \tmake_constraint_from_restrict (get_vi_for_tree (t), \"PARM_RESTRICT\");"}]}