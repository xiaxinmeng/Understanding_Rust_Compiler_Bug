{"sha": "e133ace8d907bf42754c86106fc3f04a9d9fe70f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTEzM2FjZThkOTA3YmY0Mjc1NGM4NjEwNmZjM2YwNGE5ZDlmZTcwZg==", "commit": {"author": {"name": "Paolo Carlini", "email": "pcarlini@suse.de", "date": "2007-05-31T23:37:56Z"}, "committer": {"name": "Paolo Carlini", "email": "paolo@gcc.gnu.org", "date": "2007-05-31T23:37:56Z"}, "message": "re PR libstdc++/31426 (TR1 includes do not work with -std=c++0x)\n\n2007-05-31  Paolo Carlini  <pcarlini@suse.de>\n\n\tPR libstdc++/31426\n\t* include/bits/c++config: Remove namespace association bits\n\tfrom tr1 to std.\n\n\t* include/ext/type_traits.h (__promote, __promote2,\n\t__promote3, __promote4): Add.\n\n\t* include/bits/hashtable.h: New.\n\t* include/bits/functional_hash.h: Likewise.\n\t* include/tr1/hashtable.h: Likewise.\n\n\t* include/tr1_impl/random: New.\n\t* include/tr1_impl/cinttypes: Likewise.\n\t* include/tr1_impl/cstdlib: Likewise.\n\t* include/tr1_impl/unordered_map: Likewise.\n\t* include/tr1_impl/cstdio: Likewise.\n\t* include/tr1_impl/boost_shared_ptr.h: Likewise.\n\t* include/tr1_impl/cctype: Likewise.\n\t* include/tr1_impl/random.tcc: Likewise.\n\t* include/tr1_impl/tuple: Likewise.\n\t* include/tr1_impl/functional_hash.h: Likewise.\n\t* include/tr1_impl/hashtable: Likewise.\n\t* include/tr1_impl/cmath: Likewise.\n\t* include/tr1_impl/type_traitsfwd.h: Likewise.\n\t* include/tr1_impl/hashtable_policy.h: Likewise.\n\t* include/tr1_impl/cfenv: Likewise.\n\t* include/tr1_impl/unordered_set: Likewise.\n\t* include/tr1_impl/functional: Likewise.\n\t* include/tr1_impl/utility: Likewise.\n\t* include/tr1_impl/complex: Likewise.\n\t* include/tr1_impl/type_traits: Likewise.\n\t* include/tr1_impl/cwchar: Likewise.\n\t* include/tr1_impl/cstdint: Likewise.\n\t* include/tr1_impl/regex: Likewise.\n\t* include/tr1_impl/array: Likewise.\n\t* include/tr1_impl/cwctype: Likewise.\n\n\t* include/tr1/type_traitsfwd.h: Remove.\n\t* include/tr1/boost_shared_ptr.h: Likewise.\n\t* include/tr1/common.h: Likewise.\n\t* include/tr1/hashtable: Likewise.\n\t* include/tr1/hashtable_policy.h: Likewise.\n\t* include/tr1/random.tcc: Likewise.\n\n\t* include/c_global/cinttypes: Include tr1_impl/cinttypes.\n\t* include/c_global/cstdlib: Likewise for cstdlib.\n\t* include/c_global/cstdio: Likewise for cstdio.\n\t* include/c_global/cctype: Likewise for cctype.\n\t* include/c_global/cmath: Likewise for cmath.\n\t* include/c_global/cfenv: Likewise for cfenv.\n\t* include/c_global/cwchar: Likewise for cwchar.\n\t* include/c_global/cstdint: Likewise for cstdint.\n\t* include/c_global/cwctype: Likewise for cwctype.\n\t* include/tr1/cinttypes: Likewise for cinttypes.\n\t* include/tr1/cstdlib: Likewise for cstdlib.\n\t* include/tr1/cstdio: Likewise for cstdio.\n\t* include/tr1/cctype: Likewise for cctype.\n\t* include/tr1/cmath: Likewise for cmath.\n\t* include/tr1/cfenv: Likewise for cfenv.\n\t* include/tr1/cwchar: Likewise for cwchar.\n\t* include/tr1/cstdint: Likewise for cstdint.\n\t* include/tr1/cwctype: Likewise for cwctype.\n\t* include/tr1/functional_hash.h: Likewise for functional_hash.\n\n\t* include/std/tuple: Include tr1_impl/tuple.\n\t* include/std/utility: Likewise for utility.\n\t* include/std/type_traits: Likewise for type_traits.\n\t(is_pod): Just forward to __is_pod.\n\t(has_trivial_default_constructor): Just forward to\n\t__has_trivial_constructor.\n\t(has_trivial_copy_constructor): Just forward to __has_trivial_copy.\n\t(has_trivial_assign): Just forward to __has_trivial_assign.\n\t(has_trivial_destructor): Just forward to __has_trivial_destructor.\n\t(has_nothrow_default_constructor): Just forward to\n\t__has_nothrow_constructor.\n\t(has_nothrow_copy_constructor): Just forward to __has_nothrow_copy.\n\t(has_nothrow_assign): Just forward to __has_nothrow_assign.\n\t(is_base_of): Just forward to __is_base_of.\n\t(is_signed, is_unsigned): Implement according to the C++0x\n\tspecifications.\n\t* include/std/memory: Likewise for memory.\n\t* include/std/regex: Likewise for regex.\n\t* include/std/random: Likewise for random.\n\t* include/std/unordered_map: Likewise for unordered_map.\n\t* include/std/unordered_set: Likewise for unordered_set.\n\t* include/std/functional: Likewise for functional.\n\t* include/std/complex: Likewise for complex.\n\t* include/std/array: Likewise for array.\n\t* include/tr1/tuple: Likewise for tuple.\n\t* include/tr1/utility: Likewise for utility.\n\t* include/tr1/type_traits: Likewise for type_traits\n\t* include/tr1/memory: Likewise for memory.\n\t* include/tr1/regex: Likewise for regex.\n\t* include/tr1/random: Likewise for random.\n\t* include/tr1/unordered_map: Likewise for unordered_map.\n\t* include/tr1/unordered_set: Likewise for unordered_set.\n\t* include/tr1/functional: Likewise for functional.\n\t* include/tr1/complex: Likewise for complex.\n\t* include/tr1/array: Likewise for array.\n\n\t* include/c_global/ctgmath: Tweak.\n\t* include/c_global/cstdarg: Likewise.\n\t* include/c_global/ctime: Likewise.\n\t* include/c_global/climits: Likewise.\n\t* include/c_global/cfloat: Likewise.\t\n\t* include/c_global/ccomplex: Likewise.\n\t* include/c_global/cstdbool: Likewise.\n\n\t* include/tr1/poly_laguerre.tcc: Tweak, don't use _GLIBCXX_TR1.\n\t* include/tr1/riemann_zeta.tcc: Likewise.\n\t* include/tr1/beta_function.tcc: Likewise.\n\t* include/tr1/exp_integral.tcc: Likewise.\n\t* include/tr1/hypergeometric.tcc: Likewise.\n\t* include/tr1/modified_bessel_func.tcc: Likewise.\n\t* include/tr1/legendre_function.tcc: Likewise.\n\t* include/tr1/special_function_util.h: Likewise.\n\t* include/tr1/bessel_function.tcc: Likewise.\n\t* include/tr1/poly_hermite.tcc: Likewise.\n\t* include/tr1/ell_integral.tcc: Likewise.\n\t* include/tr1/gamma.tcc: Likewise.\n\t* include/tr1/stdlib.h: Likewise.\n\t* include/tr1/math.h: Likewise.\n\n\t* include/tr1/complex.h: Minor tweaks.\n\t* include/tr1/wctype.h: Likewise.\n\t* include/tr1/wchar.h: Likewise.\n\t* include/tr1/inttypes.h: Likewise.\n\t* include/tr1/tgmath.h: Likewise.\n\t* include/tr1/cstdbool: Likewise.\n\t* include/tr1/cfloat: Likewise.\n\t* include/tr1/ccomplex: Likewise.\n\t* include/tr1/ctime: Likewise.\n\t* include/tr1/climits: Likewise.\n\t* include/tr1/ctgmath: Likewise.\n\t* include/tr1/cstdarg: Likewise.\n\n\t* testsuite/tr1/headers.cc: Move...\n\t* testsuite/tr1/headers/all.cc: ... here.\n\t* testsuite/tr1/using_namespace_std_tr1.cc: Move...\n\t* testsuite/tr1/headers/c++200x/using_namespace_std_tr1.cc: ... here.\n\t* testsuite/tr1/headers/using_namespace_std_tr1.cc ... here.\n\t* testsuite/tr1/headers/c++200x/using_namespace_std_tr1.cc: New.\n\n\t* testsuite/20_util/tuple/requirements/explicit_instantiation.cc:\n\tAdjust namespace.\n\t* testsuite/20_util/has_nothrow_copy_constructor/value.cc: Adjust to\n\tthe C++0x requirements.\n\t* testsuite/20_util/has_nothrow_default_constructor/value.cc: Likewise.\n\t* testsuite/20_util/has_trivial_copy_constructor/value.cc: Likewise.\n\t* testsuite/20_util/has_trivial_default_constructor/value.cc: Likewise.\n\n\t* testsuite/20_util/make_signed/requirements/typedefs_neg.cc: Adjust\n\tdg-error lines.\n\t* testsuite/20_util/make_unsigned/requirements/typedefs_neg.cc:\n\tLikewise.\n\t* testsuite/20_util/headers/type_traits/types_std_c++0x_neg.cc:\n\tUn-xfail.\n\n\t* testsuite/20_util/is_signed/value.cc: New.\n\t* testsuite/20_util/is_signed/requirements/typedefs.cc: Likewise.\n\t* testsuite/20_util/is_signed/requirements/explicit_instantiation.cc:\n\tLikewise.\n\t* testsuite/20_util/is_unsigned/value.cc: Likewise..\n\t* testsuite/20_util/is_unsigned/requirements/typedefs.cc: Likewise.\n\t* testsuite/20_util/is_unsigned/requirements/explicit_instantiation.cc:\n\tLikewise.\n\n\t* include/Makefile.am: Adjust.\t\n\t* include/Makefile.in: Regenerate.\n\nFrom-SVN: r125244", "tree": {"sha": "324bd2dd4033459fbf3d757935139d54703da05b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/324bd2dd4033459fbf3d757935139d54703da05b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e133ace8d907bf42754c86106fc3f04a9d9fe70f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e133ace8d907bf42754c86106fc3f04a9d9fe70f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e133ace8d907bf42754c86106fc3f04a9d9fe70f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e133ace8d907bf42754c86106fc3f04a9d9fe70f/comments", "author": null, "committer": null, "parents": [{"sha": "9cbff7e7d94be033fa30d1dba49b8036adfffcb4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9cbff7e7d94be033fa30d1dba49b8036adfffcb4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9cbff7e7d94be033fa30d1dba49b8036adfffcb4"}], "stats": {"total": 24110, "additions": 13158, "deletions": 10952}, "files": [{"sha": "48d6f879f750b53adb89373f51a3f75be550f9ce", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 172, "deletions": 0, "changes": 172, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e133ace8d907bf42754c86106fc3f04a9d9fe70f/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e133ace8d907bf42754c86106fc3f04a9d9fe70f/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=e133ace8d907bf42754c86106fc3f04a9d9fe70f", "patch": "@@ -1,3 +1,175 @@\n+2007-05-31  Paolo Carlini  <pcarlini@suse.de>\n+\n+\tPR libstdc++/31426\n+\t* include/bits/c++config: Remove namespace association bits\n+\tfrom tr1 to std.\n+\n+\t* include/ext/type_traits.h (__promote, __promote2,\n+\t__promote3, __promote4): Add.\n+\n+\t* include/bits/hashtable.h: New.\n+\t* include/bits/functional_hash.h: Likewise.\n+\t* include/tr1/hashtable.h: Likewise.\n+\n+\t* include/tr1_impl/random: New.\n+\t* include/tr1_impl/cinttypes: Likewise.\n+\t* include/tr1_impl/cstdlib: Likewise.\n+\t* include/tr1_impl/unordered_map: Likewise.\n+\t* include/tr1_impl/cstdio: Likewise.\n+\t* include/tr1_impl/boost_shared_ptr.h: Likewise.\n+\t* include/tr1_impl/cctype: Likewise.\n+\t* include/tr1_impl/random.tcc: Likewise.\n+\t* include/tr1_impl/tuple: Likewise.\n+\t* include/tr1_impl/functional_hash.h: Likewise.\n+\t* include/tr1_impl/hashtable: Likewise.\n+\t* include/tr1_impl/cmath: Likewise.\n+\t* include/tr1_impl/type_traitsfwd.h: Likewise.\n+\t* include/tr1_impl/hashtable_policy.h: Likewise.\n+\t* include/tr1_impl/cfenv: Likewise.\n+\t* include/tr1_impl/unordered_set: Likewise.\n+\t* include/tr1_impl/functional: Likewise.\n+\t* include/tr1_impl/utility: Likewise.\n+\t* include/tr1_impl/complex: Likewise.\n+\t* include/tr1_impl/type_traits: Likewise.\n+\t* include/tr1_impl/cwchar: Likewise.\n+\t* include/tr1_impl/cstdint: Likewise.\n+\t* include/tr1_impl/regex: Likewise.\n+\t* include/tr1_impl/array: Likewise.\n+\t* include/tr1_impl/cwctype: Likewise.\n+\n+\t* include/tr1/type_traitsfwd.h: Remove.\n+\t* include/tr1/boost_shared_ptr.h: Likewise.\n+\t* include/tr1/common.h: Likewise.\n+\t* include/tr1/hashtable: Likewise.\n+\t* include/tr1/hashtable_policy.h: Likewise.\n+\t* include/tr1/random.tcc: Likewise.\n+\n+\t* include/c_global/cinttypes: Include tr1_impl/cinttypes.\n+\t* include/c_global/cstdlib: Likewise for cstdlib.\n+\t* include/c_global/cstdio: Likewise for cstdio.\n+\t* include/c_global/cctype: Likewise for cctype.\n+\t* include/c_global/cmath: Likewise for cmath.\n+\t* include/c_global/cfenv: Likewise for cfenv.\n+\t* include/c_global/cwchar: Likewise for cwchar.\n+\t* include/c_global/cstdint: Likewise for cstdint.\n+\t* include/c_global/cwctype: Likewise for cwctype.\n+\t* include/tr1/cinttypes: Likewise for cinttypes.\n+\t* include/tr1/cstdlib: Likewise for cstdlib.\n+\t* include/tr1/cstdio: Likewise for cstdio.\n+\t* include/tr1/cctype: Likewise for cctype.\n+\t* include/tr1/cmath: Likewise for cmath.\n+\t* include/tr1/cfenv: Likewise for cfenv.\n+\t* include/tr1/cwchar: Likewise for cwchar.\n+\t* include/tr1/cstdint: Likewise for cstdint.\n+\t* include/tr1/cwctype: Likewise for cwctype.\n+\t* include/tr1/functional_hash.h: Likewise for functional_hash.\n+\n+\t* include/std/tuple: Include tr1_impl/tuple.\n+\t* include/std/utility: Likewise for utility.\n+\t* include/std/type_traits: Likewise for type_traits.\n+\t(is_pod): Just forward to __is_pod.\n+\t(has_trivial_default_constructor): Just forward to\n+\t__has_trivial_constructor.\n+\t(has_trivial_copy_constructor): Just forward to __has_trivial_copy.\n+\t(has_trivial_assign): Just forward to __has_trivial_assign.\n+\t(has_trivial_destructor): Just forward to __has_trivial_destructor.\n+\t(has_nothrow_default_constructor): Just forward to\n+\t__has_nothrow_constructor.\n+\t(has_nothrow_copy_constructor): Just forward to __has_nothrow_copy.\n+\t(has_nothrow_assign): Just forward to __has_nothrow_assign.\n+\t(is_base_of): Just forward to __is_base_of.\n+\t(is_signed, is_unsigned): Implement according to the C++0x\n+\tspecifications.\n+\t* include/std/memory: Likewise for memory.\n+\t* include/std/regex: Likewise for regex.\n+\t* include/std/random: Likewise for random.\n+\t* include/std/unordered_map: Likewise for unordered_map.\n+\t* include/std/unordered_set: Likewise for unordered_set.\n+\t* include/std/functional: Likewise for functional.\n+\t* include/std/complex: Likewise for complex.\n+\t* include/std/array: Likewise for array.\n+\t* include/tr1/tuple: Likewise for tuple.\n+\t* include/tr1/utility: Likewise for utility.\n+\t* include/tr1/type_traits: Likewise for type_traits\n+\t* include/tr1/memory: Likewise for memory.\n+\t* include/tr1/regex: Likewise for regex.\n+\t* include/tr1/random: Likewise for random.\n+\t* include/tr1/unordered_map: Likewise for unordered_map.\n+\t* include/tr1/unordered_set: Likewise for unordered_set.\n+\t* include/tr1/functional: Likewise for functional.\n+\t* include/tr1/complex: Likewise for complex.\n+\t* include/tr1/array: Likewise for array.\n+\n+\t* include/c_global/ctgmath: Tweak.\n+\t* include/c_global/cstdarg: Likewise.\n+\t* include/c_global/ctime: Likewise.\n+\t* include/c_global/climits: Likewise.\n+\t* include/c_global/cfloat: Likewise.\t\n+\t* include/c_global/ccomplex: Likewise.\n+\t* include/c_global/cstdbool: Likewise.\n+\n+\t* include/tr1/poly_laguerre.tcc: Tweak, don't use _GLIBCXX_TR1.\n+\t* include/tr1/riemann_zeta.tcc: Likewise.\n+\t* include/tr1/beta_function.tcc: Likewise.\n+\t* include/tr1/exp_integral.tcc: Likewise.\n+\t* include/tr1/hypergeometric.tcc: Likewise.\n+\t* include/tr1/modified_bessel_func.tcc: Likewise.\n+\t* include/tr1/legendre_function.tcc: Likewise.\n+\t* include/tr1/special_function_util.h: Likewise.\n+\t* include/tr1/bessel_function.tcc: Likewise.\n+\t* include/tr1/poly_hermite.tcc: Likewise.\n+\t* include/tr1/ell_integral.tcc: Likewise.\n+\t* include/tr1/gamma.tcc: Likewise.\n+\t* include/tr1/stdlib.h: Likewise.\n+\t* include/tr1/math.h: Likewise.\n+\n+\t* include/tr1/complex.h: Minor tweaks.\n+\t* include/tr1/wctype.h: Likewise.\n+\t* include/tr1/wchar.h: Likewise.\n+\t* include/tr1/inttypes.h: Likewise.\n+\t* include/tr1/tgmath.h: Likewise.\n+\t* include/tr1/cstdbool: Likewise.\n+\t* include/tr1/cfloat: Likewise.\n+\t* include/tr1/ccomplex: Likewise.\n+\t* include/tr1/ctime: Likewise.\n+\t* include/tr1/climits: Likewise.\n+\t* include/tr1/ctgmath: Likewise.\n+\t* include/tr1/cstdarg: Likewise.\n+\n+\t* testsuite/tr1/headers.cc: Move...\n+\t* testsuite/tr1/headers/all.cc: ... here.\n+\t* testsuite/tr1/using_namespace_std_tr1.cc: Move...\n+\t* testsuite/tr1/headers/c++200x/using_namespace_std_tr1.cc: ... here.\n+\t* testsuite/tr1/headers/using_namespace_std_tr1.cc ... here.\n+\t* testsuite/tr1/headers/c++200x/using_namespace_std_tr1.cc: New.\n+\n+\t* testsuite/20_util/tuple/requirements/explicit_instantiation.cc:\n+\tAdjust namespace.\n+\t* testsuite/20_util/has_nothrow_copy_constructor/value.cc: Adjust to\n+\tthe C++0x requirements.\n+\t* testsuite/20_util/has_nothrow_default_constructor/value.cc: Likewise.\n+\t* testsuite/20_util/has_trivial_copy_constructor/value.cc: Likewise.\n+\t* testsuite/20_util/has_trivial_default_constructor/value.cc: Likewise.\n+\n+\t* testsuite/20_util/make_signed/requirements/typedefs_neg.cc: Adjust\n+\tdg-error lines.\n+\t* testsuite/20_util/make_unsigned/requirements/typedefs_neg.cc:\n+\tLikewise.\n+\t* testsuite/20_util/headers/type_traits/types_std_c++0x_neg.cc:\n+\tUn-xfail.\n+\n+\t* testsuite/20_util/is_signed/value.cc: New.\n+\t* testsuite/20_util/is_signed/requirements/typedefs.cc: Likewise.\n+\t* testsuite/20_util/is_signed/requirements/explicit_instantiation.cc:\n+\tLikewise.\n+\t* testsuite/20_util/is_unsigned/value.cc: Likewise..\n+\t* testsuite/20_util/is_unsigned/requirements/typedefs.cc: Likewise.\n+\t* testsuite/20_util/is_unsigned/requirements/explicit_instantiation.cc:\n+\tLikewise.\n+\n+\t* include/Makefile.am: Adjust.\t\n+\t* include/Makefile.in: Regenerate.\n+\n 2007-05-31  Paolo Carlini  <pcarlini@suse.de>\n \n \tPR c++/32158 (libstdc++ bits)"}, {"sha": "406b3130755a62f09e558f291e6f841782b30024", "filename": "libstdc++-v3/include/Makefile.am", "status": "modified", "additions": 49, "deletions": 8, "changes": 57, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e133ace8d907bf42754c86106fc3f04a9d9fe70f/libstdc%2B%2B-v3%2Finclude%2FMakefile.am", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e133ace8d907bf42754c86106fc3f04a9d9fe70f/libstdc%2B%2B-v3%2Finclude%2FMakefile.am", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2FMakefile.am?ref=e133ace8d907bf42754c86106fc3f04a9d9fe70f", "patch": "@@ -82,8 +82,10 @@ bits_headers = \\\n \t${bits_srcdir}/deque.tcc \\\n \t${bits_srcdir}/fstream.tcc \\\n \t${bits_srcdir}/functexcept.h \\\n+\t${bits_srcdir}/functional_hash.h \\\n \t${bits_srcdir}/gslice.h \\\n \t${bits_srcdir}/gslice_array.h \\\n+\t${bits_srcdir}/hashtable.h \\\n \t${bits_srcdir}/indirect_array.h \\\n \t${bits_srcdir}/ios_base.h \\\n \t${bits_srcdir}/istream.tcc \\\n@@ -540,15 +542,13 @@ tr1_headers = \\\n \t${tr1_srcdir}/array \\\n \t${tr1_srcdir}/bessel_function.tcc \\\n \t${tr1_srcdir}/beta_function.tcc \\\n-\t${tr1_srcdir}/boost_shared_ptr.h \\\n \t${tr1_srcdir}/ccomplex \\\n \t${tr1_srcdir}/cctype \\\n \t${tr1_srcdir}/cfenv \\\n \t${tr1_srcdir}/cfloat \\\n \t${tr1_srcdir}/cinttypes \\\n \t${tr1_srcdir}/climits \\\n \t${tr1_srcdir}/cmath \\\n-\t${tr1_srcdir}/common.h \\\n \t${tr1_srcdir}/complex \\\n \t${tr1_srcdir}/complex.h \\\n \t${tr1_srcdir}/cstdarg \\\n@@ -568,9 +568,8 @@ tr1_headers = \\\n \t${tr1_srcdir}/functional \\\n \t${tr1_srcdir}/functional_hash.h \\\n \t${tr1_srcdir}/gamma.tcc \\\n-\t${tr1_srcdir}/hashtable \\\n \t${tr1_srcdir}/hypergeometric.tcc \\\n-\t${tr1_srcdir}/hashtable_policy.h \\\n+\t${tr1_srcdir}/hashtable.h \\\n \t${tr1_srcdir}/inttypes.h \\\n \t${tr1_srcdir}/limits.h \\\n \t${tr1_srcdir}/math.h \\\n@@ -580,7 +579,6 @@ tr1_headers = \\\n \t${tr1_srcdir}/poly_laguerre.tcc \\\n \t${tr1_srcdir}/legendre_function.tcc \\\n \t${tr1_srcdir}/random \\\n-\t${tr1_srcdir}/random.tcc \\\n \t${tr1_srcdir}/regex \\\n \t${tr1_srcdir}/riemann_zeta.tcc \\\n \t${tr1_srcdir}/special_function_util.h \\\n@@ -592,14 +590,43 @@ tr1_headers = \\\n \t${tr1_srcdir}/tgmath.h \\\n \t${tr1_srcdir}/tuple \\\n \t${tr1_srcdir}/type_traits \\\n-\t${tr1_srcdir}/type_traitsfwd.h \\\n \t${tr1_srcdir}/unordered_set \\\n \t${tr1_srcdir}/unordered_map \\\n \t${tr1_srcdir}/utility \\\n \t${tr1_srcdir}/wchar.h \\\n \t${tr1_srcdir}/wctype.h\n \n \n+tr1_impl_srcdir = ${glibcxx_srcdir}/include/tr1_impl\n+tr1_impl_builddir = ./tr1_impl\n+tr1_impl_headers = \\\n+\t${tr1_impl_srcdir}/array \\\n+\t${tr1_impl_srcdir}/boost_shared_ptr.h \\\n+\t${tr1_impl_srcdir}/cctype \\\n+\t${tr1_impl_srcdir}/cfenv \\\n+\t${tr1_impl_srcdir}/cinttypes \\\n+\t${tr1_impl_srcdir}/cmath \\\n+\t${tr1_impl_srcdir}/complex \\\n+\t${tr1_impl_srcdir}/cstdint \\\n+\t${tr1_impl_srcdir}/cstdio \\\n+\t${tr1_impl_srcdir}/cstdlib \\\n+\t${tr1_impl_srcdir}/cwchar \\\n+\t${tr1_impl_srcdir}/cwctype \\\n+\t${tr1_impl_srcdir}/functional \\\n+\t${tr1_impl_srcdir}/functional_hash.h \\\n+\t${tr1_impl_srcdir}/hashtable \\\n+\t${tr1_impl_srcdir}/hashtable_policy.h \\\n+\t${tr1_impl_srcdir}/random \\\n+\t${tr1_impl_srcdir}/random.tcc \\\n+\t${tr1_impl_srcdir}/regex \\\n+\t${tr1_impl_srcdir}/tuple \\\n+\t${tr1_impl_srcdir}/type_traits \\\n+\t${tr1_impl_srcdir}/type_traitsfwd.h \\\n+\t${tr1_impl_srcdir}/unordered_map \\\n+\t${tr1_impl_srcdir}/unordered_set \\\n+\t${tr1_impl_srcdir}/utility\n+\n+\n # This is the common subset of C++ files that all three \"C\" header models use.\n c_base_srcdir = $(C_INCLUDE_DIR)\n c_base_builddir = .\n@@ -793,7 +820,7 @@ endif\n allstamped = \\\n \tstamp-std stamp-bits stamp-c_base stamp-c_base_extra \\\n \tstamp-c_compatibility  stamp-backward stamp-ext stamp-pb \\\n-\tstamp-tr1 stamp-debug stamp-host\n+\tstamp-tr1 stamp-tr1-impl stamp-debug stamp-host\n \n # List of all files that are created by explicit building, editing, or\n # catenation.\n@@ -932,6 +959,15 @@ stamp-tr1: ${tr1_headers}\n \tfi ;\\\n \t$(STAMP) stamp-tr1\n \n+stamp-tr1-impl: ${tr1_impl_headers}\n+\t@if [ ! -d \"${tr1_impl_builddir}\" ]; then \\\n+\t    mkdir -p ${tr1_impl_builddir} ;\\\n+\tfi ;\\\n+\tif [ ! -f stamp-tr1-impl ]; then \\\n+\t  (cd ${tr1_impl_builddir} && $(LN_S) $? . || true) ;\\\n+\tfi ;\\\n+\t$(STAMP) stamp-tr1-impl\n+\n stamp-debug: ${debug_headers}\n \t@if [ ! -d \"${debug_builddir}\" ]; then \\\n \t  mkdir -p ${debug_builddir} ;\\\n@@ -1158,6 +1194,9 @@ install-headers:\n \t$(mkinstalldirs) $(DESTDIR)${gxx_include_dir}/${tr1_builddir}\n \tfor file in ${tr1_headers}; do \\\n \t  $(INSTALL_DATA) $${file} $(DESTDIR)${gxx_include_dir}/${tr1_builddir}; done\n+\t$(mkinstalldirs) $(DESTDIR)${gxx_include_dir}/${tr1_impl_builddir}\n+\tfor file in ${tr1_impl_headers}; do \\\n+\t  $(INSTALL_DATA) $${file} $(DESTDIR)${gxx_include_dir}/${tr1_impl_builddir}; done\n \t$(mkinstalldirs) $(DESTDIR)${gxx_include_dir}/${c_base_builddir}\n \tfor file in ${c_base_headers}; do \\\n \t  $(INSTALL_DATA) $${file} $(DESTDIR)${gxx_include_dir}/${c_base_builddir}; done\n@@ -1200,8 +1239,10 @@ clean-local:\n # developer tries to create them via make in the include build\n # directory. (This is more of an example of how this kind of rule can\n # be made.)\n-.PRECIOUS: $(std_headers) $(c_base_headers) $(tr1_headers) $(ext_headers)\n+.PRECIOUS: $(std_headers) $(c_base_headers) $(tr1_headers) $(tr1_impl_headers)\n+\t   $(ext_headers)\n $(std_headers): ; @:\n $(c_base_headers): ; @:\n $(tr1_headers): ; @:\n+$(tr1_impl_headers): ; @:\n $(ext_headers): ; @:"}, {"sha": "bffba8da26109b9b6c4813e23039681aa8751d7b", "filename": "libstdc++-v3/include/Makefile.in", "status": "modified", "additions": 48, "deletions": 8, "changes": 56, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e133ace8d907bf42754c86106fc3f04a9d9fe70f/libstdc%2B%2B-v3%2Finclude%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e133ace8d907bf42754c86106fc3f04a9d9fe70f/libstdc%2B%2B-v3%2Finclude%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2FMakefile.in?ref=e133ace8d907bf42754c86106fc3f04a9d9fe70f", "patch": "@@ -327,8 +327,10 @@ bits_headers = \\\n \t${bits_srcdir}/deque.tcc \\\n \t${bits_srcdir}/fstream.tcc \\\n \t${bits_srcdir}/functexcept.h \\\n+\t${bits_srcdir}/functional_hash.h \\\n \t${bits_srcdir}/gslice.h \\\n \t${bits_srcdir}/gslice_array.h \\\n+\t${bits_srcdir}/hashtable.h \\\n \t${bits_srcdir}/indirect_array.h \\\n \t${bits_srcdir}/ios_base.h \\\n \t${bits_srcdir}/istream.tcc \\\n@@ -781,15 +783,13 @@ tr1_headers = \\\n \t${tr1_srcdir}/array \\\n \t${tr1_srcdir}/bessel_function.tcc \\\n \t${tr1_srcdir}/beta_function.tcc \\\n-\t${tr1_srcdir}/boost_shared_ptr.h \\\n \t${tr1_srcdir}/ccomplex \\\n \t${tr1_srcdir}/cctype \\\n \t${tr1_srcdir}/cfenv \\\n \t${tr1_srcdir}/cfloat \\\n \t${tr1_srcdir}/cinttypes \\\n \t${tr1_srcdir}/climits \\\n \t${tr1_srcdir}/cmath \\\n-\t${tr1_srcdir}/common.h \\\n \t${tr1_srcdir}/complex \\\n \t${tr1_srcdir}/complex.h \\\n \t${tr1_srcdir}/cstdarg \\\n@@ -809,9 +809,8 @@ tr1_headers = \\\n \t${tr1_srcdir}/functional \\\n \t${tr1_srcdir}/functional_hash.h \\\n \t${tr1_srcdir}/gamma.tcc \\\n-\t${tr1_srcdir}/hashtable \\\n \t${tr1_srcdir}/hypergeometric.tcc \\\n-\t${tr1_srcdir}/hashtable_policy.h \\\n+\t${tr1_srcdir}/hashtable.h \\\n \t${tr1_srcdir}/inttypes.h \\\n \t${tr1_srcdir}/limits.h \\\n \t${tr1_srcdir}/math.h \\\n@@ -821,7 +820,6 @@ tr1_headers = \\\n \t${tr1_srcdir}/poly_laguerre.tcc \\\n \t${tr1_srcdir}/legendre_function.tcc \\\n \t${tr1_srcdir}/random \\\n-\t${tr1_srcdir}/random.tcc \\\n \t${tr1_srcdir}/regex \\\n \t${tr1_srcdir}/riemann_zeta.tcc \\\n \t${tr1_srcdir}/special_function_util.h \\\n@@ -833,13 +831,41 @@ tr1_headers = \\\n \t${tr1_srcdir}/tgmath.h \\\n \t${tr1_srcdir}/tuple \\\n \t${tr1_srcdir}/type_traits \\\n-\t${tr1_srcdir}/type_traitsfwd.h \\\n \t${tr1_srcdir}/unordered_set \\\n \t${tr1_srcdir}/unordered_map \\\n \t${tr1_srcdir}/utility \\\n \t${tr1_srcdir}/wchar.h \\\n \t${tr1_srcdir}/wctype.h\n \n+tr1_impl_srcdir = ${glibcxx_srcdir}/include/tr1_impl\n+tr1_impl_builddir = ./tr1_impl\n+tr1_impl_headers = \\\n+\t${tr1_impl_srcdir}/array \\\n+\t${tr1_impl_srcdir}/boost_shared_ptr.h \\\n+\t${tr1_impl_srcdir}/cctype \\\n+\t${tr1_impl_srcdir}/cfenv \\\n+\t${tr1_impl_srcdir}/cinttypes \\\n+\t${tr1_impl_srcdir}/cmath \\\n+\t${tr1_impl_srcdir}/complex \\\n+\t${tr1_impl_srcdir}/cstdint \\\n+\t${tr1_impl_srcdir}/cstdio \\\n+\t${tr1_impl_srcdir}/cstdlib \\\n+\t${tr1_impl_srcdir}/cwchar \\\n+\t${tr1_impl_srcdir}/cwctype \\\n+\t${tr1_impl_srcdir}/functional \\\n+\t${tr1_impl_srcdir}/functional_hash.h \\\n+\t${tr1_impl_srcdir}/hashtable \\\n+\t${tr1_impl_srcdir}/hashtable_policy.h \\\n+\t${tr1_impl_srcdir}/random \\\n+\t${tr1_impl_srcdir}/random.tcc \\\n+\t${tr1_impl_srcdir}/regex \\\n+\t${tr1_impl_srcdir}/tuple \\\n+\t${tr1_impl_srcdir}/type_traits \\\n+\t${tr1_impl_srcdir}/type_traitsfwd.h \\\n+\t${tr1_impl_srcdir}/unordered_map \\\n+\t${tr1_impl_srcdir}/unordered_set \\\n+\t${tr1_impl_srcdir}/utility\n+\n \n # This is the common subset of C++ files that all three \"C\" header models use.\n c_base_srcdir = $(C_INCLUDE_DIR)\n@@ -1017,7 +1043,7 @@ PCHFLAGS = -Winvalid-pch -Wno-deprecated -x c++-header $(CXXFLAGS)\n allstamped = \\\n \tstamp-std stamp-bits stamp-c_base stamp-c_base_extra \\\n \tstamp-c_compatibility  stamp-backward stamp-ext stamp-pb \\\n-\tstamp-tr1 stamp-debug stamp-host\n+\tstamp-tr1 stamp-tr1-impl stamp-debug stamp-host\n \n \n # List of all files that are created by explicit building, editing, or\n@@ -1326,6 +1352,15 @@ stamp-tr1: ${tr1_headers}\n \tfi ;\\\n \t$(STAMP) stamp-tr1\n \n+stamp-tr1-impl: ${tr1_impl_headers}\n+\t@if [ ! -d \"${tr1_impl_builddir}\" ]; then \\\n+\t    mkdir -p ${tr1_impl_builddir} ;\\\n+\tfi ;\\\n+\tif [ ! -f stamp-tr1-impl ]; then \\\n+\t  (cd ${tr1_impl_builddir} && $(LN_S) $? . || true) ;\\\n+\tfi ;\\\n+\t$(STAMP) stamp-tr1-impl\n+\n stamp-debug: ${debug_headers}\n \t@if [ ! -d \"${debug_builddir}\" ]; then \\\n \t  mkdir -p ${debug_builddir} ;\\\n@@ -1540,6 +1575,9 @@ install-headers:\n \t$(mkinstalldirs) $(DESTDIR)${gxx_include_dir}/${tr1_builddir}\n \tfor file in ${tr1_headers}; do \\\n \t  $(INSTALL_DATA) $${file} $(DESTDIR)${gxx_include_dir}/${tr1_builddir}; done\n+\t$(mkinstalldirs) $(DESTDIR)${gxx_include_dir}/${tr1_impl_builddir}\n+\tfor file in ${tr1_impl_headers}; do \\\n+\t  $(INSTALL_DATA) $${file} $(DESTDIR)${gxx_include_dir}/${tr1_impl_builddir}; done\n \t$(mkinstalldirs) $(DESTDIR)${gxx_include_dir}/${c_base_builddir}\n \tfor file in ${c_base_headers}; do \\\n \t  $(INSTALL_DATA) $${file} $(DESTDIR)${gxx_include_dir}/${c_base_builddir}; done\n@@ -1579,10 +1617,12 @@ clean-local:\n # developer tries to create them via make in the include build\n # directory. (This is more of an example of how this kind of rule can\n # be made.)\n-.PRECIOUS: $(std_headers) $(c_base_headers) $(tr1_headers) $(ext_headers)\n+.PRECIOUS: $(std_headers) $(c_base_headers) $(tr1_headers) $(tr1_impl_headers)\n+\t   $(ext_headers)\n $(std_headers): ; @:\n $(c_base_headers): ; @:\n $(tr1_headers): ; @:\n+$(tr1_impl_headers): ; @:\n $(ext_headers): ; @:\n # Tell versions [3.59,3.63) of GNU make to not export all variables.\n # Otherwise a system limit (for SysV at least) may be exceeded."}, {"sha": "a51901821ac61ff22cf54099d08c24062e30466b", "filename": "libstdc++-v3/include/bits/c++config", "status": "modified", "additions": 0, "deletions": 16, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e133ace8d907bf42754c86106fc3f04a9d9fe70f/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fc%2B%2Bconfig", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e133ace8d907bf42754c86106fc3f04a9d9fe70f/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fc%2B%2Bconfig", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fc%2B%2Bconfig?ref=e133ace8d907bf42754c86106fc3f04a9d9fe70f", "patch": "@@ -71,10 +71,6 @@\n # define _GLIBCXX_NAMESPACE_ASSOCIATION_DEBUG 1\n #endif\n \n-#ifdef __GXX_EXPERIMENTAL_CXX0X__\n-# define _GLIBCXX_NAMESPACE_ASSOCIATION_CXX0X 1\n-#endif\n-\n #define _GLIBCXX_NAMESPACE_ASSOCIATION_VERSION \n \n // Macros for namespace scope.\n@@ -155,18 +151,6 @@ namespace __gnu_cxx\n #endif\n #endif\n \n-// Namespace associations for C++0x, TR1 in std.\n-#if _GLIBCXX_NAMESPACE_ASSOCIATION_CXX0X\n-namespace std\n-{ \n-  namespace __cxx200x { }\n-  using namespace __cxx200x __attribute__ ((strong)); \n-}\n-# define _GLIBCXX_TR1 __cxx200x\n-#else\n-# define _GLIBCXX_TR1 tr1\n-#endif\n-\n // Define if compatibility should be provided for -mlong-double-64.\n #undef _GLIBCXX_LONG_DOUBLE_COMPAT\n "}, {"sha": "022c5caf4cc612c8ca1c563c9ce34990a6d9a6bb", "filename": "libstdc++-v3/include/bits/functional_hash.h", "status": "added", "additions": 63, "deletions": 0, "changes": 63, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e133ace8d907bf42754c86106fc3f04a9d9fe70f/libstdc%2B%2B-v3%2Finclude%2Fbits%2Ffunctional_hash.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e133ace8d907bf42754c86106fc3f04a9d9fe70f/libstdc%2B%2B-v3%2Finclude%2Fbits%2Ffunctional_hash.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Ffunctional_hash.h?ref=e133ace8d907bf42754c86106fc3f04a9d9fe70f", "patch": "@@ -0,0 +1,63 @@\n+// functional_hash.h header -*- C++ -*-\n+\n+// Copyright (C) 2007 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License\n+// along with this library; see the file COPYING.  If not, write to\n+// the Free Software Foundation, 51 Franklin Street, Fifth Floor,\n+// Boston, MA 02110-1301, USA.\n+\n+// As a special exception, you may use this file as part of a free software\n+// library without restriction.  Specifically, if other files instantiate\n+// templates or use macros or inline functions from this file, or you compile\n+// this file and link it with other files to produce an executable, this\n+// file does not by itself cause the resulting executable to be covered by\n+// the GNU General Public License.  This exception does not however\n+// invalidate any other reasons why the executable file might be covered by\n+// the GNU General Public License.\n+\n+/** @file functional_hash.h\n+ *  This is an internal header file, included by other library headers.\n+ *  You should not attempt to use it directly.\n+ */\n+\n+#ifndef _FUNCTIONAL_HASH_H\n+#define _FUNCTIONAL_HASH_H 1\n+\n+#pragma GCC system_header\n+\n+#ifndef __GXX_EXPERIMENTAL_CXX0X__\n+# include <c++0x_warning.h>\n+#endif\n+\n+#if defined(_GLIBCXX_INCLUDE_AS_TR1)\n+#  error C++0x header cannot be included from TR1 header\n+#endif\n+\n+#if defined(_GLIBCXX_INCLUDE_AS_CXX0X)\n+#  include <tr1_impl/functional_hash.h>\n+#else\n+#  define _GLIBCXX_INCLUDE_AS_CXX0X\n+#  define _GLIBCXX_BEGIN_NAMESPACE_TR1\n+#  define _GLIBCXX_END_NAMESPACE_TR1\n+#  define _GLIBCXX_TR1\n+#  include <tr1_impl/functional_hash.h>\n+#  undef _GLIBCXX_TR1\n+#  undef _GLIBCXX_END_NAMESPACE_TR1\n+#  undef _GLIBCXX_BEGIN_NAMESPACE_TR1\n+#  undef _GLIBCXX_INCLUDE_AS_CXX0X\n+#endif\n+\n+#endif // _FUNCTIONAL_HASH_H\n+"}, {"sha": "d1da5fdde21cba461e6c87364436888652a5dc41", "filename": "libstdc++-v3/include/bits/hashtable.h", "status": "added", "additions": 63, "deletions": 0, "changes": 63, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e133ace8d907bf42754c86106fc3f04a9d9fe70f/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fhashtable.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e133ace8d907bf42754c86106fc3f04a9d9fe70f/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fhashtable.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fhashtable.h?ref=e133ace8d907bf42754c86106fc3f04a9d9fe70f", "patch": "@@ -0,0 +1,63 @@\n+// hashtable.h header -*- C++ -*-\n+\n+// Copyright (C) 2007 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License\n+// along with this library; see the file COPYING.  If not, write to\n+// the Free Software Foundation, 51 Franklin Street, Fifth Floor,\n+// Boston, MA 02110-1301, USA.\n+\n+// As a special exception, you may use this file as part of a free software\n+// library without restriction.  Specifically, if other files instantiate\n+// templates or use macros or inline functions from this file, or you compile\n+// this file and link it with other files to produce an executable, this\n+// file does not by itself cause the resulting executable to be covered by\n+// the GNU General Public License.  This exception does not however\n+// invalidate any other reasons why the executable file might be covered by\n+// the GNU General Public License.\n+\n+/** @file hashtable.h\n+ *  This is an internal header file, included by other library headers.\n+ *  You should not attempt to use it directly.\n+ */\n+\n+#ifndef _HASHTABLE_H\n+#define _HASHTABLE_H 1\n+\n+#pragma GCC system_header\n+\n+#ifndef __GXX_EXPERIMENTAL_CXX0X__\n+# include <c++0x_warning.h>\n+#endif\n+\n+#if defined(_GLIBCXX_INCLUDE_AS_TR1)\n+#  error C++0x header cannot be included from TR1 header\n+#endif\n+\n+#if defined(_GLIBCXX_INCLUDE_AS_CXX0X)\n+#  include <tr1_impl/hashtable>\n+#else\n+#  define _GLIBCXX_INCLUDE_AS_CXX0X\n+#  define _GLIBCXX_BEGIN_NAMESPACE_TR1\n+#  define _GLIBCXX_END_NAMESPACE_TR1\n+#  define _GLIBCXX_TR1\n+#  include <tr1_impl/hashtable>\n+#  undef _GLIBCXX_TR1\n+#  undef _GLIBCXX_END_NAMESPACE_TR1\n+#  undef _GLIBCXX_END_NAMESPACE_TR1\n+#  undef _GLIBCXX_INCLUDE_AS_CXX0X\n+#endif\n+\n+#endif // _HASHTABLE_H\n+"}, {"sha": "bd37e223d0dbd81179e87cfd4a17488971bd5f11", "filename": "libstdc++-v3/include/c_global/ccomplex", "status": "modified", "additions": 7, "deletions": 4, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e133ace8d907bf42754c86106fc3f04a9d9fe70f/libstdc%2B%2B-v3%2Finclude%2Fc_global%2Fccomplex", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e133ace8d907bf42754c86106fc3f04a9d9fe70f/libstdc%2B%2B-v3%2Finclude%2Fc_global%2Fccomplex", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fc_global%2Fccomplex?ref=e133ace8d907bf42754c86106fc3f04a9d9fe70f", "patch": "@@ -36,11 +36,14 @@\n #ifndef _GLIBCXX_CCOMPLEX\n #define _GLIBCXX_CCOMPLEX 1\n \n-#ifdef __GXX_EXPERIMENTAL_CXX0X__\n-# include <tr1/ccomplex>\n-#else\n+#ifndef __GXX_EXPERIMENTAL_CXX0X__\n # include <c++0x_warning.h>\n #endif\n \n-#endif \n+#if defined(_GLIBCXX_INCLUDE_AS_TR1)\n+#  error C++0x header cannot be included from TR1 header\n+#endif\n+\n+#include <complex>\n \n+#endif"}, {"sha": "440245ec39fc236842e1c38ddb8d6498e5e49369", "filename": "libstdc++-v3/include/c_global/cctype", "status": "modified", "additions": 18, "deletions": 2, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e133ace8d907bf42754c86106fc3f04a9d9fe70f/libstdc%2B%2B-v3%2Finclude%2Fc_global%2Fcctype", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e133ace8d907bf42754c86106fc3f04a9d9fe70f/libstdc%2B%2B-v3%2Finclude%2Fc_global%2Fcctype", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fc_global%2Fcctype?ref=e133ace8d907bf42754c86106fc3f04a9d9fe70f", "patch": "@@ -1,6 +1,7 @@\n // -*- C++ -*- forwarding header.\n \n-// Copyright (C) 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006\n+// Copyright (C) 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005,\n+// 2006, 2007\n // Free Software Foundation, Inc.\n //\n // This file is part of the GNU ISO C++ Library.  This library is free\n@@ -84,7 +85,22 @@ _GLIBCXX_BEGIN_NAMESPACE(std)\n _GLIBCXX_END_NAMESPACE\n \n #ifdef __GXX_EXPERIMENTAL_CXX0X__\n-# include <tr1/cctype>\n+#  if defined(_GLIBCXX_INCLUDE_AS_TR1)\n+#    error C++0x header cannot be included from TR1 header\n+#  endif\n+#  if defined(_GLIBCXX_INCLUDE_AS_CXX0X)\n+#    include <tr1_impl/cctype>\n+#  else\n+#    define _GLIBCXX_INCLUDE_AS_CXX0X\n+#    define _GLIBCXX_BEGIN_NAMESPACE_TR1\n+#    define _GLIBCXX_END_NAMESPACE_TR1\n+#    define _GLIBCXX_TR1\n+#    include <tr1_impl/cctype>\n+#    undef _GLIBCXX_TR1\n+#    undef _GLIBCXX_END_NAMESPACE_TR1\n+#    undef _GLIBCXX_BEGIN_NAMESPACE_TR1\n+#    undef _GLIBCXX_INCLUDE_AS_CXX0X\n+#  endif\n #endif\n \n #endif"}, {"sha": "de72ed43ace36c196a2101164a6349829f5cc2d2", "filename": "libstdc++-v3/include/c_global/cfenv", "status": "modified", "additions": 21, "deletions": 4, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e133ace8d907bf42754c86106fc3f04a9d9fe70f/libstdc%2B%2B-v3%2Finclude%2Fc_global%2Fcfenv", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e133ace8d907bf42754c86106fc3f04a9d9fe70f/libstdc%2B%2B-v3%2Finclude%2Fc_global%2Fcfenv", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fc_global%2Fcfenv?ref=e133ace8d907bf42754c86106fc3f04a9d9fe70f", "patch": "@@ -36,11 +36,28 @@\n #ifndef _GLIBCXX_CFENV\n #define _GLIBCXX_CFENV 1\n \n-#ifdef __GXX_EXPERIMENTAL_CXX0X__\n-# include <tr1/cfenv>\n-#else\n+#ifndef __GXX_EXPERIMENTAL_CXX0X__\n # include <c++0x_warning.h>\n #endif\n \n-#endif \n+#if defined(_GLIBCXX_INCLUDE_AS_TR1)\n+#  error C++0x header cannot be included from TR1 header\n+#endif\n+\n+#include <bits/c++config.h>\n \n+#if defined(_GLIBCXX_INCLUDE_AS_CXX0X)\n+#  include <tr1_impl/cfenv>\n+#else\n+#  define _GLIBCXX_INCLUDE_AS_CXX0X\n+#  define _GLIBCXX_BEGIN_NAMESPACE_TR1\n+#  define _GLIBCXX_END_NAMESPACE_TR1\n+#  define _GLIBCXX_TR1\n+#  include <tr1_impl/cfenv>\n+#  undef _GLIBCXX_TR1\n+#  undef _GLIBCXX_END_NAMESPACE_TR1\n+#  undef _GLIBCXX_BEGIN_NAMESPACE_TR1\n+#  undef _GLIBCXX_INCLUDE_AS_CXX0X\n+#endif\n+\n+#endif"}, {"sha": "a3edc2acd73bef2b125e76761154309af805cc9f", "filename": "libstdc++-v3/include/c_global/cfloat", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e133ace8d907bf42754c86106fc3f04a9d9fe70f/libstdc%2B%2B-v3%2Finclude%2Fc_global%2Fcfloat", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e133ace8d907bf42754c86106fc3f04a9d9fe70f/libstdc%2B%2B-v3%2Finclude%2Fc_global%2Fcfloat", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fc_global%2Fcfloat?ref=e133ace8d907bf42754c86106fc3f04a9d9fe70f", "patch": "@@ -50,7 +50,15 @@\n #define _GLIBCXX_CFLOAT 1\n \n #ifdef __GXX_EXPERIMENTAL_CXX0X__\n-# include <tr1/cfloat>\n+#  if defined(_GLIBCXX_INCLUDE_AS_TR1)\n+#    error C++0x header cannot be included from TR1 header\n+#  endif\n+#  ifndef DECIMAL_DIG\n+#    define DECIMAL_DIG __DECIMAL_DIG__\n+#  endif\n+#  ifndef FLT_EVAL_METHOD\n+#    define FLT_EVAL_METHOD __FLT_EVAL_METHOD__\n+#  endif\n #endif\n \n #endif"}, {"sha": "8caceafb48bb39a462234849563dcc9a6603b3e1", "filename": "libstdc++-v3/include/c_global/cinttypes", "status": "modified", "additions": 21, "deletions": 4, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e133ace8d907bf42754c86106fc3f04a9d9fe70f/libstdc%2B%2B-v3%2Finclude%2Fc_global%2Fcinttypes", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e133ace8d907bf42754c86106fc3f04a9d9fe70f/libstdc%2B%2B-v3%2Finclude%2Fc_global%2Fcinttypes", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fc_global%2Fcinttypes?ref=e133ace8d907bf42754c86106fc3f04a9d9fe70f", "patch": "@@ -36,11 +36,28 @@\n #ifndef _GLIBCXX_CINTTYPES\n #define _GLIBCXX_CINTTYPES 1\n \n-#ifdef __GXX_EXPERIMENTAL_CXX0X__\n-# include <tr1/cinttypes>\n-#else\n+#ifndef __GXX_EXPERIMENTAL_CXX0X__\n # include <c++0x_warning.h>\n #endif\n \n-#endif \n+#if defined(_GLIBCXX_INCLUDE_AS_TR1)\n+#  error C++0x header cannot be included from TR1 header\n+#endif\n+\n+#include <cstdint>\n \n+#if defined(_GLIBCXX_INCLUDE_AS_CXX0X)\n+#  include <tr1_impl/cinttypes>\n+#else\n+#  define _GLIBCXX_INCLUDE_AS_CXX0X\n+#  define _GLIBCXX_BEGIN_NAMESPACE_TR1\n+#  define _GLIBCXX_END_NAMESPACE_TR1\n+#  define _GLIBCXX_TR1\n+#  include <tr1_impl/cinttypes>\n+#  undef _GLIBCXX_TR1\n+#  undef _GLIBCXX_END_NAMESPACE_TR1\n+#  undef _GLIBCXX_BEGIN_NAMESPACE_TR1\n+#  undef _GLIBCXX_INCLUDE_AS_CXX0X\n+#endif\n+\n+#endif"}, {"sha": "910c80a444fdb4acabbef14d6075941788e0ed43", "filename": "libstdc++-v3/include/c_global/climits", "status": "modified", "additions": 12, "deletions": 3, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e133ace8d907bf42754c86106fc3f04a9d9fe70f/libstdc%2B%2B-v3%2Finclude%2Fc_global%2Fclimits", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e133ace8d907bf42754c86106fc3f04a9d9fe70f/libstdc%2B%2B-v3%2Finclude%2Fc_global%2Fclimits", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fc_global%2Fclimits?ref=e133ace8d907bf42754c86106fc3f04a9d9fe70f", "patch": "@@ -1,6 +1,7 @@\n // -*- C++ -*- forwarding header.\n \n-// Copyright (C) 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006\n+// Copyright (C) 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005,\n+// 2006, 2007\n // Free Software Foundation, Inc.\n //\n // This file is part of the GNU ISO C++ Library.  This library is free\n@@ -49,8 +50,16 @@\n #ifndef _GLIBCXX_CLIMITS\n #define _GLIBCXX_CLIMITS 1\n \n-#ifdef __GXX_EXPERIMENTAL_CXX0X__\n-# include <tr1/climits>\n+#ifndef LLONG_MIN\n+#define LLONG_MIN -__LONG_LONG_MAX__ - 1\n+#endif\n+\n+#ifndef LLONG_MAX\n+#define LLONG_MAX __LONG_LONG_MAX__\n+#endif\n+\n+#ifndef ULLONG_MAX\n+#define ULLONG_MAX __LONG_LONG_MAX__ * 2ULL + 1\n #endif\n \n #endif"}, {"sha": "dde0154df7b5a6dc73f32b4838bce326663448be", "filename": "libstdc++-v3/include/c_global/cmath", "status": "modified", "additions": 48, "deletions": 20, "changes": 68, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e133ace8d907bf42754c86106fc3f04a9d9fe70f/libstdc%2B%2B-v3%2Finclude%2Fc_global%2Fcmath", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e133ace8d907bf42754c86106fc3f04a9d9fe70f/libstdc%2B%2B-v3%2Finclude%2Fc_global%2Fcmath", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fc_global%2Fcmath?ref=e133ace8d907bf42754c86106fc3f04a9d9fe70f", "patch": "@@ -1,6 +1,7 @@\n // -*- C++ -*- C forwarding header.\n \n-// Copyright (C) 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006\n+// Copyright (C) 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005,\n+// 2006, 2007\n // Free Software Foundation, Inc.\n //\n // This file is part of the GNU ISO C++ Library.  This library is free\n@@ -82,7 +83,17 @@ _GLIBCXX_BEGIN_NAMESPACE(std)\n \n   // Forward declaration of a helper function.  This really should be\n   // an `exported' forward declaration.\n-  template<typename _Tp> _Tp __cmath_power(_Tp, unsigned int);\n+  template<typename _Tp>\n+    _Tp __cmath_power(_Tp, unsigned int);\n+\n+  template<typename _Tp>\n+    inline _Tp\n+    __pow_helper(_Tp __x, int __n)\n+    {\n+      return __n < 0\n+        ? _Tp(1)/__cmath_power(__x, -__n)\n+        : __cmath_power(__x, __n);\n+    }\n \n   inline double\n   abs(double __x)\n@@ -123,8 +134,8 @@ _GLIBCXX_BEGIN_NAMESPACE(std)\n   { return __builtin_asinl(__x); }\n \n   template<typename _Tp>\n-  inline typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,\n-\t\t\t\t\t double>::__type\n+    inline typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,\n+\t\t\t\t\t   double>::__type\n     asin(_Tp __x)\n     { return __builtin_asin(__x); }\n \n@@ -139,8 +150,8 @@ _GLIBCXX_BEGIN_NAMESPACE(std)\n   { return __builtin_atanl(__x); }\n \n   template<typename _Tp>\n-  inline typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value, \n-\t\t\t\t\t double>::__type\n+    inline typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value, \n+\t\t\t\t\t   double>::__type\n     atan(_Tp __x)\n     { return __builtin_atan(__x); }\n \n@@ -155,11 +166,12 @@ _GLIBCXX_BEGIN_NAMESPACE(std)\n   { return __builtin_atan2l(__y, __x); }\n \n   template<typename _Tp, typename _Up>\n-    inline typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value\n-    \t\t\t\t\t   && __is_integer<_Up>::__value, \n-\t\t\t\t\t   double>::__type\n+    inline typename __gnu_cxx::__promote_2<_Tp, _Up>::__type\n     atan2(_Tp __y, _Up __x)\n-    { return __builtin_atan2(__y, __x); }\n+    {\n+      typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;\n+      return atan2(__type(__y), __type(__x));\n+    }\n \n   using ::ceil;\n \n@@ -341,15 +353,6 @@ _GLIBCXX_BEGIN_NAMESPACE(std)\n   modf(long double __x, long double* __iptr)\n   { return __builtin_modfl(__x, __iptr); }\n \n-  template<typename _Tp>\n-    inline _Tp\n-    __pow_helper(_Tp __x, int __n)\n-    {\n-      return __n < 0\n-        ? _Tp(1)/__cmath_power(__x, -__n)\n-        : __cmath_power(__x, __n);\n-    }\n-\n   using ::pow;\n \n   inline float\n@@ -360,6 +363,7 @@ _GLIBCXX_BEGIN_NAMESPACE(std)\n   pow(long double __x, long double __y)\n   { return __builtin_powl(__x, __y); }\n \n+  // DR 550.\n   inline double\n   pow(double __x, int __i)\n   { return __builtin_powi(__x, __i); }\n@@ -372,6 +376,14 @@ _GLIBCXX_BEGIN_NAMESPACE(std)\n   pow(long double __x, int __n)\n   { return __builtin_powil(__x, __n); }\n \n+  template<typename _Tp, typename _Up>\n+    inline typename __gnu_cxx::__promote_2<_Tp, _Up>::__type\n+    pow(_Tp __x, _Up __y)\n+    {\n+      typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;\n+      return pow(__type(__x), __type(__y));\n+    }\n+\n   using ::sin;\n \n   inline float\n@@ -597,7 +609,23 @@ _GLIBCXX_END_NAMESPACE\n #endif\n \n #ifdef __GXX_EXPERIMENTAL_CXX0X__\n-# include <tr1/cmath>\n+#  if defined(_GLIBCXX_INCLUDE_AS_TR1)\n+#    error C++0x header cannot be included from TR1 header\n+#  endif\n+#  include <type_traits>\n+#  if defined(_GLIBCXX_INCLUDE_AS_CXX0X)\n+#    include <tr1_impl/cmath>\n+#  else\n+#    define _GLIBCXX_INCLUDE_AS_CXX0X\n+#    define _GLIBCXX_BEGIN_NAMESPACE_TR1\n+#    define _GLIBCXX_END_NAMESPACE_TR1\n+#    define _GLIBCXX_TR1\n+#    include <tr1_impl/cmath>\n+#    undef _GLIBCXX_TR1\n+#    undef _GLIBCXX_END_NAMESPACE_TR1\n+#    undef _GLIBCXX_BEGIN_NAMESPACE_TR1\n+#    undef _GLIBCXX_INCLUDE_AS_CXX0X\n+#  endif\n #endif\n \n #endif"}, {"sha": "21b4f7a2bb0cd99043876d2bb025cb7681763359", "filename": "libstdc++-v3/include/c_global/cstdarg", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e133ace8d907bf42754c86106fc3f04a9d9fe70f/libstdc%2B%2B-v3%2Finclude%2Fc_global%2Fcstdarg", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e133ace8d907bf42754c86106fc3f04a9d9fe70f/libstdc%2B%2B-v3%2Finclude%2Fc_global%2Fcstdarg", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fc_global%2Fcstdarg?ref=e133ace8d907bf42754c86106fc3f04a9d9fe70f", "patch": "@@ -61,8 +61,4 @@ _GLIBCXX_BEGIN_NAMESPACE(std)\n \n _GLIBCXX_END_NAMESPACE\n \n-#ifdef __GXX_EXPERIMENTAL_CXX0X__\n-# include <tr1/cstdarg>\n-#endif\n-\n #endif"}, {"sha": "28dfa76abb8fe3428f8e271aeb388d4d004d716e", "filename": "libstdc++-v3/include/c_global/cstdbool", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e133ace8d907bf42754c86106fc3f04a9d9fe70f/libstdc%2B%2B-v3%2Finclude%2Fc_global%2Fcstdbool", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e133ace8d907bf42754c86106fc3f04a9d9fe70f/libstdc%2B%2B-v3%2Finclude%2Fc_global%2Fcstdbool", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fc_global%2Fcstdbool?ref=e133ace8d907bf42754c86106fc3f04a9d9fe70f", "patch": "@@ -36,10 +36,13 @@\n #ifndef _GLIBCXX_CSTDBOOL\n #define _GLIBCXX_CSTDBOOL 1\n \n-#ifdef __GXX_EXPERIMENTAL_CXX0X__\n-# include <tr1/cstdbool>\n+#ifndef __GXX_EXPERIMENTAL_CXX0X__\n+#  include <c++0x_warning.h>\n #else\n-# include <c++0x_warning.h>\n+#  include <bits/c++config.h>\n+#  if _GLIBCXX_HAVE_STDBOOL_H\n+#    include_next <stdbool.h>\n+#  endif\n #endif\n \n #endif "}, {"sha": "6c3f438c0a61e4b5a4d94efab622d0e7876efca5", "filename": "libstdc++-v3/include/c_global/cstdint", "status": "modified", "additions": 21, "deletions": 4, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e133ace8d907bf42754c86106fc3f04a9d9fe70f/libstdc%2B%2B-v3%2Finclude%2Fc_global%2Fcstdint", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e133ace8d907bf42754c86106fc3f04a9d9fe70f/libstdc%2B%2B-v3%2Finclude%2Fc_global%2Fcstdint", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fc_global%2Fcstdint?ref=e133ace8d907bf42754c86106fc3f04a9d9fe70f", "patch": "@@ -36,11 +36,28 @@\n #ifndef _GLIBCXX_CSTDINT\n #define _GLIBCXX_CSTDINT 1\n \n-#ifdef __GXX_EXPERIMENTAL_CXX0X__\n-# include <tr1/cstdint>\n-#else\n+#ifndef __GXX_EXPERIMENTAL_CXX0X__\n # include <c++0x_warning.h>\n #endif\n \n-#endif \n+#if defined(_GLIBCXX_INCLUDE_AS_TR1)\n+#  error C++0x header cannot be included from TR1 header\n+#endif\n+\n+#include <bits/c++config.h>\n \n+#if defined(_GLIBCXX_INCLUDE_AS_CXX0X)\n+#  include <tr1_impl/cstdint>\n+#else\n+#  define _GLIBCXX_INCLUDE_AS_CXX0X\n+#  define _GLIBCXX_BEGIN_NAMESPACE_TR1\n+#  define _GLIBCXX_END_NAMESPACE_TR1\n+#  define _GLIBCXX_TR1\n+#  include <tr1_impl/cstdint>\n+#  undef _GLIBCXX_TR1\n+#  undef _GLIBCXX_END_NAMESPACE_TR1\n+#  undef _GLIBCXX_BEGIN_NAMESPACE_TR1\n+#  undef _GLIBCXX_INCLUDE_AS_CXX0X\n+#endif\n+\n+#endif"}, {"sha": "3cdb5d6a258a811420fadf60431c35238c3ebb0a", "filename": "libstdc++-v3/include/c_global/cstdio", "status": "modified", "additions": 18, "deletions": 2, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e133ace8d907bf42754c86106fc3f04a9d9fe70f/libstdc%2B%2B-v3%2Finclude%2Fc_global%2Fcstdio", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e133ace8d907bf42754c86106fc3f04a9d9fe70f/libstdc%2B%2B-v3%2Finclude%2Fc_global%2Fcstdio", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fc_global%2Fcstdio?ref=e133ace8d907bf42754c86106fc3f04a9d9fe70f", "patch": "@@ -1,6 +1,7 @@\n // -*- C++ -*- forwarding header.\n \n-// Copyright (C) 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006\n+// Copyright (C) 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005,\n+// 2006, 2007\n // Free Software Foundation, Inc.\n //\n // This file is part of the GNU ISO C++ Library.  This library is free\n@@ -188,7 +189,22 @@ _GLIBCXX_END_NAMESPACE\n #endif // _GLIBCXX_USE_C99\n \n #ifdef __GXX_EXPERIMENTAL_CXX0X__\n-# include <tr1/cstdio>\n+#  if defined(_GLIBCXX_INCLUDE_AS_TR1)\n+#    error C++0x header cannot be included from TR1 header\n+#  endif\n+#  if defined(_GLIBCXX_INCLUDE_AS_CXX0X)\n+#    include <tr1_impl/cstdio>\n+#  else\n+#    define _GLIBCXX_INCLUDE_AS_CXX0X\n+#    define _GLIBCXX_BEGIN_NAMESPACE_TR1\n+#    define _GLIBCXX_END_NAMESPACE_TR1\n+#    define _GLIBCXX_TR1\n+#    include <tr1_impl/cstdio>\n+#    undef _GLIBCXX_TR1\n+#    undef _GLIBCXX_END_NAMESPACE_TR1\n+#    undef _GLIBCXX_BEGIN_NAMESPACE_TR1\n+#    undef _GLIBCXX_INCLUDE_AS_CXX0X\n+#  endif\n #endif\n \n #endif"}, {"sha": "3386ff0abc1faa9eddb64bc5066ed59ff6efb8e8", "filename": "libstdc++-v3/include/c_global/cstdlib", "status": "modified", "additions": 18, "deletions": 2, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e133ace8d907bf42754c86106fc3f04a9d9fe70f/libstdc%2B%2B-v3%2Finclude%2Fc_global%2Fcstdlib", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e133ace8d907bf42754c86106fc3f04a9d9fe70f/libstdc%2B%2B-v3%2Finclude%2Fc_global%2Fcstdlib", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fc_global%2Fcstdlib?ref=e133ace8d907bf42754c86106fc3f04a9d9fe70f", "patch": "@@ -1,6 +1,7 @@\n // -*- C++ -*- forwarding header.\n \n-// Copyright (C) 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006\n+// Copyright (C) 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005,\n+// 2006, 2007\n // Free Software Foundation, Inc.\n //\n // This file is part of the GNU ISO C++ Library.  This library is free\n@@ -223,7 +224,22 @@ _GLIBCXX_END_NAMESPACE\n #endif // _GLIBCXX_USE_C99\n \n #ifdef __GXX_EXPERIMENTAL_CXX0X__\n-# include <tr1/cstdlib>\n+#  if defined(_GLIBCXX_INCLUDE_AS_TR1)\n+#    error C++0x header cannot be included from TR1 header\n+#  endif\n+#  if defined(_GLIBCXX_INCLUDE_AS_CXX0X)\n+#    include <tr1_impl/cstdlib>\n+#  else\n+#    define _GLIBCXX_INCLUDE_AS_CXX0X\n+#    define _GLIBCXX_BEGIN_NAMESPACE_TR1\n+#    define _GLIBCXX_END_NAMESPACE_TR1\n+#    define _GLIBCXX_TR1\n+#    include <tr1_impl/cstdlib>\n+#    undef _GLIBCXX_TR1\n+#    undef _GLIBCXX_END_NAMESPACE_TR1\n+#    undef _GLIBCXX_BEGIN_NAMESPACE_TR1\n+#    undef _GLIBCXX_INCLUDE_AS_CXX0X\n+#  endif\n #endif\n \n #endif // !_GLIBCXX_HOSTED"}, {"sha": "2f3d7d02df080ae0269147f8c917c918d483e798", "filename": "libstdc++-v3/include/c_global/ctgmath", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e133ace8d907bf42754c86106fc3f04a9d9fe70f/libstdc%2B%2B-v3%2Finclude%2Fc_global%2Fctgmath", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e133ace8d907bf42754c86106fc3f04a9d9fe70f/libstdc%2B%2B-v3%2Finclude%2Fc_global%2Fctgmath", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fc_global%2Fctgmath?ref=e133ace8d907bf42754c86106fc3f04a9d9fe70f", "patch": "@@ -36,10 +36,10 @@\n #ifndef _GLIBCXX_CTGMATH\n #define _GLIBCXX_CTGMATH 1\n \n-#ifdef __GXX_EXPERIMENTAL_CXX0X__\n-# include <tr1/ctgmath>\n+#ifndef __GXX_EXPERIMENTAL_CXX0X__\n+#  include <c++0x_warning.h>\n #else\n-# include <c++0x_warning.h>\n+#  include <cmath>\n #endif\n \n #endif "}, {"sha": "915c2fc663f5ddb0b48aad09b9f605bd72f0a74e", "filename": "libstdc++-v3/include/c_global/ctime", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e133ace8d907bf42754c86106fc3f04a9d9fe70f/libstdc%2B%2B-v3%2Finclude%2Fc_global%2Fctime", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e133ace8d907bf42754c86106fc3f04a9d9fe70f/libstdc%2B%2B-v3%2Finclude%2Fc_global%2Fctime", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fc_global%2Fctime?ref=e133ace8d907bf42754c86106fc3f04a9d9fe70f", "patch": "@@ -1,6 +1,7 @@\n // -*- C++ -*- forwarding header.\n \n-// Copyright (C) 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006\n+// Copyright (C) 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005,\n+// 2006, 2007\n // Free Software Foundation, Inc.\n //\n // This file is part of the GNU ISO C++ Library.  This library is free\n@@ -79,8 +80,4 @@ _GLIBCXX_BEGIN_NAMESPACE(std)\n \n _GLIBCXX_END_NAMESPACE\n \n-#ifdef __GXX_EXPERIMENTAL_CXX0X__\n-# include <tr1/ctime>\n-#endif\n-\n #endif"}, {"sha": "92bca61edf0472f1c82e1bcfa609fe45dbc28a0d", "filename": "libstdc++-v3/include/c_global/cwchar", "status": "modified", "additions": 16, "deletions": 1, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e133ace8d907bf42754c86106fc3f04a9d9fe70f/libstdc%2B%2B-v3%2Finclude%2Fc_global%2Fcwchar", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e133ace8d907bf42754c86106fc3f04a9d9fe70f/libstdc%2B%2B-v3%2Finclude%2Fc_global%2Fcwchar", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fc_global%2Fcwchar?ref=e133ace8d907bf42754c86106fc3f04a9d9fe70f", "patch": "@@ -278,7 +278,22 @@ _GLIBCXX_END_NAMESPACE\n #endif //_GLIBCXX_USE_WCHAR_T\n \n #ifdef __GXX_EXPERIMENTAL_CXX0X__\n-# include <tr1/cwchar>\n+#  if defined(_GLIBCXX_INCLUDE_AS_TR1)\n+#    error C++0x header cannot be included from TR1 header\n+#  endif\n+#  if defined(_GLIBCXX_INCLUDE_AS_CXX0X)\n+#    include <tr1_impl/cwchar>\n+#  else\n+#    define _GLIBCXX_INCLUDE_AS_CXX0X\n+#    define _GLIBCXX_BEGIN_NAMESPACE_TR1\n+#    define _GLIBCXX_END_NAMESPACE_TR1\n+#    define _GLIBCXX_TR1\n+#    include <tr1_impl/cwchar>\n+#    undef _GLIBCXX_TR1\n+#    undef _GLIBCXX_END_NAMESPACE_TR1\n+#    undef _GLIBCXX_BEGIN_NAMESPACE_TR1\n+#    undef _GLIBCXX_INCLUDE_AS_CXX0X\n+#  endif\n #endif\n \n #endif"}, {"sha": "d2f2d779fbc989dd2085ec0bf6800eab713d1d53", "filename": "libstdc++-v3/include/c_global/cwctype", "status": "modified", "additions": 18, "deletions": 2, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e133ace8d907bf42754c86106fc3f04a9d9fe70f/libstdc%2B%2B-v3%2Finclude%2Fc_global%2Fcwctype", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e133ace8d907bf42754c86106fc3f04a9d9fe70f/libstdc%2B%2B-v3%2Finclude%2Fc_global%2Fcwctype", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fc_global%2Fcwctype?ref=e133ace8d907bf42754c86106fc3f04a9d9fe70f", "patch": "@@ -1,6 +1,7 @@\n // -*- C++ -*- forwarding header.\n \n-// Copyright (C) 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006\n+// Copyright (C) 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005,\n+// 2006, 2007\n // Free Software Foundation, Inc.\n //\n // This file is part of the GNU ISO C++ Library.  This library is free\n@@ -109,7 +110,22 @@ _GLIBCXX_END_NAMESPACE\n #endif //_GLIBCXX_USE_WCHAR_T\n \n #ifdef __GXX_EXPERIMENTAL_CXX0X__\n-# include <tr1/cwctype>\n+#  if defined(_GLIBCXX_INCLUDE_AS_TR1)\n+#    error C++0x header cannot be included from TR1 header\n+#  endif\n+#  if defined(_GLIBCXX_INCLUDE_AS_CXX0X)\n+#    include <tr1_impl/cwctype>\n+#  else\n+#    define _GLIBCXX_INCLUDE_AS_CXX0X\n+#    define _GLIBCXX_BEGIN_NAMESPACE_TR1\n+#    define _GLIBCXX_END_NAMESPACE_TR1\n+#    define _GLIBCXX_TR1\n+#    include <tr1_impl/cwctype>\n+#    undef _GLIBCXX_TR1\n+#    undef _GLIBCXX_END_NAMESPACE_TR1\n+#    undef _GLIBCXX_BEGIN_NAMESPACE_TR1\n+#    undef _GLIBCXX_INCLUDE_AS_CXX0X\n+#  endif\n #endif\n \n #endif"}, {"sha": "746d86636cd3ff2a81657ef68bc0b00b26f679e8", "filename": "libstdc++-v3/include/ext/type_traits.h", "status": "modified", "additions": 46, "deletions": 0, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e133ace8d907bf42754c86106fc3f04a9d9fe70f/libstdc%2B%2B-v3%2Finclude%2Fext%2Ftype_traits.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e133ace8d907bf42754c86106fc3f04a9d9fe70f/libstdc%2B%2B-v3%2Finclude%2Fext%2Ftype_traits.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fext%2Ftype_traits.h?ref=e133ace8d907bf42754c86106fc3f04a9d9fe70f", "patch": "@@ -159,6 +159,52 @@ _GLIBCXX_BEGIN_NAMESPACE(__gnu_cxx)\n     __is_null_pointer(_Type)\n     { return false; }\n \n+\n+  // For complex and cmath\n+  template<typename _Tp, bool = std::__is_integer<_Tp>::__value>\n+    struct __promote\n+    { typedef double __type; };\n+\n+  template<typename _Tp>\n+    struct __promote<_Tp, false>\n+    { typedef _Tp __type; };\n+\n+  template<typename _Tp, typename _Up>\n+    struct __promote_2\n+    {\n+    private:\n+      typedef typename __promote<_Tp>::__type __type1;\n+      typedef typename __promote<_Up>::__type __type2;\n+\n+    public:\n+      typedef __typeof__(__type1() + __type2()) __type;\n+    };\n+\n+  template<typename _Tp, typename _Up, typename _Vp>\n+    struct __promote_3\n+    {\n+    private:\n+      typedef typename __promote<_Tp>::__type __type1;\n+      typedef typename __promote<_Up>::__type __type2;\n+      typedef typename __promote<_Vp>::__type __type3;\n+\n+    public:\n+      typedef __typeof__(__type1() + __type2() + __type3()) __type;\n+    };\n+\n+  template<typename _Tp, typename _Up, typename _Vp, typename _Wp>\n+    struct __promote_4\n+    {\n+    private:\n+      typedef typename __promote<_Tp>::__type __type1;\n+      typedef typename __promote<_Up>::__type __type2;\n+      typedef typename __promote<_Vp>::__type __type3;\n+      typedef typename __promote<_Wp>::__type __type4;\n+\n+    public:\n+      typedef __typeof__(__type1() + __type2() + __type3() + __type4()) __type;\n+    };\n+\n _GLIBCXX_END_NAMESPACE\n \n #endif "}, {"sha": "691f41cbcd83e75ded704466e091e8d1cfab58fd", "filename": "libstdc++-v3/include/std/array", "status": "modified", "additions": 23, "deletions": 6, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e133ace8d907bf42754c86106fc3f04a9d9fe70f/libstdc%2B%2B-v3%2Finclude%2Fstd%2Farray", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e133ace8d907bf42754c86106fc3f04a9d9fe70f/libstdc%2B%2B-v3%2Finclude%2Fstd%2Farray", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fstd%2Farray?ref=e133ace8d907bf42754c86106fc3f04a9d9fe70f", "patch": "@@ -31,16 +31,33 @@\n  *  This is a Standard C++ Library header.\n  */\n \n-#ifndef _GLIBCXX_ARRAY\n-#define _GLIBCXX_ARRAY 1\n+#ifndef _GLIBCXX_CXX0X_ARRAY\n+#define _GLIBCXX_CXX0X_ARRAY 1\n \n #pragma GCC system_header\n \n-#ifdef __GXX_EXPERIMENTAL_CXX0X__\n-# include <tr1/array>\n-#else\n+#ifndef __GXX_EXPERIMENTAL_CXX0X__\n # include <c++0x_warning.h>\n #endif\n \n-#endif \n+#if defined(_GLIBCXX_INCLUDE_AS_TR1)\n+#  error C++0x header cannot be included from TR1 header\n+#endif\n+\n+#include <bits/stl_algobase.h>\n+\n+#if defined(_GLIBCXX_INCLUDE_AS_CXX0X)\n+#  include <tr1_impl/array>\n+#else\n+#  define _GLIBCXX_INCLUDE_AS_CXX0X\n+#  define _GLIBCXX_BEGIN_NAMESPACE_TR1\n+#  define _GLIBCXX_END_NAMESPACE_TR1\n+#  define _GLIBCXX_TR1\n+#  include <tr1_impl/array>\n+#  undef _GLIBCXX_TR1\n+#  undef _GLIBCXX_END_NAMESPACE_TR1\n+#  undef _GLIBCXX_BEGIN_NAMESPACE_TR1\n+#  undef _GLIBCXX_INCLUDE_AS_CXX0X\n+#endif\n \n+#endif // _GLIBCXX_CXX0X_ARRAY"}, {"sha": "61d3580380e289d936b31ceb7f16358b0ca08e53", "filename": "libstdc++-v3/include/std/complex", "status": "modified", "additions": 44, "deletions": 1, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e133ace8d907bf42754c86106fc3f04a9d9fe70f/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fcomplex", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e133ace8d907bf42754c86106fc3f04a9d9fe70f/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fcomplex", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fcomplex?ref=e133ace8d907bf42754c86106fc3f04a9d9fe70f", "patch": "@@ -47,6 +47,7 @@\n \n #include <bits/c++config.h>\n #include <bits/cpp_type_traits.h>\n+#include <ext/type_traits.h>\n #include <cmath>\n #include <sstream>\n \n@@ -1508,8 +1509,50 @@ _GLIBCXX_BEGIN_NAMESPACE(std)\n \n _GLIBCXX_END_NAMESPACE\n \n+_GLIBCXX_BEGIN_NAMESPACE(__gnu_cxx)\n+\n+  // See ext/type_traits.h for the primary template.\n+  template<typename _Tp, typename _Up>\n+    struct __promote_2<std::complex<_Tp>, _Up>\n+    {\n+    public:\n+      typedef std::complex<typename __promote_2<_Tp, _Up>::__type> __type;\n+    };\n+\n+  template<typename _Tp, typename _Up>\n+    struct __promote_2<_Tp, std::complex<_Up> >\n+    {\n+    public:\n+      typedef std::complex<typename __promote_2<_Tp, _Up>::__type> __type;\n+    };\n+  \n+  template<typename _Tp, typename _Up>\n+    struct __promote_2<std::complex<_Tp>, std::complex<_Up> >\n+    {\n+    public:\n+      typedef std::complex<typename __promote_2<_Tp, _Up>::__type> __type;\n+    };\n+\n+_GLIBCXX_END_NAMESPACE\n+\n #ifdef __GXX_EXPERIMENTAL_CXX0X__\n-# include <tr1/complex>\n+#  if defined(_GLIBCXX_INCLUDE_AS_TR1)\n+#    error C++0x header cannot be included from TR1 header\n+#  endif\n+#  include <type_traits>\n+#  if defined(_GLIBCXX_INCLUDE_AS_CXX0X)\n+#    include <tr1_impl/complex>\n+#  else\n+#    define _GLIBCXX_INCLUDE_AS_CXX0X\n+#    define _GLIBCXX_BEGIN_NAMESPACE_TR1\n+#    define _GLIBCXX_END_NAMESPACE_TR1\n+#    define _GLIBCXX_TR1\n+#    include <tr1_impl/complex>\n+#    undef _GLIBCXX_TR1\n+#    undef _GLIBCXX_END_NAMESPACE_TR1\n+#    undef _GLIBCXX_BEGIN_NAMESPACE_TR1\n+#    undef _GLIBCXX_INCLUDE_AS_CXX0X\n+#  endif\n #endif\n \n #endif\t/* _GLIBCXX_COMPLEX */"}, {"sha": "27e88176400640438ffcf3b133ca227af4d60862", "filename": "libstdc++-v3/include/std/functional", "status": "modified", "additions": 24, "deletions": 2, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e133ace8d907bf42754c86106fc3f04a9d9fe70f/libstdc%2B%2B-v3%2Finclude%2Fstd%2Ffunctional", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e133ace8d907bf42754c86106fc3f04a9d9fe70f/libstdc%2B%2B-v3%2Finclude%2Fstd%2Ffunctional", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fstd%2Ffunctional?ref=e133ace8d907bf42754c86106fc3f04a9d9fe70f", "patch": "@@ -55,7 +55,29 @@\n #include <bits/stl_function.h>\n \n #ifdef __GXX_EXPERIMENTAL_CXX0X__\n-# include <tr1/functional>\n+#  if defined(_GLIBCXX_INCLUDE_AS_TR1)\n+#    error C++0x header cannot be included from TR1 header\n+#  endif\n+#  include <cmath>\n+#  include <string>\n+#  include <typeinfo>\n+#  include <ext/type_traits.h>\n+#  include <tuple>\n+#  include <type_traits>\n+#  include <bits/functional_hash.h>\n+#  if defined(_GLIBCXX_INCLUDE_AS_CXX0X)\n+#    include <tr1_impl/functional>\n+#  else\n+#    define _GLIBCXX_INCLUDE_AS_CXX0X\n+#    define _GLIBCXX_BEGIN_NAMESPACE_TR1\n+#    define _GLIBCXX_END_NAMESPACE_TR1\n+#    define _GLIBCXX_TR1\n+#    include <tr1_impl/functional>\n+#    undef _GLIBCXX_TR1\n+#    undef _GLIBCXX_END_NAMESPACE_TR1\n+#    undef _GLIBCXX_BEGIN_NAMESPACE_TR1\n+#    undef _GLIBCXX_INCLUDE_AS_CXX0X\n+#  endif\n #endif\n \n-#endif /* _GLIBCXX_FUNCTIONAL */\n+#endif // _GLIBCXX_FUNCTIONAL"}, {"sha": "c48a5c3529c02ed3762133a538ac8ae98e18e79c", "filename": "libstdc++-v3/include/std/memory", "status": "modified", "additions": 27, "deletions": 1, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e133ace8d907bf42754c86106fc3f04a9d9fe70f/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fmemory", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e133ace8d907bf42754c86106fc3f04a9d9fe70f/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fmemory", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fmemory?ref=e133ace8d907bf42754c86106fc3f04a9d9fe70f", "patch": "@@ -60,7 +60,33 @@\n #include <bits/stl_raw_storage_iter.h>\n \n #ifdef __GXX_EXPERIMENTAL_CXX0X__\n-# include <tr1/memory>\n+#  if defined(_GLIBCXX_INCLUDE_AS_TR1)\n+#    error C++0x header cannot be included from TR1 header\n+#  endif\n+#  include <exception>        \t  // std::exception\n+#  include <new>              \t  // std::bad_alloc\n+#  include <typeinfo>         \t  // std::type_info in get_deleter\n+#  include <bits/stl_algobase.h>  // std::swap\n+#  include <iosfwd>           \t  // std::basic_ostream\n+#  include <ext/atomicity.h>\n+#  include <ext/concurrence.h>\n+#  include <bits/functexcept.h>\n+#  include <bits/stl_function.h>  // std::less\n+#  include <debug/debug.h>\n+#  include <type_traits>\n+#  if defined(_GLIBCXX_INCLUDE_AS_CXX0X)\n+#    include <tr1_impl/boost_shared_ptr.h>\n+#  else\n+#    define _GLIBCXX_INCLUDE_AS_CXX0X\n+#    define _GLIBCXX_BEGIN_NAMESPACE_TR1\n+#    define _GLIBCXX_END_NAMESPACE_TR1\n+#    define _GLIBCXX_TR1\n+#    include <tr1_impl/boost_shared_ptr.h>\n+#    undef _GLIBCXX_TR1\n+#    undef _GLIBCXX_END_NAMESPACE_TR1\n+#    undef _GLIBCXX_BEGIN_NAMESPACE_TR1\n+#    undef _GLIBCXX_INCLUDE_AS_CXX0X\n+#  endif\n #endif\n \n #endif /* _GLIBCXX_MEMORY */"}, {"sha": "2fccb6069855725d1bf48066b83d8580b735a5e6", "filename": "libstdc++-v3/include/std/random", "status": "modified", "additions": 31, "deletions": 4, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e133ace8d907bf42754c86106fc3f04a9d9fe70f/libstdc%2B%2B-v3%2Finclude%2Fstd%2Frandom", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e133ace8d907bf42754c86106fc3f04a9d9fe70f/libstdc%2B%2B-v3%2Finclude%2Fstd%2Frandom", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fstd%2Frandom?ref=e133ace8d907bf42754c86106fc3f04a9d9fe70f", "patch": "@@ -36,11 +36,38 @@\n \n #pragma GCC system_header\n \n-#ifdef __GXX_EXPERIMENTAL_CXX0X__\n-# include <tr1/random>\n-#else\n+#ifndef __GXX_EXPERIMENTAL_CXX0X__\n # include <c++0x_warning.h>\n #endif\n \n-#endif \n+#if defined(_GLIBCXX_INCLUDE_AS_TR1)\n+#  error C++0x header cannot be included from TR1 header\n+#endif\n+\n+#include <cmath>\n+#include <cstdio>\n+#include <cstdlib>\n+#include <string>\n+#include <iosfwd>\n+#include <limits>\n+#include <ext/type_traits.h>\n+#include <ext/numeric_traits.h>\n+#include <bits/concept_check.h>\n+#include <debug/debug.h>\n+#include <type_traits>\n+\n+#if defined(_GLIBCXX_INCLUDE_AS_CXX0X)\n+#  include <tr1_impl/random>\n+#else\n+#  define _GLIBCXX_INCLUDE_AS_CXX0X\n+#  define _GLIBCXX_BEGIN_NAMESPACE_TR1\n+#  define _GLIBCXX_END_NAMESPACE_TR1\n+#  define _GLIBCXX_TR1\n+#  include <tr1_impl/random>\n+#  undef _GLIBCXX_TR1\n+#  undef _GLIBCXX_END_NAMESPACE_TR1\n+#  undef _GLIBCXX_BEGIN_NAMESPACE_TR1\n+#  undef _GLIBCXX_INCLUDE_AS_CXX0X\n+#endif\n \n+#endif // _GLIBCXX_RANDOM"}, {"sha": "5c257181f2e6ee4530b106655e6d65caf4e6d4da", "filename": "libstdc++-v3/include/std/regex", "status": "modified", "additions": 30, "deletions": 6, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e133ace8d907bf42754c86106fc3f04a9d9fe70f/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fregex", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e133ace8d907bf42754c86106fc3f04a9d9fe70f/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fregex", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fregex?ref=e133ace8d907bf42754c86106fc3f04a9d9fe70f", "patch": "@@ -31,16 +31,40 @@\n  *  This is a Standard C++ Library header.\n  */\n \n-#ifndef _GLIBCXX_REGEX\n-#define _GLIBCXX_REGEX 1\n+#ifndef _GLIBCXX_CXX0X_REGEX\n+#define _GLIBCXX_CXX0X_REGEX 1\n \n #pragma GCC system_header\n \n-#ifdef __GXX_EXPERIMENTAL_CXX0X__\n-# include <tr1/regex>\n-#else\n+#ifndef __GXX_EXPERIMENTAL_CXX0X__\n # include <c++0x_warning.h>\n #endif\n \n-#endif \n+#if defined(_GLIBCXX_INCLUDE_AS_TR1)\n+#  error C++0x header cannot be included from TR1 header\n+#endif\n+\n+#include <algorithm>\n+#include <bitset>\n+#include <iterator>\n+#include <locale>\n+#include <stdexcept>\n+#include <string>\n+#include <vector>\n+#include <utility>\n+\n+#if defined(_GLIBCXX_INCLUDE_AS_CXX0X)\n+#  include <tr1_impl/regex>\n+#else\n+#  define _GLIBCXX_INCLUDE_AS_CXX0X\n+#  define _GLIBCXX_BEGIN_NAMESPACE_TR1\n+#  define _GLIBCXX_END_NAMESPACE_TR1\n+#  define _GLIBCXX_TR1\n+#  include <tr1_impl/regex>\n+#  undef _GLIBCXX_TR1\n+#  undef _GLIBCXX_END_NAMESPACE_TR1\n+#  undef _GLIBCXX_BEGIN_NAMESPACE_TR1\n+#  undef _GLIBCXX_INCLUDE_AS_CXX0X\n+#endif\n \n+#endif // _GLIBCXX_CXX0X_REGEX"}, {"sha": "94e7ef5c0864ef6a8408903b6a8b0437a04d27b8", "filename": "libstdc++-v3/include/std/tuple", "status": "modified", "additions": 23, "deletions": 6, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e133ace8d907bf42754c86106fc3f04a9d9fe70f/libstdc%2B%2B-v3%2Finclude%2Fstd%2Ftuple", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e133ace8d907bf42754c86106fc3f04a9d9fe70f/libstdc%2B%2B-v3%2Finclude%2Fstd%2Ftuple", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fstd%2Ftuple?ref=e133ace8d907bf42754c86106fc3f04a9d9fe70f", "patch": "@@ -31,16 +31,33 @@\n  *  This is a Standard C++ Library header.\n  */\n \n-#ifndef _GLIBCXX_TUPLE\n-#define _GLIBCXX_TUPLE 1\n+#ifndef _GLIBCXX_CXX0X_TUPLE\n+#define _GLIBCXX_CXX0X_TUPLE 1\n \n #pragma GCC system_header\n \n-#ifdef __GXX_EXPERIMENTAL_CXX0X__\n-# include <tr1/tuple>\n-#else\n+#ifndef __GXX_EXPERIMENTAL_CXX0X__\n # include <c++0x_warning.h>\n #endif\n \n-#endif \n+#if defined(_GLIBCXX_INCLUDE_AS_TR1)\n+#  error C++0x header cannot be included from TR1 header\n+#endif\n+\n+#include <utility>\n+\n+#if defined(_GLIBCXX_INCLUDE_AS_CXX0X)\n+#  include <tr1_impl/tuple>\n+#else\n+#  define _GLIBCXX_INCLUDE_AS_CXX0X\n+#  define _GLIBCXX_BEGIN_NAMESPACE_TR1\n+#  define _GLIBCXX_END_NAMESPACE_TR1\n+#  define _GLIBCXX_TR1\n+#  include <tr1_impl/tuple>\n+#  undef _GLIBCXX_TR1\n+#  undef _GLIBCXX_END_NAMESPACE_TR1\n+#  undef _GLIBCXX_BEGIN_NAMESPACE_TR1\n+#  undef _GLIBCXX_INCLUDE_AS_CXX0X\n+#endif\n \n+#endif // _GLIBCXX_CXX0X_TUPLE"}, {"sha": "8dbfb5622959fca929ca0d363f6f672f4baa6c1d", "filename": "libstdc++-v3/include/std/type_traits", "status": "modified", "additions": 157, "deletions": 42, "changes": 199, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e133ace8d907bf42754c86106fc3f04a9d9fe70f/libstdc%2B%2B-v3%2Finclude%2Fstd%2Ftype_traits", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e133ace8d907bf42754c86106fc3f04a9d9fe70f/libstdc%2B%2B-v3%2Finclude%2Fstd%2Ftype_traits", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fstd%2Ftype_traits?ref=e133ace8d907bf42754c86106fc3f04a9d9fe70f", "patch": "@@ -31,18 +31,159 @@\n  *  This is a Standard C++ Library header.\n  */\n \n-#ifndef _GLIBCXX_TYPE_TRAITS\n-#define _GLIBCXX_TYPE_TRAITS 1\n+#ifndef _GLIBCXX_CXX0X_TYPE_TRAITS\n+#define _GLIBCXX_CXX0X_TYPE_TRAITS 1\n \n #pragma GCC system_header\n \n-#ifdef __GXX_EXPERIMENTAL_CXX0X__\n-# include <tr1/type_traits>\n-#else\n+#ifndef __GXX_EXPERIMENTAL_CXX0X__\n # include <c++0x_warning.h>\n #endif\n \n-_GLIBCXX_BEGIN_NAMESPACE(std)\n+#if defined(_GLIBCXX_INCLUDE_AS_TR1)\n+#  error C++0x header cannot be included from TR1 header\n+#endif\n+\n+#include <cstddef>\n+\n+#if defined(_GLIBCXX_INCLUDE_AS_CXX0X)\n+#  include <tr1_impl/type_traits>\n+#else\n+#  define _GLIBCXX_INCLUDE_AS_CXX0X\n+#  define _GLIBCXX_BEGIN_NAMESPACE_TR1\n+#  define _GLIBCXX_END_NAMESPACE_TR1\n+#  define _GLIBCXX_TR1\n+#  include <tr1_impl/type_traits>\n+#  undef _GLIBCXX_TR1\n+#  undef _GLIBCXX_END_NAMESPACE_TR1\n+#  undef _GLIBCXX_BEGIN_NAMESPACE_TR1\n+#  undef _GLIBCXX_INCLUDE_AS_CXX0X\n+#endif\n+\n+namespace std\n+{\n+  template<typename _Tp,\n+\t   bool = is_integral<_Tp>::value,\n+\t   bool = is_floating_point<_Tp>::value>\n+    struct __is_signed_helper\n+    : public false_type { };\n+\n+  template<typename _Tp>\n+    struct __is_signed_helper<_Tp, false, true>\n+    : public true_type { };\n+\n+  template<typename _Tp>\n+    struct __is_signed_helper<_Tp, true, false>\n+    : public integral_constant<bool, _Tp(-1) < _Tp(0)>\n+    { };\n+\n+  template<typename _Tp>\n+    struct is_signed\n+    : public integral_constant<bool, __is_signed_helper<_Tp>::value>\n+    { };\n+\n+  template<typename _Tp>\n+    struct is_unsigned\n+    : public integral_constant<bool, (is_arithmetic<_Tp>::value\n+\t\t\t\t      && !is_signed<_Tp>::value)>\n+    { };\n+\n+  template<typename _Tp>\n+    struct is_pod\n+    : public integral_constant<bool, __is_pod(_Tp)>\n+    { };\n+\n+  template<typename _Tp>\n+    struct has_trivial_default_constructor\n+    : public integral_constant<bool, __has_trivial_constructor(_Tp)>\n+    { };\n+\n+  template<typename _Tp>\n+    struct has_trivial_copy_constructor\n+    : public integral_constant<bool, __has_trivial_copy(_Tp)>\n+    { };\n+\n+  template<typename _Tp>\n+    struct has_trivial_assign\n+    : public integral_constant<bool, __has_trivial_assign(_Tp)>\n+    { };\n+\n+  template<typename _Tp>\n+    struct has_trivial_destructor\n+    : public integral_constant<bool, __has_trivial_destructor(_Tp)>\n+    { };\n+\n+  template<typename _Tp>\n+    struct has_nothrow_default_constructor\n+    : public integral_constant<bool, __has_nothrow_constructor(_Tp)>\n+    { };\n+\n+  template<typename _Tp>\n+    struct has_nothrow_copy_constructor\n+    : public integral_constant<bool, __has_nothrow_copy(_Tp)>\n+    { };\n+\n+  template<typename _Tp>\n+    struct has_nothrow_assign\n+    : public integral_constant<bool, __has_nothrow_assign(_Tp)>\n+    { };\n+\n+  template<typename _Base, typename _Derived>\n+    struct is_base_of\n+    : public integral_constant<bool, __is_base_of(_Base, _Derived)>\n+    { };\n+\n+  // XXX FIXME\n+  // The C++0x specifications are different, see N2255.\n+  template<typename _From, typename _To>\n+    struct __is_convertible_simple\n+    : public __sfinae_types\n+    {\n+    private:\n+      static __one __test(_To);\n+      static __two __test(...);\n+      static _From __makeFrom();\n+    \n+    public:\n+      static const bool __value = sizeof(__test(__makeFrom())) == 1;\n+    };\n+\n+  template<typename _Tp>\n+    struct __is_int_or_cref\n+    {\n+      typedef typename remove_reference<_Tp>::type __rr_Tp;\n+      static const bool __value = (is_integral<_Tp>::value\n+\t\t\t\t   || (is_integral<__rr_Tp>::value\n+\t\t\t\t       && is_const<__rr_Tp>::value\n+\t\t\t\t       && !is_volatile<__rr_Tp>::value));\n+    };\n+\n+  template<typename _From, typename _To,\n+\t   bool = (is_void<_From>::value || is_void<_To>::value\n+\t\t   || is_function<_To>::value || is_array<_To>::value\n+\t\t   // This special case is here only to avoid warnings.\t\t   \n+\t\t   || (is_floating_point<typename\n+\t\t       remove_reference<_From>::type>::value\n+\t\t       && __is_int_or_cref<_To>::__value))>\n+    struct __is_convertible_helper\n+    {\n+      // \"An imaginary lvalue of type From...\".\n+      static const bool __value = (__is_convertible_simple<typename\n+\t\t\t\t   add_reference<_From>::type, _To>::__value);\n+    };\n+\n+  template<typename _From, typename _To>\n+    struct __is_convertible_helper<_From, _To, true>\n+    { static const bool __value = (is_void<_To>::value\n+\t\t\t\t   || (__is_int_or_cref<_To>::__value\n+\t\t\t\t       && !is_void<_From>::value)); };\n+\n+  template<typename _From, typename _To>\n+    struct is_convertible\n+    : public integral_constant<bool,\n+\t\t\t       __is_convertible_helper<_From, _To>::__value>\n+    { };\n+\n \n   // Define a nested type if some predicate holds.\n   template<bool, typename _Tp = void>\n@@ -131,7 +272,8 @@ _GLIBCXX_BEGIN_NAMESPACE(std)\n \n   // Utility for finding the unsigned versions of signed integral types.\n   template<typename _Tp>\n-    struct __make_unsigned;\n+    struct __make_unsigned\n+    { typedef _Tp __type; };\n \n   template<>\n     struct __make_unsigned<char>\n@@ -165,16 +307,11 @@ _GLIBCXX_BEGIN_NAMESPACE(std)\n   // Select between integral and enum: not possible to be both.\n   template<typename _Tp, \n \t   bool _IsInt = is_integral<_Tp>::value,\n-\t   bool _IsUnsigned = is_unsigned<_Tp>::value,\n \t   bool _IsEnum = is_enum<_Tp>::value>\n     struct __make_unsigned_selector;\n   \n   template<typename _Tp>\n-    struct __make_unsigned_selector<_Tp, true, true, false>\n-    { typedef _Tp __type; };\n-\n-  template<typename _Tp>\n-    struct __make_unsigned_selector<_Tp, true, false, false>\n+    struct __make_unsigned_selector<_Tp, true, false>\n     {\n     private:\n       typedef __make_unsigned<typename remove_cv<_Tp>::type> __unsignedt;\n@@ -186,7 +323,7 @@ _GLIBCXX_BEGIN_NAMESPACE(std)\n     };\n \n   template<typename _Tp>\n-    struct __make_unsigned_selector<_Tp, false, false, true>\n+    struct __make_unsigned_selector<_Tp, false, true>\n     {\n     private:\n       // GNU enums start with sizeof short.\n@@ -214,7 +351,8 @@ _GLIBCXX_BEGIN_NAMESPACE(std)\n \n   // Utility for finding the signed versions of unsigned integral types.\n   template<typename _Tp>\n-    struct __make_signed;\n+    struct __make_signed\n+    { typedef _Tp __type; };\n \n   template<>\n     struct __make_signed<char>\n@@ -248,16 +386,11 @@ _GLIBCXX_BEGIN_NAMESPACE(std)\n   // Select between integral and enum: not possible to be both.\n   template<typename _Tp, \n \t   bool _IsInt = is_integral<_Tp>::value,\n-\t   bool _IsSigned = is_signed<_Tp>::value,\n \t   bool _IsEnum = is_enum<_Tp>::value>\n     struct __make_signed_selector;\n   \n   template<typename _Tp>\n-    struct __make_signed_selector<_Tp, true, true, false>\n-    { typedef _Tp __type; };\n-\n-  template<typename _Tp>\n-    struct __make_signed_selector<_Tp, true, false, false>\n+    struct __make_signed_selector<_Tp, true, false>\n     {\n     private:\n       typedef __make_signed<typename remove_cv<_Tp>::type> __signedt;\n@@ -269,7 +402,7 @@ _GLIBCXX_BEGIN_NAMESPACE(std)\n     };\n \n   template<typename _Tp>\n-    struct __make_signed_selector<_Tp, false, false, true>\n+    struct __make_signed_selector<_Tp, false, true>\n     {\n     private:\n       // GNU enums start with sizeof short.\n@@ -293,25 +426,7 @@ _GLIBCXX_BEGIN_NAMESPACE(std)\n   // Integral, but don't define.\n   template<>\n     struct make_signed<bool>;\n+}\n \n-\n-  template<typename _Tp>\n-    struct has_nothrow_default_constructor\n-    : public integral_constant<bool, is_pod<_Tp>::value> { };\n-\n-  template<typename _Tp>\n-    struct has_nothrow_copy_constructor\n-    : public integral_constant<bool, is_pod<_Tp>::value> { };\n-\n-  template<typename _Tp>\n-    struct has_trivial_default_constructor\n-    : public integral_constant<bool, is_pod<_Tp>::value> { };\n-\n-  template<typename _Tp>\n-    struct has_trivial_copy_constructor\n-    : public integral_constant<bool, is_pod<_Tp>::value> { };\n-\n-_GLIBCXX_END_NAMESPACE\n-\n-#endif \n+#endif  // _GLIBCXX_CXX0X_TYPE_TRAITS \n "}, {"sha": "016d3eaed21fffc9cd71d3aa0eb896c9ac558371", "filename": "libstdc++-v3/include/std/unordered_map", "status": "modified", "additions": 29, "deletions": 4, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e133ace8d907bf42754c86106fc3f04a9d9fe70f/libstdc%2B%2B-v3%2Finclude%2Fstd%2Funordered_map", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e133ace8d907bf42754c86106fc3f04a9d9fe70f/libstdc%2B%2B-v3%2Finclude%2Fstd%2Funordered_map", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fstd%2Funordered_map?ref=e133ace8d907bf42754c86106fc3f04a9d9fe70f", "patch": "@@ -36,11 +36,36 @@\n \n #pragma GCC system_header\n \n-#ifdef __GXX_EXPERIMENTAL_CXX0X__\n-# include <tr1/unordered_map>\n-#else\n+#ifndef __GXX_EXPERIMENTAL_CXX0X__\n # include <c++0x_warning.h>\n #endif\n \n-#endif \n+#if defined(_GLIBCXX_INCLUDE_AS_TR1)\n+#  error C++0x header cannot be included from TR1 header\n+#endif\n+\n+#include <cmath>\n+#include <string>\n+#include <utility>\n+#include <algorithm> // lower_bound\n+#include <bits/allocator.h>\n+#include <bits/stl_function.h> // equal_to, _Identity, _Select1st\n+#include <type_traits>\n+#include <bits/functional_hash.h>\n+#include <bits/hashtable.h>\n+\n+#if defined(_GLIBCXX_INCLUDE_AS_CXX0X)\n+#  include <tr1_impl/unordered_map>\n+#else\n+#  define _GLIBCXX_INCLUDE_AS_CXX0X\n+#  define _GLIBCXX_BEGIN_NAMESPACE_TR1\n+#  define _GLIBCXX_END_NAMESPACE_TR1\n+#  define _GLIBCXX_TR1\n+#  include <tr1_impl/unordered_map>\n+#  undef _GLIBCXX_TR1\n+#  undef _GLIBCXX_END_NAMESPACE_TR1\n+#  undef _GLIBCXX_BEGIN_NAMESPACE_TR1\n+#  undef _GLIBCXX_INCLUDE_AS_CXX0X\n+#endif\n \n+#endif // _GLIBCXX_UNORDERED_MAP"}, {"sha": "dba781682ced798ee133cce181c434c163b9911b", "filename": "libstdc++-v3/include/std/unordered_set", "status": "modified", "additions": 29, "deletions": 4, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e133ace8d907bf42754c86106fc3f04a9d9fe70f/libstdc%2B%2B-v3%2Finclude%2Fstd%2Funordered_set", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e133ace8d907bf42754c86106fc3f04a9d9fe70f/libstdc%2B%2B-v3%2Finclude%2Fstd%2Funordered_set", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fstd%2Funordered_set?ref=e133ace8d907bf42754c86106fc3f04a9d9fe70f", "patch": "@@ -36,11 +36,36 @@\n \n #pragma GCC system_header\n \n-#ifdef __GXX_EXPERIMENTAL_CXX0X__\n-# include <tr1/unordered_set>\n-#else\n+#ifndef __GXX_EXPERIMENTAL_CXX0X__\n # include <c++0x_warning.h>\n #endif\n \n-#endif \n+#if defined(_GLIBCXX_INCLUDE_AS_TR1)\n+#  error C++0x header cannot be included from TR1 header\n+#endif\n+\n+#include <cmath>\n+#include <string>\n+#include <utility>\n+#include <algorithm> // lower_bound\n+#include <bits/allocator.h>\n+#include <bits/stl_function.h> // equal_to, _Identity, _Select1st\n+#include <type_traits>\n+#include <bits/functional_hash.h>\n+#include <bits/hashtable.h>\n+\n+#if defined(_GLIBCXX_INCLUDE_AS_CXX0X)\n+#  include <tr1_impl/unordered_set>\n+#else\n+#  define _GLIBCXX_INCLUDE_AS_CXX0X\n+#  define _GLIBCXX_BEGIN_NAMESPACE_TR1\n+#  define _GLIBCXX_END_NAMESPACE_TR1\n+#  define _GLIBCXX_TR1\n+#  include <tr1_impl/unordered_set>\n+#  undef _GLIBCXX_TR1\n+#  undef _GLIBCXX_END_NAMESPACE_TR1\n+#  undef _GLIBCXX_BEGIN_NAMESPACE_TR1\n+#  undef _GLIBCXX_INCLUDE_AS_CXX0X\n+#endif\n \n+#endif // _GLIBCXX_UNORDERED_SET"}, {"sha": "21440e5d90ea28dc7d454ae1d6b6193d64cf1a30", "filename": "libstdc++-v3/include/std/utility", "status": "modified", "additions": 16, "deletions": 1, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e133ace8d907bf42754c86106fc3f04a9d9fe70f/libstdc%2B%2B-v3%2Finclude%2Fstd%2Futility", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e133ace8d907bf42754c86106fc3f04a9d9fe70f/libstdc%2B%2B-v3%2Finclude%2Fstd%2Futility", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fstd%2Futility?ref=e133ace8d907bf42754c86106fc3f04a9d9fe70f", "patch": "@@ -67,7 +67,22 @@\n #include <bits/stl_pair.h>\n \n #ifdef __GXX_EXPERIMENTAL_CXX0X__\n-# include <tr1/utility>\n+#  if defined(_GLIBCXX_INCLUDE_AS_TR1)\n+#    error C++0x header cannot be included from TR1 header\n+#  endif\n+#  if defined(_GLIBCXX_INCLUDE_AS_CXX0X)\n+#    include <tr1_impl/utility>\n+#  else\n+#    define _GLIBCXX_INCLUDE_AS_CXX0X\n+#    define _GLIBCXX_BEGIN_NAMESPACE_TR1\n+#    define _GLIBCXX_END_NAMESPACE_TR1\n+#    define _GLIBCXX_TR1\n+#    include <tr1_impl/utility>\n+#    undef _GLIBCXX_TR1\n+#    undef _GLIBCXX_END_NAMESPACE_TR1\n+#    undef _GLIBCXX_BEGIN_NAMESPACE_TR1\n+#    undef _GLIBCXX_INCLUDE_AS_CXX0X\n+#  endif\n #endif\n \n #endif /* _GLIBCXX_UTILITY */"}, {"sha": "cca9520e51911c9b859f4f8c568e1ff104a7fa37", "filename": "libstdc++-v3/include/tr1/array", "status": "modified", "additions": 21, "deletions": 208, "changes": 229, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e133ace8d907bf42754c86106fc3f04a9d9fe70f/libstdc%2B%2B-v3%2Finclude%2Ftr1%2Farray", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e133ace8d907bf42754c86106fc3f04a9d9fe70f/libstdc%2B%2B-v3%2Finclude%2Ftr1%2Farray", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Ftr1%2Farray?ref=e133ace8d907bf42754c86106fc3f04a9d9fe70f", "patch": "@@ -31,216 +31,29 @@\n  *  This is a TR1 C++ Library header. \n  */\n \n-#ifndef _TR1_ARRAY\n-#define _TR1_ARRAY 1\n+#ifndef _GLIBCXX_TR1_ARRAY\n+#define _GLIBCXX_TR1_ARRAY 1\n \n-#include <bits/stl_algobase.h>\n-\n-//namespace std::tr1\n-namespace std\n-{\n-_GLIBCXX_BEGIN_NAMESPACE(_GLIBCXX_TR1)\n-\n-  /// @brief  struct array [6.2.2].\n-  /// NB: Requires complete type _Tp.\n-  template<typename _Tp, std::size_t _Nm>\n-    struct array\n-    {\n-      typedef _Tp \t    \t\t\t      value_type;\n-      typedef value_type&                   \t      reference;\n-      typedef const value_type&             \t      const_reference;\n-      typedef value_type*          \t\t      iterator;\n-      typedef const value_type*\t\t\t      const_iterator;\n-      typedef std::size_t                    \t      size_type;\n-      typedef std::ptrdiff_t                   \t      difference_type;\n-      typedef std::reverse_iterator<iterator>\t      reverse_iterator;\n-      typedef std::reverse_iterator<const_iterator>   const_reverse_iterator;\n-\n-      // Support for zero-sized arrays mandatory.\n-      value_type _M_instance[_Nm ? _Nm : 1] __attribute__((__aligned__));\n-\n-      // No explicit construct/copy/destroy for aggregate type.\n-\n-      void \n-      assign(const value_type& __u)\n-      { std::fill_n(begin(), size(), __u); }\n-\n-      void \n-      swap(array& __other)\n-      { std::swap_ranges(begin(), end(), __other.begin()); }\n-\n-      // Iterators.\n-      iterator\n-      begin()\n-      { return iterator(&_M_instance[0]); }\n-\n-      const_iterator\n-      begin() const \n-      { return const_iterator(&_M_instance[0]); }\n-\n-      iterator\n-      end() \n-      { return iterator(&_M_instance[_Nm]); }\n-\n-      const_iterator\n-      end() const\n-      { return const_iterator(&_M_instance[_Nm]); }\n-\n-      reverse_iterator \n-      rbegin()\n-      { return reverse_iterator(end()); }\n-\n-      const_reverse_iterator \n-      rbegin() const\n-      { return const_reverse_iterator(end()); }\n-\n-      reverse_iterator \n-      rend()\n-      { return reverse_iterator(begin()); }\n-\n-      const_reverse_iterator \n-      rend() const\n-      { return const_reverse_iterator(begin()); }\n-\n-      // Capacity.\n-      size_type \n-      size() const { return _Nm; }\n-\n-      size_type \n-      max_size() const { return _Nm; }\n-\n-      bool \n-      empty() const { return size() == 0; }\n-\n-      // Element access.\n-      reference\n-      operator[](size_type __n)\n-      { return _M_instance[__n]; }\n-\n-      const_reference\n-      operator[](size_type __n) const\n-      { return _M_instance[__n]; }\n-\n-      reference\n-      at(size_type __n)\n-      { \n-\t_M_check<_Nm>(__n);\n-\treturn _M_instance[__n];\n-      }\n-\n-      const_reference\n-      at(size_type __n) const\n-      {\n-\t_M_check<_Nm>(__n);\n-\treturn _M_instance[__n];\n-      }\n-\n-      reference \n-      front()\n-      { return *begin(); }\n+#pragma GCC system_header\n \n-      const_reference \n-      front() const\n-      { return *begin(); }\n-\n-      reference \n-      back()\n-      { return _Nm ? *(end() - 1) : *end(); }\n-\n-      const_reference \n-      back() const\n-      { return _Nm ? *(end() - 1) : *end(); }\n-\n-      _Tp* \n-      data()\n-      { return &_M_instance[0]; }\n-\n-      const _Tp* \n-      data() const\n-      { return &_M_instance[0]; }\n-\n-    private:\n-      template<std::size_t _Mm>\n-        typename __gnu_cxx::__enable_if<_Mm, void>::__type\n-        _M_check(size_type __n) const\n-        {\n-\t  if (__builtin_expect(__n >= _Mm, false))\n-\t    std::__throw_out_of_range(__N(\"array::_M_check\"));\n-\t}\n-\n-      // Avoid \"unsigned comparison with zero\" warnings.\n-      template<std::size_t _Mm>\n-        typename __gnu_cxx::__enable_if<!_Mm, void>::__type\n-        _M_check(size_type) const\n-        { std::__throw_out_of_range(__N(\"array::_M_check\")); }\n-    };\n-\n-  // Array comparisons.\n-  template<typename _Tp, std::size_t _Nm>\n-    inline bool \n-    operator==(const array<_Tp, _Nm>& __one, const array<_Tp, _Nm>& __two)\n-    { return std::equal(__one.begin(), __one.end(), __two.begin()); }\n-\n-  template<typename _Tp, std::size_t _Nm>\n-    inline bool\n-    operator!=(const array<_Tp, _Nm>& __one, const array<_Tp, _Nm>& __two)\n-    { return !(__one == __two); }\n-\n-  template<typename _Tp, std::size_t _Nm>\n-    inline bool\n-    operator<(const array<_Tp, _Nm>& __a, const array<_Tp, _Nm>& __b)\n-    { \n-      return std::lexicographical_compare(__a.begin(), __a.end(),\n-\t\t\t\t\t  __b.begin(), __b.end()); \n-    }\n-\n-  template<typename _Tp, std::size_t _Nm>\n-    inline bool\n-    operator>(const array<_Tp, _Nm>& __one, const array<_Tp, _Nm>& __two)\n-    { return __two < __one; }\n-\n-  template<typename _Tp, std::size_t _Nm>\n-    inline bool\n-    operator<=(const array<_Tp, _Nm>& __one, const array<_Tp, _Nm>& __two)\n-    { return !(__one > __two); }\n-\n-  template<typename _Tp, std::size_t _Nm>\n-    inline bool\n-    operator>=(const array<_Tp, _Nm>& __one, const array<_Tp, _Nm>& __two)\n-    { return !(__one < __two); }\n-\n-  // Specialized algorithms [6.2.2.2].\n-  template<typename _Tp, std::size_t _Nm>\n-    inline void\n-    swap(array<_Tp, _Nm>& __one, array<_Tp, _Nm>& __two)\n-    { std::swap_ranges(__one.begin(), __one.end(), __two.begin()); }\n-\n-  // Tuple interface to class template array [6.2.2.5].\n-  template<typename _Tp> class tuple_size;\n-  template<int _Int, typename _Tp> class tuple_element;\n-\n-  template<typename _Tp, std::size_t _Nm>\n-    struct tuple_size<array<_Tp, _Nm> >\n-    { static const int value = _Nm; };\n-\n-  template<typename _Tp, std::size_t _Nm>\n-    const int tuple_size<array<_Tp, _Nm> >::value;\n-\n-  template<int _Int, typename _Tp, std::size_t _Nm>\n-    struct tuple_element<_Int, array<_Tp, _Nm> >\n-    { typedef _Tp type; };\n-\n-  template<int _Int, typename _Tp, std::size_t _Nm>\n-    inline _Tp&\n-    get(array<_Tp, _Nm>& __arr)\n-    { return __arr[_Int]; }\n-\n-  template<int _Int, typename _Tp, std::size_t _Nm>\n-    inline const _Tp&\n-    get(const array<_Tp, _Nm>& __arr)\n-    { return __arr[_Int]; }\n+#if defined(_GLIBCXX_INCLUDE_AS_CXX0X)\n+#  error TR1 header cannot be included from C++0x header\n+#endif\n \n-_GLIBCXX_END_NAMESPACE\n-}\n+#include <bits/stl_algobase.h>\n \n+#if defined(_GLIBCXX_INCLUDE_AS_TR1)\n+#  include <tr1_impl/array>\n+#else\n+#  define _GLIBCXX_INCLUDE_AS_TR1\n+#  define _GLIBCXX_BEGIN_NAMESPACE_TR1 namespace tr1 {\n+#  define _GLIBCXX_END_NAMESPACE_TR1 }\n+#  define _GLIBCXX_TR1 tr1::\n+#  include <tr1_impl/array>\n+#  undef _GLIBCXX_TR1\n+#  undef _GLIBCXX_END_NAMESPACE_TR1\n+#  undef _GLIBCXX_BEGIN_NAMESPACE_TR1\n+#  undef _GLIBCXX_INCLUDE_AS_TR1\n #endif\n+\n+#endif // _GLIBCXX_TR1_ARRAY"}, {"sha": "eebafac41ce9eb139a0680b718b8f224da6b3140", "filename": "libstdc++-v3/include/tr1/bessel_function.tcc", "status": "modified", "additions": 10, "deletions": 9, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e133ace8d907bf42754c86106fc3f04a9d9fe70f/libstdc%2B%2B-v3%2Finclude%2Ftr1%2Fbessel_function.tcc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e133ace8d907bf42754c86106fc3f04a9d9fe70f/libstdc%2B%2B-v3%2Finclude%2Ftr1%2Fbessel_function.tcc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Ftr1%2Fbessel_function.tcc?ref=e133ace8d907bf42754c86106fc3f04a9d9fe70f", "patch": "@@ -49,14 +49,15 @@\n //       W. T. Vetterling, B. P. Flannery, Cambridge University Press (1992),\n //       2nd ed, pp. 240-245\n \n-#ifndef _TR1_BESSEL_FUNCTION_TCC\n-#define _TR1_BESSEL_FUNCTION_TCC 1\n+#ifndef _GLIBCXX_TR1_BESSEL_FUNCTION_TCC\n+#define _GLIBCXX_TR1_BESSEL_FUNCTION_TCC 1\n \n #include \"special_function_util.h\"\n \n namespace std\n {\n-_GLIBCXX_BEGIN_NAMESPACE(_GLIBCXX_TR1)\n+namespace tr1\n+{\n \n   // [5.2] Special functions\n \n@@ -102,8 +103,8 @@ _GLIBCXX_BEGIN_NAMESPACE(_GLIBCXX_TR1)\n                    _Tp & __gam1, _Tp & __gam2, _Tp & __gampl, _Tp & __gammi)\n     {\n #if _GLIBCXX_USE_C99_MATH_TR1\n-      __gampl = _Tp(1) / std::_GLIBCXX_TR1::tgamma(_Tp(1) + __mu);\n-      __gammi = _Tp(1) / std::_GLIBCXX_TR1::tgamma(_Tp(1) - __mu);\n+      __gampl = _Tp(1) / std::tr1::tgamma(_Tp(1) + __mu);\n+      __gammi = _Tp(1) / std::tr1::tgamma(_Tp(1) - __mu);\n #else\n       __gampl = _Tp(1) / __gamma(_Tp(1) + __mu);\n       __gammi = _Tp(1) / __gamma(_Tp(1) - __mu);\n@@ -318,7 +319,7 @@ _GLIBCXX_BEGIN_NAMESPACE(_GLIBCXX_TR1)\n           const _Tp __gam = (__p - __f) / __q;\n           __Jmu = std::sqrt(__w / ((__p - __f) * __gam + __q));\n #if _GLIBCXX_USE_C99_MATH_TR1\n-          __Jmu = std::_GLIBCXX_TR1::copysign(__Jmu, __Jnul);\n+          __Jmu = std::tr1::copysign(__Jmu, __Jnul);\n #else\n           if (__Jmu * __Jnul < _Tp(0))\n             __Jmu = -__Jmu;\n@@ -425,7 +426,7 @@ _GLIBCXX_BEGIN_NAMESPACE(_GLIBCXX_TR1)\n       const _Tp __x2 = __x / _Tp(2);\n       _Tp __fact = __nu * std::log(__x2);\n #if _GLIBCXX_USE_C99_MATH_TR1\n-      __fact -= std::_GLIBCXX_TR1::lgamma(__nu + _Tp(1));\n+      __fact -= std::tr1::lgamma(__nu + _Tp(1));\n #else\n       __fact -= __log_gamma(__nu + _Tp(1));\n #endif\n@@ -635,7 +636,7 @@ _GLIBCXX_BEGIN_NAMESPACE(_GLIBCXX_TR1)\n \n   /* @} */ // group tr1_math_spec_func\n \n-_GLIBCXX_END_NAMESPACE\n+}\n }\n \n-#endif // _TR1_BESSEL_FUNCTION_TCC\n+#endif // _GLIBCXX_TR1_BESSEL_FUNCTION_TCC"}, {"sha": "537947ed2877cb52da56c488139a8f68dffd7cc6", "filename": "libstdc++-v3/include/tr1/beta_function.tcc", "status": "modified", "additions": 15, "deletions": 14, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e133ace8d907bf42754c86106fc3f04a9d9fe70f/libstdc%2B%2B-v3%2Finclude%2Ftr1%2Fbeta_function.tcc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e133ace8d907bf42754c86106fc3f04a9d9fe70f/libstdc%2B%2B-v3%2Finclude%2Ftr1%2Fbeta_function.tcc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Ftr1%2Fbeta_function.tcc?ref=e133ace8d907bf42754c86106fc3f04a9d9fe70f", "patch": "@@ -49,12 +49,13 @@\n //   (4) Gamma, Exploring Euler's Constant, Julian Havil,\n //       Princeton, 2003.\n \n-#ifndef _TR1_BETA_FUNCTION_TCC\n-#define _TR1_BETA_FUNCTION_TCC 1\n+#ifndef _GLIBCXX_TR1_BETA_FUNCTION_TCC\n+#define _GLIBCXX_TR1_BETA_FUNCTION_TCC 1\n \n namespace std\n {\n-_GLIBCXX_BEGIN_NAMESPACE(_GLIBCXX_TR1)\n+namespace tr1\n+{\n \n   // [5.2] Special functions\n \n@@ -90,15 +91,15 @@ _GLIBCXX_BEGIN_NAMESPACE(_GLIBCXX_TR1)\n #if _GLIBCXX_USE_C99_MATH_TR1\n       if (__x > __y)\n         {\n-          __bet = std::_GLIBCXX_TR1::tgamma(__x)\n-                / std::_GLIBCXX_TR1::tgamma(__x + __y);\n-          __bet *= std::_GLIBCXX_TR1::tgamma(__y);\n+          __bet = std::tr1::tgamma(__x)\n+                / std::tr1::tgamma(__x + __y);\n+          __bet *= std::tr1::tgamma(__y);\n         }\n       else\n         {\n-          __bet = std::_GLIBCXX_TR1::tgamma(__y)\n-                / std::_GLIBCXX_TR1::tgamma(__x + __y);\n-          __bet *= std::_GLIBCXX_TR1::tgamma(__x);\n+          __bet = std::tr1::tgamma(__y)\n+                / std::tr1::tgamma(__x + __y);\n+          __bet *= std::tr1::tgamma(__x);\n         }\n #else\n       if (__x > __y)\n@@ -134,9 +135,9 @@ _GLIBCXX_BEGIN_NAMESPACE(_GLIBCXX_TR1)\n     __beta_lgamma(_Tp __x, _Tp __y)\n     {\n #if _GLIBCXX_USE_C99_MATH_TR1\n-      _Tp __bet = std::_GLIBCXX_TR1::lgamma(__x)\n-                + std::_GLIBCXX_TR1::lgamma(__y)\n-                - std::_GLIBCXX_TR1::lgamma(__x + __y);\n+      _Tp __bet = std::tr1::lgamma(__x)\n+                + std::tr1::lgamma(__y)\n+                - std::tr1::lgamma(__x + __y);\n #else\n       _Tp __bet = __log_gamma(__x)\n                 + __log_gamma(__y)\n@@ -205,7 +206,7 @@ _GLIBCXX_BEGIN_NAMESPACE(_GLIBCXX_TR1)\n \n   /* @} */ // group tr1_math_spec_func\n \n-_GLIBCXX_END_NAMESPACE\n+}\n }\n \n-#endif // _TR1_BETA_FUNCTION_TCC\n+#endif // __GLIBCXX_TR1_BETA_FUNCTION_TCC"}, {"sha": "98f2cdc1d9a820f7f9953159a04041d27b9f5d8c", "filename": "libstdc++-v3/include/tr1/ccomplex", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e133ace8d907bf42754c86106fc3f04a9d9fe70f/libstdc%2B%2B-v3%2Finclude%2Ftr1%2Fccomplex", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e133ace8d907bf42754c86106fc3f04a9d9fe70f/libstdc%2B%2B-v3%2Finclude%2Ftr1%2Fccomplex", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Ftr1%2Fccomplex?ref=e133ace8d907bf42754c86106fc3f04a9d9fe70f", "patch": "@@ -31,9 +31,9 @@\n  *  This is a TR1 C++ Library header. \n  */\n \n-#ifndef _TR1_CCOMPLEX\n-#define _TR1_CCOMPLEX 1\n+#ifndef _GLIBCXX_TR1_CCOMPLEX\n+#define _GLIBCXX_TR1_CCOMPLEX 1\n \n #include <tr1/complex>\n \n-#endif\n+#endif // _GLIBCXX_TR1_CCOMPLEX"}, {"sha": "72607d7fdab4302090054c54937eb73fb0fe5c19", "filename": "libstdc++-v3/include/tr1/cctype", "status": "modified", "additions": 16, "deletions": 18, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e133ace8d907bf42754c86106fc3f04a9d9fe70f/libstdc%2B%2B-v3%2Finclude%2Ftr1%2Fcctype", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e133ace8d907bf42754c86106fc3f04a9d9fe70f/libstdc%2B%2B-v3%2Finclude%2Ftr1%2Fcctype", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Ftr1%2Fcctype?ref=e133ace8d907bf42754c86106fc3f04a9d9fe70f", "patch": "@@ -1,6 +1,6 @@\n // TR1 cctype -*- C++ -*-\n \n-// Copyright (C) 2006 Free Software Foundation, Inc.\n+// Copyright (C) 2006, 2007 Free Software Foundation, Inc.\n //\n // This file is part of the GNU ISO C++ Library.  This library is free\n // software; you can redistribute it and/or modify it under the\n@@ -31,26 +31,24 @@\n  *  This is a TR1 C++ Library header. \n  */\n \n-#ifndef _TR1_CCTYPE\n-#define _TR1_CCTYPE 1\n+#ifndef _GLIBCXX_TR1_CCTYPE\n+#define _GLIBCXX_TR1_CCTYPE 1\n \n #include <bits/c++config.h>\n #include <cctype>\n \n-#if _GLIBCXX_USE_C99_CTYPE_TR1\n-\n-#undef isblank\n-\n-// namespace std::tr1\n-namespace std\n-{\n-_GLIBCXX_BEGIN_NAMESPACE(_GLIBCXX_TR1)\n-\n-  using ::isblank;\n-\n-_GLIBCXX_END_NAMESPACE\n-}\n-\n+#if defined(_GLIBCXX_INCLUDE_AS_TR1)\n+#  include <tr1_impl/cctype>\n+#else\n+#  define _GLIBCXX_INCLUDE_AS_TR1\n+#  define _GLIBCXX_BEGIN_NAMESPACE_TR1 namespace tr1 {\n+#  define _GLIBCXX_END_NAMESPACE_TR1 }\n+#  define _GLIBCXX_TR1 tr1::\n+#  include <tr1_impl/cctype>\n+#  undef _GLIBCXX_TR1\n+#  undef _GLIBCXX_END_NAMESPACE_TR1\n+#  undef _GLIBCXX_BEGIN_NAMESPACE_TR1\n+#  undef _GLIBCXX_INCLUDE_AS_TR1\n #endif\n \n-#endif\n+#endif // _GLIBCXX_TR1_CCTYPE"}, {"sha": "85447125decd06a8dc2e176c5e23b1ec935c4e94", "filename": "libstdc++-v3/include/tr1/cfenv", "status": "modified", "additions": 17, "deletions": 48, "changes": 65, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e133ace8d907bf42754c86106fc3f04a9d9fe70f/libstdc%2B%2B-v3%2Finclude%2Ftr1%2Fcfenv", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e133ace8d907bf42754c86106fc3f04a9d9fe70f/libstdc%2B%2B-v3%2Finclude%2Ftr1%2Fcfenv", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Ftr1%2Fcfenv?ref=e133ace8d907bf42754c86106fc3f04a9d9fe70f", "patch": "@@ -1,6 +1,6 @@\n-// TR1 cctype -*- C++ -*-\n+// TR1 cfenv -*- C++ -*-\n \n-// Copyright (C) 2006 Free Software Foundation, Inc.\n+// Copyright (C) 2006, 2007 Free Software Foundation, Inc.\n //\n // This file is part of the GNU ISO C++ Library.  This library is free\n // software; you can redistribute it and/or modify it under the\n@@ -31,54 +31,23 @@\n  *  This is a TR1 C++ Library header. \n  */\n \n-#ifndef _TR1_CFENV\n-#define _TR1_CFENV 1\n+#ifndef _GLIBCXX_TR1_CFENV\n+#define _GLIBCXX_TR1_CFENV 1\n \n #include <bits/c++config.h>\n \n-#if _GLIBCXX_USE_C99_FENV_TR1\n-\n-#include_next <fenv.h>\n-\n-#undef feclearexcept\n-#undef fegetexceptflag\n-#undef feraiseexcept\n-#undef fesetexceptflag\n-#undef fetestexcept\n-#undef fegetround\n-#undef fesetround\n-#undef fegetenv\n-#undef feholdexcept\n-#undef fesetenv\n-#undef feupdateenv\n-\n-// namespace std::tr1\n-namespace std\n-{\n-_GLIBCXX_BEGIN_NAMESPACE(_GLIBCXX_TR1)\n-\n-  // types\n-  using ::fenv_t;\n-  using ::fexcept_t;\n-\n-  // functions\n-  using ::feclearexcept;\n-  using ::fegetexceptflag;\n-  using ::feraiseexcept;\n-  using ::fesetexceptflag;\n-  using ::fetestexcept;\n-\n-  using ::fegetround;\n-  using ::fesetround;\n-\n-  using ::fegetenv;\n-  using ::feholdexcept;\n-  using ::fesetenv;\n-  using ::feupdateenv;\n-  \n-_GLIBCXX_END_NAMESPACE\n-}\n-\n+#if defined(_GLIBCXX_INCLUDE_AS_TR1)\n+#  include <tr1_impl/cfenv>\n+#else\n+#  define _GLIBCXX_INCLUDE_AS_TR1\n+#  define _GLIBCXX_BEGIN_NAMESPACE_TR1 namespace tr1 {\n+#  define _GLIBCXX_END_NAMESPACE_TR1 }\n+#  define _GLIBCXX_TR1 tr1::\n+#  include <tr1_impl/cfenv>\n+#  undef _GLIBCXX_TR1\n+#  undef _GLIBCXX_END_NAMESPACE_TR1\n+#  undef _GLIBCXX_BEGIN_NAMESPACE_TR1\n+#  undef _GLIBCXX_INCLUDE_AS_TR1\n #endif\n \n-#endif\n+#endif // _GLIBCXX_TR1_CFENV"}, {"sha": "86f3af8746cb0e64dcc639883a3a8fa35f5787d6", "filename": "libstdc++-v3/include/tr1/cfloat", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e133ace8d907bf42754c86106fc3f04a9d9fe70f/libstdc%2B%2B-v3%2Finclude%2Ftr1%2Fcfloat", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e133ace8d907bf42754c86106fc3f04a9d9fe70f/libstdc%2B%2B-v3%2Finclude%2Ftr1%2Fcfloat", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Ftr1%2Fcfloat?ref=e133ace8d907bf42754c86106fc3f04a9d9fe70f", "patch": "@@ -1,6 +1,6 @@\n // TR1 cfloat -*- C++ -*-\n \n-// Copyright (C) 2006 Free Software Foundation, Inc.\n+// Copyright (C) 2006, 2007 Free Software Foundation, Inc.\n //\n // This file is part of the GNU ISO C++ Library.  This library is free\n // software; you can redistribute it and/or modify it under the\n@@ -31,8 +31,8 @@\n  *  This is a TR1 C++ Library header. \n  */\n \n-#ifndef _TR1_CFLOAT\n-#define _TR1_CFLOAT 1\n+#ifndef _GLIBCXX_TR1_CFLOAT\n+#define _GLIBCXX_TR1_CFLOAT 1\n \n #include <cfloat>\n \n@@ -44,4 +44,4 @@\n #define FLT_EVAL_METHOD __FLT_EVAL_METHOD__\n #endif\n \n-#endif\n+#endif //_GLIBCXX_TR1_CFLOAT "}, {"sha": "19e2df32386db783f1d1b8887989d95bfe189160", "filename": "libstdc++-v3/include/tr1/cinttypes", "status": "modified", "additions": 15, "deletions": 43, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e133ace8d907bf42754c86106fc3f04a9d9fe70f/libstdc%2B%2B-v3%2Finclude%2Ftr1%2Fcinttypes", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e133ace8d907bf42754c86106fc3f04a9d9fe70f/libstdc%2B%2B-v3%2Finclude%2Ftr1%2Fcinttypes", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Ftr1%2Fcinttypes?ref=e133ace8d907bf42754c86106fc3f04a9d9fe70f", "patch": "@@ -31,51 +31,23 @@\n  *  This is a TR1 C++ Library header. \n  */\n \n-#ifndef _TR1_CINTTYPES\n-#define _TR1_CINTTYPES 1\n+#ifndef _GLIBCXX_TR1_CINTTYPES\n+#define _GLIBCXX_TR1_CINTTYPES 1\n \n-#include <bits/c++config.h>\n #include <tr1/cstdint>\n \n-#if _GLIBCXX_USE_C99_INTTYPES_TR1\n-\n-// For 8.11.1/1 (see C99, Note 184) \n-#define __STDC_FORMAT_MACROS\n-#include_next <inttypes.h>\n-\n-// namespace std::tr1\n-namespace std\n-{\n-_GLIBCXX_BEGIN_NAMESPACE(_GLIBCXX_TR1)\n-\n-  // types\n-  using ::imaxdiv_t;\n-\n-  // functions\n-  using ::imaxabs;\n-\n-  // May collide with _Longlong abs(_Longlong), and is not described\n-  // anywhere outside the synopsis.  Likely, a defect.\n-  //\n-  // intmax_t abs(intmax_t)\n-\n-  using ::imaxdiv;\n-\n-  // Likewise, with lldiv_t div(_Longlong, _Longlong).\n-  //\n-  // imaxdiv_t div(intmax_t, intmax_t)\n-\n-  using ::strtoimax;\n-  using ::strtoumax;\n-\n-#ifdef _GLIBCXX_USE_WCHAR_T\n-  using ::wcstoimax;\n-  using ::wcstoumax;\n-#endif\n-\n-_GLIBCXX_END_NAMESPACE\n-}\n-\n+#if defined(_GLIBCXX_INCLUDE_AS_TR1)\n+#  include <tr1_impl/cinttypes>\n+#else\n+#  define _GLIBCXX_INCLUDE_AS_TR1\n+#  define _GLIBCXX_BEGIN_NAMESPACE_TR1 namespace tr1 {\n+#  define _GLIBCXX_END_NAMESPACE_TR1 }\n+#  define _GLIBCXX_TR1 tr1::\n+#  include <tr1_impl/cinttypes>\n+#  undef _GLIBCXX_TR1\n+#  undef _GLIBCXX_END_NAMESPACE_TR1\n+#  undef _GLIBCXX_BEGIN_NAMESPACE_TR1\n+#  undef _GLIBCXX_INCLUDE_AS_TR1\n #endif\n \n-#endif\n+#endif // _GLIBCXX_TR1_CINTTYPES"}, {"sha": "9c7b0c5807cfa4658dc9da0bd386c1461fe3d65a", "filename": "libstdc++-v3/include/tr1/climits", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e133ace8d907bf42754c86106fc3f04a9d9fe70f/libstdc%2B%2B-v3%2Finclude%2Ftr1%2Fclimits", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e133ace8d907bf42754c86106fc3f04a9d9fe70f/libstdc%2B%2B-v3%2Finclude%2Ftr1%2Fclimits", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Ftr1%2Fclimits?ref=e133ace8d907bf42754c86106fc3f04a9d9fe70f", "patch": "@@ -1,6 +1,6 @@\n // TR1 climits -*- C++ -*-\n \n-// Copyright (C) 2006 Free Software Foundation, Inc.\n+// Copyright (C) 2006, 2007 Free Software Foundation, Inc.\n //\n // This file is part of the GNU ISO C++ Library.  This library is free\n // software; you can redistribute it and/or modify it under the\n@@ -31,8 +31,8 @@\n  *  This is a TR1 C++ Library header. \n  */\n \n-#ifndef _TR1_CLIMITS\n-#define _TR1_CLIMITS 1\n+#ifndef _GLIBCXX_TR1_CLIMITS\n+#define _GLIBCXX_TR1_CLIMITS 1\n \n #include <climits>\n \n@@ -48,4 +48,4 @@\n #define ULLONG_MAX __LONG_LONG_MAX__ * 2ULL + 1\n #endif\n \n-#endif\n+#endif // _GLIBCXX_TR1_CLIMITS"}, {"sha": "70d65f5c0a3fd0e9ffc956e4815bef21a97ab435", "filename": "libstdc++-v3/include/tr1/cmath", "status": "modified", "additions": 74, "deletions": 957, "changes": 1031, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e133ace8d907bf42754c86106fc3f04a9d9fe70f/libstdc%2B%2B-v3%2Finclude%2Ftr1%2Fcmath", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e133ace8d907bf42754c86106fc3f04a9d9fe70f/libstdc%2B%2B-v3%2Finclude%2Ftr1%2Fcmath", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Ftr1%2Fcmath?ref=e133ace8d907bf42754c86106fc3f04a9d9fe70f", "patch": "@@ -31,925 +31,42 @@\n  *  This is a TR1 C++ Library header. \n  */\n \n-#ifndef _TR1_CMATH\n-#define _TR1_CMATH 1\n+#ifndef _GLIBCXX_TR1_CMATH\n+#define _GLIBCXX_TR1_CMATH 1\n \n-#include <bits/c++config.h>\n-#include <bits/stl_algobase.h>\n-#include <limits>\n-#include <cmath>\n-#include <tr1/common.h>\n-\n-#if _GLIBCXX_USE_C99_MATH_TR1\n-\n-#undef acosh\n-#undef acoshf\n-#undef acoshl\n-#undef asinh\n-#undef asinhf\n-#undef asinhl\n-#undef atanh\n-#undef atanhf\n-#undef atanhl\n-#undef cbrt\n-#undef cbrtf\n-#undef cbrtl\n-#undef copysign\n-#undef copysignf\n-#undef copysignl\n-#undef erf\n-#undef erff\n-#undef erfl\n-#undef erfc\n-#undef erfcf\n-#undef erfcl\n-#undef exp2\n-#undef exp2f\n-#undef exp2l\n-#undef expm1\n-#undef expm1f\n-#undef expm1l\n-#undef fdim\n-#undef fdimf\n-#undef fdiml\n-#undef fma\n-#undef fmaf\n-#undef fmal\n-#undef fmax\n-#undef fmaxf\n-#undef fmaxl\n-#undef fmin\n-#undef fminf\n-#undef fminl\n-#undef hypot\n-#undef hypotf\n-#undef hypotl\n-#undef ilogb\n-#undef ilogbf\n-#undef ilogbl\n-#undef lgamma\n-#undef lgammaf\n-#undef lgammal\n-#undef llrint\n-#undef llrintf\n-#undef llrintl\n-#undef llround\n-#undef llroundf\n-#undef llroundl\n-#undef log1p\n-#undef log1pf\n-#undef log1pl\n-#undef log2\n-#undef log2f\n-#undef log2l\n-#undef logb\n-#undef logbf\n-#undef logbl\n-#undef lrint\n-#undef lrintf\n-#undef lrintl\n-#undef lround\n-#undef lroundf\n-#undef lroundl\n-#undef nan\n-#undef nanf\n-#undef nanl\n-#undef nearbyint\n-#undef nearbyintf\n-#undef nearbyintl\n-#undef nextafter\n-#undef nextafterf\n-#undef nextafterl\n-#undef nexttoward\n-#undef nexttowardf\n-#undef nexttowardl\n-#undef remainder\n-#undef remainderf\n-#undef remainderl\n-#undef remquo\n-#undef remquo\n-#undef remquo\n-#undef rint\n-#undef rintf\n-#undef rintl\n-#undef round\n-#undef roundf\n-#undef roundl\n-#undef scalbln\n-#undef scalblnf\n-#undef scalblnl\n-#undef scalbn\n-#undef scalbnf\n-#undef scalbnl\n-#undef tgamma\n-#undef tgammaf\n-#undef tgammal\n-#undef trunc\n-#undef truncf\n-#undef truncl\n+#pragma GCC system_header\n \n+#if defined(_GLIBCXX_INCLUDE_AS_CXX0X)\n+#  error TR1 header cannot be included from C++0x header\n #endif\n \n-// namespace std::tr1\n-namespace std\n-{\n-_GLIBCXX_BEGIN_NAMESPACE(_GLIBCXX_TR1)\n-\n-#if _GLIBCXX_USE_C99_MATH_TR1\n-\n-  // types\n-  using ::double_t;\n-  using ::float_t;\n-\n-  // functions\n-  using ::acosh;\n-  using ::acoshf;\n-  using ::acoshl;\n-\n-  using ::asinh;\n-  using ::asinhf;\n-  using ::asinhl;\n-\n-  using ::atanh;\n-  using ::atanhf;\n-  using ::atanhl;\n-\n-  using ::cbrt;\n-  using ::cbrtf;\n-  using ::cbrtl;\n-\n-  using ::copysign;\n-  using ::copysignf;\n-  using ::copysignl;\n-\n-  using ::erf;\n-  using ::erff;\n-  using ::erfl;\n-\n-  using ::erfc;\n-  using ::erfcf;\n-  using ::erfcl;\n-\n-  using ::exp2;\n-  using ::exp2f;\n-  using ::exp2l;\n-\n-  using ::expm1;\n-  using ::expm1f;\n-  using ::expm1l;\n-\n-  using ::fdim;\n-  using ::fdimf;\n-  using ::fdiml;\n-\n-  using ::fma;\n-  using ::fmaf;\n-  using ::fmal;\n-\n-  using ::fmax;\n-  using ::fmaxf;\n-  using ::fmaxl;\n-\n-  using ::fmin;\n-  using ::fminf;\n-  using ::fminl;\n-\n-  using ::hypot;\n-  using ::hypotf;\n-  using ::hypotl;\n-\n-  using ::ilogb;\n-  using ::ilogbf;\n-  using ::ilogbl;\n-\n-  using ::lgamma;\n-  using ::lgammaf;\n-  using ::lgammal;\n-\n-  using ::llrint;\n-  using ::llrintf;\n-  using ::llrintl;\n-\n-  using ::llround;\n-  using ::llroundf;\n-  using ::llroundl;\n-\n-  using ::log1p;\n-  using ::log1pf;\n-  using ::log1pl;\n-\n-  using ::log2;\n-  using ::log2f;\n-  using ::log2l;\n-\n-  using ::logb;\n-  using ::logbf;\n-  using ::logbl;\n-\n-  using ::lrint;\n-  using ::lrintf;\n-  using ::lrintl;\n-\n-  using ::lround;\n-  using ::lroundf;\n-  using ::lroundl;\n-\n-  using ::nan;\n-  using ::nanf;\n-  using ::nanl;\n-\n-  using ::nearbyint;\n-  using ::nearbyintf;\n-  using ::nearbyintl;\n-\n-  using ::nextafter;\n-  using ::nextafterf;\n-  using ::nextafterl;\n-\n-  using ::nexttoward;\n-  using ::nexttowardf;\n-  using ::nexttowardl;\n-\n-  using ::remainder;\n-  using ::remainderf;\n-  using ::remainderl;\n-\n-  using ::remquo;\n-  using ::remquo;\n-  using ::remquo;\n-\n-  using ::rint;\n-  using ::rintf;\n-  using ::rintl;\n-\n-  using ::round;\n-  using ::roundf;\n-  using ::roundl;\n-\n-  using ::scalbln;\n-  using ::scalblnf;\n-  using ::scalblnl;\n-\n-  using ::scalbn;\n-  using ::scalbnf;\n-  using ::scalbnl;\n-\n-  using ::tgamma;\n-  using ::tgammaf;\n-  using ::tgammal;\n-\n-  using ::trunc;\n-  using ::truncf;\n-  using ::truncl;\n-\n-#endif\n-\n-#if _GLIBCXX_USE_C99_MATH\n-#if !_GLIBCXX_USE_C99_FP_MACROS_DYNAMIC\n-\n-  /// @brief Function template definitions [8.16.3].\n-  //\n-  using std::signbit;\n-  \n-  using std::fpclassify;\n-\n-  using std::isfinite;\n-  using std::isinf;\n-  using std::isnan;\n-  using std::isnormal;\n-\n-  using std::isgreater;\n-  using std::isgreaterequal;\n-  using std::isless;\n-  using std::islessequal;\n-  using std::islessgreater;\n-  using std::isunordered;\n-#endif\n-#endif\n-\n-#if _GLIBCXX_USE_C99_MATH_TR1\n-\n-  /// @brief Additional overloads [8.16.4].\n-  //\n-  using std::acos;\n-\n-  inline float\n-  acosh(float __x)\n-  { return __builtin_acoshf(__x); }\n-\n-  inline long double\n-  acosh(long double __x)\n-  { return __builtin_acoshl(__x); }\n-\n-  template<typename _Tp>\n-    inline typename __promote<_Tp>::__type \n-    acosh(_Tp __x)\n-    {\n-      typedef typename __promote<_Tp>::__type __type;\n-      return acosh(__type(__x));\n-    }\n-\n-  using std::asin;\n-\n-  inline float\n-  asinh(float __x)\n-  { return __builtin_asinhf(__x); }\n-\n-  inline long double\n-  asinh(long double __x)\n-  { return __builtin_asinhl(__x); }\n-\n-  template<typename _Tp>\n-    inline typename __promote<_Tp>::__type \n-    asinh(_Tp __x)\n-    {\n-      typedef typename __promote<_Tp>::__type __type;\n-      return asinh(__type(__x));\n-    }\n-\n-  using std::atan;\n-\n-  // Workaround for c++/21682.\n-  namespace __detail\n-  {\n-    template<typename _Tp, typename _Up>\n-      inline typename\n-      __gnu_cxx::__enable_if<std::__is_floating<_Tp>::__value\n-                             || std::__is_floating<_Up>::__value,\n-\t\t\t     typename std::_GLIBCXX_TR1::\n-\t\t\t     __promote_2<_Tp, _Up>::__type>::__type\n-      atan2(_Tp __y, _Up __x)\n-      {\n-\ttypedef typename std::_GLIBCXX_TR1::__promote_2<_Tp, _Up>::__type\n-\t  __type;\n-\treturn std::atan2(__type(__y), __type(__x));\n-      }\n-  } // namespace __detail\n-\n-  using std::atan2;\n-  using __detail::atan2;\n- \n-  inline float\n-  atanh(float __x)\n-  { return __builtin_atanhf(__x); }\n-\n-  inline long double\n-  atanh(long double __x)\n-  { return __builtin_atanhl(__x); }\n-\n-  template<typename _Tp>\n-    inline typename __promote<_Tp>::__type \n-    atanh(_Tp __x)\n-    {\n-      typedef typename __promote<_Tp>::__type __type;\n-      return atanh(__type(__x));\n-    }\n-\n-  inline float\n-  cbrt(float __x)\n-  { return __builtin_cbrtf(__x); }\n-\n-  inline long double\n-  cbrt(long double __x)\n-  { return __builtin_cbrtl(__x); }\n-\n-  template<typename _Tp>\n-    inline typename __promote<_Tp>::__type \n-    cbrt(_Tp __x)\n-    {\n-      typedef typename __promote<_Tp>::__type __type;\n-      return cbrt(__type(__x));\n-    }\n-\n-  using std::ceil;\n-\n-  inline float\n-  copysign(float __x, float __y)\n-  { return __builtin_copysignf(__x, __y); }\n-\n-  inline long double\n-  copysign(long double __x, long double __y)\n-  { return __builtin_copysignl(__x, __y); }\n-\n-  template<typename _Tp, typename _Up>\n-    inline typename __promote_2<_Tp, _Up>::__type\n-    copysign(_Tp __x, _Up __y)\n-    {\n-      typedef typename __promote_2<_Tp, _Up>::__type __type;\n-      return copysign(__type(__x), __type(__y));\n-    }\n-\n-  using std::cos;\n-  using std::cosh;  \n-\n-  inline float\n-  erf(float __x)\n-  { return __builtin_erff(__x); }\n-\n-  inline long double\n-  erf(long double __x)\n-  { return __builtin_erfl(__x); }\n-\n-  template<typename _Tp>\n-    inline typename __promote<_Tp>::__type \n-    erf(_Tp __x)\n-    {\n-      typedef typename __promote<_Tp>::__type __type;\n-      return erf(__type(__x));\n-    }\n-\n-  inline float\n-  erfc(float __x)\n-  { return __builtin_erfcf(__x); }\n-\n-  inline long double\n-  erfc(long double __x)\n-  { return __builtin_erfcl(__x); }\n-\n-  template<typename _Tp>\n-    inline typename __promote<_Tp>::__type \n-    erfc(_Tp __x)\n-    {\n-      typedef typename __promote<_Tp>::__type __type;\n-      return erfc(__type(__x));\n-    }\n-\n-  using std::exp;\n-\n-  inline float\n-  exp2(float __x)\n-  { return __builtin_exp2f(__x); }\n-\n-  inline long double\n-  exp2(long double __x)\n-  { return __builtin_exp2l(__x); }\n-\n-  template<typename _Tp>\n-    inline typename __promote<_Tp>::__type \n-    exp2(_Tp __x)\n-    {\n-      typedef typename __promote<_Tp>::__type __type;\n-      return exp2(__type(__x));\n-    }\n-\n-  inline float\n-  expm1(float __x)\n-  { return __builtin_expm1f(__x); }\n-\n-  inline long double\n-  expm1(long double __x)\n-  { return __builtin_expm1l(__x); }\n-\n-  template<typename _Tp>\n-    inline typename __promote<_Tp>::__type \n-    expm1(_Tp __x)\n-    {\n-      typedef typename __promote<_Tp>::__type __type;\n-      return expm1(__type(__x));\n-    }\n-\n-  using std::fabs;\n-\n-  inline float\n-  fdim(float __x, float __y)\n-  { return __builtin_fdimf(__x, __y); }\n-\n-  inline long double\n-  fdim(long double __x, long double __y)\n-  { return __builtin_fdiml(__x, __y); }\n-\n-  template<typename _Tp, typename _Up>\n-    inline typename __promote_2<_Tp, _Up>::__type\n-    fdim(_Tp __x, _Up __y)\n-    {\n-      typedef typename __promote_2<_Tp, _Up>::__type __type;\n-      return fdim(__type(__x), __type(__y));\n-    }\n-\n-  using std::floor;\n-\n-  inline float\n-  fma(float __x, float __y, float __z)\n-  { return __builtin_fmaf(__x, __y, __z); }\n-\n-  inline long double\n-  fma(long double __x, long double __y, long double __z)\n-  { return __builtin_fmal(__x, __y, __z); }\n-\n-  template<typename _Tp, typename _Up, typename _Vp>\n-    inline typename __promote_3<_Tp, _Up, _Vp>::__type\n-    fma(_Tp __x, _Up __y, _Vp __z)\n-    {\n-      typedef typename __promote_3<_Tp, _Up, _Vp>::__type __type;\n-      return fma(__type(__x), __type(__y), __type(__z));\n-    }\n-\n-  inline float\n-  fmax(float __x, float __y)\n-  { return __builtin_fmaxf(__x, __y); }\n-\n-  inline long double\n-  fmax(long double __x, long double __y)\n-  { return __builtin_fmaxl(__x, __y); }\n-\n-  template<typename _Tp, typename _Up>\n-    inline typename __promote_2<_Tp, _Up>::__type\n-    fmax(_Tp __x, _Up __y)\n-    {\n-      typedef typename __promote_2<_Tp, _Up>::__type __type;\n-      return fmax(__type(__x), __type(__y));\n-    }\n-\n-  inline float\n-  fmin(float __x, float __y)\n-  { return __builtin_fminf(__x, __y); }\n-\n-  inline long double\n-  fmin(long double __x, long double __y)\n-  { return __builtin_fminl(__x, __y); }\n-\n-  template<typename _Tp, typename _Up>\n-    inline typename __promote_2<_Tp, _Up>::__type\n-    fmin(_Tp __x, _Up __y)\n-    {\n-      typedef typename __promote_2<_Tp, _Up>::__type __type;\n-      return fmin(__type(__x), __type(__y));\n-    }\n-\n-  using std::fmod;\n-  using std::frexp;\n-\n-  inline float\n-  hypot(float __x, float __y)\n-  { return __builtin_hypotf(__x, __y); }\n-\n-  inline long double\n-  hypot(long double __x, long double __y)\n-  { return __builtin_hypotl(__x, __y); }\n-\n-  template<typename _Tp, typename _Up>\n-    inline typename __promote_2<_Tp, _Up>::__type\n-    hypot(_Tp __x, _Up __y)\n-    {\n-      typedef typename __promote_2<_Tp, _Up>::__type __type;\n-      return hypot(__type(__x), __type(__y));\n-    }\n-\n-  inline int\n-  ilogb(float __x)\n-  { return __builtin_ilogbf(__x); }\n-\n-  inline int\n-  ilogb(long double __x)\n-  { return __builtin_ilogbl(__x); }\n-\n-  template<typename _Tp>\n-    inline int\n-    ilogb(_Tp __x)\n-    {\n-      typedef typename __promote<_Tp>::__type __type;\n-      return ilogb(__type(__x));\n-    }\n-\n-  using std::ldexp;\n-\n-  inline float\n-  lgamma(float __x)\n-  { return __builtin_lgammaf(__x); }\n-\n-  inline long double\n-  lgamma(long double __x)\n-  { return __builtin_lgammal(__x); }\n-\n-  template<typename _Tp>\n-    inline typename __promote<_Tp>::__type \n-    lgamma(_Tp __x)\n-    {\n-      typedef typename __promote<_Tp>::__type __type;\n-      return lgamma(__type(__x));\n-    }\n-\n-  inline long long\n-  llrint(float __x)\n-  { return __builtin_llrintf(__x); }\n-\n-  inline long long\n-  llrint(long double __x)\n-  { return __builtin_llrintl(__x); }\n-\n-  template<typename _Tp>\n-    inline long long\n-    llrint(_Tp __x)\n-    {\n-      typedef typename __promote<_Tp>::__type __type;\n-      return llrint(__type(__x));\n-    }\n-\n-  inline long long\n-  llround(float __x)\n-  { return __builtin_llroundf(__x); }\n-\n-  inline long long\n-  llround(long double __x)\n-  { return __builtin_llroundl(__x); }\n-\n-  template<typename _Tp>\n-    inline long long\n-    llround(_Tp __x)\n-    {\n-      typedef typename __promote<_Tp>::__type __type;\n-      return llround(__type(__x));\n-    }\n-\n-  using std::log;\n-  using std::log10;\n-\n-  inline float\n-  log1p(float __x)\n-  { return __builtin_log1pf(__x); }\n-\n-  inline long double\n-  log1p(long double __x)\n-  { return __builtin_log1pl(__x); }\n-\n-  template<typename _Tp>\n-    inline typename __promote<_Tp>::__type \n-    log1p(_Tp __x)\n-    {\n-      typedef typename __promote<_Tp>::__type __type;\n-      return log1p(__type(__x));\n-    }\n-\n-  // DR 568.\n-  inline float\n-  log2(float __x)\n-  { return __builtin_log2f(__x); }\n-\n-  inline long double\n-  log2(long double __x)\n-  { return __builtin_log2l(__x); }\n-\n-  template<typename _Tp>\n-    inline typename __promote<_Tp>::__type \n-    log2(_Tp __x)\n-    {\n-      typedef typename __promote<_Tp>::__type __type;\n-      return log2(__type(__x));\n-    }\n-\n-  inline float\n-  logb(float __x)\n-  { return __builtin_logbf(__x); }\n-\n-  inline long double\n-  logb(long double __x)\n-  { return __builtin_logbl(__x); }\n-\n-  template<typename _Tp>\n-    inline typename __promote<_Tp>::__type \n-    logb(_Tp __x)\n-    {\n-      typedef typename __promote<_Tp>::__type __type;\n-      return logb(__type(__x));\n-    }\n-\n-  inline long\n-  lrint(float __x)\n-  { return __builtin_lrintf(__x); }\n-\n-  inline long\n-  lrint(long double __x)\n-  { return __builtin_lrintl(__x); }\n-\n-  template<typename _Tp>\n-    inline long\n-    lrint(_Tp __x)\n-    {\n-      typedef typename __promote<_Tp>::__type __type;\n-      return lrint(__type(__x));\n-    }\n-\n-  inline long\n-  lround(float __x)\n-  { return __builtin_lroundf(__x); }\n-\n-  inline long\n-  lround(long double __x)\n-  { return __builtin_lroundl(__x); }\n-\n-  template<typename _Tp>\n-    inline long\n-    lround(_Tp __x)\n-    {\n-      typedef typename __promote<_Tp>::__type __type;\n-      return lround(__type(__x));\n-    }\n-\n-  inline float\n-  nearbyint(float __x)\n-  { return __builtin_nearbyintf(__x); }\n-\n-  inline long double\n-  nearbyint(long double __x)\n-  { return __builtin_nearbyintl(__x); }\n-\n-  template<typename _Tp>\n-    inline typename __promote<_Tp>::__type \n-    nearbyint(_Tp __x)\n-    {\n-      typedef typename __promote<_Tp>::__type __type;\n-      return nearbyint(__type(__x));\n-    }\n-\n-  inline float\n-  nextafter(float __x, float __y)\n-  { return __builtin_nextafterf(__x, __y); }\n-\n-  inline long double\n-  nextafter(long double __x, long double __y)\n-  { return __builtin_nextafterl(__x, __y); }\n-\n-  template<typename _Tp, typename _Up>\n-    inline typename __promote_2<_Tp, _Up>::__type\n-    nextafter(_Tp __x, _Up __y)\n-    {\n-      typedef typename __promote_2<_Tp, _Up>::__type __type;\n-      return nextafter(__type(__x), __type(__y));\n-    }\n-\n-  inline float\n-  nexttoward(float __x, long double __y)\n-  { return __builtin_nexttowardf(__x, __y); }\n-\n-  inline long double\n-  nexttoward(long double __x, long double __y)\n-  { return __builtin_nexttowardl(__x, __y); }\n-\n-  template<typename _Tp>\n-    inline typename __promote<_Tp>::__type\n-    nexttoward(_Tp __x, long double __y)\n-    {\n-      typedef typename __promote<_Tp>::__type __type;\n-      return nexttoward(__type(__x), __y);\n-    }\n-\n-  using std::pow;\n-\n-  // DR 550.\n-  template<typename _Tp, typename _Up>\n-    inline typename __promote_2<_Tp, _Up>::__type\n-    pow(_Tp __x, _Up __y)\n-    {\n-      typedef typename __promote_2<_Tp, _Up>::__type __type;\n-      return pow(__type(__x), __type(__y));\n-    }\n-\n-  inline float\n-  remainder(float __x, float __y)\n-  { return __builtin_remainderf(__x, __y); }\n-\n-  inline long double\n-  remainder(long double __x, long double __y)\n-  { return __builtin_remainderl(__x, __y); }\n-\n-  template<typename _Tp, typename _Up>\n-    inline typename __promote_2<_Tp, _Up>::__type\n-    remainder(_Tp __x, _Up __y)\n-    {\n-      typedef typename __promote_2<_Tp, _Up>::__type __type;\n-      return remainder(__type(__x), __type(__y));\n-    }\n-\n-  inline float\n-  remquo(float __x, float __y, int* __pquo)\n-  { return __builtin_remquof(__x, __y, __pquo); }\n-\n-  inline long double\n-  remquo(long double __x, long double __y, int* __pquo)\n-  { return __builtin_remquol(__x, __y, __pquo); }\n-\n-  template<typename _Tp, typename _Up>\n-    inline typename __promote_2<_Tp, _Up>::__type\n-    remquo(_Tp __x, _Up __y, int* __pquo)\n-    {\n-      typedef typename __promote_2<_Tp, _Up>::__type __type;\n-      return remquo(__type(__x), __type(__y), __pquo);\n-    }\n-\n-  inline float\n-  rint(float __x)\n-  { return __builtin_rintf(__x); }\n-\n-  inline long double\n-  rint(long double __x)\n-  { return __builtin_rintl(__x); }\n-\n-  template<typename _Tp>\n-    inline typename __promote<_Tp>::__type\n-    rint(_Tp __x)\n-    {\n-      typedef typename __promote<_Tp>::__type __type;\n-      return rint(__type(__x));\n-    }\n-\n-  inline float\n-  round(float __x)\n-  { return __builtin_roundf(__x); }\n-\n-  inline long double\n-  round(long double __x)\n-  { return __builtin_roundl(__x); }\n-\n-  template<typename _Tp>\n-    inline typename __promote<_Tp>::__type\n-    round(_Tp __x)\n-    {\n-      typedef typename __promote<_Tp>::__type __type;\n-      return round(__type(__x));\n-    }\n-\n-  inline float\n-  scalbln(float __x, long __ex)\n-  { return __builtin_scalblnf(__x, __ex); }\n-\n-  inline long double\n-  scalbln(long double __x, long __ex)\n-  { return __builtin_scalblnl(__x, __ex); }\n-\n-  template<typename _Tp>\n-    inline typename __promote<_Tp>::__type \n-    scalbln(_Tp __x, long __ex)\n-    {\n-      typedef typename __promote<_Tp>::__type __type;\n-      return scalbln(__type(__x), __ex);\n-    }\n- \n-  inline float\n-  scalbn(float __x, int __ex)\n-  { return __builtin_scalbnf(__x, __ex); }\n-\n-  inline long double\n-  scalbn(long double __x, int __ex)\n-  { return __builtin_scalbnl(__x, __ex); }\n-\n-  template<typename _Tp>\n-    inline typename __promote<_Tp>::__type \n-    scalbn(_Tp __x, int __ex)\n-    {\n-      typedef typename __promote<_Tp>::__type __type;\n-      return scalbn(__type(__x), __ex);\n-    }\n-\n-  using std::sin;\n-  using std::sinh;\n-  using std::sqrt;\n-  using std::tan;\n-  using std::tanh;\n-\n-  inline float\n-  tgamma(float __x)\n-  { return __builtin_tgammaf(__x); }\n-\n-  inline long double\n-  tgamma(long double __x)\n-  { return __builtin_tgammal(__x); }\n-\n-  template<typename _Tp>\n-    inline typename __promote<_Tp>::__type \n-    tgamma(_Tp __x)\n-    {\n-      typedef typename __promote<_Tp>::__type __type;\n-      return tgamma(__type(__x));\n-    }\n- \n-  inline float\n-  trunc(float __x)\n-  { return __builtin_truncf(__x); }\n-\n-  inline long double\n-  trunc(long double __x)\n-  { return __builtin_truncl(__x); }\n-\n-  template<typename _Tp>\n-    inline typename __promote<_Tp>::__type \n-    trunc(_Tp __x)\n-    {\n-      typedef typename __promote<_Tp>::__type __type;\n-      return trunc(__type(__x));\n-    }\n-\n+#include <cmath>\n+#include <ext/type_traits.h>\n+#include <tr1/type_traits>\n+\n+#if defined(_GLIBCXX_INCLUDE_AS_TR1)\n+#  include <tr1_impl/cmath>\n+#else\n+#  define _GLIBCXX_INCLUDE_AS_TR1\n+#  define _GLIBCXX_BEGIN_NAMESPACE_TR1 namespace tr1 {\n+#  define _GLIBCXX_END_NAMESPACE_TR1 }\n+#  define _GLIBCXX_TR1 tr1::\n+#  include <tr1_impl/cmath>\n+#  undef _GLIBCXX_TR1\n+#  undef _GLIBCXX_END_NAMESPACE_TR1\n+#  undef _GLIBCXX_BEGIN_NAMESPACE_TR1\n+#  undef _GLIBCXX_INCLUDE_AS_TR1\n #endif\n \n-_GLIBCXX_END_NAMESPACE\n-}\n-\n-\n /**\n  * @defgroup tr1_math_spec_func Mathematical Special Functions\n  * A collection of advanced mathematical special functions.\n  * @{\n  */\n #ifndef __GXX_EXPERIMENTAL_CXX0X__\n+#include <bits/stl_algobase.h>\n+#include <limits>\n+\n #include <tr1/gamma.tcc>\n #include <tr1/bessel_function.tcc>\n #include <tr1/beta_function.tcc>\n@@ -965,8 +82,8 @@ _GLIBCXX_END_NAMESPACE\n // namespace std::tr1\n namespace std\n {\n-_GLIBCXX_BEGIN_NAMESPACE(_GLIBCXX_TR1)\n-\n+namespace tr1\n+{\n   //  5.2.1.1  Associated Laguerre polynomials.\n \n   inline float\n@@ -980,10 +97,10 @@ _GLIBCXX_BEGIN_NAMESPACE(_GLIBCXX_TR1)\n   }\n \n   template<typename _Tp>\n-    inline typename __promote<_Tp>::__type\n+    inline typename __gnu_cxx::__promote<_Tp>::__type\n     assoc_laguerre(unsigned int __n, unsigned int __m, _Tp __x)\n     {\n-      typedef typename __promote<_Tp>::__type __type;\n+      typedef typename __gnu_cxx::__promote<_Tp>::__type __type;\n       return __detail::__assoc_laguerre<__type>(__n, __m, __x);\n     }\n \n@@ -999,10 +116,10 @@ _GLIBCXX_BEGIN_NAMESPACE(_GLIBCXX_TR1)\n   { return __detail::__assoc_legendre_p<long double>(__l, __m, __x); }\n \n   template<typename _Tp>\n-    inline typename __promote<_Tp>::__type\n+    inline typename __gnu_cxx::__promote<_Tp>::__type\n     assoc_legendre(unsigned int __l, unsigned int __m, _Tp __x)\n     {\n-      typedef typename __promote<_Tp>::__type __type;\n+      typedef typename __gnu_cxx::__promote<_Tp>::__type __type;\n       return __detail::__assoc_legendre_p<__type>(__l, __m, __x);\n     }\n \n@@ -1018,10 +135,10 @@ _GLIBCXX_BEGIN_NAMESPACE(_GLIBCXX_TR1)\n   { return __detail::__beta<long double>(__x, __y); }\n \n   template<typename _Tpx, typename _Tpy>\n-    inline typename __promote_2<_Tpx, _Tpy>::__type\n+    inline typename __gnu_cxx::__promote_2<_Tpx, _Tpy>::__type\n     beta(_Tpx __x, _Tpy __y)\n     {\n-      typedef typename __promote_2<_Tpx, _Tpy>::__type __type;\n+      typedef typename __gnu_cxx::__promote_2<_Tpx, _Tpy>::__type __type;\n       return __detail::__beta<__type>(__x, __y);\n     }\n \n@@ -1037,10 +154,10 @@ _GLIBCXX_BEGIN_NAMESPACE(_GLIBCXX_TR1)\n   { return __detail::__comp_ellint_1<long double>(__k); }\n \n   template<typename _Tp>\n-    inline typename __promote<_Tp>::__type\n+    inline typename __gnu_cxx::__promote<_Tp>::__type\n     comp_ellint_1(_Tp __k)\n     {\n-      typedef typename __promote<_Tp>::__type __type;\n+      typedef typename __gnu_cxx::__promote<_Tp>::__type __type;\n       return __detail::__comp_ellint_1<__type>(__k);\n     }\n \n@@ -1056,10 +173,10 @@ _GLIBCXX_BEGIN_NAMESPACE(_GLIBCXX_TR1)\n   { return __detail::__comp_ellint_2<long double>(__k); }\n \n   template<typename _Tp>\n-    inline typename __promote<_Tp>::__type\n+    inline typename __gnu_cxx::__promote<_Tp>::__type\n     comp_ellint_2(_Tp __k)\n     {\n-      typedef typename __promote<_Tp>::__type __type;\n+      typedef typename __gnu_cxx::__promote<_Tp>::__type __type;\n       return __detail::__comp_ellint_2<__type>(__k);\n     }\n \n@@ -1075,10 +192,10 @@ _GLIBCXX_BEGIN_NAMESPACE(_GLIBCXX_TR1)\n   { return __detail::__comp_ellint_3<long double>(__k, __nu); }\n \n   template<typename _Tp, typename _Tpn>\n-    inline typename __promote_2<_Tp, _Tpn>::__type\n+    inline typename __gnu_cxx::__promote_2<_Tp, _Tpn>::__type\n     comp_ellint_3(_Tp __k, _Tpn __nu)\n     {\n-      typedef typename __promote_2<_Tp, _Tpn>::__type __type;\n+      typedef typename __gnu_cxx::__promote_2<_Tp, _Tpn>::__type __type;\n       return __detail::__comp_ellint_3<__type>(__k, __nu);\n     }\n \n@@ -1094,10 +211,10 @@ _GLIBCXX_BEGIN_NAMESPACE(_GLIBCXX_TR1)\n   { return __detail::__conf_hyperg<long double>(__a, __c, __x); }\n \n   template<typename _Tpa, typename _Tpc, typename _Tp>\n-    inline typename __promote_3<_Tpa, _Tpc, _Tp>::__type\n+    inline typename __gnu_cxx::__promote_3<_Tpa, _Tpc, _Tp>::__type\n     conf_hyperg(_Tpa __a, _Tpc __c, _Tp __x)\n     {\n-      typedef typename __promote_3<_Tpa, _Tpc, _Tp>::__type __type;\n+      typedef typename __gnu_cxx::__promote_3<_Tpa, _Tpc, _Tp>::__type __type;\n       return __detail::__conf_hyperg<__type>(__a, __c, __x);\n     }\n \n@@ -1113,10 +230,10 @@ _GLIBCXX_BEGIN_NAMESPACE(_GLIBCXX_TR1)\n   { return __detail::__cyl_bessel_i<long double>(__nu, __x); }\n \n   template<typename _Tpnu, typename _Tp>\n-    inline typename __promote_2<_Tpnu, _Tp>::__type\n+    inline typename __gnu_cxx::__promote_2<_Tpnu, _Tp>::__type\n     cyl_bessel_i(_Tpnu __nu, _Tp __x)\n     {\n-      typedef typename __promote_2<_Tpnu, _Tp>::__type __type;\n+      typedef typename __gnu_cxx::__promote_2<_Tpnu, _Tp>::__type __type;\n       return __detail::__cyl_bessel_i<__type>(__nu, __x);\n     }\n \n@@ -1132,10 +249,10 @@ _GLIBCXX_BEGIN_NAMESPACE(_GLIBCXX_TR1)\n   { return __detail::__cyl_bessel_j<long double>(__nu, __x); }\n \n   template<typename _Tpnu, typename _Tp>\n-    inline typename __promote_2<_Tpnu, _Tp>::__type\n+    inline typename __gnu_cxx::__promote_2<_Tpnu, _Tp>::__type\n     cyl_bessel_j(_Tpnu __nu, _Tp __x)\n     {\n-      typedef typename __promote_2<_Tpnu, _Tp>::__type __type;\n+      typedef typename __gnu_cxx::__promote_2<_Tpnu, _Tp>::__type __type;\n       return __detail::__cyl_bessel_j<__type>(__nu, __x);\n     }\n \n@@ -1151,10 +268,10 @@ _GLIBCXX_BEGIN_NAMESPACE(_GLIBCXX_TR1)\n   { return __detail::__cyl_bessel_k<long double>(__nu, __x); }\n \n   template<typename _Tpnu, typename _Tp>\n-    inline typename __promote_2<_Tpnu, _Tp>::__type\n+    inline typename __gnu_cxx::__promote_2<_Tpnu, _Tp>::__type\n     cyl_bessel_k(_Tpnu __nu, _Tp __x)\n     {\n-      typedef typename __promote_2<_Tpnu, _Tp>::__type __type;\n+      typedef typename __gnu_cxx::__promote_2<_Tpnu, _Tp>::__type __type;\n       return __detail::__cyl_bessel_k<__type>(__nu, __x);\n     }\n \n@@ -1170,10 +287,10 @@ _GLIBCXX_BEGIN_NAMESPACE(_GLIBCXX_TR1)\n   { return __detail::__cyl_neumann_n<long double>(__nu, __x); }\n \n   template<typename _Tpnu, typename _Tp>\n-    inline typename __promote_2<_Tpnu, _Tp>::__type\n+    inline typename __gnu_cxx::__promote_2<_Tpnu, _Tp>::__type\n     cyl_neumann(_Tpnu __nu, _Tp __x)\n     {\n-      typedef typename __promote_2<_Tpnu, _Tp>::__type __type;\n+      typedef typename __gnu_cxx::__promote_2<_Tpnu, _Tp>::__type __type;\n       return __detail::__cyl_neumann_n<__type>(__nu, __x);\n     }\n \n@@ -1189,10 +306,10 @@ _GLIBCXX_BEGIN_NAMESPACE(_GLIBCXX_TR1)\n   { return __detail::__ellint_1<long double>(__k, __phi); }\n \n   template<typename _Tp, typename _Tpp>\n-    inline typename __promote_2<_Tp, _Tpp>::__type\n+    inline typename __gnu_cxx::__promote_2<_Tp, _Tpp>::__type\n     ellint_1(_Tp __k, _Tpp __phi)\n     {\n-      typedef typename __promote_2<_Tp, _Tpp>::__type __type;\n+      typedef typename __gnu_cxx::__promote_2<_Tp, _Tpp>::__type __type;\n       return __detail::__ellint_1<__type>(__k, __phi);\n     }\n \n@@ -1208,10 +325,10 @@ _GLIBCXX_BEGIN_NAMESPACE(_GLIBCXX_TR1)\n   { return __detail::__ellint_2<long double>(__k, __phi); }\n \n   template<typename _Tp, typename _Tpp>\n-    inline typename __promote_2<_Tp, _Tpp>::__type\n+    inline typename __gnu_cxx::__promote_2<_Tp, _Tpp>::__type\n     ellint_2(_Tp __k, _Tpp __phi)\n     {\n-      typedef typename __promote_2<_Tp, _Tpp>::__type __type;\n+      typedef typename __gnu_cxx::__promote_2<_Tp, _Tpp>::__type __type;\n       return __detail::__ellint_2<__type>(__k, __phi);\n     }\n \n@@ -1227,10 +344,10 @@ _GLIBCXX_BEGIN_NAMESPACE(_GLIBCXX_TR1)\n   { return __detail::__ellint_3<long double>(__k, __nu, __phi); }\n \n   template<typename _Tp, typename _Tpn, typename _Tpp>\n-    inline typename __promote_3<_Tp, _Tpn, _Tpp>::__type\n+    inline typename __gnu_cxx::__promote_3<_Tp, _Tpn, _Tpp>::__type\n     ellint_3(_Tp __k, _Tpn __nu, _Tpp __phi)\n     {\n-      typedef typename __promote_3<_Tp, _Tpn, _Tpp>::__type __type;\n+      typedef typename __gnu_cxx::__promote_3<_Tp, _Tpn, _Tpp>::__type __type;\n       return __detail::__ellint_3<__type>(__k, __nu, __phi);\n     }\n \n@@ -1246,10 +363,10 @@ _GLIBCXX_BEGIN_NAMESPACE(_GLIBCXX_TR1)\n   { return __detail::__expint<long double>(__x); }\n \n   template<typename _Tp>\n-    inline typename __promote<_Tp>::__type\n+    inline typename __gnu_cxx::__promote<_Tp>::__type\n     expint(_Tp __x)\n     {\n-      typedef typename __promote<_Tp>::__type __type;\n+      typedef typename __gnu_cxx::__promote<_Tp>::__type __type;\n       return __detail::__expint<__type>(__x);\n     }\n \n@@ -1265,10 +382,10 @@ _GLIBCXX_BEGIN_NAMESPACE(_GLIBCXX_TR1)\n   { return __detail::__poly_hermite<long double>(__n, __x); }\n \n   template<typename _Tp>\n-    inline typename __promote<_Tp>::__type\n+    inline typename __gnu_cxx::__promote<_Tp>::__type\n     hermite(unsigned int __n, _Tp __x)\n     {\n-      typedef typename __promote<_Tp>::__type __type;\n+      typedef typename __gnu_cxx::__promote<_Tp>::__type __type;\n       return __detail::__poly_hermite<__type>(__n, __x);\n     }\n \n@@ -1284,10 +401,10 @@ _GLIBCXX_BEGIN_NAMESPACE(_GLIBCXX_TR1)\n   { return __detail::__hyperg<long double>(__a, __b, __c, __x); }\n \n   template<typename _Tpa, typename _Tpb, typename _Tpc, typename _Tp>\n-    inline typename __promote_4<_Tpa, _Tpb, _Tpc, _Tp>::__type\n+    inline typename __gnu_cxx::__promote_4<_Tpa, _Tpb, _Tpc, _Tp>::__type\n     hyperg(_Tpa __a, _Tpb __b, _Tpc __c, _Tp __x)\n     {\n-      typedef typename __promote_4<_Tpa, _Tpb, _Tpc, _Tp>::__type __type;\n+      typedef typename __gnu_cxx::__promote_4<_Tpa, _Tpb, _Tpc, _Tp>::__type __type;\n       return __detail::__hyperg<__type>(__a, __b, __c, __x);\n     }\n \n@@ -1303,10 +420,10 @@ _GLIBCXX_BEGIN_NAMESPACE(_GLIBCXX_TR1)\n   { return __detail::__laguerre<long double>(__n, __x); }\n \n   template<typename _Tp>\n-    inline typename __promote<_Tp>::__type\n+    inline typename __gnu_cxx::__promote<_Tp>::__type\n     laguerre(unsigned int __n, _Tp __x)\n     {\n-      typedef typename __promote<_Tp>::__type __type;\n+      typedef typename __gnu_cxx::__promote<_Tp>::__type __type;\n       return __detail::__laguerre<__type>(__n, __x);\n     }\n \n@@ -1322,10 +439,10 @@ _GLIBCXX_BEGIN_NAMESPACE(_GLIBCXX_TR1)\n   { return __detail::__poly_legendre_p<long double>(__n, __x); }\n \n   template<typename _Tp>\n-    inline typename __promote<_Tp>::__type\n+    inline typename __gnu_cxx::__promote<_Tp>::__type\n     legendre(unsigned int __n, _Tp __x)\n     {\n-      typedef typename __promote<_Tp>::__type __type;\n+      typedef typename __gnu_cxx::__promote<_Tp>::__type __type;\n       return __detail::__poly_legendre_p<__type>(__n, __x);\n     }\n \n@@ -1341,10 +458,10 @@ _GLIBCXX_BEGIN_NAMESPACE(_GLIBCXX_TR1)\n   { return __detail::__riemann_zeta<long double>(__x); }\n \n   template<typename _Tp>\n-    inline typename __promote<_Tp>::__type\n+    inline typename __gnu_cxx::__promote<_Tp>::__type\n     riemann_zeta(_Tp __x)\n     {\n-      typedef typename __promote<_Tp>::__type __type;\n+      typedef typename __gnu_cxx::__promote<_Tp>::__type __type;\n       return __detail::__riemann_zeta<__type>(__x);\n     }\n \n@@ -1360,10 +477,10 @@ _GLIBCXX_BEGIN_NAMESPACE(_GLIBCXX_TR1)\n   { return __detail::__sph_bessel<long double>(__n, __x); }\n \n   template<typename _Tp>\n-    inline typename __promote<_Tp>::__type\n+    inline typename __gnu_cxx::__promote<_Tp>::__type\n     sph_bessel(unsigned int __n, _Tp __x)\n     {\n-      typedef typename __promote<_Tp>::__type __type;\n+      typedef typename __gnu_cxx::__promote<_Tp>::__type __type;\n       return __detail::__sph_bessel<__type>(__n, __x);\n     }\n \n@@ -1379,10 +496,10 @@ _GLIBCXX_BEGIN_NAMESPACE(_GLIBCXX_TR1)\n   { return __detail::__sph_legendre<long double>(__l, __m, __theta); }\n \n   template<typename _Tp>\n-    inline typename __promote<_Tp>::__type\n+    inline typename __gnu_cxx::__promote<_Tp>::__type\n     sph_legendre(unsigned int __l, unsigned int __m, _Tp __theta)\n     {\n-      typedef typename __promote<_Tp>::__type __type;\n+      typedef typename __gnu_cxx::__promote<_Tp>::__type __type;\n       return __detail::__sph_legendre<__type>(__l, __m, __theta);\n     }\n \n@@ -1398,18 +515,18 @@ _GLIBCXX_BEGIN_NAMESPACE(_GLIBCXX_TR1)\n   { return __detail::__sph_neumann<long double>(__n, __x); }\n \n   template<typename _Tp>\n-    inline typename __promote<_Tp>::__type\n+    inline typename __gnu_cxx::__promote<_Tp>::__type\n     sph_neumann(unsigned int __n, _Tp __x)\n     {\n-      typedef typename __promote<_Tp>::__type __type;\n+      typedef typename __gnu_cxx::__promote<_Tp>::__type __type;\n       return __detail::__sph_neumann<__type>(__n, __x);\n     }\n \n   /* @} */ // group tr1_math_spec_func\n \n-_GLIBCXX_END_NAMESPACE\n+}\n }\n \n #endif // __GXX_EXPERIMENTAL_CXX0X__\n \n-#endif\n+#endif // _GLIBCXX_TR1_CMATH"}, {"sha": "d26fdd6da5ce46f23686f1ba6d2ad48fbe4bdf9a", "filename": "libstdc++-v3/include/tr1/common.h", "status": "removed", "additions": 0, "deletions": 91, "changes": 91, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9cbff7e7d94be033fa30d1dba49b8036adfffcb4/libstdc%2B%2B-v3%2Finclude%2Ftr1%2Fcommon.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9cbff7e7d94be033fa30d1dba49b8036adfffcb4/libstdc%2B%2B-v3%2Finclude%2Ftr1%2Fcommon.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Ftr1%2Fcommon.h?ref=9cbff7e7d94be033fa30d1dba49b8036adfffcb4", "patch": "@@ -1,91 +0,0 @@\n-// Internal header for TR1 complex -*- C++ -*-\n-\n-// Copyright (C) 2006 Free Software Foundation, Inc.\n-//\n-// This file is part of the GNU ISO C++ Library.  This library is free\n-// software; you can redistribute it and/or modify it under the\n-// terms of the GNU General Public License as published by the\n-// Free Software Foundation; either version 2, or (at your option)\n-// any later version.\n-\n-// This library is distributed in the hope that it will be useful,\n-// but WITHOUT ANY WARRANTY; without even the implied warranty of\n-// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-// GNU General Public License for more details.\n-\n-// You should have received a copy of the GNU General Public License along\n-// with this library; see the file COPYING.  If not, write to the Free\n-// Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301,\n-// USA.\n-\n-// As a special exception, you may use this file as part of a free software\n-// library without restriction.  Specifically, if other files instantiate\n-// templates or use macros or inline functions from this file, or you compile\n-// this file and link it with other files to produce an executable, this\n-// file does not by itself cause the resulting executable to be covered by\n-// the GNU General Public License.  This exception does not however\n-// invalidate any other reasons why the executable file might be covered by\n-// the GNU General Public License.\n-\n-/** @file tr1/common.h\n- *  This is a TR1 C++ Library header. \n- */\n-\n-#ifndef _TR1_COMMON_H\n-#define _TR1_COMMON_H 1\n-\n-#include <tr1/type_traits>\n-\n-// namespace std::tr1\n-namespace std\n-{\n-_GLIBCXX_BEGIN_NAMESPACE(_GLIBCXX_TR1)\n-\n-  template<typename _Tp, bool = is_integral<_Tp>::value>\n-    struct __promote\n-    { typedef double __type; };\n-\n-  template<typename _Tp>\n-    struct __promote<_Tp, false>\n-    { typedef _Tp __type; };\n-\n-  template<typename _Tp, typename _Up>\n-    struct __promote_2\n-    {\n-    private:\n-      typedef typename __promote<_Tp>::__type __type1;\n-      typedef typename __promote<_Up>::__type __type2;\n-\n-    public:\n-      typedef __typeof__(__type1() + __type2()) __type;\n-    };\n-\n-  template<typename _Tp, typename _Up, typename _Vp>\n-    struct __promote_3\n-    {\n-    private:\n-      typedef typename __promote<_Tp>::__type __type1;\n-      typedef typename __promote<_Up>::__type __type2;\n-      typedef typename __promote<_Vp>::__type __type3;\n-\n-    public:\n-      typedef __typeof__(__type1() + __type2() + __type3()) __type;\n-    };\n-\n-  template<typename _Tp, typename _Up, typename _Vp, typename _Wp>\n-    struct __promote_4\n-    {\n-    private:\n-      typedef typename __promote<_Tp>::__type __type1;\n-      typedef typename __promote<_Up>::__type __type2;\n-      typedef typename __promote<_Vp>::__type __type3;\n-      typedef typename __promote<_Wp>::__type __type4;\n-\n-    public:\n-      typedef __typeof__(__type1() + __type2() + __type3() + __type4()) __type;\n-    };\n-\n-_GLIBCXX_END_NAMESPACE\n-} // namespace std\n-\n-#endif"}, {"sha": "ef21129ba4f50a5ac7ea97dbd10f26faf31eb184", "filename": "libstdc++-v3/include/tr1/complex", "status": "modified", "additions": 26, "deletions": 359, "changes": 385, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e133ace8d907bf42754c86106fc3f04a9d9fe70f/libstdc%2B%2B-v3%2Finclude%2Ftr1%2Fcomplex", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e133ace8d907bf42754c86106fc3f04a9d9fe70f/libstdc%2B%2B-v3%2Finclude%2Ftr1%2Fcomplex", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Ftr1%2Fcomplex?ref=e133ace8d907bf42754c86106fc3f04a9d9fe70f", "patch": "@@ -31,379 +31,46 @@\n  *  This is a TR1 C++ Library header. \n  */\n \n-#ifndef _TR1_COMPLEX\n-#define _TR1_COMPLEX 1\n+#ifndef _GLIBCXX_TR1_COMPLEX\n+#define _GLIBCXX_TR1_COMPLEX 1\n \n-#include <complex>\n-#include <tr1/common.h>\n-\n-// namespace std::tr1\n-namespace std\n-{\n-_GLIBCXX_BEGIN_NAMESPACE(_GLIBCXX_TR1)\n-\n-  // Forward declarations.\n-  template<typename _Tp> std::complex<_Tp> acos(const std::complex<_Tp>&);\n-  template<typename _Tp> std::complex<_Tp> asin(const std::complex<_Tp>&);\n-  template<typename _Tp> std::complex<_Tp> atan(const std::complex<_Tp>&);\n-\n-  template<typename _Tp> std::complex<_Tp> acosh(const std::complex<_Tp>&);\n-  template<typename _Tp> std::complex<_Tp> asinh(const std::complex<_Tp>&);\n-  template<typename _Tp> std::complex<_Tp> atanh(const std::complex<_Tp>&);\n-  template<typename _Tp> std::complex<_Tp> fabs(const std::complex<_Tp>&);\n-\n-  /// @brief acos(__z) [8.1.2].\n-  //  Effects:  Behaves the same as C99 function cacos, defined\n-  //            in subclause 7.3.5.1.\n-  template<typename _Tp>\n-    inline std::complex<_Tp>\n-    __complex_acos(const std::complex<_Tp>& __z)\n-    {\n-      const std::complex<_Tp> __t = std::_GLIBCXX_TR1::asin(__z);\n-      const _Tp __pi_2 = 1.5707963267948966192313216916397514L;\n-      return std::complex<_Tp>(__pi_2 - __t.real(), -__t.imag());\n-    }\n-\n-#if _GLIBCXX_USE_C99_COMPLEX_TR1\n-  inline __complex__ float\n-  __complex_acos(__complex__ float __z)\n-  { return __builtin_cacosf(__z); }\n-\n-  inline __complex__ double\n-  __complex_acos(__complex__ double __z)\n-  { return __builtin_cacos(__z); }\n-\n-  inline __complex__ long double\n-  __complex_acos(const __complex__ long double& __z)\n-  { return __builtin_cacosl(__z); }\n-\n-  template<typename _Tp>\n-    inline std::complex<_Tp>\n-    acos(const std::complex<_Tp>& __z)\n-    { return __complex_acos(__z.__rep()); }\n-#else\n-  template<typename _Tp>\n-    inline std::complex<_Tp>\n-    acos(const std::complex<_Tp>& __z)\n-    { return __complex_acos(__z); }\n-#endif\n-\n-  /// @brief asin(__z) [8.1.3].\n-  //  Effects:  Behaves the same as C99 function casin, defined\n-  //            in subclause 7.3.5.2.\n-  template<typename _Tp>\n-    inline std::complex<_Tp>\n-    __complex_asin(const std::complex<_Tp>& __z)\n-    {\n-      std::complex<_Tp> __t(-__z.imag(), __z.real());\n-      __t = std::_GLIBCXX_TR1::asinh(__t);\n-      return std::complex<_Tp>(__t.imag(), -__t.real());\n-    }\n-\n-#if _GLIBCXX_USE_C99_COMPLEX_TR1\n-  inline __complex__ float\n-  __complex_asin(__complex__ float __z)\n-  { return __builtin_casinf(__z); }\n-\n-  inline __complex__ double\n-  __complex_asin(__complex__ double __z)\n-  { return __builtin_casin(__z); }\n-\n-  inline __complex__ long double\n-  __complex_asin(const __complex__ long double& __z)\n-  { return __builtin_casinl(__z); }\n-\n-  template<typename _Tp>\n-    inline std::complex<_Tp>\n-    asin(const std::complex<_Tp>& __z)\n-    { return __complex_asin(__z.__rep()); }\n-#else\n-  template<typename _Tp>\n-    inline std::complex<_Tp>\n-    asin(const std::complex<_Tp>& __z)\n-    { return __complex_asin(__z); }\n-#endif\n-  \n-  /// @brief atan(__z) [8.1.4].\n-  //  Effects:  Behaves the same as C99 function catan, defined\n-  //            in subclause 7.3.5.3.\n-  template<typename _Tp>\n-    std::complex<_Tp>\n-    __complex_atan(const std::complex<_Tp>& __z)\n-    {\n-      const _Tp __r2 = __z.real() * __z.real();\n-      const _Tp __x = _Tp(1.0) - __r2 - __z.imag() * __z.imag();\n-\n-      _Tp __num = __z.imag() + _Tp(1.0);\n-      _Tp __den = __z.imag() - _Tp(1.0);\n-\n-      __num = __r2 + __num * __num;\n-      __den = __r2 + __den * __den;\n-\n-      return std::complex<_Tp>(_Tp(0.5) * atan2(_Tp(2.0) * __z.real(), __x),\n-\t\t\t       _Tp(0.25) * log(__num / __den));\n-    }\n-\n-#if _GLIBCXX_USE_C99_COMPLEX_TR1\n-  inline __complex__ float\n-  __complex_atan(__complex__ float __z)\n-  { return __builtin_catanf(__z); }\n-\n-  inline __complex__ double\n-  __complex_atan(__complex__ double __z)\n-  { return __builtin_catan(__z); }\n-\n-  inline __complex__ long double\n-  __complex_atan(const __complex__ long double& __z)\n-  { return __builtin_catanl(__z); }\n-\n-  template<typename _Tp>\n-    inline std::complex<_Tp>\n-    atan(const std::complex<_Tp>& __z)\n-    { return __complex_atan(__z.__rep()); }\n-#else\n-  template<typename _Tp>\n-    inline std::complex<_Tp>\n-    atan(const std::complex<_Tp>& __z)\n-    { return __complex_atan(__z); }\n-#endif\n-\n-  /// @brief acosh(__z) [8.1.5].\n-  //  Effects:  Behaves the same as C99 function cacosh, defined\n-  //            in subclause 7.3.6.1.\n-  template<typename _Tp>\n-    std::complex<_Tp>\n-    __complex_acosh(const std::complex<_Tp>& __z)\n-    {\n-      std::complex<_Tp> __t((__z.real() - __z.imag())\n-\t\t\t    * (__z.real() + __z.imag()) - _Tp(1.0),\n-\t\t\t    _Tp(2.0) * __z.real() * __z.imag());\n-      __t = std::sqrt(__t);\n-\n-      return std::log(__t + __z);\n-    }\n-\n-#if _GLIBCXX_USE_C99_COMPLEX_TR1\n-  inline __complex__ float\n-  __complex_acosh(__complex__ float __z)\n-  { return __builtin_cacoshf(__z); }\n-\n-  inline __complex__ double\n-  __complex_acosh(__complex__ double __z)\n-  { return __builtin_cacosh(__z); }\n-\n-  inline __complex__ long double\n-  __complex_acosh(const __complex__ long double& __z)\n-  { return __builtin_cacoshl(__z); }\n-\n-  template<typename _Tp>\n-    inline std::complex<_Tp>\n-    acosh(const std::complex<_Tp>& __z)\n-    { return __complex_acosh(__z.__rep()); }\n-#else\n-  template<typename _Tp>\n-    inline std::complex<_Tp>\n-    acosh(const std::complex<_Tp>& __z)\n-    { return __complex_acosh(__z); }\n-#endif\n-\n-  /// @brief asinh(__z) [8.1.6].\n-  //  Effects:  Behaves the same as C99 function casin, defined\n-  //            in subclause 7.3.6.2.\n-  template<typename _Tp>\n-    std::complex<_Tp>\n-    __complex_asinh(const std::complex<_Tp>& __z)\n-    {\n-      std::complex<_Tp> __t((__z.real() - __z.imag())\n-\t\t\t    * (__z.real() + __z.imag()) + _Tp(1.0),\n-\t\t\t    _Tp(2.0) * __z.real() * __z.imag());\n-      __t = std::sqrt(__t);\n+#pragma GCC system_header\n \n-      return std::log(__t + __z);\n-    }\n-\n-#if _GLIBCXX_USE_C99_COMPLEX_TR1\n-  inline __complex__ float\n-  __complex_asinh(__complex__ float __z)\n-  { return __builtin_casinhf(__z); }\n-\n-  inline __complex__ double\n-  __complex_asinh(__complex__ double __z)\n-  { return __builtin_casinh(__z); }\n-\n-  inline __complex__ long double\n-  __complex_asinh(const __complex__ long double& __z)\n-  { return __builtin_casinhl(__z); }\n-\n-  template<typename _Tp>\n-    inline std::complex<_Tp>\n-    asinh(const std::complex<_Tp>& __z)\n-    { return __complex_asinh(__z.__rep()); }\n-#else\n-  template<typename _Tp>\n-    inline std::complex<_Tp>\n-    asinh(const std::complex<_Tp>& __z)\n-    { return __complex_asinh(__z); }\n+#if defined(_GLIBCXX_INCLUDE_AS_CXX0X)\n+#  error TR1 header cannot be included from C++0x header\n #endif\n \n-  /// @brief atanh(__z) [8.1.7].\n-  //  Effects:  Behaves the same as C99 function catanh, defined\n-  //            in subclause 7.3.6.3.\n-  template<typename _Tp>\n-    std::complex<_Tp>\n-    __complex_atanh(const std::complex<_Tp>& __z)\n-    {\n-      const _Tp __i2 = __z.imag() * __z.imag();\n-      const _Tp __x = _Tp(1.0) - __i2 - __z.real() * __z.real();\n-\n-      _Tp __num = _Tp(1.0) + __z.real();\n-      _Tp __den = _Tp(1.0) - __z.real();\n-\n-      __num = __i2 + __num * __num;\n-      __den = __i2 + __den * __den;\n-\n-      return std::complex<_Tp>(_Tp(0.25) * (log(__num) - log(__den)),\n-\t\t\t       _Tp(0.5) * atan2(_Tp(2.0) * __z.imag(), __x));\n-    }\n-\n-#if _GLIBCXX_USE_C99_COMPLEX_TR1\n-  inline __complex__ float\n-  __complex_atanh(__complex__ float __z)\n-  { return __builtin_catanhf(__z); }\n-\n-  inline __complex__ double\n-  __complex_atanh(__complex__ double __z)\n-  { return __builtin_catanh(__z); }\n-\n-  inline __complex__ long double\n-  __complex_atanh(const __complex__ long double& __z)\n-  { return __builtin_catanhl(__z); }\n+#include <complex>\n+#include <ext/type_traits.h>\n+#include <tr1/type_traits>\n \n-  template<typename _Tp>\n-    inline std::complex<_Tp>\n-    atanh(const std::complex<_Tp>& __z)\n-    { return __complex_atanh(__z.__rep()); }\n+#if defined(_GLIBCXX_INCLUDE_AS_TR1)\n+#  include <tr1_impl/complex>\n #else\n-  template<typename _Tp>\n-    inline std::complex<_Tp>\n-    atanh(const std::complex<_Tp>& __z)\n-    { return __complex_atanh(__z); }\n+#  define _GLIBCXX_INCLUDE_AS_TR1\n+#  define _GLIBCXX_BEGIN_NAMESPACE_TR1 namespace tr1 {\n+#  define _GLIBCXX_END_NAMESPACE_TR1 }\n+#  define _GLIBCXX_TR1 tr1::\n+#  include <tr1_impl/complex>\n+#  undef _GLIBCXX_TR1\n+#  undef _GLIBCXX_END_NAMESPACE_TR1\n+#  undef _GLIBCXX_BEGIN_NAMESPACE_TR1\n+#  undef _GLIBCXX_INCLUDE_AS_TR1\n #endif\n \n-  /// @brief fabs(__z) [8.1.8].\n-  //  Effects:  Behaves the same as C99 function cabs, defined\n-  //            in subclause 7.3.8.1.\n-  template<typename _Tp>\n-    inline std::complex<_Tp>\n-    fabs(const std::complex<_Tp>& __z)\n-    { return std::abs(__z); }\n-\n-\n-  /// @brief Additional overloads [8.1.9].\n-  //\n-\n-  // See common.h for the primary template.\n-  template<typename _Tp, typename _Up>\n-    struct __promote_2<std::complex<_Tp>, _Up>\n-    {\n-    public:\n-      typedef std::complex<typename __promote_2<_Tp, _Up>::__type> __type;\n-    };\n-\n-  template<typename _Tp, typename _Up>\n-    struct __promote_2<_Tp, std::complex<_Up> >\n-    {\n-    public:\n-      typedef std::complex<typename __promote_2<_Tp, _Up>::__type> __type;\n-    };\n-  \n-  template<typename _Tp, typename _Up>\n-    struct __promote_2<std::complex<_Tp>, std::complex<_Up> >\n-    {\n-    public:\n-      typedef std::complex<typename __promote_2<_Tp, _Up>::__type> __type;\n-    };\n-\n-\n+namespace std\n+{\n+namespace tr1\n+{\n   using std::arg;\n-\n-  template<typename _Tp>\n-    inline typename __promote<_Tp>::__type\n-    arg(_Tp __x)\n-    {\n-      typedef typename __promote<_Tp>::__type __type;\n-      return std::arg(std::complex<__type>(__x));\n-    }\n-\n   using std::conj;\n-\n-  template<typename _Tp>\n-    inline std::complex<typename __promote<_Tp>::__type>\n-    conj(_Tp __x)\n-    { return __x; }\n-\n   using std::imag;\n-\n-  template<typename _Tp>\n-    inline typename __promote<_Tp>::__type\n-    imag(_Tp)\n-    { return _Tp(); }\n-\n   using std::norm;\n-\n-  template<typename _Tp>\n-    inline typename __promote<_Tp>::__type\n-    norm(_Tp __x)\n-    {\n-      typedef typename __promote<_Tp>::__type __type;\n-      return __type(__x) * __type(__x);\n-    }\n-\n   using std::polar;\n-\n-  template<typename _Tp, typename _Up>\n-    inline std::complex<typename __promote_2<_Tp, _Up>::__type>\n-    polar(const _Tp& __rho, const _Up& __theta)\n-    {\n-      typedef typename __promote_2<_Tp, _Up>::__type __type;\n-      return std::polar(__type(__rho), __type(__theta));\n-    }\n-  \n   using std::pow;\n-  \n-  template<typename _Tp, typename _Up>\n-    inline std::complex<typename __promote_2<_Tp, _Up>::__type>\n-    pow(const std::complex<_Tp>& __x, const _Up& __y)\n-    {\n-      typedef typename __promote_2<_Tp, _Up>::__type __type;\n-      return std::pow(std::complex<__type>(__x), __type(__y));\n-    }\n-\n-  template<typename _Tp, typename _Up>\n-    inline std::complex<typename __promote_2<_Tp, _Up>::__type>\n-    pow(const _Tp& __x, const std::complex<_Up>& __y)\n-    {\n-      typedef typename __promote_2<_Tp, _Up>::__type __type;\n-      return std::pow(__type(__x), std::complex<__type>(__y));\n-    }\n-\n-  template<typename _Tp, typename _Up>\n-    inline std::complex<typename __promote_2<_Tp, _Up>::__type>\n-    pow(const std::complex<_Tp>& __x, const std::complex<_Up>& __y)\n-    {\n-      typedef typename __promote_2<_Tp, _Up>::__type __type;\n-      return std::pow(std::complex<__type>(__x),\n-\t\t      std::complex<__type>(__y));\n-    }\n-\n   using std::real;\n-\n-  template<typename _Tp>\n-    inline typename __promote<_Tp>::__type\n-    real(_Tp __x)\n-    { return __x; }\n-\n-_GLIBCXX_END_NAMESPACE\n+}\n }\n \n-#endif\n+#endif // _GLIBCXX_TR1_COMPLEX\n+"}, {"sha": "ad0c77d42d40a52420b0620114ef2827cea87920", "filename": "libstdc++-v3/include/tr1/complex.h", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e133ace8d907bf42754c86106fc3f04a9d9fe70f/libstdc%2B%2B-v3%2Finclude%2Ftr1%2Fcomplex.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e133ace8d907bf42754c86106fc3f04a9d9fe70f/libstdc%2B%2B-v3%2Finclude%2Ftr1%2Fcomplex.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Ftr1%2Fcomplex.h?ref=e133ace8d907bf42754c86106fc3f04a9d9fe70f", "patch": "@@ -31,9 +31,9 @@\n  *  This is a TR1 C++ Library header. \n  */\n \n-#ifndef _TR1_COMPLEX_H\n-#define _TR1_COMPLEX_H 1\n+#ifndef _GLIBCXX_TR1_COMPLEX_H\n+#define _GLIBCXX_TR1_COMPLEX_H 1\n \n #include <tr1/ccomplex>\n \n-#endif\n+#endif // _GLIBCXX_TR1_COMPLEX_H"}, {"sha": "20629e7ab56fbe8b37b1e4dfe95b0f04c5bdcdbb", "filename": "libstdc++-v3/include/tr1/cstdarg", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e133ace8d907bf42754c86106fc3f04a9d9fe70f/libstdc%2B%2B-v3%2Finclude%2Ftr1%2Fcstdarg", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e133ace8d907bf42754c86106fc3f04a9d9fe70f/libstdc%2B%2B-v3%2Finclude%2Ftr1%2Fcstdarg", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Ftr1%2Fcstdarg?ref=e133ace8d907bf42754c86106fc3f04a9d9fe70f", "patch": "@@ -1,6 +1,6 @@\n // TR1 cstdarg -*- C++ -*-\n \n-// Copyright (C) 2006 Free Software Foundation, Inc.\n+// Copyright (C) 2006, 2007 Free Software Foundation, Inc.\n //\n // This file is part of the GNU ISO C++ Library.  This library is free\n // software; you can redistribute it and/or modify it under the\n@@ -31,9 +31,9 @@\n  *  This is a TR1 C++ Library header. \n  */\n \n-#ifndef _TR1_CSTDARG\n-#define _TR1_CSTDARG 1\n+#ifndef _GLIBCXX_TR1_CSTDARG\n+#define _GLIBCXX_TR1_CSTDARG 1\n \n #include <cstdarg>\n \n-#endif\n+#endif // _GLIBCXX_TR1_CSTDARG"}, {"sha": "4e43db3064b96de48ca6afdf9e6626550bc382ed", "filename": "libstdc++-v3/include/tr1/cstdbool", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e133ace8d907bf42754c86106fc3f04a9d9fe70f/libstdc%2B%2B-v3%2Finclude%2Ftr1%2Fcstdbool", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e133ace8d907bf42754c86106fc3f04a9d9fe70f/libstdc%2B%2B-v3%2Finclude%2Ftr1%2Fcstdbool", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Ftr1%2Fcstdbool?ref=e133ace8d907bf42754c86106fc3f04a9d9fe70f", "patch": "@@ -31,13 +31,13 @@\n  *  This is a TR1 C++ Library header. \n  */\n \n-#ifndef _TR1_CSTDBOOL\n-#define _TR1_CSTDBOOL 1\n+#ifndef _GLIBCXX_TR1_CSTDBOOL\n+#define _GLIBCXX_TR1_CSTDBOOL 1\n \n #include <bits/c++config.h>\n \n #if _GLIBCXX_HAVE_STDBOOL_H\n #include_next <stdbool.h>\n #endif\n \n-#endif\n+#endif // _GLIBCXX_TR1_CSTDBOOL"}, {"sha": "6f7ac763c8c06bfba40c96499e4fb680721d0402", "filename": "libstdc++-v3/include/tr1/cstdint", "status": "modified", "additions": 21, "deletions": 53, "changes": 74, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e133ace8d907bf42754c86106fc3f04a9d9fe70f/libstdc%2B%2B-v3%2Finclude%2Ftr1%2Fcstdint", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e133ace8d907bf42754c86106fc3f04a9d9fe70f/libstdc%2B%2B-v3%2Finclude%2Ftr1%2Fcstdint", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Ftr1%2Fcstdint?ref=e133ace8d907bf42754c86106fc3f04a9d9fe70f", "patch": "@@ -31,62 +31,30 @@\n  *  This is a TR1 C++ Library header. \n  */\n \n-#ifndef _TR1_CSTDINT\n-#define _TR1_CSTDINT 1\n+#ifndef _GLIBCXX_TR1_CSTDINT\n+#define _GLIBCXX_TR1_CSTDINT 1\n \n-#include <bits/c++config.h>\n-\n-#if _GLIBCXX_USE_C99_STDINT_TR1\n-\n-// For 8.22.1/1 (see C99, Notes 219, 220, 222) \n-#define __STDC_LIMIT_MACROS\n-#define __STDC_CONSTANT_MACROS\n-#include_next <stdint.h>\n-\n-// namespace std::tr1\n-namespace std\n-{\n-_GLIBCXX_BEGIN_NAMESPACE(_GLIBCXX_TR1)\n-\n-  using ::int8_t;\n-  using ::int16_t;\n-  using ::int32_t;\n-  using ::int64_t;\n-\n-  using ::int_fast8_t;\n-  using ::int_fast16_t;\n-  using ::int_fast32_t;\n-  using ::int_fast64_t;\n-\n-  using ::int_least8_t;\n-  using ::int_least16_t;\n-  using ::int_least32_t;\n-  using ::int_least64_t;\n+#pragma GCC system_header\n \n-  using ::intmax_t;\n-  using ::intptr_t;\n-  \n-  using ::uint8_t;\n-  using ::uint16_t;\n-  using ::uint32_t;\n-  using ::uint64_t;\n-\n-  using ::uint_fast8_t;\n-  using ::uint_fast16_t;\n-  using ::uint_fast32_t;\n-  using ::uint_fast64_t;\n-\n-  using ::uint_least8_t;\n-  using ::uint_least16_t;\n-  using ::uint_least32_t;\n-  using ::uint_least64_t;\n-\n-  using ::uintmax_t;\n-  using ::uintptr_t;\n+#if defined(_GLIBCXX_INCLUDE_AS_CXX0X)\n+#  error TR1 header cannot be included from C++0x header\n+#endif\n \n-_GLIBCXX_END_NAMESPACE\n-}\n+#include <bits/c++config.h>\n \n+#if defined(_GLIBCXX_INCLUDE_AS_TR1)\n+#  include <tr1_impl/cstdint>\n+#else\n+#  define _GLIBCXX_INCLUDE_AS_TR1\n+#  define _GLIBCXX_BEGIN_NAMESPACE_TR1 namespace tr1 {\n+#  define _GLIBCXX_END_NAMESPACE_TR1 }\n+#  define _GLIBCXX_TR1 tr1::\n+#  include <tr1_impl/cstdint>\n+#  undef _GLIBCXX_TR1\n+#  undef _GLIBCXX_END_NAMESPACE_TR1\n+#  undef _GLIBCXX_BEGIN_NAMESPACE_TR1\n+#  undef _GLIBCXX_INCLUDE_AS_TR1\n #endif\n \n-#endif\n+#endif // _GLIBCXX_TR1_CSTDINT\n+"}, {"sha": "ddb1867bc99092f78a657bb70e06d1c9fe9ee5ee", "filename": "libstdc++-v3/include/tr1/cstdio", "status": "modified", "additions": 20, "deletions": 18, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e133ace8d907bf42754c86106fc3f04a9d9fe70f/libstdc%2B%2B-v3%2Finclude%2Ftr1%2Fcstdio", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e133ace8d907bf42754c86106fc3f04a9d9fe70f/libstdc%2B%2B-v3%2Finclude%2Ftr1%2Fcstdio", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Ftr1%2Fcstdio?ref=e133ace8d907bf42754c86106fc3f04a9d9fe70f", "patch": "@@ -31,27 +31,29 @@\n  *  This is a TR1 C++ Library header. \n  */\n \n-#ifndef _TR1_CSTDIO\n-#define _TR1_CSTDIO 1\n+#ifndef _GLIBCXX_TR1_CSTDIO\n+#define _GLIBCXX_TR1_CSTDIO 1\n \n-#include <bits/c++config.h>\n-#include <cstdio>\n-\n-// namespace std::tr1\n-namespace std\n-{\n-_GLIBCXX_BEGIN_NAMESPACE(_GLIBCXX_TR1)\n-\n-#if _GLIBCXX_USE_C99\n-  using std::snprintf;\n-  using std::vsnprintf;\n+#pragma GCC system_header\n \n-  using std::vfscanf;\n-  using std::vscanf;\n-  using std::vsscanf;\n+#if defined(_GLIBCXX_INCLUDE_AS_CXX0X)\n+#  error TR1 header cannot be included from C++0x header\n #endif\n \n-_GLIBCXX_END_NAMESPACE\n-}\n+#include <cstdio>\n \n+#if defined(_GLIBCXX_INCLUDE_AS_TR1)\n+#  include <tr1_impl/cstdio>\n+#else\n+#  define _GLIBCXX_INCLUDE_AS_TR1\n+#  define _GLIBCXX_BEGIN_NAMESPACE_TR1 namespace tr1 {\n+#  define _GLIBCXX_END_NAMESPACE_TR1 }\n+#  define _GLIBCXX_TR1 tr1::\n+#  include <tr1_impl/cstdio>\n+#  undef _GLIBCXX_TR1\n+#  undef _GLIBCXX_END_NAMESPACE_TR1\n+#  undef _GLIBCXX_BEGIN_NAMESPACE_TR1\n+#  undef _GLIBCXX_INCLUDE_AS_TR1\n #endif\n+\n+#endif // _GLIBCXX_TR1_CSTDIO"}, {"sha": "acacbcd09eb72412e397ad5557d887c77130eda8", "filename": "libstdc++-v3/include/tr1/cstdlib", "status": "modified", "additions": 19, "deletions": 39, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e133ace8d907bf42754c86106fc3f04a9d9fe70f/libstdc%2B%2B-v3%2Finclude%2Ftr1%2Fcstdlib", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e133ace8d907bf42754c86106fc3f04a9d9fe70f/libstdc%2B%2B-v3%2Finclude%2Ftr1%2Fcstdlib", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Ftr1%2Fcstdlib?ref=e133ace8d907bf42754c86106fc3f04a9d9fe70f", "patch": "@@ -31,49 +31,29 @@\n  *  This is a TR1 C++ Library header. \n  */\n \n-#ifndef _TR1_CSTDLIB\n-#define _TR1_CSTDLIB 1\n+#ifndef _GLIBCXX_TR1_CSTDLIB\n+#define _GLIBCXX_TR1_CSTDLIB 1\n \n-#include <bits/c++config.h>\n+#pragma GCC system_header\n \n-#if _GLIBCXX_HOSTED\n-\n-#include <cstdlib>\n-\n-// namespace std::tr1\n-namespace std\n-{\n-_GLIBCXX_BEGIN_NAMESPACE(_GLIBCXX_TR1)\n-\n-#if _GLIBCXX_USE_C99\n-\n-#if !_GLIBCXX_USE_C99_LONG_LONG_DYNAMIC\n-  // types\n-  using std::lldiv_t;\n-\n-  // functions\n-  using std::llabs;\n-  using std::lldiv;\n-#endif\n-\n-  using std::atoll;\n-  using std::strtoll;\n-  using std::strtoull;\n-\n-  using std::strtof;\n-  using std::strtold;\n-\n-  // overloads\n-  using std::abs;\n-#if !_GLIBCXX_USE_C99_LONG_LONG_DYNAMIC\n-  using std::div;\n+#if defined(_GLIBCXX_INCLUDE_AS_CXX0X)\n+#  error TR1 header cannot be included from C++0x header\n #endif\n \n-#endif\n-\n-_GLIBCXX_END_NAMESPACE\n-}\n+#include <cstdlib>\n \n+#if defined(_GLIBCXX_INCLUDE_AS_TR1)\n+#  include <tr1_impl/cstdlib>\n+#else\n+#  define _GLIBCXX_INCLUDE_AS_TR1\n+#  define _GLIBCXX_BEGIN_NAMESPACE_TR1 namespace tr1 {\n+#  define _GLIBCXX_END_NAMESPACE_TR1 }\n+#  define _GLIBCXX_TR1 tr1::\n+#  include <tr1_impl/cstdlib>\n+#  undef _GLIBCXX_TR1\n+#  undef _GLIBCXX_END_NAMESPACE_TR1\n+#  undef _GLIBCXX_BEGIN_NAMESPACE_TR1\n+#  undef _GLIBCXX_INCLUDE_AS_TR1\n #endif\n \n-#endif\n+#endif // _GLIBCXX_TR1_CSTDLIB"}, {"sha": "2f6af6803721a096cbbb166ce0ecef66b4b5ed90", "filename": "libstdc++-v3/include/tr1/ctgmath", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e133ace8d907bf42754c86106fc3f04a9d9fe70f/libstdc%2B%2B-v3%2Finclude%2Ftr1%2Fctgmath", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e133ace8d907bf42754c86106fc3f04a9d9fe70f/libstdc%2B%2B-v3%2Finclude%2Ftr1%2Fctgmath", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Ftr1%2Fctgmath?ref=e133ace8d907bf42754c86106fc3f04a9d9fe70f", "patch": "@@ -1,6 +1,6 @@\n // TR1 ctgmath -*- C++ -*-\n \n-// Copyright (C) 2006 Free Software Foundation, Inc.\n+// Copyright (C) 2006, 2007 Free Software Foundation, Inc.\n //\n // This file is part of the GNU ISO C++ Library.  This library is free\n // software; you can redistribute it and/or modify it under the\n@@ -31,9 +31,9 @@\n  *  This is a TR1 C++ Library header. \n  */\n \n-#ifndef _TR1_CTGMATH\n-#define _TR1_CTGMATH 1\n+#ifndef _GLIBCXX_TR1_CTGMATH\n+#define _GLIBCXX_TR1_CTGMATH 1\n \n #include <tr1/cmath>\n \n-#endif\n+#endif // _GLIBCXX_TR1_CTGMATH"}, {"sha": "4c14ccab5ab13fb7f2fc7ce1363207f23ccfd620", "filename": "libstdc++-v3/include/tr1/ctime", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e133ace8d907bf42754c86106fc3f04a9d9fe70f/libstdc%2B%2B-v3%2Finclude%2Ftr1%2Fctime", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e133ace8d907bf42754c86106fc3f04a9d9fe70f/libstdc%2B%2B-v3%2Finclude%2Ftr1%2Fctime", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Ftr1%2Fctime?ref=e133ace8d907bf42754c86106fc3f04a9d9fe70f", "patch": "@@ -1,6 +1,6 @@\n // TR1 ctime -*- C++ -*-\n \n-// Copyright (C) 2006 Free Software Foundation, Inc.\n+// Copyright (C) 2006, 2007 Free Software Foundation, Inc.\n //\n // This file is part of the GNU ISO C++ Library.  This library is free\n // software; you can redistribute it and/or modify it under the\n@@ -31,9 +31,9 @@\n  *  This is a TR1 C++ Library header. \n  */\n \n-#ifndef _TR1_CTIME\n-#define _TR1_CTIME 1\n+#ifndef _GLIBCXX_TR1_CTIME\n+#define _GLIBCXX_TR1_CTIME 1\n \n #include <ctime>\n \n-#endif\n+#endif // _GLIBCXX_TR1_CTIME"}, {"sha": "c6fb88ea0e182a47f372dd5096b0fa5726d589a8", "filename": "libstdc++-v3/include/tr1/cwchar", "status": "modified", "additions": 20, "deletions": 33, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e133ace8d907bf42754c86106fc3f04a9d9fe70f/libstdc%2B%2B-v3%2Finclude%2Ftr1%2Fcwchar", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e133ace8d907bf42754c86106fc3f04a9d9fe70f/libstdc%2B%2B-v3%2Finclude%2Ftr1%2Fcwchar", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Ftr1%2Fcwchar?ref=e133ace8d907bf42754c86106fc3f04a9d9fe70f", "patch": "@@ -1,6 +1,6 @@\n // TR1 cwchar -*- C++ -*-\n \n-// Copyright (C) 2006 Free Software Foundation, Inc.\n+// Copyright (C) 2006, 2007 Free Software Foundation, Inc.\n //\n // This file is part of the GNU ISO C++ Library.  This library is free\n // software; you can redistribute it and/or modify it under the\n@@ -31,42 +31,29 @@\n  *  This is a TR1 C++ Library header. \n  */\n \n-#ifndef _TR1_CWCHAR\n-#define _TR1_CWCHAR 1\n+#ifndef _GLIBCXX_TR1_CWCHAR\n+#define _GLIBCXX_TR1_CWCHAR 1\n \n-#include <bits/c++config.h>\n+#pragma GCC system_header\n \n-#if _GLIBCXX_USE_WCHAR_T\n-\n-#include <cwchar>\n-\n-// namespace std::tr1\n-namespace std\n-{\n-_GLIBCXX_BEGIN_NAMESPACE(_GLIBCXX_TR1)\n-\n-#if _GLIBCXX_HAVE_WCSTOF\n-  using std::wcstof;\n-#endif\n-#if _GLIBCXX_HAVE_VFWSCANF\n-  using std::vfwscanf;\n-#endif\n-#if _GLIBCXX_HAVE_VSWSCANF\n-  using std::vswscanf;\n-#endif\n-#if _GLIBCXX_HAVE_VWSCANF\n-  using std::vwscanf;\n-#endif\n-\n-#if _GLIBCXX_USE_C99\n-  using std::wcstold;\n-  using std::wcstoll;\n-  using std::wcstoull;\n+#if defined(_GLIBCXX_INCLUDE_AS_CXX0X)\n+#  error TR1 header cannot be included from C++0x header\n #endif\n \n-_GLIBCXX_END_NAMESPACE\n-}\n+#include <cwchar>\n \n+#if defined(_GLIBCXX_INCLUDE_AS_TR1)\n+#  include <tr1_impl/cwchar>\n+#else\n+#  define _GLIBCXX_INCLUDE_AS_TR1\n+#  define _GLIBCXX_BEGIN_NAMESPACE_TR1 namespace tr1 {\n+#  define _GLIBCXX_END_NAMESPACE_TR1 }\n+#  define _GLIBCXX_TR1 tr1::\n+#  include <tr1_impl/cwchar>\n+#  undef _GLIBCXX_TR1\n+#  undef _GLIBCXX_END_NAMESPACE_TR1\n+#  undef _GLIBCXX_BEGIN_NAMESPACE_TR1\n+#  undef _GLIBCXX_INCLUDE_AS_TR1\n #endif\n \n-#endif\n+#endif // _GLIBCXX_TR1_CWCHAR"}, {"sha": "2b2b3679eb43afb23e4b0e1013bb18803286d814", "filename": "libstdc++-v3/include/tr1/cwctype", "status": "modified", "additions": 20, "deletions": 18, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e133ace8d907bf42754c86106fc3f04a9d9fe70f/libstdc%2B%2B-v3%2Finclude%2Ftr1%2Fcwctype", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e133ace8d907bf42754c86106fc3f04a9d9fe70f/libstdc%2B%2B-v3%2Finclude%2Ftr1%2Fcwctype", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Ftr1%2Fcwctype?ref=e133ace8d907bf42754c86106fc3f04a9d9fe70f", "patch": "@@ -1,6 +1,6 @@\n // TR1 cwctype -*- C++ -*-\n \n-// Copyright (C) 2006 Free Software Foundation, Inc.\n+// Copyright (C) 2006, 2007 Free Software Foundation, Inc.\n //\n // This file is part of the GNU ISO C++ Library.  This library is free\n // software; you can redistribute it and/or modify it under the\n@@ -31,27 +31,29 @@\n  *  This is a TR1 C++ Library header. \n  */\n \n-#ifndef _TR1_CWCTYPE\n-#define _TR1_CWCTYPE 1\n+#ifndef _GLIBCXX_TR1_CWCTYPE\n+#define _GLIBCXX_TR1_CWCTYPE 1\n \n-#include <bits/c++config.h>\n+#pragma GCC system_header\n \n-#if _GLIBCXX_USE_WCHAR_T\n+#if defined(_GLIBCXX_INCLUDE_AS_CXX0X)\n+#  error TR1 header cannot be included from C++0x header\n+#endif\n \n #include <cwctype>\n \n-// namespace std::tr1\n-namespace std\n-{\n-_GLIBCXX_BEGIN_NAMESPACE(_GLIBCXX_TR1)\n-\n-#if _GLIBCXX_HAVE_ISWBLANK\n-  using std::iswblank;\n-#endif  \n-\n-_GLIBCXX_END_NAMESPACE\n-}\n-\n+#if defined(_GLIBCXX_INCLUDE_AS_TR1)\n+#  include <tr1_impl/cwctype>\n+#else\n+#  define _GLIBCXX_INCLUDE_AS_TR1\n+#  define _GLIBCXX_BEGIN_NAMESPACE_TR1 namespace tr1 {\n+#  define _GLIBCXX_END_NAMESPACE_TR1 }\n+#  define _GLIBCXX_TR1 tr1::\n+#  include <tr1_impl/cwctype>\n+#  undef _GLIBCXX_TR1\n+#  undef _GLIBCXX_END_NAMESPACE_TR1\n+#  undef _GLIBCXX_BEGIN_NAMESPACE_TR1\n+#  undef _GLIBCXX_INCLUDE_AS_TR1\n #endif\n \n-#endif\n+#endif // _GLIBCXX_TR1_CWCTYPE"}, {"sha": "745b379fb9c9a6f7edf69a6ed9223f6479e7589c", "filename": "libstdc++-v3/include/tr1/ell_integral.tcc", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e133ace8d907bf42754c86106fc3f04a9d9fe70f/libstdc%2B%2B-v3%2Finclude%2Ftr1%2Fell_integral.tcc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e133ace8d907bf42754c86106fc3f04a9d9fe70f/libstdc%2B%2B-v3%2Finclude%2Ftr1%2Fell_integral.tcc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Ftr1%2Fell_integral.tcc?ref=e133ace8d907bf42754c86106fc3f04a9d9fe70f", "patch": "@@ -45,12 +45,13 @@\n //        W. T. Vetterling, B. P. Flannery, Cambridge University Press\n //        (1992), pp. 261-269\n \n-#ifndef _TR1_ELL_INTEGRAL_TCC\n-#define _TR1_ELL_INTEGRAL_TCC 1\n+#ifndef _GLIBCXX_TR1_ELL_INTEGRAL_TCC\n+#define _GLIBCXX_TR1_ELL_INTEGRAL_TCC 1\n \n namespace std\n {\n-_GLIBCXX_BEGIN_NAMESPACE(_GLIBCXX_TR1)\n+namespace tr1\n+{\n \n   // [5.2] Special functions\n \n@@ -755,8 +756,8 @@ _GLIBCXX_BEGIN_NAMESPACE(_GLIBCXX_TR1)\n \n   /* @} */ // group tr1_math_spec_func\n \n-_GLIBCXX_END_NAMESPACE\n+}\n }\n \n-#endif // _TR1_ELL_INTEGRAL_TCC\n+#endif // _GLIBCXX_TR1_ELL_INTEGRAL_TCC\n "}, {"sha": "fa016fc599370bd0e91ffa3a658887b5a69e9556", "filename": "libstdc++-v3/include/tr1/exp_integral.tcc", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e133ace8d907bf42754c86106fc3f04a9d9fe70f/libstdc%2B%2B-v3%2Finclude%2Ftr1%2Fexp_integral.tcc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e133ace8d907bf42754c86106fc3f04a9d9fe70f/libstdc%2B%2B-v3%2Finclude%2Ftr1%2Fexp_integral.tcc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Ftr1%2Fexp_integral.tcc?ref=e133ace8d907bf42754c86106fc3f04a9d9fe70f", "patch": "@@ -48,14 +48,15 @@\n //       2nd ed, pp. 222-225.\n //\n \n-#ifndef _TR1_EXP_INTEGRAL_TCC\n-#define _TR1_EXP_INTEGRAL_TCC 1\n+#ifndef _GLIBCXX_TR1_EXP_INTEGRAL_TCC\n+#define _GLIBCXX_TR1_EXP_INTEGRAL_TCC 1\n \n #include \"special_function_util.h\"\n \n namespace std\n {\n-_GLIBCXX_BEGIN_NAMESPACE(_GLIBCXX_TR1)\n+namespace tr1\n+{\n \n   // [5.2] Special functions\n \n@@ -532,7 +533,7 @@ _GLIBCXX_BEGIN_NAMESPACE(_GLIBCXX_TR1)\n \n   /* @} */ // group tr1_math_spec_func\n \n-_GLIBCXX_END_NAMESPACE\n+}\n }\n \n-#endif // _TR1_EXP_INTEGRAL_TCC\n+#endif // _GLIBCXX_TR1_EXP_INTEGRAL_TCC"}, {"sha": "d3afe76409b0d86fcabf3a40b31e750278d3d3ba", "filename": "libstdc++-v3/include/tr1/functional", "status": "modified", "additions": 25, "deletions": 2267, "changes": 2292, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e133ace8d907bf42754c86106fc3f04a9d9fe70f/libstdc%2B%2B-v3%2Finclude%2Ftr1%2Ffunctional", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e133ace8d907bf42754c86106fc3f04a9d9fe70f/libstdc%2B%2B-v3%2Finclude%2Ftr1%2Ffunctional", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Ftr1%2Ffunctional?ref=e133ace8d907bf42754c86106fc3f04a9d9fe70f", "patch": "@@ -31,2280 +31,38 @@\n  *  This is a TR1 C++ Library header.\n  */\n \n-#ifndef _TR1_FUNCTIONAL\n-#define _TR1_FUNCTIONAL 1\n+#ifndef _GLIBCXX_TR1_FUNCTIONAL\n+#define _GLIBCXX_TR1_FUNCTIONAL 1\n \n #pragma GCC system_header\n \n-#include <cmath>                // for std::frexp\n-#include <string>               // for std::tr1::hash\n-#include <functional>\n+#if defined(_GLIBCXX_INCLUDE_AS_CXX0X)\n+#  error TR1 header cannot be included from C++0x header\n+#endif\n+\n+#include <bits/c++config.h>\n+#include <bits/stl_function.h>\n+\n+#include <cmath>\n+#include <string>\n #include <typeinfo>\n+#include <ext/type_traits.h>\n #include <tr1/tuple>\n #include <tr1/type_traits>\n-#include <ext/type_traits.h>\n-\n-namespace std\n-{\n-_GLIBCXX_BEGIN_NAMESPACE(_GLIBCXX_TR1)\n-\n-  template<typename _MemberPointer>\n-    class _Mem_fn;\n-\n-  /**\n-   *  @if maint\n-   *  Actual implementation of _Has_result_type, which uses SFINAE to\n-   *  determine if the type _Tp has a publicly-accessible member type\n-   *  result_type.\n-   *  @endif\n-  */\n-  template<typename _Tp>\n-    class _Has_result_type_helper : __sfinae_types\n-    {\n-      template<typename _Up>\n-        struct _Wrap_type\n-\t{ };\n-\n-      template<typename _Up>\n-        static __one __test(_Wrap_type<typename _Up::result_type>*);\n-\n-      template<typename _Up>\n-        static __two __test(...);\n-\n-    public:\n-      static const bool value = sizeof(__test<_Tp>(0)) == 1;\n-    };\n-\n-  template<typename _Tp>\n-    struct _Has_result_type\n-    : integral_constant<bool,\n-\t      _Has_result_type_helper<typename remove_cv<_Tp>::type>::value>\n-    { };\n-\n-  /**\n-   *  @if maint\n-   *  If we have found a result_type, extract it.\n-   *  @endif\n-  */\n-  template<bool _Has_result_type, typename _Functor>\n-    struct _Maybe_get_result_type\n-    { };\n-\n-  template<typename _Functor>\n-    struct _Maybe_get_result_type<true, _Functor>\n-    {\n-      typedef typename _Functor::result_type result_type;\n-    };\n-\n-  /**\n-   *  @if maint\n-   *  Base class for any function object that has a weak result type, as\n-   *  defined in 3.3/3 of TR1.\n-   *  @endif\n-  */\n-  template<typename _Functor>\n-    struct _Weak_result_type_impl\n-    : _Maybe_get_result_type<_Has_result_type<_Functor>::value, _Functor>\n-    {\n-    };\n-\n-  /**\n-   * @if maint\n-   * Retrieve the result type for a function type.\n-   * @endif \n-   */\n-  template<typename _Res, typename... _ArgTypes> \n-    struct _Weak_result_type_impl<_Res(_ArgTypes...)>\n-    {\n-      typedef _Res result_type;\n-    };\n-\n-  /**\n-   * @if maint\n-   * Retrieve the result type for a function reference.\n-   * @endif \n-   */\n-  template<typename _Res, typename... _ArgTypes> \n-    struct _Weak_result_type_impl<_Res(&)(_ArgTypes...)>\n-    {\n-      typedef _Res result_type;\n-    };\n-\n-  /**\n-   * @if maint\n-   * Retrieve the result type for a function pointer.\n-   * @endif \n-   */\n-  template<typename _Res, typename... _ArgTypes> \n-    struct _Weak_result_type_impl<_Res(*)(_ArgTypes...)>\n-    {\n-      typedef _Res result_type;\n-    };\n-\n-  /**\n-   * @if maint\n-   * Retrieve result type for a member function pointer.\n-   * @endif maint\n-   */ \n-  template<typename _Res, typename _Class, typename... _ArgTypes> \n-    struct _Weak_result_type_impl<_Res (_Class::*)(_ArgTypes...)>\n-    {\n-      typedef _Res result_type;\n-    };\n-\n-  /**\n-   * @if maint\n-   * Retrieve result type for a const member function pointer.\n-   * @endif maint\n-   */ \n-  template<typename _Res, typename _Class, typename... _ArgTypes> \n-    struct _Weak_result_type_impl<_Res (_Class::*)(_ArgTypes...) const>\n-    {\n-      typedef _Res result_type;\n-    };\n-\n-  /**\n-   * @if maint\n-   * Retrieve result type for a volatile member function pointer.\n-   * @endif maint\n-   */ \n-  template<typename _Res, typename _Class, typename... _ArgTypes> \n-    struct _Weak_result_type_impl<_Res (_Class::*)(_ArgTypes...) volatile>\n-    {\n-      typedef _Res result_type;\n-    };\n-\n-  /**\n-   * @if maint\n-   * Retrieve result type for a const volatile member function pointer.\n-   * @endif maint\n-   */ \n-  template<typename _Res, typename _Class, typename... _ArgTypes> \n-    struct _Weak_result_type_impl<_Res (_Class::*)(_ArgTypes...)const volatile>\n-    {\n-      typedef _Res result_type;\n-    };\n-\n-  /**\n-   *  @if maint\n-   *  Strip top-level cv-qualifiers from the function object and let\n-   *  _Weak_result_type_impl perform the real work.\n-   *  @endif\n-  */\n-  template<typename _Functor>\n-    struct _Weak_result_type\n-    : _Weak_result_type_impl<typename remove_cv<_Functor>::type>\n-    {\n-    };\n-\n-  template<typename _Signature>\n-    class result_of;\n-\n-  /**\n-   *  @if maint\n-   *  Actual implementation of result_of. When _Has_result_type is\n-   *  true, gets its result from _Weak_result_type. Otherwise, uses\n-   *  the function object's member template result to extract the\n-   *  result type.\n-   *  @endif\n-  */\n-  template<bool _Has_result_type, typename _Signature>\n-    struct _Result_of_impl;\n-\n-  // Handle member data pointers using _Mem_fn's logic\n-  template<typename _Res, typename _Class, typename _T1>\n-    struct _Result_of_impl<false, _Res _Class::*(_T1)>\n-    {\n-      typedef typename _Mem_fn<_Res _Class::*>\n-                ::template _Result_type<_T1>::type type;\n-    };\n-\n-  /**\n-   * @if maint\n-   * Determine whether we can determine a result type from @c Functor \n-   * alone.\n-   * @endif\n-   */ \n-  template<typename _Functor, typename... _ArgTypes>\n-    class result_of<_Functor(_ArgTypes...)>\n-    : public _Result_of_impl<\n-               _Has_result_type<_Weak_result_type<_Functor> >::value,\n-               _Functor(_ArgTypes...)>\n-    {\n-    };\n-\n-  /**\n-   * @if maint\n-   * We already know the result type for @c Functor; use it.\n-   * @endif\n-   */\n-  template<typename _Functor, typename... _ArgTypes>\n-    struct _Result_of_impl<true, _Functor(_ArgTypes...)>\n-    {\n-      typedef typename _Weak_result_type<_Functor>::result_type type;\n-    };\n-\n-  /**\n-   * @if maint\n-   * We need to compute the result type for this invocation the hard \n-   * way.\n-   * @endif\n-   */\n-  template<typename _Functor, typename... _ArgTypes>\n-    struct _Result_of_impl<false, _Functor(_ArgTypes...)>\n-    {\n-      typedef typename _Functor\n-                ::template result<_Functor(_ArgTypes...)>::type type;\n-    };\n-\n-  /**\n-   * @if maint\n-   * It is unsafe to access ::result when there are zero arguments, so we \n-   * return @c void instead.\n-   * @endif\n-   */\n-  template<typename _Functor>\n-    struct _Result_of_impl<false, _Functor()>\n-    {\n-      typedef void type;\n-    };\n-\n-  /**\n-   *  @if maint\n-   *  Determines if the type _Tp derives from unary_function.\n-   *  @endif\n-  */\n-  template<typename _Tp>\n-    struct _Derives_from_unary_function : __sfinae_types\n-    {\n-    private:\n-      template<typename _T1, typename _Res>\n-        static __one __test(const volatile unary_function<_T1, _Res>*);\n-\n-      // It's tempting to change \"...\" to const volatile void*, but\n-      // that fails when _Tp is a function type.\n-      static __two __test(...);\n-\n-    public:\n-      static const bool value = sizeof(__test((_Tp*)0)) == 1;\n-    };\n-\n-  /**\n-   *  @if maint\n-   *  Determines if the type _Tp derives from binary_function.\n-   *  @endif\n-  */\n-  template<typename _Tp>\n-    struct _Derives_from_binary_function : __sfinae_types\n-    {\n-    private:\n-      template<typename _T1, typename _T2, typename _Res>\n-        static __one __test(const volatile binary_function<_T1, _T2, _Res>*);\n-\n-      // It's tempting to change \"...\" to const volatile void*, but\n-      // that fails when _Tp is a function type.\n-      static __two __test(...);\n-\n-    public:\n-      static const bool value = sizeof(__test((_Tp*)0)) == 1;\n-    };\n-\n-  /**\n-   *  @if maint\n-   *  Turns a function type into a function pointer type\n-   *  @endif\n-  */\n-  template<typename _Tp, bool _IsFunctionType = is_function<_Tp>::value>\n-    struct _Function_to_function_pointer\n-    {\n-      typedef _Tp type;\n-    };\n-\n-  template<typename _Tp>\n-    struct _Function_to_function_pointer<_Tp, true>\n-    {\n-      typedef _Tp* type;\n-    };\n-\n-  /**\n-   * @if maint\n-   * Invoke a function object, which may be either a member pointer or a\n-   * function object. The first parameter will tell which.\n-   * @endif\n-   */\n-  template<typename _Functor, typename... _Args>\n-    inline\n-    typename __gnu_cxx::__enable_if<\n-             (!is_member_pointer<_Functor>::value\n-              && !is_function<_Functor>::value\n-              && !is_function<typename remove_pointer<_Functor>::type>::value),\n-             typename result_of<_Functor(_Args...)>::type\n-           >::__type\n-    __invoke(_Functor& __f, _Args&... __args)\n-    {\n-      return __f(__args...);\n-    }\n-\n-  template<typename _Functor, typename... _Args>\n-    inline\n-    typename __gnu_cxx::__enable_if<\n-             (is_member_pointer<_Functor>::value\n-              && !is_function<_Functor>::value\n-              && !is_function<typename remove_pointer<_Functor>::type>::value),\n-             typename result_of<_Functor(_Args...)>::type\n-           >::__type\n-    __invoke(_Functor& __f, _Args&... __args)\n-    {\n-      return mem_fn(__f)(__args...);\n-    }\n-\n-  // To pick up function references (that will become function pointers)\n-  template<typename _Functor, typename... _Args>\n-    inline\n-    typename __gnu_cxx::__enable_if<\n-             (is_pointer<_Functor>::value\n-              && is_function<typename remove_pointer<_Functor>::type>::value),\n-             typename result_of<_Functor(_Args...)>::type\n-           >::__type\n-    __invoke(_Functor __f, _Args&... __args)\n-    {\n-      return __f(__args...);\n-    }\n-\n-  /**\n-   *  @if maint\n-   *  Knowing which of unary_function and binary_function _Tp derives\n-   *  from, derives from the same and ensures that reference_wrapper\n-   *  will have a weak result type. See cases below.\n-   *  @endif\n-   */\n-  template<bool _Unary, bool _Binary, typename _Tp>\n-    struct _Reference_wrapper_base_impl;\n-\n-  // Not a unary_function or binary_function, so try a weak result type\n-  template<typename _Tp>\n-    struct _Reference_wrapper_base_impl<false, false, _Tp>\n-    : _Weak_result_type<_Tp>\n-    { };\n-\n-  // unary_function but not binary_function\n-  template<typename _Tp>\n-    struct _Reference_wrapper_base_impl<true, false, _Tp>\n-    : unary_function<typename _Tp::argument_type,\n-\t\t     typename _Tp::result_type>\n-    { };\n-\n-  // binary_function but not unary_function\n-  template<typename _Tp>\n-    struct _Reference_wrapper_base_impl<false, true, _Tp>\n-    : binary_function<typename _Tp::first_argument_type,\n-\t\t      typename _Tp::second_argument_type,\n-\t\t      typename _Tp::result_type>\n-    { };\n-\n-  // both unary_function and binary_function. import result_type to\n-  // avoid conflicts.\n-   template<typename _Tp>\n-    struct _Reference_wrapper_base_impl<true, true, _Tp>\n-    : unary_function<typename _Tp::argument_type,\n-\t\t     typename _Tp::result_type>,\n-      binary_function<typename _Tp::first_argument_type,\n-\t\t      typename _Tp::second_argument_type,\n-\t\t      typename _Tp::result_type>\n-    {\n-      typedef typename _Tp::result_type result_type;\n-    };\n-\n-  /**\n-   *  @if maint\n-   *  Derives from unary_function or binary_function when it\n-   *  can. Specializations handle all of the easy cases. The primary\n-   *  template determines what to do with a class type, which may\n-   *  derive from both unary_function and binary_function.\n-   *  @endif\n-  */\n-  template<typename _Tp>\n-    struct _Reference_wrapper_base\n-    : _Reference_wrapper_base_impl<\n-      _Derives_from_unary_function<_Tp>::value,\n-      _Derives_from_binary_function<_Tp>::value,\n-      _Tp>\n-    { };\n-\n-  // - a function type (unary)\n-  template<typename _Res, typename _T1>\n-    struct _Reference_wrapper_base<_Res(_T1)>\n-    : unary_function<_T1, _Res>\n-    { };\n-\n-  // - a function type (binary)\n-  template<typename _Res, typename _T1, typename _T2>\n-    struct _Reference_wrapper_base<_Res(_T1, _T2)>\n-    : binary_function<_T1, _T2, _Res>\n-    { };\n-\n-  // - a function pointer type (unary)\n-  template<typename _Res, typename _T1>\n-    struct _Reference_wrapper_base<_Res(*)(_T1)>\n-    : unary_function<_T1, _Res>\n-    { };\n-\n-  // - a function pointer type (binary)\n-  template<typename _Res, typename _T1, typename _T2>\n-    struct _Reference_wrapper_base<_Res(*)(_T1, _T2)>\n-    : binary_function<_T1, _T2, _Res>\n-    { };\n-\n-  // - a pointer to member function type (unary, no qualifiers)\n-  template<typename _Res, typename _T1>\n-    struct _Reference_wrapper_base<_Res (_T1::*)()>\n-    : unary_function<_T1*, _Res>\n-    { };\n-\n-  // - a pointer to member function type (binary, no qualifiers)\n-  template<typename _Res, typename _T1, typename _T2>\n-    struct _Reference_wrapper_base<_Res (_T1::*)(_T2)>\n-    : binary_function<_T1*, _T2, _Res>\n-    { };\n-\n-  // - a pointer to member function type (unary, const)\n-  template<typename _Res, typename _T1>\n-    struct _Reference_wrapper_base<_Res (_T1::*)() const>\n-    : unary_function<const _T1*, _Res>\n-    { };\n-\n-  // - a pointer to member function type (binary, const)\n-  template<typename _Res, typename _T1, typename _T2>\n-    struct _Reference_wrapper_base<_Res (_T1::*)(_T2) const>\n-    : binary_function<const _T1*, _T2, _Res>\n-    { };\n-\n-  // - a pointer to member function type (unary, volatile)\n-  template<typename _Res, typename _T1>\n-    struct _Reference_wrapper_base<_Res (_T1::*)() volatile>\n-    : unary_function<volatile _T1*, _Res>\n-    { };\n-\n-  // - a pointer to member function type (binary, volatile)\n-  template<typename _Res, typename _T1, typename _T2>\n-    struct _Reference_wrapper_base<_Res (_T1::*)(_T2) volatile>\n-    : binary_function<volatile _T1*, _T2, _Res>\n-    { };\n-\n-  // - a pointer to member function type (unary, const volatile)\n-  template<typename _Res, typename _T1>\n-    struct _Reference_wrapper_base<_Res (_T1::*)() const volatile>\n-    : unary_function<const volatile _T1*, _Res>\n-    { };\n-\n-  // - a pointer to member function type (binary, const volatile)\n-  template<typename _Res, typename _T1, typename _T2>\n-    struct _Reference_wrapper_base<_Res (_T1::*)(_T2) const volatile>\n-    : binary_function<const volatile _T1*, _T2, _Res>\n-    { };\n-\n-  template<typename _Tp>\n-    class reference_wrapper\n-    : public _Reference_wrapper_base<typename remove_cv<_Tp>::type>\n-    {\n-      // If _Tp is a function type, we can't form result_of<_Tp(...)>,\n-      // so turn it into a function pointer type.\n-      typedef typename _Function_to_function_pointer<_Tp>::type\n-        _M_func_type;\n-\n-      _Tp* _M_data;\n-    public:\n-      typedef _Tp type;\n-\n-      explicit\n-      reference_wrapper(_Tp& __indata): _M_data(&__indata)\n-      { }\n-\n-      reference_wrapper(const reference_wrapper<_Tp>& __inref):\n-      _M_data(__inref._M_data)\n-      { }\n-\n-      reference_wrapper&\n-      operator=(const reference_wrapper<_Tp>& __inref)\n-      {\n-        _M_data = __inref._M_data;\n-        return *this;\n-      }\n-\n-      operator _Tp&() const\n-      { return this->get(); }\n-\n-      _Tp&\n-      get() const\n-      { return *_M_data; }\n-\n-      template<typename... _Args>\n-        typename result_of<_M_func_type(_Args...)>::type\n-        operator()(_Args&... __args) const\n-        {\n-\t  return __invoke(get(), __args...);\n-\t}\n-    };\n-\n-\n-  // Denotes a reference should be taken to a variable.\n-  template<typename _Tp>\n-    inline reference_wrapper<_Tp>\n-    ref(_Tp& __t)\n-    { return reference_wrapper<_Tp>(__t); }\n-\n-  // Denotes a const reference should be taken to a variable.\n-  template<typename _Tp>\n-    inline reference_wrapper<const _Tp>\n-    cref(const _Tp& __t)\n-    { return reference_wrapper<const _Tp>(__t); }\n-\n-  template<typename _Tp>\n-    inline reference_wrapper<_Tp>\n-    ref(reference_wrapper<_Tp> __t)\n-    { return ref(__t.get()); }\n-\n-  template<typename _Tp>\n-    inline reference_wrapper<const _Tp>\n-    cref(reference_wrapper<_Tp> __t)\n-    { return cref(__t.get()); }\n-\n-  template<typename _Tp, bool>\n-    struct _Mem_fn_const_or_non\n-    {\n-      typedef const _Tp& type;\n-    };\n-\n-  template<typename _Tp>\n-    struct _Mem_fn_const_or_non<_Tp, false>\n-    {\n-      typedef _Tp& type;\n-    };\n-\n-  /**\n-   * @if maint\n-   * Derives from @c unary_function or @c binary_function, or perhaps\n-   * nothing, depending on the number of arguments provided. The\n-   * primary template is the basis case, which derives nothing.\n-   * @endif maint\n-   */\n-  template<typename _Res, typename... _ArgTypes> \n-    struct _Maybe_unary_or_binary_function { };\n-\n-  /**\n-   * @if maint\n-   * Derives from @c unary_function, as appropriate.\n-   * @endif\n-   */ \n-  template<typename _Res, typename _T1> \n-    struct _Maybe_unary_or_binary_function<_Res, _T1>\n-    : std::unary_function<_T1, _Res> { };\n-\n-  /**\n-   * @if maint\n-   * Derives from @c binary_function, as appropriate.\n-   * @endif\n-   */ \n-  template<typename _Res, typename _T1, typename _T2> \n-    struct _Maybe_unary_or_binary_function<_Res, _T1, _T2>\n-    : std::binary_function<_T1, _T2, _Res> { };\n-\n-  /**\n-   * @if maint\n-   * Implementation of @c mem_fn for member function pointers.\n-   * @endif\n-   */\n-  template<typename _Res, typename _Class, typename... _ArgTypes>\n-    class _Mem_fn<_Res (_Class::*)(_ArgTypes...)>\n-    : public _Maybe_unary_or_binary_function<_Res, _Class*, _ArgTypes...>\n-    {\n-      typedef _Res (_Class::*_Functor)(_ArgTypes...);\n-\n-      template<typename _Tp>\n-        _Res\n-        _M_call(_Tp& __object, const volatile _Class *, \n-                _ArgTypes... __args) const\n-        { return (__object.*__pmf)(__args...); }\n-\n-      template<typename _Tp>\n-        _Res\n-        _M_call(_Tp& __ptr, const volatile void *, _ArgTypes... __args) const\n-        { return ((*__ptr).*__pmf)(__args...); }\n-\n-    public:\n-      typedef _Res result_type;\n-\n-      explicit _Mem_fn(_Functor __pmf) : __pmf(__pmf) { }\n-\n-      // Handle objects\n-      _Res\n-      operator()(_Class& __object, _ArgTypes... __args) const\n-      { return (__object.*__pmf)(__args...); }\n-\n-      // Handle pointers\n-      _Res\n-      operator()(_Class* __object, _ArgTypes... __args) const\n-      { return (__object->*__pmf)(__args...); }\n-\n-      // Handle smart pointers, references and pointers to derived\n-      template<typename _Tp>\n-        _Res\n-\toperator()(_Tp& __object, _ArgTypes... __args) const\n-        { return _M_call(__object, &__object, __args...); }\n-\n-    private:\n-      _Functor __pmf;\n-    };\n-\n-  /**\n-   * @if maint\n-   * Implementation of @c mem_fn for const member function pointers.\n-   * @endif\n-   */\n-  template<typename _Res, typename _Class, typename... _ArgTypes>\n-    class _Mem_fn<_Res (_Class::*)(_ArgTypes...) const>\n-    : public _Maybe_unary_or_binary_function<_Res, const _Class*, \n-\t\t\t\t\t     _ArgTypes...>\n-    {\n-      typedef _Res (_Class::*_Functor)(_ArgTypes...) const;\n-\n-      template<typename _Tp>\n-        _Res\n-        _M_call(_Tp& __object, const volatile _Class *, \n-                _ArgTypes... __args) const\n-        { return (__object.*__pmf)(__args...); }\n-\n-      template<typename _Tp>\n-        _Res\n-        _M_call(_Tp& __ptr, const volatile void *, _ArgTypes... __args) const\n-        { return ((*__ptr).*__pmf)(__args...); }\n-\n-    public:\n-      typedef _Res result_type;\n-\n-      explicit _Mem_fn(_Functor __pmf) : __pmf(__pmf) { }\n-\n-      // Handle objects\n-      _Res\n-      operator()(const _Class& __object, _ArgTypes... __args) const\n-      { return (__object.*__pmf)(__args...); }\n-\n-      // Handle pointers\n-      _Res\n-      operator()(const _Class* __object, _ArgTypes... __args) const\n-      { return (__object->*__pmf)(__args...); }\n-\n-      // Handle smart pointers, references and pointers to derived\n-      template<typename _Tp>\n-        _Res operator()(_Tp& __object, _ArgTypes... __args) const\n-        { return _M_call(__object, &__object, __args...); }\n-\n-    private:\n-      _Functor __pmf;\n-    };\n-\n-  /**\n-   * @if maint\n-   * Implementation of @c mem_fn for volatile member function pointers.\n-   * @endif\n-   */\n-  template<typename _Res, typename _Class, typename... _ArgTypes>\n-    class _Mem_fn<_Res (_Class::*)(_ArgTypes...) volatile>\n-    : public _Maybe_unary_or_binary_function<_Res, volatile _Class*, \n-\t\t\t\t\t     _ArgTypes...>\n-    {\n-      typedef _Res (_Class::*_Functor)(_ArgTypes...) volatile;\n-\n-      template<typename _Tp>\n-        _Res\n-        _M_call(_Tp& __object, const volatile _Class *, \n-                _ArgTypes... __args) const\n-        { return (__object.*__pmf)(__args...); }\n-\n-      template<typename _Tp>\n-        _Res\n-        _M_call(_Tp& __ptr, const volatile void *, _ArgTypes... __args) const\n-        { return ((*__ptr).*__pmf)(__args...); }\n-\n-    public:\n-      typedef _Res result_type;\n-\n-      explicit _Mem_fn(_Functor __pmf) : __pmf(__pmf) { }\n-\n-      // Handle objects\n-      _Res\n-      operator()(volatile _Class& __object, _ArgTypes... __args) const\n-      { return (__object.*__pmf)(__args...); }\n-\n-      // Handle pointers\n-      _Res\n-      operator()(volatile _Class* __object, _ArgTypes... __args) const\n-      { return (__object->*__pmf)(__args...); }\n-\n-      // Handle smart pointers, references and pointers to derived\n-      template<typename _Tp>\n-        _Res\n-\toperator()(_Tp& __object, _ArgTypes... __args) const\n-        { return _M_call(__object, &__object, __args...); }\n-\n-    private:\n-      _Functor __pmf;\n-    };\n-\n-  /**\n-   * @if maint\n-   * Implementation of @c mem_fn for const volatile member function pointers.\n-   * @endif\n-   */\n-  template<typename _Res, typename _Class, typename... _ArgTypes>\n-    class _Mem_fn<_Res (_Class::*)(_ArgTypes...) const volatile>\n-    : public _Maybe_unary_or_binary_function<_Res, const volatile _Class*, \n-\t\t\t\t\t     _ArgTypes...>\n-    {\n-      typedef _Res (_Class::*_Functor)(_ArgTypes...) const volatile;\n-\n-      template<typename _Tp>\n-        _Res\n-        _M_call(_Tp& __object, const volatile _Class *, \n-                _ArgTypes... __args) const\n-        { return (__object.*__pmf)(__args...); }\n-\n-      template<typename _Tp>\n-        _Res\n-        _M_call(_Tp& __ptr, const volatile void *, _ArgTypes... __args) const\n-        { return ((*__ptr).*__pmf)(__args...); }\n-\n-    public:\n-      typedef _Res result_type;\n-\n-      explicit _Mem_fn(_Functor __pmf) : __pmf(__pmf) { }\n-\n-      // Handle objects\n-      _Res \n-      operator()(const volatile _Class& __object, _ArgTypes... __args) const\n-      { return (__object.*__pmf)(__args...); }\n-\n-      // Handle pointers\n-      _Res \n-      operator()(const volatile _Class* __object, _ArgTypes... __args) const\n-      { return (__object->*__pmf)(__args...); }\n-\n-      // Handle smart pointers, references and pointers to derived\n-      template<typename _Tp>\n-        _Res operator()(_Tp& __object, _ArgTypes... __args) const\n-        { return _M_call(__object, &__object, __args...); }\n-\n-    private:\n-      _Functor __pmf;\n-    };\n-\n-\n-  template<typename _Res, typename _Class>\n-    class _Mem_fn<_Res _Class::*>\n-    {\n-      // This bit of genius is due to Peter Dimov, improved slightly by\n-      // Douglas Gregor.\n-      template<typename _Tp>\n-        _Res&\n-        _M_call(_Tp& __object, _Class *) const\n-        { return __object.*__pm; }\n-\n-      template<typename _Tp, typename _Up>\n-        _Res&\n-        _M_call(_Tp& __object, _Up * const *) const\n-        { return (*__object).*__pm; }\n-\n-      template<typename _Tp, typename _Up>\n-        const _Res&\n-        _M_call(_Tp& __object, const _Up * const *) const\n-        { return (*__object).*__pm; }\n-\n-      template<typename _Tp>\n-        const _Res&\n-        _M_call(_Tp& __object, const _Class *) const\n-        { return __object.*__pm; }\n-\n-      template<typename _Tp>\n-        const _Res&\n-        _M_call(_Tp& __ptr, const volatile void*) const\n-        { return (*__ptr).*__pm; }\n-\n-      template<typename _Tp> static _Tp& __get_ref();\n-\n-      template<typename _Tp>\n-        static __sfinae_types::__one __check_const(_Tp&, _Class*);\n-      template<typename _Tp, typename _Up>\n-        static __sfinae_types::__one __check_const(_Tp&, _Up * const *);\n-      template<typename _Tp, typename _Up>\n-        static __sfinae_types::__two __check_const(_Tp&, const _Up * const *);\n-      template<typename _Tp>\n-        static __sfinae_types::__two __check_const(_Tp&, const _Class*);\n-      template<typename _Tp>\n-        static __sfinae_types::__two __check_const(_Tp&, const volatile void*);\n-\n-    public:\n-      template<typename _Tp>\n-        struct _Result_type\n-\t: _Mem_fn_const_or_non<_Res,\n-\t  (sizeof(__sfinae_types::__two)\n-\t   == sizeof(__check_const<_Tp>(__get_ref<_Tp>(), (_Tp*)0)))>\n-        { };\n-\n-      template<typename _Signature>\n-        struct result;\n-\n-      template<typename _CVMem, typename _Tp>\n-        struct result<_CVMem(_Tp)>\n-\t: public _Result_type<_Tp> { };\n-\n-      template<typename _CVMem, typename _Tp>\n-        struct result<_CVMem(_Tp&)>\n-\t: public _Result_type<_Tp> { };\n-\n-      explicit\n-      _Mem_fn(_Res _Class::*__pm) : __pm(__pm) { }\n-\n-      // Handle objects\n-      _Res&\n-      operator()(_Class& __object) const\n-      { return __object.*__pm; }\n-\n-      const _Res&\n-      operator()(const _Class& __object) const\n-      { return __object.*__pm; }\n-\n-      // Handle pointers\n-      _Res&\n-      operator()(_Class* __object) const\n-      { return __object->*__pm; }\n-\n-      const _Res&\n-      operator()(const _Class* __object) const\n-      { return __object->*__pm; }\n-\n-      // Handle smart pointers and derived\n-      template<typename _Tp>\n-        typename _Result_type<_Tp>::type\n-        operator()(_Tp& __unknown) const\n-        { return _M_call(__unknown, &__unknown); }\n-\n-    private:\n-      _Res _Class::*__pm;\n-    };\n-\n-  /**\n-   *  @brief Returns a function object that forwards to the member\n-   *  pointer @a pm.\n-   */\n-  template<typename _Tp, typename _Class>\n-    inline _Mem_fn<_Tp _Class::*>\n-    mem_fn(_Tp _Class::* __pm)\n-    {\n-      return _Mem_fn<_Tp _Class::*>(__pm);\n-    }\n-\n-  /**\n-   *  @brief Determines if the given type _Tp is a function object\n-   *  should be treated as a subexpression when evaluating calls to\n-   *  function objects returned by bind(). [TR1 3.6.1]\n-   */\n-  template<typename _Tp>\n-    struct is_bind_expression\n-    { static const bool value = false; };\n-\n-  template<typename _Tp>\n-    const bool is_bind_expression<_Tp>::value;\n-\n-  /**\n-   *  @brief Determines if the given type _Tp is a placeholder in a\n-   *  bind() expression and, if so, which placeholder it is. [TR1 3.6.2]\n-   */\n-  template<typename _Tp>\n-    struct is_placeholder\n-    { static const int value = 0; };\n-\n-  template<typename _Tp>\n-    const int is_placeholder<_Tp>::value;\n-\n-  /**\n-   *  @if maint\n-   *  The type of placeholder objects defined by libstdc++.\n-   *  @endif\n-   */\n-  template<int _Num> struct _Placeholder { };\n-\n-  // Define a large number of placeholders. There is no way to\n-  // simplify this with variadic templates, because we're introducing\n-  // unique names for each.\n-  namespace placeholders { namespace {\n-    _Placeholder<1> _1;\n-    _Placeholder<2> _2;\n-    _Placeholder<3> _3;\n-    _Placeholder<4> _4;\n-    _Placeholder<5> _5;\n-    _Placeholder<6> _6;\n-    _Placeholder<7> _7;\n-    _Placeholder<8> _8;\n-    _Placeholder<9> _9;\n-    _Placeholder<10> _10;\n-    _Placeholder<11> _11;\n-    _Placeholder<12> _12;\n-    _Placeholder<13> _13;\n-    _Placeholder<14> _14;\n-    _Placeholder<15> _15;\n-    _Placeholder<16> _16;\n-    _Placeholder<17> _17;\n-    _Placeholder<18> _18;\n-    _Placeholder<19> _19;\n-    _Placeholder<20> _20;\n-    _Placeholder<21> _21;\n-    _Placeholder<22> _22;\n-    _Placeholder<23> _23;\n-    _Placeholder<24> _24;\n-    _Placeholder<25> _25;\n-    _Placeholder<26> _26;\n-    _Placeholder<27> _27;\n-    _Placeholder<28> _28;\n-    _Placeholder<29> _29;\n-  } }\n-\n-  /**\n-   *  @if maint\n-   *  Partial specialization of is_placeholder that provides the placeholder\n-   *  number for the placeholder objects defined by libstdc++.\n-   *  @endif\n-   */\n-  template<int _Num>\n-    struct is_placeholder<_Placeholder<_Num> >\n-    { static const int value = _Num; };\n-\n-  template<int _Num>\n-    const int is_placeholder<_Placeholder<_Num> >::value;\n-\n-  /**\n-   * @if maint\n-   * Stores a tuple of indices. Used by bind() to extract the elements\n-   * in a tuple. \n-   * @endif\n-   */\n-  template<int... _Indexes>\n-    struct _Index_tuple { };\n-\n-  /**\n-   *  @if maint\n-   *  Builds an _Index_tuple<0, 1, 2, ..., _Num-1>.\n-   *  @endif\n-   */\n-  template<std::size_t _Num, typename _Tuple = _Index_tuple<> >\n-    struct _Build_index_tuple;\n- \n-  template<std::size_t _Num, int... _Indexes> \n-    struct _Build_index_tuple<_Num, _Index_tuple<_Indexes...> >\n-    : _Build_index_tuple<_Num - 1, \n-                         _Index_tuple<_Indexes..., sizeof...(_Indexes)> >\n-    {\n-    };\n-\n-  template<int... _Indexes>\n-    struct _Build_index_tuple<0, _Index_tuple<_Indexes...> >\n-    {\n-      typedef _Index_tuple<_Indexes...> __type;\n-    };\n-\n-  /** \n-   * @if maint\n-   * Used by _Safe_tuple_element to indicate that there is no tuple\n-   * element at this position.\n-   * @endif\n-   */\n-  struct _No_tuple_element;\n-\n-  /**\n-   * @if maint\n-   * Implementation helper for _Safe_tuple_element. This primary\n-   * template handles the case where it is safe to use @c\n-   * tuple_element.\n-   * @endif\n-   */\n-  template<int __i, typename _Tuple, bool _IsSafe>\n-    struct _Safe_tuple_element_impl\n-    : tuple_element<__i, _Tuple> { };\n-\n-  /**\n-   * @if maint\n-   * Implementation helper for _Safe_tuple_element. This partial\n-   * specialization handles the case where it is not safe to use @c\n-   * tuple_element. We just return @c _No_tuple_element.\n-   * @endif\n-   */\n-  template<int __i, typename _Tuple>\n-    struct _Safe_tuple_element_impl<__i, _Tuple, false>\n-    {\n-      typedef _No_tuple_element type;\n-    };\n-\n-  /**\n-   * Like tuple_element, but returns @c _No_tuple_element when\n-   * tuple_element would return an error.\n-   */\n- template<int __i, typename _Tuple>\n-   struct _Safe_tuple_element\n-   : _Safe_tuple_element_impl<__i, _Tuple, \n-                              (__i >= 0 && __i < tuple_size<_Tuple>::value)>\n-   {\n-   };\n-\n-  /**\n-   *  @if maint\n-   *  Maps an argument to bind() into an actual argument to the bound\n-   *  function object [TR1 3.6.3/5]. Only the first parameter should\n-   *  be specified: the rest are used to determine among the various\n-   *  implementations. Note that, although this class is a function\n-   *  object, isn't not entirely normal because it takes only two\n-   *  parameters regardless of the number of parameters passed to the\n-   *  bind expression. The first parameter is the bound argument and\n-   *  the second parameter is a tuple containing references to the\n-   *  rest of the arguments.\n-   *  @endif\n-   */\n-  template<typename _Arg,\n-           bool _IsBindExp = is_bind_expression<_Arg>::value,\n-           bool _IsPlaceholder = (is_placeholder<_Arg>::value > 0)>\n-    class _Mu;\n-\n-  /**\n-   *  @if maint\n-   *  If the argument is reference_wrapper<_Tp>, returns the\n-   *  underlying reference. [TR1 3.6.3/5 bullet 1]\n-   *  @endif\n-   */\n-  template<typename _Tp>\n-    class _Mu<reference_wrapper<_Tp>, false, false>\n-    {\n-    public:\n-      typedef _Tp& result_type;\n-\n-      /* Note: This won't actually work for const volatile\n-       * reference_wrappers, because reference_wrapper::get() is const\n-       * but not volatile-qualified. This might be a defect in the TR.\n-       */\n-      template<typename _CVRef, typename _Tuple>\n-        result_type\n-        operator()(_CVRef& __arg, const _Tuple&) const volatile\n-        { return __arg.get(); }\n-    };\n-\n-  /**\n-   *  @if maint\n-   *  If the argument is a bind expression, we invoke the underlying\n-   *  function object with the same cv-qualifiers as we are given and\n-   *  pass along all of our arguments (unwrapped). [TR1 3.6.3/5 bullet 2]\n-   *  @endif\n-   */\n-  template<typename _Arg>\n-    class _Mu<_Arg, true, false>\n-    {\n-    public:\n-      template<typename _Signature> class result;\n-\n-      // Determine the result type when we pass the arguments along. This\n-      // involves passing along the cv-qualifiers placed on _Mu and\n-      // unwrapping the argument bundle.\n-      template<typename _CVMu, typename _CVArg, typename... _Args>\n-        class result<_CVMu(_CVArg, tuple<_Args...>)>\n-\t: public result_of<_CVArg(_Args...)> { };\n-\n-      template<typename _CVArg, typename... _Args>\n-        typename result_of<_CVArg(_Args...)>::type\n-        operator()(_CVArg& __arg,\n-\t\t   const tuple<_Args...>& __tuple) const volatile\n-        {\n-\t  // Construct an index tuple and forward to __call\n-\t  typedef typename _Build_index_tuple<sizeof...(_Args)>::__type\n-\t    _Indexes;\n-\t  return this->__call(__arg, __tuple, _Indexes());\n-\t}\n-\n-    private:\n-      // Invokes the underlying function object __arg by unpacking all\n-      // of the arguments in the tuple. \n-      template<typename _CVArg, typename... _Args, int... _Indexes>\n-        typename result_of<_CVArg(_Args...)>::type\n-        __call(_CVArg& __arg, const tuple<_Args...>& __tuple,\n-\t       const _Index_tuple<_Indexes...>&) const volatile\n-        {\n-\t  return __arg(_GLIBCXX_TR1::get<_Indexes>(__tuple)...);\n-\t}\n-    };\n-\n-  /**\n-   *  @if maint\n-   *  If the argument is a placeholder for the Nth argument, returns\n-   *  a reference to the Nth argument to the bind function object.\n-   *  [TR1 3.6.3/5 bullet 3]\n-   *  @endif\n-   */\n-  template<typename _Arg>\n-    class _Mu<_Arg, false, true>\n-    {\n-    public:\n-      template<typename _Signature> class result;\n-\n-      template<typename _CVMu, typename _CVArg, typename _Tuple>\n-        class result<_CVMu(_CVArg, _Tuple)>\n-        {\n-\t  // Add a reference, if it hasn't already been done for us.\n-\t  // This allows us to be a little bit sloppy in constructing\n-\t  // the tuple that we pass to result_of<...>.\n-\t  typedef typename _Safe_tuple_element<(is_placeholder<_Arg>::value\n-\t\t\t\t\t\t- 1), _Tuple>::type\n-\t    __base_type;\n-\n-\tpublic:\n-\t  typedef typename add_reference<__base_type>::type type;\n-\t};\n-\n-      template<typename _Tuple>\n-        typename result<_Mu(_Arg, _Tuple)>::type\n-        operator()(const volatile _Arg&, const _Tuple& __tuple) const volatile\n-        {\n-\t  return ::std::_GLIBCXX_TR1::get<(is_placeholder<_Arg>::value\n-\t\t\t\t\t   - 1)>(__tuple);\n-\t}\n-    };\n-\n-  /**\n-   *  @if maint\n-   *  If the argument is just a value, returns a reference to that\n-   *  value. The cv-qualifiers on the reference are the same as the\n-   *  cv-qualifiers on the _Mu object. [TR1 3.6.3/5 bullet 4]\n-   *  @endif\n-   */\n-  template<typename _Arg>\n-    class _Mu<_Arg, false, false>\n-    {\n-    public:\n-      template<typename _Signature> struct result;\n-\n-      template<typename _CVMu, typename _CVArg, typename _Tuple>\n-        struct result<_CVMu(_CVArg, _Tuple)>\n-        {\n-\t  typedef typename add_reference<_CVArg>::type type;\n-\t};\n-\n-      // Pick up the cv-qualifiers of the argument\n-      template<typename _CVArg, typename _Tuple>\n-        _CVArg&\n-        operator()(_CVArg& __arg, const _Tuple&) const volatile\n-        { return __arg; }\n-    };\n-\n-  /**\n-   *  @if maint\n-   *  Maps member pointers into instances of _Mem_fn but leaves all\n-   *  other function objects untouched. Used by tr1::bind(). The\n-   *  primary template handles the non--member-pointer case.\n-   *  @endif\n-   */\n-  template<typename _Tp>\n-    struct _Maybe_wrap_member_pointer\n-    {\n-      typedef _Tp type;\n-      \n-      static const _Tp&\n-      __do_wrap(const _Tp& __x)\n-      { return __x; }\n-    };\n-\n-  /**\n-   *  @if maint\n-   *  Maps member pointers into instances of _Mem_fn but leaves all\n-   *  other function objects untouched. Used by tr1::bind(). This\n-   *  partial specialization handles the member pointer case.\n-   *  @endif\n-   */\n-  template<typename _Tp, typename _Class>\n-    struct _Maybe_wrap_member_pointer<_Tp _Class::*>\n-    {\n-      typedef _Mem_fn<_Tp _Class::*> type;\n-      \n-      static type\n-      __do_wrap(_Tp _Class::* __pm)\n-      { return type(__pm); }\n-    };\n-\n-  /**\n-   *  @if maint\n-   *  Type of the function object returned from bind().\n-   *  @endif\n-   */\n-  template<typename _Signature>\n-    struct _Bind;\n-\n-   template<typename _Functor, typename... _Bound_args>\n-    class _Bind<_Functor(_Bound_args...)>\n-    : public _Weak_result_type<_Functor>\n-    {\n-      typedef _Bind __self_type;\n-      typedef typename _Build_index_tuple<sizeof...(_Bound_args)>::__type \n-        _Bound_indexes;\n-\n-      _Functor _M_f;\n-      tuple<_Bound_args...> _M_bound_args;\n-\n-      // Call unqualified\n-      template<typename... _Args, int... _Indexes>\n-        typename result_of<\n-                   _Functor(typename result_of<_Mu<_Bound_args> \n-                            (_Bound_args, tuple<_Args...>)>::type...)\n-                 >::type\n-        __call(const tuple<_Args...>& __args, _Index_tuple<_Indexes...>)\n-        {\n-          return _M_f(_Mu<_Bound_args>()\n-                      (_GLIBCXX_TR1::get<_Indexes>(_M_bound_args), __args)...);\n-        }\n-\n-      // Call as const\n-      template<typename... _Args, int... _Indexes>\n-        typename result_of<\n-                   const _Functor(typename result_of<_Mu<_Bound_args> \n-                                    (const _Bound_args, tuple<_Args...>)\n-                                  >::type...)>::type\n-        __call(const tuple<_Args...>& __args, _Index_tuple<_Indexes...>) const\n-        {\n-          return _M_f(_Mu<_Bound_args>()\n-                      (_GLIBCXX_TR1::get<_Indexes>(_M_bound_args), __args)...);\n-        }\n-\n-      // Call as volatile\n-      template<typename... _Args, int... _Indexes>\n-        typename result_of<\n-                   volatile _Functor(typename result_of<_Mu<_Bound_args> \n-                                    (volatile _Bound_args, tuple<_Args...>)\n-                                  >::type...)>::type\n-        __call(const tuple<_Args...>& __args, \n-               _Index_tuple<_Indexes...>) volatile\n-        {\n-          return _M_f(_Mu<_Bound_args>()\n-                      (_GLIBCXX_TR1::get<_Indexes>(_M_bound_args), __args)...);\n-        }\n-\n-      // Call as const volatile\n-      template<typename... _Args, int... _Indexes>\n-        typename result_of<\n-                   const volatile _Functor(typename result_of<_Mu<_Bound_args> \n-                                    (const volatile _Bound_args, \n-                                     tuple<_Args...>)\n-                                  >::type...)>::type\n-        __call(const tuple<_Args...>& __args, \n-               _Index_tuple<_Indexes...>) const volatile\n-        {\n-          return _M_f(_Mu<_Bound_args>()\n-                      (_GLIBCXX_TR1::get<_Indexes>(_M_bound_args), __args)...);\n-        }\n-\n-     public:\n-      explicit _Bind(_Functor __f, _Bound_args... __bound_args)\n-        : _M_f(__f), _M_bound_args(__bound_args...) { }\n-\n-      // Call unqualified\n-      template<typename... _Args>\n-        typename result_of<\n-                   _Functor(typename result_of<_Mu<_Bound_args> \n-                            (_Bound_args, tuple<_Args...>)>::type...)\n-                 >::type\n-        operator()(_Args&... __args)\n-        {\n-          return this->__call(_GLIBCXX_TR1::tie(__args...), _Bound_indexes());\n-        }\n-\n-      // Call as const\n-      template<typename... _Args>\n-        typename result_of<\n-                   const _Functor(typename result_of<_Mu<_Bound_args> \n-                            (const _Bound_args, tuple<_Args...>)>::type...)\n-                 >::type\n-        operator()(_Args&... __args) const\n-        {\n-          return this->__call(_GLIBCXX_TR1::tie(__args...), _Bound_indexes());\n-        }\n-\n-\n-      // Call as volatile\n-      template<typename... _Args>\n-        typename result_of<\n-                   volatile _Functor(typename result_of<_Mu<_Bound_args> \n-                            (volatile _Bound_args, tuple<_Args...>)>::type...)\n-                 >::type\n-        operator()(_Args&... __args) volatile\n-        {\n-          return this->__call(_GLIBCXX_TR1::tie(__args...), _Bound_indexes());\n-        }\n-\n-\n-      // Call as const volatile\n-      template<typename... _Args>\n-        typename result_of<\n-                   const volatile _Functor(typename result_of<_Mu<_Bound_args> \n-                            (const volatile _Bound_args, \n-                             tuple<_Args...>)>::type...)\n-                 >::type\n-        operator()(_Args&... __args) const volatile\n-        {\n-          return this->__call(_GLIBCXX_TR1::tie(__args...), _Bound_indexes());\n-        }\n-    };\n-\n-  /**\n-   *  @if maint\n-   *  Type of the function object returned from bind<R>().\n-   *  @endif\n-   */\n-  template<typename _Result, typename _Signature>\n-    struct _Bind_result;\n-\n-  template<typename _Result, typename _Functor, typename... _Bound_args>\n-    class _Bind_result<_Result, _Functor(_Bound_args...)>\n-    {\n-      typedef _Bind_result __self_type;\n-      typedef typename _Build_index_tuple<sizeof...(_Bound_args)>::__type \n-        _Bound_indexes;\n-\n-      _Functor _M_f;\n-      tuple<_Bound_args...> _M_bound_args;\n-\n-      // Call unqualified\n-      template<typename... _Args, int... _Indexes>\n-        _Result\n-        __call(const tuple<_Args...>& __args, _Index_tuple<_Indexes...>)\n-        {\n-          return _M_f(_Mu<_Bound_args>()\n-                      (_GLIBCXX_TR1::get<_Indexes>(_M_bound_args), __args)...);\n-        }\n-\n-      // Call as const\n-      template<typename... _Args, int... _Indexes>\n-        _Result\n-        __call(const tuple<_Args...>& __args, _Index_tuple<_Indexes...>) const\n-        {\n-          return _M_f(_Mu<_Bound_args>()\n-                      (_GLIBCXX_TR1::get<_Indexes>(_M_bound_args), __args)...);\n-        }\n-\n-      // Call as volatile\n-      template<typename... _Args, int... _Indexes>\n-        _Result\n-        __call(const tuple<_Args...>& __args, \n-               _Index_tuple<_Indexes...>) volatile\n-        {\n-          return _M_f(_Mu<_Bound_args>()\n-                      (_GLIBCXX_TR1::get<_Indexes>(_M_bound_args), __args)...);\n-        }\n-\n-      // Call as const volatile\n-      template<typename... _Args, int... _Indexes>\n-        _Result\n-        __call(const tuple<_Args...>& __args, \n-               _Index_tuple<_Indexes...>) const volatile\n-        {\n-          return _M_f(_Mu<_Bound_args>()\n-                      (_GLIBCXX_TR1::get<_Indexes>(_M_bound_args), __args)...);\n-        }\n-\n-    public:\n-      typedef _Result result_type;\n-\n-      explicit\n-      _Bind_result(_Functor __f, _Bound_args... __bound_args)\n-      : _M_f(__f), _M_bound_args(__bound_args...) { }\n-\n-      // Call unqualified\n-      template<typename... _Args>\n-        result_type\n-        operator()(_Args&... __args)\n-        {\n-          return this->__call(_GLIBCXX_TR1::tie(__args...), _Bound_indexes());\n-        }\n-\n-      // Call as const\n-      template<typename... _Args>\n-        result_type\n-        operator()(_Args&... __args) const\n-        {\n-          return this->__call(_GLIBCXX_TR1::tie(__args...), _Bound_indexes());\n-        }\n-\n-      // Call as volatile\n-      template<typename... _Args>\n-        result_type\n-        operator()(_Args&... __args) volatile\n-        {\n-          return this->__call(_GLIBCXX_TR1::tie(__args...), _Bound_indexes());\n-        }\n-\n-      // Call as const volatile\n-      template<typename... _Args>\n-        result_type\n-        operator()(_Args&... __args) const volatile\n-        {\n-          return this->__call(_GLIBCXX_TR1::tie(__args...), _Bound_indexes());\n-        }\n-    };\n-\n-  /**\n-   *  @if maint\n-   *  Class template _Bind is always a bind expression.\n-   *  @endif\n-   */\n-  template<typename _Signature>\n-    struct is_bind_expression<_Bind<_Signature> >\n-    { static const bool value = true; };\n-\n-  template<typename _Signature>\n-    const bool is_bind_expression<_Bind<_Signature> >::value;\n-\n-  /**\n-   *  @if maint\n-   *  Class template _Bind_result is always a bind expression.\n-   *  @endif\n-   */\n-  template<typename _Result, typename _Signature>\n-    struct is_bind_expression<_Bind_result<_Result, _Signature> >\n-    { static const bool value = true; };\n-\n-  template<typename _Result, typename _Signature>\n-    const bool is_bind_expression<_Bind_result<_Result, _Signature> >::value;\n-\n-  template<typename _Functor, typename... _ArgTypes>\n-    inline\n-    _Bind<typename _Maybe_wrap_member_pointer<_Functor>::type(_ArgTypes...)>\n-    bind(_Functor __f, _ArgTypes... __args)\n-    {\n-      typedef _Maybe_wrap_member_pointer<_Functor> __maybe_type;\n-      typedef typename __maybe_type::type __functor_type;\n-      typedef _Bind<__functor_type(_ArgTypes...)> __result_type;\n-      return __result_type(__maybe_type::__do_wrap(__f), __args...);\n-    } \n-\n-  template<typename _Result, typename _Functor, typename... _ArgTypes>\n-    inline\n-    _Bind_result<_Result,\n-\t\t typename _Maybe_wrap_member_pointer<_Functor>::type\n-                            (_ArgTypes...)>\n-    bind(_Functor __f, _ArgTypes... __args)\n-    {\n-      typedef _Maybe_wrap_member_pointer<_Functor> __maybe_type;\n-      typedef typename __maybe_type::type __functor_type;\n-      typedef _Bind_result<_Result, __functor_type(_ArgTypes...)>\n-\t__result_type;\n-      return __result_type(__maybe_type::__do_wrap(__f), __args...);\n-    }\n-\n-  /**\n-   *  @brief Exception class thrown when class template function's\n-   *  operator() is called with an empty target.\n-   *\n-   */\n-  class bad_function_call : public std::exception { };\n-\n-  /**\n-   *  @if maint\n-   *  The integral constant expression 0 can be converted into a\n-   *  pointer to this type. It is used by the function template to\n-   *  accept NULL pointers.\n-   *  @endif\n-   */\n-  struct _M_clear_type;\n-\n-  /**\n-   *  @if maint\n-   *  Trait identifying \"location-invariant\" types, meaning that the\n-   *  address of the object (or any of its members) will not escape.\n-   *  Also implies a trivial copy constructor and assignment operator.\n-   *   @endif\n-   */\n-  template<typename _Tp>\n-    struct __is_location_invariant\n-    : integral_constant<bool,\n-                        (is_pointer<_Tp>::value\n-                         || is_member_pointer<_Tp>::value)>\n-    {\n-    };\n-\n-  class _Undefined_class;\n-\n-  union _Nocopy_types\n-  {\n-    void*       _M_object;\n-    const void* _M_const_object;\n-    void (*_M_function_pointer)();\n-    void (_Undefined_class::*_M_member_pointer)();\n-  };\n-\n-  union _Any_data\n-  {\n-    void*       _M_access()       { return &_M_pod_data[0]; }\n-    const void* _M_access() const { return &_M_pod_data[0]; }\n-\n-    template<typename _Tp>\n-      _Tp&\n-      _M_access()\n-      { return *static_cast<_Tp*>(_M_access()); }\n-\n-    template<typename _Tp>\n-      const _Tp&\n-      _M_access() const\n-      { return *static_cast<const _Tp*>(_M_access()); }\n-\n-    _Nocopy_types _M_unused;\n-    char _M_pod_data[sizeof(_Nocopy_types)];\n-  };\n-\n-  enum _Manager_operation\n-  {\n-    __get_type_info,\n-    __get_functor_ptr,\n-    __clone_functor,\n-    __destroy_functor\n-  };\n-\n-  /* Simple type wrapper that helps avoid annoying const problems\n-     when casting between void pointers and pointers-to-pointers. */\n-  template<typename _Tp>\n-    struct _Simple_type_wrapper\n-    {\n-      _Simple_type_wrapper(_Tp __value) : __value(__value) { }\n-\n-      _Tp __value;\n-    };\n-\n-  template<typename _Tp>\n-    struct __is_location_invariant<_Simple_type_wrapper<_Tp> >\n-    : __is_location_invariant<_Tp>\n-    {\n-    };\n-\n-  // Converts a reference to a function object into a callable\n-  // function object.\n-  template<typename _Functor>\n-    inline _Functor&\n-    __callable_functor(_Functor& __f)\n-    { return __f; }\n-\n-  template<typename _Member, typename _Class>\n-    inline _Mem_fn<_Member _Class::*>\n-    __callable_functor(_Member _Class::* &__p)\n-    { return mem_fn(__p); }\n-\n-  template<typename _Member, typename _Class>\n-    inline _Mem_fn<_Member _Class::*>\n-    __callable_functor(_Member _Class::* const &__p)\n-    { return mem_fn(__p); }\n-\n-  template<typename _Signature>\n-    class function;\n-\n-  /**\n-   *  @if maint\n-   *  Base class of all polymorphic function object wrappers.\n-   *  @endif\n-   */\n-  class _Function_base\n-  {\n-  public:\n-    static const std::size_t _M_max_size = sizeof(_Nocopy_types);\n-    static const std::size_t _M_max_align = __alignof__(_Nocopy_types);\n-\n-    template<typename _Functor>\n-      class _Base_manager\n-      {\n-      protected:\n-\tstatic const bool __stored_locally =\n-        (__is_location_invariant<_Functor>::value\n-         && sizeof(_Functor) <= _M_max_size\n-         && __alignof__(_Functor) <= _M_max_align\n-         && (_M_max_align % __alignof__(_Functor) == 0));\n-\t\n-\ttypedef integral_constant<bool, __stored_locally> _Local_storage;\n-\n-\t// Retrieve a pointer to the function object\n-\tstatic _Functor*\n-\t_M_get_pointer(const _Any_data& __source)\n-\t{\n-\t  const _Functor* __ptr =\n-\t    __stored_locally? &__source._M_access<_Functor>()\n-\t    /* have stored a pointer */ : __source._M_access<_Functor*>();\n-\t  return const_cast<_Functor*>(__ptr);\n-\t}\n-\n-\t// Clone a location-invariant function object that fits within\n-\t// an _Any_data structure.\n-\tstatic void\n-\t_M_clone(_Any_data& __dest, const _Any_data& __source, true_type)\n-\t{\n-\t  new (__dest._M_access()) _Functor(__source._M_access<_Functor>());\n-\t}\n-\n-\t// Clone a function object that is not location-invariant or\n-\t// that cannot fit into an _Any_data structure.\n-\tstatic void\n-\t_M_clone(_Any_data& __dest, const _Any_data& __source, false_type)\n-\t{\n-\t  __dest._M_access<_Functor*>() =\n-\t    new _Functor(*__source._M_access<_Functor*>());\n-\t}\n-\n-\t// Destroying a location-invariant object may still require\n-\t// destruction.\n-\tstatic void\n-\t_M_destroy(_Any_data& __victim, true_type)\n-\t{\n-\t  __victim._M_access<_Functor>().~_Functor();\n-\t}\n-\t\n-\t// Destroying an object located on the heap.\n-\tstatic void\n-\t_M_destroy(_Any_data& __victim, false_type)\n-\t{\n-\t  delete __victim._M_access<_Functor*>();\n-\t}\n-\t\n-      public:\n-\tstatic bool\n-\t_M_manager(_Any_data& __dest, const _Any_data& __source,\n-\t\t   _Manager_operation __op)\n-\t{\n-\t  switch (__op)\n-\t    {\n-\t    case __get_type_info:\n-\t      __dest._M_access<const type_info*>() = &typeid(_Functor);\n-\t      break;\n-\n-\t    case __get_functor_ptr:\n-\t      __dest._M_access<_Functor*>() = _M_get_pointer(__source);\n-\t      break;\n-\t      \n-\t    case __clone_functor:\n-\t      _M_clone(__dest, __source, _Local_storage());\n-\t      break;\n-\n-\t    case __destroy_functor:\n-\t      _M_destroy(__dest, _Local_storage());\n-\t      break;\n-\t    }\n-\t  return false;\n-\t}\n-\n-\tstatic void\n-\t_M_init_functor(_Any_data& __functor, const _Functor& __f)\n-\t{\n-\t  _M_init_functor(__functor, __f, _Local_storage());\n-\t}\n-\t\n-\ttemplate<typename _Signature>\n-\t  static bool\n-\t  _M_not_empty_function(const function<_Signature>& __f)\n-\t  {\n-\t    return __f;\n-\t  }\n-\n-\ttemplate<typename _Tp>\n-\t  static bool\n-\t  _M_not_empty_function(const _Tp*& __fp)\n-\t  {\n-\t    return __fp;\n-\t  }\n-\n-\ttemplate<typename _Class, typename _Tp>\n-\t  static bool\n-\t  _M_not_empty_function(_Tp _Class::* const& __mp)\n-\t  {\n-\t    return __mp;\n-\t  }\n-\n-\ttemplate<typename _Tp>\n-\t  static bool\n-\t  _M_not_empty_function(const _Tp&)\n-\t  {\n-\t    return true;\n-\t  }\n-\n-      private:\n-\tstatic void\n-\t_M_init_functor(_Any_data& __functor, const _Functor& __f, true_type)\n-\t{\n-\t  new (__functor._M_access()) _Functor(__f);\n-\t}\n-\n-\tstatic void\n-\t_M_init_functor(_Any_data& __functor, const _Functor& __f, false_type)\n-\t{\n-\t  __functor._M_access<_Functor*>() = new _Functor(__f);\n-\t}\n-      };\n-\n-    template<typename _Functor>\n-      class _Ref_manager : public _Base_manager<_Functor*>\n-      {\n-\ttypedef _Function_base::_Base_manager<_Functor*> _Base;\n-\n-    public:\n-\tstatic bool\n-\t_M_manager(_Any_data& __dest, const _Any_data& __source,\n-\t\t   _Manager_operation __op)\n-\t{\n-\t  switch (__op)\n-\t    {\n-\t    case __get_type_info:\n-\t      __dest._M_access<const type_info*>() = &typeid(_Functor);\n-\t      break;\n-\t      \n-\t    case __get_functor_ptr:\n-\t      __dest._M_access<_Functor*>() = *_Base::_M_get_pointer(__source);\n-\t      return is_const<_Functor>::value;\n-\t      break;\n-\t      \n-\t    default:\n-\t      _Base::_M_manager(__dest, __source, __op);\n-\t    }\n-\t  return false;\n-\t}\n-\n-\tstatic void\n-\t_M_init_functor(_Any_data& __functor, reference_wrapper<_Functor> __f)\n-\t{\n-\t  // TBD: Use address_of function instead\n-\t  _Base::_M_init_functor(__functor, &__f.get());\n-\t}\n-      };\n-\n-    _Function_base() : _M_manager(0) { }\n-    \n-    ~_Function_base()\n-    {\n-      if (_M_manager)\n-\t_M_manager(_M_functor, _M_functor, __destroy_functor);\n-    }\n-\n-\n-    bool _M_empty() const { return !_M_manager; }\n-\n-    typedef bool (*_Manager_type)(_Any_data&, const _Any_data&,\n-                                  _Manager_operation);\n-\n-    _Any_data     _M_functor;\n-    _Manager_type _M_manager;\n-  };\n-\n-  template<typename _Signature, typename _Functor>\n-    class _Function_handler;\n-\n-  template<typename _Res, typename _Functor, typename... _ArgTypes>\n-    class _Function_handler<_Res(_ArgTypes...), _Functor>\n-    : public _Function_base::_Base_manager<_Functor>\n-    {\n-      typedef _Function_base::_Base_manager<_Functor> _Base;\n-\n-    public:\n-      static _Res\n-      _M_invoke(const _Any_data& __functor, _ArgTypes... __args)\n-      {\n-        return (*_Base::_M_get_pointer(__functor))(__args...);\n-      }\n-    };\n-\n-  template<typename _Functor, typename... _ArgTypes>\n-    class _Function_handler<void(_ArgTypes...), _Functor>\n-    : public _Function_base::_Base_manager<_Functor>\n-    {\n-      typedef _Function_base::_Base_manager<_Functor> _Base;\n-\n-     public:\n-      static void\n-      _M_invoke(const _Any_data& __functor, _ArgTypes... __args)\n-      {\n-        (*_Base::_M_get_pointer(__functor))(__args...);\n-      }\n-    };\n-\n-  template<typename _Res, typename _Functor, typename... _ArgTypes>\n-    class _Function_handler<_Res(_ArgTypes...), reference_wrapper<_Functor> >\n-    : public _Function_base::_Ref_manager<_Functor>\n-    {\n-      typedef _Function_base::_Ref_manager<_Functor> _Base;\n-\n-     public:\n-      static _Res\n-      _M_invoke(const _Any_data& __functor, _ArgTypes... __args)\n-      {\n-        return \n-          __callable_functor(**_Base::_M_get_pointer(__functor))(__args...);\n-      }\n-    };\n-\n-  template<typename _Functor, typename... _ArgTypes>\n-    class _Function_handler<void(_ArgTypes...), reference_wrapper<_Functor> >\n-    : public _Function_base::_Ref_manager<_Functor>\n-    {\n-      typedef _Function_base::_Ref_manager<_Functor> _Base;\n-\n-     public:\n-      static void\n-      _M_invoke(const _Any_data& __functor, _ArgTypes... __args)\n-      {\n-        __callable_functor(**_Base::_M_get_pointer(__functor))(__args...);\n-      }\n-    };\n-\n-  template<typename _Class, typename _Member, typename _Res, \n-           typename... _ArgTypes>\n-    class _Function_handler<_Res(_ArgTypes...), _Member _Class::*>\n-    : public _Function_handler<void(_ArgTypes...), _Member _Class::*>\n-    {\n-      typedef _Function_handler<void(_ArgTypes...), _Member _Class::*>\n-        _Base;\n-\n-     public:\n-      static _Res\n-      _M_invoke(const _Any_data& __functor, _ArgTypes... __args)\n-      {\n-        return _GLIBCXX_TR1::\n-\t  mem_fn(_Base::_M_get_pointer(__functor)->__value)(__args...);\n-      }\n-    };\n-\n-  template<typename _Class, typename _Member, typename... _ArgTypes>\n-    class _Function_handler<void(_ArgTypes...), _Member _Class::*>\n-    : public _Function_base::_Base_manager<\n-                 _Simple_type_wrapper< _Member _Class::* > >\n-    {\n-      typedef _Member _Class::* _Functor;\n-      typedef _Simple_type_wrapper<_Functor> _Wrapper;\n-      typedef _Function_base::_Base_manager<_Wrapper> _Base;\n-\n-     public:\n-      static bool\n-      _M_manager(_Any_data& __dest, const _Any_data& __source,\n-                 _Manager_operation __op)\n-      {\n-        switch (__op)\n-\t  {\n-\t  case __get_type_info:\n-\t    __dest._M_access<const type_info*>() = &typeid(_Functor);\n-\t    break;\n-\t    \n-\t  case __get_functor_ptr:\n-\t    __dest._M_access<_Functor*>() =\n-\t      &_Base::_M_get_pointer(__source)->__value;\n-\t    break;\n-\t    \n-\t  default:\n-\t    _Base::_M_manager(__dest, __source, __op);\n-\t  }\n-        return false;\n-      }\n-\n-      static void\n-      _M_invoke(const _Any_data& __functor, _ArgTypes... __args)\n-      {\n-        _GLIBCXX_TR1::\n-\t  mem_fn(_Base::_M_get_pointer(__functor)->__value)(__args...);\n-      }\n-    };\n-\n-  template<typename _Res, typename... _ArgTypes>\n-    class function<_Res(_ArgTypes...)>\n-    : public _Maybe_unary_or_binary_function<_Res, _ArgTypes...>,\n-      private _Function_base\n-    {\n-      /**\n-       *  @if maint\n-       *  This class is used to implement the safe_bool idiom.\n-       *  @endif\n-       */\n-      struct _Hidden_type\n-      {\n-\t_Hidden_type* _M_bool;\n-      };\n-\n-      /**\n-       *  @if maint\n-       *  This typedef is used to implement the safe_bool idiom.\n-       *  @endif\n-       */\n-      typedef _Hidden_type* _Hidden_type::* _Safe_bool;\n-\n-      typedef _Res _Signature_type(_ArgTypes...);\n-      \n-      struct _Useless {};\n-      \n-    public:\n-      typedef _Res result_type;\n-      \n-      // [3.7.2.1] construct/copy/destroy\n-      \n-      /**\n-       *  @brief Default construct creates an empty function call wrapper.\n-       *  @post @c !(bool)*this\n-       */\n-      function() : _Function_base() { }\n-      \n-      /**\n-       *  @brief Default construct creates an empty function call wrapper.\n-       *  @post @c !(bool)*this\n-       */\n-      function(_M_clear_type*) : _Function_base() { }\n-      \n-      /**\n-       *  @brief %Function copy constructor.\n-       *  @param x A %function object with identical call signature.\n-       *  @pre @c (bool)*this == (bool)x\n-       *\n-       *  The newly-created %function contains a copy of the target of @a\n-       *  x (if it has one).\n-       */\n-      function(const function& __x);\n-      \n-      /**\n-       *  @brief Builds a %function that targets a copy of the incoming\n-       *  function object.\n-       *  @param f A %function object that is callable with parameters of\n-       *  type @c T1, @c T2, ..., @c TN and returns a value convertible\n-       *  to @c Res.\n-       *\n-       *  The newly-created %function object will target a copy of @a\n-       *  f. If @a f is @c reference_wrapper<F>, then this function\n-       *  object will contain a reference to the function object @c\n-       *  f.get(). If @a f is a NULL function pointer or NULL\n-       *  pointer-to-member, the newly-created object will be empty.\n-       *\n-       *  If @a f is a non-NULL function pointer or an object of type @c\n-       *  reference_wrapper<F>, this function will not throw.\n-       */\n-      template<typename _Functor>\n-        function(_Functor __f,\n-                 typename __gnu_cxx::__enable_if<\n-                           !is_integral<_Functor>::value, _Useless>::__type\n-                   = _Useless());\n-\n-      /**\n-       *  @brief %Function assignment operator.\n-       *  @param x A %function with identical call signature.\n-       *  @post @c (bool)*this == (bool)x\n-       *  @returns @c *this\n-       *\n-       *  The target of @a x is copied to @c *this. If @a x has no\n-       *  target, then @c *this will be empty.\n-       *\n-       *  If @a x targets a function pointer or a reference to a function\n-       *  object, then this operation will not throw an exception.\n-       */\n-      function&\n-      operator=(const function& __x)\n-      {\n-        function(__x).swap(*this);\n-        return *this;\n-      }\n-\n-      /**\n-       *  @brief %Function assignment to zero.\n-       *  @post @c !(bool)*this\n-       *  @returns @c *this\n-       *\n-       *  The target of @a *this is deallocated, leaving it empty.\n-       */\n-      function&\n-      operator=(_M_clear_type*)\n-      {\n-        if (_M_manager)\n-\t  {\n-\t    _M_manager(_M_functor, _M_functor, __destroy_functor);\n-\t    _M_manager = 0;\n-\t    _M_invoker = 0;\n-\t  }\n-        return *this;\n-      }\n-\n-      /**\n-       *  @brief %Function assignment to a new target.\n-       *  @param f A %function object that is callable with parameters of\n-       *  type @c T1, @c T2, ..., @c TN and returns a value convertible\n-       *  to @c Res.\n-       *  @return @c *this\n-       *\n-       *  This  %function object wrapper will target a copy of @a\n-       *  f. If @a f is @c reference_wrapper<F>, then this function\n-       *  object will contain a reference to the function object @c\n-       *  f.get(). If @a f is a NULL function pointer or NULL\n-       *  pointer-to-member, @c this object will be empty.\n-       *\n-       *  If @a f is a non-NULL function pointer or an object of type @c\n-       *  reference_wrapper<F>, this function will not throw.\n-       */\n-      template<typename _Functor>\n-        typename __gnu_cxx::__enable_if<!is_integral<_Functor>::value,\n-\t                                function&>::__type\n-\toperator=(_Functor __f)\n-\t{\n-\t  function(__f).swap(*this);\n-\t  return *this;\n-\t}\n-\n-      // [3.7.2.2] function modifiers\n-      \n-      /**\n-       *  @brief Swap the targets of two %function objects.\n-       *  @param f A %function with identical call signature.\n-       *\n-       *  Swap the targets of @c this function object and @a f. This\n-       *  function will not throw an exception.\n-       */\n-      void swap(function& __x)\n-      {\n-\t_Any_data __old_functor = _M_functor;\n-\t_M_functor = __x._M_functor;\n-\t__x._M_functor = __old_functor;\n-\t_Manager_type __old_manager = _M_manager;\n-\t_M_manager = __x._M_manager;\n-\t__x._M_manager = __old_manager;\n-\t_Invoker_type __old_invoker = _M_invoker;\n-\t_M_invoker = __x._M_invoker;\n-\t__x._M_invoker = __old_invoker;\n-      }\n-      \n-      // [3.7.2.3] function capacity\n-\n-      /**\n-       *  @brief Determine if the %function wrapper has a target.\n-       *\n-       *  @return @c true when this %function object contains a target,\n-       *  or @c false when it is empty.\n-       *\n-       *  This function will not throw an exception.\n-       */\n-      operator _Safe_bool() const\n-      {\n-        if (_M_empty())\n-\t  return 0;\n-\telse\n-\t  return &_Hidden_type::_M_bool;\n-      }\n-\n-      // [3.7.2.4] function invocation\n-\n-      /**\n-       *  @brief Invokes the function targeted by @c *this.\n-       *  @returns the result of the target.\n-       *  @throws bad_function_call when @c !(bool)*this\n-       *\n-       *  The function call operator invokes the target function object\n-       *  stored by @c this.\n-       */\n-      _Res operator()(_ArgTypes... __args) const;\n-      \n-      // [3.7.2.5] function target access\n-      /**\n-       *  @brief Determine the type of the target of this function object\n-       *  wrapper.\n-       *\n-       *  @returns the type identifier of the target function object, or\n-       *  @c typeid(void) if @c !(bool)*this.\n-       *\n-       *  This function will not throw an exception.\n-       */\n-      const type_info& target_type() const;\n-      \n-      /**\n-       *  @brief Access the stored target function object.\n-       *\n-       *  @return Returns a pointer to the stored target function object,\n-       *  if @c typeid(Functor).equals(target_type()); otherwise, a NULL\n-       *  pointer.\n-       *\n-       * This function will not throw an exception.\n-       */\n-      template<typename _Functor>       _Functor* target();\n-      \n-      /**\n-       *  @overload\n-       */\n-      template<typename _Functor> const _Functor* target() const;\n-      \n-    private:\n-      // [3.7.2.6] undefined operators\n-      template<typename _Function>\n-\tvoid operator==(const function<_Function>&) const;\n-      template<typename _Function>\n-\tvoid operator!=(const function<_Function>&) const;\n-\n-      typedef _Res (*_Invoker_type)(const _Any_data&, _ArgTypes...);\n-      _Invoker_type _M_invoker;\n-  };\n-\n-  template<typename _Res, typename... _ArgTypes>\n-    function<_Res(_ArgTypes...)>::\n-    function(const function& __x)\n-    : _Function_base()\n-    {\n-      if (__x)\n-\t{\n-\t  _M_invoker = __x._M_invoker;\n-\t  _M_manager = __x._M_manager;\n-\t  __x._M_manager(_M_functor, __x._M_functor, __clone_functor);\n-\t}\n-    }\n-\n-  template<typename _Res, typename... _ArgTypes>\n-    template<typename _Functor>\n-      function<_Res(_ArgTypes...)>::\n-      function(_Functor __f,\n-\t       typename __gnu_cxx::__enable_if<\n-                       !is_integral<_Functor>::value, _Useless>::__type)\n-      : _Function_base()\n-      {\n-\ttypedef _Function_handler<_Signature_type, _Functor> _My_handler;\n-\n-\tif (_My_handler::_M_not_empty_function(__f))\n-\t  {\n-\t    _M_invoker = &_My_handler::_M_invoke;\n-\t    _M_manager = &_My_handler::_M_manager;\n-\t    _My_handler::_M_init_functor(_M_functor, __f);\n-\t  }\n-      }\n+#include <tr1/functional_hash.h>\n \n-  template<typename _Res, typename... _ArgTypes>\n-    _Res\n-    function<_Res(_ArgTypes...)>::\n-    operator()(_ArgTypes... __args) const\n-    {\n-      if (_M_empty())\n-        {\n-#if __EXCEPTIONS\n-          throw bad_function_call();\n+#if defined(_GLIBCXX_INCLUDE_AS_TR1)\n+#  include <tr1_impl/functional>\n #else\n-          __builtin_abort();\n+#  define _GLIBCXX_INCLUDE_AS_TR1\n+#  define _GLIBCXX_BEGIN_NAMESPACE_TR1 namespace tr1 {\n+#  define _GLIBCXX_END_NAMESPACE_TR1 }\n+#  define _GLIBCXX_TR1 tr1::\n+#  include <tr1_impl/functional>\n+#  undef _GLIBCXX_TR1\n+#  undef _GLIBCXX_END_NAMESPACE_TR1\n+#  undef _GLIBCXX_BEGIN_NAMESPACE_TR1\n+#  undef _GLIBCXX_INCLUDE_AS_TR1\n #endif\n-        }\n-      return _M_invoker(_M_functor, __args...);\n-    }\n-\n-  template<typename _Res, typename... _ArgTypes>\n-    const type_info&\n-    function<_Res(_ArgTypes...)>::\n-    target_type() const\n-    {\n-      if (_M_manager)\n-        {\n-          _Any_data __typeinfo_result;\n-          _M_manager(__typeinfo_result, _M_functor, __get_type_info);\n-          return *__typeinfo_result._M_access<const type_info*>();\n-        }\n-      else\n-\treturn typeid(void);\n-    }\n-\n-  template<typename _Res, typename... _ArgTypes>\n-    template<typename _Functor>\n-      _Functor*\n-      function<_Res(_ArgTypes...)>::\n-      target()\n-      {\n-\tif (typeid(_Functor) == target_type() && _M_manager)\n-\t  {\n-\t    _Any_data __ptr;\n-\t    if (_M_manager(__ptr, _M_functor, __get_functor_ptr)\n-\t\t&& !is_const<_Functor>::value)\n-\t      return 0;\n-\t    else\n-\t      return __ptr._M_access<_Functor*>();\n-\t  }\n-\telse\n-\t  return 0;\n-      }\n-\n-  template<typename _Res, typename... _ArgTypes>\n-    template<typename _Functor>\n-      const _Functor*\n-      function<_Res(_ArgTypes...)>::\n-      target() const\n-      {\n-\tif (typeid(_Functor) == target_type() && _M_manager)\n-\t  {\n-\t    _Any_data __ptr;\n-\t    _M_manager(__ptr, _M_functor, __get_functor_ptr);\n-\t    return __ptr._M_access<const _Functor*>();\n-\t  }\n-\telse\n-\t  return 0;\n-      }\n-\n-  // [3.7.2.7] null pointer comparisons\n-\n-  /**\n-   *  @brief Compares a polymorphic function object wrapper against 0\n-   *  (the NULL pointer).\n-   *  @returns @c true if the wrapper has no target, @c false otherwise\n-   *\n-   *  This function will not throw an exception.\n-   */\n-  template<typename _Signature>\n-    inline bool\n-    operator==(const function<_Signature>& __f, _M_clear_type*)\n-    { \n-      return !__f;\n-    }\n-\n-  /**\n-   *  @overload\n-   */\n-  template<typename _Signature>\n-    inline bool\n-    operator==(_M_clear_type*, const function<_Signature>& __f)\n-    {\n-      return !__f;\n-    }\n \n-  /**\n-   *  @brief Compares a polymorphic function object wrapper against 0\n-   *  (the NULL pointer).\n-   *  @returns @c false if the wrapper has no target, @c true otherwise\n-   *\n-   *  This function will not throw an exception.\n-   */\n-  template<typename _Signature>\n-    inline bool\n-    operator!=(const function<_Signature>& __f, _M_clear_type*)\n-    {\n-      return __f;\n-    }\n-\n-  /**\n-   *  @overload\n-   */\n-  template<typename _Signature>\n-    inline bool\n-    operator!=(_M_clear_type*, const function<_Signature>& __f)\n-    {\n-      return __f;\n-    }\n-\n-  // [3.7.2.8] specialized algorithms\n-\n-  /**\n-   *  @brief Swap the targets of two polymorphic function object wrappers.\n-   *\n-   *  This function will not throw an exception.\n-   */\n-  template<typename _Signature>\n-    inline void\n-    swap(function<_Signature>& __x, function<_Signature>& __y)\n-    {\n-      __x.swap(__y);\n-    }\n-\n-_GLIBCXX_END_NAMESPACE\n-}\n-\n-#include <tr1/functional_hash.h>\n-\n-#endif\n+#endif // _GLIBCXX_TR1_FUNCTIONAL"}, {"sha": "a41b232d67b9b2d8dbac921396ea825192e53c81", "filename": "libstdc++-v3/include/tr1/functional_hash.h", "status": "modified", "additions": 20, "deletions": 193, "changes": 213, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e133ace8d907bf42754c86106fc3f04a9d9fe70f/libstdc%2B%2B-v3%2Finclude%2Ftr1%2Ffunctional_hash.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e133ace8d907bf42754c86106fc3f04a9d9fe70f/libstdc%2B%2B-v3%2Finclude%2Ftr1%2Ffunctional_hash.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Ftr1%2Ffunctional_hash.h?ref=e133ace8d907bf42754c86106fc3f04a9d9fe70f", "patch": "@@ -1,4 +1,4 @@\n-// TR1 functional -*- C++ -*-\n+// TR1 functional_hash.h header -*- C++ -*-\n \n // Copyright (C) 2007 Free Software Foundation, Inc.\n //\n@@ -32,200 +32,27 @@\n  *  You should not attempt to use it directly.\n  */\n \n-#ifndef _TR1_FUNCTIONAL_HASH_H\n-#define _TR1_FUNCTIONAL_HASH_H 1\n+#ifndef _GLIBCXX_TR1_FUNCTIONAL_HASH_H\n+#define _GLIBCXX_TR1_FUNCTIONAL_HASH_H 1\n \n-#include <string>\n-#include <cmath>  // for std::frexp\n+#pragma GCC system_header\n \n-namespace std\n-{\n-_GLIBCXX_BEGIN_NAMESPACE(_GLIBCXX_TR1)\n-\n-  // Definition of default hash function std::tr1::hash<>.  The types for\n-  // which std::tr1::hash<T> is defined is in clause 6.3.3. of the PDTR.\n-  template<typename T>\n-    struct hash;\n-\n-#define _TR1_hashtable_define_trivial_hash(_Tp)         \\\n-  template<>                                            \\\n-    struct hash<_Tp>                                    \\\n-    : public std::unary_function<_Tp, std::size_t>      \\\n-    {                                                   \\\n-      std::size_t                                       \\\n-      operator()(_Tp __val) const                       \\\n-      { return static_cast<std::size_t>(__val); }       \\\n-    }                                                     \n-\n-  _TR1_hashtable_define_trivial_hash(bool);\n-  _TR1_hashtable_define_trivial_hash(char);\n-  _TR1_hashtable_define_trivial_hash(signed char);\n-  _TR1_hashtable_define_trivial_hash(unsigned char);\n-  _TR1_hashtable_define_trivial_hash(wchar_t);\n-  _TR1_hashtable_define_trivial_hash(short);\n-  _TR1_hashtable_define_trivial_hash(int);\n-  _TR1_hashtable_define_trivial_hash(long);\n-  _TR1_hashtable_define_trivial_hash(long long);\n-  _TR1_hashtable_define_trivial_hash(unsigned short);\n-  _TR1_hashtable_define_trivial_hash(unsigned int);\n-  _TR1_hashtable_define_trivial_hash(unsigned long);\n-  _TR1_hashtable_define_trivial_hash(unsigned long long);\n-\n-#undef _TR1_hashtable_define_trivial_hash\n-\n-  template<typename _Tp>\n-    struct hash<_Tp*>\n-    : public std::unary_function<_Tp*, std::size_t>\n-    {\n-      std::size_t\n-      operator()(_Tp* __p) const\n-      { return reinterpret_cast<std::size_t>(__p); }\n-    };\n-\n-  // Fowler / Noll / Vo (FNV) Hash (type FNV-1a)\n-  // (used by the next specializations of std::tr1::hash<>)\n-\n-  // Dummy generic implementation (for sizeof(size_t) != 4, 8).\n-  template<std::size_t = sizeof(std::size_t)>\n-    struct _Fnv_hash\n-    {\n-      static std::size_t\n-      hash(const char* __first, std::size_t __length)\n-      {\n-\tstd::size_t __result = 0;\n-\tfor (; __length > 0; --__length)\n-\t  __result = (__result * 131) + *__first++;\n-\treturn __result;\n-      }\n-    };\n-\n-  template<>\n-    struct _Fnv_hash<4>\n-    {\n-      static std::size_t\n-      hash(const char* __first, std::size_t __length)\n-      {\n-\tstd::size_t __result = static_cast<std::size_t>(2166136261UL);\n-\tfor (; __length > 0; --__length)\n-\t  {\n-\t    __result ^= static_cast<std::size_t>(*__first++);\n-\t    __result *= static_cast<std::size_t>(16777619UL);\n-\t  }\n-\treturn __result;\n-      }\n-    };\n-  \n-  template<>\n-    struct _Fnv_hash<8>\n-    {\n-      static std::size_t\n-      hash(const char* __first, std::size_t __length)\n-      {\n-\tstd::size_t __result =\n-\t  static_cast<std::size_t>(14695981039346656037ULL);\n-\tfor (; __length > 0; --__length)\n-\t  {\n-\t    __result ^= static_cast<std::size_t>(*__first++);\n-\t    __result *= static_cast<std::size_t>(1099511628211ULL);\n-\t  }\n-\treturn __result;\n-      }\n-    };\n-\n-  // XXX String and floating point hashes probably shouldn't be inline\n-  // member functions, since are nontrivial.  Once we have the framework\n-  // for TR1 .cc files, these should go in one.\n-  template<>\n-    struct hash<std::string>\n-    : public std::unary_function<std::string, std::size_t>\n-    {      \n-      std::size_t\n-      operator()(const std::string& __s) const\n-      { return _Fnv_hash<>::hash(__s.data(), __s.length()); }\n-    };\n-\n-#ifdef _GLIBCXX_USE_WCHAR_T\n-  template<>\n-    struct hash<std::wstring>\n-    : public std::unary_function<std::wstring, std::size_t>\n-    {\n-      std::size_t\n-      operator()(const std::wstring& __s) const\n-      {\n-\treturn _Fnv_hash<>::hash(reinterpret_cast<const char*>(__s.data()),\n-\t\t\t\t __s.length() * sizeof(wchar_t));\n-      }\n-    };\n+#if defined(_GLIBCXX_INCLUDE_AS_CXX0X)\n+#  error TR1 header cannot be included from C++0x header\n #endif\n \n-  template<>\n-    struct hash<float>\n-    : public std::unary_function<float, std::size_t>\n-    {\n-      std::size_t\n-      operator()(float __fval) const\n-      {\n-\tstd::size_t __result = 0;\n-\n-\t// 0 and -0 both hash to zero.\n-\tif (__fval != 0.0f)\n-\t  __result = _Fnv_hash<>::hash(reinterpret_cast<const char*>(&__fval),\n-\t\t\t\t       sizeof(__fval));\n-\treturn __result;\n-      }\n-    };\n-\n-  template<>\n-    struct hash<double>\n-    : public std::unary_function<double, std::size_t>\n-    {\n-      std::size_t\n-      operator()(double __dval) const\n-      {\n-\tstd::size_t __result = 0;\n-\n-\t// 0 and -0 both hash to zero.\n-\tif (__dval != 0.0)\n-\t  __result = _Fnv_hash<>::hash(reinterpret_cast<const char*>(&__dval),\n-\t\t\t\t       sizeof(__dval));\n-\treturn __result;\n-      }\n-    };\n-\n-  // For long double, careful with random padding bits (e.g., on x86,\n-  // 10 bytes -> 12 bytes) and resort to frexp.\n-  template<>\n-    struct hash<long double>\n-    : public std::unary_function<long double, std::size_t>\n-    {\n-      std::size_t\n-      operator()(long double __ldval) const\n-      {\n-\tstd::size_t __result = 0;\n-\n-\tint __exponent;\n-\t__ldval = std::frexp(__ldval, &__exponent);\n-\t__ldval = __ldval < 0.0l ? -(__ldval + 0.5l) : __ldval;\n-\n-\tconst long double __mult =\n-\t  __gnu_cxx::__numeric_traits<std::size_t>::__max + 1.0l;\n-\t__ldval *= __mult;\n-\n-\t// Try to use all the bits of the mantissa (really necessary only\n-\t// on 32-bit targets, at least for 80-bit floating point formats).\n-\tconst std::size_t __hibits = (std::size_t)__ldval;\n-\t__ldval = (__ldval - (long double)__hibits) * __mult;\n-\n-\tconst std::size_t __coeff =\n-\t  __gnu_cxx::__numeric_traits<std::size_t>::__max / __LDBL_MAX_EXP__;\n-\n-\t__result = __hibits + (std::size_t)__ldval + __coeff * __exponent;\n-\n-\treturn __result;\n-      }\n-    };\n-\n-_GLIBCXX_END_NAMESPACE\n-}\n-\n+#if defined(_GLIBCXX_INCLUDE_AS_TR1)\n+#  include <tr1_impl/functional_hash.h>\n+#else\n+#  define _GLIBCXX_INCLUDE_AS_TR1\n+#  define _GLIBCXX_BEGIN_NAMESPACE_TR1 namespace tr1 {\n+#  define _GLIBCXX_END_NAMESPACE_TR1 }\n+#  define _GLIBCXX_TR1 tr1::\n+#  include <tr1_impl/functional_hash.h>\n+#  undef _GLIBCXX_TR1\n+#  undef _GLIBCXX_END_NAMESPACE_TR1\n+#  undef _GLIBCXX_BEGIN_NAMESPACE_TR1\n+#  undef _GLIBCXX_INCLUDE_AS_TR1\n #endif\n+\n+#endif // _GLIBCXX_TR1_FUNCTIONAL_HASH_H"}, {"sha": "06702e3cbce18dc573147e85e22d2106fe8b8062", "filename": "libstdc++-v3/include/tr1/gamma.tcc", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e133ace8d907bf42754c86106fc3f04a9d9fe70f/libstdc%2B%2B-v3%2Finclude%2Ftr1%2Fgamma.tcc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e133ace8d907bf42754c86106fc3f04a9d9fe70f/libstdc%2B%2B-v3%2Finclude%2Ftr1%2Fgamma.tcc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Ftr1%2Fgamma.tcc?ref=e133ace8d907bf42754c86106fc3f04a9d9fe70f", "patch": "@@ -56,7 +56,8 @@\n \n namespace std\n {\n-_GLIBCXX_BEGIN_NAMESPACE(_GLIBCXX_TR1)\n+namespace tr1\n+{\n \n   /**\n    * @ingroup tr1_math_spec_func\n@@ -295,9 +296,9 @@ _GLIBCXX_BEGIN_NAMESPACE(_GLIBCXX_TR1)\n                       = std::numeric_limits<_Tp>::max_exponent10\n                       * std::log(_Tp(10)) - _Tp(1);\n #if _GLIBCXX_USE_C99_MATH_TR1\n-      _Tp __coeff =  std::_GLIBCXX_TR1::lgamma(_Tp(1 + __n))\n-                  - std::_GLIBCXX_TR1::lgamma(_Tp(1 + __k))\n-                  - std::_GLIBCXX_TR1::lgamma(_Tp(1 + __n - __k));\n+      _Tp __coeff =  std::tr1::lgamma(_Tp(1 + __n))\n+                  - std::tr1::lgamma(_Tp(1 + __k))\n+                  - std::tr1::lgamma(_Tp(1 + __n - __k));\n #else\n       _Tp __coeff =  __log_gamma(_Tp(1 + __n))\n                   - __log_gamma(_Tp(1 + __k))\n@@ -464,7 +465,7 @@ _GLIBCXX_BEGIN_NAMESPACE(_GLIBCXX_TR1)\n         {\n           const _Tp __hzeta = __hurwitz_zeta(_Tp(__n + 1), __x);\n #if _GLIBCXX_USE_C99_MATH_TR1\n-          const _Tp __ln_nfact = std::_GLIBCXX_TR1::lgamma(_Tp(__n + 1));\n+          const _Tp __ln_nfact = std::tr1::lgamma(_Tp(__n + 1));\n #else\n           const _Tp __ln_nfact = __log_gamma(_Tp(__n + 1));\n #endif\n@@ -479,7 +480,7 @@ _GLIBCXX_BEGIN_NAMESPACE(_GLIBCXX_TR1)\n \n   /* @} */ // group tr1_math_spec_func\n \n-_GLIBCXX_END_NAMESPACE\n+}\n }\n \n #endif // _TR1_GAMMA_TCC"}, {"sha": "b7cf83ed7e967d22229c4b00d4a0e9942f135810", "filename": "libstdc++-v3/include/tr1/hashtable.h", "status": "added", "additions": 58, "deletions": 0, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e133ace8d907bf42754c86106fc3f04a9d9fe70f/libstdc%2B%2B-v3%2Finclude%2Ftr1%2Fhashtable.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e133ace8d907bf42754c86106fc3f04a9d9fe70f/libstdc%2B%2B-v3%2Finclude%2Ftr1%2Fhashtable.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Ftr1%2Fhashtable.h?ref=e133ace8d907bf42754c86106fc3f04a9d9fe70f", "patch": "@@ -0,0 +1,58 @@\n+// TR1 hashtable.h header -*- C++ -*-\n+\n+// Copyright (C) 2007 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301,\n+// USA.\n+\n+// As a special exception, you may use this file as part of a free software\n+// library without restriction.  Specifically, if other files instantiate\n+// templates or use macros or inline functions from this file, or you compile\n+// this file and link it with other files to produce an executable, this\n+// file does not by itself cause the resulting executable to be covered by\n+// the GNU General Public License.  This exception does not however\n+// invalidate any other reasons why the executable file might be covered by\n+// the GNU General Public License.\n+\n+/** @file tr1/hashtable.h\n+ *  This is an internal header file, included by other library headers.\n+ *  You should not attempt to use it directly.\n+ */\n+\n+#ifndef _GLIBCXX_TR1_HASHTABLE_H\n+#define _GLIBCXX_TR1_HASHTABLE_H 1\n+\n+#pragma GCC system_header\n+\n+#if defined(_GLIBCXX_INCLUDE_AS_CXX0X)\n+#  error TR1 header cannot be included from C++0x header\n+#endif\n+\n+#if defined(_GLIBCXX_INCLUDE_AS_TR1)\n+#  include <tr1_impl/hashtable>\n+#else\n+#  define _GLIBCXX_INCLUDE_AS_TR1\n+#  define _GLIBCXX_BEGIN_NAMESPACE_TR1 namespace tr1 {\n+#  define _GLIBCXX_END_NAMESPACE_TR1 }\n+#  define _GLIBCXX_TR1 tr1::\n+#  include <tr1_impl/hashtable>\n+#  undef _GLIBCXX_TR1\n+#  undef _GLIBCXX_END_NAMESPACE_TR1\n+#  undef _GLIBCXX_BEGIN_NAMESPACE_TR1\n+#  undef _GLIBCXX_INCLUDE_AS_TR1\n+#endif\n+\n+#endif // _GLIBCXX_TR1_HASHTABLE_H"}, {"sha": "17fa959ba9b7161f906696029670f9fffecee6f6", "filename": "libstdc++-v3/include/tr1/hypergeometric.tcc", "status": "modified", "additions": 10, "deletions": 9, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e133ace8d907bf42754c86106fc3f04a9d9fe70f/libstdc%2B%2B-v3%2Finclude%2Ftr1%2Fhypergeometric.tcc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e133ace8d907bf42754c86106fc3f04a9d9fe70f/libstdc%2B%2B-v3%2Finclude%2Ftr1%2Fhypergeometric.tcc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Ftr1%2Fhypergeometric.tcc?ref=e133ace8d907bf42754c86106fc3f04a9d9fe70f", "patch": "@@ -44,12 +44,13 @@\n //       Section 6, pp. 555-566\n //   (2) The Gnu Scientific Library, http://www.gnu.org/software/gsl\n \n-#ifndef _TR1_HYPERGEOMETRIC_TCC\n-#define _TR1_HYPERGEOMETRIC_TCC 1\n+#ifndef _GLIBCXX_TR1_HYPERGEOMETRIC_TCC\n+#define _GLIBCXX_TR1_HYPERGEOMETRIC_TCC 1\n \n namespace std\n {\n-_GLIBCXX_BEGIN_NAMESPACE(_GLIBCXX_TR1)\n+namespace tr1\n+{\n \n   // [5.2] Special functions\n \n@@ -233,7 +234,7 @@ _GLIBCXX_BEGIN_NAMESPACE(_GLIBCXX_TR1)\n     __conf_hyperg(const _Tp __a, const _Tp __c, const _Tp __x)\n     {\n #if _GLIBCXX_USE_C99_MATH_TR1\n-      const _Tp __c_nint = std::_GLIBCXX_TR1::nearbyint(__c);\n+      const _Tp __c_nint = std::tr1::nearbyint(__c);\n #else\n       const _Tp __c_nint = static_cast<int>(__c + _Tp(0.5L));\n #endif\n@@ -735,9 +736,9 @@ _GLIBCXX_BEGIN_NAMESPACE(_GLIBCXX_TR1)\n     __hyperg(const _Tp __a, const _Tp __b, const _Tp __c, const _Tp __x)\n     {\n #if _GLIBCXX_USE_C99_MATH_TR1\n-      const _Tp __a_nint = std::_GLIBCXX_TR1::nearbyint(__a);\n-      const _Tp __b_nint = std::_GLIBCXX_TR1::nearbyint(__b);\n-      const _Tp __c_nint = std::_GLIBCXX_TR1::nearbyint(__c);\n+      const _Tp __a_nint = std::tr1::nearbyint(__a);\n+      const _Tp __b_nint = std::tr1::nearbyint(__b);\n+      const _Tp __c_nint = std::tr1::nearbyint(__c);\n #else\n       const _Tp __a_nint = static_cast<int>(__a + _Tp(0.5L));\n       const _Tp __b_nint = static_cast<int>(__b + _Tp(0.5L));\n@@ -782,7 +783,7 @@ _GLIBCXX_BEGIN_NAMESPACE(_GLIBCXX_TR1)\n \n   /* @} */ // group tr1_math_spec_func\n \n-_GLIBCXX_END_NAMESPACE\n+}\n }\n \n-#endif // _TR1_HYPERGEOMETRIC_TCC\n+#endif // _GLIBCXX_TR1_HYPERGEOMETRIC_TCC"}, {"sha": "3253247baea4af9cc6895ac328e32a447f308227", "filename": "libstdc++-v3/include/tr1/inttypes.h", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e133ace8d907bf42754c86106fc3f04a9d9fe70f/libstdc%2B%2B-v3%2Finclude%2Ftr1%2Finttypes.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e133ace8d907bf42754c86106fc3f04a9d9fe70f/libstdc%2B%2B-v3%2Finclude%2Ftr1%2Finttypes.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Ftr1%2Finttypes.h?ref=e133ace8d907bf42754c86106fc3f04a9d9fe70f", "patch": "@@ -1,6 +1,6 @@\n // TR1 inttypes.h -*- C++ -*-\n \n-// Copyright (C) 2006 Free Software Foundation, Inc.\n+// Copyright (C) 2006, 2007 Free Software Foundation, Inc.\n //\n // This file is part of the GNU ISO C++ Library.  This library is free\n // software; you can redistribute it and/or modify it under the\n@@ -31,9 +31,9 @@\n  *  This is a TR1 C++ Library header. \n  */\n \n-#ifndef _TR1_INTTYPES_H\n-#define _TR1_INTTYPES_H 1\n+#ifndef _GLIBCXX_TR1_INTTYPES_H\n+#define _GLIBCXX_TR1_INTTYPES_H 1\n \n #include <tr1/cinttypes>\n \n-#endif\n+#endif // _GLIBCXX_TR1_INTTYPES_H"}, {"sha": "839459f49a0b7ebc64f89bf47f4e159f5b25426c", "filename": "libstdc++-v3/include/tr1/legendre_function.tcc", "status": "modified", "additions": 9, "deletions": 8, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e133ace8d907bf42754c86106fc3f04a9d9fe70f/libstdc%2B%2B-v3%2Finclude%2Ftr1%2Flegendre_function.tcc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e133ace8d907bf42754c86106fc3f04a9d9fe70f/libstdc%2B%2B-v3%2Finclude%2Ftr1%2Flegendre_function.tcc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Ftr1%2Flegendre_function.tcc?ref=e133ace8d907bf42754c86106fc3f04a9d9fe70f", "patch": "@@ -47,14 +47,15 @@\n //       W. T. Vetterling, B. P. Flannery, Cambridge University Press (1992),\n //       2nd ed, pp. 252-254\n \n-#ifndef _TR1_LEGENDRE_FUNCTION_TCC\n-#define _TR1_LEGENDRE_FUNCTION_TCC 1\n+#ifndef _GLIBCXX_TR1_LEGENDRE_FUNCTION_TCC\n+#define _GLIBCXX_TR1_LEGENDRE_FUNCTION_TCC 1\n \n #include \"special_function_util.h\"\n \n namespace std\n {\n-_GLIBCXX_BEGIN_NAMESPACE(_GLIBCXX_TR1)\n+namespace tr1\n+{\n \n   // [5.2] Special functions\n \n@@ -256,14 +257,14 @@ _GLIBCXX_BEGIN_NAMESPACE(_GLIBCXX_TR1)\n           const _Tp __sgn = ( __m % 2 == 1 ? -_Tp(1) : _Tp(1));\n           const _Tp __y_mp1m_factor = __x * std::sqrt(_Tp(2 * __m + 3));\n #if _GLIBCXX_USE_C99_MATH_TR1\n-          const _Tp __lncirc = std::_GLIBCXX_TR1::log1p(-__x * __x);\n+          const _Tp __lncirc = std::tr1::log1p(-__x * __x);\n #else\n           const _Tp __lncirc = std::log(_Tp(1) - __x * __x);\n #endif\n           //  Gamma(m+1/2) / Gamma(m)\n #if _GLIBCXX_USE_C99_MATH_TR1\n-          const _Tp __lnpoch = std::_GLIBCXX_TR1::lgamma(_Tp(__m + _Tp(0.5L)))\n-                             - std::_GLIBCXX_TR1::lgamma(_Tp(__m));\n+          const _Tp __lnpoch = std::tr1::lgamma(_Tp(__m + _Tp(0.5L)))\n+                             - std::tr1::lgamma(_Tp(__m));\n #else\n           const _Tp __lnpoch = __log_gamma(_Tp(__m + _Tp(0.5L)))\n                              - __log_gamma(_Tp(__m));\n@@ -312,7 +313,7 @@ _GLIBCXX_BEGIN_NAMESPACE(_GLIBCXX_TR1)\n \n   /* @} */ // group tr1_math_spec_func\n \n-_GLIBCXX_END_NAMESPACE\n+}\n }\n \n-#endif // _TR1_LEGENDRE_FUNCTION_TCC\n+#endif // _GLIBCXX_TR1_LEGENDRE_FUNCTION_TCC"}, {"sha": "4e95b9b3c2dd275bd08cceaa2f65a7f741f07b68", "filename": "libstdc++-v3/include/tr1/math.h", "status": "modified", "additions": 127, "deletions": 127, "changes": 254, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e133ace8d907bf42754c86106fc3f04a9d9fe70f/libstdc%2B%2B-v3%2Finclude%2Ftr1%2Fmath.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e133ace8d907bf42754c86106fc3f04a9d9fe70f/libstdc%2B%2B-v3%2Finclude%2Ftr1%2Fmath.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Ftr1%2Fmath.h?ref=e133ace8d907bf42754c86106fc3f04a9d9fe70f", "patch": "@@ -31,161 +31,161 @@\n  *  This is a TR1 C++ Library header. \n  */\n \n-#ifndef _TR1_MATH_H\n-#define _TR1_MATH_H 1\n+#ifndef _GLIBCXX_TR1_MATH_H\n+#define _GLIBCXX_TR1_MATH_H 1\n \n #include <tr1/cmath>\n \n #if _GLIBCXX_USE_C99_MATH_TR1\n \n-using std::_GLIBCXX_TR1::acos;\n-using std::_GLIBCXX_TR1::acosh;\n-using std::_GLIBCXX_TR1::asin;\n-using std::_GLIBCXX_TR1::asinh;\n-using std::_GLIBCXX_TR1::atan;\n-using std::_GLIBCXX_TR1::atan2;\n-using std::_GLIBCXX_TR1::atanh;\n-using std::_GLIBCXX_TR1::cbrt;\n-using std::_GLIBCXX_TR1::ceil;\n-using std::_GLIBCXX_TR1::copysign;\n-using std::_GLIBCXX_TR1::cos;\n-using std::_GLIBCXX_TR1::cosh;\n-using std::_GLIBCXX_TR1::erf;\n-using std::_GLIBCXX_TR1::erfc;\n-using std::_GLIBCXX_TR1::exp;\n-using std::_GLIBCXX_TR1::exp2;\n-using std::_GLIBCXX_TR1::expm1;\n-using std::_GLIBCXX_TR1::fabs;\n-using std::_GLIBCXX_TR1::fdim;\n-using std::_GLIBCXX_TR1::floor;\n-using std::_GLIBCXX_TR1::fma;\n-using std::_GLIBCXX_TR1::fmax;\n-using std::_GLIBCXX_TR1::fmin;\n-using std::_GLIBCXX_TR1::fmod;\n-using std::_GLIBCXX_TR1::frexp;\n-using std::_GLIBCXX_TR1::hypot;\n-using std::_GLIBCXX_TR1::ilogb;\n-using std::_GLIBCXX_TR1::ldexp;\n-using std::_GLIBCXX_TR1::lgamma;\n-using std::_GLIBCXX_TR1::llrint;\n-using std::_GLIBCXX_TR1::llround;\n-using std::_GLIBCXX_TR1::log;\n-using std::_GLIBCXX_TR1::log10;\n-using std::_GLIBCXX_TR1::log1p;\n-using std::_GLIBCXX_TR1::log2;\n-using std::_GLIBCXX_TR1::logb;\n-using std::_GLIBCXX_TR1::lrint;\n-using std::_GLIBCXX_TR1::lround;\n-using std::_GLIBCXX_TR1::nearbyint;\n-using std::_GLIBCXX_TR1::nextafter;\n-using std::_GLIBCXX_TR1::nexttoward;\n-using std::_GLIBCXX_TR1::pow;\n-using std::_GLIBCXX_TR1::remainder;\n-using std::_GLIBCXX_TR1::remquo;\n-using std::_GLIBCXX_TR1::rint;\n-using std::_GLIBCXX_TR1::round;\n-using std::_GLIBCXX_TR1::scalbln;\n-using std::_GLIBCXX_TR1::scalbn;\n-using std::_GLIBCXX_TR1::sin;\n-using std::_GLIBCXX_TR1::sinh;\n-using std::_GLIBCXX_TR1::sqrt;\n-using std::_GLIBCXX_TR1::tan;\n-using std::_GLIBCXX_TR1::tanh;\n-using std::_GLIBCXX_TR1::tgamma;\n-using std::_GLIBCXX_TR1::trunc;\n+using std::tr1::acos;\n+using std::tr1::acosh;\n+using std::tr1::asin;\n+using std::tr1::asinh;\n+using std::tr1::atan;\n+using std::tr1::atan2;\n+using std::tr1::atanh;\n+using std::tr1::cbrt;\n+using std::tr1::ceil;\n+using std::tr1::copysign;\n+using std::tr1::cos;\n+using std::tr1::cosh;\n+using std::tr1::erf;\n+using std::tr1::erfc;\n+using std::tr1::exp;\n+using std::tr1::exp2;\n+using std::tr1::expm1;\n+using std::tr1::fabs;\n+using std::tr1::fdim;\n+using std::tr1::floor;\n+using std::tr1::fma;\n+using std::tr1::fmax;\n+using std::tr1::fmin;\n+using std::tr1::fmod;\n+using std::tr1::frexp;\n+using std::tr1::hypot;\n+using std::tr1::ilogb;\n+using std::tr1::ldexp;\n+using std::tr1::lgamma;\n+using std::tr1::llrint;\n+using std::tr1::llround;\n+using std::tr1::log;\n+using std::tr1::log10;\n+using std::tr1::log1p;\n+using std::tr1::log2;\n+using std::tr1::logb;\n+using std::tr1::lrint;\n+using std::tr1::lround;\n+using std::tr1::nearbyint;\n+using std::tr1::nextafter;\n+using std::tr1::nexttoward;\n+using std::tr1::pow;\n+using std::tr1::remainder;\n+using std::tr1::remquo;\n+using std::tr1::rint;\n+using std::tr1::round;\n+using std::tr1::scalbln;\n+using std::tr1::scalbn;\n+using std::tr1::sin;\n+using std::tr1::sinh;\n+using std::tr1::sqrt;\n+using std::tr1::tan;\n+using std::tr1::tanh;\n+using std::tr1::tgamma;\n+using std::tr1::trunc;\n \n #endif\n \n-using std::_GLIBCXX_TR1::assoc_laguerref;\n-using std::_GLIBCXX_TR1::assoc_laguerre;\n-using std::_GLIBCXX_TR1::assoc_laguerrel;\n+using std::tr1::assoc_laguerref;\n+using std::tr1::assoc_laguerre;\n+using std::tr1::assoc_laguerrel;\n \n-using std::_GLIBCXX_TR1::assoc_legendref;\n-using std::_GLIBCXX_TR1::assoc_legendre;\n-using std::_GLIBCXX_TR1::assoc_legendrel;\n+using std::tr1::assoc_legendref;\n+using std::tr1::assoc_legendre;\n+using std::tr1::assoc_legendrel;\n \n-using std::_GLIBCXX_TR1::betaf;\n-using std::_GLIBCXX_TR1::beta;\n-using std::_GLIBCXX_TR1::betal;\n+using std::tr1::betaf;\n+using std::tr1::beta;\n+using std::tr1::betal;\n \n-using std::_GLIBCXX_TR1::comp_ellint_1f;\n-using std::_GLIBCXX_TR1::comp_ellint_1;\n-using std::_GLIBCXX_TR1::comp_ellint_1l;\n+using std::tr1::comp_ellint_1f;\n+using std::tr1::comp_ellint_1;\n+using std::tr1::comp_ellint_1l;\n \n-using std::_GLIBCXX_TR1::comp_ellint_2f;\n-using std::_GLIBCXX_TR1::comp_ellint_2;\n-using std::_GLIBCXX_TR1::comp_ellint_2l;\n+using std::tr1::comp_ellint_2f;\n+using std::tr1::comp_ellint_2;\n+using std::tr1::comp_ellint_2l;\n \n-using std::_GLIBCXX_TR1::comp_ellint_3f;\n-using std::_GLIBCXX_TR1::comp_ellint_3;\n-using std::_GLIBCXX_TR1::comp_ellint_3l;\n+using std::tr1::comp_ellint_3f;\n+using std::tr1::comp_ellint_3;\n+using std::tr1::comp_ellint_3l;\n \n-using std::_GLIBCXX_TR1::conf_hypergf;\n-using std::_GLIBCXX_TR1::conf_hyperg;\n-using std::_GLIBCXX_TR1::conf_hypergl;\n+using std::tr1::conf_hypergf;\n+using std::tr1::conf_hyperg;\n+using std::tr1::conf_hypergl;\n \n-using std::_GLIBCXX_TR1::cyl_bessel_if;\n-using std::_GLIBCXX_TR1::cyl_bessel_i;\n-using std::_GLIBCXX_TR1::cyl_bessel_il;\n+using std::tr1::cyl_bessel_if;\n+using std::tr1::cyl_bessel_i;\n+using std::tr1::cyl_bessel_il;\n \n-using std::_GLIBCXX_TR1::cyl_bessel_jf;\n-using std::_GLIBCXX_TR1::cyl_bessel_j;\n-using std::_GLIBCXX_TR1::cyl_bessel_jl;\n+using std::tr1::cyl_bessel_jf;\n+using std::tr1::cyl_bessel_j;\n+using std::tr1::cyl_bessel_jl;\n \n-using std::_GLIBCXX_TR1::cyl_bessel_kf;\n-using std::_GLIBCXX_TR1::cyl_bessel_k;\n-using std::_GLIBCXX_TR1::cyl_bessel_kl;\n+using std::tr1::cyl_bessel_kf;\n+using std::tr1::cyl_bessel_k;\n+using std::tr1::cyl_bessel_kl;\n \n-using std::_GLIBCXX_TR1::cyl_neumannf;\n-using std::_GLIBCXX_TR1::cyl_neumann;\n-using std::_GLIBCXX_TR1::cyl_neumannl;\n+using std::tr1::cyl_neumannf;\n+using std::tr1::cyl_neumann;\n+using std::tr1::cyl_neumannl;\n \n-using std::_GLIBCXX_TR1::ellint_1f;\n-using std::_GLIBCXX_TR1::ellint_1;\n-using std::_GLIBCXX_TR1::ellint_1l;\n+using std::tr1::ellint_1f;\n+using std::tr1::ellint_1;\n+using std::tr1::ellint_1l;\n \n-using std::_GLIBCXX_TR1::ellint_2f;\n-using std::_GLIBCXX_TR1::ellint_2;\n-using std::_GLIBCXX_TR1::ellint_2l;\n+using std::tr1::ellint_2f;\n+using std::tr1::ellint_2;\n+using std::tr1::ellint_2l;\n \n-using std::_GLIBCXX_TR1::ellint_3f;\n-using std::_GLIBCXX_TR1::ellint_3;\n-using std::_GLIBCXX_TR1::ellint_3l;\n+using std::tr1::ellint_3f;\n+using std::tr1::ellint_3;\n+using std::tr1::ellint_3l;\n \n-using std::_GLIBCXX_TR1::expintf;\n-using std::_GLIBCXX_TR1::expint;\n-using std::_GLIBCXX_TR1::expintl;\n+using std::tr1::expintf;\n+using std::tr1::expint;\n+using std::tr1::expintl;\n \n-using std::_GLIBCXX_TR1::hermitef;\n-using std::_GLIBCXX_TR1::hermite;\n-using std::_GLIBCXX_TR1::hermitel;\n+using std::tr1::hermitef;\n+using std::tr1::hermite;\n+using std::tr1::hermitel;\n \n-using std::_GLIBCXX_TR1::hypergf;\n-using std::_GLIBCXX_TR1::hyperg;\n-using std::_GLIBCXX_TR1::hypergl;\n+using std::tr1::hypergf;\n+using std::tr1::hyperg;\n+using std::tr1::hypergl;\n \n-using std::_GLIBCXX_TR1::laguerref;\n-using std::_GLIBCXX_TR1::laguerre;\n-using std::_GLIBCXX_TR1::laguerrel;\n+using std::tr1::laguerref;\n+using std::tr1::laguerre;\n+using std::tr1::laguerrel;\n \n-using std::_GLIBCXX_TR1::legendref;\n-using std::_GLIBCXX_TR1::legendre;\n-using std::_GLIBCXX_TR1::legendrel;\n+using std::tr1::legendref;\n+using std::tr1::legendre;\n+using std::tr1::legendrel;\n \n-using std::_GLIBCXX_TR1::riemann_zetaf;\n-using std::_GLIBCXX_TR1::riemann_zeta;\n-using std::_GLIBCXX_TR1::riemann_zetal;\n+using std::tr1::riemann_zetaf;\n+using std::tr1::riemann_zeta;\n+using std::tr1::riemann_zetal;\n \n-using std::_GLIBCXX_TR1::sph_besself;\n-using std::_GLIBCXX_TR1::sph_bessel;\n-using std::_GLIBCXX_TR1::sph_bessell;\n+using std::tr1::sph_besself;\n+using std::tr1::sph_bessel;\n+using std::tr1::sph_bessell;\n \n-using std::_GLIBCXX_TR1::sph_legendref;\n-using std::_GLIBCXX_TR1::sph_legendre;\n-using std::_GLIBCXX_TR1::sph_legendrel;\n+using std::tr1::sph_legendref;\n+using std::tr1::sph_legendre;\n+using std::tr1::sph_legendrel;\n \n-using std::_GLIBCXX_TR1::sph_neumannf;\n-using std::_GLIBCXX_TR1::sph_neumann;\n-using std::_GLIBCXX_TR1::sph_neumannl;\n+using std::tr1::sph_neumannf;\n+using std::tr1::sph_neumann;\n+using std::tr1::sph_neumannl;\n \n-#endif\n+#endif // _GLIBCXX_TR1_MATH_H"}, {"sha": "69f2f57b65a31d7499a2d222dd41fcc8bc6984a0", "filename": "libstdc++-v3/include/tr1/memory", "status": "modified", "additions": 24, "deletions": 8, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e133ace8d907bf42754c86106fc3f04a9d9fe70f/libstdc%2B%2B-v3%2Finclude%2Ftr1%2Fmemory", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e133ace8d907bf42754c86106fc3f04a9d9fe70f/libstdc%2B%2B-v3%2Finclude%2Ftr1%2Fmemory", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Ftr1%2Fmemory?ref=e133ace8d907bf42754c86106fc3f04a9d9fe70f", "patch": "@@ -32,24 +32,40 @@\n  * This is a TR1 C++ Library header. \n  */\n \n-#ifndef _TR1_MEMORY\n-#define _TR1_MEMORY 1\n+#ifndef _GLIBCXX_TR1_MEMORY\n+#define _GLIBCXX_TR1_MEMORY 1\n \n-#include <cstddef>          \t// std::size_t\n+#pragma GCC system_header\n+\n+#if defined(_GLIBCXX_INCLUDE_AS_CXX0X)\n+#  error TR1 header cannot be included from C++0x header\n+#endif\n+\n+#include <memory>\n #include <exception>        \t// std::exception\n #include <new>              \t// std::bad_alloc\n #include <typeinfo>         \t// std::type_info in get_deleter\n #include <bits/stl_algobase.h>  // std::swap\n #include <iosfwd>           \t// std::basic_ostream\n-#include <memory>\n-\n #include <ext/atomicity.h>\n #include <ext/concurrence.h>\n #include <bits/functexcept.h>\n #include <bits/stl_function.h> \t// std::less\n #include <debug/debug.h>\n+#include <tr1/type_traits>\n \n-#include <tr1/type_traits>  \t// tr1::add_reference\n-#include <tr1/boost_shared_ptr.h>\n-\n+#if defined(_GLIBCXX_INCLUDE_AS_TR1)\n+#  include <tr1_impl/boost_shared_ptr.h>\n+#else\n+#  define _GLIBCXX_INCLUDE_AS_TR1\n+#  define _GLIBCXX_BEGIN_NAMESPACE_TR1 namespace tr1 {\n+#  define _GLIBCXX_END_NAMESPACE_TR1 }\n+#  define _GLIBCXX_TR1 tr1::\n+#  include <tr1_impl/boost_shared_ptr.h>\n+#  undef _GLIBCXX_TR1\n+#  undef _GLIBCXX_END_NAMESPACE_TR1\n+#  undef _GLIBCXX_BEGIN_NAMESPACE_TR1\n+#  undef _GLIBCXX_INCLUDE_AS_TR1\n #endif\n+\n+#endif // _GLIBCXX_TR1_MEMORY"}, {"sha": "912f99faea4a4d88a11e535a851a5a0d25a368f8", "filename": "libstdc++-v3/include/tr1/modified_bessel_func.tcc", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e133ace8d907bf42754c86106fc3f04a9d9fe70f/libstdc%2B%2B-v3%2Finclude%2Ftr1%2Fmodified_bessel_func.tcc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e133ace8d907bf42754c86106fc3f04a9d9fe70f/libstdc%2B%2B-v3%2Finclude%2Ftr1%2Fmodified_bessel_func.tcc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Ftr1%2Fmodified_bessel_func.tcc?ref=e133ace8d907bf42754c86106fc3f04a9d9fe70f", "patch": "@@ -49,14 +49,15 @@\n //       W. T. Vetterling, B. P. Flannery, Cambridge University Press (1992),\n //       2nd ed, pp. 246-249.\n \n-#ifndef _TR1_MODIFIED_BESSEL_FUNC_TCC\n-#define _TR1_MODIFIED_BESSEL_FUNC_TCC 1\n+#ifndef _GLIBCXX_TR1_MODIFIED_BESSEL_FUNC_TCC\n+#define _GLIBCXX_TR1_MODIFIED_BESSEL_FUNC_TCC 1\n \n #include \"special_function_util.h\"\n \n namespace std\n {\n-_GLIBCXX_BEGIN_NAMESPACE(_GLIBCXX_TR1)\n+namespace tr1\n+{\n \n   // [5.2] Special functions\n \n@@ -444,7 +445,7 @@ _GLIBCXX_BEGIN_NAMESPACE(_GLIBCXX_TR1)\n \n   /* @} */ // group tr1_math_spec_func\n \n-_GLIBCXX_END_NAMESPACE\n+}\n }\n \n-#endif // _TR1_MODIFIED_BESSEL_FUNC_TCC\n+#endif // _GLIBCXX_TR1_MODIFIED_BESSEL_FUNC_TCC"}, {"sha": "2d8ccfea8d596e7a9ef88d5c636a72a2dae4f5b1", "filename": "libstdc++-v3/include/tr1/poly_hermite.tcc", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e133ace8d907bf42754c86106fc3f04a9d9fe70f/libstdc%2B%2B-v3%2Finclude%2Ftr1%2Fpoly_hermite.tcc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e133ace8d907bf42754c86106fc3f04a9d9fe70f/libstdc%2B%2B-v3%2Finclude%2Ftr1%2Fpoly_hermite.tcc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Ftr1%2Fpoly_hermite.tcc?ref=e133ace8d907bf42754c86106fc3f04a9d9fe70f", "patch": "@@ -42,12 +42,13 @@\n //       Ed. Milton Abramowitz and Irene A. Stegun,\n //       Dover Publications, Section 22 pp. 773-802\n \n-#ifndef _TR1_POLY_HERMITE_TCC\n-#define _TR1_POLY_HERMITE_TCC 1\n+#ifndef _GLIBCXX_TR1_POLY_HERMITE_TCC\n+#define _GLIBCXX_TR1_POLY_HERMITE_TCC 1\n \n namespace std\n {\n-_GLIBCXX_BEGIN_NAMESPACE(_GLIBCXX_TR1)\n+namespace tr1\n+{\n \n   // [5.2] Special functions\n \n@@ -132,7 +133,7 @@ _GLIBCXX_BEGIN_NAMESPACE(_GLIBCXX_TR1)\n \n   /* @} */ // group tr1_math_spec_func\n \n-_GLIBCXX_END_NAMESPACE\n+}\n }\n \n-#endif // _TR1_POLY_HERMITE_TCC\n+#endif // _GLIBCXX_TR1_POLY_HERMITE_TCC"}, {"sha": "46c51a5741104a3423728e2b9fc2d592fa69327e", "filename": "libstdc++-v3/include/tr1/poly_laguerre.tcc", "status": "modified", "additions": 8, "deletions": 7, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e133ace8d907bf42754c86106fc3f04a9d9fe70f/libstdc%2B%2B-v3%2Finclude%2Ftr1%2Fpoly_laguerre.tcc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e133ace8d907bf42754c86106fc3f04a9d9fe70f/libstdc%2B%2B-v3%2Finclude%2Ftr1%2Fpoly_laguerre.tcc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Ftr1%2Fpoly_laguerre.tcc?ref=e133ace8d907bf42754c86106fc3f04a9d9fe70f", "patch": "@@ -44,12 +44,13 @@\n //       Section 13, pp. 509-510, Section 22 pp. 773-802\n //   (2) The Gnu Scientific Library, http://www.gnu.org/software/gsl\n \n-#ifndef _TR1_POLY_LAGUERRE_TCC\n-#define _TR1_POLY_LAGUERRE_TCC 1\n+#ifndef _GLIBCXX_TR1_POLY_LAGUERRE_TCC\n+#define _GLIBCXX_TR1_POLY_LAGUERRE_TCC 1\n \n namespace std\n {\n-_GLIBCXX_BEGIN_NAMESPACE(_GLIBCXX_TR1)\n+namespace tr1\n+{\n \n   // [5.2] Special functions\n \n@@ -94,8 +95,8 @@ _GLIBCXX_BEGIN_NAMESPACE(_GLIBCXX_TR1)\n                         * __eta * __eta * __cos2th * __sin2th;\n \n #if _GLIBCXX_USE_C99_MATH_TR1\n-      const _Tp __lg_b = std::_GLIBCXX_TR1::lgamma(_Tp(__n) + __b);\n-      const _Tp __lnfact = std::_GLIBCXX_TR1::lgamma(_Tp(__n + 1));\n+      const _Tp __lg_b = std::tr1::lgamma(_Tp(__n) + __b);\n+      const _Tp __lnfact = std::tr1::lgamma(_Tp(__n + 1));\n #else\n       const _Tp __lg_b = __log_gamma(_Tp(__n) + __b);\n       const _Tp __lnfact = __log_gamma(_Tp(__n + 1));\n@@ -337,7 +338,7 @@ _GLIBCXX_BEGIN_NAMESPACE(_GLIBCXX_TR1)\n \n   /* @} */ // group tr1_math_spec_func\n \n-_GLIBCXX_END_NAMESPACE\n+}\n }\n \n-#endif // _TR1_POLY_LAGUERRE_TCC\n+#endif // _GLIBCXX_TR1_POLY_LAGUERRE_TCC"}, {"sha": "49a3b21cd818b9d9a97e6a58551665fe87f7a588", "filename": "libstdc++-v3/include/tr1/random", "status": "modified", "additions": 22, "deletions": 2317, "changes": 2339, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e133ace8d907bf42754c86106fc3f04a9d9fe70f/libstdc%2B%2B-v3%2Finclude%2Ftr1%2Frandom", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e133ace8d907bf42754c86106fc3f04a9d9fe70f/libstdc%2B%2B-v3%2Finclude%2Ftr1%2Frandom", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Ftr1%2Frandom?ref=e133ace8d907bf42754c86106fc3f04a9d9fe70f", "patch": "@@ -32,2335 +32,40 @@\n  * This is a TR1 C++ Library header. \n  */\n \n-#ifndef _TR1_RANDOM\n-#define _TR1_RANDOM 1\n+#ifndef _GLIBCXX_TR1_RANDOM\n+#define _GLIBCXX_TR1_RANDOM 1\n+\n+#pragma GCC system_header\n+\n+#if defined(_GLIBCXX_INCLUDE_AS_CXX0X)\n+#  error TR1 header cannot be included from C++0x header\n+#endif\n \n #include <cmath>\n #include <cstdio>\n #include <cstdlib>\n #include <string>\n #include <iosfwd>\n #include <limits>\n-#include <tr1/type_traits>\n-#include <tr1/cmath>\n #include <ext/type_traits.h>\n #include <ext/numeric_traits.h>\n #include <bits/concept_check.h>\n #include <debug/debug.h>\n+#include <tr1/type_traits>\n+#include <tr1/cmath>\n \n-namespace std\n-{\n-_GLIBCXX_BEGIN_NAMESPACE(_GLIBCXX_TR1)\n-\n-  // [5.1] Random number generation\n-\n-  /**\n-   * @addtogroup tr1_random Random Number Generation\n-   * A facility for generating random numbers on selected distributions.\n-   * @{\n-   */\n-\n-  /*\n-   * Implementation-space details.\n-   */\n-  namespace __detail\n-  {\n-    template<typename _UIntType, int __w, \n-\t     bool = __w < std::numeric_limits<_UIntType>::digits>\n-      struct _Shift\n-      { static const _UIntType __value = 0; };\n-\n-    template<typename _UIntType, int __w>\n-      struct _Shift<_UIntType, __w, true>\n-      { static const _UIntType __value = _UIntType(1) << __w; };\n-\n-    template<typename _Tp, _Tp __a, _Tp __c, _Tp __m, bool>\n-      struct _Mod;\n-\n-    // Dispatch based on modulus value to prevent divide-by-zero compile-time\n-    // errors when m == 0.\n-    template<typename _Tp, _Tp __a, _Tp __c, _Tp __m>\n-      inline _Tp\n-      __mod(_Tp __x)\n-      { return _Mod<_Tp, __a, __c, __m, __m == 0>::__calc(__x); }\n-\n-    typedef __gnu_cxx::__conditional_type<(sizeof(unsigned) == 4),\n-\t\t    unsigned, unsigned long>::__type _UInt32Type;\n-\n-    /*\n-     * An adaptor class for converting the output of any Generator into\n-     * the input for a specific Distribution.\n-     */\n-    template<typename _Engine, typename _Distribution>\n-      struct _Adaptor\n-      { \n-\ttypedef typename _Engine::result_type        _Engine_result_type;\n-\ttypedef typename _Distribution::input_type   result_type;\n-\n-      public:\n-\t_Adaptor(const _Engine& __g)\n-\t: _M_g(__g) { }\n-\n-\tresult_type\n-\tmin() const\n-\t{\n-\t  result_type __return_value = 0;\n-\t  if (is_integral<_Engine_result_type>::value\n-\t      && is_integral<result_type>::value)\n-\t    __return_value = _M_g.min();\n-\t  else if (!is_integral<result_type>::value)\n-\t    __return_value = result_type(0);\n-\t  return __return_value;\n-\t}\n-\n-\tresult_type\n-\tmax() const\n-\t{\n-\t  result_type __return_value = 0;\n-\t  if (is_integral<_Engine_result_type>::value\n-\t      && is_integral<result_type>::value)\n-\t    __return_value = _M_g.max();\n-\t  else if (!is_integral<result_type>::value)\n-\t    __return_value = result_type(1);\n-\t  return __return_value;\n-\t}\n-\n-\tresult_type\n-\toperator()();\n-\n-      private:\n-\t_Engine _M_g;\n-      };\n-\n-    /*\n-     * Converts a value generated by the adapted random number generator into a\n-     * value in the input domain for the dependent random number distribution.\n-     *\n-     * Because the type traits are compile time constants only the appropriate\n-     * clause of the if statements will actually be emitted by the compiler.\n-     */\n-    template<typename _Engine, typename _Distribution>\n-      typename _Adaptor<_Engine, _Distribution>::result_type\n-      _Adaptor<_Engine, _Distribution>::\n-      operator()()\n-      {\n-\tresult_type __return_value = 0;\n-\tif (is_integral<_Engine_result_type>::value\n-\t    && is_integral<result_type>::value)\n-\t  __return_value = _M_g();\n-      \telse if (is_integral<_Engine_result_type>::value\n-\t\t && !is_integral<result_type>::value)\n-\t  __return_value = result_type(_M_g() - _M_g.min())\n-\t    / result_type(_M_g.max() - _M_g.min() + result_type(1));\n-\telse if (!is_integral<_Engine_result_type>::value\n-\t\t && !is_integral<result_type>::value)\n-\t  __return_value = result_type(_M_g() - _M_g.min())\n-\t    / result_type(_M_g.max() - _M_g.min());\n-      \treturn __return_value;\n-      }\n-  } // namespace __detail\n-\n-  /**\n-   * Produces random numbers on a given disribution function using a un uniform\n-   * random number generation engine.\n-   *\n-   * @todo the engine_value_type needs to be studied more carefully.\n-   */\n-  template<typename _Engine, typename _Dist>\n-    class variate_generator\n-    {\n-      // Concept requirements.\n-      __glibcxx_class_requires(_Engine, _CopyConstructibleConcept)\n-      //  __glibcxx_class_requires(_Engine, _EngineConcept)\n-      //  __glibcxx_class_requires(_Dist, _EngineConcept)\n-\n-    public:\n-      typedef _Engine                                engine_type;\n-      typedef __detail::_Adaptor<_Engine, _Dist>     engine_value_type;\n-      typedef _Dist                                  distribution_type;\n-      typedef typename _Dist::result_type            result_type;\n-\n-      // tr1:5.1.1 table 5.1 requirement\n-      typedef typename __gnu_cxx::__enable_if<\n-\tis_arithmetic<result_type>::value, result_type>::__type _IsValidType;\n-\n-      /**\n-       * Constructs a variate generator with the uniform random number\n-       * generator @p __eng for the random distribution @p __dist.\n-       *\n-       * @throws Any exceptions which may thrown by the copy constructors of\n-       * the @p _Engine or @p _Dist objects.\n-       */\n-      variate_generator(engine_type __eng, distribution_type __dist)\n-      : _M_engine(__eng), _M_dist(__dist) { }\n-\n-      /**\n-       * Gets the next generated value on the distribution.\n-       */\n-      result_type\n-      operator()()\n-      { return _M_dist(_M_engine); }\n-\n-      /**\n-       * WTF?\n-       */\n-      template<typename _Tp>\n-        result_type\n-        operator()(_Tp __value)\n-        { return _M_dist(_M_engine, __value); }\n-\n-      /**\n-       * Gets a reference to the underlying uniform random number generator\n-       * object.\n-       */\n-      engine_value_type&\n-      engine()\n-      { return _M_engine; }\n-\n-      /**\n-       * Gets a const reference to the underlying uniform random number\n-       * generator object.\n-       */\n-      const engine_value_type&\n-      engine() const\n-      { return _M_engine; }\n-\n-      /**\n-       * Gets a reference to the underlying random distribution.\n-       */\n-      distribution_type&\n-      distribution()\n-      { return _M_dist; }\n-\n-      /**\n-       * Gets a const reference to the underlying random distribution.\n-       */\n-      const distribution_type&\n-      distribution() const\n-      { return _M_dist; }\n-\n-      /**\n-       * Gets the closed lower bound of the distribution interval.\n-       */\n-      result_type\n-      min() const\n-      { return this->distribution().min(); }\n-\n-      /**\n-       * Gets the closed upper bound of the distribution interval.\n-       */\n-      result_type\n-      max() const\n-      { return this->distribution().max(); }\n-\n-    private:\n-      engine_value_type _M_engine;\n-      distribution_type _M_dist;\n-    };\n-\n-\n-  /**\n-   * @addtogroup tr1_random_generators Random Number Generators\n-   * @ingroup tr1_random\n-   *\n-   * These classes define objects which provide random or pseudorandom\n-   * numbers, either from a discrete or a continuous interval.  The\n-   * random number generator supplied as a part of this library are\n-   * all uniform random number generators which provide a sequence of\n-   * random number uniformly distributed over their range.\n-   *\n-   * A number generator is a function object with an operator() that\n-   * takes zero arguments and returns a number.\n-   *\n-   * A compliant random number generator must satisy the following\n-   * requirements.  <table border=1 cellpadding=10 cellspacing=0>\n-   * <caption align=top>Random Number Generator Requirements</caption>\n-   * <tr><td>To be documented.</td></tr> </table>\n-   * \n-   * @{\n-   */\n-\n-  /**\n-   * @brief A model of a linear congruential random number generator.\n-   *\n-   * A random number generator that produces pseudorandom numbers using the\n-   * linear function @f$x_{i+1}\\leftarrow(ax_{i} + c) \\bmod m @f$.\n-   *\n-   * The template parameter @p _UIntType must be an unsigned integral type\n-   * large enough to store values up to (__m-1). If the template parameter\n-   * @p __m is 0, the modulus @p __m used is\n-   * std::numeric_limits<_UIntType>::max() plus 1. Otherwise, the template\n-   * parameters @p __a and @p __c must be less than @p __m.\n-   *\n-   * The size of the state is @f$ 1 @f$.\n-   */\n-  template<class _UIntType, _UIntType __a, _UIntType __c, _UIntType __m>\n-    class linear_congruential\n-    {\n-      __glibcxx_class_requires(_UIntType, _UnsignedIntegerConcept)\n-      //  __glibcpp_class_requires(__a < __m && __c < __m)\n-\n-    public:\n-      /** The type of the generated random value. */\n-      typedef _UIntType result_type;\n-\n-      /** The multiplier. */\n-      static const _UIntType multiplier = __a;\n-      /** An increment. */\n-      static const _UIntType increment = __c;\n-      /** The modulus. */\n-      static const _UIntType modulus = __m;\n-\n-      /**\n-       * Constructs a %linear_congruential random number generator engine with\n-       * seed @p __s.  The default seed value is 1.\n-       *\n-       * @param __s The initial seed value.\n-       */\n-      explicit\n-      linear_congruential(unsigned long __x0 = 1)\n-      { this->seed(__x0); }\n-\n-      /**\n-       * Constructs a %linear_congruential random number generator engine\n-       * seeded from the generator function @p __g.\n-       *\n-       * @param __g The seed generator function.\n-       */\n-      template<class _Gen>\n-        linear_congruential(_Gen& __g)\n-        { this->seed(__g); }\n-\n-      /**\n-       * Reseeds the %linear_congruential random number generator engine\n-       * sequence to the seed @g __s.\n-       *\n-       * @param __s The new seed.\n-       */\n-      void\n-      seed(unsigned long __s = 1);\n-\n-      /**\n-       * Reseeds the %linear_congruential random number generator engine\n-       * sequence using values from the generator function @p __g.\n-       *\n-       * @param __g the seed generator function.\n-       */\n-      template<class _Gen>\n-        void\n-        seed(_Gen& __g)\n-        { seed(__g, typename is_fundamental<_Gen>::type()); }\n-\n-      /**\n-       * Gets the smallest possible value in the output range.\n-       *\n-       * The minumum depends on the @p __c parameter: if it is zero, the\n-       * minimum generated must be > 0, otherwise 0 is allowed.\n-       */\n-      result_type\n-      min() const\n-      { return (__detail::__mod<_UIntType, 1, 0, __m>(__c) == 0) ? 1 : 0; }\n-\n-      /**\n-       * Gets the largest possible value in the output range.\n-       */\n-      result_type\n-      max() const\n-      { return __m - 1; }\n-\n-      /**\n-       * Gets the next random number in the sequence.\n-       */\n-      result_type\n-      operator()();\n-\n-      /**\n-       * Compares two linear congruential random number generator\n-       * objects of the same type for equality.\n-       *  \n-       * @param __lhs A linear congruential random number generator object.\n-       * @param __rhs Another linear congruential random number generator obj.\n-       *\n-       * @returns true if the two objects are equal, false otherwise.\n-       */\n-      friend bool\n-      operator==(const linear_congruential& __lhs,\n-\t\t const linear_congruential& __rhs)\n-      { return __lhs._M_x == __rhs._M_x; }\n-\n-      /**\n-       * Compares two linear congruential random number generator\n-       * objects of the same type for inequality.\n-       *\n-       * @param __lhs A linear congruential random number generator object.\n-       * @param __rhs Another linear congruential random number generator obj.\n-       *\n-       * @returns true if the two objects are not equal, false otherwise.\n-       */\n-      friend bool\n-      operator!=(const linear_congruential& __lhs,\n-\t\t const linear_congruential& __rhs)\n-      { return !(__lhs == __rhs); }\n-\n-      /**\n-       * Writes the textual representation of the state x(i) of x to @p __os.\n-       *\n-       * @param __os  The output stream.\n-       * @param __lcr A % linear_congruential random number generator.\n-       * @returns __os.\n-       */\n-      template<class _UIntType1, _UIntType1 __a1, _UIntType1 __c1,\n-\t       _UIntType1 __m1,\n-\t       typename _CharT, typename _Traits>\n-        friend std::basic_ostream<_CharT, _Traits>&\n-        operator<<(std::basic_ostream<_CharT, _Traits>& __os,\n-\t\t   const linear_congruential<_UIntType1, __a1, __c1,\n-\t\t   __m1>& __lcr);\n-\n-      /**\n-       * Sets the state of the engine by reading its textual\n-       * representation from @p __is.\n-       *\n-       * The textual representation must have been previously written using an\n-       * output stream whose imbued locale and whose type's template\n-       * specialization arguments _CharT and _Traits were the same as those of\n-       * @p __is.\n-       *\n-       * @param __is  The input stream.\n-       * @param __lcr A % linear_congruential random number generator.\n-       * @returns __is.\n-       */\n-      template<class _UIntType1, _UIntType1 __a1, _UIntType1 __c1,\n-\t       _UIntType1 __m1,\n-\t       typename _CharT, typename _Traits>\n-        friend std::basic_istream<_CharT, _Traits>&\n-        operator>>(std::basic_istream<_CharT, _Traits>& __is,\n-\t\t   linear_congruential<_UIntType1, __a1, __c1, __m1>& __lcr);\n-\n-    private:\n-      template<class _Gen>\n-        void\n-        seed(_Gen& __g, true_type)\n-        { return seed(static_cast<unsigned long>(__g)); }\n-\n-      template<class _Gen>\n-        void\n-        seed(_Gen& __g, false_type);\n-\n-      _UIntType _M_x;\n-    };\n-\n-  /**\n-   * The classic Minimum Standard rand0 of Lewis, Goodman, and Miller.\n-   */\n-  typedef linear_congruential<unsigned long, 16807, 0, 2147483647> minstd_rand0;\n-\n-  /**\n-   * An alternative LCR (Lehmer Generator function) .\n-   */\n-  typedef linear_congruential<unsigned long, 48271, 0, 2147483647> minstd_rand;\n-\n-\n-  /**\n-   * A generalized feedback shift register discrete random number generator.\n-   *\n-   * This algorithm avoind multiplication and division and is designed to be\n-   * friendly to a pipelined architecture.  If the parameters are chosen\n-   * correctly, this generator will produce numbers with a very long period and\n-   * fairly good apparent entropy, although still not cryptographically strong.\n-   *\n-   * The best way to use this generator is with the predefined mt19937 class.\n-   *\n-   * This algorithm was originally invented by Makoto Matsumoto and\n-   * Takuji Nishimura.\n-   *\n-   * @var word_size   The number of bits in each element of the state vector.\n-   * @var state_size  The degree of recursion.\n-   * @var shift_size  The period parameter.\n-   * @var mask_bits   The separation point bit index.\n-   * @var parameter_a The last row of the twist matrix.\n-   * @var output_u    The first right-shift tempering matrix parameter.\n-   * @var output_s    The first left-shift tempering matrix parameter.\n-   * @var output_b    The first left-shift tempering matrix mask.\n-   * @var output_t    The second left-shift tempering matrix parameter.\n-   * @var output_c    The second left-shift tempering matrix mask.\n-   * @var output_l    The second right-shift tempering matrix parameter.\n-   */\n-  template<class _UIntType, int __w, int __n, int __m, int __r,\n-\t   _UIntType __a, int __u, int __s, _UIntType __b, int __t,\n-\t   _UIntType __c, int __l>\n-    class mersenne_twister\n-    {\n-      __glibcxx_class_requires(_UIntType, _UnsignedIntegerConcept)\n-\n-    public:\n-      // types\n-      typedef _UIntType result_type;\n-\n-      // parameter values\n-      static const int       word_size   = __w;\n-      static const int       state_size  = __n;\n-      static const int       shift_size  = __m;\n-      static const int       mask_bits   = __r;\n-      static const _UIntType parameter_a = __a;\n-      static const int       output_u    = __u;\n-      static const int       output_s    = __s;\n-      static const _UIntType output_b    = __b;\n-      static const int       output_t    = __t;\n-      static const _UIntType output_c    = __c;\n-      static const int       output_l    = __l;\n-\n-      // constructors and member function\n-      mersenne_twister()\n-      { seed(); }\n-\n-      explicit\n-      mersenne_twister(unsigned long __value)\n-      { seed(__value); }\n-\n-      template<class _Gen>\n-        mersenne_twister(_Gen& __g)\n-        { seed(__g); }\n-\n-      void\n-      seed()\n-      { seed(5489UL); }\n-\n-      void\n-      seed(unsigned long __value);\n-\n-      template<class _Gen>\n-        void\n-        seed(_Gen& __g)\n-        { seed(__g, typename is_fundamental<_Gen>::type()); }\n-\n-      result_type\n-      min() const\n-      { return 0; };\n-\n-      result_type\n-      max() const\n-      { return __detail::_Shift<_UIntType, __w>::__value - 1; }\n-\n-      result_type\n-      operator()();\n-\n-      /**\n-       * Compares two % mersenne_twister random number generator objects of\n-       * the same type for equality.\n-       *\n-       * @param __lhs A % mersenne_twister random number generator object.\n-       * @param __rhs Another % mersenne_twister random number generator\n-       *              object.\n-       *\n-       * @returns true if the two objects are equal, false otherwise.\n-       */\n-      friend bool\n-      operator==(const mersenne_twister& __lhs,\n-\t\t const mersenne_twister& __rhs)\n-      { return std::equal(__lhs._M_x, __lhs._M_x + state_size, __rhs._M_x); }\n-\n-      /**\n-       * Compares two % mersenne_twister random number generator objects of\n-       * the same type for inequality.\n-       *\n-       * @param __lhs A % mersenne_twister random number generator object.\n-       * @param __rhs Another % mersenne_twister random number generator\n-       *              object.\n-       *\n-       * @returns true if the two objects are not equal, false otherwise.\n-       */\n-      friend bool\n-      operator!=(const mersenne_twister& __lhs,\n-\t\t const mersenne_twister& __rhs)\n-      { return !(__lhs == __rhs); }\n-\n-      /**\n-       * Inserts the current state of a % mersenne_twister random number\n-       * generator engine @p __x into the output stream @p __os.\n-       *\n-       * @param __os An output stream.\n-       * @param __x  A % mersenne_twister random number generator engine.\n-       *\n-       * @returns The output stream with the state of @p __x inserted or in\n-       * an error state.\n-       */\n-      template<class _UIntType1, int __w1, int __n1, int __m1, int __r1,\n-\t       _UIntType1 __a1, int __u1, int __s1, _UIntType1 __b1, int __t1,\n-\t       _UIntType1 __c1, int __l1,\n-\t       typename _CharT, typename _Traits>\n-        friend std::basic_ostream<_CharT, _Traits>&\n-        operator<<(std::basic_ostream<_CharT, _Traits>& __os,\n-\t\t   const mersenne_twister<_UIntType1, __w1, __n1, __m1, __r1,\n-\t\t   __a1, __u1, __s1, __b1, __t1, __c1, __l1>& __x);\n-\n-      /**\n-       * Extracts the current state of a % mersenne_twister random number\n-       * generator engine @p __x from the input stream @p __is.\n-       *\n-       * @param __is An input stream.\n-       * @param __x  A % mersenne_twister random number generator engine.\n-       *\n-       * @returns The input stream with the state of @p __x extracted or in\n-       * an error state.\n-       */\n-      template<class _UIntType1, int __w1, int __n1, int __m1, int __r1,\n-\t       _UIntType1 __a1, int __u1, int __s1, _UIntType1 __b1, int __t1,\n-\t       _UIntType1 __c1, int __l1,\n-\t       typename _CharT, typename _Traits>\n-        friend std::basic_istream<_CharT, _Traits>&\n-        operator>>(std::basic_istream<_CharT, _Traits>& __is,\n-\t\t   mersenne_twister<_UIntType1, __w1, __n1, __m1, __r1,\n-\t\t   __a1, __u1, __s1, __b1, __t1, __c1, __l1>& __x);\n-\n-    private:\n-      template<class _Gen>\n-        void\n-        seed(_Gen& __g, true_type)\n-        { return seed(static_cast<unsigned long>(__g)); }\n-\n-      template<class _Gen>\n-        void\n-        seed(_Gen& __g, false_type);\n-\n-      _UIntType _M_x[state_size];\n-      int       _M_p;\n-    };\n-\n-  /**\n-   * The classic Mersenne Twister.\n-   *\n-   * Reference:\n-   * M. Matsumoto and T. Nishimura, \"Mersenne Twister: A 623-Dimensionally\n-   * Equidistributed Uniform Pseudo-Random Number Generator\", ACM Transactions\n-   * on Modeling and Computer Simulation, Vol. 8, No. 1, January 1998, pp 3-30.\n-   */\n-  typedef mersenne_twister<\n-    unsigned long, 32, 624, 397, 31,\n-    0x9908b0dful, 11, 7,\n-    0x9d2c5680ul, 15,\n-    0xefc60000ul, 18\n-    > mt19937;\n-\n-\n-  /**\n-   * @brief The Marsaglia-Zaman generator.\n-   * \n-   * This is a model of a Generalized Fibonacci discrete random number\n-   * generator, sometimes referred to as the SWC generator.\n-   *\n-   * A discrete random number generator that produces pseudorandom\n-   * numbers using @f$x_{i}\\leftarrow(x_{i - s} - x_{i - r} -\n-   * carry_{i-1}) \\bmod m @f$.\n-   *\n-   * The size of the state is @f$ r @f$\n-   * and the maximum period of the generator is @f$ m^r - m^s -1 @f$.\n-   *\n-   * N1688[4.13] says \"the template parameter _IntType shall denote an integral\n-   * type large enough to store values up to m.\"\n-   *\n-   * @if maint\n-   * @var _M_x     The state of the generator.  This is a ring buffer.\n-   * @var _M_carry The carry.\n-   * @var _M_p     Current index of x(i - r).\n-   * @endif\n-   */\n-  template<typename _IntType, _IntType __m, int __s, int __r>\n-    class subtract_with_carry\n-    {\n-      __glibcxx_class_requires(_IntType, _IntegerConcept)\n-\n-    public:\n-      /** The type of the generated random value. */\n-      typedef _IntType result_type;\n-      \n-      // parameter values\n-      static const _IntType modulus   = __m;\n-      static const int      long_lag  = __r;\n-      static const int      short_lag = __s;\n-\n-      /**\n-       * Constructs a default-initialized % subtract_with_carry random number\n-       * generator.\n-       */\n-      subtract_with_carry()\n-      { this->seed(); }\n-\n-      /**\n-       * Constructs an explicitly seeded % subtract_with_carry random number\n-       * generator.\n-       */\n-      explicit\n-      subtract_with_carry(unsigned long __value)\n-      { this->seed(__value); }\n-\n-      /**\n-       * Constructs a %subtract_with_carry random number generator engine\n-       * seeded from the generator function @p __g.\n-       *\n-       * @param __g The seed generator function.\n-       */\n-      template<class _Gen>\n-        subtract_with_carry(_Gen& __g)\n-        { this->seed(__g); }\n-\n-      /**\n-       * Seeds the initial state @f$ x_0 @f$ of the random number generator.\n-       *\n-       * N1688[4.19] modifies this as follows.  If @p __value == 0,\n-       * sets value to 19780503.  In any case, with a linear\n-       * congruential generator lcg(i) having parameters @f$ m_{lcg} =\n-       * 2147483563, a_{lcg} = 40014, c_{lcg} = 0, and lcg(0) = value\n-       * @f$, sets @f$ x_{-r} \\dots x_{-1} @f$ to @f$ lcg(1) \\bmod m\n-       * \\dots lcg(r) \\bmod m @f$ respectively.  If @f$ x_{-1} = 0 @f$\n-       * set carry to 1, otherwise sets carry to 0.\n-       */\n-      void\n-      seed(unsigned long __value = 19780503);\n-\n-      /**\n-       * Seeds the initial state @f$ x_0 @f$ of the % subtract_with_carry\n-       * random number generator.\n-       */\n-      template<class _Gen>\n-        void\n-        seed(_Gen& __g)\n-        { seed(__g, typename is_fundamental<_Gen>::type()); }\n-\n-      /**\n-       * Gets the inclusive minimum value of the range of random integers\n-       * returned by this generator.\n-       */\n-      result_type\n-      min() const\n-      { return 0; }\n-\n-      /**\n-       * Gets the inclusive maximum value of the range of random integers\n-       * returned by this generator.\n-       */\n-      result_type\n-      max() const\n-      { return this->modulus - 1; }\n-\n-      /**\n-       * Gets the next random number in the sequence.\n-       */\n-      result_type\n-      operator()();\n-\n-      /**\n-       * Compares two % subtract_with_carry random number generator objects of\n-       * the same type for equality.\n-       *\n-       * @param __lhs A % subtract_with_carry random number generator object.\n-       * @param __rhs Another % subtract_with_carry random number generator\n-       *              object.\n-       *\n-       * @returns true if the two objects are equal, false otherwise.\n-       */\n-      friend bool\n-      operator==(const subtract_with_carry& __lhs,\n-\t\t const subtract_with_carry& __rhs)\n-      { return std::equal(__lhs._M_x, __lhs._M_x + long_lag, __rhs._M_x); }\n-\n-      /**\n-       * Compares two % subtract_with_carry random number generator objects of\n-       * the same type for inequality.\n-       *\n-       * @param __lhs A % subtract_with_carry random number generator object.\n-       * @param __rhs Another % subtract_with_carry random number generator\n-       *              object.\n-       *\n-       * @returns true if the two objects are not equal, false otherwise.\n-       */\n-      friend bool\n-      operator!=(const subtract_with_carry& __lhs,\n-\t\t const subtract_with_carry& __rhs)\n-      { return !(__lhs == __rhs); }\n-\n-      /**\n-       * Inserts the current state of a % subtract_with_carry random number\n-       * generator engine @p __x into the output stream @p __os.\n-       *\n-       * @param __os An output stream.\n-       * @param __x  A % subtract_with_carry random number generator engine.\n-       *\n-       * @returns The output stream with the state of @p __x inserted or in\n-       * an error state.\n-       */\n-      template<typename _IntType1, _IntType1 __m1, int __s1, int __r1,\n-\t       typename _CharT, typename _Traits>\n-        friend std::basic_ostream<_CharT, _Traits>&\n-        operator<<(std::basic_ostream<_CharT, _Traits>& __os,\n-\t\t   const subtract_with_carry<_IntType1, __m1, __s1,\n-\t\t   __r1>& __x);\n-\n-      /**\n-       * Extracts the current state of a % subtract_with_carry random number\n-       * generator engine @p __x from the input stream @p __is.\n-       *\n-       * @param __is An input stream.\n-       * @param __x  A % subtract_with_carry random number generator engine.\n-       *\n-       * @returns The input stream with the state of @p __x extracted or in\n-       * an error state.\n-       */\n-      template<typename _IntType1, _IntType1 __m1, int __s1, int __r1,\n-\t       typename _CharT, typename _Traits>\n-        friend std::basic_istream<_CharT, _Traits>&\n-        operator>>(std::basic_istream<_CharT, _Traits>& __is,\n-\t\t   subtract_with_carry<_IntType1, __m1, __s1, __r1>& __x);\n-\n-    private:\n-      template<class _Gen>\n-        void\n-        seed(_Gen& __g, true_type)\n-        { return seed(static_cast<unsigned long>(__g)); }\n-\n-      template<class _Gen>\n-        void\n-        seed(_Gen& __g, false_type);\n-\n-      typedef typename __gnu_cxx::__add_unsigned<_IntType>::__type _UIntType;\n-\n-      _UIntType  _M_x[long_lag];\n-      _UIntType  _M_carry;\n-      int        _M_p;\n-    };\n-\n-\n-  /**\n-   * @brief The Marsaglia-Zaman generator (floats version).\n-   *\n-   * @if maint\n-   * @var _M_x     The state of the generator.  This is a ring buffer.\n-   * @var _M_carry The carry.\n-   * @var _M_p     Current index of x(i - r).\n-   * @var _M_npows Precomputed negative powers of 2.   \n-   * @endif\n-   */\n-  template<typename _RealType, int __w, int __s, int __r>\n-    class subtract_with_carry_01\n-    {\n-    public:\n-      /** The type of the generated random value. */\n-      typedef _RealType result_type;\n-      \n-      // parameter values\n-      static const int      word_size = __w;\n-      static const int      long_lag  = __r;\n-      static const int      short_lag = __s;\n-\n-      /**\n-       * Constructs a default-initialized % subtract_with_carry_01 random\n-       * number generator.\n-       */\n-      subtract_with_carry_01()\n-      {\n-\tthis->seed();\n-\t_M_initialize_npows();\n-      }\n-\n-      /**\n-       * Constructs an explicitly seeded % subtract_with_carry_01 random number\n-       * generator.\n-       */\n-      explicit\n-      subtract_with_carry_01(unsigned long __value)\n-      {\n-\tthis->seed(__value);\n-\t_M_initialize_npows();\n-      }\n-\n-      /**\n-       * Constructs a % subtract_with_carry_01 random number generator engine\n-       * seeded from the generator function @p __g.\n-       *\n-       * @param __g The seed generator function.\n-       */\n-      template<class _Gen>\n-        subtract_with_carry_01(_Gen& __g)\n-        {\n-\t  this->seed(__g);\n-\t  _M_initialize_npows();\t  \n-\t}\n-\n-      /**\n-       * Seeds the initial state @f$ x_0 @f$ of the random number generator.\n-       */\n-      void\n-      seed(unsigned long __value = 19780503);\n-\n-      /**\n-       * Seeds the initial state @f$ x_0 @f$ of the % subtract_with_carry_01\n-       * random number generator.\n-       */\n-      template<class _Gen>\n-        void\n-        seed(_Gen& __g)\n-        { seed(__g, typename is_fundamental<_Gen>::type()); }\n-\n-      /**\n-       * Gets the minimum value of the range of random floats\n-       * returned by this generator.\n-       */\n-      result_type\n-      min() const\n-      { return 0.0; }\n-\n-      /**\n-       * Gets the maximum value of the range of random floats\n-       * returned by this generator.\n-       */\n-      result_type\n-      max() const\n-      { return 1.0; }\n-\n-      /**\n-       * Gets the next random number in the sequence.\n-       */\n-      result_type\n-      operator()();\n-\n-      /**\n-       * Compares two % subtract_with_carry_01 random number generator objects\n-       * of the same type for equality.\n-       *\n-       * @param __lhs A % subtract_with_carry_01 random number\n-       *              generator object.\n-       * @param __rhs Another % subtract_with_carry_01 random number generator\n-       *              object.\n-       *\n-       * @returns true if the two objects are equal, false otherwise.\n-       */\n-      friend bool\n-      operator==(const subtract_with_carry_01& __lhs,\n-\t\t const subtract_with_carry_01& __rhs)\n-      {\n-\tfor (int __i = 0; __i < long_lag; ++__i)\n-\t  if (!std::equal(__lhs._M_x[__i], __lhs._M_x[__i] + __n,\n-\t\t\t  __rhs._M_x[__i]))\n-\t    return false;\n-\treturn true;\n-      }\n-\n-      /**\n-       * Compares two % subtract_with_carry_01 random number generator objects\n-       * of the same type for inequality.\n-       *\n-       * @param __lhs A % subtract_with_carry_01 random number\n-       *              generator object.\n-       *\n-       * @param __rhs Another % subtract_with_carry_01 random number generator\n-       *              object.\n-       *\n-       * @returns true if the two objects are not equal, false otherwise.\n-       */\n-      friend bool\n-      operator!=(const subtract_with_carry_01& __lhs,\n-\t\t const subtract_with_carry_01& __rhs)\n-      { return !(__lhs == __rhs); }\n-\n-      /**\n-       * Inserts the current state of a % subtract_with_carry_01 random number\n-       * generator engine @p __x into the output stream @p __os.\n-       *\n-       * @param __os An output stream.\n-       * @param __x  A % subtract_with_carry_01 random number generator engine.\n-       *\n-       * @returns The output stream with the state of @p __x inserted or in\n-       * an error state.\n-       */\n-      template<typename _RealType1, int __w1, int __s1, int __r1,\n-\t       typename _CharT, typename _Traits>\n-        friend std::basic_ostream<_CharT, _Traits>&\n-        operator<<(std::basic_ostream<_CharT, _Traits>& __os,\n-\t\t   const subtract_with_carry_01<_RealType1, __w1, __s1,\n-\t\t   __r1>& __x);\n-\n-      /**\n-       * Extracts the current state of a % subtract_with_carry_01 random number\n-       * generator engine @p __x from the input stream @p __is.\n-       *\n-       * @param __is An input stream.\n-       * @param __x  A % subtract_with_carry_01 random number generator engine.\n-       *\n-       * @returns The input stream with the state of @p __x extracted or in\n-       * an error state.\n-       */\n-      template<typename _RealType1, int __w1, int __s1, int __r1,\n-\t       typename _CharT, typename _Traits>\n-        friend std::basic_istream<_CharT, _Traits>&\n-        operator>>(std::basic_istream<_CharT, _Traits>& __is,\n-\t\t   subtract_with_carry_01<_RealType1, __w1, __s1, __r1>& __x);\n-\n-    private:\n-      template<class _Gen>\n-        void\n-        seed(_Gen& __g, true_type)\n-        { return seed(static_cast<unsigned long>(__g)); }\n-\n-      template<class _Gen>\n-        void\n-        seed(_Gen& __g, false_type);\n-\n-      void\n-      _M_initialize_npows();\n-\n-      static const int __n = (__w + 31) / 32;\n-\n-      typedef __detail::_UInt32Type _UInt32Type;\n-      _UInt32Type  _M_x[long_lag][__n];\n-      _RealType    _M_npows[__n];\n-      _UInt32Type  _M_carry;\n-      int          _M_p;\n-    };\n-\n-  typedef subtract_with_carry_01<float, 24, 10, 24>   ranlux_base_01;\n-\n-  // _GLIBCXX_RESOLVE_LIB_DEFECTS\n-  // 508. Bad parameters for ranlux64_base_01.\n-  typedef subtract_with_carry_01<double, 48, 5, 12> ranlux64_base_01;  \n-\n-\n-  /**\n-   * Produces random numbers from some base engine by discarding blocks of\n-   * data.\n-   *\n-   * 0 <= @p __r <= @p __p\n-   */\n-  template<class _UniformRandomNumberGenerator, int __p, int __r>\n-    class discard_block\n-    {\n-      // __glibcxx_class_requires(typename base_type::result_type,\n-      //                          ArithmeticTypeConcept)\n-\n-    public:\n-      /** The type of the underlying generator engine. */\n-      typedef _UniformRandomNumberGenerator   base_type;\n-      /** The type of the generated random value. */\n-      typedef typename base_type::result_type result_type;\n-\n-      // parameter values\n-      static const int block_size = __p;\n-      static const int used_block = __r;\n-\n-      /**\n-       * Constructs a default %discard_block engine.\n-       *\n-       * The underlying engine is default constructed as well.\n-       */\n-      discard_block()\n-      : _M_n(0) { }\n-\n-      /**\n-       * Copy constructs a %discard_block engine.\n-       *\n-       * Copies an existing base class random number geenerator.\n-       * @param rng An existing (base class) engine object.\n-       */\n-      explicit\n-      discard_block(const base_type& __rng)\n-      : _M_b(__rng), _M_n(0) { }\n-\n-      /**\n-       * Seed constructs a %discard_block engine.\n-       *\n-       * Constructs the underlying generator engine seeded with @p __s.\n-       * @param __s A seed value for the base class engine.\n-       */\n-      explicit\n-      discard_block(unsigned long __s)\n-      : _M_b(__s), _M_n(0) { }\n-\n-      /**\n-       * Generator construct a %discard_block engine.\n-       *\n-       * @param __g A seed generator function.\n-       */\n-      template<class _Gen>\n-        discard_block(_Gen& __g)\n-\t: _M_b(__g), _M_n(0) { }\n-\n-      /**\n-       * Reseeds the %discard_block object with the default seed for the\n-       * underlying base class generator engine.\n-       */\n-      void seed()\n-      {\n-\t_M_b.seed();\n-\t_M_n = 0;\n-      }\n-\n-      /**\n-       * Reseeds the %discard_block object with the given seed generator\n-       * function.\n-       * @param __g A seed generator function.\n-       */\n-      template<class _Gen>\n-        void seed(_Gen& __g)\n-        {\n-\t  _M_b.seed(__g);\n-\t  _M_n = 0;\n-\t}\n-\n-      /**\n-       * Gets a const reference to the underlying generator engine object.\n-       */\n-      const base_type&\n-      base() const\n-      { return _M_b; }\n-\n-      /**\n-       * Gets the minimum value in the generated random number range.\n-       */\n-      result_type\n-      min() const\n-      { return _M_b.min(); }\n-\n-      /**\n-       * Gets the maximum value in the generated random number range.\n-       */\n-      result_type\n-      max() const\n-      { return _M_b.max(); }\n-\n-      /**\n-       * Gets the next value in the generated random number sequence.\n-       */\n-      result_type\n-      operator()();\n-\n-      /**\n-       * Compares two %discard_block random number generator objects of\n-       * the same type for equality.\n-       *\n-       * @param __lhs A %discard_block random number generator object.\n-       * @param __rhs Another %discard_block random number generator\n-       *              object.\n-       *\n-       * @returns true if the two objects are equal, false otherwise.\n-       */\n-      friend bool\n-      operator==(const discard_block& __lhs, const discard_block& __rhs)\n-      { return (__lhs._M_b == __rhs._M_b) && (__lhs._M_n == __rhs._M_n); }\n-\n-      /**\n-       * Compares two %discard_block random number generator objects of\n-       * the same type for inequality.\n-       *\n-       * @param __lhs A %discard_block random number generator object.\n-       * @param __rhs Another %discard_block random number generator\n-       *              object.\n-       *\n-       * @returns true if the two objects are not equal, false otherwise.\n-       */\n-      friend bool\n-      operator!=(const discard_block& __lhs, const discard_block& __rhs)\n-      { return !(__lhs == __rhs); }\n-\n-      /**\n-       * Inserts the current state of a %discard_block random number\n-       * generator engine @p __x into the output stream @p __os.\n-       *\n-       * @param __os An output stream.\n-       * @param __x  A %discard_block random number generator engine.\n-       *\n-       * @returns The output stream with the state of @p __x inserted or in\n-       * an error state.\n-       */\n-      template<class _UniformRandomNumberGenerator1, int __p1, int __r1,\n-\t       typename _CharT, typename _Traits>\n-        friend std::basic_ostream<_CharT, _Traits>&\n-        operator<<(std::basic_ostream<_CharT, _Traits>& __os,\n-\t\t   const discard_block<_UniformRandomNumberGenerator1,\n-\t\t   __p1, __r1>& __x);\n-\n-      /**\n-       * Extracts the current state of a % subtract_with_carry random number\n-       * generator engine @p __x from the input stream @p __is.\n-       *\n-       * @param __is An input stream.\n-       * @param __x  A %discard_block random number generator engine.\n-       *\n-       * @returns The input stream with the state of @p __x extracted or in\n-       * an error state.\n-       */\n-      template<class _UniformRandomNumberGenerator1, int __p1, int __r1,\n-\t       typename _CharT, typename _Traits>\n-        friend std::basic_istream<_CharT, _Traits>&\n-        operator>>(std::basic_istream<_CharT, _Traits>& __is,\n-\t\t   discard_block<_UniformRandomNumberGenerator1,\n-\t\t   __p1, __r1>& __x);\n-\n-    private:\n-      base_type _M_b;\n-      int       _M_n;\n-    };\n-\n-\n-  /**\n-   * James's luxury-level-3 integer adaptation of Luescher's generator.\n-   */\n-  typedef discard_block<\n-    subtract_with_carry<unsigned long, (1UL << 24), 10, 24>,\n-      223,\n-      24\n-      > ranlux3;\n-\n-  /**\n-   * James's luxury-level-4 integer adaptation of Luescher's generator.\n-   */\n-  typedef discard_block<\n-    subtract_with_carry<unsigned long, (1UL << 24), 10, 24>,\n-      389,\n-      24\n-      > ranlux4;\n-\n-  typedef discard_block<\n-    subtract_with_carry_01<float, 24, 10, 24>,\n-      223,\n-      24\n-      > ranlux3_01;\n-\n-  typedef discard_block<\n-    subtract_with_carry_01<float, 24, 10, 24>,\n-      389,\n-      24\n-      > ranlux4_01;\n-\n-\n-  /**\n-   * A random number generator adaptor class that combines two random number\n-   * generator engines into a single output sequence.\n-   */\n-  template<class _UniformRandomNumberGenerator1, int __s1,\n-\t   class _UniformRandomNumberGenerator2, int __s2>\n-    class xor_combine\n-    {\n-      // __glibcxx_class_requires(typename _UniformRandomNumberGenerator1::\n-      //                          result_type, ArithmeticTypeConcept)\n-      // __glibcxx_class_requires(typename _UniformRandomNumberGenerator2::\n-      //                          result_type, ArithmeticTypeConcept)\n-\n-    public:\n-      /** The type of the the first underlying generator engine. */\n-      typedef _UniformRandomNumberGenerator1   base1_type;\n-      /** The type of the the second underlying generator engine. */\n-      typedef _UniformRandomNumberGenerator2   base2_type;\n-\n-    private:\n-      typedef typename base1_type::result_type _Result_type1;\n-      typedef typename base2_type::result_type _Result_type2;\n-\n-    public:\n-      /** The type of the generated random value. */\n-      typedef typename __gnu_cxx::__conditional_type<(sizeof(_Result_type1)\n-\t\t\t\t\t\t      > sizeof(_Result_type2)),\n-\t_Result_type1, _Result_type2>::__type result_type;\n-\n-      // parameter values\n-      static const int shift1 = __s1;\n-      static const int shift2 = __s2;\n-\n-      // constructors and member function\n-      xor_combine()\n-      : _M_b1(), _M_b2()\t\n-      { _M_initialize_max(); }\n-\n-      xor_combine(const base1_type& __rng1, const base2_type& __rng2)\n-      : _M_b1(__rng1), _M_b2(__rng2)\n-      { _M_initialize_max(); }\n-\n-      xor_combine(unsigned long __s)\n-      : _M_b1(__s), _M_b2(__s + 1)\n-      { _M_initialize_max(); }\n-\n-      template<class _Gen>\n-        xor_combine(_Gen& __g)\n-\t: _M_b1(__g), _M_b2(__g)\n-        { _M_initialize_max(); }\n-\n-      void\n-      seed()\n-      {\n-\t_M_b1.seed();\n-\t_M_b2.seed();\n-      }\n-\n-      template<class _Gen>\n-        void\n-        seed(_Gen& __g)\n-        {\n-\t  _M_b1.seed(__g);\n-\t  _M_b2.seed(__g);\n-\t}\n-\n-      const base1_type&\n-      base1() const\n-      { return _M_b1; }\n-\n-      const base2_type&\n-      base2() const\n-      { return _M_b2; }\n-\n-      result_type\n-      min() const\n-      { return 0; }\n-\n-      result_type\n-      max() const\n-      { return _M_max; }\n-\n-      /**\n-       * Gets the next random number in the sequence.\n-       */\n-      // NB: Not exactly the TR1 formula, per N2079 instead.\n-      result_type\n-      operator()()\n-      {\n-\treturn ((result_type(_M_b1() - _M_b1.min()) << shift1)\n-\t\t^ (result_type(_M_b2() - _M_b2.min()) << shift2));\n-      }\n-\n-      /**\n-       * Compares two %xor_combine random number generator objects of\n-       * the same type for equality.\n-       *\n-       * @param __lhs A %xor_combine random number generator object.\n-       * @param __rhs Another %xor_combine random number generator\n-       *              object.\n-       *\n-       * @returns true if the two objects are equal, false otherwise.\n-       */\n-      friend bool\n-      operator==(const xor_combine& __lhs, const xor_combine& __rhs)\n-      {\n-\treturn (__lhs.base1() == __rhs.base1())\n-\t        && (__lhs.base2() == __rhs.base2());\n-      }\n-\n-      /**\n-       * Compares two %xor_combine random number generator objects of\n-       * the same type for inequality.\n-       *\n-       * @param __lhs A %xor_combine random number generator object.\n-       * @param __rhs Another %xor_combine random number generator\n-       *              object.\n-       *\n-       * @returns true if the two objects are not equal, false otherwise.\n-       */\n-      friend bool\n-      operator!=(const xor_combine& __lhs, const xor_combine& __rhs)\n-      { return !(__lhs == __rhs); }\n-\n-      /**\n-       * Inserts the current state of a %xor_combine random number\n-       * generator engine @p __x into the output stream @p __os.\n-       *\n-       * @param __os An output stream.\n-       * @param __x  A %xor_combine random number generator engine.\n-       *\n-       * @returns The output stream with the state of @p __x inserted or in\n-       * an error state.\n-       */\n-      template<class _UniformRandomNumberGenerator11, int __s11,\n-\t       class _UniformRandomNumberGenerator21, int __s21,\n-\t       typename _CharT, typename _Traits>\n-        friend std::basic_ostream<_CharT, _Traits>&\n-        operator<<(std::basic_ostream<_CharT, _Traits>& __os,\n-\t\t   const xor_combine<_UniformRandomNumberGenerator11, __s11,\n-\t\t   _UniformRandomNumberGenerator21, __s21>& __x);\n-\n-      /**\n-       * Extracts the current state of a %xor_combine random number\n-       * generator engine @p __x from the input stream @p __is.\n-       *\n-       * @param __is An input stream.\n-       * @param __x  A %xor_combine random number generator engine.\n-       *\n-       * @returns The input stream with the state of @p __x extracted or in\n-       * an error state.\n-       */\n-      template<class _UniformRandomNumberGenerator11, int __s11,\n-\t       class _UniformRandomNumberGenerator21, int __s21,\n-\t       typename _CharT, typename _Traits>\n-        friend std::basic_istream<_CharT, _Traits>&\n-        operator>>(std::basic_istream<_CharT, _Traits>& __is,\n-\t\t   xor_combine<_UniformRandomNumberGenerator11, __s11,\n-\t\t   _UniformRandomNumberGenerator21, __s21>& __x);\n-\n-    private:\n-      void\n-      _M_initialize_max();\n-\n-      result_type\n-      _M_initialize_max_aux(result_type, result_type, int);\n-\n-      base1_type  _M_b1;\n-      base2_type  _M_b2;\n-      result_type _M_max;\n-    };\n-\n-\n-  /**\n-   * A standard interface to a platform-specific non-deterministic\n-   * random number generator (if any are available).\n-   */\n-  class random_device\n-  {\n-  public:\n-    // types\n-    typedef unsigned int result_type;\n-\n-    // constructors, destructors and member functions\n-\n-#ifdef _GLIBCXX_USE_RANDOM_TR1\n-\n-    explicit\n-    random_device(const std::string& __token = \"/dev/urandom\")\n-    {\n-      if ((__token != \"/dev/urandom\" && __token != \"/dev/random\")\n-\t  || !(_M_file = std::fopen(__token.c_str(), \"rb\")))\n-\tstd::__throw_runtime_error(__N(\"random_device::\"\n-\t\t\t\t       \"random_device(const std::string&)\"));\n-    }\n-\n-    ~random_device()\n-    { std::fclose(_M_file); }\n-\n-#else\n-\n-    explicit\n-    random_device(const std::string& __token = \"mt19937\")\n-    : _M_mt(_M_strtoul(__token)) { }\n-\n-  private:\n-    static unsigned long\n-    _M_strtoul(const std::string& __str)\n-    {\n-      unsigned long __ret = 5489UL;\n-      if (__str != \"mt19937\")\n-\t{\n-\t  const char* __nptr = __str.c_str();\n-\t  char* __endptr;\n-\t  __ret = std::strtoul(__nptr, &__endptr, 0);\n-\t  if (*__nptr == '\\0' || *__endptr != '\\0')\n-\t    std::__throw_runtime_error(__N(\"random_device::_M_strtoul\"\n-\t\t\t\t\t   \"(const std::string&)\"));\n-\t}\n-      return __ret;\n-    }\n-\n-  public:\n-\n-#endif\n-\n-    result_type\n-    min() const\n-    { return std::numeric_limits<result_type>::min(); }\n-\n-    result_type\n-    max() const\n-    { return std::numeric_limits<result_type>::max(); }\n-\n-    double\n-    entropy() const\n-    { return 0.0; }\n-\n-    result_type\n-    operator()()\n-    {\n-#ifdef _GLIBCXX_USE_RANDOM_TR1\n-      result_type __ret;\n-      std::fread(reinterpret_cast<void*>(&__ret), sizeof(result_type),\n-\t\t 1, _M_file);\n-      return __ret;\n-#else\n-      return _M_mt();\n-#endif\n-    }\n-\n-  private:\n-    random_device(const random_device&);\n-    void operator=(const random_device&);\n-\n-#ifdef _GLIBCXX_USE_RANDOM_TR1\n-    FILE*        _M_file;\n+#if defined(_GLIBCXX_INCLUDE_AS_TR1)\n+#  include <tr1_impl/random>\n #else\n-    mt19937      _M_mt;\n+#  define _GLIBCXX_INCLUDE_AS_TR1\n+#  define _GLIBCXX_BEGIN_NAMESPACE_TR1 namespace tr1 {\n+#  define _GLIBCXX_END_NAMESPACE_TR1 }\n+#  define _GLIBCXX_TR1 tr1::\n+#  include <tr1_impl/random>\n+#  undef _GLIBCXX_TR1\n+#  undef _GLIBCXX_END_NAMESPACE_TR1\n+#  undef _GLIBCXX_BEGIN_NAMESPACE_TR1\n+#  undef _GLIBCXX_INCLUDE_AS_TR1\n #endif\n-  };\n-\n-  /* @} */ // group tr1_random_generators\n-\n-  /**\n-   * @addtogroup tr1_random_distributions Random Number Distributions\n-   * @ingroup tr1_random\n-   * @{\n-   */\n-\n-  /**\n-   * @addtogroup tr1_random_distributions_discrete Discrete Distributions\n-   * @ingroup tr1_random_distributions\n-   * @{\n-   */\n-\n-  /**\n-   * @brief Uniform discrete distribution for random numbers.\n-   * A discrete random distribution on the range @f$[min, max]@f$ with equal\n-   * probability throughout the range.\n-   */\n-  template<typename _IntType = int>\n-    class uniform_int\n-    {\n-      __glibcxx_class_requires(_IntType, _IntegerConcept)\n- \n-    public:\n-      /** The type of the parameters of the distribution. */\n-      typedef _IntType input_type;\n-      /** The type of the range of the distribution. */\n-      typedef _IntType result_type;\n-\n-    public:\n-      /**\n-       * Constructs a uniform distribution object.\n-       */\n-      explicit\n-      uniform_int(_IntType __min = 0, _IntType __max = 9)\n-      : _M_min(__min), _M_max(__max)\n-      {\n-\t_GLIBCXX_DEBUG_ASSERT(_M_min <= _M_max);\n-      }\n-\n-      /**\n-       * Gets the inclusive lower bound of the distribution range.\n-       */\n-      result_type\n-      min() const\n-      { return _M_min; }\n-\n-      /**\n-       * Gets the inclusive upper bound of the distribution range.\n-       */\n-      result_type\n-      max() const\n-      { return _M_max; }\n-\n-      /**\n-       * Resets the distribution state.\n-       *\n-       * Does nothing for the uniform integer distribution.\n-       */\n-      void\n-      reset() { }\n-\n-      /**\n-       * Gets a uniformly distributed random number in the range\n-       * @f$(min, max)@f$.\n-       */\n-      template<typename _UniformRandomNumberGenerator>\n-        result_type\n-        operator()(_UniformRandomNumberGenerator& __urng)\n-        {\n-\t  typedef typename _UniformRandomNumberGenerator::result_type\n-\t    _UResult_type;\n-\t  return _M_call(__urng, _M_min, _M_max,\n-\t\t\t typename is_integral<_UResult_type>::type());\n-\t}\n-\n-      /**\n-       * Gets a uniform random number in the range @f$[0, n)@f$.\n-       *\n-       * This function is aimed at use with std::random_shuffle.\n-       */\n-      template<typename _UniformRandomNumberGenerator>\n-        result_type\n-        operator()(_UniformRandomNumberGenerator& __urng, result_type __n)\n-        {\n-\t  typedef typename _UniformRandomNumberGenerator::result_type\n-\t    _UResult_type;\n-\t  return _M_call(__urng, 0, __n - 1,\n-\t\t\t typename is_integral<_UResult_type>::type());\n-\t}\n-\n-      /**\n-       * Inserts a %uniform_int random number distribution @p __x into the\n-       * output stream @p os.\n-       *\n-       * @param __os An output stream.\n-       * @param __x  A %uniform_int random number distribution.\n-       *\n-       * @returns The output stream with the state of @p __x inserted or in\n-       * an error state.\n-       */\n-      template<typename _IntType1, typename _CharT, typename _Traits>\n-        friend std::basic_ostream<_CharT, _Traits>&\n-        operator<<(std::basic_ostream<_CharT, _Traits>& __os,\n-\t\t   const uniform_int<_IntType1>& __x);\n-\n-      /**\n-       * Extracts a %unform_int random number distribution\n-       * @p __x from the input stream @p __is.\n-       *\n-       * @param __is An input stream.\n-       * @param __x  A %uniform_int random number generator engine.\n-       *\n-       * @returns The input stream with @p __x extracted or in an error state.\n-       */\n-      template<typename _IntType1, typename _CharT, typename _Traits>\n-        friend std::basic_istream<_CharT, _Traits>&\n-        operator>>(std::basic_istream<_CharT, _Traits>& __is,\n-\t\t   uniform_int<_IntType1>& __x);\n-\n-    private:\n-      template<typename _UniformRandomNumberGenerator>\n-        result_type\n-        _M_call(_UniformRandomNumberGenerator& __urng,\n-\t\tresult_type __min, result_type __max, true_type)\n-        { return result_type(__urng() % (__max - __min + 1)) + __min; }\n-\n-      template<typename _UniformRandomNumberGenerator>\n-        result_type\n-        _M_call(_UniformRandomNumberGenerator& __urng,\n-\t\tresult_type __min, result_type __max, false_type)\n-        {\n-\t  return result_type((__urng() - __urng.min())\n-\t\t\t     / (__urng.max() - __urng.min())\n-\t\t\t     * (__max - __min + 1)) + __min;\n-\t}\n-\n-      _IntType _M_min;\n-      _IntType _M_max;\n-    };\n-\n-\n-  /**\n-   * @brief A Bernoulli random number distribution.\n-   *\n-   * Generates a sequence of true and false values with likelihood @f$ p @f$\n-   * that true will come up and @f$ (1 - p) @f$ that false will appear.\n-   */\n-  class bernoulli_distribution\n-  {\n-  public:\n-    typedef int  input_type;\n-    typedef bool result_type;\n-\n-  public:\n-    /**\n-     * Constructs a Bernoulli distribution with likelihood @p p.\n-     *\n-     * @param __p  [IN]  The likelihood of a true result being returned.  Must\n-     * be in the interval @f$ [0, 1] @f$.\n-     */\n-    explicit\n-    bernoulli_distribution(double __p = 0.5)\n-    : _M_p(__p)\n-    { \n-      _GLIBCXX_DEBUG_ASSERT((_M_p >= 0.0) && (_M_p <= 1.0));\n-    }\n-\n-    /**\n-     * Gets the @p p parameter of the distribution.\n-     */\n-    double\n-    p() const\n-    { return _M_p; }\n-\n-    /**\n-     * Resets the distribution state.\n-     *\n-     * Does nothing for a bernoulli distribution.\n-     */\n-    void\n-    reset() { }\n-\n-    /**\n-     * Gets the next value in the Bernoullian sequence.\n-     */\n-    template<class _UniformRandomNumberGenerator>\n-      result_type\n-      operator()(_UniformRandomNumberGenerator& __urng)\n-      {\n-\tif ((__urng() - __urng.min()) < _M_p * (__urng.max() - __urng.min()))\n-\t  return true;\n-\treturn false;\n-      }\n-\n-    /**\n-     * Inserts a %bernoulli_distribution random number distribution\n-     * @p __x into the output stream @p __os.\n-     *\n-     * @param __os An output stream.\n-     * @param __x  A %bernoulli_distribution random number distribution.\n-     *\n-     * @returns The output stream with the state of @p __x inserted or in\n-     * an error state.\n-     */\n-    template<typename _CharT, typename _Traits>\n-      friend std::basic_ostream<_CharT, _Traits>&\n-      operator<<(std::basic_ostream<_CharT, _Traits>& __os,\n-\t\t const bernoulli_distribution& __x);\n-\n-    /**\n-     * Extracts a %bernoulli_distribution random number distribution\n-     * @p __x from the input stream @p __is.\n-     *\n-     * @param __is An input stream.\n-     * @param __x  A %bernoulli_distribution random number generator engine.\n-     *\n-     * @returns The input stream with @p __x extracted or in an error state.\n-     */\n-    template<typename _CharT, typename _Traits>\n-      friend std::basic_istream<_CharT, _Traits>&\n-      operator>>(std::basic_istream<_CharT, _Traits>& __is,\n-\t\t bernoulli_distribution& __x)\n-      { return __is >> __x._M_p; }\n-\n-  private:\n-    double _M_p;\n-  };\n-\n-\n-  /**\n-   * @brief A discrete geometric random number distribution.\n-   *\n-   * The formula for the geometric probability mass function is \n-   * @f$ p(i) = (1 - p)p^{i-1} @f$ where @f$ p @f$ is the parameter of the\n-   * distribution.\n-   */\n-  template<typename _IntType = int, typename _RealType = double>\n-    class geometric_distribution\n-    {\n-    public:\n-      // types\n-      typedef _RealType input_type;\n-      typedef _IntType  result_type;\n-\n-      // constructors and member function\n-      explicit\n-      geometric_distribution(const _RealType& __p = _RealType(0.5))\n-      : _M_p(__p)\n-      {\n-\t_GLIBCXX_DEBUG_ASSERT((_M_p > 0.0) && (_M_p < 1.0));\n-\t_M_initialize();\n-      }\n-\n-      /**\n-       * Gets the distribution parameter @p p.\n-       */\n-      _RealType\n-      p() const\n-      { return _M_p; }\n-\n-      void\n-      reset() { }\n-\n-      template<class _UniformRandomNumberGenerator>\n-        result_type\n-        operator()(_UniformRandomNumberGenerator& __urng);\n-\n-      /**\n-       * Inserts a %geometric_distribution random number distribution\n-       * @p __x into the output stream @p __os.\n-       *\n-       * @param __os An output stream.\n-       * @param __x  A %geometric_distribution random number distribution.\n-       *\n-       * @returns The output stream with the state of @p __x inserted or in\n-       * an error state.\n-       */\n-      template<typename _IntType1, typename _RealType1,\n-\t       typename _CharT, typename _Traits>\n-        friend std::basic_ostream<_CharT, _Traits>&\n-        operator<<(std::basic_ostream<_CharT, _Traits>& __os,\n-\t\t   const geometric_distribution<_IntType1, _RealType1>& __x);\n-\n-      /**\n-       * Extracts a %geometric_distribution random number distribution\n-       * @p __x from the input stream @p __is.\n-       *\n-       * @param __is An input stream.\n-       * @param __x  A %geometric_distribution random number generator engine.\n-       *\n-       * @returns The input stream with @p __x extracted or in an error state.\n-       */\n-      template<typename _CharT, typename _Traits>\n-        friend std::basic_istream<_CharT, _Traits>&\n-        operator>>(std::basic_istream<_CharT, _Traits>& __is,\n-\t\t   geometric_distribution& __x)\n-        {\n-\t  __is >> __x._M_p;\n-\t  __x._M_initialize();\n-\t  return __is;\n-\t}\n-\n-    private:\n-      void\n-      _M_initialize()\n-      { _M_log_p = std::log(_M_p); }\n-\n-      _RealType _M_p;\n-      _RealType _M_log_p;\n-    };\n-\n-\n-  template<typename _RealType>\n-    class normal_distribution;\n-\n-  /**\n-   * @brief A discrete Poisson random number distribution.\n-   *\n-   * The formula for the poisson probability mass function is \n-   * @f$ p(i) = \\frac{mean^i}{i!} e^{-mean} @f$ where @f$ mean @f$ is the\n-   * parameter of the distribution.\n-   */\n-  template<typename _IntType = int, typename _RealType = double>\n-    class poisson_distribution\n-    {\n-    public:\n-      // types\n-      typedef _RealType input_type;\n-      typedef _IntType  result_type;\n-\n-      // constructors and member function\n-      explicit\n-      poisson_distribution(const _RealType& __mean = _RealType(1))\n-      : _M_mean(__mean), _M_nd()\n-      {\n-\t_GLIBCXX_DEBUG_ASSERT(_M_mean > 0.0);\n-\t_M_initialize();\n-      }\n-\n-      /**\n-       * Gets the distribution parameter @p mean.\n-       */\n-      _RealType\n-      mean() const\n-      { return _M_mean; }\n-\n-      void\n-      reset()\n-      { _M_nd.reset(); }\n-\n-      template<class _UniformRandomNumberGenerator>\n-        result_type\n-        operator()(_UniformRandomNumberGenerator& __urng);\n-\n-      /**\n-       * Inserts a %poisson_distribution random number distribution\n-       * @p __x into the output stream @p __os.\n-       *\n-       * @param __os An output stream.\n-       * @param __x  A %poisson_distribution random number distribution.\n-       *\n-       * @returns The output stream with the state of @p __x inserted or in\n-       * an error state.\n-       */\n-      template<typename _IntType1, typename _RealType1,\n-\t       typename _CharT, typename _Traits>\n-        friend std::basic_ostream<_CharT, _Traits>&\n-        operator<<(std::basic_ostream<_CharT, _Traits>& __os,\n-\t\t   const poisson_distribution<_IntType1, _RealType1>& __x);\n-\n-      /**\n-       * Extracts a %poisson_distribution random number distribution\n-       * @p __x from the input stream @p __is.\n-       *\n-       * @param __is An input stream.\n-       * @param __x  A %poisson_distribution random number generator engine.\n-       *\n-       * @returns The input stream with @p __x extracted or in an error state.\n-       */\n-      template<typename _IntType1, typename _RealType1,\n-\t       typename _CharT, typename _Traits>\n-        friend std::basic_istream<_CharT, _Traits>&\n-        operator>>(std::basic_istream<_CharT, _Traits>& __is,\n-\t\t   poisson_distribution<_IntType1, _RealType1>& __x);\n-\n-    private:\n-      void\n-      _M_initialize();\n-\n-      // NB: Unused when _GLIBCXX_USE_C99_MATH_TR1 is undefined.\n-      normal_distribution<_RealType> _M_nd;\n-\n-      _RealType _M_mean;\n-\n-      // Hosts either log(mean) or the threshold of the simple method.\n-      _RealType _M_lm_thr;\n-#if _GLIBCXX_USE_C99_MATH_TR1\n-      _RealType _M_lfm, _M_sm, _M_d, _M_scx, _M_1cx, _M_c2b, _M_cb;\n-#endif\n-    };\n-\n-\n-  /**\n-   * @brief A discrete binomial random number distribution.\n-   *\n-   * The formula for the binomial probability mass function is \n-   * @f$ p(i) = \\binom{n}{i} p^i (1 - p)^{t - i} @f$ where @f$ t @f$\n-   * and @f$ p @f$ are the parameters of the distribution.\n-   */\n-  template<typename _IntType = int, typename _RealType = double>\n-    class binomial_distribution\n-    {\n-    public:\n-      // types\n-      typedef _RealType input_type;\n-      typedef _IntType  result_type;\n-\n-      // constructors and member function\n-      explicit\n-      binomial_distribution(_IntType __t = 1,\n-\t\t\t    const _RealType& __p = _RealType(0.5))\n-      : _M_t(__t), _M_p(__p), _M_nd()\n-      {\n-\t_GLIBCXX_DEBUG_ASSERT((_M_t >= 0) && (_M_p >= 0.0) && (_M_p <= 1.0));\n-\t_M_initialize();\n-      }\n-\n-      /**\n-       * Gets the distribution @p t parameter.\n-       */\n-      _IntType\n-      t() const\n-      { return _M_t; }\n-      \n-      /**\n-       * Gets the distribution @p p parameter.\n-       */\n-      _RealType\n-      p() const\n-      { return _M_p; }\n-\n-      void\n-      reset()\n-      { _M_nd.reset(); }\n-\n-      template<class _UniformRandomNumberGenerator>\n-        result_type\n-        operator()(_UniformRandomNumberGenerator& __urng);\n-\n-      /**\n-       * Inserts a %binomial_distribution random number distribution\n-       * @p __x into the output stream @p __os.\n-       *\n-       * @param __os An output stream.\n-       * @param __x  A %binomial_distribution random number distribution.\n-       *\n-       * @returns The output stream with the state of @p __x inserted or in\n-       * an error state.\n-       */\n-      template<typename _IntType1, typename _RealType1,\n-\t       typename _CharT, typename _Traits>\n-        friend std::basic_ostream<_CharT, _Traits>&\n-        operator<<(std::basic_ostream<_CharT, _Traits>& __os,\n-\t\t   const binomial_distribution<_IntType1, _RealType1>& __x);\n-\n-      /**\n-       * Extracts a %binomial_distribution random number distribution\n-       * @p __x from the input stream @p __is.\n-       *\n-       * @param __is An input stream.\n-       * @param __x  A %binomial_distribution random number generator engine.\n-       *\n-       * @returns The input stream with @p __x extracted or in an error state.\n-       */\n-      template<typename _IntType1, typename _RealType1,\n-\t       typename _CharT, typename _Traits>\n-        friend std::basic_istream<_CharT, _Traits>&\n-        operator>>(std::basic_istream<_CharT, _Traits>& __is,\n-\t\t   binomial_distribution<_IntType1, _RealType1>& __x);\n-\n-    private:\n-      void\n-      _M_initialize();\n-\n-      template<class _UniformRandomNumberGenerator>\n-        result_type\n-        _M_waiting(_UniformRandomNumberGenerator& __urng, _IntType __t);\n-\n-      // NB: Unused when _GLIBCXX_USE_C99_MATH_TR1 is undefined.\n-      normal_distribution<_RealType> _M_nd;\n-\n-      _RealType _M_q;\n-#if _GLIBCXX_USE_C99_MATH_TR1\n-      _RealType _M_d1, _M_d2, _M_s1, _M_s2, _M_c,\n-\t        _M_a1, _M_a123, _M_s, _M_lf, _M_lp1p;\n-#endif\n-      _RealType _M_p;\n-      _IntType  _M_t;\n-\n-      bool      _M_easy;\n-    };\n-\n-  /* @} */ // group tr1_random_distributions_discrete\n-\n-  /**\n-   * @addtogroup tr1_random_distributions_continuous Continuous Distributions\n-   * @ingroup tr1_random_distributions\n-   * @{\n-   */\n-\n-  /**\n-   * @brief Uniform continuous distribution for random numbers.\n-   *\n-   * A continuous random distribution on the range [min, max) with equal\n-   * probability throughout the range.  The URNG should be real-valued and\n-   * deliver number in the range [0, 1).\n-   */\n-  template<typename _RealType = double>\n-    class uniform_real\n-    {\n-    public:\n-      // types\n-      typedef _RealType input_type;\n-      typedef _RealType result_type;\n-\n-    public:\n-      /**\n-       * Constructs a uniform_real object.\n-       *\n-       * @param __min [IN]  The lower bound of the distribution.\n-       * @param __max [IN]  The upper bound of the distribution.\n-       */\n-      explicit\n-      uniform_real(_RealType __min = _RealType(0),\n-\t\t   _RealType __max = _RealType(1))\n-      : _M_min(__min), _M_max(__max)\n-      {\n-\t_GLIBCXX_DEBUG_ASSERT(_M_min <= _M_max);\n-      }\n-\n-      result_type\n-      min() const\n-      { return _M_min; }\n-\n-      result_type\n-      max() const\n-      { return _M_max; }\n-\n-      void\n-      reset() { }\n-\n-      template<class _UniformRandomNumberGenerator>\n-        result_type\n-        operator()(_UniformRandomNumberGenerator& __urng)\n-        { return (__urng() * (_M_max - _M_min)) + _M_min; }\n-\n-      /**\n-       * Inserts a %uniform_real random number distribution @p __x into the\n-       * output stream @p __os.\n-       *\n-       * @param __os An output stream.\n-       * @param __x  A %uniform_real random number distribution.\n-       *\n-       * @returns The output stream with the state of @p __x inserted or in\n-       * an error state.\n-       */\n-      template<typename _RealType1, typename _CharT, typename _Traits>\n-        friend std::basic_ostream<_CharT, _Traits>&\n-        operator<<(std::basic_ostream<_CharT, _Traits>& __os,\n-\t\t   const uniform_real<_RealType1>& __x);\n-\n-      /**\n-       * Extracts a %unform_real random number distribution\n-       * @p __x from the input stream @p __is.\n-       *\n-       * @param __is An input stream.\n-       * @param __x  A %uniform_real random number generator engine.\n-       *\n-       * @returns The input stream with @p __x extracted or in an error state.\n-       */\n-      template<typename _RealType1, typename _CharT, typename _Traits>\n-        friend std::basic_istream<_CharT, _Traits>&\n-        operator>>(std::basic_istream<_CharT, _Traits>& __is,\n-\t\t   uniform_real<_RealType1>& __x);\n-\n-    private:\n-      _RealType _M_min;\n-      _RealType _M_max;\n-    };\n-\n-\n-  /**\n-   * @brief An exponential continuous distribution for random numbers.\n-   *\n-   * The formula for the exponential probability mass function is \n-   * @f$ p(x) = \\lambda e^{-\\lambda x} @f$.\n-   *\n-   * <table border=1 cellpadding=10 cellspacing=0>\n-   * <caption align=top>Distribution Statistics</caption>\n-   * <tr><td>Mean</td><td>@f$ \\frac{1}{\\lambda} @f$</td></tr>\n-   * <tr><td>Median</td><td>@f$ \\frac{\\ln 2}{\\lambda} @f$</td></tr>\n-   * <tr><td>Mode</td><td>@f$ zero @f$</td></tr>\n-   * <tr><td>Range</td><td>@f$[0, \\infty]@f$</td></tr>\n-   * <tr><td>Standard Deviation</td><td>@f$ \\frac{1}{\\lambda} @f$</td></tr>\n-   * </table>\n-   */\n-  template<typename _RealType = double>\n-    class exponential_distribution\n-    {\n-    public:\n-      // types\n-      typedef _RealType input_type;\n-      typedef _RealType result_type;\n-\n-    public:\n-      /**\n-       * Constructs an exponential distribution with inverse scale parameter\n-       * @f$ \\lambda @f$.\n-       */\n-      explicit\n-      exponential_distribution(const result_type& __lambda = result_type(1))\n-      : _M_lambda(__lambda)\n-      { \n-\t_GLIBCXX_DEBUG_ASSERT(_M_lambda > 0);\n-      }\n-\n-      /**\n-       * Gets the inverse scale parameter of the distribution.\n-       */\n-      _RealType\n-      lambda() const\n-      { return _M_lambda; }\n-\n-      /**\n-       * Resets the distribution.\n-       *\n-       * Has no effect on exponential distributions.\n-       */\n-      void\n-      reset() { }\n-\n-      template<class _UniformRandomNumberGenerator>\n-        result_type\n-        operator()(_UniformRandomNumberGenerator& __urng)\n-        { return -std::log(__urng()) / _M_lambda; }\n-\n-      /**\n-       * Inserts a %exponential_distribution random number distribution\n-       * @p __x into the output stream @p __os.\n-       *\n-       * @param __os An output stream.\n-       * @param __x  A %exponential_distribution random number distribution.\n-       *\n-       * @returns The output stream with the state of @p __x inserted or in\n-       * an error state.\n-       */\n-      template<typename _RealType1, typename _CharT, typename _Traits>\n-        friend std::basic_ostream<_CharT, _Traits>&\n-        operator<<(std::basic_ostream<_CharT, _Traits>& __os,\n-\t\t   const exponential_distribution<_RealType1>& __x);\n-\n-      /**\n-       * Extracts a %exponential_distribution random number distribution\n-       * @p __x from the input stream @p __is.\n-       *\n-       * @param __is An input stream.\n-       * @param __x A %exponential_distribution random number\n-       *            generator engine.\n-       *\n-       * @returns The input stream with @p __x extracted or in an error state.\n-       */\n-      template<typename _CharT, typename _Traits>\n-        friend std::basic_istream<_CharT, _Traits>&\n-        operator>>(std::basic_istream<_CharT, _Traits>& __is,\n-\t\t   exponential_distribution& __x)\n-        { return __is >> __x._M_lambda; }\n-\n-    private:\n-      result_type _M_lambda;\n-    };\n-\n-\n-  /**\n-   * @brief A normal continuous distribution for random numbers.\n-   *\n-   * The formula for the normal probability mass function is \n-   * @f$ p(x) = \\frac{1}{\\sigma \\sqrt{2 \\pi}} \n-   *            e^{- \\frac{{x - mean}^ {2}}{2 \\sigma ^ {2}} } @f$.\n-   */\n-  template<typename _RealType = double>\n-    class normal_distribution\n-    {\n-    public:\n-      // types\n-      typedef _RealType input_type;\n-      typedef _RealType result_type;\n-\n-    public:\n-      /**\n-       * Constructs a normal distribution with parameters @f$ mean @f$ and\n-       * @f$ \\sigma @f$.\n-       */\n-      explicit\n-      normal_distribution(const result_type& __mean = result_type(0),\n-\t\t\t  const result_type& __sigma = result_type(1))\n-      : _M_mean(__mean), _M_sigma(__sigma), _M_saved_available(false)\n-      { \n-\t_GLIBCXX_DEBUG_ASSERT(_M_sigma > 0);\n-      }\n-\n-      /**\n-       * Gets the mean of the distribution.\n-       */\n-      _RealType\n-      mean() const\n-      { return _M_mean; }\n-\n-      /**\n-       * Gets the @f$ \\sigma @f$ of the distribution.\n-       */\n-      _RealType\n-      sigma() const\n-      { return _M_sigma; }\n-\n-      /**\n-       * Resets the distribution.\n-       */\n-      void\n-      reset()\n-      { _M_saved_available = false; }\n-\n-      template<class _UniformRandomNumberGenerator>\n-        result_type\n-        operator()(_UniformRandomNumberGenerator& __urng);\n-\n-      /**\n-       * Inserts a %normal_distribution random number distribution\n-       * @p __x into the output stream @p __os.\n-       *\n-       * @param __os An output stream.\n-       * @param __x  A %normal_distribution random number distribution.\n-       *\n-       * @returns The output stream with the state of @p __x inserted or in\n-       * an error state.\n-       */\n-      template<typename _RealType1, typename _CharT, typename _Traits>\n-        friend std::basic_ostream<_CharT, _Traits>&\n-        operator<<(std::basic_ostream<_CharT, _Traits>& __os,\n-\t\t   const normal_distribution<_RealType1>& __x);\n-\n-      /**\n-       * Extracts a %normal_distribution random number distribution\n-       * @p __x from the input stream @p __is.\n-       *\n-       * @param __is An input stream.\n-       * @param __x  A %normal_distribution random number generator engine.\n-       *\n-       * @returns The input stream with @p __x extracted or in an error state.\n-       */\n-      template<typename _RealType1, typename _CharT, typename _Traits>\n-        friend std::basic_istream<_CharT, _Traits>&\n-        operator>>(std::basic_istream<_CharT, _Traits>& __is,\n-\t\t   normal_distribution<_RealType1>& __x);\n-\n-    private:\n-      result_type _M_mean;\n-      result_type _M_sigma;\n-      result_type _M_saved;\n-      bool        _M_saved_available;     \n-    };\n-\n-\n-  /**\n-   * @brief A gamma continuous distribution for random numbers.\n-   *\n-   * The formula for the gamma probability mass function is \n-   * @f$ p(x) = \\frac{1}{\\Gamma(\\alpha)} x^{\\alpha - 1} e^{-x} @f$.\n-   */\n-  template<typename _RealType = double>\n-    class gamma_distribution\n-    {\n-    public:\n-      // types\n-      typedef _RealType input_type;\n-      typedef _RealType result_type;\n-\n-    public:\n-      /**\n-       * Constructs a gamma distribution with parameters @f$ \\alpha @f$.\n-       */\n-      explicit\n-      gamma_distribution(const result_type& __alpha_val = result_type(1))\n-      : _M_alpha(__alpha_val)\n-      { \n-\t_GLIBCXX_DEBUG_ASSERT(_M_alpha > 0);\n-\t_M_initialize();\n-      }\n-\n-      /**\n-       * Gets the @f$ \\alpha @f$ of the distribution.\n-       */\n-      _RealType\n-      alpha() const\n-      { return _M_alpha; }\n-\n-      /**\n-       * Resets the distribution.\n-       */\n-      void\n-      reset() { }\n-\n-      template<class _UniformRandomNumberGenerator>\n-        result_type\n-        operator()(_UniformRandomNumberGenerator& __urng);\n-\n-      /**\n-       * Inserts a %gamma_distribution random number distribution\n-       * @p __x into the output stream @p __os.\n-       *\n-       * @param __os An output stream.\n-       * @param __x  A %gamma_distribution random number distribution.\n-       *\n-       * @returns The output stream with the state of @p __x inserted or in\n-       * an error state.\n-       */\n-      template<typename _RealType1, typename _CharT, typename _Traits>\n-        friend std::basic_ostream<_CharT, _Traits>&\n-        operator<<(std::basic_ostream<_CharT, _Traits>& __os,\n-\t\t   const gamma_distribution<_RealType1>& __x);\n-\n-      /**\n-       * Extracts a %gamma_distribution random number distribution\n-       * @p __x from the input stream @p __is.\n-       *\n-       * @param __is An input stream.\n-       * @param __x  A %gamma_distribution random number generator engine.\n-       *\n-       * @returns The input stream with @p __x extracted or in an error state.\n-       */\n-      template<typename _CharT, typename _Traits>\n-        friend std::basic_istream<_CharT, _Traits>&\n-        operator>>(std::basic_istream<_CharT, _Traits>& __is,\n-\t\t   gamma_distribution& __x)\n-        {\n-\t  __is >> __x._M_alpha;\n-\t  __x._M_initialize();\n-\t  return __is;\n-\t}\n-\n-    private:\n-      void\n-      _M_initialize();\n-\n-      result_type _M_alpha;\n-\n-      // Hosts either lambda of GB or d of modified Vaduva's.\n-      result_type _M_l_d;\n-    };\n-\n-  /* @} */ // group tr1_random_distributions_continuous\n-  /* @} */ // group tr1_random_distributions\n-  /* @} */ // group tr1_random\n-\n-_GLIBCXX_END_NAMESPACE\n-}\n-\n-#include <tr1/random.tcc>\n \n-#endif // _TR1_RANDOM\n+#endif // _GLIBCXX_TR1_RANDOM"}, {"sha": "028297799af2165f9f2f6378c346b7ef5ce833ba", "filename": "libstdc++-v3/include/tr1/regex", "status": "modified", "additions": 22, "deletions": 2383, "changes": 2405, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e133ace8d907bf42754c86106fc3f04a9d9fe70f/libstdc%2B%2B-v3%2Finclude%2Ftr1%2Fregex", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e133ace8d907bf42754c86106fc3f04a9d9fe70f/libstdc%2B%2B-v3%2Finclude%2Ftr1%2Fregex", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Ftr1%2Fregex?ref=e133ace8d907bf42754c86106fc3f04a9d9fe70f", "patch": "@@ -33,2397 +33,36 @@\n  * This is a TR1 C++ Library header. \n  */\n \n-#ifndef _TR1_REGEX\n-#define _TR1_REGEX 1\n+#ifndef _GLIBCXX_TR1_REGEX\n+#define _GLIBCXX_TR1_REGEX 1\n+\n+#pragma GCC system_header\n+\n+#if defined(_GLIBCXX_INCLUDE_AS_CXX0X)\n+#  error TR1 header cannot be included from C++0x header\n+#endif\n \n-#include <bits/c++config.h>\n #include <algorithm>\n #include <bitset>\n #include <iterator>\n #include <locale>\n #include <stdexcept>\n #include <string>\n-#include <utility>\n #include <vector>\n+#include <utility>\n \n-namespace std\n-{\n-_GLIBCXX_BEGIN_NAMESPACE(_GLIBCXX_TR1)\n-\n-/**\n- * @addtogroup tr1_regex Regular Expressions\n- * A facility for performing regular expression pattern matching.\n- * @{\n- */\n-\n-namespace regex_constants\n-{\n-  // [7.5.1] Bitmask Type syntax_option_type\n-  enum __syntax_option\n-    {\n-      _S_icase,\n-      _S_nosubs,\n-      _S_optimize,\n-      _S_collate,\n-      _S_ECMAScript,\n-      _S_basic,\n-      _S_extended,\n-      _S_awk,\n-      _S_grep,\n-      _S_egrep,\n-      _S_syntax_last\n-    };\n-\n-  /**\n-   * @brief This is a bitmask type indicating how to interpret the regex.\n-   *\n-   * The @c syntax_option_type is implementation defined but it is valid to\n-   * perform bitwise operations on these values and expect the right thing to\n-   * happen.\n-   *\n-   * A valid value of type syntax_option_type shall have exactly one of the\n-   * elements @c ECMAScript, @c basic, @c extended, @c awk, @c grep, @c egrep\n-   * set.\n-   */\n-  typedef unsigned int syntax_option_type;\n-\n-  /// Specifies that the matching of regular expressions against a character\n-  /// sequence shall be performed without regard to case.\n-  static const syntax_option_type icase      = 1 << _S_icase;\n-\n-  /// Specifies that when a regular expression is matched against a character\n-  /// container sequence, no sub-expression matches are to be stored in the\n-  /// supplied match_results structure.\n-  static const syntax_option_type nosubs     = 1 << _S_nosubs;\n-\n-  /// Specifies that the regular expression engine should pay more attention to\n-  /// the speed with which regular expressions are matched, and less to the\n-  /// speed with which regular expression objects are constructed. Otherwise\n-  /// it has no detectable effect on the program output.\n-  static const syntax_option_type optimize   = 1 << _S_optimize;\n-\n-  /// Specifies that character ranges of the form [a-b] should be locale\n-  /// sensitive.\n-  static const syntax_option_type collate    = 1 << _S_collate;\n-\n-  /// Specifies that the grammar recognized by the regular expression engine is\n-  /// that used by ECMAScript in ECMA-262 [Ecma International, ECMAScript\n-  /// Language Specification, Standard Ecma-262, third edition, 1999], as\n-  /// modified in tr1 section [7.13].  This grammar is similar to that defined\n-  /// in the PERL scripting language but extended with elements found in the\n-  /// POSIX regular expression grammar.\n-  static const syntax_option_type ECMAScript = 1 << _S_ECMAScript;\n-\n-  /// Specifies that the grammar recognized by the regular expression engine is\n-  /// that used by POSIX basic regular expressions in IEEE Std 1003.1-2001,\n-  /// Portable Operating System Interface (POSIX), Base Definitions and\n-  /// Headers, Section 9, Regular Expressions [IEEE, Information Technology --\n-  /// Portable Operating System Interface (POSIX), IEEE Standard 1003.1-2001].\n-  static const syntax_option_type basic      = 1 << _S_basic;\n-\n-  /// Specifies that the grammar recognized by the regular expression engine is\n-  /// that used by POSIX extended regular expressions in IEEE Std 1003.1-2001,\n-  /// Portable Operating System Interface (POSIX), Base Definitions and Headers,\n-  /// Section 9, Regular Expressions.\n-  static const syntax_option_type extended   = 1 << _S_extended;\n-\n-  /// Specifies that the grammar recognized by the regular expression engine is\n-  /// that used by POSIX utility awk in IEEE Std 1003.1-2001.  This option is\n-  /// identical to syntax_option_type extended, except that C-style escape\n-  /// sequences are supported.  These sequences are, explicitly, '\\\\', '\\a',\n-  /// '\\b', '\\f', '\\n', '\\r', '\\t' , '\\v', '\\\"', '\\\\', and '\\ddd' (where ddd is\n-  /// one, two, or three octal digits).  \n-  static const syntax_option_type awk        = 1 << _S_awk;\n-\n-  /// Specifies that the grammar recognized by the regular expression engine is\n-  /// that used by POSIX utility grep in IEEE Std 1003.1-2001.  This option is\n-  /// identical to syntax_option_type basic, except that newlines are treated\n-  /// as whitespace.\n-  static const syntax_option_type grep       = 1 << _S_grep;\n-\n-  /// Specifies that the grammar recognized by the regular expression engine is\n-  /// that used by POSIX utility grep when given the -E option in\n-  /// IEEE Std 1003.1-2001.  This option is identical to syntax_option_type \n-  /// extended, except that newlines are treated as whitespace.\n-  static const syntax_option_type egrep      = 1 << _S_egrep;\n-\n-\n-  // [7.5.2] Bitmask Type match_flag_type\n-  enum __match_flag\n-    {\n-      _S_not_bol,\n-      _S_not_eol,\n-      _S_not_bow,\n-      _S_not_eow,\n-      _S_any,\n-      _S_not_null,\n-      _S_continuous,\n-      _S_prev_avail,\n-      _S_sed,\n-      _S_no_copy,\n-      _S_first_only,\n-      _S_match_flag_last\n-    };\n-\n-  /**\n-   * @brief This is a bitmask type indicating regex matching rules.\n-   *\n-   * Matching a regular expression against a sequence of characters [first,\n-   * last) proceeds according to the rules of the grammar specified for the\n-   * regular expression object, modified according to the effects listed\n-   * below for any bitmask elements set.\n-   *\n-   * The @c match_flag_type is implementation defined but it is valid to\n-   * perform bitwise operations on these values and expect the right thing to\n-   * happen.\n-   */\n-  typedef std::bitset<_S_match_flag_last> match_flag_type;\n-\n-  static const match_flag_type match_default     = 0;\n-\n-  /// The first character in the sequence [first, last) is treated as though it\n-  /// is not at the beginning of a line, so the character \"^\" in the regular\n-  /// expression shall not match [first, first).\n-  static const match_flag_type match_not_bol     = 1 << _S_not_bol;\n-\n-  /// The last character in the sequence [first, last) is treated as though it\n-  /// is not at the end of a line, so the character \"$\" in the regular\n-  /// expression shall not match [last, last).\n-  static const match_flag_type match_not_eol     = 1 << _S_not_eol;\n-   \n-  /// The expression \"\\b\" is not matched against the sub-sequence\n-  /// [first,first).\n-  static const match_flag_type match_not_bow     = 1 << _S_not_bow;\n-   \n-  /// The expression \"\\b\" should not be matched against the sub-sequence\n-  /// [last,last).\n-  static const match_flag_type match_not_eow     = 1 << _S_not_eow;\n-   \n-  /// If more than one match is possible then any match is an acceptable\n-  /// result.\n-  static const match_flag_type match_any         = 1 << _S_any;\n-   \n-  /// The expression does not match an empty sequence.\n-  static const match_flag_type match_not_null    = 1 << _S_not_null;\n-   \n-  /// The expression only matchs a sub-sequence that begins at first .\n-  static const match_flag_type match_continuous  = 1 << _S_continuous;\n-   \n-  /// --first is a valid iterator position.  When this flag is set then the\n-  /// flags match_not_bol and match_not_bow are ignored by the regular\n-  /// expression algorithms 7.11 and iterators 7.12.\n-  static const match_flag_type match_prev_avail  = 1 << _S_prev_avail;\n-\n-  /// When a regular expression match is to be replaced by a new string, the\n-  /// new string is constructed using the rules used by the ECMAScript replace\n-  /// function in ECMA- 262 [Ecma International, ECMAScript Language\n-  /// Specification, Standard Ecma-262, third edition, 1999], part 15.5.4.11\n-  /// String.prototype.replace. In addition, during search and replace\n-  /// operations all non-overlapping occurrences of the regular expression\n-  /// are located and replaced, and sections of the input that did not match\n-  /// the expression are copied unchanged to the output string.\n-  ///\n-  /// Format strings (from ECMA-262 [15.5.4.11]):\n-  /// $$  $\n-  /// $&  The matched substring.\n-  /// $`  The portion of <em>string</em> that preceeds the matched substring.\n-  /// $'  The portion of <em>string</em> that follows the matched substring.\n-  /// $n  The nth capture, where n is in [1,9] and $n is not followed by a\n-  ///     decimal digit.  If n <= m and the nth capture is undefined, use the\n-  ///     empty string\n-  ///     instead. If n > m, the result is implementation-defined.\n-  /// $nn The nnth capture, where nn is a two-digit decimal number on [01, 99].\n-  ///     If nn <= m and the nth capture is undefined, use the empty string\n-  ///     instead. If nn > m, the result is implementation-defined.\n-  ///\n-  static const match_flag_type format_default    = 0;\n-\n-  /// When a regular expression match is to be replaced by a new string, the\n-  /// new string is constructed using the rules used by the POSIX sed utility\n-  /// in IEEE Std 1003.1- 2001 [IEEE, Information Technology -- Portable\n-  /// Operating System Interface (POSIX), IEEE Standard 1003.1-2001].\n-  static const match_flag_type format_sed        = 1 << _S_sed;\n-\n-  /// During a search and replace operation, sections of the character\n-  /// container sequence being searched that do not match the regular\n-  /// expression shall not be copied to the output string.\n-  static const match_flag_type format_no_copy    = 1 << _S_no_copy;\n-\n-  /// When specified during a search and replace operation, only the first\n-  /// occurrence of the regular expression shall be replaced.\n-  static const match_flag_type format_first_only = 1 << _S_first_only;\n-\n-\n-  // [7.5.3] implementation-defined error type\n-  enum error_type\n-    {\n-      _S_error_collate,\n-      _S_error_ctype,\n-      _S_error_escape,\n-      _S_error_backref,\n-      _S_error_brack,\n-      _S_error_paren,\n-      _S_error_brace,\n-      _S_error_badbrace,\n-      _S_error_range,\n-      _S_error_space,\n-      _S_error_badrepeat,\n-      _S_error_complexity,\n-      _S_error_stack,\n-      _S_error_last\n-    };\n-\n-  /// The expression contained an invalid collating element name.\n-  static const error_type error_collate(_S_error_collate);\n-\n-  /// The expression contained an invalid character class name.\n-  static const error_type error_ctype(_S_error_ctype);\n-\n-  /// The expression contained an invalid escaped character, or a trailing\n-  /// escape.\n-  static const error_type error_escape(_S_error_escape);\n-\n-  /// The expression contained an invalid back reference.\n-  static const error_type error_backref(_S_error_backref);\n-\n-  /// The expression contained mismatched [ and ].\n-  static const error_type error_brack(_S_error_brack);\n-\n-  /// The expression contained mismatched ( and ).\n-  static const error_type error_paren(_S_error_paren);\n-\n-  /// The expression contained mismatched { and }\n-  static const error_type error_brace(_S_error_brace);\n-\n-  /// The expression contained an invalid range in a {} expression.\n-  static const error_type error_badbrace(_S_error_badbrace);\n-\n-  /// The expression contained an invalid character range,\n-  /// such as [b-a] in most encodings.\n-  static const error_type error_range(_S_error_range);\n-\n-  /// There was insufficient memory to convert the expression into a\n-  /// finite state machine.\n-  static const error_type error_space(_S_error_space);\n-\n-  /// One of *?+{ was not preceded by a valid regular expression.\n-  static const error_type error_badrepeat(_S_error_badrepeat);\n-\n-  /// The complexity of an attempted match against a regular expression\n-  /// exceeded a pre-set level.\n-  static const error_type error_complexity(_S_error_complexity);\n-\n-  /// There was insufficient memory to determine whether the\n-  /// regular expression could match the specified character sequence.\n-  static const error_type error_stack(_S_error_stack);\n-}\n-\n-\n-  // [7.8] Class regex_error\n-  /**\n-   * Defines the type of objects thrown as exceptions to report errors from the\n-   * regular expression library.\n-   */\n-  class regex_error\n-  : public std::runtime_error\n-  {\n-  public:\n-    /**\n-     * @brief constructs a regex_error object.\n-     *\n-     * @param ecode the regex error code.\n-     */\n-    explicit\n-    regex_error(regex_constants::error_type __ecode)\n-    : std::runtime_error(\"regex_error\"), _M_code(__ecode)\n-    { }\n-\n-    /**\n-     * @brief gets the regex error code.\n-     *\n-     * @returns the regex error code.\n-     */\n-    regex_constants::error_type\n-    code() const\n-    { return _M_code; }\n-\n-  protected:\n-    regex_constants::error_type _M_code;\n-  };\n-\n-\n-  // [7.7] Class regex_traits\n-  /**\n-   * A regular expression traits class that satisfies the requirements of tr1\n-   * section [7.2].\n-   *\n-   * The class %regex is parameterized around a set of related types and\n-   * functions used to complete the definition of its semantics.  This class\n-   * satisfies the requirements of such a traits class.\n-   */\n-  template<typename _Ch_type>\n-    struct regex_traits\n-    {\n-    public:\n-      typedef _Ch_type                     char_type;\n-      typedef std::basic_string<char_type> string_type;\n-      typedef std::locale                  locale_type;\n-      typedef std::ctype_base::mask        char_class_type;\n-\n-    public:\n-      /**\n-       * @brief Constructs a default traits object.\n-       */\n-      regex_traits()\n-      { }\n-      \n-      /**\n-       * @brief Gives the length of a C-style string starting at @p __p.\n-       *\n-       * @param __p a pointer to the start of a character sequence.\n-       *\n-       * @returns the number of characters between @p *__p and the first\n-       * default-initialized value of type @p char_type.  In other words, uses\n-       * the C-string algorithm for determiining the length of a sequence of\n-       * characters.\n-       */\n-      static std::size_t\n-      length(const char_type* __p)\n-      { return string_type::traits_type::length(__p); }\n-\n-      /**\n-       * @brief Performs the identity translation.\n-       *\n-       * @param c A character to the locale-specific character set.\n-       *\n-       * @returns c.\n-       */\n-      char_type\n-      translate(char_type __c) const\n-      { return __c; }\n-      \n-      /**\n-       * @brief Translates a character into a case-insensitive equivalent.\n-       *\n-       * @param c A character to the locale-specific character set.\n-       *\n-       * @returns the locale-specific lower-case equivalent of c.\n-       * @throws std::bad_cast if the imbued locale does not support the ctype\n-       *         facet.\n-       */\n-      char_type\n-      translate_nocase(char_type __c) const\n-      {\n-\tusing std::ctype;\n-\tusing std::use_facet;\n-\treturn use_facet<ctype<char_type> >(_M_locale).tolower(__c);\n-      }\n-      \n-      /**\n-       * @brief Gets a sort key for a character sequence.\n-       *\n-       * @param first beginning of the character sequence.\n-       * @param last  one-past-the-end of the character sequence.\n-       *\n-       * Returns a sort key for the character sequence designated by the\n-       * iterator range [F1, F2) such that if the character sequence [G1, G2)\n-       * sorts before the character sequence [H1, H2) then\n-       * v.transform(G1, G2) < v.transform(H1, H2).\n-       *\n-       * What this really does is provide a more efficient way to compare a\n-       * string to multiple other strings in locales with fancy collation\n-       * rules and equivalence classes.\n-       *\n-       * @returns a locale-specific sort key equivalent to the input range.\n-       *\n-       * @throws std::bad_cast if the current locale does not have a collate\n-       *         facet.\n-       */\n-      template<typename _Fwd_iter>\n-        string_type\n-        transform(_Fwd_iter __first, _Fwd_iter __last) const\n-        {\n-\t  using std::collate;\n-\t  using std::use_facet;\n-\t  const collate<_Ch_type>& __c(use_facet<\n-\t\t\t\t       collate<_Ch_type> >(_M_locale));\n-\t  string_type __s(__first, __last);\n-\t  return __c.transform(__s.data(), __s.data() + __s.size());\n-\t}\n-\n-      /**\n-       * @brief Dunno.\n-       *\n-       * @param first beginning of the character sequence.\n-       * @param last  one-past-the-end of the character sequence.\n-       *\n-       * Effects: if typeid(use_facet<collate<_Ch_type> >) ==\n-       * typeid(collate_byname<_Ch_type>) and the form of the sort key\n-       * returned by collate_byname<_Ch_type>::transform(first, last) is known\n-       * and can be converted into a primary sort key then returns that key,\n-       * otherwise returns an empty string. WTF??\n-       *\n-       * @todo Implement this function.\n-       */\n-      template<typename _Fwd_iter>\n-        string_type\n-        transform_primary(_Fwd_iter __first, _Fwd_iter __last) const\n-        { return string_type(); }\n-\n-      /**\n-       * @breief Gets a collation element by name.\n-       *\n-       * @param first beginning of the collation element name.\n-       * @param last  one-past-the-end of the collation element name.\n-       * \n-       * @returns a sequence of one or more characters that represents the\n-       * collating element consisting of the character sequence designated by\n-       * the iterator range [first, last). Returns an empty string if the\n-       * character sequence is not a valid collating element.\n-       *\n-       * @todo Implement this function.\n-       */\n-      template<typename _Fwd_iter>\n-        string_type\n-        lookup_collatename(_Fwd_iter __first, _Fwd_iter __last) const\n-        { return string_type(); }\n-\n-      /**\n-       * @brief Maps one or mire characters to a named character\n-       *        classification.\n-       *\n-       * @param first beginning of the character sequence.\n-       * @param last  one-past-the-end of the character sequence.\n-       *\n-       * @returns an unspecified value that represents the character\n-       * classification named by the character sequence designated by the\n-       * iterator range [first, last). The value returned shall be independent\n-       * of the case of the characters in the character sequence. If the name\n-       * is not recognized then returns a value that compares equal to 0.\n-       *\n-       * At least the following names (or their wide-character equivalent) are\n-       * supported.\n-       * - d\n-       * - w\n-       * - s\n-       * - alnum\n-       * - alpha\n-       * - blank\n-       * - cntrl\n-       * - digit\n-       * - graph\n-       * - lower\n-       * - print\n-       * - punct\n-       * - space\n-       * - upper\n-       * - xdigit\n-       *\n-       * @todo Implement this function.\n-       */\n-      template<typename _Fwd_iter>\n-        char_class_type\n-        lookup_classname(_Fwd_iter __first, _Fwd_iter __last) const\n-        { return 0; }\n-\n-      /**\n-       * @brief Determines if @p c is a member of an identified class.\n-       *\n-       * @param c a character.\n-       * @param f a class type (as returned from lookup_classname).\n-       *\n-       * @returns true if the character @p c is a member of the classification\n-       * represented by @p f, false otherwise.\n-       *\n-       * @throws std::bad_cast if the current locale does not have a ctype\n-       *         facet.\n-       */\n-      bool\n-      isctype(_Ch_type __c, char_class_type __f) const\n-      {\n-\tusing std::ctype;\n-\tusing std::use_facet;\n-\tconst ctype<_Ch_type>& __ctype(use_facet<\n-\t\t\t\t       ctype<_Ch_type> >(_M_locale));\n-\t\n-\tif (__ctype.is(__c, __f))\n-\t  return true;\n-\t\n-\t// special case of underscore in [[:w:]]\n-\tif (__c == __ctype.widen('_'))\n-\t  {\n-\t    const char* const __wb[] = \"w\";\n-\t    char_class_type __wt = this->lookup_classname(__wb,\n-\t\t\t\t\t\t\t  __wb + sizeof(__wb));\n-\t    if (__f | __wt)\n-\t      return true;\n-\t  }\n-      \n-\t// special case of [[:space:]] in [[:blank:]]\n-\tif (__c == __ctype.isspace(__c))\n-\t  {\n-\t    const char* const __bb[] = \"blank\";\n-\t    char_class_type __bt = this->lookup_classname(__bb,\n-\t\t\t\t\t\t\t  __bb + sizeof(__bb));\n-\t    if (__f | __bt)\n-\t      return true;\n-\t  }\n-\t\n-\treturn false;\n-      }\n-\n-      /**\n-       * @brief Converts a digit to an int.\n-       *\n-       * @param ch    a character representing a digit.\n-       * @param radix the radix if the numeric conversion (limited to 8, 10,\n-       *              or 16).\n-       * \n-       * @returns the value represented by the digit ch in base radix if the\n-       * character ch is a valid digit in base radix; otherwise returns -1.\n-       *\n-       * @todo Implement this function.\n-       */\n-      int\n-      value(_Ch_type __ch, int __radix) const;\n-      \n-      /**\n-       * @brief Imbues the regex_traits object with a copy of a new locale.\n-       *\n-       * @param loc A locale.\n-       *\n-       * @returns a copy of the previous locale in use by the regex_traits\n-       *          object.\n-       *\n-       * @note Calling imbue with a different locale than the one currently in\n-       *       use invalidates all cached data held by *this.\n-       */\n-      locale_type\n-      imbue(locale_type __loc)\n-      {\n-\tstd::swap(_M_locale, __loc);\n-\treturn __loc;\n-      }\n-      \n-      /**\n-       * @brief Gets a copy of the current locale in use by the regex_traits\n-       * object.\n-       */\n-      locale_type\n-      getloc() const\n-      { return _M_locale; }\n-      \n-    protected:\n-      locale_type _M_locale;\n-    };\n-\n-\n-  // [7.8] Class basic_regex\n-  /**\n-   * Objects of specializations of this class represent regular expressions\n-   * constructed from sequences of character type @p _Ch_type.\n-   *\n-   * Storage for the regular expression is allocated and deallocated as\n-   * necessary by the member functions of this class.\n-   */\n-  template<typename _Ch_type, typename _Rx_traits = regex_traits<_Ch_type> >\n-    class basic_regex\n-    {\n-    public:\n-      // types:\n-      typedef _Ch_type                              value_type;\n-      typedef regex_constants::syntax_option_type flag_type;\n-      typedef typename _Rx_traits::locale_type  locale_type;\n-      typedef typename _Rx_traits::string_type  string_type;\n-\n-      // [7.8.1] constants\n-      static const regex_constants::syntax_option_type icase\n-        = regex_constants::icase;\n-      static const regex_constants::syntax_option_type nosubs\n-        = regex_constants::nosubs;\n-      static const regex_constants::syntax_option_type optimize\n-        = regex_constants::optimize;\n-      static const regex_constants::syntax_option_type collate\n-        = regex_constants::collate;\n-      static const regex_constants::syntax_option_type ECMAScript\n-        = regex_constants::ECMAScript;\n-      static const regex_constants::syntax_option_type basic\n-        = regex_constants::basic;\n-      static const regex_constants::syntax_option_type extended\n-        = regex_constants::extended;\n-      static const regex_constants::syntax_option_type awk\n-        = regex_constants::awk;\n-      static const regex_constants::syntax_option_type grep\n-        = regex_constants::grep;\n-      static const regex_constants::syntax_option_type egrep\n-        = regex_constants::egrep;\n-\n-      // [7.8.2] construct/copy/destroy\n-      /**\n-       * Constructs a basic regular expression that does not match any\n-       * character sequence.\n-       */\n-      basic_regex()\n-      : _M_flags(regex_constants::ECMAScript), _M_pattern(), _M_mark_count(0)\n-      { _M_compile(); }\n-\n-      /**\n-       * @brief Constructs a basic regular expression from the sequence\n-       * [p, p + char_traits<_Ch_type>::length(p)) interpreted according to the\n-       * flags in @p f.\n-       *\n-       * @param p A pointer to the start of a C-style null-terminated string\n-       *          containing a regular expression.\n-       * @param f Flags indicating the syntax rules and options.\n-       *\n-       * @throws regex_error if @p p is not a valid regular expression.\n-       */\n-      explicit\n-      basic_regex(const _Ch_type* __p,\n-\t\t  flag_type __f = regex_constants::ECMAScript)\n-      : _M_flags(__f), _M_pattern(__p), _M_mark_count(0)\n-      { _M_compile(); }\n-\n-      /**\n-       * @brief Constructs a basic regular expression from the sequence\n-       * [p, p + len) interpreted according to the flags in @p f.\n-       *\n-       * @param p   A pointer to the start of a string containing a regular\n-       *            expression.\n-       * @param len The length of the string containing the regular expression.\n-       * @param f   Flags indicating the syntax rules and options.\n-       *\n-       * @throws regex_error if @p p is not a valid regular expression.\n-       */\n-      basic_regex(const _Ch_type* __p, std::size_t __len, flag_type __f)\n-      : _M_flags(__f) , _M_pattern(__p, __len), _M_mark_count(0)\n-      { _M_compile(); }\n-\n-      /**\n-       * @brief Copy-contructs a basic regular expression.\n-       *\n-       * @param rhs A @p regex object.\n-     */\n-      basic_regex(const basic_regex& __rhs)\n-      : _M_flags(__rhs._M_flags), _M_pattern(__rhs._M_pattern),\n-\t_M_mark_count(__rhs._M_mark_count)\n-      { _M_compile(); }\n-\n-      /**\n-       * @brief Constructs a basic regular expression from the string\n-       * @p interpreted according to the flags in @p f.\n-       *\n-       * @param p A string containing a regular expression.\n-       * @param f Flags indicating the syntax rules and options.\n-       *\n-       * @throws regex_error if @p p is not a valid regular expression.\n-       */\n-      template<typename _Ch_traits, typename _Ch_alloc>\n-        explicit\n-        basic_regex(const basic_string<_Ch_type, _Ch_traits, _Ch_alloc>& __s,\n-\t\t    flag_type __f = regex_constants::ECMAScript)\n-\t: _M_flags(__f), _M_pattern(__s), _M_mark_count(0)\n-        { _M_compile(); }\n-\n-      /**\n-       * @brief Constructs a basic regular expression from the range\n-       * [first, last) interpreted according to the flags in @p f.\n-       *\n-       * @param first The start of arange containing a valid regular\n-       *              expression.\n-       * @param last  The end of a range containing a valid regular\n-       *              expression.\n-       * @param f     The format flags of the regular expression.\n-       *\n-       * @throws regex_error if @p p is not a valid regular expression.\n-       */\n-      template<typename _InputIterator>\n-        basic_regex(_InputIterator __first, _InputIterator __last, \n-\t\t    flag_type __f = regex_constants::ECMAScript)\n-\t: _M_flags(__f), _M_pattern(__first, __last), _M_mark_count(0)\n-        { _M_compile(); }\n-\n-      /**\n-       * @brief Destroys a basic regular expression.\n-       */\n-      ~basic_regex()\n-      { }\n-      \n-      /**\n-       * @brief Assigns one regular expression to another.\n-       */\n-      basic_regex&\n-      operator=(const basic_regex& __rhs)\n-      { return this->assign(__rhs); }\n-\n-      /**\n-       * @brief Replaces a regular expression with a new one constructed from\n-       * a C-style null-terminated string.\n-       *\n-       * @param A pointer to the start of a null-terminated C-style string\n-       *        containing a regular expression.\n-       */\n-      basic_regex&\n-      operator=(const _Ch_type* __p)\n-      { return this->assign(__p, flags()); }\n-      \n-      /**\n-       * @brief Replaces a regular expression with a new one constructed from\n-       * a string.\n-       *\n-       * @param A pointer to a string containing a regular expression.\n-       */\n-      template<typename _Ch_typeraits, typename _Allocator>\n-        basic_regex&\n-        operator=(const basic_string<_Ch_type, _Ch_typeraits, _Allocator>& __s)\n-        { return this->assign(__s, flags()); }\n-\n-      // [7.8.3] assign\n-      /**\n-       * @brief the real assignment operator.\n-       *\n-       * @param that Another regular expression object.\n-       */\n-      basic_regex&\n-      assign(const basic_regex& __that)\n-      {\n-\tbasic_regex __tmp(__that);\n-\tthis->swap(__tmp);\n-\treturn *this;\n-      }\n-      \n-      /**\n-       * @brief Assigns a new regular expression to a regex object from a\n-       * C-style null-terminated string containing a regular expression\n-       * pattern.\n-       *\n-       * @param p     A pointer to a C-style null-terminated string containing\n-       *              a regular expression pattern.\n-       * @param flags Syntax option flags.\n-       *\n-       * @throws regex_error if p does not contain a valid regular expression\n-       * pattern interpreted according to @p flags.  If regex_error is thrown,\n-       * *this remains unchanged.\n-       */\n-      basic_regex&\n-      assign(const _Ch_type* __p,\n-\t     flag_type __flags = regex_constants::ECMAScript)\n-      { return this->assign(string_type(__p), __flags); }\n-\n-      /**\n-       * @brief Assigns a new regular expression to a regex object from a\n-       * C-style string containing a regular expression pattern.\n-       *\n-       * @param p     A pointer to a C-style string containing a\n-       *              regular expression pattern.\n-       * @param len   The length of the regular expression pattern string.\n-       * @param flags Syntax option flags.\n-       *\n-       * @throws regex_error if p does not contain a valid regular expression\n-       * pattern interpreted according to @p flags.  If regex_error is thrown,\n-       * *this remains unchanged.\n-       */\n-      basic_regex&\n-      assign(const _Ch_type* __p, std::size_t __len, flag_type __flags)\n-      { return this->assign(string_type(__p, __len), __flags); }\n-\n-      /**\n-       * @brief Assigns a new regular expression to a regex object from a \n-       * string containing a regular expression pattern.\n-       *\n-       * @param s     A string containing a regular expression pattern.\n-       * @param flags Syntax option flags.\n-       *\n-       * @throws regex_error if p does not contain a valid regular expression\n-       * pattern interpreted according to @p flags.  If regex_error is thrown,\n-       * *this remains unchanged.\n-       */\n-      template<typename _Ch_typeraits, typename _Allocator>\n-        basic_regex&\n-        assign(const basic_string<_Ch_type, _Ch_typeraits, _Allocator>& __s,\n-\t       flag_type __f = regex_constants::ECMAScript)\n-        { \n-\t  basic_regex __tmp(__s, __f);\n-\t  this->swap(__tmp);\n-\t  return *this;\n-\t}\n-\n-      /**\n-       * @brief Assigns a new regular expression to a regex object.\n-       *\n-       * @param first The start of a range containing a valid regular\n-       *              expression.\n-       * @param last  The end of a range containing a valid regular\n-       *              expression.\n-       * @param flags Syntax option flags.\n-       *\n-       * @throws regex_error if p does not contain a valid regular expression\n-       * pattern interpreted according to @p flags.  If regex_error is thrown,\n-       * *this remains unchanged.\n-       */\n-      template<typename _InputIterator>\n-        basic_regex&\n-        assign(_InputIterator __first, _InputIterator __last,\n-\t       flag_type __flags = regex_constants::ECMAScript)\n-        { return this->assign(string_type(__first, __last), __flags); }\n-\n-      // [7.8.4] const operations\n-      /**\n-       * @brief Gets the number of marked subexpressions within the regular\n-       * expresison.\n-       */\n-      unsigned int\n-      mark_count() const\n-      { return _M_mark_count; }\n-      \n-      /**\n-       * @brief Gets the flags used to construct the regular expression\n-       * or in the last call to assign().\n-       */\n-      flag_type\n-      flags() const\n-      { return _M_flags; }\n-      \n-      // [7.8.5] locale\n-      /**\n-       * @brief Imbues the regular expression object with the given locale.\n-       *\n-       * @param loc A locale.\n-       */\n-      locale_type\n-      imbue(locale_type __loc)\n-      { return _M_traits.imbue(__loc); }\n-      \n-      /**\n-       * @brief Gets the locale currently imbued in the regular expression\n-       *        object.\n-       */\n-      locale_type\n-      getloc() const\n-      { return _M_traits.getloc(); }\n-      \n-      // [7.8.6] swap\n-      /**\n-       * @brief Swaps the contents of two regular expression obects.\n-       *\n-       * @param rhs Another regular expression object.\n-       */\n-      void\n-      swap(basic_regex& __rhs)\n-      {\n-\tstd::swap(_M_flags,      __rhs._M_flags);\n-\tstd::swap(_M_pattern,    __rhs._M_pattern);\n-\tstd::swap(_M_mark_count, __rhs._M_mark_count);\n-\tstd::swap(_M_traits,     __rhs._M_traits);\n-      }\n-      \n-    private:\n-      /**\n-       * @brief Compiles a regular expression pattern into a NFA.\n-       * @todo Implement this function.\n-       */\n-      void _M_compile()\n-      { }\n-\n-    protected:\n-      flag_type    _M_flags;\n-      string_type  _M_pattern;\n-      unsigned int _M_mark_count;\n-      _Rx_traits   _M_traits;\n-    };\n-  \n-  typedef basic_regex<char>    regex;\n-#ifdef _GLIBCXX_USE_WCHAR_T\n-  typedef basic_regex<wchar_t> wregex;\n-#endif\n-\n-\n-  // [7.8.6] basic_regex swap\n-  /**\n-   * @brief Swaps the contents of two regular expression objects.\n-   * @param lhs First regular expression.\n-   * @param rhs Second regular expression.\n-   */\n-  template<typename _Ch_type, typename _Rx_traits>\n-    inline void\n-    swap(basic_regex<_Ch_type, _Rx_traits>& __lhs,\n-\t basic_regex<_Ch_type, _Rx_traits>& __rhs)\n-    { return __lhs.swap(__rhs); }\n-\n-\n-  // [7.9] Class template sub_match\n-  /**\n-   * A sequence of characters matched by a particular marked sub-expression.\n-   *\n-   * An object of this class is essentially a pair of iterators marking a\n-   * matched subexpression within a regular expression pattern match. Such\n-   * objects can be converted to and compared with std::basic_string objects\n-   * of a similar base character type as the pattern matched by the regular\n-   * expression.\n-   *\n-   * The iterators that make up the pair are the usual half-open interval\n-   * referencing the actual original pattern matched.\n-   */\n-  template<typename _BiIter>\n-    class sub_match : public std::pair<_BiIter, _BiIter>\n-    {\n-    public:\n-      typedef typename iterator_traits<_BiIter>::value_type      value_type;\n-      typedef typename iterator_traits<_BiIter>::difference_type\n-                                                            difference_type;\n-      typedef _BiIter                                              iterator;\n-\n-    public:\n-      bool matched;\n-      \n-      /**\n-       * Gets the length of the matching sequence.\n-       */\n-      difference_type\n-      length() const\n-      { return this->matched ? std::distance(this->first, this->second) : 0; }\n-\n-      /**\n-       * @brief Gets the matching sequence as a string.\n-       *\n-       * @returns the matching sequence as a string.\n-       *\n-       * This is the implicit conversion operator.  It is identical to the\n-       * str() member function except that it will want to pop up in\n-       * unexpected places and cause a great deal of confusion and cursing\n-       * from the unwary.\n-       */\n-      operator basic_string<value_type>() const\n-      {\n-\treturn this->matched\n-\t  ? std::basic_string<value_type>(this->first, this->second)\n-\t  : std::basic_string<value_type>();\n-      }\n-      \n-      /**\n-       * @brief Gets the matching sequence as a string.\n-       *\n-       * @returns the matching sequence as a string.\n-       */\n-      basic_string<value_type>\n-      str() const\n-      {\n-\treturn this->matched\n-\t  ? std::basic_string<value_type>(this->first, this->second)\n-\t  : std::basic_string<value_type>();\n-      }\n-      \n-      /**\n-       * @brief Compares this and another matched sequence.\n-       *\n-       * @param s Another matched sequence to compare to this one.\n-       *\n-       * @retval <0 this matched sequence will collate before @p s.\n-       * @retval =0 this matched sequence is equivalent to @p s.\n-       * @retval <0 this matched sequence will collate after @p s.\n-       */\n-      int\n-      compare(const sub_match& __s) const\n-      { return this->str().compare(__s.str()); }\n-\n-      /**\n-       * @brief Compares this sub_match to a string.\n-       *\n-       * @param s A string to compare to this sub_match.\n-       *\n-       * @retval <0 this matched sequence will collate before @p s.\n-       * @retval =0 this matched sequence is equivalent to @p s.\n-       * @retval <0 this matched sequence will collate after @p s.\n-       */\n-      int\n-      compare(const basic_string<value_type>& __s) const\n-      { return this->str().compare(__s); }\n-      \n-      /**\n-       * @brief Compares this sub_match to a C-style string.\n-       *\n-       * @param s A C-style string to compare to this sub_match.\n-       *\n-       * @retval <0 this matched sequence will collate before @p s.\n-       * @retval =0 this matched sequence is equivalent to @p s.\n-       * @retval <0 this matched sequence will collate after @p s.\n-       */\n-      int\n-      compare(const value_type* __s) const\n-      { return this->str().compare(__s); }\n-    };\n-  \n-  \n-  typedef sub_match<const char*>             csub_match;\n-  typedef sub_match<string::const_iterator>  ssub_match;\n-#ifdef _GLIBCXX_USE_WCHAR_T\n-  typedef sub_match<const wchar_t*>          wcsub_match;\n-  typedef sub_match<wstring::const_iterator> wssub_match;\n-#endif\n-\n-  // [7.9.2] sub_match non-member operators\n-  \n-  /**\n-   * @brief Tests the equivalence of two regular expression submatches.\n-   * @param lhs First regular expression submatch.\n-   * @param rhs Second regular expression submatch.\n-   * @returns true if @a lhs  is equivalent to @a rhs, false otherwise.\n-   */\n-  template<typename _BiIter>\n-    inline bool\n-    operator==(const sub_match<_BiIter>& __lhs,\n-\t       const sub_match<_BiIter>& __rhs)\n-    { return __lhs.compare(__rhs) == 0; }\n-\n-  /**\n-   * @brief Tests the inequivalence of two regular expression submatches.\n-   * @param lhs First regular expression submatch.\n-   * @param rhs Second regular expression submatch.\n-   * @returns true if @a lhs  is not equivalent to @a rhs, false otherwise.\n-   */\n-  template<typename _BiIter>\n-    inline bool\n-    operator!=(const sub_match<_BiIter>& __lhs,\n-\t       const sub_match<_BiIter>& __rhs)\n-    { return __lhs.compare(__rhs) != 0; }\n-\n-  /**\n-   * @brief Tests the ordering of two regular expression submatches.\n-   * @param lhs First regular expression submatch.\n-   * @param rhs Second regular expression submatch.\n-   * @returns true if @a lhs precedes @a rhs, false otherwise.\n-   */\n-  template<typename _BiIter>\n-    inline bool\n-    operator<(const sub_match<_BiIter>& __lhs,\n-\t      const sub_match<_BiIter>& __rhs)\n-    { return __lhs.compare(__rhs) < 0; }\n-\n-  /**\n-   * @brief Tests the ordering of two regular expression submatches.\n-   * @param lhs First regular expression submatch.\n-   * @param rhs Second regular expression submatch.\n-   * @returns true if @a lhs does not succeed @a rhs, false otherwise.\n-   */\n-  template<typename _BiIter>\n-    inline bool\n-    operator<=(const sub_match<_BiIter>& __lhs,\n-\t       const sub_match<_BiIter>& __rhs)\n-    { return __lhs.compare(__rhs) <= 0; }\n-\n-  /**\n-   * @brief Tests the ordering of two regular expression submatches.\n-   * @param lhs First regular expression submatch.\n-   * @param rhs Second regular expression submatch.\n-   * @returns true if @a lhs does not preceed @a rhs, false otherwise.\n-   */\n-  template<typename _BiIter>\n-    inline bool\n-    operator>=(const sub_match<_BiIter>& __lhs,\n-\t       const sub_match<_BiIter>& __rhs)\n-    { return __lhs.compare(__rhs) >= 0; }\n-\n-  /**\n-   * @brief Tests the ordering of two regular expression submatches.\n-   * @param lhs First regular expression submatch.\n-   * @param rhs Second regular expression submatch.\n-   * @returns true if @a lhs succeeds @a rhs, false otherwise.\n-   */\n-  template<typename _BiIter>\n-    inline bool\n-    operator>(const sub_match<_BiIter>& __lhs,\n-\t      const sub_match<_BiIter>& __rhs)\n-    { return __lhs.compare(__rhs) > 0; }\n-\n-  /**\n-   * @brief Tests the equivalence of a string and a regular expression\n-   *        submatch.\n-   * @param lhs A string.\n-   * @param rhs A regular expression submatch.\n-   * @returns true if @a lhs  is equivalent to @a rhs, false otherwise.\n-   */\n-  template<typename _Bi_iter, typename _Ch_traits, typename _Ch_alloc>\n-    inline bool\n-    operator==(const basic_string<\n-\t       typename iterator_traits<_Bi_iter>::value_type,\n-\t       _Ch_traits, _Ch_alloc>& __lhs,\n-\t       const sub_match<_Bi_iter>& __rhs)\n-    { return __lhs == __rhs.str(); }\n-\n-  /**\n-   * @brief Tests the inequivalence of a string and a regular expression\n-   *        submatch.\n-   * @param lhs A string.\n-   * @param rhs A regular expression submatch.\n-   * @returns true if @a lhs  is not equivalent to @a rhs, false otherwise.\n-   */\n-  template<typename _Bi_iter, typename _Ch_traits, typename _Ch_alloc>\n-    inline bool\n-    operator!=(const basic_string<\n-\t       typename iterator_traits<_Bi_iter>::value_type,\n-\t       _Ch_traits, _Ch_alloc>& __lhs, const sub_match<_Bi_iter>& __rhs)\n-    { return __lhs != __rhs.str(); }\n-\n-  /**\n-   * @brief Tests the ordering of a string and a regular expression submatch.\n-   * @param lhs A string.\n-   * @param rhs A regular expression submatch.\n-   * @returns true if @a lhs precedes @a rhs, false otherwise.\n-   */\n-  template<typename _Bi_iter, typename _Ch_traits, typename _Ch_alloc>\n-    inline bool\n-    operator<(const basic_string<\n-\t      typename iterator_traits<_Bi_iter>::value_type,\n-\t      _Ch_traits, _Ch_alloc>& __lhs, const sub_match<_Bi_iter>& __rhs)\n-     { return __lhs < __rhs.str(); }\n-\n-  /**\n-   * @brief Tests the ordering of a string and a regular expression submatch.\n-   * @param lhs A string.\n-   * @param rhs A regular expression submatch.\n-   * @returns true if @a lhs succeeds @a rhs, false otherwise.\n-   */\n-  template<typename _Bi_iter, typename _Ch_traits, typename _Ch_alloc>\n-    inline bool\n-    operator>(const basic_string<\n-\t      typename iterator_traits<_Bi_iter>::value_type, \n-\t      _Ch_traits, _Ch_alloc>& __lhs, const sub_match<_Bi_iter>& __rhs)\n-    { return __lhs > __rhs.str(); }\n-\n-  /**\n-   * @brief Tests the ordering of a string and a regular expression submatch.\n-   * @param lhs A string.\n-   * @param rhs A regular expression submatch.\n-   * @returns true if @a lhs does not preceed @a rhs, false otherwise.\n-   */\n-  template<typename _Bi_iter, typename _Ch_traits, typename _Ch_alloc>\n-    inline bool\n-    operator>=(const basic_string<\n-\t       typename iterator_traits<_Bi_iter>::value_type,\n-\t       _Ch_traits, _Ch_alloc>& __lhs, const sub_match<_Bi_iter>& __rhs)\n-    { return __lhs >= __rhs.str(); }\n-\n-  /**\n-   * @brief Tests the ordering of a string and a regular expression submatch.\n-   * @param lhs A string.\n-   * @param rhs A regular expression submatch.\n-   * @returns true if @a lhs does not succeed @a rhs, false otherwise.\n-   */\n-  template<typename _Bi_iter, typename _Ch_traits, typename _Ch_alloc>\n-    inline bool\n-    operator<=(const basic_string<\n-\t       typename iterator_traits<_Bi_iter>::value_type,\n-\t       _Ch_traits, _Ch_alloc>& __lhs, const sub_match<_Bi_iter>& __rhs)\n-    { return __lhs <= __rhs.str(); }\n-\n-  /**\n-   * @brief Tests the equivalence of a regular expression submatch and a\n-   *        string.\n-   * @param lhs A regular expression submatch.\n-   * @param rhs A string.\n-   * @returns true if @a lhs is equivalent to @a rhs, false otherwise.\n-   */\n-  template<typename _Bi_iter, typename _Ch_traits, typename _Ch_alloc>\n-    inline bool\n-    operator==(const sub_match<_Bi_iter>& __lhs,\n-\t       const basic_string<\n-\t       typename iterator_traits<_Bi_iter>::value_type,\n-\t       _Ch_traits, _Ch_alloc>& __rhs)\n-    { return __lhs.str() == __rhs; }\n-\n-  /**\n-   * @brief Tests the inequivalence of a regular expression submatch and a\n-   *        string.\n-   * @param lhs A regular expression submatch.\n-   * @param rhs A string.\n-   * @returns true if @a lhs is not equivalent to @a rhs, false otherwise.\n-   */\n-  template<typename _Bi_iter, typename _Ch_traits, typename _Ch_alloc>\n-    inline bool\n-    operator!=(const sub_match<_Bi_iter>& __lhs,\n-\t       const basic_string<\n-\t       typename iterator_traits<_Bi_iter>::value_type,\n-\t       _Ch_traits, _Ch_alloc>& __rhs)\n-    { return __lhs.str() != __rhs; }\n-\n-  /**\n-   * @brief Tests the ordering of a regular expression submatch and a string.\n-   * @param lhs A regular expression submatch.\n-   * @param rhs A string.\n-   * @returns true if @a lhs precedes @a rhs, false otherwise.\n-   */\n-  template<typename _Bi_iter, class _Ch_traits, class _Ch_alloc>\n-    inline bool\n-    operator<(const sub_match<_Bi_iter>& __lhs,\n-\t      const basic_string<\n-\t      typename iterator_traits<_Bi_iter>::value_type,\n-\t      _Ch_traits, _Ch_alloc>& __rhs)\n-    { return __lhs.str() < __rhs; }\n-\n-  /**\n-   * @brief Tests the ordering of a regular expression submatch and a string.\n-   * @param lhs A regular expression submatch.\n-   * @param rhs A string.\n-   * @returns true if @a lhs succeeds @a rhs, false otherwise.\n-   */\n-  template<typename _Bi_iter, class _Ch_traits, class _Ch_alloc>\n-    inline bool\n-    operator>(const sub_match<_Bi_iter>& __lhs,\n-\t      const basic_string<\n-\t      typename iterator_traits<_Bi_iter>::value_type,\n-\t      _Ch_traits, _Ch_alloc>& __rhs)\n-    { return __lhs.str() > __rhs; }\n-\n-  /**\n-   * @brief Tests the ordering of a regular expression submatch and a string.\n-   * @param lhs A regular expression submatch.\n-   * @param rhs A string.\n-   * @returns true if @a lhs does not preceed @a rhs, false otherwise.\n-   */\n-  template<typename _Bi_iter, class _Ch_traits, class _Ch_alloc>\n-    inline bool\n-    operator>=(const sub_match<_Bi_iter>& __lhs,\n-\t       const basic_string<\n-\t       typename iterator_traits<_Bi_iter>::value_type,\n-\t       _Ch_traits, _Ch_alloc>& __rhs)\n-    { return __lhs.str() >= __rhs; }\n-\n-  /**\n-   * @brief Tests the ordering of a regular expression submatch and a string.\n-   * @param lhs A regular expression submatch.\n-   * @param rhs A string.\n-   * @returns true if @a lhs does not succeed @a rhs, false otherwise.\n-   */\n-  template<typename _Bi_iter, class _Ch_traits, class _Ch_alloc>\n-    inline bool\n-    operator<=(const sub_match<_Bi_iter>& __lhs,\n-\t       const basic_string<\n-\t       typename iterator_traits<_Bi_iter>::value_type,\n-\t       _Ch_traits, _Ch_alloc>& __rhs)\n-    { return __lhs.str() <= __rhs; }\n-\n-  /**\n-   * @brief Tests the equivalence of a C string and a regular expression\n-   *        submatch.\n-   * @param lhs A C string.\n-   * @param rhs A regular expression submatch.\n-   * @returns true if @a lhs  is equivalent to @a rhs, false otherwise.\n-   */\n-  template<typename _Bi_iter>\n-    inline bool\n-    operator==(typename iterator_traits<_Bi_iter>::value_type const* __lhs,\n-\t       const sub_match<_Bi_iter>& __rhs)\n-    { return __lhs == __rhs.str(); }\n-\n-  /**\n-   * @brief Tests the inequivalence of an iterator value and a regular\n-   *        expression submatch.\n-   * @param lhs A regular expression submatch.\n-   * @param rhs A string.\n-   * @returns true if @a lhs is not equivalent to @a rhs, false otherwise.\n-   */\n-  template<typename _Bi_iter>\n-    inline bool\n-    operator!=(typename iterator_traits<_Bi_iter>::value_type const* __lhs,\n-\t       const sub_match<_Bi_iter>& __rhs)\n-    { return __lhs != __rhs.str(); }\n-\n-  /**\n-   * @brief Tests the ordering of a string and a regular expression submatch.\n-   * @param lhs A string.\n-   * @param rhs A regular expression submatch.\n-   * @returns true if @a lhs precedes @a rhs, false otherwise.\n-   */\n-  template<typename _Bi_iter>\n-    inline bool\n-    operator<(typename iterator_traits<_Bi_iter>::value_type const* __lhs,\n-\t      const sub_match<_Bi_iter>& __rhs)\n-    { return __lhs < __rhs.str(); }\n-\n-  /**\n-   * @brief Tests the ordering of a string and a regular expression submatch.\n-   * @param lhs A string.\n-   * @param rhs A regular expression submatch.\n-   * @returns true if @a lhs succeeds @a rhs, false otherwise.\n-   */\n-  template<typename _Bi_iter>\n-    inline bool\n-    operator>(typename iterator_traits<_Bi_iter>::value_type const* __lhs,\n-\t      const sub_match<_Bi_iter>& __rhs)\n-    { return __lhs > __rhs.str(); }\n-\n-  /**\n-   * @brief Tests the ordering of a string and a regular expression submatch.\n-   * @param lhs A string.\n-   * @param rhs A regular expression submatch.\n-   * @returns true if @a lhs does not preceed @a rhs, false otherwise.\n-   */\n-  template<typename _Bi_iter>\n-    inline bool\n-    operator>=(typename iterator_traits<_Bi_iter>::value_type const* __lhs,\n-\t       const sub_match<_Bi_iter>& __rhs)\n-    { return __lhs >= __rhs.str(); }\n-\n-  /**\n-   * @brief Tests the ordering of a string and a regular expression submatch.\n-   * @param lhs A string.\n-   * @param rhs A regular expression submatch.\n-   * @returns true if @a lhs does not succeed @a rhs, false otherwise.\n-   */\n-  template<typename _Bi_iter>\n-    inline bool\n-    operator<=(typename iterator_traits<_Bi_iter>::value_type const* __lhs,\n-\t       const sub_match<_Bi_iter>& __rhs)\n-    { return __lhs <= __rhs.str(); }\n-\n-  /**\n-   * @brief Tests the equivalence of a regular expression submatch and a\n-   *        string.\n-   * @param lhs A regular expression submatch.\n-   * @param rhs A pointer to a string?\n-   * @returns true if @a lhs  is equivalent to @a rhs, false otherwise.\n-   */\n-  template<typename _Bi_iter>\n-    inline bool\n-    operator==(const sub_match<_Bi_iter>& __lhs,\n-\t       typename iterator_traits<_Bi_iter>::value_type const* __rhs)\n-    { return __lhs.str() == __rhs; }\n-\n-  /**\n-   * @brief Tests the inequivalence of a regular expression submatch and a\n-   *        string.\n-   * @param lhs A regular expression submatch.\n-   * @param rhs A pointer to a string.\n-   * @returns true if @a lhs is not equivalent to @a rhs, false otherwise.\n-   */\n-  template<typename _Bi_iter>\n-    inline bool\n-    operator!=(const sub_match<_Bi_iter>& __lhs,\n-\t       typename iterator_traits<_Bi_iter>::value_type const* __rhs)\n-    { return __lhs.str() != __rhs; }\n-\n-  /**\n-   * @brief Tests the ordering of a regular expression submatch and a string.\n-   * @param lhs A regular expression submatch.\n-   * @param rhs A string.\n-   * @returns true if @a lhs precedes @a rhs, false otherwise.\n-   */\n-  template<typename _Bi_iter>\n-    inline bool\n-    operator<(const sub_match<_Bi_iter>& __lhs,\n-\t      typename iterator_traits<_Bi_iter>::value_type const* __rhs)\n-    { return __lhs.str() < __rhs; }\n-\n-  /**\n-   * @brief Tests the ordering of a regular expression submatch and a string.\n-   * @param lhs A regular expression submatch.\n-   * @param rhs A string.\n-   * @returns true if @a lhs succeeds @a rhs, false otherwise.\n-   */\n-  template<typename _Bi_iter>\n-    inline bool\n-    operator>(const sub_match<_Bi_iter>& __lhs,\n-\t      typename iterator_traits<_Bi_iter>::value_type const* __rhs)\n-    { return __lhs.str() > __rhs; }\n-\n-  /**\n-   * @brief Tests the ordering of a regular expression submatch and a string.\n-   * @param lhs A regular expression submatch.\n-   * @param rhs A string.\n-   * @returns true if @a lhs does not precede @a rhs, false otherwise.\n-   */\n-  template<typename _Bi_iter>\n-    inline bool\n-    operator>=(const sub_match<_Bi_iter>& __lhs,\n-\t       typename iterator_traits<_Bi_iter>::value_type const* __rhs)\n-    { return __lhs.str() >= __rhs; }\n-\n-  /**\n-   * @brief Tests the ordering of a regular expression submatch and a string.\n-   * @param lhs A regular expression submatch.\n-   * @param rhs A string.\n-   * @returns true if @a lhs does not succeed @a rhs, false otherwise.\n-   */\n-  template<typename _Bi_iter>\n-    inline bool\n-    operator<=(const sub_match<_Bi_iter>& __lhs,\n-\t       typename iterator_traits<_Bi_iter>::value_type const* __rhs)\n-    { return __lhs.str() <= __rhs; }\n-\n-  /**\n-   * @brief Tests the equivalence of a string and a regular expression\n-   *        submatch.\n-   * @param lhs A string.\n-   * @param rhs A regular expression submatch.\n-   * @returns true if @a lhs is equivalent to @a rhs, false otherwise.\n-   */\n-  template<typename _Bi_iter>\n-    inline bool\n-    operator==(typename iterator_traits<_Bi_iter>::value_type const& __lhs,\n-\t       const sub_match<_Bi_iter>& __rhs)\n-    { return __lhs == __rhs.str(); }\n-\n-  /**\n-   * @brief Tests the inequivalence of a string and a regular expression\n-   *        submatch.\n-   * @param lhs A string.\n-   * @param rhs A regular expression submatch.\n-   * @returns true if @a lhs is not equivalent to @a rhs, false otherwise.\n-   */\n-  template<typename _Bi_iter>\n-    inline bool\n-    operator!=(typename iterator_traits<_Bi_iter>::value_type const& __lhs,\n-\t       const sub_match<_Bi_iter>& __rhs)\n-    { return __lhs != __rhs.str(); }\n-\n-  /**\n-   * @brief Tests the ordering of a string and a regular expression submatch.\n-   * @param lhs A string.\n-   * @param rhs A regular expression submatch.\n-   * @returns true if @a lhs precedes @a rhs, false otherwise.\n-   */\n-  template<typename _Bi_iter>\n-    inline bool\n-    operator<(typename iterator_traits<_Bi_iter>::value_type const& __lhs,\n-\t      const sub_match<_Bi_iter>& __rhs)\n-    { return __lhs < __rhs.str(); }\n-\n-  /**\n-   * @brief Tests the ordering of a string and a regular expression submatch.\n-   * @param lhs A string.\n-   * @param rhs A regular expression submatch.\n-   * @returns true if @a lhs succeeds @a rhs, false otherwise.\n-   */\n-  template<typename _Bi_iter>\n-    inline bool\n-    operator>(typename iterator_traits<_Bi_iter>::value_type const& __lhs,\n-\t      const sub_match<_Bi_iter>& __rhs)\n-    { return __lhs > __rhs.str(); }\n-\n-  /**\n-   * @brief Tests the ordering of a string and a regular expression submatch.\n-   * @param lhs A string.\n-   * @param rhs A regular expression submatch.\n-   * @returns true if @a lhs does not preceed @a rhs, false otherwise.\n-   */\n-  template<typename _Bi_iter>\n-    inline bool\n-    operator>=(typename iterator_traits<_Bi_iter>::value_type const& __lhs,\n-\t       const sub_match<_Bi_iter>& __rhs)\n-    { return __lhs >= __rhs.str(); }\n-\n-  /**\n-   * @brief Tests the ordering of a string and a regular expression submatch.\n-   * @param lhs A string.\n-   * @param rhs A regular expression submatch.\n-   * @returns true if @a lhs does not succeed @a rhs, false otherwise.\n-   */\n-  template<typename _Bi_iter>\n-    inline bool\n-    operator<=(typename iterator_traits<_Bi_iter>::value_type const& __lhs,\n-\t       const sub_match<_Bi_iter>& __rhs)\n-    { return __lhs <= __rhs.str(); }\n-\n-  /**\n-   * @brief Tests the equivalence of a regular expression submatch and a\n-   *        string.\n-   * @param lhs A regular expression submatch.\n-   * @param rhs A const string reference.\n-   * @returns true if @a lhs  is equivalent to @a rhs, false otherwise.\n-   */\n-  template<typename _Bi_iter>\n-    inline bool\n-    operator==(const sub_match<_Bi_iter>& __lhs,\n-\t       typename iterator_traits<_Bi_iter>::value_type const& __rhs)\n-    { return __lhs.str() == __rhs; }\n-\n-  /**\n-   * @brief Tests the inequivalence of a regular expression submatch and a\n-   *        string.\n-   * @param lhs A regular expression submatch.\n-   * @param rhs A const string reference.\n-   * @returns true if @a lhs is not equivalent to @a rhs, false otherwise.\n-   */\n-  template<typename _Bi_iter>\n-    inline bool\n-    operator!=(const sub_match<_Bi_iter>& __lhs,\n-\t       typename iterator_traits<_Bi_iter>::value_type const& __rhs)\n-    { return __lhs.str() != __rhs; }\n-\n-  /**\n-   * @brief Tests the ordering of a regular expression submatch and a string.\n-   * @param lhs A regular expression submatch.\n-   * @param rhs A const string reference.\n-   * @returns true if @a lhs preceeds @a rhs, false otherwise.\n-   */\n-  template<typename _Bi_iter>\n-    inline bool\n-    operator<(const sub_match<_Bi_iter>& __lhs,\n-\t      typename iterator_traits<_Bi_iter>::value_type const& __rhs)\n-    { return __lhs.str() < __rhs; }\n-\n-  /**\n-   * @brief Tests the ordering of a regular expression submatch and a string.\n-   * @param lhs A regular expression submatch.\n-   * @param rhs A const string reference.\n-   * @returns true if @a lhs succeeds @a rhs, false otherwise.\n-   */\n-  template<typename _Bi_iter>\n-    inline bool\n-    operator>(const sub_match<_Bi_iter>& __lhs,\n-\t      typename iterator_traits<_Bi_iter>::value_type const& __rhs)\n-    { return __lhs.str() > __rhs; }\n-\n-  /**\n-   * @brief Tests the ordering of a regular expression submatch and a string.\n-   * @param lhs A regular expression submatch.\n-   * @param rhs A const string reference.\n-   * @returns true if @a lhs does not preceed @a rhs, false otherwise.\n-   */\n-  template<typename _Bi_iter>\n-    inline bool\n-    operator>=(const sub_match<_Bi_iter>& __lhs,\n-\t       typename iterator_traits<_Bi_iter>::value_type const& __rhs)\n-    { return __lhs.str() >= __rhs; }\n-\n-  /**\n-   * @brief Tests the ordering of a regular expression submatch and a string.\n-   * @param lhs A regular expression submatch.\n-   * @param rhs A const string reference.\n-   * @returns true if @a lhs does not succeed @a rhs, false otherwise.\n-   */\n-  template<typename _Bi_iter>\n-    inline bool\n-    operator<=(const sub_match<_Bi_iter>& __lhs,\n-\t       typename iterator_traits<_Bi_iter>::value_type const& __rhs)\n-    { return __lhs.str() <= __rhs; }\n-\n-  /**\n-   * @brief Inserts a matched string into an output stream.\n-   *\n-   * @param os The output stream.\n-   * @param m  A submatch string.\n-   *\n-   * @returns the output stream with the submatch string inserted.\n-   */\n-  template<typename _Ch_type, typename _Ch_traits, typename _Bi_iter>\n-    inline\n-    basic_ostream<_Ch_type, _Ch_traits>&\n-    operator<<(basic_ostream<_Ch_type, _Ch_traits>& __os,\n-\t       const sub_match<_Bi_iter>& __m)\n-    { return __os << __m.str(); }\n-\n-  // [7.10] Class template match_results\n-  /**\n-   * A collection of character sequences representing the result of a regular\n-   * expression match.  Storage for the collection is allocated and freed as\n-   * necessary by the member functions of class template match_results.\n-   *\n-   * This class satisfies the Sequence requirements, with the exception that\n-   * only the operations defined for a const-qualified Sequence are supported.\n-   *\n-   * The sub_match object stored at index 0 represents sub-expression 0, i.e.\n-   * the whole match. In this case the sub_match member matched is always true.\n-   * The sub_match object stored at index n denotes what matched the marked\n-   * sub-expression n within the matched expression. If the sub-expression n\n-   * participated in a regular expression match then the sub_match member\n-   * matched evaluates to true, and members first and second denote the range\n-   * of characters [first, second) which formed that match. Otherwise matched\n-   * is false, and members first and second point to the end of the sequence\n-   * that was searched.\n-   */\n-  template<typename _Bi_iter,\n-\t   typename _Allocator = allocator<sub_match<_Bi_iter> > >\n-    class match_results\n-    : private std::vector<std::_GLIBCXX_TR1::sub_match<_Bi_iter>, _Allocator>\n-    {\n-    private:\n-      typedef std::vector<std::_GLIBCXX_TR1::sub_match<_Bi_iter>, _Allocator>\n-                                                              _Base_type;\n-\n-    public:\n-      typedef sub_match<_Bi_iter>                             value_type;\n-      typedef typename _Allocator::const_reference            const_reference;\n-      typedef const_reference                                 reference;\n-      typedef typename _Base_type::const_iterator             const_iterator;\n-      typedef const_iterator                                  iterator;\n-      typedef typename iterator_traits<_Bi_iter>::difference_type\n-                                                              difference_type;\n-      typedef typename _Allocator::size_type                  size_type;\n-      typedef _Allocator                                      allocator_type;\n-      typedef typename iterator_traits<_Bi_iter>::value_type  char_type;\n-      typedef basic_string<char_type>                         string_type;\n-  \n-    public:\n-      // [7.10.1] construct/copy/destroy\n-      /**\n-       * @brief Constructs a default match_results container.\n-       */\n-      explicit\n-      match_results(const _Allocator& __a = _Allocator())\n-      : _Base_type(__a), _M_matched(false)\n-      { }\n-\n-      /**\n-       * @brief Copy constructs a match_result.\n-       */\n-      match_results(const match_results& __rhs)\n-      : _Base_type(__rhs), _M_matched(__rhs._M_matched),\n-\t_M_prefix(__rhs._M_prefix), _M_suffix(__rhs._M_suffix)\n-      { }\n-\n-      /**\n-       * @brief Assigns rhs to *this.\n-       */\n-      match_results&\n-      operator=(const match_results& __rhs)\n-      {\n-\tmatch_results __tmp(__rhs);\n-\tthis->swap(__tmp);\n-      }\n-\n-      /**\n-       * @todo Implement this function.\n-       */\n-      ~match_results()\n-      { }\n-      \n-      // [7.10.2] size\n-      /**\n-       * @todo Document this function.\n-       */\n-      size_type\n-      size() const\n-      { return _M_matched ? _Base_type::size() + 1 : 0; }\n-      \n-      /**\n-       * @todo Implement this function.\n-       */\n-      //size_type\n-      //max_size() const;\n-      using _Base_type::max_size;\n-\n-      /**\n-       * @todo Document this function.\n-       */\n-      bool\n-      empty() const\n-      { return size() == 0; }\n-      \n-      // [7.10.3] element access\n-      /**\n-       * @brief Gets the length of the indicated submatch.\n-       * @param sub indicates the submatch.\n-       */\n-      difference_type\n-      length(size_type __sub = 0) const\n-      { return _M_matched ? this->str(__sub).length() : 0; }\n-\n-      /**\n-       * @todo Document this function.\n-       */\n-      difference_type\n-      position(size_type __sub = 0) const\n-      {\n-\treturn _M_matched ? std::distance(this->prefix().first,\n-\t\t\t\t\t  (*this)[__sub].first) : 0;\n-      }\n-\n-      /**\n-       * @todo Document this function.\n-       */\n-      string_type\n-      str(size_type __sub = 0) const\n-      { return _M_matched ? (*this)[__sub].str() : string_type(); }\n-      \n-      /**\n-       * @todo Document this function.\n-       */\n-      const_reference\n-      operator[](size_type __n) const\n-      { return _Base_type::operator[](__n); }\n-\n-      /**\n-       * @todo Document this function.\n-       */\n-      const_reference\n-      prefix() const\n-      { return _M_prefix; }\n-\n-      /**\n-       * @todo Document this function.\n-       */\n-      const_reference\n-      suffix() const\n-      { return _M_suffix; }\n-\n-      /**\n-       * @todo Document this function.\n-       */\n-      const_iterator\n-      begin() const\n-      { return _Base_type::begin(); }\n-      \n-      /**\n-       * @todo Document this function.\n-       */\n-      const_iterator\n-      end() const\n-      { return _Base_type::end(); }\n-      \n-      // [7.10.4] format\n-      /**\n-       * @todo Implement this function.\n-       */\n-      template<typename _Out_iter>\n-        _Out_iter\n-        format(_Out_iter __out, const string_type& __fmt,\n-\t       regex_constants::match_flag_type __flags\n-\t       = regex_constants::format_default) const\n-        { return __out; }\n-\n-      /**\n-       * @todo Implement this function.\n-       */\n-      string_type\n-      format(const string_type& __fmt,\n-\t     regex_constants::match_flag_type __flags\n-\t     = regex_constants::format_default) const;\n-\n-      // [7.10.5] allocator\n-      /**\n-       * @todo Document this function.\n-       */\n-      //allocator_type\n-      //get_allocator() const;\n-      using _Base_type::get_allocator;\n-      \n-      // [7.10.6] swap\n-      /**\n-       * @todo Document this function.\n-       */\n-      void\n-      swap(match_results& __that)\n-      {\n-\t_Base_type::swap(__that);\n-\tstd::swap(_M_matched, __that._M_matched);\n-\tstd::swap(_M_prefix,  __that._M_prefix);\n-\tstd::swap(_M_suffix,  __that._M_suffix);\n-      }\n-      \n-    private:\n-      bool       _M_matched;\n-      value_type _M_prefix;\n-      value_type _M_suffix;\n-    };\n-  \n-  typedef match_results<const char*>             cmatch;\n-  typedef match_results<string::const_iterator>  smatch;\n-#ifdef _GLIBCXX_USE_WCHAR_T\n-  typedef match_results<const wchar_t*>          wcmatch;\n-  typedef match_results<wstring::const_iterator> wsmatch;\n-#endif\n-\n-  // match_results comparisons\n-  /**\n-   * @todo Implement this function.\n-   */\n-  template<typename _Bi_iter, typename _Allocator>\n-    inline bool\n-    operator==(const match_results<_Bi_iter, _Allocator>& __m1,\n-\t       const match_results<_Bi_iter, _Allocator>& __m2);\n-\n-  /**\n-   * @todo Implement this function.\n-   */\n-  template<typename _Bi_iter, class _Allocator>\n-    inline bool\n-    operator!=(const match_results<_Bi_iter, _Allocator>& __m1,\n-\t       const match_results<_Bi_iter, _Allocator>& __m2);\n-\n-  // [7.10.6] match_results swap\n-  /**\n-   * @brief Swaps two match results.\n-   * @param lhs A match result.\n-   * @param rhs A match result.\n-   *\n-   * The contents of the two match_results objects are swapped.\n-   */\n-  template<typename _Bi_iter, typename _Allocator>\n-    inline void\n-    swap(match_results<_Bi_iter, _Allocator>& __lhs,\n-\t match_results<_Bi_iter, _Allocator>& __rhs)\n-    { return __lhs.swap(__rhs); }\n-\n-  // [7.11.2] Function template regex_match\n-  /**\n-   * @brief Determines if there is a match between the regular expression @p e\n-   * and all of the character sequence [first, last).\n-   *\n-   * @param first Beginning of the character sequence to match.\n-   * @param last  One-past-the-end of the character sequence to match.\n-   * @param m     The match results.\n-   * @param re    The regular expression.\n-   * @param flags Controls how the regular expression is matched.\n-   *\n-   * @retval true  A match exists.\n-   * @retval false Otherwise.\n-   *\n-   * @todo Implement this function.\n-   */\n-  template<typename _Bi_iter, typename _Allocator,\n-\t   typename _Ch_type, typename _Rx_traits>\n-    bool\n-    regex_match(_Bi_iter __first, _Bi_iter __last,\n-\t\tmatch_results<_Bi_iter, _Allocator>& __m,\n-\t\tconst basic_regex<_Ch_type, _Rx_traits>& __re,\n-\t\tregex_constants::match_flag_type __flags\n-\t\t= regex_constants::match_default)\n-    { return false; }\n-\n-  /**\n-   * @brief Indicates if there is a match between the regular expression @p e\n-   * and all of the character sequence [first, last).\n-   *\n-   * @param first Beginning of the character sequence to match.\n-   * @param last  One-past-the-end of the character sequence to match.\n-   * @param re    The regular expression.\n-   * @param flags Controls how the regular expression is matched.\n-   *\n-   * @retval true  A match exists.\n-   * @retval false Otherwise.\n-   */\n-  template<typename _Bi_iter, typename _Ch_type, typename _Rx_traits>\n-    bool\n-    regex_match(_Bi_iter __first, _Bi_iter __last,\n-\t\tconst basic_regex<_Ch_type, _Rx_traits>& __re,\n-\t\tregex_constants::match_flag_type __flags\n-\t\t= regex_constants::match_default)\n-    { \n-      match_results<_Bi_iter> __what;\n-      return regex_match(__first, __last, __what, __re, __flags);\n-    }\n-\n-  /**\n-   * @brief Determines if there is a match between the regular expression @p e\n-   * and a C-style null-terminated string.\n-   *\n-   * @param s  The C-style null-terminated string to match.\n-   * @param m  The match results.\n-   * @param re The regular expression.\n-   * @param f  Controls how the regular expression is matched.\n-   *\n-   * @retval true  A match exists.\n-   * @retval false Otherwise.\n-   */\n-  template<typename _Ch_type, typename _Allocator, typename _Rx_traits>\n-    inline bool\n-    regex_match(const _Ch_type* __s,\n-\t\tmatch_results<const _Ch_type*, _Allocator>& __m,\n-\t\tconst basic_regex<_Ch_type, _Rx_traits>& __re,\n-\t\tregex_constants::match_flag_type __f\n-\t\t= regex_constants::match_default)\n-    { return regex_match(__s, __s + _Rx_traits::length(__s), __m, __re, __f); }\n-\n-  /**\n-   * @brief Determines if there is a match between the regular expression @p e\n-   * and a string.\n-   *\n-   * @param s     The string to match.\n-   * @param m     The match results.\n-   * @param re    The regular expression.\n-   * @param flags Controls how the regular expression is matched.\n-   *\n-   * @retval true  A match exists.\n-   * @retval false Otherwise.\n-   */\n-  template<typename _Ch_traits, typename _Ch_alloc,\n-\t   typename _Allocator, typename _Ch_type, typename _Rx_traits>\n-    inline bool\n-    regex_match(const basic_string<_Ch_type, _Ch_traits, _Ch_alloc>& __s,\n-\t\tmatch_results<typename basic_string<_Ch_type, \n-\t\t_Ch_traits, _Ch_alloc>::const_iterator, _Allocator>& __m,\n-\t\tconst basic_regex<_Ch_type, _Rx_traits>& __re,\n-\t\tregex_constants::match_flag_type __flags\n-\t\t= regex_constants::match_default)\n-    { return regex_match(__s.begin(), __s.end(), __m, __re, __flags); }\n-\n-  /**\n-   * @brief Indicates if there is a match between the regular expression @p e\n-   * and a C-style null-terminated string.\n-   *\n-   * @param s  The C-style null-terminated string to match.\n-   * @param re The regular expression.\n-   * @param f  Controls how the regular expression is matched.\n-   *\n-   * @retval true  A match exists.\n-   * @retval false Otherwise.\n-   */\n-  template<typename _Ch_type, class _Rx_traits>\n-    inline bool\n-    regex_match(const _Ch_type* __s,\n-\t\tconst basic_regex<_Ch_type, _Rx_traits>& __re,\n-\t\tregex_constants::match_flag_type __f\n-\t\t= regex_constants::match_default)\n-    { return regex_match(__s, __s + _Rx_traits::length(__s), __re, __f); }\n-\n-  /**\n-   * @brief Indicates if there is a match between the regular expression @p e\n-   * and a string.\n-   *\n-   * @param s     [IN] The string to match.\n-   * @param re    [IN] The regular expression.\n-   * @param flags [IN] Controls how the regular expression is matched.\n-   *\n-   * @retval true  A match exists.\n-   * @retval false Otherwise.\n-   */\n-  template<typename _Ch_traits, typename _Str_allocator,\n-\t   typename _Ch_type, typename _Rx_traits>\n-    inline bool\n-    regex_match(const basic_string<_Ch_type, _Ch_traits, _Str_allocator>& __s,\n-\t\tconst basic_regex<_Ch_type, _Rx_traits>& __re,\n-\t\tregex_constants::match_flag_type __flags\n-\t\t= regex_constants::match_default)\n-    { return regex_match(__s.begin(), __s.end(), __re, __flags); }\n-\n-  // [7.11.3] Function template regex_search\n-  /**\n-   * Searches for a regular expression within a range.\n-   * @param first [IN]  The start of the string to search.\n-   * @param last  [IN]  One-past-the-end of the string to search.\n-   * @param m     [OUT] The match results.\n-   * @param re    [IN]  The regular expression to search for.\n-   * @param flags [IN]  Search policy flags.\n-   * @retval true  A match was found within the string.\n-   * @retval false No match was found within the string, the content of %m is\n-   *               undefined.\n-   * @todo Implement this function.\n-   */\n-  template<typename _Bi_iter, typename _Allocator,\n-\t   typename _Ch_type, typename _Rx_traits>\n-    inline bool\n-    regex_search(_Bi_iter __first, _Bi_iter __last,\n-\t\t match_results<_Bi_iter, _Allocator>& __m,\n-\t\t const basic_regex<_Ch_type, _Rx_traits>& __re,\n-\t\t regex_constants::match_flag_type __flags\n-\t\t = regex_constants::match_default)\n-    { return false; }\n-\n-  /**\n-   * Searches for a regular expression within a range.\n-   * @param first [IN]  The start of the string to search.\n-   * @param last  [IN]  One-past-the-end of the string to search.\n-   * @param re    [IN]  The regular expression to search for.\n-   * @param flags [IN]  Search policy flags.\n-   * @retval true  A match was found within the string.\n-   * @retval false No match was found within the string.\n-   * @todo Document me.\n-   */\n-  template<typename _Bi_iter, typename _Ch_type, typename _Rx_traits>\n-    inline bool\n-    regex_search(_Bi_iter __first, _Bi_iter __last,\n-\t\t const basic_regex<_Ch_type, _Rx_traits>& __re,\n-\t\t regex_constants::match_flag_type __flags\n-\t\t = regex_constants::match_default)\n-    {\n-      match_results<_Bi_iter> __what;\n-      return regex_search(__first, __last, __what, __re, __flags);\n-    }\n-\n-  /**\n-   * @brief Searches for a regular expression within a C-string.\n-   * @param s [IN]  A C-string to search for the regex.\n-   * @param m [OUT] The set of regex mnatches.\n-   * @param e [IN]  The regex to search for in @p s.\n-   * @param f [IN]  The search flags.\n-   * @retval true  A match was found within the string.\n-   * @retval false No match was found within the string, the content of %m is\n-   *               undefined.\n-   * @todo Document me.\n-   */\n-  template<typename _Ch_type, class _Allocator, class _Rx_traits>\n-    inline bool\n-    regex_search(const _Ch_type* __s,\n-\t\t match_results<const _Ch_type*, _Allocator>& __m,\n-\t\t const basic_regex<_Ch_type, _Rx_traits>& __e,\n-\t\t regex_constants::match_flag_type __f\n-\t\t = regex_constants::match_default)\n-    { return regex_search(__s, __s + _Rx_traits::length(__s), __m, __e, __f); }\n-\n-  /**\n-   * @brief Searches for a regular expression within a C-string.\n-   * @param s [IN]  The C-string to search.\n-   * @param e [IN]  The regular expressioon to search for.\n-   * @param f [IN]  Search policy flags.\n-   * @retval true  A match was found within the string.\n-   * @retval false No match was found within the string.\n-   * @todo Document me.\n-   */\n-  template<typename _Ch_type, typename _Rx_traits>\n-    inline bool\n-    regex_search(const _Ch_type* __s,\n-\t\t const basic_regex<_Ch_type, _Rx_traits>& __e,\n-\t\t regex_constants::match_flag_type __f\n-\t\t = regex_constants::match_default)\n-    { return regex_search(__s, __s + _Rx_traits::length(__s), __e, __f); }\n-\n-  /**\n-   * @brief Searches for a regular expression within a string.\n-   * @param s     [IN]  The string to search.\n-   * @param e     [IN]  The regular expressioon to search for.\n-   * @param flags [IN]  Search policy flags.\n-   * @retval true  A match was found within the string.\n-   * @retval false No match was found within the string.\n-   * @todo Document me.\n-   */\n-  template<typename _Ch_traits, typename _String_allocator,\n-\t   typename _Ch_type, typename _Rx_traits>\n-    inline bool\n-    regex_search(const basic_string<_Ch_type, _Ch_traits,\n-\t\t _String_allocator>& __s,\n-\t\t const basic_regex<_Ch_type, _Rx_traits>& __e,\n-\t\t regex_constants::match_flag_type __flags\n-\t\t = regex_constants::match_default)\n-    { return regex_search(__s.begin(), __s.end(), __e, __flags); }\n-\n-  /**\n-   * @brief Searches for a regular expression within a string.\n-   * @param s [IN]  A C++ string to search for the regex.\n-   * @param m [OUT] The set of regex mnatches.\n-   * @param e [IN]  The regex to search for in @p s.\n-   * @param f [IN]  The search flags.\n-   * @retval true  A match was found within the string.\n-   * @retval false No match was found within the string, the content of %m is\n-   *               undefined.\n-   */\n-  template<typename _Ch_traits, typename _Ch_alloc,\n-\t   typename _Allocator, typename _Ch_type,\n-\t   typename _Rx_traits>\n-    inline bool\n-    regex_search(const basic_string<_Ch_type, _Ch_traits, _Ch_alloc>& __s,\n-\t\t match_results<typename basic_string<_Ch_type,\n-\t\t _Ch_traits, _Ch_alloc>::const_iterator, _Allocator>& __m,\n-\t\t const basic_regex<_Ch_type, _Rx_traits>& __e,\n-\t\t regex_constants::match_flag_type __f\n-\t\t = regex_constants::match_default)\n-    { return regex_search(__s.begin(), __s.end(), __m, __e, __f); }\n-\n-  // [7.11.4] Function template regex_replace\n-  /**\n-   * @todo Implement this function.\n-   * @todo Document this function.\n-   */\n-  template<typename _Out_iter, typename _Bi_iter,\n-\t   typename _Rx_traits, typename _Ch_type>\n-    inline _Out_iter\n-    regex_replace(_Out_iter __out, _Bi_iter __first, _Bi_iter __last,\n-\t\t  const basic_regex<_Ch_type, _Rx_traits>& __e,\n-\t\t  const basic_string<_Ch_type>& __fmt,\n-\t\t  regex_constants::match_flag_type __flags\n-\t\t  = regex_constants::match_default)\n-    { return __out; }\n-\n-  /**\n-   * @todo Document me.\n-   */\n-  template<typename _Rx_traits, typename _Ch_type>\n-    inline basic_string<_Ch_type>\n-    regex_replace(const basic_string<_Ch_type>& __s,\n-\t\t  const basic_regex<_Ch_type, _Rx_traits>& __e,\n-\t\t  const basic_string<_Ch_type>& __fmt,\n-\t\t  regex_constants::match_flag_type __flags\n-\t\t  = regex_constants::match_default)\n-    {\n-      std::string __result;\n-      regex_replace(std::back_inserter(__result),\n-\t\t    __s.begin(), __s.end(), __e, __fmt, __flags);\n-      return __result;\n-    }\n-\n-  // [7.12.1] Class template regex_iterator\n-  /**\n-   * An iterator adaptor that will provide repeated calls of regex_search over \n-   * a range until no more matches remain.\n-   */\n-  template<typename _Bi_iter,\n-\t   typename _Ch_type = typename iterator_traits<_Bi_iter>::value_type,\n-\t   typename _Rx_traits = regex_traits<_Ch_type> >\n-    class regex_iterator\n-    {\n-    public:\n-      typedef basic_regex<_Ch_type, _Rx_traits>  regex_type;\n-      typedef match_results<_Bi_iter>            value_type;\n-      typedef std::ptrdiff_t                     difference_type;\n-      typedef const value_type*                  pointer;\n-      typedef const value_type&                  reference;\n-      typedef std::forward_iterator_tag          iterator_category;\n-\n-    public:\n-      /**\n-       * @brief Provides a singular iterator, useful for indicating\n-       * one-past-the-end of a range.\n-       * @todo Implement this function.\n-       * @todo Document this function.\n-       */\n-      regex_iterator();\n-      \n-      /**\n-       * Constructs a %regex_iterator...\n-       * @param a  [IN] The start of a text range to search.\n-       * @param b  [IN] One-past-the-end of the text range to search.\n-       * @param re [IN] The regular expression to match.\n-       * @param m  [IN] Policy flags for match rules.\n-       * @todo Implement this function.\n-       * @todo Document this function.\n-       */\n-      regex_iterator(_Bi_iter __a, _Bi_iter __b, const regex_type& __re,\n-\t\t     regex_constants::match_flag_type __m\n-\t\t     = regex_constants::match_default);\n-\n-      /**\n-       * Copy constructs a %regex_iterator.\n-       * @todo Implement this function.\n-       * @todo Document this function.\n-       */\n-      regex_iterator(const regex_iterator& __rhs);\n-      \n-      /**\n-       * @todo Implement this function.\n-       * @todo Document this function.\n-       */\n-      regex_iterator&\n-      operator=(const regex_iterator& __rhs);\n-      \n-      /**\n-       * @todo Implement this function.\n-       * @todo Document this function.\n-       */\n-      bool\n-      operator==(const regex_iterator& __rhs);\n-      \n-      /**\n-       * @todo Implement this function.\n-       * @todo Document this function.\n-       */\n-      bool\n-      operator!=(const regex_iterator& __rhs);\n-      \n-      /**\n-       * @todo Implement this function.\n-       * @todo Document this function.\n-       */\n-      const value_type&\n-      operator*();\n-      \n-      /**\n-       * @todo Implement this function.\n-       * @todo Document this function.\n-       */\n-      const value_type*\n-      operator->();\n-      \n-      /**\n-       * @todo Implement this function.\n-       * @todo Document this function.\n-       */\n-      regex_iterator&\n-      operator++();\n-      \n-      /**\n-       * @todo Implement this function.\n-       * @todo Document this function.\n-       */\n-      regex_iterator\n-      operator++(int);\n-      \n-    private:\n-      // these members are shown for exposition only:\n-      _Bi_iter                         begin;\n-      _Bi_iter                         end;\n-      const regex_type*                pregex;\n-      regex_constants::match_flag_type flags;\n-      match_results<_Bi_iter>          match;\n-    };\n-  \n-  typedef regex_iterator<const char*>             cregex_iterator;\n-  typedef regex_iterator<string::const_iterator>  sregex_iterator;\n-#ifdef _GLIBCXX_USE_WCHAR_T\n-  typedef regex_iterator<const wchar_t*>          wcregex_iterator;\n-  typedef regex_iterator<wstring::const_iterator> wsregex_iterator;\n-#endif\n-\n-  // [7.12.2] Class template regex_token_iterator\n-  /**\n-   * Iterates over submatches in a range (or \"splits\" a text string).\n-   *\n-   * The purpose of this iterator is to enumerate all, or all specified,\n-   * matches of a regular expression within a text range.  The dereferenced\n-   * value of an iterator of this class is a std::tr1::sub_match object.\n-   */\n-  template<typename _Bi_iter,\n-\t   typename _Ch_type = typename iterator_traits<_Bi_iter>::value_type,\n-\t   typename _Rx_traits = regex_traits<_Ch_type> >\n-    class regex_token_iterator\n-    {\n-    public:\n-      typedef basic_regex<_Ch_type, _Rx_traits> regex_type;\n-      typedef sub_match<_Bi_iter>               value_type;\n-      typedef std::ptrdiff_t                    difference_type;\n-      typedef const value_type*                 pointer;\n-      typedef const value_type&                 reference;\n-      typedef std::forward_iterator_tag         iterator_category;\n-      \n-    public:\n-      /**\n-       * @brief Default constructs a %regex_token_iterator.\n-       * @todo Implement this function.\n-       * \n-       * A default-constructed %regex_token_iterator is a singular iterator\n-       * that will compare equal to the one-past-the-end value for any\n-       * iterator of the same type.\n-       */\n-      regex_token_iterator();\n-      \n-      /**\n-       * Constrcts a %regex_token_iterator...\n-       * @param a          [IN] The start of the text to search.\n-       * @param b          [IN] One-past-the-eend of the text to search.\n-       * @param re         [IN] The regular expression to search for.\n-       * @param submatch   [IN] Which submatch to return.  There are some\n-       *                        special values for thsi parameter:\n-       *                        - -1 each enumerated subexpression does NOT\n-       *                          match the regular expression (aka field\n-       *                          splitting)\n-       *                        - 0 the entire string matching the\n-       *                          subexpression is returned for each match\n-       *                          within the text.\n-       *                        - >0 enumerates only the indicated\n-       *                          subexpression from a match within the text.\n-       * @param m          [IN] Policy flags for match rules.\n-       *\n-       * @todo Implement this function.\n-       * @todo Document this function.\n-       */\n-      regex_token_iterator(_Bi_iter __a, _Bi_iter __b, const regex_type& __re,\n-\t\t\t   int __submatch = 0,\n-\t\t\t   regex_constants::match_flag_type __m\n-\t\t\t   = regex_constants::match_default);\n-\n-      /**\n-       * Constrcts a %regex_token_iterator...\n-       * @param a          [IN] The start of the text to search.\n-       * @param b          [IN] One-past-the-eend of the text to search.\n-       * @param re         [IN] The regular expression to search for.\n-       * @param submatches [IN] A list of subexpressions to return for each\n-       *                        regular expression match within the text.\n-       * @param m          [IN] Policy flags for match rules.\n-       *\n-       * @todo Implement this function.\n-       * @todo Document this function.\n-       */\n-      regex_token_iterator(_Bi_iter __a, _Bi_iter __b,\n-\t\t\t   const regex_type& __re,\n-\t\t\t   const std::vector<int>& __submatches,\n-\t\t\t   regex_constants::match_flag_type __m\n-\t\t\t     = regex_constants::match_default);\n-\n-      /**\n-       * Constrcts a %regex_token_iterator...\n-       * @param a          [IN] The start of the text to search.\n-       * @param b          [IN] One-past-the-eend of the text to search.\n-       * @param re         [IN] The regular expression to search for.\n-       * @param submatches [IN] A list of subexpressions to return for each\n-       *                        regular expression match within the text.\n-       * @param m          [IN] Policy flags for match rules.\n-       \n-       * @todo Implement this function.\n-       * @todo Document this function.\n-       */\n-      template<std::size_t _Nm>\n-        regex_token_iterator(_Bi_iter __a, _Bi_iter __b,\n-\t\t\t     const regex_type& __re,\n-\t\t\t     const int (&__submatches)[_Nm],\n-\t\t\t     regex_constants::match_flag_type __m\n-\t\t\t     = regex_constants::match_default);\n-\n-      /**\n-       * @brief Copy constructs a %regex_token_iterator.\n-       * @param rhs [IN] A %regex_token_iterator to copy.\n-       * @todo Implement this function.\n-       */\n-      regex_token_iterator(const regex_token_iterator& __rhs);\n-      \n-      /**\n-       * @brief Assigns a %regex_token_iterator to another.\n-       * @param rhs [IN] A %regex_token_iterator to copy.\n-       * @todo Implement this function.\n-       */\n-      regex_token_iterator&\n-      operator=(const regex_token_iterator& __rhs);\n-      \n-      /**\n-       * @brief Compares a %regex_token_iterator to another for equality.\n-       * @todo Implement this function.\n-       */\n-      bool\n-      operator==(const regex_token_iterator& __rhs);\n-      \n-      /**\n-       * @brief Compares a %regex_token_iterator to another for inequality.\n-       * @todo Implement this function.\n-       */\n-      bool\n-      operator!=(const regex_token_iterator& __rhs);\n-      \n-      /**\n-       * @brief Dereferences a %regex_token_iterator.\n-       * @todo Implement this function.\n-       */\n-      const value_type&\n-      operator*();\n-      \n-      /**\n-       * @brief Selects a %regex_token_iterator member.\n-       * @todo Implement this function.\n-       */\n-      const value_type*\n-      operator->();\n-      \n-      /**\n-       * @brief Increments a %regex_token_iterator.\n-       * @todo Implement this function.\n-       */\n-      regex_token_iterator&\n-      operator++();\n-      \n-      /**\n-       * @brief Postincrements a %regex_token_iterator.\n-       * @todo Implement this function.\n-       */\n-      regex_token_iterator\n-      operator++(int);\n-      \n-    private: // data members for exposition only:\n-      typedef regex_iterator<_Bi_iter, _Ch_type, _Rx_traits> position_iterator;\n-\n-      position_iterator __position;\n-      const value_type* __result;\n-      value_type        __suffix;\n-      std::size_t       __n;\n-      std::vector<int>  __subs;\n-    };\n-\n-  typedef regex_token_iterator<const char*>             cregex_token_iterator;\n-  typedef regex_token_iterator<string::const_iterator>  sregex_token_iterator;\n-#ifdef _GLIBCXX_USE_WCHAR_T\n-  typedef regex_token_iterator<const wchar_t*>          wcregex_token_iterator;\n-  typedef regex_token_iterator<wstring::const_iterator> wsregex_token_iterator;\n+#if defined(_GLIBCXX_INCLUDE_AS_TR1)\n+#  include <tr1_impl/regex>\n+#else\n+#  define _GLIBCXX_INCLUDE_AS_TR1\n+#  define _GLIBCXX_BEGIN_NAMESPACE_TR1 namespace tr1 {\n+#  define _GLIBCXX_END_NAMESPACE_TR1 }\n+#  define _GLIBCXX_TR1 tr1::\n+#  include <tr1_impl/regex>\n+#  undef _GLIBCXX_TR1\n+#  undef _GLIBCXX_END_NAMESPACE_TR1\n+#  undef _GLIBCXX_BEGIN_NAMESPACE_TR1\n+#  undef _GLIBCXX_INCLUDE_AS_TR1\n #endif\n-  \n-  /** @} */ // group tr1_regex\n-  \n-_GLIBCXX_END_NAMESPACE\n-}\n \n-#endif // _TR1_REGEX\n+#endif // _GLIBCXX_TR1_REGEX"}, {"sha": "40277c03412564fb1c3fd78ace5cf636ca271f4b", "filename": "libstdc++-v3/include/tr1/riemann_zeta.tcc", "status": "modified", "additions": 16, "deletions": 15, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e133ace8d907bf42754c86106fc3f04a9d9fe70f/libstdc%2B%2B-v3%2Finclude%2Ftr1%2Friemann_zeta.tcc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e133ace8d907bf42754c86106fc3f04a9d9fe70f/libstdc%2B%2B-v3%2Finclude%2Ftr1%2Friemann_zeta.tcc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Ftr1%2Friemann_zeta.tcc?ref=e133ace8d907bf42754c86106fc3f04a9d9fe70f", "patch": "@@ -45,14 +45,15 @@\n //   (3) Gamma, Exploring Euler's Constant, Julian Havil,\n //       Princeton, 2003.\n \n-#ifndef _TR1_RIEMANN_ZETA_TCC\n-#define _TR1_RIEMANN_ZETA_TCC 1\n+#ifndef _GLIBCXX_TR1_RIEMANN_ZETA_TCC\n+#define _GLIBCXX_TR1_RIEMANN_ZETA_TCC 1\n \n #include \"special_function_util.h\"\n \n namespace std\n {\n-_GLIBCXX_BEGIN_NAMESPACE(_GLIBCXX_TR1)\n+namespace tr1\n+{\n \n   // [5.2] Special functions\n \n@@ -175,7 +176,7 @@ _GLIBCXX_BEGIN_NAMESPACE(_GLIBCXX_TR1)\n       if (__s < _Tp(0))\n         {\n #if _GLIBCXX_USE_C99_MATH_TR1\n-          if (std::_GLIBCXX_TR1::fmod(__s,_Tp(2)) == _Tp(0))\n+          if (std::tr1::fmod(__s,_Tp(2)) == _Tp(0))\n             return _Tp(0);\n           else\n #endif\n@@ -185,7 +186,7 @@ _GLIBCXX_BEGIN_NAMESPACE(_GLIBCXX_TR1)\n                      * __numeric_constants<_Tp>::__pi(), __s)\n                      * std::sin(__numeric_constants<_Tp>::__pi_2() * __s)\n #if _GLIBCXX_USE_C99_MATH_TR1\n-                     * std::exp(std::_GLIBCXX_TR1::lgamma(_Tp(1) - __s))\n+                     * std::exp(std::tr1::lgamma(_Tp(1) - __s))\n #else\n                      * std::exp(__log_gamma(_Tp(1) - __s))\n #endif\n@@ -204,9 +205,9 @@ _GLIBCXX_BEGIN_NAMESPACE(_GLIBCXX_TR1)\n           for (unsigned int __j = 0; __j <= __i; ++__j)\n             {\n #if _GLIBCXX_USE_C99_MATH_TR1\n-              _Tp __bincoeff =  std::_GLIBCXX_TR1::lgamma(_Tp(1 + __i))\n-                              - std::_GLIBCXX_TR1::lgamma(_Tp(1 + __j))\n-                              - std::_GLIBCXX_TR1::lgamma(_Tp(1 + __i - __j));\n+              _Tp __bincoeff =  std::tr1::lgamma(_Tp(1 + __i))\n+                              - std::tr1::lgamma(_Tp(1 + __j))\n+                              - std::tr1::lgamma(_Tp(1 + __i - __j));\n #else\n               _Tp __bincoeff =  __log_gamma(_Tp(1 + __i))\n                               - __log_gamma(_Tp(1 + __j))\n@@ -309,7 +310,7 @@ _GLIBCXX_BEGIN_NAMESPACE(_GLIBCXX_TR1)\n           __zeta *= std::pow(_Tp(2) * __numeric_constants<_Tp>::__pi(), __s)\n                  * std::sin(__numeric_constants<_Tp>::__pi_2() * __s)\n #if _GLIBCXX_USE_C99_MATH_TR1\n-                 * std::exp(std::_GLIBCXX_TR1::lgamma(_Tp(1) - __s))\n+                 * std::exp(std::tr1::lgamma(_Tp(1) - __s))\n #else\n                  * std::exp(__log_gamma(_Tp(1) - __s))\n #endif\n@@ -332,7 +333,7 @@ _GLIBCXX_BEGIN_NAMESPACE(_GLIBCXX_TR1)\n                                 * __numeric_constants<_Tp>::__pi(), __s)\n                          * std::sin(__numeric_constants<_Tp>::__pi_2() * __s)\n #if _GLIBCXX_USE_C99_MATH_TR1\n-                             * std::_GLIBCXX_TR1::tgamma(_Tp(1) - __s)\n+                             * std::tr1::tgamma(_Tp(1) - __s)\n #else\n                              * std::exp(__log_gamma(_Tp(1) - __s))\n #endif\n@@ -387,9 +388,9 @@ _GLIBCXX_BEGIN_NAMESPACE(_GLIBCXX_TR1)\n           for (unsigned int __j = 0; __j <= __i; ++__j)\n             {\n #if _GLIBCXX_USE_C99_MATH_TR1\n-              _Tp __bincoeff =  std::_GLIBCXX_TR1::lgamma(_Tp(1 + __i))\n-                              - std::_GLIBCXX_TR1::lgamma(_Tp(1 + __j))\n-                              - std::_GLIBCXX_TR1::lgamma(_Tp(1 + __i - __j));\n+              _Tp __bincoeff =  std::tr1::lgamma(_Tp(1 + __i))\n+                              - std::tr1::lgamma(_Tp(1 + __j))\n+                              - std::tr1::lgamma(_Tp(1 + __i - __j));\n #else\n               _Tp __bincoeff =  __log_gamma(_Tp(1 + __i))\n                               - __log_gamma(_Tp(1 + __j))\n@@ -443,7 +444,7 @@ _GLIBCXX_BEGIN_NAMESPACE(_GLIBCXX_TR1)\n \n   /* @} */ // group tr1_math_spec_func\n \n-_GLIBCXX_END_NAMESPACE\n+}\n }\n \n-#endif // _TR1_RIEMANN_ZETA_TCC\n+#endif // _GLIBCXX_TR1_RIEMANN_ZETA_TCC"}, {"sha": "2f33c39f886b46738ca73ead89df178c757f19c2", "filename": "libstdc++-v3/include/tr1/special_function_util.h", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e133ace8d907bf42754c86106fc3f04a9d9fe70f/libstdc%2B%2B-v3%2Finclude%2Ftr1%2Fspecial_function_util.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e133ace8d907bf42754c86106fc3f04a9d9fe70f/libstdc%2B%2B-v3%2Finclude%2Ftr1%2Fspecial_function_util.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Ftr1%2Fspecial_function_util.h?ref=e133ace8d907bf42754c86106fc3f04a9d9fe70f", "patch": "@@ -39,13 +39,14 @@\n \n // Written by Edward Smith-Rowland based on numerous mathematics books.\n \n-#ifndef _TR1_SPECIAL_FUNCTION_UTIL_H\n-#define _TR1_SPECIAL_FUNCTION_UTIL_H 1\n+#ifndef _GLIBCXX_TR1_SPECIAL_FUNCTION_UTIL_H\n+#define _GLIBCXX_TR1_SPECIAL_FUNCTION_UTIL_H 1\n \n // namespace std::tr1\n namespace std\n {\n-_GLIBCXX_BEGIN_NAMESPACE(_GLIBCXX_TR1)\n+namespace tr1\n+{\n \n   namespace __detail\n   {\n@@ -148,8 +149,8 @@ _GLIBCXX_BEGIN_NAMESPACE(_GLIBCXX_TR1)\n \n   } // namespace __detail\n \n-_GLIBCXX_END_NAMESPACE\n+}\n }\n \n-#endif // _TR1_SPECIAL_FUNCTION_UTIL_H\n+#endif // _GLIBCXX_TR1_SPECIAL_FUNCTION_UTIL_H\n "}, {"sha": "50c5e21f3950a3faaff62caed09f7b56d810221f", "filename": "libstdc++-v3/include/tr1/stdlib.h", "status": "modified", "additions": 9, "deletions": 8, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e133ace8d907bf42754c86106fc3f04a9d9fe70f/libstdc%2B%2B-v3%2Finclude%2Ftr1%2Fstdlib.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e133ace8d907bf42754c86106fc3f04a9d9fe70f/libstdc%2B%2B-v3%2Finclude%2Ftr1%2Fstdlib.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Ftr1%2Fstdlib.h?ref=e133ace8d907bf42754c86106fc3f04a9d9fe70f", "patch": "@@ -31,26 +31,27 @@\n  *  This is a TR1 C++ Library header. \n  */\n \n-#ifndef _TR1_STDLIB_H\n-#define _TR1_STDLIB_H 1\n+#ifndef _GLIBCXX_TR1_STDLIB_H\n+#define _GLIBCXX_TR1_STDLIB_H 1\n \n #include <tr1/cstdlib>\n \n #if _GLIBCXX_HOSTED\n \n #if _GLIBCXX_USE_C99\n \n-using std::_GLIBCXX_TR1::atoll;\n-using std::_GLIBCXX_TR1::strtoll;\n-using std::_GLIBCXX_TR1::strtoull;\n+using std::tr1::atoll;\n+using std::tr1::strtoll;\n+using std::tr1::strtoull;\n \n-using std::_GLIBCXX_TR1::abs;\n+using std::tr1::abs;\n #if !_GLIBCXX_USE_C99_LONG_LONG_DYNAMIC\n-using std::_GLIBCXX_TR1::div;\n+using std::tr1::div;\n #endif\n \n #endif\n \n #endif\n \n-#endif\n+#endif // _GLIBCXX_TR1_STDLIB_H\n+"}, {"sha": "1bf932172d291d075ea7022b2b47069fbf778442", "filename": "libstdc++-v3/include/tr1/tgmath.h", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e133ace8d907bf42754c86106fc3f04a9d9fe70f/libstdc%2B%2B-v3%2Finclude%2Ftr1%2Ftgmath.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e133ace8d907bf42754c86106fc3f04a9d9fe70f/libstdc%2B%2B-v3%2Finclude%2Ftr1%2Ftgmath.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Ftr1%2Ftgmath.h?ref=e133ace8d907bf42754c86106fc3f04a9d9fe70f", "patch": "@@ -1,6 +1,6 @@\n // TR1 tgmath.h -*- C++ -*-\n \n-// Copyright (C) 2006 Free Software Foundation, Inc.\n+// Copyright (C) 2006, 2007 Free Software Foundation, Inc.\n //\n // This file is part of the GNU ISO C++ Library.  This library is free\n // software; you can redistribute it and/or modify it under the\n@@ -31,9 +31,9 @@\n  *  This is a TR1 C++ Library header. \n  */\n \n-#ifndef _TR1_TGMATH_H\n-#define _TR1_TGMATH_H 1\n+#ifndef _GLIBCXX_TR1_TGMATH_H\n+#define _GLIBCXX_TR1_TGMATH_H 1\n \n #include <tr1/ctgmath>\n \n-#endif\n+#endif // _GLIBCXX_TR1_TGMATH_H"}, {"sha": "0c7ed3f60ae83cf31d3e99615ae582ff44c482f0", "filename": "libstdc++-v3/include/tr1/tuple", "status": "modified", "additions": 20, "deletions": 396, "changes": 416, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e133ace8d907bf42754c86106fc3f04a9d9fe70f/libstdc%2B%2B-v3%2Finclude%2Ftr1%2Ftuple", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e133ace8d907bf42754c86106fc3f04a9d9fe70f/libstdc%2B%2B-v3%2Finclude%2Ftr1%2Ftuple", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Ftr1%2Ftuple?ref=e133ace8d907bf42754c86106fc3f04a9d9fe70f", "patch": "@@ -34,405 +34,29 @@\n // Chris Jefferson <chris@bubblescope.net>\n // Variadic Templates support by Douglas Gregor <doug.gregor@gmail.com>\n \n-#ifndef _TR1_TUPLE\n-#define _TR1_TUPLE 1\n+#ifndef _GLIBCXX_TR1_TUPLE\n+#define _GLIBCXX_TR1_TUPLE 1\n \n #pragma GCC system_header\n \n-#include <utility>\n-\n-namespace std\n-{\n-_GLIBCXX_BEGIN_NAMESPACE(_GLIBCXX_TR1)\n-\n-  template<typename _Tp>\n-    class reference_wrapper;\n-\n-  // Adds a const reference to a non-reference type.\n-  template<typename _Tp>\n-    struct __add_c_ref\n-    { typedef const _Tp& type; };\n-\n-  template<typename _Tp>\n-    struct __add_c_ref<_Tp&>\n-    { typedef _Tp& type; };\n-\n-  // Adds a reference to a non-reference type.\n-  template<typename _Tp>\n-    struct __add_ref\n-    { typedef _Tp& type; };\n-\n-  template<typename _Tp>\n-    struct __add_ref<_Tp&>\n-    { typedef _Tp& type; };\n-\n-  /**\n-   * @if maint\n-   * Contains the actual implementation of the @c tuple template, stored\n-   * as a recursive inheritance hierarchy from the first element (most\n-   * derived class) to the last (least derived class). The @c Idx\n-   * parameter gives the 0-based index of the element stored at this\n-   * point in the hierarchy; we use it to implement a constant-time\n-   * get() operation.\n-   * @endif\n-   */\n-  template<int _Idx, typename... _Elements>\n-    struct _Tuple_impl; \n-\n-  /**\n-   * @if maint\n-   * Zero-element tuple implementation. This is the basis case for the \n-   * inheritance recursion.\n-   * @endif maint\n-   */\n-  template<int _Idx>\n-    struct _Tuple_impl<_Idx> { };\n-\n-  /**\n-   * @if maint\n-   * Recursive tuple implementation. Here we store the @c Head element\n-   * and derive from a @c Tuple_impl containing the remaining elements\n-   * (which contains the @c Tail).\n-   * @endif\n-   */\n-  template<int _Idx, typename _Head, typename... _Tail>\n-    struct _Tuple_impl<_Idx, _Head, _Tail...>\n-    : public _Tuple_impl<_Idx + 1, _Tail...>\n-    {\n-      typedef _Tuple_impl<_Idx + 1, _Tail...> _Inherited;\n-      \n-      _Head _M_head;\n-      \n-      _Inherited&       _M_tail()       { return *this; }\n-      const _Inherited& _M_tail() const { return *this; }\n-      \n-      _Tuple_impl() : _Inherited(), _M_head() { }\n-      \n-      explicit \n-      _Tuple_impl(typename __add_c_ref<_Head>::type __head,\n-\t\t  typename __add_c_ref<_Tail>::type... __tail)\n-      : _Inherited(__tail...), _M_head(__head) { }\n-\n-      template<typename... _UElements>\n-      _Tuple_impl(const _Tuple_impl<_Idx, _UElements...>& __in)\n-      : _Inherited(__in._M_tail()), _M_head(__in._M_head) { }\n-\n-      _Tuple_impl(const _Tuple_impl& __in)\n-      : _Inherited(__in._M_tail()), _M_head(__in._M_head) { }\n-     \n-      template<typename... _UElements>\n-        _Tuple_impl&\n-        operator=(const _Tuple_impl<_Idx, _UElements...>& __in)\n-        {\n-\t  _M_head = __in._M_head;\n-\t  _M_tail() = __in._M_tail();\n-\t  return *this;\n-\t}\n-\n-      _Tuple_impl&\n-      operator=(const _Tuple_impl& __in)\n-      {\n-\t_M_head = __in._M_head;\n-\t_M_tail() = __in._M_tail();\n-\treturn *this;\n-      }\n-    };\n-\n-  template<typename... _Elements> \n-    class tuple : public _Tuple_impl<0, _Elements...>\n-    {\n-      typedef _Tuple_impl<0, _Elements...> _Inherited;\n-\n-    public:\n-      tuple() : _Inherited() { }\n-\n-      explicit\n-      tuple(typename __add_c_ref<_Elements>::type... __elements)\n-      : _Inherited(__elements...) { }\n-\n-      template<typename... _UElements>\n-        tuple(const tuple<_UElements...>& __in)\n-\t: _Inherited(__in) { }\n-\n-      tuple(const tuple& __in)\n-      : _Inherited(__in) { }\n-\n-      template<typename... _UElements>\n-        tuple&\n-        operator=(const tuple<_UElements...>& __in)\n-        {\n-\t  static_cast<_Inherited&>(*this) = __in;\n-\t  return *this;\n-\t}\n-\n-      tuple&\n-      operator=(const tuple& __in)\n-      {\n-\tstatic_cast<_Inherited&>(*this) = __in;\n-\treturn *this;\n-      }\n-    };\n-\n-  template<> class tuple<> { };\n-\n-  // 2-element tuple, with construction and assignment from a pair.\n-  template<typename _T1, typename _T2>\n-    class tuple<_T1, _T2> : public _Tuple_impl<0, _T1, _T2>\n-    {\n-      typedef _Tuple_impl<0, _T1, _T2> _Inherited;\n-\n-    public:\n-      tuple() : _Inherited() { }\n-\n-      explicit\n-      tuple(typename __add_c_ref<_T1>::type __a1,\n-\t    typename __add_c_ref<_T2>::type __a2)\n-      : _Inherited(__a1, __a2) { }\n-\n-      template<typename _U1, typename _U2>\n-        tuple(const tuple<_U1, _U2>& __in)\n-\t: _Inherited(__in) { }\n-\n-      tuple(const tuple& __in)\n-      : _Inherited(__in) { }\n-\n-      template<typename _U1, typename _U2>\n-        tuple(const pair<_U1, _U2>& __in)\n-\t: _Inherited(_Tuple_impl<0, \n-\t\t     typename __add_c_ref<_U1>::type,\n-\t\t     typename __add_c_ref<_U2>::type>(__in.first, \n-\t\t\t\t\t\t      __in.second))\n-        { }\n-  \n-      template<typename _U1, typename _U2>\n-        tuple&\n-        operator=(const tuple<_U1, _U2>& __in)\n-        {\n-\t  static_cast<_Inherited&>(*this) = __in;\n-\t  return *this;\n-\t}\n-\n-      tuple&\n-      operator=(const tuple& __in)\n-      {\n-\tstatic_cast<_Inherited&>(*this) = __in;\n-\treturn *this;\n-      }\n-\n-      template<typename _U1, typename _U2>\n-        tuple&\n-        operator=(const pair<_U1, _U2>& __in)\n-        {\n-\t  this->_M_head = __in.first;\n-\t  this->_M_tail()._M_head = __in.second;\n-\t  return *this;\n-\t}\n-    };\n-\n-  \n-  /// Gives the type of the ith element of a given tuple type.\n-  template<int __i, typename _Tp>\n-    struct tuple_element;\n-\n-  /**\n-   * @if maint\n-   * Recursive case for tuple_element: strip off the first element in\n-   * the tuple and retrieve the (i-1)th element of the remaining tuple.\n-   * @endif\n-   */\n-  template<int __i, typename _Head, typename... _Tail>\n-    struct tuple_element<__i, tuple<_Head, _Tail...> >\n-    : tuple_element<__i - 1, tuple<_Tail...> > { };\n-\n-  /**\n-   * @if maint\n-   * Basis case for tuple_element: The first element is the one we're seeking.\n-   * @endif\n-   */\n-  template<typename _Head, typename... _Tail>\n-    struct tuple_element<0, tuple<_Head, _Tail...> >\n-    {\n-      typedef _Head type;\n-    };\n-\n-  /// Finds the size of a given tuple type.\n-  template<typename _Tp>\n-    struct tuple_size;\n-\n-  /// @brief class tuple_size\n-  template<typename... _Elements>\n-    struct tuple_size<tuple<_Elements...> >\n-    {\n-      static const int value = sizeof...(_Elements);\n-    };\n-\n-  template<typename... _Elements>\n-    const int tuple_size<tuple<_Elements...> >::value;\n-\n-  template<int __i, typename _Head, typename... _Tail>\n-    inline typename __add_ref<_Head>::type\n-    __get_helper(_Tuple_impl<__i, _Head, _Tail...>& __t)\n-    {\n-      return __t._M_head;\n-    }\n-\n-  template<int __i, typename _Head, typename... _Tail>\n-    inline typename __add_c_ref<_Head>::type\n-    __get_helper(const _Tuple_impl<__i, _Head, _Tail...>& __t)\n-    {\n-      return __t._M_head;\n-    }\n-\n-  // Return a reference (const reference) to the ith element of a tuple.\n-  // Any const or non-const ref elements are returned with their original type.\n-  template<int __i, typename... _Elements>\n-    inline typename __add_ref<\n-                      typename tuple_element<__i, tuple<_Elements...> >::type\n-                    >::type\n-    get(tuple<_Elements...>& __t)\n-    { \n-      return __get_helper<__i>(__t); \n-    }\n-\n-  template<int __i, typename... _Elements>\n-    inline typename __add_c_ref<\n-                      typename tuple_element<__i, tuple<_Elements...> >::type\n-                    >::type\n-    get(const tuple<_Elements...>& __t)\n-    {\n-      return __get_helper<__i>(__t);\n-    }\n-\n-  // This class helps construct the various comparison operations on tuples\n-  template<int __check_equal_size, int __i, int __j,\n-\t   typename _Tp, typename _Up>\n-    struct __tuple_compare;\n-\n-  template<int __i, int __j, typename _Tp, typename _Up>\n-    struct __tuple_compare<0, __i, __j, _Tp, _Up>\n-    {\n-      static bool __eq(const _Tp& __t, const _Up& __u)\n-      {\n-\treturn (get<__i>(__t) == get<__i>(__u) &&\n-\t\t__tuple_compare<0, __i+1, __j, _Tp, _Up>::__eq(__t, __u));\n-      }\n-     \n-      static bool __less(const _Tp& __t, const _Up& __u)\n-      {\n-\treturn ((get<__i>(__t) < get<__i>(__u))\n-\t\t|| !(get<__i>(__u) < get<__i>(__t)) &&\n-\t\t__tuple_compare<0, __i+1, __j, _Tp, _Up>::__less(__t, __u));\n-      }\n-    };\n-\n-  template<int __i, typename _Tp, typename _Up>\n-    struct __tuple_compare<0, __i, __i, _Tp, _Up>\n-    {\n-      static bool __eq(const _Tp&, const _Up&)\n-      { return true; }\n-     \n-      static bool __less(const _Tp&, const _Up&)\n-      { return false; }\n-    };\n-\n-  template<typename... _TElements, typename... _UElements>\n-    bool\n-    operator==(const tuple<_TElements...>& __t,\n-\t       const tuple<_UElements...>& __u)\n-    {\n-      typedef tuple<_TElements...> _Tp;\n-      typedef tuple<_UElements...> _Up;\n-      return (__tuple_compare<tuple_size<_Tp>::value - tuple_size<_Tp>::value,\n-\t      0, tuple_size<_Tp>::value, _Tp, _Up>::__eq(__t, __u));\n-    }\n-\n-  template<typename... _TElements, typename... _UElements>\n-    bool\n-    operator<(const tuple<_TElements...>& __t,\n-\t      const tuple<_UElements...>& __u)\n-    {\n-      typedef tuple<_TElements...> _Tp;\n-      typedef tuple<_UElements...> _Up;\n-      return (__tuple_compare<tuple_size<_Tp>::value - tuple_size<_Tp>::value,\n-\t      0, tuple_size<_Tp>::value, _Tp, _Up>::__less(__t, __u));\n-    }\n-\n-  template<typename... _TElements, typename... _UElements>\n-    bool\n-    operator!=(const tuple<_TElements...>& __t,\n-\t       const tuple<_UElements...>& __u)\n-    { return !(__t == __u); }\n-\n-  template<typename... _TElements, typename... _UElements>\n-    bool\n-    operator>(const tuple<_TElements...>& __t,\n-\t      const tuple<_UElements...>& __u)\n-    { return __u < __t; }\n-\n-  template<typename... _TElements, typename... _UElements>\n-    bool\n-    operator<=(const tuple<_TElements...>& __t,\n-\t       const tuple<_UElements...>& __u)\n-    { return !(__u < __t); }\n-\n-  template<typename... _TElements, typename... _UElements>\n-    bool\n-    operator>=(const tuple<_TElements...>& __t,\n-\t       const tuple<_UElements...>& __u)\n-    { return !(__t < __u); }\n-\n-  // Helper which adds a reference to a type when given a reference_wrapper\n-  template<typename _Tp>\n-    struct __strip_reference_wrapper\n-    {\n-      typedef _Tp __type;\n-    };\n-\n-  template<typename _Tp>\n-    struct __strip_reference_wrapper<reference_wrapper<_Tp> >\n-    {\n-      typedef _Tp& __type;\n-    };\n-\n-  template<typename _Tp>\n-    struct __strip_reference_wrapper<const reference_wrapper<_Tp> >\n-    {\n-      typedef _Tp& __type;\n-    };\n-\n-  template<typename... _Elements>\n-    inline tuple<typename __strip_reference_wrapper<_Elements>::__type...>\n-    make_tuple(_Elements... __args)\n-    {\n-      typedef tuple<typename __strip_reference_wrapper<_Elements>::__type...>\n-        __result_type;\n-      return __result_type(__args...);\n-    }\n-\n-  template<typename... _Elements>\n-    inline tuple<_Elements&...>\n-    tie(_Elements&... __args)\n-    {\n-      return tuple<_Elements&...>(__args...);\n-    }\n-\n-  // A class (and instance) which can be used in 'tie' when an element\n-  // of a tuple is not required\n-  struct _Swallow_assign\n-  {\n-    template<class _Tp>\n-      _Swallow_assign&\n-      operator=(const _Tp&)\n-      { return *this; }\n-  };\n-\n-  // TODO: Put this in some kind of shared file.\n-  namespace\n-  {\n-    _Swallow_assign ignore;\n-  }; // anonymous namespace\n+#if defined(_GLIBCXX_INCLUDE_AS_CXX0X)\n+#  error TR1 header cannot be included from C++0x header\n+#endif\n \n-_GLIBCXX_END_NAMESPACE\n-}\n+#include <utility>\n \n+#if defined(_GLIBCXX_INCLUDE_AS_TR1)\n+#  include <tr1_impl/tuple>\n+#else\n+#  define _GLIBCXX_INCLUDE_AS_TR1\n+#  define _GLIBCXX_BEGIN_NAMESPACE_TR1 namespace tr1 {\n+#  define _GLIBCXX_END_NAMESPACE_TR1 }\n+#  define _GLIBCXX_TR1 tr1::\n+#  include <tr1_impl/tuple>\n+#  undef _GLIBCXX_TR1\n+#  undef _GLIBCXX_END_NAMESPACE_TR1\n+#  undef _GLIBCXX_BEGIN_NAMESPACE_TR1\n+#  undef _GLIBCXX_INCLUDE_AS_TR1\n #endif\n+\n+#endif // _GLIBCXX_TR1_TUPLE"}, {"sha": "709cbd9bb17144ba80b3bb648d024ad3293e62b0", "filename": "libstdc++-v3/include/tr1/type_traits", "status": "modified", "additions": 50, "deletions": 457, "changes": 507, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e133ace8d907bf42754c86106fc3f04a9d9fe70f/libstdc%2B%2B-v3%2Finclude%2Ftr1%2Ftype_traits", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e133ace8d907bf42754c86106fc3f04a9d9fe70f/libstdc%2B%2B-v3%2Finclude%2Ftr1%2Ftype_traits", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Ftr1%2Ftype_traits?ref=e133ace8d907bf42754c86106fc3f04a9d9fe70f", "patch": "@@ -31,26 +31,35 @@\n  *  This is a TR1 C++ Library header. \n  */\n \n-#ifndef _TR1_TYPE_TRAITS\n-#define _TR1_TYPE_TRAITS 1\n+#ifndef _GLIBCXX_TR1_TYPE_TRAITS\n+#define _GLIBCXX_TR1_TYPE_TRAITS 1\n \n #pragma GCC system_header\n \n-#include <bits/c++config.h>\n-#include <tr1/type_traitsfwd.h>\n+#if defined(_GLIBCXX_INCLUDE_AS_CXX0X)\n+#  error TR1 header cannot be included from C++0x header\n+#endif\n+\n+#include <cstddef>\n+\n+#if defined(_GLIBCXX_INCLUDE_AS_TR1)\n+#  include <tr1_impl/type_traits>\n+#else\n+#  define _GLIBCXX_INCLUDE_AS_TR1\n+#  define _GLIBCXX_BEGIN_NAMESPACE_TR1 namespace tr1 {\n+#  define _GLIBCXX_END_NAMESPACE_TR1 }\n+#  define _GLIBCXX_TR1 tr1::\n+#  include <tr1_impl/type_traits>\n+#  undef _GLIBCXX_TR1\n+#  undef _GLIBCXX_END_NAMESPACE_TR1\n+#  undef _GLIBCXX_BEGIN_NAMESPACE_TR1\n+#  undef _GLIBCXX_INCLUDE_AS_TR1\n+#endif\n \n-// namespace std::tr1\n namespace std\n {\n-_GLIBCXX_BEGIN_NAMESPACE(_GLIBCXX_TR1)\n-\n-  // For use in __is_convertible_simple.\n-  struct __sfinae_types\n-  {\n-    typedef char __one;\n-    typedef struct { char __arr[2]; } __two;\n-  };\n-\n+namespace tr1\n+{\n #define _DEFINE_SPEC_BODY(_Value)                                    \\\n     : public integral_constant<bool, _Value> { };\n \n@@ -59,307 +68,69 @@ _GLIBCXX_BEGIN_NAMESPACE(_GLIBCXX_TR1)\n     struct _Spec                                                     \\\n     _DEFINE_SPEC_BODY(_Value)\n \n-#define _DEFINE_SPEC_1_HELPER(_Spec, _Value)                         \\\n-  template<typename _Tp>                                             \\\n-    struct _Spec                                                     \\\n-    _DEFINE_SPEC_BODY(_Value)\n-      \n-#define _DEFINE_SPEC_2_HELPER(_Spec, _Value)                         \\\n-  template<typename _Tp, typename _Cp>                               \\\n-    struct _Spec                                                     \\\n-    _DEFINE_SPEC_BODY(_Value)\n-\n #define _DEFINE_SPEC(_Order, _Trait, _Type, _Value)                  \\\n   _DEFINE_SPEC_##_Order##_HELPER(_Trait<_Type>, _Value)              \\\n   _DEFINE_SPEC_##_Order##_HELPER(_Trait<_Type const>, _Value)        \\\n   _DEFINE_SPEC_##_Order##_HELPER(_Trait<_Type volatile>, _Value)     \\\n   _DEFINE_SPEC_##_Order##_HELPER(_Trait<_Type const volatile>, _Value)\n \n-  /// @brief  helper classes [4.3].\n-  template<typename _Tp, _Tp __v>\n-    struct integral_constant\n-    {\n-      static const _Tp                      value = __v;\n-      typedef _Tp                           value_type;\n-      typedef integral_constant<_Tp, __v>   type;\n-    };\n-  typedef integral_constant<bool, true>     true_type;\n-  typedef integral_constant<bool, false>    false_type;\n-\n-  template<typename _Tp, _Tp __v>\n-    const _Tp integral_constant<_Tp, __v>::value;\n-\n-  /// @brief  primary type categories [4.5.1].\n   template<typename>\n-    struct is_void\n-    : public false_type { };\n-  _DEFINE_SPEC(0, is_void, void, true)\n-\n-  template<typename>\n-    struct is_integral\n-    : public false_type { };\n-  _DEFINE_SPEC(0, is_integral, bool, true)\n-  _DEFINE_SPEC(0, is_integral, char, true)\n-  _DEFINE_SPEC(0, is_integral, signed char, true)\n-  _DEFINE_SPEC(0, is_integral, unsigned char, true)\n-#ifdef _GLIBCXX_USE_WCHAR_T\n-  _DEFINE_SPEC(0, is_integral, wchar_t, true)\n-#endif\n-  _DEFINE_SPEC(0, is_integral, short, true)\n-  _DEFINE_SPEC(0, is_integral, unsigned short, true)\n-  _DEFINE_SPEC(0, is_integral, int, true)\n-  _DEFINE_SPEC(0, is_integral, unsigned int, true)\n-  _DEFINE_SPEC(0, is_integral, long, true)\n-  _DEFINE_SPEC(0, is_integral, unsigned long, true)\n-  _DEFINE_SPEC(0, is_integral, long long, true)\n-  _DEFINE_SPEC(0, is_integral, unsigned long long, true)\n-\n-  template<typename>\n-    struct is_floating_point\n-    : public false_type { };\n-  _DEFINE_SPEC(0, is_floating_point, float, true)\n-  _DEFINE_SPEC(0, is_floating_point, double, true)\n-  _DEFINE_SPEC(0, is_floating_point, long double, true)\n-\n-  template<typename>\n-    struct is_array\n-    : public false_type { };\n-\n-  template<typename _Tp, std::size_t _Size>\n-    struct is_array<_Tp[_Size]>\n-    : public true_type { };\n-\n-  template<typename _Tp>\n-    struct is_array<_Tp[]>\n-    : public true_type { };\n-\n-  template<typename>\n-    struct is_pointer\n-    : public false_type { };\n-  _DEFINE_SPEC(1, is_pointer, _Tp*, true)\n- \n-  template<typename>\n-    struct is_reference\n-    : public false_type { };\n-\n-  template<typename _Tp>\n-    struct is_reference<_Tp&>\n-    : public true_type { };\n-\n-  template<typename>\n-    struct is_member_object_pointer\n-    : public false_type { };\n-  _DEFINE_SPEC(2, is_member_object_pointer, _Tp _Cp::*,\n-\t       !is_function<_Tp>::value)\n-\n-  template<typename>\n-    struct is_member_function_pointer\n-    : public false_type { };\n-  _DEFINE_SPEC(2, is_member_function_pointer, _Tp _Cp::*,\n-\t       is_function<_Tp>::value)\n-\n-  template<typename _Tp>\n-    struct is_enum\n-    : public integral_constant<bool, __is_enum(_Tp)>\n-    { };\n-\n-  template<typename _Tp>\n-    struct is_union\n-    : public integral_constant<bool, __is_union(_Tp)>\n-    { };\n-\n-  template<typename _Tp>\n-    struct is_class\n-    : public integral_constant<bool, __is_class(_Tp)>\n-    { };\n-\n-  template<typename>\n-    struct __is_function_helper\n-    : public false_type { };\n-\n-  template<typename _Res, typename... _ArgTypes>\n-    struct __is_function_helper<_Res(_ArgTypes...)>\n-    : public true_type { };\n-\n-  template<typename _Res, typename... _ArgTypes>\n-    struct __is_function_helper<_Res(_ArgTypes......)>\n-    : public true_type { };\n-\n-  template<typename _Tp>\n-    struct is_function\n-    : public integral_constant<bool, (__is_function_helper<typename\n-\t\t\t\t      remove_cv<_Tp>::type>::value)>\n-    { };\n-\n-  /// @brief  composite type traits [4.5.2].\n-  template<typename _Tp>\n-    struct is_arithmetic\n-    : public integral_constant<bool, (is_integral<_Tp>::value\n-\t\t\t\t      || is_floating_point<_Tp>::value)>\n-    { };\n-\n-  template<typename _Tp>\n-    struct is_fundamental\n-    : public integral_constant<bool, (is_arithmetic<_Tp>::value\n-\t\t\t\t      || is_void<_Tp>::value)>\n-    { };\n-\n-  template<typename _Tp>\n-    struct is_object\n-    : public integral_constant<bool, !(is_function<_Tp>::value\n-\t\t\t\t       || is_reference<_Tp>::value\n-\t\t\t\t       || is_void<_Tp>::value)>\n-    { };\n-\n-  template<typename _Tp>\n-    struct is_scalar\n-    : public integral_constant<bool, (is_arithmetic<_Tp>::value\n-\t\t\t\t      || is_enum<_Tp>::value\n-\t\t\t\t      || is_pointer<_Tp>::value\n-\t\t\t\t      || is_member_pointer<_Tp>::value)>\n-    { };\n-\n-  template<typename _Tp>\n-    struct is_compound\n-    : public integral_constant<bool, !is_fundamental<_Tp>::value> { };\n-\n-  template<typename _Tp>\n-    struct is_member_pointer\n-    : public integral_constant<bool,\n-\t\t\t       (is_member_object_pointer<_Tp>::value\n-\t\t\t\t|| is_member_function_pointer<_Tp>::value)>\n-    { };\n-\n-  /// @brief  type properties [4.5.3].\n-  template<typename>\n-    struct is_const\n+    struct is_signed\n     : public false_type { };\n+  _DEFINE_SPEC(0, is_signed, signed char, true)\n+  _DEFINE_SPEC(0, is_signed, short, true)\n+  _DEFINE_SPEC(0, is_signed, int, true)\n+  _DEFINE_SPEC(0, is_signed, long, true)\n+  _DEFINE_SPEC(0, is_signed, long long, true)\n \n-  template<typename _Tp>\n-    struct is_const<_Tp const>\n-    : public true_type { };\n-  \n   template<typename>\n-    struct is_volatile\n+    struct is_unsigned\n     : public false_type { };\n-\n-  template<typename _Tp>\n-    struct is_volatile<_Tp volatile>\n-    : public true_type { };\n+  _DEFINE_SPEC(0, is_unsigned, unsigned char, true)\n+  _DEFINE_SPEC(0, is_unsigned, unsigned short, true)\n+  _DEFINE_SPEC(0, is_unsigned, unsigned int, true)\n+  _DEFINE_SPEC(0, is_unsigned, unsigned long, true)\n+  _DEFINE_SPEC(0, is_unsigned, unsigned long long, true)\n \n   template<typename _Tp>\n     struct is_pod\n     : public integral_constant<bool, __is_pod(_Tp) || is_void<_Tp>::value>\n     { };\n \n-  template<typename _Tp>\n-    struct is_empty\n-    : public integral_constant<bool, __is_empty(_Tp)>\n-    { };\n-\n-  template<typename _Tp>\n-    struct is_polymorphic\n-    : public integral_constant<bool, __is_polymorphic(_Tp)>\n-    { };\n-\n-  template<typename _Tp>\n-    struct is_abstract\n-    : public integral_constant<bool, __is_abstract(_Tp)>\n-    { };\n-\n   template<typename _Tp>\n     struct has_trivial_constructor\n-    : public integral_constant<bool, is_pod<_Tp>::value> { };\n+    : public integral_constant<bool, is_pod<_Tp>::value>\n+    { };\n \n   template<typename _Tp>\n     struct has_trivial_copy\n-    : public integral_constant<bool, is_pod<_Tp>::value> { };\n+    : public integral_constant<bool, is_pod<_Tp>::value>\n+    { };\n \n   template<typename _Tp>\n     struct has_trivial_assign\n-    : public integral_constant<bool, is_pod<_Tp>::value> { };\n+    : public integral_constant<bool, is_pod<_Tp>::value>\n+    { };\n \n   template<typename _Tp>\n     struct has_trivial_destructor\n-    : public integral_constant<bool, is_pod<_Tp>::value> { };\n+    : public integral_constant<bool, is_pod<_Tp>::value>\n+    { };\n \n   template<typename _Tp>\n     struct has_nothrow_constructor\n-    : public integral_constant<bool, is_pod<_Tp>::value> { };\n+    : public integral_constant<bool, is_pod<_Tp>::value>\n+    { };\n \n   template<typename _Tp>\n     struct has_nothrow_copy\n-    : public integral_constant<bool, is_pod<_Tp>::value> { };\n-\n-  template<typename _Tp>\n-    struct has_nothrow_assign\n-    : public integral_constant<bool, is_pod<_Tp>::value> { };\n-\n-  template<typename _Tp>\n-    struct has_virtual_destructor\n-    : public integral_constant<bool, __has_virtual_destructor(_Tp)>\n+    : public integral_constant<bool, is_pod<_Tp>::value>\n     { };\n \n-  template<typename>\n-    struct is_signed\n-    : public false_type { };\n-  _DEFINE_SPEC(0, is_signed, signed char, true)\n-  _DEFINE_SPEC(0, is_signed, short, true)\n-  _DEFINE_SPEC(0, is_signed, int, true)\n-  _DEFINE_SPEC(0, is_signed, long, true)\n-  _DEFINE_SPEC(0, is_signed, long long, true)\n-\n-  template<typename>\n-    struct is_unsigned\n-    : public false_type { };\n-  _DEFINE_SPEC(0, is_unsigned, unsigned char, true)\n-  _DEFINE_SPEC(0, is_unsigned, unsigned short, true)\n-  _DEFINE_SPEC(0, is_unsigned, unsigned int, true)\n-  _DEFINE_SPEC(0, is_unsigned, unsigned long, true)\n-  _DEFINE_SPEC(0, is_unsigned, unsigned long long, true)\n-\n   template<typename _Tp>\n-    struct alignment_of\n-    : public integral_constant<std::size_t, __alignof__(_Tp)> { };\n-  \n-  template<typename>\n-    struct rank\n-    : public integral_constant<std::size_t, 0> { };\n-   \n-  template<typename _Tp, std::size_t _Size>\n-    struct rank<_Tp[_Size]>\n-    : public integral_constant<std::size_t, 1 + rank<_Tp>::value> { };\n-\n-  template<typename _Tp>\n-    struct rank<_Tp[]>\n-    : public integral_constant<std::size_t, 1 + rank<_Tp>::value> { };\n-   \n-  template<typename, unsigned>\n-    struct extent\n-    : public integral_constant<std::size_t, 0> { };\n-  \n-  template<typename _Tp, unsigned _Uint, std::size_t _Size>\n-    struct extent<_Tp[_Size], _Uint>\n-    : public integral_constant<std::size_t,\n-\t\t\t       _Uint == 0 ? _Size : extent<_Tp,\n-\t\t\t\t\t\t\t   _Uint - 1>::value>\n-    { };\n-\n-  template<typename _Tp, unsigned _Uint>\n-    struct extent<_Tp[], _Uint>\n-    : public integral_constant<std::size_t,\n-\t\t\t       _Uint == 0 ? 0 : extent<_Tp,\n-\t\t\t\t\t\t       _Uint - 1>::value>\n+    struct has_nothrow_assign\n+    : public integral_constant<bool, is_pod<_Tp>::value>\n     { };\n-  \n-  /// @brief  relationships between types [4.6].\n-  template<typename, typename>\n-    struct is_same\n-    : public false_type { };\n-\n-  template<typename _Tp>\n-    struct is_same<_Tp, _Tp>\n-    : public true_type { };\n \n   template<typename _Base, typename _Derived>\n     struct __is_base_of_helper\n@@ -427,188 +198,10 @@ _GLIBCXX_BEGIN_NAMESPACE(_GLIBCXX_TR1)\n \t\t\t       __is_convertible_helper<_From, _To>::__value>\n     { };\n \n-  /// @brief  const-volatile modifications [4.7.1].\n-  template<typename _Tp>\n-    struct remove_const\n-    { typedef _Tp     type; };\n-\n-  template<typename _Tp>\n-    struct remove_const<_Tp const>\n-    { typedef _Tp     type; };\n-  \n-  template<typename _Tp>\n-    struct remove_volatile\n-    { typedef _Tp     type; };\n-\n-  template<typename _Tp>\n-    struct remove_volatile<_Tp volatile>\n-    { typedef _Tp     type; };\n-  \n-  template<typename _Tp>\n-    struct remove_cv\n-    {\n-      typedef typename\n-      remove_const<typename remove_volatile<_Tp>::type>::type     type;\n-    };\n-  \n-  template<typename _Tp>\n-    struct add_const\n-    { typedef _Tp const     type; };\n-   \n-  template<typename _Tp>\n-    struct add_volatile\n-    { typedef _Tp volatile     type; };\n-  \n-  template<typename _Tp>\n-    struct add_cv\n-    {\n-      typedef typename\n-      add_const<typename add_volatile<_Tp>::type>::type     type;\n-    };\n-\n-  /// @brief  reference modifications [4.7.2].\n-  template<typename _Tp>\n-    struct remove_reference\n-    { typedef _Tp     type; };\n-\n-  template<typename _Tp>\n-    struct remove_reference<_Tp&>\n-    { typedef _Tp     type; };\n-\n-  // NB: Careful with reference to void.\n-  template<typename _Tp, bool = (is_void<_Tp>::value\n-\t\t\t\t || is_reference<_Tp>::value)>\n-    struct __add_reference_helper\n-    { typedef _Tp&    type; };\n-\n-  template<typename _Tp>\n-    struct __add_reference_helper<_Tp, true>\n-    { typedef _Tp     type; };\n-\n-  template<typename _Tp>\n-    struct add_reference\n-    : public __add_reference_helper<_Tp>\n-    { };\n-\n-  /// @brief  array modifications [4.7.3].\n-  template<typename _Tp>\n-    struct remove_extent\n-    { typedef _Tp     type; };\n-\n-  template<typename _Tp, std::size_t _Size>\n-    struct remove_extent<_Tp[_Size]>\n-    { typedef _Tp     type; };\n-\n-  template<typename _Tp>\n-    struct remove_extent<_Tp[]>\n-    { typedef _Tp     type; };\n-\n-  template<typename _Tp>\n-    struct remove_all_extents\n-    { typedef _Tp     type; };\n-\n-  template<typename _Tp, std::size_t _Size>\n-    struct remove_all_extents<_Tp[_Size]>\n-    { typedef typename remove_all_extents<_Tp>::type     type; };\n-\n-  template<typename _Tp>\n-    struct remove_all_extents<_Tp[]>\n-    { typedef typename remove_all_extents<_Tp>::type     type; };\n-\n-  /// @brief  pointer modifications [4.7.4].\n-#undef _DEFINE_SPEC_BODY\n-#define _DEFINE_SPEC_BODY(_Value)      \\\n-    { typedef _Tp     type; };\n-\n-  template<typename _Tp>\n-    struct remove_pointer\n-    { typedef _Tp     type; };\n-  _DEFINE_SPEC(1, remove_pointer, _Tp*, false)\n-  \n-  template<typename _Tp>\n-    struct add_pointer\n-    { typedef typename remove_reference<_Tp>::type*     type; };\n-\n-  /// @brief  other transformations [4.8].\n-  \n-  // Due to c++/19163 and c++/17743, for the time being we cannot use\n-  // the correct, neat implementation :-(\n-  // \n-  // template<std::size_t _Len, std::size_t _Align>\n-  //   struct aligned_storage\n-  //   { typedef char type[_Len] __attribute__((__aligned__(_Align))); }\n-  //\n-  // Temporary workaround, useful for Align up to 32:\n-  template<std::size_t, std::size_t>\n-    struct aligned_storage { };\n-\n-  template<std::size_t _Len>\n-    struct aligned_storage<_Len, 1>\n-    {\n-      union type\n-      {\n-\tunsigned char __data[_Len];\n-\tchar __align __attribute__((__aligned__(1)));\n-      };\n-    };\n-\n-  template<std::size_t _Len>\n-    struct aligned_storage<_Len, 2>\n-    {\n-      union type\n-      {\n-\tunsigned char __data[_Len];\n-\tchar __align __attribute__((__aligned__(2)));\n-      };\n-    };\n-\n-  template<std::size_t _Len>\n-    struct aligned_storage<_Len, 4>\n-    {\n-      union type\n-      {\n-\tunsigned char __data[_Len];\n-\tchar __align __attribute__((__aligned__(4)));\n-      };\n-    };\n-\n-  template<std::size_t _Len>\n-    struct aligned_storage<_Len, 8>\n-    {\n-      union type\n-      {\n-\tunsigned char __data[_Len];\n-\tchar __align __attribute__((__aligned__(8)));\n-      };\n-    };\n-\n-  template<std::size_t _Len>\n-    struct aligned_storage<_Len, 16>\n-    {\n-      union type\n-      {\n-\tunsigned char __data[_Len];\n-\tchar __align __attribute__((__aligned__(16)));\n-      };\n-    };\n-  \n-  template<std::size_t _Len>\n-    struct aligned_storage<_Len, 32>\n-    {\n-      union type\n-      {\n-\tunsigned char __data[_Len];\n-\tchar __align __attribute__((__aligned__(32)));\n-      };\n-    };\n-\n #undef _DEFINE_SPEC_0_HELPER\n-#undef _DEFINE_SPEC_1_HELPER\n-#undef _DEFINE_SPEC_2_HELPER\n #undef _DEFINE_SPEC\n #undef _DEFINE_SPEC_BODY\n-\n-_GLIBCXX_END_NAMESPACE\n+}\n }\n \n-#endif\n+#endif // _GLIBCXX_TR1_TYPE_TRAITS"}, {"sha": "85e8f0015c475c756116a4994b12baa87d5e4d13", "filename": "libstdc++-v3/include/tr1/unordered_map", "status": "modified", "additions": 33, "deletions": 202, "changes": 235, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e133ace8d907bf42754c86106fc3f04a9d9fe70f/libstdc%2B%2B-v3%2Finclude%2Ftr1%2Funordered_map", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e133ace8d907bf42754c86106fc3f04a9d9fe70f/libstdc%2B%2B-v3%2Finclude%2Ftr1%2Funordered_map", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Ftr1%2Funordered_map?ref=e133ace8d907bf42754c86106fc3f04a9d9fe70f", "patch": "@@ -31,206 +31,37 @@\n  *  This is a TR1 C++ Library header. \n  */\n \n-#ifndef _TR1_UNORDERED_MAP\n-#define _TR1_UNORDERED_MAP 1\n-\n-#include <tr1/hashtable>\n+#ifndef _GLIBCXX_TR1_UNORDERED_MAP\n+#define _GLIBCXX_TR1_UNORDERED_MAP 1\n+\n+#pragma GCC system_header\n+\n+#if defined(_GLIBCXX_INCLUDE_AS_CXX0X)\n+#  error TR1 header cannot be included from C++0x header\n+#endif\n+\n+#include <cmath>\n+#include <string>\n+#include <utility>\n+#include <algorithm> // lower_bound\n+#include <bits/allocator.h>\n+#include <bits/stl_function.h> // equal_to, _Identity, _Select1st\n+#include <tr1/type_traits>\n #include <tr1/functional_hash.h>\n-\n-namespace std\n-{\n-_GLIBCXX_BEGIN_NAMESPACE(_GLIBCXX_TR1)\n-\n-  // XXX When we get typedef templates these class definitions\n-  // will be unnecessary.\n-  template<class _Key, class _Tp,\n-\t   class _Hash = hash<_Key>,\n-\t   class _Pred = std::equal_to<_Key>,\n-\t   class _Alloc = std::allocator<std::pair<const _Key, _Tp> >,\n-\t   bool __cache_hash_code = false>\n-    class __unordered_map\n-    : public _Hashtable<_Key, std::pair<const _Key, _Tp>, _Alloc,\n-\t\t\tstd::_Select1st<std::pair<const _Key, _Tp> >, _Pred, \n-\t\t\t_Hash, __detail::_Mod_range_hashing,\n-\t\t\t__detail::_Default_ranged_hash,\n-\t\t\t__detail::_Prime_rehash_policy,\n-\t\t\t__cache_hash_code, false, true>\n-    {\n-      typedef _Hashtable<_Key, std::pair<const _Key, _Tp>, _Alloc,\n-\t\t\t std::_Select1st<std::pair<const _Key, _Tp> >, _Pred,\n-\t\t\t _Hash, __detail::_Mod_range_hashing,\n-\t\t\t __detail::_Default_ranged_hash,\n-\t\t\t __detail::_Prime_rehash_policy,\n-\t\t\t __cache_hash_code, false, true>\n-        _Base;\n-\n-    public:\n-      typedef typename _Base::size_type       size_type;\n-      typedef typename _Base::hasher          hasher;\n-      typedef typename _Base::key_equal       key_equal;\n-      typedef typename _Base::allocator_type  allocator_type;\n-\n-      explicit\n-      __unordered_map(size_type __n = 10,\n-\t\t      const hasher& __hf = hasher(),\n-\t\t      const key_equal& __eql = key_equal(),\n-\t\t      const allocator_type& __a = allocator_type())\n-      : _Base(__n, __hf, __detail::_Mod_range_hashing(),\n-\t      __detail::_Default_ranged_hash(),\n-\t      __eql, std::_Select1st<std::pair<const _Key, _Tp> >(), __a)\n-      { }\n-\n-      template<typename _InputIterator>\n-        __unordered_map(_InputIterator __f, _InputIterator __l, \n-\t\t\tsize_type __n = 10,\n-\t\t\tconst hasher& __hf = hasher(), \n-\t\t\tconst key_equal& __eql = key_equal(), \n-\t\t\tconst allocator_type& __a = allocator_type())\n-\t: _Base(__f, __l, __n, __hf, __detail::_Mod_range_hashing(),\n-\t\t__detail::_Default_ranged_hash(),\n-\t\t__eql, std::_Select1st<std::pair<const _Key, _Tp> >(), __a)\n-\t{ }\n-    };\n-  \n-  template<class _Key, class _Tp,\n-\t   class _Hash = hash<_Key>,\n-\t   class _Pred = std::equal_to<_Key>,\n-\t   class _Alloc = std::allocator<std::pair<const _Key, _Tp> >,\n-\t   bool __cache_hash_code = false>\n-    class __unordered_multimap\n-    : public _Hashtable<_Key, std::pair<const _Key, _Tp>,\n-\t\t\t_Alloc,\n-\t\t\tstd::_Select1st<std::pair<const _Key, _Tp> >, _Pred,\n-\t\t\t_Hash, __detail::_Mod_range_hashing,\n-\t\t\t__detail::_Default_ranged_hash,\n-\t\t\t__detail::_Prime_rehash_policy,\n-\t\t\t__cache_hash_code, false, false>\n-    {\n-      typedef _Hashtable<_Key, std::pair<const _Key, _Tp>,\n-\t\t\t _Alloc,\n-\t\t\t std::_Select1st<std::pair<const _Key, _Tp> >, _Pred,\n-\t\t\t _Hash, __detail::_Mod_range_hashing,\n-\t\t\t __detail::_Default_ranged_hash,\n-\t\t\t __detail::_Prime_rehash_policy,\n-\t\t\t __cache_hash_code, false, false>\n-        _Base;\n-\n-    public:\n-      typedef typename _Base::size_type       size_type;\n-      typedef typename _Base::hasher          hasher;\n-      typedef typename _Base::key_equal       key_equal;\n-      typedef typename _Base::allocator_type  allocator_type;\n-      \n-      explicit\n-      __unordered_multimap(size_type __n = 10,\n-\t\t\t   const hasher& __hf = hasher(),\n-\t\t\t   const key_equal& __eql = key_equal(),\n-\t\t\t   const allocator_type& __a = allocator_type())\n-      : _Base(__n, __hf, __detail::_Mod_range_hashing(),\n-\t      __detail::_Default_ranged_hash(),\n-\t      __eql, std::_Select1st<std::pair<const _Key, _Tp> >(), __a)\n-      { }\n-\n-\n-      template<typename _InputIterator>\n-        __unordered_multimap(_InputIterator __f, _InputIterator __l, \n-\t\t\t     typename _Base::size_type __n = 0,\n-\t\t\t     const hasher& __hf = hasher(), \n-\t\t\t     const key_equal& __eql = key_equal(), \n-\t\t\t     const allocator_type& __a = allocator_type())\n-\t: _Base(__f, __l, __n, __hf, __detail::_Mod_range_hashing(),\n-\t\t__detail::_Default_ranged_hash(),\n-\t\t__eql, std::_Select1st<std::pair<const _Key, _Tp> >(), __a)\n-        { }\n-    };\n-\n-  template<class _Key, class _Tp, class _Hash, class _Pred, class _Alloc,\n-\t   bool __cache_hash_code>\n-    inline void\n-    swap(__unordered_map<_Key, _Tp, _Hash, _Pred,\n-\t _Alloc, __cache_hash_code>& __x,\n-\t __unordered_map<_Key, _Tp, _Hash, _Pred,\n-\t _Alloc, __cache_hash_code>& __y)\n-    { __x.swap(__y); }\n-\n-  template<class _Key, class _Tp, class _Hash, class _Pred, class _Alloc,\n-\t   bool __cache_hash_code>\n-    inline void\n-    swap(__unordered_multimap<_Key, _Tp, _Hash, _Pred,\n-\t _Alloc, __cache_hash_code>& __x,\n-\t __unordered_multimap<_Key, _Tp, _Hash, _Pred,\n-\t _Alloc, __cache_hash_code>& __y)\n-    { __x.swap(__y); }\n-\n-\n-  template<class _Key, class _Tp,\n-\t   class _Hash = hash<_Key>,\n-\t   class _Pred = std::equal_to<_Key>,\n-\t   class _Alloc = std::allocator<std::pair<const _Key, _Tp> > >\n-    class unordered_map\n-    : public __unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>\n-    {\n-      typedef __unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>  _Base;\n-\n-    public:\n-      typedef typename _Base::size_type       size_type;\n-      typedef typename _Base::hasher          hasher;\n-      typedef typename _Base::key_equal       key_equal;\n-      typedef typename _Base::allocator_type  allocator_type;\n-\n-      explicit\n-      unordered_map(size_type __n = 10,\n-\t\t    const hasher& __hf = hasher(),\n-\t\t    const key_equal& __eql = key_equal(),\n-\t\t    const allocator_type& __a = allocator_type())\n-      : _Base(__n, __hf, __eql, __a)\n-      { }\n-\n-      template<typename _InputIterator>\n-        unordered_map(_InputIterator __f, _InputIterator __l, \n-\t\t      size_type __n = 10,\n-\t\t      const hasher& __hf = hasher(), \n-\t\t      const key_equal& __eql = key_equal(), \n-\t\t      const allocator_type& __a = allocator_type())\n-\t: _Base(__f, __l, __n, __hf, __eql, __a)\n-        { }\n-    };\n-  \n-  template<class _Key, class _Tp,\n-\t   class _Hash = hash<_Key>,\n-\t   class _Pred = std::equal_to<_Key>,\n-\t   class _Alloc = std::allocator<std::pair<const _Key, _Tp> > >\n-    class unordered_multimap\n-    : public __unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>\n-    {\n-      typedef __unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>  _Base;\n-\n-    public:\n-      typedef typename _Base::size_type       size_type;\n-      typedef typename _Base::hasher          hasher;\n-      typedef typename _Base::key_equal       key_equal;\n-      typedef typename _Base::allocator_type  allocator_type;\n-      \n-      explicit\n-      unordered_multimap(size_type __n = 10,\n-\t\t\t const hasher& __hf = hasher(),\n-\t\t\t const key_equal& __eql = key_equal(),\n-\t\t\t const allocator_type& __a = allocator_type())\n-      : _Base(__n, __hf, __eql, __a)\n-      { }\n-\n-\n-      template<typename _InputIterator>\n-        unordered_multimap(_InputIterator __f, _InputIterator __l, \n-\t\t\t   typename _Base::size_type __n = 0,\n-\t\t\t   const hasher& __hf = hasher(), \n-\t\t\t   const key_equal& __eql = key_equal(), \n-\t\t\t   const allocator_type& __a = allocator_type())\n-\t: _Base(__f, __l, __n, __hf, __eql, __a)\n-        { }\n-    };\n-\n-_GLIBCXX_END_NAMESPACE\n-}\n-\n-#endif // _TR1_UNORDERED_MAP\n+#include <tr1/hashtable.h>\n+\n+#if defined(_GLIBCXX_INCLUDE_AS_TR1)\n+#  include <tr1_impl/unordered_map>\n+#else\n+#  define _GLIBCXX_INCLUDE_AS_TR1\n+#  define _GLIBCXX_BEGIN_NAMESPACE_TR1 namespace tr1 {\n+#  define _GLIBCXX_END_NAMESPACE_TR1 }\n+#  define _GLIBCXX_TR1 tr1::\n+#  include <tr1_impl/unordered_map>\n+#  undef _GLIBCXX_TR1\n+#  undef _GLIBCXX_END_NAMESPACE_TR1\n+#  undef _GLIBCXX_BEGIN_NAMESPACE_TR1\n+#  undef _GLIBCXX_INCLUDE_AS_TR1\n+#endif\n+\n+#endif // _GLIBCXX_TR1_UNORDERED_MAP"}, {"sha": "35c605ff681b376ada9fffbb1b8f8683deb90629", "filename": "libstdc++-v3/include/tr1/unordered_set", "status": "modified", "additions": 33, "deletions": 200, "changes": 233, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e133ace8d907bf42754c86106fc3f04a9d9fe70f/libstdc%2B%2B-v3%2Finclude%2Ftr1%2Funordered_set", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e133ace8d907bf42754c86106fc3f04a9d9fe70f/libstdc%2B%2B-v3%2Finclude%2Ftr1%2Funordered_set", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Ftr1%2Funordered_set?ref=e133ace8d907bf42754c86106fc3f04a9d9fe70f", "patch": "@@ -31,204 +31,37 @@\n  *  This is a TR1 C++ Library header. \n  */\n \n-#ifndef _TR1_UNORDERED_SET\n-#define _TR1_UNORDERED_SET 1\n-\n-#include <tr1/hashtable>\n+#ifndef _GLIBCXX_TR1_UNORDERED_SET\n+#define _GLIBCXX_TR1_UNORDERED_SET 1\n+\n+#pragma GCC system_header\n+\n+#if defined(_GLIBCXX_INCLUDE_AS_CXX0X)\n+#  error TR1 header cannot be included from C++0x header\n+#endif\n+\n+#include <cmath>\n+#include <string>\n+#include <utility>\n+#include <algorithm> // lower_bound\n+#include <bits/allocator.h>\n+#include <bits/stl_function.h> // equal_to, _Identity, _Select1st\n+#include <tr1/type_traits>\n #include <tr1/functional_hash.h>\n-\n-namespace std\n-{ \n-_GLIBCXX_BEGIN_NAMESPACE(_GLIBCXX_TR1)\n-\n-  // XXX When we get typedef templates these class definitions\n-  // will be unnecessary.\n-  template<class _Value,\n-\t   class _Hash = hash<_Value>,\n-\t   class _Pred = std::equal_to<_Value>,\n-\t   class _Alloc = std::allocator<_Value>,\n-\t   bool __cache_hash_code = false>\n-    class __unordered_set\n-    : public _Hashtable<_Value, _Value, _Alloc,\n-\t\t\tstd::_Identity<_Value>, _Pred,\n-\t\t\t_Hash, __detail::_Mod_range_hashing,\n-\t\t\t__detail::_Default_ranged_hash,\n-\t\t\t__detail::_Prime_rehash_policy,\n-\t\t\t__cache_hash_code, true, true>\n-    {\n-      typedef _Hashtable<_Value, _Value, _Alloc,\n-\t\t\t std::_Identity<_Value>, _Pred,\n-\t\t\t _Hash, __detail::_Mod_range_hashing,\n-\t\t\t __detail::_Default_ranged_hash,\n-\t\t\t __detail::_Prime_rehash_policy,\n-\t\t\t __cache_hash_code, true, true>\n-        _Base;\n-\n-    public:\n-      typedef typename _Base::size_type       size_type;\n-      typedef typename _Base::hasher          hasher;\n-      typedef typename _Base::key_equal       key_equal;\n-      typedef typename _Base::allocator_type  allocator_type;\n-      \n-      explicit\n-      __unordered_set(size_type __n = 10,\n-\t\t      const hasher& __hf = hasher(),\n-\t\t      const key_equal& __eql = key_equal(),\n-\t\t      const allocator_type& __a = allocator_type())\n-      : _Base(__n, __hf, __detail::_Mod_range_hashing(),\n-\t      __detail::_Default_ranged_hash(), __eql,\n-\t      std::_Identity<_Value>(), __a)\n-      { }\n-\n-      template<typename _InputIterator>\n-        __unordered_set(_InputIterator __f, _InputIterator __l, \n-\t\t\tsize_type __n = 10,\n-\t\t\tconst hasher& __hf = hasher(), \n-\t\t\tconst key_equal& __eql = key_equal(), \n-\t\t\tconst allocator_type& __a = allocator_type())\n-\t: _Base(__f, __l, __n, __hf, __detail::_Mod_range_hashing(),\n-\t\t__detail::_Default_ranged_hash(), __eql,\n-\t\tstd::_Identity<_Value>(), __a)\n-        { }\n-    };\n-\n-  template<class _Value,\n-\t   class _Hash = hash<_Value>,\n-\t   class _Pred = std::equal_to<_Value>,\n-\t   class _Alloc = std::allocator<_Value>,\n-\t   bool __cache_hash_code = false>\n-    class __unordered_multiset\n-    : public _Hashtable<_Value, _Value, _Alloc,\n-\t\t\tstd::_Identity<_Value>, _Pred,\n-\t\t\t_Hash, __detail::_Mod_range_hashing,\n-\t\t\t__detail::_Default_ranged_hash,\n-\t\t\t__detail::_Prime_rehash_policy,\n-\t\t\t__cache_hash_code, true, false>\n-    {\n-      typedef _Hashtable<_Value, _Value, _Alloc,\n-\t\t\t std::_Identity<_Value>, _Pred,\n-\t\t\t _Hash, __detail::_Mod_range_hashing,\n-\t\t\t __detail::_Default_ranged_hash,\n-\t\t\t __detail::_Prime_rehash_policy,\n-\t\t\t __cache_hash_code, true, false>\n-        _Base;\n-\n-    public:\n-      typedef typename _Base::size_type       size_type;\n-      typedef typename _Base::hasher          hasher;\n-      typedef typename _Base::key_equal       key_equal;\n-      typedef typename _Base::allocator_type  allocator_type;\n-      \n-      explicit\n-      __unordered_multiset(size_type __n = 10,\n-\t\t\t   const hasher& __hf = hasher(),\n-\t\t\t   const key_equal& __eql = key_equal(),\n-\t\t\t   const allocator_type& __a = allocator_type())\n-      : _Base(__n, __hf, __detail::_Mod_range_hashing(),\n-\t      __detail::_Default_ranged_hash(), __eql,\n-\t      std::_Identity<_Value>(), __a)\n-      { }\n-\n-\n-      template<typename _InputIterator>\n-        __unordered_multiset(_InputIterator __f, _InputIterator __l, \n-\t\t\t     typename _Base::size_type __n = 0,\n-\t\t\t     const hasher& __hf = hasher(), \n-\t\t\t     const key_equal& __eql = key_equal(), \n-\t\t\t     const allocator_type& __a = allocator_type())\n-\t: _Base(__f, __l, __n, __hf, __detail::_Mod_range_hashing(),\n-\t\t__detail::_Default_ranged_hash(), __eql,\n-\t\tstd::_Identity<_Value>(), __a)\n-        { }\n-    };\n-\n-  template<class _Value, class _Hash, class _Pred, class _Alloc,\n-\t   bool __cache_hash_code>\n-    inline void\n-    swap (__unordered_set<_Value, _Hash, _Pred,\n-\t  _Alloc, __cache_hash_code>& __x,\n-\t  __unordered_set<_Value, _Hash, _Pred,\n-\t  _Alloc, __cache_hash_code>& __y)\n-    { __x.swap(__y); }\n-\n-  template<class _Value, class _Hash, class _Pred, class _Alloc,\n-\t   bool __cache_hash_code>\n-    inline void\n-    swap(__unordered_multiset<_Value, _Hash, _Pred,\n-\t _Alloc, __cache_hash_code>& __x,\n-\t __unordered_multiset<_Value, _Hash, _Pred,\n-\t _Alloc, __cache_hash_code>& __y)\n-    { __x.swap(__y); }\n-\n-\n-  template<class _Value,\n-\t   class _Hash = hash<_Value>,\n-\t   class _Pred = std::equal_to<_Value>,\n-\t   class _Alloc = std::allocator<_Value> >\n-    class unordered_set\n-    : public __unordered_set<_Value, _Hash, _Pred, _Alloc>\n-    {\n-      typedef __unordered_set<_Value, _Hash, _Pred, _Alloc>  _Base;\n-\n-    public:\n-      typedef typename _Base::size_type       size_type;\n-      typedef typename _Base::hasher          hasher;\n-      typedef typename _Base::key_equal       key_equal;\n-      typedef typename _Base::allocator_type  allocator_type;\n-      \n-      explicit\n-      unordered_set(size_type __n = 10,\n-\t\t    const hasher& __hf = hasher(),\n-\t\t    const key_equal& __eql = key_equal(),\n-\t\t    const allocator_type& __a = allocator_type())\n-      : _Base(__n, __hf, __eql, __a)\n-      { }\n-\n-      template<typename _InputIterator>\n-        unordered_set(_InputIterator __f, _InputIterator __l, \n-\t\t      size_type __n = 10,\n-\t\t      const hasher& __hf = hasher(), \n-\t\t      const key_equal& __eql = key_equal(), \n-\t\t      const allocator_type& __a = allocator_type())\n-\t: _Base(__f, __l, __n, __hf, __eql, __a)\n-        { }\n-    };\n-\n-  template<class _Value,\n-\t   class _Hash = hash<_Value>,\n-\t   class _Pred = std::equal_to<_Value>,\n-\t   class _Alloc = std::allocator<_Value> >\n-    class unordered_multiset\n-    : public __unordered_multiset<_Value, _Hash, _Pred, _Alloc>\n-    {\n-      typedef __unordered_multiset<_Value, _Hash, _Pred, _Alloc>  _Base;\n-\n-    public:\n-      typedef typename _Base::size_type       size_type;\n-      typedef typename _Base::hasher          hasher;\n-      typedef typename _Base::key_equal       key_equal;\n-      typedef typename _Base::allocator_type  allocator_type;\n-      \n-      explicit\n-      unordered_multiset(size_type __n = 10,\n-\t\t\t const hasher& __hf = hasher(),\n-\t\t\t const key_equal& __eql = key_equal(),\n-\t\t\t const allocator_type& __a = allocator_type())\n-      : _Base(__n, __hf, __eql, __a)\n-      { }\n-\n-\n-      template<typename _InputIterator>\n-        unordered_multiset(_InputIterator __f, _InputIterator __l, \n-\t\t\t   typename _Base::size_type __n = 0,\n-\t\t\t   const hasher& __hf = hasher(), \n-\t\t\t   const key_equal& __eql = key_equal(), \n-\t\t\t   const allocator_type& __a = allocator_type())\n-\t: _Base(__f, __l, __n, __hf, __eql, __a)\n-        { }\n-    };\n-\n-_GLIBCXX_END_NAMESPACE\n-}\n-\n-#endif // _TR1_UNORDERED_SET\n+#include <tr1/hashtable.h>\n+\n+#if defined(_GLIBCXX_INCLUDE_AS_TR1)\n+#  include <tr1_impl/unordered_set>\n+#else\n+#  define _GLIBCXX_INCLUDE_AS_TR1\n+#  define _GLIBCXX_BEGIN_NAMESPACE_TR1 namespace tr1 {\n+#  define _GLIBCXX_END_NAMESPACE_TR1 }\n+#  define _GLIBCXX_TR1 tr1::\n+#  include <tr1_impl/unordered_set>\n+#  undef _GLIBCXX_TR1\n+#  undef _GLIBCXX_END_NAMESPACE_TR1\n+#  undef _GLIBCXX_BEGIN_NAMESPACE_TR1\n+#  undef _GLIBCXX_INCLUDE_AS_TR1\n+#endif\n+\n+#endif // _GLIBCXX_TR1_UNORDERED_SET"}, {"sha": "549411fd998533cb2475dd0636ec41c8c52e6708", "filename": "libstdc++-v3/include/tr1/utility", "status": "modified", "additions": 24, "deletions": 65, "changes": 89, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e133ace8d907bf42754c86106fc3f04a9d9fe70f/libstdc%2B%2B-v3%2Finclude%2Ftr1%2Futility", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e133ace8d907bf42754c86106fc3f04a9d9fe70f/libstdc%2B%2B-v3%2Finclude%2Ftr1%2Futility", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Ftr1%2Futility?ref=e133ace8d907bf42754c86106fc3f04a9d9fe70f", "patch": "@@ -31,72 +31,31 @@\n  *  This is a TR1 C++ Library header. \n  */\n \n-#ifndef _TR1_UTILITY\n-#define _TR1_UTILITY 1\n+#ifndef _GLIBCXX_TR1_UTILITY\n+#define _GLIBCXX_TR1_UTILITY 1\n \n-#include <utility>\n+#pragma GCC system_header\n \n-namespace std\n-{\n-_GLIBCXX_BEGIN_NAMESPACE(_GLIBCXX_TR1)\n-\n-  template<class _Tp> class tuple_size;\n-  template<int _Int, class _Tp> class tuple_element;\n-\n-   // Various functions which give std::pair a tuple-like interface.\n-  template<class _Tp1, class _Tp2>\n-    struct tuple_size<std::pair<_Tp1, _Tp2> >\n-    { static const int value = 2; };\n-\n-  template<class _Tp1, class _Tp2>\n-    const int tuple_size<std::pair<_Tp1, _Tp2> >::value;\n-\n-  template<class _Tp1, class _Tp2>\n-    struct tuple_element<0, std::pair<_Tp1, _Tp2> >\n-    { typedef _Tp1 type; };\n- \n-  template<class _Tp1, class _Tp2>\n-    struct tuple_element<1, std::pair<_Tp1, _Tp2> >\n-    { typedef _Tp2 type; };\n- \n-\n-  template<int _Int> struct __pair_get;\n-\n-  template<>\n-    struct __pair_get<0>\n-    {\n-      template<typename _Tp1, typename _Tp2>\n-      static _Tp1& __get(std::pair<_Tp1, _Tp2>& __pair)\n-      { return __pair.first; }\n-\n-      template<typename _Tp1, typename _Tp2>\n-      static const _Tp1& __const_get(const std::pair<_Tp1, _Tp2>& __pair)\n-      { return __pair.first; }\n-    };\n-\n-  template<>\n-    struct __pair_get<1>\n-    {\n-      template<typename _Tp1, typename _Tp2>\n-      static _Tp2& __get(std::pair<_Tp1, _Tp2>& __pair)\n-      { return __pair.second; }\n-\n-      template<typename _Tp1, typename _Tp2>\n-      static const _Tp2& __const_get(const std::pair<_Tp1, _Tp2>& __pair)\n-      { return __pair.second; }\n-    };\n-\n-   template<int _Int, class _Tp1, class _Tp2>\n-     inline typename tuple_element<_Int, std::pair<_Tp1, _Tp2> >::type&\n-     get(std::pair<_Tp1, _Tp2>& __in)\n-     { return __pair_get<_Int>::__get(__in); }\n- \n-   template<int _Int, class _Tp1, class _Tp2>\n-     inline const typename tuple_element<_Int, std::pair<_Tp1, _Tp2> >::type&\n-     get(const std::pair<_Tp1, _Tp2>& __in)\n-     { return __pair_get<_Int>::__const_get(__in); }\n-\n-_GLIBCXX_END_NAMESPACE\n-} \n+#if defined(_GLIBCXX_INCLUDE_AS_CXX0X)\n+#  error TR1 header cannot be included from C++0x header\n+#endif\n \n+#include <bits/c++config.h>\n+#include <bits/stl_relops.h>\n+#include <bits/stl_pair.h>\n+\n+#if defined(_GLIBCXX_INCLUDE_AS_TR1)\n+#  include <tr1_impl/utility>\n+#else\n+#  define _GLIBCXX_INCLUDE_AS_TR1\n+#  define _GLIBCXX_BEGIN_NAMESPACE_TR1 namespace tr1 {\n+#  define _GLIBCXX_END_NAMESPACE_TR1 }\n+#  define _GLIBCXX_TR1 tr1::\n+#  include <tr1_impl/utility>\n+#  undef _GLIBCXX_TR1\n+#  undef _GLIBCXX_END_NAMESPACE_TR1\n+#  undef _GLIBCXX_BEGIN_NAMESPACE_TR1\n+#  undef _GLIBCXX_INCLUDE_AS_TR1\n #endif\n+\n+#endif // _GLIBCXX_TR1_UTILITY"}, {"sha": "f14a47de1a0dcd923ae5b88ceeb701028ad24fc9", "filename": "libstdc++-v3/include/tr1/wchar.h", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e133ace8d907bf42754c86106fc3f04a9d9fe70f/libstdc%2B%2B-v3%2Finclude%2Ftr1%2Fwchar.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e133ace8d907bf42754c86106fc3f04a9d9fe70f/libstdc%2B%2B-v3%2Finclude%2Ftr1%2Fwchar.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Ftr1%2Fwchar.h?ref=e133ace8d907bf42754c86106fc3f04a9d9fe70f", "patch": "@@ -1,6 +1,6 @@\n // TR1 wchar.h -*- C++ -*-\n \n-// Copyright (C) 2006 Free Software Foundation, Inc.\n+// Copyright (C) 2006, 2007 Free Software Foundation, Inc.\n //\n // This file is part of the GNU ISO C++ Library.  This library is free\n // software; you can redistribute it and/or modify it under the\n@@ -31,9 +31,9 @@\n  *  This is a TR1 C++ Library header. \n  */\n \n-#ifndef _TR1_WCHAR_H\n-#define _TR1_WCHAR_H 1\n+#ifndef _GLIBCXX_TR1_WCHAR_H\n+#define _GLIBCXX_TR1_WCHAR_H 1\n \n #include <tr1/cwchar>\n \n-#endif\n+#endif // _GLIBCXX_TR1_WCHAR_H"}, {"sha": "1337c9b0fad32fcb52ab15443bec242b2040deea", "filename": "libstdc++-v3/include/tr1/wctype.h", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e133ace8d907bf42754c86106fc3f04a9d9fe70f/libstdc%2B%2B-v3%2Finclude%2Ftr1%2Fwctype.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e133ace8d907bf42754c86106fc3f04a9d9fe70f/libstdc%2B%2B-v3%2Finclude%2Ftr1%2Fwctype.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Ftr1%2Fwctype.h?ref=e133ace8d907bf42754c86106fc3f04a9d9fe70f", "patch": "@@ -1,6 +1,6 @@\n // TR1 wctype.h -*- C++ -*-\n \n-// Copyright (C) 2006 Free Software Foundation, Inc.\n+// Copyright (C) 2006, 2007 Free Software Foundation, Inc.\n //\n // This file is part of the GNU ISO C++ Library.  This library is free\n // software; you can redistribute it and/or modify it under the\n@@ -31,9 +31,9 @@\n  *  This is a TR1 C++ Library header. \n  */\n \n-#ifndef _TR1_WCTYPE_H\n-#define _TR1_WCTYPE_H 1\n+#ifndef _GLIBCXX_TR1_WCTYPE_H\n+#define _GLIBCXX_TR1_WCTYPE_H 1\n \n #include <tr1/cwctype>\n \n-#endif\n+#endif // _GLIBCXX_TR1_WCTYPE_H"}, {"sha": "0fda088aa53c8fab7b9badf096e812ac1c96d13d", "filename": "libstdc++-v3/include/tr1_impl/array", "status": "added", "additions": 239, "deletions": 0, "changes": 239, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e133ace8d907bf42754c86106fc3f04a9d9fe70f/libstdc%2B%2B-v3%2Finclude%2Ftr1_impl%2Farray", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e133ace8d907bf42754c86106fc3f04a9d9fe70f/libstdc%2B%2B-v3%2Finclude%2Ftr1_impl%2Farray", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Ftr1_impl%2Farray?ref=e133ace8d907bf42754c86106fc3f04a9d9fe70f", "patch": "@@ -0,0 +1,239 @@\n+// class template array -*- C++ -*-\n+\n+// Copyright (C) 2007 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301,\n+// USA.\n+\n+// As a special exception, you may use this file as part of a free software\n+// library without restriction.  Specifically, if other files instantiate\n+// templates or use macros or inline functions from this file, or you compile\n+// this file and link it with other files to produce an executable, this\n+// file does not by itself cause the resulting executable to be covered by\n+// the GNU General Public License.  This exception does not however\n+// invalidate any other reasons why the executable file might be covered by\n+// the GNU General Public License.\n+\n+/** @file tr1_impl/array\n+ *  This is an internal header file, included by other library headers.\n+ *  You should not attempt to use it directly.\n+ */\n+\n+namespace std\n+{\n+_GLIBCXX_BEGIN_NAMESPACE_TR1\n+\n+  /// @brief  struct array [6.2.2].\n+  /// NB: Requires complete type _Tp.\n+  template<typename _Tp, std::size_t _Nm>\n+    struct array\n+    {\n+      typedef _Tp \t    \t\t\t      value_type;\n+      typedef value_type&                   \t      reference;\n+      typedef const value_type&             \t      const_reference;\n+      typedef value_type*          \t\t      iterator;\n+      typedef const value_type*\t\t\t      const_iterator;\n+      typedef std::size_t                    \t      size_type;\n+      typedef std::ptrdiff_t                   \t      difference_type;\n+      typedef std::reverse_iterator<iterator>\t      reverse_iterator;\n+      typedef std::reverse_iterator<const_iterator>   const_reverse_iterator;\n+\n+      // Support for zero-sized arrays mandatory.\n+      value_type _M_instance[_Nm ? _Nm : 1] __attribute__((__aligned__));\n+\n+      // No explicit construct/copy/destroy for aggregate type.\n+\n+      void \n+      assign(const value_type& __u)\n+      { std::fill_n(begin(), size(), __u); }\n+\n+      void \n+      swap(array& __other)\n+      { std::swap_ranges(begin(), end(), __other.begin()); }\n+\n+      // Iterators.\n+      iterator\n+      begin()\n+      { return iterator(&_M_instance[0]); }\n+\n+      const_iterator\n+      begin() const \n+      { return const_iterator(&_M_instance[0]); }\n+\n+      iterator\n+      end() \n+      { return iterator(&_M_instance[_Nm]); }\n+\n+      const_iterator\n+      end() const\n+      { return const_iterator(&_M_instance[_Nm]); }\n+\n+      reverse_iterator \n+      rbegin()\n+      { return reverse_iterator(end()); }\n+\n+      const_reverse_iterator \n+      rbegin() const\n+      { return const_reverse_iterator(end()); }\n+\n+      reverse_iterator \n+      rend()\n+      { return reverse_iterator(begin()); }\n+\n+      const_reverse_iterator \n+      rend() const\n+      { return const_reverse_iterator(begin()); }\n+\n+      // Capacity.\n+      size_type \n+      size() const { return _Nm; }\n+\n+      size_type \n+      max_size() const { return _Nm; }\n+\n+      bool \n+      empty() const { return size() == 0; }\n+\n+      // Element access.\n+      reference\n+      operator[](size_type __n)\n+      { return _M_instance[__n]; }\n+\n+      const_reference\n+      operator[](size_type __n) const\n+      { return _M_instance[__n]; }\n+\n+      reference\n+      at(size_type __n)\n+      { \n+\t_M_check<_Nm>(__n);\n+\treturn _M_instance[__n];\n+      }\n+\n+      const_reference\n+      at(size_type __n) const\n+      {\n+\t_M_check<_Nm>(__n);\n+\treturn _M_instance[__n];\n+      }\n+\n+      reference \n+      front()\n+      { return *begin(); }\n+\n+      const_reference \n+      front() const\n+      { return *begin(); }\n+\n+      reference \n+      back()\n+      { return _Nm ? *(end() - 1) : *end(); }\n+\n+      const_reference \n+      back() const\n+      { return _Nm ? *(end() - 1) : *end(); }\n+\n+      _Tp* \n+      data()\n+      { return &_M_instance[0]; }\n+\n+      const _Tp* \n+      data() const\n+      { return &_M_instance[0]; }\n+\n+    private:\n+      template<std::size_t _Mm>\n+        typename __gnu_cxx::__enable_if<_Mm, void>::__type\n+        _M_check(size_type __n) const\n+        {\n+\t  if (__builtin_expect(__n >= _Mm, false))\n+\t    std::__throw_out_of_range(__N(\"array::_M_check\"));\n+\t}\n+\n+      // Avoid \"unsigned comparison with zero\" warnings.\n+      template<std::size_t _Mm>\n+        typename __gnu_cxx::__enable_if<!_Mm, void>::__type\n+        _M_check(size_type) const\n+        { std::__throw_out_of_range(__N(\"array::_M_check\")); }\n+    };\n+\n+  // Array comparisons.\n+  template<typename _Tp, std::size_t _Nm>\n+    inline bool \n+    operator==(const array<_Tp, _Nm>& __one, const array<_Tp, _Nm>& __two)\n+    { return std::equal(__one.begin(), __one.end(), __two.begin()); }\n+\n+  template<typename _Tp, std::size_t _Nm>\n+    inline bool\n+    operator!=(const array<_Tp, _Nm>& __one, const array<_Tp, _Nm>& __two)\n+    { return !(__one == __two); }\n+\n+  template<typename _Tp, std::size_t _Nm>\n+    inline bool\n+    operator<(const array<_Tp, _Nm>& __a, const array<_Tp, _Nm>& __b)\n+    { \n+      return std::lexicographical_compare(__a.begin(), __a.end(),\n+\t\t\t\t\t  __b.begin(), __b.end()); \n+    }\n+\n+  template<typename _Tp, std::size_t _Nm>\n+    inline bool\n+    operator>(const array<_Tp, _Nm>& __one, const array<_Tp, _Nm>& __two)\n+    { return __two < __one; }\n+\n+  template<typename _Tp, std::size_t _Nm>\n+    inline bool\n+    operator<=(const array<_Tp, _Nm>& __one, const array<_Tp, _Nm>& __two)\n+    { return !(__one > __two); }\n+\n+  template<typename _Tp, std::size_t _Nm>\n+    inline bool\n+    operator>=(const array<_Tp, _Nm>& __one, const array<_Tp, _Nm>& __two)\n+    { return !(__one < __two); }\n+\n+  // Specialized algorithms [6.2.2.2].\n+  template<typename _Tp, std::size_t _Nm>\n+    inline void\n+    swap(array<_Tp, _Nm>& __one, array<_Tp, _Nm>& __two)\n+    { std::swap_ranges(__one.begin(), __one.end(), __two.begin()); }\n+\n+  // Tuple interface to class template array [6.2.2.5].\n+  template<typename _Tp> class tuple_size;\n+  template<int _Int, typename _Tp> class tuple_element;\n+\n+  template<typename _Tp, std::size_t _Nm>\n+    struct tuple_size<array<_Tp, _Nm> >\n+    { static const int value = _Nm; };\n+\n+  template<typename _Tp, std::size_t _Nm>\n+    const int tuple_size<array<_Tp, _Nm> >::value;\n+\n+  template<int _Int, typename _Tp, std::size_t _Nm>\n+    struct tuple_element<_Int, array<_Tp, _Nm> >\n+    { typedef _Tp type; };\n+\n+  template<int _Int, typename _Tp, std::size_t _Nm>\n+    inline _Tp&\n+    get(array<_Tp, _Nm>& __arr)\n+    { return __arr[_Int]; }\n+\n+  template<int _Int, typename _Tp, std::size_t _Nm>\n+    inline const _Tp&\n+    get(const array<_Tp, _Nm>& __arr)\n+    { return __arr[_Int]; }\n+\n+_GLIBCXX_END_NAMESPACE_TR1\n+}"}, {"sha": "1a1af5ccd778ae2eaa38652127e8af05c91332de", "filename": "libstdc++-v3/include/tr1_impl/boost_shared_ptr.h", "status": "renamed", "additions": 6, "deletions": 11, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e133ace8d907bf42754c86106fc3f04a9d9fe70f/libstdc%2B%2B-v3%2Finclude%2Ftr1_impl%2Fboost_shared_ptr.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e133ace8d907bf42754c86106fc3f04a9d9fe70f/libstdc%2B%2B-v3%2Finclude%2Ftr1_impl%2Fboost_shared_ptr.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Ftr1_impl%2Fboost_shared_ptr.h?ref=e133ace8d907bf42754c86106fc3f04a9d9fe70f", "patch": "@@ -1,6 +1,6 @@\n-// <tr1/boost_shared_ptr.h> -*- C++ -*-\n+// <tr1_impl/boost_shared_ptr.h> -*- C++ -*-\n \n-// Copyright (C) 2005, 2006, 2007 Free Software Foundation, Inc.\n+// Copyright (C) 2007 Free Software Foundation, Inc.\n //\n // This file is part of the GNU ISO C++ Library.  This library is free\n // software; you can redistribute it and/or modify it under the\n@@ -46,17 +46,14 @@\n \n // GCC Note:  based on version 1.32.0 of the Boost library.\n \n-/** @file tr1/boost_shared_ptr.h\n+/** @file tr1_impl/boost_shared_ptr.h\n  *  This is an internal header file, included by other library headers.\n  *  You should not attempt to use it directly.\n  */\n \n-#ifndef _BOOST_SHARED_PTR_H\n-#define _BOOST_SHARED_PTR_H 1\n-\n namespace std\n {\n-_GLIBCXX_BEGIN_NAMESPACE(_GLIBCXX_TR1)\n+_GLIBCXX_BEGIN_NAMESPACE_TR1\n \n   class bad_weak_ptr : public std::exception\n   {\n@@ -1141,7 +1138,5 @@ _GLIBCXX_BEGIN_NAMESPACE(_GLIBCXX_TR1)\n       mutable weak_ptr<_Tp>  _M_weak_this;\n     };\n \n-_GLIBCXX_END_NAMESPACE\n-} // namespace std\n-\n-#endif\n+_GLIBCXX_END_NAMESPACE_TR1\n+}", "previous_filename": "libstdc++-v3/include/tr1/boost_shared_ptr.h"}, {"sha": "a227ec96211170cbcbf0be1bd4ae77078f78f324", "filename": "libstdc++-v3/include/tr1_impl/cctype", "status": "added", "additions": 48, "deletions": 0, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e133ace8d907bf42754c86106fc3f04a9d9fe70f/libstdc%2B%2B-v3%2Finclude%2Ftr1_impl%2Fcctype", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e133ace8d907bf42754c86106fc3f04a9d9fe70f/libstdc%2B%2B-v3%2Finclude%2Ftr1_impl%2Fcctype", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Ftr1_impl%2Fcctype?ref=e133ace8d907bf42754c86106fc3f04a9d9fe70f", "patch": "@@ -0,0 +1,48 @@\n+// TR1 cctype -*- C++ -*-\n+\n+// Copyright (C) 2007 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301,\n+// USA.\n+\n+// As a special exception, you may use this file as part of a free software\n+// library without restriction.  Specifically, if other files instantiate\n+// templates or use macros or inline functions from this file, or you compile\n+// this file and link it with other files to produce an executable, this\n+// file does not by itself cause the resulting executable to be covered by\n+// the GNU General Public License.  This exception does not however\n+// invalidate any other reasons why the executable file might be covered by\n+// the GNU General Public License.\n+\n+/** @file tr1_impl/cctype\n+ *  This is an internal header file, included by other library headers.\n+ *  You should not attempt to use it directly.\n+ */\n+\n+#if _GLIBCXX_USE_C99_CTYPE_TR1\n+\n+#undef isblank\n+\n+namespace std\n+{\n+_GLIBCXX_BEGIN_NAMESPACE_TR1\n+\n+  using ::isblank;\n+\n+_GLIBCXX_END_NAMESPACE_TR1\n+}\n+\n+#endif"}, {"sha": "01535e07c30dc12094901c8e679f312cc7befba2", "filename": "libstdc++-v3/include/tr1_impl/cfenv", "status": "added", "additions": 77, "deletions": 0, "changes": 77, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e133ace8d907bf42754c86106fc3f04a9d9fe70f/libstdc%2B%2B-v3%2Finclude%2Ftr1_impl%2Fcfenv", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e133ace8d907bf42754c86106fc3f04a9d9fe70f/libstdc%2B%2B-v3%2Finclude%2Ftr1_impl%2Fcfenv", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Ftr1_impl%2Fcfenv?ref=e133ace8d907bf42754c86106fc3f04a9d9fe70f", "patch": "@@ -0,0 +1,77 @@\n+// TR1 cfenv -*- C++ -*-\n+\n+// Copyright (C) 2007 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301,\n+// USA.\n+\n+// As a special exception, you may use this file as part of a free software\n+// library without restriction.  Specifically, if other files instantiate\n+// templates or use macros or inline functions from this file, or you compile\n+// this file and link it with other files to produce an executable, this\n+// file does not by itself cause the resulting executable to be covered by\n+// the GNU General Public License.  This exception does not however\n+// invalidate any other reasons why the executable file might be covered by\n+// the GNU General Public License.\n+\n+/** @file tr1_impl/cfenv\n+ *  This is an internal header file, included by other library headers.\n+ *  You should not attempt to use it directly.\n+ */\n+\n+#if _GLIBCXX_USE_C99_FENV_TR1\n+\n+#include_next <fenv.h>\n+\n+#undef feclearexcept\n+#undef fegetexceptflag\n+#undef feraiseexcept\n+#undef fesetexceptflag\n+#undef fetestexcept\n+#undef fegetround\n+#undef fesetround\n+#undef fegetenv\n+#undef feholdexcept\n+#undef fesetenv\n+#undef feupdateenv\n+\n+namespace std\n+{\n+_GLIBCXX_BEGIN_NAMESPACE_TR1\n+\n+  // types\n+  using ::fenv_t;\n+  using ::fexcept_t;\n+\n+  // functions\n+  using ::feclearexcept;\n+  using ::fegetexceptflag;\n+  using ::feraiseexcept;\n+  using ::fesetexceptflag;\n+  using ::fetestexcept;\n+\n+  using ::fegetround;\n+  using ::fesetround;\n+\n+  using ::fegetenv;\n+  using ::feholdexcept;\n+  using ::fesetenv;\n+  using ::feupdateenv;\n+  \n+_GLIBCXX_END_NAMESPACE_TR1\n+}\n+\n+#endif"}, {"sha": "05b525176263e71c0b2b61f6aa8a6d7622e8a626", "filename": "libstdc++-v3/include/tr1_impl/cinttypes", "status": "added", "additions": 73, "deletions": 0, "changes": 73, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e133ace8d907bf42754c86106fc3f04a9d9fe70f/libstdc%2B%2B-v3%2Finclude%2Ftr1_impl%2Fcinttypes", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e133ace8d907bf42754c86106fc3f04a9d9fe70f/libstdc%2B%2B-v3%2Finclude%2Ftr1_impl%2Fcinttypes", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Ftr1_impl%2Fcinttypes?ref=e133ace8d907bf42754c86106fc3f04a9d9fe70f", "patch": "@@ -0,0 +1,73 @@\n+// TR1 cinttypes -*- C++ -*-\n+\n+// Copyright (C) 2007 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301,\n+// USA.\n+\n+// As a special exception, you may use this file as part of a free software\n+// library without restriction.  Specifically, if other files instantiate\n+// templates or use macros or inline functions from this file, or you compile\n+// this file and link it with other files to produce an executable, this\n+// file does not by itself cause the resulting executable to be covered by\n+// the GNU General Public License.  This exception does not however\n+// invalidate any other reasons why the executable file might be covered by\n+// the GNU General Public License.\n+\n+/** @file tr1_impl/cinttypes\n+ *  This is an internal header file, included by other library headers.\n+ *  You should not attempt to use it directly.\n+ */\n+\n+#if _GLIBCXX_USE_C99_INTTYPES_TR1\n+\n+// For 8.11.1/1 (see C99, Note 184) \n+#define __STDC_FORMAT_MACROS\n+#include_next <inttypes.h>\n+\n+namespace std\n+{\n+_GLIBCXX_BEGIN_NAMESPACE_TR1\n+\n+  // types\n+  using ::imaxdiv_t;\n+\n+  // functions\n+  using ::imaxabs;\n+\n+  // May collide with _Longlong abs(_Longlong), and is not described\n+  // anywhere outside the synopsis.  Likely, a defect.\n+  //\n+  // intmax_t abs(intmax_t)\n+\n+  using ::imaxdiv;\n+\n+  // Likewise, with lldiv_t div(_Longlong, _Longlong).\n+  //\n+  // imaxdiv_t div(intmax_t, intmax_t)\n+\n+  using ::strtoimax;\n+  using ::strtoumax;\n+\n+#ifdef _GLIBCXX_USE_WCHAR_T\n+  using ::wcstoimax;\n+  using ::wcstoumax;\n+#endif\n+\n+_GLIBCXX_END_NAMESPACE_TR1\n+}\n+\n+#endif"}, {"sha": "3bbbda21504f9a6c22b7cccde9db078a82f14da4", "filename": "libstdc++-v3/include/tr1_impl/cmath", "status": "added", "additions": 907, "deletions": 0, "changes": 907, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e133ace8d907bf42754c86106fc3f04a9d9fe70f/libstdc%2B%2B-v3%2Finclude%2Ftr1_impl%2Fcmath", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e133ace8d907bf42754c86106fc3f04a9d9fe70f/libstdc%2B%2B-v3%2Finclude%2Ftr1_impl%2Fcmath", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Ftr1_impl%2Fcmath?ref=e133ace8d907bf42754c86106fc3f04a9d9fe70f", "patch": "@@ -0,0 +1,907 @@\n+// TR1 cmath -*- C++ -*-\n+\n+// Copyright (C) 2007 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301,\n+// USA.\n+\n+// As a special exception, you may use this file as part of a free software\n+// library without restriction.  Specifically, if other files instantiate\n+// templates or use macros or inline functions from this file, or you compile\n+// this file and link it with other files to produce an executable, this\n+// file does not by itself cause the resulting executable to be covered by\n+// the GNU General Public License.  This exception does not however\n+// invalidate any other reasons why the executable file might be covered by\n+// the GNU General Public License.\n+\n+/** @file tr1_impl/cmath\n+ *  This is an internal header file, included by other library headers.\n+ *  You should not attempt to use it directly.\n+ */\n+\n+#if _GLIBCXX_USE_C99_MATH_TR1\n+\n+#undef acosh\n+#undef acoshf\n+#undef acoshl\n+#undef asinh\n+#undef asinhf\n+#undef asinhl\n+#undef atanh\n+#undef atanhf\n+#undef atanhl\n+#undef cbrt\n+#undef cbrtf\n+#undef cbrtl\n+#undef copysign\n+#undef copysignf\n+#undef copysignl\n+#undef erf\n+#undef erff\n+#undef erfl\n+#undef erfc\n+#undef erfcf\n+#undef erfcl\n+#undef exp2\n+#undef exp2f\n+#undef exp2l\n+#undef expm1\n+#undef expm1f\n+#undef expm1l\n+#undef fdim\n+#undef fdimf\n+#undef fdiml\n+#undef fma\n+#undef fmaf\n+#undef fmal\n+#undef fmax\n+#undef fmaxf\n+#undef fmaxl\n+#undef fmin\n+#undef fminf\n+#undef fminl\n+#undef hypot\n+#undef hypotf\n+#undef hypotl\n+#undef ilogb\n+#undef ilogbf\n+#undef ilogbl\n+#undef lgamma\n+#undef lgammaf\n+#undef lgammal\n+#undef llrint\n+#undef llrintf\n+#undef llrintl\n+#undef llround\n+#undef llroundf\n+#undef llroundl\n+#undef log1p\n+#undef log1pf\n+#undef log1pl\n+#undef log2\n+#undef log2f\n+#undef log2l\n+#undef logb\n+#undef logbf\n+#undef logbl\n+#undef lrint\n+#undef lrintf\n+#undef lrintl\n+#undef lround\n+#undef lroundf\n+#undef lroundl\n+#undef nan\n+#undef nanf\n+#undef nanl\n+#undef nearbyint\n+#undef nearbyintf\n+#undef nearbyintl\n+#undef nextafter\n+#undef nextafterf\n+#undef nextafterl\n+#undef nexttoward\n+#undef nexttowardf\n+#undef nexttowardl\n+#undef remainder\n+#undef remainderf\n+#undef remainderl\n+#undef remquo\n+#undef remquo\n+#undef remquo\n+#undef rint\n+#undef rintf\n+#undef rintl\n+#undef round\n+#undef roundf\n+#undef roundl\n+#undef scalbln\n+#undef scalblnf\n+#undef scalblnl\n+#undef scalbn\n+#undef scalbnf\n+#undef scalbnl\n+#undef tgamma\n+#undef tgammaf\n+#undef tgammal\n+#undef trunc\n+#undef truncf\n+#undef truncl\n+\n+#endif\n+\n+namespace std\n+{\n+_GLIBCXX_BEGIN_NAMESPACE_TR1\n+\n+#if _GLIBCXX_USE_C99_MATH_TR1\n+\n+  // types\n+  using ::double_t;\n+  using ::float_t;\n+\n+  // functions\n+  using ::acosh;\n+  using ::acoshf;\n+  using ::acoshl;\n+\n+  using ::asinh;\n+  using ::asinhf;\n+  using ::asinhl;\n+\n+  using ::atanh;\n+  using ::atanhf;\n+  using ::atanhl;\n+\n+  using ::cbrt;\n+  using ::cbrtf;\n+  using ::cbrtl;\n+\n+  using ::copysign;\n+  using ::copysignf;\n+  using ::copysignl;\n+\n+  using ::erf;\n+  using ::erff;\n+  using ::erfl;\n+\n+  using ::erfc;\n+  using ::erfcf;\n+  using ::erfcl;\n+\n+  using ::exp2;\n+  using ::exp2f;\n+  using ::exp2l;\n+\n+  using ::expm1;\n+  using ::expm1f;\n+  using ::expm1l;\n+\n+  using ::fdim;\n+  using ::fdimf;\n+  using ::fdiml;\n+\n+  using ::fma;\n+  using ::fmaf;\n+  using ::fmal;\n+\n+  using ::fmax;\n+  using ::fmaxf;\n+  using ::fmaxl;\n+\n+  using ::fmin;\n+  using ::fminf;\n+  using ::fminl;\n+\n+  using ::hypot;\n+  using ::hypotf;\n+  using ::hypotl;\n+\n+  using ::ilogb;\n+  using ::ilogbf;\n+  using ::ilogbl;\n+\n+  using ::lgamma;\n+  using ::lgammaf;\n+  using ::lgammal;\n+\n+  using ::llrint;\n+  using ::llrintf;\n+  using ::llrintl;\n+\n+  using ::llround;\n+  using ::llroundf;\n+  using ::llroundl;\n+\n+  using ::log1p;\n+  using ::log1pf;\n+  using ::log1pl;\n+\n+  using ::log2;\n+  using ::log2f;\n+  using ::log2l;\n+\n+  using ::logb;\n+  using ::logbf;\n+  using ::logbl;\n+\n+  using ::lrint;\n+  using ::lrintf;\n+  using ::lrintl;\n+\n+  using ::lround;\n+  using ::lroundf;\n+  using ::lroundl;\n+\n+  using ::nan;\n+  using ::nanf;\n+  using ::nanl;\n+\n+  using ::nearbyint;\n+  using ::nearbyintf;\n+  using ::nearbyintl;\n+\n+  using ::nextafter;\n+  using ::nextafterf;\n+  using ::nextafterl;\n+\n+  using ::nexttoward;\n+  using ::nexttowardf;\n+  using ::nexttowardl;\n+\n+  using ::remainder;\n+  using ::remainderf;\n+  using ::remainderl;\n+\n+  using ::remquo;\n+  using ::remquo;\n+  using ::remquo;\n+\n+  using ::rint;\n+  using ::rintf;\n+  using ::rintl;\n+\n+  using ::round;\n+  using ::roundf;\n+  using ::roundl;\n+\n+  using ::scalbln;\n+  using ::scalblnf;\n+  using ::scalblnl;\n+\n+  using ::scalbn;\n+  using ::scalbnf;\n+  using ::scalbnl;\n+\n+  using ::tgamma;\n+  using ::tgammaf;\n+  using ::tgammal;\n+\n+  using ::trunc;\n+  using ::truncf;\n+  using ::truncl;\n+\n+#endif\n+\n+#if _GLIBCXX_USE_C99_MATH\n+#if !_GLIBCXX_USE_C99_FP_MACROS_DYNAMIC\n+\n+  /// @brief Function template definitions [8.16.3].\n+  //\n+  using std::signbit;\n+  \n+  using std::fpclassify;\n+\n+  using std::isfinite;\n+  using std::isinf;\n+  using std::isnan;\n+  using std::isnormal;\n+\n+  using std::isgreater;\n+  using std::isgreaterequal;\n+  using std::isless;\n+  using std::islessequal;\n+  using std::islessgreater;\n+  using std::isunordered;\n+#endif\n+#endif\n+\n+#if _GLIBCXX_USE_C99_MATH_TR1\n+\n+  /// @brief Additional overloads [8.16.4].\n+  //\n+  using std::acos;\n+\n+  inline float\n+  acosh(float __x)\n+  { return __builtin_acoshf(__x); }\n+\n+  inline long double\n+  acosh(long double __x)\n+  { return __builtin_acoshl(__x); }\n+\n+  template<typename _Tp>\n+    inline typename __gnu_cxx::__promote<_Tp>::__type \n+    acosh(_Tp __x)\n+    {\n+      typedef typename __gnu_cxx::__promote<_Tp>::__type __type;\n+      return acosh(__type(__x));\n+    }\n+\n+  using std::asin;\n+\n+  inline float\n+  asinh(float __x)\n+  { return __builtin_asinhf(__x); }\n+\n+  inline long double\n+  asinh(long double __x)\n+  { return __builtin_asinhl(__x); }\n+\n+  template<typename _Tp>\n+    inline typename __gnu_cxx::__promote<_Tp>::__type \n+    asinh(_Tp __x)\n+    {\n+      typedef typename __gnu_cxx::__promote<_Tp>::__type __type;\n+      return asinh(__type(__x));\n+    }\n+\n+  using std::atan;\n+  using std::atan2;\n+\n+  inline float\n+  atanh(float __x)\n+  { return __builtin_atanhf(__x); }\n+\n+  inline long double\n+  atanh(long double __x)\n+  { return __builtin_atanhl(__x); }\n+\n+  template<typename _Tp>\n+    inline typename __gnu_cxx::__promote<_Tp>::__type \n+    atanh(_Tp __x)\n+    {\n+      typedef typename __gnu_cxx::__promote<_Tp>::__type __type;\n+      return atanh(__type(__x));\n+    }\n+\n+  inline float\n+  cbrt(float __x)\n+  { return __builtin_cbrtf(__x); }\n+\n+  inline long double\n+  cbrt(long double __x)\n+  { return __builtin_cbrtl(__x); }\n+\n+  template<typename _Tp>\n+    inline typename __gnu_cxx::__promote<_Tp>::__type \n+    cbrt(_Tp __x)\n+    {\n+      typedef typename __gnu_cxx::__promote<_Tp>::__type __type;\n+      return cbrt(__type(__x));\n+    }\n+\n+  using std::ceil;\n+\n+  inline float\n+  copysign(float __x, float __y)\n+  { return __builtin_copysignf(__x, __y); }\n+\n+  inline long double\n+  copysign(long double __x, long double __y)\n+  { return __builtin_copysignl(__x, __y); }\n+\n+  template<typename _Tp, typename _Up>\n+    inline typename __gnu_cxx::__promote_2<_Tp, _Up>::__type\n+    copysign(_Tp __x, _Up __y)\n+    {\n+      typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;\n+      return copysign(__type(__x), __type(__y));\n+    }\n+\n+  using std::cos;\n+  using std::cosh;  \n+\n+  inline float\n+  erf(float __x)\n+  { return __builtin_erff(__x); }\n+\n+  inline long double\n+  erf(long double __x)\n+  { return __builtin_erfl(__x); }\n+\n+  template<typename _Tp>\n+    inline typename __gnu_cxx::__promote<_Tp>::__type \n+    erf(_Tp __x)\n+    {\n+      typedef typename __gnu_cxx::__promote<_Tp>::__type __type;\n+      return erf(__type(__x));\n+    }\n+\n+  inline float\n+  erfc(float __x)\n+  { return __builtin_erfcf(__x); }\n+\n+  inline long double\n+  erfc(long double __x)\n+  { return __builtin_erfcl(__x); }\n+\n+  template<typename _Tp>\n+    inline typename __gnu_cxx::__promote<_Tp>::__type \n+    erfc(_Tp __x)\n+    {\n+      typedef typename __gnu_cxx::__promote<_Tp>::__type __type;\n+      return erfc(__type(__x));\n+    }\n+\n+  using std::exp;\n+\n+  inline float\n+  exp2(float __x)\n+  { return __builtin_exp2f(__x); }\n+\n+  inline long double\n+  exp2(long double __x)\n+  { return __builtin_exp2l(__x); }\n+\n+  template<typename _Tp>\n+    inline typename __gnu_cxx::__promote<_Tp>::__type \n+    exp2(_Tp __x)\n+    {\n+      typedef typename __gnu_cxx::__promote<_Tp>::__type __type;\n+      return exp2(__type(__x));\n+    }\n+\n+  inline float\n+  expm1(float __x)\n+  { return __builtin_expm1f(__x); }\n+\n+  inline long double\n+  expm1(long double __x)\n+  { return __builtin_expm1l(__x); }\n+\n+  template<typename _Tp>\n+    inline typename __gnu_cxx::__promote<_Tp>::__type \n+    expm1(_Tp __x)\n+    {\n+      typedef typename __gnu_cxx::__promote<_Tp>::__type __type;\n+      return expm1(__type(__x));\n+    }\n+\n+  using std::fabs;\n+\n+  inline float\n+  fdim(float __x, float __y)\n+  { return __builtin_fdimf(__x, __y); }\n+\n+  inline long double\n+  fdim(long double __x, long double __y)\n+  { return __builtin_fdiml(__x, __y); }\n+\n+  template<typename _Tp, typename _Up>\n+    inline typename __gnu_cxx::__promote_2<_Tp, _Up>::__type\n+    fdim(_Tp __x, _Up __y)\n+    {\n+      typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;\n+      return fdim(__type(__x), __type(__y));\n+    }\n+\n+  using std::floor;\n+\n+  inline float\n+  fma(float __x, float __y, float __z)\n+  { return __builtin_fmaf(__x, __y, __z); }\n+\n+  inline long double\n+  fma(long double __x, long double __y, long double __z)\n+  { return __builtin_fmal(__x, __y, __z); }\n+\n+  template<typename _Tp, typename _Up, typename _Vp>\n+    inline typename __gnu_cxx::__promote_3<_Tp, _Up, _Vp>::__type\n+    fma(_Tp __x, _Up __y, _Vp __z)\n+    {\n+      typedef typename __gnu_cxx::__promote_3<_Tp, _Up, _Vp>::__type __type;\n+      return fma(__type(__x), __type(__y), __type(__z));\n+    }\n+\n+  inline float\n+  fmax(float __x, float __y)\n+  { return __builtin_fmaxf(__x, __y); }\n+\n+  inline long double\n+  fmax(long double __x, long double __y)\n+  { return __builtin_fmaxl(__x, __y); }\n+\n+  template<typename _Tp, typename _Up>\n+    inline typename __gnu_cxx::__promote_2<_Tp, _Up>::__type\n+    fmax(_Tp __x, _Up __y)\n+    {\n+      typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;\n+      return fmax(__type(__x), __type(__y));\n+    }\n+\n+  inline float\n+  fmin(float __x, float __y)\n+  { return __builtin_fminf(__x, __y); }\n+\n+  inline long double\n+  fmin(long double __x, long double __y)\n+  { return __builtin_fminl(__x, __y); }\n+\n+  template<typename _Tp, typename _Up>\n+    inline typename __gnu_cxx::__promote_2<_Tp, _Up>::__type\n+    fmin(_Tp __x, _Up __y)\n+    {\n+      typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;\n+      return fmin(__type(__x), __type(__y));\n+    }\n+\n+  using std::fmod;\n+  using std::frexp;\n+\n+  inline float\n+  hypot(float __x, float __y)\n+  { return __builtin_hypotf(__x, __y); }\n+\n+  inline long double\n+  hypot(long double __x, long double __y)\n+  { return __builtin_hypotl(__x, __y); }\n+\n+  template<typename _Tp, typename _Up>\n+    inline typename __gnu_cxx::__promote_2<_Tp, _Up>::__type\n+    hypot(_Tp __x, _Up __y)\n+    {\n+      typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;\n+      return hypot(__type(__x), __type(__y));\n+    }\n+\n+  inline int\n+  ilogb(float __x)\n+  { return __builtin_ilogbf(__x); }\n+\n+  inline int\n+  ilogb(long double __x)\n+  { return __builtin_ilogbl(__x); }\n+\n+  template<typename _Tp>\n+    inline int\n+    ilogb(_Tp __x)\n+    {\n+      typedef typename __gnu_cxx::__promote<_Tp>::__type __type;\n+      return ilogb(__type(__x));\n+    }\n+\n+  using std::ldexp;\n+\n+  inline float\n+  lgamma(float __x)\n+  { return __builtin_lgammaf(__x); }\n+\n+  inline long double\n+  lgamma(long double __x)\n+  { return __builtin_lgammal(__x); }\n+\n+  template<typename _Tp>\n+    inline typename __gnu_cxx::__promote<_Tp>::__type \n+    lgamma(_Tp __x)\n+    {\n+      typedef typename __gnu_cxx::__promote<_Tp>::__type __type;\n+      return lgamma(__type(__x));\n+    }\n+\n+  inline long long\n+  llrint(float __x)\n+  { return __builtin_llrintf(__x); }\n+\n+  inline long long\n+  llrint(long double __x)\n+  { return __builtin_llrintl(__x); }\n+\n+  template<typename _Tp>\n+    inline long long\n+    llrint(_Tp __x)\n+    {\n+      typedef typename __gnu_cxx::__promote<_Tp>::__type __type;\n+      return llrint(__type(__x));\n+    }\n+\n+  inline long long\n+  llround(float __x)\n+  { return __builtin_llroundf(__x); }\n+\n+  inline long long\n+  llround(long double __x)\n+  { return __builtin_llroundl(__x); }\n+\n+  template<typename _Tp>\n+    inline long long\n+    llround(_Tp __x)\n+    {\n+      typedef typename __gnu_cxx::__promote<_Tp>::__type __type;\n+      return llround(__type(__x));\n+    }\n+\n+  using std::log;\n+  using std::log10;\n+\n+  inline float\n+  log1p(float __x)\n+  { return __builtin_log1pf(__x); }\n+\n+  inline long double\n+  log1p(long double __x)\n+  { return __builtin_log1pl(__x); }\n+\n+  template<typename _Tp>\n+    inline typename __gnu_cxx::__promote<_Tp>::__type \n+    log1p(_Tp __x)\n+    {\n+      typedef typename __gnu_cxx::__promote<_Tp>::__type __type;\n+      return log1p(__type(__x));\n+    }\n+\n+  // DR 568.\n+  inline float\n+  log2(float __x)\n+  { return __builtin_log2f(__x); }\n+\n+  inline long double\n+  log2(long double __x)\n+  { return __builtin_log2l(__x); }\n+\n+  template<typename _Tp>\n+    inline typename __gnu_cxx::__promote<_Tp>::__type \n+    log2(_Tp __x)\n+    {\n+      typedef typename __gnu_cxx::__promote<_Tp>::__type __type;\n+      return log2(__type(__x));\n+    }\n+\n+  inline float\n+  logb(float __x)\n+  { return __builtin_logbf(__x); }\n+\n+  inline long double\n+  logb(long double __x)\n+  { return __builtin_logbl(__x); }\n+\n+  template<typename _Tp>\n+    inline typename __gnu_cxx::__promote<_Tp>::__type \n+    logb(_Tp __x)\n+    {\n+      typedef typename __gnu_cxx::__promote<_Tp>::__type __type;\n+      return logb(__type(__x));\n+    }\n+\n+  inline long\n+  lrint(float __x)\n+  { return __builtin_lrintf(__x); }\n+\n+  inline long\n+  lrint(long double __x)\n+  { return __builtin_lrintl(__x); }\n+\n+  template<typename _Tp>\n+    inline long\n+    lrint(_Tp __x)\n+    {\n+      typedef typename __gnu_cxx::__promote<_Tp>::__type __type;\n+      return lrint(__type(__x));\n+    }\n+\n+  inline long\n+  lround(float __x)\n+  { return __builtin_lroundf(__x); }\n+\n+  inline long\n+  lround(long double __x)\n+  { return __builtin_lroundl(__x); }\n+\n+  template<typename _Tp>\n+    inline long\n+    lround(_Tp __x)\n+    {\n+      typedef typename __gnu_cxx::__promote<_Tp>::__type __type;\n+      return lround(__type(__x));\n+    }\n+\n+  inline float\n+  nearbyint(float __x)\n+  { return __builtin_nearbyintf(__x); }\n+\n+  inline long double\n+  nearbyint(long double __x)\n+  { return __builtin_nearbyintl(__x); }\n+\n+  template<typename _Tp>\n+    inline typename __gnu_cxx::__promote<_Tp>::__type \n+    nearbyint(_Tp __x)\n+    {\n+      typedef typename __gnu_cxx::__promote<_Tp>::__type __type;\n+      return nearbyint(__type(__x));\n+    }\n+\n+  inline float\n+  nextafter(float __x, float __y)\n+  { return __builtin_nextafterf(__x, __y); }\n+\n+  inline long double\n+  nextafter(long double __x, long double __y)\n+  { return __builtin_nextafterl(__x, __y); }\n+\n+  template<typename _Tp, typename _Up>\n+    inline typename __gnu_cxx::__promote_2<_Tp, _Up>::__type\n+    nextafter(_Tp __x, _Up __y)\n+    {\n+      typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;\n+      return nextafter(__type(__x), __type(__y));\n+    }\n+\n+  inline float\n+  nexttoward(float __x, long double __y)\n+  { return __builtin_nexttowardf(__x, __y); }\n+\n+  inline long double\n+  nexttoward(long double __x, long double __y)\n+  { return __builtin_nexttowardl(__x, __y); }\n+\n+  template<typename _Tp>\n+    inline typename __gnu_cxx::__promote<_Tp>::__type\n+    nexttoward(_Tp __x, long double __y)\n+    {\n+      typedef typename __gnu_cxx::__promote<_Tp>::__type __type;\n+      return nexttoward(__type(__x), __y);\n+    }\n+\n+  using std::pow;\n+\n+  inline float\n+  remainder(float __x, float __y)\n+  { return __builtin_remainderf(__x, __y); }\n+\n+  inline long double\n+  remainder(long double __x, long double __y)\n+  { return __builtin_remainderl(__x, __y); }\n+\n+  template<typename _Tp, typename _Up>\n+    inline typename __gnu_cxx::__promote_2<_Tp, _Up>::__type\n+    remainder(_Tp __x, _Up __y)\n+    {\n+      typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;\n+      return remainder(__type(__x), __type(__y));\n+    }\n+\n+  inline float\n+  remquo(float __x, float __y, int* __pquo)\n+  { return __builtin_remquof(__x, __y, __pquo); }\n+\n+  inline long double\n+  remquo(long double __x, long double __y, int* __pquo)\n+  { return __builtin_remquol(__x, __y, __pquo); }\n+\n+  template<typename _Tp, typename _Up>\n+    inline typename __gnu_cxx::__promote_2<_Tp, _Up>::__type\n+    remquo(_Tp __x, _Up __y, int* __pquo)\n+    {\n+      typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;\n+      return remquo(__type(__x), __type(__y), __pquo);\n+    }\n+\n+  inline float\n+  rint(float __x)\n+  { return __builtin_rintf(__x); }\n+\n+  inline long double\n+  rint(long double __x)\n+  { return __builtin_rintl(__x); }\n+\n+  template<typename _Tp>\n+    inline typename __gnu_cxx::__promote<_Tp>::__type\n+    rint(_Tp __x)\n+    {\n+      typedef typename __gnu_cxx::__promote<_Tp>::__type __type;\n+      return rint(__type(__x));\n+    }\n+\n+  inline float\n+  round(float __x)\n+  { return __builtin_roundf(__x); }\n+\n+  inline long double\n+  round(long double __x)\n+  { return __builtin_roundl(__x); }\n+\n+  template<typename _Tp>\n+    inline typename __gnu_cxx::__promote<_Tp>::__type\n+    round(_Tp __x)\n+    {\n+      typedef typename __gnu_cxx::__promote<_Tp>::__type __type;\n+      return round(__type(__x));\n+    }\n+\n+  inline float\n+  scalbln(float __x, long __ex)\n+  { return __builtin_scalblnf(__x, __ex); }\n+\n+  inline long double\n+  scalbln(long double __x, long __ex)\n+  { return __builtin_scalblnl(__x, __ex); }\n+\n+  template<typename _Tp>\n+    inline typename __gnu_cxx::__promote<_Tp>::__type \n+    scalbln(_Tp __x, long __ex)\n+    {\n+      typedef typename __gnu_cxx::__promote<_Tp>::__type __type;\n+      return scalbln(__type(__x), __ex);\n+    }\n+ \n+  inline float\n+  scalbn(float __x, int __ex)\n+  { return __builtin_scalbnf(__x, __ex); }\n+\n+  inline long double\n+  scalbn(long double __x, int __ex)\n+  { return __builtin_scalbnl(__x, __ex); }\n+\n+  template<typename _Tp>\n+    inline typename __gnu_cxx::__promote<_Tp>::__type \n+    scalbn(_Tp __x, int __ex)\n+    {\n+      typedef typename __gnu_cxx::__promote<_Tp>::__type __type;\n+      return scalbn(__type(__x), __ex);\n+    }\n+\n+  using std::sin;\n+  using std::sinh;\n+  using std::sqrt;\n+  using std::tan;\n+  using std::tanh;\n+\n+  inline float\n+  tgamma(float __x)\n+  { return __builtin_tgammaf(__x); }\n+\n+  inline long double\n+  tgamma(long double __x)\n+  { return __builtin_tgammal(__x); }\n+\n+  template<typename _Tp>\n+    inline typename __gnu_cxx::__promote<_Tp>::__type \n+    tgamma(_Tp __x)\n+    {\n+      typedef typename __gnu_cxx::__promote<_Tp>::__type __type;\n+      return tgamma(__type(__x));\n+    }\n+ \n+  inline float\n+  trunc(float __x)\n+  { return __builtin_truncf(__x); }\n+\n+  inline long double\n+  trunc(long double __x)\n+  { return __builtin_truncl(__x); }\n+\n+  template<typename _Tp>\n+    inline typename __gnu_cxx::__promote<_Tp>::__type \n+    trunc(_Tp __x)\n+    {\n+      typedef typename __gnu_cxx::__promote<_Tp>::__type __type;\n+      return trunc(__type(__x));\n+    }\n+\n+#endif\n+\n+_GLIBCXX_END_NAMESPACE_TR1\n+}"}, {"sha": "f7631829da09c1c12ccbae4e60576c90fc23d1f4", "filename": "libstdc++-v3/include/tr1_impl/complex", "status": "added", "additions": 369, "deletions": 0, "changes": 369, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e133ace8d907bf42754c86106fc3f04a9d9fe70f/libstdc%2B%2B-v3%2Finclude%2Ftr1_impl%2Fcomplex", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e133ace8d907bf42754c86106fc3f04a9d9fe70f/libstdc%2B%2B-v3%2Finclude%2Ftr1_impl%2Fcomplex", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Ftr1_impl%2Fcomplex?ref=e133ace8d907bf42754c86106fc3f04a9d9fe70f", "patch": "@@ -0,0 +1,369 @@\n+// TR1 complex -*- C++ -*-\n+\n+// Copyright (C) 2007 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301,\n+// USA.\n+\n+// As a special exception, you may use this file as part of a free software\n+// library without restriction.  Specifically, if other files instantiate\n+// templates or use macros or inline functions from this file, or you compile\n+// this file and link it with other files to produce an executable, this\n+// file does not by itself cause the resulting executable to be covered by\n+// the GNU General Public License.  This exception does not however\n+// invalidate any other reasons why the executable file might be covered by\n+// the GNU General Public License.\n+\n+/** @file tr1_impl/complex\n+ *  This is an internal header file, included by other library headers.\n+ *  You should not attempt to use it directly.\n+ */\n+\n+namespace std\n+{\n+_GLIBCXX_BEGIN_NAMESPACE_TR1\n+\n+  // Forward declarations.\n+  template<typename _Tp> std::complex<_Tp> acos(const std::complex<_Tp>&);\n+  template<typename _Tp> std::complex<_Tp> asin(const std::complex<_Tp>&);\n+  template<typename _Tp> std::complex<_Tp> atan(const std::complex<_Tp>&);\n+\n+  template<typename _Tp> std::complex<_Tp> acosh(const std::complex<_Tp>&);\n+  template<typename _Tp> std::complex<_Tp> asinh(const std::complex<_Tp>&);\n+  template<typename _Tp> std::complex<_Tp> atanh(const std::complex<_Tp>&);\n+  template<typename _Tp> std::complex<_Tp> fabs(const std::complex<_Tp>&);\n+\n+  /// @brief acos(__z) [8.1.2].\n+  //  Effects:  Behaves the same as C99 function cacos, defined\n+  //            in subclause 7.3.5.1.\n+  template<typename _Tp>\n+    inline std::complex<_Tp>\n+    __complex_acos(const std::complex<_Tp>& __z)\n+    {\n+      const std::complex<_Tp> __t = std::_GLIBCXX_TR1 asin(__z);\n+      const _Tp __pi_2 = 1.5707963267948966192313216916397514L;\n+      return std::complex<_Tp>(__pi_2 - __t.real(), -__t.imag());\n+    }\n+\n+#if _GLIBCXX_USE_C99_COMPLEX_TR1\n+  inline __complex__ float\n+  __complex_acos(__complex__ float __z)\n+  { return __builtin_cacosf(__z); }\n+\n+  inline __complex__ double\n+  __complex_acos(__complex__ double __z)\n+  { return __builtin_cacos(__z); }\n+\n+  inline __complex__ long double\n+  __complex_acos(const __complex__ long double& __z)\n+  { return __builtin_cacosl(__z); }\n+\n+  template<typename _Tp>\n+    inline std::complex<_Tp>\n+    acos(const std::complex<_Tp>& __z)\n+    { return __complex_acos(__z.__rep()); }\n+#else\n+  template<typename _Tp>\n+    inline std::complex<_Tp>\n+    acos(const std::complex<_Tp>& __z)\n+    { return __complex_acos(__z); }\n+#endif\n+\n+  /// @brief asin(__z) [8.1.3].\n+  //  Effects:  Behaves the same as C99 function casin, defined\n+  //            in subclause 7.3.5.2.\n+  template<typename _Tp>\n+    inline std::complex<_Tp>\n+    __complex_asin(const std::complex<_Tp>& __z)\n+    {\n+      std::complex<_Tp> __t(-__z.imag(), __z.real());\n+      __t = std::_GLIBCXX_TR1 asinh(__t);\n+      return std::complex<_Tp>(__t.imag(), -__t.real());\n+    }\n+\n+#if _GLIBCXX_USE_C99_COMPLEX_TR1\n+  inline __complex__ float\n+  __complex_asin(__complex__ float __z)\n+  { return __builtin_casinf(__z); }\n+\n+  inline __complex__ double\n+  __complex_asin(__complex__ double __z)\n+  { return __builtin_casin(__z); }\n+\n+  inline __complex__ long double\n+  __complex_asin(const __complex__ long double& __z)\n+  { return __builtin_casinl(__z); }\n+\n+  template<typename _Tp>\n+    inline std::complex<_Tp>\n+    asin(const std::complex<_Tp>& __z)\n+    { return __complex_asin(__z.__rep()); }\n+#else\n+  template<typename _Tp>\n+    inline std::complex<_Tp>\n+    asin(const std::complex<_Tp>& __z)\n+    { return __complex_asin(__z); }\n+#endif\n+  \n+  /// @brief atan(__z) [8.1.4].\n+  //  Effects:  Behaves the same as C99 function catan, defined\n+  //            in subclause 7.3.5.3.\n+  template<typename _Tp>\n+    std::complex<_Tp>\n+    __complex_atan(const std::complex<_Tp>& __z)\n+    {\n+      const _Tp __r2 = __z.real() * __z.real();\n+      const _Tp __x = _Tp(1.0) - __r2 - __z.imag() * __z.imag();\n+\n+      _Tp __num = __z.imag() + _Tp(1.0);\n+      _Tp __den = __z.imag() - _Tp(1.0);\n+\n+      __num = __r2 + __num * __num;\n+      __den = __r2 + __den * __den;\n+\n+      return std::complex<_Tp>(_Tp(0.5) * atan2(_Tp(2.0) * __z.real(), __x),\n+\t\t\t       _Tp(0.25) * log(__num / __den));\n+    }\n+\n+#if _GLIBCXX_USE_C99_COMPLEX_TR1\n+  inline __complex__ float\n+  __complex_atan(__complex__ float __z)\n+  { return __builtin_catanf(__z); }\n+\n+  inline __complex__ double\n+  __complex_atan(__complex__ double __z)\n+  { return __builtin_catan(__z); }\n+\n+  inline __complex__ long double\n+  __complex_atan(const __complex__ long double& __z)\n+  { return __builtin_catanl(__z); }\n+\n+  template<typename _Tp>\n+    inline std::complex<_Tp>\n+    atan(const std::complex<_Tp>& __z)\n+    { return __complex_atan(__z.__rep()); }\n+#else\n+  template<typename _Tp>\n+    inline std::complex<_Tp>\n+    atan(const std::complex<_Tp>& __z)\n+    { return __complex_atan(__z); }\n+#endif\n+\n+  /// @brief acosh(__z) [8.1.5].\n+  //  Effects:  Behaves the same as C99 function cacosh, defined\n+  //            in subclause 7.3.6.1.\n+  template<typename _Tp>\n+    std::complex<_Tp>\n+    __complex_acosh(const std::complex<_Tp>& __z)\n+    {\n+      std::complex<_Tp> __t((__z.real() - __z.imag())\n+\t\t\t    * (__z.real() + __z.imag()) - _Tp(1.0),\n+\t\t\t    _Tp(2.0) * __z.real() * __z.imag());\n+      __t = std::sqrt(__t);\n+\n+      return std::log(__t + __z);\n+    }\n+\n+#if _GLIBCXX_USE_C99_COMPLEX_TR1\n+  inline __complex__ float\n+  __complex_acosh(__complex__ float __z)\n+  { return __builtin_cacoshf(__z); }\n+\n+  inline __complex__ double\n+  __complex_acosh(__complex__ double __z)\n+  { return __builtin_cacosh(__z); }\n+\n+  inline __complex__ long double\n+  __complex_acosh(const __complex__ long double& __z)\n+  { return __builtin_cacoshl(__z); }\n+\n+  template<typename _Tp>\n+    inline std::complex<_Tp>\n+    acosh(const std::complex<_Tp>& __z)\n+    { return __complex_acosh(__z.__rep()); }\n+#else\n+  template<typename _Tp>\n+    inline std::complex<_Tp>\n+    acosh(const std::complex<_Tp>& __z)\n+    { return __complex_acosh(__z); }\n+#endif\n+\n+  /// @brief asinh(__z) [8.1.6].\n+  //  Effects:  Behaves the same as C99 function casin, defined\n+  //            in subclause 7.3.6.2.\n+  template<typename _Tp>\n+    std::complex<_Tp>\n+    __complex_asinh(const std::complex<_Tp>& __z)\n+    {\n+      std::complex<_Tp> __t((__z.real() - __z.imag())\n+\t\t\t    * (__z.real() + __z.imag()) + _Tp(1.0),\n+\t\t\t    _Tp(2.0) * __z.real() * __z.imag());\n+      __t = std::sqrt(__t);\n+\n+      return std::log(__t + __z);\n+    }\n+\n+#if _GLIBCXX_USE_C99_COMPLEX_TR1\n+  inline __complex__ float\n+  __complex_asinh(__complex__ float __z)\n+  { return __builtin_casinhf(__z); }\n+\n+  inline __complex__ double\n+  __complex_asinh(__complex__ double __z)\n+  { return __builtin_casinh(__z); }\n+\n+  inline __complex__ long double\n+  __complex_asinh(const __complex__ long double& __z)\n+  { return __builtin_casinhl(__z); }\n+\n+  template<typename _Tp>\n+    inline std::complex<_Tp>\n+    asinh(const std::complex<_Tp>& __z)\n+    { return __complex_asinh(__z.__rep()); }\n+#else\n+  template<typename _Tp>\n+    inline std::complex<_Tp>\n+    asinh(const std::complex<_Tp>& __z)\n+    { return __complex_asinh(__z); }\n+#endif\n+\n+  /// @brief atanh(__z) [8.1.7].\n+  //  Effects:  Behaves the same as C99 function catanh, defined\n+  //            in subclause 7.3.6.3.\n+  template<typename _Tp>\n+    std::complex<_Tp>\n+    __complex_atanh(const std::complex<_Tp>& __z)\n+    {\n+      const _Tp __i2 = __z.imag() * __z.imag();\n+      const _Tp __x = _Tp(1.0) - __i2 - __z.real() * __z.real();\n+\n+      _Tp __num = _Tp(1.0) + __z.real();\n+      _Tp __den = _Tp(1.0) - __z.real();\n+\n+      __num = __i2 + __num * __num;\n+      __den = __i2 + __den * __den;\n+\n+      return std::complex<_Tp>(_Tp(0.25) * (log(__num) - log(__den)),\n+\t\t\t       _Tp(0.5) * atan2(_Tp(2.0) * __z.imag(), __x));\n+    }\n+\n+#if _GLIBCXX_USE_C99_COMPLEX_TR1\n+  inline __complex__ float\n+  __complex_atanh(__complex__ float __z)\n+  { return __builtin_catanhf(__z); }\n+\n+  inline __complex__ double\n+  __complex_atanh(__complex__ double __z)\n+  { return __builtin_catanh(__z); }\n+\n+  inline __complex__ long double\n+  __complex_atanh(const __complex__ long double& __z)\n+  { return __builtin_catanhl(__z); }\n+\n+  template<typename _Tp>\n+    inline std::complex<_Tp>\n+    atanh(const std::complex<_Tp>& __z)\n+    { return __complex_atanh(__z.__rep()); }\n+#else\n+  template<typename _Tp>\n+    inline std::complex<_Tp>\n+    atanh(const std::complex<_Tp>& __z)\n+    { return __complex_atanh(__z); }\n+#endif\n+\n+  /// @brief fabs(__z) [8.1.8].\n+  //  Effects:  Behaves the same as C99 function cabs, defined\n+  //            in subclause 7.3.8.1.\n+  template<typename _Tp>\n+    inline std::complex<_Tp>\n+    fabs(const std::complex<_Tp>& __z)\n+    { return std::abs(__z); }\n+\n+\n+#if (defined(_GLIBCXX_INCLUDE_AS_CXX0X) \\\n+     || (defined(_GLIBCXX_INCLUDE_AS_TR1) \\\n+\t && !defined(__GXX_EXPERIMENTAL_CXX0X__)))\n+\n+  /// @brief Additional overloads [8.1.9].\n+  //\n+  template<typename _Tp>\n+    inline typename __gnu_cxx::__promote<_Tp>::__type\n+    arg(_Tp __x)\n+    {\n+      typedef typename __gnu_cxx::__promote<_Tp>::__type __type;\n+      return std::arg(std::complex<__type>(__x));\n+    }\n+\n+  template<typename _Tp>\n+    inline std::complex<typename __gnu_cxx::__promote<_Tp>::__type>\n+    conj(_Tp __x)\n+    { return __x; }\n+\n+  template<typename _Tp>\n+    inline typename __gnu_cxx::__promote<_Tp>::__type\n+    imag(_Tp)\n+    { return _Tp(); }\n+\n+  template<typename _Tp>\n+    inline typename __gnu_cxx::__promote<_Tp>::__type\n+    norm(_Tp __x)\n+    {\n+      typedef typename __gnu_cxx::__promote<_Tp>::__type __type;\n+      return __type(__x) * __type(__x);\n+    }\n+\n+  template<typename _Tp, typename _Up>\n+    inline std::complex<typename __gnu_cxx::__promote_2<_Tp, _Up>::__type>\n+    polar(const _Tp& __rho, const _Up& __theta)\n+    {\n+      typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;\n+      return std::polar(__type(__rho), __type(__theta));\n+    }\n+  \n+  template<typename _Tp, typename _Up>\n+    inline std::complex<typename __gnu_cxx::__promote_2<_Tp, _Up>::__type>\n+    pow(const std::complex<_Tp>& __x, const _Up& __y)\n+    {\n+      typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;\n+      return std::pow(std::complex<__type>(__x), __type(__y));\n+    }\n+\n+  template<typename _Tp, typename _Up>\n+    inline std::complex<typename __gnu_cxx::__promote_2<_Tp, _Up>::__type>\n+    pow(const _Tp& __x, const std::complex<_Up>& __y)\n+    {\n+      typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;\n+      return std::pow(__type(__x), std::complex<__type>(__y));\n+    }\n+\n+  template<typename _Tp, typename _Up>\n+    inline std::complex<typename __gnu_cxx::__promote_2<_Tp, _Up>::__type>\n+    pow(const std::complex<_Tp>& __x, const std::complex<_Up>& __y)\n+    {\n+      typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;\n+      return std::pow(std::complex<__type>(__x),\n+\t\t      std::complex<__type>(__y));\n+    }\n+\n+  template<typename _Tp>\n+    inline typename __gnu_cxx::__promote<_Tp>::__type\n+    real(_Tp __x)\n+    { return __x; }\n+\n+#endif\n+\n+_GLIBCXX_END_NAMESPACE_TR1\n+}"}, {"sha": "862ee97864b694c744d260c1cbd632927a7eca05", "filename": "libstdc++-v3/include/tr1_impl/cstdint", "status": "added", "additions": 85, "deletions": 0, "changes": 85, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e133ace8d907bf42754c86106fc3f04a9d9fe70f/libstdc%2B%2B-v3%2Finclude%2Ftr1_impl%2Fcstdint", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e133ace8d907bf42754c86106fc3f04a9d9fe70f/libstdc%2B%2B-v3%2Finclude%2Ftr1_impl%2Fcstdint", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Ftr1_impl%2Fcstdint?ref=e133ace8d907bf42754c86106fc3f04a9d9fe70f", "patch": "@@ -0,0 +1,85 @@\n+// TR1 cstdint -*- C++ -*-\n+\n+// Copyright (C) 2007 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301,\n+// USA.\n+\n+// As a special exception, you may use this file as part of a free software\n+// library without restriction.  Specifically, if other files instantiate\n+// templates or use macros or inline functions from this file, or you compile\n+// this file and link it with other files to produce an executable, this\n+// file does not by itself cause the resulting executable to be covered by\n+// the GNU General Public License.  This exception does not however\n+// invalidate any other reasons why the executable file might be covered by\n+// the GNU General Public License.\n+\n+/** @file tr1_impl/cstdint\n+ *  This is an internal header file, included by other library headers.\n+ *  You should not attempt to use it directly.\n+ */\n+\n+#if _GLIBCXX_USE_C99_STDINT_TR1\n+\n+// For 8.22.1/1 (see C99, Notes 219, 220, 222) \n+#define __STDC_LIMIT_MACROS\n+#define __STDC_CONSTANT_MACROS\n+#include_next <stdint.h>\n+\n+namespace std\n+{\n+_GLIBCXX_BEGIN_NAMESPACE_TR1\n+\n+  using ::int8_t;\n+  using ::int16_t;\n+  using ::int32_t;\n+  using ::int64_t;\n+\n+  using ::int_fast8_t;\n+  using ::int_fast16_t;\n+  using ::int_fast32_t;\n+  using ::int_fast64_t;\n+\n+  using ::int_least8_t;\n+  using ::int_least16_t;\n+  using ::int_least32_t;\n+  using ::int_least64_t;\n+\n+  using ::intmax_t;\n+  using ::intptr_t;\n+  \n+  using ::uint8_t;\n+  using ::uint16_t;\n+  using ::uint32_t;\n+  using ::uint64_t;\n+\n+  using ::uint_fast8_t;\n+  using ::uint_fast16_t;\n+  using ::uint_fast32_t;\n+  using ::uint_fast64_t;\n+\n+  using ::uint_least8_t;\n+  using ::uint_least16_t;\n+  using ::uint_least32_t;\n+  using ::uint_least64_t;\n+\n+  using ::uintmax_t;\n+  using ::uintptr_t;\n+\n+_GLIBCXX_END_NAMESPACE_TR1\n+}\n+\n+#endif"}, {"sha": "f45adea62dd0f4f6cd387a7e0e7e5ebdfdcae924", "filename": "libstdc++-v3/include/tr1_impl/cstdio", "status": "added", "additions": 49, "deletions": 0, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e133ace8d907bf42754c86106fc3f04a9d9fe70f/libstdc%2B%2B-v3%2Finclude%2Ftr1_impl%2Fcstdio", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e133ace8d907bf42754c86106fc3f04a9d9fe70f/libstdc%2B%2B-v3%2Finclude%2Ftr1_impl%2Fcstdio", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Ftr1_impl%2Fcstdio?ref=e133ace8d907bf42754c86106fc3f04a9d9fe70f", "patch": "@@ -0,0 +1,49 @@\n+// TR1 cstdio -*- C++ -*-\n+\n+// Copyright (C) 2007 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301,\n+// USA.\n+\n+// As a special exception, you may use this file as part of a free software\n+// library without restriction.  Specifically, if other files instantiate\n+// templates or use macros or inline functions from this file, or you compile\n+// this file and link it with other files to produce an executable, this\n+// file does not by itself cause the resulting executable to be covered by\n+// the GNU General Public License.  This exception does not however\n+// invalidate any other reasons why the executable file might be covered by\n+// the GNU General Public License.\n+\n+/** @file tr1_impl/cstdio\n+ *  This is an internal header file, included by other library headers.\n+ *  You should not attempt to use it directly.\n+ */\n+\n+namespace std\n+{\n+_GLIBCXX_BEGIN_NAMESPACE_TR1\n+\n+#if _GLIBCXX_USE_C99\n+  using std::snprintf;\n+  using std::vsnprintf;\n+\n+  using std::vfscanf;\n+  using std::vscanf;\n+  using std::vsscanf;\n+#endif\n+\n+_GLIBCXX_END_NAMESPACE_TR1\n+}"}, {"sha": "482f20c11b50e063ad542ed39101338950043a3d", "filename": "libstdc++-v3/include/tr1_impl/cstdlib", "status": "added", "additions": 70, "deletions": 0, "changes": 70, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e133ace8d907bf42754c86106fc3f04a9d9fe70f/libstdc%2B%2B-v3%2Finclude%2Ftr1_impl%2Fcstdlib", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e133ace8d907bf42754c86106fc3f04a9d9fe70f/libstdc%2B%2B-v3%2Finclude%2Ftr1_impl%2Fcstdlib", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Ftr1_impl%2Fcstdlib?ref=e133ace8d907bf42754c86106fc3f04a9d9fe70f", "patch": "@@ -0,0 +1,70 @@\n+// TR1 cstdlib -*- C++ -*-\n+\n+// Copyright (C) 2007 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301,\n+// USA.\n+\n+// As a special exception, you may use this file as part of a free software\n+// library without restriction.  Specifically, if other files instantiate\n+// templates or use macros or inline functions from this file, or you compile\n+// this file and link it with other files to produce an executable, this\n+// file does not by itself cause the resulting executable to be covered by\n+// the GNU General Public License.  This exception does not however\n+// invalidate any other reasons why the executable file might be covered by\n+// the GNU General Public License.\n+\n+/** @file tr1_impl/cstdlib\n+ *  This is an internal header file, included by other library headers.\n+ *  You should not attempt to use it directly.\n+ */\n+\n+#if _GLIBCXX_HOSTED\n+\n+namespace std\n+{\n+_GLIBCXX_BEGIN_NAMESPACE_TR1\n+\n+#if _GLIBCXX_USE_C99\n+\n+#if !_GLIBCXX_USE_C99_LONG_LONG_DYNAMIC\n+  // types\n+  using std::lldiv_t;\n+\n+  // functions\n+  using std::llabs;\n+  using std::lldiv;\n+#endif\n+\n+  using std::atoll;\n+  using std::strtoll;\n+  using std::strtoull;\n+\n+  using std::strtof;\n+  using std::strtold;\n+\n+  // overloads\n+  using std::abs;\n+#if !_GLIBCXX_USE_C99_LONG_LONG_DYNAMIC\n+  using std::div;\n+#endif\n+\n+#endif\n+\n+_GLIBCXX_END_NAMESPACE_TR1\n+}\n+\n+#endif"}, {"sha": "a0f8e2dc7910ea2b94e1ef800e95acd8fce8a239", "filename": "libstdc++-v3/include/tr1_impl/cwchar", "status": "added", "additions": 63, "deletions": 0, "changes": 63, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e133ace8d907bf42754c86106fc3f04a9d9fe70f/libstdc%2B%2B-v3%2Finclude%2Ftr1_impl%2Fcwchar", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e133ace8d907bf42754c86106fc3f04a9d9fe70f/libstdc%2B%2B-v3%2Finclude%2Ftr1_impl%2Fcwchar", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Ftr1_impl%2Fcwchar?ref=e133ace8d907bf42754c86106fc3f04a9d9fe70f", "patch": "@@ -0,0 +1,63 @@\n+// TR1 cwchar -*- C++ -*-\n+\n+// Copyright (C) 2007 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301,\n+// USA.\n+\n+// As a special exception, you may use this file as part of a free software\n+// library without restriction.  Specifically, if other files instantiate\n+// templates or use macros or inline functions from this file, or you compile\n+// this file and link it with other files to produce an executable, this\n+// file does not by itself cause the resulting executable to be covered by\n+// the GNU General Public License.  This exception does not however\n+// invalidate any other reasons why the executable file might be covered by\n+// the GNU General Public License.\n+\n+/** @file tr1_impl/cwchar\n+ *  This is an internal header file, included by other library headers.\n+ *  You should not attempt to use it directly.\n+ */\n+\n+#if _GLIBCXX_USE_WCHAR_T\n+\n+namespace std\n+{\n+_GLIBCXX_BEGIN_NAMESPACE_TR1\n+\n+#if _GLIBCXX_HAVE_WCSTOF\n+  using std::wcstof;\n+#endif\n+#if _GLIBCXX_HAVE_VFWSCANF\n+  using std::vfwscanf;\n+#endif\n+#if _GLIBCXX_HAVE_VSWSCANF\n+  using std::vswscanf;\n+#endif\n+#if _GLIBCXX_HAVE_VWSCANF\n+  using std::vwscanf;\n+#endif\n+\n+#if _GLIBCXX_USE_C99\n+  using std::wcstold;\n+  using std::wcstoll;\n+  using std::wcstoull;\n+#endif\n+\n+_GLIBCXX_END_NAMESPACE_TR1\n+}\n+\n+#endif"}, {"sha": "51a2e9168832b3860f347c393d345c4fc7dd8424", "filename": "libstdc++-v3/include/tr1_impl/cwctype", "status": "added", "additions": 48, "deletions": 0, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e133ace8d907bf42754c86106fc3f04a9d9fe70f/libstdc%2B%2B-v3%2Finclude%2Ftr1_impl%2Fcwctype", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e133ace8d907bf42754c86106fc3f04a9d9fe70f/libstdc%2B%2B-v3%2Finclude%2Ftr1_impl%2Fcwctype", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Ftr1_impl%2Fcwctype?ref=e133ace8d907bf42754c86106fc3f04a9d9fe70f", "patch": "@@ -0,0 +1,48 @@\n+// TR1 cwctype -*- C++ -*-\n+\n+// Copyright (C) 2007 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301,\n+// USA.\n+\n+// As a special exception, you may use this file as part of a free software\n+// library without restriction.  Specifically, if other files instantiate\n+// templates or use macros or inline functions from this file, or you compile\n+// this file and link it with other files to produce an executable, this\n+// file does not by itself cause the resulting executable to be covered by\n+// the GNU General Public License.  This exception does not however\n+// invalidate any other reasons why the executable file might be covered by\n+// the GNU General Public License.\n+\n+/** @file tr1_impl/cwctype\n+ *  This is an internal header file, included by other library headers.\n+ *  You should not attempt to use it directly.\n+ */\n+\n+#if _GLIBCXX_USE_WCHAR_T\n+\n+namespace std\n+{\n+_GLIBCXX_BEGIN_NAMESPACE_TR1\n+\n+#if _GLIBCXX_HAVE_ISWBLANK\n+  using std::iswblank;\n+#endif  \n+\n+_GLIBCXX_END_NAMESPACE_TR1\n+}\n+\n+#endif"}, {"sha": "0005dfcc0d0c59ec610e115a386a2cccf827133f", "filename": "libstdc++-v3/include/tr1_impl/functional", "status": "added", "additions": 2294, "deletions": 0, "changes": 2294, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e133ace8d907bf42754c86106fc3f04a9d9fe70f/libstdc%2B%2B-v3%2Finclude%2Ftr1_impl%2Ffunctional", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e133ace8d907bf42754c86106fc3f04a9d9fe70f/libstdc%2B%2B-v3%2Finclude%2Ftr1_impl%2Ffunctional", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Ftr1_impl%2Ffunctional?ref=e133ace8d907bf42754c86106fc3f04a9d9fe70f", "patch": "@@ -0,0 +1,2294 @@\n+// TR1 functional header -*- C++ -*-\n+\n+// Copyright (C) 2007 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301,\n+// USA.\n+\n+// As a special exception, you may use this file as part of a free software\n+// library without restriction.  Specifically, if other files instantiate\n+// templates or use macros or inline functions from this file, or you compile\n+// this file and link it with other files to produce an executable, this\n+// file does not by itself cause the resulting executable to be covered by\n+// the GNU General Public License.  This exception does not however\n+// invalidate any other reasons why the executable file might be covered by\n+// the GNU General Public License.\n+\n+/** @file tr1_impl/functional\n+ *  This is an internal header file, included by other library headers.\n+ *  You should not attempt to use it directly.\n+ */\n+\n+namespace std\n+{\n+_GLIBCXX_BEGIN_NAMESPACE_TR1\n+\n+  template<typename _MemberPointer>\n+    class _Mem_fn;\n+\n+  /**\n+   *  @if maint\n+   *  Actual implementation of _Has_result_type, which uses SFINAE to\n+   *  determine if the type _Tp has a publicly-accessible member type\n+   *  result_type.\n+   *  @endif\n+  */\n+  template<typename _Tp>\n+    class _Has_result_type_helper : __sfinae_types\n+    {\n+      template<typename _Up>\n+        struct _Wrap_type\n+\t{ };\n+\n+      template<typename _Up>\n+        static __one __test(_Wrap_type<typename _Up::result_type>*);\n+\n+      template<typename _Up>\n+        static __two __test(...);\n+\n+    public:\n+      static const bool value = sizeof(__test<_Tp>(0)) == 1;\n+    };\n+\n+  template<typename _Tp>\n+    struct _Has_result_type\n+    : integral_constant<bool,\n+\t      _Has_result_type_helper<typename remove_cv<_Tp>::type>::value>\n+    { };\n+\n+  /**\n+   *  @if maint\n+   *  If we have found a result_type, extract it.\n+   *  @endif\n+  */\n+  template<bool _Has_result_type, typename _Functor>\n+    struct _Maybe_get_result_type\n+    { };\n+\n+  template<typename _Functor>\n+    struct _Maybe_get_result_type<true, _Functor>\n+    {\n+      typedef typename _Functor::result_type result_type;\n+    };\n+\n+  /**\n+   *  @if maint\n+   *  Base class for any function object that has a weak result type, as\n+   *  defined in 3.3/3 of TR1.\n+   *  @endif\n+  */\n+  template<typename _Functor>\n+    struct _Weak_result_type_impl\n+    : _Maybe_get_result_type<_Has_result_type<_Functor>::value, _Functor>\n+    {\n+    };\n+\n+  /**\n+   * @if maint\n+   * Retrieve the result type for a function type.\n+   * @endif \n+   */\n+  template<typename _Res, typename... _ArgTypes> \n+    struct _Weak_result_type_impl<_Res(_ArgTypes...)>\n+    {\n+      typedef _Res result_type;\n+    };\n+\n+  /**\n+   * @if maint\n+   * Retrieve the result type for a function reference.\n+   * @endif \n+   */\n+  template<typename _Res, typename... _ArgTypes> \n+    struct _Weak_result_type_impl<_Res(&)(_ArgTypes...)>\n+    {\n+      typedef _Res result_type;\n+    };\n+\n+  /**\n+   * @if maint\n+   * Retrieve the result type for a function pointer.\n+   * @endif \n+   */\n+  template<typename _Res, typename... _ArgTypes> \n+    struct _Weak_result_type_impl<_Res(*)(_ArgTypes...)>\n+    {\n+      typedef _Res result_type;\n+    };\n+\n+  /**\n+   * @if maint\n+   * Retrieve result type for a member function pointer.\n+   * @endif maint\n+   */ \n+  template<typename _Res, typename _Class, typename... _ArgTypes> \n+    struct _Weak_result_type_impl<_Res (_Class::*)(_ArgTypes...)>\n+    {\n+      typedef _Res result_type;\n+    };\n+\n+  /**\n+   * @if maint\n+   * Retrieve result type for a const member function pointer.\n+   * @endif maint\n+   */ \n+  template<typename _Res, typename _Class, typename... _ArgTypes> \n+    struct _Weak_result_type_impl<_Res (_Class::*)(_ArgTypes...) const>\n+    {\n+      typedef _Res result_type;\n+    };\n+\n+  /**\n+   * @if maint\n+   * Retrieve result type for a volatile member function pointer.\n+   * @endif maint\n+   */ \n+  template<typename _Res, typename _Class, typename... _ArgTypes> \n+    struct _Weak_result_type_impl<_Res (_Class::*)(_ArgTypes...) volatile>\n+    {\n+      typedef _Res result_type;\n+    };\n+\n+  /**\n+   * @if maint\n+   * Retrieve result type for a const volatile member function pointer.\n+   * @endif maint\n+   */ \n+  template<typename _Res, typename _Class, typename... _ArgTypes> \n+    struct _Weak_result_type_impl<_Res (_Class::*)(_ArgTypes...)const volatile>\n+    {\n+      typedef _Res result_type;\n+    };\n+\n+  /**\n+   *  @if maint\n+   *  Strip top-level cv-qualifiers from the function object and let\n+   *  _Weak_result_type_impl perform the real work.\n+   *  @endif\n+  */\n+  template<typename _Functor>\n+    struct _Weak_result_type\n+    : _Weak_result_type_impl<typename remove_cv<_Functor>::type>\n+    {\n+    };\n+\n+  template<typename _Signature>\n+    class result_of;\n+\n+  /**\n+   *  @if maint\n+   *  Actual implementation of result_of. When _Has_result_type is\n+   *  true, gets its result from _Weak_result_type. Otherwise, uses\n+   *  the function object's member template result to extract the\n+   *  result type.\n+   *  @endif\n+  */\n+  template<bool _Has_result_type, typename _Signature>\n+    struct _Result_of_impl;\n+\n+  // Handle member data pointers using _Mem_fn's logic\n+  template<typename _Res, typename _Class, typename _T1>\n+    struct _Result_of_impl<false, _Res _Class::*(_T1)>\n+    {\n+      typedef typename _Mem_fn<_Res _Class::*>\n+                ::template _Result_type<_T1>::type type;\n+    };\n+\n+  /**\n+   * @if maint\n+   * Determine whether we can determine a result type from @c Functor \n+   * alone.\n+   * @endif\n+   */ \n+  template<typename _Functor, typename... _ArgTypes>\n+    class result_of<_Functor(_ArgTypes...)>\n+    : public _Result_of_impl<\n+               _Has_result_type<_Weak_result_type<_Functor> >::value,\n+               _Functor(_ArgTypes...)>\n+    {\n+    };\n+\n+  /**\n+   * @if maint\n+   * We already know the result type for @c Functor; use it.\n+   * @endif\n+   */\n+  template<typename _Functor, typename... _ArgTypes>\n+    struct _Result_of_impl<true, _Functor(_ArgTypes...)>\n+    {\n+      typedef typename _Weak_result_type<_Functor>::result_type type;\n+    };\n+\n+  /**\n+   * @if maint\n+   * We need to compute the result type for this invocation the hard \n+   * way.\n+   * @endif\n+   */\n+  template<typename _Functor, typename... _ArgTypes>\n+    struct _Result_of_impl<false, _Functor(_ArgTypes...)>\n+    {\n+      typedef typename _Functor\n+                ::template result<_Functor(_ArgTypes...)>::type type;\n+    };\n+\n+  /**\n+   * @if maint\n+   * It is unsafe to access ::result when there are zero arguments, so we \n+   * return @c void instead.\n+   * @endif\n+   */\n+  template<typename _Functor>\n+    struct _Result_of_impl<false, _Functor()>\n+    {\n+      typedef void type;\n+    };\n+\n+  /**\n+   *  @if maint\n+   *  Determines if the type _Tp derives from unary_function.\n+   *  @endif\n+  */\n+  template<typename _Tp>\n+    struct _Derives_from_unary_function : __sfinae_types\n+    {\n+    private:\n+      template<typename _T1, typename _Res>\n+        static __one __test(const volatile unary_function<_T1, _Res>*);\n+\n+      // It's tempting to change \"...\" to const volatile void*, but\n+      // that fails when _Tp is a function type.\n+      static __two __test(...);\n+\n+    public:\n+      static const bool value = sizeof(__test((_Tp*)0)) == 1;\n+    };\n+\n+  /**\n+   *  @if maint\n+   *  Determines if the type _Tp derives from binary_function.\n+   *  @endif\n+  */\n+  template<typename _Tp>\n+    struct _Derives_from_binary_function : __sfinae_types\n+    {\n+    private:\n+      template<typename _T1, typename _T2, typename _Res>\n+        static __one __test(const volatile binary_function<_T1, _T2, _Res>*);\n+\n+      // It's tempting to change \"...\" to const volatile void*, but\n+      // that fails when _Tp is a function type.\n+      static __two __test(...);\n+\n+    public:\n+      static const bool value = sizeof(__test((_Tp*)0)) == 1;\n+    };\n+\n+  /**\n+   *  @if maint\n+   *  Turns a function type into a function pointer type\n+   *  @endif\n+  */\n+  template<typename _Tp, bool _IsFunctionType = is_function<_Tp>::value>\n+    struct _Function_to_function_pointer\n+    {\n+      typedef _Tp type;\n+    };\n+\n+  template<typename _Tp>\n+    struct _Function_to_function_pointer<_Tp, true>\n+    {\n+      typedef _Tp* type;\n+    };\n+\n+  /**\n+   * @if maint\n+   * Invoke a function object, which may be either a member pointer or a\n+   * function object. The first parameter will tell which.\n+   * @endif\n+   */\n+  template<typename _Functor, typename... _Args>\n+    inline\n+    typename __gnu_cxx::__enable_if<\n+             (!is_member_pointer<_Functor>::value\n+              && !is_function<_Functor>::value\n+              && !is_function<typename remove_pointer<_Functor>::type>::value),\n+             typename result_of<_Functor(_Args...)>::type\n+           >::__type\n+    __invoke(_Functor& __f, _Args&... __args)\n+    {\n+      return __f(__args...);\n+    }\n+\n+  template<typename _Functor, typename... _Args>\n+    inline\n+    typename __gnu_cxx::__enable_if<\n+             (is_member_pointer<_Functor>::value\n+              && !is_function<_Functor>::value\n+              && !is_function<typename remove_pointer<_Functor>::type>::value),\n+             typename result_of<_Functor(_Args...)>::type\n+           >::__type\n+    __invoke(_Functor& __f, _Args&... __args)\n+    {\n+      return mem_fn(__f)(__args...);\n+    }\n+\n+  // To pick up function references (that will become function pointers)\n+  template<typename _Functor, typename... _Args>\n+    inline\n+    typename __gnu_cxx::__enable_if<\n+             (is_pointer<_Functor>::value\n+              && is_function<typename remove_pointer<_Functor>::type>::value),\n+             typename result_of<_Functor(_Args...)>::type\n+           >::__type\n+    __invoke(_Functor __f, _Args&... __args)\n+    {\n+      return __f(__args...);\n+    }\n+\n+  /**\n+   *  @if maint\n+   *  Knowing which of unary_function and binary_function _Tp derives\n+   *  from, derives from the same and ensures that reference_wrapper\n+   *  will have a weak result type. See cases below.\n+   *  @endif\n+   */\n+  template<bool _Unary, bool _Binary, typename _Tp>\n+    struct _Reference_wrapper_base_impl;\n+\n+  // Not a unary_function or binary_function, so try a weak result type\n+  template<typename _Tp>\n+    struct _Reference_wrapper_base_impl<false, false, _Tp>\n+    : _Weak_result_type<_Tp>\n+    { };\n+\n+  // unary_function but not binary_function\n+  template<typename _Tp>\n+    struct _Reference_wrapper_base_impl<true, false, _Tp>\n+    : unary_function<typename _Tp::argument_type,\n+\t\t     typename _Tp::result_type>\n+    { };\n+\n+  // binary_function but not unary_function\n+  template<typename _Tp>\n+    struct _Reference_wrapper_base_impl<false, true, _Tp>\n+    : binary_function<typename _Tp::first_argument_type,\n+\t\t      typename _Tp::second_argument_type,\n+\t\t      typename _Tp::result_type>\n+    { };\n+\n+  // both unary_function and binary_function. import result_type to\n+  // avoid conflicts.\n+   template<typename _Tp>\n+    struct _Reference_wrapper_base_impl<true, true, _Tp>\n+    : unary_function<typename _Tp::argument_type,\n+\t\t     typename _Tp::result_type>,\n+      binary_function<typename _Tp::first_argument_type,\n+\t\t      typename _Tp::second_argument_type,\n+\t\t      typename _Tp::result_type>\n+    {\n+      typedef typename _Tp::result_type result_type;\n+    };\n+\n+  /**\n+   *  @if maint\n+   *  Derives from unary_function or binary_function when it\n+   *  can. Specializations handle all of the easy cases. The primary\n+   *  template determines what to do with a class type, which may\n+   *  derive from both unary_function and binary_function.\n+   *  @endif\n+  */\n+  template<typename _Tp>\n+    struct _Reference_wrapper_base\n+    : _Reference_wrapper_base_impl<\n+      _Derives_from_unary_function<_Tp>::value,\n+      _Derives_from_binary_function<_Tp>::value,\n+      _Tp>\n+    { };\n+\n+  // - a function type (unary)\n+  template<typename _Res, typename _T1>\n+    struct _Reference_wrapper_base<_Res(_T1)>\n+    : unary_function<_T1, _Res>\n+    { };\n+\n+  // - a function type (binary)\n+  template<typename _Res, typename _T1, typename _T2>\n+    struct _Reference_wrapper_base<_Res(_T1, _T2)>\n+    : binary_function<_T1, _T2, _Res>\n+    { };\n+\n+  // - a function pointer type (unary)\n+  template<typename _Res, typename _T1>\n+    struct _Reference_wrapper_base<_Res(*)(_T1)>\n+    : unary_function<_T1, _Res>\n+    { };\n+\n+  // - a function pointer type (binary)\n+  template<typename _Res, typename _T1, typename _T2>\n+    struct _Reference_wrapper_base<_Res(*)(_T1, _T2)>\n+    : binary_function<_T1, _T2, _Res>\n+    { };\n+\n+  // - a pointer to member function type (unary, no qualifiers)\n+  template<typename _Res, typename _T1>\n+    struct _Reference_wrapper_base<_Res (_T1::*)()>\n+    : unary_function<_T1*, _Res>\n+    { };\n+\n+  // - a pointer to member function type (binary, no qualifiers)\n+  template<typename _Res, typename _T1, typename _T2>\n+    struct _Reference_wrapper_base<_Res (_T1::*)(_T2)>\n+    : binary_function<_T1*, _T2, _Res>\n+    { };\n+\n+  // - a pointer to member function type (unary, const)\n+  template<typename _Res, typename _T1>\n+    struct _Reference_wrapper_base<_Res (_T1::*)() const>\n+    : unary_function<const _T1*, _Res>\n+    { };\n+\n+  // - a pointer to member function type (binary, const)\n+  template<typename _Res, typename _T1, typename _T2>\n+    struct _Reference_wrapper_base<_Res (_T1::*)(_T2) const>\n+    : binary_function<const _T1*, _T2, _Res>\n+    { };\n+\n+  // - a pointer to member function type (unary, volatile)\n+  template<typename _Res, typename _T1>\n+    struct _Reference_wrapper_base<_Res (_T1::*)() volatile>\n+    : unary_function<volatile _T1*, _Res>\n+    { };\n+\n+  // - a pointer to member function type (binary, volatile)\n+  template<typename _Res, typename _T1, typename _T2>\n+    struct _Reference_wrapper_base<_Res (_T1::*)(_T2) volatile>\n+    : binary_function<volatile _T1*, _T2, _Res>\n+    { };\n+\n+  // - a pointer to member function type (unary, const volatile)\n+  template<typename _Res, typename _T1>\n+    struct _Reference_wrapper_base<_Res (_T1::*)() const volatile>\n+    : unary_function<const volatile _T1*, _Res>\n+    { };\n+\n+  // - a pointer to member function type (binary, const volatile)\n+  template<typename _Res, typename _T1, typename _T2>\n+    struct _Reference_wrapper_base<_Res (_T1::*)(_T2) const volatile>\n+    : binary_function<const volatile _T1*, _T2, _Res>\n+    { };\n+\n+  template<typename _Tp>\n+    class reference_wrapper\n+    : public _Reference_wrapper_base<typename remove_cv<_Tp>::type>\n+    {\n+      // If _Tp is a function type, we can't form result_of<_Tp(...)>,\n+      // so turn it into a function pointer type.\n+      typedef typename _Function_to_function_pointer<_Tp>::type\n+        _M_func_type;\n+\n+      _Tp* _M_data;\n+    public:\n+      typedef _Tp type;\n+\n+      explicit\n+      reference_wrapper(_Tp& __indata): _M_data(&__indata)\n+      { }\n+\n+      reference_wrapper(const reference_wrapper<_Tp>& __inref):\n+      _M_data(__inref._M_data)\n+      { }\n+\n+      reference_wrapper&\n+      operator=(const reference_wrapper<_Tp>& __inref)\n+      {\n+        _M_data = __inref._M_data;\n+        return *this;\n+      }\n+\n+      operator _Tp&() const\n+      { return this->get(); }\n+\n+      _Tp&\n+      get() const\n+      { return *_M_data; }\n+\n+      template<typename... _Args>\n+        typename result_of<_M_func_type(_Args...)>::type\n+        operator()(_Args&... __args) const\n+        {\n+\t  return __invoke(get(), __args...);\n+\t}\n+    };\n+\n+\n+  // Denotes a reference should be taken to a variable.\n+  template<typename _Tp>\n+    inline reference_wrapper<_Tp>\n+    ref(_Tp& __t)\n+    { return reference_wrapper<_Tp>(__t); }\n+\n+  // Denotes a const reference should be taken to a variable.\n+  template<typename _Tp>\n+    inline reference_wrapper<const _Tp>\n+    cref(const _Tp& __t)\n+    { return reference_wrapper<const _Tp>(__t); }\n+\n+  template<typename _Tp>\n+    inline reference_wrapper<_Tp>\n+    ref(reference_wrapper<_Tp> __t)\n+    { return ref(__t.get()); }\n+\n+  template<typename _Tp>\n+    inline reference_wrapper<const _Tp>\n+    cref(reference_wrapper<_Tp> __t)\n+    { return cref(__t.get()); }\n+\n+  template<typename _Tp, bool>\n+    struct _Mem_fn_const_or_non\n+    {\n+      typedef const _Tp& type;\n+    };\n+\n+  template<typename _Tp>\n+    struct _Mem_fn_const_or_non<_Tp, false>\n+    {\n+      typedef _Tp& type;\n+    };\n+\n+  /**\n+   * @if maint\n+   * Derives from @c unary_function or @c binary_function, or perhaps\n+   * nothing, depending on the number of arguments provided. The\n+   * primary template is the basis case, which derives nothing.\n+   * @endif maint\n+   */\n+  template<typename _Res, typename... _ArgTypes> \n+    struct _Maybe_unary_or_binary_function { };\n+\n+  /**\n+   * @if maint\n+   * Derives from @c unary_function, as appropriate.\n+   * @endif\n+   */ \n+  template<typename _Res, typename _T1> \n+    struct _Maybe_unary_or_binary_function<_Res, _T1>\n+    : std::unary_function<_T1, _Res> { };\n+\n+  /**\n+   * @if maint\n+   * Derives from @c binary_function, as appropriate.\n+   * @endif\n+   */ \n+  template<typename _Res, typename _T1, typename _T2> \n+    struct _Maybe_unary_or_binary_function<_Res, _T1, _T2>\n+    : std::binary_function<_T1, _T2, _Res> { };\n+\n+  /**\n+   * @if maint\n+   * Implementation of @c mem_fn for member function pointers.\n+   * @endif\n+   */\n+  template<typename _Res, typename _Class, typename... _ArgTypes>\n+    class _Mem_fn<_Res (_Class::*)(_ArgTypes...)>\n+    : public _Maybe_unary_or_binary_function<_Res, _Class*, _ArgTypes...>\n+    {\n+      typedef _Res (_Class::*_Functor)(_ArgTypes...);\n+\n+      template<typename _Tp>\n+        _Res\n+        _M_call(_Tp& __object, const volatile _Class *, \n+                _ArgTypes... __args) const\n+        { return (__object.*__pmf)(__args...); }\n+\n+      template<typename _Tp>\n+        _Res\n+        _M_call(_Tp& __ptr, const volatile void *, _ArgTypes... __args) const\n+        { return ((*__ptr).*__pmf)(__args...); }\n+\n+    public:\n+      typedef _Res result_type;\n+\n+      explicit _Mem_fn(_Functor __pmf) : __pmf(__pmf) { }\n+\n+      // Handle objects\n+      _Res\n+      operator()(_Class& __object, _ArgTypes... __args) const\n+      { return (__object.*__pmf)(__args...); }\n+\n+      // Handle pointers\n+      _Res\n+      operator()(_Class* __object, _ArgTypes... __args) const\n+      { return (__object->*__pmf)(__args...); }\n+\n+      // Handle smart pointers, references and pointers to derived\n+      template<typename _Tp>\n+        _Res\n+\toperator()(_Tp& __object, _ArgTypes... __args) const\n+        { return _M_call(__object, &__object, __args...); }\n+\n+    private:\n+      _Functor __pmf;\n+    };\n+\n+  /**\n+   * @if maint\n+   * Implementation of @c mem_fn for const member function pointers.\n+   * @endif\n+   */\n+  template<typename _Res, typename _Class, typename... _ArgTypes>\n+    class _Mem_fn<_Res (_Class::*)(_ArgTypes...) const>\n+    : public _Maybe_unary_or_binary_function<_Res, const _Class*, \n+\t\t\t\t\t     _ArgTypes...>\n+    {\n+      typedef _Res (_Class::*_Functor)(_ArgTypes...) const;\n+\n+      template<typename _Tp>\n+        _Res\n+        _M_call(_Tp& __object, const volatile _Class *, \n+                _ArgTypes... __args) const\n+        { return (__object.*__pmf)(__args...); }\n+\n+      template<typename _Tp>\n+        _Res\n+        _M_call(_Tp& __ptr, const volatile void *, _ArgTypes... __args) const\n+        { return ((*__ptr).*__pmf)(__args...); }\n+\n+    public:\n+      typedef _Res result_type;\n+\n+      explicit _Mem_fn(_Functor __pmf) : __pmf(__pmf) { }\n+\n+      // Handle objects\n+      _Res\n+      operator()(const _Class& __object, _ArgTypes... __args) const\n+      { return (__object.*__pmf)(__args...); }\n+\n+      // Handle pointers\n+      _Res\n+      operator()(const _Class* __object, _ArgTypes... __args) const\n+      { return (__object->*__pmf)(__args...); }\n+\n+      // Handle smart pointers, references and pointers to derived\n+      template<typename _Tp>\n+        _Res operator()(_Tp& __object, _ArgTypes... __args) const\n+        { return _M_call(__object, &__object, __args...); }\n+\n+    private:\n+      _Functor __pmf;\n+    };\n+\n+  /**\n+   * @if maint\n+   * Implementation of @c mem_fn for volatile member function pointers.\n+   * @endif\n+   */\n+  template<typename _Res, typename _Class, typename... _ArgTypes>\n+    class _Mem_fn<_Res (_Class::*)(_ArgTypes...) volatile>\n+    : public _Maybe_unary_or_binary_function<_Res, volatile _Class*, \n+\t\t\t\t\t     _ArgTypes...>\n+    {\n+      typedef _Res (_Class::*_Functor)(_ArgTypes...) volatile;\n+\n+      template<typename _Tp>\n+        _Res\n+        _M_call(_Tp& __object, const volatile _Class *, \n+                _ArgTypes... __args) const\n+        { return (__object.*__pmf)(__args...); }\n+\n+      template<typename _Tp>\n+        _Res\n+        _M_call(_Tp& __ptr, const volatile void *, _ArgTypes... __args) const\n+        { return ((*__ptr).*__pmf)(__args...); }\n+\n+    public:\n+      typedef _Res result_type;\n+\n+      explicit _Mem_fn(_Functor __pmf) : __pmf(__pmf) { }\n+\n+      // Handle objects\n+      _Res\n+      operator()(volatile _Class& __object, _ArgTypes... __args) const\n+      { return (__object.*__pmf)(__args...); }\n+\n+      // Handle pointers\n+      _Res\n+      operator()(volatile _Class* __object, _ArgTypes... __args) const\n+      { return (__object->*__pmf)(__args...); }\n+\n+      // Handle smart pointers, references and pointers to derived\n+      template<typename _Tp>\n+        _Res\n+\toperator()(_Tp& __object, _ArgTypes... __args) const\n+        { return _M_call(__object, &__object, __args...); }\n+\n+    private:\n+      _Functor __pmf;\n+    };\n+\n+  /**\n+   * @if maint\n+   * Implementation of @c mem_fn for const volatile member function pointers.\n+   * @endif\n+   */\n+  template<typename _Res, typename _Class, typename... _ArgTypes>\n+    class _Mem_fn<_Res (_Class::*)(_ArgTypes...) const volatile>\n+    : public _Maybe_unary_or_binary_function<_Res, const volatile _Class*, \n+\t\t\t\t\t     _ArgTypes...>\n+    {\n+      typedef _Res (_Class::*_Functor)(_ArgTypes...) const volatile;\n+\n+      template<typename _Tp>\n+        _Res\n+        _M_call(_Tp& __object, const volatile _Class *, \n+                _ArgTypes... __args) const\n+        { return (__object.*__pmf)(__args...); }\n+\n+      template<typename _Tp>\n+        _Res\n+        _M_call(_Tp& __ptr, const volatile void *, _ArgTypes... __args) const\n+        { return ((*__ptr).*__pmf)(__args...); }\n+\n+    public:\n+      typedef _Res result_type;\n+\n+      explicit _Mem_fn(_Functor __pmf) : __pmf(__pmf) { }\n+\n+      // Handle objects\n+      _Res \n+      operator()(const volatile _Class& __object, _ArgTypes... __args) const\n+      { return (__object.*__pmf)(__args...); }\n+\n+      // Handle pointers\n+      _Res \n+      operator()(const volatile _Class* __object, _ArgTypes... __args) const\n+      { return (__object->*__pmf)(__args...); }\n+\n+      // Handle smart pointers, references and pointers to derived\n+      template<typename _Tp>\n+        _Res operator()(_Tp& __object, _ArgTypes... __args) const\n+        { return _M_call(__object, &__object, __args...); }\n+\n+    private:\n+      _Functor __pmf;\n+    };\n+\n+\n+  template<typename _Res, typename _Class>\n+    class _Mem_fn<_Res _Class::*>\n+    {\n+      // This bit of genius is due to Peter Dimov, improved slightly by\n+      // Douglas Gregor.\n+      template<typename _Tp>\n+        _Res&\n+        _M_call(_Tp& __object, _Class *) const\n+        { return __object.*__pm; }\n+\n+      template<typename _Tp, typename _Up>\n+        _Res&\n+        _M_call(_Tp& __object, _Up * const *) const\n+        { return (*__object).*__pm; }\n+\n+      template<typename _Tp, typename _Up>\n+        const _Res&\n+        _M_call(_Tp& __object, const _Up * const *) const\n+        { return (*__object).*__pm; }\n+\n+      template<typename _Tp>\n+        const _Res&\n+        _M_call(_Tp& __object, const _Class *) const\n+        { return __object.*__pm; }\n+\n+      template<typename _Tp>\n+        const _Res&\n+        _M_call(_Tp& __ptr, const volatile void*) const\n+        { return (*__ptr).*__pm; }\n+\n+      template<typename _Tp> static _Tp& __get_ref();\n+\n+      template<typename _Tp>\n+        static __sfinae_types::__one __check_const(_Tp&, _Class*);\n+      template<typename _Tp, typename _Up>\n+        static __sfinae_types::__one __check_const(_Tp&, _Up * const *);\n+      template<typename _Tp, typename _Up>\n+        static __sfinae_types::__two __check_const(_Tp&, const _Up * const *);\n+      template<typename _Tp>\n+        static __sfinae_types::__two __check_const(_Tp&, const _Class*);\n+      template<typename _Tp>\n+        static __sfinae_types::__two __check_const(_Tp&, const volatile void*);\n+\n+    public:\n+      template<typename _Tp>\n+        struct _Result_type\n+\t: _Mem_fn_const_or_non<_Res,\n+\t  (sizeof(__sfinae_types::__two)\n+\t   == sizeof(__check_const<_Tp>(__get_ref<_Tp>(), (_Tp*)0)))>\n+        { };\n+\n+      template<typename _Signature>\n+        struct result;\n+\n+      template<typename _CVMem, typename _Tp>\n+        struct result<_CVMem(_Tp)>\n+\t: public _Result_type<_Tp> { };\n+\n+      template<typename _CVMem, typename _Tp>\n+        struct result<_CVMem(_Tp&)>\n+\t: public _Result_type<_Tp> { };\n+\n+      explicit\n+      _Mem_fn(_Res _Class::*__pm) : __pm(__pm) { }\n+\n+      // Handle objects\n+      _Res&\n+      operator()(_Class& __object) const\n+      { return __object.*__pm; }\n+\n+      const _Res&\n+      operator()(const _Class& __object) const\n+      { return __object.*__pm; }\n+\n+      // Handle pointers\n+      _Res&\n+      operator()(_Class* __object) const\n+      { return __object->*__pm; }\n+\n+      const _Res&\n+      operator()(const _Class* __object) const\n+      { return __object->*__pm; }\n+\n+      // Handle smart pointers and derived\n+      template<typename _Tp>\n+        typename _Result_type<_Tp>::type\n+        operator()(_Tp& __unknown) const\n+        { return _M_call(__unknown, &__unknown); }\n+\n+    private:\n+      _Res _Class::*__pm;\n+    };\n+\n+  /**\n+   *  @brief Returns a function object that forwards to the member\n+   *  pointer @a pm.\n+   */\n+  template<typename _Tp, typename _Class>\n+    inline _Mem_fn<_Tp _Class::*>\n+    mem_fn(_Tp _Class::* __pm)\n+    {\n+      return _Mem_fn<_Tp _Class::*>(__pm);\n+    }\n+\n+  /**\n+   *  @brief Determines if the given type _Tp is a function object\n+   *  should be treated as a subexpression when evaluating calls to\n+   *  function objects returned by bind(). [TR1 3.6.1]\n+   */\n+  template<typename _Tp>\n+    struct is_bind_expression\n+    { static const bool value = false; };\n+\n+  template<typename _Tp>\n+    const bool is_bind_expression<_Tp>::value;\n+\n+  /**\n+   *  @brief Determines if the given type _Tp is a placeholder in a\n+   *  bind() expression and, if so, which placeholder it is. [TR1 3.6.2]\n+   */\n+  template<typename _Tp>\n+    struct is_placeholder\n+    { static const int value = 0; };\n+\n+  template<typename _Tp>\n+    const int is_placeholder<_Tp>::value;\n+\n+  /**\n+   *  @if maint\n+   *  The type of placeholder objects defined by libstdc++.\n+   *  @endif\n+   */\n+  template<int _Num> struct _Placeholder { };\n+\n+  // Define a large number of placeholders. There is no way to\n+  // simplify this with variadic templates, because we're introducing\n+  // unique names for each.\n+  namespace placeholders { namespace {\n+    _Placeholder<1> _1;\n+    _Placeholder<2> _2;\n+    _Placeholder<3> _3;\n+    _Placeholder<4> _4;\n+    _Placeholder<5> _5;\n+    _Placeholder<6> _6;\n+    _Placeholder<7> _7;\n+    _Placeholder<8> _8;\n+    _Placeholder<9> _9;\n+    _Placeholder<10> _10;\n+    _Placeholder<11> _11;\n+    _Placeholder<12> _12;\n+    _Placeholder<13> _13;\n+    _Placeholder<14> _14;\n+    _Placeholder<15> _15;\n+    _Placeholder<16> _16;\n+    _Placeholder<17> _17;\n+    _Placeholder<18> _18;\n+    _Placeholder<19> _19;\n+    _Placeholder<20> _20;\n+    _Placeholder<21> _21;\n+    _Placeholder<22> _22;\n+    _Placeholder<23> _23;\n+    _Placeholder<24> _24;\n+    _Placeholder<25> _25;\n+    _Placeholder<26> _26;\n+    _Placeholder<27> _27;\n+    _Placeholder<28> _28;\n+    _Placeholder<29> _29;\n+  } }\n+\n+  /**\n+   *  @if maint\n+   *  Partial specialization of is_placeholder that provides the placeholder\n+   *  number for the placeholder objects defined by libstdc++.\n+   *  @endif\n+   */\n+  template<int _Num>\n+    struct is_placeholder<_Placeholder<_Num> >\n+    { static const int value = _Num; };\n+\n+  template<int _Num>\n+    const int is_placeholder<_Placeholder<_Num> >::value;\n+\n+  /**\n+   * @if maint\n+   * Stores a tuple of indices. Used by bind() to extract the elements\n+   * in a tuple. \n+   * @endif\n+   */\n+  template<int... _Indexes>\n+    struct _Index_tuple { };\n+\n+  /**\n+   *  @if maint\n+   *  Builds an _Index_tuple<0, 1, 2, ..., _Num-1>.\n+   *  @endif\n+   */\n+  template<std::size_t _Num, typename _Tuple = _Index_tuple<> >\n+    struct _Build_index_tuple;\n+ \n+  template<std::size_t _Num, int... _Indexes> \n+    struct _Build_index_tuple<_Num, _Index_tuple<_Indexes...> >\n+    : _Build_index_tuple<_Num - 1, \n+                         _Index_tuple<_Indexes..., sizeof...(_Indexes)> >\n+    {\n+    };\n+\n+  template<int... _Indexes>\n+    struct _Build_index_tuple<0, _Index_tuple<_Indexes...> >\n+    {\n+      typedef _Index_tuple<_Indexes...> __type;\n+    };\n+\n+  /** \n+   * @if maint\n+   * Used by _Safe_tuple_element to indicate that there is no tuple\n+   * element at this position.\n+   * @endif\n+   */\n+  struct _No_tuple_element;\n+\n+  /**\n+   * @if maint\n+   * Implementation helper for _Safe_tuple_element. This primary\n+   * template handles the case where it is safe to use @c\n+   * tuple_element.\n+   * @endif\n+   */\n+  template<int __i, typename _Tuple, bool _IsSafe>\n+    struct _Safe_tuple_element_impl\n+    : tuple_element<__i, _Tuple> { };\n+\n+  /**\n+   * @if maint\n+   * Implementation helper for _Safe_tuple_element. This partial\n+   * specialization handles the case where it is not safe to use @c\n+   * tuple_element. We just return @c _No_tuple_element.\n+   * @endif\n+   */\n+  template<int __i, typename _Tuple>\n+    struct _Safe_tuple_element_impl<__i, _Tuple, false>\n+    {\n+      typedef _No_tuple_element type;\n+    };\n+\n+  /**\n+   * Like tuple_element, but returns @c _No_tuple_element when\n+   * tuple_element would return an error.\n+   */\n+ template<int __i, typename _Tuple>\n+   struct _Safe_tuple_element\n+   : _Safe_tuple_element_impl<__i, _Tuple, \n+                              (__i >= 0 && __i < tuple_size<_Tuple>::value)>\n+   {\n+   };\n+\n+  /**\n+   *  @if maint\n+   *  Maps an argument to bind() into an actual argument to the bound\n+   *  function object [TR1 3.6.3/5]. Only the first parameter should\n+   *  be specified: the rest are used to determine among the various\n+   *  implementations. Note that, although this class is a function\n+   *  object, isn't not entirely normal because it takes only two\n+   *  parameters regardless of the number of parameters passed to the\n+   *  bind expression. The first parameter is the bound argument and\n+   *  the second parameter is a tuple containing references to the\n+   *  rest of the arguments.\n+   *  @endif\n+   */\n+  template<typename _Arg,\n+           bool _IsBindExp = is_bind_expression<_Arg>::value,\n+           bool _IsPlaceholder = (is_placeholder<_Arg>::value > 0)>\n+    class _Mu;\n+\n+  /**\n+   *  @if maint\n+   *  If the argument is reference_wrapper<_Tp>, returns the\n+   *  underlying reference. [TR1 3.6.3/5 bullet 1]\n+   *  @endif\n+   */\n+  template<typename _Tp>\n+    class _Mu<reference_wrapper<_Tp>, false, false>\n+    {\n+    public:\n+      typedef _Tp& result_type;\n+\n+      /* Note: This won't actually work for const volatile\n+       * reference_wrappers, because reference_wrapper::get() is const\n+       * but not volatile-qualified. This might be a defect in the TR.\n+       */\n+      template<typename _CVRef, typename _Tuple>\n+        result_type\n+        operator()(_CVRef& __arg, const _Tuple&) const volatile\n+        { return __arg.get(); }\n+    };\n+\n+  /**\n+   *  @if maint\n+   *  If the argument is a bind expression, we invoke the underlying\n+   *  function object with the same cv-qualifiers as we are given and\n+   *  pass along all of our arguments (unwrapped). [TR1 3.6.3/5 bullet 2]\n+   *  @endif\n+   */\n+  template<typename _Arg>\n+    class _Mu<_Arg, true, false>\n+    {\n+    public:\n+      template<typename _Signature> class result;\n+\n+      // Determine the result type when we pass the arguments along. This\n+      // involves passing along the cv-qualifiers placed on _Mu and\n+      // unwrapping the argument bundle.\n+      template<typename _CVMu, typename _CVArg, typename... _Args>\n+        class result<_CVMu(_CVArg, tuple<_Args...>)>\n+\t: public result_of<_CVArg(_Args...)> { };\n+\n+      template<typename _CVArg, typename... _Args>\n+        typename result_of<_CVArg(_Args...)>::type\n+        operator()(_CVArg& __arg,\n+\t\t   const tuple<_Args...>& __tuple) const volatile\n+        {\n+\t  // Construct an index tuple and forward to __call\n+\t  typedef typename _Build_index_tuple<sizeof...(_Args)>::__type\n+\t    _Indexes;\n+\t  return this->__call(__arg, __tuple, _Indexes());\n+\t}\n+\n+    private:\n+      // Invokes the underlying function object __arg by unpacking all\n+      // of the arguments in the tuple. \n+      template<typename _CVArg, typename... _Args, int... _Indexes>\n+        typename result_of<_CVArg(_Args...)>::type\n+        __call(_CVArg& __arg, const tuple<_Args...>& __tuple,\n+\t       const _Index_tuple<_Indexes...>&) const volatile\n+        {\n+\t  return __arg(_GLIBCXX_TR1 get<_Indexes>(__tuple)...);\n+\t}\n+    };\n+\n+  /**\n+   *  @if maint\n+   *  If the argument is a placeholder for the Nth argument, returns\n+   *  a reference to the Nth argument to the bind function object.\n+   *  [TR1 3.6.3/5 bullet 3]\n+   *  @endif\n+   */\n+  template<typename _Arg>\n+    class _Mu<_Arg, false, true>\n+    {\n+    public:\n+      template<typename _Signature> class result;\n+\n+      template<typename _CVMu, typename _CVArg, typename _Tuple>\n+        class result<_CVMu(_CVArg, _Tuple)>\n+        {\n+\t  // Add a reference, if it hasn't already been done for us.\n+\t  // This allows us to be a little bit sloppy in constructing\n+\t  // the tuple that we pass to result_of<...>.\n+\t  typedef typename _Safe_tuple_element<(is_placeholder<_Arg>::value\n+\t\t\t\t\t\t- 1), _Tuple>::type\n+\t    __base_type;\n+\n+\tpublic:\n+\t  typedef typename add_reference<__base_type>::type type;\n+\t};\n+\n+      template<typename _Tuple>\n+        typename result<_Mu(_Arg, _Tuple)>::type\n+        operator()(const volatile _Arg&, const _Tuple& __tuple) const volatile\n+        {\n+\t  return ::std::_GLIBCXX_TR1 get<(is_placeholder<_Arg>::value\n+\t\t\t\t\t  - 1)>(__tuple);\n+\t}\n+    };\n+\n+  /**\n+   *  @if maint\n+   *  If the argument is just a value, returns a reference to that\n+   *  value. The cv-qualifiers on the reference are the same as the\n+   *  cv-qualifiers on the _Mu object. [TR1 3.6.3/5 bullet 4]\n+   *  @endif\n+   */\n+  template<typename _Arg>\n+    class _Mu<_Arg, false, false>\n+    {\n+    public:\n+      template<typename _Signature> struct result;\n+\n+      template<typename _CVMu, typename _CVArg, typename _Tuple>\n+        struct result<_CVMu(_CVArg, _Tuple)>\n+        {\n+\t  typedef typename add_reference<_CVArg>::type type;\n+\t};\n+\n+      // Pick up the cv-qualifiers of the argument\n+      template<typename _CVArg, typename _Tuple>\n+        _CVArg&\n+        operator()(_CVArg& __arg, const _Tuple&) const volatile\n+        { return __arg; }\n+    };\n+\n+  /**\n+   *  @if maint\n+   *  Maps member pointers into instances of _Mem_fn but leaves all\n+   *  other function objects untouched. Used by tr1::bind(). The\n+   *  primary template handles the non--member-pointer case.\n+   *  @endif\n+   */\n+  template<typename _Tp>\n+    struct _Maybe_wrap_member_pointer\n+    {\n+      typedef _Tp type;\n+      \n+      static const _Tp&\n+      __do_wrap(const _Tp& __x)\n+      { return __x; }\n+    };\n+\n+  /**\n+   *  @if maint\n+   *  Maps member pointers into instances of _Mem_fn but leaves all\n+   *  other function objects untouched. Used by tr1::bind(). This\n+   *  partial specialization handles the member pointer case.\n+   *  @endif\n+   */\n+  template<typename _Tp, typename _Class>\n+    struct _Maybe_wrap_member_pointer<_Tp _Class::*>\n+    {\n+      typedef _Mem_fn<_Tp _Class::*> type;\n+      \n+      static type\n+      __do_wrap(_Tp _Class::* __pm)\n+      { return type(__pm); }\n+    };\n+\n+  /**\n+   *  @if maint\n+   *  Type of the function object returned from bind().\n+   *  @endif\n+   */\n+  template<typename _Signature>\n+    struct _Bind;\n+\n+   template<typename _Functor, typename... _Bound_args>\n+    class _Bind<_Functor(_Bound_args...)>\n+    : public _Weak_result_type<_Functor>\n+    {\n+      typedef _Bind __self_type;\n+      typedef typename _Build_index_tuple<sizeof...(_Bound_args)>::__type \n+        _Bound_indexes;\n+\n+      _Functor _M_f;\n+      tuple<_Bound_args...> _M_bound_args;\n+\n+      // Call unqualified\n+      template<typename... _Args, int... _Indexes>\n+        typename result_of<\n+                   _Functor(typename result_of<_Mu<_Bound_args> \n+                            (_Bound_args, tuple<_Args...>)>::type...)\n+                 >::type\n+        __call(const tuple<_Args...>& __args, _Index_tuple<_Indexes...>)\n+        {\n+          return _M_f(_Mu<_Bound_args>()\n+                      (_GLIBCXX_TR1 get<_Indexes>(_M_bound_args), __args)...);\n+        }\n+\n+      // Call as const\n+      template<typename... _Args, int... _Indexes>\n+        typename result_of<\n+                   const _Functor(typename result_of<_Mu<_Bound_args> \n+                                    (const _Bound_args, tuple<_Args...>)\n+                                  >::type...)>::type\n+        __call(const tuple<_Args...>& __args, _Index_tuple<_Indexes...>) const\n+        {\n+          return _M_f(_Mu<_Bound_args>()\n+                      (_GLIBCXX_TR1 get<_Indexes>(_M_bound_args), __args)...);\n+        }\n+\n+      // Call as volatile\n+      template<typename... _Args, int... _Indexes>\n+        typename result_of<\n+                   volatile _Functor(typename result_of<_Mu<_Bound_args> \n+                                    (volatile _Bound_args, tuple<_Args...>)\n+                                  >::type...)>::type\n+        __call(const tuple<_Args...>& __args, \n+               _Index_tuple<_Indexes...>) volatile\n+        {\n+          return _M_f(_Mu<_Bound_args>()\n+                      (_GLIBCXX_TR1 get<_Indexes>(_M_bound_args), __args)...);\n+        }\n+\n+      // Call as const volatile\n+      template<typename... _Args, int... _Indexes>\n+        typename result_of<\n+                   const volatile _Functor(typename result_of<_Mu<_Bound_args> \n+                                    (const volatile _Bound_args, \n+                                     tuple<_Args...>)\n+                                  >::type...)>::type\n+        __call(const tuple<_Args...>& __args, \n+               _Index_tuple<_Indexes...>) const volatile\n+        {\n+          return _M_f(_Mu<_Bound_args>()\n+                      (_GLIBCXX_TR1 get<_Indexes>(_M_bound_args), __args)...);\n+        }\n+\n+     public:\n+      explicit _Bind(_Functor __f, _Bound_args... __bound_args)\n+        : _M_f(__f), _M_bound_args(__bound_args...) { }\n+\n+      // Call unqualified\n+      template<typename... _Args>\n+        typename result_of<\n+                   _Functor(typename result_of<_Mu<_Bound_args> \n+                            (_Bound_args, tuple<_Args...>)>::type...)\n+                 >::type\n+        operator()(_Args&... __args)\n+        {\n+          return this->__call(_GLIBCXX_TR1 tie(__args...), _Bound_indexes());\n+        }\n+\n+      // Call as const\n+      template<typename... _Args>\n+        typename result_of<\n+                   const _Functor(typename result_of<_Mu<_Bound_args> \n+                            (const _Bound_args, tuple<_Args...>)>::type...)\n+                 >::type\n+        operator()(_Args&... __args) const\n+        {\n+          return this->__call(_GLIBCXX_TR1 tie(__args...), _Bound_indexes());\n+        }\n+\n+\n+      // Call as volatile\n+      template<typename... _Args>\n+        typename result_of<\n+                   volatile _Functor(typename result_of<_Mu<_Bound_args> \n+                            (volatile _Bound_args, tuple<_Args...>)>::type...)\n+                 >::type\n+        operator()(_Args&... __args) volatile\n+        {\n+          return this->__call(_GLIBCXX_TR1 tie(__args...), _Bound_indexes());\n+        }\n+\n+\n+      // Call as const volatile\n+      template<typename... _Args>\n+        typename result_of<\n+                   const volatile _Functor(typename result_of<_Mu<_Bound_args> \n+                            (const volatile _Bound_args, \n+                             tuple<_Args...>)>::type...)\n+                 >::type\n+        operator()(_Args&... __args) const volatile\n+        {\n+          return this->__call(_GLIBCXX_TR1 tie(__args...), _Bound_indexes());\n+        }\n+    };\n+\n+  /**\n+   *  @if maint\n+   *  Type of the function object returned from bind<R>().\n+   *  @endif\n+   */\n+  template<typename _Result, typename _Signature>\n+    struct _Bind_result;\n+\n+  template<typename _Result, typename _Functor, typename... _Bound_args>\n+    class _Bind_result<_Result, _Functor(_Bound_args...)>\n+    {\n+      typedef _Bind_result __self_type;\n+      typedef typename _Build_index_tuple<sizeof...(_Bound_args)>::__type \n+        _Bound_indexes;\n+\n+      _Functor _M_f;\n+      tuple<_Bound_args...> _M_bound_args;\n+\n+      // Call unqualified\n+      template<typename... _Args, int... _Indexes>\n+        _Result\n+        __call(const tuple<_Args...>& __args, _Index_tuple<_Indexes...>)\n+        {\n+          return _M_f(_Mu<_Bound_args>()\n+                      (_GLIBCXX_TR1 get<_Indexes>(_M_bound_args), __args)...);\n+        }\n+\n+      // Call as const\n+      template<typename... _Args, int... _Indexes>\n+        _Result\n+        __call(const tuple<_Args...>& __args, _Index_tuple<_Indexes...>) const\n+        {\n+          return _M_f(_Mu<_Bound_args>()\n+                      (_GLIBCXX_TR1 get<_Indexes>(_M_bound_args), __args)...);\n+        }\n+\n+      // Call as volatile\n+      template<typename... _Args, int... _Indexes>\n+        _Result\n+        __call(const tuple<_Args...>& __args, \n+               _Index_tuple<_Indexes...>) volatile\n+        {\n+          return _M_f(_Mu<_Bound_args>()\n+                      (_GLIBCXX_TR1 get<_Indexes>(_M_bound_args), __args)...);\n+        }\n+\n+      // Call as const volatile\n+      template<typename... _Args, int... _Indexes>\n+        _Result\n+        __call(const tuple<_Args...>& __args, \n+               _Index_tuple<_Indexes...>) const volatile\n+        {\n+          return _M_f(_Mu<_Bound_args>()\n+                      (_GLIBCXX_TR1 get<_Indexes>(_M_bound_args), __args)...);\n+        }\n+\n+    public:\n+      typedef _Result result_type;\n+\n+      explicit\n+      _Bind_result(_Functor __f, _Bound_args... __bound_args)\n+      : _M_f(__f), _M_bound_args(__bound_args...) { }\n+\n+      // Call unqualified\n+      template<typename... _Args>\n+        result_type\n+        operator()(_Args&... __args)\n+        {\n+          return this->__call(_GLIBCXX_TR1 tie(__args...), _Bound_indexes());\n+        }\n+\n+      // Call as const\n+      template<typename... _Args>\n+        result_type\n+        operator()(_Args&... __args) const\n+        {\n+          return this->__call(_GLIBCXX_TR1 tie(__args...), _Bound_indexes());\n+        }\n+\n+      // Call as volatile\n+      template<typename... _Args>\n+        result_type\n+        operator()(_Args&... __args) volatile\n+        {\n+          return this->__call(_GLIBCXX_TR1 tie(__args...), _Bound_indexes());\n+        }\n+\n+      // Call as const volatile\n+      template<typename... _Args>\n+        result_type\n+        operator()(_Args&... __args) const volatile\n+        {\n+          return this->__call(_GLIBCXX_TR1 tie(__args...), _Bound_indexes());\n+        }\n+    };\n+\n+  /**\n+   *  @if maint\n+   *  Class template _Bind is always a bind expression.\n+   *  @endif\n+   */\n+  template<typename _Signature>\n+    struct is_bind_expression<_Bind<_Signature> >\n+    { static const bool value = true; };\n+\n+  template<typename _Signature>\n+    const bool is_bind_expression<_Bind<_Signature> >::value;\n+\n+  /**\n+   *  @if maint\n+   *  Class template _Bind_result is always a bind expression.\n+   *  @endif\n+   */\n+  template<typename _Result, typename _Signature>\n+    struct is_bind_expression<_Bind_result<_Result, _Signature> >\n+    { static const bool value = true; };\n+\n+  template<typename _Result, typename _Signature>\n+    const bool is_bind_expression<_Bind_result<_Result, _Signature> >::value;\n+\n+  template<typename _Functor, typename... _ArgTypes>\n+    inline\n+    _Bind<typename _Maybe_wrap_member_pointer<_Functor>::type(_ArgTypes...)>\n+    bind(_Functor __f, _ArgTypes... __args)\n+    {\n+      typedef _Maybe_wrap_member_pointer<_Functor> __maybe_type;\n+      typedef typename __maybe_type::type __functor_type;\n+      typedef _Bind<__functor_type(_ArgTypes...)> __result_type;\n+      return __result_type(__maybe_type::__do_wrap(__f), __args...);\n+    } \n+\n+  template<typename _Result, typename _Functor, typename... _ArgTypes>\n+    inline\n+    _Bind_result<_Result,\n+\t\t typename _Maybe_wrap_member_pointer<_Functor>::type\n+                            (_ArgTypes...)>\n+    bind(_Functor __f, _ArgTypes... __args)\n+    {\n+      typedef _Maybe_wrap_member_pointer<_Functor> __maybe_type;\n+      typedef typename __maybe_type::type __functor_type;\n+      typedef _Bind_result<_Result, __functor_type(_ArgTypes...)>\n+\t__result_type;\n+      return __result_type(__maybe_type::__do_wrap(__f), __args...);\n+    }\n+\n+  /**\n+   *  @brief Exception class thrown when class template function's\n+   *  operator() is called with an empty target.\n+   *\n+   */\n+  class bad_function_call : public std::exception { };\n+\n+  /**\n+   *  @if maint\n+   *  The integral constant expression 0 can be converted into a\n+   *  pointer to this type. It is used by the function template to\n+   *  accept NULL pointers.\n+   *  @endif\n+   */\n+  struct _M_clear_type;\n+\n+  /**\n+   *  @if maint\n+   *  Trait identifying \"location-invariant\" types, meaning that the\n+   *  address of the object (or any of its members) will not escape.\n+   *  Also implies a trivial copy constructor and assignment operator.\n+   *   @endif\n+   */\n+  template<typename _Tp>\n+    struct __is_location_invariant\n+    : integral_constant<bool,\n+                        (is_pointer<_Tp>::value\n+                         || is_member_pointer<_Tp>::value)>\n+    {\n+    };\n+\n+  class _Undefined_class;\n+\n+  union _Nocopy_types\n+  {\n+    void*       _M_object;\n+    const void* _M_const_object;\n+    void (*_M_function_pointer)();\n+    void (_Undefined_class::*_M_member_pointer)();\n+  };\n+\n+  union _Any_data\n+  {\n+    void*       _M_access()       { return &_M_pod_data[0]; }\n+    const void* _M_access() const { return &_M_pod_data[0]; }\n+\n+    template<typename _Tp>\n+      _Tp&\n+      _M_access()\n+      { return *static_cast<_Tp*>(_M_access()); }\n+\n+    template<typename _Tp>\n+      const _Tp&\n+      _M_access() const\n+      { return *static_cast<const _Tp*>(_M_access()); }\n+\n+    _Nocopy_types _M_unused;\n+    char _M_pod_data[sizeof(_Nocopy_types)];\n+  };\n+\n+  enum _Manager_operation\n+  {\n+    __get_type_info,\n+    __get_functor_ptr,\n+    __clone_functor,\n+    __destroy_functor\n+  };\n+\n+  /* Simple type wrapper that helps avoid annoying const problems\n+     when casting between void pointers and pointers-to-pointers. */\n+  template<typename _Tp>\n+    struct _Simple_type_wrapper\n+    {\n+      _Simple_type_wrapper(_Tp __value) : __value(__value) { }\n+\n+      _Tp __value;\n+    };\n+\n+  template<typename _Tp>\n+    struct __is_location_invariant<_Simple_type_wrapper<_Tp> >\n+    : __is_location_invariant<_Tp>\n+    {\n+    };\n+\n+  // Converts a reference to a function object into a callable\n+  // function object.\n+  template<typename _Functor>\n+    inline _Functor&\n+    __callable_functor(_Functor& __f)\n+    { return __f; }\n+\n+  template<typename _Member, typename _Class>\n+    inline _Mem_fn<_Member _Class::*>\n+    __callable_functor(_Member _Class::* &__p)\n+    { return mem_fn(__p); }\n+\n+  template<typename _Member, typename _Class>\n+    inline _Mem_fn<_Member _Class::*>\n+    __callable_functor(_Member _Class::* const &__p)\n+    { return mem_fn(__p); }\n+\n+  template<typename _Signature>\n+    class function;\n+\n+  /**\n+   *  @if maint\n+   *  Base class of all polymorphic function object wrappers.\n+   *  @endif\n+   */\n+  class _Function_base\n+  {\n+  public:\n+    static const std::size_t _M_max_size = sizeof(_Nocopy_types);\n+    static const std::size_t _M_max_align = __alignof__(_Nocopy_types);\n+\n+    template<typename _Functor>\n+      class _Base_manager\n+      {\n+      protected:\n+\tstatic const bool __stored_locally =\n+        (__is_location_invariant<_Functor>::value\n+         && sizeof(_Functor) <= _M_max_size\n+         && __alignof__(_Functor) <= _M_max_align\n+         && (_M_max_align % __alignof__(_Functor) == 0));\n+\t\n+\ttypedef integral_constant<bool, __stored_locally> _Local_storage;\n+\n+\t// Retrieve a pointer to the function object\n+\tstatic _Functor*\n+\t_M_get_pointer(const _Any_data& __source)\n+\t{\n+\t  const _Functor* __ptr =\n+\t    __stored_locally? &__source._M_access<_Functor>()\n+\t    /* have stored a pointer */ : __source._M_access<_Functor*>();\n+\t  return const_cast<_Functor*>(__ptr);\n+\t}\n+\n+\t// Clone a location-invariant function object that fits within\n+\t// an _Any_data structure.\n+\tstatic void\n+\t_M_clone(_Any_data& __dest, const _Any_data& __source, true_type)\n+\t{\n+\t  new (__dest._M_access()) _Functor(__source._M_access<_Functor>());\n+\t}\n+\n+\t// Clone a function object that is not location-invariant or\n+\t// that cannot fit into an _Any_data structure.\n+\tstatic void\n+\t_M_clone(_Any_data& __dest, const _Any_data& __source, false_type)\n+\t{\n+\t  __dest._M_access<_Functor*>() =\n+\t    new _Functor(*__source._M_access<_Functor*>());\n+\t}\n+\n+\t// Destroying a location-invariant object may still require\n+\t// destruction.\n+\tstatic void\n+\t_M_destroy(_Any_data& __victim, true_type)\n+\t{\n+\t  __victim._M_access<_Functor>().~_Functor();\n+\t}\n+\t\n+\t// Destroying an object located on the heap.\n+\tstatic void\n+\t_M_destroy(_Any_data& __victim, false_type)\n+\t{\n+\t  delete __victim._M_access<_Functor*>();\n+\t}\n+\t\n+      public:\n+\tstatic bool\n+\t_M_manager(_Any_data& __dest, const _Any_data& __source,\n+\t\t   _Manager_operation __op)\n+\t{\n+\t  switch (__op)\n+\t    {\n+\t    case __get_type_info:\n+\t      __dest._M_access<const type_info*>() = &typeid(_Functor);\n+\t      break;\n+\n+\t    case __get_functor_ptr:\n+\t      __dest._M_access<_Functor*>() = _M_get_pointer(__source);\n+\t      break;\n+\t      \n+\t    case __clone_functor:\n+\t      _M_clone(__dest, __source, _Local_storage());\n+\t      break;\n+\n+\t    case __destroy_functor:\n+\t      _M_destroy(__dest, _Local_storage());\n+\t      break;\n+\t    }\n+\t  return false;\n+\t}\n+\n+\tstatic void\n+\t_M_init_functor(_Any_data& __functor, const _Functor& __f)\n+\t{\n+\t  _M_init_functor(__functor, __f, _Local_storage());\n+\t}\n+\t\n+\ttemplate<typename _Signature>\n+\t  static bool\n+\t  _M_not_empty_function(const function<_Signature>& __f)\n+\t  {\n+\t    return __f;\n+\t  }\n+\n+\ttemplate<typename _Tp>\n+\t  static bool\n+\t  _M_not_empty_function(const _Tp*& __fp)\n+\t  {\n+\t    return __fp;\n+\t  }\n+\n+\ttemplate<typename _Class, typename _Tp>\n+\t  static bool\n+\t  _M_not_empty_function(_Tp _Class::* const& __mp)\n+\t  {\n+\t    return __mp;\n+\t  }\n+\n+\ttemplate<typename _Tp>\n+\t  static bool\n+\t  _M_not_empty_function(const _Tp&)\n+\t  {\n+\t    return true;\n+\t  }\n+\n+      private:\n+\tstatic void\n+\t_M_init_functor(_Any_data& __functor, const _Functor& __f, true_type)\n+\t{\n+\t  new (__functor._M_access()) _Functor(__f);\n+\t}\n+\n+\tstatic void\n+\t_M_init_functor(_Any_data& __functor, const _Functor& __f, false_type)\n+\t{\n+\t  __functor._M_access<_Functor*>() = new _Functor(__f);\n+\t}\n+      };\n+\n+    template<typename _Functor>\n+      class _Ref_manager : public _Base_manager<_Functor*>\n+      {\n+\ttypedef _Function_base::_Base_manager<_Functor*> _Base;\n+\n+    public:\n+\tstatic bool\n+\t_M_manager(_Any_data& __dest, const _Any_data& __source,\n+\t\t   _Manager_operation __op)\n+\t{\n+\t  switch (__op)\n+\t    {\n+\t    case __get_type_info:\n+\t      __dest._M_access<const type_info*>() = &typeid(_Functor);\n+\t      break;\n+\t      \n+\t    case __get_functor_ptr:\n+\t      __dest._M_access<_Functor*>() = *_Base::_M_get_pointer(__source);\n+\t      return is_const<_Functor>::value;\n+\t      break;\n+\t      \n+\t    default:\n+\t      _Base::_M_manager(__dest, __source, __op);\n+\t    }\n+\t  return false;\n+\t}\n+\n+\tstatic void\n+\t_M_init_functor(_Any_data& __functor, reference_wrapper<_Functor> __f)\n+\t{\n+\t  // TBD: Use address_of function instead\n+\t  _Base::_M_init_functor(__functor, &__f.get());\n+\t}\n+      };\n+\n+    _Function_base() : _M_manager(0) { }\n+    \n+    ~_Function_base()\n+    {\n+      if (_M_manager)\n+\t_M_manager(_M_functor, _M_functor, __destroy_functor);\n+    }\n+\n+\n+    bool _M_empty() const { return !_M_manager; }\n+\n+    typedef bool (*_Manager_type)(_Any_data&, const _Any_data&,\n+                                  _Manager_operation);\n+\n+    _Any_data     _M_functor;\n+    _Manager_type _M_manager;\n+  };\n+\n+  template<typename _Signature, typename _Functor>\n+    class _Function_handler;\n+\n+  template<typename _Res, typename _Functor, typename... _ArgTypes>\n+    class _Function_handler<_Res(_ArgTypes...), _Functor>\n+    : public _Function_base::_Base_manager<_Functor>\n+    {\n+      typedef _Function_base::_Base_manager<_Functor> _Base;\n+\n+    public:\n+      static _Res\n+      _M_invoke(const _Any_data& __functor, _ArgTypes... __args)\n+      {\n+        return (*_Base::_M_get_pointer(__functor))(__args...);\n+      }\n+    };\n+\n+  template<typename _Functor, typename... _ArgTypes>\n+    class _Function_handler<void(_ArgTypes...), _Functor>\n+    : public _Function_base::_Base_manager<_Functor>\n+    {\n+      typedef _Function_base::_Base_manager<_Functor> _Base;\n+\n+     public:\n+      static void\n+      _M_invoke(const _Any_data& __functor, _ArgTypes... __args)\n+      {\n+        (*_Base::_M_get_pointer(__functor))(__args...);\n+      }\n+    };\n+\n+  template<typename _Res, typename _Functor, typename... _ArgTypes>\n+    class _Function_handler<_Res(_ArgTypes...), reference_wrapper<_Functor> >\n+    : public _Function_base::_Ref_manager<_Functor>\n+    {\n+      typedef _Function_base::_Ref_manager<_Functor> _Base;\n+\n+     public:\n+      static _Res\n+      _M_invoke(const _Any_data& __functor, _ArgTypes... __args)\n+      {\n+        return \n+          __callable_functor(**_Base::_M_get_pointer(__functor))(__args...);\n+      }\n+    };\n+\n+  template<typename _Functor, typename... _ArgTypes>\n+    class _Function_handler<void(_ArgTypes...), reference_wrapper<_Functor> >\n+    : public _Function_base::_Ref_manager<_Functor>\n+    {\n+      typedef _Function_base::_Ref_manager<_Functor> _Base;\n+\n+     public:\n+      static void\n+      _M_invoke(const _Any_data& __functor, _ArgTypes... __args)\n+      {\n+        __callable_functor(**_Base::_M_get_pointer(__functor))(__args...);\n+      }\n+    };\n+\n+  template<typename _Class, typename _Member, typename _Res, \n+           typename... _ArgTypes>\n+    class _Function_handler<_Res(_ArgTypes...), _Member _Class::*>\n+    : public _Function_handler<void(_ArgTypes...), _Member _Class::*>\n+    {\n+      typedef _Function_handler<void(_ArgTypes...), _Member _Class::*>\n+        _Base;\n+\n+     public:\n+      static _Res\n+      _M_invoke(const _Any_data& __functor, _ArgTypes... __args)\n+      {\n+        return _GLIBCXX_TR1\n+\t  mem_fn(_Base::_M_get_pointer(__functor)->__value)(__args...);\n+      }\n+    };\n+\n+  template<typename _Class, typename _Member, typename... _ArgTypes>\n+    class _Function_handler<void(_ArgTypes...), _Member _Class::*>\n+    : public _Function_base::_Base_manager<\n+                 _Simple_type_wrapper< _Member _Class::* > >\n+    {\n+      typedef _Member _Class::* _Functor;\n+      typedef _Simple_type_wrapper<_Functor> _Wrapper;\n+      typedef _Function_base::_Base_manager<_Wrapper> _Base;\n+\n+     public:\n+      static bool\n+      _M_manager(_Any_data& __dest, const _Any_data& __source,\n+                 _Manager_operation __op)\n+      {\n+        switch (__op)\n+\t  {\n+\t  case __get_type_info:\n+\t    __dest._M_access<const type_info*>() = &typeid(_Functor);\n+\t    break;\n+\t    \n+\t  case __get_functor_ptr:\n+\t    __dest._M_access<_Functor*>() =\n+\t      &_Base::_M_get_pointer(__source)->__value;\n+\t    break;\n+\t    \n+\t  default:\n+\t    _Base::_M_manager(__dest, __source, __op);\n+\t  }\n+        return false;\n+      }\n+\n+      static void\n+      _M_invoke(const _Any_data& __functor, _ArgTypes... __args)\n+      {\n+        _GLIBCXX_TR1\n+\t  mem_fn(_Base::_M_get_pointer(__functor)->__value)(__args...);\n+      }\n+    };\n+\n+  template<typename _Res, typename... _ArgTypes>\n+    class function<_Res(_ArgTypes...)>\n+    : public _Maybe_unary_or_binary_function<_Res, _ArgTypes...>,\n+      private _Function_base\n+    {\n+      /**\n+       *  @if maint\n+       *  This class is used to implement the safe_bool idiom.\n+       *  @endif\n+       */\n+      struct _Hidden_type\n+      {\n+\t_Hidden_type* _M_bool;\n+      };\n+\n+      /**\n+       *  @if maint\n+       *  This typedef is used to implement the safe_bool idiom.\n+       *  @endif\n+       */\n+      typedef _Hidden_type* _Hidden_type::* _Safe_bool;\n+\n+      typedef _Res _Signature_type(_ArgTypes...);\n+      \n+      struct _Useless {};\n+      \n+    public:\n+      typedef _Res result_type;\n+      \n+      // [3.7.2.1] construct/copy/destroy\n+      \n+      /**\n+       *  @brief Default construct creates an empty function call wrapper.\n+       *  @post @c !(bool)*this\n+       */\n+      function() : _Function_base() { }\n+      \n+      /**\n+       *  @brief Default construct creates an empty function call wrapper.\n+       *  @post @c !(bool)*this\n+       */\n+      function(_M_clear_type*) : _Function_base() { }\n+      \n+      /**\n+       *  @brief %Function copy constructor.\n+       *  @param x A %function object with identical call signature.\n+       *  @pre @c (bool)*this == (bool)x\n+       *\n+       *  The newly-created %function contains a copy of the target of @a\n+       *  x (if it has one).\n+       */\n+      function(const function& __x);\n+      \n+      /**\n+       *  @brief Builds a %function that targets a copy of the incoming\n+       *  function object.\n+       *  @param f A %function object that is callable with parameters of\n+       *  type @c T1, @c T2, ..., @c TN and returns a value convertible\n+       *  to @c Res.\n+       *\n+       *  The newly-created %function object will target a copy of @a\n+       *  f. If @a f is @c reference_wrapper<F>, then this function\n+       *  object will contain a reference to the function object @c\n+       *  f.get(). If @a f is a NULL function pointer or NULL\n+       *  pointer-to-member, the newly-created object will be empty.\n+       *\n+       *  If @a f is a non-NULL function pointer or an object of type @c\n+       *  reference_wrapper<F>, this function will not throw.\n+       */\n+      template<typename _Functor>\n+        function(_Functor __f,\n+                 typename __gnu_cxx::__enable_if<\n+                           !is_integral<_Functor>::value, _Useless>::__type\n+                   = _Useless());\n+\n+      /**\n+       *  @brief %Function assignment operator.\n+       *  @param x A %function with identical call signature.\n+       *  @post @c (bool)*this == (bool)x\n+       *  @returns @c *this\n+       *\n+       *  The target of @a x is copied to @c *this. If @a x has no\n+       *  target, then @c *this will be empty.\n+       *\n+       *  If @a x targets a function pointer or a reference to a function\n+       *  object, then this operation will not throw an exception.\n+       */\n+      function&\n+      operator=(const function& __x)\n+      {\n+        function(__x).swap(*this);\n+        return *this;\n+      }\n+\n+      /**\n+       *  @brief %Function assignment to zero.\n+       *  @post @c !(bool)*this\n+       *  @returns @c *this\n+       *\n+       *  The target of @a *this is deallocated, leaving it empty.\n+       */\n+      function&\n+      operator=(_M_clear_type*)\n+      {\n+        if (_M_manager)\n+\t  {\n+\t    _M_manager(_M_functor, _M_functor, __destroy_functor);\n+\t    _M_manager = 0;\n+\t    _M_invoker = 0;\n+\t  }\n+        return *this;\n+      }\n+\n+      /**\n+       *  @brief %Function assignment to a new target.\n+       *  @param f A %function object that is callable with parameters of\n+       *  type @c T1, @c T2, ..., @c TN and returns a value convertible\n+       *  to @c Res.\n+       *  @return @c *this\n+       *\n+       *  This  %function object wrapper will target a copy of @a\n+       *  f. If @a f is @c reference_wrapper<F>, then this function\n+       *  object will contain a reference to the function object @c\n+       *  f.get(). If @a f is a NULL function pointer or NULL\n+       *  pointer-to-member, @c this object will be empty.\n+       *\n+       *  If @a f is a non-NULL function pointer or an object of type @c\n+       *  reference_wrapper<F>, this function will not throw.\n+       */\n+      template<typename _Functor>\n+        typename __gnu_cxx::__enable_if<!is_integral<_Functor>::value,\n+\t                                function&>::__type\n+\toperator=(_Functor __f)\n+\t{\n+\t  function(__f).swap(*this);\n+\t  return *this;\n+\t}\n+\n+      // [3.7.2.2] function modifiers\n+      \n+      /**\n+       *  @brief Swap the targets of two %function objects.\n+       *  @param f A %function with identical call signature.\n+       *\n+       *  Swap the targets of @c this function object and @a f. This\n+       *  function will not throw an exception.\n+       */\n+      void swap(function& __x)\n+      {\n+\t_Any_data __old_functor = _M_functor;\n+\t_M_functor = __x._M_functor;\n+\t__x._M_functor = __old_functor;\n+\t_Manager_type __old_manager = _M_manager;\n+\t_M_manager = __x._M_manager;\n+\t__x._M_manager = __old_manager;\n+\t_Invoker_type __old_invoker = _M_invoker;\n+\t_M_invoker = __x._M_invoker;\n+\t__x._M_invoker = __old_invoker;\n+      }\n+      \n+      // [3.7.2.3] function capacity\n+\n+      /**\n+       *  @brief Determine if the %function wrapper has a target.\n+       *\n+       *  @return @c true when this %function object contains a target,\n+       *  or @c false when it is empty.\n+       *\n+       *  This function will not throw an exception.\n+       */\n+      operator _Safe_bool() const\n+      {\n+        if (_M_empty())\n+\t  return 0;\n+\telse\n+\t  return &_Hidden_type::_M_bool;\n+      }\n+\n+      // [3.7.2.4] function invocation\n+\n+      /**\n+       *  @brief Invokes the function targeted by @c *this.\n+       *  @returns the result of the target.\n+       *  @throws bad_function_call when @c !(bool)*this\n+       *\n+       *  The function call operator invokes the target function object\n+       *  stored by @c this.\n+       */\n+      _Res operator()(_ArgTypes... __args) const;\n+      \n+      // [3.7.2.5] function target access\n+      /**\n+       *  @brief Determine the type of the target of this function object\n+       *  wrapper.\n+       *\n+       *  @returns the type identifier of the target function object, or\n+       *  @c typeid(void) if @c !(bool)*this.\n+       *\n+       *  This function will not throw an exception.\n+       */\n+      const type_info& target_type() const;\n+      \n+      /**\n+       *  @brief Access the stored target function object.\n+       *\n+       *  @return Returns a pointer to the stored target function object,\n+       *  if @c typeid(Functor).equals(target_type()); otherwise, a NULL\n+       *  pointer.\n+       *\n+       * This function will not throw an exception.\n+       */\n+      template<typename _Functor>       _Functor* target();\n+      \n+      /**\n+       *  @overload\n+       */\n+      template<typename _Functor> const _Functor* target() const;\n+      \n+    private:\n+      // [3.7.2.6] undefined operators\n+      template<typename _Function>\n+\tvoid operator==(const function<_Function>&) const;\n+      template<typename _Function>\n+\tvoid operator!=(const function<_Function>&) const;\n+\n+      typedef _Res (*_Invoker_type)(const _Any_data&, _ArgTypes...);\n+      _Invoker_type _M_invoker;\n+  };\n+\n+  template<typename _Res, typename... _ArgTypes>\n+    function<_Res(_ArgTypes...)>::\n+    function(const function& __x)\n+    : _Function_base()\n+    {\n+      if (__x)\n+\t{\n+\t  _M_invoker = __x._M_invoker;\n+\t  _M_manager = __x._M_manager;\n+\t  __x._M_manager(_M_functor, __x._M_functor, __clone_functor);\n+\t}\n+    }\n+\n+  template<typename _Res, typename... _ArgTypes>\n+    template<typename _Functor>\n+      function<_Res(_ArgTypes...)>::\n+      function(_Functor __f,\n+\t       typename __gnu_cxx::__enable_if<\n+                       !is_integral<_Functor>::value, _Useless>::__type)\n+      : _Function_base()\n+      {\n+\ttypedef _Function_handler<_Signature_type, _Functor> _My_handler;\n+\n+\tif (_My_handler::_M_not_empty_function(__f))\n+\t  {\n+\t    _M_invoker = &_My_handler::_M_invoke;\n+\t    _M_manager = &_My_handler::_M_manager;\n+\t    _My_handler::_M_init_functor(_M_functor, __f);\n+\t  }\n+      }\n+\n+  template<typename _Res, typename... _ArgTypes>\n+    _Res\n+    function<_Res(_ArgTypes...)>::\n+    operator()(_ArgTypes... __args) const\n+    {\n+      if (_M_empty())\n+        {\n+#if __EXCEPTIONS\n+          throw bad_function_call();\n+#else\n+          __builtin_abort();\n+#endif\n+        }\n+      return _M_invoker(_M_functor, __args...);\n+    }\n+\n+  template<typename _Res, typename... _ArgTypes>\n+    const type_info&\n+    function<_Res(_ArgTypes...)>::\n+    target_type() const\n+    {\n+      if (_M_manager)\n+        {\n+          _Any_data __typeinfo_result;\n+          _M_manager(__typeinfo_result, _M_functor, __get_type_info);\n+          return *__typeinfo_result._M_access<const type_info*>();\n+        }\n+      else\n+\treturn typeid(void);\n+    }\n+\n+  template<typename _Res, typename... _ArgTypes>\n+    template<typename _Functor>\n+      _Functor*\n+      function<_Res(_ArgTypes...)>::\n+      target()\n+      {\n+\tif (typeid(_Functor) == target_type() && _M_manager)\n+\t  {\n+\t    _Any_data __ptr;\n+\t    if (_M_manager(__ptr, _M_functor, __get_functor_ptr)\n+\t\t&& !is_const<_Functor>::value)\n+\t      return 0;\n+\t    else\n+\t      return __ptr._M_access<_Functor*>();\n+\t  }\n+\telse\n+\t  return 0;\n+      }\n+\n+  template<typename _Res, typename... _ArgTypes>\n+    template<typename _Functor>\n+      const _Functor*\n+      function<_Res(_ArgTypes...)>::\n+      target() const\n+      {\n+\tif (typeid(_Functor) == target_type() && _M_manager)\n+\t  {\n+\t    _Any_data __ptr;\n+\t    _M_manager(__ptr, _M_functor, __get_functor_ptr);\n+\t    return __ptr._M_access<const _Functor*>();\n+\t  }\n+\telse\n+\t  return 0;\n+      }\n+\n+  // [3.7.2.7] null pointer comparisons\n+\n+  /**\n+   *  @brief Compares a polymorphic function object wrapper against 0\n+   *  (the NULL pointer).\n+   *  @returns @c true if the wrapper has no target, @c false otherwise\n+   *\n+   *  This function will not throw an exception.\n+   */\n+  template<typename _Signature>\n+    inline bool\n+    operator==(const function<_Signature>& __f, _M_clear_type*)\n+    { \n+      return !__f;\n+    }\n+\n+  /**\n+   *  @overload\n+   */\n+  template<typename _Signature>\n+    inline bool\n+    operator==(_M_clear_type*, const function<_Signature>& __f)\n+    {\n+      return !__f;\n+    }\n+\n+  /**\n+   *  @brief Compares a polymorphic function object wrapper against 0\n+   *  (the NULL pointer).\n+   *  @returns @c false if the wrapper has no target, @c true otherwise\n+   *\n+   *  This function will not throw an exception.\n+   */\n+  template<typename _Signature>\n+    inline bool\n+    operator!=(const function<_Signature>& __f, _M_clear_type*)\n+    {\n+      return __f;\n+    }\n+\n+  /**\n+   *  @overload\n+   */\n+  template<typename _Signature>\n+    inline bool\n+    operator!=(_M_clear_type*, const function<_Signature>& __f)\n+    {\n+      return __f;\n+    }\n+\n+  // [3.7.2.8] specialized algorithms\n+\n+  /**\n+   *  @brief Swap the targets of two polymorphic function object wrappers.\n+   *\n+   *  This function will not throw an exception.\n+   */\n+  template<typename _Signature>\n+    inline void\n+    swap(function<_Signature>& __x, function<_Signature>& __y)\n+    {\n+      __x.swap(__y);\n+    }\n+\n+_GLIBCXX_END_NAMESPACE_TR1\n+}"}, {"sha": "3b1a758338333cffe1a58a4e19d84f6e5d7b0abf", "filename": "libstdc++-v3/include/tr1_impl/functional_hash.h", "status": "added", "additions": 223, "deletions": 0, "changes": 223, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e133ace8d907bf42754c86106fc3f04a9d9fe70f/libstdc%2B%2B-v3%2Finclude%2Ftr1_impl%2Ffunctional_hash.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e133ace8d907bf42754c86106fc3f04a9d9fe70f/libstdc%2B%2B-v3%2Finclude%2Ftr1_impl%2Ffunctional_hash.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Ftr1_impl%2Ffunctional_hash.h?ref=e133ace8d907bf42754c86106fc3f04a9d9fe70f", "patch": "@@ -0,0 +1,223 @@\n+// TR1 functional -*- C++ -*-\n+\n+// Copyright (C) 2007 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301,\n+// USA.\n+\n+// As a special exception, you may use this file as part of a free software\n+// library without restriction.  Specifically, if other files instantiate\n+// templates or use macros or inline functions from this file, or you compile\n+// this file and link it with other files to produce an executable, this\n+// file does not by itself cause the resulting executable to be covered by\n+// the GNU General Public License.  This exception does not however\n+// invalidate any other reasons why the executable file might be covered by\n+// the GNU General Public License.\n+\n+/** @file tr1_impl/functional_hash.h\n+ *  This is an internal header file, included by other library headers.\n+ *  You should not attempt to use it directly.\n+ */\n+\n+namespace std\n+{\n+_GLIBCXX_BEGIN_NAMESPACE_TR1\n+\n+  // Definition of default hash function std::tr1::hash<>.  The types for\n+  // which std::tr1::hash<T> is defined is in clause 6.3.3. of the PDTR.\n+  template<typename _Tp>\n+    struct hash;\n+\n+#define _TR1_hashtable_define_trivial_hash(_Tp)         \\\n+  template<>                                            \\\n+    struct hash<_Tp>                                    \\\n+    : public std::unary_function<_Tp, std::size_t>      \\\n+    {                                                   \\\n+      std::size_t                                       \\\n+      operator()(_Tp __val) const                       \\\n+      { return static_cast<std::size_t>(__val); }       \\\n+    }                                                     \n+\n+  _TR1_hashtable_define_trivial_hash(bool);\n+  _TR1_hashtable_define_trivial_hash(char);\n+  _TR1_hashtable_define_trivial_hash(signed char);\n+  _TR1_hashtable_define_trivial_hash(unsigned char);\n+  _TR1_hashtable_define_trivial_hash(wchar_t);\n+  _TR1_hashtable_define_trivial_hash(short);\n+  _TR1_hashtable_define_trivial_hash(int);\n+  _TR1_hashtable_define_trivial_hash(long);\n+  _TR1_hashtable_define_trivial_hash(long long);\n+  _TR1_hashtable_define_trivial_hash(unsigned short);\n+  _TR1_hashtable_define_trivial_hash(unsigned int);\n+  _TR1_hashtable_define_trivial_hash(unsigned long);\n+  _TR1_hashtable_define_trivial_hash(unsigned long long);\n+\n+#undef _TR1_hashtable_define_trivial_hash\n+\n+  template<typename _Tp>\n+    struct hash<_Tp*>\n+    : public std::unary_function<_Tp*, std::size_t>\n+    {\n+      std::size_t\n+      operator()(_Tp* __p) const\n+      { return reinterpret_cast<std::size_t>(__p); }\n+    };\n+\n+  // Fowler / Noll / Vo (FNV) Hash (type FNV-1a)\n+  // (used by the next specializations of std::tr1::hash<>)\n+\n+  // Dummy generic implementation (for sizeof(size_t) != 4, 8).\n+  template<std::size_t = sizeof(std::size_t)>\n+    struct _Fnv_hash\n+    {\n+      static std::size_t\n+      hash(const char* __first, std::size_t __length)\n+      {\n+\tstd::size_t __result = 0;\n+\tfor (; __length > 0; --__length)\n+\t  __result = (__result * 131) + *__first++;\n+\treturn __result;\n+      }\n+    };\n+\n+  template<>\n+    struct _Fnv_hash<4>\n+    {\n+      static std::size_t\n+      hash(const char* __first, std::size_t __length)\n+      {\n+\tstd::size_t __result = static_cast<std::size_t>(2166136261UL);\n+\tfor (; __length > 0; --__length)\n+\t  {\n+\t    __result ^= static_cast<std::size_t>(*__first++);\n+\t    __result *= static_cast<std::size_t>(16777619UL);\n+\t  }\n+\treturn __result;\n+      }\n+    };\n+  \n+  template<>\n+    struct _Fnv_hash<8>\n+    {\n+      static std::size_t\n+      hash(const char* __first, std::size_t __length)\n+      {\n+\tstd::size_t __result =\n+\t  static_cast<std::size_t>(14695981039346656037ULL);\n+\tfor (; __length > 0; --__length)\n+\t  {\n+\t    __result ^= static_cast<std::size_t>(*__first++);\n+\t    __result *= static_cast<std::size_t>(1099511628211ULL);\n+\t  }\n+\treturn __result;\n+      }\n+    };\n+\n+  // XXX String and floating point hashes probably shouldn't be inline\n+  // member functions, since are nontrivial.  Once we have the framework\n+  // for TR1 .cc files, these should go in one.\n+  template<>\n+    struct hash<std::string>\n+    : public std::unary_function<std::string, std::size_t>\n+    {      \n+      std::size_t\n+      operator()(const std::string& __s) const\n+      { return _Fnv_hash<>::hash(__s.data(), __s.length()); }\n+    };\n+\n+#ifdef _GLIBCXX_USE_WCHAR_T\n+  template<>\n+    struct hash<std::wstring>\n+    : public std::unary_function<std::wstring, std::size_t>\n+    {\n+      std::size_t\n+      operator()(const std::wstring& __s) const\n+      {\n+\treturn _Fnv_hash<>::hash(reinterpret_cast<const char*>(__s.data()),\n+\t\t\t\t __s.length() * sizeof(wchar_t));\n+      }\n+    };\n+#endif\n+\n+  template<>\n+    struct hash<float>\n+    : public std::unary_function<float, std::size_t>\n+    {\n+      std::size_t\n+      operator()(float __fval) const\n+      {\n+\tstd::size_t __result = 0;\n+\n+\t// 0 and -0 both hash to zero.\n+\tif (__fval != 0.0f)\n+\t  __result = _Fnv_hash<>::hash(reinterpret_cast<const char*>(&__fval),\n+\t\t\t\t       sizeof(__fval));\n+\treturn __result;\n+      }\n+    };\n+\n+  template<>\n+    struct hash<double>\n+    : public std::unary_function<double, std::size_t>\n+    {\n+      std::size_t\n+      operator()(double __dval) const\n+      {\n+\tstd::size_t __result = 0;\n+\n+\t// 0 and -0 both hash to zero.\n+\tif (__dval != 0.0)\n+\t  __result = _Fnv_hash<>::hash(reinterpret_cast<const char*>(&__dval),\n+\t\t\t\t       sizeof(__dval));\n+\treturn __result;\n+      }\n+    };\n+\n+  // For long double, careful with random padding bits (e.g., on x86,\n+  // 10 bytes -> 12 bytes) and resort to frexp.\n+  template<>\n+    struct hash<long double>\n+    : public std::unary_function<long double, std::size_t>\n+    {\n+      std::size_t\n+      operator()(long double __ldval) const\n+      {\n+\tstd::size_t __result = 0;\n+\n+\tint __exponent;\n+\t__ldval = std::frexp(__ldval, &__exponent);\n+\t__ldval = __ldval < 0.0l ? -(__ldval + 0.5l) : __ldval;\n+\n+\tconst long double __mult =\n+\t  __gnu_cxx::__numeric_traits<std::size_t>::__max + 1.0l;\n+\t__ldval *= __mult;\n+\n+\t// Try to use all the bits of the mantissa (really necessary only\n+\t// on 32-bit targets, at least for 80-bit floating point formats).\n+\tconst std::size_t __hibits = (std::size_t)__ldval;\n+\t__ldval = (__ldval - (long double)__hibits) * __mult;\n+\n+\tconst std::size_t __coeff =\n+\t  __gnu_cxx::__numeric_traits<std::size_t>::__max / __LDBL_MAX_EXP__;\n+\n+\t__result = __hibits + (std::size_t)__ldval + __coeff * __exponent;\n+\n+\treturn __result;\n+      }\n+    };\n+\n+_GLIBCXX_END_NAMESPACE_TR1\n+}"}, {"sha": "acdeb6675667a9469e9f033da4396a514f999038", "filename": "libstdc++-v3/include/tr1_impl/hashtable", "status": "renamed", "additions": 13, "deletions": 26, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e133ace8d907bf42754c86106fc3f04a9d9fe70f/libstdc%2B%2B-v3%2Finclude%2Ftr1_impl%2Fhashtable", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e133ace8d907bf42754c86106fc3f04a9d9fe70f/libstdc%2B%2B-v3%2Finclude%2Ftr1_impl%2Fhashtable", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Ftr1_impl%2Fhashtable?ref=e133ace8d907bf42754c86106fc3f04a9d9fe70f", "patch": "@@ -1,6 +1,6 @@\n // Internal header for TR1 unordered_set and unordered_map -*- C++ -*-\n \n-// Copyright (C) 2005, 2006, 2007 Free Software Foundation, Inc.\n+// Copyright (C) 2007 Free Software Foundation, Inc.\n //\n // This file is part of the GNU ISO C++ Library.  This library is free\n // software; you can redistribute it and/or modify it under the\n@@ -27,8 +27,9 @@\n // invalidate any other reasons why the executable file might be covered by\n // the GNU General Public License.\n \n-/** @file tr1/hashtable\n- *  This is a TR1 C++ Library header. \n+/** @file tr1_impl/hashtable\n+ *  This is an internal header file, included by other library headers.\n+ *  You should not attempt to use it directly.\n  */\n \n // This header file defines std::tr1::hashtable, which is used to\n@@ -49,22 +50,11 @@\n // A. Tavori and V. Dreizin, \"Policy-Based Data Structures\", 2004.\n // http://gcc.gnu.org/onlinedocs/libstdc++/ext/pb_ds/index.html\n \n-#ifndef _TR1_HASHTABLE\n-#define _TR1_HASHTABLE 1\n-\n-#include <utility>\t\t// For std::pair\n-#include <cstddef>\n-#include <cmath>\n-#include <bits/stl_iterator_base_types.h>\n-#include <bits/stl_iterator_base_funcs.h>\n-#include <bits/allocator.h>\n-#include <bits/functexcept.h>\n-#include <tr1/type_traits>\t// For true_type and false_type\n-#include <tr1/hashtable_policy.h>\n+#include <tr1_impl/hashtable_policy.h>\n \n namespace std\n { \n-_GLIBCXX_BEGIN_NAMESPACE(_GLIBCXX_TR1)\n+_GLIBCXX_BEGIN_NAMESPACE_TR1\n \n   // Class template _Hashtable, class definition.\n   \n@@ -382,10 +372,10 @@ _GLIBCXX_BEGIN_NAMESPACE(_GLIBCXX_TR1)\n \t\t       typename _Hashtable::_Hash_code_type);\n \n       std::pair<iterator, bool>\n-      _M_insert(const value_type&, std::_GLIBCXX_TR1::true_type);\n+      _M_insert(const value_type&, std::_GLIBCXX_TR1 true_type);\n \n       iterator\n-      _M_insert(const value_type&, std::_GLIBCXX_TR1::false_type);\n+      _M_insert(const value_type&, std::_GLIBCXX_TR1 false_type);\n \n       void\n       _M_erase_node(_Node*, _Node**);\n@@ -394,7 +384,7 @@ _GLIBCXX_BEGIN_NAMESPACE(_GLIBCXX_TR1)\n       // Insert and erase\n       _Insert_Return_Type\n       insert(const value_type& __v) \n-      { return _M_insert(__v, std::_GLIBCXX_TR1::integral_constant<bool,\n+      { return _M_insert(__v, std::_GLIBCXX_TR1 integral_constant<bool,\n \t\t\t __unique_keys>()); }\n \n       iterator\n@@ -908,7 +898,7 @@ _GLIBCXX_BEGIN_NAMESPACE(_GLIBCXX_TR1)\n \t\t\t\t  __chc, __cit, __uk>::iterator, bool>\n     _Hashtable<_Key, _Value, _Allocator, _ExtractKey, _Equal,\n \t       _H1, _H2, _Hash, _RehashPolicy, __chc, __cit, __uk>::\n-    _M_insert(const value_type& __v, std::_GLIBCXX_TR1::true_type)\n+    _M_insert(const value_type& __v, std::_GLIBCXX_TR1 true_type)\n     {\n       const key_type& __k = this->_M_extract(__v);\n       typename _Hashtable::_Hash_code_type __code = this->_M_hash_code(__k);\n@@ -929,7 +919,7 @@ _GLIBCXX_BEGIN_NAMESPACE(_GLIBCXX_TR1)\n \t\t\t__chc, __cit, __uk>::iterator\n     _Hashtable<_Key, _Value, _Allocator, _ExtractKey, _Equal,\n \t       _H1, _H2, _Hash, _RehashPolicy, __chc, __cit, __uk>::\n-    _M_insert(const value_type& __v, std::_GLIBCXX_TR1::false_type)\n+    _M_insert(const value_type& __v, std::_GLIBCXX_TR1 false_type)\n     {\n       std::pair<bool, std::size_t> __do_rehash\n \t= _M_rehash_policy._M_need_rehash(_M_bucket_count,\n@@ -1196,8 +1186,5 @@ _GLIBCXX_BEGIN_NAMESPACE(_GLIBCXX_TR1)\n \t}\n     }\n \n-_GLIBCXX_END_NAMESPACE\n-} // namespace std::tr1\n-\n-#endif // _TR1_HASHTABLE\n-\n+_GLIBCXX_END_NAMESPACE_TR1\n+}", "previous_filename": "libstdc++-v3/include/tr1/hashtable"}, {"sha": "79740fad31ef5e50772d449b10869acee580ffe4", "filename": "libstdc++-v3/include/tr1_impl/hashtable_policy.h", "status": "renamed", "additions": 8, "deletions": 16, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e133ace8d907bf42754c86106fc3f04a9d9fe70f/libstdc%2B%2B-v3%2Finclude%2Ftr1_impl%2Fhashtable_policy.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e133ace8d907bf42754c86106fc3f04a9d9fe70f/libstdc%2B%2B-v3%2Finclude%2Ftr1_impl%2Fhashtable_policy.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Ftr1_impl%2Fhashtable_policy.h?ref=e133ace8d907bf42754c86106fc3f04a9d9fe70f", "patch": "@@ -1,6 +1,6 @@\n // Internal policy header for TR1 unordered_set and unordered_map -*- C++ -*-\n \n-// Copyright (C) 2005, 2006, 2007 Free Software Foundation, Inc.\n+// Copyright (C) 2007 Free Software Foundation, Inc.\n //\n // This file is part of the GNU ISO C++ Library.  This library is free\n // software; you can redistribute it and/or modify it under the\n@@ -27,21 +27,15 @@\n // invalidate any other reasons why the executable file might be covered by\n // the GNU General Public License.\n \n-/** @file tr1/hashtable_policy.h\n- *  This is a TR1 C++ Library header. \n+/** @file tr1_impl/hashtable_policy.h\n+ *  This is an internal header file, included by other library headers.\n+ *  You should not attempt to use it directly.\n  */\n \n-#ifndef _TR1_HASHTABLE_POLICY_H\n-#define _TR1_HASHTABLE_POLICY_H 1\n-\n-#include <algorithm> // lower_bound\n-#include <bits/stl_function.h> // equal_to, _Identity, _Select1st\n-#include <tr1/utility>\n-#include <ext/type_traits.h>\n-\n namespace std\n { \n-_GLIBCXX_BEGIN_NAMESPACE(_GLIBCXX_TR1)\n+_GLIBCXX_BEGIN_NAMESPACE_TR1\n+\n namespace __detail\n {\n   // Helper function: return distance(first, last) for forward\n@@ -897,8 +891,6 @@ namespace __detail\n       _H2          _M_h2;\n     };\n } // namespace __detail\n-_GLIBCXX_END_NAMESPACE\n-} // namespace std::tr1\n-\n-#endif // _TR1_HASHTABLE_POLICY_H\n \n+_GLIBCXX_END_NAMESPACE_TR1\n+}", "previous_filename": "libstdc++-v3/include/tr1/hashtable_policy.h"}, {"sha": "8d2b9eed911655c536424bb90106bfb9f2841280", "filename": "libstdc++-v3/include/tr1_impl/random", "status": "added", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e133ace8d907bf42754c86106fc3f04a9d9fe70f/libstdc%2B%2B-v3%2Finclude%2Ftr1_impl%2Frandom", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e133ace8d907bf42754c86106fc3f04a9d9fe70f/libstdc%2B%2B-v3%2Finclude%2Ftr1_impl%2Frandom", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Ftr1_impl%2Frandom?ref=e133ace8d907bf42754c86106fc3f04a9d9fe70f"}, {"sha": "e57d609ef5e83cf0ae39d815eb955a62537b40f4", "filename": "libstdc++-v3/include/tr1_impl/random.tcc", "status": "renamed", "additions": 19, "deletions": 18, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e133ace8d907bf42754c86106fc3f04a9d9fe70f/libstdc%2B%2B-v3%2Finclude%2Ftr1_impl%2Frandom.tcc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e133ace8d907bf42754c86106fc3f04a9d9fe70f/libstdc%2B%2B-v3%2Finclude%2Ftr1_impl%2Frandom.tcc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Ftr1_impl%2Frandom.tcc?ref=e133ace8d907bf42754c86106fc3f04a9d9fe70f", "previous_filename": "libstdc++-v3/include/tr1/random.tcc"}, {"sha": "de695ddf8c4f969398e07ecb011771d456e08b27", "filename": "libstdc++-v3/include/tr1_impl/regex", "status": "added", "additions": 2414, "deletions": 0, "changes": 2414, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e133ace8d907bf42754c86106fc3f04a9d9fe70f/libstdc%2B%2B-v3%2Finclude%2Ftr1_impl%2Fregex", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e133ace8d907bf42754c86106fc3f04a9d9fe70f/libstdc%2B%2B-v3%2Finclude%2Ftr1_impl%2Fregex", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Ftr1_impl%2Fregex?ref=e133ace8d907bf42754c86106fc3f04a9d9fe70f"}, {"sha": "52017d617c1e59852e0e26ff1dd4aa66ed0db6c8", "filename": "libstdc++-v3/include/tr1_impl/tuple", "status": "added", "additions": 430, "deletions": 0, "changes": 430, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e133ace8d907bf42754c86106fc3f04a9d9fe70f/libstdc%2B%2B-v3%2Finclude%2Ftr1_impl%2Ftuple", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e133ace8d907bf42754c86106fc3f04a9d9fe70f/libstdc%2B%2B-v3%2Finclude%2Ftr1_impl%2Ftuple", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Ftr1_impl%2Ftuple?ref=e133ace8d907bf42754c86106fc3f04a9d9fe70f"}, {"sha": "9fa77caeff8908619285f84d07a72cac56428cc4", "filename": "libstdc++-v3/include/tr1_impl/type_traits", "status": "added", "additions": 489, "deletions": 0, "changes": 489, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e133ace8d907bf42754c86106fc3f04a9d9fe70f/libstdc%2B%2B-v3%2Finclude%2Ftr1_impl%2Ftype_traits", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e133ace8d907bf42754c86106fc3f04a9d9fe70f/libstdc%2B%2B-v3%2Finclude%2Ftr1_impl%2Ftype_traits", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Ftr1_impl%2Ftype_traits?ref=e133ace8d907bf42754c86106fc3f04a9d9fe70f"}, {"sha": "1565df0ba881ad672e4b44c0e87e3bdd262f9190", "filename": "libstdc++-v3/include/tr1_impl/type_traitsfwd.h", "status": "renamed", "additions": 5, "deletions": 49, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e133ace8d907bf42754c86106fc3f04a9d9fe70f/libstdc%2B%2B-v3%2Finclude%2Ftr1_impl%2Ftype_traitsfwd.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e133ace8d907bf42754c86106fc3f04a9d9fe70f/libstdc%2B%2B-v3%2Finclude%2Ftr1_impl%2Ftype_traitsfwd.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Ftr1_impl%2Ftype_traitsfwd.h?ref=e133ace8d907bf42754c86106fc3f04a9d9fe70f", "previous_filename": "libstdc++-v3/include/tr1/type_traitsfwd.h"}, {"sha": "a3622960108a854c0548708ea51e841d6a871f13", "filename": "libstdc++-v3/include/tr1_impl/unordered_map", "status": "added", "additions": 229, "deletions": 0, "changes": 229, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e133ace8d907bf42754c86106fc3f04a9d9fe70f/libstdc%2B%2B-v3%2Finclude%2Ftr1_impl%2Funordered_map", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e133ace8d907bf42754c86106fc3f04a9d9fe70f/libstdc%2B%2B-v3%2Finclude%2Ftr1_impl%2Funordered_map", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Ftr1_impl%2Funordered_map?ref=e133ace8d907bf42754c86106fc3f04a9d9fe70f"}, {"sha": "2292d365979e2600dff67dc5649e5aa90ab438d2", "filename": "libstdc++-v3/include/tr1_impl/unordered_set", "status": "added", "additions": 227, "deletions": 0, "changes": 227, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e133ace8d907bf42754c86106fc3f04a9d9fe70f/libstdc%2B%2B-v3%2Finclude%2Ftr1_impl%2Funordered_set", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e133ace8d907bf42754c86106fc3f04a9d9fe70f/libstdc%2B%2B-v3%2Finclude%2Ftr1_impl%2Funordered_set", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Ftr1_impl%2Funordered_set?ref=e133ace8d907bf42754c86106fc3f04a9d9fe70f"}, {"sha": "42040c9103c8a4ba0cd4456fd8f9bac796a5a378", "filename": "libstdc++-v3/include/tr1_impl/utility", "status": "added", "additions": 98, "deletions": 0, "changes": 98, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e133ace8d907bf42754c86106fc3f04a9d9fe70f/libstdc%2B%2B-v3%2Finclude%2Ftr1_impl%2Futility", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e133ace8d907bf42754c86106fc3f04a9d9fe70f/libstdc%2B%2B-v3%2Finclude%2Ftr1_impl%2Futility", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Ftr1_impl%2Futility?ref=e133ace8d907bf42754c86106fc3f04a9d9fe70f"}, {"sha": "3a1ff3d8c565783ee4cba4cbde41909a58368c07", "filename": "libstdc++-v3/testsuite/20_util/has_nothrow_copy_constructor/value.cc", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e133ace8d907bf42754c86106fc3f04a9d9fe70f/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fhas_nothrow_copy_constructor%2Fvalue.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e133ace8d907bf42754c86106fc3f04a9d9fe70f/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fhas_nothrow_copy_constructor%2Fvalue.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fhas_nothrow_copy_constructor%2Fvalue.cc?ref=e133ace8d907bf42754c86106fc3f04a9d9fe70f"}, {"sha": "839b9ccac28ee1f720c2db95a0fcb5f944c251b1", "filename": "libstdc++-v3/testsuite/20_util/has_nothrow_default_constructor/value.cc", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e133ace8d907bf42754c86106fc3f04a9d9fe70f/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fhas_nothrow_default_constructor%2Fvalue.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e133ace8d907bf42754c86106fc3f04a9d9fe70f/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fhas_nothrow_default_constructor%2Fvalue.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fhas_nothrow_default_constructor%2Fvalue.cc?ref=e133ace8d907bf42754c86106fc3f04a9d9fe70f"}, {"sha": "98eb81a37f6a82862f8c66e8923b174cd4d979e4", "filename": "libstdc++-v3/testsuite/20_util/has_trivial_copy_constructor/value.cc", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e133ace8d907bf42754c86106fc3f04a9d9fe70f/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fhas_trivial_copy_constructor%2Fvalue.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e133ace8d907bf42754c86106fc3f04a9d9fe70f/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fhas_trivial_copy_constructor%2Fvalue.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fhas_trivial_copy_constructor%2Fvalue.cc?ref=e133ace8d907bf42754c86106fc3f04a9d9fe70f"}, {"sha": "dfb707bed936c855d4a9f975f5032ca1c0fa479b", "filename": "libstdc++-v3/testsuite/20_util/has_trivial_default_constructor/value.cc", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e133ace8d907bf42754c86106fc3f04a9d9fe70f/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fhas_trivial_default_constructor%2Fvalue.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e133ace8d907bf42754c86106fc3f04a9d9fe70f/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fhas_trivial_default_constructor%2Fvalue.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fhas_trivial_default_constructor%2Fvalue.cc?ref=e133ace8d907bf42754c86106fc3f04a9d9fe70f"}, {"sha": "37c5a0346d1f944e5478ce4c7cd46a1a14a404cf", "filename": "libstdc++-v3/testsuite/20_util/headers/type_traits/types_std_c++0x_neg.cc", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e133ace8d907bf42754c86106fc3f04a9d9fe70f/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fheaders%2Ftype_traits%2Ftypes_std_c%2B%2B0x_neg.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e133ace8d907bf42754c86106fc3f04a9d9fe70f/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fheaders%2Ftype_traits%2Ftypes_std_c%2B%2B0x_neg.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fheaders%2Ftype_traits%2Ftypes_std_c%2B%2B0x_neg.cc?ref=e133ace8d907bf42754c86106fc3f04a9d9fe70f"}, {"sha": "60d18d6a01867f30184fa1de2e32f492b435d871", "filename": "libstdc++-v3/testsuite/20_util/is_signed/requirements/explicit_instantiation.cc", "status": "added", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e133ace8d907bf42754c86106fc3f04a9d9fe70f/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fis_signed%2Frequirements%2Fexplicit_instantiation.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e133ace8d907bf42754c86106fc3f04a9d9fe70f/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fis_signed%2Frequirements%2Fexplicit_instantiation.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fis_signed%2Frequirements%2Fexplicit_instantiation.cc?ref=e133ace8d907bf42754c86106fc3f04a9d9fe70f"}, {"sha": "5c7e882a03250003c8d7a0ed50875b17545b5add", "filename": "libstdc++-v3/testsuite/20_util/is_signed/requirements/typedefs.cc", "status": "added", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e133ace8d907bf42754c86106fc3f04a9d9fe70f/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fis_signed%2Frequirements%2Ftypedefs.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e133ace8d907bf42754c86106fc3f04a9d9fe70f/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fis_signed%2Frequirements%2Ftypedefs.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fis_signed%2Frequirements%2Ftypedefs.cc?ref=e133ace8d907bf42754c86106fc3f04a9d9fe70f"}, {"sha": "fcf84e7ce0a8db658f01e7679e901180f5d3e828", "filename": "libstdc++-v3/testsuite/20_util/is_signed/value.cc", "status": "added", "additions": 61, "deletions": 0, "changes": 61, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e133ace8d907bf42754c86106fc3f04a9d9fe70f/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fis_signed%2Fvalue.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e133ace8d907bf42754c86106fc3f04a9d9fe70f/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fis_signed%2Fvalue.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fis_signed%2Fvalue.cc?ref=e133ace8d907bf42754c86106fc3f04a9d9fe70f"}, {"sha": "2cef36373446be3574f1f164921c68ba1049bdb3", "filename": "libstdc++-v3/testsuite/20_util/is_unsigned/requirements/explicit_instantiation.cc", "status": "added", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e133ace8d907bf42754c86106fc3f04a9d9fe70f/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fis_unsigned%2Frequirements%2Fexplicit_instantiation.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e133ace8d907bf42754c86106fc3f04a9d9fe70f/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fis_unsigned%2Frequirements%2Fexplicit_instantiation.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fis_unsigned%2Frequirements%2Fexplicit_instantiation.cc?ref=e133ace8d907bf42754c86106fc3f04a9d9fe70f"}, {"sha": "14f3846c269c4a722b9e98c1412bb581dad708a8", "filename": "libstdc++-v3/testsuite/20_util/is_unsigned/requirements/typedefs.cc", "status": "added", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e133ace8d907bf42754c86106fc3f04a9d9fe70f/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fis_unsigned%2Frequirements%2Ftypedefs.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e133ace8d907bf42754c86106fc3f04a9d9fe70f/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fis_unsigned%2Frequirements%2Ftypedefs.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fis_unsigned%2Frequirements%2Ftypedefs.cc?ref=e133ace8d907bf42754c86106fc3f04a9d9fe70f"}, {"sha": "d924163efe5863439ebf71227dc50fc23b6a5861", "filename": "libstdc++-v3/testsuite/20_util/is_unsigned/value.cc", "status": "added", "additions": 61, "deletions": 0, "changes": 61, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e133ace8d907bf42754c86106fc3f04a9d9fe70f/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fis_unsigned%2Fvalue.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e133ace8d907bf42754c86106fc3f04a9d9fe70f/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fis_unsigned%2Fvalue.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fis_unsigned%2Fvalue.cc?ref=e133ace8d907bf42754c86106fc3f04a9d9fe70f"}, {"sha": "044f979ab676546d2f7d3a7f994f5110863748ad", "filename": "libstdc++-v3/testsuite/20_util/make_signed/requirements/typedefs_neg.cc", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e133ace8d907bf42754c86106fc3f04a9d9fe70f/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fmake_signed%2Frequirements%2Ftypedefs_neg.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e133ace8d907bf42754c86106fc3f04a9d9fe70f/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fmake_signed%2Frequirements%2Ftypedefs_neg.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fmake_signed%2Frequirements%2Ftypedefs_neg.cc?ref=e133ace8d907bf42754c86106fc3f04a9d9fe70f"}, {"sha": "f12d941616a9ce4ed515488862a473812714b283", "filename": "libstdc++-v3/testsuite/20_util/make_unsigned/requirements/typedefs_neg.cc", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e133ace8d907bf42754c86106fc3f04a9d9fe70f/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fmake_unsigned%2Frequirements%2Ftypedefs_neg.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e133ace8d907bf42754c86106fc3f04a9d9fe70f/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fmake_unsigned%2Frequirements%2Ftypedefs_neg.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fmake_unsigned%2Frequirements%2Ftypedefs_neg.cc?ref=e133ace8d907bf42754c86106fc3f04a9d9fe70f"}, {"sha": "55afcc86fdb56128e726136328b4f90a39081538", "filename": "libstdc++-v3/testsuite/20_util/tuple/requirements/explicit_instantiation.cc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e133ace8d907bf42754c86106fc3f04a9d9fe70f/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Ftuple%2Frequirements%2Fexplicit_instantiation.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e133ace8d907bf42754c86106fc3f04a9d9fe70f/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Ftuple%2Frequirements%2Fexplicit_instantiation.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Ftuple%2Frequirements%2Fexplicit_instantiation.cc?ref=e133ace8d907bf42754c86106fc3f04a9d9fe70f"}, {"sha": "633b8fb6e01fffdeca2bb14a2dcdbb664728da70", "filename": "libstdc++-v3/testsuite/tr1/headers/all.cc", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e133ace8d907bf42754c86106fc3f04a9d9fe70f/libstdc%2B%2B-v3%2Ftestsuite%2Ftr1%2Fheaders%2Fall.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e133ace8d907bf42754c86106fc3f04a9d9fe70f/libstdc%2B%2B-v3%2Ftestsuite%2Ftr1%2Fheaders%2Fall.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Ftr1%2Fheaders%2Fall.cc?ref=e133ace8d907bf42754c86106fc3f04a9d9fe70f", "previous_filename": "libstdc++-v3/testsuite/tr1/headers.cc"}, {"sha": "0d74636a6efb035bf45ab6b9b020a029d6131e71", "filename": "libstdc++-v3/testsuite/tr1/headers/c++200x/using_namespace_std_tr1.cc", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e133ace8d907bf42754c86106fc3f04a9d9fe70f/libstdc%2B%2B-v3%2Ftestsuite%2Ftr1%2Fheaders%2Fc%2B%2B200x%2Fusing_namespace_std_tr1.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e133ace8d907bf42754c86106fc3f04a9d9fe70f/libstdc%2B%2B-v3%2Ftestsuite%2Ftr1%2Fheaders%2Fc%2B%2B200x%2Fusing_namespace_std_tr1.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Ftr1%2Fheaders%2Fc%2B%2B200x%2Fusing_namespace_std_tr1.cc?ref=e133ace8d907bf42754c86106fc3f04a9d9fe70f"}, {"sha": "21fc682b8f7ce169faa42ecf75e2beb266a129df", "filename": "libstdc++-v3/testsuite/tr1/headers/using_namespace_std_tr1.cc", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e133ace8d907bf42754c86106fc3f04a9d9fe70f/libstdc%2B%2B-v3%2Ftestsuite%2Ftr1%2Fheaders%2Fusing_namespace_std_tr1.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e133ace8d907bf42754c86106fc3f04a9d9fe70f/libstdc%2B%2B-v3%2Ftestsuite%2Ftr1%2Fheaders%2Fusing_namespace_std_tr1.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Ftr1%2Fheaders%2Fusing_namespace_std_tr1.cc?ref=e133ace8d907bf42754c86106fc3f04a9d9fe70f", "previous_filename": "libstdc++-v3/testsuite/tr1/using_namespace_std_tr1.cc"}]}