{"sha": "12c3874e62ea28f9df3f14e93bba5f624b1a15d9", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTJjMzg3NGU2MmVhMjhmOWRmM2YxNGU5M2JiYTVmNjI0YjFhMTVkOQ==", "commit": {"author": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2004-02-25T20:00:00Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2004-02-25T20:00:00Z"}, "message": "basic-block.h (make_eh_edge, [...]): Declare.\n\n\n\t* basic-block.h (make_eh_edge, break_superblocks): Declare.\n\t* cfgbuild.c (make_eh_edge):  Make global.\n\t* cfglayout.c (break_superblocks): Likewise; fix memory leak.\n\t* except.c (build_post_landing_pads, connect_post_landing_pads,\n\tdw2_build_landing_pads, sjlj_emit_function_enter,\n\tsjlj_emit_function_exit, sjlj_emit_dispatch_table,\n\tsjlj_build_landing_pads): Update CFG.\n\t(emit_to_new_bb_before): New function.\n\t(finish_eh_generation): Do not rebuild the CFG.\n\nFrom-SVN: r78448", "tree": {"sha": "8328d527b50b846c05df0b06c0dc56a80978890e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8328d527b50b846c05df0b06c0dc56a80978890e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/12c3874e62ea28f9df3f14e93bba5f624b1a15d9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/12c3874e62ea28f9df3f14e93bba5f624b1a15d9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/12c3874e62ea28f9df3f14e93bba5f624b1a15d9", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/12c3874e62ea28f9df3f14e93bba5f624b1a15d9/comments", "author": null, "committer": null, "parents": [{"sha": "b29610b3cfc461e3cd119c6892c31a0832d9daaf", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b29610b3cfc461e3cd119c6892c31a0832d9daaf", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b29610b3cfc461e3cd119c6892c31a0832d9daaf"}], "stats": {"total": 165, "additions": 140, "deletions": 25}, "files": [{"sha": "74073e2b369cc2dc9c9604f00c27b7ee9d8b2bca", "filename": "gcc/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/12c3874e62ea28f9df3f14e93bba5f624b1a15d9/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/12c3874e62ea28f9df3f14e93bba5f624b1a15d9/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=12c3874e62ea28f9df3f14e93bba5f624b1a15d9", "patch": "@@ -1,3 +1,15 @@\n+2004-02-25  Jan Hubicka  <jh@suse.cz>\n+\n+\t* basic-block.h (make_eh_edge, break_superblocks): Declare.\n+\t* cfgbuild.c (make_eh_edge):  Make global.\n+\t* cfglayout.c (break_superblocks): Likewise; fix memory leak.\n+\t* except.c (build_post_landing_pads, connect_post_landing_pads,\n+\tdw2_build_landing_pads, sjlj_emit_function_enter,\n+\tsjlj_emit_function_exit, sjlj_emit_dispatch_table, \n+\tsjlj_build_landing_pads): Update CFG.\n+\t(emit_to_new_bb_before): New function.\n+\t(finish_eh_generation): Do not rebuild the CFG.\n+\n 2004-02-25  John David Anglin  <dave.anglin@nrc-cnrc.gc.ca>\n \n \t* config.gcc (hppa*-*-*, parisc*-*-*): Add MASK_BIG_SWITCH to all"}, {"sha": "05f41c01948873fff6fc8b1e0c4fcf5c07cfa3cc", "filename": "gcc/basic-block.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/12c3874e62ea28f9df3f14e93bba5f624b1a15d9/gcc%2Fbasic-block.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/12c3874e62ea28f9df3f14e93bba5f624b1a15d9/gcc%2Fbasic-block.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbasic-block.h?ref=12c3874e62ea28f9df3f14e93bba5f624b1a15d9", "patch": "@@ -566,6 +566,7 @@ extern bool purge_all_dead_edges (int);\n extern bool purge_dead_edges (basic_block);\n extern void find_sub_basic_blocks (basic_block);\n extern void find_many_sub_basic_blocks (sbitmap);\n+extern void make_eh_edge (sbitmap *, basic_block, rtx);\n extern bool can_fallthru (basic_block, basic_block);\n extern void flow_nodes_print (const char *, const sbitmap, FILE *);\n extern void flow_edge_list_print (const char *, const edge *, int, FILE *);\n@@ -649,6 +650,7 @@ extern void verify_dominators (enum cdi_direction);\n extern basic_block first_dom_son (enum cdi_direction, basic_block);\n extern basic_block next_dom_son (enum cdi_direction, basic_block);\n extern bool try_redirect_by_replacing_jump (edge, basic_block, bool);\n+extern void break_superblocks (void);\n \n #include \"cfghooks.h\"\n "}, {"sha": "00c53a46ce87a25bc4e8924a3cba5a594455921b", "filename": "gcc/cfgbuild.c", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/12c3874e62ea28f9df3f14e93bba5f624b1a15d9/gcc%2Fcfgbuild.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/12c3874e62ea28f9df3f14e93bba5f624b1a15d9/gcc%2Fcfgbuild.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgbuild.c?ref=12c3874e62ea28f9df3f14e93bba5f624b1a15d9", "patch": "@@ -53,7 +53,6 @@ static void find_basic_blocks_1 (rtx);\n static rtx find_label_refs (rtx, rtx);\n static void make_edges (rtx, basic_block, basic_block, int);\n static void make_label_edge (sbitmap *, basic_block, rtx, int);\n-static void make_eh_edge (sbitmap *, basic_block, rtx);\n static void find_bb_boundaries (basic_block);\n static void compute_outgoing_frequencies (basic_block);\n \f\n@@ -240,7 +239,7 @@ make_label_edge (sbitmap *edge_cache, basic_block src, rtx label, int flags)\n \n /* Create the edges generated by INSN in REGION.  */\n \n-static void\n+void\n make_eh_edge (sbitmap *edge_cache, basic_block src, rtx insn)\n {\n   int is_call = GET_CODE (insn) == CALL_INSN ? EDGE_ABNORMAL_CALL : 0;"}, {"sha": "25349658355d4218e5e94cabb87ed81615689944", "filename": "gcc/cfglayout.c", "status": "modified", "additions": 9, "deletions": 11, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/12c3874e62ea28f9df3f14e93bba5f624b1a15d9/gcc%2Fcfglayout.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/12c3874e62ea28f9df3f14e93bba5f624b1a15d9/gcc%2Fcfglayout.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfglayout.c?ref=12c3874e62ea28f9df3f14e93bba5f624b1a15d9", "patch": "@@ -56,7 +56,6 @@ static void change_scope (rtx, tree, tree);\n void verify_insn_chain (void);\n static void fixup_fallthru_exit_predecessor (void);\n static rtx duplicate_insn_chain (rtx, rtx);\n-static void break_superblocks (void);\n static tree insn_scope (rtx);\n \f\n rtx\n@@ -1144,23 +1143,22 @@ cfg_layout_initialize (void)\n }\n \n /* Splits superblocks.  */\n-static void\n+void\n break_superblocks (void)\n {\n   sbitmap superblocks;\n-  int i, need;\n+  bool need = false;\n+  basic_block bb;\n \n-  superblocks = sbitmap_alloc (n_basic_blocks);\n+  superblocks = sbitmap_alloc (last_basic_block);\n   sbitmap_zero (superblocks);\n \n-  need = 0;\n-\n-  for (i = 0; i < n_basic_blocks; i++)\n-    if (BASIC_BLOCK(i)->flags & BB_SUPERBLOCK)\n+  FOR_EACH_BB (bb)\n+    if (bb->flags & BB_SUPERBLOCK)\n       {\n-\tBASIC_BLOCK(i)->flags &= ~BB_SUPERBLOCK;\n-\tSET_BIT (superblocks, i);\n-\tneed = 1;\n+\tbb->flags &= ~BB_SUPERBLOCK;\n+\tSET_BIT (superblocks, bb->index);\n+\tneed = true;\n       }\n \n   if (need)"}, {"sha": "70eb3b17d7f7f5fb1717a854c10b5b57161d3dd1", "filename": "gcc/except.c", "status": "modified", "additions": 116, "deletions": 12, "changes": 128, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/12c3874e62ea28f9df3f14e93bba5f624b1a15d9/gcc%2Fexcept.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/12c3874e62ea28f9df3f14e93bba5f624b1a15d9/gcc%2Fexcept.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexcept.c?ref=12c3874e62ea28f9df3f14e93bba5f624b1a15d9", "patch": "@@ -1629,6 +1629,24 @@ assign_filter_values (void)\n   htab_delete (ehspec);\n }\n \n+/* Emit SEQ into basic block just before INSN (that is assumed to be\n+   first instruction of some existing BB and return the newly\n+   produced block.  */\n+static basic_block\n+emit_to_new_bb_before (rtx seq, rtx insn)\n+{\n+  rtx last;\n+  basic_block bb;\n+\n+  last = emit_insn_before (seq, insn);\n+  if (GET_CODE (last) == BARRIER)\n+    last = PREV_INSN (last);\n+  bb = create_basic_block (seq, last, BLOCK_FOR_INSN (insn)->prev_bb);\n+  update_bb_for_insn (bb);\n+  bb->flags |= BB_SUPERBLOCK;\n+  return bb;\n+}\n+\n /* Generate the code to actually handle exceptions, which will follow the\n    landing pads.  */\n \n@@ -1702,7 +1720,8 @@ build_post_landing_pads (void)\n \t  seq = get_insns ();\n \t  end_sequence ();\n \n-\t  emit_insn_before (seq, region->u.try.catch->label);\n+\t  emit_to_new_bb_before (seq, region->u.try.catch->label);\n+\n \t  break;\n \n \tcase ERT_ALLOWED_EXCEPTIONS:\n@@ -1726,7 +1745,7 @@ build_post_landing_pads (void)\n \t  seq = get_insns ();\n \t  end_sequence ();\n \n-\t  emit_insn_before (seq, region->label);\n+\t  emit_to_new_bb_before (seq, region->label);\n \t  break;\n \n \tcase ERT_CLEANUP:\n@@ -1758,6 +1777,7 @@ connect_post_landing_pads (void)\n       struct eh_region *region = cfun->eh->region_array[i];\n       struct eh_region *outer;\n       rtx seq;\n+      rtx barrier;\n \n       /* Mind we don't process a region more than once.  */\n       if (!region || region->region_number != i)\n@@ -1776,14 +1796,30 @@ connect_post_landing_pads (void)\n       start_sequence ();\n \n       if (outer)\n-\temit_jump (outer->post_landing_pad);\n+\t{\n+\t  edge e;\n+\t  basic_block src, dest;\n+\n+\t  emit_jump (outer->post_landing_pad);\n+\t  src = BLOCK_FOR_INSN (region->resume);\n+\t  dest = BLOCK_FOR_INSN (outer->post_landing_pad);\n+\t  while (src->succ)\n+\t    remove_edge (src->succ);\n+\t  e = make_edge (src, dest, 0);\n+\t  e->probability = REG_BR_PROB_BASE;\n+\t  e->count = src->count;\n+\t}\n       else\n \temit_library_call (unwind_resume_libfunc, LCT_THROW,\n \t\t\t   VOIDmode, 1, cfun->eh->exc_ptr, ptr_mode);\n \n       seq = get_insns ();\n       end_sequence ();\n-      emit_insn_before (seq, region->resume);\n+      barrier = emit_insn_before (seq, region->resume);\n+      /* Avoid duplicate barrier.  */\n+      if (GET_CODE (barrier) != BARRIER)\n+\tabort ();\n+      delete_insn (barrier);\n       delete_insn (region->resume);\n     }\n }\n@@ -1799,7 +1835,9 @@ dw2_build_landing_pads (void)\n     {\n       struct eh_region *region = cfun->eh->region_array[i];\n       rtx seq;\n+      basic_block bb;\n       bool clobbers_hard_regs = false;\n+      edge e;\n \n       /* Mind we don't process a region more than once.  */\n       if (!region || region->region_number != i)\n@@ -1859,7 +1897,10 @@ dw2_build_landing_pads (void)\n       seq = get_insns ();\n       end_sequence ();\n \n-      emit_insn_before (seq, region->post_landing_pad);\n+      bb = emit_to_new_bb_before (seq, region->post_landing_pad);\n+      e = make_edge (bb, bb->next_bb, EDGE_FALLTHRU);\n+      e->count = bb->count;\n+      e->probability = REG_BR_PROB_BASE;\n     }\n }\n \n@@ -2107,9 +2148,21 @@ sjlj_emit_function_enter (rtx dispatch_label)\n \n   for (fn_begin = get_insns (); ; fn_begin = NEXT_INSN (fn_begin))\n     if (GET_CODE (fn_begin) == NOTE\n-\t&& NOTE_LINE_NUMBER (fn_begin) == NOTE_INSN_FUNCTION_BEG)\n+\t&& (NOTE_LINE_NUMBER (fn_begin) == NOTE_INSN_FUNCTION_BEG\n+\t    || NOTE_LINE_NUMBER (fn_begin) == NOTE_INSN_BASIC_BLOCK))\n       break;\n-  emit_insn_after (seq, fn_begin);\n+  if (NOTE_LINE_NUMBER (fn_begin) == NOTE_INSN_FUNCTION_BEG)\n+    insert_insn_on_edge (seq, ENTRY_BLOCK_PTR->succ);\n+  else\n+    {\n+      rtx last = BB_END (ENTRY_BLOCK_PTR->succ->dest);\n+      for (; ; fn_begin = NEXT_INSN (fn_begin))\n+\tif ((GET_CODE (fn_begin) == NOTE\n+\t     && NOTE_LINE_NUMBER (fn_begin) == NOTE_INSN_FUNCTION_BEG)\n+\t    || fn_begin == last)\n+\t  break;\n+      emit_insn_after (seq, fn_begin);\n+    }\n }\n \n /* Call back from expand_function_end to know where we should put\n@@ -2125,6 +2178,7 @@ static void\n sjlj_emit_function_exit (void)\n {\n   rtx seq;\n+  edge e;\n \n   start_sequence ();\n \n@@ -2138,14 +2192,41 @@ sjlj_emit_function_exit (void)\n      post-dominates all can_throw_internal instructions.  This is\n      the last possible moment.  */\n \n-  emit_insn_after (seq, cfun->eh->sjlj_exit_after);\n+  for (e = EXIT_BLOCK_PTR->pred; e; e = e->pred_next)\n+    if (e->flags & EDGE_FALLTHRU)\n+      break;\n+  if (e)\n+    {\n+      rtx insn;\n+\n+      /* Figure out whether the place we are supposed to insert libcall\n+         is inside the last basic block or after it.  In the other case\n+         we need to emit to edge.  */\n+      if (e->src->next_bb != EXIT_BLOCK_PTR)\n+\tabort ();\n+      for (insn = NEXT_INSN (BB_END (e->src)); insn; insn = NEXT_INSN (insn))\n+\tif (insn == cfun->eh->sjlj_exit_after)\n+\t  break;\n+      if (insn)\n+\tinsert_insn_on_edge (seq, e);\n+      else\n+\t{\n+\t  insn = cfun->eh->sjlj_exit_after;\n+\t  if (GET_CODE (insn) == CODE_LABEL)\n+\t    insn = NEXT_INSN (insn);\n+\t  emit_insn_after (seq, insn);\n+\t}\n+    }\n }\n \n static void\n sjlj_emit_dispatch_table (rtx dispatch_label, struct sjlj_lp_info *lp_info)\n {\n   int i, first_reachable;\n   rtx mem, dispatch, seq, fc;\n+  rtx before;\n+  basic_block bb;\n+  edge e;\n \n   fc = cfun->eh->sjlj_fc;\n \n@@ -2200,8 +2281,12 @@ sjlj_emit_dispatch_table (rtx dispatch_label, struct sjlj_lp_info *lp_info)\n   seq = get_insns ();\n   end_sequence ();\n \n-  emit_insn_before (seq, (cfun->eh->region_array[first_reachable]\n-\t\t\t  ->post_landing_pad));\n+  before = cfun->eh->region_array[first_reachable]->post_landing_pad;\n+\n+  bb = emit_to_new_bb_before (seq, before);\n+  e = make_edge (bb, bb->next_bb, EDGE_FALLTHRU);\n+  e->count = bb->count;\n+  e->probability = REG_BR_PROB_BASE;\n }\n \n static void\n@@ -2235,6 +2320,8 @@ sjlj_build_landing_pads (void)\n void\n finish_eh_generation (void)\n {\n+  basic_block bb;\n+\n   /* Nothing to do if no regions created.  */\n   if (cfun->eh->region_tree == NULL)\n     return;\n@@ -2269,8 +2356,25 @@ finish_eh_generation (void)\n \n   /* We've totally changed the CFG.  Start over.  */\n   find_exception_handler_labels ();\n-  rebuild_jump_labels (get_insns ());\n-  find_basic_blocks (get_insns (), max_reg_num (), 0);\n+  break_superblocks ();\n+  if (USING_SJLJ_EXCEPTIONS)\n+    commit_edge_insertions ();\n+  FOR_EACH_BB (bb)\n+    {\n+      edge e, next;\n+      bool eh = false;\n+      for (e = bb->succ; e; e = next)\n+\t{\n+\t  next = e->succ_next;\n+\t  if (e->flags & EDGE_EH)\n+\t    {\n+\t      remove_edge (e);\n+\t      eh = true;\n+\t    }\n+\t}\n+      if (eh)\n+\tmake_eh_edge (NULL, bb, BB_END (bb));\n+    }\n   cleanup_cfg (CLEANUP_PRE_LOOP | CLEANUP_NO_INSN_DEL);\n }\n \f"}]}