{"sha": "56fe3ca30e1343e4f232ca539726506440e23dd3", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTZmZTNjYTMwZTEzNDNlNGYyMzJjYTUzOTcyNjUwNjQ0MGUyM2RkMw==", "commit": {"author": {"name": "Richard Sandiford", "email": "richard.sandiford@arm.com", "date": "2020-04-29T09:56:49Z"}, "committer": {"name": "Richard Sandiford", "email": "richard.sandiford@arm.com", "date": "2020-04-29T09:56:49Z"}, "message": "aarch64: Fix parameter passing for [[no_unique_address]]\n\nThis patch makes the ABI code ignore zero-sized [[no_unique_address]]\nfields when deciding whether something is a HFA or HVA.\n\nAs things stood, we'd get two sets of -Wpsabi warnings, one when\ntrying to decide whether something was an SVE function, and another\nwhen actually processing the function definition or function call.\nThe patch therefore makes aapcs_vfp_sub_candidate honour the\nCUMULATIVE_ARGS \"silent_p\" flag where applicable.\n\nThis doesn't stop all duplicate warnings for parameters, and I suspect\nwe'll get duplicate warnings for return values too, but it should be\nbetter than nothing.\n\n2020-04-29  Richard Sandiford  <richard.sandiford@arm.com>\n\ngcc/\n\t* config/aarch64/aarch64.c (aarch64_function_arg_alignment): Add a\n\tcomment explaining why we consider even zero-sized fields.\n\t(WARN_PSABI_EMPTY_CXX17_BASE): New constant.\n\t(WARN_PSABI_NO_UNIQUE_ADDRESS): Likewise.\n\t(aapcs_vfp_sub_candidate): Replace the boolean pointer parameter\n\tavoid_cxx17_empty_base with a pointer to a bitmask.  Ignore fields\n\twhose DECL_FIELD_ABI_IGNORED bit is set when determining whether\n\tsomething actually is a HFA or HVA.  Record whether we see a\n\t[[no_unique_address]] field that previous GCCs would not have\n\tignored in this way.\n\t(aarch64_vfp_is_call_or_return_candidate): Add a parameter to say\n\twhether diagnostics should be suppressed.  Update the calls to\n\taapcs_vfp_sub_candidate and report a -Wpsabi warning for the\n\t[[no_unique_address]] case.\n\t(aarch64_return_in_msb): Update call accordingly, never silencing\n\tdiagnostics.\n\t(aarch64_function_value): Likewise.\n\t(aarch64_return_in_memory_1): Likewise.\n\t(aarch64_init_cumulative_args): Likewise.\n\t(aarch64_gimplify_va_arg_expr): Likewise.\n\t(aarch64_pass_by_reference_1): Take a CUMULATIVE_ARGS pointer and\n\tuse it to decide whether arch64_vfp_is_call_or_return_candidate\n\tshould be silent.\n\t(aarch64_pass_by_reference): Update calls accordingly.\n\t(aarch64_vfp_is_call_candidate): Use the CUMULATIVE_ARGS argument\n\tto decide whether arch64_vfp_is_call_or_return_candidate should be\n\tsilent.\n\ngcc/testsuite/\n\t* g++.target/aarch64/no_unique_address_1.C: New test.\n\t* g++.target/aarch64/no_unique_address_2.C: Likewise.", "tree": {"sha": "184ab4e7a72398bedfdd95d195203eac9e952ff3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/184ab4e7a72398bedfdd95d195203eac9e952ff3"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/56fe3ca30e1343e4f232ca539726506440e23dd3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/56fe3ca30e1343e4f232ca539726506440e23dd3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/56fe3ca30e1343e4f232ca539726506440e23dd3", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/56fe3ca30e1343e4f232ca539726506440e23dd3/comments", "author": {"login": "rsandifo-arm", "id": 28043039, "node_id": "MDQ6VXNlcjI4MDQzMDM5", "avatar_url": "https://avatars.githubusercontent.com/u/28043039?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rsandifo-arm", "html_url": "https://github.com/rsandifo-arm", "followers_url": "https://api.github.com/users/rsandifo-arm/followers", "following_url": "https://api.github.com/users/rsandifo-arm/following{/other_user}", "gists_url": "https://api.github.com/users/rsandifo-arm/gists{/gist_id}", "starred_url": "https://api.github.com/users/rsandifo-arm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rsandifo-arm/subscriptions", "organizations_url": "https://api.github.com/users/rsandifo-arm/orgs", "repos_url": "https://api.github.com/users/rsandifo-arm/repos", "events_url": "https://api.github.com/users/rsandifo-arm/events{/privacy}", "received_events_url": "https://api.github.com/users/rsandifo-arm/received_events", "type": "User", "site_admin": false}, "committer": {"login": "rsandifo-arm", "id": 28043039, "node_id": "MDQ6VXNlcjI4MDQzMDM5", "avatar_url": "https://avatars.githubusercontent.com/u/28043039?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rsandifo-arm", "html_url": "https://github.com/rsandifo-arm", "followers_url": "https://api.github.com/users/rsandifo-arm/followers", "following_url": "https://api.github.com/users/rsandifo-arm/following{/other_user}", "gists_url": "https://api.github.com/users/rsandifo-arm/gists{/gist_id}", "starred_url": "https://api.github.com/users/rsandifo-arm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rsandifo-arm/subscriptions", "organizations_url": "https://api.github.com/users/rsandifo-arm/orgs", "repos_url": "https://api.github.com/users/rsandifo-arm/repos", "events_url": "https://api.github.com/users/rsandifo-arm/events{/privacy}", "received_events_url": "https://api.github.com/users/rsandifo-arm/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b5620fadc53be38da9f4b8107348759afb2c29df", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b5620fadc53be38da9f4b8107348759afb2c29df", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b5620fadc53be38da9f4b8107348759afb2c29df"}], "stats": {"total": 606, "additions": 553, "deletions": 53}, "files": [{"sha": "3a352f8bbd31cbe2faeb242d50967e7904dc7a5c", "filename": "gcc/ChangeLog", "status": "modified", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/56fe3ca30e1343e4f232ca539726506440e23dd3/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/56fe3ca30e1343e4f232ca539726506440e23dd3/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=56fe3ca30e1343e4f232ca539726506440e23dd3", "patch": "@@ -1,3 +1,33 @@\n+2020-04-29  Richard Sandiford  <richard.sandiford@arm.com>\n+\n+\t* config/aarch64/aarch64.c (aarch64_function_arg_alignment): Add a\n+\tcomment explaining why we consider even zero-sized fields.\n+\t(WARN_PSABI_EMPTY_CXX17_BASE): New constant.\n+\t(WARN_PSABI_NO_UNIQUE_ADDRESS): Likewise.\n+\t(aapcs_vfp_sub_candidate): Replace the boolean pointer parameter\n+\tavoid_cxx17_empty_base with a pointer to a bitmask.  Ignore fields\n+\twhose DECL_FIELD_ABI_IGNORED bit is set when determining whether\n+\tsomething actually is a HFA or HVA.  Record whether we see a\n+\t[[no_unique_address]] field that previous GCCs would not have\n+\tignored in this way.\n+\t(aarch64_vfp_is_call_or_return_candidate): Add a parameter to say\n+\twhether diagnostics should be suppressed.  Update the calls to\n+\taapcs_vfp_sub_candidate and report a -Wpsabi warning for the\n+\t[[no_unique_address]] case.\n+\t(aarch64_return_in_msb): Update call accordingly, never silencing\n+\tdiagnostics.\n+\t(aarch64_function_value): Likewise.\n+\t(aarch64_return_in_memory_1): Likewise.\n+\t(aarch64_init_cumulative_args): Likewise.\n+\t(aarch64_gimplify_va_arg_expr): Likewise.\n+\t(aarch64_pass_by_reference_1): Take a CUMULATIVE_ARGS pointer and\n+\tuse it to decide whether arch64_vfp_is_call_or_return_candidate\n+\tshould be silent.\n+\t(aarch64_pass_by_reference): Update calls accordingly.\n+\t(aarch64_vfp_is_call_candidate): Use the CUMULATIVE_ARGS argument\n+\tto decide whether arch64_vfp_is_call_or_return_candidate should be\n+\tsilent.\n+\n 2020-04-29  Haijian Zhang  <z.zhanghaijian@huawei.com>\n \n \tPR target/94820"}, {"sha": "e996fd12042092936045f23e15e7adb75a60e9ac", "filename": "gcc/config/aarch64/aarch64.c", "status": "modified", "additions": 106, "deletions": 53, "changes": 159, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/56fe3ca30e1343e4f232ca539726506440e23dd3/gcc%2Fconfig%2Faarch64%2Faarch64.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/56fe3ca30e1343e4f232ca539726506440e23dd3/gcc%2Fconfig%2Faarch64%2Faarch64.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Faarch64.c?ref=56fe3ca30e1343e4f232ca539726506440e23dd3", "patch": "@@ -286,7 +286,7 @@ static bool aarch64_return_in_memory_1 (const_tree);\n static bool aarch64_vfp_is_call_or_return_candidate (machine_mode,\n \t\t\t\t\t\t     const_tree,\n \t\t\t\t\t\t     machine_mode *, int *,\n-\t\t\t\t\t\t     bool *);\n+\t\t\t\t\t\t     bool *, bool);\n static void aarch64_elf_asm_constructor (rtx, int) ATTRIBUTE_UNUSED;\n static void aarch64_elf_asm_destructor (rtx, int) ATTRIBUTE_UNUSED;\n static void aarch64_override_options_after_change (void);\n@@ -5369,7 +5369,8 @@ aarch64_function_ok_for_sibcall (tree, tree exp)\n    passed in SVE registers.  */\n \n static bool\n-aarch64_pass_by_reference_1 (const function_arg_info &arg)\n+aarch64_pass_by_reference_1 (CUMULATIVE_ARGS *pcum,\n+\t\t\t     const function_arg_info &arg)\n {\n   HOST_WIDE_INT size;\n   machine_mode dummymode;\n@@ -5393,8 +5394,8 @@ aarch64_pass_by_reference_1 (const function_arg_info &arg)\n \n   /* Can this be a candidate to be passed in fp/simd register(s)?  */\n   if (aarch64_vfp_is_call_or_return_candidate (arg.mode, arg.type,\n-\t\t\t\t\t       &dummymode, &nregs,\n-\t\t\t\t\t       NULL))\n+\t\t\t\t\t       &dummymode, &nregs, NULL,\n+\t\t\t\t\t       !pcum || pcum->silent_p))\n     return false;\n \n   /* Arguments which are variable sized or larger than 2 registers are\n@@ -5412,7 +5413,7 @@ aarch64_pass_by_reference (cumulative_args_t pcum_v,\n   CUMULATIVE_ARGS *pcum = get_cumulative_args (pcum_v);\n \n   if (!arg.type)\n-    return aarch64_pass_by_reference_1 (arg);\n+    return aarch64_pass_by_reference_1 (pcum, arg);\n \n   pure_scalable_type_info pst_info;\n   switch (pst_info.analyze (arg.type))\n@@ -5431,12 +5432,12 @@ aarch64_pass_by_reference (cumulative_args_t pcum_v,\n \t      || pcum->aapcs_nprn + pst_info.num_pr () > NUM_PR_ARG_REGS);\n \n     case pure_scalable_type_info::DOESNT_MATTER:\n-      gcc_assert (aarch64_pass_by_reference_1 (arg));\n+      gcc_assert (aarch64_pass_by_reference_1 (pcum, arg));\n       return true;\n \n     case pure_scalable_type_info::NO_ABI_IDENTITY:\n     case pure_scalable_type_info::ISNT_PST:\n-      return aarch64_pass_by_reference_1 (arg);\n+      return aarch64_pass_by_reference_1 (pcum, arg);\n     }\n   gcc_unreachable ();\n }\n@@ -5464,7 +5465,8 @@ aarch64_return_in_msb (const_tree valtype)\n      is always passed/returned in the least significant bits of fp/simd\n      register(s).  */\n   if (aarch64_vfp_is_call_or_return_candidate (TYPE_MODE (valtype), valtype,\n-\t\t\t\t\t       &dummy_mode, &dummy_int, NULL))\n+\t\t\t\t\t       &dummy_mode, &dummy_int, NULL,\n+\t\t\t\t\t       false))\n     return false;\n \n   /* Likewise pure scalable types for SVE vector and predicate registers.  */\n@@ -5511,8 +5513,8 @@ aarch64_function_value (const_tree type, const_tree func,\n \n   int count;\n   machine_mode ag_mode;\n-  if (aarch64_vfp_is_call_or_return_candidate (mode, type,\n-\t\t\t\t\t       &ag_mode, &count, NULL))\n+  if (aarch64_vfp_is_call_or_return_candidate (mode, type, &ag_mode, &count,\n+\t\t\t\t\t       NULL, false))\n     {\n       gcc_assert (!sve_p);\n       if (!aarch64_composite_type_p (type, mode))\n@@ -5599,11 +5601,8 @@ aarch64_return_in_memory_1 (const_tree type)\n     /* Simple scalar types always returned in registers.  */\n     return false;\n \n-  if (aarch64_vfp_is_call_or_return_candidate (TYPE_MODE (type),\n-\t\t\t\t\t       type,\n-\t\t\t\t\t       &ag_mode,\n-\t\t\t\t\t       &count,\n-\t\t\t\t\t       NULL))\n+  if (aarch64_vfp_is_call_or_return_candidate (TYPE_MODE (type), type,\n+\t\t\t\t\t       &ag_mode, &count, NULL, false))\n     return false;\n \n   /* Types larger than 2 registers returned in memory.  */\n@@ -5646,11 +5645,9 @@ aarch64_vfp_is_call_candidate (cumulative_args_t pcum_v, machine_mode mode,\n \t\t\t       const_tree type, int *nregs)\n {\n   CUMULATIVE_ARGS *pcum = get_cumulative_args (pcum_v);\n-  return aarch64_vfp_is_call_or_return_candidate (mode,\n-\t\t\t\t\t\t  type,\n+  return aarch64_vfp_is_call_or_return_candidate (mode, type,\n \t\t\t\t\t\t  &pcum->aapcs_vfp_rmode,\n-\t\t\t\t\t\t  nregs,\n-\t\t\t\t\t\t  NULL);\n+\t\t\t\t\t\t  nregs, NULL, pcum->silent_p);\n }\n \n /* Given MODE and TYPE of a function argument, return the alignment in\n@@ -5684,6 +5681,19 @@ aarch64_function_arg_alignment (machine_mode mode, const_tree type,\n   for (tree field = TYPE_FIELDS (type); field; field = DECL_CHAIN (field))\n     if (TREE_CODE (field) == FIELD_DECL)\n       {\n+\t/* Note that we explicitly consider zero-sized fields here,\n+\t   even though they don't map to AAPCS64 machine types.\n+\t   For example, in:\n+\n+\t       struct __attribute__((aligned(8))) empty {};\n+\n+\t       struct s {\n+\t\t [[no_unique_address]] empty e;\n+\t\t int x;\n+\t       };\n+\n+\t   \"s\" contains only one Fundamental Data Type (the int field)\n+\t   but gains 8-byte alignment and size thanks to \"e\".  */\n \talignment = std::max (alignment, DECL_ALIGN (field));\n \tif (DECL_BIT_FIELD_TYPE (field))\n \t  bitfield_alignment\n@@ -5976,7 +5986,7 @@ aarch64_init_cumulative_args (CUMULATIVE_ARGS *pcum,\n       machine_mode mode ATTRIBUTE_UNUSED; /* To pass pointer as argument.  */\n       int nregs ATTRIBUTE_UNUSED; /* Likewise.  */\n       if (aarch64_vfp_is_call_or_return_candidate (TYPE_MODE (type), type,\n-\t\t\t\t\t\t   &mode, &nregs, NULL))\n+\t\t\t\t\t\t   &mode, &nregs, NULL, false))\n \taarch64_err_no_fpadvsimd (TYPE_MODE (type));\n     }\n \n@@ -16152,11 +16162,8 @@ aarch64_gimplify_va_arg_expr (tree valist, tree type, gimple_seq *pre_p,\n \n   dw_align = false;\n   adjust = 0;\n-  if (aarch64_vfp_is_call_or_return_candidate (mode,\n-\t\t\t\t\t       type,\n-\t\t\t\t\t       &ag_mode,\n-\t\t\t\t\t       &nregs,\n-\t\t\t\t\t       &is_ha))\n+  if (aarch64_vfp_is_call_or_return_candidate (mode, type, &ag_mode, &nregs,\n+\t\t\t\t\t       &is_ha, false))\n     {\n       /* No frontends can create types with variable-sized modes, so we\n \t shouldn't be asked to pass or return them.  */\n@@ -16521,23 +16528,42 @@ aarch64_member_type_forces_blk (const_tree field_or_array, machine_mode mode)\n   return default_member_type_forces_blk (field_or_array, mode);\n }\n \n+/* Bitmasks that indicate whether earlier versions of GCC would have\n+   taken a different path through the ABI logic.  This should result in\n+   a -Wpsabi warning if the earlier path led to a different ABI decision.\n+\n+   WARN_PSABI_EMPTY_CXX17_BASE\n+      Indicates that the type includes an artificial empty C++17 base field\n+      that, prior to GCC 10.1, would prevent the type from being treated as\n+      a HFA or HVA.  See PR94383 for details.\n+\n+   WARN_PSABI_NO_UNIQUE_ADDRESS\n+      Indicates that the type includes an empty [[no_unique_address]] field\n+      that, prior to GCC 10.1, would prevent the type from being treated as\n+      a HFA or HVA.  */\n+const unsigned int WARN_PSABI_EMPTY_CXX17_BASE = 1U << 0;\n+const unsigned int WARN_PSABI_NO_UNIQUE_ADDRESS = 1U << 1;\n+\n /* Walk down the type tree of TYPE counting consecutive base elements.\n    If *MODEP is VOIDmode, then set it to the first valid floating point\n    type.  If a non-floating point type is found, or if a floating point\n    type that doesn't match a non-VOIDmode *MODEP is found, then return -1,\n    otherwise return the count in the sub-tree.\n \n-   The AVOID_CXX17_EMPTY_BASE argument is to allow the caller to check whether\n-   this function has changed its behavior after the fix for PR94384 -- this fix\n-   is to avoid artificial fields in empty base classes.\n-   When called with this argument as a NULL pointer this function does not\n-   avoid the artificial fields -- this is useful to check whether the function\n-   returns something different after the fix.\n-   When called pointing at a value, this function avoids such artificial fields\n-   and sets the value to TRUE when one of these fields has been set.  */\n+   The WARN_PSABI_FLAGS argument allows the caller to check whether this\n+   function has changed its behavior relative to earlier versions of GCC.\n+   Normally the argument should be nonnull and point to a zero-initialized\n+   variable.  The function then records whether the ABI decision might\n+   be affected by a known fix to the ABI logic, setting the associated\n+   WARN_PSABI_* bits if so.\n+\n+   When the argument is instead a null pointer, the function tries to\n+   simulate the behavior of GCC before all such ABI fixes were made.\n+   This is useful to check whether the function returns something\n+   different after the ABI fixes.  */\n static int\n aapcs_vfp_sub_candidate (const_tree type, machine_mode *modep,\n-\t\t\t bool *avoid_cxx17_empty_base)\n+\t\t\t unsigned int *warn_psabi_flags)\n {\n   machine_mode mode;\n   HOST_WIDE_INT size;\n@@ -16614,7 +16640,7 @@ aapcs_vfp_sub_candidate (const_tree type, machine_mode *modep,\n \t  return -1;\n \n \tcount = aapcs_vfp_sub_candidate (TREE_TYPE (type), modep,\n-\t\t\t\t\t avoid_cxx17_empty_base);\n+\t\t\t\t\t warn_psabi_flags);\n \tif (count == -1\n \t    || !index\n \t    || !TYPE_MAX_VALUE (index)\n@@ -16652,18 +16678,30 @@ aapcs_vfp_sub_candidate (const_tree type, machine_mode *modep,\n \t    if (TREE_CODE (field) != FIELD_DECL)\n \t      continue;\n \n-\t    /* Ignore C++17 empty base fields, while their type indicates\n-\t       they do contain padding, they have zero size and thus don't\n-\t       contain any padding.  */\n-\t    if (cxx17_empty_base_field_p (field)\n-\t\t&& avoid_cxx17_empty_base)\n+\t    if (DECL_FIELD_ABI_IGNORED (field))\n \t      {\n-\t\t*avoid_cxx17_empty_base = true;\n-\t\tcontinue;\n+\t\t/* See whether this is something that earlier versions of\n+\t\t   GCC failed to ignore.  */\n+\t\tunsigned int flag;\n+\t\tif (lookup_attribute (\"no_unique_address\",\n+\t\t\t\t      DECL_ATTRIBUTES (field)))\n+\t\t  flag = WARN_PSABI_NO_UNIQUE_ADDRESS;\n+\t\telse if (cxx17_empty_base_field_p (field))\n+\t\t  flag = WARN_PSABI_EMPTY_CXX17_BASE;\n+\t\telse\n+\t\t  /* No compatibility problem.  */\n+\t\t  continue;\n+\n+\t\t/* Simulate the old behavior when WARN_PSABI_FLAGS is null.  */\n+\t\tif (warn_psabi_flags)\n+\t\t  {\n+\t\t    *warn_psabi_flags |= flag;\n+\t\t    continue;\n+\t\t  }\n \t      }\n \n \t    sub_count = aapcs_vfp_sub_candidate (TREE_TYPE (field), modep,\n-\t\t\t\t\t\t avoid_cxx17_empty_base);\n+\t\t\t\t\t\t warn_psabi_flags);\n \t    if (sub_count < 0)\n \t      return -1;\n \t    count += sub_count;\n@@ -16697,7 +16735,7 @@ aapcs_vfp_sub_candidate (const_tree type, machine_mode *modep,\n \t      continue;\n \n \t    sub_count = aapcs_vfp_sub_candidate (TREE_TYPE (field), modep,\n-\t\t\t\t\t\t avoid_cxx17_empty_base);\n+\t\t\t\t\t\t warn_psabi_flags);\n \t    if (sub_count < 0)\n \t      return -1;\n \t    count = count > sub_count ? count : sub_count;\n@@ -16796,14 +16834,20 @@ aarch64_composite_type_p (const_tree type,\n    Upon successful return, *COUNT returns the number of needed registers,\n    *BASE_MODE returns the mode of the individual register and when IS_HAF\n    is not NULL, *IS_HA indicates whether or not the argument is a homogeneous\n-   floating-point aggregate or a homogeneous short-vector aggregate.  */\n+   floating-point aggregate or a homogeneous short-vector aggregate.\n+\n+   SILENT_P is true if the function should refrain from reporting any\n+   diagnostics.  This should only be used if the caller is certain that\n+   any ABI decisions would eventually come through this function with\n+   SILENT_P set to false.  */\n \n static bool\n aarch64_vfp_is_call_or_return_candidate (machine_mode mode,\n \t\t\t\t\t const_tree type,\n \t\t\t\t\t machine_mode *base_mode,\n \t\t\t\t\t int *count,\n-\t\t\t\t\t bool *is_ha)\n+\t\t\t\t\t bool *is_ha,\n+\t\t\t\t\t bool silent_p)\n {\n   if (is_ha != NULL) *is_ha = false;\n \n@@ -16824,24 +16868,33 @@ aarch64_vfp_is_call_or_return_candidate (machine_mode mode,\n     }\n   else if (type && composite_p)\n     {\n-      bool avoided = false;\n-      int ag_count = aapcs_vfp_sub_candidate (type, &new_mode, &avoided);\n+      unsigned int warn_psabi_flags = 0;\n+      int ag_count = aapcs_vfp_sub_candidate (type, &new_mode,\n+\t\t\t\t\t      &warn_psabi_flags);\n       if (ag_count > 0 && ag_count <= HA_MAX_NUM_FLDS)\n \t{\n \t  static unsigned last_reported_type_uid;\n \t  unsigned uid = TYPE_UID (TYPE_MAIN_VARIANT (type));\n \t  int alt;\n-\t  if (warn_psabi\n-\t      && avoided\n+\t  if (!silent_p\n+\t      && warn_psabi\n+\t      && warn_psabi_flags\n \t      && uid != last_reported_type_uid\n \t      && ((alt = aapcs_vfp_sub_candidate (type, &new_mode, NULL))\n \t\t  != ag_count))\n \t    {\n \t      gcc_assert (alt == -1);\n \t      last_reported_type_uid = uid;\n-\t      inform (input_location, \"parameter passing for argument of type \"\n-\t\t      \"%qT when C++17 is enabled changed to match C++14 \"\n-\t\t      \"in GCC 10.1\", type);\n+\t      /* Use TYPE_MAIN_VARIANT to strip any redundant const\n+\t\t qualification.  */\n+\t      if (warn_psabi_flags & WARN_PSABI_NO_UNIQUE_ADDRESS)\n+\t\tinform (input_location, \"parameter passing for argument of \"\n+\t\t\t\"type %qT with %<[[no_unique_address]]%> members \"\n+\t\t\t\"changed in GCC 10.1\", TYPE_MAIN_VARIANT (type));\n+\t      else if (warn_psabi_flags & WARN_PSABI_EMPTY_CXX17_BASE)\n+\t\tinform (input_location, \"parameter passing for argument of \"\n+\t\t\t\"type %qT when C++17 is enabled changed to match \"\n+\t\t\t\"C++14 in GCC 10.1\", TYPE_MAIN_VARIANT (type));\n \t    }\n \n \t  if (is_ha != NULL) *is_ha = true;"}, {"sha": "701af0b1e72e734ab3fcebf09070c77ee2c1280a", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/56fe3ca30e1343e4f232ca539726506440e23dd3/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/56fe3ca30e1343e4f232ca539726506440e23dd3/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=56fe3ca30e1343e4f232ca539726506440e23dd3", "patch": "@@ -1,3 +1,8 @@\n+2020-04-29  Richard Sandiford  <richard.sandiford@arm.com>\n+\n+\t* g++.target/aarch64/no_unique_address_1.C: New test.\n+\t* g++.target/aarch64/no_unique_address_2.C: Likewise.\n+\n 2020-04-29  Richard Sandiford  <richard.sandiford@arm.com>\n \n \t* g++.target/arm/mve.exp: Restore the original dg-do-what-default"}, {"sha": "5fc68ea5d6d9d61d198ead9766b538421f25a2db", "filename": "gcc/testsuite/g++.target/aarch64/no_unique_address_1.C", "status": "added", "additions": 206, "deletions": 0, "changes": 206, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/56fe3ca30e1343e4f232ca539726506440e23dd3/gcc%2Ftestsuite%2Fg%2B%2B.target%2Faarch64%2Fno_unique_address_1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/56fe3ca30e1343e4f232ca539726506440e23dd3/gcc%2Ftestsuite%2Fg%2B%2B.target%2Faarch64%2Fno_unique_address_1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.target%2Faarch64%2Fno_unique_address_1.C?ref=56fe3ca30e1343e4f232ca539726506440e23dd3", "patch": "@@ -0,0 +1,206 @@\n+/* { dg-options \"-std=c++11 -O -foptimize-sibling-calls -fpeephole2\" } */\n+/* { dg-final { check-function-bodies \"**\" \"\" \"\" { target lp64 } } } */\n+\n+struct X { };\n+struct Y { int : 0; };\n+struct Z { int : 0; Y y; };\n+struct W : public X { X q; };\n+\n+struct A { float a; };\n+\n+struct B : public X { float a; };\n+struct C : public Y { float a; };\n+struct D : public Z { float a; };\n+struct E : public W { float a; };\n+\n+struct F { [[no_unique_address]] X x; float a; };\n+struct G { [[no_unique_address]] Y y; float a; };\n+struct H { [[no_unique_address]] Z z; float a; };\n+struct I { [[no_unique_address]] W w; float a; };\n+\n+struct J { float a; [[no_unique_address]] X x; float b; };\n+struct K { float a; [[no_unique_address]] Y y; float b; };\n+struct L { float a; [[no_unique_address]] Z z; float b; };\n+struct M { float a; [[no_unique_address]] W w; float b; };\n+\n+struct N : public A { float b; };\n+struct O { [[no_unique_address]] A a; float b; };\n+\n+struct P : public Y { int : 0; float a, b, c, d; };\n+\n+union Q { X x; float a; };\n+union R { [[no_unique_address]] X x; float a; };\n+\n+union S { A a; float b; };\n+union T { F f; float b; };\n+union U { N n; O o; };\n+\n+typedef S Salias;\n+typedef T Talias;\n+typedef U Ualias;\n+\n+#define T(S, s) extern int callee_##s (S)\n+\n+/*\n+** _Z8caller_aR1A:\n+**\tldr\ts0, \\[x0\\]\n+**\tb\t.*\n+*/\n+T (A, a); int caller_a (A &a) { return callee_a (a); } /* { dg-bogus {argument of type 'A'} } */\n+\n+/*\n+** _Z8caller_bR1B:\n+**\tldr\ts0, \\[x0\\]\n+**\tb\t.*\n+*/\n+T (B, b); int caller_b (B &b) { return callee_b (b); } /* { dg-bogus {argument of type 'B'} } */\n+\n+/*\n+** _Z8caller_cR1C:\n+**\tldr\ts0, \\[x0\\]\n+**\tb\t.*\n+*/\n+T (C, c); int caller_c (C &c) { return callee_c (c); } /* { dg-bogus {argument of type 'C'} } */\n+\n+/*\n+** _Z8caller_dR1D:\n+**\tldr\tx0, \\[x0\\]\n+**\tb\t.*\n+*/\n+T (D, d); int caller_d (D &d) { return callee_d (d); } /* { dg-bogus {argument of type 'D'} } */\n+\n+/*\n+** _Z8caller_eR1E:\n+**\tldr\tx0, \\[x0\\]\n+**\tb\t.*\n+*/\n+T (E, e); int caller_e (E &e) { return callee_e (e); } /* { dg-bogus {argument of type 'E'} } */\n+\n+/*\n+** _Z8caller_fR1F:\n+**\tldr\ts0, \\[x0\\]\n+**\tb\t.*\n+*/\n+T (F, f); int caller_f (F &f) { return callee_f (f); } /* { dg-message {parameter passing for argument of type 'F' with '\\[\\[no_unique_address\\]\\]' members changed in GCC 10.1} } */\n+\n+/*\n+** _Z8caller_gR1G:\n+**\tldr\ts0, \\[x0\\]\n+**\tb\t.*\n+*/\n+T (G, g); int caller_g (G &g) { return callee_g (g); } /* { dg-message {parameter passing for argument of type 'G' with '\\[\\[no_unique_address\\]\\]' members changed in GCC 10.1} } */\n+\n+/*\n+** _Z8caller_hR1H:\n+**\tldr\tx0, \\[x0\\]\n+**\tb\t.*\n+*/\n+T (H, h); int caller_h (H &h) { return callee_h (h); } /* { dg-bogus {argument of type 'H'} } */\n+\n+/*\n+** _Z8caller_iR1I:\n+**\tldr\tx0, \\[x0\\]\n+**\tb\t.*\n+*/\n+T (I, i); int caller_i (I &i) { return callee_i (i); } /* { dg-bogus {argument of type 'I'} } */\n+\n+/*\n+** _Z8caller_jR1J:\n+**\tldp\ts0, s1, \\[x0\\]\n+**\tb\t.*\n+*/\n+T (J, j); int caller_j (J &j) { return callee_j (j); } /* { dg-message {parameter passing for argument of type 'J' with '\\[\\[no_unique_address\\]\\]' members changed in GCC 10.1} } */\n+\n+/*\n+** _Z8caller_kR1K:\n+**\tldp\ts0, s1, \\[x0\\]\n+**\tb\t.*\n+*/\n+T (K, k); int caller_k (K &k) { return callee_k (k); } /* { dg-message {parameter passing for argument of type 'K' with '\\[\\[no_unique_address\\]\\]' members changed in GCC 10.1} } */\n+\n+/*\n+** _Z8caller_lR1L: { target aarch64_little_endian }\n+** (\n+**\tldr\tw1, \\[x0, 8\\]\n+**\tldr\tx0, \\[x0\\]\n+** |\n+**\tmov\t(x[0-9]+), x0\n+**\tldr\tx0, \\[x0\\]\n+**\tldr\tw1, \\[\\1, 8\\]\n+** )\n+**\tb\t.*\n+*/\n+T (L, l); int caller_l (L &l) { return callee_l (l); } /* { dg-bogus {argument of type 'L'} } */\n+\n+/*\n+** _Z8caller_mR1M: { target aarch64_little_endian }\n+** (\n+**\tldr\tw1, \\[x0, 8\\]\n+**\tldr\tx0, \\[x0\\]\n+** |\n+**\tmov\t(x[0-9]+), x0\n+**\tldr\tx0, \\[x0\\]\n+**\tldr\tw1, \\[\\1, 8\\]\n+** )\n+**\tb\t.*\n+*/\n+T (M, m); int caller_m (M &m) { return callee_m (m); } /* { dg-bogus {argument of type 'M'} } */\n+\n+/*\n+** _Z8caller_nR1N:\n+**\tldp\ts0, s1, \\[x0\\]\n+**\tb\t.*\n+*/\n+T (N, n); int caller_n (N &n) { return callee_n (n); } /* { dg-bogus {argument of type 'N'} } */\n+\n+/*\n+** _Z8caller_oR1O:\n+**\tldp\ts0, s1, \\[x0\\]\n+**\tb\t.*\n+*/\n+T (O, o); int caller_o (O &o) { return callee_o (o); } /* { dg-bogus {argument of type 'O'} } */\n+\n+/*\n+** _Z8caller_pR1P:\n+**\tldp\ts0, s1, \\[x0\\]\n+**\tldp\ts2, s3, \\[x0, 8\\]\n+**\tb\t.*\n+*/\n+T (P, p); int caller_p (P &p) { return callee_p (p); } /* { dg-bogus {argument of type 'P'} } */\n+\n+/*\n+** _Z8caller_qR1Q: { target aarch64_little_endian }\n+**\tldr\tw0, \\[x0\\]\n+**\tb\t.*\n+*/\n+T (Q, q); int caller_q (Q &q) { return callee_q (q); } /* { dg-bogus {argument of type 'Q'} } */\n+\n+/*\n+** _Z8caller_rR1R: { target aarch64_little_endian }\n+**\tldr\tw0, \\[x0\\]\n+**\tb\t.*\n+*/\n+T (R, r); int caller_r (R &r) { return callee_r (r); } /* { dg-bogus {argument of type 'R'} } */\n+\n+/*\n+** _Z8caller_sR1S:\n+**\tldr\ts0, \\[x0\\]\n+**\tb\t.*\n+*/\n+T (Salias, s); int caller_s (Salias &s) { return callee_s (s); } /* { dg-bogus {argument of type 'S'} } */\n+\n+/*\n+** _Z8caller_tR1T:\n+**\tldr\ts0, \\[x0\\]\n+**\tb\t.*\n+*/\n+T (Talias, t); int caller_t (Talias &t) { return callee_t (t); } /* { dg-message {parameter passing for argument of type 'T' with '\\[\\[no_unique_address\\]\\]' members changed in GCC 10.1} } */\n+\n+/*\n+** _Z8caller_uR1U:\n+**\tldp\ts0, s1, \\[x0\\]\n+**\tb\t.*\n+*/\n+T (Ualias, u); int caller_u (Ualias &u) { return callee_u (u); } /* { dg-bogus {argument of type 'U'} } */\n+\n+/* { dg-bogus {argument of type 'const} \"should not be printed as const\" { target *-*-*} 0 } */"}, {"sha": "f0717133ccd69d6e4f9b9c4c88383691f9ff0ecd", "filename": "gcc/testsuite/g++.target/aarch64/no_unique_address_2.C", "status": "added", "additions": 206, "deletions": 0, "changes": 206, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/56fe3ca30e1343e4f232ca539726506440e23dd3/gcc%2Ftestsuite%2Fg%2B%2B.target%2Faarch64%2Fno_unique_address_2.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/56fe3ca30e1343e4f232ca539726506440e23dd3/gcc%2Ftestsuite%2Fg%2B%2B.target%2Faarch64%2Fno_unique_address_2.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.target%2Faarch64%2Fno_unique_address_2.C?ref=56fe3ca30e1343e4f232ca539726506440e23dd3", "patch": "@@ -0,0 +1,206 @@\n+/* { dg-options \"-std=c++17 -O -foptimize-sibling-calls -fpeephole2\" } */\n+/* { dg-final { check-function-bodies \"**\" \"\" \"\" { target lp64 } } } */\n+\n+struct X { };\n+struct Y { int : 0; };\n+struct Z { int : 0; Y y; };\n+struct W : public X { X q; };\n+\n+struct A { float a; };\n+\n+struct B : public X { float a; };\n+struct C : public Y { float a; };\n+struct D : public Z { float a; };\n+struct E : public W { float a; };\n+\n+struct F { [[no_unique_address]] X x; float a; };\n+struct G { [[no_unique_address]] Y y; float a; };\n+struct H { [[no_unique_address]] Z z; float a; };\n+struct I { [[no_unique_address]] W w; float a; };\n+\n+struct J { float a; [[no_unique_address]] X x; float b; };\n+struct K { float a; [[no_unique_address]] Y y; float b; };\n+struct L { float a; [[no_unique_address]] Z z; float b; };\n+struct M { float a; [[no_unique_address]] W w; float b; };\n+\n+struct N : public A { float b; };\n+struct O { [[no_unique_address]] A a; float b; };\n+\n+struct P : public Y { int : 0; float a, b, c, d; };\n+\n+union Q { X x; float a; };\n+union R { [[no_unique_address]] X x; float a; };\n+\n+union S { A a; float b; };\n+union T { F f; float b; };\n+union U { N n; O o; };\n+\n+typedef S Salias;\n+typedef T Talias;\n+typedef U Ualias;\n+\n+#define T(S, s) extern int callee_##s (S)\n+\n+/*\n+** _Z8caller_aR1A:\n+**\tldr\ts0, \\[x0\\]\n+**\tb\t.*\n+*/\n+T (A, a); int caller_a (A &a) { return callee_a (a); } /* { dg-bogus {argument of type 'A'} } */\n+\n+/*\n+** _Z8caller_bR1B:\n+**\tldr\ts0, \\[x0\\]\n+**\tb\t.*\n+*/\n+T (B, b); int caller_b (B &b) { return callee_b (b); } /* { dg-message {parameter passing for argument of type 'B' when C\\+\\+17 is enabled changed to match C\\+\\+14 in GCC 10.1} } */\n+\n+/*\n+** _Z8caller_cR1C:\n+**\tldr\ts0, \\[x0\\]\n+**\tb\t.*\n+*/\n+T (C, c); int caller_c (C &c) { return callee_c (c); } /* { dg-message {parameter passing for argument of type 'C' when C\\+\\+17 is enabled changed to match C\\+\\+14 in GCC 10.1} } */\n+\n+/*\n+** _Z8caller_dR1D:\n+**\tldr\tx0, \\[x0\\]\n+**\tb\t.*\n+*/\n+T (D, d); int caller_d (D &d) { return callee_d (d); } /* { dg-bogus {argument of type 'D'} } */\n+\n+/*\n+** _Z8caller_eR1E:\n+**\tldr\tx0, \\[x0\\]\n+**\tb\t.*\n+*/\n+T (E, e); int caller_e (E &e) { return callee_e (e); } /* { dg-bogus {argument of type 'E'} } */\n+\n+/*\n+** _Z8caller_fR1F:\n+**\tldr\ts0, \\[x0\\]\n+**\tb\t.*\n+*/\n+T (F, f); int caller_f (F &f) { return callee_f (f); } /* { dg-message {parameter passing for argument of type 'F' with '\\[\\[no_unique_address\\]\\]' members changed in GCC 10.1} } */\n+\n+/*\n+** _Z8caller_gR1G:\n+**\tldr\ts0, \\[x0\\]\n+**\tb\t.*\n+*/\n+T (G, g); int caller_g (G &g) { return callee_g (g); } /* { dg-message {parameter passing for argument of type 'G' with '\\[\\[no_unique_address\\]\\]' members changed in GCC 10.1} } */\n+\n+/*\n+** _Z8caller_hR1H:\n+**\tldr\tx0, \\[x0\\]\n+**\tb\t.*\n+*/\n+T (H, h); int caller_h (H &h) { return callee_h (h); } /* { dg-bogus {argument of type 'H'} } */\n+\n+/*\n+** _Z8caller_iR1I:\n+**\tldr\tx0, \\[x0\\]\n+**\tb\t.*\n+*/\n+T (I, i); int caller_i (I &i) { return callee_i (i); } /* { dg-bogus {argument of type 'I'} } */\n+\n+/*\n+** _Z8caller_jR1J:\n+**\tldp\ts0, s1, \\[x0\\]\n+**\tb\t.*\n+*/\n+T (J, j); int caller_j (J &j) { return callee_j (j); } /* { dg-message {parameter passing for argument of type 'J' with '\\[\\[no_unique_address\\]\\]' members changed in GCC 10.1} } */\n+\n+/*\n+** _Z8caller_kR1K:\n+**\tldp\ts0, s1, \\[x0\\]\n+**\tb\t.*\n+*/\n+T (K, k); int caller_k (K &k) { return callee_k (k); } /* { dg-message {parameter passing for argument of type 'K' with '\\[\\[no_unique_address\\]\\]' members changed in GCC 10.1} } */\n+\n+/*\n+** _Z8caller_lR1L: { target aarch64_little_endian }\n+** (\n+**\tldr\tw1, \\[x0, 8\\]\n+**\tldr\tx0, \\[x0\\]\n+** |\n+**\tmov\t(x[0-9]+), x0\n+**\tldr\tx0, \\[x0\\]\n+**\tldr\tw1, \\[\\1, 8\\]\n+** )\n+**\tb\t.*\n+*/\n+T (L, l); int caller_l (L &l) { return callee_l (l); } /* { dg-bogus {argument of type 'L'} } */\n+\n+/*\n+** _Z8caller_mR1M: { target aarch64_little_endian }\n+** (\n+**\tldr\tw1, \\[x0, 8\\]\n+**\tldr\tx0, \\[x0\\]\n+** |\n+**\tmov\t(x[0-9]+), x0\n+**\tldr\tx0, \\[x0\\]\n+**\tldr\tw1, \\[\\1, 8\\]\n+** )\n+**\tb\t.*\n+*/\n+T (M, m); int caller_m (M &m) { return callee_m (m); } /* { dg-bogus {argument of type 'M'} } */\n+\n+/*\n+** _Z8caller_nR1N:\n+**\tldp\ts0, s1, \\[x0\\]\n+**\tb\t.*\n+*/\n+T (N, n); int caller_n (N &n) { return callee_n (n); } /* { dg-bogus {argument of type 'N'} } */\n+\n+/*\n+** _Z8caller_oR1O:\n+**\tldp\ts0, s1, \\[x0\\]\n+**\tb\t.*\n+*/\n+T (O, o); int caller_o (O &o) { return callee_o (o); } /* { dg-bogus {argument of type 'O'} } */\n+\n+/*\n+** _Z8caller_pR1P:\n+**\tldp\ts0, s1, \\[x0\\]\n+**\tldp\ts2, s3, \\[x0, 8\\]\n+**\tb\t.*\n+*/\n+T (P, p); int caller_p (P &p) { return callee_p (p); } /* { dg-message {parameter passing for argument of type 'P' when C\\+\\+17 is enabled changed to match C\\+\\+14 in GCC 10.1} } */\n+\n+/*\n+** _Z8caller_qR1Q: { target aarch64_little_endian }\n+**\tldr\tw0, \\[x0\\]\n+**\tb\t.*\n+*/\n+T (Q, q); int caller_q (Q &q) { return callee_q (q); } /* { dg-bogus {argument of type 'Q'} } */\n+\n+/*\n+** _Z8caller_rR1R: { target aarch64_little_endian }\n+**\tldr\tw0, \\[x0\\]\n+**\tb\t.*\n+*/\n+T (R, r); int caller_r (R &r) { return callee_r (r); } /* { dg-bogus {argument of type 'R'} } */\n+\n+/*\n+** _Z8caller_sR1S:\n+**\tldr\ts0, \\[x0\\]\n+**\tb\t.*\n+*/\n+T (Salias, s); int caller_s (Salias &s) { return callee_s (s); } /* { dg-bogus {argument of type 'S'} } */\n+\n+/*\n+** _Z8caller_tR1T:\n+**\tldr\ts0, \\[x0\\]\n+**\tb\t.*\n+*/\n+T (Talias, t); int caller_t (Talias &t) { return callee_t (t); } /* { dg-message {parameter passing for argument of type 'T' with '\\[\\[no_unique_address\\]\\]' members changed in GCC 10.1} } */\n+\n+/*\n+** _Z8caller_uR1U:\n+**\tldp\ts0, s1, \\[x0\\]\n+**\tb\t.*\n+*/\n+T (Ualias, u); int caller_u (Ualias &u) { return callee_u (u); } /* { dg-bogus {argument of type 'U'} } */\n+\n+/* { dg-bogus {argument of type 'const} \"should not be printed as const\" { target *-*-*} 0 } */"}]}