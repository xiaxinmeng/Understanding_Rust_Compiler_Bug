{"sha": "f48c3cd2e3f9cd9e3c329eb2d3185bd26e7c7607", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjQ4YzNjZDJlM2Y5Y2Q5ZTNjMzI5ZWIyZDMxODViZDI2ZTdjNzYwNw==", "commit": {"author": {"name": "Patrick Palka", "email": "ppalka@redhat.com", "date": "2021-08-02T13:59:56Z"}, "committer": {"name": "Patrick Palka", "email": "ppalka@redhat.com", "date": "2021-08-02T13:59:56Z"}, "message": "c++: Improve memory usage of subsumption [PR100828]\n\nConstraint subsumption is implemented in two steps.  The first step\ncomputes the disjunctive (or conjunctive) normal form of one of the\nconstraints, and the second step verifies that each clause in the\ndecomposed form implies the other constraint.   Performing these two\nsteps separately is problematic because in the first step the DNF/CNF\ncan be exponentially larger than the original constraint, and by\ncomputing it ahead of time we'd have to keep all of it in memory.\n\nThis patch fixes this exponential blowup in memory usage by interleaving\nthe two steps, so that as soon as we decompose one clause we check\nimplication for it.  In turn, memory usage during subsumption is now\nworst case linear in the size of the constraints rather than\nexponential, and so we can safely remove the hard limit of 16 clauses\nwithout introducing runaway memory usage on some inputs.  (Note the\n_time_ complexity of subsumption is still exponential in the worst case.)\n\nIn order for this to work we need to make formula::branch() insert the\ncopy of the current clause directly after the current clause rather than\nat the end of the list, so that we fully decompose a clause shortly\nafter creating it.  Otherwise we'd end up accumulating exponentially\nmany (partially decomposed) clauses in memory anyway.\n\n\tPR c++/100828\n\ngcc/cp/ChangeLog:\n\n\t* logic.cc (formula::formula): Use emplace_back instead of\n\tpush_back.\n\t(formula::branch): Insert a copy of m_current directly after\n\tm_current instead of at the end of the list.\n\t(formula::erase): Define.\n\t(decompose_formula): Remove.\n\t(decompose_antecedents): Remove.\n\t(decompose_consequents): Remove.\n\t(derive_proofs): Remove.\n\t(max_problem_size): Remove.\n\t(diagnose_constraint_size): Remove.\n\t(subsumes_constraints_nonnull): Rewrite directly in terms of\n\tdecompose_clause and derive_proof, interleaving decomposition\n\twith implication checking.  Remove limit on constraint complexity.\n\tUse formula::erase to free the current clause before moving on to\n\tthe next one.", "tree": {"sha": "099e64ec176230838894dd79597fe670fee386d9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/099e64ec176230838894dd79597fe670fee386d9"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f48c3cd2e3f9cd9e3c329eb2d3185bd26e7c7607", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f48c3cd2e3f9cd9e3c329eb2d3185bd26e7c7607", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f48c3cd2e3f9cd9e3c329eb2d3185bd26e7c7607", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f48c3cd2e3f9cd9e3c329eb2d3185bd26e7c7607/comments", "author": null, "committer": null, "parents": [{"sha": "f9fcf754825a1e01033336f84c18690aaa971a6f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f9fcf754825a1e01033336f84c18690aaa971a6f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f9fcf754825a1e01033336f84c18690aaa971a6f"}], "stats": {"total": 118, "additions": 35, "deletions": 83}, "files": [{"sha": "9d892b1473bf5988e097f7c478f1892c5a18b292", "filename": "gcc/cp/logic.cc", "status": "modified", "additions": 35, "deletions": 83, "changes": 118, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f48c3cd2e3f9cd9e3c329eb2d3185bd26e7c7607/gcc%2Fcp%2Flogic.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f48c3cd2e3f9cd9e3c329eb2d3185bd26e7c7607/gcc%2Fcp%2Flogic.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Flogic.cc?ref=f48c3cd2e3f9cd9e3c329eb2d3185bd26e7c7607", "patch": "@@ -223,9 +223,7 @@ struct formula\n \n   formula (tree t)\n   {\n-    /* This should call emplace_back(). There's an extra copy being\n-       invoked by using push_back().  */\n-    m_clauses.push_back (t);\n+    m_clauses.emplace_back (t);\n     m_current = m_clauses.begin ();\n   }\n \n@@ -248,8 +246,7 @@ struct formula\n   clause& branch ()\n   {\n     gcc_assert (!done ());\n-    m_clauses.push_back (*m_current);\n-    return m_clauses.back ();\n+    return *m_clauses.insert (std::next (m_current), *m_current);\n   }\n \n   /* Returns the position of the current clause.  */\n@@ -287,6 +284,14 @@ struct formula\n     return m_clauses.end ();\n   }\n \n+  /* Remove the specified clause from the formula.  */\n+\n+  void erase (iterator i)\n+  {\n+    gcc_assert (i != m_current);\n+    m_clauses.erase (i);\n+  }\n+\n   std::list<clause> m_clauses; /* The list of clauses.  */\n   iterator m_current; /* The current clause.  */\n };\n@@ -659,39 +664,6 @@ decompose_clause (formula& f, clause& c, rules r)\n   f.advance ();\n }\n \n-/* Decompose the logical formula F according to the logical\n-   rules determined by R.  The result is a formula containing\n-   clauses that contain only atomic terms.  */\n-\n-void\n-decompose_formula (formula& f, rules r)\n-{\n-  while (!f.done ())\n-    decompose_clause (f, *f.current (), r);\n-}\n-\n-/* Fully decomposing T into a list of sequents, each comprised of\n-   a list of atomic constraints, as if T were an antecedent.  */\n-\n-static formula\n-decompose_antecedents (tree t)\n-{\n-  formula f (t);\n-  decompose_formula (f, left);\n-  return f;\n-}\n-\n-/* Fully decomposing T into a list of sequents, each comprised of\n-   a list of atomic constraints, as if T were a consequent.  */\n-\n-static formula\n-decompose_consequents (tree t)\n-{\n-  formula f (t);\n-  decompose_formula (f, right);\n-  return f;\n-}\n-\n static bool derive_proof (clause&, tree, rules);\n \n /* Derive a proof of both operands of T.  */\n@@ -744,28 +716,6 @@ derive_proof (clause& c, tree t, rules r)\n   }\n }\n \n-/* Derive a proof of T from disjunctive clauses in F.  */\n-\n-static bool\n-derive_proofs (formula& f, tree t, rules r)\n-{\n-  for (formula::iterator i = f.begin(); i != f.end(); ++i)\n-    if (!derive_proof (*i, t, r))\n-      return false;\n-  return true;\n-}\n-\n-/* The largest number of clauses in CNF or DNF we accept as input\n-   for subsumption. This an upper bound of 2^16 expressions.  */\n-static int max_problem_size = 16;\n-\n-static inline bool\n-diagnose_constraint_size (tree t)\n-{\n-  error_at (input_location, \"%qE exceeds the maximum constraint complexity\", t);\n-  return false;\n-}\n-\n /* Key/value pair for caching subsumption results. This associates a pair of\n    constraints with a boolean value indicating the result.  */\n \n@@ -845,31 +795,33 @@ subsumes_constraints_nonnull (tree lhs, tree rhs)\n   if (bool *b = lookup_subsumption(lhs, rhs))\n     return *b;\n \n-  int n1 = dnf_size (lhs);\n-  int n2 = cnf_size (rhs);\n-\n-  /* Make sure we haven't exceeded the largest acceptable problem.  */\n-  if (std::min (n1, n2) >= max_problem_size)\n-    {\n-      if (n1 < n2)\n-        diagnose_constraint_size (lhs);\n-      else\n-\tdiagnose_constraint_size (rhs);\n-      return false;\n-    }\n-\n-  /* Decompose the smaller of the two formulas, and recursively\n-     check for implication of the larger.  */\n-  bool result;\n-  if (n1 <= n2)\n-    {\n-      formula dnf = decompose_antecedents (lhs);\n-      result = derive_proofs (dnf, rhs, left);\n-    }\n+  tree x, y;\n+  rules r;\n+  if (dnf_size (lhs) <= cnf_size (rhs))\n+    /* When LHS looks simpler than RHS, we'll determine subsumption by\n+       decomposing LHS into its disjunctive normal form and checking that\n+       each (conjunctive) clause in the decomposed LHS implies RHS.  */\n+    x = lhs, y = rhs, r = left;\n   else\n+    /* Otherwise, we'll determine subsumption by decomposing RHS into its\n+       conjunctive normal form and checking that each (disjunctive) clause\n+       in the decomposed RHS implies LHS.  */\n+    x = rhs, y = lhs, r = right;\n+\n+  /* Decompose X into a list of sequents according to R, and recursively\n+     check for implication of Y.  */\n+  bool result = true;\n+  formula f (x);\n+  while (!f.done ())\n     {\n-      formula cnf = decompose_consequents (rhs);\n-      result = derive_proofs (cnf, lhs, right);\n+      auto i = f.current ();\n+      decompose_clause (f, *i, r);\n+      if (!derive_proof (*i, y, r))\n+\t{\n+\t  result = false;\n+\t  break;\n+\t}\n+      f.erase (i);\n     }\n \n   return save_subsumption (lhs, rhs, result);"}]}