{"sha": "fa2c9034583b7fe6300e547dc67792e4eb440f48", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZmEyYzkwMzQ1ODNiN2ZlNjMwMGU1NDdkYzY3NzkyZTRlYjQ0MGY0OA==", "commit": {"author": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2016-06-01T13:08:24Z"}, "committer": {"name": "Richard Biener", "email": "rguenth@gcc.gnu.org", "date": "2016-06-01T13:08:24Z"}, "message": "re PR tree-optimization/71261 (Trunk GCC hangs on knl and broadwell targets)\n\n2016-06-01  Richard Biener  <rguenther@suse.de>\n\n\tPR tree-optimization/71261\n\t* tree-vect-patterns.c (check_bool_pattern): Gather a hash-set\n\tof stmts successfully put in the bool pattern.  Remove\n\tsingle-use restriction.\n\t(adjust_bool_pattern_cast): Add cast at the use site via the\n\tpattern def sequence.\n\t(adjust_bool_pattern): Remove recursion, maintain a hash-map\n\tof patterned defs.  Use the pattern def seqence instead of\n\tmultiple independent patterns.\n\t(sort_after_uid): New qsort compare function.\n\t(adjust_bool_stmts): New function to process stmts in the bool\n\tpattern in IL order.\n\t(vect_recog_bool_pattern): Adjust.\n\t* tree-if-conv.c (ifcvt_split_def_stmt): Remove.\n\t(ifcvt_walk_pattern_tree): Likewise.\n\t(stmt_is_root_of_bool_pattern): Likewise.\n\t(ifcvt_repair_bool_pattern): Likewise.\n\t(tree_if_conversion): Do not call ifcvt_repair_bool_pattern.\n\n\t* gcc.dg/torture/vect-bool-1.c: New testcase.\n\nFrom-SVN: r236989", "tree": {"sha": "574d63a4f07f9b63df083f2f3e1ef7f6230e90cd", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/574d63a4f07f9b63df083f2f3e1ef7f6230e90cd"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/fa2c9034583b7fe6300e547dc67792e4eb440f48", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fa2c9034583b7fe6300e547dc67792e4eb440f48", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fa2c9034583b7fe6300e547dc67792e4eb440f48", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fa2c9034583b7fe6300e547dc67792e4eb440f48/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "3e32893c0bba66df33a1143afcb45e345172360a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3e32893c0bba66df33a1143afcb45e345172360a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3e32893c0bba66df33a1143afcb45e345172360a"}], "stats": {"total": 438, "additions": 167, "deletions": 271}, "files": [{"sha": "8ab3fc62693a5951fad72bb3c7827bdc37c87d97", "filename": "gcc/ChangeLog", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fa2c9034583b7fe6300e547dc67792e4eb440f48/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fa2c9034583b7fe6300e547dc67792e4eb440f48/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=fa2c9034583b7fe6300e547dc67792e4eb440f48", "patch": "@@ -1,3 +1,24 @@\n+2016-06-01  Richard Biener  <rguenther@suse.de>\n+\n+\tPR tree-optimization/71261\n+\t* tree-vect-patterns.c (check_bool_pattern): Gather a hash-set\n+\tof stmts successfully put in the bool pattern.  Remove\n+\tsingle-use restriction.\n+\t(adjust_bool_pattern_cast): Add cast at the use site via the\n+\tpattern def sequence.\n+\t(adjust_bool_pattern): Remove recursion, maintain a hash-map\n+\tof patterned defs.  Use the pattern def seqence instead of\n+\tmultiple independent patterns.\n+\t(sort_after_uid): New qsort compare function.\n+\t(adjust_bool_stmts): New function to process stmts in the bool\n+\tpattern in IL order.\n+\t(vect_recog_bool_pattern): Adjust.\n+\t* tree-if-conv.c (ifcvt_split_def_stmt): Remove.\n+\t(ifcvt_walk_pattern_tree): Likewise.\n+\t(stmt_is_root_of_bool_pattern): Likewise.\n+\t(ifcvt_repair_bool_pattern): Likewise.\n+\t(tree_if_conversion): Do not call ifcvt_repair_bool_pattern.\n+\n 2016-06-01  Jan Hubicka  <hubicka@ucw.cz>\n \n \t* loop-unroll.c (decide_unroll_constant_iterations,"}, {"sha": "ba28ae8d6f4698d55e2dddf8e2f61e1ba22039cd", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fa2c9034583b7fe6300e547dc67792e4eb440f48/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fa2c9034583b7fe6300e547dc67792e4eb440f48/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=fa2c9034583b7fe6300e547dc67792e4eb440f48", "patch": "@@ -1,3 +1,8 @@\n+2016-06-01  Richard Biener  <rguenther@suse.de>\n+\n+\tPR tree-optimization/71261\n+\t* gcc.dg/torture/vect-bool-1.c: New testcase.\n+\n 2016-06-01  Jakub Jelinek  <jakub@redhat.com>\n \n \t* gfortran.dg/gomp/order-1.f90: New test."}, {"sha": "ca1456b4d8e9bfcfb97a8ae28bcb3c0afeaa83b3", "filename": "gcc/testsuite/gcc.dg/torture/vect-bool-1.c", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fa2c9034583b7fe6300e547dc67792e4eb440f48/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Fvect-bool-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fa2c9034583b7fe6300e547dc67792e4eb440f48/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Fvect-bool-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Fvect-bool-1.c?ref=fa2c9034583b7fe6300e547dc67792e4eb440f48", "patch": "@@ -0,0 +1,14 @@\n+/* { dg-do compile } */\n+\n+int a[64];\n+long b[64];\n+\n+void foo (void)\n+{\n+  for (int i = 0; i < 64; ++i)\n+    {\n+      _Bool x = a[i] < 10;\n+      a[i] = x;\n+      b[i] = x;\n+    }\n+}"}, {"sha": "e5a3372cd4e3c11bc744a7847ac5576e7c5a336d", "filename": "gcc/tree-if-conv.c", "status": "modified", "additions": 1, "deletions": 191, "changes": 192, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fa2c9034583b7fe6300e547dc67792e4eb440f48/gcc%2Ftree-if-conv.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fa2c9034583b7fe6300e547dc67792e4eb440f48/gcc%2Ftree-if-conv.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-if-conv.c?ref=fa2c9034583b7fe6300e547dc67792e4eb440f48", "patch": "@@ -2516,194 +2516,6 @@ ifcvt_split_critical_edges (struct loop *loop, bool aggressive_if_conv)\n   return true;\n }\n \n-/* Assumes that lhs of DEF_STMT have multiple uses.\n-   Delete one use by (1) creation of copy DEF_STMT with\n-   unique lhs; (2) change original use of lhs in one\n-   use statement with newly created lhs.  */\n-\n-static void\n-ifcvt_split_def_stmt (gimple *def_stmt, gimple *use_stmt)\n-{\n-  tree var;\n-  tree lhs;\n-  gimple *copy_stmt;\n-  gimple_stmt_iterator gsi;\n-  use_operand_p use_p;\n-  ssa_op_iter iter;\n-\n-  var = gimple_assign_lhs (def_stmt);\n-  copy_stmt = gimple_copy (def_stmt);\n-  lhs = make_temp_ssa_name (TREE_TYPE (var), NULL, \"_ifc_\");\n-  gimple_assign_set_lhs (copy_stmt, lhs);\n-  SSA_NAME_DEF_STMT (lhs) = copy_stmt;\n-  /* Insert copy of DEF_STMT.  */\n-  gsi = gsi_for_stmt (def_stmt);\n-  gsi_insert_after (&gsi, copy_stmt, GSI_SAME_STMT);\n-  /* Change use of var to lhs in use_stmt.  */\n-  if (dump_file && (dump_flags & TDF_DETAILS))\n-    {\n-      fprintf (dump_file, \"Change use of var  \");\n-      print_generic_expr (dump_file, var, TDF_SLIM);\n-      fprintf (dump_file, \" to \");\n-      print_generic_expr (dump_file, lhs, TDF_SLIM);\n-      fprintf (dump_file, \"\\n\");\n-    }\n-  FOR_EACH_SSA_USE_OPERAND (use_p, use_stmt, iter, SSA_OP_USE)\n-    {\n-      if (USE_FROM_PTR (use_p) != var)\n-\tcontinue;\n-      SET_USE (use_p, lhs);\n-      break;\n-    }\n-}\n-\n-/* Traverse bool pattern recursively starting from VAR.\n-   Save its def and use statements to defuse_list if VAR does\n-   not have single use.  */\n-\n-static void\n-ifcvt_walk_pattern_tree (tree var, vec<gimple *> *defuse_list,\n-\t\t\t gimple *use_stmt)\n-{\n-  tree rhs1, rhs2;\n-  enum tree_code code;\n-  gimple *def_stmt;\n-\n-  if (TREE_CODE (var) != SSA_NAME)\n-    return;\n-\n-  def_stmt = SSA_NAME_DEF_STMT (var);\n-  if (gimple_code (def_stmt) != GIMPLE_ASSIGN)\n-    return;\n-  if (!has_single_use (var))\n-    {\n-      /* Put def and use stmts into defuse_list.  */\n-      defuse_list->safe_push (def_stmt);\n-      defuse_list->safe_push (use_stmt);\n-      if (dump_file && (dump_flags & TDF_DETAILS))\n-\t{\n-\t  fprintf (dump_file, \"Multiple lhs uses in stmt\\n\");\n-\t  print_gimple_stmt (dump_file, def_stmt, 0, TDF_SLIM);\n-\t}\n-    }\n-  rhs1 = gimple_assign_rhs1 (def_stmt);\n-  code = gimple_assign_rhs_code (def_stmt);\n-  switch (code)\n-    {\n-    case SSA_NAME:\n-      ifcvt_walk_pattern_tree (rhs1, defuse_list, def_stmt);\n-      break;\n-    CASE_CONVERT:\n-      if ((TYPE_PRECISION (TREE_TYPE (rhs1)) != 1\n-\t   || !TYPE_UNSIGNED (TREE_TYPE (rhs1)))\n-\t  && TREE_CODE (TREE_TYPE (rhs1)) != BOOLEAN_TYPE)\n-\tbreak;\n-      ifcvt_walk_pattern_tree (rhs1, defuse_list, def_stmt);\n-      break;\n-    case BIT_NOT_EXPR:\n-      ifcvt_walk_pattern_tree (rhs1, defuse_list, def_stmt);\n-      break;\n-    case BIT_AND_EXPR:\n-    case BIT_IOR_EXPR:\n-    case BIT_XOR_EXPR:\n-      ifcvt_walk_pattern_tree (rhs1, defuse_list, def_stmt);\n-      rhs2 = gimple_assign_rhs2 (def_stmt);\n-      ifcvt_walk_pattern_tree (rhs2, defuse_list, def_stmt);\n-      break;\n-    default:\n-      break;\n-    }\n-  return;\n-}\n-\n-/* Returns true if STMT can be a root of bool pattern applied\n-   by vectorizer.  */\n-\n-static bool\n-stmt_is_root_of_bool_pattern (gimple *stmt)\n-{\n-  enum tree_code code;\n-  tree lhs, rhs;\n-\n-  code = gimple_assign_rhs_code (stmt);\n-  if (CONVERT_EXPR_CODE_P (code))\n-    {\n-      lhs = gimple_assign_lhs (stmt);\n-      rhs = gimple_assign_rhs1 (stmt);\n-      if (TREE_CODE (TREE_TYPE (rhs)) != BOOLEAN_TYPE)\n-\treturn false;\n-      if (TREE_CODE (TREE_TYPE (lhs)) == BOOLEAN_TYPE)\n-\treturn false;\n-      return true;\n-    }\n-  else if (code == COND_EXPR)\n-    {\n-      rhs = gimple_assign_rhs1 (stmt);\n-      if (TREE_CODE (rhs) != SSA_NAME)\n-\treturn false;\n-      return true;\n-    }\n-  return false;\n-}\n-\n-/*  Traverse all statements in BB which correspond to loop header to\n-    find out all statements which can start bool pattern applied by\n-    vectorizer and convert multiple uses in it to conform pattern\n-    restrictions.  Such case can occur if the same predicate is used both\n-    for phi node conversion and load/store mask.  */\n-\n-static void\n-ifcvt_repair_bool_pattern (basic_block bb)\n-{\n-  tree rhs;\n-  gimple *stmt;\n-  gimple_stmt_iterator gsi;\n-  auto_vec<gimple *> defuse_list;\n-  auto_vec<gimple *> pattern_roots;\n-  bool repeat = true;\n-  int niter = 0;\n-  unsigned int ix;\n-\n-  /* Collect all root pattern statements.  */\n-  for (gsi = gsi_start_bb (bb); !gsi_end_p (gsi); gsi_next (&gsi))\n-    {\n-      stmt = gsi_stmt (gsi);\n-      if (gimple_code (stmt) != GIMPLE_ASSIGN)\n-\tcontinue;\n-      if (!stmt_is_root_of_bool_pattern (stmt))\n-\tcontinue;\n-      pattern_roots.safe_push (stmt);\n-    }\n-\n-  if (pattern_roots.is_empty ())\n-    return;\n-\n-  /* Split all statements with multiple uses iteratively since splitting\n-     may create new multiple uses.  */\n-  while (repeat)\n-    {\n-      repeat = false;\n-      niter++;\n-      FOR_EACH_VEC_ELT (pattern_roots, ix, stmt)\n-\t{\n-\t  rhs = gimple_assign_rhs1 (stmt);\n-\t  ifcvt_walk_pattern_tree (rhs, &defuse_list, stmt);\n-\t  while (defuse_list.length () > 0)\n-\t    {\n-\t      repeat = true;\n-\t      gimple *def_stmt, *use_stmt;\n-\t      use_stmt = defuse_list.pop ();\n-\t      def_stmt = defuse_list.pop ();\n-\t      ifcvt_split_def_stmt (def_stmt, use_stmt);\n-\t    }\n-\n-\t}\n-    }\n-  if (dump_file && (dump_flags & TDF_DETAILS))\n-    fprintf (dump_file, \"Repair bool pattern takes %d iterations. \\n\",\n-\t     niter);\n-}\n-\n /* Delete redundant statements produced by predication which prevents\n    loop vectorization.  */\n \n@@ -2850,10 +2662,8 @@ tree_if_conversion (struct loop *loop)\n      on-the-fly.  */\n   combine_blocks (loop);\n \n-  /* Delete dead predicate computations and repair tree correspondent\n-     to bool pattern to delete multiple uses of predicates.  */\n+  /* Delete dead predicate computations.  */\n   ifcvt_local_dce (loop->header);\n-  ifcvt_repair_bool_pattern (loop->header);\n \n   todo |= TODO_cleanup_cfg;\n   mark_virtual_operands_for_renaming (cfun);"}, {"sha": "e1622a81b91d263a7fd3ad250f0632dd8ea42b6a", "filename": "gcc/tree-vect-patterns.c", "status": "modified", "additions": 126, "deletions": 80, "changes": 206, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fa2c9034583b7fe6300e547dc67792e4eb440f48/gcc%2Ftree-vect-patterns.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fa2c9034583b7fe6300e547dc67792e4eb440f48/gcc%2Ftree-vect-patterns.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-patterns.c?ref=fa2c9034583b7fe6300e547dc67792e4eb440f48", "patch": "@@ -2888,10 +2888,11 @@ vect_recog_mixed_size_cond_pattern (vec<gimple *> *stmts, tree *type_in,\n /* Helper function of vect_recog_bool_pattern.  Called recursively, return\n    true if bool VAR can and should be optimized that way.  Assume it shouldn't\n    in case it's a result of a comparison which can be directly vectorized into\n-   a vector comparison.  */\n+   a vector comparison.  Fills in STMTS with all stmts visited during the\n+   walk.  */\n \n static bool\n-check_bool_pattern (tree var, vec_info *vinfo)\n+check_bool_pattern (tree var, vec_info *vinfo, hash_set<gimple *> &stmts)\n {\n   gimple *def_stmt;\n   enum vect_def_type dt;\n@@ -2907,37 +2908,44 @@ check_bool_pattern (tree var, vec_info *vinfo)\n   if (!is_gimple_assign (def_stmt))\n     return false;\n \n-  if (!has_single_use (var))\n-    return false;\n+  if (stmts.contains (def_stmt))\n+    return true;\n \n   rhs1 = gimple_assign_rhs1 (def_stmt);\n   rhs_code = gimple_assign_rhs_code (def_stmt);\n   switch (rhs_code)\n     {\n     case SSA_NAME:\n-      return check_bool_pattern (rhs1, vinfo);\n+      if (! check_bool_pattern (rhs1, vinfo, stmts))\n+\treturn false;\n+      break;\n \n     CASE_CONVERT:\n       if ((TYPE_PRECISION (TREE_TYPE (rhs1)) != 1\n \t   || !TYPE_UNSIGNED (TREE_TYPE (rhs1)))\n \t  && TREE_CODE (TREE_TYPE (rhs1)) != BOOLEAN_TYPE)\n \treturn false;\n-      return check_bool_pattern (rhs1, vinfo);\n+      if (! check_bool_pattern (rhs1, vinfo, stmts))\n+\treturn false;\n+      break;\n \n     case BIT_NOT_EXPR:\n-      return check_bool_pattern (rhs1, vinfo);\n+      if (! check_bool_pattern (rhs1, vinfo, stmts))\n+\treturn false;\n+      break;\n \n     case BIT_AND_EXPR:\n     case BIT_IOR_EXPR:\n     case BIT_XOR_EXPR:\n-      if (!check_bool_pattern (rhs1, vinfo))\n+      if (! check_bool_pattern (rhs1, vinfo, stmts)\n+\t  || ! check_bool_pattern (gimple_assign_rhs2 (def_stmt), vinfo, stmts))\n \treturn false;\n-      return check_bool_pattern (gimple_assign_rhs2 (def_stmt), vinfo);\n+      break;\n \n     default:\n       if (TREE_CODE_CLASS (rhs_code) == tcc_comparison)\n \t{\n-\t  tree vecitype, comp_vectype, mask_type;\n+\t  tree vecitype, comp_vectype;\n \n \t  /* If the comparison can throw, then is_gimple_condexpr will be\n \t     false and we can't make a COND_EXPR/VEC_COND_EXPR out of it.  */\n@@ -2948,7 +2956,7 @@ check_bool_pattern (tree var, vec_info *vinfo)\n \t  if (comp_vectype == NULL_TREE)\n \t    return false;\n \n-\t  mask_type = get_mask_type_for_scalar_type (TREE_TYPE (rhs1));\n+\t  tree mask_type = get_mask_type_for_scalar_type (TREE_TYPE (rhs1));\n \t  if (mask_type\n \t      && expand_vec_cmp_expr_p (comp_vectype, mask_type))\n \t    return false;\n@@ -2964,50 +2972,54 @@ check_bool_pattern (tree var, vec_info *vinfo)\n \t    }\n \t  else\n \t    vecitype = comp_vectype;\n-\t  return expand_vec_cond_expr_p (vecitype, comp_vectype);\n+\t  if (! expand_vec_cond_expr_p (vecitype, comp_vectype))\n+\t    return false;\n \t}\n-      return false;\n+      else\n+\treturn false;\n+      break;\n     }\n+\n+  bool res = stmts.add (def_stmt);\n+  /* We can't end up recursing when just visiting SSA defs but not PHIs.  */\n+  gcc_assert (!res);\n+\n+  return true;\n }\n \n \n /* Helper function of adjust_bool_pattern.  Add a cast to TYPE to a previous\n-   stmt (SSA_NAME_DEF_STMT of VAR) by moving the COND_EXPR from RELATED_STMT\n-   to PATTERN_DEF_SEQ and adding a cast as RELATED_STMT.  */\n+   stmt (SSA_NAME_DEF_STMT of VAR) adding a cast to STMT_INFOs\n+   pattern sequence.  */\n \n static tree\n-adjust_bool_pattern_cast (tree type, tree var)\n+adjust_bool_pattern_cast (tree type, tree var, stmt_vec_info stmt_info)\n {\n-  stmt_vec_info stmt_vinfo = vinfo_for_stmt (SSA_NAME_DEF_STMT (var));\n-  gimple *cast_stmt, *pattern_stmt;\n-\n-  gcc_assert (!STMT_VINFO_PATTERN_DEF_SEQ (stmt_vinfo));\n-  pattern_stmt = STMT_VINFO_RELATED_STMT (stmt_vinfo);\n-  new_pattern_def_seq (stmt_vinfo, pattern_stmt);\n-  cast_stmt = gimple_build_assign (vect_recog_temp_ssa_var (type, NULL),\n-\t\t\t\t   NOP_EXPR, gimple_assign_lhs (pattern_stmt));\n-  STMT_VINFO_RELATED_STMT (stmt_vinfo) = cast_stmt;\n+  gimple *cast_stmt = gimple_build_assign (vect_recog_temp_ssa_var (type, NULL),\n+\t\t\t\t\t   NOP_EXPR, var);\n+  stmt_vec_info patt_vinfo = new_stmt_vec_info (cast_stmt, stmt_info->vinfo);\n+  set_vinfo_for_stmt (cast_stmt, patt_vinfo);\n+  STMT_VINFO_VECTYPE (patt_vinfo) = get_vectype_for_scalar_type (type);\n+  append_pattern_def_seq (stmt_info, cast_stmt);\n   return gimple_assign_lhs (cast_stmt);\n }\n \n+/* Helper function of vect_recog_bool_pattern.  Do the actual transformations.\n+   VAR is an SSA_NAME that should be transformed from bool to a wider integer\n+   type, OUT_TYPE is the desired final integer type of the whole pattern.\n+   STMT_INFO is the info of the pattern root and is where pattern stmts should\n+   be associated with.  DEFS is a map of pattern defs.  */\n \n-/* Helper function of vect_recog_bool_pattern.  Do the actual transformations,\n-   recursively.  VAR is an SSA_NAME that should be transformed from bool\n-   to a wider integer type, OUT_TYPE is the desired final integer type of\n-   the whole pattern, TRUEVAL should be NULL unless optimizing\n-   BIT_AND_EXPR into a COND_EXPR with one integer from one of the operands\n-   in the then_clause, STMTS is where statements with added pattern stmts\n-   should be pushed to.  */\n-\n-static tree\n-adjust_bool_pattern (tree var, tree out_type, tree trueval,\n-\t\t     vec<gimple *> *stmts)\n+static void\n+adjust_bool_pattern (tree var, tree out_type,\n+\t\t     stmt_vec_info stmt_info, hash_map <tree, tree> &defs)\n {\n   gimple *stmt = SSA_NAME_DEF_STMT (var);\n   enum tree_code rhs_code, def_rhs_code;\n   tree itype, cond_expr, rhs1, rhs2, irhs1, irhs2;\n   location_t loc;\n   gimple *pattern_stmt, *def_stmt;\n+  tree trueval = NULL_TREE;\n \n   rhs1 = gimple_assign_rhs1 (stmt);\n   rhs2 = gimple_assign_rhs2 (stmt);\n@@ -3017,15 +3029,15 @@ adjust_bool_pattern (tree var, tree out_type, tree trueval,\n     {\n     case SSA_NAME:\n     CASE_CONVERT:\n-      irhs1 = adjust_bool_pattern (rhs1, out_type, NULL_TREE, stmts);\n+      irhs1 = *defs.get (rhs1);\n       itype = TREE_TYPE (irhs1);\n       pattern_stmt\n \t= gimple_build_assign (vect_recog_temp_ssa_var (itype, NULL),\n \t\t\t       SSA_NAME, irhs1);\n       break;\n \n     case BIT_NOT_EXPR:\n-      irhs1 = adjust_bool_pattern (rhs1, out_type, NULL_TREE, stmts);\n+      irhs1 = *defs.get (rhs1);\n       itype = TREE_TYPE (irhs1);\n       pattern_stmt\n \t= gimple_build_assign (vect_recog_temp_ssa_var (itype, NULL),\n@@ -3070,57 +3082,45 @@ adjust_bool_pattern (tree var, tree out_type, tree trueval,\n       def_rhs_code = gimple_assign_rhs_code (def_stmt);\n       if (TREE_CODE_CLASS (def_rhs_code) == tcc_comparison)\n \t{\n+\t  irhs1 = *defs.get (rhs1);\n \t  tree def_rhs1 = gimple_assign_rhs1 (def_stmt);\n-\t  irhs1 = adjust_bool_pattern (rhs1, out_type, NULL_TREE, stmts);\n \t  if (TYPE_PRECISION (TREE_TYPE (irhs1))\n \t      == GET_MODE_BITSIZE (TYPE_MODE (TREE_TYPE (def_rhs1))))\n \t    {\n-\t      gimple *tstmt;\n-\t      stmt_vec_info stmt_def_vinfo = vinfo_for_stmt (def_stmt);\n-\t      irhs2 = adjust_bool_pattern (rhs2, out_type, irhs1, stmts);\n-\t      tstmt = stmts->pop ();\n-\t      gcc_assert (tstmt == def_stmt);\n-\t      stmts->quick_push (stmt);\n-\t      STMT_VINFO_RELATED_STMT (vinfo_for_stmt (stmt))\n-\t\t= STMT_VINFO_RELATED_STMT (stmt_def_vinfo);\n-\t      gcc_assert (!STMT_VINFO_PATTERN_DEF_SEQ (stmt_def_vinfo));\n-\t      STMT_VINFO_RELATED_STMT (stmt_def_vinfo) = NULL;\n-\t      return irhs2;\n+\t      rhs_code = def_rhs_code;\n+\t      rhs1 = def_rhs1;\n+\t      rhs2 = gimple_assign_rhs2 (def_stmt);\n+\t      trueval = irhs1;\n+\t      goto do_compare;\n \t    }\n \t  else\n-\t    irhs2 = adjust_bool_pattern (rhs2, out_type, NULL_TREE, stmts);\n+\t    irhs2 = *defs.get (rhs2);\n \t  goto and_ior_xor;\n \t}\n       def_stmt = SSA_NAME_DEF_STMT (rhs1);\n       def_rhs_code = gimple_assign_rhs_code (def_stmt);\n       if (TREE_CODE_CLASS (def_rhs_code) == tcc_comparison)\n \t{\n+\t  irhs2 = *defs.get (rhs2);\n \t  tree def_rhs1 = gimple_assign_rhs1 (def_stmt);\n-\t  irhs2 = adjust_bool_pattern (rhs2, out_type, NULL_TREE, stmts);\n \t  if (TYPE_PRECISION (TREE_TYPE (irhs2))\n \t      == GET_MODE_BITSIZE (TYPE_MODE (TREE_TYPE (def_rhs1))))\n \t    {\n-\t      gimple *tstmt;\n-\t      stmt_vec_info stmt_def_vinfo = vinfo_for_stmt (def_stmt);\n-\t      irhs1 = adjust_bool_pattern (rhs1, out_type, irhs2, stmts);\n-\t      tstmt = stmts->pop ();\n-\t      gcc_assert (tstmt == def_stmt);\n-\t      stmts->quick_push (stmt);\n-\t      STMT_VINFO_RELATED_STMT (vinfo_for_stmt (stmt))\n-\t\t= STMT_VINFO_RELATED_STMT (stmt_def_vinfo);\n-\t      gcc_assert (!STMT_VINFO_PATTERN_DEF_SEQ (stmt_def_vinfo));\n-\t      STMT_VINFO_RELATED_STMT (stmt_def_vinfo) = NULL;\n-\t      return irhs1;\n+\t      rhs_code = def_rhs_code;\n+\t      rhs1 = def_rhs1;\n+\t      rhs2 = gimple_assign_rhs2 (def_stmt);\n+\t      trueval = irhs2;\n+\t      goto do_compare;\n \t    }\n \t  else\n-\t    irhs1 = adjust_bool_pattern (rhs1, out_type, NULL_TREE, stmts);\n+\t    irhs1 = *defs.get (rhs1);\n \t  goto and_ior_xor;\n \t}\n       /* FALLTHRU */\n     case BIT_IOR_EXPR:\n     case BIT_XOR_EXPR:\n-      irhs1 = adjust_bool_pattern (rhs1, out_type, NULL_TREE, stmts);\n-      irhs2 = adjust_bool_pattern (rhs2, out_type, NULL_TREE, stmts);\n+      irhs1 = *defs.get (rhs1);\n+      irhs2 = *defs.get (rhs2);\n     and_ior_xor:\n       if (TYPE_PRECISION (TREE_TYPE (irhs1))\n \t  != TYPE_PRECISION (TREE_TYPE (irhs2)))\n@@ -3129,13 +3129,15 @@ adjust_bool_pattern (tree var, tree out_type, tree trueval,\n \t  int prec2 = TYPE_PRECISION (TREE_TYPE (irhs2));\n \t  int out_prec = TYPE_PRECISION (out_type);\n \t  if (absu_hwi (out_prec - prec1) < absu_hwi (out_prec - prec2))\n-\t    irhs2 = adjust_bool_pattern_cast (TREE_TYPE (irhs1), rhs2);\n+\t    irhs2 = adjust_bool_pattern_cast (TREE_TYPE (irhs1), irhs2,\n+\t\t\t\t\t      stmt_info);\n \t  else if (absu_hwi (out_prec - prec1) > absu_hwi (out_prec - prec2))\n-\t    irhs1 = adjust_bool_pattern_cast (TREE_TYPE (irhs2), rhs1);\n+\t    irhs1 = adjust_bool_pattern_cast (TREE_TYPE (irhs2), irhs1,\n+\t\t\t\t\t      stmt_info);\n \t  else\n \t    {\n-\t      irhs1 = adjust_bool_pattern_cast (out_type, rhs1);\n-\t      irhs2 = adjust_bool_pattern_cast (out_type, rhs2);\n+\t      irhs1 = adjust_bool_pattern_cast (out_type, irhs1, stmt_info);\n+\t      irhs2 = adjust_bool_pattern_cast (out_type, irhs2, stmt_info);\n \t    }\n \t}\n       itype = TREE_TYPE (irhs1);\n@@ -3145,6 +3147,7 @@ adjust_bool_pattern (tree var, tree out_type, tree trueval,\n       break;\n \n     default:\n+    do_compare:\n       gcc_assert (TREE_CODE_CLASS (rhs_code) == tcc_comparison);\n       if (TREE_CODE (TREE_TYPE (rhs1)) != INTEGER_TYPE\n \t  || !TYPE_UNSIGNED (TREE_TYPE (rhs1))\n@@ -3170,12 +3173,54 @@ adjust_bool_pattern (tree var, tree out_type, tree trueval,\n       break;\n     }\n \n-  stmts->safe_push (stmt);\n   gimple_set_location (pattern_stmt, loc);\n-  STMT_VINFO_RELATED_STMT (vinfo_for_stmt (stmt)) = pattern_stmt;\n-  return gimple_assign_lhs (pattern_stmt);\n+  /* ???  Why does vect_mark_pattern_stmts set the vector type on all\n+     pattern def seq stmts instead of just letting auto-detection do\n+     its work?  */\n+  stmt_vec_info patt_vinfo = new_stmt_vec_info (pattern_stmt, stmt_info->vinfo);\n+  set_vinfo_for_stmt (pattern_stmt, patt_vinfo);\n+  STMT_VINFO_VECTYPE (patt_vinfo) = get_vectype_for_scalar_type (itype);\n+  append_pattern_def_seq (stmt_info, pattern_stmt);\n+  defs.put (var, gimple_assign_lhs (pattern_stmt));\n+}\n+\n+/* Comparison function to qsort a vector of gimple stmts after UID.  */\n+\n+static int\n+sort_after_uid (const void *p1, const void *p2)\n+{\n+  const gimple *stmt1 = *(const gimple * const *)p1;\n+  const gimple *stmt2 = *(const gimple * const *)p2;\n+  return gimple_uid (stmt1) - gimple_uid (stmt2);\n }\n \n+/* Create pattern stmts for all stmts participating in the bool pattern\n+   specified by BOOL_STMT_SET and its root STMT with the desired type\n+   OUT_TYPE.  Return the def of the pattern root.  */\n+\n+static tree\n+adjust_bool_stmts (hash_set <gimple *> &bool_stmt_set,\n+\t\t   tree out_type, gimple *stmt)\n+{\n+  /* Gather original stmts in the bool pattern in their order of appearance\n+     in the IL.  */\n+  auto_vec<gimple *> bool_stmts (bool_stmt_set.elements ());\n+  for (hash_set <gimple *>::iterator i = bool_stmt_set.begin ();\n+       i != bool_stmt_set.end (); ++i)\n+    bool_stmts.quick_push (*i);\n+  bool_stmts.qsort (sort_after_uid);\n+\n+  /* Now process them in that order, producing pattern stmts.  */\n+  hash_map <tree, tree> defs;\n+  for (unsigned i = 0; i < bool_stmts.length (); ++i)\n+    adjust_bool_pattern (gimple_assign_lhs (bool_stmts[i]),\n+\t\t\t out_type, vinfo_for_stmt (stmt), defs);\n+\n+  /* Pop the last pattern seq stmt and install it as pattern root for STMT.  */\n+  gimple *pattern_stmt\n+    = gimple_seq_last_stmt (STMT_VINFO_PATTERN_DEF_SEQ (vinfo_for_stmt (stmt)));\n+  return gimple_assign_lhs (pattern_stmt);\n+}\n \n /* Return the proper type for converting bool VAR into\n    an integer value or NULL_TREE if no such type exists.\n@@ -3338,6 +3383,8 @@ vect_recog_bool_pattern (vec<gimple *> *stmts, tree *type_in,\n       && TREE_CODE (TREE_TYPE (var)) != BOOLEAN_TYPE)\n     return NULL;\n \n+  hash_set<gimple *> bool_stmts;\n+\n   rhs_code = gimple_assign_rhs_code (last_stmt);\n   if (CONVERT_EXPR_CODE_P (rhs_code))\n     {\n@@ -3348,9 +3395,9 @@ vect_recog_bool_pattern (vec<gimple *> *stmts, tree *type_in,\n       if (vectype == NULL_TREE)\n \treturn NULL;\n \n-      if (check_bool_pattern (var, vinfo))\n+      if (check_bool_pattern (var, vinfo, bool_stmts))\n \t{\n-\t  rhs = adjust_bool_pattern (var, TREE_TYPE (lhs), NULL_TREE, stmts);\n+\t  rhs = adjust_bool_stmts (bool_stmts, TREE_TYPE (lhs), last_stmt);\n \t  lhs = vect_recog_temp_ssa_var (TREE_TYPE (lhs), NULL);\n \t  if (useless_type_conversion_p (TREE_TYPE (lhs), TREE_TYPE (rhs)))\n \t    pattern_stmt = gimple_build_assign (lhs, SSA_NAME, rhs);\n@@ -3420,10 +3467,10 @@ vect_recog_bool_pattern (vec<gimple *> *stmts, tree *type_in,\n       if (get_vectype_for_scalar_type (type) == NULL_TREE)\n \treturn NULL;\n \n-      if (!check_bool_pattern (var, vinfo))\n+      if (!check_bool_pattern (var, vinfo, bool_stmts))\n \treturn NULL;\n \n-      rhs = adjust_bool_pattern (var, type, NULL_TREE, stmts);\n+      rhs = adjust_bool_stmts (bool_stmts, type, last_stmt);\n \n       lhs = vect_recog_temp_ssa_var (TREE_TYPE (lhs), NULL);\n       pattern_stmt \n@@ -3450,9 +3497,8 @@ vect_recog_bool_pattern (vec<gimple *> *stmts, tree *type_in,\n       if (!VECTOR_MODE_P (TYPE_MODE (vectype)))\n \treturn NULL;\n \n-      if (check_bool_pattern (var, vinfo))\n-\trhs = adjust_bool_pattern (var, TREE_TYPE (vectype),\n-\t\t\t\t   NULL_TREE, stmts);\n+      if (check_bool_pattern (var, vinfo, bool_stmts))\n+\trhs = adjust_bool_stmts (bool_stmts, TREE_TYPE (vectype), last_stmt);\n       else\n \t{\n \t  tree type = search_type_for_mask (var, vinfo);"}]}