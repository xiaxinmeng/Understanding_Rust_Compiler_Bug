{"sha": "c6fe3827dfa59a94a270eacfac1fedfb824a3d1a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YzZmZTM4MjdkZmE1OWE5NGEyNzBlYWNmYWMxZmVkZmI4MjRhM2QxYQ==", "commit": {"author": {"name": "Gary Dismukes", "email": "dismukes@adacore.com", "date": "2007-08-16T12:20:13Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2007-08-16T12:20:13Z"}, "message": "sem_ch3.adb (OK_For_Limited_Init_In_05): Allow calls to 'Input to initialize a limited object.\n\n2007-08-16  Gary Dismukes  <dismukes@adacore.com>\n\t    Javier Miranda  <miranda@adacore.com>\n\n\t* sem_ch3.adb (OK_For_Limited_Init_In_05): Allow calls to 'Input to\n\tinitialize a limited object.\n\t(Build_Derived_Record_Type): Add missing check of rules ARM 3.9.4\n\t13/2 and 14/2.\n\tMake sure Has_Complex_Representation is inherited by derived type.\n\nFrom-SVN: r127547", "tree": {"sha": "fa04397f0438b2109f39dea76743ff6979ab62d4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/fa04397f0438b2109f39dea76743ff6979ab62d4"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c6fe3827dfa59a94a270eacfac1fedfb824a3d1a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c6fe3827dfa59a94a270eacfac1fedfb824a3d1a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c6fe3827dfa59a94a270eacfac1fedfb824a3d1a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c6fe3827dfa59a94a270eacfac1fedfb824a3d1a/comments", "author": {"login": "dismukes", "id": 50880541, "node_id": "MDQ6VXNlcjUwODgwNTQx", "avatar_url": "https://avatars.githubusercontent.com/u/50880541?v=4", "gravatar_id": "", "url": "https://api.github.com/users/dismukes", "html_url": "https://github.com/dismukes", "followers_url": "https://api.github.com/users/dismukes/followers", "following_url": "https://api.github.com/users/dismukes/following{/other_user}", "gists_url": "https://api.github.com/users/dismukes/gists{/gist_id}", "starred_url": "https://api.github.com/users/dismukes/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/dismukes/subscriptions", "organizations_url": "https://api.github.com/users/dismukes/orgs", "repos_url": "https://api.github.com/users/dismukes/repos", "events_url": "https://api.github.com/users/dismukes/events{/privacy}", "received_events_url": "https://api.github.com/users/dismukes/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "369925233a003cf92489080ed0a0bcb94629b08b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/369925233a003cf92489080ed0a0bcb94629b08b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/369925233a003cf92489080ed0a0bcb94629b08b"}], "stats": {"total": 157, "additions": 95, "deletions": 62}, "files": [{"sha": "5b66982567bb057556c8d19df94491cf6b61df48", "filename": "gcc/ada/sem_ch3.adb", "status": "modified", "additions": 95, "deletions": 62, "changes": 157, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c6fe3827dfa59a94a270eacfac1fedfb824a3d1a/gcc%2Fada%2Fsem_ch3.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c6fe3827dfa59a94a270eacfac1fedfb824a3d1a/gcc%2Fada%2Fsem_ch3.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch3.adb?ref=c6fe3827dfa59a94a270eacfac1fedfb824a3d1a", "patch": "@@ -4148,19 +4148,19 @@ package body Sem_Ch3 is\n          end;\n       end if;\n \n-      --  Create a concatenation operator for the new type. Internal\n-      --  array types created for packed entities do not need such, they\n-      --  are compatible with the user-defined type.\n+      --  Create a concatenation operator for the new type. Internal array\n+      --  types created for packed entities do not need such, they are\n+      --  compatible with the user-defined type.\n \n       if Number_Dimensions (T) = 1\n          and then not Is_Packed_Array_Type (T)\n       then\n          New_Concatenation_Op (T);\n       end if;\n \n-      --  In the case of an unconstrained array the parser has already\n-      --  verified that all the indices are unconstrained but we still\n-      --  need to make sure that the element type is constrained.\n+      --  In the case of an unconstrained array the parser has already verified\n+      --  that all the indices are unconstrained but we still need to make sure\n+      --  that the element type is constrained.\n \n       if Is_Indefinite_Subtype (Element_Type) then\n          Error_Msg_N\n@@ -4180,7 +4180,7 @@ package body Sem_Ch3 is\n    ------------------------------------------------------\n \n    function Replace_Anonymous_Access_To_Protected_Subprogram\n-     (N      : Node_Id) return Entity_Id\n+     (N : Node_Id) return Entity_Id\n    is\n       Loc : constant Source_Ptr := Sloc (N);\n \n@@ -4311,9 +4311,9 @@ package body Sem_Ch3 is\n       Subt            : Entity_Id;\n \n    begin\n-      --  Set the designated type so it is available in case this is\n-      --  an access to a self-referential type, e.g. a standard list\n-      --  type with a next pointer. Will be reset after subtype is built.\n+      --  Set the designated type so it is available in case this is an access\n+      --  to a self-referential type, e.g. a standard list type with a next\n+      --  pointer. Will be reset after subtype is built.\n \n       Set_Directly_Designated_Type\n         (Derived_Type, Designated_Type (Parent_Type));\n@@ -4370,8 +4370,8 @@ package body Sem_Ch3 is\n          Set_Can_Never_Be_Null (Derived_Type);\n       end if;\n \n-      --  Note: we do not copy the Storage_Size_Variable, since\n-      --  we always go to the root type for this information.\n+      --  Note: we do not copy the Storage_Size_Variable, since we always go to\n+      --  the root type for this information.\n \n       --  Apply range checks to discriminants for derived record case\n       --  ??? THIS CODE SHOULD NOT BE HERE REALLY.\n@@ -4411,8 +4411,8 @@ package body Sem_Ch3 is\n       New_Indic     : Node_Id;\n \n       procedure Make_Implicit_Base;\n-      --  If the parent subtype is constrained, the derived type is a\n-      --  subtype of an implicit base type derived from the parent base.\n+      --  If the parent subtype is constrained, the derived type is a subtype\n+      --  of an implicit base type derived from the parent base.\n \n       ------------------------\n       -- Make_Implicit_Base --\n@@ -4720,13 +4720,12 @@ package body Sem_Ch3 is\n             Analyze (High_Bound (Range_Expression (Constraint (Indic))));\n          end if;\n \n-         --  Introduce an implicit base type for the derived type even\n-         --  if there is no constraint attached to it, since this seems\n-         --  closer to the Ada semantics. Build a full type declaration\n-         --  tree for the derived type using the implicit base type as\n-         --  the defining identifier. The build a subtype declaration\n-         --  tree which applies the constraint (if any) have it replace\n-         --  the derived type declaration.\n+         --  Introduce an implicit base type for the derived type even if there\n+         --  is no constraint attached to it, since this seems closer to the\n+         --  Ada semantics. Build a full type declaration tree for the derived\n+         --  type using the implicit base type as the defining identifier. The\n+         --  build a subtype declaration tree which applies the constraint (if\n+         --  any) have it replace the derived type declaration.\n \n          Literal := First_Literal (Parent_Type);\n          Literals_List := New_List;\n@@ -4762,10 +4761,10 @@ package body Sem_Ch3 is\n            Make_Defining_Identifier (Sloc (Derived_Type),\n              New_External_Name (Chars (Derived_Type), 'B'));\n \n-         --  Indicate the proper nature of the derived type. This must\n-         --  be done before analysis of the literals, to recognize cases\n-         --  when a literal may be hidden by a previous explicit function\n-         --  definition (cf. c83031a).\n+         --  Indicate the proper nature of the derived type. This must be done\n+         --  before analysis of the literals, to recognize cases when a literal\n+         --  may be hidden by a previous explicit function definition (cf.\n+         --  c83031a).\n \n          Set_Ekind (Derived_Type, E_Enumeration_Subtype);\n          Set_Etype (Derived_Type, Implicit_Base);\n@@ -4796,9 +4795,9 @@ package body Sem_Ch3 is\n                                                            (Parent_Type));\n          Set_Has_Delayed_Freeze (Implicit_Base);\n \n-         --  Process the subtype indication including a validation check\n-         --  on the constraint, if any. If a constraint is given, its bounds\n-         --  must be implicitly converted to the new type.\n+         --  Process the subtype indication including a validation check on the\n+         --  constraint, if any. If a constraint is given, its bounds must be\n+         --  implicitly converted to the new type.\n \n          if Nkind (Indic) = N_Subtype_Indication then\n             declare\n@@ -4813,9 +4812,9 @@ package body Sem_Ch3 is\n                           (Low_Bound  (R), Parent_Type, Implicit_Base);\n \n                else\n-                  --  Constraint is a Range attribute. Replace with the\n-                  --  explicit mention of the bounds of the prefix, which must\n-                  --  be a subtype.\n+                  --  Constraint is a Range attribute. Replace with explicit\n+                  --  mention of the bounds of the prefix, which must be a\n+                  --  subtype.\n \n                   Analyze (Prefix (R));\n                   Hi :=\n@@ -4872,8 +4871,8 @@ package body Sem_Ch3 is\n \n          Analyze (N);\n \n-         --  If pragma Discard_Names applies on the first subtype of the\n-         --  parent type, then it must be applied on this subtype as well.\n+         --  If pragma Discard_Names applies on the first subtype of the parent\n+         --  type, then it must be applied on this subtype as well.\n \n          if Einfo.Discard_Names (First_Subtype (Parent_Type)) then\n             Set_Discard_Names (Derived_Type);\n@@ -5916,27 +5915,27 @@ package body Sem_Ch3 is\n       Last_Discrim : Entity_Id;\n       Constrs      : Elist_Id;\n \n-      Discs        : Elist_Id := New_Elmt_List;\n+      Discs : Elist_Id := New_Elmt_List;\n       --  An empty Discs list means that there were no constraints in the\n       --  subtype indication or that there was an error processing it.\n \n-      Assoc_List         : Elist_Id;\n-      New_Discrs         : Elist_Id;\n-      New_Base           : Entity_Id;\n-      New_Decl           : Node_Id;\n-      New_Indic          : Node_Id;\n+      Assoc_List : Elist_Id;\n+      New_Discrs : Elist_Id;\n+      New_Base   : Entity_Id;\n+      New_Decl   : Node_Id;\n+      New_Indic  : Node_Id;\n \n       Is_Tagged          : constant Boolean := Is_Tagged_Type (Parent_Type);\n       Discriminant_Specs : constant Boolean :=\n                              Present (Discriminant_Specifications (N));\n       Private_Extension  : constant Boolean :=\n                              (Nkind (N) = N_Private_Extension_Declaration);\n \n-      Constraint_Present     : Boolean;\n-      Inherit_Discrims       : Boolean := False;\n-      Save_Etype             : Entity_Id;\n-      Save_Discr_Constr      : Elist_Id;\n-      Save_Next_Entity       : Entity_Id;\n+      Constraint_Present : Boolean;\n+      Inherit_Discrims   : Boolean := False;\n+      Save_Etype         : Entity_Id;\n+      Save_Discr_Constr  : Elist_Id;\n+      Save_Next_Entity   : Entity_Id;\n \n    begin\n       if Ekind (Parent_Type) = E_Record_Type_With_Private\n@@ -5982,7 +5981,7 @@ package body Sem_Ch3 is\n       else\n          Type_Def := Type_Definition (N);\n \n-         --  Ekind (Parent_Base) in not necessarily E_Record_Type since\n+         --  Ekind (Parent_Base) is not necessarily E_Record_Type since\n          --  Parent_Base can be a private type or private extension. However,\n          --  for tagged types with an extension the newly added fields are\n          --  visible and hence the Derived_Type is always an E_Record_Type.\n@@ -6527,13 +6526,13 @@ package body Sem_Ch3 is\n       --  Fields inherited from the Parent_Type\n \n       Set_Discard_Names\n-        (Derived_Type, Einfo.Discard_Names      (Parent_Type));\n+        (Derived_Type, Einfo.Discard_Names  (Parent_Type));\n       Set_Has_Specified_Layout\n-        (Derived_Type, Has_Specified_Layout     (Parent_Type));\n+        (Derived_Type, Has_Specified_Layout (Parent_Type));\n       Set_Is_Limited_Composite\n-        (Derived_Type, Is_Limited_Composite     (Parent_Type));\n+        (Derived_Type, Is_Limited_Composite (Parent_Type));\n       Set_Is_Private_Composite\n-        (Derived_Type, Is_Private_Composite     (Parent_Type));\n+        (Derived_Type, Is_Private_Composite (Parent_Type));\n \n       --  Fields inherited from the Parent_Base\n \n@@ -6544,9 +6543,16 @@ package body Sem_Ch3 is\n       Set_Has_Primitive_Operations\n         (Derived_Type, Has_Primitive_Operations (Parent_Base));\n \n+      --  For non-private case, we also inherit Has_Complex_Representation\n+\n+      if Ekind (Derived_Type) = E_Record_Type then\n+         Set_Has_Complex_Representation\n+           (Derived_Type, Has_Complex_Representation (Parent_Base));\n+      end if;\n+\n       --  Direct controlled types do not inherit Finalize_Storage_Only flag\n \n-      if not Is_Controlled  (Parent_Type) then\n+      if not Is_Controlled (Parent_Type) then\n          Set_Finalize_Storage_Only\n            (Derived_Type, Finalize_Storage_Only (Parent_Type));\n       end if;\n@@ -6608,7 +6614,27 @@ package body Sem_Ch3 is\n          if Ada_Version >= Ada_05 then\n             declare\n                Ifaces_List : Elist_Id;\n+\n             begin\n+               --  Checks rules 3.9.4 (13/2 and 14/2)\n+\n+               if Comes_From_Source (Derived_Type)\n+                 and then not Is_Private_Type (Derived_Type)\n+                 and then Is_Interface (Parent_Type)\n+                 and then not Is_Interface (Derived_Type)\n+               then\n+                  if Is_Task_Interface (Parent_Type) then\n+                     Error_Msg_N\n+                       (\"(Ada 2005) task type required (RM 3.9.4 (13.2))\",\n+                        Derived_Type);\n+\n+                  elsif Is_Protected_Interface (Parent_Type) then\n+                     Error_Msg_N\n+                       (\"(Ada 2005) protected type required (RM 3.9.4 (14.2))\",\n+                        Derived_Type);\n+                  end if;\n+               end if;\n+\n                --  Check ARM rules 3.9.4 (15/2), 9.1 (9.d/2) and 9.4 (11.d/2)\n \n                Check_Abstract_Interfaces (N, Type_Def);\n@@ -6820,16 +6846,16 @@ package body Sem_Ch3 is\n    begin\n       --  Set common attributes\n \n-      Set_Scope          (Derived_Type, Current_Scope);\n+      Set_Scope         (Derived_Type, Current_Scope);\n \n-      Set_Ekind          (Derived_Type, Ekind     (Parent_Base));\n-      Set_Etype          (Derived_Type,            Parent_Base);\n-      Set_Has_Task       (Derived_Type, Has_Task  (Parent_Base));\n+      Set_Ekind         (Derived_Type, Ekind    (Parent_Base));\n+      Set_Etype         (Derived_Type,           Parent_Base);\n+      Set_Has_Task      (Derived_Type, Has_Task (Parent_Base));\n \n-      Set_Size_Info      (Derived_Type,                 Parent_Type);\n-      Set_RM_Size        (Derived_Type, RM_Size        (Parent_Type));\n-      Set_Convention     (Derived_Type, Convention     (Parent_Type));\n-      Set_Is_Controlled  (Derived_Type, Is_Controlled  (Parent_Type));\n+      Set_Size_Info     (Derived_Type,                Parent_Type);\n+      Set_RM_Size       (Derived_Type, RM_Size       (Parent_Type));\n+      Set_Convention    (Derived_Type, Convention    (Parent_Type));\n+      Set_Is_Controlled (Derived_Type, Is_Controlled (Parent_Type));\n \n       --  The derived type inherits the representation clauses of the parent.\n       --  However, for a private type that is completed by a derivation, there\n@@ -14200,17 +14226,17 @@ package body Sem_Ch3 is\n          return True;\n       end if;\n \n-      --  Ada 2005 (AI-287, AI-318): Relax the strictness of the front-end in\n-      --  case of limited aggregates (including extension aggregates),\n-      --  and function calls. The function call may have been give in prefixed\n+      --  Ada 2005 (AI-287, AI-318): Relax the strictness of the front end in\n+      --  case of limited aggregates (including extension aggregates), and\n+      --  function calls. The function call may have been give in prefixed\n       --  notation, in which case the original node is an indexed component.\n \n       case Nkind (Original_Node (Exp)) is\n          when N_Aggregate | N_Extension_Aggregate | N_Function_Call | N_Op =>\n             return True;\n \n          --  Ada 2005 (AI-251): If a class-wide interface object is initialized\n-         --  with a function call, the expander has rewriten the call into an\n+         --  with a function call, the expander has rewritten the call into an\n          --  N_Type_Conversion node to force displacement of the pointer to\n          --  reference the component containing the secondary dispatch table.\n \n@@ -14221,6 +14247,13 @@ package body Sem_Ch3 is\n          when N_Indexed_Component | N_Selected_Component  =>\n             return Nkind (Exp) = N_Function_Call;\n \n+         --  A use of 'Input is a function call, hence allowed. Normally the\n+         --  attribute will be changed to a call, but the attribute by itself\n+         --  can occur with -gnatc.\n+\n+         when N_Attribute_Reference =>\n+            return Attribute_Name (Original_Node (Exp)) = Name_Input;\n+\n          when others =>\n             return False;\n       end case;"}]}