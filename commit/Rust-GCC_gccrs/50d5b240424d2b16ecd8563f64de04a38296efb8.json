{"sha": "50d5b240424d2b16ecd8563f64de04a38296efb8", "node_id": "C_kwDOANBUbNoAKDUwZDViMjQwNDI0ZDJiMTZlY2Q4NTYzZjY0ZGUwNGEzODI5NmVmYjg", "commit": {"author": {"name": "David Malcolm", "email": "dmalcolm@redhat.com", "date": "2022-11-24T01:43:32Z"}, "committer": {"name": "David Malcolm", "email": "dmalcolm@redhat.com", "date": "2022-11-24T01:43:32Z"}, "message": "analyzer: move known funs for fds to sm-fd.cc\n\nThis mostly mechanical change enables a simplification in the\nfollowup patch.  No functional change intended.\n\ngcc/analyzer/ChangeLog:\n\t* analyzer.h (register_known_fd_functions): New decl.\n\t* region-model-impl-calls.cc (class kf_accept): Move to sm-fd.cc.\n\t(class kf_bind): Likewise.\n\t(class kf_connect): Likewise.\n\t(class kf_listen): Likewise.\n\t(class kf_pipe): Likewise.\n\t(class kf_socket): Likewise.\n\t(register_known_functions): Remove registration of the above\n\tfunctions, instead calling register_known_fd_functions.\n\t* sm-fd.cc: Include \"analyzer/call-info.h\".\n\t(class kf_socket): Move here from region-model-impl-calls.cc.\n\t(class kf_bind): Likewise.\n\t(class kf_listen): Likewise.\n\t(class kf_accept): Likewise.\n\t(class kf_connect): Likewise.\n\t(class kf_pipe): Likewise.\n\t(register_known_fd_functions): New.\n\nSigned-off-by: David Malcolm <dmalcolm@redhat.com>", "tree": {"sha": "18828ef4eec9db7f7d1a077398d299c773e406fa", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/18828ef4eec9db7f7d1a077398d299c773e406fa"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/50d5b240424d2b16ecd8563f64de04a38296efb8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/50d5b240424d2b16ecd8563f64de04a38296efb8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/50d5b240424d2b16ecd8563f64de04a38296efb8", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/50d5b240424d2b16ecd8563f64de04a38296efb8/comments", "author": {"login": "davidmalcolm", "id": 1553248, "node_id": "MDQ6VXNlcjE1NTMyNDg=", "avatar_url": "https://avatars.githubusercontent.com/u/1553248?v=4", "gravatar_id": "", "url": "https://api.github.com/users/davidmalcolm", "html_url": "https://github.com/davidmalcolm", "followers_url": "https://api.github.com/users/davidmalcolm/followers", "following_url": "https://api.github.com/users/davidmalcolm/following{/other_user}", "gists_url": "https://api.github.com/users/davidmalcolm/gists{/gist_id}", "starred_url": "https://api.github.com/users/davidmalcolm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/davidmalcolm/subscriptions", "organizations_url": "https://api.github.com/users/davidmalcolm/orgs", "repos_url": "https://api.github.com/users/davidmalcolm/repos", "events_url": "https://api.github.com/users/davidmalcolm/events{/privacy}", "received_events_url": "https://api.github.com/users/davidmalcolm/received_events", "type": "User", "site_admin": false}, "committer": {"login": "davidmalcolm", "id": 1553248, "node_id": "MDQ6VXNlcjE1NTMyNDg=", "avatar_url": "https://avatars.githubusercontent.com/u/1553248?v=4", "gravatar_id": "", "url": "https://api.github.com/users/davidmalcolm", "html_url": "https://github.com/davidmalcolm", "followers_url": "https://api.github.com/users/davidmalcolm/followers", "following_url": "https://api.github.com/users/davidmalcolm/following{/other_user}", "gists_url": "https://api.github.com/users/davidmalcolm/gists{/gist_id}", "starred_url": "https://api.github.com/users/davidmalcolm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/davidmalcolm/subscriptions", "organizations_url": "https://api.github.com/users/davidmalcolm/orgs", "repos_url": "https://api.github.com/users/davidmalcolm/repos", "events_url": "https://api.github.com/users/davidmalcolm/events{/privacy}", "received_events_url": "https://api.github.com/users/davidmalcolm/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8caf155a3d6e23e47bf55068ad23c23d4655a054", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8caf155a3d6e23e47bf55068ad23c23d4655a054", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8caf155a3d6e23e47bf55068ad23c23d4655a054"}], "stats": {"total": 580, "additions": 296, "deletions": 284}, "files": [{"sha": "4fbe092199f35c7e97092ed733e51c640ef1ca64", "filename": "gcc/analyzer/analyzer.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/50d5b240424d2b16ecd8563f64de04a38296efb8/gcc%2Fanalyzer%2Fanalyzer.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/50d5b240424d2b16ecd8563f64de04a38296efb8/gcc%2Fanalyzer%2Fanalyzer.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fanalyzer.h?ref=50d5b240424d2b16ecd8563f64de04a38296efb8", "patch": "@@ -258,6 +258,7 @@ class internal_known_function : public known_function\n };\n \n extern void register_known_functions (known_function_manager &mgr);\n+extern void register_known_fd_functions (known_function_manager &kfm);\n extern void register_varargs_builtins (known_function_manager &kfm);\n \n /* Passed by pointer to PLUGIN_ANALYZER_INIT callbacks.  */"}, {"sha": "d3f2bf8240b0c8c15736e1c71db77aebbe4316bb", "filename": "gcc/analyzer/region-model-impl-calls.cc", "status": "modified", "additions": 2, "deletions": 284, "changes": 286, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/50d5b240424d2b16ecd8563f64de04a38296efb8/gcc%2Fanalyzer%2Fregion-model-impl-calls.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/50d5b240424d2b16ecd8563f64de04a38296efb8/gcc%2Fanalyzer%2Fregion-model-impl-calls.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fregion-model-impl-calls.cc?ref=50d5b240424d2b16ecd8563f64de04a38296efb8", "patch": "@@ -595,83 +595,6 @@ class kf_analyzer_get_unknown_ptr : public known_function\n   }\n };\n \n-/* Handle calls to \"accept\".\n-   See e.g. https://man7.org/linux/man-pages/man3/accept.3p.html  */\n-\n-class kf_accept : public known_function\n-{\n-  class outcome_of_accept : public succeed_or_fail_call_info\n-  {\n-  public:\n-    outcome_of_accept (const call_details &cd, bool success)\n-    : succeed_or_fail_call_info (cd, success)\n-    {}\n-\n-    bool update_model (region_model *model,\n-\t\t       const exploded_edge *,\n-\t\t       region_model_context *ctxt) const final override\n-    {\n-      const call_details cd (get_call_details (model, ctxt));\n-      return cd.get_model ()->on_accept (cd, m_success);\n-    }\n-  };\n-\n-  bool matches_call_types_p (const call_details &cd) const final override\n-  {\n-    return (cd.num_args () == 3\n-\t    && cd.arg_is_pointer_p (1)\n-\t    && cd.arg_is_pointer_p (2));\n-  }\n-\n-  void impl_call_post (const call_details &cd) const final override\n-  {\n-    if (cd.get_ctxt ())\n-      {\n-\tcd.get_ctxt ()->bifurcate (make_unique<outcome_of_accept> (cd, false));\n-\tcd.get_ctxt ()->bifurcate (make_unique<outcome_of_accept> (cd, true));\n-\tcd.get_ctxt ()->terminate_path ();\n-      }\n-  }\n-};\n-\n-/* Handle calls to \"bind\".\n-   See e.g. https://man7.org/linux/man-pages/man3/bind.3p.html  */\n-\n-class kf_bind : public known_function\n-{\n-public:\n-  class outcome_of_bind : public succeed_or_fail_call_info\n-  {\n-  public:\n-    outcome_of_bind (const call_details &cd, bool success)\n-    : succeed_or_fail_call_info (cd, success)\n-    {}\n-\n-    bool update_model (region_model *model,\n-\t\t       const exploded_edge *,\n-\t\t       region_model_context *ctxt) const final override\n-    {\n-      const call_details cd (get_call_details (model, ctxt));\n-      return cd.get_model ()->on_bind (cd, m_success);\n-    }\n-  };\n-\n-  bool matches_call_types_p (const call_details &cd) const final override\n-  {\n-    return (cd.num_args () == 3 && cd.arg_is_pointer_p (1));\n-  }\n-\n-  void impl_call_post (const call_details &cd) const final override\n-  {\n-    if (cd.get_ctxt ())\n-      {\n-\tcd.get_ctxt ()->bifurcate (make_unique<outcome_of_bind> (cd, false));\n-\tcd.get_ctxt ()->bifurcate (make_unique<outcome_of_bind> (cd, true));\n-\tcd.get_ctxt ()->terminate_path ();\n-      }\n-  }\n-};\n-\n /* Handler for \"__builtin_expect\" etc.  */\n \n class kf_expect : public internal_known_function\n@@ -723,45 +646,6 @@ kf_calloc::impl_call_pre (const call_details &cd) const\n     }\n }\n \n-/* Handle calls to \"connect\".\n-   See e.g. https://man7.org/linux/man-pages/man3/connect.3p.html  */\n-\n-class kf_connect : public known_function\n-{\n-public:\n-  class outcome_of_connect : public succeed_or_fail_call_info\n-  {\n-  public:\n-    outcome_of_connect (const call_details &cd, bool success)\n-    : succeed_or_fail_call_info (cd, success)\n-    {}\n-\n-    bool update_model (region_model *model,\n-\t\t       const exploded_edge *,\n-\t\t       region_model_context *ctxt) const final override\n-    {\n-      const call_details cd (get_call_details (model, ctxt));\n-      return cd.get_model ()->on_connect (cd, m_success);\n-    }\n-  };\n-\n-  bool matches_call_types_p (const call_details &cd) const final override\n-  {\n-    return (cd.num_args () == 3\n-\t    && cd.arg_is_pointer_p (1));\n-  }\n-\n-  void impl_call_post (const call_details &cd) const final override\n-  {\n-    if (cd.get_ctxt ())\n-      {\n-\tcd.get_ctxt ()->bifurcate (make_unique<outcome_of_connect> (cd, false));\n-\tcd.get_ctxt ()->bifurcate (make_unique<outcome_of_connect> (cd, true));\n-\tcd.get_ctxt ()->terminate_path ();\n-      }\n-  }\n-};\n-\n /* Handler for glibc's \"__errno_location\".  */\n \n class kf_errno_location : public known_function\n@@ -933,43 +817,6 @@ class kf_getchar : public known_function\n      for the analyzer).  */\n };\n \n-/* Handle calls to \"listen\".\n-   See e.g. https://man7.org/linux/man-pages/man3/listen.3p.html  */\n-\n-class kf_listen : public known_function\n-{\n-  class outcome_of_listen : public succeed_or_fail_call_info\n-  {\n-  public:\n-    outcome_of_listen (const call_details &cd, bool success)\n-    : succeed_or_fail_call_info (cd, success)\n-    {}\n-\n-    bool update_model (region_model *model,\n-\t\t       const exploded_edge *,\n-\t\t       region_model_context *ctxt) const final override\n-    {\n-      const call_details cd (get_call_details (model, ctxt));\n-      return cd.get_model ()->on_listen (cd, m_success);\n-    }\n-  };\n-\n-  bool matches_call_types_p (const call_details &cd) const final override\n-  {\n-    return cd.num_args () == 2;\n-  }\n-\n-  void impl_call_post (const call_details &cd) const final override\n-  {\n-    if (cd.get_ctxt ())\n-      {\n-\tcd.get_ctxt ()->bifurcate (make_unique<outcome_of_listen> (cd, false));\n-\tcd.get_ctxt ()->bifurcate (make_unique<outcome_of_listen> (cd, true));\n-\tcd.get_ctxt ()->terminate_path ();\n-      }\n-  }\n-};\n-\n /* Handle the on_call_pre part of \"malloc\".  */\n \n class kf_malloc : public known_function\n@@ -1077,92 +924,6 @@ kf_memset::impl_call_pre (const call_details &cd) const\n   model->fill_region (sized_dest_reg, fill_value_u8);\n }\n \n-/* Handler for calls to \"pipe\" and \"pipe2\".\n-   See e.g. https://www.man7.org/linux/man-pages/man2/pipe.2.html  */\n-\n-class kf_pipe : public known_function\n-{\n-  class failure : public failed_call_info\n-  {\n-  public:\n-    failure (const call_details &cd) : failed_call_info (cd) {}\n-\n-    bool update_model (region_model *model,\n-\t\t       const exploded_edge *,\n-\t\t       region_model_context *ctxt) const final override\n-    {\n-      /* Return -1; everything else is unchanged.  */\n-      const call_details cd (get_call_details (model, ctxt));\n-      model->update_for_int_cst_return (cd, -1, true);\n-      return true;\n-    }\n-  };\n-\n-  class success : public success_call_info\n-  {\n-  public:\n-    success (const call_details &cd) : success_call_info (cd) {}\n-\n-    bool update_model (region_model *model,\n-\t\t       const exploded_edge *,\n-\t\t       region_model_context *ctxt) const final override\n-    {\n-      const call_details cd (get_call_details (model, ctxt));\n-\n-      /* Return 0.  */\n-      model->update_for_zero_return (cd, true);\n-\n-      /* Update fd array.  */\n-      region_model_manager *mgr = cd.get_manager ();\n-      tree arr_tree = cd.get_arg_tree (0);\n-      const svalue *arr_sval = cd.get_arg_svalue (0);\n-      for (int idx = 0; idx < 2; idx++)\n-\t{\n-\t  const region *arr_reg\n-\t    = model->deref_rvalue (arr_sval, arr_tree, cd.get_ctxt ());\n-\t  const svalue *idx_sval\n-\t    = mgr->get_or_create_int_cst (integer_type_node, idx);\n-\t  const region *element_reg\n-\t    = mgr->get_element_region (arr_reg, integer_type_node, idx_sval);\n-\t  conjured_purge p (model, cd.get_ctxt ());\n-\t  const svalue *fd_sval\n-\t    = mgr->get_or_create_conjured_svalue (integer_type_node,\n-\t\t\t\t\t\t  cd.get_call_stmt (),\n-\t\t\t\t\t\t  element_reg,\n-\t\t\t\t\t\t  p);\n-\t  model->set_value (element_reg, fd_sval, cd.get_ctxt ());\n-\t  model->mark_as_valid_fd (fd_sval, cd.get_ctxt ());\n-\t}\n-      return true;\n-    }\n-  };\n-\n-public:\n-  kf_pipe (unsigned num_args)\n-  : m_num_args (num_args)\n-  {\n-    gcc_assert (num_args > 0);\n-  }\n-\n-  bool matches_call_types_p (const call_details &cd) const final override\n-  {\n-    return (cd.num_args () == m_num_args && cd.arg_is_pointer_p (0));\n-  }\n-\n-  void impl_call_post (const call_details &cd) const final override\n-  {\n-    if (cd.get_ctxt ())\n-      {\n-\tcd.get_ctxt ()->bifurcate (make_unique<failure> (cd));\n-\tcd.get_ctxt ()->bifurcate (make_unique<success> (cd));\n-\tcd.get_ctxt ()->terminate_path ();\n-      }\n-  }\n-\n-private:\n-  unsigned m_num_args;\n-};\n-\n /* A subclass of pending_diagnostic for complaining about 'putenv'\n    called on an auto var.  */\n \n@@ -1587,44 +1348,6 @@ kf_realloc::impl_call_post (const call_details &cd) const\n     }\n }\n \n-/* Handle calls to \"socket\".\n-   See e.g. https://man7.org/linux/man-pages/man3/socket.3p.html  */\n-\n-class kf_socket : public known_function\n-{\n-public:\n-  class outcome_of_socket : public succeed_or_fail_call_info\n-  {\n-  public:\n-    outcome_of_socket (const call_details &cd, bool success)\n-    : succeed_or_fail_call_info (cd, success)\n-    {}\n-\n-    bool update_model (region_model *model,\n-\t\t       const exploded_edge *,\n-\t\t       region_model_context *ctxt) const final override\n-    {\n-      const call_details cd (get_call_details (model, ctxt));\n-      return cd.get_model ()->on_socket (cd, m_success);\n-    }\n-  };\n-\n-  bool matches_call_types_p (const call_details &cd) const final override\n-  {\n-    return cd.num_args () == 3;\n-  }\n-\n-  void impl_call_post (const call_details &cd) const final override\n-  {\n-    if (cd.get_ctxt ())\n-      {\n-\tcd.get_ctxt ()->bifurcate (make_unique<outcome_of_socket> (cd, false));\n-\tcd.get_ctxt ()->bifurcate (make_unique<outcome_of_socket> (cd, true));\n-\tcd.get_ctxt ()->terminate_path ();\n-      }\n-  }\n-};\n-\n /* Handler for \"strchr\" and \"__builtin_strchr\".  */\n \n class kf_strchr : public known_function\n@@ -1933,17 +1656,12 @@ register_known_functions (known_function_manager &kfm)\n \n   /* Known POSIX functions, and some non-standard extensions.  */\n   {\n-    kfm.add (\"accept\", make_unique<kf_accept> ());\n-    kfm.add (\"bind\", make_unique<kf_bind> ());\n-    kfm.add (\"connect\", make_unique<kf_connect> ());\n     kfm.add (\"fgets\", make_unique<kf_fgets> ());\n     kfm.add (\"fgets_unlocked\", make_unique<kf_fgets> ()); // non-standard\n     kfm.add (\"fread\", make_unique<kf_fread> ());\n-    kfm.add (\"listen\", make_unique<kf_listen> ());\n-    kfm.add (\"pipe\", make_unique<kf_pipe> (1));\n-    kfm.add (\"pipe2\", make_unique<kf_pipe> (2));\n     kfm.add (\"putenv\", make_unique<kf_putenv> ());\n-    kfm.add (\"socket\", make_unique<kf_socket> ());\n+\n+    register_known_fd_functions (kfm);\n   }\n \n   /* glibc functions.  */"}, {"sha": "af59aef401d5727411a75e2d6cfa783f3950b43d", "filename": "gcc/analyzer/sm-fd.cc", "status": "modified", "additions": 293, "deletions": 0, "changes": 293, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/50d5b240424d2b16ecd8563f64de04a38296efb8/gcc%2Fanalyzer%2Fsm-fd.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/50d5b240424d2b16ecd8563f64de04a38296efb8/gcc%2Fanalyzer%2Fsm-fd.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fsm-fd.cc?ref=50d5b240424d2b16ecd8563f64de04a38296efb8", "patch": "@@ -47,6 +47,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"analyzer/program-state.h\"\n #include \"analyzer/supergraph.h\"\n #include \"analyzer/analyzer-language.h\"\n+#include \"analyzer/call-info.h\"\n \n #if ENABLE_ANALYZER\n \n@@ -2251,6 +2252,44 @@ region_model::mark_as_valid_fd (const svalue *sval, region_model_context *ctxt)\n   fd_sm->mark_as_valid_fd (this, smap, sval, *ext_state);\n }\n \n+/* Handle calls to \"socket\".\n+   See e.g. https://man7.org/linux/man-pages/man3/socket.3p.html  */\n+\n+class kf_socket : public known_function\n+{\n+public:\n+  class outcome_of_socket : public succeed_or_fail_call_info\n+  {\n+  public:\n+    outcome_of_socket (const call_details &cd, bool success)\n+    : succeed_or_fail_call_info (cd, success)\n+    {}\n+\n+    bool update_model (region_model *model,\n+\t\t       const exploded_edge *,\n+\t\t       region_model_context *ctxt) const final override\n+    {\n+      const call_details cd (get_call_details (model, ctxt));\n+      return cd.get_model ()->on_socket (cd, m_success);\n+    }\n+  };\n+\n+  bool matches_call_types_p (const call_details &cd) const final override\n+  {\n+    return cd.num_args () == 3;\n+  }\n+\n+  void impl_call_post (const call_details &cd) const final override\n+  {\n+    if (cd.get_ctxt ())\n+      {\n+\tcd.get_ctxt ()->bifurcate (make_unique<outcome_of_socket> (cd, false));\n+\tcd.get_ctxt ()->bifurcate (make_unique<outcome_of_socket> (cd, true));\n+\tcd.get_ctxt ()->terminate_path ();\n+      }\n+  }\n+};\n+\n /* Specialcase hook for handling \"socket\", for use by\n    kf_socket::outcome_of_socket::update_model.  */\n \n@@ -2269,6 +2308,44 @@ region_model::on_socket (const call_details &cd, bool successful)\n   return fd_sm->on_socket (cd, successful, sm_ctxt.get (), *ext_state);\n }\n \n+/* Handle calls to \"bind\".\n+   See e.g. https://man7.org/linux/man-pages/man3/bind.3p.html  */\n+\n+class kf_bind : public known_function\n+{\n+public:\n+  class outcome_of_bind : public succeed_or_fail_call_info\n+  {\n+  public:\n+    outcome_of_bind (const call_details &cd, bool success)\n+    : succeed_or_fail_call_info (cd, success)\n+    {}\n+\n+    bool update_model (region_model *model,\n+\t\t       const exploded_edge *,\n+\t\t       region_model_context *ctxt) const final override\n+    {\n+      const call_details cd (get_call_details (model, ctxt));\n+      return cd.get_model ()->on_bind (cd, m_success);\n+    }\n+  };\n+\n+  bool matches_call_types_p (const call_details &cd) const final override\n+  {\n+    return (cd.num_args () == 3 && cd.arg_is_pointer_p (1));\n+  }\n+\n+  void impl_call_post (const call_details &cd) const final override\n+  {\n+    if (cd.get_ctxt ())\n+      {\n+\tcd.get_ctxt ()->bifurcate (make_unique<outcome_of_bind> (cd, false));\n+\tcd.get_ctxt ()->bifurcate (make_unique<outcome_of_bind> (cd, true));\n+\tcd.get_ctxt ()->terminate_path ();\n+      }\n+  }\n+};\n+\n /* Specialcase hook for handling \"bind\", for use by\n    kf_bind::outcome_of_bind::update_model.  */\n \n@@ -2287,6 +2364,43 @@ region_model::on_bind (const call_details &cd, bool successful)\n   return fd_sm->on_bind (cd, successful, sm_ctxt.get (), *ext_state);\n }\n \n+/* Handle calls to \"listen\".\n+   See e.g. https://man7.org/linux/man-pages/man3/listen.3p.html  */\n+\n+class kf_listen : public known_function\n+{\n+  class outcome_of_listen : public succeed_or_fail_call_info\n+  {\n+  public:\n+    outcome_of_listen (const call_details &cd, bool success)\n+    : succeed_or_fail_call_info (cd, success)\n+    {}\n+\n+    bool update_model (region_model *model,\n+\t\t       const exploded_edge *,\n+\t\t       region_model_context *ctxt) const final override\n+    {\n+      const call_details cd (get_call_details (model, ctxt));\n+      return cd.get_model ()->on_listen (cd, m_success);\n+    }\n+  };\n+\n+  bool matches_call_types_p (const call_details &cd) const final override\n+  {\n+    return cd.num_args () == 2;\n+  }\n+\n+  void impl_call_post (const call_details &cd) const final override\n+  {\n+    if (cd.get_ctxt ())\n+      {\n+\tcd.get_ctxt ()->bifurcate (make_unique<outcome_of_listen> (cd, false));\n+\tcd.get_ctxt ()->bifurcate (make_unique<outcome_of_listen> (cd, true));\n+\tcd.get_ctxt ()->terminate_path ();\n+      }\n+  }\n+};\n+\n /* Specialcase hook for handling \"listen\", for use by\n    kf_listen::outcome_of_listen::update_model.  */\n \n@@ -2305,6 +2419,45 @@ region_model::on_listen (const call_details &cd, bool successful)\n   return fd_sm->on_listen (cd, successful, sm_ctxt.get (), *ext_state);\n }\n \n+/* Handle calls to \"accept\".\n+   See e.g. https://man7.org/linux/man-pages/man3/accept.3p.html  */\n+\n+class kf_accept : public known_function\n+{\n+  class outcome_of_accept : public succeed_or_fail_call_info\n+  {\n+  public:\n+    outcome_of_accept (const call_details &cd, bool success)\n+    : succeed_or_fail_call_info (cd, success)\n+    {}\n+\n+    bool update_model (region_model *model,\n+\t\t       const exploded_edge *,\n+\t\t       region_model_context *ctxt) const final override\n+    {\n+      const call_details cd (get_call_details (model, ctxt));\n+      return cd.get_model ()->on_accept (cd, m_success);\n+    }\n+  };\n+\n+  bool matches_call_types_p (const call_details &cd) const final override\n+  {\n+    return (cd.num_args () == 3\n+\t    && cd.arg_is_pointer_p (1)\n+\t    && cd.arg_is_pointer_p (2));\n+  }\n+\n+  void impl_call_post (const call_details &cd) const final override\n+  {\n+    if (cd.get_ctxt ())\n+      {\n+\tcd.get_ctxt ()->bifurcate (make_unique<outcome_of_accept> (cd, false));\n+\tcd.get_ctxt ()->bifurcate (make_unique<outcome_of_accept> (cd, true));\n+\tcd.get_ctxt ()->terminate_path ();\n+      }\n+  }\n+};\n+\n /* Specialcase hook for handling \"accept\", for use by\n    kf_accept::outcome_of_accept::update_model.  */\n \n@@ -2323,6 +2476,45 @@ region_model::on_accept (const call_details &cd, bool successful)\n   return fd_sm->on_accept (cd, successful, sm_ctxt.get (), *ext_state);\n }\n \n+/* Handle calls to \"connect\".\n+   See e.g. https://man7.org/linux/man-pages/man3/connect.3p.html  */\n+\n+class kf_connect : public known_function\n+{\n+public:\n+  class outcome_of_connect : public succeed_or_fail_call_info\n+  {\n+  public:\n+    outcome_of_connect (const call_details &cd, bool success)\n+    : succeed_or_fail_call_info (cd, success)\n+    {}\n+\n+    bool update_model (region_model *model,\n+\t\t       const exploded_edge *,\n+\t\t       region_model_context *ctxt) const final override\n+    {\n+      const call_details cd (get_call_details (model, ctxt));\n+      return cd.get_model ()->on_connect (cd, m_success);\n+    }\n+  };\n+\n+  bool matches_call_types_p (const call_details &cd) const final override\n+  {\n+    return (cd.num_args () == 3\n+\t    && cd.arg_is_pointer_p (1));\n+  }\n+\n+  void impl_call_post (const call_details &cd) const final override\n+  {\n+    if (cd.get_ctxt ())\n+      {\n+\tcd.get_ctxt ()->bifurcate (make_unique<outcome_of_connect> (cd, false));\n+\tcd.get_ctxt ()->bifurcate (make_unique<outcome_of_connect> (cd, true));\n+\tcd.get_ctxt ()->terminate_path ();\n+      }\n+  }\n+};\n+\n /* Specialcase hook for handling \"connect\", for use by\n    kf_connect::outcome_of_connect::update_model.  */\n \n@@ -2341,6 +2533,107 @@ region_model::on_connect (const call_details &cd, bool successful)\n   return fd_sm->on_connect (cd, successful, sm_ctxt.get (), *ext_state);\n }\n \n+/* Handler for calls to \"pipe\" and \"pipe2\".\n+   See e.g. https://www.man7.org/linux/man-pages/man2/pipe.2.html  */\n+\n+class kf_pipe : public known_function\n+{\n+  class failure : public failed_call_info\n+  {\n+  public:\n+    failure (const call_details &cd) : failed_call_info (cd) {}\n+\n+    bool update_model (region_model *model,\n+\t\t       const exploded_edge *,\n+\t\t       region_model_context *ctxt) const final override\n+    {\n+      /* Return -1; everything else is unchanged.  */\n+      const call_details cd (get_call_details (model, ctxt));\n+      model->update_for_int_cst_return (cd, -1, true);\n+      return true;\n+    }\n+  };\n+\n+  class success : public success_call_info\n+  {\n+  public:\n+    success (const call_details &cd) : success_call_info (cd) {}\n+\n+    bool update_model (region_model *model,\n+\t\t       const exploded_edge *,\n+\t\t       region_model_context *ctxt) const final override\n+    {\n+      const call_details cd (get_call_details (model, ctxt));\n+\n+      /* Return 0.  */\n+      model->update_for_zero_return (cd, true);\n+\n+      /* Update fd array.  */\n+      region_model_manager *mgr = cd.get_manager ();\n+      tree arr_tree = cd.get_arg_tree (0);\n+      const svalue *arr_sval = cd.get_arg_svalue (0);\n+      for (int idx = 0; idx < 2; idx++)\n+\t{\n+\t  const region *arr_reg\n+\t    = model->deref_rvalue (arr_sval, arr_tree, cd.get_ctxt ());\n+\t  const svalue *idx_sval\n+\t    = mgr->get_or_create_int_cst (integer_type_node, idx);\n+\t  const region *element_reg\n+\t    = mgr->get_element_region (arr_reg, integer_type_node, idx_sval);\n+\t  conjured_purge p (model, cd.get_ctxt ());\n+\t  const svalue *fd_sval\n+\t    = mgr->get_or_create_conjured_svalue (integer_type_node,\n+\t\t\t\t\t\t  cd.get_call_stmt (),\n+\t\t\t\t\t\t  element_reg,\n+\t\t\t\t\t\t  p);\n+\t  model->set_value (element_reg, fd_sval, cd.get_ctxt ());\n+\t  model->mark_as_valid_fd (fd_sval, cd.get_ctxt ());\n+\t}\n+      return true;\n+    }\n+  };\n+\n+public:\n+  kf_pipe (unsigned num_args)\n+  : m_num_args (num_args)\n+  {\n+    gcc_assert (num_args > 0);\n+  }\n+\n+  bool matches_call_types_p (const call_details &cd) const final override\n+  {\n+    return (cd.num_args () == m_num_args && cd.arg_is_pointer_p (0));\n+  }\n+\n+  void impl_call_post (const call_details &cd) const final override\n+  {\n+    if (cd.get_ctxt ())\n+      {\n+\tcd.get_ctxt ()->bifurcate (make_unique<failure> (cd));\n+\tcd.get_ctxt ()->bifurcate (make_unique<success> (cd));\n+\tcd.get_ctxt ()->terminate_path ();\n+      }\n+  }\n+\n+private:\n+  unsigned m_num_args;\n+};\n+\n+/* Populate KFM with instances of known functions relating to\n+   file descriptors.  */\n+\n+void\n+register_known_fd_functions (known_function_manager &kfm)\n+{\n+  kfm.add (\"accept\", make_unique<kf_accept> ());\n+  kfm.add (\"bind\", make_unique<kf_bind> ());\n+  kfm.add (\"connect\", make_unique<kf_connect> ());\n+  kfm.add (\"listen\", make_unique<kf_listen> ());\n+  kfm.add (\"pipe\", make_unique<kf_pipe> (1));\n+  kfm.add (\"pipe2\", make_unique<kf_pipe> (2));\n+  kfm.add (\"socket\", make_unique<kf_socket> ());\n+}\n+\n } // namespace ana\n \n #endif // ENABLE_ANALYZER"}]}