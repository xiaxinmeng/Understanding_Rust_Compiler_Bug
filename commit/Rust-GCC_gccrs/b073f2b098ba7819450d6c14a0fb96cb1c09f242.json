{"sha": "b073f2b098ba7819450d6c14a0fb96cb1c09f242", "node_id": "C_kwDOANBUbNoAKGIwNzNmMmIwOThiYTc4MTk0NTBkNmMxNGEwZmI5NmNiMWMwOWYyNDI", "commit": {"author": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2023-01-12T10:18:22Z"}, "committer": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2023-01-12T13:30:21Z"}, "message": "tree-optimization/99412 - reassoc and reduction chains\n\nWith -ffast-math we end up associating reduction chains and break\nthem - this is because of old code that tries to rectify reductions\ninto a shape likened by the vectorizer.  Nowadays the rank compute\nproduces correct association for reduction chains and the vectorizer\nhas robust support to fall back to a regular reductions (via\nreduction path) when it turns out to be not a proper reduction chain.\n\nSo this patch removes the special code in reassoc which makes\nthe TSVC s352 vectorized with -Ofast (it is already without\n-ffast-math).\n\n\tPR tree-optimization/99412\n\t* tree-ssa-reassoc.cc (is_phi_for_stmt): Remove.\n\t(swap_ops_for_binary_stmt): Remove reduction handling.\n\t(rewrite_expr_tree_parallel): Adjust.\n\t(reassociate_bb): Likewise.\n\t* tree-parloops.cc (build_new_reduction): Handle MINUS_EXPR.\n\n\t* gcc.dg/vect/pr99412.c: New testcase.\n\t* gcc.dg/tree-ssa/reassoc-47.c: Adjust comment.\n\t* gcc.dg/tree-ssa/reassoc-48.c: Remove.", "tree": {"sha": "4e4737fd89497bae3814686055011758a3a55734", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/4e4737fd89497bae3814686055011758a3a55734"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b073f2b098ba7819450d6c14a0fb96cb1c09f242", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b073f2b098ba7819450d6c14a0fb96cb1c09f242", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b073f2b098ba7819450d6c14a0fb96cb1c09f242", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b073f2b098ba7819450d6c14a0fb96cb1c09f242/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "117be79bd84ed21b47588d0cd86d72d5d1757cae", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/117be79bd84ed21b47588d0cd86d72d5d1757cae", "html_url": "https://github.com/Rust-GCC/gccrs/commit/117be79bd84ed21b47588d0cd86d72d5d1757cae"}], "stats": {"total": 102, "additions": 35, "deletions": 67}, "files": [{"sha": "cd2cc740f6d217636902bf32c4a0f9817d3c2fd6", "filename": "gcc/testsuite/gcc.dg/tree-ssa/reassoc-47.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b073f2b098ba7819450d6c14a0fb96cb1c09f242/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Freassoc-47.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b073f2b098ba7819450d6c14a0fb96cb1c09f242/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Freassoc-47.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Freassoc-47.c?ref=b073f2b098ba7819450d6c14a0fb96cb1c09f242", "patch": "@@ -4,6 +4,6 @@\n #define MODIFY\n #include \"reassoc-46.h\"\n \n-/* Check that if the loop accumulator is saved into a global variable, it's\n-   still added last.  */\n+/* Check that if the loop accumulator is modified using a chain of operations\n+   other than addition, its new value is still added last.  */\n /* { dg-final { scan-tree-dump-times {(?:vect_)?sum_[\\d._]+ = (?:(?:vect_)?_[\\d._]+ \\+ (?:vect_)?sum_[\\d._]+|(?:vect_)?sum_[\\d._]+ \\+ (?:vect_)?_[\\d._]+)} 1 \"optimized\" } } */"}, {"sha": "13836ebe8e621b17970f9433c2121482d38051a4", "filename": "gcc/testsuite/gcc.dg/tree-ssa/reassoc-48.c", "status": "removed", "additions": 0, "deletions": 9, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/117be79bd84ed21b47588d0cd86d72d5d1757cae/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Freassoc-48.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/117be79bd84ed21b47588d0cd86d72d5d1757cae/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Freassoc-48.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Freassoc-48.c?ref=117be79bd84ed21b47588d0cd86d72d5d1757cae", "patch": "@@ -1,9 +0,0 @@\n-/* { dg-do compile } */\n-/* { dg-options \"-O2 -fdump-tree-optimized -ftree-vectorize\" } */\n-\n-#define STORE\n-#include \"reassoc-46.h\"\n-\n-/* Check that if the loop accumulator is modified using a chain of operations\n-   other than addition, its new value is still added last.  */\n-/* { dg-final { scan-tree-dump-times {(?:vect_)?sum_[\\d._]+ = (?:(?:vect_)?_[\\d._]+ \\+ (?:vect_)?sum_[\\d._]+|(?:vect_)?sum_[\\d._]+ \\+ (?:vect_)?_[\\d._]+)} 1 \"optimized\" } } */"}, {"sha": "e3e94a052ca13a2ec56fec235a9702dc5d72c1be", "filename": "gcc/testsuite/gcc.dg/vect/pr99412.c", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b073f2b098ba7819450d6c14a0fb96cb1c09f242/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fpr99412.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b073f2b098ba7819450d6c14a0fb96cb1c09f242/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fpr99412.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fpr99412.c?ref=b073f2b098ba7819450d6c14a0fb96cb1c09f242", "patch": "@@ -0,0 +1,24 @@\n+/* { dg-do compile } */\n+/* { dg-additional-options \"-Ofast --param vect-epilogues-nomask=0\" } */\n+/* { dg-require-effective-target vect_float } */\n+\n+/* From TSVC s352.  */\n+\n+typedef float real_t;\n+\n+#define LEN_1D 32000\n+#define LEN_2D 256\n+\n+real_t a[LEN_1D],b[LEN_1D];\n+real_t foo ()\n+{\n+  real_t dot = (real_t)0.;\n+  for (int i = 0; i < LEN_1D; i += 5) {\n+      dot = dot + a[i] * b[i] + a[i + 1] * b[i + 1] + a[i + 2]\n+\t  * b[i + 2] + a[i + 3] * b[i + 3] + a[i + 4] * b[i + 4];\n+  }\n+\n+  return dot;\n+}\n+\n+/* { dg-final { scan-tree-dump \"LOOP VECTORIZED\" \"vect\" } } */"}, {"sha": "dfb75c369d6d00d893ddd6fc28f189ec0d774711", "filename": "gcc/tree-parloops.cc", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b073f2b098ba7819450d6c14a0fb96cb1c09f242/gcc%2Ftree-parloops.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b073f2b098ba7819450d6c14a0fb96cb1c09f242/gcc%2Ftree-parloops.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-parloops.cc?ref=b073f2b098ba7819450d6c14a0fb96cb1c09f242", "patch": "@@ -3228,6 +3228,9 @@ build_new_reduction (reduction_info_table_type *reduction_list,\n   /* Check for OpenMP supported reduction.  */\n   switch (reduction_code)\n     {\n+    case MINUS_EXPR:\n+      reduction_code = PLUS_EXPR;\n+      /* Fallthru.  */\n     case PLUS_EXPR:\n     case MULT_EXPR:\n     case MAX_EXPR:"}, {"sha": "5522a3ada8e308faa5b843014119815340b9499e", "filename": "gcc/tree-ssa-reassoc.cc", "status": "modified", "additions": 6, "deletions": 56, "changes": 62, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b073f2b098ba7819450d6c14a0fb96cb1c09f242/gcc%2Ftree-ssa-reassoc.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b073f2b098ba7819450d6c14a0fb96cb1c09f242/gcc%2Ftree-ssa-reassoc.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-reassoc.cc?ref=b073f2b098ba7819450d6c14a0fb96cb1c09f242", "patch": "@@ -5117,35 +5117,6 @@ maybe_optimize_range_tests (gimple *stmt)\n   return cfg_cleanup_needed;\n }\n \n-/* Return true if OPERAND is defined by a PHI node which uses the LHS\n-   of STMT in it's operands.  This is also known as a \"destructive\n-   update\" operation.  */\n-\n-static bool\n-is_phi_for_stmt (gimple *stmt, tree operand)\n-{\n-  gimple *def_stmt;\n-  gphi *def_phi;\n-  tree lhs;\n-  use_operand_p arg_p;\n-  ssa_op_iter i;\n-\n-  if (TREE_CODE (operand) != SSA_NAME)\n-    return false;\n-\n-  lhs = gimple_assign_lhs (stmt);\n-\n-  def_stmt = SSA_NAME_DEF_STMT (operand);\n-  def_phi = dyn_cast <gphi *> (def_stmt);\n-  if (!def_phi)\n-    return false;\n-\n-  FOR_EACH_PHI_ARG (arg_p, def_phi, i, SSA_OP_USE)\n-    if (lhs == USE_FROM_PTR (arg_p))\n-      return true;\n-  return false;\n-}\n-\n /* Remove def stmt of VAR if VAR has zero uses and recurse\n    on rhs1 operand if so.  */\n \n@@ -5177,42 +5148,21 @@ remove_visited_stmt_chain (tree var)\n    swaps two operands if it is profitable for binary operation\n    consuming OPINDEX + 1 abnd OPINDEX + 2 operands.\n \n-   We pair ops with the same rank if possible.\n-\n-   The alternative we try is to see if STMT is a destructive\n-   update style statement, which is like:\n-   b = phi (a, ...)\n-   a = c + b;\n-   In that case, we want to use the destructive update form to\n-   expose the possible vectorizer sum reduction opportunity.\n-   In that case, the third operand will be the phi node. This\n-   check is not performed if STMT is null.\n-\n-   We could, of course, try to be better as noted above, and do a\n-   lot of work to try to find these opportunities in >3 operand\n-   cases, but it is unlikely to be worth it.  */\n+   We pair ops with the same rank if possible.  */\n \n static void\n swap_ops_for_binary_stmt (const vec<operand_entry *> &ops,\n-\t\t\t  unsigned int opindex, gimple *stmt)\n+\t\t\t  unsigned int opindex)\n {\n   operand_entry *oe1, *oe2, *oe3;\n \n   oe1 = ops[opindex];\n   oe2 = ops[opindex + 1];\n   oe3 = ops[opindex + 2];\n \n-  if ((oe1->rank == oe2->rank\n-       && oe2->rank != oe3->rank)\n-      || (stmt && is_phi_for_stmt (stmt, oe3->op)\n-\t  && !is_phi_for_stmt (stmt, oe1->op)\n-\t  && !is_phi_for_stmt (stmt, oe2->op)))\n+  if (oe1->rank == oe2->rank && oe2->rank != oe3->rank)\n     std::swap (*oe1, *oe3);\n-  else if ((oe1->rank == oe3->rank\n-\t    && oe2->rank != oe3->rank)\n-\t   || (stmt && is_phi_for_stmt (stmt, oe2->op)\n-\t       && !is_phi_for_stmt (stmt, oe1->op)\n-\t       && !is_phi_for_stmt (stmt, oe3->op)))\n+  else if (oe1->rank == oe3->rank && oe2->rank != oe3->rank)\n     std::swap (*oe1, *oe2);\n }\n \n@@ -5561,7 +5511,7 @@ rewrite_expr_tree_parallel (gassign *stmt, int width,\n       else\n \t{\n \t  if (op_index > 1)\n-\t    swap_ops_for_binary_stmt (ops, op_index - 2, NULL);\n+\t    swap_ops_for_binary_stmt (ops, op_index - 2);\n \t  operand_entry *oe2 = ops[op_index--];\n \t  operand_entry *oe1 = ops[op_index--];\n \t  op2 = oe2->op;\n@@ -6877,7 +6827,7 @@ reassociate_bb (basic_block bb)\n                          binary op are chosen wisely.  */\n                       int len = ops.length ();\n                       if (len >= 3)\n-                        swap_ops_for_binary_stmt (ops, len - 3, stmt);\n+\t\t\tswap_ops_for_binary_stmt (ops, len - 3);\n \n \t\t      new_lhs = rewrite_expr_tree (stmt, rhs_code, 0, ops,\n \t\t\t\t\t\t   powi_result != NULL"}]}