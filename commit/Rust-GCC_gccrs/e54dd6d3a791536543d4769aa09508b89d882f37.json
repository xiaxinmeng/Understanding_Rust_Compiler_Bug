{"sha": "e54dd6d3a791536543d4769aa09508b89d882f37", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTU0ZGQ2ZDNhNzkxNTM2NTQzZDQ3NjlhYTA5NTA4Yjg5ZDg4MmYzNw==", "commit": {"author": {"name": "Richard Sandiford", "email": "richard.sandiford@linaro.org", "date": "2018-01-03T07:15:47Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2018-01-03T07:15:47Z"}, "message": "poly_int: vectorizable_reduction\n\nThis patch makes vectorizable_reduction cope with variable-length vectors.\nWe can handle the simple case of an inner loop reduction for which\nthe target has native support for the epilogue operation.  For now we\npunt on other cases, but patches after the main SVE submission allow\nSLP and double reductions too.\n\n2018-01-03  Richard Sandiford  <richard.sandiford@linaro.org>\n\t    Alan Hayward  <alan.hayward@arm.com>\n\t    David Sherwood  <david.sherwood@arm.com>\n\ngcc/\n\t* tree.h (build_index_vector): Declare.\n\t* tree.c (build_index_vector): New function.\n\t* tree-vect-loop.c (get_initial_defs_for_reduction): Treat the number\n\tof units as polynomial, forcibly converting it to a constant if\n\tvectorizable_reduction has already enforced the condition.\n\t(vect_create_epilog_for_reduction): Likewise.  Use build_index_vector\n\tto create a {1,2,3,...} vector.\n\t(vectorizable_reduction): Treat the number of units as polynomial.\n\tChoose vectype_in based on the largest scalar element size rather\n\tthan the smallest number of units.  Enforce the restrictions\n\trelied on above.\n\nCo-Authored-By: Alan Hayward <alan.hayward@arm.com>\nCo-Authored-By: David Sherwood <david.sherwood@arm.com>\n\nFrom-SVN: r256133", "tree": {"sha": "db4448d26a9b2471ac93890a2efe92185d049fe5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/db4448d26a9b2471ac93890a2efe92185d049fe5"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e54dd6d3a791536543d4769aa09508b89d882f37", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e54dd6d3a791536543d4769aa09508b89d882f37", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e54dd6d3a791536543d4769aa09508b89d882f37", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e54dd6d3a791536543d4769aa09508b89d882f37/comments", "author": null, "committer": null, "parents": [{"sha": "9031b367ac87550552318f6516487c70f3ce9a99", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9031b367ac87550552318f6516487c70f3ce9a99", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9031b367ac87550552318f6516487c70f3ce9a99"}], "stats": {"total": 106, "additions": 91, "deletions": 15}, "files": [{"sha": "eda66257b4708fdece1ffb39e5c9345204be1410", "filename": "gcc/ChangeLog", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e54dd6d3a791536543d4769aa09508b89d882f37/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e54dd6d3a791536543d4769aa09508b89d882f37/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=e54dd6d3a791536543d4769aa09508b89d882f37", "patch": "@@ -1,3 +1,19 @@\n+2018-01-03  Richard Sandiford  <richard.sandiford@linaro.org>\n+\t    Alan Hayward  <alan.hayward@arm.com>\n+\t    David Sherwood  <david.sherwood@arm.com>\n+\n+\t* tree.h (build_index_vector): Declare.\n+\t* tree.c (build_index_vector): New function.\n+\t* tree-vect-loop.c (get_initial_defs_for_reduction): Treat the number\n+\tof units as polynomial, forcibly converting it to a constant if\n+\tvectorizable_reduction has already enforced the condition.\n+\t(vect_create_epilog_for_reduction): Likewise.  Use build_index_vector\n+\tto create a {1,2,3,...} vector.\n+\t(vectorizable_reduction): Treat the number of units as polynomial.\n+\tChoose vectype_in based on the largest scalar element size rather\n+\tthan the smallest number of units.  Enforce the restrictions\n+\trelied on above.\n+\n 2018-01-03  Richard Sandiford  <richard.sandiford@linaro.org>\n \t    Alan Hayward  <alan.hayward@arm.com>\n \t    David Sherwood  <david.sherwood@arm.com>"}, {"sha": "93e430c7a562f0884138039ec1e2b3abf8214719", "filename": "gcc/tree-vect-loop.c", "status": "modified", "additions": 51, "deletions": 15, "changes": 66, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e54dd6d3a791536543d4769aa09508b89d882f37/gcc%2Ftree-vect-loop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e54dd6d3a791536543d4769aa09508b89d882f37/gcc%2Ftree-vect-loop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-loop.c?ref=e54dd6d3a791536543d4769aa09508b89d882f37", "patch": "@@ -4150,6 +4150,8 @@ get_initial_defs_for_reduction (slp_tree slp_node,\n \n   vector_type = STMT_VINFO_VECTYPE (stmt_vinfo);\n   scalar_type = TREE_TYPE (vector_type);\n+  /* vectorizable_reduction has already rejected SLP reductions on\n+     variable-length vectors.  */\n   nunits = TYPE_VECTOR_SUBPARTS (vector_type);\n \n   gcc_assert (STMT_VINFO_DEF_TYPE (stmt_vinfo) == vect_reduction_def);\n@@ -4537,8 +4539,7 @@ vect_create_epilog_for_reduction (vec<tree> vect_defs, gimple *stmt,\n   if (STMT_VINFO_VEC_REDUCTION_TYPE (stmt_info) == COND_REDUCTION)\n     {\n       tree indx_before_incr, indx_after_incr;\n-      int nunits_out = TYPE_VECTOR_SUBPARTS (vectype);\n-      int k;\n+      poly_uint64 nunits_out = TYPE_VECTOR_SUBPARTS (vectype);\n \n       gimple *vec_stmt = STMT_VINFO_VEC_STMT (stmt_info);\n       gcc_assert (gimple_assign_rhs_code (vec_stmt) == VEC_COND_EXPR);\n@@ -4554,10 +4555,7 @@ vect_create_epilog_for_reduction (vec<tree> vect_defs, gimple *stmt,\n \t vector size (STEP).  */\n \n       /* Create a {1,2,3,...} vector.  */\n-      tree_vector_builder vtemp (cr_index_vector_type, 1, 3);\n-      for (k = 0; k < 3; ++k)\n-\tvtemp.quick_push (build_int_cst (cr_index_scalar_type, k + 1));\n-      tree series_vect = vtemp.build ();\n+      tree series_vect = build_index_vector (cr_index_vector_type, 1, 1);\n \n       /* Create a vector of the step value.  */\n       tree step = build_int_cst (cr_index_scalar_type, nunits_out);\n@@ -4935,8 +4933,11 @@ vect_create_epilog_for_reduction (vec<tree> vect_defs, gimple *stmt,\n       tree data_eltype = TREE_TYPE (TREE_TYPE (new_phi_result));\n       tree idx_eltype = TREE_TYPE (TREE_TYPE (induction_index));\n       unsigned HOST_WIDE_INT el_size = tree_to_uhwi (TYPE_SIZE (idx_eltype));\n-      unsigned HOST_WIDE_INT v_size\n-\t= el_size * TYPE_VECTOR_SUBPARTS (TREE_TYPE (induction_index));\n+      poly_uint64 nunits = TYPE_VECTOR_SUBPARTS (TREE_TYPE (induction_index));\n+      /* Enforced by vectorizable_reduction, which ensures we have target\n+\t support before allowing a conditional reduction on variable-length\n+\t vectors.  */\n+      unsigned HOST_WIDE_INT v_size = el_size * nunits.to_constant ();\n       tree idx_val = NULL_TREE, val = NULL_TREE;\n       for (unsigned HOST_WIDE_INT off = 0; off < v_size; off += el_size)\n \t{\n@@ -5055,6 +5056,9 @@ vect_create_epilog_for_reduction (vec<tree> vect_defs, gimple *stmt,\n     {\n       bool reduce_with_shift = have_whole_vector_shift (mode);\n       int element_bitsize = tree_to_uhwi (bitsize);\n+      /* Enforced by vectorizable_reduction, which disallows SLP reductions\n+\t for variable-length vectors and also requires direct target support\n+\t for loop reductions.  */\n       int vec_size_in_bits = tree_to_uhwi (TYPE_SIZE (vectype));\n       tree vec_temp;\n \n@@ -5743,10 +5747,10 @@ vectorizable_reduction (gimple *stmt, gimple_stmt_iterator *gsi,\n \t  if (k == 1\n \t      && gimple_assign_rhs_code (reduc_stmt) == COND_EXPR)\n \t    continue;\n-\t  tem = get_vectype_for_scalar_type (TREE_TYPE (op));\n-\t  if (! vectype_in\n-\t      || TYPE_VECTOR_SUBPARTS (tem) < TYPE_VECTOR_SUBPARTS (vectype_in))\n-\t    vectype_in = tem;\n+\t  if (!vectype_in\n+\t      || (GET_MODE_SIZE (SCALAR_TYPE_MODE (TREE_TYPE (vectype_in)))\n+\t\t  < GET_MODE_SIZE (SCALAR_TYPE_MODE (TREE_TYPE (op)))))\n+\t    vectype_in = get_vectype_for_scalar_type (TREE_TYPE (op));\n \t  break;\n \t}\n       gcc_assert (vectype_in);\n@@ -5912,7 +5916,8 @@ vectorizable_reduction (gimple *stmt, gimple_stmt_iterator *gsi,\n \t  /* To properly compute ncopies we are interested in the widest\n \t     input type in case we're looking at a widening accumulation.  */\n \t  if (!vectype_in\n-\t      || TYPE_VECTOR_SUBPARTS (vectype_in) > TYPE_VECTOR_SUBPARTS (tem))\n+\t      || (GET_MODE_SIZE (SCALAR_TYPE_MODE (TREE_TYPE (vectype_in)))\n+\t\t  < GET_MODE_SIZE (SCALAR_TYPE_MODE (TREE_TYPE (tem)))))\n \t    vectype_in = tem;\n \t}\n \n@@ -6097,6 +6102,7 @@ vectorizable_reduction (gimple *stmt, gimple_stmt_iterator *gsi,\n   gcc_assert (ncopies >= 1);\n \n   vec_mode = TYPE_MODE (vectype_in);\n+  poly_uint64 nunits_out = TYPE_VECTOR_SUBPARTS (vectype_out);\n \n   if (code == COND_EXPR)\n     {\n@@ -6278,14 +6284,23 @@ vectorizable_reduction (gimple *stmt, gimple_stmt_iterator *gsi,\n       int scalar_precision\n \t= GET_MODE_PRECISION (SCALAR_TYPE_MODE (scalar_type));\n       cr_index_scalar_type = make_unsigned_type (scalar_precision);\n-      cr_index_vector_type = build_vector_type\n-\t(cr_index_scalar_type, TYPE_VECTOR_SUBPARTS (vectype_out));\n+      cr_index_vector_type = build_vector_type (cr_index_scalar_type,\n+\t\t\t\t\t\tnunits_out);\n \n       if (direct_internal_fn_supported_p (IFN_REDUC_MAX, cr_index_vector_type,\n \t\t\t\t\t  OPTIMIZE_FOR_SPEED))\n \treduc_fn = IFN_REDUC_MAX;\n     }\n \n+  if (reduc_fn == IFN_LAST && !nunits_out.is_constant ())\n+    {\n+      if (dump_enabled_p ())\n+\tdump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n+\t\t\t \"missing target support for reduction on\"\n+\t\t\t \" variable-length vectors.\\n\");\n+      return false;\n+    }\n+\n   if ((double_reduc\n        || STMT_VINFO_VEC_REDUCTION_TYPE (stmt_info) != TREE_CODE_REDUCTION)\n       && ncopies > 1)\n@@ -6297,6 +6312,27 @@ vectorizable_reduction (gimple *stmt, gimple_stmt_iterator *gsi,\n       return false;\n     }\n \n+  if (double_reduc && !nunits_out.is_constant ())\n+    {\n+      /* The current double-reduction code creates the initial value\n+\t element-by-element.  */\n+      if (dump_enabled_p ())\n+\tdump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n+\t\t\t \"double reduction not supported for variable-length\"\n+\t\t\t \" vectors.\\n\");\n+      return false;\n+    }\n+\n+  if (slp_node && !nunits_out.is_constant ())\n+    {\n+      /* The current SLP code creates the initial value element-by-element.  */\n+      if (dump_enabled_p ())\n+\tdump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n+\t\t\t \"SLP reduction not supported for variable-length\"\n+\t\t\t \" vectors.\\n\");\n+      return false;\n+    }\n+\n   /* In case of widenning multiplication by a constant, we update the type\n      of the constant to be the type of the other operand.  We check that the\n      constant fits the type in the pattern recognition pass.  */"}, {"sha": "93c4654309d597c57c8817a3fcd7d92b8e4ef5d4", "filename": "gcc/tree.c", "status": "modified", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e54dd6d3a791536543d4769aa09508b89d882f37/gcc%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e54dd6d3a791536543d4769aa09508b89d882f37/gcc%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.c?ref=e54dd6d3a791536543d4769aa09508b89d882f37", "patch": "@@ -1930,6 +1930,29 @@ build_vec_series (tree type, tree base, tree step)\n   return build2 (VEC_SERIES_EXPR, type, base, step);\n }\n \n+/* Return a vector with the same number of units and number of bits\n+   as VEC_TYPE, but in which the elements are a linear series of unsigned\n+   integers { BASE, BASE + STEP, BASE + STEP * 2, ... }.  */\n+\n+tree\n+build_index_vector (tree vec_type, poly_uint64 base, poly_uint64 step)\n+{\n+  tree index_vec_type = vec_type;\n+  tree index_elt_type = TREE_TYPE (vec_type);\n+  poly_uint64 nunits = TYPE_VECTOR_SUBPARTS (vec_type);\n+  if (!INTEGRAL_TYPE_P (index_elt_type) || !TYPE_UNSIGNED (index_elt_type))\n+    {\n+      index_elt_type = build_nonstandard_integer_type\n+\t(GET_MODE_BITSIZE (SCALAR_TYPE_MODE (index_elt_type)), true);\n+      index_vec_type = build_vector_type (index_elt_type, nunits);\n+    }\n+\n+  tree_vector_builder v (index_vec_type, 1, 3);\n+  for (unsigned int i = 0; i < 3; ++i)\n+    v.quick_push (build_int_cstu (index_elt_type, base + i * step));\n+  return v.build ();\n+}\n+\n /* Something has messed with the elements of CONSTRUCTOR C after it was built;\n    calculate TREE_CONSTANT and TREE_SIDE_EFFECTS.  */\n "}, {"sha": "a45c2cd5aa681ce87fd23a6257a7bcd2484003dd", "filename": "gcc/tree.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e54dd6d3a791536543d4769aa09508b89d882f37/gcc%2Ftree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e54dd6d3a791536543d4769aa09508b89d882f37/gcc%2Ftree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.h?ref=e54dd6d3a791536543d4769aa09508b89d882f37", "patch": "@@ -4062,6 +4062,7 @@ extern tree make_vector (unsigned, unsigned CXX_MEM_STAT_INFO);\n extern tree build_vector_from_ctor (tree, vec<constructor_elt, va_gc> *);\n extern tree build_vector_from_val (tree, tree);\n extern tree build_vec_series (tree, tree, tree);\n+extern tree build_index_vector (tree, poly_uint64, poly_uint64);\n extern void recompute_constructor_flags (tree);\n extern void verify_constructor_flags (tree);\n extern tree build_constructor (tree, vec<constructor_elt, va_gc> *);"}]}