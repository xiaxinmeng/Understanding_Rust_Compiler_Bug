{"sha": "c01760bc548ba79bc9ac15168b27fe7aabcb19ae", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YzAxNzYwYmM1NDhiYTc5YmM5YWMxNTE2OGIyN2ZlN2FhYmNiMTlhZQ==", "commit": {"author": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2021-06-29T07:33:24Z"}, "committer": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2021-06-29T08:34:57Z"}, "message": "tree-optimization/101242 - fix reverse graph entry detection\n\nThis avoids detecting random unrelated nodes as possible entries\nto not backwards reachable regions of the SLP graph.  Instead\nexplicitely add the problematic nodes.\n\nThis temporary XFAILs gcc.dg/vect/pr67790.c until I get the\npermute propagation adjusted to when it needs more than one\noptimistic iteration.\n\n2021-06-29  Richard Biener  <rguenther@suse.de>\n\n\tPR tree-optimization/101242\n\t* tree-vect-slp.c (vect_slp_build_vertices): Force-add\n\tPHIs with not represented initial values as leafs.\n\n\t* gcc.dg/vect/bb-slp-pr101242.c: New testcase.\n\t* gcc.dg/vect/pr67790.c: XFAIL scan for zero VEC_PERM_EXPR.", "tree": {"sha": "72f17a6918641c0263b9162c0eca87376cf7e185", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/72f17a6918641c0263b9162c0eca87376cf7e185"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c01760bc548ba79bc9ac15168b27fe7aabcb19ae", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c01760bc548ba79bc9ac15168b27fe7aabcb19ae", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c01760bc548ba79bc9ac15168b27fe7aabcb19ae", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c01760bc548ba79bc9ac15168b27fe7aabcb19ae/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "dc6866b033b1b85f690bf32c0dae7d787cbf58f0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dc6866b033b1b85f690bf32c0dae7d787cbf58f0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/dc6866b033b1b85f690bf32c0dae7d787cbf58f0"}], "stats": {"total": 64, "additions": 50, "deletions": 14}, "files": [{"sha": "d8854468df4acfd6c696e448a275d6e9834e0cd2", "filename": "gcc/testsuite/gcc.dg/vect/bb-slp-pr101242.c", "status": "added", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c01760bc548ba79bc9ac15168b27fe7aabcb19ae/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fbb-slp-pr101242.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c01760bc548ba79bc9ac15168b27fe7aabcb19ae/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fbb-slp-pr101242.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fbb-slp-pr101242.c?ref=c01760bc548ba79bc9ac15168b27fe7aabcb19ae", "patch": "@@ -0,0 +1,38 @@\n+/* { dg-do compile } */\n+/* { dg-additional-options \"-Ofast\" } */\n+\n+typedef struct {\n+  double real;\n+  double imag;\n+} complex;\n+typedef struct {\n+  complex e[3][3];\n+} su3_matrix;\n+su3_matrix check_su3_c;\n+double check_su3_ar, check_su3_ari, check_su3_max;\n+int arireturn();\n+int check_su3() {\n+  check_su3_ar = check_su3_c.e[0][0].real * check_su3_c.e[1][0].real +\n+                 check_su3_c.e[0][0].imag * check_su3_c.e[1][0].imag +\n+                 check_su3_c.e[0][1].real * check_su3_c.e[1][1].real +\n+                 check_su3_c.e[0][1].imag * check_su3_c.e[1][1].imag +\n+                 check_su3_c.e[0][2].real * check_su3_c.e[1][2].real +\n+                 check_su3_c.e[0][2].imag * check_su3_c.e[1][2].imag;\n+  check_su3_max = check_su3_c.e[0][0].real * check_su3_c.e[2][0].real +\n+                  check_su3_c.e[0][0].imag * check_su3_c.e[2][0].imag +\n+                  check_su3_c.e[0][1].real * check_su3_c.e[2][1].real +\n+                  check_su3_c.e[0][1].imag * check_su3_c.e[2][1].imag +\n+                  check_su3_c.e[0][2].real * check_su3_c.e[2][2].real +\n+                  check_su3_c.e[0][2].imag * check_su3_c.e[2][2].imag;\n+  check_su3_ari = check_su3_ar;\n+  if (check_su3_ari)\n+    check_su3_max = check_su3_c.e[1][0].real * check_su3_c.e[2][0].real +\n+                    check_su3_c.e[1][0].imag * check_su3_c.e[2][0].imag +\n+                    check_su3_c.e[1][1].real * check_su3_c.e[2][1].real +\n+                    check_su3_c.e[1][1].imag * check_su3_c.e[2][1].imag +\n+                    check_su3_c.e[1][2].real * check_su3_c.e[2][2].real +\n+                    check_su3_c.e[1][2].imag * check_su3_c.e[2][2].imag;\n+  if (check_su3_max)\n+    arireturn();\n+  return 0;\n+}"}, {"sha": "0555d41abf77afb18c2a2c801f35db18626a8b4c", "filename": "gcc/testsuite/gcc.dg/vect/pr67790.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c01760bc548ba79bc9ac15168b27fe7aabcb19ae/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fpr67790.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c01760bc548ba79bc9ac15168b27fe7aabcb19ae/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fpr67790.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fpr67790.c?ref=c01760bc548ba79bc9ac15168b27fe7aabcb19ae", "patch": "@@ -38,4 +38,4 @@ int main()\n }\n \n /* { dg-final { scan-tree-dump \"vectorizing stmts using SLP\" \"vect\" } } */\n-/* { dg-final { scan-tree-dump-times \"VEC_PERM_EXPR\" 0 \"vect\" } } */\n+/* { dg-final { scan-tree-dump-times \"VEC_PERM_EXPR\" 0 \"vect\" { xfail *-*-* } } } */"}, {"sha": "63b6e6a24b9182cef68fd63beb9107e97dc81c2d", "filename": "gcc/tree-vect-slp.c", "status": "modified", "additions": 11, "deletions": 13, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c01760bc548ba79bc9ac15168b27fe7aabcb19ae/gcc%2Ftree-vect-slp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c01760bc548ba79bc9ac15168b27fe7aabcb19ae/gcc%2Ftree-vect-slp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-slp.c?ref=c01760bc548ba79bc9ac15168b27fe7aabcb19ae", "patch": "@@ -3499,13 +3499,21 @@ vect_slp_build_vertices (hash_set<slp_tree> &visited, slp_tree node,\n   vertices.safe_push (slpg_vertex (node));\n \n   bool leaf = true;\n+  bool force_leaf = false;\n   FOR_EACH_VEC_ELT (SLP_TREE_CHILDREN (node), i, child)\n     if (child)\n       {\n \tleaf = false;\n \tvect_slp_build_vertices (visited, child, vertices, leafs);\n       }\n-  if (leaf)\n+    else\n+      force_leaf = true;\n+  /* Since SLP discovery works along use-def edges all cycles have an\n+     entry - but there's the exception of cycles where we do not handle\n+     the entry explicitely (but with a NULL SLP node), like some reductions\n+     and inductions.  Force those SLP PHIs to act as leafs to make them\n+     backwards reachable.  */\n+  if (leaf || force_leaf)\n     leafs.safe_push (node->vertex);\n }\n \n@@ -3519,18 +3527,8 @@ vect_slp_build_vertices (vec_info *info, vec<slpg_vertex> &vertices,\n   unsigned i;\n   slp_instance instance;\n   FOR_EACH_VEC_ELT (info->slp_instances, i, instance)\n-    {\n-      unsigned n_v = vertices.length ();\n-      unsigned n_l = leafs.length ();\n-      vect_slp_build_vertices (visited, SLP_INSTANCE_TREE (instance), vertices,\n-\t\t\t       leafs);\n-      /* If we added vertices but no entries to the reverse graph we've\n-\t added a cycle that is not backwards-reachable.   Push the entry\n-\t to mimic as leaf then.  */\n-      if (vertices.length () > n_v\n-\t  && leafs.length () == n_l)\n-\tleafs.safe_push (SLP_INSTANCE_TREE (instance)->vertex);\n-    }\n+    vect_slp_build_vertices (visited, SLP_INSTANCE_TREE (instance), vertices,\n+\t\t\t     leafs);\n }\n \n /* Apply (reverse) bijectite PERM to VEC.  */"}]}