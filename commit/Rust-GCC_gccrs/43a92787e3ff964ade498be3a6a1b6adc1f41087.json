{"sha": "43a92787e3ff964ade498be3a6a1b6adc1f41087", "node_id": "C_kwDOANBUbNoAKDQzYTkyNzg3ZTNmZjk2NGFkZTQ5OGJlM2E2YTFiNmFkYzFmNDEwODc", "commit": {"author": {"name": "Philip Herron", "email": "herron.philip@googlemail.com", "date": "2023-02-27T19:16:00Z"}, "committer": {"name": "Philip Herron", "email": "philip.herron@embecosm.com", "date": "2023-02-28T20:38:35Z"}, "message": "gccrs: Fix method resolution to use TryCoerce\n\nRust allows us to call generic pointer methods on pointers so in non\ngeneric contexts the old code using the bad can_eq interface couldn't\nhandle this case. So taking advantage of our new unify_and interface to try\nand infer when required we can start using our TryCoerce interface to reuse\nexisting code to assemble possible candidates more acurately using the\nexisting coercion rules.\n\nFixes #1901 #878\n\nSigned-off-by: Philip Herron <herron.philip@googlemail.com>\n\ngcc/rust/ChangeLog:\n\n\t* typecheck/rust-coercion.cc (TypeCoercionRules::Coerce): Add new try_flag\n\t(TypeCoercionRules::TypeCoercionRules): set new try flag\n\t(TypeCoercionRules::do_coercion): default to a final unify_and in the else case\n\t(TypeCoercionRules::coerce_unsafe_ptr): cannot coerce to a ptr from ref during autoderef\n\t(TypeCoercionRules::coerce_borrowed_pointer): respect coerceable mutability\n\t* typecheck/rust-coercion.h: update header\n\t* typecheck/rust-hir-dot-operator.cc (MethodResolver::select): use new TryCoerce interface\n\t(MethodResolver::append_adjustments): ensure we maintain adjustment mappings\n\t* typecheck/rust-hir-dot-operator.h: add new method append_adjustments\n\t* typecheck/rust-hir-type-check-expr.cc (TypeCheckExpr::visit): extra logging\n\ngcc/testsuite/ChangeLog:\n\n\t* rust/compile/issue-1901.rs: New test.", "tree": {"sha": "7ec6f193356791d07d4aa7937559cbd408409dcd", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/7ec6f193356791d07d4aa7937559cbd408409dcd"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/43a92787e3ff964ade498be3a6a1b6adc1f41087", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/43a92787e3ff964ade498be3a6a1b6adc1f41087", "html_url": "https://github.com/Rust-GCC/gccrs/commit/43a92787e3ff964ade498be3a6a1b6adc1f41087", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/43a92787e3ff964ade498be3a6a1b6adc1f41087/comments", "author": {"login": "philberty", "id": 84585, "node_id": "MDQ6VXNlcjg0NTg1", "avatar_url": "https://avatars.githubusercontent.com/u/84585?v=4", "gravatar_id": "", "url": "https://api.github.com/users/philberty", "html_url": "https://github.com/philberty", "followers_url": "https://api.github.com/users/philberty/followers", "following_url": "https://api.github.com/users/philberty/following{/other_user}", "gists_url": "https://api.github.com/users/philberty/gists{/gist_id}", "starred_url": "https://api.github.com/users/philberty/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/philberty/subscriptions", "organizations_url": "https://api.github.com/users/philberty/orgs", "repos_url": "https://api.github.com/users/philberty/repos", "events_url": "https://api.github.com/users/philberty/events{/privacy}", "received_events_url": "https://api.github.com/users/philberty/received_events", "type": "User", "site_admin": false}, "committer": {"login": "philberty", "id": 84585, "node_id": "MDQ6VXNlcjg0NTg1", "avatar_url": "https://avatars.githubusercontent.com/u/84585?v=4", "gravatar_id": "", "url": "https://api.github.com/users/philberty", "html_url": "https://github.com/philberty", "followers_url": "https://api.github.com/users/philberty/followers", "following_url": "https://api.github.com/users/philberty/following{/other_user}", "gists_url": "https://api.github.com/users/philberty/gists{/gist_id}", "starred_url": "https://api.github.com/users/philberty/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/philberty/subscriptions", "organizations_url": "https://api.github.com/users/philberty/orgs", "repos_url": "https://api.github.com/users/philberty/repos", "events_url": "https://api.github.com/users/philberty/events{/privacy}", "received_events_url": "https://api.github.com/users/philberty/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a20426036a360d781dae2361ffd4c7dcfe4bb40a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a20426036a360d781dae2361ffd4c7dcfe4bb40a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a20426036a360d781dae2361ffd4c7dcfe4bb40a"}], "stats": {"total": 298, "additions": 240, "deletions": 58}, "files": [{"sha": "9831e77cdd084f447fbeba6649028f084b9433ff", "filename": "gcc/rust/typecheck/rust-coercion.cc", "status": "modified", "additions": 48, "deletions": 9, "changes": 57, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/43a92787e3ff964ade498be3a6a1b6adc1f41087/gcc%2Frust%2Ftypecheck%2Frust-coercion.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/43a92787e3ff964ade498be3a6a1b6adc1f41087/gcc%2Frust%2Ftypecheck%2Frust-coercion.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-coercion.cc?ref=43a92787e3ff964ade498be3a6a1b6adc1f41087", "patch": "@@ -27,7 +27,7 @@ TypeCoercionRules::CoercionResult\n TypeCoercionRules::Coerce (TyTy::BaseType *receiver, TyTy::BaseType *expected,\n \t\t\t   Location locus, bool allow_autoderef)\n {\n-  TypeCoercionRules resolver (expected, locus, true, allow_autoderef);\n+  TypeCoercionRules resolver (expected, locus, true, allow_autoderef, false);\n   bool ok = resolver.do_coercion (receiver);\n   return ok ? resolver.try_result : CoercionResult::get_error ();\n }\n@@ -37,16 +37,18 @@ TypeCoercionRules::TryCoerce (TyTy::BaseType *receiver,\n \t\t\t      TyTy::BaseType *expected, Location locus,\n \t\t\t      bool allow_autoderef)\n {\n-  TypeCoercionRules resolver (expected, locus, false, allow_autoderef);\n+  TypeCoercionRules resolver (expected, locus, false, allow_autoderef, true);\n   bool ok = resolver.do_coercion (receiver);\n   return ok ? resolver.try_result : CoercionResult::get_error ();\n }\n \n TypeCoercionRules::TypeCoercionRules (TyTy::BaseType *expected, Location locus,\n-\t\t\t\t      bool emit_errors, bool allow_autoderef)\n+\t\t\t\t      bool emit_errors, bool allow_autoderef,\n+\t\t\t\t      bool try_flag)\n   : AutoderefCycle (!allow_autoderef), mappings (Analysis::Mappings::get ()),\n     context (TypeCheckContext::get ()), expected (expected), locus (locus),\n-    try_result (CoercionResult::get_error ()), emit_errors (emit_errors)\n+    try_result (CoercionResult::get_error ()), emit_errors (emit_errors),\n+    try_flag (try_flag)\n {}\n \n bool\n@@ -139,6 +141,31 @@ TypeCoercionRules::do_coercion (TyTy::BaseType *receiver)\n       break;\n     }\n \n+  // https://github.com/rust-lang/rust/blob/7eac88abb2e57e752f3302f02be5f3ce3d7adfb4/compiler/rustc_typeck/src/check/coercion.rs#L210\n+  switch (receiver->get_kind ())\n+    {\n+      default: {\n+\trust_debug (\n+\t  \"do_coercion default unify and infer expected: %s receiver %s\",\n+\t  receiver->debug_str ().c_str (), expected->debug_str ().c_str ());\n+\tTyTy::BaseType *result\n+\t  = unify_site_and (receiver->get_ref (),\n+\t\t\t    TyTy::TyWithLocation (expected),\n+\t\t\t    TyTy::TyWithLocation (receiver),\n+\t\t\t    locus /*unify_locus*/, false /*emit_errors*/,\n+\t\t\t    !try_flag /*commit_if_ok*/, true /*infer*/,\n+\t\t\t    try_flag /*cleanup on error*/);\n+\trust_debug (\"result\");\n+\tresult->debug ();\n+\tif (result->get_kind () != TyTy::TypeKind::ERROR)\n+\t  {\n+\t    try_result = CoercionResult{{}, result};\n+\t    return true;\n+\t  }\n+      }\n+      break;\n+    }\n+\n   return !try_result.is_error ();\n }\n \n@@ -170,13 +197,21 @@ TypeCoercionRules::coerce_unsafe_ptr (TyTy::BaseType *receiver,\n       break;\n \n       default: {\n+\t// FIXME this can probably turn into a unify_and\n \tif (receiver->can_eq (expected, false))\n \t  return CoercionResult{{}, expected->clone ()};\n \n \treturn CoercionResult::get_error ();\n       }\n     }\n \n+  bool receiver_is_non_ptr = receiver->get_kind () != TyTy::TypeKind::POINTER;\n+  if (autoderef_flag && receiver_is_non_ptr)\n+    {\n+      // it is unsafe to autoderef to raw pointers\n+      return CoercionResult::get_error ();\n+    }\n+\n   if (!coerceable_mutability (from_mutbl, to_mutbl))\n     {\n       Location lhs = mappings->lookup_location (receiver->get_ref ());\n@@ -192,9 +227,9 @@ TypeCoercionRules::coerce_unsafe_ptr (TyTy::BaseType *receiver,\n   TyTy::BaseType *result\n     = unify_site_and (receiver->get_ref (), TyTy::TyWithLocation (expected),\n \t\t      TyTy::TyWithLocation (coerced_mutability),\n-\t\t      Location () /*unify_locus*/, false /*emit_errors*/,\n-\t\t      true /*commit_if_ok*/, true /*infer*/,\n-\t\t      true /*cleanup on error*/);\n+\t\t      locus /*unify_locus*/, false /*emit_errors*/,\n+\t\t      !try_flag /*commit_if_ok*/, true /*infer*/,\n+\t\t      try_flag /*cleanup on error*/);\n   bool unsafe_ptr_coerceion_ok = result->get_kind () != TyTy::TypeKind::ERROR;\n   if (unsafe_ptr_coerceion_ok)\n     return CoercionResult{{}, result};\n@@ -229,8 +264,12 @@ TypeCoercionRules::coerce_borrowed_pointer (TyTy::BaseType *receiver,\n \t// back to a final unity anyway\n \trust_debug (\"coerce_borrowed_pointer -- unify\");\n \tTyTy::BaseType *result\n-\t  = unify_site (receiver->get_ref (), TyTy::TyWithLocation (receiver),\n-\t\t\tTyTy::TyWithLocation (expected), locus);\n+\t  = unify_site_and (receiver->get_ref (),\n+\t\t\t    TyTy::TyWithLocation (receiver),\n+\t\t\t    TyTy::TyWithLocation (expected), locus,\n+\t\t\t    false /*emit_errors*/, true /*commit_if_ok*/,\n+\t\t\t    false /* FIXME infer do we want to allow this?? */,\n+\t\t\t    true /*cleanup_on_failure*/);\n \treturn CoercionResult{{}, result};\n       }\n     }"}, {"sha": "5a6dc64b3fccad848351fe0039e9a92a642a32f3", "filename": "gcc/rust/typecheck/rust-coercion.h", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/43a92787e3ff964ade498be3a6a1b6adc1f41087/gcc%2Frust%2Ftypecheck%2Frust-coercion.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/43a92787e3ff964ade498be3a6a1b6adc1f41087/gcc%2Frust%2Ftypecheck%2Frust-coercion.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-coercion.h?ref=43a92787e3ff964ade498be3a6a1b6adc1f41087", "patch": "@@ -69,7 +69,7 @@ class TypeCoercionRules : protected AutoderefCycle\n \n protected:\n   TypeCoercionRules (TyTy::BaseType *expected, Location locus, bool emit_errors,\n-\t\t     bool allow_autoderef);\n+\t\t     bool allow_autoderef, bool try_flag);\n \n   bool select (TyTy::BaseType &autoderefed) override;\n \n@@ -87,6 +87,7 @@ class TypeCoercionRules : protected AutoderefCycle\n   // mutable fields\n   CoercionResult try_result;\n   bool emit_errors;\n+  bool try_flag;\n };\n \n } // namespace Resolver"}, {"sha": "6e5ab7d7a90c7719211d12353e33b08a258106be", "filename": "gcc/rust/typecheck/rust-hir-dot-operator.cc", "status": "modified", "additions": 144, "deletions": 46, "changes": 190, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/43a92787e3ff964ade498be3a6a1b6adc1f41087/gcc%2Frust%2Ftypecheck%2Frust-hir-dot-operator.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/43a92787e3ff964ade498be3a6a1b6adc1f41087/gcc%2Frust%2Ftypecheck%2Frust-hir-dot-operator.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-dot-operator.cc?ref=43a92787e3ff964ade498be3a6a1b6adc1f41087", "patch": "@@ -19,6 +19,8 @@\n #include \"rust-hir-dot-operator.h\"\n #include \"rust-hir-path-probe.h\"\n #include \"rust-hir-trait-resolve.h\"\n+#include \"rust-hir-type-check-item.h\"\n+#include \"rust-coercion.h\"\n \n namespace Rust {\n namespace Resolver {\n@@ -55,6 +57,10 @@ MethodResolver::select (TyTy::BaseType &receiver)\n     TyTy::FnType *ty;\n   };\n \n+  const TyTy::BaseType *raw = receiver.destructure ();\n+  bool receiver_is_raw_ptr = raw->get_kind () == TyTy::TypeKind::POINTER;\n+  bool receiver_is_ref = raw->get_kind () == TyTy::TypeKind::REF;\n+\n   // assemble inherent impl items\n   std::vector<impl_item_candidate> inherent_impl_fns;\n   mappings->iterate_impl_items (\n@@ -86,6 +92,38 @@ MethodResolver::select (TyTy::BaseType &receiver)\n \n       rust_assert (ty->get_kind () == TyTy::TypeKind::FNDEF);\n       TyTy::FnType *fnty = static_cast<TyTy::FnType *> (ty);\n+      const TyTy::BaseType *impl_self\n+\t= TypeCheckItem::ResolveImplBlockSelf (*impl);\n+\n+      // see:\n+      // https://gcc-rust.zulipchat.com/#narrow/stream/266897-general/topic/Method.20Resolution/near/338646280\n+      // https://github.com/rust-lang/rust/blob/7eac88abb2e57e752f3302f02be5f3ce3d7adfb4/compiler/rustc_typeck/src/check/method/probe.rs#L650-L660\n+      bool impl_self_is_ptr = impl_self->get_kind () == TyTy::TypeKind::POINTER;\n+      bool impl_self_is_ref = impl_self->get_kind () == TyTy::TypeKind::REF;\n+      if (receiver_is_raw_ptr && impl_self_is_ptr)\n+\t{\n+\t  const TyTy::PointerType &sptr\n+\t    = *static_cast<const TyTy::PointerType *> (impl_self);\n+\t  const TyTy::PointerType &ptr\n+\t    = *static_cast<const TyTy::PointerType *> (raw);\n+\n+\t  // we could do this via lang-item assemblies if we refactor this\n+\t  bool mut_match = sptr.mutability () == ptr.mutability ();\n+\t  if (!mut_match)\n+\t    return true;\n+\t}\n+      else if (receiver_is_ref && impl_self_is_ref)\n+\t{\n+\t  const TyTy::ReferenceType &sptr\n+\t    = *static_cast<const TyTy::ReferenceType *> (impl_self);\n+\t  const TyTy::ReferenceType &ptr\n+\t    = *static_cast<const TyTy::ReferenceType *> (raw);\n+\n+\t  // we could do this via lang-item assemblies if we refactor this\n+\t  bool mut_match = sptr.mutability () == ptr.mutability ();\n+\t  if (!mut_match)\n+\t    return true;\n+\t}\n \n       inherent_impl_fns.push_back ({func, impl, fnty});\n \n@@ -133,6 +171,39 @@ MethodResolver::select (TyTy::BaseType &receiver)\n \n \trust_assert (ty->get_kind () == TyTy::TypeKind::FNDEF);\n \tTyTy::FnType *fnty = static_cast<TyTy::FnType *> (ty);\n+\tconst TyTy::BaseType *impl_self\n+\t  = TypeCheckItem::ResolveImplBlockSelf (*impl);\n+\n+\t// see:\n+\t// https://gcc-rust.zulipchat.com/#narrow/stream/266897-general/topic/Method.20Resolution/near/338646280\n+\t// https://github.com/rust-lang/rust/blob/7eac88abb2e57e752f3302f02be5f3ce3d7adfb4/compiler/rustc_typeck/src/check/method/probe.rs#L650-L660\n+\tbool impl_self_is_ptr\n+\t  = impl_self->get_kind () == TyTy::TypeKind::POINTER;\n+\tbool impl_self_is_ref = impl_self->get_kind () == TyTy::TypeKind::REF;\n+\tif (receiver_is_raw_ptr && impl_self_is_ptr)\n+\t  {\n+\t    const TyTy::PointerType &sptr\n+\t      = *static_cast<const TyTy::PointerType *> (impl_self);\n+\t    const TyTy::PointerType &ptr\n+\t      = *static_cast<const TyTy::PointerType *> (raw);\n+\n+\t    // we could do this via lang-item assemblies if we refactor this\n+\t    bool mut_match = sptr.mutability () == ptr.mutability ();\n+\t    if (!mut_match)\n+\t      continue;\n+\t  }\n+\telse if (receiver_is_ref && impl_self_is_ref)\n+\t  {\n+\t    const TyTy::ReferenceType &sptr\n+\t      = *static_cast<const TyTy::ReferenceType *> (impl_self);\n+\t    const TyTy::ReferenceType &ptr\n+\t      = *static_cast<const TyTy::ReferenceType *> (raw);\n+\n+\t    // we could do this via lang-item assemblies if we refactor this\n+\t    bool mut_match = sptr.mutability () == ptr.mutability ();\n+\t    if (!mut_match)\n+\t      continue;\n+\t  }\n \n \tinherent_impl_fns.push_back ({func, impl, fnty});\n \treturn true;\n@@ -170,18 +241,51 @@ MethodResolver::select (TyTy::BaseType &receiver)\n     TyTy::FnType *fntype;\n   };\n \n+  // https://github.com/rust-lang/rust/blob/7eac88abb2e57e752f3302f02be5f3ce3d7adfb4/compiler/rustc_typeck/src/check/method/probe.rs#L580-L694\n+\n   rust_debug (\"inherent_impl_fns found {%lu}, trait_fns found {%lu}, \"\n \t      \"predicate_items found {%lu}\",\n \t      (unsigned long) inherent_impl_fns.size (),\n \t      (unsigned long) trait_fns.size (),\n \t      (unsigned long) predicate_items.size ());\n \n-  // see the follow for the proper fix to get rid of this we need to assemble\n-  // candidates based on a match expression gathering the relevant impl blocks\n-  // https://github.com/rust-lang/rust/blob/7eac88abb2e57e752f3302f02be5f3ce3d7adfb4/compiler/rustc_typeck/src/check/method/probe.rs#L580-L694\n-  TyTy::set_cmp_autoderef_mode ();\n-\n   bool found_possible_candidate = false;\n+  for (const auto &predicate : predicate_items)\n+    {\n+      const TyTy::FnType *fn = predicate.fntype;\n+      rust_assert (fn->is_method ());\n+\n+      TyTy::BaseType *fn_self = fn->get_self_type ();\n+      rust_debug (\"dot-operator predicate fn_self={%s} can_eq receiver={%s}\",\n+\t\t  fn_self->debug_str ().c_str (),\n+\t\t  receiver.debug_str ().c_str ());\n+\n+      auto res = TypeCoercionRules::TryCoerce (&receiver, fn_self, Location (),\n+\t\t\t\t\t       false /*allow-autoderef*/);\n+      bool ok = !res.is_error ();\n+      if (ok)\n+\t{\n+\t  std::vector<Adjustment> adjs = append_adjustments (res.adjustments);\n+\t  const TraitReference *trait_ref\n+\t    = predicate.lookup.get_parent ()->get ();\n+\t  const TraitItemReference *trait_item\n+\t    = predicate.lookup.get_raw_item ();\n+\n+\t  PathProbeCandidate::TraitItemCandidate c{trait_ref, trait_item,\n+\t\t\t\t\t\t   nullptr};\n+\t  auto try_result = MethodCandidate{\n+\t    PathProbeCandidate (PathProbeCandidate::CandidateType::TRAIT_FUNC,\n+\t\t\t\tfn->clone (), trait_item->get_locus (), c),\n+\t    adjs};\n+\t  result.insert (std::move (try_result));\n+\t  found_possible_candidate = true;\n+\t}\n+    }\n+  if (found_possible_candidate)\n+    {\n+      return true;\n+    }\n+\n   for (auto &impl_item : inherent_impl_fns)\n     {\n       bool is_trait_impl_block = impl_item.impl_block->has_trait_ref ();\n@@ -195,21 +299,25 @@ MethodResolver::select (TyTy::BaseType &receiver)\n       rust_debug (\"dot-operator impl_item fn_self={%s} can_eq receiver={%s}\",\n \t\t  fn_self->debug_str ().c_str (),\n \t\t  receiver.debug_str ().c_str ());\n-      if (fn_self->can_eq (&receiver, false))\n+\n+      auto res = TypeCoercionRules::TryCoerce (&receiver, fn_self, Location (),\n+\t\t\t\t\t       false /*allow-autoderef*/);\n+      bool ok = !res.is_error ();\n+      if (ok)\n \t{\n+\t  std::vector<Adjustment> adjs = append_adjustments (res.adjustments);\n \t  PathProbeCandidate::ImplItemCandidate c{impl_item.item,\n \t\t\t\t\t\t  impl_item.impl_block};\n \t  auto try_result = MethodCandidate{\n \t    PathProbeCandidate (PathProbeCandidate::CandidateType::IMPL_FUNC,\n \t\t\t\tfn, impl_item.item->get_locus (), c),\n-\t    adjustments};\n+\t    adjs};\n \t  result.insert (std::move (try_result));\n \t  found_possible_candidate = true;\n \t}\n     }\n   if (found_possible_candidate)\n     {\n-      TyTy::reset_cmp_autoderef_mode ();\n       return true;\n     }\n \n@@ -226,21 +334,25 @@ MethodResolver::select (TyTy::BaseType &receiver)\n       rust_debug (\n \t\"dot-operator trait_impl_item fn_self={%s} can_eq receiver={%s}\",\n \tfn_self->debug_str ().c_str (), receiver.debug_str ().c_str ());\n-      if (fn_self->can_eq (&receiver, false))\n+\n+      auto res = TypeCoercionRules::TryCoerce (&receiver, fn_self, Location (),\n+\t\t\t\t\t       false /*allow-autoderef*/);\n+      bool ok = !res.is_error ();\n+      if (ok)\n \t{\n+\t  std::vector<Adjustment> adjs = append_adjustments (res.adjustments);\n \t  PathProbeCandidate::ImplItemCandidate c{impl_item.item,\n \t\t\t\t\t\t  impl_item.impl_block};\n \t  auto try_result = MethodCandidate{\n \t    PathProbeCandidate (PathProbeCandidate::CandidateType::IMPL_FUNC,\n \t\t\t\tfn, impl_item.item->get_locus (), c),\n-\t    adjustments};\n+\t    adjs};\n \t  result.insert (std::move (try_result));\n \t  found_possible_candidate = true;\n \t}\n     }\n   if (found_possible_candidate)\n     {\n-      TyTy::reset_cmp_autoderef_mode ();\n       return true;\n     }\n \n@@ -253,53 +365,25 @@ MethodResolver::select (TyTy::BaseType &receiver)\n       rust_debug (\"dot-operator trait_item fn_self={%s} can_eq receiver={%s}\",\n \t\t  fn_self->debug_str ().c_str (),\n \t\t  receiver.debug_str ().c_str ());\n-      if (fn_self->can_eq (&receiver, false))\n+\n+      auto res = TypeCoercionRules::TryCoerce (&receiver, fn_self, Location (),\n+\t\t\t\t\t       false /*allow-autoderef*/);\n+      bool ok = !res.is_error ();\n+      if (ok)\n \t{\n+\t  std::vector<Adjustment> adjs = append_adjustments (res.adjustments);\n \t  PathProbeCandidate::TraitItemCandidate c{trait_item.reference,\n \t\t\t\t\t\t   trait_item.item_ref,\n \t\t\t\t\t\t   nullptr};\n \t  auto try_result = MethodCandidate{\n \t    PathProbeCandidate (PathProbeCandidate::CandidateType::TRAIT_FUNC,\n \t\t\t\tfn, trait_item.item->get_locus (), c),\n-\t    adjustments};\n-\t  result.insert (std::move (try_result));\n-\t  found_possible_candidate = true;\n-\t}\n-    }\n-  if (found_possible_candidate)\n-    {\n-      TyTy::reset_cmp_autoderef_mode ();\n-      return true;\n-    }\n-\n-  for (const auto &predicate : predicate_items)\n-    {\n-      const TyTy::FnType *fn = predicate.fntype;\n-      rust_assert (fn->is_method ());\n-\n-      TyTy::BaseType *fn_self = fn->get_self_type ();\n-      rust_debug (\"dot-operator predicate fn_self={%s} can_eq receiver={%s}\",\n-\t\t  fn_self->debug_str ().c_str (),\n-\t\t  receiver.debug_str ().c_str ());\n-      if (fn_self->can_eq (&receiver, false))\n-\t{\n-\t  const TraitReference *trait_ref\n-\t    = predicate.lookup.get_parent ()->get ();\n-\t  const TraitItemReference *trait_item\n-\t    = predicate.lookup.get_raw_item ();\n-\n-\t  PathProbeCandidate::TraitItemCandidate c{trait_ref, trait_item,\n-\t\t\t\t\t\t   nullptr};\n-\t  auto try_result = MethodCandidate{\n-\t    PathProbeCandidate (PathProbeCandidate::CandidateType::TRAIT_FUNC,\n-\t\t\t\tfn->clone (), trait_item->get_locus (), c),\n-\t    adjustments};\n+\t    adjs};\n \t  result.insert (std::move (try_result));\n \t  found_possible_candidate = true;\n \t}\n     }\n \n-  TyTy::reset_cmp_autoderef_mode ();\n   return found_possible_candidate;\n }\n \n@@ -328,5 +412,19 @@ MethodResolver::get_predicate_items (\n   return predicate_items;\n }\n \n+std::vector<Adjustment>\n+MethodResolver::append_adjustments (const std::vector<Adjustment> &adjs) const\n+{\n+  std::vector<Adjustment> combined;\n+  combined.reserve (adjustments.size () + adjs.size ());\n+\n+  for (const auto &a : adjustments)\n+    combined.push_back (a);\n+  for (const auto &a : adjs)\n+    combined.push_back (a);\n+\n+  return combined;\n+}\n+\n } // namespace Resolver\n } // namespace Rust"}, {"sha": "db04ad8a56fb5af74e018f594ade6462f77be619", "filename": "gcc/rust/typecheck/rust-hir-dot-operator.h", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/43a92787e3ff964ade498be3a6a1b6adc1f41087/gcc%2Frust%2Ftypecheck%2Frust-hir-dot-operator.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/43a92787e3ff964ade498be3a6a1b6adc1f41087/gcc%2Frust%2Ftypecheck%2Frust-hir-dot-operator.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-dot-operator.h?ref=43a92787e3ff964ade498be3a6a1b6adc1f41087", "patch": "@@ -69,6 +69,10 @@ class MethodResolver : private TypeCheckBase, protected AutoderefCycle\n \n   bool select (TyTy::BaseType &receiver) override;\n \n+private:\n+  std::vector<Adjustment>\n+  append_adjustments (const std::vector<Adjustment> &adjustments) const;\n+\n private:\n   // search\n   const HIR::PathIdentSegment &segment_name;"}, {"sha": "a4098682668a9c2cb2c85bd70a04dbefa78a47e7", "filename": "gcc/rust/typecheck/rust-hir-type-check-expr.cc", "status": "modified", "additions": 9, "deletions": 2, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/43a92787e3ff964ade498be3a6a1b6adc1f41087/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-expr.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/43a92787e3ff964ade498be3a6a1b6adc1f41087/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-expr.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-expr.cc?ref=43a92787e3ff964ade498be3a6a1b6adc1f41087", "patch": "@@ -1027,6 +1027,8 @@ TypeCheckExpr::visit (HIR::MethodCallExpr &expr)\n \n   context->insert_receiver (expr.get_mappings ().get_hirid (), receiver_tyty);\n \n+  rust_debug_loc (expr.get_locus (), \"attempting to resolve method for %s\",\n+\t\t  receiver_tyty->debug_str ().c_str ());\n   auto candidates\n     = MethodResolver::Probe (receiver_tyty,\n \t\t\t     expr.get_method_name ().get_segment ());\n@@ -1053,13 +1055,17 @@ TypeCheckExpr::visit (HIR::MethodCallExpr &expr)\n \n   auto candidate = *candidates.begin ();\n   rust_debug_loc (expr.get_method_name ().get_locus (),\n-\t\t  \"resolved method to: {%u} {%s}\",\n+\t\t  \"resolved method to: {%u} {%s} with [%zu] adjustments\",\n \t\t  candidate.candidate.ty->get_ref (),\n-\t\t  candidate.candidate.ty->debug_str ().c_str ());\n+\t\t  candidate.candidate.ty->debug_str ().c_str (),\n+\t\t  candidate.adjustments.size ());\n \n   // Get the adjusted self\n   Adjuster adj (receiver_tyty);\n   TyTy::BaseType *adjusted_self = adj.adjust_type (candidate.adjustments);\n+  rust_debug (\"receiver: %s adjusted self %s\",\n+\t      receiver_tyty->debug_str ().c_str (),\n+\t      adjusted_self->debug_str ().c_str ());\n \n   // store the adjustments for code-generation to know what to do which must be\n   // stored onto the receiver to so as we don't trigger duplicate deref mappings\n@@ -1331,6 +1337,7 @@ TypeCheckExpr::visit (HIR::DereferenceExpr &expr)\n   TyTy::BaseType *resolved_base\n     = TypeCheckExpr::Resolve (expr.get_expr ().get ());\n \n+  rust_debug_loc (expr.get_locus (), \"attempting deref operator overload\");\n   auto lang_item_type = Analysis::RustLangItem::ItemType::DEREF;\n   bool operator_overloaded\n     = resolve_operator_overload (lang_item_type, expr, resolved_base, nullptr);"}, {"sha": "b2a70805e758d2f8a24deeaf05daa5ba4a9f6e9b", "filename": "gcc/testsuite/rust/compile/issue-1901.rs", "status": "added", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/43a92787e3ff964ade498be3a6a1b6adc1f41087/gcc%2Ftestsuite%2Frust%2Fcompile%2Fissue-1901.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/43a92787e3ff964ade498be3a6a1b6adc1f41087/gcc%2Ftestsuite%2Frust%2Fcompile%2Fissue-1901.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust%2Fcompile%2Fissue-1901.rs?ref=43a92787e3ff964ade498be3a6a1b6adc1f41087", "patch": "@@ -0,0 +1,33 @@\n+mod intrinsics {\n+    extern \"rust-intrinsic\" {\n+        pub fn offset<T>(ptr: *const T, count: isize) -> *const T;\n+    }\n+}\n+\n+mod ptr {\n+    #[lang = \"const_ptr\"]\n+    impl<T> *const T {\n+        pub unsafe fn offset(self, count: isize) -> *const T {\n+            intrinsics::offset(self, count)\n+        }\n+    }\n+\n+    #[lang = \"mut_ptr\"]\n+    impl<T> *mut T {\n+        pub unsafe fn offset(self, count: isize) -> *mut T {\n+            intrinsics::offset(self, count) as *mut T\n+        }\n+    }\n+}\n+\n+pub fn test_const(x: *const u8) {\n+    unsafe {\n+        x.offset(1);\n+    }\n+}\n+\n+pub fn test_mut(x: *mut u8) {\n+    unsafe {\n+        x.offset(1);\n+    }\n+}"}]}