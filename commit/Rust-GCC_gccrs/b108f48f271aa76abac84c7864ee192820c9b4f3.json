{"sha": "b108f48f271aa76abac84c7864ee192820c9b4f3", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjEwOGY0OGYyNzFhYTc2YWJhYzg0Yzc4NjRlZTE5MjgyMGM5YjRmMw==", "commit": {"author": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2014-07-14T07:36:39Z"}, "committer": {"name": "Jakub Jelinek", "email": "jakub@gcc.gnu.org", "date": "2014-07-14T07:36:39Z"}, "message": "re PR middle-end/61294 (erroneous memset used with constant zero length parameter warning)\n\n\tPR middle-end/61294\ngcc/c-family/\n\t* c.opt (Wmemset-transposed-args): New warning.\ngcc/c/\n\t* c-parser.c (c_parser_expr_list): Add new argument literal_zero_mask.\n\tIf non-NULL, call c_parser_check_literal_zero.\n\t(c_parser_check_literal_zero): New function.\n\t(c_parser_postfix_expression_after_primary): Adjust\n\tc_parser_expr_list caller, handle -Wmemset-transposed-args.\ngcc/cp/\n\t* cp-tree.h (LITERAL_ZERO_P): Define.\n\t* parser.c (cp_parser_parenthesized_expression_list): Add\n\twant_literal_zero_p argument, if true, for literal zeros\n\tinsert INTEGER_CSTs with LITERAL_ZERO_P flag set.\n\t(cp_parser_postfix_expression): Adjust\n\tcp_parser_parenthesized_expression_list caller, handle\n\t-Wmemset-transposed-args.\n\t(literal_zeros): New variable.\ngcc/\n\t* doc/invoke.texi (-Wmemset-transposed-args): Document.\ngcc/testsuite/\n\t* c-c++-common/Wmemset-transposed-args1.c: New test.\n\t* c-c++-common/Wmemset-transposed-args2.c: New test.\n\t* g++.dg/warn/Wmemset-transposed-args-1.C: New test.\n\nFrom-SVN: r212510", "tree": {"sha": "dbd4b3e580d9f04d3acff0c9ca3ccc78a6f522bc", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/dbd4b3e580d9f04d3acff0c9ca3ccc78a6f522bc"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b108f48f271aa76abac84c7864ee192820c9b4f3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b108f48f271aa76abac84c7864ee192820c9b4f3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b108f48f271aa76abac84c7864ee192820c9b4f3", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b108f48f271aa76abac84c7864ee192820c9b4f3/comments", "author": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "03e0ad94a21d03ed7b434d3451a53b1d8be4a061", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/03e0ad94a21d03ed7b434d3451a53b1d8be4a061", "html_url": "https://github.com/Rust-GCC/gccrs/commit/03e0ad94a21d03ed7b434d3451a53b1d8be4a061"}], "stats": {"total": 328, "additions": 318, "deletions": 10}, "files": [{"sha": "e68492f7b396c76327b967b16b70c5608810989b", "filename": "gcc/ChangeLog", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b108f48f271aa76abac84c7864ee192820c9b4f3/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b108f48f271aa76abac84c7864ee192820c9b4f3/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=b108f48f271aa76abac84c7864ee192820c9b4f3", "patch": "@@ -1,5 +1,8 @@\n 2014-07-14  Jakub Jelinek  <jakub@redhat.com>\n \n+\tPR middle-end/61294\n+\t* doc/invoke.texi (-Wmemset-transposed-args): Document.\n+\n \tPR target/61656\n \t* config/i386/i386.c (classify_argument): Don't merge classes above\n \tnumber of words."}, {"sha": "2cd29fe927f9c832cc4fd5ed8547d9c09b8635fe", "filename": "gcc/c-family/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b108f48f271aa76abac84c7864ee192820c9b4f3/gcc%2Fc-family%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b108f48f271aa76abac84c7864ee192820c9b4f3/gcc%2Fc-family%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2FChangeLog?ref=b108f48f271aa76abac84c7864ee192820c9b4f3", "patch": "@@ -1,3 +1,8 @@\n+2014-07-14  Jakub Jelinek  <jakub@redhat.com>\n+\n+\tPR middle-end/61294\n+\t* c.opt (Wmemset-transposed-args): New warning.\n+\n 2014-07-10  Jason Merrill  <jason@redhat.com>\n \n \tPR c++/61659"}, {"sha": "c318cad951d2b726ef63f14d782d0b96f9e981a4", "filename": "gcc/c-family/c.opt", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b108f48f271aa76abac84c7864ee192820c9b4f3/gcc%2Fc-family%2Fc.opt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b108f48f271aa76abac84c7864ee192820c9b4f3/gcc%2Fc-family%2Fc.opt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc.opt?ref=b108f48f271aa76abac84c7864ee192820c9b4f3", "patch": "@@ -518,6 +518,10 @@ Wmain\n LangEnabledBy(C ObjC C++ ObjC++,Wpedantic, 2, 0)\n ;\n \n+Wmemset-transposed-args\n+C ObjC C++ ObjC++ Var(warn_memset_transposed_args) Warning LangEnabledBy(C ObjC C++ ObjC++,Wall)\n+Warn about suspicious calls to memset where the third argument is constant literal zero and the second is not\n+\n Wmissing-braces\n C ObjC C++ ObjC++ Var(warn_missing_braces) Warning LangEnabledBy(C ObjC,Wall)\n Warn about possibly missing braces around initializers"}, {"sha": "260aa082a3c58205f8c9661671fbde6fdc388c97", "filename": "gcc/c/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b108f48f271aa76abac84c7864ee192820c9b4f3/gcc%2Fc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b108f48f271aa76abac84c7864ee192820c9b4f3/gcc%2Fc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc%2FChangeLog?ref=b108f48f271aa76abac84c7864ee192820c9b4f3", "patch": "@@ -1,3 +1,12 @@\n+2014-07-14  Jakub Jelinek  <jakub@redhat.com>\n+\n+\tPR middle-end/61294\n+\t* c-parser.c (c_parser_expr_list): Add new argument literal_zero_mask.\n+\tIf non-NULL, call c_parser_check_literal_zero.\n+\t(c_parser_check_literal_zero): New function.\n+\t(c_parser_postfix_expression_after_primary): Adjust\n+\tc_parser_expr_list caller, handle -Wmemset-transposed-args.\n+\n 2014-07-06  Marek Polacek  <polacek@redhat.com>\n \n \tPR c/6940"}, {"sha": "e32bf04187e4824c67b2b4d75111a0a8f9f13160", "filename": "gcc/c/c-parser.c", "status": "modified", "additions": 54, "deletions": 3, "changes": 57, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b108f48f271aa76abac84c7864ee192820c9b4f3/gcc%2Fc%2Fc-parser.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b108f48f271aa76abac84c7864ee192820c9b4f3/gcc%2Fc%2Fc-parser.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc%2Fc-parser.c?ref=b108f48f271aa76abac84c7864ee192820c9b4f3", "patch": "@@ -1204,7 +1204,8 @@ static struct c_expr c_parser_expression (c_parser *);\n static struct c_expr c_parser_expression_conv (c_parser *);\n static vec<tree, va_gc> *c_parser_expr_list (c_parser *, bool, bool,\n \t\t\t\t\t     vec<tree, va_gc> **, location_t *,\n-\t\t\t\t\t     tree *, vec<location_t> *);\n+\t\t\t\t\t     tree *, vec<location_t> *,\n+\t\t\t\t\t     unsigned int * = NULL);\n static void c_parser_omp_construct (c_parser *);\n static void c_parser_omp_threadprivate (c_parser *);\n static void c_parser_omp_barrier (c_parser *);\n@@ -7655,6 +7656,7 @@ c_parser_postfix_expression_after_primary (c_parser *parser,\n   tree ident, idx;\n   location_t sizeof_arg_loc[3];\n   tree sizeof_arg[3];\n+  unsigned int literal_zero_mask;\n   unsigned int i;\n   vec<tree, va_gc> *exprlist;\n   vec<tree, va_gc> *origtypes = NULL;\n@@ -7709,12 +7711,13 @@ c_parser_postfix_expression_after_primary (c_parser *parser,\n \t      sizeof_arg[i] = NULL_TREE;\n \t      sizeof_arg_loc[i] = UNKNOWN_LOCATION;\n \t    }\n+\t  literal_zero_mask = 0;\n \t  if (c_parser_next_token_is (parser, CPP_CLOSE_PAREN))\n \t    exprlist = NULL;\n \t  else\n \t    exprlist = c_parser_expr_list (parser, true, false, &origtypes,\n \t\t\t\t\t   sizeof_arg_loc, sizeof_arg,\n-\t\t\t\t\t   &arg_loc);\n+\t\t\t\t\t   &arg_loc, &literal_zero_mask);\n \t  c_parser_skip_until_found (parser, CPP_CLOSE_PAREN,\n \t\t\t\t     \"expected %<)%>\");\n \t  orig_expr = expr;\n@@ -7724,6 +7727,19 @@ c_parser_postfix_expression_after_primary (c_parser *parser,\n \t\t\t\t\t      expr.value, exprlist,\n \t\t\t\t\t      sizeof_arg,\n \t\t\t\t\t      sizeof_ptr_memacc_comptypes);\n+\t  if (warn_memset_transposed_args\n+\t      && TREE_CODE (expr.value) == FUNCTION_DECL\n+\t      && DECL_BUILT_IN_CLASS (expr.value) == BUILT_IN_NORMAL\n+\t      && DECL_FUNCTION_CODE (expr.value) == BUILT_IN_MEMSET\n+\t      && vec_safe_length (exprlist) == 3\n+\t      && integer_zerop ((*exprlist)[2])\n+\t      && (literal_zero_mask & (1 << 2)) != 0\n+\t      && (!integer_zerop ((*exprlist)[1])\n+\t\t  || (literal_zero_mask & (1 << 1)) == 0))\n+\t    warning_at (expr_loc, OPT_Wmemset_transposed_args,\n+\t\t\t\"%<memset%> used with constant zero length parameter; \"\n+\t\t\t\"this could be due to transposed parameters\");\n+\n \t  expr.value\n \t    = c_build_function_call_vec (expr_loc, arg_loc, expr.value,\n \t\t\t\t\t exprlist, origtypes);\n@@ -7891,6 +7907,36 @@ c_parser_expression_conv (c_parser *parser)\n   return expr;\n }\n \n+/* Helper function of c_parser_expr_list.  Check if IDXth (0 based)\n+   argument is a literal zero alone and if so, set it in literal_zero_mask.  */\n+\n+static inline void\n+c_parser_check_literal_zero (c_parser *parser, unsigned *literal_zero_mask,\n+\t\t\t     unsigned int idx)\n+{\n+  if (idx >= HOST_BITS_PER_INT)\n+    return;\n+\n+  c_token *tok = c_parser_peek_token (parser);\n+  switch (tok->type)\n+    {\n+    case CPP_NUMBER:\n+    case CPP_CHAR:\n+    case CPP_WCHAR:\n+    case CPP_CHAR16:\n+    case CPP_CHAR32:\n+      /* If a parameter is literal zero alone, remember it\n+\t for -Wmemset-transposed-args warning.  */\n+      if (integer_zerop (tok->value)\n+\t  && !TREE_OVERFLOW (tok->value)\n+\t  && (c_parser_peek_2nd_token (parser)->type == CPP_COMMA\n+\t      || c_parser_peek_2nd_token (parser)->type == CPP_CLOSE_PAREN))\n+\t*literal_zero_mask |= 1U << idx;\n+    default:\n+      break;\n+    }\n+}\n+\n /* Parse a non-empty list of expressions.  If CONVERT_P, convert\n    functions and arrays to pointers and lvalues to rvalues.  If\n    FOLD_P, fold the expressions.  If LOCATIONS is non-NULL, save the\n@@ -7905,7 +7951,8 @@ static vec<tree, va_gc> *\n c_parser_expr_list (c_parser *parser, bool convert_p, bool fold_p,\n \t\t    vec<tree, va_gc> **p_orig_types,\n \t\t    location_t *sizeof_arg_loc, tree *sizeof_arg,\n-\t\t    vec<location_t> *locations)\n+\t\t    vec<location_t> *locations,\n+\t\t    unsigned int *literal_zero_mask)\n {\n   vec<tree, va_gc> *ret;\n   vec<tree, va_gc> *orig_types;\n@@ -7923,6 +7970,8 @@ c_parser_expr_list (c_parser *parser, bool convert_p, bool fold_p,\n   if (sizeof_arg != NULL\n       && c_parser_next_token_is_keyword (parser, RID_SIZEOF))\n     cur_sizeof_arg_loc = c_parser_peek_2nd_token (parser)->location;\n+  if (literal_zero_mask)\n+    c_parser_check_literal_zero (parser, literal_zero_mask, 0);\n   expr = c_parser_expr_no_commas (parser, NULL);\n   if (convert_p)\n     expr = convert_lvalue_to_rvalue (loc, expr, true, true);\n@@ -7949,6 +7998,8 @@ c_parser_expr_list (c_parser *parser, bool convert_p, bool fold_p,\n \tcur_sizeof_arg_loc = c_parser_peek_2nd_token (parser)->location;\n       else\n \tcur_sizeof_arg_loc = UNKNOWN_LOCATION;\n+      if (literal_zero_mask)\n+\tc_parser_check_literal_zero (parser, literal_zero_mask, idx + 1);\n       expr = c_parser_expr_no_commas (parser, NULL);\n       if (convert_p)\n \texpr = convert_lvalue_to_rvalue (loc, expr, true, true);"}, {"sha": "98af8db9c4b4803195c3a32234542816b41b51fb", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b108f48f271aa76abac84c7864ee192820c9b4f3/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b108f48f271aa76abac84c7864ee192820c9b4f3/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=b108f48f271aa76abac84c7864ee192820c9b4f3", "patch": "@@ -1,3 +1,15 @@\n+2014-07-14  Jakub Jelinek  <jakub@redhat.com>\n+\n+\tPR middle-end/61294\n+\t* cp-tree.h (LITERAL_ZERO_P): Define.\n+\t* parser.c (cp_parser_parenthesized_expression_list): Add\n+\twant_literal_zero_p argument, if true, for literal zeros\n+\tinsert INTEGER_CSTs with LITERAL_ZERO_P flag set.\n+\t(cp_parser_postfix_expression): Adjust\n+\tcp_parser_parenthesized_expression_list caller, handle\n+\t-Wmemset-transposed-args.\n+\t(literal_zeros): New variable.\n+\n 2014-07-13  Jason Merrill  <jason@redhat.com>\n \n \tPR c++/58511"}, {"sha": "091d20feee5bb145a2b7f2293a5d4f2df91feca3", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b108f48f271aa76abac84c7864ee192820c9b4f3/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b108f48f271aa76abac84c7864ee192820c9b4f3/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=b108f48f271aa76abac84c7864ee192820c9b4f3", "patch": "@@ -4187,6 +4187,10 @@ more_aggr_init_expr_args_p (const aggr_init_expr_arg_iterator *iter)\n #define SIZEOF_EXPR_TYPE_P(NODE) \\\n   TREE_LANG_FLAG_0 (SIZEOF_EXPR_CHECK (NODE))\n \n+/* True if INTEGER_CST is a zero literal seen in function argument list.  */\n+#define LITERAL_ZERO_P(NODE) \\\n+  (INTEGER_CST_CHECK (NODE)->base.nothrow_flag)\n+\n /* An enumeration of the kind of tags that C++ accepts.  */\n enum tag_types {\n   none_type = 0, /* Not a tag type.  */"}, {"sha": "55dd29f002c69e6e92458fdd29c3abdfc9caa3cb", "filename": "gcc/cp/parser.c", "status": "modified", "additions": 81, "deletions": 5, "changes": 86, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b108f48f271aa76abac84c7864ee192820c9b4f3/gcc%2Fcp%2Fparser.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b108f48f271aa76abac84c7864ee192820c9b4f3/gcc%2Fcp%2Fparser.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparser.c?ref=b108f48f271aa76abac84c7864ee192820c9b4f3", "patch": "@@ -1929,7 +1929,7 @@ static tree cp_parser_postfix_open_square_expression\n static tree cp_parser_postfix_dot_deref_expression\n   (cp_parser *, enum cpp_ttype, tree, bool, cp_id_kind *, location_t);\n static vec<tree, va_gc> *cp_parser_parenthesized_expression_list\n-  (cp_parser *, int, bool, bool, bool *);\n+  (cp_parser *, int, bool, bool, bool *, bool = false);\n /* Values for the second parameter of cp_parser_parenthesized_expression_list.  */\n enum { non_attr = 0, normal_attr = 1, id_attr = 2 };\n static void cp_parser_pseudo_destructor_name\n@@ -6078,7 +6078,8 @@ cp_parser_postfix_expression (cp_parser *parser, bool address_p, bool cast_p,\n \t    args = (cp_parser_parenthesized_expression_list\n \t\t    (parser, non_attr,\n \t\t     /*cast_p=*/false, /*allow_expansion_p=*/true,\n-\t\t     /*non_constant_p=*/NULL));\n+\t\t     /*non_constant_p=*/NULL,\n+\t\t     /*want_literal_zero_p=*/warn_memset_transposed_args));\n \t    if (is_builtin_constant_p)\n \t      {\n \t\tparser->integral_constant_expression_p\n@@ -6146,6 +6147,30 @@ cp_parser_postfix_expression (cp_parser *parser, bool address_p, bool cast_p,\n \t\t  }\n \t      }\n \n+\t    if (warn_memset_transposed_args)\n+\t      {\n+\t\tif (TREE_CODE (postfix_expression) == FUNCTION_DECL\n+\t\t    && DECL_BUILT_IN_CLASS (postfix_expression) == BUILT_IN_NORMAL\n+\t\t    && DECL_FUNCTION_CODE (postfix_expression) == BUILT_IN_MEMSET\n+\t\t    && vec_safe_length (args) == 3\n+\t\t    && integer_zerop ((*args)[2])\n+\t\t    && LITERAL_ZERO_P ((*args)[2])\n+\t\t    && !(integer_zerop ((*args)[1])\n+\t\t\t && LITERAL_ZERO_P ((*args)[1])))\n+\t\t  warning (OPT_Wmemset_transposed_args,\n+\t\t\t   \"%<memset%> used with constant zero length \"\n+\t\t\t   \"parameter; this could be due to transposed \"\n+\t\t\t   \"parameters\");\n+\n+\t\t/* Replace LITERAL_ZERO_P INTEGER_CSTs with normal ones\n+\t\t   to avoid leaking those into folder and middle-end.  */\n+\t\tunsigned int i;\n+\t\ttree arg;\n+\t\tFOR_EACH_VEC_SAFE_ELT (args, i, arg)\n+\t\t  if (TREE_CODE (arg) == INTEGER_CST && LITERAL_ZERO_P (arg))\n+\t\t    (*args)[i] = build_int_cst (TREE_TYPE (arg), 0);\n+\t      }\n+\n \t    if (TREE_CODE (postfix_expression) == COMPONENT_REF)\n \t      {\n \t\ttree instance = TREE_OPERAND (postfix_expression, 0);\n@@ -6634,6 +6659,10 @@ cp_parser_postfix_dot_deref_expression (cp_parser *parser,\n   return postfix_expression;\n }\n \n+/* Cache of LITERAL_ZERO_P constants.  */\n+\n+static GTY(()) tree literal_zeros[itk_none];\n+\n /* Parse a parenthesized expression-list.\n \n    expression-list:\n@@ -6658,14 +6687,18 @@ cp_parser_postfix_dot_deref_expression (cp_parser *parser,\n    plain identifier argument, normal_attr for an attribute that wants\n    an expression, or non_attr if we aren't parsing an attribute list.  If\n    NON_CONSTANT_P is non-NULL, *NON_CONSTANT_P indicates whether or\n-   not all of the expressions in the list were constant.  */\n+   not all of the expressions in the list were constant.\n+   WANT_LITERAL_ZERO_P is true if the caller is interested in\n+   LITERAL_ZERO_P INTEGER_CSTs.  FIXME: once we don't fold everything\n+   immediately, this can be removed.  */\n \n static vec<tree, va_gc> *\n cp_parser_parenthesized_expression_list (cp_parser* parser,\n \t\t\t\t\t int is_attribute_list,\n \t\t\t\t\t bool cast_p,\n                                          bool allow_expansion_p,\n-\t\t\t\t\t bool *non_constant_p)\n+\t\t\t\t\t bool *non_constant_p,\n+\t\t\t\t\t bool want_literal_zero_p)\n {\n   vec<tree, va_gc> *expression_list;\n   bool fold_expr_p = is_attribute_list != non_attr;\n@@ -6728,7 +6761,50 @@ cp_parser_parenthesized_expression_list (cp_parser* parser,\n \t\t  *non_constant_p = true;\n \t      }\n \t    else\n-\t      expr = cp_parser_assignment_expression (parser, cast_p, NULL);\n+\t      {\n+\t\texpr = NULL_TREE;\n+\t\tcp_token *tok = cp_lexer_peek_token (parser->lexer);\n+\t\tswitch (tok->type)\n+\t\t  {\n+\t\t  case CPP_NUMBER:\n+\t\t  case CPP_CHAR:\n+\t\t  case CPP_WCHAR:\n+\t\t  case CPP_CHAR16:\n+\t\t  case CPP_CHAR32:\n+\t\t    /* If a parameter is literal zero alone, remember it\n+\t\t       for -Wmemset-transposed-args warning.  */\n+\t\t    if (integer_zerop (tok->u.value)\n+\t\t\t&& !TREE_OVERFLOW (tok->u.value)\n+\t\t\t&& want_literal_zero_p\n+\t\t\t&& (cp_lexer_peek_nth_token (parser->lexer, 2)->type\n+\t\t\t    == CPP_COMMA\n+\t\t\t    || cp_lexer_peek_nth_token (parser->lexer, 2)->type\n+\t\t\t       == CPP_CLOSE_PAREN))\n+\t\t      {\n+\t\t\tunsigned int i;\n+\t\t\tfor (i = 0; i < itk_none; ++i)\n+\t\t\t  if (TREE_TYPE (tok->u.value) == integer_types[i])\n+\t\t\t    break;\n+\t\t\tif (i < itk_none && literal_zeros[i])\n+\t\t\t  expr = literal_zeros[i];\n+\t\t\telse\n+\t\t\t  {\n+\t\t\t    expr = copy_node (tok->u.value);\n+\t\t\t    LITERAL_ZERO_P (expr) = 1;\n+\t\t\t    if (i < itk_none)\n+\t\t\t      literal_zeros[i] = expr;\n+\t\t\t  }\n+\t\t\t/* Consume the 0 token (or '\\0', 0LL etc.).  */\n+\t\t\tcp_lexer_consume_token (parser->lexer);\n+\t\t      }\n+\t\t    break;\n+\t\t  default:\n+\t\t    break;\n+\t\t  }\n+\t\tif (expr == NULL_TREE)\n+\t\t  expr = cp_parser_assignment_expression (parser, cast_p,\n+\t\t\t\t\t\t\t  NULL);\n+\t      }\n \n \t    if (fold_expr_p)\n \t      expr = fold_non_dependent_expr (expr);"}, {"sha": "3473b7b41551078b35c937a804daaf852e3bd451", "filename": "gcc/doc/invoke.texi", "status": "modified", "additions": 14, "deletions": 2, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b108f48f271aa76abac84c7864ee192820c9b4f3/gcc%2Fdoc%2Finvoke.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b108f48f271aa76abac84c7864ee192820c9b4f3/gcc%2Fdoc%2Finvoke.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Finvoke.texi?ref=b108f48f271aa76abac84c7864ee192820c9b4f3", "patch": "@@ -258,8 +258,8 @@ Objective-C and Objective-C++ Dialects}.\n -Wno-int-to-pointer-cast -Wno-invalid-offsetof @gol\n -Winvalid-pch -Wlarger-than=@var{len}  -Wunsafe-loop-optimizations @gol\n -Wlogical-op -Wlogical-not-parentheses -Wlong-long @gol\n--Wmain -Wmaybe-uninitialized -Wmissing-braces  -Wmissing-field-initializers @gol\n--Wmissing-include-dirs @gol\n+-Wmain -Wmaybe-uninitialized -Wmemset-transposed-args -Wmissing-braces @gol\n+-Wmissing-field-initializers -Wmissing-include-dirs @gol\n -Wno-multichar  -Wnonnull  -Wodr  -Wno-overflow  -Wopenmp-simd @gol\n -Woverlength-strings  -Wpacked  -Wpacked-bitfield-compat  -Wpadded @gol\n -Wparentheses  -Wpedantic-ms-format -Wno-pedantic-ms-format @gol\n@@ -4694,6 +4694,18 @@ Warn when the @code{sizeof} operator is applied to a parameter that is\n declared as an array in a function definition.  This warning is enabled by\n default for C and C++ programs.\n \n+@item -Wmemset-transposed-args\n+@opindex Wmemset-transposed-args\n+@opindex Wno-memset-transposed-args\n+Warn for suspicious calls to the @code{memset} built-in function, if the\n+second argument is not zero and the third argument is zero.  This warns e.g.@\n+about @code{memset (buf, sizeof buf, 0)} where most probably\n+@code{memset (buf, 0, sizeof buf)} was meant instead.  The diagnostics\n+is only emitted if the third argument is literal zero, if it is some expression\n+that is folded to zero, or e.g. a cast of zero to some type etc., it\n+is far less likely that user has mistakenly exchanged the arguments and\n+no warning is emitted.  This warning is enabled by @option{-Wall}.\n+\n @item -Waddress\n @opindex Waddress\n @opindex Wno-address"}, {"sha": "a8fe5e47cccc79264cfccde0caadc707b7dd2b92", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b108f48f271aa76abac84c7864ee192820c9b4f3/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b108f48f271aa76abac84c7864ee192820c9b4f3/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=b108f48f271aa76abac84c7864ee192820c9b4f3", "patch": "@@ -1,3 +1,10 @@\n+2014-07-14  Jakub Jelinek  <jakub@redhat.com>\n+\n+\tPR middle-end/61294\n+\t* c-c++-common/Wmemset-transposed-args1.c: New test.\n+\t* c-c++-common/Wmemset-transposed-args2.c: New test.\n+\t* g++.dg/warn/Wmemset-transposed-args-1.C: New test.\n+\n 2014-07-13  Jan Hubicka  <hubicka@ucw.cz>\n \n \t* gcc.dg/pr36901.h: Simplify because non-zero symbol folding no"}, {"sha": "d188d6f7c2b35b6b29db1c572899eb122f8ddac9", "filename": "gcc/testsuite/c-c++-common/Wmemset-transposed-args1.c", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b108f48f271aa76abac84c7864ee192820c9b4f3/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2FWmemset-transposed-args1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b108f48f271aa76abac84c7864ee192820c9b4f3/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2FWmemset-transposed-args1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2FWmemset-transposed-args1.c?ref=b108f48f271aa76abac84c7864ee192820c9b4f3", "patch": "@@ -0,0 +1,31 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-Wall\" } */\n+\n+typedef __SIZE_TYPE__ size_t;\n+extern\n+#ifdef __cplusplus\n+\"C\"\n+#endif\n+void *memset (void *, int, size_t);\n+char buf[1024];\n+\n+void\n+foo ()\n+{\n+  memset (buf, sizeof buf, 0);\t/* { dg-warning \".memset. used with constant zero length parameter; this could be due to transposed parameters\" } */\n+  memset (buf, sizeof buf, '\\0'); /* { dg-warning \".memset. used with constant zero length parameter; this could be due to transposed parameters\" } */\n+  memset (buf, sizeof buf, L'\\0'); /* { dg-warning \".memset. used with constant zero length parameter; this could be due to transposed parameters\" } */\n+  memset (buf, 1, 1 - 1);\n+  memset (buf, 1, 0 - 0);\n+  memset (buf, 0, 0);\n+  memset (buf, '\\0', 0);\n+  memset (buf, L'\\0', 0);\n+  memset (buf, 1 - 1, 0); /* { dg-warning \".memset. used with constant zero length parameter; this could be due to transposed parameters\" } */\n+  memset (buf, 0 - 0, 0); /* { dg-warning \".memset. used with constant zero length parameter; this could be due to transposed parameters\" } */\n+  memset (buf, sizeof buf, 0L);\t/* { dg-warning \".memset. used with constant zero length parameter; this could be due to transposed parameters\" } */\n+  memset (buf, sizeof buf, 0UL); /* { dg-warning \".memset. used with constant zero length parameter; this could be due to transposed parameters\" } */\n+  memset (buf, sizeof buf, 0LL); /* { dg-warning \".memset. used with constant zero length parameter; this could be due to transposed parameters\" } */\n+  memset (buf, sizeof buf, 0ULL); /* { dg-warning \".memset. used with constant zero length parameter; this could be due to transposed parameters\" } */\n+  memset (buf, sizeof buf, (int) 0);\n+  memset (buf, sizeof buf, -0);\n+}"}, {"sha": "8647138cfc9183e5f57daf5283729096dafb08e0", "filename": "gcc/testsuite/c-c++-common/Wmemset-transposed-args2.c", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b108f48f271aa76abac84c7864ee192820c9b4f3/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2FWmemset-transposed-args2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b108f48f271aa76abac84c7864ee192820c9b4f3/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2FWmemset-transposed-args2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2FWmemset-transposed-args2.c?ref=b108f48f271aa76abac84c7864ee192820c9b4f3", "patch": "@@ -0,0 +1,20 @@\n+/* { dg-do compile { target { c || c++11 } } } */\n+/* { dg-options \"-Wall\" } */\n+/* { dg-additional-options \"-std=gnu99\" { target c } } */\n+\n+typedef __SIZE_TYPE__ size_t;\n+extern\n+#ifdef __cplusplus\n+\"C\"\n+#endif\n+void *memset (void *, int, size_t);\n+char buf[1024];\n+\n+void\n+foo ()\n+{\n+  memset (buf, sizeof buf, u'\\0'); /* { dg-warning \".memset. used with constant zero length parameter; this could be due to transposed parameters\" } */\n+  memset (buf, sizeof buf, U'\\0'); /* { dg-warning \".memset. used with constant zero length parameter; this could be due to transposed parameters\" } */\n+  memset (buf, u'\\0', 0);\n+  memset (buf, U'\\0', 0);\n+}"}, {"sha": "89d3edf9663dbfbf4c1cc78b49a33bd7ec4637af", "filename": "gcc/testsuite/g++.dg/warn/Wmemset-transposed-args-1.C", "status": "added", "additions": 74, "deletions": 0, "changes": 74, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b108f48f271aa76abac84c7864ee192820c9b4f3/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fwarn%2FWmemset-transposed-args-1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b108f48f271aa76abac84c7864ee192820c9b4f3/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fwarn%2FWmemset-transposed-args-1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fwarn%2FWmemset-transposed-args-1.C?ref=b108f48f271aa76abac84c7864ee192820c9b4f3", "patch": "@@ -0,0 +1,74 @@\n+// { dg-do compile }\n+// { dg-options \"-Wall\" }\n+\n+typedef __SIZE_TYPE__ size_t;\n+extern \"C\" void *memset (void *, int, size_t);\n+char buf[1024];\n+namespace std\n+{\n+  extern \"C\" void *memset (void *, int, size_t);\n+}\n+\n+template <int N>\n+void\n+foo ()\n+{\n+  memset (buf, sizeof buf, 0);\t/* { dg-warning \".memset. used with constant zero length parameter; this could be due to transposed parameters\" } */\n+  memset (buf, sizeof buf, '\\0'); /* { dg-warning \".memset. used with constant zero length parameter; this could be due to transposed parameters\" } */\n+  memset (buf, sizeof buf, L'\\0'); /* { dg-warning \".memset. used with constant zero length parameter; this could be due to transposed parameters\" } */\n+  memset (buf, sizeof buf, N);\n+  memset (buf, 1, 1 - 1);\n+  memset (buf, 1, 0 - 0);\n+  memset (buf, 1, N - N);\n+  memset (buf, 0, 0);\n+  memset (buf, 1 - 1, 0); /* { dg-warning \".memset. used with constant zero length parameter; this could be due to transposed parameters\" } */\n+  memset (buf, 0 - 0, 0); /* { dg-warning \".memset. used with constant zero length parameter; this could be due to transposed parameters\" } */\n+  memset (buf, sizeof buf, 0L);\t/* { dg-warning \".memset. used with constant zero length parameter; this could be due to transposed parameters\" } */\n+  memset (buf, sizeof buf, 0UL); /* { dg-warning \".memset. used with constant zero length parameter; this could be due to transposed parameters\" } */\n+  memset (buf, sizeof buf, 0LL); /* { dg-warning \".memset. used with constant zero length parameter; this could be due to transposed parameters\" } */\n+  memset (buf, sizeof buf, 0ULL); /* { dg-warning \".memset. used with constant zero length parameter; this could be due to transposed parameters\" } */\n+  memset (buf, sizeof buf, (int) 0);\n+  memset (buf, sizeof buf, -0);\n+}\n+\n+template <int N>\n+void\n+baz ()\n+{\n+  std::memset (buf, sizeof buf, 0);\t/* { dg-warning \".memset. used with constant zero length parameter; this could be due to transposed parameters\" } */\n+  std::memset (buf, sizeof buf, '\\0'); /* { dg-warning \".memset. used with constant zero length parameter; this could be due to transposed parameters\" } */\n+  std::memset (buf, sizeof buf, L'\\0'); /* { dg-warning \".memset. used with constant zero length parameter; this could be due to transposed parameters\" } */\n+  std::memset (buf, sizeof buf, N);\n+  std::memset (buf, 1, 1 - 1);\n+  std::memset (buf, 1, 0 - 0);\n+  std::memset (buf, 1, N - N);\n+  std::memset (buf, 0, 0);\n+  std::memset (buf, 1 - 1, 0); /* { dg-warning \".memset. used with constant zero length parameter; this could be due to transposed parameters\" } */\n+  std::memset (buf, 0 - 0, 0); /* { dg-warning \".memset. used with constant zero length parameter; this could be due to transposed parameters\" } */\n+  std::memset (buf, sizeof buf, 0L);\t/* { dg-warning \".memset. used with constant zero length parameter; this could be due to transposed parameters\" } */\n+  std::memset (buf, sizeof buf, 0UL); /* { dg-warning \".memset. used with constant zero length parameter; this could be due to transposed parameters\" } */\n+  std::memset (buf, sizeof buf, 0LL); /* { dg-warning \".memset. used with constant zero length parameter; this could be due to transposed parameters\" } */\n+  std::memset (buf, sizeof buf, 0ULL); /* { dg-warning \".memset. used with constant zero length parameter; this could be due to transposed parameters\" } */\n+  std::memset (buf, sizeof buf, (int) 0);\n+  std::memset (buf, sizeof buf, -0);\n+}\n+\n+void\n+bar ()\n+{\n+  foo<0> ();\n+  std::memset (buf, sizeof buf, 0);\t/* { dg-warning \".memset. used with constant zero length parameter; this could be due to transposed parameters\" } */\n+  std::memset (buf, sizeof buf, '\\0'); /* { dg-warning \".memset. used with constant zero length parameter; this could be due to transposed parameters\" } */\n+  std::memset (buf, sizeof buf, L'\\0'); /* { dg-warning \".memset. used with constant zero length parameter; this could be due to transposed parameters\" } */\n+  std::memset (buf, 1, 1 - 1);\n+  std::memset (buf, 1, 0 - 0);\n+  std::memset (buf, 0, 0);\n+  std::memset (buf, 1 - 1, 0); /* { dg-warning \".memset. used with constant zero length parameter; this could be due to transposed parameters\" } */\n+  std::memset (buf, 0 - 0, 0); /* { dg-warning \".memset. used with constant zero length parameter; this could be due to transposed parameters\" } */\n+  std::memset (buf, sizeof buf, 0L);\t/* { dg-warning \".memset. used with constant zero length parameter; this could be due to transposed parameters\" } */\n+  std::memset (buf, sizeof buf, 0UL); /* { dg-warning \".memset. used with constant zero length parameter; this could be due to transposed parameters\" } */\n+  std::memset (buf, sizeof buf, 0LL); /* { dg-warning \".memset. used with constant zero length parameter; this could be due to transposed parameters\" } */\n+  std::memset (buf, sizeof buf, 0ULL); /* { dg-warning \".memset. used with constant zero length parameter; this could be due to transposed parameters\" } */\n+  std::memset (buf, sizeof buf, (int) 0);\n+  std::memset (buf, sizeof buf, -0);\n+}"}]}