{"sha": "68d3ff9044377af9aecfbcb8953205c9a7a8f71f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NjhkM2ZmOTA0NDM3N2FmOWFlY2ZiY2I4OTUzMjA1YzlhN2E4ZjcxZg==", "commit": {"author": {"name": "Tobias Grosser", "email": "grosser@fim.uni-passau.de", "date": "2010-03-08T17:49:36Z"}, "committer": {"name": "Sebastian Pop", "email": "spop@gcc.gnu.org", "date": "2010-03-08T17:49:36Z"}, "message": "Fix type problems in loop ivs.\n\nFix pr42644.\nFix pr42130 (dealII).\n\n2010-03-03  Tobias Grosser  <grosser@fim.uni-passau.de>\n\n\t* gcc/graphite-clast-to-gimple.c (clast_to_gcc_expression): Also\n\thandle conversions from pointer to integers.\n\t(gcc_type_for_cloog_iv): Choose the smalles signed integer as an\n\tinduction variable, to be able to work with code generated by\n\tCLooG.\n\t* gcc/graphite-sese-to-poly.c (scop_ivs_can_be_represented): New.\n\t(build_poly_scop): Bail out if we cannot codegen a loop.\n\t* gcc/testsuite/gcc.dg/graphite/id-18.c: New.\n\t* gcc/testsuite/gcc.dg/graphite/run-id-pr42644.c: New.\n\t* libgomp/testsuite/libgomp.graphite/force-parallel-1.c: Adjust.\n\t* libgomp/testsuite/libgomp.graphite/force-parallel-2.c: Adjust.\n\nFrom-SVN: r157286", "tree": {"sha": "6a1a47eb427ba78c11b008b0e38679bf05584a5c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6a1a47eb427ba78c11b008b0e38679bf05584a5c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/68d3ff9044377af9aecfbcb8953205c9a7a8f71f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/68d3ff9044377af9aecfbcb8953205c9a7a8f71f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/68d3ff9044377af9aecfbcb8953205c9a7a8f71f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/68d3ff9044377af9aecfbcb8953205c9a7a8f71f/comments", "author": {"login": "tobiasgrosser", "id": 521960, "node_id": "MDQ6VXNlcjUyMTk2MA==", "avatar_url": "https://avatars.githubusercontent.com/u/521960?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tobiasgrosser", "html_url": "https://github.com/tobiasgrosser", "followers_url": "https://api.github.com/users/tobiasgrosser/followers", "following_url": "https://api.github.com/users/tobiasgrosser/following{/other_user}", "gists_url": "https://api.github.com/users/tobiasgrosser/gists{/gist_id}", "starred_url": "https://api.github.com/users/tobiasgrosser/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tobiasgrosser/subscriptions", "organizations_url": "https://api.github.com/users/tobiasgrosser/orgs", "repos_url": "https://api.github.com/users/tobiasgrosser/repos", "events_url": "https://api.github.com/users/tobiasgrosser/events{/privacy}", "received_events_url": "https://api.github.com/users/tobiasgrosser/received_events", "type": "User", "site_admin": false}, "committer": {"login": "sebpop", "id": 568397, "node_id": "MDQ6VXNlcjU2ODM5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/568397?v=4", "gravatar_id": "", "url": "https://api.github.com/users/sebpop", "html_url": "https://github.com/sebpop", "followers_url": "https://api.github.com/users/sebpop/followers", "following_url": "https://api.github.com/users/sebpop/following{/other_user}", "gists_url": "https://api.github.com/users/sebpop/gists{/gist_id}", "starred_url": "https://api.github.com/users/sebpop/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/sebpop/subscriptions", "organizations_url": "https://api.github.com/users/sebpop/orgs", "repos_url": "https://api.github.com/users/sebpop/repos", "events_url": "https://api.github.com/users/sebpop/events{/privacy}", "received_events_url": "https://api.github.com/users/sebpop/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e3f81db10f5c278a75b7e9c76db402ee6e5c73e2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e3f81db10f5c278a75b7e9c76db402ee6e5c73e2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e3f81db10f5c278a75b7e9c76db402ee6e5c73e2"}], "stats": {"total": 146, "additions": 137, "deletions": 9}, "files": [{"sha": "64ddbb8ed911a939beee6968ce54540a77482a27", "filename": "gcc/graphite-clast-to-gimple.c", "status": "modified", "additions": 60, "deletions": 7, "changes": 67, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/68d3ff9044377af9aecfbcb8953205c9a7a8f71f/gcc%2Fgraphite-clast-to-gimple.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/68d3ff9044377af9aecfbcb8953205c9a7a8f71f/gcc%2Fgraphite-clast-to-gimple.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgraphite-clast-to-gimple.c?ref=68d3ff9044377af9aecfbcb8953205c9a7a8f71f", "patch": "@@ -282,22 +282,37 @@ clast_to_gcc_expression (tree type, struct clast_expr *e,\n \t      {\n \t\ttree name = clast_name_to_gcc (t->var, region, newivs,\n \t\t\t\t\t       newivs_index, params_index);\n-\t\treturn fold_convert (type, name);\n+\n+\t\tif (POINTER_TYPE_P (TREE_TYPE (name)) != POINTER_TYPE_P (type))\n+\t\t  name = fold_convert (sizetype, name);\n+\n+\t\tname = fold_convert (type, name);\n+\t\treturn name;\n \t      }\n \n \t    else if (value_mone_p (t->val))\n \t      {\n \t\ttree name = clast_name_to_gcc (t->var, region, newivs,\n \t\t\t\t\t       newivs_index, params_index);\n+\n+\t\tif (POINTER_TYPE_P (TREE_TYPE (name)) != POINTER_TYPE_P (type))\n+\t\t  name = fold_convert (sizetype, name);\n+\n \t\tname = fold_convert (type, name);\n+\n \t\treturn fold_build1 (NEGATE_EXPR, type, name);\n \t      }\n \t    else\n \t      {\n \t\ttree name = clast_name_to_gcc (t->var, region, newivs,\n \t\t\t\t\t       newivs_index, params_index);\n \t\ttree cst = gmp_cst_to_tree (type, t->val);\n+\n+\t\tif (POINTER_TYPE_P (TREE_TYPE (name)) != POINTER_TYPE_P (type))\n+\t\t  name = fold_convert (sizetype, name);\n+\n \t\tname = fold_convert (type, name);\n+\n \t\tif (!POINTER_TYPE_P (type))\n \t\t  return fold_build2 (MULT_EXPR, type, cst, name);\n \n@@ -532,9 +547,16 @@ clast_get_body_of_loop (struct clast_stmt *stmt)\n   gcc_unreachable ();\n }\n \n-/* Given a CLOOG_IV, returns the type that it should have in GCC land.\n-   If the information is not available, i.e. in the case one of the\n-   transforms created the loop, just return integer_type_node.  */\n+/* Given a CLOOG_IV, return the type that CLOOG_IV should have in GCC\n+   land.  The selected type is big enough to include the original loop\n+   iteration variable, but signed to work with the subtractions CLooG\n+   may have introduced.  If such a type is not available, we fail.\n+\n+   TODO: Do not always return long_long, but the smallest possible\n+   type, that still holds the original type.\n+\n+   TODO: Get the types using CLooG instead.  This enables further\n+   optimizations, but needs CLooG support.  */\n \n static tree\n gcc_type_for_cloog_iv (const char *cloog_iv, gimple_bb_p gbb)\n@@ -546,9 +568,40 @@ gcc_type_for_cloog_iv (const char *cloog_iv, gimple_bb_p gbb)\n   slot = htab_find_slot (GBB_CLOOG_IV_TYPES (gbb), &tmp, NO_INSERT);\n \n   if (slot && *slot)\n-    return ((ivtype_map_elt) *slot)->type;\n+    {\n+      tree type = ((ivtype_map_elt) *slot)->type;\n+      int type_precision = TYPE_PRECISION (type);\n+\n+      /* Find the smallest signed type possible.  */\n+      if (!TYPE_UNSIGNED (type))\n+\t{\n+\t  if (type_precision <= TYPE_PRECISION (integer_type_node))\n+\t    return integer_type_node;\n+\n+\t  if (type_precision <= TYPE_PRECISION (long_integer_type_node))\n+\t    return long_integer_type_node;\n+\n+\t  if (type_precision <= TYPE_PRECISION (long_long_integer_type_node))\n+\t    return long_long_integer_type_node;\n+\n+\t  gcc_unreachable ();\n+\t}\n+\n+      if (type_precision < TYPE_PRECISION (integer_type_node))\n+\treturn integer_type_node;\n+\n+      if (type_precision < TYPE_PRECISION (long_integer_type_node))\n+\treturn long_integer_type_node;\n+\n+      if (type_precision < TYPE_PRECISION (long_long_integer_type_node))\n+\treturn long_long_integer_type_node;\n+\n+      /* There is no signed type available, that is large enough to hold the\n+\t original value.  */\n+      gcc_unreachable ();\n+    }\n \n-  return integer_type_node;\n+  return long_long_integer_type_node;\n }\n \n /* Returns the induction variable for the loop that gets translated to\n@@ -1046,7 +1099,7 @@ compute_cloog_iv_types_1 (poly_bb_p pbb, struct clast_user_stmt *user_stmt)\n       if (slot && !*slot)\n \t{\n \t  tree oldiv = pbb_to_depth_to_oldiv (pbb, index);\n-\t  tree type = oldiv ? TREE_TYPE (oldiv) : integer_type_node;\n+\t  tree type = TREE_TYPE (oldiv);\n \t  *slot = new_ivtype_map_elt (tmp.cloog_iv, type);\n \t}\n     }"}, {"sha": "279a905764dfb07062e3fb5bd09cf08184ca218d", "filename": "gcc/graphite-sese-to-poly.c", "status": "modified", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/68d3ff9044377af9aecfbcb8953205c9a7a8f71f/gcc%2Fgraphite-sese-to-poly.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/68d3ff9044377af9aecfbcb8953205c9a7a8f71f/gcc%2Fgraphite-sese-to-poly.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgraphite-sese-to-poly.c?ref=68d3ff9044377af9aecfbcb8953205c9a7a8f71f", "patch": "@@ -2893,6 +2893,38 @@ scop_canonicalize_loops (scop_p scop)\n       graphite_loop_normal_form (loop);\n }\n \n+/* Can all ivs be represented by a signed integer?\n+   As CLooG might generate negative values in its expressions, signed loop ivs\n+   are required in the backend. */\n+static bool\n+scop_ivs_can_be_represented (scop_p scop)\n+{\n+  loop_iterator li;\n+  loop_p loop;\n+\n+  FOR_EACH_LOOP (li, loop, 0)\n+    {\n+      tree type;\n+      int precision;\n+\n+      if (!loop_in_sese_p (loop, SCOP_REGION (scop)))\n+\tcontinue;\n+\n+      if (!loop->single_iv)\n+\tcontinue;\n+\n+      type = TREE_TYPE(loop->single_iv);\n+      precision = TYPE_PRECISION (type);\n+\n+      if (TYPE_UNSIGNED (type)\n+\t  && precision >= TYPE_PRECISION (long_long_integer_type_node))\n+\treturn false;\n+    }\n+\n+  return true;\n+}\n+\n+\n /* Builds the polyhedral representation for a SESE region.  */\n \n bool\n@@ -2915,6 +2947,10 @@ build_poly_scop (scop_p scop)\n     return false;\n \n   scop_canonicalize_loops (scop);\n+\n+  if (!scop_ivs_can_be_represented (scop))\n+    return false;\n+\n   build_sese_loop_nests (region);\n   build_sese_conditions (region);\n   find_scop_parameters (scop);"}, {"sha": "77628fa8cb95074b7d0995cef2d33d765543fb06", "filename": "gcc/testsuite/gcc.dg/graphite/id-18.c", "status": "added", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/68d3ff9044377af9aecfbcb8953205c9a7a8f71f/gcc%2Ftestsuite%2Fgcc.dg%2Fgraphite%2Fid-18.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/68d3ff9044377af9aecfbcb8953205c9a7a8f71f/gcc%2Ftestsuite%2Fgcc.dg%2Fgraphite%2Fid-18.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fgraphite%2Fid-18.c?ref=68d3ff9044377af9aecfbcb8953205c9a7a8f71f", "patch": "@@ -0,0 +1,7 @@\n+long do_hash (const char * lo, const char * hi)\n+{\n+\tint val = 0;\n+\tfor (; lo < hi; ++lo)\n+\t\tval = *lo;\n+\treturn val;\n+}"}, {"sha": "2e9006470c49f2545cda307549766c7c38f28472", "filename": "gcc/testsuite/gcc.dg/graphite/run-id-pr42644.c", "status": "added", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/68d3ff9044377af9aecfbcb8953205c9a7a8f71f/gcc%2Ftestsuite%2Fgcc.dg%2Fgraphite%2Frun-id-pr42644.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/68d3ff9044377af9aecfbcb8953205c9a7a8f71f/gcc%2Ftestsuite%2Fgcc.dg%2Fgraphite%2Frun-id-pr42644.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fgraphite%2Frun-id-pr42644.c?ref=68d3ff9044377af9aecfbcb8953205c9a7a8f71f", "patch": "@@ -0,0 +1,32 @@\n+/* Testcase extracted from test 183.equake in SPEC CPU2000.  */\n+double Ke[2], ds[2];\n+\n+void foo(double Ke[2], int i, double ds[],  int column)\n+{\n+  double tt, ts;\n+  int j;\n+\n+  for (j = 0; j < 2; j++)\n+    {\n+      ++column;\n+      ts = ds[i];\n+      if (i == j)\n+\ttt = 123;\n+      else\n+\ttt = 0;\n+      Ke[column] = Ke[column] + ts + tt;\n+    }\n+}\n+\n+int\n+main ()\n+{\n+  int i, j;\n+\n+  ds[0] = 1.0;\n+  ds[1] = 1.0;\n+\n+  foo(Ke, 0, ds, -1);\n+\n+  return (int) Ke[0] != 124;\n+}"}, {"sha": "1ad4b4192d6e345b97d09cd9060b75b585504595", "filename": "libgomp/testsuite/libgomp.graphite/force-parallel-1.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/68d3ff9044377af9aecfbcb8953205c9a7a8f71f/libgomp%2Ftestsuite%2Flibgomp.graphite%2Fforce-parallel-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/68d3ff9044377af9aecfbcb8953205c9a7a8f71f/libgomp%2Ftestsuite%2Flibgomp.graphite%2Fforce-parallel-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.graphite%2Fforce-parallel-1.c?ref=68d3ff9044377af9aecfbcb8953205c9a7a8f71f", "patch": "@@ -23,7 +23,7 @@ int main(void)\n }\n \n /* Check that parallel code generation part make the right answer.  */\n-/* { dg-final { scan-tree-dump-times \"1 loops carried no dependency\" 2 \"graphite\" } } */\n+/* { dg-final { scan-tree-dump-times \"1 loops carried no dependency\" 1 \"graphite\" } } */\n /* { dg-final { cleanup-tree-dump \"graphite\" } } */\n /* { dg-final { scan-tree-dump-times \"loopfn\" 5 \"optimized\" } } */\n /* { dg-final { cleanup-tree-dump \"parloops\" } } */"}, {"sha": "1ce0feb250606a24c928cc0a66abbc6dc12786bc", "filename": "libgomp/testsuite/libgomp.graphite/force-parallel-2.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/68d3ff9044377af9aecfbcb8953205c9a7a8f71f/libgomp%2Ftestsuite%2Flibgomp.graphite%2Fforce-parallel-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/68d3ff9044377af9aecfbcb8953205c9a7a8f71f/libgomp%2Ftestsuite%2Flibgomp.graphite%2Fforce-parallel-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.graphite%2Fforce-parallel-2.c?ref=68d3ff9044377af9aecfbcb8953205c9a7a8f71f", "patch": "@@ -23,7 +23,7 @@ int main(void)\n }\n \n /* Check that parallel code generation part make the right answer.  */\n-/* { dg-final { scan-tree-dump-times \"2 loops carried no dependency\" 2 \"graphite\" } } */\n+/* { dg-final { scan-tree-dump-times \"2 loops carried no dependency\" 1 \"graphite\" } } */\n /* { dg-final { cleanup-tree-dump \"graphite\" } } */\n /* { dg-final { scan-tree-dump-times \"loopfn\" 5 \"optimized\" } } */\n /* { dg-final { cleanup-tree-dump \"parloops\" } } */"}]}