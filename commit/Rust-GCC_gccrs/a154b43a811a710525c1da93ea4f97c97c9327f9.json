{"sha": "a154b43a811a710525c1da93ea4f97c97c9327f9", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTE1NGI0M2E4MTFhNzEwNTI1YzFkYTkzZWE0Zjk3Yzk3YzkzMjdmOQ==", "commit": {"author": {"name": "Zdenek Dvorak", "email": "dvorakz@suse.cz", "date": "2007-04-17T16:42:29Z"}, "committer": {"name": "Zdenek Dvorak", "email": "rakdver@gcc.gnu.org", "date": "2007-04-17T16:42:29Z"}, "message": "re PR rtl-optimization/31360 (RTL loop invariant is not aggressive enough)\n\n\tPR rtl-optimization/31360\n\t* cfgloopanal.c (target_small_cost, target_pres_cost): Removed.\n\t(target_reg_cost): New.\n\t(init_set_costs): Initialize target_reg_cost.  Add comments\n\tregarding the rationale of the costs.\n\t(global_cost_for_size): Renamed to...\n\t(estimate_reg_pressure_cost): ... and simplify.  Decrease importance\n\tof register pressure.\n\t* tree-ssa-loop-ivopts.c (ivopts_global_cost_for_size): Use\n\testimate_reg_pressure_cost.  Add number of ivs.\n\t(determine_set_costs): Dump target_reg_cost.\n\t* loop-invariant.c (gain_for_invariant):  Use\n\testimate_reg_pressure_cost.  Removed n_inv_uses argument.\n\t(best_gain_for_invariant, find_invariants_to_move): Remove\n\tn_inv_uses.\n\t* cfgloop.h (target_small_cost, target_pres_cost): Removed.\n\t(target_reg_cost): Declare.\n\t(global_cost_for_size): Declaration removed.\n\t(estimate_reg_pressure_cost): Declare.\n\n\t* gcc.dg/loop-7.c: New test.\n\nFrom-SVN: r123919", "tree": {"sha": "0a31c59ebc8695e61c56119d3a3890c7117e0a43", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/0a31c59ebc8695e61c56119d3a3890c7117e0a43"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a154b43a811a710525c1da93ea4f97c97c9327f9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a154b43a811a710525c1da93ea4f97c97c9327f9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a154b43a811a710525c1da93ea4f97c97c9327f9", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a154b43a811a710525c1da93ea4f97c97c9327f9/comments", "author": null, "committer": null, "parents": [{"sha": "faf28b3a89f32229935b0f60383423315121eb8d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/faf28b3a89f32229935b0f60383423315121eb8d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/faf28b3a89f32229935b0f60383423315121eb8d"}], "stats": {"total": 165, "additions": 99, "deletions": 66}, "files": [{"sha": "55c0fa33f1129ac855e25078de7329226649a5a0", "filename": "gcc/ChangeLog", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a154b43a811a710525c1da93ea4f97c97c9327f9/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a154b43a811a710525c1da93ea4f97c97c9327f9/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=a154b43a811a710525c1da93ea4f97c97c9327f9", "patch": "@@ -1,3 +1,25 @@\n+2007-04-17  Zdenek Dvorak  <dvorakz@suse.cz>\n+\n+\tPR rtl-optimization/31360\n+\t* cfgloopanal.c (target_small_cost, target_pres_cost): Removed.\n+\t(target_reg_cost): New.\n+\t(init_set_costs): Initialize target_reg_cost.  Add comments\n+\tregarding the rationale of the costs.\n+\t(global_cost_for_size): Renamed to...\n+\t(estimate_reg_pressure_cost): ... and simplify.  Decrease importance\n+\tof register pressure.\n+\t* tree-ssa-loop-ivopts.c (ivopts_global_cost_for_size): Use\n+\testimate_reg_pressure_cost.  Add number of ivs.\n+\t(determine_set_costs): Dump target_reg_cost.\n+\t* loop-invariant.c (gain_for_invariant):  Use\n+\testimate_reg_pressure_cost.  Removed n_inv_uses argument.\n+\t(best_gain_for_invariant, find_invariants_to_move): Remove\n+\tn_inv_uses.\n+\t* cfgloop.h (target_small_cost, target_pres_cost): Removed.\n+\t(target_reg_cost): Declare.\n+\t(global_cost_for_size): Declaration removed.\n+\t(estimate_reg_pressure_cost): Declare.\n+\n 2007-04-17  Peter Bergner  <bergner@vnet.ibm.com>\n \n \t* config/rs6000/rs6000.c (rs6000_hard_regno_mode_ok): Force TDmode"}, {"sha": "52160635bb999564a89cfc0c7b238110e5ca2837", "filename": "gcc/cfgloop.h", "status": "modified", "additions": 5, "deletions": 9, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a154b43a811a710525c1da93ea4f97c97c9327f9/gcc%2Fcfgloop.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a154b43a811a710525c1da93ea4f97c97c9327f9/gcc%2Fcfgloop.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgloop.h?ref=a154b43a811a710525c1da93ea4f97c97c9327f9", "patch": "@@ -562,18 +562,14 @@ fel_init (loop_iterator *li, loop_p *loop, unsigned flags)\n \n /* The properties of the target.  */\n \n-extern unsigned target_avail_regs;\t/* Number of available registers.  */\n-extern unsigned target_res_regs;\t/* Number of reserved registers.  */\n-extern unsigned target_small_cost;\t/* The cost for register when there\n-\t\t\t\t\t   is a free one.  */\n-extern unsigned target_pres_cost;\t/* The cost for register when there are\n-\t\t\t\t\t   not too many free ones.  */\n-extern unsigned target_spill_cost;\t/* The cost for register when we need\n-\t\t\t\t\t   to spill.  */\n+extern unsigned target_avail_regs;\n+extern unsigned target_res_regs;\n+extern unsigned target_reg_cost;\n+extern unsigned target_spill_cost;\n \n /* Register pressure estimation for induction variable optimizations & loop\n    invariant motion.  */\n-extern unsigned global_cost_for_size (unsigned, unsigned, unsigned);\n+extern unsigned estimate_reg_pressure_cost (unsigned, unsigned);\n extern void init_set_costs (void);\n \n /* Loop optimizer initialization.  */"}, {"sha": "7baa30a48998da6e5df7caf06c7b82fc9144faae", "filename": "gcc/cfgloopanal.c", "status": "modified", "additions": 31, "deletions": 24, "changes": 55, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a154b43a811a710525c1da93ea4f97c97c9327f9/gcc%2Fcfgloopanal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a154b43a811a710525c1da93ea4f97c97c9327f9/gcc%2Fcfgloopanal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgloopanal.c?ref=a154b43a811a710525c1da93ea4f97c97c9327f9", "patch": "@@ -523,11 +523,13 @@ seq_cost (rtx seq)\n /* The properties of the target.  */\n \n unsigned target_avail_regs;\t/* Number of available registers.  */\n-unsigned target_res_regs;\t/* Number of reserved registers.  */\n-unsigned target_small_cost;\t/* The cost for register when there is a free one.  */\n-unsigned target_pres_cost;\t/* The cost for register when there are not too many\n-\t\t\t\t   free ones.  */\n-unsigned target_spill_cost;\t/* The cost for register when we need to spill.  */\n+unsigned target_res_regs;\t/* Number of registers reserved for temporary\n+\t\t\t\t   expressions.  */\n+unsigned target_reg_cost;\t/* The cost for register when there still\n+\t\t\t\t   is some reserve, but we are approaching\n+\t\t\t\t   the number of available registers.  */\n+unsigned target_spill_cost;\t/* The cost for register when we need\n+\t\t\t\t   to spill.  */\n \n /* Initialize the constants for computing set costs.  */\n \n@@ -548,14 +550,20 @@ init_set_costs (void)\n \n   target_res_regs = 3;\n \n-  /* These are really just heuristic values.  */\n+  /* Set up the costs for using extra registers:\n+\n+     1) If not many free registers remain, we should prefer having an\n+\tadditional move to decreasing the number of available registers.\n+\t(TARGET_REG_COST).\n+     2) If no registers are available, we need to spill, which may require\n+\tstoring the old value to memory and loading it back\n+\t(TARGET_SPILL_COST).  */\n \n   start_sequence ();\n   emit_move_insn (reg1, reg2);\n   seq = get_insns ();\n   end_sequence ();\n-  target_small_cost = seq_cost (seq);\n-  target_pres_cost = 2 * target_small_cost;\n+  target_reg_cost = seq_cost (seq);\n \n   start_sequence ();\n   emit_move_insn (mem, reg1);\n@@ -565,27 +573,26 @@ init_set_costs (void)\n   target_spill_cost = seq_cost (seq);\n }\n \n-/* Calculates cost for having SIZE new loop global variables.  REGS_USED is the\n-   number of global registers used in loop.  N_USES is the number of relevant\n-   variable uses.  */\n+/* Estimates cost of increased register pressure caused by making N_NEW new\n+   registers live around the loop.  N_OLD is the number of registers live\n+   around the loop.  */\n \n unsigned\n-global_cost_for_size (unsigned size, unsigned regs_used, unsigned n_uses)\n+estimate_reg_pressure_cost (unsigned n_new, unsigned n_old)\n {\n-  unsigned regs_needed = regs_used + size;\n-  unsigned cost = 0;\n+  unsigned regs_needed = n_new + n_old;\n \n+  /* If we have enough registers, we should use them and not restrict\n+     the transformations unnecessarily.  */\n   if (regs_needed + target_res_regs <= target_avail_regs)\n-    cost += target_small_cost * size;\n-  else if (regs_needed <= target_avail_regs)\n-    cost += target_pres_cost * size;\n-  else\n-    {\n-      cost += target_pres_cost * size;\n-      cost += target_spill_cost * n_uses * (regs_needed - target_avail_regs) / regs_needed;\n-    }\n-\n-  return cost;\n+    return 0;\n+\n+  /* If we are close to running out of registers, try to preserve them.  */\n+  if (regs_needed <= target_avail_regs)\n+    return target_reg_cost * n_new;\n+  \n+  /* If we run out of registers, it is very expensive to add another one.  */\n+  return target_spill_cost * n_new;\n }\n \n /* Sets EDGE_LOOP_EXIT flag for all loop exits.  */"}, {"sha": "304e424cf2d7b5301cee2cd6ed997a23afd78cb2", "filename": "gcc/loop-invariant.c", "status": "modified", "additions": 16, "deletions": 30, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a154b43a811a710525c1da93ea4f97c97c9327f9/gcc%2Floop-invariant.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a154b43a811a710525c1da93ea4f97c97c9327f9/gcc%2Floop-invariant.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Floop-invariant.c?ref=a154b43a811a710525c1da93ea4f97c97c9327f9", "patch": "@@ -983,37 +983,34 @@ get_inv_cost (struct invariant *inv, int *comp_cost, unsigned *regs_needed)\n }\n \n /* Calculates gain for eliminating invariant INV.  REGS_USED is the number\n-   of registers used in the loop, N_INV_USES is the number of uses of\n-   invariants, NEW_REGS is the number of new variables already added due to\n-   the invariant motion.  The number of registers needed for it is stored in\n-   *REGS_NEEDED.  */\n+   of registers used in the loop, NEW_REGS is the number of new variables\n+   already added due to the invariant motion.  The number of registers needed\n+   for it is stored in *REGS_NEEDED.  */\n \n static int\n gain_for_invariant (struct invariant *inv, unsigned *regs_needed,\n-\t\t    unsigned new_regs, unsigned regs_used, unsigned n_inv_uses)\n+\t\t    unsigned new_regs, unsigned regs_used)\n {\n   int comp_cost, size_cost;\n \n   get_inv_cost (inv, &comp_cost, regs_needed);\n   actual_stamp++;\n \n-  size_cost = (global_cost_for_size (new_regs + *regs_needed,\n-\t\t\t\t     regs_used, n_inv_uses)\n-\t       - global_cost_for_size (new_regs, regs_used, n_inv_uses));\n+  size_cost = (estimate_reg_pressure_cost (new_regs + *regs_needed, regs_used)\n+\t       - estimate_reg_pressure_cost (new_regs, regs_used));\n \n   return comp_cost - size_cost;\n }\n \n /* Finds invariant with best gain for moving.  Returns the gain, stores\n    the invariant in *BEST and number of registers needed for it to\n-   *REGS_NEEDED.  REGS_USED is the number of registers used in\n-   the loop, N_INV_USES is the number of uses of invariants.  NEW_REGS\n-   is the number of new variables already added due to invariant motion.  */\n+   *REGS_NEEDED.  REGS_USED is the number of registers used in the loop.\n+   NEW_REGS is the number of new variables already added due to invariant\n+   motion.  */\n \n static int\n best_gain_for_invariant (struct invariant **best, unsigned *regs_needed,\n-\t\t\t unsigned new_regs, unsigned regs_used,\n-\t\t\t unsigned n_inv_uses)\n+\t\t\t unsigned new_regs, unsigned regs_used)\n {\n   struct invariant *inv;\n   int gain = 0, again;\n@@ -1028,8 +1025,7 @@ best_gain_for_invariant (struct invariant **best, unsigned *regs_needed,\n       if (inv->eqto != inv->invno)\n \tcontinue;\n \n-      again = gain_for_invariant (inv, &aregs_needed,\n-\t\t\t\t  new_regs, regs_used, n_inv_uses);\n+      again = gain_for_invariant (inv, &aregs_needed, new_regs, regs_used);\n       if (again > gain)\n \t{\n \t  gain = again;\n@@ -1070,19 +1066,16 @@ set_move_mark (unsigned invno)\n static void\n find_invariants_to_move (void)\n {\n-  unsigned i, regs_used, n_inv_uses, regs_needed = 0, new_regs;\n+  unsigned i, regs_used, regs_needed = 0, new_regs;\n   struct invariant *inv = NULL;\n   unsigned int n_regs = DF_REG_SIZE (df);\n \n   if (!VEC_length (invariant_p, invariants))\n     return;\n \n-  /* Now something slightly more involved.  First estimate the number of used\n-     registers.  */\n-  n_inv_uses = 0;\n-\n-  /* We do not really do a good job in this estimation; put some initial bound\n-     here to stand for induction variables etc. that we do not detect.  */\n+  /* We do not really do a good job in estimating number of registers used;\n+     we put some initial bound here to stand for induction variables etc.\n+     that we do not detect.  */\n   regs_used = 2;\n \n   for (i = 0; i < n_regs; i++)\n@@ -1094,15 +1087,8 @@ find_invariants_to_move (void)\n \t}\n     }\n \n-  for (i = 0; VEC_iterate (invariant_p, invariants, i, inv); i++)\n-    {\n-      if (inv->def)\n-\tn_inv_uses += inv->def->n_uses;\n-    }\n-\n   new_regs = 0;\n-  while (best_gain_for_invariant (&inv, &regs_needed,\n-\t\t\t\t  new_regs, regs_used, n_inv_uses) > 0)\n+  while (best_gain_for_invariant (&inv, &regs_needed, new_regs, regs_used) > 0)\n     {\n       set_move_mark (inv->invno);\n       new_regs += regs_needed;"}, {"sha": "36592abfa08fc1b060a4a088fa38cb53e31a8cd5", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a154b43a811a710525c1da93ea4f97c97c9327f9/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a154b43a811a710525c1da93ea4f97c97c9327f9/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=a154b43a811a710525c1da93ea4f97c97c9327f9", "patch": "@@ -1,3 +1,8 @@\n+2007-04-17  Zdenek Dvorak  <dvorakz@suse.cz>\n+\n+\tPR rtl-optimization/31360\n+\t* gcc.dg/loop-7.c: New test.\n+\n 2007-04-17  Mark Mitchell  <mark@codesourcery.com>\n \n \t* gcc.misc-tests/linkage.exp: Do not run on remote hosts."}, {"sha": "0457add9c7964caea2763fae3216c98a343afb9c", "filename": "gcc/testsuite/gcc.dg/loop-7.c", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a154b43a811a710525c1da93ea4f97c97c9327f9/gcc%2Ftestsuite%2Fgcc.dg%2Floop-7.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a154b43a811a710525c1da93ea4f97c97c9327f9/gcc%2Ftestsuite%2Fgcc.dg%2Floop-7.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Floop-7.c?ref=a154b43a811a710525c1da93ea4f97c97c9327f9", "patch": "@@ -0,0 +1,16 @@\n+/* PR rtl-optimization/31360  */\n+\n+/* { dg-do compile { target { powerpc*-*-* } } } */\n+/* { dg-options \"-O1 -fdump-rtl-loop2_invariant\" } */\n+\n+void f(int *a)\n+{\n+  int i;\n+  for (i = 0;i<100;i++)\n+    a[i] = 0;\n+}\n+\n+/* Load of 0 is moved out of the loop.  */\n+/* { dg-final { scan-rtl-dump-times \"Decided\" 1 \"loop2_invariant\" } } */\n+/* { dg-final { cleanup-rtl-dump \"loop2_invariant\" } } */\n+"}, {"sha": "d26608b4cd1917ff044b4807666947c4cad16562", "filename": "gcc/tree-ssa-loop-ivopts.c", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a154b43a811a710525c1da93ea4f97c97c9327f9/gcc%2Ftree-ssa-loop-ivopts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a154b43a811a710525c1da93ea4f97c97c9327f9/gcc%2Ftree-ssa-loop-ivopts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-ivopts.c?ref=a154b43a811a710525c1da93ea4f97c97c9327f9", "patch": "@@ -3908,7 +3908,9 @@ determine_iv_costs (struct ivopts_data *data)\n static unsigned\n ivopts_global_cost_for_size (struct ivopts_data *data, unsigned size)\n {\n-  return global_cost_for_size (size, data->regs_used, n_iv_uses (data));\n+  /* We add size to the cost, so that we prefer eliminating ivs\n+     if possible.  */\n+  return size + estimate_reg_pressure_cost (size, data->regs_used);\n }\n \n /* For each size of the induction variable set determine the penalty.  */\n@@ -3945,8 +3947,7 @@ determine_set_costs (struct ivopts_data *data)\n     {\n       fprintf (dump_file, \"Global costs:\\n\");\n       fprintf (dump_file, \"  target_avail_regs %d\\n\", target_avail_regs);\n-      fprintf (dump_file, \"  target_small_cost %d\\n\", target_small_cost);\n-      fprintf (dump_file, \"  target_pres_cost %d\\n\", target_pres_cost);\n+      fprintf (dump_file, \"  target_reg_cost %d\\n\", target_reg_cost);\n       fprintf (dump_file, \"  target_spill_cost %d\\n\", target_spill_cost);\n     }\n "}]}