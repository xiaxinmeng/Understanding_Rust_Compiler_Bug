{"sha": "965703ed8e1a320e190baee91f8ce6a3c07d98ea", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTY1NzAzZWQ4ZTFhMzIwZTE5MGJhZWU5MWY4Y2U2YTNjMDdkOThlYQ==", "commit": {"author": {"name": "Roger Sayle", "email": "roger@eyesopen.com", "date": "2004-06-13T02:46:08Z"}, "committer": {"name": "Roger Sayle", "email": "sayle@gcc.gnu.org", "date": "2004-06-13T02:46:08Z"}, "message": "expmed.c (shift_cost, [...]): Additionally index by machine mode.\n\n\n\t* expmed.c (shift_cost, shiftadd_cost, shiftsub_cost): Additionally\n\tindex by machine mode.\n\t(init_expmed): Initialize shift_cost, shiftadd_cost and shiftsub_cost\n\ttables inside the loop over machine modes.\n\t(synth_mult, expand_mult_highpart_optab, expand_mult_highpart,\n\texpand_divmod): Index shift*_cost by the appropriate machine mode.\n\nFrom-SVN: r83053", "tree": {"sha": "60606718d799c08f814f5d1cc825b6455dad1de4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/60606718d799c08f814f5d1cc825b6455dad1de4"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/965703ed8e1a320e190baee91f8ce6a3c07d98ea", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/965703ed8e1a320e190baee91f8ce6a3c07d98ea", "html_url": "https://github.com/Rust-GCC/gccrs/commit/965703ed8e1a320e190baee91f8ce6a3c07d98ea", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/965703ed8e1a320e190baee91f8ce6a3c07d98ea/comments", "author": null, "committer": null, "parents": [{"sha": "3839e36afce7cf51ec030562adcad7af941495e9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3839e36afce7cf51ec030562adcad7af941495e9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3839e36afce7cf51ec030562adcad7af941495e9"}], "stats": {"total": 162, "additions": 92, "deletions": 70}, "files": [{"sha": "825208bf99a4eb834579e1ef315834ae1b3343c6", "filename": "gcc/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/965703ed8e1a320e190baee91f8ce6a3c07d98ea/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/965703ed8e1a320e190baee91f8ce6a3c07d98ea/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=965703ed8e1a320e190baee91f8ce6a3c07d98ea", "patch": "@@ -1,3 +1,12 @@\n+2004-06-12  Roger Sayle  <roger@eyesopen.com>\n+\n+\t* expmed.c (shift_cost, shiftadd_cost, shiftsub_cost): Additionally\n+\tindex by machine mode.\n+\t(init_expmed): Initialize shift_cost, shiftadd_cost and shiftsub_cost\n+\ttables inside the loop over machine modes.\n+\t(synth_mult, expand_mult_highpart_optab, expand_mult_highpart,\n+\texpand_divmod): Index shift*_cost by the appropriate machine mode.\n+\n 2004-06-12  Eric Christopher  <echristo@redhat.com>\n \n \t* config/s390/s390.h: Rename TARGET_TPF to TARGET_TPF_PROFILING."}, {"sha": "f45de5d56cc9a0baaf6dcab5765b5c1617040bac", "filename": "gcc/expmed.c", "status": "modified", "additions": 83, "deletions": 70, "changes": 153, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/965703ed8e1a320e190baee91f8ce6a3c07d98ea/gcc%2Fexpmed.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/965703ed8e1a320e190baee91f8ce6a3c07d98ea/gcc%2Fexpmed.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpmed.c?ref=965703ed8e1a320e190baee91f8ce6a3c07d98ea", "patch": "@@ -94,9 +94,9 @@ static int smod_pow2_cheap[NUM_MACHINE_MODES];\n static int zero_cost;\n static int add_cost[NUM_MACHINE_MODES];\n static int neg_cost[NUM_MACHINE_MODES];\n-static int shift_cost[MAX_BITS_PER_WORD];\n-static int shiftadd_cost[MAX_BITS_PER_WORD];\n-static int shiftsub_cost[MAX_BITS_PER_WORD];\n+static int shift_cost[NUM_MACHINE_MODES][MAX_BITS_PER_WORD];\n+static int shiftadd_cost[NUM_MACHINE_MODES][MAX_BITS_PER_WORD];\n+static int shiftsub_cost[NUM_MACHINE_MODES][MAX_BITS_PER_WORD];\n static int mul_cost[NUM_MACHINE_MODES];\n static int div_cost[NUM_MACHINE_MODES];\n static int mul_widen_cost[NUM_MACHINE_MODES];\n@@ -106,38 +106,24 @@ void\n init_expmed (void)\n {\n   rtx reg, shift_insn, shiftadd_insn, shiftsub_insn;\n+  rtx shift_pat, shiftadd_pat, shiftsub_pat;\n+  rtx pow2[MAX_BITS_PER_WORD];\n+  rtx cint[MAX_BITS_PER_WORD];\n   int dummy;\n-  int m;\n+  int m, n;\n   enum machine_mode mode, wider_mode;\n \n   start_sequence ();\n \n-  /* This is \"some random pseudo register\" for purposes of calling recog\n-     to see what insns exist.  */\n-  reg = gen_rtx_REG (word_mode, 10000);\n-\n   zero_cost = rtx_cost (const0_rtx, 0);\n \n-  shift_insn = emit_insn (gen_rtx_SET (VOIDmode, reg,\n-\t\t\t\t       gen_rtx_ASHIFT (word_mode, reg,\n-\t\t\t\t\t\t       const0_rtx)));\n-\n-  shiftadd_insn\n-    = emit_insn (gen_rtx_SET (VOIDmode, reg,\n-\t\t\t      gen_rtx_PLUS (word_mode,\n-\t\t\t\t\t    gen_rtx_MULT (word_mode,\n-\t\t\t\t\t\t\t  reg, const0_rtx),\n-\t\t\t\t\t    reg)));\n-\n-  shiftsub_insn\n-    = emit_insn (gen_rtx_SET (VOIDmode, reg,\n-\t\t\t      gen_rtx_MINUS (word_mode,\n-\t\t\t\t\t     gen_rtx_MULT (word_mode,\n-\t\t\t\t\t\t\t   reg, const0_rtx),\n-\t\t\t\t\t     reg)));\n-\n   init_recog ();\n \n+  for (m = 1; m < MAX_BITS_PER_WORD; m++)\n+    {\n+      pow2[m] = GEN_INT ((HOST_WIDE_INT) 1 << m);\n+      cint[m] = GEN_INT (m);\n+    }\n \n   for (mode = GET_CLASS_NARROWEST_MODE (MODE_INT);\n        mode != VOIDmode;\n@@ -176,27 +162,52 @@ init_expmed (void)\n \t\t\t\t\t   GEN_INT (GET_MODE_BITSIZE (mode)))),\n \t\t\tSET);\n \t}\n-    }\n \n-  shift_cost[0] = 0;\n-  shiftadd_cost[0] = shiftsub_cost[0] = add_cost[word_mode];\n-\n-  for (m = 1; m < MAX_BITS_PER_WORD; m++)\n-    {\n-      rtx c_int = GEN_INT ((HOST_WIDE_INT) 1 << m);\n-      shift_cost[m] = shiftadd_cost[m] = shiftsub_cost[m] = 32000;\n-\n-      XEXP (SET_SRC (PATTERN (shift_insn)), 1) = GEN_INT (m);\n-      if (recog (PATTERN (shift_insn), shift_insn, &dummy) >= 0)\n-\tshift_cost[m] = rtx_cost (SET_SRC (PATTERN (shift_insn)), SET);\n-\n-      XEXP (XEXP (SET_SRC (PATTERN (shiftadd_insn)), 0), 1) = c_int;\n-      if (recog (PATTERN (shiftadd_insn), shiftadd_insn, &dummy) >= 0)\n-\tshiftadd_cost[m] = rtx_cost (SET_SRC (PATTERN (shiftadd_insn)), SET);\n-\n-      XEXP (XEXP (SET_SRC (PATTERN (shiftsub_insn)), 0), 1) = c_int;\n-      if (recog (PATTERN (shiftsub_insn), shiftsub_insn, &dummy) >= 0)\n-\tshiftsub_cost[m] = rtx_cost (SET_SRC (PATTERN (shiftsub_insn)), SET);\n+\tshift_insn = emit_insn (gen_rtx_SET (VOIDmode, reg,\n+\t\t\t\t\t     gen_rtx_ASHIFT (mode, reg,\n+\t\t\t\t\t\t\t     const0_rtx)));\n+\n+\tshiftadd_insn\n+\t  = emit_insn (gen_rtx_SET (VOIDmode, reg,\n+\t\t\t\t    gen_rtx_PLUS (mode,\n+\t\t\t\t\t\t  gen_rtx_MULT (mode,\n+\t\t\t\t\t\t\t\treg,\n+\t\t\t\t\t\t\t\tconst0_rtx),\n+\t\t\t\t\t\t  reg)));\n+\n+\tshiftsub_insn\n+\t  = emit_insn (gen_rtx_SET (VOIDmode, reg,\n+\t\t\t\t    gen_rtx_MINUS (mode,\n+\t\t\t\t\t\t   gen_rtx_MULT (mode,\n+\t\t\t\t\t\t\t\t reg,\n+\t\t\t\t\t\t\t\t const0_rtx),\n+\t\t\t\t\t\t   reg)));\n+\n+\tshift_pat = PATTERN (shift_insn);\n+\tshiftadd_pat = PATTERN (shiftadd_insn);\n+\tshiftsub_pat = PATTERN (shiftsub_insn);\n+\n+\tshift_cost[mode][0] = 0;\n+\tshiftadd_cost[mode][0] = shiftsub_cost[mode][0] = add_cost[mode];\n+\n+\tn = MIN (MAX_BITS_PER_WORD, GET_MODE_BITSIZE (mode));\n+\tfor (m = 1; m < n; m++)\n+\t  {\n+\t    shift_cost[mode][m] = 32000;\n+\t    XEXP (SET_SRC (shift_pat), 1) = cint[m];\n+\t    if (recog (shift_pat, shift_insn, &dummy) >= 0)\n+\t      shift_cost[mode][m] = rtx_cost (SET_SRC (shift_pat), SET);\n+\n+\t    shiftadd_cost[mode][m] = 32000;\n+\t    XEXP (XEXP (SET_SRC (shiftadd_pat), 0), 1) = pow2[m];\n+\t    if (recog (shiftadd_pat, shiftadd_insn, &dummy) >= 0)\n+\t      shiftadd_cost[mode][m] = rtx_cost (SET_SRC (shiftadd_pat), SET);\n+\n+\t    shiftsub_cost[mode][m] = 32000;\n+\t    XEXP (XEXP (SET_SRC (shiftsub_pat), 0), 1) = pow2[m];\n+\t    if (recog (shiftsub_pat, shiftsub_insn, &dummy) >= 0)\n+\t      shiftsub_cost[mode][m] = rtx_cost (SET_SRC (shiftsub_pat), SET);\n+\t  }\n     }\n \n   end_sequence ();\n@@ -2226,7 +2237,7 @@ synth_mult (struct algorithm *alg_out, unsigned HOST_WIDE_INT t,\n       if (m < BITS_PER_WORD)\n \t{\n \t  q = t >> m;\n-\t  cost = shift_cost[m];\n+\t  cost = shift_cost[mode][m];\n \t  synth_mult (alg_in, q, cost_limit - cost, mode);\n \n \t  cost += alg_in->cost;\n@@ -2310,9 +2321,9 @@ synth_mult (struct algorithm *alg_out, unsigned HOST_WIDE_INT t,\n       d = ((unsigned HOST_WIDE_INT) 1 << m) + 1;\n       if (t % d == 0 && t > d && m < BITS_PER_WORD)\n \t{\n-\t  cost = add_cost[mode] + shift_cost[m];\n-\t  if (shiftadd_cost[m] < cost)\n-\t    cost = shiftadd_cost[m];\n+\t  cost = add_cost[mode] + shift_cost[mode][m];\n+\t  if (shiftadd_cost[mode][m] < cost)\n+\t    cost = shiftadd_cost[mode][m];\n \t  synth_mult (alg_in, t / d, cost_limit - cost, mode);\n \n \t  cost += alg_in->cost;\n@@ -2331,9 +2342,9 @@ synth_mult (struct algorithm *alg_out, unsigned HOST_WIDE_INT t,\n       d = ((unsigned HOST_WIDE_INT) 1 << m) - 1;\n       if (t % d == 0 && t > d && m < BITS_PER_WORD)\n \t{\n-\t  cost = add_cost[mode] + shift_cost[m];\n-\t  if (shiftsub_cost[m] < cost)\n-\t    cost = shiftsub_cost[m];\n+\t  cost = add_cost[mode] + shift_cost[mode][m];\n+\t  if (shiftsub_cost[mode][m] < cost)\n+\t    cost = shiftsub_cost[mode][m];\n \t  synth_mult (alg_in, t / d, cost_limit - cost, mode);\n \n \t  cost += alg_in->cost;\n@@ -2358,7 +2369,7 @@ synth_mult (struct algorithm *alg_out, unsigned HOST_WIDE_INT t,\n       m = exact_log2 (q);\n       if (m >= 0 && m < BITS_PER_WORD)\n \t{\n-\t  cost = shiftadd_cost[m];\n+\t  cost = shiftadd_cost[mode][m];\n \t  synth_mult (alg_in, (t - 1) >> m, cost_limit - cost, mode);\n \n \t  cost += alg_in->cost;\n@@ -2377,7 +2388,7 @@ synth_mult (struct algorithm *alg_out, unsigned HOST_WIDE_INT t,\n       m = exact_log2 (q);\n       if (m >= 0 && m < BITS_PER_WORD)\n \t{\n-\t  cost = shiftsub_cost[m];\n+\t  cost = shiftsub_cost[mode][m];\n \t  synth_mult (alg_in, (t + 1) >> m, cost_limit - cost, mode);\n \n \t  cost += alg_in->cost;\n@@ -2911,7 +2922,7 @@ expand_mult_highpart_optab (enum machine_mode mode, rtx op0, rtx op1,\n   /* Secondly, same as above, but use sign flavor opposite of unsignedp.\n      Need to adjust the result after the multiplication.  */\n   if (size - 1 < BITS_PER_WORD\n-      && (mul_highpart_cost[mode] + 2 * shift_cost[size-1]\n+      && (mul_highpart_cost[mode] + 2 * shift_cost[mode][size-1]\n \t  + 4 * add_cost[mode] < max_cost))\n     {\n       moptab = unsignedp ? smul_highpart_optab : umul_highpart_optab;\n@@ -2938,7 +2949,7 @@ expand_mult_highpart_optab (enum machine_mode mode, rtx op0, rtx op1,\n   moptab = smul_optab;\n   if (smul_optab->handlers[wider_mode].insn_code != CODE_FOR_nothing\n       && size - 1 < BITS_PER_WORD\n-      && mul_cost[wider_mode] + shift_cost[size-1] < max_cost)\n+      && mul_cost[wider_mode] + shift_cost[mode][size-1] < max_cost)\n     {\n       tem = expand_binop (wider_mode, moptab, op0, op1, 0,\n \t\t\t  unsignedp, OPTAB_WIDEN);\n@@ -2950,7 +2961,7 @@ expand_mult_highpart_optab (enum machine_mode mode, rtx op0, rtx op1,\n   moptab = unsignedp ? smul_widen_optab : umul_widen_optab;\n   if (moptab->handlers[wider_mode].insn_code != CODE_FOR_nothing\n       && size - 1 < BITS_PER_WORD\n-      && (mul_widen_cost[wider_mode] + 2 * shift_cost[size-1]\n+      && (mul_widen_cost[wider_mode] + 2 * shift_cost[mode][size-1]\n \t  + 4 * add_cost[mode] < max_cost))\n     {\n       tem = expand_binop (wider_mode, moptab, op0, narrow_op1,\n@@ -3004,7 +3015,7 @@ expand_mult_highpart (enum machine_mode mode, rtx op0,\n     return expand_mult_highpart_optab (mode, op0, op1, target,\n \t\t\t\t       unsignedp, max_cost);\n \n-  extra_cost = shift_cost[GET_MODE_BITSIZE (mode) - 1];\n+  extra_cost = shift_cost[mode][GET_MODE_BITSIZE (mode) - 1];\n \n   /* Check whether we try to multiply by a negative constant.  */\n   if (!unsignedp && ((cnst1 >> (GET_MODE_BITSIZE (mode) - 1)) & 1))\n@@ -3344,9 +3355,10 @@ expand_divmod (int rem_flag, enum tree_code code, enum machine_mode mode,\n \t\t\t    if (post_shift - 1 >= BITS_PER_WORD)\n \t\t\t      goto fail1;\n \n-\t\t\t    extra_cost = (shift_cost[post_shift - 1]\n-\t\t\t\t\t  + shift_cost[1]\n-\t\t\t\t\t  + 2 * add_cost[compute_mode]);\n+\t\t\t    extra_cost\n+\t\t\t      = (shift_cost[compute_mode][post_shift - 1]\n+\t\t\t\t + shift_cost[compute_mode][1]\n+\t\t\t\t + 2 * add_cost[compute_mode]);\n \t\t\t    t1 = expand_mult_highpart (compute_mode, op0, ml,\n \t\t\t\t\t\t       NULL_RTX, 1,\n \t\t\t\t\t\t       max_cost - extra_cost);\n@@ -3376,8 +3388,9 @@ expand_divmod (int rem_flag, enum tree_code code, enum machine_mode mode,\n \t\t\t    t1 = expand_shift (RSHIFT_EXPR, compute_mode, op0,\n \t\t\t\t\t       build_int_2 (pre_shift, 0),\n \t\t\t\t\t       NULL_RTX, 1);\n-\t\t\t    extra_cost = (shift_cost[pre_shift]\n-\t\t\t\t\t  + shift_cost[post_shift]);\n+\t\t\t    extra_cost\n+\t\t\t      = (shift_cost[compute_mode][pre_shift]\n+\t\t\t\t + shift_cost[compute_mode][post_shift]);\n \t\t\t    t2 = expand_mult_highpart (compute_mode, t1, ml,\n \t\t\t\t\t\t       NULL_RTX, 1,\n \t\t\t\t\t\t       max_cost - extra_cost);\n@@ -3511,8 +3524,8 @@ expand_divmod (int rem_flag, enum tree_code code, enum machine_mode mode,\n \t\t\t    || size - 1 >= BITS_PER_WORD)\n \t\t\t  goto fail1;\n \n-\t\t\textra_cost = (shift_cost[post_shift]\n-\t\t\t\t      + shift_cost[size - 1]\n+\t\t\textra_cost = (shift_cost[compute_mode][post_shift]\n+\t\t\t\t      + shift_cost[compute_mode][size - 1]\n \t\t\t\t      + add_cost[compute_mode]);\n \t\t\tt1 = expand_mult_highpart (compute_mode, op0, ml,\n \t\t\t\t\t\t   NULL_RTX, 0,\n@@ -3543,8 +3556,8 @@ expand_divmod (int rem_flag, enum tree_code code, enum machine_mode mode,\n \t\t\t  goto fail1;\n \n \t\t\tml |= (~(unsigned HOST_WIDE_INT) 0) << (size - 1);\n-\t\t\textra_cost = (shift_cost[post_shift]\n-\t\t\t\t      + shift_cost[size - 1]\n+\t\t\textra_cost = (shift_cost[compute_mode][post_shift]\n+\t\t\t\t      + shift_cost[compute_mode][size - 1]\n \t\t\t\t      + 2 * add_cost[compute_mode]);\n \t\t\tt1 = expand_mult_highpart (compute_mode, op0, ml,\n \t\t\t\t\t\t   NULL_RTX, 0,\n@@ -3634,8 +3647,8 @@ expand_divmod (int rem_flag, enum tree_code code, enum machine_mode mode,\n \t\t\t\t\t   NULL_RTX, 0);\n \t\t\tt2 = expand_binop (compute_mode, xor_optab, op0, t1,\n \t\t\t\t\t   NULL_RTX, 0, OPTAB_WIDEN);\n-\t\t\textra_cost = (shift_cost[post_shift]\n-\t\t\t\t      + shift_cost[size - 1]\n+\t\t\textra_cost = (shift_cost[compute_mode][post_shift]\n+\t\t\t\t      + shift_cost[compute_mode][size - 1]\n \t\t\t\t      + 2 * add_cost[compute_mode]);\n \t\t\tt3 = expand_mult_highpart (compute_mode, t2, ml,\n \t\t\t\t\t\t   NULL_RTX, 1,"}]}