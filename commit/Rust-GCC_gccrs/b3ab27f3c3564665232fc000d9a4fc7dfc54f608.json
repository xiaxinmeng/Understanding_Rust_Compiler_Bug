{"sha": "b3ab27f3c3564665232fc000d9a4fc7dfc54f608", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjNhYjI3ZjNjMzU2NDY2NTIzMmZjMDAwZDlhNGZjN2RmYzU0ZjYwOA==", "commit": {"author": {"name": "Mark Mitchell", "email": "mark@codesourcery.com", "date": "1999-09-24T20:54:08Z"}, "committer": {"name": "Mark Mitchell", "email": "mmitchel@gcc.gnu.org", "date": "1999-09-24T20:54:08Z"}, "message": "cp-tree.h (CPTI_CLEANUP_TYPE): New macro.\n\n\t* cp-tree.h (CPTI_CLEANUP_TYPE): New macro.\n\t(cleanup_type): Likewise.\n\t(search_tree): Change prototype.\n\t* decl.c (local_variable_p): Adjust for new interface to\n\tsearch_tree.\n\t(check_default_argument): Likewise.\n\t* error.c (dump_expr): Handle INIT_EXPR.\n\t* except.c (expand_throw): Don't make cleanup_type a local static.\n\t* expr.c (cplus_expand_expr): Don't handle NEW_EXPR.\n\t* init.c (build_new): Call build_new_1 directly, rather than\n\tbuilding a NEW_EXPR.\n\t(build_new_1): Tidy.  Don't build a VEC_INIT_EXPR except when\n\tprocessing file-scope initializers.\n\t* lex.c (init_parse): Add an opname_tab entry for INIT_EXPR.\n\t* tree.c: Include splay-tree.h\n\t(no_linkage_helper): Adjust for new interface to search_tree.\n\t(search_tree): Pass around pointers to tree nodes, rather than the\n\tnodes themselves.  Handle VEC_INIT_EXPR.\n\t(no_linkage_check): Adjust for new interface to search_tree.\n\t(mapcar): Handle VEC_INIT_EXPR.\n\t(target_remap): New variable.\n\t(bot_manip): Use it.\n\t(bot_replace): New function.\n\t(break_out_target_exprs): Use it to remap all variables used in a\n\tdefault argument expression.\n\t* typeck.c (build_modify_expr): Don't crash when outside a\n\tfunction and presented with an INIT_EXPR assignment\n\t* Makefile.in (tree.o): Depend on splay-tree.h.\n\nFrom-SVN: r29659", "tree": {"sha": "f016f005549032f3aa4a1f3b8935bf7659fccce5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f016f005549032f3aa4a1f3b8935bf7659fccce5"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b3ab27f3c3564665232fc000d9a4fc7dfc54f608", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b3ab27f3c3564665232fc000d9a4fc7dfc54f608", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b3ab27f3c3564665232fc000d9a4fc7dfc54f608", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b3ab27f3c3564665232fc000d9a4fc7dfc54f608/comments", "author": null, "committer": null, "parents": [{"sha": "d353a00cf3b107bd681ff47b597a55f5bd5b1bb3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d353a00cf3b107bd681ff47b597a55f5bd5b1bb3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d353a00cf3b107bd681ff47b597a55f5bd5b1bb3"}], "stats": {"total": 173, "additions": 137, "deletions": 36}, "files": [{"sha": "19485a5ae31a53889bcef63bd687d01f92f8e3cb", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b3ab27f3c3564665232fc000d9a4fc7dfc54f608/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b3ab27f3c3564665232fc000d9a4fc7dfc54f608/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=b3ab27f3c3564665232fc000d9a4fc7dfc54f608", "patch": "@@ -1,3 +1,34 @@\n+1999-09-24  Mark Mitchell  <mark@codesourcery.com>\n+\n+\t* cp-tree.h (CPTI_CLEANUP_TYPE): New macro.\n+\t(cleanup_type): Likewise.\n+\t(search_tree): Change prototype.\n+\t* decl.c (local_variable_p): Adjust for new interface to\n+\tsearch_tree.\n+\t(check_default_argument): Likewise.\n+\t* error.c (dump_expr): Handle INIT_EXPR.\n+\t* except.c (expand_throw): Don't make cleanup_type a local static.\n+\t* expr.c (cplus_expand_expr): Don't handle NEW_EXPR.\n+\t* init.c (build_new): Call build_new_1 directly, rather than\n+\tbuilding a NEW_EXPR.\n+\t(build_new_1): Tidy.  Don't build a VEC_INIT_EXPR except when\n+\tprocessing file-scope initializers.\n+\t* lex.c (init_parse): Add an opname_tab entry for INIT_EXPR.\n+\t* tree.c: Include splay-tree.h\n+\t(no_linkage_helper): Adjust for new interface to search_tree.\n+\t(search_tree): Pass around pointers to tree nodes, rather than the\n+\tnodes themselves.  Handle VEC_INIT_EXPR.\n+\t(no_linkage_check): Adjust for new interface to search_tree.\n+\t(mapcar): Handle VEC_INIT_EXPR.\n+\t(target_remap): New variable.\n+\t(bot_manip): Use it.\n+\t(bot_replace): New function.\n+\t(break_out_target_exprs): Use it to remap all variables used in a\n+\tdefault argument expression.\n+\t* typeck.c (build_modify_expr): Don't crash when outside a\n+\tfunction and presented with an INIT_EXPR assignment\n+\t* Makefile.in (tree.o): Depend on splay-tree.h.\n+\n Fri Sep 24 10:48:10 1999  Bernd Schmidt  <bernds@cygnus.co.uk>\n \n \t* decl.c (duplicate_decls): Use DECL_BUILT_IN_CLASS rather than"}, {"sha": "5f0b118f7264401012d9bbdc45a731784191aad1", "filename": "gcc/cp/Makefile.in", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b3ab27f3c3564665232fc000d9a4fc7dfc54f608/gcc%2Fcp%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b3ab27f3c3564665232fc000d9a4fc7dfc54f608/gcc%2Fcp%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FMakefile.in?ref=b3ab27f3c3564665232fc000d9a4fc7dfc54f608", "patch": "@@ -274,7 +274,8 @@ cvt.o : cvt.c $(CONFIG_H) $(CXX_TREE_H) $(srcdir)/../system.h decl.h \\\n search.o : search.c $(CONFIG_H) $(CXX_TREE_H) $(srcdir)/../stack.h \\\n   $(srcdir)/../flags.h $(srcdir)/../system.h $(srcdir)/../toplev.h $(RTL_H)\n tree.o : tree.c $(CONFIG_H) $(CXX_TREE_H) $(srcdir)/../flags.h \\\n-  $(srcdir)/../system.h $(srcdir)/../toplev.h $(srcdir)/../ggc.h $(RTL_H)\n+  $(srcdir)/../system.h $(srcdir)/../toplev.h $(srcdir)/../ggc.h $(RTL_H) \\\n+  $(srcdir)/../../include/splay-tree.h\n ptree.o : ptree.c $(CONFIG_H) $(CXX_TREE_H) $(srcdir)/../system.h\n rtti.o : rtti.c $(CONFIG_H) $(CXX_TREE_H) $(srcdir)/../flags.h \\\n   $(srcdir)/../system.h $(srcdir)/../toplev.h"}, {"sha": "584600e53c67a90fc333e45e1d504324c28fcc95", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b3ab27f3c3564665232fc000d9a4fc7dfc54f608/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b3ab27f3c3564665232fc000d9a4fc7dfc54f608/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=b3ab27f3c3564665232fc000d9a4fc7dfc54f608", "patch": "@@ -408,6 +408,7 @@ enum cp_tree_index\n     CPTI_WCHAR_DECL,\n     CPTI_VTABLE_ENTRY_TYPE,\n     CPTI_DELTA_TYPE,\n+    CPTI_CLEANUP_TYPE,\n \n     CPTI_TP_DESC_TYPE,\n     CPTI_ACCESS_MODE_TYPE,\n@@ -560,6 +561,9 @@ extern tree cp_global_trees[CPTI_MAX];\n /* The declaration for `std::atexit'.  */\n #define atexit_node                     cp_global_trees[CPTI_ATEXIT]\n \n+/* The type of a destructor.  */\n+#define cleanup_type                    cp_global_trees[CPTI_CLEANUP_TYPE]\n+\n /* Global state.  */\n \n struct saved_scope {\n@@ -3855,7 +3859,7 @@ extern void push_permanent_obstack              PROTO((void));\n extern tree build_dummy_object\t\t\tPROTO((tree));\n extern tree maybe_dummy_object\t\t\tPROTO((tree, tree *));\n extern int is_dummy_object\t\t\tPROTO((tree));\n-extern tree search_tree                         PROTO((tree, tree (*)(tree)));\n+extern tree search_tree                         PROTO((tree *, tree (*)(tree *)));\n extern int cp_valid_lang_attribute\t\tPROTO((tree, tree, tree, tree));\n extern tree make_ptrmem_cst                     PROTO((tree, tree));\n extern tree cp_build_qualified_type_real        PROTO((tree, int, int));"}, {"sha": "f456dbb090ab2e753c6c32a06e5fcd4158cafbd0", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b3ab27f3c3564665232fc000d9a4fc7dfc54f608/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b3ab27f3c3564665232fc000d9a4fc7dfc54f608/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=b3ab27f3c3564665232fc000d9a4fc7dfc54f608", "patch": "@@ -149,7 +149,7 @@ static boolean typename_compare PROTO((hash_table_key, hash_table_key));\n static void push_binding PROTO((tree, tree, struct binding_level*));\n static int add_binding PROTO((tree, tree));\n static void pop_binding PROTO((tree, tree));\n-static tree local_variable_p PROTO((tree));\n+static tree local_variable_p PROTO((tree *));\n static tree find_binding PROTO((tree, tree));\n static tree select_decl PROTO((tree, int));\n static int lookup_flags PROTO((int, int));\n@@ -11188,13 +11188,15 @@ require_complete_types_for_parms (parms)\n     }\n }\n \n-/* Returns DECL if DECL is a local variable (or parameter).  Returns\n+/* Returns *TP if *TP is a local variable (or parameter).  Returns\n    NULL_TREE otherwise.  */\n \n static tree\n-local_variable_p (t)\n-     tree t;\n+local_variable_p (tp)\n+     tree *tp;\n {\n+  tree t = *tp;\n+\n   if ((TREE_CODE (t) == VAR_DECL \n        /* A VAR_DECL with a context that is a _TYPE is a static data\n \t  member.  */\n@@ -11273,7 +11275,7 @@ check_default_argument (decl, arg)\n \n      The keyword `this' shall not be used in a default argument of a\n      member function.  */\n-  var = search_tree (arg, local_variable_p);\n+  var = search_tree (&arg, local_variable_p);\n   if (var)\n     {\n       cp_error (\"default argument `%E' uses local variable `%D'\","}, {"sha": "883a2e5e91eaaaf2d4758a2741546628a4ae3633", "filename": "gcc/cp/error.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b3ab27f3c3564665232fc000d9a4fc7dfc54f608/gcc%2Fcp%2Ferror.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b3ab27f3c3564665232fc000d9a4fc7dfc54f608/gcc%2Fcp%2Ferror.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ferror.c?ref=b3ab27f3c3564665232fc000d9a4fc7dfc54f608", "patch": "@@ -1476,6 +1476,7 @@ dump_expr (t, nop)\n \tdump_expr (TREE_OPERAND (t, 1), 0);\n       break;\n \n+    case INIT_EXPR:\n     case MODIFY_EXPR:\n     case PLUS_EXPR:\n     case MINUS_EXPR:"}, {"sha": "a078e65b4fd504187d841082808d83931b43d02a", "filename": "gcc/cp/except.c", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b3ab27f3c3564665232fc000d9a4fc7dfc54f608/gcc%2Fcp%2Fexcept.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b3ab27f3c3564665232fc000d9a4fc7dfc54f608/gcc%2Fcp%2Fexcept.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fexcept.c?ref=b3ab27f3c3564665232fc000d9a4fc7dfc54f608", "patch": "@@ -830,7 +830,6 @@ expand_throw (exp)\n      tree exp;\n {\n   tree fn;\n-  static tree cleanup_type;\n \n   if (! doing_eh (1))\n     return;"}, {"sha": "741174ee89a855901bd9a15c66ce102db6317573", "filename": "gcc/cp/expr.c", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b3ab27f3c3564665232fc000d9a4fc7dfc54f608/gcc%2Fcp%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b3ab27f3c3564665232fc000d9a4fc7dfc54f608/gcc%2Fcp%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fexpr.c?ref=b3ab27f3c3564665232fc000d9a4fc7dfc54f608", "patch": "@@ -239,9 +239,6 @@ cplus_expand_expr (exp, target, tmode, modifier)\n \t\t\t   integer_one_node),\n \t  TREE_OPERAND (exp, 1), 0), target, tmode, modifier);\n \n-    case NEW_EXPR:\n-      return expand_expr (build_new_1 (exp), target, tmode, modifier);\n-\n     case STMT_EXPR:\n       {\n \ttree rtl_expr = begin_stmt_expr ();"}, {"sha": "19d8c7458afa91e7743c122a66b1a944dc8f6c97", "filename": "gcc/cp/init.c", "status": "modified", "additions": 11, "deletions": 5, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b3ab27f3c3564665232fc000d9a4fc7dfc54f608/gcc%2Fcp%2Finit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b3ab27f3c3564665232fc000d9a4fc7dfc54f608/gcc%2Fcp%2Finit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Finit.c?ref=b3ab27f3c3564665232fc000d9a4fc7dfc54f608", "patch": "@@ -2065,6 +2065,9 @@ build_new (placement, decl, init, use_global_new)\n   rval = build (NEW_EXPR, build_pointer_type (type), placement, t, init);\n   NEW_EXPR_USE_GLOBAL (rval) = use_global_new;\n   TREE_SIDE_EFFECTS (rval) = 1;\n+  rval = build_new_1 (rval);\n+  if (rval == error_mark_node)\n+    return error_mark_node;\n \n   /* Wrap it in a NOP_EXPR so warn_if_unused_value doesn't complain.  */\n   rval = build1 (NOP_EXPR, TREE_TYPE (rval), rval);\n@@ -2188,11 +2191,7 @@ build_new_1 (exp)\n \t\t      && TREE_TYPE (TREE_VALUE (placement)) == ptr_type_node));\n \n   if (use_cookie)\n-    {\n-      tree extra = BI_header_size;\n-\n-      size = size_binop (PLUS_EXPR, size, extra);\n-    }\n+    size = size_binop (PLUS_EXPR, size, BI_header_size);\n \n   if (has_array)\n     {\n@@ -2378,6 +2377,13 @@ build_new_1 (exp)\n \t  rval = newrval;\n \t  TREE_HAS_CONSTRUCTOR (rval) = 1;\n \t}\n+      else if (current_function_decl)\n+\trval = (build_vec_init\n+\t\t(NULL_TREE, \n+\t\t save_expr (rval),\n+\t\t build_binary_op (MINUS_EXPR, nelts, integer_one_node),\n+\t\t init,\n+\t\t /*from_array=*/0));\n       else\n \trval = build (VEC_INIT_EXPR, TREE_TYPE (rval),\n \t\t      save_expr (rval), init, nelts);"}, {"sha": "b61cad4cb10034abc6b683d8a2c9cd57c77506a3", "filename": "gcc/cp/lex.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b3ab27f3c3564665232fc000d9a4fc7dfc54f608/gcc%2Fcp%2Flex.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b3ab27f3c3564665232fc000d9a4fc7dfc54f608/gcc%2Fcp%2Flex.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Flex.c?ref=b3ab27f3c3564665232fc000d9a4fc7dfc54f608", "patch": "@@ -795,6 +795,7 @@ init_parse (filename)\n   opname_tab[(int) INDIRECT_REF] = \"*\";\n   opname_tab[(int) ARRAY_REF] = \"[]\";\n   opname_tab[(int) MODIFY_EXPR] = \"=\";\n+  opname_tab[(int) INIT_EXPR] = \"=\";\n   opname_tab[(int) NEW_EXPR] = \"new\";\n   opname_tab[(int) DELETE_EXPR] = \"delete\";\n   opname_tab[(int) VEC_NEW_EXPR] = \"new []\";"}, {"sha": "1253c949a206aa624de022e6a44dec8d6dbe83ce", "filename": "gcc/cp/tree.c", "status": "modified", "additions": 77, "deletions": 19, "changes": 96, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b3ab27f3c3564665232fc000d9a4fc7dfc54f608/gcc%2Fcp%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b3ab27f3c3564665232fc000d9a4fc7dfc54f608/gcc%2Fcp%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftree.c?ref=b3ab27f3c3564665232fc000d9a4fc7dfc54f608", "patch": "@@ -28,16 +28,18 @@ Boston, MA 02111-1307, USA.  */\n #include \"rtl.h\"\n #include \"toplev.h\"\n #include \"ggc.h\"\n+#include \"splay-tree.h\"\n \n static tree bot_manip PROTO((tree));\n+static tree bot_replace PROTO((tree *));\n static tree build_cplus_array_type_1 PROTO((tree, tree));\n static void list_hash_add PROTO((int, tree));\n static int list_hash PROTO((tree, tree, tree));\n static tree list_hash_lookup PROTO((int, tree, tree, tree));\n static void propagate_binfo_offsets PROTO((tree, tree));\n static int avoid_overlap PROTO((tree, tree));\n static cp_lvalue_kind lvalue_p_1 PROTO((tree, int));\n-static tree no_linkage_helper PROTO((tree));\n+static tree no_linkage_helper PROTO((tree *));\n static tree build_srcloc PROTO((char *, int));\n static void mark_list_hash PROTO ((void *));\n \n@@ -1529,19 +1531,20 @@ copy_template_template_parm (t)\n    non-null, return that value.  */\n \n tree\n-search_tree (t, func)\n-     tree t;\n-     tree (*func) PROTO((tree));\n+search_tree (tp, func)\n+     tree *tp;\n+     tree (*func) PROTO((tree *));\n {\n-#define TRY(ARG) if (tmp=search_tree (ARG, func), tmp != NULL_TREE) return tmp\n+#define TRY(ARG) if (tmp=search_tree (&ARG, func), tmp != NULL_TREE) return tmp\n \n+  tree t = *tp;\n   tree tmp;\n   enum tree_code code; \n-\n+  \n   if (t == NULL_TREE)\n-    return t;\n+    return NULL_TREE;\n   \n-  tmp = func (t);\n+  tmp = func (tp);\n   if (tmp)\n     return tmp;\n \n@@ -1618,6 +1621,7 @@ search_tree (t, func)\n     case TARGET_EXPR:\n     case AGGR_INIT_EXPR:\n     case NEW_EXPR:\n+    case VEC_INIT_EXPR:\n       TRY (TREE_OPERAND (t, 0));\n       TRY (TREE_OPERAND (t, 1));\n       TRY (TREE_OPERAND (t, 2));\n@@ -1737,9 +1741,11 @@ search_tree (t, func)\n /* Passed to search_tree.  Checks for the use of types with no linkage.  */\n \n static tree\n-no_linkage_helper (t)\n-     tree t;\n+no_linkage_helper (tp)\n+     tree *tp;\n {\n+  tree t = *tp;\n+\n   if (TYPE_P (t)\n       && (IS_AGGR_TYPE (t) || TREE_CODE (t) == ENUMERAL_TYPE)\n       && (decl_function_context (TYPE_MAIN_DECL (t))\n@@ -1760,7 +1766,7 @@ no_linkage_check (t)\n   if (processing_template_decl)\n     return NULL_TREE;\n \n-  t = search_tree (t, no_linkage_helper);\n+  t = search_tree (&t, no_linkage_helper);\n   if (t != error_mark_node)\n     return t;\n   return NULL_TREE;\n@@ -1986,6 +1992,7 @@ mapcar (t, func)\n       return t;\n \n     case NEW_EXPR:\n+    case VEC_INIT_EXPR:\n       t = copy_node (t);\n       TREE_OPERAND (t, 0) = mapcar (TREE_OPERAND (t, 0), func);\n       TREE_OPERAND (t, 1) = mapcar (TREE_OPERAND (t, 1), func);\n@@ -2093,39 +2100,90 @@ array_type_nelts_total (type)\n   return sz;\n }\n \n-static\n-tree\n+/* When we parse a default argument expression, we may create\n+   temporary variables via TARGET_EXPRs.  When we actually use the\n+   default-argument expression, we make a copy of the expression, but\n+   we must relpace the temporaries with appropriate local versions.  */\n+\n+/* A map from VAR_DECLs declared in TARGET_EXPRs in a default argument\n+   to corresponding \"instantiations\" of those variables.  */\n+static splay_tree target_remap;\n+static int target_remap_count;\n+\n+/* Called from break_out_target_exprs via mapcar.  */\n+\n+static tree\n bot_manip (t)\n      tree t;\n {\n   if (TREE_CODE (t) != TREE_LIST && ! TREE_SIDE_EFFECTS (t))\n     return t;\n   else if (TREE_CODE (t) == TARGET_EXPR)\n     {\n+      tree u;\n+\n       if (TREE_CODE (TREE_OPERAND (t, 1)) == AGGR_INIT_EXPR)\n \t{\n \t  mark_used (TREE_OPERAND (TREE_OPERAND (TREE_OPERAND (t, 1), 0), 0));\n-\t  return build_cplus_new\n+\t  u = build_cplus_new\n \t    (TREE_TYPE (t), break_out_target_exprs (TREE_OPERAND (t, 1)));\n \t}\n-      t = copy_node (t);\n-      TREE_OPERAND (t, 0) = build (VAR_DECL, TREE_TYPE (t));\n-      layout_decl (TREE_OPERAND (t, 0), 0);\n-      return t;\n+      else \n+\t{\n+\t  u = copy_node (t);\n+\t  TREE_OPERAND (u, 0) = build (VAR_DECL, TREE_TYPE (t));\n+\t  layout_decl (TREE_OPERAND (u, 0), 0);\n+\t}\n+\n+      /* Map the old variable to the new one.  */\n+      splay_tree_insert (target_remap, \n+\t\t\t (splay_tree_key) TREE_OPERAND (t, 0), \n+\t\t\t (splay_tree_value) TREE_OPERAND (u, 0));\n+      return u;\n     }\n   else if (TREE_CODE (t) == CALL_EXPR)\n     mark_used (TREE_OPERAND (TREE_OPERAND (t, 0), 0));\n \n   return NULL_TREE;\n }\n   \n+/* Replace all remapped VAR_DECLs in T with their new equivalents.  */\n+\n+static tree\n+bot_replace (t)\n+     tree *t;\n+{\n+  if (TREE_CODE (*t) == VAR_DECL)\n+    {\n+      splay_tree_node n = splay_tree_lookup (target_remap,\n+\t\t\t\t\t     (splay_tree_key) *t);\n+      if (n)\n+\t*t = (tree) n->value;\n+    }\n+\n+  return NULL_TREE;\n+}\n+\t\n /* Actually, we'll just clean out the target exprs for the moment.  */\n \n tree\n break_out_target_exprs (t)\n      tree t;\n {\n-  return mapcar (t, bot_manip);\n+  if (!target_remap_count++)\n+    target_remap = splay_tree_new (splay_tree_compare_pointers, \n+\t\t\t\t   /*splay_tree_delete_key_fn=*/NULL, \n+\t\t\t\t   /*splay_tree_delete_value_fn=*/NULL);\n+  t = mapcar (t, bot_manip);\n+  search_tree (&t, bot_replace);\n+\n+  if (!--target_remap_count)\n+    {\n+      splay_tree_delete (target_remap);\n+      target_remap = NULL;\n+    }\n+\n+  return t;\n }\n \n /* Obstack used for allocating nodes in template function and variable"}, {"sha": "80be5f850baeb687be0a59a47f6cc23513446323", "filename": "gcc/cp/typeck.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b3ab27f3c3564665232fc000d9a4fc7dfc54f608/gcc%2Fcp%2Ftypeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b3ab27f3c3564665232fc000d9a4fc7dfc54f608/gcc%2Fcp%2Ftypeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck.c?ref=b3ab27f3c3564665232fc000d9a4fc7dfc54f608", "patch": "@@ -5877,7 +5877,8 @@ build_modify_expr (lhs, modifycode, rhs)\n     {\n       newrhs = convert_for_initialization (lhs, lhstype, newrhs, LOOKUP_NORMAL,\n \t\t\t\t\t   \"assignment\", NULL_TREE, 0);\n-      if (lhs == DECL_RESULT (current_function_decl))\n+      if (current_function_decl && \n+\t  lhs == DECL_RESULT (current_function_decl))\n \t{\n \t  if (DECL_INITIAL (lhs))\n \t    warning (\"return value from function receives multiple initializations\");"}]}