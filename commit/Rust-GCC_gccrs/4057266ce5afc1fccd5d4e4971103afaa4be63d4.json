{"sha": "4057266ce5afc1fccd5d4e4971103afaa4be63d4", "node_id": "C_kwDOANBUbNoAKDQwNTcyNjZjZTVhZmMxZmNjZDVkNGU0OTcxMTAzYWZhYTRiZTYzZDQ", "commit": {"author": {"name": "Richard Sandiford", "email": "richard.sandiford@arm.com", "date": "2022-02-09T16:57:05Z"}, "committer": {"name": "Richard Sandiford", "email": "richard.sandiford@arm.com", "date": "2022-02-09T16:57:05Z"}, "message": "aarch64: Add a general vec_concat expander\n\nAfter previous patches, we have a (mostly new) group of vec_concat\npatterns as well as vestiges of the old move_lo/hi_quad patterns.\n(A previous patch removed the move_lo_quad insns, but we still\nhave the move_hi_quad insns and both sets of expanders.)\n\nThis patch is the first of two to remove the old move_lo/hi_quad\nstuff.  It isn't technically a regression fix, but it seemed\nbetter to make the changes now rather than leave things in\na half-finished and inconsistent state.\n\nThis patch defines an aarch64_vec_concat expander that coerces the\nelement operands into a valid form, including the ones added by the\nprevious patch.  This in turn lets us get rid of one move_lo/hi_quad\npair.\n\nAs a side-effect, it also means that vcombines of 2 vectors make\nbetter use of the available forms, like vec_inits of 2 scalars\nalready do.\n\ngcc/\n\t* config/aarch64/aarch64-protos.h (aarch64_split_simd_combine):\n\tDelete.\n\t* config/aarch64/aarch64-simd.md (@aarch64_combinez<mode>): Rename\n\tto...\n\t(*aarch64_combinez<mode>): ...this.\n\t(@aarch64_combinez_be<mode>): Rename to...\n\t(*aarch64_combinez_be<mode>): ...this.\n\t(@aarch64_vec_concat<mode>): New expander.\n\t(aarch64_combine<mode>): Use it.\n\t(@aarch64_simd_combine<mode>): Delete.\n\t* config/aarch64/aarch64.cc (aarch64_split_simd_combine): Delete.\n\t(aarch64_expand_vector_init): Use aarch64_vec_concat.\n\ngcc/testsuite/\n\t* gcc.target/aarch64/vec-init-12.c: New test.", "tree": {"sha": "04ea2c2249ee2bcf0374f35570b8fb69f059b1a1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/04ea2c2249ee2bcf0374f35570b8fb69f059b1a1"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/4057266ce5afc1fccd5d4e4971103afaa4be63d4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4057266ce5afc1fccd5d4e4971103afaa4be63d4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4057266ce5afc1fccd5d4e4971103afaa4be63d4", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4057266ce5afc1fccd5d4e4971103afaa4be63d4/comments", "author": {"login": "rsandifo-arm", "id": 28043039, "node_id": "MDQ6VXNlcjI4MDQzMDM5", "avatar_url": "https://avatars.githubusercontent.com/u/28043039?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rsandifo-arm", "html_url": "https://github.com/rsandifo-arm", "followers_url": "https://api.github.com/users/rsandifo-arm/followers", "following_url": "https://api.github.com/users/rsandifo-arm/following{/other_user}", "gists_url": "https://api.github.com/users/rsandifo-arm/gists{/gist_id}", "starred_url": "https://api.github.com/users/rsandifo-arm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rsandifo-arm/subscriptions", "organizations_url": "https://api.github.com/users/rsandifo-arm/orgs", "repos_url": "https://api.github.com/users/rsandifo-arm/repos", "events_url": "https://api.github.com/users/rsandifo-arm/events{/privacy}", "received_events_url": "https://api.github.com/users/rsandifo-arm/received_events", "type": "User", "site_admin": false}, "committer": {"login": "rsandifo-arm", "id": 28043039, "node_id": "MDQ6VXNlcjI4MDQzMDM5", "avatar_url": "https://avatars.githubusercontent.com/u/28043039?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rsandifo-arm", "html_url": "https://github.com/rsandifo-arm", "followers_url": "https://api.github.com/users/rsandifo-arm/followers", "following_url": "https://api.github.com/users/rsandifo-arm/following{/other_user}", "gists_url": "https://api.github.com/users/rsandifo-arm/gists{/gist_id}", "starred_url": "https://api.github.com/users/rsandifo-arm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rsandifo-arm/subscriptions", "organizations_url": "https://api.github.com/users/rsandifo-arm/orgs", "repos_url": "https://api.github.com/users/rsandifo-arm/repos", "events_url": "https://api.github.com/users/rsandifo-arm/events{/privacy}", "received_events_url": "https://api.github.com/users/rsandifo-arm/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "85ac2fe44fd4acf8350dd74ccb003a2050baad2a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/85ac2fe44fd4acf8350dd74ccb003a2050baad2a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/85ac2fe44fd4acf8350dd74ccb003a2050baad2a"}], "stats": {"total": 198, "additions": 122, "deletions": 76}, "files": [{"sha": "392efa0b74d22e80d2b1c3a5435fd74b8dea2878", "filename": "gcc/config/aarch64/aarch64-protos.h", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4057266ce5afc1fccd5d4e4971103afaa4be63d4/gcc%2Fconfig%2Faarch64%2Faarch64-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4057266ce5afc1fccd5d4e4971103afaa4be63d4/gcc%2Fconfig%2Faarch64%2Faarch64-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Faarch64-protos.h?ref=4057266ce5afc1fccd5d4e4971103afaa4be63d4", "patch": "@@ -925,8 +925,6 @@ bool aarch64_split_128bit_move_p (rtx, rtx);\n \n bool aarch64_mov128_immediate (rtx);\n \n-void aarch64_split_simd_combine (rtx, rtx, rtx);\n-\n void aarch64_split_simd_move (rtx, rtx);\n \n /* Check for a legitimate floating point constant for FMOV.  */"}, {"sha": "7acde0dd099d34a4610a4d886fb93148d183cb34", "filename": "gcc/config/aarch64/aarch64-simd.md", "status": "modified", "additions": 50, "deletions": 26, "changes": 76, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4057266ce5afc1fccd5d4e4971103afaa4be63d4/gcc%2Fconfig%2Faarch64%2Faarch64-simd.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4057266ce5afc1fccd5d4e4971103afaa4be63d4/gcc%2Fconfig%2Faarch64%2Faarch64-simd.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Faarch64-simd.md?ref=4057266ce5afc1fccd5d4e4971103afaa4be63d4", "patch": "@@ -4403,7 +4403,7 @@\n ;; In this insn, operand 1 should be low, and operand 2 the high part of the\n ;; dest vector.\n \n-(define_insn \"@aarch64_combinez<mode>\"\n+(define_insn \"*aarch64_combinez<mode>\"\n   [(set (match_operand:<VDBL> 0 \"register_operand\" \"=w,w,w\")\n \t(vec_concat:<VDBL>\n \t  (match_operand:VDC 1 \"nonimmediate_operand\" \"w,?r,m\")\n@@ -4417,7 +4417,7 @@\n    (set_attr \"arch\" \"simd,fp,simd\")]\n )\n \n-(define_insn \"@aarch64_combinez_be<mode>\"\n+(define_insn \"*aarch64_combinez_be<mode>\"\n   [(set (match_operand:<VDBL> 0 \"register_operand\" \"=w,w,w\")\n         (vec_concat:<VDBL>\n \t  (match_operand:VDC 2 \"aarch64_simd_or_scalar_imm_zero\")\n@@ -4431,38 +4431,62 @@\n    (set_attr \"arch\" \"simd,fp,simd\")]\n )\n \n-(define_expand \"aarch64_combine<mode>\"\n-  [(match_operand:<VDBL> 0 \"register_operand\")\n-   (match_operand:VDC 1 \"register_operand\")\n-   (match_operand:VDC 2 \"aarch64_simd_reg_or_zero\")]\n+;; Form a vector whose first half (in array order) comes from operand 1\n+;; and whose second half (in array order) comes from operand 2.\n+;; This operand order follows the RTL vec_concat operation.\n+(define_expand \"@aarch64_vec_concat<mode>\"\n+  [(set (match_operand:<VDBL> 0 \"register_operand\")\n+\t(vec_concat:<VDBL>\n+\t  (match_operand:VDC 1 \"general_operand\")\n+\t  (match_operand:VDC 2 \"general_operand\")))]\n   \"TARGET_SIMD\"\n {\n-  if (operands[2] == CONST0_RTX (<MODE>mode))\n+  int lo = BYTES_BIG_ENDIAN ? 2 : 1;\n+  int hi = BYTES_BIG_ENDIAN ? 1 : 2;\n+\n+  if (MEM_P (operands[1])\n+      && MEM_P (operands[2])\n+      && aarch64_mergeable_load_pair_p (<VDBL>mode, operands[1], operands[2]))\n+    /* Use load_pair_lanes<mode>.  */\n+    ;\n+  else if (operands[hi] == CONST0_RTX (<MODE>mode))\n     {\n-      if (BYTES_BIG_ENDIAN)\n-\temit_insn (gen_aarch64_combinez_be<mode> (operands[0], operands[1],\n-\t\t\t\t\t\t  operands[2]));\n-      else\n-\temit_insn (gen_aarch64_combinez<mode> (operands[0], operands[1],\n-\t\t\t\t\t       operands[2]));\n+      /* Use *aarch64_combinez<mode>.  */\n+      if (!nonimmediate_operand (operands[lo], <MODE>mode))\n+\toperands[lo] = force_reg (<MODE>mode, operands[lo]);\n     }\n   else\n-    aarch64_split_simd_combine (operands[0], operands[1], operands[2]);\n-  DONE;\n-}\n-)\n+    {\n+      /* Use *aarch64_combine_general<mode>.  */\n+      operands[lo] = force_reg (<MODE>mode, operands[lo]);\n+      if (!aarch64_simd_nonimmediate_operand (operands[hi], <MODE>mode))\n+\t{\n+\t  if (MEM_P (operands[hi]))\n+\t    {\n+\t      rtx addr = force_reg (Pmode, XEXP (operands[hi], 0));\n+\t      operands[hi] = replace_equiv_address (operands[hi], addr);\n+\t    }\n+\t  else\n+\t    operands[hi] = force_reg (<MODE>mode, operands[hi]);\n+\t}\n+    }\n+})\n \n-(define_expand \"@aarch64_simd_combine<mode>\"\n+;; Form a vector whose least significant half comes from operand 1 and whose\n+;; most significant half comes from operand 2.  This operand order follows\n+;; arm_neon.h vcombine* intrinsics.\n+(define_expand \"aarch64_combine<mode>\"\n   [(match_operand:<VDBL> 0 \"register_operand\")\n-   (match_operand:VDC 1 \"register_operand\")\n-   (match_operand:VDC 2 \"register_operand\")]\n+   (match_operand:VDC 1 \"general_operand\")\n+   (match_operand:VDC 2 \"general_operand\")]\n   \"TARGET_SIMD\"\n-  {\n-    emit_insn (gen_move_lo_quad_<Vdbl> (operands[0], operands[1]));\n-    emit_insn (gen_move_hi_quad_<Vdbl> (operands[0], operands[2]));\n-    DONE;\n-  }\n-[(set_attr \"type\" \"multiple\")]\n+{\n+  if (BYTES_BIG_ENDIAN)\n+    std::swap (operands[1], operands[2]);\n+  emit_insn (gen_aarch64_vec_concat<mode> (operands[0], operands[1],\n+\t\t\t\t\t   operands[2]));\n+  DONE;\n+}\n )\n \n ;; <su><addsub>l<q>."}, {"sha": "af42d1bedfe21cbed62e6a0405a50bc9ea480f61", "filename": "gcc/config/aarch64/aarch64.cc", "status": "modified", "additions": 7, "deletions": 48, "changes": 55, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4057266ce5afc1fccd5d4e4971103afaa4be63d4/gcc%2Fconfig%2Faarch64%2Faarch64.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4057266ce5afc1fccd5d4e4971103afaa4be63d4/gcc%2Fconfig%2Faarch64%2Faarch64.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Faarch64.cc?ref=4057266ce5afc1fccd5d4e4971103afaa4be63d4", "patch": "@@ -4239,23 +4239,6 @@ aarch64_split_128bit_move_p (rtx dst, rtx src)\n   return true;\n }\n \n-/* Split a complex SIMD combine.  */\n-\n-void\n-aarch64_split_simd_combine (rtx dst, rtx src1, rtx src2)\n-{\n-  machine_mode src_mode = GET_MODE (src1);\n-  machine_mode dst_mode = GET_MODE (dst);\n-\n-  gcc_assert (VECTOR_MODE_P (dst_mode));\n-  gcc_assert (register_operand (dst, dst_mode)\n-\t      && register_operand (src1, src_mode)\n-\t      && register_operand (src2, src_mode));\n-\n-  emit_insn (gen_aarch64_simd_combine (src_mode, dst, src1, src2));\n-  return;\n-}\n-\n /* Split a complex SIMD move.  */\n \n void\n@@ -20941,37 +20924,13 @@ aarch64_expand_vector_init (rtx target, rtx vals)\n      of mode N in VALS and we must put their concatentation into TARGET.  */\n   if (XVECLEN (vals, 0) == 2 && VECTOR_MODE_P (GET_MODE (XVECEXP (vals, 0, 0))))\n     {\n-      gcc_assert (known_eq (GET_MODE_SIZE (mode),\n-\t\t  2 * GET_MODE_SIZE (GET_MODE (XVECEXP (vals, 0, 0)))));\n-      rtx lo = XVECEXP (vals, 0, 0);\n-      rtx hi = XVECEXP (vals, 0, 1);\n-      machine_mode narrow_mode = GET_MODE (lo);\n-      gcc_assert (GET_MODE_INNER (narrow_mode) == inner_mode);\n-      gcc_assert (narrow_mode == GET_MODE (hi));\n-\n-      /* When we want to concatenate a half-width vector with zeroes we can\n-\t use the aarch64_combinez[_be] patterns.  Just make sure that the\n-\t zeroes are in the right half.  */\n-      if (BYTES_BIG_ENDIAN\n-\t  && aarch64_simd_imm_zero (lo, narrow_mode)\n-\t  && general_operand (hi, narrow_mode))\n-\temit_insn (gen_aarch64_combinez_be (narrow_mode, target, hi, lo));\n-      else if (!BYTES_BIG_ENDIAN\n-\t       && aarch64_simd_imm_zero (hi, narrow_mode)\n-\t       && general_operand (lo, narrow_mode))\n-\temit_insn (gen_aarch64_combinez (narrow_mode, target, lo, hi));\n-      else\n-\t{\n-\t  /* Else create the two half-width registers and combine them.  */\n-\t  if (!REG_P (lo))\n-\t    lo = force_reg (GET_MODE (lo), lo);\n-\t  if (!REG_P (hi))\n-\t    hi = force_reg (GET_MODE (hi), hi);\n-\n-\t  if (BYTES_BIG_ENDIAN)\n-\t    std::swap (lo, hi);\n-\t  emit_insn (gen_aarch64_simd_combine (narrow_mode, target, lo, hi));\n-\t}\n+      machine_mode narrow_mode = GET_MODE (XVECEXP (vals, 0, 0));\n+      gcc_assert (GET_MODE_INNER (narrow_mode) == inner_mode\n+\t\t  && known_eq (GET_MODE_SIZE (mode),\n+\t\t\t       2 * GET_MODE_SIZE (narrow_mode)));\n+      emit_insn (gen_aarch64_vec_concat (narrow_mode, target,\n+\t\t\t\t\t XVECEXP (vals, 0, 0),\n+\t\t\t\t\t XVECEXP (vals, 0, 1)));\n      return;\n    }\n "}, {"sha": "c287478e2d8fa3ba45fbe41088c6d14b65d8f825", "filename": "gcc/testsuite/gcc.target/aarch64/vec-init-12.c", "status": "added", "additions": 65, "deletions": 0, "changes": 65, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4057266ce5afc1fccd5d4e4971103afaa4be63d4/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fvec-init-12.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4057266ce5afc1fccd5d4e4971103afaa4be63d4/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fvec-init-12.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fvec-init-12.c?ref=4057266ce5afc1fccd5d4e4971103afaa4be63d4", "patch": "@@ -0,0 +1,65 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O\" } */\n+/* { dg-final { check-function-bodies \"**\" \"\" \"\" { target lp64 } } } */\n+\n+#include <arm_neon.h>\n+\n+/*\n+** s32_1:\n+**\tldr\tq0, \\[x0\\]\n+**\tret\n+*/\n+int32x4_t s32_1(int32x2_t *ptr) {\n+  if (__BYTE_ORDER__ == __ORDER_BIG_ENDIAN__)\n+    return vcombine_s32 (ptr[1], ptr[0]);\n+  else\n+    return vcombine_s32 (ptr[0], ptr[1]);\n+}\n+/*\n+** s32_2:\n+**\tadd\tx([0-9])+, x0, #?8\n+**\tld1\t{v0\\.d}\\[1\\], \\[x\\1\\]\n+**\tret\n+*/\n+int32x4_t s32_2(int32x2_t a0, int32x2_t *ptr) {\n+  return vcombine_s32 (a0, ptr[1]);\n+}\n+/*\n+** s32_3:\n+**\tldr\td0, \\[x0\\], #?16\n+**\tld1\t{v0\\.d}\\[1\\], \\[x0\\]\n+**\tret\n+*/\n+int32x4_t s32_3(int32x2_t *ptr) {\n+  return vcombine_s32 (ptr[0], ptr[2]);\n+}\n+\n+/*\n+** f32_1:\n+**\tldr\tq0, \\[x0\\]\n+**\tret\n+*/\n+float32x4_t f32_1(float32x2_t *ptr) {\n+  if (__BYTE_ORDER__ == __ORDER_BIG_ENDIAN__)\n+    return vcombine_f32 (ptr[1], ptr[0]);\n+  else\n+    return vcombine_f32 (ptr[0], ptr[1]);\n+}\n+/*\n+** f32_2:\n+**\tadd\tx([0-9])+, x0, #?8\n+**\tld1\t{v0\\.d}\\[1\\], \\[x\\1\\]\n+**\tret\n+*/\n+float32x4_t f32_2(float32x2_t a0, float32x2_t *ptr) {\n+  return vcombine_f32 (a0, ptr[1]);\n+}\n+/*\n+** f32_3:\n+**\tldr\td0, \\[x0\\], #?16\n+**\tld1\t{v0\\.d}\\[1\\], \\[x0\\]\n+**\tret\n+*/\n+float32x4_t f32_3(float32x2_t *ptr) {\n+  return vcombine_f32 (ptr[0], ptr[2]);\n+}"}]}