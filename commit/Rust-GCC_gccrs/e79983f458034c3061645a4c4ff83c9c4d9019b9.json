{"sha": "e79983f458034c3061645a4c4ff83c9c4d9019b9", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTc5OTgzZjQ1ODAzNGMzMDYxNjQ1YTRjNGZmODNjOWM0ZDkwMTliOQ==", "commit": {"author": {"name": "Michael Meissner", "email": "meissner@linux.vnet.ibm.com", "date": "2011-10-11T19:55:09Z"}, "committer": {"name": "Michael Meissner", "email": "meissner@gcc.gnu.org", "date": "2011-10-11T19:55:09Z"}, "message": "Convert standard builtin functions from being arrays to using a functional interface\n\nFrom-SVN: r179820", "tree": {"sha": "304b794b6f6f0af1f79b00f4166b897337141fac", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/304b794b6f6f0af1f79b00f4166b897337141fac"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e79983f458034c3061645a4c4ff83c9c4d9019b9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e79983f458034c3061645a4c4ff83c9c4d9019b9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e79983f458034c3061645a4c4ff83c9c4d9019b9", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e79983f458034c3061645a4c4ff83c9c4d9019b9/comments", "author": null, "committer": null, "parents": [{"sha": "f0286f957326b588ba6f49d1fed0c14c19033830", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f0286f957326b588ba6f49d1fed0c14c19033830", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f0286f957326b588ba6f49d1fed0c14c19033830"}], "stats": {"total": 1319, "additions": 853, "deletions": 466}, "files": [{"sha": "9be1e21ace55fab12e4378748832d3c39244f3b7", "filename": "gcc/ChangeLog", "status": "modified", "additions": 126, "deletions": 0, "changes": 126, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e79983f458034c3061645a4c4ff83c9c4d9019b9/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e79983f458034c3061645a4c4ff83c9c4d9019b9/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=e79983f458034c3061645a4c4ff83c9c4d9019b9", "patch": "@@ -1,3 +1,129 @@\n+2011-10-11  Michael Meissner  <meissner@linux.vnet.ibm.com>\n+\n+\t* tree.h (built_in_decls): Delete old interface with two parallel\n+\tarrays to hold standard builtin declarations, and replace it with\n+\ta function based interface that can support creating builtins on\n+\tthe fly in the future.  Change all uses, and poison the old\n+\tnames.  Make sure 0 is not a legitimate builtin index.\n+\t(implicit_built_in_decls): Ditto.\n+\t(built_in_info): Ditto.\n+\t(BUILTIN_VALID_P): Ditto.\n+\t(builtin_decl_explicit): Ditto.\n+\t(builtin_decl_implicit): Ditto.\n+\t(set_builtin_decl): Ditto.\n+\t(set_builtin_decl_implicit_p): Ditto.\n+\t(builtin_decl_explicit_p): Ditto.\n+\t(builtin_decl_implicit_p): Ditto.\n+\t* tree-complex.c (expand_complex_libcall): Ditto.\n+\t* tree-loop-distribution.c (generate_memset_zero): Ditto.\n+\t* tree-ssa-strlen.c (get_string_length): Ditto.\n+\t(handle_builtin_strcpy): Ditto.\n+\t(handle_builtin_strcat): Ditto.\n+\t* tree.c (iterative_hash_expr): Ditto.\n+\t(local_define_builtin): Ditto.\n+\t(build_common_builtin_nodes): Ditto.\n+\t* builtins.c (built_in_decls): Ditto.\n+\t(implicit_built_in_decls): Ditto.\n+\t(built_in_info): Ditto\n+\t(expand_builtin_classify_type): Ditto.\n+\t(mathfn_built_in_1): Ditto.\n+\t(expand_builtin_cexpi): Ditto.\n+\t(expand_builtin_mempcpy_args): Ditto.\n+\t(expand_builtin_stpcpy): Ditto.\n+\t(gimplify_va_arg_expr): Ditto.\n+\t(expand_builtin_sync_operation): Ditto.\n+\t(build_builtin_expect_predicate): Ditto.\n+\t(fold_builtin_memory_op): Ditto.\n+\t(fold_builtin_strcpy): Ditto.\n+\t(fold_builtin_stpcpy): Ditto.\n+\t(fold_builtin_strncpy): Ditto.\n+\t(fold_builtin_interclass_mathfn): Ditto.\n+\t(fold_builtin_classify): Ditto.\n+\t(fold_builtin_2): Ditto.\n+\t(fold_builtin_strstr): Ditto.\n+\t(fold_builtin_strrchr): Ditto.\n+\t(fold_builtin_strpbrk): Ditto.\n+\t(fold_builtin_strcat): Ditto.\n+\t(fold_builtin_strncat): Ditto.\n+\t(fold_builtin_strcspn): Ditto.\n+\t(fold_builtin_fputs): Ditto.\n+\t(fold_builtin_sprintf): Ditto.\n+\t(fold_builtin_snprintf): Ditto.\n+\t(expand_builtin_memory_chk): Ditto.\n+\t(fold_builtin_memory_chk): Ditto.\n+\t(fold_builtin_stxcpy_chk): Ditto.\n+\t(fold_builtin_strncpy_chk): Ditto.\n+\t(fold_builtin_strcat_chk): Ditto.\n+\t(fold_builtin_strncat_chk): Ditto.\n+\t(fold_builtin_sprintf_chk_1): Ditto.\n+\t(fold_builtin_snprintf_chk_1): Ditto.\n+\t(fold_builtin_printf): Ditto.\n+\t(fold_builtin_fprintf): Ditto.\n+\t(fold_call_stmt): Ditto.\n+\t(set_builtin_user_assembler_name): Ditto.\n+\t* tree-emutls.c (emutls_common_1): Ditto.\n+\t* omp-low.c (scan_omp): Ditto.\n+\t(lower_rec_input_clauses): Ditto.\n+\t(lower_reduction_clauses): Ditto.\n+\t(expand_parallel_call): Ditto.\n+\t(expand_task_call): Ditto.\n+\t(maybe_catch_exception): Ditto.\n+\t(optimize_omp_library_calls): Ditto.\n+\t(expand_omp_for_generic): Ditto.\n+\t(expand_omp_for_static_nochunk): Ditto.\n+\t(expand_omp_for_static_chunk): Ditto.\n+\t(expand_omp_sections): Ditto.\n+\t(expand_omp_atomic_fetch_op): Ditto.\n+\t(expand_omp_atomic_pipeline): Ditto.\n+\t(expand_omp_atomic_mutex): Ditto.\n+\t(lower_omp_single_simple): Ditto.\n+\t(lower_omp_single_copy): Ditto.\n+\t(lower_omp_master): Ditto.\n+\t(lower_omp_ordered): Ditto.\n+\t(lower_omp_critical): Ditto.\n+\t* tree-ssa-ccp.c (optimize_stdarg_builtin): Ditto.\n+\t* builtins.c (DEF_BUILTIN_STUB): Ditto.\n+\t(BUILT_IN_NONE): Ditto.\n+\t* tree-ssa-math-opts.c (execute_optimize_bswap): Ditto.\n+\t* gimple-low.c (lower_function_body): Ditto.\n+\t(lower_builtin_setjmp): Ditto.\n+\t* c-decl.c (merge_decls): Ditto.\n+\t* tree-eh.c (lower_resx): Ditto.\n+\t(lower_resx): Ditto.\n+\t(lower_eh_dispatch): Ditto.\n+\t* function (gimplify_parameters): Ditto.\n+\t* c-typeck.c (build_function_call_vec): Ditto.\n+\t* gimplify.c (build_stack_save_restore): Ditto.\n+\t(gimplify_vla_decl): Ditto.\n+\t(gimplify_modify_expr_to_memcpy): Ditto.\n+\t(gimplify_modify_expr_to_memset): Ditto.\n+\t(gimplify_variable_sized_compare): Ditto.\n+\t(gimplify_function_tree): Ditto.\n+\t* calls.c (emit_call_1): Ditto.\n+\t* tree-ssa-forprop.c (simplify_builtin_call): Ditto.\n+\t* tree-nested.c (convert_nl_goto_reference): Ditto.\n+\t(convert_tramp_reference_op): Ditto.\n+\t(finalize_nesting_tree_1): Ditto.\n+\t* tree-ssa-loop-prefetch.c (issue_prefetch_ref): Ditto.\n+\t(tree_ssa_prefetch_arrays): Ditto.\n+\t* tree-streamer-in.c (streamer_get_builtin_tree): Ditto.\n+\t* system.h (built_in_decls): Ditto.\n+\t(implicit_built_in_decls): Ditto.\n+\t* tree-vect-generic.c (expand_vector_operations_1): Ditto.\n+\t* config/sparc/sparc.c (sparc_gimplify_va_arg): Ditto.\n+\t* config/i386/i386.c (ix86_gimplify_va_arg): Ditto.\n+\t(ix86_veclibabi_svml): Ditto.\n+\t(ix86_veclibabi_acml): Ditto.\n+\t* config/vms/vms.c (vms_patch_builtins): Ditto.\n+\t* config/ia64/ia64.c (ia64_init_builtins): Ditto.\n+\t* config/rs6000/rs6000.c (rs6000_gimplify_va_arg): Ditto.\n+\t(rs6000_builtin_vectorized_libmass): Ditto.\n+\t(rs6000_init_builtins): Ditto.\n+\t* config/darwin.c (darwin_override_options): Ditto.\n+\t(darwin_patch_builtin): Ditto.\n+\t(darwin_rename_builtins): Ditto.\n+\t* config/pa/pa.c (pa_init_builtins): Ditto.\n+\n 2011-10-11  Bill Schmidt  <wschmidt@linux.vnet.ibm.com>\n \n \t* tree.h (copy_ref_info): Expose existing function."}, {"sha": "bbcb20bafcc96271b21d7eb1687fd26d0524bc26", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e79983f458034c3061645a4c4ff83c9c4d9019b9/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e79983f458034c3061645a4c4ff83c9c4d9019b9/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=e79983f458034c3061645a4c4ff83c9c4d9019b9", "patch": "@@ -1,3 +1,14 @@\n+2011-10-11  Michael Meissner  <meissner@linux.vnet.ibm.com>\n+\n+\t* gcc-interface/utils.c (def_builtin_1): Delete old interface with\n+\ttwo parallel arrays to hold standard builtin declarations, and\n+\treplace it with a function based interface that can support\n+\tcreating builtins on the fly in the future.  Change all uses, and\n+\tpoison the old names.  Make sure 0 is not a legitimate builtin\n+\tindex.\n+\t* gcc-interface/trans.c (Exception_Handler_to_gnu_zcx): Ditto.\n+\t(gnat_to_gnu): Ditto.\n+\n 2011-10-07  Eric Botcazou  <ebotcazou@adacore.com>\n \n \tPR lto/50492"}, {"sha": "858810ae4e84a7009ebf53208ff50336e0c73a45", "filename": "gcc/ada/gcc-interface/trans.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e79983f458034c3061645a4c4ff83c9c4d9019b9/gcc%2Fada%2Fgcc-interface%2Ftrans.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e79983f458034c3061645a4c4ff83c9c4d9019b9/gcc%2Fada%2Fgcc-interface%2Ftrans.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Ftrans.c?ref=e79983f458034c3061645a4c4ff83c9c4d9019b9", "patch": "@@ -4230,7 +4230,7 @@ Exception_Handler_to_gnu_zcx (Node_Id gnat_node)\n      time, and reuse it to feed the end_handler hook's argument at exit.  */\n \n   gnu_current_exc_ptr\n-    = build_call_expr (built_in_decls [BUILT_IN_EH_POINTER],\n+    = build_call_expr (builtin_decl_explicit (BUILT_IN_EH_POINTER),\n \t\t       1, integer_zero_node);\n   prev_gnu_incoming_exc_ptr = gnu_incoming_exc_ptr;\n   gnu_incoming_exc_ptr = create_var_decl (get_identifier (\"EXPTR\"), NULL_TREE,\n@@ -5520,7 +5520,7 @@ gnat_to_gnu (Node_Id gnat_node)\n \t      to_ptr = build_fold_addr_expr (to);\n \t      from_ptr = build_fold_addr_expr (from);\n \n-\t      t = implicit_built_in_decls[BUILT_IN_MEMMOVE];\n+\t      t = builtin_decl_implicit (BUILT_IN_MEMMOVE);\n \t      gnu_result = build_call_expr (t, 3, to_ptr, from_ptr, size);\n \t   }\n \t}"}, {"sha": "7c7e7c6c499819eb7fd3f4efb91a03b0e0e12bc5", "filename": "gcc/ada/gcc-interface/utils.c", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e79983f458034c3061645a4c4ff83c9c4d9019b9/gcc%2Fada%2Fgcc-interface%2Futils.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e79983f458034c3061645a4c4ff83c9c4d9019b9/gcc%2Fada%2Fgcc-interface%2Futils.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Futils.c?ref=e79983f458034c3061645a4c4ff83c9c4d9019b9", "patch": "@@ -5657,7 +5657,7 @@ def_builtin_1 (enum built_in_function fncode,\n \n   /* Preserve an already installed decl.  It most likely was setup in advance\n      (e.g. as part of the internal builtins) for specific reasons.  */\n-  if (built_in_decls[(int) fncode] != NULL_TREE)\n+  if (builtin_decl_explicit (fncode) != NULL_TREE)\n     return;\n \n   gcc_assert ((!both_p && !fallback_p)\n@@ -5674,9 +5674,7 @@ def_builtin_1 (enum built_in_function fncode,\n     add_builtin_function (libname, libtype, fncode, fnclass,\n \t\t\t  NULL, fnattrs);\n \n-  built_in_decls[(int) fncode] = decl;\n-  if (implicit_p)\n-    implicit_built_in_decls[(int) fncode] = decl;\n+  set_builtin_decl (fncode, decl, implicit_p);\n }\n \n static int flag_isoc94 = 0;"}, {"sha": "296c5b7dd91001c5686e5bc76d8b04c9930c9ded", "filename": "gcc/builtins.c", "status": "modified", "additions": 94, "deletions": 92, "changes": 186, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e79983f458034c3061645a4c4ff83c9c4d9019b9/gcc%2Fbuiltins.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e79983f458034c3061645a4c4ff83c9c4d9019b9/gcc%2Fbuiltins.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbuiltins.c?ref=e79983f458034c3061645a4c4ff83c9c4d9019b9", "patch": "@@ -75,11 +75,7 @@ const char * built_in_names[(int) END_BUILTINS] =\n \n /* Setup an array of _DECL trees, make sure each element is\n    initialized to NULL_TREE.  */\n-tree built_in_decls[(int) END_BUILTINS];\n-/* Declarations used when constructing the builtin implicitly in the compiler.\n-   It may be NULL_TREE when this is invalid (for instance runtime is not\n-   required to implement the function call in all cases).  */\n-tree implicit_built_in_decls[(int) END_BUILTINS];\n+builtin_info_type builtin_info;\n \n static const char *c_getstr (tree);\n static rtx c_readstr (const char *, enum machine_mode);\n@@ -1791,17 +1787,15 @@ expand_builtin_classify_type (tree exp)\n   fcode = BUILT_IN_MATHFN##_R; fcodef = BUILT_IN_MATHFN##F_R ; \\\n   fcodel = BUILT_IN_MATHFN##L_R ; break;\n \n-/* Return mathematic function equivalent to FN but operating directly\n-   on TYPE, if available.  If IMPLICIT is true find the function in\n-   implicit_built_in_decls[], otherwise use built_in_decls[].  If we\n-   can't do the conversion, return zero.  */\n+/* Return mathematic function equivalent to FN but operating directly on TYPE,\n+   if available.  If IMPLICIT is true use the implicit builtin declaration,\n+   otherwise use the explicit declaration.  If we can't do the conversion,\n+   return zero.  */\n \n static tree\n-mathfn_built_in_1 (tree type, enum built_in_function fn, bool implicit)\n+mathfn_built_in_1 (tree type, enum built_in_function fn, bool implicit_p)\n {\n-  tree const *const fn_arr\n-    = implicit ? implicit_built_in_decls : built_in_decls;\n-  enum built_in_function fcode, fcodef, fcodel;\n+  enum built_in_function fcode, fcodef, fcodel, fcode2;\n \n   switch (fn)\n     {\n@@ -1898,13 +1892,18 @@ mathfn_built_in_1 (tree type, enum built_in_function fn, bool implicit)\n       }\n \n   if (TYPE_MAIN_VARIANT (type) == double_type_node)\n-    return fn_arr[fcode];\n+    fcode2 = fcode;\n   else if (TYPE_MAIN_VARIANT (type) == float_type_node)\n-    return fn_arr[fcodef];\n+    fcode2 = fcodef;\n   else if (TYPE_MAIN_VARIANT (type) == long_double_type_node)\n-    return fn_arr[fcodel];\n+    fcode2 = fcodel;\n   else\n     return NULL_TREE;\n+\n+  if (implicit_p && !builtin_decl_implicit_p (fcode2))\n+    return NULL_TREE;\n+\n+  return builtin_decl_explicit (fcode2);\n }\n \n /* Like mathfn_built_in_1(), but always use the implicit array.  */\n@@ -2554,11 +2553,11 @@ expand_builtin_cexpi (tree exp, rtx target)\n       rtx op1a, op2a;\n \n       if (DECL_FUNCTION_CODE (fndecl) == BUILT_IN_CEXPIF)\n-\tfn = built_in_decls[BUILT_IN_SINCOSF];\n+\tfn = builtin_decl_explicit (BUILT_IN_SINCOSF);\n       else if (DECL_FUNCTION_CODE (fndecl) == BUILT_IN_CEXPI)\n-\tfn = built_in_decls[BUILT_IN_SINCOS];\n+\tfn = builtin_decl_explicit (BUILT_IN_SINCOS);\n       else if (DECL_FUNCTION_CODE (fndecl) == BUILT_IN_CEXPIL)\n-\tfn = built_in_decls[BUILT_IN_SINCOSL];\n+\tfn = builtin_decl_explicit (BUILT_IN_SINCOSL);\n       else\n \tgcc_unreachable ();\n \n@@ -2580,11 +2579,11 @@ expand_builtin_cexpi (tree exp, rtx target)\n       tree ctype = build_complex_type (type);\n \n       if (DECL_FUNCTION_CODE (fndecl) == BUILT_IN_CEXPIF)\n-\tfn = built_in_decls[BUILT_IN_CEXPF];\n+\tfn = builtin_decl_explicit (BUILT_IN_CEXPF);\n       else if (DECL_FUNCTION_CODE (fndecl) == BUILT_IN_CEXPI)\n-\tfn = built_in_decls[BUILT_IN_CEXP];\n+\tfn = builtin_decl_explicit (BUILT_IN_CEXP);\n       else if (DECL_FUNCTION_CODE (fndecl) == BUILT_IN_CEXPIL)\n-\tfn = built_in_decls[BUILT_IN_CEXPL];\n+\tfn = builtin_decl_explicit (BUILT_IN_CEXPL);\n       else\n \tgcc_unreachable ();\n \n@@ -3129,9 +3128,9 @@ expand_builtin_mempcpy_args (tree dest, tree src, tree len,\n \t\t\t     rtx target, enum machine_mode mode, int endp)\n {\n     /* If return value is ignored, transform mempcpy into memcpy.  */\n-  if (target == const0_rtx && implicit_built_in_decls[BUILT_IN_MEMCPY])\n+  if (target == const0_rtx && builtin_decl_implicit_p (BUILT_IN_MEMCPY))\n     {\n-      tree fn = implicit_built_in_decls[BUILT_IN_MEMCPY];\n+      tree fn = builtin_decl_implicit (BUILT_IN_MEMCPY);\n       tree result = build_call_nofold_loc (UNKNOWN_LOCATION, fn, 3,\n \t\t\t\t\t   dest, src, len);\n       return expand_expr (result, target, mode, EXPAND_NORMAL);\n@@ -3292,9 +3291,9 @@ expand_builtin_stpcpy (tree exp, rtx target, enum machine_mode mode)\n   src = CALL_EXPR_ARG (exp, 1);\n \n   /* If return value is ignored, transform stpcpy into strcpy.  */\n-  if (target == const0_rtx && implicit_built_in_decls[BUILT_IN_STRCPY])\n+  if (target == const0_rtx && builtin_decl_implicit (BUILT_IN_STRCPY))\n     {\n-      tree fn = implicit_built_in_decls[BUILT_IN_STRCPY];\n+      tree fn = builtin_decl_implicit (BUILT_IN_STRCPY);\n       tree result = build_call_nofold_loc (loc, fn, 2, dst, src);\n       return expand_expr (result, target, mode, EXPAND_NORMAL);\n     }\n@@ -4353,7 +4352,7 @@ gimplify_va_arg_expr (tree *expr_p, gimple_seq *pre_p, gimple_seq *post_p)\n \t expression to exit or longjmp.  */\n       gimplify_and_add (valist, pre_p);\n       t = build_call_expr_loc (loc,\n-\t\t\t       implicit_built_in_decls[BUILT_IN_TRAP], 0);\n+\t\t\t       builtin_decl_implicit (BUILT_IN_TRAP), 0);\n       gimplify_and_add (t, pre_p);\n \n       /* This is dead code, but go ahead and finish so that the\n@@ -5126,7 +5125,7 @@ expand_builtin_sync_operation (enum machine_mode mode, tree exp,\n \t  if (warned_f_a_n)\n \t    break;\n \n-\t  fndecl = implicit_built_in_decls[BUILT_IN_SYNC_FETCH_AND_NAND_N];\n+\t  fndecl = builtin_decl_implicit (BUILT_IN_SYNC_FETCH_AND_NAND_N);\n \t  inform (loc, \"%qD changed semantics in GCC 4.4\", fndecl);\n \t  warned_f_a_n = true;\n \t  break;\n@@ -5140,7 +5139,7 @@ expand_builtin_sync_operation (enum machine_mode mode, tree exp,\n \t  if (warned_n_a_f)\n \t    break;\n \n-\t  fndecl = implicit_built_in_decls[BUILT_IN_SYNC_NAND_AND_FETCH_N];\n+\t fndecl = builtin_decl_implicit (BUILT_IN_SYNC_NAND_AND_FETCH_N);\n \t  inform (loc, \"%qD changed semantics in GCC 4.4\", fndecl);\n \t  warned_n_a_f = true;\n \t  break;\n@@ -6247,7 +6246,7 @@ build_builtin_expect_predicate (location_t loc, tree pred, tree expected)\n {\n   tree fn, arg_types, pred_type, expected_type, call_expr, ret_type;\n \n-  fn = built_in_decls[BUILT_IN_EXPECT];\n+  fn = builtin_decl_explicit (BUILT_IN_EXPECT);\n   arg_types = TYPE_ARG_TYPES (TREE_TYPE (fn));\n   ret_type = TREE_TYPE (TREE_TYPE (fn));\n   pred_type = TREE_VALUE (arg_types);\n@@ -8039,7 +8038,7 @@ fold_builtin_memory_op (location_t loc, tree dest, tree src,\n \t\t  && (MIN (src_align, dest_align) / BITS_PER_UNIT\n \t\t      >= (unsigned HOST_WIDE_INT) tree_low_cst (len, 1))))\n \t    {\n-\t      tree fn = implicit_built_in_decls[BUILT_IN_MEMCPY];\n+\t      tree fn = builtin_decl_implicit (BUILT_IN_MEMCPY);\n \t      if (!fn)\n \t\treturn NULL_TREE;\n               return build_call_expr_loc (loc, fn, 3, dest, src, len);\n@@ -8098,7 +8097,7 @@ fold_builtin_memory_op (location_t loc, tree dest, tree src,\n \t      else\n \t\treturn NULL_TREE;\n \n-\t      fn = implicit_built_in_decls[BUILT_IN_MEMCPY];\n+\t      fn = builtin_decl_implicit (BUILT_IN_MEMCPY);\n \t      if (!fn)\n \t\treturn NULL_TREE;\n \t      return build_call_expr_loc (loc, fn, 3, dest, src, len);\n@@ -8117,7 +8116,7 @@ fold_builtin_memory_op (location_t loc, tree dest, tree src,\n \t      if (!refs_may_alias_p_1 (&destr, &srcr, false))\n \t\t{\n \t\t  tree fn;\n-\t\t  fn = implicit_built_in_decls[BUILT_IN_MEMCPY];\n+\t\t  fn = builtin_decl_implicit (BUILT_IN_MEMCPY);\n \t\t  if (!fn)\n \t\t    return NULL_TREE;\n \t\t  return build_call_expr_loc (loc, fn, 3, dest, src, len);\n@@ -8292,7 +8291,7 @@ fold_builtin_strcpy (location_t loc, tree fndecl, tree dest, tree src, tree len)\n   if (optimize_function_for_size_p (cfun))\n     return NULL_TREE;\n \n-  fn = implicit_built_in_decls[BUILT_IN_MEMCPY];\n+  fn = builtin_decl_implicit (BUILT_IN_MEMCPY);\n   if (!fn)\n     return NULL_TREE;\n \n@@ -8331,7 +8330,7 @@ fold_builtin_stpcpy (location_t loc, tree fndecl, tree dest, tree src)\n       && !integer_zerop (len))\n     return NULL_TREE;\n \n-  fn = implicit_built_in_decls[BUILT_IN_MEMCPY];\n+  fn = builtin_decl_implicit (BUILT_IN_MEMCPY);\n   if (!fn)\n     return NULL_TREE;\n \n@@ -8390,7 +8389,7 @@ fold_builtin_strncpy (location_t loc, tree fndecl, tree dest,\n     return NULL_TREE;\n \n   /* OK transform into builtin memcpy.  */\n-  fn = implicit_built_in_decls[BUILT_IN_MEMCPY];\n+  fn = builtin_decl_implicit (BUILT_IN_MEMCPY);\n   if (!fn)\n     return NULL_TREE;\n \n@@ -9213,7 +9212,7 @@ fold_builtin_interclass_mathfn (location_t loc, tree fndecl, tree arg)\n     CASE_FLT_FN (BUILT_IN_ISINF):\n       {\n \t/* isinf(x) -> isgreater(fabs(x),DBL_MAX).  */\n-\ttree const isgr_fn = built_in_decls[BUILT_IN_ISGREATER];\n+\ttree const isgr_fn = builtin_decl_explicit (BUILT_IN_ISGREATER);\n \ttree const type = TREE_TYPE (arg);\n \tREAL_VALUE_TYPE r;\n \tchar buf[128];\n@@ -9229,7 +9228,7 @@ fold_builtin_interclass_mathfn (location_t loc, tree fndecl, tree arg)\n     case BUILT_IN_ISFINITE:\n       {\n \t/* isfinite(x) -> islessequal(fabs(x),DBL_MAX).  */\n-\ttree const isle_fn = built_in_decls[BUILT_IN_ISLESSEQUAL];\n+\ttree const isle_fn = builtin_decl_explicit (BUILT_IN_ISLESSEQUAL);\n \ttree const type = TREE_TYPE (arg);\n \tREAL_VALUE_TYPE r;\n \tchar buf[128];\n@@ -9252,8 +9251,8 @@ fold_builtin_interclass_mathfn (location_t loc, tree fndecl, tree arg)\n       {\n \t/* isnormal(x) -> isgreaterequal(fabs(x),DBL_MIN) &\n \t   islessequal(fabs(x),DBL_MAX).  */\n-\ttree const isle_fn = built_in_decls[BUILT_IN_ISLESSEQUAL];\n-\ttree const isge_fn = built_in_decls[BUILT_IN_ISGREATEREQUAL];\n+\ttree const isle_fn = builtin_decl_explicit (BUILT_IN_ISLESSEQUAL);\n+\ttree const isge_fn = builtin_decl_explicit (BUILT_IN_ISGREATEREQUAL);\n \ttree const type = TREE_TYPE (arg);\n \tREAL_VALUE_TYPE rmax, rmin;\n \tchar buf[128];\n@@ -9314,7 +9313,7 @@ fold_builtin_classify (location_t loc, tree fndecl, tree arg, int builtin_index)\n \t   1.  So e.g. \"if (isinf_sign(x))\" would be folded to just\n \t   \"if (isinf(x) ? 1 : 0)\" which becomes \"if (isinf(x))\". */\n \ttree signbit_fn = mathfn_built_in_1 (TREE_TYPE (arg), BUILT_IN_SIGNBIT, 0);\n-\ttree isinf_fn = built_in_decls[BUILT_IN_ISINF];\n+\ttree isinf_fn = builtin_decl_explicit (BUILT_IN_ISINF);\n \ttree tmp = NULL_TREE;\n \n \targ = builtin_save_expr (arg);\n@@ -10037,7 +10036,7 @@ fold_builtin_2 (location_t loc, tree fndecl, tree arg0, tree arg1, bool ignore)\n     case BUILT_IN_STPCPY:\n       if (ignore)\n \t{\n-\t  tree fn = implicit_built_in_decls[BUILT_IN_STRCPY];\n+\t  tree fn = builtin_decl_implicit (BUILT_IN_STRCPY);\n \t  if (!fn)\n \t    break;\n \n@@ -10837,7 +10836,7 @@ fold_builtin_strstr (location_t loc, tree s1, tree s2, tree type)\n       if (p2[1] != '\\0')\n \treturn NULL_TREE;\n \n-      fn = implicit_built_in_decls[BUILT_IN_STRCHR];\n+      fn = builtin_decl_implicit (BUILT_IN_STRCHR);\n       if (!fn)\n \treturn NULL_TREE;\n \n@@ -10957,7 +10956,7 @@ fold_builtin_strrchr (location_t loc, tree s1, tree s2, tree type)\n       if (! integer_zerop (s2))\n \treturn NULL_TREE;\n \n-      fn = implicit_built_in_decls[BUILT_IN_STRCHR];\n+      fn = builtin_decl_implicit (BUILT_IN_STRCHR);\n       if (!fn)\n \treturn NULL_TREE;\n \n@@ -11021,7 +11020,7 @@ fold_builtin_strpbrk (location_t loc, tree s1, tree s2, tree type)\n       if (p2[1] != '\\0')\n \treturn NULL_TREE;  /* Really call strpbrk.  */\n \n-      fn = implicit_built_in_decls[BUILT_IN_STRCHR];\n+      fn = builtin_decl_implicit (BUILT_IN_STRCHR);\n       if (!fn)\n \treturn NULL_TREE;\n \n@@ -11068,8 +11067,8 @@ fold_builtin_strcat (location_t loc ATTRIBUTE_UNUSED, tree dst, tree src)\n \t{\n \t  /* See if we can store by pieces into (dst + strlen(dst)).  */\n \t  tree newdst, call;\n-\t  tree strlen_fn = implicit_built_in_decls[BUILT_IN_STRLEN];\n-\t  tree strcpy_fn = implicit_built_in_decls[BUILT_IN_STRCPY];\n+\t  tree strlen_fn = builtin_decl_implicit (BUILT_IN_STRLEN);\n+\t  tree strcpy_fn = builtin_decl_implicit (BUILT_IN_STRCPY);\n \n \t  if (!strlen_fn || !strcpy_fn)\n \t    return NULL_TREE;\n@@ -11142,7 +11141,7 @@ fold_builtin_strncat (location_t loc, tree dst, tree src, tree len)\n       if (TREE_CODE (len) == INTEGER_CST && p\n \t  && compare_tree_int (len, strlen (p)) >= 0)\n \t{\n-\t  tree fn = implicit_built_in_decls[BUILT_IN_STRCAT];\n+\t  tree fn = builtin_decl_implicit (BUILT_IN_STRCAT);\n \n \t  /* If the replacement _DECL isn't initialized, don't do the\n \t     transformation.  */\n@@ -11247,7 +11246,7 @@ fold_builtin_strcspn (location_t loc, tree s1, tree s2)\n       /* If the second argument is \"\", return __builtin_strlen(s1).  */\n       if (p2 && *p2 == '\\0')\n \t{\n-\t  tree fn = implicit_built_in_decls[BUILT_IN_STRLEN];\n+\t  tree fn = builtin_decl_implicit (BUILT_IN_STRLEN);\n \n \t  /* If the replacement _DECL isn't initialized, don't do the\n \t     transformation.  */\n@@ -11273,10 +11272,12 @@ fold_builtin_fputs (location_t loc, tree arg0, tree arg1,\n {\n   /* If we're using an unlocked function, assume the other unlocked\n      functions exist explicitly.  */\n-  tree const fn_fputc = unlocked ? built_in_decls[BUILT_IN_FPUTC_UNLOCKED]\n-    : implicit_built_in_decls[BUILT_IN_FPUTC];\n-  tree const fn_fwrite = unlocked ? built_in_decls[BUILT_IN_FWRITE_UNLOCKED]\n-    : implicit_built_in_decls[BUILT_IN_FWRITE];\n+  tree const fn_fputc = (unlocked\n+\t\t\t ? builtin_decl_explicit (BUILT_IN_FPUTC_UNLOCKED)\n+\t\t\t : builtin_decl_implicit (BUILT_IN_FPUTC));\n+  tree const fn_fwrite = (unlocked\n+\t\t\t  ? builtin_decl_explicit (BUILT_IN_FWRITE_UNLOCKED)\n+\t\t\t  : builtin_decl_implicit (BUILT_IN_FWRITE));\n \n   /* If the return value is used, don't do the transformation.  */\n   if (!ignore)\n@@ -11470,7 +11471,7 @@ fold_builtin_sprintf (location_t loc, tree dest, tree fmt,\n   /* If the format doesn't contain % args or %%, use strcpy.  */\n   if (strchr (fmt_str, target_percent) == NULL)\n     {\n-      tree fn = implicit_built_in_decls[BUILT_IN_STRCPY];\n+      tree fn = builtin_decl_implicit (BUILT_IN_STRCPY);\n \n       if (!fn)\n \treturn NULL_TREE;\n@@ -11490,7 +11491,7 @@ fold_builtin_sprintf (location_t loc, tree dest, tree fmt,\n   else if (fmt_str && strcmp (fmt_str, target_percent_s) == 0)\n     {\n       tree fn;\n-      fn = implicit_built_in_decls[BUILT_IN_STRCPY];\n+      fn = builtin_decl_implicit (BUILT_IN_STRCPY);\n \n       if (!fn)\n \treturn NULL_TREE;\n@@ -11512,7 +11513,7 @@ fold_builtin_sprintf (location_t loc, tree dest, tree fmt,\n   if (call && retval)\n     {\n       retval = fold_convert_loc\n-\t(loc, TREE_TYPE (TREE_TYPE (implicit_built_in_decls[BUILT_IN_SPRINTF])),\n+\t(loc, TREE_TYPE (TREE_TYPE (builtin_decl_implicit (BUILT_IN_SPRINTF))),\n \t retval);\n       return build2 (COMPOUND_EXPR, TREE_TYPE (retval), call, retval);\n     }\n@@ -11565,7 +11566,7 @@ fold_builtin_snprintf (location_t loc, tree dest, tree destsize, tree fmt,\n   /* If the format doesn't contain % args or %%, use strcpy.  */\n   if (strchr (fmt_str, target_percent) == NULL)\n     {\n-      tree fn = implicit_built_in_decls[BUILT_IN_STRCPY];\n+      tree fn = builtin_decl_implicit (BUILT_IN_STRCPY);\n       size_t len = strlen (fmt_str);\n \n       /* Don't optimize snprintf (buf, 4, \"abc\", ptr++).  */\n@@ -11597,7 +11598,7 @@ fold_builtin_snprintf (location_t loc, tree dest, tree destsize, tree fmt,\n   /* If the format is \"%s\", use strcpy if the result isn't used.  */\n   else if (fmt_str && strcmp (fmt_str, target_percent_s) == 0)\n     {\n-      tree fn = implicit_built_in_decls[BUILT_IN_STRCPY];\n+      tree fn = builtin_decl_implicit (BUILT_IN_STRCPY);\n       unsigned HOST_WIDE_INT origlen;\n \n       /* Don't crash on snprintf (str1, cst, \"%s\").  */\n@@ -11632,7 +11633,7 @@ fold_builtin_snprintf (location_t loc, tree dest, tree destsize, tree fmt,\n \n   if (call && retval)\n     {\n-      tree fn = built_in_decls[BUILT_IN_SNPRINTF];\n+      tree fn = builtin_decl_explicit (BUILT_IN_SNPRINTF);\n       retval = fold_convert_loc (loc, TREE_TYPE (TREE_TYPE (fn)), retval);\n       return build2 (COMPOUND_EXPR, TREE_TYPE (retval), call, retval);\n     }\n@@ -11720,16 +11721,16 @@ expand_builtin_memory_chk (tree exp, rtx target, enum machine_mode mode,\n       switch (fcode)\n \t{\n \tcase BUILT_IN_MEMCPY_CHK:\n-\t  fn = built_in_decls[BUILT_IN_MEMCPY];\n+\t  fn = builtin_decl_explicit (BUILT_IN_MEMCPY);\n \t  break;\n \tcase BUILT_IN_MEMPCPY_CHK:\n-\t  fn = built_in_decls[BUILT_IN_MEMPCPY];\n+\t  fn = builtin_decl_explicit (BUILT_IN_MEMPCPY);\n \t  break;\n \tcase BUILT_IN_MEMMOVE_CHK:\n-\t  fn = built_in_decls[BUILT_IN_MEMMOVE];\n+\t  fn = builtin_decl_explicit (BUILT_IN_MEMMOVE);\n \t  break;\n \tcase BUILT_IN_MEMSET_CHK:\n-\t  fn = built_in_decls[BUILT_IN_MEMSET];\n+\t  fn = builtin_decl_explicit (BUILT_IN_MEMSET);\n \t  break;\n \tdefault:\n \t  break;\n@@ -11781,7 +11782,7 @@ expand_builtin_memory_chk (tree exp, rtx target, enum machine_mode mode,\n \t     normal __memcpy_chk.  */\n \t  if (readonly_data_expr (src))\n \t    {\n-\t      tree fn = built_in_decls[BUILT_IN_MEMCPY_CHK];\n+\t      tree fn = builtin_decl_explicit (BUILT_IN_MEMCPY_CHK);\n \t      if (!fn)\n \t\treturn NULL_RTX;\n \t      fn = build_call_nofold_loc (EXPR_LOCATION (exp), fn, 4,\n@@ -12045,7 +12046,7 @@ fold_builtin_memory_chk (location_t loc, tree fndecl,\n \t\t{\n \t\t  /* (void) __mempcpy_chk () can be optimized into\n \t\t     (void) __memcpy_chk ().  */\n-\t\t  fn = built_in_decls[BUILT_IN_MEMCPY_CHK];\n+\t\t  fn = builtin_decl_explicit (BUILT_IN_MEMCPY_CHK);\n \t\t  if (!fn)\n \t\t    return NULL_TREE;\n \n@@ -12067,16 +12068,16 @@ fold_builtin_memory_chk (location_t loc, tree fndecl,\n   switch (fcode)\n     {\n     case BUILT_IN_MEMCPY_CHK:\n-      fn = built_in_decls[BUILT_IN_MEMCPY];\n+      fn = builtin_decl_explicit (BUILT_IN_MEMCPY);\n       break;\n     case BUILT_IN_MEMPCPY_CHK:\n-      fn = built_in_decls[BUILT_IN_MEMPCPY];\n+      fn = builtin_decl_explicit (BUILT_IN_MEMPCPY);\n       break;\n     case BUILT_IN_MEMMOVE_CHK:\n-      fn = built_in_decls[BUILT_IN_MEMMOVE];\n+      fn = builtin_decl_explicit (BUILT_IN_MEMMOVE);\n       break;\n     case BUILT_IN_MEMSET_CHK:\n-      fn = built_in_decls[BUILT_IN_MEMSET];\n+      fn = builtin_decl_explicit (BUILT_IN_MEMSET);\n       break;\n     default:\n       break;\n@@ -12131,7 +12132,7 @@ fold_builtin_stxcpy_chk (location_t loc, tree fndecl, tree dest,\n \n \t\t  /* If return value of __stpcpy_chk is ignored,\n \t\t     optimize into __strcpy_chk.  */\n-\t\t  fn = built_in_decls[BUILT_IN_STRCPY_CHK];\n+\t\t  fn = builtin_decl_explicit (BUILT_IN_STRCPY_CHK);\n \t\t  if (!fn)\n \t\t    return NULL_TREE;\n \n@@ -12143,7 +12144,7 @@ fold_builtin_stxcpy_chk (location_t loc, tree fndecl, tree dest,\n \n \t      /* If c_strlen returned something, but not a constant,\n \t\t transform __strcpy_chk into __memcpy_chk.  */\n-\t      fn = built_in_decls[BUILT_IN_MEMCPY_CHK];\n+\t      fn = builtin_decl_explicit (BUILT_IN_MEMCPY_CHK);\n \t      if (!fn)\n \t\treturn NULL_TREE;\n \n@@ -12163,8 +12164,8 @@ fold_builtin_stxcpy_chk (location_t loc, tree fndecl, tree dest,\n     }\n \n   /* If __builtin_st{r,p}cpy_chk is used, assume st{r,p}cpy is available.  */\n-  fn = built_in_decls[fcode == BUILT_IN_STPCPY_CHK\n-\t\t      ? BUILT_IN_STPCPY : BUILT_IN_STRCPY];\n+  fn = builtin_decl_explicit (fcode == BUILT_IN_STPCPY_CHK\n+\t\t\t      ? BUILT_IN_STPCPY : BUILT_IN_STRCPY);\n   if (!fn)\n     return NULL_TREE;\n \n@@ -12208,7 +12209,7 @@ fold_builtin_strncpy_chk (location_t loc, tree dest, tree src,\n     }\n \n   /* If __builtin_strncpy_chk is used, assume strncpy is available.  */\n-  fn = built_in_decls[BUILT_IN_STRNCPY];\n+  fn = builtin_decl_explicit (BUILT_IN_STRNCPY);\n   if (!fn)\n     return NULL_TREE;\n \n@@ -12239,7 +12240,7 @@ fold_builtin_strcat_chk (location_t loc, tree fndecl, tree dest,\n     return NULL_TREE;\n \n   /* If __builtin_strcat_chk is used, assume strcat is available.  */\n-  fn = built_in_decls[BUILT_IN_STRCAT];\n+  fn = builtin_decl_explicit (BUILT_IN_STRCAT);\n   if (!fn)\n     return NULL_TREE;\n \n@@ -12281,7 +12282,7 @@ fold_builtin_strncat_chk (location_t loc, tree fndecl,\n \t  && ! tree_int_cst_lt (len, src_len))\n \t{\n \t  /* If LEN >= strlen (SRC), optimize into __strcat_chk.  */\n-\t  fn = built_in_decls[BUILT_IN_STRCAT_CHK];\n+\t  fn = builtin_decl_explicit (BUILT_IN_STRCAT_CHK);\n \t  if (!fn)\n \t    return NULL_TREE;\n \n@@ -12291,7 +12292,7 @@ fold_builtin_strncat_chk (location_t loc, tree fndecl,\n     }\n \n   /* If __builtin_strncat_chk is used, assume strncat is available.  */\n-  fn = built_in_decls[BUILT_IN_STRNCAT];\n+  fn = builtin_decl_explicit (BUILT_IN_STRNCAT);\n   if (!fn)\n     return NULL_TREE;\n \n@@ -12382,8 +12383,8 @@ fold_builtin_sprintf_chk_1 (location_t loc, int nargs, tree *args,\n     }\n \n   /* If __builtin_{,v}sprintf_chk is used, assume {,v}sprintf is available.  */\n-  fn = built_in_decls[fcode == BUILT_IN_VSPRINTF_CHK\n-\t\t      ? BUILT_IN_VSPRINTF : BUILT_IN_SPRINTF];\n+  fn = builtin_decl_explicit (fcode == BUILT_IN_VSPRINTF_CHK\n+\t\t\t      ? BUILT_IN_VSPRINTF : BUILT_IN_SPRINTF);\n   if (!fn)\n     return NULL_TREE;\n \n@@ -12471,8 +12472,8 @@ fold_builtin_snprintf_chk_1 (location_t loc, int nargs, tree *args,\n \n   /* If __builtin_{,v}snprintf_chk is used, assume {,v}snprintf is\n      available.  */\n-  fn = built_in_decls[fcode == BUILT_IN_VSNPRINTF_CHK\n-\t\t      ? BUILT_IN_VSNPRINTF : BUILT_IN_SNPRINTF];\n+  fn = builtin_decl_explicit (fcode == BUILT_IN_VSNPRINTF_CHK\n+\t\t\t      ? BUILT_IN_VSNPRINTF : BUILT_IN_SNPRINTF);\n   if (!fn)\n     return NULL_TREE;\n \n@@ -12526,13 +12527,13 @@ fold_builtin_printf (location_t loc, tree fndecl, tree fmt,\n     {\n       /* If we're using an unlocked function, assume the other\n \t unlocked functions exist explicitly.  */\n-      fn_putchar = built_in_decls[BUILT_IN_PUTCHAR_UNLOCKED];\n-      fn_puts = built_in_decls[BUILT_IN_PUTS_UNLOCKED];\n+      fn_putchar = builtin_decl_explicit (BUILT_IN_PUTCHAR_UNLOCKED);\n+      fn_puts = builtin_decl_explicit (BUILT_IN_PUTS_UNLOCKED);\n     }\n   else\n     {\n-      fn_putchar = implicit_built_in_decls[BUILT_IN_PUTCHAR];\n-      fn_puts = implicit_built_in_decls[BUILT_IN_PUTS];\n+      fn_putchar = builtin_decl_implicit (BUILT_IN_PUTCHAR);\n+      fn_puts = builtin_decl_implicit (BUILT_IN_PUTS);\n     }\n \n   if (!init_target_chars ())\n@@ -12677,13 +12678,13 @@ fold_builtin_fprintf (location_t loc, tree fndecl, tree fp,\n     {\n       /* If we're using an unlocked function, assume the other\n \t unlocked functions exist explicitly.  */\n-      fn_fputc = built_in_decls[BUILT_IN_FPUTC_UNLOCKED];\n-      fn_fputs = built_in_decls[BUILT_IN_FPUTS_UNLOCKED];\n+      fn_fputc = builtin_decl_explicit (BUILT_IN_FPUTC_UNLOCKED);\n+      fn_fputs = builtin_decl_explicit (BUILT_IN_FPUTS_UNLOCKED);\n     }\n   else\n     {\n-      fn_fputc = implicit_built_in_decls[BUILT_IN_FPUTC];\n-      fn_fputs = implicit_built_in_decls[BUILT_IN_FPUTS];\n+      fn_fputc = builtin_decl_implicit (BUILT_IN_FPUTC);\n+      fn_fputs = builtin_decl_implicit (BUILT_IN_FPUTS);\n     }\n \n   if (!init_target_chars ())\n@@ -13485,7 +13486,7 @@ fold_call_stmt (gimple stmt, bool ignore)\n   return NULL_TREE;\n }\n \n-/* Look up the function in built_in_decls that corresponds to DECL\n+/* Look up the function in builtin_decl that corresponds to DECL\n    and set ASMSPEC as its user assembler name.  DECL must be a\n    function decl that declares a builtin.  */\n \n@@ -13497,8 +13498,9 @@ set_builtin_user_assembler_name (tree decl, const char *asmspec)\n \t      && DECL_BUILT_IN_CLASS (decl) == BUILT_IN_NORMAL\n \t      && asmspec != 0);\n \n-  builtin = built_in_decls [DECL_FUNCTION_CODE (decl)];\n-  set_user_assembler_name (builtin, asmspec);\n+  builtin = builtin_decl_explicit (DECL_FUNCTION_CODE (decl));\n+  set_user_assembler_name (\n+builtin, asmspec);\n   switch (DECL_FUNCTION_CODE (decl))\n     {\n     case BUILT_IN_MEMCPY:"}, {"sha": "0420b550f3b3ef83c3584ac71db0fa5556186854", "filename": "gcc/builtins.def", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e79983f458034c3061645a4c4ff83c9c4d9019b9/gcc%2Fbuiltins.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e79983f458034c3061645a4c4ff83c9c4d9019b9/gcc%2Fbuiltins.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbuiltins.def?ref=e79983f458034c3061645a4c4ff83c9c4d9019b9", "patch": "@@ -131,8 +131,8 @@ along with GCC; see the file COPYING3.  If not see\n    define it here at all.  */\n #undef DEF_BUILTIN_STUB\n #define DEF_BUILTIN_STUB(ENUM, NAME) \\\n-  DEF_BUILTIN (ENUM, NAME, BUILT_IN_NORMAL, 0, 0, false, false, \\\n-\t       false, 0, false, false)\n+  DEF_BUILTIN (ENUM, NAME, BUILT_IN_NORMAL, BT_LAST, BT_LAST, false, false, \\\n+\t       false, ATTR_LAST, false, false)\n \n /* Builtin used by the implementation of GNU OpenMP.  None of these are\n    actually implemented in the compiler; they're all in libgomp.  */\n@@ -173,6 +173,9 @@ along with GCC; see the file COPYING3.  If not see\n #undef ATTR_MATHFN_FPROUNDING_STORE\n #define ATTR_MATHFN_FPROUNDING_STORE ATTR_NOTHROW_LEAF_LIST\n \n+/* Make sure 0 is not a legitimate builtin.  */\n+DEF_BUILTIN_STUB(BUILT_IN_NONE, (const char *)0)\n+\n /* Category: math builtins.  */\n DEF_LIB_BUILTIN        (BUILT_IN_ACOS, \"acos\", BT_FN_DOUBLE_DOUBLE, ATTR_MATHFN_FPROUNDING_ERRNO)\n DEF_C99_C90RES_BUILTIN (BUILT_IN_ACOSF, \"acosf\", BT_FN_FLOAT_FLOAT, ATTR_MATHFN_FPROUNDING_ERRNO)"}, {"sha": "7af70f00c0fb05aa1f4e6be8e224c1f0cf2e2f86", "filename": "gcc/c-decl.c", "status": "modified", "additions": 16, "deletions": 12, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e79983f458034c3061645a4c4ff83c9c4d9019b9/gcc%2Fc-decl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e79983f458034c3061645a4c4ff83c9c4d9019b9/gcc%2Fc-decl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-decl.c?ref=e79983f458034c3061645a4c4ff83c9c4d9019b9", "patch": "@@ -2372,17 +2372,21 @@ merge_decls (tree newdecl, tree olddecl, tree newtype, tree oldtype)\n \t    {\n \t      C_DECL_BUILTIN_PROTOTYPE (newdecl) = 0;\n \t      if (DECL_BUILT_IN_CLASS (newdecl) == BUILT_IN_NORMAL)\n-\t\tswitch (DECL_FUNCTION_CODE (newdecl))\n-\t\t  {\n-\t\t  /* If a compatible prototype of these builtin functions\n-\t\t     is seen, assume the runtime implements it with the\n-\t\t     expected semantics.  */\n-\t\t  case BUILT_IN_STPCPY:\n-\t\t    implicit_built_in_decls[DECL_FUNCTION_CODE (newdecl)]\n-\t\t      = built_in_decls[DECL_FUNCTION_CODE (newdecl)];\n-\t\t  default:\n-\t\t    break;\n-\t\t  }\n+\t\t{\n+\t\t  enum built_in_function fncode = DECL_FUNCTION_CODE (newdecl);\n+\t\t  switch (fncode)\n+\t\t    {\n+\t\t      /* If a compatible prototype of these builtin functions\n+\t\t\t is seen, assume the runtime implements it with the\n+\t\t\t expected semantics.  */\n+\t\t    case BUILT_IN_STPCPY:\n+\t\t      if (builtin_decl_explicit_p (fncode))\n+\t\t\tset_builtin_decl_implicit_p (fncode, true);\n+\t\t      break;\n+\t\t    default:\n+\t\t      break;\n+\t\t    }\n+\t\t}\n \t    }\n \t  else\n \t    C_DECL_BUILTIN_PROTOTYPE (newdecl)\n@@ -4338,7 +4342,7 @@ finish_decl (tree decl, location_t init_loc, tree init,\n     }\n \n   /* If this is a function and an assembler name is specified, reset DECL_RTL\n-     so we can give it its new name.  Also, update built_in_decls if it\n+     so we can give it its new name.  Also, update builtin_decl if it\n      was a normal built-in.  */\n   if (TREE_CODE (decl) == FUNCTION_DECL && asmspec)\n     {"}, {"sha": "3a26e170ecc45bde3225deefeb5a29db94d50f3a", "filename": "gcc/c-family/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e79983f458034c3061645a4c4ff83c9c4d9019b9/gcc%2Fc-family%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e79983f458034c3061645a4c4ff83c9c4d9019b9/gcc%2Fc-family%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2FChangeLog?ref=e79983f458034c3061645a4c4ff83c9c4d9019b9", "patch": "@@ -1,3 +1,14 @@\n+2011-10-11  Michael Meissner  <meissner@linux.vnet.ibm.com>\n+\n+\t* c-common.c (def_builtin_1): Delete old interface with two\n+\tparallel arrays to hold standard builtin declarations, and replace\n+\tit with a function based interface that can support creating\n+\tbuiltins on the fly in the future.  Change all uses, and poison\n+\tthe old\tnames.  Make sure 0 is not a legitimate builtin index.\n+\t* c-omp.c (c_finish_omp_barrier): Ditto.\n+\t(c_finish_omp_taskwait): Ditto.\n+\t(c_finish_omp_flush): Ditto.\n+\n 2011-10-11  Tristan Gingold  <gingold@adacore.com>\n \n \t* c.opt: (fallow-parameterless-variadic-functions): New."}, {"sha": "0aa0fefbd7c1d128454014d2a5b2d1cb3aa5b91b", "filename": "gcc/c-family/c-common.c", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e79983f458034c3061645a4c4ff83c9c4d9019b9/gcc%2Fc-family%2Fc-common.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e79983f458034c3061645a4c4ff83c9c4d9019b9/gcc%2Fc-family%2Fc-common.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc-common.c?ref=e79983f458034c3061645a4c4ff83c9c4d9019b9", "patch": "@@ -5168,15 +5168,14 @@ def_builtin_1 (enum built_in_function fncode,\n   decl = add_builtin_function (name, fntype, fncode, fnclass,\n \t\t\t       (fallback_p ? libname : NULL),\n \t\t\t       fnattrs);\n+\n+  set_builtin_decl (fncode, decl, implicit_p);\n+\n   if (both_p\n       && !flag_no_builtin && !builtin_function_disabled_p (libname)\n       && !(nonansi_p && flag_no_nonansi_builtin))\n     add_builtin_function (libname, libtype, fncode, fnclass,\n \t\t\t  NULL, fnattrs);\n-\n-  built_in_decls[(int) fncode] = decl;\n-  if (implicit_p)\n-    implicit_built_in_decls[(int) fncode] = decl;\n }\n \f\n /* Nonzero if the type T promotes to int.  This is (nearly) the\n@@ -9144,11 +9143,13 @@ resolve_overloaded_builtin (location_t loc, tree function, VEC(tree,gc) *params)\n       {\n \tint n = sync_resolve_size (function, params);\n \ttree new_function, first_param, result;\n+\tenum built_in_function fncode;\n \n \tif (n == 0)\n \t  return error_mark_node;\n \n-\tnew_function = built_in_decls[orig_code + exact_log2 (n) + 1];\n+\tfncode = (enum built_in_function)((int)orig_code + exact_log2 (n) + 1);\n+\tnew_function = builtin_decl_explicit (fncode);\n \tif (!sync_resolve_params (function, new_function, params))\n \t  return error_mark_node;\n "}, {"sha": "481211ed72d564eba2f58ff49ffbe58db880b7ec", "filename": "gcc/c-family/c-omp.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e79983f458034c3061645a4c4ff83c9c4d9019b9/gcc%2Fc-family%2Fc-omp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e79983f458034c3061645a4c4ff83c9c4d9019b9/gcc%2Fc-family%2Fc-omp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc-omp.c?ref=e79983f458034c3061645a4c4ff83c9c4d9019b9", "patch": "@@ -77,7 +77,7 @@ c_finish_omp_barrier (location_t loc)\n {\n   tree x;\n \n-  x = built_in_decls[BUILT_IN_GOMP_BARRIER];\n+  x = builtin_decl_explicit (BUILT_IN_GOMP_BARRIER);\n   x = build_call_expr_loc (loc, x, 0);\n   add_stmt (x);\n }\n@@ -91,7 +91,7 @@ c_finish_omp_taskwait (location_t loc)\n {\n   tree x;\n \n-  x = built_in_decls[BUILT_IN_GOMP_TASKWAIT];\n+  x = builtin_decl_explicit (BUILT_IN_GOMP_TASKWAIT);\n   x = build_call_expr_loc (loc, x, 0);\n   add_stmt (x);\n }\n@@ -105,7 +105,7 @@ c_finish_omp_taskyield (location_t loc)\n {\n   tree x;\n \n-  x = built_in_decls[BUILT_IN_GOMP_TASKYIELD];\n+  x = builtin_decl_explicit (BUILT_IN_GOMP_TASKYIELD);\n   x = build_call_expr_loc (loc, x, 0);\n   add_stmt (x);\n }\n@@ -260,7 +260,7 @@ c_finish_omp_flush (location_t loc)\n {\n   tree x;\n \n-  x = built_in_decls[BUILT_IN_SYNC_SYNCHRONIZE];\n+  x = builtin_decl_explicit (BUILT_IN_SYNC_SYNCHRONIZE);\n   x = build_call_expr_loc (loc, x, 0);\n   add_stmt (x);\n }"}, {"sha": "7dfdae2b38e071ad5266c9825dcf53867b9a205f", "filename": "gcc/c-typeck.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e79983f458034c3061645a4c4ff83c9c4d9019b9/gcc%2Fc-typeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e79983f458034c3061645a4c4ff83c9c4d9019b9/gcc%2Fc-typeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-typeck.c?ref=e79983f458034c3061645a4c4ff83c9c4d9019b9", "patch": "@@ -2766,7 +2766,8 @@ build_function_call_vec (location_t loc, tree function, VEC(tree,gc) *params,\n       && !comptypes (fntype, TREE_TYPE (tem)))\n     {\n       tree return_type = TREE_TYPE (fntype);\n-      tree trap = build_function_call (loc, built_in_decls[BUILT_IN_TRAP],\n+      tree trap = build_function_call (loc,\n+\t\t\t\t       builtin_decl_explicit (BUILT_IN_TRAP),\n \t\t\t\t       NULL_TREE);\n       int i;\n "}, {"sha": "eeb6b2ec602c2bc78ac06087e366dff06fdf8d94", "filename": "gcc/calls.c", "status": "modified", "additions": 9, "deletions": 4, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e79983f458034c3061645a4c4ff83c9c4d9019b9/gcc%2Fcalls.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e79983f458034c3061645a4c4ff83c9c4d9019b9/gcc%2Fcalls.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcalls.c?ref=e79983f458034c3061645a4c4ff83c9c4d9019b9", "patch": "@@ -274,17 +274,22 @@ emit_call_1 (rtx funexp, tree fntree ATTRIBUTE_UNUSED, tree fndecl ATTRIBUTE_UNU\n   if (fndecl && TREE_CODE (fndecl) == FUNCTION_DECL)\n     {\n       tree t = fndecl;\n+\n       /* Although a built-in FUNCTION_DECL and its non-__builtin\n \t counterpart compare equal and get a shared mem_attrs, they\n \t produce different dump output in compare-debug compilations,\n \t if an entry gets garbage collected in one compilation, then\n \t adds a different (but equivalent) entry, while the other\n \t doesn't run the garbage collector at the same spot and then\n \t shares the mem_attr with the equivalent entry. */\n-      if (DECL_BUILT_IN_CLASS (t) == BUILT_IN_NORMAL\n-\t  && built_in_decls[DECL_FUNCTION_CODE (t)])\n-\tt = built_in_decls[DECL_FUNCTION_CODE (t)];\n-      set_mem_expr (funmem, t);\n+      if (DECL_BUILT_IN_CLASS (t) == BUILT_IN_NORMAL)\n+\t{\n+\t  tree t2 = builtin_decl_explicit (DECL_FUNCTION_CODE (t));\n+\t  if (t2)\n+\t    t = t2;\n+\t}\n+\n+\tset_mem_expr (funmem, t);\n     }\n   else if (fntree)\n     set_mem_expr (funmem, build_simple_mem_ref (CALL_EXPR_FN (fntree)));"}, {"sha": "d8e5cd974a2521cbc1a4a6d86abaf4648a680195", "filename": "gcc/config/darwin.c", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e79983f458034c3061645a4c4ff83c9c4d9019b9/gcc%2Fconfig%2Fdarwin.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e79983f458034c3061645a4c4ff83c9c4d9019b9/gcc%2Fconfig%2Fdarwin.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fdarwin.c?ref=e79983f458034c3061645a4c4ff83c9c4d9019b9", "patch": "@@ -2962,7 +2962,7 @@ darwin_override_options (void)\n static void\n darwin_patch_builtin (int fncode)\n {\n-  tree fn = built_in_decls[fncode];\n+  tree fn = builtin_decl_explicit (fncode);\n   tree sym;\n   char *newname;\n \n@@ -2974,7 +2974,7 @@ darwin_patch_builtin (int fncode)\n \n   set_user_assembler_name (fn, newname);\n \n-  fn = implicit_built_in_decls[fncode];\n+  fn = builtin_decl_implicit (fncode);\n   if (fn)\n     set_user_assembler_name (fn, newname);\n }\n@@ -3149,17 +3149,18 @@ darwin_rename_builtins (void)\n      use the faster version.  */\n   if (!flag_unsafe_math_optimizations)\n     {\n-      int dcode = (BUILT_IN_COMPLEX_DIV_MIN\n-\t\t   + DCmode - MIN_MODE_COMPLEX_FLOAT);\n-      tree fn = built_in_decls[dcode];\n+      enum built_in_function dcode\n+\t= (enum built_in_function)(BUILT_IN_COMPLEX_DIV_MIN\n+\t\t\t\t   + DCmode - MIN_MODE_COMPLEX_FLOAT);\n+      tree fn = builtin_decl_explicit (dcode);\n       /* Fortran and c call TARGET_INIT_BUILTINS and\n \t TARGET_INIT_LIBFUNCS at different times, so we have to put a\n \t call into each to ensure that at least one of them is called\n \t after build_common_builtin_nodes.  A better fix is to add a\n \t new hook to run after build_common_builtin_nodes runs.  */\n       if (fn)\n \tset_user_assembler_name (fn, \"___ieee_divdc3\");\n-      fn = implicit_built_in_decls[dcode];\n+      fn = builtin_decl_implicit (dcode);\n       if (fn)\n \tset_user_assembler_name (fn, \"___ieee_divdc3\");\n     }"}, {"sha": "625c55e76d95e392688ef76853434142bf9d00e6", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e79983f458034c3061645a4c4ff83c9c4d9019b9/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e79983f458034c3061645a4c4ff83c9c4d9019b9/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=e79983f458034c3061645a4c4ff83c9c4d9019b9", "patch": "@@ -8027,7 +8027,7 @@ ix86_gimplify_va_arg (tree valist, tree type, gimple_seq *pre_p,\n \t      else\n \t\t{\n \t\t  tree copy\n-\t\t    = build_call_expr (implicit_built_in_decls[BUILT_IN_MEMCPY],\n+\t\t    = build_call_expr (builtin_decl_implicit (BUILT_IN_MEMCPY),\n \t\t\t\t       3, dest_addr, src_addr,\n \t\t\t\t       size_int (cur_size));\n \t\t  gimplify_and_add (copy, pre_p);\n@@ -29160,7 +29160,7 @@ ix86_veclibabi_svml (enum built_in_function fn, tree type_out, tree type_in)\n       return NULL_TREE;\n     }\n \n-  bname = IDENTIFIER_POINTER (DECL_NAME (implicit_built_in_decls[fn]));\n+  bname = IDENTIFIER_POINTER (DECL_NAME (builtin_decl_implicit (fn)));\n \n   if (fn == BUILT_IN_LOGF)\n     strcpy (name, \"vmlsLn4\");\n@@ -29178,7 +29178,8 @@ ix86_veclibabi_svml (enum built_in_function fn, tree type_out, tree type_in)\n   name[4] &= ~0x20;\n \n   arity = 0;\n-  for (args = DECL_ARGUMENTS (implicit_built_in_decls[fn]); args;\n+  for (args = DECL_ARGUMENTS (builtin_decl_implicit (fn));\n+       args;\n        args = TREE_CHAIN (args))\n     arity++;\n \n@@ -29259,11 +29260,12 @@ ix86_veclibabi_acml (enum built_in_function fn, tree type_out, tree type_in)\n       return NULL_TREE;\n     }\n \n-  bname = IDENTIFIER_POINTER (DECL_NAME (implicit_built_in_decls[fn]));\n+  bname = IDENTIFIER_POINTER (DECL_NAME (builtin_decl_implicit (fn)));\n   sprintf (name + 7, \"%s\", bname+10);\n \n   arity = 0;\n-  for (args = DECL_ARGUMENTS (implicit_built_in_decls[fn]); args;\n+  for (args = DECL_ARGUMENTS (builtin_decl_implicit (fn));\n+       args;\n        args = TREE_CHAIN (args))\n     arity++;\n "}, {"sha": "6d3ac6d45eed384ff8551032e4fb32b23f6fff17", "filename": "gcc/config/ia64/ia64.c", "status": "modified", "additions": 6, "deletions": 9, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e79983f458034c3061645a4c4ff83c9c4d9019b9/gcc%2Fconfig%2Fia64%2Fia64.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e79983f458034c3061645a4c4ff83c9c4d9019b9/gcc%2Fconfig%2Fia64%2Fia64.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fia64%2Fia64.c?ref=e79983f458034c3061645a4c4ff83c9c4d9019b9", "patch": "@@ -10100,15 +10100,12 @@ ia64_init_builtins (void)\n \n   if (TARGET_HPUX)\n     {\n-      if (built_in_decls [BUILT_IN_FINITE])\n-\tset_user_assembler_name (built_in_decls [BUILT_IN_FINITE],\n-\t  \"_Isfinite\");\n-      if (built_in_decls [BUILT_IN_FINITEF])\n-\tset_user_assembler_name (built_in_decls [BUILT_IN_FINITEF],\n-\t  \"_Isfinitef\");\n-      if (built_in_decls [BUILT_IN_FINITEL])\n-\tset_user_assembler_name (built_in_decls [BUILT_IN_FINITEL],\n-\t  \"_Isfinitef128\");\n+      if ((decl = builtin_decl_explicit (BUILT_IN_FINITE))) != NULL_TREE)\n+\tset_user_assembler_name (decl, \"_Isfinite\");\n+      if ((decl = builtin_decl_explicit (BUILT_IN_FINITEF))) != NULL_TREE)\n+\tset_user_assembler_name (decl, \"_Isfinitef\");\n+      if ((decl = builtin_decl_explicit (BUILT_IN_FINITEL))) != NULL_TREE)\n+\tset_user_assembler_name (decl, \"_Isfinitef128\");\n     }\n }\n "}, {"sha": "66e3fc700b4699de1205b4c78ea87e499a05597e", "filename": "gcc/config/pa/pa.c", "status": "modified", "additions": 13, "deletions": 8, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e79983f458034c3061645a4c4ff83c9c4d9019b9/gcc%2Fconfig%2Fpa%2Fpa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e79983f458034c3061645a4c4ff83c9c4d9019b9/gcc%2Fconfig%2Fpa%2Fpa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpa%2Fpa.c?ref=e79983f458034c3061645a4c4ff83c9c4d9019b9", "patch": "@@ -555,16 +555,21 @@ static void\n pa_init_builtins (void)\n {\n #ifdef DONT_HAVE_FPUTC_UNLOCKED\n-  built_in_decls[(int) BUILT_IN_FPUTC_UNLOCKED] =\n-    built_in_decls[(int) BUILT_IN_PUTC_UNLOCKED];\n-  implicit_built_in_decls[(int) BUILT_IN_FPUTC_UNLOCKED]\n-    = implicit_built_in_decls[(int) BUILT_IN_PUTC_UNLOCKED];\n+  {\n+    tree decl = builtin_decl_explicit (BUILT_IN_PUTC_UNLOCKED);\n+    set_builtin_decl (BUILT_IN_FPUTC_UNLOCKED, decl,\n+\t\t      builtin_decl_implicit_p (BUILT_IN_PUTC_UNLOCKED));\n+  }\n #endif\n #if TARGET_HPUX_11\n-  if (built_in_decls [BUILT_IN_FINITE])\n-    set_user_assembler_name (built_in_decls [BUILT_IN_FINITE], \"_Isfinite\");\n-  if (built_in_decls [BUILT_IN_FINITEF])\n-    set_user_assembler_name (built_in_decls [BUILT_IN_FINITEF], \"_Isfinitef\");\n+  {\n+    tree decl;\n+\n+    if ((decl = builtin_decl_explicit (BUILT_IN_FINITE)) != NULL_TREE)\n+      set_user_assembler_name (decl, \"_Isfinite\");\n+    if ((decl = builtin_decl_explicit (BUILT_IN_FINITEF)) != NULL_TREE)\n+      set_user_assembler_name (decl, \"_Isfinitef\");\n+  }\n #endif\n \n   if (HPUX_LONG_DOUBLE_LIBRARY)"}, {"sha": "4fd2192d3806c9df2408a8ccf2e562fae3e6a717", "filename": "gcc/config/rs6000/rs6000.c", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e79983f458034c3061645a4c4ff83c9c4d9019b9/gcc%2Fconfig%2Frs6000%2Frs6000.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e79983f458034c3061645a4c4ff83c9c4d9019b9/gcc%2Fconfig%2Frs6000%2Frs6000.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.c?ref=e79983f458034c3061645a4c4ff83c9c4d9019b9", "patch": "@@ -3739,7 +3739,7 @@ rs6000_builtin_vectorized_libmass (tree fndecl, tree type_out, tree type_in)\n \tcase BUILT_IN_SQRT:\n \tcase BUILT_IN_TAN:\n \tcase BUILT_IN_TANH:\n-\t  bdecl = implicit_built_in_decls[fn];\n+\t  bdecl = builtin_decl_implicit (fn);\n \t  suffix = \"d2\";\t\t\t\t/* pow -> powd2 */\n \t  if (el_mode != DFmode\n \t      || n != 2)\n@@ -3776,7 +3776,7 @@ rs6000_builtin_vectorized_libmass (tree fndecl, tree type_out, tree type_in)\n \tcase BUILT_IN_SQRTF:\n \tcase BUILT_IN_TANF:\n \tcase BUILT_IN_TANHF:\n-\t  bdecl = implicit_built_in_decls[fn];\n+\t  bdecl = builtin_decl_implicit (fn);\n \t  suffix = \"4\";\t\t\t\t\t/* powf -> powf4 */\n \t  if (el_mode != SFmode\n \t      || n != 4)\n@@ -9400,7 +9400,7 @@ rs6000_gimplify_va_arg (tree valist, tree type, gimple_seq *pre_p,\n       tree tmp = create_tmp_var (type, \"va_arg_tmp\");\n       tree dest_addr = build_fold_addr_expr (tmp);\n \n-      tree copy = build_call_expr (implicit_built_in_decls[BUILT_IN_MEMCPY],\n+      tree copy = build_call_expr (builtin_decl_implicit (BUILT_IN_MEMCPY),\n \t\t\t\t   3, dest_addr, addr, size_int (rsize * 4));\n \n       gimplify_and_add (copy, pre_p);\n@@ -12213,8 +12213,8 @@ rs6000_init_builtins (void)\n \n #if TARGET_XCOFF\n   /* AIX libm provides clog as __clog.  */\n-  if (built_in_decls [BUILT_IN_CLOG])\n-    set_user_assembler_name (built_in_decls [BUILT_IN_CLOG], \"__clog\");\n+  if ((tdecl = builtin_decl_explicit ([BUILT_IN_CLOG))) != NULL_TREE)\n+    set_user_assembler_name (tdecl, \"__clog\");\n #endif\n \n #ifdef SUBTARGET_INIT_BUILTINS"}, {"sha": "9c7cc56b43e0a224f4d5e91a2f9d525dfb2714d7", "filename": "gcc/config/sparc/sparc.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e79983f458034c3061645a4c4ff83c9c4d9019b9/gcc%2Fconfig%2Fsparc%2Fsparc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e79983f458034c3061645a4c4ff83c9c4d9019b9/gcc%2Fconfig%2Fsparc%2Fsparc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fsparc.c?ref=e79983f458034c3061645a4c4ff83c9c4d9019b9", "patch": "@@ -6789,7 +6789,7 @@ sparc_gimplify_va_arg (tree valist, tree type, gimple_seq *pre_p,\n     {\n       tree tmp = create_tmp_var (type, \"va_arg_tmp\");\n       tree dest_addr = build_fold_addr_expr (tmp);\n-      tree copy = build_call_expr (implicit_built_in_decls[BUILT_IN_MEMCPY],\n+      tree copy = build_call_expr (builtin_decl_implicit (BUILT_IN_MEMCPY),\n \t\t\t\t   3, dest_addr, addr, size_int (rsize));\n       TREE_ADDRESSABLE (tmp) = 1;\n       gimplify_and_add (copy, pre_p);"}, {"sha": "44940a3aa3b1aa81d1ead56b0b106ba3548d22ea", "filename": "gcc/config/vms/vms.c", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e79983f458034c3061645a4c4ff83c9c4d9019b9/gcc%2Fconfig%2Fvms%2Fvms.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e79983f458034c3061645a4c4ff83c9c4d9019b9/gcc%2Fconfig%2Fvms%2Fvms.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fvms%2Fvms.c?ref=e79983f458034c3061645a4c4ff83c9c4d9019b9", "patch": "@@ -99,8 +99,11 @@ vms_patch_builtins (void)\n   unsigned int i;\n \n   /* Fwrite on VMS is non-standard.  */\n-  implicit_built_in_decls[(int) BUILT_IN_FWRITE] = NULL_TREE;\n-  implicit_built_in_decls[(int) BUILT_IN_FWRITE_UNLOCKED] = NULL_TREE;\n+  if (builtin_decl_implicit_p (BUILT_IN_WRITE))\n+    set_builtin_decl_implicit_p (BUILT_IN_WRITE, false);\n+\n+  if (builtin_decl_implicit_p (BUILT_IN_WRITE_UNLOCKED))\n+    set_builtin_decl_implicit_p (BUILT_IN_WRITE_UNLOCKED, false);\n \n   /* Define aliases for names.  */\n   for (i = 0; i < NBR_CRTL_NAMES; i++)"}, {"sha": "ca8566f0f5cd02c63ebdc063502c69692dc0bdc2", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e79983f458034c3061645a4c4ff83c9c4d9019b9/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e79983f458034c3061645a4c4ff83c9c4d9019b9/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=e79983f458034c3061645a4c4ff83c9c4d9019b9", "patch": "@@ -1,3 +1,17 @@\n+2011-10-11  Michael Meissner  <meissner@linux.vnet.ibm.com>\n+\n+\t* decl.c (duplicate_decls): Delete old interface with two parallel\n+\tarrays to hold standard builtin declarations, and replace it with\n+\ta function based interface that can support creating builtins on\n+\tthe fly in the future.  Change all uses, and poison the old\n+\tnames.  Make sure 0 is not a legitimate builtin index.\n+\t* except.c (build_eh_type_type): Ditto.\n+\t(choose_personality_routine): Ditto.\n+\t* semantics.c (finish_omp_atomic): Ditto.\n+\t(finish_omp_barrier): Ditto.\n+\t(finish_omp_flush): Ditto.\n+\t(finish_omp_taskwait): Ditto.\n+\n 2011-10-11  Jason Merrill  <jason@redhat.com>\n \n \tPR c++/49855"}, {"sha": "c8f325548cb75b5d147e0191d71e41c700d38c9d", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 22, "deletions": 16, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e79983f458034c3061645a4c4ff83c9c4d9019b9/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e79983f458034c3061645a4c4ff83c9c4d9019b9/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=e79983f458034c3061645a4c4ff83c9c4d9019b9", "patch": "@@ -1357,11 +1357,13 @@ duplicate_decls (tree newdecl, tree olddecl, bool newdecl_is_friend)\n       if (DECL_BUILT_IN_CLASS (olddecl) == BUILT_IN_NORMAL\n \t  && DECL_ANTICIPATED (olddecl)\n \t  && TREE_NOTHROW (newdecl)\n-\t  && !TREE_NOTHROW (olddecl)\n-\t  && built_in_decls [DECL_FUNCTION_CODE (olddecl)] != NULL_TREE\n-\t  && built_in_decls [DECL_FUNCTION_CODE (olddecl)] != olddecl\n-\t  && types_match)\n-\tTREE_NOTHROW (built_in_decls [DECL_FUNCTION_CODE (olddecl)]) = 1;\n+\t  && !TREE_NOTHROW (olddecl))\n+\t{\n+\t  enum built_in_function fncode = DECL_FUNCTION_CODE (olddecl);\n+\t  tree tmpdecl = builtin_decl_explicit (fncode);\n+\t  if (tmpdecl && tmpdecl != olddecl && types_match)\n+\t    TREE_NOTHROW (tmpdecl)  = 1;\n+\t}\n \n       /* Whether or not the builtin can throw exceptions has no\n \t bearing on this declarator.  */\n@@ -2136,17 +2138,21 @@ duplicate_decls (tree newdecl, tree olddecl, bool newdecl_is_friend)\n \t\t regardless of declaration matches.  */\n \t      COPY_DECL_RTL (olddecl, newdecl);\n \t      if (DECL_BUILT_IN_CLASS (newdecl) == BUILT_IN_NORMAL)\n-\t\tswitch (DECL_FUNCTION_CODE (newdecl))\n-\t\t  {\n-\t\t    /* If a compatible prototype of these builtin functions\n-\t\t       is seen, assume the runtime implements it with the\n-\t\t       expected semantics.  */\n-\t\t  case BUILT_IN_STPCPY:\n-\t\t    implicit_built_in_decls[DECL_FUNCTION_CODE (newdecl)]\n-\t\t      = built_in_decls[DECL_FUNCTION_CODE (newdecl)];\n-\t\t  default:\n-\t\t    break;\n-\t\t  }\n+\t\t{\n+\t\t  enum built_in_function fncode = DECL_FUNCTION_CODE (newdecl);\n+\t\t  switch (fncode)\n+\t\t    {\n+\t\t      /* If a compatible prototype of these builtin functions\n+\t\t\t is seen, assume the runtime implements it with the\n+\t\t\t expected semantics.  */\n+\t\t    case BUILT_IN_STPCPY:\n+\t\t      if (builtin_decl_explicit_p (fncode))\n+\t\t\tset_builtin_decl_implicit_p (fncode, true);\n+\t\t      break;\n+\t\t    default:\n+\t\t      break;\n+\t\t    }\n+\t\t}\n \t    }\n \n \t  DECL_RESULT (newdecl) = DECL_RESULT (olddecl);"}, {"sha": "e529685c992eefabac4c1098c3f57f9cb71cbb26", "filename": "gcc/cp/except.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e79983f458034c3061645a4c4ff83c9c4d9019b9/gcc%2Fcp%2Fexcept.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e79983f458034c3061645a4c4ff83c9c4d9019b9/gcc%2Fcp%2Fexcept.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fexcept.c?ref=e79983f458034c3061645a4c4ff83c9c4d9019b9", "patch": "@@ -140,7 +140,7 @@ build_eh_type_type (tree type)\n tree\n build_exc_ptr (void)\n {\n-  return build_call_n (built_in_decls [BUILT_IN_EH_POINTER],\n+  return build_call_n (builtin_decl_explicit (BUILT_IN_EH_POINTER),\n \t\t       1, integer_zero_node);\n }\n \n@@ -333,7 +333,7 @@ choose_personality_routine (enum languages lang)\n \n     case lang_java:\n       state = chose_java;\n-      terminate_node = built_in_decls [BUILT_IN_ABORT];\n+      terminate_node = builtin_decl_explicit (BUILT_IN_ABORT);\n       pragma_java_exceptions = true;\n       break;\n "}, {"sha": "eed38e62f7b88f5a82d8d4ee2bea72ab98e83676", "filename": "gcc/cp/semantics.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e79983f458034c3061645a4c4ff83c9c4d9019b9/gcc%2Fcp%2Fsemantics.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e79983f458034c3061645a4c4ff83c9c4d9019b9/gcc%2Fcp%2Fsemantics.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsemantics.c?ref=e79983f458034c3061645a4c4ff83c9c4d9019b9", "patch": "@@ -4784,7 +4784,7 @@ finish_omp_atomic (enum tree_code code, enum tree_code opcode, tree lhs,\n void\n finish_omp_barrier (void)\n {\n-  tree fn = built_in_decls[BUILT_IN_GOMP_BARRIER];\n+  tree fn = builtin_decl_explicit (BUILT_IN_GOMP_BARRIER);\n   VEC(tree,gc) *vec = make_tree_vector ();\n   tree stmt = finish_call_expr (fn, &vec, false, false, tf_warning_or_error);\n   release_tree_vector (vec);\n@@ -4794,7 +4794,7 @@ finish_omp_barrier (void)\n void\n finish_omp_flush (void)\n {\n-  tree fn = built_in_decls[BUILT_IN_SYNC_SYNCHRONIZE];\n+  tree fn = builtin_decl_explicit (BUILT_IN_SYNC_SYNCHRONIZE);\n   VEC(tree,gc) *vec = make_tree_vector ();\n   tree stmt = finish_call_expr (fn, &vec, false, false, tf_warning_or_error);\n   release_tree_vector (vec);\n@@ -4804,7 +4804,7 @@ finish_omp_flush (void)\n void\n finish_omp_taskwait (void)\n {\n-  tree fn = built_in_decls[BUILT_IN_GOMP_TASKWAIT];\n+  tree fn = builtin_decl_explicit (BUILT_IN_GOMP_TASKWAIT);\n   VEC(tree,gc) *vec = make_tree_vector ();\n   tree stmt = finish_call_expr (fn, &vec, false, false, tf_warning_or_error);\n   release_tree_vector (vec);\n@@ -4814,7 +4814,7 @@ finish_omp_taskwait (void)\n void\n finish_omp_taskyield (void)\n {\n-  tree fn = built_in_decls[BUILT_IN_GOMP_TASKYIELD];\n+  tree fn = builtin_decl_explicit (BUILT_IN_GOMP_TASKYIELD);\n   VEC(tree,gc) *vec = make_tree_vector ();\n   tree stmt = finish_call_expr (fn, &vec, false, false, tf_warning_or_error);\n   release_tree_vector (vec);"}, {"sha": "029edf2c290f64a2860fd220c8c039ef7653f9f9", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e79983f458034c3061645a4c4ff83c9c4d9019b9/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e79983f458034c3061645a4c4ff83c9c4d9019b9/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=e79983f458034c3061645a4c4ff83c9c4d9019b9", "patch": "@@ -1,3 +1,37 @@\n+2011-10-11  Michael Meissner  <meissner@linux.vnet.ibm.com>\n+\n+\t* trans-expr.c (gfc_conv_power_op): Delete old interface with two\n+\tparallel arrays to hold standard builtin declarations, and replace\n+\tit with a function based interface that can support creating\n+\tbuiltins on the fly in the future.  Change all uses, and poison\n+\tthe old names.  Make sure 0 is not a legitimate builtin index.\n+\t(fill_with_spaces): Ditto.\n+\t(gfc_trans_string_copy): Ditto.\n+\t(gfc_trans_zero_assign): Ditto.\n+\t(gfc_build_memcpy_call): Ditto.\n+\t(alloc_scalar_allocatable_for_assignment): Ditto.\n+\t* trans-array.c (gfc_trans_array_constructor_value): Ditto.\n+\t(duplicate_allocatable): Ditto.\n+\t(gfc_alloc_allocatable_for_assignment): Ditto.\n+\t* trans-openmp.c (gfc_omp_clause_copy_ctor): Ditto.\n+\t(gfc_omp_clause_assign_op): Ditto.\n+\t(gfc_trans_omp_atomic): Ditto.\n+\t(gfc_trans_omp_do): Ditto.\n+\t(gfc_trans_omp_task): Ditto.\n+\t* trans-stmt.c (gfc_trans_stop): Ditto.\n+\t(gfc_trans_sync): Ditto.\n+\t(gfc_trans_allocate): Ditto.\n+\t(gfc_trans_deallocate): Ditto.\n+\t* trans.c (gfc_call_malloc): Ditto.\n+\t(gfc_allocate_using_malloc): Ditto.\n+\t(gfc_call_free): Ditto.\n+\t(gfc_deallocate_with_status): Ditto.\n+\t(gfc_deallocate_scalar_with_status): Ditto.\n+\t* f95-lang.c (gfc_define_builtin): Ditto.\n+\t(gfc_init_builtin_functions): Ditto.\n+\t* trans-decl.c (create_main_function): Ditto.\n+\t* trans-intrinsic.c (builtin_decl_for_precision): Ditto.\n+\n 2011-10-10  Thomas Koenig  <tkoenig@gcc.gnu.org>\n \n \tPR fortran/50564"}, {"sha": "57c01148fffc7f5e983c6962bde191f3ed665d6b", "filename": "gcc/fortran/f95-lang.c", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e79983f458034c3061645a4c4ff83c9c4d9019b9/gcc%2Ffortran%2Ff95-lang.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e79983f458034c3061645a4c4ff83c9c4d9019b9/gcc%2Ffortran%2Ff95-lang.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ff95-lang.c?ref=e79983f458034c3061645a4c4ff83c9c4d9019b9", "patch": "@@ -639,7 +639,7 @@ gfc_builtin_function (tree decl)\n #define ATTR_CONST_NOTHROW_LIST\t\t(ECF_NOTHROW | ECF_CONST)\n \n static void\n-gfc_define_builtin (const char *name, tree type, int code,\n+gfc_define_builtin (const char *name, tree type, enum built_in_function code,\n \t\t    const char *library_name, int attr)\n {\n   tree decl;\n@@ -654,8 +654,7 @@ gfc_define_builtin (const char *name, tree type, int code,\n     DECL_ATTRIBUTES (decl) = tree_cons (get_identifier (\"leaf\"),\n \t\t\t\t\tNULL, DECL_ATTRIBUTES (decl));\n \n-  built_in_decls[code] = decl;\n-  implicit_built_in_decls[code] = decl;\n+  set_builtin_decl (code, decl, true);\n }\n \n \n@@ -1006,7 +1005,7 @@ gfc_init_builtin_functions (void)\n                                     size_type_node, NULL_TREE);\n   gfc_define_builtin (\"__builtin_malloc\", ftype, BUILT_IN_MALLOC,\n \t\t      \"malloc\", ATTR_NOTHROW_LEAF_LIST);\n-  DECL_IS_MALLOC (built_in_decls[BUILT_IN_MALLOC]) = 1;\n+  DECL_IS_MALLOC (builtin_decl_explicit (BUILT_IN_MALLOC)) = 1;\n \n   ftype = build_function_type_list (pvoid_type_node,\n                                     size_type_node, pvoid_type_node,\n@@ -1122,7 +1121,7 @@ gfc_init_builtin_functions (void)\n \n   gfc_define_builtin (\"__builtin_trap\", builtin_types[BT_FN_VOID],\n \t\t      BUILT_IN_TRAP, NULL, ATTR_NOTHROW_LEAF_LIST);\n-  TREE_THIS_VOLATILE (built_in_decls[BUILT_IN_TRAP]) = 1;\n+  TREE_THIS_VOLATILE (builtin_decl_explicit (BUILT_IN_TRAP)) = 1;\n \n   gfc_define_builtin (\"__emutls_get_address\",\n \t\t      builtin_types[BT_FN_PTR_PTR],"}, {"sha": "585dc438d636dffdfbd35c79c747e667408d098b", "filename": "gcc/fortran/trans-array.c", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e79983f458034c3061645a4c4ff83c9c4d9019b9/gcc%2Ffortran%2Ftrans-array.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e79983f458034c3061645a4c4ff83c9c4d9019b9/gcc%2Ffortran%2Ftrans-array.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-array.c?ref=e79983f458034c3061645a4c4ff83c9c4d9019b9", "patch": "@@ -1458,8 +1458,8 @@ gfc_trans_array_constructor_value (stmtblock_t * pblock, tree type,\n \t      size = TREE_INT_CST_LOW (TYPE_SIZE_UNIT (type));\n \t      bound = build_int_cst (size_type_node, n * size);\n \t      tmp = build_call_expr_loc (input_location,\n-\t\t\t\t     built_in_decls[BUILT_IN_MEMCPY], 3,\n-\t\t\t\t     tmp, init, bound);\n+\t\t\t\t\t builtin_decl_explicit (BUILT_IN_MEMCPY),\n+\t\t\t\t\t 3, tmp, init, bound);\n \t      gfc_add_expr_to_block (&body, tmp);\n \n \t      *poffset = fold_build2_loc (input_location, PLUS_EXPR,\n@@ -6633,7 +6633,7 @@ duplicate_allocatable (tree dest, tree src, tree type, int rank,\n \t  gfc_add_expr_to_block (&block, tmp);\n \t}\n \n-      tmp = built_in_decls[BUILT_IN_MEMCPY];\n+      tmp = builtin_decl_explicit (BUILT_IN_MEMCPY);\n       tmp = build_call_expr_loc (input_location, tmp, 3,\n \t\t\t\t dest, src, size);\n     }\n@@ -6657,7 +6657,7 @@ duplicate_allocatable (tree dest, tree src, tree type, int rank,\n \n       /* We know the temporary and the value will be the same length,\n \t so can use memcpy.  */\n-      tmp = built_in_decls[BUILT_IN_MEMCPY];\n+      tmp = builtin_decl_explicit (BUILT_IN_MEMCPY);\n       tmp = build_call_expr_loc (input_location,\n \t\t\ttmp, 3, gfc_conv_descriptor_data_get (dest),\n \t\t\tgfc_conv_descriptor_data_get (src), size);\n@@ -7413,7 +7413,7 @@ gfc_alloc_allocatable_for_assignment (gfc_loopinfo *loop,\n      in the array reference - (*desc.data)[<element>]. */\n   gfc_init_block (&realloc_block);\n   tmp = build_call_expr_loc (input_location,\n-\t\t\t     built_in_decls[BUILT_IN_REALLOC], 2,\n+\t\t\t     builtin_decl_explicit (BUILT_IN_REALLOC), 2,\n \t\t\t     fold_convert (pvoid_type_node, array1),\n \t\t\t     size2);\n   gfc_conv_descriptor_data_set (&realloc_block,\n@@ -7429,8 +7429,8 @@ gfc_alloc_allocatable_for_assignment (gfc_loopinfo *loop,\n   /* Malloc expression.  */\n   gfc_init_block (&alloc_block);\n   tmp = build_call_expr_loc (input_location,\n-\t\t\t     built_in_decls[BUILT_IN_MALLOC], 1,\n-\t\t\t     size2);\n+\t\t\t     builtin_decl_explicit (BUILT_IN_MALLOC),\n+\t\t\t     1, size2);\n   gfc_conv_descriptor_data_set (&alloc_block,\n \t\t\t\tdesc, tmp);\n   tmp = gfc_conv_descriptor_dtype (desc);"}, {"sha": "b7460b779e276d89b958e9c89240976759536d88", "filename": "gcc/fortran/trans-decl.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e79983f458034c3061645a4c4ff83c9c4d9019b9/gcc%2Ffortran%2Ftrans-decl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e79983f458034c3061645a4c4ff83c9c4d9019b9/gcc%2Ffortran%2Ftrans-decl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-decl.c?ref=e79983f458034c3061645a4c4ff83c9c4d9019b9", "patch": "@@ -4989,7 +4989,7 @@ create_main_function (tree fndecl)\n     { \n       /* Per F2008, 8.5.1 END of the main program implies a\n \t SYNC MEMORY.  */ \n-      tmp = built_in_decls [BUILT_IN_SYNC_SYNCHRONIZE];\n+      tmp = builtin_decl_explicit (BUILT_IN_SYNC_SYNCHRONIZE);\n       tmp = build_call_expr_loc (input_location, tmp, 0);\n       gfc_add_expr_to_block (&body, tmp);\n "}, {"sha": "ca0523fedca28e4adbf7a55b7d6ae226598fb068", "filename": "gcc/fortran/trans-expr.c", "status": "modified", "additions": 18, "deletions": 16, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e79983f458034c3061645a4c4ff83c9c4d9019b9/gcc%2Ffortran%2Ftrans-expr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e79983f458034c3061645a4c4ff83c9c4d9019b9/gcc%2Ffortran%2Ftrans-expr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-expr.c?ref=e79983f458034c3061645a4c4ff83c9c4d9019b9", "patch": "@@ -1124,22 +1124,22 @@ gfc_conv_power_op (gfc_se * se, gfc_expr * expr)\n \t      switch (kind)\n \t\t{\n \t\tcase 0:\n-\t\t  fndecl = built_in_decls[BUILT_IN_POWIF];\n+\t\t  fndecl = builtin_decl_explicit (BUILT_IN_POWIF);\n \t\t  break;\n \t\t\n \t\tcase 1:\n-\t\t  fndecl = built_in_decls[BUILT_IN_POWI];\n+\t\t  fndecl = builtin_decl_explicit (BUILT_IN_POWI);\n \t\t  break;\n \n \t\tcase 2:\n-\t\t  fndecl = built_in_decls[BUILT_IN_POWIL];\n+\t\t  fndecl = builtin_decl_explicit (BUILT_IN_POWIL);\n \t\t  break;\n \n \t\tcase 3:\n \t\t  /* Use the __builtin_powil() only if real(kind=16) is \n \t\t     actually the C long double type.  */\n \t\t  if (!gfc_real16_is_float128)\n-\t\t    fndecl = built_in_decls[BUILT_IN_POWIL];\n+\t\t    fndecl = builtin_decl_explicit (BUILT_IN_POWIL);\n \t\t  break;\n \n \t\tdefault:\n@@ -3855,7 +3855,8 @@ fill_with_spaces (tree start, tree type, tree size)\n   /* For a simple char type, we can call memset().  */\n   if (compare_tree_int (TYPE_SIZE_UNIT (type), 1) == 0)\n     return build_call_expr_loc (input_location,\n-\t\t\t    built_in_decls[BUILT_IN_MEMSET], 3, start,\n+\t\t\t    builtin_decl_explicit (BUILT_IN_MEMSET),\n+\t\t\t    3, start,\n \t\t\t    build_int_cst (gfc_get_int_type (gfc_c_int_kind),\n \t\t\t\t\t   lang_hooks.to_target_charset (' ')),\n \t\t\t    size);\n@@ -4015,13 +4016,13 @@ gfc_trans_string_copy (stmtblock_t * block, tree dlength, tree dest,\n   cond2 = fold_build2_loc (input_location, GE_EXPR, boolean_type_node, slen,\n \t\t\t   dlen);\n   tmp2 = build_call_expr_loc (input_location,\n-\t\t\t  built_in_decls[BUILT_IN_MEMMOVE],\n-\t\t\t  3, dest, src, dlen);\n+\t\t\t      builtin_decl_explicit (BUILT_IN_MEMMOVE),\n+\t\t\t      3, dest, src, dlen);\n \n   /* Else copy and pad with spaces.  */\n   tmp3 = build_call_expr_loc (input_location,\n-\t\t\t  built_in_decls[BUILT_IN_MEMMOVE],\n-\t\t\t  3, dest, src, slen);\n+\t\t\t      builtin_decl_explicit (BUILT_IN_MEMMOVE),\n+\t\t\t      3, dest, src, slen);\n \n   tmp4 = fold_build_pointer_plus_loc (input_location, dest, slen);\n   tmp4 = fill_with_spaces (tmp4, chartype,\n@@ -5816,8 +5817,8 @@ gfc_trans_zero_assign (gfc_expr * expr)\n \n   /* Construct call to __builtin_memset.  */\n   tmp = build_call_expr_loc (input_location,\n-\t\t\t built_in_decls[BUILT_IN_MEMSET],\n-\t\t\t 3, dest, integer_zero_node, len);\n+\t\t\t     builtin_decl_explicit (BUILT_IN_MEMSET),\n+\t\t\t     3, dest, integer_zero_node, len);\n   return fold_convert (void_type_node, tmp);\n }\n \n@@ -5845,7 +5846,8 @@ gfc_build_memcpy_call (tree dst, tree src, tree len)\n \n   /* Construct call to __builtin_memcpy.  */\n   tmp = build_call_expr_loc (input_location,\n-\t\t\t built_in_decls[BUILT_IN_MEMCPY], 3, dst, src, len);\n+\t\t\t     builtin_decl_explicit (BUILT_IN_MEMCPY),\n+\t\t\t     3, dst, src, len);\n   return fold_convert (void_type_node, tmp);\n }\n \n@@ -6056,8 +6058,8 @@ alloc_scalar_allocatable_for_assignment (stmtblock_t *block,\n     }\n \n   tmp = build_call_expr_loc (input_location,\n-\t\t\t     built_in_decls[BUILT_IN_MALLOC], 1,\n-\t\t\t     size_in_bytes);\n+\t\t\t     builtin_decl_explicit (BUILT_IN_MALLOC),\n+\t\t\t     1, size_in_bytes);\n   tmp = fold_convert (TREE_TYPE (lse.expr), tmp);\n   gfc_add_modify (block, lse.expr, tmp);\n   if (expr1->ts.type == BT_CHARACTER && expr1->ts.deferred)\n@@ -6083,8 +6085,8 @@ alloc_scalar_allocatable_for_assignment (stmtblock_t *block,\n \t\t      build_empty_stmt (input_location));\n       gfc_add_expr_to_block (block, tmp);\n       tmp = build_call_expr_loc (input_location,\n-\t\t\t\t built_in_decls[BUILT_IN_REALLOC], 2,\n-\t\t\t\t fold_convert (pvoid_type_node, lse.expr),\n+\t\t\t\t builtin_decl_explicit (BUILT_IN_REALLOC),\n+\t\t\t\t 2, fold_convert (pvoid_type_node, lse.expr),\n \t\t\t\t size_in_bytes);\n       tmp = fold_convert (TREE_TYPE (lse.expr), tmp);\n       gfc_add_modify (block, lse.expr, tmp);"}, {"sha": "ed18bfa6bdeaaaf34407d0b2b784247ec7cf417e", "filename": "gcc/fortran/trans-intrinsic.c", "status": "modified", "additions": 49, "deletions": 40, "changes": 89, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e79983f458034c3061645a4c4ff83c9c4d9019b9/gcc%2Ffortran%2Ftrans-intrinsic.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e79983f458034c3061645a4c4ff83c9c4d9019b9/gcc%2Ffortran%2Ftrans-intrinsic.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-intrinsic.c?ref=e79983f458034c3061645a4c4ff83c9c4d9019b9", "patch": "@@ -139,7 +139,7 @@ static tree\n builtin_decl_for_precision (enum built_in_function base_built_in,\n \t\t\t    int precision)\n {\n-  int i = END_BUILTINS;\n+  enum built_in_function i = END_BUILTINS;\n \n   gfc_intrinsic_map_t *m;\n   for (m = gfc_intrinsic_map; m->double_built_in != base_built_in ; m++)\n@@ -158,7 +158,7 @@ builtin_decl_for_precision (enum built_in_function base_built_in,\n       return m->real16_decl;\n     }\n \n-  return (i == END_BUILTINS ? NULL_TREE : built_in_decls[i]);\n+  return (i == END_BUILTINS ? NULL_TREE : builtin_decl_explicit (i));\n }\n \n \n@@ -679,26 +679,28 @@ gfc_build_intrinsic_lib_fndecls (void)\n        m->id != GFC_ISYM_NONE || m->double_built_in != END_BUILTINS; m++)\n     {\n       if (m->float_built_in != END_BUILTINS)\n-\tm->real4_decl = built_in_decls[m->float_built_in];\n+\tm->real4_decl = builtin_decl_explicit (m->float_built_in);\n       if (m->complex_float_built_in != END_BUILTINS)\n-\tm->complex4_decl = built_in_decls[m->complex_float_built_in];\n+\tm->complex4_decl = builtin_decl_explicit (m->complex_float_built_in);\n       if (m->double_built_in != END_BUILTINS)\n-\tm->real8_decl = built_in_decls[m->double_built_in];\n+\tm->real8_decl = builtin_decl_explicit (m->double_built_in);\n       if (m->complex_double_built_in != END_BUILTINS)\n-\tm->complex8_decl = built_in_decls[m->complex_double_built_in];\n+\tm->complex8_decl = builtin_decl_explicit (m->complex_double_built_in);\n \n       /* If real(kind=10) exists, it is always long double.  */\n       if (m->long_double_built_in != END_BUILTINS)\n-\tm->real10_decl = built_in_decls[m->long_double_built_in];\n+\tm->real10_decl = builtin_decl_explicit (m->long_double_built_in);\n       if (m->complex_long_double_built_in != END_BUILTINS)\n-\tm->complex10_decl = built_in_decls[m->complex_long_double_built_in];\n+\tm->complex10_decl\n+\t  = builtin_decl_explicit (m->complex_long_double_built_in);\n \n       if (!gfc_real16_is_float128)\n \t{\n \t  if (m->long_double_built_in != END_BUILTINS)\n-\t    m->real16_decl = built_in_decls[m->long_double_built_in];\n+\t    m->real16_decl = builtin_decl_explicit (m->long_double_built_in);\n \t  if (m->complex_long_double_built_in != END_BUILTINS)\n-\t    m->complex16_decl = built_in_decls[m->complex_long_double_built_in];\n+\t    m->complex16_decl\n+\t      = builtin_decl_explicit (m->complex_long_double_built_in);\n \t}\n       else if (quad_decls[m->double_built_in] != NULL_TREE)\n         {\n@@ -2210,7 +2212,8 @@ gfc_conv_intrinsic_minmax (gfc_se * se, gfc_expr * expr, enum tree_code op)\n       if (FLOAT_TYPE_P (TREE_TYPE (mvar)))\n \t{\n \t  isnan = build_call_expr_loc (input_location,\n-\t\t\t\t   built_in_decls[BUILT_IN_ISNAN], 1, mvar);\n+\t\t\t\t       builtin_decl_explicit (BUILT_IN_ISNAN),\n+\t\t\t\t       1, mvar);\n \t  tmp = fold_build2_loc (input_location, TRUTH_OR_EXPR,\n \t\t\t\t boolean_type_node, tmp,\n \t\t\t\t fold_convert (boolean_type_node, isnan));\n@@ -4087,17 +4090,17 @@ gfc_conv_intrinsic_leadz (gfc_se * se, gfc_expr * expr)\n   if (argsize <= INT_TYPE_SIZE)\n     {\n       arg_type = unsigned_type_node;\n-      func = built_in_decls[BUILT_IN_CLZ];\n+      func = builtin_decl_explicit (BUILT_IN_CLZ);\n     }\n   else if (argsize <= LONG_TYPE_SIZE)\n     {\n       arg_type = long_unsigned_type_node;\n-      func = built_in_decls[BUILT_IN_CLZL];\n+      func = builtin_decl_explicit (BUILT_IN_CLZL);\n     }\n   else if (argsize <= LONG_LONG_TYPE_SIZE)\n     {\n       arg_type = long_long_unsigned_type_node;\n-      func = built_in_decls[BUILT_IN_CLZLL];\n+      func = builtin_decl_explicit (BUILT_IN_CLZLL);\n     }\n   else\n     {\n@@ -4136,7 +4139,7 @@ gfc_conv_intrinsic_leadz (gfc_se * se, gfc_expr * expr)\n \t where ULL_MAX is the largest value that a ULL_MAX can hold\n \t (0xFFFFFFFFFFFFFFFF for a 64-bit long long type), and ULLSIZE\n \t is the bit-size of the long long type (64 in this example).  */\n-      tree ullsize, ullmax, tmp1, tmp2;\n+      tree ullsize, ullmax, tmp1, tmp2, btmp;\n \n       ullsize = build_int_cst (result_type, LONG_LONG_TYPE_SIZE);\n       ullmax = fold_build1_loc (input_location, BIT_NOT_EXPR,\n@@ -4154,16 +4157,14 @@ gfc_conv_intrinsic_leadz (gfc_se * se, gfc_expr * expr)\n       tmp1 = fold_build2_loc (input_location, RSHIFT_EXPR, arg_type,\n \t\t\t      arg, ullsize);\n       tmp1 = fold_convert (long_long_unsigned_type_node, tmp1);\n+      btmp = builtin_decl_explicit (BUILT_IN_CLZLL);\n       tmp1 = fold_convert (result_type,\n-\t\t\t   build_call_expr_loc (input_location,\t\n-\t\t\t\t\t\tbuilt_in_decls[BUILT_IN_CLZLL],\n-\t\t\t\t\t\t1, tmp1));\n+\t\t\t   build_call_expr_loc (input_location, btmp, 1, tmp1));\n \n       tmp2 = fold_convert (long_long_unsigned_type_node, arg);\n+      btmp = builtin_decl_explicit (BUILT_IN_CLZLL);\n       tmp2 = fold_convert (result_type,\n-\t\t\t   build_call_expr_loc (input_location,\n-\t\t\t\t\t\tbuilt_in_decls[BUILT_IN_CLZLL],\n-\t\t\t\t\t\t1, tmp2));\n+\t\t\t   build_call_expr_loc (input_location, btmp, 1, tmp2));\n       tmp2 = fold_build2_loc (input_location, PLUS_EXPR, result_type,\n \t\t\t      tmp2, ullsize);\n \n@@ -4206,17 +4207,17 @@ gfc_conv_intrinsic_trailz (gfc_se * se, gfc_expr *expr)\n   if (argsize <= INT_TYPE_SIZE)\n     {\n       arg_type = unsigned_type_node;\n-      func = built_in_decls[BUILT_IN_CTZ];\n+      func = builtin_decl_explicit (BUILT_IN_CTZ);\n     }\n   else if (argsize <= LONG_TYPE_SIZE)\n     {\n       arg_type = long_unsigned_type_node;\n-      func = built_in_decls[BUILT_IN_CTZL];\n+      func = builtin_decl_explicit (BUILT_IN_CTZL);\n     }\n   else if (argsize <= LONG_LONG_TYPE_SIZE)\n     {\n       arg_type = long_long_unsigned_type_node;\n-      func = built_in_decls[BUILT_IN_CTZLL];\n+      func = builtin_decl_explicit (BUILT_IN_CTZLL);\n     }\n   else\n     {\n@@ -4250,7 +4251,7 @@ gfc_conv_intrinsic_trailz (gfc_se * se, gfc_expr *expr)\n \t where ULL_MAX is the largest value that a ULL_MAX can hold\n \t (0xFFFFFFFFFFFFFFFF for a 64-bit long long type), and ULLSIZE\n \t is the bit-size of the long long type (64 in this example).  */\n-      tree ullsize, ullmax, tmp1, tmp2;\n+      tree ullsize, ullmax, tmp1, tmp2, btmp;\n \n       ullsize = build_int_cst (result_type, LONG_LONG_TYPE_SIZE);\n       ullmax = fold_build1_loc (input_location, BIT_NOT_EXPR,\n@@ -4265,18 +4266,16 @@ gfc_conv_intrinsic_trailz (gfc_se * se, gfc_expr *expr)\n       tmp1 = fold_build2_loc (input_location, RSHIFT_EXPR, arg_type,\n \t\t\t      arg, ullsize);\n       tmp1 = fold_convert (long_long_unsigned_type_node, tmp1);\n+      btmp = builtin_decl_explicit (BUILT_IN_CTZLL);\n       tmp1 = fold_convert (result_type,\n-\t\t\t   build_call_expr_loc (input_location,\t\n-\t\t\t\t\t\tbuilt_in_decls[BUILT_IN_CTZLL],\n-\t\t\t\t\t\t1, tmp1));\n+\t\t\t   build_call_expr_loc (input_location, btmp, 1, tmp1));\n       tmp1 = fold_build2_loc (input_location, PLUS_EXPR, result_type,\n \t\t\t      tmp1, ullsize);\n \n       tmp2 = fold_convert (long_long_unsigned_type_node, arg);\n+      btmp = builtin_decl_explicit (BUILT_IN_CTZLL);\n       tmp2 = fold_convert (result_type,\n-\t\t\t   build_call_expr_loc (input_location,\n-\t\t\t\t\t\tbuilt_in_decls[BUILT_IN_CTZLL],\n-\t\t\t\t\t\t1, tmp2));\n+\t\t\t   build_call_expr_loc (input_location, btmp, 1, tmp2));\n \n       trailz = fold_build3_loc (input_location, COND_EXPR, result_type,\n \t\t\t\tcond, tmp1, tmp2);\n@@ -4312,17 +4311,23 @@ gfc_conv_intrinsic_popcnt_poppar (gfc_se * se, gfc_expr *expr, int parity)\n   if (argsize <= INT_TYPE_SIZE)\n     {\n       arg_type = unsigned_type_node;\n-      func = built_in_decls[parity ? BUILT_IN_PARITY : BUILT_IN_POPCOUNT];\n+      func = builtin_decl_explicit (parity\n+\t\t\t\t    ? BUILT_IN_PARITY\n+\t\t\t\t    : BUILT_IN_POPCOUNT);\n     }\n   else if (argsize <= LONG_TYPE_SIZE)\n     {\n       arg_type = long_unsigned_type_node;\n-      func = built_in_decls[parity ? BUILT_IN_PARITYL : BUILT_IN_POPCOUNTL];\n+      func = builtin_decl_explicit (parity\n+\t\t\t\t    ? BUILT_IN_PARITYL\n+\t\t\t\t    : BUILT_IN_POPCOUNTL);\n     }\n   else if (argsize <= LONG_LONG_TYPE_SIZE)\n     {\n       arg_type = long_long_unsigned_type_node;\n-      func = built_in_decls[parity ? BUILT_IN_PARITYLL : BUILT_IN_POPCOUNTLL];\n+      func = builtin_decl_explicit (parity\n+\t\t\t\t    ? BUILT_IN_PARITYLL\n+\t\t\t\t    : BUILT_IN_POPCOUNTLL);\n     }\n   else\n     {\n@@ -4335,7 +4340,9 @@ gfc_conv_intrinsic_popcnt_poppar (gfc_se * se, gfc_expr *expr, int parity)\n \t as 'long long'.  */\n       gcc_assert (argsize == 2 * LONG_LONG_TYPE_SIZE);\n \n-      func = built_in_decls[parity ? BUILT_IN_PARITYLL : BUILT_IN_POPCOUNTLL];\n+      func = builtin_decl_explicit (parity\n+\t\t\t\t    ? BUILT_IN_PARITYLL\n+\t\t\t\t    : BUILT_IN_POPCOUNTLL);\n \n       /* Convert it to an integer, and store into a variable.  */\n       utype = gfc_build_uint_type (argsize);\n@@ -4588,7 +4595,8 @@ gfc_conv_intrinsic_isnan (gfc_se * se, gfc_expr * expr)\n \n   gfc_conv_intrinsic_function_args (se, expr, &arg, 1);\n   se->expr = build_call_expr_loc (input_location,\n-\t\t\t      built_in_decls[BUILT_IN_ISNAN], 1, arg);\n+\t\t\t\t  builtin_decl_explicit (BUILT_IN_ISNAN),\n+\t\t\t\t  1, arg);\n   STRIP_TYPE_NOPS (se->expr);\n   se->expr = fold_convert (gfc_typenode_for_spec (&expr->ts), se->expr);\n }\n@@ -5498,7 +5506,7 @@ gfc_conv_intrinsic_transfer (gfc_se * se, gfc_expr * expr)\n \n   /* Use memcpy to do the transfer.  */\n   tmp = build_call_expr_loc (input_location,\n-\t\t\t built_in_decls[BUILT_IN_MEMCPY],\n+\t\t\t builtin_decl_explicit (BUILT_IN_MEMCPY),\n \t\t\t 3,\n \t\t\t tmp,\n \t\t\t fold_convert (pvoid_type_node, source),\n@@ -5543,7 +5551,7 @@ gfc_conv_intrinsic_transfer (gfc_se * se, gfc_expr * expr)\n       gfc_add_modify (&block, tmpdecl,\n \t\t      fold_convert (TREE_TYPE (ptr), tmp));\n       tmp = build_call_expr_loc (input_location,\n-\t\t\t     built_in_decls[BUILT_IN_MEMCPY], 3,\n+\t\t\t     builtin_decl_explicit (BUILT_IN_MEMCPY), 3,\n \t\t\t     fold_convert (pvoid_type_node, tmpdecl),\n \t\t\t     fold_convert (pvoid_type_node, ptr),\n \t\t\t     extent);\n@@ -5568,7 +5576,7 @@ gfc_conv_intrinsic_transfer (gfc_se * se, gfc_expr * expr)\n       /* Use memcpy to do the transfer.  */\n       tmp = gfc_build_addr_expr (NULL_TREE, tmpdecl);\n       tmp = build_call_expr_loc (input_location,\n-\t\t\t     built_in_decls[BUILT_IN_MEMCPY], 3,\n+\t\t\t     builtin_decl_explicit (BUILT_IN_MEMCPY), 3,\n \t\t\t     fold_convert (pvoid_type_node, tmp),\n \t\t\t     fold_convert (pvoid_type_node, ptr),\n \t\t\t     extent);\n@@ -6009,7 +6017,8 @@ gfc_conv_intrinsic_repeat (gfc_se * se, gfc_expr * expr)\n   tmp = fold_build_pointer_plus_loc (input_location,\n \t\t\t\t     fold_convert (pvoid_type_node, dest), tmp);\n   tmp = build_call_expr_loc (input_location,\n-\t\t\t     built_in_decls[BUILT_IN_MEMMOVE], 3, tmp, src,\n+\t\t\t     builtin_decl_explicit (BUILT_IN_MEMMOVE),\n+\t\t\t     3, tmp, src,\n \t\t\t     fold_build2_loc (input_location, MULT_EXPR,\n \t\t\t\t\t      size_type_node, slen,\n \t\t\t\t\t      fold_convert (size_type_node,"}, {"sha": "a41e97bdadf2fb4930aab850310488f25038c998", "filename": "gcc/fortran/trans-openmp.c", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e79983f458034c3061645a4c4ff83c9c4d9019b9/gcc%2Ffortran%2Ftrans-openmp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e79983f458034c3061645a4c4ff83c9c4d9019b9/gcc%2Ffortran%2Ftrans-openmp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-openmp.c?ref=e79983f458034c3061645a4c4ff83c9c4d9019b9", "patch": "@@ -249,7 +249,8 @@ gfc_omp_clause_copy_ctor (tree clause, tree dest, tree src)\n   gfc_conv_descriptor_data_set (&cond_block, dest, ptr);\n \n   call = build_call_expr_loc (input_location,\n-\t\t\t  built_in_decls[BUILT_IN_MEMCPY], 3, ptr,\n+\t\t\t  builtin_decl_explicit (BUILT_IN_MEMCPY),\n+\t\t\t  3, ptr,\n \t\t\t  fold_convert (pvoid_type_node,\n \t\t\t\t\tgfc_conv_descriptor_data_get (src)),\n \t\t\t  size);\n@@ -300,7 +301,7 @@ gfc_omp_clause_assign_op (tree clause ATTRIBUTE_UNUSED, tree dest, tree src)\n \t\t\t  size, esize);\n   size = gfc_evaluate_now (fold_convert (size_type_node, size), &block);\n   call = build_call_expr_loc (input_location,\n-\t\t\t  built_in_decls[BUILT_IN_MEMCPY], 3,\n+\t\t\t  builtin_decl_explicit (BUILT_IN_MEMCPY), 3,\n \t\t\t  fold_convert (pvoid_type_node,\n \t\t\t\t\tgfc_conv_descriptor_data_get (dest)),\n \t\t\t  fold_convert (pvoid_type_node,\n@@ -1273,7 +1274,7 @@ gfc_trans_omp_atomic (gfc_code *code)\n static tree\n gfc_trans_omp_barrier (void)\n {\n-  tree decl = built_in_decls [BUILT_IN_GOMP_BARRIER];\n+  tree decl = builtin_decl_explicit (BUILT_IN_GOMP_BARRIER);\n   return build_call_expr_loc (input_location, decl, 0);\n }\n \n@@ -1547,7 +1548,7 @@ gfc_trans_omp_do (gfc_code *code, stmtblock_t *pblock,\n static tree\n gfc_trans_omp_flush (void)\n {\n-  tree decl = built_in_decls [BUILT_IN_SYNC_SYNCHRONIZE];\n+  tree decl = builtin_decl_explicit (BUILT_IN_SYNC_SYNCHRONIZE);\n   return build_call_expr_loc (input_location, decl, 0);\n }\n \n@@ -1738,14 +1739,14 @@ gfc_trans_omp_task (gfc_code *code)\n static tree\n gfc_trans_omp_taskwait (void)\n {\n-  tree decl = built_in_decls [BUILT_IN_GOMP_TASKWAIT];\n+  tree decl = builtin_decl_explicit (BUILT_IN_GOMP_TASKWAIT);\n   return build_call_expr_loc (input_location, decl, 0);\n }\n \n static tree\n gfc_trans_omp_taskyield (void)\n {\n-  tree decl = built_in_decls [BUILT_IN_GOMP_TASKYIELD];\n+  tree decl = builtin_decl_explicit (BUILT_IN_GOMP_TASKYIELD);\n   return build_call_expr_loc (input_location, decl, 0);\n }\n "}, {"sha": "c71eeec400fc6f378885520e3a7ad23802e35696", "filename": "gcc/fortran/trans-stmt.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e79983f458034c3061645a4c4ff83c9c4d9019b9/gcc%2Ffortran%2Ftrans-stmt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e79983f458034c3061645a4c4ff83c9c4d9019b9/gcc%2Ffortran%2Ftrans-stmt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-stmt.c?ref=e79983f458034c3061645a4c4ff83c9c4d9019b9", "patch": "@@ -602,7 +602,7 @@ gfc_trans_stop (gfc_code *code, bool error_stop)\n   if (gfc_option.coarray == GFC_FCOARRAY_LIB && !error_stop)\n     {\n       /* Per F2008, 8.5.1 STOP implies a SYNC MEMORY.  */\n-      tmp = built_in_decls [BUILT_IN_SYNC_SYNCHRONIZE];\n+      tmp = builtin_decl_explicit (BUILT_IN_SYNC_SYNCHRONIZE);\n       tmp = build_call_expr_loc (input_location, tmp, 0);\n       gfc_add_expr_to_block (&se.pre, tmp);\n \n@@ -774,7 +774,7 @@ gfc_trans_sync (gfc_code *code, gfc_exec_op type)\n       image control statements SYNC IMAGES and SYNC ALL.  */\n    if (gfc_option.coarray == GFC_FCOARRAY_LIB)\n      {\n-\ttmp = built_in_decls [BUILT_IN_SYNC_SYNCHRONIZE];\n+       tmp = builtin_decl_explicit (BUILT_IN_SYNC_SYNCHRONIZE);\n \ttmp = build_call_expr_loc (input_location, tmp, 0);\n \tgfc_add_expr_to_block (&se.pre, tmp);\n      }\n@@ -5076,7 +5076,7 @@ gfc_trans_allocate (gfc_code * code)\n \t\t\t      slen);\n \n       dlen = build_call_expr_loc (input_location,\n-\t\t\t      built_in_decls[BUILT_IN_MEMCPY], 3,\n+\t\t\t\t  builtin_decl_explicit (BUILT_IN_MEMCPY), 3,\n \t\tgfc_build_addr_expr (pvoid_type_node, se.expr), errmsg, slen);\n \n       tmp = fold_build2_loc (input_location, NE_EXPR, boolean_type_node, stat,\n@@ -5251,7 +5251,7 @@ gfc_trans_deallocate (gfc_code *code)\n \t\t\t      slen);\n \n       dlen = build_call_expr_loc (input_location,\n-\t\t\t      built_in_decls[BUILT_IN_MEMCPY], 3,\n+\t\t\t\t  builtin_decl_explicit (BUILT_IN_MEMCPY), 3,\n \t\tgfc_build_addr_expr (pvoid_type_node, se.expr), errmsg, slen);\n \n       tmp = fold_build2_loc (input_location, NE_EXPR, boolean_type_node, astat,"}, {"sha": "0176aece2b87e57e95574411600682a977bb3cc1", "filename": "gcc/fortran/trans.c", "status": "modified", "additions": 15, "deletions": 11, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e79983f458034c3061645a4c4ff83c9c4d9019b9/gcc%2Ffortran%2Ftrans.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e79983f458034c3061645a4c4ff83c9c4d9019b9/gcc%2Ffortran%2Ftrans.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans.c?ref=e79983f458034c3061645a4c4ff83c9c4d9019b9", "patch": "@@ -512,7 +512,7 @@ gfc_trans_runtime_check (bool error, bool once, tree cond, stmtblock_t * pblock,\n tree\n gfc_call_malloc (stmtblock_t * block, tree type, tree size)\n {\n-  tree tmp, msg, malloc_result, null_result, res;\n+  tree tmp, msg, malloc_result, null_result, res, malloc_tree;\n   stmtblock_t block2;\n \n   size = gfc_evaluate_now (size, block);\n@@ -529,10 +529,11 @@ gfc_call_malloc (stmtblock_t * block, tree type, tree size)\n   size = fold_build2_loc (input_location, MAX_EXPR, size_type_node, size,\n \t\t\t  build_int_cst (size_type_node, 1));\n \n+  malloc_tree = builtin_decl_explicit (BUILT_IN_MALLOC);\n   gfc_add_modify (&block2, res,\n \t\t  fold_convert (prvoid_type_node,\n \t\t\t\tbuild_call_expr_loc (input_location,\n-\t\t\t\t   built_in_decls[BUILT_IN_MALLOC], 1, size)));\n+\t\t\t\t\t\t     malloc_tree, 1, size)));\n \n   /* Optionally check whether malloc was successful.  */\n   if (gfc_option.rtcheck & GFC_RTCHECK_MEM)\n@@ -604,7 +605,7 @@ gfc_allocate_using_malloc (stmtblock_t * block, tree pointer,\n   gfc_add_modify (block, pointer,\n \t  fold_convert (TREE_TYPE (pointer),\n \t\tbuild_call_expr_loc (input_location,\n-\t\t\t     built_in_decls[BUILT_IN_MALLOC], 1,\n+\t\t\t     builtin_decl_explicit (BUILT_IN_MALLOC), 1,\n \t\t\t     fold_build2_loc (input_location,\n \t\t\t\t      MAX_EXPR, size_type_node, size,\n \t\t\t\t      build_int_cst (size_type_node, 1)))));\n@@ -783,7 +784,8 @@ gfc_call_free (tree var)\n   cond = fold_build2_loc (input_location, NE_EXPR, boolean_type_node, var,\n \t\t\t  build_int_cst (pvoid_type_node, 0));\n   call = build_call_expr_loc (input_location,\n-\t\t\t      built_in_decls[BUILT_IN_FREE], 1, var);\n+\t\t\t      builtin_decl_explicit (BUILT_IN_FREE),\n+\t\t\t      1, var);\n   tmp = fold_build3_loc (input_location, COND_EXPR, void_type_node, cond, call,\n \t\t\t build_empty_stmt (input_location));\n   gfc_add_expr_to_block (&block, tmp);\n@@ -871,8 +873,8 @@ gfc_deallocate_with_status (tree pointer, tree status, bool can_fail,\n   /* When POINTER is not NULL, we free it.  */\n   gfc_start_block (&non_null);\n   tmp = build_call_expr_loc (input_location,\n-\t\t\t built_in_decls[BUILT_IN_FREE], 1,\n-\t\t\t fold_convert (pvoid_type_node, pointer));\n+\t\t\t     builtin_decl_explicit (BUILT_IN_FREE), 1,\n+\t\t\t     fold_convert (pvoid_type_node, pointer));\n   gfc_add_expr_to_block (&non_null, tmp);\n \n   if (status != NULL_TREE && !integer_zerop (status))\n@@ -968,8 +970,8 @@ gfc_deallocate_scalar_with_status (tree pointer, tree status, bool can_fail,\n     }\n   \n   tmp = build_call_expr_loc (input_location,\n-\t\t\t built_in_decls[BUILT_IN_FREE], 1,\n-\t\t\t fold_convert (pvoid_type_node, pointer));\n+\t\t\t     builtin_decl_explicit (BUILT_IN_FREE), 1,\n+\t\t\t     fold_convert (pvoid_type_node, pointer));\n   gfc_add_expr_to_block (&non_null, tmp);\n \n   if (status != NULL_TREE && !integer_zerop (status))\n@@ -1026,7 +1028,7 @@ gfc_call_realloc (stmtblock_t * block, tree mem, tree size)\n \n   /* Call realloc and check the result.  */\n   tmp = build_call_expr_loc (input_location,\n-\t\t\t built_in_decls[BUILT_IN_REALLOC], 2,\n+\t\t\t builtin_decl_explicit (BUILT_IN_REALLOC), 2,\n \t\t\t fold_convert (pvoid_type_node, mem), size);\n   gfc_add_modify (block, res, fold_convert (type, tmp));\n   null_result = fold_build2_loc (input_location, EQ_EXPR, boolean_type_node,\n@@ -1593,7 +1595,8 @@ gfc_unlikely (tree cond)\n   cond = fold_convert (long_integer_type_node, cond);\n   tmp = build_zero_cst (long_integer_type_node);\n   cond = build_call_expr_loc (input_location,\n-\t\t\t      built_in_decls[BUILT_IN_EXPECT], 2, cond, tmp);\n+\t\t\t      builtin_decl_explicit (BUILT_IN_EXPECT),\n+\t\t\t      2, cond, tmp);\n   cond = fold_convert (boolean_type_node, cond);\n   return cond;\n }\n@@ -1609,7 +1612,8 @@ gfc_likely (tree cond)\n   cond = fold_convert (long_integer_type_node, cond);\n   tmp = build_one_cst (long_integer_type_node);\n   cond = build_call_expr_loc (input_location,\n-\t\t\t      built_in_decls[BUILT_IN_EXPECT], 2, cond, tmp);\n+\t\t\t      builtin_decl_explicit (BUILT_IN_EXPECT),\n+\t\t\t      2, cond, tmp);\n   cond = fold_convert (boolean_type_node, cond);\n   return cond;\n }"}, {"sha": "c5ede62ca06c9e95ad3309b1defb5a17b6bac4ab", "filename": "gcc/function.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e79983f458034c3061645a4c4ff83c9c4d9019b9/gcc%2Ffunction.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e79983f458034c3061645a4c4ff83c9c4d9019b9/gcc%2Ffunction.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffunction.c?ref=e79983f458034c3061645a4c4ff83c9c4d9019b9", "patch": "@@ -3635,7 +3635,7 @@ gimplify_parameters (void)\n \t\t  DECL_IGNORED_P (addr) = 0;\n \t\t  local = build_fold_indirect_ref (addr);\n \n-\t\t  t = built_in_decls[BUILT_IN_ALLOCA_WITH_ALIGN];\n+\t\t  t = builtin_decl_explicit (BUILT_IN_ALLOCA_WITH_ALIGN);\n \t\t  t = build_call_expr (t, 1, DECL_SIZE_UNIT (parm),\n \t\t\t\t       size_int (DECL_ALIGN (parm)));\n "}, {"sha": "fd03ba4702bc9025a885f9fc0b4c836f688425a0", "filename": "gcc/gimple-low.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e79983f458034c3061645a4c4ff83c9c4d9019b9/gcc%2Fgimple-low.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e79983f458034c3061645a4c4ff83c9c4d9019b9/gcc%2Fgimple-low.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-low.c?ref=e79983f458034c3061645a4c4ff83c9c4d9019b9", "patch": "@@ -169,7 +169,7 @@ lower_function_body (void)\n \t and insert.  */\n       disp_var = create_tmp_var (ptr_type_node, \"setjmpvar\");\n       arg = build_addr (disp_label, current_function_decl);\n-      t = implicit_built_in_decls[BUILT_IN_SETJMP_DISPATCHER];\n+      t = builtin_decl_implicit (BUILT_IN_SETJMP_DISPATCHER);\n       x = gimple_build_call (t, 1, arg);\n       gimple_call_set_lhs (x, disp_var);\n \n@@ -861,7 +861,7 @@ lower_builtin_setjmp (gimple_stmt_iterator *gsi)\n \n   /* Build '__builtin_setjmp_setup (BUF, NEXT_LABEL)' and insert.  */\n   arg = build_addr (next_label, current_function_decl);\n-  t = implicit_built_in_decls[BUILT_IN_SETJMP_SETUP];\n+  t = builtin_decl_implicit (BUILT_IN_SETJMP_SETUP);\n   g = gimple_build_call (t, 2, gimple_call_arg (stmt, 0), arg);\n   gimple_set_location (g, loc);\n   gimple_set_block (g, gimple_block (stmt));\n@@ -886,7 +886,7 @@ lower_builtin_setjmp (gimple_stmt_iterator *gsi)\n \n   /* Build '__builtin_setjmp_receiver (NEXT_LABEL)' and insert.  */\n   arg = build_addr (next_label, current_function_decl);\n-  t = implicit_built_in_decls[BUILT_IN_SETJMP_RECEIVER];\n+  t = builtin_decl_implicit (BUILT_IN_SETJMP_RECEIVER);\n   g = gimple_build_call (t, 1, arg);\n   gimple_set_location (g, loc);\n   gimple_set_block (g, gimple_block (stmt));"}, {"sha": "2c9ba1d78aadf34a5b0d5193cf5d768cf8efbf53", "filename": "gcc/gimplify.c", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e79983f458034c3061645a4c4ff83c9c4d9019b9/gcc%2Fgimplify.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e79983f458034c3061645a4c4ff83c9c4d9019b9/gcc%2Fgimplify.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimplify.c?ref=e79983f458034c3061645a4c4ff83c9c4d9019b9", "patch": "@@ -1109,12 +1109,12 @@ build_stack_save_restore (gimple *save, gimple *restore)\n {\n   tree tmp_var;\n \n-  *save = gimple_build_call (implicit_built_in_decls[BUILT_IN_STACK_SAVE], 0);\n+  *save = gimple_build_call (builtin_decl_implicit (BUILT_IN_STACK_SAVE), 0);\n   tmp_var = create_tmp_var (ptr_type_node, \"saved_stack\");\n   gimple_call_set_lhs (*save, tmp_var);\n \n   *restore\n-    = gimple_build_call (implicit_built_in_decls[BUILT_IN_STACK_RESTORE],\n+    = gimple_build_call (builtin_decl_implicit (BUILT_IN_STACK_RESTORE),\n \t\t\t 1, tmp_var);\n }\n \n@@ -1329,7 +1329,7 @@ gimplify_vla_decl (tree decl, gimple_seq *seq_p)\n   SET_DECL_VALUE_EXPR (decl, t);\n   DECL_HAS_VALUE_EXPR_P (decl) = 1;\n \n-  t = built_in_decls[BUILT_IN_ALLOCA_WITH_ALIGN];\n+  t = builtin_decl_explicit (BUILT_IN_ALLOCA_WITH_ALIGN);\n   t = build_call_expr (t, 2, DECL_SIZE_UNIT (decl),\n \t\t       size_int (DECL_ALIGN (decl)));\n   /* The call has been built for a variable-sized object.  */\n@@ -3211,7 +3211,7 @@ gimplify_modify_expr_to_memcpy (tree *expr_p, tree size, bool want_value,\n   to_ptr = build_fold_addr_expr_loc (loc, to);\n   gimplify_arg (&to_ptr, seq_p, loc);\n \n-  t = implicit_built_in_decls[BUILT_IN_MEMCPY];\n+  t = builtin_decl_implicit (BUILT_IN_MEMCPY);\n \n   gs = gimple_build_call (t, 3, to_ptr, from_ptr, size);\n \n@@ -3258,7 +3258,7 @@ gimplify_modify_expr_to_memset (tree *expr_p, tree size, bool want_value,\n \n   to_ptr = build_fold_addr_expr_loc (loc, to);\n   gimplify_arg (&to_ptr, seq_p, loc);\n-  t = implicit_built_in_decls[BUILT_IN_MEMSET];\n+  t = builtin_decl_implicit (BUILT_IN_MEMSET);\n \n   gs = gimple_build_call (t, 3, to_ptr, integer_zero_node, size);\n \n@@ -4681,7 +4681,7 @@ gimplify_variable_sized_compare (tree *expr_p)\n   arg = SUBSTITUTE_PLACEHOLDER_IN_EXPR (arg, op0);\n   src = build_fold_addr_expr_loc (loc, op1);\n   dest = build_fold_addr_expr_loc (loc, op0);\n-  t = implicit_built_in_decls[BUILT_IN_MEMCMP];\n+  t = builtin_decl_implicit (BUILT_IN_MEMCMP);\n   t = build_call_expr_loc (loc, t, 3, dest, src, arg);\n \n   expr\n@@ -7980,24 +7980,24 @@ gimplify_function_tree (tree fndecl)\n       tree tmp_var;\n       gimple call;\n \n-      x = implicit_built_in_decls[BUILT_IN_RETURN_ADDRESS];\n+      x = builtin_decl_implicit (BUILT_IN_RETURN_ADDRESS);\n       call = gimple_build_call (x, 1, integer_zero_node);\n       tmp_var = create_tmp_var (ptr_type_node, \"return_addr\");\n       gimple_call_set_lhs (call, tmp_var);\n       gimplify_seq_add_stmt (&cleanup, call);\n-      x = implicit_built_in_decls[BUILT_IN_PROFILE_FUNC_EXIT];\n+      x = builtin_decl_implicit (BUILT_IN_PROFILE_FUNC_EXIT);\n       call = gimple_build_call (x, 2,\n \t\t\t\tbuild_fold_addr_expr (current_function_decl),\n \t\t\t\ttmp_var);\n       gimplify_seq_add_stmt (&cleanup, call);\n       tf = gimple_build_try (seq, cleanup, GIMPLE_TRY_FINALLY);\n \n-      x = implicit_built_in_decls[BUILT_IN_RETURN_ADDRESS];\n+      x = builtin_decl_implicit (BUILT_IN_RETURN_ADDRESS);\n       call = gimple_build_call (x, 1, integer_zero_node);\n       tmp_var = create_tmp_var (ptr_type_node, \"return_addr\");\n       gimple_call_set_lhs (call, tmp_var);\n       gimplify_seq_add_stmt (&body, call);\n-      x = implicit_built_in_decls[BUILT_IN_PROFILE_FUNC_ENTER];\n+      x = builtin_decl_implicit (BUILT_IN_PROFILE_FUNC_ENTER);\n       call = gimple_build_call (x, 2,\n \t\t\t\tbuild_fold_addr_expr (current_function_decl),\n \t\t\t\ttmp_var);"}, {"sha": "db0fdb31b9b3a4e9b2dff4c3a1ae32a76607dc43", "filename": "gcc/go/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e79983f458034c3061645a4c4ff83c9c4d9019b9/gcc%2Fgo%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e79983f458034c3061645a4c4ff83c9c4d9019b9/gcc%2Fgo%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2FChangeLog?ref=e79983f458034c3061645a4c4ff83c9c4d9019b9", "patch": "@@ -1,3 +1,13 @@\n+2011-10-11  Michael Meissner  <meissner@linux.vnet.ibm.com>\n+\n+\t* gofrontend/gogo-tree.cc (define_builtin): Delete old interface\n+\twith two parallel arrays to hold standard builtin declarations,\n+\tand replace it with a function based interface that can support\n+\tcreating builtins on the fly in the future.  Change all uses, and\n+\tpoison the old names.  Make sure 0 is not a legitimate builtin\n+\tindex.\n+\t(Gogo::make_trampoline(tree): Ditto.\n+\n 2011-08-24  Roberto Lublinerman  <rluble@gmail.com>\n \n \t* lang.opt: Add fgo-optimize-."}, {"sha": "6cfc0124604e03c9bfe7dfdd097f604508761e25", "filename": "gcc/go/gofrontend/gogo-tree.cc", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e79983f458034c3061645a4c4ff83c9c4d9019b9/gcc%2Fgo%2Fgofrontend%2Fgogo-tree.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e79983f458034c3061645a4c4ff83c9c4d9019b9/gcc%2Fgo%2Fgofrontend%2Fgogo-tree.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fgogo-tree.cc?ref=e79983f458034c3061645a4c4ff83c9c4d9019b9", "patch": "@@ -69,8 +69,7 @@ define_builtin(built_in_function bcode, const char* name, const char* libname,\n \t\t\t\t   libname, NULL_TREE);\n   if (const_p)\n     TREE_READONLY(decl) = 1;\n-  built_in_decls[bcode] = decl;\n-  implicit_built_in_decls[bcode] = decl;\n+  set_builtin_decl (bcode, decl, true);\n   builtin_functions[name] = decl;\n   if (libname != NULL)\n     {\n@@ -2311,14 +2310,13 @@ Gogo::make_trampoline(tree fnaddr, tree closure, source_location location)\n   x = save_expr(x);\n \n   // Initialize the trampoline.\n-  tree ini = build_call_expr(implicit_built_in_decls[BUILT_IN_INIT_TRAMPOLINE],\n+  tree ini = build_call_expr(builtin_decl_implicit(BUILT_IN_INIT_TRAMPOLINE),\n \t\t\t     3, x, fnaddr, closure);\n \n   // On some targets the trampoline address needs to be adjusted.  For\n   // example, when compiling in Thumb mode on the ARM, the address\n   // needs to have the low bit set.\n-  x = build_call_expr(implicit_built_in_decls[BUILT_IN_ADJUST_TRAMPOLINE],\n-\t\t      1, x);\n+  x = build_call_expr(builtin_decl_explicit(BUILT_IN_ADJUST_TRAMPOLINE), 1, x);\n   x = fold_convert(TREE_TYPE(fnaddr), x);\n \n   return build2(COMPOUND_EXPR, TREE_TYPE(x), ini, x);"}, {"sha": "dfb6500541c30082f6995f8ef3cd91673305bcd4", "filename": "gcc/java/ChangeLog", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e79983f458034c3061645a4c4ff83c9c4d9019b9/gcc%2Fjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e79983f458034c3061645a4c4ff83c9c4d9019b9/gcc%2Fjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2FChangeLog?ref=e79983f458034c3061645a4c4ff83c9c4d9019b9", "patch": "@@ -1,3 +1,19 @@\n+2011-10-11  Michael Meissner  <meissner@linux.vnet.ibm.com>\n+\n+\t* class.c (build_static_field_ref): Delete old interface with two\n+\tparallel arrays to hold standard builtin declarations, and replace\n+\tit with a function based interface that can support creating\n+\tbuiltins on the fly in the future.  Change all uses, and poison\n+\tthe old names.  Make sure 0 is not a legitimate builtin index.\n+\t* decl.c (java_init_decl_processing): Ditto.\n+\t* except.c (compareAndSwapLong_builtin): Ditto.\n+\t(compareAndSwapObject_builtin): Ditto.\n+\t(putVolatile_builtin): Ditto.\n+\t(define_builtin): Ditto.\n+\t(check_for_builtin): Ditto.\n+\t* expr.c (rewrite_arglist_getcaller): Ditto.\n+\t(expand_java_field_op): Ditto.\n+\n 2011-08-24  Joseph Myers  <joseph@codesourcery.com>\n \n \t* Make-lang.in (CFLAGS-java/jcf-io.o, CFLAGS-java/jcf-path.o):"}, {"sha": "5ab345dc472403d75afca9be86287a309ec06b18", "filename": "gcc/java/builtins.c", "status": "modified", "additions": 12, "deletions": 14, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e79983f458034c3061645a4c4ff83c9c4d9019b9/gcc%2Fjava%2Fbuiltins.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e79983f458034c3061645a4c4ff83c9c4d9019b9/gcc%2Fjava%2Fbuiltins.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fbuiltins.c?ref=e79983f458034c3061645a4c4ff83c9c4d9019b9", "patch": "@@ -324,13 +324,13 @@ compareAndSwapInt_builtin (tree method_return_type ATTRIBUTE_UNUSED,\n       || flag_use_atomic_builtins)\n     {\n       tree addr, stmt;\n+      enum built_in_function fncode = BUILT_IN_SYNC_BOOL_COMPARE_AND_SWAP_4;\n       UNMARSHAL5 (orig_call);\n       (void) value_type; /* Avoid set but not used warning.  */\n \n       addr = build_addr_sum (int_type_node, obj_arg, offset_arg);\n-      stmt = build_call_expr \n-\t\t\t(built_in_decls[BUILT_IN_SYNC_BOOL_COMPARE_AND_SWAP_4],\n-\t\t\t 3, addr, expected_arg, value_arg);\n+      stmt = build_call_expr (builtin_decl_explicit (fncode),\n+\t\t\t      3, addr, expected_arg, value_arg);\n \n       return build_check_this (stmt, this_arg);\n     }\n@@ -351,13 +351,13 @@ compareAndSwapLong_builtin (tree method_return_type ATTRIBUTE_UNUSED,\n        but not the multi-word versions.  */\n     {\n       tree addr, stmt;\n+      enum built_in_function fncode = BUILT_IN_SYNC_BOOL_COMPARE_AND_SWAP_8;\n       UNMARSHAL5 (orig_call);\n       (void) value_type; /* Avoid set but not used warning.  */\n \n       addr = build_addr_sum (long_type_node, obj_arg, offset_arg);\n-      stmt = build_call_expr \n-\t\t\t(built_in_decls[BUILT_IN_SYNC_BOOL_COMPARE_AND_SWAP_8],\n-\t\t\t 3, addr, expected_arg, value_arg);\n+      stmt = build_call_expr (builtin_decl_explicit (fncode),\n+\t\t\t      3, addr, expected_arg, value_arg);\n \n       return build_check_this (stmt, this_arg);\n     }\n@@ -373,15 +373,15 @@ compareAndSwapObject_builtin (tree method_return_type ATTRIBUTE_UNUSED,\n       || flag_use_atomic_builtins)\n   {\n     tree addr, stmt;\n-    int builtin;\n+    enum built_in_function builtin;\n \n     UNMARSHAL5 (orig_call);\n     builtin = (POINTER_SIZE == 32 \n \t       ? BUILT_IN_SYNC_BOOL_COMPARE_AND_SWAP_4 \n \t       : BUILT_IN_SYNC_BOOL_COMPARE_AND_SWAP_8);\n \n     addr = build_addr_sum (value_type, obj_arg, offset_arg);\n-    stmt = build_call_expr (built_in_decls[builtin],\n+    stmt = build_call_expr (builtin_decl_explicit (builtin),\n \t\t\t    3, addr, expected_arg, value_arg);\n \n     return build_check_this (stmt, this_arg);\n@@ -401,7 +401,7 @@ putVolatile_builtin (tree method_return_type ATTRIBUTE_UNUSED,\n     = fold_convert (build_pointer_type (build_type_variant (value_type, 0, 1)),\n \t\t    addr);\n   \n-  stmt = build_call_expr (built_in_decls[BUILT_IN_SYNC_SYNCHRONIZE], 0);\n+  stmt = build_call_expr (builtin_decl_explicit (BUILT_IN_SYNC_SYNCHRONIZE), 0);\n   modify_stmt = fold_build2 (MODIFY_EXPR, value_type,\n \t\t\t     build_java_indirect_ref (value_type, addr,\n \t\t\t\t\t\t      flag_check_references),\n@@ -425,8 +425,7 @@ getVolatile_builtin (tree method_return_type ATTRIBUTE_UNUSED,\n     = fold_convert (build_pointer_type (build_type_variant \n \t\t\t\t\t(method_return_type, 0, 1)), addr);\n   \n-  stmt = build_call_expr (built_in_decls[BUILT_IN_SYNC_SYNCHRONIZE], 0);\n-  \n+  stmt = build_call_expr (builtin_decl_explicit (BUILT_IN_SYNC_SYNCHRONIZE), 0);\n   tmp = build_decl (BUILTINS_LOCATION, VAR_DECL, NULL, method_return_type);\n   DECL_IGNORED_P (tmp) = 1;\n   DECL_ARTIFICIAL (tmp) = 1;\n@@ -483,8 +482,7 @@ define_builtin (enum built_in_function val,\n   if (flags & BUILTIN_CONST)\n     TREE_READONLY (decl) = 1;\n \n-  implicit_built_in_decls[val] = decl;\n-  built_in_decls[val] = decl;\n+  set_builtin_decl (val, decl, true);\n }\n \n \f\n@@ -627,7 +625,7 @@ check_for_builtin (tree method, tree call)\n \t         with the BC-ABI.  */\n \t      if (flag_indirect_dispatch)\n \t        return call;\n-\t      fn = built_in_decls[java_builtins[i].builtin_code];\n+\t      fn = builtin_decl_explicit (java_builtins[i].builtin_code);\n \t      if (fn == NULL_TREE)\n \t\treturn call;\n \t      return java_build_function_call_expr (fn, call);"}, {"sha": "ac69319349a867dab1b9f82e659738d4f467fe54", "filename": "gcc/java/class.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e79983f458034c3061645a4c4ff83c9c4d9019b9/gcc%2Fjava%2Fclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e79983f458034c3061645a4c4ff83c9c4d9019b9/gcc%2Fjava%2Fclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fclass.c?ref=e79983f458034c3061645a4c4ff83c9c4d9019b9", "patch": "@@ -1266,7 +1266,7 @@ build_static_field_ref (tree fdecl)\n       int cpool_index = alloc_constant_fieldref (output_class, fdecl);\n       tree cache_entry = build_fieldref_cache_entry (cpool_index, fdecl);\n       tree test\n-        = build_call_expr (built_in_decls[BUILT_IN_EXPECT], 2,\n+        = build_call_expr (builtin_decl_implicit (BUILT_IN_EXPECT), 2,\n \t\t\t   build2 (EQ_EXPR, boolean_type_node,\n \t\t\t\t   cache_entry, null_pointer_node),\n \t\t\t   boolean_false_node);"}, {"sha": "1e1db76dc3b6c7b0d15335bb94212902fa1cc542", "filename": "gcc/java/decl.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e79983f458034c3061645a4c4ff83c9c4d9019b9/gcc%2Fjava%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e79983f458034c3061645a4c4ff83c9c4d9019b9/gcc%2Fjava%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fdecl.c?ref=e79983f458034c3061645a4c4ff83c9c4d9019b9", "patch": "@@ -1135,7 +1135,7 @@ java_init_decl_processing (void)\n \n   initialize_builtins ();\n \n-  soft_fmod_node = built_in_decls[BUILT_IN_FMOD];\n+  soft_fmod_node = builtin_decl_explicit (BUILT_IN_FMOD);\n \n   parse_version ();\n }"}, {"sha": "ff9a1063e373094bb496d7d4fc00f1d092895750", "filename": "gcc/java/except.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e79983f458034c3061645a4c4ff83c9c4d9019b9/gcc%2Fjava%2Fexcept.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e79983f458034c3061645a4c4ff83c9c4d9019b9/gcc%2Fjava%2Fexcept.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fexcept.c?ref=e79983f458034c3061645a4c4ff83c9c4d9019b9", "patch": "@@ -520,8 +520,8 @@ expand_end_java_handler (struct eh_range *range)\n \t    type = throwable_type_node;\n \t  eh_type = prepare_eh_table_type (type);\n \n-\t  x = build_call_expr (built_in_decls[BUILT_IN_EH_POINTER],\n-\t\t\t\t1, integer_zero_node);\n+\t  x = build_call_expr (builtin_decl_explicit (BUILT_IN_EH_POINTER),\n+\t\t\t       1, integer_zero_node);\n \t  x = build2 (MODIFY_EXPR, void_type_node, exc_obj, x);\n \t  tsi_link_after (&stmts_i, x, TSI_CONTINUE_LINKING);\n "}, {"sha": "d38311726d38bafa6479c99d6a9cbf50a0b8cb4f", "filename": "gcc/java/expr.c", "status": "modified", "additions": 9, "deletions": 5, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e79983f458034c3061645a4c4ff83c9c4d9019b9/gcc%2Fjava%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e79983f458034c3061645a4c4ff83c9c4d9019b9/gcc%2Fjava%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fexpr.c?ref=e79983f458034c3061645a4c4ff83c9c4d9019b9", "patch": "@@ -2073,7 +2073,7 @@ static void\n rewrite_arglist_getcaller (VEC(tree,gc) **arglist)\n {\n   tree retaddr \n-    = build_call_expr (built_in_decls[BUILT_IN_RETURN_ADDRESS],\n+    = build_call_expr (builtin_decl_explicit (BUILT_IN_RETURN_ADDRESS),\n \t\t       1, integer_zero_node);\n \n   DECL_UNINLINABLE (current_function_decl) = 1;\n@@ -2933,8 +2933,10 @@ expand_java_field_op (int is_static, int is_putting, int field_ref_index)\n \t\t\t    field_ref, new_value);\n \n       if (TREE_THIS_VOLATILE (field_decl))\n-\tjava_add_stmt\n-\t  (build_call_expr (built_in_decls[BUILT_IN_SYNC_SYNCHRONIZE], 0));\n+\t{\n+\t  tree sync = builtin_decl_explicit (BUILT_IN_SYNC_SYNCHRONIZE);\n+\t  java_add_stmt (build_call_expr (sync, 0));\n+\t}\n       \t  \n       java_add_stmt (modify_expr);\n     }\n@@ -2952,8 +2954,10 @@ expand_java_field_op (int is_static, int is_putting, int field_ref_index)\n       java_add_stmt (modify_expr);\n \n       if (TREE_THIS_VOLATILE (field_decl))\n-\tjava_add_stmt \n-\t  (build_call_expr (built_in_decls[BUILT_IN_SYNC_SYNCHRONIZE], 0));\n+\t{\n+\t  tree sync = builtin_decl_explicit (BUILT_IN_SYNC_SYNCHRONIZE);\n+\t  java_add_stmt (build_call_expr (sync, 0));\n+\t}\n \n       push_value (temp);\n     }      "}, {"sha": "e350fd83b054729e9d70e27ff9901fa29e8fe2b0", "filename": "gcc/lto/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e79983f458034c3061645a4c4ff83c9c4d9019b9/gcc%2Flto%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e79983f458034c3061645a4c4ff83c9c4d9019b9/gcc%2Flto%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto%2FChangeLog?ref=e79983f458034c3061645a4c4ff83c9c4d9019b9", "patch": "@@ -1,3 +1,11 @@\n+2011-10-11  Michael Meissner  <meissner@linux.vnet.ibm.com>\n+\n+\t* lto-lang.c (def_builtin_1): Delete old interface with two\n+\tparallel arrays to hold standard builtin declarations, and replace\n+\tit with a function based interface that can support creating\n+\tbuiltins on the fly in the future.  Change all uses, and poison\n+\tthe old names.  Make sure 0 is not a legitimate builtin index.\n+\n 2011-10-02   Andi Kleen <ak@linux.intel.com>\n \n \t* lto-object.c (lto_obj_add_section_data): Add list."}, {"sha": "4a5f6fe8ab55e871412638cc4255124391b9b601", "filename": "gcc/lto/lto-lang.c", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e79983f458034c3061645a4c4ff83c9c4d9019b9/gcc%2Flto%2Flto-lang.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e79983f458034c3061645a4c4ff83c9c4d9019b9/gcc%2Flto%2Flto-lang.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto%2Flto-lang.c?ref=e79983f458034c3061645a4c4ff83c9c4d9019b9", "patch": "@@ -499,9 +499,7 @@ def_builtin_1 (enum built_in_function fncode, const char *name,\n     add_builtin_function (libname, libtype, fncode, fnclass,\n \t\t\t  NULL, fnattrs);\n \n-  built_in_decls[(int) fncode] = decl;\n-  if (implicit_p)\n-    implicit_built_in_decls[(int) fncode] = decl;\n+  set_builtin_decl (fncode, decl, implicit_p);\n }\n \n "}, {"sha": "e195ed5dd1b7d12dffbf56b83372652fa287d2c8", "filename": "gcc/objc/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e79983f458034c3061645a4c4ff83c9c4d9019b9/gcc%2Fobjc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e79983f458034c3061645a4c4ff83c9c4d9019b9/gcc%2Fobjc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fobjc%2FChangeLog?ref=e79983f458034c3061645a4c4ff83c9c4d9019b9", "patch": "@@ -1,3 +1,14 @@\n+2011-10-11  Michael Meissner  <meissner@linux.vnet.ibm.com>\n+\n+\t* objc-next-runtime-abi-01.c (objc_build_exc_ptr): Delete old\n+\tinterface with two parallel arrays to hold standard builtin\n+\tdeclarations, and replace it with a function based interface that\n+\tcan support creating builtins on the fly in the future.  Change\n+\tall uses, and poison the old names.  Make sure 0 is not a\n+\tlegitimate builtin index.\n+\t* objc-next-runtime-abi-02.c (objc_build_exc_ptr): Ditto.\n+\t* objc-gnu-runtime-abi-01.c (objc_build_exc_ptr): Ditto.\n+\n 2011-07-19  Richard Guenther  <rguenther@suse.de>\n \n \t* objc-next-runtime-abi-02.c (objc_v2_build_ivar_ref):"}, {"sha": "f136828f60acb586250f1d6868dafbff30ab946f", "filename": "gcc/objc/objc-gnu-runtime-abi-01.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e79983f458034c3061645a4c4ff83c9c4d9019b9/gcc%2Fobjc%2Fobjc-gnu-runtime-abi-01.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e79983f458034c3061645a4c4ff83c9c4d9019b9/gcc%2Fobjc%2Fobjc-gnu-runtime-abi-01.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fobjc%2Fobjc-gnu-runtime-abi-01.c?ref=e79983f458034c3061645a4c4ff83c9c4d9019b9", "patch": "@@ -2226,7 +2226,7 @@ static tree\n objc_build_exc_ptr (struct objc_try_context **x ATTRIBUTE_UNUSED)\n {\n   tree t;\n-  t = built_in_decls[BUILT_IN_EH_POINTER];\n+  t = builtin_decl_explicit (BUILT_IN_EH_POINTER);\n   t = build_call_expr (t, 1, integer_zero_node);\n   return fold_convert (objc_object_type, t);\n }"}, {"sha": "c1e60b392d530ab6bdb58ccc4a8a03054f83b87a", "filename": "gcc/objc/objc-next-runtime-abi-01.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e79983f458034c3061645a4c4ff83c9c4d9019b9/gcc%2Fobjc%2Fobjc-next-runtime-abi-01.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e79983f458034c3061645a4c4ff83c9c4d9019b9/gcc%2Fobjc%2Fobjc-next-runtime-abi-01.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fobjc%2Fobjc-next-runtime-abi-01.c?ref=e79983f458034c3061645a4c4ff83c9c4d9019b9", "patch": "@@ -2919,7 +2919,7 @@ objc_build_exc_ptr (struct objc_try_context **cur_try_context)\n   else\n     {\n       tree t;\n-      t = built_in_decls[BUILT_IN_EH_POINTER];\n+      t = builtin_decl_explicit (BUILT_IN_EH_POINTER);\n       t = build_call_expr (t, 1, integer_zero_node);\n       return fold_convert (objc_object_type, t);\n     }"}, {"sha": "56df2afaf0c5ee0cea189b0c1b367b952cf9f8f0", "filename": "gcc/objc/objc-next-runtime-abi-02.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e79983f458034c3061645a4c4ff83c9c4d9019b9/gcc%2Fobjc%2Fobjc-next-runtime-abi-02.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e79983f458034c3061645a4c4ff83c9c4d9019b9/gcc%2Fobjc%2Fobjc-next-runtime-abi-02.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fobjc%2Fobjc-next-runtime-abi-02.c?ref=e79983f458034c3061645a4c4ff83c9c4d9019b9", "patch": "@@ -3676,7 +3676,7 @@ static tree\n objc_build_exc_ptr (struct objc_try_context **x ATTRIBUTE_UNUSED)\n {\n   tree t;\n-  t = built_in_decls[BUILT_IN_EH_POINTER];\n+  t = builtin_decl_explicit (BUILT_IN_EH_POINTER);\n   t = build_call_expr (t, 1, integer_zero_node);\n   return fold_convert (objc_object_type, t);\n }"}, {"sha": "05a3493e95f9160605f441774daeadace2ec31df", "filename": "gcc/omp-low.c", "status": "modified", "additions": 91, "deletions": 71, "changes": 162, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e79983f458034c3061645a4c4ff83c9c4d9019b9/gcc%2Fomp-low.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e79983f458034c3061645a4c4ff83c9c4d9019b9/gcc%2Fomp-low.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fomp-low.c?ref=e79983f458034c3061645a4c4ff83c9c4d9019b9", "patch": "@@ -2059,7 +2059,7 @@ scan_omp (gimple_seq body, omp_context *ctx)\n static tree\n build_omp_barrier (void)\n {\n-  return build_call_expr (built_in_decls[BUILT_IN_GOMP_BARRIER], 0);\n+  return build_call_expr (builtin_decl_explicit (BUILT_IN_GOMP_BARRIER), 0);\n }\n \n /* If a context was created for STMT when it was scanned, return it.  */\n@@ -2300,7 +2300,7 @@ lower_rec_input_clauses (tree clauses, gimple_seq *ilist, gimple_seq *dlist,\n \t      if (c_kind != OMP_CLAUSE_FIRSTPRIVATE || !is_task_ctx (ctx))\n \t\t{\n \t\t  gimple stmt;\n-\t\t  tree tmp;\n+\t\t  tree tmp, atmp;\n \n \t\t  ptr = DECL_VALUE_EXPR (new_var);\n \t\t  gcc_assert (TREE_CODE (ptr) == INDIRECT_REF);\n@@ -2309,8 +2309,8 @@ lower_rec_input_clauses (tree clauses, gimple_seq *ilist, gimple_seq *dlist,\n \t\t  x = TYPE_SIZE_UNIT (TREE_TYPE (new_var));\n \n \t\t  /* void *tmp = __builtin_alloca */\n-\t\t  stmt\n-\t\t    = gimple_build_call (built_in_decls[BUILT_IN_ALLOCA], 1, x);\n+\t\t  atmp = builtin_decl_explicit (BUILT_IN_ALLOCA);\n+\t\t  stmt = gimple_build_call (atmp, 1, x);\n \t\t  tmp = create_tmp_var_raw (ptr_type_node, NULL);\n \t\t  gimple_add_tmp_var (tmp);\n \t\t  gimple_call_set_lhs (stmt, tmp);\n@@ -2354,8 +2354,8 @@ lower_rec_input_clauses (tree clauses, gimple_seq *ilist, gimple_seq *dlist,\n \t\t}\n \t      else\n \t\t{\n-\t\t  x = build_call_expr_loc (clause_loc,\n-\t\t\t\t       built_in_decls[BUILT_IN_ALLOCA], 1, x);\n+\t\t  tree atmp = builtin_decl_explicit (BUILT_IN_ALLOCA);\n+\t\t  x = build_call_expr_loc (clause_loc, atmp, 1, x);\n \t\t}\n \n \t      x = fold_convert_loc (clause_loc, TREE_TYPE (new_var), x);\n@@ -2493,7 +2493,8 @@ lower_rec_input_clauses (tree clauses, gimple_seq *ilist, gimple_seq *dlist,\n      but it certainly is to C++ operator=.  */\n   if (copyin_seq)\n     {\n-      x = build_call_expr (built_in_decls[BUILT_IN_OMP_GET_THREAD_NUM], 0);\n+      x = build_call_expr (builtin_decl_explicit (BUILT_IN_OMP_GET_THREAD_NUM),\n+\t\t\t   0);\n       x = build2 (NE_EXPR, boolean_type_node, x,\n \t\t  build_int_cst (TREE_TYPE (x), 0));\n       x = build3 (COND_EXPR, void_type_node, x, copyin_seq, NULL);\n@@ -2688,12 +2689,14 @@ lower_reduction_clauses (tree clauses, gimple_seq *stmt_seqp, omp_context *ctx)\n \t}\n     }\n \n-  stmt = gimple_build_call (built_in_decls[BUILT_IN_GOMP_ATOMIC_START], 0);\n+  stmt = gimple_build_call (builtin_decl_explicit (BUILT_IN_GOMP_ATOMIC_START),\n+\t\t\t    0);\n   gimple_seq_add_stmt (stmt_seqp, stmt);\n \n   gimple_seq_add_seq (stmt_seqp, sub_seq);\n \n-  stmt = gimple_build_call (built_in_decls[BUILT_IN_GOMP_ATOMIC_END], 0);\n+  stmt = gimple_build_call (builtin_decl_explicit (BUILT_IN_GOMP_ATOMIC_END),\n+\t\t\t    0);\n   gimple_seq_add_stmt (stmt_seqp, stmt);\n }\n \n@@ -2917,7 +2920,8 @@ expand_parallel_call (struct omp_region *region, basic_block bb,\n   tree t, t1, t2, val, cond, c, clauses;\n   gimple_stmt_iterator gsi;\n   gimple stmt;\n-  int start_ix;\n+  enum built_in_function start_ix;\n+  int start_ix2;\n   location_t clause_loc;\n   VEC(tree,gc) *args;\n \n@@ -2932,10 +2936,11 @@ expand_parallel_call (struct omp_region *region, basic_block bb,\n \t{\n \tcase GIMPLE_OMP_FOR:\n \t  gcc_assert (region->inner->sched_kind != OMP_CLAUSE_SCHEDULE_AUTO);\n-\t  start_ix = BUILT_IN_GOMP_PARALLEL_LOOP_STATIC_START\n-\t\t     + (region->inner->sched_kind\n-\t\t\t== OMP_CLAUSE_SCHEDULE_RUNTIME\n-\t\t\t? 3 : region->inner->sched_kind);\n+\t  start_ix2 = ((int)BUILT_IN_GOMP_PARALLEL_LOOP_STATIC_START\n+\t\t       + (region->inner->sched_kind\n+\t\t\t  == OMP_CLAUSE_SCHEDULE_RUNTIME\n+\t\t\t  ? 3 : region->inner->sched_kind));\n+\t  start_ix = (enum built_in_function)start_ix2;\n \t  break;\n \tcase GIMPLE_OMP_SECTIONS:\n \t  start_ix = BUILT_IN_GOMP_PARALLEL_SECTIONS_START;\n@@ -3057,7 +3062,7 @@ expand_parallel_call (struct omp_region *region, basic_block bb,\n   VEC_splice (tree, args, ws_args);\n \n   t = build_call_expr_loc_vec (UNKNOWN_LOCATION,\n-\t\t\t       built_in_decls[start_ix], args);\n+\t\t\t       builtin_decl_explicit (start_ix), args);\n \n   force_gimple_operand_gsi (&gsi, t, true, NULL_TREE,\n \t\t\t    false, GSI_CONTINUE_LINKING);\n@@ -3073,7 +3078,8 @@ expand_parallel_call (struct omp_region *region, basic_block bb,\n \t\t\t    false, GSI_CONTINUE_LINKING);\n \n   t = build_call_expr_loc (gimple_location (entry_stmt),\n-\t\t\t   built_in_decls[BUILT_IN_GOMP_PARALLEL_END], 0);\n+\t\t\t   builtin_decl_explicit (BUILT_IN_GOMP_PARALLEL_END),\n+\t\t\t   0);\n   force_gimple_operand_gsi (&gsi, t, true, NULL_TREE,\n \t\t\t    false, GSI_CONTINUE_LINKING);\n }\n@@ -3125,7 +3131,8 @@ expand_task_call (basic_block bb, gimple entry_stmt)\n   else\n     t3 = build_fold_addr_expr_loc (loc, t);\n \n-  t = build_call_expr (built_in_decls[BUILT_IN_GOMP_TASK], 7, t1, t2, t3,\n+  t = build_call_expr (builtin_decl_explicit (BUILT_IN_GOMP_TASK),\n+\t\t       7, t1, t2, t3,\n \t\t       gimple_omp_task_arg_size (entry_stmt),\n \t\t       gimple_omp_task_arg_align (entry_stmt), cond, flags);\n \n@@ -3150,7 +3157,7 @@ maybe_catch_exception (gimple_seq body)\n   if (lang_hooks.eh_protect_cleanup_actions != NULL)\n     decl = lang_hooks.eh_protect_cleanup_actions ();\n   else\n-    decl = built_in_decls[BUILT_IN_TRAP];\n+    decl = builtin_decl_explicit (BUILT_IN_TRAP);\n \n   g = gimple_build_eh_must_not_throw (decl);\n   g = gimple_build_try (body, gimple_seq_alloc_with_stmt (g),\n@@ -3297,10 +3304,10 @@ optimize_omp_library_calls (gimple entry_stmt)\n {\n   basic_block bb;\n   gimple_stmt_iterator gsi;\n-  tree thr_num_id\n-    = DECL_ASSEMBLER_NAME (built_in_decls [BUILT_IN_OMP_GET_THREAD_NUM]);\n-  tree num_thr_id\n-    = DECL_ASSEMBLER_NAME (built_in_decls [BUILT_IN_OMP_GET_NUM_THREADS]);\n+  tree thr_num_tree = builtin_decl_explicit (BUILT_IN_OMP_GET_THREAD_NUM);\n+  tree thr_num_id = DECL_ASSEMBLER_NAME (thr_num_tree);\n+  tree num_thr_tree = builtin_decl_explicit (BUILT_IN_OMP_GET_NUM_THREADS);\n+  tree num_thr_id = DECL_ASSEMBLER_NAME (num_thr_tree);\n   bool untied_task = (gimple_code (entry_stmt) == GIMPLE_OMP_TASK\n \t\t      && find_omp_clause (gimple_omp_task_clauses (entry_stmt),\n \t\t\t\t\t  OMP_CLAUSE_UNTIED) != NULL);\n@@ -3325,10 +3332,10 @@ optimize_omp_library_calls (gimple entry_stmt)\n \t\t   during the execution of the task region.  */\n \t\tif (untied_task)\n \t\t  continue;\n-\t\tbuilt_in = built_in_decls [BUILT_IN_OMP_GET_THREAD_NUM];\n+\t\tbuilt_in = builtin_decl_explicit (BUILT_IN_OMP_GET_THREAD_NUM);\n \t      }\n \t    else if (DECL_NAME (decl) == num_thr_id)\n-\t      built_in = built_in_decls [BUILT_IN_OMP_GET_NUM_THREADS];\n+\t      built_in = builtin_decl_explicit (BUILT_IN_OMP_GET_NUM_THREADS);\n \t    else\n \t      continue;\n \n@@ -3812,7 +3819,7 @@ expand_omp_for_generic (struct omp_region *region,\n     {\n       /* In a combined parallel loop, emit a call to\n \t GOMP_loop_foo_next.  */\n-      t = build_call_expr (built_in_decls[next_fn], 2,\n+      t = build_call_expr (builtin_decl_explicit (next_fn), 2,\n \t\t\t   build_fold_addr_expr (istart0),\n \t\t\t   build_fold_addr_expr (iend0));\n     }\n@@ -3848,34 +3855,36 @@ expand_omp_for_generic (struct omp_region *region,\n \t  if (fd->chunk_size)\n \t    {\n \t      t = fold_convert (fd->iter_type, fd->chunk_size);\n-\t      t = build_call_expr (built_in_decls[start_fn], 6,\n-\t\t\t\t   t0, t1, t2, t, t3, t4);\n+\t      t = build_call_expr (builtin_decl_explicit (start_fn),\n+\t\t\t\t   6, t0, t1, t2, t, t3, t4);\n \t    }\n \t  else\n-\t    t = build_call_expr (built_in_decls[start_fn], 5,\n-\t\t\t\t t0, t1, t2, t3, t4);\n+\t    t = build_call_expr (builtin_decl_explicit (start_fn),\n+\t\t\t\t 5, t0, t1, t2, t3, t4);\n \t}\n       else\n \t{\n \t  tree t5;\n \t  tree c_bool_type;\n+\t  tree bfn_decl;\n \n \t  /* The GOMP_loop_ull_*start functions have additional boolean\n \t     argument, true for < loops and false for > loops.\n \t     In Fortran, the C bool type can be different from\n \t     boolean_type_node.  */\n-\t  c_bool_type = TREE_TYPE (TREE_TYPE (built_in_decls[start_fn]));\n+\t  bfn_decl = builtin_decl_explicit (start_fn);\n+\t  c_bool_type = TREE_TYPE (TREE_TYPE (bfn_decl));\n \t  t5 = build_int_cst (c_bool_type,\n \t\t\t      fd->loop.cond_code == LT_EXPR ? 1 : 0);\n \t  if (fd->chunk_size)\n \t    {\n+\t      tree bfn_decl = builtin_decl_explicit (start_fn);\n \t      t = fold_convert (fd->iter_type, fd->chunk_size);\n-\t      t = build_call_expr (built_in_decls[start_fn], 7,\n-\t\t\t\t   t5, t0, t1, t2, t, t3, t4);\n+\t      t = build_call_expr (bfn_decl, 7, t5, t0, t1, t2, t, t3, t4);\n \t    }\n \t  else\n-\t    t = build_call_expr (built_in_decls[start_fn], 6,\n-\t\t\t\t t5, t0, t1, t2, t3, t4);\n+\t    t = build_call_expr (builtin_decl_explicit (start_fn),\n+\t\t\t\t 6, t5, t0, t1, t2, t3, t4);\n \t}\n     }\n   if (TREE_TYPE (t) != boolean_type_node)\n@@ -4031,7 +4040,7 @@ expand_omp_for_generic (struct omp_region *region,\n       /* Emit code to get the next parallel iteration in L2_BB.  */\n       gsi = gsi_start_bb (l2_bb);\n \n-      t = build_call_expr (built_in_decls[next_fn], 2,\n+      t = build_call_expr (builtin_decl_explicit (next_fn), 2,\n \t\t\t   build_fold_addr_expr (istart0),\n \t\t\t   build_fold_addr_expr (iend0));\n       t = force_gimple_operand_gsi (&gsi, t, true, NULL_TREE,\n@@ -4046,9 +4055,9 @@ expand_omp_for_generic (struct omp_region *region,\n   /* Add the loop cleanup function.  */\n   gsi = gsi_last_bb (exit_bb);\n   if (gimple_omp_return_nowait_p (gsi_stmt (gsi)))\n-    t = built_in_decls[BUILT_IN_GOMP_LOOP_END_NOWAIT];\n+    t = builtin_decl_explicit (BUILT_IN_GOMP_LOOP_END_NOWAIT);\n   else\n-    t = built_in_decls[BUILT_IN_GOMP_LOOP_END];\n+    t = builtin_decl_explicit (BUILT_IN_GOMP_LOOP_END);\n   stmt = gimple_build_call (t, 0);\n   gsi_insert_after (&gsi, stmt, GSI_SAME_STMT);\n   gsi_remove (&gsi, true);\n@@ -4169,12 +4178,12 @@ expand_omp_for_static_nochunk (struct omp_region *region,\n   gsi = gsi_last_bb (entry_bb);\n   gcc_assert (gimple_code (gsi_stmt (gsi)) == GIMPLE_OMP_FOR);\n \n-  t = build_call_expr (built_in_decls[BUILT_IN_OMP_GET_NUM_THREADS], 0);\n+  t = build_call_expr (builtin_decl_explicit (BUILT_IN_OMP_GET_NUM_THREADS), 0);\n   t = fold_convert (itype, t);\n   nthreads = force_gimple_operand_gsi (&gsi, t, true, NULL_TREE,\n \t\t\t\t       true, GSI_SAME_STMT);\n \n-  t = build_call_expr (built_in_decls[BUILT_IN_OMP_GET_THREAD_NUM], 0);\n+  t = build_call_expr (builtin_decl_explicit (BUILT_IN_OMP_GET_THREAD_NUM), 0);\n   t = fold_convert (itype, t);\n   threadid = force_gimple_operand_gsi (&gsi, t, true, NULL_TREE,\n \t\t\t\t       true, GSI_SAME_STMT);\n@@ -4391,12 +4400,12 @@ expand_omp_for_static_chunk (struct omp_region *region, struct omp_for_data *fd)\n   si = gsi_last_bb (entry_bb);\n   gcc_assert (gimple_code (gsi_stmt (si)) == GIMPLE_OMP_FOR);\n \n-  t = build_call_expr (built_in_decls[BUILT_IN_OMP_GET_NUM_THREADS], 0);\n+  t = build_call_expr (builtin_decl_explicit (BUILT_IN_OMP_GET_NUM_THREADS), 0);\n   t = fold_convert (itype, t);\n   nthreads = force_gimple_operand_gsi (&si, t, true, NULL_TREE,\n \t\t\t\t       true, GSI_SAME_STMT);\n \n-  t = build_call_expr (built_in_decls[BUILT_IN_OMP_GET_THREAD_NUM], 0);\n+  t = build_call_expr (builtin_decl_explicit (BUILT_IN_OMP_GET_THREAD_NUM), 0);\n   t = fold_convert (itype, t);\n   threadid = force_gimple_operand_gsi (&si, t, true, NULL_TREE,\n \t\t\t\t       true, GSI_SAME_STMT);\n@@ -4658,14 +4667,14 @@ expand_omp_for (struct omp_region *region)\n       fn_index = (fd.sched_kind == OMP_CLAUSE_SCHEDULE_RUNTIME)\n \t\t  ? 3 : fd.sched_kind;\n       fn_index += fd.have_ordered * 4;\n-      start_ix = BUILT_IN_GOMP_LOOP_STATIC_START + fn_index;\n-      next_ix = BUILT_IN_GOMP_LOOP_STATIC_NEXT + fn_index;\n+      start_ix = ((int)BUILT_IN_GOMP_LOOP_STATIC_START) + fn_index;\n+      next_ix = ((int)BUILT_IN_GOMP_LOOP_STATIC_NEXT) + fn_index;\n       if (fd.iter_type == long_long_unsigned_type_node)\n \t{\n-\t  start_ix += BUILT_IN_GOMP_LOOP_ULL_STATIC_START\n-\t\t      - BUILT_IN_GOMP_LOOP_STATIC_START;\n-\t  next_ix += BUILT_IN_GOMP_LOOP_ULL_STATIC_NEXT\n-\t\t     - BUILT_IN_GOMP_LOOP_STATIC_NEXT;\n+\t  start_ix += ((int)BUILT_IN_GOMP_LOOP_ULL_STATIC_START\n+\t\t\t- (int)BUILT_IN_GOMP_LOOP_STATIC_START);\n+\t  next_ix += ((int)BUILT_IN_GOMP_LOOP_ULL_STATIC_NEXT\n+\t\t      - (int)BUILT_IN_GOMP_LOOP_STATIC_NEXT);\n \t}\n       expand_omp_for_generic (region, &fd, (enum built_in_function) start_ix,\n \t\t\t      (enum built_in_function) next_ix);\n@@ -4778,13 +4787,13 @@ expand_omp_sections (struct omp_region *region)\n \t call GOMP_sections_start.  */\n       t = build_int_cst (unsigned_type_node,\n \t\t\t exit_reachable ? len - 1 : len);\n-      u = built_in_decls[BUILT_IN_GOMP_SECTIONS_START];\n+      u = builtin_decl_explicit (BUILT_IN_GOMP_SECTIONS_START);\n       stmt = gimple_build_call (u, 1, t);\n     }\n   else\n     {\n       /* Otherwise, call GOMP_sections_next.  */\n-      u = built_in_decls[BUILT_IN_GOMP_SECTIONS_NEXT];\n+      u = builtin_decl_explicit (BUILT_IN_GOMP_SECTIONS_NEXT);\n       stmt = gimple_build_call (u, 0);\n     }\n   gimple_call_set_lhs (stmt, vin);\n@@ -4866,16 +4875,19 @@ expand_omp_sections (struct omp_region *region)\n   VEC_free (tree, heap, label_vec);\n \n   si = gsi_start_bb (default_bb);\n-  stmt = gimple_build_call (built_in_decls[BUILT_IN_TRAP], 0);\n+  stmt = gimple_build_call (builtin_decl_explicit (BUILT_IN_TRAP), 0);\n   gsi_insert_after (&si, stmt, GSI_CONTINUE_LINKING);\n \n   if (exit_reachable)\n     {\n+      tree bfn_decl;\n+\n       /* Code to get the next section goes in L1_BB.  */\n       si = gsi_last_bb (l1_bb);\n       gcc_assert (gimple_code (gsi_stmt (si)) == GIMPLE_OMP_CONTINUE);\n \n-      stmt = gimple_build_call (built_in_decls[BUILT_IN_GOMP_SECTIONS_NEXT], 0);\n+      bfn_decl = builtin_decl_explicit (BUILT_IN_GOMP_SECTIONS_NEXT);\n+      stmt = gimple_build_call (bfn_decl, 0);\n       gimple_call_set_lhs (stmt, vnext);\n       gsi_insert_after (&si, stmt, GSI_SAME_STMT);\n       gsi_remove (&si, true);\n@@ -4885,9 +4897,9 @@ expand_omp_sections (struct omp_region *region)\n       /* Cleanup function replaces GIMPLE_OMP_RETURN in EXIT_BB.  */\n       si = gsi_last_bb (l2_bb);\n       if (gimple_omp_return_nowait_p (gsi_stmt (si)))\n-\tt = built_in_decls[BUILT_IN_GOMP_SECTIONS_END_NOWAIT];\n+\tt = builtin_decl_explicit (BUILT_IN_GOMP_SECTIONS_END_NOWAIT);\n       else\n-\tt = built_in_decls[BUILT_IN_GOMP_SECTIONS_END];\n+\tt = builtin_decl_explicit (BUILT_IN_GOMP_SECTIONS_END);\n       stmt = gimple_build_call (t, 0);\n       gsi_insert_after (&si, stmt, GSI_SAME_STMT);\n       gsi_remove (&si, true);\n@@ -4995,7 +5007,7 @@ expand_omp_atomic_fetch_op (basic_block load_bb,\n \t\t\t    tree addr, tree loaded_val,\n \t\t\t    tree stored_val, int index)\n {\n-  enum built_in_function oldbase, newbase;\n+  enum built_in_function oldbase, newbase, tmpbase;\n   tree decl, itype, call;\n   direct_optab optab, oldoptab, newoptab;\n   tree lhs, rhs;\n@@ -5085,7 +5097,9 @@ expand_omp_atomic_fetch_op (basic_block load_bb,\n   else\n     return false;\n \n-  decl = built_in_decls[(need_new ? newbase : oldbase) + index + 1];\n+  tmpbase = ((enum built_in_function)\n+\t     ((need_new ? newbase : oldbase) + index + 1));\n+  decl = builtin_decl_explicit (tmpbase);\n   if (decl == NULL_TREE)\n     return false;\n   itype = TREE_TYPE (TREE_TYPE (decl));\n@@ -5166,8 +5180,11 @@ expand_omp_atomic_pipeline (basic_block load_bb, basic_block store_bb,\n   basic_block loop_header = single_succ (load_bb);\n   gimple phi, stmt;\n   edge e;\n+  enum built_in_function fncode;\n \n-  cmpxchg = built_in_decls[BUILT_IN_SYNC_VAL_COMPARE_AND_SWAP_N + index + 1];\n+  fncode = (enum built_in_function)((int)BUILT_IN_SYNC_VAL_COMPARE_AND_SWAP_N\n+\t\t\t\t    + index + 1);\n+  cmpxchg = builtin_decl_explicit (fncode);\n   if (cmpxchg == NULL_TREE)\n     return false;\n   type = TYPE_MAIN_VARIANT (TREE_TYPE (TREE_TYPE (addr)));\n@@ -5355,7 +5372,7 @@ expand_omp_atomic_mutex (basic_block load_bb, basic_block store_bb,\n   si = gsi_last_bb (load_bb);\n   gcc_assert (gimple_code (gsi_stmt (si)) == GIMPLE_OMP_ATOMIC_LOAD);\n \n-  t = built_in_decls[BUILT_IN_GOMP_ATOMIC_START];\n+  t = builtin_decl_explicit (BUILT_IN_GOMP_ATOMIC_START);\n   t = build_call_expr (t, 0);\n   force_gimple_operand_gsi (&si, t, true, NULL_TREE, true, GSI_SAME_STMT);\n \n@@ -5370,7 +5387,7 @@ expand_omp_atomic_mutex (basic_block load_bb, basic_block store_bb,\n \t\t\t      stored_val);\n   gsi_insert_before (&si, stmt, GSI_SAME_STMT);\n \n-  t = built_in_decls[BUILT_IN_GOMP_ATOMIC_END];\n+  t = builtin_decl_explicit (BUILT_IN_GOMP_ATOMIC_END);\n   t = build_call_expr (t, 0);\n   force_gimple_operand_gsi (&si, t, true, NULL_TREE, true, GSI_SAME_STMT);\n   gsi_remove (&si, true);\n@@ -5806,7 +5823,7 @@ lower_omp_single_simple (gimple single_stmt, gimple_seq *pre_p)\n   gimple call, cond;\n   tree lhs, decl;\n \n-  decl = built_in_decls[BUILT_IN_GOMP_SINGLE_START];\n+  decl = builtin_decl_explicit (BUILT_IN_GOMP_SINGLE_START);\n   lhs = create_tmp_var (TREE_TYPE (TREE_TYPE (decl)), NULL);\n   call = gimple_build_call (decl, 0);\n   gimple_call_set_lhs (call, lhs);\n@@ -5855,7 +5872,7 @@ lower_omp_single_simple (gimple single_stmt, gimple_seq *pre_p)\n static void\n lower_omp_single_copy (gimple single_stmt, gimple_seq *pre_p, omp_context *ctx)\n {\n-  tree ptr_type, t, l0, l1, l2;\n+  tree ptr_type, t, l0, l1, l2, bfn_decl;\n   gimple_seq copyin_seq;\n   location_t loc = gimple_location (single_stmt);\n \n@@ -5868,7 +5885,8 @@ lower_omp_single_copy (gimple single_stmt, gimple_seq *pre_p, omp_context *ctx)\n   l1 = create_artificial_label (loc);\n   l2 = create_artificial_label (loc);\n \n-  t = build_call_expr_loc (loc, built_in_decls[BUILT_IN_GOMP_SINGLE_COPY_START], 0);\n+  bfn_decl = builtin_decl_explicit (BUILT_IN_GOMP_SINGLE_COPY_START);\n+  t = build_call_expr_loc (loc, bfn_decl, 0);\n   t = fold_convert_loc (loc, ptr_type, t);\n   gimplify_assign (ctx->receiver_decl, t, pre_p);\n \n@@ -5887,8 +5905,8 @@ lower_omp_single_copy (gimple single_stmt, gimple_seq *pre_p, omp_context *ctx)\n \t\t\t      &copyin_seq, ctx);\n \n   t = build_fold_addr_expr_loc (loc, ctx->sender_decl);\n-  t = build_call_expr_loc (loc, built_in_decls[BUILT_IN_GOMP_SINGLE_COPY_END],\n-\t\t       1, t);\n+  bfn_decl = builtin_decl_explicit (BUILT_IN_GOMP_SINGLE_COPY_END);\n+  t = build_call_expr_loc (loc, bfn_decl, 1, t);\n   gimplify_and_add (t, pre_p);\n \n   t = build_and_jump (&l2);\n@@ -5955,7 +5973,7 @@ lower_omp_single (gimple_stmt_iterator *gsi_p, omp_context *ctx)\n static void\n lower_omp_master (gimple_stmt_iterator *gsi_p, omp_context *ctx)\n {\n-  tree block, lab = NULL, x;\n+  tree block, lab = NULL, x, bfn_decl;\n   gimple stmt = gsi_stmt (*gsi_p), bind;\n   location_t loc = gimple_location (stmt);\n   gimple_seq tseq;\n@@ -5967,7 +5985,8 @@ lower_omp_master (gimple_stmt_iterator *gsi_p, omp_context *ctx)\n   bind = gimple_build_bind (NULL, gimple_seq_alloc_with_stmt (stmt),\n       \t\t\t\t block);\n \n-  x = build_call_expr_loc (loc, built_in_decls[BUILT_IN_OMP_GET_THREAD_NUM], 0);\n+  bfn_decl = builtin_decl_explicit (BUILT_IN_OMP_GET_THREAD_NUM);\n+  x = build_call_expr_loc (loc, bfn_decl, 0);\n   x = build2 (EQ_EXPR, boolean_type_node, x, integer_zero_node);\n   x = build3 (COND_EXPR, void_type_node, x, NULL, build_and_jump (&lab));\n   tseq = NULL;\n@@ -6006,15 +6025,16 @@ lower_omp_ordered (gimple_stmt_iterator *gsi_p, omp_context *ctx)\n   bind = gimple_build_bind (NULL, gimple_seq_alloc_with_stmt (stmt),\n       \t\t\t\t   block);\n \n-  x = gimple_build_call (built_in_decls[BUILT_IN_GOMP_ORDERED_START], 0);\n+  x = gimple_build_call (builtin_decl_explicit (BUILT_IN_GOMP_ORDERED_START),\n+\t\t\t 0);\n   gimple_bind_add_stmt (bind, x);\n \n   lower_omp (gimple_omp_body (stmt), ctx);\n   gimple_omp_set_body (stmt, maybe_catch_exception (gimple_omp_body (stmt)));\n   gimple_bind_add_seq (bind, gimple_omp_body (stmt));\n   gimple_omp_set_body (stmt, NULL);\n \n-  x = gimple_build_call (built_in_decls[BUILT_IN_GOMP_ORDERED_END], 0);\n+  x = gimple_build_call (builtin_decl_explicit (BUILT_IN_GOMP_ORDERED_END), 0);\n   gimple_bind_add_stmt (bind, x);\n \n   gimple_bind_add_stmt (bind, gimple_build_omp_return (true));\n@@ -6080,19 +6100,19 @@ lower_omp_critical (gimple_stmt_iterator *gsi_p, omp_context *ctx)\n       else\n \tdecl = (tree) n->value;\n \n-      lock = built_in_decls[BUILT_IN_GOMP_CRITICAL_NAME_START];\n+      lock = builtin_decl_explicit (BUILT_IN_GOMP_CRITICAL_NAME_START);\n       lock = build_call_expr_loc (loc, lock, 1, build_fold_addr_expr_loc (loc, decl));\n \n-      unlock = built_in_decls[BUILT_IN_GOMP_CRITICAL_NAME_END];\n+      unlock = builtin_decl_explicit (BUILT_IN_GOMP_CRITICAL_NAME_END);\n       unlock = build_call_expr_loc (loc, unlock, 1,\n \t\t\t\tbuild_fold_addr_expr_loc (loc, decl));\n     }\n   else\n     {\n-      lock = built_in_decls[BUILT_IN_GOMP_CRITICAL_START];\n+      lock = builtin_decl_explicit (BUILT_IN_GOMP_CRITICAL_START);\n       lock = build_call_expr_loc (loc, lock, 0);\n \n-      unlock = built_in_decls[BUILT_IN_GOMP_CRITICAL_END];\n+      unlock = builtin_decl_explicit (BUILT_IN_GOMP_CRITICAL_END);\n       unlock = build_call_expr_loc (loc, unlock, 0);\n     }\n "}, {"sha": "e86f7ba7a4f6cd3fab033a4c1929e3d2c27ed075", "filename": "gcc/system.h", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e79983f458034c3061645a4c4ff83c9c4d9019b9/gcc%2Fsystem.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e79983f458034c3061645a4c4ff83c9c4d9019b9/gcc%2Fsystem.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsystem.h?ref=e79983f458034c3061645a4c4ff83c9c4d9019b9", "patch": "@@ -882,6 +882,9 @@ extern void fancy_abort (const char *, int, const char *) ATTRIBUTE_NORETURN;\n \tTARGET_HANDLE_OFAST TARGET_OPTION_OPTIMIZATION \\\n         TARGET_IRA_COVER_CLASSES TARGET_HELP\n \n+/* Arrays that were deleted in favor of a functional interface.  */\n+ #pragma GCC poison built_in_decls implicit_built_in_decls\n+\n /* Hooks into libgcc2.  */\n  #pragma GCC poison LIBGCC2_DOUBLE_TYPE_SIZE LIBGCC2_WORDS_BIG_ENDIAN \\\n    LIBGCC2_FLOAT_WORDS_BIG_ENDIAN"}, {"sha": "0547fcf147fd74aa5e58607a7089bdc470a1b551", "filename": "gcc/tree-complex.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e79983f458034c3061645a4c4ff83c9c4d9019b9/gcc%2Ftree-complex.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e79983f458034c3061645a4c4ff83c9c4d9019b9/gcc%2Ftree-complex.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-complex.c?ref=e79983f458034c3061645a4c4ff83c9c4d9019b9", "patch": "@@ -956,7 +956,7 @@ expand_complex_libcall (gimple_stmt_iterator *gsi, tree ar, tree ai,\n \t     (BUILT_IN_COMPLEX_DIV_MIN + mode - MIN_MODE_COMPLEX_FLOAT));\n   else\n     gcc_unreachable ();\n-  fn = built_in_decls[bcode];\n+  fn = builtin_decl_explicit (bcode);\n \n   stmt = gimple_build_call (fn, 4, ar, ai, br, bi);\n   gimple_call_set_lhs (stmt, lhs);"}, {"sha": "f751d8d98a2f8fffd5e9e77b0932616744d81ebc", "filename": "gcc/tree-eh.c", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e79983f458034c3061645a4c4ff83c9c4d9019b9/gcc%2Ftree-eh.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e79983f458034c3061645a4c4ff83c9c4d9019b9/gcc%2Ftree-eh.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-eh.c?ref=e79983f458034c3061645a4c4ff83c9c4d9019b9", "patch": "@@ -2934,7 +2934,7 @@ lower_resx (basic_block bb, gimple stmt, struct pointer_map_t *mnt_map)\n \n \t Resolve this by expanding the resx node to an abort.  */\n \n-      fn = implicit_built_in_decls[BUILT_IN_TRAP];\n+      fn = builtin_decl_implicit (BUILT_IN_TRAP);\n       x = gimple_build_call (fn, 0);\n       gsi_insert_before (&gsi, x, GSI_SAME_STMT);\n \n@@ -2991,7 +2991,7 @@ lower_resx (basic_block bb, gimple stmt, struct pointer_map_t *mnt_map)\n \t  edge_iterator ei;\n \t  tree dst_nr = build_int_cst (integer_type_node, dst_r->index);\n \n-\t  fn = implicit_built_in_decls[BUILT_IN_EH_COPY_VALUES];\n+\t  fn = builtin_decl_implicit (BUILT_IN_EH_COPY_VALUES);\n \t  src_nr = build_int_cst (integer_type_node, src_r->index);\n \t  x = gimple_build_call (fn, 2, dst_nr, src_nr);\n \t  gsi_insert_before (&gsi, x, GSI_SAME_STMT);\n@@ -3026,21 +3026,21 @@ lower_resx (basic_block bb, gimple stmt, struct pointer_map_t *mnt_map)\n \t with no arguments for C++ and Java.  Check for that.  */\n       if (src_r->use_cxa_end_cleanup)\n \t{\n-\t  fn = implicit_built_in_decls[BUILT_IN_CXA_END_CLEANUP];\n+\t  fn = builtin_decl_implicit (BUILT_IN_CXA_END_CLEANUP);\n \t  x = gimple_build_call (fn, 0);\n \t  gsi_insert_before (&gsi, x, GSI_SAME_STMT);\n \t}\n       else\n \t{\n-\t  fn = implicit_built_in_decls[BUILT_IN_EH_POINTER];\n+\t  fn = builtin_decl_implicit (BUILT_IN_EH_POINTER);\n \t  src_nr = build_int_cst (integer_type_node, src_r->index);\n \t  x = gimple_build_call (fn, 1, src_nr);\n \t  var = create_tmp_var (ptr_type_node, NULL);\n \t  var = make_ssa_name (var, x);\n \t  gimple_call_set_lhs (x, var);\n \t  gsi_insert_before (&gsi, x, GSI_SAME_STMT);\n \n-\t  fn = implicit_built_in_decls[BUILT_IN_UNWIND_RESUME];\n+\t  fn = builtin_decl_implicit (BUILT_IN_UNWIND_RESUME);\n \t  x = gimple_build_call (fn, 1, var);\n \t  gsi_insert_before (&gsi, x, GSI_SAME_STMT);\n \t}\n@@ -3206,7 +3206,7 @@ lower_eh_dispatch (basic_block src, gimple stmt)\n \t  }\n \telse\n \t  {\n-\t    fn = implicit_built_in_decls[BUILT_IN_EH_FILTER];\n+\t    fn = builtin_decl_implicit (BUILT_IN_EH_FILTER);\n \t    x = gimple_build_call (fn, 1, build_int_cst (integer_type_node,\n \t\t\t\t\t\t\t region_nr));\n \t    filter = create_tmp_var (TREE_TYPE (TREE_TYPE (fn)), NULL);\n@@ -3232,7 +3232,7 @@ lower_eh_dispatch (basic_block src, gimple stmt)\n \tedge b_e = BRANCH_EDGE (src);\n \tedge f_e = FALLTHRU_EDGE (src);\n \n-\tfn = implicit_built_in_decls[BUILT_IN_EH_FILTER];\n+\tfn = builtin_decl_implicit (BUILT_IN_EH_FILTER);\n \tx = gimple_build_call (fn, 1, build_int_cst (integer_type_node,\n \t\t\t\t\t\t     region_nr));\n \tfilter = create_tmp_var (TREE_TYPE (TREE_TYPE (fn)), NULL);"}, {"sha": "f046363c3d4933cff9b4a6af9ade4a81d067b08f", "filename": "gcc/tree-emutls.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e79983f458034c3061645a4c4ff83c9c4d9019b9/gcc%2Ftree-emutls.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e79983f458034c3061645a4c4ff83c9c4d9019b9/gcc%2Ftree-emutls.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-emutls.c?ref=e79983f458034c3061645a4c4ff83c9c4d9019b9", "patch": "@@ -387,8 +387,8 @@ emutls_common_1 (tree tls_decl, tree control_decl, tree *pstmts)\n \n   word_type_node = lang_hooks.types.type_for_mode (word_mode, 1);\n \n-  x = build_call_expr (built_in_decls[BUILT_IN_EMUTLS_REGISTER_COMMON], 4,\n-\t\t       build_fold_addr_expr (control_decl),\n+  x = build_call_expr (builtin_decl_explicit (BUILT_IN_EMUTLS_REGISTER_COMMON),\n+\t\t       4, build_fold_addr_expr (control_decl),\n \t\t       fold_convert (word_type_node,\n \t\t\t\t     DECL_SIZE_UNIT (tls_decl)),\n \t\t       build_int_cst (word_type_node,\n@@ -623,7 +623,7 @@ lower_emutls_function_body (struct cgraph_node *node)\n   push_cfun (DECL_STRUCT_FUNCTION (node->decl));\n \n   d.cfun_node = node;\n-  d.builtin_decl = built_in_decls[BUILT_IN_EMUTLS_GET_ADDRESS];\n+  d.builtin_decl = builtin_decl_explicit (BUILT_IN_EMUTLS_GET_ADDRESS);\n   /* This is where we introduce the declaration to the IL and so we have to\n      create a node for it.  */\n   d.builtin_node = cgraph_get_create_node (d.builtin_decl);"}, {"sha": "810b974b256d0cd1220c959b28cac5d4117e3576", "filename": "gcc/tree-loop-distribution.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e79983f458034c3061645a4c4ff83c9c4d9019b9/gcc%2Ftree-loop-distribution.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e79983f458034c3061645a4c4ff83c9c4d9019b9/gcc%2Ftree-loop-distribution.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-loop-distribution.c?ref=e79983f458034c3061645a4c4ff83c9c4d9019b9", "patch": "@@ -289,7 +289,7 @@ generate_memset_zero (gimple stmt, tree op0, tree nb_iter,\n   mem = force_gimple_operand (addr_base, &stmts, true, NULL);\n   gimple_seq_add_seq (&stmt_list, stmts);\n \n-  fn = build_fold_addr_expr (implicit_built_in_decls [BUILT_IN_MEMSET]);\n+  fn = build_fold_addr_expr (builtin_decl_implicit (BUILT_IN_MEMSET));\n   fn_call = gimple_build_call (fn, 3, mem, integer_zero_node, nb_bytes);\n   gimple_seq_add_stmt (&stmt_list, fn_call);\n   gsi_insert_seq_after (&bsi, stmt_list, GSI_CONTINUE_LINKING);"}, {"sha": "ae3a8dd609fd01795bd6b3236c41a98b9555ba67", "filename": "gcc/tree-nested.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e79983f458034c3061645a4c4ff83c9c4d9019b9/gcc%2Ftree-nested.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e79983f458034c3061645a4c4ff83c9c4d9019b9/gcc%2Ftree-nested.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-nested.c?ref=e79983f458034c3061645a4c4ff83c9c4d9019b9", "patch": "@@ -1811,8 +1811,8 @@ convert_nl_goto_reference (gimple_stmt_iterator *gsi, bool *handled_ops_p,\n   x = get_frame_field (info, target_context, field, &wi->gsi);\n   x = build_addr (x, target_context);\n   x = gsi_gimplify_val (info, x, &wi->gsi);\n-  call = gimple_build_call (implicit_built_in_decls[BUILT_IN_NONLOCAL_GOTO], 2,\n-\t\t\t    build_addr (new_label, target_context), x);\n+  call = gimple_build_call (builtin_decl_implicit (BUILT_IN_NONLOCAL_GOTO),\n+\t\t\t    2, build_addr (new_label, target_context), x);\n   gsi_replace (&wi->gsi, call, false);\n \n   /* We have handled all of STMT's operands, no need to keep going.  */\n@@ -1924,7 +1924,7 @@ convert_tramp_reference_op (tree *tp, int *walk_subtrees, void *data)\n \n       /* Do machine-specific ugliness.  Normally this will involve\n \t computing extra alignment, but it can really be anything.  */\n-      builtin = implicit_built_in_decls[BUILT_IN_ADJUST_TRAMPOLINE];\n+      builtin = builtin_decl_implicit (BUILT_IN_ADJUST_TRAMPOLINE);\n       call = gimple_build_call (builtin, 1, x);\n       x = init_tmp_var_with_call (info, &wi->gsi, call);\n \n@@ -2399,7 +2399,7 @@ finalize_nesting_tree_1 (struct nesting_info *root)\n \t\t      root->frame_decl, field, NULL_TREE);\n \t  arg1 = build_addr (x, context);\n \n-\t  x = implicit_built_in_decls[BUILT_IN_INIT_TRAMPOLINE];\n+\t  x = builtin_decl_implicit (BUILT_IN_INIT_TRAMPOLINE);\n \t  stmt = gimple_build_call (x, 3, arg1, arg2, arg3);\n \t  gimple_seq_add_stmt (&stmt_list, stmt);\n \t}"}, {"sha": "31c31c141c90bfeb052b73df76bba4c2bce350fd", "filename": "gcc/tree-ssa-ccp.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e79983f458034c3061645a4c4ff83c9c4d9019b9/gcc%2Ftree-ssa-ccp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e79983f458034c3061645a4c4ff83c9c4d9019b9/gcc%2Ftree-ssa-ccp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-ccp.c?ref=e79983f458034c3061645a4c4ff83c9c4d9019b9", "patch": "@@ -2175,7 +2175,7 @@ optimize_stdarg_builtin (gimple call)\n     case BUILT_IN_VA_START:\n       if (!va_list_simple_ptr\n \t  || targetm.expand_builtin_va_start != NULL\n-          || built_in_decls[BUILT_IN_NEXT_ARG] == NULL)\n+          || builtin_decl_explicit_p (BUILT_IN_NEXT_ARG))\n \treturn NULL_TREE;\n \n       if (gimple_call_num_args (call) != 2)\n@@ -2188,7 +2188,7 @@ optimize_stdarg_builtin (gimple call)\n \treturn NULL_TREE;\n \n       lhs = build_fold_indirect_ref_loc (loc, lhs);\n-      rhs = build_call_expr_loc (loc, built_in_decls[BUILT_IN_NEXT_ARG],\n+      rhs = build_call_expr_loc (loc, builtin_decl_explicit (BUILT_IN_NEXT_ARG),\n                              1, integer_zero_node);\n       rhs = fold_convert_loc (loc, TREE_TYPE (lhs), rhs);\n       return build2 (MODIFY_EXPR, TREE_TYPE (lhs), lhs, rhs);"}, {"sha": "1db93a65a65f434cf8ad6a42544306705652a9a2", "filename": "gcc/tree-ssa-forwprop.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e79983f458034c3061645a4c4ff83c9c4d9019b9/gcc%2Ftree-ssa-forwprop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e79983f458034c3061645a4c4ff83c9c4d9019b9/gcc%2Ftree-ssa-forwprop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-forwprop.c?ref=e79983f458034c3061645a4c4ff83c9c4d9019b9", "patch": "@@ -1595,7 +1595,8 @@ simplify_builtin_call (gimple_stmt_iterator *gsi_p, tree callee2)\n \t      if (!is_gimple_val (ptr1))\n \t\tptr1 = force_gimple_operand_gsi (gsi_p, ptr1, true, NULL_TREE,\n \t\t\t\t\t\t true, GSI_SAME_STMT);\n-\t      gimple_call_set_fndecl (stmt2, built_in_decls [BUILT_IN_MEMCPY]);\n+\t      gimple_call_set_fndecl (stmt2,\n+\t\t\t\t      builtin_decl_explicit (BUILT_IN_MEMCPY));\n \t      gimple_call_set_arg (stmt2, 0, ptr1);\n \t      gimple_call_set_arg (stmt2, 1, new_str_cst);\n \t      gimple_call_set_arg (stmt2, 2,"}, {"sha": "264d97bc1b57e248a0f6a4849380b1e275520762", "filename": "gcc/tree-ssa-loop-prefetch.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e79983f458034c3061645a4c4ff83c9c4d9019b9/gcc%2Ftree-ssa-loop-prefetch.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e79983f458034c3061645a4c4ff83c9c4d9019b9/gcc%2Ftree-ssa-loop-prefetch.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-prefetch.c?ref=e79983f458034c3061645a4c4ff83c9c4d9019b9", "patch": "@@ -1117,7 +1117,7 @@ issue_prefetch_ref (struct mem_ref *ref, unsigned unroll_factor, unsigned ahead)\n \t\t\t\t\t   NULL, true, GSI_SAME_STMT);\n       }\n       /* Create the prefetch instruction.  */\n-      prefetch = gimple_build_call (built_in_decls[BUILT_IN_PREFETCH],\n+      prefetch = gimple_build_call (builtin_decl_explicit (BUILT_IN_PREFETCH),\n \t\t\t\t    3, addr, write_p, local);\n       gsi_insert_before (&bsi, prefetch, GSI_SAME_STMT);\n     }\n@@ -1909,15 +1909,15 @@ tree_ssa_prefetch_arrays (void)\n \n   initialize_original_copy_tables ();\n \n-  if (!built_in_decls[BUILT_IN_PREFETCH])\n+  if (!builtin_decl_explicit_p (BUILT_IN_PREFETCH))\n     {\n       tree type = build_function_type_list (void_type_node,\n \t\t\t\t\t    const_ptr_type_node, NULL_TREE);\n       tree decl = add_builtin_function (\"__builtin_prefetch\", type,\n \t\t\t\t\tBUILT_IN_PREFETCH, BUILT_IN_NORMAL,\n \t\t\t\t\tNULL, NULL_TREE);\n       DECL_IS_NOVOPS (decl) = true;\n-      built_in_decls[BUILT_IN_PREFETCH] = decl;\n+      set_builtin_decl (BUILT_IN_PREFETCH, decl, false);\n     }\n \n   /* We assume that size of cache line is a power of two, so verify this"}, {"sha": "02d91ca8bbd9b25a5795ab8b59883f174cbc80e3", "filename": "gcc/tree-ssa-math-opts.c", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e79983f458034c3061645a4c4ff83c9c4d9019b9/gcc%2Ftree-ssa-math-opts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e79983f458034c3061645a4c4ff83c9c4d9019b9/gcc%2Ftree-ssa-math-opts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-math-opts.c?ref=e79983f458034c3061645a4c4ff83c9c4d9019b9", "patch": "@@ -1805,9 +1805,9 @@ execute_optimize_bswap (void)\n   if (sizeof (HOST_WIDEST_INT) < 8)\n     return 0;\n \n-  bswap32_p = (built_in_decls[BUILT_IN_BSWAP32]\n+  bswap32_p = (builtin_decl_explicit_p (BUILT_IN_BSWAP32)\n \t       && optab_handler (bswap_optab, SImode) != CODE_FOR_nothing);\n-  bswap64_p = (built_in_decls[BUILT_IN_BSWAP64]\n+  bswap64_p = (builtin_decl_explicit_p (BUILT_IN_BSWAP64)\n \t       && (optab_handler (bswap_optab, DImode) != CODE_FOR_nothing\n \t\t   || (bswap32_p && word_mode == SImode)));\n \n@@ -1818,13 +1818,13 @@ execute_optimize_bswap (void)\n      assumes that the return and argument type are the same.  */\n   if (bswap32_p)\n     {\n-      tree fndecl = built_in_decls[BUILT_IN_BSWAP32];\n+      tree fndecl = builtin_decl_explicit (BUILT_IN_BSWAP32);\n       bswap32_type = TREE_VALUE (TYPE_ARG_TYPES (TREE_TYPE (fndecl)));\n     }\n \n   if (bswap64_p)\n     {\n-      tree fndecl = built_in_decls[BUILT_IN_BSWAP64];\n+      tree fndecl = builtin_decl_explicit (BUILT_IN_BSWAP64);\n       bswap64_type = TREE_VALUE (TYPE_ARG_TYPES (TREE_TYPE (fndecl)));\n     }\n \n@@ -1858,14 +1858,14 @@ execute_optimize_bswap (void)\n \t    case 32:\n \t      if (bswap32_p)\n \t\t{\n-\t\t  fndecl = built_in_decls[BUILT_IN_BSWAP32];\n+\t\t  fndecl = builtin_decl_explicit (BUILT_IN_BSWAP32);\n \t\t  bswap_type = bswap32_type;\n \t\t}\n \t      break;\n \t    case 64:\n \t      if (bswap64_p)\n \t\t{\n-\t\t  fndecl = built_in_decls[BUILT_IN_BSWAP64];\n+\t\t  fndecl = builtin_decl_explicit (BUILT_IN_BSWAP64);\n \t\t  bswap_type = bswap64_type;\n \t\t}\n \t      break;"}, {"sha": "697340f535aaa2b77d1e19fd473126a93c84e25f", "filename": "gcc/tree-ssa-strlen.c", "status": "modified", "additions": 15, "deletions": 18, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e79983f458034c3061645a4c4ff83c9c4d9019b9/gcc%2Ftree-ssa-strlen.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e79983f458034c3061645a4c4ff83c9c4d9019b9/gcc%2Ftree-ssa-strlen.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-strlen.c?ref=e79983f458034c3061645a4c4ff83c9c4d9019b9", "patch": "@@ -397,7 +397,7 @@ get_string_length (strinfo si)\n       callee = gimple_call_fndecl (stmt);\n       gcc_assert (callee && DECL_BUILT_IN_CLASS (callee) == BUILT_IN_NORMAL);\n       lhs = gimple_call_lhs (stmt);\n-      gcc_assert (implicit_built_in_decls[BUILT_IN_STRCPY] != NULL_TREE);\n+      gcc_assert (builtin_decl_implicit_p (BUILT_IN_STRCPY));\n       /* unshare_strinfo is intentionally not called here.  The (delayed)\n \t transformation of strcpy or strcat into stpcpy is done at the place\n \t of the former strcpy/strcat call and so can affect all the strinfos\n@@ -409,7 +409,7 @@ get_string_length (strinfo si)\n \tcase BUILT_IN_STRCAT:\n \tcase BUILT_IN_STRCAT_CHK:\n \t  gsi = gsi_for_stmt (stmt);\n-\t  fn = implicit_built_in_decls[BUILT_IN_STRLEN];\n+\t  fn = builtin_decl_implicit (BUILT_IN_STRLEN);\n \t  gcc_assert (lhs == NULL_TREE);\n \t  lhs_var = create_tmp_var (TREE_TYPE (TREE_TYPE (fn)), NULL);\n \t  add_referenced_var (lhs_var);\n@@ -434,9 +434,9 @@ get_string_length (strinfo si)\n \tcase BUILT_IN_STRCPY:\n \tcase BUILT_IN_STRCPY_CHK:\n \t  if (gimple_call_num_args (stmt) == 2)\n-\t    fn = implicit_built_in_decls[BUILT_IN_STPCPY];\n+\t    fn = builtin_decl_implicit (BUILT_IN_STPCPY);\n \t  else\n-\t    fn = built_in_decls[BUILT_IN_STPCPY_CHK];\n+\t    fn = builtin_decl_explicit (BUILT_IN_STPCPY_CHK);\n \t  gcc_assert (lhs == NULL_TREE);\n \t  if (dump_file && (dump_flags & TDF_DETAILS) != 0)\n \t    {\n@@ -1070,8 +1070,7 @@ handle_builtin_strcpy (enum built_in_function bcode, gimple_stmt_iterator *gsi)\n       {\n       case BUILT_IN_STRCPY:\n       case BUILT_IN_STRCPY_CHK:\n-\tif (implicit_built_in_decls[BUILT_IN_STPCPY] == NULL_TREE\n-\t    || lhs != NULL_TREE)\n+\tif (lhs != NULL_TREE || !builtin_decl_implicit_p (BUILT_IN_STPCPY))\n \t  return;\n \tbreak;\n       case BUILT_IN_STPCPY:\n@@ -1154,20 +1153,20 @@ handle_builtin_strcpy (enum built_in_function bcode, gimple_stmt_iterator *gsi)\n   switch (bcode)\n     {\n     case BUILT_IN_STRCPY:\n-      fn = implicit_built_in_decls[BUILT_IN_MEMCPY];\n+      fn = builtin_decl_implicit (BUILT_IN_MEMCPY);\n       if (lhs)\n \tVEC_replace (int, ssa_ver_to_stridx, SSA_NAME_VERSION (lhs), didx);\n       break;\n     case BUILT_IN_STRCPY_CHK:\n-      fn = built_in_decls[BUILT_IN_MEMCPY_CHK];\n+      fn = builtin_decl_explicit (BUILT_IN_MEMCPY_CHK);\n       if (lhs)\n \tVEC_replace (int, ssa_ver_to_stridx, SSA_NAME_VERSION (lhs), didx);\n       break;\n     case BUILT_IN_STPCPY:\n       /* This would need adjustment of the lhs (subtract one),\n \t or detection that the trailing '\\0' doesn't need to be\n \t written, if it will be immediately overwritten.\n-      fn = built_in_decls[BUILT_IN_MEMPCPY];  */\n+      fn = builtin_decl_explicit (BUILT_IN_MEMPCPY);  */\n       if (lhs)\n \t{\n \t  dsi->endptr = lhs;\n@@ -1178,7 +1177,7 @@ handle_builtin_strcpy (enum built_in_function bcode, gimple_stmt_iterator *gsi)\n       /* This would need adjustment of the lhs (subtract one),\n \t or detection that the trailing '\\0' doesn't need to be\n \t written, if it will be immediately overwritten.\n-      fn = built_in_decls[BUILT_IN_MEMPCPY_CHK];  */\n+      fn = builtin_decl_explicit (BUILT_IN_MEMPCPY_CHK);  */\n       if (lhs)\n \t{\n \t  dsi->endptr = lhs;\n@@ -1400,8 +1399,7 @@ handle_builtin_strcat (enum built_in_function bcode, gimple_stmt_iterator *gsi)\n \t with length endptr - p if we need to compute the length\n \t later on.  Don't do this transformation if we don't need\n \t it.  */\n-      if (implicit_built_in_decls[BUILT_IN_STPCPY] != NULL_TREE\n-\t  && lhs == NULL_TREE)\n+      if (builtin_decl_implicit_p (BUILT_IN_STPCPY) && lhs == NULL_TREE)\n \t{\n \t  if (didx == 0)\n \t    {\n@@ -1460,8 +1458,7 @@ handle_builtin_strcat (enum built_in_function bcode, gimple_stmt_iterator *gsi)\n   else\n     {\n       dsi->length = NULL;\n-      if (implicit_built_in_decls[BUILT_IN_STPCPY] != NULL_TREE\n-\t  && lhs == NULL_TREE)\n+      if (lhs == NULL_TREE && builtin_decl_implicit_p (BUILT_IN_STPCPY))\n \tdsi->dont_invalidate = true;\n     }\n \n@@ -1481,15 +1478,15 @@ handle_builtin_strcat (enum built_in_function bcode, gimple_stmt_iterator *gsi)\n     {\n     case BUILT_IN_STRCAT:\n       if (srclen != NULL_TREE)\n-\tfn = implicit_built_in_decls[BUILT_IN_MEMCPY];\n+\tfn = builtin_decl_implicit (BUILT_IN_MEMCPY);\n       else\n-\tfn = implicit_built_in_decls[BUILT_IN_STRCPY];\n+\tfn = builtin_decl_implicit (BUILT_IN_STRCPY);\n       break;\n     case BUILT_IN_STRCAT_CHK:\n       if (srclen != NULL_TREE)\n-\tfn = built_in_decls[BUILT_IN_MEMCPY_CHK];\n+\tfn = builtin_decl_explicit (BUILT_IN_MEMCPY_CHK);\n       else\n-\tfn = built_in_decls[BUILT_IN_STRCPY_CHK];\n+\tfn = builtin_decl_explicit (BUILT_IN_STRCPY_CHK);\n       objsz = gimple_call_arg (stmt, 2);\n       break;\n     default:"}, {"sha": "db2bb3764325d7874d0de21abf909571d66f6602", "filename": "gcc/tree-streamer-in.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e79983f458034c3061645a4c4ff83c9c4d9019b9/gcc%2Ftree-streamer-in.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e79983f458034c3061645a4c4ff83c9c4d9019b9/gcc%2Ftree-streamer-in.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-streamer-in.c?ref=e79983f458034c3061645a4c4ff83c9c4d9019b9", "patch": "@@ -1049,7 +1049,7 @@ streamer_get_builtin_tree (struct lto_input_block *ib, struct data_in *data_in)\n     {\n       if (fcode >= END_BUILTINS)\n \tfatal_error (\"machine independent builtin code out of range\");\n-      result = built_in_decls[fcode];\n+      result = builtin_decl_explicit (fcode);\n       gcc_assert (result);\n     }\n   else if (fclass == BUILT_IN_MD)"}, {"sha": "64c4968857585037f05f8a98a5ea0c52852f1ddf", "filename": "gcc/tree.c", "status": "modified", "additions": 20, "deletions": 22, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e79983f458034c3061645a4c4ff83c9c4d9019b9/gcc%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e79983f458034c3061645a4c4ff83c9c4d9019b9/gcc%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.c?ref=e79983f458034c3061645a4c4ff83c9c4d9019b9", "patch": "@@ -4656,10 +4656,9 @@ free_lang_data_in_decl (tree decl)\n            && DECL_INITIAL (decl)\n            && TREE_CODE (DECL_INITIAL (decl)) == BLOCK)\n     {\n-      /* Strip builtins from the translation-unit BLOCK.  We still have\n-\t targets without builtin_decl support and also builtins are\n-\t shared nodes and thus we can't use TREE_CHAIN in multiple\n-\t lists.  */\n+      /* Strip builtins from the translation-unit BLOCK.  We still have targets\n+\t without builtin_decl_explicit support and also builtins are shared\n+\t nodes and thus we can't use TREE_CHAIN in multiple lists.  */\n       tree *nextp = &BLOCK_VARS (DECL_INITIAL (decl));\n       while (*nextp)\n         {\n@@ -6942,9 +6941,9 @@ iterative_hash_expr (const_tree t, hashval_t val)\n \t or front end builtins, since the function code is overloaded in those\n \t cases.  */\n       if (DECL_BUILT_IN_CLASS (t) == BUILT_IN_NORMAL\n-\t  && built_in_decls[DECL_FUNCTION_CODE (t)])\n+\t  && builtin_decl_explicit_p (DECL_FUNCTION_CODE (t)))\n \t{\n-\t  t = built_in_decls[DECL_FUNCTION_CODE (t)];\n+\t  t = builtin_decl_explicit (DECL_FUNCTION_CODE (t));\n \t  code = TREE_CODE (t);\n \t}\n       /* FALL THROUGH */\n@@ -9429,8 +9428,7 @@ local_define_builtin (const char *name, tree type, enum built_in_function code,\n     DECL_ATTRIBUTES (decl) = tree_cons (get_identifier (\"leaf\"),\n \t\t\t\t\tNULL, DECL_ATTRIBUTES (decl));\n \n-  built_in_decls[code] = decl;\n-  implicit_built_in_decls[code] = decl;\n+  set_builtin_decl (code, decl, true);\n }\n \n /* Call this function after instantiating all builtins that the language\n@@ -9442,22 +9440,22 @@ build_common_builtin_nodes (void)\n {\n   tree tmp, ftype;\n \n-  if (built_in_decls[BUILT_IN_MEMCPY] == NULL\n-      || built_in_decls[BUILT_IN_MEMMOVE] == NULL)\n+  if (!builtin_decl_explicit_p (BUILT_IN_MEMCPY)\n+      || !builtin_decl_explicit_p (BUILT_IN_MEMMOVE))\n     {\n       ftype = build_function_type_list (ptr_type_node,\n \t\t\t\t\tptr_type_node, const_ptr_type_node,\n \t\t\t\t\tsize_type_node, NULL_TREE);\n \n-      if (built_in_decls[BUILT_IN_MEMCPY] == NULL)\n+      if (!builtin_decl_explicit_p (BUILT_IN_MEMCPY))\n \tlocal_define_builtin (\"__builtin_memcpy\", ftype, BUILT_IN_MEMCPY,\n \t\t\t      \"memcpy\", ECF_NOTHROW | ECF_LEAF);\n-      if (built_in_decls[BUILT_IN_MEMMOVE] == NULL)\n+      if (!builtin_decl_explicit_p (BUILT_IN_MEMMOVE))\n \tlocal_define_builtin (\"__builtin_memmove\", ftype, BUILT_IN_MEMMOVE,\n \t\t\t      \"memmove\", ECF_NOTHROW | ECF_LEAF);\n     }\n \n-  if (built_in_decls[BUILT_IN_MEMCMP] == NULL)\n+  if (!builtin_decl_explicit_p (BUILT_IN_MEMCMP))\n     {\n       ftype = build_function_type_list (integer_type_node, const_ptr_type_node,\n \t\t\t\t\tconst_ptr_type_node, size_type_node,\n@@ -9466,7 +9464,7 @@ build_common_builtin_nodes (void)\n \t\t\t    \"memcmp\", ECF_PURE | ECF_NOTHROW | ECF_LEAF);\n     }\n \n-  if (built_in_decls[BUILT_IN_MEMSET] == NULL)\n+  if (!builtin_decl_explicit_p (BUILT_IN_MEMSET))\n     {\n       ftype = build_function_type_list (ptr_type_node,\n \t\t\t\t\tptr_type_node, integer_type_node,\n@@ -9475,7 +9473,7 @@ build_common_builtin_nodes (void)\n \t\t\t    \"memset\", ECF_NOTHROW | ECF_LEAF);\n     }\n \n-  if (built_in_decls[BUILT_IN_ALLOCA] == NULL)\n+  if (!builtin_decl_explicit_p (BUILT_IN_ALLOCA))\n     {\n       ftype = build_function_type_list (ptr_type_node,\n \t\t\t\t\tsize_type_node, NULL_TREE);\n@@ -9492,8 +9490,8 @@ build_common_builtin_nodes (void)\n   /* If we're checking the stack, `alloca' can throw.  */\n   if (flag_stack_check)\n     {\n-      TREE_NOTHROW (built_in_decls[BUILT_IN_ALLOCA]) = 0;\n-      TREE_NOTHROW (built_in_decls[BUILT_IN_ALLOCA_WITH_ALIGN]) = 0;\n+      TREE_NOTHROW (builtin_decl_explicit (BUILT_IN_ALLOCA)) = 0;\n+      TREE_NOTHROW (builtin_decl_explicit (BUILT_IN_ALLOCA_WITH_ALIGN)) = 0;\n     }\n \n   ftype = build_function_type_list (void_type_node,\n@@ -9560,7 +9558,7 @@ build_common_builtin_nodes (void)\n \t\t\t ? \"_Unwind_SjLj_Resume\" : \"_Unwind_Resume\"),\n \t\t\tECF_NORETURN);\n \n-  if (built_in_decls[BUILT_IN_RETURN_ADDRESS] == NULL_TREE)\n+  if (builtin_decl_explicit (BUILT_IN_RETURN_ADDRESS) == NULL_TREE)\n     {\n       ftype = build_function_type_list (ptr_type_node, integer_type_node,\n \t\t\t\t\tNULL_TREE);\n@@ -9570,16 +9568,16 @@ build_common_builtin_nodes (void)\n \t\t\t    ECF_NOTHROW);\n     }\n \n-  if (built_in_decls[BUILT_IN_PROFILE_FUNC_ENTER] == NULL_TREE\n-      || built_in_decls[BUILT_IN_PROFILE_FUNC_EXIT] == NULL_TREE)\n+  if (!builtin_decl_explicit_p (BUILT_IN_PROFILE_FUNC_ENTER)\n+      || !builtin_decl_explicit_p (BUILT_IN_PROFILE_FUNC_EXIT))\n     {\n       ftype = build_function_type_list (void_type_node, ptr_type_node,\n \t\t\t\t\tptr_type_node, NULL_TREE);\n-      if (built_in_decls[BUILT_IN_PROFILE_FUNC_ENTER] == NULL_TREE)\n+      if (!builtin_decl_explicit_p (BUILT_IN_PROFILE_FUNC_ENTER))\n \tlocal_define_builtin (\"__cyg_profile_func_enter\", ftype,\n \t\t\t      BUILT_IN_PROFILE_FUNC_ENTER,\n \t\t\t      \"__cyg_profile_func_enter\", 0);\n-      if (built_in_decls[BUILT_IN_PROFILE_FUNC_EXIT] == NULL_TREE)\n+      if (!builtin_decl_explicit_p (BUILT_IN_PROFILE_FUNC_EXIT))\n \tlocal_define_builtin (\"__cyg_profile_func_exit\", ftype,\n \t\t\t      BUILT_IN_PROFILE_FUNC_EXIT,\n \t\t\t      \"__cyg_profile_func_exit\", 0);"}, {"sha": "18fdd07fe4eaf6dc190db1db7a48064ff44384ff", "filename": "gcc/tree.h", "status": "modified", "additions": 90, "deletions": 4, "changes": 94, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e79983f458034c3061645a4c4ff83c9c4d9019b9/gcc%2Ftree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e79983f458034c3061645a4c4ff83c9c4d9019b9/gcc%2Ftree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.h?ref=e79983f458034c3061645a4c4ff83c9c4d9019b9", "patch": "@@ -335,10 +335,6 @@ extern const char * built_in_names[(int) END_BUILTINS];\n #define CASE_FLT_FN(FN) case FN: case FN##F: case FN##L\n #define CASE_FLT_FN_REENT(FN) case FN##_R: case FN##F_R: case FN##L_R\n #define CASE_INT_FN(FN) case FN: case FN##L: case FN##LL\n-\n-/* An array of _DECL trees for the above.  */\n-extern GTY(()) tree built_in_decls[(int) END_BUILTINS];\n-extern GTY(()) tree implicit_built_in_decls[(int) END_BUILTINS];\n \f\n /* In an OMP_CLAUSE node.  */\n \n@@ -5918,4 +5914,94 @@ is_lang_specific (tree t)\n /* In gimple-low.c.  */\n extern bool block_may_fallthru (const_tree);\n \n+\f\n+/* Functional interface to the builtin functions.  */\n+\n+/* The builtin_info structure holds the FUNCTION_DECL of the standard builtin\n+   function, and a flag that says if the function is available implicitly, or\n+   whether the user has to code explicit calls to __builtin_<xxx>.  */\n+\n+typedef struct GTY(()) builtin_info_type_d {\n+  tree decl[(int)END_BUILTINS];\n+  bool implicit_p[(int)END_BUILTINS];\n+} builtin_info_type;\n+\n+extern GTY(()) builtin_info_type builtin_info;\n+\n+/* Valid builtin number.  */\n+#define BUILTIN_VALID_P(FNCODE) \\\n+  (IN_RANGE ((int)FNCODE, ((int)BUILT_IN_NONE) + 1, ((int) END_BUILTINS) - 1))\n+\n+/* Return the tree node for an explicit standard builtin function or NULL.  */\n+static inline tree\n+builtin_decl_explicit (enum built_in_function fncode)\n+{\n+  gcc_checking_assert (BUILTIN_VALID_P (fncode));\n+\n+  return builtin_info.decl[(size_t)fncode];\n+}\n+\n+/* Return the tree node for an implicit builtin function or NULL.  */\n+static inline tree\n+builtin_decl_implicit (enum built_in_function fncode)\n+{\n+  size_t uns_fncode = (size_t)fncode;\n+  gcc_checking_assert (BUILTIN_VALID_P (fncode));\n+\n+  if (!builtin_info.implicit_p[uns_fncode])\n+    return NULL_TREE;\n+\n+  return builtin_info.decl[uns_fncode];\n+}\n+\n+/* Set explicit builtin function nodes and whether it is an implicit\n+   function.  */\n+\n+static inline void\n+set_builtin_decl (enum built_in_function fncode, tree decl, bool implicit_p)\n+{\n+  size_t ufncode = (size_t)fncode;\n+\n+  gcc_checking_assert (BUILTIN_VALID_P (fncode)\n+\t\t       && (decl != NULL_TREE || !implicit_p));\n+\n+  builtin_info.decl[ufncode] = decl;\n+  builtin_info.implicit_p[ufncode] = implicit_p;\n+}\n+\n+/* Set the implicit flag for a builtin function.  */\n+\n+static inline void\n+set_builtin_decl_implicit_p (enum built_in_function fncode, bool implicit_p)\n+{\n+  size_t uns_fncode = (size_t)fncode;\n+\n+  gcc_checking_assert (BUILTIN_VALID_P (fncode)\n+\t\t       && builtin_info.decl[uns_fncode] != NULL_TREE);\n+\n+  builtin_info.implicit_p[uns_fncode] = implicit_p;\n+}\n+\n+/* Return whether the standard builtin function can be used as an explicit\n+   function.  */\n+\n+static inline bool\n+builtin_decl_explicit_p (enum built_in_function fncode)\n+{\n+  gcc_checking_assert (BUILTIN_VALID_P (fncode));\n+  return (builtin_info.decl[(size_t)fncode] != NULL_TREE);\n+}\n+\n+/* Return whether the standard builtin function can be used implicitly.  */\n+\n+static inline bool\n+builtin_decl_implicit_p (enum built_in_function fncode)\n+{\n+  size_t uns_fncode = (size_t)fncode;\n+\n+  gcc_checking_assert (BUILTIN_VALID_P (fncode));\n+  return (builtin_info.decl[uns_fncode] != NULL_TREE\n+\t  && builtin_info.implicit_p[uns_fncode]);\n+}\n+\n #endif  /* GCC_TREE_H  */"}]}