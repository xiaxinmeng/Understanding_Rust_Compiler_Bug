{"sha": "b9faa3301c523c2c165387da4b19e659f7362a92", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjlmYWEzMzAxYzUyM2MyYzE2NTM4N2RhNGIxOWU2NTlmNzM2MmE5Mg==", "commit": {"author": {"name": "Mike Crowe", "email": "mac@mcrowe.com", "date": "2020-09-11T13:25:00Z"}, "committer": {"name": "Jonathan Wakely", "email": "jwakely@redhat.com", "date": "2020-09-11T13:28:50Z"}, "message": "libstdc++: Loop when futex waits against arbitrary clock\n\nIf std::future::wait_until is passed a time point measured against a\nclock that is neither std::chrono::steady_clock nor\nstd::chrono::system_clock then the generic implementation of\n__atomic_futex_unsigned::_M_load_when_equal_until is called which\ncalculates the timeout based on __clock_t and calls the\n_M_load_when_equal_until method for that clock to perform the actual\nwait.\n\nThere's no guarantee that __clock_t is running at the same speed as the\ncaller's clock, so if the underlying wait times out timeout we need to\ncheck the timeout against the caller's clock again before potentially\nlooping.\n\nAlso add two extra tests to the testsuite's async.cc:\n\n* run test03 with steady_clock_copy, which behaves identically to\n  chrono::steady_clock, but isn't chrono::steady_clock. This causes\n  the overload of __atomic_futex_unsigned::_M_load_when_equal_until\n  that takes an arbitrary clock to be called.\n\n* invent test04 which uses a deliberately slow running clock in order\n  to exercise the looping behaviour of\n  __atomic_futex_unsigned::_M_load_when_equal_until described above.\n\nlibstdc++-v3/ChangeLog:\n\n\t* include/bits/atomic_futex.h\n\t(__atomic_futex_unsigned::_M_load_when_equal_until): Add\n\tloop on generic _Clock to check the timeout against _Clock\n\tagain after _M_load_when_equal_until returns indicating a\n\ttimeout.\n\t* testsuite/30_threads/async/async.cc: Invent slow_clock\n\tthat runs at an eleventh of steady_clock's speed. Use it\n\tto test the user-supplied-clock variant of\n\t__atomic_futex_unsigned::_M_load_when_equal_until works\n\tgenerally with test03 and loops correctly when the timeout\n\ttime hasn't been reached in test04.", "tree": {"sha": "fb1249738ad5942d228fd766eea59de654143ea3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/fb1249738ad5942d228fd766eea59de654143ea3"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b9faa3301c523c2c165387da4b19e659f7362a92", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b9faa3301c523c2c165387da4b19e659f7362a92", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b9faa3301c523c2c165387da4b19e659f7362a92", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b9faa3301c523c2c165387da4b19e659f7362a92/comments", "author": {"login": "mikecrowe", "id": 93615, "node_id": "MDQ6VXNlcjkzNjE1", "avatar_url": "https://avatars.githubusercontent.com/u/93615?v=4", "gravatar_id": "", "url": "https://api.github.com/users/mikecrowe", "html_url": "https://github.com/mikecrowe", "followers_url": "https://api.github.com/users/mikecrowe/followers", "following_url": "https://api.github.com/users/mikecrowe/following{/other_user}", "gists_url": "https://api.github.com/users/mikecrowe/gists{/gist_id}", "starred_url": "https://api.github.com/users/mikecrowe/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/mikecrowe/subscriptions", "organizations_url": "https://api.github.com/users/mikecrowe/orgs", "repos_url": "https://api.github.com/users/mikecrowe/repos", "events_url": "https://api.github.com/users/mikecrowe/events{/privacy}", "received_events_url": "https://api.github.com/users/mikecrowe/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jwakely", "id": 1254480, "node_id": "MDQ6VXNlcjEyNTQ0ODA=", "avatar_url": "https://avatars.githubusercontent.com/u/1254480?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jwakely", "html_url": "https://github.com/jwakely", "followers_url": "https://api.github.com/users/jwakely/followers", "following_url": "https://api.github.com/users/jwakely/following{/other_user}", "gists_url": "https://api.github.com/users/jwakely/gists{/gist_id}", "starred_url": "https://api.github.com/users/jwakely/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jwakely/subscriptions", "organizations_url": "https://api.github.com/users/jwakely/orgs", "repos_url": "https://api.github.com/users/jwakely/repos", "events_url": "https://api.github.com/users/jwakely/events{/privacy}", "received_events_url": "https://api.github.com/users/jwakely/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "87fce1923fcc8d6ef508500475c149082dc9d338", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/87fce1923fcc8d6ef508500475c149082dc9d338", "html_url": "https://github.com/Rust-GCC/gccrs/commit/87fce1923fcc8d6ef508500475c149082dc9d338"}], "stats": {"total": 85, "additions": 80, "deletions": 5}, "files": [{"sha": "5f95adeb361330dabe0f2a03387c8f9360a049ae", "filename": "libstdc++-v3/include/bits/atomic_futex.h", "status": "modified", "additions": 10, "deletions": 5, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b9faa3301c523c2c165387da4b19e659f7362a92/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fatomic_futex.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b9faa3301c523c2c165387da4b19e659f7362a92/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fatomic_futex.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fatomic_futex.h?ref=b9faa3301c523c2c165387da4b19e659f7362a92", "patch": "@@ -229,11 +229,16 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       _M_load_when_equal_until(unsigned __val, memory_order __mo,\n \t  const chrono::time_point<_Clock, _Duration>& __atime)\n       {\n-\tconst typename _Clock::time_point __c_entry = _Clock::now();\n-\tconst __clock_t::time_point __s_entry = __clock_t::now();\n-\tconst auto __delta = __atime - __c_entry;\n-\tconst auto __s_atime = __s_entry + __delta;\n-\treturn _M_load_when_equal_until(__val, __mo, __s_atime);\n+\ttypename _Clock::time_point __c_entry = _Clock::now();\n+\tdo {\n+\t  const __clock_t::time_point __s_entry = __clock_t::now();\n+\t  const auto __delta = __atime - __c_entry;\n+\t  const auto __s_atime = __s_entry + __delta;\n+\t  if (_M_load_when_equal_until(__val, __mo, __s_atime))\n+\t    return true;\n+\t  __c_entry = _Clock::now();\n+\t} while (__c_entry < __atime);\n+\treturn false;\n       }\n \n     // Returns false iff a timeout occurred."}, {"sha": "31e9686fab27b4fbabf59704b4fbd6ac2f3f94f2", "filename": "libstdc++-v3/testsuite/30_threads/async/async.cc", "status": "modified", "additions": 70, "deletions": 0, "changes": 70, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b9faa3301c523c2c165387da4b19e659f7362a92/libstdc%2B%2B-v3%2Ftestsuite%2F30_threads%2Fasync%2Fasync.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b9faa3301c523c2c165387da4b19e659f7362a92/libstdc%2B%2B-v3%2Ftestsuite%2F30_threads%2Fasync%2Fasync.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F30_threads%2Fasync%2Fasync.cc?ref=b9faa3301c523c2c165387da4b19e659f7362a92", "patch": "@@ -62,6 +62,24 @@ void test02()\n   VERIFY( status == std::future_status::ready );\n }\n \n+// This clock behaves exactly the same as steady_clock, but it is not\n+// steady_clock which means that the generic clock overload of\n+// future::wait_until is used.\n+struct steady_clock_copy\n+{\n+  using rep = std::chrono::steady_clock::rep;\n+  using period = std::chrono::steady_clock::period;\n+  using duration = std::chrono::steady_clock::duration;\n+  using time_point = std::chrono::time_point<steady_clock_copy, duration>;\n+  static constexpr bool is_steady = true;\n+\n+  static time_point now()\n+  {\n+    const auto steady = std::chrono::steady_clock::now();\n+    return time_point{steady.time_since_epoch()};\n+  }\n+};\n+\n // This test is prone to failures if run on a loaded machine where the\n // kernel decides not to schedule us for several seconds. It also\n // assumes that no-one will warp CLOCK whilst the test is\n@@ -89,11 +107,63 @@ void test03()\n   VERIFY( elapsed < std::chrono::seconds(5) );\n }\n \n+// This clock is supposed to run at a tenth of normal speed, but we\n+// don't have to worry about rounding errors causing us to wake up\n+// slightly too early below if we actually run it at an eleventh of\n+// normal speed. It is used to exercise the\n+// __atomic_futex_unsigned::_M_load_when_equal_until overload that\n+// takes an arbitrary clock.\n+struct slow_clock\n+{\n+  using rep = std::chrono::steady_clock::rep;\n+  using period = std::chrono::steady_clock::period;\n+  using duration = std::chrono::steady_clock::duration;\n+  using time_point = std::chrono::time_point<slow_clock, duration>;\n+  static constexpr bool is_steady = true;\n+\n+  static time_point now()\n+  {\n+    const auto steady = std::chrono::steady_clock::now();\n+    return time_point{steady.time_since_epoch() / 11};\n+  }\n+};\n+\n+void test04()\n+{\n+  using namespace std::chrono;\n+\n+  auto const slow_start = slow_clock::now();\n+  future<void> f1 = async(launch::async, []() {\n+      std::this_thread::sleep_for(std::chrono::seconds(2));\n+    });\n+\n+  // Wait for ~1s\n+  {\n+    auto const steady_begin = steady_clock::now();\n+    auto const status = f1.wait_until(slow_start + milliseconds(100));\n+    VERIFY(status == std::future_status::timeout);\n+    auto const elapsed = steady_clock::now() - steady_begin;\n+    VERIFY(elapsed >= seconds(1));\n+    VERIFY(elapsed < seconds(2));\n+  }\n+\n+  // Wait for up to ~2s more\n+  {\n+    auto const steady_begin = steady_clock::now();\n+    auto const status = f1.wait_until(slow_start + milliseconds(300));\n+    VERIFY(status == std::future_status::ready);\n+    auto const elapsed = steady_clock::now() - steady_begin;\n+    VERIFY(elapsed < seconds(2));\n+  }\n+}\n+\n int main()\n {\n   test01();\n   test02();\n   test03<std::chrono::system_clock>();\n   test03<std::chrono::steady_clock>();\n+  test03<steady_clock_copy>();\n+  test04();\n   return 0;\n }"}]}