{"sha": "6822a10d9d8a0f9635e88624fb12ff34653e47a2", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NjgyMmExMGQ5ZDhhMGY5NjM1ZTg4NjI0ZmIxMmZmMzQ2NTNlNDdhMg==", "commit": {"author": {"name": "Roger Sayle", "email": "roger@eyesopen.com", "date": "2006-12-20T17:23:43Z"}, "committer": {"name": "Roger Sayle", "email": "sayle@gcc.gnu.org", "date": "2006-12-20T17:23:43Z"}, "message": "trans-expr.c (is_zero_initializer_p): Determine whether a given constant expression is a zero initializer.\n\n\n\t* trans-expr.c (is_zero_initializer_p): Determine whether a given\n\tconstant expression is a zero initializer.\n\t(gfc_trans_zero_assign): New function to attempt to optimize\n\t\"a(:) = 0.0\" as a call to __builtin_memset (a, 0, sizeof(a));\n\t(gfc_trans_assignment): Special case array assignments to a\n\tzero initializer constant, using gfc_trans_zero_assign.\n\n\t* gfortran.dg/array_memset_1.f90: New test case.\n\nFrom-SVN: r120078", "tree": {"sha": "2deff0c64810fea5035bf5058aeb42b4c126396b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/2deff0c64810fea5035bf5058aeb42b4c126396b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6822a10d9d8a0f9635e88624fb12ff34653e47a2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6822a10d9d8a0f9635e88624fb12ff34653e47a2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6822a10d9d8a0f9635e88624fb12ff34653e47a2", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6822a10d9d8a0f9635e88624fb12ff34653e47a2/comments", "author": null, "committer": null, "parents": [{"sha": "f1f4e530a59db86e577e9e83871626c782e33585", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f1f4e530a59db86e577e9e83871626c782e33585", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f1f4e530a59db86e577e9e83871626c782e33585"}], "stats": {"total": 165, "additions": 165, "deletions": 0}, "files": [{"sha": "0eb5dc5d75eb9433953bd127db9a8de3e57e50d7", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6822a10d9d8a0f9635e88624fb12ff34653e47a2/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6822a10d9d8a0f9635e88624fb12ff34653e47a2/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=6822a10d9d8a0f9635e88624fb12ff34653e47a2", "patch": "@@ -1,3 +1,12 @@\n+2006-12-20  Roger Sayle  <roger@eyesopen.com>\n+\n+\t* trans-expr.c (is_zero_initializer_p): Determine whether a given\n+\tconstant expression is a zero initializer.\n+\t(gfc_trans_zero_assign): New function to attempt to optimize\n+\t\"a(:) = 0.0\" as a call to __builtin_memset (a, 0, sizeof(a));\n+\t(gfc_trans_assignment): Special case array assignments to a\n+\tzero initializer constant, using gfc_trans_zero_assign.\n+\n 2006-12-20  Paul Thomas  <pault@gcc.gnu.org>\n \n \tPR fortran/29992"}, {"sha": "bd7983487c44234744cdb5921c8b69114abb7e57", "filename": "gcc/fortran/trans-expr.c", "status": "modified", "additions": 88, "deletions": 0, "changes": 88, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6822a10d9d8a0f9635e88624fb12ff34653e47a2/gcc%2Ffortran%2Ftrans-expr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6822a10d9d8a0f9635e88624fb12ff34653e47a2/gcc%2Ffortran%2Ftrans-expr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-expr.c?ref=6822a10d9d8a0f9635e88624fb12ff34653e47a2", "patch": "@@ -3449,6 +3449,82 @@ gfc_trans_arrayfunc_assign (gfc_expr * expr1, gfc_expr * expr2)\n   return gfc_finish_block (&se.pre);\n }\n \n+/* Determine whether the given EXPR_CONSTANT is a zero initializer.  */\n+\n+static bool\n+is_zero_initializer_p (gfc_expr * expr)\n+{\n+  if (expr->expr_type != EXPR_CONSTANT)\n+    return false;\n+  /* We ignore Hollerith constants for the time being.  */\n+  if (expr->from_H)\n+    return false;\n+\n+  switch (expr->ts.type)\n+    {\n+    case BT_INTEGER:\n+      return mpz_cmp_si (expr->value.integer, 0) == 0;\n+\n+    case BT_REAL:\n+      return mpfr_zero_p (expr->value.real)\n+\t     && MPFR_SIGN (expr->value.real) >= 0;\n+\n+    case BT_LOGICAL:\n+      return expr->value.logical == 0;\n+\n+    case BT_COMPLEX:\n+      return mpfr_zero_p (expr->value.complex.r)\n+\t     && MPFR_SIGN (expr->value.complex.r) >= 0\n+             && mpfr_zero_p (expr->value.complex.i)\n+\t     && MPFR_SIGN (expr->value.complex.i) >= 0;\n+\n+    default:\n+      break;\n+    }\n+  return false;\n+}\n+\n+/* Try to efficiently translate array(:) = 0.  Return NULL if this\n+   can't be done.  */\n+\n+static tree\n+gfc_trans_zero_assign (gfc_expr * expr)\n+{\n+  tree dest, len, type;\n+  tree tmp, args;\n+  gfc_symbol *sym;\n+\n+  sym = expr->symtree->n.sym;\n+  dest = gfc_get_symbol_decl (sym);\n+\n+  type = TREE_TYPE (dest);\n+  if (POINTER_TYPE_P (type))\n+    type = TREE_TYPE (type);\n+  if (!GFC_ARRAY_TYPE_P (type))\n+    return NULL_TREE;\n+\n+  /* Determine the length of the array.  */\n+  len = GFC_TYPE_ARRAY_SIZE (type);\n+  if (!len || TREE_CODE (len) != INTEGER_CST)\n+    return NULL_TREE;\n+\n+  len = fold_build2 (MULT_EXPR, gfc_array_index_type, len,\n+                     TYPE_SIZE_UNIT (gfc_get_element_type (type)));\n+\n+  /* Convert arguments to the correct types.  */\n+  if (!POINTER_TYPE_P (TREE_TYPE (dest)))\n+    dest = gfc_build_addr_expr (pvoid_type_node, dest);\n+  else\n+    dest = fold_convert (pvoid_type_node, dest);\n+  len = fold_convert (size_type_node, len);\n+\n+  /* Construct call to __builtin_memset.  */\n+  args = build_tree_list (NULL_TREE, len);\n+  args = tree_cons (NULL_TREE, integer_zero_node, args);\n+  args = tree_cons (NULL_TREE, dest, args);\n+  tmp = build_function_call_expr (built_in_decls[BUILT_IN_MEMSET], args);\n+  return fold_convert (void_type_node, tmp);\n+}\n \n /* Translate an assignment.  Most of the code is concerned with\n    setting up the scalarizer.  */\n@@ -3475,6 +3551,18 @@ gfc_trans_assignment (gfc_expr * expr1, gfc_expr * expr2, bool init_flag)\n \treturn tmp;\n     }\n \n+  /* Special case assigning an array to zero.  */\n+  if (expr1->expr_type == EXPR_VARIABLE\n+      && expr1->rank > 0\n+      && expr1->ref\n+      && gfc_full_array_ref_p (expr1->ref)\n+      && is_zero_initializer_p (expr2))\n+    {\n+      tmp = gfc_trans_zero_assign (expr1);\n+      if (tmp)\n+        return tmp;\n+    }\n+\n   /* Assignment of the form lhs = rhs.  */\n   gfc_start_block (&block);\n "}, {"sha": "d666489aa3e4c65a9248138eac0fcf3a7ae15db0", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6822a10d9d8a0f9635e88624fb12ff34653e47a2/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6822a10d9d8a0f9635e88624fb12ff34653e47a2/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=6822a10d9d8a0f9635e88624fb12ff34653e47a2", "patch": "@@ -1,3 +1,7 @@\n+2006-12-20  Roger Sayle  <roger@eyesopen.com>\n+\n+\t* gfortran.dg/array_memset_1.f90: New test case.\n+\n 2006-12-20  Dorit Nuzman  <dorit@il.ibm.com>\n \n \t* lib/target-supports.exp: Add spu to"}, {"sha": "cd6cb0d6d5d4e67559851ac2900bc27772876ba8", "filename": "gcc/testsuite/gfortran.dg/array_memset_1.f90", "status": "added", "additions": 64, "deletions": 0, "changes": 64, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6822a10d9d8a0f9635e88624fb12ff34653e47a2/gcc%2Ftestsuite%2Fgfortran.dg%2Farray_memset_1.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6822a10d9d8a0f9635e88624fb12ff34653e47a2/gcc%2Ftestsuite%2Fgfortran.dg%2Farray_memset_1.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Farray_memset_1.f90?ref=6822a10d9d8a0f9635e88624fb12ff34653e47a2", "patch": "@@ -0,0 +1,64 @@\n+! { dg-do compile }\n+! { dg-options \"-O2 -fdump-tree-original\" }\n+subroutine i1(a)\n+  integer :: a(20)\n+  a = 0;\n+end subroutine\n+\n+subroutine i2(a)\n+  integer :: a(20)\n+  a(:) = 0;\n+end subroutine\n+\n+subroutine i3(a)\n+  integer :: a(20)\n+  a(1:20) = 0;\n+end subroutine\n+\n+subroutine r1(a)\n+  real :: a(20)\n+  a = 0.0;\n+end subroutine\n+\n+subroutine r2(a)\n+  real :: a(20)\n+  a(:) = 0.0;\n+end subroutine\n+\n+subroutine r3(a)\n+  real :: a(20)\n+  a(1:20) = 0.0;\n+end subroutine\n+\n+subroutine z1(a)\n+  complex :: a(20)\n+  a = 0;\n+end subroutine\n+\n+subroutine z2(a)\n+  complex :: a(20)\n+  a(:) = 0;\n+end subroutine\n+\n+subroutine z3(a)\n+  complex :: a(20)\n+  a(1:20) = 0;\n+end subroutine\n+\n+subroutine l1(a)\n+  logical :: a(20)\n+  a = .false.;\n+end subroutine\n+\n+subroutine l2(a)\n+  logical :: a(20)\n+  a(:) = .false.;\n+end subroutine\n+\n+subroutine l3(a)\n+  logical :: a(20)\n+  a(1:20) = .false.;\n+end subroutine\n+\n+! { dg-final { scan-tree-dump-times \"memset\" 12 \"original\" } }\n+! { dg-final { cleanup-tree-dump \"original\" } }"}]}