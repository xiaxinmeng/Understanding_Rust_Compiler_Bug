{"sha": "6876e5bcd4e69cec6ef3507bb4ca64e22373b379", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Njg3NmU1YmNkNGU2OWNlYzZlZjM1MDdiYjRjYTY0ZTIyMzczYjM3OQ==", "commit": {"author": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2015-05-12T11:55:40Z"}, "committer": {"name": "Richard Biener", "email": "rguenth@gcc.gnu.org", "date": "2015-05-12T11:55:40Z"}, "message": "re PR tree-optimization/37021 (Fortran Complex reduction / multiplication not vectorized)\n\n2015-05-12  Richard Biener  <rguenther@suse.de>\n\n\tPR tree-optimization/37021\n\t* tree-vectorizer.h (struct _slp_tree): Add two_operators flag.\n\t(SLP_TREE_TWO_OPERATORS): New define.\n\t* tree-vect-slp.c (vect_create_new_slp_node): Initialize\n\tSLP_TREE_TWO_OPERATORS.\n\t(vect_build_slp_tree_1): Allow two mixing plus/minus in an\n\tSLP node.\n\t(vect_build_slp_tree): Adjust.\n\t(vect_analyze_slp_cost_1): Likewise.\n\t(vect_schedule_slp_instance): Vectorize mixing plus/minus by\n\temitting two vector stmts and mixing the results.\n\n\t* gcc.target/i386/vect-addsub.c: New testcase.\n\nFrom-SVN: r223059", "tree": {"sha": "48f20620956e1e4536e3d46f35bc962b7f2c4802", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/48f20620956e1e4536e3d46f35bc962b7f2c4802"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6876e5bcd4e69cec6ef3507bb4ca64e22373b379", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6876e5bcd4e69cec6ef3507bb4ca64e22373b379", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6876e5bcd4e69cec6ef3507bb4ca64e22373b379", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6876e5bcd4e69cec6ef3507bb4ca64e22373b379/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "eed4068d5d3916f9560246873069bfaaf7b75afe", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/eed4068d5d3916f9560246873069bfaaf7b75afe", "html_url": "https://github.com/Rust-GCC/gccrs/commit/eed4068d5d3916f9560246873069bfaaf7b75afe"}], "stats": {"total": 192, "additions": 185, "deletions": 7}, "files": [{"sha": "adc96c32b007341432bfd9688cd1d37852b4013b", "filename": "gcc/ChangeLog", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6876e5bcd4e69cec6ef3507bb4ca64e22373b379/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6876e5bcd4e69cec6ef3507bb4ca64e22373b379/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=6876e5bcd4e69cec6ef3507bb4ca64e22373b379", "patch": "@@ -1,3 +1,17 @@\n+2015-05-12  Richard Biener  <rguenther@suse.de>\n+\n+\tPR tree-optimization/37021\n+\t* tree-vectorizer.h (struct _slp_tree): Add two_operators flag.\n+\t(SLP_TREE_TWO_OPERATORS): New define.\n+\t* tree-vect-slp.c (vect_create_new_slp_node): Initialize\n+\tSLP_TREE_TWO_OPERATORS.\n+\t(vect_build_slp_tree_1): Allow two mixing plus/minus in an\n+\tSLP node.\n+\t(vect_build_slp_tree): Adjust.\n+\t(vect_analyze_slp_cost_1): Likewise.\n+\t(vect_schedule_slp_instance): Vectorize mixing plus/minus by\n+\temitting two vector stmts and mixing the results.\n+\n 2015-05-12  Dominik Vogt  <vogt@linux.vnet.ibm.com>\n \n \t* call.c (print_z_candidates): Remove dead code."}, {"sha": "9819e2a7731fe9e3100615b2360255561e2f21e6", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6876e5bcd4e69cec6ef3507bb4ca64e22373b379/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6876e5bcd4e69cec6ef3507bb4ca64e22373b379/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=6876e5bcd4e69cec6ef3507bb4ca64e22373b379", "patch": "@@ -1,3 +1,8 @@\n+2015-05-12  Richard Biener  <rguenther@suse.de>\n+\n+\tPR tree-optimization/37021\n+\t* gcc.target/i386/vect-addsub.c: New testcase.\n+\n 2015-05-11  Alexander Monakov  <amonakov@ispras.ru>\n \n \t* gcc.target/i386/pr65753.c: Use -O2 instead of -O."}, {"sha": "2d7532882a7e9f0f8ac4178558b555489b5c269d", "filename": "gcc/testsuite/gcc.target/i386/vect-addsub.c", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6876e5bcd4e69cec6ef3507bb4ca64e22373b379/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fvect-addsub.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6876e5bcd4e69cec6ef3507bb4ca64e22373b379/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fvect-addsub.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fvect-addsub.c?ref=6876e5bcd4e69cec6ef3507bb4ca64e22373b379", "patch": "@@ -0,0 +1,22 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -ftree-vectorize -msse4 -mtune=generic\" } */\n+\n+/* We need SSE4 so the backend recognizes a { 0, 5, 2, 7 } constant\n+   permutation as supported as the vectorizer wants to generate\n+\n+     vect__6.10_24 = vect__3.6_20 - vect__5.9_23;\n+     vect__6.11_25 = vect__3.6_20 + vect__5.9_23;\n+     _26 = VEC_PERM_EXPR <vect__6.10_24, vect__6.11_25, { 0, 5, 2, 7 }>;\n+\n+   See also the ??? comment about using and/andn/or in expand_vec_perm_blend\n+   for non-SSE4 targets.  */\n+\n+void testf (float * __restrict__ p, float * __restrict q)\n+{\n+  p[0] = p[0] - q[0];\n+  p[1] = p[1] + q[1];\n+  p[2] = p[2] - q[2];\n+  p[3] = p[3] + q[3];\n+}\n+\n+/* { dg-final { scan-assembler \"addsubps\" } } */"}, {"sha": "c675b1cf5db4b51f418270f6ec746b8500219f83", "filename": "gcc/tree-vect-slp.c", "status": "modified", "additions": 141, "deletions": 7, "changes": 148, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6876e5bcd4e69cec6ef3507bb4ca64e22373b379/gcc%2Ftree-vect-slp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6876e5bcd4e69cec6ef3507bb4ca64e22373b379/gcc%2Ftree-vect-slp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-slp.c?ref=6876e5bcd4e69cec6ef3507bb4ca64e22373b379", "patch": "@@ -160,6 +160,7 @@ vect_create_new_slp_node (vec<gimple> scalar_stmts)\n   SLP_TREE_VEC_STMTS (node).create (0);\n   SLP_TREE_CHILDREN (node).create (nops);\n   SLP_TREE_LOAD_PERMUTATION (node) = vNULL;\n+  SLP_TREE_TWO_OPERATORS (node) = false;\n \n   return node;\n }\n@@ -472,11 +473,14 @@ static bool\n vect_build_slp_tree_1 (loop_vec_info loop_vinfo, bb_vec_info bb_vinfo,\n \t\t       vec<gimple> stmts, unsigned int group_size,\n \t\t       unsigned nops, unsigned int *max_nunits,\n-\t\t       unsigned int vectorization_factor, bool *matches)\n+\t\t       unsigned int vectorization_factor, bool *matches,\n+\t\t       bool *two_operators)\n {\n   unsigned int i;\n-  gimple stmt = stmts[0];\n-  enum tree_code first_stmt_code = ERROR_MARK, rhs_code = ERROR_MARK;\n+  gimple first_stmt = stmts[0], stmt = stmts[0];\n+  enum tree_code first_stmt_code = ERROR_MARK;\n+  enum tree_code alt_stmt_code = ERROR_MARK;\n+  enum tree_code rhs_code = ERROR_MARK;\n   enum tree_code first_cond_code = ERROR_MARK;\n   tree lhs;\n   bool need_same_oprnds = false;\n@@ -674,11 +678,21 @@ vect_build_slp_tree_1 (loop_vec_info loop_vinfo, bb_vec_info bb_vinfo,\n \t}\n       else\n \t{\n+\t  if (first_stmt_code != rhs_code\n+\t      && alt_stmt_code == ERROR_MARK)\n+\t    alt_stmt_code = rhs_code;\n \t  if (first_stmt_code != rhs_code\n \t      && (first_stmt_code != IMAGPART_EXPR\n \t\t  || rhs_code != REALPART_EXPR)\n \t      && (first_stmt_code != REALPART_EXPR\n \t\t  || rhs_code != IMAGPART_EXPR)\n+\t      /* Handle mismatches in plus/minus by computing both\n+\t\t and merging the results.  */\n+\t      && !((first_stmt_code == PLUS_EXPR\n+\t\t    || first_stmt_code == MINUS_EXPR)\n+\t\t   && (alt_stmt_code == PLUS_EXPR\n+\t\t       || alt_stmt_code == MINUS_EXPR)\n+\t\t   && rhs_code == alt_stmt_code)\n               && !(STMT_VINFO_GROUPED_ACCESS (vinfo_for_stmt (stmt))\n                    && (first_stmt_code == ARRAY_REF\n                        || first_stmt_code == BIT_FIELD_REF\n@@ -692,7 +706,10 @@ vect_build_slp_tree_1 (loop_vec_info loop_vinfo, bb_vec_info bb_vinfo,\n \t\t\t\t   \"Build SLP failed: different operation \"\n \t\t\t\t   \"in stmt \");\n \t\t  dump_gimple_stmt (MSG_MISSED_OPTIMIZATION, TDF_SLIM, stmt, 0);\n-                  dump_printf (MSG_MISSED_OPTIMIZATION, \"\\n\");\n+\t\t  dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n+\t\t\t\t   \"original stmt \");\n+\t\t  dump_gimple_stmt (MSG_MISSED_OPTIMIZATION, TDF_SLIM,\n+\t\t\t\t    first_stmt, 0);\n \t\t}\n \t      /* Mismatch.  */\n \t      continue;\n@@ -921,6 +938,43 @@ vect_build_slp_tree_1 (loop_vec_info loop_vinfo, bb_vec_info bb_vinfo,\n     if (!matches[i])\n       return false;\n \n+  /* If we allowed a two-operation SLP node verify the target can cope\n+     with the permute we are going to use.  */\n+  if (alt_stmt_code != ERROR_MARK\n+      && TREE_CODE_CLASS (alt_stmt_code) != tcc_reference)\n+    {\n+      unsigned char *sel\n+\t= XALLOCAVEC (unsigned char, TYPE_VECTOR_SUBPARTS (vectype));\n+      for (i = 0; i < TYPE_VECTOR_SUBPARTS (vectype); ++i)\n+\t{\n+\t  sel[i] = i;\n+\t  if (gimple_assign_rhs_code (stmts[i % group_size]) == alt_stmt_code)\n+\t    sel[i] += TYPE_VECTOR_SUBPARTS (vectype);\n+\t}\n+      if (!can_vec_perm_p (TYPE_MODE (vectype), false, sel))\n+\t{\n+\t  for (i = 0; i < group_size; ++i)\n+\t    if (gimple_assign_rhs_code (stmts[i]) == alt_stmt_code)\n+\t      {\n+\t\tmatches[i] = false;\n+\t\tif (dump_enabled_p ())\n+\t\t  {\n+\t\t    dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n+\t\t\t\t     \"Build SLP failed: different operation \"\n+\t\t\t\t     \"in stmt \");\n+\t\t    dump_gimple_stmt (MSG_MISSED_OPTIMIZATION, TDF_SLIM,\n+\t\t\t\t      stmts[i], 0);\n+\t\t    dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n+\t\t\t\t     \"original stmt \");\n+\t\t    dump_gimple_stmt (MSG_MISSED_OPTIMIZATION, TDF_SLIM,\n+\t\t\t\t      first_stmt, 0);\n+\t\t  }\n+\t      }\n+\t  return false;\n+\t}\n+      *two_operators = true;\n+    }\n+\n   return true;\n }\n \n@@ -957,10 +1011,13 @@ vect_build_slp_tree (loop_vec_info loop_vinfo, bb_vec_info bb_vinfo,\n   else\n     return false;\n \n+  bool two_operators = false;\n   if (!vect_build_slp_tree_1 (loop_vinfo, bb_vinfo,\n \t\t\t      SLP_TREE_SCALAR_STMTS (*node), group_size, nops,\n-\t\t\t      max_nunits, vectorization_factor, matches))\n+\t\t\t      max_nunits, vectorization_factor, matches,\n+\t\t\t      &two_operators))\n     return false;\n+  SLP_TREE_TWO_OPERATORS (*node) = two_operators;\n \n   /* If the SLP node is a load, terminate the recursion.  */\n   if (STMT_VINFO_GROUPED_ACCESS (vinfo_for_stmt (stmt))\n@@ -1519,8 +1576,17 @@ vect_analyze_slp_cost_1 (loop_vec_info loop_vinfo, bb_vec_info bb_vinfo,\n \t}\n     }\n   else\n-    record_stmt_cost (body_cost_vec, ncopies_for_cost, vector_stmt,\n-\t\t      stmt_info, 0, vect_body);\n+    {\n+      record_stmt_cost (body_cost_vec, ncopies_for_cost, vector_stmt,\n+\t\t\tstmt_info, 0, vect_body);\n+      if (SLP_TREE_TWO_OPERATORS (node))\n+\t{\n+\t  record_stmt_cost (body_cost_vec, ncopies_for_cost, vector_stmt,\n+\t\t\t    stmt_info, 0, vect_body);\n+\t  record_stmt_cost (body_cost_vec, ncopies_for_cost, vec_perm,\n+\t\t\t    stmt_info, 0, vect_body);\n+\t}\n+    }\n \n   /* Scan operands and account for prologue cost of constants/externals.\n      ???  This over-estimates cost for multiple uses and should be\n@@ -3352,6 +3418,74 @@ vect_schedule_slp_instance (slp_tree node, slp_instance instance,\n       STMT_VINFO_TYPE (stmt_info) = reduc_vec_info_type;\n     }\n \n+  /* Handle two-operation SLP nodes by vectorizing the group with\n+     both operations and then performing a merge.  */\n+  if (SLP_TREE_TWO_OPERATORS (node))\n+    {\n+      enum tree_code code0 = gimple_assign_rhs_code (stmt);\n+      enum tree_code ocode;\n+      gimple ostmt;\n+      unsigned char *mask = XALLOCAVEC (unsigned char, group_size);\n+      bool allsame = true;\n+      FOR_EACH_VEC_ELT (SLP_TREE_SCALAR_STMTS (node), i, ostmt)\n+\tif (gimple_assign_rhs_code (ostmt) != code0)\n+\t  {\n+\t    mask[i] = 1;\n+\t    allsame = false;\n+\t    ocode = gimple_assign_rhs_code (ostmt);\n+\t  }\n+\telse\n+\t  mask[i] = 0;\n+      if (!allsame)\n+\t{\n+\t  vec<gimple> v0;\n+\t  vec<gimple> v1;\n+\t  unsigned j;\n+\t  tree tmask = NULL_TREE;\n+\t  vect_transform_stmt (stmt, &si, &grouped_store, node, instance);\n+\t  v0 = SLP_TREE_VEC_STMTS (node).copy ();\n+\t  SLP_TREE_VEC_STMTS (node).truncate (0);\n+\t  gimple_assign_set_rhs_code (stmt, ocode);\n+\t  vect_transform_stmt (stmt, &si, &grouped_store, node, instance);\n+\t  gimple_assign_set_rhs_code (stmt, code0);\n+\t  v1 = SLP_TREE_VEC_STMTS (node).copy ();\n+\t  SLP_TREE_VEC_STMTS (node).truncate (0);\n+\t  tree meltype = build_nonstandard_integer_type\n+\t      (GET_MODE_BITSIZE (TYPE_MODE (TREE_TYPE (vectype))), 1);\n+\t  tree mvectype = get_same_sized_vectype (meltype, vectype);\n+\t  unsigned k = 0, l;\n+\t  for (j = 0; j < v0.length (); ++j)\n+\t    {\n+\t      tree *melts = XALLOCAVEC (tree, TYPE_VECTOR_SUBPARTS (vectype));\n+\t      for (l = 0; l < TYPE_VECTOR_SUBPARTS (vectype); ++l)\n+\t\t{\n+\t\t  if (k > group_size)\n+\t\t    k = 0;\n+\t\t  melts[l] = build_int_cst\n+\t\t      (meltype, mask[k++] * TYPE_VECTOR_SUBPARTS (vectype) + l);\n+\t\t}\n+\t      tmask = build_vector (mvectype, melts);\n+\n+\t      /* ???  Not all targets support a VEC_PERM_EXPR with a\n+\t         constant mask that would translate to a vec_merge RTX\n+\t\t (with their vec_perm_const_ok).  We can either not\n+\t\t vectorize in that case or let veclower do its job.\n+\t\t Unfortunately that isn't too great and at least for\n+\t\t plus/minus we'd eventually like to match targets\n+\t\t vector addsub instructions.  */\n+\t      gimple vstmt;\n+\t      vstmt = gimple_build_assign (make_ssa_name (vectype),\n+\t\t\t\t\t   VEC_PERM_EXPR,\n+\t\t\t\t\t   gimple_assign_lhs (v0[j]),\n+\t\t\t\t\t   gimple_assign_lhs (v1[j]), tmask);\n+\t      vect_finish_stmt_generation (stmt, vstmt, &si);\n+\t      SLP_TREE_VEC_STMTS (node).quick_push (vstmt);\n+\t    }\n+\t  v0.release ();\n+\t  v1.release ();\n+\t  return false;\n+\t}\n+    }\n   is_store = vect_transform_stmt (stmt, &si, &grouped_store, node, instance);\n   return is_store;\n }"}, {"sha": "5a4fdbb63accf8fee9dd09a362cfbcb52c12362b", "filename": "gcc/tree-vectorizer.h", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6876e5bcd4e69cec6ef3507bb4ca64e22373b379/gcc%2Ftree-vectorizer.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6876e5bcd4e69cec6ef3507bb4ca64e22373b379/gcc%2Ftree-vectorizer.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vectorizer.h?ref=6876e5bcd4e69cec6ef3507bb4ca64e22373b379", "patch": "@@ -111,6 +111,8 @@ struct _slp_tree {\n      scalar elements in one scalar iteration (GROUP_SIZE) multiplied by VF\n      divided by vector size.  */\n   unsigned int vec_stmts_size;\n+  /* Whether the scalar computations use two different operators.  */\n+  bool two_operators;\n };\n \n \n@@ -146,6 +148,7 @@ typedef struct _slp_instance {\n #define SLP_TREE_VEC_STMTS(S)                    (S)->vec_stmts\n #define SLP_TREE_NUMBER_OF_VEC_STMTS(S)          (S)->vec_stmts_size\n #define SLP_TREE_LOAD_PERMUTATION(S)             (S)->load_permutation\n+#define SLP_TREE_TWO_OPERATORS(S)\t\t (S)->two_operators\n \n /* This structure is used in creation of an SLP tree.  Each instance\n    corresponds to the same operand in a group of scalar stmts in an SLP"}]}