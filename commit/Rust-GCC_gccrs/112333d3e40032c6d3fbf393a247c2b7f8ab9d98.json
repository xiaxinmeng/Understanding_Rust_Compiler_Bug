{"sha": "112333d3e40032c6d3fbf393a247c2b7f8ab9d98", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTEyMzMzZDNlNDAwMzJjNmQzZmJmMzkzYTI0N2MyYjdmOGFiOWQ5OA==", "commit": {"author": {"name": "Bernd Schmidt", "email": "bernds@redhat.com", "date": "2001-03-28T14:25:37Z"}, "committer": {"name": "Bernd Schmidt", "email": "bernds@gcc.gnu.org", "date": "2001-03-28T14:25:37Z"}, "message": "Fix missing barrier problem\n\nFrom-SVN: r40932", "tree": {"sha": "06b79eec24dd4adacaba92a5d2333746199529dc", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/06b79eec24dd4adacaba92a5d2333746199529dc"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/112333d3e40032c6d3fbf393a247c2b7f8ab9d98", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/112333d3e40032c6d3fbf393a247c2b7f8ab9d98", "html_url": "https://github.com/Rust-GCC/gccrs/commit/112333d3e40032c6d3fbf393a247c2b7f8ab9d98", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/112333d3e40032c6d3fbf393a247c2b7f8ab9d98/comments", "author": null, "committer": null, "parents": [{"sha": "669ff14e8d774550cb426ae240c5c74eb5380d9c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/669ff14e8d774550cb426ae240c5c74eb5380d9c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/669ff14e8d774550cb426ae240c5c74eb5380d9c"}], "stats": {"total": 270, "additions": 175, "deletions": 95}, "files": [{"sha": "8c76b2e0c858187ab9f2e400c01313195f8ca21a", "filename": "gcc/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/112333d3e40032c6d3fbf393a247c2b7f8ab9d98/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/112333d3e40032c6d3fbf393a247c2b7f8ab9d98/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=112333d3e40032c6d3fbf393a247c2b7f8ab9d98", "patch": "@@ -2,6 +2,15 @@\n \n \t* cselib.c (hash_rtx): Don't do tail recursion elimination by hand.\n \n+\t* config/ia64/ia64.c (update_set_flags): New function, broken out of\n+\trtx_needs_barrier.\n+\t(set_src_needs_barrier): Likewise.\n+\t(rtx_needs_barrier): For SET case, use these two functions.  Rework\n+\tPARALLEL case to handle all inputs before all outputs.\n+\t(emit_insn_group_barriers): Call init_insn_group_barriers only if we\n+\tsaw a label and no stop bit since then.\n+\t(maybe_rotate, process_epilogue): Add prototypes.\n+\n 2001-03-28  Richard Henderson  <rth@redhat.com>\n \n \t* config/rs6000/rs6000.h (EPILOGUE_USES): Use TARGET_AIX,"}, {"sha": "37943864eb396bb83bf414437e9485a3118de84b", "filename": "gcc/config/ia64/ia64.c", "status": "modified", "additions": 166, "deletions": 95, "changes": 261, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/112333d3e40032c6d3fbf393a247c2b7f8ab9d98/gcc%2Fconfig%2Fia64%2Fia64.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/112333d3e40032c6d3fbf393a247c2b7f8ab9d98/gcc%2Fconfig%2Fia64%2Fia64.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fia64%2Fia64.c?ref=112333d3e40032c6d3fbf393a247c2b7f8ab9d98", "patch": "@@ -118,6 +118,7 @@ static void ia64_free_machine_status PARAMS ((struct function *));\n static void emit_insn_group_barriers PARAMS ((FILE *, rtx));\n static void emit_all_insn_group_barriers PARAMS ((FILE *, rtx));\n static void emit_predicate_relation_info PARAMS ((void));\n+static void process_epilogue PARAMS ((void));\n static int process_set PARAMS ((FILE *, rtx));\n \n static rtx ia64_expand_fetch_and_op PARAMS ((optab, enum machine_mode,\n@@ -3826,6 +3827,8 @@ static void rws_update PARAMS ((struct reg_write_state *, int,\n \t\t\t\tstruct reg_flags, int));\n static int rws_access_regno PARAMS ((int, struct reg_flags, int));\n static int rws_access_reg PARAMS ((rtx, struct reg_flags, int));\n+static void update_set_flags PARAMS ((rtx, struct reg_flags *, int *, rtx *));\n+static int set_src_needs_barrier PARAMS ((rtx, struct reg_flags, int, rtx));\n static int rtx_needs_barrier PARAMS ((rtx, struct reg_flags, int));\n static void init_insn_group_barriers PARAMS ((void));\n static int group_barrier_needed_p PARAMS ((rtx));\n@@ -3994,6 +3997,132 @@ rws_access_reg (reg, flags, pred)\n     }\n }\n \n+/* Examine X, which is a SET rtx, and update the flags, the predicate, and\n+   the condition, stored in *PFLAGS, *PPRED and *PCOND.  */\n+\n+static void\n+update_set_flags (x, pflags, ppred, pcond)\n+     rtx x;\n+     struct reg_flags *pflags;\n+     int *ppred;\n+     rtx *pcond;\n+{\n+  rtx src = SET_SRC (x);\n+\n+  *pcond = 0;\n+\n+  switch (GET_CODE (src))\n+    {\n+    case CALL:\n+      return;\n+\n+    case IF_THEN_ELSE:\n+      if (SET_DEST (x) == pc_rtx)\n+\t/* X is a conditional branch.  */\n+\treturn;\t\n+      else\n+\t{\n+\t  int is_complemented = 0;\n+\n+\t  /* X is a conditional move.  */\n+\t  rtx cond = XEXP (src, 0);\n+\t  if (GET_CODE (cond) == EQ)\n+\t    is_complemented = 1;\n+\t  cond = XEXP (cond, 0);\n+\t  if (GET_CODE (cond) != REG\n+\t      && REGNO_REG_CLASS (REGNO (cond)) != PR_REGS)\n+\t    abort ();\n+\t  *pcond = cond;\n+\t  if (XEXP (src, 1) == SET_DEST (x)\n+\t      || XEXP (src, 2) == SET_DEST (x))\n+\t    {\n+\t      /* X is a conditional move that conditionally writes the\n+\t\t destination.  */\n+\n+\t      /* We need another complement in this case.  */\n+\t      if (XEXP (src, 1) == SET_DEST (x))\n+\t\tis_complemented = ! is_complemented;\n+\n+\t      *ppred = REGNO (cond);\n+\t      if (is_complemented)\n+\t\t++*ppred;\n+\t    }\n+\n+\t  /* ??? If this is a conditional write to the dest, then this\n+\t     instruction does not actually read one source.  This probably\n+\t     doesn't matter, because that source is also the dest.  */\n+\t  /* ??? Multiple writes to predicate registers are allowed\n+\t     if they are all AND type compares, or if they are all OR\n+\t     type compares.  We do not generate such instructions\n+\t     currently.  */\n+\t}\n+      /* ... fall through ... */\n+\n+    default:\n+      if (GET_RTX_CLASS (GET_CODE (src)) == '<'\n+\t  && GET_MODE_CLASS (GET_MODE (XEXP (src, 0))) == MODE_FLOAT)\n+\t/* Set pflags->is_fp to 1 so that we know we're dealing\n+\t   with a floating point comparison when processing the\n+\t   destination of the SET.  */\n+\tpflags->is_fp = 1;\n+\n+      /* Discover if this is a parallel comparison.  We only handle\n+\t and.orcm and or.andcm at present, since we must retain a\n+\t strict inverse on the predicate pair.  */\n+      else if (GET_CODE (src) == AND)\n+\tpflags->is_and = 1;\n+      else if (GET_CODE (src) == IOR)\n+\tpflags->is_or = 1;\n+\n+      break;\n+    }\n+}\n+\n+/* Subroutine of rtx_needs_barrier; this function determines whether the\n+   source of a given SET rtx found in X needs a barrier.  FLAGS and PRED\n+   are as in rtx_needs_barrier.  COND is an rtx that holds the condition\n+   for this insn.  */\n+   \n+static int\n+set_src_needs_barrier (x, flags, pred, cond)\n+     rtx x;\n+     struct reg_flags flags;\n+     int pred;\n+     rtx cond;\n+{\n+  int need_barrier = 0;\n+  rtx dst;\n+  rtx src = SET_SRC (x);\n+\n+  if (GET_CODE (src) == CALL)\n+    /* We don't need to worry about the result registers that\n+       get written by subroutine call.  */\n+    return rtx_needs_barrier (src, flags, pred);\n+  else if (SET_DEST (x) == pc_rtx)\n+    {\n+      /* X is a conditional branch.  */\n+      /* ??? This seems redundant, as the caller sets this bit for\n+\t all JUMP_INSNs.  */\n+      flags.is_branch = 1;\n+      return rtx_needs_barrier (src, flags, pred);\n+    }\n+\n+  need_barrier = rtx_needs_barrier (src, flags, pred);\n+\n+  /* This instruction unconditionally uses a predicate register.  */\n+  if (cond)\n+    need_barrier |= rws_access_reg (cond, flags, 0);\n+\n+  dst = SET_DEST (x);\n+  if (GET_CODE (dst) == ZERO_EXTRACT)\n+    {\n+      need_barrier |= rtx_needs_barrier (XEXP (dst, 1), flags, pred);\n+      need_barrier |= rtx_needs_barrier (XEXP (dst, 2), flags, pred);\n+      dst = XEXP (dst, 0);\n+    }\n+  return need_barrier;\n+}\n+\n /* Handle an access to rtx X of type FLAGS using predicate register PRED.\n    Return 1 is this access creates a dependency with an earlier instruction\n    in the same group.  */\n@@ -4009,7 +4138,6 @@ rtx_needs_barrier (x, flags, pred)\n   int need_barrier = 0;\n   const char *format_ptr;\n   struct reg_flags new_flags;\n-  rtx src, dst;\n   rtx cond = 0;\n \n   if (! x)\n@@ -4019,95 +4147,14 @@ rtx_needs_barrier (x, flags, pred)\n \n   switch (GET_CODE (x))\n     {\n-    case SET:\n-      src = SET_SRC (x);\n-      switch (GET_CODE (src))\n-\t{\n-\tcase CALL:\n-\t  /* We don't need to worry about the result registers that\n-             get written by subroutine call.  */\n-\t  need_barrier = rtx_needs_barrier (src, flags, pred);\n-\t  return need_barrier;\n-\n-\tcase IF_THEN_ELSE:\n-\t  if (SET_DEST (x) == pc_rtx)\n-\t    {\n-\t      /* X is a conditional branch.  */\n-\t      /* ??? This seems redundant, as the caller sets this bit for\n-\t\t all JUMP_INSNs.  */\n-\t      new_flags.is_branch = 1;\n-\t      need_barrier = rtx_needs_barrier (src, new_flags, pred);\n-\t      return need_barrier;\n-\t    }\n-\t  else\n-\t    {\n-\t      /* X is a conditional move.  */\n-\t      cond = XEXP (src, 0);\n-\t      if (GET_CODE (cond) == EQ)\n-\t\tis_complemented = 1;\n-\t      cond = XEXP (cond, 0);\n-\t      if (GET_CODE (cond) != REG\n-\t\t  && REGNO_REG_CLASS (REGNO (cond)) != PR_REGS)\n-\t\tabort ();\n-\n-\t      if (XEXP (src, 1) == SET_DEST (x)\n-\t\t  || XEXP (src, 2) == SET_DEST (x))\n-\t\t{\n-\t\t  /* X is a conditional move that conditionally writes the\n-\t\t     destination.  */\n-\n-\t\t  /* We need another complement in this case.  */\n-\t\t  if (XEXP (src, 1) == SET_DEST (x))\n-\t\t    is_complemented = ! is_complemented;\n-\n-\t\t  pred = REGNO (cond);\n-\t\t  if (is_complemented)\n-\t\t    ++pred;\n-\t\t}\n-\n-\t      /* ??? If this is a conditional write to the dest, then this\n-\t\t instruction does not actually read one source.  This probably\n-\t\t doesn't matter, because that source is also the dest.  */\n-\t      /* ??? Multiple writes to predicate registers are allowed\n-\t\t if they are all AND type compares, or if they are all OR\n-\t\t type compares.  We do not generate such instructions\n-\t\t currently.  */\n-\t    }\n-\t  /* ... fall through ... */\n-\n-\tdefault:\n-\t  if (GET_RTX_CLASS (GET_CODE (src)) == '<'\n-\t       && GET_MODE_CLASS (GET_MODE (XEXP (src, 0))) == MODE_FLOAT)\n-\t    /* Set new_flags.is_fp to 1 so that we know we're dealing\n-\t       with a floating point comparison when processing the\n-\t       destination of the SET.  */\n-\t    new_flags.is_fp = 1;\n-\n-\t  /* Discover if this is a parallel comparison.  We only handle\n-\t     and.orcm and or.andcm at present, since we must retain a\n-\t     strict inverse on the predicate pair.  */\n-\t  else if (GET_CODE (src) == AND)\n-\t    new_flags.is_and = flags.is_and = 1;\n-\t  else if (GET_CODE (src) == IOR)\n-\t    new_flags.is_or = flags.is_or = 1;\n-\n-\t  break;\n-\t}\n-      need_barrier = rtx_needs_barrier (src, flags, pred);\n-\n-      /* This instruction unconditionally uses a predicate register.  */\n-      if (cond)\n-\tneed_barrier |= rws_access_reg (cond, flags, 0);\n-\n-      dst = SET_DEST (x);\n-      if (GET_CODE (dst) == ZERO_EXTRACT)\n+    case SET:      \n+      update_set_flags (x, &new_flags, &pred, &cond);\n+      need_barrier = set_src_needs_barrier (x, new_flags, pred, cond);\n+      if (GET_CODE (SET_SRC (x)) != CALL)\n \t{\n-\t  need_barrier |= rtx_needs_barrier (XEXP (dst, 1), flags, pred);\n-\t  need_barrier |= rtx_needs_barrier (XEXP (dst, 2), flags, pred);\n-\t  dst = XEXP (dst, 0);\n+\t  new_flags.is_write = 1;\n+\t  need_barrier |= rtx_needs_barrier (SET_DEST (x), new_flags, pred);\n \t}\n-      new_flags.is_write = 1;\n-      need_barrier |= rtx_needs_barrier (dst, new_flags, pred);\n       break;\n \n     case CALL:\n@@ -4180,8 +4227,33 @@ rtx_needs_barrier (x, flags, pred)\n \n     case PARALLEL:\n       for (i = XVECLEN (x, 0) - 1; i >= 0; --i)\n-\tif (rtx_needs_barrier (XVECEXP (x, 0, i), flags, pred))\n-\t  need_barrier = 1;\n+\t{\n+\t  rtx pat = XVECEXP (x, 0, i);\n+\t  if (GET_CODE (pat) == SET)\n+\t    {\n+\t      update_set_flags (pat, &new_flags, &pred, &cond);\n+\t      need_barrier |= set_src_needs_barrier (pat, new_flags, pred, cond);\n+\t    }\n+\t  else if (GET_CODE (pat) == USE || GET_CODE (pat) == CALL)\n+\t    need_barrier |= rtx_needs_barrier (pat, flags, pred);\n+\t  else if (GET_CODE (pat) != CLOBBER && GET_CODE (pat) != RETURN)\n+\t    abort ();\n+\t}\n+      for (i = XVECLEN (x, 0) - 1; i >= 0; --i)\n+\t{\n+\t  rtx pat = XVECEXP (x, 0, i);\n+\t  if (GET_CODE (pat) == SET)\n+\t    {\n+\t      if (GET_CODE (SET_SRC (pat)) != CALL)\n+\t\t{\n+\t\t  new_flags.is_write = 1;\n+\t\t  need_barrier |= rtx_needs_barrier (SET_DEST (pat), new_flags,\n+\t\t\t\t\t\t     pred);\n+\t\t}\n+\t    }\n+\t  else if (GET_CODE (pat) == CLOBBER)\n+\t    need_barrier |= rtx_needs_barrier (pat, flags, pred);\n+\t}\n       break;\n \n     case SUBREG:\n@@ -4532,9 +4604,10 @@ emit_insn_group_barriers (dump, insns)\n \t\t\t     INSN_UID (last_label));\n \t\t  emit_insn_before (gen_insn_group_barrier (GEN_INT (3)), last_label);\n \t\t  insn = last_label;\n+\n+\t\t  init_insn_group_barriers ();\n+\t\t  last_label = 0;\n \t\t}\n-\t      init_insn_group_barriers ();\n-\t      last_label = 0;\n \t    }\n \t}\n     }\n@@ -4783,9 +4856,7 @@ static int itanium_split_issue PARAMS ((const struct ia64_packet *, int));\n static rtx ia64_single_set PARAMS ((rtx));\n static int insn_matches_slot PARAMS ((const struct ia64_packet *, enum attr_type, int, rtx));\n static void ia64_emit_insn_before PARAMS ((rtx, rtx));\n-#if 0\n-static rtx gen_nop_type PARAMS ((enum attr_type));\n-#endif\n+static void maybe_rotate PARAMS ((FILE *));\n static void finish_last_head PARAMS ((FILE *, int));\n static void rotate_one_bundle PARAMS ((FILE *));\n static void rotate_two_bundles PARAMS ((FILE *));"}]}