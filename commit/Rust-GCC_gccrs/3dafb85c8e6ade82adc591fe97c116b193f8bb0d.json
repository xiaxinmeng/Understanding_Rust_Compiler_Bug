{"sha": "3dafb85c8e6ade82adc591fe97c116b193f8bb0d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6M2RhZmI4NWM4ZTZhZGU4MmFkYzU5MWZlOTdjMTE2YjE5M2Y4YmIwZA==", "commit": {"author": {"name": "Martin Liska", "email": "mliska@suse.cz", "date": "2014-08-25T13:01:47Z"}, "committer": {"name": "Martin Liska", "email": "marxin@gcc.gnu.org", "date": "2014-08-25T13:01:47Z"}, "message": "IPA C++ refactoring 4/N\n\n\t* cgraph.h (symtab_node):\n\t(bool needed_p (void)): created from decide_is_symbol_needed\n\t(bool referred_to_p (void)): created from referred_to_p\n\t(static cgraph_node *get_for_asmname (tree asmname)): created from symtab_node_for_asm\n\t* cgraph.h (cgraph_node):\n\t(void assemble_thunks_and_aliases (void)): created from assemble_thunks_and_aliases\n\t(void expand (void)): created from expand_function\n\t(static void finalize_function (tree, bool)): created from cgraph_finalize_function\n\t(static cgraph_local_info *local_info (tree decl)): created from cgraph_local_info\n\t(static cgraph_global_info *global_info (tree)): created from cgraph_global_info\n\t(static cgraph_rtl_info *rtl_info (tree)): created from cgraph_rtl_info\n\t* cgraph.h (varpool_node):\n\t(static void add (tree decl): created from varpool_add_new_variable\n\t* cgraph.h (cgraph_edge):\n\tvoid remove (void);\n\t(void remove_caller (void)): created from cgraph_edge_remove_caller\n\t(void remove_callee (void)): created from cgraph_edge_remove_callee\n\t(void set_call_stmt (gimple new_stmt, bool update_speculative = true)):\n\t  created from cgraph_set_call_stmt\t\n\t(void redirect_callee (cgraph_node *n)): created from cgraph_redirect_edge_callee\n\t(cgraph_edge *make_direct (cgraph_node *callee)): created from cgraph_make_edge_direct\n\t(cgraph_edge *make_speculative (cgraph_node *n2, gcov_type direct_count,\n\t  gimple redirect_call_stmt_to_callee (void)): created from cgraph_turn_edge_to_speculative\n\t(void speculative_call_info (cgraph_edge *&direct, cgraph_edge *&indirect, ipa_ref *&reference)):\n\t  created from cgraph_speculative_call_info\n\t(cgraph_edge * clone (cgraph_node *n, gimple call_stmt, unsigned stmt_uid, gcov_type count_scale,\n\t  int freq_scale, bool update_original)): created from cgraph_clone_edge\n\t(cgraph_edge *resolve_speculation (tree callee_decl)): created from cgraph_resolve_speculation\n\t(bool cannot_lead_to_return_p (void)): created from cannot_lead_to_return_p\n\t(bool recursive_p (void)): created from cgraph_edge_recursive_p\n\t(bool maybe_hot_p (void)): created from cgraph_maybe_hot_edge_p\n\t(static unsigned int rebuild_edges (void)): created from rebuild_cgraph_edges \n\t(static void rebuild_references (void)): created from cgraph_rebuild_references\n\t* cgraph.h (symbol_table):\n\t(create_reference): renamed from add_reference\n\t(maybe_create_reference): renamed from maybe_add_reference\n\t(void register_symbol (symtab_node *node)): new function\n\t(void clear_asm_symbols (void)): new function\n\t(void unregister (symtab_node *node)): new function\n\t(void release_symbol (cgraph_node *node, int uid)): new function\n\t(cgraph_node * allocate_cgraph_symbol (void)): new function\n\t(void initialize (void)): created from cgraph_init\n\t(symtab_node *first_symbol (void)):new function\n\t(asm_node *first_asm_symbol (void)):new function\n\t(symtab_node *first_defined_symbol (void)):new function\n\t(varpool_node *first_variable (void)):new function\n\t(varpool_node *next_variable (varpool_node *node)):new function\n\t(varpool_node *first_static_initializer (void)):new function\n\t(varpool_node *next_static_initializer (varpool_node *node)):new function\n\t(varpool_node *first_defined_variable (void)):new function\n\t(varpool_node *next_defined_variable (varpool_node *node)):new function\n\t(cgraph_node *first_defined_function (void)):new function\n\t(cgraph_node *next_defined_function (cgraph_node *node)):new function\n\t(cgraph_node *first_function (void)):new function\n\t(cgraph_node *next_function (cgraph_node *node)):new function\n\t(cgraph_node *first_function_with_gimple_body (void)):new function\n\t(asm_node *finalize_toplevel_asm (tree asm_str)): created from add_asm_node\n\t(bool remove_unreachable_nodes (bool before_inlining_p, FILE *file)):\n\t  created from symtab_remove_unreachable_nodes\n\t(void remove_unreferenced_decls (void)): created from varpool_remove_unreferenced_decls\n\t(void process_new_functions (void)): created from cgraph_process_new_functions\n\t(void process_same_body_aliases (void)): created from cgraph_process_same_body_aliases\n\t(bool output_variables (void)): created from varpool_node::output_variables\n\t(void output_asm_statements (void)): created from output_asm_statements\n\t(void finalize_compilation_unit (void)): created from finalize_compilation_unit\n\t(void compile (void)): created from compile\n\t(void output_weakrefs (void)): created from output_weakrefs\n\t(cgraph_node *create_empty (void)): created from cgraph_node::create_empty\n\t(cgraph_edge *create_edge (cgraph_node *caller, cgraph_node *callee, gimple call_stmt,\n\t  gcov_type count, int freq, bool indir_unknown_callee)): created from cgraph_node::create_edge\n\t(void free_edge (cgraph_edge *e)): created from cgraph_free_edge\n\t(cgraph_node *next_function_with_gimple_body (cgraph_node *node)):\n\t  created from cgraph_next_function_with_gimple_body\n\t(void remove_edge_removal_hook (cgraph_edge_hook_list *)):\n\t  created from cgraph_remove_edge_removal_hook\n\t(cgraph_node_hook_list *add_cgraph_removal_hook (cgraph_node_hook, void *)):\n\t  created from cgraph_add_node_removal_hook\n\t(void remove_cgraph_removal_hook (cgraph_node_hook_list *)):\n\t  created from cgraph_remove_node_removal_hook\n\t(varpool_node_hook_list *add_varpool_removal_hook (varpool_node_hook, void *)):\n\t  created from varpool_add_node_removal_hook\n\t(void remove_varpool_removal_hook (varpool_node_hook_list *)):\n\t  created from varpool_remove_node_removal_hook\n\t(cgraph_node_hook_list *add_cgraph_insertion_hook (cgraph_node_hook, void *)):\n\t  created from cgraph_add_function_insertion_hook\n\t(void remove_cgraph_insertion_hook (cgraph_node_hook_list *)):\n\t  created from cgraph_remove_function_insertion_hook\n\t(varpool_node_hook_list *add_varpool_insertion_hook (varpool_node_hook, void *)):\n\t  created from varpool_add_variable_insertion_hook\n\t(void remove_varpool_insertion_hook (varpool_node_hook_list *)):\n\t  created from varpool_remove_variable_insertion_hook\n\t(cgraph_2edge_hook_list *add_edge_duplication_hook (cgraph_2edge_hook, void *)):\n\t  created from cgraph_add_edge_duplication_hook\n\t(void remove_edge_duplication_hook (cgraph_2edge_hook_list *)):\n\t  created from cgraph_remove_edge_duplication_hook\n\t(cgraph_2node_hook_list *add_cgraph_duplication_hook (cgraph_2node_hook, void *)):\n\t  created from cgraph_add_node_duplication_hook\n\t(void remove_cgraph_duplication_hook (cgraph_2node_hook_list *)):\n\t  created from cgraph_remove_node_duplication_hook\n\t(void call_edge_removal_hooks (cgraph_edge *e)):\n\t  created from cgraph_call_edge_removal_hooks\n\t(void call_cgraph_insertion_hooks (cgraph_node *node)):\n\t  created from call_function_insertion_hooks \n\t(void call_cgraph_removal_hooks (cgraph_node *node)):\n\t  created from cgraph_call_node_removal_hooks \n\t(void call_cgraph_duplication_hooks (cgraph_node *node, cgraph_node *node2)):\n\t  created from cgraph_node::call_duplication_hooks \n\t(void call_edge_duplication_hooks (cgraph_edge *cs1, cgraph_edge *cs2)):\n\t  created from cgraph_call_edge_duplication_hooks\n\t(void call_varpool_removal_hooks (varpool_node *node)):\n\t  created from varpool_call_node_removal_hooks\n\t(void call_varpool_insertion_hooks (varpool_node *node)):\n\t  created from varpool_call_variable_insertion_hooks\n\t(void insert_to_assembler_name_hash (symtab_node *node, bool with_clones)):\n\t  created from insert_to_assembler_name_hash\n\t(void unlink_from_assembler_name_hash (symtab_node *node, bool with_clones)):\n\t  created from unlink_from_assembler_name_hash\n\t(void symtab_prevail_in_asm_name_hash (symtab_node *node)):\n\t  created from symtab_prevail_in_asm_name_hash\n\t(void symtab_initialize_asm_name_hash (void)):\n\t  created from symtab_initialize_asm_name_hash\n\t(void change_decl_assembler_name (tree decl, tree name)):\n\t  created from change_decl_assembler_name\n\t(void materialize_all_clones (void)): created from cgraph_materialize_all_clones\n\t(static hashval_t decl_assembler_name_hash (const_tree asmname)):\n\t  created from decl_assembler_name_hash\n\t(static bool decl_assembler_name_equal (tree decl, const_tree asmname)):\n\t  created from decl_assembler_name_equal\n\t(static hashval_t hash_node_by_assembler_name (const void *p)):\n\t  created from hash_node_by_assembler_name\n\t(static int eq_assembler_name (const void *p1, const void *p2)):\n\t  created from eq_assembler_name\n\nFrom-SVN: r214422", "tree": {"sha": "6efa3ef534f8ca5761c35200d5cc61a819dde6f4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6efa3ef534f8ca5761c35200d5cc61a819dde6f4"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3dafb85c8e6ade82adc591fe97c116b193f8bb0d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3dafb85c8e6ade82adc591fe97c116b193f8bb0d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3dafb85c8e6ade82adc591fe97c116b193f8bb0d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3dafb85c8e6ade82adc591fe97c116b193f8bb0d/comments", "author": {"login": "marxin", "id": 2658545, "node_id": "MDQ6VXNlcjI2NTg1NDU=", "avatar_url": "https://avatars.githubusercontent.com/u/2658545?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marxin", "html_url": "https://github.com/marxin", "followers_url": "https://api.github.com/users/marxin/followers", "following_url": "https://api.github.com/users/marxin/following{/other_user}", "gists_url": "https://api.github.com/users/marxin/gists{/gist_id}", "starred_url": "https://api.github.com/users/marxin/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marxin/subscriptions", "organizations_url": "https://api.github.com/users/marxin/orgs", "repos_url": "https://api.github.com/users/marxin/repos", "events_url": "https://api.github.com/users/marxin/events{/privacy}", "received_events_url": "https://api.github.com/users/marxin/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "3749134042ab5f54d0c30af1ec336e7132ac9bc8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3749134042ab5f54d0c30af1ec336e7132ac9bc8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3749134042ab5f54d0c30af1ec336e7132ac9bc8"}], "stats": {"total": 3630, "additions": 2028, "deletions": 1602}, "files": [{"sha": "8e4b593afe847ec3a1953655c46e28fc3226a1b1", "filename": "gcc/ChangeLog", "status": "modified", "additions": 135, "deletions": 0, "changes": 135, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3dafb85c8e6ade82adc591fe97c116b193f8bb0d/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3dafb85c8e6ade82adc591fe97c116b193f8bb0d/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=3dafb85c8e6ade82adc591fe97c116b193f8bb0d", "patch": "@@ -1,3 +1,138 @@\n+2014-08-25  Martin Liska  <mliska@suse.cz>\n+\n+\t* cgraph.h (symtab_node):\n+\t(bool needed_p (void)): created from decide_is_symbol_needed\n+\t(bool referred_to_p (void)): created from referred_to_p\n+\t(static cgraph_node *get_for_asmname (tree asmname)): created from symtab_node_for_asm\n+\t* cgraph.h (cgraph_node):\n+\t(void assemble_thunks_and_aliases (void)): created from assemble_thunks_and_aliases\n+\t(void expand (void)): created from expand_function\n+\t(static void finalize_function (tree, bool)): created from cgraph_finalize_function\n+\t(static cgraph_local_info *local_info (tree decl)): created from cgraph_local_info\n+\t(static cgraph_global_info *global_info (tree)): created from cgraph_global_info\n+\t(static cgraph_rtl_info *rtl_info (tree)): created from cgraph_rtl_info\n+\t* cgraph.h (varpool_node):\n+\t(static void add (tree decl): created from varpool_add_new_variable\n+\t* cgraph.h (cgraph_edge):\n+\tvoid remove (void);\n+\t(void remove_caller (void)): created from cgraph_edge_remove_caller\n+\t(void remove_callee (void)): created from cgraph_edge_remove_callee\n+\t(void set_call_stmt (gimple new_stmt, bool update_speculative = true)):\n+\t  created from cgraph_set_call_stmt\t\n+\t(void redirect_callee (cgraph_node *n)): created from cgraph_redirect_edge_callee\n+\t(cgraph_edge *make_direct (cgraph_node *callee)): created from cgraph_make_edge_direct\n+\t(cgraph_edge *make_speculative (cgraph_node *n2, gcov_type direct_count,\n+\t  gimple redirect_call_stmt_to_callee (void)): created from cgraph_turn_edge_to_speculative\n+\t(void speculative_call_info (cgraph_edge *&direct, cgraph_edge *&indirect, ipa_ref *&reference)):\n+\t  created from cgraph_speculative_call_info\n+\t(cgraph_edge * clone (cgraph_node *n, gimple call_stmt, unsigned stmt_uid, gcov_type count_scale,\n+\t  int freq_scale, bool update_original)): created from cgraph_clone_edge\n+\t(cgraph_edge *resolve_speculation (tree callee_decl)): created from cgraph_resolve_speculation\n+\t(bool cannot_lead_to_return_p (void)): created from cannot_lead_to_return_p\n+\t(bool recursive_p (void)): created from cgraph_edge_recursive_p\n+\t(bool maybe_hot_p (void)): created from cgraph_maybe_hot_edge_p\n+\t(static unsigned int rebuild_edges (void)): created from rebuild_cgraph_edges \n+\t(static void rebuild_references (void)): created from cgraph_rebuild_references\n+\t* cgraph.h (symbol_table):\n+\t(create_reference): renamed from add_reference\n+\t(maybe_create_reference): renamed from maybe_add_reference\n+\t(void register_symbol (symtab_node *node)): new function\n+\t(void clear_asm_symbols (void)): new function\n+\t(void unregister (symtab_node *node)): new function\n+\t(void release_symbol (cgraph_node *node, int uid)): new function\n+\t(cgraph_node * allocate_cgraph_symbol (void)): new function\n+\t(void initialize (void)): created from cgraph_init\n+\t(symtab_node *first_symbol (void)):new function\n+\t(asm_node *first_asm_symbol (void)):new function\n+\t(symtab_node *first_defined_symbol (void)):new function\n+\t(varpool_node *first_variable (void)):new function\n+\t(varpool_node *next_variable (varpool_node *node)):new function\n+\t(varpool_node *first_static_initializer (void)):new function\n+\t(varpool_node *next_static_initializer (varpool_node *node)):new function\n+\t(varpool_node *first_defined_variable (void)):new function\n+\t(varpool_node *next_defined_variable (varpool_node *node)):new function\n+\t(cgraph_node *first_defined_function (void)):new function\n+\t(cgraph_node *next_defined_function (cgraph_node *node)):new function\n+\t(cgraph_node *first_function (void)):new function\n+\t(cgraph_node *next_function (cgraph_node *node)):new function\n+\t(cgraph_node *first_function_with_gimple_body (void)):new function\n+\t(asm_node *finalize_toplevel_asm (tree asm_str)): created from add_asm_node\n+\t(bool remove_unreachable_nodes (bool before_inlining_p, FILE *file)):\n+\t  created from symtab_remove_unreachable_nodes\n+\t(void remove_unreferenced_decls (void)): created from varpool_remove_unreferenced_decls\n+\t(void process_new_functions (void)): created from cgraph_process_new_functions\n+\t(void process_same_body_aliases (void)): created from cgraph_process_same_body_aliases\n+\t(bool output_variables (void)): created from varpool_node::output_variables\n+\t(void output_asm_statements (void)): created from output_asm_statements\n+\t(void finalize_compilation_unit (void)): created from finalize_compilation_unit\n+\t(void compile (void)): created from compile\n+\t(void output_weakrefs (void)): created from output_weakrefs\n+\t(cgraph_node *create_empty (void)): created from cgraph_node::create_empty\n+\t(cgraph_edge *create_edge (cgraph_node *caller, cgraph_node *callee, gimple call_stmt,\n+\t  gcov_type count, int freq, bool indir_unknown_callee)): created from cgraph_node::create_edge\n+\t(void free_edge (cgraph_edge *e)): created from cgraph_free_edge\n+\t(cgraph_node *next_function_with_gimple_body (cgraph_node *node)):\n+\t  created from cgraph_next_function_with_gimple_body\n+\t(void remove_edge_removal_hook (cgraph_edge_hook_list *)):\n+\t  created from cgraph_remove_edge_removal_hook\n+\t(cgraph_node_hook_list *add_cgraph_removal_hook (cgraph_node_hook, void *)):\n+\t  created from cgraph_add_node_removal_hook\n+\t(void remove_cgraph_removal_hook (cgraph_node_hook_list *)):\n+\t  created from cgraph_remove_node_removal_hook\n+\t(varpool_node_hook_list *add_varpool_removal_hook (varpool_node_hook, void *)):\n+\t  created from varpool_add_node_removal_hook\n+\t(void remove_varpool_removal_hook (varpool_node_hook_list *)):\n+\t  created from varpool_remove_node_removal_hook\n+\t(cgraph_node_hook_list *add_cgraph_insertion_hook (cgraph_node_hook, void *)):\n+\t  created from cgraph_add_function_insertion_hook\n+\t(void remove_cgraph_insertion_hook (cgraph_node_hook_list *)):\n+\t  created from cgraph_remove_function_insertion_hook\n+\t(varpool_node_hook_list *add_varpool_insertion_hook (varpool_node_hook, void *)):\n+\t  created from varpool_add_variable_insertion_hook\n+\t(void remove_varpool_insertion_hook (varpool_node_hook_list *)):\n+\t  created from varpool_remove_variable_insertion_hook\n+\t(cgraph_2edge_hook_list *add_edge_duplication_hook (cgraph_2edge_hook, void *)):\n+\t  created from cgraph_add_edge_duplication_hook\n+\t(void remove_edge_duplication_hook (cgraph_2edge_hook_list *)):\n+\t  created from cgraph_remove_edge_duplication_hook\n+\t(cgraph_2node_hook_list *add_cgraph_duplication_hook (cgraph_2node_hook, void *)):\n+\t  created from cgraph_add_node_duplication_hook\n+\t(void remove_cgraph_duplication_hook (cgraph_2node_hook_list *)):\n+\t  created from cgraph_remove_node_duplication_hook\n+\t(void call_edge_removal_hooks (cgraph_edge *e)):\n+\t  created from cgraph_call_edge_removal_hooks\n+\t(void call_cgraph_insertion_hooks (cgraph_node *node)):\n+\t  created from call_function_insertion_hooks \n+\t(void call_cgraph_removal_hooks (cgraph_node *node)):\n+\t  created from cgraph_call_node_removal_hooks \n+\t(void call_cgraph_duplication_hooks (cgraph_node *node, cgraph_node *node2)):\n+\t  created from cgraph_node::call_duplication_hooks \n+\t(void call_edge_duplication_hooks (cgraph_edge *cs1, cgraph_edge *cs2)):\n+\t  created from cgraph_call_edge_duplication_hooks\n+\t(void call_varpool_removal_hooks (varpool_node *node)):\n+\t  created from varpool_call_node_removal_hooks\n+\t(void call_varpool_insertion_hooks (varpool_node *node)):\n+\t  created from varpool_call_variable_insertion_hooks\n+\t(void insert_to_assembler_name_hash (symtab_node *node, bool with_clones)):\n+\t  created from insert_to_assembler_name_hash\n+\t(void unlink_from_assembler_name_hash (symtab_node *node, bool with_clones)):\n+\t  created from unlink_from_assembler_name_hash\n+\t(void symtab_prevail_in_asm_name_hash (symtab_node *node)):\n+\t  created from symtab_prevail_in_asm_name_hash\n+\t(void symtab_initialize_asm_name_hash (void)):\n+\t  created from symtab_initialize_asm_name_hash\n+\t(void change_decl_assembler_name (tree decl, tree name)):\n+\t  created from change_decl_assembler_name\n+\t(void materialize_all_clones (void)): created from cgraph_materialize_all_clones\n+\t(static hashval_t decl_assembler_name_hash (const_tree asmname)):\n+\t  created from decl_assembler_name_hash\n+\t(static bool decl_assembler_name_equal (tree decl, const_tree asmname)):\n+\t  created from decl_assembler_name_equal\n+\t(static hashval_t hash_node_by_assembler_name (const void *p)):\n+\t  created from hash_node_by_assembler_name\n+\t(static int eq_assembler_name (const void *p1, const void *p2)):\n+\t  created from eq_assembler_name\n+\n 2014-08-25  Marek Polacek  <polacek@redhat.com>\n \n \t* config/i386/i386.md (SWI1248_AVX512BW): Add missing paren."}, {"sha": "266a942651fd9255a7e47bac34fb57c667000906", "filename": "gcc/ada/gcc-interface/utils.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3dafb85c8e6ade82adc591fe97c116b193f8bb0d/gcc%2Fada%2Fgcc-interface%2Futils.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3dafb85c8e6ade82adc591fe97c116b193f8bb0d/gcc%2Fada%2Fgcc-interface%2Futils.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Futils.c?ref=3dafb85c8e6ade82adc591fe97c116b193f8bb0d", "patch": "@@ -3156,7 +3156,7 @@ rest_of_subprog_body_compilation (tree subprog_decl)\n   dump_function (TDI_original, subprog_decl);\n \n   if (!decl_function_context (subprog_decl))\n-    cgraph_finalize_function (subprog_decl, false);\n+    cgraph_node::finalize_function (subprog_decl, false);\n   else\n     /* Register this function with cgraph just far enough to get it\n        added to our parent's nested function list.  */\n@@ -5187,7 +5187,7 @@ gnat_write_global_declarations (void)\n       debug_hooks->global_decl (iter);\n \n   /* Proceed to optimize and emit assembly. */\n-  finalize_compilation_unit ();\n+  symtab->finalize_compilation_unit ();\n \n   /* After cgraph has had a chance to emit everything that's going to\n      be emitted, output debug information for the rest of globals.  */"}, {"sha": "804f37cee5167804669c519c5634be1bd05854e6", "filename": "gcc/c-family/c-pragma.c", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3dafb85c8e6ade82adc591fe97c116b193f8bb0d/gcc%2Fc-family%2Fc-pragma.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3dafb85c8e6ade82adc591fe97c116b193f8bb0d/gcc%2Fc-family%2Fc-pragma.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc-pragma.c?ref=3dafb85c8e6ade82adc591fe97c116b193f8bb0d", "patch": "@@ -25,7 +25,6 @@ along with GCC; see the file COPYING3.  If not see\n #include \"stringpool.h\"\n #include \"attribs.h\"\n #include \"varasm.h\"\n-#include \"gcc-symtab.h\"\n #include \"function.h\"\t\t/* For cfun.  FIXME: Does the parser know\n \t\t\t\t   when it is inside a function, so that\n \t\t\t\t   we don't have to look at cfun?  */\n@@ -329,7 +328,7 @@ maybe_apply_pending_pragma_weaks (void)\n       if (id == NULL)\n \tcontinue;\n \n-      target = symtab_node_for_asm (id);\n+      target = symtab_node::get_for_asmname (id);\n       decl = build_decl (UNKNOWN_LOCATION,\n \t\t\t target ? TREE_CODE (target->decl) : FUNCTION_DECL,\n \t\t\t alias_id, default_function_type);\n@@ -479,7 +478,7 @@ handle_pragma_redefine_extname (cpp_reader * ARG_UNUSED (dummy))\n \t\t\t \"conflict with previous rename\");\n \t    }\n \t  else\n-\t    change_decl_assembler_name (decl, newname);\n+\t    symtab->change_decl_assembler_name (decl, newname);\n \t}\n     }\n "}, {"sha": "b4995a67733c6c74cdba559cced0e43a774559b9", "filename": "gcc/c/c-decl.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3dafb85c8e6ade82adc591fe97c116b193f8bb0d/gcc%2Fc%2Fc-decl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3dafb85c8e6ade82adc591fe97c116b193f8bb0d/gcc%2Fc%2Fc-decl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc%2Fc-decl.c?ref=3dafb85c8e6ade82adc591fe97c116b193f8bb0d", "patch": "@@ -8665,12 +8665,12 @@ finish_function (void)\n \n \t  /* ??? Objc emits functions after finalizing the compilation unit.\n \t     This should be cleaned up later and this conditional removed.  */\n-\t  if (cgraph_global_info_ready)\n+\t  if (symtab->global_info_ready)\n \t    {\n \t      cgraph_node::add_new_function (fndecl, false);\n \t      return;\n \t    }\n-\t  cgraph_finalize_function (fndecl, false);\n+\t  cgraph_node::finalize_function (fndecl, false);\n \t}\n       else\n \t{\n@@ -10428,7 +10428,7 @@ c_write_global_declarations (void)\n \n   /* We're done parsing; proceed to optimize and emit assembly.\n      FIXME: shouldn't be the front end's responsibility to call this.  */\n-  finalize_compilation_unit ();\n+  symtab->finalize_compilation_unit ();\n \n   timevar_stop (TV_PHASE_OPT_GEN);\n   timevar_start (TV_PHASE_DBGINFO);"}, {"sha": "34f1e4701f1ab482b9addf39ca2b2beefc97ccbf", "filename": "gcc/c/c-parser.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3dafb85c8e6ade82adc591fe97c116b193f8bb0d/gcc%2Fc%2Fc-parser.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3dafb85c8e6ade82adc591fe97c116b193f8bb0d/gcc%2Fc%2Fc-parser.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc%2Fc-parser.c?ref=3dafb85c8e6ade82adc591fe97c116b193f8bb0d", "patch": "@@ -1980,7 +1980,7 @@ c_parser_asm_definition (c_parser *parser)\n {\n   tree asm_str = c_parser_simple_asm_expr (parser);\n   if (asm_str)\n-    add_asm_node (asm_str);\n+    symtab->finalize_toplevel_asm (asm_str);\n   c_parser_skip_until_found (parser, CPP_SEMICOLON, \"expected %<;%>\");\n }\n "}, {"sha": "10f52bb8a2e375b2780a993f4cc9c41f9c824b5f", "filename": "gcc/calls.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3dafb85c8e6ade82adc591fe97c116b193f8bb0d/gcc%2Fcalls.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3dafb85c8e6ade82adc591fe97c116b193f8bb0d/gcc%2Fcalls.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcalls.c?ref=3dafb85c8e6ade82adc591fe97c116b193f8bb0d", "patch": "@@ -2406,7 +2406,7 @@ expand_call (tree exp, rtx target, int ignore)\n   preferred_stack_boundary = PREFERRED_STACK_BOUNDARY;\n   if (fndecl)\n     {\n-      struct cgraph_rtl_info *i = cgraph_rtl_info (fndecl);\n+      struct cgraph_rtl_info *i = cgraph_node::rtl_info (fndecl);\n       /* Without automatic stack alignment, we can't increase preferred\n \t stack boundary.  With automatic stack alignment, it is\n \t unnecessary since unless we can guarantee that all callers will"}, {"sha": "99e00764c80ed85075648851a524ccb7c23e5109", "filename": "gcc/cgraph.c", "status": "modified", "additions": 338, "deletions": 423, "changes": 761, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3dafb85c8e6ade82adc591fe97c116b193f8bb0d/gcc%2Fcgraph.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3dafb85c8e6ade82adc591fe97c116b193f8bb0d/gcc%2Fcgraph.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraph.c?ref=3dafb85c8e6ade82adc591fe97c116b193f8bb0d", "patch": "@@ -68,30 +68,12 @@ along with GCC; see the file COPYING3.  If not see\n /* FIXME: Only for PROP_loops, but cgraph shouldn't have to know about this.  */\n #include \"tree-pass.h\"\n \n-static inline void cgraph_edge_remove_caller (struct cgraph_edge *e);\n-static inline void cgraph_edge_remove_callee (struct cgraph_edge *e);\n-\n /* Queue of cgraph nodes scheduled to be lowered.  */\n symtab_node *x_cgraph_nodes_queue;\n-#define cgraph_nodes_queue ((struct cgraph_node *)x_cgraph_nodes_queue)\n-\n-/* Number of nodes in existence.  */\n-int cgraph_n_nodes;\n-\n-/* Maximal uid used in cgraph nodes.  */\n-int cgraph_max_uid;\n-\n-/* Maximal uid used in cgraph edges.  */\n-int cgraph_edge_max_uid;\n-\n-/* Set when whole unit has been analyzed so we can access global info.  */\n-bool cgraph_global_info_ready = false;\n-\n-/* What state callgraph is in right now.  */\n-enum cgraph_state cgraph_state = CGRAPH_STATE_PARSING;\n+#define cgraph_nodes_queue ((cgraph_node *)x_cgraph_nodes_queue)\n \n-/* Set when the cgraph is fully build and the basic flags are computed.  */\n-bool cgraph_function_flags_ready = false;\n+/* Symbol table global context.  */\n+symbol_table *symtab;\n \n /* List of hooks triggered on cgraph_edge events.  */\n struct cgraph_edge_hook_list {\n@@ -121,50 +103,29 @@ struct cgraph_2node_hook_list {\n   struct cgraph_2node_hook_list *next;\n };\n \n-/* List of hooks triggered when an edge is removed.  */\n-struct cgraph_edge_hook_list *first_cgraph_edge_removal_hook;\n-/* List of hooks triggered when a node is removed.  */\n-struct cgraph_node_hook_list *first_cgraph_node_removal_hook;\n-/* List of hooks triggered when an edge is duplicated.  */\n-struct cgraph_2edge_hook_list *first_cgraph_edge_duplicated_hook;\n-/* List of hooks triggered when a node is duplicated.  */\n-struct cgraph_2node_hook_list *first_cgraph_node_duplicated_hook;\n-/* List of hooks triggered when an function is inserted.  */\n-struct cgraph_node_hook_list *first_cgraph_function_insertion_hook;\n-\n-/* Head of a linked list of unused (freed) call graph nodes.\n-   Do not GTY((delete)) this list so UIDs gets reliably recycled.  */\n-static GTY(()) struct cgraph_node *free_nodes;\n-/* Head of a linked list of unused (freed) call graph edges.\n-   Do not GTY((delete)) this list so UIDs gets reliably recycled.  */\n-static GTY(()) struct cgraph_edge *free_edges;\n-\n-/* Did procss_same_body_aliases run?  */\n-bool cpp_implicit_aliases_done;\n-\n /* Map a cgraph_node to cgraph_function_version_info using this htab.\n    The cgraph_function_version_info has a THIS_NODE field that is the\n    corresponding cgraph_node..  */\n \n-static GTY((param_is (struct cgraph_function_version_info))) htab_t\n+static GTY((param_is (cgraph_function_version_info))) htab_t\n   cgraph_fnver_htab = NULL;\n \n /* Hash function for cgraph_fnver_htab.  */\n static hashval_t\n cgraph_fnver_htab_hash (const void *ptr)\n {\n-  int uid = ((const struct cgraph_function_version_info *)ptr)->this_node->uid;\n+  int uid = ((const cgraph_function_version_info *)ptr)->this_node->uid;\n   return (hashval_t)(uid);\n }\n \n /* eq function for cgraph_fnver_htab.  */\n static int\n cgraph_fnver_htab_eq (const void *p1, const void *p2)\n {\n-  const struct cgraph_function_version_info *n1\n-    = (const struct cgraph_function_version_info *)p1;\n-  const struct cgraph_function_version_info *n2\n-    = (const struct cgraph_function_version_info *)p2;\n+  const cgraph_function_version_info *n1\n+    = (const cgraph_function_version_info *)p1;\n+  const cgraph_function_version_info *n2\n+    = (const cgraph_function_version_info *)p2;\n \n   return n1->this_node->uid == n2->this_node->uid;\n }\n@@ -174,25 +135,25 @@ static GTY(()) struct cgraph_function_version_info *\n   version_info_node = NULL;\n \n /* Get the cgraph_function_version_info node corresponding to node.  */\n-struct cgraph_function_version_info *\n+cgraph_function_version_info *\n cgraph_node::function_version (void)\n {\n-  struct cgraph_function_version_info *ret;\n-  struct cgraph_function_version_info key;\n+  cgraph_function_version_info *ret;\n+  cgraph_function_version_info key;\n   key.this_node = this;\n \n   if (cgraph_fnver_htab == NULL)\n     return NULL;\n \n-  ret = (struct cgraph_function_version_info *)\n+  ret = (cgraph_function_version_info *)\n     htab_find (cgraph_fnver_htab, &key);\n \n   return ret;\n }\n \n /* Insert a new cgraph_function_version_info node into cgraph_fnver_htab\n    corresponding to cgraph_node NODE.  */\n-struct cgraph_function_version_info *\n+cgraph_function_version_info *\n cgraph_node::insert_new_function_version (void)\n {\n   void **slot;\n@@ -216,8 +177,8 @@ cgraph_node::insert_new_function_version (void)\n void\n cgraph_node::delete_function_version (tree decl)\n {\n-  struct cgraph_node *decl_node = cgraph_node::get (decl);\n-  struct cgraph_function_version_info *decl_v = NULL;\n+  cgraph_node *decl_node = cgraph_node::get (decl);\n+  cgraph_function_version_info *decl_v = NULL;\n \n   if (decl_node == NULL)\n     return;\n@@ -244,12 +205,12 @@ cgraph_node::delete_function_version (tree decl)\n void\n cgraph_node::record_function_versions (tree decl1, tree decl2)\n {\n-  struct cgraph_node *decl1_node = cgraph_node::get_create (decl1);\n-  struct cgraph_node *decl2_node = cgraph_node::get_create (decl2);\n-  struct cgraph_function_version_info *decl1_v = NULL;\n-  struct cgraph_function_version_info *decl2_v = NULL;\n-  struct cgraph_function_version_info *before;\n-  struct cgraph_function_version_info *after;\n+  cgraph_node *decl1_node = cgraph_node::get_create (decl1);\n+  cgraph_node *decl2_node = cgraph_node::get_create (decl2);\n+  cgraph_function_version_info *decl1_v = NULL;\n+  cgraph_function_version_info *decl2_v = NULL;\n+  cgraph_function_version_info *before;\n+  cgraph_function_version_info *after;\n \n   gcc_assert (decl1_node != NULL && decl2_node != NULL);\n   decl1_v = decl1_node->function_version ();\n@@ -280,20 +241,14 @@ cgraph_node::record_function_versions (tree decl1, tree decl2)\n   after->prev = before;\n }\n \n-/* Macros to access the next item in the list of free cgraph nodes and\n-   edges. */\n-#define NEXT_FREE_NODE(NODE) dyn_cast<cgraph_node *> ((NODE)->next)\n-#define SET_NEXT_FREE_NODE(NODE,NODE2) ((NODE))->next = NODE2\n-#define NEXT_FREE_EDGE(EDGE) (EDGE)->prev_caller\n-\n /* Register HOOK to be called with DATA on each removed edge.  */\n-struct cgraph_edge_hook_list *\n-cgraph_add_edge_removal_hook (cgraph_edge_hook hook, void *data)\n+cgraph_edge_hook_list *\n+symbol_table::add_edge_removal_hook (cgraph_edge_hook hook, void *data)\n {\n-  struct cgraph_edge_hook_list *entry;\n-  struct cgraph_edge_hook_list **ptr = &first_cgraph_edge_removal_hook;\n+  cgraph_edge_hook_list *entry;\n+  cgraph_edge_hook_list **ptr = &m_first_edge_removal_hook;\n \n-  entry = (struct cgraph_edge_hook_list *) xmalloc (sizeof (*entry));\n+  entry = (cgraph_edge_hook_list *) xmalloc (sizeof (*entry));\n   entry->hook = hook;\n   entry->data = data;\n   entry->next = NULL;\n@@ -305,9 +260,9 @@ cgraph_add_edge_removal_hook (cgraph_edge_hook hook, void *data)\n \n /* Remove ENTRY from the list of hooks called on removing edges.  */\n void\n-cgraph_remove_edge_removal_hook (struct cgraph_edge_hook_list *entry)\n+symbol_table::remove_edge_removal_hook (cgraph_edge_hook_list *entry)\n {\n-  struct cgraph_edge_hook_list **ptr = &first_cgraph_edge_removal_hook;\n+  cgraph_edge_hook_list **ptr = &m_first_edge_removal_hook;\n \n   while (*ptr != entry)\n     ptr = &(*ptr)->next;\n@@ -316,10 +271,10 @@ cgraph_remove_edge_removal_hook (struct cgraph_edge_hook_list *entry)\n }\n \n /* Call all edge removal hooks.  */\n-static void\n-cgraph_call_edge_removal_hooks (struct cgraph_edge *e)\n+void\n+symbol_table::call_edge_removal_hooks (cgraph_edge *e)\n {\n-  struct cgraph_edge_hook_list *entry = first_cgraph_edge_removal_hook;\n+  cgraph_edge_hook_list *entry = m_first_edge_removal_hook;\n   while (entry)\n   {\n     entry->hook (e, entry->data);\n@@ -328,13 +283,13 @@ cgraph_call_edge_removal_hooks (struct cgraph_edge *e)\n }\n \n /* Register HOOK to be called with DATA on each removed node.  */\n-struct cgraph_node_hook_list *\n-cgraph_add_node_removal_hook (cgraph_node_hook hook, void *data)\n+cgraph_node_hook_list *\n+symbol_table::add_cgraph_removal_hook (cgraph_node_hook hook, void *data)\n {\n-  struct cgraph_node_hook_list *entry;\n-  struct cgraph_node_hook_list **ptr = &first_cgraph_node_removal_hook;\n+  cgraph_node_hook_list *entry;\n+  cgraph_node_hook_list **ptr = &m_first_cgraph_removal_hook;\n \n-  entry = (struct cgraph_node_hook_list *) xmalloc (sizeof (*entry));\n+  entry = (cgraph_node_hook_list *) xmalloc (sizeof (*entry));\n   entry->hook = hook;\n   entry->data = data;\n   entry->next = NULL;\n@@ -346,9 +301,9 @@ cgraph_add_node_removal_hook (cgraph_node_hook hook, void *data)\n \n /* Remove ENTRY from the list of hooks called on removing nodes.  */\n void\n-cgraph_remove_node_removal_hook (struct cgraph_node_hook_list *entry)\n+symbol_table::remove_cgraph_removal_hook (cgraph_node_hook_list *entry)\n {\n-  struct cgraph_node_hook_list **ptr = &first_cgraph_node_removal_hook;\n+  cgraph_node_hook_list **ptr = &m_first_cgraph_removal_hook;\n \n   while (*ptr != entry)\n     ptr = &(*ptr)->next;\n@@ -357,25 +312,38 @@ cgraph_remove_node_removal_hook (struct cgraph_node_hook_list *entry)\n }\n \n /* Call all node removal hooks.  */\n-static void\n-cgraph_call_node_removal_hooks (struct cgraph_node *node)\n+void\n+symbol_table::call_cgraph_removal_hooks (cgraph_node *node)\n {\n-  struct cgraph_node_hook_list *entry = first_cgraph_node_removal_hook;\n+  cgraph_node_hook_list *entry = m_first_cgraph_removal_hook;\n   while (entry)\n   {\n     entry->hook (node, entry->data);\n     entry = entry->next;\n   }\n }\n \n+/* Call all node removal hooks.  */\n+void\n+symbol_table::call_cgraph_insertion_hooks (cgraph_node *node)\n+{\n+  cgraph_node_hook_list *entry = m_first_cgraph_insertion_hook;\n+  while (entry)\n+  {\n+    entry->hook (node, entry->data);\n+    entry = entry->next;\n+  }\n+}\n+\n+\n /* Register HOOK to be called with DATA on each inserted node.  */\n-struct cgraph_node_hook_list *\n-cgraph_add_function_insertion_hook (cgraph_node_hook hook, void *data)\n+cgraph_node_hook_list *\n+symbol_table::add_cgraph_insertion_hook (cgraph_node_hook hook, void *data)\n {\n-  struct cgraph_node_hook_list *entry;\n-  struct cgraph_node_hook_list **ptr = &first_cgraph_function_insertion_hook;\n+  cgraph_node_hook_list *entry;\n+  cgraph_node_hook_list **ptr = &m_first_cgraph_insertion_hook;\n \n-  entry = (struct cgraph_node_hook_list *) xmalloc (sizeof (*entry));\n+  entry = (cgraph_node_hook_list *) xmalloc (sizeof (*entry));\n   entry->hook = hook;\n   entry->data = data;\n   entry->next = NULL;\n@@ -387,36 +355,24 @@ cgraph_add_function_insertion_hook (cgraph_node_hook hook, void *data)\n \n /* Remove ENTRY from the list of hooks called on inserted nodes.  */\n void\n-cgraph_remove_function_insertion_hook (struct cgraph_node_hook_list *entry)\n+symbol_table::remove_cgraph_insertion_hook (cgraph_node_hook_list *entry)\n {\n-  struct cgraph_node_hook_list **ptr = &first_cgraph_function_insertion_hook;\n+  cgraph_node_hook_list **ptr = &m_first_cgraph_insertion_hook;\n \n   while (*ptr != entry)\n     ptr = &(*ptr)->next;\n   *ptr = entry->next;\n   free (entry);\n }\n \n-/* Call all node insertion hooks.  */\n-void\n-cgraph_node::call_function_insertion_hooks (void)\n-{\n-  struct cgraph_node_hook_list *entry = first_cgraph_function_insertion_hook;\n-  while (entry)\n-  {\n-    entry->hook (this, entry->data);\n-    entry = entry->next;\n-  }\n-}\n-\n /* Register HOOK to be called with DATA on each duplicated edge.  */\n-struct cgraph_2edge_hook_list *\n-cgraph_add_edge_duplication_hook (cgraph_2edge_hook hook, void *data)\n+cgraph_2edge_hook_list *\n+symbol_table::add_edge_duplication_hook (cgraph_2edge_hook hook, void *data)\n {\n-  struct cgraph_2edge_hook_list *entry;\n-  struct cgraph_2edge_hook_list **ptr = &first_cgraph_edge_duplicated_hook;\n+  cgraph_2edge_hook_list *entry;\n+  cgraph_2edge_hook_list **ptr = &m_first_edge_duplicated_hook;\n \n-  entry = (struct cgraph_2edge_hook_list *) xmalloc (sizeof (*entry));\n+  entry = (cgraph_2edge_hook_list *) xmalloc (sizeof (*entry));\n   entry->hook = hook;\n   entry->data = data;\n   entry->next = NULL;\n@@ -428,9 +384,9 @@ cgraph_add_edge_duplication_hook (cgraph_2edge_hook hook, void *data)\n \n /* Remove ENTRY from the list of hooks called on duplicating edges.  */\n void\n-cgraph_remove_edge_duplication_hook (struct cgraph_2edge_hook_list *entry)\n+symbol_table::remove_edge_duplication_hook (cgraph_2edge_hook_list *entry)\n {\n-  struct cgraph_2edge_hook_list **ptr = &first_cgraph_edge_duplicated_hook;\n+  cgraph_2edge_hook_list **ptr = &m_first_edge_duplicated_hook;\n \n   while (*ptr != entry)\n     ptr = &(*ptr)->next;\n@@ -440,10 +396,9 @@ cgraph_remove_edge_duplication_hook (struct cgraph_2edge_hook_list *entry)\n \n /* Call all edge duplication hooks.  */\n void\n-cgraph_call_edge_duplication_hooks (struct cgraph_edge *cs1,\n-\t\t\t\t    struct cgraph_edge *cs2)\n+symbol_table::call_edge_duplication_hooks (cgraph_edge *cs1, cgraph_edge *cs2)\n {\n-  struct cgraph_2edge_hook_list *entry = first_cgraph_edge_duplicated_hook;\n+  cgraph_2edge_hook_list *entry = m_first_edge_duplicated_hook;\n   while (entry)\n   {\n     entry->hook (cs1, cs2, entry->data);\n@@ -452,13 +407,13 @@ cgraph_call_edge_duplication_hooks (struct cgraph_edge *cs1,\n }\n \n /* Register HOOK to be called with DATA on each duplicated node.  */\n-struct cgraph_2node_hook_list *\n-cgraph_add_node_duplication_hook (cgraph_2node_hook hook, void *data)\n+cgraph_2node_hook_list *\n+symbol_table::add_cgraph_duplication_hook (cgraph_2node_hook hook, void *data)\n {\n-  struct cgraph_2node_hook_list *entry;\n-  struct cgraph_2node_hook_list **ptr = &first_cgraph_node_duplicated_hook;\n+  cgraph_2node_hook_list *entry;\n+  cgraph_2node_hook_list **ptr = &m_first_cgraph_duplicated_hook;\n \n-  entry = (struct cgraph_2node_hook_list *) xmalloc (sizeof (*entry));\n+  entry = (cgraph_2node_hook_list *) xmalloc (sizeof (*entry));\n   entry->hook = hook;\n   entry->data = data;\n   entry->next = NULL;\n@@ -470,9 +425,9 @@ cgraph_add_node_duplication_hook (cgraph_2node_hook hook, void *data)\n \n /* Remove ENTRY from the list of hooks called on duplicating nodes.  */\n void\n-cgraph_remove_node_duplication_hook (struct cgraph_2node_hook_list *entry)\n+symbol_table::remove_cgraph_duplication_hook (cgraph_2node_hook_list *entry)\n {\n-  struct cgraph_2node_hook_list **ptr = &first_cgraph_node_duplicated_hook;\n+  cgraph_2node_hook_list **ptr = &m_first_cgraph_duplicated_hook;\n \n   while (*ptr != entry)\n     ptr = &(*ptr)->next;\n@@ -482,57 +437,23 @@ cgraph_remove_node_duplication_hook (struct cgraph_2node_hook_list *entry)\n \n /* Call all node duplication hooks.  */\n void\n-cgraph_node::call_duplication_hooks (struct cgraph_node *node2)\n+symbol_table::call_cgraph_duplication_hooks (cgraph_node *node,\n+\t\t\t\t\t     cgraph_node *node2)\n {\n-  struct cgraph_2node_hook_list *entry = first_cgraph_node_duplicated_hook;\n+  cgraph_2node_hook_list *entry = m_first_cgraph_duplicated_hook;\n   while (entry)\n   {\n-    entry->hook (this, node2, entry->data);\n+    entry->hook (node, node2, entry->data);\n     entry = entry->next;\n   }\n }\n \n-/* Allocate new callgraph node.  */\n-\n-static inline struct cgraph_node *\n-cgraph_allocate_node (void)\n-{\n-  struct cgraph_node *node;\n-\n-  if (free_nodes)\n-    {\n-      node = free_nodes;\n-      free_nodes = NEXT_FREE_NODE (node);\n-    }\n-  else\n-    {\n-      node = ggc_cleared_alloc<cgraph_node> ();\n-      node->uid = cgraph_max_uid++;\n-    }\n-\n-  return node;\n-}\n-\n-/* Allocate new callgraph node and insert it into basic data structures.  */\n-\n-cgraph_node *\n-cgraph_node::create_empty (void)\n-{\n-  struct cgraph_node *node = cgraph_allocate_node ();\n-\n-  node->type = SYMTAB_FUNCTION;\n-  node->frequency = NODE_FREQUENCY_NORMAL;\n-  node->count_materialization_scale = REG_BR_PROB_BASE;\n-  cgraph_n_nodes++;\n-  return node;\n-}\n-\n /* Return cgraph node assigned to DECL.  Create new one when needed.  */\n \n cgraph_node *\n cgraph_node::create (tree decl)\n {\n-  struct cgraph_node *node = cgraph_node::create_empty ();\n+  cgraph_node *node = symtab->create_empty ();\n   gcc_assert (TREE_CODE (decl) == FUNCTION_DECL);\n \n   node->decl = decl;\n@@ -553,17 +474,17 @@ cgraph_node::create (tree decl)\n cgraph_node *\n cgraph_node::get_create (tree decl)\n {\n-  struct cgraph_node *first_clone = cgraph_node::get (decl);\n+  cgraph_node *first_clone = cgraph_node::get (decl);\n \n   if (first_clone && !first_clone->global.inlined_to)\n     return first_clone;\n \n-  struct cgraph_node *node = cgraph_node::create (decl);\n+  cgraph_node *node = cgraph_node::create (decl);\n   if (first_clone)\n     {\n       first_clone->clone_of = node;\n       node->clones = first_clone;\n-      symtab_prevail_in_asm_name_hash (node);\n+      symtab->symtab_prevail_in_asm_name_hash (node);\n       node->decl->decl_with_vis.symtab_node = node;\n       if (dump_file)\n \tfprintf (dump_file, \"Introduced new external node \"\n@@ -604,22 +525,22 @@ cgraph_node::create_alias (tree alias, tree target)\n    and cgraph_node::get (ALIAS) transparently returns\n    cgraph_node::get (DECL).  */\n \n-struct cgraph_node *\n+cgraph_node *\n cgraph_node::create_same_body_alias (tree alias, tree decl)\n {\n-  struct cgraph_node *n;\n+  cgraph_node *n;\n #ifndef ASM_OUTPUT_DEF\n   /* If aliases aren't supported by the assembler, fail.  */\n   return NULL;\n #endif\n   /* Langhooks can create same body aliases of symbols not defined.\n      Those are useless. Drop them on the floor.  */\n-  if (cgraph_global_info_ready)\n+  if (symtab->global_info_ready)\n     return NULL;\n \n   n = cgraph_node::create_alias (alias, decl);\n   n->cpp_implicit_alias = true;\n-  if (cpp_implicit_aliases_done)\n+  if (symtab->cpp_implicit_aliases_done)\n     n->resolve_alias (cgraph_node::get (decl));\n   return n;\n }\n@@ -628,14 +549,14 @@ cgraph_node::create_same_body_alias (tree alias, tree decl)\n    aliases DECL with an adjustments made into the first parameter.\n    See comments in thunk_adjust for detail on the parameters.  */\n \n-struct cgraph_node *\n+cgraph_node *\n cgraph_node::create_thunk (tree alias, tree, bool this_adjusting,\n \t\t\t   HOST_WIDE_INT fixed_offset,\n \t\t\t   HOST_WIDE_INT virtual_value,\n \t\t\t   tree virtual_offset,\n \t\t\t   tree real_alias)\n {\n-  struct cgraph_node *node;\n+  cgraph_node *node;\n \n   node = cgraph_node::get (alias);\n   if (node)\n@@ -662,7 +583,7 @@ cgraph_node *\n cgraph_node::get_for_asmname (tree asmname)\n {\n   /* We do not want to look at inline clones.  */\n-  for (symtab_node *node = symtab_node_for_asm (asmname);\n+  for (symtab_node *node = symtab_node::get_for_asmname (asmname);\n        node;\n        node = node->next_sharing_asm_name)\n     {\n@@ -678,21 +599,21 @@ cgraph_node::get_for_asmname (tree asmname)\n static hashval_t\n edge_hash (const void *x)\n {\n-  return htab_hash_pointer (((const struct cgraph_edge *) x)->call_stmt);\n+  return htab_hash_pointer (((const cgraph_edge *) x)->call_stmt);\n }\n \n /* Return nonzero if the call_stmt of of cgraph_edge X is stmt *Y.  */\n \n static int\n edge_eq (const void *x, const void *y)\n {\n-  return ((const struct cgraph_edge *) x)->call_stmt == y;\n+  return ((const cgraph_edge *) x)->call_stmt == y;\n }\n \n /* Add call graph edge E to call site hash of its caller.  */\n \n static inline void\n-cgraph_update_edge_in_call_site_hash (struct cgraph_edge *e)\n+cgraph_update_edge_in_call_site_hash (cgraph_edge *e)\n {\n   void **slot;\n   slot = htab_find_slot_with_hash (e->caller->call_site_hash,\n@@ -705,7 +626,7 @@ cgraph_update_edge_in_call_site_hash (struct cgraph_edge *e)\n /* Add call graph edge E to call site hash of its caller.  */\n \n static inline void\n-cgraph_add_edge_to_call_site_hash (struct cgraph_edge *e)\n+cgraph_add_edge_to_call_site_hash (cgraph_edge *e)\n {\n   void **slot;\n   /* There are two speculative edges for every statement (one direct,\n@@ -718,7 +639,7 @@ cgraph_add_edge_to_call_site_hash (struct cgraph_edge *e)\n \t\t\t\t   INSERT);\n   if (*slot)\n     {\n-      gcc_assert (((struct cgraph_edge *)*slot)->speculative);\n+      gcc_assert (((cgraph_edge *)*slot)->speculative);\n       if (e->callee)\n \t*slot = e;\n       return;\n@@ -733,11 +654,11 @@ cgraph_add_edge_to_call_site_hash (struct cgraph_edge *e)\n cgraph_edge *\n cgraph_node::get_edge (gimple call_stmt)\n {\n-  struct cgraph_edge *e, *e2;\n+  cgraph_edge *e, *e2;\n   int n = 0;\n \n   if (call_site_hash)\n-    return (struct cgraph_edge *)\n+    return (cgraph_edge *)\n       htab_find_with_hash (call_site_hash, call_stmt,\n       \t                   htab_hash_pointer (call_stmt));\n \n@@ -774,49 +695,50 @@ cgraph_node::get_edge (gimple call_stmt)\n }\n \n \n-/* Change field call_stmt of edge E to NEW_STMT.\n+/* Change field call_stmt of edge to NEW_STMT.\n    If UPDATE_SPECULATIVE and E is any component of speculative\n    edge, then update all components.  */\n \n void\n-cgraph_set_call_stmt (struct cgraph_edge *e, gimple new_stmt,\n-\t\t      bool update_speculative)\n+cgraph_edge::set_call_stmt (gimple new_stmt, bool update_speculative)\n {\n   tree decl;\n \n   /* Speculative edges has three component, update all of them\n      when asked to.  */\n-  if (update_speculative && e->speculative)\n+  if (update_speculative && speculative)\n     {\n-      struct cgraph_edge *direct, *indirect;\n-      struct ipa_ref *ref;\n+      cgraph_edge *direct, *indirect;\n+      ipa_ref *ref;\n \n-      cgraph_speculative_call_info (e, direct, indirect, ref);\n-      cgraph_set_call_stmt (direct, new_stmt, false);\n-      cgraph_set_call_stmt (indirect, new_stmt, false);\n+      speculative_call_info (direct, indirect, ref);\n+      direct->set_call_stmt (new_stmt, false);\n+      indirect->set_call_stmt (new_stmt, false);\n       ref->stmt = new_stmt;\n       return;\n     }\n \n   /* Only direct speculative edges go to call_site_hash.  */\n-  if (e->caller->call_site_hash\n-      && (!e->speculative || !e->indirect_unknown_callee))\n+  if (caller->call_site_hash\n+      && (!speculative || !indirect_unknown_callee))\n     {\n-      htab_remove_elt_with_hash (e->caller->call_site_hash,\n-\t\t\t\t e->call_stmt,\n-\t\t\t\t htab_hash_pointer (e->call_stmt));\n+      htab_remove_elt_with_hash (caller->call_site_hash,\n+\t\t\t\t call_stmt,\n+\t\t\t\t htab_hash_pointer (call_stmt));\n     }\n \n-  e->call_stmt = new_stmt;\n-  if (e->indirect_unknown_callee\n+  cgraph_edge *e = this;\n+\n+  call_stmt = new_stmt;\n+  if (indirect_unknown_callee\n       && (decl = gimple_call_fndecl (new_stmt)))\n     {\n       /* Constant propagation (and possibly also inlining?) can turn an\n \t indirect call into a direct one.  */\n-      struct cgraph_node *new_callee = cgraph_node::get (decl);\n+      cgraph_node *new_callee = cgraph_node::get (decl);\n \n       gcc_checking_assert (new_callee);\n-      e = cgraph_make_edge_direct (e, new_callee);\n+      e = make_direct (new_callee);\n     }\n \n   push_cfun (DECL_STRUCT_FUNCTION (e->caller->decl));\n@@ -831,9 +753,9 @@ cgraph_set_call_stmt (struct cgraph_edge *e, gimple new_stmt,\n    edge).  */\n \n cgraph_edge *\n-cgraph_node::create_edge (cgraph_node *caller, cgraph_node *callee,\n-\t\t\t  gimple call_stmt, gcov_type count, int freq,\n-\t\t\t  bool indir_unknown_callee)\n+symbol_table::create_edge (cgraph_node *caller, cgraph_node *callee,\n+\t\t     gimple call_stmt, gcov_type count, int freq,\n+\t\t     bool indir_unknown_callee)\n {\n   cgraph_edge *edge;\n \n@@ -844,7 +766,7 @@ cgraph_node::create_edge (cgraph_node *caller, cgraph_node *callee,\n       /* This is a rather expensive check possibly triggering\n \t construction of call stmt hashtable.  */\n #ifdef ENABLE_CHECKING\n-      struct cgraph_edge *e;\n+      cgraph_edge *e;\n       gcc_checking_assert (\n \t!(e = caller->get_edge (call_stmt)) || e->speculative);\n #endif\n@@ -859,10 +781,12 @@ cgraph_node::create_edge (cgraph_node *caller, cgraph_node *callee,\n     }\n   else\n     {\n-      edge = ggc_alloc<struct cgraph_edge> ();\n-      edge->uid = cgraph_edge_max_uid++;\n+      edge = ggc_alloc<cgraph_edge> ();\n+      edge->uid = edges_max_uid++;\n     }\n \n+  edges_count++;\n+\n   edge->aux = NULL;\n   edge->caller = caller;\n   edge->callee = callee;\n@@ -903,12 +827,12 @@ cgraph_node::create_edge (cgraph_node *caller, cgraph_node *callee,\n \n /* Create edge from a given function to CALLEE in the cgraph.  */\n \n-struct cgraph_edge *\n-cgraph_node::create_edge (struct cgraph_node *callee,\n+cgraph_edge *\n+cgraph_node::create_edge (cgraph_node *callee,\n \t\t\t  gimple call_stmt, gcov_type count, int freq)\n {\n-  cgraph_edge *edge = cgraph_node::create_edge (this, callee, call_stmt,\n-\t\t\t\t\t\tcount, freq, false);\n+  cgraph_edge *edge = symtab->create_edge (this, callee, call_stmt, count,\n+\t\t\t\t\t   freq, false);\n \n   initialize_inline_failed (edge);\n \n@@ -926,10 +850,10 @@ cgraph_node::create_edge (struct cgraph_node *callee,\n \n /* Allocate cgraph_indirect_call_info and set its fields to default values. */\n \n-struct cgraph_indirect_call_info *\n+cgraph_indirect_call_info *\n cgraph_allocate_init_indirect_info (void)\n {\n-  struct cgraph_indirect_call_info *ii;\n+  cgraph_indirect_call_info *ii;\n \n   ii = ggc_cleared_alloc<cgraph_indirect_call_info> ();\n   ii->param_index = -1;\n@@ -940,13 +864,13 @@ cgraph_allocate_init_indirect_info (void)\n    statement destination is a formal parameter of the caller with index\n    PARAM_INDEX. */\n \n-struct cgraph_edge *\n+cgraph_edge *\n cgraph_node::create_indirect_edge (gimple call_stmt, int ecf_flags,\n \t\t\t\t   gcov_type count, int freq,\n \t\t\t\t   bool compute_indirect_info)\n {\n-  struct cgraph_edge *edge = cgraph_node::create_edge (this, NULL, call_stmt,\n-\t\t\t\t\t\t       count, freq, true);\n+  cgraph_edge *edge = symtab->create_edge (this, NULL, call_stmt,\n+\t\t\t\t\t\t\t    count, freq, true);\n   tree target;\n \n   initialize_inline_failed (edge);\n@@ -995,46 +919,46 @@ cgraph_node::create_indirect_edge (gimple call_stmt, int ecf_flags,\n   return edge;\n }\n \n-/* Remove the edge E from the list of the callers of the callee.  */\n+/* Remove the edge from the list of the callers of the callee.  */\n \n-static inline void\n-cgraph_edge_remove_callee (struct cgraph_edge *e)\n+void\n+cgraph_edge::remove_callee (void)\n {\n-  gcc_assert (!e->indirect_unknown_callee);\n-  if (e->prev_caller)\n-    e->prev_caller->next_caller = e->next_caller;\n-  if (e->next_caller)\n-    e->next_caller->prev_caller = e->prev_caller;\n-  if (!e->prev_caller)\n-    e->callee->callers = e->next_caller;\n+  gcc_assert (!indirect_unknown_callee);\n+  if (prev_caller)\n+    prev_caller->next_caller = next_caller;\n+  if (next_caller)\n+    next_caller->prev_caller = prev_caller;\n+  if (!prev_caller)\n+    callee->callers = next_caller;\n }\n \n-/* Remove the edge E from the list of the callees of the caller.  */\n+/* Remove the edge from the list of the callees of the caller.  */\n \n-static inline void\n-cgraph_edge_remove_caller (struct cgraph_edge *e)\n+void\n+cgraph_edge::remove_caller (void)\n {\n-  if (e->prev_callee)\n-    e->prev_callee->next_callee = e->next_callee;\n-  if (e->next_callee)\n-    e->next_callee->prev_callee = e->prev_callee;\n-  if (!e->prev_callee)\n+  if (prev_callee)\n+    prev_callee->next_callee = next_callee;\n+  if (next_callee)\n+    next_callee->prev_callee = prev_callee;\n+  if (!prev_callee)\n     {\n-      if (e->indirect_unknown_callee)\n-\te->caller->indirect_calls = e->next_callee;\n+      if (indirect_unknown_callee)\n+\tcaller->indirect_calls = next_callee;\n       else\n-\te->caller->callees = e->next_callee;\n+\tcaller->callees = next_callee;\n     }\n-  if (e->caller->call_site_hash)\n-    htab_remove_elt_with_hash (e->caller->call_site_hash,\n-\t\t\t       e->call_stmt,\n-\t  \t\t       htab_hash_pointer (e->call_stmt));\n+  if (caller->call_site_hash)\n+    htab_remove_elt_with_hash (caller->call_site_hash,\n+\t\t\t       call_stmt,\n+\t\t\t       htab_hash_pointer (call_stmt));\n }\n \n /* Put the edge onto the free list.  */\n \n-static void\n-cgraph_free_edge (struct cgraph_edge *e)\n+void\n+symbol_table::free_edge (cgraph_edge *e)\n {\n   int uid = e->uid;\n \n@@ -1046,32 +970,33 @@ cgraph_free_edge (struct cgraph_edge *e)\n   e->uid = uid;\n   NEXT_FREE_EDGE (e) = free_edges;\n   free_edges = e;\n+  edges_count--;\n }\n \n-/* Remove the edge E in the cgraph.  */\n+/* Remove the edge in the cgraph.  */\n \n void\n-cgraph_remove_edge (struct cgraph_edge *e)\n+cgraph_edge::remove (void)\n {\n   /* Call all edge removal hooks.  */\n-  cgraph_call_edge_removal_hooks (e);\n+  symtab->call_edge_removal_hooks (this);\n \n-  if (!e->indirect_unknown_callee)\n+  if (!indirect_unknown_callee)\n     /* Remove from callers list of the callee.  */\n-    cgraph_edge_remove_callee (e);\n+    remove_callee ();\n \n   /* Remove from callees list of the callers.  */\n-  cgraph_edge_remove_caller (e);\n+  remove_caller ();\n \n   /* Put the edge onto the free list.  */\n-  cgraph_free_edge (e);\n+  symtab->free_edge (this);\n }\n \n /* Set callee of call graph edge E and add it to the corresponding set of\n    callers. */\n \n static void\n-cgraph_set_edge_callee (struct cgraph_edge *e, struct cgraph_node *n)\n+cgraph_set_edge_callee (cgraph_edge *e, cgraph_node *n)\n {\n   e->prev_caller = NULL;\n   if (n->callers)\n@@ -1081,7 +1006,7 @@ cgraph_set_edge_callee (struct cgraph_edge *e, struct cgraph_node *n)\n   e->callee = n;\n }\n \n-/* Turn edge E into speculative call calling N2. Update\n+/* Turn edge into speculative call calling N2. Update\n    the profile so the direct call is taken COUNT times\n    with FREQUENCY.  \n \n@@ -1099,15 +1024,13 @@ cgraph_set_edge_callee (struct cgraph_edge *e, struct cgraph_node *n)\n \n    Return direct edge created.  */\n \n-struct cgraph_edge *\n-cgraph_turn_edge_to_speculative (struct cgraph_edge *e,\n-\t\t\t\t struct cgraph_node *n2,\n-\t\t\t\t gcov_type direct_count,\n-\t\t\t\t int direct_frequency)\n+cgraph_edge *\n+cgraph_edge::make_speculative (cgraph_node *n2, gcov_type direct_count,\n+\t\t\t       int direct_frequency)\n {\n-  struct cgraph_node *n = e->caller;\n-  struct ipa_ref *ref = NULL;\n-  struct cgraph_edge *e2;\n+  cgraph_node *n = caller;\n+  ipa_ref *ref = NULL;\n+  cgraph_edge *e2;\n \n   if (dump_file)\n     {\n@@ -1116,21 +1039,21 @@ cgraph_turn_edge_to_speculative (struct cgraph_edge *e,\n \t       xstrdup (n->name ()), n->order,\n \t       xstrdup (n2->name ()), n2->order);\n     }\n-  e->speculative = true;\n-  e2 = n->create_edge (n2, e->call_stmt, direct_count, direct_frequency);\n+  speculative = true;\n+  e2 = n->create_edge (n2, call_stmt, direct_count, direct_frequency);\n   initialize_inline_failed (e2);\n   e2->speculative = true;\n   if (TREE_NOTHROW (n2->decl))\n     e2->can_throw_external = false;\n   else\n-    e2->can_throw_external = e->can_throw_external;\n-  e2->lto_stmt_uid = e->lto_stmt_uid;\n-  e->count -= e2->count;\n-  e->frequency -= e2->frequency;\n-  cgraph_call_edge_duplication_hooks (e, e2);\n-  ref = n->add_reference (n2, IPA_REF_ADDR, e->call_stmt);\n-  ref->lto_stmt_uid = e->lto_stmt_uid;\n-  ref->speculative = e->speculative;\n+    e2->can_throw_external = can_throw_external;\n+  e2->lto_stmt_uid = lto_stmt_uid;\n+  count -= e2->count;\n+  frequency -= e2->frequency;\n+  symtab->call_edge_duplication_hooks (this, e2);\n+  ref = n->create_reference (n2, IPA_REF_ADDR, call_stmt);\n+  ref->lto_stmt_uid = lto_stmt_uid;\n+  ref->speculative = speculative;\n   n2->mark_address_taken ();\n   return e2;\n }\n@@ -1142,18 +1065,18 @@ cgraph_turn_edge_to_speculative (struct cgraph_edge *e,\n    All three components are attached to single statement (the indirect\n    call) and if one of them exists, all of them must exist.\n \n-   Given speculative call edge E, return all three components. \n+   Given speculative call edge, return all three components.\n  */\n \n void\n-cgraph_speculative_call_info (struct cgraph_edge *e,\n-\t\t\t      struct cgraph_edge *&direct,\n-\t\t\t      struct cgraph_edge *&indirect,\n-\t\t\t      struct ipa_ref *&reference)\n+cgraph_edge::speculative_call_info (cgraph_edge *&direct,\n+\t\t\t\t    cgraph_edge *&indirect,\n+\t\t\t\t    ipa_ref *&reference)\n {\n-  struct ipa_ref *ref;\n+  ipa_ref *ref;\n   int i;\n-  struct cgraph_edge *e2;\n+  cgraph_edge *e2;\n+  cgraph_edge *e = this;\n \n   if (!e->indirect_unknown_callee)\n     for (e2 = e->caller->indirect_calls;\n@@ -1196,31 +1119,32 @@ cgraph_speculative_call_info (struct cgraph_edge *e,\n   gcc_assert (e && e2 && ref);\n }\n \n-/* Redirect callee of E to N.  The function does not update underlying\n+/* Redirect callee of the edge to N.  The function does not update underlying\n    call expression.  */\n \n void\n-cgraph_redirect_edge_callee (struct cgraph_edge *e, struct cgraph_node *n)\n+cgraph_edge::redirect_callee (cgraph_node *n)\n {\n   /* Remove from callers list of the current callee.  */\n-  cgraph_edge_remove_callee (e);\n+  remove_callee ();\n \n   /* Insert to callers list of the new callee.  */\n-  cgraph_set_edge_callee (e, n);\n+  cgraph_set_edge_callee (this, n);\n }\n \n-/* Speculative call EDGE turned out to be direct call to CALLE_DECL.\n+/* Speculative call edge turned out to be direct call to CALLE_DECL.\n    Remove the speculative call sequence and return edge representing the call.\n    It is up to caller to redirect the call as appropriate. */\n \n-struct cgraph_edge *\n-cgraph_resolve_speculation (struct cgraph_edge *edge, tree callee_decl)\n+cgraph_edge *\n+cgraph_edge::resolve_speculation (tree callee_decl)\n {\n-  struct cgraph_edge *e2;\n-  struct ipa_ref *ref;\n+  cgraph_edge *edge = this;\n+  cgraph_edge *e2;\n+  ipa_ref *ref;\n \n   gcc_assert (edge->speculative);\n-  cgraph_speculative_call_info (edge, e2, edge, ref);\n+  edge->speculative_call_info (e2, edge, ref);\n   if (!callee_decl\n       || !ref->referred->semantically_equivalent_p\n \t   (symtab_node::get (callee_decl)))\n@@ -1246,7 +1170,7 @@ cgraph_resolve_speculation (struct cgraph_edge *edge, tree callee_decl)\n     }\n   else\n     {\n-      struct cgraph_edge *tmp = edge;\n+      cgraph_edge *tmp = edge;\n       if (dump_file)\n         fprintf (dump_file, \"Speculative call turned into direct call.\\n\");\n       edge = e2;\n@@ -1262,58 +1186,59 @@ cgraph_resolve_speculation (struct cgraph_edge *edge, tree callee_decl)\n   e2->speculative = false;\n   ref->remove_reference ();\n   if (e2->indirect_unknown_callee || e2->inline_failed)\n-    cgraph_remove_edge (e2);\n+    e2->remove ();\n   else\n     e2->callee->remove_symbol_and_inline_clones ();\n   if (edge->caller->call_site_hash)\n     cgraph_update_edge_in_call_site_hash (edge);\n   return edge;\n }\n \n-/* Make an indirect EDGE with an unknown callee an ordinary edge leading to\n+/* Make an indirect edge with an unknown callee an ordinary edge leading to\n    CALLEE.  DELTA is an integer constant that is to be added to the this\n    pointer (first parameter) to compensate for skipping a thunk adjustment.  */\n \n-struct cgraph_edge *\n-cgraph_make_edge_direct (struct cgraph_edge *edge, struct cgraph_node *callee)\n+cgraph_edge *\n+cgraph_edge::make_direct (cgraph_node *callee)\n {\n-  gcc_assert (edge->indirect_unknown_callee);\n+  cgraph_edge *edge = this;\n+  gcc_assert (indirect_unknown_callee);\n \n   /* If we are redirecting speculative call, make it non-speculative.  */\n-  if (edge->indirect_unknown_callee && edge->speculative)\n+  if (indirect_unknown_callee && speculative)\n     {\n-      edge = cgraph_resolve_speculation (edge, callee->decl);\n+      edge = edge->resolve_speculation (callee->decl);\n \n       /* On successful speculation just return the pre existing direct edge.  */\n-      if (!edge->indirect_unknown_callee)\n+      if (!indirect_unknown_callee)\n         return edge;\n     }\n \n-  edge->indirect_unknown_callee = 0;\n-  ggc_free (edge->indirect_info);\n-  edge->indirect_info = NULL;\n+  indirect_unknown_callee = 0;\n+  ggc_free (indirect_info);\n+  indirect_info = NULL;\n \n   /* Get the edge out of the indirect edge list. */\n-  if (edge->prev_callee)\n-    edge->prev_callee->next_callee = edge->next_callee;\n-  if (edge->next_callee)\n-    edge->next_callee->prev_callee = edge->prev_callee;\n-  if (!edge->prev_callee)\n-    edge->caller->indirect_calls = edge->next_callee;\n+  if (prev_callee)\n+    prev_callee->next_callee = next_callee;\n+  if (next_callee)\n+    next_callee->prev_callee = prev_callee;\n+  if (!prev_callee)\n+    caller->indirect_calls = next_callee;\n \n   /* Put it into the normal callee list */\n-  edge->prev_callee = NULL;\n-  edge->next_callee = edge->caller->callees;\n-  if (edge->caller->callees)\n-    edge->caller->callees->prev_callee = edge;\n-  edge->caller->callees = edge;\n+  prev_callee = NULL;\n+  next_callee = caller->callees;\n+  if (caller->callees)\n+    caller->callees->prev_callee = edge;\n+  caller->callees = edge;\n \n   /* Insert to callers list of the new callee.  */\n   cgraph_set_edge_callee (edge, callee);\n \n-  if (edge->call_stmt)\n-    edge->call_stmt_cannot_inline_p\n-      = !gimple_check_call_matching_types (edge->call_stmt, callee->decl,\n+  if (call_stmt)\n+    call_stmt_cannot_inline_p\n+      = !gimple_check_call_matching_types (call_stmt, callee->decl,\n \t\t\t\t\t   false);\n \n   /* We need to re-determine the inlining status of the edge.  */\n@@ -1325,27 +1250,29 @@ cgraph_make_edge_direct (struct cgraph_edge *edge, struct cgraph_node *callee)\n    associated with E so that it corresponds to the edge callee.  */\n \n gimple\n-cgraph_redirect_edge_call_stmt_to_callee (struct cgraph_edge *e)\n+cgraph_edge::redirect_call_stmt_to_callee (void)\n {\n+  cgraph_edge *e = this;\n+\n   tree decl = gimple_call_fndecl (e->call_stmt);\n   tree lhs = gimple_call_lhs (e->call_stmt);\n   gimple new_stmt;\n   gimple_stmt_iterator gsi;\n #ifdef ENABLE_CHECKING\n-  struct cgraph_node *node;\n+  cgraph_node *node;\n #endif\n \n   if (e->speculative)\n     {\n-      struct cgraph_edge *e2;\n+      cgraph_edge *e2;\n       gimple new_stmt;\n-      struct ipa_ref *ref;\n+      ipa_ref *ref;\n \n-      cgraph_speculative_call_info (e, e, e2, ref);\n+      e->speculative_call_info (e, e2, ref);\n       /* If there already is an direct call (i.e. as a result of inliner's\n \t substitution), forget about speculating.  */\n       if (decl)\n-\te = cgraph_resolve_speculation (e, decl);\n+\te = e->resolve_speculation (decl);\n       /* If types do not match, speculation was likely wrong. \n          The direct edge was posisbly redirected to the clone with a different\n \t signature.  We did not update the call statement yet, so compare it \n@@ -1361,7 +1288,7 @@ cgraph_redirect_edge_call_stmt_to_callee (struct cgraph_edge *e)\n \t\t     e->caller->order,\n \t\t     xstrdup (e->callee->name ()),\n \t\t     e->callee->order);\n-\t  e = cgraph_resolve_speculation (e, NULL);\n+\t  e = e->resolve_speculation ();\n \t  /* We are producing the final function body and will throw away the\n \t     callgraph edges really soon.  Reset the counts/frequencies to\n \t     keep verifier happy in the case of roundoff errors.  */\n@@ -1423,16 +1350,16 @@ cgraph_redirect_edge_call_stmt_to_callee (struct cgraph_edge *e)\n     }\n #endif\n \n-  if (cgraph_dump_file)\n+  if (symtab->dump_file)\n     {\n-      fprintf (cgraph_dump_file, \"updating call of %s/%i -> %s/%i: \",\n+      fprintf (symtab->dump_file, \"updating call of %s/%i -> %s/%i: \",\n \t       xstrdup (e->caller->name ()), e->caller->order,\n \t       xstrdup (e->callee->name ()), e->callee->order);\n-      print_gimple_stmt (cgraph_dump_file, e->call_stmt, 0, dump_flags);\n+      print_gimple_stmt (symtab->dump_file, e->call_stmt, 0, dump_flags);\n       if (e->callee->clone.combined_args_to_skip)\n \t{\n-\t  fprintf (cgraph_dump_file, \" combined args to skip: \");\n-\t  dump_bitmap (cgraph_dump_file,\n+\t  fprintf (symtab->dump_file, \" combined args to skip: \");\n+\t  dump_bitmap (symtab->dump_file,\n \t\t       e->callee->clone.combined_args_to_skip);\n \t}\n     }\n@@ -1498,10 +1425,10 @@ cgraph_redirect_edge_call_stmt_to_callee (struct cgraph_edge *e)\n \n   e->caller->set_call_stmt_including_clones (e->call_stmt, new_stmt, false);\n \n-  if (cgraph_dump_file)\n+  if (symtab->dump_file)\n     {\n-      fprintf (cgraph_dump_file, \"  updated to:\");\n-      print_gimple_stmt (cgraph_dump_file, e->call_stmt, 0, dump_flags);\n+      fprintf (symtab->dump_file, \"  updated to:\");\n+      print_gimple_stmt (symtab->dump_file, e->call_stmt, 0, dump_flags);\n     }\n   return new_stmt;\n }\n@@ -1513,7 +1440,7 @@ cgraph_redirect_edge_call_stmt_to_callee (struct cgraph_edge *e)\n    replacement.  */\n \n static void\n-cgraph_update_edges_for_call_stmt_node (struct cgraph_node *node,\n+cgraph_update_edges_for_call_stmt_node (cgraph_node *node,\n \t\t\t\t\tgimple old_stmt, tree old_call,\n \t\t\t\t\tgimple new_stmt)\n {\n@@ -1527,8 +1454,8 @@ cgraph_update_edges_for_call_stmt_node (struct cgraph_node *node,\n      into different builtin.  */\n   if (old_call != new_call)\n     {\n-      struct cgraph_edge *e = node->get_edge (old_stmt);\n-      struct cgraph_edge *ne = NULL;\n+      cgraph_edge *e = node->get_edge (old_stmt);\n+      cgraph_edge *ne = NULL;\n       gcov_type count;\n       int frequency;\n \n@@ -1539,13 +1466,13 @@ cgraph_update_edges_for_call_stmt_node (struct cgraph_node *node,\n \t     it.  We also might've cloned and redirected the edge.  */\n \t  if (new_call && e->callee)\n \t    {\n-\t      struct cgraph_node *callee = e->callee;\n+\t      cgraph_node *callee = e->callee;\n \t      while (callee)\n \t\t{\n \t\t  if (callee->decl == new_call\n \t\t      || callee->former_clone_of == new_call)\n \t\t    {\n-\t\t      cgraph_set_call_stmt (e, new_stmt);\n+\t\t      e->set_call_stmt (new_stmt);\n \t\t      return;\n \t\t    }\n \t\t  callee = callee->clone_of;\n@@ -1558,7 +1485,7 @@ cgraph_update_edges_for_call_stmt_node (struct cgraph_node *node,\n \t  count = e->count;\n \t  frequency = e->frequency;\n  \t  if (e->indirect_unknown_callee || e->inline_failed)\n-\t    cgraph_remove_edge (e);\n+\t    e->remove ();\n \t  else\n \t    e->callee->remove_symbol_and_inline_clones ();\n \t}\n@@ -1580,7 +1507,7 @@ cgraph_update_edges_for_call_stmt_node (struct cgraph_node *node,\n     }\n   /* We only updated the call stmt; update pointer in cgraph edge..  */\n   else if (old_stmt != new_stmt)\n-    cgraph_set_call_stmt (node->get_edge (old_stmt), new_stmt);\n+    node->get_edge (old_stmt)->set_call_stmt (new_stmt);\n }\n \n /* Update or remove the corresponding cgraph edge if a GIMPLE_CALL\n@@ -1590,8 +1517,8 @@ cgraph_update_edges_for_call_stmt_node (struct cgraph_node *node,\n void\n cgraph_update_edges_for_call_stmt (gimple old_stmt, tree old_decl, gimple new_stmt)\n {\n-  struct cgraph_node *orig = cgraph_node::get (cfun->decl);\n-  struct cgraph_node *node;\n+  cgraph_node *orig = cgraph_node::get (cfun->decl);\n+  cgraph_node *node;\n \n   gcc_checking_assert (orig);\n   cgraph_update_edges_for_call_stmt_node (orig, old_stmt, old_decl, new_stmt);\n@@ -1619,26 +1546,26 @@ cgraph_update_edges_for_call_stmt (gimple old_stmt, tree old_decl, gimple new_st\n void\n cgraph_node::remove_callees (void)\n {\n-  struct cgraph_edge *e, *f;\n+  cgraph_edge *e, *f;\n \n   /* It is sufficient to remove the edges from the lists of callers of\n      the callees.  The callee list of the node can be zapped with one\n      assignment.  */\n   for (e = callees; e; e = f)\n     {\n       f = e->next_callee;\n-      cgraph_call_edge_removal_hooks (e);\n+      symtab->call_edge_removal_hooks (e);\n       if (!e->indirect_unknown_callee)\n-\tcgraph_edge_remove_callee (e);\n-      cgraph_free_edge (e);\n+\te->remove_callee ();\n+      symtab->free_edge (e);\n     }\n   for (e = indirect_calls; e; e = f)\n     {\n       f = e->next_callee;\n-      cgraph_call_edge_removal_hooks (e);\n+      symtab->call_edge_removal_hooks (e);\n       if (!e->indirect_unknown_callee)\n-\tcgraph_edge_remove_callee (e);\n-      cgraph_free_edge (e);\n+\te->remove_callee ();\n+      symtab->free_edge (e);\n     }\n   indirect_calls = NULL;\n   callees = NULL;\n@@ -1654,17 +1581,17 @@ cgraph_node::remove_callees (void)\n void\n cgraph_node::remove_callers (void)\n {\n-  struct cgraph_edge *e, *f;\n+  cgraph_edge *e, *f;\n \n   /* It is sufficient to remove the edges from the lists of callees of\n      the callers.  The caller list of the node can be zapped with one\n      assignment.  */\n   for (e = callers; e; e = f)\n     {\n       f = e->next_caller;\n-      cgraph_call_edge_removal_hooks (e);\n-      cgraph_edge_remove_caller (e);\n-      cgraph_free_edge (e);\n+      symtab->call_edge_removal_hooks (e);\n+      e->remove_caller ();\n+      symtab->free_edge (e);\n     }\n   callers = NULL;\n }\n@@ -1719,7 +1646,7 @@ void\n cgraph_node::release_body (void)\n {\n   ipa_transforms_to_apply.release ();\n-  if (!used_as_abstract_origin && cgraph_state != CGRAPH_STATE_PARSING)\n+  if (!used_as_abstract_origin && symtab->state != PARSING)\n     {\n       DECL_RESULT (decl) = NULL;\n       DECL_ARGUMENTS (decl) = NULL;\n@@ -1739,10 +1666,10 @@ cgraph_node::release_body (void)\n void\n cgraph_node::remove (void)\n {\n-  struct cgraph_node *n;\n+  cgraph_node *n;\n   int uid = this->uid;\n \n-  cgraph_call_node_removal_hooks (this);\n+  symtab->call_cgraph_removal_hooks (this);\n   remove_callers ();\n   remove_callees ();\n   ipa_transforms_to_apply.release ();\n@@ -1756,7 +1683,7 @@ cgraph_node::remove (void)\n   nested = NULL;\n   if (origin)\n     {\n-      struct cgraph_node **node2 = &origin->nested;\n+      cgraph_node **node2 = &origin->nested;\n \n       while (*node2 != this)\n \tnode2 = &(*node2)->next_nested;\n@@ -1771,7 +1698,7 @@ cgraph_node::remove (void)\n     next_sibling_clone->prev_sibling_clone = prev_sibling_clone;\n   if (clones)\n     {\n-      struct cgraph_node *n, *next;\n+      cgraph_node *n, *next;\n \n       if (clone_of)\n         {\n@@ -1804,12 +1731,12 @@ cgraph_node::remove (void)\n      itself is kept in the cgraph even after it is compiled.  Check whether\n      we are done with this body and reclaim it proactively if this is the case.\n      */\n-  if (cgraph_state != CGRAPH_LTO_STREAMING)\n+  if (symtab->state != LTO_STREAMING)\n     {\n       n = cgraph_node::get (decl);\n       if (!n\n \t  || (!n->clones && !n->clone_of && !n->global.inlined_to\n-\t      && (cgraph_global_info_ready\n+\t      && (symtab->global_info_ready\n \t\t  && (TREE_ASM_WRITTEN (n->decl)\n \t\t      || DECL_EXTERNAL (n->decl)\n \t\t      || !n->analyzed\n@@ -1823,15 +1750,8 @@ cgraph_node::remove (void)\n       htab_delete (call_site_hash);\n       call_site_hash = NULL;\n     }\n-  cgraph_n_nodes--;\n \n-  /* Clear out the node to NULL all pointers and add the node to the free\n-     list.  */\n-  memset (this, 0, sizeof (*this));\n-  type = SYMTAB_FUNCTION;\n-  this->uid = uid;\n-  SET_NEXT_FREE_NODE (this, free_nodes);\n-  free_nodes = this;\n+  symtab->release_symbol (this, uid);\n }\n \n /* Likewise indicate that a node is having address taken.  */\n@@ -1860,41 +1780,36 @@ cgraph_node::mark_address_taken (void)\n \n /* Return local info for the compiled function.  */\n \n-struct cgraph_local_info *\n-cgraph_local_info (tree decl)\n+cgraph_local_info *\n+cgraph_node::local_info (tree decl)\n {\n-  struct cgraph_node *node;\n-\n   gcc_assert (TREE_CODE (decl) == FUNCTION_DECL);\n-  node = cgraph_node::get (decl);\n+  cgraph_node *node = get (decl);\n   if (!node)\n     return NULL;\n   return &node->local;\n }\n \n-/* Return local info for the compiled function.  */\n+/* Return global info for the compiled function.  */\n \n-struct cgraph_global_info *\n-cgraph_global_info (tree decl)\n+cgraph_global_info *\n+cgraph_node::global_info (tree decl)\n {\n-  struct cgraph_node *node;\n-\n-  gcc_assert (TREE_CODE (decl) == FUNCTION_DECL && cgraph_global_info_ready);\n-  node = cgraph_node::get (decl);\n+  gcc_assert (TREE_CODE (decl) == FUNCTION_DECL\n+    && symtab->global_info_ready);\n+  cgraph_node *node = get (decl);\n   if (!node)\n     return NULL;\n   return &node->global;\n }\n \n /* Return local info for the compiled function.  */\n \n-struct cgraph_rtl_info *\n-cgraph_rtl_info (tree decl)\n+cgraph_rtl_info *\n+cgraph_node::rtl_info (tree decl)\n {\n-  struct cgraph_node *node;\n-\n   gcc_assert (TREE_CODE (decl) == FUNCTION_DECL);\n-  node = cgraph_node::get (decl);\n+  cgraph_node *node = get (decl);\n   if (!node\n       || (decl != current_function_decl\n \t  && !TREE_ASM_WRITTEN (node->decl)))\n@@ -1948,7 +1863,7 @@ const char * const cgraph_availability_names[] =\n void\n cgraph_node::dump (FILE *f)\n {\n-  struct cgraph_edge *edge;\n+  cgraph_edge *edge;\n   int indirect_calls_count = 0;\n \n   dump_base (f);\n@@ -1963,7 +1878,7 @@ cgraph_node::dump (FILE *f)\n     fprintf (f, \"  Clone of %s/%i\\n\",\n \t     clone_of->asm_name (),\n \t     clone_of->order);\n-  if (cgraph_function_flags_ready)\n+  if (symtab->function_flags_ready)\n     fprintf (f, \"  Availability: %s\\n\",\n \t     cgraph_availability_names [get_availability ()]);\n \n@@ -2028,12 +1943,12 @@ cgraph_node::dump (FILE *f)\n     {\n       fprintf (f, \"%s/%i \", edge->caller->asm_name (),\n \t       edge->caller->order);\n-      if (edge->count)\n+      if (count)\n \tfprintf (f, \"(%\"PRId64\"x) \",\n-\t\t (int64_t)edge->count);\n-      if (edge->frequency)\n+\t\t (int64_t)count);\n+      if (frequency)\n \tfprintf (f, \"(%.2f per call) \",\n-\t\t edge->frequency / (double)CGRAPH_FREQ_BASE);\n+\t\t frequency / (double)CGRAPH_FREQ_BASE);\n       if (edge->speculative)\n \tfprintf (f, \"(speculative) \");\n       if (!edge->inline_failed)\n@@ -2057,10 +1972,10 @@ cgraph_node::dump (FILE *f)\n \tfprintf (f, \"(indirect_inlining) \");\n       if (edge->count)\n \tfprintf (f, \"(%\"PRId64\"x) \",\n-\t\t (int64_t)edge->count);\n+\t\t (int64_t)count);\n       if (edge->frequency)\n \tfprintf (f, \"(%.2f per call) \",\n-\t\t edge->frequency / (double)CGRAPH_FREQ_BASE);\n+\t\t frequency / (double)CGRAPH_FREQ_BASE);\n       if (edge->can_throw_external)\n \tfprintf (f, \"(can throw external) \");\n     }\n@@ -2086,7 +2001,7 @@ cgraph_node::debug (void)\n void\n cgraph_node::dump_cgraph (FILE *f)\n {\n-  struct cgraph_node *node;\n+  cgraph_node *node;\n \n   fprintf (f, \"callgraph:\\n\\n\");\n   FOR_EACH_FUNCTION (node)\n@@ -2098,7 +2013,7 @@ cgraph_node::dump_cgraph (FILE *f)\n bool\n cgraph_function_possibly_inlined_p (tree decl)\n {\n-  if (!cgraph_global_info_ready)\n+  if (!symtab->global_info_ready)\n     return !DECL_UNINLINABLE (decl);\n   return DECL_POSSIBLY_INLINED (decl);\n }\n@@ -2107,7 +2022,7 @@ cgraph_function_possibly_inlined_p (tree decl)\n void\n cgraph_node::unnest (void)\n {\n-  struct cgraph_node **node2 = &origin->nested;\n+  cgraph_node **node2 = &origin->nested;\n   gcc_assert (origin);\n \n   while (*node2 != this)\n@@ -2157,7 +2072,7 @@ cgraph_node::get_availability (void)\n \n /* Worker for cgraph_node_can_be_local_p.  */\n static bool\n-cgraph_node_cannot_be_local_p_1 (struct cgraph_node *node, void *)\n+cgraph_node_cannot_be_local_p_1 (cgraph_node *node, void *)\n {\n   return !(!node->force_output\n \t   && ((DECL_COMDAT (node->decl)\n@@ -2189,8 +2104,8 @@ cgraph_node::call_for_symbol_thunks_and_aliases (bool (*callback)\n \t\t\t\t\t\t void *data,\n \t\t\t\t\t\t bool include_overwritable)\n {\n-  struct cgraph_edge *e;\n-  struct ipa_ref *ref;\n+  cgraph_edge *e;\n+  ipa_ref *ref;\n \n   if (callback (this, data))\n     return true;\n@@ -2204,7 +2119,7 @@ cgraph_node::call_for_symbol_thunks_and_aliases (bool (*callback)\n \n   FOR_EACH_ALIAS (this, ref)\n     {\n-      struct cgraph_node *alias = dyn_cast <cgraph_node *> (ref->referring);\n+      cgraph_node *alias = dyn_cast <cgraph_node *> (ref->referring);\n       if (include_overwritable\n \t  || alias->get_availability () > AVAIL_INTERPOSABLE)\n \tif (alias->call_for_symbol_thunks_and_aliases (callback, data,\n@@ -2224,14 +2139,14 @@ cgraph_node::call_for_symbol_and_aliases (bool (*callback) (cgraph_node *,\n \t\t\t\t\t  void *data,\n \t\t\t\t\t  bool include_overwritable)\n {\n-  struct ipa_ref *ref;\n+  ipa_ref *ref;\n \n   if (callback (this, data))\n     return true;\n \n   FOR_EACH_ALIAS (this, ref)\n     {\n-      struct cgraph_node *alias = dyn_cast <cgraph_node *> (ref->referring);\n+      cgraph_node *alias = dyn_cast <cgraph_node *> (ref->referring);\n       if (include_overwritable\n \t  || alias->get_availability () > AVAIL_INTERPOSABLE)\n \tif (alias->call_for_symbol_and_aliases (callback, data,\n@@ -2244,7 +2159,7 @@ cgraph_node::call_for_symbol_and_aliases (bool (*callback) (cgraph_node *,\n /* Worker to bring NODE local.  */\n \n bool\n-cgraph_node::make_local (struct cgraph_node *node, void *)\n+cgraph_node::make_local (cgraph_node *node, void *)\n {\n   gcc_checking_assert (node->can_be_local_p ());\n   if (DECL_COMDAT (node->decl) || DECL_EXTERNAL (node->decl))\n@@ -2275,9 +2190,9 @@ cgraph_node::make_local (void)\n /* Worker to set nothrow flag.  */\n \n static bool\n-cgraph_set_nothrow_flag_1 (struct cgraph_node *node, void *data)\n+cgraph_set_nothrow_flag_1 (cgraph_node *node, void *data)\n {\n-  struct cgraph_edge *e;\n+  cgraph_edge *e;\n \n   TREE_NOTHROW (node->decl) = data != NULL;\n \n@@ -2300,7 +2215,7 @@ cgraph_node::set_nothrow_flag (bool nothrow)\n /* Worker to set const flag.  */\n \n static bool\n-cgraph_set_const_flag_1 (struct cgraph_node *node, void *data)\n+cgraph_set_const_flag_1 (cgraph_node *node, void *data)\n {\n   /* Static constructors and destructors without a side effect can be\n      optimized out.  */\n@@ -2330,7 +2245,7 @@ cgraph_node::set_const_flag (bool readonly, bool looping)\n /* Worker to set pure flag.  */\n \n static bool\n-cgraph_set_pure_flag_1 (struct cgraph_node *node, void *data)\n+cgraph_set_pure_flag_1 (cgraph_node *node, void *data)\n {\n   /* Static constructors and destructors without a side effect can be\n      optimized out.  */\n@@ -2371,27 +2286,27 @@ cgraph_node::cannot_return_p (void)\n \t     == (ECF_NORETURN | ECF_NOTHROW));\n }\n \n-/* Return true when call of E can not lead to return from caller\n+/* Return true when call of edge can not lead to return from caller\n    and thus it is safe to ignore its side effects for IPA analysis\n    when computing side effects of the caller.\n    FIXME: We could actually mark all edges that have no reaching\n    patch to the exit block or throw to get better results.  */\n bool\n-cgraph_edge_cannot_lead_to_return (struct cgraph_edge *e)\n+cgraph_edge::cannot_lead_to_return_p (void)\n {\n-  if (e->caller->cannot_return_p ())\n+  if (caller->cannot_return_p ())\n     return true;\n-  if (e->indirect_unknown_callee)\n+  if (indirect_unknown_callee)\n     {\n-      int flags = e->indirect_info->ecf_flags;\n+      int flags = indirect_info->ecf_flags;\n       if (!flag_exceptions)\n \treturn (flags & ECF_NORETURN) != 0;\n       else\n \treturn ((flags & (ECF_NORETURN | ECF_NOTHROW))\n \t\t == (ECF_NORETURN | ECF_NOTHROW));\n     }\n   else\n-    return e->callee->cannot_return_p ();\n+    return callee->cannot_return_p ();\n }\n \n /* Return true when function can be removed from callgraph\n@@ -2422,7 +2337,7 @@ cgraph_node::can_remove_if_no_direct_calls_and_refs_p (void)\n /* Worker for cgraph_can_remove_if_no_direct_calls_p.  */\n \n static bool\n-nonremovable_p (struct cgraph_node *node, void *)\n+nonremovable_p (cgraph_node *node, void *)\n {\n   return !node->can_remove_if_no_direct_calls_and_refs_p ();\n }\n@@ -2477,7 +2392,7 @@ cgraph_node::will_be_removed_from_program_if_no_direct_calls_p (void)\n /* Worker for cgraph_only_called_directly_p.  */\n \n static bool\n-cgraph_not_only_called_directly_p_1 (struct cgraph_node *node, void *)\n+cgraph_not_only_called_directly_p_1 (cgraph_node *node, void *)\n {\n   return !node->only_called_directly_or_aliased_p ();\n }\n@@ -2499,10 +2414,10 @@ cgraph_node::only_called_directly_p (void)\n /* Collect all callers of NODE.  Worker for collect_callers_of_node.  */\n \n static bool\n-collect_callers_of_node_1 (struct cgraph_node *node, void *data)\n+collect_callers_of_node_1 (cgraph_node *node, void *data)\n {\n   vec<cgraph_edge *> *redirect_callers = (vec<cgraph_edge *> *)data;\n-  struct cgraph_edge *cs;\n+  cgraph_edge *cs;\n   enum availability avail;\n   node->ultimate_alias_target (&avail);\n \n@@ -2528,7 +2443,7 @@ cgraph_node::collect_callers (void)\n /* Return TRUE if NODE2 a clone of NODE or is equivalent to it.  */\n \n static bool\n-clone_of_p (struct cgraph_node *node, struct cgraph_node *node2)\n+clone_of_p (cgraph_node *node, cgraph_node *node2)\n {\n   bool skipped_thunk = false;\n   node = node->ultimate_alias_target ();\n@@ -2566,7 +2481,7 @@ clone_of_p (struct cgraph_node *node, struct cgraph_node *node2)\n /* Verify edge E count and frequency.  */\n \n static bool\n-verify_edge_count_and_frequency (struct cgraph_edge *e)\n+verify_edge_count_and_frequency (cgraph_edge *e)\n {\n   bool error_found = false;\n   if (e->count < 0)\n@@ -2608,7 +2523,7 @@ verify_edge_count_and_frequency (struct cgraph_edge *e)\n \n /* Switch to THIS_CFUN if needed and print STMT to stderr.  */\n static void\n-cgraph_debug_gimple_stmt (struct function *this_cfun, gimple stmt)\n+cgraph_debug_gimple_stmt (function *this_cfun, gimple stmt)\n {\n   bool fndecl_was_null = false;\n   /* debug_gimple_stmt needs correct cfun */\n@@ -2629,13 +2544,13 @@ cgraph_debug_gimple_stmt (struct function *this_cfun, gimple stmt)\n    statement.  Return true if the verification should fail.  */\n \n static bool\n-verify_edge_corresponds_to_fndecl (struct cgraph_edge *e, tree decl)\n+verify_edge_corresponds_to_fndecl (cgraph_edge *e, tree decl)\n {\n-  struct cgraph_node *node;\n+  cgraph_node *node;\n \n   if (!decl || e->callee->global.inlined_to)\n     return false;\n-  if (cgraph_state == CGRAPH_LTO_STREAMING)\n+  if (symtab->state == LTO_STREAMING)\n     return false;\n   node = cgraph_node::get (decl);\n \n@@ -2669,8 +2584,8 @@ verify_edge_corresponds_to_fndecl (struct cgraph_edge *e, tree decl)\n DEBUG_FUNCTION void\n cgraph_node::verify_node (void)\n {\n-  struct cgraph_edge *e;\n-  struct function *this_cfun = DECL_STRUCT_FUNCTION (decl);\n+  cgraph_edge *e;\n+  function *this_cfun = DECL_STRUCT_FUNCTION (decl);\n   basic_block this_block;\n   gimple_stmt_iterator gsi;\n   bool error_found = false;\n@@ -2786,7 +2701,7 @@ cgraph_node::verify_node (void)\n \n   if (clone_of)\n     {\n-      struct cgraph_node *n;\n+      cgraph_node *n;\n       for (n = clone_of->clones; n; n = n->next_sibling_clone)\n \tif (n == this)\n \t  break;\n@@ -2798,7 +2713,7 @@ cgraph_node::verify_node (void)\n     }\n   if (clones)\n     {\n-      struct cgraph_node *n;\n+      cgraph_node *n;\n       for (n = clones; n; n = n->next_sibling_clone)\n \tif (n->clone_of != this)\n \t  break;\n@@ -2828,7 +2743,7 @@ cgraph_node::verify_node (void)\n     {\n       bool ref_found = false;\n       int i;\n-      struct ipa_ref *ref = NULL;\n+      ipa_ref *ref = NULL;\n \n       if (callees)\n \t{\n@@ -2881,7 +2796,7 @@ cgraph_node::verify_node (void)\n \t{\n \t  hash_set<gimple> stmts;\n \t  int i;\n-\t  struct ipa_ref *ref = NULL;\n+\t  ipa_ref *ref = NULL;\n \n \t  /* Reach the trees by walking over the CFG, and note the\n \t     enclosing basic-blocks in the call edges.  */\n@@ -2898,7 +2813,7 @@ cgraph_node::verify_node (void)\n \t\t  stmts.add (stmt);\n \t\t  if (is_gimple_call (stmt))\n \t\t    {\n-\t\t      struct cgraph_edge *e = get_edge (stmt);\n+\t\t      cgraph_edge *e = get_edge (stmt);\n \t\t      tree decl = gimple_call_fndecl (stmt);\n \t\t      if (e)\n \t\t\t{\n@@ -2986,7 +2901,7 @@ cgraph_node::verify_node (void)\n DEBUG_FUNCTION void\n cgraph_node::verify_cgraph_nodes (void)\n {\n-  struct cgraph_node *node;\n+  cgraph_node *node;\n \n   if (seen_error ())\n     return;\n@@ -3029,7 +2944,7 @@ cgraph_node::function_symbol (enum availability *availability)\n bool\n cgraph_node::get_body (void)\n {\n-  struct lto_file_decl_data *file_data;\n+  lto_file_decl_data *file_data;\n   const char *data, *name;\n   size_t len;\n   tree decl = this->decl;"}, {"sha": "879899c7d3696e471729a27b0e3e453c09a9946a", "filename": "gcc/cgraph.h", "status": "modified", "additions": 675, "deletions": 230, "changes": 905, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3dafb85c8e6ade82adc591fe97c116b193f8bb0d/gcc%2Fcgraph.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3dafb85c8e6ade82adc591fe97c116b193f8bb0d/gcc%2Fcgraph.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraph.h?ref=3dafb85c8e6ade82adc591fe97c116b193f8bb0d", "patch": "@@ -28,6 +28,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"basic-block.h\"\n #include \"function.h\"\n #include \"ipa-ref.h\"\n+#include \"dumpfile.h\"\n \n /* Symbol table consists of functions and variables.\n    TODO: add labels and CONST_DECLs.  */\n@@ -117,21 +118,21 @@ class GTY((desc (\"%h.type\"), tag (\"SYMTAB_SYMBOL\"),\n   /* Return ipa reference from this symtab_node to\n      REFERED_NODE or REFERED_VARPOOL_NODE. USE_TYPE specify type\n      of the use and STMT the statement (if it exists).  */\n-  struct ipa_ref *add_reference (symtab_node *referred_node,\n-\t\t\t\t enum ipa_ref_use use_type);\n+  ipa_ref *create_reference (symtab_node *referred_node,\n+\t\t\t     enum ipa_ref_use use_type);\n \n   /* Return ipa reference from this symtab_node to\n      REFERED_NODE or REFERED_VARPOOL_NODE. USE_TYPE specify type\n      of the use and STMT the statement (if it exists).  */\n-  struct ipa_ref *add_reference (symtab_node *referred_node,\n-\t\t\t\t enum ipa_ref_use use_type, gimple stmt);\n+  ipa_ref *create_reference (symtab_node *referred_node,\n+\t\t\t     enum ipa_ref_use use_type, gimple stmt);\n \n   /* If VAL is a reference to a function or a variable, add a reference from\n      this symtab_node to the corresponding symbol table node.  USE_TYPE specify\n      type of the use and STMT the statement (if it exists).  Return the new\n      reference or NULL if none was created.  */\n-  struct ipa_ref *maybe_add_reference (tree val, enum ipa_ref_use use_type,\n-\t\t\t\t       gimple stmt);\n+  ipa_ref *maybe_create_reference (tree val, enum ipa_ref_use use_type,\n+\t\t\t\t   gimple stmt);\n \n   /* Clone all references from symtab NODE to this symtab_node.  */\n   void clone_references (symtab_node *node);\n@@ -143,12 +144,12 @@ class GTY((desc (\"%h.type\"), tag (\"SYMTAB_SYMBOL\"),\n   void clone_referring (symtab_node *node);\n \n   /* Clone reference REF to this symtab_node and set its stmt to STMT.  */\n-  struct ipa_ref *clone_reference (struct ipa_ref *ref, gimple stmt);\n+  ipa_ref *clone_reference (ipa_ref *ref, gimple stmt);\n \n   /* Find the structure describing a reference to REFERRED_NODE\n      and associated with statement STMT.  */\n-  struct ipa_ref *find_reference (symtab_node *referred_node, gimple stmt,\n-\t\t\t\t  unsigned int lto_stmt_uid);\n+  ipa_ref *find_reference (symtab_node *referred_node, gimple stmt,\n+\t\t\t   unsigned int lto_stmt_uid);\n \n   /* Remove all references that are associated with statement STMT.  */\n   void remove_stmt_references (gimple stmt);\n@@ -172,13 +173,13 @@ class GTY((desc (\"%h.type\"), tag (\"SYMTAB_SYMBOL\"),\n   void dump_referring (FILE *);\n \n   /* Iterates I-th reference in the list, REF is also set.  */\n-  struct ipa_ref *iterate_reference (unsigned i, struct ipa_ref *&ref);\n+  ipa_ref *iterate_reference (unsigned i, ipa_ref *&ref);\n \n   /* Iterates I-th referring item in the list, REF is also set.  */\n-  struct ipa_ref *iterate_referring (unsigned i, struct ipa_ref *&ref);\n+  ipa_ref *iterate_referring (unsigned i, ipa_ref *&ref);\n \n   /* Iterates I-th referring alias item in the list, REF is also set.  */\n-  struct ipa_ref *iterate_direct_aliases (unsigned i, struct ipa_ref *&ref);\n+  ipa_ref *iterate_direct_aliases (unsigned i, ipa_ref *&ref);\n \n   /* Return true if symtab node and TARGET represents\n      semantically equivalent symbols.  */\n@@ -289,6 +290,14 @@ class GTY((desc (\"%h.type\"), tag (\"SYMTAB_SYMBOL\"),\n      or abstract function kept for debug info purposes only.  */\n   bool real_symbol_p (void);\n \n+  /* Determine if symbol declaration is needed.  That is, visible to something\n+     either outside this translation unit, something magic in the system\n+     configury. This function is used just during symbol creation.  */\n+  bool needed_p (void);\n+\n+  /* Return true when there are references to the node.  */\n+  bool referred_to_p (void);\n+\n   /* Return true if NODE can be discarded by linker from the binary.  */\n   inline bool\n   can_be_discarded_p (void)\n@@ -337,6 +346,10 @@ class GTY((desc (\"%h.type\"), tag (\"SYMTAB_SYMBOL\"),\n     return decl->decl_with_vis.symtab_node;\n   }\n \n+  /* Return the cgraph node that has ASMNAME for its DECL_ASSEMBLER_NAME.\n+     Return NULL if there's no such node.  */\n+  static symtab_node *get_for_asmname (const_tree asmname);\n+\n   /* Dump symbol table to F.  */\n   static void dump_table (FILE *);\n \n@@ -362,7 +375,7 @@ class GTY((desc (\"%h.type\"), tag (\"SYMTAB_SYMBOL\"),\n   /*** Flags representing the symbol type.  ***/\n \n   /* True when symbol corresponds to a definition in current unit.\n-     set via cgraph_finalize_function or varpool_finalize_decl  */\n+     set via finalize_function or finalize_decl  */\n   unsigned definition : 1;\n   /* True when symbol is an alias.\n      Set by ssemble_alias.  */\n@@ -450,7 +463,7 @@ class GTY((desc (\"%h.type\"), tag (\"SYMTAB_SYMBOL\"),\n   symtab_node *same_comdat_group;\n \n   /* Vectors of referring and referenced entities.  */\n-  struct ipa_ref_list ref_list;\n+  ipa_ref_list ref_list;\n \n   /* Alias target. May be either DECL pointer or ASSEMBLER_NAME pointer\n      depending to what was known to frontend on the creation time.\n@@ -679,7 +692,7 @@ struct GTY(()) cgraph_simd_clone {\n   cgraph_node *origin;\n \n   /* Annotated function arguments for the original function.  */\n-  struct cgraph_simd_clone_arg GTY((length (\"%h.nargs\"))) args[1];\n+  cgraph_simd_clone_arg GTY((length (\"%h.nargs\"))) args[1];\n };\n \n /* Function Multiversioning info.  */\n@@ -689,11 +702,11 @@ struct GTY(()) cgraph_function_version_info {\n   /* Chains all the semantically identical function versions.  The\n      first function in this chain is the version_info node of the\n      default function.  */\n-  struct cgraph_function_version_info *prev;\n+  cgraph_function_version_info *prev;\n   /* If this version node corresponds to a dispatcher for function\n      versions, this points to the version info node of the default\n      function, the first node in the chain.  */\n-  struct cgraph_function_version_info *next;\n+  cgraph_function_version_info *next;\n   /* If this node corresponds to a function version, this points\n      to the dispatcher function decl, which is the function that must\n      be called to execute the right function version at run-time.\n@@ -769,7 +782,7 @@ struct GTY((tag (\"SYMTAB_FUNCTION\"))) cgraph_node : public symtab_node {\n \t\t\t     bool update_original,\n \t\t\t     vec<cgraph_edge *> redirect_callers,\n \t\t\t     bool call_duplication_hook,\n-\t\t\t     struct cgraph_node *new_inlined_to,\n+\t\t\t     cgraph_node *new_inlined_to,\n \t\t\t     bitmap args_to_skip);\n \n   /* Create callgraph node clone with new declaration.  The actual body will\n@@ -823,10 +836,10 @@ struct GTY((tag (\"SYMTAB_FUNCTION\"))) cgraph_node : public symtab_node {\n \n   /* Insert a new cgraph_function_version_info node into cgraph_fnver_htab\n      corresponding to cgraph_node.  */\n-  struct cgraph_function_version_info *insert_new_function_version (void);\n+  cgraph_function_version_info *insert_new_function_version (void);\n \n   /* Get the cgraph_function_version_info node corresponding to node.  */\n-  struct cgraph_function_version_info *function_version (void);\n+  cgraph_function_version_info *function_version (void);\n \n   /* Discover all functions and variables that are trivially needed, analyze\n      them as well as all functions and variables referred by them  */\n@@ -858,6 +871,12 @@ struct GTY((tag (\"SYMTAB_FUNCTION\"))) cgraph_node : public symtab_node {\n      thunks that are not lowered.  */\n   bool expand_thunk (bool output_asm_thunks, bool force_gimple_thunk);\n \n+  /* Assemble thunks and aliases associated to node.  */\n+  void assemble_thunks_and_aliases (void);\n+\n+  /* Expand function specified by node.  */\n+  void expand (void);\n+\n   /* As an GCC extension we allow redefinition of the function.  The\n      semantics when both copies of bodies differ is not well defined.\n      We replace the old body with new body so in unit at a time mode\n@@ -908,20 +927,21 @@ struct GTY((tag (\"SYMTAB_FUNCTION\"))) cgraph_node : public symtab_node {\n   priority_type get_fini_priority (void);\n \n   /* Create edge from a given function to CALLEE in the cgraph.  */\n-  struct cgraph_edge *create_edge (cgraph_node *callee,\n-\t\t\t\t   gimple call_stmt, gcov_type count,\n-\t\t\t\t   int freq);\n+  cgraph_edge *create_edge (cgraph_node *callee,\n+\t\t\t    gimple call_stmt, gcov_type count,\n+\t\t\t    int freq);\n+\n   /* Create an indirect edge with a yet-undetermined callee where the call\n      statement destination is a formal parameter of the caller with index\n      PARAM_INDEX. */\n-  struct cgraph_edge *create_indirect_edge (gimple call_stmt, int ecf_flags,\n-\t\t\t\t\t    gcov_type count, int freq,\n-\t\t\t\t\t    bool compute_indirect_info = true);\n+  cgraph_edge *create_indirect_edge (gimple call_stmt, int ecf_flags,\n+\t\t\t\t     gcov_type count, int freq,\n+\t\t\t\t     bool compute_indirect_info = true);\n \n   /* Like cgraph_create_edge walk the clone tree and update all clones sharing\n    same function body.  If clones already have edge for OLD_STMT; only\n    update the edge same way as cgraph_set_call_stmt_including_clones does.  */\n-  void create_edge_including_clones (struct cgraph_node *callee,\n+  void create_edge_including_clones (cgraph_node *callee,\n \t\t\t\t     gimple old_stmt, gimple stmt,\n \t\t\t\t     gcov_type count,\n \t\t\t\t     int freq,\n@@ -957,9 +977,6 @@ struct GTY((tag (\"SYMTAB_FUNCTION\"))) cgraph_node : public symtab_node {\n      if any to PURE.  */\n   void set_pure_flag (bool pure, bool looping);\n \n-  /* Call all node duplication hooks.  */\n-  void call_duplication_hooks (cgraph_node *node2);\n-\n   /* Call calback on function and aliases associated to the function.\n      When INCLUDE_OVERWRITABLE is false, overwritable aliases and thunks are\n      skipped. */\n@@ -976,9 +993,6 @@ struct GTY((tag (\"SYMTAB_FUNCTION\"))) cgraph_node : public symtab_node {\n \t\t\t\t\t void *data,\n \t\t\t\t\t bool include_overwritable);\n \n-  /* Call all node insertion hooks.  */\n-  void call_function_insertion_hooks (void);\n-\n   /* Likewise indicate that a node is needed, i.e. reachable via some\n      external means.  */\n   inline void mark_force_output (void);\n@@ -1044,7 +1058,8 @@ struct GTY((tag (\"SYMTAB_FUNCTION\"))) cgraph_node : public symtab_node {\n   static void dump_cgraph (FILE *f);\n \n   /* Dump the call graph to stderr.  */\n-  static inline void debug_cgraph (void)\n+  static inline\n+  void debug_cgraph (void)\n   {\n     dump_cgraph (stderr);\n   }\n@@ -1058,7 +1073,7 @@ struct GTY((tag (\"SYMTAB_FUNCTION\"))) cgraph_node : public symtab_node {\n   static void delete_function_version (tree decl);\n \n   /* Add the function FNDECL to the call graph.\n-     Unlike cgraph_finalize_function, this function is intended to be used\n+     Unlike finalize_function, this function is intended to be used\n      by middle end and allows insertion of new function at arbitrary point\n      of compilation.  The function can be either in high, low or SSA form\n      GIMPLE.\n@@ -1077,16 +1092,28 @@ struct GTY((tag (\"SYMTAB_FUNCTION\"))) cgraph_node : public symtab_node {\n     return dyn_cast <cgraph_node *> (symtab_node::get (decl));\n   }\n \n+  /* DECL has been parsed.  Take it, queue it, compile it at the whim of the\n+     logic in effect.  If NO_COLLECT is true, then our caller cannot stand to\n+     have the garbage collector run at the moment.  We would need to either\n+     create a new GC context, or just not compile right now.  */\n+  static void finalize_function (tree, bool);\n+\n   /* Return cgraph node assigned to DECL.  Create new one when needed.  */\n   static cgraph_node * create (tree decl);\n \n-  /* Allocate new callgraph node and insert it into basic data structures.  */\n-  static cgraph_node * create_empty (void);\n-\n   /* Try to find a call graph node for declaration DECL and if it does not\n      exist or if it corresponds to an inline clone, create a new one.  */\n   static cgraph_node * get_create (tree);\n \n+  /* Return local info for the compiled function.  */\n+  static cgraph_local_info *local_info (tree decl);\n+\n+  /* Return global info for the compiled function.  */\n+  static cgraph_global_info *global_info (tree);\n+\n+  /* Return local info for the compiled function.  */\n+  static cgraph_rtl_info *rtl_info (tree);\n+\n   /* Return the cgraph node that has ASMNAME for its DECL_ASSEMBLER_NAME.\n      Return NULL if there's no such node.  */\n   static cgraph_node *get_for_asmname (tree asmname);\n@@ -1119,16 +1146,11 @@ struct GTY((tag (\"SYMTAB_FUNCTION\"))) cgraph_node : public symtab_node {\n      with (not necessarily cgraph_node (DECL).  */\n   static cgraph_node *create_alias (tree alias, tree target);\n \n-  static cgraph_edge * create_edge (cgraph_node *caller, cgraph_node *callee,\n-\t\t\t\t    gimple call_stmt, gcov_type count,\n-\t\t\t\t    int freq,\n-\t\t\t\t    bool indir_unknown_callee);\n-\n-  struct cgraph_edge *callees;\n-  struct cgraph_edge *callers;\n+  cgraph_edge *callees;\n+  cgraph_edge *callers;\n   /* List of edges representing indirect calls with a yet undetermined\n      callee.  */\n-  struct cgraph_edge *indirect_calls;\n+  cgraph_edge *indirect_calls;\n   /* For nested functions points to function the node is nested in.  */\n   cgraph_node *origin;\n   /* Points to first nested function, if any.  */\n@@ -1142,13 +1164,13 @@ struct GTY((tag (\"SYMTAB_FUNCTION\"))) cgraph_node : public symtab_node {\n   cgraph_node *clone_of;\n   /* For functions with many calls sites it holds map from call expression\n      to the edge to speed up cgraph_edge function.  */\n-  htab_t GTY((param_is (struct cgraph_edge))) call_site_hash;\n+  htab_t GTY((param_is (cgraph_edge))) call_site_hash;\n   /* Declaration node used to be clone of. */\n   tree former_clone_of;\n \n   /* If this is a SIMD clone, this points to the SIMD specific\n      information for it.  */\n-  struct cgraph_simd_clone *simdclone;\n+  cgraph_simd_clone *simdclone;\n   /* If this function has SIMD clones, this points to the first clone.  */\n   cgraph_node *simd_clones;\n \n@@ -1157,11 +1179,11 @@ struct GTY((tag (\"SYMTAB_FUNCTION\"))) cgraph_node : public symtab_node {\n      per-function in order to allow IPA passes to introduce new functions.  */\n   vec<ipa_opt_pass> GTY((skip)) ipa_transforms_to_apply;\n \n-  struct cgraph_local_info local;\n-  struct cgraph_global_info global;\n-  struct cgraph_rtl_info rtl;\n-  struct cgraph_clone_info clone;\n-  struct cgraph_thunk_info thunk;\n+  cgraph_local_info local;\n+  cgraph_global_info global;\n+  cgraph_rtl_info rtl;\n+  cgraph_clone_info clone;\n+  cgraph_thunk_info thunk;\n \n   /* Expected number of executions: calculated in profile.c.  */\n   gcov_type count;\n@@ -1276,18 +1298,81 @@ struct GTY(()) cgraph_indirect_call_info\n };\n \n struct GTY((chain_next (\"%h.next_caller\"), chain_prev (\"%h.prev_caller\"))) cgraph_edge {\n+  friend class cgraph_node;\n+\n+  /* Remove the edge in the cgraph.  */\n+  void remove (void);\n+\n+  /* Change field call_stmt of edge to NEW_STMT.\n+     If UPDATE_SPECULATIVE and E is any component of speculative\n+     edge, then update all components.  */\n+  void set_call_stmt (gimple new_stmt, bool update_speculative = true);\n+\n+  /* Redirect callee of the edge to N.  The function does not update underlying\n+     call expression.  */\n+  void redirect_callee (cgraph_node *n);\n+\n+  /* Make an indirect edge with an unknown callee an ordinary edge leading to\n+     CALLEE.  DELTA is an integer constant that is to be added to the this\n+     pointer (first parameter) to compensate for skipping\n+     a thunk adjustment.  */\n+  cgraph_edge *make_direct (cgraph_node *callee);\n+\n+  /* Turn edge into speculative call calling N2. Update\n+     the profile so the direct call is taken COUNT times\n+     with FREQUENCY.  */\n+  cgraph_edge *make_speculative (cgraph_node *n2, gcov_type direct_count,\n+\t\t\t\t int direct_frequency);\n+\n+   /* Given speculative call edge, return all three components.  */\n+  void speculative_call_info (cgraph_edge *&direct, cgraph_edge *&indirect,\n+\t\t\t      ipa_ref *&reference);\n+\n+  /* Speculative call edge turned out to be direct call to CALLE_DECL.\n+     Remove the speculative call sequence and return edge representing the call.\n+     It is up to caller to redirect the call as appropriate. */\n+  cgraph_edge *resolve_speculation (tree callee_decl = NULL);\n+\n+  /* If necessary, change the function declaration in the call statement\n+     associated with the edge so that it corresponds to the edge callee.  */\n+  gimple redirect_call_stmt_to_callee (void);\n+\n+  /* Create clone of edge in the node N represented\n+     by CALL_EXPR the callgraph.  */\n+  cgraph_edge * clone (cgraph_node *n, gimple call_stmt, unsigned stmt_uid,\n+\t\t       gcov_type count_scale, int freq_scale, bool update_original);\n+\n+  /* Return true when call of edge can not lead to return from caller\n+     and thus it is safe to ignore its side effects for IPA analysis\n+     when computing side effects of the caller.  */\n+  bool cannot_lead_to_return_p (void);\n+\n+  /* Return true when the edge represents a direct recursion.  */\n+  bool recursive_p (void);\n+\n+  /* Return true if the call can be hot.  */\n+  bool maybe_hot_p (void);\n+\n+  /* Rebuild cgraph edges for current function node.  This needs to be run after\n+     passes that don't update the cgraph.  */\n+  static unsigned int rebuild_edges (void);\n+\n+  /* Rebuild cgraph references for current function node.  This needs to be run\n+     after passes that don't update the cgraph.  */\n+  static void rebuild_references (void);\n+\n   /* Expected number of executions: calculated in profile.c.  */\n   gcov_type count;\n   cgraph_node *caller;\n   cgraph_node *callee;\n-  struct cgraph_edge *prev_caller;\n-  struct cgraph_edge *next_caller;\n-  struct cgraph_edge *prev_callee;\n-  struct cgraph_edge *next_callee;\n+  cgraph_edge *prev_caller;\n+  cgraph_edge *next_caller;\n+  cgraph_edge *prev_callee;\n+  cgraph_edge *next_callee;\n   gimple call_stmt;\n   /* Additional information about an indirect call.  Not cleared when an edge\n      becomes direct.  */\n-  struct cgraph_indirect_call_info *indirect_info;\n+  cgraph_indirect_call_info *indirect_info;\n   PTR GTY ((skip (\"\"))) aux;\n   /* When equal to CIF_OK, inline this call.  Otherwise, points to the\n      explanation why function was not inlined.  */\n@@ -1329,6 +1414,13 @@ struct GTY((chain_next (\"%h.next_caller\"), chain_prev (\"%h.prev_caller\"))) cgrap\n      Optimizers may later redirect direct call to clone, so 1) and 3)\n      do not need to necesarily agree with destination.  */\n   unsigned int speculative : 1;\n+\n+private:\n+  /* Remove the edge from the list of the callers of the callee.  */\n+  void remove_caller (void);\n+\n+  /* Remove the edge from the list of the callees of the caller.  */\n+  void remove_callee (void);\n };\n \n #define CGRAPH_FREQ_BASE 1000\n@@ -1402,6 +1494,12 @@ class GTY((tag (\"SYMTAB_VARIABLE\"))) varpool_node : public symtab_node {\n      if all direct calls are eliminated.  */\n   inline bool can_remove_if_no_refs_p (void);\n \n+  /* Add the variable DECL to the varpool.\n+     Unlike finalize_decl function is intended to be used\n+     by middle end and allows insertion of new variable at arbitrary point\n+     of compilation.  */\n+  static void add (tree decl);\n+\n   /* Return varpool node for given symbol and check it is a function. */\n   static inline varpool_node *get (const_tree decl);\n \n@@ -1410,9 +1508,6 @@ class GTY((tag (\"SYMTAB_VARIABLE\"))) varpool_node : public symtab_node {\n      visible.  */\n   static void finalize_decl (tree decl);\n \n-  /* Output all variables enqueued to be assembled.  */\n-  static bool output_variables (void);\n-\n   /* Attempt to mark ALIAS as an alias to DECL.  Return TRUE if successful.\n      Extra name aliases are output whenever DECL is output.  */\n   static varpool_node * create_extra_name_alias (tree alias, tree decl);\n@@ -1459,8 +1554,10 @@ class GTY((tag (\"SYMTAB_VARIABLE\"))) varpool_node : public symtab_node {\n /* Every top level asm statement is put into a asm_node.  */\n \n struct GTY(()) asm_node {\n+\n+\n   /* Next asm node.  */\n-  struct asm_node *next;\n+  asm_node *next;\n   /* String for this asm node.  */\n   tree asm_str;\n   /* Ordering of all cgraph nodes.  */\n@@ -1487,151 +1584,385 @@ is_a_helper <varpool_node *>::test (symtab_node *p)\n   return p && p->type == SYMTAB_VARIABLE;\n }\n \n-extern GTY(()) symtab_node *symtab_nodes;\n-extern GTY(()) int cgraph_n_nodes;\n-extern GTY(()) int cgraph_max_uid;\n-extern GTY(()) int cgraph_edge_max_uid;\n-extern bool cgraph_global_info_ready;\n-enum cgraph_state\n+/* Macros to access the next item in the list of free cgraph nodes and\n+   edges. */\n+#define NEXT_FREE_NODE(NODE) dyn_cast<cgraph_node *> ((NODE)->next)\n+#define SET_NEXT_FREE_NODE(NODE,NODE2) ((NODE))->next = NODE2\n+#define NEXT_FREE_EDGE(EDGE) (EDGE)->prev_caller\n+\n+typedef void (*cgraph_edge_hook)(cgraph_edge *, void *);\n+typedef void (*cgraph_node_hook)(cgraph_node *, void *);\n+typedef void (*varpool_node_hook)(varpool_node *, void *);\n+typedef void (*cgraph_2edge_hook)(cgraph_edge *, cgraph_edge *, void *);\n+typedef void (*cgraph_2node_hook)(cgraph_node *, cgraph_node *, void *);\n+\n+struct cgraph_edge_hook_list;\n+struct cgraph_node_hook_list;\n+struct varpool_node_hook_list;\n+struct cgraph_2edge_hook_list;\n+struct cgraph_2node_hook_list;\n+\n+/* Map from a symbol to initialization/finalization priorities.  */\n+struct GTY(()) symbol_priority_map {\n+  symtab_node *symbol;\n+  priority_type init;\n+  priority_type fini;\n+};\n+\n+enum symtab_state\n {\n   /* Frontend is parsing and finalizing functions.  */\n-  CGRAPH_STATE_PARSING,\n+  PARSING,\n   /* Callgraph is being constructed.  It is safe to add new functions.  */\n-  CGRAPH_STATE_CONSTRUCTION,\n+  CONSTRUCTION,\n   /* Callgraph is being at LTO time.  */\n-  CGRAPH_LTO_STREAMING,\n+  LTO_STREAMING,\n   /* Callgraph is built and IPA passes are being run.  */\n-  CGRAPH_STATE_IPA,\n+  IPA,\n   /* Callgraph is built and all functions are transformed to SSA form.  */\n-  CGRAPH_STATE_IPA_SSA,\n+  IPA_SSA,\n   /* Functions are now ordered and being passed to RTL expanders.  */\n-  CGRAPH_STATE_EXPANSION,\n+  EXPANSION,\n   /* All cgraph expansion is done.  */\n-  CGRAPH_STATE_FINISHED\n+  FINISHED\n };\n-extern enum cgraph_state cgraph_state;\n-extern bool cgraph_function_flags_ready;\n-extern vec<cgraph_node *> cgraph_new_nodes;\n \n-extern GTY(()) struct asm_node *asm_nodes;\n-extern GTY(()) int symtab_order;\n-extern bool cpp_implicit_aliases_done;\n+class GTY((tag (\"SYMTAB\"))) symbol_table\n+{\n+public:\n+  friend class symtab_node;\n+  friend class cgraph_node;\n+  friend class cgraph_edge;\n+\n+  /* Initialize callgraph dump file.  */\n+  inline void\n+  initialize (void)\n+  {\n+    if (!dump_file)\n+      dump_file = dump_begin (TDI_cgraph, NULL);\n+  }\n+\n+  /* Register a top-level asm statement ASM_STR.  */\n+  inline asm_node *finalize_toplevel_asm (tree asm_str);\n+\n+  /* Analyze the whole compilation unit once it is parsed completely.  */\n+  void finalize_compilation_unit (void);\n+\n+  /* C++ frontend produce same body aliases all over the place, even before PCH\n+     gets streamed out. It relies on us linking the aliases with their function\n+     in order to do the fixups, but ipa-ref is not PCH safe.  Consequentely we\n+     first produce aliases without links, but once C++ FE is sure he won't sream\n+     PCH we build the links via this function.  */\n+  void process_same_body_aliases (void);\n+\n+  /* Perform simple optimizations based on callgraph.  */\n+  void compile (void);\n+\n+  /* Process CGRAPH_NEW_FUNCTIONS and perform actions necessary to add these\n+     functions into callgraph in a way so they look like ordinary reachable\n+     functions inserted into callgraph already at construction time.  */\n+  void process_new_functions (void);\n+\n+  /* Once all functions from compilation unit are in memory, produce all clones\n+     and update all calls.  We might also do this on demand if we don't want to\n+     bring all functions to memory prior compilation, but current WHOPR\n+     implementation does that and it is is bit easier to keep everything right\n+     in this order.  */\n+  void materialize_all_clones (void);\n+\n+  /* Register a symbol NODE.  */\n+  inline void register_symbol (symtab_node *node);\n+\n+  inline void\n+  clear_asm_symbols (void)\n+  {\n+    asmnodes = NULL;\n+    asm_last_node = NULL;\n+  }\n+\n+  /* Perform reachability analysis and reclaim all unreachable nodes.  */\n+  bool remove_unreachable_nodes (bool before_inlining_p, FILE *file);\n+\n+  /* Optimization of function bodies might've rendered some variables as\n+     unnecessary so we want to avoid these from being compiled.  Re-do\n+     reachability starting from variables that are either externally visible\n+     or was referred from the asm output routines.  */\n+  void remove_unreferenced_decls (void);\n+\n+  /* Unregister a symbol NODE.  */\n+  inline void unregister (symtab_node *node);\n+\n+  /* Allocate new callgraph node and insert it into basic data structures.  */\n+  cgraph_node *create_empty (void);\n+\n+  /* Release a callgraph NODE with UID and put in to the list\n+     of free nodes.  */\n+  void release_symbol (cgraph_node *node, int uid);\n+\n+  /* Output all variables enqueued to be assembled.  */\n+  bool output_variables (void);\n+\n+  /* Output all asm statements we have stored up to be output.  */\n+  void output_asm_statements (void);\n+\n+  /* Weakrefs may be associated to external decls and thus not output\n+     at expansion time.  Emit all necessary aliases.  */\n+  void output_weakrefs (void);\n+\n+  /* Return first static symbol with definition.  */\n+  inline symtab_node *first_symbol (void);\n+\n+  /* Return first assembler symbol.  */\n+  inline asm_node *\n+  first_asm_symbol (void)\n+  {\n+    return asmnodes;\n+  }\n+\n+  /* Return first static symbol with definition.  */\n+  inline symtab_node *first_defined_symbol (void);\n+\n+  /* Return first variable.  */\n+  inline varpool_node *first_variable (void);\n+\n+  /* Return next variable after NODE.  */\n+  inline varpool_node *next_variable (varpool_node *node);\n+\n+  /* Return first static variable with initializer.  */\n+  inline varpool_node *first_static_initializer (void);\n+\n+  /* Return next static variable with initializer after NODE.  */\n+  inline varpool_node *next_static_initializer (varpool_node *node);\n+\n+  /* Return first static variable with definition.  */\n+  inline varpool_node *first_defined_variable (void);\n+\n+  /* Return next static variable with definition after NODE.  */\n+  inline varpool_node *next_defined_variable (varpool_node *node);\n+\n+  /* Return first function with body defined.  */\n+  inline cgraph_node *first_defined_function (void);\n+\n+  /* Return next function with body defined after NODE.  */\n+  inline cgraph_node *next_defined_function (cgraph_node *node);\n+\n+  /* Return first function.  */\n+  inline cgraph_node *first_function (void);\n+\n+  /* Return next function.  */\n+  inline cgraph_node *next_function (cgraph_node *node);\n+\n+  /* Return first function with body defined.  */\n+  cgraph_node *first_function_with_gimple_body (void);\n+\n+  /* Return next reachable static variable with initializer after NODE.  */\n+  inline cgraph_node *next_function_with_gimple_body (cgraph_node *node);\n+\n+  /* Register HOOK to be called with DATA on each removed edge.  */\n+  cgraph_edge_hook_list *add_edge_removal_hook (cgraph_edge_hook hook,\n+\t\t\t\t\t\tvoid *data);\n+\n+  /* Remove ENTRY from the list of hooks called on removing edges.  */\n+  void remove_edge_removal_hook (cgraph_edge_hook_list *entry);\n+\n+  /* Register HOOK to be called with DATA on each removed node.  */\n+  cgraph_node_hook_list *add_cgraph_removal_hook (cgraph_node_hook hook,\n+\t\t\t\t\t\t  void *data);\n+\n+  /* Remove ENTRY from the list of hooks called on removing nodes.  */\n+  void remove_cgraph_removal_hook (cgraph_node_hook_list *entry);\n+\n+  /* Register HOOK to be called with DATA on each removed node.  */\n+  varpool_node_hook_list *add_varpool_removal_hook (varpool_node_hook hook,\n+\t\t\t\t\t\t    void *data);\n+\n+  /* Remove ENTRY from the list of hooks called on removing nodes.  */\n+  void remove_varpool_removal_hook (varpool_node_hook_list *entry);\n+\n+  /* Register HOOK to be called with DATA on each inserted node.  */\n+  cgraph_node_hook_list *add_cgraph_insertion_hook (cgraph_node_hook hook,\n+\t\t\t\t\t\t    void *data);\n+\n+  /* Remove ENTRY from the list of hooks called on inserted nodes.  */\n+  void remove_cgraph_insertion_hook (cgraph_node_hook_list *entry);\n+\n+  /* Register HOOK to be called with DATA on each inserted node.  */\n+  varpool_node_hook_list *add_varpool_insertion_hook (varpool_node_hook hook,\n+\t\t\t\t\t\t      void *data);\n+\n+  /* Remove ENTRY from the list of hooks called on inserted nodes.  */\n+  void remove_varpool_insertion_hook (varpool_node_hook_list *entry);\n+\n+  /* Register HOOK to be called with DATA on each duplicated edge.  */\n+  cgraph_2edge_hook_list *add_edge_duplication_hook (cgraph_2edge_hook hook,\n+\t\t\t\t\t\t     void *data);\n+  /* Remove ENTRY from the list of hooks called on duplicating edges.  */\n+  void remove_edge_duplication_hook (cgraph_2edge_hook_list *entry);\n+\n+  /* Register HOOK to be called with DATA on each duplicated node.  */\n+  cgraph_2node_hook_list *add_cgraph_duplication_hook (cgraph_2node_hook hook,\n+\t\t\t\t\t\t       void *data);\n+\n+  /* Remove ENTRY from the list of hooks called on duplicating nodes.  */\n+  void remove_cgraph_duplication_hook (cgraph_2node_hook_list *entry);\n+\n+  /* Call all edge removal hooks.  */\n+  void call_edge_removal_hooks (cgraph_edge *e);\n+\n+  /* Call all node insertion hooks.  */\n+  void call_cgraph_insertion_hooks (cgraph_node *node);\n+\n+  /* Call all node removal hooks.  */\n+  void call_cgraph_removal_hooks (cgraph_node *node);\n+\n+  /* Call all node duplication hooks.  */\n+  void call_cgraph_duplication_hooks (cgraph_node *node, cgraph_node *node2);\n+\n+  /* Call all edge duplication hooks.  */\n+  void call_edge_duplication_hooks (cgraph_edge *cs1, cgraph_edge *cs2);\n+\n+  /* Call all node removal hooks.  */\n+  void call_varpool_removal_hooks (varpool_node *node);\n+\n+  /* Call all node insertion hooks.  */\n+  void call_varpool_insertion_hooks (varpool_node *node);\n+\n+  /* Arrange node to be first in its entry of assembler_name_hash.  */\n+  void symtab_prevail_in_asm_name_hash (symtab_node *node);\n+\n+  /* Initalize asm name hash unless.  */\n+  void symtab_initialize_asm_name_hash (void);\n+\n+  /* Set the DECL_ASSEMBLER_NAME and update symtab hashtables.  */\n+  void change_decl_assembler_name (tree decl, tree name);\n \n-/* In symtab.c  */\n-symtab_node *symtab_node_for_asm (const_tree asmname);\n+  int cgraph_count;\n+  int cgraph_max_uid;\n+\n+  int edges_count;\n+  int edges_max_uid;\n+\n+  symtab_node* GTY(()) nodes;\n+  asm_node* GTY(()) asmnodes;\n+  asm_node* GTY(()) asm_last_node;\n+  cgraph_node* GTY(()) free_nodes;\n+\n+  /* Head of a linked list of unused (freed) call graph edges.\n+     Do not GTY((delete)) this list so UIDs gets reliably recycled.  */\n+  cgraph_edge * GTY(()) free_edges;\n+\n+  /* The order index of the next symtab node to be created.  This is\n+     used so that we can sort the cgraph nodes in order by when we saw\n+     them, to support -fno-toplevel-reorder.  */\n+  int order;\n+\n+  /* Set when whole unit has been analyzed so we can access global info.  */\n+  bool global_info_ready;\n+  /* What state callgraph is in right now.  */\n+  enum symtab_state state;\n+  /* Set when the cgraph is fully build and the basic flags are computed.  */\n+  bool function_flags_ready;\n+\n+  bool cpp_implicit_aliases_done;\n+\n+  /* Hash table used to hold sectoons.  */\n+  htab_t GTY((param_is (section_hash_entry))) section_hash;\n+\n+  /* Hash table used to convert assembler names into nodes.  */\n+  htab_t GTY((param_is (symtab_node))) assembler_name_hash;\n+\n+  /* Hash table used to hold init priorities.  */\n+  htab_t GTY ((param_is (symbol_priority_map))) init_priority_hash;\n+\n+  FILE* GTY ((skip)) dump_file;\n+\n+private:\n+  /* Allocate new callgraph node.  */\n+  inline cgraph_node * allocate_cgraph_symbol (void);\n+\n+  /* Allocate a cgraph_edge structure and fill it with data according to the\n+     parameters of which only CALLEE can be NULL (when creating an indirect call\n+     edge).  */\n+  cgraph_edge *create_edge (cgraph_node *caller, cgraph_node *callee,\n+\t\t\t    gimple call_stmt, gcov_type count, int freq,\n+\t\t\t    bool indir_unknown_callee);\n+\n+  /* Put the edge onto the free list.  */\n+  void free_edge (cgraph_edge *e);\n+\n+  /* Insert NODE to assembler name hash.  */\n+  void insert_to_assembler_name_hash (symtab_node *node, bool with_clones);\n+\n+  /* Remove NODE from assembler name hash.  */\n+  void unlink_from_assembler_name_hash (symtab_node *node, bool with_clones);\n+\n+  /* Hash asmnames ignoring the user specified marks.  */\n+  static hashval_t decl_assembler_name_hash (const_tree asmname);\n+\n+  /* Compare ASMNAME with the DECL_ASSEMBLER_NAME of DECL.  */\n+  static bool decl_assembler_name_equal (tree decl, const_tree asmname);\n+\n+  /* Returns a hash code for P.  */\n+  static hashval_t hash_node_by_assembler_name (const void *p);\n+\n+  /* Returns nonzero if P1 and P2 are equal.  */\n+  static int eq_assembler_name (const void *p1, const void *p2);\n+\n+  /* List of hooks triggered when an edge is removed.  */\n+  cgraph_edge_hook_list * GTY((skip)) m_first_edge_removal_hook;\n+  /* List of hooks triggem_red when a cgraph node is removed.  */\n+  cgraph_node_hook_list * GTY((skip)) m_first_cgraph_removal_hook;\n+  /* List of hooks triggered when an edge is duplicated.  */\n+  cgraph_2edge_hook_list * GTY((skip)) m_first_edge_duplicated_hook;\n+  /* List of hooks triggered when a node is duplicated.  */\n+  cgraph_2node_hook_list * GTY((skip)) m_first_cgraph_duplicated_hook;\n+  /* List of hooks triggered when an function is inserted.  */\n+  cgraph_node_hook_list * GTY((skip)) m_first_cgraph_insertion_hook;\n+  /* List of hooks triggered when an variable is inserted.  */\n+  varpool_node_hook_list * GTY((skip)) m_first_varpool_insertion_hook;\n+  /* List of hooks triggered when a node is removed.  */\n+  varpool_node_hook_list * GTY((skip)) m_first_varpool_removal_hook;\n+};\n+\n+extern GTY(()) symbol_table *symtab;\n+\n+extern vec<cgraph_node *> cgraph_new_nodes;\n \n /* In cgraph.c  */\n void release_function_body (tree);\n-struct cgraph_indirect_call_info *cgraph_allocate_init_indirect_info (void);\n-void cgraph_remove_edge (struct cgraph_edge *);\n+cgraph_indirect_call_info *cgraph_allocate_init_indirect_info (void);\n \n-void cgraph_set_call_stmt (struct cgraph_edge *, gimple, bool update_speculative = true);\n void cgraph_update_edges_for_call_stmt (gimple, tree, gimple);\n-struct cgraph_local_info *cgraph_local_info (tree);\n-struct cgraph_global_info *cgraph_global_info (tree);\n-struct cgraph_rtl_info *cgraph_rtl_info (tree);\n-void cgraph_call_edge_duplication_hooks (struct cgraph_edge *,\n-\t\t\t\t         struct cgraph_edge *);\n-\n bool cgraph_function_possibly_inlined_p (tree);\n-bool cgraph_edge_cannot_lead_to_return (struct cgraph_edge *);\n-void cgraph_redirect_edge_callee (struct cgraph_edge *, cgraph_node *);\n-struct cgraph_edge *cgraph_make_edge_direct (struct cgraph_edge *,\n-\t\t\t\t\t     cgraph_node *);\n \n const char* cgraph_inline_failed_string (cgraph_inline_failed_t);\n cgraph_inline_failed_type_t cgraph_inline_failed_type (cgraph_inline_failed_t);\n \n bool resolution_used_from_other_file_p (enum ld_plugin_symbol_resolution);\n-typedef void (*cgraph_edge_hook)(struct cgraph_edge *, void *);\n-typedef void (*cgraph_node_hook)(cgraph_node *, void *);\n-typedef void (*varpool_node_hook)(varpool_node *, void *);\n-typedef void (*cgraph_2edge_hook)(struct cgraph_edge *, struct cgraph_edge *,\n-\t\t\t\t  void *);\n-typedef void (*cgraph_2node_hook)(cgraph_node *, cgraph_node *,\n-\t\t\t\t  void *);\n-struct cgraph_edge_hook_list;\n-struct cgraph_node_hook_list;\n-struct varpool_node_hook_list;\n-struct cgraph_2edge_hook_list;\n-struct cgraph_2node_hook_list;\n-struct cgraph_edge_hook_list *cgraph_add_edge_removal_hook (cgraph_edge_hook, void *);\n-void cgraph_remove_edge_removal_hook (struct cgraph_edge_hook_list *);\n-cgraph_node_hook_list *cgraph_add_node_removal_hook (cgraph_node_hook,\n-\t\t\t\t\t\t\t    void *);\n-void cgraph_remove_node_removal_hook (cgraph_node_hook_list *);\n-struct varpool_node_hook_list *varpool_add_node_removal_hook (varpool_node_hook,\n-\t\t\t\t\t\t\t      void *);\n-void varpool_remove_node_removal_hook (struct varpool_node_hook_list *);\n-cgraph_node_hook_list *cgraph_add_function_insertion_hook (cgraph_node_hook,\n-\t\t\t\t\t\t\t          void *);\n-void cgraph_remove_function_insertion_hook (cgraph_node_hook_list *);\n-struct varpool_node_hook_list *varpool_add_variable_insertion_hook (varpool_node_hook,\n-\t\t\t\t\t\t\t            void *);\n-void varpool_remove_variable_insertion_hook (struct varpool_node_hook_list *);\n-struct cgraph_2edge_hook_list *cgraph_add_edge_duplication_hook (cgraph_2edge_hook, void *);\n-void cgraph_remove_edge_duplication_hook (struct cgraph_2edge_hook_list *);\n-struct cgraph_2node_hook_list *cgraph_add_node_duplication_hook (cgraph_2node_hook, void *);\n-void cgraph_remove_node_duplication_hook (struct cgraph_2node_hook_list *);\n-gimple cgraph_redirect_edge_call_stmt_to_callee (struct cgraph_edge *);\n-struct cgraph_edge *\n-cgraph_turn_edge_to_speculative (struct cgraph_edge *,\n-\t\t\t\t cgraph_node *,\n-\t\t\t\t gcov_type, int);\n-void cgraph_speculative_call_info (struct cgraph_edge *,\n-\t\t\t\t   struct cgraph_edge *&,\n-\t\t\t\t   struct cgraph_edge *&,\n-\t\t\t\t   struct ipa_ref *&);\n extern bool gimple_check_call_matching_types (gimple, tree, bool);\n \n /* In cgraphunit.c  */\n-struct asm_node *add_asm_node (tree);\n-extern FILE *cgraph_dump_file;\n-void cgraph_finalize_function (tree, bool);\n-void finalize_compilation_unit (void);\n-void compile (void);\n-void init_cgraph (void);\n-void cgraph_process_new_functions (void);\n-void cgraph_process_same_body_aliases (void);\n /*  Initialize datastructures so DECL is a function in lowered gimple form.\n     IN_SSA is true if the gimple is in SSA.  */\n basic_block init_lowered_empty_function (tree, bool);\n \n /* In cgraphclones.c  */\n \n-struct cgraph_edge * cgraph_clone_edge (struct cgraph_edge *,\n-\t\t\t\t\tcgraph_node *, gimple,\n-\t\t\t\t\tunsigned, gcov_type, int, bool);\n tree clone_function_name (tree decl, const char *);\n \n-void cgraph_materialize_all_clones (void);\n void tree_function_versioning (tree, tree, vec<ipa_replace_map *, va_gc> *,\n \t\t\t       bool, bitmap, bool, bitmap, basic_block);\n-struct cgraph_edge *cgraph_resolve_speculation (struct cgraph_edge *, tree);\n \n /* In cgraphbuild.c  */\n-unsigned int rebuild_cgraph_edges (void);\n-void cgraph_rebuild_references (void);\n int compute_call_stmt_bb_frequency (tree, basic_block bb);\n void record_references_in_initializer (tree, bool);\n \n /* In ipa.c  */\n-bool symtab_remove_unreachable_nodes (bool, FILE *);\n void cgraph_build_static_cdtor (char which, tree body, int priority);\n void ipa_discover_readonly_nonaddressable_vars (void);\n \n-/* In predict.c  */\n-bool cgraph_maybe_hot_edge_p (struct cgraph_edge *e);\n-\n /* In varpool.c  */\n-void varpool_reset_queue (void);\n tree ctor_for_folding (tree);\n-void varpool_add_new_variable (tree);\n-void symtab_initialize_asm_name_hash (void);\n-void symtab_prevail_in_asm_name_hash (symtab_node *node);\n-\n-/* In cgraph.c */\n-extern void change_decl_assembler_name (tree, tree);\n \n /* Return true when the symbol is real symbol, i.e. it is not inline clone\n    or abstract function kept for debug info purposes only.  */\n@@ -1685,7 +2016,7 @@ symtab_node::in_same_comdat_group_p (symtab_node *target)\n inline symtab_node *\n symtab_node::get_alias_target (void)\n {\n-  struct ipa_ref *ref = NULL;\n+  ipa_ref *ref = NULL;\n   iterate_reference (0, ref);\n   gcc_checking_assert (ref->use == IPA_REF_ALIAS);\n   return ref->referred;\n@@ -1705,24 +2036,137 @@ symtab_node::next_defined_symbol (void)\n }\n \n /* Return varpool node for given symbol and check it is a function. */\n+\n inline varpool_node *\n varpool_node::get (const_tree decl)\n {\n   gcc_checking_assert (TREE_CODE (decl) == VAR_DECL);\n   return dyn_cast<varpool_node *> (symtab_node::get (decl));\n }\n \n+/* Register a symbol NODE.  */\n+\n+inline void\n+symbol_table::register_symbol (symtab_node *node)\n+{\n+  node->next = nodes;\n+  node->previous = NULL;\n+\n+  if (nodes)\n+    nodes->previous = node;\n+  nodes = node;\n+\n+  node->order = order++;\n+}\n+\n+/* Register a top-level asm statement ASM_STR.  */\n+\n+asm_node *\n+symbol_table::finalize_toplevel_asm (tree asm_str)\n+{\n+  asm_node *node;\n+\n+  node = ggc_cleared_alloc<asm_node> ();\n+  node->asm_str = asm_str;\n+  node->order = order++;\n+  node->next = NULL;\n+\n+  if (asmnodes == NULL)\n+    asmnodes = node;\n+  else\n+    asm_last_node->next = node;\n+\n+  asm_last_node = node;\n+  return node;\n+}\n+\n+/* Unregister a symbol NODE.  */\n+inline void\n+symbol_table::unregister (symtab_node *node)\n+{\n+  if (node->previous)\n+    node->previous->next = node->next;\n+  else\n+    nodes = node->next;\n+\n+  if (node->next)\n+    node->next->previous = node->previous;\n+\n+  node->next = NULL;\n+  node->previous = NULL;\n+}\n+\n+/* Allocate new callgraph node and insert it into basic data structures.  */\n+\n+inline cgraph_node *\n+symbol_table::create_empty (void)\n+{\n+  cgraph_node *node = allocate_cgraph_symbol ();\n+\n+  node->type = SYMTAB_FUNCTION;\n+  node->frequency = NODE_FREQUENCY_NORMAL;\n+  node->count_materialization_scale = REG_BR_PROB_BASE;\n+  cgraph_count++;\n+\n+  return node;\n+}\n+\n+/* Release a callgraph NODE with UID and put in to the list of free nodes.  */\n+\n+inline void\n+symbol_table::release_symbol (cgraph_node *node, int uid)\n+{\n+  cgraph_count--;\n+\n+  /* Clear out the node to NULL all pointers and add the node to the free\n+     list.  */\n+  memset (node, 0, sizeof (*node));\n+  node->type = SYMTAB_FUNCTION;\n+  node->uid = uid;\n+  SET_NEXT_FREE_NODE (node, free_nodes);\n+  free_nodes = node;\n+}\n+\n+/* Allocate new callgraph node.  */\n+\n+inline cgraph_node *\n+symbol_table::allocate_cgraph_symbol (void)\n+{\n+  cgraph_node *node;\n+\n+  if (free_nodes)\n+    {\n+      node = free_nodes;\n+      free_nodes = NEXT_FREE_NODE (node);\n+    }\n+  else\n+    {\n+      node = ggc_cleared_alloc<cgraph_node> ();\n+      node->uid = cgraph_max_uid++;\n+    }\n+\n+  return node;\n+}\n+\n+\n+/* Return first static symbol with definition.  */\n+inline symtab_node *\n+symbol_table::first_symbol (void)\n+{\n+  return nodes;\n+}\n+\n /* Walk all symbols.  */\n #define FOR_EACH_SYMBOL(node) \\\n-   for ((node) = symtab_nodes; (node); (node) = (node)->next)\n+   for ((node) = symtab->first_symbol (); (node); (node) = (node)->next)\n \n /* Return first static symbol with definition.  */\n-static inline symtab_node *\n-symtab_first_defined_symbol (void)\n+inline symtab_node *\n+symbol_table::first_defined_symbol (void)\n {\n   symtab_node *node;\n \n-  for (node = symtab_nodes; node; node = node->next)\n+  for (node = nodes; node; node = node->next)\n     if (node->definition)\n       return node;\n \n@@ -1731,23 +2175,23 @@ symtab_first_defined_symbol (void)\n \n /* Walk all symbols with definitions in current unit.  */\n #define FOR_EACH_DEFINED_SYMBOL(node) \\\n-   for ((node) = symtab_first_defined_symbol (); (node); \\\n+   for ((node) = symtab->first_defined_symbol (); (node); \\\n \t(node) = node->next_defined_symbol ())\n \n /* Return first variable.  */\n-static inline varpool_node *\n-varpool_first_variable (void)\n+inline varpool_node *\n+symbol_table::first_variable (void)\n {\n   symtab_node *node;\n-  for (node = symtab_nodes; node; node = node->next)\n+  for (node = nodes; node; node = node->next)\n     if (varpool_node *vnode = dyn_cast <varpool_node *> (node))\n       return vnode;\n   return NULL;\n }\n \n /* Return next variable after NODE.  */\n-static inline varpool_node *\n-varpool_next_variable (varpool_node *node)\n+inline varpool_node *\n+symbol_table::next_variable (varpool_node *node)\n {\n   symtab_node *node1 = node->next;\n   for (; node1; node1 = node1->next)\n@@ -1757,16 +2201,16 @@ varpool_next_variable (varpool_node *node)\n }\n /* Walk all variables.  */\n #define FOR_EACH_VARIABLE(node) \\\n-   for ((node) = varpool_first_variable (); \\\n+   for ((node) = symtab->first_variable (); \\\n         (node); \\\n-\t(node) = varpool_next_variable ((node)))\n+\t(node) = symtab->next_variable ((node)))\n \n /* Return first static variable with initializer.  */\n-static inline varpool_node *\n-varpool_first_static_initializer (void)\n+inline varpool_node *\n+symbol_table::first_static_initializer (void)\n {\n   symtab_node *node;\n-  for (node = symtab_nodes; node; node = node->next)\n+  for (node = nodes; node; node = node->next)\n     {\n       varpool_node *vnode = dyn_cast <varpool_node *> (node);\n       if (vnode && DECL_INITIAL (node->decl))\n@@ -1776,8 +2220,8 @@ varpool_first_static_initializer (void)\n }\n \n /* Return next static variable with initializer after NODE.  */\n-static inline varpool_node *\n-varpool_next_static_initializer (varpool_node *node)\n+inline varpool_node *\n+symbol_table::next_static_initializer (varpool_node *node)\n {\n   symtab_node *node1 = node->next;\n   for (; node1; node1 = node1->next)\n@@ -1791,15 +2235,15 @@ varpool_next_static_initializer (varpool_node *node)\n \n /* Walk all static variables with initializer set.  */\n #define FOR_EACH_STATIC_INITIALIZER(node) \\\n-   for ((node) = varpool_first_static_initializer (); (node); \\\n-        (node) = varpool_next_static_initializer (node))\n+   for ((node) = symtab->first_static_initializer (); (node); \\\n+\t(node) = symtab->next_static_initializer (node))\n \n /* Return first static variable with definition.  */\n-static inline varpool_node *\n-varpool_first_defined_variable (void)\n+inline varpool_node *\n+symbol_table::first_defined_variable (void)\n {\n   symtab_node *node;\n-  for (node = symtab_nodes; node; node = node->next)\n+  for (node = nodes; node; node = node->next)\n     {\n       varpool_node *vnode = dyn_cast <varpool_node *> (node);\n       if (vnode && vnode->definition)\n@@ -1809,8 +2253,8 @@ varpool_first_defined_variable (void)\n }\n \n /* Return next static variable with definition after NODE.  */\n-static inline varpool_node *\n-varpool_next_defined_variable (varpool_node *node)\n+inline varpool_node *\n+symbol_table::next_defined_variable (varpool_node *node)\n {\n   symtab_node *node1 = node->next;\n   for (; node1; node1 = node1->next)\n@@ -1823,15 +2267,15 @@ varpool_next_defined_variable (varpool_node *node)\n }\n /* Walk all variables with definitions in current unit.  */\n #define FOR_EACH_DEFINED_VARIABLE(node) \\\n-   for ((node) = varpool_first_defined_variable (); (node); \\\n-        (node) = varpool_next_defined_variable (node))\n+   for ((node) = symtab->first_defined_variable (); (node); \\\n+\t(node) = symtab->next_defined_variable (node))\n \n /* Return first function with body defined.  */\n-static inline cgraph_node *\n-cgraph_first_defined_function (void)\n+inline cgraph_node *\n+symbol_table::first_defined_function (void)\n {\n   symtab_node *node;\n-  for (node = symtab_nodes; node; node = node->next)\n+  for (node = nodes; node; node = node->next)\n     {\n       cgraph_node *cn = dyn_cast <cgraph_node *> (node);\n       if (cn && cn->definition)\n@@ -1841,8 +2285,8 @@ cgraph_first_defined_function (void)\n }\n \n /* Return next function with body defined after NODE.  */\n-static inline cgraph_node *\n-cgraph_next_defined_function (cgraph_node *node)\n+inline cgraph_node *\n+symbol_table::next_defined_function (cgraph_node *node)\n {\n   symtab_node *node1 = node->next;\n   for (; node1; node1 = node1->next)\n@@ -1856,53 +2300,37 @@ cgraph_next_defined_function (cgraph_node *node)\n \n /* Walk all functions with body defined.  */\n #define FOR_EACH_DEFINED_FUNCTION(node) \\\n-   for ((node) = cgraph_first_defined_function (); (node); \\\n-        (node) = cgraph_next_defined_function ((node)))\n+   for ((node) = symtab->first_defined_function (); (node); \\\n+\t(node) = symtab->next_defined_function ((node)))\n \n /* Return first function.  */\n-static inline cgraph_node *\n-cgraph_first_function (void)\n+inline cgraph_node *\n+symbol_table::first_function (void)\n {\n   symtab_node *node;\n-  for (node = symtab_nodes; node; node = node->next)\n+  for (node = nodes; node; node = node->next)\n     if (cgraph_node *cn = dyn_cast <cgraph_node *> (node))\n       return cn;\n   return NULL;\n }\n \n /* Return next function.  */\n-static inline cgraph_node *\n-cgraph_next_function (cgraph_node *node)\n+inline cgraph_node *\n+symbol_table::next_function (cgraph_node *node)\n {\n   symtab_node *node1 = node->next;\n   for (; node1; node1 = node1->next)\n     if (cgraph_node *cn1 = dyn_cast <cgraph_node *> (node1))\n       return cn1;\n   return NULL;\n }\n-/* Walk all functions.  */\n-#define FOR_EACH_FUNCTION(node) \\\n-   for ((node) = cgraph_first_function (); (node); \\\n-        (node) = cgraph_next_function ((node)))\n-\n-/* Return true when callgraph node is a function with Gimple body defined\n-   in current unit.  Functions can also be define externally or they\n-   can be thunks with no Gimple representation.\n-\n-   Note that at WPA stage, the function body may not be present in memory.  */\n-\n-inline bool\n-cgraph_node::has_gimple_body_p (void)\n-{\n-  return definition && !thunk.thunk_p && !alias;\n-}\n \n /* Return first function with body defined.  */\n-static inline cgraph_node *\n-cgraph_first_function_with_gimple_body (void)\n+inline cgraph_node *\n+symbol_table::first_function_with_gimple_body (void)\n {\n   symtab_node *node;\n-  for (node = symtab_nodes; node; node = node->next)\n+  for (node = nodes; node; node = node->next)\n     {\n       cgraph_node *cn = dyn_cast <cgraph_node *> (node);\n       if (cn && cn->has_gimple_body_p ())\n@@ -1912,8 +2340,8 @@ cgraph_first_function_with_gimple_body (void)\n }\n \n /* Return next reachable static variable with initializer after NODE.  */\n-static inline cgraph_node *\n-cgraph_next_function_with_gimple_body (cgraph_node *node)\n+inline cgraph_node *\n+symbol_table::next_function_with_gimple_body (cgraph_node *node)\n {\n   symtab_node *node1 = node->next;\n   for (; node1; node1 = node1->next)\n@@ -1925,10 +2353,27 @@ cgraph_next_function_with_gimple_body (cgraph_node *node)\n   return NULL;\n }\n \n+/* Walk all functions.  */\n+#define FOR_EACH_FUNCTION(node) \\\n+   for ((node) = symtab->first_function (); (node); \\\n+\t(node) = symtab->next_function ((node)))\n+\n+/* Return true when callgraph node is a function with Gimple body defined\n+   in current unit.  Functions can also be define externally or they\n+   can be thunks with no Gimple representation.\n+\n+   Note that at WPA stage, the function body may not be present in memory.  */\n+\n+inline bool\n+cgraph_node::has_gimple_body_p (void)\n+{\n+  return definition && !thunk.thunk_p && !alias;\n+}\n+\n /* Walk all functions with body defined.  */\n #define FOR_EACH_FUNCTION_WITH_GIMPLE_BODY(node) \\\n-   for ((node) = cgraph_first_function_with_gimple_body (); (node); \\\n-        (node) = cgraph_next_function_with_gimple_body (node))\n+   for ((node) = symtab->first_function_with_gimple_body (); (node); \\\n+\t(node) = symtab->next_function_with_gimple_body (node))\n \n /* Create a new static variable of type TYPE.  */\n tree add_new_static_var (tree type);\n@@ -2044,15 +2489,15 @@ varpool_node::ultimate_alias_target (availability *availability)\n   return n;\n }\n \n-/* Return true when the edge E represents a direct recursion.  */\n-static inline bool\n-cgraph_edge_recursive_p (struct cgraph_edge *e)\n+/* Return true when the edge represents a direct recursion.  */\n+inline bool\n+cgraph_edge::recursive_p (void)\n {\n-  cgraph_node *callee = e->callee->ultimate_alias_target ();\n-  if (e->caller->global.inlined_to)\n-    return e->caller->global.inlined_to->decl == callee->decl;\n+  cgraph_node *c = callee->ultimate_alias_target ();\n+  if (caller->global.inlined_to)\n+    return caller->global.inlined_to->decl == c->decl;\n   else\n-    return e->caller->decl == callee->decl;\n+    return caller->decl == c->decl;\n }\n \n /* Return true if the TM_CLONE bit is set for a given FNDECL.  */"}, {"sha": "96d7015b75e0424c1369a207e2781ee1a0f0461a", "filename": "gcc/cgraphbuild.c", "status": "modified", "additions": 34, "deletions": 32, "changes": 66, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3dafb85c8e6ade82adc591fe97c116b193f8bb0d/gcc%2Fcgraphbuild.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3dafb85c8e6ade82adc591fe97c116b193f8bb0d/gcc%2Fcgraphbuild.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraphbuild.c?ref=3dafb85c8e6ade82adc591fe97c116b193f8bb0d", "patch": "@@ -56,7 +56,7 @@ record_reference (tree *tp, int *walk_subtrees, void *data)\n {\n   tree t = *tp;\n   tree decl;\n-  struct record_reference_ctx *ctx = (struct record_reference_ctx *)data;\n+  record_reference_ctx *ctx = (record_reference_ctx *)data;\n \n   t = canonicalize_constructor_val (t, NULL);\n   if (!t)\n@@ -78,16 +78,16 @@ record_reference (tree *tp, int *walk_subtrees, void *data)\n       decl = get_base_var (*tp);\n       if (TREE_CODE (decl) == FUNCTION_DECL)\n \t{\n-\t  struct cgraph_node *node = cgraph_node::get_create (decl);\n+\t  cgraph_node *node = cgraph_node::get_create (decl);\n \t  if (!ctx->only_vars)\n \t    node->mark_address_taken ();\n-\t  ctx->varpool_node->add_reference (node, IPA_REF_ADDR);\n+\t  ctx->varpool_node->create_reference (node, IPA_REF_ADDR);\n \t}\n \n       if (TREE_CODE (decl) == VAR_DECL)\n \t{\n \t  varpool_node *vnode = varpool_node::get_create (decl);\n-\t  ctx->varpool_node->add_reference (vnode, IPA_REF_ADDR);\n+\t  ctx->varpool_node->create_reference (vnode, IPA_REF_ADDR);\n \t}\n       *walk_subtrees = 0;\n       break;\n@@ -109,7 +109,7 @@ record_reference (tree *tp, int *walk_subtrees, void *data)\n /* Record references to typeinfos in the type list LIST.  */\n \n static void\n-record_type_list (struct cgraph_node *node, tree list)\n+record_type_list (cgraph_node *node, tree list)\n {\n   for (; list; list = TREE_CHAIN (list))\n     {\n@@ -124,7 +124,7 @@ record_type_list (struct cgraph_node *node, tree list)\n \t  if (TREE_CODE (type) == VAR_DECL)\n \t    {\n \t      varpool_node *vnode = varpool_node::get_create (type);\n-\t      node->add_reference (vnode, IPA_REF_ADDR);\n+\t      node->create_reference (vnode, IPA_REF_ADDR);\n \t    }\n \t}\n     }\n@@ -134,16 +134,16 @@ record_type_list (struct cgraph_node *node, tree list)\n    for NODE.  */\n \n static void\n-record_eh_tables (struct cgraph_node *node, struct function *fun)\n+record_eh_tables (cgraph_node *node, function *fun)\n {\n   eh_region i;\n \n   if (DECL_FUNCTION_PERSONALITY (node->decl))\n     {\n       tree per_decl = DECL_FUNCTION_PERSONALITY (node->decl);\n-      struct cgraph_node *per_node = cgraph_node::get_create (per_decl);\n+      cgraph_node *per_node = cgraph_node::get_create (per_decl);\n \n-      node->add_reference (per_node, IPA_REF_ADDR);\n+      node->create_reference (per_node, IPA_REF_ADDR);\n       per_node->mark_address_taken ();\n     }\n \n@@ -222,16 +222,16 @@ mark_address (gimple stmt, tree addr, tree, void *data)\n   addr = get_base_address (addr);\n   if (TREE_CODE (addr) == FUNCTION_DECL)\n     {\n-      struct cgraph_node *node = cgraph_node::get_create (addr);\n+      cgraph_node *node = cgraph_node::get_create (addr);\n       node->mark_address_taken ();\n-      ((symtab_node *)data)->add_reference (node, IPA_REF_ADDR, stmt);\n+      ((symtab_node *)data)->create_reference (node, IPA_REF_ADDR, stmt);\n     }\n   else if (addr && TREE_CODE (addr) == VAR_DECL\n \t   && (TREE_STATIC (addr) || DECL_EXTERNAL (addr)))\n     {\n       varpool_node *vnode = varpool_node::get_create (addr);\n \n-      ((symtab_node *)data)->add_reference (vnode, IPA_REF_ADDR, stmt);\n+      ((symtab_node *)data)->create_reference (vnode, IPA_REF_ADDR, stmt);\n     }\n \n   return false;\n@@ -247,16 +247,16 @@ mark_load (gimple stmt, tree t, tree, void *data)\n     {\n       /* ??? This can happen on platforms with descriptors when these are\n \t directly manipulated in the code.  Pretend that it's an address.  */\n-      struct cgraph_node *node = cgraph_node::get_create (t);\n+      cgraph_node *node = cgraph_node::get_create (t);\n       node->mark_address_taken ();\n-      ((symtab_node *)data)->add_reference (node, IPA_REF_ADDR, stmt);\n+      ((symtab_node *)data)->create_reference (node, IPA_REF_ADDR, stmt);\n     }\n   else if (t && TREE_CODE (t) == VAR_DECL\n \t   && (TREE_STATIC (t) || DECL_EXTERNAL (t)))\n     {\n       varpool_node *vnode = varpool_node::get_create (t);\n \n-      ((symtab_node *)data)->add_reference (vnode, IPA_REF_LOAD, stmt);\n+      ((symtab_node *)data)->create_reference (vnode, IPA_REF_LOAD, stmt);\n     }\n   return false;\n }\n@@ -272,7 +272,7 @@ mark_store (gimple stmt, tree t, tree, void *data)\n     {\n       varpool_node *vnode = varpool_node::get_create (t);\n \n-      ((symtab_node *)data)->add_reference (vnode, IPA_REF_STORE, stmt);\n+      ((symtab_node *)data)->create_reference (vnode, IPA_REF_STORE, stmt);\n      }\n   return false;\n }\n@@ -320,7 +320,7 @@ unsigned int\n pass_build_cgraph_edges::execute (function *fun)\n {\n   basic_block bb;\n-  struct cgraph_node *node = cgraph_node::get (current_function_decl);\n+  cgraph_node *node = cgraph_node::get (current_function_decl);\n   gimple_stmt_iterator gsi;\n   tree decl;\n   unsigned ix;\n@@ -343,8 +343,7 @@ pass_build_cgraph_edges::execute (function *fun)\n \t\t\t\t\t\t\t bb);\n \t      decl = gimple_call_fndecl (stmt);\n \t      if (decl)\n-\t\tnode->create_edge (cgraph_node::get_create (decl),\n-\t\t\t\t   stmt, bb->count, freq);\n+\t\tnode->create_edge (cgraph_node::get_create (decl), stmt, bb->count, freq);\n \t      else if (gimple_call_internal_p (stmt))\n \t\t;\n \t      else\n@@ -357,18 +356,18 @@ pass_build_cgraph_edges::execute (function *fun)\n \t      && gimple_omp_parallel_child_fn (stmt))\n \t    {\n \t      tree fn = gimple_omp_parallel_child_fn (stmt);\n-\t      node->add_reference (cgraph_node::get_create (fn),\n+\t      node->create_reference (cgraph_node::get_create (fn),\n \t\t\t\t      IPA_REF_ADDR, stmt);\n \t    }\n \t  if (gimple_code (stmt) == GIMPLE_OMP_TASK)\n \t    {\n \t      tree fn = gimple_omp_task_child_fn (stmt);\n \t      if (fn)\n-\t\tnode->add_reference (cgraph_node::get_create (fn),\n+\t\tnode->create_reference (cgraph_node::get_create (fn),\n \t\t\t\t\tIPA_REF_ADDR, stmt);\n \t      fn = gimple_omp_task_copy_fn (stmt);\n \t      if (fn)\n-\t\tnode->add_reference (cgraph_node::get_create (fn),\n+\t\tnode->create_reference (cgraph_node::get_create (fn),\n \t\t\t\t\tIPA_REF_ADDR, stmt);\n \t    }\n \t}\n@@ -404,7 +403,7 @@ record_references_in_initializer (tree decl, bool only_vars)\n {\n   varpool_node *node = varpool_node::get_create (decl);\n   hash_set<tree> visited_nodes;\n-  struct record_reference_ctx ctx = {false, NULL};\n+  record_reference_ctx ctx = {false, NULL};\n \n   ctx.varpool_node = node;\n   ctx.only_vars = only_vars;\n@@ -416,10 +415,10 @@ record_references_in_initializer (tree decl, bool only_vars)\n    passes that don't update the cgraph.  */\n \n unsigned int\n-rebuild_cgraph_edges (void)\n+cgraph_edge::rebuild_edges (void)\n {\n   basic_block bb;\n-  struct cgraph_node *node = cgraph_node::get (current_function_decl);\n+  cgraph_node *node = cgraph_node::get (current_function_decl);\n   gimple_stmt_iterator gsi;\n \n   node->remove_callees ();\n@@ -460,16 +459,16 @@ rebuild_cgraph_edges (void)\n   return 0;\n }\n \n-/* Rebuild cgraph edges for current function node.  This needs to be run after\n-   passes that don't update the cgraph.  */\n+/* Rebuild cgraph references for current function node.  This needs to be run\n+   after passes that don't update the cgraph.  */\n \n void\n-cgraph_rebuild_references (void)\n+cgraph_edge::rebuild_references (void)\n {\n   basic_block bb;\n-  struct cgraph_node *node = cgraph_node::get (current_function_decl);\n+  cgraph_node *node = cgraph_node::get (current_function_decl);\n   gimple_stmt_iterator gsi;\n-  struct ipa_ref *ref = NULL;\n+  ipa_ref *ref = NULL;\n   int i;\n \n   /* Keep speculative references for further cgraph edge expansion.  */\n@@ -515,7 +514,10 @@ class pass_rebuild_cgraph_edges : public gimple_opt_pass\n \n   /* opt_pass methods: */\n   opt_pass * clone () { return new pass_rebuild_cgraph_edges (m_ctxt); }\n-  virtual unsigned int execute (function *) { return rebuild_cgraph_edges (); }\n+  virtual unsigned int execute (function *)\n+  {\n+    return cgraph_edge::rebuild_edges ();\n+  }\n \n }; // class pass_rebuild_cgraph_edges\n \n@@ -561,7 +563,7 @@ class pass_remove_cgraph_callee_edges : public gimple_opt_pass\n unsigned int\n pass_remove_cgraph_callee_edges::execute (function *)\n {\n-  struct cgraph_node *node = cgraph_node::get (current_function_decl);\n+  cgraph_node *node = cgraph_node::get (current_function_decl);\n   node->remove_callees ();\n   node->remove_all_references ();\n   return 0;"}, {"sha": "eb044184fe1b090e1b43b9639bc70db4260a4fd2", "filename": "gcc/cgraphclones.c", "status": "modified", "additions": 108, "deletions": 104, "changes": 212, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3dafb85c8e6ade82adc591fe97c116b193f8bb0d/gcc%2Fcgraphclones.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3dafb85c8e6ade82adc591fe97c116b193f8bb0d/gcc%2Fcgraphclones.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraphclones.c?ref=3dafb85c8e6ade82adc591fe97c116b193f8bb0d", "patch": "@@ -102,69 +102,70 @@ along with GCC; see the file COPYING3.  If not see\n #include \"lto-streamer.h\"\n #include \"except.h\"\n \n-/* Create clone of E in the node N represented by CALL_EXPR the callgraph.  */\n-struct cgraph_edge *\n-cgraph_clone_edge (struct cgraph_edge *e, struct cgraph_node *n,\n-\t\t   gimple call_stmt, unsigned stmt_uid, gcov_type count_scale,\n-\t\t   int freq_scale, bool update_original)\n+/* Create clone of edge in the node N represented by CALL_EXPR\n+   the callgraph.  */\n+\n+cgraph_edge *\n+cgraph_edge::clone (cgraph_node *n, gimple call_stmt, unsigned stmt_uid,\n+\t\t    gcov_type count_scale, int freq_scale, bool update_original)\n {\n-  struct cgraph_edge *new_edge;\n-  gcov_type count = apply_probability (e->count, count_scale);\n+  cgraph_edge *new_edge;\n+  gcov_type gcov_count = apply_probability (count, count_scale);\n   gcov_type freq;\n \n   /* We do not want to ignore loop nest after frequency drops to 0.  */\n   if (!freq_scale)\n     freq_scale = 1;\n-  freq = e->frequency * (gcov_type) freq_scale / CGRAPH_FREQ_BASE;\n+  freq = frequency * (gcov_type) freq_scale / CGRAPH_FREQ_BASE;\n   if (freq > CGRAPH_FREQ_MAX)\n     freq = CGRAPH_FREQ_MAX;\n \n-  if (e->indirect_unknown_callee)\n+  if (indirect_unknown_callee)\n     {\n       tree decl;\n \n       if (call_stmt && (decl = gimple_call_fndecl (call_stmt))\n \t  /* When the call is speculative, we need to resolve it \n \t     via cgraph_resolve_speculation and not here.  */\n-\t  && !e->speculative)\n+\t  && !speculative)\n \t{\n-\t  struct cgraph_node *callee = cgraph_node::get (decl);\n+\t  cgraph_node *callee = cgraph_node::get (decl);\n \t  gcc_checking_assert (callee);\n-\t  new_edge = n->create_edge (callee, call_stmt, count, freq);\n+\t  new_edge = n->create_edge (callee, call_stmt, gcov_count, freq);\n \t}\n       else\n \t{\n \t  new_edge = n->create_indirect_edge (call_stmt,\n-\t\t\t\t\t      e->indirect_info->ecf_flags,\n+\t\t\t\t\t      indirect_info->ecf_flags,\n \t\t\t\t\t      count, freq, false);\n-\t  *new_edge->indirect_info = *e->indirect_info;\n+\t  *new_edge->indirect_info = *indirect_info;\n \t}\n     }\n   else\n     {\n-      new_edge = n->create_edge (e->callee, call_stmt, count, freq);\n-      if (e->indirect_info)\n+      new_edge = n->create_edge (callee, call_stmt, gcov_count, freq);\n+      if (indirect_info)\n \t{\n \t  new_edge->indirect_info\n \t    = ggc_cleared_alloc<cgraph_indirect_call_info> ();\n-\t  *new_edge->indirect_info = *e->indirect_info;\n+\t  *new_edge->indirect_info = *indirect_info;\n \t}\n     }\n \n-  new_edge->inline_failed = e->inline_failed;\n-  new_edge->indirect_inlining_edge = e->indirect_inlining_edge;\n+  new_edge->inline_failed = inline_failed;\n+  new_edge->indirect_inlining_edge = indirect_inlining_edge;\n   new_edge->lto_stmt_uid = stmt_uid;\n   /* Clone flags that depend on call_stmt availability manually.  */\n-  new_edge->can_throw_external = e->can_throw_external;\n-  new_edge->call_stmt_cannot_inline_p = e->call_stmt_cannot_inline_p;\n-  new_edge->speculative = e->speculative;\n+  new_edge->can_throw_external = can_throw_external;\n+  new_edge->call_stmt_cannot_inline_p = call_stmt_cannot_inline_p;\n+  new_edge->speculative = speculative;\n   if (update_original)\n     {\n-      e->count -= new_edge->count;\n-      if (e->count < 0)\n-\te->count = 0;\n+      count -= new_edge->count;\n+      if (count < 0)\n+\tcount = 0;\n     }\n-  cgraph_call_edge_duplication_hooks (e, new_edge);\n+  symtab->call_edge_duplication_hooks (this, new_edge);\n   return new_edge;\n }\n \n@@ -309,7 +310,7 @@ duplicate_thunk_for_node (cgraph_node *thunk, cgraph_node *node)\n   if (thunk_of->thunk.thunk_p)\n     node = duplicate_thunk_for_node (thunk_of, node);\n \n-  struct cgraph_edge *cs;\n+  cgraph_edge *cs;\n   for (cs = node->callers; cs; cs = cs->next_caller)\n     if (cs->caller->thunk.thunk_p\n \t&& cs->caller->thunk.this_adjusting == thunk->thunk.this_adjusting\n@@ -350,13 +351,14 @@ duplicate_thunk_for_node (cgraph_node *thunk, cgraph_node *node)\n   new_thunk->clone.args_to_skip = node->clone.args_to_skip;\n   new_thunk->clone.combined_args_to_skip = node->clone.combined_args_to_skip;\n \n-  struct cgraph_edge *e = new_thunk->create_edge (node, NULL, 0,\n+  cgraph_edge *e = new_thunk->create_edge (node, NULL, 0,\n \t\t\t\t\t\t  CGRAPH_FREQ_BASE);\n   e->call_stmt_cannot_inline_p = true;\n-  cgraph_call_edge_duplication_hooks (thunk->callees, e);\n+  symtab->call_edge_duplication_hooks (thunk->callees, e);\n   if (!new_thunk->expand_thunk (false, false))\n     new_thunk->analyzed = true;\n-  thunk->call_duplication_hooks (new_thunk);\n+\n+  symtab->call_cgraph_duplication_hooks (thunk, new_thunk);\n   return new_thunk;\n }\n \n@@ -365,13 +367,13 @@ duplicate_thunk_for_node (cgraph_node *thunk, cgraph_node *node)\n    chain.  */\n \n void\n-redirect_edge_duplicating_thunks (struct cgraph_edge *e, struct cgraph_node *n)\n+redirect_edge_duplicating_thunks (cgraph_edge *e, cgraph_node *n)\n {\n   cgraph_node *orig_to = e->callee->ultimate_alias_target ();\n   if (orig_to->thunk.thunk_p)\n     n = duplicate_thunk_for_node (orig_to, n);\n \n-  cgraph_redirect_edge_callee (e, n);\n+  e->redirect_callee (n);\n }\n \n /* Create node representing clone of N executed COUNT times.  Decrease\n@@ -395,11 +397,11 @@ cgraph_node::create_clone (tree decl, gcov_type gcov_count, int freq,\n \t\t\t   bool update_original,\n \t\t\t   vec<cgraph_edge *> redirect_callers,\n \t\t\t   bool call_duplication_hook,\n-\t\t\t   struct cgraph_node *new_inlined_to,\n+\t\t\t   cgraph_node *new_inlined_to,\n \t\t\t   bitmap args_to_skip)\n {\n-  struct cgraph_node *new_node = cgraph_node::create_empty ();\n-  struct cgraph_edge *e;\n+  cgraph_node *new_node = symtab->create_empty ();\n+  cgraph_edge *e;\n   gcov_type count_scale;\n   unsigned i;\n \n@@ -466,12 +468,12 @@ cgraph_node::create_clone (tree decl, gcov_type gcov_count, int freq,\n     }\n \n   for (e = callees;e; e=e->next_callee)\n-    cgraph_clone_edge (e, new_node, e->call_stmt, e->lto_stmt_uid,\n-\t\t       count_scale, freq, update_original);\n+    e->clone (new_node, e->call_stmt, e->lto_stmt_uid, count_scale,\n+\t      freq, update_original);\n \n   for (e = indirect_calls; e; e = e->next_callee)\n-    cgraph_clone_edge (e, new_node, e->call_stmt, e->lto_stmt_uid,\n-\t\t       count_scale, freq, update_original);\n+    e->clone (new_node, e->call_stmt, e->lto_stmt_uid,\n+\t      count_scale, freq, update_original);\n   new_node->clone_references (this);\n \n   new_node->next_sibling_clone = clones;\n@@ -481,7 +483,7 @@ cgraph_node::create_clone (tree decl, gcov_type gcov_count, int freq,\n   new_node->clone_of = this;\n \n   if (call_duplication_hook)\n-    call_duplication_hooks (new_node);\n+    symtab->call_cgraph_duplication_hooks (this, new_node);\n   return new_node;\n }\n \n@@ -516,16 +518,16 @@ clone_function_name (tree decl, const char *suffix)\n    TODO: after merging in ipa-sra use function call notes instead of args_to_skip\n    bitmap interface.\n    */\n-struct cgraph_node *\n+cgraph_node *\n cgraph_node::create_virtual_clone (vec<cgraph_edge *> redirect_callers,\n \t\t\t\t   vec<ipa_replace_map *, va_gc> *tree_map,\n \t\t\t\t   bitmap args_to_skip, const char * suffix)\n {\n   tree old_decl = decl;\n-  struct cgraph_node *new_node = NULL;\n+  cgraph_node *new_node = NULL;\n   tree new_decl;\n   size_t len, i;\n-  struct ipa_replace_map *map;\n+  ipa_replace_map *map;\n   char *name;\n \n   if (!in_lto_p)\n@@ -578,13 +580,13 @@ cgraph_node::create_virtual_clone (vec<cgraph_edge *> redirect_callers,\n       || in_lto_p)\n     new_node->unique_name = true;\n   FOR_EACH_VEC_SAFE_ELT (tree_map, i, map)\n-    new_node->maybe_add_reference (map->new_tree, IPA_REF_ADDR, NULL);\n+    new_node->maybe_create_reference (map->new_tree, IPA_REF_ADDR, NULL);\n \n   if (ipa_transforms_to_apply.exists ())\n     new_node->ipa_transforms_to_apply\n       = ipa_transforms_to_apply.copy ();\n \n-  call_duplication_hooks (new_node);\n+  symtab->call_cgraph_duplication_hooks (this, new_node);\n \n   return new_node;\n }\n@@ -594,7 +596,7 @@ cgraph_node::create_virtual_clone (vec<cgraph_edge *> redirect_callers,\n cgraph_node *\n cgraph_node::find_replacement (void)\n {\n-  struct cgraph_node *next_inline_clone, *replacement;\n+  cgraph_node *next_inline_clone, *replacement;\n \n   for (next_inline_clone = clones;\n        next_inline_clone\n@@ -607,8 +609,8 @@ cgraph_node::find_replacement (void)\n      other clones to be based on it.  */\n   if (next_inline_clone)\n     {\n-      struct cgraph_node *n;\n-      struct cgraph_node *new_clones;\n+      cgraph_node *n;\n+      cgraph_node *new_clones;\n \n       replacement = next_inline_clone;\n \n@@ -684,30 +686,30 @@ void\n cgraph_node::set_call_stmt_including_clones (gimple old_stmt, gimple new_stmt,\n \t\t\t\t\t     bool update_speculative)\n {\n-  struct cgraph_node *node;\n-  struct cgraph_edge *edge = get_edge (old_stmt);\n+  cgraph_node *node;\n+  cgraph_edge *edge = get_edge (old_stmt);\n \n   if (edge)\n-    cgraph_set_call_stmt (edge, new_stmt, update_speculative);\n+    edge->set_call_stmt (new_stmt, update_speculative);\n \n   node = clones;\n   if (node)\n     while (node != this)\n       {\n-\tstruct cgraph_edge *edge = node->get_edge (old_stmt);\n+\tcgraph_edge *edge = node->get_edge (old_stmt);\n \tif (edge)\n \t  {\n-\t    cgraph_set_call_stmt (edge, new_stmt, update_speculative);\n+\t    edge->set_call_stmt (new_stmt, update_speculative);\n \t    /* If UPDATE_SPECULATIVE is false, it means that we are turning\n \t       speculative call into a real code sequence.  Update the\n \t       callgraph edges.  */\n \t    if (edge->speculative && !update_speculative)\n \t      {\n-\t\tstruct cgraph_edge *direct, *indirect;\n-\t\tstruct ipa_ref *ref;\n+\t\tcgraph_edge *direct, *indirect;\n+\t\tipa_ref *ref;\n \n \t\tgcc_assert (!edge->indirect_unknown_callee);\n-\t\tcgraph_speculative_call_info (edge, direct, indirect, ref);\n+\t\tedge->speculative_call_info (direct, indirect, ref);\n \t\tdirect->speculative = false;\n \t\tindirect->speculative = false;\n \t\tref->speculative = false;\n@@ -735,14 +737,14 @@ cgraph_node::set_call_stmt_including_clones (gimple old_stmt, gimple new_stmt,\n    frequencies of the clones.  */\n \n void\n-cgraph_node::create_edge_including_clones (struct cgraph_node *callee,\n+cgraph_node::create_edge_including_clones (cgraph_node *callee,\n \t\t\t\t\t   gimple old_stmt, gimple stmt,\n \t\t\t\t\t   gcov_type count,\n \t\t\t\t\t   int freq,\n \t\t\t\t\t   cgraph_inline_failed_t reason)\n {\n-  struct cgraph_node *node;\n-  struct cgraph_edge *edge;\n+  cgraph_node *node;\n+  cgraph_edge *edge;\n \n   if (!get_edge (stmt))\n     {\n@@ -754,14 +756,14 @@ cgraph_node::create_edge_including_clones (struct cgraph_node *callee,\n   if (node)\n     while (node != this)\n       {\n-\tstruct cgraph_edge *edge = node->get_edge (old_stmt);\n+\tcgraph_edge *edge = node->get_edge (old_stmt);\n \n         /* It is possible that clones already contain the edge while\n \t   master didn't.  Either we promoted indirect call into direct\n \t   call in the clone or we are processing clones of unreachable\n \t   master where edges has been removed.  */\n \tif (edge)\n-\t  cgraph_set_call_stmt (edge, stmt);\n+\t  edge->set_call_stmt (stmt);\n \telse if (! node->get_edge (stmt))\n \t  {\n \t    edge = node->create_edge (callee, stmt, count, freq);\n@@ -790,12 +792,12 @@ cgraph_node::create_edge_including_clones (struct cgraph_node *callee,\n bool\n cgraph_node::remove_symbol_and_inline_clones (cgraph_node *forbidden_node)\n {\n-  struct cgraph_edge *e, *next;\n+  cgraph_edge *e, *next;\n   bool found = false;\n \n   if (this == forbidden_node)\n     {\n-      cgraph_remove_edge (callers);\n+      callers->remove ();\n       return true;\n     }\n   for (e = callees; e; e = next)\n@@ -813,16 +815,16 @@ cgraph_node::remove_symbol_and_inline_clones (cgraph_node *forbidden_node)\n    respective tree code should be updated to call the NEW_VERSION.  */\n \n static void\n-update_call_expr (struct cgraph_node *new_version)\n+update_call_expr (cgraph_node *new_version)\n {\n-  struct cgraph_edge *e;\n+  cgraph_edge *e;\n \n   gcc_assert (new_version);\n \n   /* Update the call expr on the edges to call the new version.  */\n   for (e = new_version->callers; e; e = e->next_caller)\n     {\n-      struct function *inner_function = DECL_STRUCT_FUNCTION (e->caller->decl);\n+      function *inner_function = DECL_STRUCT_FUNCTION (e->caller->decl);\n       gimple_call_set_fndecl (e->call_stmt, new_version->decl);\n       maybe_clean_eh_stmt_fn (inner_function, e->call_stmt);\n     }\n@@ -845,8 +847,8 @@ cgraph_node::create_version_clone (tree new_decl,\n \t\t\t\t  vec<cgraph_edge *> redirect_callers,\n \t\t\t\t  bitmap bbs_to_copy)\n  {\n-   struct cgraph_node *new_version;\n-   struct cgraph_edge *e;\n+   cgraph_node *new_version;\n+   cgraph_edge *e;\n    unsigned i;\n \n    new_version = cgraph_node::create (new_decl);\n@@ -863,25 +865,25 @@ cgraph_node::create_version_clone (tree new_decl,\n    for (e = callees; e; e=e->next_callee)\n      if (!bbs_to_copy\n \t || bitmap_bit_p (bbs_to_copy, gimple_bb (e->call_stmt)->index))\n-       cgraph_clone_edge (e, new_version, e->call_stmt,\n-\t\t\t  e->lto_stmt_uid, REG_BR_PROB_BASE,\n-\t\t\t  CGRAPH_FREQ_BASE,\n-\t\t\t  true);\n+       e->clone (new_version, e->call_stmt,\n+\t\t e->lto_stmt_uid, REG_BR_PROB_BASE,\n+\t\t CGRAPH_FREQ_BASE,\n+\t\t true);\n    for (e = indirect_calls; e; e=e->next_callee)\n      if (!bbs_to_copy\n \t || bitmap_bit_p (bbs_to_copy, gimple_bb (e->call_stmt)->index))\n-       cgraph_clone_edge (e, new_version, e->call_stmt,\n-\t\t\t  e->lto_stmt_uid, REG_BR_PROB_BASE,\n-\t\t\t  CGRAPH_FREQ_BASE,\n-\t\t\t  true);\n+       e->clone (new_version, e->call_stmt,\n+\t\t e->lto_stmt_uid, REG_BR_PROB_BASE,\n+\t\t CGRAPH_FREQ_BASE,\n+\t\t true);\n    FOR_EACH_VEC_ELT (redirect_callers, i, e)\n      {\n        /* Redirect calls to the old version node to point to its new\n \t  version.  */\n-       cgraph_redirect_edge_callee (e, new_version);\n+       e->redirect_callee (new_version);\n      }\n \n-   call_duplication_hooks (new_version);\n+   symtab->call_cgraph_duplication_hooks (this, new_version);\n \n    return new_version;\n  }\n@@ -913,7 +915,7 @@ cgraph_node::create_version_clone_with_body\n    const char *clone_name)\n {\n   tree old_decl = decl;\n-  struct cgraph_node *new_version_node = NULL;\n+  cgraph_node *new_version_node = NULL;\n   tree new_decl;\n \n   if (!tree_versionable_function_p (old_decl))\n@@ -970,14 +972,14 @@ cgraph_node::create_version_clone_with_body\n   /* Update the call_expr on the edges to call the new version node. */\n   update_call_expr (new_version_node);\n \n-  new_version_node->call_function_insertion_hooks ();\n+  symtab->call_cgraph_insertion_hooks (this);\n   return new_version_node;\n }\n \n /* Given virtual clone, turn it into actual clone.  */\n \n static void\n-cgraph_materialize_clone (struct cgraph_node *node)\n+cgraph_materialize_clone (cgraph_node *node)\n {\n   bitmap_obstack_initialize (NULL);\n   node->former_clone_of = node->clone_of->decl;\n@@ -988,10 +990,11 @@ cgraph_materialize_clone (struct cgraph_node *node)\n   \t\t\t    node->clone.tree_map, true,\n \t\t\t    node->clone.args_to_skip, false,\n \t\t\t    NULL, NULL);\n-  if (cgraph_dump_file)\n+  if (symtab->dump_file)\n     {\n-      dump_function_to_file (node->clone_of->decl, cgraph_dump_file, dump_flags);\n-      dump_function_to_file (node->decl, cgraph_dump_file, dump_flags);\n+      dump_function_to_file (node->clone_of->decl, symtab->dump_file,\n+\t\t\t     dump_flags);\n+      dump_function_to_file (node->decl, symtab->dump_file, dump_flags);\n     }\n \n   /* Function is no longer clone.  */\n@@ -1020,14 +1023,14 @@ cgraph_materialize_clone (struct cgraph_node *node)\n    this order.  */\n \n void\n-cgraph_materialize_all_clones (void)\n+symbol_table::materialize_all_clones (void)\n {\n-  struct cgraph_node *node;\n+  cgraph_node *node;\n   bool stabilized = false;\n   \n \n-  if (cgraph_dump_file)\n-    fprintf (cgraph_dump_file, \"Materializing clones\\n\");\n+  if (symtab->dump_file)\n+    fprintf (symtab->dump_file, \"Materializing clones\\n\");\n #ifdef ENABLE_CHECKING\n   cgraph_node::verify_cgraph_nodes ();\n #endif\n@@ -1047,39 +1050,40 @@ cgraph_materialize_all_clones (void)\n \t\tnode->clone_of->get_body ();\n \t      if (gimple_has_body_p (node->clone_of->decl))\n \t        {\n-\t\t  if (cgraph_dump_file)\n+\t\t  if (symtab->dump_file)\n \t\t    {\n-\t\t      fprintf (cgraph_dump_file, \"cloning %s to %s\\n\",\n+\t\t      fprintf (symtab->dump_file, \"cloning %s to %s\\n\",\n \t\t\t       xstrdup (node->clone_of->name ()),\n \t\t\t       xstrdup (node->name ()));\n \t\t      if (node->clone.tree_map)\n \t\t        {\n \t\t\t  unsigned int i;\n-\t\t          fprintf (cgraph_dump_file, \"   replace map: \");\n+\t\t\t  fprintf (symtab->dump_file, \"   replace map: \");\n \t\t\t  for (i = 0;\n \t\t\t       i < vec_safe_length (node->clone.tree_map);\n \t\t\t       i++)\n \t\t\t    {\n-\t\t\t      struct ipa_replace_map *replace_info;\n+\t\t\t      ipa_replace_map *replace_info;\n \t\t\t      replace_info = (*node->clone.tree_map)[i];\n-\t\t\t      print_generic_expr (cgraph_dump_file, replace_info->old_tree, 0);\n-\t\t\t      fprintf (cgraph_dump_file, \" -> \");\n-\t\t\t      print_generic_expr (cgraph_dump_file, replace_info->new_tree, 0);\n-\t\t\t      fprintf (cgraph_dump_file, \"%s%s;\",\n+\t\t\t      print_generic_expr (symtab->dump_file, replace_info->old_tree, 0);\n+\t\t\t      fprintf (symtab->dump_file, \" -> \");\n+\t\t\t      print_generic_expr (symtab->dump_file, replace_info->new_tree, 0);\n+\t\t\t      fprintf (symtab->dump_file, \"%s%s;\",\n \t\t\t      \t       replace_info->replace_p ? \"(replace)\":\"\",\n \t\t\t\t       replace_info->ref_p ? \"(ref)\":\"\");\n \t\t\t    }\n-\t\t\t  fprintf (cgraph_dump_file, \"\\n\");\n+\t\t\t  fprintf (symtab->dump_file, \"\\n\");\n \t\t\t}\n \t\t      if (node->clone.args_to_skip)\n \t\t\t{\n-\t\t          fprintf (cgraph_dump_file, \"   args_to_skip: \");\n-\t\t          dump_bitmap (cgraph_dump_file, node->clone.args_to_skip);\n+\t\t\t  fprintf (symtab->dump_file, \"   args_to_skip: \");\n+\t\t\t  dump_bitmap (symtab->dump_file,\n+\t\t\t\t       node->clone.args_to_skip);\n \t\t\t}\n \t\t      if (node->clone.args_to_skip)\n \t\t\t{\n-\t\t          fprintf (cgraph_dump_file, \"   combined_args_to_skip:\");\n-\t\t          dump_bitmap (cgraph_dump_file, node->clone.combined_args_to_skip);\n+\t\t\t  fprintf (symtab->dump_file, \"   combined_args_to_skip:\");\n+\t\t\t  dump_bitmap (symtab->dump_file, node->clone.combined_args_to_skip);\n \t\t\t}\n \t\t    }\n \t\t  cgraph_materialize_clone (node);\n@@ -1096,12 +1100,12 @@ cgraph_materialize_all_clones (void)\n       }\n     else\n       node->clear_stmts_in_references ();\n-  if (cgraph_dump_file)\n-    fprintf (cgraph_dump_file, \"Materialization Call site updates done.\\n\");\n+  if (symtab->dump_file)\n+    fprintf (symtab->dump_file, \"Materialization Call site updates done.\\n\");\n #ifdef ENABLE_CHECKING\n   cgraph_node::verify_cgraph_nodes ();\n #endif\n-  symtab_remove_unreachable_nodes (false, cgraph_dump_file);\n+  symtab->remove_unreachable_nodes (false, symtab->dump_file);\n }\n \n #include \"gt-cgraphclones.h\""}, {"sha": "3a9972917ecd879123853b8d85f893668de3db88", "filename": "gcc/cgraphunit.c", "status": "modified", "additions": 190, "deletions": 230, "changes": 420, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3dafb85c8e6ade82adc591fe97c116b193f8bb0d/gcc%2Fcgraphunit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3dafb85c8e6ade82adc591fe97c116b193f8bb0d/gcc%2Fcgraphunit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraphunit.c?ref=3dafb85c8e6ade82adc591fe97c116b193f8bb0d", "patch": "@@ -25,7 +25,7 @@ along with GCC; see the file COPYING3.  If not see\n \n    The front-end is supposed to use following functionality:\n \n-    - cgraph_finalize_function\n+    - finalize_function\n \n       This function is called once front-end has parsed whole body of function\n       and it is certain that the function body nor the declaration will change.\n@@ -219,45 +219,34 @@ vec<cgraph_node *> cgraph_new_nodes;\n \n static void expand_all_functions (void);\n static void mark_functions_to_output (void);\n-static void expand_function (struct cgraph_node *);\n static void handle_alias_pairs (void);\n \n-FILE *cgraph_dump_file;\n-\n-/* Linked list of cgraph asm nodes.  */\n-struct asm_node *asm_nodes;\n-\n-/* Last node in cgraph_asm_nodes.  */\n-static GTY(()) struct asm_node *asm_last_node;\n-\n /* Used for vtable lookup in thunk adjusting.  */\n static GTY (()) tree vtable_entry_type;\n \n-/* Determine if symbol DECL is needed.  That is, visible to something\n+/* Determine if symbol declaration is needed.  That is, visible to something\n    either outside this translation unit, something magic in the system\n    configury */\n bool\n-decide_is_symbol_needed (symtab_node *node)\n+symtab_node::needed_p (void)\n {\n-  tree decl = node->decl;\n-\n   /* Double check that no one output the function into assembly file\n      early.  */\n   gcc_checking_assert (!DECL_ASSEMBLER_NAME_SET_P (decl)\n \t               || !TREE_SYMBOL_REFERENCED (DECL_ASSEMBLER_NAME (decl)));\n \n-  if (!node->definition)\n+  if (!definition)\n     return false;\n \n   if (DECL_EXTERNAL (decl))\n     return false;\n \n   /* If the user told us it is used, then it must be so.  */\n-  if (node->force_output)\n+  if (force_output)\n     return true;\n \n   /* ABI forced symbols are needed when they are external.  */\n-  if (node->forced_by_abi && TREE_PUBLIC (decl))\n+  if (forced_by_abi && TREE_PUBLIC (decl))\n     return true;\n \n  /* Keep constructors, destructors and virtual functions.  */\n@@ -297,7 +286,7 @@ enqueue_node (symtab_node *node)\n    functions inserted into callgraph already at construction time.  */\n \n void\n-cgraph_process_new_functions (void)\n+symbol_table::process_new_functions (void)\n {\n   tree fndecl;\n \n@@ -311,19 +300,19 @@ cgraph_process_new_functions (void)\n     {\n       cgraph_node *node = cgraph_new_nodes[i];\n       fndecl = node->decl;\n-      switch (cgraph_state)\n+      switch (state)\n \t{\n-\tcase CGRAPH_STATE_CONSTRUCTION:\n+\tcase CONSTRUCTION:\n \t  /* At construction time we just need to finalize function and move\n \t     it into reachable functions list.  */\n \n-\t  cgraph_finalize_function (fndecl, false);\n-\t  node->call_function_insertion_hooks ();\n+\t  cgraph_node::finalize_function (fndecl, false);\n+\t  call_cgraph_insertion_hooks (node);\n \t  enqueue_node (node);\n \t  break;\n \n-\tcase CGRAPH_STATE_IPA:\n-\tcase CGRAPH_STATE_IPA_SSA:\n+\tcase IPA:\n+\tcase IPA_SSA:\n \t  /* When IPA optimization already started, do all essential\n \t     transformations that has been already performed on the whole\n \t     cgraph but not on this function.  */\n@@ -332,23 +321,22 @@ cgraph_process_new_functions (void)\n \t  if (!node->analyzed)\n \t    node->analyze ();\n \t  push_cfun (DECL_STRUCT_FUNCTION (fndecl));\n-\t  if (cgraph_state == CGRAPH_STATE_IPA_SSA\n+\t  if (state == IPA_SSA\n \t      && !gimple_in_ssa_p (DECL_STRUCT_FUNCTION (fndecl)))\n \t    g->get_passes ()->execute_early_local_passes ();\n \t  else if (inline_summary_vec != NULL)\n \t    compute_inline_parameters (node, true);\n \t  free_dominance_info (CDI_POST_DOMINATORS);\n \t  free_dominance_info (CDI_DOMINATORS);\n \t  pop_cfun ();\n-\t  node->call_function_insertion_hooks ();\n \t  break;\n \n-\tcase CGRAPH_STATE_EXPANSION:\n+\tcase EXPANSION:\n \t  /* Functions created during expansion shall be compiled\n \t     directly.  */\n \t  node->process = 0;\n-\t  node->call_function_insertion_hooks ();\n-\t  expand_function (node);\n+\t  call_cgraph_insertion_hooks (node);\n+\t  node->expand ();\n \t  break;\n \n \tdefault:\n@@ -394,18 +382,18 @@ cgraph_node::reset (void)\n   remove_all_references ();\n }\n \n-/* Return true when there are references to NODE.  */\n+/* Return true when there are references to the node.  */\n \n-static bool\n-referred_to_p (symtab_node *node)\n+bool\n+symtab_node::referred_to_p (void)\n {\n-  struct ipa_ref *ref = NULL;\n+  ipa_ref *ref = NULL;\n \n   /* See if there are any references at all.  */\n-  if (node->iterate_referring (0, ref))\n+  if (iterate_referring (0, ref))\n     return true;\n   /* For functions check also calls.  */\n-  cgraph_node *cn = dyn_cast <cgraph_node *> (node);\n+  cgraph_node *cn = dyn_cast <cgraph_node *> (this);\n   if (cn && cn->callers)\n     return true;\n   return false;\n@@ -417,9 +405,9 @@ referred_to_p (symtab_node *node)\n    a new GC context, or just not compile right now.  */\n \n void\n-cgraph_finalize_function (tree decl, bool no_collect)\n+cgraph_node::finalize_function (tree decl, bool no_collect)\n {\n-  struct cgraph_node *node = cgraph_node::get_create (decl);\n+  cgraph_node *node = cgraph_node::get_create (decl);\n \n   if (node->definition)\n     {\n@@ -467,14 +455,13 @@ cgraph_finalize_function (tree decl, bool no_collect)\n   if (!no_collect)\n     ggc_collect ();\n \n-  if (cgraph_state == CGRAPH_STATE_CONSTRUCTION\n-      && (decide_is_symbol_needed (node)\n-\t  || referred_to_p (node)))\n+  if (symtab->state == CONSTRUCTION\n+      && (node->needed_p () || node->referred_to_p ()))\n     enqueue_node (node);\n }\n \n /* Add the function FNDECL to the call graph.\n-   Unlike cgraph_finalize_function, this function is intended to be used\n+   Unlike finalize_function, this function is intended to be used\n    by middle end and allows insertion of new function at arbitrary point\n    of compilation.  The function can be either in high, low or SSA form\n    GIMPLE.\n@@ -489,30 +476,30 @@ void\n cgraph_node::add_new_function (tree fndecl, bool lowered)\n {\n   gcc::pass_manager *passes = g->get_passes ();\n-  struct cgraph_node *node;\n-  switch (cgraph_state)\n+  cgraph_node *node;\n+  switch (symtab->state)\n     {\n-      case CGRAPH_STATE_PARSING:\n-\tcgraph_finalize_function (fndecl, false);\n+      case PARSING:\n+\tcgraph_node::finalize_function (fndecl, false);\n \tbreak;\n-      case CGRAPH_STATE_CONSTRUCTION:\n+      case CONSTRUCTION:\n \t/* Just enqueue function to be processed at nearest occurrence.  */\n \tnode = cgraph_node::get_create (fndecl);\n \tif (lowered)\n \t  node->lowered = true;\n \tcgraph_new_nodes.safe_push (node);\n         break;\n \n-      case CGRAPH_STATE_IPA:\n-      case CGRAPH_STATE_IPA_SSA:\n-      case CGRAPH_STATE_EXPANSION:\n+      case IPA:\n+      case IPA_SSA:\n+      case EXPANSION:\n \t/* Bring the function into finalized state and enqueue for later\n \t   analyzing and compilation.  */\n \tnode = cgraph_node::get_create (fndecl);\n \tnode->local.local = false;\n \tnode->definition = true;\n \tnode->force_output = true;\n-\tif (!lowered && cgraph_state == CGRAPH_STATE_EXPANSION)\n+\tif (!lowered && symtab->state == EXPANSION)\n \t  {\n \t    push_cfun (DECL_STRUCT_FUNCTION (fndecl));\n \t    gimple_register_cfg_hooks ();\n@@ -529,7 +516,7 @@ cgraph_node::add_new_function (tree fndecl, bool lowered)\n \tcgraph_new_nodes.safe_push (node);\n         break;\n \n-      case CGRAPH_STATE_FINISHED:\n+      case FINISHED:\n \t/* At the very end of compilation we have to do all the work up\n \t   to expansion.  */\n \tnode = cgraph_node::create (fndecl);\n@@ -544,7 +531,7 @@ cgraph_node::add_new_function (tree fndecl, bool lowered)\n \t  g->get_passes ()->execute_early_local_passes ();\n \tbitmap_obstack_release (NULL);\n \tpop_cfun ();\n-\texpand_function (node);\n+\tnode->expand ();\n \tbreak;\n \n       default:\n@@ -558,38 +545,20 @@ cgraph_node::add_new_function (tree fndecl, bool lowered)\n     DECL_FUNCTION_PERSONALITY (fndecl) = lang_hooks.eh_personality ();\n }\n \n-/* Add a top-level asm statement to the list.  */\n-\n-struct asm_node *\n-add_asm_node (tree asm_str)\n-{\n-  struct asm_node *node;\n-\n-  node = ggc_cleared_alloc<asm_node> ();\n-  node->asm_str = asm_str;\n-  node->order = symtab_order++;\n-  node->next = NULL;\n-  if (asm_nodes == NULL)\n-    asm_nodes = node;\n-  else\n-    asm_last_node->next = node;\n-  asm_last_node = node;\n-  return node;\n-}\n-\n /* Output all asm statements we have stored up to be output.  */\n \n-static void\n-output_asm_statements (void)\n+void\n+symbol_table::output_asm_statements (void)\n {\n-  struct asm_node *can;\n+  asm_node *can;\n \n   if (seen_error ())\n     return;\n \n-  for (can = asm_nodes; can; can = can->next)\n+  for (can = first_asm_symbol (); can; can = can->next)\n     assemble_asm (can->asm_str);\n-  asm_nodes = NULL;\n+\n+  clear_asm_symbols ();\n }\n \n /* Analyze the function scheduled to be output.  */\n@@ -617,7 +586,7 @@ cgraph_node::analyze (void)\n   else if (dispatcher_function)\n     {\n       /* Generate the dispatcher body of multi-versioned functions.  */\n-      struct cgraph_function_version_info *dispatcher_version_info\n+      cgraph_function_version_info *dispatcher_version_info\n \t= function_version ();\n       if (dispatcher_version_info != NULL\n           && (dispatcher_version_info->dispatcher_resolver\n@@ -674,7 +643,7 @@ cgraph_node::analyze (void)\n    PCH we build the links via this function.  */\n \n void\n-cgraph_process_same_body_aliases (void)\n+symbol_table::process_same_body_aliases (void)\n {\n   symtab_node *node;\n   FOR_EACH_SYMBOL (node)\n@@ -718,7 +687,7 @@ process_common_attributes (tree decl)\n    declaration -- but the front end will subsequently merge that declaration\n    with the original declaration and discard the second declaration.\n \n-   Furthermore, we can't mark these nodes in cgraph_finalize_function because:\n+   Furthermore, we can't mark these nodes in finalize_function because:\n \n     void f() {}\n     void f() __attribute__((externally_visible));\n@@ -729,14 +698,14 @@ process_common_attributes (tree decl)\n    attributes at that point.  */\n \n static void\n-process_function_and_variable_attributes (struct cgraph_node *first,\n+process_function_and_variable_attributes (cgraph_node *first,\n                                           varpool_node *first_var)\n {\n-  struct cgraph_node *node;\n+  cgraph_node *node;\n   varpool_node *vnode;\n \n-  for (node = cgraph_first_function (); node != first;\n-       node = cgraph_next_function (node))\n+  for (node = symtab->first_function (); node != first;\n+       node = symtab->next_function (node))\n     {\n       tree decl = node->decl;\n       if (DECL_PRESERVE_P (decl))\n@@ -768,8 +737,8 @@ process_function_and_variable_attributes (struct cgraph_node *first,\n      \n       process_common_attributes (decl);\n     }\n-  for (vnode = varpool_first_variable (); vnode != first_var;\n-       vnode = varpool_next_variable (vnode))\n+  for (vnode = symtab->first_variable (); vnode != first_var;\n+       vnode = symtab->next_variable (vnode))\n     {\n       tree decl = vnode->decl;\n       if (DECL_EXTERNAL (decl)\n@@ -821,16 +790,16 @@ varpool_node::finalize_decl (tree decl)\n \t  && !DECL_ARTIFICIAL (node->decl)))\n     node->force_output = true;\n \n-  if (cgraph_state == CGRAPH_STATE_CONSTRUCTION\n-      && (decide_is_symbol_needed (node)\n-\t  || referred_to_p (node)))\n+  if (symtab->state == CONSTRUCTION\n+      && (node->needed_p () || node->referred_to_p ()))\n     enqueue_node (node);\n-  if (cgraph_state >= CGRAPH_STATE_IPA_SSA)\n+  if (symtab->state >= IPA_SSA)\n     node->analyze ();\n   /* Some frontends produce various interface variables after compilation\n      finished.  */\n-  if (cgraph_state == CGRAPH_STATE_FINISHED\n-      || (!flag_toplevel_reorder && cgraph_state == CGRAPH_STATE_EXPANSION))\n+  if (symtab->state == FINISHED\n+      || (!flag_toplevel_reorder\n+\t&& symtab->state == EXPANSION))\n     node->assemble_decl ();\n }\n \n@@ -841,7 +810,7 @@ varpool_node::finalize_decl (tree decl)\n \n static void\n walk_polymorphic_call_targets (hash_set<void *> *reachable_call_targets,\n-\t\t\t       struct cgraph_edge *edge)\n+\t\t\t       cgraph_edge *edge)\n {\n   unsigned int i;\n   void *cache_token;\n@@ -852,9 +821,9 @@ walk_polymorphic_call_targets (hash_set<void *> *reachable_call_targets,\n \n   if (!reachable_call_targets->add (cache_token))\n     {\n-      if (cgraph_dump_file)\n+      if (symtab->dump_file)\n \tdump_possible_polymorphic_call_targets \n-\t  (cgraph_dump_file, edge);\n+\t  (symtab->dump_file, edge);\n \n       for (i = 0; i < targets.length (); i++)\n \t{\n@@ -887,11 +856,11 @@ walk_polymorphic_call_targets (hash_set<void *> *reachable_call_targets,\n \t    target = cgraph_node::create\n \t\t\t(builtin_decl_implicit (BUILT_IN_UNREACHABLE));\n \n-\t  if (cgraph_dump_file)\n+\t  if (symtab->dump_file)\n \t    {\n-\t      fprintf (cgraph_dump_file,\n+\t      fprintf (symtab->dump_file,\n \t\t       \"Devirtualizing call: \");\n-\t      print_gimple_stmt (cgraph_dump_file,\n+\t      print_gimple_stmt (symtab->dump_file,\n \t\t\t\t edge->call_stmt, 0,\n \t\t\t\t TDF_SLIM);\n \t    }\n@@ -903,13 +872,13 @@ walk_polymorphic_call_targets (hash_set<void *> *reachable_call_targets,\n \t\t\t       edge->caller->name (), target->name ());\n \t    }\n \n-\t  cgraph_make_edge_direct (edge, target);\n-\t  cgraph_redirect_edge_call_stmt_to_callee (edge);\n-\t  if (cgraph_dump_file)\n+\t  edge->make_direct (target);\n+\t  edge->redirect_call_stmt_to_callee ();\n+\t  if (symtab->dump_file)\n \t    {\n-\t      fprintf (cgraph_dump_file,\n+\t      fprintf (symtab->dump_file,\n \t\t       \"Devirtualized as: \");\n-\t      print_gimple_stmt (cgraph_dump_file,\n+\t      print_gimple_stmt (symtab->dump_file,\n \t\t\t\t edge->call_stmt, 0,\n \t\t\t\t TDF_SLIM);\n \t    }\n@@ -926,26 +895,26 @@ analyze_functions (void)\n {\n   /* Keep track of already processed nodes when called multiple times for\n      intermodule optimization.  */\n-  static struct cgraph_node *first_analyzed;\n-  struct cgraph_node *first_handled = first_analyzed;\n+  static cgraph_node *first_analyzed;\n+  cgraph_node *first_handled = first_analyzed;\n   static varpool_node *first_analyzed_var;\n   varpool_node *first_handled_var = first_analyzed_var;\n   hash_set<void *> reachable_call_targets;\n \n   symtab_node *node;\n   symtab_node *next;\n   int i;\n-  struct ipa_ref *ref;\n+  ipa_ref *ref;\n   bool changed = true;\n   location_t saved_loc = input_location;\n \n   bitmap_obstack_initialize (NULL);\n-  cgraph_state = CGRAPH_STATE_CONSTRUCTION;\n+  symtab->state = CONSTRUCTION;\n   input_location = UNKNOWN_LOCATION;\n \n   /* Ugly, but the fixup can not happen at a time same body alias is created;\n      C++ FE is confused about the COMDAT groups being right.  */\n-  if (cpp_implicit_aliases_done)\n+  if (symtab->cpp_implicit_aliases_done)\n     FOR_EACH_SYMBOL (node)\n       if (node->cpp_implicit_alias)\n \t  node->fixup_same_cpp_alias_visibility (node->get_alias_target ());\n@@ -961,33 +930,33 @@ analyze_functions (void)\n \t\t\t\t\t\tfirst_analyzed_var);\n \n       /* First identify the trivially needed symbols.  */\n-      for (node = symtab_nodes;\n+      for (node = symtab->first_symbol ();\n \t   node != first_analyzed\n \t   && node != first_analyzed_var; node = node->next)\n \t{\n \t  /* Convert COMDAT group designators to IDENTIFIER_NODEs.  */\n \t  node->get_comdat_group_id ();\n-\t  if (decide_is_symbol_needed (node))\n+\t  if (node->needed_p ())\n \t    {\n \t      enqueue_node (node);\n-\t      if (!changed && cgraph_dump_file)\n-\t\tfprintf (cgraph_dump_file, \"Trivially needed symbols:\");\n+\t      if (!changed && symtab->dump_file)\n+\t\tfprintf (symtab->dump_file, \"Trivially needed symbols:\");\n \t      changed = true;\n-\t      if (cgraph_dump_file)\n-\t\tfprintf (cgraph_dump_file, \" %s\", node->asm_name ());\n-\t      if (!changed && cgraph_dump_file)\n-\t\tfprintf (cgraph_dump_file, \"\\n\");\n+\t      if (symtab->dump_file)\n+\t\tfprintf (symtab->dump_file, \" %s\", node->asm_name ());\n+\t      if (!changed && symtab->dump_file)\n+\t\tfprintf (symtab->dump_file, \"\\n\");\n \t    }\n \t  if (node == first_analyzed\n \t      || node == first_analyzed_var)\n \t    break;\n \t}\n-      cgraph_process_new_functions ();\n-      first_analyzed_var = varpool_first_variable ();\n-      first_analyzed = cgraph_first_function ();\n+      symtab->process_new_functions ();\n+      first_analyzed_var = symtab->first_variable ();\n+      first_analyzed = symtab->first_function ();\n \n-      if (changed && cgraph_dump_file)\n-\tfprintf (cgraph_dump_file, \"\\n\");\n+      if (changed && symtab->dump_file)\n+\tfprintf (symtab->dump_file, \"\\n\");\n \n       /* Lower representation, build callgraph edges and references for all trivially\n          needed symbols and all symbols referred by them.  */\n@@ -999,7 +968,7 @@ analyze_functions (void)\n \t  cgraph_node *cnode = dyn_cast <cgraph_node *> (node);\n \t  if (cnode && cnode->definition)\n \t    {\n-\t      struct cgraph_edge *edge;\n+\t      cgraph_edge *edge;\n \t      tree decl = cnode->decl;\n \n \t      /* ??? It is possible to create extern inline function\n@@ -1023,7 +992,7 @@ analyze_functions (void)\n \t\t   enqueue_node (edge->callee);\n \t      if (optimize && flag_devirtualize)\n \t\t{\n-\t\t  struct cgraph_edge *next;\n+\t\t  cgraph_edge *next;\n \n \t\t  for (edge = cnode->indirect_calls; edge; edge = next)\n \t\t    {\n@@ -1040,7 +1009,7 @@ analyze_functions (void)\n \t      will be later needed to output debug info.  */\n \t      if (DECL_ABSTRACT_ORIGIN (decl))\n \t\t{\n-\t\t  struct cgraph_node *origin_node\n+\t\t  cgraph_node *origin_node\n \t\t    = cgraph_node::get_create (DECL_ABSTRACT_ORIGIN (decl));\n \t\t  origin_node->used_as_abstract_origin = true;\n \t\t}\n@@ -1063,31 +1032,31 @@ analyze_functions (void)\n \t  for (i = 0; node->iterate_reference (i, ref); i++)\n \t    if (ref->referred->definition)\n \t      enqueue_node (ref->referred);\n-          cgraph_process_new_functions ();\n+\t  symtab->process_new_functions ();\n \t}\n     }\n   if (optimize && flag_devirtualize)\n     update_type_inheritance_graph ();\n \n   /* Collect entry points to the unit.  */\n-  if (cgraph_dump_file)\n+  if (symtab->dump_file)\n     {\n-      fprintf (cgraph_dump_file, \"\\n\\nInitial \");\n-      symtab_node::dump_table (cgraph_dump_file);\n+      fprintf (symtab->dump_file, \"\\n\\nInitial \");\n+      symtab_node::dump_table (symtab->dump_file);\n     }\n \n-  if (cgraph_dump_file)\n-    fprintf (cgraph_dump_file, \"\\nRemoving unused symbols:\");\n+  if (symtab->dump_file)\n+    fprintf (symtab->dump_file, \"\\nRemoving unused symbols:\");\n \n-  for (node = symtab_nodes;\n+  for (node = symtab->first_symbol ();\n        node != first_handled\n        && node != first_handled_var; node = next)\n     {\n       next = node->next;\n-      if (!node->aux && !referred_to_p (node))\n+      if (!node->aux && !node->referred_to_p ())\n \t{\n-\t  if (cgraph_dump_file)\n-\t    fprintf (cgraph_dump_file, \" %s\", node->name ());\n+\t  if (symtab->dump_file)\n+\t    fprintf (symtab->dump_file, \" %s\", node->name ());\n \t  node->remove ();\n \t  continue;\n \t}\n@@ -1109,20 +1078,20 @@ analyze_functions (void)\n     }\n   for (;node; node = node->next)\n     node->aux = NULL;\n-  first_analyzed = cgraph_first_function ();\n-  first_analyzed_var = varpool_first_variable ();\n-  if (cgraph_dump_file)\n+  first_analyzed = symtab->first_function ();\n+  first_analyzed_var = symtab->first_variable ();\n+  if (symtab->dump_file)\n     {\n-      fprintf (cgraph_dump_file, \"\\n\\nReclaimed \");\n-      symtab_node::dump_table (cgraph_dump_file);\n+      fprintf (symtab->dump_file, \"\\n\\nReclaimed \");\n+      symtab_node::dump_table (symtab->dump_file);\n     }\n   bitmap_obstack_release (NULL);\n   ggc_collect ();\n   /* Initialize assembler name hash, in particular we want to trigger C++\n      mangling and same body alias creation before we free DECL_ARGUMENTS\n      used by it.  */\n   if (!seen_error ())\n-    symtab_initialize_asm_name_hash ();\n+    symtab->symtab_initialize_asm_name_hash ();\n \n   input_location = saved_loc;\n }\n@@ -1139,7 +1108,7 @@ handle_alias_pairs (void)\n   \n   for (i = 0; alias_pairs && alias_pairs->iterate (i, &p);)\n     {\n-      symtab_node *target_node = symtab_node_for_asm (p->target);\n+      symtab_node *target_node = symtab_node::get_for_asmname (p->target);\n \n       /* Weakrefs with target not defined in current unit are easy to handle:\n \t they behave just as external variables except we need to note the\n@@ -1182,7 +1151,7 @@ handle_alias_pairs (void)\n       if (TREE_CODE (p->decl) == FUNCTION_DECL\n           && target_node && is_a <cgraph_node *> (target_node))\n \t{\n-\t  struct cgraph_node *src_node = cgraph_node::get (p->decl);\n+\t  cgraph_node *src_node = cgraph_node::get (p->decl);\n \t  if (src_node && src_node->definition)\n \t    src_node->reset ();\n \t  cgraph_node::create_alias (p->decl, target_node->decl);\n@@ -1212,7 +1181,7 @@ handle_alias_pairs (void)\n static void\n mark_functions_to_output (void)\n {\n-  struct cgraph_node *node;\n+  cgraph_node *node;\n #ifdef ENABLE_CHECKING\n   bool check_same_comdat_groups = false;\n \n@@ -1241,7 +1210,7 @@ mark_functions_to_output (void)\n \t  node->process = 1;\n \t  if (node->same_comdat_group)\n \t    {\n-\t      struct cgraph_node *next;\n+\t      cgraph_node *next;\n \t      for (next = dyn_cast<cgraph_node *> (node->same_comdat_group);\n \t\t   next != node;\n \t\t   next = dyn_cast<cgraph_node *> (next->same_comdat_group))\n@@ -1696,62 +1665,61 @@ cgraph_node::expand_thunk (bool output_asm_thunks, bool force_gimple_thunk)\n   return true;\n }\n \n-/* Assemble thunks and aliases associated to NODE.  */\n+/* Assemble thunks and aliases associated to node.  */\n \n-static void\n-assemble_thunks_and_aliases (struct cgraph_node *node)\n+void\n+cgraph_node::assemble_thunks_and_aliases (void)\n {\n-  struct cgraph_edge *e;\n-  struct ipa_ref *ref;\n+  cgraph_edge *e;\n+  ipa_ref *ref;\n \n-  for (e = node->callers; e;)\n+  for (e = callers; e;)\n     if (e->caller->thunk.thunk_p)\n       {\n-\tstruct cgraph_node *thunk = e->caller;\n+\tcgraph_node *thunk = e->caller;\n \n \te = e->next_caller;\n \tthunk->expand_thunk (true, false);\n-\tassemble_thunks_and_aliases (thunk);\n+\tthunk->assemble_thunks_and_aliases ();\n       }\n     else\n       e = e->next_caller;\n \n-  FOR_EACH_ALIAS (node, ref)\n+  FOR_EACH_ALIAS (this, ref)\n     {\n-      struct cgraph_node *alias = dyn_cast <cgraph_node *> (ref->referring);\n-      bool saved_written = TREE_ASM_WRITTEN (node->decl);\n+      cgraph_node *alias = dyn_cast <cgraph_node *> (ref->referring);\n+      bool saved_written = TREE_ASM_WRITTEN (decl);\n \n       /* Force assemble_alias to really output the alias this time instead\n \t of buffering it in same alias pairs.  */\n-      TREE_ASM_WRITTEN (node->decl) = 1;\n+      TREE_ASM_WRITTEN (decl) = 1;\n       do_assemble_alias (alias->decl,\n-\t\t\t DECL_ASSEMBLER_NAME (node->decl));\n-      assemble_thunks_and_aliases (alias);\n-      TREE_ASM_WRITTEN (node->decl) = saved_written;\n+\t\t\t DECL_ASSEMBLER_NAME (decl));\n+      alias->assemble_thunks_and_aliases ();\n+      TREE_ASM_WRITTEN (decl) = saved_written;\n     }\n }\n \n-/* Expand function specified by NODE.  */\n+/* Expand function specified by node.  */\n \n-static void\n-expand_function (struct cgraph_node *node)\n+void\n+cgraph_node::expand (void)\n {\n-  tree decl = node->decl;\n   location_t saved_loc;\n \n   /* We ought to not compile any inline clones.  */\n-  gcc_assert (!node->global.inlined_to);\n+  gcc_assert (!global.inlined_to);\n \n   announce_function (decl);\n-  node->process = 0;\n-  gcc_assert (node->lowered);\n-  node->get_body ();\n+  process = 0;\n+  gcc_assert (lowered);\n+  get_body ();\n \n   /* Generate RTL for the body of DECL.  */\n \n   timevar_push (TV_REST_OF_COMPILATION);\n \n-  gcc_assert (cgraph_global_info_ready);\n+  gcc_assert (symtab->global_info_ready);\n \n   /* Initialize the default bitmap obstack.  */\n   bitmap_obstack_initialize (NULL);\n@@ -1836,12 +1804,12 @@ expand_function (struct cgraph_node *node)\n      make one pass assemblers, like one on AIX, happy.  See PR 50689.\n      FIXME: Perhaps thunks should be move before function IFF they are not in comdat\n      groups.  */\n-  assemble_thunks_and_aliases (node);\n-  node->release_body ();\n+  assemble_thunks_and_aliases ();\n+  release_body ();\n   /* Eliminate all call edges.  This is important so the GIMPLE_CALL no longer\n      points to the dead function body.  */\n-  node->remove_callees ();\n-  node->remove_all_references ();\n+  remove_callees ();\n+  remove_all_references ();\n }\n \n /* Node comparer that is responsible for the order that corresponds\n@@ -1850,8 +1818,8 @@ expand_function (struct cgraph_node *node)\n static int\n node_cmp (const void *pa, const void *pb)\n {\n-  const struct cgraph_node *a = *(const struct cgraph_node * const *) pa;\n-  const struct cgraph_node *b = *(const struct cgraph_node * const *) pb;\n+  const cgraph_node *a = *(const cgraph_node * const *) pa;\n+  const cgraph_node *b = *(const cgraph_node * const *) pb;\n \n   /* Functions with time profile must be before these without profile.  */\n   if (!a->tp_first_run || !b->tp_first_run)\n@@ -1875,14 +1843,15 @@ node_cmp (const void *pa, const void *pb)\n static void\n expand_all_functions (void)\n {\n-  struct cgraph_node *node;\n-  struct cgraph_node **order = XCNEWVEC (struct cgraph_node *, cgraph_n_nodes);\n+  cgraph_node *node;\n+  cgraph_node **order = XCNEWVEC (cgraph_node *,\n+\t\t\t\t\t symtab->cgraph_count);\n   unsigned int expanded_func_count = 0, profiled_func_count = 0;\n   int order_pos, new_order_pos = 0;\n   int i;\n \n   order_pos = ipa_reverse_postorder (order);\n-  gcc_assert (order_pos == cgraph_n_nodes);\n+  gcc_assert (order_pos == symtab->cgraph_count);\n \n   /* Garbage collector may remove inline clones we eliminate during\n      optimization.  So we must be sure to not reference them.  */\n@@ -1891,7 +1860,7 @@ expand_all_functions (void)\n       order[new_order_pos++] = order[i];\n \n   if (flag_profile_reorder_functions)\n-    qsort (order, new_order_pos, sizeof (struct cgraph_node *), node_cmp);\n+    qsort (order, new_order_pos, sizeof (cgraph_node *), node_cmp);\n \n   for (i = new_order_pos - 1; i >= 0; i--)\n     {\n@@ -1903,23 +1872,24 @@ expand_all_functions (void)\n      if(node->tp_first_run)\n        profiled_func_count++;\n \n-    if (cgraph_dump_file)\n-      fprintf (cgraph_dump_file, \"Time profile order in expand_all_functions:%s:%d\\n\", node->asm_name (), node->tp_first_run);\n-\n+    if (symtab->dump_file)\n+\t  fprintf (symtab->dump_file,\n+\t\t   \"Time profile order in expand_all_functions:%s:%d\\n\",\n+\t\t   node->asm_name (), node->tp_first_run);\n \t  node->process = 0;\n-\t  expand_function (node);\n+\t  node->expand ();\n \t}\n     }\n \n     if (dump_file)\n       fprintf (dump_file, \"Expanded functions with time profile (%s):%u/%u\\n\",\n                main_input_filename, profiled_func_count, expanded_func_count);\n \n-  if (cgraph_dump_file && flag_profile_reorder_functions)\n-    fprintf (cgraph_dump_file, \"Expanded functions with time profile:%u/%u\\n\",\n+  if (symtab->dump_file && flag_profile_reorder_functions)\n+    fprintf (symtab->dump_file, \"Expanded functions with time profile:%u/%u\\n\",\n              profiled_func_count, expanded_func_count);\n \n-  cgraph_process_new_functions ();\n+  symtab->process_new_functions ();\n   free_gimplify_stack ();\n \n   free (order);\n@@ -1940,9 +1910,9 @@ struct cgraph_order_sort\n   enum cgraph_order_sort_kind kind;\n   union\n   {\n-    struct cgraph_node *f;\n+    cgraph_node *f;\n     varpool_node *v;\n-    struct asm_node *a;\n+    asm_node *a;\n   } u;\n };\n \n@@ -1956,14 +1926,13 @@ static void\n output_in_order (void)\n {\n   int max;\n-  struct cgraph_order_sort *nodes;\n+  cgraph_order_sort *nodes;\n   int i;\n-  struct cgraph_node *pf;\n+  cgraph_node *pf;\n   varpool_node *pv;\n-  struct asm_node *pa;\n-\n-  max = symtab_order;\n-  nodes = XCNEWVEC (struct cgraph_order_sort, max);\n+  asm_node *pa;\n+  max = symtab->order;\n+  nodes = XCNEWVEC (cgraph_order_sort, max);\n \n   FOR_EACH_DEFINED_FUNCTION (pf)\n     {\n@@ -1985,7 +1954,7 @@ output_in_order (void)\n \tnodes[i].u.v = pv;\n       }\n \n-  for (pa = asm_nodes; pa; pa = pa->next)\n+  for (pa = symtab->first_asm_symbol (); pa; pa = pa->next)\n     {\n       i = pa->order;\n       gcc_assert (nodes[i].kind == ORDER_UNDEFINED);\n@@ -2005,7 +1974,7 @@ output_in_order (void)\n \t{\n \tcase ORDER_FUNCTION:\n \t  nodes[i].u.f->process = 0;\n-\t  expand_function (nodes[i].u.f);\n+\t  nodes[i].u.f->expand ();\n \t  break;\n \n \tcase ORDER_VAR:\n@@ -2024,7 +1993,8 @@ output_in_order (void)\n \t}\n     }\n \n-  asm_nodes = NULL;\n+  symtab->clear_asm_symbols ();\n+\n   free (nodes);\n }\n \n@@ -2049,12 +2019,12 @@ ipa_passes (void)\n \n   /* This extra symtab_remove_unreachable_nodes pass tends to catch some\n      devirtualization and other changes where removal iterate.  */\n-  symtab_remove_unreachable_nodes (true, cgraph_dump_file);\n+  symtab->remove_unreachable_nodes (true, symtab->dump_file);\n \n   /* If pass_all_early_optimizations was not scheduled, the state of\n      the cgraph will not be properly updated.  Update it now.  */\n-  if (cgraph_state < CGRAPH_STATE_IPA_SSA)\n-    cgraph_state = CGRAPH_STATE_IPA_SSA;\n+  if (symtab->state < IPA_SSA)\n+    symtab->state = IPA_SSA;\n \n   if (!in_lto_p)\n     {\n@@ -2064,7 +2034,7 @@ ipa_passes (void)\n       /* Process new functions added.  */\n       set_cfun (NULL);\n       current_function_decl = NULL;\n-      cgraph_process_new_functions ();\n+      symtab->process_new_functions ();\n \n       execute_ipa_summary_passes\n \t((ipa_opt_pass_d *) passes->all_regular_ipa_passes);\n@@ -2102,8 +2072,8 @@ get_alias_symbol (tree decl)\n /* Weakrefs may be associated to external decls and thus not output\n    at expansion time.  Emit all necessary aliases.  */\n \n-static void\n-output_weakrefs (void)\n+void\n+symbol_table::output_weakrefs (void)\n {\n   symtab_node *node;\n   FOR_EACH_SYMBOL (node)\n@@ -2133,20 +2103,10 @@ output_weakrefs (void)\n       }\n }\n \n-/* Initialize callgraph dump file.  */\n-\n-void\n-init_cgraph (void)\n-{\n-  if (!cgraph_dump_file)\n-    cgraph_dump_file = dump_begin (TDI_cgraph, NULL);\n-}\n-\n-\n /* Perform simple optimizations based on callgraph.  */\n \n void\n-compile (void)\n+symbol_table::compile (void)\n {\n   if (seen_error ())\n     return;\n@@ -2163,7 +2123,7 @@ compile (void)\n     }\n   if (!quiet_flag)\n     fprintf (stderr, \"Performing interprocedural optimizations\\n\");\n-  cgraph_state = CGRAPH_STATE_IPA;\n+  state = IPA;\n \n   /* If LTO is enabled, initialize the streamer hooks needed by GIMPLE.  */\n   if (flag_lto)\n@@ -2184,12 +2144,12 @@ compile (void)\n   /* This pass remove bodies of extern inline functions we never inlined.\n      Do this later so other IPA passes see what is really going on.\n      FIXME: This should be run just after inlining by pasmanager.  */\n-  symtab_remove_unreachable_nodes (false, dump_file);\n-  cgraph_global_info_ready = true;\n-  if (cgraph_dump_file)\n+  remove_unreachable_nodes (false, dump_file);\n+  global_info_ready = true;\n+  if (dump_file)\n     {\n-      fprintf (cgraph_dump_file, \"Optimized \");\n-      symtab_node:: dump_table (cgraph_dump_file);\n+      fprintf (dump_file, \"Optimized \");\n+      symtab_node:: dump_table (dump_file);\n     }\n   if (post_ipa_mem_report)\n     {\n@@ -2206,7 +2166,7 @@ compile (void)\n   symtab_node::verify_symtab_nodes ();\n #endif\n \n-  cgraph_materialize_all_clones ();\n+  materialize_all_clones ();\n   bitmap_obstack_initialize (NULL);\n   execute_ipa_pass_list (g->get_passes ()->all_late_ipa_passes);\n   bitmap_obstack_release (NULL);\n@@ -2238,7 +2198,7 @@ compile (void)\n       }\n #endif\n \n-  cgraph_state = CGRAPH_STATE_EXPANSION;\n+  state = EXPANSION;\n \n   if (!flag_toplevel_reorder)\n     output_in_order ();\n@@ -2247,25 +2207,25 @@ compile (void)\n       output_asm_statements ();\n \n       expand_all_functions ();\n-      varpool_node::output_variables ();\n+      output_variables ();\n     }\n \n-  cgraph_process_new_functions ();\n-  cgraph_state = CGRAPH_STATE_FINISHED;\n+  process_new_functions ();\n+  state = FINISHED;\n   output_weakrefs ();\n \n-  if (cgraph_dump_file)\n+  if (dump_file)\n     {\n-      fprintf (cgraph_dump_file, \"\\nFinal \");\n-      symtab_node::dump_table (cgraph_dump_file);\n+      fprintf (dump_file, \"\\nFinal \");\n+      symtab_node::dump_table (dump_file);\n     }\n #ifdef ENABLE_CHECKING\n   symtab_node::verify_symtab_nodes ();\n   /* Double check that all inline clones are gone and that all\n      function bodies have been released from memory.  */\n   if (!seen_error ())\n     {\n-      struct cgraph_node *node;\n+      cgraph_node *node;\n       bool error_found = false;\n \n       FOR_EACH_DEFINED_FUNCTION (node)\n@@ -2285,7 +2245,7 @@ compile (void)\n /* Analyze the whole compilation unit once it is parsed completely.  */\n \n void\n-finalize_compilation_unit (void)\n+symbol_table::finalize_compilation_unit (void)\n {\n   timevar_push (TV_CGRAPH);\n \n@@ -2332,7 +2292,7 @@ finalize_compilation_unit (void)\n    kind of wrapper method.  */\n \n void\n-cgraph_node::create_wrapper (struct cgraph_node *target)\n+cgraph_node::create_wrapper (cgraph_node *target)\n {\n     /* Preserve DECL_RESULT so we get right by reference flag.  */\n     tree decl_result = DECL_RESULT (decl);\n@@ -2351,7 +2311,7 @@ cgraph_node::create_wrapper (struct cgraph_node *target)\n     thunk.thunk_p = true;\n     thunk.this_adjusting = false;\n \n-    struct cgraph_edge *e = create_edge (target, NULL, 0, CGRAPH_FREQ_BASE);\n+    cgraph_edge *e = create_edge (target, NULL, 0, CGRAPH_FREQ_BASE);\n \n     if (!expand_thunk (false, true))\n       analyzed = true;"}, {"sha": "1a768d5e273ee5d3893268222a41ea525bc4185a", "filename": "gcc/combine.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3dafb85c8e6ade82adc591fe97c116b193f8bb0d/gcc%2Fcombine.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3dafb85c8e6ade82adc591fe97c116b193f8bb0d/gcc%2Fcombine.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcombine.c?ref=3dafb85c8e6ade82adc591fe97c116b193f8bb0d", "patch": "@@ -1548,7 +1548,7 @@ setup_incoming_promotions (rtx_insn *first)\n          function lie within the current compilation unit.  (This does\n \t take into account the exporting of a function via taking its\n \t address, and so forth.)  */\n-      strictly_local = cgraph_local_info (current_function_decl)->local;\n+      strictly_local = cgraph_node::local_info (current_function_decl)->local;\n \n       /* The mode and signedness of the argument before any promotions happen\n          (equal to the mode of the pseudo holding it at that stage).  */"}, {"sha": "7a82a9ba72a2dba2b1090ffdebf5cd2b4898bf8b", "filename": "gcc/config/arm/arm.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3dafb85c8e6ade82adc591fe97c116b193f8bb0d/gcc%2Fconfig%2Farm%2Farm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3dafb85c8e6ade82adc591fe97c116b193f8bb0d/gcc%2Fconfig%2Farm%2Farm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.c?ref=3dafb85c8e6ade82adc591fe97c116b193f8bb0d", "patch": "@@ -5135,7 +5135,7 @@ arm_get_pcs_model (const_tree type, const_tree decl)\n \t     so we are free to use whatever conventions are\n \t     appropriate.  */\n \t  /* FIXME: remove CONST_CAST_TREE when cgraph is constified.  */\n-\t  struct cgraph_local_info *i = cgraph_local_info (CONST_CAST_TREE(decl));\n+\t  cgraph_local_info *i = cgraph_node::local_info (CONST_CAST_TREE(decl));\n \t  if (i && i->local)\n \t    return ARM_PCS_AAPCS_LOCAL;\n \t}"}, {"sha": "59456a8cc9fab324457c06582ed703e47af2e9d4", "filename": "gcc/config/bfin/bfin.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3dafb85c8e6ade82adc591fe97c116b193f8bb0d/gcc%2Fconfig%2Fbfin%2Fbfin.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3dafb85c8e6ade82adc591fe97c116b193f8bb0d/gcc%2Fconfig%2Fbfin%2Fbfin.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fbfin%2Fbfin.c?ref=3dafb85c8e6ade82adc591fe97c116b193f8bb0d", "patch": "@@ -1045,7 +1045,7 @@ bfin_load_pic_reg (rtx dest)\n   struct cgraph_local_info *i = NULL;\n   rtx addr;\n  \n-  i = cgraph_local_info (current_function_decl);\n+  i = cgraph_node::local_info (current_function_decl);\n  \n   /* Functions local to the translation unit don't need to reload the\n      pic reg, since the caller always passes a usable one.  */\n@@ -1839,8 +1839,8 @@ bfin_function_ok_for_sibcall (tree decl ATTRIBUTE_UNUSED,\n     /* Not enough information.  */\n     return false;\n  \n-  this_func = cgraph_local_info (current_function_decl);\n-  called_func = cgraph_local_info (decl);\n+  this_func = cgraph_node::local_info (current_function_decl);\n+  called_func = cgraph_node::local_info (decl);\n   if (!called_func)\n     return false;\n   return !called_func->local || this_func->local;"}, {"sha": "aaea6c0c93d937e2c61d29b9aa7bb80defc1e508", "filename": "gcc/config/c6x/c6x.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3dafb85c8e6ade82adc591fe97c116b193f8bb0d/gcc%2Fconfig%2Fc6x%2Fc6x.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3dafb85c8e6ade82adc591fe97c116b193f8bb0d/gcc%2Fconfig%2Fc6x%2Fc6x.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fc6x%2Fc6x.c?ref=3dafb85c8e6ade82adc591fe97c116b193f8bb0d", "patch": "@@ -1177,7 +1177,7 @@ c6x_function_ok_for_sibcall (tree decl, tree exp)\n \t/* Not enough information.  */\n \treturn false;\n \n-      this_func = cgraph_local_info (current_function_decl);\n+      this_func = cgraph_node::local_info (current_function_decl);\n       return this_func->local;\n     }\n \n@@ -2540,7 +2540,7 @@ must_reload_pic_reg_p (void)\n   if (!TARGET_DSBT)\n     return false;\n \n-  i = cgraph_local_info (current_function_decl);\n+  i = cgraph_node::local_info (current_function_decl);\n \n   if ((crtl->uses_pic_offset_table || !crtl->is_leaf) && !i->local)\n     return true;"}, {"sha": "cef1198bc12f8640e0529938bdb15cf91b060c58", "filename": "gcc/config/cris/cris.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3dafb85c8e6ade82adc591fe97c116b193f8bb0d/gcc%2Fconfig%2Fcris%2Fcris.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3dafb85c8e6ade82adc591fe97c116b193f8bb0d/gcc%2Fconfig%2Fcris%2Fcris.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fcris%2Fcris.c?ref=3dafb85c8e6ade82adc591fe97c116b193f8bb0d", "patch": "@@ -2578,7 +2578,7 @@ cris_legitimate_pic_operand (rtx x)\n void \n cris_asm_output_ident (const char *string)\n {\n-  if (cgraph_state != CGRAPH_STATE_PARSING)\n+  if (symtab->state != PARSING)\n     return;\n \n   default_asm_output_ident_directive (string);"}, {"sha": "12b1ea88b050400fe98644440e118db51a939ca1", "filename": "gcc/config/cris/cris.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3dafb85c8e6ade82adc591fe97c116b193f8bb0d/gcc%2Fconfig%2Fcris%2Fcris.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3dafb85c8e6ade82adc591fe97c116b193f8bb0d/gcc%2Fconfig%2Fcris%2Fcris.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fcris%2Fcris.h?ref=3dafb85c8e6ade82adc591fe97c116b193f8bb0d", "patch": "@@ -859,7 +859,7 @@ enum cris_symbol_type\n /* We don't want an .ident for gcc.  To avoid that but still support\n    #ident, we override TARGET_ASM_OUTPUT_IDENT and, since the gcc .ident\n    is its only use besides front-end .ident directives, we return if\n-   the state if the cgraph is not CGRAPH_STATE_PARSING.  */\n+   the state if the cgraph is not PARSING.  */\n #undef TARGET_ASM_OUTPUT_IDENT\n #define TARGET_ASM_OUTPUT_IDENT cris_asm_output_ident\n "}, {"sha": "9e876cfd6fd5b0b5e45f7679d8f7bbdbd0d90021", "filename": "gcc/config/darwin-c.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3dafb85c8e6ade82adc591fe97c116b193f8bb0d/gcc%2Fconfig%2Fdarwin-c.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3dafb85c8e6ade82adc591fe97c116b193f8bb0d/gcc%2Fconfig%2Fdarwin-c.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fdarwin-c.c?ref=3dafb85c8e6ade82adc591fe97c116b193f8bb0d", "patch": "@@ -731,7 +731,7 @@ darwin_objc_declare_unresolved_class_reference (const char *name)\n   gcc_checking_assert (!strncmp (name, \".objc_class_name_\", 17));\n \n   snprintf (buf, len, \"%s%s\", reference, name);\n-  add_asm_node (build_string (strlen (buf), buf));\n+  symtab->finalize_toplevel_asm (build_string (strlen (buf), buf));\n }\n \n static void\n@@ -746,10 +746,10 @@ darwin_objc_declare_class_definition (const char *name)\n \n   /* Mimic default_globalize_label.  */\n   snprintf (buf, len, \".globl\\t%s\", xname);\n-  add_asm_node (build_string (strlen (buf), buf));\n+  symtab->finalize_toplevel_asm (build_string (strlen (buf), buf));\n \n   snprintf (buf, len, \"%s = 0\", xname);\n-  add_asm_node (build_string (strlen (buf), buf));\n+  symtab->finalize_toplevel_asm (build_string (strlen (buf), buf));\n }\n \n #undef  TARGET_HANDLE_C_OPTION"}, {"sha": "796ba721f9fa8af56cae9a9cdbe2f586cf1ac9d5", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3dafb85c8e6ade82adc591fe97c116b193f8bb0d/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3dafb85c8e6ade82adc591fe97c116b193f8bb0d/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=3dafb85c8e6ade82adc591fe97c116b193f8bb0d", "patch": "@@ -5664,7 +5664,7 @@ ix86_function_regparm (const_tree type, const_tree decl)\n       && !(profile_flag && !flag_fentry))\n     {\n       /* FIXME: remove this CONST_CAST when cgraph.[ch] is constified.  */\n-      struct cgraph_local_info *i = cgraph_local_info (CONST_CAST_TREE (decl));\n+      cgraph_local_info *i = cgraph_node::local_info (CONST_CAST_TREE (decl));\n       if (i && i->local && i->can_change_signature)\n \t{\n \t  int local_regparm, globals = 0, regno;\n@@ -5741,7 +5741,7 @@ ix86_function_sseregparm (const_tree type, const_tree decl, bool warn)\n       && !(profile_flag && !flag_fentry))\n     {\n       /* FIXME: remove this CONST_CAST when cgraph.[ch] is constified.  */\n-      struct cgraph_local_info *i = cgraph_local_info (CONST_CAST_TREE(decl));\n+      cgraph_local_info *i = cgraph_node::local_info (CONST_CAST_TREE(decl));\n       if (i && i->local && i->can_change_signature)\n \treturn TARGET_SSE2 ? 2 : 1;\n     }\n@@ -6150,7 +6150,7 @@ init_cumulative_args (CUMULATIVE_ARGS *cum,  /* Argument info to initialize */\n \n   if (fndecl)\n     {\n-      i = cgraph_local_info (fndecl);\n+      i = cgraph_node::local_info (fndecl);\n       cum->call_abi = ix86_function_abi (fndecl);\n     }\n   else\n@@ -32231,7 +32231,7 @@ make_resolver_func (const tree default_decl,\n   *empty_bb = init_lowered_empty_function (decl, false);\n \n   cgraph_node::add_new_function (decl, true);\n-  cgraph_node::get_create (decl)->call_function_insertion_hooks ();\n+  symtab->call_cgraph_insertion_hooks (cgraph_node::get_create (decl));\n \n   pop_cfun ();\n \n@@ -32304,7 +32304,7 @@ ix86_generate_version_dispatcher_body (void *node_p)\n     }\n \n   dispatch_function_versions (resolver_decl, &fn_ver_vec, &empty_bb);\n-  rebuild_cgraph_edges (); \n+  cgraph_edge::rebuild_edges ();\n   pop_cfun ();\n   return resolver_decl;\n }\n@@ -32493,7 +32493,7 @@ fold_builtin_cpu (tree fndecl, tree *args)\n \t\t\t\t\t\"__cpu_model\");\n \n \n-  varpool_add_new_variable (__cpu_model_var);\n+  varpool_node::add (__cpu_model_var);\n \n   gcc_assert ((args != NULL) && (*args != NULL));\n "}, {"sha": "ee18e2643cbd449c0c40da432ea784433974a71d", "filename": "gcc/config/microblaze/microblaze.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3dafb85c8e6ade82adc591fe97c116b193f8bb0d/gcc%2Fconfig%2Fmicroblaze%2Fmicroblaze.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3dafb85c8e6ade82adc591fe97c116b193f8bb0d/gcc%2Fconfig%2Fmicroblaze%2Fmicroblaze.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmicroblaze%2Fmicroblaze.c?ref=3dafb85c8e6ade82adc591fe97c116b193f8bb0d", "patch": "@@ -3350,7 +3350,7 @@ microblaze_asm_output_ident (const char *string)\n   int size;\n   char *buf;\n \n-  if (cgraph_state != CGRAPH_STATE_PARSING)\n+  if (symtab->state != PARSING)\n     return;\n \n   size = strlen (string) + 1;\n@@ -3360,7 +3360,7 @@ microblaze_asm_output_ident (const char *string)\n     section_asm_op = READONLY_DATA_SECTION_ASM_OP;\n \n   buf = ACONCAT ((section_asm_op, \"\\n\\t.ascii \\\"\", string, \"\\\\0\\\"\\n\", NULL));\n-  add_asm_node (build_string (strlen (buf), buf));\n+  symtab->finalize_toplevel_asm (build_string (strlen (buf), buf));\n }\n \n static void"}, {"sha": "d936cb0f200be986137a588a6e984d256950fd53", "filename": "gcc/coverage.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3dafb85c8e6ade82adc591fe97c116b193f8bb0d/gcc%2Fcoverage.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3dafb85c8e6ade82adc591fe97c116b193f8bb0d/gcc%2Fcoverage.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcoverage.c?ref=3dafb85c8e6ade82adc591fe97c116b193f8bb0d", "patch": "@@ -1090,8 +1090,8 @@ coverage_obj_init (void)\n   if (!prg_ctr_mask)\n     return false;\n \n-  if (cgraph_dump_file)\n-    fprintf (cgraph_dump_file, \"Using data file %s\\n\", da_file_name);\n+  if (symtab->dump_file)\n+    fprintf (symtab->dump_file, \"Using data file %s\\n\", da_file_name);\n \n   /* Prune functions.  */\n   for (fn_prev = &functions_head; (fn = *fn_prev);)"}, {"sha": "4be48479ad076f994bfbf5b85466cf72fe039d5b", "filename": "gcc/cp/decl2.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3dafb85c8e6ade82adc591fe97c116b193f8bb0d/gcc%2Fcp%2Fdecl2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3dafb85c8e6ade82adc591fe97c116b193f8bb0d/gcc%2Fcp%2Fdecl2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl2.c?ref=3dafb85c8e6ade82adc591fe97c116b193f8bb0d", "patch": "@@ -4320,7 +4320,7 @@ cp_write_global_declarations (void)\n       return;\n     }\n \n-  cgraph_process_same_body_aliases ();\n+  symtab->process_same_body_aliases ();\n \n   /* Handle -fdump-ada-spec[-slim] */\n   if (flag_dump_ada_spec || flag_dump_ada_spec_slim)\n@@ -4663,7 +4663,7 @@ cp_write_global_declarations (void)\n       vtv_build_vtable_verify_fndecl ();\n     }\n \n-  finalize_compilation_unit ();\n+  symtab->finalize_compilation_unit ();\n \n   if (flag_vtable_verify)\n     {"}, {"sha": "ad99cab38cf64969e3e50aa6e4cc9a7e67cbd5f7", "filename": "gcc/cp/parser.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3dafb85c8e6ade82adc591fe97c116b193f8bb0d/gcc%2Fcp%2Fparser.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3dafb85c8e6ade82adc591fe97c116b193f8bb0d/gcc%2Fcp%2Fparser.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparser.c?ref=3dafb85c8e6ade82adc591fe97c116b193f8bb0d", "patch": "@@ -16619,7 +16619,7 @@ cp_parser_asm_definition (cp_parser* parser)\n \t    }\n \t}\n       else\n-\tadd_asm_node (string);\n+\tsymtab->finalize_toplevel_asm (string);\n     }\n }\n "}, {"sha": "16abad0572b1af1cb132bf452abe9ff9ba8a1945", "filename": "gcc/cp/semantics.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3dafb85c8e6ade82adc591fe97c116b193f8bb0d/gcc%2Fcp%2Fsemantics.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3dafb85c8e6ade82adc591fe97c116b193f8bb0d/gcc%2Fcp%2Fsemantics.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsemantics.c?ref=3dafb85c8e6ade82adc591fe97c116b193f8bb0d", "patch": "@@ -4056,7 +4056,7 @@ expand_or_defer_fn (tree fn)\n       function_depth++;\n \n       /* Expand or defer, at the whim of the compilation unit manager.  */\n-      cgraph_finalize_function (fn, function_depth > 1);\n+      cgraph_node::finalize_function (fn, function_depth > 1);\n       emit_associated_thunks (fn);\n \n       function_depth--;"}, {"sha": "54c5dd383a215216c2b0bb0bb81e1c898ca03647", "filename": "gcc/cp/vtable-class-hierarchy.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3dafb85c8e6ade82adc591fe97c116b193f8bb0d/gcc%2Fcp%2Fvtable-class-hierarchy.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3dafb85c8e6ade82adc591fe97c116b193f8bb0d/gcc%2Fcp%2Fvtable-class-hierarchy.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fvtable-class-hierarchy.c?ref=3dafb85c8e6ade82adc591fe97c116b193f8bb0d", "patch": "@@ -1188,7 +1188,7 @@ vtv_generate_init_routine (void)\n       gimplify_function_tree (vtv_fndecl);\n       cgraph_node::add_new_function (vtv_fndecl, false);\n \n-      cgraph_process_new_functions ();\n+      symtab->process_new_functions ();\n \n       if (flag_vtable_verify == VTV_PREINIT_PRIORITY)\n         assemble_vtv_preinit_initializer (vtv_fndecl);"}, {"sha": "1a9e50a997bec7c7d2585b49be488b4f5400e74d", "filename": "gcc/dwarf2out.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3dafb85c8e6ade82adc591fe97c116b193f8bb0d/gcc%2Fdwarf2out.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3dafb85c8e6ade82adc591fe97c116b193f8bb0d/gcc%2Fdwarf2out.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdwarf2out.c?ref=3dafb85c8e6ade82adc591fe97c116b193f8bb0d", "patch": "@@ -15344,7 +15344,7 @@ reference_to_unused (tree * tp, int * walk_subtrees,\n   /* ???  The C++ FE emits debug information for using decls, so\n      putting gcc_unreachable here falls over.  See PR31899.  For now\n      be conservative.  */\n-  else if (!cgraph_global_info_ready\n+  else if (!symtab->global_info_ready\n \t   && (TREE_CODE (*tp) == VAR_DECL || TREE_CODE (*tp) == FUNCTION_DECL))\n     return *tp;\n   else if (TREE_CODE (*tp) == VAR_DECL)"}, {"sha": "8cef83dbc4074b64b70e66568787b6b90a5f0a3b", "filename": "gcc/final.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3dafb85c8e6ade82adc591fe97c116b193f8bb0d/gcc%2Ffinal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3dafb85c8e6ade82adc591fe97c116b193f8bb0d/gcc%2Ffinal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffinal.c?ref=3dafb85c8e6ade82adc591fe97c116b193f8bb0d", "patch": "@@ -4697,8 +4697,8 @@ rest_of_clean_state (void)\n       unsigned int pref = crtl->preferred_stack_boundary;\n       if (crtl->stack_alignment_needed > crtl->preferred_stack_boundary)\n         pref = crtl->stack_alignment_needed;\n-      cgraph_rtl_info (current_function_decl)->preferred_incoming_stack_boundary\n-        = pref;\n+      cgraph_node::rtl_info (current_function_decl)\n+\t->preferred_incoming_stack_boundary = pref;\n     }\n \n   /* Make sure volatile mem refs aren't considered valid operands for\n@@ -4820,7 +4820,7 @@ collect_fn_hard_reg_usage (void)\n   if (hard_reg_set_subset_p (call_used_reg_set, function_used_regs))\n     return;\n \n-  node = cgraph_rtl_info (current_function_decl);\n+  node = cgraph_node::rtl_info (current_function_decl);\n   gcc_assert (node != NULL);\n \n   COPY_HARD_REG_SET (node->function_used_regs, function_used_regs);\n@@ -4861,7 +4861,7 @@ get_call_cgraph_rtl_info (rtx_insn *insn)\n       || !decl_binds_to_current_def_p (fndecl))\n     return NULL;\n \n-  return cgraph_rtl_info (fndecl);\n+  return cgraph_node::rtl_info (fndecl);\n }\n \n /* Find hard registers used by function call instruction INSN, and return them"}, {"sha": "3063fea732341308c41d037fe2570f3e69147d99", "filename": "gcc/fortran/trans-decl.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3dafb85c8e6ade82adc591fe97c116b193f8bb0d/gcc%2Ffortran%2Ftrans-decl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3dafb85c8e6ade82adc591fe97c116b193f8bb0d/gcc%2Ffortran%2Ftrans-decl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-decl.c?ref=3dafb85c8e6ade82adc591fe97c116b193f8bb0d", "patch": "@@ -2565,7 +2565,7 @@ build_entry_thunks (gfc_namespace * ns, bool global)\n \n       current_function_decl = NULL_TREE;\n \n-      cgraph_finalize_function (thunk_fndecl, true);\n+      cgraph_node::finalize_function (thunk_fndecl, true);\n \n       /* We share the symbols in the formal argument list with other entry\n \t points and the master function.  Clear them so that they are\n@@ -4817,7 +4817,7 @@ generate_coarray_init (gfc_namespace * ns __attribute((unused)))\n   if (decl_function_context (fndecl))\n     (void) cgraph_node::create (fndecl);\n   else\n-    cgraph_finalize_function (fndecl, true);\n+    cgraph_node::finalize_function (fndecl, true);\n \n   pop_function_context ();\n   current_function_decl = save_fn_decl;\n@@ -5529,7 +5529,7 @@ create_main_function (tree fndecl)\n   /* Output the GENERIC tree.  */\n   dump_function (TDI_original, ftn_main);\n \n-  cgraph_finalize_function (ftn_main, true);\n+  cgraph_node::finalize_function (ftn_main, true);\n \n   if (old_context)\n     {\n@@ -5911,7 +5911,7 @@ gfc_generate_function_code (gfc_namespace * ns)\n \t(void) cgraph_node::create (fndecl);\n     }\n   else\n-    cgraph_finalize_function (fndecl, true);\n+    cgraph_node::finalize_function (fndecl, true);\n \n   gfc_trans_use_stmts (ns);\n   gfc_traverse_ns (ns, gfc_emit_parameter_debug_info);"}, {"sha": "f4fe65bd6c0aae5974cf4521d8c223afd6fac57f", "filename": "gcc/gimple-fold.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3dafb85c8e6ade82adc591fe97c116b193f8bb0d/gcc%2Fgimple-fold.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3dafb85c8e6ade82adc591fe97c116b193f8bb0d/gcc%2Fgimple-fold.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-fold.c?ref=3dafb85c8e6ade82adc591fe97c116b193f8bb0d", "patch": "@@ -98,7 +98,7 @@ can_refer_decl_in_current_unit_p (tree decl, tree from_decl)\n     {\n       /* Before we start optimizing unreachable code we can be sure all\n \t static objects are defined.  */\n-      if (cgraph_function_flags_ready)\n+      if (symtab->function_flags_ready)\n \treturn true;\n       snode = symtab_node::get (decl);\n       if (!snode || !snode->definition)\n@@ -143,7 +143,7 @@ can_refer_decl_in_current_unit_p (tree decl, tree from_decl)\n      units where they are used and when the other unit was compiled with LTO\n      it is possible that vtable was kept public while the function itself\n      was privatized. */\n-  if (!cgraph_function_flags_ready)\n+  if (!symtab->function_flags_ready)\n     return true;\n \n   snode = symtab_node::get (decl);"}, {"sha": "059706e039fd9df1cd84340e2629c0254252da61", "filename": "gcc/go/go-gcc.cc", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3dafb85c8e6ade82adc591fe97c116b193f8bb0d/gcc%2Fgo%2Fgo-gcc.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3dafb85c8e6ade82adc591fe97c116b193f8bb0d/gcc%2Fgo%2Fgo-gcc.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgo-gcc.cc?ref=3dafb85c8e6ade82adc591fe97c116b193f8bb0d", "patch": "@@ -2914,7 +2914,7 @@ Gcc_backend::write_global_definitions(\n         {\n           go_preserve_from_gc(decl);\n           gimplify_function_tree(decl);\n-          cgraph_finalize_function(decl, true);\n+          cgraph_node::finalize_function(decl, true);\n \n           defs[i] = decl;\n           ++i;\n@@ -2925,7 +2925,7 @@ Gcc_backend::write_global_definitions(\n \n   wrapup_global_declarations(defs, i);\n \n-  finalize_compilation_unit();\n+  symtab->finalize_compilation_unit();\n \n   check_global_declarations(defs, i);\n   emit_debug_global_declarations(defs, i);"}, {"sha": "44d4c9ab93b86712f03c2a751e542c6c8d6c23c6", "filename": "gcc/ipa-cp.c", "status": "modified", "additions": 16, "deletions": 15, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3dafb85c8e6ade82adc591fe97c116b193f8bb0d/gcc%2Fipa-cp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3dafb85c8e6ade82adc591fe97c116b193f8bb0d/gcc%2Fipa-cp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-cp.c?ref=3dafb85c8e6ade82adc591fe97c116b193f8bb0d", "patch": "@@ -498,7 +498,7 @@ gather_caller_stats (struct cgraph_node *node, void *data)\n \tstats->count_sum += cs->count;\n \tstats->freq_sum += cs->frequency;\n \tstats->n_calls++;\n-\tif (cgraph_maybe_hot_edge_p (cs))\n+\tif (cs->maybe_hot_p ())\n \t  stats->n_hot_calls ++;\n       }\n   return false;\n@@ -585,8 +585,9 @@ struct topo_info\n static void\n build_toporder_info (struct topo_info *topo)\n {\n-  topo->order = XCNEWVEC (struct cgraph_node *, cgraph_n_nodes);\n-  topo->stack = XCNEWVEC (struct cgraph_node *, cgraph_n_nodes);\n+  topo->order = XCNEWVEC (struct cgraph_node *, symtab->cgraph_count);\n+  topo->stack = XCNEWVEC (struct cgraph_node *, symtab->cgraph_count);\n+\n   topo->stack_top = 0;\n   topo->nnodes = ipa_reduced_postorder (topo->order, true, true, NULL);\n }\n@@ -2284,7 +2285,7 @@ propagate_effects (void)\n       for (val = base; val; val = val->scc_next)\n \tfor (src = val->sources; src; src = src->next)\n \t  if (src->val\n-\t      && cgraph_maybe_hot_edge_p (src->cs))\n+\t      && src->cs->maybe_hot_p ())\n \t    {\n \t      src->val->prop_time_benefit = safe_add (time,\n \t\t\t\t\t\tsrc->val->prop_time_benefit);\n@@ -2415,11 +2416,11 @@ static inline void\n grow_edge_clone_vectors (void)\n {\n   if (next_edge_clone.length ()\n-      <=  (unsigned) cgraph_edge_max_uid)\n-    next_edge_clone.safe_grow_cleared (cgraph_edge_max_uid + 1);\n+      <=  (unsigned) symtab->edges_max_uid)\n+    next_edge_clone.safe_grow_cleared (symtab->edges_max_uid + 1);\n   if (prev_edge_clone.length ()\n-      <=  (unsigned) cgraph_edge_max_uid)\n-    prev_edge_clone.safe_grow_cleared (cgraph_edge_max_uid + 1);\n+      <=  (unsigned) symtab->edges_max_uid)\n+    prev_edge_clone.safe_grow_cleared (symtab->edges_max_uid + 1);\n }\n \n /* Edge duplication hook to grow the appropriate linked list in\n@@ -2555,7 +2556,7 @@ get_info_about_necessary_edges (struct ipcp_value *val, int *freq_sum,\n \t      count++;\n \t      freq += cs->frequency;\n \t      cnt += cs->count;\n-\t      hot |= cgraph_maybe_hot_edge_p (cs);\n+\t      hot |= cs->maybe_hot_p ();\n \t    }\n \t  cs = get_next_cgraph_edge_clone (cs);\n \t}\n@@ -2805,7 +2806,7 @@ create_specialized_node (struct cgraph_node *node,\n \t\t\t\t\t args_to_skip, \"constprop\");\n   ipa_set_node_agg_value_chain (new_node, aggvals);\n   for (av = aggvals; av; av = av->next)\n-    new_node->maybe_add_reference (av->value, IPA_REF_ADDR, NULL);\n+    new_node->maybe_create_reference (av->value, IPA_REF_ADDR, NULL);\n \n   if (dump_file && (dump_flags & TDF_DETAILS))\n     {\n@@ -3366,7 +3367,7 @@ perhaps_add_new_callers (struct cgraph_node *node, struct ipcp_value *val)\n \t\t\t     xstrdup (val->spec_node->name ()),\n \t\t\t     val->spec_node->order);\n \n-\t\t  cgraph_redirect_edge_callee (cs, val->spec_node);\n+\t\t  cs->redirect_callee (val->spec_node);\n \t\t  redirected_sum += cs->count;\n \t\t}\n \t    }\n@@ -3687,9 +3688,9 @@ ipcp_driver (void)\n   ipa_check_create_edge_args ();\n   grow_edge_clone_vectors ();\n   edge_duplication_hook_holder =\n-    cgraph_add_edge_duplication_hook (&ipcp_edge_duplication_hook, NULL);\n+    symtab->add_edge_duplication_hook (&ipcp_edge_duplication_hook, NULL);\n   edge_removal_hook_holder =\n-    cgraph_add_edge_removal_hook (&ipcp_edge_removal_hook, NULL);\n+    symtab->add_edge_removal_hook (&ipcp_edge_removal_hook, NULL);\n \n   ipcp_values_pool = create_alloc_pool (\"IPA-CP values\",\n \t\t\t\t\tsizeof (struct ipcp_value), 32);\n@@ -3716,8 +3717,8 @@ ipcp_driver (void)\n   /* Free all IPCP structures.  */\n   free_toporder_info (&topo);\n   next_edge_clone.release ();\n-  cgraph_remove_edge_removal_hook (edge_removal_hook_holder);\n-  cgraph_remove_edge_duplication_hook (edge_duplication_hook_holder);\n+  symtab->remove_edge_removal_hook (edge_removal_hook_holder);\n+  symtab->remove_edge_duplication_hook (edge_duplication_hook_holder);\n   ipa_free_all_structures_after_ipa_cp ();\n   if (dump_file)\n     fprintf (dump_file, \"\\nIPA constant propagation end\\n\");"}, {"sha": "f98a18e7b8f14161a91407bf1ea2278639e36223", "filename": "gcc/ipa-devirt.c", "status": "modified", "additions": 20, "deletions": 20, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3dafb85c8e6ade82adc591fe97c116b193f8bb0d/gcc%2Fipa-devirt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3dafb85c8e6ade82adc591fe97c116b193f8bb0d/gcc%2Fipa-devirt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-devirt.c?ref=3dafb85c8e6ade82adc591fe97c116b193f8bb0d", "patch": "@@ -217,7 +217,7 @@ static bool\n type_all_ctors_visible_p (tree t)\n {\n   return !flag_ltrans\n-\t && cgraph_state >= CGRAPH_STATE_CONSTRUCTION\n+\t && symtab->state >= CONSTRUCTION\n \t /* We can not always use type_all_derivations_known_p.\n \t    For function local types we must assume case where\n \t    the function is COMDAT and shared in between units. \n@@ -1085,14 +1085,14 @@ add_type_duplicate (odr_type val, tree type)\n \t  merge = false;\n \t  odr_violation_reported = true;\n \t  val->odr_violated = true;\n-\t  if (cgraph_dump_file)\n+\t  if (symtab->dump_file)\n \t    {\n-\t      fprintf (cgraph_dump_file, \"ODR violation\\n\");\n+\t      fprintf (symtab->dump_file, \"ODR violation\\n\");\n \t    \n-\t      print_node (cgraph_dump_file, \"\", val->type, 0);\n-\t      putc ('\\n',cgraph_dump_file);\n-\t      print_node (cgraph_dump_file, \"\", type, 0);\n-\t      putc ('\\n',cgraph_dump_file);\n+\t      print_node (symtab->dump_file, \"\", val->type, 0);\n+\t      putc ('\\n',symtab->dump_file);\n+\t      print_node (symtab->dump_file, \"\", type, 0);\n+\t      putc ('\\n',symtab->dump_file);\n \t    }\n \t}\n \n@@ -1125,14 +1125,14 @@ add_type_duplicate (odr_type val, tree type)\n \t\t\t  \"a type with the same name but different bases is \"\n \t\t\t  \"defined in another translation unit\");\n \t      val->odr_violated = true;\n-\t      if (cgraph_dump_file)\n+\t      if (symtab->dump_file)\n \t\t{\n-\t\t  fprintf (cgraph_dump_file, \"ODR bse violation or merging bug?\\n\");\n+\t\t  fprintf (symtab->dump_file, \"ODR bse violation or merging bug?\\n\");\n \t\t\n-\t\t  print_node (cgraph_dump_file, \"\", val->type, 0);\n-\t\t  putc ('\\n',cgraph_dump_file);\n-\t\t  print_node (cgraph_dump_file, \"\", type, 0);\n-\t\t  putc ('\\n',cgraph_dump_file);\n+\t\t  print_node (symtab->dump_file, \"\", val->type, 0);\n+\t\t  putc ('\\n',symtab->dump_file);\n+\t\t  print_node (symtab->dump_file, \"\", type, 0);\n+\t\t  putc ('\\n',symtab->dump_file);\n \t\t}\n \t    }\n \t}\n@@ -1446,7 +1446,7 @@ referenced_from_vtable_p (struct cgraph_node *node)\n     return true;\n \n   /* We need references built.  */\n-  if (cgraph_state <= CGRAPH_STATE_CONSTRUCTION)\n+  if (symtab->state <= CONSTRUCTION)\n     return true;\n \n   for (i = 0; node->iterate_referring (i, ref); i++)\n@@ -3388,8 +3388,8 @@ possible_polymorphic_call_targets (tree otr_type,\n       if (!node_removal_hook_holder)\n \t{\n \t  node_removal_hook_holder =\n-\t    cgraph_add_node_removal_hook (&devirt_node_removal_hook, NULL);\n-\t  varpool_add_node_removal_hook (&devirt_variable_node_removal_hook,\n+\t    symtab->add_cgraph_removal_hook (&devirt_node_removal_hook, NULL);\n+\t  symtab->add_varpool_removal_hook (&devirt_variable_node_removal_hook,\n \t\t\t\t\t NULL);\n \t}\n     }\n@@ -3866,7 +3866,7 @@ ipa_devirt (void)\n \t    if (!flag_devirtualize_speculatively)\n \t      continue;\n \n-\t    if (!cgraph_maybe_hot_edge_p (e))\n+\t    if (!e->maybe_hot_p ())\n \t      {\n \t\tif (dump_file)\n \t\t  fprintf (dump_file, \"Call is cold\\n\\n\");\n@@ -3917,7 +3917,7 @@ ipa_devirt (void)\n \t      {\n \t\tstruct cgraph_edge *e2;\n \t\tstruct ipa_ref *ref;\n-\t\tcgraph_speculative_call_info (e, e2, e, ref);\n+\t\te->speculative_call_info (e2, e, ref);\n \t\tif (e2->callee->ultimate_alias_target ()\n \t\t    == likely_target->ultimate_alias_target ())\n \t\t  {\n@@ -3988,8 +3988,8 @@ ipa_devirt (void)\n \t\t  }\n \t\tnconverted++;\n \t\tupdate = true;\n-\t\tcgraph_turn_edge_to_speculative\n-\t\t  (e, likely_target, e->count * 8 / 10, e->frequency * 8 / 10);\n+\t\te->make_speculative\n+\t\t  (likely_target, e->count * 8 / 10, e->frequency * 8 / 10);\n \t      }\n \t  }\n       if (update)"}, {"sha": "38f56d2fcd5cd88533c00426b5624dc0e229cffe", "filename": "gcc/ipa-inline-analysis.c", "status": "modified", "additions": 26, "deletions": 27, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3dafb85c8e6ade82adc591fe97c116b193f8bb0d/gcc%2Fipa-inline-analysis.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3dafb85c8e6ade82adc591fe97c116b193f8bb0d/gcc%2Fipa-inline-analysis.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-inline-analysis.c?ref=3dafb85c8e6ade82adc591fe97c116b193f8bb0d", "patch": "@@ -758,9 +758,8 @@ edge_set_predicate (struct cgraph_edge *e, struct predicate *predicate)\n     {\n       struct cgraph_node *callee = !e->inline_failed ? e->callee : NULL;\n \n-      cgraph_redirect_edge_callee (e,\n-\t\t\t\t   cgraph_node::get_create\n-\t\t\t\t     (builtin_decl_implicit (BUILT_IN_UNREACHABLE)));\n+      e->redirect_callee (cgraph_node::get_create\n+\t\t\t    (builtin_decl_implicit (BUILT_IN_UNREACHABLE)));\n       e->inline_failed = CIF_UNREACHABLE;\n       if (callee)\n \tcallee->remove_symbol_and_inline_clones ();\n@@ -961,21 +960,21 @@ inline_summary_alloc (void)\n {\n   if (!node_removal_hook_holder)\n     node_removal_hook_holder =\n-      cgraph_add_node_removal_hook (&inline_node_removal_hook, NULL);\n+      symtab->add_cgraph_removal_hook (&inline_node_removal_hook, NULL);\n   if (!edge_removal_hook_holder)\n     edge_removal_hook_holder =\n-      cgraph_add_edge_removal_hook (&inline_edge_removal_hook, NULL);\n+      symtab->add_edge_removal_hook (&inline_edge_removal_hook, NULL);\n   if (!node_duplication_hook_holder)\n     node_duplication_hook_holder =\n-      cgraph_add_node_duplication_hook (&inline_node_duplication_hook, NULL);\n+      symtab->add_cgraph_duplication_hook (&inline_node_duplication_hook, NULL);\n   if (!edge_duplication_hook_holder)\n     edge_duplication_hook_holder =\n-      cgraph_add_edge_duplication_hook (&inline_edge_duplication_hook, NULL);\n+      symtab->add_edge_duplication_hook (&inline_edge_duplication_hook, NULL);\n \n-  if (vec_safe_length (inline_summary_vec) <= (unsigned) cgraph_max_uid)\n-    vec_safe_grow_cleared (inline_summary_vec, cgraph_max_uid + 1);\n-  if (inline_edge_summary_vec.length () <= (unsigned) cgraph_edge_max_uid)\n-    inline_edge_summary_vec.safe_grow_cleared (cgraph_edge_max_uid + 1);\n+  if (vec_safe_length (inline_summary_vec) <= (unsigned) symtab->cgraph_max_uid)\n+    vec_safe_grow_cleared (inline_summary_vec, symtab->cgraph_max_uid + 1);\n+  if (inline_edge_summary_vec.length () <= (unsigned) symtab->edges_max_uid)\n+    inline_edge_summary_vec.safe_grow_cleared (symtab->edges_max_uid + 1);\n   if (!edge_predicate_pool)\n     edge_predicate_pool = create_alloc_pool (\"edge predicates\",\n \t\t\t\t\t     sizeof (struct predicate), 10);\n@@ -1291,10 +1290,10 @@ inline_edge_removal_hook (struct cgraph_edge *edge,\n void\n initialize_growth_caches (void)\n {\n-  if (cgraph_edge_max_uid)\n-    edge_growth_cache.safe_grow_cleared (cgraph_edge_max_uid);\n-  if (cgraph_max_uid)\n-    node_growth_cache.safe_grow_cleared (cgraph_max_uid);\n+  if (symtab->edges_max_uid)\n+    edge_growth_cache.safe_grow_cleared (symtab->edges_max_uid);\n+  if (symtab->cgraph_max_uid)\n+    node_growth_cache.safe_grow_cleared (symtab->cgraph_max_uid);\n }\n \n \n@@ -3019,7 +3018,7 @@ estimate_edge_size_and_time (struct cgraph_edge *e, int *size, int *min_size,\n   if (!e->callee\n       && estimate_edge_devirt_benefit (e, &call_size, &call_time,\n \t\t\t\t       known_vals, known_binfos, known_aggs)\n-      && hints && cgraph_maybe_hot_edge_p (e))\n+      && hints && e->maybe_hot_p ())\n     *hints |= INLINE_HINT_indirect_call;\n   cur_size = call_size * INLINE_SIZE_SCALE;\n   *size += cur_size;\n@@ -3633,7 +3632,7 @@ simple_edge_hints (struct cgraph_edge *edge)\n \t\t\t    ? edge->caller->global.inlined_to : edge->caller);\n   if (inline_summary (to)->scc_no\n       && inline_summary (to)->scc_no == inline_summary (edge->callee)->scc_no\n-      && !cgraph_edge_recursive_p (edge))\n+      && !edge->recursive_p ())\n     hints |= INLINE_HINT_same_scc;\n \n   if (to->lto_file_data && edge->callee->lto_file_data\n@@ -3677,7 +3676,7 @@ do_estimate_edge_time (struct cgraph_edge *edge)\n      edges and for those we disable size limits.  Don't do that when\n      probability that caller will call the callee is low however, since it\n      may hurt optimization of the caller's hot path.  */\n-  if (edge->count && cgraph_maybe_hot_edge_p (edge)\n+  if (edge->count && edge->maybe_hot_p ()\n       && (edge->count * 2\n           > (edge->caller->global.inlined_to\n \t     ? edge->caller->global.inlined_to->count : edge->caller->count)))\n@@ -3694,7 +3693,7 @@ do_estimate_edge_time (struct cgraph_edge *edge)\n     {\n       inline_summary (edge->callee)->min_size = min_size;\n       if ((int) edge_growth_cache.length () <= edge->uid)\n-\tedge_growth_cache.safe_grow_cleared (cgraph_edge_max_uid);\n+\tedge_growth_cache.safe_grow_cleared (symtab->edges_max_uid);\n       edge_growth_cache[edge->uid].time = time + (time >= 0);\n \n       edge_growth_cache[edge->uid].size = size + (size >= 0);\n@@ -3888,7 +3887,7 @@ do_estimate_growth (struct cgraph_node *node)\n   if (node_growth_cache.exists ())\n     {\n       if ((int) node_growth_cache.length () <= node->uid)\n-\tnode_growth_cache.safe_grow_cleared (cgraph_max_uid);\n+\tnode_growth_cache.safe_grow_cleared (symtab->cgraph_max_uid);\n       node_growth_cache[node->uid] = d.growth + (d.growth >= 0);\n     }\n   return d.growth;\n@@ -4015,7 +4014,7 @@ inline_generate_summary (void)\n     return;\n \n   function_insertion_hook_holder =\n-    cgraph_add_function_insertion_hook (&add_new_function, NULL);\n+    symtab->add_cgraph_insertion_hook (&add_new_function, NULL);\n \n   ipa_register_cgraph_hooks ();\n   inline_free_summary ();\n@@ -4199,7 +4198,7 @@ inline_read_summary (void)\n \tipa_prop_read_jump_functions ();\n     }\n   function_insertion_hook_holder =\n-    cgraph_add_function_insertion_hook (&add_new_function, NULL);\n+    symtab->add_cgraph_insertion_hook (&add_new_function, NULL);\n }\n \n \n@@ -4332,19 +4331,19 @@ inline_free_summary (void)\n     if (!node->alias)\n       reset_inline_summary (node);\n   if (function_insertion_hook_holder)\n-    cgraph_remove_function_insertion_hook (function_insertion_hook_holder);\n+    symtab->remove_cgraph_insertion_hook (function_insertion_hook_holder);\n   function_insertion_hook_holder = NULL;\n   if (node_removal_hook_holder)\n-    cgraph_remove_node_removal_hook (node_removal_hook_holder);\n+    symtab->remove_cgraph_removal_hook (node_removal_hook_holder);\n   node_removal_hook_holder = NULL;\n   if (edge_removal_hook_holder)\n-    cgraph_remove_edge_removal_hook (edge_removal_hook_holder);\n+    symtab->remove_edge_removal_hook (edge_removal_hook_holder);\n   edge_removal_hook_holder = NULL;\n   if (node_duplication_hook_holder)\n-    cgraph_remove_node_duplication_hook (node_duplication_hook_holder);\n+    symtab->remove_cgraph_duplication_hook (node_duplication_hook_holder);\n   node_duplication_hook_holder = NULL;\n   if (edge_duplication_hook_holder)\n-    cgraph_remove_edge_duplication_hook (edge_duplication_hook_holder);\n+    symtab->remove_edge_duplication_hook (edge_duplication_hook_holder);\n   edge_duplication_hook_holder = NULL;\n   vec_free (inline_summary_vec);\n   inline_edge_summary_vec.release ();"}, {"sha": "4b0fcad396ff5c84c5a535514a1a50a64ff3cdf9", "filename": "gcc/ipa-inline-transform.c", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3dafb85c8e6ade82adc591fe97c116b193f8bb0d/gcc%2Fipa-inline-transform.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3dafb85c8e6ade82adc591fe97c116b193f8bb0d/gcc%2Fipa-inline-transform.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-inline-transform.c?ref=3dafb85c8e6ade82adc591fe97c116b193f8bb0d", "patch": "@@ -188,7 +188,7 @@ clone_inlined_nodes (struct cgraph_edge *e, bool duplicate,\n \t\t\t\t       update_original, vNULL, true,\n \t\t\t\t       inlining_into,\n \t\t\t\t       NULL);\n-\t  cgraph_redirect_edge_callee (e, n);\n+\t  e->redirect_callee (n);\n \t}\n     }\n   else\n@@ -204,7 +204,7 @@ clone_inlined_nodes (struct cgraph_edge *e, bool duplicate,\n         clone_inlined_nodes (e, duplicate, update_original, overall_size, freq_scale);\n       if (e->speculative && !speculation_useful_p (e, true))\n \t{\n-\t  cgraph_resolve_speculation (e, NULL);\n+\t  e->resolve_speculation (NULL);\n \t  speculation_removed = true;\n \t}\n     }\n@@ -257,7 +257,7 @@ inline_call (struct cgraph_edge *e, bool update_original,\n   if (e->callee != callee)\n     {\n       struct cgraph_node *alias = e->callee, *next_alias;\n-      cgraph_redirect_edge_callee (e, callee);\n+      e->redirect_callee (callee);\n       while (alias && alias != callee)\n \t{\n \t  if (!alias->callers\n@@ -421,7 +421,7 @@ save_inline_function_body (struct cgraph_node *node)\n static bool\n preserve_function_body_p (struct cgraph_node *node)\n {\n-  gcc_assert (cgraph_global_info_ready);\n+  gcc_assert (symtab->global_info_ready);\n   gcc_assert (!node->alias && !node->thunk.thunk_p);\n \n   /* Look if there is any clone around.  */\n@@ -451,7 +451,7 @@ inline_transform (struct cgraph_node *node)\n   for (e = node->callees; e; e = next)\n     {\n       next = e->next_callee;\n-      cgraph_redirect_edge_call_stmt_to_callee (e);\n+      e->redirect_call_stmt_to_callee ();\n     }\n   node->remove_all_references ();\n "}, {"sha": "d7a232cee8a5e72b6d59a30d99e87b39d82418eb", "filename": "gcc/ipa-inline.c", "status": "modified", "additions": 28, "deletions": 29, "changes": 57, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3dafb85c8e6ade82adc591fe97c116b193f8bb0d/gcc%2Fipa-inline.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3dafb85c8e6ade82adc591fe97c116b193f8bb0d/gcc%2Fipa-inline.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-inline.c?ref=3dafb85c8e6ade82adc591fe97c116b193f8bb0d", "patch": "@@ -463,7 +463,7 @@ want_early_inline_function_p (struct cgraph_edge *e)\n \n       if (growth <= 0)\n \t;\n-      else if (!cgraph_maybe_hot_edge_p (e)\n+      else if (!e->maybe_hot_p ()\n \t       && growth > 0)\n \t{\n \t  if (dump_file)\n@@ -578,7 +578,7 @@ want_inline_small_function_p (struct cgraph_edge *e, bool report)\n      promote non-inline function to inline and we increase\n      MAX_INLINE_INSNS_SINGLE 16fold for inline functions.  */\n   else if ((!DECL_DECLARED_INLINE_P (callee->decl)\n-\t   && (!e->count || !cgraph_maybe_hot_edge_p (e)))\n+\t   && (!e->count || !e->maybe_hot_p ()))\n \t   && inline_summary (callee)->min_size - inline_edge_summary (e)->call_stmt_size\n \t      > MAX (MAX_INLINE_INSNS_SINGLE, MAX_INLINE_INSNS_AUTO))\n     {\n@@ -651,7 +651,7 @@ want_inline_small_function_p (struct cgraph_edge *e, bool report)\n  \t    }\n \t}\n       /* If call is cold, do not inline when function body would grow. */\n-      else if (!cgraph_maybe_hot_edge_p (e)\n+      else if (!e->maybe_hot_p ()\n \t       && (growth >= MAX_INLINE_INSNS_SINGLE\n \t\t   || growth_likely_positive (callee, growth)))\n \t{\n@@ -689,7 +689,7 @@ want_inline_self_recursive_call_p (struct cgraph_edge *edge,\n   if (DECL_DECLARED_INLINE_P (edge->caller->decl))\n     max_depth = PARAM_VALUE (PARAM_MAX_INLINE_RECURSIVE_DEPTH);\n \n-  if (!cgraph_maybe_hot_edge_p (edge))\n+  if (!edge->maybe_hot_p ())\n     {\n       reason = \"recursive call is cold\";\n       want_inline = false;\n@@ -797,7 +797,7 @@ check_callers (struct cgraph_node *node, void *has_hot_call)\n      {\n        if (!can_inline_edge_p (e, true))\n          return true;\n-       if (!(*(bool *)has_hot_call) && cgraph_maybe_hot_edge_p (e))\n+       if (!(*(bool *)has_hot_call) && e->maybe_hot_p ())\n \t *(bool *)has_hot_call = true;\n      }\n   return false;\n@@ -1052,7 +1052,7 @@ edge_badness (struct cgraph_edge *edge, bool dump)\n   gcc_assert (badness >= INT_MIN);\n   gcc_assert (badness <= INT_MAX - 1);\n   /* Make recursive inlining happen always after other inlining is done.  */\n-  if (cgraph_edge_recursive_p (edge))\n+  if (edge->recursive_p ())\n     return badness + 1;\n   else\n     return badness;\n@@ -1342,13 +1342,13 @@ recursive_inlining (struct cgraph_edge *edge,\n \t the already modified body.  */\n       if (master_clone)\n \t{\n-          cgraph_redirect_edge_callee (curr, master_clone);\n-          reset_edge_growth_cache (curr);\n+\t  curr->redirect_callee (master_clone);\n+\t  reset_edge_growth_cache (curr);\n \t}\n \n       if (estimate_size_after_inlining (node, curr) > limit)\n \t{\n-\t  cgraph_redirect_edge_callee (curr, dest);\n+\t  curr->redirect_callee (dest);\n \t  reset_edge_growth_cache (curr);\n \t  break;\n \t}\n@@ -1362,7 +1362,7 @@ recursive_inlining (struct cgraph_edge *edge,\n \n       if (!want_inline_self_recursive_call_p (curr, node, false, depth))\n \t{\n-\t  cgraph_redirect_edge_callee (curr, dest);\n+\t  curr->redirect_callee (dest);\n \t  reset_edge_growth_cache (curr);\n \t  continue;\n \t}\n@@ -1387,7 +1387,7 @@ recursive_inlining (struct cgraph_edge *edge,\n \t  for (e = master_clone->callees; e; e = e->next_callee)\n \t    if (!e->inline_failed)\n \t      clone_inlined_nodes (e, true, false, NULL, CGRAPH_FREQ_BASE);\n-          cgraph_redirect_edge_callee (curr, master_clone);\n+\t  curr->redirect_callee (master_clone);\n           reset_edge_growth_cache (curr);\n \t}\n \n@@ -1413,10 +1413,10 @@ recursive_inlining (struct cgraph_edge *edge,\n   /* Remove master clone we used for inlining.  We rely that clones inlined\n      into master clone gets queued just before master clone so we don't\n      need recursion.  */\n-  for (node = cgraph_first_function (); node != master_clone;\n+  for (node = symtab->first_function (); node != master_clone;\n        node = next)\n     {\n-      next = cgraph_next_function (node);\n+      next = symtab->next_function (node);\n       if (node->global.inlined_to == master_clone)\n \tnode->remove ();\n     }\n@@ -1485,7 +1485,7 @@ speculation_useful_p (struct cgraph_edge *e, bool anticipate_inlining)\n \n   gcc_assert (e->speculative && !e->indirect_unknown_callee);\n \n-  if (!cgraph_maybe_hot_edge_p (e))\n+  if (!e->maybe_hot_p ())\n     return false;\n \n   /* See if IP optimizations found something potentially useful about the\n@@ -1496,13 +1496,13 @@ speculation_useful_p (struct cgraph_edge *e, bool anticipate_inlining)\n       int ecf_flags = flags_from_decl_or_type (target->decl);\n       if (ecf_flags & ECF_CONST)\n         {\n-          cgraph_speculative_call_info (e, direct, indirect, ref);\n+\t  e->speculative_call_info (direct, indirect, ref);\n \t  if (!(indirect->indirect_info->ecf_flags & ECF_CONST))\n \t    return true;\n         }\n       else if (ecf_flags & ECF_PURE)\n         {\n-          cgraph_speculative_call_info (e, direct, indirect, ref);\n+\t  e->speculative_call_info (direct, indirect, ref);\n \t  if (!(indirect->indirect_info->ecf_flags & ECF_PURE))\n \t    return true;\n         }\n@@ -1534,7 +1534,7 @@ resolve_noninline_speculation (fibheap_t edge_heap, struct cgraph_edge *edge)\n       bitmap updated_nodes = BITMAP_ALLOC (NULL);\n \n       spec_rem += edge->count;\n-      cgraph_resolve_speculation (edge, NULL);\n+      edge->resolve_speculation ();\n       reset_edge_caches (where);\n       inline_update_overall_summary (where);\n       update_caller_keys (edge_heap, where,\n@@ -1561,14 +1561,13 @@ inline_small_functions (void)\n   int min_size, max_size;\n   auto_vec<cgraph_edge *> new_indirect_edges;\n   int initial_size = 0;\n-  struct cgraph_node **order = XCNEWVEC (struct cgraph_node *, cgraph_n_nodes);\n+  struct cgraph_node **order = XCNEWVEC (cgraph_node *, symtab->cgraph_count);\n   struct cgraph_edge_hook_list *edge_removal_hook_holder;\n-\n   if (flag_indirect_inlining)\n     new_indirect_edges.create (8);\n \n   edge_removal_hook_holder\n-    = cgraph_add_edge_removal_hook (&heap_edge_removal_hook, edge_heap);\n+    = symtab->add_edge_removal_hook (&heap_edge_removal_hook, edge_heap);\n \n   /* Compute overall unit size and other global parameters used by badness\n      metrics.  */\n@@ -1651,7 +1650,7 @@ inline_small_functions (void)\n \t    }\n \t  if (edge->speculative && !speculation_useful_p (edge, edge->aux != NULL))\n \t    {\n-\t      cgraph_resolve_speculation (edge, NULL);\n+\t      edge->resolve_speculation ();\n \t      update = true;\n \t    }\n \t}\n@@ -1756,7 +1755,7 @@ inline_small_functions (void)\n \t recursive calls where we do effects similar to loop unrolling.\n \t When inlining such edge seems profitable, leave decision on\n \t specific inliner.  */\n-      if (cgraph_edge_recursive_p (edge))\n+      if (edge->recursive_p ())\n \t{\n \t  where = edge->caller;\n \t  if (where->global.inlined_to)\n@@ -1859,7 +1858,7 @@ inline_small_functions (void)\n \t     initial_size, overall_size,\n \t     initial_size ? overall_size * 100 / (initial_size) - 100: 0);\n   BITMAP_FREE (updated_nodes);\n-  cgraph_remove_edge_removal_hook (edge_removal_hook_holder);\n+  symtab->remove_edge_removal_hook (edge_removal_hook_holder);\n }\n \n /* Flatten NODE.  Performed both during early inlining and\n@@ -1908,7 +1907,7 @@ flatten_function (struct cgraph_node *node, bool early)\n \t  : !can_early_inline_edge_p (e))\n \tcontinue;\n \n-      if (cgraph_edge_recursive_p (e))\n+      if (e->recursive_p ())\n \t{\n \t  if (dump_file)\n \t    fprintf (dump_file, \"Not inlining: recursive call.\\n\");\n@@ -2141,7 +2140,7 @@ ipa_inline (void)\n   if (!optimize)\n     return 0;\n \n-  order = XCNEWVEC (struct cgraph_node *, cgraph_n_nodes);\n+  order = XCNEWVEC (struct cgraph_node *, symtab->cgraph_count);\n \n   if (in_lto_p && optimize)\n     ipa_update_after_lto_read ();\n@@ -2184,7 +2183,7 @@ ipa_inline (void)\n \n   /* Do first after-inlining removal.  We want to remove all \"stale\" extern inline\n      functions and virtual functions so we really know what is called once.  */\n-  symtab_remove_unreachable_nodes (false, dump_file);\n+  symtab->remove_unreachable_nodes (false, dump_file);\n   free (order);\n \n   /* Inline functions with a property that after inlining into all callers the\n@@ -2222,7 +2221,7 @@ ipa_inline (void)\n \t      next = edge->next_callee;\n \t      if (edge->speculative && !speculation_useful_p (edge, false))\n \t\t{\n-\t\t  cgraph_resolve_speculation (edge, NULL);\n+\t\t  edge->resolve_speculation ();\n \t\t  spec_rem += edge->count;\n \t\t  update = true;\n \t\t  remove_functions = true;\n@@ -2284,7 +2283,7 @@ inline_always_inline_functions (struct cgraph_node *node)\n       if (!DECL_DISREGARD_INLINE_LIMITS (callee->decl))\n \tcontinue;\n \n-      if (cgraph_edge_recursive_p (e))\n+      if (e->recursive_p ())\n \t{\n \t  if (dump_file)\n \t    fprintf (dump_file, \"  Not inlining recursive call to %s.\\n\",\n@@ -2346,7 +2345,7 @@ early_inline_small_functions (struct cgraph_node *node)\n       if (!can_early_inline_edge_p (e))\n \tcontinue;\n \n-      if (cgraph_edge_recursive_p (e))\n+      if (e->recursive_p ())\n \t{\n \t  if (dump_file)\n \t    fprintf (dump_file, \"  Not inlining: recursive call.\\n\");"}, {"sha": "ac461e24d178fc225cde97f3ef6567e2909420a6", "filename": "gcc/ipa-profile.c", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3dafb85c8e6ade82adc591fe97c116b193f8bb0d/gcc%2Fipa-profile.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3dafb85c8e6ade82adc591fe97c116b193f8bb0d/gcc%2Fipa-profile.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-profile.c?ref=3dafb85c8e6ade82adc591fe97c116b193f8bb0d", "patch": "@@ -379,13 +379,13 @@ contains_hot_call_p (struct cgraph_node *node)\n {\n   struct cgraph_edge *e;\n   for (e = node->callees; e; e = e->next_callee)\n-    if (cgraph_maybe_hot_edge_p (e))\n+    if (e->maybe_hot_p ())\n       return true;\n     else if (!e->inline_failed\n \t     && contains_hot_call_p (e->callee))\n       return true;\n   for (e = node->indirect_calls; e; e = e->next_callee)\n-    if (cgraph_maybe_hot_edge_p (e))\n+    if (e->maybe_hot_p ())\n       return true;\n   return false;\n }\n@@ -603,7 +603,7 @@ ipa_profile (void)\n \t\t\tfprintf (dump_file,\n \t\t\t\t \"Not speculating: probability is too low.\\n\");\n \t\t    }\n-\t\t  else if (!cgraph_maybe_hot_edge_p (e))\n+\t\t  else if (!e->maybe_hot_p ())\n \t\t    {\n \t\t      nuseless++;\n \t\t      if (dump_file)\n@@ -633,8 +633,8 @@ ipa_profile (void)\n \t\t\t    n2 = alias;\n \t\t\t}\n \t\t      nconverted++;\n-\t\t      cgraph_turn_edge_to_speculative\n-\t\t\t(e, n2,\n+\t\t      e->make_speculative\n+\t\t\t(n2,\n \t\t\t apply_scale (e->count,\n \t\t\t\t      e->indirect_info->common_target_probability),\n \t\t\t apply_scale (e->frequency,\n@@ -669,7 +669,7 @@ ipa_profile (void)\n \t     nuseless, nuseless * 100.0 / nindirect,\n \t     nconverted, nconverted * 100.0 / nindirect);\n \n-  order = XCNEWVEC (struct cgraph_node *, cgraph_n_nodes);\n+  order = XCNEWVEC (struct cgraph_node *, symtab->cgraph_count);\n   order_pos = ipa_reverse_postorder (order);\n   for (i = order_pos - 1; i >= 0; i--)\n     {"}, {"sha": "9632ea85b6773149d4dc2ae352878e9d5cdde86c", "filename": "gcc/ipa-prop.c", "status": "modified", "additions": 16, "deletions": 14, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3dafb85c8e6ade82adc591fe97c116b193f8bb0d/gcc%2Fipa-prop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3dafb85c8e6ade82adc591fe97c116b193f8bb0d/gcc%2Fipa-prop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-prop.c?ref=3dafb85c8e6ade82adc591fe97c116b193f8bb0d", "patch": "@@ -2897,7 +2897,7 @@ ipa_make_edge_direct_to_target (struct cgraph_edge *ie, tree target)\n \t\t       \"converting indirect call in %s to direct call to %s\\n\",\n \t\t       ie->caller->name (), callee->name ());\n     }\n-  ie = cgraph_make_edge_direct (ie, callee);\n+  ie = ie->make_direct (callee);\n   es = inline_edge_summary (ie);\n   es->call_stmt_size -= (eni_size_weights.indirect_call_cost\n \t\t\t - eni_size_weights.call_cost);\n@@ -3510,8 +3510,10 @@ void\n ipa_set_node_agg_value_chain (struct cgraph_node *node,\n \t\t\t      struct ipa_agg_replacement_value *aggvals)\n {\n-  if (vec_safe_length (ipa_node_agg_replacements) <= (unsigned) cgraph_max_uid)\n-    vec_safe_grow_cleared (ipa_node_agg_replacements, cgraph_max_uid + 1);\n+  if (vec_safe_length (ipa_node_agg_replacements)\n+      <= (unsigned) symtab->cgraph_max_uid)\n+    vec_safe_grow_cleared (ipa_node_agg_replacements,\n+\t\t\t   symtab->cgraph_max_uid + 1);\n \n   (*ipa_node_agg_replacements)[node->uid] = aggvals;\n }\n@@ -3699,34 +3701,34 @@ ipa_register_cgraph_hooks (void)\n {\n   if (!edge_removal_hook_holder)\n     edge_removal_hook_holder =\n-      cgraph_add_edge_removal_hook (&ipa_edge_removal_hook, NULL);\n+      symtab->add_edge_removal_hook (&ipa_edge_removal_hook, NULL);\n   if (!node_removal_hook_holder)\n     node_removal_hook_holder =\n-      cgraph_add_node_removal_hook (&ipa_node_removal_hook, NULL);\n+      symtab->add_cgraph_removal_hook (&ipa_node_removal_hook, NULL);\n   if (!edge_duplication_hook_holder)\n     edge_duplication_hook_holder =\n-      cgraph_add_edge_duplication_hook (&ipa_edge_duplication_hook, NULL);\n+      symtab->add_edge_duplication_hook (&ipa_edge_duplication_hook, NULL);\n   if (!node_duplication_hook_holder)\n     node_duplication_hook_holder =\n-      cgraph_add_node_duplication_hook (&ipa_node_duplication_hook, NULL);\n+      symtab->add_cgraph_duplication_hook (&ipa_node_duplication_hook, NULL);\n   function_insertion_hook_holder =\n-      cgraph_add_function_insertion_hook (&ipa_add_new_function, NULL);\n+      symtab->add_cgraph_insertion_hook (&ipa_add_new_function, NULL);\n }\n \n /* Unregister our cgraph hooks if they are not already there.  */\n \n static void\n ipa_unregister_cgraph_hooks (void)\n {\n-  cgraph_remove_edge_removal_hook (edge_removal_hook_holder);\n+  symtab->remove_edge_removal_hook (edge_removal_hook_holder);\n   edge_removal_hook_holder = NULL;\n-  cgraph_remove_node_removal_hook (node_removal_hook_holder);\n+  symtab->remove_cgraph_removal_hook (node_removal_hook_holder);\n   node_removal_hook_holder = NULL;\n-  cgraph_remove_edge_duplication_hook (edge_duplication_hook_holder);\n+  symtab->remove_edge_duplication_hook (edge_duplication_hook_holder);\n   edge_duplication_hook_holder = NULL;\n-  cgraph_remove_node_duplication_hook (node_duplication_hook_holder);\n+  symtab->remove_cgraph_duplication_hook (node_duplication_hook_holder);\n   node_duplication_hook_holder = NULL;\n-  cgraph_remove_function_insertion_hook (function_insertion_hook_holder);\n+  symtab->remove_cgraph_insertion_hook (function_insertion_hook_holder);\n   function_insertion_hook_holder = NULL;\n }\n \n@@ -4256,7 +4258,7 @@ ipa_modify_call_arguments (struct cgraph_edge *cs, gimple stmt,\n     }\n   gsi_replace (&gsi, new_stmt, true);\n   if (cs)\n-    cgraph_set_call_stmt (cs, new_stmt);\n+    cs->set_call_stmt (new_stmt);\n   do\n     {\n       current_node->record_stmt_references (gsi_stmt (gsi));"}, {"sha": "a6db8f67ede54346c293711560f680dec2212ba7", "filename": "gcc/ipa-prop.h", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3dafb85c8e6ade82adc591fe97c116b193f8bb0d/gcc%2Fipa-prop.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3dafb85c8e6ade82adc591fe97c116b193f8bb0d/gcc%2Fipa-prop.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-prop.h?ref=3dafb85c8e6ade82adc591fe97c116b193f8bb0d", "patch": "@@ -538,10 +538,10 @@ static inline void\n ipa_check_create_node_params (void)\n {\n   if (!ipa_node_params_vector.exists ())\n-    ipa_node_params_vector.create (cgraph_max_uid);\n+    ipa_node_params_vector.create (symtab->cgraph_max_uid);\n \n-  if (ipa_node_params_vector.length () <= (unsigned) cgraph_max_uid)\n-    ipa_node_params_vector.safe_grow_cleared (cgraph_max_uid + 1);\n+  if (ipa_node_params_vector.length () <= (unsigned) symtab->cgraph_max_uid)\n+    ipa_node_params_vector.safe_grow_cleared (symtab->cgraph_max_uid + 1);\n }\n \n /* This function ensures the array of edge arguments infos is big enough to\n@@ -550,8 +550,9 @@ ipa_check_create_node_params (void)\n static inline void\n ipa_check_create_edge_args (void)\n {\n-  if (vec_safe_length (ipa_edge_args_vector) <= (unsigned) cgraph_edge_max_uid)\n-    vec_safe_grow_cleared (ipa_edge_args_vector, cgraph_edge_max_uid + 1);\n+  if (vec_safe_length (ipa_edge_args_vector)\n+      <= (unsigned) symtab->edges_max_uid)\n+    vec_safe_grow_cleared (ipa_edge_args_vector, symtab->edges_max_uid + 1);\n }\n \n /* Returns true if the array of edge infos is large enough to accommodate an"}, {"sha": "459d08db3b3a72c10d9b8fddb147d1df86a7b125", "filename": "gcc/ipa-pure-const.c", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3dafb85c8e6ade82adc591fe97c116b193f8bb0d/gcc%2Fipa-pure-const.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3dafb85c8e6ade82adc591fe97c116b193f8bb0d/gcc%2Fipa-pure-const.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-pure-const.c?ref=3dafb85c8e6ade82adc591fe97c116b193f8bb0d", "patch": "@@ -890,11 +890,11 @@ register_hooks (void)\n   init_p = true;\n \n   node_removal_hook_holder =\n-      cgraph_add_node_removal_hook (&remove_node_data, NULL);\n+      symtab->add_cgraph_removal_hook (&remove_node_data, NULL);\n   node_duplication_hook_holder =\n-      cgraph_add_node_duplication_hook (&duplicate_node_data, NULL);\n+      symtab->add_cgraph_duplication_hook (&duplicate_node_data, NULL);\n   function_insertion_hook_holder =\n-      cgraph_add_function_insertion_hook (&add_new_function, NULL);\n+      symtab->add_cgraph_insertion_hook (&add_new_function, NULL);\n }\n \n \n@@ -1090,7 +1090,7 @@ propagate_pure_const (void)\n   struct cgraph_node *node;\n   struct cgraph_node *w;\n   struct cgraph_node **order =\n-    XCNEWVEC (struct cgraph_node *, cgraph_n_nodes);\n+    XCNEWVEC (struct cgraph_node *, symtab->cgraph_count);\n   int order_pos;\n   int i;\n   struct ipa_dfs_info * w_info;\n@@ -1192,7 +1192,7 @@ propagate_pure_const (void)\n \t\t\t       y_l->looping);\n \t\t    }\n \t\t  if (y_l->pure_const_state > IPA_PURE\n-\t\t      && cgraph_edge_cannot_lead_to_return (e))\n+\t\t      && e->cannot_lead_to_return_p ())\n \t\t    {\n \t\t      if (dump_file && (dump_flags & TDF_DETAILS))\n \t\t\tfprintf (dump_file,\n@@ -1213,7 +1213,7 @@ propagate_pure_const (void)\n \t      else\n \t\tstate_from_flags (&edge_state, &edge_looping,\n \t\t\t\t  flags_from_decl_or_type (y->decl),\n-\t\t\t\t  cgraph_edge_cannot_lead_to_return (e));\n+\t\t\t\t  e->cannot_lead_to_return_p ());\n \n \t      /* Merge the results with what we already know.  */\n \t      better_state (&edge_state, &edge_looping,\n@@ -1237,7 +1237,7 @@ propagate_pure_const (void)\n \t\tfprintf (dump_file, \"    Indirect call\");\n \t      state_from_flags (&edge_state, &edge_looping,\n \t\t\t        ie->indirect_info->ecf_flags,\n-\t\t\t        cgraph_edge_cannot_lead_to_return (ie));\n+\t\t\t\tie->cannot_lead_to_return_p ());\n \t      /* Merge the results with what we already know.  */\n \t      better_state (&edge_state, &edge_looping,\n \t\t\t    w_l->state_previously_known,\n@@ -1368,7 +1368,7 @@ propagate_nothrow (void)\n   struct cgraph_node *node;\n   struct cgraph_node *w;\n   struct cgraph_node **order =\n-    XCNEWVEC (struct cgraph_node *, cgraph_n_nodes);\n+    XCNEWVEC (struct cgraph_node *, symtab->cgraph_count);\n   int order_pos;\n   int i;\n   struct ipa_dfs_info * w_info;\n@@ -1473,9 +1473,9 @@ propagate (void)\n {\n   struct cgraph_node *node;\n \n-  cgraph_remove_function_insertion_hook (function_insertion_hook_holder);\n-  cgraph_remove_node_duplication_hook (node_duplication_hook_holder);\n-  cgraph_remove_node_removal_hook (node_removal_hook_holder);\n+  symtab->remove_cgraph_insertion_hook (function_insertion_hook_holder);\n+  symtab->remove_cgraph_duplication_hook (node_duplication_hook_holder);\n+  symtab->remove_cgraph_removal_hook (node_removal_hook_holder);\n \n   /* Nothrow makes more function to not lead to return and improve\n      later analysis.  */"}, {"sha": "9767eabaddf9e0f3b2a73cad8a021642f5b50229", "filename": "gcc/ipa-reference.c", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3dafb85c8e6ade82adc591fe97c116b193f8bb0d/gcc%2Fipa-reference.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3dafb85c8e6ade82adc591fe97c116b193f8bb0d/gcc%2Fipa-reference.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-reference.c?ref=3dafb85c8e6ade82adc591fe97c116b193f8bb0d", "patch": "@@ -387,7 +387,7 @@ propagate_bits (ipa_reference_global_vars_info_t x_global, struct cgraph_node *x\n \t\t seems so to local analysis.  If we cannot return from\n \t\t the function, we can safely ignore the call.  */\n \t      if ((flags & ECF_PURE)\n-\t\t  || cgraph_edge_cannot_lead_to_return (e))\n+\t\t  || e->cannot_lead_to_return_p ())\n \t\tcontinue;\n \n \t      union_static_var_sets (x_global->statics_written,\n@@ -419,9 +419,9 @@ ipa_init (void)\n   all_module_statics = BITMAP_ALLOC (&optimization_summary_obstack);\n \n   node_removal_hook_holder =\n-      cgraph_add_node_removal_hook (&remove_node_data, NULL);\n+      symtab->add_cgraph_removal_hook (&remove_node_data, NULL);\n   node_duplication_hook_holder =\n-      cgraph_add_node_duplication_hook (&duplicate_node_data, NULL);\n+      symtab->add_cgraph_duplication_hook (&duplicate_node_data, NULL);\n }\n \n \n@@ -642,7 +642,7 @@ get_read_write_all_from_node (struct cgraph_node *node,\n \tread_all = true;\n \tif (dump_file && (dump_flags & TDF_DETAILS))\n \t  fprintf (dump_file, \"   indirect call -> read all\\n\");\n-\tif (!cgraph_edge_cannot_lead_to_return (ie)\n+\tif (!ie->cannot_lead_to_return_p ()\n \t    && !(ie->indirect_info->ecf_flags & ECF_PURE))\n \t  {\n \t    if (dump_file && (dump_flags & TDF_DETAILS))\n@@ -660,7 +660,7 @@ propagate (void)\n {\n   struct cgraph_node *node;\n   struct cgraph_node **order =\n-    XCNEWVEC (struct cgraph_node *, cgraph_n_nodes);\n+    XCNEWVEC (struct cgraph_node *, symtab->cgraph_count);\n   int order_pos;\n   int i;\n \n@@ -1011,9 +1011,9 @@ ipa_reference_read_optimization_summary (void)\n   bitmap_obstack_initialize (&optimization_summary_obstack);\n \n   node_removal_hook_holder =\n-      cgraph_add_node_removal_hook (&remove_node_data, NULL);\n+      symtab->add_cgraph_removal_hook (&remove_node_data, NULL);\n   node_duplication_hook_holder =\n-      cgraph_add_node_duplication_hook (&duplicate_node_data, NULL);\n+      symtab->add_cgraph_duplication_hook (&duplicate_node_data, NULL);\n   all_module_statics = BITMAP_ALLOC (&optimization_summary_obstack);\n \n   while ((file_data = file_data_vec[j++]))"}, {"sha": "3762d6a46f7f52ea39cb9bf4f188c3c7f7cdca86", "filename": "gcc/ipa-split.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3dafb85c8e6ade82adc591fe97c116b193f8bb0d/gcc%2Fipa-split.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3dafb85c8e6ade82adc591fe97c116b193f8bb0d/gcc%2Fipa-split.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-split.c?ref=3dafb85c8e6ade82adc591fe97c116b193f8bb0d", "patch": "@@ -1229,7 +1229,7 @@ split_function (struct split_point *split_point)\n     }\n \n   /* Now create the actual clone.  */\n-  rebuild_cgraph_edges ();\n+  cgraph_edge::rebuild_edges ();\n   node = cur_node->create_version_clone_with_body\n     (vNULL, NULL, args_to_skip, !split_part_return_p, split_point->split_bbs,\n      split_point->entry_bb, \"part\");"}, {"sha": "552071ed024bc223c8efaba6e83fc1d7061dfac9", "filename": "gcc/ipa-utils.c", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3dafb85c8e6ade82adc591fe97c116b193f8bb0d/gcc%2Fipa-utils.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3dafb85c8e6ade82adc591fe97c116b193f8bb0d/gcc%2Fipa-utils.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-utils.c?ref=3dafb85c8e6ade82adc591fe97c116b193f8bb0d", "patch": "@@ -173,7 +173,7 @@ ipa_reduced_postorder (struct cgraph_node **order,\n   struct cgraph_node *node;\n   struct searchc_env env;\n   splay_tree_node result;\n-  env.stack = XCNEWVEC (struct cgraph_node *, cgraph_n_nodes);\n+  env.stack = XCNEWVEC (struct cgraph_node *, symtab->cgraph_count);\n   env.stack_size = 0;\n   env.result = order;\n   env.order_pos = 0;\n@@ -292,7 +292,7 @@ ipa_reverse_postorder (struct cgraph_node **order)\n   struct ipa_ref *ref = NULL;\n \n   struct postorder_stack *stack =\n-    XCNEWVEC (struct postorder_stack, cgraph_n_nodes);\n+    XCNEWVEC (struct postorder_stack, symtab->cgraph_count);\n \n   /* We have to deal with cycles nicely, so use a depth first traversal\n      output algorithm.  Ignore the fact that some functions won't need\n@@ -407,9 +407,9 @@ ipa_merge_profiles (struct cgraph_node *dst,\n \n   if (!dst->count)\n     return;\n-  if (cgraph_dump_file)\n+  if (symtab->dump_file)\n     {\n-      fprintf (cgraph_dump_file, \"Merging profiles of %s/%i to %s/%i\\n\",\n+      fprintf (symtab->dump_file, \"Merging profiles of %s/%i to %s/%i\\n\",\n \t       xstrdup (src->name ()), src->order,\n \t       xstrdup (dst->name ()), dst->order);\n     }\n@@ -456,16 +456,16 @@ ipa_merge_profiles (struct cgraph_node *dst,\n   if (n_basic_blocks_for_fn (srccfun)\n       != n_basic_blocks_for_fn (dstcfun))\n     {\n-      if (cgraph_dump_file)\n-\tfprintf (cgraph_dump_file,\n+      if (symtab->dump_file)\n+\tfprintf (symtab->dump_file,\n \t\t \"Giving up; number of basic block mismatch.\\n\");\n       match = false;\n     }\n   else if (last_basic_block_for_fn (srccfun)\n \t   != last_basic_block_for_fn (dstcfun))\n     {\n-      if (cgraph_dump_file)\n-\tfprintf (cgraph_dump_file,\n+      if (symtab->dump_file)\n+\tfprintf (symtab->dump_file,\n \t\t \"Giving up; last block mismatch.\\n\");\n       match = false;\n     }\n@@ -480,17 +480,17 @@ ipa_merge_profiles (struct cgraph_node *dst,\n \t  dstbb = BASIC_BLOCK_FOR_FN (dstcfun, srcbb->index);\n \t  if (dstbb == NULL)\n \t    {\n-\t      if (cgraph_dump_file)\n-\t\tfprintf (cgraph_dump_file,\n+\t      if (symtab->dump_file)\n+\t\tfprintf (symtab->dump_file,\n \t\t\t \"No matching block for bb %i.\\n\",\n \t\t\t srcbb->index);\n \t      match = false;\n \t      break;\n \t    }\n \t  if (EDGE_COUNT (srcbb->succs) != EDGE_COUNT (dstbb->succs))\n \t    {\n-\t      if (cgraph_dump_file)\n-\t\tfprintf (cgraph_dump_file,\n+\t      if (symtab->dump_file)\n+\t\tfprintf (symtab->dump_file,\n \t\t\t \"Edge count mistmatch for bb %i.\\n\",\n \t\t\t srcbb->index);\n \t      match = false;\n@@ -502,8 +502,8 @@ ipa_merge_profiles (struct cgraph_node *dst,\n \t      edge dste = EDGE_SUCC (dstbb, i);\n \t      if (srce->dest->index != dste->dest->index)\n \t\t{\n-\t\t  if (cgraph_dump_file)\n-\t\t    fprintf (cgraph_dump_file,\n+\t\t  if (symtab->dump_file)\n+\t\t    fprintf (symtab->dump_file,\n \t\t\t     \"Succ edge mistmatch for bb %i.\\n\",\n \t\t\t     srce->dest->index);\n \t\t  match = false;"}, {"sha": "32199af252f00a79201d34cb09f37d129f2279b2", "filename": "gcc/ipa-visibility.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3dafb85c8e6ade82adc591fe97c116b193f8bb0d/gcc%2Fipa-visibility.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3dafb85c8e6ade82adc591fe97c116b193f8bb0d/gcc%2Fipa-visibility.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-visibility.c?ref=3dafb85c8e6ade82adc591fe97c116b193f8bb0d", "patch": "@@ -580,11 +580,11 @@ function_and_variable_visibility (bool whole_program)\n \t\t{\n \t\t  struct cgraph_edge *e = node->callers;\n \n-\t\t  cgraph_redirect_edge_callee (e, alias);\n+\t\t  e->redirect_callee (alias);\n \t\t  if (gimple_has_body_p (e->caller->decl))\n \t\t    {\n \t\t      push_cfun (DECL_STRUCT_FUNCTION (e->caller->decl));\n-\t\t      cgraph_redirect_edge_call_stmt_to_callee (e);\n+\t\t      e->redirect_call_stmt_to_callee ();\n \t\t      pop_cfun ();\n \t\t    }\n \t\t}\n@@ -717,7 +717,7 @@ function_and_variable_visibility (bool whole_program)\n \t  fprintf (dump_file, \" %s\", vnode->name ());\n       fprintf (dump_file, \"\\n\\n\");\n     }\n-  cgraph_function_flags_ready = true;\n+  symtab->function_flags_ready = true;\n   return 0;\n }\n "}, {"sha": "5afacd87b7a548983e02e057c465b5dbae5aaa54", "filename": "gcc/ipa.c", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3dafb85c8e6ade82adc591fe97c116b193f8bb0d/gcc%2Fipa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3dafb85c8e6ade82adc591fe97c116b193f8bb0d/gcc%2Fipa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa.c?ref=3dafb85c8e6ade82adc591fe97c116b193f8bb0d", "patch": "@@ -114,7 +114,7 @@ process_references (symtab_node *snode,\n       if (node->definition && !node->in_other_partition\n \t  && ((!DECL_EXTERNAL (node->decl) || node->alias)\n \t      || (((before_inlining_p\n-\t\t    && (cgraph_state < CGRAPH_STATE_IPA_SSA\n+\t\t    && (symtab->state < IPA_SSA\n \t\t        || !lookup_attribute (\"always_inline\",\n \t\t\t\t\t      DECL_ATTRIBUTES (node->decl)))))\n \t\t  /* We use variable constructors during late complation for\n@@ -169,7 +169,7 @@ walk_polymorphic_call_targets (hash_set<void *> *reachable_call_targets,\n \t     devirtualization.  */\n \t   if (n->definition\n \t       && (before_inlining_p\n-\t\t   && (cgraph_state < CGRAPH_STATE_IPA_SSA\n+\t\t   && (symtab->state < IPA_SSA\n \t\t       || !lookup_attribute (\"always_inline\",\n \t\t\t\t\t     DECL_ATTRIBUTES (n->decl)))))\n \t     reachable->add (n);\n@@ -205,11 +205,11 @@ walk_polymorphic_call_targets (hash_set<void *> *reachable_call_targets,\n                                target->name (),\n                                target->order);\n \t    }\n-\t  edge = cgraph_make_edge_direct (edge, target);\n+\t  edge = edge->make_direct (target);\n \t  if (inline_summary_vec)\n \t    inline_update_overall_summary (node);\n \t  else if (edge->call_stmt)\n-\t    cgraph_redirect_edge_call_stmt_to_callee (edge);\n+\t    edge->redirect_call_stmt_to_callee ();\n \t}\n     }\n }\n@@ -270,7 +270,7 @@ walk_polymorphic_call_targets (hash_set<void *> *reachable_call_targets,\n    we set AUX pointer of processed symbols in the boundary to constant 2.  */\n \n bool\n-symtab_remove_unreachable_nodes (bool before_inlining_p, FILE *file)\n+symbol_table::remove_unreachable_nodes (bool before_inlining_p, FILE *file)\n {\n   symtab_node *first = (symtab_node *) (void *) 1;\n   struct cgraph_node *node, *next;\n@@ -448,9 +448,9 @@ symtab_remove_unreachable_nodes (bool before_inlining_p, FILE *file)\n     }\n \n   /* Remove unreachable functions.   */\n-  for (node = cgraph_first_function (); node; node = next)\n+  for (node = first_function (); node; node = next)\n     {\n-      next = cgraph_next_function (node);\n+      next = next_function (node);\n \n       /* If node is not needed at all, remove it.  */\n       if (!node->aux)\n@@ -515,9 +515,9 @@ symtab_remove_unreachable_nodes (bool before_inlining_p, FILE *file)\n   /* Remove unreachable variables.  */\n   if (file)\n     fprintf (file, \"\\nReclaiming variables:\");\n-  for (vnode = varpool_first_variable (); vnode; vnode = vnext)\n+  for (vnode = first_variable (); vnode; vnode = vnext)\n     {\n-      vnext = varpool_next_variable (vnode);\n+      vnext = next_variable (vnode);\n       if (!vnode->aux\n \t  /* For can_refer_decl_in_current_unit_p we want to track for\n \t     all external variables if they are defined in other partition"}, {"sha": "607aecec22f30663fd6d097a68b73a5e4c67ee68", "filename": "gcc/java/decl.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3dafb85c8e6ade82adc591fe97c116b193f8bb0d/gcc%2Fjava%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3dafb85c8e6ade82adc591fe97c116b193f8bb0d/gcc%2Fjava%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fdecl.c?ref=3dafb85c8e6ade82adc591fe97c116b193f8bb0d", "patch": "@@ -1890,7 +1890,7 @@ finish_method (tree fndecl)\n   cfun->function_end_locus = DECL_FUNCTION_LAST_LINE (fndecl);\n \n   /* Defer inlining and expansion to the cgraph optimizers.  */\n-  cgraph_finalize_function (fndecl, false);\n+  cgraph_node::finalize_function (fndecl, false);\n }\n \n /* We pessimistically marked all methods and fields external until we"}, {"sha": "9c4a9cf8be6e75ca2f2f6cee99de9862af4b0ebb", "filename": "gcc/java/jcf-parse.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3dafb85c8e6ade82adc591fe97c116b193f8bb0d/gcc%2Fjava%2Fjcf-parse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3dafb85c8e6ade82adc591fe97c116b193f8bb0d/gcc%2Fjava%2Fjcf-parse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fjcf-parse.c?ref=3dafb85c8e6ade82adc591fe97c116b193f8bb0d", "patch": "@@ -1727,7 +1727,7 @@ java_emit_static_constructor (void)\n \n       DECL_STATIC_CONSTRUCTOR (decl) = 1;\n       java_genericize (decl);\n-      cgraph_finalize_function (decl, false);\n+      cgraph_node::finalize_function (decl, false);\n     }\n }\n "}, {"sha": "8ff91ba6db0c524ab035bc4f3ce58bd64665a018", "filename": "gcc/langhooks.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3dafb85c8e6ade82adc591fe97c116b193f8bb0d/gcc%2Flanghooks.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3dafb85c8e6ade82adc591fe97c116b193f8bb0d/gcc%2Flanghooks.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flanghooks.c?ref=3dafb85c8e6ade82adc591fe97c116b193f8bb0d", "patch": "@@ -320,7 +320,7 @@ write_global_declarations (void)\n   timevar_start (TV_PHASE_OPT_GEN);\n   /* This lang hook is dual-purposed, and also finalizes the\n      compilation unit.  */\n-  finalize_compilation_unit ();\n+  symtab->finalize_compilation_unit ();\n   timevar_stop (TV_PHASE_OPT_GEN);\n \n   timevar_start (TV_PHASE_DBGINFO);"}, {"sha": "68f6a521682a4ce03e79f45bc241985c503ae2bc", "filename": "gcc/lto-cgraph.c", "status": "modified", "additions": 11, "deletions": 12, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3dafb85c8e6ade82adc591fe97c116b193f8bb0d/gcc%2Flto-cgraph.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3dafb85c8e6ade82adc591fe97c116b193f8bb0d/gcc%2Flto-cgraph.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto-cgraph.c?ref=3dafb85c8e6ade82adc591fe97c116b193f8bb0d", "patch": "@@ -789,7 +789,7 @@ add_node_to (lto_symtab_encoder_t encoder, struct cgraph_node *node,\n /* Add all references in NODE to encoders.  */\n \n static void\n-add_references (lto_symtab_encoder_t encoder, symtab_node *node)\n+create_references (lto_symtab_encoder_t encoder, symtab_node *node)\n {\n   int i;\n   struct ipa_ref *ref = NULL;\n@@ -828,7 +828,7 @@ compute_ltrans_boundary (lto_symtab_encoder_t in_encoder)\n       struct cgraph_node *node = lsei_cgraph_node (lsei);\n       add_node_to (encoder, node, true);\n       lto_set_symtab_encoder_in_partition (encoder, node);\n-      add_references (encoder, node);\n+      create_references (encoder, node);\n       /* For proper debug info, we need to ship the origins, too.  */\n       if (DECL_ABSTRACT_ORIGIN (node->decl))\n \t{\n@@ -844,7 +844,7 @@ compute_ltrans_boundary (lto_symtab_encoder_t in_encoder)\n \n       lto_set_symtab_encoder_in_partition (encoder, vnode);\n       lto_set_symtab_encoder_encode_initializer (encoder, vnode);\n-      add_references (encoder, vnode);\n+      create_references (encoder, vnode);\n       /* For proper debug info, we need to ship the origins, too.  */\n       if (DECL_ABSTRACT_ORIGIN (vnode->decl))\n \t{\n@@ -866,7 +866,7 @@ compute_ltrans_boundary (lto_symtab_encoder_t in_encoder)\n \t      && vnode->ctor_useable_for_folding_p ())\n \t    {\n \t      lto_set_symtab_encoder_encode_initializer (encoder, vnode);\n-\t      add_references (encoder, vnode);\n+\t      create_references (encoder, vnode);\n \t    }\n        }\n     }\n@@ -1114,7 +1114,6 @@ input_node (struct lto_file_decl_data *file_data,\n   int i, count;\n   tree group;\n   const char *section;\n-\n   order = streamer_read_hwi (ib) + order_base;\n   clone_ref = streamer_read_hwi (ib);\n \n@@ -1132,14 +1131,14 @@ input_node (struct lto_file_decl_data *file_data,\n       /* Declaration of functions can be already merged with a declaration\n \t from other input file.  We keep cgraph unmerged until after streaming\n \t of ipa passes is done.  Alays forcingly create a fresh node.  */\n-      node = cgraph_node::create_empty ();\n+      node = symtab->create_empty ();\n       node->decl = fn_decl;\n       node->register_symbol ();\n     }\n \n   node->order = order;\n-  if (order >= symtab_order)\n-    symtab_order = order + 1;\n+  if (order >= symtab->order)\n+    symtab->order = order + 1;\n \n   node->count = streamer_read_gcov_count (ib);\n   node->count_materialization_scale = streamer_read_hwi (ib);\n@@ -1241,8 +1240,8 @@ input_varpool_node (struct lto_file_decl_data *file_data,\n   node->register_symbol ();\n \n   node->order = order;\n-  if (order >= symtab_order)\n-    symtab_order = order + 1;\n+  if (order >= symtab->order)\n+    symtab->order = order + 1;\n   node->lto_file_data = file_data;\n \n   bp = streamer_read_bitpack (ib);\n@@ -1308,7 +1307,7 @@ input_ref (struct lto_input_block *ib,\n   use = (enum ipa_ref_use) bp_unpack_value (&bp, 2);\n   speculative = (enum ipa_ref_use) bp_unpack_value (&bp, 1);\n   node = nodes[streamer_read_hwi (ib)];\n-  ref = referring_node->add_reference (node, use);\n+  ref = referring_node->create_reference (node, use);\n   ref->speculative = speculative;\n   if (is_a <cgraph_node *> (referring_node))\n     ref->lto_stmt_uid = streamer_read_hwi (ib);\n@@ -1397,7 +1396,7 @@ input_cgraph_1 (struct lto_file_decl_data *file_data,\n   unsigned i;\n \n   tag = streamer_read_enum (ib, LTO_symtab_tags, LTO_symtab_last_tag);\n-  order_base = symtab_order;\n+  order_base = symtab->order;\n   while (tag)\n     {\n       if (tag == LTO_symtab_edge)"}, {"sha": "271b51ca4cc39bced2560187a5a417ec06ada40c", "filename": "gcc/lto-streamer-in.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3dafb85c8e6ade82adc591fe97c116b193f8bb0d/gcc%2Flto-streamer-in.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3dafb85c8e6ade82adc591fe97c116b193f8bb0d/gcc%2Flto-streamer-in.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto-streamer-in.c?ref=3dafb85c8e6ade82adc591fe97c116b193f8bb0d", "patch": "@@ -1358,10 +1358,10 @@ lto_input_toplevel_asms (struct lto_file_decl_data *file_data, int order_base)\n \n   while ((str = streamer_read_string_cst (data_in, &ib)))\n     {\n-      struct asm_node *node = add_asm_node (str);\n+      asm_node *node = symtab->finalize_toplevel_asm (str);\n       node->order = streamer_read_hwi (&ib) + order_base;\n-      if (node->order >= symtab_order)\n-\tsymtab_order = node->order + 1;\n+      if (node->order >= symtab->order)\n+\tsymtab->order = node->order + 1;\n     }\n \n   lto_data_in_delete (data_in);"}, {"sha": "b516c7b14d7f1bc93e905b90c67bcf5bc7f5ae48", "filename": "gcc/lto-streamer-out.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3dafb85c8e6ade82adc591fe97c116b193f8bb0d/gcc%2Flto-streamer-out.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3dafb85c8e6ade82adc591fe97c116b193f8bb0d/gcc%2Flto-streamer-out.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto-streamer-out.c?ref=3dafb85c8e6ade82adc591fe97c116b193f8bb0d", "patch": "@@ -2098,15 +2098,15 @@ lto_output_toplevel_asms (void)\n   char *section_name;\n   struct lto_simple_header_with_strings header;\n \n-  if (! asm_nodes)\n+  if (!symtab->first_asm_symbol ())\n     return;\n \n   ob = create_output_block (LTO_section_asm);\n \n   /* Make string 0 be a NULL string.  */\n   streamer_write_char_stream (ob->string_stream, 0);\n \n-  for (can = asm_nodes; can; can = can->next)\n+  for (can = symtab->first_asm_symbol (); can; can = can->next)\n     {\n       streamer_write_string_cst (ob, ob->main_stream, can->asm_str);\n       streamer_write_hwi (ob, can->order);"}, {"sha": "5bd089b128660b1f36d396b110f3ddb09d241f2e", "filename": "gcc/lto/lto-partition.c", "status": "modified", "additions": 30, "deletions": 28, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3dafb85c8e6ade82adc591fe97c116b193f8bb0d/gcc%2Flto%2Flto-partition.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3dafb85c8e6ade82adc591fe97c116b193f8bb0d/gcc%2Flto%2Flto-partition.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto%2Flto-partition.c?ref=3dafb85c8e6ade82adc591fe97c116b193f8bb0d", "patch": "@@ -22,7 +22,6 @@ along with GCC; see the file COPYING3.  If not see\n #include \"coretypes.h\"\n #include \"toplev.h\"\n #include \"tree.h\"\n-#include \"gcc-symtab.h\"\n #include \"basic-block.h\"\n #include \"tree-ssa-alias.h\"\n #include \"internal-fn.h\"\n@@ -140,8 +139,9 @@ add_symbol_to_partition_1 (ltrans_partition part, symtab_node *node)\n   if (symbol_partitioned_p (node))\n     {\n       node->in_other_partition = 1;\n-      if (cgraph_dump_file)\n-        fprintf (cgraph_dump_file, \"Symbol node %s now used in multiple partitions\\n\",\n+      if (symtab->dump_file)\n+\tfprintf (symtab->dump_file,\n+\t\t \"Symbol node %s now used in multiple partitions\\n\",\n \t\t node->name ());\n     }\n   node->aux = (void *)((size_t)node->aux + 1);\n@@ -413,7 +413,7 @@ lto_balanced_map (int n_lto_partitions)\n {\n   int n_nodes = 0;\n   int n_varpool_nodes = 0, varpool_pos = 0, best_varpool_pos = 0;\n-  struct cgraph_node **order = XNEWVEC (struct cgraph_node *, cgraph_max_uid);\n+  struct cgraph_node **order = XNEWVEC (cgraph_node *, symtab->cgraph_max_uid);\n   varpool_node **varpool_order = NULL;\n   int i;\n   struct cgraph_node *node;\n@@ -446,9 +446,10 @@ lto_balanced_map (int n_lto_partitions)\n      things works smoother if we order in source order.  */\n   qsort (order, n_nodes, sizeof (struct cgraph_node *), node_cmp);\n \n-  if (cgraph_dump_file)\n+  if (symtab->dump_file)\n     for(i = 0; i < n_nodes; i++)\n-      fprintf (cgraph_dump_file, \"Balanced map symbol order:%s:%u\\n\", order[i]->name (), order[i]->tp_first_run);\n+      fprintf (symtab->dump_file, \"Balanced map symbol order:%s:%u\\n\",\n+\t       order[i]->name (), order[i]->tp_first_run);\n \n   if (!flag_toplevel_reorder)\n     {\n@@ -471,8 +472,8 @@ lto_balanced_map (int n_lto_partitions)\n     partition_size = PARAM_VALUE (MIN_PARTITION_SIZE);\n   npartitions = 1;\n   partition = new_partition (\"\");\n-  if (cgraph_dump_file)\n-    fprintf (cgraph_dump_file, \"Total unit size: %i, partition size: %i\\n\",\n+  if (symtab->dump_file)\n+    fprintf (symtab->dump_file, \"Total unit size: %i, partition size: %i\\n\",\n \t     total_size, partition_size);\n \n   for (i = 0; i < n_nodes; i++)\n@@ -657,8 +658,8 @@ lto_balanced_map (int n_lto_partitions)\n \t  best_total_size = total_size;\n \t  best_varpool_pos = varpool_pos;\n \t}\n-      if (cgraph_dump_file)\n-\tfprintf (cgraph_dump_file, \"Step %i: added %s/%i, size %i, cost %i/%i \"\n+      if (symtab->dump_file)\n+\tfprintf (symtab->dump_file, \"Step %i: added %s/%i, size %i, cost %i/%i \"\n \t\t \"best %i/%i, step %i\\n\", i,\n \t\t order[i]->name (), order[i]->order,\n \t\t partition->insns, cost, internal,\n@@ -669,8 +670,8 @@ lto_balanced_map (int n_lto_partitions)\n \t{\n \t  if (best_i != i)\n \t    {\n-\t      if (cgraph_dump_file)\n-\t\tfprintf (cgraph_dump_file, \"Unwinding %i insertions to step %i\\n\",\n+\t      if (symtab->dump_file)\n+\t\tfprintf (symtab->dump_file, \"Unwinding %i insertions to step %i\\n\",\n \t\t\t i - best_i, best_i);\n \t      undo_partition (partition, best_n_nodes);\n \t      varpool_pos = best_varpool_pos;\n@@ -686,8 +687,8 @@ lto_balanced_map (int n_lto_partitions)\n \t  total_size = best_total_size;\n \t  cost = 0;\n \n-\t  if (cgraph_dump_file)\n-\t    fprintf (cgraph_dump_file, \"New partition\\n\");\n+\t  if (symtab->dump_file)\n+\t    fprintf (symtab->dump_file, \"New partition\\n\");\n \t  best_n_nodes = 0;\n \t  best_cost = INT_MAX;\n \n@@ -744,8 +745,8 @@ privatize_symbol_name (symtab_node *node)\n   if (node->lto_file_data\n       && lto_get_decl_name_mapping (node->lto_file_data, name) != name)\n     {\n-      if (cgraph_dump_file)\n-\tfprintf (cgraph_dump_file,\n+      if (symtab->dump_file)\n+\tfprintf (symtab->dump_file,\n \t\t\"Not privatizing symbol name: %s. It privatized already.\\n\",\n \t\tname);\n       return false;\n@@ -756,19 +757,20 @@ privatize_symbol_name (symtab_node *node)\n      that are not really clones.  */\n   if (node->unique_name)\n     {\n-      if (cgraph_dump_file)\n-\tfprintf (cgraph_dump_file,\n+      if (symtab->dump_file)\n+\tfprintf (symtab->dump_file,\n \t\t\"Not privatizing symbol name: %s. Has unique name.\\n\",\n \t\tname);\n       return false;\n     }\n-  change_decl_assembler_name (decl, clone_function_name (decl, \"lto_priv\"));\n+  symtab->change_decl_assembler_name (decl,\n+\t\t\t\t      clone_function_name (decl, \"lto_priv\"));\n   if (node->lto_file_data)\n     lto_record_renamed_decl (node->lto_file_data, name,\n \t\t\t     IDENTIFIER_POINTER\n \t\t\t     (DECL_ASSEMBLER_NAME (decl)));\n-  if (cgraph_dump_file)\n-    fprintf (cgraph_dump_file,\n+  if (symtab->dump_file)\n+    fprintf (symtab->dump_file,\n \t    \"Privatizing symbol name: %s -> %s\\n\",\n \t    name, IDENTIFIER_POINTER (DECL_ASSEMBLER_NAME (decl)));\n   return true;\n@@ -793,8 +795,8 @@ promote_symbol (symtab_node *node)\n   TREE_PUBLIC (node->decl) = 1;\n   DECL_VISIBILITY (node->decl) = VISIBILITY_HIDDEN;\n   DECL_VISIBILITY_SPECIFIED (node->decl) = true;\n-  if (cgraph_dump_file)\n-    fprintf (cgraph_dump_file,\n+  if (symtab->dump_file)\n+    fprintf (symtab->dump_file,\n \t    \"Promoting as hidden: %s\\n\", node->name ());\n }\n \n@@ -842,7 +844,7 @@ rename_statics (lto_symtab_encoder_t encoder, symtab_node *node)\n   /* Now walk symbols sharing the same name and see if there are any conflicts.\n      (all types of symbols counts here, since we can not have static of the\n      same name as external or public symbol.)  */\n-  for (s = symtab_node_for_asm (name);\n+  for (s = symtab_node::get_for_asmname (name);\n        s; s = s->next_sharing_asm_name)\n     if ((s->real_symbol_p () || may_need_named_section_p (encoder, s))\n \t&& s->decl != node->decl\n@@ -854,13 +856,13 @@ rename_statics (lto_symtab_encoder_t encoder, symtab_node *node)\n   if (!s)\n     return;\n \n-  if (cgraph_dump_file)\n-    fprintf (cgraph_dump_file,\n+  if (symtab->dump_file)\n+    fprintf (symtab->dump_file,\n \t    \"Renaming statics with asm name: %s\\n\", node->name ());\n \n   /* Assign every symbol in the set that shares the same ASM name an unique\n      mangled name.  */\n-  for (s = symtab_node_for_asm (name); s;)\n+  for (s = symtab_node::get_for_asmname (name); s;)\n     if (!s->externally_visible\n \t&& ((s->real_symbol_p ()\n              && !DECL_EXTERNAL (node->decl)\n@@ -871,7 +873,7 @@ rename_statics (lto_symtab_encoder_t encoder, symtab_node *node)\n       {\n         if (privatize_symbol_name (s))\n \t  /* Re-start from beginning since we do not know how many symbols changed a name.  */\n-\t  s = symtab_node_for_asm (name);\n+\t  s = symtab_node::get_for_asmname (name);\n         else s = s->next_sharing_asm_name;\n       }\n     else s = s->next_sharing_asm_name;"}, {"sha": "cf000760713b3be43dff2091ddd791442681e5f7", "filename": "gcc/lto/lto-symtab.c", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3dafb85c8e6ade82adc591fe97c116b193f8bb0d/gcc%2Flto%2Flto-symtab.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3dafb85c8e6ade82adc591fe97c116b193f8bb0d/gcc%2Flto%2Flto-symtab.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto%2Flto-symtab.c?ref=3dafb85c8e6ade82adc591fe97c116b193f8bb0d", "patch": "@@ -46,9 +46,9 @@ lto_cgraph_replace_node (struct cgraph_node *node,\n   struct cgraph_edge *e, *next;\n   bool compatible_p;\n \n-  if (cgraph_dump_file)\n+  if (symtab->dump_file)\n     {\n-      fprintf (cgraph_dump_file, \"Replacing cgraph node %s/%i by %s/%i\"\n+      fprintf (symtab->dump_file, \"Replacing cgraph node %s/%i by %s/%i\"\n  \t       \" for symbol %s\\n\",\n \t       node->name (), node->order,\n \t       prevailing_node->name (),\n@@ -75,7 +75,7 @@ lto_cgraph_replace_node (struct cgraph_node *node,\n   for (e = node->callers; e; e = next)\n     {\n       next = e->next_caller;\n-      cgraph_redirect_edge_callee (e, prevailing_node);\n+      e->redirect_callee (prevailing_node);\n       /* If there is a mismatch between the supposed callee return type and\n \t the real one do not attempt to inline this function.\n \t ???  We really need a way to match function signatures for ABI\n@@ -443,13 +443,13 @@ lto_symtab_merge_decls_1 (symtab_node *first)\n   symtab_node *prevailing;\n   bool diagnosed_p = false;\n \n-  if (cgraph_dump_file)\n+  if (symtab->dump_file)\n     {\n-      fprintf (cgraph_dump_file, \"Merging nodes for %s. Candidates:\\n\",\n+      fprintf (symtab->dump_file, \"Merging nodes for %s. Candidates:\\n\",\n \t       first->asm_name ());\n       for (e = first; e; e = e->next_sharing_asm_name)\n \tif (TREE_PUBLIC (e->decl))\n-\t  e->dump (cgraph_dump_file);\n+\t  e->dump (symtab->dump_file);\n     }\n \n   /* Compute the symbol resolutions.  This is a no-op when using the\n@@ -497,7 +497,7 @@ lto_symtab_merge_decls_1 (symtab_node *first)\n \t}\n     }\n \n-  symtab_prevail_in_asm_name_hash (prevailing);\n+  symtab->symtab_prevail_in_asm_name_hash (prevailing);\n \n   /* Diagnose mismatched objects.  */\n   for (e = prevailing->next_sharing_asm_name;\n@@ -539,11 +539,11 @@ lto_symtab_merge_decls_1 (symtab_node *first)\n      mismatches.  */\n   lto_symtab_merge_decls_2 (prevailing, diagnosed_p);\n \n-  if (cgraph_dump_file)\n+  if (symtab->dump_file)\n     {\n-      fprintf (cgraph_dump_file, \"After resolution:\\n\");\n+      fprintf (symtab->dump_file, \"After resolution:\\n\");\n       for (e = prevailing; e; e = e->next_sharing_asm_name)\n-\te->dump (cgraph_dump_file);\n+\te->dump (symtab->dump_file);\n     }\n }\n \n@@ -555,7 +555,7 @@ lto_symtab_merge_decls (void)\n   symtab_node *node;\n \n   /* Populate assembler name hash.   */\n-  symtab_initialize_asm_name_hash ();\n+  symtab->symtab_initialize_asm_name_hash ();\n \n   FOR_EACH_SYMBOL (node)\n     if (!node->previous_sharing_asm_name\n@@ -599,7 +599,7 @@ lto_symtab_merge_symbols (void)\n \n   if (!flag_ltrans)\n     {\n-      symtab_initialize_asm_name_hash ();\n+      symtab->symtab_initialize_asm_name_hash ();\n \n       /* Do the actual merging.  \n          At this point we invalidate hash translating decls into symtab nodes\n@@ -621,7 +621,7 @@ lto_symtab_merge_symbols (void)\n \n \t  if (!node->analyzed && node->alias_target)\n \t    {\n-\t      symtab_node *tgt = symtab_node_for_asm (node->alias_target);\n+\t      symtab_node *tgt = symtab_node::get_for_asmname (node->alias_target);\n \t      gcc_assert (node->weakref);\n \t      if (tgt)\n \t\tnode->resolve_alias (tgt);\n@@ -688,7 +688,7 @@ lto_symtab_prevailing_decl (tree decl)\n   gcc_assert (DECL_ASSEMBLER_NAME_SET_P (decl));\n \n   /* Walk through the list of candidates and return the one we merged to.  */\n-  ret = symtab_node_for_asm (DECL_ASSEMBLER_NAME (decl));\n+  ret = symtab_node::get_for_asmname (DECL_ASSEMBLER_NAME (decl));\n   if (!ret)\n     return decl;\n "}, {"sha": "1ecbbce4c8862fc7009146f3b85126871e922d4a", "filename": "gcc/lto/lto.c", "status": "modified", "additions": 29, "deletions": 28, "changes": 57, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3dafb85c8e6ade82adc591fe97c116b193f8bb0d/gcc%2Flto%2Flto.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3dafb85c8e6ade82adc591fe97c116b193f8bb0d/gcc%2Flto%2Flto.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto%2Flto.c?ref=3dafb85c8e6ade82adc591fe97c116b193f8bb0d", "patch": "@@ -2215,8 +2215,9 @@ lto_create_files_from_ids (lto_file *file, struct lto_file_decl_data *file_data,\n \t\t\t   int *count)\n {\n   lto_file_finalize (file_data, file);\n-  if (cgraph_dump_file)\n-    fprintf (cgraph_dump_file, \"Creating file %s with sub id \" HOST_WIDE_INT_PRINT_HEX \"\\n\", \n+  if (symtab->dump_file)\n+    fprintf (symtab->dump_file,\n+\t     \"Creating file %s with sub id \" HOST_WIDE_INT_PRINT_HEX \"\\n\",\n \t     file_data->file_name, file_data->id);\n   (*count)++;\n   return 0;\n@@ -2595,41 +2596,41 @@ lto_wpa_write_files (void)\n \n       if (!quiet_flag)\n \tfprintf (stderr, \" %s (%s %i insns)\", temp_filename, part->name, part->insns);\n-      if (cgraph_dump_file)\n+      if (symtab->dump_file)\n \t{\n           lto_symtab_encoder_iterator lsei;\n \t  \n-\t  fprintf (cgraph_dump_file, \"Writing partition %s to file %s, %i insns\\n\",\n+\t  fprintf (symtab->dump_file, \"Writing partition %s to file %s, %i insns\\n\",\n \t\t   part->name, temp_filename, part->insns);\n-\t  fprintf (cgraph_dump_file, \"  Symbols in partition: \");\n+\t  fprintf (symtab->dump_file, \"  Symbols in partition: \");\n \t  for (lsei = lsei_start_in_partition (part->encoder); !lsei_end_p (lsei);\n \t       lsei_next_in_partition (&lsei))\n \t    {\n \t      symtab_node *node = lsei_node (lsei);\n-\t      fprintf (cgraph_dump_file, \"%s \", node->asm_name ());\n+\t      fprintf (symtab->dump_file, \"%s \", node->asm_name ());\n \t    }\n-\t  fprintf (cgraph_dump_file, \"\\n  Symbols in boundary: \");\n+\t  fprintf (symtab->dump_file, \"\\n  Symbols in boundary: \");\n \t  for (lsei = lsei_start (part->encoder); !lsei_end_p (lsei);\n \t       lsei_next (&lsei))\n \t    {\n \t      symtab_node *node = lsei_node (lsei);\n \t      if (!lto_symtab_encoder_in_partition_p (part->encoder, node))\n \t\t{\n-\t          fprintf (cgraph_dump_file, \"%s \", node->asm_name ());\n+\t\t  fprintf (symtab->dump_file, \"%s \", node->asm_name ());\n \t\t  cgraph_node *cnode = dyn_cast <cgraph_node *> (node);\n \t\t  if (cnode\n \t\t      && lto_symtab_encoder_encode_body_p (part->encoder, cnode))\n-\t\t    fprintf (cgraph_dump_file, \"(body included)\");\n+\t\t    fprintf (symtab->dump_file, \"(body included)\");\n \t\t  else\n \t\t    {\n \t\t      varpool_node *vnode = dyn_cast <varpool_node *> (node);\n \t\t      if (vnode\n \t\t\t  && lto_symtab_encoder_encode_initializer_p (part->encoder, vnode))\n-\t\t\tfprintf (cgraph_dump_file, \"(initializer included)\");\n+\t\t\tfprintf (symtab->dump_file, \"(initializer included)\");\n \t\t    }\n \t\t}\n \t    }\n-\t  fprintf (cgraph_dump_file, \"\\n\");\n+\t  fprintf (symtab->dump_file, \"\\n\");\n \t}\n       gcc_checking_assert (lto_symtab_encoder_size (part->encoder) || !i);\n \n@@ -2889,7 +2890,7 @@ read_cgraph_and_symbols (unsigned nfiles, const char **fnames)\n   struct lto_file_decl_data **decl_data;\n   symtab_node *snode;\n \n-  init_cgraph ();\n+  symtab->initialize ();\n \n   timevar_push (TV_IPA_LTO_DECL_IN);\n \n@@ -2914,7 +2915,7 @@ read_cgraph_and_symbols (unsigned nfiles, const char **fnames)\n       /* True, since the plugin splits the archives.  */\n       gcc_assert (num_objects == nfiles);\n     }\n-  cgraph_state = CGRAPH_LTO_STREAMING;\n+  symtab->state = LTO_STREAMING;\n \n   canonical_type_hash_cache = new hash_map<const_tree, hashval_t> (251);\n   gimple_canonical_types = htab_create_ggc (16381, gimple_canonical_type_hash,\n@@ -3078,23 +3079,23 @@ read_cgraph_and_symbols (unsigned nfiles, const char **fnames)\n \n   /* Finally merge the cgraph according to the decl merging decisions.  */\n   timevar_push (TV_IPA_LTO_CGRAPH_MERGE);\n-  if (cgraph_dump_file)\n+  if (symtab->dump_file)\n     {\n-      fprintf (cgraph_dump_file, \"Before merging:\\n\");\n-      symtab_node::dump_table (cgraph_dump_file);\n+      fprintf (symtab->dump_file, \"Before merging:\\n\");\n+      symtab_node::dump_table (symtab->dump_file);\n     }\n   lto_symtab_merge_symbols ();\n   /* Removal of unreachable symbols is needed to make verify_symtab to pass;\n      we are still having duplicated comdat groups containing local statics.\n      We could also just remove them while merging.  */\n-  symtab_remove_unreachable_nodes (true, dump_file);\n+  symtab->remove_unreachable_nodes (true, dump_file);\n   ggc_collect ();\n-  cgraph_state = CGRAPH_STATE_IPA_SSA;\n+  symtab->state = IPA_SSA;\n \n   timevar_pop (TV_IPA_LTO_CGRAPH_MERGE);\n \n   /* Indicate that the cgraph is built and ready.  */\n-  cgraph_function_flags_ready = true;\n+  symtab->function_flags_ready = true;\n \n   ggc_free (all_file_decl_data);\n   all_file_decl_data = NULL;\n@@ -3236,20 +3237,20 @@ do_whole_program_analysis (void)\n       dump_memory_report (false);\n     }\n \n-  cgraph_function_flags_ready = true;\n+  symtab->function_flags_ready = true;\n \n-  if (cgraph_dump_file)\n-    symtab_node::dump_table (cgraph_dump_file);\n+  if (symtab->dump_file)\n+    symtab_node::dump_table (symtab->dump_file);\n   bitmap_obstack_initialize (NULL);\n-  cgraph_state = CGRAPH_STATE_IPA_SSA;\n+  symtab->state = IPA_SSA;\n \n   execute_ipa_pass_list (g->get_passes ()->all_regular_ipa_passes);\n-  symtab_remove_unreachable_nodes (false, dump_file);\n+  symtab->remove_unreachable_nodes (false, dump_file);\n \n-  if (cgraph_dump_file)\n+  if (symtab->dump_file)\n     {\n-      fprintf (cgraph_dump_file, \"Optimized \");\n-      symtab_node::dump_table (cgraph_dump_file);\n+      fprintf (symtab->dump_file, \"Optimized \");\n+      symtab_node::dump_table (symtab->dump_file);\n     }\n #ifdef ENABLE_CHECKING\n   symtab_node::verify_symtab_nodes ();\n@@ -3432,7 +3433,7 @@ lto_main (void)\n \n \t  /* Let the middle end know that we have read and merged all of\n \t     the input files.  */ \n-\t  compile ();\n+\t  symtab->compile ();\n \n \t  timevar_stop (TV_PHASE_OPT_GEN);\n "}, {"sha": "9d1cd2ce0f8d62309aa6c94f487d5c98d67e00ff", "filename": "gcc/omp-low.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3dafb85c8e6ade82adc591fe97c116b193f8bb0d/gcc%2Fomp-low.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3dafb85c8e6ade82adc591fe97c116b193f8bb0d/gcc%2Fomp-low.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fomp-low.c?ref=3dafb85c8e6ade82adc591fe97c116b193f8bb0d", "patch": "@@ -4907,7 +4907,7 @@ expand_omp_taskreg (struct omp_region *region)\n       push_cfun (child_cfun);\n       if (optimize)\n \toptimize_omp_library_calls (entry_stmt);\n-      rebuild_cgraph_edges ();\n+      cgraph_edge::rebuild_edges ();\n \n       /* Some EH regions might become dead, see PR34608.  If\n \t pass_cleanup_cfg isn't the first pass to happen with the\n@@ -8022,7 +8022,7 @@ expand_omp_target (struct omp_region *region)\n       /* Fix the callgraph edges for child_cfun.  Those for cfun will be\n \t fixed in a following pass.  */\n       push_cfun (child_cfun);\n-      rebuild_cgraph_edges ();\n+      cgraph_edge::rebuild_edges ();\n \n       /* Some EH regions might become dead, see PR34608.  If\n \t pass_cleanup_cfg isn't the first pass to happen with the\n@@ -11051,7 +11051,7 @@ simd_clone_create (struct cgraph_node *old_node)\n       DECL_STATIC_CONSTRUCTOR (new_decl) = 0;\n       DECL_STATIC_DESTRUCTOR (new_decl) = 0;\n       new_node = old_node->create_version_clone (new_decl, vNULL, NULL);\n-      new_node->call_function_insertion_hooks ();\n+      symtab->call_cgraph_insertion_hooks (new_node);\n     }\n   if (new_node == NULL)\n     return new_node;\n@@ -11884,7 +11884,7 @@ expand_simd_clones (struct cgraph_node *node)\n \t      clone->prev_clone->simdclone->next_clone = n;\n \t      node->simd_clones->simdclone->prev_clone = n;\n \t    }\n-\t  change_decl_assembler_name (n->decl, id);\n+\t  symtab->change_decl_assembler_name (n->decl, id);\n \t  /* And finally adjust the return type, parameters and for\n \t     definitions also function body.  */\n \t  if (node->definition)"}, {"sha": "5001c3d047dc5da10cbbffd0ae9dcc836654806d", "filename": "gcc/passes.c", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3dafb85c8e6ade82adc591fe97c116b193f8bb0d/gcc%2Fpasses.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3dafb85c8e6ade82adc591fe97c116b193f8bb0d/gcc%2Fpasses.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpasses.c?ref=3dafb85c8e6ade82adc591fe97c116b193f8bb0d", "patch": "@@ -333,8 +333,8 @@ execute_all_early_local_passes (void)\n      none of the sub-passes are IPA passes and do not create new\n      functions, this is ok.  We're setting this value for the benefit\n      of IPA passes that follow.  */\n-  if (cgraph_state < CGRAPH_STATE_IPA_SSA)\n-    cgraph_state = CGRAPH_STATE_IPA_SSA;\n+  if (symtab->state < IPA_SSA)\n+    symtab->state = IPA_SSA;\n   return 0;\n }\n \n@@ -1506,7 +1506,7 @@ do_per_function_toporder (void (*callback) (function *, void *data), void *data)\n   else\n     {\n       gcc_assert (!order);\n-      order = ggc_vec_alloc<cgraph_node *> (cgraph_n_nodes);\n+      order = ggc_vec_alloc<cgraph_node *> (symtab->cgraph_count);\n       nnodes = ipa_reverse_postorder (order);\n       for (i = nnodes - 1; i >= 0; i--)\n         order[i]->process = 1;\n@@ -1732,7 +1732,7 @@ execute_function_todo (function *fn, void *data)\n     rebuild_frequencies ();\n \n   if (flags & TODO_rebuild_cgraph_edges)\n-    rebuild_cgraph_edges ();\n+    cgraph_edge::rebuild_edges ();\n \n   /* If we've seen errors do not bother running any verifiers.  */\n   if (!seen_error ())\n@@ -1814,7 +1814,7 @@ execute_todo (unsigned int flags)\n   if (flags & TODO_remove_functions)\n     {\n       gcc_assert (!cfun);\n-      symtab_remove_unreachable_nodes (true, dump_file);\n+      symtab->remove_unreachable_nodes (true, dump_file);\n     }\n \n   if ((flags & TODO_dump_symtab) && dump_file && !current_function_decl)\n@@ -2113,15 +2113,15 @@ execute_one_pass (opt_pass *pass)\n \t\tnode->get_body ();\n \t\tpush_cfun (DECL_STRUCT_FUNCTION (node->decl));\n \t\texecute_all_ipa_transforms ();\n-\t\trebuild_cgraph_edges ();\n+\t\tcgraph_edge::rebuild_edges ();\n \t\tfree_dominance_info (CDI_DOMINATORS);\n \t\tfree_dominance_info (CDI_POST_DOMINATORS);\n \t\tpop_cfun ();\n \t\tapplied = true;\n \t      }\n \t  }\n       if (applied)\n-        symtab_remove_unreachable_nodes (false, dump_file);\n+\tsymtab->remove_unreachable_nodes (false, dump_file);\n       /* Restore current_pass.  */\n       current_pass = pass;\n     }\n@@ -2176,7 +2176,7 @@ execute_one_pass (opt_pass *pass)\n     }\n \n   if (!current_function_decl)\n-    cgraph_process_new_functions ();\n+    symtab->process_new_functions ();\n \n   pass_fini_dump_file (pass);\n \n@@ -2314,9 +2314,9 @@ ipa_write_summaries (void)\n      cgraph_expand_all_functions.  This mostly facilitates debugging,\n      since it causes the gimple file to be processed in the same order\n      as the source code.  */\n-  order = XCNEWVEC (struct cgraph_node *, cgraph_n_nodes);\n+  order = XCNEWVEC (struct cgraph_node *, symtab->cgraph_count);\n   order_pos = ipa_reverse_postorder (order);\n-  gcc_assert (order_pos == cgraph_n_nodes);\n+  gcc_assert (order_pos == symtab->cgraph_count);\n \n   for (i = order_pos - 1; i >= 0; i--)\n     {\n@@ -2555,7 +2555,7 @@ execute_ipa_pass_list (opt_pass *pass)\n \t    gcc_unreachable ();\n \t}\n       gcc_assert (!current_function_decl);\n-      cgraph_process_new_functions ();\n+      symtab->process_new_functions ();\n       pass = pass->next;\n     }\n   while (pass);"}, {"sha": "eb5db2acf8440bb2f408f64d44797580e8abe30e", "filename": "gcc/predict.c", "status": "modified", "additions": 12, "deletions": 13, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3dafb85c8e6ade82adc591fe97c116b193f8bb0d/gcc%2Fpredict.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3dafb85c8e6ade82adc591fe97c116b193f8bb0d/gcc%2Fpredict.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpredict.c?ref=3dafb85c8e6ade82adc591fe97c116b193f8bb0d", "patch": "@@ -187,31 +187,30 @@ maybe_hot_bb_p (struct function *fun, const_basic_block bb)\n /* Return true if the call can be hot.  */\n \n bool\n-cgraph_maybe_hot_edge_p (struct cgraph_edge *edge)\n+cgraph_edge::maybe_hot_p (void)\n {\n   if (profile_info && flag_branch_probabilities\n-      && !maybe_hot_count_p (NULL,\n-                             edge->count))\n+      && !maybe_hot_count_p (NULL, count))\n     return false;\n-  if (edge->caller->frequency == NODE_FREQUENCY_UNLIKELY_EXECUTED\n-      || (edge->callee\n-\t  && edge->callee->frequency == NODE_FREQUENCY_UNLIKELY_EXECUTED))\n+  if (caller->frequency == NODE_FREQUENCY_UNLIKELY_EXECUTED\n+      || (callee\n+\t  && callee->frequency == NODE_FREQUENCY_UNLIKELY_EXECUTED))\n     return false;\n-  if (edge->caller->frequency > NODE_FREQUENCY_UNLIKELY_EXECUTED\n-      && (edge->callee\n-\t  && edge->callee->frequency <= NODE_FREQUENCY_EXECUTED_ONCE))\n+  if (caller->frequency > NODE_FREQUENCY_UNLIKELY_EXECUTED\n+      && (callee\n+\t  && callee->frequency <= NODE_FREQUENCY_EXECUTED_ONCE))\n     return false;\n   if (optimize_size)\n     return false;\n-  if (edge->caller->frequency == NODE_FREQUENCY_HOT)\n+  if (caller->frequency == NODE_FREQUENCY_HOT)\n     return true;\n-  if (edge->caller->frequency == NODE_FREQUENCY_EXECUTED_ONCE\n-      && edge->frequency < CGRAPH_FREQ_BASE * 3 / 2)\n+  if (caller->frequency == NODE_FREQUENCY_EXECUTED_ONCE\n+      && frequency < CGRAPH_FREQ_BASE * 3 / 2)\n     return false;\n   if (flag_guess_branch_prob)\n     {\n       if (PARAM_VALUE (HOT_BB_FREQUENCY_FRACTION) == 0\n-\t  || edge->frequency <= (CGRAPH_FREQ_BASE\n+\t  || frequency <= (CGRAPH_FREQ_BASE\n \t\t\t\t / PARAM_VALUE (HOT_BB_FREQUENCY_FRACTION)))\n         return false;\n     }"}, {"sha": "d8302a7663943bd5b6284b80396d3d38ac7fb83d", "filename": "gcc/stor-layout.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3dafb85c8e6ade82adc591fe97c116b193f8bb0d/gcc%2Fstor-layout.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3dafb85c8e6ade82adc591fe97c116b193f8bb0d/gcc%2Fstor-layout.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fstor-layout.c?ref=3dafb85c8e6ade82adc591fe97c116b193f8bb0d", "patch": "@@ -298,7 +298,7 @@ finalize_size_functions (void)\n       dump_function (TDI_original, fndecl);\n       gimplify_function_tree (fndecl);\n       dump_function (TDI_generic, fndecl);\n-      cgraph_finalize_function (fndecl, false);\n+      cgraph_node::finalize_function (fndecl, false);\n     }\n \n   vec_free (size_functions);"}, {"sha": "739a8e4a308df4a0851498759bb7743fe3efd0ed", "filename": "gcc/symtab.c", "status": "modified", "additions": 120, "deletions": 154, "changes": 274, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3dafb85c8e6ade82adc591fe97c116b193f8bb0d/gcc%2Fsymtab.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3dafb85c8e6ade82adc591fe97c116b193f8bb0d/gcc%2Fsymtab.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsymtab.c?ref=3dafb85c8e6ade82adc591fe97c116b193f8bb0d", "patch": "@@ -61,36 +61,10 @@ const char * const ld_plugin_symbol_resolution_names[]=\n   \"prevailing_def_ironly_exp\"\n };\n \n-\n-/* Hash table used to hold sectoons.  */\n-static GTY((param_is (section_hash_entry))) htab_t section_hash;\n-\n-/* Hash table used to convert assembler names into nodes.  */\n-static GTY((param_is (symtab_node))) htab_t assembler_name_hash;\n-\n-/* Map from a symbol to initialization/finalization priorities.  */\n-struct GTY(()) symbol_priority_map {\n-  symtab_node *symbol;\n-  priority_type init;\n-  priority_type fini;\n-};\n-\n-/* Hash table used to hold init priorities.  */\n-static GTY ((param_is (struct symbol_priority_map)))\n-  htab_t init_priority_hash;\n-\n-/* Linked list of symbol table nodes.  */\n-symtab_node *symtab_nodes;\n-\n-/* The order index of the next symtab node to be created.  This is\n-   used so that we can sort the cgraph nodes in order by when we saw\n-   them, to support -fno-toplevel-reorder.  */\n-int symtab_order;\n-\n /* Hash asmnames ignoring the user specified marks.  */\n \n-static hashval_t\n-decl_assembler_name_hash (const_tree asmname)\n+hashval_t\n+symbol_table::decl_assembler_name_hash (const_tree asmname)\n {\n   if (IDENTIFIER_POINTER (asmname)[0] == '*')\n     {\n@@ -111,17 +85,17 @@ decl_assembler_name_hash (const_tree asmname)\n \n /* Returns a hash code for P.  */\n \n-static hashval_t\n-hash_node_by_assembler_name (const void *p)\n+hashval_t\n+symbol_table::hash_node_by_assembler_name (const void *p)\n {\n   const symtab_node *n = (const symtab_node *) p;\n   return (hashval_t) decl_assembler_name_hash (DECL_ASSEMBLER_NAME (n->decl));\n }\n \n /* Compare ASMNAME with the DECL_ASSEMBLER_NAME of DECL.  */\n \n-static bool\n-decl_assembler_name_equal (tree decl, const_tree asmname)\n+bool\n+symbol_table::decl_assembler_name_equal (tree decl, const_tree asmname)\n {\n   tree decl_asmname = DECL_ASSEMBLER_NAME (decl);\n   const char *decl_str;\n@@ -176,8 +150,8 @@ decl_assembler_name_equal (tree decl, const_tree asmname)\n \n /* Returns nonzero if P1 and P2 are equal.  */\n \n-static int\n-eq_assembler_name (const void *p1, const void *p2)\n+int\n+symbol_table::eq_assembler_name (const void *p1, const void *p2)\n {\n   const symtab_node *n1 = (const symtab_node *) p1;\n   const_tree name = (const_tree)p2;\n@@ -186,8 +160,9 @@ eq_assembler_name (const void *p1, const void *p2)\n \n /* Insert NODE to assembler name hash.  */\n \n-static void\n-insert_to_assembler_name_hash (symtab_node *node, bool with_clones)\n+void\n+symbol_table::insert_to_assembler_name_hash (symtab_node *node,\n+\t\t\t\t\t     bool with_clones)\n {\n   if (is_a <varpool_node *> (node) && DECL_HARD_REGISTER (node->decl))\n     return;\n@@ -196,7 +171,7 @@ insert_to_assembler_name_hash (symtab_node *node, bool with_clones)\n   if (assembler_name_hash)\n     {\n       void **aslot;\n-      struct cgraph_node *cnode;\n+      cgraph_node *cnode;\n       tree decl = node->decl;\n \n       tree name = DECL_ASSEMBLER_NAME (node->decl);\n@@ -222,12 +197,13 @@ insert_to_assembler_name_hash (symtab_node *node, bool with_clones)\n \n /* Remove NODE from assembler name hash.  */\n \n-static void\n-unlink_from_assembler_name_hash (symtab_node *node, bool with_clones)\n+void\n+symbol_table::unlink_from_assembler_name_hash (symtab_node *node,\n+\t\t\t\t\t       bool with_clones)\n {\n   if (assembler_name_hash)\n     {\n-      struct cgraph_node *cnode;\n+      cgraph_node *cnode;\n       tree decl = node->decl;\n \n       if (node->next_sharing_asm_name)\n@@ -266,7 +242,7 @@ unlink_from_assembler_name_hash (symtab_node *node, bool with_clones)\n /* Arrange node to be first in its entry of assembler_name_hash.  */\n \n void\n-symtab_prevail_in_asm_name_hash (symtab_node *node)\n+symbol_table::symtab_prevail_in_asm_name_hash (symtab_node *node)\n {\n   unlink_from_assembler_name_hash (node, false);\n   insert_to_assembler_name_hash (node, false);\n@@ -275,7 +251,7 @@ symtab_prevail_in_asm_name_hash (symtab_node *node)\n /* Initalize asm name hash unless.  */\n \n void\n-symtab_initialize_asm_name_hash (void)\n+symbol_table::symtab_initialize_asm_name_hash (void)\n {\n   symtab_node *node;\n   if (!assembler_name_hash)\n@@ -288,32 +264,10 @@ symtab_initialize_asm_name_hash (void)\n     }\n }\n \n-/* Return the cgraph node that has ASMNAME for its DECL_ASSEMBLER_NAME.\n-   Return NULL if there's no such node.  */\n-\n-symtab_node *\n-symtab_node_for_asm (const_tree asmname)\n-{\n-  symtab_node *node;\n-  void **slot;\n-\n-  symtab_initialize_asm_name_hash ();\n-  slot = htab_find_slot_with_hash (assembler_name_hash, asmname,\n-\t\t\t\t   decl_assembler_name_hash (asmname),\n-\t\t\t\t   NO_INSERT);\n-\n-  if (slot)\n-    {\n-      node = (symtab_node *) *slot;\n-      return node;\n-    }\n-  return NULL;\n-}\n-\n /* Set the DECL_ASSEMBLER_NAME and update symtab hashtables.  */\n \n void\n-change_decl_assembler_name (tree decl, tree name)\n+symbol_table::change_decl_assembler_name (tree decl, tree name)\n {\n   symtab_node *node = NULL;\n \n@@ -391,22 +345,16 @@ eq_sections (const void *p1, const void *p2)\n void\n symtab_node::register_symbol (void)\n {\n-  next = symtab_nodes;\n-  previous = NULL;\n-  if (symtab_nodes)\n-    symtab_nodes->previous = this;\n-  symtab_nodes = this;\n+  symtab->register_symbol (this);\n \n   if (!decl->decl_with_vis.symtab_node)\n     decl->decl_with_vis.symtab_node = this;\n \n   ref_list.clear ();\n \n-  order = symtab_order++;\n-\n   /* Be sure to do this last; C++ FE might create new nodes via\n      DECL_ASSEMBLER_NAME langhook!  */\n-  insert_to_assembler_name_hash (this, false);\n+  symtab->insert_to_assembler_name_hash (this, false);\n }\n \n /* Remove NODE from same comdat group.   */\n@@ -444,14 +392,7 @@ symtab_node::unregister (void)\n \n   remove_from_same_comdat_group ();\n \n-  if (previous)\n-    previous->next = next;\n-  else\n-    symtab_nodes = next;\n-  if (next)\n-    next->previous = previous;\n-  next = NULL;\n-  previous = NULL;\n+  symtab->unregister (this);\n \n   /* During LTO symtab merging we temporarily corrupt decl to symtab node\n      hash.  */\n@@ -464,16 +405,16 @@ symtab_node::unregister (void)\n       decl->decl_with_vis.symtab_node = replacement_node;\n     }\n   if (!is_a <varpool_node *> (this) || !DECL_HARD_REGISTER (decl))\n-    unlink_from_assembler_name_hash (this, false);\n+    symtab->unlink_from_assembler_name_hash (this, false);\n   if (in_init_priority_hash)\n     {\n-      struct symbol_priority_map in;\n+      symbol_priority_map in;\n       void **slot;\n       in.symbol = this;\n \n-      slot = htab_find_slot (init_priority_hash, &in, NO_INSERT);\n+      slot = htab_find_slot (symtab->init_priority_hash, &in, NO_INSERT);\n       if (slot)\n-\thtab_clear_slot (init_priority_hash, slot);\n+\thtab_clear_slot (symtab->init_priority_hash, slot);\n     }\n }\n \n@@ -560,24 +501,24 @@ symtab_node::name () const\n    REFERED_NODE or REFERED_VARPOOL_NODE. USE_TYPE specify type\n    of the use.  */\n \n-struct ipa_ref *\n-symtab_node::add_reference (symtab_node *referred_node,\n-\t\t\t    enum ipa_ref_use use_type)\n+ipa_ref *\n+symtab_node::create_reference (symtab_node *referred_node,\n+\t\t\t       enum ipa_ref_use use_type)\n {\n-  return add_reference (referred_node, use_type, NULL);\n+  return create_reference (referred_node, use_type, NULL);\n }\n \n \n /* Return ipa reference from this symtab_node to\n    REFERED_NODE or REFERED_VARPOOL_NODE. USE_TYPE specify type\n    of the use and STMT the statement (if it exists).  */\n \n-struct ipa_ref *\n-symtab_node::add_reference (symtab_node *referred_node,\n-\t\t\t    enum ipa_ref_use use_type, gimple stmt)\n+ipa_ref *\n+symtab_node::create_reference (symtab_node *referred_node,\n+\t\t\t       enum ipa_ref_use use_type, gimple stmt)\n {\n-  struct ipa_ref *ref = NULL, *ref2 = NULL;\n-  struct ipa_ref_list *list, *list2;\n+  ipa_ref *ref = NULL, *ref2 = NULL;\n+  ipa_ref_list *list, *list2;\n   ipa_ref_t *old_references;\n \n   gcc_checking_assert (!stmt || is_a <cgraph_node *> (this));\n@@ -627,9 +568,9 @@ symtab_node::add_reference (symtab_node *referred_node,\n    type of the use and STMT the statement (if it exists).  Return the new\n    reference or NULL if none was created.  */\n \n-struct ipa_ref *\n-symtab_node::maybe_add_reference (tree val, enum ipa_ref_use use_type,\n-\t\t\t\t  gimple stmt)\n+ipa_ref *\n+symtab_node::maybe_create_reference (tree val, enum ipa_ref_use use_type,\n+\t\t\t\t     gimple stmt)\n {\n   STRIP_NOPS (val);\n   if (TREE_CODE (val) != ADDR_EXPR)\n@@ -640,24 +581,24 @@ symtab_node::maybe_add_reference (tree val, enum ipa_ref_use use_type,\n     {\n       symtab_node *referred = symtab_node::get (val);\n       gcc_checking_assert (referred);\n-      return add_reference (referred, use_type, stmt);\n+      return create_reference (referred, use_type, stmt);\n     }\n   return NULL;\n }\n \n /* Clone all references from symtab NODE to this symtab_node.  */\n \n void\n-symtab_node::clone_references (struct symtab_node *node)\n+symtab_node::clone_references (symtab_node *node)\n {\n-  struct ipa_ref *ref = NULL, *ref2 = NULL;\n+  ipa_ref *ref = NULL, *ref2 = NULL;\n   int i;\n   for (i = 0; node->iterate_reference (i, ref); i++)\n     {\n       bool speculative = ref->speculative;\n       unsigned int stmt_uid = ref->lto_stmt_uid;\n \n-      ref2 = add_reference (ref->referred, ref->use, ref->stmt);\n+      ref2 = create_reference (ref->referred, ref->use, ref->stmt);\n       ref2->speculative = speculative;\n       ref2->lto_stmt_uid = stmt_uid;\n     }\n@@ -666,31 +607,31 @@ symtab_node::clone_references (struct symtab_node *node)\n /* Clone all referring from symtab NODE to this symtab_node.  */\n \n void\n-symtab_node::clone_referring (struct symtab_node *node)\n+symtab_node::clone_referring (symtab_node *node)\n {\n-  struct ipa_ref *ref = NULL, *ref2 = NULL;\n+  ipa_ref *ref = NULL, *ref2 = NULL;\n   int i;\n   for (i = 0; node->iterate_referring(i, ref); i++)\n     {\n       bool speculative = ref->speculative;\n       unsigned int stmt_uid = ref->lto_stmt_uid;\n \n-      ref2 = ref->referring->add_reference (this, ref->use, ref->stmt);\n+      ref2 = ref->referring->create_reference (this, ref->use, ref->stmt);\n       ref2->speculative = speculative;\n       ref2->lto_stmt_uid = stmt_uid;\n     }\n }\n \n /* Clone reference REF to this symtab_node and set its stmt to STMT.  */\n \n-struct ipa_ref *\n-symtab_node::clone_reference (struct ipa_ref *ref, gimple stmt)\n+ipa_ref *\n+symtab_node::clone_reference (ipa_ref *ref, gimple stmt)\n {\n   bool speculative = ref->speculative;\n   unsigned int stmt_uid = ref->lto_stmt_uid;\n-  struct ipa_ref *ref2;\n+  ipa_ref *ref2;\n \n-  ref2 = add_reference (ref->referred, ref->use, stmt);\n+  ref2 = create_reference (ref->referred, ref->use, stmt);\n   ref2->speculative = speculative;\n   ref2->lto_stmt_uid = stmt_uid;\n   return ref2;\n@@ -699,11 +640,11 @@ symtab_node::clone_reference (struct ipa_ref *ref, gimple stmt)\n /* Find the structure describing a reference to REFERRED_NODE\n    and associated with statement STMT.  */\n \n-struct ipa_ref *\n+ipa_ref *\n symtab_node::find_reference (symtab_node *referred_node,\n \t\t\t     gimple stmt, unsigned int lto_stmt_uid)\n {\n-  struct ipa_ref *r = NULL;\n+  ipa_ref *r = NULL;\n   int i;\n \n   for (i = 0; iterate_reference (i, r); i++)\n@@ -721,7 +662,7 @@ symtab_node::find_reference (symtab_node *referred_node,\n void\n symtab_node::remove_stmt_references (gimple stmt)\n {\n-  struct ipa_ref *r = NULL;\n+  ipa_ref *r = NULL;\n   int i = 0;\n \n   while (iterate_reference (i, r))\n@@ -739,7 +680,7 @@ symtab_node::remove_stmt_references (gimple stmt)\n void\n symtab_node::clear_stmts_in_references (void)\n {\n-  struct ipa_ref *r = NULL;\n+  ipa_ref *r = NULL;\n   int i;\n \n   for (i = 0; iterate_reference (i, r); i++)\n@@ -775,7 +716,7 @@ symtab_node::remove_all_referring (void)\n void\n symtab_node::dump_references (FILE *file)\n {\n-  struct ipa_ref *ref = NULL;\n+  ipa_ref *ref = NULL;\n   int i;\n   for (i = 0; iterate_reference (i, ref); i++)\n     {\n@@ -794,7 +735,7 @@ symtab_node::dump_references (FILE *file)\n void\n symtab_node::dump_referring (FILE *file)\n {\n-  struct ipa_ref *ref = NULL;\n+  ipa_ref *ref = NULL;\n   int i;\n   for (i = 0; iterate_referring(i, ref); i++)\n     {\n@@ -812,7 +753,7 @@ symtab_node::dump_referring (FILE *file)\n bool\n symtab_node::has_aliases_p (void)\n {\n-  struct ipa_ref *ref = NULL;\n+  ipa_ref *ref = NULL;\n   int i;\n \n   for (i = 0; iterate_referring (i, ref); i++)\n@@ -823,8 +764,8 @@ symtab_node::has_aliases_p (void)\n \n /* Iterates I-th reference in the list, REF is also set.  */\n \n-struct ipa_ref *\n-symtab_node::iterate_reference (unsigned i, struct ipa_ref *&ref)\n+ipa_ref *\n+symtab_node::iterate_reference (unsigned i, ipa_ref *&ref)\n {\n   vec_safe_iterate (ref_list.references, i, &ref);\n \n@@ -833,8 +774,8 @@ symtab_node::iterate_reference (unsigned i, struct ipa_ref *&ref)\n \n /* Iterates I-th referring item in the list, REF is also set.  */\n \n-struct ipa_ref *\n-symtab_node::iterate_referring (unsigned i, struct ipa_ref *&ref)\n+ipa_ref *\n+symtab_node::iterate_referring (unsigned i, ipa_ref *&ref)\n {\n   ref_list.referring.iterate (i, &ref);\n \n@@ -843,8 +784,8 @@ symtab_node::iterate_referring (unsigned i, struct ipa_ref *&ref)\n \n /* Iterates I-th referring alias item in the list, REF is also set.  */\n \n-struct ipa_ref *\n-symtab_node::iterate_direct_aliases (unsigned i, struct ipa_ref *&ref)\n+ipa_ref *\n+symtab_node::iterate_direct_aliases (unsigned i, ipa_ref *&ref)\n {\n   ref_list.referring.iterate (i, &ref);\n \n@@ -993,6 +934,29 @@ symtab_node::dump_table (FILE *f)\n     node->dump (f);\n }\n \n+\n+/* Return the cgraph node that has ASMNAME for its DECL_ASSEMBLER_NAME.\n+   Return NULL if there's no such node.  */\n+\n+symtab_node *\n+symtab_node::get_for_asmname (const_tree asmname)\n+{\n+  symtab_node *node;\n+  void **slot;\n+\n+  symtab->symtab_initialize_asm_name_hash ();\n+  slot = htab_find_slot_with_hash (symtab->assembler_name_hash, asmname,\n+\t\t\t\t   symtab->decl_assembler_name_hash (asmname),\n+\t\t\t\t   NO_INSERT);\n+\n+  if (slot)\n+    {\n+      node = (symtab_node *) *slot;\n+      return node;\n+    }\n+  return NULL;\n+}\n+\n /* Dump symtab node NODE to stderr.  */\n \n DEBUG_FUNCTION void\n@@ -1031,7 +995,7 @@ symtab_node::verify_base (void)\n       error_found = true;\n     }\n    \n-  if (cgraph_state != CGRAPH_LTO_STREAMING)\n+  if (symtab->state != LTO_STREAMING)\n     {\n       hashed_node = symtab_node::get (decl);\n       if (!hashed_node)\n@@ -1048,9 +1012,9 @@ symtab_node::verify_base (void)\n \t  error_found = true;\n \t}\n     }\n-  if (assembler_name_hash)\n+  if (symtab->assembler_name_hash)\n     {\n-      hashed_node = symtab_node_for_asm (DECL_ASSEMBLER_NAME (decl));\n+      hashed_node = symtab_node::get_for_asmname (DECL_ASSEMBLER_NAME (decl));\n       if (hashed_node && hashed_node->previous_sharing_asm_name)\n \t{\n           error (\"assembler name hash list corrupted\");\n@@ -1138,7 +1102,7 @@ symtab_node::verify_base (void)\n       while (n != this);\n       if (comdat_local_p ())\n \t{\n-\t  struct ipa_ref *ref = NULL;\n+\t  ipa_ref *ref = NULL;\n \n \t  for (int i = 0; iterate_referring (i, ref); ++i)\n \t    {\n@@ -1436,11 +1400,11 @@ symtab_node::set_section_for_node (const char *section)\n       x_section->ref_count--;\n       if (!x_section->ref_count)\n \t{\n-\t  slot = htab_find_slot_with_hash (section_hash, x_section->name,\n+\t  slot = htab_find_slot_with_hash (symtab->section_hash, x_section->name,\n \t\t\t\t\t   htab_hash_string (x_section->name),\n \t\t\t\t\t   INSERT);\n \t  ggc_free (x_section);\n-\t  htab_clear_slot (section_hash, slot);\n+\t  htab_clear_slot (symtab->section_hash, slot);\n \t}\n       x_section = NULL;\n     }\n@@ -1449,10 +1413,10 @@ symtab_node::set_section_for_node (const char *section)\n       implicit_section = false;\n       return;\n     }\n-  if (!section_hash)\n-    section_hash = htab_create_ggc (10, hash_section_hash_entry,\n+  if (!symtab->section_hash)\n+    symtab->section_hash = htab_create_ggc (10, hash_section_hash_entry,\n \t\t\t\t    eq_sections, NULL);\n-  slot = htab_find_slot_with_hash (section_hash, section,\n+  slot = htab_find_slot_with_hash (symtab->section_hash, section,\n \t\t\t\t   htab_hash_string (section),\n \t\t\t\t   INSERT);\n   if (*slot)\n@@ -1491,13 +1455,14 @@ symtab_node::set_section (const char *section)\n priority_type\n symtab_node::get_init_priority ()\n {\n-  struct symbol_priority_map *h;\n-  struct symbol_priority_map in;\n+  symbol_priority_map *h;\n+  symbol_priority_map in;\n \n   if (!this->in_init_priority_hash)\n     return DEFAULT_INIT_PRIORITY;\n   in.symbol = this;\n-  h = (struct symbol_priority_map *) htab_find (init_priority_hash, &in);\n+  h = (symbol_priority_map *) htab_find (symtab->init_priority_hash,\n+\t\t\t\t\t\t&in);\n   return h ? h->init : DEFAULT_INIT_PRIORITY;\n }\n \n@@ -1516,13 +1481,14 @@ enum availability symtab_node::get_availability (void)\n priority_type\n cgraph_node::get_fini_priority ()\n {\n-  struct symbol_priority_map *h;\n-  struct symbol_priority_map in;\n+  symbol_priority_map *h;\n+  symbol_priority_map in;\n \n   if (!this->in_init_priority_hash)\n     return DEFAULT_INIT_PRIORITY;\n   in.symbol = this;\n-  h = (struct symbol_priority_map *) htab_find (init_priority_hash, &in);\n+  h = (symbol_priority_map *) htab_find (symtab->init_priority_hash,\n+\t\t\t\t\t\t&in);\n   return h ? h->fini : DEFAULT_INIT_PRIORITY;\n }\n \n@@ -1531,8 +1497,8 @@ cgraph_node::get_fini_priority ()\n int\n symbol_priority_map_eq (const void *va, const void *vb)\n {\n-  const struct symbol_priority_map *const a = (const struct symbol_priority_map *) va,\n-    *const b = (const struct symbol_priority_map *) vb;\n+  const symbol_priority_map *const a = (const symbol_priority_map *) va,\n+    *const b = (const symbol_priority_map *) vb;\n   return (a->symbol == b->symbol);\n }\n \n@@ -1541,27 +1507,28 @@ symbol_priority_map_eq (const void *va, const void *vb)\n unsigned int\n symbol_priority_map_hash (const void *item)\n {\n-  return htab_hash_pointer (((const struct symbol_priority_map *)item)->symbol);\n+  return htab_hash_pointer (((const symbol_priority_map *)item)->symbol);\n }\n \n /* Return the initialization and finalization priority information for\n    DECL.  If there is no previous priority information, a freshly\n    allocated structure is returned.  */\n \n-struct symbol_priority_map *\n+symbol_priority_map *\n symtab_node::priority_info (void)\n {\n-  struct symbol_priority_map in;\n-  struct symbol_priority_map *h;\n+  symbol_priority_map in;\n+  symbol_priority_map *h;\n   void **loc;\n \n   in.symbol = this;\n-  if (!init_priority_hash)\n-    init_priority_hash = htab_create_ggc (512, symbol_priority_map_hash,\n-                                          symbol_priority_map_eq, 0);\n+  if (!symtab->init_priority_hash)\n+    symtab->init_priority_hash = htab_create_ggc (512,\n+\t\t\t\t\t\t  symbol_priority_map_hash,\n+\t\t\t\t\t\t  symbol_priority_map_eq, 0);\n \n-  loc = htab_find_slot (init_priority_hash, &in, INSERT);\n-  h = (struct symbol_priority_map *) *loc;\n+  loc = htab_find_slot (symtab->init_priority_hash, &in, INSERT);\n+  h = (symbol_priority_map *) *loc;\n   if (!h)\n     {\n       h = ggc_cleared_alloc<symbol_priority_map> ();\n@@ -1580,7 +1547,7 @@ symtab_node::priority_info (void)\n void\n symtab_node::set_init_priority (priority_type priority)\n {\n-  struct symbol_priority_map *h;\n+  symbol_priority_map *h;\n \n   if (is_a <cgraph_node *> (this))\n     gcc_assert (DECL_STATIC_CONSTRUCTOR (this->decl));\n@@ -1599,7 +1566,7 @@ symtab_node::set_init_priority (priority_type priority)\n void\n cgraph_node::set_fini_priority (priority_type priority)\n {\n-  struct symbol_priority_map *h;\n+  symbol_priority_map *h;\n \n   gcc_assert (DECL_STATIC_DESTRUCTOR (this->decl));\n \n@@ -1653,7 +1620,7 @@ symtab_node::resolve_alias (symtab_node *target)\n   definition = true;\n   alias = true;\n   analyzed = true;\n-  add_reference (target, IPA_REF_ALIAS, NULL);\n+  create_reference (target, IPA_REF_ALIAS, NULL);\n \n   /* Add alias into the comdat group of its target unless it is already there.  */\n   if (same_comdat_group)\n@@ -1677,7 +1644,7 @@ symtab_node::resolve_alias (symtab_node *target)\n      when renaming symbols.  */\n   alias_target = NULL;\n \n-  if (cpp_implicit_alias && cgraph_state >= CGRAPH_STATE_CONSTRUCTION)\n+  if (cpp_implicit_alias && symtab->state >= CONSTRUCTION)\n     fixup_same_cpp_alias_visibility (target);\n \n   /* If alias has address taken, so does the target.  */\n@@ -1696,7 +1663,7 @@ symtab_node::call_for_symbol_and_aliases (bool (*callback) (symtab_node *,\n \t\t\t\t\tvoid *data, bool include_overwritable)\n {\n   int i;\n-  struct ipa_ref *ref;\n+  ipa_ref *ref;\n \n   if (callback (this, data))\n     return true;\n@@ -1926,7 +1893,7 @@ symtab_node::nonzero_address ()\n      When parsing, beware the cases when WEAK attribute is added later.  */\n   if (!DECL_WEAK (this->decl)\n       && flag_delete_null_pointer_checks\n-      && cgraph_state > CGRAPH_STATE_PARSING)\n+      && symtab->state > PARSING)\n     return true;\n \n   /* If target is defined and not extern, we know it will be output and thus\n@@ -1944,4 +1911,3 @@ symtab_node::nonzero_address ()\n     return true;\n   return false;\n }\n-#include \"gt-symtab.h\""}, {"sha": "492a7ef58e5234e9df90b71597f20a7d5177986a", "filename": "gcc/toplev.c", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3dafb85c8e6ade82adc591fe97c116b193f8bb0d/gcc%2Ftoplev.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3dafb85c8e6ade82adc591fe97c116b193f8bb0d/gcc%2Ftoplev.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftoplev.c?ref=3dafb85c8e6ade82adc591fe97c116b193f8bb0d", "patch": "@@ -93,6 +93,8 @@ along with GCC; see the file COPYING3.  If not see\n \t\t\t\t   declarations for e.g. AIX 4.x.  */\n #endif\n \n+#include <new>\n+\n static void general_init (const char *);\n static void do_compile (void);\n static void process_options (void);\n@@ -401,7 +403,7 @@ wrapup_global_declaration_2 (tree decl)\n \tneeded = false;\n       else if (node && node->alias)\n \tneeded = false;\n-      else if (!cgraph_global_info_ready\n+      else if (!symtab->global_info_ready\n \t       && (TREE_USED (decl)\n \t\t   || TREE_USED (DECL_ASSEMBLER_NAME (decl))))\n \t/* needed */;\n@@ -1173,6 +1175,7 @@ general_init (const char *argv0)\n   /* Create the singleton holder for global state.\n      Doing so also creates the pass manager and with it the passes.  */\n   g = new gcc::context ();\n+  symtab = ggc_cleared_alloc <symbol_table> ();\n \n   statistics_early_init ();\n   finish_params ();\n@@ -1931,7 +1934,7 @@ do_compile (void)\n \n           ggc_protect_identifiers = true;\n \n-          init_cgraph ();\n+\t  symtab->initialize ();\n           init_final (main_input_filename);\n           coverage_init (aux_base_name);\n           statistics_init ();"}, {"sha": "82857963f544a55bf77316c54f23e57cddf1777b", "filename": "gcc/trans-mem.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3dafb85c8e6ade82adc591fe97c116b193f8bb0d/gcc%2Ftrans-mem.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3dafb85c8e6ade82adc591fe97c116b193f8bb0d/gcc%2Ftrans-mem.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftrans-mem.c?ref=3dafb85c8e6ade82adc591fe97c116b193f8bb0d", "patch": "@@ -4174,7 +4174,7 @@ ipa_tm_scan_calls_transaction (struct tm_ipa_cg_data *d,\n \n   // ??? copy_bbs should maintain cgraph edges for the blocks as it is\n   // copying them, rather than forcing us to do this externally.\n-  rebuild_cgraph_edges ();\n+  cgraph_edge::rebuild_edges ();\n \n   // ??? In ipa_uninstrument_transaction we don't try to update dominators\n   // because copy_bbs doesn't return a VEC like iterate_fix_dominators expects.\n@@ -4715,7 +4715,7 @@ ipa_tm_diagnose_transaction (struct cgraph_node *node,\n \t      if (is_tm_callable (fndecl))\n \t\tcontinue;\n \n-\t      if (cgraph_local_info (fndecl)->tm_may_enter_irr)\n+\t      if (cgraph_node::local_info (fndecl)->tm_may_enter_irr)\n \t\terror_at (gimple_location (stmt),\n \t\t\t  \"unsafe function call %qD within \"\n \t\t\t  \"atomic transaction\", fndecl);\n@@ -4913,7 +4913,7 @@ ipa_tm_create_version (struct cgraph_node *old_node)\n \n   record_tm_clone_pair (old_decl, new_decl);\n \n-  new_node->call_function_insertion_hooks ();\n+  symtab->call_cgraph_insertion_hooks (new_node);\n   if (old_node->force_output\n       || old_node->ref_list.first_referring ())\n     ipa_tm_mark_force_output_node (new_node);\n@@ -5134,7 +5134,7 @@ ipa_tm_transform_calls_redirect (struct cgraph_node *node,\n       fndecl = new_node->decl;\n     }\n \n-  cgraph_redirect_edge_callee (e, new_node);\n+  e->redirect_callee (new_node);\n   gimple_call_set_fndecl (stmt, fndecl);\n }\n "}, {"sha": "c915e3301e422c5f43dab69b85c9395a7647d79a", "filename": "gcc/tree-emutls.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3dafb85c8e6ade82adc591fe97c116b193f8bb0d/gcc%2Ftree-emutls.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3dafb85c8e6ade82adc591fe97c116b193f8bb0d/gcc%2Ftree-emutls.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-emutls.c?ref=3dafb85c8e6ade82adc591fe97c116b193f8bb0d", "patch": "@@ -274,7 +274,7 @@ get_emutls_init_templ_addr (tree decl)\n   if (DECL_EXTERNAL (to))\n     varpool_node::get_create (to);\n   else\n-    varpool_add_new_variable (to);\n+    varpool_node::add (to);\n   return build_fold_addr_expr (to);\n }\n \n@@ -344,7 +344,7 @@ new_emutls_decl (tree decl, tree alias_of)\n   if (DECL_EXTERNAL (to))\n     varpool_node::get_create (to);\n   else if (!alias_of)\n-    varpool_add_new_variable (to);\n+    varpool_node::add (to);\n   else \n     varpool_node::create_alias (to,\n \t\t\t\tvarpool_node::get_for_asmname\n@@ -425,7 +425,7 @@ gen_emutls_addr (tree decl, struct lower_emutls_data *d)\n \n       /* We may be adding a new reference to a new variable to the function.\n          This means we have to play with the ipa-reference web.  */\n-      d->cfun_node->add_reference (cvar, IPA_REF_ADDR, x);\n+      d->cfun_node->create_reference (cvar, IPA_REF_ADDR, x);\n \n       /* Record this ssa_name for possible use later in the basic block.  */\n       data->access = addr;"}, {"sha": "b82a1471f452a200ada0e3781b69bfa8cb7a11e2", "filename": "gcc/tree-inline.c", "status": "modified", "additions": 17, "deletions": 17, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3dafb85c8e6ade82adc591fe97c116b193f8bb0d/gcc%2Ftree-inline.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3dafb85c8e6ade82adc591fe97c116b193f8bb0d/gcc%2Ftree-inline.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-inline.c?ref=3dafb85c8e6ade82adc591fe97c116b193f8bb0d", "patch": "@@ -1800,10 +1800,10 @@ copy_bb (copy_body_data *id, basic_block bb, int frequency_scale,\n \t\t      int edge_freq = edge->frequency;\n \t\t      int new_freq;\n \t\t      struct cgraph_edge *old_edge = edge;\n-\t\t      edge = cgraph_clone_edge (edge, id->dst_node, stmt,\n-\t\t\t\t\t        gimple_uid (stmt),\n-\t\t\t\t\t        REG_BR_PROB_BASE, CGRAPH_FREQ_BASE,\n-\t\t\t\t\t        true);\n+\t\t      edge = edge->clone (id->dst_node, stmt,\n+\t\t\t\t\t  gimple_uid (stmt),\n+\t\t\t\t\t  REG_BR_PROB_BASE, CGRAPH_FREQ_BASE,\n+\t\t\t\t\t  true);\n \t\t      /* We could also just rescale the frequency, but\n \t\t         doing so would introduce roundoff errors and make\n \t\t\t verifier unhappy.  */\n@@ -1818,11 +1818,11 @@ copy_bb (copy_body_data *id, basic_block bb, int frequency_scale,\n \t\t\t  struct ipa_ref *ref;\n \n \t\t\t  gcc_assert (!edge->indirect_unknown_callee);\n-\t\t\t  cgraph_speculative_call_info (old_edge, direct, indirect, ref);\n-\t\t\t  indirect = cgraph_clone_edge (indirect, id->dst_node, stmt,\n-\t\t\t\t\t\t\tgimple_uid (stmt),\n-\t\t\t\t\t\t\tREG_BR_PROB_BASE, CGRAPH_FREQ_BASE,\n-\t\t\t\t\t\t\ttrue);\n+\t\t\t  old_edge->speculative_call_info (direct, indirect, ref);\n+\t\t\t  indirect = indirect->clone (id->dst_node, stmt,\n+\t\t\t\t\t\t      gimple_uid (stmt),\n+\t\t\t\t\t\t      REG_BR_PROB_BASE, CGRAPH_FREQ_BASE,\n+\t\t\t\t\t\t      true);\n \t\t\t  if (old_edge->frequency + indirect->frequency)\n \t\t\t    {\n \t\t\t      edge->frequency = MIN (RDIV ((gcov_type)new_freq * old_edge->frequency,\n@@ -1865,7 +1865,7 @@ copy_bb (copy_body_data *id, basic_block bb, int frequency_scale,\n \t\tcase CB_CGE_MOVE:\n \t\t  edge = id->dst_node->get_edge (orig_stmt);\n \t\t  if (edge)\n-\t\t    cgraph_set_call_stmt (edge, stmt);\n+\t\t    edge->set_call_stmt (stmt);\n \t\t  break;\n \n \t\tdefault:\n@@ -2426,7 +2426,7 @@ redirect_all_calls (copy_body_data * id, basic_block bb)\n \t{\n \t  struct cgraph_edge *edge = id->dst_node->get_edge (gsi_stmt (si));\n \t  if (edge)\n-\t    cgraph_redirect_edge_call_stmt_to_callee (edge);\n+\t    edge->redirect_call_stmt_to_callee ();\n \t}\n     }\n }\n@@ -4192,7 +4192,7 @@ expand_call_inline (basic_block bb, gimple stmt, copy_body_data *id)\n \t  && !cg_edge->callee->local.redefined_extern_inline\n \t  /* During early inline pass, report only when optimization is\n \t     not turned on.  */\n-\t  && (cgraph_global_info_ready\n+\t  && (symtab->global_info_ready\n \t      || !optimize\n \t      || cgraph_inline_failed_type (reason) == CIF_FINAL_ERROR)\n \t  /* PR 20090218-1_0.c. Body can be provided by another module. */\n@@ -4209,9 +4209,9 @@ expand_call_inline (basic_block bb, gimple stmt, copy_body_data *id)\n \t       && reason != CIF_UNSPECIFIED\n \t       && !lookup_attribute (\"noinline\", DECL_ATTRIBUTES (fn))\n \t       /* Do not warn about not inlined recursive calls.  */\n-\t       && !cgraph_edge_recursive_p (cg_edge)\n+\t       && !cg_edge->recursive_p ()\n \t       /* Avoid warnings during early inline pass. */\n-\t       && cgraph_global_info_ready)\n+\t       && symtab->global_info_ready)\n \t{\n \t  warning (OPT_Winline, \"inlining failed in call to %q+F: %s\",\n \t\t   fn, _(cgraph_inline_failed_string (reason)));\n@@ -5216,7 +5216,7 @@ delete_unreachable_blocks_update_callgraph (copy_body_data *id)\n \t\t  if (!e->inline_failed)\n \t\t    e->callee->remove_symbol_and_inline_clones (id->dst_node);\n \t\t  else\n-\t\t    cgraph_remove_edge (e);\n+\t\t    e->remove ();\n \t\t}\n \t      if (id->transform_call_graph_edges == CB_CGE_MOVE_CLONES\n \t\t  && id->dst_node->clones)\n@@ -5229,7 +5229,7 @@ delete_unreachable_blocks_update_callgraph (copy_body_data *id)\n \t\t\tif (!e->inline_failed)\n \t\t\t  e->callee->remove_symbol_and_inline_clones (id->dst_node);\n \t\t\telse\n-\t\t\t  cgraph_remove_edge (e);\n+\t\t\t  e->remove ();\n \t\t      }\n \n \t\t    if (node->clones)\n@@ -5535,7 +5535,7 @@ tree_function_versioning (tree old_decl, tree new_decl,\n   fold_cond_expr_cond ();\n   delete_unreachable_blocks_update_callgraph (&id);\n   if (id.dst_node->definition)\n-    cgraph_rebuild_references ();\n+    cgraph_edge::rebuild_references ();\n   update_ssa (TODO_update_ssa);\n \n   /* After partial cloning we need to rescale frequencies, so they are"}, {"sha": "82cec96038540712ba1f12efdd38ebea378b2764", "filename": "gcc/tree-nested.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3dafb85c8e6ade82adc591fe97c116b193f8bb0d/gcc%2Ftree-nested.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3dafb85c8e6ade82adc591fe97c116b193f8bb0d/gcc%2Ftree-nested.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-nested.c?ref=3dafb85c8e6ade82adc591fe97c116b193f8bb0d", "patch": "@@ -2897,7 +2897,7 @@ unnest_nesting_tree_1 (struct nesting_info *root)\n   if (node->origin)\n     {\n        node->unnest ();\n-       cgraph_finalize_function (root->context, true);\n+       cgraph_node::finalize_function (root->context, true);\n     }\n }\n "}, {"sha": "ba90196c7ce08a2e11593253bb906ac46604e5c2", "filename": "gcc/tree-profile.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3dafb85c8e6ade82adc591fe97c116b193f8bb0d/gcc%2Ftree-profile.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3dafb85c8e6ade82adc591fe97c116b193f8bb0d/gcc%2Ftree-profile.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-profile.c?ref=3dafb85c8e6ade82adc591fe97c116b193f8bb0d", "patch": "@@ -565,7 +565,7 @@ tree_profiling (void)\n \n   /* This is a small-ipa pass that gets called only once, from\n      cgraphunit.c:ipa_passes().  */\n-  gcc_assert (cgraph_state == CGRAPH_STATE_IPA_SSA);\n+  gcc_assert (symtab->state == IPA_SSA);\n \n   init_node_map (true);\n \n@@ -657,7 +657,7 @@ tree_profiling (void)\n       cleanup_tree_cfg ();\n       update_ssa (TODO_update_ssa);\n \n-      rebuild_cgraph_edges ();\n+      cgraph_edge::rebuild_edges ();\n \n       pop_cfun ();\n     }"}, {"sha": "8259dbaa316db43e917b28812e7ebea7100a9197", "filename": "gcc/tree-sra.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3dafb85c8e6ade82adc591fe97c116b193f8bb0d/gcc%2Ftree-sra.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3dafb85c8e6ade82adc591fe97c116b193f8bb0d/gcc%2Ftree-sra.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-sra.c?ref=3dafb85c8e6ade82adc591fe97c116b193f8bb0d", "patch": "@@ -4894,7 +4894,7 @@ modify_function (struct cgraph_node *node, ipa_parm_adjustment_vec adjustments)\n   struct cgraph_node *new_node;\n   bool cfg_changed;\n \n-  rebuild_cgraph_edges ();\n+  cgraph_edge::rebuild_edges ();\n   free_dominance_info (CDI_DOMINATORS);\n   pop_cfun ();\n "}, {"sha": "80a32855791f49d621f8a92e6e5f2273fd0a3792", "filename": "gcc/varasm.c", "status": "modified", "additions": 8, "deletions": 9, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3dafb85c8e6ade82adc591fe97c116b193f8bb0d/gcc%2Fvarasm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3dafb85c8e6ade82adc591fe97c116b193f8bb0d/gcc%2Fvarasm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvarasm.c?ref=3dafb85c8e6ade82adc591fe97c116b193f8bb0d", "patch": "@@ -33,7 +33,6 @@ along with GCC; see the file COPYING3.  If not see\n #include \"tree.h\"\n #include \"stor-layout.h\"\n #include \"stringpool.h\"\n-#include \"gcc-symtab.h\"\n #include \"varasm.h\"\n #include \"flags.h\"\n #include \"function.h\"\n@@ -856,7 +855,7 @@ set_user_assembler_name (tree decl, const char *name)\n   char *starred = (char *) alloca (strlen (name) + 2);\n   starred[0] = '*';\n   strcpy (starred + 1, name);\n-  change_decl_assembler_name (decl, get_identifier (starred));\n+  symtab->change_decl_assembler_name (decl, get_identifier (starred));\n   SET_DECL_RTL (decl, NULL_RTX);\n }\n \f\n@@ -2332,8 +2331,8 @@ assemble_external (tree decl ATTRIBUTE_UNUSED)\n      Ideally, only final.c would be calling this function, but it is\n      not clear whether that would break things somehow.  See PR 17982\n      for further discussion.  */\n-  gcc_assert (cgraph_state == CGRAPH_STATE_EXPANSION\n-\t      || cgraph_state == CGRAPH_STATE_FINISHED);\n+  gcc_assert (state == EXPANSION\n+\t      || state == FINISHED);\n #endif\n \n   if (!DECL_P (decl) || !DECL_EXTERNAL (decl) || !TREE_PUBLIC (decl))\n@@ -5361,7 +5360,7 @@ weak_finish_1 (tree decl)\n static tree\n find_decl (tree target)\n {\n-  symtab_node *node = symtab_node_for_asm (target);\n+  symtab_node *node = symtab_node::get_for_asmname (target);\n   if (node)\n     return node->decl;\n   return NULL_TREE;\n@@ -5656,12 +5655,12 @@ assemble_alias (tree decl, tree target)\n \n   /* If the target has already been emitted, we don't have to queue the\n      alias.  This saves a tad of memory.  */\n-  if (cgraph_global_info_ready)\n+  if (symtab->global_info_ready)\n     target_decl = find_decl (target);\n   else\n     target_decl= NULL;\n   if ((target_decl && TREE_ASM_WRITTEN (target_decl))\n-      || cgraph_state >= CGRAPH_STATE_EXPANSION)\n+      || symtab->state >= EXPANSION)\n     do_assemble_alias (decl, target);\n   else\n     {\n@@ -7591,10 +7590,10 @@ default_asm_output_ident_directive (const char *ident_str)\n      to asm_out_file.  Instead, add a fake top-level asm statement.\n      This allows the front ends to use this hook without actually\n      writing to asm_out_file, to handle #ident or Pragma Ident.  */\n-  if (cgraph_state == CGRAPH_STATE_PARSING)\n+  if (symtab->state == PARSING)\n     {\n       char *buf = ACONCAT ((ident_asm_op, \"\\\"\", ident_str, \"\\\"\\n\", NULL));\n-      add_asm_node (build_string (strlen (buf), buf));\n+      symtab->finalize_toplevel_asm (build_string (strlen (buf), buf));\n     }\n   else\n     fprintf (asm_out_file, \"%s\\\"%s\\\"\\n\", ident_asm_op, ident_str);"}, {"sha": "72971d61b53e70cacb466a280e0569484b633dd0", "filename": "gcc/varpool.c", "status": "modified", "additions": 50, "deletions": 55, "changes": 105, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3dafb85c8e6ade82adc591fe97c116b193f8bb0d/gcc%2Fvarpool.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3dafb85c8e6ade82adc591fe97c116b193f8bb0d/gcc%2Fvarpool.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvarpool.c?ref=3dafb85c8e6ade82adc591fe97c116b193f8bb0d", "patch": "@@ -50,19 +50,14 @@ struct varpool_node_hook_list {\n   struct varpool_node_hook_list *next;\n };\n \n-/* List of hooks triggered when a node is removed.  */\n-struct varpool_node_hook_list *first_varpool_node_removal_hook;\n-/* List of hooks triggered when an variable is inserted.  */\n-struct varpool_node_hook_list *first_varpool_variable_insertion_hook;\n-\n /* Register HOOK to be called with DATA on each removed node.  */\n-struct varpool_node_hook_list *\n-varpool_add_node_removal_hook (varpool_node_hook hook, void *data)\n+varpool_node_hook_list *\n+symbol_table::add_varpool_removal_hook (varpool_node_hook hook, void *data)\n {\n-  struct varpool_node_hook_list *entry;\n-  struct varpool_node_hook_list **ptr = &first_varpool_node_removal_hook;\n+  varpool_node_hook_list *entry;\n+  varpool_node_hook_list **ptr = &m_first_varpool_removal_hook;\n \n-  entry = (struct varpool_node_hook_list *) xmalloc (sizeof (*entry));\n+  entry = (varpool_node_hook_list *) xmalloc (sizeof (*entry));\n   entry->hook = hook;\n   entry->data = data;\n   entry->next = NULL;\n@@ -74,9 +69,9 @@ varpool_add_node_removal_hook (varpool_node_hook hook, void *data)\n \n /* Remove ENTRY from the list of hooks called on removing nodes.  */\n void\n-varpool_remove_node_removal_hook (struct varpool_node_hook_list *entry)\n+symbol_table::remove_varpool_removal_hook (varpool_node_hook_list *entry)\n {\n-  struct varpool_node_hook_list **ptr = &first_varpool_node_removal_hook;\n+  varpool_node_hook_list **ptr = &m_first_varpool_removal_hook;\n \n   while (*ptr != entry)\n     ptr = &(*ptr)->next;\n@@ -85,10 +80,10 @@ varpool_remove_node_removal_hook (struct varpool_node_hook_list *entry)\n }\n \n /* Call all node removal hooks.  */\n-static void\n-varpool_call_node_removal_hooks (varpool_node *node)\n+void\n+symbol_table::call_varpool_removal_hooks (varpool_node *node)\n {\n-  struct varpool_node_hook_list *entry = first_varpool_node_removal_hook;\n+  varpool_node_hook_list *entry = m_first_varpool_removal_hook;\n   while (entry)\n   {\n     entry->hook (node, entry->data);\n@@ -97,13 +92,13 @@ varpool_call_node_removal_hooks (varpool_node *node)\n }\n \n /* Register HOOK to be called with DATA on each inserted node.  */\n-struct varpool_node_hook_list *\n-varpool_add_variable_insertion_hook (varpool_node_hook hook, void *data)\n+varpool_node_hook_list *\n+symbol_table::add_varpool_insertion_hook (varpool_node_hook hook, void *data)\n {\n-  struct varpool_node_hook_list *entry;\n-  struct varpool_node_hook_list **ptr = &first_varpool_variable_insertion_hook;\n+  varpool_node_hook_list *entry;\n+  varpool_node_hook_list **ptr = &m_first_varpool_insertion_hook;\n \n-  entry = (struct varpool_node_hook_list *) xmalloc (sizeof (*entry));\n+  entry = (varpool_node_hook_list *) xmalloc (sizeof (*entry));\n   entry->hook = hook;\n   entry->data = data;\n   entry->next = NULL;\n@@ -115,9 +110,9 @@ varpool_add_variable_insertion_hook (varpool_node_hook hook, void *data)\n \n /* Remove ENTRY from the list of hooks called on inserted nodes.  */\n void\n-varpool_remove_variable_insertion_hook (struct varpool_node_hook_list *entry)\n+symbol_table::remove_varpool_insertion_hook (varpool_node_hook_list *entry)\n {\n-  struct varpool_node_hook_list **ptr = &first_varpool_variable_insertion_hook;\n+  varpool_node_hook_list **ptr = &m_first_varpool_insertion_hook;\n \n   while (*ptr != entry)\n     ptr = &(*ptr)->next;\n@@ -127,9 +122,9 @@ varpool_remove_variable_insertion_hook (struct varpool_node_hook_list *entry)\n \n /* Call all node insertion hooks.  */\n void\n-varpool_call_variable_insertion_hooks (varpool_node *node)\n+symbol_table::call_varpool_insertion_hooks (varpool_node *node)\n {\n-  struct varpool_node_hook_list *entry = first_varpool_variable_insertion_hook;\n+  varpool_node_hook_list *entry = m_first_varpool_insertion_hook;\n   while (entry)\n   {\n     entry->hook (node, entry->data);\n@@ -167,11 +162,11 @@ varpool_node::get_create (tree decl)\n void\n varpool_node::remove (void)\n {\n-  varpool_call_node_removal_hooks (this);\n+  symtab->call_varpool_removal_hooks (this);\n   unregister ();\n \n   /* When streaming we can have multiple nodes associated with decl.  */\n-  if (cgraph_state == CGRAPH_LTO_STREAMING)\n+  if (symtab->state == LTO_STREAMING)\n     ;\n   /* Keep constructor when it may be used for folding. We remove\n      references to external variables before final compilation.  */\n@@ -195,7 +190,7 @@ varpool_node::remove_initializer (void)\n \t entries for given decl.  Do not attempt to remove\n \t the boides, or we will end up remiving\n \t wrong one.  */\n-      && cgraph_state != CGRAPH_LTO_STREAMING)\n+      && symtab->state != LTO_STREAMING)\n     DECL_INITIAL (decl) = error_mark_node;\n }\n \n@@ -205,7 +200,7 @@ varpool_node::dump (FILE *f)\n {\n   dump_base (f);\n   fprintf (f, \"  Availability: %s\\n\",\n-\t   cgraph_function_flags_ready\n+\t   symtab->function_flags_ready\n \t   ? cgraph_availability_names[get_availability ()]\n \t   : \"not-ready\");\n   fprintf (f, \"  Varpool flags:\");\n@@ -256,7 +251,7 @@ varpool_node::debug_varpool (void)\n varpool_node *\n varpool_node::get_for_asmname (tree asmname)\n {\n-  if (symtab_node *node = symtab_node_for_asm (asmname))\n+  if (symtab_node *node = symtab_node::get_for_asmname (asmname))\n     return dyn_cast <varpool_node *> (node);\n   else\n     return NULL;\n@@ -268,7 +263,7 @@ varpool_node::get_for_asmname (tree asmname)\n tree\n varpool_node::get_constructor (void)\n {\n-  struct lto_file_decl_data *file_data;\n+  lto_file_decl_data *file_data;\n   const char *data, *name;\n   size_t len;\n \n@@ -437,16 +432,16 @@ ctor_for_folding (tree decl)\n }\n \n /* Add the variable DECL to the varpool.\n-   Unlike varpool_finalize_decl function is intended to be used\n+   Unlike finalize_decl function is intended to be used\n    by middle end and allows insertion of new variable at arbitrary point\n    of compilation.  */\n void\n-varpool_add_new_variable (tree decl)\n+varpool_node::add (tree decl)\n {\n   varpool_node *node;\n   varpool_node::finalize_decl (decl);\n   node = varpool_node::get_create (decl);\n-  varpool_call_variable_insertion_hooks (node);\n+  symtab->call_varpool_insertion_hooks (node);\n   if (node->externally_visible_p ())\n     node->externally_visible = true;\n }\n@@ -487,7 +482,7 @@ varpool_node::analyze (void)\n      We however don't want to re-analyze already analyzed nodes.  */\n   if (!analyzed)\n     {\n-      gcc_assert (!in_lto_p || cgraph_function_flags_ready);\n+      gcc_assert (!in_lto_p || symtab->function_flags_ready);\n       /* Compute the alignment early so function body expanders are\n \t already informed about increased alignment.  */\n       align_variable (decl, 0);\n@@ -504,7 +499,7 @@ varpool_node::analyze (void)\n void\n varpool_node::assemble_aliases (void)\n {\n-  struct ipa_ref *ref;\n+  ipa_ref *ref;\n \n   FOR_EACH_ALIAS (this, ref)\n     {\n@@ -578,20 +573,20 @@ enqueue_node (varpool_node *node, varpool_node **first)\n    reachability starting from variables that are either externally visible\n    or was referred from the asm output routines.  */\n \n-static void\n-varpool_remove_unreferenced_decls (void)\n+void\n+symbol_table::remove_unreferenced_decls (void)\n {\n   varpool_node *next, *node;\n   varpool_node *first = (varpool_node *)(void *)1;\n   int i;\n-  struct ipa_ref *ref = NULL;\n+  ipa_ref *ref = NULL;\n   hash_set<varpool_node *> referenced;\n \n   if (seen_error ())\n     return;\n \n-  if (cgraph_dump_file)\n-    fprintf (cgraph_dump_file, \"Trivially needed variables:\");\n+  if (dump_file)\n+    fprintf (dump_file, \"Trivially needed variables:\");\n   FOR_EACH_DEFINED_VARIABLE (node)\n     {\n       if (node->analyzed\n@@ -601,8 +596,8 @@ varpool_remove_unreferenced_decls (void)\n \t      || DECL_RTL_SET_P (node->decl)))\n \t{\n \t  enqueue_node (node, &first);\n-          if (cgraph_dump_file)\n-\t    fprintf (cgraph_dump_file, \" %s\", node->asm_name ());\n+\t  if (dump_file)\n+\t    fprintf (dump_file, \" %s\", node->asm_name ());\n \t}\n     }\n   while (first != (varpool_node *)(void *)1)\n@@ -635,24 +630,24 @@ varpool_remove_unreferenced_decls (void)\n \t    referenced.add (node);\n \t}\n     }\n-  if (cgraph_dump_file)\n-    fprintf (cgraph_dump_file, \"\\nRemoving variables:\");\n-  for (node = varpool_first_defined_variable (); node; node = next)\n+  if (dump_file)\n+    fprintf (dump_file, \"\\nRemoving variables:\");\n+  for (node = first_defined_variable (); node; node = next)\n     {\n-      next = varpool_next_defined_variable (node);\n+      next = next_defined_variable (node);\n       if (!node->aux)\n \t{\n-          if (cgraph_dump_file)\n-\t    fprintf (cgraph_dump_file, \" %s\", node->asm_name ());\n-\t  if (referenced.contains (node))\n+\t  if (dump_file)\n+\t    fprintf (dump_file, \" %s\", node->asm_name ());\n+\t  if (referenced.contains(node))\n \t    node->remove_initializer ();\n \t  else\n \t    node->remove ();\n \t}\n     }\n \n-  if (cgraph_dump_file)\n-    fprintf (cgraph_dump_file, \"\\n\");\n+  if (dump_file)\n+    fprintf (dump_file, \"\\n\");\n }\n \n /* For variables in named sections make sure get_variable_section\n@@ -674,15 +669,15 @@ varpool_node::finalize_named_section_flags (void)\n \n /* Output all variables enqueued to be assembled.  */\n bool\n-varpool_node::output_variables (void)\n+symbol_table::output_variables (void)\n {\n   bool changed = false;\n   varpool_node *node;\n \n   if (seen_error ())\n     return false;\n \n-  varpool_remove_unreferenced_decls ();\n+  remove_unreferenced_decls ();\n \n   timevar_push (TV_VAROUT);\n \n@@ -755,7 +750,7 @@ varpool_node::create_extra_name_alias (tree alias, tree decl)\n      via DECL_ASSEMBLER_NAME mechanizm.\n      This is unfortunate because they are not going through the\n      standard channels.  Ensure they get output.  */\n-  if (cpp_implicit_aliases_done)\n+  if (symtab->cpp_implicit_aliases_done)\n     alias_node->resolve_alias (varpool_node::get_create (decl));\n   return alias_node;\n }\n@@ -770,7 +765,7 @@ varpool_node::call_for_node_and_aliases (bool (*callback) (varpool_node *,\n \t\t\t\t\t void *data,\n \t\t\t\t\t bool include_overwritable)\n {\n-  struct ipa_ref *ref;\n+  ipa_ref *ref;\n \n   if (callback (this, data))\n     return true;"}]}