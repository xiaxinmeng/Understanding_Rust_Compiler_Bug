{"sha": "6bf5ce8f85c50886913d6f26a248f4c4c1445bd2", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NmJmNWNlOGY4NWM1MDg4NjkxM2Q2ZjI2YTI0OGY0YzRjMTQ0NWJkMg==", "commit": {"author": {"name": "Bill Schmidt", "email": "wschmidt@linux.vnet.ibm.com", "date": "2014-09-04T14:31:34Z"}, "committer": {"name": "William Schmidt", "email": "wschmidt@gcc.gnu.org", "date": "2014-09-04T14:31:34Z"}, "message": "rs6000.c (special_handling_values): Add SH_EXTRACT.\n\n[gcc]\n\n2014-09-04  Bill Schmidt  <wschmidt@linux.vnet.ibm.com>\n\n\t* config/rs6000/rs6000.c (special_handling_values): Add\n\tSH_EXTRACT.\n\t(rtx_is_swappable_p): Look for patterns with a VEC_SELECT, perhaps\n\twrapped in a VEC_DUPLICATE, representing an extract.  Mark these\n\tas swappable with special handling SH_EXTRACT.  Remove\n\tUNSPEC_VSX_XXSPLTW from the list of disallowed unspecs for the\n\toptimization.\n\t(adjust_extract): New function.\n\t(handle_special_swappables): Add default to case statement; add\n\tcase for SH_EXTRACT that calls adjust_extract.\n\t(dump_swap_insn_table): Handle SH_EXTRACT.\n\n[gcc/testsuite]\n\n2014-09-04  Bill Schmidt  <wschmidt@linux.vnet.ibm.com>\n\n\t* gcc.target/powerpc/swaps-p8-13.c: New test.\n\t* gcc.target/powerpc/swaps-p8-14.c: New test.\n\t* gcc.target/powerpc/swaps-p8-15.c: New test.\n\nFrom-SVN: r214903", "tree": {"sha": "d032c6b31e1debd476e39d7f665dc43cd8604345", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d032c6b31e1debd476e39d7f665dc43cd8604345"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6bf5ce8f85c50886913d6f26a248f4c4c1445bd2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6bf5ce8f85c50886913d6f26a248f4c4c1445bd2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6bf5ce8f85c50886913d6f26a248f4c4c1445bd2", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6bf5ce8f85c50886913d6f26a248f4c4c1445bd2/comments", "author": {"login": "wschmidt-ibm", "id": 5520937, "node_id": "MDQ6VXNlcjU1MjA5Mzc=", "avatar_url": "https://avatars.githubusercontent.com/u/5520937?v=4", "gravatar_id": "", "url": "https://api.github.com/users/wschmidt-ibm", "html_url": "https://github.com/wschmidt-ibm", "followers_url": "https://api.github.com/users/wschmidt-ibm/followers", "following_url": "https://api.github.com/users/wschmidt-ibm/following{/other_user}", "gists_url": "https://api.github.com/users/wschmidt-ibm/gists{/gist_id}", "starred_url": "https://api.github.com/users/wschmidt-ibm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/wschmidt-ibm/subscriptions", "organizations_url": "https://api.github.com/users/wschmidt-ibm/orgs", "repos_url": "https://api.github.com/users/wschmidt-ibm/repos", "events_url": "https://api.github.com/users/wschmidt-ibm/events{/privacy}", "received_events_url": "https://api.github.com/users/wschmidt-ibm/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "2b3106ecef35e73229cca4c82b0ccd1fb2225f51", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2b3106ecef35e73229cca4c82b0ccd1fb2225f51", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2b3106ecef35e73229cca4c82b0ccd1fb2225f51"}], "stats": {"total": 220, "additions": 217, "deletions": 3}, "files": [{"sha": "a10162d5bd035653035119c94fefd2fd6c7cbc45", "filename": "gcc/ChangeLog", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6bf5ce8f85c50886913d6f26a248f4c4c1445bd2/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6bf5ce8f85c50886913d6f26a248f4c4c1445bd2/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=6bf5ce8f85c50886913d6f26a248f4c4c1445bd2", "patch": "@@ -1,3 +1,17 @@\n+2014-09-04  Bill Schmidt  <wschmidt@linux.vnet.ibm.com>\n+\n+\t* config/rs6000/rs6000.c (special_handling_values): Add\n+\tSH_EXTRACT.\n+\t(rtx_is_swappable_p): Look for patterns with a VEC_SELECT, perhaps\n+\twrapped in a VEC_DUPLICATE, representing an extract.  Mark these\n+\tas swappable with special handling SH_EXTRACT.  Remove\n+\tUNSPEC_VSX_XXSPLTW from the list of disallowed unspecs for the\n+\toptimization.\n+\t(adjust_extract): New function.\n+\t(handle_special_swappables): Add default to case statement; add\n+\tcase for SH_EXTRACT that calls adjust_extract.\n+\t(dump_swap_insn_table): Handle SH_EXTRACT.\n+\n 2014-09-04  Bill Schmidt  <wschmidt@linux.vnet.ibm.com>\n \n \t* config/rs6000/vsx.md (*vsx_extract_<mode>_load): Always match"}, {"sha": "6370304b28731f439b2b8b7710d079535ddaf404", "filename": "gcc/config/rs6000/rs6000.c", "status": "modified", "additions": 53, "deletions": 3, "changes": 56, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6bf5ce8f85c50886913d6f26a248f4c4c1445bd2/gcc%2Fconfig%2Frs6000%2Frs6000.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6bf5ce8f85c50886913d6f26a248f4c4c1445bd2/gcc%2Fconfig%2Frs6000%2Frs6000.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.c?ref=6bf5ce8f85c50886913d6f26a248f4c4c1445bd2", "patch": "@@ -33523,7 +33523,8 @@ enum special_handling_values {\n   SH_CONST_VECTOR,\n   SH_SUBREG,\n   SH_NOSWAP_LD,\n-  SH_NOSWAP_ST\n+  SH_NOSWAP_ST,\n+  SH_EXTRACT\n };\n \n /* Union INSN with all insns containing definitions that reach USE.\n@@ -33665,6 +33666,7 @@ rtx_is_swappable_p (rtx op, unsigned int *special)\n {\n   enum rtx_code code = GET_CODE (op);\n   int i, j;\n+  rtx parallel;\n \n   switch (code)\n     {\n@@ -33675,7 +33677,6 @@ rtx_is_swappable_p (rtx op, unsigned int *special)\n       return 1;\n \n     case VEC_CONCAT:\n-    case VEC_SELECT:\n     case ASM_INPUT:\n     case ASM_OPERANDS:\n       return 0;\n@@ -33693,6 +33694,28 @@ rtx_is_swappable_p (rtx op, unsigned int *special)\n \t handling.  */\n       if (GET_CODE (XEXP (op, 0)) == CONST_INT)\n \treturn 1;\n+      else if (GET_CODE (XEXP (op, 0)) == REG\n+\t       && GET_MODE_INNER (GET_MODE (op)) == GET_MODE (XEXP (op, 0)))\n+\t/* This catches V2DF and V2DI splat, at a minimum.  */\n+\treturn 1;\n+      else if (GET_CODE (XEXP (op, 0)) == VEC_SELECT)\n+\t/* If the duplicated item is from a select, defer to the select\n+\t   processing to see if we can change the lane for the splat.  */\n+\treturn rtx_is_swappable_p (XEXP (op, 0), special);\n+      else\n+\treturn 0;\n+\n+    case VEC_SELECT:\n+      /* A vec_extract operation is ok if we change the lane.  */\n+      if (GET_CODE (XEXP (op, 0)) == REG\n+\t  && GET_MODE_INNER (GET_MODE (XEXP (op, 0))) == GET_MODE (op)\n+\t  && GET_CODE ((parallel = XEXP (op, 1))) == PARALLEL\n+\t  && XVECLEN (parallel, 0) == 1\n+\t  && GET_CODE (XVECEXP (parallel, 0, 0)) == CONST_INT)\n+\t{\n+\t  *special = SH_EXTRACT;\n+\t  return 1;\n+\t}\n       else\n \treturn 0;\n \n@@ -33738,7 +33761,6 @@ rtx_is_swappable_p (rtx op, unsigned int *special)\n \t    || val == UNSPEC_VSX_CVSPDPN\n \t    || val == UNSPEC_VSX_SET\n \t    || val == UNSPEC_VSX_SLDWI\n-\t    || val == UNSPEC_VSX_XXSPLTW\n \t    || val == UNSPEC_VUNPACK_HI_SIGN\n \t    || val == UNSPEC_VUNPACK_HI_SIGN_DIRECT\n \t    || val == UNSPEC_VUNPACK_LO_SIGN\n@@ -34076,6 +34098,27 @@ permute_store (rtx_insn *insn)\n \t     INSN_UID (insn));\n }\n \n+/* Given OP that contains a vector extract operation, change the index\n+   of the extracted lane to count from the other side of the vector.  */\n+static void\n+adjust_extract (rtx_insn *insn)\n+{\n+  rtx body = PATTERN (insn);\n+  /* The vec_select may be wrapped in a vec_duplicate for a splat, so\n+     account for that.  */\n+  rtx sel = (GET_CODE (body) == VEC_DUPLICATE\n+\t     ? XEXP (XEXP (body, 0), 1)\n+\t     : XEXP (body, 1));\n+  rtx par = XEXP (sel, 1);\n+  int nunits = GET_MODE_NUNITS (GET_MODE (XEXP (sel, 0)));\n+  XVECEXP (par, 0, 0) = GEN_INT (nunits - 1 - INTVAL (XVECEXP (par, 0, 0)));\n+  INSN_CODE (insn) = -1; /* Force re-recognition.  */\n+  df_insn_rescan (insn);\n+\n+  if (dump_file)\n+    fprintf (dump_file, \"Changing lane for extract %d\\n\", INSN_UID (insn));\n+}\n+\n /* The insn described by INSN_ENTRY[I] can be swapped, but only\n    with special handling.  Take care of that here.  */\n static void\n@@ -34086,6 +34129,8 @@ handle_special_swappables (swap_web_entry *insn_entry, unsigned i)\n \n   switch (insn_entry[i].special_handling)\n     {\n+    default:\n+      gcc_unreachable ();\n     case SH_CONST_VECTOR:\n       {\n \t/* A CONST_VECTOR will only show up somewhere in the RHS of a SET.  */\n@@ -34112,6 +34157,9 @@ handle_special_swappables (swap_web_entry *insn_entry, unsigned i)\n       /* Convert a non-permuting store to a permuting one.  */\n       permute_store (insn);\n       break;\n+    case SH_EXTRACT:\n+      /* Change the lane on an extract operation.  */\n+      adjust_extract (insn);\n     }\n }\n \n@@ -34180,6 +34228,8 @@ dump_swap_insn_table (swap_web_entry *insn_entry)\n \t      fputs (\"special:load \", dump_file);\n \t    else if (insn_entry[i].special_handling == SH_NOSWAP_ST)\n \t      fputs (\"special:store \", dump_file);\n+\t    else if (insn_entry[i].special_handling == SH_EXTRACT)\n+\t      fputs (\"special:extract \", dump_file);\n \t  }\n \tif (insn_entry[i].web_not_optimizable)\n \t  fputs (\"unoptimizable \", dump_file);"}, {"sha": "462d1d3c3182e73aa799bfa58d5e8afa3fee1e55", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6bf5ce8f85c50886913d6f26a248f4c4c1445bd2/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6bf5ce8f85c50886913d6f26a248f4c4c1445bd2/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=6bf5ce8f85c50886913d6f26a248f4c4c1445bd2", "patch": "@@ -1,3 +1,9 @@\n+2014-09-04  Bill Schmidt  <wschmidt@linux.vnet.ibm.com>\n+\n+\t* gcc.target/powerpc/swaps-p8-13.c: New test.\n+\t* gcc.target/powerpc/swaps-p8-14.c: New test.\n+\t* gcc.target/powerpc/swaps-p8-15.c: New test.\n+\n 2014-09-04  Bill Schmidt  <wschmidt@linux.vnet.ibm.com>\n \n \t* gcc.target/powerpc/vsx-extract-1.c:  Test 0th doubleword"}, {"sha": "522639b8811142b8561bf11df582d00fe5c08d2e", "filename": "gcc/testsuite/gcc.target/powerpc/swaps-p8-13.c", "status": "added", "additions": 53, "deletions": 0, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6bf5ce8f85c50886913d6f26a248f4c4c1445bd2/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fswaps-p8-13.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6bf5ce8f85c50886913d6f26a248f4c4c1445bd2/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fswaps-p8-13.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fswaps-p8-13.c?ref=6bf5ce8f85c50886913d6f26a248f4c4c1445bd2", "patch": "@@ -0,0 +1,53 @@\n+/* { dg-do run { target { powerpc64le-*-* } } } */\n+/* { dg-options \"-mcpu=power8 -O3\" } */\n+\n+#include <altivec.h>\n+void abort ();\n+\n+#define N 4096\n+long long ca[N] __attribute__((aligned(16)));\n+long long cb[N] __attribute__((aligned(16)));\n+long long cc[N] __attribute__((aligned(16)));\n+long long cd[N] __attribute__((aligned(16)));\n+long long x;\n+\n+__attribute__((noinline)) void foo ()\n+{\n+  int i;\n+  vector long long va, vb, vc, vd, tmp;\n+  volatile unsigned long long three = 3;\n+  vector unsigned long long threes = vec_splats (three);\n+  for (i = 0; i < N; i+=2) {\n+    vb = vec_vsx_ld (0, (vector long long *)&cb[i]);\n+    vc = vec_vsx_ld (0, (vector long long *)&cc[i]);\n+    vd = vec_vsx_ld (0, (vector long long *)&cd[i]);\n+    tmp = vec_add (vb, vc);\n+    tmp = vec_sub (tmp, vd);\n+    tmp = vec_sra (tmp, threes);\n+    x = vec_extract (tmp, 0);\n+    vec_vsx_st (tmp, 0, (vector long long *)&ca[i]);\n+  }\n+}\n+\n+__attribute__((noinline)) void init ()\n+{\n+  int i;\n+  for (i = 0; i < N; ++i) {\n+    cb[i] = 3 * i - 2048;\n+    cc[i] = -5 * i + 93;\n+    cd[i] = i + 14;\n+  }\n+}\n+\n+int main ()\n+{\n+  int i;\n+  init ();\n+  foo ();\n+  for (i = 0; i < N; ++i)\n+    if (ca[i] != (-3 * i - 1969) >> 3)\n+      abort ();\n+  if (x != ca[N-1])\n+    abort ();\n+  return 0;\n+}"}, {"sha": "50d1ec4f5b82730d5b495c326fbe056dea056d1e", "filename": "gcc/testsuite/gcc.target/powerpc/swaps-p8-14.c", "status": "added", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6bf5ce8f85c50886913d6f26a248f4c4c1445bd2/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fswaps-p8-14.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6bf5ce8f85c50886913d6f26a248f4c4c1445bd2/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fswaps-p8-14.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fswaps-p8-14.c?ref=6bf5ce8f85c50886913d6f26a248f4c4c1445bd2", "patch": "@@ -0,0 +1,42 @@\n+/* { dg-do compile { target { powerpc64le-*-* } } } */\n+/* { dg-options \"-mcpu=power8 -O3\" } */\n+/* { dg-final { scan-assembler \"lxvd2x\" } } */\n+/* { dg-final { scan-assembler \"stxvd2x\" } } */\n+/* { dg-final { scan-assembler \"stxsdx\" } } */\n+/* { dg-final { scan-assembler-times \"xxpermdi\" 1 } } */\n+\n+/* The only xxpermdi expected is for the vec_splats.  */\n+\n+#include <altivec.h>\n+void abort ();\n+\n+#define N 4096\n+long long ca[N] __attribute__((aligned(16)));\n+long long cb[N] __attribute__((aligned(16)));\n+long long cc[N] __attribute__((aligned(16)));\n+long long cd[N] __attribute__((aligned(16)));\n+long long x;\n+\n+__attribute__((noinline)) void foo ()\n+{\n+  int i;\n+  vector long long va, vb, vc, vd, tmp;\n+  volatile unsigned long long three = 3;\n+  vector unsigned long long threes = vec_splats (three);\n+  for (i = 0; i < N; i+=2) {\n+    vb = vec_vsx_ld (0, (vector long long *)&cb[i]);\n+    vc = vec_vsx_ld (0, (vector long long *)&cc[i]);\n+    vd = vec_vsx_ld (0, (vector long long *)&cd[i]);\n+    tmp = vec_add (vb, vc);\n+    tmp = vec_sub (tmp, vd);\n+    tmp = vec_sra (tmp, threes);\n+    x = vec_extract (tmp, 0);\n+    vec_vsx_st (tmp, 0, (vector long long *)&ca[i]);\n+  }\n+}\n+\n+int main ()\n+{\n+  foo ();\n+  return 0;\n+}"}, {"sha": "3c9296c3783bdd9101f728e4bca796d43b986949", "filename": "gcc/testsuite/gcc.target/powerpc/swaps-p8-15.c", "status": "added", "additions": 49, "deletions": 0, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6bf5ce8f85c50886913d6f26a248f4c4c1445bd2/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fswaps-p8-15.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6bf5ce8f85c50886913d6f26a248f4c4c1445bd2/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fswaps-p8-15.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fswaps-p8-15.c?ref=6bf5ce8f85c50886913d6f26a248f4c4c1445bd2", "patch": "@@ -0,0 +1,49 @@\n+/* { dg-do compile { target { powerpc64le-*-* } } } */\n+/* { dg-options \"-mcpu=power8 -O3\" } */\n+/* { dg-final { scan-assembler \"lxvd2x\" } } */\n+/* { dg-final { scan-assembler \"stxvd2x\" } } */\n+/* { dg-final { scan-assembler \"xxspltw\" } } */\n+/* { dg-final { scan-assembler-not \"xxpermdi\" } } */\n+\n+#include <altivec.h>\n+void abort();\n+\n+typedef struct xx {vector double l; vector double h;} xx;\n+\n+#define N 4096\n+#define M 10000000\n+vector float ca[N][4] = {0};\n+vector float cb[N][4] = {0};\n+vector float cc[N][4] = {0};\n+\n+__attribute__((noinline)) void foo ()\n+{\n+  int i;\n+  for (i = 0; i < N; i++) {\n+    cc[i][0] = vec_mul(vec_splats(cb[i][0][0]), ca[i][0]);\n+    cc[i][0] = vec_madd(cc[i][0],vec_splats(cb[i][0][1]), ca[i][1]);\n+    cc[i][0] = vec_madd(cc[i][0],vec_splats(cb[i][0][2]), ca[i][2]);\n+    cc[i][0] = vec_madd(cc[i][0],vec_splats(cb[i][0][3]), ca[i][3]);\n+\n+    cc[i][1] = vec_mul(vec_splats(cb[i][1][0]), ca[i][0]);\n+    cc[i][1] = vec_madd(cc[i][0],vec_splats(cb[i][1][1]), ca[i][1]);\n+    cc[i][1] = vec_madd(cc[i][0],vec_splats(cb[i][1][2]), ca[i][2]);\n+    cc[i][1] = vec_madd(cc[i][0],vec_splats(cb[i][1][3]), ca[i][3]);\n+    \n+    cc[i][2] = vec_mul(vec_splats(cb[i][2][0]), ca[i][0]);\n+    cc[i][2] = vec_madd(cc[i][0],vec_splats(cb[i][2][1]), ca[i][1]);\n+    cc[i][2] = vec_madd(cc[i][0],vec_splats(cb[i][2][2]), ca[i][2]);\n+    cc[i][2] = vec_madd(cc[i][0],vec_splats(cb[i][2][3]), ca[i][3]);\n+    \n+    cc[i][3] = vec_mul(vec_splats(cb[i][3][0]), ca[i][0]);\n+    cc[i][3] = vec_madd(cc[i][0],vec_splats(cb[i][3][1]), ca[i][1]);\n+    cc[i][3] = vec_madd(cc[i][0],vec_splats(cb[i][3][2]), ca[i][2]);\n+    cc[i][3] = vec_madd(cc[i][0],vec_splats(cb[i][3][3]), ca[i][3]);\n+  }\n+}\n+\n+int main ()\n+{\n+  foo ();\n+  return 0;\n+}"}]}