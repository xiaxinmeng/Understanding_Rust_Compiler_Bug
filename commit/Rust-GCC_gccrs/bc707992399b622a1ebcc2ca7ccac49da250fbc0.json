{"sha": "bc707992399b622a1ebcc2ca7ccac49da250fbc0", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YmM3MDc5OTIzOTliNjIyYTFlYmNjMmNhN2NjYWM0OWRhMjUwZmJjMA==", "commit": {"author": {"name": "John David Anglin", "email": "dave.anglin@nrc-cnrc.gc.ca", "date": "2010-09-08T23:32:06Z"}, "committer": {"name": "John David Anglin", "email": "danglin@gcc.gnu.org", "date": "2010-09-08T23:32:06Z"}, "message": "re PR target/45250 (FAIL: tr1/5_numerical_facilities/special_functions/01_assoc_laguerre/check_nan.cc)\n\n\tPR target/45250\n\t* config/pa/pa.md (nonlocal_goto): Restore hard frame pointer using\n\thard_frame_pointer_rtx instead of virtual_stack_vars_rtx.\n\t(builtin_longjmp): Likewise.\n\t(allocate_stack): Use hard_frame_pointer_rtx instead of\n\tframe_pointer_rtx.\n\t* config/pa/pa-protos.h (pa_initial_elimination_offset): Declare.\n\t* config/pa/pa.c (pa_internal_arg_pointer): Declare.\n\t(pa_can_eliminate): Likewise.\n\t(TARGET_INTERNAL_ARG_POINTER): Define.\n\t(TARGET_CAN_ELIMINATE): Define.\n\t(hppa_expand_prologue): Use hard frame pointer instead of soft frame\n\tpointer.\n\t(hppa_expand_epilogue, pa_eh_return_handler_rtx): Likewise.\n\t(pa_internal_arg_pointer, pa_can_eliminate,\n\tpa_initial_elimination_offset): New.\n\t* config/pa/pa.h (FRAME_POINTER_REGNUM): Set to new general register.\n\t(HARD_FRAME_POINTER_REGNUM): Set to register three.\n\t(INITIAL_FRAME_POINTER_OFFSET): Delete.\n\t(ELIMINABLE_REGS, INITIAL_ELIMINATION_OFFSET, DWARF_FRAME_REGISTERS):\n\tDefine.\n\t(DWARF_ALT_FRAME_RETURN_COLUMN, REGNO_OK_FOR_INDEX_P,\n\tREGNO_OK_FOR_BASE_P): Update to include soft frame pointer.\n\t* config/pa/pa32-regs.h (FIRST_PSEUDO_REGISTER): Increase by one.\n\t(FIXED_REGISTERS, CALL_USED_REGISTERS, REG_ALLOC_ORDER,\n\tREG_CLASS_CONTENTS, REGNO_REG_CLASS, REGISTER_NAMES): Update to include\n\tnew soft frame pointer.\n\t* config/pa/pa64-regs.h: Likewise.\n\nFrom-SVN: r164036", "tree": {"sha": "ec559029d98ecf0e7d227c8916f91d3c8652a9eb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ec559029d98ecf0e7d227c8916f91d3c8652a9eb"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/bc707992399b622a1ebcc2ca7ccac49da250fbc0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bc707992399b622a1ebcc2ca7ccac49da250fbc0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bc707992399b622a1ebcc2ca7ccac49da250fbc0", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bc707992399b622a1ebcc2ca7ccac49da250fbc0/comments", "author": null, "committer": null, "parents": [{"sha": "2824d6e567c61e0fc3351449ff652bdbc7e93e26", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2824d6e567c61e0fc3351449ff652bdbc7e93e26", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2824d6e567c61e0fc3351449ff652bdbc7e93e26"}], "stats": {"total": 239, "additions": 174, "deletions": 65}, "files": [{"sha": "05be760ea2dd0e198fb37c18ec8d2957120278da", "filename": "gcc/ChangeLog", "status": "modified", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc707992399b622a1ebcc2ca7ccac49da250fbc0/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc707992399b622a1ebcc2ca7ccac49da250fbc0/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=bc707992399b622a1ebcc2ca7ccac49da250fbc0", "patch": "@@ -1,3 +1,34 @@\n+2010-09-08  John David Anglin  <dave.anglin@nrc-cnrc.gc.ca>\n+\n+\tPR target/45250\n+\t* config/pa/pa.md (nonlocal_goto): Restore hard frame pointer using\n+\thard_frame_pointer_rtx instead of virtual_stack_vars_rtx.\n+\t(builtin_longjmp): Likewise.\n+\t(allocate_stack): Use hard_frame_pointer_rtx instead of\n+\tframe_pointer_rtx.\n+\t* config/pa/pa-protos.h (pa_initial_elimination_offset): Declare.\n+\t* config/pa/pa.c (pa_internal_arg_pointer): Declare.\n+\t(pa_can_eliminate): Likewise.\n+\t(TARGET_INTERNAL_ARG_POINTER): Define.\n+\t(TARGET_CAN_ELIMINATE): Define.\n+\t(hppa_expand_prologue): Use hard frame pointer instead of soft frame\n+\tpointer.\n+\t(hppa_expand_epilogue, pa_eh_return_handler_rtx): Likewise.\n+\t(pa_internal_arg_pointer, pa_can_eliminate,\n+\tpa_initial_elimination_offset): New.\n+\t* config/pa/pa.h (FRAME_POINTER_REGNUM): Set to new general register.\n+\t(HARD_FRAME_POINTER_REGNUM): Set to register three.\n+\t(INITIAL_FRAME_POINTER_OFFSET): Delete.\n+\t(ELIMINABLE_REGS, INITIAL_ELIMINATION_OFFSET, DWARF_FRAME_REGISTERS):\n+\tDefine.\n+\t(DWARF_ALT_FRAME_RETURN_COLUMN, REGNO_OK_FOR_INDEX_P,\n+\tREGNO_OK_FOR_BASE_P): Update to include soft frame pointer.\n+\t* config/pa/pa32-regs.h (FIRST_PSEUDO_REGISTER): Increase by one.\n+\t(FIXED_REGISTERS, CALL_USED_REGISTERS, REG_ALLOC_ORDER,\n+\tREG_CLASS_CONTENTS, REGNO_REG_CLASS, REGISTER_NAMES): Update to include\n+\tnew soft frame pointer.\n+\t* config/pa/pa64-regs.h: Likewise.\n+\n 2010-09-08  Uros Bizjak  <ubizjak@gmail.com>\n \n \t* config/i386/i386.h (EH_RETURN_DATA_REGNO) Use DX_REG instead of"}, {"sha": "8097c58cdbb4fccee8711e11be5756bbe6cb4ce2", "filename": "gcc/config/pa/pa-protos.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc707992399b622a1ebcc2ca7ccac49da250fbc0/gcc%2Fconfig%2Fpa%2Fpa-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc707992399b622a1ebcc2ca7ccac49da250fbc0/gcc%2Fconfig%2Fpa%2Fpa-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpa%2Fpa-protos.h?ref=bc707992399b622a1ebcc2ca7ccac49da250fbc0", "patch": "@@ -171,6 +171,7 @@ extern void pa_hpux_asm_output_external (FILE *, tree, const char *);\n extern bool pa_cannot_change_mode_class (enum machine_mode, enum machine_mode,\n \t\t\t\t\t enum reg_class);\n extern bool pa_modes_tieable_p (enum machine_mode, enum machine_mode);\n+extern HOST_WIDE_INT pa_initial_elimination_offset (int, int);\n \n extern const int magic_milli[];\n extern int shadd_constant_p (int);"}, {"sha": "754d27adc06184de1eb65e4c2d702bcd1de595cf", "filename": "gcc/config/pa/pa.c", "status": "modified", "additions": 65, "deletions": 14, "changes": 79, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc707992399b622a1ebcc2ca7ccac49da250fbc0/gcc%2Fconfig%2Fpa%2Fpa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc707992399b622a1ebcc2ca7ccac49da250fbc0/gcc%2Fconfig%2Fpa%2Fpa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpa%2Fpa.c?ref=bc707992399b622a1ebcc2ca7ccac49da250fbc0", "patch": "@@ -174,6 +174,8 @@ static void pa_trampoline_init (rtx, tree, rtx);\n static rtx pa_trampoline_adjust_address (rtx);\n static rtx pa_delegitimize_address (rtx);\n static bool pa_print_operand_punct_valid_p (unsigned char);\n+static rtx pa_internal_arg_pointer (void);\n+static bool pa_can_eliminate (const int, const int);\n \n /* The following extra sections are only used for SOM.  */\n static GTY(()) section *som_readonly_data_section;\n@@ -360,6 +362,10 @@ static size_t n_deferred_plabels = 0;\n #define TARGET_TRAMPOLINE_ADJUST_ADDRESS pa_trampoline_adjust_address\n #undef TARGET_DELEGITIMIZE_ADDRESS\n #define TARGET_DELEGITIMIZE_ADDRESS pa_delegitimize_address\n+#undef TARGET_INTERNAL_ARG_POINTER\n+#define TARGET_INTERNAL_ARG_POINTER pa_internal_arg_pointer\n+#undef TARGET_CAN_ELIMINATE\n+#define TARGET_CAN_ELIMINATE pa_can_eliminate\n \n struct gcc_target targetm = TARGET_INITIALIZER;\n \f\n@@ -3762,11 +3768,11 @@ hppa_expand_prologue (void)\n \t     pointer by actual_fsize bytes.  Two versions, first\n \t     handles small (<8k) frames.  The second handles large (>=8k)\n \t     frames.  */\n-\t  insn = emit_move_insn (tmpreg, frame_pointer_rtx);\n+\t  insn = emit_move_insn (tmpreg, hard_frame_pointer_rtx);\n \t  if (DO_FRAME_NOTES)\n \t    RTX_FRAME_RELATED_P (insn) = 1;\n \n-\t  insn = emit_move_insn (frame_pointer_rtx, stack_pointer_rtx);\n+\t  insn = emit_move_insn (hard_frame_pointer_rtx, stack_pointer_rtx);\n \t  if (DO_FRAME_NOTES)\n \t    RTX_FRAME_RELATED_P (insn) = 1;\n \n@@ -3810,7 +3816,7 @@ hppa_expand_prologue (void)\n \t\t\t\t       GEN_INT (TARGET_64BIT ? -8 : -4));\n \n \t      emit_move_insn (gen_rtx_MEM (word_mode, addr),\n-\t\t\t      frame_pointer_rtx);\n+\t\t\t      hard_frame_pointer_rtx);\n \t    }\n \t  else\n \t    emit_insn (gen_blockage ());\n@@ -3853,15 +3859,15 @@ hppa_expand_prologue (void)\n \t      if (regno == INVALID_REGNUM)\n \t\tbreak;\n \n-\t      store_reg (regno, offset, FRAME_POINTER_REGNUM);\n+\t      store_reg (regno, offset, HARD_FRAME_POINTER_REGNUM);\n \t      offset += UNITS_PER_WORD;\n \t    }\n \t}\n \n       for (i = 18; i >= 4; i--)\n \tif (df_regs_ever_live_p (i) && ! call_used_regs[i])\n \t  {\n-\t    store_reg (i, offset, FRAME_POINTER_REGNUM);\n+\t    store_reg (i, offset, HARD_FRAME_POINTER_REGNUM);\n \t    offset += UNITS_PER_WORD;\n \t    gr_saved++;\n \t  }\n@@ -3950,8 +3956,8 @@ hppa_expand_prologue (void)\n \t save area.  */\n       if (frame_pointer_needed)\n \t{\n-\t  set_reg_plus_d (1, FRAME_POINTER_REGNUM, offset, 0);\n-\t  base = frame_pointer_rtx;\n+\t  set_reg_plus_d (1, HARD_FRAME_POINTER_REGNUM, offset, 0);\n+\t  base = hard_frame_pointer_rtx;\n \t}\n       else\n \t{\n@@ -4149,7 +4155,7 @@ hppa_expand_epilogue (void)\n       ret_off = TARGET_64BIT ? -16 : -20;\n       if (frame_pointer_needed)\n \t{\n-\t  load_reg (2, ret_off, FRAME_POINTER_REGNUM);\n+\t  load_reg (2, ret_off, HARD_FRAME_POINTER_REGNUM);\n \t  ret_off = 0;\n \t}\n       else\n@@ -4180,15 +4186,15 @@ hppa_expand_epilogue (void)\n \t      if (regno == INVALID_REGNUM)\n \t\tbreak;\n \n-\t      load_reg (regno, offset, FRAME_POINTER_REGNUM);\n+\t      load_reg (regno, offset, HARD_FRAME_POINTER_REGNUM);\n \t      offset += UNITS_PER_WORD;\n \t    }\n \t}\n \n       for (i = 18; i >= 4; i--)\n \tif (df_regs_ever_live_p (i) && ! call_used_regs[i])\n \t  {\n-\t    load_reg (i, offset, FRAME_POINTER_REGNUM);\n+\t    load_reg (i, offset, HARD_FRAME_POINTER_REGNUM);\n \t    offset += UNITS_PER_WORD;\n \t  }\n     }\n@@ -4247,7 +4253,7 @@ hppa_expand_epilogue (void)\n     {\n       /* Adjust the register to index off of.  */\n       if (frame_pointer_needed)\n-\tset_reg_plus_d (1, FRAME_POINTER_REGNUM, offset, 0);\n+\tset_reg_plus_d (1, HARD_FRAME_POINTER_REGNUM, offset, 0);\n       else\n \tset_reg_plus_d (1, STACK_POINTER_REGNUM, offset, 0);\n \n@@ -4275,8 +4281,9 @@ hppa_expand_epilogue (void)\n     {\n       rtx delta = GEN_INT (-64);\n \n-      set_reg_plus_d (STACK_POINTER_REGNUM, FRAME_POINTER_REGNUM, 64, 0);\n-      emit_insn (gen_pre_load (frame_pointer_rtx, stack_pointer_rtx, delta));\n+      set_reg_plus_d (STACK_POINTER_REGNUM, HARD_FRAME_POINTER_REGNUM, 64, 0);\n+      emit_insn (gen_pre_load (hard_frame_pointer_rtx,\n+\t\t\t       stack_pointer_rtx, delta));\n     }\n   /* If we were deferring a callee register restore, do it now.  */\n   else if (merge_sp_adjust_with_load)\n@@ -5920,7 +5927,7 @@ pa_eh_return_handler_rtx (void)\n {\n   rtx tmp;\n \n-  tmp = gen_rtx_PLUS (word_mode, frame_pointer_rtx,\n+  tmp = gen_rtx_PLUS (word_mode, hard_frame_pointer_rtx,\n \t\t      TARGET_64BIT ? GEN_INT (-16) : GEN_INT (-20));\n   tmp = gen_rtx_MEM (word_mode, tmp);\n   tmp->volatil = 1;\n@@ -10100,4 +10107,48 @@ pa_delegitimize_address (rtx orig_x)\n   return x;\n }\n \f\n+static rtx\n+pa_internal_arg_pointer (void)\n+{\n+  /* The argument pointer and the hard frame pointer are the same in\n+     the 32-bit runtime, so we don't need a copy.  */\n+  if (TARGET_64BIT)\n+    return copy_to_reg (virtual_incoming_args_rtx);\n+  else\n+    return virtual_incoming_args_rtx;\n+}\n+\n+/* Given FROM and TO register numbers, say whether this elimination is allowed.\n+   Frame pointer elimination is automatically handled.  */\n+\n+static bool\n+pa_can_eliminate (const int from, const int to)\n+{\n+  /* The argument cannot be eliminated in the 64-bit runtime.  */\n+  if (TARGET_64BIT && from == ARG_POINTER_REGNUM)\n+    return false;\n+\n+  return (from == HARD_FRAME_POINTER_REGNUM && to == STACK_POINTER_REGNUM\n+          ? ! frame_pointer_needed\n+          : true);\n+}\n+\n+/* Define the offset between two registers, FROM to be eliminated and its\n+   replacement TO, at the start of a routine.  */\n+HOST_WIDE_INT\n+pa_initial_elimination_offset (int from, int to)\n+{\n+  HOST_WIDE_INT offset;\n+\n+  if ((from == HARD_FRAME_POINTER_REGNUM || from == FRAME_POINTER_REGNUM)\n+      && to == STACK_POINTER_REGNUM)\n+    offset = -compute_frame_size (get_frame_size (), 0);\n+  else if (from == FRAME_POINTER_REGNUM && to == HARD_FRAME_POINTER_REGNUM)\n+    offset = 0;\n+  else\n+    gcc_unreachable ();\n+\n+  return offset;\n+}\n+\n #include \"gt-pa.h\""}, {"sha": "ae768b2ed9725b707a39606b9535b2c0c008a2ff", "filename": "gcc/config/pa/pa.h", "status": "modified", "additions": 44, "deletions": 15, "changes": 59, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc707992399b622a1ebcc2ca7ccac49da250fbc0/gcc%2Fconfig%2Fpa%2Fpa.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc707992399b622a1ebcc2ca7ccac49da250fbc0/gcc%2Fconfig%2Fpa%2Fpa.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpa%2Fpa.h?ref=bc707992399b622a1ebcc2ca7ccac49da250fbc0", "patch": "@@ -344,24 +344,18 @@ typedef struct GTY(()) machine_function\n /* Register to use for pushing function arguments.  */\n #define STACK_POINTER_REGNUM 30\n \n+/* Fixed register for local variable access.  Always eliminated.  */\n+#define FRAME_POINTER_REGNUM (TARGET_64BIT ? 61 : 89)\n+\n /* Base register for access to local variables of the function.  */\n-#define FRAME_POINTER_REGNUM 3\n+#define HARD_FRAME_POINTER_REGNUM 3\n \n /* Don't allow hard registers to be renamed into r2 unless r2\n    is already live or already being saved (due to eh).  */\n \n #define HARD_REGNO_RENAME_OK(OLD_REG, NEW_REG) \\\n   ((NEW_REG) != 2 || df_regs_ever_live_p (2) || crtl->calls_eh_return)\n \n-/* C statement to store the difference between the frame pointer\n-   and the stack pointer values immediately after the function prologue.\n-\n-   Note, we always pretend that this is a leaf function because if\n-   it's not, there's no point in trying to eliminate the\n-   frame pointer.  If it is a leaf function, we guessed right!  */\n-#define INITIAL_FRAME_POINTER_OFFSET(VAR) \\\n-  do {(VAR) = - compute_frame_size (get_frame_size (), 0);} while (0)\n-\n /* Base register for access to arguments of the function.  */\n #define ARG_POINTER_REGNUM (TARGET_64BIT ? 29 : 3)\n \n@@ -385,6 +379,31 @@ extern struct rtx_def *hppa_pic_save_rtx (void);\n    is passed to a function.  */\n #define PA_STRUCT_VALUE_REGNUM 28\n \n+/* Definitions for register eliminations.\n+\n+   We have two registers that can be eliminated.  First, the frame pointer\n+   register can often be eliminated in favor of the stack pointer register.\n+   Secondly, the argument pointer register can always be eliminated in the\n+   32-bit runtimes.  */\n+\n+/* This is an array of structures.  Each structure initializes one pair\n+   of eliminable registers.  The \"from\" register number is given first,\n+   followed by \"to\".  Eliminations of the same \"from\" register are listed\n+   in order of preference.\n+\n+   The argument pointer cannot be eliminated in the 64-bit runtime.  It\n+   is the same register as the hard frame pointer in the 32-bit runtime.\n+   So, it does not need to be listed.  */\n+#define ELIMINABLE_REGS                                 \\\n+{{ HARD_FRAME_POINTER_REGNUM, STACK_POINTER_REGNUM},    \\\n+ { FRAME_POINTER_REGNUM, STACK_POINTER_REGNUM},         \\\n+ { FRAME_POINTER_REGNUM, HARD_FRAME_POINTER_REGNUM} }\n+\n+/* Define the offset between two registers, one to be eliminated,\n+   and the other its replacement, at the start of a routine.  */\n+#define INITIAL_ELIMINATION_OFFSET(FROM, TO, OFFSET) \\\n+  ((OFFSET) = pa_initial_elimination_offset(FROM, TO))\n+\n /* Describe how we implement __builtin_eh_return.  */\n #define EH_RETURN_DATA_REGNO(N)\t\\\n   ((N) < 3 ? (N) + 20 : (N) == 3 ? 31 : INVALID_REGNUM)\n@@ -394,6 +413,10 @@ extern struct rtx_def *hppa_pic_save_rtx (void);\n /* Offset from the frame pointer register value to the top of stack.  */\n #define FRAME_POINTER_CFA_OFFSET(FNDECL) 0\n \n+/* The maximum number of hard registers that can be saved in the call\n+   frame.  The soft frame pointer is not included.  */\n+#define DWARF_FRAME_REGISTERS (FIRST_PSEUDO_REGISTER - 1)\n+\n /* A C expression whose value is RTL representing the location of the\n    incoming return address at the beginning of any function, before the\n    prologue.  You only need to define this macro if you want to support\n@@ -408,7 +431,7 @@ extern struct rtx_def *hppa_pic_save_rtx (void);\n \n    Column 0 is not used but unfortunately its register size is set to\n    4 bytes (sizeof CCmode) so it can't be used on 64-bit targets.  */\n-#define DWARF_ALT_FRAME_RETURN_COLUMN FIRST_PSEUDO_REGISTER\n+#define DWARF_ALT_FRAME_RETURN_COLUMN (FIRST_PSEUDO_REGISTER - 1)\n \n /* This macro chooses the encoding of pointers embedded in the exception\n    handling sections.  If at all possible, this should be defined such\n@@ -777,12 +800,14 @@ extern int may_call_alloca;\n \n #define REGNO_OK_FOR_INDEX_P(X) \\\n   ((X) && ((X) < 32\t\t\t\t\t\t\t\\\n-   || (X >= FIRST_PSEUDO_REGISTER\t\t\t\t\t\\\n+   || ((X) == FRAME_POINTER_REGNUM)\t\t\t\t\t\\\n+   || ((X) >= FIRST_PSEUDO_REGISTER\t\t\t\t\t\\\n        && reg_renumber\t\t\t\t\t\t\t\\\n        && (unsigned) reg_renumber[X] < 32)))\n #define REGNO_OK_FOR_BASE_P(X) \\\n   ((X) && ((X) < 32\t\t\t\t\t\t\t\\\n-   || (X >= FIRST_PSEUDO_REGISTER\t\t\t\t\t\\\n+   || ((X) == FRAME_POINTER_REGNUM)\t\t\t\t\t\\\n+   || ((X) >= FIRST_PSEUDO_REGISTER\t\t\t\t\t\\\n        && reg_renumber\t\t\t\t\t\t\t\\\n        && (unsigned) reg_renumber[X] < 32)))\n #define REGNO_OK_FOR_FP_P(X) \\\n@@ -931,12 +956,16 @@ extern int may_call_alloca;\n /* Nonzero if X is a hard reg that can be used as an index\n    or if it is a pseudo reg.  */\n #define REG_OK_FOR_INDEX_P(X) \\\n-  (REGNO (X) && (REGNO (X) < 32 || REGNO (X) >= FIRST_PSEUDO_REGISTER))\n+  (REGNO (X) && (REGNO (X) < 32 \t\t\t\t\\\n+   || REGNO (X) == FRAME_POINTER_REGNUM\t\t\t\t\\\n+   || REGNO (X) >= FIRST_PSEUDO_REGISTER))\n \n /* Nonzero if X is a hard reg that can be used as a base reg\n    or if it is a pseudo reg.  */\n #define REG_OK_FOR_BASE_P(X) \\\n-  (REGNO (X) && (REGNO (X) < 32 || REGNO (X) >= FIRST_PSEUDO_REGISTER))\n+  (REGNO (X) && (REGNO (X) < 32 \t\t\t\t\\\n+   || REGNO (X) == FRAME_POINTER_REGNUM\t\t\t\t\\\n+   || REGNO (X) >= FIRST_PSEUDO_REGISTER))\n \n #else\n "}, {"sha": "a68989f4fdc3a1d2a391382d186b7a415c9b4a38", "filename": "gcc/config/pa/pa.md", "status": "modified", "additions": 7, "deletions": 12, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc707992399b622a1ebcc2ca7ccac49da250fbc0/gcc%2Fconfig%2Fpa%2Fpa.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc707992399b622a1ebcc2ca7ccac49da250fbc0/gcc%2Fconfig%2Fpa%2Fpa.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpa%2Fpa.md?ref=bc707992399b622a1ebcc2ca7ccac49da250fbc0", "patch": "@@ -7073,10 +7073,10 @@\n   /* Restore the frame pointer.  The virtual_stack_vars_rtx is saved\n      instead of the hard_frame_pointer_rtx in the save area.  As a\n      result, an extra instruction is needed to adjust for the offset\n-     of the virtual stack variables and the frame pointer.  */\n+     of the virtual stack variables and the hard frame pointer.  */\n   if (GET_CODE (fp) != REG)\n     fp = force_reg (Pmode, fp);\n-  emit_move_insn (virtual_stack_vars_rtx, fp);\n+  emit_move_insn (hard_frame_pointer_rtx, plus_constant (fp, -8));\n \n   emit_stack_restore (SAVE_NONLOCAL, stack, NULL_RTX);\n \n@@ -8517,15 +8517,10 @@ add,l %2,%3,%3\\;bv,n %%r0(%3)\"\n \n   /* Restore the frame pointer.  The virtual_stack_vars_rtx is saved\n      instead of the hard_frame_pointer_rtx in the save area.  We need\n-     to adjust for the offset between these two values when we have\n-     a nonlocal_goto pattern.  When we don't have a nonlocal_goto\n-     pattern, the receiver performs the adjustment.  */\n-#ifdef HAVE_nonlocal_goto\n-  if (HAVE_nonlocal_goto)\n-    emit_move_insn (virtual_stack_vars_rtx, force_reg (Pmode, fp));\n-  else\n-#endif\n-    emit_move_insn (hard_frame_pointer_rtx, fp);\n+     to adjust for the offset between these two values.  */\n+  if (GET_CODE (fp) != REG)\n+    fp = force_reg (Pmode, fp);\n+  emit_move_insn (hard_frame_pointer_rtx, plus_constant (fp, -8));\n \n   /* This bit is the same as expand_builtin_longjmp.  */\n   emit_stack_restore (SAVE_NONLOCAL, stack, NULL_RTX);\n@@ -9528,7 +9523,7 @@ add,l %2,%3,%3\\;bv,n %%r0(%3)\"\n     {\n       addr = gen_rtx_PLUS (word_mode, stack_pointer_rtx,\n \t\t\t   GEN_INT (TARGET_64BIT ? -8 : -4));\n-      emit_move_insn (gen_rtx_MEM (word_mode, addr), frame_pointer_rtx);\n+      emit_move_insn (gen_rtx_MEM (word_mode, addr), hard_frame_pointer_rtx);\n     }\n   if (!TARGET_64BIT && flag_pic)\n     {"}, {"sha": "21aa71940a20d50e813605ca1e3249c320e926f0", "filename": "gcc/config/pa/pa32-regs.h", "status": "modified", "additions": 13, "deletions": 11, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc707992399b622a1ebcc2ca7ccac49da250fbc0/gcc%2Fconfig%2Fpa%2Fpa32-regs.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc707992399b622a1ebcc2ca7ccac49da250fbc0/gcc%2Fconfig%2Fpa%2Fpa32-regs.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpa%2Fpa32-regs.h?ref=bc707992399b622a1ebcc2ca7ccac49da250fbc0", "patch": "@@ -1,5 +1,5 @@\n /* Copyright (C) 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007,\n-   2008 Free Software Foundation, Inc.\n+   2008, 2010 Free Software Foundation, Inc.\n \n This file is part of GCC.\n \n@@ -43,8 +43,8 @@ see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n    has different fp units: define separate register sets for the 1.0\n    and 1.1 fp units.  */\n \n-#define FIRST_PSEUDO_REGISTER 89  /* 32 general regs + 56 fp regs +\n-\t\t\t\t     + 1 shift reg */\n+#define FIRST_PSEUDO_REGISTER 90  /* 32 general regs + 56 fp regs +\n+\t\t\t\t     + 1 shift reg + frame pointer */\n \n /* 1 for registers that have pervasive standard uses\n    and are not available for the register allocator.\n@@ -96,7 +96,8 @@ see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n   0, 0, 0, 0, 0, 0, 0, 0, \\\n   0, 0, 0, 0, 0, 0, 0, 0, \\\n   0, 0, 0, 0, 0, 0, 0, 0, \\\n-  0}\n+  /* shift register and soft frame pointer */ \\\n+  0, 1}\n \n /* 1 for registers not available across function calls.\n    These must include the FIXED_REGISTERS and also any\n@@ -117,7 +118,8 @@ see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n   0, 0, 0, 0, 1, 1, 1, 1, \\\n   1, 1, 1, 1, 1, 1, 1, 1, \\\n   1, 1, 1, 1, 1, 1, 1, 1, \\\n-  1}\n+  /* shift register and soft frame pointer */ \\\n+  1, 1}\n \n #define CONDITIONAL_REGISTER_USAGE \\\n {\t\t\t\t\t\t\\\n@@ -172,7 +174,7 @@ see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n    3,  4,  5,  6,  7,  8,  9, 10, \t\\\n   11, 12, 13, 14, 15, 16, 17, 18,\t\\\n   /* special registers.  */\t\t\\\n-   1, 30,  0, 88}\n+   1, 30,  0, 88, 89}\n \n \n /* Return number of consecutive hard regs needed starting at reg REGNO\n@@ -304,12 +306,12 @@ enum reg_class { NO_REGS, R1_REGS, GENERAL_REGS, FPUPPER_REGS, FP_REGS,\n #define REG_CLASS_CONTENTS\t\\\n  {{0x00000000, 0x00000000, 0x00000000},\t/* NO_REGS */\t\t\t\\\n   {0x00000002, 0x00000000, 0x00000000},\t/* R1_REGS */\t\t\t\\\n-  {0xfffffffe, 0x00000000, 0x00000000},\t/* GENERAL_REGS */\t\t\\\n+  {0xfffffffe, 0x00000000, 0x02000000},\t/* GENERAL_REGS */\t\t\\\n   {0x00000000, 0xff000000, 0x00ffffff},\t/* FPUPPER_REGS */\t\t\\\n   {0x00000000, 0xffffffff, 0x00ffffff},\t/* FP_REGS */\t\t\t\\\n-  {0xfffffffe, 0xffffffff, 0x00ffffff},\t/* GENERAL_OR_FP_REGS */\t\\\n+  {0xfffffffe, 0xffffffff, 0x02ffffff},\t/* GENERAL_OR_FP_REGS */\t\\\n   {0x00000000, 0x00000000, 0x01000000},\t/* SHIFT_REGS */\t\t\\\n-  {0xfffffffe, 0xffffffff, 0x01ffffff}}\t/* ALL_REGS */\n+  {0xfffffffe, 0xffffffff, 0x03ffffff}}\t/* ALL_REGS */\n \n /* The following macro defines cover classes for Integrated Register\n    Allocator.  Cover classes is a set of non-intersected register\n@@ -336,7 +338,7 @@ enum reg_class { NO_REGS, R1_REGS, GENERAL_REGS, FPUPPER_REGS, FP_REGS,\n #define REGNO_REG_CLASS(REGNO)\t\t\t\t\t\t\\\n   ((REGNO) == 0 ? NO_REGS \t\t\t\t\t\t\\\n    : (REGNO) == 1 ? R1_REGS\t\t\t\t\t\t\\\n-   : (REGNO) < 32 ? GENERAL_REGS\t\t\t\t\t\\\n+   : (REGNO) < 32 || (REGNO) == 89 ? GENERAL_REGS\t\t\t\\\n    : (REGNO) < 56 ? FP_REGS\t\t\t\t\t\t\\\n    : (REGNO) < 88 ? FPUPPER_REGS\t\t\t\t\t\\\n    : SHIFT_REGS)\n@@ -370,7 +372,7 @@ enum reg_class { NO_REGS, R1_REGS, GENERAL_REGS, FPUPPER_REGS, FP_REGS,\n  \"%fr20\", \"%fr20R\", \"%fr21\", \"%fr21R\", \"%fr22\", \"%fr22R\", \"%fr23\", \"%fr23R\", \\\n  \"%fr24\", \"%fr24R\", \"%fr25\", \"%fr25R\", \"%fr26\", \"%fr26R\", \"%fr27\", \"%fr27R\", \\\n  \"%fr28\", \"%fr28R\", \"%fr29\", \"%fr29R\", \"%fr30\", \"%fr30R\", \"%fr31\", \"%fr31R\", \\\n- \"SAR\"}\n+ \"SAR\",   \"sfp\"}\n \n #define ADDITIONAL_REGISTER_NAMES \\\n {{\"%fr4L\",32}, {\"%fr5L\",34}, {\"%fr6L\",36}, {\"%fr7L\",38},\t\t\\"}, {"sha": "32e2fa2e677581894bb2fe1adf32f605e3080cef", "filename": "gcc/config/pa/pa64-regs.h", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc707992399b622a1ebcc2ca7ccac49da250fbc0/gcc%2Fconfig%2Fpa%2Fpa64-regs.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc707992399b622a1ebcc2ca7ccac49da250fbc0/gcc%2Fconfig%2Fpa%2Fpa64-regs.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpa%2Fpa64-regs.h?ref=bc707992399b622a1ebcc2ca7ccac49da250fbc0", "patch": "@@ -1,5 +1,5 @@\n /* Configuration for GCC-compiler for PA-RISC.\n-   Copyright (C) 1999, 2000, 2003, 2004, 2007, 2008\n+   Copyright (C) 1999, 2000, 2003, 2004, 2007, 2008, 2010\n    Free Software Foundation, Inc.\n \n This file is part of GCC.\n@@ -38,8 +38,8 @@ along with GCC; see the file COPYING3.  If not see\n    issue as using the halves independently triggers false dependency stalls\n    anyway.  */\n \n-#define FIRST_PSEUDO_REGISTER 61  /* 32 general regs + 28 fp regs +\n-\t\t\t\t     + 1 shift reg */\n+#define FIRST_PSEUDO_REGISTER 62  /* 32 general regs + 28 fp regs +\n+\t\t\t\t     + 1 shift reg + frame pointer */\n \n /* 1 for registers that have pervasive standard uses\n    and are not available for the register allocator.\n@@ -79,8 +79,8 @@ along with GCC; see the file COPYING3.  If not see\n   0, 0, 0, 0, 0, 0, 0, 0, \\\n   0, 0, 0, 0, 0, 0, 0, 0, \\\n   0, 0, 0, 0,\t\t  \\\n-  /* shift register */\t  \\\n-  0}\n+  /* shift register and soft frame pointer */\t  \\\n+  0, 1}\n \n /* 1 for registers not available across function calls.\n    These must include the FIXED_REGISTERS and also any\n@@ -98,8 +98,8 @@ along with GCC; see the file COPYING3.  If not see\n   0, 0, 0, 0, 0, 0, 0, 0, \\\n   0, 0, 1, 1, 1, 1, 1, 1, \\\n   1, 1, 1, 1, \t\t  \\\n-  /* shift register */    \\\n-  1}\n+  /* shift register and soft frame pointer */    \\\n+  1, 1}\n \n #define CONDITIONAL_REGISTER_USAGE \\\n {\t\t\t\t\t\t\\\n@@ -137,7 +137,7 @@ along with GCC; see the file COPYING3.  If not see\n    3,  4,  5,  6,  7,  8,  9, 10, \t\\\n   11, 12, 13, 14, 15, 16, 17, 18,\t\\\n   /* special registers.  */\t\t\\\n-   1, 27, 30,  0, 60}\n+   1, 27, 30,  0, 60, 61}\n \n \n /* Return number of consecutive hard regs needed starting at reg REGNO\n@@ -235,12 +235,12 @@ enum reg_class { NO_REGS, R1_REGS, GENERAL_REGS, FPUPPER_REGS, FP_REGS,\n #define REG_CLASS_CONTENTS\t\\\n  {{0x00000000, 0x00000000},\t/* NO_REGS */\t\t\t\\\n   {0x00000002, 0x00000000},\t/* R1_REGS */\t\t\t\\\n-  {0xfffffffe, 0x00000000},\t/* GENERAL_REGS */\t\t\\\n+  {0xfffffffe, 0x20000000},\t/* GENERAL_REGS */\t\t\\\n   {0x00000000, 0x00000000},\t/* FPUPPER_REGS */\t\t\\\n   {0x00000000, 0x0fffffff},\t/* FP_REGS */\t\t\t\\\n-  {0xfffffffe, 0x0fffffff},\t/* GENERAL_OR_FP_REGS */\t\\\n+  {0xfffffffe, 0x2fffffff},\t/* GENERAL_OR_FP_REGS */\t\\\n   {0x00000000, 0x10000000},\t/* SHIFT_REGS */\t\t\\\n-  {0xfffffffe, 0x1fffffff}}\t/* ALL_REGS */\n+  {0xfffffffe, 0x3fffffff}}\t/* ALL_REGS */\n \n /* The following macro defines cover classes for Integrated Register\n    Allocator.  Cover classes is a set of non-intersected register\n@@ -267,7 +267,7 @@ enum reg_class { NO_REGS, R1_REGS, GENERAL_REGS, FPUPPER_REGS, FP_REGS,\n #define REGNO_REG_CLASS(REGNO)\t\t\t\t\t\t\\\n   ((REGNO) == 0 ? NO_REGS \t\t\t\t\t\t\\\n    : (REGNO) == 1 ? R1_REGS\t\t\t\t\t\t\\\n-   : (REGNO) < 32 ? GENERAL_REGS\t\t\t\t\t\\\n+   : (REGNO) < 32 || (REGNO) == 61 ? GENERAL_REGS\t\t\t\\\n    : (REGNO) < 60 ? FP_REGS\t\t\t\t\t\t\\\n    : SHIFT_REGS)\n \n@@ -293,7 +293,7 @@ enum reg_class { NO_REGS, R1_REGS, GENERAL_REGS, FPUPPER_REGS, FP_REGS,\n  \"%fr4\",  \"%fr5\",   \"%fr6\",  \"%fr7\",   \"%fr8\",  \"%fr9\",   \"%fr10\", \"%fr11\",  \\\n  \"%fr12\", \"%fr13\",  \"%fr14\", \"%fr15\",  \"%fr16\", \"%fr17\",  \"%fr18\", \"%fr19\",  \\\n  \"%fr20\", \"%fr21\",  \"%fr22\", \"%fr23\",  \"%fr24\", \"%fr25\",  \"%fr26\", \"%fr27\",  \\\n- \"%fr28\", \"%fr29\",  \"%fr30\", \"%fr31\", \"SAR\"}\n+ \"%fr28\", \"%fr29\",  \"%fr30\", \"%fr31\",  \"SAR\",   \"sfp\"}\n \n #define ADDITIONAL_REGISTER_NAMES \\\n  {{\"%cr11\",60}}"}]}