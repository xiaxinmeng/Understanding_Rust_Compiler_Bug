{"sha": "b0186f718a778b98e1c77a8279a10d79e2d83b8d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjAxODZmNzE4YTc3OGI5OGUxYzc3YTgyNzlhMTBkNzllMmQ4M2I4ZA==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2011-08-02T07:53:29Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2011-08-02T07:53:29Z"}, "message": "[multiple changes]\n\n2011-08-02  Robert Dewar  <dewar@adacore.com>\n\n\t* exp_util.adb, par-ch10.adb, par-ch6.adb, sem.adb, sem_ch6.adb,\n\tsem_ch6.ads, sinfo.adb, sinfo.ads, sprint.adb: Change parameterized\n\texpression to expression function.\n\n2011-08-02  Ed Schonberg  <schonberg@adacore.com>\n\n\t* sem_ch4.adb: transform simple Ada2012 membership into equality only\n\tif types are compatible.\n\n2011-08-02  Yannick Moy  <moy@adacore.com>\n\n\t* sem_res.adb (Matching_Static_Array_Bounds): new function which\n\treturns True if its argument array types have same dimension and same\n\tstatic bounds at each index.\n\t(Resolve_Actuals): issue an error in formal mode on actuals passed as\n\tOUT or IN OUT paramaters which are not view conversions in SPARK.\n\t(Resolve_Arithmetic_Op): issue an error in formal mode on\n\tmultiplication or division with operands of fixed point types which are\n\tnot qualified or explicitly converted.\n\t(Resolve_Comparison_Op): issue an error in formal mode on comparisons of\n\tBoolean or array type (except String) operands.\n\t(Resolve_Equality_Op): issue an error in formal mode on equality\n\toperators for array types other than String with non-matching static\n\tbounds.\n\t(Resolve_Logical_Op): issue an error in formal mode on logical operators\n\tfor array types with non-matching static bounds. Factorize the code in\n\tMatching_Static_Array_Bounds.\n\t(Resolve_Qualified_Expression): issue an error in formal mode on\n\tqualified expressions for array types with non-matching static bounds.\n\t(Resolve_Type_Conversion): issue an error in formal mode on type\n\tconversion for array types with non-matching static bounds\n\nFrom-SVN: r177089", "tree": {"sha": "3e21c7b70b04eee27ee374a0f5c03b3d7ce795b3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/3e21c7b70b04eee27ee374a0f5c03b3d7ce795b3"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b0186f718a778b98e1c77a8279a10d79e2d83b8d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b0186f718a778b98e1c77a8279a10d79e2d83b8d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b0186f718a778b98e1c77a8279a10d79e2d83b8d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b0186f718a778b98e1c77a8279a10d79e2d83b8d/comments", "author": null, "committer": null, "parents": [{"sha": "767bb4e896d51ddb4aa6b44663f52f8be9d0f052", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/767bb4e896d51ddb4aa6b44663f52f8be9d0f052", "html_url": "https://github.com/Rust-GCC/gccrs/commit/767bb4e896d51ddb4aa6b44663f52f8be9d0f052"}], "stats": {"total": 756, "additions": 461, "deletions": 295}, "files": [{"sha": "b7a2c5e4abdf2f388ca896a37d3d757f6091a6cc", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b0186f718a778b98e1c77a8279a10d79e2d83b8d/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b0186f718a778b98e1c77a8279a10d79e2d83b8d/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=b0186f718a778b98e1c77a8279a10d79e2d83b8d", "patch": "@@ -1,3 +1,37 @@\n+2011-08-02  Robert Dewar  <dewar@adacore.com>\n+\n+\t* exp_util.adb, par-ch10.adb, par-ch6.adb, sem.adb, sem_ch6.adb,\n+\tsem_ch6.ads, sinfo.adb, sinfo.ads, sprint.adb: Change parameterized\n+\texpression to expression function.\n+\n+2011-08-02  Ed Schonberg  <schonberg@adacore.com>\n+\n+\t* sem_ch4.adb: transform simple Ada2012 membership into equality only\n+\tif types are compatible.\n+\n+2011-08-02  Yannick Moy  <moy@adacore.com>\n+\n+\t* sem_res.adb (Matching_Static_Array_Bounds): new function which\n+\treturns True if its argument array types have same dimension and same\n+\tstatic bounds at each index.\n+\t(Resolve_Actuals): issue an error in formal mode on actuals passed as\n+\tOUT or IN OUT paramaters which are not view conversions in SPARK.\n+\t(Resolve_Arithmetic_Op): issue an error in formal mode on\n+\tmultiplication or division with operands of fixed point types which are\n+\tnot qualified or explicitly converted.\n+\t(Resolve_Comparison_Op): issue an error in formal mode on comparisons of\n+\tBoolean or array type (except String) operands.\n+\t(Resolve_Equality_Op): issue an error in formal mode on equality\n+\toperators for array types other than String with non-matching static\n+\tbounds.\n+\t(Resolve_Logical_Op): issue an error in formal mode on logical operators\n+\tfor array types with non-matching static bounds. Factorize the code in\n+\tMatching_Static_Array_Bounds.\n+\t(Resolve_Qualified_Expression): issue an error in formal mode on\n+\tqualified expressions for array types with non-matching static bounds.\n+\t(Resolve_Type_Conversion): issue an error in formal mode on type\n+\tconversion for array types with non-matching static bounds\n+\n 2011-08-02  Robert Dewar  <dewar@adacore.com>\n \n \t* par-ch10.adb: Minor code reorganization (use Nkind_In)."}, {"sha": "03e41c91441745472d5f835d6b62b1577c321543", "filename": "gcc/ada/exp_util.adb", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b0186f718a778b98e1c77a8279a10d79e2d83b8d/gcc%2Fada%2Fexp_util.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b0186f718a778b98e1c77a8279a10d79e2d83b8d/gcc%2Fada%2Fexp_util.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_util.adb?ref=b0186f718a778b98e1c77a8279a10d79e2d83b8d", "patch": "@@ -2592,6 +2592,7 @@ package body Exp_Util is\n                N_Entry_Body                             |\n                N_Exception_Declaration                  |\n                N_Exception_Renaming_Declaration         |\n+               N_Expression_Function                    |\n                N_Formal_Abstract_Subprogram_Declaration |\n                N_Formal_Concrete_Subprogram_Declaration |\n                N_Formal_Object_Declaration              |\n@@ -2613,7 +2614,6 @@ package body Exp_Util is\n                N_Package_Declaration                    |\n                N_Package_Instantiation                  |\n                N_Package_Renaming_Declaration           |\n-               N_Parameterized_Expression               |\n                N_Private_Extension_Declaration          |\n                N_Private_Type_Declaration               |\n                N_Procedure_Instantiation                |"}, {"sha": "08553dd037658d462dd9649d194123c3cc89e817", "filename": "gcc/ada/par-ch10.adb", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b0186f718a778b98e1c77a8279a10d79e2d83b8d/gcc%2Fada%2Fpar-ch10.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b0186f718a778b98e1c77a8279a10d79e2d83b8d/gcc%2Fada%2Fpar-ch10.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fpar-ch10.adb?ref=b0186f718a778b98e1c77a8279a10d79e2d83b8d", "patch": "@@ -562,9 +562,9 @@ package body Ch10 is\n          then\n             Name_Node := Defining_Unit_Name (Unit_Node);\n \n-         elsif Nkind (Unit_Node) = N_Parameterized_Expression then\n+         elsif Nkind (Unit_Node) = N_Expression_Function then\n             Error_Msg_SP\n-              (\"parameterized expression cannot be used as compilation unit\");\n+              (\"expression function cannot be used as compilation unit\");\n             return Comp_Unit_Node;\n \n          --  Anything else is a serious error, abandon scan"}, {"sha": "fae8304f41019435f0349c9088c31da789f6bc33", "filename": "gcc/ada/par-ch6.adb", "status": "modified", "additions": 34, "deletions": 35, "changes": 69, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b0186f718a778b98e1c77a8279a10d79e2d83b8d/gcc%2Fada%2Fpar-ch6.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b0186f718a778b98e1c77a8279a10d79e2d83b8d/gcc%2Fada%2Fpar-ch6.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fpar-ch6.adb?ref=b0186f718a778b98e1c77a8279a10d79e2d83b8d", "patch": "@@ -82,7 +82,7 @@ package body Ch6 is\n \n    --  This routine scans out a subprogram declaration, subprogram body,\n    --  subprogram renaming declaration or subprogram generic instantiation.\n-   --  It also handles the new Ada 2012 parameterized expression form\n+   --  It also handles the new Ada 2012 expression function form\n \n    --  SUBPROGRAM_DECLARATION ::=\n    --    SUBPROGRAM_SPECIFICATION\n@@ -126,7 +126,7 @@ package body Ch6 is\n    --  is classified as a basic declarative item, but it is parsed here, with\n    --  other subprogram constructs.\n \n-   --  PARAMETERIZED_EXPRESSION ::=\n+   --  EXPRESSION_FUNCTION ::=\n    --    FUNCTION SPECIFICATION IS (EXPRESSION);\n \n    --  The value in Pf_Flags indicates which of these possible declarations\n@@ -137,7 +137,7 @@ package body Ch6 is\n    --    Pf_Flags.Pbod                 Set if proper body OK\n    --    Pf_Flags.Rnam                 Set if renaming declaration OK\n    --    Pf_Flags.Stub                 Set if body stub OK\n-   --    Pf_Flags.Pexp                 Set if parameterized expression OK\n+   --    Pf_Flags.Pexp                 Set if expression function OK\n \n    --  If an inappropriate form is encountered, it is scanned out but an\n    --  error message indicating that it is appearing in an inappropriate\n@@ -598,7 +598,7 @@ package body Ch6 is\n          end if;\n       end if;\n \n-      --  Processing for stub or subprogram body or parameterized expression\n+      --  Processing for stub or subprogram body or expression function\n \n       <<Subprogram_Body>>\n \n@@ -623,21 +623,21 @@ package body Ch6 is\n             TF_Semicolon;\n             return Stub_Node;\n \n-         --  Subprogram body or parameterized expression case\n+         --  Subprogram body or expression function case\n \n          else\n-            Scan_Body_Or_Parameterized_Expression : declare\n+            Scan_Body_Or_Expression_Function : declare\n \n-               function Likely_Parameterized_Expression return Boolean;\n-               --  Returns True if we have a probably case of a parameterized\n-               --  expression omitting the parentheses, if so, returns True\n+               function Likely_Expression_Function return Boolean;\n+               --  Returns True if we have a probable case of an expression\n+               --  function omitting the parentheses, if so, returns True\n                --  and emits an appropriate error message, else returns False.\n \n-               -------------------------------------\n-               -- Likely_Parameterized_Expression --\n-               -------------------------------------\n+               --------------------------------\n+               -- Likely_Expression_Function --\n+               --------------------------------\n \n-               function Likely_Parameterized_Expression return Boolean is\n+               function Likely_Expression_Function return Boolean is\n                begin\n                   --  If currently pointing to BEGIN or a declaration keyword\n                   --  or a pragma, then we definitely have a subprogram body.\n@@ -650,15 +650,15 @@ package body Ch6 is\n                      return False;\n \n                   --  Test for tokens which could only start an expression and\n-                  --  thus signal the case of a parameterized expression.\n+                  --  thus signal the case of a expression function.\n \n-                  elsif Token in Token_Class_Literal\n+                  elsif Token     in Token_Class_Literal\n                     or else Token in Token_Class_Unary_Addop\n-                    or else Token = Tok_Left_Paren\n-                    or else Token = Tok_Abs\n-                    or else Token = Tok_Null\n-                    or else Token = Tok_New\n-                    or else Token = Tok_Not\n+                    or else Token =  Tok_Left_Paren\n+                    or else Token =  Tok_Abs\n+                    or else Token =  Tok_Null\n+                    or else Token =  Tok_New\n+                    or else Token =  Tok_Not\n                   then\n                      null;\n \n@@ -680,12 +680,13 @@ package body Ch6 is\n                      --  Otherwise we have to scan ahead. If the identifier is\n                      --  followed by a colon or a comma, it is a declaration\n                      --  and hence we have a subprogram body. Otherwise assume\n-                     --  a parameterized expression.\n+                     --  a expression function.\n \n                      else\n                         declare\n                            Scan_State : Saved_Scan_State;\n                            Tok        : Token_Type;\n+\n                         begin\n                            Save_Scan_State (Scan_State);\n                            Scan; -- past identifier\n@@ -699,43 +700,41 @@ package body Ch6 is\n                      end if;\n                   end if;\n \n-                  --  Fall through if we have a likely parameterized expression\n+                  --  Fall through if we have a likely expression function\n \n                   Error_Msg_SC\n-                    (\"parameterized expression must be \"\n-                     & \"enclosed in parentheses\");\n+                    (\"expression function must be enclosed in parentheses\");\n                   return True;\n-               end Likely_Parameterized_Expression;\n+               end Likely_Expression_Function;\n \n-            --  Start of processing for Scan_Body_Or_Parameterized_Expression\n+            --  Start of processing for Scan_Body_Or_Expression_Function\n \n             begin\n-               --  Parameterized_Expression case\n+               --  Expression_Function case\n \n                if Token = Tok_Left_Paren\n-                 or else Likely_Parameterized_Expression\n+                 or else Likely_Expression_Function\n                then\n-                  --  Check parameterized expression allowed here\n+                  --  Check expression function allowed here\n \n                   if not Pf_Flags.Pexp then\n-                     Error_Msg_SC\n-                       (\"parameterized expression not allowed here!\");\n+                     Error_Msg_SC (\"expression function not allowed here!\");\n                   end if;\n \n                   --  Check we are in Ada 2012 mode\n \n                   if Ada_Version < Ada_2012 then\n                      Error_Msg_SC\n-                       (\"parameterized expression is an Ada 2012 feature!\");\n+                       (\"expression function is an Ada 2012 feature!\");\n                      Error_Msg_SC\n                        (\"\\unit must be compiled with -gnat2012 switch!\");\n                   end if;\n \n-                  --  Parse out expression and build parameterized expression\n+                  --  Parse out expression and build expression function\n \n                   Body_Node :=\n                     New_Node\n-                      (N_Parameterized_Expression, Sloc (Specification_Node));\n+                      (N_Expression_Function, Sloc (Specification_Node));\n                   Set_Specification (Body_Node, Specification_Node);\n                   Set_Expression (Body_Node, P_Expression);\n                   T_Semicolon;\n@@ -775,7 +774,7 @@ package body Ch6 is\n                end if;\n \n                return Body_Node;\n-            end Scan_Body_Or_Parameterized_Expression;\n+            end Scan_Body_Or_Expression_Function;\n          end if;\n \n       --  Processing for subprogram declaration"}, {"sha": "5b434993803c3542877b433e87a1a5cf19dfb3dd", "filename": "gcc/ada/sem.adb", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b0186f718a778b98e1c77a8279a10d79e2d83b8d/gcc%2Fada%2Fsem.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b0186f718a778b98e1c77a8279a10d79e2d83b8d/gcc%2Fada%2Fsem.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem.adb?ref=b0186f718a778b98e1c77a8279a10d79e2d83b8d", "patch": "@@ -223,6 +223,9 @@ package body Sem is\n          when N_Explicit_Dereference =>\n             Analyze_Explicit_Dereference (N);\n \n+         when N_Expression_Function =>\n+            Analyze_Expression_Function (N);\n+\n          when N_Expression_With_Actions =>\n             Analyze_Expression_With_Actions (N);\n \n@@ -439,9 +442,6 @@ package body Sem is\n          when N_Parameter_Association =>\n             Analyze_Parameter_Association (N);\n \n-         when N_Parameterized_Expression =>\n-            Analyze_Parameterized_Expression (N);\n-\n          when N_Pragma =>\n             Analyze_Pragma (N);\n "}, {"sha": "8b737ab1f9f2ae398d9cfb48033f13856c20ab2f", "filename": "gcc/ada/sem_ch4.adb", "status": "modified", "additions": 7, "deletions": 4, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b0186f718a778b98e1c77a8279a10d79e2d83b8d/gcc%2Fada%2Fsem_ch4.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b0186f718a778b98e1c77a8279a10d79e2d83b8d/gcc%2Fada%2Fsem_ch4.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch4.adb?ref=b0186f718a778b98e1c77a8279a10d79e2d83b8d", "patch": "@@ -2475,7 +2475,8 @@ package body Sem_Ch4 is\n          end if;\n \n       --  If not a range, it can be a subtype mark, or else it is a degenerate\n-      --  membership test with a singleton value, i.e. a test for equality.\n+      --  membership test with a singleton value, i.e. a test for equality,\n+      --  if the types are compatible.\n \n       else\n          Analyze (R);\n@@ -2485,7 +2486,9 @@ package body Sem_Ch4 is\n             Find_Type (R);\n             Check_Fully_Declared (Entity (R), R);\n \n-         elsif Ada_Version >= Ada_2012 then\n+         elsif Ada_Version >= Ada_2012\n+           and then Has_Compatible_Type (R, Etype (L))\n+         then\n             if Nkind (N) = N_In then\n                Rewrite (N,\n                  Make_Op_Eq (Loc,\n@@ -2502,8 +2505,8 @@ package body Sem_Ch4 is\n             return;\n \n          else\n-            --  In previous version of the language this is an error that will\n-            --  be diagnosed below.\n+            --  In all versions of the language, if we reach this point there\n+            --  is a previous error that will be diagnosed below.\n \n             Find_Type (R);\n          end if;"}, {"sha": "af20ffaa40f772381cfd4b6f6505221818f32b75", "filename": "gcc/ada/sem_ch6.adb", "status": "modified", "additions": 186, "deletions": 186, "changes": 372, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b0186f718a778b98e1c77a8279a10d79e2d83b8d/gcc%2Fada%2Fsem_ch6.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b0186f718a778b98e1c77a8279a10d79e2d83b8d/gcc%2Fada%2Fsem_ch6.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch6.adb?ref=b0186f718a778b98e1c77a8279a10d79e2d83b8d", "patch": "@@ -215,141 +215,6 @@ package body Sem_Ch6 is\n    --  setting the proper validity status for this entity, which depends on\n    --  the kind of parameter and the validity checking mode.\n \n-   ------------------------------\n-   -- Analyze_Return_Statement --\n-   ------------------------------\n-\n-   procedure Analyze_Return_Statement (N : Node_Id) is\n-\n-      pragma Assert (Nkind_In (N, N_Simple_Return_Statement,\n-                                  N_Extended_Return_Statement));\n-\n-      Returns_Object : constant Boolean :=\n-                         Nkind (N) = N_Extended_Return_Statement\n-                           or else\n-                            (Nkind (N) = N_Simple_Return_Statement\n-                              and then Present (Expression (N)));\n-      --  True if we're returning something; that is, \"return <expression>;\"\n-      --  or \"return Result : T [:= ...]\". False for \"return;\". Used for error\n-      --  checking: If Returns_Object is True, N should apply to a function\n-      --  body; otherwise N should apply to a procedure body, entry body,\n-      --  accept statement, or extended return statement.\n-\n-      function Find_What_It_Applies_To return Entity_Id;\n-      --  Find the entity representing the innermost enclosing body, accept\n-      --  statement, or extended return statement. If the result is a callable\n-      --  construct or extended return statement, then this will be the value\n-      --  of the Return_Applies_To attribute. Otherwise, the program is\n-      --  illegal. See RM-6.5(4/2).\n-\n-      -----------------------------\n-      -- Find_What_It_Applies_To --\n-      -----------------------------\n-\n-      function Find_What_It_Applies_To return Entity_Id is\n-         Result : Entity_Id := Empty;\n-\n-      begin\n-         --  Loop outward through the Scope_Stack, skipping blocks and loops\n-\n-         for J in reverse 0 .. Scope_Stack.Last loop\n-            Result := Scope_Stack.Table (J).Entity;\n-            exit when Ekind (Result) /= E_Block and then\n-                      Ekind (Result) /= E_Loop;\n-         end loop;\n-\n-         pragma Assert (Present (Result));\n-         return Result;\n-      end Find_What_It_Applies_To;\n-\n-      --  Local declarations\n-\n-      Scope_Id   : constant Entity_Id   := Find_What_It_Applies_To;\n-      Kind       : constant Entity_Kind := Ekind (Scope_Id);\n-      Loc        : constant Source_Ptr  := Sloc (N);\n-      Stm_Entity : constant Entity_Id   :=\n-                     New_Internal_Entity\n-                       (E_Return_Statement, Current_Scope, Loc, 'R');\n-\n-   --  Start of processing for Analyze_Return_Statement\n-\n-   begin\n-      Set_Return_Statement_Entity (N, Stm_Entity);\n-\n-      Set_Etype (Stm_Entity, Standard_Void_Type);\n-      Set_Return_Applies_To (Stm_Entity, Scope_Id);\n-\n-      --  Place Return entity on scope stack, to simplify enforcement of 6.5\n-      --  (4/2): an inner return statement will apply to this extended return.\n-\n-      if Nkind (N) = N_Extended_Return_Statement then\n-         Push_Scope (Stm_Entity);\n-      end if;\n-\n-      --  Check that pragma No_Return is obeyed. Don't complain about the\n-      --  implicitly-generated return that is placed at the end.\n-\n-      if No_Return (Scope_Id) and then Comes_From_Source (N) then\n-         Error_Msg_N (\"RETURN statement not allowed (No_Return)\", N);\n-      end if;\n-\n-      --  Warn on any unassigned OUT parameters if in procedure\n-\n-      if Ekind (Scope_Id) = E_Procedure then\n-         Warn_On_Unassigned_Out_Parameter (N, Scope_Id);\n-      end if;\n-\n-      --  Check that functions return objects, and other things do not\n-\n-      if Kind = E_Function or else Kind = E_Generic_Function then\n-         if not Returns_Object then\n-            Error_Msg_N (\"missing expression in return from function\", N);\n-         end if;\n-\n-      elsif Kind = E_Procedure or else Kind = E_Generic_Procedure then\n-         if Returns_Object then\n-            Error_Msg_N (\"procedure cannot return value (use function)\", N);\n-         end if;\n-\n-      elsif Kind = E_Entry or else Kind = E_Entry_Family then\n-         if Returns_Object then\n-            if Is_Protected_Type (Scope (Scope_Id)) then\n-               Error_Msg_N (\"entry body cannot return value\", N);\n-            else\n-               Error_Msg_N (\"accept statement cannot return value\", N);\n-            end if;\n-         end if;\n-\n-      elsif Kind = E_Return_Statement then\n-\n-         --  We are nested within another return statement, which must be an\n-         --  extended_return_statement.\n-\n-         if Returns_Object then\n-            Error_Msg_N\n-              (\"extended_return_statement cannot return value; \" &\n-               \"use `\"\"RETURN;\"\"`\", N);\n-         end if;\n-\n-      else\n-         Error_Msg_N (\"illegal context for return statement\", N);\n-      end if;\n-\n-      if Ekind_In (Kind, E_Function, E_Generic_Function) then\n-         Analyze_Function_Return (N);\n-\n-      elsif Ekind_In (Kind, E_Procedure, E_Generic_Procedure) then\n-         Set_Return_Present (Scope_Id);\n-      end if;\n-\n-      if Nkind (N) = N_Extended_Return_Statement then\n-         End_Scope;\n-      end if;\n-\n-      Kill_Current_Values (Last_Assignment_Only => True);\n-      Check_Unreachable_Code (N);\n-   end Analyze_Return_Statement;\n-\n    ---------------------------------------------\n    -- Analyze_Abstract_Subprogram_Declaration --\n    ---------------------------------------------\n@@ -398,6 +263,55 @@ package body Sem_Ch6 is\n       Analyze_Aspect_Specifications (N, Designator, Aspect_Specifications (N));\n    end Analyze_Abstract_Subprogram_Declaration;\n \n+   ---------------------------------\n+   -- Analyze_Expression_Function --\n+   ---------------------------------\n+\n+   procedure Analyze_Expression_Function (N : Node_Id) is\n+      Loc      : constant Source_Ptr := Sloc (N);\n+      LocX     : constant Source_Ptr := Sloc (Expression (N));\n+      Def_Id   : constant Entity_Id  := Defining_Entity (Specification (N));\n+      New_Body : Node_Id;\n+\n+      Prev : constant Entity_Id := Current_Entity_In_Scope (Def_Id);\n+      --  If the expression is a completion, Prev is the entity whose\n+      --  declaration is completed.\n+\n+   begin\n+      --  This is one of the occasions on which we transform the tree during\n+      --  semantic analysis. Transform the expression function into an\n+      --  equivalent subprogram body, and then analyze that.\n+\n+      New_Body :=\n+        Make_Subprogram_Body (Loc,\n+          Specification              => Specification (N),\n+          Declarations               => Empty_List,\n+          Handled_Statement_Sequence =>\n+            Make_Handled_Sequence_Of_Statements (LocX,\n+              Statements => New_List (\n+                Make_Simple_Return_Statement (LocX,\n+                  Expression => Expression (N)))));\n+\n+      if Present (Prev)\n+        and then Ekind (Prev) = E_Generic_Function\n+      then\n+         --  If the expression completes a generic subprogram, we must create a\n+         --  separate node for the body, because at instantiation the original\n+         --  node of the generic copy must be a generic subprogram body, and\n+         --  cannot be a expression function. Otherwise we just rewrite the\n+         --  expression with the non-generic body.\n+\n+         Insert_After (N, New_Body);\n+         Rewrite (N, Make_Null_Statement (Loc));\n+         Analyze (N);\n+         Analyze (New_Body);\n+\n+      else\n+         Rewrite (N, New_Body);\n+         Analyze (N);\n+      end if;\n+   end Analyze_Expression_Function;\n+\n    ----------------------------------------\n    -- Analyze_Extended_Return_Statement  --\n    ----------------------------------------\n@@ -1095,55 +1009,6 @@ package body Sem_Ch6 is\n       Analyze (Explicit_Actual_Parameter (N));\n    end Analyze_Parameter_Association;\n \n-   --------------------------------------\n-   -- Analyze_Parameterized_Expression --\n-   --------------------------------------\n-\n-   procedure Analyze_Parameterized_Expression (N : Node_Id) is\n-      Loc      : constant Source_Ptr := Sloc (N);\n-      LocX     : constant Source_Ptr := Sloc (Expression (N));\n-      Def_Id   : constant Entity_Id  := Defining_Entity (Specification (N));\n-      New_Body : Node_Id;\n-\n-      Prev : constant Entity_Id := Current_Entity_In_Scope (Def_Id);\n-      --  If the expression is a completion, Prev is the entity whose\n-      --  declaration is completed.\n-\n-   begin\n-      --  This is one of the occasions on which we transform the tree during\n-      --  semantic analysis. Transform the parameterized expression into an\n-      --  equivalent subprogram body, and then analyze that.\n-\n-      New_Body :=\n-        Make_Subprogram_Body (Loc,\n-          Specification              => Specification (N),\n-          Declarations               => Empty_List,\n-          Handled_Statement_Sequence =>\n-            Make_Handled_Sequence_Of_Statements (LocX,\n-              Statements => New_List (\n-                Make_Simple_Return_Statement (LocX,\n-                  Expression => Expression (N)))));\n-\n-      if Present (Prev)\n-        and then Ekind (Prev) = E_Generic_Function\n-      then\n-         --  If the expression completes a generic subprogram, we must create\n-         --  a separate node for the body, because at instantiation the\n-         --  original node of the generic copy must be a generic subprogram\n-         --  body, and cannot be a parameterized expression. Otherwise we\n-         --  just rewrite the expression with the non-generic body.\n-\n-         Insert_After (N, New_Body);\n-         Rewrite (N, Make_Null_Statement (Loc));\n-         Analyze (N);\n-         Analyze (New_Body);\n-\n-      else\n-         Rewrite (N, New_Body);\n-         Analyze (N);\n-      end if;\n-   end Analyze_Parameterized_Expression;\n-\n    ----------------------------\n    -- Analyze_Procedure_Call --\n    ----------------------------\n@@ -1372,6 +1237,141 @@ package body Sem_Ch6 is\n       end if;\n    end Analyze_Procedure_Call;\n \n+   ------------------------------\n+   -- Analyze_Return_Statement --\n+   ------------------------------\n+\n+   procedure Analyze_Return_Statement (N : Node_Id) is\n+\n+      pragma Assert (Nkind_In (N, N_Simple_Return_Statement,\n+                                  N_Extended_Return_Statement));\n+\n+      Returns_Object : constant Boolean :=\n+                         Nkind (N) = N_Extended_Return_Statement\n+                           or else\n+                            (Nkind (N) = N_Simple_Return_Statement\n+                              and then Present (Expression (N)));\n+      --  True if we're returning something; that is, \"return <expression>;\"\n+      --  or \"return Result : T [:= ...]\". False for \"return;\". Used for error\n+      --  checking: If Returns_Object is True, N should apply to a function\n+      --  body; otherwise N should apply to a procedure body, entry body,\n+      --  accept statement, or extended return statement.\n+\n+      function Find_What_It_Applies_To return Entity_Id;\n+      --  Find the entity representing the innermost enclosing body, accept\n+      --  statement, or extended return statement. If the result is a callable\n+      --  construct or extended return statement, then this will be the value\n+      --  of the Return_Applies_To attribute. Otherwise, the program is\n+      --  illegal. See RM-6.5(4/2).\n+\n+      -----------------------------\n+      -- Find_What_It_Applies_To --\n+      -----------------------------\n+\n+      function Find_What_It_Applies_To return Entity_Id is\n+         Result : Entity_Id := Empty;\n+\n+      begin\n+         --  Loop outward through the Scope_Stack, skipping blocks and loops\n+\n+         for J in reverse 0 .. Scope_Stack.Last loop\n+            Result := Scope_Stack.Table (J).Entity;\n+            exit when Ekind (Result) /= E_Block and then\n+                      Ekind (Result) /= E_Loop;\n+         end loop;\n+\n+         pragma Assert (Present (Result));\n+         return Result;\n+      end Find_What_It_Applies_To;\n+\n+      --  Local declarations\n+\n+      Scope_Id   : constant Entity_Id   := Find_What_It_Applies_To;\n+      Kind       : constant Entity_Kind := Ekind (Scope_Id);\n+      Loc        : constant Source_Ptr  := Sloc (N);\n+      Stm_Entity : constant Entity_Id   :=\n+                     New_Internal_Entity\n+                       (E_Return_Statement, Current_Scope, Loc, 'R');\n+\n+   --  Start of processing for Analyze_Return_Statement\n+\n+   begin\n+      Set_Return_Statement_Entity (N, Stm_Entity);\n+\n+      Set_Etype (Stm_Entity, Standard_Void_Type);\n+      Set_Return_Applies_To (Stm_Entity, Scope_Id);\n+\n+      --  Place Return entity on scope stack, to simplify enforcement of 6.5\n+      --  (4/2): an inner return statement will apply to this extended return.\n+\n+      if Nkind (N) = N_Extended_Return_Statement then\n+         Push_Scope (Stm_Entity);\n+      end if;\n+\n+      --  Check that pragma No_Return is obeyed. Don't complain about the\n+      --  implicitly-generated return that is placed at the end.\n+\n+      if No_Return (Scope_Id) and then Comes_From_Source (N) then\n+         Error_Msg_N (\"RETURN statement not allowed (No_Return)\", N);\n+      end if;\n+\n+      --  Warn on any unassigned OUT parameters if in procedure\n+\n+      if Ekind (Scope_Id) = E_Procedure then\n+         Warn_On_Unassigned_Out_Parameter (N, Scope_Id);\n+      end if;\n+\n+      --  Check that functions return objects, and other things do not\n+\n+      if Kind = E_Function or else Kind = E_Generic_Function then\n+         if not Returns_Object then\n+            Error_Msg_N (\"missing expression in return from function\", N);\n+         end if;\n+\n+      elsif Kind = E_Procedure or else Kind = E_Generic_Procedure then\n+         if Returns_Object then\n+            Error_Msg_N (\"procedure cannot return value (use function)\", N);\n+         end if;\n+\n+      elsif Kind = E_Entry or else Kind = E_Entry_Family then\n+         if Returns_Object then\n+            if Is_Protected_Type (Scope (Scope_Id)) then\n+               Error_Msg_N (\"entry body cannot return value\", N);\n+            else\n+               Error_Msg_N (\"accept statement cannot return value\", N);\n+            end if;\n+         end if;\n+\n+      elsif Kind = E_Return_Statement then\n+\n+         --  We are nested within another return statement, which must be an\n+         --  extended_return_statement.\n+\n+         if Returns_Object then\n+            Error_Msg_N\n+              (\"extended_return_statement cannot return value; \" &\n+               \"use `\"\"RETURN;\"\"`\", N);\n+         end if;\n+\n+      else\n+         Error_Msg_N (\"illegal context for return statement\", N);\n+      end if;\n+\n+      if Ekind_In (Kind, E_Function, E_Generic_Function) then\n+         Analyze_Function_Return (N);\n+\n+      elsif Ekind_In (Kind, E_Procedure, E_Generic_Procedure) then\n+         Set_Return_Present (Scope_Id);\n+      end if;\n+\n+      if Nkind (N) = N_Extended_Return_Statement then\n+         End_Scope;\n+      end if;\n+\n+      Kill_Current_Values (Last_Assignment_Only => True);\n+      Check_Unreachable_Code (N);\n+   end Analyze_Return_Statement;\n+\n    -------------------------------------\n    -- Analyze_Simple_Return_Statement --\n    -------------------------------------\n@@ -2449,9 +2449,9 @@ package body Sem_Ch6 is\n \n            and then not In_Instance\n \n-           --  No warnings for parameterized expressions\n+           --  No warnings for expression functions\n \n-           and then Nkind (Original_Node (N)) /= N_Parameterized_Expression\n+           and then Nkind (Original_Node (N)) /= N_Expression_Function\n          then\n             Style.Body_With_No_Spec (N);\n          end if;"}, {"sha": "96d967b128dca07612c0eb44ad4a8469ca4c50fb", "filename": "gcc/ada/sem_ch6.ads", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b0186f718a778b98e1c77a8279a10d79e2d83b8d/gcc%2Fada%2Fsem_ch6.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b0186f718a778b98e1c77a8279a10d79e2d83b8d/gcc%2Fada%2Fsem_ch6.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch6.ads?ref=b0186f718a778b98e1c77a8279a10d79e2d83b8d", "patch": "@@ -35,11 +35,11 @@ package Sem_Ch6 is\n    --  type is stronger than the ones preceding it.\n \n    procedure Analyze_Abstract_Subprogram_Declaration (N : Node_Id);\n+   procedure Analyze_Expression_Function             (N : Node_Id);\n    procedure Analyze_Extended_Return_Statement       (N : Node_Id);\n    procedure Analyze_Function_Call                   (N : Node_Id);\n    procedure Analyze_Operator_Symbol                 (N : Node_Id);\n    procedure Analyze_Parameter_Association           (N : Node_Id);\n-   procedure Analyze_Parameterized_Expression        (N : Node_Id);\n    procedure Analyze_Procedure_Call                  (N : Node_Id);\n    procedure Analyze_Simple_Return_Statement         (N : Node_Id);\n    procedure Analyze_Subprogram_Declaration          (N : Node_Id);"}, {"sha": "495b260ac50b9d596ec7af788251bc15f1799c6f", "filename": "gcc/ada/sem_res.adb", "status": "modified", "additions": 162, "deletions": 41, "changes": 203, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b0186f718a778b98e1c77a8279a10d79e2d83b8d/gcc%2Fada%2Fsem_res.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b0186f718a778b98e1c77a8279a10d79e2d83b8d/gcc%2Fada%2Fsem_res.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_res.adb?ref=b0186f718a778b98e1c77a8279a10d79e2d83b8d", "patch": "@@ -92,6 +92,12 @@ package body Sem_Res is\n \n    --  Note that Resolve_Attribute is separated off in Sem_Attr\n \n+   function Matching_Static_Array_Bounds\n+     (L_Typ : Node_Id;\n+      R_Typ : Node_Id) return Boolean;\n+   --  L_Typ and R_Typ are two array types. Returns True when they have the\n+   --  same dimension, and, for each index position, the same static bounds.\n+\n    function Bad_Unordered_Enumeration_Reference\n      (N : Node_Id;\n       T : Entity_Id) return Boolean;\n@@ -1571,6 +1577,65 @@ package body Sem_Res is\n       end if;\n    end Make_Call_Into_Operator;\n \n+   ----------------------------------\n+   -- Matching_Static_Array_Bounds --\n+   ----------------------------------\n+\n+   function Matching_Static_Array_Bounds\n+     (L_Typ : Node_Id;\n+      R_Typ : Node_Id) return Boolean\n+   is\n+      L_Ndims : constant Nat := Number_Dimensions (L_Typ);\n+      R_Ndims : constant Nat := Number_Dimensions (R_Typ);\n+\n+      L_Index : Node_Id;\n+      R_Index : Node_Id;\n+      L_Low   : Node_Id;\n+      L_High  : Node_Id;\n+      R_Low   : Node_Id;\n+      R_High  : Node_Id;\n+\n+   begin\n+      if L_Ndims /= R_Ndims then\n+         return False;\n+      end if;\n+\n+      --  Unconstrained types do not have static bounds\n+\n+      if not Is_Constrained (L_Typ) or else not Is_Constrained (R_Typ) then\n+         return False;\n+      end if;\n+\n+      L_Index := First_Index (L_Typ);\n+      R_Index := First_Index (R_Typ);\n+\n+      for Indx in 1 .. L_Ndims loop\n+         Get_Index_Bounds (L_Index, L_Low, L_High);\n+         Get_Index_Bounds (R_Index, R_Low, R_High);\n+\n+         if True\n+           and then Is_Static_Expression (L_Low)\n+           and then Is_Static_Expression (L_High)\n+           and then Is_Static_Expression (R_Low)\n+           and then Is_Static_Expression (R_High)\n+           and then Expr_Value (L_Low)  = Expr_Value (R_Low)\n+           and then Expr_Value (L_High) = Expr_Value (R_High)\n+         then\n+            --  Matching so far, continue with next index\n+\n+            null;\n+\n+         else\n+            return False;\n+         end if;\n+\n+         Next (L_Index);\n+         Next (R_Index);\n+      end loop;\n+\n+      return True;\n+   end Matching_Static_Array_Bounds;\n+\n    -------------------\n    -- Operator_Kind --\n    -------------------\n@@ -1582,6 +1647,8 @@ package body Sem_Res is\n       Kind : Node_Kind;\n \n    begin\n+      --  Use CASE statement or array???\n+\n       if Is_Binary then\n          if    Op_Name =  Name_Op_And      then\n             Kind := N_Op_And;\n@@ -3555,6 +3622,31 @@ package body Sem_Res is\n             A_Typ := Etype (A);\n             F_Typ := Etype (F);\n \n+            --  In SPARK or ALFA, the only view conversions are those involving\n+            --  ancestor conversion of an extended type.\n+\n+            if Formal_Verification_Mode\n+              and then Comes_From_Source (Original_Node (A))\n+              and then Nkind (A) = N_Type_Conversion\n+              and then Ekind_In (F, E_Out_Parameter, E_In_Out_Parameter)\n+            then\n+               declare\n+                  Operand     : constant Node_Id   := Expression (A);\n+                  Operand_Typ : constant Entity_Id := Etype (Operand);\n+                  Target_Typ  : constant Entity_Id := A_Typ;\n+               begin\n+                  if not (Is_Tagged_Type (Target_Typ)\n+                          and then not Is_Class_Wide_Type (Target_Typ)\n+                          and then Is_Tagged_Type (Operand_Typ)\n+                          and then not Is_Class_Wide_Type (Operand_Typ)\n+                          and then Is_Ancestor (Target_Typ, Operand_Typ))\n+                  then\n+                     Error_Msg_F (\"|~~ancestor conversion is the only \"\n+                                  & \"view conversion\", A);\n+                  end if;\n+               end;\n+            end if;\n+\n             --  Save actual for subsequent check on order dependence, and\n             --  indicate whether actual is modifiable. For AI05-0144-2.\n \n@@ -4795,6 +4887,21 @@ package body Sem_Res is\n       Generate_Operator_Reference (N, Typ);\n       Eval_Arithmetic_Op (N);\n \n+      --  In SPARK and ALFA, a multiplication or division with operands of\n+      --  fixed point types shall be qualified or explicitly converted to\n+      --  identify the result type.\n+\n+      if Formal_Verification_Mode\n+        and then (Is_Fixed_Point_Type (Etype (L))\n+                  or else Is_Fixed_Point_Type (Etype (R)))\n+        and then Nkind_In (N, N_Op_Multiply, N_Op_Divide)\n+        and then\n+          not Nkind_In (Parent (N), N_Qualified_Expression, N_Type_Conversion)\n+      then\n+         Error_Msg_F\n+           (\"|~~operation should be qualified or explicitly converted\", N);\n+      end if;\n+\n       --  Set overflow and division checking bit. Much cleverer code needed\n       --  here eventually and perhaps the Resolve routines should be separated\n       --  for the various arithmetic operations, since they will need\n@@ -5792,6 +5899,22 @@ package body Sem_Res is\n       Generate_Operator_Reference (N, T);\n       Check_Low_Bound_Tested (N);\n \n+      --  In SPARK or ALFA, ordering operators <, <=, >, >= are not defined\n+      --  for Boolean types or array types except String.\n+\n+      if Formal_Verification_Mode\n+        and then Comes_From_Source (Original_Node (N))\n+      then\n+         if Is_Boolean_Type (T) then\n+            Error_Msg_F (\"|~~comparison is not defined on Boolean type\", N);\n+         elsif Is_Array_Type (T)\n+           and then Base_Type (T) /= Standard_String\n+         then\n+            Error_Msg_F\n+              (\"|~~comparison is not defined on array type except String\", N);\n+         end if;\n+      end if;\n+\n       --  Check comparison on unordered enumeration\n \n       if Comes_From_Source (N)\n@@ -6635,6 +6758,20 @@ package body Sem_Res is\n          Resolve (L, T);\n          Resolve (R, T);\n \n+         --  In SPARK or ALFA, equality operators = and /= for array types\n+         --  other than String are only defined when, for each index position,\n+         --  the operands have equal static bounds.\n+\n+         if Formal_Verification_Mode\n+           and then Comes_From_Source (Original_Node (N))\n+           and then Is_Array_Type (T)\n+           and then Base_Type (T) /= Standard_String\n+           and then not Matching_Static_Array_Bounds (Etype (L), Etype (R))\n+         then\n+            Error_Msg_F\n+              (\"|~~array types should have matching static bounds\", N);\n+         end if;\n+\n          --  If the unique type is a class-wide type then it will be expanded\n          --  into a dispatching call to the predefined primitive. Therefore we\n          --  check here for potential violation of such restriction.\n@@ -7163,48 +7300,11 @@ package body Sem_Res is\n \n       if Formal_Verification_Mode\n         and then Comes_From_Source (Original_Node (N))\n-        and then Is_Array_Type (Etype (N))\n+        and then Is_Array_Type (B_Typ)\n+        and then not Matching_Static_Array_Bounds (Etype (Left_Opnd (N)),\n+                                                   Etype (Right_Opnd (N)))\n       then\n-         declare\n-            L_Index : Node_Id;\n-            R_Index : Node_Id;\n-            L_Low   : Node_Id;\n-            L_High  : Node_Id;\n-            R_Low   : Node_Id;\n-            R_High  : Node_Id;\n-\n-            L_Typ : constant Node_Id := Etype (Left_Opnd (N));\n-            R_Typ : constant Node_Id := Etype (Right_Opnd (N));\n-\n-         begin\n-            L_Index := First_Index (L_Typ);\n-            R_Index := First_Index (R_Typ);\n-\n-            Get_Index_Bounds (L_Index, L_Low, L_High);\n-            Get_Index_Bounds (R_Index, R_Low, R_High);\n-\n-            --  Another error is issued for constrained array types with\n-            --  non-static bounds elsewhere, so only deal with different\n-            --  constrained types, or unconstrained types.\n-\n-            if L_Typ /= R_Typ or else not Is_Constrained (L_Typ) then\n-               if not Is_Static_Expression (L_Low)\n-                 or else not Is_Static_Expression (R_Low)\n-                 or else Expr_Value (L_Low) /= Expr_Value (R_Low)\n-               then\n-                  Error_Msg_F (\"|~~operation defined only when both operands \"\n-                               & \"have the same static lower bound\", N);\n-               end if;\n-\n-               if not Is_Static_Expression (L_High)\n-                 or else not Is_Static_Expression (R_High)\n-                 or else Expr_Value (L_High) /= Expr_Value (R_High)\n-               then\n-                  Error_Msg_F (\"|~~operation defined only when both operands \"\n-                               & \"have the same static higher bound\", N);\n-               end if;\n-            end if;\n-         end;\n+         Error_Msg_F (\"|~~array types should have matching static bounds\", N);\n       end if;\n \n    end Resolve_Logical_Op;\n@@ -7857,6 +7957,15 @@ package body Sem_Res is\n    begin\n       Resolve (Expr, Target_Typ);\n \n+      if Formal_Verification_Mode\n+        and then Comes_From_Source (Original_Node (N))\n+        and then Is_Array_Type (Target_Typ)\n+        and then Is_Array_Type (Etype (Expr))\n+        and then not Matching_Static_Array_Bounds (Target_Typ, Etype (Expr))\n+      then\n+         Error_Msg_F (\"|~~array types should have matching static bounds\", N);\n+      end if;\n+\n       --  A qualified expression requires an exact match of the type,\n       --  class-wide matching is not allowed. However, if the qualifying\n       --  type is specific and the expression has a class-wide type, it\n@@ -8971,6 +9080,18 @@ package body Sem_Res is\n \n       Resolve (Operand);\n \n+      --  In SPARK or ALFA, a type conversion between array types should be\n+      --  restricted to types which have matching static bounds.\n+\n+      if Formal_Verification_Mode\n+        and then Comes_From_Source (Original_Node (N))\n+        and then Is_Array_Type (Target_Typ)\n+        and then Is_Array_Type (Operand_Typ)\n+        and then not Matching_Static_Array_Bounds (Target_Typ, Operand_Typ)\n+      then\n+         Error_Msg_F (\"|~~array types should have matching static bounds\", N);\n+      end if;\n+\n       --  Note: we do the Eval_Type_Conversion call before applying the\n       --  required checks for a subtype conversion. This is important, since\n       --  both are prepared under certain circumstances to change the type"}, {"sha": "42421425a3e3947fd46a4c85f0109a8bedeb103a", "filename": "gcc/ada/sinfo.adb", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b0186f718a778b98e1c77a8279a10d79e2d83b8d/gcc%2Fada%2Fsinfo.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b0186f718a778b98e1c77a8279a10d79e2d83b8d/gcc%2Fada%2Fsinfo.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsinfo.adb?ref=b0186f718a778b98e1c77a8279a10d79e2d83b8d", "patch": "@@ -1223,14 +1223,14 @@ package body Sinfo is\n         or else NT (N).Nkind = N_Discriminant_Association\n         or else NT (N).Nkind = N_Discriminant_Specification\n         or else NT (N).Nkind = N_Exception_Declaration\n+        or else NT (N).Nkind = N_Expression_Function\n         or else NT (N).Nkind = N_Expression_With_Actions\n         or else NT (N).Nkind = N_Free_Statement\n         or else NT (N).Nkind = N_Mod_Clause\n         or else NT (N).Nkind = N_Modular_Type_Definition\n         or else NT (N).Nkind = N_Number_Declaration\n         or else NT (N).Nkind = N_Object_Declaration\n         or else NT (N).Nkind = N_Parameter_Specification\n-        or else NT (N).Nkind = N_Parameterized_Expression\n         or else NT (N).Nkind = N_Pragma_Argument_Association\n         or else NT (N).Nkind = N_Qualified_Expression\n         or else NT (N).Nkind = N_Raise_Statement\n@@ -2797,12 +2797,12 @@ package body Sinfo is\n    begin\n       pragma Assert (False\n         or else NT (N).Nkind = N_Abstract_Subprogram_Declaration\n+        or else NT (N).Nkind = N_Expression_Function\n         or else NT (N).Nkind = N_Formal_Abstract_Subprogram_Declaration\n         or else NT (N).Nkind = N_Formal_Concrete_Subprogram_Declaration\n         or else NT (N).Nkind = N_Generic_Package_Declaration\n         or else NT (N).Nkind = N_Generic_Subprogram_Declaration\n         or else NT (N).Nkind = N_Package_Declaration\n-        or else NT (N).Nkind = N_Parameterized_Expression\n         or else NT (N).Nkind = N_Subprogram_Body\n         or else NT (N).Nkind = N_Subprogram_Body_Stub\n         or else NT (N).Nkind = N_Subprogram_Declaration\n@@ -4267,14 +4267,14 @@ package body Sinfo is\n         or else NT (N).Nkind = N_Discriminant_Association\n         or else NT (N).Nkind = N_Discriminant_Specification\n         or else NT (N).Nkind = N_Exception_Declaration\n+        or else NT (N).Nkind = N_Expression_Function\n         or else NT (N).Nkind = N_Expression_With_Actions\n         or else NT (N).Nkind = N_Free_Statement\n         or else NT (N).Nkind = N_Mod_Clause\n         or else NT (N).Nkind = N_Modular_Type_Definition\n         or else NT (N).Nkind = N_Number_Declaration\n         or else NT (N).Nkind = N_Object_Declaration\n         or else NT (N).Nkind = N_Parameter_Specification\n-        or else NT (N).Nkind = N_Parameterized_Expression\n         or else NT (N).Nkind = N_Pragma_Argument_Association\n         or else NT (N).Nkind = N_Qualified_Expression\n         or else NT (N).Nkind = N_Raise_Statement\n@@ -5842,12 +5842,12 @@ package body Sinfo is\n    begin\n       pragma Assert (False\n         or else NT (N).Nkind = N_Abstract_Subprogram_Declaration\n+        or else NT (N).Nkind = N_Expression_Function\n         or else NT (N).Nkind = N_Formal_Abstract_Subprogram_Declaration\n         or else NT (N).Nkind = N_Formal_Concrete_Subprogram_Declaration\n         or else NT (N).Nkind = N_Generic_Package_Declaration\n         or else NT (N).Nkind = N_Generic_Subprogram_Declaration\n         or else NT (N).Nkind = N_Package_Declaration\n-        or else NT (N).Nkind = N_Parameterized_Expression\n         or else NT (N).Nkind = N_Subprogram_Body\n         or else NT (N).Nkind = N_Subprogram_Body_Stub\n         or else NT (N).Nkind = N_Subprogram_Declaration"}, {"sha": "a4ccd62ef079f5dabf804e814e1af306a487d51d", "filename": "gcc/ada/sinfo.ads", "status": "modified", "additions": 17, "deletions": 7, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b0186f718a778b98e1c77a8279a10d79e2d83b8d/gcc%2Fada%2Fsinfo.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b0186f718a778b98e1c77a8279a10d79e2d83b8d/gcc%2Fada%2Fsinfo.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsinfo.ads?ref=b0186f718a778b98e1c77a8279a10d79e2d83b8d", "patch": "@@ -4591,17 +4591,17 @@ package Sinfo is\n       --  Has_Relative_Deadline_Pragma (Flag9-Sem)\n       --  Has_Pragma_CPU (Flag14-Sem)\n \n-      ------------------------------\n-      -- Parameterized Expression --\n-      ------------------------------\n+      -------------------------\n+      -- Expression Function --\n+      -------------------------\n \n       --  This is an Ada 2012 extension, we put it here for now, to be labeled\n       --  and put in its proper section when we know exactly where that is!\n \n-      --  PARAMETERIZED_EXPRESSION ::=\n+      --  EXPRESSION_FUNCTION ::=\n       --    FUNCTION SPECIFICATION IS (EXPRESSION);\n \n-      --  N_Parameterized_Expression\n+      --  N_Expression_Function\n       --  Sloc points to FUNCTION\n       --  Specification (Node1)\n       --  Expression (Node3)\n@@ -7591,14 +7591,14 @@ package Sinfo is\n \n       N_Component_Declaration,\n       N_Entry_Declaration,\n+      N_Expression_Function,\n       N_Formal_Object_Declaration,\n       N_Formal_Type_Declaration,\n       N_Full_Type_Declaration,\n       N_Incomplete_Type_Declaration,\n       N_Iterator_Specification,\n       N_Loop_Parameter_Specification,\n       N_Object_Declaration,\n-      N_Parameterized_Expression,\n       N_Protected_Type_Declaration,\n       N_Private_Extension_Declaration,\n       N_Private_Type_Declaration,\n@@ -10818,7 +10818,7 @@ package Sinfo is\n         4 => True,    --  Handled_Statement_Sequence (Node4)\n         5 => False),  --  Corresponding_Spec (Node5-Sem)\n \n-     N_Parameterized_Expression =>\n+     N_Expression_Function =>\n        (1 => True,    --  Specification (Node1)\n         2 => False,   --  unused\n         3 => True,    --  Expression (Node3)\n@@ -12317,8 +12317,18 @@ package Sinfo is\n    pragma Inline (Set_Withed_Body);\n    pragma Inline (Set_Zero_Cost_Handling);\n \n+   --------------\n+   -- Synonyms --\n+   --------------\n+\n+   --  These synonyms are to aid in transition, they should eventually be\n+   --  removed when all remaining references to the obsolete name are gone.\n+\n    N_Simple_Return_Statement : constant Node_Kind := N_Return_Statement;\n    --  Rename N_Return_Statement to be N_Simple_Return_Statement. Clients\n    --  should refer to N_Simple_Return_Statement.\n \n+   N_Parameterized_Expression : constant Node_Kind := N_Expression_Function;\n+   --  Old name for expression functions (used during Ada 2012 transition)\n+\n end Sinfo;"}, {"sha": "63bfd54c95ceb02755c1b2d0ba657ec40eb899ef", "filename": "gcc/ada/sprint.adb", "status": "modified", "additions": 10, "deletions": 11, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b0186f718a778b98e1c77a8279a10d79e2d83b8d/gcc%2Fada%2Fsprint.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b0186f718a778b98e1c77a8279a10d79e2d83b8d/gcc%2Fada%2Fsprint.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsprint.adb?ref=b0186f718a778b98e1c77a8279a10d79e2d83b8d", "patch": "@@ -1620,6 +1620,16 @@ package body Sprint is\n             Indent_End;\n             Write_Indent;\n \n+         when N_Expression_Function =>\n+            Write_Indent;\n+            Sprint_Node_Sloc (Specification (Node));\n+            Write_Str (\" is\");\n+            Indent_Begin;\n+            Write_Indent;\n+            Sprint_Node (Expression (Node));\n+            Write_Char (';');\n+            Indent_End;\n+\n          when N_Extended_Return_Statement =>\n             Write_Indent_Str_Sloc (\"return \");\n             Sprint_Node_List (Return_Object_Declarations (Node));\n@@ -2488,17 +2498,6 @@ package body Sprint is\n                Write_Str (\", \");\n             end if;\n \n-         when N_Parameterized_Expression =>\n-            Write_Indent;\n-            Sprint_Node_Sloc (Specification (Node));\n-\n-            Write_Str (\" is\");\n-            Indent_Begin;\n-            Write_Indent;\n-            Sprint_Node (Expression (Node));\n-            Write_Char (';');\n-            Indent_End;\n-\n          when N_Pop_Constraint_Error_Label =>\n             Write_Indent_Str (\"%pop_constraint_error_label\");\n "}]}