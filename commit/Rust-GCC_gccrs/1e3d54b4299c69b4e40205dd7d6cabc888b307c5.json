{"sha": "1e3d54b4299c69b4e40205dd7d6cabc888b307c5", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MWUzZDU0YjQyOTljNjliNGU0MDIwNWRkN2Q2Y2FiYzg4OGIzMDdjNQ==", "commit": {"author": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2016-07-05T16:17:12Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2016-07-05T16:17:12Z"}, "message": "tree-scalar-evolution.c (iv_can_overflow_p): New function.\n\n\t* tree-scalar-evolution.c (iv_can_overflow_p): New function.\n\t(simple_iv): Use it.\n\n\t* gcc.dg/tree-ssa/scev-14.c: new testcase.\n\nFrom-SVN: r238012", "tree": {"sha": "d03a0e81441d18d5bd2895516d42ce6af2c990f0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d03a0e81441d18d5bd2895516d42ce6af2c990f0"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/1e3d54b4299c69b4e40205dd7d6cabc888b307c5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1e3d54b4299c69b4e40205dd7d6cabc888b307c5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1e3d54b4299c69b4e40205dd7d6cabc888b307c5", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1e3d54b4299c69b4e40205dd7d6cabc888b307c5/comments", "author": null, "committer": null, "parents": [{"sha": "341c5337bfb2f281cbb377b3bbdbbdf503f3520e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/341c5337bfb2f281cbb377b3bbdbbdf503f3520e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/341c5337bfb2f281cbb377b3bbdbbdf503f3520e"}], "stats": {"total": 109, "additions": 109, "deletions": 0}, "files": [{"sha": "c7468666273061bf1ae4356b476e3558ee37ba73", "filename": "gcc/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1e3d54b4299c69b4e40205dd7d6cabc888b307c5/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1e3d54b4299c69b4e40205dd7d6cabc888b307c5/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=1e3d54b4299c69b4e40205dd7d6cabc888b307c5", "patch": "@@ -1,3 +1,8 @@\n+2016-07-05  Jan Hubicka  <jh@suse.cz>\n+\n+\t* tree-scalar-evolution.c (iv_can_overflow_p): New function.\n+\t(simple_iv): Use it.\n+\n 2016-07-05  Jan Hubicka  <jh@suse.cz>\n \n \t* tree-ssa-loop-niter.c (nowrap_type_p): Use ANY_INTEGRAL_TYPE_P."}, {"sha": "d57f9c3eede534aa8ce40af5dcff4ee07b4eac2b", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1e3d54b4299c69b4e40205dd7d6cabc888b307c5/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1e3d54b4299c69b4e40205dd7d6cabc888b307c5/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=1e3d54b4299c69b4e40205dd7d6cabc888b307c5", "patch": "@@ -1,3 +1,7 @@\n+2016-07-05  Jan Hubicka  <jh@suse.cz>\n+\n+\t* gcc.dg/tree-ssa/scev-14.c: new testcase.\n+\n 2016-07-05  David Malcolm  <dmalcolm@redhat.com>\n \n \tPR c++/62314"}, {"sha": "43af7d3dab479ce749ef5e14eb59903cebac0ec3", "filename": "gcc/testsuite/gcc.dg/tree-ssa/scev-14.c", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1e3d54b4299c69b4e40205dd7d6cabc888b307c5/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fscev-14.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1e3d54b4299c69b4e40205dd7d6cabc888b307c5/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fscev-14.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fscev-14.c?ref=1e3d54b4299c69b4e40205dd7d6cabc888b307c5", "patch": "@@ -0,0 +1,11 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -fdump-tree-ivopts-details\" } */\n+int a[100];\n+void t(unsigned int n)\n+{\n+  unsigned int i;\n+  for (i=0; i<n; i++)\n+     a[i]++;\n+}\n+/* { dg-final { scan-tree-dump \"Overflowness wrto loop niter:\tNo-overflow\"  \"ivopts\" } } */\n+/* { dg-final { scan-tree-dump-not \"Overflowness wrto loop niter:\tOverflow\" \"ivopts\" } } */"}, {"sha": "e51f0aaedc199291273d4e2734ce167117a46bd6", "filename": "gcc/tree-scalar-evolution.c", "status": "modified", "additions": 89, "deletions": 0, "changes": 89, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1e3d54b4299c69b4e40205dd7d6cabc888b307c5/gcc%2Ftree-scalar-evolution.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1e3d54b4299c69b4e40205dd7d6cabc888b307c5/gcc%2Ftree-scalar-evolution.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-scalar-evolution.c?ref=1e3d54b4299c69b4e40205dd7d6cabc888b307c5", "patch": "@@ -3309,6 +3309,91 @@ scev_reset (void)\n     }\n }\n \n+/* Return true if the IV calculation in TYPE can overflow based on the knowledge\n+   of the upper bound on the number of iterations of LOOP, the BASE and STEP\n+   of IV.\n+\n+   We do not use information whether TYPE can overflow so it is safe to\n+   use this test even for derived IVs not computed every iteration or\n+   hypotetical IVs to be inserted into code.  */\n+\n+static bool\n+iv_can_overflow_p (struct loop *loop, tree type, tree base, tree step)\n+{\n+  widest_int nit;\n+  wide_int base_min, base_max, step_min, step_max, type_min, type_max;\n+  signop sgn = TYPE_SIGN (type);\n+\n+  if (integer_zerop (step))\n+    return false;\n+\n+  if (TREE_CODE (base) == INTEGER_CST)\n+    base_min = base_max = base;\n+  else if (TREE_CODE (base) == SSA_NAME\n+\t   && INTEGRAL_TYPE_P (TREE_TYPE (base))\n+\t   && get_range_info (base, &base_min, &base_max) == VR_RANGE)\n+    ;\n+  else\n+    return true;\n+\n+  if (TREE_CODE (step) == INTEGER_CST)\n+    step_min = step_max = step;\n+  else if (TREE_CODE (step) == SSA_NAME\n+\t   && INTEGRAL_TYPE_P (TREE_TYPE (step))\n+\t   && get_range_info (step, &step_min, &step_max) == VR_RANGE)\n+    ;\n+  else\n+    return true;\n+\n+  if (!get_max_loop_iterations (loop, &nit))\n+    return true;\n+\n+  type_min = wi::min_value (type);\n+  type_max = wi::max_value (type);\n+\n+  /* Just sanity check that we don't see values out of the range of the type.\n+     In this case the arithmetics bellow would overflow.  */\n+  gcc_checking_assert (wi::ge_p (base_min, type_min, sgn)\n+\t\t       && wi::le_p (base_max, type_max, sgn));\n+\n+  /* Account the possible increment in the last ieration.  */\n+  bool overflow = false;\n+  nit = wi::add (nit, 1, SIGNED, &overflow);\n+  if (overflow)\n+    return true;\n+\n+  /* NIT is typeless and can exceed the precision of the type.  In this case\n+     overflow is always possible, because we know STEP is non-zero.  */\n+  if (wi::min_precision (nit, UNSIGNED) > TYPE_PRECISION (type))\n+    return true;\n+  wide_int nit2 = wide_int::from (nit, TYPE_PRECISION (type), UNSIGNED);\n+\n+  /* If step can be positive, check that nit*step <= type_max-base.\n+     This can be done by unsigned arithmetic and we only need to watch overflow\n+     in the multiplication. The right hand side can always be represented in\n+     the type.  */\n+  if (sgn == UNSIGNED || !wi::neg_p (step_max))\n+    {\n+      bool overflow = false;\n+      if (wi::gtu_p (wi::mul (step_max, nit2, UNSIGNED, &overflow),\n+\t\t     type_max - base_max)\n+\t  || overflow)\n+\treturn true;\n+    }\n+  /* If step can be negative, check that nit*(-step) <= base_min-type_min.  */\n+  if (sgn == SIGNED && wi::neg_p (step_min))\n+    {\n+      bool overflow = false, overflow2 = false;\n+      if (wi::gtu_p (wi::mul (wi::neg (step_min, &overflow2),\n+\t\t     nit2, UNSIGNED, &overflow),\n+\t\t     base_min - type_min)\n+\t  || overflow || overflow2)\n+        return true;\n+    }\n+\n+  return false;\n+}\n+\n /* Checks whether use of OP in USE_LOOP behaves as a simple affine iv with\n    respect to WRTO_LOOP and returns its base and step in IV if possible\n    (see analyze_scalar_evolution_in_loop for more details on USE_LOOP\n@@ -3377,6 +3462,10 @@ simple_iv (struct loop *wrto_loop, struct loop *use_loop, tree op,\n \n   iv->no_overflow = !folded_casts && nowrap_type_p (type);\n \n+  if (!iv->no_overflow\n+      && !iv_can_overflow_p (wrto_loop, type, iv->base, iv->step))\n+    iv->no_overflow = true;\n+\n   /* Try to simplify iv base:\n \n        (signed T) ((unsigned T)base + step) ;; TREE_TYPE (base) == signed T"}]}