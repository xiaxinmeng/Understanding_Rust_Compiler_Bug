{"sha": "e2c8363087652e9f4d52a5d3e88990a1a2c1cb23", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTJjODM2MzA4NzY1MmU5ZjRkNTJhNWQzZTg4OTkwYTFhMmMxY2IyMw==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@redhat.com", "date": "2011-12-23T22:07:16Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2011-12-23T22:07:16Z"}, "message": "Delete VEC_EXTRACT_EVEN/ODD_EXPR.\n\n\t* tree.def (VEC_EXTRACT_EVEN_EXPR, VEC_EXTRACT_ODD_EXPR): Remove.\n\t* cfgexpand.c (expand_debug_expr): Don't handle them.\n\t* expr.c (expand_expr_real_2): Likewise.\n\t* fold-const.c (fold_binary_loc): Likewise.\n\t* gimple-pretty-print.c (dump_binary_rhs): Likewise.\n\t* tree-cfg.c (verify_gimple_assign_binary): Likewise.\n\t* tree-inline.c (estimate_operator_cost): Likewise.\n\t* tree-pretty-print.c (dump_generic_node): Likewise.\n\t* tree-vect-generic.c (expand_vector_operations_1): Likewise.\n\t* optabs.c (optab_for_tree_code): Likewise.\n\t(can_vec_perm_for_code_p): Remove.\n\t(expand_binop): Don't try it.\n\t(init_optabs): Don't init vec_extract_even/odd_optab.\n\t* genopinit.c (optabs): Likewise.\n\t* optabs.h (OTI_vec_extract_even, OTI_vec_extract_odd): Remove.\n\t(vec_extract_even_optab, vec_extract_odd_optab): Remove.\n\t* tree-vect-data-refs.c (vect_strided_store_supported): Tidy code.\n\t(vect_permute_store_chain): Use TYPE_VECTOR_SUBPARTS instead of\n\tGET_MODE_NUNITS; check vect_gen_perm_mask return value instead of\n\tasserting vect_strided_store_supported.\n\t(vect_strided_load_supported): Use can_vec_perm_p.\n\t(vect_permute_load_chain): Use VEC_PERM_EXPR.\n\n\t* doc/generic.texi (VEC_EXTRACT_EVEN_EXPR): Remove.\n\t(VEC_EXTRACT_ODD_EXPR): Remove.\n\t* doc/md.texi (vec_extract_even, vec_extract_odd): Remove.\n\nFrom-SVN: r182669", "tree": {"sha": "f192a8cf06c285d9663ee9b363012776e9ae394b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f192a8cf06c285d9663ee9b363012776e9ae394b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e2c8363087652e9f4d52a5d3e88990a1a2c1cb23", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e2c8363087652e9f4d52a5d3e88990a1a2c1cb23", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e2c8363087652e9f4d52a5d3e88990a1a2c1cb23", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e2c8363087652e9f4d52a5d3e88990a1a2c1cb23/comments", "author": null, "committer": null, "parents": [{"sha": "ef2361a9e57dacabbf1179f5e5b472ab43d33153", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ef2361a9e57dacabbf1179f5e5b472ab43d33153", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ef2361a9e57dacabbf1179f5e5b472ab43d33153"}], "stats": {"total": 326, "additions": 80, "deletions": 246}, "files": [{"sha": "a5e914a3735dcc172f12ef91ecbf13bde59f235d", "filename": "gcc/ChangeLog", "status": "modified", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e2c8363087652e9f4d52a5d3e88990a1a2c1cb23/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e2c8363087652e9f4d52a5d3e88990a1a2c1cb23/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=e2c8363087652e9f4d52a5d3e88990a1a2c1cb23", "patch": "@@ -1,3 +1,32 @@\n+2011-12-23  Richard Henderson  <rth@redhat.com>\n+\n+\t* tree.def (VEC_EXTRACT_EVEN_EXPR, VEC_EXTRACT_ODD_EXPR): Remove.\n+\t* cfgexpand.c (expand_debug_expr): Don't handle them.\n+\t* expr.c (expand_expr_real_2): Likewise.\n+\t* fold-const.c (fold_binary_loc): Likewise.\n+\t* gimple-pretty-print.c (dump_binary_rhs): Likewise.\n+\t* tree-cfg.c (verify_gimple_assign_binary): Likewise.\n+\t* tree-inline.c (estimate_operator_cost): Likewise.\n+\t* tree-pretty-print.c (dump_generic_node): Likewise.\n+\t* tree-vect-generic.c (expand_vector_operations_1): Likewise.\n+\t* optabs.c (optab_for_tree_code): Likewise.\n+\t(can_vec_perm_for_code_p): Remove.\n+\t(expand_binop): Don't try it.\n+\t(init_optabs): Don't init vec_extract_even/odd_optab.\n+\t* genopinit.c (optabs): Likewise.\n+\t* optabs.h (OTI_vec_extract_even, OTI_vec_extract_odd): Remove.\n+\t(vec_extract_even_optab, vec_extract_odd_optab): Remove.\n+\t* tree-vect-data-refs.c (vect_strided_store_supported): Tidy code.\n+\t(vect_permute_store_chain): Use TYPE_VECTOR_SUBPARTS instead of\n+\tGET_MODE_NUNITS; check vect_gen_perm_mask return value instead of\n+\tasserting vect_strided_store_supported.\n+\t(vect_strided_load_supported): Use can_vec_perm_p.\n+\t(vect_permute_load_chain): Use VEC_PERM_EXPR.\n+\n+\t* doc/generic.texi (VEC_EXTRACT_EVEN_EXPR): Remove.\n+\t(VEC_EXTRACT_ODD_EXPR): Remove.\n+\t* doc/md.texi (vec_extract_even, vec_extract_odd): Remove.\n+\n 2011-12-23  Anatoly Sokolov  <aesok@post.ru>\n \n \t* config/score/score.h (REGISTER_MOVE_COST, MEMORY_MOVE_COST): Remove."}, {"sha": "2b2e464791cf2abf1afd71f1867e5209ed659858", "filename": "gcc/cfgexpand.c", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e2c8363087652e9f4d52a5d3e88990a1a2c1cb23/gcc%2Fcfgexpand.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e2c8363087652e9f4d52a5d3e88990a1a2c1cb23/gcc%2Fcfgexpand.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgexpand.c?ref=e2c8363087652e9f4d52a5d3e88990a1a2c1cb23", "patch": "@@ -3449,8 +3449,6 @@ expand_debug_expr (tree exp)\n     case REDUC_MIN_EXPR:\n     case REDUC_PLUS_EXPR:\n     case VEC_COND_EXPR:\n-    case VEC_EXTRACT_EVEN_EXPR:\n-    case VEC_EXTRACT_ODD_EXPR:\n     case VEC_LSHIFT_EXPR:\n     case VEC_PACK_FIX_TRUNC_EXPR:\n     case VEC_PACK_SAT_EXPR:"}, {"sha": "31e8855bf846cc10297db1c326172e4072db2950", "filename": "gcc/doc/generic.texi", "status": "modified", "additions": 0, "deletions": 9, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e2c8363087652e9f4d52a5d3e88990a1a2c1cb23/gcc%2Fdoc%2Fgeneric.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e2c8363087652e9f4d52a5d3e88990a1a2c1cb23/gcc%2Fdoc%2Fgeneric.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fgeneric.texi?ref=e2c8363087652e9f4d52a5d3e88990a1a2c1cb23", "patch": "@@ -1695,8 +1695,6 @@ its sole argument yields the representation for @code{ap}.\n @tindex VEC_PACK_TRUNC_EXPR\n @tindex VEC_PACK_SAT_EXPR\n @tindex VEC_PACK_FIX_TRUNC_EXPR\n-@tindex VEC_EXTRACT_EVEN_EXPR\n-@tindex VEC_EXTRACT_ODD_EXPR\n \n @table @code\n @item VEC_LSHIFT_EXPR\n@@ -1765,13 +1763,6 @@ of elements of a floating point type.  The result is a vector that contains\n twice as many elements of an integral type whose size is half as wide.  The\n elements of the two vectors are merged (concatenated) to form the output\n vector.\n-\n-@item VEC_EXTRACT_EVEN_EXPR\n-@itemx VEC_EXTRACT_ODD_EXPR\n-These nodes represent extracting of the even/odd elements of the two input\n-vectors, respectively. Their operands and result are vectors that contain the\n-same number of elements of the same type.\n-\n @end table\n \n "}, {"sha": "93183e6f8957e615e70948fa96270697ce725570", "filename": "gcc/doc/md.texi", "status": "modified", "additions": 0, "deletions": 14, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e2c8363087652e9f4d52a5d3e88990a1a2c1cb23/gcc%2Fdoc%2Fmd.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e2c8363087652e9f4d52a5d3e88990a1a2c1cb23/gcc%2Fdoc%2Fmd.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fmd.texi?ref=e2c8363087652e9f4d52a5d3e88990a1a2c1cb23", "patch": "@@ -4145,20 +4145,6 @@ operand 1 is new value of field and operand 2 specify the field index.\n Extract given field from the vector value.  Operand 1 is the vector, operand 2\n specify field index and operand 0 place to store value into.\n \n-@cindex @code{vec_extract_even@var{m}} instruction pattern\n-@item @samp{vec_extract_even@var{m}}\n-Extract even elements from the input vectors (operand 1 and operand 2).\n-The even elements of operand 2 are concatenated to the even elements of operand\n-1 in their original order. The result is stored in operand 0.\n-The output and input vectors should have the same modes.\n-\n-@cindex @code{vec_extract_odd@var{m}} instruction pattern\n-@item @samp{vec_extract_odd@var{m}}\n-Extract odd elements from the input vectors (operand 1 and operand 2).\n-The odd elements of operand 2 are concatenated to the odd elements of operand\n-1 in their original order. The result is stored in operand 0.\n-The output and input vectors should have the same modes.\n-\n @cindex @code{vec_init@var{m}} instruction pattern\n @item @samp{vec_init@var{m}}\n Initialize the vector to given values.  Operand 0 is the vector to initialize"}, {"sha": "c10f91576878144a70860fee0a20958349d3ef8d", "filename": "gcc/expr.c", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e2c8363087652e9f4d52a5d3e88990a1a2c1cb23/gcc%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e2c8363087652e9f4d52a5d3e88990a1a2c1cb23/gcc%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.c?ref=e2c8363087652e9f4d52a5d3e88990a1a2c1cb23", "patch": "@@ -8647,10 +8647,6 @@ expand_expr_real_2 (sepops ops, rtx target, enum machine_mode tmode,\n         return temp;\n       }\n \n-    case VEC_EXTRACT_EVEN_EXPR:\n-    case VEC_EXTRACT_ODD_EXPR:\n-      goto binop;\n-\n     case VEC_LSHIFT_EXPR:\n     case VEC_RSHIFT_EXPR:\n       {"}, {"sha": "5d3196b73775f102b4229cdaf18e1aedf0b3c408", "filename": "gcc/fold-const.c", "status": "modified", "additions": 0, "deletions": 27, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e2c8363087652e9f4d52a5d3e88990a1a2c1cb23/gcc%2Ffold-const.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e2c8363087652e9f4d52a5d3e88990a1a2c1cb23/gcc%2Ffold-const.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffold-const.c?ref=e2c8363087652e9f4d52a5d3e88990a1a2c1cb23", "patch": "@@ -13501,33 +13501,6 @@ fold_binary_loc (location_t loc,\n       /* An ASSERT_EXPR should never be passed to fold_binary.  */\n       gcc_unreachable ();\n \n-    case VEC_EXTRACT_EVEN_EXPR:\n-    case VEC_EXTRACT_ODD_EXPR:\n-      if ((TREE_CODE (arg0) == VECTOR_CST\n-\t   || TREE_CODE (arg0) == CONSTRUCTOR)\n-\t  && (TREE_CODE (arg1) == VECTOR_CST\n-\t      || TREE_CODE (arg1) == CONSTRUCTOR))\n-\t{\n-\t  unsigned int nelts = TYPE_VECTOR_SUBPARTS (type), i;\n-\t  unsigned char *sel = XALLOCAVEC (unsigned char, nelts);\n-\n-\t  for (i = 0; i < nelts; i++)\n-\t    switch (code)\n-\t      {\n-\t      case VEC_EXTRACT_EVEN_EXPR:\n-\t\tsel[i] = i * 2;\n-\t\tbreak;\n-\t      case VEC_EXTRACT_ODD_EXPR:\n-\t\tsel[i] = i * 2 + 1;\n-\t\tbreak;\n-\t      default:\n-\t\tgcc_unreachable ();\n-\t      }\n-\n-\t  return fold_vec_perm (type, arg0, arg1, sel);\n-\t}\n-      return NULL_TREE;\n-\n     case VEC_PACK_TRUNC_EXPR:\n     case VEC_PACK_FIX_TRUNC_EXPR:\n       {"}, {"sha": "baccd452b63884ff1b388212bf3bd647ef52a5f2", "filename": "gcc/genopinit.c", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e2c8363087652e9f4d52a5d3e88990a1a2c1cb23/gcc%2Fgenopinit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e2c8363087652e9f4d52a5d3e88990a1a2c1cb23/gcc%2Fgenopinit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgenopinit.c?ref=e2c8363087652e9f4d52a5d3e88990a1a2c1cb23", "patch": "@@ -267,8 +267,6 @@ static const char * const optabs[] =\n   \"set_direct_optab_handler (atomic_or_optab, $A, CODE_FOR_$(atomic_or$I$a$))\",\n   \"set_optab_handler (vec_set_optab, $A, CODE_FOR_$(vec_set$a$))\",\n   \"set_optab_handler (vec_extract_optab, $A, CODE_FOR_$(vec_extract$a$))\",\n-  \"set_optab_handler (vec_extract_even_optab, $A, CODE_FOR_$(vec_extract_even$a$))\",\n-  \"set_optab_handler (vec_extract_odd_optab, $A, CODE_FOR_$(vec_extract_odd$a$))\",\n   \"set_optab_handler (vec_init_optab, $A, CODE_FOR_$(vec_init$a$))\",\n   \"set_optab_handler (vec_shl_optab, $A, CODE_FOR_$(vec_shl_$a$))\",\n   \"set_optab_handler (vec_shr_optab, $A, CODE_FOR_$(vec_shr_$a$))\","}, {"sha": "3ba7183a553fb12f16433fed9ad8558b4d41b7c7", "filename": "gcc/gimple-pretty-print.c", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e2c8363087652e9f4d52a5d3e88990a1a2c1cb23/gcc%2Fgimple-pretty-print.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e2c8363087652e9f4d52a5d3e88990a1a2c1cb23/gcc%2Fgimple-pretty-print.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-pretty-print.c?ref=e2c8363087652e9f4d52a5d3e88990a1a2c1cb23", "patch": "@@ -345,8 +345,6 @@ dump_binary_rhs (pretty_printer *buffer, gimple gs, int spc, int flags)\n     case VEC_PACK_TRUNC_EXPR:\n     case VEC_PACK_SAT_EXPR:\n     case VEC_PACK_FIX_TRUNC_EXPR:\n-    case VEC_EXTRACT_EVEN_EXPR:\n-    case VEC_EXTRACT_ODD_EXPR:\n     case VEC_WIDEN_LSHIFT_HI_EXPR:\n     case VEC_WIDEN_LSHIFT_LO_EXPR:\n       for (p = tree_code_name [(int) code]; *p; p++)"}, {"sha": "b586eb91626da0e0ec8dbcfd5e60df7147b93f48", "filename": "gcc/optabs.c", "status": "modified", "additions": 0, "deletions": 108, "changes": 108, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e2c8363087652e9f4d52a5d3e88990a1a2c1cb23/gcc%2Foptabs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e2c8363087652e9f4d52a5d3e88990a1a2c1cb23/gcc%2Foptabs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Foptabs.c?ref=e2c8363087652e9f4d52a5d3e88990a1a2c1cb23", "patch": "@@ -547,12 +547,6 @@ optab_for_tree_code (enum tree_code code, const_tree type,\n     case ABS_EXPR:\n       return trapv ? absv_optab : abs_optab;\n \n-    case VEC_EXTRACT_EVEN_EXPR:\n-      return vec_extract_even_optab;\n-\n-    case VEC_EXTRACT_ODD_EXPR:\n-      return vec_extract_odd_optab;\n-\n     default:\n       return NULL;\n     }\n@@ -1600,26 +1594,6 @@ expand_binop (enum machine_mode mode, optab binoptab, rtx op0, rtx op1,\n \t}\n     }\n \n-  /* Certain vector operations can be implemented with vector permutation.  */\n-  if (VECTOR_MODE_P (mode))\n-    {\n-      enum tree_code tcode = ERROR_MARK;\n-      rtx sel;\n-\n-      if (binoptab == vec_extract_even_optab)\n-\ttcode = VEC_EXTRACT_EVEN_EXPR;\n-      else if (binoptab == vec_extract_odd_optab)\n-\ttcode = VEC_EXTRACT_ODD_EXPR;\n-\n-      if (tcode != ERROR_MARK\n-\t  && can_vec_perm_for_code_p (tcode, mode, &sel))\n-\t{\n-\t  temp = expand_vec_perm (mode, op0, op1, sel, target);\n-\t  gcc_assert (temp != NULL);\n-\t  return temp;\n-\t}\n-    }\n-\n   /* Look for a wider mode of the same class for which we think we\n      can open-code the operation.  Check for a widening multiply at the\n      wider mode as well.  */\n@@ -6259,8 +6233,6 @@ init_optabs (void)\n   init_optab (udot_prod_optab, UNKNOWN);\n \n   init_optab (vec_extract_optab, UNKNOWN);\n-  init_optab (vec_extract_even_optab, UNKNOWN);\n-  init_optab (vec_extract_odd_optab, UNKNOWN);\n   init_optab (vec_set_optab, UNKNOWN);\n   init_optab (vec_init_optab, UNKNOWN);\n   init_optab (vec_shl_optab, UNKNOWN);\n@@ -6868,86 +6840,6 @@ can_vec_perm_p (enum machine_mode mode, bool variable,\n   return true;\n }\n \n-/* Return true if we can implement with VEC_PERM_EXPR for this target.\n-   If PSEL is non-null, return the selector for the permutation.  */\n-\n-bool\n-can_vec_perm_for_code_p (enum tree_code code, enum machine_mode mode,\n-\t\t\t rtx *psel)\n-{\n-  bool need_sel_test = false;\n-  enum insn_code icode;\n-\n-  /* If the target doesn't implement a vector mode for the vector type,\n-     then no operations are supported.  */\n-  if (!VECTOR_MODE_P (mode))\n-    return false;\n-\n-  /* Do as many tests as possible without reqiring the selector.  */\n-  icode = direct_optab_handler (vec_perm_optab, mode);\n-  if (icode == CODE_FOR_nothing && GET_MODE_INNER (mode) != QImode)\n-    {\n-      enum machine_mode qimode\n-\t= mode_for_vector (QImode, GET_MODE_SIZE (mode));\n-      if (VECTOR_MODE_P (qimode))\n-\ticode = direct_optab_handler (vec_perm_optab, qimode);\n-    }\n-  if (icode == CODE_FOR_nothing)\n-    {\n-      icode = direct_optab_handler (vec_perm_const_optab, mode);\n-      if (icode != CODE_FOR_nothing\n-\t  && targetm.vectorize.vec_perm_const_ok != NULL)\n-\tneed_sel_test = true;\n-    }\n-  if (icode == CODE_FOR_nothing)\n-    return false;\n-\n-  /* If the selector is required, or if we need to test it, build it.  */\n-  if (psel || need_sel_test)\n-    {\n-      int i, nelt = GET_MODE_NUNITS (mode), alt = 0;\n-      unsigned char *data = XALLOCAVEC (unsigned char, nelt);\n-\n-      switch (code)\n-\t{\n-\tcase VEC_EXTRACT_ODD_EXPR:\n-\t  alt = 1;\n-\t  /* FALLTHRU */\n-\tcase VEC_EXTRACT_EVEN_EXPR:\n-\t  for (i = 0; i < nelt; ++i)\n-\t    data[i] = i * 2 + alt;\n-\t  break;\n-\n-\tdefault:\n-\t  gcc_unreachable ();\n-\t}\n-\n-      if (need_sel_test\n-\t  && !targetm.vectorize.vec_perm_const_ok (mode, data))\n-\treturn false;\n-\n-      if (psel)\n-\t{\n-\t  rtvec vec = rtvec_alloc (nelt);\n-\t  enum machine_mode imode = mode;\n-\n-\t  for (i = 0; i < nelt; ++i)\n-\t    RTVEC_ELT (vec, i) = GEN_INT (data[i]);\n-\n-\t  if (GET_MODE_CLASS (mode) != MODE_VECTOR_INT)\n-\t    {\n-\t      imode = int_mode_for_mode (GET_MODE_INNER (mode));\n-\t      imode = mode_for_vector (imode, nelt);\n-\t      gcc_assert (GET_MODE_CLASS (imode) == MODE_VECTOR_INT);\n-\t    }\n-\n-\t  *psel = gen_rtx_CONST_VECTOR (imode, vec);\n-\t}\n-    }\n-\n-  return true;\n-}\n-\n /* A subroutine of expand_vec_perm for expanding one vec_perm insn.  */\n \n static rtx"}, {"sha": "cc4854dcf48bf3f7a88f4be6a65df2b6019cfc20", "filename": "gcc/optabs.h", "status": "modified", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e2c8363087652e9f4d52a5d3e88990a1a2c1cb23/gcc%2Foptabs.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e2c8363087652e9f4d52a5d3e88990a1a2c1cb23/gcc%2Foptabs.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Foptabs.h?ref=e2c8363087652e9f4d52a5d3e88990a1a2c1cb23", "patch": "@@ -332,9 +332,6 @@ enum optab_index\n   OTI_vec_set,\n   /* Extract specified field of vector operand.  */\n   OTI_vec_extract,\n-  /* Extract even/odd fields of vector operands.  */\n-  OTI_vec_extract_even,\n-  OTI_vec_extract_odd,\n   /* Initialize vector operand.  */\n   OTI_vec_init,\n   /* Whole vector shift. The shift amount is in bits.  */\n@@ -559,8 +556,6 @@ enum optab_index\n \n #define vec_set_optab (&optab_table[OTI_vec_set])\n #define vec_extract_optab (&optab_table[OTI_vec_extract])\n-#define vec_extract_even_optab (&optab_table[OTI_vec_extract_even])\n-#define vec_extract_odd_optab (&optab_table[OTI_vec_extract_odd])\n #define vec_init_optab (&optab_table[OTI_vec_init])\n #define vec_shl_optab (&optab_table[OTI_vec_shl])\n #define vec_shr_optab (&optab_table[OTI_vec_shr])\n@@ -1003,9 +998,6 @@ extern rtx expand_vec_shift_expr (sepops, rtx);\n /* Return tree if target supports vector operations for VEC_PERM_EXPR.  */\n extern bool can_vec_perm_p (enum machine_mode, bool, const unsigned char *);\n \n-/* Return true if target supports vector operations using VEC_PERM_EXPR.  */\n-extern bool can_vec_perm_for_code_p (enum tree_code, enum machine_mode, rtx *);\n-\n /* Generate code for VEC_PERM_EXPR.  */\n extern rtx expand_vec_perm (enum machine_mode, rtx, rtx, rtx, rtx);\n "}, {"sha": "6e1a60403ef9361dcc8e6c6f5791d9e59ee299d7", "filename": "gcc/tree-cfg.c", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e2c8363087652e9f4d52a5d3e88990a1a2c1cb23/gcc%2Ftree-cfg.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e2c8363087652e9f4d52a5d3e88990a1a2c1cb23/gcc%2Ftree-cfg.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-cfg.c?ref=e2c8363087652e9f4d52a5d3e88990a1a2c1cb23", "patch": "@@ -3711,8 +3711,6 @@ verify_gimple_assign_binary (gimple stmt)\n     case VEC_PACK_TRUNC_EXPR:\n     case VEC_PACK_SAT_EXPR:\n     case VEC_PACK_FIX_TRUNC_EXPR:\n-    case VEC_EXTRACT_EVEN_EXPR:\n-    case VEC_EXTRACT_ODD_EXPR:\n       /* FIXME.  */\n       return false;\n "}, {"sha": "c6ae65e7a42b51dec593c3531a83a7ee323f5825", "filename": "gcc/tree-inline.c", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e2c8363087652e9f4d52a5d3e88990a1a2c1cb23/gcc%2Ftree-inline.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e2c8363087652e9f4d52a5d3e88990a1a2c1cb23/gcc%2Ftree-inline.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-inline.c?ref=e2c8363087652e9f4d52a5d3e88990a1a2c1cb23", "patch": "@@ -3399,8 +3399,6 @@ estimate_operator_cost (enum tree_code code, eni_weights *weights,\n     case VEC_PACK_TRUNC_EXPR:\n     case VEC_PACK_SAT_EXPR:\n     case VEC_PACK_FIX_TRUNC_EXPR:\n-    case VEC_EXTRACT_EVEN_EXPR:\n-    case VEC_EXTRACT_ODD_EXPR:\n     case VEC_WIDEN_LSHIFT_HI_EXPR:\n     case VEC_WIDEN_LSHIFT_LO_EXPR:\n "}, {"sha": "4b9b4536641469a999a26fba7201421c4a372989", "filename": "gcc/tree-pretty-print.c", "status": "modified", "additions": 0, "deletions": 16, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e2c8363087652e9f4d52a5d3e88990a1a2c1cb23/gcc%2Ftree-pretty-print.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e2c8363087652e9f4d52a5d3e88990a1a2c1cb23/gcc%2Ftree-pretty-print.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-pretty-print.c?ref=e2c8363087652e9f4d52a5d3e88990a1a2c1cb23", "patch": "@@ -2388,22 +2388,6 @@ dump_generic_node (pretty_printer *buffer, tree node, int spc, int flags,\n       dump_block_node (buffer, node, spc, flags);\n       break;\n \n-    case VEC_EXTRACT_EVEN_EXPR:\n-      pp_string (buffer, \" VEC_EXTRACT_EVEN_EXPR < \");\n-      dump_generic_node (buffer, TREE_OPERAND (node, 0), spc, flags, false);\n-      pp_string (buffer, \", \");\n-      dump_generic_node (buffer, TREE_OPERAND (node, 1), spc, flags, false);\n-      pp_string (buffer, \" > \");\n-      break;\n-\n-    case VEC_EXTRACT_ODD_EXPR:\n-      pp_string (buffer, \" VEC_EXTRACT_ODD_EXPR < \");\n-      dump_generic_node (buffer, TREE_OPERAND (node, 0), spc, flags, false);\n-      pp_string (buffer, \", \");\n-      dump_generic_node (buffer, TREE_OPERAND (node, 1), spc, flags, false);\n-      pp_string (buffer, \" > \");\n-      break;\n-\n     default:\n       NIY;\n     }"}, {"sha": "43f7662e658e24936c9eee39644118e09e7d18cc", "filename": "gcc/tree-vect-data-refs.c", "status": "modified", "additions": 49, "deletions": 37, "changes": 86, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e2c8363087652e9f4d52a5d3e88990a1a2c1cb23/gcc%2Ftree-vect-data-refs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e2c8363087652e9f4d52a5d3e88990a1a2c1cb23/gcc%2Ftree-vect-data-refs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-data-refs.c?ref=e2c8363087652e9f4d52a5d3e88990a1a2c1cb23", "patch": "@@ -3794,15 +3794,13 @@ vect_create_destination_var (tree scalar_dest, tree vectype)\n \n /* Function vect_strided_store_supported.\n \n-   Returns TRUE is INTERLEAVE_HIGH and INTERLEAVE_LOW operations are supported,\n-   and FALSE otherwise.  */\n+   Returns TRUE if interleave high and interleave low permutations\n+   are supported, and FALSE otherwise.  */\n \n bool\n vect_strided_store_supported (tree vectype, unsigned HOST_WIDE_INT count)\n {\n-  enum machine_mode mode;\n-\n-  mode = TYPE_MODE (vectype);\n+  enum machine_mode mode = TYPE_MODE (vectype);\n \n   /* vect_permute_store_chain requires the group size to be a power of two.  */\n   if (exact_log2 (count) == -1)\n@@ -3813,7 +3811,7 @@ vect_strided_store_supported (tree vectype, unsigned HOST_WIDE_INT count)\n       return false;\n     }\n \n-  /* Check that the operation is supported.  */\n+  /* Check that the permutation is supported.  */\n   if (VECTOR_MODE_P (mode))\n     {\n       unsigned int i, nelt = GET_MODE_NUNITS (mode);\n@@ -3923,11 +3921,9 @@ vect_permute_store_chain (VEC(tree,heap) *dr_chain,\n   tree vectype = STMT_VINFO_VECTYPE (vinfo_for_stmt (stmt));\n   tree perm_mask_low, perm_mask_high;\n   unsigned int i, n;\n-  unsigned int j, nelt = GET_MODE_NUNITS (TYPE_MODE (vectype));\n+  unsigned int j, nelt = TYPE_VECTOR_SUBPARTS (vectype);\n   unsigned char *sel = XALLOCAVEC (unsigned char, nelt);\n \n-  gcc_assert (vect_strided_store_supported (vectype, length));\n-\n   *result_chain = VEC_copy (tree, heap, dr_chain);\n \n   for (i = 0, n = nelt / 2; i < n; i++)\n@@ -3936,9 +3932,12 @@ vect_permute_store_chain (VEC(tree,heap) *dr_chain,\n       sel[i * 2 + 1] = i + nelt;\n     }\n   perm_mask_high = vect_gen_perm_mask (vectype, sel);\n+  gcc_assert (perm_mask_high != NULL);\n+\n   for (i = 0; i < nelt; i++)\n     sel[i] += nelt / 2;\n   perm_mask_low = vect_gen_perm_mask (vectype, sel);\n+  gcc_assert (perm_mask_low != NULL);\n \n   for (i = 0, n = exact_log2 (length); i < n; i++)\n     {\n@@ -4246,16 +4245,13 @@ vect_setup_realignment (gimple stmt, gimple_stmt_iterator *gsi,\n \n /* Function vect_strided_load_supported.\n \n-   Returns TRUE is EXTRACT_EVEN and EXTRACT_ODD operations are supported,\n+   Returns TRUE if even and odd permutations are supported,\n    and FALSE otherwise.  */\n \n bool\n vect_strided_load_supported (tree vectype, unsigned HOST_WIDE_INT count)\n {\n-  optab ee_optab, eo_optab;\n-  enum machine_mode mode;\n-\n-  mode = TYPE_MODE (vectype);\n+  enum machine_mode mode = TYPE_MODE (vectype);\n \n   /* vect_permute_load_chain requires the group size to be a power of two.  */\n   if (exact_log2 (count) == -1)\n@@ -4266,18 +4262,22 @@ vect_strided_load_supported (tree vectype, unsigned HOST_WIDE_INT count)\n       return false;\n     }\n \n-  ee_optab = optab_for_tree_code (VEC_EXTRACT_EVEN_EXPR,\n-\t\t\t\t  vectype, optab_default);\n-  eo_optab = optab_for_tree_code (VEC_EXTRACT_ODD_EXPR,\n-\t\t\t\t  vectype, optab_default);\n-  if (ee_optab && eo_optab\n-      && optab_handler (ee_optab, mode) != CODE_FOR_nothing\n-      && optab_handler (eo_optab, mode) != CODE_FOR_nothing)\n-    return true;\n+  /* Check that the permutation is supported.  */\n+  if (VECTOR_MODE_P (mode))\n+    {\n+      unsigned int i, nelt = GET_MODE_NUNITS (mode);\n+      unsigned char *sel = XALLOCAVEC (unsigned char, nelt);\n \n-  if (can_vec_perm_for_code_p (VEC_EXTRACT_EVEN_EXPR, mode, NULL)\n-      && can_vec_perm_for_code_p (VEC_EXTRACT_ODD_EXPR, mode, NULL))\n-    return true;\n+      for (i = 0; i < nelt; i++)\n+\tsel[i] = i * 2;\n+      if (can_vec_perm_p (mode, false, sel))\n+\t{\n+\t  for (i = 0; i < nelt; i++)\n+\t    sel[i] = i * 2 + 1;\n+\t  if (can_vec_perm_p (mode, false, sel))\n+\t    return true;\n+\t}\n+    }\n \n   if (vect_print_dump_info (REPORT_DETAILS))\n     fprintf (vect_dump, \"extract even/odd not supported by target\");\n@@ -4379,17 +4379,28 @@ vect_permute_load_chain (VEC(tree,heap) *dr_chain,\n \t\t\t VEC(tree,heap) **result_chain)\n {\n   tree perm_dest, data_ref, first_vect, second_vect;\n+  tree perm_mask_even, perm_mask_odd;\n   gimple perm_stmt;\n   tree vectype = STMT_VINFO_VECTYPE (vinfo_for_stmt (stmt));\n-  int i;\n-  unsigned int j;\n-\n-  gcc_assert (vect_strided_load_supported (vectype, length));\n+  unsigned int i, j, log_length = exact_log2 (length);\n+  unsigned nelt = TYPE_VECTOR_SUBPARTS (vectype);\n+  unsigned char *sel = XALLOCAVEC (unsigned char, nelt);\n \n   *result_chain = VEC_copy (tree, heap, dr_chain);\n-  for (i = 0; i < exact_log2 (length); i++)\n+\n+  for (i = 0; i < nelt; ++i)\n+    sel[i] = i * 2;\n+  perm_mask_even = vect_gen_perm_mask (vectype, sel);\n+  gcc_assert (perm_mask_even != NULL);\n+\n+  for (i = 0; i < nelt; ++i)\n+    sel[i] = i * 2 + 1;\n+  perm_mask_odd = vect_gen_perm_mask (vectype, sel);\n+  gcc_assert (perm_mask_odd != NULL);\n+\n+  for (i = 0; i < log_length; i++)\n     {\n-      for (j = 0; j < length; j +=2)\n+      for (j = 0; j < length; j += 2)\n \t{\n \t  first_vect = VEC_index (tree, dr_chain, j);\n \t  second_vect = VEC_index (tree, dr_chain, j+1);\n@@ -4399,9 +4410,9 @@ vect_permute_load_chain (VEC(tree,heap) *dr_chain,\n \t  DECL_GIMPLE_REG_P (perm_dest) = 1;\n \t  add_referenced_var (perm_dest);\n \n-\t  perm_stmt = gimple_build_assign_with_ops (VEC_EXTRACT_EVEN_EXPR,\n-\t\t\t\t\t\t    perm_dest, first_vect,\n-\t\t\t\t\t\t    second_vect);\n+\t  perm_stmt = gimple_build_assign_with_ops3 (VEC_PERM_EXPR, perm_dest,\n+\t\t\t\t\t\t     first_vect, second_vect,\n+\t\t\t\t\t\t     perm_mask_even);\n \n \t  data_ref = make_ssa_name (perm_dest, perm_stmt);\n \t  gimple_assign_set_lhs (perm_stmt, data_ref);\n@@ -4415,9 +4426,10 @@ vect_permute_load_chain (VEC(tree,heap) *dr_chain,\n \t  DECL_GIMPLE_REG_P (perm_dest) = 1;\n \t  add_referenced_var (perm_dest);\n \n-\t  perm_stmt = gimple_build_assign_with_ops (VEC_EXTRACT_ODD_EXPR,\n-\t\t\t\t\t\t    perm_dest, first_vect,\n-\t\t\t\t\t\t    second_vect);\n+\t  perm_stmt = gimple_build_assign_with_ops3 (VEC_PERM_EXPR, perm_dest,\n+\t\t\t\t\t\t     first_vect, second_vect,\n+\t\t\t\t\t\t     perm_mask_odd);\n+\n \t  data_ref = make_ssa_name (perm_dest, perm_stmt);\n \t  gimple_assign_set_lhs (perm_stmt, data_ref);\n \t  vect_finish_stmt_generation (stmt, perm_stmt, gsi);"}, {"sha": "9dec8c63770265602c7e0f02d7db5d7fa06f68b3", "filename": "gcc/tree-vect-generic.c", "status": "modified", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e2c8363087652e9f4d52a5d3e88990a1a2c1cb23/gcc%2Ftree-vect-generic.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e2c8363087652e9f4d52a5d3e88990a1a2c1cb23/gcc%2Ftree-vect-generic.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-generic.c?ref=e2c8363087652e9f4d52a5d3e88990a1a2c1cb23", "patch": "@@ -773,13 +773,6 @@ expand_vector_operations_1 (gimple_stmt_iterator *gsi)\n       || code == VIEW_CONVERT_EXPR)\n     return;\n \n-  /* These are only created by the vectorizer, after having queried\n-     the target support.  It's more than just looking at the optab,\n-     and there's no need to do it again.  */\n-  if (code == VEC_EXTRACT_EVEN_EXPR\n-      || code == VEC_EXTRACT_ODD_EXPR)\n-    return;\n-\n   gcc_assert (code != CONVERT_EXPR);\n \n   /* The signedness is determined from input argument.  */"}, {"sha": "4deb16bed0744f274b9c89d6aeefc12f108178a6", "filename": "gcc/tree-vect-stmts.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e2c8363087652e9f4d52a5d3e88990a1a2c1cb23/gcc%2Ftree-vect-stmts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e2c8363087652e9f4d52a5d3e88990a1a2c1cb23/gcc%2Ftree-vect-stmts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-stmts.c?ref=e2c8363087652e9f4d52a5d3e88990a1a2c1cb23", "patch": "@@ -4542,8 +4542,8 @@ vectorizable_load (gimple stmt, gimple_stmt_iterator *gsi, gimple *vec_stmt,\n \n      Then permutation statements are generated:\n \n-     VS5: vx5 = VEC_EXTRACT_EVEN_EXPR < vx0, vx1 >\n-     VS6: vx6 = VEC_EXTRACT_ODD_EXPR < vx0, vx1 >\n+     VS5: vx5 = VEC_PERM_EXPR < vx0, vx1, { 0, 2, ..., i*2 } >\n+     VS6: vx6 = VEC_PERM_EXPR < vx0, vx1, { 1, 3, ..., i*2+1 } >\n        ...\n \n      And they are put in STMT_VINFO_VEC_STMT of the corresponding scalar stmts"}, {"sha": "a30724913880a2c638a531778d154a8a824cf5b4", "filename": "gcc/tree.def", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e2c8363087652e9f4d52a5d3e88990a1a2c1cb23/gcc%2Ftree.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e2c8363087652e9f4d52a5d3e88990a1a2c1cb23/gcc%2Ftree.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.def?ref=e2c8363087652e9f4d52a5d3e88990a1a2c1cb23", "patch": "@@ -1188,10 +1188,6 @@ DEFTREECODE (VEC_PACK_SAT_EXPR, \"vec_pack_sat_expr\", tcc_binary, 2)\n    the output vector.  */\n DEFTREECODE (VEC_PACK_FIX_TRUNC_EXPR, \"vec_pack_fix_trunc_expr\", tcc_binary, 2)\n \n-/* Extract even/odd fields from vectors.  */\n-DEFTREECODE (VEC_EXTRACT_EVEN_EXPR, \"vec_extract_even_expr\", tcc_binary, 2)\n-DEFTREECODE (VEC_EXTRACT_ODD_EXPR, \"vec_extract_odd_expr\", tcc_binary, 2)\n-\n /* Widening vector shift left in bits.\n    Operand 0 is a vector to be shifted with N elements of size S.\n    Operand 1 is an integer shift amount in bits."}]}