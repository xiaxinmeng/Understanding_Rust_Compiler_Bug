{"sha": "8de08f4c8650d8b1b00901d0ada78ffd87a7cfa9", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OGRlMDhmNGM4NjUwZDhiMWIwMDkwMWQwYWRhNzhmZmQ4N2E3Y2ZhOQ==", "commit": {"author": {"name": "Douglas Gregor", "email": "doug.gregor@gmail.com", "date": "2007-07-04T06:32:30Z"}, "committer": {"name": "Doug Gregor", "email": "dgregor@gcc.gnu.org", "date": "2007-07-04T06:32:30Z"}, "message": "tree.c (maybe_canonicalize_argtypes): New.\n\n2007-07-04  Douglas Gregor  <doug.gregor@gmail.com>\n\n\t* tree.c (maybe_canonicalize_argtypes): New.\n\t(build_function_type): Set canonical type.\n\t(build_method_type_directly): Ditto.\n\t(reconstruct_complex_type): Rebuild the METHOD_TYPE node\n\tproperly.\n\t\n2007-07-04  Douglas Gregor  <doug.gregor@gmail.com>\n\n\t* decl.c (build_ptrmemfunc_type): Always use structural equality\n\ttests when comparing pointer-to-member-function types, because the\n\thandling of TYPE_GET_PTRMEMFUNC_TYPE currently defeats canonical\n\ttypes.\n\nFrom-SVN: r126303", "tree": {"sha": "57e6f75b199598a710c4e2a6c1666ad20df96b3c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/57e6f75b199598a710c4e2a6c1666ad20df96b3c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/8de08f4c8650d8b1b00901d0ada78ffd87a7cfa9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8de08f4c8650d8b1b00901d0ada78ffd87a7cfa9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8de08f4c8650d8b1b00901d0ada78ffd87a7cfa9", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8de08f4c8650d8b1b00901d0ada78ffd87a7cfa9/comments", "author": {"login": "DougGregor", "id": 989428, "node_id": "MDQ6VXNlcjk4OTQyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/989428?v=4", "gravatar_id": "", "url": "https://api.github.com/users/DougGregor", "html_url": "https://github.com/DougGregor", "followers_url": "https://api.github.com/users/DougGregor/followers", "following_url": "https://api.github.com/users/DougGregor/following{/other_user}", "gists_url": "https://api.github.com/users/DougGregor/gists{/gist_id}", "starred_url": "https://api.github.com/users/DougGregor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/DougGregor/subscriptions", "organizations_url": "https://api.github.com/users/DougGregor/orgs", "repos_url": "https://api.github.com/users/DougGregor/repos", "events_url": "https://api.github.com/users/DougGregor/events{/privacy}", "received_events_url": "https://api.github.com/users/DougGregor/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "2d1a1007a08a449f45c830d78e955ed9bb2a23ca", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2d1a1007a08a449f45c830d78e955ed9bb2a23ca", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2d1a1007a08a449f45c830d78e955ed9bb2a23ca"}], "stats": {"total": 149, "additions": 133, "deletions": 16}, "files": [{"sha": "abeacc362eff0c9be2a4f8d448911ac6f74fb0b4", "filename": "gcc/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8de08f4c8650d8b1b00901d0ada78ffd87a7cfa9/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8de08f4c8650d8b1b00901d0ada78ffd87a7cfa9/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=8de08f4c8650d8b1b00901d0ada78ffd87a7cfa9", "patch": "@@ -1,3 +1,11 @@\n+2007-07-04  Douglas Gregor  <doug.gregor@gmail.com>\n+\n+\t* tree.c (maybe_canonicalize_argtypes): New.\n+\t(build_function_type): Set canonical type.\n+\t(build_method_type_directly): Ditto.\n+\t(reconstruct_complex_type): Rebuild the METHOD_TYPE node\n+\tproperly.\n+\n 2007-07-03  Andrew Pinski  <andrew_pinski@playstation.sony.com>\n \n \t* tree-ssa-loop-ivopts.c (strip_offset_1): Treat POINTER_PLUS_EXPR"}, {"sha": "1621175b8467d3471130b6074ce7e1c2bc5c28af", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8de08f4c8650d8b1b00901d0ada78ffd87a7cfa9/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8de08f4c8650d8b1b00901d0ada78ffd87a7cfa9/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=8de08f4c8650d8b1b00901d0ada78ffd87a7cfa9", "patch": "@@ -1,3 +1,10 @@\n+2007-07-04  Douglas Gregor  <doug.gregor@gmail.com>\n+\n+\t* decl.c (build_ptrmemfunc_type): Always use structural equality\n+\ttests when comparing pointer-to-member-function types, because the\n+\thandling of TYPE_GET_PTRMEMFUNC_TYPE currently defeats canonical\n+\ttypes.\n+\t\n 2007-07-03  Mark Mitchell  <mark@codesourcery.com>\n \n \t* init.c (build_new): Tweak comment."}, {"sha": "630cec1295f81dcb704f70fd95f2f8cb8203b98d", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8de08f4c8650d8b1b00901d0ada78ffd87a7cfa9/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8de08f4c8650d8b1b00901d0ada78ffd87a7cfa9/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=8de08f4c8650d8b1b00901d0ada78ffd87a7cfa9", "patch": "@@ -6602,10 +6602,10 @@ build_ptrmemfunc_type (tree type)\n      later.  */\n   TYPE_SET_PTRMEMFUNC_TYPE (type, t);\n \n-  if (TYPE_STRUCTURAL_EQUALITY_P (type))\n-    SET_TYPE_STRUCTURAL_EQUALITY (t);\n-  else if (TYPE_CANONICAL (type) != type)\n-    TYPE_CANONICAL (t) = build_ptrmemfunc_type (TYPE_CANONICAL (type));\n+  /* Managing canonical types for the RECORD_TYPE behind a\n+     pointer-to-member function is a nightmare, so use structural\n+     equality for now.  */\n+  SET_TYPE_STRUCTURAL_EQUALITY (t);\n \n   return t;\n }"}, {"sha": "8feaf47ff5283dc070444abd785d72bd1fb4f277", "filename": "gcc/tree.c", "status": "modified", "additions": 114, "deletions": 12, "changes": 126, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8de08f4c8650d8b1b00901d0ada78ffd87a7cfa9/gcc%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8de08f4c8650d8b1b00901d0ada78ffd87a7cfa9/gcc%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.c?ref=8de08f4c8650d8b1b00901d0ada78ffd87a7cfa9", "patch": "@@ -5647,6 +5647,82 @@ get_inner_array_type (tree array)\n   return type;\n }\n \n+/* Computes the canonical argument types from the argument type list\n+   ARGTYPES. \n+\n+   ANY_STRUCTURAL_P points to a boolean that states whether any of the\n+   other types that work with ARGTYPES (e.g., the return type of the\n+   function) are structural. *ANY_STRUCTURAL_P will be set TRUE if any\n+   of those types or any of the argument types in ARGTYPES are\n+   structural.\n+\n+   ANY_NONCANONICAL_P points to a boolean that states whether any of\n+   the other types that work with ARGTYPES (e.g., the return type of\n+   the function) are non-canonical type nodes. *ANY_NONCANONICAL_P\n+   will be set TRUE if any of those types or any of the argument types\n+   in ARGTYPES are non-canonical.\n+\n+   Returns a canonical argument list, which may be ARGTYPES when the\n+   canonical argument list is unneeded (i.e., *ANY_STRUCTURAL_P is\n+   true) or would not differ from ARGTYPES.  */\n+\n+static tree \n+maybe_canonicalize_argtypes(tree argtypes, \n+\t\t\t    bool *any_structural_p,\n+\t\t\t    bool *any_noncanonical_p)\n+{\n+  tree arg;\n+  bool any_noncanonical_argtypes_p = false;\n+  \n+  for (arg = argtypes; arg && !(*any_structural_p); arg = TREE_CHAIN (arg))\n+    {\n+      if (!TREE_VALUE (arg) || TREE_VALUE (arg) == error_mark_node)\n+\t/* Fail gracefully by stating that the type is structural.  */\n+\t*any_structural_p = true;\n+      else if (TYPE_STRUCTURAL_EQUALITY_P (TREE_VALUE (arg)))\n+\t*any_structural_p = true;\n+      else if (TYPE_CANONICAL (TREE_VALUE (arg)) != TREE_VALUE (arg)\n+\t       || TREE_PURPOSE (arg))\n+\t/* If the argument has a default argument, we consider it\n+\t   non-canonical even though the type itself is canonical.\n+\t   That way, different variants of function and method types\n+\t   with default arguments will all point to the variant with\n+\t   no defaults as their canonical type.  */\n+        any_noncanonical_argtypes_p = true;\n+    }\n+\n+  if (*any_structural_p)\n+    return argtypes;\n+\n+  if (any_noncanonical_argtypes_p)\n+    {\n+      /* Build the canonical list of argument types.  */\n+      tree canon_argtypes = NULL_TREE;\n+      bool is_void = false;\n+\n+      for (arg = argtypes; arg; arg = TREE_CHAIN (arg))\n+        {\n+          if (arg == void_list_node)\n+            is_void = true;\n+          else\n+            canon_argtypes = tree_cons (NULL_TREE,\n+                                        TYPE_CANONICAL (TREE_VALUE (arg)),\n+                                        canon_argtypes);\n+        }\n+\n+      canon_argtypes = nreverse (canon_argtypes);\n+      if (is_void)\n+        canon_argtypes = chainon (canon_argtypes, void_list_node);\n+\n+      /* There is a non-canonical type.  */\n+      *any_noncanonical_p = true;\n+      return canon_argtypes;\n+    }\n+\n+  /* The canonical argument types are the same as ARGTYPES.  */\n+  return argtypes;\n+}\n+\n /* Construct, lay out and return\n    the type of functions returning type VALUE_TYPE\n    given arguments of types ARG_TYPES.\n@@ -5659,6 +5735,8 @@ build_function_type (tree value_type, tree arg_types)\n {\n   tree t;\n   hashval_t hashcode = 0;\n+  bool any_structural_p, any_noncanonical_p;\n+  tree canon_argtypes;\n \n   if (TREE_CODE (value_type) == FUNCTION_TYPE)\n     {\n@@ -5671,14 +5749,23 @@ build_function_type (tree value_type, tree arg_types)\n   TREE_TYPE (t) = value_type;\n   TYPE_ARG_TYPES (t) = arg_types;\n \n-  /* We don't have canonicalization of function types, yet. */\n-  SET_TYPE_STRUCTURAL_EQUALITY (t);\n-\n   /* If we already have such a type, use the old one.  */\n   hashcode = iterative_hash_object (TYPE_HASH (value_type), hashcode);\n   hashcode = type_hash_list (arg_types, hashcode);\n   t = type_hash_canon (hashcode, t);\n \n+  /* Set up the canonical type. */\n+  any_structural_p   = TYPE_STRUCTURAL_EQUALITY_P (value_type);\n+  any_noncanonical_p = TYPE_CANONICAL (value_type) != value_type;\n+  canon_argtypes = maybe_canonicalize_argtypes (arg_types, \n+\t\t\t\t\t\t&any_structural_p,\n+\t\t\t\t\t\t&any_noncanonical_p);\n+  if (any_structural_p)\n+    SET_TYPE_STRUCTURAL_EQUALITY (t);\n+  else if (any_noncanonical_p)\n+    TYPE_CANONICAL (t) = build_function_type (TYPE_CANONICAL (value_type),\n+\t\t\t\t\t      canon_argtypes);\n+      \n   if (!COMPLETE_TYPE_P (t))\n     layout_type (t);\n   return t;\n@@ -5728,6 +5815,8 @@ build_method_type_directly (tree basetype,\n   tree t;\n   tree ptype;\n   int hashcode = 0;\n+  bool any_structural_p, any_noncanonical_p;\n+  tree canon_argtypes;\n \n   /* Make a node of the sort we want.  */\n   t = make_node (METHOD_TYPE);\n@@ -5741,15 +5830,29 @@ build_method_type_directly (tree basetype,\n   argtypes = tree_cons (NULL_TREE, ptype, argtypes);\n   TYPE_ARG_TYPES (t) = argtypes;\n \n-  /* We don't have canonicalization of method types yet. */\n-  SET_TYPE_STRUCTURAL_EQUALITY (t);\n-\n   /* If we already have such a type, use the old one.  */\n   hashcode = iterative_hash_object (TYPE_HASH (basetype), hashcode);\n   hashcode = iterative_hash_object (TYPE_HASH (rettype), hashcode);\n   hashcode = type_hash_list (argtypes, hashcode);\n   t = type_hash_canon (hashcode, t);\n \n+  /* Set up the canonical type. */\n+  any_structural_p\n+    = (TYPE_STRUCTURAL_EQUALITY_P (basetype)\n+       || TYPE_STRUCTURAL_EQUALITY_P (rettype));\n+  any_noncanonical_p\n+    = (TYPE_CANONICAL (basetype) != basetype\n+       || TYPE_CANONICAL (rettype) != rettype);\n+  canon_argtypes = maybe_canonicalize_argtypes (TREE_CHAIN (argtypes),\n+\t\t\t\t\t\t&any_structural_p,\n+\t\t\t\t\t\t&any_noncanonical_p);\n+  if (any_structural_p)\n+    SET_TYPE_STRUCTURAL_EQUALITY (t);\n+  else if (any_noncanonical_p)\n+    TYPE_CANONICAL (t) \n+      = build_method_type_directly (TYPE_CANONICAL (basetype),\n+\t\t\t\t    TYPE_CANONICAL (rettype),\n+\t\t\t\t    canon_argtypes);\n   if (!COMPLETE_TYPE_P (t))\n     layout_type (t);\n \n@@ -7329,15 +7432,14 @@ reconstruct_complex_type (tree type, tree bottom)\n     }\n   else if (TREE_CODE (type) == METHOD_TYPE)\n     {\n-      tree argtypes;\n       inner = reconstruct_complex_type (TREE_TYPE (type), bottom);\n       /* The build_method_type_directly() routine prepends 'this' to argument list,\n          so we must compensate by getting rid of it.  */\n-      argtypes = TYPE_ARG_TYPES (type);\n-      outer = build_method_type_directly (TYPE_METHOD_BASETYPE (type),\n-\t\t\t\t\t  inner,\n-\t\t\t\t\t  TYPE_ARG_TYPES (type));\n-      TYPE_ARG_TYPES (outer) = argtypes;\n+      outer \n+\t= build_method_type_directly \n+\t    (TREE_TYPE (TREE_VALUE (TYPE_ARG_TYPES (type))),\n+\t     inner,\n+\t     TREE_CHAIN (TYPE_ARG_TYPES (type)));\n     }\n   else\n     return bottom;"}]}