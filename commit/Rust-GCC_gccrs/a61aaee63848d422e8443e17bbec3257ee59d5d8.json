{"sha": "a61aaee63848d422e8443e17bbec3257ee59d5d8", "node_id": "C_kwDOANBUbNoAKGE2MWFhZWU2Mzg0OGQ0MjJlODQ0M2UxN2JiZWMzMjU3ZWU1OWQ1ZDg", "commit": {"author": {"name": "David Malcolm", "email": "dmalcolm@redhat.com", "date": "2022-02-16T14:06:46Z"}, "committer": {"name": "David Malcolm", "email": "dmalcolm@redhat.com", "date": "2022-02-16T23:48:30Z"}, "message": "analyzer: fixes to free of non-heap detection [PR104560]\n\nPR analyzer/104560 reports various false positives from\n-Wanalyzer-free-of-non-heap seen with rdma-core, on what's\neffectively:\n\n  free (&ptr->field)\n\nwhere in this case \"field\" is the first element of its struct, and thus\n&ptr->field == ptr, and could be on the heap.\n\nThe root cause is due to malloc_state_machine::on_stmt making\n  \"LHS = &EXPR;\"\ntransition LHS from start to non_heap when EXPR is not a MEM_REF;\nthis assumption doesn't hold for the above case.\n\nThis patch eliminates that state transition, instead relying on\nmalloc_state_machine::get_default_state to detect regions known to\nnot be on the heap.\nDoing so fixes the false positive, but eliminates some events relating\nto free-of-alloca identifying the alloca, so the patch also reworks\nfree_of_non_heap to capture which region has been freed, adding\nregion creation events to diagnostic paths, so that the alloca calls\ncan be identified, and using the memory space of the region for more\nprecise wording of the diagnostic.\nThe improvement to malloc_state_machine::get_default_state also\nmeans we now detect attempts to free VLAs, functions and code labels.\n\nIn doing so I spotted that I wasn't adding region creation events for\nregions for global variables, and for cases where an allocation is the\nlast stmt within its basic block, so the patch also fixes these issues.\n\ngcc/analyzer/ChangeLog:\n\tPR analyzer/104560\n\t* diagnostic-manager.cc (diagnostic_manager::build_emission_path):\n\tAdd region creation events for globals of interest.\n\t(null_assignment_sm_context::get_old_program_state): New.\n\t(diagnostic_manager::add_events_for_eedge): Move check for\n\tchanging dynamic extents from PK_BEFORE_STMT case to after the\n\tswitch on the dst_point's kind so that we can emit them for the\n\tfinal stmt in a basic block.\n\t* engine.cc (impl_sm_context::get_old_program_state): New.\n\t* sm-malloc.cc (malloc_state_machine::get_default_state): Rewrite\n\tdetection of m_non_heap to use get_memory_space.\n\t(free_of_non_heap::free_of_non_heap): Add freed_reg param.\n\t(free_of_non_heap::subclass_equal_p): Update for changes to\n\tfields.\n\t(free_of_non_heap::emit): Drop m_kind in favor of\n\tget_memory_space.\n\t(free_of_non_heap::describe_state_change): Remove logic for\n\tdetecting alloca.\n\t(free_of_non_heap::mark_interesting_stuff): Add region-creation of\n\tm_freed_reg.\n\t(free_of_non_heap::get_memory_space): New.\n\t(free_of_non_heap::kind): Drop enum.\n\t(free_of_non_heap::m_freed_reg): New field.\n\t(free_of_non_heap::m_kind): Drop field.\n\t(malloc_state_machine::on_stmt): Drop transition to m_non_heap.\n\t(malloc_state_machine::handle_free_of_non_heap): New function,\n\tsplit out from on_deallocator_call and on_realloc_call, adding\n\tdetection of the freed region.\n\t(malloc_state_machine::on_deallocator_call): Use it.\n\t(malloc_state_machine::on_realloc_call): Likewise.\n\t* sm.h (sm_context::get_old_program_state): New vfunc.\n\ngcc/testsuite/ChangeLog:\n\tPR analyzer/104560\n\t* g++.dg/analyzer/placement-new.C: Update expected wording.\n\t* g++.dg/analyzer/pr100244.C: Likewise.\n\t* gcc.dg/analyzer/attr-malloc-1.c (test_7): Likewise.\n\t* gcc.dg/analyzer/malloc-1.c (test_24): Likewise.\n\t(test_25): Likewise.\n\t(test_26): Likewise.\n\t(test_50a, test_50b, test_50c): New.\n\t* gcc.dg/analyzer/malloc-callbacks.c (test_5): Update expected\n\twording.\n\t* gcc.dg/analyzer/malloc-paths-8.c: Likewise.\n\t* gcc.dg/analyzer/pr104560-1.c: New test.\n\t* gcc.dg/analyzer/pr104560-2.c: New test.\n\t* gcc.dg/analyzer/realloc-1.c (test_7): Updated expected wording.\n\t* gcc.dg/analyzer/vla-1.c (test_2): New.  Prune output from\n\t-Wfree-nonheap-object.\n\nSigned-off-by: David Malcolm <dmalcolm@redhat.com>", "tree": {"sha": "2b0b4a63040799e86211bd329f4c93b2961a1555", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/2b0b4a63040799e86211bd329f4c93b2961a1555"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a61aaee63848d422e8443e17bbec3257ee59d5d8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a61aaee63848d422e8443e17bbec3257ee59d5d8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a61aaee63848d422e8443e17bbec3257ee59d5d8", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a61aaee63848d422e8443e17bbec3257ee59d5d8/comments", "author": {"login": "davidmalcolm", "id": 1553248, "node_id": "MDQ6VXNlcjE1NTMyNDg=", "avatar_url": "https://avatars.githubusercontent.com/u/1553248?v=4", "gravatar_id": "", "url": "https://api.github.com/users/davidmalcolm", "html_url": "https://github.com/davidmalcolm", "followers_url": "https://api.github.com/users/davidmalcolm/followers", "following_url": "https://api.github.com/users/davidmalcolm/following{/other_user}", "gists_url": "https://api.github.com/users/davidmalcolm/gists{/gist_id}", "starred_url": "https://api.github.com/users/davidmalcolm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/davidmalcolm/subscriptions", "organizations_url": "https://api.github.com/users/davidmalcolm/orgs", "repos_url": "https://api.github.com/users/davidmalcolm/repos", "events_url": "https://api.github.com/users/davidmalcolm/events{/privacy}", "received_events_url": "https://api.github.com/users/davidmalcolm/received_events", "type": "User", "site_admin": false}, "committer": {"login": "davidmalcolm", "id": 1553248, "node_id": "MDQ6VXNlcjE1NTMyNDg=", "avatar_url": "https://avatars.githubusercontent.com/u/1553248?v=4", "gravatar_id": "", "url": "https://api.github.com/users/davidmalcolm", "html_url": "https://github.com/davidmalcolm", "followers_url": "https://api.github.com/users/davidmalcolm/followers", "following_url": "https://api.github.com/users/davidmalcolm/following{/other_user}", "gists_url": "https://api.github.com/users/davidmalcolm/gists{/gist_id}", "starred_url": "https://api.github.com/users/davidmalcolm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/davidmalcolm/subscriptions", "organizations_url": "https://api.github.com/users/davidmalcolm/orgs", "repos_url": "https://api.github.com/users/davidmalcolm/repos", "events_url": "https://api.github.com/users/davidmalcolm/events{/privacy}", "received_events_url": "https://api.github.com/users/davidmalcolm/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "24ca97325cab7bc454c785d55f37120fe7ea6f74", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/24ca97325cab7bc454c785d55f37120fe7ea6f74", "html_url": "https://github.com/Rust-GCC/gccrs/commit/24ca97325cab7bc454c785d55f37120fe7ea6f74"}], "stats": {"total": 379, "additions": 262, "deletions": 117}, "files": [{"sha": "680016e94bce910666c6c58c9e59874dd7acf94a", "filename": "gcc/analyzer/diagnostic-manager.cc", "status": "modified", "additions": 70, "deletions": 35, "changes": 105, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a61aaee63848d422e8443e17bbec3257ee59d5d8/gcc%2Fanalyzer%2Fdiagnostic-manager.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a61aaee63848d422e8443e17bbec3257ee59d5d8/gcc%2Fanalyzer%2Fdiagnostic-manager.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fdiagnostic-manager.cc?ref=a61aaee63848d422e8443e17bbec3257ee59d5d8", "patch": "@@ -1272,6 +1272,35 @@ diagnostic_manager::build_emission_path (const path_builder &pb,\n \n   interesting_t interest;\n   pb.get_pending_diagnostic ()->mark_interesting_stuff (&interest);\n+\n+  /* Add region creation events for any globals of interest, at the\n+     beginning of the path.  */\n+  {\n+    for (auto reg : interest.m_region_creation)\n+      switch (reg->get_memory_space ())\n+\t{\n+\tdefault:\n+\t  continue;\n+\tcase MEMSPACE_CODE:\n+\tcase MEMSPACE_GLOBALS:\n+\tcase MEMSPACE_READONLY_DATA:\n+\t  {\n+\t    const region *base_reg = reg->get_base_region ();\n+\t    if (tree decl = base_reg->maybe_get_decl ())\n+\t      if (DECL_P (decl)\n+\t\t  && DECL_SOURCE_LOCATION (decl) != UNKNOWN_LOCATION)\n+\t\t{\n+\t\t  emission_path->add_region_creation_event\n+\t\t    (reg,\n+\t\t     DECL_SOURCE_LOCATION (decl),\n+\t\t     NULL_TREE,\n+\t\t     0);\n+\t\t}\n+\t  }\n+\t}\n+  }\n+\n+  /* Walk EPATH, adding events as appropriate.  */\n   for (unsigned i = 0; i < epath.m_edges.length (); i++)\n     {\n       const exploded_edge *eedge = epath.m_edges[i];\n@@ -1569,6 +1598,11 @@ struct null_assignment_sm_context : public sm_context\n     return NULL_TREE;\n   }\n \n+  const program_state *get_old_program_state () const FINAL OVERRIDE\n+  {\n+    return m_old_state;\n+  }\n+\n   const program_state *m_old_state;\n   const program_state *m_new_state;\n   const gimple *m_stmt;\n@@ -1729,46 +1763,47 @@ diagnostic_manager::add_events_for_eedge (const path_builder &pb,\n \t\t  break;\n \t      }\n \n-\t    /* Look for changes in dynamic extents, which will identify\n-\t       the creation of heap-based regions and alloca regions.  */\n-\t    if (interest)\n-\t      {\n-\t\tconst region_model *src_model = src_state.m_region_model;\n-\t\tconst region_model *dst_model = dst_state.m_region_model;\n-\t\tif (src_model->get_dynamic_extents ()\n-\t\t    != dst_model->get_dynamic_extents ())\n-\t\t{\n-\t\t  unsigned i;\n-\t\t  const region *reg;\n-\t\t  FOR_EACH_VEC_ELT (interest->m_region_creation, i, reg)\n-\t\t    {\n-\t\t      const region *base_reg = reg->get_base_region ();\n-\t\t      const svalue *old_extents\n-\t\t\t= src_model->get_dynamic_extents (base_reg);\n-\t\t      const svalue *new_extents\n-\t\t\t= dst_model->get_dynamic_extents (base_reg);\n-\t\t      if (old_extents == NULL && new_extents != NULL)\n-\t\t\tswitch (base_reg->get_kind ())\n-\t\t\t  {\n-\t\t\t  default:\n-\t\t\t    break;\n-\t\t\t  case RK_HEAP_ALLOCATED:\n-\t\t\t  case RK_ALLOCA:\n-\t\t\t    emission_path->add_region_creation_event\n-\t\t\t      (reg,\n-\t\t\t       src_point.get_location (),\n-\t\t\t       src_point.get_fndecl (),\n-\t\t\t       src_stack_depth);\n-\t\t\t    break;\n-\t\t\t  }\n-\t\t    }\n-\t\t}\n-\t      }\n \t  }\n       }\n       break;\n     }\n \n+  /* Look for changes in dynamic extents, which will identify\n+     the creation of heap-based regions and alloca regions.  */\n+  if (interest)\n+    {\n+      const region_model *src_model = src_state.m_region_model;\n+      const region_model *dst_model = dst_state.m_region_model;\n+      if (src_model->get_dynamic_extents ()\n+\t  != dst_model->get_dynamic_extents ())\n+\t{\n+\t  unsigned i;\n+\t  const region *reg;\n+\t  FOR_EACH_VEC_ELT (interest->m_region_creation, i, reg)\n+\t    {\n+\t      const region *base_reg = reg->get_base_region ();\n+\t      const svalue *old_extents\n+\t\t= src_model->get_dynamic_extents (base_reg);\n+\t      const svalue *new_extents\n+\t\t= dst_model->get_dynamic_extents (base_reg);\n+\t      if (old_extents == NULL && new_extents != NULL)\n+\t\tswitch (base_reg->get_kind ())\n+\t\t  {\n+\t\t  default:\n+\t\t    break;\n+\t\t  case RK_HEAP_ALLOCATED:\n+\t\t  case RK_ALLOCA:\n+\t\t    emission_path->add_region_creation_event\n+\t\t      (reg,\n+\t\t       src_point.get_location (),\n+\t\t       src_point.get_fndecl (),\n+\t\t       src_stack_depth);\n+\t\t    break;\n+\t\t  }\n+\t    }\n+\t}\n+    }\n+\n   if (pb.get_feasibility_problem ()\n       && &pb.get_feasibility_problem ()->m_eedge == &eedge)\n     {"}, {"sha": "f5b85ce102e86b64e6126787c316000cc8fd807f", "filename": "gcc/analyzer/engine.cc", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a61aaee63848d422e8443e17bbec3257ee59d5d8/gcc%2Fanalyzer%2Fengine.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a61aaee63848d422e8443e17bbec3257ee59d5d8/gcc%2Fanalyzer%2Fengine.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fengine.cc?ref=a61aaee63848d422e8443e17bbec3257ee59d5d8", "patch": "@@ -500,6 +500,11 @@ class impl_sm_context : public sm_context\n     return m_unknown_side_effects;\n   }\n \n+  const program_state *get_old_program_state () const FINAL OVERRIDE\n+  {\n+    return m_old_state;\n+  }\n+\n   log_user m_logger;\n   exploded_graph &m_eg;\n   exploded_node *m_enode_for_diag;"}, {"sha": "a5fa60d020bd5548d0e16c79ddbf2ac95beb1b9c", "filename": "gcc/analyzer/sm-malloc.cc", "status": "modified", "additions": 70, "deletions": 64, "changes": 134, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a61aaee63848d422e8443e17bbec3257ee59d5d8/gcc%2Fanalyzer%2Fsm-malloc.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a61aaee63848d422e8443e17bbec3257ee59d5d8/gcc%2Fanalyzer%2Fsm-malloc.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fsm-malloc.cc?ref=a61aaee63848d422e8443e17bbec3257ee59d5d8", "patch": "@@ -356,10 +356,16 @@ class malloc_state_machine : public state_machine\n     if (const region_svalue *ptr = sval->dyn_cast_region_svalue ())\n       {\n \tconst region *reg = ptr->get_pointee ();\n-\tconst region *base_reg = reg->get_base_region ();\n-\tif (base_reg->get_kind () == RK_DECL\n-\t    || base_reg->get_kind () == RK_STRING)\n-\t  return m_non_heap;\n+\tswitch (reg->get_memory_space ())\n+\t  {\n+\t  default:\n+\t    break;\n+\t  case MEMSPACE_CODE:\n+\t  case MEMSPACE_GLOBALS:\n+\t  case MEMSPACE_STACK:\n+\t  case MEMSPACE_READONLY_DATA:\n+\t    return m_non_heap;\n+\t  }\n       }\n     return m_start;\n   }\n@@ -425,6 +431,11 @@ class malloc_state_machine : public state_machine\n \t\t\t  const gcall *call,\n \t\t\t  const deallocator_set *deallocators,\n \t\t\t  bool returns_nonnull = false) const;\n+  void handle_free_of_non_heap (sm_context *sm_ctxt,\n+\t\t\t\tconst supernode *node,\n+\t\t\t\tconst gcall *call,\n+\t\t\t\ttree arg,\n+\t\t\t\tconst deallocator *d) const;\n   void on_deallocator_call (sm_context *sm_ctxt,\n \t\t\t    const supernode *node,\n \t\t\t    const gcall *call,\n@@ -1289,8 +1300,9 @@ class free_of_non_heap : public malloc_diagnostic\n {\n public:\n   free_of_non_heap (const malloc_state_machine &sm, tree arg,\n+\t\t    const region *freed_reg,\n \t\t    const char *funcname)\n-  : malloc_diagnostic (sm, arg), m_funcname (funcname), m_kind (KIND_UNKNOWN)\n+  : malloc_diagnostic (sm, arg), m_freed_reg (freed_reg), m_funcname (funcname)\n   {\n   }\n \n@@ -1300,52 +1312,41 @@ class free_of_non_heap : public malloc_diagnostic\n     FINAL OVERRIDE\n   {\n     const free_of_non_heap &other = (const free_of_non_heap &)base_other;\n-    return (same_tree_p (m_arg, other.m_arg) && m_kind == other.m_kind);\n+    return (same_tree_p (m_arg, other.m_arg)\n+\t    && m_freed_reg == other.m_freed_reg);\n   }\n \n   bool emit (rich_location *rich_loc) FINAL OVERRIDE\n   {\n     auto_diagnostic_group d;\n     diagnostic_metadata m;\n     m.add_cwe (590); /* CWE-590: Free of Memory not on the Heap.  */\n-    switch (m_kind)\n+    switch (get_memory_space ())\n       {\n       default:\n+      case MEMSPACE_HEAP:\n \tgcc_unreachable ();\n-      case KIND_UNKNOWN:\n+      case MEMSPACE_UNKNOWN:\n+      case MEMSPACE_CODE:\n+      case MEMSPACE_GLOBALS:\n+      case MEMSPACE_READONLY_DATA:\n \treturn warning_meta (rich_loc, m, OPT_Wanalyzer_free_of_non_heap,\n \t\t\t     \"%<%s%> of %qE which points to memory\"\n \t\t\t     \" not on the heap\",\n \t\t\t     m_funcname, m_arg);\n \tbreak;\n-      case KIND_ALLOCA:\n+      case MEMSPACE_STACK:\n \treturn warning_meta (rich_loc, m, OPT_Wanalyzer_free_of_non_heap,\n-\t\t\t     \"%<%s%> of memory allocated on the stack by\"\n-\t\t\t     \" %qs (%qE) will corrupt the heap\",\n-\t\t\t     m_funcname, \"alloca\", m_arg);\n+\t\t\t     \"%<%s%> of %qE which points to memory\"\n+\t\t\t     \" on the stack\",\n+\t\t\t     m_funcname, m_arg);\n \tbreak;\n       }\n   }\n \n-  label_text describe_state_change (const evdesc::state_change &change)\n+  label_text describe_state_change (const evdesc::state_change &)\n     FINAL OVERRIDE\n   {\n-    /* Attempt to reconstruct what kind of pointer it is.\n-       (It seems neater for this to be a part of the state, though).  */\n-    if (change.m_expr && TREE_CODE (change.m_expr) == SSA_NAME)\n-      {\n-\tgimple *def_stmt = SSA_NAME_DEF_STMT (change.m_expr);\n-\tif (gcall *call = dyn_cast <gcall *> (def_stmt))\n-\t  {\n-\t    if (is_special_named_call_p (call, \"alloca\", 1)\n-\t\t|| is_special_named_call_p (call, \"__builtin_alloca\", 1))\n-\t      {\n-\t\tm_kind = KIND_ALLOCA;\n-\t\treturn label_text::borrow\n-\t\t  (\"memory is allocated on the stack here\");\n-\t      }\n-\t  }\n-      }\n     return label_text::borrow (\"pointer is from here\");\n   }\n \n@@ -1354,14 +1355,23 @@ class free_of_non_heap : public malloc_diagnostic\n     return ev.formatted_print (\"call to %qs here\", m_funcname);\n   }\n \n+  void mark_interesting_stuff (interesting_t *interest) FINAL OVERRIDE\n+  {\n+    if (m_freed_reg)\n+      interest->add_region_creation (m_freed_reg);\n+  }\n+\n private:\n-  enum kind\n+  enum memory_space get_memory_space () const\n   {\n-    KIND_UNKNOWN,\n-    KIND_ALLOCA\n-  };\n+    if (m_freed_reg)\n+      return m_freed_reg->get_memory_space ();\n+    else\n+      return MEMSPACE_UNKNOWN;\n+  }\n+\n+  const region *m_freed_reg;\n   const char *m_funcname;\n-  enum kind m_kind;\n };\n \n /* struct allocation_state : public state_machine::state.  */\n@@ -1701,26 +1711,6 @@ malloc_state_machine::on_stmt (sm_context *sm_ctxt,\n     if (any_pointer_p (lhs))\n       on_zero_assignment (sm_ctxt, stmt,lhs);\n \n-  /* If we have \"LHS = &EXPR;\" and EXPR is something other than a MEM_REF,\n-     transition LHS from start to non_heap.\n-     Doing it for ADDR_EXPR(MEM_REF()) is likely wrong, and can lead to\n-     unbounded chains of unmergeable sm-state on pointer arithmetic in loops\n-     when optimization is enabled.  */\n-  if (const gassign *assign_stmt = dyn_cast <const gassign *> (stmt))\n-    {\n-      enum tree_code op = gimple_assign_rhs_code (assign_stmt);\n-      if (op == ADDR_EXPR)\n-\t{\n-\t  tree lhs = gimple_assign_lhs (assign_stmt);\n-\t  if (lhs)\n-\t    {\n-\t      tree addr_expr = gimple_assign_rhs1 (assign_stmt);\n-\t      if (TREE_CODE (TREE_OPERAND (addr_expr, 0)) != MEM_REF)\n-\t\tsm_ctxt->on_transition (node, stmt, lhs, m_start, m_non_heap);\n-\t    }\n-\t}\n-    }\n-\n   /* Handle dereferences.  */\n   for (unsigned i = 0; i < gimple_num_ops (stmt); i++)\n     {\n@@ -1789,6 +1779,30 @@ malloc_state_machine::on_allocator_call (sm_context *sm_ctxt,\n     }\n }\n \n+/* Handle deallocations of non-heap pointers.\n+   non-heap -> stop, with warning.  */\n+\n+void\n+malloc_state_machine::handle_free_of_non_heap (sm_context *sm_ctxt,\n+\t\t\t\t\t       const supernode *node,\n+\t\t\t\t\t       const gcall *call,\n+\t\t\t\t\t       tree arg,\n+\t\t\t\t\t       const deallocator *d) const\n+{\n+  tree diag_arg = sm_ctxt->get_diagnostic_tree (arg);\n+  const region *freed_reg = NULL;\n+  if (const program_state *old_state = sm_ctxt->get_old_program_state ())\n+    {\n+      const region_model *old_model = old_state->m_region_model;\n+      const svalue *ptr_sval = old_model->get_rvalue (arg, NULL);\n+      freed_reg = old_model->deref_rvalue (ptr_sval, arg, NULL);\n+    }\n+  sm_ctxt->warn (node, call, arg,\n+\t\t new free_of_non_heap (*this, diag_arg, freed_reg,\n+\t\t\t\t       d->m_name));\n+  sm_ctxt->set_next_state (call, arg, m_stop);\n+}\n+\n void\n malloc_state_machine::on_deallocator_call (sm_context *sm_ctxt,\n \t\t\t\t\t   const supernode *node,\n@@ -1835,11 +1849,7 @@ malloc_state_machine::on_deallocator_call (sm_context *sm_ctxt,\n   else if (state == m_non_heap)\n     {\n       /* non-heap -> stop, with warning.  */\n-      tree diag_arg = sm_ctxt->get_diagnostic_tree (arg);\n-      sm_ctxt->warn (node, call, arg,\n-\t\t     new free_of_non_heap (*this, diag_arg,\n-\t\t\t\t\t   d->m_name));\n-      sm_ctxt->set_next_state (call, arg, m_stop);\n+      handle_free_of_non_heap (sm_ctxt, node, call, arg, d);\n     }\n }\n \n@@ -1894,11 +1904,7 @@ malloc_state_machine::on_realloc_call (sm_context *sm_ctxt,\n   else if (state == m_non_heap)\n     {\n       /* non-heap -> stop, with warning.  */\n-      tree diag_arg = sm_ctxt->get_diagnostic_tree (arg);\n-      sm_ctxt->warn (node, call, arg,\n-\t\t     new free_of_non_heap (*this, diag_arg,\n-\t\t\t\t\t   d->m_name));\n-      sm_ctxt->set_next_state (call, arg, m_stop);\n+      handle_free_of_non_heap (sm_ctxt, node, call, arg, d);\n       if (path_context *path_ctxt = sm_ctxt->get_path_context ())\n \tpath_ctxt->terminate_path ();\n     }"}, {"sha": "7ce1c73e217aa727da9b72b1c83aea59c886abca", "filename": "gcc/analyzer/sm.h", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a61aaee63848d422e8443e17bbec3257ee59d5d8/gcc%2Fanalyzer%2Fsm.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a61aaee63848d422e8443e17bbec3257ee59d5d8/gcc%2Fanalyzer%2Fsm.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fsm.h?ref=a61aaee63848d422e8443e17bbec3257ee59d5d8", "patch": "@@ -274,6 +274,10 @@ class sm_context\n   /* Are we handling an external function with unknown side effects?  */\n   virtual bool unknown_side_effects_p () const { return false; }\n \n+  virtual const program_state *get_old_program_state () const = 0;\n+\n+  const svalue *get_old_svalue (tree expr) const;\n+\n protected:\n   sm_context (int sm_idx, const state_machine &sm)\n   : m_sm_idx (sm_idx), m_sm (sm) {}"}, {"sha": "89055491a4892cf30c0dd86ee53edbe06f40ed1a", "filename": "gcc/testsuite/g++.dg/analyzer/placement-new.C", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a61aaee63848d422e8443e17bbec3257ee59d5d8/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fanalyzer%2Fplacement-new.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a61aaee63848d422e8443e17bbec3257ee59d5d8/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fanalyzer%2Fplacement-new.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fanalyzer%2Fplacement-new.C?ref=a61aaee63848d422e8443e17bbec3257ee59d5d8", "patch": "@@ -20,9 +20,9 @@ void test_2 (void)\n \n void test_3 (void)\n {\n-  char buf[sizeof(int)];\n+  char buf[sizeof(int)]; // { dg-message \"region created on stack here\" }\n   int *p = new(buf) int (42);\n-  delete p; // { dg-warning \"memory not on the heap\" }\n+  delete p; // { dg-warning \"memory on the stack\" }\n }\n \n // { dg-prune-output \"-Wfree-nonheap-object\" }"}, {"sha": "1d5e13dd8658f3941bbc51f691609765f966f00c", "filename": "gcc/testsuite/g++.dg/analyzer/pr100244.C", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a61aaee63848d422e8443e17bbec3257ee59d5d8/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fanalyzer%2Fpr100244.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a61aaee63848d422e8443e17bbec3257ee59d5d8/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fanalyzer%2Fpr100244.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fanalyzer%2Fpr100244.C?ref=a61aaee63848d422e8443e17bbec3257ee59d5d8", "patch": "@@ -11,7 +11,7 @@ struct _Hashtable_alloc {\n   int _M_single_bucket;\n   int *_M_buckets;\n   _Hashtable_alloc () { _M_buckets = &_M_single_bucket; }\n-  ~_Hashtable_alloc () { delete _M_buckets; } // { dg-warning \"not on the heap\" }\n+  ~_Hashtable_alloc () { delete _M_buckets; } // { dg-warning \"on the stack\" }\n };\n \n void"}, {"sha": "e956cf5fda67438e40ab636d392031bb99ac3595", "filename": "gcc/testsuite/gcc.dg/analyzer/attr-malloc-1.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a61aaee63848d422e8443e17bbec3257ee59d5d8/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fattr-malloc-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a61aaee63848d422e8443e17bbec3257ee59d5d8/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fattr-malloc-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fattr-malloc-1.c?ref=a61aaee63848d422e8443e17bbec3257ee59d5d8", "patch": "@@ -70,7 +70,7 @@ void test_6 (struct foo *p)\n void test_7 ()\n {\n   struct foo f;\n-  foo_release (&f); /* { dg-warning \"not on the heap\" \"analyzer\" } */\n+  foo_release (&f); /* { dg-warning \"on the stack\" \"analyzer\" } */\n   /* { dg-warning \"'foo_release' called on unallocated object 'f'\" \"non-analyzer\" { target *-*-* } .-1 } */\n }\n "}, {"sha": "d69a60530eba315337d2cfd940b8c4d46b790445", "filename": "gcc/testsuite/gcc.dg/analyzer/malloc-1.c", "status": "modified", "additions": 25, "deletions": 7, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a61aaee63848d422e8443e17bbec3257ee59d5d8/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fmalloc-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a61aaee63848d422e8443e17bbec3257ee59d5d8/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fmalloc-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fmalloc-1.c?ref=a61aaee63848d422e8443e17bbec3257ee59d5d8", "patch": "@@ -271,23 +271,23 @@ int *test_23a (int n)\n \n int test_24 (void)\n {\n-  void *ptr = __builtin_alloca (sizeof (int)); /* { dg-message \"memory is allocated on the stack here\" } */\n-  free (ptr); /* { dg-warning \"'free' of memory allocated on the stack by 'alloca' \\\\('ptr'\\\\) will corrupt the heap \\\\\\[CWE-590\\\\\\]\" } */\n+  void *ptr = __builtin_alloca (sizeof (int)); /* { dg-message \"region created on stack here\" } */\n+  free (ptr); /* { dg-warning \"'free' of 'ptr' which points to memory on the stack \\\\\\[CWE-590\\\\\\]\" } */\n }\n \n int test_25 (void)\n {\n-  char tmp[100];\n-  void *p = tmp; /* { dg-message \"pointer is from here\" } */\n-  free (p); /* { dg-warning \"'free' of 'p' which points to memory not on the heap \\\\\\[CWE-590\\\\\\]\" } */\n+  char tmp[100]; /* { dg-message \"region created on stack here\" } */\n+  void *p = tmp;\n+  free (p); /* { dg-warning \"'free' of 'p' which points to memory on the stack \\\\\\[CWE-590\\\\\\]\" } */\n   /* TODO: more precise messages here.  */\n }\n \n-char global_buffer[100];\n+char global_buffer[100]; /* { dg-message \"region created here\" } */\n \n int test_26 (void)\n {\n-  void *p = global_buffer; /* { dg-message \"pointer is from here\" } */\n+  void *p = global_buffer;\n   free (p); /* { dg-warning \"'free' of 'p' which points to memory not on the heap \\\\\\[CWE-590\\\\\\]\" } */\n   /* TODO: more precise messages here.  */\n }\n@@ -608,4 +608,22 @@ int test_49 (int i)\n   return x;\n }\n \n+/* Free of function, and of label within function.  */\n+\n+void test_50a (void)\n+{\n+}\n+\n+void test_50b (void)\n+{\n+  free (test_50a); /* { dg-warning \"'free' of '&test_50a' which points to memory not on the heap \\\\\\[CWE-590\\\\\\]\" } */\n+}\n+\n+void test_50c (void)\n+{\n+ my_label:\n+  free (&&my_label); /* { dg-warning \"'free' of '&my_label' which points to memory not on the heap \\\\\\[CWE-590\\\\\\]\" } */\n+}\n+\n+\n /* { dg-prune-output \"\\\\\\[-Wfree-nonheap-object\" } */"}, {"sha": "c79f80d376d64e4928ef60f826ebb103e48dbd7e", "filename": "gcc/testsuite/gcc.dg/analyzer/malloc-callbacks.c", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a61aaee63848d422e8443e17bbec3257ee59d5d8/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fmalloc-callbacks.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a61aaee63848d422e8443e17bbec3257ee59d5d8/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fmalloc-callbacks.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fmalloc-callbacks.c?ref=a61aaee63848d422e8443e17bbec3257ee59d5d8", "patch": "@@ -61,9 +61,8 @@ int *test_5 (void)\n {\n   allocator_t alloc_fn = get_alloca ();\n   deallocator_t dealloc_fn = get_free ();\n-  int *ptr = alloc_fn (sizeof (int)); /* { dg-message \"pointer is from here\" } */\n-  /* TODO: message should read \"memory is allocated on the stack here\".  */\n-  dealloc_fn (ptr); /* { dg-warning \"'free' of 'ptr' which points to memory not on the heap\" } */\n+  int *ptr = alloc_fn (sizeof (int)); /* dg-message \"region created on stack here\" } */\n+  dealloc_fn (ptr); /* { dg-warning \"'free' of 'ptr' which points to memory on the stack\" } */\n }\n \n static void __attribute__((noinline))"}, {"sha": "4988f53b94cbc8d4756813abcfde460db1505ed4", "filename": "gcc/testsuite/gcc.dg/analyzer/malloc-paths-8.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a61aaee63848d422e8443e17bbec3257ee59d5d8/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fmalloc-paths-8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a61aaee63848d422e8443e17bbec3257ee59d5d8/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fmalloc-paths-8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fmalloc-paths-8.c?ref=a61aaee63848d422e8443e17bbec3257ee59d5d8", "patch": "@@ -40,7 +40,7 @@ void test_3 (size_t sz)\n {\n   void *ptr;\n   if (sz <= LIMIT)\n-    ptr = __builtin_alloca (sz); /* { dg-message \"memory is allocated on the stack here\" } */\n+    ptr = __builtin_alloca (sz); /* { dg-message \"region created on stack here\" } */\n   else\n     ptr = malloc (sz);\n \n@@ -49,7 +49,7 @@ void test_3 (size_t sz)\n   /* Bug: the \"sz <= LIMIT\" above should have been \"sz < LIMIT\",\n      so there's a free-of-alloca when sz == LIMIT.  */\n   if (sz >= LIMIT)\n-    free (ptr); /* { dg-warning \"'free' of memory allocated on the stack by 'alloca'\" } */\n+    free (ptr); /* { dg-warning \"'free' of 'ptr' which points to memory on the stack\" } */\n }\n /* { dg-bogus \"leak of 'ptr'\" } */\n /* This can't happen, as \"sz > 1024\" && \"sz <= 1023\" is impossible.  */"}, {"sha": "aeab4b9f06c1f9fe30f3abd746c98ada5576de66", "filename": "gcc/testsuite/gcc.dg/analyzer/pr104560-1.c", "status": "added", "additions": 43, "deletions": 0, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a61aaee63848d422e8443e17bbec3257ee59d5d8/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fpr104560-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a61aaee63848d422e8443e17bbec3257ee59d5d8/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fpr104560-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fpr104560-1.c?ref=a61aaee63848d422e8443e17bbec3257ee59d5d8", "patch": "@@ -0,0 +1,43 @@\n+/* Reduced/adapted from false positive from -Wanalyzer-free-of-non-heap\n+   seen on rdma-core.  */\n+\n+#include <stddef.h>\n+\n+#define check_types_match(expr1, expr2)\t\t\t\\\n+\t((typeof(expr1) *)0 != (typeof(expr2) *)0)\n+\n+#define container_of(member_ptr, containing_type, member)\t\t\\\n+\t ((containing_type *)\t\t\t\t\t\t\\\n+\t  ((char *)(member_ptr)\t\t\t\t\t\t\\\n+\t   - container_off(containing_type, member))\t\t\t\\\n+\t  + check_types_match(*(member_ptr), ((containing_type *)0)->member))\n+\n+#define container_off(containing_type, member)\t\\\n+\toffsetof(containing_type, member)\n+\n+struct ibv_device {\n+\t/* [...snip...] */\n+};\n+\n+struct verbs_device {\n+\tstruct ibv_device device; /* Must be first */\n+\t/* [...snip...] */\n+\tint placeholder;\n+};\n+\n+struct mlx5_device {\n+\tstruct verbs_device verbs_dev;\n+\tint placeholder;\n+};\n+\n+static inline struct mlx5_device *to_mdev(struct ibv_device *ibdev)\n+{\n+\treturn container_of(ibdev, struct mlx5_device, verbs_dev.device);\n+}\n+  \n+static void mlx5_uninit_device(struct verbs_device *verbs_device)\n+{\n+        struct mlx5_device *dev = to_mdev(&verbs_device->device);\n+\n+        __builtin_free(dev); /* { dg-bogus \"not on the heap\" } */\n+}"}, {"sha": "f968a582caa16ca1ed9674918f26a67e47054a59", "filename": "gcc/testsuite/gcc.dg/analyzer/pr104560-2.c", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a61aaee63848d422e8443e17bbec3257ee59d5d8/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fpr104560-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a61aaee63848d422e8443e17bbec3257ee59d5d8/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fpr104560-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fpr104560-2.c?ref=a61aaee63848d422e8443e17bbec3257ee59d5d8", "patch": "@@ -0,0 +1,26 @@\n+struct ibv_device {\n+  /* [...snip...] */\n+  int placeholder;\n+};\n+\n+struct verbs_device {\n+  struct ibv_device device; /* Must be first */\n+  /* [...snip...] */\n+  int placeholder;\n+};\n+\n+struct mlx5_device {\n+  struct verbs_device verbs_dev;\n+  int placeholder;\n+};\n+\n+static inline struct mlx5_device *to_mdev(struct ibv_device *ibdev)\n+{\n+  return (struct mlx5_device *)ibdev;\n+}\n+  \n+static void mlx5_uninit_device(struct verbs_device *verbs_device)\n+{\n+  struct mlx5_device *dev = to_mdev(&verbs_device->device);\n+  __builtin_free(dev); /* { dg-bogus \"not on the heap\" } */\n+}"}, {"sha": "9951e118efeb5d50a78adb413474b3bda8a17659", "filename": "gcc/testsuite/gcc.dg/analyzer/realloc-1.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a61aaee63848d422e8443e17bbec3257ee59d5d8/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Frealloc-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a61aaee63848d422e8443e17bbec3257ee59d5d8/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Frealloc-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Frealloc-1.c?ref=a61aaee63848d422e8443e17bbec3257ee59d5d8", "patch": "@@ -59,8 +59,8 @@ void test_6 (size_t sz)\n \n void *test_7 (size_t sz)\n {\n-  char buf[100];\n-  void *p = realloc (&buf, sz); /* { dg-warning \"'realloc' of '&buf' which points to memory not on the heap\" } */\n+  char buf[100]; /* { dg-message \"region created on stack here\" } */\n+  void *p = realloc (&buf, sz); /* { dg-warning \"'realloc' of '&buf' which points to memory on the stack\" } */\n   return p;  \n }\n "}, {"sha": "9561d742c3a8ed86bf6df743e9caaa3b6a95d151", "filename": "gcc/testsuite/gcc.dg/analyzer/vla-1.c", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a61aaee63848d422e8443e17bbec3257ee59d5d8/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fvla-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a61aaee63848d422e8443e17bbec3257ee59d5d8/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fvla-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fvla-1.c?ref=a61aaee63848d422e8443e17bbec3257ee59d5d8", "patch": "@@ -12,3 +12,12 @@ void test_1 (int n)\n   s.b = 17;\n   __analyzer_eval (s.b == 17); /* { dg-warning \"TRUE\" } */\n }\n+\n+void test_2 (int n)\n+{\n+  int arr[n]; /* { dg-message \"region created on stack here\" } */\n+  __builtin_free (arr); /* { dg-warning \"'free' of '<unknown>' which points to memory on the stack\" } */\n+  // TODO: fix the \"unknown\" here\n+}\n+\n+/* { dg-prune-output \"\\\\\\[-Wfree-nonheap-object\" } */"}]}