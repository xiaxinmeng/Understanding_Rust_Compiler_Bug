{"sha": "2e794ee866f33007c5759bbb3b8d1f970b35adaa", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MmU3OTRlZTg2NmYzMzAwN2M1NzU5YmJiM2I4ZDFmOTcwYjM1YWRhYQ==", "commit": {"author": {"name": "Richard Stallman", "email": "rms@gnu.org", "date": "1993-05-02T12:43:15Z"}, "committer": {"name": "Richard Stallman", "email": "rms@gnu.org", "date": "1993-05-02T12:43:15Z"}, "message": "(record_jump_cond): Use mode of op0 or op1, not MODE,\n\nwhen testing for narrowing or widening subregs.\n\nFrom-SVN: r4301", "tree": {"sha": "ded0d90e309dc81fc04febbb338027d67648afad", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ded0d90e309dc81fc04febbb338027d67648afad"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2e794ee866f33007c5759bbb3b8d1f970b35adaa", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2e794ee866f33007c5759bbb3b8d1f970b35adaa", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2e794ee866f33007c5759bbb3b8d1f970b35adaa", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2e794ee866f33007c5759bbb3b8d1f970b35adaa/comments", "author": null, "committer": null, "parents": [{"sha": "64685ffacf290aca816acc9a044bfa6ea0cc0725", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/64685ffacf290aca816acc9a044bfa6ea0cc0725", "html_url": "https://github.com/Rust-GCC/gccrs/commit/64685ffacf290aca816acc9a044bfa6ea0cc0725"}], "stats": {"total": 17, "additions": 13, "deletions": 4}, "files": [{"sha": "64d55f0abba96733569e5afaaf00b2e7db7b893c", "filename": "gcc/cse.c", "status": "modified", "additions": 13, "deletions": 4, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2e794ee866f33007c5759bbb3b8d1f970b35adaa/gcc%2Fcse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2e794ee866f33007c5759bbb3b8d1f970b35adaa/gcc%2Fcse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcse.c?ref=2e794ee866f33007c5759bbb3b8d1f970b35adaa", "patch": "@@ -5490,8 +5490,10 @@ record_jump_cond (code, mode, op0, op1, reversed_nonequality)\n      true for all smaller modes whether or not there is a SUBREG, but\n      is not worth testing for with no SUBREG.  */\n \n+  /* Note that GET_MODE (op0) may not equal MODE.  */\n   if (code == EQ && GET_CODE (op0) == SUBREG\n-      && GET_MODE_SIZE (mode) > GET_MODE_SIZE (GET_MODE (SUBREG_REG (op0))))\n+      && (GET_MODE_SIZE (GET_MODE (op0))\n+\t  > GET_MODE_SIZE (GET_MODE (SUBREG_REG (op0)))))\n     {\n       enum machine_mode inner_mode = GET_MODE (SUBREG_REG (op0));\n       rtx tem = gen_lowpart_if_possible (inner_mode, op1);\n@@ -5502,7 +5504,8 @@ record_jump_cond (code, mode, op0, op1, reversed_nonequality)\n     }\n \n   if (code == EQ && GET_CODE (op1) == SUBREG\n-      && GET_MODE_SIZE (mode) > GET_MODE_SIZE (GET_MODE (SUBREG_REG (op1))))\n+      && (GET_MODE_SIZE (GET_MODE (op1))\n+\t  > GET_MODE_SIZE (GET_MODE (SUBREG_REG (op1)))))\n     {\n       enum machine_mode inner_mode = GET_MODE (SUBREG_REG (op1));\n       rtx tem = gen_lowpart_if_possible (inner_mode, op0);\n@@ -5515,9 +5518,14 @@ record_jump_cond (code, mode, op0, op1, reversed_nonequality)\n   /* Similarly, if this is an NE comparison, and either is a SUBREG \n      making a smaller mode, we know the whole thing is also NE.  */\n \n+  /* Note that GET_MODE (op0) may not equal MODE;\n+     if we test MODE instead, we can get an infinite recursion\n+     alternating between two modes each wider than MODE.  */\n+\n   if (code == NE && GET_CODE (op0) == SUBREG\n       && subreg_lowpart_p (op0)\n-      && GET_MODE_SIZE (mode) < GET_MODE_SIZE (GET_MODE (SUBREG_REG (op0))))\n+      && (GET_MODE_SIZE (GET_MODE (op0))\n+\t  < GET_MODE_SIZE (GET_MODE (SUBREG_REG (op0)))))\n     {\n       enum machine_mode inner_mode = GET_MODE (SUBREG_REG (op0));\n       rtx tem = gen_lowpart_if_possible (inner_mode, op1);\n@@ -5529,7 +5537,8 @@ record_jump_cond (code, mode, op0, op1, reversed_nonequality)\n \n   if (code == NE && GET_CODE (op1) == SUBREG\n       && subreg_lowpart_p (op1)\n-      && GET_MODE_SIZE (mode) < GET_MODE_SIZE (GET_MODE (SUBREG_REG (op1))))\n+      && (GET_MODE_SIZE (GET_MODE (op1))\n+\t  < GET_MODE_SIZE (GET_MODE (SUBREG_REG (op1)))))\n     {\n       enum machine_mode inner_mode = GET_MODE (SUBREG_REG (op1));\n       rtx tem = gen_lowpart_if_possible (inner_mode, op0);"}]}