{"sha": "3fed2ce96f7ec8ee8603b33ba0426ac40acecf24", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6M2ZlZDJjZTk2ZjdlYzhlZTg2MDNiMzNiYTA0MjZhYzQwYWNlY2YyNA==", "commit": {"author": {"name": "Richard Sandiford", "email": "richard.sandiford@linaro.org", "date": "2017-12-21T07:02:06Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2017-12-21T07:02:06Z"}, "message": "poly_int: find_bswap_or_nop_load\n\nThis patch handles polynomial offsets in find_bswap_or_nop_load,\nwhich could be useful for constant-sized data at a variable offset.\nIt is needed for a later patch to compile.\n\n2017-12-21  Richard Sandiford  <richard.sandiford@linaro.org>\n\t    Alan Hayward  <alan.hayward@arm.com>\n\t    David Sherwood  <david.sherwood@arm.com>\n\ngcc/\n\t* gimple-ssa-stor-merging.c (find_bswap_or_nop_load): Track polynomial\n\toffsets for MEM_REFs.\n\nCo-Authored-By: Alan Hayward <alan.hayward@arm.com>\nCo-Authored-By: David Sherwood <david.sherwood@arm.com>\n\nFrom-SVN: r255929", "tree": {"sha": "fdfa5cbd5b25aa64b8b60ea4bded58e1b91e91ee", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/fdfa5cbd5b25aa64b8b60ea4bded58e1b91e91ee"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3fed2ce96f7ec8ee8603b33ba0426ac40acecf24", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3fed2ce96f7ec8ee8603b33ba0426ac40acecf24", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3fed2ce96f7ec8ee8603b33ba0426ac40acecf24", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3fed2ce96f7ec8ee8603b33ba0426ac40acecf24/comments", "author": null, "committer": null, "parents": [{"sha": "bc83d568345bb3d8210b73f038109a972e7f6f6d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bc83d568345bb3d8210b73f038109a972e7f6f6d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bc83d568345bb3d8210b73f038109a972e7f6f6d"}], "stats": {"total": 31, "additions": 17, "deletions": 14}, "files": [{"sha": "58da0852dde4e6a71f14abf34d9c3af0d90a2ce6", "filename": "gcc/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3fed2ce96f7ec8ee8603b33ba0426ac40acecf24/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3fed2ce96f7ec8ee8603b33ba0426ac40acecf24/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=3fed2ce96f7ec8ee8603b33ba0426ac40acecf24", "patch": "@@ -1,3 +1,10 @@\n+2017-12-21  Richard Sandiford  <richard.sandiford@linaro.org>\n+\t    Alan Hayward  <alan.hayward@arm.com>\n+\t    David Sherwood  <david.sherwood@arm.com>\n+\n+\t* gimple-ssa-stor-merging.c (find_bswap_or_nop_load): Track polynomial\n+\toffsets for MEM_REFs.\n+\n 2017-12-21  Richard Sandiford  <richard.sandiford@linaro.org>\n \t    Alan Hayward  <alan.hayward@arm.com>\n \t    David Sherwood  <david.sherwood@arm.com>"}, {"sha": "0d15ef76c38e4bc3792a57c6412cd39ae4cbeeb2", "filename": "gcc/gimple-ssa-store-merging.c", "status": "modified", "additions": 10, "deletions": 14, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3fed2ce96f7ec8ee8603b33ba0426ac40acecf24/gcc%2Fgimple-ssa-store-merging.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3fed2ce96f7ec8ee8603b33ba0426ac40acecf24/gcc%2Fgimple-ssa-store-merging.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-ssa-store-merging.c?ref=3fed2ce96f7ec8ee8603b33ba0426ac40acecf24", "patch": "@@ -374,35 +374,31 @@ find_bswap_or_nop_load (gimple *stmt, tree ref, struct symbolic_number *n)\n     return false;\n   else if (TREE_CODE (base_addr) == MEM_REF)\n     {\n-      offset_int bit_offset = 0;\n+      poly_offset_int bit_offset = 0;\n       tree off = TREE_OPERAND (base_addr, 1);\n \n       if (!integer_zerop (off))\n \t{\n-\t  offset_int boff, coff = mem_ref_offset (base_addr);\n-\t  boff = coff << LOG2_BITS_PER_UNIT;\n+\t  poly_offset_int boff = mem_ref_offset (base_addr);\n+\t  boff <<= LOG2_BITS_PER_UNIT;\n \t  bit_offset += boff;\n \t}\n \n       base_addr = TREE_OPERAND (base_addr, 0);\n \n       /* Avoid returning a negative bitpos as this may wreak havoc later.  */\n-      if (wi::neg_p (bit_offset))\n+      if (maybe_lt (bit_offset, 0))\n \t{\n-\t  offset_int mask = wi::mask <offset_int> (LOG2_BITS_PER_UNIT, false);\n-\t  offset_int tem = wi::bit_and_not (bit_offset, mask);\n-\t  /* TEM is the bitpos rounded to BITS_PER_UNIT towards -Inf.\n-\t     Subtract it to BIT_OFFSET and add it (scaled) to OFFSET.  */\n-\t  bit_offset -= tem;\n-\t  tem >>= LOG2_BITS_PER_UNIT;\n+\t  tree byte_offset = wide_int_to_tree\n+\t    (sizetype, bits_to_bytes_round_down (bit_offset));\n+\t  bit_offset = num_trailing_bits (bit_offset);\n \t  if (offset)\n-\t    offset = size_binop (PLUS_EXPR, offset,\n-\t\t\t\t    wide_int_to_tree (sizetype, tem));\n+\t    offset = size_binop (PLUS_EXPR, offset, byte_offset);\n \t  else\n-\t    offset = wide_int_to_tree (sizetype, tem);\n+\t    offset = byte_offset;\n \t}\n \n-      bitpos += bit_offset.to_shwi ();\n+      bitpos += bit_offset.force_shwi ();\n     }\n   else\n     base_addr = build_fold_addr_expr (base_addr);"}]}