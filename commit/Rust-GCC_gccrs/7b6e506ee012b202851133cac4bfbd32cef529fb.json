{"sha": "7b6e506ee012b202851133cac4bfbd32cef529fb", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6N2I2ZTUwNmVlMDEyYjIwMjg1MTEzM2NhYzRiZmJkMzJjZWY1MjlmYg==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@redhat.com", "date": "2002-05-25T19:51:43Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2002-05-25T19:51:43Z"}, "message": "configure.in (HAVE_AS_TLS): Add ia64 test.\n\n\t* configure.in (HAVE_AS_TLS): Add ia64 test.\n\t* configure: Rebuild.\n\t* config/ia64/ia64.c (ia64_tls_size_string, ia64_tls_size): New.\n\t(override_options): Set it.\n\t(TARGET_HAVE_TLS): New.\n\t(sdata_symbolic_operand): Look for 's'.\n\t(tls_symbolic_operand): New.\n\t(ia64_expand_load_address): Abort for tls symbols.\n\t(gen_tls_get_addr): New.\n\t(gen_thread_pointer): New.\n\t(ia64_expand_move): Split out from movdi.  Handle tls symbols.\n\t(rtx_needs_barrier): Add new unspecs.\n\t(ia64_encode_section_info): Handle tls symbols.\n\t(ia64_strip_name_encoding): Strip two encoding chars.\n\t* config/ia64/ia64.h (ia64_tls_size, ia64_tls_size_string): New.\n\t(TARGET_TLS14, TARGET_TLS22, TARGET_TLS64): New.\n\t(TARGET_OPTIONS): Add tls-size.\n\t(ENCODE_SECTION_INFO_CHAR): Rename from SDATA_NAME_FLAG_CHAR.\n\t* config/ia64/ia64.md (UNSPEC_LTOFF_DTPMOD, UNSPEC_LTOFF_DTPREL,\n\tUNSPEC_DTPREL, UNSPEC_LTOFF_TPREL, UNSPEC_TPREL, UNSPEC_LD_BASE): New.\n\t(movqi, movhi, movsi, movdi, movti): Use ia64_expand_move.\n\t(movsf, movdf): Likewise.\n\t(movdi_symbolic): Use match_scratch.  Don't split if we won't\n\thave a scratch availiable.\n\t(load_ltoff_dtpmod, load_dtprel, load_dtprel64, load_dtprel22,\n\tadd_dtprel, add_dtprel14, add_dtprel22, load_ltoff_tprel, load_tprel,\n\tload_tprel64, load_tprel22, add_tprel, add_tprel14, add_tprel22): New.\n\t* config/ia64/ia64-protos.h: Update.\n\t* config/ia64/sysv4.h (ASM_OUTPUT_ALIGNED_DECL_LOCAL): Use\n\tsdata_symbolic_operand.\n\t(ASM_OUTPUT_LABELREF): Strip two characters.\n\nFrom-SVN: r53874", "tree": {"sha": "3d10268991489c31ef331c00cfe80ed29bdaac9a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/3d10268991489c31ef331c00cfe80ed29bdaac9a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/7b6e506ee012b202851133cac4bfbd32cef529fb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7b6e506ee012b202851133cac4bfbd32cef529fb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7b6e506ee012b202851133cac4bfbd32cef529fb", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7b6e506ee012b202851133cac4bfbd32cef529fb/comments", "author": null, "committer": null, "parents": [{"sha": "8c1d52a397e0ebed0a96dfab417da25b3af2234d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8c1d52a397e0ebed0a96dfab417da25b3af2234d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8c1d52a397e0ebed0a96dfab417da25b3af2234d"}], "stats": {"total": 691, "additions": 580, "deletions": 111}, "files": [{"sha": "b1c1dd3fb3d550e8ce5865fcbf3d726347d5722b", "filename": "gcc/ChangeLog", "status": "modified", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7b6e506ee012b202851133cac4bfbd32cef529fb/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7b6e506ee012b202851133cac4bfbd32cef529fb/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=7b6e506ee012b202851133cac4bfbd32cef529fb", "patch": "@@ -1,3 +1,37 @@\n+2002-05-25  Richard Henderson  <rth@redhat.com>\n+\n+\t* configure.in (HAVE_AS_TLS): Add ia64 test.\n+\t* configure: Rebuild.\n+\t* config/ia64/ia64.c (ia64_tls_size_string, ia64_tls_size): New.\n+\t(override_options): Set it.\n+\t(TARGET_HAVE_TLS): New.\n+\t(sdata_symbolic_operand): Look for 's'.\n+\t(tls_symbolic_operand): New.\n+\t(ia64_expand_load_address): Abort for tls symbols.\n+\t(gen_tls_get_addr): New.\n+\t(gen_thread_pointer): New.\n+\t(ia64_expand_move): Split out from movdi.  Handle tls symbols.\n+\t(rtx_needs_barrier): Add new unspecs.\n+\t(ia64_encode_section_info): Handle tls symbols.\n+\t(ia64_strip_name_encoding): Strip two encoding chars.\n+\t* config/ia64/ia64.h (ia64_tls_size, ia64_tls_size_string): New.\n+\t(TARGET_TLS14, TARGET_TLS22, TARGET_TLS64): New.\n+\t(TARGET_OPTIONS): Add tls-size.\n+\t(ENCODE_SECTION_INFO_CHAR): Rename from SDATA_NAME_FLAG_CHAR.\n+\t* config/ia64/ia64.md (UNSPEC_LTOFF_DTPMOD, UNSPEC_LTOFF_DTPREL,\n+\tUNSPEC_DTPREL, UNSPEC_LTOFF_TPREL, UNSPEC_TPREL, UNSPEC_LD_BASE): New.\n+\t(movqi, movhi, movsi, movdi, movti): Use ia64_expand_move.\n+\t(movsf, movdf): Likewise.\n+\t(movdi_symbolic): Use match_scratch.  Don't split if we won't\n+\thave a scratch availiable.\n+\t(load_ltoff_dtpmod, load_dtprel, load_dtprel64, load_dtprel22,\n+\tadd_dtprel, add_dtprel14, add_dtprel22, load_ltoff_tprel, load_tprel,\n+\tload_tprel64, load_tprel22, add_tprel, add_tprel14, add_tprel22): New.\n+\t* config/ia64/ia64-protos.h: Update.\n+\t* config/ia64/sysv4.h (ASM_OUTPUT_ALIGNED_DECL_LOCAL): Use\n+\tsdata_symbolic_operand.\n+\t(ASM_OUTPUT_LABELREF): Strip two characters.\n+\n 2002-05-25  Kazu Hirata  <kazu@cs.umass.edu>\n \n \t* combine.c (simplify_set): Remove an unnecessary subreg."}, {"sha": "204740a68e6b7db14a61038d3a73e2fd25d4c04a", "filename": "gcc/config/ia64/ia64-protos.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7b6e506ee012b202851133cac4bfbd32cef529fb/gcc%2Fconfig%2Fia64%2Fia64-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7b6e506ee012b202851133cac4bfbd32cef529fb/gcc%2Fconfig%2Fia64%2Fia64-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fia64%2Fia64-protos.h?ref=7b6e506ee012b202851133cac4bfbd32cef529fb", "patch": "@@ -31,6 +31,7 @@ extern int call_operand PARAMS((rtx, enum machine_mode));\n extern int sdata_symbolic_operand PARAMS((rtx, enum machine_mode));\n extern int got_symbolic_operand PARAMS((rtx, enum machine_mode));\n extern int symbolic_operand PARAMS((rtx, enum machine_mode));\n+extern int tls_symbolic_operand PARAMS((rtx, enum machine_mode));\n extern int function_operand PARAMS((rtx, enum machine_mode));\n extern int setjmp_operand PARAMS((rtx, enum machine_mode));\n extern int move_operand PARAMS((rtx, enum machine_mode));\n@@ -68,6 +69,7 @@ extern int destination_tfmode_operand PARAMS((rtx, enum machine_mode));\n extern int tfreg_or_fp01_operand PARAMS((rtx, enum machine_mode));\n extern int basereg_operand PARAMS((rtx, enum machine_mode));\n \n+extern rtx ia64_expand_move PARAMS ((rtx, rtx));\n extern int ia64_move_ok PARAMS((rtx, rtx));\n extern int ia64_depz_field_mask PARAMS((rtx, rtx));\n extern rtx ia64_gp_save_reg PARAMS((int));"}, {"sha": "1445ae9bea3e9e648b784af926aa221d8d5a9ab9", "filename": "gcc/config/ia64/ia64.c", "status": "modified", "additions": 298, "deletions": 28, "changes": 326, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7b6e506ee012b202851133cac4bfbd32cef529fb/gcc%2Fconfig%2Fia64%2Fia64.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7b6e506ee012b202851133cac4bfbd32cef529fb/gcc%2Fconfig%2Fia64%2Fia64.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fia64%2Fia64.c?ref=7b6e506ee012b202851133cac4bfbd32cef529fb", "patch": "@@ -94,6 +94,13 @@ static const char * const ia64_output_reg_names[8] =\n /* String used with the -mfixed-range= option.  */\n const char *ia64_fixed_range_string;\n \n+/* Determines whether we use adds, addl, or movl to generate our\n+   TLS immediate offsets.  */\n+int ia64_tls_size = 22;\n+\n+/* String used with the -mtls-size= option.  */\n+const char *ia64_tls_size_string;\n+\n /* Determines whether we run our final scheduling pass or not.  We always\n    avoid the normal second scheduling pass.  */\n static int ia64_flag_schedule_insns2;\n@@ -103,6 +110,8 @@ static int ia64_flag_schedule_insns2;\n \n unsigned int ia64_section_threshold;\n \f\n+static rtx gen_tls_get_addr PARAMS ((void));\n+static rtx gen_thread_pointer PARAMS ((void));\n static int find_gr_spill PARAMS ((int));\n static int next_scratch_gr_reg PARAMS ((void));\n static void mark_reg_gr_used_mask PARAMS ((rtx, void *));\n@@ -230,6 +239,11 @@ static const struct attribute_spec ia64_attribute_table[] =\n #undef TARGET_SCHED_REORDER2\n #define TARGET_SCHED_REORDER2 ia64_sched_reorder2\n \n+#ifdef HAVE_AS_TLS\n+#undef TARGET_HAVE_TLS\n+#define TARGET_HAVE_TLS true\n+#endif\n+\n struct gcc_target targetm = TARGET_INITIALIZER;\n \f\n /* Return 1 if OP is a valid operand for the MEM of a CALL insn.  */\n@@ -266,7 +280,10 @@ sdata_symbolic_operand (op, mode)\n       if (CONSTANT_POOL_ADDRESS_P (op))\n \treturn GET_MODE_SIZE (get_pool_mode (op)) <= ia64_section_threshold;\n       else\n-        return XSTR (op, 0)[0] == SDATA_NAME_FLAG_CHAR;\n+\t{\n+\t  const char *str = XSTR (op, 0);\n+          return (str[0] == ENCODE_SECTION_INFO_CHAR && str[1] == 's');\n+\t}\n \n     default:\n       break;\n@@ -340,6 +357,35 @@ symbolic_operand (op, mode)\n   return 0;\n }\n \n+/* Return tls_model if OP refers to a TLS symbol.  */\n+\n+int\n+tls_symbolic_operand (op, mode)\n+     rtx op;\n+     enum machine_mode mode ATTRIBUTE_UNUSED;\n+{\n+  const char *str;\n+\n+  if (GET_CODE (op) != SYMBOL_REF)\n+    return 0;\n+  str = XSTR (op, 0);\n+  if (str[0] != ENCODE_SECTION_INFO_CHAR)\n+    return 0;\n+  switch (str[1])\n+    {\n+    case 'G':\n+      return TLS_MODEL_GLOBAL_DYNAMIC;\n+    case 'L':\n+      return TLS_MODEL_LOCAL_DYNAMIC;\n+    case 'i':\n+      return TLS_MODEL_INITIAL_EXEC;\n+    case 'l':\n+      return TLS_MODEL_LOCAL_EXEC;\n+    }\n+  return 0;\n+}\n+\n+\n /* Return 1 if OP refers to a function.  */\n \n int\n@@ -953,6 +999,9 @@ ia64_expand_load_address (dest, src, scratch)\n   else\n     temp = dest;\n \n+  if (tls_symbolic_operand (src, Pmode))\n+    abort ();\n+\n   if (TARGET_AUTO_PIC)\n     emit_insn (gen_load_gprel64 (temp, src));\n   else if (GET_CODE (src) == SYMBOL_REF && SYMBOL_REF_FLAG (src))\n@@ -995,6 +1044,185 @@ ia64_expand_load_address (dest, src, scratch)\n     emit_move_insn (dest, temp);\n }\n \n+static rtx\n+gen_tls_get_addr ()\n+{\n+  static rtx tga;\n+  if (!tga)\n+    {\n+      tga = init_one_libfunc (\"__tls_get_addr\");\n+      ggc_add_rtx_root (&tga, 1);\n+    }\n+  return tga;\n+}\n+\n+static rtx\n+gen_thread_pointer ()\n+{\n+  static rtx tp;\n+  if (!tp)\n+    {\n+      tp = gen_rtx_REG (Pmode, 13);\n+      RTX_UNCHANGING_P (tp);\n+      ggc_add_rtx_root (&tp, 1);\n+    }\n+  return tp;\n+}\n+\n+rtx\n+ia64_expand_move (op0, op1)\n+     rtx op0, op1;\n+{\n+  enum machine_mode mode = GET_MODE (op0);\n+\n+  if (!reload_in_progress && !reload_completed && !ia64_move_ok (op0, op1))\n+    op1 = force_reg (mode, op1);\n+\n+  if (mode == Pmode)\n+    {\n+      enum tls_model tls_kind;\n+      if ((tls_kind = tls_symbolic_operand (op1, Pmode)))\n+\t{\n+\t  rtx tga_op1, tga_op2, tga_ret, tga_eqv, tmp, insns;\n+\n+\t  switch (tls_kind)\n+\t    {\n+\t    case TLS_MODEL_GLOBAL_DYNAMIC:\n+\t      start_sequence ();\n+\n+\t      tga_op1 = gen_reg_rtx (Pmode);\n+\t      emit_insn (gen_load_ltoff_dtpmod (tga_op1, op1));\n+\t      tga_op1 = gen_rtx_MEM (Pmode, tga_op1);\n+\t      RTX_UNCHANGING_P (tga_op1) = 1;\n+\n+\t      tga_op2 = gen_reg_rtx (Pmode);\n+\t      emit_insn (gen_load_ltoff_dtprel (tga_op2, op1));\n+\t      tga_op2 = gen_rtx_MEM (Pmode, tga_op2);\n+\t      RTX_UNCHANGING_P (tga_op2) = 1;\n+\t      \n+\t      tga_ret = emit_library_call_value (gen_tls_get_addr (), NULL_RTX,\n+\t\t\t\t\t\t LCT_CONST, Pmode, 2, tga_op1,\n+\t\t\t\t\t\t Pmode, tga_op2, Pmode);\n+\n+\t      insns = get_insns ();\n+\t      end_sequence ();\n+\n+\t      emit_libcall_block (insns, op0, tga_ret, op1);\n+\t      return NULL_RTX;\n+\n+\t    case TLS_MODEL_LOCAL_DYNAMIC:\n+\t      /* ??? This isn't the completely proper way to do local-dynamic\n+\t\t If the call to __tls_get_addr is used only by a single symbol,\n+\t\t then we should (somehow) move the dtprel to the second arg\n+\t\t to avoid the extra add.  */\n+\t      start_sequence ();\n+\n+\t      tga_op1 = gen_reg_rtx (Pmode);\n+\t      emit_insn (gen_load_ltoff_dtpmod (tga_op1, op1));\n+\t      tga_op1 = gen_rtx_MEM (Pmode, tga_op1);\n+\t      RTX_UNCHANGING_P (tga_op1) = 1;\n+\n+\t      tga_op2 = const0_rtx;\n+\n+\t      tga_ret = emit_library_call_value (gen_tls_get_addr (), NULL_RTX,\n+\t\t\t\t\t\t LCT_CONST, Pmode, 2, tga_op1,\n+\t\t\t\t\t\t Pmode, tga_op2, Pmode);\n+\n+\t      insns = get_insns ();\n+\t      end_sequence ();\n+\n+\t      tga_eqv = gen_rtx_UNSPEC (Pmode, gen_rtvec (1, const0_rtx),\n+\t\t\t\t\tUNSPEC_LD_BASE);\n+\t      tmp = gen_reg_rtx (Pmode);\n+\t      emit_libcall_block (insns, tmp, tga_ret, tga_eqv);\n+\n+\t      if (register_operand (op0, Pmode))\n+\t\ttga_ret = op0;\n+\t      else\n+\t\ttga_ret = gen_reg_rtx (Pmode);\n+\t      if (TARGET_TLS64)\n+\t\t{\n+\t\t  emit_insn (gen_load_dtprel (tga_ret, op1));\n+\t\t  emit_insn (gen_adddi3 (tga_ret, tmp, tga_ret));\n+\t\t}\n+\t      else\n+\t\temit_insn (gen_add_dtprel (tga_ret, tmp, op1));\n+\t      if (tga_ret == op0)\n+\t\treturn NULL_RTX;\n+\t      op1 = tga_ret;\n+\t      break;\n+\n+\t    case TLS_MODEL_INITIAL_EXEC:\n+\t      tmp = gen_reg_rtx (Pmode);\n+\t      emit_insn (gen_load_ltoff_tprel (tmp, op1));\n+\t      tmp = gen_rtx_MEM (Pmode, tmp);\n+\t      RTX_UNCHANGING_P (tmp) = 1;\n+\t      tmp = force_reg (Pmode, tmp);\n+\n+\t      if (register_operand (op0, Pmode))\n+\t\top1 = op0;\n+\t      else\n+\t\top1 = gen_reg_rtx (Pmode);\n+\t      emit_insn (gen_adddi3 (op1, tmp, gen_thread_pointer ()));\n+\t      if (op1 == op0)\n+\t\treturn NULL_RTX;\n+\t      break;\n+\n+\t    case TLS_MODEL_LOCAL_EXEC:\n+\t      if (register_operand (op0, Pmode))\n+\t\ttmp = op0;\n+\t      else\n+\t\ttmp = gen_reg_rtx (Pmode);\n+\t      if (TARGET_TLS64)\n+\t\t{\n+\t\t  emit_insn (gen_load_tprel (tmp, op1));\n+\t\t  emit_insn (gen_adddi3 (tmp, gen_thread_pointer (), tmp));\n+\t\t}\n+\t      else\n+\t\temit_insn (gen_add_tprel (tmp, gen_thread_pointer (), op1));\n+\t      if (tmp == op0)\n+\t\treturn NULL_RTX;\n+\t      op1 = tmp;\n+\t      break;\n+\n+\t    default:\n+\t      abort ();\n+\t    }\n+\t}\n+      else if (!TARGET_NO_PIC && symbolic_operand (op1, DImode))\n+\t{\n+\t  /* Before optimization starts, delay committing to any particular\n+\t     type of PIC address load.  If this function gets deferred, we\n+\t     may acquire information that changes the value of the\n+\t     sdata_symbolic_operand predicate.\n+\n+\t     But don't delay for function pointers.  Loading a function address\n+\t     actually loads the address of the descriptor not the function.\n+\t     If we represent these as SYMBOL_REFs, then they get cse'd with\n+\t     calls, and we end up with calls to the descriptor address instead\n+\t     of calls to the function address.  Functions are not candidates\n+\t     for sdata anyways.\n+\n+\t     Don't delay for LABEL_REF because the splitter loses REG_LABEL\n+\t     notes.  Don't delay for pool addresses on general principals;\n+\t     they'll never become non-local behind our back.  */\n+\n+\t  if (rtx_equal_function_value_matters\n+\t      && GET_CODE (op1) != LABEL_REF\n+\t      && ! (GET_CODE (op1) == SYMBOL_REF\n+\t\t    && (SYMBOL_REF_FLAG (op1)\n+\t\t\t|| CONSTANT_POOL_ADDRESS_P (op1)\n+\t\t\t|| STRING_POOL_ADDRESS_P (op1))))\n+\t    emit_insn (gen_movdi_symbolic (op0, op1));\n+\t  else\n+\t    ia64_expand_load_address (op0, op1, NULL_RTX);\n+\t  return NULL_RTX;\n+\t}\n+    }\n+\n+  return op1;\n+}\n+\n rtx\n ia64_gp_save_reg (setjmp_p)\n      int setjmp_p;\n@@ -3975,6 +4203,16 @@ ia64_override_options ()\n   if (ia64_fixed_range_string)\n     fix_range (ia64_fixed_range_string);\n \n+  if (ia64_tls_size_string)\n+    {\n+      char *end;\n+      unsigned long tmp = strtoul (ia64_tls_size_string, &end, 10);\n+      if (*end || (tmp != 14 && tmp != 22 && tmp != 64))\n+\terror (\"bad value (%s) for -mtls-size= switch\", ia64_tls_size_string);\n+      else\n+\tia64_tls_size = tmp;\n+    }\n+\n   ia64_flag_schedule_insns2 = flag_schedule_insns_after_reload;\n   flag_schedule_insns_after_reload = 0;\n \n@@ -4595,6 +4833,20 @@ rtx_needs_barrier (x, flags, pred)\n     case UNSPEC:\n       switch (XINT (x, 1))\n \t{\n+\tcase UNSPEC_LTOFF_DTPMOD:\n+\tcase UNSPEC_LTOFF_DTPREL:\n+\tcase UNSPEC_DTPREL:\n+\tcase UNSPEC_LTOFF_TPREL:\n+\tcase UNSPEC_TPREL:\n+\tcase UNSPEC_PRED_REL_MUTEX:\n+\tcase UNSPEC_PIC_CALL:\n+        case UNSPEC_MF:\n+        case UNSPEC_FETCHADD_ACQ:\n+\tcase UNSPEC_BSP_VALUE:\n+\tcase UNSPEC_FLUSHRS:\n+\tcase UNSPEC_BUNDLE_SELECTOR:\n+          break;\n+\n \tcase UNSPEC_GR_SPILL:\n \tcase UNSPEC_GR_RESTORE:\n \t  {\n@@ -4614,15 +4866,6 @@ rtx_needs_barrier (x, flags, pred)\n \t  need_barrier = rtx_needs_barrier (XVECEXP (x, 0, 0), flags, pred);\n \t  break;\n \n-\tcase UNSPEC_PRED_REL_MUTEX:\n-\tcase UNSPEC_PIC_CALL:\n-        case UNSPEC_MF:\n-        case UNSPEC_FETCHADD_ACQ:\n-\tcase UNSPEC_BSP_VALUE:\n-\tcase UNSPEC_FLUSHRS:\n-\tcase UNSPEC_BUNDLE_SELECTOR:\n-          break;\n-\n         case UNSPEC_ADDP4:\n \t  need_barrier = rtx_needs_barrier (XVECEXP (x, 0, 0), flags, pred);\n \t  break;\n@@ -6910,8 +7153,9 @@ ia64_encode_section_info (decl, first)\n      int first ATTRIBUTE_UNUSED;\n {\n   const char *symbol_str;\n-  bool is_local, is_small;\n+  bool is_local;\n   rtx symbol;\n+  char encoding = 0;\n \n   if (TREE_CODE (decl) == FUNCTION_DECL)\n     {\n@@ -6930,40 +7174,66 @@ ia64_encode_section_info (decl, first)\n \n   is_local = (*targetm.binds_local_p) (decl);\n \n+  if (TREE_CODE (decl) == VAR_DECL && DECL_THREAD_LOCAL (decl))\n+    {\n+      enum tls_model kind;\n+      if (!flag_pic)\n+\t{\n+\t  if (is_local)\n+\t    kind = TLS_MODEL_LOCAL_EXEC;\n+\t  else\n+\t    kind = TLS_MODEL_INITIAL_EXEC;\n+\t}\n+      else if (is_local)\n+\tkind = TLS_MODEL_LOCAL_DYNAMIC;\n+      else\n+\tkind = TLS_MODEL_GLOBAL_DYNAMIC;\n+      if (kind < flag_tls_default)\n+\tkind = flag_tls_default;\n+\n+      encoding = \" GLil\"[kind];\n+    }\n   /* Determine if DECL will wind up in .sdata/.sbss.  */\n-  is_small = ia64_in_small_data_p (decl);\n+  else if (is_local && ia64_in_small_data_p (decl))\n+    encoding = 's';\n \n   /* Finally, encode this into the symbol string.  */\n-  if (is_local && is_small)\n+  if (encoding)\n     {\n       char *newstr;\n       size_t len;\n \n-      if (symbol_str[0] == SDATA_NAME_FLAG_CHAR)\n-\treturn;\n+      if (symbol_str[0] == ENCODE_SECTION_INFO_CHAR)\n+\t{\n+\t  if (encoding == symbol_str[1])\n+\t    return;\n+\t  /* ??? Sdata became thread or thread becaome not thread.  Lose.  */\n+\t  abort ();\n+\t}\n \n-      len = strlen (symbol_str) + 1;\n-      newstr = alloca (len + 1);\n-      newstr[0] = SDATA_NAME_FLAG_CHAR;\n-      memcpy (newstr + 1, symbol_str, len);\n+      len = strlen (symbol_str);\n+      newstr = alloca (len + 3);\n+      newstr[0] = ENCODE_SECTION_INFO_CHAR;\n+      newstr[1] = encoding;\n+      memcpy (newstr + 2, symbol_str, len + 1);\n \n-      XSTR (symbol, 0) = ggc_alloc_string (newstr, len);\n+      XSTR (symbol, 0) = ggc_alloc_string (newstr, len + 2);\n     }\n \n-  /* This decl is marked as being in small data/bss but it shouldn't\n-     be; one likely explanation for this is that the decl has been\n-     moved into a different section from the one it was in when\n-     targetm.encode_section_info was first called.  Remove the '@'.  */\n-  else if (symbol_str[0] == SDATA_NAME_FLAG_CHAR)\n-    XSTR (symbol, 0) = ggc_strdup (symbol_str + 1);\n+  /* This decl is marked as being in small data/bss but it shouldn't be;\n+     one likely explanation for this is that the decl has been moved into\n+     a different section from the one it was in when encode_section_info\n+     was first called.  Remove the encoding.  */\n+  else if (symbol_str[0] == ENCODE_SECTION_INFO_CHAR)\n+    XSTR (symbol, 0) = ggc_strdup (symbol_str + 2);\n }\n \n static const char *\n ia64_strip_name_encoding (str)\n      const char *str;\n {\n-  if (str[0] == SDATA_NAME_FLAG_CHAR)\n-    str++;\n+  if (str[0] == ENCODE_SECTION_INFO_CHAR)\n+    str += 2;\n   if (str[0] == '*')\n     str++;\n   return str;"}, {"sha": "d1e0556b128c9acd4c622b158ba44b6ce028c5ba", "filename": "gcc/config/ia64/ia64.h", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7b6e506ee012b202851133cac4bfbd32cef529fb/gcc%2Fconfig%2Fia64%2Fia64.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7b6e506ee012b202851133cac4bfbd32cef529fb/gcc%2Fconfig%2Fia64%2Fia64.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fia64%2Fia64.h?ref=7b6e506ee012b202851133cac4bfbd32cef529fb", "patch": "@@ -109,6 +109,11 @@ extern int target_flags;\n \n #define TARGET_DWARF2_ASM\t(target_flags & MASK_DWARF2_ASM)\n \n+extern int ia64_tls_size;\n+#define TARGET_TLS14\t\t(ia64_tls_size == 14)\n+#define TARGET_TLS22\t\t(ia64_tls_size == 22)\n+#define TARGET_TLS64\t\t(ia64_tls_size == 64)\n+\n /* This macro defines names of command options to set and clear bits in\n    `target_flags'.  Its definition is an initializer with a subgrouping for\n    each command option.  */\n@@ -177,10 +182,13 @@ extern int target_flags;\n    subgrouping for each command option.  */\n \n extern const char *ia64_fixed_range_string;\n+extern const char *ia64_tls_size_string;\n #define TARGET_OPTIONS \\\n {\t\t\t\t\t\t\t\t\t\\\n   { \"fixed-range=\", \t&ia64_fixed_range_string,\t\t\t\\\n       N_(\"Specify range of registers to make fixed\")},\t\t\t\\\n+  { \"tls-size=\",\t&ia64_tls_size_string,\t\t\t\t\\\n+      N_(\"Specify bit size of immediate TLS offsets\")},\t\t\t\\\n }\n \n /* Sometimes certain combinations of command options do not make sense on a\n@@ -1774,7 +1782,7 @@ do {\t\t\t\t\t\t\t\t\t\\\n \n #define BSS_SECTION_ASM_OP \"\\t.bss\"\n \n-#define SDATA_NAME_FLAG_CHAR '@'\n+#define ENCODE_SECTION_INFO_CHAR '@'\n \n #define IA64_DEFAULT_GVALUE 8\n \f"}, {"sha": "8bfffe30c6df27736df8b16d5106498d69412dbb", "filename": "gcc/config/ia64/ia64.md", "status": "modified", "additions": 187, "deletions": 65, "changes": 252, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7b6e506ee012b202851133cac4bfbd32cef529fb/gcc%2Fconfig%2Fia64%2Fia64.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7b6e506ee012b202851133cac4bfbd32cef529fb/gcc%2Fconfig%2Fia64%2Fia64.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fia64%2Fia64.md?ref=7b6e506ee012b202851133cac4bfbd32cef529fb", "patch": "@@ -49,20 +49,28 @@\n ;; ??? Need a better way to describe alternate fp status registers.\n \n (define_constants\n-  [(UNSPEC_GR_SPILL\t\t1)\n-   (UNSPEC_GR_RESTORE\t\t2)\n-   (UNSPEC_FR_SPILL\t\t3)\n-   (UNSPEC_FR_RESTORE\t\t4)\n-   (UNSPEC_FR_RECIP_APPROX\t5)\n-   (UNSPEC_PRED_REL_MUTEX\t7)\n-   (UNSPEC_POPCNT\t\t8)\n-   (UNSPEC_PIC_CALL\t\t9)\n-   (UNSPEC_MF\t\t\t12)\n-   (UNSPEC_CMPXCHG_ACQ\t\t13)\n-   (UNSPEC_FETCHADD_ACQ\t\t19)\n-   (UNSPEC_BSP_VALUE\t\t20)\n-   (UNSPEC_FLUSHRS\t\t21)\n-   (UNSPEC_BUNDLE_SELECTOR\t22)\n+  [; Relocations\n+   (UNSPEC_LTOFF_DTPMOD\t\t0)\n+   (UNSPEC_LTOFF_DTPREL\t\t1)\n+   (UNSPEC_DTPREL\t\t2)\n+   (UNSPEC_LTOFF_TPREL\t\t3)\n+   (UNSPEC_TPREL\t\t4)\n+\n+   (UNSPEC_LD_BASE\t\t9)\n+   (UNSPEC_GR_SPILL\t\t10)\n+   (UNSPEC_GR_RESTORE\t\t11)\n+   (UNSPEC_FR_SPILL\t\t12)\n+   (UNSPEC_FR_RESTORE\t\t13)\n+   (UNSPEC_FR_RECIP_APPROX\t14)\n+   (UNSPEC_PRED_REL_MUTEX\t15)\n+   (UNSPEC_POPCNT\t\t16)\n+   (UNSPEC_PIC_CALL\t\t17)\n+   (UNSPEC_MF\t\t\t18)\n+   (UNSPEC_CMPXCHG_ACQ\t\t19)\n+   (UNSPEC_FETCHADD_ACQ\t\t20)\n+   (UNSPEC_BSP_VALUE\t\t21)\n+   (UNSPEC_FLUSHRS\t\t22)\n+   (UNSPEC_BUNDLE_SELECTOR\t23)\n    (UNSPEC_ADDP4\t\t24)\n    (UNSPEC_PROLOGUE_USE\t\t25)\n   ])\n@@ -72,9 +80,9 @@\n    (UNSPECV_BLOCKAGE\t\t1)\n    (UNSPECV_INSN_GROUP_BARRIER\t2)\n    (UNSPECV_BREAK\t\t3)\n-   (UNSPECV_SET_BSP\t\t5)\n-   (UNSPECV_PSAC_ALL\t\t8)\t; pred.safe_across_calls\n-   (UNSPECV_PSAC_NORMAL\t\t9)\n+   (UNSPECV_SET_BSP\t\t4)\n+   (UNSPECV_PSAC_ALL\t\t5)\t; pred.safe_across_calls\n+   (UNSPECV_PSAC_NORMAL\t\t6)\n   ])\n \f\n ;; ::::::::::::::::::::\n@@ -276,9 +284,10 @@\n \t(match_operand:QI 1 \"general_operand\" \"\"))]\n   \"\"\n {\n-  if (! reload_in_progress && ! reload_completed\n-      && ! ia64_move_ok (operands[0], operands[1]))\n-    operands[1] = force_reg (QImode, operands[1]);\n+  rtx op1 = ia64_expand_move (operands[0], operands[1]);\n+  if (!op1)\n+    DONE;\n+  operands[1] = op1;\n })\n \n (define_insn \"*movqi_internal\"\n@@ -300,9 +309,10 @@\n \t(match_operand:HI 1 \"general_operand\" \"\"))]\n   \"\"\n {\n-  if (! reload_in_progress && ! reload_completed\n-      && ! ia64_move_ok (operands[0], operands[1]))\n-    operands[1] = force_reg (HImode, operands[1]);\n+  rtx op1 = ia64_expand_move (operands[0], operands[1]);\n+  if (!op1)\n+    DONE;\n+  operands[1] = op1;\n })\n \n (define_insn \"*movhi_internal\"\n@@ -324,9 +334,10 @@\n \t(match_operand:SI 1 \"general_operand\" \"\"))]\n   \"\"\n {\n-  if (! reload_in_progress && ! reload_completed\n-      && ! ia64_move_ok (operands[0], operands[1]))\n-    operands[1] = force_reg (SImode, operands[1]);\n+  rtx op1 = ia64_expand_move (operands[0], operands[1]);\n+  if (!op1)\n+    DONE;\n+  operands[1] = op1;\n })\n \n (define_insn \"*movsi_internal\"\n@@ -352,30 +363,10 @@\n \t(match_operand:DI 1 \"general_operand\" \"\"))]\n   \"\"\n {\n-  if (! reload_in_progress && ! reload_completed\n-      && ! ia64_move_ok (operands[0], operands[1]))\n-    operands[1] = force_reg (DImode, operands[1]);\n-  if (! TARGET_NO_PIC && symbolic_operand (operands[1], DImode))\n-    {\n-      /* Before optimization starts, delay committing to any particular\n-\t type of PIC address load.  If this function gets deferred, we\n-\t may acquire information that changes the value of the\n-\t sdata_symbolic_operand predicate.  */\n-      /* But don't delay for function pointers.  Loading a function address\n-\t actually loads the address of the descriptor not the function.\n-\t If we represent these as SYMBOL_REFs, then they get cse'd with\n-\t calls, and we end up with calls to the descriptor address instead of\n-\t calls to the function address.  Functions are not candidates for\n-\t sdata anyways.  */\n-      if (rtx_equal_function_value_matters\n-\t  && ! (GET_CODE (operands[1]) == SYMBOL_REF\n-\t\t&& SYMBOL_REF_FLAG (operands[1])))\n-\temit_insn (gen_movdi_symbolic (operands[0], operands[1],\n-\t\t\t\t       gen_reg_rtx (DImode)));\n-      else\n-        ia64_expand_load_address (operands[0], operands[1], NULL_RTX);\n-      DONE;\n-    }\n+  rtx op1 = ia64_expand_move (operands[0], operands[1]);\n+  if (!op1)\n+    DONE;\n+  operands[1] = op1;\n })\n \n ;; This is used during early compilation to delay the decision on\n@@ -384,19 +375,22 @@\n ;; deferred functions, since we may acquire additional information\n ;; on the variables used in the meantime.\n \n-;; ??? This causes us to lose REG_LABEL notes, because the insn splitter\n-;; does not attempt to preserve any REG_NOTES on the input instruction.\n-\n (define_insn_and_split \"movdi_symbolic\"\n   [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n \t(match_operand:DI 1 \"symbolic_operand\" \"s\"))\n-   (clobber (match_operand:DI  2 \"register_operand\" \"+r\"))\n+   (clobber (match_scratch:DI 2 \"=r\"))\n    (use (reg:DI 1))]\n   \"\"\n   \"* abort ();\"\n-  \"\"\n+  \"!no_new_pseudos || reload_completed\"\n   [(const_int 0)]\n-  { ia64_expand_load_address (operands[0], operands[1], operands[2]); DONE; })\n+{\n+  rtx scratch = operands[2];\n+  if (!reload_completed)\n+    gen_reg_rtx (Pmode);\n+  ia64_expand_load_address (operands[0], operands[1], scratch); \n+  DONE;\n+})\n \n (define_insn \"*movdi_internal\"\n   [(set (match_operand:DI 0 \"destination_operand\"\n@@ -505,6 +499,131 @@\n   \"addl %0 = @ltoff(%1), gp\"\n   [(set_attr \"itanium_class\" \"ialu\")])\n \n+(define_insn \"load_ltoff_dtpmod\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n+\t(plus:DI (reg:DI 1)\n+\t\t (unspec:DI [(match_operand:DI 1 \"symbolic_operand\" \"\")]\n+\t\t\t    UNSPEC_LTOFF_DTPMOD)))]\n+  \"\"\n+  \"addl %0 = @ltoff(@dtpmod(%1)), gp\"\n+  [(set_attr \"itanium_class\" \"ialu\")])\n+\n+(define_insn \"load_ltoff_dtprel\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n+\t(plus:DI (reg:DI 1)\n+\t\t (unspec:DI [(match_operand:DI 1 \"symbolic_operand\" \"\")]\n+\t\t\t    UNSPEC_LTOFF_DTPREL)))]\n+  \"\"\n+  \"addl %0 = @ltoff(@dtprel(%1)), gp\"\n+  [(set_attr \"itanium_class\" \"ialu\")])\n+\n+(define_expand \"load_dtprel\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"\")\n+\t(unspec:DI [(match_operand:DI 1 \"symbolic_operand\" \"\")]\n+\t\t   UNSPEC_DTPREL))]\n+  \"\"\n+  \"\")\n+\n+(define_insn \"*load_dtprel64\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n+\t(unspec:DI [(match_operand:DI 1 \"symbolic_operand\" \"\")]\n+\t\t   UNSPEC_DTPREL))]\n+  \"TARGET_TLS64\"\n+  \"movl %0 = @dtprel(%1)\"\n+  [(set_attr \"itanium_class\" \"long_i\")])\n+\n+(define_insn \"*load_dtprel22\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n+\t(unspec:DI [(match_operand:DI 1 \"symbolic_operand\" \"\")]\n+\t\t   UNSPEC_DTPREL))]\n+  \"\"\n+  \"addl %0 = @dtprel(%1), r0\"\n+  [(set_attr \"itanium_class\" \"ialu\")])\n+\n+(define_expand \"add_dtprel\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"\")\n+\t(plus:DI (match_operand:DI 1 \"register_operand\" \"\")\n+\t\t (unspec:DI [(match_operand:DI 2 \"symbolic_operand\" \"\")]\n+\t\t\t    UNSPEC_DTPREL)))]\n+  \"!TARGET_TLS64\"\n+  \"\")\n+\n+(define_insn \"*add_dtprel14\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n+\t(plus:DI (match_operand:DI 1 \"register_operand\" \"r\")\n+\t\t (unspec:DI [(match_operand:DI 2 \"symbolic_operand\" \"\")]\n+\t\t\t    UNSPEC_DTPREL)))]\n+  \"TARGET_TLS14\"\n+  \"adds %0 = @dtprel(%2), %1\"\n+  [(set_attr \"itanium_class\" \"ialu\")])\n+\n+(define_insn \"*add_dtprel22\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n+\t(plus:DI (match_operand:DI 1 \"register_operand\" \"a\")\n+\t\t (unspec:DI [(match_operand:DI 2 \"symbolic_operand\" \"\")]\n+\t\t\t    UNSPEC_DTPREL)))]\n+  \"TARGET_TLS22\"\n+  \"addl %0 = @dtprel(%2), %1\"\n+  [(set_attr \"itanium_class\" \"ialu\")])\n+\n+(define_insn \"load_ltoff_tprel\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n+\t(plus:DI (reg:DI 1)\n+\t\t (unspec:DI [(match_operand:DI 1 \"symbolic_operand\" \"\")]\n+\t\t\t    UNSPEC_LTOFF_TPREL)))]\n+  \"\"\n+  \"addl %0 = @ltoff(@tprel(%1)), gp\"\n+  [(set_attr \"itanium_class\" \"ialu\")])\n+\n+(define_expand \"load_tprel\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"\")\n+\t(unspec:DI [(match_operand:DI 1 \"symbolic_operand\" \"\")]\n+\t\t   UNSPEC_TPREL))]\n+  \"\"\n+  \"\")\n+\n+(define_insn \"*load_tprel64\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n+\t(unspec:DI [(match_operand:DI 1 \"symbolic_operand\" \"\")]\n+\t\t   UNSPEC_TPREL))]\n+  \"TARGET_TLS64\"\n+  \"movl %0 = @tprel(%1)\"\n+  [(set_attr \"itanium_class\" \"long_i\")])\n+\n+(define_insn \"*load_tprel22\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n+\t(unspec:DI [(match_operand:DI 1 \"symbolic_operand\" \"\")]\n+\t\t   UNSPEC_TPREL))]\n+  \"\"\n+  \"addl %0 = @tprel(%1), r0\"\n+  [(set_attr \"itanium_class\" \"ialu\")])\n+\n+(define_expand \"add_tprel\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"\")\n+\t(plus:DI (match_operand:DI 1 \"register_operand\" \"\")\n+\t\t (unspec:DI [(match_operand:DI 2 \"symbolic_operand\" \"\")]\n+\t\t\t    UNSPEC_TPREL)))]\n+  \"!TARGET_TLS64\"\n+  \"\")\n+\n+(define_insn \"*add_tprel14\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n+\t(plus:DI (match_operand:DI 1 \"register_operand\" \"r\")\n+\t\t (unspec:DI [(match_operand:DI 2 \"symbolic_operand\" \"\")]\n+\t\t\t    UNSPEC_TPREL)))]\n+  \"TARGET_TLS14\"\n+  \"adds %0 = @tprel(%2), %1\"\n+  [(set_attr \"itanium_class\" \"ialu\")])\n+\n+(define_insn \"*add_tprel22\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n+\t(plus:DI (match_operand:DI 1 \"register_operand\" \"a\")\n+\t\t (unspec:DI [(match_operand:DI 2 \"symbolic_operand\" \"\")]\n+\t\t\t    UNSPEC_TPREL)))]\n+  \"TARGET_TLS22\"\n+  \"addl %0 = @tprel(%2), %1\"\n+  [(set_attr \"itanium_class\" \"ialu\")])\n+\n ;; With no offsettable memory references, we've got to have a scratch\n ;; around to play with the second word.\n (define_expand \"movti\"\n@@ -513,9 +632,10 @@\n \t      (clobber (match_scratch:DI 2 \"\"))])]\n   \"\"\n {\n-  if (! reload_in_progress && ! reload_completed\n-      && ! ia64_move_ok (operands[0], operands[1]))\n-    operands[1] = force_reg (TImode, operands[1]);\n+  rtx op1 = ia64_expand_move (operands[0], operands[1]);\n+  if (!op1)\n+    DONE;\n+  operands[1] = op1;\n })\n \n (define_insn_and_split \"*movti_internal\"\n@@ -630,9 +750,10 @@\n \t(match_operand:SF 1 \"general_operand\" \"\"))]\n   \"\"\n {\n-  if (! reload_in_progress && ! reload_completed\n-      && ! ia64_move_ok (operands[0], operands[1]))\n-    operands[1] = force_reg (SFmode, operands[1]);\n+  rtx op1 = ia64_expand_move (operands[0], operands[1]);\n+  if (!op1)\n+    DONE;\n+  operands[1] = op1;\n })\n \n (define_insn \"*movsf_internal\"\n@@ -655,9 +776,10 @@\n \t(match_operand:DF 1 \"general_operand\" \"\"))]\n   \"\"\n {\n-  if (! reload_in_progress && ! reload_completed\n-      && ! ia64_move_ok (operands[0], operands[1]))\n-    operands[1] = force_reg (DFmode, operands[1]);\n+  rtx op1 = ia64_expand_move (operands[0], operands[1]);\n+  if (!op1)\n+    DONE;\n+  operands[1] = op1;\n })\n \n (define_insn \"*movdf_internal\""}, {"sha": "164beba04f77e63c710f7a184ef6719503d6c214", "filename": "gcc/config/ia64/sysv4.h", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7b6e506ee012b202851133cac4bfbd32cef529fb/gcc%2Fconfig%2Fia64%2Fsysv4.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7b6e506ee012b202851133cac4bfbd32cef529fb/gcc%2Fconfig%2Fia64%2Fsysv4.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fia64%2Fsysv4.h?ref=7b6e506ee012b202851133cac4bfbd32cef529fb", "patch": "@@ -42,8 +42,7 @@ extern int size_directive_output;\n #undef ASM_OUTPUT_ALIGNED_LOCAL\n #define ASM_OUTPUT_ALIGNED_DECL_LOCAL(FILE, DECL, NAME, SIZE, ALIGN) \\\n do {\t\t\t\t\t\t\t\t\t\\\n-  if ((DECL)\t\t\t\t\t\t\t\t\\\n-      && XSTR (XEXP (DECL_RTL (DECL), 0), 0)[0] == SDATA_NAME_FLAG_CHAR) \\\n+  if ((DECL) && sdata_symbolic_operand (XEXP (DECL_RTL (DECL), 0), Pmode)) \\\n     sbss_section ();\t\t\t\t\t\t\t\\\n   else\t\t\t\t\t\t\t\t\t\\\n     bss_section ();\t\t\t\t\t\t\t\\\n@@ -62,8 +61,8 @@ do {\t\t\t\t\t\t\t\t\t\\\n #define ASM_OUTPUT_LABELREF(STREAM, NAME)\t\\\n do {\t\t\t\t\t\t\\\n   const char *name_ = NAME;\t\t\t\\\n-  if (*name_ == SDATA_NAME_FLAG_CHAR)\t\t\\\n-    name_++;\t\t\t\t\t\\\n+  if (*name_ == ENCODE_SECTION_INFO_CHAR)\t\\\n+    name_ += 2;\t\t\t\t\t\\\n   if (*name_ == '*')\t\t\t\t\\\n     name_++;\t\t\t\t\t\\\n   else\t\t\t\t\t\t\\"}, {"sha": "9db1b4310a7225e4b66fa0c1151d193ec2cfc116", "filename": "gcc/configure", "status": "modified", "additions": 30, "deletions": 13, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7b6e506ee012b202851133cac4bfbd32cef529fb/gcc%2Fconfigure", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7b6e506ee012b202851133cac4bfbd32cef529fb/gcc%2Fconfigure", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfigure?ref=7b6e506ee012b202851133cac4bfbd32cef529fb", "patch": "@@ -7416,6 +7416,23 @@ foo:\t.long\t25\n \ttls_first_major=2\n \ttls_first_minor=13\n \t;;\n+  ia64-*-*)\n+    conftest_s='\n+\t.section \".tdata\",\"awT\",@progbits\n+foo:\tdata8\t25\n+\t.text\n+\taddl\tr16 = @ltoff(@dtpmod(foo#)), gp\n+\taddl\tr17 = @ltoff(@dtprel(foo#)), gp\n+\taddl\tr18 = @ltoff(@tprel(foo#)), gp\n+\taddl\tr19 = @dtprel(foo#), gp\n+\tadds\tr21 = @dtprel(foo#), r13\n+\tmovl\tr23 = @dtprel(foo#)\n+\taddl\tr20 = @tprel(foo#), gp\n+\tadds\tr22 = @tprel(foo#), r13\n+\tmovl\tr24 = @tprel(foo#)'\n+\ttls_first_major=2\n+\ttls_first_minor=13\n+\t;;\n esac\n if test -z \"$tls_first_major\"; then\n   :\n@@ -7446,7 +7463,7 @@ case \"$target\" in\n   # All TARGET_ABI_OSF targets.\n   alpha*-*-osf* | alpha*-*-linux* | alpha*-*-*bsd*)\n     echo $ac_n \"checking assembler supports explicit relocations\"\"... $ac_c\" 1>&6\n-echo \"configure:7450: checking assembler supports explicit relocations\" >&5\n+echo \"configure:7467: checking assembler supports explicit relocations\" >&5\n if eval \"test \\\"`echo '$''{'gcc_cv_as_explicit_relocs'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n@@ -7496,7 +7513,7 @@ EOF\n     ;;\n   sparc*-*-*)\n     echo $ac_n \"checking assembler .register pseudo-op support\"\"... $ac_c\" 1>&6\n-echo \"configure:7500: checking assembler .register pseudo-op support\" >&5\n+echo \"configure:7517: checking assembler .register pseudo-op support\" >&5\n if eval \"test \\\"`echo '$''{'gcc_cv_as_register_pseudo_op'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n@@ -7524,7 +7541,7 @@ EOF\n     fi\n \n     echo $ac_n \"checking assembler supports -relax\"\"... $ac_c\" 1>&6\n-echo \"configure:7528: checking assembler supports -relax\" >&5\n+echo \"configure:7545: checking assembler supports -relax\" >&5\n if eval \"test \\\"`echo '$''{'gcc_cv_as_relax_opt'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n@@ -7552,7 +7569,7 @@ EOF\n     fi\n \n     echo $ac_n \"checking assembler and linker support unaligned pc related relocs\"\"... $ac_c\" 1>&6\n-echo \"configure:7556: checking assembler and linker support unaligned pc related relocs\" >&5\n+echo \"configure:7573: checking assembler and linker support unaligned pc related relocs\" >&5\n if eval \"test \\\"`echo '$''{'gcc_cv_as_sparc_ua_pcrel'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n@@ -7579,7 +7596,7 @@ EOF\n     fi\n \n     echo $ac_n \"checking assembler and linker support unaligned pc related relocs against hidden symbols\"\"... $ac_c\" 1>&6\n-echo \"configure:7583: checking assembler and linker support unaligned pc related relocs against hidden symbols\" >&5\n+echo \"configure:7600: checking assembler and linker support unaligned pc related relocs against hidden symbols\" >&5\n if eval \"test \\\"`echo '$''{'gcc_cv_as_sparc_ua_pcrel_hidden'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n@@ -7620,7 +7637,7 @@ EOF\n \n     if test \"x$gcc_cv_as_flags64\" != xno; then\n \techo $ac_n \"checking for assembler offsetable %lo() support\"\"... $ac_c\" 1>&6\n-echo \"configure:7624: checking for assembler offsetable %lo() support\" >&5\n+echo \"configure:7641: checking for assembler offsetable %lo() support\" >&5\n if eval \"test \\\"`echo '$''{'gcc_cv_as_offsetable_lo10'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n@@ -7660,7 +7677,7 @@ EOF\n \n   i[34567]86-*-* | x86_64-*-*)\n     echo $ac_n \"checking assembler instructions\"\"... $ac_c\" 1>&6\n-echo \"configure:7664: checking assembler instructions\" >&5\n+echo \"configure:7681: checking assembler instructions\" >&5\n     gcc_cv_as_instructions=\n     if test x$gcc_cv_gas_major_version != x -a x$gcc_cv_gas_minor_version != x; then\n       if test \"$gcc_cv_gas_major_version\" -eq 2 -a \"$gcc_cv_gas_minor_version\" -ge 9 -o \"$gcc_cv_gas_major_version\" -gt 2; then\n@@ -7687,7 +7704,7 @@ EOF\n     echo \"$ac_t\"\"$gcc_cv_as_instructions\" 1>&6\n \n     echo $ac_n \"checking assembler GOTOFF in data directives\"\"... $ac_c\" 1>&6\n-echo \"configure:7691: checking assembler GOTOFF in data directives\" >&5\n+echo \"configure:7708: checking assembler GOTOFF in data directives\" >&5\n     gcc_cv_as_gotoff_in_data=no\n     if test x$gcc_cv_gas_major_version != x -a x$gcc_cv_gas_minor_version != x\n     then\n@@ -7717,7 +7734,7 @@ EOF\n esac\n \n echo $ac_n \"checking assembler dwarf2 debug_line support\"\"... $ac_c\" 1>&6\n-echo \"configure:7721: checking assembler dwarf2 debug_line support\" >&5\n+echo \"configure:7738: checking assembler dwarf2 debug_line support\" >&5\n gcc_cv_as_dwarf2_debug_line=no\n # ??? Not all targets support dwarf2 debug_line, even within a version\n # of gas.  Moreover, we need to emit a valid instruction to trigger any\n@@ -7773,7 +7790,7 @@ fi\n echo \"$ac_t\"\"$gcc_cv_as_dwarf2_debug_line\" 1>&6\n \n echo $ac_n \"checking assembler --gdwarf2 support\"\"... $ac_c\" 1>&6\n-echo \"configure:7777: checking assembler --gdwarf2 support\" >&5\n+echo \"configure:7794: checking assembler --gdwarf2 support\" >&5\n gcc_cv_as_gdwarf2_flag=no\n if test x$gcc_cv_gas_major_version != x -a x$gcc_cv_gas_minor_version != x;\n then\n@@ -7802,7 +7819,7 @@ fi\n echo \"$ac_t\"\"$gcc_cv_as_gdwarf2_flag\" 1>&6\n \n echo $ac_n \"checking assembler --gstabs support\"\"... $ac_c\" 1>&6\n-echo \"configure:7806: checking assembler --gstabs support\" >&5\n+echo \"configure:7823: checking assembler --gstabs support\" >&5\n gcc_cv_as_gstabs_flag=no\n if test x$gcc_cv_gas_major_version != x -a x$gcc_cv_gas_minor_version != x;\n then\n@@ -7830,7 +7847,7 @@ fi\n echo \"$ac_t\"\"$gcc_cv_as_gstabs_flag\" 1>&6\n \n echo $ac_n \"checking linker PT_GNU_EH_FRAME support\"\"... $ac_c\" 1>&6\n-echo \"configure:7834: checking linker PT_GNU_EH_FRAME support\" >&5\n+echo \"configure:7851: checking linker PT_GNU_EH_FRAME support\" >&5\n gcc_cv_ld_eh_frame_hdr=no\n if test x$gcc_cv_gld_major_version != x -a x$gcc_cv_gld_minor_version != x; then\n   if test \"$gcc_cv_gld_major_version\" -eq 2 -a \"$gcc_cv_gld_minor_version\" -ge 12 -o \"$gcc_cv_gld_major_version\" -gt 2 && grep 'EMUL = elf' ../ld/Makefile > /dev/null; then\n@@ -7993,7 +8010,7 @@ fi\n \n \n echo $ac_n \"checking whether to enable maintainer-specific portions of Makefiles\"\"... $ac_c\" 1>&6\n-echo \"configure:7997: checking whether to enable maintainer-specific portions of Makefiles\" >&5\n+echo \"configure:8014: checking whether to enable maintainer-specific portions of Makefiles\" >&5\n     # Check whether --enable-maintainer-mode or --disable-maintainer-mode was given.\n if test \"${enable_maintainer_mode+set}\" = set; then\n   enableval=\"$enable_maintainer_mode\""}, {"sha": "55ad7c4a44d7f4afc941660b0393eb3738bf8fcd", "filename": "gcc/configure.in", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7b6e506ee012b202851133cac4bfbd32cef529fb/gcc%2Fconfigure.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7b6e506ee012b202851133cac4bfbd32cef529fb/gcc%2Fconfigure.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfigure.in?ref=7b6e506ee012b202851133cac4bfbd32cef529fb", "patch": "@@ -1743,6 +1743,23 @@ foo:\t.long\t25\n \ttls_first_major=2\n \ttls_first_minor=13\n \t;;\n+  ia64-*-*)\n+    conftest_s='\n+\t.section \".tdata\",\"awT\",@progbits\n+foo:\tdata8\t25\n+\t.text\n+\taddl\tr16 = @ltoff(@dtpmod(foo#)), gp\n+\taddl\tr17 = @ltoff(@dtprel(foo#)), gp\n+\taddl\tr18 = @ltoff(@tprel(foo#)), gp\n+\taddl\tr19 = @dtprel(foo#), gp\n+\tadds\tr21 = @dtprel(foo#), r13\n+\tmovl\tr23 = @dtprel(foo#)\n+\taddl\tr20 = @tprel(foo#), gp\n+\tadds\tr22 = @tprel(foo#), r13\n+\tmovl\tr24 = @tprel(foo#)'\n+\ttls_first_major=2\n+\ttls_first_minor=13\n+\t;;\n esac\n if test -z \"$tls_first_major\"; then\n   :"}]}