{"sha": "8dfaeb6384f2630d761cd174c9ed1048f2d70ff9", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OGRmYWViNjM4NGYyNjMwZDc2MWNkMTc0YzllZDEwNDhmMmQ3MGZmOQ==", "commit": {"author": {"name": "Mark Mitchell", "email": "mark@codesourcery.com", "date": "1999-11-05T09:26:11Z"}, "committer": {"name": "Mark Mitchell", "email": "mmitchel@gcc.gnu.org", "date": "1999-11-05T09:26:11Z"}, "message": "Makefile.in (typeck2.o): Depend on output.h.\n\n\t* Makefile.in (typeck2.o): Depend on output.h.\n\t* typeck2.c: Include output.h.\n\n\t* decl.c (flag_ansi): Remove declaration.\n\n\t* pt.c (tinst_level_tick): Make it static.\n\t(last_template_error_tick): Likewise.\n\n\t* cp-tree.h (mapcar): Remove declaration.\n\t(search_tree): Likewise.\n\t(walk_tree_fn): New typedef.\n\t(walk_tree): New function.\n\t* tree.c (bot_manip): Change prototype.  Adjust to be called via\n\twalk_tree.\n\t(bot_replace): Likewise.\n\t(no_linkage_helper): Likewise.\n\t(copy_tree_r): New function.\n\t(search_tree): Rename, and adjust, to become ...\n\t(walk_tree): New function.\n\t(mapcar): Remove.\n\t(target_remap): Remove.\n\t(target_remap_count): Likewise.\n\t(break_out_target_exprs): Use walk_tree.\n\t* decl.c (local_variable_p): Change prototype.\n\t(check_default_argument): Use walk_tree.\n\t* pt.c (for_each_template_parm_r): New function, split out from ...\n\t(for_each_template_parm): Here.  Use it, via walk_tree.\n\nFrom-SVN: r30412", "tree": {"sha": "2bcac642768c7fd2d983046a13ba0c097ac83b2e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/2bcac642768c7fd2d983046a13ba0c097ac83b2e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/8dfaeb6384f2630d761cd174c9ed1048f2d70ff9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8dfaeb6384f2630d761cd174c9ed1048f2d70ff9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8dfaeb6384f2630d761cd174c9ed1048f2d70ff9", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8dfaeb6384f2630d761cd174c9ed1048f2d70ff9/comments", "author": null, "committer": null, "parents": [{"sha": "71144a650c7723a6548f4795eb7c09304c242a03", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/71144a650c7723a6548f4795eb7c09304c242a03", "html_url": "https://github.com/Rust-GCC/gccrs/commit/71144a650c7723a6548f4795eb7c09304c242a03"}], "stats": {"total": 913, "additions": 294, "deletions": 619}, "files": [{"sha": "1882c28a5e4b5718d48aa77c0d11c887a3529489", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8dfaeb6384f2630d761cd174c9ed1048f2d70ff9/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8dfaeb6384f2630d761cd174c9ed1048f2d70ff9/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=8dfaeb6384f2630d761cd174c9ed1048f2d70ff9", "patch": "@@ -19,7 +19,7 @@\n \t(copy_tree_r): New function.\n \t(search_tree): Rename, and adjust, to become ...\n \t(walk_tree): New function.\n-\t(mapcar): Rtemove.\n+\t(mapcar): Remove.\n \t(target_remap): Remove.\n \t(target_remap_count): Likewise.\n \t(break_out_target_exprs): Use walk_tree."}, {"sha": "6f8f1b7dbc008f5f658f1ee4906d0e6b4928e90c", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8dfaeb6384f2630d761cd174c9ed1048f2d70ff9/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8dfaeb6384f2630d761cd174c9ed1048f2d70ff9/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=8dfaeb6384f2630d761cd174c9ed1048f2d70ff9", "patch": "@@ -3986,15 +3986,15 @@ extern int varargs_function_p\t\t\tPROTO((tree));\n extern int really_overloaded_fn\t\t\tPROTO((tree));\n extern int cp_tree_equal\t\t\tPROTO((tree, tree));\n extern int can_free\t\t\t\tPROTO((struct obstack *, tree));\n-extern tree mapcar\t\t\t\tPROTO((tree, tree (*) (tree)));\n extern tree no_linkage_check\t\t\tPROTO((tree));\n extern void debug_binfo\t\t\t\tPROTO((tree));\n extern void push_expression_obstack\t\tPROTO((void));\n extern void push_permanent_obstack              PROTO((void));\n extern tree build_dummy_object\t\t\tPROTO((tree));\n extern tree maybe_dummy_object\t\t\tPROTO((tree, tree *));\n extern int is_dummy_object\t\t\tPROTO((tree));\n-extern tree search_tree                         PROTO((tree *, tree (*)(tree *)));\n+typedef tree (*walk_tree_fn)                    PROTO((tree *, int *, void *));\n+extern tree walk_tree                           PROTO((tree *, walk_tree_fn, void *));\n extern int cp_valid_lang_attribute\t\tPROTO((tree, tree, tree, tree));\n extern tree make_ptrmem_cst                     PROTO((tree, tree));\n extern tree cp_build_qualified_type_real        PROTO((tree, int, int));"}, {"sha": "80aec15def56d44969dd24efbf905c28c3239cb2", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 5, "deletions": 8, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8dfaeb6384f2630d761cd174c9ed1048f2d70ff9/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8dfaeb6384f2630d761cd174c9ed1048f2d70ff9/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=8dfaeb6384f2630d761cd174c9ed1048f2d70ff9", "patch": "@@ -141,7 +141,7 @@ static boolean typename_compare PROTO((hash_table_key, hash_table_key));\n static void push_binding PROTO((tree, tree, struct binding_level*));\n static int add_binding PROTO((tree, tree));\n static void pop_binding PROTO((tree, tree));\n-static tree local_variable_p PROTO((tree *));\n+static tree local_variable_p PROTO((tree *, int *, void *));\n static tree find_binding PROTO((tree, tree));\n static tree select_decl PROTO((tree, int));\n static int lookup_flags PROTO((int, int));\n@@ -349,11 +349,6 @@ extern int flag_no_builtin;\n \n extern int flag_no_nonansi_builtin;\n \n-/* Nonzero means enable obscure ANSI features and disable GNU extensions\n-   that might cause ANSI-compliant code to be miscompiled.  */\n-\n-extern int flag_ansi;\n-\n /* Nonzero if we want to support huge (> 2^(sizeof(short)*8-1) bytes)\n    objects.  */\n extern int flag_huge_objects;\n@@ -11189,8 +11184,10 @@ require_complete_types_for_parms (parms)\n    NULL_TREE otherwise.  */\n \n static tree\n-local_variable_p (tp)\n+local_variable_p (tp, walk_subtrees, data)\n      tree *tp;\n+     int *walk_subtrees ATTRIBUTE_UNUSED;\n+     void *data ATTRIBUTE_UNUSED;\n {\n   tree t = *tp;\n \n@@ -11272,7 +11269,7 @@ check_default_argument (decl, arg)\n \n      The keyword `this' shall not be used in a default argument of a\n      member function.  */\n-  var = search_tree (&arg, local_variable_p);\n+  var = walk_tree (&arg, local_variable_p, NULL);\n   if (var)\n     {\n       cp_error (\"default argument `%E' uses local variable `%D'\","}, {"sha": "c70147d8fadc895b2f965e7e82696c0cd580fed2", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 105, "deletions": 185, "changes": 290, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8dfaeb6384f2630d761cd174c9ed1048f2d70ff9/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8dfaeb6384f2630d761cd174c9ed1048f2d70ff9/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=8dfaeb6384f2630d761cd174c9ed1048f2d70ff9", "patch": "@@ -4032,83 +4032,56 @@ lookup_template_class (d1, arglist, in_decl, context, entering_scope)\n     }\n }\n \f\n-/* For each TEMPLATE_TYPE_PARM, TEMPLATE_TEMPLATE_PARM, or\n-   TEMPLATE_PARM_INDEX in T, call FN with the parameter and the DATA.\n-   If FN returns non-zero, the iteration is terminated, and\n-   for_each_template_parm returns 1.  Otherwise, the iteration\n-   continues.  If FN never returns a non-zero value, the value\n-   returned by for_each_template_parm is 0.  If FN is NULL, it is\n-   considered to be the function which always returns 1.  */\n-\n-static int\n-for_each_template_parm (t, fn, data)\n-     tree t;\n-     tree_fn_t fn;\n-     void* data;\n+struct pair_fn_data \n {\n-  if (!t)\n-    return 0;\n+  tree_fn_t fn;\n+  void *data;\n+};\n+\n+/* Called from for_each_template_parm via walk_tree.  */\n \n+static tree\n+for_each_template_parm_r (tp, walk_subtrees, d)\n+     tree *tp;\n+     int *walk_subtrees;\n+     void *d;\n+{\n+  tree t = *tp;\n+  struct pair_fn_data *pfd = (struct pair_fn_data *) d;\n+  tree_fn_t fn = pfd->fn;\n+  void *data = pfd->data;\n+  \n   if (TREE_CODE_CLASS (TREE_CODE (t)) == 't'\n       && for_each_template_parm (TYPE_CONTEXT (t), fn, data))\n-    return 1;\n+    return error_mark_node;\n \n   switch (TREE_CODE (t))\n     {\n-    case ARRAY_REF:\n-    case OFFSET_REF:\n-      return (for_each_template_parm (TREE_OPERAND (t, 0), fn, data)\n-\t      || for_each_template_parm (TREE_OPERAND (t, 1), fn, data));\n-\n-    case IDENTIFIER_NODE:\n-      if (!IDENTIFIER_TEMPLATE (t))\n-\treturn 0;\n-      my_friendly_abort (42);\n-\n-      /* aggregates of tree nodes */\n-    case TREE_VEC:\n-      {\n-\tint i = TREE_VEC_LENGTH (t);\n-\twhile (i--)\n-\t  if (for_each_template_parm (TREE_VEC_ELT (t, i), fn, data))\n-\t    return 1;\n-\treturn 0;\n-      }\n-    case TREE_LIST:\n-      if (for_each_template_parm (TREE_PURPOSE (t), fn, data)\n-\t  || for_each_template_parm (TREE_VALUE (t), fn, data))\n-\treturn 1;\n-      return for_each_template_parm (TREE_CHAIN (t), fn, data);\n-\n-    case OVERLOAD:\n-      if (for_each_template_parm (OVL_FUNCTION (t), fn, data))\n-\treturn 1;\n-      return for_each_template_parm (OVL_CHAIN (t), fn, data);\n-\n-      /* constructed type nodes */\n-    case POINTER_TYPE:\n-    case REFERENCE_TYPE:\n-      return for_each_template_parm (TREE_TYPE (t), fn, data);\n-\n     case RECORD_TYPE:\n       if (TYPE_PTRMEMFUNC_FLAG (t))\n-\treturn for_each_template_parm (TYPE_PTRMEMFUNC_FN_TYPE (t),\n-\t\t\t\t       fn, data);\n+\tbreak;\n       /* Fall through.  */\n \n     case UNION_TYPE:\n     case ENUMERAL_TYPE:\n-      if (! TYPE_TEMPLATE_INFO (t))\n-\treturn 0;\n-      return for_each_template_parm (TREE_VALUE\n-\t\t\t\t     (TYPE_TEMPLATE_INFO (t)),\n-\t\t\t\t     fn, data);\n+      if (!TYPE_TEMPLATE_INFO (t))\n+\t*walk_subtrees = 0;\n+      else if (for_each_template_parm (TREE_VALUE (TYPE_TEMPLATE_INFO (t)),\n+\t\t\t\t       fn, data))\n+\treturn error_mark_node;\n+      break;\n+\n     case METHOD_TYPE:\n+      /* Since we're not going to walk subtrees, we have to do this\n+\t explicitly here.  */\n       if (for_each_template_parm (TYPE_METHOD_BASETYPE (t), fn, data))\n-\treturn 1;\n-      /* Fall through.  */\n+\treturn error_mark_node;\n \n     case FUNCTION_TYPE:\n+      /* Check the return type.  */\n+      if (for_each_template_parm (TREE_TYPE (t), fn, data))\n+\treturn error_mark_node;\n+\n       /* Check the parameter types.  Since default arguments are not\n \t instantiated until they are needed, the TYPE_ARG_TYPES may\n \t contain expressions that involve template parameters.  But,\n@@ -4120,132 +4093,72 @@ for_each_template_parm (t, fn, data)\n \n \tfor (parm = TYPE_ARG_TYPES (t); parm; parm = TREE_CHAIN (parm))\n \t  if (for_each_template_parm (TREE_VALUE (parm), fn, data))\n-\t    return 1;\n-      }\n-\n-      /* Check the return type, too.  */\n-      return for_each_template_parm (TREE_TYPE (t), fn, data);\n-\n-    case ARRAY_TYPE:\n-      if (for_each_template_parm (TYPE_DOMAIN (t), fn, data))\n-\treturn 1;\n-      return for_each_template_parm (TREE_TYPE (t), fn, data);\n-    case OFFSET_TYPE:\n-      if (for_each_template_parm (TYPE_OFFSET_BASETYPE (t), fn, data))\n-\treturn 1;\n-      return for_each_template_parm (TREE_TYPE (t), fn, data);\n-\n-      /* decl nodes */\n-    case TYPE_DECL:\n-      return for_each_template_parm (TREE_TYPE (t), fn, data);\n+\t    return error_mark_node;\n \n-    case TEMPLATE_DECL:\n-      /* A template template parameter is encountered */\n-      if (DECL_TEMPLATE_TEMPLATE_PARM_P (t))\n-\treturn for_each_template_parm (TREE_TYPE (t), fn, data);\n-      /* Already substituted template template parameter */\n-      return 0;\n-      \n-    case CONST_DECL:\n-      if (for_each_template_parm (DECL_INITIAL (t), fn, data))\n-\treturn 1;\n-      goto check_type_and_context;\n+\t/* Since we've already handled the TYPE_ARG_TYPES, we don't\n+\t   want walk_tree walking into them itself.  */\n+\t*walk_subtrees = 0;\n+      }\n+      break;\n \n     case FUNCTION_DECL:\n     case VAR_DECL:\n       if (DECL_LANG_SPECIFIC (t) && DECL_TEMPLATE_INFO (t)\n \t  && for_each_template_parm (DECL_TI_ARGS (t), fn, data))\n-\treturn 1;\n-      /* fall through */\n+\treturn error_mark_node;\n+      /* Fall through.  */\n+\n+    case CONST_DECL:\n     case PARM_DECL:\n-    check_type_and_context:\n-      if (for_each_template_parm (TREE_TYPE (t), fn, data))\n-\treturn 1;\n       if (DECL_CONTEXT (t) \n \t  && for_each_template_parm (DECL_CONTEXT (t), fn, data))\n-\treturn 1;\n-      return 0;\n-\n-    case CALL_EXPR:\n-      return (for_each_template_parm (TREE_OPERAND (t, 0), fn, data)\n-\t      || for_each_template_parm (TREE_OPERAND (t, 1), fn, data));\n-\t\n-    case ADDR_EXPR:\n-      return for_each_template_parm (TREE_OPERAND (t, 0), fn, data);\n+\treturn error_mark_node;\n+      break;\n \n-      /* template parm nodes */\n     case TEMPLATE_TEMPLATE_PARM:\n       /* Record template parameters such as `T' inside `TT<T>'.  */\n       if (TEMPLATE_TEMPLATE_PARM_TEMPLATE_INFO (t)\n \t  && for_each_template_parm (TYPE_TI_ARGS (t), fn, data))\n-\treturn 1;\n+\treturn error_mark_node;\n+      /* Fall through.  */\n+\n     case TEMPLATE_TYPE_PARM:\n     case TEMPLATE_PARM_INDEX:\n-      if (fn)\n-\treturn (*fn)(t, data);\n-      else\n-\treturn 1;\n-\n-      /* simple type nodes */\n-    case INTEGER_TYPE:\n-      if (for_each_template_parm (TYPE_MIN_VALUE (t), fn, data))\n-\treturn 1;\n-      return for_each_template_parm (TYPE_MAX_VALUE (t), fn, data);\n-\n-    case REAL_TYPE:\n-    case COMPLEX_TYPE:\n-    case VOID_TYPE:\n-    case BOOLEAN_TYPE:\n-    case NAMESPACE_DECL:\n-    case FIELD_DECL:\n-      return 0;\n-\n-      /* constants */\n-    case INTEGER_CST:\n-    case REAL_CST:\n-    case STRING_CST:\n-      return 0;\n-\n-    case ERROR_MARK:\n-      /* Non-error_mark_node ERROR_MARKs are bad things.  */\n-      my_friendly_assert (t == error_mark_node, 274);\n-      /* NOTREACHED */\n-      return 0;\n-\n-    case PTRMEM_CST:\n-      return for_each_template_parm (TREE_TYPE (t), fn, data);\n-\n-    case SCOPE_REF:\n-      return for_each_template_parm (TREE_OPERAND (t, 0), fn, data);\n+      if (fn && (*fn)(t, data))\n+\treturn error_mark_node;\n+      else if (!fn)\n+\treturn error_mark_node;\n+      break;\n \n-    case CONSTRUCTOR:\n-      if (TREE_TYPE (t) && TYPE_PTRMEMFUNC_P (TREE_TYPE (t)))\n-\treturn for_each_template_parm (TYPE_PTRMEMFUNC_FN_TYPE\n-\t\t\t\t       (TREE_TYPE (t)), fn, data);\n-      return for_each_template_parm (TREE_OPERAND (t, 1), fn, data);\n+    case TEMPLATE_DECL:\n+      /* A template template parameter is encountered */\n+      if (DECL_TEMPLATE_TEMPLATE_PARM_P (t)\n+\t  && for_each_template_parm (TREE_TYPE (t), fn, data))\n+\treturn error_mark_node;\n \n-    case SIZEOF_EXPR:\n-    case ALIGNOF_EXPR:\n-      return for_each_template_parm (TREE_OPERAND (t, 0), fn, data);\n+      /* Already substituted template template parameter */\n+      *walk_subtrees = 0;\n+      break;\n \n     case TYPENAME_TYPE:\n-      if (!fn)\n-\treturn 1;\n-      return (for_each_template_parm (TYPE_CONTEXT (t), fn, data)\n-\t      || for_each_template_parm (TYPENAME_TYPE_FULLNAME (t),\n-\t\t\t\t\t fn, data));\n+      if (!fn || for_each_template_parm (TYPENAME_TYPE_FULLNAME (t), fn, data))\n+\treturn error_mark_node;\n+      break;\n \n+    case CONSTRUCTOR:\n+      if (TREE_TYPE (t) && TYPE_PTRMEMFUNC_P (TREE_TYPE (t))\n+\t  && for_each_template_parm (TYPE_PTRMEMFUNC_FN_TYPE\n+\t\t\t\t     (TREE_TYPE (t)), fn, data))\n+\treturn error_mark_node;\n+      break;\n+      \n     case INDIRECT_REF:\n     case COMPONENT_REF:\n       /* If there's no type, then this thing must be some expression\n \t involving template parameters.  */\n       if (!fn && !TREE_TYPE (t))\n-\treturn 1;\n-      if (TREE_CODE (t) == COMPONENT_REF)\n-\treturn (for_each_template_parm (TREE_OPERAND (t, 0), fn, data)\n-\t\t|| for_each_template_parm (TREE_OPERAND (t, 1), fn, data));\n-      else\n-\treturn for_each_template_parm (TREE_OPERAND (t, 0), fn, data);\n+\treturn error_mark_node;\n+      break;\n \n     case MODOP_EXPR:\n     case CAST_EXPR:\n@@ -4259,32 +4172,39 @@ for_each_template_parm (t, fn, data)\n     case LOOKUP_EXPR:\n     case PSEUDO_DTOR_EXPR:\n       if (!fn)\n-\treturn 1;\n-      /* Fall through.  */\n+\treturn error_mark_node;\n+      break;\n \n     default:\n-      switch (TREE_CODE_CLASS (TREE_CODE (t)))\n-\t{\n-\tcase '1':\n-\tcase '2':\n-\tcase 'e':\n-\tcase '<':\n-\t  {\n-\t    int i;\n-\t    for (i = first_rtl_op (TREE_CODE (t)); --i >= 0;)\n-\t      if (for_each_template_parm (TREE_OPERAND (t, i), fn, data))\n-\t\treturn 1;\n-\t    return 0;\n-\t  }\n-\tdefault:\n-\t  break;\n-\t}\n-      sorry (\"testing %s for template parms\",\n-\t     tree_code_name [(int) TREE_CODE (t)]);\n-      my_friendly_abort (82);\n-      /* NOTREACHED */\n-      return 0;\n+      break;\n     }\n+\n+  /* We didn't find any template parameters we liked.  */\n+  return NULL_TREE;\n+}\n+\n+/* For each TEMPLATE_TYPE_PARM, TEMPLATE_TEMPLATE_PARM, or\n+   TEMPLATE_PARM_INDEX in T, call FN with the parameter and the DATA.\n+   If FN returns non-zero, the iteration is terminated, and\n+   for_each_template_parm returns 1.  Otherwise, the iteration\n+   continues.  If FN never returns a non-zero value, the value\n+   returned by for_each_template_parm is 0.  If FN is NULL, it is\n+   considered to be the function which always returns 1.  */\n+\n+static int\n+for_each_template_parm (t, fn, data)\n+     tree t;\n+     tree_fn_t fn;\n+     void* data;\n+{\n+  struct pair_fn_data pfd;\n+\n+  /* Set up.  */\n+  pfd.fn = fn;\n+  pfd.data = data;\n+\n+  /* Walk the tree.  */\n+  return walk_tree (&t, for_each_template_parm_r, &pfd) != NULL_TREE;\n }\n \n int\n@@ -4301,8 +4221,8 @@ extern int max_tinst_depth;\n #ifdef GATHER_STATISTICS\n int depth_reached;\n #endif\n-int tinst_level_tick;\n-int last_template_error_tick;\n+static int tinst_level_tick;\n+static int last_template_error_tick;\n \n /* Print out all the template instantiations that we are currently\n    working on.  If ERR, we are being called from cp_thing, so do"}, {"sha": "d1b725b2c321ec02cc7b92f6153ec414875453d7", "filename": "gcc/cp/tree.c", "status": "modified", "additions": 181, "deletions": 423, "changes": 604, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8dfaeb6384f2630d761cd174c9ed1048f2d70ff9/gcc%2Fcp%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8dfaeb6384f2630d761cd174c9ed1048f2d70ff9/gcc%2Fcp%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftree.c?ref=8dfaeb6384f2630d761cd174c9ed1048f2d70ff9", "patch": "@@ -30,18 +30,19 @@ Boston, MA 02111-1307, USA.  */\n #include \"ggc.h\"\n #include \"splay-tree.h\"\n \n-static tree bot_manip PROTO((tree));\n-static tree bot_replace PROTO((tree *));\n+static tree bot_manip PROTO((tree *, int *, void *));\n+static tree bot_replace PROTO((tree *, int *, void *));\n static tree build_cplus_array_type_1 PROTO((tree, tree));\n static void list_hash_add PROTO((int, tree));\n static int list_hash PROTO((tree, tree, tree));\n static tree list_hash_lookup PROTO((int, tree, tree, tree));\n static void propagate_binfo_offsets PROTO((tree, tree));\n static int avoid_overlap PROTO((tree, tree));\n static cp_lvalue_kind lvalue_p_1 PROTO((tree, int));\n-static tree no_linkage_helper PROTO((tree *));\n+static tree no_linkage_helper PROTO((tree *, int *, void *));\n static tree build_srcloc PROTO((char *, int));\n static void mark_list_hash PROTO ((void *));\n+static tree copy_tree_r PROTO ((tree *, int *, void *));\n \n #define CEIL(x,y) (((x) + (y) - 1) / (y))\n \n@@ -1524,221 +1525,181 @@ copy_template_template_parm (t)\n   return t2;\n }\n \n-/* Walk through the tree structure T, applying func.  If func ever returns\n-   non-null, return that value.  */\n+/* Apply FUNC to all the sub-trees of TP in a pre-order traversal.\n+   FUNC is called with the DATA and the address of each sub-tree.  If\n+   FUNC returns a non-NULL value, the traversal is aborted, and the\n+   value returned by FUNC is returned.  */\n \n-tree\n-search_tree (tp, func)\n+tree \n+walk_tree (tp, func, data)\n      tree *tp;\n-     tree (*func) PROTO((tree *));\n+     walk_tree_fn func;\n+     void *data;\n {\n-#define TRY(ARG) if (tmp=search_tree (&ARG, func), tmp != NULL_TREE) return tmp\n-\n-  tree t = *tp;\n-  tree tmp;\n-  enum tree_code code; \n+  enum tree_code code;\n+  int walk_subtrees;\n+  tree result;\n   \n-  if (t == NULL_TREE)\n+#define WALK_SUBTREE(NODE)\t\t\t\\\n+  do\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\\\n+      result = walk_tree (&(NODE), func, data);\t\\\n+      if (result)\t\t\t\t\\\n+\treturn result;\t\t\t\t\\\n+    }\t\t\t\t\t\t\\\n+  while (0)\n+\n+  /* Skip empty subtrees.  */\n+  if (!*tp)\n     return NULL_TREE;\n-  \n-  tmp = func (tp);\n-  if (tmp)\n-    return tmp;\n \n-  /* Handle some common cases up front.  */\n-  code = TREE_CODE (t);\n-  if (TREE_CODE_CLASS (code) == '1')\n+  /* Call the function.  */\n+  walk_subtrees = 1;\n+  result = (*func) (tp, &walk_subtrees, data);\n+\n+  /* If we found something, return it.  */\n+  if (result)\n+    return result;\n+\n+  /* Even if we didn't, FUNC may have decided that there was nothing\n+     interesting below this point in the tree.  */\n+  if (!walk_subtrees)\n+    return NULL_TREE;\n+\n+  code = TREE_CODE (*tp);\n+\n+  /* Handle commmon cases up front.  */\n+  if (IS_EXPR_CODE_CLASS (TREE_CODE_CLASS (code))\n+      || TREE_CODE_CLASS (code) == 'r')\n     {\n-      TRY (TREE_OPERAND (t, 0));\n+      int i;\n+\n+      /* Walk over all the sub-trees of this operand.  */\n+      for (i = first_rtl_op (code) - 1; i >= 0; --i)\n+\tWALK_SUBTREE (TREE_OPERAND (*tp, i));\n+\n+      /* We didn't find what we were looking for.  */\n       return NULL_TREE;\n     }\n-  else if (TREE_CODE_CLASS (code) == '2' || TREE_CODE_CLASS (code) == '<')\n+  else if (TREE_CODE_CLASS (code) == 'd')\n     {\n-      TRY (TREE_OPERAND (t, 0));\n-      TRY (TREE_OPERAND (t, 1));\n+      WALK_SUBTREE (TREE_TYPE (*tp));\n+      WALK_SUBTREE (DECL_INITIAL (*tp));\n+      WALK_SUBTREE (DECL_SIZE (*tp));\n+\n+      /* We didn't find what we were looking for.  */\n       return NULL_TREE;\n     }\n \n+  /* Not one of the easy cases.  We must explicitly go through the\n+     children.  */\n   switch (code)\n     {\n     case ERROR_MARK:\n-      break;\n-\n     case IDENTIFIER_NODE:\n+    case INTEGER_CST:\n+    case REAL_CST:\n+    case STRING_CST:\n+    case DEFAULT_ARG:\n+    case TEMPLATE_TEMPLATE_PARM:\n+    case TEMPLATE_PARM_INDEX:\n+    case TEMPLATE_TYPE_PARM:\n+    case REAL_TYPE:\n+    case COMPLEX_TYPE:\n+    case VOID_TYPE:\n+    case BOOLEAN_TYPE:\n+    case TYPENAME_TYPE:\n+    case UNION_TYPE:\n+    case ENUMERAL_TYPE:\n+    case TYPEOF_TYPE:\n+    case BLOCK:\n+      /* None of thse have subtrees other than those already walked\n+         above.  */\n       break;\n \n-    case VAR_DECL:\n-    case FUNCTION_DECL:\n-    case CONST_DECL:\n-    case TEMPLATE_DECL:\n-    case NAMESPACE_DECL:\n-      break;\n-\n-    case TYPE_DECL:\n-      TRY (TREE_TYPE (t));\n+    case PTRMEM_CST:\n+      WALK_SUBTREE (TREE_TYPE (*tp));\n       break;\n \n-    case PARM_DECL:\n-      TRY (TREE_TYPE (t));\n-      TRY (TREE_CHAIN (t));\n+    case POINTER_TYPE:\n+    case REFERENCE_TYPE:\n+      WALK_SUBTREE (TREE_TYPE (*tp));\n       break;\n \n     case TREE_LIST:\n-      TRY (TREE_PURPOSE (t));\n-      TRY (TREE_VALUE (t));\n-      TRY (TREE_CHAIN (t));\n+      WALK_SUBTREE (TREE_PURPOSE (*tp));\n+      WALK_SUBTREE (TREE_VALUE (*tp));\n+      WALK_SUBTREE (TREE_CHAIN (*tp));\n       break;\n \n     case OVERLOAD:\n-      TRY (OVL_FUNCTION (t));\n-      TRY (OVL_CHAIN (t));\n+      WALK_SUBTREE (OVL_FUNCTION (*tp));\n+      WALK_SUBTREE (OVL_CHAIN (*tp));\n       break;\n \n     case TREE_VEC:\n       {\n-\tint len = TREE_VEC_LENGTH (t);\n-\n-\tt = copy_node (t);\n+\tint len = TREE_VEC_LENGTH (*tp);\n \twhile (len--)\n-\t  TRY (TREE_VEC_ELT (t, len));\n+\t  WALK_SUBTREE (TREE_VEC_ELT (*tp, len));\n       }\n       break;\n \n-    case INTEGER_CST:\n-    case REAL_CST:\n-    case STRING_CST:\n-    case DEFAULT_ARG:\n-      break;\n-\n-    case PTRMEM_CST:\n-      TRY (TREE_TYPE (t));\n-      break;\n-\n-    case COND_EXPR:\n-    case TARGET_EXPR:\n-    case AGGR_INIT_EXPR:\n-    case NEW_EXPR:\n-      TRY (TREE_OPERAND (t, 0));\n-      TRY (TREE_OPERAND (t, 1));\n-      TRY (TREE_OPERAND (t, 2));\n-      break;\n-\n-    case TRUTH_AND_EXPR:\n-    case TRUTH_OR_EXPR:\n-    case TRUTH_XOR_EXPR:\n-    case TRUTH_ANDIF_EXPR:\n-    case TRUTH_ORIF_EXPR:\n-    case PREDECREMENT_EXPR:\n-    case PREINCREMENT_EXPR:\n-    case POSTDECREMENT_EXPR:\n-    case POSTINCREMENT_EXPR:\n-    case ARRAY_REF:\n-    case SCOPE_REF:\n-    case TRY_CATCH_EXPR:\n-    case WITH_CLEANUP_EXPR:\n-    case CALL_EXPR:\n-    case COMPOUND_EXPR:\n-    case MODIFY_EXPR:\n-    case INIT_EXPR:\n-    case OFFSET_REF:\n-      TRY (TREE_OPERAND (t, 0));\n-      TRY (TREE_OPERAND (t, 1));\n-      break;\n-\n-    case SAVE_EXPR:\n-    case ADDR_EXPR:\n-    case INDIRECT_REF:\n-    case TRUTH_NOT_EXPR:\n-    case COMPONENT_REF:\n-    case CLEANUP_POINT_EXPR:\n-    case LOOKUP_EXPR:\n-    case THROW_EXPR:\n-    case EXIT_EXPR:\n-    case LOOP_EXPR:\n-    case BIT_FIELD_REF:\n-    case VA_ARG_EXPR:\n-      TRY (TREE_OPERAND (t, 0));\n-      break;\n-\n-    case MODOP_EXPR:\n-    case ARROW_EXPR:\n-    case DOTSTAR_EXPR:\n-    case TYPEID_EXPR:\n-    case PSEUDO_DTOR_EXPR:\n-      break;\n-\n     case COMPLEX_CST:\n-      TRY (TREE_REALPART (t));\n-      TRY (TREE_IMAGPART (t));\n+      WALK_SUBTREE (TREE_REALPART (*tp));\n+      WALK_SUBTREE (TREE_IMAGPART (*tp));\n       break;\n \n     case CONSTRUCTOR:\n-      TRY (CONSTRUCTOR_ELTS (t));\n-      break;\n-\n-    case TEMPLATE_TEMPLATE_PARM:\n-    case TEMPLATE_PARM_INDEX:\n-    case TEMPLATE_TYPE_PARM:\n-      break;\n-\n-    case BIND_EXPR:\n-    case STMT_EXPR:\n-      break;\n-\n-    case REAL_TYPE:\n-    case COMPLEX_TYPE:\n-    case VOID_TYPE:\n-    case BOOLEAN_TYPE:\n-    case TYPENAME_TYPE:\n-    case UNION_TYPE:\n-    case ENUMERAL_TYPE:\n-    case TYPEOF_TYPE:\n+      WALK_SUBTREE (CONSTRUCTOR_ELTS (*tp));\n       break;\n \n-    case POINTER_TYPE:\n-    case REFERENCE_TYPE:\n-      TRY (TREE_TYPE (t));\n-      break;\n+    case METHOD_TYPE:\n+      WALK_SUBTREE (TYPE_METHOD_BASETYPE (*tp));\n+      /* Fall through.  */\n \n     case FUNCTION_TYPE:\n-    case METHOD_TYPE:\n-      TRY (TREE_TYPE (t));\n-      TRY (TYPE_ARG_TYPES (t));\n+      WALK_SUBTREE (TREE_TYPE (*tp));\n+      WALK_SUBTREE (TYPE_ARG_TYPES (*tp));\n       break;\n \n     case ARRAY_TYPE:\n-      TRY (TREE_TYPE (t));\n-      TRY (TYPE_DOMAIN (t));\n+      WALK_SUBTREE (TREE_TYPE (*tp));\n+      WALK_SUBTREE (TYPE_DOMAIN (*tp));\n       break;\n \n     case INTEGER_TYPE:\n-      TRY (TYPE_MAX_VALUE (t));\n+      WALK_SUBTREE (TYPE_MIN_VALUE (*tp));\n+      WALK_SUBTREE (TYPE_MAX_VALUE (*tp));\n       break;\n \n     case OFFSET_TYPE:\n-      TRY (TREE_TYPE (t));\n-      TRY (TYPE_OFFSET_BASETYPE (t));\n+      WALK_SUBTREE (TREE_TYPE (*tp));\n+      WALK_SUBTREE (TYPE_OFFSET_BASETYPE (*tp));\n       break;\n \n     case RECORD_TYPE:\n-      if (TYPE_PTRMEMFUNC_P (t))\n-\tTRY (TYPE_PTRMEMFUNC_FN_TYPE (t));\n+      if (TYPE_PTRMEMFUNC_P (*tp))\n+\tWALK_SUBTREE (TYPE_PTRMEMFUNC_FN_TYPE (*tp));\n       break;\n       \n     default:\n       my_friendly_abort (19990803);\n     }\n \n+  /* We didn't find what we were looking for.  */\n   return NULL_TREE;\n \n-#undef TRY\n+#undef WALK_SUBTREE\n }\n \n-/* Passed to search_tree.  Checks for the use of types with no linkage.  */\n+/* Passed to walk_tree.  Checks for the use of types with no linkage.  */\n \n static tree\n-no_linkage_helper (tp)\n+no_linkage_helper (tp, walk_subtrees, data)\n      tree *tp;\n+     int *walk_subtrees ATTRIBUTE_UNUSED;\n+     void *data ATTRIBUTE_UNUSED;\n {\n   tree t = *tp;\n \n@@ -1762,269 +1723,47 @@ no_linkage_check (t)\n   if (processing_template_decl)\n     return NULL_TREE;\n \n-  t = search_tree (&t, no_linkage_helper);\n+  t = walk_tree (&t, no_linkage_helper, NULL);\n   if (t != error_mark_node)\n     return t;\n   return NULL_TREE;\n }\n \n+/* Passed to walk_tree.  Copies the node pointed to, if appropriate.  */\n \n-/* Make copies of all the nodes below T.  If FUNC is non-NULL, call it\n-   for each node.  */\n-\n-tree\n-mapcar (t, func)\n-     tree t;\n-     tree (*func) PROTO((tree));\n-{\n-  tree tmp;\n-  enum tree_code code; \n-\n-  if (t == NULL_TREE)\n-    return t;\n-\n-  if (func) \n-    {\n-      tmp = func (t);\n-      if (tmp)\n-\treturn tmp;\n-    }\n-\n-  /* Handle some common cases up front.  */\n-  code = TREE_CODE (t);\n-  if (TREE_CODE_CLASS (code) == '1')\n-    {\n-      t = copy_node (t);\n-      TREE_TYPE (t) = mapcar (TREE_TYPE (t), func);\n-      TREE_OPERAND (t, 0) = mapcar (TREE_OPERAND (t, 0), func);\n-      return t;\n-    }\n-  else if (TREE_CODE_CLASS (code) == '2' || TREE_CODE_CLASS (code) == '<')\n-    {\n-      t = copy_node (t);\n-      TREE_TYPE (t) = mapcar (TREE_TYPE (t), func);\n-      TREE_OPERAND (t, 0) = mapcar (TREE_OPERAND (t, 0), func);\n-      TREE_OPERAND (t, 1) = mapcar (TREE_OPERAND (t, 1), func);\n-      return t;\n-    }\n-\n-  switch (TREE_CODE (t))\n+static tree\n+copy_tree_r (tp, walk_subtrees, data)\n+     tree *tp;\n+     int *walk_subtrees ATTRIBUTE_UNUSED;\n+     void *data ATTRIBUTE_UNUSED;\n+{\n+  enum tree_code code = TREE_CODE (*tp);\n+\n+  /* We make copies of most nodes.  */\n+  if (IS_EXPR_CODE_CLASS (TREE_CODE_CLASS (code))\n+      || TREE_CODE_CLASS (code) == 'r'\n+      || TREE_CODE_CLASS (code) == 'c'\n+      || code == PARM_DECL\n+      || code == TREE_LIST\n+      || code == TREE_VEC\n+      || code == OVERLOAD)\n     {\n-    case ERROR_MARK:\n-      return error_mark_node;\n-\n-    case VAR_DECL:\n-    case FUNCTION_DECL:\n-    case CONST_DECL:\n-      /* Rather than aborting, return error_mark_node.  This allows us\n-\t to report a sensible error message on code like this:\n-\n-\t void g() { int i; f<i>(7); } \n-\n-         In a case like:\n-\n-           void g() { const int i = 7; f<i>(7); }\n-\n-\t however, we must actually return the constant initializer.  */\n-      if (TREE_READONLY_DECL_P (t))\n-\t{\n-\t  tmp = decl_constant_value (t);\n-\t  if (tmp != t)\n-\t    return mapcar (tmp, func);\n-\t}\n-      return error_mark_node;\n-\n-    case PARM_DECL:\n-      {\n-\ttree chain = TREE_CHAIN (t);\n-\tt = copy_node (t);\n-\tTREE_CHAIN (t) = mapcar (chain, func);\n-\tTREE_TYPE (t) = mapcar (TREE_TYPE (t), func);\n-\tDECL_INITIAL (t) = mapcar (DECL_INITIAL (t), func);\n-\tDECL_SIZE (t) = mapcar (DECL_SIZE (t), func);\n-\treturn t;\n-      }\n-\n-    case TREE_LIST:\n-      {\n-\ttree chain = TREE_CHAIN (t);\n-\tt = copy_node (t);\n-\tTREE_PURPOSE (t) = mapcar (TREE_PURPOSE (t), func);\n-\tTREE_VALUE (t) = mapcar (TREE_VALUE (t), func);\n-\tTREE_CHAIN (t) = mapcar (chain, func);\n-\treturn t;\n-      }\n-\n-    case OVERLOAD:\n-      {\n-\ttree chain = OVL_CHAIN (t);\n-\tt = copy_node (t);\n-\tOVL_FUNCTION (t) = mapcar (OVL_FUNCTION (t), func);\n-\tOVL_CHAIN (t) = mapcar (chain, func);\n-\treturn t;\n-      }\n-\n-    case TREE_VEC:\n-      {\n-\tint len = TREE_VEC_LENGTH (t);\n-\n-\tt = copy_node (t);\n-\twhile (len--)\n-\t  TREE_VEC_ELT (t, len) = mapcar (TREE_VEC_ELT (t, len), func);\n-\treturn t;\n-      }\n+      /* Because the chain gets clobbered when we make a copy, we save it\n+\t here.  */\n+      tree chain = TREE_CHAIN (*tp);\n \n-    case INTEGER_CST:\n-    case REAL_CST:\n-    case STRING_CST:\n-      return copy_node (t);\n-\n-    case PTRMEM_CST:\n-      t = copy_node (t);\n-      TREE_TYPE (t) = mapcar (TREE_TYPE (t), func);\n-      PTRMEM_CST_MEMBER (t) = mapcar (PTRMEM_CST_MEMBER (t), func);\n-      return t;\n-\n-    case COND_EXPR:\n-    case TARGET_EXPR:\n-    case AGGR_INIT_EXPR:\n-      t = copy_node (t);\n-      TREE_OPERAND (t, 0) = mapcar (TREE_OPERAND (t, 0), func);\n-      TREE_OPERAND (t, 1) = mapcar (TREE_OPERAND (t, 1), func);\n-      TREE_OPERAND (t, 2) = mapcar (TREE_OPERAND (t, 2), func);\n-      return t;\n-\n-    case TRUTH_AND_EXPR:\n-    case TRUTH_OR_EXPR:\n-    case TRUTH_XOR_EXPR:\n-    case TRUTH_ANDIF_EXPR:\n-    case TRUTH_ORIF_EXPR:\n-    case PREDECREMENT_EXPR:\n-    case PREINCREMENT_EXPR:\n-    case POSTDECREMENT_EXPR:\n-    case POSTINCREMENT_EXPR:\n-    case ARRAY_REF:\n-    case SCOPE_REF:\n-    case TRY_CATCH_EXPR:\n-    case WITH_CLEANUP_EXPR:\n-    case COMPOUND_EXPR:\n-    case MODIFY_EXPR:\n-    case INIT_EXPR:\n-    case OFFSET_REF:\n-      t = copy_node (t);\n-      TREE_OPERAND (t, 0) = mapcar (TREE_OPERAND (t, 0), func);\n-      TREE_OPERAND (t, 1) = mapcar (TREE_OPERAND (t, 1), func);\n-      return t;\n-\n-    case CALL_EXPR:\n-      t = copy_node (t);\n-      TREE_TYPE (t) = mapcar (TREE_TYPE (t), func);\n-      TREE_OPERAND (t, 0) = mapcar (TREE_OPERAND (t, 0), func);\n-      TREE_OPERAND (t, 1) = mapcar (TREE_OPERAND (t, 1), func);\n-      TREE_OPERAND (t, 2) = NULL_TREE;\n-      return t;\n+      /* Copy the node.  */\n+      *tp = copy_node (*tp);\n \n-    case SAVE_EXPR:\n-    case ADDR_EXPR:\n-    case INDIRECT_REF:\n-    case TRUTH_NOT_EXPR:\n-    case COMPONENT_REF:\n-    case CLEANUP_POINT_EXPR:\n-    case THROW_EXPR:\n-    case STMT_EXPR:\n-    case VA_ARG_EXPR:\n-      t = copy_node (t);\n-      TREE_TYPE (t) = mapcar (TREE_TYPE (t), func);\n-      TREE_OPERAND (t, 0) = mapcar (TREE_OPERAND (t, 0), func);\n-      return t;\n-\n-    case POINTER_TYPE:\n-      tmp = build_pointer_type (mapcar (TREE_TYPE (t), func));\n-      return cp_build_qualified_type (tmp, TYPE_QUALS (t));\n-    case REFERENCE_TYPE:\n-      tmp = build_reference_type (mapcar (TREE_TYPE (t), func));\n-      return cp_build_qualified_type (tmp, TYPE_QUALS (t));\n-    case FUNCTION_TYPE:\n-      tmp = build_function_type (mapcar (TREE_TYPE (t), func),\n-\t\t\t\t mapcar (TYPE_ARG_TYPES (t), func));\n-      return cp_build_qualified_type (tmp, TYPE_QUALS (t));\n-    case ARRAY_TYPE:\n-      tmp = build_cplus_array_type (mapcar (TREE_TYPE (t), func),\n-\t\t\t\t    mapcar (TYPE_DOMAIN (t), func));\n-      return cp_build_qualified_type (tmp, CP_TYPE_QUALS (t));\n-    case INTEGER_TYPE:\n-      tmp = build_index_type (mapcar (TYPE_MAX_VALUE (t), func));\n-      return cp_build_qualified_type (tmp, TYPE_QUALS (t));\n-    case OFFSET_TYPE:\n-      tmp = build_offset_type (mapcar (TYPE_OFFSET_BASETYPE (t), func),\n-\t\t\t       mapcar (TREE_TYPE (t), func));\n-      return cp_build_qualified_type (tmp, TYPE_QUALS (t));\n-    case METHOD_TYPE:\n-      tmp = build_cplus_method_type\n-\t(mapcar (TREE_TYPE (TREE_VALUE (TYPE_ARG_TYPES (t))), func),\n-\t mapcar (TREE_TYPE (t), func),\n-\t mapcar (TREE_CHAIN (TYPE_ARG_TYPES (t)), func));\n-      return cp_build_qualified_type (tmp, TYPE_QUALS (t));\n-\n-    case COMPLEX_CST:\n-      t = copy_node (t);\n-      TREE_REALPART (t) = mapcar (TREE_REALPART (t), func);\n-      TREE_IMAGPART (t) = mapcar (TREE_REALPART (t), func);\n-      return t;\n-\n-    case CONSTRUCTOR:\n-      t = copy_node (t);\n-      CONSTRUCTOR_ELTS (t) = mapcar (CONSTRUCTOR_ELTS (t), func);\n-      return t;\n-\n-    case TEMPLATE_TEMPLATE_PARM:\n-      return copy_template_template_parm (t);\n-\n-    case BIND_EXPR:\n-      t = copy_node (t);\n-      TREE_OPERAND (t, 0) = mapcar (TREE_OPERAND (t, 0), func);\n-      TREE_OPERAND (t, 1) = mapcar (TREE_OPERAND (t, 1), func);\n-      TREE_OPERAND (t, 2) = NULL_TREE;\n-      return t;\n-\n-    case NEW_EXPR:\n-      t = copy_node (t);\n-      TREE_OPERAND (t, 0) = mapcar (TREE_OPERAND (t, 0), func);\n-      TREE_OPERAND (t, 1) = mapcar (TREE_OPERAND (t, 1), func);\n-      TREE_OPERAND (t, 2) = mapcar (TREE_OPERAND (t, 2), func);\n-      return t;\n-\n-    case BIT_FIELD_REF:\n-      t = copy_node (t);\n-      TREE_TYPE (t) = mapcar (TREE_TYPE (t), func);\n-      TREE_OPERAND (t, 0) = mapcar (TREE_OPERAND (t, 0), func);\n-      TREE_OPERAND (t, 1) = mapcar (TREE_OPERAND (t, 1), func);\n-      TREE_OPERAND (t, 2) = mapcar (TREE_OPERAND (t, 2), func);\n-      return t;\n-      \n-    case LOOKUP_EXPR:\n-    case EXIT_EXPR:\n-    case LOOP_EXPR:\n-      t = copy_node (t);\n-      TREE_OPERAND (t, 0) = mapcar (TREE_OPERAND (t, 0), func);\n-      return t;\n-\n-    case RTL_EXPR:\n-      t = copy_node (t);\n-      TREE_TYPE (t) = mapcar (TREE_TYPE (t), func);\n-      return t;\n-\n-    case RECORD_TYPE:\n-      if (TYPE_PTRMEMFUNC_P (t))\n-\treturn build_ptrmemfunc_type\n-\t  (mapcar (TYPE_PTRMEMFUNC_FN_TYPE (t), func));\n-      /* else fall through */\n-\n-    default:\n-      my_friendly_abort (19990815);\n+      /* Now, restore the chain, if appropriate.  That will cause\n+\t walk_tree to walk into the chain as well.  */\n+      if (code == PARM_DECL || code == TREE_LIST || code == OVERLOAD)\n+\tTREE_CHAIN (*tp) = chain;\n     }\n-  my_friendly_abort (107);\n-  /* NOTREACHED */\n+  else if (code == TEMPLATE_TEMPLATE_PARM)\n+    /* These must be copied specially.  */\n+    *tp = copy_template_template_parm (*tp);\n+\n   return NULL_TREE;\n }\n \n@@ -2092,24 +1831,23 @@ array_type_nelts_total (type)\n   return sz;\n }\n \n-/* When we parse a default argument expression, we may create\n-   temporary variables via TARGET_EXPRs.  When we actually use the\n-   default-argument expression, we make a copy of the expression, but\n-   we must relpace the temporaries with appropriate local versions.  */\n-\n-/* A map from VAR_DECLs declared in TARGET_EXPRs in a default argument\n-   to corresponding \"instantiations\" of those variables.  */\n-static splay_tree target_remap;\n-static int target_remap_count;\n-\n /* Called from break_out_target_exprs via mapcar.  */\n \n static tree\n-bot_manip (t)\n-     tree t;\n+bot_manip (tp, walk_subtrees, data)\n+     tree *tp;\n+     int *walk_subtrees;\n+     void *data;\n {\n+  splay_tree target_remap = ((splay_tree) data);\n+  tree t = *tp;\n+\n   if (TREE_CODE (t) != TREE_LIST && ! TREE_SIDE_EFFECTS (t))\n-    return t;\n+    {\n+      /* There can't be any TARGET_EXPRs below this point.  */\n+      *walk_subtrees = 0;\n+      return NULL_TREE;\n+    }\n   else if (TREE_CODE (t) == TARGET_EXPR)\n     {\n       tree u;\n@@ -2131,20 +1869,34 @@ bot_manip (t)\n       splay_tree_insert (target_remap, \n \t\t\t (splay_tree_key) TREE_OPERAND (t, 0), \n \t\t\t (splay_tree_value) TREE_OPERAND (u, 0));\n-      return u;\n+\n+      /* Replace the old expression with the new version.  */\n+      *tp = u;\n+      /* We don't have to go below this point; the recursive call to\n+\t break_out_target_exprs will have handled anything below this\n+\t point.  */\n+      *walk_subtrees = 0;\n+      return NULL_TREE;\n     }\n   else if (TREE_CODE (t) == CALL_EXPR)\n     mark_used (TREE_OPERAND (TREE_OPERAND (t, 0), 0));\n \n-  return NULL_TREE;\n+  /* Make a copy of this node.  */\n+  return copy_tree_r (tp, walk_subtrees, NULL);\n }\n   \n-/* Replace all remapped VAR_DECLs in T with their new equivalents.  */\n+/* Replace all remapped VAR_DECLs in T with their new equivalents.\n+   DATA is really a splay-tree mapping old variables to new\n+   variables.  */\n \n static tree\n-bot_replace (t)\n+bot_replace (t, walk_subtrees, data)\n      tree *t;\n+     int *walk_subtrees ATTRIBUTE_UNUSED;\n+     void *data;\n {\n+  splay_tree target_remap = ((splay_tree) data);\n+\n   if (TREE_CODE (*t) == VAR_DECL)\n     {\n       splay_tree_node n = splay_tree_lookup (target_remap,\n@@ -2156,18 +1908,24 @@ bot_replace (t)\n   return NULL_TREE;\n }\n \t\n-/* Actually, we'll just clean out the target exprs for the moment.  */\n+/* When we parse a default argument expression, we may create\n+   temporary variables via TARGET_EXPRs.  When we actually use the\n+   default-argument expression, we make a copy of the expression, but\n+   we must replace the temporaries with appropriate local versions.  */\n \n tree\n break_out_target_exprs (t)\n      tree t;\n {\n+  static int target_remap_count;\n+  static splay_tree target_remap;\n+\n   if (!target_remap_count++)\n     target_remap = splay_tree_new (splay_tree_compare_pointers, \n \t\t\t\t   /*splay_tree_delete_key_fn=*/NULL, \n \t\t\t\t   /*splay_tree_delete_value_fn=*/NULL);\n-  t = mapcar (t, bot_manip);\n-  search_tree (&t, bot_replace);\n+  walk_tree (&t, bot_manip, target_remap);\n+  walk_tree (&t, bot_replace, target_remap);\n \n   if (!--target_remap_count)\n     {"}]}