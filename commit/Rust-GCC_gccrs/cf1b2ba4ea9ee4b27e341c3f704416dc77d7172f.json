{"sha": "cf1b2ba4ea9ee4b27e341c3f704416dc77d7172f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Y2YxYjJiYTRlYTllZTRiMjdlMzQxYzNmNzA0NDE2ZGM3N2Q3MTcyZg==", "commit": {"author": {"name": "Richard Sandiford", "email": "richard.sandiford@linaro.org", "date": "2018-01-03T07:16:22Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2018-01-03T07:16:22Z"}, "message": "poly_int: vectorizable_simd_clone_call\n\nThis patch makes vectorizable_simd_clone_call cope with variable-length\nvectors.  For now we don't support SIMD clones for variable-length\nvectors; this will be post GCC 8 material.\n\n2018-01-03  Richard Sandiford  <richard.sandiford@linaro.org>\n\t    Alan Hayward  <alan.hayward@arm.com>\n\t    David Sherwood  <david.sherwood@arm.com>\n\ngcc/\n\t* tree-vect-stmts.c (simd_clone_subparts): New function.\n\t(vectorizable_simd_clone_call): Use it instead of TYPE_VECTOR_SUBPARTS.\n\nCo-Authored-By: Alan Hayward <alan.hayward@arm.com>\nCo-Authored-By: David Sherwood <david.sherwood@arm.com>\n\nFrom-SVN: r256138", "tree": {"sha": "17bb834b43110573e9272538071dae4523444139", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/17bb834b43110573e9272538071dae4523444139"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/cf1b2ba4ea9ee4b27e341c3f704416dc77d7172f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cf1b2ba4ea9ee4b27e341c3f704416dc77d7172f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cf1b2ba4ea9ee4b27e341c3f704416dc77d7172f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cf1b2ba4ea9ee4b27e341c3f704416dc77d7172f/comments", "author": null, "committer": null, "parents": [{"sha": "c7bda0f40e1ddd9fc2c347fafeab93350be036f8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c7bda0f40e1ddd9fc2c347fafeab93350be036f8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c7bda0f40e1ddd9fc2c347fafeab93350be036f8"}], "stats": {"total": 51, "additions": 34, "deletions": 17}, "files": [{"sha": "5379f0363d6206a94f32343bbab21a82c5dfa801", "filename": "gcc/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf1b2ba4ea9ee4b27e341c3f704416dc77d7172f/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf1b2ba4ea9ee4b27e341c3f704416dc77d7172f/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=cf1b2ba4ea9ee4b27e341c3f704416dc77d7172f", "patch": "@@ -1,3 +1,10 @@\n+2018-01-03  Richard Sandiford  <richard.sandiford@linaro.org>\n+\t    Alan Hayward  <alan.hayward@arm.com>\n+\t    David Sherwood  <david.sherwood@arm.com>\n+\n+\t* tree-vect-stmts.c (simd_clone_subparts): New function.\n+\t(vectorizable_simd_clone_call): Use it instead of TYPE_VECTOR_SUBPARTS.\n+\n 2018-01-03  Richard Sandiford  <richard.sandiford@linaro.org>\n \t    Alan Hayward  <alan.hayward@arm.com>\n \t    David Sherwood  <david.sherwood@arm.com>"}, {"sha": "603526163ad6a49714299dfe8b683b16081d47ee", "filename": "gcc/tree-vect-stmts.c", "status": "modified", "additions": 27, "deletions": 17, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf1b2ba4ea9ee4b27e341c3f704416dc77d7172f/gcc%2Ftree-vect-stmts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf1b2ba4ea9ee4b27e341c3f704416dc77d7172f/gcc%2Ftree-vect-stmts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-stmts.c?ref=cf1b2ba4ea9ee4b27e341c3f704416dc77d7172f", "patch": "@@ -3219,6 +3219,16 @@ vect_simd_lane_linear (tree op, struct loop *loop,\n     }\n }\n \n+/* Return the number of elements in vector type VECTYPE, which is associated\n+   with a SIMD clone.  At present these vectors always have a constant\n+   length.  */\n+\n+static unsigned HOST_WIDE_INT\n+simd_clone_subparts (tree vectype)\n+{\n+  return TYPE_VECTOR_SUBPARTS (vectype);\n+}\n+\n /* Function vectorizable_simd_clone_call.\n \n    Check if STMT performs a function call that can be vectorized\n@@ -3487,7 +3497,7 @@ vectorizable_simd_clone_call (gimple *stmt, gimple_stmt_iterator *gsi,\n \t  = get_vectype_for_scalar_type (TREE_TYPE (gimple_call_arg (stmt,\n \t\t\t\t\t\t\t\t     i)));\n \tif (arginfo[i].vectype == NULL\n-\t    || (TYPE_VECTOR_SUBPARTS (arginfo[i].vectype)\n+\t    || (simd_clone_subparts (arginfo[i].vectype)\n \t\t> bestn->simdclone->simdlen))\n \t  return false;\n       }\n@@ -3574,15 +3584,15 @@ vectorizable_simd_clone_call (gimple *stmt, gimple_stmt_iterator *gsi,\n \t    {\n \t    case SIMD_CLONE_ARG_TYPE_VECTOR:\n \t      atype = bestn->simdclone->args[i].vector_type;\n-\t      o = nunits / TYPE_VECTOR_SUBPARTS (atype);\n+\t      o = nunits / simd_clone_subparts (atype);\n \t      for (m = j * o; m < (j + 1) * o; m++)\n \t\t{\n-\t\t  if (TYPE_VECTOR_SUBPARTS (atype)\n-\t\t      < TYPE_VECTOR_SUBPARTS (arginfo[i].vectype))\n+\t\t  if (simd_clone_subparts (atype)\n+\t\t      < simd_clone_subparts (arginfo[i].vectype))\n \t\t    {\n \t\t      unsigned int prec = GET_MODE_BITSIZE (TYPE_MODE (atype));\n-\t\t      k = (TYPE_VECTOR_SUBPARTS (arginfo[i].vectype)\n-\t\t\t   / TYPE_VECTOR_SUBPARTS (atype));\n+\t\t      k = (simd_clone_subparts (arginfo[i].vectype)\n+\t\t\t   / simd_clone_subparts (atype));\n \t\t      gcc_assert ((k & (k - 1)) == 0);\n \t\t      if (m == 0)\n \t\t\tvec_oprnd0\n@@ -3608,8 +3618,8 @@ vectorizable_simd_clone_call (gimple *stmt, gimple_stmt_iterator *gsi,\n \t\t    }\n \t\t  else\n \t\t    {\n-\t\t      k = (TYPE_VECTOR_SUBPARTS (atype)\n-\t\t\t   / TYPE_VECTOR_SUBPARTS (arginfo[i].vectype));\n+\t\t      k = (simd_clone_subparts (atype)\n+\t\t\t   / simd_clone_subparts (arginfo[i].vectype));\n \t\t      gcc_assert ((k & (k - 1)) == 0);\n \t\t      vec<constructor_elt, va_gc> *ctor_elts;\n \t\t      if (k != 1)\n@@ -3727,11 +3737,11 @@ vectorizable_simd_clone_call (gimple *stmt, gimple_stmt_iterator *gsi,\n       new_stmt = gimple_build_call_vec (fndecl, vargs);\n       if (vec_dest)\n \t{\n-\t  gcc_assert (ratype || TYPE_VECTOR_SUBPARTS (rtype) == nunits);\n+\t  gcc_assert (ratype || simd_clone_subparts (rtype) == nunits);\n \t  if (ratype)\n \t    new_temp = create_tmp_var (ratype);\n-\t  else if (TYPE_VECTOR_SUBPARTS (vectype)\n-\t\t   == TYPE_VECTOR_SUBPARTS (rtype))\n+\t  else if (simd_clone_subparts (vectype)\n+\t\t   == simd_clone_subparts (rtype))\n \t    new_temp = make_ssa_name (vec_dest, new_stmt);\n \t  else\n \t    new_temp = make_ssa_name (rtype, new_stmt);\n@@ -3741,11 +3751,11 @@ vectorizable_simd_clone_call (gimple *stmt, gimple_stmt_iterator *gsi,\n \n       if (vec_dest)\n \t{\n-\t  if (TYPE_VECTOR_SUBPARTS (vectype) < nunits)\n+\t  if (simd_clone_subparts (vectype) < nunits)\n \t    {\n \t      unsigned int k, l;\n \t      unsigned int prec = GET_MODE_BITSIZE (TYPE_MODE (vectype));\n-\t      k = nunits / TYPE_VECTOR_SUBPARTS (vectype);\n+\t      k = nunits / simd_clone_subparts (vectype);\n \t      gcc_assert ((k & (k - 1)) == 0);\n \t      for (l = 0; l < k; l++)\n \t\t{\n@@ -3780,16 +3790,16 @@ vectorizable_simd_clone_call (gimple *stmt, gimple_stmt_iterator *gsi,\n \t\t}\n \t      continue;\n \t    }\n-\t  else if (TYPE_VECTOR_SUBPARTS (vectype) > nunits)\n+\t  else if (simd_clone_subparts (vectype) > nunits)\n \t    {\n-\t      unsigned int k = (TYPE_VECTOR_SUBPARTS (vectype)\n-\t\t\t\t/ TYPE_VECTOR_SUBPARTS (rtype));\n+\t      unsigned int k = (simd_clone_subparts (vectype)\n+\t\t\t\t/ simd_clone_subparts (rtype));\n \t      gcc_assert ((k & (k - 1)) == 0);\n \t      if ((j & (k - 1)) == 0)\n \t\tvec_alloc (ret_ctor_elts, k);\n \t      if (ratype)\n \t\t{\n-\t\t  unsigned int m, o = nunits / TYPE_VECTOR_SUBPARTS (rtype);\n+\t\t  unsigned int m, o = nunits / simd_clone_subparts (rtype);\n \t\t  for (m = 0; m < o; m++)\n \t\t    {\n \t\t      tree tem = build4 (ARRAY_REF, rtype, new_temp,"}]}