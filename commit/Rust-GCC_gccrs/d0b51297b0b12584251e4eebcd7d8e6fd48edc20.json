{"sha": "d0b51297b0b12584251e4eebcd7d8e6fd48edc20", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDBiNTEyOTdiMGIxMjU4NDI1MWU0ZWViY2Q3ZDhlNmZkNDhlZGMyMA==", "commit": {"author": {"name": "Jackson Woodruff", "email": "jackson.woodruff@arm.com", "date": "2018-05-30T10:59:25Z"}, "committer": {"name": "Kyrylo Tkachov", "email": "ktkachov@gcc.gnu.org", "date": "2018-05-30T10:59:25Z"}, "message": "[AArch64] Improve LDP/STP generation that requires a base register\n\nThis patch generalizes the formation of LDP/STP that require a base register.\n\nIn AArch64, LDP/STP instructions have different sized immediate offsets than\nnormal LDR/STR instructions. This part of the backend attempts to spot groups\nof four LDR/STR instructions that can be turned into LDP/STP instructions by\nusing a base register.\n\nPreviously, we would only accept address pairs that were ordered in ascending\nor descending order, and only strictly sequential loads/stores. In fact, the\ninstructions that we generate from this should be able to consider any order\nof loads or stores (provided that they can be re-ordered). They should also be\nable to accept non-sequential loads and stores provided that the two pairs of\naddresses are amenable to pairing. The current code is also overly restrictive\non the range of addresses that are accepted, as LDP/STP instructions may take\nnegative offsets as well as positive ones.\n\nThis patch improves that by allowing us to accept all orders of loads/stores\nthat are valid, and extending the range that the LDP/STP addresses can reach. \n\n2017-05-30  Jackson Woodruff  <jackson.woodruff@arm.com>\n\n\t* config/aarch64/aarch64.c (aarch64_host_wide_int_compare): New.\n\t(aarch64_ldrstr_offset_compare): New.\n\t(aarch64_operands_adjust_ok_for_ldpstp): Update to consider all\n\tload/store orderings.\n\t(aarch64_gen_adjusted_ldpstp): Likewise.\n\n\t* gcc.target/aarch64/simd/ldp_stp_9: New.\n\t* gcc.target/aarch64/simd/ldp_stp_10: New.\n\t* gcc.target/aarch64/simd/ldp_stp_11: New.\n\t* gcc.target/aarch64/simd/ldp_stp_12: New.\n\nFrom-SVN: r260952", "tree": {"sha": "21ad00bd75ac07a9a1b087a73e2a2587e24d064f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/21ad00bd75ac07a9a1b087a73e2a2587e24d064f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d0b51297b0b12584251e4eebcd7d8e6fd48edc20", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d0b51297b0b12584251e4eebcd7d8e6fd48edc20", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d0b51297b0b12584251e4eebcd7d8e6fd48edc20", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d0b51297b0b12584251e4eebcd7d8e6fd48edc20/comments", "author": null, "committer": null, "parents": [{"sha": "2eb2847ec54a3262f303f47697c5e5cbe3cc089d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2eb2847ec54a3262f303f47697c5e5cbe3cc089d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2eb2847ec54a3262f303f47697c5e5cbe3cc089d"}], "stats": {"total": 387, "additions": 290, "deletions": 97}, "files": [{"sha": "9b89baa67320d13d5c8adccf1b3b01d04bd2ebb3", "filename": "gcc/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0b51297b0b12584251e4eebcd7d8e6fd48edc20/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0b51297b0b12584251e4eebcd7d8e6fd48edc20/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=d0b51297b0b12584251e4eebcd7d8e6fd48edc20", "patch": "@@ -1,3 +1,11 @@\n+2017-05-30  Jackson Woodruff  <jackson.woodruff@arm.com>\n+\n+\t* config/aarch64/aarch64.c (aarch64_host_wide_int_compare): New.\n+\t(aarch64_ldrstr_offset_compare): New.\n+\t(aarch64_operands_adjust_ok_for_ldpstp): Update to consider all\n+\tload/store orderings.\n+\t(aarch64_gen_adjusted_ldpstp): Likewise.\n+\n 2018-05-30  Wilco Dijkstra  <wdijkstr@arm.com>\n \n \t* config/aarch64/aarch64.c (aarch64_ira_change_pseudo_allocno_class):"}, {"sha": "c94f7093b0880aee17a4f9b7a3a60b2c27a62f98", "filename": "gcc/config/aarch64/aarch64.c", "status": "modified", "additions": 164, "deletions": 97, "changes": 261, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0b51297b0b12584251e4eebcd7d8e6fd48edc20/gcc%2Fconfig%2Faarch64%2Faarch64.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0b51297b0b12584251e4eebcd7d8e6fd48edc20/gcc%2Fconfig%2Faarch64%2Faarch64.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Faarch64.c?ref=d0b51297b0b12584251e4eebcd7d8e6fd48edc20", "patch": "@@ -17033,6 +17033,50 @@ aarch64_swap_ldrstr_operands (rtx* operands, bool load)\n     }\n }\n \n+/* Taking X and Y to be HOST_WIDE_INT pointers, return the result of a\n+   comparison between the two.  */\n+int\n+aarch64_host_wide_int_compare (const void *x, const void *y)\n+{\n+  return wi::cmps (* ((const HOST_WIDE_INT *) x),\n+\t\t   * ((const HOST_WIDE_INT *) y));\n+}\n+\n+/* Taking X and Y to be pairs of RTX, one pointing to a MEM rtx and the\n+   other pointing to a REG rtx containing an offset, compare the offsets\n+   of the two pairs.\n+\n+   Return:\n+\n+\t1 iff offset (X) > offset (Y)\n+\t0 iff offset (X) == offset (Y)\n+\t-1 iff offset (X) < offset (Y)  */\n+int\n+aarch64_ldrstr_offset_compare (const void *x, const void *y)\n+{\n+  const rtx * operands_1 = (const rtx *) x;\n+  const rtx * operands_2 = (const rtx *) y;\n+  rtx mem_1, mem_2, base, offset_1, offset_2;\n+\n+  if (MEM_P (operands_1[0]))\n+    mem_1 = operands_1[0];\n+  else\n+    mem_1 = operands_1[1];\n+\n+  if (MEM_P (operands_2[0]))\n+    mem_2 = operands_2[0];\n+  else\n+    mem_2 = operands_2[1];\n+\n+  /* Extract the offsets.  */\n+  extract_base_offset_in_addr (mem_1, &base, &offset_1);\n+  extract_base_offset_in_addr (mem_2, &base, &offset_2);\n+\n+  gcc_assert (offset_1 != NULL_RTX && offset_2 != NULL_RTX);\n+\n+  return wi::cmps (INTVAL (offset_1), INTVAL (offset_2));\n+}\n+\n /* Given OPERANDS of consecutive load/store, check if we can merge\n    them into ldp/stp by adjusting the offset.  LOAD is true if they\n    are load instructions.  MODE is the mode of memory operands.\n@@ -17059,7 +17103,7 @@ aarch64_operands_adjust_ok_for_ldpstp (rtx *operands, bool load,\n \t\t\t\t       scalar_mode mode)\n {\n   enum reg_class rclass_1, rclass_2, rclass_3, rclass_4;\n-  HOST_WIDE_INT offval_1, offval_2, offval_3, offval_4, msize;\n+  HOST_WIDE_INT offvals[4], msize;\n   rtx mem_1, mem_2, mem_3, mem_4, reg_1, reg_2, reg_3, reg_4;\n   rtx base_1, base_2, base_3, base_4, offset_1, offset_2, offset_3, offset_4;\n \n@@ -17075,8 +17119,12 @@ aarch64_operands_adjust_ok_for_ldpstp (rtx *operands, bool load,\n       mem_4 = operands[7];\n       gcc_assert (REG_P (reg_1) && REG_P (reg_2)\n \t\t  && REG_P (reg_3) && REG_P (reg_4));\n-      if (REGNO (reg_1) == REGNO (reg_2) || REGNO (reg_3) == REGNO (reg_4))\n-\treturn false;\n+\n+      /* Do not attempt to merge the loads if the loads clobber each other.  */\n+      for (int i = 0; i < 8; i += 2)\n+\tfor (int j = i + 2; j < 8; j += 2)\n+\t  if (reg_overlap_mentioned_p (operands[i], operands[j]))\n+\t    return false;\n     }\n   else\n     {\n@@ -17118,32 +17166,34 @@ aarch64_operands_adjust_ok_for_ldpstp (rtx *operands, bool load,\n       || !rtx_equal_p (base_3, base_4))\n     return false;\n \n-  offval_1 = INTVAL (offset_1);\n-  offval_2 = INTVAL (offset_2);\n-  offval_3 = INTVAL (offset_3);\n-  offval_4 = INTVAL (offset_4);\n+  offvals[0] = INTVAL (offset_1);\n+  offvals[1] = INTVAL (offset_2);\n+  offvals[2] = INTVAL (offset_3);\n+  offvals[3] = INTVAL (offset_4);\n   msize = GET_MODE_SIZE (mode);\n-  /* Check if the offsets are consecutive.  */\n-  if ((offval_1 != (offval_2 + msize)\n-       || offval_1 != (offval_3 + msize * 2)\n-       || offval_1 != (offval_4 + msize * 3))\n-      && (offval_4 != (offval_3 + msize)\n-\t  || offval_4 != (offval_2 + msize * 2)\n-\t  || offval_4 != (offval_1 + msize * 3)))\n+\n+  /* Check if the offsets can be put in the right order to do a ldp/stp.  */\n+  qsort (offvals, 4, sizeof (HOST_WIDE_INT), aarch64_host_wide_int_compare);\n+\n+  if (!(offvals[1] == offvals[0] + msize\n+\t&& offvals[3] == offvals[2] + msize))\n     return false;\n \n-  /* Check if the addresses are clobbered by load.  */\n-  if (load)\n-    {\n-      if (reg_mentioned_p (reg_1, mem_1)\n-\t  || reg_mentioned_p (reg_2, mem_2)\n-\t  || reg_mentioned_p (reg_3, mem_3))\n-\treturn false;\n+  /* Check that offsets are within range of each other.  The ldp/stp\n+     instructions have 7 bit immediate offsets, so use 0x80.  */\n+  if (offvals[2] - offvals[0] >= msize * 0x80)\n+    return false;\n \n-      /* In increasing order, the last load can clobber the address.  */\n-      if (offval_1 > offval_2 && reg_mentioned_p (reg_4, mem_4))\n-\treturn false;\n-    }\n+  /* The offsets must be aligned with respect to each other.  */\n+  if (offvals[0] % msize != offvals[2] % msize)\n+    return false;\n+\n+  /* Check if the addresses are clobbered by load.  */\n+  if (load && (reg_mentioned_p (reg_1, mem_1)\n+\t       || reg_mentioned_p (reg_2, mem_2)\n+\t       || reg_mentioned_p (reg_3, mem_3)\n+\t       || reg_mentioned_p (reg_4, mem_4)))\n+    return false;\n \n   /* If we have SImode and slow unaligned ldp,\n      check the alignment to be at least 8 byte. */\n@@ -17182,8 +17232,8 @@ aarch64_operands_adjust_ok_for_ldpstp (rtx *operands, bool load,\n }\n \n /* Given OPERANDS of consecutive load/store, this function pairs them\n-   into ldp/stp after adjusting the offset.  It depends on the fact\n-   that addresses of load/store instructions are in increasing order.\n+   into LDP/STP after adjusting the offset.  It depends on the fact\n+   that the operands can be sorted so the offsets are correct for STP.\n    MODE is the mode of memory operands.  CODE is the rtl operator\n    which should be applied to all memory operands, it's SIGN_EXTEND,\n    ZERO_EXTEND or UNKNOWN.  */\n@@ -17192,100 +17242,109 @@ bool\n aarch64_gen_adjusted_ldpstp (rtx *operands, bool load,\n \t\t\t     scalar_mode mode, RTX_CODE code)\n {\n-  rtx base, offset_1, offset_2, t1, t2;\n+  rtx base, offset_1, offset_3, t1, t2;\n   rtx mem_1, mem_2, mem_3, mem_4;\n-  HOST_WIDE_INT off_val, abs_off, adj_off, new_off, stp_off_limit, msize;\n-\n-  if (load)\n-    {\n-      mem_1 = operands[1];\n-      mem_2 = operands[3];\n-    }\n-  else\n-    {\n-      mem_1 = operands[0];\n-      mem_2 = operands[2];\n-    }\n+  rtx temp_operands[8];\n+  HOST_WIDE_INT off_val_1, off_val_3, base_off, new_off_1, new_off_3,\n+\t\tstp_off_upper_limit, stp_off_lower_limit, msize;\n \n-  extract_base_offset_in_addr (mem_1, &base, &offset_1);\n-  extract_base_offset_in_addr (mem_2, &base, &offset_2);\n-  gcc_assert (base != NULL_RTX && offset_1 != NULL_RTX\n-\t      && offset_2 != NULL_RTX);\n+  /* We make changes on a copy as we may still bail out.  */\n+  for (int i = 0; i < 8; i ++)\n+    temp_operands[i] = operands[i];\n \n-  if (INTVAL (offset_1) > INTVAL (offset_2))\n-    {\n-      std::swap (operands[0], operands[6]);\n-      std::swap (operands[1], operands[7]);\n-      std::swap (operands[2], operands[4]);\n-      std::swap (operands[3], operands[5]);\n-    }\n+  /* Sort the operands.  */\n+  qsort (temp_operands, 4, 2 * sizeof (rtx *), aarch64_ldrstr_offset_compare);\n \n   if (load)\n     {\n-      mem_1 = operands[1];\n-      mem_2 = operands[3];\n-      mem_3 = operands[5];\n-      mem_4 = operands[7];\n+      mem_1 = temp_operands[1];\n+      mem_2 = temp_operands[3];\n+      mem_3 = temp_operands[5];\n+      mem_4 = temp_operands[7];\n     }\n   else\n     {\n-      mem_1 = operands[0];\n-      mem_2 = operands[2];\n-      mem_3 = operands[4];\n-      mem_4 = operands[6];\n+      mem_1 = temp_operands[0];\n+      mem_2 = temp_operands[2];\n+      mem_3 = temp_operands[4];\n+      mem_4 = temp_operands[6];\n       gcc_assert (code == UNKNOWN);\n     }\n \n-  /* Extract the offset of the new first address.  */\n   extract_base_offset_in_addr (mem_1, &base, &offset_1);\n-  extract_base_offset_in_addr (mem_2, &base, &offset_2);\n+  extract_base_offset_in_addr (mem_3, &base, &offset_3);\n+  gcc_assert (base != NULL_RTX && offset_1 != NULL_RTX\n+\t      && offset_3 != NULL_RTX);\n \n-  /* Adjust offset thus it can fit in ldp/stp instruction.  */\n+  /* Adjust offset so it can fit in LDP/STP instruction.  */\n   msize = GET_MODE_SIZE (mode);\n-  stp_off_limit = msize * 0x40;\n-  off_val = INTVAL (offset_1);\n-  abs_off = (off_val < 0) ? -off_val : off_val;\n-  new_off = abs_off % stp_off_limit;\n-  adj_off = abs_off - new_off;\n+  stp_off_upper_limit = msize * (0x40 - 1);\n+  stp_off_lower_limit = - msize * 0x40;\n \n-  /* Further adjust to make sure all offsets are OK.  */\n-  if ((new_off + msize * 2) >= stp_off_limit)\n+  off_val_1 = INTVAL (offset_1);\n+  off_val_3 = INTVAL (offset_3);\n+\n+  /* The base offset is optimally half way between the two STP/LDP offsets.  */\n+  if (msize <= 4)\n+    base_off = (off_val_1 + off_val_3) / 2;\n+  else\n+    /* However, due to issues with negative LDP/STP offset generation for\n+       larger modes, for DF, DI and vector modes. we must not use negative\n+       addresses smaller than 9 signed unadjusted bits can store.  This\n+       provides the most range in this case.  */\n+    base_off = off_val_1;\n+\n+  /* Adjust the base so that it is aligned with the addresses but still\n+     optimal.  */\n+  if (base_off % msize != off_val_1 % msize)\n+    /* Fix the offset, bearing in mind we want to make it bigger not\n+       smaller.  */\n+    base_off += (((base_off % msize) - (off_val_1 % msize)) + msize) % msize;\n+  else if (msize <= 4)\n+    /* The negative range of LDP/STP is one larger than the positive range.  */\n+    base_off += msize;\n+\n+  /* Check if base offset is too big or too small.  We can attempt to resolve\n+     this issue by setting it to the maximum value and seeing if the offsets\n+     still fit.  */\n+  if (base_off >= 0x1000)\n     {\n-      adj_off += stp_off_limit;\n-      new_off -= stp_off_limit;\n+      base_off = 0x1000 - 1;\n+      /* We must still make sure that the base offset is aligned with respect\n+\t to the address.  But it may may not be made any bigger.  */\n+      base_off -= (((base_off % msize) - (off_val_1 % msize)) + msize) % msize;\n     }\n \n-  /* Make sure the adjustment can be done with ADD/SUB instructions.  */\n-  if (adj_off >= 0x1000)\n-    return false;\n-\n-  if (off_val < 0)\n+  /* Likewise for the case where the base is too small.  */\n+  if (base_off <= -0x1000)\n     {\n-      adj_off = -adj_off;\n-      new_off = -new_off;\n+      base_off = -0x1000 + 1;\n+      base_off += (((base_off % msize) - (off_val_1 % msize)) + msize) % msize;\n     }\n \n-  /* Create new memory references.  */\n-  mem_1 = change_address (mem_1, VOIDmode,\n-\t\t\t  plus_constant (DImode, operands[8], new_off));\n+  /* Offset of the first STP/LDP.  */\n+  new_off_1 = off_val_1 - base_off;\n+\n+  /* Offset of the second STP/LDP.  */\n+  new_off_3 = off_val_3 - base_off;\n \n-  /* Check if the adjusted address is OK for ldp/stp.  */\n-  if (!aarch64_mem_pair_operand (mem_1, mode))\n+  /* The offsets must be within the range of the LDP/STP instructions.  */\n+  if (new_off_1 > stp_off_upper_limit || new_off_1 < stp_off_lower_limit\n+      || new_off_3 > stp_off_upper_limit || new_off_3 < stp_off_lower_limit)\n     return false;\n \n-  msize = GET_MODE_SIZE (mode);\n-  mem_2 = change_address (mem_2, VOIDmode,\n-\t\t\t  plus_constant (DImode,\n-\t\t\t\t\t operands[8],\n-\t\t\t\t\t new_off + msize));\n-  mem_3 = change_address (mem_3, VOIDmode,\n-\t\t\t  plus_constant (DImode,\n-\t\t\t\t\t operands[8],\n-\t\t\t\t\t new_off + msize * 2));\n-  mem_4 = change_address (mem_4, VOIDmode,\n-\t\t\t  plus_constant (DImode,\n-\t\t\t\t\t operands[8],\n-\t\t\t\t\t new_off + msize * 3));\n+  replace_equiv_address_nv (mem_1, plus_constant (Pmode, operands[8],\n+\t\t\t\t\t\t  new_off_1), true);\n+  replace_equiv_address_nv (mem_2, plus_constant (Pmode, operands[8],\n+\t\t\t\t\t\t  new_off_1 + msize), true);\n+  replace_equiv_address_nv (mem_3, plus_constant (Pmode, operands[8],\n+\t\t\t\t\t\t  new_off_3), true);\n+  replace_equiv_address_nv (mem_4, plus_constant (Pmode, operands[8],\n+\t\t\t\t\t\t  new_off_3 + msize), true);\n+\n+  if (!aarch64_mem_pair_operand (mem_1, mode)\n+      || !aarch64_mem_pair_operand (mem_3, mode))\n+    return false;\n \n   if (code == ZERO_EXTEND)\n     {\n@@ -17304,21 +17363,29 @@ aarch64_gen_adjusted_ldpstp (rtx *operands, bool load,\n \n   if (load)\n     {\n+      operands[0] = temp_operands[0];\n       operands[1] = mem_1;\n+      operands[2] = temp_operands[2];\n       operands[3] = mem_2;\n+      operands[4] = temp_operands[4];\n       operands[5] = mem_3;\n+      operands[6] = temp_operands[6];\n       operands[7] = mem_4;\n     }\n   else\n     {\n       operands[0] = mem_1;\n+      operands[1] = temp_operands[1];\n       operands[2] = mem_2;\n+      operands[3] = temp_operands[3];\n       operands[4] = mem_3;\n+      operands[5] = temp_operands[5];\n       operands[6] = mem_4;\n+      operands[7] = temp_operands[7];\n     }\n \n   /* Emit adjusting instruction.  */\n-  emit_insn (gen_rtx_SET (operands[8], plus_constant (DImode, base, adj_off)));\n+  emit_insn (gen_rtx_SET (operands[8], plus_constant (DImode, base, base_off)));\n   /* Emit ldp/stp instructions.  */\n   t1 = gen_rtx_SET (operands[0], operands[1]);\n   t2 = gen_rtx_SET (operands[2], operands[3]);"}, {"sha": "158b8800234bf03eb970cd0b2489e20969a78389", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0b51297b0b12584251e4eebcd7d8e6fd48edc20/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0b51297b0b12584251e4eebcd7d8e6fd48edc20/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=d0b51297b0b12584251e4eebcd7d8e6fd48edc20", "patch": "@@ -1,3 +1,10 @@\n+2017-05-30  Jackson Woodruff  <jackson.woodruff@arm.com>\n+\n+\t* gcc.target/aarch64/simd/ldp_stp_9: New.\n+\t* gcc.target/aarch64/simd/ldp_stp_10: New.\n+\t* gcc.target/aarch64/simd/ldp_stp_11: New.\n+\t* gcc.target/aarch64/simd/ldp_stp_12: New.\n+\n 2018-05-30  Ed Schonberg  <schonberg@adacore.com>\n \n \t* gnat.dg/tls1.adb, gnat.dg/tls1_pkg.ads: New testcase."}, {"sha": "31f392901d2ca9e9e31cb20735fdf86eb040ee88", "filename": "gcc/testsuite/gcc.target/aarch64/ldp_stp_10.c", "status": "added", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0b51297b0b12584251e4eebcd7d8e6fd48edc20/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fldp_stp_10.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0b51297b0b12584251e4eebcd7d8e6fd48edc20/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fldp_stp_10.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fldp_stp_10.c?ref=d0b51297b0b12584251e4eebcd7d8e6fd48edc20", "patch": "@@ -0,0 +1,33 @@\n+/* { dg-options \"-O2\" } */\n+\n+int\n+load (int *arr)\n+{\n+  return arr[527] << 1 + arr[400] << 1 + arr[401] << 1 + arr[528] << 1;\n+}\n+\n+/* { dg-final { scan-assembler-times \"ldp\\tw\\[0-9\\]+, w\\[0-9\\]+, \" 2 } } */\n+\n+float\n+load_float (float *arr)\n+{\n+  return arr[404] + arr[403] + arr[400] + arr[401];\n+}\n+\n+/* { dg-final { scan-assembler-times \"ldp\\ts\\[0-9\\]+, s\\[0-9\\]+, \" 2 } } */\n+\n+long long\n+load_long (long long int *arr)\n+{\n+  return arr[400] << 1 + arr[401] << 1 + arr[403] << 1 + arr[404] << 1;\n+}\n+\n+/* { dg-final { scan-assembler-times \"ldp\\tx\\[0-9\\]+, x\\[0-9\\]+, \" 2 } } */\n+\n+double\n+load_double (double *arr)\n+{\n+  return arr[200] + arr[201] + arr[263] + arr[264];\n+}\n+\n+/* { dg-final { scan-assembler-times \"ldp\\td\\[0-9\\]+, d\\[0-9\\]+, \" 2 } } */"}, {"sha": "73e9fd7161ff9c313d6b4eaf1a3e88f75dc8bb01", "filename": "gcc/testsuite/gcc.target/aarch64/ldp_stp_11.c", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0b51297b0b12584251e4eebcd7d8e6fd48edc20/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fldp_stp_11.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0b51297b0b12584251e4eebcd7d8e6fd48edc20/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fldp_stp_11.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fldp_stp_11.c?ref=d0b51297b0b12584251e4eebcd7d8e6fd48edc20", "patch": "@@ -0,0 +1,16 @@\n+/* { dg-options \"-O2\" } */\n+\n+double\n+load_one (double *in)\n+{\n+  return in[400] + in[401] + in[527] + in[528];\n+}\n+\n+double\n+load_two (double *in)\n+{\n+  return in[400] + in[401] + in[464] + in[465];\n+}\n+\n+/* This is expected to fail due to PR 82214.  */\n+/* { dg-final { scan-assembler-times \"stp\\td\\[0-9\\]+, d\\[0-9\\]+,\" 4 { xfail *-*-* } } } */"}, {"sha": "718e82b53f0ccfd09a19afa26ebdb88654359e33", "filename": "gcc/testsuite/gcc.target/aarch64/ldp_stp_12.c", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0b51297b0b12584251e4eebcd7d8e6fd48edc20/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fldp_stp_12.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0b51297b0b12584251e4eebcd7d8e6fd48edc20/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fldp_stp_12.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fldp_stp_12.c?ref=d0b51297b0b12584251e4eebcd7d8e6fd48edc20", "patch": "@@ -0,0 +1,13 @@\n+/* { dg-options \"-O2\" } */\n+\n+void\n+store_offset (int *array, int x, int y)\n+{\n+  array[1085] = x;\n+  array[1084] = y;\n+\n+  array[1086] = y;\n+  array[1087] = 5;\n+}\n+\n+/* { dg-final { scan-assembler-times \"stp\\tw\\[0-9\\]+, w\\[0-9\\]+, \" 2 } } */"}, {"sha": "8f9564595b26b39c5bdc160d396886c57e48f841", "filename": "gcc/testsuite/gcc.target/aarch64/ldp_stp_9.c", "status": "added", "additions": 49, "deletions": 0, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0b51297b0b12584251e4eebcd7d8e6fd48edc20/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fldp_stp_9.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0b51297b0b12584251e4eebcd7d8e6fd48edc20/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fldp_stp_9.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fldp_stp_9.c?ref=d0b51297b0b12584251e4eebcd7d8e6fd48edc20", "patch": "@@ -0,0 +1,49 @@\n+/* { dg-options \"-O2\" } */\n+\n+void\n+store (int *arr, int x, int y, int z)\n+{\n+  arr[400] = x;\n+  arr[401] = y;\n+\n+  arr[500] = z;\n+  arr[501] = x;\n+}\n+\n+/* { dg-final { scan-assembler-times \"stp\\tw\\[0-9\\]+, w\\[0-9\\]+, \" 2 } } */\n+\n+void\n+store_float (float *arr, float x, float y)\n+{\n+  arr[404] = x;\n+  arr[403] = y;\n+\n+  arr[400] = x;\n+  arr[401] = y;\n+}\n+\n+/* { dg-final { scan-assembler-times \"stp\\ts\\[0-9\\]+, s\\[0-9\\]+, \" 2 } } */\n+\n+void\n+store_long (long long int *arr, long long int x, long long int y)\n+{\n+  arr[400] = x;\n+  arr[401] = y;\n+\n+  arr[403] = y;\n+  arr[404] = x;\n+}\n+\n+/* { dg-final { scan-assembler-times \"stp\\tx\\[0-9\\]+, x\\[0-9\\]+, \" 2 } } */\n+\n+void\n+store_double (double *arr, double x, double y)\n+{\n+  arr[200] = x;\n+  arr[201] = y;\n+\n+  arr[263] = y;\n+  arr[264] = x;\n+}\n+\n+/* { dg-final { scan-assembler-times \"stp\\td\\[0-9\\]+, d\\[0-9\\]+, \" 2 } } */"}]}