{"sha": "2e7fc8780e0d5009bc8edd116378a25dea8cb1fa", "node_id": "C_kwDOANBUbNoAKDJlN2ZjODc4MGUwZDUwMDliYzhlZGQxMTYzNzhhMjVkZWE4Y2IxZmE", "commit": {"author": {"name": "Arthur Cohen", "email": "arthur.cohen@embecosm.com", "date": "2022-08-23T15:27:23Z"}, "committer": {"name": "Arthur Cohen", "email": "arthur.cohen@embecosm.com", "date": "2022-12-13T13:00:05Z"}, "message": "gccrs: Add attributes checker\n\nThe attribute checker is responsible for checking the validity of various\nattributes including built-in ones. It is currently unfinished and will\nreceive some modifications, as well as become the host of some existing\ncode in the compiler which needs to be refactored. One of its\nresponsibilities is to make sure that arguments given to built-in\nattributes are correct, or contain the correct type of information. This\nvisitor also checks that an attribute is allowed to be used in the current\nparticular context.\n\n\tgcc/rust/\n\t* util/rust-attributes.cc: New.\n\t* util/rust-attributes.h: New.", "tree": {"sha": "42385a3fd9a961a9295df6daadd9e4f21f474430", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/42385a3fd9a961a9295df6daadd9e4f21f474430"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2e7fc8780e0d5009bc8edd116378a25dea8cb1fa", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2e7fc8780e0d5009bc8edd116378a25dea8cb1fa", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2e7fc8780e0d5009bc8edd116378a25dea8cb1fa", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2e7fc8780e0d5009bc8edd116378a25dea8cb1fa/comments", "author": {"login": "CohenArthur", "id": 43524065, "node_id": "MDQ6VXNlcjQzNTI0MDY1", "avatar_url": "https://avatars.githubusercontent.com/u/43524065?v=4", "gravatar_id": "", "url": "https://api.github.com/users/CohenArthur", "html_url": "https://github.com/CohenArthur", "followers_url": "https://api.github.com/users/CohenArthur/followers", "following_url": "https://api.github.com/users/CohenArthur/following{/other_user}", "gists_url": "https://api.github.com/users/CohenArthur/gists{/gist_id}", "starred_url": "https://api.github.com/users/CohenArthur/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/CohenArthur/subscriptions", "organizations_url": "https://api.github.com/users/CohenArthur/orgs", "repos_url": "https://api.github.com/users/CohenArthur/repos", "events_url": "https://api.github.com/users/CohenArthur/events{/privacy}", "received_events_url": "https://api.github.com/users/CohenArthur/received_events", "type": "User", "site_admin": false}, "committer": {"login": "CohenArthur", "id": 43524065, "node_id": "MDQ6VXNlcjQzNTI0MDY1", "avatar_url": "https://avatars.githubusercontent.com/u/43524065?v=4", "gravatar_id": "", "url": "https://api.github.com/users/CohenArthur", "html_url": "https://github.com/CohenArthur", "followers_url": "https://api.github.com/users/CohenArthur/followers", "following_url": "https://api.github.com/users/CohenArthur/following{/other_user}", "gists_url": "https://api.github.com/users/CohenArthur/gists{/gist_id}", "starred_url": "https://api.github.com/users/CohenArthur/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/CohenArthur/subscriptions", "organizations_url": "https://api.github.com/users/CohenArthur/orgs", "repos_url": "https://api.github.com/users/CohenArthur/repos", "events_url": "https://api.github.com/users/CohenArthur/events{/privacy}", "received_events_url": "https://api.github.com/users/CohenArthur/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9a4fee5f57c1ba6844407f81a6a40c30bc2735d4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9a4fee5f57c1ba6844407f81a6a40c30bc2735d4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9a4fee5f57c1ba6844407f81a6a40c30bc2735d4"}], "stats": {"total": 1109, "additions": 1109, "deletions": 0}, "files": [{"sha": "b73e95344149f4b2a8b9c9253d675421e0f49f3b", "filename": "gcc/rust/util/rust-attributes.cc", "status": "added", "additions": 839, "deletions": 0, "changes": 839, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2e7fc8780e0d5009bc8edd116378a25dea8cb1fa/gcc%2Frust%2Futil%2Frust-attributes.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2e7fc8780e0d5009bc8edd116378a25dea8cb1fa/gcc%2Frust%2Futil%2Frust-attributes.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Futil%2Frust-attributes.cc?ref=2e7fc8780e0d5009bc8edd116378a25dea8cb1fa", "patch": "@@ -0,0 +1,839 @@\n+// Copyright (C) 2020-2022 Free Software Foundation, Inc.\n+\n+// This file is part of GCC.\n+\n+// GCC is free software; you can redistribute it and/or modify it under\n+// the terms of the GNU General Public License as published by the Free\n+// Software Foundation; either version 3, or (at your option) any later\n+// version.\n+\n+// GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+// WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+// for more details.\n+\n+// You should have received a copy of the GNU General Public License\n+// along with GCC; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#include \"rust-system.h\"\n+#include \"rust-attributes.h\"\n+#include \"rust-ast.h\"\n+#include \"rust-ast-full.h\"\n+#include \"rust-diagnostics.h\"\n+\n+namespace Rust {\n+namespace Analysis {\n+\n+// https://doc.rust-lang.org/stable/nightly-rustc/src/rustc_feature/builtin_attrs.rs.html#248\n+static const BuiltinAttrDefinition __definitions[] = {\n+  {\"inline\", CODE_GENERATION},\n+  {\"cold\", CODE_GENERATION},\n+  {\"cfg\", EXPANSION},\n+  {\"cfg_attr\", EXPANSION},\n+  {\"deprecated\", STATIC_ANALYSIS},\n+  {\"allow\", STATIC_ANALYSIS},\n+  {\"doc\", HIR_LOWERING},\n+  {\"must_use\", STATIC_ANALYSIS},\n+  {\"lang\", HIR_LOWERING},\n+  {\"link_section\", CODE_GENERATION},\n+  {\"no_mangle\", CODE_GENERATION},\n+  {\"repr\", CODE_GENERATION},\n+  {\"path\", EXPANSION},\n+};\n+\n+BuiltinAttributeMappings *\n+BuiltinAttributeMappings::get ()\n+{\n+  static BuiltinAttributeMappings *instance = nullptr;\n+  if (instance == nullptr)\n+    instance = new BuiltinAttributeMappings ();\n+\n+  return instance;\n+}\n+\n+const BuiltinAttrDefinition &\n+BuiltinAttributeMappings::lookup_builtin (const std::string &attr_name) const\n+{\n+  auto it = mappings.find (attr_name);\n+  if (it == mappings.end ())\n+    return BuiltinAttrDefinition::error_node ();\n+\n+  return it->second;\n+}\n+\n+BuiltinAttributeMappings::BuiltinAttributeMappings ()\n+{\n+  size_t ndefinitions = sizeof (__definitions) / sizeof (BuiltinAttrDefinition);\n+  for (size_t i = 0; i < ndefinitions; i++)\n+    {\n+      const BuiltinAttrDefinition &def = __definitions[i];\n+      mappings.insert ({def.name, def});\n+    }\n+}\n+\n+AttributeChecker::AttributeChecker () {}\n+\n+void\n+AttributeChecker::go (AST::Crate &crate)\n+{\n+  check_attributes (crate.get_inner_attrs ());\n+\n+  for (auto &item : crate.items)\n+    item->accept_vis (*this);\n+}\n+\n+static bool\n+is_builtin (const AST::Attribute &attribute, BuiltinAttrDefinition &builtin)\n+{\n+  auto &segments = attribute.get_path ().get_segments ();\n+\n+  // Builtin attributes always have a single segment. This avoids us creating\n+  // strings all over the place and performing a linear search in the builtins\n+  // map\n+  if (segments.size () != 1)\n+    return false;\n+\n+  builtin = BuiltinAttributeMappings::get ()->lookup_builtin (\n+    segments.at (0).get_segment_name ());\n+\n+  return !builtin.is_error ();\n+}\n+\n+/**\n+ * Check that the string given to #[doc(alias = ...)] or #[doc(alias(...))] is\n+ * valid.\n+ *\n+ * This means no whitespace characters other than spaces and no quoting\n+ * characters.\n+ */\n+static void\n+check_doc_alias (const std::string &alias_input, const Location &locus)\n+{\n+  // FIXME: The locus here is for the whole attribute. Can we get the locus\n+  // of the alias input instead?\n+  for (auto c : alias_input)\n+    if ((ISSPACE (c) && c != ' ') || c == '\\'' || c == '\\\"')\n+      {\n+\tauto to_print = std::string (1, c);\n+\tswitch (c)\n+\t  {\n+\t  case '\\n':\n+\t    to_print = \"\\\\n\";\n+\t    break;\n+\t  case '\\t':\n+\t    to_print = \"\\\\t\";\n+\t    break;\n+\t  default:\n+\t    break;\n+\t  }\n+\trust_error_at (locus,\n+\t\t       \"invalid character used in %<#[doc(alias)]%> input: %qs\",\n+\t\t       to_print.c_str ());\n+      }\n+\n+  if (alias_input.empty ())\n+    return;\n+\n+  if (alias_input.front () == ' ' || alias_input.back () == ' ')\n+    rust_error_at (locus,\n+\t\t   \"%<#[doc(alias)]%> input cannot start or end with a space\");\n+}\n+\n+static void\n+check_doc_attribute (const AST::Attribute &attribute)\n+{\n+  if (!attribute.has_attr_input ())\n+    {\n+      rust_error_at (\n+\tattribute.get_locus (),\n+\t// FIXME: Improve error message here. Rustc has a very good one\n+\t\"%<#[doc]%> cannot be an empty attribute\");\n+      return;\n+    }\n+\n+  switch (attribute.get_attr_input ().get_attr_input_type ())\n+    {\n+    case AST::AttrInput::LITERAL:\n+    case AST::AttrInput::META_ITEM:\n+      break;\n+      // FIXME: Handle them as well\n+\n+      case AST::AttrInput::TOKEN_TREE: {\n+\t// FIXME: This doesn't check for #[doc(alias(...))]\n+\tconst auto &option = static_cast<const AST::DelimTokenTree &> (\n+\t  attribute.get_attr_input ());\n+\tauto *meta_item = option.parse_to_meta_item ();\n+\n+\tfor (auto &item : meta_item->get_items ())\n+\t  {\n+\t    if (item->is_key_value_pair ())\n+\t      {\n+\t\tauto name_value\n+\t\t  = static_cast<AST::MetaNameValueStr *> (item.get ())\n+\t\t      ->get_name_value_pair ();\n+\n+\t\t// FIXME: Check for other stuff than #[doc(alias = ...)]\n+\t\tif (name_value.first == \"alias\")\n+\t\t  check_doc_alias (name_value.second, attribute.get_locus ());\n+\t      }\n+\t  }\n+\tbreak;\n+      }\n+    }\n+}\n+\n+void\n+AttributeChecker::check_attribute (const AST::Attribute &attribute)\n+{\n+  BuiltinAttrDefinition result;\n+\n+  // This checker does not check non-builtin attributes\n+  if (!is_builtin (attribute, result))\n+    return;\n+\n+  // TODO: Add checks here for each builtin attribute\n+  // TODO: Have an enum of builtins as well, switching on strings is annoying\n+  // and costly\n+  if (result.name == \"doc\")\n+    check_doc_attribute (attribute);\n+}\n+\n+void\n+AttributeChecker::check_attributes (const AST::AttrVec &attributes)\n+{\n+  for (auto &attr : attributes)\n+    check_attribute (attr);\n+}\n+\n+void\n+AttributeChecker::visit (AST::Token &tok)\n+{}\n+\n+void\n+AttributeChecker::visit (AST::DelimTokenTree &delim_tok_tree)\n+{}\n+\n+void\n+AttributeChecker::visit (AST::AttrInputMetaItemContainer &input)\n+{}\n+\n+void\n+AttributeChecker::visit (AST::IdentifierExpr &ident_expr)\n+{}\n+\n+void\n+AttributeChecker::visit (AST::Lifetime &lifetime)\n+{}\n+\n+void\n+AttributeChecker::visit (AST::LifetimeParam &lifetime_param)\n+{}\n+\n+void\n+AttributeChecker::visit (AST::ConstGenericParam &const_param)\n+{}\n+\n+// rust-path.h\n+void\n+AttributeChecker::visit (AST::PathInExpression &path)\n+{}\n+\n+void\n+AttributeChecker::visit (AST::TypePathSegment &segment)\n+{}\n+\n+void\n+AttributeChecker::visit (AST::TypePathSegmentGeneric &segment)\n+{}\n+\n+void\n+AttributeChecker::visit (AST::TypePathSegmentFunction &segment)\n+{}\n+\n+void\n+AttributeChecker::visit (AST::TypePath &path)\n+{}\n+\n+void\n+AttributeChecker::visit (AST::QualifiedPathInExpression &path)\n+{}\n+\n+void\n+AttributeChecker::visit (AST::QualifiedPathInType &path)\n+{}\n+\n+// rust-expr.h\n+void\n+AttributeChecker::visit (AST::LiteralExpr &expr)\n+{}\n+\n+void\n+AttributeChecker::visit (AST::AttrInputLiteral &attr_input)\n+{}\n+\n+void\n+AttributeChecker::visit (AST::MetaItemLitExpr &meta_item)\n+{}\n+\n+void\n+AttributeChecker::visit (AST::MetaItemPathLit &meta_item)\n+{}\n+\n+void\n+AttributeChecker::visit (AST::BorrowExpr &expr)\n+{}\n+\n+void\n+AttributeChecker::visit (AST::DereferenceExpr &expr)\n+{}\n+\n+void\n+AttributeChecker::visit (AST::ErrorPropagationExpr &expr)\n+{}\n+\n+void\n+AttributeChecker::visit (AST::NegationExpr &expr)\n+{}\n+\n+void\n+AttributeChecker::visit (AST::ArithmeticOrLogicalExpr &expr)\n+{}\n+\n+void\n+AttributeChecker::visit (AST::ComparisonExpr &expr)\n+{}\n+\n+void\n+AttributeChecker::visit (AST::LazyBooleanExpr &expr)\n+{}\n+\n+void\n+AttributeChecker::visit (AST::TypeCastExpr &expr)\n+{}\n+\n+void\n+AttributeChecker::visit (AST::AssignmentExpr &expr)\n+{}\n+\n+void\n+AttributeChecker::visit (AST::CompoundAssignmentExpr &expr)\n+{}\n+\n+void\n+AttributeChecker::visit (AST::GroupedExpr &expr)\n+{}\n+\n+void\n+AttributeChecker::visit (AST::ArrayElemsValues &elems)\n+{}\n+\n+void\n+AttributeChecker::visit (AST::ArrayElemsCopied &elems)\n+{}\n+\n+void\n+AttributeChecker::visit (AST::ArrayExpr &expr)\n+{}\n+\n+void\n+AttributeChecker::visit (AST::ArrayIndexExpr &expr)\n+{}\n+\n+void\n+AttributeChecker::visit (AST::TupleExpr &expr)\n+{}\n+\n+void\n+AttributeChecker::visit (AST::TupleIndexExpr &expr)\n+{}\n+\n+void\n+AttributeChecker::visit (AST::StructExprStruct &expr)\n+{}\n+\n+void\n+AttributeChecker::visit (AST::StructExprFieldIdentifier &field)\n+{}\n+\n+void\n+AttributeChecker::visit (AST::StructExprFieldIdentifierValue &field)\n+{}\n+\n+void\n+AttributeChecker::visit (AST::StructExprFieldIndexValue &field)\n+{}\n+\n+void\n+AttributeChecker::visit (AST::StructExprStructFields &expr)\n+{}\n+\n+void\n+AttributeChecker::visit (AST::StructExprStructBase &expr)\n+{}\n+\n+void\n+AttributeChecker::visit (AST::CallExpr &expr)\n+{}\n+\n+void\n+AttributeChecker::visit (AST::MethodCallExpr &expr)\n+{}\n+\n+void\n+AttributeChecker::visit (AST::FieldAccessExpr &expr)\n+{}\n+\n+void\n+AttributeChecker::visit (AST::ClosureExprInner &expr)\n+{}\n+\n+void\n+AttributeChecker::visit (AST::BlockExpr &expr)\n+{}\n+\n+void\n+AttributeChecker::visit (AST::ClosureExprInnerTyped &expr)\n+{}\n+\n+void\n+AttributeChecker::visit (AST::ContinueExpr &expr)\n+{}\n+\n+void\n+AttributeChecker::visit (AST::BreakExpr &expr)\n+{}\n+\n+void\n+AttributeChecker::visit (AST::RangeFromToExpr &expr)\n+{}\n+\n+void\n+AttributeChecker::visit (AST::RangeFromExpr &expr)\n+{}\n+\n+void\n+AttributeChecker::visit (AST::RangeToExpr &expr)\n+{}\n+\n+void\n+AttributeChecker::visit (AST::RangeFullExpr &expr)\n+{}\n+\n+void\n+AttributeChecker::visit (AST::RangeFromToInclExpr &expr)\n+{}\n+\n+void\n+AttributeChecker::visit (AST::RangeToInclExpr &expr)\n+{}\n+\n+void\n+AttributeChecker::visit (AST::ReturnExpr &expr)\n+{}\n+\n+void\n+AttributeChecker::visit (AST::UnsafeBlockExpr &expr)\n+{}\n+\n+void\n+AttributeChecker::visit (AST::LoopExpr &expr)\n+{}\n+\n+void\n+AttributeChecker::visit (AST::WhileLoopExpr &expr)\n+{}\n+\n+void\n+AttributeChecker::visit (AST::WhileLetLoopExpr &expr)\n+{}\n+\n+void\n+AttributeChecker::visit (AST::ForLoopExpr &expr)\n+{}\n+\n+void\n+AttributeChecker::visit (AST::IfExpr &expr)\n+{}\n+\n+void\n+AttributeChecker::visit (AST::IfExprConseqElse &expr)\n+{}\n+\n+void\n+AttributeChecker::visit (AST::IfExprConseqIf &expr)\n+{}\n+\n+void\n+AttributeChecker::visit (AST::IfExprConseqIfLet &expr)\n+{}\n+\n+void\n+AttributeChecker::visit (AST::IfLetExpr &expr)\n+{}\n+\n+void\n+AttributeChecker::visit (AST::IfLetExprConseqElse &expr)\n+{}\n+\n+void\n+AttributeChecker::visit (AST::IfLetExprConseqIf &expr)\n+{}\n+\n+void\n+AttributeChecker::visit (AST::IfLetExprConseqIfLet &expr)\n+{}\n+\n+void\n+AttributeChecker::visit (AST::MatchExpr &expr)\n+{}\n+\n+void\n+AttributeChecker::visit (AST::AwaitExpr &expr)\n+{}\n+\n+void\n+AttributeChecker::visit (AST::AsyncBlockExpr &expr)\n+{}\n+\n+// rust-item.h\n+void\n+AttributeChecker::visit (AST::TypeParam &param)\n+{}\n+\n+void\n+AttributeChecker::visit (AST::LifetimeWhereClauseItem &item)\n+{}\n+\n+void\n+AttributeChecker::visit (AST::TypeBoundWhereClauseItem &item)\n+{}\n+\n+void\n+AttributeChecker::visit (AST::Method &method)\n+{}\n+\n+void\n+AttributeChecker::visit (AST::Module &module)\n+{}\n+\n+void\n+AttributeChecker::visit (AST::ExternCrate &crate)\n+{}\n+\n+void\n+AttributeChecker::visit (AST::UseTreeGlob &use_tree)\n+{}\n+\n+void\n+AttributeChecker::visit (AST::UseTreeList &use_tree)\n+{}\n+\n+void\n+AttributeChecker::visit (AST::UseTreeRebind &use_tree)\n+{}\n+\n+void\n+AttributeChecker::visit (AST::UseDeclaration &use_decl)\n+{}\n+\n+void\n+AttributeChecker::visit (AST::Function &function)\n+{}\n+\n+void\n+AttributeChecker::visit (AST::TypeAlias &type_alias)\n+{}\n+\n+void\n+AttributeChecker::visit (AST::StructStruct &struct_item)\n+{\n+  check_attributes (struct_item.get_outer_attrs ());\n+}\n+\n+void\n+AttributeChecker::visit (AST::TupleStruct &tuple_struct)\n+{}\n+\n+void\n+AttributeChecker::visit (AST::EnumItem &item)\n+{}\n+\n+void\n+AttributeChecker::visit (AST::EnumItemTuple &item)\n+{}\n+\n+void\n+AttributeChecker::visit (AST::EnumItemStruct &item)\n+{}\n+\n+void\n+AttributeChecker::visit (AST::EnumItemDiscriminant &item)\n+{}\n+\n+void\n+AttributeChecker::visit (AST::Enum &enum_item)\n+{}\n+\n+void\n+AttributeChecker::visit (AST::Union &union_item)\n+{}\n+\n+void\n+AttributeChecker::visit (AST::ConstantItem &const_item)\n+{}\n+\n+void\n+AttributeChecker::visit (AST::StaticItem &static_item)\n+{}\n+\n+void\n+AttributeChecker::visit (AST::TraitItemFunc &item)\n+{}\n+\n+void\n+AttributeChecker::visit (AST::TraitItemMethod &item)\n+{}\n+\n+void\n+AttributeChecker::visit (AST::TraitItemConst &item)\n+{}\n+\n+void\n+AttributeChecker::visit (AST::TraitItemType &item)\n+{}\n+\n+void\n+AttributeChecker::visit (AST::Trait &trait)\n+{}\n+\n+void\n+AttributeChecker::visit (AST::InherentImpl &impl)\n+{}\n+\n+void\n+AttributeChecker::visit (AST::TraitImpl &impl)\n+{}\n+\n+void\n+AttributeChecker::visit (AST::ExternalStaticItem &item)\n+{}\n+\n+void\n+AttributeChecker::visit (AST::ExternalFunctionItem &item)\n+{}\n+\n+void\n+AttributeChecker::visit (AST::ExternBlock &block)\n+{}\n+\n+// rust-macro.h\n+void\n+AttributeChecker::visit (AST::MacroMatchFragment &match)\n+{}\n+\n+void\n+AttributeChecker::visit (AST::MacroMatchRepetition &match)\n+{}\n+\n+void\n+AttributeChecker::visit (AST::MacroMatcher &matcher)\n+{}\n+\n+void\n+AttributeChecker::visit (AST::MacroRulesDefinition &rules_def)\n+{}\n+\n+void\n+AttributeChecker::visit (AST::MacroInvocation &macro_invoc)\n+{}\n+\n+void\n+AttributeChecker::visit (AST::MetaItemPath &meta_item)\n+{}\n+\n+void\n+AttributeChecker::visit (AST::MetaItemSeq &meta_item)\n+{}\n+\n+void\n+AttributeChecker::visit (AST::MetaWord &meta_item)\n+{}\n+\n+void\n+AttributeChecker::visit (AST::MetaNameValueStr &meta_item)\n+{}\n+\n+void\n+AttributeChecker::visit (AST::MetaListPaths &meta_item)\n+{}\n+\n+void\n+AttributeChecker::visit (AST::MetaListNameValueStr &meta_item)\n+{}\n+\n+// rust-pattern.h\n+void\n+AttributeChecker::visit (AST::LiteralPattern &pattern)\n+{}\n+\n+void\n+AttributeChecker::visit (AST::IdentifierPattern &pattern)\n+{}\n+\n+void\n+AttributeChecker::visit (AST::WildcardPattern &pattern)\n+{}\n+\n+// void AttributeChecker::visit(RangePatternBound& bound){}\n+\n+void\n+AttributeChecker::visit (AST::RangePatternBoundLiteral &bound)\n+{}\n+\n+void\n+AttributeChecker::visit (AST::RangePatternBoundPath &bound)\n+{}\n+\n+void\n+AttributeChecker::visit (AST::RangePatternBoundQualPath &bound)\n+{}\n+\n+void\n+AttributeChecker::visit (AST::RangePattern &pattern)\n+{}\n+\n+void\n+AttributeChecker::visit (AST::ReferencePattern &pattern)\n+{}\n+\n+// void AttributeChecker::visit(StructPatternField& field){}\n+\n+void\n+AttributeChecker::visit (AST::StructPatternFieldTuplePat &field)\n+{}\n+\n+void\n+AttributeChecker::visit (AST::StructPatternFieldIdentPat &field)\n+{}\n+\n+void\n+AttributeChecker::visit (AST::StructPatternFieldIdent &field)\n+{}\n+\n+void\n+AttributeChecker::visit (AST::StructPattern &pattern)\n+{}\n+\n+// void AttributeChecker::visit(TupleStructItems& tuple_items){}\n+\n+void\n+AttributeChecker::visit (AST::TupleStructItemsNoRange &tuple_items)\n+{}\n+\n+void\n+AttributeChecker::visit (AST::TupleStructItemsRange &tuple_items)\n+{}\n+\n+void\n+AttributeChecker::visit (AST::TupleStructPattern &pattern)\n+{}\n+\n+// void AttributeChecker::visit(TuplePatternItems& tuple_items){}\n+\n+void\n+AttributeChecker::visit (AST::TuplePatternItemsMultiple &tuple_items)\n+{}\n+\n+void\n+AttributeChecker::visit (AST::TuplePatternItemsRanged &tuple_items)\n+{}\n+\n+void\n+AttributeChecker::visit (AST::TuplePattern &pattern)\n+{}\n+\n+void\n+AttributeChecker::visit (AST::GroupedPattern &pattern)\n+{}\n+\n+void\n+AttributeChecker::visit (AST::SlicePattern &pattern)\n+{}\n+\n+// rust-stmt.h\n+void\n+AttributeChecker::visit (AST::EmptyStmt &stmt)\n+{}\n+\n+void\n+AttributeChecker::visit (AST::LetStmt &stmt)\n+{}\n+\n+void\n+AttributeChecker::visit (AST::ExprStmtWithoutBlock &stmt)\n+{}\n+\n+void\n+AttributeChecker::visit (AST::ExprStmtWithBlock &stmt)\n+{}\n+\n+// rust-type.h\n+void\n+AttributeChecker::visit (AST::TraitBound &bound)\n+{}\n+\n+void\n+AttributeChecker::visit (AST::ImplTraitType &type)\n+{}\n+\n+void\n+AttributeChecker::visit (AST::TraitObjectType &type)\n+{}\n+\n+void\n+AttributeChecker::visit (AST::ParenthesisedType &type)\n+{}\n+\n+void\n+AttributeChecker::visit (AST::ImplTraitTypeOneBound &type)\n+{}\n+\n+void\n+AttributeChecker::visit (AST::TraitObjectTypeOneBound &type)\n+{}\n+\n+void\n+AttributeChecker::visit (AST::TupleType &type)\n+{}\n+\n+void\n+AttributeChecker::visit (AST::NeverType &type)\n+{}\n+\n+void\n+AttributeChecker::visit (AST::RawPointerType &type)\n+{}\n+\n+void\n+AttributeChecker::visit (AST::ReferenceType &type)\n+{}\n+\n+void\n+AttributeChecker::visit (AST::ArrayType &type)\n+{}\n+\n+void\n+AttributeChecker::visit (AST::SliceType &type)\n+{}\n+\n+void\n+AttributeChecker::visit (AST::InferredType &type)\n+{}\n+\n+void\n+AttributeChecker::visit (AST::BareFunctionType &type)\n+{}\n+\n+} // namespace Analysis\n+} // namespace Rust"}, {"sha": "3ac93ff59080d0dfe90de9aaefade6692e851fd3", "filename": "gcc/rust/util/rust-attributes.h", "status": "added", "additions": 270, "deletions": 0, "changes": 270, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2e7fc8780e0d5009bc8edd116378a25dea8cb1fa/gcc%2Frust%2Futil%2Frust-attributes.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2e7fc8780e0d5009bc8edd116378a25dea8cb1fa/gcc%2Frust%2Futil%2Frust-attributes.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Futil%2Frust-attributes.h?ref=2e7fc8780e0d5009bc8edd116378a25dea8cb1fa", "patch": "@@ -0,0 +1,270 @@\n+// Copyright (C) 2020-2022 Free Software Foundation, Inc.\n+\n+// This file is part of GCC.\n+\n+// GCC is free software; you can redistribute it and/or modify it under\n+// the terms of the GNU General Public License as published by the Free\n+// Software Foundation; either version 3, or (at your option) any later\n+// version.\n+\n+// GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+// WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+// for more details.\n+\n+// You should have received a copy of the GNU General Public License\n+// along with GCC; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#include \"rust-ast.h\"\n+#include \"rust-system.h\"\n+#include \"rust-ast-visitor.h\"\n+\n+namespace Rust {\n+namespace Analysis {\n+\n+enum CompilerPass\n+{\n+  UNKNOWN,\n+\n+  EXPANSION,\n+  NAME_RESOLUTION,\n+  HIR_LOWERING,\n+  TYPE_CHECK,\n+  STATIC_ANALYSIS,\n+  CODE_GENERATION\n+};\n+\n+struct BuiltinAttrDefinition\n+{\n+  std::string name;\n+  CompilerPass handler;\n+\n+  static BuiltinAttrDefinition get_error ()\n+  {\n+    return BuiltinAttrDefinition{\"\", UNKNOWN};\n+  }\n+\n+  static BuiltinAttrDefinition &error_node ()\n+  {\n+    static BuiltinAttrDefinition error_node = get_error ();\n+    return error_node;\n+  }\n+\n+  bool is_error () const { return name.empty (); }\n+};\n+\n+class BuiltinAttributeMappings\n+{\n+public:\n+  static BuiltinAttributeMappings *get ();\n+\n+  const BuiltinAttrDefinition &\n+  lookup_builtin (const std::string &attr_name) const;\n+\n+private:\n+  BuiltinAttributeMappings ();\n+\n+  std::map<std::string, const BuiltinAttrDefinition> mappings;\n+};\n+\n+/**\n+ * Checks the validity of various attributes. The goal of this visitor is to\n+ * make sure that attributes are applied in allowed contexts, for example to\n+ * make sure that #[inline] is only applied to functions and closures, as well\n+ * as checking the \"arguments\" or input given to these attributes, making sure\n+ * it is appropriate and valid.\n+ */\n+class AttributeChecker : public AST::ASTVisitor\n+{\n+public:\n+  AttributeChecker ();\n+\n+  /**\n+   * Check all the attributes of all the items of a crate\n+   */\n+  void go (AST::Crate &crate);\n+\n+private:\n+  /* Check the validity of a given attribute */\n+  void check_attribute (const AST::Attribute &attribute);\n+\n+  /* Check the validity of all given attributes */\n+  void check_attributes (const AST::AttrVec &attributes);\n+\n+  // rust-ast.h\n+  void visit (AST::Token &tok);\n+  void visit (AST::DelimTokenTree &delim_tok_tree);\n+  void visit (AST::AttrInputMetaItemContainer &input);\n+  void visit (AST::IdentifierExpr &ident_expr);\n+  void visit (AST::Lifetime &lifetime);\n+  void visit (AST::LifetimeParam &lifetime_param);\n+  void visit (AST::ConstGenericParam &const_param);\n+\n+  // rust-path.h\n+  void visit (AST::PathInExpression &path);\n+  void visit (AST::TypePathSegment &segment);\n+  void visit (AST::TypePathSegmentGeneric &segment);\n+  void visit (AST::TypePathSegmentFunction &segment);\n+  void visit (AST::TypePath &path);\n+  void visit (AST::QualifiedPathInExpression &path);\n+  void visit (AST::QualifiedPathInType &path);\n+\n+  // rust-expr.h\n+  void visit (AST::LiteralExpr &expr);\n+  void visit (AST::AttrInputLiteral &attr_input);\n+  void visit (AST::MetaItemLitExpr &meta_item);\n+  void visit (AST::MetaItemPathLit &meta_item);\n+  void visit (AST::BorrowExpr &expr);\n+  void visit (AST::DereferenceExpr &expr);\n+  void visit (AST::ErrorPropagationExpr &expr);\n+  void visit (AST::NegationExpr &expr);\n+  void visit (AST::ArithmeticOrLogicalExpr &expr);\n+  void visit (AST::ComparisonExpr &expr);\n+  void visit (AST::LazyBooleanExpr &expr);\n+  void visit (AST::TypeCastExpr &expr);\n+  void visit (AST::AssignmentExpr &expr);\n+  void visit (AST::CompoundAssignmentExpr &expr);\n+  void visit (AST::GroupedExpr &expr);\n+  void visit (AST::ArrayElemsValues &elems);\n+  void visit (AST::ArrayElemsCopied &elems);\n+  void visit (AST::ArrayExpr &expr);\n+  void visit (AST::ArrayIndexExpr &expr);\n+  void visit (AST::TupleExpr &expr);\n+  void visit (AST::TupleIndexExpr &expr);\n+  void visit (AST::StructExprStruct &expr);\n+  void visit (AST::StructExprFieldIdentifier &field);\n+  void visit (AST::StructExprFieldIdentifierValue &field);\n+  void visit (AST::StructExprFieldIndexValue &field);\n+  void visit (AST::StructExprStructFields &expr);\n+  void visit (AST::StructExprStructBase &expr);\n+  void visit (AST::CallExpr &expr);\n+  void visit (AST::MethodCallExpr &expr);\n+  void visit (AST::FieldAccessExpr &expr);\n+  void visit (AST::ClosureExprInner &expr);\n+  void visit (AST::BlockExpr &expr);\n+  void visit (AST::ClosureExprInnerTyped &expr);\n+  void visit (AST::ContinueExpr &expr);\n+  void visit (AST::BreakExpr &expr);\n+  void visit (AST::RangeFromToExpr &expr);\n+  void visit (AST::RangeFromExpr &expr);\n+  void visit (AST::RangeToExpr &expr);\n+  void visit (AST::RangeFullExpr &expr);\n+  void visit (AST::RangeFromToInclExpr &expr);\n+  void visit (AST::RangeToInclExpr &expr);\n+  void visit (AST::ReturnExpr &expr);\n+  void visit (AST::UnsafeBlockExpr &expr);\n+  void visit (AST::LoopExpr &expr);\n+  void visit (AST::WhileLoopExpr &expr);\n+  void visit (AST::WhileLetLoopExpr &expr);\n+  void visit (AST::ForLoopExpr &expr);\n+  void visit (AST::IfExpr &expr);\n+  void visit (AST::IfExprConseqElse &expr);\n+  void visit (AST::IfExprConseqIf &expr);\n+  void visit (AST::IfExprConseqIfLet &expr);\n+  void visit (AST::IfLetExpr &expr);\n+  void visit (AST::IfLetExprConseqElse &expr);\n+  void visit (AST::IfLetExprConseqIf &expr);\n+  void visit (AST::IfLetExprConseqIfLet &expr);\n+  void visit (AST::MatchExpr &expr);\n+  void visit (AST::AwaitExpr &expr);\n+  void visit (AST::AsyncBlockExpr &expr);\n+\n+  // rust-item.h\n+  void visit (AST::TypeParam &param);\n+  void visit (AST::LifetimeWhereClauseItem &item);\n+  void visit (AST::TypeBoundWhereClauseItem &item);\n+  void visit (AST::Method &method);\n+  void visit (AST::Module &module);\n+  void visit (AST::ExternCrate &crate);\n+  void visit (AST::UseTreeGlob &use_tree);\n+  void visit (AST::UseTreeList &use_tree);\n+  void visit (AST::UseTreeRebind &use_tree);\n+  void visit (AST::UseDeclaration &use_decl);\n+  void visit (AST::Function &function);\n+  void visit (AST::TypeAlias &type_alias);\n+  void visit (AST::StructStruct &struct_item);\n+  void visit (AST::TupleStruct &tuple_struct);\n+  void visit (AST::EnumItem &item);\n+  void visit (AST::EnumItemTuple &item);\n+  void visit (AST::EnumItemStruct &item);\n+  void visit (AST::EnumItemDiscriminant &item);\n+  void visit (AST::Enum &enum_item);\n+  void visit (AST::Union &union_item);\n+  void visit (AST::ConstantItem &const_item);\n+  void visit (AST::StaticItem &static_item);\n+  void visit (AST::TraitItemFunc &item);\n+  void visit (AST::TraitItemMethod &item);\n+  void visit (AST::TraitItemConst &item);\n+  void visit (AST::TraitItemType &item);\n+  void visit (AST::Trait &trait);\n+  void visit (AST::InherentImpl &impl);\n+  void visit (AST::TraitImpl &impl);\n+  void visit (AST::ExternalStaticItem &item);\n+  void visit (AST::ExternalFunctionItem &item);\n+  void visit (AST::ExternBlock &block);\n+\n+  // rust-macro.h\n+  void visit (AST::MacroMatchFragment &match);\n+  void visit (AST::MacroMatchRepetition &match);\n+  void visit (AST::MacroMatcher &matcher);\n+  void visit (AST::MacroRulesDefinition &rules_def);\n+  void visit (AST::MacroInvocation &macro_invoc);\n+  void visit (AST::MetaItemPath &meta_item);\n+  void visit (AST::MetaItemSeq &meta_item);\n+  void visit (AST::MetaWord &meta_item);\n+  void visit (AST::MetaNameValueStr &meta_item);\n+  void visit (AST::MetaListPaths &meta_item);\n+  void visit (AST::MetaListNameValueStr &meta_item);\n+\n+  // rust-pattern.h\n+  void visit (AST::LiteralPattern &pattern);\n+  void visit (AST::IdentifierPattern &pattern);\n+  void visit (AST::WildcardPattern &pattern);\n+  // void visit(RangePatternBound& bound);\n+  void visit (AST::RangePatternBoundLiteral &bound);\n+  void visit (AST::RangePatternBoundPath &bound);\n+  void visit (AST::RangePatternBoundQualPath &bound);\n+  void visit (AST::RangePattern &pattern);\n+  void visit (AST::ReferencePattern &pattern);\n+  // void visit(StructPatternField& field);\n+  void visit (AST::StructPatternFieldTuplePat &field);\n+  void visit (AST::StructPatternFieldIdentPat &field);\n+  void visit (AST::StructPatternFieldIdent &field);\n+  void visit (AST::StructPattern &pattern);\n+  // void visit(TupleStructItems& tuple_items);\n+  void visit (AST::TupleStructItemsNoRange &tuple_items);\n+  void visit (AST::TupleStructItemsRange &tuple_items);\n+  void visit (AST::TupleStructPattern &pattern);\n+  // void visit(TuplePatternItems& tuple_items);\n+  void visit (AST::TuplePatternItemsMultiple &tuple_items);\n+  void visit (AST::TuplePatternItemsRanged &tuple_items);\n+  void visit (AST::TuplePattern &pattern);\n+  void visit (AST::GroupedPattern &pattern);\n+  void visit (AST::SlicePattern &pattern);\n+\n+  // rust-stmt.h\n+  void visit (AST::EmptyStmt &stmt);\n+  void visit (AST::LetStmt &stmt);\n+  void visit (AST::ExprStmtWithoutBlock &stmt);\n+  void visit (AST::ExprStmtWithBlock &stmt);\n+\n+  // rust-type.h\n+  void visit (AST::TraitBound &bound);\n+  void visit (AST::ImplTraitType &type);\n+  void visit (AST::TraitObjectType &type);\n+  void visit (AST::ParenthesisedType &type);\n+  void visit (AST::ImplTraitTypeOneBound &type);\n+  void visit (AST::TraitObjectTypeOneBound &type);\n+  void visit (AST::TupleType &type);\n+  void visit (AST::NeverType &type);\n+  void visit (AST::RawPointerType &type);\n+  void visit (AST::ReferenceType &type);\n+  void visit (AST::ArrayType &type);\n+  void visit (AST::SliceType &type);\n+  void visit (AST::InferredType &type);\n+  void visit (AST::BareFunctionType &type);\n+};\n+\n+} // namespace Analysis\n+} // namespace Rust"}]}