{"sha": "6e063ac3887d7e3b2992fa5fa12a57e743be6c1d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NmUwNjNhYzM4ODdkN2UzYjI5OTJmYTVmYTEyYTU3ZTc0M2JlNmMxZA==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@adacore.com", "date": "2020-02-09T19:53:05Z"}, "committer": {"name": "Pierre-Marie de Rodat", "email": "derodat@adacore.com", "date": "2020-06-08T07:50:56Z"}, "message": "[Ada] AI12-0226 Make objects more consistent\n\n2020-06-08  Arnaud Charlet  <charlet@adacore.com>\n\ngcc/ada/\n\n\t* sem_ch8.adb (Analyze_Object_Renaming): Simplify code by moving\n\tmany special cases to Is_Object_Reference and removing others by\n\tonly checking renamings coming from sources.\n\t* sem_util.adb (Is_Object_Reference): Update for AI12-0226 and\n\tadd more regular handling of 'Priority. Remove special cases no\n\tlonger needed now that we are only checking renamings coming\n\tfrom sources.", "tree": {"sha": "b9b558c4b32e86f48ac60f781e243bed1c6019ec", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b9b558c4b32e86f48ac60f781e243bed1c6019ec"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6e063ac3887d7e3b2992fa5fa12a57e743be6c1d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6e063ac3887d7e3b2992fa5fa12a57e743be6c1d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6e063ac3887d7e3b2992fa5fa12a57e743be6c1d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6e063ac3887d7e3b2992fa5fa12a57e743be6c1d/comments", "author": {"login": "ArnaudCharlet", "id": 30291825, "node_id": "MDQ6VXNlcjMwMjkxODI1", "avatar_url": "https://avatars.githubusercontent.com/u/30291825?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ArnaudCharlet", "html_url": "https://github.com/ArnaudCharlet", "followers_url": "https://api.github.com/users/ArnaudCharlet/followers", "following_url": "https://api.github.com/users/ArnaudCharlet/following{/other_user}", "gists_url": "https://api.github.com/users/ArnaudCharlet/gists{/gist_id}", "starred_url": "https://api.github.com/users/ArnaudCharlet/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ArnaudCharlet/subscriptions", "organizations_url": "https://api.github.com/users/ArnaudCharlet/orgs", "repos_url": "https://api.github.com/users/ArnaudCharlet/repos", "events_url": "https://api.github.com/users/ArnaudCharlet/events{/privacy}", "received_events_url": "https://api.github.com/users/ArnaudCharlet/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pmderodat", "id": 758452, "node_id": "MDQ6VXNlcjc1ODQ1Mg==", "avatar_url": "https://avatars.githubusercontent.com/u/758452?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pmderodat", "html_url": "https://github.com/pmderodat", "followers_url": "https://api.github.com/users/pmderodat/followers", "following_url": "https://api.github.com/users/pmderodat/following{/other_user}", "gists_url": "https://api.github.com/users/pmderodat/gists{/gist_id}", "starred_url": "https://api.github.com/users/pmderodat/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pmderodat/subscriptions", "organizations_url": "https://api.github.com/users/pmderodat/orgs", "repos_url": "https://api.github.com/users/pmderodat/repos", "events_url": "https://api.github.com/users/pmderodat/events{/privacy}", "received_events_url": "https://api.github.com/users/pmderodat/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ae9293fb8e1895006ce33069eaabdecfe65c46a2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ae9293fb8e1895006ce33069eaabdecfe65c46a2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ae9293fb8e1895006ce33069eaabdecfe65c46a2"}], "stats": {"total": 163, "additions": 53, "deletions": 110}, "files": [{"sha": "fcdc0f36ec02d2ed7a1c85b26321320f8f196b60", "filename": "gcc/ada/sem_ch8.adb", "status": "modified", "additions": 37, "deletions": 70, "changes": 107, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6e063ac3887d7e3b2992fa5fa12a57e743be6c1d/gcc%2Fada%2Fsem_ch8.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6e063ac3887d7e3b2992fa5fa12a57e743be6c1d/gcc%2Fada%2Fsem_ch8.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch8.adb?ref=6e063ac3887d7e3b2992fa5fa12a57e743be6c1d", "patch": "@@ -759,12 +759,13 @@ package body Sem_Ch8 is\n    -----------------------------\n \n    procedure Analyze_Object_Renaming (N : Node_Id) is\n-      Id  : constant Entity_Id  := Defining_Identifier (N);\n-      Loc : constant Source_Ptr := Sloc (N);\n-      Nam : constant Node_Id    := Name (N);\n-      Dec : Node_Id;\n-      T   : Entity_Id;\n-      T2  : Entity_Id;\n+      Id            : constant Entity_Id  := Defining_Identifier (N);\n+      Loc           : constant Source_Ptr := Sloc (N);\n+      Nam           : constant Node_Id    := Name (N);\n+      Is_Object_Ref : Boolean := False;\n+      Dec           : Node_Id;\n+      T             : Entity_Id;\n+      T2            : Entity_Id;\n \n       procedure Check_Constrained_Object;\n       --  If the nominal type is unconstrained but the renamed object is\n@@ -1016,18 +1017,6 @@ package body Sem_Ch8 is\n             Mark_Ghost_Renaming (N, Entity (Nam));\n          end if;\n \n-         --  Reject renamings of conversions unless the type is tagged, or\n-         --  the conversion is implicit (which can occur for cases of anonymous\n-         --  access types in Ada 2012).\n-\n-         if Nkind (Nam) = N_Type_Conversion\n-           and then Comes_From_Source (Nam)\n-           and then not Is_Tagged_Type (T)\n-         then\n-            Error_Msg_N\n-              (\"renaming of conversion only allowed for tagged types\", Nam);\n-         end if;\n-\n          Resolve (Nam, T);\n \n          --  If the renamed object is a function call of a limited type,\n@@ -1268,15 +1257,7 @@ package body Sem_Ch8 is\n          return;\n       end if;\n \n-      --  Ada 2005 (AI-327)\n-\n-      if Ada_Version >= Ada_2005\n-        and then Nkind (Nam) = N_Attribute_Reference\n-        and then Attribute_Name (Nam) = Name_Priority\n-      then\n-         null;\n-\n-      elsif Ada_Version >= Ada_2005 and then Nkind (Nam) in N_Has_Entity then\n+      if Ada_Version >= Ada_2005 and then Nkind (Nam) in N_Has_Entity then\n          declare\n             Nam_Ent  : constant Entity_Id := Entity (Get_Object_Name (Nam));\n             Nam_Decl : constant Node_Id   := Declaration_Node (Nam_Ent);\n@@ -1375,13 +1356,33 @@ package body Sem_Ch8 is\n \n       Init_Object_Size_Align (Id);\n \n+      --  If N comes from source then check that the original node is an\n+      --  object reference since there may have been several rewritting and\n+      --  folding. Do not do this for N_Function_Call or N_Explicit_Dereference\n+      --  which might correspond to rewrites of e.g. N_Selected_Component\n+      --  (for example Object.Method rewriting).\n+      --  If N does not come from source then assume the tree is properly\n+      --  formed and accept any object reference. In such cases we do support\n+      --  more cases of renamings anyway, so the actual check on which renaming\n+      --  is valid is better left to the code generator as a last sanity\n+      --  check.\n+\n+      if Comes_From_Source (N) then\n+         if Nkind_In (Nam, N_Function_Call, N_Explicit_Dereference) then\n+            Is_Object_Ref := Is_Object_Reference (Nam);\n+         else\n+            Is_Object_Ref := Is_Object_Reference (Original_Node (Nam));\n+         end if;\n+      else\n+         Is_Object_Ref := True;\n+      end if;\n+\n       if T = Any_Type or else Etype (Nam) = Any_Type then\n          return;\n \n-      --  Verify that the renamed entity is an object or a function call. It\n-      --  may have been rewritten in several ways.\n+      --  Verify that the renamed entity is an object or function call.\n \n-      elsif Is_Object_Reference (Nam) then\n+      elsif Is_Object_Ref then\n          if Comes_From_Source (N) then\n             if Is_Dependent_Component_Of_Mutable_Object (Nam) then\n                Error_Msg_N\n@@ -1400,49 +1401,15 @@ package body Sem_Ch8 is\n             end if;\n          end if;\n \n-      --  A static function call may have been folded into a literal\n+      --  Weird but legal, equivalent to renaming a function call. Illegal\n+      --  if the literal is the result of constant-folding an attribute\n+      --  reference that is not a function.\n \n-      elsif Nkind (Original_Node (Nam)) = N_Function_Call\n-\n-        --  When expansion is disabled, attribute reference is not rewritten\n-        --  as function call. Otherwise it may be rewritten as a conversion,\n-        --  so check original node.\n-\n-        or else (Nkind (Original_Node (Nam)) = N_Attribute_Reference\n-                  and then Is_Function_Attribute_Name\n-                             (Attribute_Name (Original_Node (Nam))))\n-\n-        --  Weird but legal, equivalent to renaming a function call. Illegal\n-        --  if the literal is the result of constant-folding an attribute\n-        --  reference that is not a function.\n-\n-        or else (Is_Entity_Name (Nam)\n-                  and then Ekind (Entity (Nam)) = E_Enumeration_Literal\n-                  and then\n-                    Nkind (Original_Node (Nam)) /= N_Attribute_Reference)\n-\n-        or else (Nkind (Nam) = N_Type_Conversion\n-                  and then Is_Tagged_Type (Entity (Subtype_Mark (Nam))))\n-      then\n-         null;\n-\n-      elsif Nkind (Nam) = N_Type_Conversion then\n-         Error_Msg_N\n-           (\"renaming of conversion only allowed for tagged types\", Nam);\n-\n-      --  Ada 2005 (AI-327)\n-\n-      elsif Ada_Version >= Ada_2005\n-        and then Nkind (Nam) = N_Attribute_Reference\n-        and then Attribute_Name (Nam) = Name_Priority\n+      elsif Is_Entity_Name (Nam)\n+        and then Ekind (Entity (Nam)) = E_Enumeration_Literal\n+        and then Nkind (Original_Node (Nam)) /= N_Attribute_Reference\n       then\n          null;\n-\n-      --  Allow internally generated x'Ref resulting in N_Reference node\n-\n-      elsif Nkind (Nam) = N_Reference then\n-         null;\n-\n       else\n          Error_Msg_N (\"expect object name in renaming\", Nam);\n       end if;"}, {"sha": "b32d4fd6d145a41d4702bea5d57c28cb0206c5fc", "filename": "gcc/ada/sem_util.adb", "status": "modified", "additions": 16, "deletions": 40, "changes": 56, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6e063ac3887d7e3b2992fa5fa12a57e743be6c1d/gcc%2Fada%2Fsem_util.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6e063ac3887d7e3b2992fa5fa12a57e743be6c1d/gcc%2Fada%2Fsem_util.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_util.adb?ref=6e063ac3887d7e3b2992fa5fa12a57e743be6c1d", "patch": "@@ -16420,33 +16420,6 @@ package body Sem_Util is\n    -------------------------\n \n    function Is_Object_Reference (N : Node_Id) return Boolean is\n-      function Is_Internally_Generated_Renaming (N : Node_Id) return Boolean;\n-      --  Determine whether N is the name of an internally-generated renaming\n-\n-      --------------------------------------\n-      -- Is_Internally_Generated_Renaming --\n-      --------------------------------------\n-\n-      function Is_Internally_Generated_Renaming (N : Node_Id) return Boolean is\n-         P : Node_Id;\n-\n-      begin\n-         P := N;\n-         while Present (P) loop\n-            if Nkind (P) = N_Object_Renaming_Declaration then\n-               return not Comes_From_Source (P);\n-            elsif Is_List_Member (P) then\n-               return False;\n-            end if;\n-\n-            P := Parent (P);\n-         end loop;\n-\n-         return False;\n-      end Is_Internally_Generated_Renaming;\n-\n-   --  Start of processing for Is_Object_Reference\n-\n    begin\n       if Is_Entity_Name (N) then\n          return Present (Entity (N)) and then Is_Object (Entity (N));\n@@ -16472,13 +16445,14 @@ package body Sem_Util is\n             =>\n                return Etype (N) /= Standard_Void_Type;\n \n-            --  Attributes references 'Loop_Entry, 'Old, and 'Result yield\n-            --  objects, even though they are not functions.\n+            --  Attributes references 'Loop_Entry, 'Old, 'Priority and 'Result\n+            --  yield objects, even though they are not functions.\n \n             when N_Attribute_Reference =>\n                return\n                  Nam_In (Attribute_Name (N), Name_Loop_Entry,\n                                              Name_Old,\n+                                             Name_Priority,\n                                              Name_Result)\n                    or else Is_Function_Attribute_Name (Attribute_Name (N));\n \n@@ -16501,9 +16475,19 @@ package body Sem_Util is\n             --  A view conversion of a tagged object is an object reference\n \n             when N_Type_Conversion =>\n-               return Is_Tagged_Type (Etype (Subtype_Mark (N)))\n-                 and then Is_Tagged_Type (Etype (Expression (N)))\n-                 and then Is_Object_Reference (Expression (N));\n+               if Ada_Version <= Ada_2012 then\n+                  --  A view conversion of a tagged object is an object\n+                  --  reference.\n+                  return Is_Tagged_Type (Etype (Subtype_Mark (N)))\n+                    and then Is_Tagged_Type (Etype (Expression (N)))\n+                    and then Is_Object_Reference (Expression (N));\n+\n+               else\n+                  --  AI12-0226: In Ada 202x a value conversion of an object is\n+                  --  an object.\n+\n+                  return Is_Object_Reference (Expression (N));\n+               end if;\n \n             --  An unchecked type conversion is considered to be an object if\n             --  the operand is an object (this construction arises only as a\n@@ -16512,14 +16496,6 @@ package body Sem_Util is\n             when N_Unchecked_Type_Conversion =>\n                return True;\n \n-            --  Allow string literals to act as objects as long as they appear\n-            --  in internally-generated renamings. The expansion of iterators\n-            --  may generate such renamings when the range involves a string\n-            --  literal.\n-\n-            when N_String_Literal =>\n-               return Is_Internally_Generated_Renaming (Parent (N));\n-\n             --  AI05-0003: In Ada 2012 a qualified expression is a name.\n             --  This allows disambiguation of function calls and the use\n             --  of aggregates in more contexts."}]}