{"sha": "df92c6403cb342aac3fe8720895d979b6d677321", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZGY5MmM2NDAzY2IzNDJhYWMzZmU4NzIwODk1ZDk3OWI2ZDY3NzMyMQ==", "commit": {"author": {"name": "Steven Bosscher", "email": "steven@gcc.gnu.org", "date": "2012-09-13T13:41:46Z"}, "committer": {"name": "Steven Bosscher", "email": "steven@gcc.gnu.org", "date": "2012-09-13T13:41:46Z"}, "message": "ipa-pure-const.c (state_from_flags, [...]): Use current_function_name instead of lang_hooks.decl_printable_name.\n\n\t* ipa-pure-const.c (state_from_flags, local_pure_const): Use\n\tcurrent_function_name instead of lang_hooks.decl_printable_name.\n\n\t* function.h (fndecl_name): New prototype.\n\t* function.c (fndecl_name): New function.\n\t* vecir.h (cgraph_node_p): New standard IR VEC type.\n\t* trans-mem.c (cgraph_node_p): No need anymore to define it here.\n\t* ipa-utils.h (ipa_get_nodes_in_cycle): New prototype.\n\t* ipa-utils.c (ipa_get_nodes_in_cycle): New function.\n\t* ipa-reference.c: Don't include langhooks.h, and certainly not twice.\n\tFix many formatting issues (long lines, short lines, spacing, etc.).\n\t(get_static_name): Use fndecl_name.\n\t(dump_static_vars_set_to_file): New function split out from propagate.\n\t(union_static_var_sets): New function, union two sets and collapse\n\tto all_module_statics as quickly as possible.\n\t(intersect_static_var_sets): New function, similar to above.\n\t(copy_static_var_set): Renamed from copy_global_bitmap and rewritten\n\tto allocate a copy on the same bitmap_obstack as the source set.\n\t(propagate_bits): Simplify, and clarify by using union_static_var_sets.\n\t(generate_summary): Remove bm_temp.  Print UID of promotable globals.\n\t(read_write_all_from_decl): Use pass-by-reference, bless C++.\n\t(get_read_write_all_from_node): New function, split out from propagate.\n\t(propagate): Simplify and clarify with helper functions.  Use\n\tipa_get_nodes_in_cycle to walk all nodes in a reduced node.\n\t(ipa_reference_read_optimization_summary): Use fndecl_name instead of\n\tlang_hooks.decl_printable_name.\n\n\t* rtl.h (print_rtl_single_with_indent): New prototype.\n\t* print-rtl.c (print_rtl_single_with_indent): New function.\n\t* cfghooks.h (empty_block_p, split_block_before_cond_jump): New hooks.\n\t* cfghooks.c (empty_block_p, split_block_before_cond_jump): Implement.\n\t* cfgrtl.c (rtl_block_empty_p, rtl_split_block_before_cond_jump):\n\tImplement RTL specific hooks.\n\t(rtl_cfg_hooks, cfg_layout_rtl_cfg_hooks): Register the new hooks.\n\t* tree-cfg.c (gimple_empty_block_p,\n\tgimple_split_block_before_cond_jump): Implement GIMPLE specific hooks.\n\t(gimple_cfg_hooks): Register the new hooks.\n\t* tree-ssa-phiopt.c (empty_block_p): Remove in favor of new hook.\n\nFrom-SVN: r191255", "tree": {"sha": "ccf42e9cc160d21ec43421b4abfe25c8a1812cda", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ccf42e9cc160d21ec43421b4abfe25c8a1812cda"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/df92c6403cb342aac3fe8720895d979b6d677321", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/df92c6403cb342aac3fe8720895d979b6d677321", "html_url": "https://github.com/Rust-GCC/gccrs/commit/df92c6403cb342aac3fe8720895d979b6d677321", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/df92c6403cb342aac3fe8720895d979b6d677321/comments", "author": null, "committer": null, "parents": [{"sha": "17742d62a2438144b6235b8f29141ec931c3bf96", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/17742d62a2438144b6235b8f29141ec931c3bf96", "html_url": "https://github.com/Rust-GCC/gccrs/commit/17742d62a2438144b6235b8f29141ec931c3bf96"}], "stats": {"total": 820, "additions": 476, "deletions": 344}, "files": [{"sha": "b3ae7ec1348d82578403bf9090628442db7cc32f", "filename": "gcc/ChangeLog", "status": "modified", "additions": 47, "deletions": 6, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df92c6403cb342aac3fe8720895d979b6d677321/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df92c6403cb342aac3fe8720895d979b6d677321/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=df92c6403cb342aac3fe8720895d979b6d677321", "patch": "@@ -1,3 +1,44 @@\n+2012-09-13  Steven Bosscher  <steven@gcc.gnu.org>\n+\n+\t* ipa-pure-const.c (state_from_flags, local_pure_const): Use\n+\tcurrent_function_name instead of lang_hooks.decl_printable_name.\n+\n+\t* function.h (fndecl_name): New prototype.\n+\t* function.c (fndecl_name): New function.\n+\t* vecir.h (cgraph_node_p): New standard IR VEC type.\n+\t* trans-mem.c (cgraph_node_p): No need anymore to define it here.\n+\t* ipa-utils.h (ipa_get_nodes_in_cycle): New prototype.\n+\t* ipa-utils.c (ipa_get_nodes_in_cycle): New function.\n+\t* ipa-reference.c: Don't include langhooks.h, and certainly not twice.\n+\tFix many formatting issues (long lines, short lines, spacing, etc.).\n+\t(get_static_name): Use fndecl_name.\n+\t(dump_static_vars_set_to_file): New function split out from propagate.\n+\t(union_static_var_sets): New function, union two sets and collapse\n+\tto all_module_statics as quickly as possible.\n+\t(intersect_static_var_sets): New function, similar to above.\n+\t(copy_static_var_set): Renamed from copy_global_bitmap and rewritten\n+\tto allocate a copy on the same bitmap_obstack as the source set.\n+\t(propagate_bits): Simplify, and clarify by using union_static_var_sets.\n+\t(generate_summary): Remove bm_temp.  Print UID of promotable globals.\n+\t(read_write_all_from_decl): Use pass-by-reference, bless C++.\n+\t(get_read_write_all_from_node): New function, split out from propagate.\n+\t(propagate): Simplify and clarify with helper functions.  Use\n+\tipa_get_nodes_in_cycle to walk all nodes in a reduced node.\n+\t(ipa_reference_read_optimization_summary): Use fndecl_name instead of\n+\tlang_hooks.decl_printable_name.\n+\n+\t* rtl.h (print_rtl_single_with_indent): New prototype.\n+\t* print-rtl.c (print_rtl_single_with_indent): New function.\n+\t* cfghooks.h (empty_block_p, split_block_before_cond_jump): New hooks.\n+\t* cfghooks.c (empty_block_p, split_block_before_cond_jump): Implement.\n+\t* cfgrtl.c (rtl_block_empty_p, rtl_split_block_before_cond_jump):\n+\tImplement RTL specific hooks.\n+\t(rtl_cfg_hooks, cfg_layout_rtl_cfg_hooks): Register the new hooks.\n+\t* tree-cfg.c (gimple_empty_block_p,\n+\tgimple_split_block_before_cond_jump): Implement GIMPLE specific hooks.\n+\t(gimple_cfg_hooks): Register the new hooks.\n+\t* tree-ssa-phiopt.c (empty_block_p): Remove in favor of new hook.\n+\n 2012-09-13  Richard Guenther  <rguenther@suse.de>\n \n \t* tree-ssa-sccvn.h (enum vn_kind): New.\n@@ -165,8 +206,8 @@\n \n 2012-09-11  Marc Glisse  <marc.glisse@inria.fr>\n \n-        * tree-ssa-forwprop.c (simplify_vector_constructor): New function.\n-        (ssa_forward_propagate_and_combine): Call it.\n+\t* tree-ssa-forwprop.c (simplify_vector_constructor): New function.\n+\t(ssa_forward_propagate_and_combine): Call it.\n \n 2012-09-11  Diego Novillo  <dnovillo@google.com>\n \n@@ -193,7 +234,7 @@\n \t* doc/sourcebuild.texi (arm_neon_v2_ok): Fix @anchor.\n \n 2012-09-11  Ramana Radhakrishnan  <ramana.radhakrishnan@arm.com>\n-            Matthew Gretton-Dann  <matthew.gretton-dann@arm.com>\n+\t    Matthew Gretton-Dann  <matthew.gretton-dann@arm.com>\n \n \t* config/arm/neon.md (fma<VCVTF:mode>4): New pattern.\n \t(*fmsub<VCVTF:mode>4): Likewise.\n@@ -304,7 +345,7 @@\n \n 2012-09-10  Marc Glisse  <marc.glisse@inria.fr>\n \n-        * tree-ssa-forwprop.c (simplify_permutation): Handle CONSTRUCTOR.\n+\t* tree-ssa-forwprop.c (simplify_permutation): Handle CONSTRUCTOR.\n \n 2012-09-10  Martin Jambor  <mjambor@suse.cz>\n \n@@ -641,7 +682,7 @@\n \n 2012-09-05  Andrew Pinski  <apinski@cavium.com>\n \n- \t* optabs.c (emit_conditional_add): Correct comment about the arguments.\n+\t* optabs.c (emit_conditional_add): Correct comment about the arguments.\n \tRemove code which might swap op2 and op3 since they cannot be swapped.\n \t* doc/md.texi (add@var{mode}cc): Fix document about how the arguments\n \tare used.\n@@ -1598,7 +1639,7 @@\n \t* alias.c (rtx_equal_for_memref_p): Convert constant cases.\n \t* combine.c (find_single_use_1, mark_used_regs_combine): Convert\n \tto CASE_CONST_ANY.\n- \t* cse.c (exp_equiv_p, canon_reg, fold_rtx, cse_process_notes_1,\n+\t* cse.c (exp_equiv_p, canon_reg, fold_rtx, cse_process_notes_1,\n \tcount_reg_usage): Convert constant cases.\n \t* cselib.c (cselib_expand_value_rtx_1): Convert to CASE_CONST_ANY.\n \t(cselib_subst_to_values): Convert constant cases."}, {"sha": "acd1f7abebc1008a1cb0ee3672a1a82895a3495f", "filename": "gcc/cfghooks.c", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df92c6403cb342aac3fe8720895d979b6d677321/gcc%2Fcfghooks.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df92c6403cb342aac3fe8720895d979b6d677321/gcc%2Fcfghooks.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfghooks.c?ref=df92c6403cb342aac3fe8720895d979b6d677321", "patch": "@@ -1306,3 +1306,21 @@ copy_bbs (basic_block *bbs, unsigned n, basic_block *new_bbs,\n     bbs[i]->flags &= ~BB_DUPLICATED;\n }\n \n+/* Return true if BB contains only labels or non-executable\n+   instructions */\n+bool\n+empty_block_p (basic_block bb)\n+{\n+  gcc_assert (cfg_hooks->empty_block_p);\n+  return cfg_hooks->empty_block_p (bb);\n+}\n+\n+/* Split a basic block if it ends with a conditional branch and if\n+   the other part of the block is not empty.  */\n+basic_block\n+split_block_before_cond_jump (basic_block bb)\n+{\n+  gcc_assert (cfg_hooks->split_block_before_cond_jump);\n+  return cfg_hooks->split_block_before_cond_jump (bb);\n+}\n+"}, {"sha": "951bdf6e17d78cce3128b0bcca70520e3611ca35", "filename": "gcc/cfghooks.h", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df92c6403cb342aac3fe8720895d979b6d677321/gcc%2Fcfghooks.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df92c6403cb342aac3fe8720895d979b6d677321/gcc%2Fcfghooks.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfghooks.h?ref=df92c6403cb342aac3fe8720895d979b6d677321", "patch": "@@ -138,6 +138,13 @@ struct cfg_hooks\n   /* Add PHI arguments queued in PENDINT_STMT list on edge E to edge\n      E->dest (only in tree-ssa loop versioning.  */\n   void (*flush_pending_stmts) (edge);\n+  \n+  /* True if a block contains no executable instructions.  */\n+  bool (*empty_block_p) (basic_block);\n+\n+  /* Split a basic block if it ends with a conditional branch and if\n+     the other part of the block is not empty.  */\n+  basic_block (*split_block_before_cond_jump) (basic_block);\n };\n \n extern void verify_flow_info (void);\n@@ -166,6 +173,8 @@ extern bool predicted_by_p (const_basic_block bb, enum br_predictor predictor);\n extern bool can_duplicate_block_p (const_basic_block);\n extern basic_block duplicate_block (basic_block, edge, basic_block);\n extern bool block_ends_with_call_p (basic_block bb);\n+extern bool empty_block_p (basic_block);\n+extern basic_block split_block_before_cond_jump (basic_block);\n extern bool block_ends_with_condjump_p (const_basic_block bb);\n extern int flow_call_edges_add (sbitmap);\n extern void execute_on_growing_pred (edge);"}, {"sha": "4df289d8889702d53bd16458d6a9830a5f44db8b", "filename": "gcc/cfgrtl.c", "status": "modified", "additions": 51, "deletions": 2, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df92c6403cb342aac3fe8720895d979b6d677321/gcc%2Fcfgrtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df92c6403cb342aac3fe8720895d979b6d677321/gcc%2Fcfgrtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgrtl.c?ref=df92c6403cb342aac3fe8720895d979b6d677321", "patch": "@@ -4120,6 +4120,51 @@ rtl_make_forwarder_block (edge fallthru ATTRIBUTE_UNUSED)\n {\n }\n \n+/* Return true if BB contains only labels or non-executable\n+   instructions.  */\n+\n+static bool\n+rtl_block_empty_p (basic_block bb)\n+{\n+  rtx insn;\n+\n+  if (bb == ENTRY_BLOCK_PTR || bb == EXIT_BLOCK_PTR)\n+    return true;\n+\n+  FOR_BB_INSNS (bb, insn)\n+    if (NONDEBUG_INSN_P (insn) && !any_uncondjump_p (insn))\n+      return false;\n+\n+  return true;\n+}\n+\n+/* Split a basic block if it ends with a conditional branch and if\n+   the other part of the block is not empty.  */\n+\n+static basic_block\n+rtl_split_block_before_cond_jump (basic_block bb)\n+{\n+  rtx insn;\n+  rtx split_point = NULL;\n+  rtx last = NULL;\n+  bool found_code = false;\n+\n+  FOR_BB_INSNS (bb, insn)\n+    {\n+      if (any_condjump_p (insn))\n+\tsplit_point = last;\n+      else if (NONDEBUG_INSN_P (insn))\n+\tfound_code = true;\n+      last = insn;\n+    }\n+\n+  /* Did not find everything.  */ \n+  if (found_code && split_point)\n+    return split_block (bb, split_point)->dest;\n+  else \n+    return NULL;\n+}\n+\n /* Return 1 if BB ends with a call, possibly followed by some\n    instructions that must stay with the call, 0 otherwise.  */\n \n@@ -4432,7 +4477,9 @@ struct cfg_hooks rtl_cfg_hooks = {\n   NULL, /* lv_add_condition_to_bb */\n   NULL, /* lv_adjust_loop_header_phi*/\n   NULL, /* extract_cond_bb_edges */\n-  NULL\t\t/* flush_pending_stmts */\n+  NULL, /* flush_pending_stmts */\n+  rtl_block_empty_p, /* block_empty_p */\n+  rtl_split_block_before_cond_jump, /* split_block_before_cond_jump */\n };\n \n /* Implementation of CFG manipulation for cfg layout RTL, where\n@@ -4470,7 +4517,9 @@ struct cfg_hooks cfg_layout_rtl_cfg_hooks = {\n   rtl_lv_add_condition_to_bb, /* lv_add_condition_to_bb */\n   NULL, /* lv_adjust_loop_header_phi*/\n   rtl_extract_cond_bb_edges, /* extract_cond_bb_edges */\n-  NULL\t\t/* flush_pending_stmts */\n+  NULL, /* flush_pending_stmts */  \n+  rtl_block_empty_p, /* block_empty_p */\n+  rtl_split_block_before_cond_jump, /* split_block_before_cond_jump */\n };\n \n #include \"gt-cfgrtl.h\""}, {"sha": "72056a6eecc70ab77421aa459988968657f6ebbb", "filename": "gcc/function.c", "status": "modified", "additions": 11, "deletions": 3, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df92c6403cb342aac3fe8720895d979b6d677321/gcc%2Ffunction.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df92c6403cb342aac3fe8720895d979b6d677321/gcc%2Ffunction.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffunction.c?ref=df92c6403cb342aac3fe8720895d979b6d677321", "patch": "@@ -6753,13 +6753,21 @@ reposition_prologue_and_epilogue_notes (void)\n #endif /* HAVE_prologue or HAVE_epilogue */\n }\n \n+/* Returns the name of function declared by FNDECL.  */\n+const char *\n+fndecl_name (tree fndecl)\n+{\n+  if (fndecl == NULL)\n+    return \"(nofn)\";\n+  return lang_hooks.decl_printable_name (fndecl, 2);\n+}\n+\n /* Returns the name of function FN.  */\n const char *\n function_name (struct function *fn)\n {\n-  if (fn == NULL)\n-    return \"(nofn)\";\n-  return lang_hooks.decl_printable_name (fn->decl, 2);\n+  tree fndecl = (fn == NULL) ? NULL : fn->decl;\n+  return fndecl_name (fndecl);\n }\n \n /* Returns the name of the current function.  */"}, {"sha": "59e729dc6bf8675cbbe09e7c91fbe20bac7018db", "filename": "gcc/function.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df92c6403cb342aac3fe8720895d979b6d677321/gcc%2Ffunction.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df92c6403cb342aac3fe8720895d979b6d677321/gcc%2Ffunction.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffunction.h?ref=df92c6403cb342aac3fe8720895d979b6d677321", "patch": "@@ -760,6 +760,7 @@ extern void clobber_return_register (void);\n extern rtx get_arg_pointer_save_area (void);\n \n /* Returns the name of the current function.  */\n+extern const char *fndecl_name (tree);\n extern const char *function_name (struct function *);\n extern const char *current_function_name (void);\n "}, {"sha": "6bdd4d14bdf588718acb917070121cc6af65dcb7", "filename": "gcc/ipa-pure-const.c", "status": "modified", "additions": 8, "deletions": 12, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df92c6403cb342aac3fe8720895d979b6d677321/gcc%2Fipa-pure-const.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df92c6403cb342aac3fe8720895d979b6d677321/gcc%2Fipa-pure-const.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-pure-const.c?ref=df92c6403cb342aac3fe8720895d979b6d677321", "patch": "@@ -192,6 +192,7 @@ warn_function_noreturn (tree decl)\n       = suggest_attribute (OPT_Wsuggest_attribute_noreturn, decl,\n \t\t\t   true, warned_about, \"noreturn\");\n }\n+\n /* Init the function state.  */\n \n static void\n@@ -387,7 +388,7 @@ state_from_flags (enum pure_const_state_e *state, bool *looping,\n   else\n     {\n       if (dump_file && (dump_flags & TDF_DETAILS))\n-\tfprintf (dump_file, \" neihter\\n\");\n+\tfprintf (dump_file, \" neither\\n\");\n       *state = IPA_NEITHER;\n       *looping = true;\n     }\n@@ -1573,7 +1574,7 @@ local_pure_const (void)\n       warn_function_noreturn (cfun->decl);\n       if (dump_file)\n         fprintf (dump_file, \"Function found to be noreturn: %s\\n\",\n-\t         lang_hooks.decl_printable_name (current_function_decl, 2));\n+\t         current_function_name ());\n \n       /* Update declaration and reduce profile to executed once.  */\n       TREE_THIS_VOLATILE (current_function_decl) = 1;\n@@ -1597,8 +1598,7 @@ local_pure_const (void)\n \t  if (dump_file)\n \t    fprintf (dump_file, \"Function found to be %sconst: %s\\n\",\n \t\t     l->looping ? \"looping \" : \"\",\n-\t\t     lang_hooks.decl_printable_name (current_function_decl,\n-\t\t\t\t\t\t     2));\n+\t\t     current_function_name ());\n \t}\n       else if (DECL_LOOPING_CONST_OR_PURE_P (current_function_decl)\n \t       && !l->looping)\n@@ -1610,8 +1610,7 @@ local_pure_const (void)\n \t    }\n \t  if (dump_file)\n \t    fprintf (dump_file, \"Function found to be non-looping: %s\\n\",\n-\t\t     lang_hooks.decl_printable_name (current_function_decl,\n-\t\t\t\t\t\t     2));\n+\t\t     current_function_name ());\n \t}\n       break;\n \n@@ -1627,8 +1626,7 @@ local_pure_const (void)\n \t  if (dump_file)\n \t    fprintf (dump_file, \"Function found to be %spure: %s\\n\",\n \t\t     l->looping ? \"looping \" : \"\",\n-\t\t     lang_hooks.decl_printable_name (current_function_decl,\n-\t\t\t\t\t\t     2));\n+\t\t     current_function_name ());\n \t}\n       else if (DECL_LOOPING_CONST_OR_PURE_P (current_function_decl)\n \t       && !l->looping)\n@@ -1640,8 +1638,7 @@ local_pure_const (void)\n \t    }\n \t  if (dump_file)\n \t    fprintf (dump_file, \"Function found to be non-looping: %s\\n\",\n-\t\t     lang_hooks.decl_printable_name (current_function_decl,\n-\t\t\t\t\t\t     2));\n+\t\t     current_function_name ());\n \t}\n       break;\n \n@@ -1654,8 +1651,7 @@ local_pure_const (void)\n       changed = true;\n       if (dump_file)\n \tfprintf (dump_file, \"Function found to be nothrow: %s\\n\",\n-\t\t lang_hooks.decl_printable_name (current_function_decl,\n-\t\t\t\t\t\t 2));\n+\t\t current_function_name ());\n     }\n   free (l);\n   if (changed)"}, {"sha": "9072fe821991cdd0dafb667c2cbf9c98de2786eb", "filename": "gcc/ipa-reference.c", "status": "modified", "additions": 245, "deletions": 295, "changes": 540, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df92c6403cb342aac3fe8720895d979b6d677321/gcc%2Fipa-reference.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df92c6403cb342aac3fe8720895d979b6d677321/gcc%2Fipa-reference.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-reference.c?ref=df92c6403cb342aac3fe8720895d979b6d677321", "patch": "@@ -45,7 +45,6 @@ along with GCC; see the file COPYING3.  If not see\n #include \"tree-flow.h\"\n #include \"tree-inline.h\"\n #include \"tree-pass.h\"\n-#include \"langhooks.h\"\n #include \"pointer-set.h\"\n #include \"splay-tree.h\"\n #include \"ggc.h\"\n@@ -55,7 +54,6 @@ along with GCC; see the file COPYING3.  If not see\n #include \"cgraph.h\"\n #include \"flags.h\"\n #include \"diagnostic.h\"\n-#include \"langhooks.h\"\n #include \"data-streamer.h\"\n #include \"lto-streamer.h\"\n \n@@ -109,9 +107,9 @@ typedef struct ipa_reference_vars_info_d *ipa_reference_vars_info_t;\n    being considered by the compilation level alias analysis.  */\n static splay_tree reference_vars_to_consider;\n \n-/* A bit is set for every module static we are considering.  This is\n-   ored into the local info when asm code is found that clobbers all\n-   memory. */\n+/* Set of all interesting module statics.  A bit is set for every module\n+   static we are considering.  This is added to the local info when asm\n+   code is found that clobbers all memory.  */\n static bitmap all_module_statics;\n \n /* Obstack holding bitmaps of local analysis (live from analysis to\n@@ -124,10 +122,12 @@ static bitmap_obstack optimization_summary_obstack;\n static struct cgraph_2node_hook_list *node_duplication_hook_holder;\n static struct cgraph_node_hook_list *node_removal_hook_holder;\n \n-/* Vector where the reference var infos are actually stored. */\n+/* Vector where the reference var infos are actually stored. \n+   Indexed by UID of call graph nodes.  */\n DEF_VEC_P (ipa_reference_vars_info_t);\n DEF_VEC_ALLOC_P (ipa_reference_vars_info_t, heap);\n static VEC (ipa_reference_vars_info_t, heap) *ipa_reference_vars_vector;\n+\n DEF_VEC_P (ipa_reference_optimization_summary_t);\n DEF_VEC_ALLOC_P (ipa_reference_optimization_summary_t, heap);\n static VEC (ipa_reference_optimization_summary_t, heap) *ipa_reference_opt_sum_vector;\n@@ -153,7 +153,8 @@ get_reference_optimization_summary (struct cgraph_node *node)\n \t\t      ipa_reference_opt_sum_vector)\n \t  <= (unsigned int) node->uid))\n     return NULL;\n-  return VEC_index (ipa_reference_optimization_summary_t, ipa_reference_opt_sum_vector,\n+  return VEC_index (ipa_reference_optimization_summary_t,\n+\t\t    ipa_reference_opt_sum_vector,\n \t\t    node->uid);\n }\n \n@@ -186,16 +187,15 @@ set_reference_optimization_summary (struct cgraph_node *node,\n \t       ipa_reference_opt_sum_vector, node->uid, info);\n }\n \n-/* Return a bitmap indexed by_DECL_UID uid for the static variables\n-   that are not read during the execution of the function FN.  Returns\n+/* Return a bitmap indexed by DECL_UID for the static variables that\n+   are *not* read during the execution of the function FN.  Returns\n    NULL if no data is available.  */\n \n bitmap\n ipa_reference_get_not_read_global (struct cgraph_node *fn)\n {\n-  ipa_reference_optimization_summary_t info;\n-\n-  info = get_reference_optimization_summary (cgraph_function_node (fn, NULL));\n+  ipa_reference_optimization_summary_t info =\n+    get_reference_optimization_summary (cgraph_function_node (fn, NULL));\n   if (info)\n     return info->statics_not_read;\n   else if (flags_from_decl_or_type (fn->symbol.decl) & ECF_LEAF)\n@@ -204,17 +204,16 @@ ipa_reference_get_not_read_global (struct cgraph_node *fn)\n     return NULL;\n }\n \n-/* Return a bitmap indexed by DECL_UID uid for the static variables\n-   that are not written during the execution of the function FN.  Note\n+/* Return a bitmap indexed by DECL_UID for the static variables that\n+   are *not* written during the execution of the function FN.  Note\n    that variables written may or may not be read during the function\n    call.  Returns NULL if no data is available.  */\n \n bitmap\n ipa_reference_get_not_written_global (struct cgraph_node *fn)\n {\n-  ipa_reference_optimization_summary_t info;\n-\n-  info = get_reference_optimization_summary (fn);\n+  ipa_reference_optimization_summary_t info =\n+    get_reference_optimization_summary (fn);\n   if (info)\n     return info->statics_not_written;\n   else if (flags_from_decl_or_type (fn->symbol.decl) & ECF_LEAF)\n@@ -277,89 +276,147 @@ get_static_name (int index)\n {\n   splay_tree_node stn =\n     splay_tree_lookup (reference_vars_to_consider, index);\n-  if (stn)\n-    return lang_hooks.decl_printable_name ((tree)(stn->value), 2);\n-  return NULL;\n+  return fndecl_name ((tree)(stn->value));\n+}\n+\n+/* Dump a set of static vars to FILE.  */\n+static void\n+dump_static_vars_set_to_file (FILE *f, bitmap set)\n+{\n+  unsigned int index;\n+  bitmap_iterator bi;\n+  if (set == NULL)\n+    return;\n+  else if (set == all_module_statics)\n+    fprintf (f, \"ALL\");\n+  else\n+    EXECUTE_IF_SET_IN_BITMAP (set, 0, index, bi)\n+      {\n+        fprintf (f, \"%s \", get_static_name (index));\n+      }\n+}\n+\n+/* Compute X |= Y, taking into account the possibility that\n+   either X or Y is already the maximum set.\n+   Return true if X is the maximum set after taking the union with Y.  */\n+\n+static bool\n+union_static_var_sets (bitmap &x, bitmap y)\n+{\n+  if (x != all_module_statics)\n+    {\n+      if (y == all_module_statics)\n+\t{\n+\t  BITMAP_FREE (x);\n+\t  x = all_module_statics;\n+\t}\n+      else if (bitmap_ior_into (x, y))\n+\t{\n+\t  /* The union may have reduced X to the maximum set.\n+\t     In that case, we want to make that visible explicitly.\n+\t     Even though bitmap_equal_p can be very expensive, it\n+\t     turns out to be an overall win to check this here for\n+\t     an LTO bootstrap of GCC itself.  Liberally extrapoliate\n+\t     that result to be applicable to all cases.  */\n+\t  if (bitmap_equal_p (x, all_module_statics))\n+\t    {\n+\t      BITMAP_FREE (x);\n+\t      x = all_module_statics;\n+\t    }\n+\t}\n+    }\n+  return x == all_module_statics;\n+}\n+\n+/* Compute X &= Y, taking into account the possibility that\n+   X may become the maximum set.  */\n+\n+static bool\n+intersect_static_var_sets (bitmap &x, bitmap y)\n+{\n+  if (x != all_module_statics)\n+    {\n+      bitmap_and_into (x, y);\n+      /* As with union_static_var_sets, reducing to the maximum\n+\t set as early as possible is an overall win.  */\n+      if (bitmap_equal_p (x, all_module_statics))\n+\t{\n+\t  BITMAP_FREE (x);\n+\t  x = all_module_statics;\n+\t}\n+    }\n+  return x == all_module_statics;\n }\n \n-/* Or in all of the bits from every callee of X into X_GLOBAL, the caller's cycle,\n-   bit vector.  There are several cases to check to avoid the sparse\n-   bitmap oring.  */\n+/* Return a copy of SET on the bitmap obstack containing SET.\n+   But if SET is NULL or the maximum set, return that instead.  */\n+\n+static bitmap\n+copy_static_var_set (bitmap set)\n+{\n+  if (set == NULL || set == all_module_statics)\n+    return set;\n+  bitmap_obstack *o = set->obstack;\n+  gcc_checking_assert (o);\n+  bitmap copy = BITMAP_ALLOC (o);\n+  bitmap_copy (copy, set);\n+  return copy;\n+}\n+\n+/* Compute the union all of the statics read and written by every callee of X\n+   into X_GLOBAL->statics_read and X_GLOBAL->statics_written.  X_GLOBAL is\n+   actually the set representing the cycle containing X.  If the read and\n+   written sets of X_GLOBAL has been reduced to the maximum set, we don't\n+   have to look at the remaining callees.  */\n \n static void\n propagate_bits (ipa_reference_global_vars_info_t x_global, struct cgraph_node *x)\n {\n   struct cgraph_edge *e;\n-  for (e = x->callees; e; e = e->next_callee)\n+  bool read_all = x_global->statics_read == all_module_statics;\n+  bool write_all = x_global->statics_written == all_module_statics;\n+  for (e = x->callees;\n+       e && !(read_all && write_all);\n+       e = e->next_callee)\n     {\n       enum availability avail;\n       struct cgraph_node *y = cgraph_function_node (e->callee, &avail);\n-\n       if (!y)\n \tcontinue;\n+\n       /* Only look into nodes we can propagate something.  */\n+      int flags = flags_from_decl_or_type (y->symbol.decl);\n       if (avail > AVAIL_OVERWRITABLE\n-\t  || (avail == AVAIL_OVERWRITABLE\n-\t      && (flags_from_decl_or_type (y->symbol.decl) & ECF_LEAF)))\n+\t  || (avail == AVAIL_OVERWRITABLE && (flags & ECF_LEAF)))\n \t{\n-\t  int flags = flags_from_decl_or_type (y->symbol.decl);\n \t  if (get_reference_vars_info (y))\n \t    {\n-\t      ipa_reference_vars_info_t y_info\n-\t\t= get_reference_vars_info (y);\n+\t      ipa_reference_vars_info_t y_info = get_reference_vars_info (y);\n \t      ipa_reference_global_vars_info_t y_global = &y_info->global;\n \n-\t      /* Calls in current cycle do not have global computed yet.  */\n+\t      /* Calls in the current cycle do not have their global set\n+\t\t computed yet (but everything else does because we're\n+\t\t visiting nodes in topological order).  */\n \t      if (!y_global->statics_read)\n \t\tcontinue;\n \n-\t      /* If function is declared const, it reads no memory even if it\n+\t      /* If the function is const, it reads no memory even if it\n \t\t seems so to local analysis.  */\n \t      if (flags & ECF_CONST)\n \t\tcontinue;\n \n-\t      if (x_global->statics_read\n-\t\t  != all_module_statics)\n-\t\t{\n-\t\t  if (y_global->statics_read\n-\t\t      == all_module_statics)\n-\t\t    {\n-\t\t      BITMAP_FREE (x_global->statics_read);\n-\t\t      x_global->statics_read\n-\t\t\t= all_module_statics;\n-\t\t    }\n-\t\t  /* Skip bitmaps that are pointer equal to node's bitmap\n-\t\t     (no reason to spin within the cycle).  */\n-\t\t  else if (x_global->statics_read\n-\t\t\t   != y_global->statics_read)\n-\t\t    bitmap_ior_into (x_global->statics_read,\n+\t      union_static_var_sets (x_global->statics_read,\n \t\t\t\t     y_global->statics_read);\n-\t\t}\n \n-\t      /* If function is declared pure, it has no stores even if it\n-\t\t seems so to local analysis; If we can not return from here,\n-\t\t we can safely ignore the call.  */\n+\t      /* If the function is pure, it has no stores even if it\n+\t\t seems so to local analysis.  If we cannot return from\n+\t\t the function, we can safely ignore the call.  */\n \t      if ((flags & ECF_PURE)\n \t\t  || cgraph_edge_cannot_lead_to_return (e))\n \t\tcontinue;\n \n-\t      if (x_global->statics_written\n-\t\t  != all_module_statics)\n-\t\t{\n-\t\t  if (y_global->statics_written\n-\t\t      == all_module_statics)\n-\t\t    {\n-\t\t      BITMAP_FREE (x_global->statics_written);\n-\t\t      x_global->statics_written\n-\t\t\t= all_module_statics;\n-\t\t    }\n-\t\t  /* Skip bitmaps that are pointer equal to node's bitmap\n-\t\t     (no reason to spin within the cycle).  */\n-\t\t  else if (x_global->statics_written\n-\t\t\t   != y_global->statics_written)\n-\t\t    bitmap_ior_into (x_global->statics_written,\n+\t      union_static_var_sets (x_global->statics_written,\n \t\t\t\t     y_global->statics_written);\n-\t\t}\n \t    }\n \t  else\n \t    gcc_unreachable ();\n@@ -449,19 +506,6 @@ analyze_function (struct cgraph_node *fn)\n     bitmap_clear (local->statics_written);\n }\n \n-static bitmap\n-copy_global_bitmap (bitmap src)\n-{\n-  bitmap dst;\n-  if (!src)\n-    return NULL;\n-  if (src == all_module_statics)\n-    return all_module_statics;\n-  dst = BITMAP_ALLOC (&optimization_summary_obstack);\n-  bitmap_copy (dst, src);\n-  return dst;\n-}\n-\n \n /* Called when new clone is inserted to callgraph late.  */\n \n@@ -477,8 +521,10 @@ duplicate_node_data (struct cgraph_node *src, struct cgraph_node *dst,\n     return;\n   dst_ginfo = XCNEW (struct ipa_reference_optimization_summary_d);\n   set_reference_optimization_summary (dst, dst_ginfo);\n-  dst_ginfo->statics_not_read = copy_global_bitmap (ginfo->statics_not_read);\n-  dst_ginfo->statics_not_written = copy_global_bitmap (ginfo->statics_not_written);\n+  dst_ginfo->statics_not_read =\n+    copy_static_var_set (ginfo->statics_not_read);\n+  dst_ginfo->statics_not_written =\n+    copy_static_var_set (ginfo->statics_not_written);\n }\n \n /* Called when node is removed.  */\n@@ -511,10 +557,8 @@ generate_summary (void)\n   struct cgraph_node *node;\n   unsigned int index;\n   bitmap_iterator bi;\n-  bitmap bm_temp;\n \n   ipa_init ();\n-  bm_temp = BITMAP_ALLOC (&local_info_obstack);\n \n   /* Process all of the functions next.  */\n   FOR_EACH_DEFINED_FUNCTION (node)\n@@ -523,12 +567,10 @@ generate_summary (void)\n   if (dump_file)\n     EXECUTE_IF_SET_IN_BITMAP (all_module_statics, 0, index, bi)\n       {\n-\tfprintf (dump_file, \"\\nPromotable global:%s\",\n-\t\t get_static_name (index));\n+\tfprintf (dump_file, \"\\nPromotable global:%s (uid=%u)\\n\",\n+\t\t get_static_name (index), index);\n       }\n \n-  BITMAP_FREE(bm_temp);\n-\n   if (dump_file)\n     FOR_EACH_DEFINED_FUNCTION (node)\n       if (cgraph_function_body_availability (node) >= AVAIL_OVERWRITABLE)\n@@ -563,8 +605,8 @@ generate_summary (void)\n /* Set READ_ALL/WRITE_ALL based on decl flags of NODE.  */\n \n static void\n-read_write_all_from_decl (struct cgraph_node *node, bool * read_all,\n-\t\t\t  bool * write_all)\n+read_write_all_from_decl (struct cgraph_node *node,\n+\t\t\t  bool &read_all, bool &write_all)\n {\n   tree decl = node->symbol.decl;\n   int flags = flags_from_decl_or_type (decl);\n@@ -576,7 +618,7 @@ read_write_all_from_decl (struct cgraph_node *node, bool * read_all,\n   else if ((flags & ECF_PURE)\n \t   || cgraph_node_cannot_return (node))\n     {\n-      *read_all = true;\n+      read_all = true;\n       if (dump_file && (dump_flags & TDF_DETAILS))\n          fprintf (dump_file, \"   %s/%i -> read all\\n\",\n \t\t  cgraph_node_asm_name (node), node->symbol.order);\n@@ -585,23 +627,64 @@ read_write_all_from_decl (struct cgraph_node *node, bool * read_all,\n     {\n        /* TODO: To be able to produce sane results, we should also handle\n \t  common builtins, in particular throw.  */\n-      *read_all = true;\n-      *write_all = true;\n+      read_all = true;\n+      write_all = true;\n       if (dump_file && (dump_flags & TDF_DETAILS))\n          fprintf (dump_file, \"   %s/%i -> read all, write all\\n\",\n \t\t  cgraph_node_asm_name (node), node->symbol.order);\n     }\n }\n \n+/* Set READ_ALL/WRITE_ALL based on decl flags of NODE or any member\n+   in the cycle of NODE.  */\n+\n+static void\n+get_read_write_all_from_node (struct cgraph_node *node,\n+\t\t\t      bool &read_all, bool &write_all)\n+{\n+  struct cgraph_edge *e, *ie;\n+\n+  /* When function is overwritable, we can not assume anything.  */\n+  if (cgraph_function_body_availability (node) <= AVAIL_OVERWRITABLE)\n+    read_write_all_from_decl (node, read_all, write_all);\n+\n+  for (e = node->callees;\n+       e && !(read_all && write_all);\n+       e = e->next_callee)\n+    {\n+      enum availability avail;\n+      struct cgraph_node *callee = cgraph_function_node (e->callee, &avail);\n+      gcc_checking_assert (callee);\n+      if (avail <= AVAIL_OVERWRITABLE)\n+\tread_write_all_from_decl (callee, read_all, write_all);\n+    }\n+\n+  for (ie = node->indirect_calls;\n+       ie && !(read_all && write_all);\n+       ie = ie->next_callee)\n+    if (!(ie->indirect_info->ecf_flags & ECF_CONST))\n+      {\n+\tread_all = true;\n+\tif (dump_file && (dump_flags & TDF_DETAILS))\n+\t  fprintf (dump_file, \"   indirect call -> read all\\n\");\n+\tif (!cgraph_edge_cannot_lead_to_return (ie)\n+\t    && !(ie->indirect_info->ecf_flags & ECF_PURE))\n+\t  {\n+\t    if (dump_file && (dump_flags & TDF_DETAILS))\n+\t      fprintf (dump_file, \"   indirect call -> write all\\n\");\n+\t    write_all = true;\n+\t  }\n+      }\n+}\n+\n /* Produce the global information by preforming a transitive closure\n-   on the local information that was produced by ipa_analyze_function */\n+   on the local information that was produced by ipa_analyze_function.  */\n \n static unsigned int\n propagate (void)\n {\n   struct cgraph_node *node;\n   struct varpool_node *vnode;\n-  struct cgraph_node *w;\n   struct cgraph_node **order =\n     XCNEWVEC (struct cgraph_node *, cgraph_n_nodes);\n   int order_pos;\n@@ -627,12 +710,9 @@ propagate (void)\n   FOR_EACH_DEFINED_FUNCTION (node)\n     {\n       ipa_reference_local_vars_info_t node_l;\n-\n       node_l = &get_reference_vars_info (node)->local;\n-      if (node_l->statics_read != all_module_statics)\n-        bitmap_and_into (node_l->statics_read, all_module_statics);\n-      if (node_l->statics_written != all_module_statics)\n-        bitmap_and_into (node_l->statics_written, all_module_statics);\n+      intersect_static_var_sets (node_l->statics_read, all_module_statics);\n+      intersect_static_var_sets (node_l->statics_written, all_module_statics);\n     }\n \n   /* Propagate the local information through the call graph to produce\n@@ -645,250 +725,123 @@ propagate (void)\n \n   for (i = 0; i < order_pos; i++ )\n     {\n+      unsigned x;\n+      struct cgraph_node *w;\n       ipa_reference_vars_info_t node_info;\n       ipa_reference_global_vars_info_t node_g;\n       ipa_reference_local_vars_info_t node_l;\n-      struct cgraph_edge *e, *ie;\n-\n-      bool read_all;\n-      bool write_all;\n-      struct ipa_dfs_info * w_info;\n+      bool read_all = false;\n+      bool write_all = false;\n \n       node = order[i];\n       if (node->alias)\n \tcontinue;\n+\n       node_info = get_reference_vars_info (node);\n       gcc_assert (node_info);\n-\n+      node_l = &node_info->local;\n+      node_g = &node_info->global;\n \n       if (dump_file && (dump_flags & TDF_DETAILS))\n \tfprintf (dump_file, \"Starting cycle with %s/%i\\n\",\n \t\t  cgraph_node_asm_name (node), node->symbol.order);\n \n-      node_l = &node_info->local;\n-      node_g = &node_info->global;\n-\n-      read_all = false;\n-      write_all = false;\n-\n-      /* When function is overwritable, we can not assume anything.  */\n-      if (cgraph_function_body_availability (node) <= AVAIL_OVERWRITABLE)\n-        read_write_all_from_decl (node, &read_all, &write_all);\n+      VEC (cgraph_node_p, heap) *cycle_nodes = ipa_get_nodes_in_cycle (node);\n \n-      for (e = node->callees; e; e = e->next_callee)\n-\t{\n-\t  enum availability avail;\n-\t  struct cgraph_node *callee = cgraph_function_node (e->callee, &avail);\n-          if (!callee || avail <= AVAIL_OVERWRITABLE)\n-            read_write_all_from_decl (callee, &read_all, &write_all);\n-\t}\n-\n-      for (ie = node->indirect_calls; ie; ie = ie->next_callee)\n-\tif (!(ie->indirect_info->ecf_flags & ECF_CONST))\n-\t  {\n-\t    read_all = true;\n-\t    if (dump_file && (dump_flags & TDF_DETAILS))\n-\t       fprintf (dump_file, \"   indirect call -> read all\\n\");\n-\t    if (!cgraph_edge_cannot_lead_to_return (ie)\n-\t\t&& !(ie->indirect_info->ecf_flags & ECF_PURE))\n-\t      {\n-\t\tif (dump_file && (dump_flags & TDF_DETAILS))\n-\t\t   fprintf (dump_file, \"   indirect call -> write all\\n\");\n-\t        write_all = true;\n-\t      }\n-\t  }\n-\n-\n-      /* If any node in a cycle is read_all or write_all\n-\t they all are. */\n-      w_info = (struct ipa_dfs_info *) node->symbol.aux;\n-      w = w_info->next_cycle;\n-      while (w && (!read_all || !write_all))\n+      /* If any node in a cycle is read_all or write_all, they all are.  */\n+      FOR_EACH_VEC_ELT (cgraph_node_p, cycle_nodes, x, w)\n \t{\n \t  if (dump_file && (dump_flags & TDF_DETAILS))\n \t    fprintf (dump_file, \"  Visiting %s/%i\\n\",\n-\t\t      cgraph_node_asm_name (w), w->symbol.order);\n-\t  /* When function is overwritable, we can not assume anything.  */\n-\t  if (cgraph_function_body_availability (w) <= AVAIL_OVERWRITABLE)\n-\t    read_write_all_from_decl (w, &read_all, &write_all);\n-\n-\t  for (e = w->callees; e; e = e->next_callee)\n-\t    {\n-\t      enum availability avail;\n-\t      struct cgraph_node *callee = cgraph_function_node (e->callee, &avail);\n-\n-\t      if (avail <= AVAIL_OVERWRITABLE)\n-\t\tread_write_all_from_decl (callee, &read_all, &write_all);\n-\t    }\n-\n-\t  for (ie = w->indirect_calls; ie; ie = ie->next_callee)\n-\t    if (!(ie->indirect_info->ecf_flags & ECF_CONST))\n-\t      {\n-\t\tread_all = true;\n-\t\tif (dump_file && (dump_flags & TDF_DETAILS))\n-\t\t   fprintf (dump_file, \"   indirect call -> read all\\n\");\n-\t\tif (!cgraph_edge_cannot_lead_to_return (ie)\n-\t\t    && !(ie->indirect_info->ecf_flags & ECF_PURE))\n-\t\t  {\n-\t\t    write_all = true;\n-\t\t    if (dump_file && (dump_flags & TDF_DETAILS))\n-\t\t       fprintf (dump_file, \"   indirect call -> write all\\n\");\n-\t\t  }\n-\t      }\n-\n-\t  w_info = (struct ipa_dfs_info *) w->symbol.aux;\n-\t  w = w_info->next_cycle;\n+\t\t     cgraph_node_asm_name (w), w->symbol.order);\n+\t  get_read_write_all_from_node (w, read_all, write_all);\n+\t  if (read_all && write_all)\n+\t    break;\n \t}\n \n-\n-      /* Initialized the bitmaps for the reduced nodes */\n+      /* Initialized the bitmaps global sets for the reduced node.  */\n       if (read_all)\n \tnode_g->statics_read = all_module_statics;\n       else\n-\t{\n-\t  node_g->statics_read = BITMAP_ALLOC (&local_info_obstack);\n-\t  bitmap_copy (node_g->statics_read,\n-\t\t       node_l->statics_read);\n-\t}\n+\tnode_g->statics_read = copy_static_var_set (node_l->statics_read);\n       if (write_all)\n \tnode_g->statics_written = all_module_statics;\n       else\n-\t{\n-\t  node_g->statics_written = BITMAP_ALLOC (&local_info_obstack);\n-\t  bitmap_copy (node_g->statics_written,\n-\t\t       node_l->statics_written);\n-\t}\n+\tnode_g->statics_written = copy_static_var_set (node_l->statics_written);\n \n-      propagate_bits (node_g, node);\n-      w_info = (struct ipa_dfs_info *) node->symbol.aux;\n-      w = w_info->next_cycle;\n-      while (w && (!read_all || !write_all))\n+      /* Merge the sets of this cycle with all sets of callees reached\n+         from this cycle.  */\n+      FOR_EACH_VEC_ELT (cgraph_node_p, cycle_nodes, x, w)\n \t{\n-\t  ipa_reference_vars_info_t w_ri =\n-\t    get_reference_vars_info (w);\n-\t  ipa_reference_local_vars_info_t w_l = &w_ri->local;\n-\t  int flags = flags_from_decl_or_type (w->symbol.decl);\n-\n-\t  /* These global bitmaps are initialized from the local info\n-\t     of all of the nodes in the region.  However there is no\n-\t     need to do any work if the bitmaps were set to\n-\t     all_module_statics.  */\n-\t  if (!read_all && !(flags & ECF_CONST))\n-\t    bitmap_ior_into (node_g->statics_read,\n-\t\t\t     w_l->statics_read);\n-\t  if (!write_all\n-\t      && !(flags & ECF_PURE)\n-\t      && !cgraph_node_cannot_return (w))\n-\t    bitmap_ior_into (node_g->statics_written,\n-\t\t\t     w_l->statics_written);\n+\t  if (read_all && write_all)\n+\t    break;\n+\n+\t  if (w != node)\n+\t    {\n+\t      ipa_reference_vars_info_t w_ri = get_reference_vars_info (w);\n+\t      ipa_reference_local_vars_info_t w_l = &w_ri->local;\n+\t      int flags = flags_from_decl_or_type (w->symbol.decl);\n+\n+\t      if (!(flags & ECF_CONST))\n+\t\tread_all = union_static_var_sets (node_g->statics_read,\n+\t\t\t\t\t\t  w_l->statics_read);\n+\t      if (!(flags & ECF_PURE)\n+\t\t  && !cgraph_node_cannot_return (w))\n+\t\twrite_all = union_static_var_sets (node_g->statics_written,\n+\t\t\t\t\t\t   w_l->statics_written);\n+\t    }\n+\n \t  propagate_bits (node_g, w);\n-\t  w_info = (struct ipa_dfs_info *) w->symbol.aux;\n-\t  w = w_info->next_cycle;\n \t}\n \n       /* All nodes within a cycle have the same global info bitmaps.  */\n-      node_info->global = *node_g;\n-      w_info = (struct ipa_dfs_info *) node->symbol.aux;\n-      w = w_info->next_cycle;\n-      while (w)\n+      FOR_EACH_VEC_ELT (cgraph_node_p, cycle_nodes, x, w)\n \t{\n-\t  ipa_reference_vars_info_t w_ri =\n-\t    get_reference_vars_info (w);\n-\n+\t  ipa_reference_vars_info_t w_ri = get_reference_vars_info (w);\n           w_ri->global = *node_g;\n-\n-\t  w_info = (struct ipa_dfs_info *) w->symbol.aux;\n-\t  w = w_info->next_cycle;\n \t}\n+\n+      VEC_free (cgraph_node_p, heap, cycle_nodes);\n     }\n \n   if (dump_file)\n     {\n-      for (i = 0; i < order_pos; i++ )\n+      for (i = 0; i < order_pos; i++)\n \t{\n-\t  ipa_reference_vars_info_t node_info;\n-\t  ipa_reference_global_vars_info_t node_g;\n-\t  ipa_reference_local_vars_info_t node_l;\n-\t  unsigned int index;\n-\t  bitmap_iterator bi;\n-\t  struct ipa_dfs_info * w_info;\n+\t  unsigned x;\n+\t  struct cgraph_node *w;\n \n \t  node = order[i];\n \t  if (node->alias)\n \t    continue;\n-\t  node_info = get_reference_vars_info (node);\n-\t  node_g = &node_info->global;\n-\t  node_l = &node_info->local;\n+\n \t  fprintf (dump_file,\n \t\t   \"\\nFunction name:%s/%i:\",\n \t\t   cgraph_node_asm_name (node), node->symbol.order);\n-\t  fprintf (dump_file, \"\\n  locals read: \");\n-\t  if (node_l->statics_read)\n-\t    EXECUTE_IF_SET_IN_BITMAP (node_l->statics_read,\n-\t\t\t\t      0, index, bi)\n-\t      {\n-\t\tfprintf (dump_file, \"%s \",\n-\t\t\t get_static_name (index));\n-\t      }\n-\t  fprintf (dump_file, \"\\n  locals written: \");\n-\t  if (node_l->statics_written)\n-\t    EXECUTE_IF_SET_IN_BITMAP (node_l->statics_written,\n-\t\t\t\t      0, index, bi)\n-\t      {\n-\t\tfprintf(dump_file, \"%s \",\n-\t\t\tget_static_name (index));\n-\t      }\n \n-\t  w_info = (struct ipa_dfs_info *) node->symbol.aux;\n-\t  w = w_info->next_cycle;\n-\t  while (w)\n+\t  ipa_reference_vars_info_t node_info = get_reference_vars_info (node);\n+\t  ipa_reference_global_vars_info_t node_g = &node_info->global;\n+\n+\t  VEC (cgraph_node_p, heap) *cycle_nodes = ipa_get_nodes_in_cycle (node);\n+\t  FOR_EACH_VEC_ELT (cgraph_node_p, cycle_nodes, x, w)\n \t    {\n-\t      ipa_reference_vars_info_t w_ri =\n-\t\tget_reference_vars_info (w);\n+\t      ipa_reference_vars_info_t w_ri = get_reference_vars_info (w);\n \t      ipa_reference_local_vars_info_t w_l = &w_ri->local;\n-\t      fprintf (dump_file, \"\\n  next cycle: %s/%i \",\n-\t\t       cgraph_node_asm_name (w), w->symbol.order);\n+\t      if (w != node)\n+\t\tfprintf (dump_file, \"\\n  next cycle: %s/%i \",\n+\t\t\t cgraph_node_asm_name (w), w->symbol.order);\n \t      fprintf (dump_file, \"\\n    locals read: \");\n-\t      if (w_l->statics_read)\n-\t\tEXECUTE_IF_SET_IN_BITMAP (w_l->statics_read,\n-\t\t\t\t\t  0, index, bi)\n-\t\t  {\n-\t\t    fprintf (dump_file, \"%s \",\n-\t\t\t     get_static_name (index));\n-\t\t  }\n-\n+\t      dump_static_vars_set_to_file (dump_file, w_l->statics_read);\n \t      fprintf (dump_file, \"\\n    locals written: \");\n-\t      if (w_l->statics_written)\n-\t\tEXECUTE_IF_SET_IN_BITMAP (w_l->statics_written,\n-\t\t\t\t\t  0, index, bi)\n-\t\t  {\n-\t\t    fprintf (dump_file, \"%s \",\n-\t\t\t     get_static_name (index));\n-\t\t  }\n-\n-\t      w_info = (struct ipa_dfs_info *) w->symbol.aux;\n-\t      w = w_info->next_cycle;\n+\t      dump_static_vars_set_to_file (dump_file, w_l->statics_written);\n \t    }\n+\t  VEC_free (cgraph_node_p, heap, cycle_nodes);\n+\n \t  fprintf (dump_file, \"\\n  globals read: \");\n-\t  if (node_g->statics_read == all_module_statics)\n-\t    fprintf (dump_file, \"ALL\");\n-\t  else\n-\t    EXECUTE_IF_SET_IN_BITMAP (node_g->statics_read,\n-\t\t\t\t      0, index, bi)\n-\t      {\n-\t        fprintf (dump_file, \"%s \",\n-\t\t         get_static_name (index));\n-\t      }\n+\t  dump_static_vars_set_to_file (dump_file, node_g->statics_read);\n \t  fprintf (dump_file, \"\\n  globals written: \");\n-\t  if (node_g->statics_written == all_module_statics)\n-\t    fprintf (dump_file, \"ALL\");\n-\t  else\n-\t    EXECUTE_IF_SET_IN_BITMAP (node_g->statics_written,\n-\t\t\t\t      0, index, bi)\n-\t      {\n-\t\tfprintf (dump_file, \"%s \",\n-\t\t\t get_static_name (index));\n-\t      }\n+\t  dump_static_vars_set_to_file (dump_file, node_g->statics_written);\n+\t  fprintf (dump_file, \"\\n\");\n \t}\n     }\n \n@@ -1140,8 +1093,7 @@ ipa_reference_read_optimization_summary (void)\n \t\t\t\t\t\t\t     var_index);\n \t      bitmap_set_bit (all_module_statics, DECL_UID (v_decl));\n \t      if (dump_file)\n-\t\tfprintf (dump_file, \" %s\",\n-\t\t\t lang_hooks.decl_printable_name (v_decl, 2));\n+\t\tfprintf (dump_file, \" %s\", fndecl_name (v_decl));\n \t    }\n \n \t  for (i = 0; i < f_count; i++)\n@@ -1180,8 +1132,7 @@ ipa_reference_read_optimization_summary (void)\n \t\t\t\t\t\t\t\t   var_index);\n \t\t    bitmap_set_bit (info->statics_not_read, DECL_UID (v_decl));\n \t\t    if (dump_file)\n-\t\t      fprintf (dump_file, \" %s\",\n-\t\t\t       lang_hooks.decl_printable_name (v_decl, 2));\n+\t\t      fprintf (dump_file, \" %s\", fndecl_name (v_decl));\n \t\t  }\n \n \t      if (dump_file)\n@@ -1203,8 +1154,7 @@ ipa_reference_read_optimization_summary (void)\n \t\t\t\t\t\t\t\t   var_index);\n \t\t    bitmap_set_bit (info->statics_not_written, DECL_UID (v_decl));\n \t\t    if (dump_file)\n-\t\t      fprintf (dump_file, \" %s\",\n-\t\t\t       lang_hooks.decl_printable_name (v_decl, 2));\n+\t\t      fprintf (dump_file, \" %s\", fndecl_name (v_decl));\n \t\t  }\n \t      if (dump_file)\n \t\tfprintf (dump_file, \"\\n\");"}, {"sha": "91fc3806a2e55ba7e76b02c121cba180fce267e3", "filename": "gcc/ipa-utils.c", "status": "modified", "additions": 22, "deletions": 2, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df92c6403cb342aac3fe8720895d979b6d677321/gcc%2Fipa-utils.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df92c6403cb342aac3fe8720895d979b6d677321/gcc%2Fipa-utils.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-utils.c?ref=df92c6403cb342aac3fe8720895d979b6d677321", "patch": "@@ -154,8 +154,11 @@ searchc (struct searchc_env* env, struct cgraph_node *v,\n \n /* Topsort the call graph by caller relation.  Put the result in ORDER.\n \n-   The REDUCE flag is true if you want the cycles reduced to single nodes.  Set\n-   ALLOW_OVERWRITABLE if nodes with such availability should be included.\n+   The REDUCE flag is true if you want the cycles reduced to single nodes.\n+   You can use ipa_get_nodes_in_cycle to obtain a vector containing all real\n+   call graph nodes in a reduced node.\n+\n+   Set ALLOW_OVERWRITABLE if nodes with such availability should be included.\n    IGNORE_EDGE, if non-NULL is a hook that may make some edges insignificant\n    for the topological sort.   */\n \n@@ -231,6 +234,23 @@ ipa_free_postorder_info (void)\n     }\n }\n \n+/* Get the set of nodes for the cycle in the reduced call graph starting\n+   from NODE.  */\n+\n+VEC (cgraph_node_p, heap) *\n+ipa_get_nodes_in_cycle (struct cgraph_node *node)\n+{\n+  VEC (cgraph_node_p, heap) *v = NULL;\n+  struct ipa_dfs_info *node_dfs_info;\n+  while (node)\n+    {\n+      VEC_safe_push (cgraph_node_p, heap, v, node);\n+      node_dfs_info = (struct ipa_dfs_info *) node->symbol.aux;\n+      node = node_dfs_info->next_cycle;\n+    }\n+  return v;\n+}\n+\n struct postorder_stack\n {\n   struct cgraph_node *node;"}, {"sha": "f95624060597a07693d79c9ea31338e8a327f013", "filename": "gcc/ipa-utils.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df92c6403cb342aac3fe8720895d979b6d677321/gcc%2Fipa-utils.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df92c6403cb342aac3fe8720895d979b6d677321/gcc%2Fipa-utils.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-utils.h?ref=df92c6403cb342aac3fe8720895d979b6d677321", "patch": "@@ -42,6 +42,7 @@ void ipa_print_order (FILE*, const char *, struct cgraph_node**, int);\n int ipa_reduced_postorder (struct cgraph_node **, bool, bool,\n \t\t\t  bool (*ignore_edge) (struct cgraph_edge *));\n void ipa_free_postorder_info (void);\n+VEC (cgraph_node_p, heap) *ipa_get_nodes_in_cycle (struct cgraph_node *);\n int ipa_reverse_postorder (struct cgraph_node **);\n tree get_base_var (tree);\n "}, {"sha": "57d531d879ca4f4d500624aa7fe49f068cd30643", "filename": "gcc/print-rtl.c", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df92c6403cb342aac3fe8720895d979b6d677321/gcc%2Fprint-rtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df92c6403cb342aac3fe8720895d979b6d677321/gcc%2Fprint-rtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fprint-rtl.c?ref=df92c6403cb342aac3fe8720895d979b6d677321", "patch": "@@ -811,11 +811,27 @@ print_rtl (FILE *outf, const_rtx rtx_first)\n int\n print_rtl_single (FILE *outf, const_rtx x)\n {\n+  return print_rtl_single_with_indent (outf, x, 0);\n+}\n+\n+/* Like print_rtl_single, except specify a file and indentation.  */\n+\n+int\n+print_rtl_single_with_indent (FILE *outf, const_rtx x, int ind)\n+{\n+  int old_indent = indent;\n+  char *s_indent = (char *) alloca ((size_t) ind + 1);\n+  memset ((void *) s_indent, ' ', (size_t) ind);\n+  s_indent[ind] = '\\0';\n+\n+  indent = ind;\n   outfile = outf;\n   sawclose = 0;\n+  fputs (s_indent, outfile);\n   fputs (print_rtx_head, outfile);\n   print_rtx (x);\n   putc ('\\n', outf);\n+  indent = old_indent;\n   return 1;\n }\n "}, {"sha": "cf52efb638912706e4faefda3232bc623ef9b903", "filename": "gcc/rtl.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df92c6403cb342aac3fe8720895d979b6d677321/gcc%2Frtl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df92c6403cb342aac3fe8720895d979b6d677321/gcc%2Frtl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtl.h?ref=df92c6403cb342aac3fe8720895d979b6d677321", "patch": "@@ -2508,6 +2508,7 @@ extern void print_mem_expr (FILE *, const_tree);\n extern void print_rtl (FILE *, const_rtx);\n extern void print_simple_rtl (FILE *, const_rtx);\n extern int print_rtl_single (FILE *, const_rtx);\n+extern int print_rtl_single_with_indent (FILE *, const_rtx, int);\n extern void print_inline_rtx (FILE *, const_rtx, int);\n \n /* In function.c */"}, {"sha": "9ce646a6af0b7dfe7e8dc6462fbdb13a801b7813", "filename": "gcc/trans-mem.c", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df92c6403cb342aac3fe8720895d979b6d677321/gcc%2Ftrans-mem.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df92c6403cb342aac3fe8720895d979b6d677321/gcc%2Ftrans-mem.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftrans-mem.c?ref=df92c6403cb342aac3fe8720895d979b6d677321", "patch": "@@ -3582,11 +3582,6 @@ struct tm_ipa_cg_data\n   bool want_irr_scan_normal;\n };\n \n-typedef struct cgraph_node *cgraph_node_p;\n-\n-DEF_VEC_P (cgraph_node_p);\n-DEF_VEC_ALLOC_P (cgraph_node_p, heap);\n-\n typedef VEC (cgraph_node_p, heap) *cgraph_node_queue;\n \n /* Return the ipa data associated with NODE, allocating zeroed memory"}, {"sha": "1a166cc4994006eb300951b884ea76ce1cd2e2d3", "filename": "gcc/tree-cfg.c", "status": "modified", "additions": 41, "deletions": 1, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df92c6403cb342aac3fe8720895d979b6d677321/gcc%2Ftree-cfg.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df92c6403cb342aac3fe8720895d979b6d677321/gcc%2Ftree-cfg.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-cfg.c?ref=df92c6403cb342aac3fe8720895d979b6d677321", "patch": "@@ -5335,6 +5335,44 @@ gimple_move_block_after (basic_block bb, basic_block after)\n }\n \n \n+/* Return TRUE if block BB has no executable statements, otherwise return\n+   FALSE.  */\n+\n+bool\n+gimple_empty_block_p (basic_block bb)\n+{\n+  /* BB must have no executable statements.  */\n+  gimple_stmt_iterator gsi = gsi_after_labels (bb);\n+  if (phi_nodes (bb))\n+    return false;\n+  if (gsi_end_p (gsi))\n+    return true;\n+  if (is_gimple_debug (gsi_stmt (gsi)))\n+    gsi_next_nondebug (&gsi);\n+  return gsi_end_p (gsi);\n+}\n+\n+\n+/* Split a basic block if it ends with a conditional branch and if the\n+   other part of the block is not empty.  */\n+\n+static basic_block\n+gimple_split_block_before_cond_jump (basic_block bb)\n+{\n+  gimple last, split_point;\n+  gimple_stmt_iterator gsi = gsi_last_nondebug_bb (bb);\n+  if (gsi_end_p (gsi))\n+    return NULL;\n+  last = gsi_stmt (gsi);\n+  if (gimple_code (last) != GIMPLE_COND\n+      && gimple_code (last) != GIMPLE_SWITCH)\n+    return NULL;\n+  gsi_prev_nondebug (&gsi);\n+  split_point = gsi_stmt (gsi);\n+  return split_block (bb, split_point)->dest;\n+}\n+\n+\n /* Return true if basic_block can be duplicated.  */\n \n static bool\n@@ -7492,7 +7530,9 @@ struct cfg_hooks gimple_cfg_hooks = {\n   gimple_lv_add_condition_to_bb, /* lv_add_condition_to_bb */\n   gimple_lv_adjust_loop_header_phi, /* lv_adjust_loop_header_phi*/\n   extract_true_false_edges_from_block, /* extract_cond_bb_edges */\n-  flush_pending_stmts\t\t/* flush_pending_stmts */\n+  flush_pending_stmts, \t\t/* flush_pending_stmts */  \n+  gimple_empty_block_p,           /* block_empty_p */\n+  gimple_split_block_before_cond_jump, /* split_block_before_cond_jump */\n };\n \n "}, {"sha": "948620fa8cdc82545453b270512ed65ca74e2ff8", "filename": "gcc/tree-ssa-phiopt.c", "status": "modified", "additions": 0, "deletions": 18, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df92c6403cb342aac3fe8720895d979b6d677321/gcc%2Ftree-ssa-phiopt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df92c6403cb342aac3fe8720895d979b6d677321/gcc%2Ftree-ssa-phiopt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-phiopt.c?ref=df92c6403cb342aac3fe8720895d979b6d677321", "patch": "@@ -519,24 +519,6 @@ blocks_in_phiopt_order (void)\n #undef VISITED_P\n }\n \n-\n-/* Return TRUE if block BB has no executable statements, otherwise return\n-   FALSE.  */\n-\n-bool\n-empty_block_p (basic_block bb)\n-{\n-  /* BB must have no executable statements.  */\n-  gimple_stmt_iterator gsi = gsi_after_labels (bb);\n-  if (phi_nodes (bb))\n-    return false;\n-  if (gsi_end_p (gsi))\n-    return true;\n-  if (is_gimple_debug (gsi_stmt (gsi)))\n-    gsi_next_nondebug (&gsi);\n-  return gsi_end_p (gsi);\n-}\n-\n /* Replace PHI node element whose edge is E in block BB with variable NEW.\n    Remove the edge from COND_BLOCK which does not lead to BB (COND_BLOCK\n    is known to have two edges, one of which must reach BB).  */"}, {"sha": "e0d911a579ed64defc652d72fb13a2314768f012", "filename": "gcc/vecir.h", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df92c6403cb342aac3fe8720895d979b6d677321/gcc%2Fvecir.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df92c6403cb342aac3fe8720895d979b6d677321/gcc%2Fvecir.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvecir.h?ref=df92c6403cb342aac3fe8720895d979b6d677321", "patch": "@@ -49,4 +49,9 @@ DEF_VEC_P(rtx);\n DEF_VEC_ALLOC_P(rtx,heap);\n DEF_VEC_ALLOC_P(rtx,gc);\n \n+/* A varray of call graph nodes.  */\n+typedef struct cgraph_node *cgraph_node_p;\n+DEF_VEC_P (cgraph_node_p);\n+DEF_VEC_ALLOC_P (cgraph_node_p, heap);\n+\n #endif /* GCC_VECIR_H */"}]}