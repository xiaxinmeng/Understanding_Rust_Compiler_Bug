{"sha": "9bb19e143cfe8863e2e79d4176b5d7e997b08c5f", "node_id": "C_kwDOANBUbNoAKDliYjE5ZTE0M2NmZTg4NjNlMmU3OWQ0MTc2YjVkN2U5OTdiMDhjNWY", "commit": {"author": {"name": "Tamar Christina", "email": "tamar.christina@arm.com", "date": "2022-08-03T15:00:39Z"}, "committer": {"name": "Tamar Christina", "email": "tamar.christina@arm.com", "date": "2022-08-03T15:00:39Z"}, "message": "middle-end: Support recognition of three-way max/min.\n\nThis patch adds support for three-way min/max recognition in phi-opts.\n\nConcretely for e.g.\n\n#include <stdint.h>\n\nuint8_t three_min (uint8_t xc, uint8_t xm, uint8_t xy) {\n\tuint8_t\t xk;\n    if (xc < xm) {\n        xk = (uint8_t) (xc < xy ? xc : xy);\n    } else {\n        xk = (uint8_t) (xm < xy ? xm : xy);\n    }\n    return xk;\n}\n\nwe generate:\n\n  <bb 2> [local count: 1073741824]:\n  _5 = MIN_EXPR <xc_1(D), xy_3(D)>;\n  _7 = MIN_EXPR <xm_2(D), _5>;\n  return _7;\n\ninstead of\n\n  <bb 2>:\n  if (xc_2(D) < xm_3(D))\n    goto <bb 3>;\n  else\n    goto <bb 4>;\n\n  <bb 3>:\n  xk_5 = MIN_EXPR <xc_2(D), xy_4(D)>;\n  goto <bb 5>;\n\n  <bb 4>:\n  xk_6 = MIN_EXPR <xm_3(D), xy_4(D)>;\n\n  <bb 5>:\n  # xk_1 = PHI <xk_5(3), xk_6(4)>\n  return xk_1;\n\nThe same function also immediately deals with turning a minimization problem\ninto a maximization one if the results are inverted.  We do this here since\ndoing it in match.pd would end up changing the shape of the BBs and adding\nadditional instructions which would prevent various optimizations from working.\n\ngcc/ChangeLog:\n\n\t* tree-ssa-phiopt.cc (minmax_replacement): Optionally search for the phi\n\tsequence of a three-way conditional.\n\t(replace_phi_edge_with_variable): Support diamonds.\n\t(tree_ssa_phiopt_worker): Detect diamond phi structure for three-way\n\tmin/max.\n\t(strip_bit_not, invert_minmax_code): New.\n\ngcc/testsuite/ChangeLog:\n\n\t* gcc.dg/tree-ssa/split-path-1.c: Disable phi-opts so we don't optimize\n\tcode away.\n\t* gcc.dg/tree-ssa/minmax-10.c: New test.\n\t* gcc.dg/tree-ssa/minmax-11.c: New test.\n\t* gcc.dg/tree-ssa/minmax-12.c: New test.\n\t* gcc.dg/tree-ssa/minmax-13.c: New test.\n\t* gcc.dg/tree-ssa/minmax-14.c: New test.\n\t* gcc.dg/tree-ssa/minmax-15.c: New test.\n\t* gcc.dg/tree-ssa/minmax-16.c: New test.\n\t* gcc.dg/tree-ssa/minmax-3.c: New test.\n\t* gcc.dg/tree-ssa/minmax-4.c: New test.\n\t* gcc.dg/tree-ssa/minmax-5.c: New test.\n\t* gcc.dg/tree-ssa/minmax-6.c: New test.\n\t* gcc.dg/tree-ssa/minmax-7.c: New test.\n\t* gcc.dg/tree-ssa/minmax-8.c: New test.\n\t* gcc.dg/tree-ssa/minmax-9.c: New test.", "tree": {"sha": "fe1317a6184004d57927af006a7ea324529157e3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/fe1317a6184004d57927af006a7ea324529157e3"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/9bb19e143cfe8863e2e79d4176b5d7e997b08c5f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9bb19e143cfe8863e2e79d4176b5d7e997b08c5f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9bb19e143cfe8863e2e79d4176b5d7e997b08c5f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9bb19e143cfe8863e2e79d4176b5d7e997b08c5f/comments", "author": {"login": "TamarChristinaArm", "id": 48126768, "node_id": "MDQ6VXNlcjQ4MTI2NzY4", "avatar_url": "https://avatars.githubusercontent.com/u/48126768?v=4", "gravatar_id": "", "url": "https://api.github.com/users/TamarChristinaArm", "html_url": "https://github.com/TamarChristinaArm", "followers_url": "https://api.github.com/users/TamarChristinaArm/followers", "following_url": "https://api.github.com/users/TamarChristinaArm/following{/other_user}", "gists_url": "https://api.github.com/users/TamarChristinaArm/gists{/gist_id}", "starred_url": "https://api.github.com/users/TamarChristinaArm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/TamarChristinaArm/subscriptions", "organizations_url": "https://api.github.com/users/TamarChristinaArm/orgs", "repos_url": "https://api.github.com/users/TamarChristinaArm/repos", "events_url": "https://api.github.com/users/TamarChristinaArm/events{/privacy}", "received_events_url": "https://api.github.com/users/TamarChristinaArm/received_events", "type": "User", "site_admin": false}, "committer": {"login": "TamarChristinaArm", "id": 48126768, "node_id": "MDQ6VXNlcjQ4MTI2NzY4", "avatar_url": "https://avatars.githubusercontent.com/u/48126768?v=4", "gravatar_id": "", "url": "https://api.github.com/users/TamarChristinaArm", "html_url": "https://github.com/TamarChristinaArm", "followers_url": "https://api.github.com/users/TamarChristinaArm/followers", "following_url": "https://api.github.com/users/TamarChristinaArm/following{/other_user}", "gists_url": "https://api.github.com/users/TamarChristinaArm/gists{/gist_id}", "starred_url": "https://api.github.com/users/TamarChristinaArm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/TamarChristinaArm/subscriptions", "organizations_url": "https://api.github.com/users/TamarChristinaArm/orgs", "repos_url": "https://api.github.com/users/TamarChristinaArm/repos", "events_url": "https://api.github.com/users/TamarChristinaArm/events{/privacy}", "received_events_url": "https://api.github.com/users/TamarChristinaArm/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b6df113247b9f3f7c3db0e65c481dad5bcfddfb4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b6df113247b9f3f7c3db0e65c481dad5bcfddfb4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b6df113247b9f3f7c3db0e65c481dad5bcfddfb4"}], "stats": {"total": 525, "additions": 505, "deletions": 20}, "files": [{"sha": "589953684416a9d263084deb58f6cde7094dd517", "filename": "gcc/testsuite/gcc.dg/tree-ssa/minmax-10.c", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9bb19e143cfe8863e2e79d4176b5d7e997b08c5f/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fminmax-10.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9bb19e143cfe8863e2e79d4176b5d7e997b08c5f/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fminmax-10.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fminmax-10.c?ref=9bb19e143cfe8863e2e79d4176b5d7e997b08c5f", "patch": "@@ -0,0 +1,20 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O -fdump-tree-optimized\" } */\n+\n+#include <stdint.h>\n+\n+uint8_t three_max (uint8_t xc, uint8_t xm, uint8_t xy) {\n+    uint8_t\t xk;\n+    xc=~xc;\n+    xm=~xm;\n+    xy=~xy;\n+    if (xc > xm) {\n+        xk = (uint8_t) (xc > xy ? xc : xy);\n+    } else {\n+        xk = (uint8_t) (xm > xy ? xm : xy);\n+    }\n+    return xk;\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"MIN_EXPR\" 2 \"optimized\" } } */\n+/* { dg-final { scan-tree-dump-times \"= ~\" 1 \"optimized\" } } */"}, {"sha": "1c2ef01b5d1e639fbf95bb5ca473b63cc98e9df1", "filename": "gcc/testsuite/gcc.dg/tree-ssa/minmax-11.c", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9bb19e143cfe8863e2e79d4176b5d7e997b08c5f/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fminmax-11.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9bb19e143cfe8863e2e79d4176b5d7e997b08c5f/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fminmax-11.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fminmax-11.c?ref=9bb19e143cfe8863e2e79d4176b5d7e997b08c5f", "patch": "@@ -0,0 +1,21 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O -fdump-tree-optimized\" } */\n+\n+#include <stdint.h>\n+\n+uint8_t three_minmax1 (uint8_t xc, uint8_t xm, uint8_t xy) {\n+\tuint8_t\t xk;\n+    xc=~xc;\n+    xm=~xm;\n+    xy=~xy;\n+    if (xc > xm) {\n+        xk = (uint8_t) (xc < xy ? xc : xy);\n+    } else {\n+        xk = (uint8_t) (xm < xy ? xm : xy);\n+    }\n+    return xk;\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"MIN_EXPR\" 1 \"optimized\" } } */\n+/* { dg-final { scan-tree-dump-times \"MAX_EXPR\" 1 \"optimized\" } } */\n+/* { dg-final { scan-tree-dump-times \"= ~\" 1 \"optimized\" } } */"}, {"sha": "3d0c07d9b57dd689bcb89653937727ab441e7f2b", "filename": "gcc/testsuite/gcc.dg/tree-ssa/minmax-12.c", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9bb19e143cfe8863e2e79d4176b5d7e997b08c5f/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fminmax-12.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9bb19e143cfe8863e2e79d4176b5d7e997b08c5f/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fminmax-12.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fminmax-12.c?ref=9bb19e143cfe8863e2e79d4176b5d7e997b08c5f", "patch": "@@ -0,0 +1,20 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O -fdump-tree-phiopt\" } */\n+\n+#include <stdint.h>\n+\n+uint8_t three_minmax3 (uint8_t xc, uint8_t xm, uint8_t xy) {\n+        uint8_t  xk;\n+    xc=~xc;\n+    xm=~xm;\n+    xy=~xy;\n+    if (xc > xm) {\n+        xk = (uint8_t) (xy < xc ? xc : xy);\n+    } else {\n+        xk = (uint8_t) (xm < xy ? xm : xy);\n+    }\n+    return xk;\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"MIN_EXPR\" 1 \"phiopt1\" } } */\n+/* { dg-final { scan-tree-dump-times \"MAX_EXPR\" 1 \"phiopt1\" } } */"}, {"sha": "c0d0f27c8027ae87654532d1b919cfeccf4413e0", "filename": "gcc/testsuite/gcc.dg/tree-ssa/minmax-13.c", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9bb19e143cfe8863e2e79d4176b5d7e997b08c5f/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fminmax-13.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9bb19e143cfe8863e2e79d4176b5d7e997b08c5f/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fminmax-13.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fminmax-13.c?ref=9bb19e143cfe8863e2e79d4176b5d7e997b08c5f", "patch": "@@ -0,0 +1,19 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O -fdump-tree-phiopt\" } */\n+\n+#include <stdint.h>\n+\n+uint8_t three_minmax2 (uint8_t xc, uint8_t xm, uint8_t xy) {\n+\tuint8_t\t xk;\n+    xc=~xc;\n+    xm=~xm;\n+    xy=~xy;\n+    if (xc > xm) {\n+        xk = (uint8_t) (xc > xy ? xc : xy);\n+    } else {\n+        xk = (uint8_t) (xm < xy ? xm : xy);\n+    }\n+    return xk;\n+}\n+/* { dg-final { scan-tree-dump-times \"MIN_EXPR\" 1 \"phiopt1\" } } */\n+/* { dg-final { scan-tree-dump-times \"MAX_EXPR\" 1 \"phiopt1\" } } */"}, {"sha": "9c0cadbf7e3119527cb2007d01fe4c7dd772c069", "filename": "gcc/testsuite/gcc.dg/tree-ssa/minmax-14.c", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9bb19e143cfe8863e2e79d4176b5d7e997b08c5f/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fminmax-14.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9bb19e143cfe8863e2e79d4176b5d7e997b08c5f/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fminmax-14.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fminmax-14.c?ref=9bb19e143cfe8863e2e79d4176b5d7e997b08c5f", "patch": "@@ -0,0 +1,21 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O -fdump-tree-optimized\" } */\n+\n+#include <stdint.h>\n+\n+uint8_t three_minmax11 (uint8_t xc, uint8_t xm, uint8_t xy) {\n+        uint8_t  xk;\n+    xc=~xc;\n+    xm=~xm;\n+    xy=~xy;\n+    if (xc < xm) {\n+        xk = (uint8_t) (xc > xy ? xc : xy);\n+    } else {\n+        xk = (uint8_t) (xm > xy ? xm : xy);\n+    }\n+    return xk;\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"MIN_EXPR\" 1 \"optimized\" } } */\n+/* { dg-final { scan-tree-dump-times \"MAX_EXPR\" 1 \"optimized\" } } */\n+/* { dg-final { scan-tree-dump-times \"= ~\" 1 \"optimized\" } } */"}, {"sha": "1d97a16564f069b4348ff325c4fd713a224f838a", "filename": "gcc/testsuite/gcc.dg/tree-ssa/minmax-15.c", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9bb19e143cfe8863e2e79d4176b5d7e997b08c5f/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fminmax-15.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9bb19e143cfe8863e2e79d4176b5d7e997b08c5f/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fminmax-15.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fminmax-15.c?ref=9bb19e143cfe8863e2e79d4176b5d7e997b08c5f", "patch": "@@ -0,0 +1,21 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O -fdump-tree-phiopt\" } */\n+\n+#include <stdint.h>\n+#include <stdbool.h>\n+\n+uint8_t three_min (uint8_t xc, uint8_t xm, uint8_t xy, bool m) {\n+    uint8_t  xk;\n+    if (xc)\n+      {\n+        if (xc < xm) {\n+            xk = (uint8_t) (xc < xy ? xc : xy);\n+        } else {\n+            xk = (uint8_t) (xm < xy ? xm : xy);\n+        }\n+      }\n+\n+    return xk;\n+}\n+/* { dg-final { scan-tree-dump-times \"MIN_EXPR\" 3 \"phiopt1\" } } */\n+/* { dg-final { scan-tree-dump-times \"MAX_EXPR\" 0 \"phiopt1\" } } */"}, {"sha": "89377a2cb341bdafa6ba145c61c1f966af536839", "filename": "gcc/testsuite/gcc.dg/tree-ssa/minmax-16.c", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9bb19e143cfe8863e2e79d4176b5d7e997b08c5f/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fminmax-16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9bb19e143cfe8863e2e79d4176b5d7e997b08c5f/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fminmax-16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fminmax-16.c?ref=9bb19e143cfe8863e2e79d4176b5d7e997b08c5f", "patch": "@@ -0,0 +1,17 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O -fdump-tree-phiopt -g\" } */\n+\n+#include <stdint.h>\n+\n+uint8_t three_min (uint8_t xc, uint8_t xm, uint8_t xy) {\n+\tuint8_t\t xk;\n+    if (xc < xm) {\n+        xk = (uint8_t) (xc < xy ? xc : xy);\n+    } else {\n+        xk = (uint8_t) (xm < xy ? xm : xy);\n+    }\n+    return xk;\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"MIN_EXPR\" 3 \"phiopt1\" } } */\n+/* { dg-final { scan-tree-dump-times \"MAX_EXPR\" 0 \"phiopt1\" } } */"}, {"sha": "de3b2e946e81701e3b75f580e6a843695a05786e", "filename": "gcc/testsuite/gcc.dg/tree-ssa/minmax-3.c", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9bb19e143cfe8863e2e79d4176b5d7e997b08c5f/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fminmax-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9bb19e143cfe8863e2e79d4176b5d7e997b08c5f/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fminmax-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fminmax-3.c?ref=9bb19e143cfe8863e2e79d4176b5d7e997b08c5f", "patch": "@@ -0,0 +1,17 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O -fdump-tree-phiopt\" } */\n+\n+#include <stdint.h>\n+\n+uint8_t three_min (uint8_t xc, uint8_t xm, uint8_t xy) {\n+\tuint8_t\t xk;\n+    if (xc < xm) {\n+        xk = (uint8_t) (xc < xy ? xc : xy);\n+    } else {\n+        xk = (uint8_t) (xm < xy ? xm : xy);\n+    }\n+    return xk;\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"MIN_EXPR\" 3 \"phiopt1\" } } */\n+/* { dg-final { scan-tree-dump-times \"MAX_EXPR\" 0 \"phiopt1\" } } */"}, {"sha": "0b6d667be868c2405eaefd17cb522da44bafa0e2", "filename": "gcc/testsuite/gcc.dg/tree-ssa/minmax-4.c", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9bb19e143cfe8863e2e79d4176b5d7e997b08c5f/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fminmax-4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9bb19e143cfe8863e2e79d4176b5d7e997b08c5f/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fminmax-4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fminmax-4.c?ref=9bb19e143cfe8863e2e79d4176b5d7e997b08c5f", "patch": "@@ -0,0 +1,17 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O -fdump-tree-phiopt\" } */\n+\n+#include <stdint.h>\n+\n+uint8_t three_max (uint8_t xc, uint8_t xm, uint8_t xy) {\n+    uint8_t\t xk;\n+    if (xc > xm) {\n+        xk = (uint8_t) (xc > xy ? xc : xy);\n+    } else {\n+        xk = (uint8_t) (xm > xy ? xm : xy);\n+    }\n+    return xk;\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"MIN_EXPR\" 0 \"phiopt1\" } } */\n+/* { dg-final { scan-tree-dump-times \"MAX_EXPR\" 3 \"phiopt1\" } } */"}, {"sha": "650601a3cc75d09a9e6e54a35f5b9993074f8510", "filename": "gcc/testsuite/gcc.dg/tree-ssa/minmax-5.c", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9bb19e143cfe8863e2e79d4176b5d7e997b08c5f/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fminmax-5.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9bb19e143cfe8863e2e79d4176b5d7e997b08c5f/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fminmax-5.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fminmax-5.c?ref=9bb19e143cfe8863e2e79d4176b5d7e997b08c5f", "patch": "@@ -0,0 +1,17 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O -fdump-tree-phiopt\" } */\n+\n+#include <stdint.h>\n+\n+uint8_t three_minmax1 (uint8_t xc, uint8_t xm, uint8_t xy) {\n+\tuint8_t\t xk;\n+    if (xc > xm) {\n+        xk = (uint8_t) (xc < xy ? xc : xy);\n+    } else {\n+        xk = (uint8_t) (xm < xy ? xm : xy);\n+    }\n+    return xk;\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"MIN_EXPR\" 2 \"phiopt1\" } } */\n+/* { dg-final { scan-tree-dump-times \"MAX_EXPR\" 1 \"phiopt1\" } } */"}, {"sha": "a628f6d99222958cfd8c410f0e85639e3a49dd4b", "filename": "gcc/testsuite/gcc.dg/tree-ssa/minmax-6.c", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9bb19e143cfe8863e2e79d4176b5d7e997b08c5f/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fminmax-6.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9bb19e143cfe8863e2e79d4176b5d7e997b08c5f/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fminmax-6.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fminmax-6.c?ref=9bb19e143cfe8863e2e79d4176b5d7e997b08c5f", "patch": "@@ -0,0 +1,17 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O -fdump-tree-phiopt\" } */\n+\n+#include <stdint.h>\n+\n+uint8_t three_minmax3 (uint8_t xc, uint8_t xm, uint8_t xy) {\n+        uint8_t  xk;\n+    if (xc > xm) {\n+        xk = (uint8_t) (xy < xc ? xc : xy);\n+    } else {\n+        xk = (uint8_t) (xm < xy ? xm : xy);\n+    }\n+    return xk;\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"MIN_EXPR\" 1 \"phiopt1\" } } */\n+/* { dg-final { scan-tree-dump-times \"MAX_EXPR\" 1 \"phiopt1\" } } */"}, {"sha": "cb42412c4ada433b2f59df0a8bef9fa7b1c5e104", "filename": "gcc/testsuite/gcc.dg/tree-ssa/minmax-7.c", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9bb19e143cfe8863e2e79d4176b5d7e997b08c5f/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fminmax-7.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9bb19e143cfe8863e2e79d4176b5d7e997b08c5f/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fminmax-7.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fminmax-7.c?ref=9bb19e143cfe8863e2e79d4176b5d7e997b08c5f", "patch": "@@ -0,0 +1,16 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O -fdump-tree-phiopt\" } */\n+\n+#include <stdint.h>\n+\n+uint8_t three_minmax2 (uint8_t xc, uint8_t xm, uint8_t xy) {\n+\tuint8_t\t xk;\n+    if (xc > xm) {\n+        xk = (uint8_t) (xc > xy ? xc : xy);\n+    } else {\n+        xk = (uint8_t) (xm < xy ? xm : xy);\n+    }\n+    return xk;\n+}\n+/* { dg-final { scan-tree-dump-times \"MIN_EXPR\" 1 \"phiopt1\" } } */\n+/* { dg-final { scan-tree-dump-times \"MAX_EXPR\" 1 \"phiopt1\" } } */"}, {"sha": "9cd050e932376bc50bd6ae60cb654fcab0bfdd1c", "filename": "gcc/testsuite/gcc.dg/tree-ssa/minmax-8.c", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9bb19e143cfe8863e2e79d4176b5d7e997b08c5f/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fminmax-8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9bb19e143cfe8863e2e79d4176b5d7e997b08c5f/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fminmax-8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fminmax-8.c?ref=9bb19e143cfe8863e2e79d4176b5d7e997b08c5f", "patch": "@@ -0,0 +1,17 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O -fdump-tree-phiopt\" } */\n+\n+#include <stdint.h>\n+\n+uint8_t three_minmax11 (uint8_t xc, uint8_t xm, uint8_t xy) {\n+        uint8_t  xk;\n+    if (xc < xm) {\n+        xk = (uint8_t) (xc > xy ? xc : xy);\n+    } else {\n+        xk = (uint8_t) (xm > xy ? xm : xy);\n+    }\n+    return xk;\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"MIN_EXPR\" 1 \"phiopt1\" } } */\n+/* { dg-final { scan-tree-dump-times \"MAX_EXPR\" 2 \"phiopt1\" } } */"}, {"sha": "24f580271c3ac3945860b506d4dc7d178a826093", "filename": "gcc/testsuite/gcc.dg/tree-ssa/minmax-9.c", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9bb19e143cfe8863e2e79d4176b5d7e997b08c5f/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fminmax-9.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9bb19e143cfe8863e2e79d4176b5d7e997b08c5f/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fminmax-9.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fminmax-9.c?ref=9bb19e143cfe8863e2e79d4176b5d7e997b08c5f", "patch": "@@ -0,0 +1,20 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O -fdump-tree-optimized\" } */\n+\n+#include <stdint.h>\n+\n+uint8_t three_min (uint8_t xc, uint8_t xm, uint8_t xy) {\n+\tuint8_t\t xk;\n+    xc=~xc;\n+    xm=~xm;\n+    xy=~xy;\n+    if (xc < xm) {\n+        xk = (uint8_t) (xc < xy ? xc : xy);\n+    } else {\n+        xk = (uint8_t) (xm < xy ? xm : xy);\n+    }\n+    return xk;\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"= ~\" 1 \"optimized\" } } */\n+/* { dg-final { scan-tree-dump-times \"MAX_EXPR\" 2 \"optimized\" } } */"}, {"sha": "902dde44a50e171b4f34ba7247d75a32d2c860ed", "filename": "gcc/testsuite/gcc.dg/tree-ssa/split-path-1.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9bb19e143cfe8863e2e79d4176b5d7e997b08c5f/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fsplit-path-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9bb19e143cfe8863e2e79d4176b5d7e997b08c5f/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fsplit-path-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fsplit-path-1.c?ref=9bb19e143cfe8863e2e79d4176b5d7e997b08c5f", "patch": "@@ -1,5 +1,5 @@\n /* { dg-do run } */\n-/* { dg-options \"-O2 -fsplit-paths -fdump-tree-split-paths-details --param max-jump-thread-duplication-stmts=20\" } */\n+/* { dg-options \"-O2 -fsplit-paths -fdump-tree-split-paths-details --param max-jump-thread-duplication-stmts=20 -fno-ssa-phiopt\" } */\n \n #include <stdio.h>\n #include <stdlib.h>"}, {"sha": "a8e55e040649e17f83a2fc3340e368cf9c4c5e70", "filename": "gcc/tree-ssa-phiopt.cc", "status": "modified", "additions": 244, "deletions": 19, "changes": 263, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9bb19e143cfe8863e2e79d4176b5d7e997b08c5f/gcc%2Ftree-ssa-phiopt.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9bb19e143cfe8863e2e79d4176b5d7e997b08c5f/gcc%2Ftree-ssa-phiopt.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-phiopt.cc?ref=9bb19e143cfe8863e2e79d4176b5d7e997b08c5f", "patch": "@@ -63,8 +63,8 @@ static gphi *factor_out_conditional_conversion (edge, edge, gphi *, tree, tree,\n \t\t\t\t\t\tgimple *);\n static int value_replacement (basic_block, basic_block,\n \t\t\t      edge, edge, gphi *, tree, tree);\n-static bool minmax_replacement (basic_block, basic_block,\n-\t\t\t\tedge, edge, gphi *, tree, tree);\n+static bool minmax_replacement (basic_block, basic_block, basic_block,\n+\t\t\t\tedge, edge, gphi *, tree, tree, bool);\n static bool spaceship_replacement (basic_block, basic_block,\n \t\t\t\t   edge, edge, gphi *, tree, tree);\n static bool cond_removal_in_builtin_zero_pattern (basic_block, basic_block,\n@@ -200,6 +200,7 @@ tree_ssa_phiopt_worker (bool do_store_elim, bool do_hoist_loads, bool early_p)\n       basic_block bb1, bb2;\n       edge e1, e2;\n       tree arg0, arg1;\n+      bool diamond_p = false;\n \n       bb = bb_order[i];\n \n@@ -266,6 +267,9 @@ tree_ssa_phiopt_worker (bool do_store_elim, bool do_hoist_loads, bool early_p)\n \t    hoist_adjacent_loads (bb, bb1, bb2, bb3);\n \t  continue;\n \t}\n+      else if (EDGE_SUCC (bb1, 0)->dest == EDGE_SUCC (bb2, 0)->dest\n+\t       && !empty_block_p (bb1))\n+\tdiamond_p = true;\n       else\n \tcontinue;\n \n@@ -294,10 +298,13 @@ tree_ssa_phiopt_worker (bool do_store_elim, bool do_hoist_loads, bool early_p)\n \t}\n       else\n \t{\n-\t  gimple_seq phis = phi_nodes (bb2);\n \t  gimple_stmt_iterator gsi;\n \t  bool candorest = true;\n \n+\t  /* Check that we're looking for nested phis.  */\n+\t  basic_block merge = diamond_p ? EDGE_SUCC (bb2, 0)->dest : bb2;\n+\t  gimple_seq phis = phi_nodes (merge);\n+\n \t  /* Value replacement can work with more than one PHI\n \t     so try that first. */\n \t  if (!early_p)\n@@ -317,6 +324,7 @@ tree_ssa_phiopt_worker (bool do_store_elim, bool do_hoist_loads, bool early_p)\n \t  if (!candorest)\n \t    continue;\n \n+\t  e2 = diamond_p ? EDGE_SUCC (bb2, 0) : e2;\n \t  phi = single_non_singleton_phi_for_edges (phis, e1, e2);\n \t  if (!phi)\n \t    continue;\n@@ -330,6 +338,7 @@ tree_ssa_phiopt_worker (bool do_store_elim, bool do_hoist_loads, bool early_p)\n \n \t  gphi *newphi;\n \t  if (single_pred_p (bb1)\n+\t      && !diamond_p\n \t      && (newphi = factor_out_conditional_conversion (e1, e2, phi,\n \t\t\t\t\t\t\t      arg0, arg1,\n \t\t\t\t\t\t\t      cond_stmt)))\n@@ -344,20 +353,25 @@ tree_ssa_phiopt_worker (bool do_store_elim, bool do_hoist_loads, bool early_p)\n \t    }\n \n \t  /* Do the replacement of conditional if it can be done.  */\n-\t  if (!early_p && two_value_replacement (bb, bb1, e2, phi, arg0, arg1))\n+\t  if (!early_p\n+\t      && !diamond_p\n+\t      && two_value_replacement (bb, bb1, e2, phi, arg0, arg1))\n \t    cfgchanged = true;\n-\t  else if (match_simplify_replacement (bb, bb1, e1, e2, phi,\n-\t\t\t\t\t       arg0, arg1,\n-\t\t\t\t\t       early_p))\n+\t  else if (!diamond_p\n+\t\t   && match_simplify_replacement (bb, bb1, e1, e2, phi,\n+\t\t\t\t\t\t  arg0, arg1, early_p))\n \t    cfgchanged = true;\n \t  else if (!early_p\n+\t\t   && !diamond_p\n \t\t   && single_pred_p (bb1)\n \t\t   && cond_removal_in_builtin_zero_pattern (bb, bb1, e1, e2,\n \t\t\t\t\t\t\t    phi, arg0, arg1))\n \t    cfgchanged = true;\n-\t  else if (minmax_replacement (bb, bb1, e1, e2, phi, arg0, arg1))\n+\t  else if (minmax_replacement (bb, bb1, bb2, e1, e2, phi, arg0, arg1,\n+\t\t\t\t       diamond_p))\n \t    cfgchanged = true;\n \t  else if (single_pred_p (bb1)\n+\t\t   && !diamond_p\n \t\t   && spaceship_replacement (bb, bb1, e1, e2, phi, arg0, arg1))\n \t    cfgchanged = true;\n \t}\n@@ -422,12 +436,23 @@ replace_phi_edge_with_variable (basic_block cond_block,\n   SET_USE (PHI_ARG_DEF_PTR (phi, e->dest_idx), new_tree);\n \n   /* Remove the empty basic block.  */\n-  edge edge_to_remove;\n+  edge edge_to_remove = NULL, keep_edge = NULL;\n   if (EDGE_SUCC (cond_block, 0)->dest == bb)\n-    edge_to_remove = EDGE_SUCC (cond_block, 1);\n+    {\n+      edge_to_remove = EDGE_SUCC (cond_block, 1);\n+      keep_edge = EDGE_SUCC (cond_block, 0);\n+    }\n+  else if (EDGE_SUCC (cond_block, 1)->dest == bb)\n+    {\n+      edge_to_remove = EDGE_SUCC (cond_block, 0);\n+      keep_edge = EDGE_SUCC (cond_block, 1);\n+    }\n+  else if ((keep_edge = find_edge (cond_block, e->src)))\n+    ;\n   else\n-    edge_to_remove = EDGE_SUCC (cond_block, 0);\n-  if (EDGE_COUNT (edge_to_remove->dest->preds) == 1)\n+    gcc_unreachable ();\n+\n+  if (edge_to_remove && EDGE_COUNT (edge_to_remove->dest->preds) == 1)\n     {\n       e->flags |= EDGE_FALLTHRU;\n       e->flags &= ~(EDGE_TRUE_VALUE | EDGE_FALSE_VALUE);\n@@ -444,9 +469,9 @@ replace_phi_edge_with_variable (basic_block cond_block,\n \t CFG cleanup deal with the edge removal to avoid\n \t updating dominators here in a non-trivial way.  */\n       gcond *cond = as_a <gcond *> (last_stmt (cond_block));\n-      if (edge_to_remove->flags & EDGE_TRUE_VALUE)\n+      if (keep_edge->flags & EDGE_FALSE_VALUE)\n \tgimple_cond_make_false (cond);\n-      else\n+      else if (keep_edge->flags & EDGE_TRUE_VALUE)\n \tgimple_cond_make_true (cond);\n     }\n \n@@ -1733,15 +1758,52 @@ value_replacement (basic_block cond_bb, basic_block middle_bb,\n   return 0;\n }\n \n+/* If VAR is an SSA_NAME that points to a BIT_NOT_EXPR then return the TREE for\n+   the value being inverted.  */\n+\n+static tree\n+strip_bit_not (tree var)\n+{\n+  if (TREE_CODE (var) != SSA_NAME)\n+    return NULL_TREE;\n+\n+  gimple *assign = SSA_NAME_DEF_STMT (var);\n+  if (gimple_code (assign) != GIMPLE_ASSIGN)\n+    return NULL_TREE;\n+\n+  if (gimple_assign_rhs_code (assign) != BIT_NOT_EXPR)\n+    return NULL_TREE;\n+\n+  return gimple_assign_rhs1 (assign);\n+}\n+\n+/* Invert a MIN to a MAX or a MAX to a MIN expression CODE.  */\n+\n+enum tree_code\n+invert_minmax_code (enum tree_code code)\n+{\n+  switch (code) {\n+  case MIN_EXPR:\n+    return MAX_EXPR;\n+  case MAX_EXPR:\n+    return MIN_EXPR;\n+  default:\n+    gcc_unreachable ();\n+  }\n+}\n+\n /*  The function minmax_replacement does the main work of doing the minmax\n     replacement.  Return true if the replacement is done.  Otherwise return\n     false.\n     BB is the basic block where the replacement is going to be done on.  ARG0\n-    is argument 0 from the PHI.  Likewise for ARG1.  */\n+    is argument 0 from the PHI.  Likewise for ARG1.\n+\n+    If THREEWAY_P then expect the BB to be laid out in diamond shape with each\n+    BB containing only a MIN or MAX expression.  */\n \n static bool\n-minmax_replacement (basic_block cond_bb, basic_block middle_bb,\n-\t\t    edge e0, edge e1, gphi *phi, tree arg0, tree arg1)\n+minmax_replacement (basic_block cond_bb, basic_block middle_bb, basic_block alt_middle_bb,\n+\t\t    edge e0, edge e1, gphi *phi, tree arg0, tree arg1, bool threeway_p)\n {\n   tree result;\n   edge true_edge, false_edge;\n@@ -1896,16 +1958,20 @@ minmax_replacement (basic_block cond_bb, basic_block middle_bb,\n   if (false_edge->dest == middle_bb)\n     false_edge = EDGE_SUCC (false_edge->dest, 0);\n \n+  /* When THREEWAY_P then e1 will point to the edge of the final transition\n+     from middle-bb to end.  */\n   if (true_edge == e0)\n     {\n-      gcc_assert (false_edge == e1);\n+      if (!threeway_p)\n+\tgcc_assert (false_edge == e1);\n       arg_true = arg0;\n       arg_false = arg1;\n     }\n   else\n     {\n       gcc_assert (false_edge == e0);\n-      gcc_assert (true_edge == e1);\n+      if (!threeway_p)\n+\tgcc_assert (true_edge == e1);\n       arg_true = arg1;\n       arg_false = arg0;\n     }\n@@ -1937,6 +2003,165 @@ minmax_replacement (basic_block cond_bb, basic_block middle_bb,\n       else\n \treturn false;\n     }\n+  else if (middle_bb != alt_middle_bb && threeway_p)\n+    {\n+      /* Recognize the following case:\n+\n+\t if (smaller < larger)\n+\t   a = MIN (smaller, c);\n+\t else\n+\t   b = MIN (larger, c);\n+\t x = PHI <a, b>\n+\n+\t This is equivalent to\n+\n+\t a = MIN (smaller, c);\n+\t x = MIN (larger, a);  */\n+\n+      gimple *assign = last_and_only_stmt (middle_bb);\n+      tree lhs, op0, op1, bound;\n+      tree alt_lhs, alt_op0, alt_op1;\n+      bool invert = false;\n+\n+      if (!single_pred_p (middle_bb)\n+\t  || !single_pred_p (alt_middle_bb)\n+\t  || !single_succ_p (middle_bb)\n+\t  || !single_succ_p (alt_middle_bb))\n+\treturn false;\n+\n+      /* When THREEWAY_P then e1 will point to the edge of the final transition\n+\t from middle-bb to end.  */\n+      if (true_edge == e0)\n+\tgcc_assert (false_edge == EDGE_PRED (e1->src, 0));\n+      else\n+\tgcc_assert (true_edge == EDGE_PRED (e1->src, 0));\n+\n+      bool valid_minmax_p = false;\n+      gimple_stmt_iterator it1\n+\t= gsi_start_nondebug_after_labels_bb (middle_bb);\n+      gimple_stmt_iterator it2\n+\t= gsi_start_nondebug_after_labels_bb (alt_middle_bb);\n+      if (gsi_one_nondebug_before_end_p (it1)\n+\t  && gsi_one_nondebug_before_end_p (it2))\n+\t{\n+\t  gimple *stmt1 = gsi_stmt (it1);\n+\t  gimple *stmt2 = gsi_stmt (it2);\n+\t  if (is_gimple_assign (stmt1) && is_gimple_assign (stmt2))\n+\t    {\n+\t      enum tree_code code1 = gimple_assign_rhs_code (stmt1);\n+\t      enum tree_code code2 = gimple_assign_rhs_code (stmt2);\n+\t      valid_minmax_p = (code1 == MIN_EXPR || code1 == MAX_EXPR)\n+\t\t\t       && (code2 == MIN_EXPR || code2 == MAX_EXPR);\n+\t    }\n+\t}\n+\n+      if (!valid_minmax_p)\n+\treturn false;\n+\n+      if (!assign\n+\t  || gimple_code (assign) != GIMPLE_ASSIGN)\n+\treturn false;\n+\n+      lhs = gimple_assign_lhs (assign);\n+      ass_code = gimple_assign_rhs_code (assign);\n+      if (ass_code != MAX_EXPR && ass_code != MIN_EXPR)\n+\treturn false;\n+\n+      op0 = gimple_assign_rhs1 (assign);\n+      op1 = gimple_assign_rhs2 (assign);\n+\n+      assign = last_and_only_stmt (alt_middle_bb);\n+      if (!assign\n+\t  || gimple_code (assign) != GIMPLE_ASSIGN)\n+\treturn false;\n+\n+      alt_lhs = gimple_assign_lhs (assign);\n+      if (ass_code != gimple_assign_rhs_code (assign))\n+\treturn false;\n+\n+      if (!operand_equal_for_phi_arg_p (lhs, arg_true)\n+\t || !operand_equal_for_phi_arg_p (alt_lhs, arg_false))\n+\treturn false;\n+\n+      alt_op0 = gimple_assign_rhs1 (assign);\n+      alt_op1 = gimple_assign_rhs2 (assign);\n+\n+      if ((operand_equal_for_phi_arg_p (op0, smaller)\n+\t\t|| (alt_smaller\n+\t\t    && operand_equal_for_phi_arg_p (op0, alt_smaller)))\n+\t       && (operand_equal_for_phi_arg_p (alt_op0, larger)\n+\t\t   || (alt_larger\n+\t\t       && operand_equal_for_phi_arg_p (alt_op0, alt_larger))))\n+\t{\n+\t  /* We got here if the condition is true, i.e., SMALLER < LARGER.  */\n+\t  if (!operand_equal_for_phi_arg_p (op1, alt_op1))\n+\t    return false;\n+\n+\t  if ((arg0 = strip_bit_not (op0)) != NULL\n+\t      && (arg1 = strip_bit_not (alt_op0)) != NULL\n+\t      && (bound = strip_bit_not (op1)) != NULL)\n+\t    {\n+\t      minmax = MAX_EXPR;\n+\t      ass_code = invert_minmax_code (ass_code);\n+\t      invert = true;\n+\t    }\n+\t  else\n+\t    {\n+\t      bound = op1;\n+\t      minmax = MIN_EXPR;\n+\t      arg0 = op0;\n+\t      arg1 = alt_op0;\n+\t     }\n+\t}\n+      else if ((operand_equal_for_phi_arg_p (op0, larger)\n+\t\t|| (alt_larger\n+\t\t    && operand_equal_for_phi_arg_p (op0, alt_larger)))\n+\t       && (operand_equal_for_phi_arg_p (alt_op0, smaller)\n+\t\t   || (alt_smaller\n+\t\t       && operand_equal_for_phi_arg_p (alt_op0, alt_smaller))))\n+\t{\n+\t  /* We got here if the condition is true, i.e., SMALLER > LARGER.  */\n+\t  if (!operand_equal_for_phi_arg_p (op1, alt_op1))\n+\t    return false;\n+\n+\t  if ((arg0 = strip_bit_not (op0)) != NULL\n+\t      && (arg1 = strip_bit_not (alt_op0)) != NULL\n+\t      && (bound = strip_bit_not (op1)) != NULL)\n+\t    {\n+\t      minmax = MIN_EXPR;\n+\t      ass_code = invert_minmax_code (ass_code);\n+\t      invert = true;\n+\t    }\n+\t  else\n+\t    {\n+\t      bound = op1;\n+\t      minmax = MAX_EXPR;\n+\t      arg0 = op0;\n+\t      arg1 = alt_op0;\n+\t     }\n+\t}\n+      else\n+\treturn false;\n+\n+      /* Emit the statement to compute min/max.  */\n+      location_t locus = gimple_location (last_stmt (cond_bb));\n+      gimple_seq stmts = NULL;\n+      tree phi_result = PHI_RESULT (phi);\n+      result = gimple_build (&stmts, locus, minmax, TREE_TYPE (phi_result),\n+\t\t\t     arg0, bound);\n+      result = gimple_build (&stmts, locus, ass_code, TREE_TYPE (phi_result),\n+\t\t\t     result, arg1);\n+      if (invert)\n+\tresult = gimple_build (&stmts, locus, BIT_NOT_EXPR, TREE_TYPE (phi_result),\n+\t\t\t       result);\n+\n+      gsi = gsi_last_bb (cond_bb);\n+      gsi_insert_seq_before (&gsi, stmts, GSI_NEW_STMT);\n+\n+      replace_phi_edge_with_variable (cond_bb, e1, phi, result);\n+\n+      return true;\n+    }\n   else\n     {\n       /* Recognize the following case, assuming d <= u:"}]}