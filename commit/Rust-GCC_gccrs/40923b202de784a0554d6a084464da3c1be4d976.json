{"sha": "40923b202de784a0554d6a084464da3c1be4d976", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDA5MjNiMjAyZGU3ODRhMDU1NGQ2YTA4NDQ2NGRhM2MxYmU0ZDk3Ng==", "commit": {"author": {"name": "Devang Patel", "email": "dpatel@apple.com", "date": "2004-09-04T03:27:01Z"}, "committer": {"name": "Devang Patel", "email": "dpatel@gcc.gnu.org", "date": "2004-09-04T03:27:01Z"}, "message": "Tree level if-conversion for vectorizer.\n\n        * Makefile.in (OBJS-common): Add tree-if-conv.o\n        (tree-if-conv.o): New rule.\n        * cfgloop.c (flow_loop_exit_edges_find): Set EDGE_LOOP_EXIT flag.\n        (get_loop_body_in_bfs_order): New.\n        * cfgloop.h (get_loop_body_in_bfs_order): New.\n        * tree-flow.h (enum move_pos): Move here from ..\n        * tree-ssa-loop-im.c (enum move_pos): here.\n        (movement_possibility): Make externally visible.\n        * tree-optimize.c (init_tree_optimization_passes): New entry for\n        if conversion pass.\n        * tree-pass.h (pass_if_conversion): New.\n        * tree-ssa-operands.c (get_expr_operands): Handle COND_EXPR.\n        * tree-if-conv.c: New file.\n        * doc/passes.texi: Document tree if-conversion pass.\n        * doc/tree-ssa.texi: Same.\n\n        testsuite:\n\n        * gcc.dg/tree-ssa/ifc-20040816-1.c: New test.\n        * gcc.dg/tree-ssa/ifc-20040816-2.c: New test.\n\nFrom-SVN: r87073", "tree": {"sha": "1634fa84e47784b37bfc8b13390fa4532f7860b8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1634fa84e47784b37bfc8b13390fa4532f7860b8"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/40923b202de784a0554d6a084464da3c1be4d976", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/40923b202de784a0554d6a084464da3c1be4d976", "html_url": "https://github.com/Rust-GCC/gccrs/commit/40923b202de784a0554d6a084464da3c1be4d976", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/40923b202de784a0554d6a084464da3c1be4d976/comments", "author": null, "committer": null, "parents": [{"sha": "48d0dd75204e91efaba289e40b5eee703b07ccd8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/48d0dd75204e91efaba289e40b5eee703b07ccd8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/48d0dd75204e91efaba289e40b5eee703b07ccd8"}], "stats": {"total": 1313, "additions": 1299, "deletions": 14}, "files": [{"sha": "30a50beed797d1a9c259e6e199e0351817f9262c", "filename": "gcc/ChangeLog", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/40923b202de784a0554d6a084464da3c1be4d976/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/40923b202de784a0554d6a084464da3c1be4d976/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=40923b202de784a0554d6a084464da3c1be4d976", "patch": "@@ -1,3 +1,21 @@\n+2004-09-03  Devang Patel  <dpatel@apple.com>\n+\n+\t* Makefile.in (OBJS-common): Add tree-if-conv.o\n+\t(tree-if-conv.o): New rule.\n+\t* cfgloop.c (flow_loop_exit_edges_find): Set EDGE_LOOP_EXIT flag.\n+\t(get_loop_body_in_bfs_order): New.\n+\t* cfgloop.h (get_loop_body_in_bfs_order): New.\n+\t* tree-flow.h (enum move_pos): Move here from ..\n+\t* tree-ssa-loop-im.c (enum move_pos): here.\n+\t(movement_possibility): Make externally visible.\n+\t* tree-optimize.c (init_tree_optimization_passes): New entry for\n+\tif conversion pass.\n+\t* tree-pass.h (pass_if_conversion): New.\n+\t* tree-ssa-operands.c (get_expr_operands): Handle COND_EXPR.\n+\t* tree-if-conv.c: New file.\n+\t* doc/passes.texi: Document tree if-conversion pass.\n+\t* doc/tree-ssa.texi: Same.\t\n+\n 2004-09-03  H.J. Lu  <hongjiu.lu@intel.com>\n \n \tPR target/14925:"}, {"sha": "887b30fa7da9436c7ae7eaec0eafd49a4f9798ee", "filename": "gcc/Makefile.in", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/40923b202de784a0554d6a084464da3c1be4d976/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/40923b202de784a0554d6a084464da3c1be4d976/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=40923b202de784a0554d6a084464da3c1be4d976", "patch": "@@ -887,7 +887,6 @@ C_AND_OBJC_OBJS = attribs.o c-errors.o c-lex.o c-pragma.o c-decl.o c-typeck.o \\\n C_OBJS = c-parse.o c-lang.o stub-objc.o $(C_AND_OBJC_OBJS)\n \n # Language-independent object files.\n-\n OBJS-common = \\\n  tree-chrec.o tree-scalar-evolution.o tree-data-ref.o\t\t\t   \\\n  tree-cfg.o tree-dfa.o tree-eh.o tree-ssa.o tree-optimize.o tree-gimple.o  \\\n@@ -900,6 +899,7 @@ OBJS-common = \\\n  tree-phinodes.o tree-ssanames.o tree-sra.o tree-complex.o tree-ssa-loop.o \\\n  tree-ssa-loop-niter.o tree-ssa-loop-manip.o tree-ssa-threadupdate.o\t   \\\n  tree-vectorizer.o tree-ssa-loop-ivcanon.o tree-ssa-propagate.o\t \t   \\\n+ tree-if-conv.o\t \t                                                   \\\n  alias.o bb-reorder.o bitmap.o builtins.o caller-save.o calls.o\t  \t   \\\n  cfg.o cfganal.o cfgbuild.o cfgcleanup.o cfglayout.o cfgloop.o\t\t   \\\n  cfgloopanal.o cfgloopmanip.o loop-init.o loop-unswitch.o loop-unroll.o\t   \\\n@@ -1688,6 +1688,10 @@ tree-tailcall.o : tree-tailcall.c $(TREE_FLOW_H) $(CONFIG_H) $(SYSTEM_H) \\\n tree-nested.o: tree-nested.c $(CONFIG_H) $(SYSTEM_H) $(TM_H) $(TREE_H) \\\n    $(RTL_H) $(TM_P_H) function.h tree-dump.h tree-inline.h tree-iterator.h \\\n    tree-gimple.h cgraph.h $(EXPR_H) langhooks.h $(GGC_H) gt-tree-nested.h\n+tree-if-conv.o: tree-if-conv.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) \\\n+   $(TREE_H) flags.h $(TIMEVAR_H) varray.h $(BASIC_BLOCK_H) $(TREE_FLOW_H) \\\n+   cfgloop.h $(RTL_H) c-common.h tree-chrec.h tree-data-ref.h \\\n+   tree-scalar-evolution.h tree-pass.h \n tree-iterator.o : tree-iterator.c $(CONFIG_H) $(SYSTEM_H) $(TREE_H) \\\n    coretypes.h $(GGC_H) tree-iterator.h tree-gimple.h gt-tree-iterator.h\n tree-dfa.o : tree-dfa.c $(TREE_FLOW_H) $(CONFIG_H) $(SYSTEM_H) \\"}, {"sha": "892b70d1da5ae762d61e19fb0314414ec24d58c4", "filename": "gcc/cfgloop.c", "status": "modified", "additions": 58, "deletions": 1, "changes": 59, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/40923b202de784a0554d6a084464da3c1be4d976/gcc%2Fcfgloop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/40923b202de784a0554d6a084464da3c1be4d976/gcc%2Fcfgloop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgloop.c?ref=40923b202de784a0554d6a084464da3c1be4d976", "patch": "@@ -315,7 +315,10 @@ flow_loop_exit_edges_find (struct loop *loop)\n \t  basic_block dest = e->dest;\n \n \t  if (!flow_bb_inside_loop_p (loop, dest))\n-\t    loop->exit_edges[num_exits++] = e;\n+\t    {\n+\t      e->flags |= EDGE_LOOP_EXIT;\n+\t      loop->exit_edges[num_exits++] = e;\n+\t    }\n       }\n     }\n   free (bbs);\n@@ -1085,6 +1088,60 @@ get_loop_body_in_dom_order (const struct loop *loop)\n   return tovisit;\n }\n \n+/* Get body of a LOOP in breadth first sort order.  */\n+\n+basic_block *\n+get_loop_body_in_bfs_order (const struct loop *loop)\n+{\n+  basic_block *blocks;\n+  basic_block bb;\n+  bitmap visited;\n+  unsigned int i = 0;\n+  unsigned int vc = 1;\n+\n+  if (!loop->num_nodes)\n+    abort ();\n+\n+  if (loop->latch == EXIT_BLOCK_PTR)\n+    abort ();\n+\n+  blocks = xcalloc (loop->num_nodes, sizeof (basic_block));\n+  visited = BITMAP_XMALLOC ();\n+\n+  bb = loop->header;\n+  while (i < loop->num_nodes)\n+    {\n+      edge e;\n+      \n+      if (!bitmap_bit_p (visited, bb->index))\n+        { \n+          /* This basic block is now visited */\n+          bitmap_set_bit (visited, bb->index);\n+          blocks[i++] = bb;\n+        }\n+      \n+      for (e = bb->succ; e; e = e->succ_next)\n+        { \n+          if (flow_bb_inside_loop_p (loop, e->dest))\n+            { \n+              if (!bitmap_bit_p (visited, e->dest->index))\n+                { \n+                  bitmap_set_bit (visited, e->dest->index);\n+                  blocks[i++] = e->dest;\n+                }\n+            }\n+        }\n+      \n+      if (i < vc)\n+        abort ();\n+      \n+      bb = blocks[vc++];\n+    }\n+  \n+  BITMAP_XFREE (visited);\n+  return blocks;\n+}\n+\n /* Gets exit edges of a LOOP, returning their number in N_EDGES.  */\n edge *\n get_loop_exit_edges (const struct loop *loop, unsigned int *n_edges)"}, {"sha": "60c80ceaa3fd842768509738b6e9cab67ee4d632", "filename": "gcc/cfgloop.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/40923b202de784a0554d6a084464da3c1be4d976/gcc%2Fcfgloop.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/40923b202de784a0554d6a084464da3c1be4d976/gcc%2Fcfgloop.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgloop.h?ref=40923b202de784a0554d6a084464da3c1be4d976", "patch": "@@ -272,6 +272,7 @@ extern unsigned get_loop_level (const struct loop *);\n /* Loops & cfg manipulation.  */\n extern basic_block *get_loop_body (const struct loop *);\n extern basic_block *get_loop_body_in_dom_order (const struct loop *);\n+extern basic_block *get_loop_body_in_bfs_order (const struct loop *);\n extern edge *get_loop_exit_edges (const struct loop *, unsigned *);\n extern unsigned num_loop_branches (const struct loop *);\n "}, {"sha": "16de6ea138add60e81440a136b3cc4a861aad753", "filename": "gcc/doc/passes.texi", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/40923b202de784a0554d6a084464da3c1be4d976/gcc%2Fdoc%2Fpasses.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/40923b202de784a0554d6a084464da3c1be4d976/gcc%2Fdoc%2Fpasses.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fpasses.texi?ref=40923b202de784a0554d6a084464da3c1be4d976", "patch": "@@ -385,6 +385,15 @@ The optimizations also use various utility functions contained in\n @file{tree-ssa-loop-manip.c}, @file{cfgloop.c}, @file{cfgloopanal.c} and\n @file{cfgloopmanip.c}.\n \n+@item Tree level if-conversion for vectorizer\n+\n+This pass applies if-conversion to simple loops to help vectorizer.\n+We identify if convertable loops, if-convert statements and merge\n+basic blocks in one big block. The idea is to present loop in such\n+form so that vectorizer can have one to one mapping between statements\n+and available vector operations. This patch re-introduces COND_EXPR\n+at GIMPLE level. This pass is located in @file{tree-if-conv.c}.\n+\n @item Conditional constant propagation\n \n This pass relaxes a lattice of values in order to identify those"}, {"sha": "1c88e9f021c0730e60a05b9a0c7bd5b2cc43985f", "filename": "gcc/doc/tree-ssa.texi", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/40923b202de784a0554d6a084464da3c1be4d976/gcc%2Fdoc%2Ftree-ssa.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/40923b202de784a0554d6a084464da3c1be4d976/gcc%2Fdoc%2Ftree-ssa.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Ftree-ssa.texi?ref=40923b202de784a0554d6a084464da3c1be4d976", "patch": "@@ -260,6 +260,9 @@ becomes\n   a = T1;\n @end smallexample\n \n+Tree level if-conversion pass re-introduces @code{?:} expression, if appropriate.\n+It is used to vectorize loops with conditions using vector conditional operations.\n+\n Note that in GIMPLE, @code{if} statements are also represented using\n @code{COND_EXPR}, as described below.\n "}, {"sha": "276c31d819162b373b45c4425d4e3d69c48f2290", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/40923b202de784a0554d6a084464da3c1be4d976/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/40923b202de784a0554d6a084464da3c1be4d976/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=40923b202de784a0554d6a084464da3c1be4d976", "patch": "@@ -1,3 +1,8 @@\n+2004-09-03  Devang Patel  <dpatel@apple.com>\n+\t\n+\t* gcc.dg/tree-ssa/ifc-20040816-1.c: New test.\n+\t* gcc.dg/tree-ssa/ifc-20040816-2.c: New test.\n+\t\n 2004-09-03  Jan Beulich  <jbeulich@novell.com>\n \n \t* g++.dg/abi/bitfield5.C: Use -mno-ms-bitfields."}, {"sha": "2290563eb8cd79d72eff27bb555cd24b075d251f", "filename": "gcc/testsuite/gcc.dg/tree-ssa/ifc-20040816-1.c", "status": "added", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/40923b202de784a0554d6a084464da3c1be4d976/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fifc-20040816-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/40923b202de784a0554d6a084464da3c1be4d976/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fifc-20040816-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fifc-20040816-1.c?ref=40923b202de784a0554d6a084464da3c1be4d976", "patch": "@@ -0,0 +1,36 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-c -O2 -fdump-tree-ifcvt-stats\" { target *-*-* } } */\n+\n+#include <stdarg.h>\n+#include <signal.h>\n+\n+#define N 16\n+#define MAX 42\n+\n+extern void abort(void); \n+\n+int main1 ()\n+{  \n+  int A[N] = {36,39,42,45,43,32,21,12,23,34,45,56,67,78,89,11};\n+\n+  int i, j;\n+\n+  for (i = 0; i < N; i++)\n+    {\n+      j = A[i];\n+      A[i] = ( j >= MAX ? MAX : 0); \n+    }\n+\n+  /* check results:  */\n+  for (i = 0; i < N; i++)\n+    {\n+      if (A[i] > MAX)\n+\tabort ();\n+    }\n+\n+  return 0;\n+}\n+\n+\n+\n+/* { dg-final { scan-tree-dump-times \"Applying if-conversion\" 1 \"ifcvt\" } } */"}, {"sha": "47ac65272348d6f57d7a17da784a7697b291408c", "filename": "gcc/testsuite/gcc.dg/tree-ssa/ifc-20040816-2.c", "status": "added", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/40923b202de784a0554d6a084464da3c1be4d976/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fifc-20040816-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/40923b202de784a0554d6a084464da3c1be4d976/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fifc-20040816-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fifc-20040816-2.c?ref=40923b202de784a0554d6a084464da3c1be4d976", "patch": "@@ -0,0 +1,37 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-c -O2 -fdump-tree-ifcvt-stats\" { target *-*-* } } */\n+\n+typedef float afloat __attribute__ ((__aligned__(16)));\n+void foo(const afloat * __restrict__ zr_in,\n+\t\tconst afloat * __restrict__ zi_in,\n+\t\tconst afloat * __restrict__ zk_in,\n+\t\tafloat * __restrict__ zr_out,\n+\t\tafloat * __restrict__ zi_out,\n+\t\tafloat * __restrict__ zk_out,\n+\t\tfloat cr, float ci)\n+{\n+  unsigned int pi;\n+  float tmp_r, tmp_i, tmp_k;\n+  for (pi = 0; pi < (512)*(512); pi++) {\n+    float zr = zr_in[pi];\n+    float zi = zi_in[pi];\n+    float zk = zk_in[pi];\n+    \n+    if (zr*zr + zi*zi >= 4.0f) {\n+      tmp_r = zr;\n+      tmp_i = zi;\n+      tmp_k = zk;\n+    } else {\n+      tmp_r = (zr*zr - zi*zi + cr);\n+      tmp_i = (2 * zr * zi + ci);\n+      tmp_k = zk + 1.0f;\n+    }\n+    zr_out[pi] = tmp_r;\n+    zi_out[pi] = tmp_i;\n+    zk_out[pi] = tmp_k;\n+  }\n+}\n+\n+\n+/* { dg-final { scan-tree-dump-times \"Applying if-conversion\" 1 \"ifcvt\" } } */\n+"}, {"sha": "19d0b14ac35ce424f315390951d64308ec648dc5", "filename": "gcc/tree-flow.h", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/40923b202de784a0554d6a084464da3c1be4d976/gcc%2Ftree-flow.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/40923b202de784a0554d6a084464da3c1be4d976/gcc%2Ftree-flow.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-flow.h?ref=40923b202de784a0554d6a084464da3c1be4d976", "patch": "@@ -654,6 +654,22 @@ bool for_each_index (tree *, bool (*) (tree, tree *, void *), void *);\n void create_iv (tree, tree, tree, struct loop *, block_stmt_iterator *, bool,\n \t\ttree *, tree *);\n \n+/* In tree-ssa-loop-im.c  */\n+/* The possibilities of statement movement.  */\n+\n+enum move_pos\n+  {\n+    MOVE_IMPOSSIBLE,\t\t/* No movement -- side effect expression.  */\n+    MOVE_PRESERVE_EXECUTION,\t/* Must not cause the non-executed statement\n+\t\t\t\t   become executed -- memory accesses, ... */\n+    MOVE_POSSIBLE\t\t/* Unlimited movement.  */\n+  };\n+extern enum move_pos movement_possibility (tree);\n+\n+/* In tree-if-conv.c  */\n+bool tree_if_conversion (struct loop *, bool);\n+\n+\n /* In tree-flow-inline.h  */\n static inline int phi_arg_from_edge (tree, edge);\n static inline bool is_call_clobbered (tree);"}, {"sha": "e435512cba132652b1d93f3bd0b4f53d4f8b7925", "filename": "gcc/tree-if-conv.c", "status": "added", "additions": 1102, "deletions": 0, "changes": 1102, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/40923b202de784a0554d6a084464da3c1be4d976/gcc%2Ftree-if-conv.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/40923b202de784a0554d6a084464da3c1be4d976/gcc%2Ftree-if-conv.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-if-conv.c?ref=40923b202de784a0554d6a084464da3c1be4d976", "patch": "@@ -0,0 +1,1102 @@\n+/* If-conversion for vectorizer.\n+   Copyright (C) 2004 Free Software Foundation, Inc.\n+   Contributed by Devang Patel <dpatel@apple.com>\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it under\n+the terms of the GNU General Public License as published by the Free\n+Software Foundation; either version 2, or (at your option) any later\n+version.\n+\n+GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING.  If not, write to the Free\n+Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n+02111-1307, USA.  */\n+\n+/* This pass implements tree level if-conversion transformation of loops. \n+   Initial goal is to help vectorizer vectorize loops with conditions.\n+\n+   A short description of if-conversion:\n+\n+     o Decide if a loop is if-convertable or not.\n+     o Walk all loop basic blocks in breadth first order (BFS order).\n+       o Remove conditional statements (at the end of basic block)\n+         and propogate condition into destination basic blcoks'\n+\t predicate list.\n+       o Replace modify expression with conditional modify expression\n+         using current basic block's condition.\n+     o Merge all basic blocks\n+       o Replace phi nodes with conditional modify expr\n+       o Merge all basic blocks into header\n+\n+     Sample transformation:\n+\n+     INPUT\n+     -----\n+\n+     # i_23 = PHI <0(0), i_18(10)>;\n+     <L0>:;\n+     j_15 = A[i_23];\n+     if (j_15 > 41) goto <L1>; else goto <L17>;\n+\n+     <L17>:;\n+     goto <bb 3> (<L3>);\n+\n+     <L1>:;\n+\n+     # iftmp.2_4 = PHI <0(8), 42(2)>;\n+     <L3>:;\n+     A[i_23] = iftmp.2_4;\n+     i_18 = i_23 + 1;\n+     if (i_18 <= 15) goto <L19>; else goto <L18>;\n+\n+     <L19>:;\n+     goto <bb 1> (<L0>);\n+\n+     <L18>:;\n+\n+     OUTPUT\n+     ------\n+\n+     # i_23 = PHI <0(0), i_18(10)>;\n+     <L0>:;\n+     j_15 = A[i_23];\n+     \n+     <L3>:;\n+     iftmp.2_4 = j_15 > 41 ? 42 : 0;\n+     A[i_23] = iftmp.2_4;\n+     i_18 = i_23 + 1;\n+     if (i_18 <= 15) goto <L19>; else goto <L18>;\n+     \n+     <L19>:;\n+     goto <bb 1> (<L0>);\n+\n+     <L18>:;\n+*/\n+\n+#include \"config.h\"\n+#include \"system.h\"\n+#include \"coretypes.h\"\n+#include \"tm.h\"\n+#include \"errors.h\"\n+#include \"tree.h\"\n+#include \"c-common.h\"\n+#include \"flags.h\"\n+#include \"timevar.h\"\n+#include \"varray.h\"\n+#include \"rtl.h\"\n+#include \"basic-block.h\"\n+#include \"diagnostic.h\"\n+#include \"tree-flow.h\"\n+#include \"tree-dump.h\"\n+#include \"cfgloop.h\"\n+#include \"tree-chrec.h\"\n+#include \"tree-data-ref.h\"\n+#include \"tree-scalar-evolution.h\"\n+#include \"tree-pass.h\"\n+#include \"target.h\"\n+\n+/* local function prototypes */\n+static void main_tree_if_conversion (void);\n+static tree tree_if_convert_stmt (struct loop *loop, tree, tree, \n+\t\t\t\t  block_stmt_iterator *);\n+static void tree_if_convert_cond_expr (struct loop *, tree, tree, \n+\t\t\t\t       block_stmt_iterator *);\n+static bool if_convertable_phi_p (struct loop *, basic_block, tree);\n+static bool if_convertable_modify_expr_p (struct loop *, basic_block, tree);\n+static bool if_convertable_stmt_p (struct loop *, basic_block, tree);\n+static bool if_convertable_bb_p (struct loop *, basic_block, bool);\n+static bool if_convertable_loop_p (struct loop *, bool);\n+static void add_to_predicate_list (basic_block, tree);\n+static tree add_to_dst_predicate_list (struct loop * loop, tree, tree, tree,\n+\t\t\t\t       block_stmt_iterator *);\n+static void clean_predicate_lists (struct loop *loop);\n+static bool find_phi_replacement_condition (basic_block, tree *,\n+                                            block_stmt_iterator *);\n+static void replace_phi_with_cond_modify_expr (tree, tree, bool,\n+                                               block_stmt_iterator *);\n+static void process_phi_nodes (struct loop *);\n+static void combine_blocks (struct loop *);\n+static tree ifc_temp_var (tree, tree);\n+static bool pred_blocks_visited_p (basic_block, bitmap *);\n+static basic_block * get_loop_body_in_if_conv_order (const struct loop *loop);\n+static bool bb_with_exit_edge_p (basic_block);\n+\n+/* List of basic blocks in if-conversion-suitable order.  */\n+static basic_block *ifc_bbs;\n+\n+/* Main entry point.\n+   Apply if-conversion to the LOOP. Return true if successful otherwise return\n+   false. If false is returned then loop remains unchanged.  \n+   FOR_VECTORIZER is a boolean flag. It indicates whether if-conversion is used\n+   for vectorizer or not. If it is used for vectorizer, additional checks are\n+   used. (Vectorization checks are not yet imlemented).  */\n+\n+bool\n+tree_if_conversion (struct loop *loop, bool for_vectorizer)\n+{\n+  basic_block bb;\n+  block_stmt_iterator itr;\n+  tree cond;\n+  unsigned int i;\n+\n+  ifc_bbs = NULL;\n+\n+  /* if-conversion is not appropriate for all loops. First, check if loop  is\n+     if-convertable or not.  */\n+  if (!if_convertable_loop_p (loop, for_vectorizer))\n+    {\n+      if (dump_file && (dump_flags & TDF_DETAILS))\n+\tfprintf (dump_file,\"-------------------------\\n\");\n+      if (ifc_bbs)\n+\t{\n+\t  free (ifc_bbs);\n+\t  ifc_bbs = NULL;\n+\t}\n+      free_dominance_info (CDI_POST_DOMINATORS);\n+      free_df ();\n+      return false;\n+    }\n+\n+  cond = NULL_TREE;\n+  \n+  /* Do actual work now.  */\n+  for (i = 0; i < loop->num_nodes; i++)  \n+    {\n+      bb = ifc_bbs [i];\n+\n+      /* Update condition using predicate list.  */\n+      cond = bb->aux;\n+\n+      /* Process all statements in this basic block.\n+\t Remove conditional expresion, if any, and annotate\n+\t destination basic block(s) appropriately.  */\n+      for (itr = bsi_start (bb); !bsi_end_p (itr); /* empty */)\n+\t{\n+\t  tree t = bsi_stmt (itr);\n+\t  cond = tree_if_convert_stmt (loop, t, cond, &itr);\n+\t  if (!bsi_end_p (itr))\n+\t    bsi_next (&itr);\n+\t}\n+\n+      /* If current bb has only one successor, then consider it as an \n+\t unconditional goto.  */\n+      if (bb->succ && !bb->succ->succ_next)\n+\t{\n+\t  basic_block bb_n = bb->succ->dest;\n+\t  if (cond != NULL_TREE)\n+\t    add_to_predicate_list (bb_n, cond);\n+\t  cond = NULL_TREE;\n+\t}\n+    }\n+\n+  /* Now, all statements are if-converted and basic blocks are\n+     annotated appropriately. Combine all basic block into one huge\n+     basic block.  */\n+  combine_blocks (loop);\n+\n+  /* clean up */\n+  clean_predicate_lists (loop);\n+  free (ifc_bbs);\n+  ifc_bbs = NULL;\n+  free_df ();\n+\n+  return true;\n+}\n+\n+/* if-convert stmt T which is part of LOOP. \n+   If T is a MODIFY_EXPR than it is converted into conditional modify \n+   expression using COND.  For conditional expressions, add condition in the \n+   destination basic block's predicate list and remove conditional \n+   expression itself. BSI is the iterator used to traverse statements of \n+   loop. It is used here when it is required to delete current statement.  */\n+\n+static tree\n+tree_if_convert_stmt (struct loop *  loop, tree t, tree cond, \n+\t\t      block_stmt_iterator *bsi)\n+{\n+  if (dump_file && (dump_flags & TDF_DETAILS))\n+    {\n+      fprintf (dump_file, \"------if-convert stmt\\n\");\n+      print_generic_stmt (dump_file, t, TDF_SLIM);\n+      print_generic_stmt (dump_file, cond, TDF_SLIM);\n+    }\n+\n+  switch (TREE_CODE (t))\n+    {\n+      /* Labels are harmless here.  */\n+    case LABEL_EXPR:\n+      break;\n+\n+    case MODIFY_EXPR:\n+      /* This modify_expr is killing previous value of LHS. Appropriate value will\n+\t be selected by PHI node based on condition. It is possible that before\n+\t this transformation, PHI nodes was selecting default value and now it will\n+\t use this new value. This is OK because it does not change validity the \n+\t program.  */\n+      break;\n+\n+    case GOTO_EXPR:\n+      /* Unconditional goto */\n+      add_to_predicate_list (bb_for_stmt (TREE_OPERAND (t, 1)), cond);\n+      bsi_remove (bsi);\n+      cond = NULL_TREE;\n+      break;\n+\n+    case COND_EXPR:\n+      /* Update destination blocks' predicate list and remove this\n+\t condition expression.  */\n+      tree_if_convert_cond_expr (loop, t, cond, bsi);\n+      cond = NULL_TREE; \n+      break;\n+\t\n+    default:    \n+      abort ();\n+      break;\n+    }\n+  return cond;\n+}\n+\n+/* STMT is COND_EXPR. Update two destination's predicate list.\n+   Remove COND_EXPR, if it is not the loop exit condition. Otherwise\n+   update loop exit condition appropriatly.  BSI is the iterator\n+   used to traverse statement list. STMT is part of loop LOOP.  */\n+\n+static void\n+tree_if_convert_cond_expr (struct loop *loop, tree stmt, tree cond, \n+\t\t\t   block_stmt_iterator *bsi)\n+{\n+  tree then_clause, else_clause, c, new_cond;\n+  new_cond = NULL_TREE;\n+\n+#ifdef ENABLE_CHECKING\n+  if (TREE_CODE (stmt) != COND_EXPR)\n+    abort ();\n+#endif\n+\n+  c = TREE_OPERAND (stmt, 0);\n+  then_clause = TREE_OPERAND (stmt, 1);\n+  else_clause = TREE_OPERAND (stmt, 2);\n+  \n+  /* Create temp. for condition.  */\n+  if (!is_gimple_reg (c))\n+    {\n+      tree new_stmt;\n+      new_stmt = ifc_temp_var (TREE_TYPE (c), unshare_expr (c));\n+      bsi_insert_before (bsi, new_stmt, BSI_SAME_STMT);\n+      c = TREE_OPERAND (new_stmt, 0);\n+    }\n+\t\n+  /* Add new condition into destination's predicate list.  */\n+  if (then_clause)\n+    /* if 'c' is true then then_clause is reached.  */\n+    new_cond = add_to_dst_predicate_list (loop, then_clause, cond, c, bsi);\n+  \n+  if (else_clause)\n+    {\n+      /* if 'c' is false then else_clause is reached.  */\n+      tree c2 = build1 (TRUTH_NOT_EXPR, \n+\t\t\tboolean_type_node, \n+\t\t\tunshare_expr (c));\n+      add_to_dst_predicate_list (loop, else_clause, cond, c2, bsi);\n+    }\n+\n+  /* Now this conditional statement is redundent. Remove it.\n+     But, do not remove exit condition! Update exit condition\n+     using new condition.  */\n+  if (!bb_with_exit_edge_p (bb_for_stmt (stmt)))\n+    {\n+      bsi_remove (bsi);\n+      cond = NULL_TREE;\n+    }\n+  else if (new_cond != NULL_TREE)\n+    {\n+      TREE_OPERAND (stmt, 0) = new_cond;\n+      modify_stmt (stmt);\n+    }\n+  return;\n+}\n+\n+/* Return true, iff PHI is if-convertable. PHI is part of loop LOOP\n+   and it belongs to basic block BB.\n+   PHI is not if-convertable \n+   - if it has more than 2 arguments.\n+   - Virtual PHI is immediately used in another PHI node.  */\n+\n+static bool\n+if_convertable_phi_p (struct loop *loop, basic_block bb, tree phi)\n+{\n+  if (dump_file && (dump_flags & TDF_DETAILS))\n+    {\n+      fprintf (dump_file, \"-------------------------\\n\");\n+      print_generic_stmt (dump_file, phi, TDF_SLIM);\n+    }\n+  \n+  if (bb != loop->header && PHI_NUM_ARGS (phi) != 2)\n+    {\n+      if (dump_file && (dump_flags & TDF_DETAILS))\n+\tfprintf (dump_file, \"More than two phi node args.\\n\");\n+      return false;\n+    }\n+  \n+  if (!is_gimple_reg (SSA_NAME_VAR (PHI_RESULT (phi))))\n+    {\n+      int j;\n+      dataflow_t df = get_immediate_uses (phi);\n+      int num_uses = num_immediate_uses (df);\n+      for (j = 0; j < num_uses; j++)\n+\t{\n+\t  tree use = immediate_use (df, j);\n+\t  if (TREE_CODE (use) == PHI_NODE)\n+\t    {\n+\t      if (dump_file && (dump_flags & TDF_DETAILS))\n+\t\tfprintf (dump_file, \"Difficult to handle this virtual phi.\\n\");\n+\t      return false;\n+\t    }\n+\t}\n+    }\n+\n+  return true;\n+}\n+\n+/* Return true, if M_EXPR is if-convertable.  \n+   MODIFY_EXPR is not if-convertable if,\n+   - It is not movable.\n+   - It could trap.\n+   - LHS is not var decl.\n+  MODIFY_EXPR is part of block BB, which is inside loop LOOP.\n+*/\n+\n+static bool\n+if_convertable_modify_expr_p (struct loop *loop, basic_block bb, tree m_expr)\n+{\n+  if (dump_file && (dump_flags & TDF_DETAILS))\n+    {\n+      fprintf (dump_file, \"-------------------------\\n\");\n+      print_generic_stmt (dump_file, m_expr, TDF_SLIM);\n+    }\n+  \n+  /* Be conservative and do not handle immovable expressions.  */\n+  if (movement_possibility (m_expr) == MOVE_IMPOSSIBLE)\n+    {\n+      if (dump_file && (dump_flags & TDF_DETAILS))\n+\tfprintf (dump_file, \"stmt is movable. Don't take risk\\n\");\n+      return false;\n+    }\n+\n+  /* See if it needs speculative loading or not.  */\n+  if (bb != loop->header \n+      && tree_could_trap_p (TREE_OPERAND (m_expr, 1)))\n+    {\n+      if (dump_file && (dump_flags & TDF_DETAILS))\n+\tfprintf (dump_file, \"tree could trap...\\n\");\n+      return false;\n+    }\n+\n+  if (TREE_CODE (TREE_OPERAND (m_expr, 1)) == CALL_EXPR)\n+    {\n+      if (dump_file && (dump_flags & TDF_DETAILS))\n+\tfprintf (dump_file, \"CALL_EXPR \\n\");\n+      return false;\n+    }\n+\n+  if (TREE_CODE (TREE_OPERAND (m_expr, 0)) != SSA_NAME\n+      && bb != loop->header\n+      && !bb_with_exit_edge_p (bb))\n+    {\n+      if (dump_file && (dump_flags & TDF_DETAILS))\n+\t{\n+\t  fprintf (dump_file, \"LHS is not var\\n\");\n+\t  print_generic_stmt (dump_file, m_expr, TDF_SLIM);\n+\t}\n+      return false;\n+    }\n+\n+\n+  return true;\n+}\n+\n+/* Return true, iff STMT is if-convertable.  \n+   Statement is if-convertable if,\n+   - It is if-converatable MODIFY_EXPR\n+   - IT is LABEL_EXPR, GOTO_EXPR or COND_EXPR.  \n+   STMT is inside block BB, which is inside loop LOOP.  */\n+\n+static bool\n+if_convertable_stmt_p (struct loop *loop, basic_block bb, tree stmt)\n+{\n+  switch (TREE_CODE (stmt))\n+    {\n+    case LABEL_EXPR:\n+      break;\n+      \n+    case MODIFY_EXPR:\n+      \n+      if (!if_convertable_modify_expr_p (loop, bb, stmt))\n+\treturn false;\n+      break;\n+      \n+    case GOTO_EXPR:\n+    case COND_EXPR:\n+      break;\n+      \n+    default:\n+      /* Don't know what to do with 'em so don't do anything.  */\n+      if (dump_file && (dump_flags & TDF_DETAILS))\n+\t{\n+\t  fprintf (dump_file, \"don't know what to do\\n\");\n+\t  print_generic_stmt (dump_file, stmt, TDF_SLIM);\n+\t}\n+      return false;\n+      break;\n+    }\n+\n+  return true;\n+}\n+\n+/* Return true, iff BB is if-convertable. \n+   Note: This routine does _not_ check basic block statements and phis.\n+   Basic block is not if-converatable if,\n+   - Basic block is non-empty and it is after exit block (in BFS order).  \n+   - Basic block is after exit block but before latch.\n+   - Basic block edge(s) is not normal.  \n+   EXIT_BB_SEEN is true if basic block with exit edge is already seen.\n+   BB is inside loop LOOP. */\n+\n+static bool \n+if_convertable_bb_p (struct loop *loop, basic_block bb, bool exit_bb_seen)\n+{\n+  edge e;\n+\n+  if (dump_file && (dump_flags & TDF_DETAILS))\n+    fprintf (dump_file, \"----------[%d]-------------\\n\", bb->index);\n+  \n+  if (exit_bb_seen)\n+    {\n+      if (bb != loop->latch)\n+\t{\n+\t  if (dump_file && (dump_flags & TDF_DETAILS))\n+\t    fprintf (dump_file, \"basic block after exit bb but before latch\\n\");\n+\t  return false;\n+\t}\n+      else if (!empty_block_p (bb))\n+\t{\n+\t  if (dump_file && (dump_flags & TDF_DETAILS))\n+\t    fprintf (dump_file, \"non empty basic block after exit bb\\n\");\n+\t  return false;\n+\t}\n+    }\n+  \n+  /* Be less adveturous and handle only normal edges.  */\n+  for (e = bb->succ; e; e = e->succ_next)\n+    if (e->flags & \n+\t(EDGE_ABNORMAL_CALL | EDGE_EH | EDGE_ABNORMAL | EDGE_IRREDUCIBLE_LOOP))\n+      {\n+\tif (dump_file && (dump_flags & TDF_DETAILS))\n+\t  fprintf (dump_file,\"Difficult to handle edges\\n\");\n+\treturn false;\n+      }\n+\n+  return true;\n+}\n+\n+/* Return true, iff LOOP is if-convertable. \n+   LOOP is if-convertable if,\n+   - It is innermost.\n+   - It has two or more basic blocks.\n+   - It has only one exit.\n+   - Loop header is not the exit edge. \n+   - If its basic blocks and phi nodes are if convertable. See above for \n+     more info.   \n+   FOR_VECTORIZER enables vectorizer specific checks. For example, support\n+   for vector conditions, data dependency checks etc.. (Not implemented yet).  */\n+\n+static bool\n+if_convertable_loop_p (struct loop *loop, bool for_vectorizer ATTRIBUTE_UNUSED)\n+{\n+  tree phi;\n+  basic_block bb;\n+  block_stmt_iterator itr;\n+  unsigned int i;\n+  edge e;\n+  bool exit_bb_seen = false;\n+\n+  /* Handle only inner most loop.  */\n+  if (!loop || loop->inner)\n+    {\n+      if (dump_file && (dump_flags & TDF_DETAILS))\n+\tfprintf (dump_file, \"not inner most loop\\n\");\n+      return false;\n+    }\n+  \n+  flow_loop_scan (loop, LOOP_ALL);\n+\n+  /* If only one block, no need for if-conversion.  */\n+  if (loop->num_nodes <= 2)\n+    {\n+      if (dump_file && (dump_flags & TDF_DETAILS))\n+\tfprintf (dump_file, \"less thant 2 basic blocks\\n\");\n+      return false;\n+    }\n+  \n+  /* More than one loop exit is too much to handle.  */\n+  if (loop->num_exits > 1)\n+    {\n+      if (dump_file && (dump_flags & TDF_DETAILS))\n+\tfprintf (dump_file, \"multiple exits\\n\");\n+      return false;\n+    }\n+\n+  /* ??? Check target's vector conditional operation support for vectorizer.  */\n+\n+  /* If one of the loop header's edge is exit edge then do not apply\n+     if-conversion.  */\n+  for (e = loop->header->succ; e; e = e->succ_next)\n+    if ( e->flags & EDGE_LOOP_EXIT)\n+      return false;\n+\n+  compute_immediate_uses (TDFA_USE_OPS|TDFA_USE_VOPS, NULL);\n+\n+  calculate_dominance_info (CDI_DOMINATORS);\n+  calculate_dominance_info (CDI_POST_DOMINATORS);\n+\n+  /* Allow statements that can be handled during if-conversion.  */\n+  ifc_bbs = get_loop_body_in_if_conv_order (loop);\n+  if (!ifc_bbs)\n+    {\n+      if (dump_file && (dump_flags & TDF_DETAILS))\n+\tfprintf (dump_file,\"Irreducible loop\\n\");\n+      free_dominance_info (CDI_POST_DOMINATORS);\n+      return false;\n+    }\n+    \n+  for (i = 0; i < loop->num_nodes; i++)\n+    {\n+      bb = ifc_bbs[i];\n+\n+      if (!if_convertable_bb_p (loop, bb, exit_bb_seen))\n+\treturn false;\n+\n+      /* Check statements.  */\n+      for (itr = bsi_start (bb); !bsi_end_p (itr); bsi_next (&itr))\n+\tif (!if_convertable_stmt_p (loop, bb, bsi_stmt (itr)))\n+\t  return false;\n+      /* ??? Check data dependency for vectorizer.  */\n+\n+      /* What about phi nodes ? */\n+      for (phi = phi_nodes (bb); phi; phi = TREE_CHAIN (phi))\n+\tif (!if_convertable_phi_p (loop, bb, phi))\n+\t  return false;\n+\n+      if (bb_with_exit_edge_p (bb))\n+\texit_bb_seen = true;\n+    }\n+\n+  /* OK. Did not find any potential issues so go ahead in if-convert\n+     this loop. Now there is no looking back.  */\n+  if (dump_file)\n+    fprintf (dump_file,\"Applying if-conversion\\n\");\n+\n+  free_dominance_info (CDI_POST_DOMINATORS);\n+  return true;\n+}\n+\n+/* Add condition COND into predicate list of basic block BB.  */\n+\n+static void\n+add_to_predicate_list (basic_block bb, tree new_cond)\n+{\n+  tree cond = bb->aux;\n+  \n+  if (cond)\n+    cond = fold (build (TRUTH_OR_EXPR, boolean_type_node,\n+\t\t\tunshare_expr (cond), new_cond));\n+  else\n+    cond = new_cond;\n+\n+  bb->aux = cond;\n+}\n+\n+/* Add condition COND into DST's predicate list.  PREV_COND is\n+   existing condition.  */\n+\n+static tree\n+add_to_dst_predicate_list (struct loop * loop, tree dst, \n+\t\t\t   tree prev_cond, tree cond,\n+\t\t\t   block_stmt_iterator *bsi)\n+{\n+  basic_block bb;\n+  tree new_cond = NULL_TREE;\n+\n+#ifdef ENABLE_CHECKING\n+  if (TREE_CODE (dst) != GOTO_EXPR)\n+    abort ();\n+#endif\n+  bb = label_to_block (TREE_OPERAND (dst, 0));\n+  if (!flow_bb_inside_loop_p (loop, bb))\n+    return NULL_TREE;\n+\n+  if (prev_cond == boolean_true_node || !prev_cond)\n+    new_cond = unshare_expr (cond);\n+  else\n+    {\n+      tree tmp_stmt;\n+      /* new_cond == prev_cond AND cond */\n+      tree tmp = build (TRUTH_AND_EXPR, boolean_type_node,\n+\t\t\tunshare_expr (prev_cond), cond);\n+      tmp_stmt = ifc_temp_var (boolean_type_node, tmp);\n+      bsi_insert_before (bsi, tmp_stmt, BSI_SAME_STMT);\n+      new_cond = TREE_OPERAND (tmp_stmt, 0);\n+    }\n+  add_to_predicate_list (bb, new_cond);\n+  return new_cond;\n+}\n+\n+/* During if-conversion aux field from basic block is used to hold predicate\n+   list. Clean each basic block's predicate list for the given LOOP.  */\n+\n+static void\n+clean_predicate_lists (struct loop *loop)\n+{\n+  unsigned int i;\n+\n+  for (i = 0; i < loop->num_nodes; i++)\n+    ifc_bbs[i]->aux = NULL;\n+}\n+\n+/* Basic block BB has two predecessors. Using predecessor's aux field, set\n+   appropriate condition COND for the PHI node replacement. Return true if\n+   phi arguments are condition is selected from second predecessor.  */\n+\n+static bool\n+find_phi_replacement_condition (basic_block bb, tree *cond,\n+                                block_stmt_iterator *bsi)\n+{\n+  edge e;\n+  basic_block p1 = NULL;\n+  basic_block p2 = NULL;\n+  bool switch_args = false;\n+  tree tmp_cond;\n+\n+  for (e = bb->pred; e; e = e->pred_next)\n+    {\n+      if (p1 == NULL)\n+\t  p1 = e->src;\n+      else if (p2 == NULL)\n+\tp2 = e->src;\n+      else\n+\t/* More than two predecessors. This is not expected.  */\n+\tabort ();\n+    }\n+\n+  /* Use condition that is not TRUTH_NOT_EXPR in conditional modify expr.  */\n+  tmp_cond = p1->aux;\n+  if (TREE_CODE (tmp_cond) == TRUTH_NOT_EXPR)\n+    {\n+      *cond  = p2->aux;\n+      switch_args = true;\n+    }\n+  else\n+    {\n+      *cond  = p1->aux;\n+      switch_args = false;\n+    }\n+    \n+  /* Create temp. for the condition. Vectorizier prefers to have gimple \n+     value as condition. Various targets use different means to communicate \n+     condition in vector compare operation. Using gimple value allows compiler \n+     to emit vector compare and select RTL without exposing compare's result.  */\n+  if (!is_gimple_reg (*cond) && !is_gimple_condexpr (*cond))\n+    {\n+      tree new_stmt;\n+\n+      new_stmt = ifc_temp_var (TREE_TYPE (*cond), unshare_expr (*cond));\n+      bsi_insert_after (bsi, new_stmt, BSI_SAME_STMT);\n+      bsi_next (bsi);\n+      *cond = TREE_OPERAND (new_stmt, 0);\n+    }\n+\n+#ifdef ENABLE_CHECKING\n+  if (*cond == NULL_TREE)\n+    abort ();\n+#endif\n+\n+  return switch_args;\n+}\n+\n+\n+/* Replace PHI node with conditional modify expr using COND.  \n+   This routine does not handle PHI nodes with more than two arguments. \n+   For example,\n+     S1: A = PHI <x1(1), x2(5)\n+   is converted into,\n+     S2: A = cond ? x1 : x2;\n+   S2 is inserted at the top of basic block's statement list.\n+   PHI arguments are switched if SWITCH_ARGS is true.\n+*/\n+\n+static void\n+replace_phi_with_cond_modify_expr (tree phi, tree cond, bool switch_args,\n+                                   block_stmt_iterator *bsi)\n+{\n+  tree new_stmt;\n+  basic_block bb;\n+  tree rhs;\n+  tree arg_0, arg_1;\n+\n+#ifdef ENABLE_CHECKING\n+  if (TREE_CODE (phi) != PHI_NODE)\n+    abort ();\n+\n+  /* If this is not filtered earlier, then now it is too late.  */\n+  if (PHI_NUM_ARGS (phi) != 2)\n+     abort ();\n+#endif\n+\n+  /* Find basic block and initialize iterator.  */\n+  bb = bb_for_stmt (phi);\n+\n+  new_stmt = NULL_TREE;\n+  arg_0 = NULL_TREE;\n+  arg_1 = NULL_TREE;\n+  \n+  /* Use condition that is not TRUTH_NOT_EXPR in conditional modify expr.  */\n+  if (switch_args)\n+    {\n+      arg_0 = PHI_ARG_DEF (phi, 1);\n+      arg_1 = PHI_ARG_DEF (phi, 0);\n+    }\n+  else\n+    {\n+      arg_0 = PHI_ARG_DEF (phi, 0);\n+      arg_1 = PHI_ARG_DEF (phi, 1);\n+    }\n+\n+  /* Build new RHS using selected condtion and arguments.  */\n+  rhs = build (COND_EXPR, TREE_TYPE (PHI_RESULT (phi)),\n+\t       unshare_expr (cond), unshare_expr (arg_0),\n+\t       unshare_expr (arg_1));\n+\n+  /* Create new MODIFY expresstion using RHS.  */\n+  new_stmt = build (MODIFY_EXPR, TREE_TYPE (PHI_RESULT (phi)),\n+\t\t    unshare_expr (PHI_RESULT (phi)), rhs);\n+\n+  /* Make new statement definition of the original phi result.  */\n+  SSA_NAME_DEF_STMT (PHI_RESULT (phi)) = new_stmt;\n+\n+  /* Set basic block and insert using iterator.  */\n+  set_bb_for_stmt (new_stmt, bb);\n+\n+  bsi_insert_after (bsi, new_stmt, BSI_SAME_STMT);\n+  bsi_next (bsi);\n+\n+  modify_stmt (new_stmt);\n+\n+  if (dump_file && (dump_flags & TDF_DETAILS))\n+    {\n+      fprintf (dump_file, \"new phi replacement stmt\\n\");\n+      print_generic_stmt (dump_file, new_stmt, TDF_SLIM);\n+    }\n+}\n+\n+/* Process phi nodes for the given  LOOP.  Replace phi nodes with cond \n+   modify expr.  */\n+\n+static void\n+process_phi_nodes (struct loop *loop)\n+{\n+  basic_block bb;\n+  unsigned int orig_loop_num_nodes = loop->num_nodes;\n+  unsigned int i;\n+\n+  /* Replace phi nodes with cond. modify expr.  */\n+  for (i = 1; i < orig_loop_num_nodes; i++)\n+    {\n+      tree phi, cond;\n+      block_stmt_iterator bsi;\n+      bool switch_args = false;\n+      bb = ifc_bbs[i];\n+      \n+      if (bb == loop->header || bb == loop->latch)\n+\tcontinue;\n+\n+      phi = phi_nodes (bb);\n+      bsi = bsi_start (bb);\n+\n+      /* BB has two predecessors. Using predecessor's aux field, set\n+\t appropriate condition for the PHI node replacement.  */\n+      if (phi)\n+\tswitch_args = find_phi_replacement_condition (bb, &cond, &bsi);\n+\n+      while (phi)\n+\t{\n+\t  tree next = TREE_CHAIN (phi);\n+\t  replace_phi_with_cond_modify_expr (phi, cond, switch_args, &bsi);\n+\t  release_phi_node (phi);\n+\t  phi = next;\n+\t}\n+      bb_ann (bb)->phi_nodes = NULL;\n+    }\n+  return;\n+}\n+\n+/* Combine all basic block from the given LOOP into one or two super \n+   basic block.  Replace PHI nodes with conditional modify expression. */\n+\n+static void\n+combine_blocks (struct loop *loop)\n+{\n+  basic_block bb, exit_bb, merge_target_bb;\n+  unsigned int orig_loop_num_nodes = loop->num_nodes;\n+  unsigned int i;\n+\n+  /* Process phi nodes to prepare blocks for merge.  */\n+  process_phi_nodes (loop);\n+\n+  exit_bb = NULL;\n+\n+  /* Merge basic blocks */\n+  merge_target_bb = loop->header;\n+  for (i = 1; i < orig_loop_num_nodes; i++)\n+    {\n+      edge e;\n+      block_stmt_iterator bsi;\n+      tree_stmt_iterator last;\n+\n+      bb = ifc_bbs[i];\n+\n+      if (bb == loop->latch)\n+\tcontinue;\n+\n+      if (!exit_bb && bb_with_exit_edge_p (bb))\n+\t  exit_bb = bb;\n+\n+      if (bb == exit_bb)\n+\t{\n+\t  edge new_e;\n+\n+\t  /* Connect this node with loop header.  */\n+\t  new_e = make_edge (ifc_bbs[0], bb, EDGE_FALLTHRU);\n+\t  set_immediate_dominator (CDI_DOMINATORS, bb, ifc_bbs[0]);\n+\n+\t  if (exit_bb != loop->latch)\n+\t    {\n+\t      /* Redirect non-exit edge to loop->latch.  */\n+\t      for (e = bb->succ; e; e = e->succ_next)\n+\t\tif (!(e->flags & EDGE_LOOP_EXIT))\n+\t\t  {\n+\t\t    redirect_edge_and_branch (e, loop->latch);\n+\t\t    set_immediate_dominator (CDI_DOMINATORS, loop->latch, bb);\n+\t\t  }\n+\t    }\n+\t  continue;\n+\t}\n+\n+      /* It is time to remove this basic block.\t First remove edges.  */\n+      while (bb->succ != NULL)\n+\tssa_remove_edge (bb->succ);\n+      while (bb->pred != NULL)\n+\tssa_remove_edge (bb->pred);\n+\n+      /* Remove labels and make stmts member of loop->header.  */\n+      for (bsi = bsi_start (bb); !bsi_end_p (bsi); )\n+\t{\n+\t  if (TREE_CODE (bsi_stmt (bsi)) == LABEL_EXPR)\n+\t    bsi_remove (&bsi);\n+\t  else\n+\t    {\n+\t      set_bb_for_stmt (bsi_stmt (bsi), merge_target_bb);\n+\t      bsi_next (&bsi);\n+\t    }\n+\t}\n+\n+      /* Update stmt list.  */\n+      last = tsi_last (merge_target_bb->stmt_list);\n+      tsi_link_after (&last, bb->stmt_list, TSI_NEW_STMT);\n+      bb->stmt_list = NULL;\n+\n+      /* Update dominator info.  */\n+      if (dom_computed[CDI_DOMINATORS])\n+\tdelete_from_dominance_info (CDI_DOMINATORS, bb);\n+      if (dom_computed[CDI_POST_DOMINATORS])\n+\tdelete_from_dominance_info (CDI_POST_DOMINATORS, bb);\n+      \n+      /* Remove basic block.  */\n+      remove_bb_from_loops (bb);\n+      expunge_block (bb);\n+    }\n+}\n+\n+/* Make new  temp variable of type TYPE. Add MODIFY_EXPR to assign EXP \n+   to the new variable.  */\n+\n+static tree\n+ifc_temp_var (tree type, tree exp)\n+{\n+  const char *name = \"_ifc_\";\n+  tree var, stmt, new_name;\n+\n+  if (is_gimple_reg (exp))\n+    return exp;\n+\n+  /* Create new temporary variable.  */\n+  var = create_tmp_var (type, name);\n+  add_referenced_tmp_var (var);\n+\n+  /* Build new statement to assigne EXP to new variable.  */\n+  stmt = build (MODIFY_EXPR, type, var, exp);\n+  \n+  /* Get SSA name for the new variable and set make new statement\n+     its definition statment.  */\n+  new_name = make_ssa_name (var, stmt);\n+  TREE_OPERAND (stmt, 0) = new_name;\n+  SSA_NAME_DEF_STMT (new_name) = stmt;\n+\n+  return stmt;\n+}\n+\n+\n+/* Return TRUE iff, all pred blocks of BB are visited.\n+   Bitmap VISITED keeps history of visited blocks.  */\n+\n+static bool\n+pred_blocks_visited_p (basic_block bb, bitmap *visited)\n+{\n+  edge e;\n+  for (e = bb->pred; e; e = e->pred_next)\n+    if (!bitmap_bit_p (*visited, e->src->index))\n+      return false;\n+  \n+  return true;\n+}\n+\n+/* Get body of a LOOP in suitable order for if-conversion.\n+   It is caller's responsibility to deallocate basic block\n+   list.  If-conversion suitable order is, BFS order with one\n+   additional constraint. Select block in BFS block, if all\n+   pred are already selected.  */\n+\n+static basic_block * \n+get_loop_body_in_if_conv_order (const struct loop *loop)\n+{\n+  basic_block *blocks, *blocks_in_bfs_order;\n+  basic_block bb;\n+  bitmap visited;\n+  unsigned int index = 0;\n+  unsigned int visited_count = 0;\n+\n+  if (!loop->num_nodes)\n+    abort ();\n+  \n+  if (loop->latch == EXIT_BLOCK_PTR)\n+    abort ();\n+\n+  blocks = xcalloc (loop->num_nodes, sizeof (basic_block));\n+  visited = BITMAP_XMALLOC ();\n+\n+  blocks_in_bfs_order = get_loop_body_in_bfs_order (loop);\n+\n+  index = 0;\n+  while (index < loop->num_nodes)\n+    {\n+      bb = blocks_in_bfs_order [index];\n+      \n+      if (bb->flags & BB_IRREDUCIBLE_LOOP)\n+\t{\n+\t  free (blocks_in_bfs_order);\n+\t  BITMAP_FREE (visited);\n+\t  free (blocks);\n+\t  return NULL;\n+\t}\n+      if (!bitmap_bit_p (visited, bb->index))\n+\t{\n+\t  if (pred_blocks_visited_p (bb, &visited)\n+\t      || bb == loop->header)\n+\t    {\n+\t      /* This block is now visited.  */\n+\t      bitmap_set_bit (visited, bb->index);\n+\t      blocks[visited_count++] = bb;\n+\t    }\n+\t}\n+      index++;\n+      if (index == loop->num_nodes\n+\t  && visited_count != loop->num_nodes)\n+\t{\n+\t  /* Not done yet.  */\n+\t  index = 0;\n+\t}\n+    }\n+  free (blocks_in_bfs_order);\n+  BITMAP_XFREE (visited);\n+  return blocks;\n+}\n+\n+/* Return true if one of the basic block BB edge is loop exit.  */\n+\n+static bool\n+bb_with_exit_edge_p (basic_block bb)\n+{\n+  edge e;\n+  bool exit_edge_found = false;\n+\n+  for (e = bb->succ; e && !exit_edge_found ; e = e->succ_next)\n+    if (e->flags & EDGE_LOOP_EXIT)\n+      exit_edge_found = true;\n+\n+  return exit_edge_found;\n+}\n+\n+/* Tree if-conversion pass management.  */\n+\n+static void\n+main_tree_if_conversion (void)\n+{\n+  unsigned i, loop_num;\n+  struct loop *loop;\n+\n+  if (!current_loops)\n+    return;\n+\n+  loop_num = current_loops->num;\n+  for (i = 0; i < loop_num; i++)\n+    {\n+      loop =  current_loops->parray[i];\n+      if (!loop)\n+      continue;\n+\n+      tree_if_conversion (loop, true);\n+    }\n+\n+}\n+\n+static bool\n+gate_tree_if_conversion (void)\n+{\n+  return true;\n+}\n+\n+struct tree_opt_pass pass_if_conversion =\n+{\n+  \"ifcvt\",                           /* name */\n+  gate_tree_if_conversion,           /* gate */\n+  main_tree_if_conversion,           /* execute */\n+  NULL,                              /* sub */\n+  NULL,                              /* next */\n+  0,                                 /* static_pass_number */\n+  0,                                 /* tv_id */\n+  PROP_cfg | PROP_ssa | PROP_alias,  /* properties_required */\n+  0,                                 /* properties_provided */\n+  0,                                 /* properties_destroyed */\n+  TODO_dump_func,                    /* todo_flags_start */\n+  TODO_dump_func \n+    | TODO_verify_ssa\n+    | TODO_verify_stmts \n+    | TODO_verify_flow               /* todo_flags_finish */\n+};\n+"}, {"sha": "e3dcc95215977a481244782d05bdc64bc09888ae", "filename": "gcc/tree-optimize.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/40923b202de784a0554d6a084464da3c1be4d976/gcc%2Ftree-optimize.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/40923b202de784a0554d6a084464da3c1be4d976/gcc%2Ftree-optimize.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-optimize.c?ref=40923b202de784a0554d6a084464da3c1be4d976", "patch": "@@ -368,6 +368,7 @@ init_tree_optimization_passes (void)\n   NEXT_PASS (pass_loop_init);\n   NEXT_PASS (pass_lim);\n   NEXT_PASS (pass_iv_canon);\n+  NEXT_PASS (pass_if_conversion);\n   NEXT_PASS (pass_vectorize);\n   NEXT_PASS (pass_complete_unroll);\n   NEXT_PASS (pass_loop_done);"}, {"sha": "0712a4ec827db39d7ad64a1542cdcd9bbf801ae8", "filename": "gcc/tree-pass.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/40923b202de784a0554d6a084464da3c1be4d976/gcc%2Ftree-pass.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/40923b202de784a0554d6a084464da3c1be4d976/gcc%2Ftree-pass.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-pass.h?ref=40923b202de784a0554d6a084464da3c1be4d976", "patch": "@@ -110,6 +110,7 @@ extern struct tree_opt_pass pass_loop;\n extern struct tree_opt_pass pass_loop_init;\n extern struct tree_opt_pass pass_lim;\n extern struct tree_opt_pass pass_iv_canon;\n+extern struct tree_opt_pass pass_if_conversion;\n extern struct tree_opt_pass pass_vectorize;\n extern struct tree_opt_pass pass_complete_unroll;\n extern struct tree_opt_pass pass_loop_done;"}, {"sha": "6aad73150c27ce663531e1e62bc601518dce4927", "filename": "gcc/tree-ssa-loop-im.c", "status": "modified", "additions": 1, "deletions": 11, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/40923b202de784a0554d6a084464da3c1be4d976/gcc%2Ftree-ssa-loop-im.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/40923b202de784a0554d6a084464da3c1be4d976/gcc%2Ftree-ssa-loop-im.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-im.c?ref=40923b202de784a0554d6a084464da3c1be4d976", "patch": "@@ -47,16 +47,6 @@ struct depend\n   struct depend *next;\n };\n \n-/* The possibilities of statement movement.  */\n-\n-enum move_pos\n-{\n-  MOVE_IMPOSSIBLE,\t\t/* No movement -- side effect expression.  */\n-  MOVE_PRESERVE_EXECUTION,\t/* Must not cause the non-executed statement\n-\t\t\t\t   become executed -- memory accesses, ... */\n-  MOVE_POSSIBLE\t\t\t/* Unlimited movement.  */\n-};\n-\n /* The auxiliary data kept for each statement.  */\n \n struct lim_aux_data\n@@ -170,7 +160,7 @@ for_each_index (tree *addr_p, bool (*cbck) (tree, tree *, void *), void *data)\n    because it may trap), return MOVE_PRESERVE_EXECUTION.\n    Otherwise return MOVE_IMPOSSIBLE.  */\n \n-static enum move_pos\n+enum move_pos\n movement_possibility (tree stmt)\n {\n   tree lhs, rhs;"}, {"sha": "200f4b58f7a6fb0e8b480002c0ad0e6d088eaaf0", "filename": "gcc/tree-ssa-operands.c", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/40923b202de784a0554d6a084464da3c1be4d976/gcc%2Ftree-ssa-operands.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/40923b202de784a0554d6a084464da3c1be4d976/gcc%2Ftree-ssa-operands.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-operands.c?ref=40923b202de784a0554d6a084464da3c1be4d976", "patch": "@@ -625,7 +625,6 @@ finalize_ssa_vuses (vuse_optype *old_ops_p)\n   return vuse_ops;\n }\n \n-\n /* Return a new v_must_def operand vector for STMT, comparing to OLD_OPS_P.  */\n \n static v_must_def_optype\n@@ -1081,6 +1080,12 @@ get_expr_operands (tree stmt, tree *expr_p, int flags)\n       get_call_expr_operands (stmt, expr);\n       return;\n \n+    case COND_EXPR:\n+      get_expr_operands (stmt, &COND_EXPR_COND (expr), opf_none);\n+      get_expr_operands (stmt, &TREE_OPERAND (expr, 1), opf_none);\n+      get_expr_operands (stmt, &TREE_OPERAND (expr, 2), opf_none);\n+      return;\n+\n     case MODIFY_EXPR:\n       {\n \tint subflags;"}]}