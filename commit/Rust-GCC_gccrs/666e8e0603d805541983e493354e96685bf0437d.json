{"sha": "666e8e0603d805541983e493354e96685bf0437d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NjY2ZThlMDYwM2Q4MDU1NDE5ODNlNDkzMzU0ZTk2Njg1YmYwNDM3ZA==", "commit": {"author": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2015-01-16T13:26:10Z"}, "committer": {"name": "Richard Biener", "email": "rguenth@gcc.gnu.org", "date": "2015-01-16T13:26:10Z"}, "message": "re PR middle-end/64614 (bogus used initialized warning (in gcc 4.9.2); switch statement versus &)\n\n2015-01-16  Richard Biener  <rguenther@suse.de>\n\n\tPR middle-end/64614\n\t* tree-ssa-uninit.c: Include tree-cfg.h.\n\t(MAX_SWITCH_CASES): New define.\n\t(convert_control_dep_chain_into_preds): Handle switch statements.\n\t(is_pred_expr_subset_of): Handle x == CST vs. (x & CST) != 0.\n\t(normalize_one_pred_1): Do not split bit-manipulations.\n\tRecord (x & CST).\n\n\t* gcc.dg/uninit-18.c: New testcase.\n\nFrom-SVN: r219739", "tree": {"sha": "77c2c4cbf400083f8491986b099931ccc2a98ae0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/77c2c4cbf400083f8491986b099931ccc2a98ae0"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/666e8e0603d805541983e493354e96685bf0437d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/666e8e0603d805541983e493354e96685bf0437d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/666e8e0603d805541983e493354e96685bf0437d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/666e8e0603d805541983e493354e96685bf0437d/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "6220fdff17b91f6d1e06a119967b716f87a8e82b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6220fdff17b91f6d1e06a119967b716f87a8e82b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6220fdff17b91f6d1e06a119967b716f87a8e82b"}], "stats": {"total": 126, "additions": 117, "deletions": 9}, "files": [{"sha": "89738ad25b701cb7bb43b46e9435b203c7c939d7", "filename": "gcc/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/666e8e0603d805541983e493354e96685bf0437d/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/666e8e0603d805541983e493354e96685bf0437d/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=666e8e0603d805541983e493354e96685bf0437d", "patch": "@@ -1,3 +1,13 @@\n+2015-01-16  Richard Biener  <rguenther@suse.de>\n+\n+\tPR middle-end/64614\n+\t* tree-ssa-uninit.c: Include tree-cfg.h.\n+\t(MAX_SWITCH_CASES): New define.\n+\t(convert_control_dep_chain_into_preds): Handle switch statements.\n+\t(is_pred_expr_subset_of): Handle x == CST vs. (x & CST) != 0.\n+\t(normalize_one_pred_1): Do not split bit-manipulations.\n+\tRecord (x & CST).\n+\n 2015-01-16  Richard Biener  <rguenther@suse.de>\n \n \tPR tree-optimization/64568"}, {"sha": "b542f771434fb6abe29e28feb09a2fabd6e2aabc", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/666e8e0603d805541983e493354e96685bf0437d/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/666e8e0603d805541983e493354e96685bf0437d/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=666e8e0603d805541983e493354e96685bf0437d", "patch": "@@ -1,3 +1,8 @@\n+2015-01-16  Richard Biener  <rguenther@suse.de>\n+\n+\tPR middle-end/64614\n+\t* gcc.dg/uninit-18.c: New testcase.\n+\n 2015-01-16  Richard Biener  <rguenther@suse.de>\n \n \tPR tree-optimization/64568"}, {"sha": "223983e107e088605671f7ebabe91066a6a7dc39", "filename": "gcc/testsuite/gcc.dg/uninit-18.c", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/666e8e0603d805541983e493354e96685bf0437d/gcc%2Ftestsuite%2Fgcc.dg%2Funinit-18.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/666e8e0603d805541983e493354e96685bf0437d/gcc%2Ftestsuite%2Fgcc.dg%2Funinit-18.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Funinit-18.c?ref=666e8e0603d805541983e493354e96685bf0437d", "patch": "@@ -0,0 +1,24 @@\n+/* { dg-do compile }  */\n+/* { dg-options \"-O -Wuninitialized\" } */\n+\n+char *foo(int bar, char *baz)\n+{\n+  char *tmp;\n+\n+  if (bar & 3)\n+    tmp = baz;\n+\n+  switch (bar) {\n+  case 1:\n+    tmp[5] = 7;    /* { dg-bogus \"may be used uninitialized\" } */\n+    break;\n+  case 2:\n+    tmp[11] = 15;  /* { dg-bogus \"may be used uninitialized\" } */\n+    break;\n+  default:\n+    tmp = 0;\n+    break;\n+  }\n+\n+  return tmp;      /* { dg-bogus \"may be used uninitialized\" } */\n+}"}, {"sha": "25aae19f5667a5c95aa33ef27fb60ccc60460aed", "filename": "gcc/tree-ssa-uninit.c", "status": "modified", "additions": 78, "deletions": 9, "changes": 87, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/666e8e0603d805541983e493354e96685bf0437d/gcc%2Ftree-ssa-uninit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/666e8e0603d805541983e493354e96685bf0437d/gcc%2Ftree-ssa-uninit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-uninit.c?ref=666e8e0603d805541983e493354e96685bf0437d", "patch": "@@ -58,6 +58,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"tree-pass.h\"\n #include \"diagnostic-core.h\"\n #include \"params.h\"\n+#include \"tree-cfg.h\"\n \n /* This implements the pass that does predicate aware warning on uses of\n    possibly uninitialized variables. The pass first collects the set of\n@@ -411,6 +412,7 @@ find_control_equiv_block (basic_block bb)\n #define MAX_NUM_CHAINS 8\n #define MAX_CHAIN_LEN 5\n #define MAX_POSTDOM_CHECK 8\n+#define MAX_SWITCH_CASES 40\n \n /* Computes the control dependence chains (paths of edges)\n    for DEP_BB up to the dominating basic block BB (the head node of a\n@@ -592,17 +594,63 @@ convert_control_dep_chain_into_preds (vec<edge> *dep_chains,\n               if (skip)\n                 continue;\n             }\n-          if (gimple_code (cond_stmt) != GIMPLE_COND)\n+          if (gimple_code (cond_stmt) == GIMPLE_COND)\n+\t    {\n+\t      one_pred.pred_lhs = gimple_cond_lhs (cond_stmt);\n+\t      one_pred.pred_rhs = gimple_cond_rhs (cond_stmt);\n+\t      one_pred.cond_code = gimple_cond_code (cond_stmt);\n+\t      one_pred.invert = !!(e->flags & EDGE_FALSE_VALUE);\n+\t      t_chain.safe_push (one_pred);\n+\t      has_valid_pred = true;\n+\t    }\n+\t  else if (gswitch *gs = dyn_cast <gswitch *> (cond_stmt))\n+\t    {\n+\t      /* Avoid quadratic behavior.  */\n+\t      if (gimple_switch_num_labels (gs) > MAX_SWITCH_CASES)\n+\t\t{\n+\t\t  has_valid_pred = false;\n+\t\t  break;\n+\t\t}\n+\t      /* Find the case label.  */\n+\t      tree l = NULL_TREE;\n+\t      unsigned idx;\n+\t      for (idx = 0; idx < gimple_switch_num_labels (gs); ++idx)\n+\t\t{\n+\t\t  tree tl = gimple_switch_label (gs, idx);\n+\t\t  if (e->dest == label_to_block (CASE_LABEL (tl)))\n+\t\t    {\n+\t\t      if (!l)\n+\t\t\tl = tl;\n+\t\t      else\n+\t\t\t{\n+\t\t\t  l = NULL_TREE;\n+\t\t\t  break;\n+\t\t\t}\n+\t\t    }\n+\t\t}\n+\t      /* If more than one label reaches this block or the case\n+\t         label doesn't have a single value (like the default one)\n+\t\t fail.  */\n+\t      if (!l\n+\t\t  || !CASE_LOW (l)\n+\t\t  || (CASE_HIGH (l) && !operand_equal_p (CASE_LOW (l),\n+\t\t\t\t\t\t\t CASE_HIGH (l), 0)))\n+\t\t{\n+\t\t  has_valid_pred = false;\n+\t\t  break;\n+\t\t}\n+\t      one_pred.pred_lhs = gimple_switch_index (gs);\n+\t      one_pred.pred_rhs = CASE_LOW (l);\n+\t      one_pred.cond_code = EQ_EXPR;\n+\t      one_pred.invert = false;\n+\t      t_chain.safe_push (one_pred);\n+\t      has_valid_pred = true;\n+\t    }\n+\t  else\n             {\n               has_valid_pred = false;\n               break;\n             }\n-          one_pred.pred_lhs = gimple_cond_lhs (cond_stmt);\n-          one_pred.pred_rhs = gimple_cond_rhs (cond_stmt);\n-          one_pred.cond_code = gimple_cond_code (cond_stmt);\n-          one_pred.invert = !!(e->flags & EDGE_FALSE_VALUE);\n-          t_chain.safe_push (one_pred);\n-\t  has_valid_pred = true;\n         }\n \n       if (!has_valid_pred)\n@@ -1329,6 +1377,10 @@ is_pred_expr_subset_of (pred_info expr1, pred_info expr2)\n   if (expr2.invert)\n     code2 = invert_tree_comparison (code2, false);\n \n+  if (code1 == EQ_EXPR && code2 == BIT_AND_EXPR)\n+    return wi::eq_p (expr1.pred_rhs,\n+\t\t     wi::bit_and (expr1.pred_rhs, expr2.pred_rhs));\n+\n   if (code1 != code2 && code2 != NE_EXPR)\n     return false;\n \n@@ -1970,8 +2022,25 @@ normalize_one_pred_1 (pred_chain_union *norm_preds,\n     }\n   else if (gimple_assign_rhs_code (def_stmt) == and_or_code)\n     {\n-      push_to_worklist (gimple_assign_rhs1 (def_stmt), work_list, mark_set);\n-      push_to_worklist (gimple_assign_rhs2 (def_stmt), work_list, mark_set);\n+      /* Avoid splitting up bit manipulations like x & 3 or y | 1.  */\n+      if (is_gimple_min_invariant (gimple_assign_rhs2 (def_stmt)))\n+\t{\n+\t  /* But treat x & 3 as condition.  */\n+\t  if (and_or_code == BIT_AND_EXPR)\n+\t    {\n+\t      pred_info n_pred;\n+\t      n_pred.pred_lhs = gimple_assign_rhs1 (def_stmt);\n+\t      n_pred.pred_rhs = gimple_assign_rhs2 (def_stmt);\n+\t      n_pred.cond_code = and_or_code;\n+\t      n_pred.invert = false;\n+\t      norm_chain->safe_push (n_pred);\n+\t    }\n+\t}\n+      else\n+\t{\n+\t  push_to_worklist (gimple_assign_rhs1 (def_stmt), work_list, mark_set);\n+\t  push_to_worklist (gimple_assign_rhs2 (def_stmt), work_list, mark_set);\n+\t}\n     }\n   else if (TREE_CODE_CLASS (gimple_assign_rhs_code (def_stmt))\n \t   == tcc_comparison)"}]}