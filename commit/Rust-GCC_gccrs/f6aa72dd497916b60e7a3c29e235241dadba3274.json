{"sha": "f6aa72dd497916b60e7a3c29e235241dadba3274", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjZhYTcyZGQ0OTc5MTZiNjBlN2EzYzI5ZTIzNTI0MWRhZGJhMzI3NA==", "commit": {"author": {"name": "Manuel L\u00f3pez-Ib\u00e1\u00f1ez", "email": "manu@gcc.gnu.org", "date": "2007-05-20T20:29:55Z"}, "committer": {"name": "Manuel L\u00f3pez-Ib\u00e1\u00f1ez", "email": "manu@gcc.gnu.org", "date": "2007-05-20T20:29:55Z"}, "message": "re PR middle-end/7651 (Define -Wextra strictly in terms of other warning flags)\n\n2007-05-20  Manuel Lopez-Ibanez  <manu@gcc.gnu.org>\n\t\n\tPR middle-end/7651\n\tPR c++/11856\n\tPR c/12963\n\tPR c/23587\n\tPR other/29694\n\t* c.opt (Wtype-limits): New.\n\t* doc/invoke.texi (Wtype-limits): Document it.\n\t(Wextra): Enabled by -Wextra.\n\t* c-opts.c (c_common_post_options): Enabled by -Wextra.\n\t* c-common.c (shorten_compare): Warn with Wtype-limits.\n\ntestsuite/\n\t* gcc.dg/compare6.c: Replace Wall with Wtype-limits.\n\t* gcc.dg/Wtype-limits.c: New.\n\t* gcc.dg/Wtype-limits-Wextra.c: New.\n\t* gcc.dg/Wtype-limits-no.c: New.\n\t* g++.dg/warn/Wtype-limits.C: New.\n\t* g++.dg/warn/Wtype-limits-Wextra.C: New.\n\t* g++.dg/warn/Wtype-limits-no.C: New.\n\nFrom-SVN: r124875", "tree": {"sha": "90312ab1a9121fa6e7864a7b15bdaf3260ab1b8b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/90312ab1a9121fa6e7864a7b15bdaf3260ab1b8b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f6aa72dd497916b60e7a3c29e235241dadba3274", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f6aa72dd497916b60e7a3c29e235241dadba3274", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f6aa72dd497916b60e7a3c29e235241dadba3274", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f6aa72dd497916b60e7a3c29e235241dadba3274/comments", "author": null, "committer": null, "parents": [{"sha": "da5a2efd39b67a36c4e70f059ffbbb6103606f3e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/da5a2efd39b67a36c4e70f059ffbbb6103606f3e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/da5a2efd39b67a36c4e70f059ffbbb6103606f3e"}], "stats": {"total": 530, "additions": 515, "deletions": 15}, "files": [{"sha": "41311d9e4a685865771c6aea69cb05e83b8adbe8", "filename": "gcc/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f6aa72dd497916b60e7a3c29e235241dadba3274/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f6aa72dd497916b60e7a3c29e235241dadba3274/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=f6aa72dd497916b60e7a3c29e235241dadba3274", "patch": "@@ -1,3 +1,16 @@\n+2007-05-20  Manuel Lopez-Ibanez  <manu@gcc.gnu.org>\n+\t\n+\tPR middle-end/7651\n+\tPR c++/11856\n+\tPR c/12963\n+\tPR c/23587\n+\tPR other/29694\n+\t* c.opt (Wtype-limits): New.\n+\t* doc/invoke.texi (Wtype-limits): Document it.\n+\t(Wextra): Enabled by -Wextra.\n+\t* c-opts.c (c_common_post_options): Enabled by -Wextra.\n+\t* c-common.c (shorten_compare): Warn with Wtype-limits.\n+\n 2006-05-20  Uros Bizjak  <ubizjak@gmail.com>\n \n \t* config/i386/tmmintrin.h (_mm_alignr_epi32): Implement as always"}, {"sha": "3814bfde6676717f05785d3efcb269cd4420ddcf", "filename": "gcc/c-common.c", "status": "modified", "additions": 12, "deletions": 10, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f6aa72dd497916b60e7a3c29e235241dadba3274/gcc%2Fc-common.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f6aa72dd497916b60e7a3c29e235241dadba3274/gcc%2Fc-common.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-common.c?ref=f6aa72dd497916b60e7a3c29e235241dadba3274", "patch": "@@ -2517,9 +2517,9 @@ shorten_compare (tree *op0_ptr, tree *op1_ptr, tree *restype_ptr,\n       if (TREE_CODE (primop0) != INTEGER_CST)\n \t{\n \t  if (val == truthvalue_false_node)\n-\t    warning (0, \"comparison is always false due to limited range of data type\");\n+\t    warning (OPT_Wtype_limits, \"comparison is always false due to limited range of data type\");\n \t  if (val == truthvalue_true_node)\n-\t    warning (0, \"comparison is always true due to limited range of data type\");\n+\t    warning (OPT_Wtype_limits, \"comparison is always true due to limited range of data type\");\n \t}\n \n       if (val != 0)\n@@ -2589,24 +2589,26 @@ shorten_compare (tree *op0_ptr, tree *op1_ptr, tree *restype_ptr,\n \t  switch (code)\n \t    {\n \t    case GE_EXPR:\n-\t      /* All unsigned values are >= 0, so we warn if extra warnings\n-\t\t are requested.  However, if OP0 is a constant that is\n-\t\t >= 0, the signedness of the comparison isn't an issue,\n-\t\t so suppress the warning.  */\n-\t      if (extra_warnings && !in_system_header\n+\t      /* All unsigned values are >= 0, so we warn.  However,\n+\t\t if OP0 is a constant that is >= 0, the signedness of\n+\t\t the comparison isn't an issue, so suppress the\n+\t\t warning.  */\n+\t      if (warn_type_limits && !in_system_header\n \t\t  && !(TREE_CODE (primop0) == INTEGER_CST\n \t\t       && !TREE_OVERFLOW (convert (c_common_signed_type (type),\n \t\t\t\t\t\t   primop0))))\n-\t\twarning (0, \"comparison of unsigned expression >= 0 is always true\");\n+\t\twarning (OPT_Wtype_limits, \n+\t\t\t \"comparison of unsigned expression >= 0 is always true\");\n \t      value = truthvalue_true_node;\n \t      break;\n \n \t    case LT_EXPR:\n-\t      if (extra_warnings && !in_system_header\n+\t      if (warn_type_limits && !in_system_header\n \t\t  && !(TREE_CODE (primop0) == INTEGER_CST\n \t\t       && !TREE_OVERFLOW (convert (c_common_signed_type (type),\n \t\t\t\t\t\t   primop0))))\n-\t\twarning (0, \"comparison of unsigned expression < 0 is always false\");\n+\t\twarning (OPT_Wtype_limits, \n+\t\t\t \"comparison of unsigned expression < 0 is always false\");\n \t      value = truthvalue_false_node;\n \t      break;\n "}, {"sha": "b11e671e49bc2236a64a84f1015b88ef43d33b9d", "filename": "gcc/c-opts.c", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f6aa72dd497916b60e7a3c29e235241dadba3274/gcc%2Fc-opts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f6aa72dd497916b60e7a3c29e235241dadba3274/gcc%2Fc-opts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-opts.c?ref=f6aa72dd497916b60e7a3c29e235241dadba3274", "patch": "@@ -1059,10 +1059,13 @@ c_common_post_options (const char **pfilename)\n   if (flag_objc_exceptions && !flag_objc_sjlj_exceptions)\n     flag_exceptions = 1;\n \n-  /* -Wextra implies -Wclobbered, -Wempty-body, -Wsign-compare, \n+  /* -Wextra implies -Wtype-limits, -Wclobbered, \n+     -Wempty-body, -Wsign-compare, \n      -Wmissing-field-initializers, -Wmissing-parameter-type\n      -Wold-style-declaration, and -Woverride-init, \n      but not if explicitly overridden.  */\n+  if (warn_type_limits == -1)\n+    warn_type_limits = extra_warnings;\n   if (warn_clobbered == -1)\n     warn_clobbered = extra_warnings;\n   if (warn_empty_body == -1)"}, {"sha": "63e2bda5b4240526908046a9af3f8ea1cb2b190b", "filename": "gcc/c.opt", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f6aa72dd497916b60e7a3c29e235241dadba3274/gcc%2Fc.opt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f6aa72dd497916b60e7a3c29e235241dadba3274/gcc%2Fc.opt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc.opt?ref=f6aa72dd497916b60e7a3c29e235241dadba3274", "patch": "@@ -124,6 +124,10 @@ Wall\n C ObjC C++ ObjC++ Warning\n Enable most warning messages\n \n+Wtype-limits\n+C ObjC C++ ObjC++ Var(warn_type_limits) Init(-1) Warning\n+Warn if a comparison is always true or always false due to the limited range of the data type\n+\n Wassign-intercept\n ObjC ObjC++ Var(warn_assign_intercept) Warning\n Warn whenever an Objective-C assignment is being intercepted by the garbage collector"}, {"sha": "d8260ba120b88aa025b0fd9f5538a35d0ffddf93", "filename": "gcc/doc/invoke.texi", "status": "modified", "additions": 16, "deletions": 3, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f6aa72dd497916b60e7a3c29e235241dadba3274/gcc%2Fdoc%2Finvoke.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f6aa72dd497916b60e7a3c29e235241dadba3274/gcc%2Fdoc%2Finvoke.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Finvoke.texi?ref=f6aa72dd497916b60e7a3c29e235241dadba3274", "patch": "@@ -224,7 +224,7 @@ Objective-C and Objective-C++ Dialects}.\n @item Warning Options\n @xref{Warning Options,,Options to Request or Suppress Warnings}.\n @gccoptlist{-fsyntax-only  -pedantic  -pedantic-errors @gol\n--w  -Wextra  -Wall  -Waddress  -Waggregate-return -Warray-bounds @gol\n+-w  -Wextra  -Wall  -Waddress  -Waggregate-return  -Warray-bounds @gol\n -Wno-attributes -Wc++-compat -Wc++0x-compat -Wcast-align  -Wcast-qual  @gol\n -Wchar-subscripts -Wclobbered  -Wcomment @gol\n -Wconversion  -Wcoverage-mismatch  -Wno-deprecated-declarations @gol\n@@ -251,7 +251,7 @@ Objective-C and Objective-C++ Dialects}.\n -Wstrict-aliasing -Wstrict-aliasing=n @gol\n -Wstrict-overflow -Wstrict-overflow=@var{n} @gol\n -Wswitch  -Wswitch-default  -Wswitch-enum @gol\n--Wsystem-headers  -Wtrigraphs  -Wundef  -Wuninitialized @gol\n+-Wsystem-headers  -Wtrigraphs  -Wtype-limits  -Wundef  -Wuninitialized @gol\n -Wunknown-pragmas  -Wno-pragmas -Wunreachable-code @gol\n -Wunused  -Wunused-function  -Wunused-label  -Wunused-parameter @gol\n -Wunused-value  -Wunused-variable @gol\n@@ -3134,7 +3134,11 @@ messages for these events:\n \n @itemize @bullet\n @item\n-An unsigned value is compared against zero with @samp{<} or @samp{>=}.\n+Warn if a comparison is always true or always false due to the limited\n+range of the data type, but do not warn for constant expressions.  For\n+example, warn if an unsigned variable is compared against zero with\n+@samp{<} or @samp{>=}.  This warning can be independently controlled\n+by @option{-Wtype-limits}.\n \n @item @r{(C only)}\n Storage-class specifiers like @code{static} are not the first things\n@@ -3376,6 +3380,15 @@ convenience in calculations with @code{void *} pointers and pointers\n to functions.  In C++, warn also when an arithmetic operation involves\n @code{NULL}.  This warning is also enabled by @option{-pedantic}.\n \n+@item -Wtype-limits\n+@opindex Wtype-limits\n+@opindex Wno-type-limits\n+Warn if a comparison is always true or always false due to the limited\n+range of the data type, but do not warn for constant expressions.  For\n+example, warn if an unsigned variable is compared against zero with\n+@samp{<} or @samp{>=}.  This warning is also enabled by\n+@option{-Wextra}.\n+\n @item -Wbad-function-cast @r{(C only)}\n @opindex Wbad-function-cast\n Warn whenever a function call is cast to a non-matching type."}, {"sha": "db0a0d5ac95ab5f74040fc7f64d775c5e5f34af4", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f6aa72dd497916b60e7a3c29e235241dadba3274/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f6aa72dd497916b60e7a3c29e235241dadba3274/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=f6aa72dd497916b60e7a3c29e235241dadba3274", "patch": "@@ -1,3 +1,18 @@\n+2007-05-20  Manuel Lopez-Ibanez  <manu@gcc.gnu.org>\n+\n+\tPR middle-end/7651\n+\tPR c++/11856\n+\tPR c/12963\n+\tPR c/23587\n+\tPR other/29694\n+\t* gcc.dg/compare6.c: Replace Wall with Wtype-limits.\n+\t* gcc.dg/Wtype-limits.c: New.\n+\t* gcc.dg/Wtype-limits-Wextra.c: New.\n+\t* gcc.dg/Wtype-limits-no.c: New.\n+\t* g++.dg/warn/Wtype-limits.C: New.\n+\t* g++.dg/warn/Wtype-limits-Wextra.C: New.\n+\t* g++.dg/warn/Wtype-limits-no.C: New.\n+\n 2006-05-20  Uros Bizjak  <ubizjak@gmail.com>\n \n \t* gcc.target/i386/sse-vect-types.c: Revert 'Use \"-msse\""}, {"sha": "9cbdbe54783e1abec41eb98f8f3822ee0ac3c9e7", "filename": "gcc/testsuite/g++.dg/warn/Wtype-limits-Wextra.C", "status": "added", "additions": 84, "deletions": 0, "changes": 84, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f6aa72dd497916b60e7a3c29e235241dadba3274/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fwarn%2FWtype-limits-Wextra.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f6aa72dd497916b60e7a3c29e235241dadba3274/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fwarn%2FWtype-limits-Wextra.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fwarn%2FWtype-limits-Wextra.C?ref=f6aa72dd497916b60e7a3c29e235241dadba3274", "patch": "@@ -0,0 +1,84 @@\n+/* Test that -Wtype-limits is enabled by -Wextra.  */\n+/* { dg-do compile } */\n+/* { dg-options \"-Wextra\" } */\n+extern void assert (int);\n+\n+void a (unsigned char x)\n+{\n+  if (x < 0)  return;/* { dg-warning \"comparison is always false due to limited range of data type\" } */\n+  if (x >= 0) return;/* { dg-warning \"comparison is always true due to limited range of data type\" } */\n+  if (0 > x)  return;/* { dg-warning \"comparison is always false due to limited range of data type\" } */\n+  if (0 <= x) return;/* { dg-warning \"comparison is always true due to limited range of data type\" } */\n+  if (x <= 255) /* { dg-warning \"comparison is always true due to limited range of data type\" } */\n+    return;\n+  if (255 >= x) /* { dg-warning \"comparison is always true due to limited range of data type\" } */\n+    return;\n+  if ((int)x <= 255) /* { dg-bogus \"comparison is always true due to limited range of data type\" \"\" { xfail *-*-* } 16 } */\n+    return;\n+  if (255 >= (unsigned char) 1)\n+    return;\n+\n+}\n+\n+void b (unsigned short x)\n+{\n+  if (x < 0)  return;/* { dg-warning \"comparison is always false due to limited range of data type\" } */\n+  if (x >= 0) return;/* { dg-warning \"comparison is always true due to limited range of data type\" } */\n+  if (0 > x)  return;/* { dg-warning \"comparison is always false due to limited range of data type\" } */\n+  if (0 <= x) return;/* { dg-warning \"comparison is always true due to limited range of data type\" } */\n+}\n+\n+void c (unsigned int x)\n+{\n+  if (x < 0)  return;/* { dg-warning \"comparison of unsigned expression < 0 is always false\" } */\n+  if (x >= 0) return;/* { dg-warning \"comparison of unsigned expression >= 0 is always true\" } */\n+  if (0 > x)  return;/* { dg-warning \"comparison of unsigned expression < 0 is always false\" } */\n+  if (0 <= x) return;/* { dg-warning \"comparison of unsigned expression >= 0 is always true\" } */\n+  if (1U >= 0) return;\n+  if (1U < 0) return;\n+  if (0 <= 1U) return;\n+  if (0 > 1U) return;\n+}\n+\n+void d (unsigned long x)\n+{\n+  if (x < 0)  return;/* { dg-warning \"comparison of unsigned expression < 0 is always false\" } */\n+  if (x >= 0) return;/* { dg-warning \"comparison of unsigned expression >= 0 is always true\" } */\n+  if (0 > x)  return;/* { dg-warning \"comparison of unsigned expression < 0 is always false\" } */\n+  if (0 <= x) return;/* { dg-warning \"comparison of unsigned expression >= 0 is always true\" } */\n+}\n+\n+void e (unsigned long long x)\n+{\n+  if (x < 0)  return;/* { dg-warning \"comparison of unsigned expression < 0 is always false\" } */\n+  if (x >= 0) return;/* { dg-warning \"comparison of unsigned expression >= 0 is always true\" } */\n+  if (0 > x)  return;/* { dg-warning \"comparison of unsigned expression < 0 is always false\" } */\n+  if (0 <= x) return;/* { dg-warning \"comparison of unsigned expression >= 0 is always true\" } */\n+}\n+\n+int test (int x) \n+{\n+  if ((long long)x <= 0x123456789ABCLL) /* { dg-bogus \"comparison is always true due to limited range of data type\" \"\" { xfail *-*-* } 61 } */\n+    return 1;\n+  else \n+    return 0;\n+}\n+\n+template <typename Int, Int D>\n+void f(Int x) {\n+  assert(0 <= x and x <= D); // { dg-warning \"comparison is always true due to limited range of data type\" }\n+}\n+\n+int ff(void) {\n+  f<unsigned char, 2>(5);\n+  f<signed char, 2>(5);\n+}\n+\n+template <typename Int, Int D>\n+void g(void) {\n+  assert(0 <= D);\n+}\n+int gg(void) {\n+  g<unsigned char, 2>();\n+}\n+"}, {"sha": "5040e2657ba40ea897f1e846517557d80ad4fcd1", "filename": "gcc/testsuite/g++.dg/warn/Wtype-limits-no.C", "status": "added", "additions": 84, "deletions": 0, "changes": 84, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f6aa72dd497916b60e7a3c29e235241dadba3274/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fwarn%2FWtype-limits-no.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f6aa72dd497916b60e7a3c29e235241dadba3274/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fwarn%2FWtype-limits-no.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fwarn%2FWtype-limits-no.C?ref=f6aa72dd497916b60e7a3c29e235241dadba3274", "patch": "@@ -0,0 +1,84 @@\n+/* Test disabling -Wtype-limits.  */\n+/* { dg-do compile } */\n+/* { dg-options \"-Wextra -Wno-type-limits\" } */\n+extern void assert (int);\n+\n+void a (unsigned char x)\n+{\n+  if (x < 0)  return;/* { dg-bogus \"comparison is always false due to limited range of data type\" } */\n+  if (x >= 0) return;/* { dg-bogus \"comparison is always true due to limited range of data type\" } */\n+  if (0 > x)  return;/* { dg-bogus \"comparison is always false due to limited range of data type\" } */\n+  if (0 <= x) return;/* { dg-bogus \"comparison is always true due to limited range of data type\" } */\n+  if (x <= 255) /* { dg-bogus \"comparison is always true due to limited range of data type\" } */\n+    return;\n+  if (255 >= x) /* { dg-bogus \"comparison is always true due to limited range of data type\" } */\n+    return;\n+  if ((int)x <= 255) \n+    return;\n+  if (255 >= (unsigned char) 1)\n+    return;\n+\n+}\n+\n+void b (unsigned short x)\n+{\n+  if (x < 0)  return;/* { dg-bogus \"comparison is always false due to limited range of data type\" } */\n+  if (x >= 0) return;/* { dg-bogus \"comparison is always true due to limited range of data type\" } */\n+  if (0 > x)  return;/* { dg-bogus \"comparison is always false due to limited range of data type\" } */\n+  if (0 <= x) return;/* { dg-bogus \"comparison is always true due to limited range of data type\" } */\n+}\n+\n+void c (unsigned int x)\n+{\n+  if (x < 0)  return;/* { dg-bogus \"comparison of unsigned expression < 0 is always false\" } */\n+  if (x >= 0) return;/* { dg-bogus \"comparison of unsigned expression >= 0 is always true\" } */\n+  if (0 > x)  return;/* { dg-bogus \"comparison of unsigned expression < 0 is always false\" } */\n+  if (0 <= x) return;/* { dg-bogus \"comparison of unsigned expression >= 0 is always true\" } */\n+  if (1U >= 0) return;\n+  if (1U < 0) return;\n+  if (0 <= 1U) return;\n+  if (0 > 1U) return;\n+}\n+\n+void d (unsigned long x)\n+{\n+  if (x < 0)  return;/* { dg-bogus \"comparison of unsigned expression < 0 is always false\" } */\n+  if (x >= 0) return;/* { dg-bogus \"comparison of unsigned expression >= 0 is always true\" } */\n+  if (0 > x)  return;/* { dg-bogus \"comparison of unsigned expression < 0 is always false\" } */\n+  if (0 <= x) return;/* { dg-bogus \"comparison of unsigned expression >= 0 is always true\" } */\n+}\n+\n+void e (unsigned long long x)\n+{\n+  if (x < 0)  return;/* { dg-bogus \"comparison of unsigned expression < 0 is always false\" } */\n+  if (x >= 0) return;/* { dg-bogus \"comparison of unsigned expression >= 0 is always true\" } */\n+  if (0 > x)  return;/* { dg-bogus \"comparison of unsigned expression < 0 is always false\" } */\n+  if (0 <= x) return;/* { dg-bogus \"comparison of unsigned expression >= 0 is always true\" } */\n+}\n+\n+int test (int x) \n+{\n+  if ((long long)x <= 0x123456789ABCLL) /* { dg-bogus \"comparison is always true due to limited range of data type\" } */\n+    return 1;\n+  else \n+    return 0;\n+}\n+\n+template <typename Int, Int D>\n+void f(Int x) {\n+  assert(0 <= x and x <= D); // { dg-bogus \"comparison is always true due to limited range of data type\" }\n+}\n+\n+int ff(void) {\n+  f<unsigned char, 2>(5);\n+  f<signed char, 2>(5);\n+}\n+\n+template <typename Int, Int D>\n+void g(void) {\n+  assert(0 <= D);\n+}\n+int gg(void) {\n+  g<unsigned char, 2>();\n+}\n+"}, {"sha": "814c2a8826eba49cbe1eecedefead3977655b773", "filename": "gcc/testsuite/g++.dg/warn/Wtype-limits.C", "status": "added", "additions": 84, "deletions": 0, "changes": 84, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f6aa72dd497916b60e7a3c29e235241dadba3274/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fwarn%2FWtype-limits.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f6aa72dd497916b60e7a3c29e235241dadba3274/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fwarn%2FWtype-limits.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fwarn%2FWtype-limits.C?ref=f6aa72dd497916b60e7a3c29e235241dadba3274", "patch": "@@ -0,0 +1,84 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-Wtype-limits\" } */\n+\n+extern void assert (int);\n+\n+void a (unsigned char x)\n+{\n+  if (x < 0)  return;/* { dg-warning \"comparison is always false due to limited range of data type\" } */\n+  if (x >= 0) return;/* { dg-warning \"comparison is always true due to limited range of data type\" } */\n+  if (0 > x)  return;/* { dg-warning \"comparison is always false due to limited range of data type\" } */\n+  if (0 <= x) return;/* { dg-warning \"comparison is always true due to limited range of data type\" } */\n+  if (x <= 255) /* { dg-warning \"comparison is always true due to limited range of data type\" } */\n+    return;\n+  if (255 >= x) /* { dg-warning \"comparison is always true due to limited range of data type\" } */\n+    return;\n+  if ((int)x <= 255) /* { dg-bogus \"comparison is always true due to limited range of data type\" \"\" { xfail *-*-* } 16 } */\n+    return;\n+  if (255 >= (unsigned char) 1)\n+    return;\n+\n+}\n+\n+void b (unsigned short x)\n+{\n+  if (x < 0)  return;/* { dg-warning \"comparison is always false due to limited range of data type\" } */\n+  if (x >= 0) return;/* { dg-warning \"comparison is always true due to limited range of data type\" } */\n+  if (0 > x)  return;/* { dg-warning \"comparison is always false due to limited range of data type\" } */\n+  if (0 <= x) return;/* { dg-warning \"comparison is always true due to limited range of data type\" } */\n+}\n+\n+void c (unsigned int x)\n+{\n+  if (x < 0)  return;/* { dg-warning \"comparison of unsigned expression < 0 is always false\" } */\n+  if (x >= 0) return;/* { dg-warning \"comparison of unsigned expression >= 0 is always true\" } */\n+  if (0 > x)  return;/* { dg-warning \"comparison of unsigned expression < 0 is always false\" } */\n+  if (0 <= x) return;/* { dg-warning \"comparison of unsigned expression >= 0 is always true\" } */\n+  if (1U >= 0) return;\n+  if (1U < 0) return;\n+  if (0 <= 1U) return;\n+  if (0 > 1U) return;\n+}\n+\n+void d (unsigned long x)\n+{\n+  if (x < 0)  return;/* { dg-warning \"comparison of unsigned expression < 0 is always false\" } */\n+  if (x >= 0) return;/* { dg-warning \"comparison of unsigned expression >= 0 is always true\" } */\n+  if (0 > x)  return;/* { dg-warning \"comparison of unsigned expression < 0 is always false\" } */\n+  if (0 <= x) return;/* { dg-warning \"comparison of unsigned expression >= 0 is always true\" } */\n+}\n+\n+void e (unsigned long long x)\n+{\n+  if (x < 0)  return;/* { dg-warning \"comparison of unsigned expression < 0 is always false\" } */\n+  if (x >= 0) return;/* { dg-warning \"comparison of unsigned expression >= 0 is always true\" } */\n+  if (0 > x)  return;/* { dg-warning \"comparison of unsigned expression < 0 is always false\" } */\n+  if (0 <= x) return;/* { dg-warning \"comparison of unsigned expression >= 0 is always true\" } */\n+}\n+\n+int test (int x) \n+{\n+  if ((long long)x <= 0x123456789ABCLL) /* { dg-bogus \"comparison is always true due to limited range of data type\" \"\" { xfail *-*-* } 61 } */\n+    return 1;\n+  else \n+    return 0;\n+}\n+\n+template <typename Int, Int D>\n+void f(Int x) {\n+  assert(0 <= x and x <= D); // { dg-warning \"comparison is always true due to limited range of data type\" }\n+}\n+\n+int ff(void) {\n+  f<unsigned char, 2>(5);\n+  f<signed char, 2>(5);\n+}\n+\n+template <typename Int, Int D>\n+void g(void) {\n+  assert(0 <= D);\n+}\n+int gg(void) {\n+  g<unsigned char, 2>();\n+}\n+"}, {"sha": "ae13e73ef8b1b71cf177ac152c3912eff0217839", "filename": "gcc/testsuite/gcc.dg/Wtype-limits-Wextra.c", "status": "added", "additions": 66, "deletions": 0, "changes": 66, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f6aa72dd497916b60e7a3c29e235241dadba3274/gcc%2Ftestsuite%2Fgcc.dg%2FWtype-limits-Wextra.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f6aa72dd497916b60e7a3c29e235241dadba3274/gcc%2Ftestsuite%2Fgcc.dg%2FWtype-limits-Wextra.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2FWtype-limits-Wextra.c?ref=f6aa72dd497916b60e7a3c29e235241dadba3274", "patch": "@@ -0,0 +1,66 @@\n+/* Test that -Wtype-limits is enabled by -Wextra */\n+/* { dg-do compile } */\n+/* { dg-options \"-Wextra\" } */\n+\n+\n+void a (unsigned char x)\n+{\n+  if (x < 0)  return;/* { dg-warning \"comparison is always false due to limited range of data type\" } */\n+  if (x >= 0) return;/* { dg-warning \"comparison is always true due to limited range of data type\" } */\n+  if (0 > x)  return;/* { dg-warning \"comparison is always false due to limited range of data type\" } */\n+  if (0 <= x) return;/* { dg-warning \"comparison is always true due to limited range of data type\" } */\n+  if (x <= 255) /* { dg-warning \"comparison is always true due to limited range of data type\" } */\n+    return;\n+  if (255 >= x) /* { dg-warning \"comparison is always true due to limited range of data type\" } */\n+    return;\n+  if ((int)x <= 255) /* { dg-bogus \"comparison is always true due to limited range of data type\" \"\" { xfail *-*-* } 16 } */\n+    return;\n+  if (255 >= (unsigned char) 1)\n+    return;\n+\n+}\n+\n+void b (unsigned short x)\n+{\n+  if (x < 0)  return;/* { dg-warning \"comparison is always false due to limited range of data type\" } */\n+  if (x >= 0) return;/* { dg-warning \"comparison is always true due to limited range of data type\" } */\n+  if (0 > x)  return;/* { dg-warning \"comparison is always false due to limited range of data type\" } */\n+  if (0 <= x) return;/* { dg-warning \"comparison is always true due to limited range of data type\" } */\n+}\n+\n+void c (unsigned int x)\n+{\n+  if (x < 0)  return;/* { dg-warning \"comparison of unsigned expression < 0 is always false\" } */\n+  if (x >= 0) return;/* { dg-warning \"comparison of unsigned expression >= 0 is always true\" } */\n+  if (0 > x)  return;/* { dg-warning \"comparison of unsigned expression < 0 is always false\" } */\n+  if (0 <= x) return;/* { dg-warning \"comparison of unsigned expression >= 0 is always true\" } */\n+  if (1U >= 0) return;\n+  if (1U < 0) return;\n+  if (0 <= 1U) return;\n+  if (0 > 1U) return;\n+}\n+\n+void d (unsigned long x)\n+{\n+  if (x < 0)  return;/* { dg-warning \"comparison of unsigned expression < 0 is always false\" } */\n+  if (x >= 0) return;/* { dg-warning \"comparison of unsigned expression >= 0 is always true\" } */\n+  if (0 > x)  return;/* { dg-warning \"comparison of unsigned expression < 0 is always false\" } */\n+  if (0 <= x) return;/* { dg-warning \"comparison of unsigned expression >= 0 is always true\" } */\n+}\n+\n+void e (unsigned long long x)\n+{\n+  if (x < 0)  return;/* { dg-warning \"comparison of unsigned expression < 0 is always false\" } */\n+  if (x >= 0) return;/* { dg-warning \"comparison of unsigned expression >= 0 is always true\" } */\n+  if (0 > x)  return;/* { dg-warning \"comparison of unsigned expression < 0 is always false\" } */\n+  if (0 <= x) return;/* { dg-warning \"comparison of unsigned expression >= 0 is always true\" } */\n+}\n+\n+int test (int x) \n+{\n+  if ((long long)x <= 0x123456789ABCLL) /* { dg-bogus \"comparison is always true due to limited range of data type\" \"\" { xfail *-*-* } 61 } */\n+    return 1;\n+  else \n+    return 0;\n+}\n+"}, {"sha": "2af909abfa6786b99c9d7eaa894aea9f5c506658", "filename": "gcc/testsuite/gcc.dg/Wtype-limits-no.c", "status": "added", "additions": 66, "deletions": 0, "changes": 66, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f6aa72dd497916b60e7a3c29e235241dadba3274/gcc%2Ftestsuite%2Fgcc.dg%2FWtype-limits-no.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f6aa72dd497916b60e7a3c29e235241dadba3274/gcc%2Ftestsuite%2Fgcc.dg%2FWtype-limits-no.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2FWtype-limits-no.c?ref=f6aa72dd497916b60e7a3c29e235241dadba3274", "patch": "@@ -0,0 +1,66 @@\n+/* Test disabling -Wtype-limits */\n+/* { dg-do compile } */\n+/* { dg-options \"-Wextra -Wno-type-limits\" } */\n+\n+\n+void a (unsigned char x)\n+{\n+  if (x < 0)  return;/* { dg-bogus \"comparison is always false due to limited range of data type\" } */\n+  if (x >= 0) return;/* { dg-bogus \"comparison is always true due to limited range of data type\" } */\n+  if (0 > x)  return;/* { dg-bogus \"comparison is always false due to limited range of data type\" } */\n+  if (0 <= x) return;/* { dg-bogus \"comparison is always true due to limited range of data type\" } */\n+  if (x <= 255) /* { dg-bogus \"comparison is always true due to limited range of data type\" } */\n+    return;\n+  if (255 >= x) /* { dg-bogus \"comparison is always true due to limited range of data type\" } */\n+    return;\n+  if ((int)x <= 255)\n+    return;\n+  if (255 >= (unsigned char) 1)\n+    return;\n+\n+}\n+\n+void b (unsigned short x)\n+{\n+  if (x < 0)  return;/* { dg-bogus \"comparison is always false due to limited range of data type\" } */\n+  if (x >= 0) return;/* { dg-bogus \"comparison is always true due to limited range of data type\" } */\n+  if (0 > x)  return;/* { dg-bogus \"comparison is always false due to limited range of data type\" } */\n+  if (0 <= x) return;/* { dg-bogus \"comparison is always true due to limited range of data type\" } */\n+}\n+\n+void c (unsigned int x)\n+{\n+  if (x < 0)  return;/* { dg-bogus \"comparison of unsigned expression < 0 is always false\" } */\n+  if (x >= 0) return;/* { dg-bogus \"comparison of unsigned expression >= 0 is always true\" } */\n+  if (0 > x)  return;/* { dg-bogus \"comparison of unsigned expression < 0 is always false\" } */\n+  if (0 <= x) return;/* { dg-bogus \"comparison of unsigned expression >= 0 is always true\" } */\n+  if (1U >= 0) return;\n+  if (1U < 0) return;\n+  if (0 <= 1U) return;\n+  if (0 > 1U) return;\n+}\n+\n+void d (unsigned long x)\n+{\n+  if (x < 0)  return;/* { dg-bogus \"comparison of unsigned expression < 0 is always false\" } */\n+  if (x >= 0) return;/* { dg-bogus \"comparison of unsigned expression >= 0 is always true\" } */\n+  if (0 > x)  return;/* { dg-bogus \"comparison of unsigned expression < 0 is always false\" } */\n+  if (0 <= x) return;/* { dg-bogus \"comparison of unsigned expression >= 0 is always true\" } */\n+}\n+\n+void e (unsigned long long x)\n+{\n+  if (x < 0)  return;/* { dg-bogus \"comparison of unsigned expression < 0 is always false\" } */\n+  if (x >= 0) return;/* { dg-bogus \"comparison of unsigned expression >= 0 is always true\" } */\n+  if (0 > x)  return;/* { dg-bogus \"comparison of unsigned expression < 0 is always false\" } */\n+  if (0 <= x) return;/* { dg-bogus \"comparison of unsigned expression >= 0 is always true\" } */\n+}\n+\n+int test (int x) \n+{\n+  if ((long long)x <= 0x123456789ABCLL) \n+    return 1;\n+  else \n+    return 0;\n+}\n+"}, {"sha": "64e7da61c9a03367a378e6fd36e3f045684dc156", "filename": "gcc/testsuite/gcc.dg/Wtype-limits.c", "status": "added", "additions": 66, "deletions": 0, "changes": 66, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f6aa72dd497916b60e7a3c29e235241dadba3274/gcc%2Ftestsuite%2Fgcc.dg%2FWtype-limits.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f6aa72dd497916b60e7a3c29e235241dadba3274/gcc%2Ftestsuite%2Fgcc.dg%2FWtype-limits.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2FWtype-limits.c?ref=f6aa72dd497916b60e7a3c29e235241dadba3274", "patch": "@@ -0,0 +1,66 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-Wtype-limits\" } */\n+\n+\n+\n+void a (unsigned char x)\n+{\n+  if (x < 0)  return;/* { dg-warning \"comparison is always false due to limited range of data type\" } */\n+  if (x >= 0) return;/* { dg-warning \"comparison is always true due to limited range of data type\" } */\n+  if (0 > x)  return;/* { dg-warning \"comparison is always false due to limited range of data type\" } */\n+  if (0 <= x) return;/* { dg-warning \"comparison is always true due to limited range of data type\" } */\n+  if (x <= 255) /* { dg-warning \"comparison is always true due to limited range of data type\" } */\n+    return;\n+  if (255 >= x) /* { dg-warning \"comparison is always true due to limited range of data type\" } */\n+    return;\n+  if ((int)x <= 255) /* { dg-bogus \"comparison is always true due to limited range of data type\" \"\" { xfail *-*-* } 16 } */\n+    return;\n+  if (255 >= (unsigned char) 1)\n+    return;\n+\n+}\n+\n+void b (unsigned short x)\n+{\n+  if (x < 0)  return;/* { dg-warning \"comparison is always false due to limited range of data type\" } */\n+  if (x >= 0) return;/* { dg-warning \"comparison is always true due to limited range of data type\" } */\n+  if (0 > x)  return;/* { dg-warning \"comparison is always false due to limited range of data type\" } */\n+  if (0 <= x) return;/* { dg-warning \"comparison is always true due to limited range of data type\" } */\n+}\n+\n+void c (unsigned int x)\n+{\n+  if (x < 0)  return;/* { dg-warning \"comparison of unsigned expression < 0 is always false\" } */\n+  if (x >= 0) return;/* { dg-warning \"comparison of unsigned expression >= 0 is always true\" } */\n+  if (0 > x)  return;/* { dg-warning \"comparison of unsigned expression < 0 is always false\" } */\n+  if (0 <= x) return;/* { dg-warning \"comparison of unsigned expression >= 0 is always true\" } */\n+  if (1U >= 0) return;\n+  if (1U < 0) return;\n+  if (0 <= 1U) return;\n+  if (0 > 1U) return;\n+}\n+\n+void d (unsigned long x)\n+{\n+  if (x < 0)  return;/* { dg-warning \"comparison of unsigned expression < 0 is always false\" } */\n+  if (x >= 0) return;/* { dg-warning \"comparison of unsigned expression >= 0 is always true\" } */\n+  if (0 > x)  return;/* { dg-warning \"comparison of unsigned expression < 0 is always false\" } */\n+  if (0 <= x) return;/* { dg-warning \"comparison of unsigned expression >= 0 is always true\" } */\n+}\n+\n+void e (unsigned long long x)\n+{\n+  if (x < 0)  return;/* { dg-warning \"comparison of unsigned expression < 0 is always false\" } */\n+  if (x >= 0) return;/* { dg-warning \"comparison of unsigned expression >= 0 is always true\" } */\n+  if (0 > x)  return;/* { dg-warning \"comparison of unsigned expression < 0 is always false\" } */\n+  if (0 <= x) return;/* { dg-warning \"comparison of unsigned expression >= 0 is always true\" } */\n+}\n+\n+int test (int x) \n+{\n+  if ((long long)x <= 0x123456789ABCLL) /* { dg-bogus \"comparison is always true due to limited range of data type\" \"\" { xfail *-*-* } 61 } */\n+    return 1;\n+  else \n+    return 0;\n+}\n+"}, {"sha": "72f50207b03c5b226505d956528bad7767254ec4", "filename": "gcc/testsuite/gcc.dg/compare6.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f6aa72dd497916b60e7a3c29e235241dadba3274/gcc%2Ftestsuite%2Fgcc.dg%2Fcompare6.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f6aa72dd497916b60e7a3c29e235241dadba3274/gcc%2Ftestsuite%2Fgcc.dg%2Fcompare6.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fcompare6.c?ref=f6aa72dd497916b60e7a3c29e235241dadba3274", "patch": "@@ -1,7 +1,7 @@\n /* PR c/2098 */\n /* Test for a warning on comparison on out-of-range data.  */\n /* { dg-do compile { xfail c4x-*-* } } */\n-/* { dg-options \"-Wall\" } */\n+/* { dg-options \"-Wtype-limits\" } */\n \n signed char sc;\n unsigned char uc;"}]}