{"sha": "fdb33708b4393f5794a726497c71aadc5d9dfe65", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZmRiMzM3MDhiNDM5M2Y1Nzk0YTcyNjQ5N2M3MWFhZGM1ZDlkZmU2NQ==", "commit": {"author": {"name": "Roger Sayle", "email": "roger@eyesopen.com", "date": "2004-01-20T22:59:59Z"}, "committer": {"name": "Roger Sayle", "email": "sayle@gcc.gnu.org", "date": "2004-01-20T22:59:59Z"}, "message": "fold-const.c (fold_convert): Rename to fold_convert_const.\n\n\n\t* fold-const.c (fold_convert): Rename to fold_convert_const.\n\t(fold_convert_const): Change arguments to take a tree_code,\n\ta type and the operand/expression to be converted.  Return\n\tNULL_TREE if no simplification is possible.  Add support for\n\tFIX_CEIL_EXPR and FIX_FLOOR_EXPR in addition to FIX_TRUNC_EXPR.\n\t(fold): Handle FIX_CEIL_EXPR and FIX_FLOOR_EXPR.\n\tAdjust call to fold_convert to match new fold_convert_const.\n\tAvoid modifying the tree passed to fold in-place.\n\nFrom-SVN: r76237", "tree": {"sha": "7c1875f2cf72e5a1fe76b5d2b14fbd92343c68dc", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/7c1875f2cf72e5a1fe76b5d2b14fbd92343c68dc"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/fdb33708b4393f5794a726497c71aadc5d9dfe65", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fdb33708b4393f5794a726497c71aadc5d9dfe65", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fdb33708b4393f5794a726497c71aadc5d9dfe65", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fdb33708b4393f5794a726497c71aadc5d9dfe65/comments", "author": null, "committer": null, "parents": [{"sha": "34c80057fcd1c1019fa93f44483842e1d1c9cc55", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/34c80057fcd1c1019fa93f44483842e1d1c9cc55", "html_url": "https://github.com/Rust-GCC/gccrs/commit/34c80057fcd1c1019fa93f44483842e1d1c9cc55"}], "stats": {"total": 88, "additions": 55, "deletions": 33}, "files": [{"sha": "497575ac213472ec786b66896400dac35b4529a8", "filename": "gcc/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fdb33708b4393f5794a726497c71aadc5d9dfe65/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fdb33708b4393f5794a726497c71aadc5d9dfe65/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=fdb33708b4393f5794a726497c71aadc5d9dfe65", "patch": "@@ -1,3 +1,14 @@\n+2004-01-20  Roger Sayle  <roger@eyesopen.com>\n+\n+\t* fold-const.c (fold_convert): Rename to fold_convert_const.\n+\t(fold_convert_const): Change arguments to take a tree_code,\n+\ta type and the operand/expression to be converted.  Return\n+\tNULL_TREE if no simplification is possible.  Add support for\n+\tFIX_CEIL_EXPR and FIX_FLOOR_EXPR in addition to FIX_TRUNC_EXPR.\n+\t(fold): Handle FIX_CEIL_EXPR and FIX_FLOOR_EXPR.\n+\tAdjust call to fold_convert to match new fold_convert_const.\n+\tAvoid modifying the tree passed to fold in-place.\n+\n 2004-01-21  Alan Modra  <amodra@bigpond.net.au>\n \n \t* config/rs6000/sysv4.h (DWARF2_FRAME_REG_OUT): Define."}, {"sha": "d29b86e067ed2c58350996f483b9b91f49369c24", "filename": "gcc/fold-const.c", "status": "modified", "additions": 44, "deletions": 33, "changes": 77, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fdb33708b4393f5794a726497c71aadc5d9dfe65/gcc%2Ffold-const.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fdb33708b4393f5794a726497c71aadc5d9dfe65/gcc%2Ffold-const.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffold-const.c?ref=fdb33708b4393f5794a726497c71aadc5d9dfe65", "patch": "@@ -1,6 +1,6 @@\n /* Fold a constant sub-tree into a single node for C-compiler\n    Copyright (C) 1987, 1988, 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999,\n-   2000, 2001, 2002, 2003 Free Software Foundation, Inc.\n+   2000, 2001, 2002, 2003, 2004 Free Software Foundation, Inc.\n \n This file is part of GCC.\n \n@@ -69,7 +69,7 @@ static tree int_const_binop (enum tree_code, tree, tree, int);\n static tree const_binop (enum tree_code, tree, tree, int);\n static hashval_t size_htab_hash (const void *);\n static int size_htab_eq (const void *, const void *);\n-static tree fold_convert (tree, tree);\n+static tree fold_convert_const (enum tree_code, tree, tree);\n static enum tree_code invert_tree_comparison (enum tree_code);\n static enum tree_code swap_tree_comparison (enum tree_code);\n static int comparison_to_compcode (enum tree_code);\n@@ -1657,14 +1657,17 @@ size_diffop (tree arg0, tree arg1)\n }\n \f\n \n-/* Given T, a tree representing type conversion of ARG1, a constant,\n-   return a constant tree representing the result of conversion.  */\n+/* Attempt to fold type conversion operation CODE of expression ARG1 to\n+   type TYPE.  If no simplification can be done return NULL_TREE.  */\n \n static tree\n-fold_convert (tree t, tree arg1)\n+fold_convert_const (enum tree_code code, tree type, tree arg1)\n {\n-  tree type = TREE_TYPE (t);\n   int overflow = 0;\n+  tree t;\n+\n+  if (TREE_TYPE (arg1) == type)\n+    return arg1;\n \n   if (POINTER_TYPE_P (type) || INTEGRAL_TYPE_P (type))\n     {\n@@ -1673,7 +1676,7 @@ fold_convert (tree t, tree arg1)\n \t  /* If we would build a constant wider than GCC supports,\n \t     leave the conversion unfolded.  */\n \t  if (TYPE_PRECISION (type) > 2 * HOST_BITS_PER_WIDE_INT)\n-\t    return t;\n+\t    return NULL_TREE;\n \n \t  /* If we are trying to make a sizetype for a small integer, use\n \t     size_int to pick up cached types to reduce duplicate nodes.  */\n@@ -1701,6 +1704,7 @@ fold_convert (tree t, tree arg1)\n \t       || TREE_OVERFLOW (arg1));\n \t  TREE_CONSTANT_OVERFLOW (t)\n \t    = TREE_OVERFLOW (t) | TREE_CONSTANT_OVERFLOW (arg1);\n+\t  return t;\n \t}\n       else if (TREE_CODE (arg1) == REAL_CST)\n \t{\n@@ -1715,25 +1719,43 @@ fold_convert (tree t, tree arg1)\n \n \t  HOST_WIDE_INT high, low;\n \n+\t  REAL_VALUE_TYPE r;\n \t  REAL_VALUE_TYPE x = TREE_REAL_CST (arg1);\n-\t  /* If x is NaN, return zero and show we have an overflow.  */\n-\t  if (REAL_VALUE_ISNAN (x))\n+\n+\t  switch (code)\n+\t    {\n+\t    case FIX_TRUNC_EXPR:\n+\t      real_trunc (&r, VOIDmode, &x);\n+\t      break;\n+\n+\t    case FIX_CEIL_EXPR:\n+\t      real_ceil (&r, VOIDmode, &x);\n+\t      break;\n+\n+\t    case FIX_FLOOR_EXPR:\n+\t      real_floor (&r, VOIDmode, &x);\n+\t      break;\n+\n+\t    default:\n+\t      abort ();\n+\t    }\n+\n+\t  /* If R is NaN, return zero and show we have an overflow.  */\n+\t  if (REAL_VALUE_ISNAN (r))\n \t    {\n \t      overflow = 1;\n \t      high = 0;\n \t      low = 0;\n \t    }\n \n-\t  /* See if X will be in range after truncation towards 0.\n-\t     To compensate for truncation, move the bounds away from 0,\n-\t     but reject if X exactly equals the adjusted bounds.  */\n+\t  /* See if R is less than the lower bound or greater than the\n+\t     upper bound.  */\n \n \t  if (! overflow)\n \t    {\n \t      tree lt = TYPE_MIN_VALUE (type);\n \t      REAL_VALUE_TYPE l = real_value_from_int_cst (NULL_TREE, lt);\n-\t      REAL_ARITHMETIC (l, MINUS_EXPR, l, dconst1);\n-\t      if (! REAL_VALUES_LESS (l, x))\n+\t      if (REAL_VALUES_LESS (r, l))\n \t\t{\n \t\t  overflow = 1;\n \t\t  high = TREE_INT_CST_HIGH (lt);\n@@ -1747,8 +1769,7 @@ fold_convert (tree t, tree arg1)\n \t      if (ut)\n \t\t{\n \t\t  REAL_VALUE_TYPE u = real_value_from_int_cst (NULL_TREE, ut);\n-\t\t  REAL_ARITHMETIC (u, PLUS_EXPR, u, dconst1);\n-\t\t  if (! REAL_VALUES_LESS (x, u))\n+\t\t  if (REAL_VALUES_LESS (u, r))\n \t\t    {\n \t\t      overflow = 1;\n \t\t      high = TREE_INT_CST_HIGH (ut);\n@@ -1758,16 +1779,16 @@ fold_convert (tree t, tree arg1)\n \t    }\n \n \t  if (! overflow)\n-\t    REAL_VALUE_TO_INT (&low, &high, x);\n+\t    REAL_VALUE_TO_INT (&low, &high, r);\n \n \t  t = build_int_2 (low, high);\n \t  TREE_TYPE (t) = type;\n \t  TREE_OVERFLOW (t)\n \t    = TREE_OVERFLOW (arg1) | force_fit_type (t, overflow);\n \t  TREE_CONSTANT_OVERFLOW (t)\n \t    = TREE_OVERFLOW (t) | TREE_CONSTANT_OVERFLOW (arg1);\n+\t  return t;\n \t}\n-      TREE_TYPE (t) = type;\n     }\n   else if (TREE_CODE (type) == REAL_TYPE)\n     {\n@@ -1795,8 +1816,7 @@ fold_convert (tree t, tree arg1)\n \t  return t;\n \t}\n     }\n-  TREE_CONSTANT (t) = 1;\n-  return t;\n+  return NULL_TREE;\n }\n \f\n /* Return an expr equal to X but certainly not valid as an lvalue.  */\n@@ -5432,8 +5452,8 @@ fold (tree expr)\n     case FLOAT_EXPR:\n     case CONVERT_EXPR:\n     case FIX_TRUNC_EXPR:\n-      /* Other kinds of FIX are not handled properly by fold_convert.  */\n-\n+    case FIX_CEIL_EXPR:\n+    case FIX_FLOOR_EXPR:\n       if (TREE_TYPE (TREE_OPERAND (t, 0)) == TREE_TYPE (t))\n \treturn TREE_OPERAND (t, 0);\n \n@@ -5577,17 +5597,8 @@ fold (tree expr)\n \t\t\t\tconvert (TREE_TYPE (t), and1)));\n \t}\n \n-      if (!wins)\n-\t{\n-\t  if (TREE_CONSTANT (t) != TREE_CONSTANT (arg0))\n-\t    {\n-\t      if (t == orig_t)\n-\t\tt = copy_node (t);\n-\t      TREE_CONSTANT (t) = TREE_CONSTANT (arg0);\n-\t    }\n-\t  return t;\n-\t}\n-      return fold_convert (t, arg0);\n+      tem = fold_convert_const (code, TREE_TYPE (t), arg0);\n+      return tem ? tem : t;\n \n     case VIEW_CONVERT_EXPR:\n       if (TREE_CODE (TREE_OPERAND (t, 0)) == VIEW_CONVERT_EXPR)"}]}