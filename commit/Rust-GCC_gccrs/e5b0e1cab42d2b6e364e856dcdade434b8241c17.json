{"sha": "e5b0e1cab42d2b6e364e856dcdade434b8241c17", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTViMGUxY2FiNDJkMmI2ZTM2NGU4NTZkY2RhZGU0MzRiODI0MWMxNw==", "commit": {"author": {"name": "Vladimir Makarov", "email": "vmakarov@redhat.com", "date": "2011-04-04T20:19:45Z"}, "committer": {"name": "Vladimir Makarov", "email": "vmakarov@gcc.gnu.org", "date": "2011-04-04T20:19:45Z"}, "message": "re PR target/48380 (ICE in postreload.c while building trunk)\n\n2011-04-01  Vladimir Makarov  <vmakarov@redhat.com>\n\n\tPR target/48380\n\t* ira.c (ira): Call grow_reg_equivs when fix_reg_equiv_init is\n          not called.\n\n\t* ira-emit.c (emit_move_list): Update reg equiv init insn list.\n\nFrom-SVN: r171951", "tree": {"sha": "d2e5f25caa57b1f1ca4267f71b4e8b1c72221732", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d2e5f25caa57b1f1ca4267f71b4e8b1c72221732"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e5b0e1cab42d2b6e364e856dcdade434b8241c17", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e5b0e1cab42d2b6e364e856dcdade434b8241c17", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e5b0e1cab42d2b6e364e856dcdade434b8241c17", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e5b0e1cab42d2b6e364e856dcdade434b8241c17/comments", "author": {"login": "vnmakarov", "id": 9855671, "node_id": "MDQ6VXNlcjk4NTU2NzE=", "avatar_url": "https://avatars.githubusercontent.com/u/9855671?v=4", "gravatar_id": "", "url": "https://api.github.com/users/vnmakarov", "html_url": "https://github.com/vnmakarov", "followers_url": "https://api.github.com/users/vnmakarov/followers", "following_url": "https://api.github.com/users/vnmakarov/following{/other_user}", "gists_url": "https://api.github.com/users/vnmakarov/gists{/gist_id}", "starred_url": "https://api.github.com/users/vnmakarov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/vnmakarov/subscriptions", "organizations_url": "https://api.github.com/users/vnmakarov/orgs", "repos_url": "https://api.github.com/users/vnmakarov/repos", "events_url": "https://api.github.com/users/vnmakarov/events{/privacy}", "received_events_url": "https://api.github.com/users/vnmakarov/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "a3935ffcb75885f82b3034c8b45bc54b14b49cff", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a3935ffcb75885f82b3034c8b45bc54b14b49cff", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a3935ffcb75885f82b3034c8b45bc54b14b49cff"}], "stats": {"total": 53, "additions": 41, "deletions": 12}, "files": [{"sha": "659ea8355cf92d2d7d90d7cfdfa71a14e319a9ce", "filename": "gcc/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e5b0e1cab42d2b6e364e856dcdade434b8241c17/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e5b0e1cab42d2b6e364e856dcdade434b8241c17/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=e5b0e1cab42d2b6e364e856dcdade434b8241c17", "patch": "@@ -1,3 +1,11 @@\n+2011-04-01  Vladimir Makarov  <vmakarov@redhat.com>\n+\n+\tPR target/48380\n+\t* ira.c (ira): Call grow_reg_equivs when fix_reg_equiv_init is\n+          not called.\n+\n+\t* ira-emit.c (emit_move_list): Update reg equiv init insn list.\n+\n 2011-04-04  Steven Bosscher  <steven@gcc.gnu.org>\n \n \t* cprop.c (struct expr): Split 'expr' field in 'dest' and 'src'."}, {"sha": "0219342d4c50f9be882c9f26db6584c8b3eb63b9", "filename": "gcc/ira-emit.c", "status": "modified", "additions": 29, "deletions": 7, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e5b0e1cab42d2b6e364e856dcdade434b8241c17/gcc%2Fira-emit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e5b0e1cab42d2b6e364e856dcdade434b8241c17/gcc%2Fira-emit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fira-emit.c?ref=e5b0e1cab42d2b6e364e856dcdade434b8241c17", "patch": "@@ -900,8 +900,8 @@ modify_move_list (move_t list)\n static rtx\n emit_move_list (move_t list, int freq)\n {\n-  int cost;\n-  rtx result, insn;\n+  int cost, regno;\n+  rtx result, insn, set, to;\n   enum machine_mode mode;\n   enum reg_class aclass;\n \n@@ -913,12 +913,34 @@ emit_move_list (move_t list, int freq)\n \t\t      allocno_emit_reg (list->from));\n       list->insn = get_insns ();\n       end_sequence ();\n-      /* The reload needs to have set up insn codes.  If the reload\n-\t sets up insn codes by itself, it may fail because insns will\n-\t have hard registers instead of pseudos and there may be no\n-\t machine insn with given hard registers.  */\n       for (insn = list->insn; insn != NULL_RTX; insn = NEXT_INSN (insn))\n-\trecog_memoized (insn);\n+\t{\n+\t  /* The reload needs to have set up insn codes.  If the\n+\t     reload sets up insn codes by itself, it may fail because\n+\t     insns will have hard registers instead of pseudos and\n+\t     there may be no machine insn with given hard\n+\t     registers.  */\n+\t  recog_memoized (insn);\n+\t  /* Add insn to equiv init insn list if it is necessary.\n+\t     Otherwise reload will not remove this insn if it decides\n+\t     to use the equivalence.  */\n+\t  if ((set = single_set (insn)) != NULL_RTX)\n+\t    {\n+\t      to = SET_DEST (set);\n+\t      if (GET_CODE (to) == SUBREG)\n+\t\tto = SUBREG_REG (to);\n+\t      ira_assert (REG_P (to));\n+\t      regno = REGNO (to);\n+\t      if (regno >= ira_reg_equiv_len\n+\t\t  || (! ira_reg_equiv_invariant_p[regno]\n+\t\t      && ira_reg_equiv_const[regno] == NULL_RTX))\n+\t\tcontinue; /* regno has no equivalence.  */\n+\t      ira_assert ((int) VEC_length (reg_equivs_t, reg_equivs)\n+\t\t\t  >= ira_reg_equiv_len);\n+\t      reg_equiv_init (regno)\n+\t\t= gen_rtx_INSN_LIST (VOIDmode, insn, reg_equiv_init (regno));\n+\t    }\n+\t}\n       emit_insn (list->insn);\n       mode = ALLOCNO_MODE (list->to);\n       aclass = ALLOCNO_CLASS (list->to);"}, {"sha": "79deab6344ddf84a15654015bcba774abbc09e78", "filename": "gcc/ira.c", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e5b0e1cab42d2b6e364e856dcdade434b8241c17/gcc%2Fira.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e5b0e1cab42d2b6e364e856dcdade434b8241c17/gcc%2Fira.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fira.c?ref=e5b0e1cab42d2b6e364e856dcdade434b8241c17", "patch": "@@ -3657,8 +3657,6 @@ ira (FILE *f)\n   if (delete_trivially_dead_insns (get_insns (), max_reg_num ()))\n     df_analyze ();\n \n-  grow_reg_equivs ();\n-\n   if (max_regno != max_regno_before_ira)\n     {\n       regstat_free_n_sets_and_refs ();\n@@ -3667,10 +3665,10 @@ ira (FILE *f)\n       regstat_compute_ri ();\n     }\n \n-  allocate_initial_values (reg_equivs);\n-\n   overall_cost_before = ira_overall_cost;\n-  if (ira_conflicts_p)\n+  if (! ira_conflicts_p)\n+    grow_reg_equivs ();\n+  else\n     {\n       fix_reg_equiv_init ();\n \n@@ -3686,6 +3684,7 @@ ira (FILE *f)\n       memset (ira_spilled_reg_stack_slots, 0,\n \t      max_regno * sizeof (struct ira_spilled_reg_stack_slot));\n     }\n+  allocate_initial_values (reg_equivs);\n \n   timevar_pop (TV_IRA);\n "}]}