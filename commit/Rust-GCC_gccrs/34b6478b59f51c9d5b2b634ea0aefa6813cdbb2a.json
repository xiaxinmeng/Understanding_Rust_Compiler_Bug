{"sha": "34b6478b59f51c9d5b2b634ea0aefa6813cdbb2a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzRiNjQ3OGI1OWY1MWM5ZDViMmI2MzRlYTBhZWZhNjgxM2NkYmIyYQ==", "commit": {"author": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "1998-03-22T22:35:21Z"}, "committer": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "1998-03-22T22:35:21Z"}, "message": "More merge stuff.\n\nFrom-SVN: r18769", "tree": {"sha": "b7cee5292ee53741f0bc31e22fd7b26155c2854a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b7cee5292ee53741f0bc31e22fd7b26155c2854a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/34b6478b59f51c9d5b2b634ea0aefa6813cdbb2a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/34b6478b59f51c9d5b2b634ea0aefa6813cdbb2a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/34b6478b59f51c9d5b2b634ea0aefa6813cdbb2a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/34b6478b59f51c9d5b2b634ea0aefa6813cdbb2a/comments", "author": null, "committer": null, "parents": [{"sha": "b19e662bb2109abc394beeb819bc7f65a9bd5ec1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b19e662bb2109abc394beeb819bc7f65a9bd5ec1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b19e662bb2109abc394beeb819bc7f65a9bd5ec1"}], "stats": {"total": 45, "additions": 7, "deletions": 38}, "files": [{"sha": "f200d12e3c7a830cc011489711e9a4e936734c11", "filename": "texinfo/info/man.c", "status": "modified", "additions": 2, "deletions": 8, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/34b6478b59f51c9d5b2b634ea0aefa6813cdbb2a/texinfo%2Finfo%2Fman.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/34b6478b59f51c9d5b2b634ea0aefa6813cdbb2a/texinfo%2Finfo%2Fman.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/texinfo%2Finfo%2Fman.c?ref=34b6478b59f51c9d5b2b634ea0aefa6813cdbb2a", "patch": "@@ -1,5 +1,5 @@\n /*  man.c: How to read and format man files.\n-    $Id: man.c,v 1.4 1998/03/22 21:47:54 law Exp $\n+    $Id: man.c,v 1.5 1998/03/22 22:35:19 law Exp $\n \n    Copyright (C) 1995, 97 Free Software Foundation, Inc.\n \n@@ -32,10 +32,6 @@\n #include \"tilde.h\"\n #include \"man.h\"\n \n-#if !defined (SIGCHLD) && defined (SIGCLD)\n-#define SIGCHLD\tSIGCLD\n-#endif\n-\n #if !defined (_POSIX_VERSION)\n #define pid_t int\n #endif\n@@ -48,8 +44,6 @@\n #  endif /* !hpux */\n #endif /* FD_SET */\n \n-extern char *getenv ();\n-\n static char *read_from_fd ();\n static void clean_manpage ();\n static NODE *manpage_node_of_file_buffer ();\n@@ -175,7 +169,7 @@ executable_file_in_path (filename, path)\n static char *\n find_man_formatter ()\n {\n-  return (executable_file_in_path (\"man\", getenv (\"PATH\")));\n+  return (executable_file_in_path (\"man\", (char *)getenv (\"PATH\")));\n }\n \n static char *manpage_pagename = (char *)NULL;"}, {"sha": "25f6c6cdfcb4c03276020f089c235639bfebb73f", "filename": "texinfo/makeinfo/makeinfo.c", "status": "modified", "additions": 5, "deletions": 30, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/34b6478b59f51c9d5b2b634ea0aefa6813cdbb2a/texinfo%2Fmakeinfo%2Fmakeinfo.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/34b6478b59f51c9d5b2b634ea0aefa6813cdbb2a/texinfo%2Fmakeinfo%2Fmakeinfo.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/texinfo%2Fmakeinfo%2Fmakeinfo.c?ref=34b6478b59f51c9d5b2b634ea0aefa6813cdbb2a", "patch": "@@ -1,5 +1,5 @@\n /* Makeinfo -- convert Texinfo source files into Info files.\n-   $Id: makeinfo.c,v 1.6 1998/03/22 21:47:57 law Exp $\n+   $Id: makeinfo.c,v 1.8 1998/03/24 18:07:53 law Exp $\n \n    Copyright (C) 1987, 92, 93, 94, 95, 96, 97 Free Software Foundation, Inc.\n \n@@ -774,7 +774,6 @@ static COMMAND command_table[] = {\n   { NULL, NULL, NO_BRACE_ARGS }\n };\n \n-\n struct option long_options[] =\n {\n   { \"error-limit\", 1, 0, 'e' },                 /* formerly -el */\n@@ -1148,25 +1147,6 @@ print_version_info ()\n           major_version, minor_version);\n }\n \n-/* Like realloc (), but barfs if there isn't enough memory. */\n-void *\n-xrealloc (pointer, nbytes)\n-     void *pointer;\n-     unsigned int nbytes;\n-{\n-  void *temp;\n-\n-  if (!pointer)\n-    temp = (void *)xmalloc (nbytes);\n-  else\n-    temp = (void *)realloc (pointer, nbytes);\n-\n-  if (nbytes && !temp)\n-    memory_error (\"xrealloc\", nbytes);\n-\n-  return (temp);\n-}\n-\n /* If EXIT_VALUE is zero, print the full usage message to stdout.\n    Otherwise, just say to use --help for more info.\n    Then exit with EXIT_VALUE. */\n@@ -1269,7 +1249,7 @@ find_and_load (filename)\n     goto error_exit;\n \n   /* Load the file. */\n-  result = (char *)xmalloc (file_size + 2);\n+  result = (char *)xmalloc (1 + file_size);\n \n   /* VMS stat lies about the st_size value.  The actual number of\n      readable bytes is always less than this value.  The arcane\n@@ -1313,8 +1293,6 @@ find_and_load (filename)\n      extra unnecessary work each time it is called (that is a lot of times).\n      The SIZE_OF_INPUT_TEXT is one past the actual end of the text. */\n   input_text[size_of_input_text] = '\\n';\n-  /* Necessary, because later on we call strlen(input_text+limit). */\n-  input_text[size_of_input_text+1] = '\\0';\n   return (result);\n }\n \n@@ -1974,15 +1952,14 @@ convert_from_stream (stream, name)\n      FILE *stream;\n      char *name;\n {\n-  int buffer_size = READ_BUFFER_GROWTH;\n-  char *buffer = (char *) xmalloc (buffer_size + 2);\n-  int buffer_offset = 0;\n+  char *buffer = (char *)NULL;\n+  int buffer_offset = 0, buffer_size = 0;\n \n   initialize_conversion ();\n \n   /* Read until the end of the stream.  This isn't strictly correct, since\n      the texinfo input may end before the stream ends, but it is a quick\n-     working heuristic. */\n+     working hueristic. */\n   while (!feof (stream))\n     {\n       int count;\n@@ -2016,8 +1993,6 @@ convert_from_stream (stream, name)\n      extra unnecessary work each time it is called (that is a lot of times).\n      The SIZE_OF_INPUT_TEXT is one past the actual end of the text. */\n   input_text[size_of_input_text] = '\\n';\n-  /* Necessary, because later on we call strlen(input_text+limit). */\n-  input_text[size_of_input_text+1] = '\\0';\n \n   convert_from_loaded_file (name);\n }"}]}