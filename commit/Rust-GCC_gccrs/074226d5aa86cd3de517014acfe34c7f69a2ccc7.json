{"sha": "074226d5aa86cd3de517014acfe34c7f69a2ccc7", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDc0MjI2ZDVhYTg2Y2QzZGU1MTcwMTRhY2ZlMzRjN2Y2OWEyY2NjNw==", "commit": {"author": {"name": "Eric Botcazou", "email": "ebotcazou@adacore.com", "date": "2021-03-01T06:53:05Z"}, "committer": {"name": "Eric Botcazou", "email": "ebotcazou@adacore.com", "date": "2021-03-01T06:58:50Z"}, "message": "Fix wrong result for 1.0/3.0 at -O2 -fno-omit-frame-pointer -frounding-math\n\nThis wrong-code PR for the C++ compiler on x86-64/Windows is a regression\nin GCC 9 and later, but the underlying issue has probably been there since\nSEH was implemented and is exposed by this comment in config/i386/winnt.c:\n\n  /* SEH records saves relative to the \"current\" stack pointer, whether\n     or not there's a frame pointer in place.  This tracks the current\n     stack pointer offset from the CFA.  */\n  HOST_WIDE_INT sp_offset;\n\nThat's not what the (current) Microsoft documentation says; instead it says:\n\n  /* SEH records offsets relative to the lowest address of the fixed stack\n     allocation.  If there is no frame pointer, these offsets are from the\n     stack pointer; if there is a frame pointer, these offsets are from the\n     value of the stack pointer when the frame pointer was established, i.e.\n     the frame pointer minus the offset in the .seh_setframe directive.  */\n\nThat's why the implementation is correct only under the condition that the\nframe pointer be established *after* the fixed stack allocation; as a matter\nof fact, that's clearly the model underpinning SEH, but is the opposite of\nwhat is done e.g. on Linux.\n\nHowever the issue is mostly papered over in practice because:\n\n  1. SEH forces use_fast_prologue_epilogue to false, which in turns forces\nsave_regs_using_mov to false, so the general regs are always pushed when\nthey need to be saved, which eliminates the offset computation for them.\n\n  2. As soon as a frame is larger than 240 bytes, the frame pointer is fixed\narbitrarily to 128 bytes above the stack pointer, which of course requires\nthat it be established after the fixed stack allocation.\n\nSo you need a small frame clobbering one of the call-saved XMM registers in\norder to generate wrong SEH unwind info.\n\nThe attached fix makes sure that the frame pointer is always established\nafter the fixed stack allocation by pointing it at or below the lowest used\nregister save area, i.e. the SSE save area, and removing the special early\nsaves in the prologue; the end result is a uniform prologue sequence for\nSEH whatever the frame size.  And it avoids a discrepancy between cases\nwhere the number of saved general regs is even and cases where it is odd.\n\ngcc/\n\tPR target/99234\n\t* config/i386/i386.c (ix86_compute_frame_layout): For a SEH target,\n\tpoint the hard frame pointer to the SSE register save area instead\n\tof the general register save area.  Perform only minimal adjustment\n\tfor small frames if it is initially not correctly aligned.\n\t(ix86_expand_prologue): Remove early saves for a SEH target.\n\t* config/i386/winnt.c (struct seh_frame_state): Document constraint.\ngcc/testsuite/\n\t* g++.dg/eh/seh-xmm-unwind.C: New test.", "tree": {"sha": "bb9dd53e67dcb47d7a5adabf2db43feec428734f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/bb9dd53e67dcb47d7a5adabf2db43feec428734f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/074226d5aa86cd3de517014acfe34c7f69a2ccc7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/074226d5aa86cd3de517014acfe34c7f69a2ccc7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/074226d5aa86cd3de517014acfe34c7f69a2ccc7", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/074226d5aa86cd3de517014acfe34c7f69a2ccc7/comments", "author": null, "committer": null, "parents": [{"sha": "2c83c3fbd2baaadb4091eddfc77398e43e6134ea", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2c83c3fbd2baaadb4091eddfc77398e43e6134ea", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2c83c3fbd2baaadb4091eddfc77398e43e6134ea"}], "stats": {"total": 113, "additions": 88, "deletions": 25}, "files": [{"sha": "e85b06b6824bd780b311b742d8e506d5805e1dac", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 13, "deletions": 22, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/074226d5aa86cd3de517014acfe34c7f69a2ccc7/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/074226d5aa86cd3de517014acfe34c7f69a2ccc7/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=074226d5aa86cd3de517014acfe34c7f69a2ccc7", "patch": "@@ -6490,11 +6490,6 @@ ix86_compute_frame_layout (void)\n   offset += frame->nregs * UNITS_PER_WORD;\n   frame->reg_save_offset = offset;\n \n-  /* On SEH target, registers are pushed just before the frame pointer\n-     location.  */\n-  if (TARGET_SEH)\n-    frame->hard_frame_pointer_offset = offset;\n-\n   /* Calculate the size of the va-arg area (not including padding, if any).  */\n   frame->va_arg_size = ix86_varargs_gpr_size + ix86_varargs_fpr_size;\n \n@@ -6660,14 +6655,21 @@ ix86_compute_frame_layout (void)\n      the unwind data structure.  */\n   if (TARGET_SEH)\n     {\n-      HOST_WIDE_INT diff;\n+      /* Force the frame pointer to point at or below the lowest register save\n+\t area, see the SEH code in config/i386/winnt.c for the rationale.  */\n+      frame->hard_frame_pointer_offset = frame->sse_reg_save_offset;\n \n-      /* If we can leave the frame pointer where it is, do so.  Also, returns\n+      /* If we can leave the frame pointer where it is, do so.  Also, return\n \t the establisher frame for __builtin_frame_address (0).  */\n-      diff = frame->stack_pointer_offset - frame->hard_frame_pointer_offset;\n-      if (diff <= SEH_MAX_FRAME_SIZE\n-\t  && (diff > 240 || (diff & 15) != 0)\n-\t  && !crtl->accesses_prior_frames)\n+      const HOST_WIDE_INT diff\n+\t= frame->stack_pointer_offset - frame->hard_frame_pointer_offset;\n+      if (diff <= 255)\n+\t{\n+\t  /* The resulting diff will be a multiple of 16 lower than 255,\n+\t     i.e. at most 240 as required by the unwind data structure.  */\n+\t  frame->hard_frame_pointer_offset += (diff & 15);\n+\t}\n+      else if (diff <= SEH_MAX_FRAME_SIZE && !crtl->accesses_prior_frames)\n \t{\n \t  /* Ideally we'd determine what portion of the local stack frame\n \t     (within the constraint of the lowest 240) is most heavily used.\n@@ -8336,17 +8338,6 @@ ix86_expand_prologue (void)\n       insn = emit_insn (gen_push (hard_frame_pointer_rtx));\n       RTX_FRAME_RELATED_P (insn) = 1;\n \n-      /* Push registers now, before setting the frame pointer\n-\t on SEH target.  */\n-      if (!int_registers_saved\n-\t  && TARGET_SEH\n-\t  && !frame.save_regs_using_mov)\n-\t{\n-\t  ix86_emit_save_regs ();\n-\t  int_registers_saved = true;\n-\t  gcc_assert (m->fs.sp_offset == frame.reg_save_offset);\n-\t}\n-\n       if (m->fs.sp_offset == frame.hard_frame_pointer_offset)\n \t{\n \t  insn = emit_move_insn (hard_frame_pointer_rtx, stack_pointer_rtx);"}, {"sha": "cc1219652943c9123e813b7b8a0afd46f83b62c3", "filename": "gcc/config/i386/winnt.c", "status": "modified", "additions": 14, "deletions": 3, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/074226d5aa86cd3de517014acfe34c7f69a2ccc7/gcc%2Fconfig%2Fi386%2Fwinnt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/074226d5aa86cd3de517014acfe34c7f69a2ccc7/gcc%2Fconfig%2Fi386%2Fwinnt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fwinnt.c?ref=074226d5aa86cd3de517014acfe34c7f69a2ccc7", "patch": "@@ -830,9 +830,20 @@ i386_pe_asm_lto_end (void)\n \n struct seh_frame_state\n {\n-  /* SEH records saves relative to the \"current\" stack pointer, whether\n-     or not there's a frame pointer in place.  This tracks the current\n-     stack pointer offset from the CFA.  */\n+  /* SEH records offsets relative to the lowest address of the fixed stack\n+     allocation.  If there is no frame pointer, these offsets are from the\n+     stack pointer; if there is a frame pointer, these offsets are from the\n+     value of the stack pointer when the frame pointer was established, i.e.\n+     the frame pointer minus the offset in the .seh_setframe directive.\n+\n+     We do not distinguish these two cases, i.e. we consider that the offsets\n+     are always relative to the \"current\" stack pointer.  This means that we\n+     need to perform the fixed stack allocation before establishing the frame\n+     pointer whenever there are registers to be saved, and this is guaranteed\n+     by the prologue provided that we force the frame pointer to point at or\n+     below the lowest used register save area, see ix86_compute_frame_layout.\n+\n+     This tracks the current stack pointer offset from the CFA.  */\n   HOST_WIDE_INT sp_offset;\n \n   /* The CFA is located at CFA_REG + CFA_OFFSET.  */"}, {"sha": "07fd805b3fd7b77400e9c44f08bad22df58bee7b", "filename": "gcc/testsuite/g++.dg/eh/seh-xmm-unwind.C", "status": "added", "additions": 61, "deletions": 0, "changes": 61, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/074226d5aa86cd3de517014acfe34c7f69a2ccc7/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Feh%2Fseh-xmm-unwind.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/074226d5aa86cd3de517014acfe34c7f69a2ccc7/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Feh%2Fseh-xmm-unwind.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Feh%2Fseh-xmm-unwind.C?ref=074226d5aa86cd3de517014acfe34c7f69a2ccc7", "patch": "@@ -0,0 +1,61 @@\n+/* PR target/99234 */\n+/* Test SEH unwinding of XMM register saves.  */\n+\n+/* { dg-do run { target { x86_64-*-mingw32 && lp64 } } } */\n+\n+extern \"C\" void abort (void);\n+extern \"C\" void exit (int);\n+\n+void\n+foo (void)\n+{\n+  register __int128 xmm6  asm(\"xmm6\")  = 0;\n+  register __int128 xmm7  asm(\"xmm7\")  = 0;\n+  register __int128 xmm8  asm(\"xmm8\")  = 0;\n+  register __int128 xmm9  asm(\"xmm9\")  = 0;\n+  register __int128 xmm10 asm(\"xmm10\") = 0;\n+  register __int128 xmm11 asm(\"xmm11\") = 0;\n+  register __int128 xmm12 asm(\"xmm12\") = 0;\n+  register __int128 xmm13 asm(\"xmm13\") = 0;\n+  register __int128 xmm14 asm(\"xmm14\") = 0;\n+  register __int128 xmm15 asm(\"xmm15\") = 0;\n+\n+  __asm__ __volatile__ (\"\" : \"+x\" (xmm6),  \"+x\" (xmm7),  \"+x\" (xmm8),  \"+x\" (xmm9),\n+\t\t\t     \"+x\" (xmm10), \"+x\" (xmm11), \"+x\" (xmm12), \"+x\" (xmm13),\n+\t\t\t     \"+x\" (xmm14), \"+x\" (xmm15));\n+\n+  throw 1;\n+}\n+\n+int\n+main (void)\n+{\n+  register __int128 xmm6  asm(\"xmm6\")  = 6;\n+  register __int128 xmm7  asm(\"xmm7\")  = 7;\n+  register __int128 xmm8  asm(\"xmm8\")  = 8;\n+  register __int128 xmm9  asm(\"xmm9\")  = 9;\n+  register __int128 xmm10 asm(\"xmm10\") = 10;\n+  register __int128 xmm11 asm(\"xmm11\") = 11;\n+  register __int128 xmm12 asm(\"xmm12\") = 12;\n+  register __int128 xmm13 asm(\"xmm13\") = 13;\n+  register __int128 xmm14 asm(\"xmm14\") = 14;\n+  register __int128 xmm15 asm(\"xmm15\") = 15;\n+\n+  __asm__ __volatile__ (\"\" : \"+x\" (xmm6),  \"+x\" (xmm7),  \"+x\" (xmm8),  \"+x\" (xmm9),\n+\t\t\t     \"+x\" (xmm10), \"+x\" (xmm11), \"+x\" (xmm12), \"+x\" (xmm13),\n+\t\t\t     \"+x\" (xmm14), \"+x\" (xmm15));\n+\n+  try {\n+    foo ();\n+  } catch (...) {\n+    __asm__ __volatile__ (\"\" : \"+x\" (xmm6),  \"+x\" (xmm7),  \"+x\" (xmm8),  \"+x\" (xmm9),\n+\t\t\t       \"+x\" (xmm10), \"+x\" (xmm11), \"+x\" (xmm12), \"+x\" (xmm13),\n+\t\t\t       \"+x\" (xmm14), \"+x\" (xmm15));\n+\n+    if (xmm6 != 6 || xmm7 != 7 || xmm8 != 8 || xmm9 != 9 || xmm10 != 10\n+        || xmm11 != 11 || xmm12 != 12 || xmm13 != 13 || xmm14 != 14 || xmm15 != 15)\n+      abort ();\n+  }\n+\n+  exit (0);\n+}"}]}