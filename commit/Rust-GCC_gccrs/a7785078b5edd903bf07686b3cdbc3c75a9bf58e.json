{"sha": "a7785078b5edd903bf07686b3cdbc3c75a9bf58e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTc3ODUwNzhiNWVkZDkwM2JmMDc2ODZiM2NkYmMzYzc1YTliZjU4ZQ==", "commit": {"author": {"name": "Will Schmidt", "email": "will_schmidt@vnet.ibm.com", "date": "2017-05-12T15:35:17Z"}, "committer": {"name": "Will Schmidt", "email": "willschm@gcc.gnu.org", "date": "2017-05-12T15:35:17Z"}, "message": "rs6000.c (gimple-fold.h): New #include.\n\n[gcc]\n\n2017-05-10  Will Schmidt  <will_schmidt@vnet.ibm.com>\n\n\t* config/rs6000/rs6000.c (gimple-fold.h): New #include.\n\t(rs6000_gimple_fold_builtin): Add handling for early GIMPLE\n\texpansion of vector logical operations (and, andc, or, xor,\n\tnor, orc, nand)\n\n[gcc/testsuite]\n\n2017-05-10  Will Schmidt  <will_schmidt@vnet.ibm.com>\n\n\t* gcc.target/powerpc/fold-vec-logical-ands-char.c: New.\n\t* gcc.target/powerpc/fold-vec-logical-ands-int.c: New.\n\t* gcc.target/powerpc/fold-vec-logical-ands-longlong.c: New.\n\t* gcc.target/powerpc/fold-vec-logical-ands-short.c: New.\n\t* gcc.target/powerpc/fold-vec-logical-ors-char.c: New.\n\t* gcc.target/powerpc/fold-vec-logical-ors-int.c: New.\n\t* gcc.target/powerpc/fold-vec-logical-ors-longlong.c: New.\n\t* gcc.target/powerpc/fold-vec-logical-ors-short.c: New.\n\t* gcc.target/powerpc/fold-vec-logical-other-char.c: New.\n\t* gcc.target/powerpc/fold-vec-logical-other-int.c: New.\n\t* gcc.target/powerpc/fold-vec-logical-other-longlong.c: New.\n\t* gcc.target/powerpc/fold-vec-logical-other-short.c: New.\n\nFrom-SVN: r247976", "tree": {"sha": "3a194f6f00935f35c5a13888aa034df309f6908e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/3a194f6f00935f35c5a13888aa034df309f6908e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a7785078b5edd903bf07686b3cdbc3c75a9bf58e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a7785078b5edd903bf07686b3cdbc3c75a9bf58e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a7785078b5edd903bf07686b3cdbc3c75a9bf58e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a7785078b5edd903bf07686b3cdbc3c75a9bf58e/comments", "author": {"login": "willschm", "id": 44359, "node_id": "MDQ6VXNlcjQ0MzU5", "avatar_url": "https://avatars.githubusercontent.com/u/44359?v=4", "gravatar_id": "", "url": "https://api.github.com/users/willschm", "html_url": "https://github.com/willschm", "followers_url": "https://api.github.com/users/willschm/followers", "following_url": "https://api.github.com/users/willschm/following{/other_user}", "gists_url": "https://api.github.com/users/willschm/gists{/gist_id}", "starred_url": "https://api.github.com/users/willschm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/willschm/subscriptions", "organizations_url": "https://api.github.com/users/willschm/orgs", "repos_url": "https://api.github.com/users/willschm/repos", "events_url": "https://api.github.com/users/willschm/events{/privacy}", "received_events_url": "https://api.github.com/users/willschm/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "edc19e037029e1d98762e893bb668721109652e5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/edc19e037029e1d98762e893bb668721109652e5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/edc19e037029e1d98762e893bb668721109652e5"}], "stats": {"total": 1523, "additions": 1522, "deletions": 1}, "files": [{"sha": "852630e3ee46a40dce0728fa798d8f985f10782e", "filename": "gcc/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a7785078b5edd903bf07686b3cdbc3c75a9bf58e/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a7785078b5edd903bf07686b3cdbc3c75a9bf58e/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=a7785078b5edd903bf07686b3cdbc3c75a9bf58e", "patch": "@@ -1,3 +1,10 @@\n+2017-05-10  Will Schmidt  <will_schmidt@vnet.ibm.com>\n+\n+\t* config/rs6000/rs6000.c (gimple-fold.h): New #include.\n+\t(rs6000_gimple_fold_builtin): Add handling for early GIMPLE\n+\texpansion of vector logical operations (and, andc, or, xor,\n+\tnor, orc, nand).\n+\n 2017-05-12  Will Schmidt  <will_schmidt@vnet.ibm.com>\n \n \t* gimple-fold.c (create_tmp_reg_or_ssa_name): Remove static declaration."}, {"sha": "2290439cfe3c1f03fe7c75901d1b1b7e5d178794", "filename": "gcc/config/rs6000/rs6000.c", "status": "modified", "additions": 105, "deletions": 1, "changes": 106, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a7785078b5edd903bf07686b3cdbc3c75a9bf58e/gcc%2Fconfig%2Frs6000%2Frs6000.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a7785078b5edd903bf07686b3cdbc3c75a9bf58e/gcc%2Fconfig%2Frs6000%2Frs6000.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.c?ref=a7785078b5edd903bf07686b3cdbc3c75a9bf58e", "patch": "@@ -55,6 +55,7 @@\n #include \"reload.h\"\n #include \"sched-int.h\"\n #include \"gimplify.h\"\n+#include \"gimple-fold.h\"\n #include \"gimple-iterator.h\"\n #include \"gimple-ssa.h\"\n #include \"gimple-walk.h\"\n@@ -17204,7 +17205,110 @@ rs6000_gimple_fold_builtin (gimple_stmt_iterator *gsi)\n \tgsi_replace (gsi, g, true);\n \treturn true;\n       }\n-\n+    /* Flavors of vec_and.  */\n+    case ALTIVEC_BUILTIN_VAND:\n+      {\n+\targ0 = gimple_call_arg (stmt, 0);\n+\targ1 = gimple_call_arg (stmt, 1);\n+\tlhs = gimple_call_lhs (stmt);\n+\tgimple *g = gimple_build_assign (lhs, BIT_AND_EXPR, arg0, arg1);\n+\tgimple_set_location (g, gimple_location (stmt));\n+\tgsi_replace (gsi, g, true);\n+\treturn true;\n+      }\n+    /* Flavors of vec_andc.  */\n+    case ALTIVEC_BUILTIN_VANDC:\n+      {\n+\targ0 = gimple_call_arg (stmt, 0);\n+\targ1 = gimple_call_arg (stmt, 1);\n+\tlhs = gimple_call_lhs (stmt);\n+\ttree temp = create_tmp_reg_or_ssa_name (TREE_TYPE (arg1));\n+\tgimple *g = gimple_build_assign(temp, BIT_NOT_EXPR, arg1);\n+\tgimple_set_location (g, gimple_location (stmt));\n+\tgsi_insert_before(gsi, g, GSI_SAME_STMT);\n+\tg = gimple_build_assign (lhs, BIT_AND_EXPR, arg0, temp);\n+\tgimple_set_location (g, gimple_location (stmt));\n+\tgsi_replace (gsi, g, true);\n+\treturn true;\n+      }\n+    /* Flavors of vec_nand.  */\n+    case P8V_BUILTIN_VEC_NAND:\n+    case P8V_BUILTIN_NAND_V16QI:\n+    case P8V_BUILTIN_NAND_V8HI:\n+    case P8V_BUILTIN_NAND_V4SI:\n+    case P8V_BUILTIN_NAND_V4SF:\n+    case P8V_BUILTIN_NAND_V2DF:\n+    case P8V_BUILTIN_NAND_V2DI:\n+      {\n+\targ0 = gimple_call_arg (stmt, 0);\n+\targ1 = gimple_call_arg (stmt, 1);\n+\tlhs = gimple_call_lhs (stmt);\n+\ttree temp = create_tmp_reg_or_ssa_name (TREE_TYPE (arg1));\n+\tgimple *g = gimple_build_assign(temp, BIT_AND_EXPR, arg0, arg1);\n+\tgimple_set_location (g, gimple_location (stmt));\n+\tgsi_insert_before(gsi, g, GSI_SAME_STMT);\n+\tg = gimple_build_assign (lhs, BIT_NOT_EXPR, temp);\n+\tgimple_set_location (g, gimple_location (stmt));\n+\tgsi_replace (gsi, g, true);\n+\treturn true;\n+      }\n+    /* Flavors of vec_or.  */\n+    case ALTIVEC_BUILTIN_VOR:\n+      {\n+\targ0 = gimple_call_arg (stmt, 0);\n+\targ1 = gimple_call_arg (stmt, 1);\n+\tlhs = gimple_call_lhs (stmt);\n+\tgimple *g = gimple_build_assign (lhs, BIT_IOR_EXPR, arg0, arg1);\n+\tgimple_set_location (g, gimple_location (stmt));\n+\tgsi_replace (gsi, g, true);\n+\treturn true;\n+      }\n+    /* flavors of vec_orc.  */\n+    case P8V_BUILTIN_ORC_V16QI:\n+    case P8V_BUILTIN_ORC_V8HI:\n+    case P8V_BUILTIN_ORC_V4SI:\n+    case P8V_BUILTIN_ORC_V4SF:\n+    case P8V_BUILTIN_ORC_V2DF:\n+    case P8V_BUILTIN_ORC_V2DI:\n+      {\n+\targ0 = gimple_call_arg (stmt, 0);\n+\targ1 = gimple_call_arg (stmt, 1);\n+\tlhs = gimple_call_lhs (stmt);\n+\ttree temp = create_tmp_reg_or_ssa_name (TREE_TYPE (arg1));\n+\tgimple *g = gimple_build_assign(temp, BIT_NOT_EXPR, arg1);\n+\tgimple_set_location (g, gimple_location (stmt));\n+\tgsi_insert_before(gsi, g, GSI_SAME_STMT);\n+\tg = gimple_build_assign (lhs, BIT_IOR_EXPR, arg0, temp);\n+\tgimple_set_location (g, gimple_location (stmt));\n+\tgsi_replace (gsi, g, true);\n+\treturn true;\n+      }\n+    /* Flavors of vec_xor.  */\n+    case ALTIVEC_BUILTIN_VXOR:\n+      {\n+\targ0 = gimple_call_arg (stmt, 0);\n+\targ1 = gimple_call_arg (stmt, 1);\n+\tlhs = gimple_call_lhs (stmt);\n+\tgimple *g = gimple_build_assign (lhs, BIT_XOR_EXPR, arg0, arg1);\n+\tgimple_set_location (g, gimple_location (stmt));\n+\tgsi_replace (gsi, g, true);\n+\treturn true;\n+      }\n+    /* Flavors of vec_nor.  */\n+    case ALTIVEC_BUILTIN_VNOR:\n+      {\n+\targ0 = gimple_call_arg (stmt, 0);\n+\targ1 = gimple_call_arg (stmt, 1);\n+\tlhs = gimple_call_lhs (stmt);\n+\ttree temp = create_tmp_reg_or_ssa_name (TREE_TYPE (arg1));\n+\tgimple *g = gimple_build_assign (temp, BIT_IOR_EXPR, arg0, arg1);\n+\tgimple_set_location (g, gimple_location (stmt));\n+\tgsi_insert_before(gsi, g, GSI_SAME_STMT);\n+\tg = gimple_build_assign (lhs, BIT_NOT_EXPR, temp);\n+\tgimple_set_location (g, gimple_location (stmt));\n+\tgsi_replace (gsi, g, true);\n+\treturn true;\n+      }\n     default:\n       break;\n     }"}, {"sha": "1bffa4a82ba1ed29e79c2d67b07296bcc698ce71", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a7785078b5edd903bf07686b3cdbc3c75a9bf58e/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a7785078b5edd903bf07686b3cdbc3c75a9bf58e/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=a7785078b5edd903bf07686b3cdbc3c75a9bf58e", "patch": "@@ -1,3 +1,18 @@\n+2017-05-12  Will Schmidt  <will_schmidt@vnet.ibm.com>\n+\n+\t* gcc.target/powerpc/fold-vec-logical-ands-char.c: New.\n+\t* gcc.target/powerpc/fold-vec-logical-ands-int.c: New.\n+\t* gcc.target/powerpc/fold-vec-logical-ands-longlong.c: New.\n+\t* gcc.target/powerpc/fold-vec-logical-ands-short.c: New.\n+\t* gcc.target/powerpc/fold-vec-logical-ors-char.c: New.\n+\t* gcc.target/powerpc/fold-vec-logical-ors-int.c: New.\n+\t* gcc.target/powerpc/fold-vec-logical-ors-longlong.c: New.\n+\t* gcc.target/powerpc/fold-vec-logical-ors-short.c: New.\n+\t* gcc.target/powerpc/fold-vec-logical-other-char.c: New.\n+\t* gcc.target/powerpc/fold-vec-logical-other-int.c: New.\n+\t* gcc.target/powerpc/fold-vec-logical-other-longlong.c: New.\n+\t* gcc.target/powerpc/fold-vec-logical-other-short.c: New.\n+\n 2017-05-12  Paolo Carlini  <paolo.carlini@oracle.com>\n \n \tPR c++/49604"}, {"sha": "021da58441e1daaca8f2e2eda7f3eee2c4367b1c", "filename": "gcc/testsuite/gcc.target/powerpc/fold-vec-logical-ands-char.c", "status": "added", "additions": 108, "deletions": 0, "changes": 108, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a7785078b5edd903bf07686b3cdbc3c75a9bf58e/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Ffold-vec-logical-ands-char.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a7785078b5edd903bf07686b3cdbc3c75a9bf58e/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Ffold-vec-logical-ands-char.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Ffold-vec-logical-ands-char.c?ref=a7785078b5edd903bf07686b3cdbc3c75a9bf58e", "patch": "@@ -0,0 +1,108 @@\n+/* Verify that overloaded built-ins for vec_and and vec_andc\n+ * with char inputs produce the right results. */\n+\n+/* { dg-do compile } */\n+/* { dg-require-effective-target powerpc_vsx_ok } */\n+/* { dg-options \"-maltivec -O1\" } */\n+\n+#include <altivec.h>\n+\n+vector signed char\n+test1_and (vector bool char x, vector signed char y)\n+{\n+  vector signed char *foo;\n+  *foo += vec_and (x, y);\n+  return *foo;\n+}\n+\n+vector signed char\n+test1_andc (vector bool char x, vector signed char y)\n+{\n+  vector signed char *foo;\n+  *foo += vec_andc (x, y);\n+  return *foo;\n+}\n+\n+vector signed char\n+test2_and (vector signed char x, vector bool char y)\n+{\n+  vector signed char *foo;\n+  *foo += vec_and (x, y);\n+  return *foo;\n+}\n+\n+vector signed char\n+test2_andc (vector signed char x, vector bool char y)\n+{\n+  vector signed char *foo;\n+  *foo += vec_andc (x, y);\n+  return *foo;\n+}\n+\n+vector signed char\n+test3_and (vector signed char x, vector signed char y)\n+{\n+  vector signed char *foo;\n+  *foo += vec_and (x, y);\n+  return *foo;\n+}\n+\n+vector signed char\n+test3_andc (vector signed char x, vector signed char y)\n+{\n+  vector signed char *foo;\n+  *foo += vec_andc (x, y);\n+  return *foo;\n+}\n+\n+vector unsigned char\n+test4_and (vector bool char x, vector unsigned char y)\n+{\n+  vector unsigned char *foo;\n+  *foo += vec_and (x, y);\n+  return *foo;\n+}\n+\n+vector unsigned char\n+test4_andc (vector bool char x, vector unsigned char y)\n+{\n+  vector unsigned char *foo;\n+  *foo += vec_andc (x, y);\n+  return *foo;\n+}\n+\n+vector unsigned char\n+test5_and (vector unsigned char x, vector bool char y)\n+{\n+  vector unsigned char *foo;\n+  *foo += vec_and (x, y);\n+  return *foo;\n+}\n+\n+vector unsigned char\n+test5_andc (vector unsigned char x, vector bool char y)\n+{\n+  vector unsigned char *foo;\n+  *foo += vec_andc (x, y);\n+  return *foo;\n+}\n+\n+vector unsigned char\n+test6_and (vector unsigned char x, vector unsigned char y)\n+{\n+  vector unsigned char *foo;\n+  *foo += vec_and (x, y);\n+  return *foo;\n+}\n+\n+vector unsigned char\n+test6_andc (vector unsigned char x, vector unsigned char y)\n+{\n+  vector unsigned char *foo;\n+  *foo += vec_andc (x, y);\n+  return *foo;\n+}\n+\n+/* { dg-final { scan-assembler-times {\\mxxland\\M} 6 } } */\n+/* { dg-final { scan-assembler-times {\\mxxlandc\\M} 6 } } */\n+"}, {"sha": "ccac7d5f8f23f491b33bc9241bb47a3f102f1a24", "filename": "gcc/testsuite/gcc.target/powerpc/fold-vec-logical-ands-int.c", "status": "added", "additions": 108, "deletions": 0, "changes": 108, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a7785078b5edd903bf07686b3cdbc3c75a9bf58e/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Ffold-vec-logical-ands-int.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a7785078b5edd903bf07686b3cdbc3c75a9bf58e/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Ffold-vec-logical-ands-int.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Ffold-vec-logical-ands-int.c?ref=a7785078b5edd903bf07686b3cdbc3c75a9bf58e", "patch": "@@ -0,0 +1,108 @@\n+/* Verify that overloaded built-ins for vec_and, vec_andc, vec_or and vec_xor\n+ * with int inputs produce the right results.  */\n+\n+/* { dg-do compile } */\n+/* { dg-require-effective-target powerpc_altivec_ok } */\n+/* { dg-options \"-maltivec -O1\" } */\n+\n+#include <altivec.h>\n+\n+vector signed int\n+test1_and (vector bool int x, vector signed int y)\n+{\n+  vector signed int *foo;\n+  *foo += vec_and (x, y);\n+  return *foo;\n+}\n+\n+vector signed int\n+test1_andc (vector bool int x, vector signed int y)\n+{\n+  vector signed int *foo;\n+  *foo += vec_andc (x, y);\n+  return *foo;\n+}\n+\n+vector signed int\n+test2_and (vector signed int x, vector bool int y)\n+{\n+  vector signed int *foo;\n+  *foo += vec_and (x, y);\n+  return *foo;\n+}\n+\n+vector signed int\n+test2_andc (vector signed int x, vector bool int y)\n+{\n+  vector signed int *foo;\n+  *foo += vec_andc (x, y);\n+  return *foo;\n+}\n+\n+vector signed int\n+test3_and (vector signed int x, vector signed int y)\n+{\n+  vector signed int *foo;\n+  *foo += vec_and (x, y);\n+  return *foo;\n+}\n+\n+vector signed int\n+test3_andc (vector signed int x, vector signed int y)\n+{\n+  vector signed int *foo;\n+  *foo += vec_andc (x, y);\n+  return *foo;\n+}\n+\n+vector unsigned int\n+test4_and (vector bool int x, vector unsigned int y)\n+{\n+  vector unsigned int *foo;\n+  *foo += vec_and (x, y);\n+  return *foo;\n+}\n+\n+vector unsigned int\n+test4_andc (vector bool int x, vector unsigned int y)\n+{\n+  vector unsigned int *foo;\n+  *foo += vec_andc (x, y);\n+  return *foo;\n+}\n+\n+vector unsigned int\n+test5_and (vector unsigned int x, vector bool int y)\n+{\n+  vector unsigned int *foo;\n+  *foo += vec_and (x, y);\n+  return *foo;\n+}\n+\n+vector unsigned int\n+test5_andc (vector unsigned int x, vector bool int y)\n+{\n+  vector unsigned int *foo;\n+  *foo += vec_andc (x, y);\n+  return *foo;\n+}\n+\n+vector unsigned int\n+test6_and (vector unsigned int x, vector unsigned int y)\n+{\n+  vector unsigned int *foo;\n+  *foo += vec_and (x, y);\n+  return *foo;\n+}\n+\n+vector unsigned int\n+test6_andc (vector unsigned int x, vector unsigned int y)\n+{\n+  vector unsigned int *foo;\n+  *foo += vec_andc (x, y);\n+  return *foo;\n+}\n+\n+/* { dg-final { scan-assembler-times {\\mxxland\\M} 6 } } */\n+/* { dg-final { scan-assembler-times {\\mxxlandc\\M} 6 } } */\n+"}, {"sha": "76bece11a99e5ae632146c8d0f2bcc65c49325df", "filename": "gcc/testsuite/gcc.target/powerpc/fold-vec-logical-ands-longlong.c", "status": "added", "additions": 107, "deletions": 0, "changes": 107, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a7785078b5edd903bf07686b3cdbc3c75a9bf58e/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Ffold-vec-logical-ands-longlong.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a7785078b5edd903bf07686b3cdbc3c75a9bf58e/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Ffold-vec-logical-ands-longlong.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Ffold-vec-logical-ands-longlong.c?ref=a7785078b5edd903bf07686b3cdbc3c75a9bf58e", "patch": "@@ -0,0 +1,107 @@\n+/* Verify that overloaded built-ins for vec_and,vec_or,vec_xor with long long\n+   inputs produce the right results.  */\n+\n+/* { dg-do compile } */\n+/* { dg-require-effective-target powerpc_vsx_ok } */\n+/* { dg-options \"-mvsx -O2\" } */\n+\n+#include <altivec.h>\n+\n+vector signed long long\n+test1_and (vector bool long long x, vector signed long long y)\n+{\n+  vector signed long long *foo;\n+  *foo += vec_and (x, y);\n+  return *foo;\n+}\n+\n+vector signed long long\n+test1_andc (vector bool long long x, vector signed long long y)\n+{\n+  vector signed long long *foo;\n+  *foo += vec_andc (x, y);\n+  return *foo;\n+}\n+\n+vector signed long long\n+test2_and (vector signed long long x, vector bool long long y)\n+{\n+  vector signed long long *foo;\n+  *foo += vec_and (x, y);\n+  return *foo;\n+}\n+\n+vector signed long long\n+test2_andc (vector signed long long x, vector bool long long y)\n+{\n+  vector signed long long *foo;\n+  *foo += vec_andc (x, y);\n+  return *foo;\n+}\n+\n+vector signed long long\n+test3_and (vector signed long long x, vector signed long long y)\n+{\n+  vector signed long long *foo;\n+  *foo += vec_and (x, y);\n+  return *foo;\n+}\n+\n+vector signed long long\n+test3_andc (vector signed long long x, vector signed long long y)\n+{\n+  vector signed long long *foo;\n+  *foo += vec_andc (x, y);\n+  return *foo;\n+}\n+\n+vector unsigned long long\n+test4_and (vector bool long long x, vector unsigned long long y)\n+{\n+  vector unsigned long long *foo;\n+  *foo += vec_and (x, y);\n+  return *foo;\n+}\n+\n+vector unsigned long long\n+test4_andc (vector bool long long x, vector unsigned long long y)\n+{\n+  vector unsigned long long *foo;\n+  *foo += vec_andc (x, y);\n+  return *foo;\n+}\n+\n+vector unsigned long long\n+test5_and (vector unsigned long long x, vector bool long long y)\n+{\n+  vector unsigned long long *foo;\n+  *foo += vec_and (x, y);\n+  return *foo;\n+}\n+\n+vector unsigned long long\n+test5_andc (vector unsigned long long x, vector bool long long y)\n+{\n+  vector unsigned long long *foo;\n+  *foo += vec_andc (x, y);\n+  return *foo;\n+}\n+\n+vector unsigned long long\n+test6_and (vector unsigned long long x, vector unsigned long long y)\n+{\n+  vector unsigned long long *foo;\n+  *foo += vec_and (x, y);\n+  return *foo;\n+}\n+\n+vector unsigned long long\n+test6_andc (vector unsigned long long x, vector unsigned long long y)\n+{\n+  vector unsigned long long *foo;\n+  *foo += vec_andc (x, y);\n+  return *foo;\n+}\n+\n+/* { dg-final { scan-assembler-times {\\mxxland\\M} 6 } } */\n+/* { dg-final { scan-assembler-times {\\mxxlandc\\M} 6 } } */"}, {"sha": "8ee320675b1538bda7f6e16787aa7a1b93947b9d", "filename": "gcc/testsuite/gcc.target/powerpc/fold-vec-logical-ands-short.c", "status": "added", "additions": 107, "deletions": 0, "changes": 107, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a7785078b5edd903bf07686b3cdbc3c75a9bf58e/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Ffold-vec-logical-ands-short.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a7785078b5edd903bf07686b3cdbc3c75a9bf58e/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Ffold-vec-logical-ands-short.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Ffold-vec-logical-ands-short.c?ref=a7785078b5edd903bf07686b3cdbc3c75a9bf58e", "patch": "@@ -0,0 +1,107 @@\n+/* Verify that overloaded built-ins for vec_and,vec_or,vec_xor with short\n+   inputs produce the right results.  */\n+\n+/* { dg-do compile } */\n+/* { dg-require-effective-target powerpc_altivec_ok } */\n+/* { dg-options \"-maltivec -O1\" } */\n+\n+#include <altivec.h>\n+\n+vector signed short\n+test1_and (vector bool short x, vector signed short y)\n+{\n+  vector signed short *foo;\n+  *foo += vec_and (x, y);\n+  return *foo;\n+}\n+\n+vector signed short\n+test1_andc (vector bool short x, vector signed short y)\n+{\n+  vector signed short *foo;\n+  *foo += vec_andc (x, y);\n+  return *foo;\n+}\n+\n+vector signed short\n+test2_and (vector signed short x, vector bool short y)\n+{\n+  vector signed short *foo;\n+  *foo += vec_and (x, y);\n+  return *foo;\n+}\n+\n+vector signed short\n+test2_andc (vector signed short x, vector bool short y)\n+{\n+  vector signed short *foo;\n+  *foo += vec_andc (x, y);\n+  return *foo;\n+}\n+\n+vector signed short\n+test3_and (vector signed short x, vector signed short y)\n+{\n+  vector signed short *foo;\n+  *foo += vec_and (x, y);\n+  return *foo;\n+}\n+\n+vector signed short\n+test3_andc (vector signed short x, vector signed short y)\n+{\n+  vector signed short *foo;\n+  *foo += vec_andc (x, y);\n+  return *foo;\n+}\n+\n+vector unsigned short\n+test4_and (vector bool short x, vector unsigned short y)\n+{\n+  vector unsigned short *foo;\n+  *foo += vec_and (x, y);\n+  return *foo;\n+}\n+\n+vector unsigned short\n+test4_andc (vector bool short x, vector unsigned short y)\n+{\n+  vector unsigned short *foo;\n+  *foo += vec_andc (x, y);\n+  return *foo;\n+}\n+\n+vector unsigned short\n+test5_and (vector unsigned short x, vector bool short y)\n+{\n+  vector unsigned short *foo;\n+  *foo += vec_and (x, y);\n+  return *foo;\n+}\n+\n+vector unsigned short\n+test5_andc (vector unsigned short x, vector bool short y)\n+{\n+  vector unsigned short *foo;\n+  *foo += vec_andc (x, y);\n+  return *foo;\n+}\n+\n+vector unsigned short\n+test6_and (vector unsigned short x, vector unsigned short y)\n+{\n+  vector unsigned short *foo;\n+  *foo += vec_and (x, y);\n+  return *foo;\n+}\n+\n+vector unsigned short\n+test6_andc (vector unsigned short x, vector unsigned short y)\n+{\n+  vector unsigned short *foo;\n+  *foo += vec_andc (x, y);\n+  return *foo;\n+}\n+\n+/* { dg-final { scan-assembler-times {\\mxxland\\M} 6 } } */\n+/* { dg-final { scan-assembler-times {\\mxxlandc\\M} 6 } } */"}, {"sha": "283189f8713478a5753050f277a5d1523a1b1d53", "filename": "gcc/testsuite/gcc.target/powerpc/fold-vec-logical-ors-char.c", "status": "added", "additions": 126, "deletions": 0, "changes": 126, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a7785078b5edd903bf07686b3cdbc3c75a9bf58e/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Ffold-vec-logical-ors-char.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a7785078b5edd903bf07686b3cdbc3c75a9bf58e/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Ffold-vec-logical-ors-char.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Ffold-vec-logical-ors-char.c?ref=a7785078b5edd903bf07686b3cdbc3c75a9bf58e", "patch": "@@ -0,0 +1,126 @@\n+/* Verify that overloaded built-ins for vec_or, vec_xor, vec_nor\n+ * with char inputs produce the right results. */\n+\n+/* { dg-do compile } */\n+/* { dg-require-effective-target powerpc_vsx_ok } */\n+/* { dg-options \"-maltivec -O1\" } */\n+\n+#include <altivec.h>\n+\n+\n+vector signed char\n+test1_or (vector bool char x, vector signed char y)\n+{\n+  vector signed char *foo;\n+  *foo += vec_or (x, y);\n+  return *foo;\n+}\n+\n+vector signed char\n+test1_xor (vector bool char x, vector signed char y)\n+{\n+  vector signed char *foo;\n+  *foo += vec_xor (x, y);\n+  return *foo;\n+}\n+\n+vector signed char\n+test2_or (vector signed char x, vector bool char y)\n+{\n+  vector signed char *foo;\n+  *foo += vec_or (x, y);\n+  return *foo;\n+}\n+\n+vector signed char\n+test2_xor (vector signed char x, vector bool char y)\n+{\n+  vector signed char *foo;\n+  *foo += vec_xor (x, y);\n+  return *foo;\n+}\n+\n+vector signed char\n+test3_or (vector signed char x, vector signed char y)\n+{\n+  vector signed char *foo;\n+  *foo += vec_or (x, y);\n+  return *foo;\n+}\n+\n+vector signed char\n+test3_xor (vector signed char x, vector signed char y)\n+{\n+  vector signed char *foo;\n+  *foo += vec_xor (x, y);\n+  return *foo;\n+}\n+\n+vector signed char\n+test3_nor (vector signed char x, vector signed char y)\n+{\n+  vector signed char *foo;\n+  *foo += vec_nor (x, y);\n+  return *foo;\n+}\n+\n+\n+vector unsigned char\n+test4_or (vector bool char x, vector unsigned char y)\n+{\n+  vector unsigned char *foo;\n+  *foo += vec_or (x, y);\n+  return *foo;\n+}\n+\n+vector unsigned char\n+test4_xor (vector bool char x, vector unsigned char y)\n+{\n+  vector unsigned char *foo;\n+  *foo += vec_xor (x, y);\n+  return *foo;\n+}\n+\n+vector unsigned char\n+test5_or (vector unsigned char x, vector bool char y)\n+{\n+  vector unsigned char *foo;\n+  *foo += vec_or (x, y);\n+  return *foo;\n+}\n+\n+vector unsigned char\n+test5_xor (vector unsigned char x, vector bool char y)\n+{\n+  vector unsigned char *foo;\n+  *foo += vec_xor (x, y);\n+  return *foo;\n+}\n+\n+vector unsigned char\n+test6_or (vector unsigned char x, vector unsigned char y)\n+{\n+  vector unsigned char *foo;\n+  *foo += vec_or (x, y);\n+  return *foo;\n+}\n+\n+vector unsigned char\n+test6_xor (vector unsigned char x, vector unsigned char y)\n+{\n+  vector unsigned char *foo;\n+  *foo += vec_xor (x, y);\n+  return *foo;\n+}\n+\n+vector unsigned char\n+test6_nor (vector unsigned char x, vector unsigned char y)\n+{\n+  vector unsigned char *foo;\n+  *foo += vec_nor (x, y);\n+  return *foo;\n+}\n+\n+/* { dg-final { scan-assembler-times {\\mxxlor\\M} 6 } } */\n+/* { dg-final { scan-assembler-times {\\mxxlxor\\M} 6 } } */\n+/* { dg-final { scan-assembler-times {\\mxxlnor\\M} 2 } } */"}, {"sha": "11e98ae4dcf91635a11c3c3b467c22dcb364cf8f", "filename": "gcc/testsuite/gcc.target/powerpc/fold-vec-logical-ors-int.c", "status": "added", "additions": 124, "deletions": 0, "changes": 124, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a7785078b5edd903bf07686b3cdbc3c75a9bf58e/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Ffold-vec-logical-ors-int.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a7785078b5edd903bf07686b3cdbc3c75a9bf58e/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Ffold-vec-logical-ors-int.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Ffold-vec-logical-ors-int.c?ref=a7785078b5edd903bf07686b3cdbc3c75a9bf58e", "patch": "@@ -0,0 +1,124 @@\n+/* Verify that overloaded built-ins for vec_and, vec_andc, vec_or and vec_xor\n+ * with int inputs produce the right results.  */\n+\n+/* { dg-do compile } */\n+/* { dg-require-effective-target powerpc_altivec_ok } */\n+/* { dg-options \"-maltivec -O1\" } */\n+\n+#include <altivec.h>\n+\n+vector signed int\n+test1_or (vector bool int x, vector signed int y)\n+{\n+  vector signed int *foo;\n+  *foo += vec_or (x, y);\n+  return *foo;\n+}\n+\n+vector signed int\n+test1_xor (vector bool int x, vector signed int y)\n+{\n+  vector signed int *foo;\n+  *foo += vec_xor (x, y);\n+  return *foo;\n+}\n+\n+vector signed int\n+test2_or (vector signed int x, vector bool int y)\n+{\n+  vector signed int *foo;\n+  *foo += vec_or (x, y);\n+  return *foo;\n+}\n+\n+vector signed int\n+test2_xor (vector signed int x, vector bool int y)\n+{\n+  vector signed int *foo;\n+  *foo += vec_xor (x, y);\n+  return *foo;\n+}\n+\n+vector signed int\n+test3_or (vector signed int x, vector signed int y)\n+{\n+  vector signed int *foo;\n+  *foo += vec_or (x, y);\n+  return *foo;\n+}\n+\n+vector signed int\n+test3_xor (vector signed int x, vector signed int y)\n+{\n+  vector signed int *foo;\n+  *foo += vec_xor (x, y);\n+  return *foo;\n+}\n+\n+vector signed int\n+test3_nor (vector signed int x, vector signed int y)\n+{\n+  vector signed int *foo;\n+  *foo += vec_nor (x, y);\n+  return *foo;\n+}\n+\n+vector unsigned int\n+test4_or (vector bool int x, vector unsigned int y)\n+{\n+  vector unsigned int *foo;\n+  *foo += vec_or (x, y);\n+  return *foo;\n+}\n+\n+vector unsigned int\n+test4_xor (vector bool int x, vector unsigned int y)\n+{\n+  vector unsigned int *foo;\n+  *foo += vec_xor (x, y);\n+  return *foo;\n+}\n+\n+vector unsigned int\n+test5_or (vector unsigned int x, vector bool int y)\n+{\n+  vector unsigned int *foo;\n+  *foo += vec_or (x, y);\n+  return *foo;\n+}\n+\n+vector unsigned int\n+test5_xor (vector unsigned int x, vector bool int y)\n+{\n+  vector unsigned int *foo;\n+  *foo += vec_xor (x, y);\n+  return *foo;\n+}\n+\n+vector unsigned int\n+test6_or (vector unsigned int x, vector unsigned int y)\n+{\n+  vector unsigned int *foo;\n+  *foo += vec_or (x, y);\n+  return *foo;\n+}\n+\n+vector unsigned int\n+test6_xor (vector unsigned int x, vector unsigned int y)\n+{\n+  vector unsigned int *foo;\n+  *foo += vec_xor (x, y);\n+  return *foo;\n+}\n+\n+vector unsigned int\n+test6_nor (vector unsigned int x, vector unsigned int y)\n+{\n+  vector unsigned int *foo;\n+  *foo += vec_nor (x, y);\n+  return *foo;\n+}\n+\n+/* { dg-final { scan-assembler-times {\\mxxlor\\M} 6 } } */\n+/* { dg-final { scan-assembler-times {\\mxxlxor\\M} 6 } } */\n+/* { dg-final { scan-assembler-times {\\mxxlnor\\M} 2 } } */"}, {"sha": "ac532f52d0c3f177a47f85994f7f8b19f5b0c3f1", "filename": "gcc/testsuite/gcc.target/powerpc/fold-vec-logical-ors-longlong.c", "status": "added", "additions": 161, "deletions": 0, "changes": 161, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a7785078b5edd903bf07686b3cdbc3c75a9bf58e/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Ffold-vec-logical-ors-longlong.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a7785078b5edd903bf07686b3cdbc3c75a9bf58e/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Ffold-vec-logical-ors-longlong.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Ffold-vec-logical-ors-longlong.c?ref=a7785078b5edd903bf07686b3cdbc3c75a9bf58e", "patch": "@@ -0,0 +1,161 @@\n+/* Verify that overloaded built-ins for vec_or, vec_xor, vec_nor with\n+ * long long inputs produce the right results.  */\n+\n+/* { dg-do compile } */\n+/* { dg-require-effective-target powerpc_vsx_ok } */\n+/* { dg-options \"-mvsx -O2\" } */\n+\n+#include <altivec.h>\n+\n+vector signed long long\n+test1_or (vector bool long long x, vector signed long long y)\n+{\n+  vector signed long long *foo;\n+  *foo += vec_or (x, y);\n+  return *foo;\n+}\n+\n+vector signed long long\n+test1_xor (vector bool long long x, vector signed long long y)\n+{\n+  vector signed long long *foo;\n+  *foo += vec_xor (x, y);\n+  return *foo;\n+}\n+\n+vector signed long long\n+test1_nor (vector bool long long x, vector signed long long y)\n+{\n+  vector signed long long *foo;\n+  *foo += vec_nor (x, y);\n+  return *foo;\n+}\n+\n+vector signed long long\n+test2_or (vector signed long long x, vector bool long long y)\n+{\n+  vector signed long long *foo;\n+  *foo += vec_or (x, y);\n+  return *foo;\n+}\n+\n+vector signed long long\n+test2_xor (vector signed long long x, vector bool long long y)\n+{\n+  vector signed long long *foo;\n+  *foo += vec_xor (x, y);\n+  return *foo;\n+}\n+\n+vector signed long long\n+test2_nor (vector signed long long x, vector bool long long y)\n+{\n+  vector signed long long *foo;\n+  *foo += vec_nor (x, y);\n+  return *foo;\n+}\n+\n+vector signed long long\n+test3_or (vector signed long long x, vector signed long long y)\n+{\n+  vector signed long long *foo;\n+  *foo += vec_or (x, y);\n+  return *foo;\n+}\n+\n+vector signed long long\n+test3_xor (vector signed long long x, vector signed long long y)\n+{\n+  vector signed long long *foo;\n+  *foo += vec_xor (x, y);\n+  return *foo;\n+}\n+\n+vector signed long long\n+test3_nor (vector signed long long x, vector signed long long y)\n+{\n+  vector signed long long *foo;\n+  *foo += vec_nor (x, y);\n+  return *foo;\n+}\n+\n+vector unsigned long long\n+test4_or (vector bool long long x, vector unsigned long long y)\n+{\n+  vector unsigned long long *foo;\n+  *foo += vec_or (x, y);\n+  return *foo;\n+}\n+\n+vector unsigned long long\n+test4_xor (vector bool long long x, vector unsigned long long y)\n+{\n+  vector unsigned long long *foo;\n+  *foo += vec_xor (x, y);\n+  return *foo;\n+}\n+\n+vector unsigned long long\n+test4_nor (vector bool long long x, vector unsigned long long y)\n+{\n+  vector unsigned long long *foo;\n+  *foo += vec_nor (x, y);\n+  return *foo;\n+}\n+\n+vector unsigned long long\n+test5_or (vector unsigned long long x, vector bool long long y)\n+{\n+  vector unsigned long long *foo;\n+  *foo += vec_or (x, y);\n+  return *foo;\n+}\n+\n+vector unsigned long long\n+test5_xor (vector unsigned long long x, vector bool long long y)\n+{\n+  vector unsigned long long *foo;\n+  *foo += vec_xor (x, y);\n+  return *foo;\n+}\n+\n+vector unsigned long long\n+test5_nor (vector unsigned long long x, vector bool long long y)\n+{\n+  vector unsigned long long *foo;\n+  *foo += vec_nor (x, y);\n+  return *foo;\n+}\n+\n+vector unsigned long long\n+test6_or (vector unsigned long long x, vector unsigned long long y)\n+{\n+  vector unsigned long long *foo;\n+  *foo += vec_or (x, y);\n+  return *foo;\n+}\n+\n+vector unsigned long long\n+test6_xor (vector unsigned long long x, vector unsigned long long y)\n+{\n+  vector unsigned long long *foo;\n+  *foo += vec_xor (x, y);\n+  return *foo;\n+}\n+\n+vector unsigned long long\n+test6_nor (vector unsigned long long x, vector unsigned long long y)\n+{\n+  vector unsigned long long *foo;\n+  *foo += vec_nor (x, y);\n+  return *foo;\n+}\n+\n+// Codegen on power7 is such that the vec_or() tests generate more xxlor\n+// instructions than what is seen on power8 or newer.\n+// Thus, an additional target close for the xxlor instruction check.\n+/* { dg-final { scan-assembler-times {\\mxxlor\\M} 6 { target p8vector_hw }  } } */\n+/* { dg-final { scan-assembler-times {\\mxxlor\\M} 24 { target { ! p8vector_hw }  }  } } */\n+\n+/* { dg-final { scan-assembler-times {\\mxxlxor\\M} 6 } } */\n+/* { dg-final { scan-assembler-times {\\mxxlnor\\M} 6 } } */"}, {"sha": "24f3a55efe0146f80ad7873ae59875594b5e6d20", "filename": "gcc/testsuite/gcc.target/powerpc/fold-vec-logical-ors-short.c", "status": "added", "additions": 124, "deletions": 0, "changes": 124, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a7785078b5edd903bf07686b3cdbc3c75a9bf58e/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Ffold-vec-logical-ors-short.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a7785078b5edd903bf07686b3cdbc3c75a9bf58e/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Ffold-vec-logical-ors-short.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Ffold-vec-logical-ors-short.c?ref=a7785078b5edd903bf07686b3cdbc3c75a9bf58e", "patch": "@@ -0,0 +1,124 @@\n+/* Verify that overloaded built-ins for vec_or, vec_xor, vec_nor with short\n+   inputs produce the right results.  */\n+\n+/* { dg-do compile } */\n+/* { dg-require-effective-target powerpc_altivec_ok } */\n+/* { dg-options \"-maltivec -O1\" } */\n+\n+#include <altivec.h>\n+\n+vector signed short\n+test1_or (vector bool short x, vector signed short y)\n+{\n+  vector signed short *foo;\n+  *foo += vec_or (x, y);\n+  return *foo;\n+}\n+\n+vector signed short\n+test1_xor (vector bool short x, vector signed short y)\n+{\n+  vector signed short *foo;\n+  *foo += vec_xor (x, y);\n+  return *foo;\n+}\n+\n+vector signed short\n+test2_or (vector signed short x, vector bool short y)\n+{\n+  vector signed short *foo;\n+  *foo += vec_or (x, y);\n+  return *foo;\n+}\n+\n+vector signed short\n+test2_xor (vector signed short x, vector bool short y)\n+{\n+  vector signed short *foo;\n+  *foo += vec_xor (x, y);\n+  return *foo;\n+}\n+\n+vector signed short\n+test3_or (vector signed short x, vector signed short y)\n+{\n+  vector signed short *foo;\n+  *foo += vec_or (x, y);\n+  return *foo;\n+}\n+\n+vector signed short\n+test3_xor (vector signed short x, vector signed short y)\n+{\n+  vector signed short *foo;\n+  *foo += vec_xor (x, y);\n+  return *foo;\n+}\n+\n+vector signed short\n+test3_nor (vector signed short x, vector signed short y)\n+{\n+  vector signed short *foo;\n+  *foo += vec_nor (x, y);\n+  return *foo;\n+}\n+\n+vector unsigned short\n+test4_or (vector bool short x, vector unsigned short y)\n+{\n+  vector unsigned short *foo;\n+  *foo += vec_or (x, y);\n+  return *foo;\n+}\n+\n+vector unsigned short\n+test4_xor (vector bool short x, vector unsigned short y)\n+{\n+  vector unsigned short *foo;\n+  *foo += vec_xor (x, y);\n+  return *foo;\n+}\n+\n+vector unsigned short\n+test5_or (vector unsigned short x, vector bool short y)\n+{\n+  vector unsigned short *foo;\n+  *foo += vec_or (x, y);\n+  return *foo;\n+}\n+\n+vector unsigned short\n+test5_xor (vector unsigned short x, vector bool short y)\n+{\n+  vector unsigned short *foo;\n+  *foo += vec_xor (x, y);\n+  return *foo;\n+}\n+\n+vector unsigned short\n+test6_or (vector unsigned short x, vector unsigned short y)\n+{\n+  vector unsigned short *foo;\n+  *foo += vec_or (x, y);\n+  return *foo;\n+}\n+\n+vector unsigned short\n+test6_xor (vector unsigned short x, vector unsigned short y)\n+{\n+  vector unsigned short *foo;\n+  *foo += vec_xor (x, y);\n+  return *foo;\n+}\n+\n+vector unsigned short\n+test6_nor (vector unsigned short x, vector unsigned short y)\n+{\n+  vector unsigned short *foo;\n+  *foo += vec_nor (x, y);\n+  return *foo;\n+}\n+\n+/* { dg-final { scan-assembler-times {\\mxxlor\\M} 6 } } */\n+/* { dg-final { scan-assembler-times {\\mxxlxor\\M} 6 } } */\n+/* { dg-final { scan-assembler-times {\\mxxlnor\\M} 2 } } */"}, {"sha": "8726df617de4736ecaa3128901302b3e8472fb9f", "filename": "gcc/testsuite/gcc.target/powerpc/fold-vec-logical-other-char.c", "status": "added", "additions": 108, "deletions": 0, "changes": 108, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a7785078b5edd903bf07686b3cdbc3c75a9bf58e/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Ffold-vec-logical-other-char.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a7785078b5edd903bf07686b3cdbc3c75a9bf58e/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Ffold-vec-logical-other-char.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Ffold-vec-logical-other-char.c?ref=a7785078b5edd903bf07686b3cdbc3c75a9bf58e", "patch": "@@ -0,0 +1,108 @@\n+/* Verify that overloaded built-ins for vec_orc and vec_nand with char\n+ * inputs produce the right results.  These intrinsics (vec_orc,\n+ * vec_nand) were added as part of ISA 2.07 (P8).  */\n+\n+/* { dg-do compile } */\n+/* { dg-require-effective-target p8vector_hw } */\n+/* { dg-options \"-mpower8-vector -O1\" } */\n+\n+#include <altivec.h>\n+\n+vector signed char\n+test1_orc (vector bool char x, vector signed char y)\n+{\n+  vector signed char *foo;\n+  *foo += vec_orc (x, y);\n+  return *foo;\n+}\n+\n+vector signed char\n+test1_nand (vector bool char x, vector signed char y)\n+{\n+  vector signed char *foo;\n+  *foo += vec_nand (x, y);\n+  return *foo;\n+}\n+\n+vector signed char\n+test2_orc (vector signed char x, vector bool char y)\n+{\n+  vector signed char *foo;\n+  *foo += vec_orc (x, y);\n+  return *foo;\n+}\n+\n+vector signed char\n+test2_nand (vector signed char x, vector bool char y)\n+{\n+  vector signed char *foo;\n+  *foo += vec_nand (x, y);\n+  return *foo;\n+}\n+\n+vector signed char\n+test3_orc (vector signed char x, vector signed char y)\n+{\n+  vector signed char *foo;\n+  *foo += vec_orc (x, y);\n+  return *foo;\n+}\n+\n+vector signed char\n+test3_nand (vector signed char x, vector signed char y)\n+{\n+  vector signed char *foo;\n+  *foo += vec_nand (x, y);\n+  return *foo;\n+}\n+\n+vector unsigned char\n+test4_orc (vector bool char x, vector unsigned char y)\n+{\n+  vector unsigned char *foo;\n+  *foo += vec_orc (x, y);\n+  return *foo;\n+}\n+\n+vector unsigned char\n+test4_nand (vector bool char x, vector unsigned char y)\n+{\n+  vector unsigned char *foo;\n+  *foo += vec_nand (x, y);\n+  return *foo;\n+}\n+\n+vector unsigned char\n+test5_orc (vector unsigned char x, vector bool char y)\n+{\n+  vector unsigned char *foo;\n+  *foo += vec_orc (x, y);\n+  return *foo;\n+}\n+\n+vector unsigned char\n+test5_nand (vector unsigned char x, vector bool char y)\n+{\n+  vector unsigned char *foo;\n+  *foo += vec_nand (x, y);\n+  return *foo;\n+}\n+\n+vector unsigned char\n+test6_orc (vector unsigned char x, vector unsigned char y)\n+{\n+  vector unsigned char *foo;\n+  *foo += vec_orc (x, y);\n+  return *foo;\n+}\n+\n+vector unsigned char\n+test6_nand (vector unsigned char x, vector unsigned char y)\n+{\n+  vector unsigned char *foo;\n+  *foo += vec_nand (x, y);\n+  return *foo;\n+}\n+\n+/* { dg-final { scan-assembler-times {\\mxxlnand\\M} 6 } } */\n+/* { dg-final { scan-assembler-times {\\mxxlorc\\M} 6 } } */"}, {"sha": "61d34059b67564cb4ad1405e322c5153752eab68", "filename": "gcc/testsuite/gcc.target/powerpc/fold-vec-logical-other-int.c", "status": "added", "additions": 108, "deletions": 0, "changes": 108, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a7785078b5edd903bf07686b3cdbc3c75a9bf58e/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Ffold-vec-logical-other-int.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a7785078b5edd903bf07686b3cdbc3c75a9bf58e/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Ffold-vec-logical-other-int.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Ffold-vec-logical-other-int.c?ref=a7785078b5edd903bf07686b3cdbc3c75a9bf58e", "patch": "@@ -0,0 +1,108 @@\n+/* Verify that overloaded built-ins for vec_orc and vec_nand with int\n+ * inputs produce the right results.  These intrinsics (vec_orc, \n+ * vec_nand) were added as part of ISA 2.07 (P8).  */\n+\n+/* { dg-do compile } */\n+/* { dg-require-effective-target powerpc_p8vector_ok } */\n+/* { dg-options \"-mpower8-vector -O1\" } */\n+\n+#include <altivec.h>\n+\n+vector signed int\n+test1_orc (vector bool int x, vector signed int y)\n+{\n+  vector signed int *foo;\n+  *foo += vec_orc (x, y);\n+  return *foo;\n+}\n+\n+vector signed int\n+test1_nand (vector bool int x, vector signed int y)\n+{\n+  vector signed int *foo;\n+  *foo += vec_nand (x, y);\n+  return *foo;\n+}\n+\n+vector signed int\n+test2_orc (vector signed int x, vector bool int y)\n+{\n+  vector signed int *foo;\n+  *foo += vec_orc (x, y);\n+  return *foo;\n+}\n+\n+vector signed int\n+test2_nand (vector signed int x, vector bool int y)\n+{\n+  vector signed int *foo;\n+  *foo += vec_nand (x, y);\n+  return *foo;\n+}\n+\n+vector signed int\n+test3_orc (vector signed int x, vector signed int y)\n+{\n+  vector signed int *foo;\n+  *foo += vec_orc (x, y);\n+  return *foo;\n+}\n+\n+vector signed int\n+test3_nand (vector signed int x, vector signed int y)\n+{\n+  vector signed int *foo;\n+  *foo += vec_nand (x, y);\n+  return *foo;\n+}\n+\n+vector unsigned int\n+test4_orc (vector bool int x, vector unsigned int y)\n+{\n+  vector unsigned int *foo;\n+  *foo += vec_orc (x, y);\n+  return *foo;\n+}\n+\n+vector unsigned int\n+test4_nand (vector bool int x, vector unsigned int y)\n+{\n+  vector unsigned int *foo;\n+  *foo += vec_nand (x, y);\n+  return *foo;\n+}\n+\n+vector unsigned int\n+test5_orc (vector unsigned int x, vector bool int y)\n+{\n+  vector unsigned int *foo;\n+  *foo += vec_orc (x, y);\n+  return *foo;\n+}\n+\n+vector unsigned int\n+test5_nand (vector unsigned int x, vector bool int y)\n+{\n+  vector unsigned int *foo;\n+  *foo += vec_nand (x, y);\n+  return *foo;\n+}\n+\n+vector unsigned int\n+test6_orc (vector unsigned int x, vector unsigned int y)\n+{\n+  vector unsigned int *foo;\n+  *foo += vec_orc (x, y);\n+  return *foo;\n+}\n+\n+vector unsigned int\n+test6_nand (vector unsigned int x, vector unsigned int y)\n+{\n+  vector unsigned int *foo;\n+  *foo += vec_nand (x, y);\n+  return *foo;\n+}\n+\n+/* { dg-final { scan-assembler-times {\\mxxlnand\\M} 6 } } */\n+/* { dg-final { scan-assembler-times {\\mxxlorc\\M} 6 } } */"}, {"sha": "8e14927620e90e4fd7554d9e7ba235dd198041e7", "filename": "gcc/testsuite/gcc.target/powerpc/fold-vec-logical-other-longlong.c", "status": "added", "additions": 106, "deletions": 0, "changes": 106, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a7785078b5edd903bf07686b3cdbc3c75a9bf58e/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Ffold-vec-logical-other-longlong.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a7785078b5edd903bf07686b3cdbc3c75a9bf58e/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Ffold-vec-logical-other-longlong.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Ffold-vec-logical-other-longlong.c?ref=a7785078b5edd903bf07686b3cdbc3c75a9bf58e", "patch": "@@ -0,0 +1,106 @@\n+/* Verify that overloaded built-ins for vec_orc and vec_nand with long long\n+   inputs produce the right results.  */\n+\n+/* { dg-do compile } */\n+/* { dg-require-effective-target powerpc_p8vector_ok } */\n+/* { dg-options \"-mpower8-vector -O1\" } */\n+\n+#include <altivec.h>\n+\n+vector signed long long\n+test1_orc (vector bool long long x, vector signed long long y)\n+{\n+  vector signed long long *foo;\n+  *foo += vec_orc (x, y);\n+  return *foo;\n+}\n+\n+vector signed long long\n+test1_nand (vector bool long long x, vector signed long long y)\n+{\n+  vector signed long long *foo;\n+  *foo += vec_nand (x, y);\n+  return *foo;\n+}\n+\n+vector signed long long\n+test2_orc (vector signed long long x, vector bool long long y)\n+{\n+  vector signed long long *foo;\n+  *foo += vec_orc (x, y);\n+  return *foo;\n+}\n+\n+vector signed long long\n+test2_nand (vector signed long long x, vector bool long long y)\n+{\n+  vector signed long long *foo;\n+  *foo += vec_nand (x, y);\n+  return *foo;\n+}\n+\n+vector signed long long\n+test3_orc (vector signed long long x, vector signed long long y)\n+{\n+  vector signed long long *foo;\n+  *foo += vec_orc (x, y);\n+  return *foo;\n+}\n+\n+vector signed long long\n+test3_nand (vector signed long long x, vector signed long long y)\n+{\n+  vector signed long long *foo;\n+  *foo += vec_nand (x, y);\n+  return *foo;\n+}\n+\n+vector unsigned long long\n+test4_orc (vector bool long long x, vector unsigned long long y)\n+{\n+  vector unsigned long long *foo;\n+  *foo += vec_orc (x, y);\n+  return *foo;\n+}\n+\n+vector unsigned long long\n+test4_nand (vector bool long long x, vector unsigned long long y)\n+{\n+  vector unsigned long long *foo;\n+  *foo += vec_nand (x, y);\n+  return *foo;\n+}\n+\n+vector unsigned long long\n+test5_orc (vector unsigned long long x, vector bool long long y)\n+{\n+  vector unsigned long long *foo;\n+  *foo += vec_orc (x, y);\n+  return *foo;\n+}\n+\n+vector unsigned long long\n+test5_nand (vector unsigned long long x, vector bool long long y)\n+{\n+  vector unsigned long long *foo;\n+  *foo += vec_nand (x, y);\n+  return *foo;\n+}\n+\n+vector unsigned long long\n+test6_orc (vector unsigned long long x, vector unsigned long long y)\n+{\n+  vector unsigned long long *foo;\n+  *foo += vec_orc (x, y);\n+  return *foo;\n+}\n+vector unsigned long long\n+test6_nand (vector unsigned long long x, vector unsigned long long y)\n+{\n+  vector unsigned long long *foo;\n+  *foo += vec_nand (x, y);\n+  return *foo;\n+}\n+\n+/* { dg-final { scan-assembler-times {\\mxxlorc\\M} 6 } } */\n+/* { dg-final { scan-assembler-times {\\mxxlnand\\M} 6 } } */"}, {"sha": "cc354b935dcc15ce03b2f2be7b60af72fcd2ff7b", "filename": "gcc/testsuite/gcc.target/powerpc/fold-vec-logical-other-short.c", "status": "added", "additions": 108, "deletions": 0, "changes": 108, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a7785078b5edd903bf07686b3cdbc3c75a9bf58e/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Ffold-vec-logical-other-short.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a7785078b5edd903bf07686b3cdbc3c75a9bf58e/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Ffold-vec-logical-other-short.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Ffold-vec-logical-other-short.c?ref=a7785078b5edd903bf07686b3cdbc3c75a9bf58e", "patch": "@@ -0,0 +1,108 @@\n+/* Verify that overloaded built-ins for vec_orc and vec_nand with short\n+ * inputs produce the right results.  These intrinsics (vec_orc, \n+ * vec_nand) were added as part of ISA 2.07 (P8).  */\n+\n+/* { dg-do compile } */\n+/* { dg-require-effective-target powerpc_p8vector_ok } */\n+/* { dg-options \"-mpower8-vector -O1\" } */\n+\n+#include <altivec.h>\n+\n+vector signed short\n+test1_orc (vector bool short x, vector signed short y)\n+{\n+  vector signed short *foo;\n+  *foo += vec_orc (x, y);\n+  return *foo;\n+}\n+\n+vector signed short\n+test1_nand (vector bool short x, vector signed short y)\n+{\n+  vector signed short *foo;\n+  *foo += vec_nand (x, y);\n+  return *foo;\n+}\n+\n+vector signed short\n+test2_orc (vector signed short x, vector bool short y)\n+{\n+  vector signed short *foo;\n+  *foo += vec_orc (x, y);\n+  return *foo;\n+}\n+\n+vector signed short\n+test2_nand (vector signed short x, vector bool short y)\n+{\n+  vector signed short *foo;\n+  *foo += vec_nand (x, y);\n+  return *foo;\n+}\n+\n+vector signed short\n+test3_orc (vector signed short x, vector signed short y)\n+{\n+  vector signed short *foo;\n+  *foo += vec_orc (x, y);\n+  return *foo;\n+}\n+\n+vector signed short\n+test3_nand (vector signed short x, vector signed short y)\n+{\n+  vector signed short *foo;\n+  *foo += vec_nand (x, y);\n+  return *foo;\n+}\n+\n+vector unsigned short\n+test4_orc (vector bool short x, vector unsigned short y)\n+{\n+  vector unsigned short *foo;\n+  *foo += vec_orc (x, y);\n+  return *foo;\n+}\n+\n+vector unsigned short\n+test4_nand (vector bool short x, vector unsigned short y)\n+{\n+  vector unsigned short *foo;\n+  *foo += vec_nand (x, y);\n+  return *foo;\n+}\n+\n+vector unsigned short\n+test5_orc (vector unsigned short x, vector bool short y)\n+{\n+  vector unsigned short *foo;\n+  *foo += vec_orc (x, y);\n+  return *foo;\n+}\n+\n+vector unsigned short\n+test5_nand (vector unsigned short x, vector bool short y)\n+{\n+  vector unsigned short *foo;\n+  *foo += vec_nand (x, y);\n+  return *foo;\n+}\n+\n+vector unsigned short\n+test6_orc (vector unsigned short x, vector unsigned short y)\n+{\n+  vector unsigned short *foo;\n+  *foo += vec_orc (x, y);\n+  return *foo;\n+}\n+\n+vector unsigned short\n+test6_nand (vector unsigned short x, vector unsigned short y)\n+{\n+  vector unsigned short *foo;\n+  *foo += vec_nand (x, y);\n+  return *foo;\n+}\n+\n+/* { dg-final { scan-assembler-times {\\mxxlnand\\M} 6 } } */\n+/* { dg-final { scan-assembler-times {\\mxxlorc\\M} 6 } } */"}]}