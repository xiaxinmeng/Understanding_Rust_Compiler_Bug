{"sha": "9ae2a7c39995fe2830360d87331500efc1fc6f15", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OWFlMmE3YzM5OTk1ZmUyODMwMzYwZDg3MzMxNTAwZWZjMWZjNmYxNQ==", "commit": {"author": {"name": "Jonathan Wakely", "email": "jwakely@redhat.com", "date": "2019-03-07T14:15:53Z"}, "committer": {"name": "Jonathan Wakely", "email": "redi@gcc.gnu.org", "date": "2019-03-07T14:15:53Z"}, "message": "P0356R5 Simplified partial function application\n\n\t* include/std/functional [C++20] (_Bind_front, _Bind_front_t): Define\n\thelpers for bind_front.\n\t(bind_front, __cpp_lib_bind_front): Define.\n\t* testsuite/20_util/function_objects/bind_front/1.cc: New test.\n\nFrom-SVN: r269455", "tree": {"sha": "661834222054024347051c564fa9c5d16f312a58", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/661834222054024347051c564fa9c5d16f312a58"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/9ae2a7c39995fe2830360d87331500efc1fc6f15", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9ae2a7c39995fe2830360d87331500efc1fc6f15", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9ae2a7c39995fe2830360d87331500efc1fc6f15", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9ae2a7c39995fe2830360d87331500efc1fc6f15/comments", "author": {"login": "jwakely", "id": 1254480, "node_id": "MDQ6VXNlcjEyNTQ0ODA=", "avatar_url": "https://avatars.githubusercontent.com/u/1254480?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jwakely", "html_url": "https://github.com/jwakely", "followers_url": "https://api.github.com/users/jwakely/followers", "following_url": "https://api.github.com/users/jwakely/following{/other_user}", "gists_url": "https://api.github.com/users/jwakely/gists{/gist_id}", "starred_url": "https://api.github.com/users/jwakely/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jwakely/subscriptions", "organizations_url": "https://api.github.com/users/jwakely/orgs", "repos_url": "https://api.github.com/users/jwakely/repos", "events_url": "https://api.github.com/users/jwakely/events{/privacy}", "received_events_url": "https://api.github.com/users/jwakely/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jwakely", "id": 1254480, "node_id": "MDQ6VXNlcjEyNTQ0ODA=", "avatar_url": "https://avatars.githubusercontent.com/u/1254480?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jwakely", "html_url": "https://github.com/jwakely", "followers_url": "https://api.github.com/users/jwakely/followers", "following_url": "https://api.github.com/users/jwakely/following{/other_user}", "gists_url": "https://api.github.com/users/jwakely/gists{/gist_id}", "starred_url": "https://api.github.com/users/jwakely/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jwakely/subscriptions", "organizations_url": "https://api.github.com/users/jwakely/orgs", "repos_url": "https://api.github.com/users/jwakely/repos", "events_url": "https://api.github.com/users/jwakely/events{/privacy}", "received_events_url": "https://api.github.com/users/jwakely/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "20faba6ddf316ea84b764b305ec1f9372f7f0ebd", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/20faba6ddf316ea84b764b305ec1f9372f7f0ebd", "html_url": "https://github.com/Rust-GCC/gccrs/commit/20faba6ddf316ea84b764b305ec1f9372f7f0ebd"}], "stats": {"total": 284, "additions": 284, "deletions": 0}, "files": [{"sha": "4aa4c5ef28b14854c56a18f52cee13a29aae0b04", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ae2a7c39995fe2830360d87331500efc1fc6f15/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ae2a7c39995fe2830360d87331500efc1fc6f15/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=9ae2a7c39995fe2830360d87331500efc1fc6f15", "patch": "@@ -1,3 +1,11 @@\n+2019-03-07  Jonathan Wakely  <jwakely@redhat.com>\n+\n+\tP0356R5 Simplified partial function application\n+\t* include/std/functional [C++20] (_Bind_front, _Bind_front_t): Define\n+\thelpers for bind_front.\n+\t(bind_front, __cpp_lib_bind_front): Define.\n+\t* testsuite/20_util/function_objects/bind_front/1.cc: New test.\n+\n 2019-03-06  Jonathan Wakely  <jwakely@redhat.com>\n \n \t* include/std/type_traits (__cpp_lib_bounded_array_traits): Define."}, {"sha": "8cf2c670648e51501e364e398337ef3f91d6c0b6", "filename": "libstdc++-v3/include/std/functional", "status": "modified", "additions": 100, "deletions": 0, "changes": 100, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ae2a7c39995fe2830360d87331500efc1fc6f15/libstdc%2B%2B-v3%2Finclude%2Fstd%2Ffunctional", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ae2a7c39995fe2830360d87331500efc1fc6f15/libstdc%2B%2B-v3%2Finclude%2Fstd%2Ffunctional", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fstd%2Ffunctional?ref=9ae2a7c39995fe2830360d87331500efc1fc6f15", "patch": "@@ -836,6 +836,106 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \t\t\t\t\t  std::forward<_BoundArgs>(__args)...);\n     }\n \n+#if __cplusplus > 201703L\n+#define __cpp_lib_bind_front 201902L\n+\n+  template<typename _Fd, typename... _BoundArgs>\n+    struct _Bind_front\n+    {\n+      static_assert(is_move_constructible_v<_Fd>);\n+      static_assert((is_move_constructible_v<_BoundArgs> && ...));\n+\n+      // First parameter is to ensure this constructor is never used\n+      // instead of the copy/move constructor.\n+      template<typename _Fn, typename... _Args>\n+\texplicit constexpr\n+\t_Bind_front(int, _Fn&& __fn, _Args&&... __args)\n+\tnoexcept(__and_<is_nothrow_constructible<_Fd, _Fn>,\n+\t\t\tis_nothrow_constructible<_BoundArgs, _Args>...>::value)\n+\t: _M_fd(std::forward<_Fn>(__fn)),\n+\t  _M_bound_args(std::forward<_Args>(__args)...)\n+\t{ static_assert(sizeof...(_Args) == sizeof...(_BoundArgs)); }\n+\n+      _Bind_front(const _Bind_front&) = default;\n+      _Bind_front(_Bind_front&&) = default;\n+      _Bind_front& operator=(const _Bind_front&) = default;\n+      _Bind_front& operator=(_Bind_front&&) = default;\n+      ~_Bind_front() = default;\n+\n+      template<typename... _CallArgs>\n+\tconstexpr\n+\tinvoke_result_t<_Fd&, _BoundArgs&..., _CallArgs...>\n+\toperator()(_CallArgs&&... __call_args) &\n+\tnoexcept(is_nothrow_invocable_v<_Fd&, _BoundArgs&..., _CallArgs...>)\n+\t{\n+\t  return _S_call(*this, _BoundIndices(),\n+\t      std::forward<_CallArgs>(__call_args)...);\n+\t}\n+\n+      template<typename... _CallArgs>\n+\tconstexpr\n+\tinvoke_result_t<const _Fd&, const _BoundArgs&..., _CallArgs...>\n+\toperator()(_CallArgs&&... __call_args) const &\n+\tnoexcept(is_nothrow_invocable_v<const _Fd&, const _BoundArgs&...,\n+\t\t\t\t\t_CallArgs...>)\n+\t{\n+\t  return _S_call(*this, _BoundIndices(),\n+\t      std::forward<_CallArgs>(__call_args)...);\n+\t}\n+\n+      template<typename... _CallArgs>\n+\tconstexpr\n+\tinvoke_result_t<_Fd, _BoundArgs..., _CallArgs...>\n+\toperator()(_CallArgs&&... __call_args) &&\n+\tnoexcept(is_nothrow_invocable_v<_Fd, _BoundArgs..., _CallArgs...>)\n+\t{\n+\t  return _S_call(std::move(*this), _BoundIndices(),\n+\t      std::forward<_CallArgs>(__call_args)...);\n+\t}\n+\n+      template<typename... _CallArgs>\n+\tconstexpr\n+\tinvoke_result_t<const _Fd, const _BoundArgs..., _CallArgs...>\n+\toperator()(_CallArgs&&... __call_args) const &&\n+\tnoexcept(is_nothrow_invocable_v<const _Fd, const _BoundArgs...,\n+\t\t\t\t\t_CallArgs...>)\n+\t{\n+\t  return _S_call(std::move(*this), _BoundIndices(),\n+\t      std::forward<_CallArgs>(__call_args)...);\n+\t}\n+\n+    private:\n+      using _BoundIndices = index_sequence_for<_BoundArgs...>;\n+\n+      template<typename _Tp, size_t... _Ind, typename... _CallArgs>\n+\tstatic constexpr\n+\tdecltype(auto)\n+\t_S_call(_Tp&& __g, index_sequence<_Ind...>, _CallArgs&&... __call_args)\n+\t{\n+\t  return std::invoke(std::forward<_Tp>(__g)._M_fd,\n+\t      std::get<_Ind>(std::forward<_Tp>(__g)._M_bound_args)...,\n+\t      std::forward<_CallArgs>(__call_args)...);\n+\t}\n+\n+      _Fd _M_fd;\n+      std::tuple<_BoundArgs...> _M_bound_args;\n+    };\n+\n+  template<typename _Fn, typename... _Args>\n+    using _Bind_front_t\n+      = _Bind_front<decay_t<_Fn>, unwrap_ref_decay_t<_Args>...>;\n+\n+  template<typename _Fn, typename... _Args>\n+    _Bind_front_t<_Fn, _Args...>\n+    bind_front(_Fn&& __fn, _Args&&... __args)\n+    noexcept(is_nothrow_constructible_v<int, _Bind_front_t<_Fn, _Args...>,\n+\t\t\t\t\t_Fn, _Args...>)\n+    {\n+      return _Bind_front_t<_Fn, _Args...>(0, std::forward<_Fn>(__fn),\n+\t\t\t\t\t  std::forward<_Args>(__args)...);\n+    }\n+#endif\n+\n #if __cplusplus >= 201402L\n   /// Generalized negator.\n   template<typename _Fn>"}, {"sha": "eea31e9e8a52c07626a286f714ff5d5fd8c4e11c", "filename": "libstdc++-v3/testsuite/20_util/function_objects/bind_front/1.cc", "status": "added", "additions": 176, "deletions": 0, "changes": 176, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ae2a7c39995fe2830360d87331500efc1fc6f15/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Ffunction_objects%2Fbind_front%2F1.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ae2a7c39995fe2830360d87331500efc1fc6f15/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Ffunction_objects%2Fbind_front%2F1.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Ffunction_objects%2Fbind_front%2F1.cc?ref=9ae2a7c39995fe2830360d87331500efc1fc6f15", "patch": "@@ -0,0 +1,176 @@\n+// Copyright (C) 2014-2019 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// { dg-options \"-std=gnu++2a\" }\n+// { dg-do compile { target c++2a } }\n+\n+#include <functional>\n+#include <testsuite_hooks.h>\n+\n+#ifndef __cpp_lib_bind_front\n+# error \"Feature test macro for bind_front is missing\"\n+#elif __cpp_lib_bind_front < 201811L\n+# error \"Feature test macro for bind_front has wrong value\"\n+#endif\n+\n+using std::bind_front;\n+using std::is_same_v;\n+using std::is_invocable_v;\n+using std::is_invocable_r_v;\n+\n+void\n+test01()\n+{\n+  struct F { void operator()() {} };\n+\n+  // Arguments should be decayed:\n+  static_assert(std::is_same_v<\n+      decltype(bind_front(std::declval<F>(), std::declval<int>())),\n+      decltype(bind_front(std::declval<F&>(), std::declval<int&>()))\n+      >);\n+  static_assert(std::is_same_v<\n+      decltype(bind_front(std::declval<F>(), std::declval<int>())),\n+      decltype(bind_front(std::declval<const F&>(), std::declval<const int&>()))\n+      >);\n+\n+  // Reference wrappers should be handled:\n+  static_assert(!std::is_same_v<\n+      decltype(bind_front(std::declval<F>(), std::declval<int&>())),\n+      decltype(bind_front(std::declval<F>(), std::ref(std::declval<int&>())))\n+      >);\n+  static_assert(!std::is_same_v<\n+      decltype(bind_front(std::declval<F>(), std::declval<const int&>())),\n+      decltype(bind_front(std::declval<F>(), std::cref(std::declval<int&>())))\n+      >);\n+  static_assert(!std::is_same_v<\n+      decltype(bind_front(std::declval<F>(), std::ref(std::declval<int&>()))),\n+      decltype(bind_front(std::declval<F>(), std::cref(std::declval<int&>())))\n+      >);\n+}\n+\n+void\n+test02()\n+{\n+  struct quals\n+  {\n+    bool as_const;\n+    bool as_lvalue;\n+  };\n+\n+  struct F\n+  {\n+    quals operator()() & { return { false, true }; }\n+    quals operator()() const & { return { true, true }; }\n+    quals operator()() && { return { false, false }; }\n+    quals operator()() const && { return { true, false }; }\n+  };\n+\n+  F f;\n+  auto g = bind_front(f);\n+  const auto& cg = g;\n+  quals q;\n+\n+  // constness and value category should be forwarded to the target object:\n+  q = g();\n+  VERIFY( ! q.as_const && q.as_lvalue );\n+  std::move(g)();\n+  VERIFY( ! q.as_const && ! q.as_lvalue );\n+  q = cg();\n+  VERIFY( q.as_const && q.as_lvalue );\n+  q = std::move(cg)();\n+  VERIFY( q.as_const && ! q.as_lvalue );\n+}\n+\n+void\n+test03()\n+{\n+  struct F\n+  {\n+    int& operator()(int& i, void*) { return i; }\n+    void* operator()(int, void* p) const { return p; }\n+  };\n+\n+  int i = 5;\n+  void* vp = &vp; // arbitrary void* value\n+\n+  auto g1 = bind_front(F{}, i); // call wrapper has bound arg of type int\n+  using G1 = decltype(g1);\n+  // Invoking G1& will pass g1's bound arg as int&, so calls first overload:\n+  static_assert(is_invocable_r_v<int&, G1&, void*>);\n+  // Invoking const G1& or G&& calls second overload:\n+  static_assert(is_invocable_r_v<void*, const G1&, void*>);\n+  static_assert(is_invocable_r_v<void*, G1&&, void*>);\n+  void* p1 = static_cast<G1&&>(g1)(vp);\n+  VERIFY( p1 == vp );\n+\n+  auto g2 = bind_front(F{}, std::ref(i)); // bound arg of type int&\n+  using G2 = decltype(g2);\n+  // Bound arg always forwarded as int& even from G2&& or const G2&\n+  static_assert(is_invocable_r_v<int&, G2&, void*>);\n+  static_assert(is_invocable_r_v<int&, G2&&, void*>);\n+  // But cannot call first overload on const G2:\n+  static_assert(is_invocable_r_v<void*, const G2&, void*>);\n+  static_assert(is_invocable_r_v<void*, const G2&&, void*>);\n+  int& i2 = g2(vp);\n+  VERIFY( &i2 == &i );\n+  int& i2r = static_cast<G2&&>(g2)(vp);\n+  VERIFY( &i2r == &i );\n+  void* p2 = const_cast<const G2&>(g2)(vp);\n+  VERIFY( p2 == vp );\n+\n+  auto g3 = bind_front(F{}, std::cref(i)); // bound arg of type const int&\n+  using G3 = decltype(g3);\n+  // Bound arg always forwarded as const int& so can only call second overload:\n+  static_assert(is_invocable_r_v<void*, G3&, void*>);\n+  static_assert(is_invocable_r_v<void*, G3&&, void*>);\n+  static_assert(is_invocable_r_v<void*, const G3&, void*>);\n+  static_assert(is_invocable_r_v<void*, const G3&&, void*>);\n+\n+  auto g4 = bind_front(g2, nullptr);\n+  using G4 = decltype(g4);\n+  static_assert(is_invocable_r_v<int&, G4&>);\n+  static_assert(is_invocable_r_v<int&, G4&&>);\n+  static_assert(is_invocable_r_v<void*, const G4&>);\n+  static_assert(is_invocable_r_v<void*, const G4&&>);\n+}\n+\n+int f(int i, int j, int k) { return i + j + k; }\n+\n+void\n+test04()\n+{\n+  auto g = bind_front(f);\n+  VERIFY( g(1, 2, 3) == 6 );\n+  auto g1 = bind_front(f, 1);\n+  VERIFY( g1(2, 3) == 6 );\n+  VERIFY( bind_front(g, 1)(2, 3) == 6 );\n+  auto g2 = bind_front(f, 1, 2);\n+  VERIFY( g2(3) == 6 );\n+  VERIFY( bind_front(g1, 2)(3) == 6 );\n+  auto g3 = bind_front(f, 1, 2, 3);\n+  VERIFY( g3() == 6 );\n+  VERIFY( bind_front(g2, 3)() == 6 );\n+}\n+\n+int\n+main()\n+{\n+  test01();\n+  test02();\n+  test03();\n+  test04();\n+}"}]}