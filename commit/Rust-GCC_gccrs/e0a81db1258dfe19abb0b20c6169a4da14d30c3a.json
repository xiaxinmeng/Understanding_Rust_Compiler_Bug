{"sha": "e0a81db1258dfe19abb0b20c6169a4da14d30c3a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTBhODFkYjEyNThkZmUxOWFiYjBiMjBjNjE2OWE0ZGExNGQzMGMzYQ==", "commit": {"author": {"name": "Uros Bizjak", "email": "uros@gcc.gnu.org", "date": "2014-04-14T17:49:36Z"}, "committer": {"name": "Uros Bizjak", "email": "uros@gcc.gnu.org", "date": "2014-04-14T17:49:36Z"}, "message": "i386.c (examine_argument): Return bool.\n\n\t* config/i386/i386.c (examine_argument): Return bool.  Return true if\n\tparameter should be passed in memory.\n\t<case X86_64_COMPLEX_X87_CLASS>: Adjust.\n\t(construct_container): Update calls to examine_argument.\n\t(function_arg_advance_64): Ditto.\n\t(return_in_memory_32): Merge with ix86_return_in_memory.\n\t(return_in_memory_64): Ditto.\n\t(return_in_memory_ms_64): Ditto.\n\nFrom-SVN: r209388", "tree": {"sha": "a96b3c8300f61480a0b34625cd423adc75265452", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a96b3c8300f61480a0b34625cd423adc75265452"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e0a81db1258dfe19abb0b20c6169a4da14d30c3a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e0a81db1258dfe19abb0b20c6169a4da14d30c3a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e0a81db1258dfe19abb0b20c6169a4da14d30c3a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e0a81db1258dfe19abb0b20c6169a4da14d30c3a/comments", "author": null, "committer": null, "parents": [{"sha": "cb90235dad713561e78ca7dd929218f22919cd24", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cb90235dad713561e78ca7dd929218f22919cd24", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cb90235dad713561e78ca7dd929218f22919cd24"}], "stats": {"total": 202, "additions": 101, "deletions": 101}, "files": [{"sha": "91bb92fedbe39c6dbd65082156821bc3083223b6", "filename": "gcc/ChangeLog", "status": "modified", "additions": 27, "deletions": 21, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e0a81db1258dfe19abb0b20c6169a4da14d30c3a/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e0a81db1258dfe19abb0b20c6169a4da14d30c3a/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=e0a81db1258dfe19abb0b20c6169a4da14d30c3a", "patch": "@@ -1,3 +1,14 @@\n+2014-04-14  Uros Bizjak  <ubizjak@gmail.com>\n+\n+\t* config/i386/i386.c (examine_argument): Return bool.  Return true if\n+\tparameter should be passed in memory.\n+\t<case X86_64_COMPLEX_X87_CLASS>: Adjust.\n+\t(construct_container): Update calls to examine_argument.\n+\t(function_arg_advance_64): Ditto.\n+\t(return_in_memory_32): Merge with ix86_return_in_memory.\n+\t(return_in_memory_64): Ditto.\n+\t(return_in_memory_ms_64): Ditto.\n+\n 2014-04-14  Jan Hubicka  <hubicka@ucw.cz>\n \n \t* ipa-utils.c (ipa_merge_profiles): Merge profile_id.\n@@ -12,8 +23,7 @@\n 2014-04-14  H.J. Lu  <hongjiu.lu@intel.com>\n \n \tPR target/60827\n-\t* config/i386/i386.md (*fixuns_trunc<mode>_1): Revert the last\n-\tchange.\n+\t* config/i386/i386.md (*fixuns_trunc<mode>_1): Revert the last change.\n \n 2014-04-14  H.J. Lu  <hongjiu.lu@intel.com>\n \n@@ -181,8 +191,7 @@\n 2014-04-11  Tobias Burnus  <burnus@net-b.de>\n \n \tPR other/59055\n-\t* doc/bugreport.texi (Bugs): Remove nodes pointing to the\n-\tnirvana.\n+\t* doc/bugreport.texi (Bugs): Remove nodes pointing to the nirvana.\n \t* doc/gcc.texi (Service): Update description in the @menu\n \t* doc/invoke.texi (Option Summary): Remove misplaced and\n \tduplicated @menu.\n@@ -208,15 +217,14 @@\n 2014-04-11  Jakub Jelinek  <jakub@redhat.com>\n \n \tPR rtl-optimization/60663\n-\t* cse.c (cse_insn): Set src_volatile on ASM_OPERANDS in\n-\tPARALLEL.\n+\t* cse.c (cse_insn): Set src_volatile on ASM_OPERANDS in PARALLEL.\n \n 2014-04-10  Jan Hubicka  <hubicka@ucw.cz>\n \t    Jakub Jelinek  <jakub@redhat.com>\n \n \tPR lto/60567\n-\t* ipa.c (function_and_variable_visibility): Copy forced_by_abi flag from\n-\tdecl_node to node.\n+\t* ipa.c (function_and_variable_visibility): Copy forced_by_abi\n+\tflag from decl_node to node.\n \n 2014-04-10  Ramana Radhakrishnan  <ramana.radhakrishnan@arm.com>\n \n@@ -334,9 +342,10 @@\n \n 2014-04-05  Pitchumani Sivanupandi  <Pitchumani.S@atmel.com>\n \n-\t* config/avr/avr-arch.h (avr_mcu_t): Add dev_attribute field to have device\n-\tspecific ISA/ feature information. Remove short_sp and errata_skip ds.\n-\tAdd avr_device_specific_features enum to have device specific info.\n+\t* config/avr/avr-arch.h (avr_mcu_t): Add dev_attribute field to have\n+\tdevice specific ISA/ feature information. Remove short_sp and\n+\terrata_skip ds.  Add avr_device_specific_features enum to have device\n+\tspecific info.\n \t* config/avr/avr-c.c (avr_cpu_cpp_builtins): use dev_attribute to check\n \terrata_skip. Add __AVR_ISA_RMW__ builtin macro if RMW ISA available.\n \t* config/avr/avr-devices.c (avr_mcu_types): Update AVR_MCU macro for\n@@ -456,8 +465,8 @@\n \n \tPR tree-optimization/60505\n \t* tree-vectorizer.h (struct _stmt_vec_info): Add th field as the\n-\tthreshold of number of iterations below which no vectorization will be\n-\tdone.\n+\tthreshold of number of iterations below which no vectorization\n+\twill be done.\n \t* tree-vect-loop.c (new_loop_vec_info):\n \tInitialize LOOP_VINFO_COST_MODEL_THRESHOLD.\n \t* tree-vect-loop.c (vect_analyze_loop_operations):\n@@ -469,8 +478,7 @@\n \n 2014-04-03  Richard Biener  <rguenther@suse.de>\n \n-\t* tree-streamer.h (struct streamer_tree_cache_d): Add next_idx\n-\tmember.\n+\t* tree-streamer.h (struct streamer_tree_cache_d): Add next_idx member.\n \t(streamer_tree_cache_create): Adjust.\n \t* tree-streamer.c (streamer_tree_cache_add_to_node_array): Adjust\n \tto allow optional nodes array.\n@@ -481,8 +489,7 @@\n \t* lto-streamer-out.c (create_output_block): Avoid maintaining\n \tthe node array in the writer cache.\n \t(DFS_write_tree): Remove assertion.\n-\t(produce_asm_for_decls): Free the out decl state hash table\n-\tearly.\n+\t(produce_asm_for_decls): Free the out decl state hash table early.\n \t* lto-streamer-in.c (lto_data_in_create): Adjust for\n \tstreamer_tree_cache_create prototype change.\n \n@@ -536,8 +543,8 @@\n 2014-04-02  Jan Hubicka  <hubicka@ucw.cz>\n \n \tPR ipa/60659\n-\t* ipa-devirt.c (get_polymorphic_call_info): Do not ICE on type inconsistent\n-\tcode and instead mark the context inconsistent.\n+\t* ipa-devirt.c (get_polymorphic_call_info): Do not ICE on type\n+\tinconsistent code and instead mark the context inconsistent.\n \t(possible_polymorphic_call_targets): For inconsistent contexts\n \treturn empty complete list.\n \n@@ -641,8 +648,7 @@\n \n 2014-04-01  Richard Biener  <rguenther@suse.de>\n \n-\t* gimple.h (struct gimple_statement_base): Align subcode to\n-\t16 bits.\n+\t* gimple.h (struct gimple_statement_base): Align subcode to 16 bits.\n \n 2014-04-01  Sebastian Huber  <sebastian.huber@embedded-brains.de>\n "}, {"sha": "f2e6957169deae4f2ea0887518289ba523a787db", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 74, "deletions": 80, "changes": 154, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e0a81db1258dfe19abb0b20c6169a4da14d30c3a/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e0a81db1258dfe19abb0b20c6169a4da14d30c3a/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=e0a81db1258dfe19abb0b20c6169a4da14d30c3a", "patch": "@@ -6806,8 +6806,9 @@ classify_argument (enum machine_mode mode, const_tree type,\n }\n \n /* Examine the argument and return set number of register required in each\n-   class.  Return 0 iff parameter should be passed in memory.  */\n-static int\n+   class.  Return true iff parameter should be passed in memory.  */\n+\n+static bool\n examine_argument (enum machine_mode mode, const_tree type, int in_return,\n \t\t  int *int_nregs, int *sse_nregs)\n {\n@@ -6816,8 +6817,9 @@ examine_argument (enum machine_mode mode, const_tree type, int in_return,\n \n   *int_nregs = 0;\n   *sse_nregs = 0;\n+\n   if (!n)\n-    return 0;\n+    return true;\n   for (n--; n >= 0; n--)\n     switch (regclass[n])\n       {\n@@ -6835,15 +6837,15 @@ examine_argument (enum machine_mode mode, const_tree type, int in_return,\n \tbreak;\n       case X86_64_X87_CLASS:\n       case X86_64_X87UP_CLASS:\n+      case X86_64_COMPLEX_X87_CLASS:\n \tif (!in_return)\n-\t  return 0;\n+\t  return true;\n \tbreak;\n-      case X86_64_COMPLEX_X87_CLASS:\n-\treturn in_return ? 2 : 0;\n       case X86_64_MEMORY_CLASS:\n \tgcc_unreachable ();\n       }\n-  return 1;\n+\n+  return false;\n }\n \n /* Construct container for the argument used by GCC interface.  See\n@@ -6873,8 +6875,8 @@ construct_container (enum machine_mode mode, enum machine_mode orig_mode,\n   n = classify_argument (mode, type, regclass, 0);\n   if (!n)\n     return NULL;\n-  if (!examine_argument (mode, type, in_return, &needed_intregs,\n-\t\t\t &needed_sseregs))\n+  if (examine_argument (mode, type, in_return, &needed_intregs,\n+\t\t\t&needed_sseregs))\n     return NULL;\n   if (needed_intregs > nintregs || needed_sseregs > nsseregs)\n     return NULL;\n@@ -7193,7 +7195,7 @@ function_arg_advance_64 (CUMULATIVE_ARGS *cum, enum machine_mode mode,\n \t\t || VALID_AVX256_REG_MODE (mode)))\n     return;\n \n-  if (examine_argument (mode, type, 0, &int_nregs, &sse_nregs)\n+  if (!examine_argument (mode, type, 0, &int_nregs, &sse_nregs)\n       && sse_nregs <= cum->sse_nregs && int_nregs <= cum->nregs)\n     {\n       cum->nregs -= int_nregs;\n@@ -7988,95 +7990,87 @@ ix86_libcall_value (enum machine_mode mode)\n \n /* Return true iff type is returned in memory.  */\n \n-static bool ATTRIBUTE_UNUSED\n-return_in_memory_32 (const_tree type, enum machine_mode mode)\n+static bool\n+ix86_return_in_memory (const_tree type, const_tree fntype ATTRIBUTE_UNUSED)\n {\n+#ifdef SUBTARGET_RETURN_IN_MEMORY\n+  return SUBTARGET_RETURN_IN_MEMORY (type, fntype);\n+#else\n+  const enum machine_mode mode = type_natural_mode (type, NULL, true);\n   HOST_WIDE_INT size;\n \n-  if (mode == BLKmode)\n-    return true;\n-\n-  size = int_size_in_bytes (type);\n-\n-  if (MS_AGGREGATE_RETURN && AGGREGATE_TYPE_P (type) && size <= 8)\n-    return false;\n-\n-  if (VECTOR_MODE_P (mode) || mode == TImode)\n+  if (TARGET_64BIT)\n     {\n-      /* User-created vectors small enough to fit in EAX.  */\n-      if (size < 8)\n-\treturn false;\n-\n-      /* MMX/3dNow values are returned in MM0,\n-\t except when it doesn't exits or the ABI prescribes otherwise.  */\n-      if (size == 8)\n-\treturn !TARGET_MMX || TARGET_VECT8_RETURNS;\n+      if (ix86_function_type_abi (fntype) == MS_ABI)\n+\t{\n+\t  size = int_size_in_bytes (type);\n \n-      /* SSE values are returned in XMM0, except when it doesn't exist.  */\n-      if (size == 16)\n-\treturn !TARGET_SSE;\n+\t  /* __m128 is returned in xmm0.  */\n+\t  if ((!type || VECTOR_INTEGER_TYPE_P (type)\n+\t       || INTEGRAL_TYPE_P (type)\n+\t       || VECTOR_FLOAT_TYPE_P (type))\n+\t      && (SCALAR_INT_MODE_P (mode) || VECTOR_MODE_P (mode))\n+\t      && !COMPLEX_MODE_P (mode)\n+\t      && (GET_MODE_SIZE (mode) == 16 || size == 16))\n+\t    return false;\n \n-      /* AVX values are returned in YMM0, except when it doesn't exist.  */\n-      if (size == 32)\n-\treturn !TARGET_AVX;\n+\t  /* Otherwise, the size must be exactly in [1248]. */\n+\t  return size != 1 && size != 2 && size != 4 && size != 8;\n+\t}\n+      else\n+\t{\n+\t  int needed_intregs, needed_sseregs;\n \n-      /* AVX512F values are returned in ZMM0, except when it doesn't exist.  */\n-      if (size == 64)\n-\treturn !TARGET_AVX512F;\n+\t  return examine_argument (mode, type, 1,\n+\t\t\t\t   &needed_intregs, &needed_sseregs);\n+\t}\n     }\n+  else\n+    {\n+      if (mode == BLKmode)\n+\treturn true;\n \n-  if (mode == XFmode)\n-    return false;\n+      size = int_size_in_bytes (type);\n \n-  if (size > 12)\n-    return true;\n+      if (MS_AGGREGATE_RETURN && AGGREGATE_TYPE_P (type) && size <= 8)\n+\treturn false;\n \n-  /* OImode shouldn't be used directly.  */\n-  gcc_assert (mode != OImode);\n+      if (VECTOR_MODE_P (mode) || mode == TImode)\n+\t{\n+\t  /* User-created vectors small enough to fit in EAX.  */\n+\t  if (size < 8)\n+\t    return false;\n \n-  return false;\n-}\n+\t  /* Unless ABI prescibes otherwise,\n+\t     MMX/3dNow values are returned in MM0 if available.  */\n+\t     \n+\t  if (size == 8)\n+\t    return TARGET_VECT8_RETURNS || !TARGET_MMX;\n \n-static bool ATTRIBUTE_UNUSED\n-return_in_memory_64 (const_tree type, enum machine_mode mode)\n-{\n-  int needed_intregs, needed_sseregs;\n-  return !examine_argument (mode, type, 1, &needed_intregs, &needed_sseregs);\n-}\n+\t  /* SSE values are returned in XMM0 if available.  */\n+\t  if (size == 16)\n+\t    return !TARGET_SSE;\n \n-static bool ATTRIBUTE_UNUSED\n-return_in_memory_ms_64 (const_tree type, enum machine_mode mode)\n-{\n-  HOST_WIDE_INT size = int_size_in_bytes (type);\n+\t  /* AVX values are returned in YMM0 if available.  */\n+\t  if (size == 32)\n+\t    return !TARGET_AVX;\n \n-  /* __m128 is returned in xmm0.  */\n-  if ((!type || VECTOR_INTEGER_TYPE_P (type) || INTEGRAL_TYPE_P (type)\n-       || VECTOR_FLOAT_TYPE_P (type))\n-      && (SCALAR_INT_MODE_P (mode) || VECTOR_MODE_P (mode))\n-      && !COMPLEX_MODE_P (mode) && (GET_MODE_SIZE (mode) == 16 || size == 16))\n-    return false;\n+\t  /* AVX512F values are returned in ZMM0 if available.  */\n+\t  if (size == 64)\n+\t    return !TARGET_AVX512F;\n+\t}\n \n-  /* Otherwise, the size must be exactly in [1248]. */\n-  return size != 1 && size != 2 && size != 4 && size != 8;\n-}\n+      if (mode == XFmode)\n+\treturn false;\n \n-static bool\n-ix86_return_in_memory (const_tree type, const_tree fntype ATTRIBUTE_UNUSED)\n-{\n-#ifdef SUBTARGET_RETURN_IN_MEMORY\n-  return SUBTARGET_RETURN_IN_MEMORY (type, fntype);\n-#else\n-  const enum machine_mode mode = type_natural_mode (type, NULL, true);\n+      if (size > 12)\n+\treturn true;\n \n-  if (TARGET_64BIT)\n-    {\n-      if (ix86_function_type_abi (fntype) == MS_ABI)\n-\treturn return_in_memory_ms_64 (type, mode);\n-      else\n-\treturn return_in_memory_64 (type, mode);\n+      /* OImode shouldn't be used directly.  */\n+      gcc_assert (mode != OImode);\n+\n+      return false;\n     }\n-  else\n-    return return_in_memory_32 (type, mode);\n #endif\n }\n "}]}