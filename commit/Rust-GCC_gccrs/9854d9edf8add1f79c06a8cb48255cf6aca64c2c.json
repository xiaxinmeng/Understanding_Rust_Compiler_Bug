{"sha": "9854d9edf8add1f79c06a8cb48255cf6aca64c2c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTg1NGQ5ZWRmOGFkZDFmNzljMDZhOGNiNDgyNTVjZjZhY2E2NGMyYw==", "commit": {"author": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1993-04-12T19:27:55Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1993-04-12T19:27:55Z"}, "message": "(print_operand): Sort all cases in alphabetical order.\n\n(print_operand, case 'G'): New case.\n(output_epilog): Know that \"GNU Obj-C\" is the language string for Objective-C.\n\nFrom-SVN: r4100", "tree": {"sha": "7ec31741ec1669b31e4e619bd2e9336d26f52b53", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/7ec31741ec1669b31e4e619bd2e9336d26f52b53"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/9854d9edf8add1f79c06a8cb48255cf6aca64c2c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9854d9edf8add1f79c06a8cb48255cf6aca64c2c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9854d9edf8add1f79c06a8cb48255cf6aca64c2c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9854d9edf8add1f79c06a8cb48255cf6aca64c2c/comments", "author": null, "committer": null, "parents": [{"sha": "2afabb483c5fe1f2c1b351cac76e21a2fd259428", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2afabb483c5fe1f2c1b351cac76e21a2fd259428", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2afabb483c5fe1f2c1b351cac76e21a2fd259428"}], "stats": {"total": 421, "additions": 216, "deletions": 205}, "files": [{"sha": "69dca321d1978c69d2643603a10f502fb73c5b6e", "filename": "gcc/config/rs6000/rs6000.c", "status": "modified", "additions": 216, "deletions": 205, "changes": 421, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9854d9edf8add1f79c06a8cb48255cf6aca64c2c/gcc%2Fconfig%2Frs6000%2Frs6000.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9854d9edf8add1f79c06a8cb48255cf6aca64c2c/gcc%2Fconfig%2Frs6000%2Frs6000.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.c?ref=9854d9edf8add1f79c06a8cb48255cf6aca64c2c", "patch": "@@ -709,15 +709,98 @@ print_operand (file, x, code)\n \n   switch (code)\n     {\n-    case 'k':\n-      /* X must be a constant.  Write the 1's complement of the\n-\t constant.  */\n+    case 'A':\n+      /* If X is a constant integer whose low-order 5 bits are zero,\n+\t write 'l'.  Otherwise, write 'r'.  This is a kludge to fix a bug\n+\t in the RS/6000 assembler where \"sri\" with a zero shift count\n+\t write a trash instruction.  */\n+      if (GET_CODE (x) == CONST_INT && (INTVAL (x) & 31) == 0)\n+\tfprintf (file, \"l\");\n+      else\n+\tfprintf (file, \"r\");\n+      return;\n+\n+    case 'b':\n+      /* Low-order 16 bits of constant, unsigned.  */\n       if (! INT_P (x))\n-\toutput_operand_lossage (\"invalid %%k value\");\n+\toutput_operand_lossage (\"invalid %%b value\");\n \n-      fprintf (file, \"%d\", ~ INT_LOWPART (x));\n+      fprintf (file, \"%d\", INT_LOWPART (x) & 0xffff);\n       return;\n \n+    case 'C':\n+      /* This is an optional cror needed for LE or GE floating-point\n+\t comparisons.  Otherwise write nothing.  */\n+      if ((GET_CODE (x) == LE || GET_CODE (x) == GE)\n+\t  && GET_MODE (XEXP (x, 0)) == CCFPmode)\n+\t{\n+\t  int base_bit = 4 * (REGNO (XEXP (x, 0)) - 68);\n+\n+\t  fprintf (file, \"cror %d,%d,%d\\n\\t\", base_bit + 3,\n+\t\t   base_bit + 2, base_bit + (GET_CODE (x) == GE));\n+\t}\n+      return;\n+\n+    case 'D':\n+      /* Similar, except that this is for an scc, so we must be able to\n+\t encode the test in a single bit that is one.  We do the above\n+\t for any LE, GE, GEU, or LEU and invert the bit for NE.  */\n+      if (GET_CODE (x) == LE || GET_CODE (x) == GE\n+\t  || GET_CODE (x) == LEU || GET_CODE (x) == GEU)\n+\t{\n+\t  int base_bit = 4 * (REGNO (XEXP (x, 0)) - 68);\n+\n+\t  fprintf (file, \"cror %d,%d,%d\\n\\t\", base_bit + 3,\n+\t\t   base_bit + 2,\n+\t\t   base_bit + (GET_CODE (x) == GE || GET_CODE (x) == GEU));\n+\t}\n+\n+      else if (GET_CODE (x) == NE)\n+\t{\n+\t  int base_bit = 4 * (REGNO (XEXP (x, 0)) - 68);\n+\n+\t  fprintf (file, \"crnor %d,%d,%d\\n\\t\", base_bit + 3,\n+\t\t   base_bit + 2, base_bit + 2);\n+\t}\n+      return;\n+\n+    case 'E':\n+      /* X is a CR register.  Print the number of the third bit of the CR */\n+      if (GET_CODE (x) != REG || ! CR_REGNO_P (REGNO (x)))\n+\toutput_operand_lossage (\"invalid %%E value\");\n+\n+      fprintf(file, \"%d\", 4 * (REGNO (x) - 68) + 3);\n+      break;\n+\n+    case 'f':\n+      /* X is a CR register.  Print the shift count needed to move it\n+\t to the high-order four bits.  */\n+      if (GET_CODE (x) != REG || ! CR_REGNO_P (REGNO (x)))\n+\toutput_operand_lossage (\"invalid %%f value\");\n+      else\n+\tfprintf (file, \"%d\", 4 * (REGNO (x) - 68));\n+      return;\n+\n+    case 'F':\n+      /* Similar, but print the count for the rotate in the opposite\n+\t direction.  */\n+      if (GET_CODE (x) != REG || ! CR_REGNO_P (REGNO (x)))\n+\toutput_operand_lossage (\"invalid %%F value\");\n+      else\n+\tfprintf (file, \"%d\", 32 - 4 * (REGNO (x) - 68));\n+      return;\n+\n+    case 'G':\n+      /* X is a constant integer.  If it is negative, print \"m\",\n+\t otherwise print \"z\".  This is to make a aze or ame insn.  */\n+      if (GET_CODE (x) != CONST_INT)\n+\toutput_operand_lossage (\"invalid %%G value\");\n+      else if (INTVAL (x) >= 0)\n+\tfprintf (file, \"z\");\n+      else\n+\tfprintf (file, \"m\");\n+      return;\n+\t\n     case 'h':\n       /* If constant, output low-order five bits.  Otherwise,\n \t write normally. */\n@@ -735,66 +818,57 @@ print_operand (file, x, code)\n       fprintf (file, \"%d\", (INT_LOWPART (x) + 24) & 31);\n       return;\n \n-    case 'b':\n-      /* Low-order 16 bits of constant, unsigned.  */\n-      if (! INT_P (x))\n-\toutput_operand_lossage (\"invalid %%b value\");\n-\n-      fprintf (file, \"%d\", INT_LOWPART (x) & 0xffff);\n-      return;\n-\n-    case 'w':\n-      /* If constant, low-order 16 bits of constant, signed.  Otherwise, write\n-\t normally.  */\n+    case 'I':\n+      /* Print `i' if this is a constant, else nothing.  */\n       if (INT_P (x))\n-\tfprintf (file, \"%d\",\n-\t\t (INT_LOWPART (x) & 0xffff) - 2 * (INT_LOWPART (x) & 0x8000));\n-      else\n-\tprint_operand (file, x, 0);\n+\tfprintf (file, \"i\");\n       return;\n \n-    case 'W':\n-      /* If constant, low-order 16 bits of constant, unsigned.\n-\t Otherwise, write normally.  */\n-      if (INT_P (x))\n-\tfprintf (file, \"%d\", INT_LOWPART (x) & 0xffff);\n+    case 'j':\n+      /* Write the bit number in CCR for jump.  */\n+      i = ccr_bit (x, 0);\n+      if (i == -1)\n+\toutput_operand_lossage (\"invalid %%j code\");\n       else\n-\tprint_operand (file, x, 0);\n-      return;\n-\n-    case 'u':\n-      /* High-order 16 bits of constant.  */\n-      if (! INT_P (x))\n-\toutput_operand_lossage (\"invalid %%u value\");\n-\n-      fprintf (file, \"%d\", (INT_LOWPART (x) >> 16) & 0xffff);\n+\tfprintf (file, \"%d\", i);\n       return;\n \n-    case 's':\n-      /* Low 5 bits of 32 - value */\n-      if (! INT_P (x))\n-\toutput_operand_lossage (\"invalid %%s value\");\n-\n-      fprintf (file, \"%d\", (32 - INT_LOWPART (x)) & 31);\n+    case 'J':\n+      /* Similar, but add one for shift count in rlinm for scc and pass\n+\t scc flag to `ccr_bit'.  */\n+      i = ccr_bit (x, 1);\n+      if (i == -1)\n+\toutput_operand_lossage (\"invalid %%J code\");\n+      else\n+\tfprintf (file, \"%d\", i + 1);\n       return;\n \n-    case 'S':\n-      /* Low 5 bits of 31 - value */\n+    case 'k':\n+      /* X must be a constant.  Write the 1's complement of the\n+\t constant.  */\n       if (! INT_P (x))\n-\toutput_operand_lossage (\"invalid %%S value\");\n+\toutput_operand_lossage (\"invalid %%k value\");\n \n-      fprintf (file, \"%d\", (31 - INT_LOWPART (x)) & 31);\n+      fprintf (file, \"%d\", ~ INT_LOWPART (x));\n       return;\n \n-    case 'p':\n-      /* X is a CONST_INT that is a power of two.  Output the logarithm.  */\n-      if (! INT_P (x)\n-\t  || (i = exact_log2 (INT_LOWPART (x))) < 0)\n-\toutput_operand_lossage (\"invalid %%p value\");\n-\n-      fprintf (file, \"%d\", i);\n+    case 'L':\n+      /* Write second word of DImode or DFmode reference.  Works on register\n+\t or non-indexed memory only.  */\n+      if (GET_CODE (x) == REG)\n+\tfprintf (file, \"%d\", REGNO (x) + 1);\n+      else if (GET_CODE (x) == MEM)\n+\t{\n+\t  /* Handle possible auto-increment.  Since it is pre-increment and\n+\t     we have already done it, we can just use an offset of four.  */\n+\t  if (GET_CODE (XEXP (x, 0)) == PRE_INC\n+\t      || GET_CODE (XEXP (x, 0)) == PRE_DEC)\n+\t    output_address (plus_constant (XEXP (XEXP (x, 0), 0), 4));\n+\t  else\n+\t    output_address (plus_constant (XEXP (x, 0), 4));\n+\t}\n       return;\n-\n+\t\t\t    \n     case 'm':\n       /* MB value for a mask operand.  */\n       if (! mask_operand (x, VOIDmode))\n@@ -866,60 +940,6 @@ print_operand (file, x, code)\n       fprintf (file, \"%d\", i);\n       return;\n \n-    case 'f':\n-      /* X is a CR register.  Print the shift count needed to move it\n-\t to the high-order four bits.  */\n-      if (GET_CODE (x) != REG || ! CR_REGNO_P (REGNO (x)))\n-\toutput_operand_lossage (\"invalid %%f value\");\n-      else\n-\tfprintf (file, \"%d\", 4 * (REGNO (x) - 68));\n-      return;\n-\n-    case 'F':\n-      /* Similar, but print the count for the rotate in the opposite\n-\t direction.  */\n-      if (GET_CODE (x) != REG || ! CR_REGNO_P (REGNO (x)))\n-\toutput_operand_lossage (\"invalid %%F value\");\n-      else\n-\tfprintf (file, \"%d\", 32 - 4 * (REGNO (x) - 68));\n-      return;\n-\n-    case 'E':\n-      /* X is a CR register.  Print the number of the third bit of the CR */\n-      if (GET_CODE (x) != REG || ! CR_REGNO_P (REGNO (x)))\n-\toutput_operand_lossage (\"invalid %%E value\");\n-\n-      fprintf(file, \"%d\", 4 * (REGNO (x) - 68) + 3);\n-      break;\n-\n-    case 'R':\n-      /* X is a CR register.  Print the mask for `mtcrf'.  */\n-      if (GET_CODE (x) != REG || ! CR_REGNO_P (REGNO (x)))\n-\toutput_operand_lossage (\"invalid %%R value\");\n-      else\n-\tfprintf (file, \"%d\", 128 >> (REGNO (x) - 68));\n-      return;\n-\n-    case 'X':\n-      if (GET_CODE (x) == MEM\n-\t  && LEGITIMATE_INDEXED_ADDRESS_P (XEXP (x, 0)))\n-\tfprintf (file, \"x\");\n-      return;\n-\n-    case 'U':\n-      /* Print `u' if this has an auto-increment or auto-decrement.  */\n-      if (GET_CODE (x) == MEM\n-\t  && (GET_CODE (XEXP (x, 0)) == PRE_INC\n-\t      || GET_CODE (XEXP (x, 0)) == PRE_DEC))\n-\tfprintf (file, \"u\");\n-      return;\n-\n-    case 'I':\n-      /* Print `i' if this is a constant, else nothing.  */\n-      if (INT_P (x))\n-\tfprintf (file, \"i\");\n-      return;\n-\n     case 'N':\n       /* Write the number of elements in the vector times 4.  */\n       if (GET_CODE (x) != PARALLEL)\n@@ -936,6 +956,15 @@ print_operand (file, x, code)\n       fprintf (file, \"%d\", (XVECLEN (x, 0) - 1) * 4);\n       return;\n \n+    case 'p':\n+      /* X is a CONST_INT that is a power of two.  Output the logarithm.  */\n+      if (! INT_P (x)\n+\t  || (i = exact_log2 (INT_LOWPART (x))) < 0)\n+\toutput_operand_lossage (\"invalid %%p value\");\n+\n+      fprintf (file, \"%d\", i);\n+      return;\n+\n     case 'P':\n       /* The operand must be an indirect memory reference.  The result\n \t is the register number. */\n@@ -946,51 +975,30 @@ print_operand (file, x, code)\n       fprintf (file, \"%d\", REGNO (XEXP (x, 0)));\n       return;\n \n-    case 'L':\n-      /* Write second word of DImode or DFmode reference.  Works on register\n-\t or non-indexed memory only.  */\n-      if (GET_CODE (x) == REG)\n-\tfprintf (file, \"%d\", REGNO (x) + 1);\n-      else if (GET_CODE (x) == MEM)\n-\t{\n-\t  /* Handle possible auto-increment.  Since it is pre-increment and\n-\t     we have already done it, we can just use an offset of four.  */\n-\t  if (GET_CODE (XEXP (x, 0)) == PRE_INC\n-\t      || GET_CODE (XEXP (x, 0)) == PRE_DEC)\n-\t    output_address (plus_constant (XEXP (XEXP (x, 0), 0), 4));\n-\t  else\n-\t    output_address (plus_constant (XEXP (x, 0), 4));\n-\t}\n+    case 'R':\n+      /* X is a CR register.  Print the mask for `mtcrf'.  */\n+      if (GET_CODE (x) != REG || ! CR_REGNO_P (REGNO (x)))\n+\toutput_operand_lossage (\"invalid %%R value\");\n+      else\n+\tfprintf (file, \"%d\", 128 >> (REGNO (x) - 68));\n       return;\n-\t\t\t    \n-    case 'Y':\n-      /* Similar, for third word of TImode  */\n-      if (GET_CODE (x) == REG)\n-\tfprintf (file, \"%d\", REGNO (x) + 2);\n-      else if (GET_CODE (x) == MEM)\n-\t{\n-\t  if (GET_CODE (XEXP (x, 0)) == PRE_INC\n-\t      || GET_CODE (XEXP (x, 0)) == PRE_DEC)\n-\t    output_address (plus_constant (XEXP (XEXP (x, 0), 0), 8));\n-\t  else\n-\t    output_address (plus_constant (XEXP (x, 0), 8));\n-\t}\n+\n+    case 's':\n+      /* Low 5 bits of 32 - value */\n+      if (! INT_P (x))\n+\toutput_operand_lossage (\"invalid %%s value\");\n+\n+      fprintf (file, \"%d\", (32 - INT_LOWPART (x)) & 31);\n       return;\n-\t\t\t    \n-    case 'Z':\n-      /* Similar, for last word of TImode.  */\n-      if (GET_CODE (x) == REG)\n-\tfprintf (file, \"%d\", REGNO (x) + 3);\n-      else if (GET_CODE (x) == MEM)\n-\t{\n-\t  if (GET_CODE (XEXP (x, 0)) == PRE_INC\n-\t      || GET_CODE (XEXP (x, 0)) == PRE_DEC)\n-\t    output_address (plus_constant (XEXP (XEXP (x, 0), 0), 12));\n-\t  else\n-\t    output_address (plus_constant (XEXP (x, 0), 12));\n-\t}\n+\n+    case 'S':\n+      /* Low 5 bits of 31 - value */\n+      if (! INT_P (x))\n+\toutput_operand_lossage (\"invalid %%S value\");\n+\n+      fprintf (file, \"%d\", (31 - INT_LOWPART (x)) & 31);\n       return;\n-\t\t\t    \n+\n     case 't':\n       /* Write 12 if this jump operation will branch if true, 4 otherwise. \n \t All floating-point operations except NE branch true and integer\n@@ -1024,61 +1032,61 @@ print_operand (file, x, code)\n \tfprintf (file, \"12\");\n       return;\n       \n-    case 'j':\n-      /* Write the bit number in CCR for jump.  */\n-      i = ccr_bit (x, 0);\n-      if (i == -1)\n-\toutput_operand_lossage (\"invalid %%j code\");\n-      else\n-\tfprintf (file, \"%d\", i);\n-      return;\n+    case 'u':\n+      /* High-order 16 bits of constant.  */\n+      if (! INT_P (x))\n+\toutput_operand_lossage (\"invalid %%u value\");\n \n-    case 'J':\n-      /* Similar, but add one for shift count in rlinm for scc and pass\n-\t scc flag to `ccr_bit'.  */\n-      i = ccr_bit (x, 1);\n-      if (i == -1)\n-\toutput_operand_lossage (\"invalid %%J code\");\n-      else\n-\tfprintf (file, \"%d\", i + 1);\n+      fprintf (file, \"%d\", (INT_LOWPART (x) >> 16) & 0xffff);\n       return;\n \n-    case 'C':\n-      /* This is an optional cror needed for LE or GE floating-point\n-\t comparisons.  Otherwise write nothing.  */\n-      if ((GET_CODE (x) == LE || GET_CODE (x) == GE)\n-\t  && GET_MODE (XEXP (x, 0)) == CCFPmode)\n-\t{\n-\t  int base_bit = 4 * (REGNO (XEXP (x, 0)) - 68);\n+    case 'U':\n+      /* Print `u' if this has an auto-increment or auto-decrement.  */\n+      if (GET_CODE (x) == MEM\n+\t  && (GET_CODE (XEXP (x, 0)) == PRE_INC\n+\t      || GET_CODE (XEXP (x, 0)) == PRE_DEC))\n+\tfprintf (file, \"u\");\n+      return;\n \n-\t  fprintf (file, \"cror %d,%d,%d\\n\\t\", base_bit + 3,\n-\t\t   base_bit + 2, base_bit + (GET_CODE (x) == GE));\n-\t}\n+    case 'w':\n+      /* If constant, low-order 16 bits of constant, signed.  Otherwise, write\n+\t normally.  */\n+      if (INT_P (x))\n+\tfprintf (file, \"%d\",\n+\t\t (INT_LOWPART (x) & 0xffff) - 2 * (INT_LOWPART (x) & 0x8000));\n+      else\n+\tprint_operand (file, x, 0);\n       return;\n \n-    case 'D':\n-      /* Similar, except that this is for an scc, so we must be able to\n-\t encode the test in a single bit that is one.  We do the above\n-\t for any LE, GE, GEU, or LEU and invert the bit for NE.  */\n-      if (GET_CODE (x) == LE || GET_CODE (x) == GE\n-\t  || GET_CODE (x) == LEU || GET_CODE (x) == GEU)\n-\t{\n-\t  int base_bit = 4 * (REGNO (XEXP (x, 0)) - 68);\n+    case 'W':\n+      /* If constant, low-order 16 bits of constant, unsigned.\n+\t Otherwise, write normally.  */\n+      if (INT_P (x))\n+\tfprintf (file, \"%d\", INT_LOWPART (x) & 0xffff);\n+      else\n+\tprint_operand (file, x, 0);\n+      return;\n \n-\t  fprintf (file, \"cror %d,%d,%d\\n\\t\", base_bit + 3,\n-\t\t   base_bit + 2,\n-\t\t   base_bit + (GET_CODE (x) == GE || GET_CODE (x) == GEU));\n-\t}\n+    case 'X':\n+      if (GET_CODE (x) == MEM\n+\t  && LEGITIMATE_INDEXED_ADDRESS_P (XEXP (x, 0)))\n+\tfprintf (file, \"x\");\n+      return;\n \n-      else if (GET_CODE (x) == NE)\n+    case 'Y':\n+      /* Like 'L', for third word of TImode  */\n+      if (GET_CODE (x) == REG)\n+\tfprintf (file, \"%d\", REGNO (x) + 2);\n+      else if (GET_CODE (x) == MEM)\n \t{\n-\t  int base_bit = 4 * (REGNO (XEXP (x, 0)) - 68);\n-\n-\t  fprintf (file, \"crnor %d,%d,%d\\n\\t\", base_bit + 3,\n-\t\t   base_bit + 2, base_bit + 2);\n+\t  if (GET_CODE (XEXP (x, 0)) == PRE_INC\n+\t      || GET_CODE (XEXP (x, 0)) == PRE_DEC)\n+\t    output_address (plus_constant (XEXP (XEXP (x, 0), 0), 8));\n+\t  else\n+\t    output_address (plus_constant (XEXP (x, 0), 8));\n \t}\n       return;\n-\n+\t\t\t    \n     case 'z':\n       /* X is a SYMBOL_REF.  Write out the name preceded by a\n \t period and without any trailing data in brackets.  Used for function\n@@ -1090,17 +1098,20 @@ print_operand (file, x, code)\n       RS6000_OUTPUT_BASENAME (file, XSTR (x, 0));\n       return;\n \n-    case 'A':\n-      /* If X is a constant integer whose low-order 5 bits are zero,\n-\t write 'l'.  Otherwise, write 'r'.  This is a kludge to fix a bug\n-\t in the RS/6000 assembler where \"sri\" with a zero shift count\n-\t write a trash instruction.  */\n-      if (GET_CODE (x) == CONST_INT && (INTVAL (x) & 31) == 0)\n-\tfprintf (file, \"l\");\n-      else\n-\tfprintf (file, \"r\");\n+    case 'Z':\n+      /* Like 'L', for last word of TImode.  */\n+      if (GET_CODE (x) == REG)\n+\tfprintf (file, \"%d\", REGNO (x) + 3);\n+      else if (GET_CODE (x) == MEM)\n+\t{\n+\t  if (GET_CODE (XEXP (x, 0)) == PRE_INC\n+\t      || GET_CODE (XEXP (x, 0)) == PRE_DEC)\n+\t    output_address (plus_constant (XEXP (XEXP (x, 0), 0), 12));\n+\t  else\n+\t    output_address (plus_constant (XEXP (x, 0), 12));\n+\t}\n       return;\n-\n+\t\t\t    \n     case 0:\n       if (GET_CODE (x) == REG)\n \tfprintf (file, \"%s\", reg_names[REGNO (x)]);\n@@ -1441,9 +1452,9 @@ output_epilog (file, size)\n \n     /* Language type.  Unfortunately, there doesn't seem to be any official way\n        to get this info, so we use language_string.  C is 0.  C++ is 9.\n-       No number defined for Obj-C, but it doesn't have its own\n-       language_string, so we can't detect it anyways.  */\n-    if (! strcmp (language_string, \"GNU C\"))\n+       No number defined for Obj-C, so use the value for C for now.  */\n+    if (! strcmp (language_string, \"GNU C\")\n+\t|| ! strcmp (language_string, \"GNU Obj-C\"))\n       i = 0;\n     else if (! strcmp (language_string, \"GNU F77\"))\n       i = 1;"}]}