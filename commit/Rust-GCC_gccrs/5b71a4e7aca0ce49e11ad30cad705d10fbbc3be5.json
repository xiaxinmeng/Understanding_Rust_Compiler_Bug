{"sha": "5b71a4e7aca0ce49e11ad30cad705d10fbbc3be5", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NWI3MWE0ZTdhY2EwY2U0OWUxMWFkMzBjYWQ3MDVkMTBmYmJjM2JlNQ==", "commit": {"author": {"name": "David Edelsohn", "email": "edelsohn@gnu.org", "date": "2003-01-08T23:05:22Z"}, "committer": {"name": "David Edelsohn", "email": "dje@gcc.gnu.org", "date": "2003-01-08T23:05:22Z"}, "message": "rs6000.h (FUNCTION_MODE): Always use SImode.\n\n        * config/rs6000/rs6000.h (FUNCTION_MODE): Always use SImode.\n        * config/rs6000/rs6000.c (TARGET_ASM_CAN_OUTPUT_MI_THUNK): Redefine\n        as hook_bool_tree_hwi_hwi_tree_true.\n        (rs6000_emit_allocate_stack): Use TARGET_32BIT.\n        (rs6000_emit_epilogue): Same.\n        (rs6000_output_mi_thunk): Re-implement as RTL.\n        * config/rs6000/xcoff.h (ASM_DECLARE_FUNCTION_NAME): Call\n        xcoffout_declare_function if any debugging enabled.\n\nFrom-SVN: r61058", "tree": {"sha": "1780067f61586da2b47e577b223448fb249491d0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1780067f61586da2b47e577b223448fb249491d0"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5b71a4e7aca0ce49e11ad30cad705d10fbbc3be5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5b71a4e7aca0ce49e11ad30cad705d10fbbc3be5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5b71a4e7aca0ce49e11ad30cad705d10fbbc3be5", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5b71a4e7aca0ce49e11ad30cad705d10fbbc3be5/comments", "author": null, "committer": null, "parents": [{"sha": "66e2aa7d3acf0b5ef6eac043668211d06e37573f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/66e2aa7d3acf0b5ef6eac043668211d06e37573f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/66e2aa7d3acf0b5ef6eac043668211d06e37573f"}], "stats": {"total": 259, "additions": 100, "deletions": 159}, "files": [{"sha": "ed19269b379bcd08b028db1ca845e5feb513fbe0", "filename": "gcc/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5b71a4e7aca0ce49e11ad30cad705d10fbbc3be5/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5b71a4e7aca0ce49e11ad30cad705d10fbbc3be5/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=5b71a4e7aca0ce49e11ad30cad705d10fbbc3be5", "patch": "@@ -1,3 +1,14 @@\n+2003-01-08  David Edelsohn  <edelsohn@gnu.org>\n+\n+\t* config/rs6000/rs6000.h (FUNCTION_MODE): Always use SImode.\n+\t* config/rs6000/rs6000.c (TARGET_ASM_CAN_OUTPUT_MI_THUNK): Redefine\n+\tas hook_bool_tree_hwi_hwi_tree_true.\n+\t(rs6000_emit_allocate_stack): Use TARGET_32BIT.\n+\t(rs6000_emit_epilogue): Same.\n+\t(rs6000_output_mi_thunk): Re-implement as RTL.\n+\t* config/rs6000/xcoff.h (ASM_DECLARE_FUNCTION_NAME): Call\n+\txcoffout_declare_function if any debugging enabled.\n+\n 2003-01-08  Chris Demetriou  <cgd@broadcom.com>\n \n \t* config.gcc (mipsisa32r2-*-elf*, mipsisa32r2el-*-elf*): New"}, {"sha": "292a0b8b73cdb194f6707b2de1f8b961eed7f66e", "filename": "gcc/config/rs6000/rs6000.c", "status": "modified", "additions": 87, "deletions": 153, "changes": 240, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5b71a4e7aca0ce49e11ad30cad705d10fbbc3be5/gcc%2Fconfig%2Frs6000%2Frs6000.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5b71a4e7aca0ce49e11ad30cad705d10fbbc3be5/gcc%2Fconfig%2Frs6000%2Frs6000.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.c?ref=5b71a4e7aca0ce49e11ad30cad705d10fbbc3be5", "patch": "@@ -207,7 +207,7 @@ static unsigned int rs6000_elf_section_type_flags PARAMS ((tree, const char *,\n static void rs6000_elf_asm_out_constructor PARAMS ((rtx, int));\n static void rs6000_elf_asm_out_destructor PARAMS ((rtx, int));\n static void rs6000_elf_select_section PARAMS ((tree, int,\n-\t\t\t\t\t\t unsigned HOST_WIDE_INT));\n+\t\t\t\t\t       unsigned HOST_WIDE_INT));\n static void rs6000_elf_unique_section PARAMS ((tree, int));\n static void rs6000_elf_select_rtx_section PARAMS ((enum machine_mode, rtx,\n \t\t\t\t\t\t   unsigned HOST_WIDE_INT));\n@@ -388,12 +388,8 @@ static const char alt_reg_names[][8] =\n #undef TARGET_ASM_OUTPUT_MI_THUNK\n #define TARGET_ASM_OUTPUT_MI_THUNK rs6000_output_mi_thunk\n \n-/* ??? Should work everywhere, but ask dje@watson.ibm.com before\n-   enabling for AIX.  */\n-#if TARGET_OBJECT_FORMAT != OBJECT_XCOFF\n #undef TARGET_ASM_CAN_OUTPUT_MI_THUNK\n-#define TARGET_ASM_CAN_OUTPUT_MI_THUNK default_can_output_mi_thunk_no_vcall\n-#endif\n+#define TARGET_ASM_CAN_OUTPUT_MI_THUNK hook_bool_tree_hwi_hwi_tree_true\n \n #undef TARGET_FUNCTION_OK_FOR_SIBCALL\n #define TARGET_FUNCTION_OK_FOR_SIBCALL rs6000_function_ok_for_sibcall\n@@ -9916,14 +9912,14 @@ rs6000_emit_allocate_stack (size, copy_r12)\n \t  && REGNO (stack_limit_rtx) > 1 \n \t  && REGNO (stack_limit_rtx) <= 31)\n \t{\n-\t  emit_insn (Pmode == SImode\n+\t  emit_insn (TARGET_32BIT\n \t\t     ? gen_addsi3 (tmp_reg,\n \t\t\t\t   stack_limit_rtx,\n \t\t\t\t   GEN_INT (size))\n \t\t     : gen_adddi3 (tmp_reg,\n \t\t\t\t   stack_limit_rtx,\n \t\t\t\t   GEN_INT (size)));\n-\t  \n+\n \t  emit_insn (gen_cond_trap (LTU, stack_reg, tmp_reg,\n \t\t\t\t    const0_rtx));\n \t}\n@@ -9935,7 +9931,7 @@ rs6000_emit_allocate_stack (size, copy_r12)\n \t\t\t\t      gen_rtx_PLUS (Pmode, \n \t\t\t\t\t\t    stack_limit_rtx, \n \t\t\t\t\t\t    GEN_INT (size)));\n-\t  \n+\n \t  emit_insn (gen_elf_high (tmp_reg, toload));\n \t  emit_insn (gen_elf_low (tmp_reg, tmp_reg, toload));\n \t  emit_insn (gen_cond_trap (LTU, stack_reg, tmp_reg,\n@@ -9959,24 +9955,22 @@ rs6000_emit_allocate_stack (size, copy_r12)\n \t  try_split (PATTERN (insn), insn, 0);\n \t  todec = tmp_reg;\n \t}\n-      \n-      if (Pmode == SImode)\n-\tinsn = emit_insn (gen_movsi_update (stack_reg, stack_reg, \n-\t\t\t\t\t    todec, stack_reg));\n-      else\n-\tinsn = emit_insn (gen_movdi_update (stack_reg, stack_reg, \n+\n+      insn = emit_insn (TARGET_32BIT\n+\t\t\t? gen_movsi_update (stack_reg, stack_reg,\n+\t\t\t\t\t    todec, stack_reg)\n+\t\t\t: gen_movdi_update (stack_reg, stack_reg, \n \t\t\t\t\t    todec, stack_reg));\n     }\n   else\n     {\n-      if (Pmode == SImode)\n-\tinsn = emit_insn (gen_addsi3 (stack_reg, stack_reg, todec));\n-      else\n-\tinsn = emit_insn (gen_adddi3 (stack_reg, stack_reg, todec));\n+      insn = emit_insn (TARGET_32BIT\n+\t\t\t? gen_addsi3 (stack_reg, stack_reg, todec)\n+\t\t\t: gen_adddi3 (stack_reg, stack_reg, todec));\n       emit_move_insn (gen_rtx_MEM (Pmode, stack_reg),\n \t\t      gen_rtx_REG (Pmode, 12));\n     }\n-  \n+ \n   RTX_FRAME_RELATED_P (insn) = 1;\n   REG_NOTES (insn) = \n     gen_rtx_EXPR_LIST (REG_FRAME_RELATED_EXPR,\n@@ -10970,7 +10964,7 @@ rs6000_emit_epilogue (sibcall)\n \t}\n       else if (sp_offset != 0)\n \t{\n-\t  emit_insn (Pmode == SImode\n+\t  emit_insn (TARGET_32BIT\n \t\t     ? gen_addsi3 (sp_reg_rtx, sp_reg_rtx,\n \t\t\t\t   GEN_INT (sp_offset))\n \t\t     : gen_adddi3 (sp_reg_rtx, sp_reg_rtx,\n@@ -10981,7 +10975,7 @@ rs6000_emit_epilogue (sibcall)\n   if (current_function_calls_eh_return)\n     {\n       rtx sa = EH_RETURN_STACKADJ_RTX;\n-      emit_insn (Pmode == SImode\n+      emit_insn (TARGET_32BIT\n \t\t ? gen_addsi3 (sp_reg_rtx, sp_reg_rtx, sa)\n \t\t : gen_adddi3 (sp_reg_rtx, sp_reg_rtx, sa));\n     }\n@@ -11344,159 +11338,99 @@ rs6000_output_mi_thunk (file, thunk_fndecl, delta, vcall_offset, function)\n      FILE *file;\n      tree thunk_fndecl ATTRIBUTE_UNUSED;\n      HOST_WIDE_INT delta;\n-     HOST_WIDE_INT vcall_offset ATTRIBUTE_UNUSED;\n+     HOST_WIDE_INT vcall_offset;\n      tree function;\n {\n-  const char *this_reg =\n-    reg_names[ aggregate_value_p (TREE_TYPE (TREE_TYPE (function))) ? 4 : 3 ];\n-  const char *prefix;\n-  const char *fname;\n-  const char *r0\t = reg_names[0];\n-  const char *toc\t = reg_names[2];\n-  const char *schain\t = reg_names[11];\n-  const char *r12\t = reg_names[12];\n-  char buf[512];\n-  static int labelno = 0;\n-\n-  /* Small constants that can be done by one add instruction.  */\n-  if (delta >= -32768 && delta <= 32767)\n-    {\n-      if (! TARGET_NEW_MNEMONICS)\n-\tfprintf (file, \"\\tcal %s,%d(%s)\\n\", this_reg, (int) delta, this_reg);\n-      else\n-\tfprintf (file, \"\\taddi %s,%s,%d\\n\", this_reg, this_reg, (int) delta);\n-    }\n+  rtx this, insn, funexp;\n \n-  /* 64-bit constants.  If \"int\" is 32 bits, we'll never hit this abort.  */\n-  else if (TARGET_64BIT && (delta < -2147483647 - 1 || delta > 2147483647))\n-    abort ();\n+  reload_completed = 1;\n+  no_new_pseudos = 1;\n \n-  /* Large constants that can be done by one addis instruction.  */\n-  else if ((delta & 0xffff) == 0)\n-    asm_fprintf (file, \"\\t{cau|addis} %s,%s,%d\\n\", this_reg, this_reg,\n-\t\t (int) (delta >> 16));\n+  /* Mark the end of the (empty) prologue.  */\n+  emit_note (NULL, NOTE_INSN_PROLOGUE_END);\n \n-  /* 32-bit constants that can be done by an add and addis instruction.  */\n+  /* Find the \"this\" pointer.  If the function returns a structure,\n+     the structure return pointer is in r3.  */\n+  if (aggregate_value_p (TREE_TYPE (TREE_TYPE (function))))\n+    this = gen_rtx_REG (Pmode, 4);\n   else\n-    {\n-      /* Break into two pieces, propagating the sign bit from the low\n-\t word to the upper word.  */\n-      int delta_low  = ((delta & 0xffff) ^ 0x8000) - 0x8000;\n-      int delta_high = (delta - delta_low) >> 16;\n+    this = gen_rtx_REG (Pmode, 3);\n \n-      asm_fprintf (file, \"\\t{cau|addis} %s,%s,%d\\n\", this_reg, this_reg,\n-\t\t   delta_high);\n-\n-      if (! TARGET_NEW_MNEMONICS)\n-\tfprintf (file, \"\\tcal %s,%d(%s)\\n\", this_reg, delta_low, this_reg);\n-      else\n-\tfprintf (file, \"\\taddi %s,%s,%d\\n\", this_reg, this_reg, delta_low);\n+  /* Apply the constant offset, if required.  */\n+  if (delta)\n+    {\n+      rtx delta_rtx = GEN_INT (delta);\n+      emit_insn (TARGET_32BIT\n+\t\t ? gen_addsi3 (this, this, delta_rtx)\n+\t\t : gen_adddi3 (this, this, delta_rtx));\n     }\n \n-  /* Get the prefix in front of the names.  */\n-  switch (DEFAULT_ABI)\n+  /* Apply the offset from the vtable, if required.  */\n+  if (vcall_offset)\n     {\n-    default:\n-      abort ();\n+      rtx vcall_offset_rtx = GEN_INT (vcall_offset);\n+      rtx tmp = gen_rtx_REG (Pmode, 12);\n \n-    case ABI_AIX:\n-      prefix = \".\";\n-      break;\n-\n-    case ABI_V4:\n-    case ABI_AIX_NODESC:\n-    case ABI_DARWIN:\n-      prefix = \"\";\n-      break;\n+      emit_move_insn (tmp, gen_rtx_MEM (Pmode, this));\n+      emit_insn (TARGET_32BIT\n+\t\t ? gen_addsi3 (tmp, tmp, vcall_offset_rtx)\n+\t\t : gen_adddi3 (tmp, tmp, vcall_offset_rtx));\n+      emit_move_insn (tmp, gen_rtx_MEM (Pmode, tmp));\n+      emit_insn (TARGET_32BIT\n+\t\t ? gen_addsi3 (this, this, tmp)\n+\t\t : gen_adddi3 (this, this, tmp));\n     }\n \n-  /* If the function is compiled in this module, jump to it directly.\n-     Otherwise, load up its address and jump to it.  */\n-\n-  fname = XSTR (XEXP (DECL_RTL (function), 0), 0);\n+  /* Generate a tail call to the target function.  */\n+  if (!TREE_USED (function))\n+    {\n+      assemble_external (function);\n+      TREE_USED (function) = 1;\n+    }\n+  funexp = XEXP (DECL_RTL (function), 0);\n \n-  if (current_file_function_operand (XEXP (DECL_RTL (function), 0), VOIDmode)\n+  SYMBOL_REF_FLAG (funexp) = 0;\n+  if (current_file_function_operand (funexp, VOIDmode)\n       && (! lookup_attribute (\"longcall\",\n \t\t\t      TYPE_ATTRIBUTES (TREE_TYPE (function)))\n \t  || lookup_attribute (\"shortcall\",\n \t\t\t       TYPE_ATTRIBUTES (TREE_TYPE (function)))))\n-    {\n-      fprintf (file, \"\\tb %s\", prefix);\n-      assemble_name (file, fname);\n-      if (DEFAULT_ABI == ABI_V4 && flag_pic) fputs (\"@local\", file);\n-      putc ('\\n', file);\n-    }\n-\n-  else\n-    {\n-      switch (DEFAULT_ABI)\n-\t{\n-\tdefault:\n-\t  abort ();\n-\n-\tcase ABI_AIX:\n-\t  /* Set up a TOC entry for the function.  */\n-\t  ASM_GENERATE_INTERNAL_LABEL (buf, \"Lthunk\", labelno);\n-\t  toc_section ();\n-\t  (*targetm.asm_out.internal_label) (file, \"Lthunk\", labelno);\n-\t  labelno++;\n+    SYMBOL_REF_FLAG (funexp) = 1;\n \n-\t  if (TARGET_MINIMAL_TOC)\n-\t    fputs (TARGET_32BIT ? \"\\t.long \" : DOUBLE_INT_ASM_OP, file);\n-\t  else\n-\t    {\n-\t      fputs (\"\\t.tc \", file);\n-\t      assemble_name (file, fname);\n-\t      fputs (\"[TC],\", file);\n-\t    }\n-\t  assemble_name (file, fname);\n-\t  putc ('\\n', file);\n-\t  function_section (current_function_decl);\n-\t  if (TARGET_MINIMAL_TOC)\n-\t    asm_fprintf (file, (TARGET_32BIT)\n-\t\t\t ? \"\\t{l|lwz} %s,%s(%s)\\n\" : \"\\tld %s,%s(%s)\\n\", r12,\n-\t\t\t TARGET_ELF ? \".LCTOC0@toc\" : \".LCTOC..1\", toc);\n-\t  asm_fprintf (file, (TARGET_32BIT) ? \"\\t{l|lwz} %s,\" : \"\\tld %s,\", r12);\n-\t  assemble_name (file, buf);\n-\t  if (TARGET_ELF && TARGET_MINIMAL_TOC)\n-\t    fputs (\"-(.LCTOC1)\", file);\n-\t  asm_fprintf (file, \"(%s)\\n\", TARGET_MINIMAL_TOC ? r12 : toc);\n-\t  asm_fprintf (file,\n-\t\t       (TARGET_32BIT) ? \"\\t{l|lwz} %s,0(%s)\\n\" : \"\\tld %s,0(%s)\\n\",\n-\t\t       r0, r12);\n-\n-\t  asm_fprintf (file,\n-\t\t       (TARGET_32BIT) ? \"\\t{l|lwz} %s,4(%s)\\n\" : \"\\tld %s,8(%s)\\n\",\n-\t\t       toc, r12);\n-\n-\t  asm_fprintf (file, \"\\tmtctr %s\\n\", r0);\n-\t  asm_fprintf (file,\n-\t\t       (TARGET_32BIT) ? \"\\t{l|lwz} %s,8(%s)\\n\" : \"\\tld %s,16(%s)\\n\",\n-\t\t       schain, r12);\n-\n-\t  asm_fprintf (file, \"\\tbctr\\n\");\n-\t  break;\n-\n-\tcase ABI_AIX_NODESC:\n-\tcase ABI_V4:\n-\t  fprintf (file, \"\\tb %s\", prefix);\n-\t  assemble_name (file, fname);\n-\t  if (flag_pic) fputs (\"@plt\", file);\n-\t  putc ('\\n', file);\n-\t  break;\n+  funexp = gen_rtx_MEM (FUNCTION_MODE, funexp);\n \n #if TARGET_MACHO\n-\tcase ABI_DARWIN:\n-\t  fprintf (file, \"\\tb %s\", prefix);\n-\t  if (flag_pic && !machopic_name_defined_p (fname))\n-\t    assemble_name (file, machopic_stub_name (fname));\n-\t  else\n-\t    assemble_name (file, fname);\n-\t  putc ('\\n', file);\n-\t  break;\n+  if (flag_pic)\n+    funexp = machopic_indirect_call_target (funexp);\n #endif\n-\t}\n-    }\n+\n+  /* gen_sibcall expects reload to convert scratch pseudo to LR so we must\n+     generate sibcall RTL explicitly to avoid constraint abort.  */\n+  insn = emit_call_insn (\n+\t   gen_rtx_PARALLEL (VOIDmode,\n+\t     gen_rtvec (4,\n+\t\t\tgen_rtx_CALL (VOIDmode,\n+\t\t\t\t      funexp, const0_rtx),\n+\t\t\tgen_rtx_USE (VOIDmode, const0_rtx),\n+\t\t\tgen_rtx_USE (VOIDmode,\n+\t\t\t\t     gen_rtx_REG (SImode,\n+\t\t\t\t\t\t  LINK_REGISTER_REGNUM)),\n+\t\t\tgen_rtx_RETURN (VOIDmode))));\n+  SIBLING_CALL_P (insn) = 1;\n+  emit_barrier ();\n+\n+  /* Run just enough of rest_of_compilation to get the insns emitted.\n+     There's not really enough bulk here to make other passes such as\n+     instruction scheduling worth while.  Note that use_thunk calls\n+     assemble_start_function and assemble_end_function.  */\n+  insn = get_insns ();\n+  shorten_branches (insn);\n+  final_start_function (insn, file, 1);\n+  final (insn, file, 1, 0);\n+  final_end_function ();\n+\n+  reload_completed = 0;\n+  no_new_pseudos = 0;\n }\n \f\n /* A quick summary of the various types of 'constant-pool tables'"}, {"sha": "675680410ebaff472c4e645363f7972ce3036097", "filename": "gcc/config/rs6000/rs6000.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5b71a4e7aca0ce49e11ad30cad705d10fbbc3be5/gcc%2Fconfig%2Frs6000%2Frs6000.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5b71a4e7aca0ce49e11ad30cad705d10fbbc3be5/gcc%2Fconfig%2Frs6000%2Frs6000.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.h?ref=5b71a4e7aca0ce49e11ad30cad705d10fbbc3be5", "patch": "@@ -2274,7 +2274,7 @@ do {\t\t\t\t\t\t\t\t\t     \\\n \n /* Mode of a function address in a call instruction (for indexing purposes).\n    Doesn't matter on RS/6000.  */\n-#define FUNCTION_MODE (TARGET_32BIT ? SImode : DImode)\n+#define FUNCTION_MODE SImode\n \n /* Define this if addresses of constant functions\n    shouldn't be put through pseudo regs where they can be cse'd."}, {"sha": "890e30d7da3d279c2fd98093479502c3d2f8a329", "filename": "gcc/config/rs6000/xcoff.h", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5b71a4e7aca0ce49e11ad30cad705d10fbbc3be5/gcc%2Fconfig%2Frs6000%2Fxcoff.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5b71a4e7aca0ce49e11ad30cad705d10fbbc3be5/gcc%2Fconfig%2Frs6000%2Fxcoff.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Fxcoff.h?ref=5b71a4e7aca0ce49e11ad30cad705d10fbbc3be5", "patch": "@@ -296,11 +296,7 @@ toc_section ()\t\t\t\t\t\t\\\n   putc ('.', FILE);\t\t\t\t\t\t\\\n   RS6000_OUTPUT_BASENAME (FILE, NAME);\t\t\t\t\\\n   fputs (\":\\n\", FILE);\t\t\t\t\t\t\\\n-  if (write_symbols == XCOFF_DEBUG\t\t\t\t\\\n-      /* When called before targetm.asm_out.output_mi_thunk,\t\\\n-\t we won't be emitting the rest of the debug info that\t\\\n-\t goes along with this, leading to assembler errors.  */ \\\n-      && !(current_function_is_thunk && !no_new_pseudos))\t\\\n+  if (write_symbols != NO_DEBUG)\t\t\t\t\\\n     xcoffout_declare_function (FILE, DECL, NAME);\t\t\\\n }\n "}]}