{"sha": "9b8fbdeca1c7c0f384a31ad42296a6a4861afdf3", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OWI4ZmJkZWNhMWM3YzBmMzg0YTMxYWQ0MjI5NmE2YTQ4NjFhZmRmMw==", "commit": {"author": {"name": "Richard Stallman", "email": "rms@gnu.org", "date": "1992-06-24T04:16:31Z"}, "committer": {"name": "Richard Stallman", "email": "rms@gnu.org", "date": "1992-06-24T04:16:31Z"}, "message": "Initial revision\n\nFrom-SVN: r1268", "tree": {"sha": "90803873013955e18c2dd43f1a85af9df6cc7754", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/90803873013955e18c2dd43f1a85af9df6cc7754"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/9b8fbdeca1c7c0f384a31ad42296a6a4861afdf3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9b8fbdeca1c7c0f384a31ad42296a6a4861afdf3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9b8fbdeca1c7c0f384a31ad42296a6a4861afdf3", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9b8fbdeca1c7c0f384a31ad42296a6a4861afdf3/comments", "author": null, "committer": null, "parents": [{"sha": "15872eeb797710097001dee9c8f7c05db1d7bbc1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/15872eeb797710097001dee9c8f7c05db1d7bbc1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/15872eeb797710097001dee9c8f7c05db1d7bbc1"}], "stats": {"total": 2156, "additions": 2156, "deletions": 0}, "files": [{"sha": "29106ae7665ab22f115529772629238702365abd", "filename": "gcc/config/tahoe/tahoe.md", "status": "added", "additions": 2156, "deletions": 0, "changes": 2156, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9b8fbdeca1c7c0f384a31ad42296a6a4861afdf3/gcc%2Fconfig%2Ftahoe%2Ftahoe.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9b8fbdeca1c7c0f384a31ad42296a6a4861afdf3/gcc%2Fconfig%2Ftahoe%2Ftahoe.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Ftahoe%2Ftahoe.md?ref=9b8fbdeca1c7c0f384a31ad42296a6a4861afdf3", "patch": "@@ -0,0 +1,2156 @@\n+;;- Machine description for GNU compiler\n+;;- Tahoe version\n+;;   Copyright (C) 1989 Free Software Foundation, Inc.\n+\n+;; This file is part of GNU CC.\n+\n+;; GNU CC is free software; you can redistribute it and/or modify\n+;; it under the terms of the GNU General Public License as published by\n+;; the Free Software Foundation; either version 2, or (at your option)\n+;; any later version.\n+\n+;; GNU CC is distributed in the hope that it will be useful,\n+;; but WITHOUT ANY WARRANTY; without even the implied warranty of\n+;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+;; GNU General Public License for more details.\n+\n+;; You should have received a copy of the GNU General Public License\n+;; along with GNU CC; see the file COPYING.  If not, write to\n+;; the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.\n+\n+\n+; File: tahoe.md\n+;\n+; Original port made at the University of Buffalo by Devon Bowen,\n+; Dale Wiles and Kevin Zachmann.\n+;\n+; Piet van Oostrum (piet@cs.ruu.nl) made changes for HCX/UX, fixed\n+; some bugs and made some improvements (hopefully).\n+;\n+; Mail bugs reports or fixes to:\tgcc@cs.buffalo.edu\n+\n+\n+; movdi must call the output_move_double routine to move it around since\n+; the tahoe doesn't efficiently support 8 bit moves.\n+\n+(define_insn \"movdi\"\n+  [(set (match_operand:DI 0 \"general_operand\" \"=g\")\n+\t(match_operand:DI 1 \"general_operand\" \"g\"))]\n+  \"\"\n+  \"*\n+{\n+  CC_STATUS_INIT;\n+  return output_move_double (operands);\n+}\")\n+\n+\n+; the trick in the movsi is accessing the contents of the sp register.  The\n+; tahoe doesn't allow you to access it directly so you have to access the\n+; address of the top of the stack instead.\n+\n+(define_insn \"movsi\"\n+  [(set (match_operand:SI 0 \"general_operand\" \"=g\")\n+\t(match_operand:SI 1 \"general_operand\" \"g\"))]\n+  \"\"\n+  \"*\n+{\n+   rtx link;\n+   if (operands[1] == const1_rtx\n+      && (link = find_reg_note (insn, REG_WAS_0, 0))\n+      && ! XEXP (link, 0)->volatil\n+      && GET_CODE (XEXP (link, 0)) != NOTE\n+      && no_labels_between_p (XEXP (link, 0), insn))\n+    return \\\"incl %0\\\";\n+   if (GET_CODE (operands[1]) == SYMBOL_REF || GET_CODE (operands[1]) == CONST)\n+    {\n+      if (push_operand (operands[0], SImode))\n+\treturn \\\"pushab %a1\\\";\n+      return \\\"movab %a1,%0\\\";\n+    }\n+  if (operands[1] == const0_rtx)\n+    return \\\"clrl %0\\\";\n+  if (push_operand (operands[0], SImode))\n+    return \\\"pushl %1\\\";\n+  if (GET_CODE(operands[1]) == REG && REGNO(operands[1]) == 14)\n+    return \\\"moval (sp),%0\\\";\n+  return \\\"movl %1,%0\\\";\n+}\")\n+\n+\n+(define_insn \"movhi\"\n+  [(set (match_operand:HI 0 \"general_operand\" \"=g\")\n+\t(match_operand:HI 1 \"general_operand\" \"g\"))]\n+  \"\"\n+  \"*\n+{\n+ rtx link;\n+ if (operands[1] == const1_rtx\n+     && (link = find_reg_note (insn, REG_WAS_0, 0))\n+     && ! XEXP (link, 0)->volatil\n+     && GET_CODE (XEXP (link, 0)) != NOTE\n+     && no_labels_between_p (XEXP (link, 0), insn))\n+    return \\\"incw %0\\\";\n+  if (operands[1] == const0_rtx)\n+    return \\\"clrw %0\\\";\n+  return \\\"movw %1,%0\\\";\n+}\")\n+\n+\n+(define_insn \"movqi\"\n+  [(set (match_operand:QI 0 \"general_operand\" \"=g\")\n+\t(match_operand:QI 1 \"general_operand\" \"g\"))]\n+  \"\"\n+  \"*\n+{\n+  if (operands[1] == const0_rtx)\n+    return \\\"clrb %0\\\";\n+  return \\\"movb %1,%0\\\";\n+}\")\n+\n+\n+; movsf has three cases since they can move from one place to another\n+; or to/from the fpp and since different instructions are needed for\n+; each case.  The fpp related instructions don't set the flags properly.\n+\n+(define_insn \"movsf\"\n+  [(set (match_operand:SF 0 \"general_operand\" \"=g,=a,=g\")\n+\t(match_operand:SF 1 \"general_operand\" \"g,g,a\"))]\n+  \"\"\n+  \"*\n+{\n+  CC_STATUS_INIT;\n+  switch (which_alternative)\n+    {\n+    case 0: return \\\"movl %1,%0\\\";\n+    case 1: return \\\"ldf %1\\\";\n+    case 2: return \\\"stf %0\\\";\n+   }\n+}\")\n+\n+\n+; movdf has a number of different cases.  If it's going to or from\n+; the fpp, use the special instructions to do it.  If not, use the\n+; output_move_double function.\n+\n+(define_insn \"movdf\"\n+  [(set (match_operand:DF 0 \"general_operand\" \"=a,=g,?=g\")\n+\t(match_operand:DF 1 \"general_operand\" \"g,a,g\"))]\n+  \"\"\n+  \"*\n+{\n+  CC_STATUS_INIT;\n+  switch (which_alternative)\n+    {\n+    case 0:\n+      return \\\"ldd %1\\\";\n+    case 1:\n+      if (push_operand (operands[0], DFmode))\n+        return \\\"pushd\\\";\n+      else\n+        return \\\"std %0\\\";\n+    case 2:\n+      return output_move_double (operands);\n+   }\n+}\")\n+\n+\n+;========================================================================\n+; The tahoe has the following semantics for byte (and similar for word)\n+; operands: if the operand is a register or immediate, it takes the full 32\n+; bit operand, if the operand is memory, it sign-extends the byte.  The\n+; operation is performed on the 32 bit values.  If the destination is a\n+; register, the full 32 bit result is stored, if the destination is memory,\n+; of course only the low part is stored.  The condition code is based on the\n+; 32 bit operation.  Only on the movz instructions the byte from memory is\n+; zero-extended rather than sign-extended.\n+\n+; This means that for arithmetic instructions we can use addb etc.  to\n+; perform a long add from a signed byte from memory to a register.  Of\n+; course this would also work for logical operations, but that doesn't seem\n+; very useful.\n+\n+(define_insn \"\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+\t(plus:SI (sign_extend:SI (match_operand:QI 1 \"memory_operand\" \"m\"))\n+\t\t (sign_extend:SI (match_operand:QI 2 \"memory_operand\" \"m\"))))]\n+  \"\"\n+  \"addb3 %1,%2,%0\")\n+\n+(define_insn \"\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+\t(plus:SI (match_operand:SI 1 \"nonmemory_operand\" \"%ri\")\n+\t\t (sign_extend:SI (match_operand:QI 2 \"memory_operand\" \"m\"))))]\n+  \"\"\n+  \"*\n+{\n+  if (rtx_equal_p (operands[0], operands[1]))\n+    return \\\"addb2 %2,%0\\\";\n+  return \\\"addb3 %1,%2,%0\\\";\n+}\")\n+\n+; We can also consider the result to be a half integer\n+\n+(define_insn \"\"\n+  [(set (match_operand:HI 0 \"register_operand\" \"=r\")\n+\t(plus:HI (sign_extend:HI (match_operand:QI 1 \"memory_operand\" \"m\"))\n+\t\t (sign_extend:HI (match_operand:QI 2 \"memory_operand\" \"m\"))))]\n+  \"\"\n+  \"addb3 %1,%2,%0\")\n+\n+(define_insn \"\"\n+  [(set (match_operand:HI 0 \"register_operand\" \"=r\")\n+\t(plus:HI (match_operand:HI 1 \"nonmemory_operand\" \"%ri\")\n+\t\t (sign_extend:HI (match_operand:QI 2 \"memory_operand\" \"m\"))))]\n+  \"\"\n+  \"*\n+{\n+  if (rtx_equal_p (operands[0], operands[1]))\n+    return \\\"addb2 %2,%0\\\";\n+  return \\\"addb3 %1,%2,%0\\\";\n+}\")\n+\n+; The same applies to words (HI)\n+\n+(define_insn \"\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+\t(plus:SI (sign_extend:SI (match_operand:HI 1 \"memory_operand\" \"m\"))\n+\t\t (sign_extend:SI (match_operand:HI 2 \"memory_operand\" \"m\"))))]\n+  \"\"\n+  \"addw3 %1,%2,%0\")\n+\n+(define_insn \"\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+\t(plus:SI (match_operand:SI 1 \"nonmemory_operand\" \"%ri\")\n+\t\t (sign_extend:SI (match_operand:HI 2 \"memory_operand\" \"m\"))))]\n+  \"\"\n+  \"*\n+{\n+  if (rtx_equal_p (operands[0], operands[1]))\n+    return \\\"addw2 %2,%0\\\";\n+  return \\\"addw3 %1,%2,%0\\\";\n+}\")\n+\n+; ======================= Now for subtract ==============================\n+\n+(define_insn \"\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+\t(minus:SI (sign_extend:SI (match_operand:QI 1 \"memory_operand\" \"m\"))\n+\t\t  (sign_extend:SI (match_operand:QI 2 \"memory_operand\" \"m\"))))]\n+  \"\"\n+  \"subb3 %2,%1,%0\")\n+\n+(define_insn \"\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+\t(minus:SI (match_operand:SI 1 \"nonmemory_operand\" \"ri\")\n+\t\t  (sign_extend:SI (match_operand:QI 2 \"memory_operand\" \"m\"))))]\n+  \"\"\n+  \"*\n+{\n+  if (rtx_equal_p (operands[0], operands[1]))\n+    return \\\"subb2 %2,%0\\\";\n+  return \\\"subb3 %2,%1,%0\\\";\n+}\")\n+\n+(define_insn \"\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+\t(minus:SI (sign_extend:SI (match_operand:QI 1 \"memory_operand\" \"m\"))\n+\t\t  (match_operand:SI 2 \"nonmemory_operand\" \"ri\")))]\n+  \"\"\n+  \"subb3 %2,%1,%0\")\n+\n+; We can also consider the result to be a half integer\n+\n+(define_insn \"\"\n+  [(set (match_operand:HI 0 \"register_operand\" \"=r\")\n+\t(minus:HI (sign_extend:HI (match_operand:QI 1 \"memory_operand\" \"m\"))\n+\t\t (sign_extend:HI (match_operand:QI 2 \"memory_operand\" \"m\"))))]\n+  \"\"\n+  \"subb3 %2,%1,%0\")\n+\n+(define_insn \"\"\n+  [(set (match_operand:HI 0 \"register_operand\" \"=r\")\n+\t(minus:HI (match_operand:HI 1 \"nonmemory_operand\" \"%ri\")\n+\t\t (sign_extend:HI (match_operand:QI 2 \"memory_operand\" \"m\"))))]\n+  \"\"\n+  \"*\n+{\n+  if (rtx_equal_p (operands[0], operands[1]))\n+    return \\\"subb2 %2,%0\\\";\n+  return \\\"subb3 %2,%1,%0\\\";\n+}\")\n+\n+(define_insn \"\"\n+  [(set (match_operand:HI 0 \"register_operand\" \"=r\")\n+\t(minus:HI (sign_extend:HI (match_operand:QI 1 \"memory_operand\" \"m\"))\n+\t\t (match_operand:HI 2 \"nonmemory_operand\" \"ri\")))]\n+  \"\"\n+  \"subb3 %2,%1,%0\")\n+\n+; The same applies to words (HI)\n+\n+(define_insn \"\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+\t(minus:SI (sign_extend:SI (match_operand:HI 1 \"memory_operand\" \"m\"))\n+\t\t  (sign_extend:SI (match_operand:HI 2 \"memory_operand\" \"m\"))))]\n+  \"\"\n+  \"subw3 %2,%1,%0\")\n+\n+(define_insn \"\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+\t(minus:SI (match_operand:SI 1 \"nonmemory_operand\" \"ri\")\n+\t\t (sign_extend:SI (match_operand:HI 2 \"memory_operand\" \"m\"))))]\n+  \"\"\n+  \"*\n+{\n+  if (rtx_equal_p (operands[0], operands[1]))\n+    return \\\"subw2 %2,%0\\\";\n+  return \\\"subw3 %2,%1,%0\\\";\n+}\")\n+\n+(define_insn \"\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+\t(minus:SI (sign_extend:SI (match_operand:HI 1 \"memory_operand\" \"m\"))\n+\t\t  (match_operand:SI 2 \"nonmemory_operand\" \"ri\")))]\n+  \"\"\n+  \"subw3 %2,%1,%0\")\n+\n+; ======================= Now for neg ==============================\n+\n+(define_insn \"\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+\t(neg:SI (sign_extend:SI (match_operand:QI 1 \"memory_operand\" \"m\"))))]\n+  \"\"\n+  \"mnegb %1,%0\")\n+\n+(define_insn \"\"\n+  [(set (match_operand:HI 0 \"register_operand\" \"=r\")\n+\t(neg:HI (sign_extend:HI (match_operand:QI 1 \"memory_operand\" \"m\"))))]\n+  \"\"\n+  \"mnegb %1,%0\")\n+\n+(define_insn \"\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+\t(neg:SI (sign_extend:SI (match_operand:HI 1 \"memory_operand\" \"m\"))))]\n+  \"\"\n+  \"mnegw %1,%0\")\n+\n+;========================================================================\n+\n+\n+(define_insn \"addsi3\"\n+  [(set (match_operand:SI 0 \"general_operand\" \"=g\")\n+\t(plus:SI (match_operand:SI 1 \"general_operand\" \"g\")\n+\t\t (match_operand:SI 2 \"general_operand\" \"g\")))]\n+  \"\"\n+  \"*\n+{\n+  if (rtx_equal_p (operands[0], operands[1]))\n+    {\n+      if (operands[2] == const1_rtx)\n+\treturn \\\"incl %0\\\";\n+      if (GET_CODE (operands[2]) == CONST_INT\n+\t  && INTVAL (operands[2]) == -1)\n+\treturn \\\"decl %0\\\";\n+      if (GET_CODE (operands[2]) == CONST_INT\n+\t  && (unsigned) (- INTVAL (operands[2])) < 64)\n+\treturn \\\"subl2 $%n2,%0\\\";\n+      return \\\"addl2 %2,%0\\\";\n+    }\n+  if (rtx_equal_p (operands[0], operands[2]))\n+    return \\\"addl2 %1,%0\\\";\n+  if (GET_CODE (operands[2]) == CONST_INT\n+      && GET_CODE (operands[1]) == REG)\n+    {\n+      if (push_operand (operands[0], SImode))\n+        return \\\"pushab %c2(%1)\\\";\n+      return \\\"movab %c2(%1),%0\\\";\n+    }\n+  if (GET_CODE (operands[2]) == CONST_INT\n+      && (unsigned) (- INTVAL (operands[2])) < 64)\n+    return \\\"subl3 $%n2,%1,%0\\\";\n+  return \\\"addl3 %1,%2,%0\\\";\n+}\")\n+\n+\n+(define_insn \"addhi3\"\n+  [(set (match_operand:HI 0 \"general_operand\" \"=g\")\n+\t(plus:HI (match_operand:HI 1 \"general_operand\" \"g\")\n+\t\t (match_operand:HI 2 \"general_operand\" \"g\")))]\n+  \"\"\n+  \"*\n+{\n+  if (rtx_equal_p (operands[0], operands[1]))\n+    {\n+      if (operands[2] == const1_rtx)\n+\treturn \\\"incw %0\\\";\n+      if (GET_CODE (operands[2]) == CONST_INT\n+\t  && INTVAL (operands[2]) == -1)\n+\treturn \\\"decw %0\\\";\n+      if (GET_CODE (operands[2]) == CONST_INT\n+\t  && (unsigned) (- INTVAL (operands[2])) < 64)\n+\treturn \\\"subw2 $%n2,%0\\\";\n+      return \\\"addw2 %2,%0\\\";\n+    }\n+  if (rtx_equal_p (operands[0], operands[2]))\n+    return \\\"addw2 %1,%0\\\";\n+  if (GET_CODE (operands[2]) == CONST_INT\n+      && (unsigned) (- INTVAL (operands[2])) < 64)\n+    return \\\"subw3 $%n2,%1,%0\\\";\n+  return \\\"addw3 %1,%2,%0\\\";\n+}\")\n+\n+\n+(define_insn \"addqi3\"\n+  [(set (match_operand:QI 0 \"general_operand\" \"=g\")\n+\t(plus:QI (match_operand:QI 1 \"general_operand\" \"g\")\n+\t\t (match_operand:QI 2 \"general_operand\" \"g\")))]\n+  \"\"\n+  \"*\n+{\n+  if (rtx_equal_p (operands[0], operands[1]))\n+    {\n+      if (operands[2] == const1_rtx)\n+\treturn \\\"incb %0\\\";\n+      if (GET_CODE (operands[2]) == CONST_INT\n+\t  && INTVAL (operands[2]) == -1)\n+\treturn \\\"decb %0\\\";\n+      if (GET_CODE (operands[2]) == CONST_INT\n+\t  && (unsigned) (- INTVAL (operands[2])) < 64)\n+\treturn \\\"subb2 $%n2,%0\\\";\n+      return \\\"addb2 %2,%0\\\";\n+    }\n+  if (rtx_equal_p (operands[0], operands[2]))\n+    return \\\"addb2 %1,%0\\\";\n+  if (GET_CODE (operands[2]) == CONST_INT\n+      && (unsigned) (- INTVAL (operands[2])) < 64)\n+    return \\\"subb3 $%n2,%1,%0\\\";\n+  return \\\"addb3 %1,%2,%0\\\";\n+}\")\n+\n+; addsf3 can only add into the fpp register since the fpp is treated\n+; as a separate unit in the machine.  It also doesn't set the flags at\n+; all.\n+\n+(define_insn \"addsf3\"\n+  [(set (match_operand:SF 0 \"register_operand\" \"=a\")\n+\t(plus:SF (match_operand:SF 1 \"register_operand\" \"%0\")\n+\t\t (match_operand:SF 2 \"general_operand\" \"g\")))]\n+  \"\"\n+  \"*\n+{\n+  CC_STATUS_INIT;\n+  return \\\"addf %2\\\";\n+}\")\n+\n+\n+; adddf3 can only add into the fpp reg since the fpp is treated as a\n+; separate entity.  Doubles can only be read from a register or memory\n+; since a double is not an immediate mode.  Flags are not set by this\n+; instruction.\n+\n+(define_insn \"adddf3\"\n+  [(set (match_operand:DF 0 \"register_operand\" \"=a\")\n+\t(plus:DF (match_operand:DF 1 \"register_operand\" \"%0\")\n+\t\t (match_operand:DF 2 \"general_operand\" \"rm\")))]\n+  \"\"\n+  \"*\n+{\n+  CC_STATUS_INIT;\n+  return \\\"addd %2\\\";\n+}\")\n+\n+\n+; Subtraction from the sp (needed by the built in alloc function) needs\n+; to be different since the sp cannot be directly read on the tahoe.\n+; If it's a simple constant, you just use displacement.  Otherwise, you\n+; push the sp, and then do the subtraction off the stack.\n+\n+(define_insn \"subsi3\"\n+  [(set (match_operand:SI 0 \"general_operand\" \"=g\")\n+\t(minus:SI (match_operand:SI 1 \"general_operand\" \"g\")\n+\t\t  (match_operand:SI 2 \"general_operand\" \"g\")))]\n+  \"\"\n+  \"*\n+{\n+  if (rtx_equal_p (operands[0], operands[1]))\n+    {\n+      if (operands[2] == const1_rtx)\n+\treturn \\\"decl %0\\\";\n+      if (GET_CODE(operands[0]) == REG && REGNO(operands[0]) == 14)\n+        {\n+\t  if (GET_CODE(operands[2]) == CONST_INT)\n+\t    return \\\"movab %n2(sp),sp\\\";\n+\t  else\n+\t    return \\\"pushab (sp)\\;subl3 %2,(sp),sp\\\";\n+\t}\n+      return \\\"subl2 %2,%0\\\";\n+    }\n+  if (rtx_equal_p (operands[1], operands[2]))\n+    return \\\"clrl %0\\\";\n+  return \\\"subl3 %2,%1,%0\\\";\n+}\")\n+\n+\n+(define_insn \"subhi3\"\n+  [(set (match_operand:HI 0 \"general_operand\" \"=g\")\n+\t(minus:HI (match_operand:HI 1 \"general_operand\" \"g\")\n+\t\t  (match_operand:HI 2 \"general_operand\" \"g\")))]\n+  \"\"\n+  \"*\n+{\n+  if (rtx_equal_p (operands[0], operands[1]))\n+    {\n+      if (operands[2] == const1_rtx)\n+\treturn \\\"decw %0\\\";\n+      return \\\"subw2 %2,%0\\\";\n+    }\n+  if (rtx_equal_p (operands[1], operands[2]))\n+    return \\\"clrw %0\\\";\n+  return \\\"subw3 %2,%1,%0\\\";\n+}\")\n+\n+\n+(define_insn \"subqi3\"\n+  [(set (match_operand:QI 0 \"general_operand\" \"=g\")\n+\t(minus:QI (match_operand:QI 1 \"general_operand\" \"g\")\n+\t\t  (match_operand:QI 2 \"general_operand\" \"g\")))]\n+  \"\"\n+  \"*\n+{\n+  if (rtx_equal_p (operands[0], operands[1]))\n+    {\n+      if (operands[2] == const1_rtx)\n+\treturn \\\"decb %0\\\";\n+      return \\\"subb2 %2,%0\\\";\n+    }\n+  if (rtx_equal_p (operands[1], operands[2]))\n+    return \\\"clrb %0\\\";\n+  return \\\"subb3 %2,%1,%0\\\";\n+}\")\n+\n+\n+; subsf3 can only subtract into the fpp accumulator due to the way\n+; the fpp reg is limited by the instruction set.  This also doesn't\n+; bother setting up flags.\n+\n+(define_insn \"subsf3\"\n+  [(set (match_operand:SF 0 \"register_operand\" \"=a\")\n+\t(minus:SF (match_operand:SF 1 \"register_operand\" \"0\")\n+\t\t  (match_operand:SF 2 \"general_operand\" \"g\")))]\n+  \"\"\n+  \"*\n+{\n+  CC_STATUS_INIT;\n+  return \\\"subf %2\\\";\n+}\")\n+\n+\n+; subdf3 is set up to subtract into the fpp reg due to limitations\n+; of the fpp instruction set.  Doubles can not be immediate.  This\n+; instruction does not set the flags.\n+\n+(define_insn \"subdf3\"\n+  [(set (match_operand:DF 0 \"register_operand\" \"=a\")\n+\t(minus:DF (match_operand:DF 1 \"register_operand\" \"0\")\n+\t\t  (match_operand:DF 2 \"general_operand\" \"rm\")))]\n+  \"\"\n+  \"*\n+{\n+  CC_STATUS_INIT;\n+  return \\\"subd %2\\\";\n+}\")\n+\n+\n+(define_insn \"mulsi3\"\n+  [(set (match_operand:SI 0 \"general_operand\" \"=g\")\n+\t(mult:SI (match_operand:SI 1 \"general_operand\" \"g\")\n+\t\t (match_operand:SI 2 \"general_operand\" \"g\")))]\n+  \"\"\n+  \"*\n+{\n+  if (rtx_equal_p (operands[0], operands[1]))\n+    return \\\"mull2 %2,%0\\\";\n+  if (rtx_equal_p (operands[0], operands[2]))\n+    return \\\"mull2 %1,%0\\\";\n+  return \\\"mull3 %1,%2,%0\\\";\n+}\")\n+\n+\n+; mulsf3 can only multiply into the fpp accumulator due to limitations\n+; of the fpp.  It also does not set the condition codes properly.\n+\n+(define_insn \"mulsf3\"\n+  [(set (match_operand:SF 0 \"register_operand\" \"=a\")\n+\t(mult:SF (match_operand:SF 1 \"register_operand\" \"%0\")\n+\t\t (match_operand:SF 2 \"general_operand\" \"g\")))]\n+  \"\"\n+  \"*\n+{\n+  CC_STATUS_INIT;\n+  return \\\"mulf %2\\\";\n+}\")\n+\n+\n+; muldf3 can only multiply into the fpp reg since the fpp is limited\n+; from the rest.  Doubles may not be immediate mode.  This does not set\n+; the flags like gcc would expect.\n+\n+(define_insn \"muldf3\"\n+  [(set (match_operand:DF 0 \"register_operand\" \"=a\")\n+\t(mult:DF (match_operand:DF 1 \"register_operand\" \"%0\")\n+\t\t (match_operand:DF 2 \"general_operand\" \"rm\")))]\n+  \"\"\n+  \"*\n+{\n+  CC_STATUS_INIT;\n+  return \\\"muld %2\\\";\n+}\")\n+\n+\n+\n+(define_insn \"divsi3\"\n+  [(set (match_operand:SI 0 \"general_operand\" \"=g\")\n+\t(div:SI (match_operand:SI 1 \"general_operand\" \"g\")\n+\t\t(match_operand:SI 2 \"general_operand\" \"g\")))]\n+  \"\"\n+  \"*\n+{\n+  if (rtx_equal_p (operands[1], operands[2]))\n+    return \\\"movl $1,%0\\\";\n+  if (operands[1] == const0_rtx)\n+    return \\\"clrl %0\\\";\n+  if (GET_CODE (operands[2]) == CONST_INT\n+      && INTVAL (operands[2]) == -1)\n+    return \\\"mnegl %1,%0\\\";\n+  if (rtx_equal_p (operands[0], operands[1]))\n+    return \\\"divl2 %2,%0\\\";\n+  return \\\"divl3 %2,%1,%0\\\";\n+}\")\n+\n+\n+; divsf3 must divide into the fpp accumulator.  Flags are not set by\n+; this instruction, so they are cleared.\n+\n+(define_insn \"divsf3\"\n+  [(set (match_operand:SF 0 \"register_operand\" \"=a\")\n+\t(div:SF (match_operand:SF 1 \"register_operand\" \"0\")\n+\t\t(match_operand:SF 2 \"general_operand\" \"g\")))]\n+  \"\"\n+  \"*\n+{\n+  CC_STATUS_INIT;\n+  return \\\"divf %2\\\";\n+}\")\n+\n+\n+; divdf3 also must divide into the fpp reg so optimization isn't\n+; possible.  Note that doubles cannot be immediate.  The flags here\n+; are not set correctly so they must be ignored.\n+\n+(define_insn \"divdf3\"\n+  [(set (match_operand:DF 0 \"register_operand\" \"=a\")\n+\t(div:DF (match_operand:DF 1 \"register_operand\" \"0\")\n+\t\t(match_operand:DF 2 \"general_operand\" \"rm\")))]\n+  \"\"\n+  \"*\n+{\n+  CC_STATUS_INIT;\n+  return \\\"divd %2\\\";\n+}\")\n+\n+\n+\n+(define_insn \"andsi3\"\n+  [(set (match_operand:SI 0 \"general_operand\" \"=g\")\n+\t(and:SI (match_operand:SI 1 \"general_operand\" \"g\")\n+\t\t(match_operand:SI 2 \"general_operand\" \"g\")))]\n+  \"\"\n+  \"*\n+{\n+  if (rtx_equal_p (operands[0], operands[1]))\n+    return \\\"andl2 %2,%0\\\";\n+  if (rtx_equal_p (operands[0], operands[2]))\n+    return \\\"andl2 %1,%0\\\";\n+  return \\\"andl3 %2,%1,%0\\\";\n+}\")\n+\n+\n+\n+(define_insn \"andhi3\"\n+  [(set (match_operand:HI 0 \"general_operand\" \"=g\")\n+\t(and:HI (match_operand:HI 1 \"general_operand\" \"g\")\n+\t\t(match_operand:HI 2 \"general_operand\" \"g\")))]\n+  \"\"\n+  \"*\n+{\n+  if (rtx_equal_p (operands[0], operands[1]))\n+    return \\\"andw2 %2,%0\\\";\n+  if (rtx_equal_p (operands[0], operands[2]))\n+    return \\\"andw2 %1,%0\\\";\n+  return \\\"andw3 %2,%1,%0\\\";\n+}\")\n+\n+\n+(define_insn \"andqi3\"\n+  [(set (match_operand:QI 0 \"general_operand\" \"=g\")\n+\t(and:QI (match_operand:QI 1 \"general_operand\" \"g\")\n+\t\t(match_operand:QI 2 \"general_operand\" \"g\")))]\n+  \"\"\n+  \"*\n+{\n+  if (rtx_equal_p (operands[0], operands[1]))\n+    return \\\"andb2 %2,%0\\\";\n+  if (rtx_equal_p (operands[0], operands[2]))\n+    return \\\"andb2 %1,%0\\\";\n+  return \\\"andb3 %2,%1,%0\\\";\n+}\")\n+\n+\n+(define_insn \"iorsi3\"\n+  [(set (match_operand:SI 0 \"general_operand\" \"=g\")\n+\t(ior:SI (match_operand:SI 1 \"general_operand\" \"g\")\n+\t\t(match_operand:SI 2 \"general_operand\" \"g\")))]\n+  \"\"\n+  \"*\n+{\n+  if (rtx_equal_p (operands[0], operands[1]))\n+    return \\\"orl2 %2,%0\\\";\n+  if (rtx_equal_p (operands[0], operands[2]))\n+    return \\\"orl2 %1,%0\\\";\n+  return \\\"orl3 %2,%1,%0\\\";\n+}\")\n+\n+\n+\n+(define_insn \"iorhi3\"\n+  [(set (match_operand:HI 0 \"general_operand\" \"=g\")\n+\t(ior:HI (match_operand:HI 1 \"general_operand\" \"g\")\n+\t\t(match_operand:HI 2 \"general_operand\" \"g\")))]\n+  \"\"\n+  \"*\n+{\n+  if (rtx_equal_p (operands[0], operands[1]))\n+    return \\\"orw2 %2,%0\\\";\n+  if (rtx_equal_p (operands[0], operands[2]))\n+    return \\\"orw2 %1,%0\\\";\n+  return \\\"orw3 %2,%1,%0\\\";\n+}\")\n+\n+\n+\n+(define_insn \"iorqi3\"\n+  [(set (match_operand:QI 0 \"general_operand\" \"=g\")\n+\t(ior:QI (match_operand:QI 1 \"general_operand\" \"g\")\n+\t\t(match_operand:QI 2 \"general_operand\" \"g\")))]\n+  \"\"\n+  \"*\n+{\n+  if (rtx_equal_p (operands[0], operands[1]))\n+    return \\\"orb2 %2,%0\\\";\n+  if (rtx_equal_p (operands[0], operands[2]))\n+    return \\\"orb2 %1,%0\\\";\n+  return \\\"orb3 %2,%1,%0\\\";\n+}\")\n+\n+\n+(define_insn \"xorsi3\"\n+  [(set (match_operand:SI 0 \"general_operand\" \"=g\")\n+\t(xor:SI (match_operand:SI 1 \"general_operand\" \"g\")\n+\t\t(match_operand:SI 2 \"general_operand\" \"g\")))]\n+  \"\"\n+  \"*\n+{\n+  if (rtx_equal_p (operands[0], operands[1]))\n+    return \\\"xorl2 %2,%0\\\";\n+  if (rtx_equal_p (operands[0], operands[2]))\n+    return \\\"xorl2 %1,%0\\\";\n+  return \\\"xorl3 %2,%1,%0\\\";\n+}\")\n+\n+\n+(define_insn \"xorhi3\"\n+  [(set (match_operand:HI 0 \"general_operand\" \"=g\")\n+\t(xor:HI (match_operand:HI 1 \"general_operand\" \"g\")\n+\t\t(match_operand:HI 2 \"general_operand\" \"g\")))]\n+  \"\"\n+  \"*\n+{\n+  if (rtx_equal_p (operands[0], operands[1]))\n+    return \\\"xorw2 %2,%0\\\";\n+  if (rtx_equal_p (operands[0], operands[2]))\n+    return \\\"xorw2 %1,%0\\\";\n+  return \\\"xorw3 %2,%1,%0\\\";\n+}\")\n+\n+\n+(define_insn \"xorqi3\"\n+  [(set (match_operand:QI 0 \"general_operand\" \"=g\")\n+\t(xor:QI (match_operand:QI 1 \"general_operand\" \"g\")\n+\t\t(match_operand:QI 2 \"general_operand\" \"g\")))]\n+  \"\"\n+  \"*\n+{\n+  if (rtx_equal_p (operands[0], operands[1]))\n+    return \\\"xorb2 %2,%0\\\";\n+  if (rtx_equal_p (operands[0], operands[2]))\n+    return \\\"xorb2 %1,%0\\\";\n+  return \\\"xorb3 %2,%1,%0\\\";\n+}\")\n+\n+\n+; shifts on the tahoe are expensive, try some magic first...\n+\n+(define_insn \"ashlsi3\"\n+  [(set (match_operand:SI 0 \"general_operand\" \"=g\")\n+\t(ashift:SI (match_operand:SI 1 \"general_operand\" \"g\")\n+\t\t   (match_operand:QI 2 \"general_operand\" \"g\")))]\n+  \"\"\n+  \"*\n+{\n+  if (GET_CODE(operands[2]) == REG)\n+      return \\\"mull3 ___shtab[%2],%1,%0\\\";\n+  /* if (GET_CODE(operands[2]) == REG)\n+    if (rtx_equal_p (operands[0], operands[1]))\n+      return \\\"mull2 ___shtab[%2],%1\\\";\n+    else\n+      return \\\"mull3 ___shtab[%2],%1,%0\\\"; */\n+  if (GET_CODE(operands[1]) == REG)\n+    {\n+      if (operands[2] == const1_rtx)\n+\t{\n+\t  CC_STATUS_INIT;\n+\t  return \\\"movaw 0[%1],%0\\\";\n+\t}\n+      if (GET_CODE(operands[2]) == CONST_INT && INTVAL(operands[2]) == 2)\n+\t{\n+\t  CC_STATUS_INIT;\n+\t  return \\\"moval 0[%1],%0\\\";\n+\t}\n+    }\n+  if (GET_CODE(operands[2]) != CONST_INT || INTVAL(operands[2]) == 1)\n+    return \\\"shal %2,%1,%0\\\";\n+  if (rtx_equal_p (operands[0], operands[1]))\n+    return \\\"mull2 %s2,%1\\\";\n+  else\n+    return \\\"mull3 %s2,%1,%0\\\";\n+}\")\n+\n+\n+(define_insn \"ashrsi3\"\n+  [(set (match_operand:SI 0 \"general_operand\" \"=g\")\n+\t(ashiftrt:SI (match_operand:SI 1 \"general_operand\" \"g\")\n+\t\t   (match_operand:QI 2 \"general_operand\" \"g\")))]\n+  \"\"\n+  \"shar %2,%1,%0\")\n+\n+\n+; shifts are very expensive, try some magic first...\n+\n+(define_insn \"lshlsi3\"\n+  [(set (match_operand:SI 0 \"general_operand\" \"=g\")\n+\t(lshift:SI (match_operand:SI 1 \"general_operand\" \"g\")\n+\t\t   (match_operand:QI 2 \"general_operand\" \"g\")))]\n+  \"\"\n+  \"*\n+{\n+  if (GET_CODE(operands[2]) == REG)\n+      return \\\"mull3 ___shtab[%2],%1,%0\\\";\n+  /* if (GET_CODE(operands[2]) == REG)\n+  if (rtx_equal_p (operands[0], operands[1]))\n+    return \\\"mull2 ___shtab[%2],%1\\\";\n+  else\n+    return \\\"mull3 ___shtab[%2],%1,%0\\\"; */\n+  if (GET_CODE(operands[1]) == REG)\n+    {\n+      if (operands[2] == const1_rtx)\n+        {\n+\t  CC_STATUS_INIT;\n+\t  return \\\"movaw 0[%1],%0\\\";\n+\t}\n+      if (GET_CODE(operands[2]) == CONST_INT && INTVAL(operands[2]) == 2)\n+        {\n+\t  CC_STATUS_INIT;\n+\t  return \\\"moval 0[%1],%0\\\";\n+\t}\n+    }\n+  if (GET_CODE(operands[2]) != CONST_INT || INTVAL(operands[2]) == 1)\n+    return \\\"shll %2,%1,%0\\\";\n+  if (rtx_equal_p (operands[0], operands[1]))\n+    return \\\"mull2 %s2,%1\\\";\n+  else\n+    return \\\"mull3 %s2,%1,%0\\\";\n+}\")\n+\n+\n+(define_insn \"lshrsi3\"\n+  [(set (match_operand:SI 0 \"general_operand\" \"=g\")\n+\t(lshiftrt:SI (match_operand:SI 1 \"general_operand\" \"g\")\n+\t\t   (match_operand:QI 2 \"general_operand\" \"g\")))]\n+  \"\"\n+  \"shrl %2,%1,%0\")\n+\n+\n+(define_insn \"negsi2\"\n+  [(set (match_operand:SI 0 \"general_operand\" \"=g\")\n+\t(neg:SI (match_operand:SI 1 \"general_operand\" \"g\")))]\n+  \"\"\n+  \"mnegl %1,%0\")\n+\n+\n+(define_insn \"neghi2\"\n+  [(set (match_operand:HI 0 \"general_operand\" \"=g\")\n+\t(neg:HI (match_operand:HI 1 \"general_operand\" \"g\")))]\n+  \"\"\n+  \"mnegw %1,%0\")\n+\n+\n+(define_insn \"negqi2\"\n+  [(set (match_operand:QI 0 \"general_operand\" \"=g\")\n+\t(neg:QI (match_operand:QI 1 \"general_operand\" \"g\")))]\n+  \"\"\n+  \"mnegb %1,%0\")\n+\n+\n+; negsf2 can only negate the value already in the fpp accumulator.\n+; The value remains in the fpp accumulator.  No flags are set.\n+\n+(define_insn \"negsf2\"\n+  [(set (match_operand:SF 0 \"register_operand\" \"=a,=a\")\n+\t(neg:SF (match_operand:SF 1 \"register_operand\" \"a,g\")))]\n+  \"\"\n+  \"*\n+{\n+  CC_STATUS_INIT;\n+  switch (which_alternative)\n+    {\n+    case 0: return \\\"negf\\\";\n+    case 1: return \\\"lnf %1\\\";\n+    }\n+}\")\n+\n+\n+; negdf2 can only negate the value already in the fpp accumulator.\n+; The value remains in the fpp accumulator.  No flags are set.\n+\n+(define_insn \"negdf2\"\n+  [(set (match_operand:DF 0 \"register_operand\" \"=a,=a\")\n+\t(neg:DF (match_operand:DF 1 \"register_operand\" \"a,g\")))]\n+  \"\"\n+  \"*\n+{\n+  CC_STATUS_INIT;\n+  switch (which_alternative)\n+    {\n+    case 0: return \\\"negd\\\";\n+    case 1: return \\\"lnd %1\\\";\n+    }\n+}\")\n+\n+\n+; sqrtsf2 tahoe can calculate the square root of a float in the\n+; fpp accumulator.  The answer remains in the fpp accumulator.  No\n+; flags are set by this function.\n+\n+(define_insn \"sqrtsf2\"\n+  [(set (match_operand:SF 0 \"register_operand\" \"=a\")\n+\t(sqrt:SF (match_operand:SF 1 \"register_operand\" \"0\")))]\n+  \"\"\n+  \"*\n+{\n+  CC_STATUS_INIT;\n+  return \\\"sqrtf\\\";\n+}\")\n+\n+\n+; ffssi2 tahoe instruction gives one less than gcc desired result for\n+; any given input.  So the increment is necessary here.\n+\n+(define_insn \"ffssi2\"\n+  [(set (match_operand:SI 0 \"general_operand\" \"=g\")\n+\t(ffs:SI (match_operand:SI 1 \"general_operand\" \"g\")))]\n+  \"\"\n+  \"*\n+{\n+  if (push_operand(operands[0], SImode))\n+    return \\\"ffs %1,%0\\;incl (sp)\\\";\n+  return \\\"ffs %1,%0\\;incl %0\\\";\n+}\")\n+\n+\n+(define_insn \"one_cmplsi2\"\n+  [(set (match_operand:SI 0 \"general_operand\" \"=g\")\n+\t(not:SI (match_operand:SI 1 \"general_operand\" \"g\")))]\n+  \"\"\n+  \"mcoml %1,%0\")\n+\n+\n+(define_insn \"one_cmplhi2\"\n+  [(set (match_operand:HI 0 \"general_operand\" \"=g\")\n+\t(not:HI (match_operand:HI 1 \"general_operand\" \"g\")))]\n+  \"\"\n+  \"mcomw %1,%0\")\n+\n+\n+(define_insn \"one_cmplqi2\"\n+  [(set (match_operand:QI 0 \"general_operand\" \"=g\")\n+\t(not:QI (match_operand:QI 1 \"general_operand\" \"g\")))]\n+  \"\"\n+  \"mcomb %1,%0\")\n+\n+\n+; cmpsi works fine, but due to microcode problems, the tahoe doesn't\n+; properly compare hi's and qi's.  Leaving them out seems to be acceptable\n+; to the compiler, so they were left out.  Compares of the stack are\n+; possible, though.\n+\n+; There are optimized cases possible, however.  These follow first.\n+\n+(define_insn \"\"\n+  [(set (cc0)\n+\t(compare (sign_extend:SI (match_operand:HI 0 \"memory_operand\" \"m\"))\n+\t\t (sign_extend:SI (match_operand:HI 1 \"memory_operand\" \"m\"))))]\n+  \"\"\n+  \"cmpw %0,%1\")\n+\n+(define_insn \"\"\n+  [(set (cc0)\n+\t(compare (match_operand:SI 0 \"nonmemory_operand\" \"ri\")\n+\t\t (sign_extend:SI (match_operand:HI 1 \"memory_operand\" \"m\"))))]\n+  \"\"\n+  \"cmpw %0,%1\")\n+\n+(define_insn \"\"\n+  [(set (cc0)\n+\t(compare (sign_extend:SI (match_operand:HI 0 \"memory_operand\" \"m\"))\n+\t\t (match_operand:SI 1 \"nonmemory_operand\" \"ri\")))]\n+  \"\"\n+  \"cmpw %0,%1\")\n+\n+; zero-extended compares give the same result as sign-extended compares, if\n+; the compare is unsigned.  Just see: if both operands are <65536 they are the\n+; same in both cases.  If both are >=65536 the you effectively compare x+D\n+; with y+D, where D=2**32-2**16, so the result is the same.  if x<65536 and\n+; y>=65536 then you compare x with y+D, and in both cases the result is x<y.\n+\n+(define_insn \"\"\n+  [(set (cc0)\n+\t(compare (zero_extend:SI (match_operand:HI 0 \"memory_operand\" \"m\"))\n+\t\t (zero_extend:SI (match_operand:HI 1 \"memory_operand\" \"m\"))))]\n+  \"tahoe_cmp_check (insn, operands[0], 0)\"\n+  \"cmpw %0,%1\")\n+\n+(define_insn \"\"\n+  [(set (cc0)\n+\t(compare (zero_extend:SI (match_operand:HI 0 \"memory_operand\" \"m\"))\n+\t\t (match_operand:SI 1 \"immediate_operand\" \"i\")))]\n+  \"tahoe_cmp_check(insn, operands[1], 65535)\"\n+  \"*\n+{\n+  if (INTVAL (operands[1]) > 32767)\n+    operands[1] = gen_rtx (CONST_INT, VOIDmode, INTVAL (operands[1]) + 0xffff0000);\n+  return \\\"cmpw %0,%1\\\";\n+}\")\n+\n+\n+(define_insn \"\"\n+  [(set (cc0)\n+\t(compare (sign_extend:SI (match_operand:QI 0 \"memory_operand\" \"m\"))\n+\t\t (sign_extend:SI (match_operand:QI 1 \"memory_operand\" \"m\"))))]\n+  \"\"\n+  \"cmpb %0,%1\")\n+\n+(define_insn \"\"\n+  [(set (cc0)\n+\t(compare (match_operand:SI 0 \"nonmemory_operand\" \"ri\")\n+\t\t (sign_extend:SI (match_operand:QI 1 \"memory_operand\" \"m\"))))]\n+  \"\"\n+  \"cmpb %0,%1\")\n+\n+(define_insn \"\"\n+  [(set (cc0)\n+\t(compare (sign_extend:SI (match_operand:QI 0 \"memory_operand\" \"m\"))\n+\t\t (match_operand:SI 1 \"nonmemory_operand\" \"ri\")))]\n+  \"\"\n+  \"cmpb %0,%1\")\n+\n+; zero-extended compares give the same result as sign-extended compares, if\n+; the compare is unsigned.  Just see: if both operands are <128 they are the\n+; same in both cases.  If both are >=128 the you effectively compare x+D\n+; with y+D, where D=2**32-2**8, so the result is the same.  if x<128 and\n+; y>=128 then you compare x with y+D, and in both cases the result is x<y.\n+\n+(define_insn \"\"\n+  [(set (cc0)\n+\t(compare (zero_extend:SI (match_operand:QI 0 \"memory_operand\" \"m\"))\n+\t\t (zero_extend:SI (match_operand:QI 1 \"memory_operand\" \"m\"))))]\n+  \"tahoe_cmp_check (insn, operands[0], 0)\"\n+  \"cmpb %0,%1\")\n+\n+(define_insn \"\"\n+  [(set (cc0)\n+\t(compare (zero_extend:SI (match_operand:QI 0 \"memory_operand\" \"m\"))\n+\t\t (match_operand:SI 1 \"immediate_operand\" \"i\")))]\n+  \"tahoe_cmp_check(insn, operands[1], 255)\"\n+  \"*\n+{\n+  if (INTVAL (operands[1]) > 127)\n+    operands[1] = gen_rtx (CONST_INT, VOIDmode, INTVAL (operands[1]) + 0xffffff00);\n+  return \\\"cmpb %0,%1\\\";\n+}\")\n+\n+\n+(define_insn \"cmpsi\"\n+  [(set (cc0)\n+\t(compare (match_operand:SI 0 \"nonimmediate_operand\" \"g\")\n+\t         (match_operand:SI 1 \"general_operand\" \"g\")))]\n+  \"\"\n+  \"cmpl %0,%1\")\n+\n+\n+; cmpsf similar to vax, but first operand is expected to be in the\n+; fpp accumulator.\n+\n+(define_insn \"cmpsf\"\n+  [(set (cc0)\n+\t(compare (match_operand:SF 0 \"general_operand\" \"a,g\")\n+\t       (match_operand:SF 1 \"general_operand\" \"g,g\")))]\n+  \"\"\n+  \"*\n+{\n+  switch (which_alternative)\n+    {\n+    case 0: return \\\"cmpf %1\\\";\n+    case 1: return \\\"cmpf2 %0,%1\\\";\n+    }\n+}\")\n+\n+\n+; cmpdf similar to vax, but first operand is expected to be in the\n+; fpp accumulator.  Immediate doubles not allowed.\n+\n+(define_insn \"cmpdf\"\n+  [(set (cc0)\n+\t(compare (match_operand:DF 0 \"general_operand\" \"a,rm\")\n+\t\t (match_operand:DF 1 \"general_operand\" \"rm,rm\")))]\n+  \"\"\n+  \"*\n+{\n+  switch (which_alternative)\n+    {\n+    case 0: return \\\"cmpd %1\\\";\n+    case 1: return \\\"cmpd2 %0,%1\\\";\n+    }\n+}\")\n+\n+;; We don't want to allow a constant operand for test insns because\n+;; (set (cc0) (const_int foo)) has no mode information.  Such insns will\n+;; be folded while optimizing anyway.\n+\n+(define_insn \"tstsi\"\n+  [(set (cc0)\n+\t(match_operand:SI 0 \"nonimmediate_operand\" \"g\"))]\n+  \"\"\n+  \"tstl %0\")\n+\n+\n+; small tests from memory are normal, but testing from registers doesn't\n+; expand the data properly.  So test in this case does a convert and tests\n+; the new register data from the stack.\n+\n+; First some special cases that do work\n+\n+\n+(define_insn \"\"\n+  [(set (cc0)\n+\t(sign_extend:SI (match_operand:HI 0 \"memory_operand\" \"m\")))]\n+  \"\"\n+  \"tstw %0\")\n+\n+(define_insn \"\"\n+  [(set (cc0)\n+\t(zero_extend:SI (match_operand:HI 0 \"memory_operand\" \"m\")))]\n+  \"tahoe_cmp_check (insn, operands[0], 0)\"\n+  \"tstw %0\")\n+\n+\n+(define_insn \"tsthi\"\n+  [(set (cc0)\n+\t(match_operand:HI 0 \"extendable_operand\" \"m,!r\"))]\n+  \"GET_MODE (operands[0]) != VOIDmode\"\n+  \"*\n+{\n+  rtx xoperands[2];\n+  extern rtx tahoe_reg_conversion_loc;\n+  switch (which_alternative)\n+    {\n+    case 0:\n+      return \\\"tstw %0\\\";\n+    case 1:\n+      xoperands[0] = operands[0];\n+      xoperands[1] = tahoe_reg_conversion_loc;\n+      output_asm_insn (\\\"movl %0,%1\\\", xoperands);\n+      xoperands[1] = plus_constant (XEXP (tahoe_reg_conversion_loc, 0), 2);\n+      output_asm_insn (\\\"tstw %a1\\\", xoperands);\n+      return \\\"\\\";\n+    }\n+}\")\n+\n+\n+(define_insn \"\"\n+  [(set (cc0)\n+\t(sign_extend:SI (match_operand:QI 0 \"memory_operand\" \"m\")))]\n+  \"\"\n+  \"tstb %0\")\n+\n+(define_insn \"\"\n+  [(set (cc0)\n+\t(zero_extend:SI (match_operand:QI 0 \"memory_operand\" \"m\")))]\n+  \"tahoe_cmp_check (insn, operands[0], 0)\"\n+  \"tstb %0\")\n+\n+\n+(define_insn \"tstqi\"\n+  [(set (cc0)\n+\t(match_operand:QI 0 \"extendable_operand\" \"m,!r\"))]\n+  \"GET_MODE (operands[0]) != VOIDmode\"\n+  \"*\n+{\n+  rtx xoperands[2];\n+  extern rtx tahoe_reg_conversion_loc;\n+  switch (which_alternative)\n+    {\n+    case 0:\n+      return \\\"tstb %0\\\";\n+    case 1:\n+      xoperands[0] = operands[0];\n+      xoperands[1] = tahoe_reg_conversion_loc;\n+      output_asm_insn (\\\"movl %0,%1\\\", xoperands);\n+      xoperands[1] = plus_constant (XEXP (tahoe_reg_conversion_loc, 0), 3);\n+      output_asm_insn (\\\"tstb %a1\\\", xoperands);\n+      return \\\"\\\";\n+    }\n+}\")\n+\n+; tstsf compares a given value to a value already in the fpp accumulator.\n+; No flags are set by this so ignore them.\n+\n+(define_insn \"tstsf\"\n+  [(set (cc0)\n+\t(match_operand:SF 0 \"register_operand\" \"a\"))]\n+  \"\"\n+  \"tstf\")\n+\n+\n+; tstdf compares a given value to a value already in the fpp accumulator.\n+; immediate doubles not allowed.  Flags are ignored after this.\n+\n+(define_insn \"tstdf\"\n+  [(set (cc0)\n+\t(match_operand:DF 0 \"register_operand\" \"a\"))]\n+  \"\"\n+  \"tstd\")\n+\n+\n+\n+; movstrhi tahoe instruction does not load registers by itself like\n+; the vax counterpart does.  registers 0-2 must be primed by hand.\n+; we have loaded the registers in the order: dst, src, count.\n+\n+(define_insn \"movstrhi\"\n+  [(set (match_operand:BLK 0 \"general_operand\" \"p\")\n+\t (match_operand:BLK 1 \"general_operand\" \"p\"))\n+   (use (match_operand:HI 2 \"general_operand\" \"g\"))\n+   (clobber (reg:SI 0))\n+   (clobber (reg:SI 1))\n+   (clobber (reg:SI 2))]\n+  \"\"\n+  \"movab %0,r1\\;movab %1,r0\\;movl %2,r2\\;movblk\")\n+\n+\n+; floatsisf2 on tahoe converts the long from reg/mem into the fpp\n+; accumulator.  There are no hi and qi counterparts.  Flags are not\n+; set correctly here.\n+\n+(define_insn \"floatsisf2\"\n+  [(set (match_operand:SF 0 \"register_operand\" \"=a\")\n+\t(float:SF (match_operand:SI 1 \"general_operand\" \"g\")))]\n+  \"\"\n+  \"*\n+{\n+  CC_STATUS_INIT;\n+  return \\\"cvlf %1\\\";\n+}\")\n+\n+\n+; floatsidf2 on tahoe converts the long from reg/mem into the fpp\n+; accumulator.  There are no hi and qi counterparts.  Flags are not\n+; set correctly here.\n+\n+(define_insn \"floatsidf2\"\n+  [(set (match_operand:DF 0 \"register_operand\" \"=a\")\n+\t(float:DF (match_operand:SI 1 \"general_operand\" \"g\")))]\n+  \"\"\n+  \"*\n+{\n+  CC_STATUS_INIT;\n+  return \\\"cvld %1\\\";\n+}\")\n+\n+\n+; fix_truncsfsi2 to convert a float to long, tahoe must have the float\n+; in the fpp accumulator.  Flags are not set here.\n+\n+(define_insn \"fix_truncsfsi2\"\n+  [(set (match_operand:SI 0 \"general_operand\" \"=g\")\n+\t(fix:SI (fix:SF (match_operand:SF 1 \"register_operand\" \"a\"))))]\n+  \"\"\n+  \"*\n+{\n+  CC_STATUS_INIT;\n+  return \\\"cvfl %0\\\";\n+}\")\n+\n+\n+; fix_truncsfsi2 to convert a double to long, tahoe must have the double\n+; in the fpp accumulator.  Flags are not set here.\n+\n+(define_insn \"fix_truncdfsi2\"\n+  [(set (match_operand:SI 0 \"general_operand\" \"=g\")\n+\t(fix:SI (fix:DF (match_operand:DF 1 \"register_operand\" \"a\"))))]\n+  \"\"\n+  \"*\n+{\n+  CC_STATUS_INIT;\n+  return \\\"cvdl %0\\\";\n+}\")\n+\n+\n+(define_insn \"truncsihi2\"\n+  [(set (match_operand:HI 0 \"general_operand\" \"=g\")\n+\t(truncate:HI (match_operand:SI 1 \"general_operand\" \"g\")))]\n+  \"\"\n+  \"cvtlw %1,%0\")\n+\n+\n+(define_insn \"truncsiqi2\"\n+  [(set (match_operand:QI 0 \"general_operand\" \"=g\")\n+\t(truncate:QI (match_operand:SI 1 \"general_operand\" \"g\")))]\n+  \"\"\n+  \"cvtlb %1,%0\")\n+\n+\n+(define_insn \"trunchiqi2\"\n+  [(set (match_operand:QI 0 \"general_operand\" \"=g\")\n+\t(truncate:QI (match_operand:HI 1 \"general_operand\" \"g\")))]\n+  \"\"\n+  \"cvtwb %1,%0\")\n+\n+\n+; The fpp related instructions don't set flags, so ignore them\n+; after this instruction.\n+\n+(define_insn \"truncdfsf2\"\n+  [(set (match_operand:SF 0 \"register_operand\" \"=a\")\n+\t(float_truncate:SF (match_operand:DF 1 \"register_operand\" \"0\")))]\n+  \"\"\n+  \"*\n+{\n+  CC_STATUS_INIT;\n+  return \\\"cvdf\\\";\n+}\")\n+\n+\n+; This monster is to cover for the Tahoe's nasty habit of not extending\n+; a number if the source is in a register.  (It just moves it!) Case 0 is\n+; a normal extend from memory.  Case 1 does the extension from the top of\n+; the stack.  Extension from the stack doesn't set the flags right since\n+; the moval changes them.\n+\n+(define_insn \"extendhisi2\"\n+  [(set (match_operand:SI 0 \"general_operand\" \"=g,?=g\")\n+\t(sign_extend:SI (match_operand:HI 1 \"nonimmediate_operand\" \"m,r\")))]\n+  \"\"\n+  \"*\n+{\n+  switch (which_alternative)\n+    {\n+    case 0:\n+      return \\\"cvtwl %1,%0\\\";\n+    case 1:\n+      if (push_operand (operands[0], SImode))\n+\treturn \\\"pushl %1\\;cvtwl 2(sp),(sp)\\\";\n+      else\n+\t{\n+          CC_STATUS_INIT;\n+\t  return \\\"pushl %1\\;cvtwl 2(sp),%0\\;moval 4(sp),sp\\\";\n+\t}\n+    }\n+}\")\n+\n+; This monster is to cover for the Tahoe's nasty habit of not extending\n+; a number if the source is in a register.  (It just moves it!) Case 0 is\n+; a normal extend from memory.  Case 1 does the extension from the top of\n+; the stack.  Extension from the stack doesn't set the flags right since\n+; the moval changes them.\n+\n+(define_insn \"extendqisi2\"\n+  [(set (match_operand:SI 0 \"general_operand\" \"=g,?=g\")\n+\t(sign_extend:SI (match_operand:QI 1 \"nonimmediate_operand\" \"m,r\")))]\n+  \"\"\n+  \"*\n+{\n+  switch (which_alternative)\n+    {\n+    case 0:\n+      return \\\"cvtbl %1,%0\\\";\n+    case 1:\n+      if (push_operand (operands[0], SImode))\n+\treturn \\\"pushl %1\\;cvtbl 3(sp),(sp)\\\";\n+      else\n+\t{\n+\t  CC_STATUS_INIT;\n+\t  return \\\"pushl %1\\;cvtbl 3(sp),%0\\;moval 4(sp),sp\\\";\n+\t}\n+    }\n+}\")\n+\n+\n+; This monster is to cover for the Tahoe's nasty habit of not extending\n+; a number if the source is in a register.  (It just moves it!) Case 0 is\n+; a normal extend from memory.  Case 1 does the extension from the top of\n+; the stack.  Extension from the stack doesn't set the flags right since\n+; the moval changes them.\n+\n+(define_insn \"extendqihi2\"\n+  [(set (match_operand:HI 0 \"general_operand\" \"=g,?=g\")\n+\t(sign_extend:HI (match_operand:QI 1 \"nonimmediate_operand\" \"m,r\")))]\n+  \"\"\n+  \"*\n+{\n+  switch (which_alternative)\n+    {\n+    case 0:\n+      return \\\"cvtbw %1,%0\\\";\n+    case 1:\n+      if (push_operand (operands[0], SImode))\n+\treturn \\\"pushl %1\\;cvtbw 3(sp),(sp)\\\";\n+      else\n+\t{\n+\t  CC_STATUS_INIT;\n+\t  return \\\"pushl %1\\;cvtbw 3(sp),%0\\;moval 4(sp),sp\\\";\n+\t}\n+     }\n+}\")\n+\n+\n+; extendsfdf2 tahoe uses the fpp accumulator to do the extension.\n+; It takes a float and loads it up directly as a double.\n+\n+(define_insn \"extendsfdf2\"\n+  [(set (match_operand:DF 0 \"register_operand\" \"=a\")\n+\t(float_extend:DF (match_operand:SF 1 \"general_operand\" \"g\")))]\n+  \"\"\n+  \"*\n+{\n+  CC_STATUS_INIT;\n+  return \\\"ldfd %1\\\";\n+}\")\n+\n+\n+; movz works fine from memory but not from register for the same reasons\n+; the cvt instructions don't work right.  So we use the normal instruction\n+; from memory and we use an and to simulate it from register.  This is faster\n+; than pulling it off the stack.\n+\n+\n+(define_insn \"zero_extendhisi2\"\n+  [(set (match_operand:SI 0 \"general_operand\" \"=g,?=g\")\n+\t(zero_extend:SI (match_operand:HI 1 \"nonimmediate_operand\" \"m,r\")))]\n+  \"\"\n+  \"*\n+{\n+  switch (which_alternative)\n+    {\n+    case 0: return \\\"movzwl %1,%0\\\";\n+    case 1: return \\\"andl3 $0xffff,%1,%0\\\";\n+    }\n+}\")\n+\n+; movz works fine from memory but not from register for the same reasons\n+; the cvt instructions don't work right.  So we use the normal instruction\n+; from memory and we use an and to simulate it from register.  This is faster\n+; than pulling it off the stack.\n+\n+(define_insn \"zero_extendqihi2\"\n+  [(set (match_operand:HI 0 \"general_operand\" \"=g,?=g\")\n+\t(zero_extend:HI (match_operand:QI 1 \"nonimmediate_operand\" \"m,r\")))]\n+  \"\"\n+  \"*\n+{\n+  switch (which_alternative)\n+    {\n+    case 0: return \\\"movzbw %1,%0\\\";\n+    case 1: return \\\"andw3 $0xff,%1,%0\\\";\n+    }\n+}\")\n+\n+\n+; movz works fine from memory but not from register for the same reasons\n+; the cvt instructions don't work right.  So we use the normal instruction\n+; from memory and we use an and to simulate it from register.  This is faster\n+; than pulling it off the stack.\n+\n+(define_insn \"zero_extendqisi2\"\n+  [(set (match_operand:SI 0 \"general_operand\" \"=g,?=g\")\n+\t(zero_extend:SI (match_operand:QI 1 \"nonimmediate_operand\" \"m,r\")))]\n+  \"\"\n+  \"*\n+{\n+  switch (which_alternative)\n+    {\n+    case 0: return \\\"movzbl %1,%0\\\";\n+    case 1: return \\\"andl3 $0xff,%1,%0\\\";\n+    }\n+}\")\n+\n+\n+(define_insn \"beq\"\n+  [(set (pc)\n+\t(if_then_else (eq (cc0)\n+\t\t\t  (const_int 0))\n+\t\t      (label_ref (match_operand 0 \"\" \"\"))\n+\t\t      (pc)))]\n+  \"\"\n+  \"jeql %l0\")\n+\n+\n+(define_insn \"bne\"\n+  [(set (pc)\n+\t(if_then_else (ne (cc0)\n+\t\t\t  (const_int 0))\n+\t\t      (label_ref (match_operand 0 \"\" \"\"))\n+\t\t      (pc)))]\n+  \"\"\n+  \"jneq %l0\")\n+\n+\n+(define_insn \"bgt\"\n+  [(set (pc)\n+\t(if_then_else (gt (cc0)\n+\t\t\t  (const_int 0))\n+\t\t      (label_ref (match_operand 0 \"\" \"\"))\n+\t\t      (pc)))]\n+  \"\"\n+  \"jgtr %l0\")\n+\n+\n+(define_insn \"bgtu\"\n+  [(set (pc)\n+\t(if_then_else (gtu (cc0)\n+\t\t\t   (const_int 0))\n+\t\t      (label_ref (match_operand 0 \"\" \"\"))\n+\t\t      (pc)))]\n+  \"\"\n+  \"jgtru %l0\")\n+\n+\n+(define_insn \"blt\"\n+  [(set (pc)\n+\t(if_then_else (lt (cc0)\n+\t\t\t  (const_int 0))\n+\t\t      (label_ref (match_operand 0 \"\" \"\"))\n+\t\t      (pc)))]\n+  \"\"\n+  \"jlss %l0\")\n+\n+\n+(define_insn \"bltu\"\n+  [(set (pc)\n+\t(if_then_else (ltu (cc0)\n+\t\t\t   (const_int 0))\n+\t\t      (label_ref (match_operand 0 \"\" \"\"))\n+\t\t      (pc)))]\n+  \"\"\n+  \"jlssu %l0\")\n+\n+\n+(define_insn \"bge\"\n+  [(set (pc)\n+\t(if_then_else (ge (cc0)\n+\t\t\t  (const_int 0))\n+\t\t      (label_ref (match_operand 0 \"\" \"\"))\n+\t\t      (pc)))]\n+  \"\"\n+  \"jgeq %l0\")\n+\n+\n+(define_insn \"bgeu\"\n+  [(set (pc)\n+\t(if_then_else (geu (cc0)\n+\t\t\t   (const_int 0))\n+\t\t      (label_ref (match_operand 0 \"\" \"\"))\n+\t\t      (pc)))]\n+  \"\"\n+  \"jgequ %l0\")\n+\n+\n+(define_insn \"ble\"\n+  [(set (pc)\n+\t(if_then_else (le (cc0)\n+\t\t\t  (const_int 0))\n+\t\t      (label_ref (match_operand 0 \"\" \"\"))\n+\t\t      (pc)))]\n+  \"\"\n+  \"jleq %l0\")\n+\n+\n+(define_insn \"bleu\"\n+  [(set (pc)\n+\t(if_then_else (leu (cc0)\n+\t\t\t   (const_int 0))\n+\t\t      (label_ref (match_operand 0 \"\" \"\"))\n+\t\t      (pc)))]\n+  \"\"\n+  \"jlequ %l0\")\n+\n+\n+; gcc does not account for register mask/argc longword.  Thus the number\n+; for the call = number bytes for args + 4\n+\n+(define_insn \"call\"\n+  [(call (match_operand:QI 0 \"memory_operand\" \"m\")\n+\t (match_operand:QI 1 \"general_operand\" \"g\"))]\n+  \"\"\n+  \"*\n+{\n+  operands[1] = gen_rtx (CONST_INT, VOIDmode, (INTVAL (operands[1]) + 4));\n+  if (GET_CODE(operands[0]) == MEM\n+      && CONSTANT_ADDRESS_P (XEXP(operands[0], 0))\n+      && INTVAL (operands[1]) < 64)\n+    return \\\"callf %1,%0\\\"; /* this is much faster */   \n+  return \\\"calls %1,%0\\\";\n+}\")\n+\n+; gcc does not account for register mask/argc longword.  Thus the number\n+; for the call = number bytes for args + 4\n+\n+(define_insn \"call_value\"\n+  [(set (match_operand 0 \"\" \"g\")\n+\t(call (match_operand:QI 1 \"memory_operand\" \"m\")\n+\t      (match_operand:QI 2 \"general_operand\" \"g\")))]\n+  \"\"\n+  \"*\n+{\n+  operands[2] = gen_rtx (CONST_INT, VOIDmode, (INTVAL (operands[2]) + 4));\n+  if (GET_CODE(operands[1]) == MEM\n+      && CONSTANT_ADDRESS_P (XEXP(operands[1], 0))\n+      && INTVAL (operands[2]) < 64)\n+    return \\\"callf %2,%1\\\"; /* this is much faster */   \n+  return \\\"calls %2,%1\\\";\n+}\")\n+\n+\n+(define_insn \"return\"\n+  [(return)]\n+  \"\"\n+  \"ret\")\n+\n+(define_insn \"nop\"\n+  [(const_int 0)]\n+  \"\"\n+  \"nop\")\n+\n+; casesi this code extracted from the vax code.  The instructions are\n+; very similar.  Tahoe requires that the table be word aligned.  GCC\n+; places the table immediately after, thus the alignment directive.\n+\n+(define_insn \"casesi\"\n+  [(set (pc)\n+\t(if_then_else (le (minus:SI (match_operand:SI 0 \"general_operand\" \"g\")\n+\t\t\t\t    (match_operand:SI 1 \"general_operand\" \"g\"))\n+\t\t\t  (match_operand:SI 2 \"general_operand\" \"g\"))\n+\t\t      (plus:SI (sign_extend:SI\n+\t\t\t\t(mem:HI (plus:SI (pc)\n+\t\t\t\t\t\t (minus:SI (match_dup 0)\n+\t\t\t\t\t\t\t   (match_dup 1)))))\n+\t\t\t       (label_ref:SI (match_operand 3 \"\" \"\")))\n+\t\t      (pc)))]\n+  \"\"\n+  \"casel %0,%1,%2\\;.align %@\")\n+\n+\n+(define_insn \"jump\"\n+  [(set (pc)\n+\t(label_ref (match_operand 0 \"\" \"\")))]\n+  \"\"\n+  \"jbr %l0\")\n+\n+\n+;; This is the list of all the non-standard insn patterns\n+\n+\n+; This is used to access the address of a byte.  This is similar to\n+; movqi, but the second operand had to be \"address_operand\" type, so\n+; it had to be an unnamed one.\n+\n+(define_insn \"\"\n+  [(set (match_operand:SI 0 \"general_operand\" \"=g\")\n+\t(match_operand:QI 1 \"address_operand\" \"p\"))]\n+  \"\"\n+  \"*\n+{\n+  if (push_operand (operands[0], SImode))\n+    return \\\"pushab %a1\\\";\n+  return \\\"movab %a1,%0\\\";\n+}\")\n+\n+; This is used to access the address of a word.  This is similar to\n+; movhi, but the second operand had to be \"address_operand\" type, so\n+; it had to be an unnamed one.\n+\n+(define_insn \"\"\n+  [(set (match_operand:SI 0 \"general_operand\" \"=g\")\n+\t(match_operand:HI 1 \"address_operand\" \"p\"))]\n+  \"\"\n+  \"*\n+{\n+  if (push_operand (operands[0], SImode))\n+    return \\\"pushaw %a1\\\";\n+  return \\\"movaw %a1,%0\\\";\n+}\")\n+\n+; This is used to access the address of a long.  This is similar to\n+; movsi, but the second operand had to be \"address_operand\" type, so\n+; it had to be an unnamed one.\n+\n+(define_insn \"\"\n+  [(set (match_operand:SI 0 \"general_operand\" \"=g\")\n+\t(match_operand:SI 1 \"address_operand\" \"p\"))]\n+  \"\"\n+  \"*\n+{\n+  if (push_operand (operands[0], SImode))\n+    return \\\"pushal %a1\\\";\n+  return \\\"moval %a1,%0\\\";\n+}\")\n+\n+\n+; bit test longword instruction, same as vax\n+\n+(define_insn \"\"\n+  [(set (cc0)\n+\t(and:SI (match_operand:SI 0 \"general_operand\" \"g\")\n+\t\t(match_operand:SI 1 \"general_operand\" \"g\")))]\n+  \"\"\n+  \"bitl %0,%1\")\n+\n+\n+; bit test word instructions, same as vax\n+\n+(define_insn \"\"\n+  [(set (cc0)\n+\t(and:HI (match_operand:HI 0 \"general_operand\" \"g\")\n+\t\t(match_operand:HI 1 \"general_operand\" \"g\")))]\n+  \"\"\n+  \"bitw %0,%1\")\n+\n+\n+; bit test instructions, same as vax\n+\n+(define_insn \"\"\n+  [(set (cc0)\n+\t(and:QI (match_operand:QI 0 \"general_operand\" \"g\")\n+\t\t(match_operand:QI 1 \"general_operand\" \"g\")))]\n+  \"\"\n+  \"bitb %0,%1\")\n+\n+\n+; bne counterpart.  in case gcc reverses the conditional.\n+\n+(define_insn \"\"\n+  [(set (pc)\n+\t(if_then_else (eq (cc0)\n+\t\t\t  (const_int 0))\n+\t\t      (pc)\n+\t\t      (label_ref (match_operand 0 \"\" \"\"))))]\n+  \"\"\n+  \"jneq %l0\")\n+\n+\n+; beq counterpart.  in case gcc reverses the conditional.\n+\n+(define_insn \"\"\n+  [(set (pc)\n+\t(if_then_else (ne (cc0)\n+\t\t\t  (const_int 0))\n+\t\t      (pc)\n+\t\t      (label_ref (match_operand 0 \"\" \"\"))))]\n+  \"\"\n+  \"jeql %l0\")\n+\n+\n+; ble counterpart.  in case gcc reverses the conditional.\n+\n+(define_insn \"\"\n+  [(set (pc)\n+\t(if_then_else (gt (cc0)\n+\t\t\t  (const_int 0))\n+\t\t      (pc)\n+\t\t      (label_ref (match_operand 0 \"\" \"\"))))]\n+  \"\"\n+  \"jleq %l0\")\n+\n+\n+; bleu counterpart.  in case gcc reverses the conditional.\n+\n+(define_insn \"\"\n+  [(set (pc)\n+\t(if_then_else (gtu (cc0)\n+\t\t\t   (const_int 0))\n+\t\t      (pc)\n+\t\t      (label_ref (match_operand 0 \"\" \"\"))))]\n+  \"\"\n+  \"jlequ %l0\")\n+\n+\n+; bge counterpart.  in case gcc reverses the conditional.\n+\n+(define_insn \"\"\n+  [(set (pc)\n+\t(if_then_else (lt (cc0)\n+\t\t\t  (const_int 0))\n+\t\t      (pc)\n+\t\t      (label_ref (match_operand 0 \"\" \"\"))))]\n+  \"\"\n+  \"jgeq %l0\")\n+\n+\n+; bgeu counterpart.  in case gcc reverses the conditional.\n+\n+(define_insn \"\"\n+  [(set (pc)\n+\t(if_then_else (ltu (cc0)\n+\t\t\t   (const_int 0))\n+\t\t      (pc)\n+\t\t      (label_ref (match_operand 0 \"\" \"\"))))]\n+  \"\"\n+  \"jgequ %l0\")\n+\n+\n+; blt counterpart.  in case gcc reverses the conditional.\n+\n+(define_insn \"\"\n+  [(set (pc)\n+\t(if_then_else (ge (cc0)\n+\t\t\t  (const_int 0))\n+\t\t      (pc)\n+\t\t      (label_ref (match_operand 0 \"\" \"\"))))]\n+  \"\"\n+  \"jlss %l0\")\n+\n+\n+; bltu counterpart.  in case gcc reverses the conditional.\n+\n+(define_insn \"\"\n+  [(set (pc)\n+\t(if_then_else (geu (cc0)\n+\t\t\t   (const_int 0))\n+\t\t      (pc)\n+\t\t      (label_ref (match_operand 0 \"\" \"\"))))]\n+  \"\"\n+  \"jlssu %l0\")\n+\n+\n+; bgt counterpart.  in case gcc reverses the conditional.\n+\n+(define_insn \"\"\n+  [(set (pc)\n+\t(if_then_else (le (cc0)\n+\t\t\t  (const_int 0))\n+\t\t      (pc)\n+\t\t      (label_ref (match_operand 0 \"\" \"\"))))]\n+  \"\"\n+  \"jgtr %l0\")\n+\n+\n+; bgtu counterpart.  in case gcc reverses the conditional.\n+\n+(define_insn \"\"\n+  [(set (pc)\n+\t(if_then_else (leu (cc0)\n+\t\t\t   (const_int 0))\n+\t\t      (pc)\n+\t\t      (label_ref (match_operand 0 \"\" \"\"))))]\n+  \"\"\n+  \"jgtru %l0\")\n+\n+\n+; casesi alternate form as found in vax code.  this form is to\n+; compensate for the table's offset being no distance (0 displacement)\n+\n+(define_insn \"\"\n+  [(set (pc)\n+\t(if_then_else (le (match_operand:SI 0 \"general_operand\" \"g\")\n+\t\t\t  (match_operand:SI 1 \"general_operand\" \"g\"))\n+\t\t      (plus:SI (sign_extend:SI\n+\t\t\t\t(mem:HI (plus:SI (pc)\n+\t\t\t\t\t\t (minus:SI (match_dup 0)\n+\t\t\t\t\t\t\t   (const_int 0)))))\n+\t\t\t       (label_ref:SI (match_operand 3 \"\" \"\")))\n+\t\t      (pc)))]\n+  \"\"\n+  \"casel %0,$0,%1\\;.align %@\")\n+\n+\n+; casesi alternate form as found in vax code.  another form to\n+; compensate for the table's offset being no distance (0 displacement)\n+\n+(define_insn \"\"\n+  [(set (pc)\n+\t(if_then_else (le (match_operand:SI 0 \"general_operand\" \"g\")\n+\t\t\t  (match_operand:SI 1 \"general_operand\" \"g\"))\n+\t\t      (plus:SI (sign_extend:SI\n+\t\t\t\t(mem:HI (plus:SI (pc)\n+\t\t\t\t\t\t (match_dup 0))))\n+\t\t\t       (label_ref:SI (match_operand 3 \"\" \"\")))\n+\t\t      (pc)))]\n+  \"\"\n+  \"casel %0,$0,%1 \\;.align %@\")\n+\n+(define_insn \"\"\n+  [(set (pc)\n+\t(if_then_else\n+\t (lt (plus:SI (match_operand:SI 0 \"general_operand\" \"+g\")\n+\t\t      (const_int 1))\n+\t     (match_operand:SI 1 \"general_operand\" \"g\"))\n+\t (label_ref (match_operand 2 \"\" \"\"))\n+\t (pc)))\n+   (set (match_dup 0)\n+\t(plus:SI (match_dup 0)\n+\t\t (const_int 1)))]\n+  \"\"\n+  \"aoblss %1,%0,%l2\")\n+\n+(define_insn \"\"\n+  [(set (pc)\n+\t(if_then_else\n+\t (le (plus:SI (match_operand:SI 0 \"general_operand\" \"+g\")\n+\t\t      (const_int 1))\n+\t     (match_operand:SI 1 \"general_operand\" \"g\"))\n+\t (label_ref (match_operand 2 \"\" \"\"))\n+\t (pc)))\n+   (set (match_dup 0)\n+\t(plus:SI (match_dup 0)\n+\t\t (const_int 1)))]\n+  \"\"\n+  \"aobleq %1,%0,%l2\")\n+\n+(define_insn \"\"\n+  [(set (pc)\n+\t(if_then_else\n+\t (ge (plus:SI (match_operand:SI 0 \"general_operand\" \"+g\")\n+\t\t      (const_int 1))\n+\t     (match_operand:SI 1 \"general_operand\" \"g\"))\n+\t (pc)\n+\t (label_ref (match_operand 2 \"\" \"\"))))\n+   (set (match_dup 0)\n+\t(plus:SI (match_dup 0)\n+\t\t (const_int 1)))]\n+  \"\"\n+  \"aoblss %1,%0,%l2\")\n+\n+(define_insn \"\"\n+  [(set (pc)\n+\t(if_then_else\n+\t (gt (plus:SI (match_operand:SI 0 \"general_operand\" \"+g\")\n+\t\t      (const_int 1))\n+\t     (match_operand:SI 1 \"general_operand\" \"g\"))\n+\t (pc)\n+\t (label_ref (match_operand 2 \"\" \"\"))))\n+   (set (match_dup 0)\n+\t(plus:SI (match_dup 0)\n+\t\t (const_int 1)))]\n+  \"\"\n+  \"aobleq %1,%0,%l2\")\n+\n+; bbs/bbc\n+\n+(define_insn \"\"\n+  [(set (pc)\n+\t(if_then_else\n+\t (ne (sign_extract:SI (match_operand:SI 0 \"nonimmediate_operand\" \"rm\")\n+\t\t\t      (const_int 1)\n+\t\t      (subreg:QI (match_operand:SI 1 \"general_operand\" \"g\") 0))\n+\t     (const_int 0))\n+\t (label_ref (match_operand 2 \"\" \"\"))\n+\t (pc)))]\n+  \"\"\n+  \"bbs %1,%0,%l2\")\n+\n+(define_insn \"\"\n+  [(set (pc)\n+\t(if_then_else\n+\t (eq (sign_extract:SI (match_operand:SI 0 \"nonimmediate_operand\" \"rm\")\n+\t\t\t      (const_int 1)\n+\t\t      (subreg:QI (match_operand:SI 1 \"general_operand\" \"g\") 0))\n+\t     (const_int 0))\n+\t (label_ref (match_operand 2 \"\" \"\"))\n+\t (pc)))]\n+  \"\"\n+  \"bbc %1,%0,%l2\")\n+\n+(define_insn \"\"\n+  [(set (pc)\n+\t(if_then_else\n+\t (ne (sign_extract:SI (match_operand:SI 0 \"nonimmediate_operand\" \"rm\")\n+\t\t\t      (const_int 1)\n+\t\t      (subreg:QI (match_operand:SI 1 \"general_operand\" \"g\") 0))\n+\t     (const_int 0))\n+\t (pc)\n+\t (label_ref (match_operand 2 \"\" \"\"))))]\n+  \"\"\n+  \"bbc %1,%0,%l2\")\n+\n+(define_insn \"\"\n+  [(set (pc)\n+\t(if_then_else\n+\t (eq (sign_extract:SI (match_operand:SI 0 \"nonimmediate_operand\" \"rm\")\n+\t\t\t      (const_int 1)\n+\t\t      (subreg:QI (match_operand:SI 1 \"general_operand\" \"g\") 0))\n+\t     (const_int 0))\n+\t (pc)\n+\t (label_ref (match_operand 2 \"\" \"\"))))]\n+  \"\"\n+  \"bbs %1,%0,%l2\")\n+\n+; if the shift count is a byte in a register we can use it as a long\n+\n+(define_insn \"\"\n+  [(set (pc)\n+\t(if_then_else\n+\t (ne (sign_extract:SI (match_operand:SI 0 \"nonimmediate_operand\" \"rm\")\n+\t\t\t      (const_int 1)\n+\t\t\t      (match_operand:QI 1 \"register_operand\" \"r\"))\n+\t     (const_int 0))\n+\t (label_ref (match_operand 2 \"\" \"\"))\n+\t (pc)))]\n+  \"\"\n+  \"bbs %1,%0,%l2\")\n+\n+(define_insn \"\"\n+  [(set (pc)\n+\t(if_then_else\n+\t (eq (sign_extract:SI (match_operand:SI 0 \"nonimmediate_operand\" \"rm\")\n+\t\t\t      (const_int 1)\n+\t\t\t      (match_operand:QI 1 \"register_operand\" \"r\"))\n+\t     (const_int 0))\n+\t (label_ref (match_operand 2 \"\" \"\"))\n+\t (pc)))]\n+  \"\"\n+  \"bbc %1,%0,%l2\")\n+\n+(define_insn \"\"\n+  [(set (pc)\n+\t(if_then_else\n+\t (ne (sign_extract:SI (match_operand:SI 0 \"nonimmediate_operand\" \"rm\")\n+\t\t\t      (const_int 1)\n+\t\t\t      (match_operand:QI 1 \"register_operand\" \"r\"))\n+\t     (const_int 0))\n+\t (pc)\n+\t (label_ref (match_operand 2 \"\" \"\"))))]\n+  \"\"\n+  \"bbc %1,%0,%l2\")\n+\n+(define_insn \"\"\n+  [(set (pc)\n+\t(if_then_else\n+\t (eq (sign_extract:SI (match_operand:SI 0 \"nonimmediate_operand\" \"rm\")\n+\t\t\t      (const_int 1)\n+\t\t\t      (match_operand:QI 1 \"register_operand\" \"r\"))\n+\t     (const_int 0))\n+\t (pc)\n+\t (label_ref (match_operand 2 \"\" \"\"))))]\n+  \"\"\n+  \"bbs %1,%0,%l2\")\n+\n+; special case for 1 << constant.  We don't do these because they are slower\n+; than the bitl instruction\n+\n+;(define_insn \"\"\n+;  [(set (pc)\n+;\t(if_then_else\n+;\t (ne (and:SI (match_operand:SI 0 \"nonimmediate_operand\" \"%rm\")\n+;\t\t     (match_operand:SI 1 \"immediate_operand\" \"i\"))\n+;\t     (const_int 0))\n+;\t (label_ref (match_operand 2 \"\" \"\"))\n+;\t (pc)))]\n+;  \"GET_CODE (operands[1]) == CONST_INT\n+;   && exact_log2 (INTVAL (operands[1])) >= 0\"\n+;  \"*\n+;{\n+;  operands[1]\n+;    = gen_rtx (CONST_INT, VOIDmode, exact_log2 (INTVAL (operands[1])));\n+;  return \\\"bbs %1,%0,%l2\\\";\n+;}\")\n+;\n+;(define_insn \"\"\n+;  [(set (pc)\n+;\t(if_then_else\n+;\t (eq (and:SI (match_operand:SI 0 \"nonimmediate_operand\" \"%rm\")\n+;\t\t     (match_operand:SI 1 \"immediate_operand\" \"i\"))\n+;\t     (const_int 0))\n+;\t (label_ref (match_operand 2 \"\" \"\"))\n+;\t (pc)))]\n+;  \"GET_CODE (operands[1]) == CONST_INT\n+;   && exact_log2 (INTVAL (operands[1])) >= 0\"\n+;  \"*\n+;{\n+;  operands[1]\n+;    = gen_rtx (CONST_INT, VOIDmode, exact_log2 (INTVAL (operands[1])));\n+;  return \\\"bbc %1,%0,%l2\\\";\n+;}\")\n+;\n+;(define_insn \"\"\n+;  [(set (pc)\n+;\t(if_then_else\n+;\t (ne (and:SI (match_operand:SI 0 \"nonimmediate_operand\" \"%rm\")\n+;\t\t     (match_operand:SI 1 \"immediate_operand\" \"i\"))\n+;\t     (const_int 0))\n+;\t (pc)\n+;\t (label_ref (match_operand 2 \"\" \"\"))))]\n+;  \"GET_CODE (operands[1]) == CONST_INT\n+;   && exact_log2 (INTVAL (operands[1])) >= 0\"\n+;  \"*\n+;{\n+;  operands[1]\n+;    = gen_rtx (CONST_INT, VOIDmode, exact_log2 (INTVAL (operands[1])));\n+;  return \\\"bbc %1,%0,%l2\\\";\n+;}\")\n+;\n+;(define_insn \"\"\n+;  [(set (pc)\n+;\t(if_then_else\n+;\t (eq (and:SI (match_operand:SI 0 \"nonimmediate_operand\" \"%rm\")\n+;\t\t     (match_operand:SI 1 \"immediate_operand\" \"i\"))\n+;\t     (const_int 0))\n+;\t (pc)\n+;\t (label_ref (match_operand 2 \"\" \"\"))))]\n+;  \"GET_CODE (operands[1]) == CONST_INT\n+;   && exact_log2 (INTVAL (operands[1])) >= 0\"\n+;  \"*\n+;{\n+;  operands[1]\n+;    = gen_rtx (CONST_INT, VOIDmode, exact_log2 (INTVAL (operands[1])));\n+;  return \\\"bbs %1,%0,%l2\\\";\n+;}\")\n+\n+\f\n+;;- Local variables:\n+;;- mode:emacs-lisp\n+;;- comment-start: \";;- \"\n+;;- eval: (set-syntax-table (copy-sequence (syntax-table)))\n+;;- eval: (modify-syntax-entry ?[ \"(]\")\n+;;- eval: (modify-syntax-entry ?] \")[\")\n+;;- eval: (modify-syntax-entry ?{ \"(}\")\n+;;- eval: (modify-syntax-entry ?} \"){\")\n+;;- End:"}]}