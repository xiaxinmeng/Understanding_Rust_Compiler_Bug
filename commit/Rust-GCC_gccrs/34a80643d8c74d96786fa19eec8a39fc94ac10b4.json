{"sha": "34a80643d8c74d96786fa19eec8a39fc94ac10b4", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzRhODA2NDNkOGM3NGQ5Njc4NmZhMTllZWM4YTM5ZmM5NGFjMTBiNA==", "commit": {"author": {"name": "J\"orn Rennecke", "email": "joern.rennecke@superh.com", "date": "2002-07-03T09:49:46Z"}, "committer": {"name": "Joern Rennecke", "email": "amylaar@gcc.gnu.org", "date": "2002-07-03T09:49:46Z"}, "message": "optabs.c (expand_vector_binop): Don't store using a SUBREG smaller than UNITS_PER_WORD...\n\ngcc:\n\t* optabs.c (expand_vector_binop): Don't store using a SUBREG smaller\n\tthan UNITS_PER_WORD, unless this is little endian and the first unit\n\tin this word.  Let extract_bit_field decide how to load an element.\n\tForce arguments to matching mode.\n\t(expand_vector_unop): Likewise.\n\n\t* simplify-rtx.c (simplify_subreg): Don't assume that all vectors\n\tconsist of word_mode elements.\n\t* c-typeck.c (build_binary_op): Allow vector types for BIT_AND_EXPR,\n\tBIT_ANDTC_EXPR, BIT_IOR_EXPR and BIT_XOR_EXPR.\n\t(build_unary_op): Allow vector types for BIT_NOT_EPR.\n\t* emit-rtl.c (gen_lowpart_common): Use simplify_gen_subreg for\n\tCONST_VECTOR.\n\t* optabs.c (expand_vector_binop): Try to perform operation in\n\tsmaller vector modes with same inner size.  Add handling of AND, IOR\n\tand XOR.  Reject expansion to inner-mode sized scalars when using\n\tOPTAB_DIRECT.  Use simplify_gen_subreg on constants.\n\t(expand_vector_unop): Try to perform operation in smaller vector\n\tmodes with same inner size.  Add handling of one's complement.\n\tWhen there is no vector negate operation, try a vector subtract\n\toperation.  Use simplify_gen_subreg on constants.\n\t* simplify-rtx.c (simplify_subreg): Add capability to convert vector\n\tconstants into smaller vectors with same inner mode, and to\n\tinteger CONST_DOUBLEs.\n\ngcc/testsuite:\n\t* gcc.c-torture/execute/simd-1.c (main): Also test &, |, ^, ~.\n\t* gcc.c-torture/execute/simd-2.c (main): Likewise.\n\nFrom-SVN: r55209", "tree": {"sha": "4e697d4885e1475c42eeedf76c38e9b4ccdff584", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/4e697d4885e1475c42eeedf76c38e9b4ccdff584"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/34a80643d8c74d96786fa19eec8a39fc94ac10b4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/34a80643d8c74d96786fa19eec8a39fc94ac10b4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/34a80643d8c74d96786fa19eec8a39fc94ac10b4", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/34a80643d8c74d96786fa19eec8a39fc94ac10b4/comments", "author": null, "committer": null, "parents": [{"sha": "032b2b29901082316175de7c7edb51c927ab06aa", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/032b2b29901082316175de7c7edb51c927ab06aa", "html_url": "https://github.com/Rust-GCC/gccrs/commit/032b2b29901082316175de7c7edb51c927ab06aa"}], "stats": {"total": 303, "additions": 259, "deletions": 44}, "files": [{"sha": "9218d3fefb5cf2ff83a82aceecbbc4421cd0ef83", "filename": "gcc/ChangeLog", "status": "modified", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/34a80643d8c74d96786fa19eec8a39fc94ac10b4/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/34a80643d8c74d96786fa19eec8a39fc94ac10b4/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=34a80643d8c74d96786fa19eec8a39fc94ac10b4", "patch": "@@ -1,3 +1,30 @@\n+Wed Jul  3 10:24:16 2002  J\"orn Rennecke <joern.rennecke@superh.com>\n+\n+\t* optabs.c (expand_vector_binop): Don't store using a SUBREG smaller\n+\tthan UNITS_PER_WORD, unless this is little endian and the first unit\n+\tin this word.  Let extract_bit_field decide how to load an element.\n+\tForce arguments to matching mode.\n+\t(expand_vector_unop): Likewise.\n+\n+\t* simplify-rtx.c (simplify_subreg): Don't assume that all vectors\n+\tconsist of word_mode elements.\n+\t* c-typeck.c (build_binary_op): Allow vector types for BIT_AND_EXPR,\n+\tBIT_ANDTC_EXPR, BIT_IOR_EXPR and BIT_XOR_EXPR.\n+\t(build_unary_op): Allow vector types for BIT_NOT_EPR.\n+\t* emit-rtl.c (gen_lowpart_common): Use simplify_gen_subreg for\n+\tCONST_VECTOR.\n+\t* optabs.c (expand_vector_binop): Try to perform operation in\n+\tsmaller vector modes with same inner size.  Add handling of AND, IOR\n+\tand XOR.  Reject expansion to inner-mode sized scalars when using\n+\tOPTAB_DIRECT.  Use simplify_gen_subreg on constants.\n+\t(expand_vector_unop): Try to perform operation in smaller vector\n+\tmodes with same inner size.  Add handling of one's complement.\n+\tWhen there is no vector negate operation, try a vector subtract\n+\toperation.  Use simplify_gen_subreg on constants.\n+\t* simplify-rtx.c (simplify_subreg): Add capability to convert vector\n+\tconstants into smaller vectors with same inner mode, and to\n+\tinteger CONST_DOUBLEs.\n+\n 2002-07-02  Kaveh R. Ghazi  <ghazi@caip.rutgers.edu>\n \n \t* c-parse.in (parsing_iso_function_signature): New variable."}, {"sha": "0a70363f406a731ef07b91ba4407b2ea918e61e2", "filename": "gcc/c-typeck.c", "status": "modified", "additions": 9, "deletions": 4, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/34a80643d8c74d96786fa19eec8a39fc94ac10b4/gcc%2Fc-typeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/34a80643d8c74d96786fa19eec8a39fc94ac10b4/gcc%2Fc-typeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-typeck.c?ref=34a80643d8c74d96786fa19eec8a39fc94ac10b4", "patch": "@@ -2071,6 +2071,8 @@ build_binary_op (code, orig_op0, orig_op1, convert_p)\n     case BIT_XOR_EXPR:\n       if (code0 == INTEGER_TYPE && code1 == INTEGER_TYPE)\n \tshorten = -1;\n+      else if (code0 == VECTOR_TYPE && code1 == VECTOR_TYPE)\n+\tcommon = 1;\n       break;\n \n     case TRUNC_MOD_EXPR:\n@@ -2778,21 +2780,24 @@ build_unary_op (code, xarg, flag)\n       break;\n \n     case BIT_NOT_EXPR:\n-      if (typecode == COMPLEX_TYPE)\n+      if (typecode == INTEGER_TYPE || typecode == VECTOR_TYPE)\n+\t{\n+\t  if (!noconvert)\n+\t    arg = default_conversion (arg);\n+\t}\n+      else if (typecode == COMPLEX_TYPE)\n \t{\n \t  code = CONJ_EXPR;\n \t  if (pedantic)\n \t    pedwarn (\"ISO C does not support `~' for complex conjugation\");\n \t  if (!noconvert)\n \t    arg = default_conversion (arg);\n \t}\n-      else if (typecode != INTEGER_TYPE)\n+      else\n \t{\n \t  error (\"wrong type argument to bit-complement\");\n \t  return error_mark_node;\n \t}\n-      else if (!noconvert)\n-\targ = default_conversion (arg);\n       break;\n \n     case ABS_EXPR:"}, {"sha": "0ee4f117f352f888c20f46db77d8b4033beb4143", "filename": "gcc/emit-rtl.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/34a80643d8c74d96786fa19eec8a39fc94ac10b4/gcc%2Femit-rtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/34a80643d8c74d96786fa19eec8a39fc94ac10b4/gcc%2Femit-rtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Femit-rtl.c?ref=34a80643d8c74d96786fa19eec8a39fc94ac10b4", "patch": "@@ -991,7 +991,7 @@ gen_lowpart_common (mode, x)\n \treturn gen_rtx_fmt_e (GET_CODE (x), mode, XEXP (x, 0));\n     }\n   else if (GET_CODE (x) == SUBREG || GET_CODE (x) == REG\n-\t   || GET_CODE (x) == CONCAT)\n+\t   || GET_CODE (x) == CONCAT || GET_CODE (x) == CONST_VECTOR)\n     return simplify_gen_subreg (mode, x, GET_MODE (x), offset);\n   /* If X is a CONST_INT or a CONST_DOUBLE, extract the appropriate bits\n      from the low-order part of the constant.  */"}, {"sha": "c9230618e45a8a686cd369d74dbca77a20b862d2", "filename": "gcc/optabs.c", "status": "modified", "additions": 132, "deletions": 30, "changes": 162, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/34a80643d8c74d96786fa19eec8a39fc94ac10b4/gcc%2Foptabs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/34a80643d8c74d96786fa19eec8a39fc94ac10b4/gcc%2Foptabs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Foptabs.c?ref=34a80643d8c74d96786fa19eec8a39fc94ac10b4", "patch": "@@ -1923,40 +1923,86 @@ expand_vector_binop (mode, binoptab, op0, op1, target, unsignedp, methods)\n      int unsignedp;\n      enum optab_methods methods;\n {\n-  enum machine_mode submode;\n-  int elts, subsize, i;\n+  enum machine_mode submode, tmode;\n+  int size, elts, subsize, subbitsize, i;\n   rtx t, a, b, res, seq;\n   enum mode_class class;\n \n   class = GET_MODE_CLASS (mode);\n \n+  size =  GET_MODE_SIZE (mode);\n   submode = GET_MODE_INNER (mode);\n-  subsize = GET_MODE_UNIT_SIZE (mode);\n-  elts = GET_MODE_NUNITS (mode);\n-\n-  if (!target)\n-    target = gen_reg_rtx (mode);\n-\n-  start_sequence ();\n \n-  /* FIXME: Optimally, we should try to do this in narrower vector\n-     modes if available.  E.g. When trying V8SI, try V4SI, else\n-     V2SI, else decay into SI.  */\n+  /* Search for the widest vector mode with the same inner mode that is\n+     still narrower than MODE and that allows to open-code this operator.\n+     Note, if we find such a mode and the handler later decides it can't\n+     do the expansion, we'll be called recursively with the narrower mode.  */\n+  for (tmode = GET_CLASS_NARROWEST_MODE (class);\n+       GET_MODE_SIZE (tmode) < GET_MODE_SIZE (mode);\n+       tmode = GET_MODE_WIDER_MODE (tmode))\n+    {\n+      if (GET_MODE_INNER (tmode) == GET_MODE_INNER (mode)\n+\t  && binoptab->handlers[(int) tmode].insn_code != CODE_FOR_nothing)\n+\tsubmode = tmode;\n+    }\n \n   switch (binoptab->code)\n     {\n+    case AND:\n+    case IOR:\n+    case XOR:\n+      tmode = int_mode_for_mode (mode);\n+      if (tmode != BLKmode)\n+\tsubmode = tmode;\n     case PLUS:\n     case MINUS:\n     case MULT:\n     case DIV:\n+      subsize = GET_MODE_SIZE (submode);\n+      subbitsize = GET_MODE_BITSIZE (submode);\n+      elts = size / subsize;\n+\n+      /* If METHODS is OPTAB_DIRECT, we don't insist on the exact mode,\n+\t but that we operate on more than one element at a time.  */\n+      if (subsize == GET_MODE_UNIT_SIZE (mode) && methods == OPTAB_DIRECT)\n+\treturn 0;\n+\n+      start_sequence ();\n+\n+      /* Errors can leave us with a const0_rtx as operand.  */\n+      if (GET_MODE (op0) != mode)\n+\top0 = copy_to_mode_reg (mode, op0);\n+      if (GET_MODE (op1) != mode)\n+\top1 = copy_to_mode_reg (mode, op1);\n+\n+      if (!target)\n+\ttarget = gen_reg_rtx (mode);\n+\n       for (i = 0; i < elts; ++i)\n \t{\n-\t  t = simplify_gen_subreg (submode, target, mode,\n-\t\t\t\t   i * subsize);\n-\t  a = simplify_gen_subreg (submode, op0, mode,\n-\t\t\t\t   i * subsize);\n-\t  b = simplify_gen_subreg (submode, op1, mode,\n-\t\t\t\t   i * subsize);\n+\t  /* If this is part of a register, and not the first item in the\n+\t     word, we can't store using a SUBREG - that would clobber\n+\t     previous results.\n+\t     And storing with a SUBREG is only possible for the least\n+\t     significant part, hence we can't do it for big endian\n+\t     (unless we want to permute the evaluation order.  */\n+\t  if (GET_CODE (target) == REG\n+\t      && (BYTES_BIG_ENDIAN\n+\t\t  ? subsize < UNITS_PER_WORD\n+\t\t  : ((i * subsize) % UNITS_PER_WORD) != 0))\n+\t    t = NULL_RTX;\n+\t  else\n+\t    t = simplify_gen_subreg (submode, target, mode, i * subsize);\n+\t  if (CONSTANT_P (op0))\n+\t    a = simplify_gen_subreg (submode, op0, mode, i * subsize);\n+\t  else\n+\t    a = extract_bit_field (op0, subbitsize, i * subbitsize, unsignedp,\n+\t\t\t\t   NULL_RTX, submode, submode, size);\n+\t  if (CONSTANT_P (op1))\n+\t    b = simplify_gen_subreg (submode, op1, mode, i * subsize);\n+\t  else\n+\t    b = extract_bit_field (op1, subbitsize, i * subbitsize, unsignedp,\n+\t\t\t\t   NULL_RTX, submode, submode, size);\n \n \t  if (binoptab->code == DIV)\n \t    {\n@@ -1974,7 +2020,11 @@ expand_vector_binop (mode, binoptab, op0, op1, target, unsignedp, methods)\n \t  if (res == 0)\n \t    break;\n \n-\t  emit_move_insn (t, res);\n+\t  if (t)\n+\t    emit_move_insn (t, res);\n+\t  else\n+\t    store_bit_field (target, subbitsize, i * subbitsize, submode, res,\n+\t\t\t     size);\n \t}\n       break;\n \n@@ -1999,31 +2049,83 @@ expand_vector_unop (mode, unoptab, op0, target, unsignedp)\n      rtx target;\n      int unsignedp;\n {\n-  enum machine_mode submode;\n-  int elts, subsize, i;\n+  enum machine_mode submode, tmode;\n+  int size, elts, subsize, subbitsize, i;\n   rtx t, a, res, seq;\n \n+  size =  GET_MODE_SIZE (mode);\n   submode = GET_MODE_INNER (mode);\n-  subsize = GET_MODE_UNIT_SIZE (mode);\n-  elts = GET_MODE_NUNITS (mode);\n+\n+  /* Search for the widest vector mode with the same inner mode that is\n+     still narrower than MODE and that allows to open-code this operator.\n+     Note, if we find such a mode and the handler later decides it can't\n+     do the expansion, we'll be called recursively with the narrower mode.  */\n+  for (tmode = GET_CLASS_NARROWEST_MODE (GET_MODE_CLASS (mode));\n+       GET_MODE_SIZE (tmode) < GET_MODE_SIZE (mode);\n+       tmode = GET_MODE_WIDER_MODE (tmode))\n+    {\n+      if (GET_MODE_INNER (tmode) == GET_MODE_INNER (mode)\n+\t  && unoptab->handlers[(int) tmode].insn_code != CODE_FOR_nothing)\n+\tsubmode = tmode;\n+    }\n+  /* If there is no negate operation, try doing a subtract from zero.  */\n+  if (unoptab == neg_optab && GET_MODE_CLASS (submode) == MODE_INT)\n+    {    \n+      rtx temp;\n+      temp = expand_binop (mode, sub_optab, CONST0_RTX (mode), op0,\n+                           target, unsignedp, OPTAB_DIRECT);\n+      if (temp)\n+\treturn temp;\n+    }\n+\n+  if (unoptab == one_cmpl_optab)\n+    {\n+      tmode = int_mode_for_mode (mode);\n+      if (tmode != BLKmode)\n+\tsubmode = tmode;\n+    }\n+\n+  subsize = GET_MODE_SIZE (submode);\n+  subbitsize = GET_MODE_BITSIZE (submode);\n+  elts = size / subsize;\n+\n+  /* Errors can leave us with a const0_rtx as operand.  */\n+  if (GET_MODE (op0) != mode)\n+    op0 = copy_to_mode_reg (mode, op0);\n \n   if (!target)\n     target = gen_reg_rtx (mode);\n \n   start_sequence ();\n \n-  /* FIXME: Optimally, we should try to do this in narrower vector\n-     modes if available.  E.g. When trying V8SI, try V4SI, else\n-     V2SI, else decay into SI.  */\n-\n   for (i = 0; i < elts; ++i)\n     {\n-      t = simplify_gen_subreg (submode, target, mode, i * subsize);\n-      a = simplify_gen_subreg (submode, op0, mode, i * subsize);\n+      /* If this is part of a register, and not the first item in the\n+\t word, we can't store using a SUBREG - that would clobber\n+\t previous results.\n+\t And storing with a SUBREG is only possible for the least\n+\t significant part, hence we can't do it for big endian\n+\t (unless we want to permute the evaluation order.  */\n+      if (GET_CODE (target) == REG\n+\t  && (BYTES_BIG_ENDIAN\n+\t      ?  subsize < UNITS_PER_WORD\n+\t      : ((i * subsize) % UNITS_PER_WORD) != 0))\n+\tt = NULL_RTX;\n+      else\n+\tt = simplify_gen_subreg (submode, target, mode, i * subsize);\n+      if (CONSTANT_P (op0))\n+\ta = simplify_gen_subreg (submode, op0, mode, i * subsize);\n+      else\n+\ta = extract_bit_field (op0, subbitsize, i * subbitsize, unsignedp,\n+\t\t\t       t, submode, submode, size);\n \n       res = expand_unop (submode, unoptab, a, t, unsignedp);\n \n-      emit_move_insn (t, res);\n+      if (t)\n+\temit_move_insn (t, res);\n+      else\n+\tstore_bit_field (target, subbitsize, i * subbitsize, submode, res,\n+\t\t\t size);\n     }\n \n   seq = get_insns ();"}, {"sha": "63961dd5ada4c9a3155fcdb2110e967cdc788f15", "filename": "gcc/simplify-rtx.c", "status": "modified", "additions": 47, "deletions": 9, "changes": 56, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/34a80643d8c74d96786fa19eec8a39fc94ac10b4/gcc%2Fsimplify-rtx.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/34a80643d8c74d96786fa19eec8a39fc94ac10b4/gcc%2Fsimplify-rtx.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsimplify-rtx.c?ref=34a80643d8c74d96786fa19eec8a39fc94ac10b4", "patch": "@@ -2271,19 +2271,57 @@ simplify_subreg (outermode, op, innermode, byte)\n   /* Simplify subregs of vector constants.  */\n   if (GET_CODE (op) == CONST_VECTOR)\n     {\n-      int offset = byte / UNITS_PER_WORD;\n+      int elt_size = GET_MODE_SIZE (GET_MODE_INNER (innermode));\n+      int offset = byte / elt_size;\n       rtx elt;\n \n-      /* This shouldn't happen, but let's not do anything stupid.  */\n-      if (GET_MODE_INNER (innermode) != outermode)\n-\treturn NULL_RTX;\n-\n-      elt = CONST_VECTOR_ELT (op, offset);\n+      if (GET_MODE_INNER (innermode) == outermode)\n+\t{\n+\t  elt = CONST_VECTOR_ELT (op, offset);\n \n-      /* ?? We probably don't need this copy_rtx because constants\n-\t can be shared.  ?? */\n+\t  /* ?? We probably don't need this copy_rtx because constants\n+\t     can be shared.  ?? */\n \n-      return copy_rtx (elt);\n+\t  return copy_rtx (elt);\n+\t}\n+      else if (GET_MODE_INNER (innermode) == GET_MODE_INNER (outermode)\n+\t       && GET_MODE_SIZE (innermode) > GET_MODE_SIZE (outermode))\n+\t{\n+\t  return (gen_rtx_CONST_VECTOR\n+\t\t  (outermode,\n+\t\t   gen_rtvec_v (GET_MODE_NUNITS (outermode),\n+\t\t\t\t&CONST_VECTOR_ELT (op, offset))));\n+\t}\n+      else if (GET_MODE_CLASS (outermode) == MODE_INT\n+\t       && (GET_MODE_SIZE (outermode) % elt_size == 0))\n+\t{\n+\t  /* This happens when the target register size is smaller then\n+\t     the vector mode, and we synthesize operations with vectors\n+\t     of elements that are smaller than the register size.  */\n+\t  HOST_WIDE_INT sum = 0, high = 0;\n+\t  unsigned n_elts = (GET_MODE_SIZE (outermode) / elt_size);\n+\t  unsigned i = BYTES_BIG_ENDIAN ? offset : offset + n_elts - 1;\n+\t  unsigned step = BYTES_BIG_ENDIAN ? 1 : -1;\n+\t  int shift = BITS_PER_UNIT * elt_size;\n+\n+\t  for (; n_elts--; i += step)\n+\t    {\n+\t      elt = CONST_VECTOR_ELT (op, i);\n+\t      if (GET_CODE (elt) != CONST_INT)\n+\t\treturn NULL_RTX;\n+\t      high = high << shift | sum >> (HOST_BITS_PER_WIDE_INT - shift);\n+\t      sum = (sum << shift) + INTVAL (elt);\n+\t    }\n+\t  if (GET_MODE_BITSIZE (outermode) <= HOST_BITS_PER_WIDE_INT)\n+\t    return GEN_INT (trunc_int_for_mode (sum, outermode));\n+\t  else if (GET_MODE_BITSIZE (outermode) == 2* HOST_BITS_PER_WIDE_INT)\n+\t    return immed_double_const (high, sum, outermode);\n+\t  else\n+\t    return NULL_RTX;\n+\t}\n+      else\n+        /* This shouldn't happen, but let's not do anything stupid.  */\n+\treturn NULL_RTX;\n     }\n \n   /* Attempt to simplify constant to non-SUBREG expression.  */"}, {"sha": "9daae1a46b07f0f3897176a08f04695829bc6647", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/34a80643d8c74d96786fa19eec8a39fc94ac10b4/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/34a80643d8c74d96786fa19eec8a39fc94ac10b4/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=34a80643d8c74d96786fa19eec8a39fc94ac10b4", "patch": "@@ -1,3 +1,8 @@\n+Wed Jul  3 10:25:41 2002  J\"orn Rennecke <joern.rennecke@superh.com>\n+\n+\t* gcc.c-torture/execute/simd-1.c (main): Also test &, |, ^, ~.\n+\t* gcc.c-torture/execute/simd-2.c (main): Likewise.\n+\n 2002-07-02  Kaveh R. Ghazi  <ghazi@caip.rutgers.edu>\n \n \t* gcc.dg/cpp/tr-warn2.c: Use traditional C style function definitions."}, {"sha": "a93a6191cd13e98679a7ae33a258d1e4644708f0", "filename": "gcc/testsuite/gcc.c-torture/execute/simd-1.c", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/34a80643d8c74d96786fa19eec8a39fc94ac10b4/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fsimd-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/34a80643d8c74d96786fa19eec8a39fc94ac10b4/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fsimd-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fsimd-1.c?ref=34a80643d8c74d96786fa19eec8a39fc94ac10b4", "patch": "@@ -45,10 +45,29 @@ main ()\n \n   verify (res.i[0], res.i[1], res.i[2], res.i[3], 15, 7, 7, 6);\n \n+  k = i & j;\n+  res.v = k;\n+\n+  verify (res.i[0], res.i[1], res.i[2], res.i[3], 2, 4, 20, 8);\n+\n+  k = i | j;\n+  res.v = k;\n+\n+  verify (res.i[0], res.i[1], res.i[2], res.i[3], 158, 109, 150, 222);\n+\n+  k = i ^ j;\n+  res.v = k;\n+\n+  verify (res.i[0], res.i[1], res.i[2], res.i[3], 156, 105, 130, 214);\n+\n   k = -i;\n   res.v = k;\n   verify (res.i[0], res.i[1], res.i[2], res.i[3],\n \t  -150, -100, -150, -200);\n \n+  k = ~i;\n+  res.v = k;\n+  verify (res.i[0], res.i[1], res.i[2], res.i[3], -151, -101, -151, -201);\n+\n   exit (0);\n }"}, {"sha": "2d1b92228f7cffce9b253ca83a557e40c73365c3", "filename": "gcc/testsuite/gcc.c-torture/execute/simd-2.c", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/34a80643d8c74d96786fa19eec8a39fc94ac10b4/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fsimd-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/34a80643d8c74d96786fa19eec8a39fc94ac10b4/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fsimd-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fsimd-2.c?ref=34a80643d8c74d96786fa19eec8a39fc94ac10b4", "patch": "@@ -44,10 +44,29 @@ main ()\n \n   verify (res.i[0], res.i[1], res.i[2], res.i[3], 15, 7, 7, 6);\n \n+  k = i & j;\n+  res.v = k;\n+\n+  verify (res.i[0], res.i[1], res.i[2], res.i[3], 2, 4, 20, 8);\n+\n+  k = i | j;\n+  res.v = k;\n+\n+  verify (res.i[0], res.i[1], res.i[2], res.i[3], 158, 109, 150, 222);\n+\n+  k = i ^ j;\n+  res.v = k;\n+\n+  verify (res.i[0], res.i[1], res.i[2], res.i[3], 156, 105, 130, 214);\n+\n   k = -i;\n   res.v = k;\n   verify (res.i[0], res.i[1], res.i[2], res.i[3],\n \t  -150, -100, -150, -200);\n \n+  k = ~i;\n+  res.v = k;\n+  verify (res.i[0], res.i[1], res.i[2], res.i[3], -151, -101, -151, -201);\n+\n   exit (0);\n }"}]}