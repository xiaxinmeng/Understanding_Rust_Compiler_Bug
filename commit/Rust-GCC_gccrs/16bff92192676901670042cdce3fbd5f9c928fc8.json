{"sha": "16bff92192676901670042cdce3fbd5f9c928fc8", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTZiZmY5MjE5MjY3NjkwMTY3MDA0MmNkY2UzZmJkNWY5YzkyOGZjOA==", "commit": {"author": {"name": "Thomas Koenig", "email": "tkoenig@gcc.gnu.org", "date": "2009-07-19T15:07:21Z"}, "committer": {"name": "Thomas Koenig", "email": "tkoenig@gcc.gnu.org", "date": "2009-07-19T15:07:21Z"}, "message": "[multiple changes]\n\n2009-07-19  Thomas Koenig  <tkoenig@gcc.gnu.org>\n\n\tPR libfortran/34670\n\tPR libfortran/36874\n\t* Makefile.am:  Add bounds.c\n\t* libgfortran.h (bounds_equal_extents):  Add prototype.\n\t(bounds_iforeach_return):  Likewise.\n\t(bounds_ifunction_return):  Likewise.\n\t(bounds_reduced_extents):  Likewise.\n\t* runtime/bounds.c:  New file.\n\t(bounds_iforeach_return):  New function; correct typo in\n\terror message.\n\t(bounds_ifunction_return):  New function.\n\t(bounds_equal_extents):  New function.\n\t(bounds_reduced_extents):  Likewise.\n\t* intrinsics/cshift0.c (cshift0):  Use new functions\n\tfor bounds checking.\n\t* intrinsics/eoshift0.c (eoshift0):  Likewise.\n\t* intrinsics/eoshift2.c (eoshift2):  Likewise.\n\t* m4/iforeach.m4:  Likewise.\n\t* m4/eoshift1.m4:  Likewise.\n\t* m4/eoshift3.m4:  Likewise.\n\t* m4/cshift1.m4:  Likewise.\n\t* m4/ifunction.m4:  Likewise.\n\t* Makefile.in:  Regenerated.\n\t* generated/cshift1_16.c: Regenerated.\n\t* generated/cshift1_4.c: Regenerated.\n\t* generated/cshift1_8.c: Regenerated.\n\t* generated/eoshift1_16.c: Regenerated.\n\t* generated/eoshift1_4.c: Regenerated.\n\t* generated/eoshift1_8.c: Regenerated.\n\t* generated/eoshift3_16.c: Regenerated.\n\t* generated/eoshift3_4.c: Regenerated.\n\t* generated/eoshift3_8.c: Regenerated.\n\t* generated/maxloc0_16_i1.c: Regenerated.\n\t* generated/maxloc0_16_i16.c: Regenerated.\n\t* generated/maxloc0_16_i2.c: Regenerated.\n\t* generated/maxloc0_16_i4.c: Regenerated.\n\t* generated/maxloc0_16_i8.c: Regenerated.\n\t* generated/maxloc0_16_r10.c: Regenerated.\n\t* generated/maxloc0_16_r16.c: Regenerated.\n\t* generated/maxloc0_16_r4.c: Regenerated.\n\t* generated/maxloc0_16_r8.c: Regenerated.\n\t* generated/maxloc0_4_i1.c: Regenerated.\n\t* generated/maxloc0_4_i16.c: Regenerated.\n\t* generated/maxloc0_4_i2.c: Regenerated.\n\t* generated/maxloc0_4_i4.c: Regenerated.\n\t* generated/maxloc0_4_i8.c: Regenerated.\n\t* generated/maxloc0_4_r10.c: Regenerated.\n\t* generated/maxloc0_4_r16.c: Regenerated.\n\t* generated/maxloc0_4_r4.c: Regenerated.\n\t* generated/maxloc0_4_r8.c: Regenerated.\n\t* generated/maxloc0_8_i1.c: Regenerated.\n\t* generated/maxloc0_8_i16.c: Regenerated.\n\t* generated/maxloc0_8_i2.c: Regenerated.\n\t* generated/maxloc0_8_i4.c: Regenerated.\n\t* generated/maxloc0_8_i8.c: Regenerated.\n\t* generated/maxloc0_8_r10.c: Regenerated.\n\t* generated/maxloc0_8_r16.c: Regenerated.\n\t* generated/maxloc0_8_r4.c: Regenerated.\n\t* generated/maxloc0_8_r8.c: Regenerated.\n\t* generated/maxloc1_16_i1.c: Regenerated.\n\t* generated/maxloc1_16_i16.c: Regenerated.\n\t* generated/maxloc1_16_i2.c: Regenerated.\n\t* generated/maxloc1_16_i4.c: Regenerated.\n\t* generated/maxloc1_16_i8.c: Regenerated.\n\t* generated/maxloc1_16_r10.c: Regenerated.\n\t* generated/maxloc1_16_r16.c: Regenerated.\n\t* generated/maxloc1_16_r4.c: Regenerated.\n\t* generated/maxloc1_16_r8.c: Regenerated.\n\t* generated/maxloc1_4_i1.c: Regenerated.\n\t* generated/maxloc1_4_i16.c: Regenerated.\n\t* generated/maxloc1_4_i2.c: Regenerated.\n\t* generated/maxloc1_4_i4.c: Regenerated.\n\t* generated/maxloc1_4_i8.c: Regenerated.\n\t* generated/maxloc1_4_r10.c: Regenerated.\n\t* generated/maxloc1_4_r16.c: Regenerated.\n\t* generated/maxloc1_4_r4.c: Regenerated.\n\t* generated/maxloc1_4_r8.c: Regenerated.\n\t* generated/maxloc1_8_i1.c: Regenerated.\n\t* generated/maxloc1_8_i16.c: Regenerated.\n\t* generated/maxloc1_8_i2.c: Regenerated.\n\t* generated/maxloc1_8_i4.c: Regenerated.\n\t* generated/maxloc1_8_i8.c: Regenerated.\n\t* generated/maxloc1_8_r10.c: Regenerated.\n\t* generated/maxloc1_8_r16.c: Regenerated.\n\t* generated/maxloc1_8_r4.c: Regenerated.\n\t* generated/maxloc1_8_r8.c: Regenerated.\n\t* generated/maxval_i1.c: Regenerated.\n\t* generated/maxval_i16.c: Regenerated.\n\t* generated/maxval_i2.c: Regenerated.\n\t* generated/maxval_i4.c: Regenerated.\n\t* generated/maxval_i8.c: Regenerated.\n\t* generated/maxval_r10.c: Regenerated.\n\t* generated/maxval_r16.c: Regenerated.\n\t* generated/maxval_r4.c: Regenerated.\n\t* generated/maxval_r8.c: Regenerated.\n\t* generated/minloc0_16_i1.c: Regenerated.\n\t* generated/minloc0_16_i16.c: Regenerated.\n\t* generated/minloc0_16_i2.c: Regenerated.\n\t* generated/minloc0_16_i4.c: Regenerated.\n\t* generated/minloc0_16_i8.c: Regenerated.\n\t* generated/minloc0_16_r10.c: Regenerated.\n\t* generated/minloc0_16_r16.c: Regenerated.\n\t* generated/minloc0_16_r4.c: Regenerated.\n\t* generated/minloc0_16_r8.c: Regenerated.\n\t* generated/minloc0_4_i1.c: Regenerated.\n\t* generated/minloc0_4_i16.c: Regenerated.\n\t* generated/minloc0_4_i2.c: Regenerated.\n\t* generated/minloc0_4_i4.c: Regenerated.\n\t* generated/minloc0_4_i8.c: Regenerated.\n\t* generated/minloc0_4_r10.c: Regenerated.\n\t* generated/minloc0_4_r16.c: Regenerated.\n\t* generated/minloc0_4_r4.c: Regenerated.\n\t* generated/minloc0_4_r8.c: Regenerated.\n\t* generated/minloc0_8_i1.c: Regenerated.\n\t* generated/minloc0_8_i16.c: Regenerated.\n\t* generated/minloc0_8_i2.c: Regenerated.\n\t* generated/minloc0_8_i4.c: Regenerated.\n\t* generated/minloc0_8_i8.c: Regenerated.\n\t* generated/minloc0_8_r10.c: Regenerated.\n\t* generated/minloc0_8_r16.c: Regenerated.\n\t* generated/minloc0_8_r4.c: Regenerated.\n\t* generated/minloc0_8_r8.c: Regenerated.\n\t* generated/minloc1_16_i1.c: Regenerated.\n\t* generated/minloc1_16_i16.c: Regenerated.\n\t* generated/minloc1_16_i2.c: Regenerated.\n\t* generated/minloc1_16_i4.c: Regenerated.\n\t* generated/minloc1_16_i8.c: Regenerated.\n\t* generated/minloc1_16_r10.c: Regenerated.\n\t* generated/minloc1_16_r16.c: Regenerated.\n\t* generated/minloc1_16_r4.c: Regenerated.\n\t* generated/minloc1_16_r8.c: Regenerated.\n\t* generated/minloc1_4_i1.c: Regenerated.\n\t* generated/minloc1_4_i16.c: Regenerated.\n\t* generated/minloc1_4_i2.c: Regenerated.\n\t* generated/minloc1_4_i4.c: Regenerated.\n\t* generated/minloc1_4_i8.c: Regenerated.\n\t* generated/minloc1_4_r10.c: Regenerated.\n\t* generated/minloc1_4_r16.c: Regenerated.\n\t* generated/minloc1_4_r4.c: Regenerated.\n\t* generated/minloc1_4_r8.c: Regenerated.\n\t* generated/minloc1_8_i1.c: Regenerated.\n\t* generated/minloc1_8_i16.c: Regenerated.\n\t* generated/minloc1_8_i2.c: Regenerated.\n\t* generated/minloc1_8_i4.c: Regenerated.\n\t* generated/minloc1_8_i8.c: Regenerated.\n\t* generated/minloc1_8_r10.c: Regenerated.\n\t* generated/minloc1_8_r16.c: Regenerated.\n\t* generated/minloc1_8_r4.c: Regenerated.\n\t* generated/minloc1_8_r8.c: Regenerated.\n\t* generated/minval_i1.c: Regenerated.\n\t* generated/minval_i16.c: Regenerated.\n\t* generated/minval_i2.c: Regenerated.\n\t* generated/minval_i4.c: Regenerated.\n\t* generated/minval_i8.c: Regenerated.\n\t* generated/minval_r10.c: Regenerated.\n\t* generated/minval_r16.c: Regenerated.\n\t* generated/minval_r4.c: Regenerated.\n\t* generated/minval_r8.c: Regenerated.\n\t* generated/product_c10.c: Regenerated.\n\t* generated/product_c16.c: Regenerated.\n\t* generated/product_c4.c: Regenerated.\n\t* generated/product_c8.c: Regenerated.\n\t* generated/product_i1.c: Regenerated.\n\t* generated/product_i16.c: Regenerated.\n\t* generated/product_i2.c: Regenerated.\n\t* generated/product_i4.c: Regenerated.\n\t* generated/product_i8.c: Regenerated.\n\t* generated/product_r10.c: Regenerated.\n\t* generated/product_r16.c: Regenerated.\n\t* generated/product_r4.c: Regenerated.\n\t* generated/product_r8.c: Regenerated.\n\t* generated/sum_c10.c: Regenerated.\n\t* generated/sum_c16.c: Regenerated.\n\t* generated/sum_c4.c: Regenerated.\n\t* generated/sum_c8.c: Regenerated.\n\t* generated/sum_i1.c: Regenerated.\n\t* generated/sum_i16.c: Regenerated.\n\t* generated/sum_i2.c: Regenerated.\n\t* generated/sum_i4.c: Regenerated.\n\t* generated/sum_i8.c: Regenerated.\n\t* generated/sum_r10.c: Regenerated.\n\t* generated/sum_r16.c: Regenerated.\n\t* generated/sum_r4.c: Regenerated.\n\t* generated/sum_r8.c: Regenerated.\n\n2009-07-19   Thomas Koenig  <tkoenig@gcc.gnu.org>\n\n\tPR libfortran/34670\n\tPR libfortran/36874\n\t* gfortran.dg/cshift_bounds_1.f90:  New test.\n\t* gfortran.dg/cshift_bounds_2.f90:  New test.\n\t* gfortran.dg/cshift_bounds_3.f90:  New test.\n\t* gfortran.dg/cshift_bounds_4.f90:  New test.\n\t* gfortran.dg/eoshift_bounds_1.f90:  New test.\n\t* gfortran.dg/maxloc_bounds_4.f90:  Correct typo in error message.\n\t* gfortran.dg/maxloc_bounds_5.f90:  Correct typo in error message.\n\t* gfortran.dg/maxloc_bounds_7.f90:  Correct typo in error message.\n\nFrom-SVN: r149792", "tree": {"sha": "28774f9933d09cfe5f0816f6b9a4a36da7361147", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/28774f9933d09cfe5f0816f6b9a4a36da7361147"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/16bff92192676901670042cdce3fbd5f9c928fc8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/16bff92192676901670042cdce3fbd5f9c928fc8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/16bff92192676901670042cdce3fbd5f9c928fc8", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/16bff92192676901670042cdce3fbd5f9c928fc8/comments", "author": null, "committer": null, "parents": [{"sha": "a915ab00004ad7f5cddf0f232de0718561306d36", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a915ab00004ad7f5cddf0f232de0718561306d36", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a915ab00004ad7f5cddf0f232de0718561306d36"}], "stats": {"total": 8912, "additions": 1883, "deletions": 7029}, "files": [{"sha": "a1ba3f1d774e068df8bf881c0a8c3aed239a0199", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/16bff92192676901670042cdce3fbd5f9c928fc8/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/16bff92192676901670042cdce3fbd5f9c928fc8/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=16bff92192676901670042cdce3fbd5f9c928fc8", "patch": "@@ -1,3 +1,16 @@\n+2009-07-19   Thomas Koenig  <tkoenig@gcc.gnu.org>\n+\n+\tPR libfortran/34670\n+\tPR libfortran/36874\n+\t* gfortran.dg/cshift_bounds_1.f90:  New test.\n+\t* gfortran.dg/cshift_bounds_2.f90:  New test.\n+\t* gfortran.dg/cshift_bounds_3.f90:  New test.\n+\t* gfortran.dg/cshift_bounds_4.f90:  New test.\n+\t* gfortran.dg/eoshift_bounds_1.f90:  New test.\n+\t* gfortran.dg/maxloc_bounds_4.f90:  Correct typo in error message.\n+\t* gfortran.dg/maxloc_bounds_5.f90:  Correct typo in error message.\n+\t* gfortran.dg/maxloc_bounds_7.f90:  Correct typo in error message.\n+\n 2009-07-19  Jan Hubicka  <jh@suse.cz>\n \n \tPR tree-optimization/40676"}, {"sha": "5932004f2f387b360599bbddc1b45290305a83c6", "filename": "gcc/testsuite/gfortran.dg/cshift_bounds_1.f90", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/16bff92192676901670042cdce3fbd5f9c928fc8/gcc%2Ftestsuite%2Fgfortran.dg%2Fcshift_bounds_1.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/16bff92192676901670042cdce3fbd5f9c928fc8/gcc%2Ftestsuite%2Fgfortran.dg%2Fcshift_bounds_1.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fcshift_bounds_1.f90?ref=16bff92192676901670042cdce3fbd5f9c928fc8", "patch": "@@ -0,0 +1,24 @@\n+! { dg-do run }\n+! { dg-options \"-fbounds-check\" }\n+! Check that empty arrays are handled correctly in\n+! cshift and eoshift\n+program main\n+  character(len=50) :: line\n+  character(len=3), dimension(2,2) :: a, b\n+  integer :: n1, n2\n+  line = '-1-2'\n+  read (line,'(2I2)') n1, n2\n+  call foo(a, b, n1, n2)\n+  a = 'abc'\n+  write (line,'(4A)') eoshift(a, 3)\n+  write (line,'(4A)') cshift(a, 3)\n+  write (line,'(4A)') cshift(a(:,1:n1), 3)\n+  write (line,'(4A)') eoshift(a(1:n2,:), 3)\n+end program main\n+\n+subroutine foo(a, b, n1, n2)\n+  character(len=3), dimension(2, n1) :: a\n+  character(len=3), dimension(n2, 2) :: b\n+  a = cshift(b,1)\n+  a = eoshift(b,1)\n+end subroutine foo"}, {"sha": "8d7e779eacd6ceedc9ccbe7ed6ef6553303baef7", "filename": "gcc/testsuite/gfortran.dg/cshift_bounds_2.f90", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/16bff92192676901670042cdce3fbd5f9c928fc8/gcc%2Ftestsuite%2Fgfortran.dg%2Fcshift_bounds_2.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/16bff92192676901670042cdce3fbd5f9c928fc8/gcc%2Ftestsuite%2Fgfortran.dg%2Fcshift_bounds_2.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fcshift_bounds_2.f90?ref=16bff92192676901670042cdce3fbd5f9c928fc8", "patch": "@@ -0,0 +1,11 @@\n+! { dg-do run }\n+! { dg-options \"-fbounds-check\" }\n+! { dg-shouldfail \"Incorrect extent in return value of CSHIFT intrinsic in dimension 2: is 3, should be 2\" }\n+program main\n+  integer, dimension(:,:), allocatable :: a, b\n+  allocate (a(2,2))\n+  allocate (b(2,3))\n+  a = 1\n+  b = cshift(a,1)\n+end program main\n+! { dg-output \"Fortran runtime error: Incorrect extent in return value of CSHIFT intrinsic in dimension 2: is 3, should be 2\" }"}, {"sha": "33e387f32485f165d32eab73d979f7b547a21aef", "filename": "gcc/testsuite/gfortran.dg/cshift_bounds_3.f90", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/16bff92192676901670042cdce3fbd5f9c928fc8/gcc%2Ftestsuite%2Fgfortran.dg%2Fcshift_bounds_3.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/16bff92192676901670042cdce3fbd5f9c928fc8/gcc%2Ftestsuite%2Fgfortran.dg%2Fcshift_bounds_3.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fcshift_bounds_3.f90?ref=16bff92192676901670042cdce3fbd5f9c928fc8", "patch": "@@ -0,0 +1,12 @@\n+! { dg-do run }\n+! { dg-options \"-fbounds-check\" }\n+! { dg-shouldfail \"Incorrect size in SHIFT argument of CSHIFT intrinsic: should not be zero-sized\" }\n+program main\n+  real, dimension(1,0) :: a, b, c\n+  integer :: sp(3), i\n+  a = 4.0\n+  sp = 1\n+  i = 1\n+  b = cshift (a,sp(1:i)) ! Invalid\n+end program main\n+! { dg-output \"Fortran runtime error: Incorrect size in SHIFT argument of CSHIFT intrinsic: should not be zero-sized\" }"}, {"sha": "4a3fcfbd1de56d1acfa566060f63b97272411553", "filename": "gcc/testsuite/gfortran.dg/cshift_bounds_4.f90", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/16bff92192676901670042cdce3fbd5f9c928fc8/gcc%2Ftestsuite%2Fgfortran.dg%2Fcshift_bounds_4.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/16bff92192676901670042cdce3fbd5f9c928fc8/gcc%2Ftestsuite%2Fgfortran.dg%2Fcshift_bounds_4.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fcshift_bounds_4.f90?ref=16bff92192676901670042cdce3fbd5f9c928fc8", "patch": "@@ -0,0 +1,13 @@\n+! { dg-do run }\n+! { dg-shouldfail \"Incorrect extent in SHIFT argument of CSHIFT intrinsic in dimension 1: is 3, should be 2\" }\n+! { dg-options \"-fbounds-check\" }\n+program main\n+  integer, dimension(:,:), allocatable :: a, b\n+  integer, dimension(:), allocatable :: sh\n+  allocate (a(2,2))\n+  allocate (b(2,2))\n+  allocate (sh(3))\n+  a = 1\n+  b = cshift(a,sh)\n+end program main\n+! { dg-output \"Fortran runtime error: Incorrect extent in SHIFT argument of CSHIFT intrinsic in dimension 1: is 3, should be 2\" }"}, {"sha": "f32341556368cde4d8f537b36a921dc4082bdbf3", "filename": "gcc/testsuite/gfortran.dg/eoshift_bounds_1.f90", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/16bff92192676901670042cdce3fbd5f9c928fc8/gcc%2Ftestsuite%2Fgfortran.dg%2Feoshift_bounds_1.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/16bff92192676901670042cdce3fbd5f9c928fc8/gcc%2Ftestsuite%2Fgfortran.dg%2Feoshift_bounds_1.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Feoshift_bounds_1.f90?ref=16bff92192676901670042cdce3fbd5f9c928fc8", "patch": "@@ -0,0 +1,12 @@\n+! { dg-do run }\n+! { dg-options \"-fbounds-check\" }\n+! { dg-shouldfail \"Incorrect size in SHIFT argument of EOSHIFT intrinsic: should not be zero-sized\" }\n+program main\n+  real, dimension(1,0) :: a, b, c\n+  integer :: sp(3), i\n+  a = 4.0\n+  sp = 1\n+  i = 1\n+  b = eoshift (a,sp(1:i)) ! Invalid\n+end program main\n+! { dg-output \"Fortran runtime error: Incorrect size in SHIFT argument of EOSHIFT intrinsic: should not be zero-sized\" }"}, {"sha": "7ba103d6168ad4e3d32a05c3721fd719ba6a6242", "filename": "gcc/testsuite/gfortran.dg/maxloc_bounds_4.f90", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/16bff92192676901670042cdce3fbd5f9c928fc8/gcc%2Ftestsuite%2Fgfortran.dg%2Fmaxloc_bounds_4.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/16bff92192676901670042cdce3fbd5f9c928fc8/gcc%2Ftestsuite%2Fgfortran.dg%2Fmaxloc_bounds_4.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fmaxloc_bounds_4.f90?ref=16bff92192676901670042cdce3fbd5f9c928fc8", "patch": "@@ -1,6 +1,6 @@\n ! { dg-do run }\n ! { dg-options \"-fbounds-check\" }\n-! { dg-shouldfail \"Incorrect extent in return value of MAXLOC intrnisic: is 3, should be 2\" }\n+! { dg-shouldfail \"Incorrect extent in return value of MAXLOC intrinsic: is 3, should be 2\" }\n module tst\n contains\n   subroutine foo(res)\n@@ -18,6 +18,6 @@ program main\n   integer :: res(3)\n   call foo(res)\n end program main\n-! { dg-output \"Fortran runtime error: Incorrect extent in return value of MAXLOC intrnisic: is 3, should be 2\" }\n+! { dg-output \"Fortran runtime error: Incorrect extent in return value of MAXLOC intrinsic: is 3, should be 2\" }\n ! { dg-final { cleanup-modules \"tst\" } }\n "}, {"sha": "34d06da55ac09cd7d0b8c487d1c5bd3e4c10b20e", "filename": "gcc/testsuite/gfortran.dg/maxloc_bounds_5.f90", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/16bff92192676901670042cdce3fbd5f9c928fc8/gcc%2Ftestsuite%2Fgfortran.dg%2Fmaxloc_bounds_5.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/16bff92192676901670042cdce3fbd5f9c928fc8/gcc%2Ftestsuite%2Fgfortran.dg%2Fmaxloc_bounds_5.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fmaxloc_bounds_5.f90?ref=16bff92192676901670042cdce3fbd5f9c928fc8", "patch": "@@ -1,6 +1,6 @@\n ! { dg-do run }\n ! { dg-options \"-fbounds-check\" }\n-! { dg-shouldfail \"Incorrect extent in return value of MAXLOC intrnisic: is 3, should be 2\" }\n+! { dg-shouldfail \"Incorrect extent in return value of MAXLOC intrinsic: is 3, should be 2\" }\n module tst\n contains\n   subroutine foo(res)\n@@ -18,5 +18,5 @@ program main\n   integer :: res(3)\n   call foo(res)\n end program main\n-! { dg-output \"Fortran runtime error: Incorrect extent in return value of MAXLOC intrnisic: is 3, should be 2\" }\n+! { dg-output \"Fortran runtime error: Incorrect extent in return value of MAXLOC intrinsic: is 3, should be 2\" }\n ! { dg-final { cleanup-modules \"tst\" } }"}, {"sha": "817bf8fac399562aabc47e5a788c7920b81e2945", "filename": "gcc/testsuite/gfortran.dg/maxloc_bounds_7.f90", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/16bff92192676901670042cdce3fbd5f9c928fc8/gcc%2Ftestsuite%2Fgfortran.dg%2Fmaxloc_bounds_7.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/16bff92192676901670042cdce3fbd5f9c928fc8/gcc%2Ftestsuite%2Fgfortran.dg%2Fmaxloc_bounds_7.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fmaxloc_bounds_7.f90?ref=16bff92192676901670042cdce3fbd5f9c928fc8", "patch": "@@ -1,6 +1,6 @@\n ! { dg-do run }\n ! { dg-options \"-fbounds-check\" }\n-! { dg-shouldfail \"Incorrect extent in return value of MAXLOC intrnisic: is 3, should be 2\" }\n+! { dg-shouldfail \"Incorrect extent in return value of MAXLOC intrinsic: is 3, should be 2\" }\n module tst\n contains\n   subroutine foo(res)\n@@ -18,5 +18,5 @@ program main\n   integer :: res(3)\n   call foo(res)\n end program main\n-! { dg-output \"Fortran runtime error: Incorrect extent in return value of MAXLOC intrnisic: is 3, should be 2\" }\n+! { dg-output \"Fortran runtime error: Incorrect extent in return value of MAXLOC intrinsic: is 3, should be 2\" }\n ! { dg-final { cleanup-modules \"tst\" } }"}, {"sha": "8231ed1588c18dc1bc11fad861b6d5f98f96ffd4", "filename": "libgfortran/ChangeLog", "status": "modified", "additions": 187, "deletions": 0, "changes": 187, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/16bff92192676901670042cdce3fbd5f9c928fc8/libgfortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/16bff92192676901670042cdce3fbd5f9c928fc8/libgfortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2FChangeLog?ref=16bff92192676901670042cdce3fbd5f9c928fc8", "patch": "@@ -1,3 +1,190 @@\n+2009-07-19  Thomas Koenig  <tkoenig@gcc.gnu.org>\n+\n+\tPR libfortran/34670\n+\tPR libfortran/36874\n+\t* Makefile.am:  Add bounds.c\n+\t* libgfortran.h (bounds_equal_extents):  Add prototype.\n+\t(bounds_iforeach_return):  Likewise.\n+\t(bounds_ifunction_return):  Likewise.\n+\t(bounds_reduced_extents):  Likewise.\n+\t* runtime/bounds.c:  New file.\n+\t(bounds_iforeach_return):  New function; correct typo in\n+\terror message.\n+\t(bounds_ifunction_return):  New function.\n+\t(bounds_equal_extents):  New function.\n+\t(bounds_reduced_extents):  Likewise.\n+\t* intrinsics/cshift0.c (cshift0):  Use new functions\n+\tfor bounds checking.\n+\t* intrinsics/eoshift0.c (eoshift0):  Likewise.\n+\t* intrinsics/eoshift2.c (eoshift2):  Likewise.\n+\t* m4/iforeach.m4:  Likewise.\n+\t* m4/eoshift1.m4:  Likewise.\n+\t* m4/eoshift3.m4:  Likewise.\n+\t* m4/cshift1.m4:  Likewise.\n+\t* m4/ifunction.m4:  Likewise.\n+\t* Makefile.in:  Regenerated.\n+\t* generated/cshift1_16.c: Regenerated.\n+\t* generated/cshift1_4.c: Regenerated.\n+\t* generated/cshift1_8.c: Regenerated.\n+\t* generated/eoshift1_16.c: Regenerated.\n+\t* generated/eoshift1_4.c: Regenerated.\n+\t* generated/eoshift1_8.c: Regenerated.\n+\t* generated/eoshift3_16.c: Regenerated.\n+\t* generated/eoshift3_4.c: Regenerated.\n+\t* generated/eoshift3_8.c: Regenerated.\n+\t* generated/maxloc0_16_i1.c: Regenerated.\n+\t* generated/maxloc0_16_i16.c: Regenerated.\n+\t* generated/maxloc0_16_i2.c: Regenerated.\n+\t* generated/maxloc0_16_i4.c: Regenerated.\n+\t* generated/maxloc0_16_i8.c: Regenerated.\n+\t* generated/maxloc0_16_r10.c: Regenerated.\n+\t* generated/maxloc0_16_r16.c: Regenerated.\n+\t* generated/maxloc0_16_r4.c: Regenerated.\n+\t* generated/maxloc0_16_r8.c: Regenerated.\n+\t* generated/maxloc0_4_i1.c: Regenerated.\n+\t* generated/maxloc0_4_i16.c: Regenerated.\n+\t* generated/maxloc0_4_i2.c: Regenerated.\n+\t* generated/maxloc0_4_i4.c: Regenerated.\n+\t* generated/maxloc0_4_i8.c: Regenerated.\n+\t* generated/maxloc0_4_r10.c: Regenerated.\n+\t* generated/maxloc0_4_r16.c: Regenerated.\n+\t* generated/maxloc0_4_r4.c: Regenerated.\n+\t* generated/maxloc0_4_r8.c: Regenerated.\n+\t* generated/maxloc0_8_i1.c: Regenerated.\n+\t* generated/maxloc0_8_i16.c: Regenerated.\n+\t* generated/maxloc0_8_i2.c: Regenerated.\n+\t* generated/maxloc0_8_i4.c: Regenerated.\n+\t* generated/maxloc0_8_i8.c: Regenerated.\n+\t* generated/maxloc0_8_r10.c: Regenerated.\n+\t* generated/maxloc0_8_r16.c: Regenerated.\n+\t* generated/maxloc0_8_r4.c: Regenerated.\n+\t* generated/maxloc0_8_r8.c: Regenerated.\n+\t* generated/maxloc1_16_i1.c: Regenerated.\n+\t* generated/maxloc1_16_i16.c: Regenerated.\n+\t* generated/maxloc1_16_i2.c: Regenerated.\n+\t* generated/maxloc1_16_i4.c: Regenerated.\n+\t* generated/maxloc1_16_i8.c: Regenerated.\n+\t* generated/maxloc1_16_r10.c: Regenerated.\n+\t* generated/maxloc1_16_r16.c: Regenerated.\n+\t* generated/maxloc1_16_r4.c: Regenerated.\n+\t* generated/maxloc1_16_r8.c: Regenerated.\n+\t* generated/maxloc1_4_i1.c: Regenerated.\n+\t* generated/maxloc1_4_i16.c: Regenerated.\n+\t* generated/maxloc1_4_i2.c: Regenerated.\n+\t* generated/maxloc1_4_i4.c: Regenerated.\n+\t* generated/maxloc1_4_i8.c: Regenerated.\n+\t* generated/maxloc1_4_r10.c: Regenerated.\n+\t* generated/maxloc1_4_r16.c: Regenerated.\n+\t* generated/maxloc1_4_r4.c: Regenerated.\n+\t* generated/maxloc1_4_r8.c: Regenerated.\n+\t* generated/maxloc1_8_i1.c: Regenerated.\n+\t* generated/maxloc1_8_i16.c: Regenerated.\n+\t* generated/maxloc1_8_i2.c: Regenerated.\n+\t* generated/maxloc1_8_i4.c: Regenerated.\n+\t* generated/maxloc1_8_i8.c: Regenerated.\n+\t* generated/maxloc1_8_r10.c: Regenerated.\n+\t* generated/maxloc1_8_r16.c: Regenerated.\n+\t* generated/maxloc1_8_r4.c: Regenerated.\n+\t* generated/maxloc1_8_r8.c: Regenerated.\n+\t* generated/maxval_i1.c: Regenerated.\n+\t* generated/maxval_i16.c: Regenerated.\n+\t* generated/maxval_i2.c: Regenerated.\n+\t* generated/maxval_i4.c: Regenerated.\n+\t* generated/maxval_i8.c: Regenerated.\n+\t* generated/maxval_r10.c: Regenerated.\n+\t* generated/maxval_r16.c: Regenerated.\n+\t* generated/maxval_r4.c: Regenerated.\n+\t* generated/maxval_r8.c: Regenerated.\n+\t* generated/minloc0_16_i1.c: Regenerated.\n+\t* generated/minloc0_16_i16.c: Regenerated.\n+\t* generated/minloc0_16_i2.c: Regenerated.\n+\t* generated/minloc0_16_i4.c: Regenerated.\n+\t* generated/minloc0_16_i8.c: Regenerated.\n+\t* generated/minloc0_16_r10.c: Regenerated.\n+\t* generated/minloc0_16_r16.c: Regenerated.\n+\t* generated/minloc0_16_r4.c: Regenerated.\n+\t* generated/minloc0_16_r8.c: Regenerated.\n+\t* generated/minloc0_4_i1.c: Regenerated.\n+\t* generated/minloc0_4_i16.c: Regenerated.\n+\t* generated/minloc0_4_i2.c: Regenerated.\n+\t* generated/minloc0_4_i4.c: Regenerated.\n+\t* generated/minloc0_4_i8.c: Regenerated.\n+\t* generated/minloc0_4_r10.c: Regenerated.\n+\t* generated/minloc0_4_r16.c: Regenerated.\n+\t* generated/minloc0_4_r4.c: Regenerated.\n+\t* generated/minloc0_4_r8.c: Regenerated.\n+\t* generated/minloc0_8_i1.c: Regenerated.\n+\t* generated/minloc0_8_i16.c: Regenerated.\n+\t* generated/minloc0_8_i2.c: Regenerated.\n+\t* generated/minloc0_8_i4.c: Regenerated.\n+\t* generated/minloc0_8_i8.c: Regenerated.\n+\t* generated/minloc0_8_r10.c: Regenerated.\n+\t* generated/minloc0_8_r16.c: Regenerated.\n+\t* generated/minloc0_8_r4.c: Regenerated.\n+\t* generated/minloc0_8_r8.c: Regenerated.\n+\t* generated/minloc1_16_i1.c: Regenerated.\n+\t* generated/minloc1_16_i16.c: Regenerated.\n+\t* generated/minloc1_16_i2.c: Regenerated.\n+\t* generated/minloc1_16_i4.c: Regenerated.\n+\t* generated/minloc1_16_i8.c: Regenerated.\n+\t* generated/minloc1_16_r10.c: Regenerated.\n+\t* generated/minloc1_16_r16.c: Regenerated.\n+\t* generated/minloc1_16_r4.c: Regenerated.\n+\t* generated/minloc1_16_r8.c: Regenerated.\n+\t* generated/minloc1_4_i1.c: Regenerated.\n+\t* generated/minloc1_4_i16.c: Regenerated.\n+\t* generated/minloc1_4_i2.c: Regenerated.\n+\t* generated/minloc1_4_i4.c: Regenerated.\n+\t* generated/minloc1_4_i8.c: Regenerated.\n+\t* generated/minloc1_4_r10.c: Regenerated.\n+\t* generated/minloc1_4_r16.c: Regenerated.\n+\t* generated/minloc1_4_r4.c: Regenerated.\n+\t* generated/minloc1_4_r8.c: Regenerated.\n+\t* generated/minloc1_8_i1.c: Regenerated.\n+\t* generated/minloc1_8_i16.c: Regenerated.\n+\t* generated/minloc1_8_i2.c: Regenerated.\n+\t* generated/minloc1_8_i4.c: Regenerated.\n+\t* generated/minloc1_8_i8.c: Regenerated.\n+\t* generated/minloc1_8_r10.c: Regenerated.\n+\t* generated/minloc1_8_r16.c: Regenerated.\n+\t* generated/minloc1_8_r4.c: Regenerated.\n+\t* generated/minloc1_8_r8.c: Regenerated.\n+\t* generated/minval_i1.c: Regenerated.\n+\t* generated/minval_i16.c: Regenerated.\n+\t* generated/minval_i2.c: Regenerated.\n+\t* generated/minval_i4.c: Regenerated.\n+\t* generated/minval_i8.c: Regenerated.\n+\t* generated/minval_r10.c: Regenerated.\n+\t* generated/minval_r16.c: Regenerated.\n+\t* generated/minval_r4.c: Regenerated.\n+\t* generated/minval_r8.c: Regenerated.\n+\t* generated/product_c10.c: Regenerated.\n+\t* generated/product_c16.c: Regenerated.\n+\t* generated/product_c4.c: Regenerated.\n+\t* generated/product_c8.c: Regenerated.\n+\t* generated/product_i1.c: Regenerated.\n+\t* generated/product_i16.c: Regenerated.\n+\t* generated/product_i2.c: Regenerated.\n+\t* generated/product_i4.c: Regenerated.\n+\t* generated/product_i8.c: Regenerated.\n+\t* generated/product_r10.c: Regenerated.\n+\t* generated/product_r16.c: Regenerated.\n+\t* generated/product_r4.c: Regenerated.\n+\t* generated/product_r8.c: Regenerated.\n+\t* generated/sum_c10.c: Regenerated.\n+\t* generated/sum_c16.c: Regenerated.\n+\t* generated/sum_c4.c: Regenerated.\n+\t* generated/sum_c8.c: Regenerated.\n+\t* generated/sum_i1.c: Regenerated.\n+\t* generated/sum_i16.c: Regenerated.\n+\t* generated/sum_i2.c: Regenerated.\n+\t* generated/sum_i4.c: Regenerated.\n+\t* generated/sum_i8.c: Regenerated.\n+\t* generated/sum_r10.c: Regenerated.\n+\t* generated/sum_r16.c: Regenerated.\n+\t* generated/sum_r4.c: Regenerated.\n+\t* generated/sum_r8.c: Regenerated.\n+\n 2009-07-17  Janne Blomqvist  <jb@gcc.gnu.org>\n \t    Jerry DeLisle  <jvdelisle@gcc.gnu.org>\n \t\t"}, {"sha": "4a974ba00669b667518ba12d9912bde4e5ebf9e1", "filename": "libgfortran/Makefile.am", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/16bff92192676901670042cdce3fbd5f9c928fc8/libgfortran%2FMakefile.am", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/16bff92192676901670042cdce3fbd5f9c928fc8/libgfortran%2FMakefile.am", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2FMakefile.am?ref=16bff92192676901670042cdce3fbd5f9c928fc8", "patch": "@@ -122,6 +122,7 @@ runtime/in_unpack_generic.c\n \n gfor_src= \\\n runtime/backtrace.c \\\n+runtime/bounds.c \\\n runtime/compile_options.c \\\n runtime/convert_char.c \\\n runtime/environ.c \\"}, {"sha": "7741c324aafb33ca2d76da84b1150c13a01f27ad", "filename": "libgfortran/Makefile.in", "status": "modified", "additions": 13, "deletions": 4, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/16bff92192676901670042cdce3fbd5f9c928fc8/libgfortran%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/16bff92192676901670042cdce3fbd5f9c928fc8/libgfortran%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2FMakefile.in?ref=16bff92192676901670042cdce3fbd5f9c928fc8", "patch": "@@ -78,7 +78,7 @@ myexeclibLTLIBRARIES_INSTALL = $(INSTALL)\n toolexeclibLTLIBRARIES_INSTALL = $(INSTALL)\n LTLIBRARIES = $(myexeclib_LTLIBRARIES) $(toolexeclib_LTLIBRARIES)\n libgfortran_la_LIBADD =\n-am__libgfortran_la_SOURCES_DIST = runtime/backtrace.c \\\n+am__libgfortran_la_SOURCES_DIST = runtime/backtrace.c runtime/bounds.c \\\n \truntime/compile_options.c runtime/convert_char.c \\\n \truntime/environ.c runtime/error.c runtime/fpu.c runtime/main.c \\\n \truntime/memory.c runtime/pause.c runtime/stop.c \\\n@@ -580,9 +580,9 @@ am__libgfortran_la_SOURCES_DIST = runtime/backtrace.c \\\n \t$(srcdir)/generated/misc_specifics.F90 intrinsics/dprod_r8.f90 \\\n \tintrinsics/f2c_specifics.F90 libgfortran_c.c $(filter-out \\\n \t%.c,$(prereq_SRC))\n-am__objects_1 = backtrace.lo compile_options.lo convert_char.lo \\\n-\tenviron.lo error.lo fpu.lo main.lo memory.lo pause.lo stop.lo \\\n-\tstring.lo select.lo\n+am__objects_1 = backtrace.lo bounds.lo compile_options.lo \\\n+\tconvert_char.lo environ.lo error.lo fpu.lo main.lo memory.lo \\\n+\tpause.lo stop.lo string.lo select.lo\n am__objects_2 = all_l1.lo all_l2.lo all_l4.lo all_l8.lo all_l16.lo\n am__objects_3 = any_l1.lo any_l2.lo any_l4.lo any_l8.lo any_l16.lo\n am__objects_4 = count_1_l.lo count_2_l.lo count_4_l.lo count_8_l.lo \\\n@@ -1050,6 +1050,7 @@ runtime/in_unpack_generic.c\n \n gfor_src = \\\n runtime/backtrace.c \\\n+runtime/bounds.c \\\n runtime/compile_options.c \\\n runtime/convert_char.c \\\n runtime/environ.c \\\n@@ -1806,6 +1807,7 @@ distclean-compile:\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/associated.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/backtrace.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/bit_intrinsics.Plo@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/bounds.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/c99_functions.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/chdir.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/chmod.Plo@am__quote@\n@@ -2678,6 +2680,13 @@ backtrace.lo: runtime/backtrace.c\n @AMDEP_TRUE@@am__fastdepCC_FALSE@\tDEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@\n @am__fastdepCC_FALSE@\t$(LIBTOOL) --tag=CC --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o backtrace.lo `test -f 'runtime/backtrace.c' || echo '$(srcdir)/'`runtime/backtrace.c\n \n+bounds.lo: runtime/bounds.c\n+@am__fastdepCC_TRUE@\tif $(LIBTOOL) --tag=CC --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT bounds.lo -MD -MP -MF \"$(DEPDIR)/bounds.Tpo\" -c -o bounds.lo `test -f 'runtime/bounds.c' || echo '$(srcdir)/'`runtime/bounds.c; \\\n+@am__fastdepCC_TRUE@\tthen mv -f \"$(DEPDIR)/bounds.Tpo\" \"$(DEPDIR)/bounds.Plo\"; else rm -f \"$(DEPDIR)/bounds.Tpo\"; exit 1; fi\n+@AMDEP_TRUE@@am__fastdepCC_FALSE@\tsource='runtime/bounds.c' object='bounds.lo' libtool=yes @AMDEPBACKSLASH@\n+@AMDEP_TRUE@@am__fastdepCC_FALSE@\tDEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@\n+@am__fastdepCC_FALSE@\t$(LIBTOOL) --tag=CC --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o bounds.lo `test -f 'runtime/bounds.c' || echo '$(srcdir)/'`runtime/bounds.c\n+\n compile_options.lo: runtime/compile_options.c\n @am__fastdepCC_TRUE@\tif $(LIBTOOL) --tag=CC --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT compile_options.lo -MD -MP -MF \"$(DEPDIR)/compile_options.Tpo\" -c -o compile_options.lo `test -f 'runtime/compile_options.c' || echo '$(srcdir)/'`runtime/compile_options.c; \\\n @am__fastdepCC_TRUE@\tthen mv -f \"$(DEPDIR)/compile_options.Tpo\" \"$(DEPDIR)/compile_options.Plo\"; else rm -f \"$(DEPDIR)/compile_options.Tpo\"; exit 1; fi"}, {"sha": "b2cb7f17ce47fec325e83816956be3dc695139fa", "filename": "libgfortran/generated/cshift1_16.c", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/16bff92192676901670042cdce3fbd5f9c928fc8/libgfortran%2Fgenerated%2Fcshift1_16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/16bff92192676901670042cdce3fbd5f9c928fc8/libgfortran%2Fgenerated%2Fcshift1_16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fcshift1_16.c?ref=16bff92192676901670042cdce3fbd5f9c928fc8", "patch": "@@ -98,6 +98,17 @@ cshift1 (gfc_array_char * const restrict ret,\n \t  GFC_DIMENSION_SET(ret->dim[i], 0, ub, str);\n         }\n     }\n+  else if (unlikely (compile_options.bounds_check))\n+    {\n+      bounds_equal_extents ((array_t *) ret, (array_t *) array,\n+\t\t\t\t \"return value\", \"CSHIFT\");\n+    }\n+\n+  if (unlikely (compile_options.bounds_check))\n+    {\n+      bounds_reduced_extents ((array_t *) h, (array_t *) array, which,\n+      \t\t\t      \"SHIFT argument\", \"CSHIFT\");\n+    }\n \n   if (arraysize == 0)\n     return;"}, {"sha": "30f3d99dc35430b42e6f258139057997c4ca74ef", "filename": "libgfortran/generated/cshift1_4.c", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/16bff92192676901670042cdce3fbd5f9c928fc8/libgfortran%2Fgenerated%2Fcshift1_4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/16bff92192676901670042cdce3fbd5f9c928fc8/libgfortran%2Fgenerated%2Fcshift1_4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fcshift1_4.c?ref=16bff92192676901670042cdce3fbd5f9c928fc8", "patch": "@@ -98,6 +98,17 @@ cshift1 (gfc_array_char * const restrict ret,\n \t  GFC_DIMENSION_SET(ret->dim[i], 0, ub, str);\n         }\n     }\n+  else if (unlikely (compile_options.bounds_check))\n+    {\n+      bounds_equal_extents ((array_t *) ret, (array_t *) array,\n+\t\t\t\t \"return value\", \"CSHIFT\");\n+    }\n+\n+  if (unlikely (compile_options.bounds_check))\n+    {\n+      bounds_reduced_extents ((array_t *) h, (array_t *) array, which,\n+      \t\t\t      \"SHIFT argument\", \"CSHIFT\");\n+    }\n \n   if (arraysize == 0)\n     return;"}, {"sha": "c3bf473e49c1de572548d2d67268779f4daf1f15", "filename": "libgfortran/generated/cshift1_8.c", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/16bff92192676901670042cdce3fbd5f9c928fc8/libgfortran%2Fgenerated%2Fcshift1_8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/16bff92192676901670042cdce3fbd5f9c928fc8/libgfortran%2Fgenerated%2Fcshift1_8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fcshift1_8.c?ref=16bff92192676901670042cdce3fbd5f9c928fc8", "patch": "@@ -98,6 +98,17 @@ cshift1 (gfc_array_char * const restrict ret,\n \t  GFC_DIMENSION_SET(ret->dim[i], 0, ub, str);\n         }\n     }\n+  else if (unlikely (compile_options.bounds_check))\n+    {\n+      bounds_equal_extents ((array_t *) ret, (array_t *) array,\n+\t\t\t\t \"return value\", \"CSHIFT\");\n+    }\n+\n+  if (unlikely (compile_options.bounds_check))\n+    {\n+      bounds_reduced_extents ((array_t *) h, (array_t *) array, which,\n+      \t\t\t      \"SHIFT argument\", \"CSHIFT\");\n+    }\n \n   if (arraysize == 0)\n     return;"}, {"sha": "a14bd2927153128e7fb1ef86fd365c74c7f89a41", "filename": "libgfortran/generated/eoshift1_16.c", "status": "modified", "additions": 20, "deletions": 4, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/16bff92192676901670042cdce3fbd5f9c928fc8/libgfortran%2Fgenerated%2Feoshift1_16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/16bff92192676901670042cdce3fbd5f9c928fc8/libgfortran%2Fgenerated%2Feoshift1_16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Feoshift1_16.c?ref=16bff92192676901670042cdce3fbd5f9c928fc8", "patch": "@@ -62,6 +62,7 @@ eoshift1 (gfc_array_char * const restrict ret,\n   index_type len;\n   index_type n;\n   index_type size;\n+  index_type arraysize;\n   int which;\n   GFC_INTEGER_16 sh;\n   GFC_INTEGER_16 delta;\n@@ -82,11 +83,12 @@ eoshift1 (gfc_array_char * const restrict ret,\n   extent[0] = 1;\n   count[0] = 0;\n \n+  arraysize = size0 ((array_t *) array);\n   if (ret->data == NULL)\n     {\n       int i;\n \n-      ret->data = internal_malloc_size (size * size0 ((array_t *)array));\n+      ret->data = internal_malloc_size (size * arraysize);\n       ret->offset = 0;\n       ret->dtype = array->dtype;\n       for (i = 0; i < GFC_DESCRIPTOR_RANK (array); i++)\n@@ -104,13 +106,27 @@ eoshift1 (gfc_array_char * const restrict ret,\n \t  GFC_DIMENSION_SET(ret->dim[i], 0, ub, str);\n \n         }\n+      if (arraysize > 0)\n+\tret->data = internal_malloc_size (size * arraysize);\n+      else\n+\tret->data = internal_malloc_size (1);\n+\n     }\n-  else\n+  else if (unlikely (compile_options.bounds_check))\n     {\n-      if (size0 ((array_t *) ret) == 0)\n-\treturn;\n+      bounds_equal_extents ((array_t *) ret, (array_t *) array,\n+\t\t\t\t \"return value\", \"EOSHIFT\");\n     }\n \n+  if (unlikely (compile_options.bounds_check))\n+    {\n+      bounds_reduced_extents ((array_t *) h, (array_t *) array, which,\n+      \t\t\t      \"SHIFT argument\", \"EOSHIFT\");\n+    }\n+\n+  if (arraysize == 0)\n+    return;\n+\n   n = 0;\n   for (dim = 0; dim < GFC_DESCRIPTOR_RANK (array); dim++)\n     {"}, {"sha": "06bc309c4a845b8c033e6e8bd2c80e5c584eb386", "filename": "libgfortran/generated/eoshift1_4.c", "status": "modified", "additions": 20, "deletions": 4, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/16bff92192676901670042cdce3fbd5f9c928fc8/libgfortran%2Fgenerated%2Feoshift1_4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/16bff92192676901670042cdce3fbd5f9c928fc8/libgfortran%2Fgenerated%2Feoshift1_4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Feoshift1_4.c?ref=16bff92192676901670042cdce3fbd5f9c928fc8", "patch": "@@ -62,6 +62,7 @@ eoshift1 (gfc_array_char * const restrict ret,\n   index_type len;\n   index_type n;\n   index_type size;\n+  index_type arraysize;\n   int which;\n   GFC_INTEGER_4 sh;\n   GFC_INTEGER_4 delta;\n@@ -82,11 +83,12 @@ eoshift1 (gfc_array_char * const restrict ret,\n   extent[0] = 1;\n   count[0] = 0;\n \n+  arraysize = size0 ((array_t *) array);\n   if (ret->data == NULL)\n     {\n       int i;\n \n-      ret->data = internal_malloc_size (size * size0 ((array_t *)array));\n+      ret->data = internal_malloc_size (size * arraysize);\n       ret->offset = 0;\n       ret->dtype = array->dtype;\n       for (i = 0; i < GFC_DESCRIPTOR_RANK (array); i++)\n@@ -104,13 +106,27 @@ eoshift1 (gfc_array_char * const restrict ret,\n \t  GFC_DIMENSION_SET(ret->dim[i], 0, ub, str);\n \n         }\n+      if (arraysize > 0)\n+\tret->data = internal_malloc_size (size * arraysize);\n+      else\n+\tret->data = internal_malloc_size (1);\n+\n     }\n-  else\n+  else if (unlikely (compile_options.bounds_check))\n     {\n-      if (size0 ((array_t *) ret) == 0)\n-\treturn;\n+      bounds_equal_extents ((array_t *) ret, (array_t *) array,\n+\t\t\t\t \"return value\", \"EOSHIFT\");\n     }\n \n+  if (unlikely (compile_options.bounds_check))\n+    {\n+      bounds_reduced_extents ((array_t *) h, (array_t *) array, which,\n+      \t\t\t      \"SHIFT argument\", \"EOSHIFT\");\n+    }\n+\n+  if (arraysize == 0)\n+    return;\n+\n   n = 0;\n   for (dim = 0; dim < GFC_DESCRIPTOR_RANK (array); dim++)\n     {"}, {"sha": "3e9162d0f085529c9235be56c378f670d20bc8f7", "filename": "libgfortran/generated/eoshift1_8.c", "status": "modified", "additions": 20, "deletions": 4, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/16bff92192676901670042cdce3fbd5f9c928fc8/libgfortran%2Fgenerated%2Feoshift1_8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/16bff92192676901670042cdce3fbd5f9c928fc8/libgfortran%2Fgenerated%2Feoshift1_8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Feoshift1_8.c?ref=16bff92192676901670042cdce3fbd5f9c928fc8", "patch": "@@ -62,6 +62,7 @@ eoshift1 (gfc_array_char * const restrict ret,\n   index_type len;\n   index_type n;\n   index_type size;\n+  index_type arraysize;\n   int which;\n   GFC_INTEGER_8 sh;\n   GFC_INTEGER_8 delta;\n@@ -82,11 +83,12 @@ eoshift1 (gfc_array_char * const restrict ret,\n   extent[0] = 1;\n   count[0] = 0;\n \n+  arraysize = size0 ((array_t *) array);\n   if (ret->data == NULL)\n     {\n       int i;\n \n-      ret->data = internal_malloc_size (size * size0 ((array_t *)array));\n+      ret->data = internal_malloc_size (size * arraysize);\n       ret->offset = 0;\n       ret->dtype = array->dtype;\n       for (i = 0; i < GFC_DESCRIPTOR_RANK (array); i++)\n@@ -104,13 +106,27 @@ eoshift1 (gfc_array_char * const restrict ret,\n \t  GFC_DIMENSION_SET(ret->dim[i], 0, ub, str);\n \n         }\n+      if (arraysize > 0)\n+\tret->data = internal_malloc_size (size * arraysize);\n+      else\n+\tret->data = internal_malloc_size (1);\n+\n     }\n-  else\n+  else if (unlikely (compile_options.bounds_check))\n     {\n-      if (size0 ((array_t *) ret) == 0)\n-\treturn;\n+      bounds_equal_extents ((array_t *) ret, (array_t *) array,\n+\t\t\t\t \"return value\", \"EOSHIFT\");\n     }\n \n+  if (unlikely (compile_options.bounds_check))\n+    {\n+      bounds_reduced_extents ((array_t *) h, (array_t *) array, which,\n+      \t\t\t      \"SHIFT argument\", \"EOSHIFT\");\n+    }\n+\n+  if (arraysize == 0)\n+    return;\n+\n   n = 0;\n   for (dim = 0; dim < GFC_DESCRIPTOR_RANK (array); dim++)\n     {"}, {"sha": "ec21d1ec14dc1cf22455158eab8007d365ab3ab7", "filename": "libgfortran/generated/eoshift3_16.c", "status": "modified", "additions": 19, "deletions": 4, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/16bff92192676901670042cdce3fbd5f9c928fc8/libgfortran%2Fgenerated%2Feoshift3_16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/16bff92192676901670042cdce3fbd5f9c928fc8/libgfortran%2Fgenerated%2Feoshift3_16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Feoshift3_16.c?ref=16bff92192676901670042cdce3fbd5f9c928fc8", "patch": "@@ -66,6 +66,7 @@ eoshift3 (gfc_array_char * const restrict ret,\n   index_type len;\n   index_type n;\n   index_type size;\n+  index_type arraysize;\n   int which;\n   GFC_INTEGER_16 sh;\n   GFC_INTEGER_16 delta;\n@@ -76,6 +77,7 @@ eoshift3 (gfc_array_char * const restrict ret,\n   soffset = 0;\n   roffset = 0;\n \n+  arraysize = size0 ((array_t *) array);\n   size = GFC_DESCRIPTOR_SIZE(array);\n \n   if (pwhich)\n@@ -87,7 +89,7 @@ eoshift3 (gfc_array_char * const restrict ret,\n     {\n       int i;\n \n-      ret->data = internal_malloc_size (size * size0 ((array_t *)array));\n+      ret->data = internal_malloc_size (size * arraysize);\n       ret->offset = 0;\n       ret->dtype = array->dtype;\n       for (i = 0; i < GFC_DESCRIPTOR_RANK (array); i++)\n@@ -105,13 +107,26 @@ eoshift3 (gfc_array_char * const restrict ret,\n \t  GFC_DIMENSION_SET(ret->dim[i], 0, ub, str);\n \n         }\n+      if (arraysize > 0)\n+\tret->data = internal_malloc_size (size * arraysize);\n+      else\n+\tret->data = internal_malloc_size (1);\n+\n     }\n-  else\n+  else if (unlikely (compile_options.bounds_check))\n+    {\n+      bounds_equal_extents ((array_t *) ret, (array_t *) array,\n+\t\t\t\t \"return value\", \"EOSHIFT\");\n+    }\n+\n+  if (unlikely (compile_options.bounds_check))\n     {\n-      if (size0 ((array_t *) ret) == 0)\n-\treturn;\n+      bounds_reduced_extents ((array_t *) h, (array_t *) array, which,\n+      \t\t\t      \"SHIFT argument\", \"EOSHIFT\");\n     }\n \n+  if (arraysize == 0)\n+    return;\n \n   extent[0] = 1;\n   count[0] = 0;"}, {"sha": "ce4cede1f1d0dd57b2ea1ae5a7028bfff071e516", "filename": "libgfortran/generated/eoshift3_4.c", "status": "modified", "additions": 19, "deletions": 4, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/16bff92192676901670042cdce3fbd5f9c928fc8/libgfortran%2Fgenerated%2Feoshift3_4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/16bff92192676901670042cdce3fbd5f9c928fc8/libgfortran%2Fgenerated%2Feoshift3_4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Feoshift3_4.c?ref=16bff92192676901670042cdce3fbd5f9c928fc8", "patch": "@@ -66,6 +66,7 @@ eoshift3 (gfc_array_char * const restrict ret,\n   index_type len;\n   index_type n;\n   index_type size;\n+  index_type arraysize;\n   int which;\n   GFC_INTEGER_4 sh;\n   GFC_INTEGER_4 delta;\n@@ -76,6 +77,7 @@ eoshift3 (gfc_array_char * const restrict ret,\n   soffset = 0;\n   roffset = 0;\n \n+  arraysize = size0 ((array_t *) array);\n   size = GFC_DESCRIPTOR_SIZE(array);\n \n   if (pwhich)\n@@ -87,7 +89,7 @@ eoshift3 (gfc_array_char * const restrict ret,\n     {\n       int i;\n \n-      ret->data = internal_malloc_size (size * size0 ((array_t *)array));\n+      ret->data = internal_malloc_size (size * arraysize);\n       ret->offset = 0;\n       ret->dtype = array->dtype;\n       for (i = 0; i < GFC_DESCRIPTOR_RANK (array); i++)\n@@ -105,13 +107,26 @@ eoshift3 (gfc_array_char * const restrict ret,\n \t  GFC_DIMENSION_SET(ret->dim[i], 0, ub, str);\n \n         }\n+      if (arraysize > 0)\n+\tret->data = internal_malloc_size (size * arraysize);\n+      else\n+\tret->data = internal_malloc_size (1);\n+\n     }\n-  else\n+  else if (unlikely (compile_options.bounds_check))\n+    {\n+      bounds_equal_extents ((array_t *) ret, (array_t *) array,\n+\t\t\t\t \"return value\", \"EOSHIFT\");\n+    }\n+\n+  if (unlikely (compile_options.bounds_check))\n     {\n-      if (size0 ((array_t *) ret) == 0)\n-\treturn;\n+      bounds_reduced_extents ((array_t *) h, (array_t *) array, which,\n+      \t\t\t      \"SHIFT argument\", \"EOSHIFT\");\n     }\n \n+  if (arraysize == 0)\n+    return;\n \n   extent[0] = 1;\n   count[0] = 0;"}, {"sha": "4af36f72bb49e614a525439d95dfbb55a0e85b31", "filename": "libgfortran/generated/eoshift3_8.c", "status": "modified", "additions": 19, "deletions": 4, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/16bff92192676901670042cdce3fbd5f9c928fc8/libgfortran%2Fgenerated%2Feoshift3_8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/16bff92192676901670042cdce3fbd5f9c928fc8/libgfortran%2Fgenerated%2Feoshift3_8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Feoshift3_8.c?ref=16bff92192676901670042cdce3fbd5f9c928fc8", "patch": "@@ -66,6 +66,7 @@ eoshift3 (gfc_array_char * const restrict ret,\n   index_type len;\n   index_type n;\n   index_type size;\n+  index_type arraysize;\n   int which;\n   GFC_INTEGER_8 sh;\n   GFC_INTEGER_8 delta;\n@@ -76,6 +77,7 @@ eoshift3 (gfc_array_char * const restrict ret,\n   soffset = 0;\n   roffset = 0;\n \n+  arraysize = size0 ((array_t *) array);\n   size = GFC_DESCRIPTOR_SIZE(array);\n \n   if (pwhich)\n@@ -87,7 +89,7 @@ eoshift3 (gfc_array_char * const restrict ret,\n     {\n       int i;\n \n-      ret->data = internal_malloc_size (size * size0 ((array_t *)array));\n+      ret->data = internal_malloc_size (size * arraysize);\n       ret->offset = 0;\n       ret->dtype = array->dtype;\n       for (i = 0; i < GFC_DESCRIPTOR_RANK (array); i++)\n@@ -105,13 +107,26 @@ eoshift3 (gfc_array_char * const restrict ret,\n \t  GFC_DIMENSION_SET(ret->dim[i], 0, ub, str);\n \n         }\n+      if (arraysize > 0)\n+\tret->data = internal_malloc_size (size * arraysize);\n+      else\n+\tret->data = internal_malloc_size (1);\n+\n     }\n-  else\n+  else if (unlikely (compile_options.bounds_check))\n+    {\n+      bounds_equal_extents ((array_t *) ret, (array_t *) array,\n+\t\t\t\t \"return value\", \"EOSHIFT\");\n+    }\n+\n+  if (unlikely (compile_options.bounds_check))\n     {\n-      if (size0 ((array_t *) ret) == 0)\n-\treturn;\n+      bounds_reduced_extents ((array_t *) h, (array_t *) array, which,\n+      \t\t\t      \"SHIFT argument\", \"EOSHIFT\");\n     }\n \n+  if (arraysize == 0)\n+    return;\n \n   extent[0] = 1;\n   count[0] = 0;"}, {"sha": "c9f58e33ea632059630700b1f73a7eaa248ca545", "filename": "libgfortran/generated/maxloc0_16_i1.c", "status": "modified", "additions": 10, "deletions": 62, "changes": 72, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/16bff92192676901670042cdce3fbd5f9c928fc8/libgfortran%2Fgenerated%2Fmaxloc0_16_i1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/16bff92192676901670042cdce3fbd5f9c928fc8/libgfortran%2Fgenerated%2Fmaxloc0_16_i1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxloc0_16_i1.c?ref=16bff92192676901670042cdce3fbd5f9c928fc8", "patch": "@@ -63,21 +63,8 @@ maxloc0_16_i1 (gfc_array_i16 * const restrict retarray,\n   else\n     {\n       if (unlikely (compile_options.bounds_check))\n-\t{\n-\t  int ret_rank;\n-\t  index_type ret_extent;\n-\n-\t  ret_rank = GFC_DESCRIPTOR_RANK (retarray);\n-\t  if (ret_rank != 1)\n-\t    runtime_error (\"rank of return array in MAXLOC intrinsic\"\n-\t\t\t   \" should be 1, is %ld\", (long int) ret_rank);\n-\n-\t  ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,0);\n-\t  if (ret_extent != rank)\n-\t    runtime_error (\"Incorrect extent in return value of\"\n-\t\t\t   \" MAXLOC intrnisic: is %ld, should be %ld\",\n-\t\t\t   (long int) ret_extent, (long int) rank);\n-\t}\n+        bounds_iforeach_return ((array_t *) retarray, (array_t *) array,\n+\t                        \"MAXLOC\");\n     }\n \n   dstride = GFC_DESCRIPTOR_STRIDE(retarray,0);\n@@ -186,38 +173,11 @@ mmaxloc0_16_i1 (gfc_array_i16 * const restrict retarray,\n     {\n       if (unlikely (compile_options.bounds_check))\n \t{\n-\t  int ret_rank, mask_rank;\n-\t  index_type ret_extent;\n-\t  int n;\n-\t  index_type array_extent, mask_extent;\n-\n-\t  ret_rank = GFC_DESCRIPTOR_RANK (retarray);\n-\t  if (ret_rank != 1)\n-\t    runtime_error (\"rank of return array in MAXLOC intrinsic\"\n-\t\t\t   \" should be 1, is %ld\", (long int) ret_rank);\n-\n-\t  ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,0);\n-\t  if (ret_extent != rank)\n-\t    runtime_error (\"Incorrect extent in return value of\"\n-\t\t\t   \" MAXLOC intrnisic: is %ld, should be %ld\",\n-\t\t\t   (long int) ret_extent, (long int) rank);\n-\t\n-\t  mask_rank = GFC_DESCRIPTOR_RANK (mask);\n-\t  if (rank != mask_rank)\n-\t    runtime_error (\"rank of MASK argument in MAXLOC intrnisic\"\n-\t                   \"should be %ld, is %ld\", (long int) rank,\n-\t\t\t   (long int) mask_rank);\n-\n-\t  for (n=0; n<rank; n++)\n-\t    {\n-\t      array_extent = GFC_DESCRIPTOR_EXTENT(array,n);\n-\t      mask_extent = GFC_DESCRIPTOR_EXTENT(mask,n);\n-\t      if (array_extent != mask_extent)\n-\t\truntime_error (\"Incorrect extent in MASK argument of\"\n-\t\t\t       \" MAXLOC intrinsic in dimension %ld:\"\n-\t\t\t       \" is %ld, should be %ld\", (long int) n + 1,\n-\t\t\t       (long int) mask_extent, (long int) array_extent);\n-\t    }\n+\n+\t  bounds_iforeach_return ((array_t *) retarray, (array_t *) array,\n+\t\t\t\t  \"MAXLOC\");\n+\t  bounds_equal_extents ((array_t *) mask, (array_t *) array,\n+\t\t\t\t  \"MASK argument\", \"MAXLOC\");\n \t}\n     }\n \n@@ -340,22 +300,10 @@ smaxloc0_16_i1 (gfc_array_i16 * const restrict retarray,\n       retarray->offset = 0;\n       retarray->data = internal_malloc_size (sizeof (GFC_INTEGER_16) * rank);\n     }\n-  else\n+  else if (unlikely (compile_options.bounds_check))\n     {\n-      if (unlikely (compile_options.bounds_check))\n-\t{\n-\t  int ret_rank;\n-\t  index_type ret_extent;\n-\n-\t  ret_rank = GFC_DESCRIPTOR_RANK (retarray);\n-\t  if (ret_rank != 1)\n-\t    runtime_error (\"rank of return array in MAXLOC intrinsic\"\n-\t\t\t   \" should be 1, is %ld\", (long int) ret_rank);\n-\n-\t  ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,0);\n-\t    if (ret_extent != rank)\n-\t      runtime_error (\"dimension of return array incorrect\");\n-\t}\n+       bounds_iforeach_return ((array_t *) retarray, (array_t *) array,\n+\t\t\t       \"MAXLOC\");\n     }\n \n   dstride = GFC_DESCRIPTOR_STRIDE(retarray,0);"}, {"sha": "8adbc932279294586d769f959788d7377a2adc01", "filename": "libgfortran/generated/maxloc0_16_i16.c", "status": "modified", "additions": 10, "deletions": 62, "changes": 72, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/16bff92192676901670042cdce3fbd5f9c928fc8/libgfortran%2Fgenerated%2Fmaxloc0_16_i16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/16bff92192676901670042cdce3fbd5f9c928fc8/libgfortran%2Fgenerated%2Fmaxloc0_16_i16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxloc0_16_i16.c?ref=16bff92192676901670042cdce3fbd5f9c928fc8", "patch": "@@ -63,21 +63,8 @@ maxloc0_16_i16 (gfc_array_i16 * const restrict retarray,\n   else\n     {\n       if (unlikely (compile_options.bounds_check))\n-\t{\n-\t  int ret_rank;\n-\t  index_type ret_extent;\n-\n-\t  ret_rank = GFC_DESCRIPTOR_RANK (retarray);\n-\t  if (ret_rank != 1)\n-\t    runtime_error (\"rank of return array in MAXLOC intrinsic\"\n-\t\t\t   \" should be 1, is %ld\", (long int) ret_rank);\n-\n-\t  ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,0);\n-\t  if (ret_extent != rank)\n-\t    runtime_error (\"Incorrect extent in return value of\"\n-\t\t\t   \" MAXLOC intrnisic: is %ld, should be %ld\",\n-\t\t\t   (long int) ret_extent, (long int) rank);\n-\t}\n+        bounds_iforeach_return ((array_t *) retarray, (array_t *) array,\n+\t                        \"MAXLOC\");\n     }\n \n   dstride = GFC_DESCRIPTOR_STRIDE(retarray,0);\n@@ -186,38 +173,11 @@ mmaxloc0_16_i16 (gfc_array_i16 * const restrict retarray,\n     {\n       if (unlikely (compile_options.bounds_check))\n \t{\n-\t  int ret_rank, mask_rank;\n-\t  index_type ret_extent;\n-\t  int n;\n-\t  index_type array_extent, mask_extent;\n-\n-\t  ret_rank = GFC_DESCRIPTOR_RANK (retarray);\n-\t  if (ret_rank != 1)\n-\t    runtime_error (\"rank of return array in MAXLOC intrinsic\"\n-\t\t\t   \" should be 1, is %ld\", (long int) ret_rank);\n-\n-\t  ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,0);\n-\t  if (ret_extent != rank)\n-\t    runtime_error (\"Incorrect extent in return value of\"\n-\t\t\t   \" MAXLOC intrnisic: is %ld, should be %ld\",\n-\t\t\t   (long int) ret_extent, (long int) rank);\n-\t\n-\t  mask_rank = GFC_DESCRIPTOR_RANK (mask);\n-\t  if (rank != mask_rank)\n-\t    runtime_error (\"rank of MASK argument in MAXLOC intrnisic\"\n-\t                   \"should be %ld, is %ld\", (long int) rank,\n-\t\t\t   (long int) mask_rank);\n-\n-\t  for (n=0; n<rank; n++)\n-\t    {\n-\t      array_extent = GFC_DESCRIPTOR_EXTENT(array,n);\n-\t      mask_extent = GFC_DESCRIPTOR_EXTENT(mask,n);\n-\t      if (array_extent != mask_extent)\n-\t\truntime_error (\"Incorrect extent in MASK argument of\"\n-\t\t\t       \" MAXLOC intrinsic in dimension %ld:\"\n-\t\t\t       \" is %ld, should be %ld\", (long int) n + 1,\n-\t\t\t       (long int) mask_extent, (long int) array_extent);\n-\t    }\n+\n+\t  bounds_iforeach_return ((array_t *) retarray, (array_t *) array,\n+\t\t\t\t  \"MAXLOC\");\n+\t  bounds_equal_extents ((array_t *) mask, (array_t *) array,\n+\t\t\t\t  \"MASK argument\", \"MAXLOC\");\n \t}\n     }\n \n@@ -340,22 +300,10 @@ smaxloc0_16_i16 (gfc_array_i16 * const restrict retarray,\n       retarray->offset = 0;\n       retarray->data = internal_malloc_size (sizeof (GFC_INTEGER_16) * rank);\n     }\n-  else\n+  else if (unlikely (compile_options.bounds_check))\n     {\n-      if (unlikely (compile_options.bounds_check))\n-\t{\n-\t  int ret_rank;\n-\t  index_type ret_extent;\n-\n-\t  ret_rank = GFC_DESCRIPTOR_RANK (retarray);\n-\t  if (ret_rank != 1)\n-\t    runtime_error (\"rank of return array in MAXLOC intrinsic\"\n-\t\t\t   \" should be 1, is %ld\", (long int) ret_rank);\n-\n-\t  ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,0);\n-\t    if (ret_extent != rank)\n-\t      runtime_error (\"dimension of return array incorrect\");\n-\t}\n+       bounds_iforeach_return ((array_t *) retarray, (array_t *) array,\n+\t\t\t       \"MAXLOC\");\n     }\n \n   dstride = GFC_DESCRIPTOR_STRIDE(retarray,0);"}, {"sha": "16849c273636d9df66e4815cfdaf6e95e845405c", "filename": "libgfortran/generated/maxloc0_16_i2.c", "status": "modified", "additions": 10, "deletions": 62, "changes": 72, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/16bff92192676901670042cdce3fbd5f9c928fc8/libgfortran%2Fgenerated%2Fmaxloc0_16_i2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/16bff92192676901670042cdce3fbd5f9c928fc8/libgfortran%2Fgenerated%2Fmaxloc0_16_i2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxloc0_16_i2.c?ref=16bff92192676901670042cdce3fbd5f9c928fc8", "patch": "@@ -63,21 +63,8 @@ maxloc0_16_i2 (gfc_array_i16 * const restrict retarray,\n   else\n     {\n       if (unlikely (compile_options.bounds_check))\n-\t{\n-\t  int ret_rank;\n-\t  index_type ret_extent;\n-\n-\t  ret_rank = GFC_DESCRIPTOR_RANK (retarray);\n-\t  if (ret_rank != 1)\n-\t    runtime_error (\"rank of return array in MAXLOC intrinsic\"\n-\t\t\t   \" should be 1, is %ld\", (long int) ret_rank);\n-\n-\t  ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,0);\n-\t  if (ret_extent != rank)\n-\t    runtime_error (\"Incorrect extent in return value of\"\n-\t\t\t   \" MAXLOC intrnisic: is %ld, should be %ld\",\n-\t\t\t   (long int) ret_extent, (long int) rank);\n-\t}\n+        bounds_iforeach_return ((array_t *) retarray, (array_t *) array,\n+\t                        \"MAXLOC\");\n     }\n \n   dstride = GFC_DESCRIPTOR_STRIDE(retarray,0);\n@@ -186,38 +173,11 @@ mmaxloc0_16_i2 (gfc_array_i16 * const restrict retarray,\n     {\n       if (unlikely (compile_options.bounds_check))\n \t{\n-\t  int ret_rank, mask_rank;\n-\t  index_type ret_extent;\n-\t  int n;\n-\t  index_type array_extent, mask_extent;\n-\n-\t  ret_rank = GFC_DESCRIPTOR_RANK (retarray);\n-\t  if (ret_rank != 1)\n-\t    runtime_error (\"rank of return array in MAXLOC intrinsic\"\n-\t\t\t   \" should be 1, is %ld\", (long int) ret_rank);\n-\n-\t  ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,0);\n-\t  if (ret_extent != rank)\n-\t    runtime_error (\"Incorrect extent in return value of\"\n-\t\t\t   \" MAXLOC intrnisic: is %ld, should be %ld\",\n-\t\t\t   (long int) ret_extent, (long int) rank);\n-\t\n-\t  mask_rank = GFC_DESCRIPTOR_RANK (mask);\n-\t  if (rank != mask_rank)\n-\t    runtime_error (\"rank of MASK argument in MAXLOC intrnisic\"\n-\t                   \"should be %ld, is %ld\", (long int) rank,\n-\t\t\t   (long int) mask_rank);\n-\n-\t  for (n=0; n<rank; n++)\n-\t    {\n-\t      array_extent = GFC_DESCRIPTOR_EXTENT(array,n);\n-\t      mask_extent = GFC_DESCRIPTOR_EXTENT(mask,n);\n-\t      if (array_extent != mask_extent)\n-\t\truntime_error (\"Incorrect extent in MASK argument of\"\n-\t\t\t       \" MAXLOC intrinsic in dimension %ld:\"\n-\t\t\t       \" is %ld, should be %ld\", (long int) n + 1,\n-\t\t\t       (long int) mask_extent, (long int) array_extent);\n-\t    }\n+\n+\t  bounds_iforeach_return ((array_t *) retarray, (array_t *) array,\n+\t\t\t\t  \"MAXLOC\");\n+\t  bounds_equal_extents ((array_t *) mask, (array_t *) array,\n+\t\t\t\t  \"MASK argument\", \"MAXLOC\");\n \t}\n     }\n \n@@ -340,22 +300,10 @@ smaxloc0_16_i2 (gfc_array_i16 * const restrict retarray,\n       retarray->offset = 0;\n       retarray->data = internal_malloc_size (sizeof (GFC_INTEGER_16) * rank);\n     }\n-  else\n+  else if (unlikely (compile_options.bounds_check))\n     {\n-      if (unlikely (compile_options.bounds_check))\n-\t{\n-\t  int ret_rank;\n-\t  index_type ret_extent;\n-\n-\t  ret_rank = GFC_DESCRIPTOR_RANK (retarray);\n-\t  if (ret_rank != 1)\n-\t    runtime_error (\"rank of return array in MAXLOC intrinsic\"\n-\t\t\t   \" should be 1, is %ld\", (long int) ret_rank);\n-\n-\t  ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,0);\n-\t    if (ret_extent != rank)\n-\t      runtime_error (\"dimension of return array incorrect\");\n-\t}\n+       bounds_iforeach_return ((array_t *) retarray, (array_t *) array,\n+\t\t\t       \"MAXLOC\");\n     }\n \n   dstride = GFC_DESCRIPTOR_STRIDE(retarray,0);"}, {"sha": "a6e979ce489a5f52e77b597b4753845a48f494df", "filename": "libgfortran/generated/maxloc0_16_i4.c", "status": "modified", "additions": 10, "deletions": 62, "changes": 72, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/16bff92192676901670042cdce3fbd5f9c928fc8/libgfortran%2Fgenerated%2Fmaxloc0_16_i4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/16bff92192676901670042cdce3fbd5f9c928fc8/libgfortran%2Fgenerated%2Fmaxloc0_16_i4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxloc0_16_i4.c?ref=16bff92192676901670042cdce3fbd5f9c928fc8", "patch": "@@ -63,21 +63,8 @@ maxloc0_16_i4 (gfc_array_i16 * const restrict retarray,\n   else\n     {\n       if (unlikely (compile_options.bounds_check))\n-\t{\n-\t  int ret_rank;\n-\t  index_type ret_extent;\n-\n-\t  ret_rank = GFC_DESCRIPTOR_RANK (retarray);\n-\t  if (ret_rank != 1)\n-\t    runtime_error (\"rank of return array in MAXLOC intrinsic\"\n-\t\t\t   \" should be 1, is %ld\", (long int) ret_rank);\n-\n-\t  ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,0);\n-\t  if (ret_extent != rank)\n-\t    runtime_error (\"Incorrect extent in return value of\"\n-\t\t\t   \" MAXLOC intrnisic: is %ld, should be %ld\",\n-\t\t\t   (long int) ret_extent, (long int) rank);\n-\t}\n+        bounds_iforeach_return ((array_t *) retarray, (array_t *) array,\n+\t                        \"MAXLOC\");\n     }\n \n   dstride = GFC_DESCRIPTOR_STRIDE(retarray,0);\n@@ -186,38 +173,11 @@ mmaxloc0_16_i4 (gfc_array_i16 * const restrict retarray,\n     {\n       if (unlikely (compile_options.bounds_check))\n \t{\n-\t  int ret_rank, mask_rank;\n-\t  index_type ret_extent;\n-\t  int n;\n-\t  index_type array_extent, mask_extent;\n-\n-\t  ret_rank = GFC_DESCRIPTOR_RANK (retarray);\n-\t  if (ret_rank != 1)\n-\t    runtime_error (\"rank of return array in MAXLOC intrinsic\"\n-\t\t\t   \" should be 1, is %ld\", (long int) ret_rank);\n-\n-\t  ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,0);\n-\t  if (ret_extent != rank)\n-\t    runtime_error (\"Incorrect extent in return value of\"\n-\t\t\t   \" MAXLOC intrnisic: is %ld, should be %ld\",\n-\t\t\t   (long int) ret_extent, (long int) rank);\n-\t\n-\t  mask_rank = GFC_DESCRIPTOR_RANK (mask);\n-\t  if (rank != mask_rank)\n-\t    runtime_error (\"rank of MASK argument in MAXLOC intrnisic\"\n-\t                   \"should be %ld, is %ld\", (long int) rank,\n-\t\t\t   (long int) mask_rank);\n-\n-\t  for (n=0; n<rank; n++)\n-\t    {\n-\t      array_extent = GFC_DESCRIPTOR_EXTENT(array,n);\n-\t      mask_extent = GFC_DESCRIPTOR_EXTENT(mask,n);\n-\t      if (array_extent != mask_extent)\n-\t\truntime_error (\"Incorrect extent in MASK argument of\"\n-\t\t\t       \" MAXLOC intrinsic in dimension %ld:\"\n-\t\t\t       \" is %ld, should be %ld\", (long int) n + 1,\n-\t\t\t       (long int) mask_extent, (long int) array_extent);\n-\t    }\n+\n+\t  bounds_iforeach_return ((array_t *) retarray, (array_t *) array,\n+\t\t\t\t  \"MAXLOC\");\n+\t  bounds_equal_extents ((array_t *) mask, (array_t *) array,\n+\t\t\t\t  \"MASK argument\", \"MAXLOC\");\n \t}\n     }\n \n@@ -340,22 +300,10 @@ smaxloc0_16_i4 (gfc_array_i16 * const restrict retarray,\n       retarray->offset = 0;\n       retarray->data = internal_malloc_size (sizeof (GFC_INTEGER_16) * rank);\n     }\n-  else\n+  else if (unlikely (compile_options.bounds_check))\n     {\n-      if (unlikely (compile_options.bounds_check))\n-\t{\n-\t  int ret_rank;\n-\t  index_type ret_extent;\n-\n-\t  ret_rank = GFC_DESCRIPTOR_RANK (retarray);\n-\t  if (ret_rank != 1)\n-\t    runtime_error (\"rank of return array in MAXLOC intrinsic\"\n-\t\t\t   \" should be 1, is %ld\", (long int) ret_rank);\n-\n-\t  ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,0);\n-\t    if (ret_extent != rank)\n-\t      runtime_error (\"dimension of return array incorrect\");\n-\t}\n+       bounds_iforeach_return ((array_t *) retarray, (array_t *) array,\n+\t\t\t       \"MAXLOC\");\n     }\n \n   dstride = GFC_DESCRIPTOR_STRIDE(retarray,0);"}, {"sha": "8e2d4bc0a3519f8094647c504b37de1cca32a2e4", "filename": "libgfortran/generated/maxloc0_16_i8.c", "status": "modified", "additions": 10, "deletions": 62, "changes": 72, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/16bff92192676901670042cdce3fbd5f9c928fc8/libgfortran%2Fgenerated%2Fmaxloc0_16_i8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/16bff92192676901670042cdce3fbd5f9c928fc8/libgfortran%2Fgenerated%2Fmaxloc0_16_i8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxloc0_16_i8.c?ref=16bff92192676901670042cdce3fbd5f9c928fc8", "patch": "@@ -63,21 +63,8 @@ maxloc0_16_i8 (gfc_array_i16 * const restrict retarray,\n   else\n     {\n       if (unlikely (compile_options.bounds_check))\n-\t{\n-\t  int ret_rank;\n-\t  index_type ret_extent;\n-\n-\t  ret_rank = GFC_DESCRIPTOR_RANK (retarray);\n-\t  if (ret_rank != 1)\n-\t    runtime_error (\"rank of return array in MAXLOC intrinsic\"\n-\t\t\t   \" should be 1, is %ld\", (long int) ret_rank);\n-\n-\t  ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,0);\n-\t  if (ret_extent != rank)\n-\t    runtime_error (\"Incorrect extent in return value of\"\n-\t\t\t   \" MAXLOC intrnisic: is %ld, should be %ld\",\n-\t\t\t   (long int) ret_extent, (long int) rank);\n-\t}\n+        bounds_iforeach_return ((array_t *) retarray, (array_t *) array,\n+\t                        \"MAXLOC\");\n     }\n \n   dstride = GFC_DESCRIPTOR_STRIDE(retarray,0);\n@@ -186,38 +173,11 @@ mmaxloc0_16_i8 (gfc_array_i16 * const restrict retarray,\n     {\n       if (unlikely (compile_options.bounds_check))\n \t{\n-\t  int ret_rank, mask_rank;\n-\t  index_type ret_extent;\n-\t  int n;\n-\t  index_type array_extent, mask_extent;\n-\n-\t  ret_rank = GFC_DESCRIPTOR_RANK (retarray);\n-\t  if (ret_rank != 1)\n-\t    runtime_error (\"rank of return array in MAXLOC intrinsic\"\n-\t\t\t   \" should be 1, is %ld\", (long int) ret_rank);\n-\n-\t  ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,0);\n-\t  if (ret_extent != rank)\n-\t    runtime_error (\"Incorrect extent in return value of\"\n-\t\t\t   \" MAXLOC intrnisic: is %ld, should be %ld\",\n-\t\t\t   (long int) ret_extent, (long int) rank);\n-\t\n-\t  mask_rank = GFC_DESCRIPTOR_RANK (mask);\n-\t  if (rank != mask_rank)\n-\t    runtime_error (\"rank of MASK argument in MAXLOC intrnisic\"\n-\t                   \"should be %ld, is %ld\", (long int) rank,\n-\t\t\t   (long int) mask_rank);\n-\n-\t  for (n=0; n<rank; n++)\n-\t    {\n-\t      array_extent = GFC_DESCRIPTOR_EXTENT(array,n);\n-\t      mask_extent = GFC_DESCRIPTOR_EXTENT(mask,n);\n-\t      if (array_extent != mask_extent)\n-\t\truntime_error (\"Incorrect extent in MASK argument of\"\n-\t\t\t       \" MAXLOC intrinsic in dimension %ld:\"\n-\t\t\t       \" is %ld, should be %ld\", (long int) n + 1,\n-\t\t\t       (long int) mask_extent, (long int) array_extent);\n-\t    }\n+\n+\t  bounds_iforeach_return ((array_t *) retarray, (array_t *) array,\n+\t\t\t\t  \"MAXLOC\");\n+\t  bounds_equal_extents ((array_t *) mask, (array_t *) array,\n+\t\t\t\t  \"MASK argument\", \"MAXLOC\");\n \t}\n     }\n \n@@ -340,22 +300,10 @@ smaxloc0_16_i8 (gfc_array_i16 * const restrict retarray,\n       retarray->offset = 0;\n       retarray->data = internal_malloc_size (sizeof (GFC_INTEGER_16) * rank);\n     }\n-  else\n+  else if (unlikely (compile_options.bounds_check))\n     {\n-      if (unlikely (compile_options.bounds_check))\n-\t{\n-\t  int ret_rank;\n-\t  index_type ret_extent;\n-\n-\t  ret_rank = GFC_DESCRIPTOR_RANK (retarray);\n-\t  if (ret_rank != 1)\n-\t    runtime_error (\"rank of return array in MAXLOC intrinsic\"\n-\t\t\t   \" should be 1, is %ld\", (long int) ret_rank);\n-\n-\t  ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,0);\n-\t    if (ret_extent != rank)\n-\t      runtime_error (\"dimension of return array incorrect\");\n-\t}\n+       bounds_iforeach_return ((array_t *) retarray, (array_t *) array,\n+\t\t\t       \"MAXLOC\");\n     }\n \n   dstride = GFC_DESCRIPTOR_STRIDE(retarray,0);"}, {"sha": "d76e947aa0d81fcb7eb5ab27b11915bc4855ff87", "filename": "libgfortran/generated/maxloc0_16_r10.c", "status": "modified", "additions": 10, "deletions": 62, "changes": 72, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/16bff92192676901670042cdce3fbd5f9c928fc8/libgfortran%2Fgenerated%2Fmaxloc0_16_r10.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/16bff92192676901670042cdce3fbd5f9c928fc8/libgfortran%2Fgenerated%2Fmaxloc0_16_r10.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxloc0_16_r10.c?ref=16bff92192676901670042cdce3fbd5f9c928fc8", "patch": "@@ -63,21 +63,8 @@ maxloc0_16_r10 (gfc_array_i16 * const restrict retarray,\n   else\n     {\n       if (unlikely (compile_options.bounds_check))\n-\t{\n-\t  int ret_rank;\n-\t  index_type ret_extent;\n-\n-\t  ret_rank = GFC_DESCRIPTOR_RANK (retarray);\n-\t  if (ret_rank != 1)\n-\t    runtime_error (\"rank of return array in MAXLOC intrinsic\"\n-\t\t\t   \" should be 1, is %ld\", (long int) ret_rank);\n-\n-\t  ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,0);\n-\t  if (ret_extent != rank)\n-\t    runtime_error (\"Incorrect extent in return value of\"\n-\t\t\t   \" MAXLOC intrnisic: is %ld, should be %ld\",\n-\t\t\t   (long int) ret_extent, (long int) rank);\n-\t}\n+        bounds_iforeach_return ((array_t *) retarray, (array_t *) array,\n+\t                        \"MAXLOC\");\n     }\n \n   dstride = GFC_DESCRIPTOR_STRIDE(retarray,0);\n@@ -186,38 +173,11 @@ mmaxloc0_16_r10 (gfc_array_i16 * const restrict retarray,\n     {\n       if (unlikely (compile_options.bounds_check))\n \t{\n-\t  int ret_rank, mask_rank;\n-\t  index_type ret_extent;\n-\t  int n;\n-\t  index_type array_extent, mask_extent;\n-\n-\t  ret_rank = GFC_DESCRIPTOR_RANK (retarray);\n-\t  if (ret_rank != 1)\n-\t    runtime_error (\"rank of return array in MAXLOC intrinsic\"\n-\t\t\t   \" should be 1, is %ld\", (long int) ret_rank);\n-\n-\t  ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,0);\n-\t  if (ret_extent != rank)\n-\t    runtime_error (\"Incorrect extent in return value of\"\n-\t\t\t   \" MAXLOC intrnisic: is %ld, should be %ld\",\n-\t\t\t   (long int) ret_extent, (long int) rank);\n-\t\n-\t  mask_rank = GFC_DESCRIPTOR_RANK (mask);\n-\t  if (rank != mask_rank)\n-\t    runtime_error (\"rank of MASK argument in MAXLOC intrnisic\"\n-\t                   \"should be %ld, is %ld\", (long int) rank,\n-\t\t\t   (long int) mask_rank);\n-\n-\t  for (n=0; n<rank; n++)\n-\t    {\n-\t      array_extent = GFC_DESCRIPTOR_EXTENT(array,n);\n-\t      mask_extent = GFC_DESCRIPTOR_EXTENT(mask,n);\n-\t      if (array_extent != mask_extent)\n-\t\truntime_error (\"Incorrect extent in MASK argument of\"\n-\t\t\t       \" MAXLOC intrinsic in dimension %ld:\"\n-\t\t\t       \" is %ld, should be %ld\", (long int) n + 1,\n-\t\t\t       (long int) mask_extent, (long int) array_extent);\n-\t    }\n+\n+\t  bounds_iforeach_return ((array_t *) retarray, (array_t *) array,\n+\t\t\t\t  \"MAXLOC\");\n+\t  bounds_equal_extents ((array_t *) mask, (array_t *) array,\n+\t\t\t\t  \"MASK argument\", \"MAXLOC\");\n \t}\n     }\n \n@@ -340,22 +300,10 @@ smaxloc0_16_r10 (gfc_array_i16 * const restrict retarray,\n       retarray->offset = 0;\n       retarray->data = internal_malloc_size (sizeof (GFC_INTEGER_16) * rank);\n     }\n-  else\n+  else if (unlikely (compile_options.bounds_check))\n     {\n-      if (unlikely (compile_options.bounds_check))\n-\t{\n-\t  int ret_rank;\n-\t  index_type ret_extent;\n-\n-\t  ret_rank = GFC_DESCRIPTOR_RANK (retarray);\n-\t  if (ret_rank != 1)\n-\t    runtime_error (\"rank of return array in MAXLOC intrinsic\"\n-\t\t\t   \" should be 1, is %ld\", (long int) ret_rank);\n-\n-\t  ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,0);\n-\t    if (ret_extent != rank)\n-\t      runtime_error (\"dimension of return array incorrect\");\n-\t}\n+       bounds_iforeach_return ((array_t *) retarray, (array_t *) array,\n+\t\t\t       \"MAXLOC\");\n     }\n \n   dstride = GFC_DESCRIPTOR_STRIDE(retarray,0);"}, {"sha": "2e6dcf1dcfa7cf7f59b92131ed5cbe1dc8c99938", "filename": "libgfortran/generated/maxloc0_16_r16.c", "status": "modified", "additions": 10, "deletions": 62, "changes": 72, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/16bff92192676901670042cdce3fbd5f9c928fc8/libgfortran%2Fgenerated%2Fmaxloc0_16_r16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/16bff92192676901670042cdce3fbd5f9c928fc8/libgfortran%2Fgenerated%2Fmaxloc0_16_r16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxloc0_16_r16.c?ref=16bff92192676901670042cdce3fbd5f9c928fc8", "patch": "@@ -63,21 +63,8 @@ maxloc0_16_r16 (gfc_array_i16 * const restrict retarray,\n   else\n     {\n       if (unlikely (compile_options.bounds_check))\n-\t{\n-\t  int ret_rank;\n-\t  index_type ret_extent;\n-\n-\t  ret_rank = GFC_DESCRIPTOR_RANK (retarray);\n-\t  if (ret_rank != 1)\n-\t    runtime_error (\"rank of return array in MAXLOC intrinsic\"\n-\t\t\t   \" should be 1, is %ld\", (long int) ret_rank);\n-\n-\t  ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,0);\n-\t  if (ret_extent != rank)\n-\t    runtime_error (\"Incorrect extent in return value of\"\n-\t\t\t   \" MAXLOC intrnisic: is %ld, should be %ld\",\n-\t\t\t   (long int) ret_extent, (long int) rank);\n-\t}\n+        bounds_iforeach_return ((array_t *) retarray, (array_t *) array,\n+\t                        \"MAXLOC\");\n     }\n \n   dstride = GFC_DESCRIPTOR_STRIDE(retarray,0);\n@@ -186,38 +173,11 @@ mmaxloc0_16_r16 (gfc_array_i16 * const restrict retarray,\n     {\n       if (unlikely (compile_options.bounds_check))\n \t{\n-\t  int ret_rank, mask_rank;\n-\t  index_type ret_extent;\n-\t  int n;\n-\t  index_type array_extent, mask_extent;\n-\n-\t  ret_rank = GFC_DESCRIPTOR_RANK (retarray);\n-\t  if (ret_rank != 1)\n-\t    runtime_error (\"rank of return array in MAXLOC intrinsic\"\n-\t\t\t   \" should be 1, is %ld\", (long int) ret_rank);\n-\n-\t  ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,0);\n-\t  if (ret_extent != rank)\n-\t    runtime_error (\"Incorrect extent in return value of\"\n-\t\t\t   \" MAXLOC intrnisic: is %ld, should be %ld\",\n-\t\t\t   (long int) ret_extent, (long int) rank);\n-\t\n-\t  mask_rank = GFC_DESCRIPTOR_RANK (mask);\n-\t  if (rank != mask_rank)\n-\t    runtime_error (\"rank of MASK argument in MAXLOC intrnisic\"\n-\t                   \"should be %ld, is %ld\", (long int) rank,\n-\t\t\t   (long int) mask_rank);\n-\n-\t  for (n=0; n<rank; n++)\n-\t    {\n-\t      array_extent = GFC_DESCRIPTOR_EXTENT(array,n);\n-\t      mask_extent = GFC_DESCRIPTOR_EXTENT(mask,n);\n-\t      if (array_extent != mask_extent)\n-\t\truntime_error (\"Incorrect extent in MASK argument of\"\n-\t\t\t       \" MAXLOC intrinsic in dimension %ld:\"\n-\t\t\t       \" is %ld, should be %ld\", (long int) n + 1,\n-\t\t\t       (long int) mask_extent, (long int) array_extent);\n-\t    }\n+\n+\t  bounds_iforeach_return ((array_t *) retarray, (array_t *) array,\n+\t\t\t\t  \"MAXLOC\");\n+\t  bounds_equal_extents ((array_t *) mask, (array_t *) array,\n+\t\t\t\t  \"MASK argument\", \"MAXLOC\");\n \t}\n     }\n \n@@ -340,22 +300,10 @@ smaxloc0_16_r16 (gfc_array_i16 * const restrict retarray,\n       retarray->offset = 0;\n       retarray->data = internal_malloc_size (sizeof (GFC_INTEGER_16) * rank);\n     }\n-  else\n+  else if (unlikely (compile_options.bounds_check))\n     {\n-      if (unlikely (compile_options.bounds_check))\n-\t{\n-\t  int ret_rank;\n-\t  index_type ret_extent;\n-\n-\t  ret_rank = GFC_DESCRIPTOR_RANK (retarray);\n-\t  if (ret_rank != 1)\n-\t    runtime_error (\"rank of return array in MAXLOC intrinsic\"\n-\t\t\t   \" should be 1, is %ld\", (long int) ret_rank);\n-\n-\t  ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,0);\n-\t    if (ret_extent != rank)\n-\t      runtime_error (\"dimension of return array incorrect\");\n-\t}\n+       bounds_iforeach_return ((array_t *) retarray, (array_t *) array,\n+\t\t\t       \"MAXLOC\");\n     }\n \n   dstride = GFC_DESCRIPTOR_STRIDE(retarray,0);"}, {"sha": "5d1fe355fafccaed188d1edda862df988dca2e72", "filename": "libgfortran/generated/maxloc0_16_r4.c", "status": "modified", "additions": 10, "deletions": 62, "changes": 72, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/16bff92192676901670042cdce3fbd5f9c928fc8/libgfortran%2Fgenerated%2Fmaxloc0_16_r4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/16bff92192676901670042cdce3fbd5f9c928fc8/libgfortran%2Fgenerated%2Fmaxloc0_16_r4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxloc0_16_r4.c?ref=16bff92192676901670042cdce3fbd5f9c928fc8", "patch": "@@ -63,21 +63,8 @@ maxloc0_16_r4 (gfc_array_i16 * const restrict retarray,\n   else\n     {\n       if (unlikely (compile_options.bounds_check))\n-\t{\n-\t  int ret_rank;\n-\t  index_type ret_extent;\n-\n-\t  ret_rank = GFC_DESCRIPTOR_RANK (retarray);\n-\t  if (ret_rank != 1)\n-\t    runtime_error (\"rank of return array in MAXLOC intrinsic\"\n-\t\t\t   \" should be 1, is %ld\", (long int) ret_rank);\n-\n-\t  ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,0);\n-\t  if (ret_extent != rank)\n-\t    runtime_error (\"Incorrect extent in return value of\"\n-\t\t\t   \" MAXLOC intrnisic: is %ld, should be %ld\",\n-\t\t\t   (long int) ret_extent, (long int) rank);\n-\t}\n+        bounds_iforeach_return ((array_t *) retarray, (array_t *) array,\n+\t                        \"MAXLOC\");\n     }\n \n   dstride = GFC_DESCRIPTOR_STRIDE(retarray,0);\n@@ -186,38 +173,11 @@ mmaxloc0_16_r4 (gfc_array_i16 * const restrict retarray,\n     {\n       if (unlikely (compile_options.bounds_check))\n \t{\n-\t  int ret_rank, mask_rank;\n-\t  index_type ret_extent;\n-\t  int n;\n-\t  index_type array_extent, mask_extent;\n-\n-\t  ret_rank = GFC_DESCRIPTOR_RANK (retarray);\n-\t  if (ret_rank != 1)\n-\t    runtime_error (\"rank of return array in MAXLOC intrinsic\"\n-\t\t\t   \" should be 1, is %ld\", (long int) ret_rank);\n-\n-\t  ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,0);\n-\t  if (ret_extent != rank)\n-\t    runtime_error (\"Incorrect extent in return value of\"\n-\t\t\t   \" MAXLOC intrnisic: is %ld, should be %ld\",\n-\t\t\t   (long int) ret_extent, (long int) rank);\n-\t\n-\t  mask_rank = GFC_DESCRIPTOR_RANK (mask);\n-\t  if (rank != mask_rank)\n-\t    runtime_error (\"rank of MASK argument in MAXLOC intrnisic\"\n-\t                   \"should be %ld, is %ld\", (long int) rank,\n-\t\t\t   (long int) mask_rank);\n-\n-\t  for (n=0; n<rank; n++)\n-\t    {\n-\t      array_extent = GFC_DESCRIPTOR_EXTENT(array,n);\n-\t      mask_extent = GFC_DESCRIPTOR_EXTENT(mask,n);\n-\t      if (array_extent != mask_extent)\n-\t\truntime_error (\"Incorrect extent in MASK argument of\"\n-\t\t\t       \" MAXLOC intrinsic in dimension %ld:\"\n-\t\t\t       \" is %ld, should be %ld\", (long int) n + 1,\n-\t\t\t       (long int) mask_extent, (long int) array_extent);\n-\t    }\n+\n+\t  bounds_iforeach_return ((array_t *) retarray, (array_t *) array,\n+\t\t\t\t  \"MAXLOC\");\n+\t  bounds_equal_extents ((array_t *) mask, (array_t *) array,\n+\t\t\t\t  \"MASK argument\", \"MAXLOC\");\n \t}\n     }\n \n@@ -340,22 +300,10 @@ smaxloc0_16_r4 (gfc_array_i16 * const restrict retarray,\n       retarray->offset = 0;\n       retarray->data = internal_malloc_size (sizeof (GFC_INTEGER_16) * rank);\n     }\n-  else\n+  else if (unlikely (compile_options.bounds_check))\n     {\n-      if (unlikely (compile_options.bounds_check))\n-\t{\n-\t  int ret_rank;\n-\t  index_type ret_extent;\n-\n-\t  ret_rank = GFC_DESCRIPTOR_RANK (retarray);\n-\t  if (ret_rank != 1)\n-\t    runtime_error (\"rank of return array in MAXLOC intrinsic\"\n-\t\t\t   \" should be 1, is %ld\", (long int) ret_rank);\n-\n-\t  ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,0);\n-\t    if (ret_extent != rank)\n-\t      runtime_error (\"dimension of return array incorrect\");\n-\t}\n+       bounds_iforeach_return ((array_t *) retarray, (array_t *) array,\n+\t\t\t       \"MAXLOC\");\n     }\n \n   dstride = GFC_DESCRIPTOR_STRIDE(retarray,0);"}, {"sha": "dc489f311165568769d09f57557c7f854d10c6a1", "filename": "libgfortran/generated/maxloc0_16_r8.c", "status": "modified", "additions": 10, "deletions": 62, "changes": 72, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/16bff92192676901670042cdce3fbd5f9c928fc8/libgfortran%2Fgenerated%2Fmaxloc0_16_r8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/16bff92192676901670042cdce3fbd5f9c928fc8/libgfortran%2Fgenerated%2Fmaxloc0_16_r8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxloc0_16_r8.c?ref=16bff92192676901670042cdce3fbd5f9c928fc8", "patch": "@@ -63,21 +63,8 @@ maxloc0_16_r8 (gfc_array_i16 * const restrict retarray,\n   else\n     {\n       if (unlikely (compile_options.bounds_check))\n-\t{\n-\t  int ret_rank;\n-\t  index_type ret_extent;\n-\n-\t  ret_rank = GFC_DESCRIPTOR_RANK (retarray);\n-\t  if (ret_rank != 1)\n-\t    runtime_error (\"rank of return array in MAXLOC intrinsic\"\n-\t\t\t   \" should be 1, is %ld\", (long int) ret_rank);\n-\n-\t  ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,0);\n-\t  if (ret_extent != rank)\n-\t    runtime_error (\"Incorrect extent in return value of\"\n-\t\t\t   \" MAXLOC intrnisic: is %ld, should be %ld\",\n-\t\t\t   (long int) ret_extent, (long int) rank);\n-\t}\n+        bounds_iforeach_return ((array_t *) retarray, (array_t *) array,\n+\t                        \"MAXLOC\");\n     }\n \n   dstride = GFC_DESCRIPTOR_STRIDE(retarray,0);\n@@ -186,38 +173,11 @@ mmaxloc0_16_r8 (gfc_array_i16 * const restrict retarray,\n     {\n       if (unlikely (compile_options.bounds_check))\n \t{\n-\t  int ret_rank, mask_rank;\n-\t  index_type ret_extent;\n-\t  int n;\n-\t  index_type array_extent, mask_extent;\n-\n-\t  ret_rank = GFC_DESCRIPTOR_RANK (retarray);\n-\t  if (ret_rank != 1)\n-\t    runtime_error (\"rank of return array in MAXLOC intrinsic\"\n-\t\t\t   \" should be 1, is %ld\", (long int) ret_rank);\n-\n-\t  ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,0);\n-\t  if (ret_extent != rank)\n-\t    runtime_error (\"Incorrect extent in return value of\"\n-\t\t\t   \" MAXLOC intrnisic: is %ld, should be %ld\",\n-\t\t\t   (long int) ret_extent, (long int) rank);\n-\t\n-\t  mask_rank = GFC_DESCRIPTOR_RANK (mask);\n-\t  if (rank != mask_rank)\n-\t    runtime_error (\"rank of MASK argument in MAXLOC intrnisic\"\n-\t                   \"should be %ld, is %ld\", (long int) rank,\n-\t\t\t   (long int) mask_rank);\n-\n-\t  for (n=0; n<rank; n++)\n-\t    {\n-\t      array_extent = GFC_DESCRIPTOR_EXTENT(array,n);\n-\t      mask_extent = GFC_DESCRIPTOR_EXTENT(mask,n);\n-\t      if (array_extent != mask_extent)\n-\t\truntime_error (\"Incorrect extent in MASK argument of\"\n-\t\t\t       \" MAXLOC intrinsic in dimension %ld:\"\n-\t\t\t       \" is %ld, should be %ld\", (long int) n + 1,\n-\t\t\t       (long int) mask_extent, (long int) array_extent);\n-\t    }\n+\n+\t  bounds_iforeach_return ((array_t *) retarray, (array_t *) array,\n+\t\t\t\t  \"MAXLOC\");\n+\t  bounds_equal_extents ((array_t *) mask, (array_t *) array,\n+\t\t\t\t  \"MASK argument\", \"MAXLOC\");\n \t}\n     }\n \n@@ -340,22 +300,10 @@ smaxloc0_16_r8 (gfc_array_i16 * const restrict retarray,\n       retarray->offset = 0;\n       retarray->data = internal_malloc_size (sizeof (GFC_INTEGER_16) * rank);\n     }\n-  else\n+  else if (unlikely (compile_options.bounds_check))\n     {\n-      if (unlikely (compile_options.bounds_check))\n-\t{\n-\t  int ret_rank;\n-\t  index_type ret_extent;\n-\n-\t  ret_rank = GFC_DESCRIPTOR_RANK (retarray);\n-\t  if (ret_rank != 1)\n-\t    runtime_error (\"rank of return array in MAXLOC intrinsic\"\n-\t\t\t   \" should be 1, is %ld\", (long int) ret_rank);\n-\n-\t  ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,0);\n-\t    if (ret_extent != rank)\n-\t      runtime_error (\"dimension of return array incorrect\");\n-\t}\n+       bounds_iforeach_return ((array_t *) retarray, (array_t *) array,\n+\t\t\t       \"MAXLOC\");\n     }\n \n   dstride = GFC_DESCRIPTOR_STRIDE(retarray,0);"}, {"sha": "7cdd813391ee335c1ab34fdb0ebce8c23401ccbe", "filename": "libgfortran/generated/maxloc0_4_i1.c", "status": "modified", "additions": 10, "deletions": 62, "changes": 72, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/16bff92192676901670042cdce3fbd5f9c928fc8/libgfortran%2Fgenerated%2Fmaxloc0_4_i1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/16bff92192676901670042cdce3fbd5f9c928fc8/libgfortran%2Fgenerated%2Fmaxloc0_4_i1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxloc0_4_i1.c?ref=16bff92192676901670042cdce3fbd5f9c928fc8", "patch": "@@ -63,21 +63,8 @@ maxloc0_4_i1 (gfc_array_i4 * const restrict retarray,\n   else\n     {\n       if (unlikely (compile_options.bounds_check))\n-\t{\n-\t  int ret_rank;\n-\t  index_type ret_extent;\n-\n-\t  ret_rank = GFC_DESCRIPTOR_RANK (retarray);\n-\t  if (ret_rank != 1)\n-\t    runtime_error (\"rank of return array in MAXLOC intrinsic\"\n-\t\t\t   \" should be 1, is %ld\", (long int) ret_rank);\n-\n-\t  ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,0);\n-\t  if (ret_extent != rank)\n-\t    runtime_error (\"Incorrect extent in return value of\"\n-\t\t\t   \" MAXLOC intrnisic: is %ld, should be %ld\",\n-\t\t\t   (long int) ret_extent, (long int) rank);\n-\t}\n+        bounds_iforeach_return ((array_t *) retarray, (array_t *) array,\n+\t                        \"MAXLOC\");\n     }\n \n   dstride = GFC_DESCRIPTOR_STRIDE(retarray,0);\n@@ -186,38 +173,11 @@ mmaxloc0_4_i1 (gfc_array_i4 * const restrict retarray,\n     {\n       if (unlikely (compile_options.bounds_check))\n \t{\n-\t  int ret_rank, mask_rank;\n-\t  index_type ret_extent;\n-\t  int n;\n-\t  index_type array_extent, mask_extent;\n-\n-\t  ret_rank = GFC_DESCRIPTOR_RANK (retarray);\n-\t  if (ret_rank != 1)\n-\t    runtime_error (\"rank of return array in MAXLOC intrinsic\"\n-\t\t\t   \" should be 1, is %ld\", (long int) ret_rank);\n-\n-\t  ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,0);\n-\t  if (ret_extent != rank)\n-\t    runtime_error (\"Incorrect extent in return value of\"\n-\t\t\t   \" MAXLOC intrnisic: is %ld, should be %ld\",\n-\t\t\t   (long int) ret_extent, (long int) rank);\n-\t\n-\t  mask_rank = GFC_DESCRIPTOR_RANK (mask);\n-\t  if (rank != mask_rank)\n-\t    runtime_error (\"rank of MASK argument in MAXLOC intrnisic\"\n-\t                   \"should be %ld, is %ld\", (long int) rank,\n-\t\t\t   (long int) mask_rank);\n-\n-\t  for (n=0; n<rank; n++)\n-\t    {\n-\t      array_extent = GFC_DESCRIPTOR_EXTENT(array,n);\n-\t      mask_extent = GFC_DESCRIPTOR_EXTENT(mask,n);\n-\t      if (array_extent != mask_extent)\n-\t\truntime_error (\"Incorrect extent in MASK argument of\"\n-\t\t\t       \" MAXLOC intrinsic in dimension %ld:\"\n-\t\t\t       \" is %ld, should be %ld\", (long int) n + 1,\n-\t\t\t       (long int) mask_extent, (long int) array_extent);\n-\t    }\n+\n+\t  bounds_iforeach_return ((array_t *) retarray, (array_t *) array,\n+\t\t\t\t  \"MAXLOC\");\n+\t  bounds_equal_extents ((array_t *) mask, (array_t *) array,\n+\t\t\t\t  \"MASK argument\", \"MAXLOC\");\n \t}\n     }\n \n@@ -340,22 +300,10 @@ smaxloc0_4_i1 (gfc_array_i4 * const restrict retarray,\n       retarray->offset = 0;\n       retarray->data = internal_malloc_size (sizeof (GFC_INTEGER_4) * rank);\n     }\n-  else\n+  else if (unlikely (compile_options.bounds_check))\n     {\n-      if (unlikely (compile_options.bounds_check))\n-\t{\n-\t  int ret_rank;\n-\t  index_type ret_extent;\n-\n-\t  ret_rank = GFC_DESCRIPTOR_RANK (retarray);\n-\t  if (ret_rank != 1)\n-\t    runtime_error (\"rank of return array in MAXLOC intrinsic\"\n-\t\t\t   \" should be 1, is %ld\", (long int) ret_rank);\n-\n-\t  ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,0);\n-\t    if (ret_extent != rank)\n-\t      runtime_error (\"dimension of return array incorrect\");\n-\t}\n+       bounds_iforeach_return ((array_t *) retarray, (array_t *) array,\n+\t\t\t       \"MAXLOC\");\n     }\n \n   dstride = GFC_DESCRIPTOR_STRIDE(retarray,0);"}, {"sha": "b2bc05307eb525afac56819fbf394196d8acf199", "filename": "libgfortran/generated/maxloc0_4_i16.c", "status": "modified", "additions": 10, "deletions": 62, "changes": 72, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/16bff92192676901670042cdce3fbd5f9c928fc8/libgfortran%2Fgenerated%2Fmaxloc0_4_i16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/16bff92192676901670042cdce3fbd5f9c928fc8/libgfortran%2Fgenerated%2Fmaxloc0_4_i16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxloc0_4_i16.c?ref=16bff92192676901670042cdce3fbd5f9c928fc8", "patch": "@@ -63,21 +63,8 @@ maxloc0_4_i16 (gfc_array_i4 * const restrict retarray,\n   else\n     {\n       if (unlikely (compile_options.bounds_check))\n-\t{\n-\t  int ret_rank;\n-\t  index_type ret_extent;\n-\n-\t  ret_rank = GFC_DESCRIPTOR_RANK (retarray);\n-\t  if (ret_rank != 1)\n-\t    runtime_error (\"rank of return array in MAXLOC intrinsic\"\n-\t\t\t   \" should be 1, is %ld\", (long int) ret_rank);\n-\n-\t  ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,0);\n-\t  if (ret_extent != rank)\n-\t    runtime_error (\"Incorrect extent in return value of\"\n-\t\t\t   \" MAXLOC intrnisic: is %ld, should be %ld\",\n-\t\t\t   (long int) ret_extent, (long int) rank);\n-\t}\n+        bounds_iforeach_return ((array_t *) retarray, (array_t *) array,\n+\t                        \"MAXLOC\");\n     }\n \n   dstride = GFC_DESCRIPTOR_STRIDE(retarray,0);\n@@ -186,38 +173,11 @@ mmaxloc0_4_i16 (gfc_array_i4 * const restrict retarray,\n     {\n       if (unlikely (compile_options.bounds_check))\n \t{\n-\t  int ret_rank, mask_rank;\n-\t  index_type ret_extent;\n-\t  int n;\n-\t  index_type array_extent, mask_extent;\n-\n-\t  ret_rank = GFC_DESCRIPTOR_RANK (retarray);\n-\t  if (ret_rank != 1)\n-\t    runtime_error (\"rank of return array in MAXLOC intrinsic\"\n-\t\t\t   \" should be 1, is %ld\", (long int) ret_rank);\n-\n-\t  ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,0);\n-\t  if (ret_extent != rank)\n-\t    runtime_error (\"Incorrect extent in return value of\"\n-\t\t\t   \" MAXLOC intrnisic: is %ld, should be %ld\",\n-\t\t\t   (long int) ret_extent, (long int) rank);\n-\t\n-\t  mask_rank = GFC_DESCRIPTOR_RANK (mask);\n-\t  if (rank != mask_rank)\n-\t    runtime_error (\"rank of MASK argument in MAXLOC intrnisic\"\n-\t                   \"should be %ld, is %ld\", (long int) rank,\n-\t\t\t   (long int) mask_rank);\n-\n-\t  for (n=0; n<rank; n++)\n-\t    {\n-\t      array_extent = GFC_DESCRIPTOR_EXTENT(array,n);\n-\t      mask_extent = GFC_DESCRIPTOR_EXTENT(mask,n);\n-\t      if (array_extent != mask_extent)\n-\t\truntime_error (\"Incorrect extent in MASK argument of\"\n-\t\t\t       \" MAXLOC intrinsic in dimension %ld:\"\n-\t\t\t       \" is %ld, should be %ld\", (long int) n + 1,\n-\t\t\t       (long int) mask_extent, (long int) array_extent);\n-\t    }\n+\n+\t  bounds_iforeach_return ((array_t *) retarray, (array_t *) array,\n+\t\t\t\t  \"MAXLOC\");\n+\t  bounds_equal_extents ((array_t *) mask, (array_t *) array,\n+\t\t\t\t  \"MASK argument\", \"MAXLOC\");\n \t}\n     }\n \n@@ -340,22 +300,10 @@ smaxloc0_4_i16 (gfc_array_i4 * const restrict retarray,\n       retarray->offset = 0;\n       retarray->data = internal_malloc_size (sizeof (GFC_INTEGER_4) * rank);\n     }\n-  else\n+  else if (unlikely (compile_options.bounds_check))\n     {\n-      if (unlikely (compile_options.bounds_check))\n-\t{\n-\t  int ret_rank;\n-\t  index_type ret_extent;\n-\n-\t  ret_rank = GFC_DESCRIPTOR_RANK (retarray);\n-\t  if (ret_rank != 1)\n-\t    runtime_error (\"rank of return array in MAXLOC intrinsic\"\n-\t\t\t   \" should be 1, is %ld\", (long int) ret_rank);\n-\n-\t  ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,0);\n-\t    if (ret_extent != rank)\n-\t      runtime_error (\"dimension of return array incorrect\");\n-\t}\n+       bounds_iforeach_return ((array_t *) retarray, (array_t *) array,\n+\t\t\t       \"MAXLOC\");\n     }\n \n   dstride = GFC_DESCRIPTOR_STRIDE(retarray,0);"}, {"sha": "fb3b40bd791e3a9fe29fde4e3e4205174acdf245", "filename": "libgfortran/generated/maxloc0_4_i2.c", "status": "modified", "additions": 10, "deletions": 62, "changes": 72, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/16bff92192676901670042cdce3fbd5f9c928fc8/libgfortran%2Fgenerated%2Fmaxloc0_4_i2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/16bff92192676901670042cdce3fbd5f9c928fc8/libgfortran%2Fgenerated%2Fmaxloc0_4_i2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxloc0_4_i2.c?ref=16bff92192676901670042cdce3fbd5f9c928fc8", "patch": "@@ -63,21 +63,8 @@ maxloc0_4_i2 (gfc_array_i4 * const restrict retarray,\n   else\n     {\n       if (unlikely (compile_options.bounds_check))\n-\t{\n-\t  int ret_rank;\n-\t  index_type ret_extent;\n-\n-\t  ret_rank = GFC_DESCRIPTOR_RANK (retarray);\n-\t  if (ret_rank != 1)\n-\t    runtime_error (\"rank of return array in MAXLOC intrinsic\"\n-\t\t\t   \" should be 1, is %ld\", (long int) ret_rank);\n-\n-\t  ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,0);\n-\t  if (ret_extent != rank)\n-\t    runtime_error (\"Incorrect extent in return value of\"\n-\t\t\t   \" MAXLOC intrnisic: is %ld, should be %ld\",\n-\t\t\t   (long int) ret_extent, (long int) rank);\n-\t}\n+        bounds_iforeach_return ((array_t *) retarray, (array_t *) array,\n+\t                        \"MAXLOC\");\n     }\n \n   dstride = GFC_DESCRIPTOR_STRIDE(retarray,0);\n@@ -186,38 +173,11 @@ mmaxloc0_4_i2 (gfc_array_i4 * const restrict retarray,\n     {\n       if (unlikely (compile_options.bounds_check))\n \t{\n-\t  int ret_rank, mask_rank;\n-\t  index_type ret_extent;\n-\t  int n;\n-\t  index_type array_extent, mask_extent;\n-\n-\t  ret_rank = GFC_DESCRIPTOR_RANK (retarray);\n-\t  if (ret_rank != 1)\n-\t    runtime_error (\"rank of return array in MAXLOC intrinsic\"\n-\t\t\t   \" should be 1, is %ld\", (long int) ret_rank);\n-\n-\t  ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,0);\n-\t  if (ret_extent != rank)\n-\t    runtime_error (\"Incorrect extent in return value of\"\n-\t\t\t   \" MAXLOC intrnisic: is %ld, should be %ld\",\n-\t\t\t   (long int) ret_extent, (long int) rank);\n-\t\n-\t  mask_rank = GFC_DESCRIPTOR_RANK (mask);\n-\t  if (rank != mask_rank)\n-\t    runtime_error (\"rank of MASK argument in MAXLOC intrnisic\"\n-\t                   \"should be %ld, is %ld\", (long int) rank,\n-\t\t\t   (long int) mask_rank);\n-\n-\t  for (n=0; n<rank; n++)\n-\t    {\n-\t      array_extent = GFC_DESCRIPTOR_EXTENT(array,n);\n-\t      mask_extent = GFC_DESCRIPTOR_EXTENT(mask,n);\n-\t      if (array_extent != mask_extent)\n-\t\truntime_error (\"Incorrect extent in MASK argument of\"\n-\t\t\t       \" MAXLOC intrinsic in dimension %ld:\"\n-\t\t\t       \" is %ld, should be %ld\", (long int) n + 1,\n-\t\t\t       (long int) mask_extent, (long int) array_extent);\n-\t    }\n+\n+\t  bounds_iforeach_return ((array_t *) retarray, (array_t *) array,\n+\t\t\t\t  \"MAXLOC\");\n+\t  bounds_equal_extents ((array_t *) mask, (array_t *) array,\n+\t\t\t\t  \"MASK argument\", \"MAXLOC\");\n \t}\n     }\n \n@@ -340,22 +300,10 @@ smaxloc0_4_i2 (gfc_array_i4 * const restrict retarray,\n       retarray->offset = 0;\n       retarray->data = internal_malloc_size (sizeof (GFC_INTEGER_4) * rank);\n     }\n-  else\n+  else if (unlikely (compile_options.bounds_check))\n     {\n-      if (unlikely (compile_options.bounds_check))\n-\t{\n-\t  int ret_rank;\n-\t  index_type ret_extent;\n-\n-\t  ret_rank = GFC_DESCRIPTOR_RANK (retarray);\n-\t  if (ret_rank != 1)\n-\t    runtime_error (\"rank of return array in MAXLOC intrinsic\"\n-\t\t\t   \" should be 1, is %ld\", (long int) ret_rank);\n-\n-\t  ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,0);\n-\t    if (ret_extent != rank)\n-\t      runtime_error (\"dimension of return array incorrect\");\n-\t}\n+       bounds_iforeach_return ((array_t *) retarray, (array_t *) array,\n+\t\t\t       \"MAXLOC\");\n     }\n \n   dstride = GFC_DESCRIPTOR_STRIDE(retarray,0);"}, {"sha": "2a84c7f48975b35783096d881483527f58924bb0", "filename": "libgfortran/generated/maxloc0_4_i4.c", "status": "modified", "additions": 10, "deletions": 62, "changes": 72, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/16bff92192676901670042cdce3fbd5f9c928fc8/libgfortran%2Fgenerated%2Fmaxloc0_4_i4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/16bff92192676901670042cdce3fbd5f9c928fc8/libgfortran%2Fgenerated%2Fmaxloc0_4_i4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxloc0_4_i4.c?ref=16bff92192676901670042cdce3fbd5f9c928fc8", "patch": "@@ -63,21 +63,8 @@ maxloc0_4_i4 (gfc_array_i4 * const restrict retarray,\n   else\n     {\n       if (unlikely (compile_options.bounds_check))\n-\t{\n-\t  int ret_rank;\n-\t  index_type ret_extent;\n-\n-\t  ret_rank = GFC_DESCRIPTOR_RANK (retarray);\n-\t  if (ret_rank != 1)\n-\t    runtime_error (\"rank of return array in MAXLOC intrinsic\"\n-\t\t\t   \" should be 1, is %ld\", (long int) ret_rank);\n-\n-\t  ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,0);\n-\t  if (ret_extent != rank)\n-\t    runtime_error (\"Incorrect extent in return value of\"\n-\t\t\t   \" MAXLOC intrnisic: is %ld, should be %ld\",\n-\t\t\t   (long int) ret_extent, (long int) rank);\n-\t}\n+        bounds_iforeach_return ((array_t *) retarray, (array_t *) array,\n+\t                        \"MAXLOC\");\n     }\n \n   dstride = GFC_DESCRIPTOR_STRIDE(retarray,0);\n@@ -186,38 +173,11 @@ mmaxloc0_4_i4 (gfc_array_i4 * const restrict retarray,\n     {\n       if (unlikely (compile_options.bounds_check))\n \t{\n-\t  int ret_rank, mask_rank;\n-\t  index_type ret_extent;\n-\t  int n;\n-\t  index_type array_extent, mask_extent;\n-\n-\t  ret_rank = GFC_DESCRIPTOR_RANK (retarray);\n-\t  if (ret_rank != 1)\n-\t    runtime_error (\"rank of return array in MAXLOC intrinsic\"\n-\t\t\t   \" should be 1, is %ld\", (long int) ret_rank);\n-\n-\t  ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,0);\n-\t  if (ret_extent != rank)\n-\t    runtime_error (\"Incorrect extent in return value of\"\n-\t\t\t   \" MAXLOC intrnisic: is %ld, should be %ld\",\n-\t\t\t   (long int) ret_extent, (long int) rank);\n-\t\n-\t  mask_rank = GFC_DESCRIPTOR_RANK (mask);\n-\t  if (rank != mask_rank)\n-\t    runtime_error (\"rank of MASK argument in MAXLOC intrnisic\"\n-\t                   \"should be %ld, is %ld\", (long int) rank,\n-\t\t\t   (long int) mask_rank);\n-\n-\t  for (n=0; n<rank; n++)\n-\t    {\n-\t      array_extent = GFC_DESCRIPTOR_EXTENT(array,n);\n-\t      mask_extent = GFC_DESCRIPTOR_EXTENT(mask,n);\n-\t      if (array_extent != mask_extent)\n-\t\truntime_error (\"Incorrect extent in MASK argument of\"\n-\t\t\t       \" MAXLOC intrinsic in dimension %ld:\"\n-\t\t\t       \" is %ld, should be %ld\", (long int) n + 1,\n-\t\t\t       (long int) mask_extent, (long int) array_extent);\n-\t    }\n+\n+\t  bounds_iforeach_return ((array_t *) retarray, (array_t *) array,\n+\t\t\t\t  \"MAXLOC\");\n+\t  bounds_equal_extents ((array_t *) mask, (array_t *) array,\n+\t\t\t\t  \"MASK argument\", \"MAXLOC\");\n \t}\n     }\n \n@@ -340,22 +300,10 @@ smaxloc0_4_i4 (gfc_array_i4 * const restrict retarray,\n       retarray->offset = 0;\n       retarray->data = internal_malloc_size (sizeof (GFC_INTEGER_4) * rank);\n     }\n-  else\n+  else if (unlikely (compile_options.bounds_check))\n     {\n-      if (unlikely (compile_options.bounds_check))\n-\t{\n-\t  int ret_rank;\n-\t  index_type ret_extent;\n-\n-\t  ret_rank = GFC_DESCRIPTOR_RANK (retarray);\n-\t  if (ret_rank != 1)\n-\t    runtime_error (\"rank of return array in MAXLOC intrinsic\"\n-\t\t\t   \" should be 1, is %ld\", (long int) ret_rank);\n-\n-\t  ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,0);\n-\t    if (ret_extent != rank)\n-\t      runtime_error (\"dimension of return array incorrect\");\n-\t}\n+       bounds_iforeach_return ((array_t *) retarray, (array_t *) array,\n+\t\t\t       \"MAXLOC\");\n     }\n \n   dstride = GFC_DESCRIPTOR_STRIDE(retarray,0);"}, {"sha": "2e1fa6daef82171cf702b1e0437e97a02b5b2b4b", "filename": "libgfortran/generated/maxloc0_4_i8.c", "status": "modified", "additions": 10, "deletions": 62, "changes": 72, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/16bff92192676901670042cdce3fbd5f9c928fc8/libgfortran%2Fgenerated%2Fmaxloc0_4_i8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/16bff92192676901670042cdce3fbd5f9c928fc8/libgfortran%2Fgenerated%2Fmaxloc0_4_i8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxloc0_4_i8.c?ref=16bff92192676901670042cdce3fbd5f9c928fc8", "patch": "@@ -63,21 +63,8 @@ maxloc0_4_i8 (gfc_array_i4 * const restrict retarray,\n   else\n     {\n       if (unlikely (compile_options.bounds_check))\n-\t{\n-\t  int ret_rank;\n-\t  index_type ret_extent;\n-\n-\t  ret_rank = GFC_DESCRIPTOR_RANK (retarray);\n-\t  if (ret_rank != 1)\n-\t    runtime_error (\"rank of return array in MAXLOC intrinsic\"\n-\t\t\t   \" should be 1, is %ld\", (long int) ret_rank);\n-\n-\t  ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,0);\n-\t  if (ret_extent != rank)\n-\t    runtime_error (\"Incorrect extent in return value of\"\n-\t\t\t   \" MAXLOC intrnisic: is %ld, should be %ld\",\n-\t\t\t   (long int) ret_extent, (long int) rank);\n-\t}\n+        bounds_iforeach_return ((array_t *) retarray, (array_t *) array,\n+\t                        \"MAXLOC\");\n     }\n \n   dstride = GFC_DESCRIPTOR_STRIDE(retarray,0);\n@@ -186,38 +173,11 @@ mmaxloc0_4_i8 (gfc_array_i4 * const restrict retarray,\n     {\n       if (unlikely (compile_options.bounds_check))\n \t{\n-\t  int ret_rank, mask_rank;\n-\t  index_type ret_extent;\n-\t  int n;\n-\t  index_type array_extent, mask_extent;\n-\n-\t  ret_rank = GFC_DESCRIPTOR_RANK (retarray);\n-\t  if (ret_rank != 1)\n-\t    runtime_error (\"rank of return array in MAXLOC intrinsic\"\n-\t\t\t   \" should be 1, is %ld\", (long int) ret_rank);\n-\n-\t  ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,0);\n-\t  if (ret_extent != rank)\n-\t    runtime_error (\"Incorrect extent in return value of\"\n-\t\t\t   \" MAXLOC intrnisic: is %ld, should be %ld\",\n-\t\t\t   (long int) ret_extent, (long int) rank);\n-\t\n-\t  mask_rank = GFC_DESCRIPTOR_RANK (mask);\n-\t  if (rank != mask_rank)\n-\t    runtime_error (\"rank of MASK argument in MAXLOC intrnisic\"\n-\t                   \"should be %ld, is %ld\", (long int) rank,\n-\t\t\t   (long int) mask_rank);\n-\n-\t  for (n=0; n<rank; n++)\n-\t    {\n-\t      array_extent = GFC_DESCRIPTOR_EXTENT(array,n);\n-\t      mask_extent = GFC_DESCRIPTOR_EXTENT(mask,n);\n-\t      if (array_extent != mask_extent)\n-\t\truntime_error (\"Incorrect extent in MASK argument of\"\n-\t\t\t       \" MAXLOC intrinsic in dimension %ld:\"\n-\t\t\t       \" is %ld, should be %ld\", (long int) n + 1,\n-\t\t\t       (long int) mask_extent, (long int) array_extent);\n-\t    }\n+\n+\t  bounds_iforeach_return ((array_t *) retarray, (array_t *) array,\n+\t\t\t\t  \"MAXLOC\");\n+\t  bounds_equal_extents ((array_t *) mask, (array_t *) array,\n+\t\t\t\t  \"MASK argument\", \"MAXLOC\");\n \t}\n     }\n \n@@ -340,22 +300,10 @@ smaxloc0_4_i8 (gfc_array_i4 * const restrict retarray,\n       retarray->offset = 0;\n       retarray->data = internal_malloc_size (sizeof (GFC_INTEGER_4) * rank);\n     }\n-  else\n+  else if (unlikely (compile_options.bounds_check))\n     {\n-      if (unlikely (compile_options.bounds_check))\n-\t{\n-\t  int ret_rank;\n-\t  index_type ret_extent;\n-\n-\t  ret_rank = GFC_DESCRIPTOR_RANK (retarray);\n-\t  if (ret_rank != 1)\n-\t    runtime_error (\"rank of return array in MAXLOC intrinsic\"\n-\t\t\t   \" should be 1, is %ld\", (long int) ret_rank);\n-\n-\t  ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,0);\n-\t    if (ret_extent != rank)\n-\t      runtime_error (\"dimension of return array incorrect\");\n-\t}\n+       bounds_iforeach_return ((array_t *) retarray, (array_t *) array,\n+\t\t\t       \"MAXLOC\");\n     }\n \n   dstride = GFC_DESCRIPTOR_STRIDE(retarray,0);"}, {"sha": "934337a6ac02d242e589556a81b354db21a0a8d5", "filename": "libgfortran/generated/maxloc0_4_r10.c", "status": "modified", "additions": 10, "deletions": 62, "changes": 72, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/16bff92192676901670042cdce3fbd5f9c928fc8/libgfortran%2Fgenerated%2Fmaxloc0_4_r10.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/16bff92192676901670042cdce3fbd5f9c928fc8/libgfortran%2Fgenerated%2Fmaxloc0_4_r10.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxloc0_4_r10.c?ref=16bff92192676901670042cdce3fbd5f9c928fc8", "patch": "@@ -63,21 +63,8 @@ maxloc0_4_r10 (gfc_array_i4 * const restrict retarray,\n   else\n     {\n       if (unlikely (compile_options.bounds_check))\n-\t{\n-\t  int ret_rank;\n-\t  index_type ret_extent;\n-\n-\t  ret_rank = GFC_DESCRIPTOR_RANK (retarray);\n-\t  if (ret_rank != 1)\n-\t    runtime_error (\"rank of return array in MAXLOC intrinsic\"\n-\t\t\t   \" should be 1, is %ld\", (long int) ret_rank);\n-\n-\t  ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,0);\n-\t  if (ret_extent != rank)\n-\t    runtime_error (\"Incorrect extent in return value of\"\n-\t\t\t   \" MAXLOC intrnisic: is %ld, should be %ld\",\n-\t\t\t   (long int) ret_extent, (long int) rank);\n-\t}\n+        bounds_iforeach_return ((array_t *) retarray, (array_t *) array,\n+\t                        \"MAXLOC\");\n     }\n \n   dstride = GFC_DESCRIPTOR_STRIDE(retarray,0);\n@@ -186,38 +173,11 @@ mmaxloc0_4_r10 (gfc_array_i4 * const restrict retarray,\n     {\n       if (unlikely (compile_options.bounds_check))\n \t{\n-\t  int ret_rank, mask_rank;\n-\t  index_type ret_extent;\n-\t  int n;\n-\t  index_type array_extent, mask_extent;\n-\n-\t  ret_rank = GFC_DESCRIPTOR_RANK (retarray);\n-\t  if (ret_rank != 1)\n-\t    runtime_error (\"rank of return array in MAXLOC intrinsic\"\n-\t\t\t   \" should be 1, is %ld\", (long int) ret_rank);\n-\n-\t  ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,0);\n-\t  if (ret_extent != rank)\n-\t    runtime_error (\"Incorrect extent in return value of\"\n-\t\t\t   \" MAXLOC intrnisic: is %ld, should be %ld\",\n-\t\t\t   (long int) ret_extent, (long int) rank);\n-\t\n-\t  mask_rank = GFC_DESCRIPTOR_RANK (mask);\n-\t  if (rank != mask_rank)\n-\t    runtime_error (\"rank of MASK argument in MAXLOC intrnisic\"\n-\t                   \"should be %ld, is %ld\", (long int) rank,\n-\t\t\t   (long int) mask_rank);\n-\n-\t  for (n=0; n<rank; n++)\n-\t    {\n-\t      array_extent = GFC_DESCRIPTOR_EXTENT(array,n);\n-\t      mask_extent = GFC_DESCRIPTOR_EXTENT(mask,n);\n-\t      if (array_extent != mask_extent)\n-\t\truntime_error (\"Incorrect extent in MASK argument of\"\n-\t\t\t       \" MAXLOC intrinsic in dimension %ld:\"\n-\t\t\t       \" is %ld, should be %ld\", (long int) n + 1,\n-\t\t\t       (long int) mask_extent, (long int) array_extent);\n-\t    }\n+\n+\t  bounds_iforeach_return ((array_t *) retarray, (array_t *) array,\n+\t\t\t\t  \"MAXLOC\");\n+\t  bounds_equal_extents ((array_t *) mask, (array_t *) array,\n+\t\t\t\t  \"MASK argument\", \"MAXLOC\");\n \t}\n     }\n \n@@ -340,22 +300,10 @@ smaxloc0_4_r10 (gfc_array_i4 * const restrict retarray,\n       retarray->offset = 0;\n       retarray->data = internal_malloc_size (sizeof (GFC_INTEGER_4) * rank);\n     }\n-  else\n+  else if (unlikely (compile_options.bounds_check))\n     {\n-      if (unlikely (compile_options.bounds_check))\n-\t{\n-\t  int ret_rank;\n-\t  index_type ret_extent;\n-\n-\t  ret_rank = GFC_DESCRIPTOR_RANK (retarray);\n-\t  if (ret_rank != 1)\n-\t    runtime_error (\"rank of return array in MAXLOC intrinsic\"\n-\t\t\t   \" should be 1, is %ld\", (long int) ret_rank);\n-\n-\t  ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,0);\n-\t    if (ret_extent != rank)\n-\t      runtime_error (\"dimension of return array incorrect\");\n-\t}\n+       bounds_iforeach_return ((array_t *) retarray, (array_t *) array,\n+\t\t\t       \"MAXLOC\");\n     }\n \n   dstride = GFC_DESCRIPTOR_STRIDE(retarray,0);"}, {"sha": "c2660258a312c87d00eced31d41f3d6b79076edb", "filename": "libgfortran/generated/maxloc0_4_r16.c", "status": "modified", "additions": 10, "deletions": 62, "changes": 72, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/16bff92192676901670042cdce3fbd5f9c928fc8/libgfortran%2Fgenerated%2Fmaxloc0_4_r16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/16bff92192676901670042cdce3fbd5f9c928fc8/libgfortran%2Fgenerated%2Fmaxloc0_4_r16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxloc0_4_r16.c?ref=16bff92192676901670042cdce3fbd5f9c928fc8", "patch": "@@ -63,21 +63,8 @@ maxloc0_4_r16 (gfc_array_i4 * const restrict retarray,\n   else\n     {\n       if (unlikely (compile_options.bounds_check))\n-\t{\n-\t  int ret_rank;\n-\t  index_type ret_extent;\n-\n-\t  ret_rank = GFC_DESCRIPTOR_RANK (retarray);\n-\t  if (ret_rank != 1)\n-\t    runtime_error (\"rank of return array in MAXLOC intrinsic\"\n-\t\t\t   \" should be 1, is %ld\", (long int) ret_rank);\n-\n-\t  ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,0);\n-\t  if (ret_extent != rank)\n-\t    runtime_error (\"Incorrect extent in return value of\"\n-\t\t\t   \" MAXLOC intrnisic: is %ld, should be %ld\",\n-\t\t\t   (long int) ret_extent, (long int) rank);\n-\t}\n+        bounds_iforeach_return ((array_t *) retarray, (array_t *) array,\n+\t                        \"MAXLOC\");\n     }\n \n   dstride = GFC_DESCRIPTOR_STRIDE(retarray,0);\n@@ -186,38 +173,11 @@ mmaxloc0_4_r16 (gfc_array_i4 * const restrict retarray,\n     {\n       if (unlikely (compile_options.bounds_check))\n \t{\n-\t  int ret_rank, mask_rank;\n-\t  index_type ret_extent;\n-\t  int n;\n-\t  index_type array_extent, mask_extent;\n-\n-\t  ret_rank = GFC_DESCRIPTOR_RANK (retarray);\n-\t  if (ret_rank != 1)\n-\t    runtime_error (\"rank of return array in MAXLOC intrinsic\"\n-\t\t\t   \" should be 1, is %ld\", (long int) ret_rank);\n-\n-\t  ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,0);\n-\t  if (ret_extent != rank)\n-\t    runtime_error (\"Incorrect extent in return value of\"\n-\t\t\t   \" MAXLOC intrnisic: is %ld, should be %ld\",\n-\t\t\t   (long int) ret_extent, (long int) rank);\n-\t\n-\t  mask_rank = GFC_DESCRIPTOR_RANK (mask);\n-\t  if (rank != mask_rank)\n-\t    runtime_error (\"rank of MASK argument in MAXLOC intrnisic\"\n-\t                   \"should be %ld, is %ld\", (long int) rank,\n-\t\t\t   (long int) mask_rank);\n-\n-\t  for (n=0; n<rank; n++)\n-\t    {\n-\t      array_extent = GFC_DESCRIPTOR_EXTENT(array,n);\n-\t      mask_extent = GFC_DESCRIPTOR_EXTENT(mask,n);\n-\t      if (array_extent != mask_extent)\n-\t\truntime_error (\"Incorrect extent in MASK argument of\"\n-\t\t\t       \" MAXLOC intrinsic in dimension %ld:\"\n-\t\t\t       \" is %ld, should be %ld\", (long int) n + 1,\n-\t\t\t       (long int) mask_extent, (long int) array_extent);\n-\t    }\n+\n+\t  bounds_iforeach_return ((array_t *) retarray, (array_t *) array,\n+\t\t\t\t  \"MAXLOC\");\n+\t  bounds_equal_extents ((array_t *) mask, (array_t *) array,\n+\t\t\t\t  \"MASK argument\", \"MAXLOC\");\n \t}\n     }\n \n@@ -340,22 +300,10 @@ smaxloc0_4_r16 (gfc_array_i4 * const restrict retarray,\n       retarray->offset = 0;\n       retarray->data = internal_malloc_size (sizeof (GFC_INTEGER_4) * rank);\n     }\n-  else\n+  else if (unlikely (compile_options.bounds_check))\n     {\n-      if (unlikely (compile_options.bounds_check))\n-\t{\n-\t  int ret_rank;\n-\t  index_type ret_extent;\n-\n-\t  ret_rank = GFC_DESCRIPTOR_RANK (retarray);\n-\t  if (ret_rank != 1)\n-\t    runtime_error (\"rank of return array in MAXLOC intrinsic\"\n-\t\t\t   \" should be 1, is %ld\", (long int) ret_rank);\n-\n-\t  ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,0);\n-\t    if (ret_extent != rank)\n-\t      runtime_error (\"dimension of return array incorrect\");\n-\t}\n+       bounds_iforeach_return ((array_t *) retarray, (array_t *) array,\n+\t\t\t       \"MAXLOC\");\n     }\n \n   dstride = GFC_DESCRIPTOR_STRIDE(retarray,0);"}, {"sha": "a3499531d27fce0613027f43f68a6298ae31b62d", "filename": "libgfortran/generated/maxloc0_4_r4.c", "status": "modified", "additions": 10, "deletions": 62, "changes": 72, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/16bff92192676901670042cdce3fbd5f9c928fc8/libgfortran%2Fgenerated%2Fmaxloc0_4_r4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/16bff92192676901670042cdce3fbd5f9c928fc8/libgfortran%2Fgenerated%2Fmaxloc0_4_r4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxloc0_4_r4.c?ref=16bff92192676901670042cdce3fbd5f9c928fc8", "patch": "@@ -63,21 +63,8 @@ maxloc0_4_r4 (gfc_array_i4 * const restrict retarray,\n   else\n     {\n       if (unlikely (compile_options.bounds_check))\n-\t{\n-\t  int ret_rank;\n-\t  index_type ret_extent;\n-\n-\t  ret_rank = GFC_DESCRIPTOR_RANK (retarray);\n-\t  if (ret_rank != 1)\n-\t    runtime_error (\"rank of return array in MAXLOC intrinsic\"\n-\t\t\t   \" should be 1, is %ld\", (long int) ret_rank);\n-\n-\t  ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,0);\n-\t  if (ret_extent != rank)\n-\t    runtime_error (\"Incorrect extent in return value of\"\n-\t\t\t   \" MAXLOC intrnisic: is %ld, should be %ld\",\n-\t\t\t   (long int) ret_extent, (long int) rank);\n-\t}\n+        bounds_iforeach_return ((array_t *) retarray, (array_t *) array,\n+\t                        \"MAXLOC\");\n     }\n \n   dstride = GFC_DESCRIPTOR_STRIDE(retarray,0);\n@@ -186,38 +173,11 @@ mmaxloc0_4_r4 (gfc_array_i4 * const restrict retarray,\n     {\n       if (unlikely (compile_options.bounds_check))\n \t{\n-\t  int ret_rank, mask_rank;\n-\t  index_type ret_extent;\n-\t  int n;\n-\t  index_type array_extent, mask_extent;\n-\n-\t  ret_rank = GFC_DESCRIPTOR_RANK (retarray);\n-\t  if (ret_rank != 1)\n-\t    runtime_error (\"rank of return array in MAXLOC intrinsic\"\n-\t\t\t   \" should be 1, is %ld\", (long int) ret_rank);\n-\n-\t  ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,0);\n-\t  if (ret_extent != rank)\n-\t    runtime_error (\"Incorrect extent in return value of\"\n-\t\t\t   \" MAXLOC intrnisic: is %ld, should be %ld\",\n-\t\t\t   (long int) ret_extent, (long int) rank);\n-\t\n-\t  mask_rank = GFC_DESCRIPTOR_RANK (mask);\n-\t  if (rank != mask_rank)\n-\t    runtime_error (\"rank of MASK argument in MAXLOC intrnisic\"\n-\t                   \"should be %ld, is %ld\", (long int) rank,\n-\t\t\t   (long int) mask_rank);\n-\n-\t  for (n=0; n<rank; n++)\n-\t    {\n-\t      array_extent = GFC_DESCRIPTOR_EXTENT(array,n);\n-\t      mask_extent = GFC_DESCRIPTOR_EXTENT(mask,n);\n-\t      if (array_extent != mask_extent)\n-\t\truntime_error (\"Incorrect extent in MASK argument of\"\n-\t\t\t       \" MAXLOC intrinsic in dimension %ld:\"\n-\t\t\t       \" is %ld, should be %ld\", (long int) n + 1,\n-\t\t\t       (long int) mask_extent, (long int) array_extent);\n-\t    }\n+\n+\t  bounds_iforeach_return ((array_t *) retarray, (array_t *) array,\n+\t\t\t\t  \"MAXLOC\");\n+\t  bounds_equal_extents ((array_t *) mask, (array_t *) array,\n+\t\t\t\t  \"MASK argument\", \"MAXLOC\");\n \t}\n     }\n \n@@ -340,22 +300,10 @@ smaxloc0_4_r4 (gfc_array_i4 * const restrict retarray,\n       retarray->offset = 0;\n       retarray->data = internal_malloc_size (sizeof (GFC_INTEGER_4) * rank);\n     }\n-  else\n+  else if (unlikely (compile_options.bounds_check))\n     {\n-      if (unlikely (compile_options.bounds_check))\n-\t{\n-\t  int ret_rank;\n-\t  index_type ret_extent;\n-\n-\t  ret_rank = GFC_DESCRIPTOR_RANK (retarray);\n-\t  if (ret_rank != 1)\n-\t    runtime_error (\"rank of return array in MAXLOC intrinsic\"\n-\t\t\t   \" should be 1, is %ld\", (long int) ret_rank);\n-\n-\t  ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,0);\n-\t    if (ret_extent != rank)\n-\t      runtime_error (\"dimension of return array incorrect\");\n-\t}\n+       bounds_iforeach_return ((array_t *) retarray, (array_t *) array,\n+\t\t\t       \"MAXLOC\");\n     }\n \n   dstride = GFC_DESCRIPTOR_STRIDE(retarray,0);"}, {"sha": "7180bf8ce609fd7813c15823c7cd2984c741fe40", "filename": "libgfortran/generated/maxloc0_4_r8.c", "status": "modified", "additions": 10, "deletions": 62, "changes": 72, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/16bff92192676901670042cdce3fbd5f9c928fc8/libgfortran%2Fgenerated%2Fmaxloc0_4_r8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/16bff92192676901670042cdce3fbd5f9c928fc8/libgfortran%2Fgenerated%2Fmaxloc0_4_r8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxloc0_4_r8.c?ref=16bff92192676901670042cdce3fbd5f9c928fc8", "patch": "@@ -63,21 +63,8 @@ maxloc0_4_r8 (gfc_array_i4 * const restrict retarray,\n   else\n     {\n       if (unlikely (compile_options.bounds_check))\n-\t{\n-\t  int ret_rank;\n-\t  index_type ret_extent;\n-\n-\t  ret_rank = GFC_DESCRIPTOR_RANK (retarray);\n-\t  if (ret_rank != 1)\n-\t    runtime_error (\"rank of return array in MAXLOC intrinsic\"\n-\t\t\t   \" should be 1, is %ld\", (long int) ret_rank);\n-\n-\t  ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,0);\n-\t  if (ret_extent != rank)\n-\t    runtime_error (\"Incorrect extent in return value of\"\n-\t\t\t   \" MAXLOC intrnisic: is %ld, should be %ld\",\n-\t\t\t   (long int) ret_extent, (long int) rank);\n-\t}\n+        bounds_iforeach_return ((array_t *) retarray, (array_t *) array,\n+\t                        \"MAXLOC\");\n     }\n \n   dstride = GFC_DESCRIPTOR_STRIDE(retarray,0);\n@@ -186,38 +173,11 @@ mmaxloc0_4_r8 (gfc_array_i4 * const restrict retarray,\n     {\n       if (unlikely (compile_options.bounds_check))\n \t{\n-\t  int ret_rank, mask_rank;\n-\t  index_type ret_extent;\n-\t  int n;\n-\t  index_type array_extent, mask_extent;\n-\n-\t  ret_rank = GFC_DESCRIPTOR_RANK (retarray);\n-\t  if (ret_rank != 1)\n-\t    runtime_error (\"rank of return array in MAXLOC intrinsic\"\n-\t\t\t   \" should be 1, is %ld\", (long int) ret_rank);\n-\n-\t  ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,0);\n-\t  if (ret_extent != rank)\n-\t    runtime_error (\"Incorrect extent in return value of\"\n-\t\t\t   \" MAXLOC intrnisic: is %ld, should be %ld\",\n-\t\t\t   (long int) ret_extent, (long int) rank);\n-\t\n-\t  mask_rank = GFC_DESCRIPTOR_RANK (mask);\n-\t  if (rank != mask_rank)\n-\t    runtime_error (\"rank of MASK argument in MAXLOC intrnisic\"\n-\t                   \"should be %ld, is %ld\", (long int) rank,\n-\t\t\t   (long int) mask_rank);\n-\n-\t  for (n=0; n<rank; n++)\n-\t    {\n-\t      array_extent = GFC_DESCRIPTOR_EXTENT(array,n);\n-\t      mask_extent = GFC_DESCRIPTOR_EXTENT(mask,n);\n-\t      if (array_extent != mask_extent)\n-\t\truntime_error (\"Incorrect extent in MASK argument of\"\n-\t\t\t       \" MAXLOC intrinsic in dimension %ld:\"\n-\t\t\t       \" is %ld, should be %ld\", (long int) n + 1,\n-\t\t\t       (long int) mask_extent, (long int) array_extent);\n-\t    }\n+\n+\t  bounds_iforeach_return ((array_t *) retarray, (array_t *) array,\n+\t\t\t\t  \"MAXLOC\");\n+\t  bounds_equal_extents ((array_t *) mask, (array_t *) array,\n+\t\t\t\t  \"MASK argument\", \"MAXLOC\");\n \t}\n     }\n \n@@ -340,22 +300,10 @@ smaxloc0_4_r8 (gfc_array_i4 * const restrict retarray,\n       retarray->offset = 0;\n       retarray->data = internal_malloc_size (sizeof (GFC_INTEGER_4) * rank);\n     }\n-  else\n+  else if (unlikely (compile_options.bounds_check))\n     {\n-      if (unlikely (compile_options.bounds_check))\n-\t{\n-\t  int ret_rank;\n-\t  index_type ret_extent;\n-\n-\t  ret_rank = GFC_DESCRIPTOR_RANK (retarray);\n-\t  if (ret_rank != 1)\n-\t    runtime_error (\"rank of return array in MAXLOC intrinsic\"\n-\t\t\t   \" should be 1, is %ld\", (long int) ret_rank);\n-\n-\t  ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,0);\n-\t    if (ret_extent != rank)\n-\t      runtime_error (\"dimension of return array incorrect\");\n-\t}\n+       bounds_iforeach_return ((array_t *) retarray, (array_t *) array,\n+\t\t\t       \"MAXLOC\");\n     }\n \n   dstride = GFC_DESCRIPTOR_STRIDE(retarray,0);"}, {"sha": "a850603e5c5e212f615545eed80f015d32df1e67", "filename": "libgfortran/generated/maxloc0_8_i1.c", "status": "modified", "additions": 10, "deletions": 62, "changes": 72, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/16bff92192676901670042cdce3fbd5f9c928fc8/libgfortran%2Fgenerated%2Fmaxloc0_8_i1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/16bff92192676901670042cdce3fbd5f9c928fc8/libgfortran%2Fgenerated%2Fmaxloc0_8_i1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxloc0_8_i1.c?ref=16bff92192676901670042cdce3fbd5f9c928fc8", "patch": "@@ -63,21 +63,8 @@ maxloc0_8_i1 (gfc_array_i8 * const restrict retarray,\n   else\n     {\n       if (unlikely (compile_options.bounds_check))\n-\t{\n-\t  int ret_rank;\n-\t  index_type ret_extent;\n-\n-\t  ret_rank = GFC_DESCRIPTOR_RANK (retarray);\n-\t  if (ret_rank != 1)\n-\t    runtime_error (\"rank of return array in MAXLOC intrinsic\"\n-\t\t\t   \" should be 1, is %ld\", (long int) ret_rank);\n-\n-\t  ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,0);\n-\t  if (ret_extent != rank)\n-\t    runtime_error (\"Incorrect extent in return value of\"\n-\t\t\t   \" MAXLOC intrnisic: is %ld, should be %ld\",\n-\t\t\t   (long int) ret_extent, (long int) rank);\n-\t}\n+        bounds_iforeach_return ((array_t *) retarray, (array_t *) array,\n+\t                        \"MAXLOC\");\n     }\n \n   dstride = GFC_DESCRIPTOR_STRIDE(retarray,0);\n@@ -186,38 +173,11 @@ mmaxloc0_8_i1 (gfc_array_i8 * const restrict retarray,\n     {\n       if (unlikely (compile_options.bounds_check))\n \t{\n-\t  int ret_rank, mask_rank;\n-\t  index_type ret_extent;\n-\t  int n;\n-\t  index_type array_extent, mask_extent;\n-\n-\t  ret_rank = GFC_DESCRIPTOR_RANK (retarray);\n-\t  if (ret_rank != 1)\n-\t    runtime_error (\"rank of return array in MAXLOC intrinsic\"\n-\t\t\t   \" should be 1, is %ld\", (long int) ret_rank);\n-\n-\t  ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,0);\n-\t  if (ret_extent != rank)\n-\t    runtime_error (\"Incorrect extent in return value of\"\n-\t\t\t   \" MAXLOC intrnisic: is %ld, should be %ld\",\n-\t\t\t   (long int) ret_extent, (long int) rank);\n-\t\n-\t  mask_rank = GFC_DESCRIPTOR_RANK (mask);\n-\t  if (rank != mask_rank)\n-\t    runtime_error (\"rank of MASK argument in MAXLOC intrnisic\"\n-\t                   \"should be %ld, is %ld\", (long int) rank,\n-\t\t\t   (long int) mask_rank);\n-\n-\t  for (n=0; n<rank; n++)\n-\t    {\n-\t      array_extent = GFC_DESCRIPTOR_EXTENT(array,n);\n-\t      mask_extent = GFC_DESCRIPTOR_EXTENT(mask,n);\n-\t      if (array_extent != mask_extent)\n-\t\truntime_error (\"Incorrect extent in MASK argument of\"\n-\t\t\t       \" MAXLOC intrinsic in dimension %ld:\"\n-\t\t\t       \" is %ld, should be %ld\", (long int) n + 1,\n-\t\t\t       (long int) mask_extent, (long int) array_extent);\n-\t    }\n+\n+\t  bounds_iforeach_return ((array_t *) retarray, (array_t *) array,\n+\t\t\t\t  \"MAXLOC\");\n+\t  bounds_equal_extents ((array_t *) mask, (array_t *) array,\n+\t\t\t\t  \"MASK argument\", \"MAXLOC\");\n \t}\n     }\n \n@@ -340,22 +300,10 @@ smaxloc0_8_i1 (gfc_array_i8 * const restrict retarray,\n       retarray->offset = 0;\n       retarray->data = internal_malloc_size (sizeof (GFC_INTEGER_8) * rank);\n     }\n-  else\n+  else if (unlikely (compile_options.bounds_check))\n     {\n-      if (unlikely (compile_options.bounds_check))\n-\t{\n-\t  int ret_rank;\n-\t  index_type ret_extent;\n-\n-\t  ret_rank = GFC_DESCRIPTOR_RANK (retarray);\n-\t  if (ret_rank != 1)\n-\t    runtime_error (\"rank of return array in MAXLOC intrinsic\"\n-\t\t\t   \" should be 1, is %ld\", (long int) ret_rank);\n-\n-\t  ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,0);\n-\t    if (ret_extent != rank)\n-\t      runtime_error (\"dimension of return array incorrect\");\n-\t}\n+       bounds_iforeach_return ((array_t *) retarray, (array_t *) array,\n+\t\t\t       \"MAXLOC\");\n     }\n \n   dstride = GFC_DESCRIPTOR_STRIDE(retarray,0);"}, {"sha": "73683d89589cd0e3496dca651ec6325ada6d219f", "filename": "libgfortran/generated/maxloc0_8_i16.c", "status": "modified", "additions": 10, "deletions": 62, "changes": 72, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/16bff92192676901670042cdce3fbd5f9c928fc8/libgfortran%2Fgenerated%2Fmaxloc0_8_i16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/16bff92192676901670042cdce3fbd5f9c928fc8/libgfortran%2Fgenerated%2Fmaxloc0_8_i16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxloc0_8_i16.c?ref=16bff92192676901670042cdce3fbd5f9c928fc8", "patch": "@@ -63,21 +63,8 @@ maxloc0_8_i16 (gfc_array_i8 * const restrict retarray,\n   else\n     {\n       if (unlikely (compile_options.bounds_check))\n-\t{\n-\t  int ret_rank;\n-\t  index_type ret_extent;\n-\n-\t  ret_rank = GFC_DESCRIPTOR_RANK (retarray);\n-\t  if (ret_rank != 1)\n-\t    runtime_error (\"rank of return array in MAXLOC intrinsic\"\n-\t\t\t   \" should be 1, is %ld\", (long int) ret_rank);\n-\n-\t  ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,0);\n-\t  if (ret_extent != rank)\n-\t    runtime_error (\"Incorrect extent in return value of\"\n-\t\t\t   \" MAXLOC intrnisic: is %ld, should be %ld\",\n-\t\t\t   (long int) ret_extent, (long int) rank);\n-\t}\n+        bounds_iforeach_return ((array_t *) retarray, (array_t *) array,\n+\t                        \"MAXLOC\");\n     }\n \n   dstride = GFC_DESCRIPTOR_STRIDE(retarray,0);\n@@ -186,38 +173,11 @@ mmaxloc0_8_i16 (gfc_array_i8 * const restrict retarray,\n     {\n       if (unlikely (compile_options.bounds_check))\n \t{\n-\t  int ret_rank, mask_rank;\n-\t  index_type ret_extent;\n-\t  int n;\n-\t  index_type array_extent, mask_extent;\n-\n-\t  ret_rank = GFC_DESCRIPTOR_RANK (retarray);\n-\t  if (ret_rank != 1)\n-\t    runtime_error (\"rank of return array in MAXLOC intrinsic\"\n-\t\t\t   \" should be 1, is %ld\", (long int) ret_rank);\n-\n-\t  ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,0);\n-\t  if (ret_extent != rank)\n-\t    runtime_error (\"Incorrect extent in return value of\"\n-\t\t\t   \" MAXLOC intrnisic: is %ld, should be %ld\",\n-\t\t\t   (long int) ret_extent, (long int) rank);\n-\t\n-\t  mask_rank = GFC_DESCRIPTOR_RANK (mask);\n-\t  if (rank != mask_rank)\n-\t    runtime_error (\"rank of MASK argument in MAXLOC intrnisic\"\n-\t                   \"should be %ld, is %ld\", (long int) rank,\n-\t\t\t   (long int) mask_rank);\n-\n-\t  for (n=0; n<rank; n++)\n-\t    {\n-\t      array_extent = GFC_DESCRIPTOR_EXTENT(array,n);\n-\t      mask_extent = GFC_DESCRIPTOR_EXTENT(mask,n);\n-\t      if (array_extent != mask_extent)\n-\t\truntime_error (\"Incorrect extent in MASK argument of\"\n-\t\t\t       \" MAXLOC intrinsic in dimension %ld:\"\n-\t\t\t       \" is %ld, should be %ld\", (long int) n + 1,\n-\t\t\t       (long int) mask_extent, (long int) array_extent);\n-\t    }\n+\n+\t  bounds_iforeach_return ((array_t *) retarray, (array_t *) array,\n+\t\t\t\t  \"MAXLOC\");\n+\t  bounds_equal_extents ((array_t *) mask, (array_t *) array,\n+\t\t\t\t  \"MASK argument\", \"MAXLOC\");\n \t}\n     }\n \n@@ -340,22 +300,10 @@ smaxloc0_8_i16 (gfc_array_i8 * const restrict retarray,\n       retarray->offset = 0;\n       retarray->data = internal_malloc_size (sizeof (GFC_INTEGER_8) * rank);\n     }\n-  else\n+  else if (unlikely (compile_options.bounds_check))\n     {\n-      if (unlikely (compile_options.bounds_check))\n-\t{\n-\t  int ret_rank;\n-\t  index_type ret_extent;\n-\n-\t  ret_rank = GFC_DESCRIPTOR_RANK (retarray);\n-\t  if (ret_rank != 1)\n-\t    runtime_error (\"rank of return array in MAXLOC intrinsic\"\n-\t\t\t   \" should be 1, is %ld\", (long int) ret_rank);\n-\n-\t  ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,0);\n-\t    if (ret_extent != rank)\n-\t      runtime_error (\"dimension of return array incorrect\");\n-\t}\n+       bounds_iforeach_return ((array_t *) retarray, (array_t *) array,\n+\t\t\t       \"MAXLOC\");\n     }\n \n   dstride = GFC_DESCRIPTOR_STRIDE(retarray,0);"}, {"sha": "3b8e793e4ceff2a0fde7b11e4e5f161bae89a1ad", "filename": "libgfortran/generated/maxloc0_8_i2.c", "status": "modified", "additions": 10, "deletions": 62, "changes": 72, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/16bff92192676901670042cdce3fbd5f9c928fc8/libgfortran%2Fgenerated%2Fmaxloc0_8_i2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/16bff92192676901670042cdce3fbd5f9c928fc8/libgfortran%2Fgenerated%2Fmaxloc0_8_i2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxloc0_8_i2.c?ref=16bff92192676901670042cdce3fbd5f9c928fc8", "patch": "@@ -63,21 +63,8 @@ maxloc0_8_i2 (gfc_array_i8 * const restrict retarray,\n   else\n     {\n       if (unlikely (compile_options.bounds_check))\n-\t{\n-\t  int ret_rank;\n-\t  index_type ret_extent;\n-\n-\t  ret_rank = GFC_DESCRIPTOR_RANK (retarray);\n-\t  if (ret_rank != 1)\n-\t    runtime_error (\"rank of return array in MAXLOC intrinsic\"\n-\t\t\t   \" should be 1, is %ld\", (long int) ret_rank);\n-\n-\t  ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,0);\n-\t  if (ret_extent != rank)\n-\t    runtime_error (\"Incorrect extent in return value of\"\n-\t\t\t   \" MAXLOC intrnisic: is %ld, should be %ld\",\n-\t\t\t   (long int) ret_extent, (long int) rank);\n-\t}\n+        bounds_iforeach_return ((array_t *) retarray, (array_t *) array,\n+\t                        \"MAXLOC\");\n     }\n \n   dstride = GFC_DESCRIPTOR_STRIDE(retarray,0);\n@@ -186,38 +173,11 @@ mmaxloc0_8_i2 (gfc_array_i8 * const restrict retarray,\n     {\n       if (unlikely (compile_options.bounds_check))\n \t{\n-\t  int ret_rank, mask_rank;\n-\t  index_type ret_extent;\n-\t  int n;\n-\t  index_type array_extent, mask_extent;\n-\n-\t  ret_rank = GFC_DESCRIPTOR_RANK (retarray);\n-\t  if (ret_rank != 1)\n-\t    runtime_error (\"rank of return array in MAXLOC intrinsic\"\n-\t\t\t   \" should be 1, is %ld\", (long int) ret_rank);\n-\n-\t  ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,0);\n-\t  if (ret_extent != rank)\n-\t    runtime_error (\"Incorrect extent in return value of\"\n-\t\t\t   \" MAXLOC intrnisic: is %ld, should be %ld\",\n-\t\t\t   (long int) ret_extent, (long int) rank);\n-\t\n-\t  mask_rank = GFC_DESCRIPTOR_RANK (mask);\n-\t  if (rank != mask_rank)\n-\t    runtime_error (\"rank of MASK argument in MAXLOC intrnisic\"\n-\t                   \"should be %ld, is %ld\", (long int) rank,\n-\t\t\t   (long int) mask_rank);\n-\n-\t  for (n=0; n<rank; n++)\n-\t    {\n-\t      array_extent = GFC_DESCRIPTOR_EXTENT(array,n);\n-\t      mask_extent = GFC_DESCRIPTOR_EXTENT(mask,n);\n-\t      if (array_extent != mask_extent)\n-\t\truntime_error (\"Incorrect extent in MASK argument of\"\n-\t\t\t       \" MAXLOC intrinsic in dimension %ld:\"\n-\t\t\t       \" is %ld, should be %ld\", (long int) n + 1,\n-\t\t\t       (long int) mask_extent, (long int) array_extent);\n-\t    }\n+\n+\t  bounds_iforeach_return ((array_t *) retarray, (array_t *) array,\n+\t\t\t\t  \"MAXLOC\");\n+\t  bounds_equal_extents ((array_t *) mask, (array_t *) array,\n+\t\t\t\t  \"MASK argument\", \"MAXLOC\");\n \t}\n     }\n \n@@ -340,22 +300,10 @@ smaxloc0_8_i2 (gfc_array_i8 * const restrict retarray,\n       retarray->offset = 0;\n       retarray->data = internal_malloc_size (sizeof (GFC_INTEGER_8) * rank);\n     }\n-  else\n+  else if (unlikely (compile_options.bounds_check))\n     {\n-      if (unlikely (compile_options.bounds_check))\n-\t{\n-\t  int ret_rank;\n-\t  index_type ret_extent;\n-\n-\t  ret_rank = GFC_DESCRIPTOR_RANK (retarray);\n-\t  if (ret_rank != 1)\n-\t    runtime_error (\"rank of return array in MAXLOC intrinsic\"\n-\t\t\t   \" should be 1, is %ld\", (long int) ret_rank);\n-\n-\t  ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,0);\n-\t    if (ret_extent != rank)\n-\t      runtime_error (\"dimension of return array incorrect\");\n-\t}\n+       bounds_iforeach_return ((array_t *) retarray, (array_t *) array,\n+\t\t\t       \"MAXLOC\");\n     }\n \n   dstride = GFC_DESCRIPTOR_STRIDE(retarray,0);"}, {"sha": "1b0bc42bf6915afb20ed46955fc9f02fc3e3e4d4", "filename": "libgfortran/generated/maxloc0_8_i4.c", "status": "modified", "additions": 10, "deletions": 62, "changes": 72, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/16bff92192676901670042cdce3fbd5f9c928fc8/libgfortran%2Fgenerated%2Fmaxloc0_8_i4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/16bff92192676901670042cdce3fbd5f9c928fc8/libgfortran%2Fgenerated%2Fmaxloc0_8_i4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxloc0_8_i4.c?ref=16bff92192676901670042cdce3fbd5f9c928fc8", "patch": "@@ -63,21 +63,8 @@ maxloc0_8_i4 (gfc_array_i8 * const restrict retarray,\n   else\n     {\n       if (unlikely (compile_options.bounds_check))\n-\t{\n-\t  int ret_rank;\n-\t  index_type ret_extent;\n-\n-\t  ret_rank = GFC_DESCRIPTOR_RANK (retarray);\n-\t  if (ret_rank != 1)\n-\t    runtime_error (\"rank of return array in MAXLOC intrinsic\"\n-\t\t\t   \" should be 1, is %ld\", (long int) ret_rank);\n-\n-\t  ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,0);\n-\t  if (ret_extent != rank)\n-\t    runtime_error (\"Incorrect extent in return value of\"\n-\t\t\t   \" MAXLOC intrnisic: is %ld, should be %ld\",\n-\t\t\t   (long int) ret_extent, (long int) rank);\n-\t}\n+        bounds_iforeach_return ((array_t *) retarray, (array_t *) array,\n+\t                        \"MAXLOC\");\n     }\n \n   dstride = GFC_DESCRIPTOR_STRIDE(retarray,0);\n@@ -186,38 +173,11 @@ mmaxloc0_8_i4 (gfc_array_i8 * const restrict retarray,\n     {\n       if (unlikely (compile_options.bounds_check))\n \t{\n-\t  int ret_rank, mask_rank;\n-\t  index_type ret_extent;\n-\t  int n;\n-\t  index_type array_extent, mask_extent;\n-\n-\t  ret_rank = GFC_DESCRIPTOR_RANK (retarray);\n-\t  if (ret_rank != 1)\n-\t    runtime_error (\"rank of return array in MAXLOC intrinsic\"\n-\t\t\t   \" should be 1, is %ld\", (long int) ret_rank);\n-\n-\t  ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,0);\n-\t  if (ret_extent != rank)\n-\t    runtime_error (\"Incorrect extent in return value of\"\n-\t\t\t   \" MAXLOC intrnisic: is %ld, should be %ld\",\n-\t\t\t   (long int) ret_extent, (long int) rank);\n-\t\n-\t  mask_rank = GFC_DESCRIPTOR_RANK (mask);\n-\t  if (rank != mask_rank)\n-\t    runtime_error (\"rank of MASK argument in MAXLOC intrnisic\"\n-\t                   \"should be %ld, is %ld\", (long int) rank,\n-\t\t\t   (long int) mask_rank);\n-\n-\t  for (n=0; n<rank; n++)\n-\t    {\n-\t      array_extent = GFC_DESCRIPTOR_EXTENT(array,n);\n-\t      mask_extent = GFC_DESCRIPTOR_EXTENT(mask,n);\n-\t      if (array_extent != mask_extent)\n-\t\truntime_error (\"Incorrect extent in MASK argument of\"\n-\t\t\t       \" MAXLOC intrinsic in dimension %ld:\"\n-\t\t\t       \" is %ld, should be %ld\", (long int) n + 1,\n-\t\t\t       (long int) mask_extent, (long int) array_extent);\n-\t    }\n+\n+\t  bounds_iforeach_return ((array_t *) retarray, (array_t *) array,\n+\t\t\t\t  \"MAXLOC\");\n+\t  bounds_equal_extents ((array_t *) mask, (array_t *) array,\n+\t\t\t\t  \"MASK argument\", \"MAXLOC\");\n \t}\n     }\n \n@@ -340,22 +300,10 @@ smaxloc0_8_i4 (gfc_array_i8 * const restrict retarray,\n       retarray->offset = 0;\n       retarray->data = internal_malloc_size (sizeof (GFC_INTEGER_8) * rank);\n     }\n-  else\n+  else if (unlikely (compile_options.bounds_check))\n     {\n-      if (unlikely (compile_options.bounds_check))\n-\t{\n-\t  int ret_rank;\n-\t  index_type ret_extent;\n-\n-\t  ret_rank = GFC_DESCRIPTOR_RANK (retarray);\n-\t  if (ret_rank != 1)\n-\t    runtime_error (\"rank of return array in MAXLOC intrinsic\"\n-\t\t\t   \" should be 1, is %ld\", (long int) ret_rank);\n-\n-\t  ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,0);\n-\t    if (ret_extent != rank)\n-\t      runtime_error (\"dimension of return array incorrect\");\n-\t}\n+       bounds_iforeach_return ((array_t *) retarray, (array_t *) array,\n+\t\t\t       \"MAXLOC\");\n     }\n \n   dstride = GFC_DESCRIPTOR_STRIDE(retarray,0);"}, {"sha": "5bf95201d7c767e96f19ef691ad3051ab77ed42c", "filename": "libgfortran/generated/maxloc0_8_i8.c", "status": "modified", "additions": 10, "deletions": 62, "changes": 72, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/16bff92192676901670042cdce3fbd5f9c928fc8/libgfortran%2Fgenerated%2Fmaxloc0_8_i8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/16bff92192676901670042cdce3fbd5f9c928fc8/libgfortran%2Fgenerated%2Fmaxloc0_8_i8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxloc0_8_i8.c?ref=16bff92192676901670042cdce3fbd5f9c928fc8", "patch": "@@ -63,21 +63,8 @@ maxloc0_8_i8 (gfc_array_i8 * const restrict retarray,\n   else\n     {\n       if (unlikely (compile_options.bounds_check))\n-\t{\n-\t  int ret_rank;\n-\t  index_type ret_extent;\n-\n-\t  ret_rank = GFC_DESCRIPTOR_RANK (retarray);\n-\t  if (ret_rank != 1)\n-\t    runtime_error (\"rank of return array in MAXLOC intrinsic\"\n-\t\t\t   \" should be 1, is %ld\", (long int) ret_rank);\n-\n-\t  ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,0);\n-\t  if (ret_extent != rank)\n-\t    runtime_error (\"Incorrect extent in return value of\"\n-\t\t\t   \" MAXLOC intrnisic: is %ld, should be %ld\",\n-\t\t\t   (long int) ret_extent, (long int) rank);\n-\t}\n+        bounds_iforeach_return ((array_t *) retarray, (array_t *) array,\n+\t                        \"MAXLOC\");\n     }\n \n   dstride = GFC_DESCRIPTOR_STRIDE(retarray,0);\n@@ -186,38 +173,11 @@ mmaxloc0_8_i8 (gfc_array_i8 * const restrict retarray,\n     {\n       if (unlikely (compile_options.bounds_check))\n \t{\n-\t  int ret_rank, mask_rank;\n-\t  index_type ret_extent;\n-\t  int n;\n-\t  index_type array_extent, mask_extent;\n-\n-\t  ret_rank = GFC_DESCRIPTOR_RANK (retarray);\n-\t  if (ret_rank != 1)\n-\t    runtime_error (\"rank of return array in MAXLOC intrinsic\"\n-\t\t\t   \" should be 1, is %ld\", (long int) ret_rank);\n-\n-\t  ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,0);\n-\t  if (ret_extent != rank)\n-\t    runtime_error (\"Incorrect extent in return value of\"\n-\t\t\t   \" MAXLOC intrnisic: is %ld, should be %ld\",\n-\t\t\t   (long int) ret_extent, (long int) rank);\n-\t\n-\t  mask_rank = GFC_DESCRIPTOR_RANK (mask);\n-\t  if (rank != mask_rank)\n-\t    runtime_error (\"rank of MASK argument in MAXLOC intrnisic\"\n-\t                   \"should be %ld, is %ld\", (long int) rank,\n-\t\t\t   (long int) mask_rank);\n-\n-\t  for (n=0; n<rank; n++)\n-\t    {\n-\t      array_extent = GFC_DESCRIPTOR_EXTENT(array,n);\n-\t      mask_extent = GFC_DESCRIPTOR_EXTENT(mask,n);\n-\t      if (array_extent != mask_extent)\n-\t\truntime_error (\"Incorrect extent in MASK argument of\"\n-\t\t\t       \" MAXLOC intrinsic in dimension %ld:\"\n-\t\t\t       \" is %ld, should be %ld\", (long int) n + 1,\n-\t\t\t       (long int) mask_extent, (long int) array_extent);\n-\t    }\n+\n+\t  bounds_iforeach_return ((array_t *) retarray, (array_t *) array,\n+\t\t\t\t  \"MAXLOC\");\n+\t  bounds_equal_extents ((array_t *) mask, (array_t *) array,\n+\t\t\t\t  \"MASK argument\", \"MAXLOC\");\n \t}\n     }\n \n@@ -340,22 +300,10 @@ smaxloc0_8_i8 (gfc_array_i8 * const restrict retarray,\n       retarray->offset = 0;\n       retarray->data = internal_malloc_size (sizeof (GFC_INTEGER_8) * rank);\n     }\n-  else\n+  else if (unlikely (compile_options.bounds_check))\n     {\n-      if (unlikely (compile_options.bounds_check))\n-\t{\n-\t  int ret_rank;\n-\t  index_type ret_extent;\n-\n-\t  ret_rank = GFC_DESCRIPTOR_RANK (retarray);\n-\t  if (ret_rank != 1)\n-\t    runtime_error (\"rank of return array in MAXLOC intrinsic\"\n-\t\t\t   \" should be 1, is %ld\", (long int) ret_rank);\n-\n-\t  ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,0);\n-\t    if (ret_extent != rank)\n-\t      runtime_error (\"dimension of return array incorrect\");\n-\t}\n+       bounds_iforeach_return ((array_t *) retarray, (array_t *) array,\n+\t\t\t       \"MAXLOC\");\n     }\n \n   dstride = GFC_DESCRIPTOR_STRIDE(retarray,0);"}, {"sha": "28008d4a0c4ebd01e320bbd846002d3e7d2e04eb", "filename": "libgfortran/generated/maxloc0_8_r10.c", "status": "modified", "additions": 10, "deletions": 62, "changes": 72, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/16bff92192676901670042cdce3fbd5f9c928fc8/libgfortran%2Fgenerated%2Fmaxloc0_8_r10.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/16bff92192676901670042cdce3fbd5f9c928fc8/libgfortran%2Fgenerated%2Fmaxloc0_8_r10.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxloc0_8_r10.c?ref=16bff92192676901670042cdce3fbd5f9c928fc8", "patch": "@@ -63,21 +63,8 @@ maxloc0_8_r10 (gfc_array_i8 * const restrict retarray,\n   else\n     {\n       if (unlikely (compile_options.bounds_check))\n-\t{\n-\t  int ret_rank;\n-\t  index_type ret_extent;\n-\n-\t  ret_rank = GFC_DESCRIPTOR_RANK (retarray);\n-\t  if (ret_rank != 1)\n-\t    runtime_error (\"rank of return array in MAXLOC intrinsic\"\n-\t\t\t   \" should be 1, is %ld\", (long int) ret_rank);\n-\n-\t  ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,0);\n-\t  if (ret_extent != rank)\n-\t    runtime_error (\"Incorrect extent in return value of\"\n-\t\t\t   \" MAXLOC intrnisic: is %ld, should be %ld\",\n-\t\t\t   (long int) ret_extent, (long int) rank);\n-\t}\n+        bounds_iforeach_return ((array_t *) retarray, (array_t *) array,\n+\t                        \"MAXLOC\");\n     }\n \n   dstride = GFC_DESCRIPTOR_STRIDE(retarray,0);\n@@ -186,38 +173,11 @@ mmaxloc0_8_r10 (gfc_array_i8 * const restrict retarray,\n     {\n       if (unlikely (compile_options.bounds_check))\n \t{\n-\t  int ret_rank, mask_rank;\n-\t  index_type ret_extent;\n-\t  int n;\n-\t  index_type array_extent, mask_extent;\n-\n-\t  ret_rank = GFC_DESCRIPTOR_RANK (retarray);\n-\t  if (ret_rank != 1)\n-\t    runtime_error (\"rank of return array in MAXLOC intrinsic\"\n-\t\t\t   \" should be 1, is %ld\", (long int) ret_rank);\n-\n-\t  ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,0);\n-\t  if (ret_extent != rank)\n-\t    runtime_error (\"Incorrect extent in return value of\"\n-\t\t\t   \" MAXLOC intrnisic: is %ld, should be %ld\",\n-\t\t\t   (long int) ret_extent, (long int) rank);\n-\t\n-\t  mask_rank = GFC_DESCRIPTOR_RANK (mask);\n-\t  if (rank != mask_rank)\n-\t    runtime_error (\"rank of MASK argument in MAXLOC intrnisic\"\n-\t                   \"should be %ld, is %ld\", (long int) rank,\n-\t\t\t   (long int) mask_rank);\n-\n-\t  for (n=0; n<rank; n++)\n-\t    {\n-\t      array_extent = GFC_DESCRIPTOR_EXTENT(array,n);\n-\t      mask_extent = GFC_DESCRIPTOR_EXTENT(mask,n);\n-\t      if (array_extent != mask_extent)\n-\t\truntime_error (\"Incorrect extent in MASK argument of\"\n-\t\t\t       \" MAXLOC intrinsic in dimension %ld:\"\n-\t\t\t       \" is %ld, should be %ld\", (long int) n + 1,\n-\t\t\t       (long int) mask_extent, (long int) array_extent);\n-\t    }\n+\n+\t  bounds_iforeach_return ((array_t *) retarray, (array_t *) array,\n+\t\t\t\t  \"MAXLOC\");\n+\t  bounds_equal_extents ((array_t *) mask, (array_t *) array,\n+\t\t\t\t  \"MASK argument\", \"MAXLOC\");\n \t}\n     }\n \n@@ -340,22 +300,10 @@ smaxloc0_8_r10 (gfc_array_i8 * const restrict retarray,\n       retarray->offset = 0;\n       retarray->data = internal_malloc_size (sizeof (GFC_INTEGER_8) * rank);\n     }\n-  else\n+  else if (unlikely (compile_options.bounds_check))\n     {\n-      if (unlikely (compile_options.bounds_check))\n-\t{\n-\t  int ret_rank;\n-\t  index_type ret_extent;\n-\n-\t  ret_rank = GFC_DESCRIPTOR_RANK (retarray);\n-\t  if (ret_rank != 1)\n-\t    runtime_error (\"rank of return array in MAXLOC intrinsic\"\n-\t\t\t   \" should be 1, is %ld\", (long int) ret_rank);\n-\n-\t  ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,0);\n-\t    if (ret_extent != rank)\n-\t      runtime_error (\"dimension of return array incorrect\");\n-\t}\n+       bounds_iforeach_return ((array_t *) retarray, (array_t *) array,\n+\t\t\t       \"MAXLOC\");\n     }\n \n   dstride = GFC_DESCRIPTOR_STRIDE(retarray,0);"}, {"sha": "04bfd57e1fc3f8e943cd0d54f12021d8370b1a5c", "filename": "libgfortran/generated/maxloc0_8_r16.c", "status": "modified", "additions": 10, "deletions": 62, "changes": 72, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/16bff92192676901670042cdce3fbd5f9c928fc8/libgfortran%2Fgenerated%2Fmaxloc0_8_r16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/16bff92192676901670042cdce3fbd5f9c928fc8/libgfortran%2Fgenerated%2Fmaxloc0_8_r16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxloc0_8_r16.c?ref=16bff92192676901670042cdce3fbd5f9c928fc8", "patch": "@@ -63,21 +63,8 @@ maxloc0_8_r16 (gfc_array_i8 * const restrict retarray,\n   else\n     {\n       if (unlikely (compile_options.bounds_check))\n-\t{\n-\t  int ret_rank;\n-\t  index_type ret_extent;\n-\n-\t  ret_rank = GFC_DESCRIPTOR_RANK (retarray);\n-\t  if (ret_rank != 1)\n-\t    runtime_error (\"rank of return array in MAXLOC intrinsic\"\n-\t\t\t   \" should be 1, is %ld\", (long int) ret_rank);\n-\n-\t  ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,0);\n-\t  if (ret_extent != rank)\n-\t    runtime_error (\"Incorrect extent in return value of\"\n-\t\t\t   \" MAXLOC intrnisic: is %ld, should be %ld\",\n-\t\t\t   (long int) ret_extent, (long int) rank);\n-\t}\n+        bounds_iforeach_return ((array_t *) retarray, (array_t *) array,\n+\t                        \"MAXLOC\");\n     }\n \n   dstride = GFC_DESCRIPTOR_STRIDE(retarray,0);\n@@ -186,38 +173,11 @@ mmaxloc0_8_r16 (gfc_array_i8 * const restrict retarray,\n     {\n       if (unlikely (compile_options.bounds_check))\n \t{\n-\t  int ret_rank, mask_rank;\n-\t  index_type ret_extent;\n-\t  int n;\n-\t  index_type array_extent, mask_extent;\n-\n-\t  ret_rank = GFC_DESCRIPTOR_RANK (retarray);\n-\t  if (ret_rank != 1)\n-\t    runtime_error (\"rank of return array in MAXLOC intrinsic\"\n-\t\t\t   \" should be 1, is %ld\", (long int) ret_rank);\n-\n-\t  ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,0);\n-\t  if (ret_extent != rank)\n-\t    runtime_error (\"Incorrect extent in return value of\"\n-\t\t\t   \" MAXLOC intrnisic: is %ld, should be %ld\",\n-\t\t\t   (long int) ret_extent, (long int) rank);\n-\t\n-\t  mask_rank = GFC_DESCRIPTOR_RANK (mask);\n-\t  if (rank != mask_rank)\n-\t    runtime_error (\"rank of MASK argument in MAXLOC intrnisic\"\n-\t                   \"should be %ld, is %ld\", (long int) rank,\n-\t\t\t   (long int) mask_rank);\n-\n-\t  for (n=0; n<rank; n++)\n-\t    {\n-\t      array_extent = GFC_DESCRIPTOR_EXTENT(array,n);\n-\t      mask_extent = GFC_DESCRIPTOR_EXTENT(mask,n);\n-\t      if (array_extent != mask_extent)\n-\t\truntime_error (\"Incorrect extent in MASK argument of\"\n-\t\t\t       \" MAXLOC intrinsic in dimension %ld:\"\n-\t\t\t       \" is %ld, should be %ld\", (long int) n + 1,\n-\t\t\t       (long int) mask_extent, (long int) array_extent);\n-\t    }\n+\n+\t  bounds_iforeach_return ((array_t *) retarray, (array_t *) array,\n+\t\t\t\t  \"MAXLOC\");\n+\t  bounds_equal_extents ((array_t *) mask, (array_t *) array,\n+\t\t\t\t  \"MASK argument\", \"MAXLOC\");\n \t}\n     }\n \n@@ -340,22 +300,10 @@ smaxloc0_8_r16 (gfc_array_i8 * const restrict retarray,\n       retarray->offset = 0;\n       retarray->data = internal_malloc_size (sizeof (GFC_INTEGER_8) * rank);\n     }\n-  else\n+  else if (unlikely (compile_options.bounds_check))\n     {\n-      if (unlikely (compile_options.bounds_check))\n-\t{\n-\t  int ret_rank;\n-\t  index_type ret_extent;\n-\n-\t  ret_rank = GFC_DESCRIPTOR_RANK (retarray);\n-\t  if (ret_rank != 1)\n-\t    runtime_error (\"rank of return array in MAXLOC intrinsic\"\n-\t\t\t   \" should be 1, is %ld\", (long int) ret_rank);\n-\n-\t  ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,0);\n-\t    if (ret_extent != rank)\n-\t      runtime_error (\"dimension of return array incorrect\");\n-\t}\n+       bounds_iforeach_return ((array_t *) retarray, (array_t *) array,\n+\t\t\t       \"MAXLOC\");\n     }\n \n   dstride = GFC_DESCRIPTOR_STRIDE(retarray,0);"}, {"sha": "238b8699bac668e8bd4072aead590f2d5e9e36b5", "filename": "libgfortran/generated/maxloc0_8_r4.c", "status": "modified", "additions": 10, "deletions": 62, "changes": 72, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/16bff92192676901670042cdce3fbd5f9c928fc8/libgfortran%2Fgenerated%2Fmaxloc0_8_r4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/16bff92192676901670042cdce3fbd5f9c928fc8/libgfortran%2Fgenerated%2Fmaxloc0_8_r4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxloc0_8_r4.c?ref=16bff92192676901670042cdce3fbd5f9c928fc8", "patch": "@@ -63,21 +63,8 @@ maxloc0_8_r4 (gfc_array_i8 * const restrict retarray,\n   else\n     {\n       if (unlikely (compile_options.bounds_check))\n-\t{\n-\t  int ret_rank;\n-\t  index_type ret_extent;\n-\n-\t  ret_rank = GFC_DESCRIPTOR_RANK (retarray);\n-\t  if (ret_rank != 1)\n-\t    runtime_error (\"rank of return array in MAXLOC intrinsic\"\n-\t\t\t   \" should be 1, is %ld\", (long int) ret_rank);\n-\n-\t  ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,0);\n-\t  if (ret_extent != rank)\n-\t    runtime_error (\"Incorrect extent in return value of\"\n-\t\t\t   \" MAXLOC intrnisic: is %ld, should be %ld\",\n-\t\t\t   (long int) ret_extent, (long int) rank);\n-\t}\n+        bounds_iforeach_return ((array_t *) retarray, (array_t *) array,\n+\t                        \"MAXLOC\");\n     }\n \n   dstride = GFC_DESCRIPTOR_STRIDE(retarray,0);\n@@ -186,38 +173,11 @@ mmaxloc0_8_r4 (gfc_array_i8 * const restrict retarray,\n     {\n       if (unlikely (compile_options.bounds_check))\n \t{\n-\t  int ret_rank, mask_rank;\n-\t  index_type ret_extent;\n-\t  int n;\n-\t  index_type array_extent, mask_extent;\n-\n-\t  ret_rank = GFC_DESCRIPTOR_RANK (retarray);\n-\t  if (ret_rank != 1)\n-\t    runtime_error (\"rank of return array in MAXLOC intrinsic\"\n-\t\t\t   \" should be 1, is %ld\", (long int) ret_rank);\n-\n-\t  ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,0);\n-\t  if (ret_extent != rank)\n-\t    runtime_error (\"Incorrect extent in return value of\"\n-\t\t\t   \" MAXLOC intrnisic: is %ld, should be %ld\",\n-\t\t\t   (long int) ret_extent, (long int) rank);\n-\t\n-\t  mask_rank = GFC_DESCRIPTOR_RANK (mask);\n-\t  if (rank != mask_rank)\n-\t    runtime_error (\"rank of MASK argument in MAXLOC intrnisic\"\n-\t                   \"should be %ld, is %ld\", (long int) rank,\n-\t\t\t   (long int) mask_rank);\n-\n-\t  for (n=0; n<rank; n++)\n-\t    {\n-\t      array_extent = GFC_DESCRIPTOR_EXTENT(array,n);\n-\t      mask_extent = GFC_DESCRIPTOR_EXTENT(mask,n);\n-\t      if (array_extent != mask_extent)\n-\t\truntime_error (\"Incorrect extent in MASK argument of\"\n-\t\t\t       \" MAXLOC intrinsic in dimension %ld:\"\n-\t\t\t       \" is %ld, should be %ld\", (long int) n + 1,\n-\t\t\t       (long int) mask_extent, (long int) array_extent);\n-\t    }\n+\n+\t  bounds_iforeach_return ((array_t *) retarray, (array_t *) array,\n+\t\t\t\t  \"MAXLOC\");\n+\t  bounds_equal_extents ((array_t *) mask, (array_t *) array,\n+\t\t\t\t  \"MASK argument\", \"MAXLOC\");\n \t}\n     }\n \n@@ -340,22 +300,10 @@ smaxloc0_8_r4 (gfc_array_i8 * const restrict retarray,\n       retarray->offset = 0;\n       retarray->data = internal_malloc_size (sizeof (GFC_INTEGER_8) * rank);\n     }\n-  else\n+  else if (unlikely (compile_options.bounds_check))\n     {\n-      if (unlikely (compile_options.bounds_check))\n-\t{\n-\t  int ret_rank;\n-\t  index_type ret_extent;\n-\n-\t  ret_rank = GFC_DESCRIPTOR_RANK (retarray);\n-\t  if (ret_rank != 1)\n-\t    runtime_error (\"rank of return array in MAXLOC intrinsic\"\n-\t\t\t   \" should be 1, is %ld\", (long int) ret_rank);\n-\n-\t  ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,0);\n-\t    if (ret_extent != rank)\n-\t      runtime_error (\"dimension of return array incorrect\");\n-\t}\n+       bounds_iforeach_return ((array_t *) retarray, (array_t *) array,\n+\t\t\t       \"MAXLOC\");\n     }\n \n   dstride = GFC_DESCRIPTOR_STRIDE(retarray,0);"}, {"sha": "16d9a45331a4427ff585e871b4641cc745ad9016", "filename": "libgfortran/generated/maxloc0_8_r8.c", "status": "modified", "additions": 10, "deletions": 62, "changes": 72, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/16bff92192676901670042cdce3fbd5f9c928fc8/libgfortran%2Fgenerated%2Fmaxloc0_8_r8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/16bff92192676901670042cdce3fbd5f9c928fc8/libgfortran%2Fgenerated%2Fmaxloc0_8_r8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxloc0_8_r8.c?ref=16bff92192676901670042cdce3fbd5f9c928fc8", "patch": "@@ -63,21 +63,8 @@ maxloc0_8_r8 (gfc_array_i8 * const restrict retarray,\n   else\n     {\n       if (unlikely (compile_options.bounds_check))\n-\t{\n-\t  int ret_rank;\n-\t  index_type ret_extent;\n-\n-\t  ret_rank = GFC_DESCRIPTOR_RANK (retarray);\n-\t  if (ret_rank != 1)\n-\t    runtime_error (\"rank of return array in MAXLOC intrinsic\"\n-\t\t\t   \" should be 1, is %ld\", (long int) ret_rank);\n-\n-\t  ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,0);\n-\t  if (ret_extent != rank)\n-\t    runtime_error (\"Incorrect extent in return value of\"\n-\t\t\t   \" MAXLOC intrnisic: is %ld, should be %ld\",\n-\t\t\t   (long int) ret_extent, (long int) rank);\n-\t}\n+        bounds_iforeach_return ((array_t *) retarray, (array_t *) array,\n+\t                        \"MAXLOC\");\n     }\n \n   dstride = GFC_DESCRIPTOR_STRIDE(retarray,0);\n@@ -186,38 +173,11 @@ mmaxloc0_8_r8 (gfc_array_i8 * const restrict retarray,\n     {\n       if (unlikely (compile_options.bounds_check))\n \t{\n-\t  int ret_rank, mask_rank;\n-\t  index_type ret_extent;\n-\t  int n;\n-\t  index_type array_extent, mask_extent;\n-\n-\t  ret_rank = GFC_DESCRIPTOR_RANK (retarray);\n-\t  if (ret_rank != 1)\n-\t    runtime_error (\"rank of return array in MAXLOC intrinsic\"\n-\t\t\t   \" should be 1, is %ld\", (long int) ret_rank);\n-\n-\t  ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,0);\n-\t  if (ret_extent != rank)\n-\t    runtime_error (\"Incorrect extent in return value of\"\n-\t\t\t   \" MAXLOC intrnisic: is %ld, should be %ld\",\n-\t\t\t   (long int) ret_extent, (long int) rank);\n-\t\n-\t  mask_rank = GFC_DESCRIPTOR_RANK (mask);\n-\t  if (rank != mask_rank)\n-\t    runtime_error (\"rank of MASK argument in MAXLOC intrnisic\"\n-\t                   \"should be %ld, is %ld\", (long int) rank,\n-\t\t\t   (long int) mask_rank);\n-\n-\t  for (n=0; n<rank; n++)\n-\t    {\n-\t      array_extent = GFC_DESCRIPTOR_EXTENT(array,n);\n-\t      mask_extent = GFC_DESCRIPTOR_EXTENT(mask,n);\n-\t      if (array_extent != mask_extent)\n-\t\truntime_error (\"Incorrect extent in MASK argument of\"\n-\t\t\t       \" MAXLOC intrinsic in dimension %ld:\"\n-\t\t\t       \" is %ld, should be %ld\", (long int) n + 1,\n-\t\t\t       (long int) mask_extent, (long int) array_extent);\n-\t    }\n+\n+\t  bounds_iforeach_return ((array_t *) retarray, (array_t *) array,\n+\t\t\t\t  \"MAXLOC\");\n+\t  bounds_equal_extents ((array_t *) mask, (array_t *) array,\n+\t\t\t\t  \"MASK argument\", \"MAXLOC\");\n \t}\n     }\n \n@@ -340,22 +300,10 @@ smaxloc0_8_r8 (gfc_array_i8 * const restrict retarray,\n       retarray->offset = 0;\n       retarray->data = internal_malloc_size (sizeof (GFC_INTEGER_8) * rank);\n     }\n-  else\n+  else if (unlikely (compile_options.bounds_check))\n     {\n-      if (unlikely (compile_options.bounds_check))\n-\t{\n-\t  int ret_rank;\n-\t  index_type ret_extent;\n-\n-\t  ret_rank = GFC_DESCRIPTOR_RANK (retarray);\n-\t  if (ret_rank != 1)\n-\t    runtime_error (\"rank of return array in MAXLOC intrinsic\"\n-\t\t\t   \" should be 1, is %ld\", (long int) ret_rank);\n-\n-\t  ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,0);\n-\t    if (ret_extent != rank)\n-\t      runtime_error (\"dimension of return array incorrect\");\n-\t}\n+       bounds_iforeach_return ((array_t *) retarray, (array_t *) array,\n+\t\t\t       \"MAXLOC\");\n     }\n \n   dstride = GFC_DESCRIPTOR_STRIDE(retarray,0);"}, {"sha": "9be5cdd6d450a31efc1ffca31770e44c7876a1d0", "filename": "libgfortran/generated/maxloc1_16_i1.c", "status": "modified", "additions": 6, "deletions": 36, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/16bff92192676901670042cdce3fbd5f9c928fc8/libgfortran%2Fgenerated%2Fmaxloc1_16_i1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/16bff92192676901670042cdce3fbd5f9c928fc8/libgfortran%2Fgenerated%2Fmaxloc1_16_i1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxloc1_16_i1.c?ref=16bff92192676901670042cdce3fbd5f9c928fc8", "patch": "@@ -120,19 +120,8 @@ maxloc1_16_i1 (gfc_array_i16 * const restrict retarray,\n \t\t       (long int) rank);\n \n       if (unlikely (compile_options.bounds_check))\n-\t{\n-\t  for (n=0; n < rank; n++)\n-\t    {\n-\t      index_type ret_extent;\n-\n-\t      ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,n);\n-\t      if (extent[n] != ret_extent)\n-\t\truntime_error (\"Incorrect extent in return value of\"\n-\t\t\t       \" MAXLOC intrinsic in dimension %ld:\"\n-\t\t\t       \" is %ld, should be %ld\", (long int) n + 1,\n-\t\t\t       (long int) ret_extent, (long int) extent[n]);\n-\t    }\n-\t}\n+\tbounds_ifunction_return ((array_t *) retarray, extent,\n+\t\t\t\t \"return value\", \"MAXLOC\");\n     }\n \n   for (n = 0; n < rank; n++)\n@@ -313,29 +302,10 @@ mmaxloc1_16_i1 (gfc_array_i16 * const restrict retarray,\n \n       if (unlikely (compile_options.bounds_check))\n \t{\n-\t  for (n=0; n < rank; n++)\n-\t    {\n-\t      index_type ret_extent;\n-\n-\t      ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,n);\n-\t      if (extent[n] != ret_extent)\n-\t\truntime_error (\"Incorrect extent in return value of\"\n-\t\t\t       \" MAXLOC intrinsic in dimension %ld:\"\n-\t\t\t       \" is %ld, should be %ld\", (long int) n + 1,\n-\t\t\t       (long int) ret_extent, (long int) extent[n]);\n-\t    }\n-          for (n=0; n<= rank; n++)\n-            {\n-              index_type mask_extent, array_extent;\n-\n-\t      array_extent = GFC_DESCRIPTOR_EXTENT(array,n);\n-\t      mask_extent = GFC_DESCRIPTOR_EXTENT(mask,n);\n-\t      if (array_extent != mask_extent)\n-\t\truntime_error (\"Incorrect extent in MASK argument of\"\n-\t\t\t       \" MAXLOC intrinsic in dimension %ld:\"\n-\t\t\t       \" is %ld, should be %ld\", (long int) n + 1,\n-\t\t\t       (long int) mask_extent, (long int) array_extent);\n-\t    }\n+\t  bounds_ifunction_return ((array_t *) retarray, extent,\n+\t\t\t\t   \"return value\", \"MAXLOC\");\n+\t  bounds_equal_extents ((array_t *) mask, (array_t *) array,\n+\t  \t\t\t\"MASK argument\", \"MAXLOC\");\n \t}\n     }\n "}, {"sha": "9118f85c73c7ec5d392dd8e14c2b62c0016cb9ee", "filename": "libgfortran/generated/maxloc1_16_i16.c", "status": "modified", "additions": 6, "deletions": 36, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/16bff92192676901670042cdce3fbd5f9c928fc8/libgfortran%2Fgenerated%2Fmaxloc1_16_i16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/16bff92192676901670042cdce3fbd5f9c928fc8/libgfortran%2Fgenerated%2Fmaxloc1_16_i16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxloc1_16_i16.c?ref=16bff92192676901670042cdce3fbd5f9c928fc8", "patch": "@@ -120,19 +120,8 @@ maxloc1_16_i16 (gfc_array_i16 * const restrict retarray,\n \t\t       (long int) rank);\n \n       if (unlikely (compile_options.bounds_check))\n-\t{\n-\t  for (n=0; n < rank; n++)\n-\t    {\n-\t      index_type ret_extent;\n-\n-\t      ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,n);\n-\t      if (extent[n] != ret_extent)\n-\t\truntime_error (\"Incorrect extent in return value of\"\n-\t\t\t       \" MAXLOC intrinsic in dimension %ld:\"\n-\t\t\t       \" is %ld, should be %ld\", (long int) n + 1,\n-\t\t\t       (long int) ret_extent, (long int) extent[n]);\n-\t    }\n-\t}\n+\tbounds_ifunction_return ((array_t *) retarray, extent,\n+\t\t\t\t \"return value\", \"MAXLOC\");\n     }\n \n   for (n = 0; n < rank; n++)\n@@ -313,29 +302,10 @@ mmaxloc1_16_i16 (gfc_array_i16 * const restrict retarray,\n \n       if (unlikely (compile_options.bounds_check))\n \t{\n-\t  for (n=0; n < rank; n++)\n-\t    {\n-\t      index_type ret_extent;\n-\n-\t      ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,n);\n-\t      if (extent[n] != ret_extent)\n-\t\truntime_error (\"Incorrect extent in return value of\"\n-\t\t\t       \" MAXLOC intrinsic in dimension %ld:\"\n-\t\t\t       \" is %ld, should be %ld\", (long int) n + 1,\n-\t\t\t       (long int) ret_extent, (long int) extent[n]);\n-\t    }\n-          for (n=0; n<= rank; n++)\n-            {\n-              index_type mask_extent, array_extent;\n-\n-\t      array_extent = GFC_DESCRIPTOR_EXTENT(array,n);\n-\t      mask_extent = GFC_DESCRIPTOR_EXTENT(mask,n);\n-\t      if (array_extent != mask_extent)\n-\t\truntime_error (\"Incorrect extent in MASK argument of\"\n-\t\t\t       \" MAXLOC intrinsic in dimension %ld:\"\n-\t\t\t       \" is %ld, should be %ld\", (long int) n + 1,\n-\t\t\t       (long int) mask_extent, (long int) array_extent);\n-\t    }\n+\t  bounds_ifunction_return ((array_t *) retarray, extent,\n+\t\t\t\t   \"return value\", \"MAXLOC\");\n+\t  bounds_equal_extents ((array_t *) mask, (array_t *) array,\n+\t  \t\t\t\"MASK argument\", \"MAXLOC\");\n \t}\n     }\n "}, {"sha": "66b24b0fadf3d2646c86c1f09ab14f3856b30063", "filename": "libgfortran/generated/maxloc1_16_i2.c", "status": "modified", "additions": 6, "deletions": 36, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/16bff92192676901670042cdce3fbd5f9c928fc8/libgfortran%2Fgenerated%2Fmaxloc1_16_i2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/16bff92192676901670042cdce3fbd5f9c928fc8/libgfortran%2Fgenerated%2Fmaxloc1_16_i2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxloc1_16_i2.c?ref=16bff92192676901670042cdce3fbd5f9c928fc8", "patch": "@@ -120,19 +120,8 @@ maxloc1_16_i2 (gfc_array_i16 * const restrict retarray,\n \t\t       (long int) rank);\n \n       if (unlikely (compile_options.bounds_check))\n-\t{\n-\t  for (n=0; n < rank; n++)\n-\t    {\n-\t      index_type ret_extent;\n-\n-\t      ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,n);\n-\t      if (extent[n] != ret_extent)\n-\t\truntime_error (\"Incorrect extent in return value of\"\n-\t\t\t       \" MAXLOC intrinsic in dimension %ld:\"\n-\t\t\t       \" is %ld, should be %ld\", (long int) n + 1,\n-\t\t\t       (long int) ret_extent, (long int) extent[n]);\n-\t    }\n-\t}\n+\tbounds_ifunction_return ((array_t *) retarray, extent,\n+\t\t\t\t \"return value\", \"MAXLOC\");\n     }\n \n   for (n = 0; n < rank; n++)\n@@ -313,29 +302,10 @@ mmaxloc1_16_i2 (gfc_array_i16 * const restrict retarray,\n \n       if (unlikely (compile_options.bounds_check))\n \t{\n-\t  for (n=0; n < rank; n++)\n-\t    {\n-\t      index_type ret_extent;\n-\n-\t      ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,n);\n-\t      if (extent[n] != ret_extent)\n-\t\truntime_error (\"Incorrect extent in return value of\"\n-\t\t\t       \" MAXLOC intrinsic in dimension %ld:\"\n-\t\t\t       \" is %ld, should be %ld\", (long int) n + 1,\n-\t\t\t       (long int) ret_extent, (long int) extent[n]);\n-\t    }\n-          for (n=0; n<= rank; n++)\n-            {\n-              index_type mask_extent, array_extent;\n-\n-\t      array_extent = GFC_DESCRIPTOR_EXTENT(array,n);\n-\t      mask_extent = GFC_DESCRIPTOR_EXTENT(mask,n);\n-\t      if (array_extent != mask_extent)\n-\t\truntime_error (\"Incorrect extent in MASK argument of\"\n-\t\t\t       \" MAXLOC intrinsic in dimension %ld:\"\n-\t\t\t       \" is %ld, should be %ld\", (long int) n + 1,\n-\t\t\t       (long int) mask_extent, (long int) array_extent);\n-\t    }\n+\t  bounds_ifunction_return ((array_t *) retarray, extent,\n+\t\t\t\t   \"return value\", \"MAXLOC\");\n+\t  bounds_equal_extents ((array_t *) mask, (array_t *) array,\n+\t  \t\t\t\"MASK argument\", \"MAXLOC\");\n \t}\n     }\n "}, {"sha": "3f6c952ebe6e9a999c50d2a6f66bfea03541d65b", "filename": "libgfortran/generated/maxloc1_16_i4.c", "status": "modified", "additions": 6, "deletions": 36, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/16bff92192676901670042cdce3fbd5f9c928fc8/libgfortran%2Fgenerated%2Fmaxloc1_16_i4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/16bff92192676901670042cdce3fbd5f9c928fc8/libgfortran%2Fgenerated%2Fmaxloc1_16_i4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxloc1_16_i4.c?ref=16bff92192676901670042cdce3fbd5f9c928fc8", "patch": "@@ -120,19 +120,8 @@ maxloc1_16_i4 (gfc_array_i16 * const restrict retarray,\n \t\t       (long int) rank);\n \n       if (unlikely (compile_options.bounds_check))\n-\t{\n-\t  for (n=0; n < rank; n++)\n-\t    {\n-\t      index_type ret_extent;\n-\n-\t      ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,n);\n-\t      if (extent[n] != ret_extent)\n-\t\truntime_error (\"Incorrect extent in return value of\"\n-\t\t\t       \" MAXLOC intrinsic in dimension %ld:\"\n-\t\t\t       \" is %ld, should be %ld\", (long int) n + 1,\n-\t\t\t       (long int) ret_extent, (long int) extent[n]);\n-\t    }\n-\t}\n+\tbounds_ifunction_return ((array_t *) retarray, extent,\n+\t\t\t\t \"return value\", \"MAXLOC\");\n     }\n \n   for (n = 0; n < rank; n++)\n@@ -313,29 +302,10 @@ mmaxloc1_16_i4 (gfc_array_i16 * const restrict retarray,\n \n       if (unlikely (compile_options.bounds_check))\n \t{\n-\t  for (n=0; n < rank; n++)\n-\t    {\n-\t      index_type ret_extent;\n-\n-\t      ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,n);\n-\t      if (extent[n] != ret_extent)\n-\t\truntime_error (\"Incorrect extent in return value of\"\n-\t\t\t       \" MAXLOC intrinsic in dimension %ld:\"\n-\t\t\t       \" is %ld, should be %ld\", (long int) n + 1,\n-\t\t\t       (long int) ret_extent, (long int) extent[n]);\n-\t    }\n-          for (n=0; n<= rank; n++)\n-            {\n-              index_type mask_extent, array_extent;\n-\n-\t      array_extent = GFC_DESCRIPTOR_EXTENT(array,n);\n-\t      mask_extent = GFC_DESCRIPTOR_EXTENT(mask,n);\n-\t      if (array_extent != mask_extent)\n-\t\truntime_error (\"Incorrect extent in MASK argument of\"\n-\t\t\t       \" MAXLOC intrinsic in dimension %ld:\"\n-\t\t\t       \" is %ld, should be %ld\", (long int) n + 1,\n-\t\t\t       (long int) mask_extent, (long int) array_extent);\n-\t    }\n+\t  bounds_ifunction_return ((array_t *) retarray, extent,\n+\t\t\t\t   \"return value\", \"MAXLOC\");\n+\t  bounds_equal_extents ((array_t *) mask, (array_t *) array,\n+\t  \t\t\t\"MASK argument\", \"MAXLOC\");\n \t}\n     }\n "}, {"sha": "141dc5142ef7c85608b0ee8f066906a677647237", "filename": "libgfortran/generated/maxloc1_16_i8.c", "status": "modified", "additions": 6, "deletions": 36, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/16bff92192676901670042cdce3fbd5f9c928fc8/libgfortran%2Fgenerated%2Fmaxloc1_16_i8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/16bff92192676901670042cdce3fbd5f9c928fc8/libgfortran%2Fgenerated%2Fmaxloc1_16_i8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxloc1_16_i8.c?ref=16bff92192676901670042cdce3fbd5f9c928fc8", "patch": "@@ -120,19 +120,8 @@ maxloc1_16_i8 (gfc_array_i16 * const restrict retarray,\n \t\t       (long int) rank);\n \n       if (unlikely (compile_options.bounds_check))\n-\t{\n-\t  for (n=0; n < rank; n++)\n-\t    {\n-\t      index_type ret_extent;\n-\n-\t      ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,n);\n-\t      if (extent[n] != ret_extent)\n-\t\truntime_error (\"Incorrect extent in return value of\"\n-\t\t\t       \" MAXLOC intrinsic in dimension %ld:\"\n-\t\t\t       \" is %ld, should be %ld\", (long int) n + 1,\n-\t\t\t       (long int) ret_extent, (long int) extent[n]);\n-\t    }\n-\t}\n+\tbounds_ifunction_return ((array_t *) retarray, extent,\n+\t\t\t\t \"return value\", \"MAXLOC\");\n     }\n \n   for (n = 0; n < rank; n++)\n@@ -313,29 +302,10 @@ mmaxloc1_16_i8 (gfc_array_i16 * const restrict retarray,\n \n       if (unlikely (compile_options.bounds_check))\n \t{\n-\t  for (n=0; n < rank; n++)\n-\t    {\n-\t      index_type ret_extent;\n-\n-\t      ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,n);\n-\t      if (extent[n] != ret_extent)\n-\t\truntime_error (\"Incorrect extent in return value of\"\n-\t\t\t       \" MAXLOC intrinsic in dimension %ld:\"\n-\t\t\t       \" is %ld, should be %ld\", (long int) n + 1,\n-\t\t\t       (long int) ret_extent, (long int) extent[n]);\n-\t    }\n-          for (n=0; n<= rank; n++)\n-            {\n-              index_type mask_extent, array_extent;\n-\n-\t      array_extent = GFC_DESCRIPTOR_EXTENT(array,n);\n-\t      mask_extent = GFC_DESCRIPTOR_EXTENT(mask,n);\n-\t      if (array_extent != mask_extent)\n-\t\truntime_error (\"Incorrect extent in MASK argument of\"\n-\t\t\t       \" MAXLOC intrinsic in dimension %ld:\"\n-\t\t\t       \" is %ld, should be %ld\", (long int) n + 1,\n-\t\t\t       (long int) mask_extent, (long int) array_extent);\n-\t    }\n+\t  bounds_ifunction_return ((array_t *) retarray, extent,\n+\t\t\t\t   \"return value\", \"MAXLOC\");\n+\t  bounds_equal_extents ((array_t *) mask, (array_t *) array,\n+\t  \t\t\t\"MASK argument\", \"MAXLOC\");\n \t}\n     }\n "}, {"sha": "74bc4d305620c3ee0ead9bccdd98661a78e2c486", "filename": "libgfortran/generated/maxloc1_16_r10.c", "status": "modified", "additions": 6, "deletions": 36, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/16bff92192676901670042cdce3fbd5f9c928fc8/libgfortran%2Fgenerated%2Fmaxloc1_16_r10.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/16bff92192676901670042cdce3fbd5f9c928fc8/libgfortran%2Fgenerated%2Fmaxloc1_16_r10.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxloc1_16_r10.c?ref=16bff92192676901670042cdce3fbd5f9c928fc8", "patch": "@@ -120,19 +120,8 @@ maxloc1_16_r10 (gfc_array_i16 * const restrict retarray,\n \t\t       (long int) rank);\n \n       if (unlikely (compile_options.bounds_check))\n-\t{\n-\t  for (n=0; n < rank; n++)\n-\t    {\n-\t      index_type ret_extent;\n-\n-\t      ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,n);\n-\t      if (extent[n] != ret_extent)\n-\t\truntime_error (\"Incorrect extent in return value of\"\n-\t\t\t       \" MAXLOC intrinsic in dimension %ld:\"\n-\t\t\t       \" is %ld, should be %ld\", (long int) n + 1,\n-\t\t\t       (long int) ret_extent, (long int) extent[n]);\n-\t    }\n-\t}\n+\tbounds_ifunction_return ((array_t *) retarray, extent,\n+\t\t\t\t \"return value\", \"MAXLOC\");\n     }\n \n   for (n = 0; n < rank; n++)\n@@ -313,29 +302,10 @@ mmaxloc1_16_r10 (gfc_array_i16 * const restrict retarray,\n \n       if (unlikely (compile_options.bounds_check))\n \t{\n-\t  for (n=0; n < rank; n++)\n-\t    {\n-\t      index_type ret_extent;\n-\n-\t      ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,n);\n-\t      if (extent[n] != ret_extent)\n-\t\truntime_error (\"Incorrect extent in return value of\"\n-\t\t\t       \" MAXLOC intrinsic in dimension %ld:\"\n-\t\t\t       \" is %ld, should be %ld\", (long int) n + 1,\n-\t\t\t       (long int) ret_extent, (long int) extent[n]);\n-\t    }\n-          for (n=0; n<= rank; n++)\n-            {\n-              index_type mask_extent, array_extent;\n-\n-\t      array_extent = GFC_DESCRIPTOR_EXTENT(array,n);\n-\t      mask_extent = GFC_DESCRIPTOR_EXTENT(mask,n);\n-\t      if (array_extent != mask_extent)\n-\t\truntime_error (\"Incorrect extent in MASK argument of\"\n-\t\t\t       \" MAXLOC intrinsic in dimension %ld:\"\n-\t\t\t       \" is %ld, should be %ld\", (long int) n + 1,\n-\t\t\t       (long int) mask_extent, (long int) array_extent);\n-\t    }\n+\t  bounds_ifunction_return ((array_t *) retarray, extent,\n+\t\t\t\t   \"return value\", \"MAXLOC\");\n+\t  bounds_equal_extents ((array_t *) mask, (array_t *) array,\n+\t  \t\t\t\"MASK argument\", \"MAXLOC\");\n \t}\n     }\n "}, {"sha": "cadca8bedb294e60a8a81f02e17db401af664cc0", "filename": "libgfortran/generated/maxloc1_16_r16.c", "status": "modified", "additions": 6, "deletions": 36, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/16bff92192676901670042cdce3fbd5f9c928fc8/libgfortran%2Fgenerated%2Fmaxloc1_16_r16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/16bff92192676901670042cdce3fbd5f9c928fc8/libgfortran%2Fgenerated%2Fmaxloc1_16_r16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxloc1_16_r16.c?ref=16bff92192676901670042cdce3fbd5f9c928fc8", "patch": "@@ -120,19 +120,8 @@ maxloc1_16_r16 (gfc_array_i16 * const restrict retarray,\n \t\t       (long int) rank);\n \n       if (unlikely (compile_options.bounds_check))\n-\t{\n-\t  for (n=0; n < rank; n++)\n-\t    {\n-\t      index_type ret_extent;\n-\n-\t      ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,n);\n-\t      if (extent[n] != ret_extent)\n-\t\truntime_error (\"Incorrect extent in return value of\"\n-\t\t\t       \" MAXLOC intrinsic in dimension %ld:\"\n-\t\t\t       \" is %ld, should be %ld\", (long int) n + 1,\n-\t\t\t       (long int) ret_extent, (long int) extent[n]);\n-\t    }\n-\t}\n+\tbounds_ifunction_return ((array_t *) retarray, extent,\n+\t\t\t\t \"return value\", \"MAXLOC\");\n     }\n \n   for (n = 0; n < rank; n++)\n@@ -313,29 +302,10 @@ mmaxloc1_16_r16 (gfc_array_i16 * const restrict retarray,\n \n       if (unlikely (compile_options.bounds_check))\n \t{\n-\t  for (n=0; n < rank; n++)\n-\t    {\n-\t      index_type ret_extent;\n-\n-\t      ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,n);\n-\t      if (extent[n] != ret_extent)\n-\t\truntime_error (\"Incorrect extent in return value of\"\n-\t\t\t       \" MAXLOC intrinsic in dimension %ld:\"\n-\t\t\t       \" is %ld, should be %ld\", (long int) n + 1,\n-\t\t\t       (long int) ret_extent, (long int) extent[n]);\n-\t    }\n-          for (n=0; n<= rank; n++)\n-            {\n-              index_type mask_extent, array_extent;\n-\n-\t      array_extent = GFC_DESCRIPTOR_EXTENT(array,n);\n-\t      mask_extent = GFC_DESCRIPTOR_EXTENT(mask,n);\n-\t      if (array_extent != mask_extent)\n-\t\truntime_error (\"Incorrect extent in MASK argument of\"\n-\t\t\t       \" MAXLOC intrinsic in dimension %ld:\"\n-\t\t\t       \" is %ld, should be %ld\", (long int) n + 1,\n-\t\t\t       (long int) mask_extent, (long int) array_extent);\n-\t    }\n+\t  bounds_ifunction_return ((array_t *) retarray, extent,\n+\t\t\t\t   \"return value\", \"MAXLOC\");\n+\t  bounds_equal_extents ((array_t *) mask, (array_t *) array,\n+\t  \t\t\t\"MASK argument\", \"MAXLOC\");\n \t}\n     }\n "}, {"sha": "f2afd83ab32b3eac4f34a74fd857b1673fef552a", "filename": "libgfortran/generated/maxloc1_16_r4.c", "status": "modified", "additions": 6, "deletions": 36, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/16bff92192676901670042cdce3fbd5f9c928fc8/libgfortran%2Fgenerated%2Fmaxloc1_16_r4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/16bff92192676901670042cdce3fbd5f9c928fc8/libgfortran%2Fgenerated%2Fmaxloc1_16_r4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxloc1_16_r4.c?ref=16bff92192676901670042cdce3fbd5f9c928fc8", "patch": "@@ -120,19 +120,8 @@ maxloc1_16_r4 (gfc_array_i16 * const restrict retarray,\n \t\t       (long int) rank);\n \n       if (unlikely (compile_options.bounds_check))\n-\t{\n-\t  for (n=0; n < rank; n++)\n-\t    {\n-\t      index_type ret_extent;\n-\n-\t      ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,n);\n-\t      if (extent[n] != ret_extent)\n-\t\truntime_error (\"Incorrect extent in return value of\"\n-\t\t\t       \" MAXLOC intrinsic in dimension %ld:\"\n-\t\t\t       \" is %ld, should be %ld\", (long int) n + 1,\n-\t\t\t       (long int) ret_extent, (long int) extent[n]);\n-\t    }\n-\t}\n+\tbounds_ifunction_return ((array_t *) retarray, extent,\n+\t\t\t\t \"return value\", \"MAXLOC\");\n     }\n \n   for (n = 0; n < rank; n++)\n@@ -313,29 +302,10 @@ mmaxloc1_16_r4 (gfc_array_i16 * const restrict retarray,\n \n       if (unlikely (compile_options.bounds_check))\n \t{\n-\t  for (n=0; n < rank; n++)\n-\t    {\n-\t      index_type ret_extent;\n-\n-\t      ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,n);\n-\t      if (extent[n] != ret_extent)\n-\t\truntime_error (\"Incorrect extent in return value of\"\n-\t\t\t       \" MAXLOC intrinsic in dimension %ld:\"\n-\t\t\t       \" is %ld, should be %ld\", (long int) n + 1,\n-\t\t\t       (long int) ret_extent, (long int) extent[n]);\n-\t    }\n-          for (n=0; n<= rank; n++)\n-            {\n-              index_type mask_extent, array_extent;\n-\n-\t      array_extent = GFC_DESCRIPTOR_EXTENT(array,n);\n-\t      mask_extent = GFC_DESCRIPTOR_EXTENT(mask,n);\n-\t      if (array_extent != mask_extent)\n-\t\truntime_error (\"Incorrect extent in MASK argument of\"\n-\t\t\t       \" MAXLOC intrinsic in dimension %ld:\"\n-\t\t\t       \" is %ld, should be %ld\", (long int) n + 1,\n-\t\t\t       (long int) mask_extent, (long int) array_extent);\n-\t    }\n+\t  bounds_ifunction_return ((array_t *) retarray, extent,\n+\t\t\t\t   \"return value\", \"MAXLOC\");\n+\t  bounds_equal_extents ((array_t *) mask, (array_t *) array,\n+\t  \t\t\t\"MASK argument\", \"MAXLOC\");\n \t}\n     }\n "}, {"sha": "3da10665b72c32847601e4e3c8d47fe81c064749", "filename": "libgfortran/generated/maxloc1_16_r8.c", "status": "modified", "additions": 6, "deletions": 36, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/16bff92192676901670042cdce3fbd5f9c928fc8/libgfortran%2Fgenerated%2Fmaxloc1_16_r8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/16bff92192676901670042cdce3fbd5f9c928fc8/libgfortran%2Fgenerated%2Fmaxloc1_16_r8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxloc1_16_r8.c?ref=16bff92192676901670042cdce3fbd5f9c928fc8", "patch": "@@ -120,19 +120,8 @@ maxloc1_16_r8 (gfc_array_i16 * const restrict retarray,\n \t\t       (long int) rank);\n \n       if (unlikely (compile_options.bounds_check))\n-\t{\n-\t  for (n=0; n < rank; n++)\n-\t    {\n-\t      index_type ret_extent;\n-\n-\t      ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,n);\n-\t      if (extent[n] != ret_extent)\n-\t\truntime_error (\"Incorrect extent in return value of\"\n-\t\t\t       \" MAXLOC intrinsic in dimension %ld:\"\n-\t\t\t       \" is %ld, should be %ld\", (long int) n + 1,\n-\t\t\t       (long int) ret_extent, (long int) extent[n]);\n-\t    }\n-\t}\n+\tbounds_ifunction_return ((array_t *) retarray, extent,\n+\t\t\t\t \"return value\", \"MAXLOC\");\n     }\n \n   for (n = 0; n < rank; n++)\n@@ -313,29 +302,10 @@ mmaxloc1_16_r8 (gfc_array_i16 * const restrict retarray,\n \n       if (unlikely (compile_options.bounds_check))\n \t{\n-\t  for (n=0; n < rank; n++)\n-\t    {\n-\t      index_type ret_extent;\n-\n-\t      ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,n);\n-\t      if (extent[n] != ret_extent)\n-\t\truntime_error (\"Incorrect extent in return value of\"\n-\t\t\t       \" MAXLOC intrinsic in dimension %ld:\"\n-\t\t\t       \" is %ld, should be %ld\", (long int) n + 1,\n-\t\t\t       (long int) ret_extent, (long int) extent[n]);\n-\t    }\n-          for (n=0; n<= rank; n++)\n-            {\n-              index_type mask_extent, array_extent;\n-\n-\t      array_extent = GFC_DESCRIPTOR_EXTENT(array,n);\n-\t      mask_extent = GFC_DESCRIPTOR_EXTENT(mask,n);\n-\t      if (array_extent != mask_extent)\n-\t\truntime_error (\"Incorrect extent in MASK argument of\"\n-\t\t\t       \" MAXLOC intrinsic in dimension %ld:\"\n-\t\t\t       \" is %ld, should be %ld\", (long int) n + 1,\n-\t\t\t       (long int) mask_extent, (long int) array_extent);\n-\t    }\n+\t  bounds_ifunction_return ((array_t *) retarray, extent,\n+\t\t\t\t   \"return value\", \"MAXLOC\");\n+\t  bounds_equal_extents ((array_t *) mask, (array_t *) array,\n+\t  \t\t\t\"MASK argument\", \"MAXLOC\");\n \t}\n     }\n "}, {"sha": "3a76e0ee626cbb90c7db79ff5b0525dc1ed65c47", "filename": "libgfortran/generated/maxloc1_4_i1.c", "status": "modified", "additions": 6, "deletions": 36, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/16bff92192676901670042cdce3fbd5f9c928fc8/libgfortran%2Fgenerated%2Fmaxloc1_4_i1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/16bff92192676901670042cdce3fbd5f9c928fc8/libgfortran%2Fgenerated%2Fmaxloc1_4_i1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxloc1_4_i1.c?ref=16bff92192676901670042cdce3fbd5f9c928fc8", "patch": "@@ -120,19 +120,8 @@ maxloc1_4_i1 (gfc_array_i4 * const restrict retarray,\n \t\t       (long int) rank);\n \n       if (unlikely (compile_options.bounds_check))\n-\t{\n-\t  for (n=0; n < rank; n++)\n-\t    {\n-\t      index_type ret_extent;\n-\n-\t      ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,n);\n-\t      if (extent[n] != ret_extent)\n-\t\truntime_error (\"Incorrect extent in return value of\"\n-\t\t\t       \" MAXLOC intrinsic in dimension %ld:\"\n-\t\t\t       \" is %ld, should be %ld\", (long int) n + 1,\n-\t\t\t       (long int) ret_extent, (long int) extent[n]);\n-\t    }\n-\t}\n+\tbounds_ifunction_return ((array_t *) retarray, extent,\n+\t\t\t\t \"return value\", \"MAXLOC\");\n     }\n \n   for (n = 0; n < rank; n++)\n@@ -313,29 +302,10 @@ mmaxloc1_4_i1 (gfc_array_i4 * const restrict retarray,\n \n       if (unlikely (compile_options.bounds_check))\n \t{\n-\t  for (n=0; n < rank; n++)\n-\t    {\n-\t      index_type ret_extent;\n-\n-\t      ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,n);\n-\t      if (extent[n] != ret_extent)\n-\t\truntime_error (\"Incorrect extent in return value of\"\n-\t\t\t       \" MAXLOC intrinsic in dimension %ld:\"\n-\t\t\t       \" is %ld, should be %ld\", (long int) n + 1,\n-\t\t\t       (long int) ret_extent, (long int) extent[n]);\n-\t    }\n-          for (n=0; n<= rank; n++)\n-            {\n-              index_type mask_extent, array_extent;\n-\n-\t      array_extent = GFC_DESCRIPTOR_EXTENT(array,n);\n-\t      mask_extent = GFC_DESCRIPTOR_EXTENT(mask,n);\n-\t      if (array_extent != mask_extent)\n-\t\truntime_error (\"Incorrect extent in MASK argument of\"\n-\t\t\t       \" MAXLOC intrinsic in dimension %ld:\"\n-\t\t\t       \" is %ld, should be %ld\", (long int) n + 1,\n-\t\t\t       (long int) mask_extent, (long int) array_extent);\n-\t    }\n+\t  bounds_ifunction_return ((array_t *) retarray, extent,\n+\t\t\t\t   \"return value\", \"MAXLOC\");\n+\t  bounds_equal_extents ((array_t *) mask, (array_t *) array,\n+\t  \t\t\t\"MASK argument\", \"MAXLOC\");\n \t}\n     }\n "}, {"sha": "7c3bc2dd3fb5e857083c4b110fec067ce838540f", "filename": "libgfortran/generated/maxloc1_4_i16.c", "status": "modified", "additions": 6, "deletions": 36, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/16bff92192676901670042cdce3fbd5f9c928fc8/libgfortran%2Fgenerated%2Fmaxloc1_4_i16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/16bff92192676901670042cdce3fbd5f9c928fc8/libgfortran%2Fgenerated%2Fmaxloc1_4_i16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxloc1_4_i16.c?ref=16bff92192676901670042cdce3fbd5f9c928fc8", "patch": "@@ -120,19 +120,8 @@ maxloc1_4_i16 (gfc_array_i4 * const restrict retarray,\n \t\t       (long int) rank);\n \n       if (unlikely (compile_options.bounds_check))\n-\t{\n-\t  for (n=0; n < rank; n++)\n-\t    {\n-\t      index_type ret_extent;\n-\n-\t      ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,n);\n-\t      if (extent[n] != ret_extent)\n-\t\truntime_error (\"Incorrect extent in return value of\"\n-\t\t\t       \" MAXLOC intrinsic in dimension %ld:\"\n-\t\t\t       \" is %ld, should be %ld\", (long int) n + 1,\n-\t\t\t       (long int) ret_extent, (long int) extent[n]);\n-\t    }\n-\t}\n+\tbounds_ifunction_return ((array_t *) retarray, extent,\n+\t\t\t\t \"return value\", \"MAXLOC\");\n     }\n \n   for (n = 0; n < rank; n++)\n@@ -313,29 +302,10 @@ mmaxloc1_4_i16 (gfc_array_i4 * const restrict retarray,\n \n       if (unlikely (compile_options.bounds_check))\n \t{\n-\t  for (n=0; n < rank; n++)\n-\t    {\n-\t      index_type ret_extent;\n-\n-\t      ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,n);\n-\t      if (extent[n] != ret_extent)\n-\t\truntime_error (\"Incorrect extent in return value of\"\n-\t\t\t       \" MAXLOC intrinsic in dimension %ld:\"\n-\t\t\t       \" is %ld, should be %ld\", (long int) n + 1,\n-\t\t\t       (long int) ret_extent, (long int) extent[n]);\n-\t    }\n-          for (n=0; n<= rank; n++)\n-            {\n-              index_type mask_extent, array_extent;\n-\n-\t      array_extent = GFC_DESCRIPTOR_EXTENT(array,n);\n-\t      mask_extent = GFC_DESCRIPTOR_EXTENT(mask,n);\n-\t      if (array_extent != mask_extent)\n-\t\truntime_error (\"Incorrect extent in MASK argument of\"\n-\t\t\t       \" MAXLOC intrinsic in dimension %ld:\"\n-\t\t\t       \" is %ld, should be %ld\", (long int) n + 1,\n-\t\t\t       (long int) mask_extent, (long int) array_extent);\n-\t    }\n+\t  bounds_ifunction_return ((array_t *) retarray, extent,\n+\t\t\t\t   \"return value\", \"MAXLOC\");\n+\t  bounds_equal_extents ((array_t *) mask, (array_t *) array,\n+\t  \t\t\t\"MASK argument\", \"MAXLOC\");\n \t}\n     }\n "}, {"sha": "cdcdfa4383a412423a92f74937d6c25057983327", "filename": "libgfortran/generated/maxloc1_4_i2.c", "status": "modified", "additions": 6, "deletions": 36, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/16bff92192676901670042cdce3fbd5f9c928fc8/libgfortran%2Fgenerated%2Fmaxloc1_4_i2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/16bff92192676901670042cdce3fbd5f9c928fc8/libgfortran%2Fgenerated%2Fmaxloc1_4_i2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxloc1_4_i2.c?ref=16bff92192676901670042cdce3fbd5f9c928fc8", "patch": "@@ -120,19 +120,8 @@ maxloc1_4_i2 (gfc_array_i4 * const restrict retarray,\n \t\t       (long int) rank);\n \n       if (unlikely (compile_options.bounds_check))\n-\t{\n-\t  for (n=0; n < rank; n++)\n-\t    {\n-\t      index_type ret_extent;\n-\n-\t      ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,n);\n-\t      if (extent[n] != ret_extent)\n-\t\truntime_error (\"Incorrect extent in return value of\"\n-\t\t\t       \" MAXLOC intrinsic in dimension %ld:\"\n-\t\t\t       \" is %ld, should be %ld\", (long int) n + 1,\n-\t\t\t       (long int) ret_extent, (long int) extent[n]);\n-\t    }\n-\t}\n+\tbounds_ifunction_return ((array_t *) retarray, extent,\n+\t\t\t\t \"return value\", \"MAXLOC\");\n     }\n \n   for (n = 0; n < rank; n++)\n@@ -313,29 +302,10 @@ mmaxloc1_4_i2 (gfc_array_i4 * const restrict retarray,\n \n       if (unlikely (compile_options.bounds_check))\n \t{\n-\t  for (n=0; n < rank; n++)\n-\t    {\n-\t      index_type ret_extent;\n-\n-\t      ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,n);\n-\t      if (extent[n] != ret_extent)\n-\t\truntime_error (\"Incorrect extent in return value of\"\n-\t\t\t       \" MAXLOC intrinsic in dimension %ld:\"\n-\t\t\t       \" is %ld, should be %ld\", (long int) n + 1,\n-\t\t\t       (long int) ret_extent, (long int) extent[n]);\n-\t    }\n-          for (n=0; n<= rank; n++)\n-            {\n-              index_type mask_extent, array_extent;\n-\n-\t      array_extent = GFC_DESCRIPTOR_EXTENT(array,n);\n-\t      mask_extent = GFC_DESCRIPTOR_EXTENT(mask,n);\n-\t      if (array_extent != mask_extent)\n-\t\truntime_error (\"Incorrect extent in MASK argument of\"\n-\t\t\t       \" MAXLOC intrinsic in dimension %ld:\"\n-\t\t\t       \" is %ld, should be %ld\", (long int) n + 1,\n-\t\t\t       (long int) mask_extent, (long int) array_extent);\n-\t    }\n+\t  bounds_ifunction_return ((array_t *) retarray, extent,\n+\t\t\t\t   \"return value\", \"MAXLOC\");\n+\t  bounds_equal_extents ((array_t *) mask, (array_t *) array,\n+\t  \t\t\t\"MASK argument\", \"MAXLOC\");\n \t}\n     }\n "}, {"sha": "bf60007dd2336b3a2086f5e333903c419d97b7a5", "filename": "libgfortran/generated/maxloc1_4_i4.c", "status": "modified", "additions": 6, "deletions": 36, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/16bff92192676901670042cdce3fbd5f9c928fc8/libgfortran%2Fgenerated%2Fmaxloc1_4_i4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/16bff92192676901670042cdce3fbd5f9c928fc8/libgfortran%2Fgenerated%2Fmaxloc1_4_i4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxloc1_4_i4.c?ref=16bff92192676901670042cdce3fbd5f9c928fc8", "patch": "@@ -120,19 +120,8 @@ maxloc1_4_i4 (gfc_array_i4 * const restrict retarray,\n \t\t       (long int) rank);\n \n       if (unlikely (compile_options.bounds_check))\n-\t{\n-\t  for (n=0; n < rank; n++)\n-\t    {\n-\t      index_type ret_extent;\n-\n-\t      ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,n);\n-\t      if (extent[n] != ret_extent)\n-\t\truntime_error (\"Incorrect extent in return value of\"\n-\t\t\t       \" MAXLOC intrinsic in dimension %ld:\"\n-\t\t\t       \" is %ld, should be %ld\", (long int) n + 1,\n-\t\t\t       (long int) ret_extent, (long int) extent[n]);\n-\t    }\n-\t}\n+\tbounds_ifunction_return ((array_t *) retarray, extent,\n+\t\t\t\t \"return value\", \"MAXLOC\");\n     }\n \n   for (n = 0; n < rank; n++)\n@@ -313,29 +302,10 @@ mmaxloc1_4_i4 (gfc_array_i4 * const restrict retarray,\n \n       if (unlikely (compile_options.bounds_check))\n \t{\n-\t  for (n=0; n < rank; n++)\n-\t    {\n-\t      index_type ret_extent;\n-\n-\t      ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,n);\n-\t      if (extent[n] != ret_extent)\n-\t\truntime_error (\"Incorrect extent in return value of\"\n-\t\t\t       \" MAXLOC intrinsic in dimension %ld:\"\n-\t\t\t       \" is %ld, should be %ld\", (long int) n + 1,\n-\t\t\t       (long int) ret_extent, (long int) extent[n]);\n-\t    }\n-          for (n=0; n<= rank; n++)\n-            {\n-              index_type mask_extent, array_extent;\n-\n-\t      array_extent = GFC_DESCRIPTOR_EXTENT(array,n);\n-\t      mask_extent = GFC_DESCRIPTOR_EXTENT(mask,n);\n-\t      if (array_extent != mask_extent)\n-\t\truntime_error (\"Incorrect extent in MASK argument of\"\n-\t\t\t       \" MAXLOC intrinsic in dimension %ld:\"\n-\t\t\t       \" is %ld, should be %ld\", (long int) n + 1,\n-\t\t\t       (long int) mask_extent, (long int) array_extent);\n-\t    }\n+\t  bounds_ifunction_return ((array_t *) retarray, extent,\n+\t\t\t\t   \"return value\", \"MAXLOC\");\n+\t  bounds_equal_extents ((array_t *) mask, (array_t *) array,\n+\t  \t\t\t\"MASK argument\", \"MAXLOC\");\n \t}\n     }\n "}, {"sha": "18edc044d998f46ac810debea20afd34bbeab2c3", "filename": "libgfortran/generated/maxloc1_4_i8.c", "status": "modified", "additions": 6, "deletions": 36, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/16bff92192676901670042cdce3fbd5f9c928fc8/libgfortran%2Fgenerated%2Fmaxloc1_4_i8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/16bff92192676901670042cdce3fbd5f9c928fc8/libgfortran%2Fgenerated%2Fmaxloc1_4_i8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxloc1_4_i8.c?ref=16bff92192676901670042cdce3fbd5f9c928fc8", "patch": "@@ -120,19 +120,8 @@ maxloc1_4_i8 (gfc_array_i4 * const restrict retarray,\n \t\t       (long int) rank);\n \n       if (unlikely (compile_options.bounds_check))\n-\t{\n-\t  for (n=0; n < rank; n++)\n-\t    {\n-\t      index_type ret_extent;\n-\n-\t      ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,n);\n-\t      if (extent[n] != ret_extent)\n-\t\truntime_error (\"Incorrect extent in return value of\"\n-\t\t\t       \" MAXLOC intrinsic in dimension %ld:\"\n-\t\t\t       \" is %ld, should be %ld\", (long int) n + 1,\n-\t\t\t       (long int) ret_extent, (long int) extent[n]);\n-\t    }\n-\t}\n+\tbounds_ifunction_return ((array_t *) retarray, extent,\n+\t\t\t\t \"return value\", \"MAXLOC\");\n     }\n \n   for (n = 0; n < rank; n++)\n@@ -313,29 +302,10 @@ mmaxloc1_4_i8 (gfc_array_i4 * const restrict retarray,\n \n       if (unlikely (compile_options.bounds_check))\n \t{\n-\t  for (n=0; n < rank; n++)\n-\t    {\n-\t      index_type ret_extent;\n-\n-\t      ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,n);\n-\t      if (extent[n] != ret_extent)\n-\t\truntime_error (\"Incorrect extent in return value of\"\n-\t\t\t       \" MAXLOC intrinsic in dimension %ld:\"\n-\t\t\t       \" is %ld, should be %ld\", (long int) n + 1,\n-\t\t\t       (long int) ret_extent, (long int) extent[n]);\n-\t    }\n-          for (n=0; n<= rank; n++)\n-            {\n-              index_type mask_extent, array_extent;\n-\n-\t      array_extent = GFC_DESCRIPTOR_EXTENT(array,n);\n-\t      mask_extent = GFC_DESCRIPTOR_EXTENT(mask,n);\n-\t      if (array_extent != mask_extent)\n-\t\truntime_error (\"Incorrect extent in MASK argument of\"\n-\t\t\t       \" MAXLOC intrinsic in dimension %ld:\"\n-\t\t\t       \" is %ld, should be %ld\", (long int) n + 1,\n-\t\t\t       (long int) mask_extent, (long int) array_extent);\n-\t    }\n+\t  bounds_ifunction_return ((array_t *) retarray, extent,\n+\t\t\t\t   \"return value\", \"MAXLOC\");\n+\t  bounds_equal_extents ((array_t *) mask, (array_t *) array,\n+\t  \t\t\t\"MASK argument\", \"MAXLOC\");\n \t}\n     }\n "}, {"sha": "bae17fe5f36bfe527cf96cb6f07efba495f94807", "filename": "libgfortran/generated/maxloc1_4_r10.c", "status": "modified", "additions": 6, "deletions": 36, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/16bff92192676901670042cdce3fbd5f9c928fc8/libgfortran%2Fgenerated%2Fmaxloc1_4_r10.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/16bff92192676901670042cdce3fbd5f9c928fc8/libgfortran%2Fgenerated%2Fmaxloc1_4_r10.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxloc1_4_r10.c?ref=16bff92192676901670042cdce3fbd5f9c928fc8", "patch": "@@ -120,19 +120,8 @@ maxloc1_4_r10 (gfc_array_i4 * const restrict retarray,\n \t\t       (long int) rank);\n \n       if (unlikely (compile_options.bounds_check))\n-\t{\n-\t  for (n=0; n < rank; n++)\n-\t    {\n-\t      index_type ret_extent;\n-\n-\t      ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,n);\n-\t      if (extent[n] != ret_extent)\n-\t\truntime_error (\"Incorrect extent in return value of\"\n-\t\t\t       \" MAXLOC intrinsic in dimension %ld:\"\n-\t\t\t       \" is %ld, should be %ld\", (long int) n + 1,\n-\t\t\t       (long int) ret_extent, (long int) extent[n]);\n-\t    }\n-\t}\n+\tbounds_ifunction_return ((array_t *) retarray, extent,\n+\t\t\t\t \"return value\", \"MAXLOC\");\n     }\n \n   for (n = 0; n < rank; n++)\n@@ -313,29 +302,10 @@ mmaxloc1_4_r10 (gfc_array_i4 * const restrict retarray,\n \n       if (unlikely (compile_options.bounds_check))\n \t{\n-\t  for (n=0; n < rank; n++)\n-\t    {\n-\t      index_type ret_extent;\n-\n-\t      ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,n);\n-\t      if (extent[n] != ret_extent)\n-\t\truntime_error (\"Incorrect extent in return value of\"\n-\t\t\t       \" MAXLOC intrinsic in dimension %ld:\"\n-\t\t\t       \" is %ld, should be %ld\", (long int) n + 1,\n-\t\t\t       (long int) ret_extent, (long int) extent[n]);\n-\t    }\n-          for (n=0; n<= rank; n++)\n-            {\n-              index_type mask_extent, array_extent;\n-\n-\t      array_extent = GFC_DESCRIPTOR_EXTENT(array,n);\n-\t      mask_extent = GFC_DESCRIPTOR_EXTENT(mask,n);\n-\t      if (array_extent != mask_extent)\n-\t\truntime_error (\"Incorrect extent in MASK argument of\"\n-\t\t\t       \" MAXLOC intrinsic in dimension %ld:\"\n-\t\t\t       \" is %ld, should be %ld\", (long int) n + 1,\n-\t\t\t       (long int) mask_extent, (long int) array_extent);\n-\t    }\n+\t  bounds_ifunction_return ((array_t *) retarray, extent,\n+\t\t\t\t   \"return value\", \"MAXLOC\");\n+\t  bounds_equal_extents ((array_t *) mask, (array_t *) array,\n+\t  \t\t\t\"MASK argument\", \"MAXLOC\");\n \t}\n     }\n "}, {"sha": "811f01c2176c904c15f6bfae730e0b93d248e60e", "filename": "libgfortran/generated/maxloc1_4_r16.c", "status": "modified", "additions": 6, "deletions": 36, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/16bff92192676901670042cdce3fbd5f9c928fc8/libgfortran%2Fgenerated%2Fmaxloc1_4_r16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/16bff92192676901670042cdce3fbd5f9c928fc8/libgfortran%2Fgenerated%2Fmaxloc1_4_r16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxloc1_4_r16.c?ref=16bff92192676901670042cdce3fbd5f9c928fc8", "patch": "@@ -120,19 +120,8 @@ maxloc1_4_r16 (gfc_array_i4 * const restrict retarray,\n \t\t       (long int) rank);\n \n       if (unlikely (compile_options.bounds_check))\n-\t{\n-\t  for (n=0; n < rank; n++)\n-\t    {\n-\t      index_type ret_extent;\n-\n-\t      ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,n);\n-\t      if (extent[n] != ret_extent)\n-\t\truntime_error (\"Incorrect extent in return value of\"\n-\t\t\t       \" MAXLOC intrinsic in dimension %ld:\"\n-\t\t\t       \" is %ld, should be %ld\", (long int) n + 1,\n-\t\t\t       (long int) ret_extent, (long int) extent[n]);\n-\t    }\n-\t}\n+\tbounds_ifunction_return ((array_t *) retarray, extent,\n+\t\t\t\t \"return value\", \"MAXLOC\");\n     }\n \n   for (n = 0; n < rank; n++)\n@@ -313,29 +302,10 @@ mmaxloc1_4_r16 (gfc_array_i4 * const restrict retarray,\n \n       if (unlikely (compile_options.bounds_check))\n \t{\n-\t  for (n=0; n < rank; n++)\n-\t    {\n-\t      index_type ret_extent;\n-\n-\t      ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,n);\n-\t      if (extent[n] != ret_extent)\n-\t\truntime_error (\"Incorrect extent in return value of\"\n-\t\t\t       \" MAXLOC intrinsic in dimension %ld:\"\n-\t\t\t       \" is %ld, should be %ld\", (long int) n + 1,\n-\t\t\t       (long int) ret_extent, (long int) extent[n]);\n-\t    }\n-          for (n=0; n<= rank; n++)\n-            {\n-              index_type mask_extent, array_extent;\n-\n-\t      array_extent = GFC_DESCRIPTOR_EXTENT(array,n);\n-\t      mask_extent = GFC_DESCRIPTOR_EXTENT(mask,n);\n-\t      if (array_extent != mask_extent)\n-\t\truntime_error (\"Incorrect extent in MASK argument of\"\n-\t\t\t       \" MAXLOC intrinsic in dimension %ld:\"\n-\t\t\t       \" is %ld, should be %ld\", (long int) n + 1,\n-\t\t\t       (long int) mask_extent, (long int) array_extent);\n-\t    }\n+\t  bounds_ifunction_return ((array_t *) retarray, extent,\n+\t\t\t\t   \"return value\", \"MAXLOC\");\n+\t  bounds_equal_extents ((array_t *) mask, (array_t *) array,\n+\t  \t\t\t\"MASK argument\", \"MAXLOC\");\n \t}\n     }\n "}, {"sha": "065770f1a7a693e0b953575b8c78c45fc95dcae5", "filename": "libgfortran/generated/maxloc1_4_r4.c", "status": "modified", "additions": 6, "deletions": 36, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/16bff92192676901670042cdce3fbd5f9c928fc8/libgfortran%2Fgenerated%2Fmaxloc1_4_r4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/16bff92192676901670042cdce3fbd5f9c928fc8/libgfortran%2Fgenerated%2Fmaxloc1_4_r4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxloc1_4_r4.c?ref=16bff92192676901670042cdce3fbd5f9c928fc8", "patch": "@@ -120,19 +120,8 @@ maxloc1_4_r4 (gfc_array_i4 * const restrict retarray,\n \t\t       (long int) rank);\n \n       if (unlikely (compile_options.bounds_check))\n-\t{\n-\t  for (n=0; n < rank; n++)\n-\t    {\n-\t      index_type ret_extent;\n-\n-\t      ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,n);\n-\t      if (extent[n] != ret_extent)\n-\t\truntime_error (\"Incorrect extent in return value of\"\n-\t\t\t       \" MAXLOC intrinsic in dimension %ld:\"\n-\t\t\t       \" is %ld, should be %ld\", (long int) n + 1,\n-\t\t\t       (long int) ret_extent, (long int) extent[n]);\n-\t    }\n-\t}\n+\tbounds_ifunction_return ((array_t *) retarray, extent,\n+\t\t\t\t \"return value\", \"MAXLOC\");\n     }\n \n   for (n = 0; n < rank; n++)\n@@ -313,29 +302,10 @@ mmaxloc1_4_r4 (gfc_array_i4 * const restrict retarray,\n \n       if (unlikely (compile_options.bounds_check))\n \t{\n-\t  for (n=0; n < rank; n++)\n-\t    {\n-\t      index_type ret_extent;\n-\n-\t      ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,n);\n-\t      if (extent[n] != ret_extent)\n-\t\truntime_error (\"Incorrect extent in return value of\"\n-\t\t\t       \" MAXLOC intrinsic in dimension %ld:\"\n-\t\t\t       \" is %ld, should be %ld\", (long int) n + 1,\n-\t\t\t       (long int) ret_extent, (long int) extent[n]);\n-\t    }\n-          for (n=0; n<= rank; n++)\n-            {\n-              index_type mask_extent, array_extent;\n-\n-\t      array_extent = GFC_DESCRIPTOR_EXTENT(array,n);\n-\t      mask_extent = GFC_DESCRIPTOR_EXTENT(mask,n);\n-\t      if (array_extent != mask_extent)\n-\t\truntime_error (\"Incorrect extent in MASK argument of\"\n-\t\t\t       \" MAXLOC intrinsic in dimension %ld:\"\n-\t\t\t       \" is %ld, should be %ld\", (long int) n + 1,\n-\t\t\t       (long int) mask_extent, (long int) array_extent);\n-\t    }\n+\t  bounds_ifunction_return ((array_t *) retarray, extent,\n+\t\t\t\t   \"return value\", \"MAXLOC\");\n+\t  bounds_equal_extents ((array_t *) mask, (array_t *) array,\n+\t  \t\t\t\"MASK argument\", \"MAXLOC\");\n \t}\n     }\n "}, {"sha": "e083507934581e3707c1f67a019a770769d81003", "filename": "libgfortran/generated/maxloc1_4_r8.c", "status": "modified", "additions": 6, "deletions": 36, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/16bff92192676901670042cdce3fbd5f9c928fc8/libgfortran%2Fgenerated%2Fmaxloc1_4_r8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/16bff92192676901670042cdce3fbd5f9c928fc8/libgfortran%2Fgenerated%2Fmaxloc1_4_r8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxloc1_4_r8.c?ref=16bff92192676901670042cdce3fbd5f9c928fc8", "patch": "@@ -120,19 +120,8 @@ maxloc1_4_r8 (gfc_array_i4 * const restrict retarray,\n \t\t       (long int) rank);\n \n       if (unlikely (compile_options.bounds_check))\n-\t{\n-\t  for (n=0; n < rank; n++)\n-\t    {\n-\t      index_type ret_extent;\n-\n-\t      ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,n);\n-\t      if (extent[n] != ret_extent)\n-\t\truntime_error (\"Incorrect extent in return value of\"\n-\t\t\t       \" MAXLOC intrinsic in dimension %ld:\"\n-\t\t\t       \" is %ld, should be %ld\", (long int) n + 1,\n-\t\t\t       (long int) ret_extent, (long int) extent[n]);\n-\t    }\n-\t}\n+\tbounds_ifunction_return ((array_t *) retarray, extent,\n+\t\t\t\t \"return value\", \"MAXLOC\");\n     }\n \n   for (n = 0; n < rank; n++)\n@@ -313,29 +302,10 @@ mmaxloc1_4_r8 (gfc_array_i4 * const restrict retarray,\n \n       if (unlikely (compile_options.bounds_check))\n \t{\n-\t  for (n=0; n < rank; n++)\n-\t    {\n-\t      index_type ret_extent;\n-\n-\t      ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,n);\n-\t      if (extent[n] != ret_extent)\n-\t\truntime_error (\"Incorrect extent in return value of\"\n-\t\t\t       \" MAXLOC intrinsic in dimension %ld:\"\n-\t\t\t       \" is %ld, should be %ld\", (long int) n + 1,\n-\t\t\t       (long int) ret_extent, (long int) extent[n]);\n-\t    }\n-          for (n=0; n<= rank; n++)\n-            {\n-              index_type mask_extent, array_extent;\n-\n-\t      array_extent = GFC_DESCRIPTOR_EXTENT(array,n);\n-\t      mask_extent = GFC_DESCRIPTOR_EXTENT(mask,n);\n-\t      if (array_extent != mask_extent)\n-\t\truntime_error (\"Incorrect extent in MASK argument of\"\n-\t\t\t       \" MAXLOC intrinsic in dimension %ld:\"\n-\t\t\t       \" is %ld, should be %ld\", (long int) n + 1,\n-\t\t\t       (long int) mask_extent, (long int) array_extent);\n-\t    }\n+\t  bounds_ifunction_return ((array_t *) retarray, extent,\n+\t\t\t\t   \"return value\", \"MAXLOC\");\n+\t  bounds_equal_extents ((array_t *) mask, (array_t *) array,\n+\t  \t\t\t\"MASK argument\", \"MAXLOC\");\n \t}\n     }\n "}, {"sha": "b1d1f0e8dc8e7491851125ef91f5c2c46057b8fb", "filename": "libgfortran/generated/maxloc1_8_i1.c", "status": "modified", "additions": 6, "deletions": 36, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/16bff92192676901670042cdce3fbd5f9c928fc8/libgfortran%2Fgenerated%2Fmaxloc1_8_i1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/16bff92192676901670042cdce3fbd5f9c928fc8/libgfortran%2Fgenerated%2Fmaxloc1_8_i1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxloc1_8_i1.c?ref=16bff92192676901670042cdce3fbd5f9c928fc8", "patch": "@@ -120,19 +120,8 @@ maxloc1_8_i1 (gfc_array_i8 * const restrict retarray,\n \t\t       (long int) rank);\n \n       if (unlikely (compile_options.bounds_check))\n-\t{\n-\t  for (n=0; n < rank; n++)\n-\t    {\n-\t      index_type ret_extent;\n-\n-\t      ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,n);\n-\t      if (extent[n] != ret_extent)\n-\t\truntime_error (\"Incorrect extent in return value of\"\n-\t\t\t       \" MAXLOC intrinsic in dimension %ld:\"\n-\t\t\t       \" is %ld, should be %ld\", (long int) n + 1,\n-\t\t\t       (long int) ret_extent, (long int) extent[n]);\n-\t    }\n-\t}\n+\tbounds_ifunction_return ((array_t *) retarray, extent,\n+\t\t\t\t \"return value\", \"MAXLOC\");\n     }\n \n   for (n = 0; n < rank; n++)\n@@ -313,29 +302,10 @@ mmaxloc1_8_i1 (gfc_array_i8 * const restrict retarray,\n \n       if (unlikely (compile_options.bounds_check))\n \t{\n-\t  for (n=0; n < rank; n++)\n-\t    {\n-\t      index_type ret_extent;\n-\n-\t      ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,n);\n-\t      if (extent[n] != ret_extent)\n-\t\truntime_error (\"Incorrect extent in return value of\"\n-\t\t\t       \" MAXLOC intrinsic in dimension %ld:\"\n-\t\t\t       \" is %ld, should be %ld\", (long int) n + 1,\n-\t\t\t       (long int) ret_extent, (long int) extent[n]);\n-\t    }\n-          for (n=0; n<= rank; n++)\n-            {\n-              index_type mask_extent, array_extent;\n-\n-\t      array_extent = GFC_DESCRIPTOR_EXTENT(array,n);\n-\t      mask_extent = GFC_DESCRIPTOR_EXTENT(mask,n);\n-\t      if (array_extent != mask_extent)\n-\t\truntime_error (\"Incorrect extent in MASK argument of\"\n-\t\t\t       \" MAXLOC intrinsic in dimension %ld:\"\n-\t\t\t       \" is %ld, should be %ld\", (long int) n + 1,\n-\t\t\t       (long int) mask_extent, (long int) array_extent);\n-\t    }\n+\t  bounds_ifunction_return ((array_t *) retarray, extent,\n+\t\t\t\t   \"return value\", \"MAXLOC\");\n+\t  bounds_equal_extents ((array_t *) mask, (array_t *) array,\n+\t  \t\t\t\"MASK argument\", \"MAXLOC\");\n \t}\n     }\n "}, {"sha": "3028b2de6fb8b0a889dee712f0a5e1d079987cbf", "filename": "libgfortran/generated/maxloc1_8_i16.c", "status": "modified", "additions": 6, "deletions": 36, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/16bff92192676901670042cdce3fbd5f9c928fc8/libgfortran%2Fgenerated%2Fmaxloc1_8_i16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/16bff92192676901670042cdce3fbd5f9c928fc8/libgfortran%2Fgenerated%2Fmaxloc1_8_i16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxloc1_8_i16.c?ref=16bff92192676901670042cdce3fbd5f9c928fc8", "patch": "@@ -120,19 +120,8 @@ maxloc1_8_i16 (gfc_array_i8 * const restrict retarray,\n \t\t       (long int) rank);\n \n       if (unlikely (compile_options.bounds_check))\n-\t{\n-\t  for (n=0; n < rank; n++)\n-\t    {\n-\t      index_type ret_extent;\n-\n-\t      ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,n);\n-\t      if (extent[n] != ret_extent)\n-\t\truntime_error (\"Incorrect extent in return value of\"\n-\t\t\t       \" MAXLOC intrinsic in dimension %ld:\"\n-\t\t\t       \" is %ld, should be %ld\", (long int) n + 1,\n-\t\t\t       (long int) ret_extent, (long int) extent[n]);\n-\t    }\n-\t}\n+\tbounds_ifunction_return ((array_t *) retarray, extent,\n+\t\t\t\t \"return value\", \"MAXLOC\");\n     }\n \n   for (n = 0; n < rank; n++)\n@@ -313,29 +302,10 @@ mmaxloc1_8_i16 (gfc_array_i8 * const restrict retarray,\n \n       if (unlikely (compile_options.bounds_check))\n \t{\n-\t  for (n=0; n < rank; n++)\n-\t    {\n-\t      index_type ret_extent;\n-\n-\t      ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,n);\n-\t      if (extent[n] != ret_extent)\n-\t\truntime_error (\"Incorrect extent in return value of\"\n-\t\t\t       \" MAXLOC intrinsic in dimension %ld:\"\n-\t\t\t       \" is %ld, should be %ld\", (long int) n + 1,\n-\t\t\t       (long int) ret_extent, (long int) extent[n]);\n-\t    }\n-          for (n=0; n<= rank; n++)\n-            {\n-              index_type mask_extent, array_extent;\n-\n-\t      array_extent = GFC_DESCRIPTOR_EXTENT(array,n);\n-\t      mask_extent = GFC_DESCRIPTOR_EXTENT(mask,n);\n-\t      if (array_extent != mask_extent)\n-\t\truntime_error (\"Incorrect extent in MASK argument of\"\n-\t\t\t       \" MAXLOC intrinsic in dimension %ld:\"\n-\t\t\t       \" is %ld, should be %ld\", (long int) n + 1,\n-\t\t\t       (long int) mask_extent, (long int) array_extent);\n-\t    }\n+\t  bounds_ifunction_return ((array_t *) retarray, extent,\n+\t\t\t\t   \"return value\", \"MAXLOC\");\n+\t  bounds_equal_extents ((array_t *) mask, (array_t *) array,\n+\t  \t\t\t\"MASK argument\", \"MAXLOC\");\n \t}\n     }\n "}, {"sha": "74d7fb306b4e303d8c45241d1aff64bc4175154d", "filename": "libgfortran/generated/maxloc1_8_i2.c", "status": "modified", "additions": 6, "deletions": 36, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/16bff92192676901670042cdce3fbd5f9c928fc8/libgfortran%2Fgenerated%2Fmaxloc1_8_i2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/16bff92192676901670042cdce3fbd5f9c928fc8/libgfortran%2Fgenerated%2Fmaxloc1_8_i2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxloc1_8_i2.c?ref=16bff92192676901670042cdce3fbd5f9c928fc8", "patch": "@@ -120,19 +120,8 @@ maxloc1_8_i2 (gfc_array_i8 * const restrict retarray,\n \t\t       (long int) rank);\n \n       if (unlikely (compile_options.bounds_check))\n-\t{\n-\t  for (n=0; n < rank; n++)\n-\t    {\n-\t      index_type ret_extent;\n-\n-\t      ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,n);\n-\t      if (extent[n] != ret_extent)\n-\t\truntime_error (\"Incorrect extent in return value of\"\n-\t\t\t       \" MAXLOC intrinsic in dimension %ld:\"\n-\t\t\t       \" is %ld, should be %ld\", (long int) n + 1,\n-\t\t\t       (long int) ret_extent, (long int) extent[n]);\n-\t    }\n-\t}\n+\tbounds_ifunction_return ((array_t *) retarray, extent,\n+\t\t\t\t \"return value\", \"MAXLOC\");\n     }\n \n   for (n = 0; n < rank; n++)\n@@ -313,29 +302,10 @@ mmaxloc1_8_i2 (gfc_array_i8 * const restrict retarray,\n \n       if (unlikely (compile_options.bounds_check))\n \t{\n-\t  for (n=0; n < rank; n++)\n-\t    {\n-\t      index_type ret_extent;\n-\n-\t      ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,n);\n-\t      if (extent[n] != ret_extent)\n-\t\truntime_error (\"Incorrect extent in return value of\"\n-\t\t\t       \" MAXLOC intrinsic in dimension %ld:\"\n-\t\t\t       \" is %ld, should be %ld\", (long int) n + 1,\n-\t\t\t       (long int) ret_extent, (long int) extent[n]);\n-\t    }\n-          for (n=0; n<= rank; n++)\n-            {\n-              index_type mask_extent, array_extent;\n-\n-\t      array_extent = GFC_DESCRIPTOR_EXTENT(array,n);\n-\t      mask_extent = GFC_DESCRIPTOR_EXTENT(mask,n);\n-\t      if (array_extent != mask_extent)\n-\t\truntime_error (\"Incorrect extent in MASK argument of\"\n-\t\t\t       \" MAXLOC intrinsic in dimension %ld:\"\n-\t\t\t       \" is %ld, should be %ld\", (long int) n + 1,\n-\t\t\t       (long int) mask_extent, (long int) array_extent);\n-\t    }\n+\t  bounds_ifunction_return ((array_t *) retarray, extent,\n+\t\t\t\t   \"return value\", \"MAXLOC\");\n+\t  bounds_equal_extents ((array_t *) mask, (array_t *) array,\n+\t  \t\t\t\"MASK argument\", \"MAXLOC\");\n \t}\n     }\n "}, {"sha": "fcf11b8ffbf4c4b793094ee903c8d92f55f70754", "filename": "libgfortran/generated/maxloc1_8_i4.c", "status": "modified", "additions": 6, "deletions": 36, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/16bff92192676901670042cdce3fbd5f9c928fc8/libgfortran%2Fgenerated%2Fmaxloc1_8_i4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/16bff92192676901670042cdce3fbd5f9c928fc8/libgfortran%2Fgenerated%2Fmaxloc1_8_i4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxloc1_8_i4.c?ref=16bff92192676901670042cdce3fbd5f9c928fc8", "patch": "@@ -120,19 +120,8 @@ maxloc1_8_i4 (gfc_array_i8 * const restrict retarray,\n \t\t       (long int) rank);\n \n       if (unlikely (compile_options.bounds_check))\n-\t{\n-\t  for (n=0; n < rank; n++)\n-\t    {\n-\t      index_type ret_extent;\n-\n-\t      ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,n);\n-\t      if (extent[n] != ret_extent)\n-\t\truntime_error (\"Incorrect extent in return value of\"\n-\t\t\t       \" MAXLOC intrinsic in dimension %ld:\"\n-\t\t\t       \" is %ld, should be %ld\", (long int) n + 1,\n-\t\t\t       (long int) ret_extent, (long int) extent[n]);\n-\t    }\n-\t}\n+\tbounds_ifunction_return ((array_t *) retarray, extent,\n+\t\t\t\t \"return value\", \"MAXLOC\");\n     }\n \n   for (n = 0; n < rank; n++)\n@@ -313,29 +302,10 @@ mmaxloc1_8_i4 (gfc_array_i8 * const restrict retarray,\n \n       if (unlikely (compile_options.bounds_check))\n \t{\n-\t  for (n=0; n < rank; n++)\n-\t    {\n-\t      index_type ret_extent;\n-\n-\t      ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,n);\n-\t      if (extent[n] != ret_extent)\n-\t\truntime_error (\"Incorrect extent in return value of\"\n-\t\t\t       \" MAXLOC intrinsic in dimension %ld:\"\n-\t\t\t       \" is %ld, should be %ld\", (long int) n + 1,\n-\t\t\t       (long int) ret_extent, (long int) extent[n]);\n-\t    }\n-          for (n=0; n<= rank; n++)\n-            {\n-              index_type mask_extent, array_extent;\n-\n-\t      array_extent = GFC_DESCRIPTOR_EXTENT(array,n);\n-\t      mask_extent = GFC_DESCRIPTOR_EXTENT(mask,n);\n-\t      if (array_extent != mask_extent)\n-\t\truntime_error (\"Incorrect extent in MASK argument of\"\n-\t\t\t       \" MAXLOC intrinsic in dimension %ld:\"\n-\t\t\t       \" is %ld, should be %ld\", (long int) n + 1,\n-\t\t\t       (long int) mask_extent, (long int) array_extent);\n-\t    }\n+\t  bounds_ifunction_return ((array_t *) retarray, extent,\n+\t\t\t\t   \"return value\", \"MAXLOC\");\n+\t  bounds_equal_extents ((array_t *) mask, (array_t *) array,\n+\t  \t\t\t\"MASK argument\", \"MAXLOC\");\n \t}\n     }\n "}, {"sha": "1210fb12a823a1c7fe1cb1462c77ebe431a0328c", "filename": "libgfortran/generated/maxloc1_8_i8.c", "status": "modified", "additions": 6, "deletions": 36, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/16bff92192676901670042cdce3fbd5f9c928fc8/libgfortran%2Fgenerated%2Fmaxloc1_8_i8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/16bff92192676901670042cdce3fbd5f9c928fc8/libgfortran%2Fgenerated%2Fmaxloc1_8_i8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxloc1_8_i8.c?ref=16bff92192676901670042cdce3fbd5f9c928fc8", "patch": "@@ -120,19 +120,8 @@ maxloc1_8_i8 (gfc_array_i8 * const restrict retarray,\n \t\t       (long int) rank);\n \n       if (unlikely (compile_options.bounds_check))\n-\t{\n-\t  for (n=0; n < rank; n++)\n-\t    {\n-\t      index_type ret_extent;\n-\n-\t      ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,n);\n-\t      if (extent[n] != ret_extent)\n-\t\truntime_error (\"Incorrect extent in return value of\"\n-\t\t\t       \" MAXLOC intrinsic in dimension %ld:\"\n-\t\t\t       \" is %ld, should be %ld\", (long int) n + 1,\n-\t\t\t       (long int) ret_extent, (long int) extent[n]);\n-\t    }\n-\t}\n+\tbounds_ifunction_return ((array_t *) retarray, extent,\n+\t\t\t\t \"return value\", \"MAXLOC\");\n     }\n \n   for (n = 0; n < rank; n++)\n@@ -313,29 +302,10 @@ mmaxloc1_8_i8 (gfc_array_i8 * const restrict retarray,\n \n       if (unlikely (compile_options.bounds_check))\n \t{\n-\t  for (n=0; n < rank; n++)\n-\t    {\n-\t      index_type ret_extent;\n-\n-\t      ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,n);\n-\t      if (extent[n] != ret_extent)\n-\t\truntime_error (\"Incorrect extent in return value of\"\n-\t\t\t       \" MAXLOC intrinsic in dimension %ld:\"\n-\t\t\t       \" is %ld, should be %ld\", (long int) n + 1,\n-\t\t\t       (long int) ret_extent, (long int) extent[n]);\n-\t    }\n-          for (n=0; n<= rank; n++)\n-            {\n-              index_type mask_extent, array_extent;\n-\n-\t      array_extent = GFC_DESCRIPTOR_EXTENT(array,n);\n-\t      mask_extent = GFC_DESCRIPTOR_EXTENT(mask,n);\n-\t      if (array_extent != mask_extent)\n-\t\truntime_error (\"Incorrect extent in MASK argument of\"\n-\t\t\t       \" MAXLOC intrinsic in dimension %ld:\"\n-\t\t\t       \" is %ld, should be %ld\", (long int) n + 1,\n-\t\t\t       (long int) mask_extent, (long int) array_extent);\n-\t    }\n+\t  bounds_ifunction_return ((array_t *) retarray, extent,\n+\t\t\t\t   \"return value\", \"MAXLOC\");\n+\t  bounds_equal_extents ((array_t *) mask, (array_t *) array,\n+\t  \t\t\t\"MASK argument\", \"MAXLOC\");\n \t}\n     }\n "}, {"sha": "e0873d2590eb802f577dbf298b05855435838c9d", "filename": "libgfortran/generated/maxloc1_8_r10.c", "status": "modified", "additions": 6, "deletions": 36, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/16bff92192676901670042cdce3fbd5f9c928fc8/libgfortran%2Fgenerated%2Fmaxloc1_8_r10.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/16bff92192676901670042cdce3fbd5f9c928fc8/libgfortran%2Fgenerated%2Fmaxloc1_8_r10.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxloc1_8_r10.c?ref=16bff92192676901670042cdce3fbd5f9c928fc8", "patch": "@@ -120,19 +120,8 @@ maxloc1_8_r10 (gfc_array_i8 * const restrict retarray,\n \t\t       (long int) rank);\n \n       if (unlikely (compile_options.bounds_check))\n-\t{\n-\t  for (n=0; n < rank; n++)\n-\t    {\n-\t      index_type ret_extent;\n-\n-\t      ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,n);\n-\t      if (extent[n] != ret_extent)\n-\t\truntime_error (\"Incorrect extent in return value of\"\n-\t\t\t       \" MAXLOC intrinsic in dimension %ld:\"\n-\t\t\t       \" is %ld, should be %ld\", (long int) n + 1,\n-\t\t\t       (long int) ret_extent, (long int) extent[n]);\n-\t    }\n-\t}\n+\tbounds_ifunction_return ((array_t *) retarray, extent,\n+\t\t\t\t \"return value\", \"MAXLOC\");\n     }\n \n   for (n = 0; n < rank; n++)\n@@ -313,29 +302,10 @@ mmaxloc1_8_r10 (gfc_array_i8 * const restrict retarray,\n \n       if (unlikely (compile_options.bounds_check))\n \t{\n-\t  for (n=0; n < rank; n++)\n-\t    {\n-\t      index_type ret_extent;\n-\n-\t      ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,n);\n-\t      if (extent[n] != ret_extent)\n-\t\truntime_error (\"Incorrect extent in return value of\"\n-\t\t\t       \" MAXLOC intrinsic in dimension %ld:\"\n-\t\t\t       \" is %ld, should be %ld\", (long int) n + 1,\n-\t\t\t       (long int) ret_extent, (long int) extent[n]);\n-\t    }\n-          for (n=0; n<= rank; n++)\n-            {\n-              index_type mask_extent, array_extent;\n-\n-\t      array_extent = GFC_DESCRIPTOR_EXTENT(array,n);\n-\t      mask_extent = GFC_DESCRIPTOR_EXTENT(mask,n);\n-\t      if (array_extent != mask_extent)\n-\t\truntime_error (\"Incorrect extent in MASK argument of\"\n-\t\t\t       \" MAXLOC intrinsic in dimension %ld:\"\n-\t\t\t       \" is %ld, should be %ld\", (long int) n + 1,\n-\t\t\t       (long int) mask_extent, (long int) array_extent);\n-\t    }\n+\t  bounds_ifunction_return ((array_t *) retarray, extent,\n+\t\t\t\t   \"return value\", \"MAXLOC\");\n+\t  bounds_equal_extents ((array_t *) mask, (array_t *) array,\n+\t  \t\t\t\"MASK argument\", \"MAXLOC\");\n \t}\n     }\n "}, {"sha": "83d84c58ef1992e910c068d26a679c9276d833c0", "filename": "libgfortran/generated/maxloc1_8_r16.c", "status": "modified", "additions": 6, "deletions": 36, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/16bff92192676901670042cdce3fbd5f9c928fc8/libgfortran%2Fgenerated%2Fmaxloc1_8_r16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/16bff92192676901670042cdce3fbd5f9c928fc8/libgfortran%2Fgenerated%2Fmaxloc1_8_r16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxloc1_8_r16.c?ref=16bff92192676901670042cdce3fbd5f9c928fc8", "patch": "@@ -120,19 +120,8 @@ maxloc1_8_r16 (gfc_array_i8 * const restrict retarray,\n \t\t       (long int) rank);\n \n       if (unlikely (compile_options.bounds_check))\n-\t{\n-\t  for (n=0; n < rank; n++)\n-\t    {\n-\t      index_type ret_extent;\n-\n-\t      ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,n);\n-\t      if (extent[n] != ret_extent)\n-\t\truntime_error (\"Incorrect extent in return value of\"\n-\t\t\t       \" MAXLOC intrinsic in dimension %ld:\"\n-\t\t\t       \" is %ld, should be %ld\", (long int) n + 1,\n-\t\t\t       (long int) ret_extent, (long int) extent[n]);\n-\t    }\n-\t}\n+\tbounds_ifunction_return ((array_t *) retarray, extent,\n+\t\t\t\t \"return value\", \"MAXLOC\");\n     }\n \n   for (n = 0; n < rank; n++)\n@@ -313,29 +302,10 @@ mmaxloc1_8_r16 (gfc_array_i8 * const restrict retarray,\n \n       if (unlikely (compile_options.bounds_check))\n \t{\n-\t  for (n=0; n < rank; n++)\n-\t    {\n-\t      index_type ret_extent;\n-\n-\t      ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,n);\n-\t      if (extent[n] != ret_extent)\n-\t\truntime_error (\"Incorrect extent in return value of\"\n-\t\t\t       \" MAXLOC intrinsic in dimension %ld:\"\n-\t\t\t       \" is %ld, should be %ld\", (long int) n + 1,\n-\t\t\t       (long int) ret_extent, (long int) extent[n]);\n-\t    }\n-          for (n=0; n<= rank; n++)\n-            {\n-              index_type mask_extent, array_extent;\n-\n-\t      array_extent = GFC_DESCRIPTOR_EXTENT(array,n);\n-\t      mask_extent = GFC_DESCRIPTOR_EXTENT(mask,n);\n-\t      if (array_extent != mask_extent)\n-\t\truntime_error (\"Incorrect extent in MASK argument of\"\n-\t\t\t       \" MAXLOC intrinsic in dimension %ld:\"\n-\t\t\t       \" is %ld, should be %ld\", (long int) n + 1,\n-\t\t\t       (long int) mask_extent, (long int) array_extent);\n-\t    }\n+\t  bounds_ifunction_return ((array_t *) retarray, extent,\n+\t\t\t\t   \"return value\", \"MAXLOC\");\n+\t  bounds_equal_extents ((array_t *) mask, (array_t *) array,\n+\t  \t\t\t\"MASK argument\", \"MAXLOC\");\n \t}\n     }\n "}, {"sha": "94250d30a9dbc1b04a68111a60b4265789120cf5", "filename": "libgfortran/generated/maxloc1_8_r4.c", "status": "modified", "additions": 6, "deletions": 36, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/16bff92192676901670042cdce3fbd5f9c928fc8/libgfortran%2Fgenerated%2Fmaxloc1_8_r4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/16bff92192676901670042cdce3fbd5f9c928fc8/libgfortran%2Fgenerated%2Fmaxloc1_8_r4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxloc1_8_r4.c?ref=16bff92192676901670042cdce3fbd5f9c928fc8", "patch": "@@ -120,19 +120,8 @@ maxloc1_8_r4 (gfc_array_i8 * const restrict retarray,\n \t\t       (long int) rank);\n \n       if (unlikely (compile_options.bounds_check))\n-\t{\n-\t  for (n=0; n < rank; n++)\n-\t    {\n-\t      index_type ret_extent;\n-\n-\t      ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,n);\n-\t      if (extent[n] != ret_extent)\n-\t\truntime_error (\"Incorrect extent in return value of\"\n-\t\t\t       \" MAXLOC intrinsic in dimension %ld:\"\n-\t\t\t       \" is %ld, should be %ld\", (long int) n + 1,\n-\t\t\t       (long int) ret_extent, (long int) extent[n]);\n-\t    }\n-\t}\n+\tbounds_ifunction_return ((array_t *) retarray, extent,\n+\t\t\t\t \"return value\", \"MAXLOC\");\n     }\n \n   for (n = 0; n < rank; n++)\n@@ -313,29 +302,10 @@ mmaxloc1_8_r4 (gfc_array_i8 * const restrict retarray,\n \n       if (unlikely (compile_options.bounds_check))\n \t{\n-\t  for (n=0; n < rank; n++)\n-\t    {\n-\t      index_type ret_extent;\n-\n-\t      ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,n);\n-\t      if (extent[n] != ret_extent)\n-\t\truntime_error (\"Incorrect extent in return value of\"\n-\t\t\t       \" MAXLOC intrinsic in dimension %ld:\"\n-\t\t\t       \" is %ld, should be %ld\", (long int) n + 1,\n-\t\t\t       (long int) ret_extent, (long int) extent[n]);\n-\t    }\n-          for (n=0; n<= rank; n++)\n-            {\n-              index_type mask_extent, array_extent;\n-\n-\t      array_extent = GFC_DESCRIPTOR_EXTENT(array,n);\n-\t      mask_extent = GFC_DESCRIPTOR_EXTENT(mask,n);\n-\t      if (array_extent != mask_extent)\n-\t\truntime_error (\"Incorrect extent in MASK argument of\"\n-\t\t\t       \" MAXLOC intrinsic in dimension %ld:\"\n-\t\t\t       \" is %ld, should be %ld\", (long int) n + 1,\n-\t\t\t       (long int) mask_extent, (long int) array_extent);\n-\t    }\n+\t  bounds_ifunction_return ((array_t *) retarray, extent,\n+\t\t\t\t   \"return value\", \"MAXLOC\");\n+\t  bounds_equal_extents ((array_t *) mask, (array_t *) array,\n+\t  \t\t\t\"MASK argument\", \"MAXLOC\");\n \t}\n     }\n "}, {"sha": "4b759782227d97ff06789c136914443d0414ee65", "filename": "libgfortran/generated/maxloc1_8_r8.c", "status": "modified", "additions": 6, "deletions": 36, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/16bff92192676901670042cdce3fbd5f9c928fc8/libgfortran%2Fgenerated%2Fmaxloc1_8_r8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/16bff92192676901670042cdce3fbd5f9c928fc8/libgfortran%2Fgenerated%2Fmaxloc1_8_r8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxloc1_8_r8.c?ref=16bff92192676901670042cdce3fbd5f9c928fc8", "patch": "@@ -120,19 +120,8 @@ maxloc1_8_r8 (gfc_array_i8 * const restrict retarray,\n \t\t       (long int) rank);\n \n       if (unlikely (compile_options.bounds_check))\n-\t{\n-\t  for (n=0; n < rank; n++)\n-\t    {\n-\t      index_type ret_extent;\n-\n-\t      ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,n);\n-\t      if (extent[n] != ret_extent)\n-\t\truntime_error (\"Incorrect extent in return value of\"\n-\t\t\t       \" MAXLOC intrinsic in dimension %ld:\"\n-\t\t\t       \" is %ld, should be %ld\", (long int) n + 1,\n-\t\t\t       (long int) ret_extent, (long int) extent[n]);\n-\t    }\n-\t}\n+\tbounds_ifunction_return ((array_t *) retarray, extent,\n+\t\t\t\t \"return value\", \"MAXLOC\");\n     }\n \n   for (n = 0; n < rank; n++)\n@@ -313,29 +302,10 @@ mmaxloc1_8_r8 (gfc_array_i8 * const restrict retarray,\n \n       if (unlikely (compile_options.bounds_check))\n \t{\n-\t  for (n=0; n < rank; n++)\n-\t    {\n-\t      index_type ret_extent;\n-\n-\t      ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,n);\n-\t      if (extent[n] != ret_extent)\n-\t\truntime_error (\"Incorrect extent in return value of\"\n-\t\t\t       \" MAXLOC intrinsic in dimension %ld:\"\n-\t\t\t       \" is %ld, should be %ld\", (long int) n + 1,\n-\t\t\t       (long int) ret_extent, (long int) extent[n]);\n-\t    }\n-          for (n=0; n<= rank; n++)\n-            {\n-              index_type mask_extent, array_extent;\n-\n-\t      array_extent = GFC_DESCRIPTOR_EXTENT(array,n);\n-\t      mask_extent = GFC_DESCRIPTOR_EXTENT(mask,n);\n-\t      if (array_extent != mask_extent)\n-\t\truntime_error (\"Incorrect extent in MASK argument of\"\n-\t\t\t       \" MAXLOC intrinsic in dimension %ld:\"\n-\t\t\t       \" is %ld, should be %ld\", (long int) n + 1,\n-\t\t\t       (long int) mask_extent, (long int) array_extent);\n-\t    }\n+\t  bounds_ifunction_return ((array_t *) retarray, extent,\n+\t\t\t\t   \"return value\", \"MAXLOC\");\n+\t  bounds_equal_extents ((array_t *) mask, (array_t *) array,\n+\t  \t\t\t\"MASK argument\", \"MAXLOC\");\n \t}\n     }\n "}, {"sha": "cbffa3021aa75e3395ecb56a584b36632f61c1f5", "filename": "libgfortran/generated/maxval_i1.c", "status": "modified", "additions": 6, "deletions": 36, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/16bff92192676901670042cdce3fbd5f9c928fc8/libgfortran%2Fgenerated%2Fmaxval_i1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/16bff92192676901670042cdce3fbd5f9c928fc8/libgfortran%2Fgenerated%2Fmaxval_i1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxval_i1.c?ref=16bff92192676901670042cdce3fbd5f9c928fc8", "patch": "@@ -119,19 +119,8 @@ maxval_i1 (gfc_array_i1 * const restrict retarray,\n \t\t       (long int) rank);\n \n       if (unlikely (compile_options.bounds_check))\n-\t{\n-\t  for (n=0; n < rank; n++)\n-\t    {\n-\t      index_type ret_extent;\n-\n-\t      ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,n);\n-\t      if (extent[n] != ret_extent)\n-\t\truntime_error (\"Incorrect extent in return value of\"\n-\t\t\t       \" MAXVAL intrinsic in dimension %ld:\"\n-\t\t\t       \" is %ld, should be %ld\", (long int) n + 1,\n-\t\t\t       (long int) ret_extent, (long int) extent[n]);\n-\t    }\n-\t}\n+\tbounds_ifunction_return ((array_t *) retarray, extent,\n+\t\t\t\t \"return value\", \"MAXVAL\");\n     }\n \n   for (n = 0; n < rank; n++)\n@@ -307,29 +296,10 @@ mmaxval_i1 (gfc_array_i1 * const restrict retarray,\n \n       if (unlikely (compile_options.bounds_check))\n \t{\n-\t  for (n=0; n < rank; n++)\n-\t    {\n-\t      index_type ret_extent;\n-\n-\t      ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,n);\n-\t      if (extent[n] != ret_extent)\n-\t\truntime_error (\"Incorrect extent in return value of\"\n-\t\t\t       \" MAXVAL intrinsic in dimension %ld:\"\n-\t\t\t       \" is %ld, should be %ld\", (long int) n + 1,\n-\t\t\t       (long int) ret_extent, (long int) extent[n]);\n-\t    }\n-          for (n=0; n<= rank; n++)\n-            {\n-              index_type mask_extent, array_extent;\n-\n-\t      array_extent = GFC_DESCRIPTOR_EXTENT(array,n);\n-\t      mask_extent = GFC_DESCRIPTOR_EXTENT(mask,n);\n-\t      if (array_extent != mask_extent)\n-\t\truntime_error (\"Incorrect extent in MASK argument of\"\n-\t\t\t       \" MAXVAL intrinsic in dimension %ld:\"\n-\t\t\t       \" is %ld, should be %ld\", (long int) n + 1,\n-\t\t\t       (long int) mask_extent, (long int) array_extent);\n-\t    }\n+\t  bounds_ifunction_return ((array_t *) retarray, extent,\n+\t\t\t\t   \"return value\", \"MAXVAL\");\n+\t  bounds_equal_extents ((array_t *) mask, (array_t *) array,\n+\t  \t\t\t\"MASK argument\", \"MAXVAL\");\n \t}\n     }\n "}, {"sha": "e0e53411e36ae7ec98ee46e9d05a79dc6adbff3d", "filename": "libgfortran/generated/maxval_i16.c", "status": "modified", "additions": 6, "deletions": 36, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/16bff92192676901670042cdce3fbd5f9c928fc8/libgfortran%2Fgenerated%2Fmaxval_i16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/16bff92192676901670042cdce3fbd5f9c928fc8/libgfortran%2Fgenerated%2Fmaxval_i16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxval_i16.c?ref=16bff92192676901670042cdce3fbd5f9c928fc8", "patch": "@@ -119,19 +119,8 @@ maxval_i16 (gfc_array_i16 * const restrict retarray,\n \t\t       (long int) rank);\n \n       if (unlikely (compile_options.bounds_check))\n-\t{\n-\t  for (n=0; n < rank; n++)\n-\t    {\n-\t      index_type ret_extent;\n-\n-\t      ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,n);\n-\t      if (extent[n] != ret_extent)\n-\t\truntime_error (\"Incorrect extent in return value of\"\n-\t\t\t       \" MAXVAL intrinsic in dimension %ld:\"\n-\t\t\t       \" is %ld, should be %ld\", (long int) n + 1,\n-\t\t\t       (long int) ret_extent, (long int) extent[n]);\n-\t    }\n-\t}\n+\tbounds_ifunction_return ((array_t *) retarray, extent,\n+\t\t\t\t \"return value\", \"MAXVAL\");\n     }\n \n   for (n = 0; n < rank; n++)\n@@ -307,29 +296,10 @@ mmaxval_i16 (gfc_array_i16 * const restrict retarray,\n \n       if (unlikely (compile_options.bounds_check))\n \t{\n-\t  for (n=0; n < rank; n++)\n-\t    {\n-\t      index_type ret_extent;\n-\n-\t      ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,n);\n-\t      if (extent[n] != ret_extent)\n-\t\truntime_error (\"Incorrect extent in return value of\"\n-\t\t\t       \" MAXVAL intrinsic in dimension %ld:\"\n-\t\t\t       \" is %ld, should be %ld\", (long int) n + 1,\n-\t\t\t       (long int) ret_extent, (long int) extent[n]);\n-\t    }\n-          for (n=0; n<= rank; n++)\n-            {\n-              index_type mask_extent, array_extent;\n-\n-\t      array_extent = GFC_DESCRIPTOR_EXTENT(array,n);\n-\t      mask_extent = GFC_DESCRIPTOR_EXTENT(mask,n);\n-\t      if (array_extent != mask_extent)\n-\t\truntime_error (\"Incorrect extent in MASK argument of\"\n-\t\t\t       \" MAXVAL intrinsic in dimension %ld:\"\n-\t\t\t       \" is %ld, should be %ld\", (long int) n + 1,\n-\t\t\t       (long int) mask_extent, (long int) array_extent);\n-\t    }\n+\t  bounds_ifunction_return ((array_t *) retarray, extent,\n+\t\t\t\t   \"return value\", \"MAXVAL\");\n+\t  bounds_equal_extents ((array_t *) mask, (array_t *) array,\n+\t  \t\t\t\"MASK argument\", \"MAXVAL\");\n \t}\n     }\n "}, {"sha": "293a75f57cf41c27b6b4e53c6a52c7149d0514dd", "filename": "libgfortran/generated/maxval_i2.c", "status": "modified", "additions": 6, "deletions": 36, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/16bff92192676901670042cdce3fbd5f9c928fc8/libgfortran%2Fgenerated%2Fmaxval_i2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/16bff92192676901670042cdce3fbd5f9c928fc8/libgfortran%2Fgenerated%2Fmaxval_i2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxval_i2.c?ref=16bff92192676901670042cdce3fbd5f9c928fc8", "patch": "@@ -119,19 +119,8 @@ maxval_i2 (gfc_array_i2 * const restrict retarray,\n \t\t       (long int) rank);\n \n       if (unlikely (compile_options.bounds_check))\n-\t{\n-\t  for (n=0; n < rank; n++)\n-\t    {\n-\t      index_type ret_extent;\n-\n-\t      ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,n);\n-\t      if (extent[n] != ret_extent)\n-\t\truntime_error (\"Incorrect extent in return value of\"\n-\t\t\t       \" MAXVAL intrinsic in dimension %ld:\"\n-\t\t\t       \" is %ld, should be %ld\", (long int) n + 1,\n-\t\t\t       (long int) ret_extent, (long int) extent[n]);\n-\t    }\n-\t}\n+\tbounds_ifunction_return ((array_t *) retarray, extent,\n+\t\t\t\t \"return value\", \"MAXVAL\");\n     }\n \n   for (n = 0; n < rank; n++)\n@@ -307,29 +296,10 @@ mmaxval_i2 (gfc_array_i2 * const restrict retarray,\n \n       if (unlikely (compile_options.bounds_check))\n \t{\n-\t  for (n=0; n < rank; n++)\n-\t    {\n-\t      index_type ret_extent;\n-\n-\t      ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,n);\n-\t      if (extent[n] != ret_extent)\n-\t\truntime_error (\"Incorrect extent in return value of\"\n-\t\t\t       \" MAXVAL intrinsic in dimension %ld:\"\n-\t\t\t       \" is %ld, should be %ld\", (long int) n + 1,\n-\t\t\t       (long int) ret_extent, (long int) extent[n]);\n-\t    }\n-          for (n=0; n<= rank; n++)\n-            {\n-              index_type mask_extent, array_extent;\n-\n-\t      array_extent = GFC_DESCRIPTOR_EXTENT(array,n);\n-\t      mask_extent = GFC_DESCRIPTOR_EXTENT(mask,n);\n-\t      if (array_extent != mask_extent)\n-\t\truntime_error (\"Incorrect extent in MASK argument of\"\n-\t\t\t       \" MAXVAL intrinsic in dimension %ld:\"\n-\t\t\t       \" is %ld, should be %ld\", (long int) n + 1,\n-\t\t\t       (long int) mask_extent, (long int) array_extent);\n-\t    }\n+\t  bounds_ifunction_return ((array_t *) retarray, extent,\n+\t\t\t\t   \"return value\", \"MAXVAL\");\n+\t  bounds_equal_extents ((array_t *) mask, (array_t *) array,\n+\t  \t\t\t\"MASK argument\", \"MAXVAL\");\n \t}\n     }\n "}, {"sha": "4d105a0d57fc5e5a7221026e458ac43e7bd02187", "filename": "libgfortran/generated/maxval_i4.c", "status": "modified", "additions": 6, "deletions": 36, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/16bff92192676901670042cdce3fbd5f9c928fc8/libgfortran%2Fgenerated%2Fmaxval_i4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/16bff92192676901670042cdce3fbd5f9c928fc8/libgfortran%2Fgenerated%2Fmaxval_i4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxval_i4.c?ref=16bff92192676901670042cdce3fbd5f9c928fc8", "patch": "@@ -119,19 +119,8 @@ maxval_i4 (gfc_array_i4 * const restrict retarray,\n \t\t       (long int) rank);\n \n       if (unlikely (compile_options.bounds_check))\n-\t{\n-\t  for (n=0; n < rank; n++)\n-\t    {\n-\t      index_type ret_extent;\n-\n-\t      ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,n);\n-\t      if (extent[n] != ret_extent)\n-\t\truntime_error (\"Incorrect extent in return value of\"\n-\t\t\t       \" MAXVAL intrinsic in dimension %ld:\"\n-\t\t\t       \" is %ld, should be %ld\", (long int) n + 1,\n-\t\t\t       (long int) ret_extent, (long int) extent[n]);\n-\t    }\n-\t}\n+\tbounds_ifunction_return ((array_t *) retarray, extent,\n+\t\t\t\t \"return value\", \"MAXVAL\");\n     }\n \n   for (n = 0; n < rank; n++)\n@@ -307,29 +296,10 @@ mmaxval_i4 (gfc_array_i4 * const restrict retarray,\n \n       if (unlikely (compile_options.bounds_check))\n \t{\n-\t  for (n=0; n < rank; n++)\n-\t    {\n-\t      index_type ret_extent;\n-\n-\t      ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,n);\n-\t      if (extent[n] != ret_extent)\n-\t\truntime_error (\"Incorrect extent in return value of\"\n-\t\t\t       \" MAXVAL intrinsic in dimension %ld:\"\n-\t\t\t       \" is %ld, should be %ld\", (long int) n + 1,\n-\t\t\t       (long int) ret_extent, (long int) extent[n]);\n-\t    }\n-          for (n=0; n<= rank; n++)\n-            {\n-              index_type mask_extent, array_extent;\n-\n-\t      array_extent = GFC_DESCRIPTOR_EXTENT(array,n);\n-\t      mask_extent = GFC_DESCRIPTOR_EXTENT(mask,n);\n-\t      if (array_extent != mask_extent)\n-\t\truntime_error (\"Incorrect extent in MASK argument of\"\n-\t\t\t       \" MAXVAL intrinsic in dimension %ld:\"\n-\t\t\t       \" is %ld, should be %ld\", (long int) n + 1,\n-\t\t\t       (long int) mask_extent, (long int) array_extent);\n-\t    }\n+\t  bounds_ifunction_return ((array_t *) retarray, extent,\n+\t\t\t\t   \"return value\", \"MAXVAL\");\n+\t  bounds_equal_extents ((array_t *) mask, (array_t *) array,\n+\t  \t\t\t\"MASK argument\", \"MAXVAL\");\n \t}\n     }\n "}, {"sha": "2ff17283e7950aca524affbe5b3c8bdfca6fa903", "filename": "libgfortran/generated/maxval_i8.c", "status": "modified", "additions": 6, "deletions": 36, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/16bff92192676901670042cdce3fbd5f9c928fc8/libgfortran%2Fgenerated%2Fmaxval_i8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/16bff92192676901670042cdce3fbd5f9c928fc8/libgfortran%2Fgenerated%2Fmaxval_i8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxval_i8.c?ref=16bff92192676901670042cdce3fbd5f9c928fc8", "patch": "@@ -119,19 +119,8 @@ maxval_i8 (gfc_array_i8 * const restrict retarray,\n \t\t       (long int) rank);\n \n       if (unlikely (compile_options.bounds_check))\n-\t{\n-\t  for (n=0; n < rank; n++)\n-\t    {\n-\t      index_type ret_extent;\n-\n-\t      ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,n);\n-\t      if (extent[n] != ret_extent)\n-\t\truntime_error (\"Incorrect extent in return value of\"\n-\t\t\t       \" MAXVAL intrinsic in dimension %ld:\"\n-\t\t\t       \" is %ld, should be %ld\", (long int) n + 1,\n-\t\t\t       (long int) ret_extent, (long int) extent[n]);\n-\t    }\n-\t}\n+\tbounds_ifunction_return ((array_t *) retarray, extent,\n+\t\t\t\t \"return value\", \"MAXVAL\");\n     }\n \n   for (n = 0; n < rank; n++)\n@@ -307,29 +296,10 @@ mmaxval_i8 (gfc_array_i8 * const restrict retarray,\n \n       if (unlikely (compile_options.bounds_check))\n \t{\n-\t  for (n=0; n < rank; n++)\n-\t    {\n-\t      index_type ret_extent;\n-\n-\t      ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,n);\n-\t      if (extent[n] != ret_extent)\n-\t\truntime_error (\"Incorrect extent in return value of\"\n-\t\t\t       \" MAXVAL intrinsic in dimension %ld:\"\n-\t\t\t       \" is %ld, should be %ld\", (long int) n + 1,\n-\t\t\t       (long int) ret_extent, (long int) extent[n]);\n-\t    }\n-          for (n=0; n<= rank; n++)\n-            {\n-              index_type mask_extent, array_extent;\n-\n-\t      array_extent = GFC_DESCRIPTOR_EXTENT(array,n);\n-\t      mask_extent = GFC_DESCRIPTOR_EXTENT(mask,n);\n-\t      if (array_extent != mask_extent)\n-\t\truntime_error (\"Incorrect extent in MASK argument of\"\n-\t\t\t       \" MAXVAL intrinsic in dimension %ld:\"\n-\t\t\t       \" is %ld, should be %ld\", (long int) n + 1,\n-\t\t\t       (long int) mask_extent, (long int) array_extent);\n-\t    }\n+\t  bounds_ifunction_return ((array_t *) retarray, extent,\n+\t\t\t\t   \"return value\", \"MAXVAL\");\n+\t  bounds_equal_extents ((array_t *) mask, (array_t *) array,\n+\t  \t\t\t\"MASK argument\", \"MAXVAL\");\n \t}\n     }\n "}, {"sha": "356998b3027f6cd9001a26bce3be880481944f06", "filename": "libgfortran/generated/maxval_r10.c", "status": "modified", "additions": 6, "deletions": 36, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/16bff92192676901670042cdce3fbd5f9c928fc8/libgfortran%2Fgenerated%2Fmaxval_r10.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/16bff92192676901670042cdce3fbd5f9c928fc8/libgfortran%2Fgenerated%2Fmaxval_r10.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxval_r10.c?ref=16bff92192676901670042cdce3fbd5f9c928fc8", "patch": "@@ -119,19 +119,8 @@ maxval_r10 (gfc_array_r10 * const restrict retarray,\n \t\t       (long int) rank);\n \n       if (unlikely (compile_options.bounds_check))\n-\t{\n-\t  for (n=0; n < rank; n++)\n-\t    {\n-\t      index_type ret_extent;\n-\n-\t      ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,n);\n-\t      if (extent[n] != ret_extent)\n-\t\truntime_error (\"Incorrect extent in return value of\"\n-\t\t\t       \" MAXVAL intrinsic in dimension %ld:\"\n-\t\t\t       \" is %ld, should be %ld\", (long int) n + 1,\n-\t\t\t       (long int) ret_extent, (long int) extent[n]);\n-\t    }\n-\t}\n+\tbounds_ifunction_return ((array_t *) retarray, extent,\n+\t\t\t\t \"return value\", \"MAXVAL\");\n     }\n \n   for (n = 0; n < rank; n++)\n@@ -307,29 +296,10 @@ mmaxval_r10 (gfc_array_r10 * const restrict retarray,\n \n       if (unlikely (compile_options.bounds_check))\n \t{\n-\t  for (n=0; n < rank; n++)\n-\t    {\n-\t      index_type ret_extent;\n-\n-\t      ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,n);\n-\t      if (extent[n] != ret_extent)\n-\t\truntime_error (\"Incorrect extent in return value of\"\n-\t\t\t       \" MAXVAL intrinsic in dimension %ld:\"\n-\t\t\t       \" is %ld, should be %ld\", (long int) n + 1,\n-\t\t\t       (long int) ret_extent, (long int) extent[n]);\n-\t    }\n-          for (n=0; n<= rank; n++)\n-            {\n-              index_type mask_extent, array_extent;\n-\n-\t      array_extent = GFC_DESCRIPTOR_EXTENT(array,n);\n-\t      mask_extent = GFC_DESCRIPTOR_EXTENT(mask,n);\n-\t      if (array_extent != mask_extent)\n-\t\truntime_error (\"Incorrect extent in MASK argument of\"\n-\t\t\t       \" MAXVAL intrinsic in dimension %ld:\"\n-\t\t\t       \" is %ld, should be %ld\", (long int) n + 1,\n-\t\t\t       (long int) mask_extent, (long int) array_extent);\n-\t    }\n+\t  bounds_ifunction_return ((array_t *) retarray, extent,\n+\t\t\t\t   \"return value\", \"MAXVAL\");\n+\t  bounds_equal_extents ((array_t *) mask, (array_t *) array,\n+\t  \t\t\t\"MASK argument\", \"MAXVAL\");\n \t}\n     }\n "}, {"sha": "cf281085a16b92439b7cd5aa3f48fa888ee79b91", "filename": "libgfortran/generated/maxval_r16.c", "status": "modified", "additions": 6, "deletions": 36, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/16bff92192676901670042cdce3fbd5f9c928fc8/libgfortran%2Fgenerated%2Fmaxval_r16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/16bff92192676901670042cdce3fbd5f9c928fc8/libgfortran%2Fgenerated%2Fmaxval_r16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxval_r16.c?ref=16bff92192676901670042cdce3fbd5f9c928fc8", "patch": "@@ -119,19 +119,8 @@ maxval_r16 (gfc_array_r16 * const restrict retarray,\n \t\t       (long int) rank);\n \n       if (unlikely (compile_options.bounds_check))\n-\t{\n-\t  for (n=0; n < rank; n++)\n-\t    {\n-\t      index_type ret_extent;\n-\n-\t      ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,n);\n-\t      if (extent[n] != ret_extent)\n-\t\truntime_error (\"Incorrect extent in return value of\"\n-\t\t\t       \" MAXVAL intrinsic in dimension %ld:\"\n-\t\t\t       \" is %ld, should be %ld\", (long int) n + 1,\n-\t\t\t       (long int) ret_extent, (long int) extent[n]);\n-\t    }\n-\t}\n+\tbounds_ifunction_return ((array_t *) retarray, extent,\n+\t\t\t\t \"return value\", \"MAXVAL\");\n     }\n \n   for (n = 0; n < rank; n++)\n@@ -307,29 +296,10 @@ mmaxval_r16 (gfc_array_r16 * const restrict retarray,\n \n       if (unlikely (compile_options.bounds_check))\n \t{\n-\t  for (n=0; n < rank; n++)\n-\t    {\n-\t      index_type ret_extent;\n-\n-\t      ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,n);\n-\t      if (extent[n] != ret_extent)\n-\t\truntime_error (\"Incorrect extent in return value of\"\n-\t\t\t       \" MAXVAL intrinsic in dimension %ld:\"\n-\t\t\t       \" is %ld, should be %ld\", (long int) n + 1,\n-\t\t\t       (long int) ret_extent, (long int) extent[n]);\n-\t    }\n-          for (n=0; n<= rank; n++)\n-            {\n-              index_type mask_extent, array_extent;\n-\n-\t      array_extent = GFC_DESCRIPTOR_EXTENT(array,n);\n-\t      mask_extent = GFC_DESCRIPTOR_EXTENT(mask,n);\n-\t      if (array_extent != mask_extent)\n-\t\truntime_error (\"Incorrect extent in MASK argument of\"\n-\t\t\t       \" MAXVAL intrinsic in dimension %ld:\"\n-\t\t\t       \" is %ld, should be %ld\", (long int) n + 1,\n-\t\t\t       (long int) mask_extent, (long int) array_extent);\n-\t    }\n+\t  bounds_ifunction_return ((array_t *) retarray, extent,\n+\t\t\t\t   \"return value\", \"MAXVAL\");\n+\t  bounds_equal_extents ((array_t *) mask, (array_t *) array,\n+\t  \t\t\t\"MASK argument\", \"MAXVAL\");\n \t}\n     }\n "}, {"sha": "b2541a2dc1b42e262e39855e52ef7b232e9c7d45", "filename": "libgfortran/generated/maxval_r4.c", "status": "modified", "additions": 6, "deletions": 36, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/16bff92192676901670042cdce3fbd5f9c928fc8/libgfortran%2Fgenerated%2Fmaxval_r4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/16bff92192676901670042cdce3fbd5f9c928fc8/libgfortran%2Fgenerated%2Fmaxval_r4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxval_r4.c?ref=16bff92192676901670042cdce3fbd5f9c928fc8", "patch": "@@ -119,19 +119,8 @@ maxval_r4 (gfc_array_r4 * const restrict retarray,\n \t\t       (long int) rank);\n \n       if (unlikely (compile_options.bounds_check))\n-\t{\n-\t  for (n=0; n < rank; n++)\n-\t    {\n-\t      index_type ret_extent;\n-\n-\t      ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,n);\n-\t      if (extent[n] != ret_extent)\n-\t\truntime_error (\"Incorrect extent in return value of\"\n-\t\t\t       \" MAXVAL intrinsic in dimension %ld:\"\n-\t\t\t       \" is %ld, should be %ld\", (long int) n + 1,\n-\t\t\t       (long int) ret_extent, (long int) extent[n]);\n-\t    }\n-\t}\n+\tbounds_ifunction_return ((array_t *) retarray, extent,\n+\t\t\t\t \"return value\", \"MAXVAL\");\n     }\n \n   for (n = 0; n < rank; n++)\n@@ -307,29 +296,10 @@ mmaxval_r4 (gfc_array_r4 * const restrict retarray,\n \n       if (unlikely (compile_options.bounds_check))\n \t{\n-\t  for (n=0; n < rank; n++)\n-\t    {\n-\t      index_type ret_extent;\n-\n-\t      ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,n);\n-\t      if (extent[n] != ret_extent)\n-\t\truntime_error (\"Incorrect extent in return value of\"\n-\t\t\t       \" MAXVAL intrinsic in dimension %ld:\"\n-\t\t\t       \" is %ld, should be %ld\", (long int) n + 1,\n-\t\t\t       (long int) ret_extent, (long int) extent[n]);\n-\t    }\n-          for (n=0; n<= rank; n++)\n-            {\n-              index_type mask_extent, array_extent;\n-\n-\t      array_extent = GFC_DESCRIPTOR_EXTENT(array,n);\n-\t      mask_extent = GFC_DESCRIPTOR_EXTENT(mask,n);\n-\t      if (array_extent != mask_extent)\n-\t\truntime_error (\"Incorrect extent in MASK argument of\"\n-\t\t\t       \" MAXVAL intrinsic in dimension %ld:\"\n-\t\t\t       \" is %ld, should be %ld\", (long int) n + 1,\n-\t\t\t       (long int) mask_extent, (long int) array_extent);\n-\t    }\n+\t  bounds_ifunction_return ((array_t *) retarray, extent,\n+\t\t\t\t   \"return value\", \"MAXVAL\");\n+\t  bounds_equal_extents ((array_t *) mask, (array_t *) array,\n+\t  \t\t\t\"MASK argument\", \"MAXVAL\");\n \t}\n     }\n "}, {"sha": "8eb0b8684fbdfc3c01807d6780cfc7f1d7fbaf87", "filename": "libgfortran/generated/maxval_r8.c", "status": "modified", "additions": 6, "deletions": 36, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/16bff92192676901670042cdce3fbd5f9c928fc8/libgfortran%2Fgenerated%2Fmaxval_r8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/16bff92192676901670042cdce3fbd5f9c928fc8/libgfortran%2Fgenerated%2Fmaxval_r8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxval_r8.c?ref=16bff92192676901670042cdce3fbd5f9c928fc8", "patch": "@@ -119,19 +119,8 @@ maxval_r8 (gfc_array_r8 * const restrict retarray,\n \t\t       (long int) rank);\n \n       if (unlikely (compile_options.bounds_check))\n-\t{\n-\t  for (n=0; n < rank; n++)\n-\t    {\n-\t      index_type ret_extent;\n-\n-\t      ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,n);\n-\t      if (extent[n] != ret_extent)\n-\t\truntime_error (\"Incorrect extent in return value of\"\n-\t\t\t       \" MAXVAL intrinsic in dimension %ld:\"\n-\t\t\t       \" is %ld, should be %ld\", (long int) n + 1,\n-\t\t\t       (long int) ret_extent, (long int) extent[n]);\n-\t    }\n-\t}\n+\tbounds_ifunction_return ((array_t *) retarray, extent,\n+\t\t\t\t \"return value\", \"MAXVAL\");\n     }\n \n   for (n = 0; n < rank; n++)\n@@ -307,29 +296,10 @@ mmaxval_r8 (gfc_array_r8 * const restrict retarray,\n \n       if (unlikely (compile_options.bounds_check))\n \t{\n-\t  for (n=0; n < rank; n++)\n-\t    {\n-\t      index_type ret_extent;\n-\n-\t      ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,n);\n-\t      if (extent[n] != ret_extent)\n-\t\truntime_error (\"Incorrect extent in return value of\"\n-\t\t\t       \" MAXVAL intrinsic in dimension %ld:\"\n-\t\t\t       \" is %ld, should be %ld\", (long int) n + 1,\n-\t\t\t       (long int) ret_extent, (long int) extent[n]);\n-\t    }\n-          for (n=0; n<= rank; n++)\n-            {\n-              index_type mask_extent, array_extent;\n-\n-\t      array_extent = GFC_DESCRIPTOR_EXTENT(array,n);\n-\t      mask_extent = GFC_DESCRIPTOR_EXTENT(mask,n);\n-\t      if (array_extent != mask_extent)\n-\t\truntime_error (\"Incorrect extent in MASK argument of\"\n-\t\t\t       \" MAXVAL intrinsic in dimension %ld:\"\n-\t\t\t       \" is %ld, should be %ld\", (long int) n + 1,\n-\t\t\t       (long int) mask_extent, (long int) array_extent);\n-\t    }\n+\t  bounds_ifunction_return ((array_t *) retarray, extent,\n+\t\t\t\t   \"return value\", \"MAXVAL\");\n+\t  bounds_equal_extents ((array_t *) mask, (array_t *) array,\n+\t  \t\t\t\"MASK argument\", \"MAXVAL\");\n \t}\n     }\n "}, {"sha": "7a505126bcd53e3d6bc8e0d35401a83a2ce5fd95", "filename": "libgfortran/generated/minloc0_16_i1.c", "status": "modified", "additions": 10, "deletions": 62, "changes": 72, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/16bff92192676901670042cdce3fbd5f9c928fc8/libgfortran%2Fgenerated%2Fminloc0_16_i1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/16bff92192676901670042cdce3fbd5f9c928fc8/libgfortran%2Fgenerated%2Fminloc0_16_i1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminloc0_16_i1.c?ref=16bff92192676901670042cdce3fbd5f9c928fc8", "patch": "@@ -63,21 +63,8 @@ minloc0_16_i1 (gfc_array_i16 * const restrict retarray,\n   else\n     {\n       if (unlikely (compile_options.bounds_check))\n-\t{\n-\t  int ret_rank;\n-\t  index_type ret_extent;\n-\n-\t  ret_rank = GFC_DESCRIPTOR_RANK (retarray);\n-\t  if (ret_rank != 1)\n-\t    runtime_error (\"rank of return array in MINLOC intrinsic\"\n-\t\t\t   \" should be 1, is %ld\", (long int) ret_rank);\n-\n-\t  ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,0);\n-\t  if (ret_extent != rank)\n-\t    runtime_error (\"Incorrect extent in return value of\"\n-\t\t\t   \" MINLOC intrnisic: is %ld, should be %ld\",\n-\t\t\t   (long int) ret_extent, (long int) rank);\n-\t}\n+        bounds_iforeach_return ((array_t *) retarray, (array_t *) array,\n+\t                        \"MINLOC\");\n     }\n \n   dstride = GFC_DESCRIPTOR_STRIDE(retarray,0);\n@@ -186,38 +173,11 @@ mminloc0_16_i1 (gfc_array_i16 * const restrict retarray,\n     {\n       if (unlikely (compile_options.bounds_check))\n \t{\n-\t  int ret_rank, mask_rank;\n-\t  index_type ret_extent;\n-\t  int n;\n-\t  index_type array_extent, mask_extent;\n-\n-\t  ret_rank = GFC_DESCRIPTOR_RANK (retarray);\n-\t  if (ret_rank != 1)\n-\t    runtime_error (\"rank of return array in MINLOC intrinsic\"\n-\t\t\t   \" should be 1, is %ld\", (long int) ret_rank);\n-\n-\t  ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,0);\n-\t  if (ret_extent != rank)\n-\t    runtime_error (\"Incorrect extent in return value of\"\n-\t\t\t   \" MINLOC intrnisic: is %ld, should be %ld\",\n-\t\t\t   (long int) ret_extent, (long int) rank);\n-\t\n-\t  mask_rank = GFC_DESCRIPTOR_RANK (mask);\n-\t  if (rank != mask_rank)\n-\t    runtime_error (\"rank of MASK argument in MINLOC intrnisic\"\n-\t                   \"should be %ld, is %ld\", (long int) rank,\n-\t\t\t   (long int) mask_rank);\n-\n-\t  for (n=0; n<rank; n++)\n-\t    {\n-\t      array_extent = GFC_DESCRIPTOR_EXTENT(array,n);\n-\t      mask_extent = GFC_DESCRIPTOR_EXTENT(mask,n);\n-\t      if (array_extent != mask_extent)\n-\t\truntime_error (\"Incorrect extent in MASK argument of\"\n-\t\t\t       \" MINLOC intrinsic in dimension %ld:\"\n-\t\t\t       \" is %ld, should be %ld\", (long int) n + 1,\n-\t\t\t       (long int) mask_extent, (long int) array_extent);\n-\t    }\n+\n+\t  bounds_iforeach_return ((array_t *) retarray, (array_t *) array,\n+\t\t\t\t  \"MINLOC\");\n+\t  bounds_equal_extents ((array_t *) mask, (array_t *) array,\n+\t\t\t\t  \"MASK argument\", \"MINLOC\");\n \t}\n     }\n \n@@ -340,22 +300,10 @@ sminloc0_16_i1 (gfc_array_i16 * const restrict retarray,\n       retarray->offset = 0;\n       retarray->data = internal_malloc_size (sizeof (GFC_INTEGER_16) * rank);\n     }\n-  else\n+  else if (unlikely (compile_options.bounds_check))\n     {\n-      if (unlikely (compile_options.bounds_check))\n-\t{\n-\t  int ret_rank;\n-\t  index_type ret_extent;\n-\n-\t  ret_rank = GFC_DESCRIPTOR_RANK (retarray);\n-\t  if (ret_rank != 1)\n-\t    runtime_error (\"rank of return array in MINLOC intrinsic\"\n-\t\t\t   \" should be 1, is %ld\", (long int) ret_rank);\n-\n-\t  ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,0);\n-\t    if (ret_extent != rank)\n-\t      runtime_error (\"dimension of return array incorrect\");\n-\t}\n+       bounds_iforeach_return ((array_t *) retarray, (array_t *) array,\n+\t\t\t       \"MINLOC\");\n     }\n \n   dstride = GFC_DESCRIPTOR_STRIDE(retarray,0);"}, {"sha": "cfb4115b34f1920275181c82927088d0e1e595aa", "filename": "libgfortran/generated/minloc0_16_i16.c", "status": "modified", "additions": 10, "deletions": 62, "changes": 72, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/16bff92192676901670042cdce3fbd5f9c928fc8/libgfortran%2Fgenerated%2Fminloc0_16_i16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/16bff92192676901670042cdce3fbd5f9c928fc8/libgfortran%2Fgenerated%2Fminloc0_16_i16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminloc0_16_i16.c?ref=16bff92192676901670042cdce3fbd5f9c928fc8", "patch": "@@ -63,21 +63,8 @@ minloc0_16_i16 (gfc_array_i16 * const restrict retarray,\n   else\n     {\n       if (unlikely (compile_options.bounds_check))\n-\t{\n-\t  int ret_rank;\n-\t  index_type ret_extent;\n-\n-\t  ret_rank = GFC_DESCRIPTOR_RANK (retarray);\n-\t  if (ret_rank != 1)\n-\t    runtime_error (\"rank of return array in MINLOC intrinsic\"\n-\t\t\t   \" should be 1, is %ld\", (long int) ret_rank);\n-\n-\t  ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,0);\n-\t  if (ret_extent != rank)\n-\t    runtime_error (\"Incorrect extent in return value of\"\n-\t\t\t   \" MINLOC intrnisic: is %ld, should be %ld\",\n-\t\t\t   (long int) ret_extent, (long int) rank);\n-\t}\n+        bounds_iforeach_return ((array_t *) retarray, (array_t *) array,\n+\t                        \"MINLOC\");\n     }\n \n   dstride = GFC_DESCRIPTOR_STRIDE(retarray,0);\n@@ -186,38 +173,11 @@ mminloc0_16_i16 (gfc_array_i16 * const restrict retarray,\n     {\n       if (unlikely (compile_options.bounds_check))\n \t{\n-\t  int ret_rank, mask_rank;\n-\t  index_type ret_extent;\n-\t  int n;\n-\t  index_type array_extent, mask_extent;\n-\n-\t  ret_rank = GFC_DESCRIPTOR_RANK (retarray);\n-\t  if (ret_rank != 1)\n-\t    runtime_error (\"rank of return array in MINLOC intrinsic\"\n-\t\t\t   \" should be 1, is %ld\", (long int) ret_rank);\n-\n-\t  ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,0);\n-\t  if (ret_extent != rank)\n-\t    runtime_error (\"Incorrect extent in return value of\"\n-\t\t\t   \" MINLOC intrnisic: is %ld, should be %ld\",\n-\t\t\t   (long int) ret_extent, (long int) rank);\n-\t\n-\t  mask_rank = GFC_DESCRIPTOR_RANK (mask);\n-\t  if (rank != mask_rank)\n-\t    runtime_error (\"rank of MASK argument in MINLOC intrnisic\"\n-\t                   \"should be %ld, is %ld\", (long int) rank,\n-\t\t\t   (long int) mask_rank);\n-\n-\t  for (n=0; n<rank; n++)\n-\t    {\n-\t      array_extent = GFC_DESCRIPTOR_EXTENT(array,n);\n-\t      mask_extent = GFC_DESCRIPTOR_EXTENT(mask,n);\n-\t      if (array_extent != mask_extent)\n-\t\truntime_error (\"Incorrect extent in MASK argument of\"\n-\t\t\t       \" MINLOC intrinsic in dimension %ld:\"\n-\t\t\t       \" is %ld, should be %ld\", (long int) n + 1,\n-\t\t\t       (long int) mask_extent, (long int) array_extent);\n-\t    }\n+\n+\t  bounds_iforeach_return ((array_t *) retarray, (array_t *) array,\n+\t\t\t\t  \"MINLOC\");\n+\t  bounds_equal_extents ((array_t *) mask, (array_t *) array,\n+\t\t\t\t  \"MASK argument\", \"MINLOC\");\n \t}\n     }\n \n@@ -340,22 +300,10 @@ sminloc0_16_i16 (gfc_array_i16 * const restrict retarray,\n       retarray->offset = 0;\n       retarray->data = internal_malloc_size (sizeof (GFC_INTEGER_16) * rank);\n     }\n-  else\n+  else if (unlikely (compile_options.bounds_check))\n     {\n-      if (unlikely (compile_options.bounds_check))\n-\t{\n-\t  int ret_rank;\n-\t  index_type ret_extent;\n-\n-\t  ret_rank = GFC_DESCRIPTOR_RANK (retarray);\n-\t  if (ret_rank != 1)\n-\t    runtime_error (\"rank of return array in MINLOC intrinsic\"\n-\t\t\t   \" should be 1, is %ld\", (long int) ret_rank);\n-\n-\t  ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,0);\n-\t    if (ret_extent != rank)\n-\t      runtime_error (\"dimension of return array incorrect\");\n-\t}\n+       bounds_iforeach_return ((array_t *) retarray, (array_t *) array,\n+\t\t\t       \"MINLOC\");\n     }\n \n   dstride = GFC_DESCRIPTOR_STRIDE(retarray,0);"}, {"sha": "6dbbfbb5105c58a0ffcc872a1d9093a4927afcd7", "filename": "libgfortran/generated/minloc0_16_i2.c", "status": "modified", "additions": 10, "deletions": 62, "changes": 72, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/16bff92192676901670042cdce3fbd5f9c928fc8/libgfortran%2Fgenerated%2Fminloc0_16_i2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/16bff92192676901670042cdce3fbd5f9c928fc8/libgfortran%2Fgenerated%2Fminloc0_16_i2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminloc0_16_i2.c?ref=16bff92192676901670042cdce3fbd5f9c928fc8", "patch": "@@ -63,21 +63,8 @@ minloc0_16_i2 (gfc_array_i16 * const restrict retarray,\n   else\n     {\n       if (unlikely (compile_options.bounds_check))\n-\t{\n-\t  int ret_rank;\n-\t  index_type ret_extent;\n-\n-\t  ret_rank = GFC_DESCRIPTOR_RANK (retarray);\n-\t  if (ret_rank != 1)\n-\t    runtime_error (\"rank of return array in MINLOC intrinsic\"\n-\t\t\t   \" should be 1, is %ld\", (long int) ret_rank);\n-\n-\t  ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,0);\n-\t  if (ret_extent != rank)\n-\t    runtime_error (\"Incorrect extent in return value of\"\n-\t\t\t   \" MINLOC intrnisic: is %ld, should be %ld\",\n-\t\t\t   (long int) ret_extent, (long int) rank);\n-\t}\n+        bounds_iforeach_return ((array_t *) retarray, (array_t *) array,\n+\t                        \"MINLOC\");\n     }\n \n   dstride = GFC_DESCRIPTOR_STRIDE(retarray,0);\n@@ -186,38 +173,11 @@ mminloc0_16_i2 (gfc_array_i16 * const restrict retarray,\n     {\n       if (unlikely (compile_options.bounds_check))\n \t{\n-\t  int ret_rank, mask_rank;\n-\t  index_type ret_extent;\n-\t  int n;\n-\t  index_type array_extent, mask_extent;\n-\n-\t  ret_rank = GFC_DESCRIPTOR_RANK (retarray);\n-\t  if (ret_rank != 1)\n-\t    runtime_error (\"rank of return array in MINLOC intrinsic\"\n-\t\t\t   \" should be 1, is %ld\", (long int) ret_rank);\n-\n-\t  ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,0);\n-\t  if (ret_extent != rank)\n-\t    runtime_error (\"Incorrect extent in return value of\"\n-\t\t\t   \" MINLOC intrnisic: is %ld, should be %ld\",\n-\t\t\t   (long int) ret_extent, (long int) rank);\n-\t\n-\t  mask_rank = GFC_DESCRIPTOR_RANK (mask);\n-\t  if (rank != mask_rank)\n-\t    runtime_error (\"rank of MASK argument in MINLOC intrnisic\"\n-\t                   \"should be %ld, is %ld\", (long int) rank,\n-\t\t\t   (long int) mask_rank);\n-\n-\t  for (n=0; n<rank; n++)\n-\t    {\n-\t      array_extent = GFC_DESCRIPTOR_EXTENT(array,n);\n-\t      mask_extent = GFC_DESCRIPTOR_EXTENT(mask,n);\n-\t      if (array_extent != mask_extent)\n-\t\truntime_error (\"Incorrect extent in MASK argument of\"\n-\t\t\t       \" MINLOC intrinsic in dimension %ld:\"\n-\t\t\t       \" is %ld, should be %ld\", (long int) n + 1,\n-\t\t\t       (long int) mask_extent, (long int) array_extent);\n-\t    }\n+\n+\t  bounds_iforeach_return ((array_t *) retarray, (array_t *) array,\n+\t\t\t\t  \"MINLOC\");\n+\t  bounds_equal_extents ((array_t *) mask, (array_t *) array,\n+\t\t\t\t  \"MASK argument\", \"MINLOC\");\n \t}\n     }\n \n@@ -340,22 +300,10 @@ sminloc0_16_i2 (gfc_array_i16 * const restrict retarray,\n       retarray->offset = 0;\n       retarray->data = internal_malloc_size (sizeof (GFC_INTEGER_16) * rank);\n     }\n-  else\n+  else if (unlikely (compile_options.bounds_check))\n     {\n-      if (unlikely (compile_options.bounds_check))\n-\t{\n-\t  int ret_rank;\n-\t  index_type ret_extent;\n-\n-\t  ret_rank = GFC_DESCRIPTOR_RANK (retarray);\n-\t  if (ret_rank != 1)\n-\t    runtime_error (\"rank of return array in MINLOC intrinsic\"\n-\t\t\t   \" should be 1, is %ld\", (long int) ret_rank);\n-\n-\t  ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,0);\n-\t    if (ret_extent != rank)\n-\t      runtime_error (\"dimension of return array incorrect\");\n-\t}\n+       bounds_iforeach_return ((array_t *) retarray, (array_t *) array,\n+\t\t\t       \"MINLOC\");\n     }\n \n   dstride = GFC_DESCRIPTOR_STRIDE(retarray,0);"}, {"sha": "811ad1fe324ff31eb0bc589e36bb82976f0cc337", "filename": "libgfortran/generated/minloc0_16_i4.c", "status": "modified", "additions": 10, "deletions": 62, "changes": 72, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/16bff92192676901670042cdce3fbd5f9c928fc8/libgfortran%2Fgenerated%2Fminloc0_16_i4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/16bff92192676901670042cdce3fbd5f9c928fc8/libgfortran%2Fgenerated%2Fminloc0_16_i4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminloc0_16_i4.c?ref=16bff92192676901670042cdce3fbd5f9c928fc8", "patch": "@@ -63,21 +63,8 @@ minloc0_16_i4 (gfc_array_i16 * const restrict retarray,\n   else\n     {\n       if (unlikely (compile_options.bounds_check))\n-\t{\n-\t  int ret_rank;\n-\t  index_type ret_extent;\n-\n-\t  ret_rank = GFC_DESCRIPTOR_RANK (retarray);\n-\t  if (ret_rank != 1)\n-\t    runtime_error (\"rank of return array in MINLOC intrinsic\"\n-\t\t\t   \" should be 1, is %ld\", (long int) ret_rank);\n-\n-\t  ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,0);\n-\t  if (ret_extent != rank)\n-\t    runtime_error (\"Incorrect extent in return value of\"\n-\t\t\t   \" MINLOC intrnisic: is %ld, should be %ld\",\n-\t\t\t   (long int) ret_extent, (long int) rank);\n-\t}\n+        bounds_iforeach_return ((array_t *) retarray, (array_t *) array,\n+\t                        \"MINLOC\");\n     }\n \n   dstride = GFC_DESCRIPTOR_STRIDE(retarray,0);\n@@ -186,38 +173,11 @@ mminloc0_16_i4 (gfc_array_i16 * const restrict retarray,\n     {\n       if (unlikely (compile_options.bounds_check))\n \t{\n-\t  int ret_rank, mask_rank;\n-\t  index_type ret_extent;\n-\t  int n;\n-\t  index_type array_extent, mask_extent;\n-\n-\t  ret_rank = GFC_DESCRIPTOR_RANK (retarray);\n-\t  if (ret_rank != 1)\n-\t    runtime_error (\"rank of return array in MINLOC intrinsic\"\n-\t\t\t   \" should be 1, is %ld\", (long int) ret_rank);\n-\n-\t  ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,0);\n-\t  if (ret_extent != rank)\n-\t    runtime_error (\"Incorrect extent in return value of\"\n-\t\t\t   \" MINLOC intrnisic: is %ld, should be %ld\",\n-\t\t\t   (long int) ret_extent, (long int) rank);\n-\t\n-\t  mask_rank = GFC_DESCRIPTOR_RANK (mask);\n-\t  if (rank != mask_rank)\n-\t    runtime_error (\"rank of MASK argument in MINLOC intrnisic\"\n-\t                   \"should be %ld, is %ld\", (long int) rank,\n-\t\t\t   (long int) mask_rank);\n-\n-\t  for (n=0; n<rank; n++)\n-\t    {\n-\t      array_extent = GFC_DESCRIPTOR_EXTENT(array,n);\n-\t      mask_extent = GFC_DESCRIPTOR_EXTENT(mask,n);\n-\t      if (array_extent != mask_extent)\n-\t\truntime_error (\"Incorrect extent in MASK argument of\"\n-\t\t\t       \" MINLOC intrinsic in dimension %ld:\"\n-\t\t\t       \" is %ld, should be %ld\", (long int) n + 1,\n-\t\t\t       (long int) mask_extent, (long int) array_extent);\n-\t    }\n+\n+\t  bounds_iforeach_return ((array_t *) retarray, (array_t *) array,\n+\t\t\t\t  \"MINLOC\");\n+\t  bounds_equal_extents ((array_t *) mask, (array_t *) array,\n+\t\t\t\t  \"MASK argument\", \"MINLOC\");\n \t}\n     }\n \n@@ -340,22 +300,10 @@ sminloc0_16_i4 (gfc_array_i16 * const restrict retarray,\n       retarray->offset = 0;\n       retarray->data = internal_malloc_size (sizeof (GFC_INTEGER_16) * rank);\n     }\n-  else\n+  else if (unlikely (compile_options.bounds_check))\n     {\n-      if (unlikely (compile_options.bounds_check))\n-\t{\n-\t  int ret_rank;\n-\t  index_type ret_extent;\n-\n-\t  ret_rank = GFC_DESCRIPTOR_RANK (retarray);\n-\t  if (ret_rank != 1)\n-\t    runtime_error (\"rank of return array in MINLOC intrinsic\"\n-\t\t\t   \" should be 1, is %ld\", (long int) ret_rank);\n-\n-\t  ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,0);\n-\t    if (ret_extent != rank)\n-\t      runtime_error (\"dimension of return array incorrect\");\n-\t}\n+       bounds_iforeach_return ((array_t *) retarray, (array_t *) array,\n+\t\t\t       \"MINLOC\");\n     }\n \n   dstride = GFC_DESCRIPTOR_STRIDE(retarray,0);"}, {"sha": "583f489d30c85469dce6c8d0f282c37ed0f4cb67", "filename": "libgfortran/generated/minloc0_16_i8.c", "status": "modified", "additions": 10, "deletions": 62, "changes": 72, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/16bff92192676901670042cdce3fbd5f9c928fc8/libgfortran%2Fgenerated%2Fminloc0_16_i8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/16bff92192676901670042cdce3fbd5f9c928fc8/libgfortran%2Fgenerated%2Fminloc0_16_i8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminloc0_16_i8.c?ref=16bff92192676901670042cdce3fbd5f9c928fc8", "patch": "@@ -63,21 +63,8 @@ minloc0_16_i8 (gfc_array_i16 * const restrict retarray,\n   else\n     {\n       if (unlikely (compile_options.bounds_check))\n-\t{\n-\t  int ret_rank;\n-\t  index_type ret_extent;\n-\n-\t  ret_rank = GFC_DESCRIPTOR_RANK (retarray);\n-\t  if (ret_rank != 1)\n-\t    runtime_error (\"rank of return array in MINLOC intrinsic\"\n-\t\t\t   \" should be 1, is %ld\", (long int) ret_rank);\n-\n-\t  ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,0);\n-\t  if (ret_extent != rank)\n-\t    runtime_error (\"Incorrect extent in return value of\"\n-\t\t\t   \" MINLOC intrnisic: is %ld, should be %ld\",\n-\t\t\t   (long int) ret_extent, (long int) rank);\n-\t}\n+        bounds_iforeach_return ((array_t *) retarray, (array_t *) array,\n+\t                        \"MINLOC\");\n     }\n \n   dstride = GFC_DESCRIPTOR_STRIDE(retarray,0);\n@@ -186,38 +173,11 @@ mminloc0_16_i8 (gfc_array_i16 * const restrict retarray,\n     {\n       if (unlikely (compile_options.bounds_check))\n \t{\n-\t  int ret_rank, mask_rank;\n-\t  index_type ret_extent;\n-\t  int n;\n-\t  index_type array_extent, mask_extent;\n-\n-\t  ret_rank = GFC_DESCRIPTOR_RANK (retarray);\n-\t  if (ret_rank != 1)\n-\t    runtime_error (\"rank of return array in MINLOC intrinsic\"\n-\t\t\t   \" should be 1, is %ld\", (long int) ret_rank);\n-\n-\t  ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,0);\n-\t  if (ret_extent != rank)\n-\t    runtime_error (\"Incorrect extent in return value of\"\n-\t\t\t   \" MINLOC intrnisic: is %ld, should be %ld\",\n-\t\t\t   (long int) ret_extent, (long int) rank);\n-\t\n-\t  mask_rank = GFC_DESCRIPTOR_RANK (mask);\n-\t  if (rank != mask_rank)\n-\t    runtime_error (\"rank of MASK argument in MINLOC intrnisic\"\n-\t                   \"should be %ld, is %ld\", (long int) rank,\n-\t\t\t   (long int) mask_rank);\n-\n-\t  for (n=0; n<rank; n++)\n-\t    {\n-\t      array_extent = GFC_DESCRIPTOR_EXTENT(array,n);\n-\t      mask_extent = GFC_DESCRIPTOR_EXTENT(mask,n);\n-\t      if (array_extent != mask_extent)\n-\t\truntime_error (\"Incorrect extent in MASK argument of\"\n-\t\t\t       \" MINLOC intrinsic in dimension %ld:\"\n-\t\t\t       \" is %ld, should be %ld\", (long int) n + 1,\n-\t\t\t       (long int) mask_extent, (long int) array_extent);\n-\t    }\n+\n+\t  bounds_iforeach_return ((array_t *) retarray, (array_t *) array,\n+\t\t\t\t  \"MINLOC\");\n+\t  bounds_equal_extents ((array_t *) mask, (array_t *) array,\n+\t\t\t\t  \"MASK argument\", \"MINLOC\");\n \t}\n     }\n \n@@ -340,22 +300,10 @@ sminloc0_16_i8 (gfc_array_i16 * const restrict retarray,\n       retarray->offset = 0;\n       retarray->data = internal_malloc_size (sizeof (GFC_INTEGER_16) * rank);\n     }\n-  else\n+  else if (unlikely (compile_options.bounds_check))\n     {\n-      if (unlikely (compile_options.bounds_check))\n-\t{\n-\t  int ret_rank;\n-\t  index_type ret_extent;\n-\n-\t  ret_rank = GFC_DESCRIPTOR_RANK (retarray);\n-\t  if (ret_rank != 1)\n-\t    runtime_error (\"rank of return array in MINLOC intrinsic\"\n-\t\t\t   \" should be 1, is %ld\", (long int) ret_rank);\n-\n-\t  ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,0);\n-\t    if (ret_extent != rank)\n-\t      runtime_error (\"dimension of return array incorrect\");\n-\t}\n+       bounds_iforeach_return ((array_t *) retarray, (array_t *) array,\n+\t\t\t       \"MINLOC\");\n     }\n \n   dstride = GFC_DESCRIPTOR_STRIDE(retarray,0);"}, {"sha": "fa29e93e2f50d5450d1eca2eeff77a22706fa64a", "filename": "libgfortran/generated/minloc0_16_r10.c", "status": "modified", "additions": 10, "deletions": 62, "changes": 72, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/16bff92192676901670042cdce3fbd5f9c928fc8/libgfortran%2Fgenerated%2Fminloc0_16_r10.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/16bff92192676901670042cdce3fbd5f9c928fc8/libgfortran%2Fgenerated%2Fminloc0_16_r10.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminloc0_16_r10.c?ref=16bff92192676901670042cdce3fbd5f9c928fc8", "patch": "@@ -63,21 +63,8 @@ minloc0_16_r10 (gfc_array_i16 * const restrict retarray,\n   else\n     {\n       if (unlikely (compile_options.bounds_check))\n-\t{\n-\t  int ret_rank;\n-\t  index_type ret_extent;\n-\n-\t  ret_rank = GFC_DESCRIPTOR_RANK (retarray);\n-\t  if (ret_rank != 1)\n-\t    runtime_error (\"rank of return array in MINLOC intrinsic\"\n-\t\t\t   \" should be 1, is %ld\", (long int) ret_rank);\n-\n-\t  ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,0);\n-\t  if (ret_extent != rank)\n-\t    runtime_error (\"Incorrect extent in return value of\"\n-\t\t\t   \" MINLOC intrnisic: is %ld, should be %ld\",\n-\t\t\t   (long int) ret_extent, (long int) rank);\n-\t}\n+        bounds_iforeach_return ((array_t *) retarray, (array_t *) array,\n+\t                        \"MINLOC\");\n     }\n \n   dstride = GFC_DESCRIPTOR_STRIDE(retarray,0);\n@@ -186,38 +173,11 @@ mminloc0_16_r10 (gfc_array_i16 * const restrict retarray,\n     {\n       if (unlikely (compile_options.bounds_check))\n \t{\n-\t  int ret_rank, mask_rank;\n-\t  index_type ret_extent;\n-\t  int n;\n-\t  index_type array_extent, mask_extent;\n-\n-\t  ret_rank = GFC_DESCRIPTOR_RANK (retarray);\n-\t  if (ret_rank != 1)\n-\t    runtime_error (\"rank of return array in MINLOC intrinsic\"\n-\t\t\t   \" should be 1, is %ld\", (long int) ret_rank);\n-\n-\t  ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,0);\n-\t  if (ret_extent != rank)\n-\t    runtime_error (\"Incorrect extent in return value of\"\n-\t\t\t   \" MINLOC intrnisic: is %ld, should be %ld\",\n-\t\t\t   (long int) ret_extent, (long int) rank);\n-\t\n-\t  mask_rank = GFC_DESCRIPTOR_RANK (mask);\n-\t  if (rank != mask_rank)\n-\t    runtime_error (\"rank of MASK argument in MINLOC intrnisic\"\n-\t                   \"should be %ld, is %ld\", (long int) rank,\n-\t\t\t   (long int) mask_rank);\n-\n-\t  for (n=0; n<rank; n++)\n-\t    {\n-\t      array_extent = GFC_DESCRIPTOR_EXTENT(array,n);\n-\t      mask_extent = GFC_DESCRIPTOR_EXTENT(mask,n);\n-\t      if (array_extent != mask_extent)\n-\t\truntime_error (\"Incorrect extent in MASK argument of\"\n-\t\t\t       \" MINLOC intrinsic in dimension %ld:\"\n-\t\t\t       \" is %ld, should be %ld\", (long int) n + 1,\n-\t\t\t       (long int) mask_extent, (long int) array_extent);\n-\t    }\n+\n+\t  bounds_iforeach_return ((array_t *) retarray, (array_t *) array,\n+\t\t\t\t  \"MINLOC\");\n+\t  bounds_equal_extents ((array_t *) mask, (array_t *) array,\n+\t\t\t\t  \"MASK argument\", \"MINLOC\");\n \t}\n     }\n \n@@ -340,22 +300,10 @@ sminloc0_16_r10 (gfc_array_i16 * const restrict retarray,\n       retarray->offset = 0;\n       retarray->data = internal_malloc_size (sizeof (GFC_INTEGER_16) * rank);\n     }\n-  else\n+  else if (unlikely (compile_options.bounds_check))\n     {\n-      if (unlikely (compile_options.bounds_check))\n-\t{\n-\t  int ret_rank;\n-\t  index_type ret_extent;\n-\n-\t  ret_rank = GFC_DESCRIPTOR_RANK (retarray);\n-\t  if (ret_rank != 1)\n-\t    runtime_error (\"rank of return array in MINLOC intrinsic\"\n-\t\t\t   \" should be 1, is %ld\", (long int) ret_rank);\n-\n-\t  ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,0);\n-\t    if (ret_extent != rank)\n-\t      runtime_error (\"dimension of return array incorrect\");\n-\t}\n+       bounds_iforeach_return ((array_t *) retarray, (array_t *) array,\n+\t\t\t       \"MINLOC\");\n     }\n \n   dstride = GFC_DESCRIPTOR_STRIDE(retarray,0);"}, {"sha": "304ca7e95fcfbe7d770704b26378fe61c6f93cca", "filename": "libgfortran/generated/minloc0_16_r16.c", "status": "modified", "additions": 10, "deletions": 62, "changes": 72, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/16bff92192676901670042cdce3fbd5f9c928fc8/libgfortran%2Fgenerated%2Fminloc0_16_r16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/16bff92192676901670042cdce3fbd5f9c928fc8/libgfortran%2Fgenerated%2Fminloc0_16_r16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminloc0_16_r16.c?ref=16bff92192676901670042cdce3fbd5f9c928fc8", "patch": "@@ -63,21 +63,8 @@ minloc0_16_r16 (gfc_array_i16 * const restrict retarray,\n   else\n     {\n       if (unlikely (compile_options.bounds_check))\n-\t{\n-\t  int ret_rank;\n-\t  index_type ret_extent;\n-\n-\t  ret_rank = GFC_DESCRIPTOR_RANK (retarray);\n-\t  if (ret_rank != 1)\n-\t    runtime_error (\"rank of return array in MINLOC intrinsic\"\n-\t\t\t   \" should be 1, is %ld\", (long int) ret_rank);\n-\n-\t  ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,0);\n-\t  if (ret_extent != rank)\n-\t    runtime_error (\"Incorrect extent in return value of\"\n-\t\t\t   \" MINLOC intrnisic: is %ld, should be %ld\",\n-\t\t\t   (long int) ret_extent, (long int) rank);\n-\t}\n+        bounds_iforeach_return ((array_t *) retarray, (array_t *) array,\n+\t                        \"MINLOC\");\n     }\n \n   dstride = GFC_DESCRIPTOR_STRIDE(retarray,0);\n@@ -186,38 +173,11 @@ mminloc0_16_r16 (gfc_array_i16 * const restrict retarray,\n     {\n       if (unlikely (compile_options.bounds_check))\n \t{\n-\t  int ret_rank, mask_rank;\n-\t  index_type ret_extent;\n-\t  int n;\n-\t  index_type array_extent, mask_extent;\n-\n-\t  ret_rank = GFC_DESCRIPTOR_RANK (retarray);\n-\t  if (ret_rank != 1)\n-\t    runtime_error (\"rank of return array in MINLOC intrinsic\"\n-\t\t\t   \" should be 1, is %ld\", (long int) ret_rank);\n-\n-\t  ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,0);\n-\t  if (ret_extent != rank)\n-\t    runtime_error (\"Incorrect extent in return value of\"\n-\t\t\t   \" MINLOC intrnisic: is %ld, should be %ld\",\n-\t\t\t   (long int) ret_extent, (long int) rank);\n-\t\n-\t  mask_rank = GFC_DESCRIPTOR_RANK (mask);\n-\t  if (rank != mask_rank)\n-\t    runtime_error (\"rank of MASK argument in MINLOC intrnisic\"\n-\t                   \"should be %ld, is %ld\", (long int) rank,\n-\t\t\t   (long int) mask_rank);\n-\n-\t  for (n=0; n<rank; n++)\n-\t    {\n-\t      array_extent = GFC_DESCRIPTOR_EXTENT(array,n);\n-\t      mask_extent = GFC_DESCRIPTOR_EXTENT(mask,n);\n-\t      if (array_extent != mask_extent)\n-\t\truntime_error (\"Incorrect extent in MASK argument of\"\n-\t\t\t       \" MINLOC intrinsic in dimension %ld:\"\n-\t\t\t       \" is %ld, should be %ld\", (long int) n + 1,\n-\t\t\t       (long int) mask_extent, (long int) array_extent);\n-\t    }\n+\n+\t  bounds_iforeach_return ((array_t *) retarray, (array_t *) array,\n+\t\t\t\t  \"MINLOC\");\n+\t  bounds_equal_extents ((array_t *) mask, (array_t *) array,\n+\t\t\t\t  \"MASK argument\", \"MINLOC\");\n \t}\n     }\n \n@@ -340,22 +300,10 @@ sminloc0_16_r16 (gfc_array_i16 * const restrict retarray,\n       retarray->offset = 0;\n       retarray->data = internal_malloc_size (sizeof (GFC_INTEGER_16) * rank);\n     }\n-  else\n+  else if (unlikely (compile_options.bounds_check))\n     {\n-      if (unlikely (compile_options.bounds_check))\n-\t{\n-\t  int ret_rank;\n-\t  index_type ret_extent;\n-\n-\t  ret_rank = GFC_DESCRIPTOR_RANK (retarray);\n-\t  if (ret_rank != 1)\n-\t    runtime_error (\"rank of return array in MINLOC intrinsic\"\n-\t\t\t   \" should be 1, is %ld\", (long int) ret_rank);\n-\n-\t  ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,0);\n-\t    if (ret_extent != rank)\n-\t      runtime_error (\"dimension of return array incorrect\");\n-\t}\n+       bounds_iforeach_return ((array_t *) retarray, (array_t *) array,\n+\t\t\t       \"MINLOC\");\n     }\n \n   dstride = GFC_DESCRIPTOR_STRIDE(retarray,0);"}, {"sha": "0ce5e08a6734ad3efdbd07e67157eadcbeab2181", "filename": "libgfortran/generated/minloc0_16_r4.c", "status": "modified", "additions": 10, "deletions": 62, "changes": 72, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/16bff92192676901670042cdce3fbd5f9c928fc8/libgfortran%2Fgenerated%2Fminloc0_16_r4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/16bff92192676901670042cdce3fbd5f9c928fc8/libgfortran%2Fgenerated%2Fminloc0_16_r4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminloc0_16_r4.c?ref=16bff92192676901670042cdce3fbd5f9c928fc8", "patch": "@@ -63,21 +63,8 @@ minloc0_16_r4 (gfc_array_i16 * const restrict retarray,\n   else\n     {\n       if (unlikely (compile_options.bounds_check))\n-\t{\n-\t  int ret_rank;\n-\t  index_type ret_extent;\n-\n-\t  ret_rank = GFC_DESCRIPTOR_RANK (retarray);\n-\t  if (ret_rank != 1)\n-\t    runtime_error (\"rank of return array in MINLOC intrinsic\"\n-\t\t\t   \" should be 1, is %ld\", (long int) ret_rank);\n-\n-\t  ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,0);\n-\t  if (ret_extent != rank)\n-\t    runtime_error (\"Incorrect extent in return value of\"\n-\t\t\t   \" MINLOC intrnisic: is %ld, should be %ld\",\n-\t\t\t   (long int) ret_extent, (long int) rank);\n-\t}\n+        bounds_iforeach_return ((array_t *) retarray, (array_t *) array,\n+\t                        \"MINLOC\");\n     }\n \n   dstride = GFC_DESCRIPTOR_STRIDE(retarray,0);\n@@ -186,38 +173,11 @@ mminloc0_16_r4 (gfc_array_i16 * const restrict retarray,\n     {\n       if (unlikely (compile_options.bounds_check))\n \t{\n-\t  int ret_rank, mask_rank;\n-\t  index_type ret_extent;\n-\t  int n;\n-\t  index_type array_extent, mask_extent;\n-\n-\t  ret_rank = GFC_DESCRIPTOR_RANK (retarray);\n-\t  if (ret_rank != 1)\n-\t    runtime_error (\"rank of return array in MINLOC intrinsic\"\n-\t\t\t   \" should be 1, is %ld\", (long int) ret_rank);\n-\n-\t  ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,0);\n-\t  if (ret_extent != rank)\n-\t    runtime_error (\"Incorrect extent in return value of\"\n-\t\t\t   \" MINLOC intrnisic: is %ld, should be %ld\",\n-\t\t\t   (long int) ret_extent, (long int) rank);\n-\t\n-\t  mask_rank = GFC_DESCRIPTOR_RANK (mask);\n-\t  if (rank != mask_rank)\n-\t    runtime_error (\"rank of MASK argument in MINLOC intrnisic\"\n-\t                   \"should be %ld, is %ld\", (long int) rank,\n-\t\t\t   (long int) mask_rank);\n-\n-\t  for (n=0; n<rank; n++)\n-\t    {\n-\t      array_extent = GFC_DESCRIPTOR_EXTENT(array,n);\n-\t      mask_extent = GFC_DESCRIPTOR_EXTENT(mask,n);\n-\t      if (array_extent != mask_extent)\n-\t\truntime_error (\"Incorrect extent in MASK argument of\"\n-\t\t\t       \" MINLOC intrinsic in dimension %ld:\"\n-\t\t\t       \" is %ld, should be %ld\", (long int) n + 1,\n-\t\t\t       (long int) mask_extent, (long int) array_extent);\n-\t    }\n+\n+\t  bounds_iforeach_return ((array_t *) retarray, (array_t *) array,\n+\t\t\t\t  \"MINLOC\");\n+\t  bounds_equal_extents ((array_t *) mask, (array_t *) array,\n+\t\t\t\t  \"MASK argument\", \"MINLOC\");\n \t}\n     }\n \n@@ -340,22 +300,10 @@ sminloc0_16_r4 (gfc_array_i16 * const restrict retarray,\n       retarray->offset = 0;\n       retarray->data = internal_malloc_size (sizeof (GFC_INTEGER_16) * rank);\n     }\n-  else\n+  else if (unlikely (compile_options.bounds_check))\n     {\n-      if (unlikely (compile_options.bounds_check))\n-\t{\n-\t  int ret_rank;\n-\t  index_type ret_extent;\n-\n-\t  ret_rank = GFC_DESCRIPTOR_RANK (retarray);\n-\t  if (ret_rank != 1)\n-\t    runtime_error (\"rank of return array in MINLOC intrinsic\"\n-\t\t\t   \" should be 1, is %ld\", (long int) ret_rank);\n-\n-\t  ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,0);\n-\t    if (ret_extent != rank)\n-\t      runtime_error (\"dimension of return array incorrect\");\n-\t}\n+       bounds_iforeach_return ((array_t *) retarray, (array_t *) array,\n+\t\t\t       \"MINLOC\");\n     }\n \n   dstride = GFC_DESCRIPTOR_STRIDE(retarray,0);"}, {"sha": "8346be1ff4b47cc930c04aaa6a6f71a32c0e93a4", "filename": "libgfortran/generated/minloc0_16_r8.c", "status": "modified", "additions": 10, "deletions": 62, "changes": 72, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/16bff92192676901670042cdce3fbd5f9c928fc8/libgfortran%2Fgenerated%2Fminloc0_16_r8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/16bff92192676901670042cdce3fbd5f9c928fc8/libgfortran%2Fgenerated%2Fminloc0_16_r8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminloc0_16_r8.c?ref=16bff92192676901670042cdce3fbd5f9c928fc8", "patch": "@@ -63,21 +63,8 @@ minloc0_16_r8 (gfc_array_i16 * const restrict retarray,\n   else\n     {\n       if (unlikely (compile_options.bounds_check))\n-\t{\n-\t  int ret_rank;\n-\t  index_type ret_extent;\n-\n-\t  ret_rank = GFC_DESCRIPTOR_RANK (retarray);\n-\t  if (ret_rank != 1)\n-\t    runtime_error (\"rank of return array in MINLOC intrinsic\"\n-\t\t\t   \" should be 1, is %ld\", (long int) ret_rank);\n-\n-\t  ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,0);\n-\t  if (ret_extent != rank)\n-\t    runtime_error (\"Incorrect extent in return value of\"\n-\t\t\t   \" MINLOC intrnisic: is %ld, should be %ld\",\n-\t\t\t   (long int) ret_extent, (long int) rank);\n-\t}\n+        bounds_iforeach_return ((array_t *) retarray, (array_t *) array,\n+\t                        \"MINLOC\");\n     }\n \n   dstride = GFC_DESCRIPTOR_STRIDE(retarray,0);\n@@ -186,38 +173,11 @@ mminloc0_16_r8 (gfc_array_i16 * const restrict retarray,\n     {\n       if (unlikely (compile_options.bounds_check))\n \t{\n-\t  int ret_rank, mask_rank;\n-\t  index_type ret_extent;\n-\t  int n;\n-\t  index_type array_extent, mask_extent;\n-\n-\t  ret_rank = GFC_DESCRIPTOR_RANK (retarray);\n-\t  if (ret_rank != 1)\n-\t    runtime_error (\"rank of return array in MINLOC intrinsic\"\n-\t\t\t   \" should be 1, is %ld\", (long int) ret_rank);\n-\n-\t  ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,0);\n-\t  if (ret_extent != rank)\n-\t    runtime_error (\"Incorrect extent in return value of\"\n-\t\t\t   \" MINLOC intrnisic: is %ld, should be %ld\",\n-\t\t\t   (long int) ret_extent, (long int) rank);\n-\t\n-\t  mask_rank = GFC_DESCRIPTOR_RANK (mask);\n-\t  if (rank != mask_rank)\n-\t    runtime_error (\"rank of MASK argument in MINLOC intrnisic\"\n-\t                   \"should be %ld, is %ld\", (long int) rank,\n-\t\t\t   (long int) mask_rank);\n-\n-\t  for (n=0; n<rank; n++)\n-\t    {\n-\t      array_extent = GFC_DESCRIPTOR_EXTENT(array,n);\n-\t      mask_extent = GFC_DESCRIPTOR_EXTENT(mask,n);\n-\t      if (array_extent != mask_extent)\n-\t\truntime_error (\"Incorrect extent in MASK argument of\"\n-\t\t\t       \" MINLOC intrinsic in dimension %ld:\"\n-\t\t\t       \" is %ld, should be %ld\", (long int) n + 1,\n-\t\t\t       (long int) mask_extent, (long int) array_extent);\n-\t    }\n+\n+\t  bounds_iforeach_return ((array_t *) retarray, (array_t *) array,\n+\t\t\t\t  \"MINLOC\");\n+\t  bounds_equal_extents ((array_t *) mask, (array_t *) array,\n+\t\t\t\t  \"MASK argument\", \"MINLOC\");\n \t}\n     }\n \n@@ -340,22 +300,10 @@ sminloc0_16_r8 (gfc_array_i16 * const restrict retarray,\n       retarray->offset = 0;\n       retarray->data = internal_malloc_size (sizeof (GFC_INTEGER_16) * rank);\n     }\n-  else\n+  else if (unlikely (compile_options.bounds_check))\n     {\n-      if (unlikely (compile_options.bounds_check))\n-\t{\n-\t  int ret_rank;\n-\t  index_type ret_extent;\n-\n-\t  ret_rank = GFC_DESCRIPTOR_RANK (retarray);\n-\t  if (ret_rank != 1)\n-\t    runtime_error (\"rank of return array in MINLOC intrinsic\"\n-\t\t\t   \" should be 1, is %ld\", (long int) ret_rank);\n-\n-\t  ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,0);\n-\t    if (ret_extent != rank)\n-\t      runtime_error (\"dimension of return array incorrect\");\n-\t}\n+       bounds_iforeach_return ((array_t *) retarray, (array_t *) array,\n+\t\t\t       \"MINLOC\");\n     }\n \n   dstride = GFC_DESCRIPTOR_STRIDE(retarray,0);"}, {"sha": "3a0b22ba71acc3654a93182345be6c7e148c1ca3", "filename": "libgfortran/generated/minloc0_4_i1.c", "status": "modified", "additions": 10, "deletions": 62, "changes": 72, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/16bff92192676901670042cdce3fbd5f9c928fc8/libgfortran%2Fgenerated%2Fminloc0_4_i1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/16bff92192676901670042cdce3fbd5f9c928fc8/libgfortran%2Fgenerated%2Fminloc0_4_i1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminloc0_4_i1.c?ref=16bff92192676901670042cdce3fbd5f9c928fc8", "patch": "@@ -63,21 +63,8 @@ minloc0_4_i1 (gfc_array_i4 * const restrict retarray,\n   else\n     {\n       if (unlikely (compile_options.bounds_check))\n-\t{\n-\t  int ret_rank;\n-\t  index_type ret_extent;\n-\n-\t  ret_rank = GFC_DESCRIPTOR_RANK (retarray);\n-\t  if (ret_rank != 1)\n-\t    runtime_error (\"rank of return array in MINLOC intrinsic\"\n-\t\t\t   \" should be 1, is %ld\", (long int) ret_rank);\n-\n-\t  ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,0);\n-\t  if (ret_extent != rank)\n-\t    runtime_error (\"Incorrect extent in return value of\"\n-\t\t\t   \" MINLOC intrnisic: is %ld, should be %ld\",\n-\t\t\t   (long int) ret_extent, (long int) rank);\n-\t}\n+        bounds_iforeach_return ((array_t *) retarray, (array_t *) array,\n+\t                        \"MINLOC\");\n     }\n \n   dstride = GFC_DESCRIPTOR_STRIDE(retarray,0);\n@@ -186,38 +173,11 @@ mminloc0_4_i1 (gfc_array_i4 * const restrict retarray,\n     {\n       if (unlikely (compile_options.bounds_check))\n \t{\n-\t  int ret_rank, mask_rank;\n-\t  index_type ret_extent;\n-\t  int n;\n-\t  index_type array_extent, mask_extent;\n-\n-\t  ret_rank = GFC_DESCRIPTOR_RANK (retarray);\n-\t  if (ret_rank != 1)\n-\t    runtime_error (\"rank of return array in MINLOC intrinsic\"\n-\t\t\t   \" should be 1, is %ld\", (long int) ret_rank);\n-\n-\t  ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,0);\n-\t  if (ret_extent != rank)\n-\t    runtime_error (\"Incorrect extent in return value of\"\n-\t\t\t   \" MINLOC intrnisic: is %ld, should be %ld\",\n-\t\t\t   (long int) ret_extent, (long int) rank);\n-\t\n-\t  mask_rank = GFC_DESCRIPTOR_RANK (mask);\n-\t  if (rank != mask_rank)\n-\t    runtime_error (\"rank of MASK argument in MINLOC intrnisic\"\n-\t                   \"should be %ld, is %ld\", (long int) rank,\n-\t\t\t   (long int) mask_rank);\n-\n-\t  for (n=0; n<rank; n++)\n-\t    {\n-\t      array_extent = GFC_DESCRIPTOR_EXTENT(array,n);\n-\t      mask_extent = GFC_DESCRIPTOR_EXTENT(mask,n);\n-\t      if (array_extent != mask_extent)\n-\t\truntime_error (\"Incorrect extent in MASK argument of\"\n-\t\t\t       \" MINLOC intrinsic in dimension %ld:\"\n-\t\t\t       \" is %ld, should be %ld\", (long int) n + 1,\n-\t\t\t       (long int) mask_extent, (long int) array_extent);\n-\t    }\n+\n+\t  bounds_iforeach_return ((array_t *) retarray, (array_t *) array,\n+\t\t\t\t  \"MINLOC\");\n+\t  bounds_equal_extents ((array_t *) mask, (array_t *) array,\n+\t\t\t\t  \"MASK argument\", \"MINLOC\");\n \t}\n     }\n \n@@ -340,22 +300,10 @@ sminloc0_4_i1 (gfc_array_i4 * const restrict retarray,\n       retarray->offset = 0;\n       retarray->data = internal_malloc_size (sizeof (GFC_INTEGER_4) * rank);\n     }\n-  else\n+  else if (unlikely (compile_options.bounds_check))\n     {\n-      if (unlikely (compile_options.bounds_check))\n-\t{\n-\t  int ret_rank;\n-\t  index_type ret_extent;\n-\n-\t  ret_rank = GFC_DESCRIPTOR_RANK (retarray);\n-\t  if (ret_rank != 1)\n-\t    runtime_error (\"rank of return array in MINLOC intrinsic\"\n-\t\t\t   \" should be 1, is %ld\", (long int) ret_rank);\n-\n-\t  ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,0);\n-\t    if (ret_extent != rank)\n-\t      runtime_error (\"dimension of return array incorrect\");\n-\t}\n+       bounds_iforeach_return ((array_t *) retarray, (array_t *) array,\n+\t\t\t       \"MINLOC\");\n     }\n \n   dstride = GFC_DESCRIPTOR_STRIDE(retarray,0);"}, {"sha": "cd947eb6f05ef153002cff0fe725d0d61ce6fb79", "filename": "libgfortran/generated/minloc0_4_i16.c", "status": "modified", "additions": 10, "deletions": 62, "changes": 72, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/16bff92192676901670042cdce3fbd5f9c928fc8/libgfortran%2Fgenerated%2Fminloc0_4_i16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/16bff92192676901670042cdce3fbd5f9c928fc8/libgfortran%2Fgenerated%2Fminloc0_4_i16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminloc0_4_i16.c?ref=16bff92192676901670042cdce3fbd5f9c928fc8", "patch": "@@ -63,21 +63,8 @@ minloc0_4_i16 (gfc_array_i4 * const restrict retarray,\n   else\n     {\n       if (unlikely (compile_options.bounds_check))\n-\t{\n-\t  int ret_rank;\n-\t  index_type ret_extent;\n-\n-\t  ret_rank = GFC_DESCRIPTOR_RANK (retarray);\n-\t  if (ret_rank != 1)\n-\t    runtime_error (\"rank of return array in MINLOC intrinsic\"\n-\t\t\t   \" should be 1, is %ld\", (long int) ret_rank);\n-\n-\t  ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,0);\n-\t  if (ret_extent != rank)\n-\t    runtime_error (\"Incorrect extent in return value of\"\n-\t\t\t   \" MINLOC intrnisic: is %ld, should be %ld\",\n-\t\t\t   (long int) ret_extent, (long int) rank);\n-\t}\n+        bounds_iforeach_return ((array_t *) retarray, (array_t *) array,\n+\t                        \"MINLOC\");\n     }\n \n   dstride = GFC_DESCRIPTOR_STRIDE(retarray,0);\n@@ -186,38 +173,11 @@ mminloc0_4_i16 (gfc_array_i4 * const restrict retarray,\n     {\n       if (unlikely (compile_options.bounds_check))\n \t{\n-\t  int ret_rank, mask_rank;\n-\t  index_type ret_extent;\n-\t  int n;\n-\t  index_type array_extent, mask_extent;\n-\n-\t  ret_rank = GFC_DESCRIPTOR_RANK (retarray);\n-\t  if (ret_rank != 1)\n-\t    runtime_error (\"rank of return array in MINLOC intrinsic\"\n-\t\t\t   \" should be 1, is %ld\", (long int) ret_rank);\n-\n-\t  ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,0);\n-\t  if (ret_extent != rank)\n-\t    runtime_error (\"Incorrect extent in return value of\"\n-\t\t\t   \" MINLOC intrnisic: is %ld, should be %ld\",\n-\t\t\t   (long int) ret_extent, (long int) rank);\n-\t\n-\t  mask_rank = GFC_DESCRIPTOR_RANK (mask);\n-\t  if (rank != mask_rank)\n-\t    runtime_error (\"rank of MASK argument in MINLOC intrnisic\"\n-\t                   \"should be %ld, is %ld\", (long int) rank,\n-\t\t\t   (long int) mask_rank);\n-\n-\t  for (n=0; n<rank; n++)\n-\t    {\n-\t      array_extent = GFC_DESCRIPTOR_EXTENT(array,n);\n-\t      mask_extent = GFC_DESCRIPTOR_EXTENT(mask,n);\n-\t      if (array_extent != mask_extent)\n-\t\truntime_error (\"Incorrect extent in MASK argument of\"\n-\t\t\t       \" MINLOC intrinsic in dimension %ld:\"\n-\t\t\t       \" is %ld, should be %ld\", (long int) n + 1,\n-\t\t\t       (long int) mask_extent, (long int) array_extent);\n-\t    }\n+\n+\t  bounds_iforeach_return ((array_t *) retarray, (array_t *) array,\n+\t\t\t\t  \"MINLOC\");\n+\t  bounds_equal_extents ((array_t *) mask, (array_t *) array,\n+\t\t\t\t  \"MASK argument\", \"MINLOC\");\n \t}\n     }\n \n@@ -340,22 +300,10 @@ sminloc0_4_i16 (gfc_array_i4 * const restrict retarray,\n       retarray->offset = 0;\n       retarray->data = internal_malloc_size (sizeof (GFC_INTEGER_4) * rank);\n     }\n-  else\n+  else if (unlikely (compile_options.bounds_check))\n     {\n-      if (unlikely (compile_options.bounds_check))\n-\t{\n-\t  int ret_rank;\n-\t  index_type ret_extent;\n-\n-\t  ret_rank = GFC_DESCRIPTOR_RANK (retarray);\n-\t  if (ret_rank != 1)\n-\t    runtime_error (\"rank of return array in MINLOC intrinsic\"\n-\t\t\t   \" should be 1, is %ld\", (long int) ret_rank);\n-\n-\t  ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,0);\n-\t    if (ret_extent != rank)\n-\t      runtime_error (\"dimension of return array incorrect\");\n-\t}\n+       bounds_iforeach_return ((array_t *) retarray, (array_t *) array,\n+\t\t\t       \"MINLOC\");\n     }\n \n   dstride = GFC_DESCRIPTOR_STRIDE(retarray,0);"}, {"sha": "6d65cfb2421dd24ee6c4ac361ad723e01d0639ba", "filename": "libgfortran/generated/minloc0_4_i2.c", "status": "modified", "additions": 10, "deletions": 62, "changes": 72, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/16bff92192676901670042cdce3fbd5f9c928fc8/libgfortran%2Fgenerated%2Fminloc0_4_i2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/16bff92192676901670042cdce3fbd5f9c928fc8/libgfortran%2Fgenerated%2Fminloc0_4_i2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminloc0_4_i2.c?ref=16bff92192676901670042cdce3fbd5f9c928fc8", "patch": "@@ -63,21 +63,8 @@ minloc0_4_i2 (gfc_array_i4 * const restrict retarray,\n   else\n     {\n       if (unlikely (compile_options.bounds_check))\n-\t{\n-\t  int ret_rank;\n-\t  index_type ret_extent;\n-\n-\t  ret_rank = GFC_DESCRIPTOR_RANK (retarray);\n-\t  if (ret_rank != 1)\n-\t    runtime_error (\"rank of return array in MINLOC intrinsic\"\n-\t\t\t   \" should be 1, is %ld\", (long int) ret_rank);\n-\n-\t  ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,0);\n-\t  if (ret_extent != rank)\n-\t    runtime_error (\"Incorrect extent in return value of\"\n-\t\t\t   \" MINLOC intrnisic: is %ld, should be %ld\",\n-\t\t\t   (long int) ret_extent, (long int) rank);\n-\t}\n+        bounds_iforeach_return ((array_t *) retarray, (array_t *) array,\n+\t                        \"MINLOC\");\n     }\n \n   dstride = GFC_DESCRIPTOR_STRIDE(retarray,0);\n@@ -186,38 +173,11 @@ mminloc0_4_i2 (gfc_array_i4 * const restrict retarray,\n     {\n       if (unlikely (compile_options.bounds_check))\n \t{\n-\t  int ret_rank, mask_rank;\n-\t  index_type ret_extent;\n-\t  int n;\n-\t  index_type array_extent, mask_extent;\n-\n-\t  ret_rank = GFC_DESCRIPTOR_RANK (retarray);\n-\t  if (ret_rank != 1)\n-\t    runtime_error (\"rank of return array in MINLOC intrinsic\"\n-\t\t\t   \" should be 1, is %ld\", (long int) ret_rank);\n-\n-\t  ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,0);\n-\t  if (ret_extent != rank)\n-\t    runtime_error (\"Incorrect extent in return value of\"\n-\t\t\t   \" MINLOC intrnisic: is %ld, should be %ld\",\n-\t\t\t   (long int) ret_extent, (long int) rank);\n-\t\n-\t  mask_rank = GFC_DESCRIPTOR_RANK (mask);\n-\t  if (rank != mask_rank)\n-\t    runtime_error (\"rank of MASK argument in MINLOC intrnisic\"\n-\t                   \"should be %ld, is %ld\", (long int) rank,\n-\t\t\t   (long int) mask_rank);\n-\n-\t  for (n=0; n<rank; n++)\n-\t    {\n-\t      array_extent = GFC_DESCRIPTOR_EXTENT(array,n);\n-\t      mask_extent = GFC_DESCRIPTOR_EXTENT(mask,n);\n-\t      if (array_extent != mask_extent)\n-\t\truntime_error (\"Incorrect extent in MASK argument of\"\n-\t\t\t       \" MINLOC intrinsic in dimension %ld:\"\n-\t\t\t       \" is %ld, should be %ld\", (long int) n + 1,\n-\t\t\t       (long int) mask_extent, (long int) array_extent);\n-\t    }\n+\n+\t  bounds_iforeach_return ((array_t *) retarray, (array_t *) array,\n+\t\t\t\t  \"MINLOC\");\n+\t  bounds_equal_extents ((array_t *) mask, (array_t *) array,\n+\t\t\t\t  \"MASK argument\", \"MINLOC\");\n \t}\n     }\n \n@@ -340,22 +300,10 @@ sminloc0_4_i2 (gfc_array_i4 * const restrict retarray,\n       retarray->offset = 0;\n       retarray->data = internal_malloc_size (sizeof (GFC_INTEGER_4) * rank);\n     }\n-  else\n+  else if (unlikely (compile_options.bounds_check))\n     {\n-      if (unlikely (compile_options.bounds_check))\n-\t{\n-\t  int ret_rank;\n-\t  index_type ret_extent;\n-\n-\t  ret_rank = GFC_DESCRIPTOR_RANK (retarray);\n-\t  if (ret_rank != 1)\n-\t    runtime_error (\"rank of return array in MINLOC intrinsic\"\n-\t\t\t   \" should be 1, is %ld\", (long int) ret_rank);\n-\n-\t  ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,0);\n-\t    if (ret_extent != rank)\n-\t      runtime_error (\"dimension of return array incorrect\");\n-\t}\n+       bounds_iforeach_return ((array_t *) retarray, (array_t *) array,\n+\t\t\t       \"MINLOC\");\n     }\n \n   dstride = GFC_DESCRIPTOR_STRIDE(retarray,0);"}, {"sha": "938d2e482087f59b26d1e24a90121835a12ea1df", "filename": "libgfortran/generated/minloc0_4_i4.c", "status": "modified", "additions": 10, "deletions": 62, "changes": 72, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/16bff92192676901670042cdce3fbd5f9c928fc8/libgfortran%2Fgenerated%2Fminloc0_4_i4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/16bff92192676901670042cdce3fbd5f9c928fc8/libgfortran%2Fgenerated%2Fminloc0_4_i4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminloc0_4_i4.c?ref=16bff92192676901670042cdce3fbd5f9c928fc8", "patch": "@@ -63,21 +63,8 @@ minloc0_4_i4 (gfc_array_i4 * const restrict retarray,\n   else\n     {\n       if (unlikely (compile_options.bounds_check))\n-\t{\n-\t  int ret_rank;\n-\t  index_type ret_extent;\n-\n-\t  ret_rank = GFC_DESCRIPTOR_RANK (retarray);\n-\t  if (ret_rank != 1)\n-\t    runtime_error (\"rank of return array in MINLOC intrinsic\"\n-\t\t\t   \" should be 1, is %ld\", (long int) ret_rank);\n-\n-\t  ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,0);\n-\t  if (ret_extent != rank)\n-\t    runtime_error (\"Incorrect extent in return value of\"\n-\t\t\t   \" MINLOC intrnisic: is %ld, should be %ld\",\n-\t\t\t   (long int) ret_extent, (long int) rank);\n-\t}\n+        bounds_iforeach_return ((array_t *) retarray, (array_t *) array,\n+\t                        \"MINLOC\");\n     }\n \n   dstride = GFC_DESCRIPTOR_STRIDE(retarray,0);\n@@ -186,38 +173,11 @@ mminloc0_4_i4 (gfc_array_i4 * const restrict retarray,\n     {\n       if (unlikely (compile_options.bounds_check))\n \t{\n-\t  int ret_rank, mask_rank;\n-\t  index_type ret_extent;\n-\t  int n;\n-\t  index_type array_extent, mask_extent;\n-\n-\t  ret_rank = GFC_DESCRIPTOR_RANK (retarray);\n-\t  if (ret_rank != 1)\n-\t    runtime_error (\"rank of return array in MINLOC intrinsic\"\n-\t\t\t   \" should be 1, is %ld\", (long int) ret_rank);\n-\n-\t  ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,0);\n-\t  if (ret_extent != rank)\n-\t    runtime_error (\"Incorrect extent in return value of\"\n-\t\t\t   \" MINLOC intrnisic: is %ld, should be %ld\",\n-\t\t\t   (long int) ret_extent, (long int) rank);\n-\t\n-\t  mask_rank = GFC_DESCRIPTOR_RANK (mask);\n-\t  if (rank != mask_rank)\n-\t    runtime_error (\"rank of MASK argument in MINLOC intrnisic\"\n-\t                   \"should be %ld, is %ld\", (long int) rank,\n-\t\t\t   (long int) mask_rank);\n-\n-\t  for (n=0; n<rank; n++)\n-\t    {\n-\t      array_extent = GFC_DESCRIPTOR_EXTENT(array,n);\n-\t      mask_extent = GFC_DESCRIPTOR_EXTENT(mask,n);\n-\t      if (array_extent != mask_extent)\n-\t\truntime_error (\"Incorrect extent in MASK argument of\"\n-\t\t\t       \" MINLOC intrinsic in dimension %ld:\"\n-\t\t\t       \" is %ld, should be %ld\", (long int) n + 1,\n-\t\t\t       (long int) mask_extent, (long int) array_extent);\n-\t    }\n+\n+\t  bounds_iforeach_return ((array_t *) retarray, (array_t *) array,\n+\t\t\t\t  \"MINLOC\");\n+\t  bounds_equal_extents ((array_t *) mask, (array_t *) array,\n+\t\t\t\t  \"MASK argument\", \"MINLOC\");\n \t}\n     }\n \n@@ -340,22 +300,10 @@ sminloc0_4_i4 (gfc_array_i4 * const restrict retarray,\n       retarray->offset = 0;\n       retarray->data = internal_malloc_size (sizeof (GFC_INTEGER_4) * rank);\n     }\n-  else\n+  else if (unlikely (compile_options.bounds_check))\n     {\n-      if (unlikely (compile_options.bounds_check))\n-\t{\n-\t  int ret_rank;\n-\t  index_type ret_extent;\n-\n-\t  ret_rank = GFC_DESCRIPTOR_RANK (retarray);\n-\t  if (ret_rank != 1)\n-\t    runtime_error (\"rank of return array in MINLOC intrinsic\"\n-\t\t\t   \" should be 1, is %ld\", (long int) ret_rank);\n-\n-\t  ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,0);\n-\t    if (ret_extent != rank)\n-\t      runtime_error (\"dimension of return array incorrect\");\n-\t}\n+       bounds_iforeach_return ((array_t *) retarray, (array_t *) array,\n+\t\t\t       \"MINLOC\");\n     }\n \n   dstride = GFC_DESCRIPTOR_STRIDE(retarray,0);"}, {"sha": "b64024e45fcb9e8e51fa15d5dd4b9d93471c6d7a", "filename": "libgfortran/generated/minloc0_4_i8.c", "status": "modified", "additions": 10, "deletions": 62, "changes": 72, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/16bff92192676901670042cdce3fbd5f9c928fc8/libgfortran%2Fgenerated%2Fminloc0_4_i8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/16bff92192676901670042cdce3fbd5f9c928fc8/libgfortran%2Fgenerated%2Fminloc0_4_i8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminloc0_4_i8.c?ref=16bff92192676901670042cdce3fbd5f9c928fc8", "patch": "@@ -63,21 +63,8 @@ minloc0_4_i8 (gfc_array_i4 * const restrict retarray,\n   else\n     {\n       if (unlikely (compile_options.bounds_check))\n-\t{\n-\t  int ret_rank;\n-\t  index_type ret_extent;\n-\n-\t  ret_rank = GFC_DESCRIPTOR_RANK (retarray);\n-\t  if (ret_rank != 1)\n-\t    runtime_error (\"rank of return array in MINLOC intrinsic\"\n-\t\t\t   \" should be 1, is %ld\", (long int) ret_rank);\n-\n-\t  ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,0);\n-\t  if (ret_extent != rank)\n-\t    runtime_error (\"Incorrect extent in return value of\"\n-\t\t\t   \" MINLOC intrnisic: is %ld, should be %ld\",\n-\t\t\t   (long int) ret_extent, (long int) rank);\n-\t}\n+        bounds_iforeach_return ((array_t *) retarray, (array_t *) array,\n+\t                        \"MINLOC\");\n     }\n \n   dstride = GFC_DESCRIPTOR_STRIDE(retarray,0);\n@@ -186,38 +173,11 @@ mminloc0_4_i8 (gfc_array_i4 * const restrict retarray,\n     {\n       if (unlikely (compile_options.bounds_check))\n \t{\n-\t  int ret_rank, mask_rank;\n-\t  index_type ret_extent;\n-\t  int n;\n-\t  index_type array_extent, mask_extent;\n-\n-\t  ret_rank = GFC_DESCRIPTOR_RANK (retarray);\n-\t  if (ret_rank != 1)\n-\t    runtime_error (\"rank of return array in MINLOC intrinsic\"\n-\t\t\t   \" should be 1, is %ld\", (long int) ret_rank);\n-\n-\t  ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,0);\n-\t  if (ret_extent != rank)\n-\t    runtime_error (\"Incorrect extent in return value of\"\n-\t\t\t   \" MINLOC intrnisic: is %ld, should be %ld\",\n-\t\t\t   (long int) ret_extent, (long int) rank);\n-\t\n-\t  mask_rank = GFC_DESCRIPTOR_RANK (mask);\n-\t  if (rank != mask_rank)\n-\t    runtime_error (\"rank of MASK argument in MINLOC intrnisic\"\n-\t                   \"should be %ld, is %ld\", (long int) rank,\n-\t\t\t   (long int) mask_rank);\n-\n-\t  for (n=0; n<rank; n++)\n-\t    {\n-\t      array_extent = GFC_DESCRIPTOR_EXTENT(array,n);\n-\t      mask_extent = GFC_DESCRIPTOR_EXTENT(mask,n);\n-\t      if (array_extent != mask_extent)\n-\t\truntime_error (\"Incorrect extent in MASK argument of\"\n-\t\t\t       \" MINLOC intrinsic in dimension %ld:\"\n-\t\t\t       \" is %ld, should be %ld\", (long int) n + 1,\n-\t\t\t       (long int) mask_extent, (long int) array_extent);\n-\t    }\n+\n+\t  bounds_iforeach_return ((array_t *) retarray, (array_t *) array,\n+\t\t\t\t  \"MINLOC\");\n+\t  bounds_equal_extents ((array_t *) mask, (array_t *) array,\n+\t\t\t\t  \"MASK argument\", \"MINLOC\");\n \t}\n     }\n \n@@ -340,22 +300,10 @@ sminloc0_4_i8 (gfc_array_i4 * const restrict retarray,\n       retarray->offset = 0;\n       retarray->data = internal_malloc_size (sizeof (GFC_INTEGER_4) * rank);\n     }\n-  else\n+  else if (unlikely (compile_options.bounds_check))\n     {\n-      if (unlikely (compile_options.bounds_check))\n-\t{\n-\t  int ret_rank;\n-\t  index_type ret_extent;\n-\n-\t  ret_rank = GFC_DESCRIPTOR_RANK (retarray);\n-\t  if (ret_rank != 1)\n-\t    runtime_error (\"rank of return array in MINLOC intrinsic\"\n-\t\t\t   \" should be 1, is %ld\", (long int) ret_rank);\n-\n-\t  ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,0);\n-\t    if (ret_extent != rank)\n-\t      runtime_error (\"dimension of return array incorrect\");\n-\t}\n+       bounds_iforeach_return ((array_t *) retarray, (array_t *) array,\n+\t\t\t       \"MINLOC\");\n     }\n \n   dstride = GFC_DESCRIPTOR_STRIDE(retarray,0);"}, {"sha": "e130e21d3c22f797936cb175974af76b03c9c9c8", "filename": "libgfortran/generated/minloc0_4_r10.c", "status": "modified", "additions": 10, "deletions": 62, "changes": 72, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/16bff92192676901670042cdce3fbd5f9c928fc8/libgfortran%2Fgenerated%2Fminloc0_4_r10.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/16bff92192676901670042cdce3fbd5f9c928fc8/libgfortran%2Fgenerated%2Fminloc0_4_r10.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminloc0_4_r10.c?ref=16bff92192676901670042cdce3fbd5f9c928fc8", "patch": "@@ -63,21 +63,8 @@ minloc0_4_r10 (gfc_array_i4 * const restrict retarray,\n   else\n     {\n       if (unlikely (compile_options.bounds_check))\n-\t{\n-\t  int ret_rank;\n-\t  index_type ret_extent;\n-\n-\t  ret_rank = GFC_DESCRIPTOR_RANK (retarray);\n-\t  if (ret_rank != 1)\n-\t    runtime_error (\"rank of return array in MINLOC intrinsic\"\n-\t\t\t   \" should be 1, is %ld\", (long int) ret_rank);\n-\n-\t  ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,0);\n-\t  if (ret_extent != rank)\n-\t    runtime_error (\"Incorrect extent in return value of\"\n-\t\t\t   \" MINLOC intrnisic: is %ld, should be %ld\",\n-\t\t\t   (long int) ret_extent, (long int) rank);\n-\t}\n+        bounds_iforeach_return ((array_t *) retarray, (array_t *) array,\n+\t                        \"MINLOC\");\n     }\n \n   dstride = GFC_DESCRIPTOR_STRIDE(retarray,0);\n@@ -186,38 +173,11 @@ mminloc0_4_r10 (gfc_array_i4 * const restrict retarray,\n     {\n       if (unlikely (compile_options.bounds_check))\n \t{\n-\t  int ret_rank, mask_rank;\n-\t  index_type ret_extent;\n-\t  int n;\n-\t  index_type array_extent, mask_extent;\n-\n-\t  ret_rank = GFC_DESCRIPTOR_RANK (retarray);\n-\t  if (ret_rank != 1)\n-\t    runtime_error (\"rank of return array in MINLOC intrinsic\"\n-\t\t\t   \" should be 1, is %ld\", (long int) ret_rank);\n-\n-\t  ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,0);\n-\t  if (ret_extent != rank)\n-\t    runtime_error (\"Incorrect extent in return value of\"\n-\t\t\t   \" MINLOC intrnisic: is %ld, should be %ld\",\n-\t\t\t   (long int) ret_extent, (long int) rank);\n-\t\n-\t  mask_rank = GFC_DESCRIPTOR_RANK (mask);\n-\t  if (rank != mask_rank)\n-\t    runtime_error (\"rank of MASK argument in MINLOC intrnisic\"\n-\t                   \"should be %ld, is %ld\", (long int) rank,\n-\t\t\t   (long int) mask_rank);\n-\n-\t  for (n=0; n<rank; n++)\n-\t    {\n-\t      array_extent = GFC_DESCRIPTOR_EXTENT(array,n);\n-\t      mask_extent = GFC_DESCRIPTOR_EXTENT(mask,n);\n-\t      if (array_extent != mask_extent)\n-\t\truntime_error (\"Incorrect extent in MASK argument of\"\n-\t\t\t       \" MINLOC intrinsic in dimension %ld:\"\n-\t\t\t       \" is %ld, should be %ld\", (long int) n + 1,\n-\t\t\t       (long int) mask_extent, (long int) array_extent);\n-\t    }\n+\n+\t  bounds_iforeach_return ((array_t *) retarray, (array_t *) array,\n+\t\t\t\t  \"MINLOC\");\n+\t  bounds_equal_extents ((array_t *) mask, (array_t *) array,\n+\t\t\t\t  \"MASK argument\", \"MINLOC\");\n \t}\n     }\n \n@@ -340,22 +300,10 @@ sminloc0_4_r10 (gfc_array_i4 * const restrict retarray,\n       retarray->offset = 0;\n       retarray->data = internal_malloc_size (sizeof (GFC_INTEGER_4) * rank);\n     }\n-  else\n+  else if (unlikely (compile_options.bounds_check))\n     {\n-      if (unlikely (compile_options.bounds_check))\n-\t{\n-\t  int ret_rank;\n-\t  index_type ret_extent;\n-\n-\t  ret_rank = GFC_DESCRIPTOR_RANK (retarray);\n-\t  if (ret_rank != 1)\n-\t    runtime_error (\"rank of return array in MINLOC intrinsic\"\n-\t\t\t   \" should be 1, is %ld\", (long int) ret_rank);\n-\n-\t  ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,0);\n-\t    if (ret_extent != rank)\n-\t      runtime_error (\"dimension of return array incorrect\");\n-\t}\n+       bounds_iforeach_return ((array_t *) retarray, (array_t *) array,\n+\t\t\t       \"MINLOC\");\n     }\n \n   dstride = GFC_DESCRIPTOR_STRIDE(retarray,0);"}, {"sha": "45ccb614ecb88cb425922c589144ba01cbd43d13", "filename": "libgfortran/generated/minloc0_4_r16.c", "status": "modified", "additions": 10, "deletions": 62, "changes": 72, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/16bff92192676901670042cdce3fbd5f9c928fc8/libgfortran%2Fgenerated%2Fminloc0_4_r16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/16bff92192676901670042cdce3fbd5f9c928fc8/libgfortran%2Fgenerated%2Fminloc0_4_r16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminloc0_4_r16.c?ref=16bff92192676901670042cdce3fbd5f9c928fc8", "patch": "@@ -63,21 +63,8 @@ minloc0_4_r16 (gfc_array_i4 * const restrict retarray,\n   else\n     {\n       if (unlikely (compile_options.bounds_check))\n-\t{\n-\t  int ret_rank;\n-\t  index_type ret_extent;\n-\n-\t  ret_rank = GFC_DESCRIPTOR_RANK (retarray);\n-\t  if (ret_rank != 1)\n-\t    runtime_error (\"rank of return array in MINLOC intrinsic\"\n-\t\t\t   \" should be 1, is %ld\", (long int) ret_rank);\n-\n-\t  ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,0);\n-\t  if (ret_extent != rank)\n-\t    runtime_error (\"Incorrect extent in return value of\"\n-\t\t\t   \" MINLOC intrnisic: is %ld, should be %ld\",\n-\t\t\t   (long int) ret_extent, (long int) rank);\n-\t}\n+        bounds_iforeach_return ((array_t *) retarray, (array_t *) array,\n+\t                        \"MINLOC\");\n     }\n \n   dstride = GFC_DESCRIPTOR_STRIDE(retarray,0);\n@@ -186,38 +173,11 @@ mminloc0_4_r16 (gfc_array_i4 * const restrict retarray,\n     {\n       if (unlikely (compile_options.bounds_check))\n \t{\n-\t  int ret_rank, mask_rank;\n-\t  index_type ret_extent;\n-\t  int n;\n-\t  index_type array_extent, mask_extent;\n-\n-\t  ret_rank = GFC_DESCRIPTOR_RANK (retarray);\n-\t  if (ret_rank != 1)\n-\t    runtime_error (\"rank of return array in MINLOC intrinsic\"\n-\t\t\t   \" should be 1, is %ld\", (long int) ret_rank);\n-\n-\t  ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,0);\n-\t  if (ret_extent != rank)\n-\t    runtime_error (\"Incorrect extent in return value of\"\n-\t\t\t   \" MINLOC intrnisic: is %ld, should be %ld\",\n-\t\t\t   (long int) ret_extent, (long int) rank);\n-\t\n-\t  mask_rank = GFC_DESCRIPTOR_RANK (mask);\n-\t  if (rank != mask_rank)\n-\t    runtime_error (\"rank of MASK argument in MINLOC intrnisic\"\n-\t                   \"should be %ld, is %ld\", (long int) rank,\n-\t\t\t   (long int) mask_rank);\n-\n-\t  for (n=0; n<rank; n++)\n-\t    {\n-\t      array_extent = GFC_DESCRIPTOR_EXTENT(array,n);\n-\t      mask_extent = GFC_DESCRIPTOR_EXTENT(mask,n);\n-\t      if (array_extent != mask_extent)\n-\t\truntime_error (\"Incorrect extent in MASK argument of\"\n-\t\t\t       \" MINLOC intrinsic in dimension %ld:\"\n-\t\t\t       \" is %ld, should be %ld\", (long int) n + 1,\n-\t\t\t       (long int) mask_extent, (long int) array_extent);\n-\t    }\n+\n+\t  bounds_iforeach_return ((array_t *) retarray, (array_t *) array,\n+\t\t\t\t  \"MINLOC\");\n+\t  bounds_equal_extents ((array_t *) mask, (array_t *) array,\n+\t\t\t\t  \"MASK argument\", \"MINLOC\");\n \t}\n     }\n \n@@ -340,22 +300,10 @@ sminloc0_4_r16 (gfc_array_i4 * const restrict retarray,\n       retarray->offset = 0;\n       retarray->data = internal_malloc_size (sizeof (GFC_INTEGER_4) * rank);\n     }\n-  else\n+  else if (unlikely (compile_options.bounds_check))\n     {\n-      if (unlikely (compile_options.bounds_check))\n-\t{\n-\t  int ret_rank;\n-\t  index_type ret_extent;\n-\n-\t  ret_rank = GFC_DESCRIPTOR_RANK (retarray);\n-\t  if (ret_rank != 1)\n-\t    runtime_error (\"rank of return array in MINLOC intrinsic\"\n-\t\t\t   \" should be 1, is %ld\", (long int) ret_rank);\n-\n-\t  ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,0);\n-\t    if (ret_extent != rank)\n-\t      runtime_error (\"dimension of return array incorrect\");\n-\t}\n+       bounds_iforeach_return ((array_t *) retarray, (array_t *) array,\n+\t\t\t       \"MINLOC\");\n     }\n \n   dstride = GFC_DESCRIPTOR_STRIDE(retarray,0);"}, {"sha": "6d8f74e29914026e25327a9d4a7b39fc4f857cdd", "filename": "libgfortran/generated/minloc0_4_r4.c", "status": "modified", "additions": 10, "deletions": 62, "changes": 72, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/16bff92192676901670042cdce3fbd5f9c928fc8/libgfortran%2Fgenerated%2Fminloc0_4_r4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/16bff92192676901670042cdce3fbd5f9c928fc8/libgfortran%2Fgenerated%2Fminloc0_4_r4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminloc0_4_r4.c?ref=16bff92192676901670042cdce3fbd5f9c928fc8", "patch": "@@ -63,21 +63,8 @@ minloc0_4_r4 (gfc_array_i4 * const restrict retarray,\n   else\n     {\n       if (unlikely (compile_options.bounds_check))\n-\t{\n-\t  int ret_rank;\n-\t  index_type ret_extent;\n-\n-\t  ret_rank = GFC_DESCRIPTOR_RANK (retarray);\n-\t  if (ret_rank != 1)\n-\t    runtime_error (\"rank of return array in MINLOC intrinsic\"\n-\t\t\t   \" should be 1, is %ld\", (long int) ret_rank);\n-\n-\t  ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,0);\n-\t  if (ret_extent != rank)\n-\t    runtime_error (\"Incorrect extent in return value of\"\n-\t\t\t   \" MINLOC intrnisic: is %ld, should be %ld\",\n-\t\t\t   (long int) ret_extent, (long int) rank);\n-\t}\n+        bounds_iforeach_return ((array_t *) retarray, (array_t *) array,\n+\t                        \"MINLOC\");\n     }\n \n   dstride = GFC_DESCRIPTOR_STRIDE(retarray,0);\n@@ -186,38 +173,11 @@ mminloc0_4_r4 (gfc_array_i4 * const restrict retarray,\n     {\n       if (unlikely (compile_options.bounds_check))\n \t{\n-\t  int ret_rank, mask_rank;\n-\t  index_type ret_extent;\n-\t  int n;\n-\t  index_type array_extent, mask_extent;\n-\n-\t  ret_rank = GFC_DESCRIPTOR_RANK (retarray);\n-\t  if (ret_rank != 1)\n-\t    runtime_error (\"rank of return array in MINLOC intrinsic\"\n-\t\t\t   \" should be 1, is %ld\", (long int) ret_rank);\n-\n-\t  ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,0);\n-\t  if (ret_extent != rank)\n-\t    runtime_error (\"Incorrect extent in return value of\"\n-\t\t\t   \" MINLOC intrnisic: is %ld, should be %ld\",\n-\t\t\t   (long int) ret_extent, (long int) rank);\n-\t\n-\t  mask_rank = GFC_DESCRIPTOR_RANK (mask);\n-\t  if (rank != mask_rank)\n-\t    runtime_error (\"rank of MASK argument in MINLOC intrnisic\"\n-\t                   \"should be %ld, is %ld\", (long int) rank,\n-\t\t\t   (long int) mask_rank);\n-\n-\t  for (n=0; n<rank; n++)\n-\t    {\n-\t      array_extent = GFC_DESCRIPTOR_EXTENT(array,n);\n-\t      mask_extent = GFC_DESCRIPTOR_EXTENT(mask,n);\n-\t      if (array_extent != mask_extent)\n-\t\truntime_error (\"Incorrect extent in MASK argument of\"\n-\t\t\t       \" MINLOC intrinsic in dimension %ld:\"\n-\t\t\t       \" is %ld, should be %ld\", (long int) n + 1,\n-\t\t\t       (long int) mask_extent, (long int) array_extent);\n-\t    }\n+\n+\t  bounds_iforeach_return ((array_t *) retarray, (array_t *) array,\n+\t\t\t\t  \"MINLOC\");\n+\t  bounds_equal_extents ((array_t *) mask, (array_t *) array,\n+\t\t\t\t  \"MASK argument\", \"MINLOC\");\n \t}\n     }\n \n@@ -340,22 +300,10 @@ sminloc0_4_r4 (gfc_array_i4 * const restrict retarray,\n       retarray->offset = 0;\n       retarray->data = internal_malloc_size (sizeof (GFC_INTEGER_4) * rank);\n     }\n-  else\n+  else if (unlikely (compile_options.bounds_check))\n     {\n-      if (unlikely (compile_options.bounds_check))\n-\t{\n-\t  int ret_rank;\n-\t  index_type ret_extent;\n-\n-\t  ret_rank = GFC_DESCRIPTOR_RANK (retarray);\n-\t  if (ret_rank != 1)\n-\t    runtime_error (\"rank of return array in MINLOC intrinsic\"\n-\t\t\t   \" should be 1, is %ld\", (long int) ret_rank);\n-\n-\t  ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,0);\n-\t    if (ret_extent != rank)\n-\t      runtime_error (\"dimension of return array incorrect\");\n-\t}\n+       bounds_iforeach_return ((array_t *) retarray, (array_t *) array,\n+\t\t\t       \"MINLOC\");\n     }\n \n   dstride = GFC_DESCRIPTOR_STRIDE(retarray,0);"}, {"sha": "eb01e685620011f66437a2e155693d157d270581", "filename": "libgfortran/generated/minloc0_4_r8.c", "status": "modified", "additions": 10, "deletions": 62, "changes": 72, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/16bff92192676901670042cdce3fbd5f9c928fc8/libgfortran%2Fgenerated%2Fminloc0_4_r8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/16bff92192676901670042cdce3fbd5f9c928fc8/libgfortran%2Fgenerated%2Fminloc0_4_r8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminloc0_4_r8.c?ref=16bff92192676901670042cdce3fbd5f9c928fc8", "patch": "@@ -63,21 +63,8 @@ minloc0_4_r8 (gfc_array_i4 * const restrict retarray,\n   else\n     {\n       if (unlikely (compile_options.bounds_check))\n-\t{\n-\t  int ret_rank;\n-\t  index_type ret_extent;\n-\n-\t  ret_rank = GFC_DESCRIPTOR_RANK (retarray);\n-\t  if (ret_rank != 1)\n-\t    runtime_error (\"rank of return array in MINLOC intrinsic\"\n-\t\t\t   \" should be 1, is %ld\", (long int) ret_rank);\n-\n-\t  ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,0);\n-\t  if (ret_extent != rank)\n-\t    runtime_error (\"Incorrect extent in return value of\"\n-\t\t\t   \" MINLOC intrnisic: is %ld, should be %ld\",\n-\t\t\t   (long int) ret_extent, (long int) rank);\n-\t}\n+        bounds_iforeach_return ((array_t *) retarray, (array_t *) array,\n+\t                        \"MINLOC\");\n     }\n \n   dstride = GFC_DESCRIPTOR_STRIDE(retarray,0);\n@@ -186,38 +173,11 @@ mminloc0_4_r8 (gfc_array_i4 * const restrict retarray,\n     {\n       if (unlikely (compile_options.bounds_check))\n \t{\n-\t  int ret_rank, mask_rank;\n-\t  index_type ret_extent;\n-\t  int n;\n-\t  index_type array_extent, mask_extent;\n-\n-\t  ret_rank = GFC_DESCRIPTOR_RANK (retarray);\n-\t  if (ret_rank != 1)\n-\t    runtime_error (\"rank of return array in MINLOC intrinsic\"\n-\t\t\t   \" should be 1, is %ld\", (long int) ret_rank);\n-\n-\t  ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,0);\n-\t  if (ret_extent != rank)\n-\t    runtime_error (\"Incorrect extent in return value of\"\n-\t\t\t   \" MINLOC intrnisic: is %ld, should be %ld\",\n-\t\t\t   (long int) ret_extent, (long int) rank);\n-\t\n-\t  mask_rank = GFC_DESCRIPTOR_RANK (mask);\n-\t  if (rank != mask_rank)\n-\t    runtime_error (\"rank of MASK argument in MINLOC intrnisic\"\n-\t                   \"should be %ld, is %ld\", (long int) rank,\n-\t\t\t   (long int) mask_rank);\n-\n-\t  for (n=0; n<rank; n++)\n-\t    {\n-\t      array_extent = GFC_DESCRIPTOR_EXTENT(array,n);\n-\t      mask_extent = GFC_DESCRIPTOR_EXTENT(mask,n);\n-\t      if (array_extent != mask_extent)\n-\t\truntime_error (\"Incorrect extent in MASK argument of\"\n-\t\t\t       \" MINLOC intrinsic in dimension %ld:\"\n-\t\t\t       \" is %ld, should be %ld\", (long int) n + 1,\n-\t\t\t       (long int) mask_extent, (long int) array_extent);\n-\t    }\n+\n+\t  bounds_iforeach_return ((array_t *) retarray, (array_t *) array,\n+\t\t\t\t  \"MINLOC\");\n+\t  bounds_equal_extents ((array_t *) mask, (array_t *) array,\n+\t\t\t\t  \"MASK argument\", \"MINLOC\");\n \t}\n     }\n \n@@ -340,22 +300,10 @@ sminloc0_4_r8 (gfc_array_i4 * const restrict retarray,\n       retarray->offset = 0;\n       retarray->data = internal_malloc_size (sizeof (GFC_INTEGER_4) * rank);\n     }\n-  else\n+  else if (unlikely (compile_options.bounds_check))\n     {\n-      if (unlikely (compile_options.bounds_check))\n-\t{\n-\t  int ret_rank;\n-\t  index_type ret_extent;\n-\n-\t  ret_rank = GFC_DESCRIPTOR_RANK (retarray);\n-\t  if (ret_rank != 1)\n-\t    runtime_error (\"rank of return array in MINLOC intrinsic\"\n-\t\t\t   \" should be 1, is %ld\", (long int) ret_rank);\n-\n-\t  ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,0);\n-\t    if (ret_extent != rank)\n-\t      runtime_error (\"dimension of return array incorrect\");\n-\t}\n+       bounds_iforeach_return ((array_t *) retarray, (array_t *) array,\n+\t\t\t       \"MINLOC\");\n     }\n \n   dstride = GFC_DESCRIPTOR_STRIDE(retarray,0);"}, {"sha": "d4924e48f19e81493f318dede233d44e55211176", "filename": "libgfortran/generated/minloc0_8_i1.c", "status": "modified", "additions": 10, "deletions": 62, "changes": 72, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/16bff92192676901670042cdce3fbd5f9c928fc8/libgfortran%2Fgenerated%2Fminloc0_8_i1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/16bff92192676901670042cdce3fbd5f9c928fc8/libgfortran%2Fgenerated%2Fminloc0_8_i1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminloc0_8_i1.c?ref=16bff92192676901670042cdce3fbd5f9c928fc8", "patch": "@@ -63,21 +63,8 @@ minloc0_8_i1 (gfc_array_i8 * const restrict retarray,\n   else\n     {\n       if (unlikely (compile_options.bounds_check))\n-\t{\n-\t  int ret_rank;\n-\t  index_type ret_extent;\n-\n-\t  ret_rank = GFC_DESCRIPTOR_RANK (retarray);\n-\t  if (ret_rank != 1)\n-\t    runtime_error (\"rank of return array in MINLOC intrinsic\"\n-\t\t\t   \" should be 1, is %ld\", (long int) ret_rank);\n-\n-\t  ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,0);\n-\t  if (ret_extent != rank)\n-\t    runtime_error (\"Incorrect extent in return value of\"\n-\t\t\t   \" MINLOC intrnisic: is %ld, should be %ld\",\n-\t\t\t   (long int) ret_extent, (long int) rank);\n-\t}\n+        bounds_iforeach_return ((array_t *) retarray, (array_t *) array,\n+\t                        \"MINLOC\");\n     }\n \n   dstride = GFC_DESCRIPTOR_STRIDE(retarray,0);\n@@ -186,38 +173,11 @@ mminloc0_8_i1 (gfc_array_i8 * const restrict retarray,\n     {\n       if (unlikely (compile_options.bounds_check))\n \t{\n-\t  int ret_rank, mask_rank;\n-\t  index_type ret_extent;\n-\t  int n;\n-\t  index_type array_extent, mask_extent;\n-\n-\t  ret_rank = GFC_DESCRIPTOR_RANK (retarray);\n-\t  if (ret_rank != 1)\n-\t    runtime_error (\"rank of return array in MINLOC intrinsic\"\n-\t\t\t   \" should be 1, is %ld\", (long int) ret_rank);\n-\n-\t  ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,0);\n-\t  if (ret_extent != rank)\n-\t    runtime_error (\"Incorrect extent in return value of\"\n-\t\t\t   \" MINLOC intrnisic: is %ld, should be %ld\",\n-\t\t\t   (long int) ret_extent, (long int) rank);\n-\t\n-\t  mask_rank = GFC_DESCRIPTOR_RANK (mask);\n-\t  if (rank != mask_rank)\n-\t    runtime_error (\"rank of MASK argument in MINLOC intrnisic\"\n-\t                   \"should be %ld, is %ld\", (long int) rank,\n-\t\t\t   (long int) mask_rank);\n-\n-\t  for (n=0; n<rank; n++)\n-\t    {\n-\t      array_extent = GFC_DESCRIPTOR_EXTENT(array,n);\n-\t      mask_extent = GFC_DESCRIPTOR_EXTENT(mask,n);\n-\t      if (array_extent != mask_extent)\n-\t\truntime_error (\"Incorrect extent in MASK argument of\"\n-\t\t\t       \" MINLOC intrinsic in dimension %ld:\"\n-\t\t\t       \" is %ld, should be %ld\", (long int) n + 1,\n-\t\t\t       (long int) mask_extent, (long int) array_extent);\n-\t    }\n+\n+\t  bounds_iforeach_return ((array_t *) retarray, (array_t *) array,\n+\t\t\t\t  \"MINLOC\");\n+\t  bounds_equal_extents ((array_t *) mask, (array_t *) array,\n+\t\t\t\t  \"MASK argument\", \"MINLOC\");\n \t}\n     }\n \n@@ -340,22 +300,10 @@ sminloc0_8_i1 (gfc_array_i8 * const restrict retarray,\n       retarray->offset = 0;\n       retarray->data = internal_malloc_size (sizeof (GFC_INTEGER_8) * rank);\n     }\n-  else\n+  else if (unlikely (compile_options.bounds_check))\n     {\n-      if (unlikely (compile_options.bounds_check))\n-\t{\n-\t  int ret_rank;\n-\t  index_type ret_extent;\n-\n-\t  ret_rank = GFC_DESCRIPTOR_RANK (retarray);\n-\t  if (ret_rank != 1)\n-\t    runtime_error (\"rank of return array in MINLOC intrinsic\"\n-\t\t\t   \" should be 1, is %ld\", (long int) ret_rank);\n-\n-\t  ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,0);\n-\t    if (ret_extent != rank)\n-\t      runtime_error (\"dimension of return array incorrect\");\n-\t}\n+       bounds_iforeach_return ((array_t *) retarray, (array_t *) array,\n+\t\t\t       \"MINLOC\");\n     }\n \n   dstride = GFC_DESCRIPTOR_STRIDE(retarray,0);"}, {"sha": "dad459a898f88907d9234aad860aa1b5d7f143d4", "filename": "libgfortran/generated/minloc0_8_i16.c", "status": "modified", "additions": 10, "deletions": 62, "changes": 72, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/16bff92192676901670042cdce3fbd5f9c928fc8/libgfortran%2Fgenerated%2Fminloc0_8_i16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/16bff92192676901670042cdce3fbd5f9c928fc8/libgfortran%2Fgenerated%2Fminloc0_8_i16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminloc0_8_i16.c?ref=16bff92192676901670042cdce3fbd5f9c928fc8", "patch": "@@ -63,21 +63,8 @@ minloc0_8_i16 (gfc_array_i8 * const restrict retarray,\n   else\n     {\n       if (unlikely (compile_options.bounds_check))\n-\t{\n-\t  int ret_rank;\n-\t  index_type ret_extent;\n-\n-\t  ret_rank = GFC_DESCRIPTOR_RANK (retarray);\n-\t  if (ret_rank != 1)\n-\t    runtime_error (\"rank of return array in MINLOC intrinsic\"\n-\t\t\t   \" should be 1, is %ld\", (long int) ret_rank);\n-\n-\t  ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,0);\n-\t  if (ret_extent != rank)\n-\t    runtime_error (\"Incorrect extent in return value of\"\n-\t\t\t   \" MINLOC intrnisic: is %ld, should be %ld\",\n-\t\t\t   (long int) ret_extent, (long int) rank);\n-\t}\n+        bounds_iforeach_return ((array_t *) retarray, (array_t *) array,\n+\t                        \"MINLOC\");\n     }\n \n   dstride = GFC_DESCRIPTOR_STRIDE(retarray,0);\n@@ -186,38 +173,11 @@ mminloc0_8_i16 (gfc_array_i8 * const restrict retarray,\n     {\n       if (unlikely (compile_options.bounds_check))\n \t{\n-\t  int ret_rank, mask_rank;\n-\t  index_type ret_extent;\n-\t  int n;\n-\t  index_type array_extent, mask_extent;\n-\n-\t  ret_rank = GFC_DESCRIPTOR_RANK (retarray);\n-\t  if (ret_rank != 1)\n-\t    runtime_error (\"rank of return array in MINLOC intrinsic\"\n-\t\t\t   \" should be 1, is %ld\", (long int) ret_rank);\n-\n-\t  ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,0);\n-\t  if (ret_extent != rank)\n-\t    runtime_error (\"Incorrect extent in return value of\"\n-\t\t\t   \" MINLOC intrnisic: is %ld, should be %ld\",\n-\t\t\t   (long int) ret_extent, (long int) rank);\n-\t\n-\t  mask_rank = GFC_DESCRIPTOR_RANK (mask);\n-\t  if (rank != mask_rank)\n-\t    runtime_error (\"rank of MASK argument in MINLOC intrnisic\"\n-\t                   \"should be %ld, is %ld\", (long int) rank,\n-\t\t\t   (long int) mask_rank);\n-\n-\t  for (n=0; n<rank; n++)\n-\t    {\n-\t      array_extent = GFC_DESCRIPTOR_EXTENT(array,n);\n-\t      mask_extent = GFC_DESCRIPTOR_EXTENT(mask,n);\n-\t      if (array_extent != mask_extent)\n-\t\truntime_error (\"Incorrect extent in MASK argument of\"\n-\t\t\t       \" MINLOC intrinsic in dimension %ld:\"\n-\t\t\t       \" is %ld, should be %ld\", (long int) n + 1,\n-\t\t\t       (long int) mask_extent, (long int) array_extent);\n-\t    }\n+\n+\t  bounds_iforeach_return ((array_t *) retarray, (array_t *) array,\n+\t\t\t\t  \"MINLOC\");\n+\t  bounds_equal_extents ((array_t *) mask, (array_t *) array,\n+\t\t\t\t  \"MASK argument\", \"MINLOC\");\n \t}\n     }\n \n@@ -340,22 +300,10 @@ sminloc0_8_i16 (gfc_array_i8 * const restrict retarray,\n       retarray->offset = 0;\n       retarray->data = internal_malloc_size (sizeof (GFC_INTEGER_8) * rank);\n     }\n-  else\n+  else if (unlikely (compile_options.bounds_check))\n     {\n-      if (unlikely (compile_options.bounds_check))\n-\t{\n-\t  int ret_rank;\n-\t  index_type ret_extent;\n-\n-\t  ret_rank = GFC_DESCRIPTOR_RANK (retarray);\n-\t  if (ret_rank != 1)\n-\t    runtime_error (\"rank of return array in MINLOC intrinsic\"\n-\t\t\t   \" should be 1, is %ld\", (long int) ret_rank);\n-\n-\t  ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,0);\n-\t    if (ret_extent != rank)\n-\t      runtime_error (\"dimension of return array incorrect\");\n-\t}\n+       bounds_iforeach_return ((array_t *) retarray, (array_t *) array,\n+\t\t\t       \"MINLOC\");\n     }\n \n   dstride = GFC_DESCRIPTOR_STRIDE(retarray,0);"}, {"sha": "20cb1f20b9bb2dddb9127e9b4025d4c56ae56574", "filename": "libgfortran/generated/minloc0_8_i2.c", "status": "modified", "additions": 10, "deletions": 62, "changes": 72, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/16bff92192676901670042cdce3fbd5f9c928fc8/libgfortran%2Fgenerated%2Fminloc0_8_i2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/16bff92192676901670042cdce3fbd5f9c928fc8/libgfortran%2Fgenerated%2Fminloc0_8_i2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminloc0_8_i2.c?ref=16bff92192676901670042cdce3fbd5f9c928fc8", "patch": "@@ -63,21 +63,8 @@ minloc0_8_i2 (gfc_array_i8 * const restrict retarray,\n   else\n     {\n       if (unlikely (compile_options.bounds_check))\n-\t{\n-\t  int ret_rank;\n-\t  index_type ret_extent;\n-\n-\t  ret_rank = GFC_DESCRIPTOR_RANK (retarray);\n-\t  if (ret_rank != 1)\n-\t    runtime_error (\"rank of return array in MINLOC intrinsic\"\n-\t\t\t   \" should be 1, is %ld\", (long int) ret_rank);\n-\n-\t  ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,0);\n-\t  if (ret_extent != rank)\n-\t    runtime_error (\"Incorrect extent in return value of\"\n-\t\t\t   \" MINLOC intrnisic: is %ld, should be %ld\",\n-\t\t\t   (long int) ret_extent, (long int) rank);\n-\t}\n+        bounds_iforeach_return ((array_t *) retarray, (array_t *) array,\n+\t                        \"MINLOC\");\n     }\n \n   dstride = GFC_DESCRIPTOR_STRIDE(retarray,0);\n@@ -186,38 +173,11 @@ mminloc0_8_i2 (gfc_array_i8 * const restrict retarray,\n     {\n       if (unlikely (compile_options.bounds_check))\n \t{\n-\t  int ret_rank, mask_rank;\n-\t  index_type ret_extent;\n-\t  int n;\n-\t  index_type array_extent, mask_extent;\n-\n-\t  ret_rank = GFC_DESCRIPTOR_RANK (retarray);\n-\t  if (ret_rank != 1)\n-\t    runtime_error (\"rank of return array in MINLOC intrinsic\"\n-\t\t\t   \" should be 1, is %ld\", (long int) ret_rank);\n-\n-\t  ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,0);\n-\t  if (ret_extent != rank)\n-\t    runtime_error (\"Incorrect extent in return value of\"\n-\t\t\t   \" MINLOC intrnisic: is %ld, should be %ld\",\n-\t\t\t   (long int) ret_extent, (long int) rank);\n-\t\n-\t  mask_rank = GFC_DESCRIPTOR_RANK (mask);\n-\t  if (rank != mask_rank)\n-\t    runtime_error (\"rank of MASK argument in MINLOC intrnisic\"\n-\t                   \"should be %ld, is %ld\", (long int) rank,\n-\t\t\t   (long int) mask_rank);\n-\n-\t  for (n=0; n<rank; n++)\n-\t    {\n-\t      array_extent = GFC_DESCRIPTOR_EXTENT(array,n);\n-\t      mask_extent = GFC_DESCRIPTOR_EXTENT(mask,n);\n-\t      if (array_extent != mask_extent)\n-\t\truntime_error (\"Incorrect extent in MASK argument of\"\n-\t\t\t       \" MINLOC intrinsic in dimension %ld:\"\n-\t\t\t       \" is %ld, should be %ld\", (long int) n + 1,\n-\t\t\t       (long int) mask_extent, (long int) array_extent);\n-\t    }\n+\n+\t  bounds_iforeach_return ((array_t *) retarray, (array_t *) array,\n+\t\t\t\t  \"MINLOC\");\n+\t  bounds_equal_extents ((array_t *) mask, (array_t *) array,\n+\t\t\t\t  \"MASK argument\", \"MINLOC\");\n \t}\n     }\n \n@@ -340,22 +300,10 @@ sminloc0_8_i2 (gfc_array_i8 * const restrict retarray,\n       retarray->offset = 0;\n       retarray->data = internal_malloc_size (sizeof (GFC_INTEGER_8) * rank);\n     }\n-  else\n+  else if (unlikely (compile_options.bounds_check))\n     {\n-      if (unlikely (compile_options.bounds_check))\n-\t{\n-\t  int ret_rank;\n-\t  index_type ret_extent;\n-\n-\t  ret_rank = GFC_DESCRIPTOR_RANK (retarray);\n-\t  if (ret_rank != 1)\n-\t    runtime_error (\"rank of return array in MINLOC intrinsic\"\n-\t\t\t   \" should be 1, is %ld\", (long int) ret_rank);\n-\n-\t  ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,0);\n-\t    if (ret_extent != rank)\n-\t      runtime_error (\"dimension of return array incorrect\");\n-\t}\n+       bounds_iforeach_return ((array_t *) retarray, (array_t *) array,\n+\t\t\t       \"MINLOC\");\n     }\n \n   dstride = GFC_DESCRIPTOR_STRIDE(retarray,0);"}, {"sha": "ca02f4fe379ae66fda221847b3ed5311208f676b", "filename": "libgfortran/generated/minloc0_8_i4.c", "status": "modified", "additions": 10, "deletions": 62, "changes": 72, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/16bff92192676901670042cdce3fbd5f9c928fc8/libgfortran%2Fgenerated%2Fminloc0_8_i4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/16bff92192676901670042cdce3fbd5f9c928fc8/libgfortran%2Fgenerated%2Fminloc0_8_i4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminloc0_8_i4.c?ref=16bff92192676901670042cdce3fbd5f9c928fc8", "patch": "@@ -63,21 +63,8 @@ minloc0_8_i4 (gfc_array_i8 * const restrict retarray,\n   else\n     {\n       if (unlikely (compile_options.bounds_check))\n-\t{\n-\t  int ret_rank;\n-\t  index_type ret_extent;\n-\n-\t  ret_rank = GFC_DESCRIPTOR_RANK (retarray);\n-\t  if (ret_rank != 1)\n-\t    runtime_error (\"rank of return array in MINLOC intrinsic\"\n-\t\t\t   \" should be 1, is %ld\", (long int) ret_rank);\n-\n-\t  ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,0);\n-\t  if (ret_extent != rank)\n-\t    runtime_error (\"Incorrect extent in return value of\"\n-\t\t\t   \" MINLOC intrnisic: is %ld, should be %ld\",\n-\t\t\t   (long int) ret_extent, (long int) rank);\n-\t}\n+        bounds_iforeach_return ((array_t *) retarray, (array_t *) array,\n+\t                        \"MINLOC\");\n     }\n \n   dstride = GFC_DESCRIPTOR_STRIDE(retarray,0);\n@@ -186,38 +173,11 @@ mminloc0_8_i4 (gfc_array_i8 * const restrict retarray,\n     {\n       if (unlikely (compile_options.bounds_check))\n \t{\n-\t  int ret_rank, mask_rank;\n-\t  index_type ret_extent;\n-\t  int n;\n-\t  index_type array_extent, mask_extent;\n-\n-\t  ret_rank = GFC_DESCRIPTOR_RANK (retarray);\n-\t  if (ret_rank != 1)\n-\t    runtime_error (\"rank of return array in MINLOC intrinsic\"\n-\t\t\t   \" should be 1, is %ld\", (long int) ret_rank);\n-\n-\t  ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,0);\n-\t  if (ret_extent != rank)\n-\t    runtime_error (\"Incorrect extent in return value of\"\n-\t\t\t   \" MINLOC intrnisic: is %ld, should be %ld\",\n-\t\t\t   (long int) ret_extent, (long int) rank);\n-\t\n-\t  mask_rank = GFC_DESCRIPTOR_RANK (mask);\n-\t  if (rank != mask_rank)\n-\t    runtime_error (\"rank of MASK argument in MINLOC intrnisic\"\n-\t                   \"should be %ld, is %ld\", (long int) rank,\n-\t\t\t   (long int) mask_rank);\n-\n-\t  for (n=0; n<rank; n++)\n-\t    {\n-\t      array_extent = GFC_DESCRIPTOR_EXTENT(array,n);\n-\t      mask_extent = GFC_DESCRIPTOR_EXTENT(mask,n);\n-\t      if (array_extent != mask_extent)\n-\t\truntime_error (\"Incorrect extent in MASK argument of\"\n-\t\t\t       \" MINLOC intrinsic in dimension %ld:\"\n-\t\t\t       \" is %ld, should be %ld\", (long int) n + 1,\n-\t\t\t       (long int) mask_extent, (long int) array_extent);\n-\t    }\n+\n+\t  bounds_iforeach_return ((array_t *) retarray, (array_t *) array,\n+\t\t\t\t  \"MINLOC\");\n+\t  bounds_equal_extents ((array_t *) mask, (array_t *) array,\n+\t\t\t\t  \"MASK argument\", \"MINLOC\");\n \t}\n     }\n \n@@ -340,22 +300,10 @@ sminloc0_8_i4 (gfc_array_i8 * const restrict retarray,\n       retarray->offset = 0;\n       retarray->data = internal_malloc_size (sizeof (GFC_INTEGER_8) * rank);\n     }\n-  else\n+  else if (unlikely (compile_options.bounds_check))\n     {\n-      if (unlikely (compile_options.bounds_check))\n-\t{\n-\t  int ret_rank;\n-\t  index_type ret_extent;\n-\n-\t  ret_rank = GFC_DESCRIPTOR_RANK (retarray);\n-\t  if (ret_rank != 1)\n-\t    runtime_error (\"rank of return array in MINLOC intrinsic\"\n-\t\t\t   \" should be 1, is %ld\", (long int) ret_rank);\n-\n-\t  ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,0);\n-\t    if (ret_extent != rank)\n-\t      runtime_error (\"dimension of return array incorrect\");\n-\t}\n+       bounds_iforeach_return ((array_t *) retarray, (array_t *) array,\n+\t\t\t       \"MINLOC\");\n     }\n \n   dstride = GFC_DESCRIPTOR_STRIDE(retarray,0);"}, {"sha": "dffaec6861b68103555c458137911392973fa61a", "filename": "libgfortran/generated/minloc0_8_i8.c", "status": "modified", "additions": 10, "deletions": 62, "changes": 72, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/16bff92192676901670042cdce3fbd5f9c928fc8/libgfortran%2Fgenerated%2Fminloc0_8_i8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/16bff92192676901670042cdce3fbd5f9c928fc8/libgfortran%2Fgenerated%2Fminloc0_8_i8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminloc0_8_i8.c?ref=16bff92192676901670042cdce3fbd5f9c928fc8", "patch": "@@ -63,21 +63,8 @@ minloc0_8_i8 (gfc_array_i8 * const restrict retarray,\n   else\n     {\n       if (unlikely (compile_options.bounds_check))\n-\t{\n-\t  int ret_rank;\n-\t  index_type ret_extent;\n-\n-\t  ret_rank = GFC_DESCRIPTOR_RANK (retarray);\n-\t  if (ret_rank != 1)\n-\t    runtime_error (\"rank of return array in MINLOC intrinsic\"\n-\t\t\t   \" should be 1, is %ld\", (long int) ret_rank);\n-\n-\t  ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,0);\n-\t  if (ret_extent != rank)\n-\t    runtime_error (\"Incorrect extent in return value of\"\n-\t\t\t   \" MINLOC intrnisic: is %ld, should be %ld\",\n-\t\t\t   (long int) ret_extent, (long int) rank);\n-\t}\n+        bounds_iforeach_return ((array_t *) retarray, (array_t *) array,\n+\t                        \"MINLOC\");\n     }\n \n   dstride = GFC_DESCRIPTOR_STRIDE(retarray,0);\n@@ -186,38 +173,11 @@ mminloc0_8_i8 (gfc_array_i8 * const restrict retarray,\n     {\n       if (unlikely (compile_options.bounds_check))\n \t{\n-\t  int ret_rank, mask_rank;\n-\t  index_type ret_extent;\n-\t  int n;\n-\t  index_type array_extent, mask_extent;\n-\n-\t  ret_rank = GFC_DESCRIPTOR_RANK (retarray);\n-\t  if (ret_rank != 1)\n-\t    runtime_error (\"rank of return array in MINLOC intrinsic\"\n-\t\t\t   \" should be 1, is %ld\", (long int) ret_rank);\n-\n-\t  ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,0);\n-\t  if (ret_extent != rank)\n-\t    runtime_error (\"Incorrect extent in return value of\"\n-\t\t\t   \" MINLOC intrnisic: is %ld, should be %ld\",\n-\t\t\t   (long int) ret_extent, (long int) rank);\n-\t\n-\t  mask_rank = GFC_DESCRIPTOR_RANK (mask);\n-\t  if (rank != mask_rank)\n-\t    runtime_error (\"rank of MASK argument in MINLOC intrnisic\"\n-\t                   \"should be %ld, is %ld\", (long int) rank,\n-\t\t\t   (long int) mask_rank);\n-\n-\t  for (n=0; n<rank; n++)\n-\t    {\n-\t      array_extent = GFC_DESCRIPTOR_EXTENT(array,n);\n-\t      mask_extent = GFC_DESCRIPTOR_EXTENT(mask,n);\n-\t      if (array_extent != mask_extent)\n-\t\truntime_error (\"Incorrect extent in MASK argument of\"\n-\t\t\t       \" MINLOC intrinsic in dimension %ld:\"\n-\t\t\t       \" is %ld, should be %ld\", (long int) n + 1,\n-\t\t\t       (long int) mask_extent, (long int) array_extent);\n-\t    }\n+\n+\t  bounds_iforeach_return ((array_t *) retarray, (array_t *) array,\n+\t\t\t\t  \"MINLOC\");\n+\t  bounds_equal_extents ((array_t *) mask, (array_t *) array,\n+\t\t\t\t  \"MASK argument\", \"MINLOC\");\n \t}\n     }\n \n@@ -340,22 +300,10 @@ sminloc0_8_i8 (gfc_array_i8 * const restrict retarray,\n       retarray->offset = 0;\n       retarray->data = internal_malloc_size (sizeof (GFC_INTEGER_8) * rank);\n     }\n-  else\n+  else if (unlikely (compile_options.bounds_check))\n     {\n-      if (unlikely (compile_options.bounds_check))\n-\t{\n-\t  int ret_rank;\n-\t  index_type ret_extent;\n-\n-\t  ret_rank = GFC_DESCRIPTOR_RANK (retarray);\n-\t  if (ret_rank != 1)\n-\t    runtime_error (\"rank of return array in MINLOC intrinsic\"\n-\t\t\t   \" should be 1, is %ld\", (long int) ret_rank);\n-\n-\t  ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,0);\n-\t    if (ret_extent != rank)\n-\t      runtime_error (\"dimension of return array incorrect\");\n-\t}\n+       bounds_iforeach_return ((array_t *) retarray, (array_t *) array,\n+\t\t\t       \"MINLOC\");\n     }\n \n   dstride = GFC_DESCRIPTOR_STRIDE(retarray,0);"}, {"sha": "fe31ea91ec42605a27b9f557371bf13380a04c82", "filename": "libgfortran/generated/minloc0_8_r10.c", "status": "modified", "additions": 10, "deletions": 62, "changes": 72, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/16bff92192676901670042cdce3fbd5f9c928fc8/libgfortran%2Fgenerated%2Fminloc0_8_r10.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/16bff92192676901670042cdce3fbd5f9c928fc8/libgfortran%2Fgenerated%2Fminloc0_8_r10.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminloc0_8_r10.c?ref=16bff92192676901670042cdce3fbd5f9c928fc8", "patch": "@@ -63,21 +63,8 @@ minloc0_8_r10 (gfc_array_i8 * const restrict retarray,\n   else\n     {\n       if (unlikely (compile_options.bounds_check))\n-\t{\n-\t  int ret_rank;\n-\t  index_type ret_extent;\n-\n-\t  ret_rank = GFC_DESCRIPTOR_RANK (retarray);\n-\t  if (ret_rank != 1)\n-\t    runtime_error (\"rank of return array in MINLOC intrinsic\"\n-\t\t\t   \" should be 1, is %ld\", (long int) ret_rank);\n-\n-\t  ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,0);\n-\t  if (ret_extent != rank)\n-\t    runtime_error (\"Incorrect extent in return value of\"\n-\t\t\t   \" MINLOC intrnisic: is %ld, should be %ld\",\n-\t\t\t   (long int) ret_extent, (long int) rank);\n-\t}\n+        bounds_iforeach_return ((array_t *) retarray, (array_t *) array,\n+\t                        \"MINLOC\");\n     }\n \n   dstride = GFC_DESCRIPTOR_STRIDE(retarray,0);\n@@ -186,38 +173,11 @@ mminloc0_8_r10 (gfc_array_i8 * const restrict retarray,\n     {\n       if (unlikely (compile_options.bounds_check))\n \t{\n-\t  int ret_rank, mask_rank;\n-\t  index_type ret_extent;\n-\t  int n;\n-\t  index_type array_extent, mask_extent;\n-\n-\t  ret_rank = GFC_DESCRIPTOR_RANK (retarray);\n-\t  if (ret_rank != 1)\n-\t    runtime_error (\"rank of return array in MINLOC intrinsic\"\n-\t\t\t   \" should be 1, is %ld\", (long int) ret_rank);\n-\n-\t  ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,0);\n-\t  if (ret_extent != rank)\n-\t    runtime_error (\"Incorrect extent in return value of\"\n-\t\t\t   \" MINLOC intrnisic: is %ld, should be %ld\",\n-\t\t\t   (long int) ret_extent, (long int) rank);\n-\t\n-\t  mask_rank = GFC_DESCRIPTOR_RANK (mask);\n-\t  if (rank != mask_rank)\n-\t    runtime_error (\"rank of MASK argument in MINLOC intrnisic\"\n-\t                   \"should be %ld, is %ld\", (long int) rank,\n-\t\t\t   (long int) mask_rank);\n-\n-\t  for (n=0; n<rank; n++)\n-\t    {\n-\t      array_extent = GFC_DESCRIPTOR_EXTENT(array,n);\n-\t      mask_extent = GFC_DESCRIPTOR_EXTENT(mask,n);\n-\t      if (array_extent != mask_extent)\n-\t\truntime_error (\"Incorrect extent in MASK argument of\"\n-\t\t\t       \" MINLOC intrinsic in dimension %ld:\"\n-\t\t\t       \" is %ld, should be %ld\", (long int) n + 1,\n-\t\t\t       (long int) mask_extent, (long int) array_extent);\n-\t    }\n+\n+\t  bounds_iforeach_return ((array_t *) retarray, (array_t *) array,\n+\t\t\t\t  \"MINLOC\");\n+\t  bounds_equal_extents ((array_t *) mask, (array_t *) array,\n+\t\t\t\t  \"MASK argument\", \"MINLOC\");\n \t}\n     }\n \n@@ -340,22 +300,10 @@ sminloc0_8_r10 (gfc_array_i8 * const restrict retarray,\n       retarray->offset = 0;\n       retarray->data = internal_malloc_size (sizeof (GFC_INTEGER_8) * rank);\n     }\n-  else\n+  else if (unlikely (compile_options.bounds_check))\n     {\n-      if (unlikely (compile_options.bounds_check))\n-\t{\n-\t  int ret_rank;\n-\t  index_type ret_extent;\n-\n-\t  ret_rank = GFC_DESCRIPTOR_RANK (retarray);\n-\t  if (ret_rank != 1)\n-\t    runtime_error (\"rank of return array in MINLOC intrinsic\"\n-\t\t\t   \" should be 1, is %ld\", (long int) ret_rank);\n-\n-\t  ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,0);\n-\t    if (ret_extent != rank)\n-\t      runtime_error (\"dimension of return array incorrect\");\n-\t}\n+       bounds_iforeach_return ((array_t *) retarray, (array_t *) array,\n+\t\t\t       \"MINLOC\");\n     }\n \n   dstride = GFC_DESCRIPTOR_STRIDE(retarray,0);"}, {"sha": "365403c87f0fedc9220602cc130803d8cb827e71", "filename": "libgfortran/generated/minloc0_8_r16.c", "status": "modified", "additions": 10, "deletions": 62, "changes": 72, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/16bff92192676901670042cdce3fbd5f9c928fc8/libgfortran%2Fgenerated%2Fminloc0_8_r16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/16bff92192676901670042cdce3fbd5f9c928fc8/libgfortran%2Fgenerated%2Fminloc0_8_r16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminloc0_8_r16.c?ref=16bff92192676901670042cdce3fbd5f9c928fc8", "patch": "@@ -63,21 +63,8 @@ minloc0_8_r16 (gfc_array_i8 * const restrict retarray,\n   else\n     {\n       if (unlikely (compile_options.bounds_check))\n-\t{\n-\t  int ret_rank;\n-\t  index_type ret_extent;\n-\n-\t  ret_rank = GFC_DESCRIPTOR_RANK (retarray);\n-\t  if (ret_rank != 1)\n-\t    runtime_error (\"rank of return array in MINLOC intrinsic\"\n-\t\t\t   \" should be 1, is %ld\", (long int) ret_rank);\n-\n-\t  ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,0);\n-\t  if (ret_extent != rank)\n-\t    runtime_error (\"Incorrect extent in return value of\"\n-\t\t\t   \" MINLOC intrnisic: is %ld, should be %ld\",\n-\t\t\t   (long int) ret_extent, (long int) rank);\n-\t}\n+        bounds_iforeach_return ((array_t *) retarray, (array_t *) array,\n+\t                        \"MINLOC\");\n     }\n \n   dstride = GFC_DESCRIPTOR_STRIDE(retarray,0);\n@@ -186,38 +173,11 @@ mminloc0_8_r16 (gfc_array_i8 * const restrict retarray,\n     {\n       if (unlikely (compile_options.bounds_check))\n \t{\n-\t  int ret_rank, mask_rank;\n-\t  index_type ret_extent;\n-\t  int n;\n-\t  index_type array_extent, mask_extent;\n-\n-\t  ret_rank = GFC_DESCRIPTOR_RANK (retarray);\n-\t  if (ret_rank != 1)\n-\t    runtime_error (\"rank of return array in MINLOC intrinsic\"\n-\t\t\t   \" should be 1, is %ld\", (long int) ret_rank);\n-\n-\t  ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,0);\n-\t  if (ret_extent != rank)\n-\t    runtime_error (\"Incorrect extent in return value of\"\n-\t\t\t   \" MINLOC intrnisic: is %ld, should be %ld\",\n-\t\t\t   (long int) ret_extent, (long int) rank);\n-\t\n-\t  mask_rank = GFC_DESCRIPTOR_RANK (mask);\n-\t  if (rank != mask_rank)\n-\t    runtime_error (\"rank of MASK argument in MINLOC intrnisic\"\n-\t                   \"should be %ld, is %ld\", (long int) rank,\n-\t\t\t   (long int) mask_rank);\n-\n-\t  for (n=0; n<rank; n++)\n-\t    {\n-\t      array_extent = GFC_DESCRIPTOR_EXTENT(array,n);\n-\t      mask_extent = GFC_DESCRIPTOR_EXTENT(mask,n);\n-\t      if (array_extent != mask_extent)\n-\t\truntime_error (\"Incorrect extent in MASK argument of\"\n-\t\t\t       \" MINLOC intrinsic in dimension %ld:\"\n-\t\t\t       \" is %ld, should be %ld\", (long int) n + 1,\n-\t\t\t       (long int) mask_extent, (long int) array_extent);\n-\t    }\n+\n+\t  bounds_iforeach_return ((array_t *) retarray, (array_t *) array,\n+\t\t\t\t  \"MINLOC\");\n+\t  bounds_equal_extents ((array_t *) mask, (array_t *) array,\n+\t\t\t\t  \"MASK argument\", \"MINLOC\");\n \t}\n     }\n \n@@ -340,22 +300,10 @@ sminloc0_8_r16 (gfc_array_i8 * const restrict retarray,\n       retarray->offset = 0;\n       retarray->data = internal_malloc_size (sizeof (GFC_INTEGER_8) * rank);\n     }\n-  else\n+  else if (unlikely (compile_options.bounds_check))\n     {\n-      if (unlikely (compile_options.bounds_check))\n-\t{\n-\t  int ret_rank;\n-\t  index_type ret_extent;\n-\n-\t  ret_rank = GFC_DESCRIPTOR_RANK (retarray);\n-\t  if (ret_rank != 1)\n-\t    runtime_error (\"rank of return array in MINLOC intrinsic\"\n-\t\t\t   \" should be 1, is %ld\", (long int) ret_rank);\n-\n-\t  ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,0);\n-\t    if (ret_extent != rank)\n-\t      runtime_error (\"dimension of return array incorrect\");\n-\t}\n+       bounds_iforeach_return ((array_t *) retarray, (array_t *) array,\n+\t\t\t       \"MINLOC\");\n     }\n \n   dstride = GFC_DESCRIPTOR_STRIDE(retarray,0);"}, {"sha": "53c89b13f7fcb26a56277d0bfd4160500afdc355", "filename": "libgfortran/generated/minloc0_8_r4.c", "status": "modified", "additions": 10, "deletions": 62, "changes": 72, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/16bff92192676901670042cdce3fbd5f9c928fc8/libgfortran%2Fgenerated%2Fminloc0_8_r4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/16bff92192676901670042cdce3fbd5f9c928fc8/libgfortran%2Fgenerated%2Fminloc0_8_r4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminloc0_8_r4.c?ref=16bff92192676901670042cdce3fbd5f9c928fc8", "patch": "@@ -63,21 +63,8 @@ minloc0_8_r4 (gfc_array_i8 * const restrict retarray,\n   else\n     {\n       if (unlikely (compile_options.bounds_check))\n-\t{\n-\t  int ret_rank;\n-\t  index_type ret_extent;\n-\n-\t  ret_rank = GFC_DESCRIPTOR_RANK (retarray);\n-\t  if (ret_rank != 1)\n-\t    runtime_error (\"rank of return array in MINLOC intrinsic\"\n-\t\t\t   \" should be 1, is %ld\", (long int) ret_rank);\n-\n-\t  ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,0);\n-\t  if (ret_extent != rank)\n-\t    runtime_error (\"Incorrect extent in return value of\"\n-\t\t\t   \" MINLOC intrnisic: is %ld, should be %ld\",\n-\t\t\t   (long int) ret_extent, (long int) rank);\n-\t}\n+        bounds_iforeach_return ((array_t *) retarray, (array_t *) array,\n+\t                        \"MINLOC\");\n     }\n \n   dstride = GFC_DESCRIPTOR_STRIDE(retarray,0);\n@@ -186,38 +173,11 @@ mminloc0_8_r4 (gfc_array_i8 * const restrict retarray,\n     {\n       if (unlikely (compile_options.bounds_check))\n \t{\n-\t  int ret_rank, mask_rank;\n-\t  index_type ret_extent;\n-\t  int n;\n-\t  index_type array_extent, mask_extent;\n-\n-\t  ret_rank = GFC_DESCRIPTOR_RANK (retarray);\n-\t  if (ret_rank != 1)\n-\t    runtime_error (\"rank of return array in MINLOC intrinsic\"\n-\t\t\t   \" should be 1, is %ld\", (long int) ret_rank);\n-\n-\t  ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,0);\n-\t  if (ret_extent != rank)\n-\t    runtime_error (\"Incorrect extent in return value of\"\n-\t\t\t   \" MINLOC intrnisic: is %ld, should be %ld\",\n-\t\t\t   (long int) ret_extent, (long int) rank);\n-\t\n-\t  mask_rank = GFC_DESCRIPTOR_RANK (mask);\n-\t  if (rank != mask_rank)\n-\t    runtime_error (\"rank of MASK argument in MINLOC intrnisic\"\n-\t                   \"should be %ld, is %ld\", (long int) rank,\n-\t\t\t   (long int) mask_rank);\n-\n-\t  for (n=0; n<rank; n++)\n-\t    {\n-\t      array_extent = GFC_DESCRIPTOR_EXTENT(array,n);\n-\t      mask_extent = GFC_DESCRIPTOR_EXTENT(mask,n);\n-\t      if (array_extent != mask_extent)\n-\t\truntime_error (\"Incorrect extent in MASK argument of\"\n-\t\t\t       \" MINLOC intrinsic in dimension %ld:\"\n-\t\t\t       \" is %ld, should be %ld\", (long int) n + 1,\n-\t\t\t       (long int) mask_extent, (long int) array_extent);\n-\t    }\n+\n+\t  bounds_iforeach_return ((array_t *) retarray, (array_t *) array,\n+\t\t\t\t  \"MINLOC\");\n+\t  bounds_equal_extents ((array_t *) mask, (array_t *) array,\n+\t\t\t\t  \"MASK argument\", \"MINLOC\");\n \t}\n     }\n \n@@ -340,22 +300,10 @@ sminloc0_8_r4 (gfc_array_i8 * const restrict retarray,\n       retarray->offset = 0;\n       retarray->data = internal_malloc_size (sizeof (GFC_INTEGER_8) * rank);\n     }\n-  else\n+  else if (unlikely (compile_options.bounds_check))\n     {\n-      if (unlikely (compile_options.bounds_check))\n-\t{\n-\t  int ret_rank;\n-\t  index_type ret_extent;\n-\n-\t  ret_rank = GFC_DESCRIPTOR_RANK (retarray);\n-\t  if (ret_rank != 1)\n-\t    runtime_error (\"rank of return array in MINLOC intrinsic\"\n-\t\t\t   \" should be 1, is %ld\", (long int) ret_rank);\n-\n-\t  ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,0);\n-\t    if (ret_extent != rank)\n-\t      runtime_error (\"dimension of return array incorrect\");\n-\t}\n+       bounds_iforeach_return ((array_t *) retarray, (array_t *) array,\n+\t\t\t       \"MINLOC\");\n     }\n \n   dstride = GFC_DESCRIPTOR_STRIDE(retarray,0);"}, {"sha": "ab553b24005b6528eb77cad49ff7077cb20ca511", "filename": "libgfortran/generated/minloc0_8_r8.c", "status": "modified", "additions": 10, "deletions": 62, "changes": 72, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/16bff92192676901670042cdce3fbd5f9c928fc8/libgfortran%2Fgenerated%2Fminloc0_8_r8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/16bff92192676901670042cdce3fbd5f9c928fc8/libgfortran%2Fgenerated%2Fminloc0_8_r8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminloc0_8_r8.c?ref=16bff92192676901670042cdce3fbd5f9c928fc8", "patch": "@@ -63,21 +63,8 @@ minloc0_8_r8 (gfc_array_i8 * const restrict retarray,\n   else\n     {\n       if (unlikely (compile_options.bounds_check))\n-\t{\n-\t  int ret_rank;\n-\t  index_type ret_extent;\n-\n-\t  ret_rank = GFC_DESCRIPTOR_RANK (retarray);\n-\t  if (ret_rank != 1)\n-\t    runtime_error (\"rank of return array in MINLOC intrinsic\"\n-\t\t\t   \" should be 1, is %ld\", (long int) ret_rank);\n-\n-\t  ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,0);\n-\t  if (ret_extent != rank)\n-\t    runtime_error (\"Incorrect extent in return value of\"\n-\t\t\t   \" MINLOC intrnisic: is %ld, should be %ld\",\n-\t\t\t   (long int) ret_extent, (long int) rank);\n-\t}\n+        bounds_iforeach_return ((array_t *) retarray, (array_t *) array,\n+\t                        \"MINLOC\");\n     }\n \n   dstride = GFC_DESCRIPTOR_STRIDE(retarray,0);\n@@ -186,38 +173,11 @@ mminloc0_8_r8 (gfc_array_i8 * const restrict retarray,\n     {\n       if (unlikely (compile_options.bounds_check))\n \t{\n-\t  int ret_rank, mask_rank;\n-\t  index_type ret_extent;\n-\t  int n;\n-\t  index_type array_extent, mask_extent;\n-\n-\t  ret_rank = GFC_DESCRIPTOR_RANK (retarray);\n-\t  if (ret_rank != 1)\n-\t    runtime_error (\"rank of return array in MINLOC intrinsic\"\n-\t\t\t   \" should be 1, is %ld\", (long int) ret_rank);\n-\n-\t  ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,0);\n-\t  if (ret_extent != rank)\n-\t    runtime_error (\"Incorrect extent in return value of\"\n-\t\t\t   \" MINLOC intrnisic: is %ld, should be %ld\",\n-\t\t\t   (long int) ret_extent, (long int) rank);\n-\t\n-\t  mask_rank = GFC_DESCRIPTOR_RANK (mask);\n-\t  if (rank != mask_rank)\n-\t    runtime_error (\"rank of MASK argument in MINLOC intrnisic\"\n-\t                   \"should be %ld, is %ld\", (long int) rank,\n-\t\t\t   (long int) mask_rank);\n-\n-\t  for (n=0; n<rank; n++)\n-\t    {\n-\t      array_extent = GFC_DESCRIPTOR_EXTENT(array,n);\n-\t      mask_extent = GFC_DESCRIPTOR_EXTENT(mask,n);\n-\t      if (array_extent != mask_extent)\n-\t\truntime_error (\"Incorrect extent in MASK argument of\"\n-\t\t\t       \" MINLOC intrinsic in dimension %ld:\"\n-\t\t\t       \" is %ld, should be %ld\", (long int) n + 1,\n-\t\t\t       (long int) mask_extent, (long int) array_extent);\n-\t    }\n+\n+\t  bounds_iforeach_return ((array_t *) retarray, (array_t *) array,\n+\t\t\t\t  \"MINLOC\");\n+\t  bounds_equal_extents ((array_t *) mask, (array_t *) array,\n+\t\t\t\t  \"MASK argument\", \"MINLOC\");\n \t}\n     }\n \n@@ -340,22 +300,10 @@ sminloc0_8_r8 (gfc_array_i8 * const restrict retarray,\n       retarray->offset = 0;\n       retarray->data = internal_malloc_size (sizeof (GFC_INTEGER_8) * rank);\n     }\n-  else\n+  else if (unlikely (compile_options.bounds_check))\n     {\n-      if (unlikely (compile_options.bounds_check))\n-\t{\n-\t  int ret_rank;\n-\t  index_type ret_extent;\n-\n-\t  ret_rank = GFC_DESCRIPTOR_RANK (retarray);\n-\t  if (ret_rank != 1)\n-\t    runtime_error (\"rank of return array in MINLOC intrinsic\"\n-\t\t\t   \" should be 1, is %ld\", (long int) ret_rank);\n-\n-\t  ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,0);\n-\t    if (ret_extent != rank)\n-\t      runtime_error (\"dimension of return array incorrect\");\n-\t}\n+       bounds_iforeach_return ((array_t *) retarray, (array_t *) array,\n+\t\t\t       \"MINLOC\");\n     }\n \n   dstride = GFC_DESCRIPTOR_STRIDE(retarray,0);"}, {"sha": "9177230a5ae56388bab3115e0e812079cd21b63f", "filename": "libgfortran/generated/minloc1_16_i1.c", "status": "modified", "additions": 6, "deletions": 36, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/16bff92192676901670042cdce3fbd5f9c928fc8/libgfortran%2Fgenerated%2Fminloc1_16_i1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/16bff92192676901670042cdce3fbd5f9c928fc8/libgfortran%2Fgenerated%2Fminloc1_16_i1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminloc1_16_i1.c?ref=16bff92192676901670042cdce3fbd5f9c928fc8", "patch": "@@ -120,19 +120,8 @@ minloc1_16_i1 (gfc_array_i16 * const restrict retarray,\n \t\t       (long int) rank);\n \n       if (unlikely (compile_options.bounds_check))\n-\t{\n-\t  for (n=0; n < rank; n++)\n-\t    {\n-\t      index_type ret_extent;\n-\n-\t      ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,n);\n-\t      if (extent[n] != ret_extent)\n-\t\truntime_error (\"Incorrect extent in return value of\"\n-\t\t\t       \" MINLOC intrinsic in dimension %ld:\"\n-\t\t\t       \" is %ld, should be %ld\", (long int) n + 1,\n-\t\t\t       (long int) ret_extent, (long int) extent[n]);\n-\t    }\n-\t}\n+\tbounds_ifunction_return ((array_t *) retarray, extent,\n+\t\t\t\t \"return value\", \"MINLOC\");\n     }\n \n   for (n = 0; n < rank; n++)\n@@ -313,29 +302,10 @@ mminloc1_16_i1 (gfc_array_i16 * const restrict retarray,\n \n       if (unlikely (compile_options.bounds_check))\n \t{\n-\t  for (n=0; n < rank; n++)\n-\t    {\n-\t      index_type ret_extent;\n-\n-\t      ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,n);\n-\t      if (extent[n] != ret_extent)\n-\t\truntime_error (\"Incorrect extent in return value of\"\n-\t\t\t       \" MINLOC intrinsic in dimension %ld:\"\n-\t\t\t       \" is %ld, should be %ld\", (long int) n + 1,\n-\t\t\t       (long int) ret_extent, (long int) extent[n]);\n-\t    }\n-          for (n=0; n<= rank; n++)\n-            {\n-              index_type mask_extent, array_extent;\n-\n-\t      array_extent = GFC_DESCRIPTOR_EXTENT(array,n);\n-\t      mask_extent = GFC_DESCRIPTOR_EXTENT(mask,n);\n-\t      if (array_extent != mask_extent)\n-\t\truntime_error (\"Incorrect extent in MASK argument of\"\n-\t\t\t       \" MINLOC intrinsic in dimension %ld:\"\n-\t\t\t       \" is %ld, should be %ld\", (long int) n + 1,\n-\t\t\t       (long int) mask_extent, (long int) array_extent);\n-\t    }\n+\t  bounds_ifunction_return ((array_t *) retarray, extent,\n+\t\t\t\t   \"return value\", \"MINLOC\");\n+\t  bounds_equal_extents ((array_t *) mask, (array_t *) array,\n+\t  \t\t\t\"MASK argument\", \"MINLOC\");\n \t}\n     }\n "}, {"sha": "5ffebe29a481fb1e378ffe1fd242ca3021c9efd7", "filename": "libgfortran/generated/minloc1_16_i16.c", "status": "modified", "additions": 6, "deletions": 36, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/16bff92192676901670042cdce3fbd5f9c928fc8/libgfortran%2Fgenerated%2Fminloc1_16_i16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/16bff92192676901670042cdce3fbd5f9c928fc8/libgfortran%2Fgenerated%2Fminloc1_16_i16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminloc1_16_i16.c?ref=16bff92192676901670042cdce3fbd5f9c928fc8", "patch": "@@ -120,19 +120,8 @@ minloc1_16_i16 (gfc_array_i16 * const restrict retarray,\n \t\t       (long int) rank);\n \n       if (unlikely (compile_options.bounds_check))\n-\t{\n-\t  for (n=0; n < rank; n++)\n-\t    {\n-\t      index_type ret_extent;\n-\n-\t      ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,n);\n-\t      if (extent[n] != ret_extent)\n-\t\truntime_error (\"Incorrect extent in return value of\"\n-\t\t\t       \" MINLOC intrinsic in dimension %ld:\"\n-\t\t\t       \" is %ld, should be %ld\", (long int) n + 1,\n-\t\t\t       (long int) ret_extent, (long int) extent[n]);\n-\t    }\n-\t}\n+\tbounds_ifunction_return ((array_t *) retarray, extent,\n+\t\t\t\t \"return value\", \"MINLOC\");\n     }\n \n   for (n = 0; n < rank; n++)\n@@ -313,29 +302,10 @@ mminloc1_16_i16 (gfc_array_i16 * const restrict retarray,\n \n       if (unlikely (compile_options.bounds_check))\n \t{\n-\t  for (n=0; n < rank; n++)\n-\t    {\n-\t      index_type ret_extent;\n-\n-\t      ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,n);\n-\t      if (extent[n] != ret_extent)\n-\t\truntime_error (\"Incorrect extent in return value of\"\n-\t\t\t       \" MINLOC intrinsic in dimension %ld:\"\n-\t\t\t       \" is %ld, should be %ld\", (long int) n + 1,\n-\t\t\t       (long int) ret_extent, (long int) extent[n]);\n-\t    }\n-          for (n=0; n<= rank; n++)\n-            {\n-              index_type mask_extent, array_extent;\n-\n-\t      array_extent = GFC_DESCRIPTOR_EXTENT(array,n);\n-\t      mask_extent = GFC_DESCRIPTOR_EXTENT(mask,n);\n-\t      if (array_extent != mask_extent)\n-\t\truntime_error (\"Incorrect extent in MASK argument of\"\n-\t\t\t       \" MINLOC intrinsic in dimension %ld:\"\n-\t\t\t       \" is %ld, should be %ld\", (long int) n + 1,\n-\t\t\t       (long int) mask_extent, (long int) array_extent);\n-\t    }\n+\t  bounds_ifunction_return ((array_t *) retarray, extent,\n+\t\t\t\t   \"return value\", \"MINLOC\");\n+\t  bounds_equal_extents ((array_t *) mask, (array_t *) array,\n+\t  \t\t\t\"MASK argument\", \"MINLOC\");\n \t}\n     }\n "}, {"sha": "f1110c1b25470b5a3397fcbdbbfd2cd4d6797fe9", "filename": "libgfortran/generated/minloc1_16_i2.c", "status": "modified", "additions": 6, "deletions": 36, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/16bff92192676901670042cdce3fbd5f9c928fc8/libgfortran%2Fgenerated%2Fminloc1_16_i2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/16bff92192676901670042cdce3fbd5f9c928fc8/libgfortran%2Fgenerated%2Fminloc1_16_i2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminloc1_16_i2.c?ref=16bff92192676901670042cdce3fbd5f9c928fc8", "patch": "@@ -120,19 +120,8 @@ minloc1_16_i2 (gfc_array_i16 * const restrict retarray,\n \t\t       (long int) rank);\n \n       if (unlikely (compile_options.bounds_check))\n-\t{\n-\t  for (n=0; n < rank; n++)\n-\t    {\n-\t      index_type ret_extent;\n-\n-\t      ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,n);\n-\t      if (extent[n] != ret_extent)\n-\t\truntime_error (\"Incorrect extent in return value of\"\n-\t\t\t       \" MINLOC intrinsic in dimension %ld:\"\n-\t\t\t       \" is %ld, should be %ld\", (long int) n + 1,\n-\t\t\t       (long int) ret_extent, (long int) extent[n]);\n-\t    }\n-\t}\n+\tbounds_ifunction_return ((array_t *) retarray, extent,\n+\t\t\t\t \"return value\", \"MINLOC\");\n     }\n \n   for (n = 0; n < rank; n++)\n@@ -313,29 +302,10 @@ mminloc1_16_i2 (gfc_array_i16 * const restrict retarray,\n \n       if (unlikely (compile_options.bounds_check))\n \t{\n-\t  for (n=0; n < rank; n++)\n-\t    {\n-\t      index_type ret_extent;\n-\n-\t      ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,n);\n-\t      if (extent[n] != ret_extent)\n-\t\truntime_error (\"Incorrect extent in return value of\"\n-\t\t\t       \" MINLOC intrinsic in dimension %ld:\"\n-\t\t\t       \" is %ld, should be %ld\", (long int) n + 1,\n-\t\t\t       (long int) ret_extent, (long int) extent[n]);\n-\t    }\n-          for (n=0; n<= rank; n++)\n-            {\n-              index_type mask_extent, array_extent;\n-\n-\t      array_extent = GFC_DESCRIPTOR_EXTENT(array,n);\n-\t      mask_extent = GFC_DESCRIPTOR_EXTENT(mask,n);\n-\t      if (array_extent != mask_extent)\n-\t\truntime_error (\"Incorrect extent in MASK argument of\"\n-\t\t\t       \" MINLOC intrinsic in dimension %ld:\"\n-\t\t\t       \" is %ld, should be %ld\", (long int) n + 1,\n-\t\t\t       (long int) mask_extent, (long int) array_extent);\n-\t    }\n+\t  bounds_ifunction_return ((array_t *) retarray, extent,\n+\t\t\t\t   \"return value\", \"MINLOC\");\n+\t  bounds_equal_extents ((array_t *) mask, (array_t *) array,\n+\t  \t\t\t\"MASK argument\", \"MINLOC\");\n \t}\n     }\n "}, {"sha": "86c0acf5a0c2ddbc6f48ab9cbc19a40aa9d8ce5f", "filename": "libgfortran/generated/minloc1_16_i4.c", "status": "modified", "additions": 6, "deletions": 36, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/16bff92192676901670042cdce3fbd5f9c928fc8/libgfortran%2Fgenerated%2Fminloc1_16_i4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/16bff92192676901670042cdce3fbd5f9c928fc8/libgfortran%2Fgenerated%2Fminloc1_16_i4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminloc1_16_i4.c?ref=16bff92192676901670042cdce3fbd5f9c928fc8", "patch": "@@ -120,19 +120,8 @@ minloc1_16_i4 (gfc_array_i16 * const restrict retarray,\n \t\t       (long int) rank);\n \n       if (unlikely (compile_options.bounds_check))\n-\t{\n-\t  for (n=0; n < rank; n++)\n-\t    {\n-\t      index_type ret_extent;\n-\n-\t      ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,n);\n-\t      if (extent[n] != ret_extent)\n-\t\truntime_error (\"Incorrect extent in return value of\"\n-\t\t\t       \" MINLOC intrinsic in dimension %ld:\"\n-\t\t\t       \" is %ld, should be %ld\", (long int) n + 1,\n-\t\t\t       (long int) ret_extent, (long int) extent[n]);\n-\t    }\n-\t}\n+\tbounds_ifunction_return ((array_t *) retarray, extent,\n+\t\t\t\t \"return value\", \"MINLOC\");\n     }\n \n   for (n = 0; n < rank; n++)\n@@ -313,29 +302,10 @@ mminloc1_16_i4 (gfc_array_i16 * const restrict retarray,\n \n       if (unlikely (compile_options.bounds_check))\n \t{\n-\t  for (n=0; n < rank; n++)\n-\t    {\n-\t      index_type ret_extent;\n-\n-\t      ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,n);\n-\t      if (extent[n] != ret_extent)\n-\t\truntime_error (\"Incorrect extent in return value of\"\n-\t\t\t       \" MINLOC intrinsic in dimension %ld:\"\n-\t\t\t       \" is %ld, should be %ld\", (long int) n + 1,\n-\t\t\t       (long int) ret_extent, (long int) extent[n]);\n-\t    }\n-          for (n=0; n<= rank; n++)\n-            {\n-              index_type mask_extent, array_extent;\n-\n-\t      array_extent = GFC_DESCRIPTOR_EXTENT(array,n);\n-\t      mask_extent = GFC_DESCRIPTOR_EXTENT(mask,n);\n-\t      if (array_extent != mask_extent)\n-\t\truntime_error (\"Incorrect extent in MASK argument of\"\n-\t\t\t       \" MINLOC intrinsic in dimension %ld:\"\n-\t\t\t       \" is %ld, should be %ld\", (long int) n + 1,\n-\t\t\t       (long int) mask_extent, (long int) array_extent);\n-\t    }\n+\t  bounds_ifunction_return ((array_t *) retarray, extent,\n+\t\t\t\t   \"return value\", \"MINLOC\");\n+\t  bounds_equal_extents ((array_t *) mask, (array_t *) array,\n+\t  \t\t\t\"MASK argument\", \"MINLOC\");\n \t}\n     }\n "}, {"sha": "7e965bee56da613da199128a69f29ece4f713fe1", "filename": "libgfortran/generated/minloc1_16_i8.c", "status": "modified", "additions": 6, "deletions": 36, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/16bff92192676901670042cdce3fbd5f9c928fc8/libgfortran%2Fgenerated%2Fminloc1_16_i8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/16bff92192676901670042cdce3fbd5f9c928fc8/libgfortran%2Fgenerated%2Fminloc1_16_i8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminloc1_16_i8.c?ref=16bff92192676901670042cdce3fbd5f9c928fc8", "patch": "@@ -120,19 +120,8 @@ minloc1_16_i8 (gfc_array_i16 * const restrict retarray,\n \t\t       (long int) rank);\n \n       if (unlikely (compile_options.bounds_check))\n-\t{\n-\t  for (n=0; n < rank; n++)\n-\t    {\n-\t      index_type ret_extent;\n-\n-\t      ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,n);\n-\t      if (extent[n] != ret_extent)\n-\t\truntime_error (\"Incorrect extent in return value of\"\n-\t\t\t       \" MINLOC intrinsic in dimension %ld:\"\n-\t\t\t       \" is %ld, should be %ld\", (long int) n + 1,\n-\t\t\t       (long int) ret_extent, (long int) extent[n]);\n-\t    }\n-\t}\n+\tbounds_ifunction_return ((array_t *) retarray, extent,\n+\t\t\t\t \"return value\", \"MINLOC\");\n     }\n \n   for (n = 0; n < rank; n++)\n@@ -313,29 +302,10 @@ mminloc1_16_i8 (gfc_array_i16 * const restrict retarray,\n \n       if (unlikely (compile_options.bounds_check))\n \t{\n-\t  for (n=0; n < rank; n++)\n-\t    {\n-\t      index_type ret_extent;\n-\n-\t      ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,n);\n-\t      if (extent[n] != ret_extent)\n-\t\truntime_error (\"Incorrect extent in return value of\"\n-\t\t\t       \" MINLOC intrinsic in dimension %ld:\"\n-\t\t\t       \" is %ld, should be %ld\", (long int) n + 1,\n-\t\t\t       (long int) ret_extent, (long int) extent[n]);\n-\t    }\n-          for (n=0; n<= rank; n++)\n-            {\n-              index_type mask_extent, array_extent;\n-\n-\t      array_extent = GFC_DESCRIPTOR_EXTENT(array,n);\n-\t      mask_extent = GFC_DESCRIPTOR_EXTENT(mask,n);\n-\t      if (array_extent != mask_extent)\n-\t\truntime_error (\"Incorrect extent in MASK argument of\"\n-\t\t\t       \" MINLOC intrinsic in dimension %ld:\"\n-\t\t\t       \" is %ld, should be %ld\", (long int) n + 1,\n-\t\t\t       (long int) mask_extent, (long int) array_extent);\n-\t    }\n+\t  bounds_ifunction_return ((array_t *) retarray, extent,\n+\t\t\t\t   \"return value\", \"MINLOC\");\n+\t  bounds_equal_extents ((array_t *) mask, (array_t *) array,\n+\t  \t\t\t\"MASK argument\", \"MINLOC\");\n \t}\n     }\n "}, {"sha": "e57462634c54457af5ecfcae7bc9a88577466ab3", "filename": "libgfortran/generated/minloc1_16_r10.c", "status": "modified", "additions": 6, "deletions": 36, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/16bff92192676901670042cdce3fbd5f9c928fc8/libgfortran%2Fgenerated%2Fminloc1_16_r10.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/16bff92192676901670042cdce3fbd5f9c928fc8/libgfortran%2Fgenerated%2Fminloc1_16_r10.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminloc1_16_r10.c?ref=16bff92192676901670042cdce3fbd5f9c928fc8", "patch": "@@ -120,19 +120,8 @@ minloc1_16_r10 (gfc_array_i16 * const restrict retarray,\n \t\t       (long int) rank);\n \n       if (unlikely (compile_options.bounds_check))\n-\t{\n-\t  for (n=0; n < rank; n++)\n-\t    {\n-\t      index_type ret_extent;\n-\n-\t      ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,n);\n-\t      if (extent[n] != ret_extent)\n-\t\truntime_error (\"Incorrect extent in return value of\"\n-\t\t\t       \" MINLOC intrinsic in dimension %ld:\"\n-\t\t\t       \" is %ld, should be %ld\", (long int) n + 1,\n-\t\t\t       (long int) ret_extent, (long int) extent[n]);\n-\t    }\n-\t}\n+\tbounds_ifunction_return ((array_t *) retarray, extent,\n+\t\t\t\t \"return value\", \"MINLOC\");\n     }\n \n   for (n = 0; n < rank; n++)\n@@ -313,29 +302,10 @@ mminloc1_16_r10 (gfc_array_i16 * const restrict retarray,\n \n       if (unlikely (compile_options.bounds_check))\n \t{\n-\t  for (n=0; n < rank; n++)\n-\t    {\n-\t      index_type ret_extent;\n-\n-\t      ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,n);\n-\t      if (extent[n] != ret_extent)\n-\t\truntime_error (\"Incorrect extent in return value of\"\n-\t\t\t       \" MINLOC intrinsic in dimension %ld:\"\n-\t\t\t       \" is %ld, should be %ld\", (long int) n + 1,\n-\t\t\t       (long int) ret_extent, (long int) extent[n]);\n-\t    }\n-          for (n=0; n<= rank; n++)\n-            {\n-              index_type mask_extent, array_extent;\n-\n-\t      array_extent = GFC_DESCRIPTOR_EXTENT(array,n);\n-\t      mask_extent = GFC_DESCRIPTOR_EXTENT(mask,n);\n-\t      if (array_extent != mask_extent)\n-\t\truntime_error (\"Incorrect extent in MASK argument of\"\n-\t\t\t       \" MINLOC intrinsic in dimension %ld:\"\n-\t\t\t       \" is %ld, should be %ld\", (long int) n + 1,\n-\t\t\t       (long int) mask_extent, (long int) array_extent);\n-\t    }\n+\t  bounds_ifunction_return ((array_t *) retarray, extent,\n+\t\t\t\t   \"return value\", \"MINLOC\");\n+\t  bounds_equal_extents ((array_t *) mask, (array_t *) array,\n+\t  \t\t\t\"MASK argument\", \"MINLOC\");\n \t}\n     }\n "}, {"sha": "08815d322f573f46cdb0a021e5b3251cc7455417", "filename": "libgfortran/generated/minloc1_16_r16.c", "status": "modified", "additions": 6, "deletions": 36, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/16bff92192676901670042cdce3fbd5f9c928fc8/libgfortran%2Fgenerated%2Fminloc1_16_r16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/16bff92192676901670042cdce3fbd5f9c928fc8/libgfortran%2Fgenerated%2Fminloc1_16_r16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminloc1_16_r16.c?ref=16bff92192676901670042cdce3fbd5f9c928fc8", "patch": "@@ -120,19 +120,8 @@ minloc1_16_r16 (gfc_array_i16 * const restrict retarray,\n \t\t       (long int) rank);\n \n       if (unlikely (compile_options.bounds_check))\n-\t{\n-\t  for (n=0; n < rank; n++)\n-\t    {\n-\t      index_type ret_extent;\n-\n-\t      ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,n);\n-\t      if (extent[n] != ret_extent)\n-\t\truntime_error (\"Incorrect extent in return value of\"\n-\t\t\t       \" MINLOC intrinsic in dimension %ld:\"\n-\t\t\t       \" is %ld, should be %ld\", (long int) n + 1,\n-\t\t\t       (long int) ret_extent, (long int) extent[n]);\n-\t    }\n-\t}\n+\tbounds_ifunction_return ((array_t *) retarray, extent,\n+\t\t\t\t \"return value\", \"MINLOC\");\n     }\n \n   for (n = 0; n < rank; n++)\n@@ -313,29 +302,10 @@ mminloc1_16_r16 (gfc_array_i16 * const restrict retarray,\n \n       if (unlikely (compile_options.bounds_check))\n \t{\n-\t  for (n=0; n < rank; n++)\n-\t    {\n-\t      index_type ret_extent;\n-\n-\t      ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,n);\n-\t      if (extent[n] != ret_extent)\n-\t\truntime_error (\"Incorrect extent in return value of\"\n-\t\t\t       \" MINLOC intrinsic in dimension %ld:\"\n-\t\t\t       \" is %ld, should be %ld\", (long int) n + 1,\n-\t\t\t       (long int) ret_extent, (long int) extent[n]);\n-\t    }\n-          for (n=0; n<= rank; n++)\n-            {\n-              index_type mask_extent, array_extent;\n-\n-\t      array_extent = GFC_DESCRIPTOR_EXTENT(array,n);\n-\t      mask_extent = GFC_DESCRIPTOR_EXTENT(mask,n);\n-\t      if (array_extent != mask_extent)\n-\t\truntime_error (\"Incorrect extent in MASK argument of\"\n-\t\t\t       \" MINLOC intrinsic in dimension %ld:\"\n-\t\t\t       \" is %ld, should be %ld\", (long int) n + 1,\n-\t\t\t       (long int) mask_extent, (long int) array_extent);\n-\t    }\n+\t  bounds_ifunction_return ((array_t *) retarray, extent,\n+\t\t\t\t   \"return value\", \"MINLOC\");\n+\t  bounds_equal_extents ((array_t *) mask, (array_t *) array,\n+\t  \t\t\t\"MASK argument\", \"MINLOC\");\n \t}\n     }\n "}, {"sha": "7f2967d6eb4df7e68c29dad5bebafe3631b0a033", "filename": "libgfortran/generated/minloc1_16_r4.c", "status": "modified", "additions": 6, "deletions": 36, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/16bff92192676901670042cdce3fbd5f9c928fc8/libgfortran%2Fgenerated%2Fminloc1_16_r4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/16bff92192676901670042cdce3fbd5f9c928fc8/libgfortran%2Fgenerated%2Fminloc1_16_r4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminloc1_16_r4.c?ref=16bff92192676901670042cdce3fbd5f9c928fc8", "patch": "@@ -120,19 +120,8 @@ minloc1_16_r4 (gfc_array_i16 * const restrict retarray,\n \t\t       (long int) rank);\n \n       if (unlikely (compile_options.bounds_check))\n-\t{\n-\t  for (n=0; n < rank; n++)\n-\t    {\n-\t      index_type ret_extent;\n-\n-\t      ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,n);\n-\t      if (extent[n] != ret_extent)\n-\t\truntime_error (\"Incorrect extent in return value of\"\n-\t\t\t       \" MINLOC intrinsic in dimension %ld:\"\n-\t\t\t       \" is %ld, should be %ld\", (long int) n + 1,\n-\t\t\t       (long int) ret_extent, (long int) extent[n]);\n-\t    }\n-\t}\n+\tbounds_ifunction_return ((array_t *) retarray, extent,\n+\t\t\t\t \"return value\", \"MINLOC\");\n     }\n \n   for (n = 0; n < rank; n++)\n@@ -313,29 +302,10 @@ mminloc1_16_r4 (gfc_array_i16 * const restrict retarray,\n \n       if (unlikely (compile_options.bounds_check))\n \t{\n-\t  for (n=0; n < rank; n++)\n-\t    {\n-\t      index_type ret_extent;\n-\n-\t      ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,n);\n-\t      if (extent[n] != ret_extent)\n-\t\truntime_error (\"Incorrect extent in return value of\"\n-\t\t\t       \" MINLOC intrinsic in dimension %ld:\"\n-\t\t\t       \" is %ld, should be %ld\", (long int) n + 1,\n-\t\t\t       (long int) ret_extent, (long int) extent[n]);\n-\t    }\n-          for (n=0; n<= rank; n++)\n-            {\n-              index_type mask_extent, array_extent;\n-\n-\t      array_extent = GFC_DESCRIPTOR_EXTENT(array,n);\n-\t      mask_extent = GFC_DESCRIPTOR_EXTENT(mask,n);\n-\t      if (array_extent != mask_extent)\n-\t\truntime_error (\"Incorrect extent in MASK argument of\"\n-\t\t\t       \" MINLOC intrinsic in dimension %ld:\"\n-\t\t\t       \" is %ld, should be %ld\", (long int) n + 1,\n-\t\t\t       (long int) mask_extent, (long int) array_extent);\n-\t    }\n+\t  bounds_ifunction_return ((array_t *) retarray, extent,\n+\t\t\t\t   \"return value\", \"MINLOC\");\n+\t  bounds_equal_extents ((array_t *) mask, (array_t *) array,\n+\t  \t\t\t\"MASK argument\", \"MINLOC\");\n \t}\n     }\n "}, {"sha": "4d6fa8b43ee49ead948c9b62d97c7dcfd96281c5", "filename": "libgfortran/generated/minloc1_16_r8.c", "status": "modified", "additions": 6, "deletions": 36, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/16bff92192676901670042cdce3fbd5f9c928fc8/libgfortran%2Fgenerated%2Fminloc1_16_r8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/16bff92192676901670042cdce3fbd5f9c928fc8/libgfortran%2Fgenerated%2Fminloc1_16_r8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminloc1_16_r8.c?ref=16bff92192676901670042cdce3fbd5f9c928fc8", "patch": "@@ -120,19 +120,8 @@ minloc1_16_r8 (gfc_array_i16 * const restrict retarray,\n \t\t       (long int) rank);\n \n       if (unlikely (compile_options.bounds_check))\n-\t{\n-\t  for (n=0; n < rank; n++)\n-\t    {\n-\t      index_type ret_extent;\n-\n-\t      ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,n);\n-\t      if (extent[n] != ret_extent)\n-\t\truntime_error (\"Incorrect extent in return value of\"\n-\t\t\t       \" MINLOC intrinsic in dimension %ld:\"\n-\t\t\t       \" is %ld, should be %ld\", (long int) n + 1,\n-\t\t\t       (long int) ret_extent, (long int) extent[n]);\n-\t    }\n-\t}\n+\tbounds_ifunction_return ((array_t *) retarray, extent,\n+\t\t\t\t \"return value\", \"MINLOC\");\n     }\n \n   for (n = 0; n < rank; n++)\n@@ -313,29 +302,10 @@ mminloc1_16_r8 (gfc_array_i16 * const restrict retarray,\n \n       if (unlikely (compile_options.bounds_check))\n \t{\n-\t  for (n=0; n < rank; n++)\n-\t    {\n-\t      index_type ret_extent;\n-\n-\t      ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,n);\n-\t      if (extent[n] != ret_extent)\n-\t\truntime_error (\"Incorrect extent in return value of\"\n-\t\t\t       \" MINLOC intrinsic in dimension %ld:\"\n-\t\t\t       \" is %ld, should be %ld\", (long int) n + 1,\n-\t\t\t       (long int) ret_extent, (long int) extent[n]);\n-\t    }\n-          for (n=0; n<= rank; n++)\n-            {\n-              index_type mask_extent, array_extent;\n-\n-\t      array_extent = GFC_DESCRIPTOR_EXTENT(array,n);\n-\t      mask_extent = GFC_DESCRIPTOR_EXTENT(mask,n);\n-\t      if (array_extent != mask_extent)\n-\t\truntime_error (\"Incorrect extent in MASK argument of\"\n-\t\t\t       \" MINLOC intrinsic in dimension %ld:\"\n-\t\t\t       \" is %ld, should be %ld\", (long int) n + 1,\n-\t\t\t       (long int) mask_extent, (long int) array_extent);\n-\t    }\n+\t  bounds_ifunction_return ((array_t *) retarray, extent,\n+\t\t\t\t   \"return value\", \"MINLOC\");\n+\t  bounds_equal_extents ((array_t *) mask, (array_t *) array,\n+\t  \t\t\t\"MASK argument\", \"MINLOC\");\n \t}\n     }\n "}, {"sha": "107ebea06cd30fc901f756c07042277280e398c3", "filename": "libgfortran/generated/minloc1_4_i1.c", "status": "modified", "additions": 6, "deletions": 36, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/16bff92192676901670042cdce3fbd5f9c928fc8/libgfortran%2Fgenerated%2Fminloc1_4_i1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/16bff92192676901670042cdce3fbd5f9c928fc8/libgfortran%2Fgenerated%2Fminloc1_4_i1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminloc1_4_i1.c?ref=16bff92192676901670042cdce3fbd5f9c928fc8", "patch": "@@ -120,19 +120,8 @@ minloc1_4_i1 (gfc_array_i4 * const restrict retarray,\n \t\t       (long int) rank);\n \n       if (unlikely (compile_options.bounds_check))\n-\t{\n-\t  for (n=0; n < rank; n++)\n-\t    {\n-\t      index_type ret_extent;\n-\n-\t      ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,n);\n-\t      if (extent[n] != ret_extent)\n-\t\truntime_error (\"Incorrect extent in return value of\"\n-\t\t\t       \" MINLOC intrinsic in dimension %ld:\"\n-\t\t\t       \" is %ld, should be %ld\", (long int) n + 1,\n-\t\t\t       (long int) ret_extent, (long int) extent[n]);\n-\t    }\n-\t}\n+\tbounds_ifunction_return ((array_t *) retarray, extent,\n+\t\t\t\t \"return value\", \"MINLOC\");\n     }\n \n   for (n = 0; n < rank; n++)\n@@ -313,29 +302,10 @@ mminloc1_4_i1 (gfc_array_i4 * const restrict retarray,\n \n       if (unlikely (compile_options.bounds_check))\n \t{\n-\t  for (n=0; n < rank; n++)\n-\t    {\n-\t      index_type ret_extent;\n-\n-\t      ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,n);\n-\t      if (extent[n] != ret_extent)\n-\t\truntime_error (\"Incorrect extent in return value of\"\n-\t\t\t       \" MINLOC intrinsic in dimension %ld:\"\n-\t\t\t       \" is %ld, should be %ld\", (long int) n + 1,\n-\t\t\t       (long int) ret_extent, (long int) extent[n]);\n-\t    }\n-          for (n=0; n<= rank; n++)\n-            {\n-              index_type mask_extent, array_extent;\n-\n-\t      array_extent = GFC_DESCRIPTOR_EXTENT(array,n);\n-\t      mask_extent = GFC_DESCRIPTOR_EXTENT(mask,n);\n-\t      if (array_extent != mask_extent)\n-\t\truntime_error (\"Incorrect extent in MASK argument of\"\n-\t\t\t       \" MINLOC intrinsic in dimension %ld:\"\n-\t\t\t       \" is %ld, should be %ld\", (long int) n + 1,\n-\t\t\t       (long int) mask_extent, (long int) array_extent);\n-\t    }\n+\t  bounds_ifunction_return ((array_t *) retarray, extent,\n+\t\t\t\t   \"return value\", \"MINLOC\");\n+\t  bounds_equal_extents ((array_t *) mask, (array_t *) array,\n+\t  \t\t\t\"MASK argument\", \"MINLOC\");\n \t}\n     }\n "}, {"sha": "b84c52461e7f013724c50c2c49501f38b7cedad0", "filename": "libgfortran/generated/minloc1_4_i16.c", "status": "modified", "additions": 6, "deletions": 36, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/16bff92192676901670042cdce3fbd5f9c928fc8/libgfortran%2Fgenerated%2Fminloc1_4_i16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/16bff92192676901670042cdce3fbd5f9c928fc8/libgfortran%2Fgenerated%2Fminloc1_4_i16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminloc1_4_i16.c?ref=16bff92192676901670042cdce3fbd5f9c928fc8", "patch": "@@ -120,19 +120,8 @@ minloc1_4_i16 (gfc_array_i4 * const restrict retarray,\n \t\t       (long int) rank);\n \n       if (unlikely (compile_options.bounds_check))\n-\t{\n-\t  for (n=0; n < rank; n++)\n-\t    {\n-\t      index_type ret_extent;\n-\n-\t      ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,n);\n-\t      if (extent[n] != ret_extent)\n-\t\truntime_error (\"Incorrect extent in return value of\"\n-\t\t\t       \" MINLOC intrinsic in dimension %ld:\"\n-\t\t\t       \" is %ld, should be %ld\", (long int) n + 1,\n-\t\t\t       (long int) ret_extent, (long int) extent[n]);\n-\t    }\n-\t}\n+\tbounds_ifunction_return ((array_t *) retarray, extent,\n+\t\t\t\t \"return value\", \"MINLOC\");\n     }\n \n   for (n = 0; n < rank; n++)\n@@ -313,29 +302,10 @@ mminloc1_4_i16 (gfc_array_i4 * const restrict retarray,\n \n       if (unlikely (compile_options.bounds_check))\n \t{\n-\t  for (n=0; n < rank; n++)\n-\t    {\n-\t      index_type ret_extent;\n-\n-\t      ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,n);\n-\t      if (extent[n] != ret_extent)\n-\t\truntime_error (\"Incorrect extent in return value of\"\n-\t\t\t       \" MINLOC intrinsic in dimension %ld:\"\n-\t\t\t       \" is %ld, should be %ld\", (long int) n + 1,\n-\t\t\t       (long int) ret_extent, (long int) extent[n]);\n-\t    }\n-          for (n=0; n<= rank; n++)\n-            {\n-              index_type mask_extent, array_extent;\n-\n-\t      array_extent = GFC_DESCRIPTOR_EXTENT(array,n);\n-\t      mask_extent = GFC_DESCRIPTOR_EXTENT(mask,n);\n-\t      if (array_extent != mask_extent)\n-\t\truntime_error (\"Incorrect extent in MASK argument of\"\n-\t\t\t       \" MINLOC intrinsic in dimension %ld:\"\n-\t\t\t       \" is %ld, should be %ld\", (long int) n + 1,\n-\t\t\t       (long int) mask_extent, (long int) array_extent);\n-\t    }\n+\t  bounds_ifunction_return ((array_t *) retarray, extent,\n+\t\t\t\t   \"return value\", \"MINLOC\");\n+\t  bounds_equal_extents ((array_t *) mask, (array_t *) array,\n+\t  \t\t\t\"MASK argument\", \"MINLOC\");\n \t}\n     }\n "}, {"sha": "641b15d1d69fc3d97c68349311f458e4864da0aa", "filename": "libgfortran/generated/minloc1_4_i2.c", "status": "modified", "additions": 6, "deletions": 36, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/16bff92192676901670042cdce3fbd5f9c928fc8/libgfortran%2Fgenerated%2Fminloc1_4_i2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/16bff92192676901670042cdce3fbd5f9c928fc8/libgfortran%2Fgenerated%2Fminloc1_4_i2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminloc1_4_i2.c?ref=16bff92192676901670042cdce3fbd5f9c928fc8", "patch": "@@ -120,19 +120,8 @@ minloc1_4_i2 (gfc_array_i4 * const restrict retarray,\n \t\t       (long int) rank);\n \n       if (unlikely (compile_options.bounds_check))\n-\t{\n-\t  for (n=0; n < rank; n++)\n-\t    {\n-\t      index_type ret_extent;\n-\n-\t      ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,n);\n-\t      if (extent[n] != ret_extent)\n-\t\truntime_error (\"Incorrect extent in return value of\"\n-\t\t\t       \" MINLOC intrinsic in dimension %ld:\"\n-\t\t\t       \" is %ld, should be %ld\", (long int) n + 1,\n-\t\t\t       (long int) ret_extent, (long int) extent[n]);\n-\t    }\n-\t}\n+\tbounds_ifunction_return ((array_t *) retarray, extent,\n+\t\t\t\t \"return value\", \"MINLOC\");\n     }\n \n   for (n = 0; n < rank; n++)\n@@ -313,29 +302,10 @@ mminloc1_4_i2 (gfc_array_i4 * const restrict retarray,\n \n       if (unlikely (compile_options.bounds_check))\n \t{\n-\t  for (n=0; n < rank; n++)\n-\t    {\n-\t      index_type ret_extent;\n-\n-\t      ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,n);\n-\t      if (extent[n] != ret_extent)\n-\t\truntime_error (\"Incorrect extent in return value of\"\n-\t\t\t       \" MINLOC intrinsic in dimension %ld:\"\n-\t\t\t       \" is %ld, should be %ld\", (long int) n + 1,\n-\t\t\t       (long int) ret_extent, (long int) extent[n]);\n-\t    }\n-          for (n=0; n<= rank; n++)\n-            {\n-              index_type mask_extent, array_extent;\n-\n-\t      array_extent = GFC_DESCRIPTOR_EXTENT(array,n);\n-\t      mask_extent = GFC_DESCRIPTOR_EXTENT(mask,n);\n-\t      if (array_extent != mask_extent)\n-\t\truntime_error (\"Incorrect extent in MASK argument of\"\n-\t\t\t       \" MINLOC intrinsic in dimension %ld:\"\n-\t\t\t       \" is %ld, should be %ld\", (long int) n + 1,\n-\t\t\t       (long int) mask_extent, (long int) array_extent);\n-\t    }\n+\t  bounds_ifunction_return ((array_t *) retarray, extent,\n+\t\t\t\t   \"return value\", \"MINLOC\");\n+\t  bounds_equal_extents ((array_t *) mask, (array_t *) array,\n+\t  \t\t\t\"MASK argument\", \"MINLOC\");\n \t}\n     }\n "}, {"sha": "c1daa5771b1b0c0e726bc2aede983197ffa04c99", "filename": "libgfortran/generated/minloc1_4_i4.c", "status": "modified", "additions": 6, "deletions": 36, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/16bff92192676901670042cdce3fbd5f9c928fc8/libgfortran%2Fgenerated%2Fminloc1_4_i4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/16bff92192676901670042cdce3fbd5f9c928fc8/libgfortran%2Fgenerated%2Fminloc1_4_i4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminloc1_4_i4.c?ref=16bff92192676901670042cdce3fbd5f9c928fc8", "patch": "@@ -120,19 +120,8 @@ minloc1_4_i4 (gfc_array_i4 * const restrict retarray,\n \t\t       (long int) rank);\n \n       if (unlikely (compile_options.bounds_check))\n-\t{\n-\t  for (n=0; n < rank; n++)\n-\t    {\n-\t      index_type ret_extent;\n-\n-\t      ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,n);\n-\t      if (extent[n] != ret_extent)\n-\t\truntime_error (\"Incorrect extent in return value of\"\n-\t\t\t       \" MINLOC intrinsic in dimension %ld:\"\n-\t\t\t       \" is %ld, should be %ld\", (long int) n + 1,\n-\t\t\t       (long int) ret_extent, (long int) extent[n]);\n-\t    }\n-\t}\n+\tbounds_ifunction_return ((array_t *) retarray, extent,\n+\t\t\t\t \"return value\", \"MINLOC\");\n     }\n \n   for (n = 0; n < rank; n++)\n@@ -313,29 +302,10 @@ mminloc1_4_i4 (gfc_array_i4 * const restrict retarray,\n \n       if (unlikely (compile_options.bounds_check))\n \t{\n-\t  for (n=0; n < rank; n++)\n-\t    {\n-\t      index_type ret_extent;\n-\n-\t      ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,n);\n-\t      if (extent[n] != ret_extent)\n-\t\truntime_error (\"Incorrect extent in return value of\"\n-\t\t\t       \" MINLOC intrinsic in dimension %ld:\"\n-\t\t\t       \" is %ld, should be %ld\", (long int) n + 1,\n-\t\t\t       (long int) ret_extent, (long int) extent[n]);\n-\t    }\n-          for (n=0; n<= rank; n++)\n-            {\n-              index_type mask_extent, array_extent;\n-\n-\t      array_extent = GFC_DESCRIPTOR_EXTENT(array,n);\n-\t      mask_extent = GFC_DESCRIPTOR_EXTENT(mask,n);\n-\t      if (array_extent != mask_extent)\n-\t\truntime_error (\"Incorrect extent in MASK argument of\"\n-\t\t\t       \" MINLOC intrinsic in dimension %ld:\"\n-\t\t\t       \" is %ld, should be %ld\", (long int) n + 1,\n-\t\t\t       (long int) mask_extent, (long int) array_extent);\n-\t    }\n+\t  bounds_ifunction_return ((array_t *) retarray, extent,\n+\t\t\t\t   \"return value\", \"MINLOC\");\n+\t  bounds_equal_extents ((array_t *) mask, (array_t *) array,\n+\t  \t\t\t\"MASK argument\", \"MINLOC\");\n \t}\n     }\n "}, {"sha": "2229fc49a0d3c93711dad67fb7086420d202ac77", "filename": "libgfortran/generated/minloc1_4_i8.c", "status": "modified", "additions": 6, "deletions": 36, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/16bff92192676901670042cdce3fbd5f9c928fc8/libgfortran%2Fgenerated%2Fminloc1_4_i8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/16bff92192676901670042cdce3fbd5f9c928fc8/libgfortran%2Fgenerated%2Fminloc1_4_i8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminloc1_4_i8.c?ref=16bff92192676901670042cdce3fbd5f9c928fc8", "patch": "@@ -120,19 +120,8 @@ minloc1_4_i8 (gfc_array_i4 * const restrict retarray,\n \t\t       (long int) rank);\n \n       if (unlikely (compile_options.bounds_check))\n-\t{\n-\t  for (n=0; n < rank; n++)\n-\t    {\n-\t      index_type ret_extent;\n-\n-\t      ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,n);\n-\t      if (extent[n] != ret_extent)\n-\t\truntime_error (\"Incorrect extent in return value of\"\n-\t\t\t       \" MINLOC intrinsic in dimension %ld:\"\n-\t\t\t       \" is %ld, should be %ld\", (long int) n + 1,\n-\t\t\t       (long int) ret_extent, (long int) extent[n]);\n-\t    }\n-\t}\n+\tbounds_ifunction_return ((array_t *) retarray, extent,\n+\t\t\t\t \"return value\", \"MINLOC\");\n     }\n \n   for (n = 0; n < rank; n++)\n@@ -313,29 +302,10 @@ mminloc1_4_i8 (gfc_array_i4 * const restrict retarray,\n \n       if (unlikely (compile_options.bounds_check))\n \t{\n-\t  for (n=0; n < rank; n++)\n-\t    {\n-\t      index_type ret_extent;\n-\n-\t      ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,n);\n-\t      if (extent[n] != ret_extent)\n-\t\truntime_error (\"Incorrect extent in return value of\"\n-\t\t\t       \" MINLOC intrinsic in dimension %ld:\"\n-\t\t\t       \" is %ld, should be %ld\", (long int) n + 1,\n-\t\t\t       (long int) ret_extent, (long int) extent[n]);\n-\t    }\n-          for (n=0; n<= rank; n++)\n-            {\n-              index_type mask_extent, array_extent;\n-\n-\t      array_extent = GFC_DESCRIPTOR_EXTENT(array,n);\n-\t      mask_extent = GFC_DESCRIPTOR_EXTENT(mask,n);\n-\t      if (array_extent != mask_extent)\n-\t\truntime_error (\"Incorrect extent in MASK argument of\"\n-\t\t\t       \" MINLOC intrinsic in dimension %ld:\"\n-\t\t\t       \" is %ld, should be %ld\", (long int) n + 1,\n-\t\t\t       (long int) mask_extent, (long int) array_extent);\n-\t    }\n+\t  bounds_ifunction_return ((array_t *) retarray, extent,\n+\t\t\t\t   \"return value\", \"MINLOC\");\n+\t  bounds_equal_extents ((array_t *) mask, (array_t *) array,\n+\t  \t\t\t\"MASK argument\", \"MINLOC\");\n \t}\n     }\n "}, {"sha": "ade388b399dfa27c7ac11dc6fdf61d107683535e", "filename": "libgfortran/generated/minloc1_4_r10.c", "status": "modified", "additions": 6, "deletions": 36, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/16bff92192676901670042cdce3fbd5f9c928fc8/libgfortran%2Fgenerated%2Fminloc1_4_r10.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/16bff92192676901670042cdce3fbd5f9c928fc8/libgfortran%2Fgenerated%2Fminloc1_4_r10.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminloc1_4_r10.c?ref=16bff92192676901670042cdce3fbd5f9c928fc8", "patch": "@@ -120,19 +120,8 @@ minloc1_4_r10 (gfc_array_i4 * const restrict retarray,\n \t\t       (long int) rank);\n \n       if (unlikely (compile_options.bounds_check))\n-\t{\n-\t  for (n=0; n < rank; n++)\n-\t    {\n-\t      index_type ret_extent;\n-\n-\t      ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,n);\n-\t      if (extent[n] != ret_extent)\n-\t\truntime_error (\"Incorrect extent in return value of\"\n-\t\t\t       \" MINLOC intrinsic in dimension %ld:\"\n-\t\t\t       \" is %ld, should be %ld\", (long int) n + 1,\n-\t\t\t       (long int) ret_extent, (long int) extent[n]);\n-\t    }\n-\t}\n+\tbounds_ifunction_return ((array_t *) retarray, extent,\n+\t\t\t\t \"return value\", \"MINLOC\");\n     }\n \n   for (n = 0; n < rank; n++)\n@@ -313,29 +302,10 @@ mminloc1_4_r10 (gfc_array_i4 * const restrict retarray,\n \n       if (unlikely (compile_options.bounds_check))\n \t{\n-\t  for (n=0; n < rank; n++)\n-\t    {\n-\t      index_type ret_extent;\n-\n-\t      ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,n);\n-\t      if (extent[n] != ret_extent)\n-\t\truntime_error (\"Incorrect extent in return value of\"\n-\t\t\t       \" MINLOC intrinsic in dimension %ld:\"\n-\t\t\t       \" is %ld, should be %ld\", (long int) n + 1,\n-\t\t\t       (long int) ret_extent, (long int) extent[n]);\n-\t    }\n-          for (n=0; n<= rank; n++)\n-            {\n-              index_type mask_extent, array_extent;\n-\n-\t      array_extent = GFC_DESCRIPTOR_EXTENT(array,n);\n-\t      mask_extent = GFC_DESCRIPTOR_EXTENT(mask,n);\n-\t      if (array_extent != mask_extent)\n-\t\truntime_error (\"Incorrect extent in MASK argument of\"\n-\t\t\t       \" MINLOC intrinsic in dimension %ld:\"\n-\t\t\t       \" is %ld, should be %ld\", (long int) n + 1,\n-\t\t\t       (long int) mask_extent, (long int) array_extent);\n-\t    }\n+\t  bounds_ifunction_return ((array_t *) retarray, extent,\n+\t\t\t\t   \"return value\", \"MINLOC\");\n+\t  bounds_equal_extents ((array_t *) mask, (array_t *) array,\n+\t  \t\t\t\"MASK argument\", \"MINLOC\");\n \t}\n     }\n "}, {"sha": "e6cf58be55103dd327e24dbbfd0ba620dbf31ce8", "filename": "libgfortran/generated/minloc1_4_r16.c", "status": "modified", "additions": 6, "deletions": 36, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/16bff92192676901670042cdce3fbd5f9c928fc8/libgfortran%2Fgenerated%2Fminloc1_4_r16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/16bff92192676901670042cdce3fbd5f9c928fc8/libgfortran%2Fgenerated%2Fminloc1_4_r16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminloc1_4_r16.c?ref=16bff92192676901670042cdce3fbd5f9c928fc8", "patch": "@@ -120,19 +120,8 @@ minloc1_4_r16 (gfc_array_i4 * const restrict retarray,\n \t\t       (long int) rank);\n \n       if (unlikely (compile_options.bounds_check))\n-\t{\n-\t  for (n=0; n < rank; n++)\n-\t    {\n-\t      index_type ret_extent;\n-\n-\t      ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,n);\n-\t      if (extent[n] != ret_extent)\n-\t\truntime_error (\"Incorrect extent in return value of\"\n-\t\t\t       \" MINLOC intrinsic in dimension %ld:\"\n-\t\t\t       \" is %ld, should be %ld\", (long int) n + 1,\n-\t\t\t       (long int) ret_extent, (long int) extent[n]);\n-\t    }\n-\t}\n+\tbounds_ifunction_return ((array_t *) retarray, extent,\n+\t\t\t\t \"return value\", \"MINLOC\");\n     }\n \n   for (n = 0; n < rank; n++)\n@@ -313,29 +302,10 @@ mminloc1_4_r16 (gfc_array_i4 * const restrict retarray,\n \n       if (unlikely (compile_options.bounds_check))\n \t{\n-\t  for (n=0; n < rank; n++)\n-\t    {\n-\t      index_type ret_extent;\n-\n-\t      ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,n);\n-\t      if (extent[n] != ret_extent)\n-\t\truntime_error (\"Incorrect extent in return value of\"\n-\t\t\t       \" MINLOC intrinsic in dimension %ld:\"\n-\t\t\t       \" is %ld, should be %ld\", (long int) n + 1,\n-\t\t\t       (long int) ret_extent, (long int) extent[n]);\n-\t    }\n-          for (n=0; n<= rank; n++)\n-            {\n-              index_type mask_extent, array_extent;\n-\n-\t      array_extent = GFC_DESCRIPTOR_EXTENT(array,n);\n-\t      mask_extent = GFC_DESCRIPTOR_EXTENT(mask,n);\n-\t      if (array_extent != mask_extent)\n-\t\truntime_error (\"Incorrect extent in MASK argument of\"\n-\t\t\t       \" MINLOC intrinsic in dimension %ld:\"\n-\t\t\t       \" is %ld, should be %ld\", (long int) n + 1,\n-\t\t\t       (long int) mask_extent, (long int) array_extent);\n-\t    }\n+\t  bounds_ifunction_return ((array_t *) retarray, extent,\n+\t\t\t\t   \"return value\", \"MINLOC\");\n+\t  bounds_equal_extents ((array_t *) mask, (array_t *) array,\n+\t  \t\t\t\"MASK argument\", \"MINLOC\");\n \t}\n     }\n "}, {"sha": "6aa23040294ba28ffe23c3b4abd642abd18cc5ba", "filename": "libgfortran/generated/minloc1_4_r4.c", "status": "modified", "additions": 6, "deletions": 36, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/16bff92192676901670042cdce3fbd5f9c928fc8/libgfortran%2Fgenerated%2Fminloc1_4_r4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/16bff92192676901670042cdce3fbd5f9c928fc8/libgfortran%2Fgenerated%2Fminloc1_4_r4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminloc1_4_r4.c?ref=16bff92192676901670042cdce3fbd5f9c928fc8", "patch": "@@ -120,19 +120,8 @@ minloc1_4_r4 (gfc_array_i4 * const restrict retarray,\n \t\t       (long int) rank);\n \n       if (unlikely (compile_options.bounds_check))\n-\t{\n-\t  for (n=0; n < rank; n++)\n-\t    {\n-\t      index_type ret_extent;\n-\n-\t      ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,n);\n-\t      if (extent[n] != ret_extent)\n-\t\truntime_error (\"Incorrect extent in return value of\"\n-\t\t\t       \" MINLOC intrinsic in dimension %ld:\"\n-\t\t\t       \" is %ld, should be %ld\", (long int) n + 1,\n-\t\t\t       (long int) ret_extent, (long int) extent[n]);\n-\t    }\n-\t}\n+\tbounds_ifunction_return ((array_t *) retarray, extent,\n+\t\t\t\t \"return value\", \"MINLOC\");\n     }\n \n   for (n = 0; n < rank; n++)\n@@ -313,29 +302,10 @@ mminloc1_4_r4 (gfc_array_i4 * const restrict retarray,\n \n       if (unlikely (compile_options.bounds_check))\n \t{\n-\t  for (n=0; n < rank; n++)\n-\t    {\n-\t      index_type ret_extent;\n-\n-\t      ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,n);\n-\t      if (extent[n] != ret_extent)\n-\t\truntime_error (\"Incorrect extent in return value of\"\n-\t\t\t       \" MINLOC intrinsic in dimension %ld:\"\n-\t\t\t       \" is %ld, should be %ld\", (long int) n + 1,\n-\t\t\t       (long int) ret_extent, (long int) extent[n]);\n-\t    }\n-          for (n=0; n<= rank; n++)\n-            {\n-              index_type mask_extent, array_extent;\n-\n-\t      array_extent = GFC_DESCRIPTOR_EXTENT(array,n);\n-\t      mask_extent = GFC_DESCRIPTOR_EXTENT(mask,n);\n-\t      if (array_extent != mask_extent)\n-\t\truntime_error (\"Incorrect extent in MASK argument of\"\n-\t\t\t       \" MINLOC intrinsic in dimension %ld:\"\n-\t\t\t       \" is %ld, should be %ld\", (long int) n + 1,\n-\t\t\t       (long int) mask_extent, (long int) array_extent);\n-\t    }\n+\t  bounds_ifunction_return ((array_t *) retarray, extent,\n+\t\t\t\t   \"return value\", \"MINLOC\");\n+\t  bounds_equal_extents ((array_t *) mask, (array_t *) array,\n+\t  \t\t\t\"MASK argument\", \"MINLOC\");\n \t}\n     }\n "}, {"sha": "ccc93f5e00e069a37f2e49534ec10e544095be16", "filename": "libgfortran/generated/minloc1_4_r8.c", "status": "modified", "additions": 6, "deletions": 36, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/16bff92192676901670042cdce3fbd5f9c928fc8/libgfortran%2Fgenerated%2Fminloc1_4_r8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/16bff92192676901670042cdce3fbd5f9c928fc8/libgfortran%2Fgenerated%2Fminloc1_4_r8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminloc1_4_r8.c?ref=16bff92192676901670042cdce3fbd5f9c928fc8", "patch": "@@ -120,19 +120,8 @@ minloc1_4_r8 (gfc_array_i4 * const restrict retarray,\n \t\t       (long int) rank);\n \n       if (unlikely (compile_options.bounds_check))\n-\t{\n-\t  for (n=0; n < rank; n++)\n-\t    {\n-\t      index_type ret_extent;\n-\n-\t      ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,n);\n-\t      if (extent[n] != ret_extent)\n-\t\truntime_error (\"Incorrect extent in return value of\"\n-\t\t\t       \" MINLOC intrinsic in dimension %ld:\"\n-\t\t\t       \" is %ld, should be %ld\", (long int) n + 1,\n-\t\t\t       (long int) ret_extent, (long int) extent[n]);\n-\t    }\n-\t}\n+\tbounds_ifunction_return ((array_t *) retarray, extent,\n+\t\t\t\t \"return value\", \"MINLOC\");\n     }\n \n   for (n = 0; n < rank; n++)\n@@ -313,29 +302,10 @@ mminloc1_4_r8 (gfc_array_i4 * const restrict retarray,\n \n       if (unlikely (compile_options.bounds_check))\n \t{\n-\t  for (n=0; n < rank; n++)\n-\t    {\n-\t      index_type ret_extent;\n-\n-\t      ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,n);\n-\t      if (extent[n] != ret_extent)\n-\t\truntime_error (\"Incorrect extent in return value of\"\n-\t\t\t       \" MINLOC intrinsic in dimension %ld:\"\n-\t\t\t       \" is %ld, should be %ld\", (long int) n + 1,\n-\t\t\t       (long int) ret_extent, (long int) extent[n]);\n-\t    }\n-          for (n=0; n<= rank; n++)\n-            {\n-              index_type mask_extent, array_extent;\n-\n-\t      array_extent = GFC_DESCRIPTOR_EXTENT(array,n);\n-\t      mask_extent = GFC_DESCRIPTOR_EXTENT(mask,n);\n-\t      if (array_extent != mask_extent)\n-\t\truntime_error (\"Incorrect extent in MASK argument of\"\n-\t\t\t       \" MINLOC intrinsic in dimension %ld:\"\n-\t\t\t       \" is %ld, should be %ld\", (long int) n + 1,\n-\t\t\t       (long int) mask_extent, (long int) array_extent);\n-\t    }\n+\t  bounds_ifunction_return ((array_t *) retarray, extent,\n+\t\t\t\t   \"return value\", \"MINLOC\");\n+\t  bounds_equal_extents ((array_t *) mask, (array_t *) array,\n+\t  \t\t\t\"MASK argument\", \"MINLOC\");\n \t}\n     }\n "}, {"sha": "86003e572e929c84c78922914df1ea172e6f68a2", "filename": "libgfortran/generated/minloc1_8_i1.c", "status": "modified", "additions": 6, "deletions": 36, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/16bff92192676901670042cdce3fbd5f9c928fc8/libgfortran%2Fgenerated%2Fminloc1_8_i1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/16bff92192676901670042cdce3fbd5f9c928fc8/libgfortran%2Fgenerated%2Fminloc1_8_i1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminloc1_8_i1.c?ref=16bff92192676901670042cdce3fbd5f9c928fc8", "patch": "@@ -120,19 +120,8 @@ minloc1_8_i1 (gfc_array_i8 * const restrict retarray,\n \t\t       (long int) rank);\n \n       if (unlikely (compile_options.bounds_check))\n-\t{\n-\t  for (n=0; n < rank; n++)\n-\t    {\n-\t      index_type ret_extent;\n-\n-\t      ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,n);\n-\t      if (extent[n] != ret_extent)\n-\t\truntime_error (\"Incorrect extent in return value of\"\n-\t\t\t       \" MINLOC intrinsic in dimension %ld:\"\n-\t\t\t       \" is %ld, should be %ld\", (long int) n + 1,\n-\t\t\t       (long int) ret_extent, (long int) extent[n]);\n-\t    }\n-\t}\n+\tbounds_ifunction_return ((array_t *) retarray, extent,\n+\t\t\t\t \"return value\", \"MINLOC\");\n     }\n \n   for (n = 0; n < rank; n++)\n@@ -313,29 +302,10 @@ mminloc1_8_i1 (gfc_array_i8 * const restrict retarray,\n \n       if (unlikely (compile_options.bounds_check))\n \t{\n-\t  for (n=0; n < rank; n++)\n-\t    {\n-\t      index_type ret_extent;\n-\n-\t      ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,n);\n-\t      if (extent[n] != ret_extent)\n-\t\truntime_error (\"Incorrect extent in return value of\"\n-\t\t\t       \" MINLOC intrinsic in dimension %ld:\"\n-\t\t\t       \" is %ld, should be %ld\", (long int) n + 1,\n-\t\t\t       (long int) ret_extent, (long int) extent[n]);\n-\t    }\n-          for (n=0; n<= rank; n++)\n-            {\n-              index_type mask_extent, array_extent;\n-\n-\t      array_extent = GFC_DESCRIPTOR_EXTENT(array,n);\n-\t      mask_extent = GFC_DESCRIPTOR_EXTENT(mask,n);\n-\t      if (array_extent != mask_extent)\n-\t\truntime_error (\"Incorrect extent in MASK argument of\"\n-\t\t\t       \" MINLOC intrinsic in dimension %ld:\"\n-\t\t\t       \" is %ld, should be %ld\", (long int) n + 1,\n-\t\t\t       (long int) mask_extent, (long int) array_extent);\n-\t    }\n+\t  bounds_ifunction_return ((array_t *) retarray, extent,\n+\t\t\t\t   \"return value\", \"MINLOC\");\n+\t  bounds_equal_extents ((array_t *) mask, (array_t *) array,\n+\t  \t\t\t\"MASK argument\", \"MINLOC\");\n \t}\n     }\n "}, {"sha": "8dab74cbd1fedca4c9b4bb744c19e9182484dad9", "filename": "libgfortran/generated/minloc1_8_i16.c", "status": "modified", "additions": 6, "deletions": 36, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/16bff92192676901670042cdce3fbd5f9c928fc8/libgfortran%2Fgenerated%2Fminloc1_8_i16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/16bff92192676901670042cdce3fbd5f9c928fc8/libgfortran%2Fgenerated%2Fminloc1_8_i16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminloc1_8_i16.c?ref=16bff92192676901670042cdce3fbd5f9c928fc8", "patch": "@@ -120,19 +120,8 @@ minloc1_8_i16 (gfc_array_i8 * const restrict retarray,\n \t\t       (long int) rank);\n \n       if (unlikely (compile_options.bounds_check))\n-\t{\n-\t  for (n=0; n < rank; n++)\n-\t    {\n-\t      index_type ret_extent;\n-\n-\t      ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,n);\n-\t      if (extent[n] != ret_extent)\n-\t\truntime_error (\"Incorrect extent in return value of\"\n-\t\t\t       \" MINLOC intrinsic in dimension %ld:\"\n-\t\t\t       \" is %ld, should be %ld\", (long int) n + 1,\n-\t\t\t       (long int) ret_extent, (long int) extent[n]);\n-\t    }\n-\t}\n+\tbounds_ifunction_return ((array_t *) retarray, extent,\n+\t\t\t\t \"return value\", \"MINLOC\");\n     }\n \n   for (n = 0; n < rank; n++)\n@@ -313,29 +302,10 @@ mminloc1_8_i16 (gfc_array_i8 * const restrict retarray,\n \n       if (unlikely (compile_options.bounds_check))\n \t{\n-\t  for (n=0; n < rank; n++)\n-\t    {\n-\t      index_type ret_extent;\n-\n-\t      ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,n);\n-\t      if (extent[n] != ret_extent)\n-\t\truntime_error (\"Incorrect extent in return value of\"\n-\t\t\t       \" MINLOC intrinsic in dimension %ld:\"\n-\t\t\t       \" is %ld, should be %ld\", (long int) n + 1,\n-\t\t\t       (long int) ret_extent, (long int) extent[n]);\n-\t    }\n-          for (n=0; n<= rank; n++)\n-            {\n-              index_type mask_extent, array_extent;\n-\n-\t      array_extent = GFC_DESCRIPTOR_EXTENT(array,n);\n-\t      mask_extent = GFC_DESCRIPTOR_EXTENT(mask,n);\n-\t      if (array_extent != mask_extent)\n-\t\truntime_error (\"Incorrect extent in MASK argument of\"\n-\t\t\t       \" MINLOC intrinsic in dimension %ld:\"\n-\t\t\t       \" is %ld, should be %ld\", (long int) n + 1,\n-\t\t\t       (long int) mask_extent, (long int) array_extent);\n-\t    }\n+\t  bounds_ifunction_return ((array_t *) retarray, extent,\n+\t\t\t\t   \"return value\", \"MINLOC\");\n+\t  bounds_equal_extents ((array_t *) mask, (array_t *) array,\n+\t  \t\t\t\"MASK argument\", \"MINLOC\");\n \t}\n     }\n "}, {"sha": "ba76fc1c269cb271faec4157c2ea51045faa4347", "filename": "libgfortran/generated/minloc1_8_i2.c", "status": "modified", "additions": 6, "deletions": 36, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/16bff92192676901670042cdce3fbd5f9c928fc8/libgfortran%2Fgenerated%2Fminloc1_8_i2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/16bff92192676901670042cdce3fbd5f9c928fc8/libgfortran%2Fgenerated%2Fminloc1_8_i2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminloc1_8_i2.c?ref=16bff92192676901670042cdce3fbd5f9c928fc8", "patch": "@@ -120,19 +120,8 @@ minloc1_8_i2 (gfc_array_i8 * const restrict retarray,\n \t\t       (long int) rank);\n \n       if (unlikely (compile_options.bounds_check))\n-\t{\n-\t  for (n=0; n < rank; n++)\n-\t    {\n-\t      index_type ret_extent;\n-\n-\t      ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,n);\n-\t      if (extent[n] != ret_extent)\n-\t\truntime_error (\"Incorrect extent in return value of\"\n-\t\t\t       \" MINLOC intrinsic in dimension %ld:\"\n-\t\t\t       \" is %ld, should be %ld\", (long int) n + 1,\n-\t\t\t       (long int) ret_extent, (long int) extent[n]);\n-\t    }\n-\t}\n+\tbounds_ifunction_return ((array_t *) retarray, extent,\n+\t\t\t\t \"return value\", \"MINLOC\");\n     }\n \n   for (n = 0; n < rank; n++)\n@@ -313,29 +302,10 @@ mminloc1_8_i2 (gfc_array_i8 * const restrict retarray,\n \n       if (unlikely (compile_options.bounds_check))\n \t{\n-\t  for (n=0; n < rank; n++)\n-\t    {\n-\t      index_type ret_extent;\n-\n-\t      ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,n);\n-\t      if (extent[n] != ret_extent)\n-\t\truntime_error (\"Incorrect extent in return value of\"\n-\t\t\t       \" MINLOC intrinsic in dimension %ld:\"\n-\t\t\t       \" is %ld, should be %ld\", (long int) n + 1,\n-\t\t\t       (long int) ret_extent, (long int) extent[n]);\n-\t    }\n-          for (n=0; n<= rank; n++)\n-            {\n-              index_type mask_extent, array_extent;\n-\n-\t      array_extent = GFC_DESCRIPTOR_EXTENT(array,n);\n-\t      mask_extent = GFC_DESCRIPTOR_EXTENT(mask,n);\n-\t      if (array_extent != mask_extent)\n-\t\truntime_error (\"Incorrect extent in MASK argument of\"\n-\t\t\t       \" MINLOC intrinsic in dimension %ld:\"\n-\t\t\t       \" is %ld, should be %ld\", (long int) n + 1,\n-\t\t\t       (long int) mask_extent, (long int) array_extent);\n-\t    }\n+\t  bounds_ifunction_return ((array_t *) retarray, extent,\n+\t\t\t\t   \"return value\", \"MINLOC\");\n+\t  bounds_equal_extents ((array_t *) mask, (array_t *) array,\n+\t  \t\t\t\"MASK argument\", \"MINLOC\");\n \t}\n     }\n "}, {"sha": "03b57de804e5c1cedc4cde570f5df78551271a04", "filename": "libgfortran/generated/minloc1_8_i4.c", "status": "modified", "additions": 6, "deletions": 36, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/16bff92192676901670042cdce3fbd5f9c928fc8/libgfortran%2Fgenerated%2Fminloc1_8_i4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/16bff92192676901670042cdce3fbd5f9c928fc8/libgfortran%2Fgenerated%2Fminloc1_8_i4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminloc1_8_i4.c?ref=16bff92192676901670042cdce3fbd5f9c928fc8", "patch": "@@ -120,19 +120,8 @@ minloc1_8_i4 (gfc_array_i8 * const restrict retarray,\n \t\t       (long int) rank);\n \n       if (unlikely (compile_options.bounds_check))\n-\t{\n-\t  for (n=0; n < rank; n++)\n-\t    {\n-\t      index_type ret_extent;\n-\n-\t      ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,n);\n-\t      if (extent[n] != ret_extent)\n-\t\truntime_error (\"Incorrect extent in return value of\"\n-\t\t\t       \" MINLOC intrinsic in dimension %ld:\"\n-\t\t\t       \" is %ld, should be %ld\", (long int) n + 1,\n-\t\t\t       (long int) ret_extent, (long int) extent[n]);\n-\t    }\n-\t}\n+\tbounds_ifunction_return ((array_t *) retarray, extent,\n+\t\t\t\t \"return value\", \"MINLOC\");\n     }\n \n   for (n = 0; n < rank; n++)\n@@ -313,29 +302,10 @@ mminloc1_8_i4 (gfc_array_i8 * const restrict retarray,\n \n       if (unlikely (compile_options.bounds_check))\n \t{\n-\t  for (n=0; n < rank; n++)\n-\t    {\n-\t      index_type ret_extent;\n-\n-\t      ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,n);\n-\t      if (extent[n] != ret_extent)\n-\t\truntime_error (\"Incorrect extent in return value of\"\n-\t\t\t       \" MINLOC intrinsic in dimension %ld:\"\n-\t\t\t       \" is %ld, should be %ld\", (long int) n + 1,\n-\t\t\t       (long int) ret_extent, (long int) extent[n]);\n-\t    }\n-          for (n=0; n<= rank; n++)\n-            {\n-              index_type mask_extent, array_extent;\n-\n-\t      array_extent = GFC_DESCRIPTOR_EXTENT(array,n);\n-\t      mask_extent = GFC_DESCRIPTOR_EXTENT(mask,n);\n-\t      if (array_extent != mask_extent)\n-\t\truntime_error (\"Incorrect extent in MASK argument of\"\n-\t\t\t       \" MINLOC intrinsic in dimension %ld:\"\n-\t\t\t       \" is %ld, should be %ld\", (long int) n + 1,\n-\t\t\t       (long int) mask_extent, (long int) array_extent);\n-\t    }\n+\t  bounds_ifunction_return ((array_t *) retarray, extent,\n+\t\t\t\t   \"return value\", \"MINLOC\");\n+\t  bounds_equal_extents ((array_t *) mask, (array_t *) array,\n+\t  \t\t\t\"MASK argument\", \"MINLOC\");\n \t}\n     }\n "}, {"sha": "dc1c1fff4d24f9bd9cc505cabf550b1efcde764f", "filename": "libgfortran/generated/minloc1_8_i8.c", "status": "modified", "additions": 6, "deletions": 36, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/16bff92192676901670042cdce3fbd5f9c928fc8/libgfortran%2Fgenerated%2Fminloc1_8_i8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/16bff92192676901670042cdce3fbd5f9c928fc8/libgfortran%2Fgenerated%2Fminloc1_8_i8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminloc1_8_i8.c?ref=16bff92192676901670042cdce3fbd5f9c928fc8", "patch": "@@ -120,19 +120,8 @@ minloc1_8_i8 (gfc_array_i8 * const restrict retarray,\n \t\t       (long int) rank);\n \n       if (unlikely (compile_options.bounds_check))\n-\t{\n-\t  for (n=0; n < rank; n++)\n-\t    {\n-\t      index_type ret_extent;\n-\n-\t      ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,n);\n-\t      if (extent[n] != ret_extent)\n-\t\truntime_error (\"Incorrect extent in return value of\"\n-\t\t\t       \" MINLOC intrinsic in dimension %ld:\"\n-\t\t\t       \" is %ld, should be %ld\", (long int) n + 1,\n-\t\t\t       (long int) ret_extent, (long int) extent[n]);\n-\t    }\n-\t}\n+\tbounds_ifunction_return ((array_t *) retarray, extent,\n+\t\t\t\t \"return value\", \"MINLOC\");\n     }\n \n   for (n = 0; n < rank; n++)\n@@ -313,29 +302,10 @@ mminloc1_8_i8 (gfc_array_i8 * const restrict retarray,\n \n       if (unlikely (compile_options.bounds_check))\n \t{\n-\t  for (n=0; n < rank; n++)\n-\t    {\n-\t      index_type ret_extent;\n-\n-\t      ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,n);\n-\t      if (extent[n] != ret_extent)\n-\t\truntime_error (\"Incorrect extent in return value of\"\n-\t\t\t       \" MINLOC intrinsic in dimension %ld:\"\n-\t\t\t       \" is %ld, should be %ld\", (long int) n + 1,\n-\t\t\t       (long int) ret_extent, (long int) extent[n]);\n-\t    }\n-          for (n=0; n<= rank; n++)\n-            {\n-              index_type mask_extent, array_extent;\n-\n-\t      array_extent = GFC_DESCRIPTOR_EXTENT(array,n);\n-\t      mask_extent = GFC_DESCRIPTOR_EXTENT(mask,n);\n-\t      if (array_extent != mask_extent)\n-\t\truntime_error (\"Incorrect extent in MASK argument of\"\n-\t\t\t       \" MINLOC intrinsic in dimension %ld:\"\n-\t\t\t       \" is %ld, should be %ld\", (long int) n + 1,\n-\t\t\t       (long int) mask_extent, (long int) array_extent);\n-\t    }\n+\t  bounds_ifunction_return ((array_t *) retarray, extent,\n+\t\t\t\t   \"return value\", \"MINLOC\");\n+\t  bounds_equal_extents ((array_t *) mask, (array_t *) array,\n+\t  \t\t\t\"MASK argument\", \"MINLOC\");\n \t}\n     }\n "}, {"sha": "15f22542ec2a697932335b27aa0a4200c8418f1d", "filename": "libgfortran/generated/minloc1_8_r10.c", "status": "modified", "additions": 6, "deletions": 36, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/16bff92192676901670042cdce3fbd5f9c928fc8/libgfortran%2Fgenerated%2Fminloc1_8_r10.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/16bff92192676901670042cdce3fbd5f9c928fc8/libgfortran%2Fgenerated%2Fminloc1_8_r10.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminloc1_8_r10.c?ref=16bff92192676901670042cdce3fbd5f9c928fc8", "patch": "@@ -120,19 +120,8 @@ minloc1_8_r10 (gfc_array_i8 * const restrict retarray,\n \t\t       (long int) rank);\n \n       if (unlikely (compile_options.bounds_check))\n-\t{\n-\t  for (n=0; n < rank; n++)\n-\t    {\n-\t      index_type ret_extent;\n-\n-\t      ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,n);\n-\t      if (extent[n] != ret_extent)\n-\t\truntime_error (\"Incorrect extent in return value of\"\n-\t\t\t       \" MINLOC intrinsic in dimension %ld:\"\n-\t\t\t       \" is %ld, should be %ld\", (long int) n + 1,\n-\t\t\t       (long int) ret_extent, (long int) extent[n]);\n-\t    }\n-\t}\n+\tbounds_ifunction_return ((array_t *) retarray, extent,\n+\t\t\t\t \"return value\", \"MINLOC\");\n     }\n \n   for (n = 0; n < rank; n++)\n@@ -313,29 +302,10 @@ mminloc1_8_r10 (gfc_array_i8 * const restrict retarray,\n \n       if (unlikely (compile_options.bounds_check))\n \t{\n-\t  for (n=0; n < rank; n++)\n-\t    {\n-\t      index_type ret_extent;\n-\n-\t      ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,n);\n-\t      if (extent[n] != ret_extent)\n-\t\truntime_error (\"Incorrect extent in return value of\"\n-\t\t\t       \" MINLOC intrinsic in dimension %ld:\"\n-\t\t\t       \" is %ld, should be %ld\", (long int) n + 1,\n-\t\t\t       (long int) ret_extent, (long int) extent[n]);\n-\t    }\n-          for (n=0; n<= rank; n++)\n-            {\n-              index_type mask_extent, array_extent;\n-\n-\t      array_extent = GFC_DESCRIPTOR_EXTENT(array,n);\n-\t      mask_extent = GFC_DESCRIPTOR_EXTENT(mask,n);\n-\t      if (array_extent != mask_extent)\n-\t\truntime_error (\"Incorrect extent in MASK argument of\"\n-\t\t\t       \" MINLOC intrinsic in dimension %ld:\"\n-\t\t\t       \" is %ld, should be %ld\", (long int) n + 1,\n-\t\t\t       (long int) mask_extent, (long int) array_extent);\n-\t    }\n+\t  bounds_ifunction_return ((array_t *) retarray, extent,\n+\t\t\t\t   \"return value\", \"MINLOC\");\n+\t  bounds_equal_extents ((array_t *) mask, (array_t *) array,\n+\t  \t\t\t\"MASK argument\", \"MINLOC\");\n \t}\n     }\n "}, {"sha": "64d1b26a7ee887d5432ea50365b2289647a88ae9", "filename": "libgfortran/generated/minloc1_8_r16.c", "status": "modified", "additions": 6, "deletions": 36, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/16bff92192676901670042cdce3fbd5f9c928fc8/libgfortran%2Fgenerated%2Fminloc1_8_r16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/16bff92192676901670042cdce3fbd5f9c928fc8/libgfortran%2Fgenerated%2Fminloc1_8_r16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminloc1_8_r16.c?ref=16bff92192676901670042cdce3fbd5f9c928fc8", "patch": "@@ -120,19 +120,8 @@ minloc1_8_r16 (gfc_array_i8 * const restrict retarray,\n \t\t       (long int) rank);\n \n       if (unlikely (compile_options.bounds_check))\n-\t{\n-\t  for (n=0; n < rank; n++)\n-\t    {\n-\t      index_type ret_extent;\n-\n-\t      ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,n);\n-\t      if (extent[n] != ret_extent)\n-\t\truntime_error (\"Incorrect extent in return value of\"\n-\t\t\t       \" MINLOC intrinsic in dimension %ld:\"\n-\t\t\t       \" is %ld, should be %ld\", (long int) n + 1,\n-\t\t\t       (long int) ret_extent, (long int) extent[n]);\n-\t    }\n-\t}\n+\tbounds_ifunction_return ((array_t *) retarray, extent,\n+\t\t\t\t \"return value\", \"MINLOC\");\n     }\n \n   for (n = 0; n < rank; n++)\n@@ -313,29 +302,10 @@ mminloc1_8_r16 (gfc_array_i8 * const restrict retarray,\n \n       if (unlikely (compile_options.bounds_check))\n \t{\n-\t  for (n=0; n < rank; n++)\n-\t    {\n-\t      index_type ret_extent;\n-\n-\t      ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,n);\n-\t      if (extent[n] != ret_extent)\n-\t\truntime_error (\"Incorrect extent in return value of\"\n-\t\t\t       \" MINLOC intrinsic in dimension %ld:\"\n-\t\t\t       \" is %ld, should be %ld\", (long int) n + 1,\n-\t\t\t       (long int) ret_extent, (long int) extent[n]);\n-\t    }\n-          for (n=0; n<= rank; n++)\n-            {\n-              index_type mask_extent, array_extent;\n-\n-\t      array_extent = GFC_DESCRIPTOR_EXTENT(array,n);\n-\t      mask_extent = GFC_DESCRIPTOR_EXTENT(mask,n);\n-\t      if (array_extent != mask_extent)\n-\t\truntime_error (\"Incorrect extent in MASK argument of\"\n-\t\t\t       \" MINLOC intrinsic in dimension %ld:\"\n-\t\t\t       \" is %ld, should be %ld\", (long int) n + 1,\n-\t\t\t       (long int) mask_extent, (long int) array_extent);\n-\t    }\n+\t  bounds_ifunction_return ((array_t *) retarray, extent,\n+\t\t\t\t   \"return value\", \"MINLOC\");\n+\t  bounds_equal_extents ((array_t *) mask, (array_t *) array,\n+\t  \t\t\t\"MASK argument\", \"MINLOC\");\n \t}\n     }\n "}, {"sha": "00977886a97996fcaee20e9529ec629e5007d432", "filename": "libgfortran/generated/minloc1_8_r4.c", "status": "modified", "additions": 6, "deletions": 36, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/16bff92192676901670042cdce3fbd5f9c928fc8/libgfortran%2Fgenerated%2Fminloc1_8_r4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/16bff92192676901670042cdce3fbd5f9c928fc8/libgfortran%2Fgenerated%2Fminloc1_8_r4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminloc1_8_r4.c?ref=16bff92192676901670042cdce3fbd5f9c928fc8", "patch": "@@ -120,19 +120,8 @@ minloc1_8_r4 (gfc_array_i8 * const restrict retarray,\n \t\t       (long int) rank);\n \n       if (unlikely (compile_options.bounds_check))\n-\t{\n-\t  for (n=0; n < rank; n++)\n-\t    {\n-\t      index_type ret_extent;\n-\n-\t      ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,n);\n-\t      if (extent[n] != ret_extent)\n-\t\truntime_error (\"Incorrect extent in return value of\"\n-\t\t\t       \" MINLOC intrinsic in dimension %ld:\"\n-\t\t\t       \" is %ld, should be %ld\", (long int) n + 1,\n-\t\t\t       (long int) ret_extent, (long int) extent[n]);\n-\t    }\n-\t}\n+\tbounds_ifunction_return ((array_t *) retarray, extent,\n+\t\t\t\t \"return value\", \"MINLOC\");\n     }\n \n   for (n = 0; n < rank; n++)\n@@ -313,29 +302,10 @@ mminloc1_8_r4 (gfc_array_i8 * const restrict retarray,\n \n       if (unlikely (compile_options.bounds_check))\n \t{\n-\t  for (n=0; n < rank; n++)\n-\t    {\n-\t      index_type ret_extent;\n-\n-\t      ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,n);\n-\t      if (extent[n] != ret_extent)\n-\t\truntime_error (\"Incorrect extent in return value of\"\n-\t\t\t       \" MINLOC intrinsic in dimension %ld:\"\n-\t\t\t       \" is %ld, should be %ld\", (long int) n + 1,\n-\t\t\t       (long int) ret_extent, (long int) extent[n]);\n-\t    }\n-          for (n=0; n<= rank; n++)\n-            {\n-              index_type mask_extent, array_extent;\n-\n-\t      array_extent = GFC_DESCRIPTOR_EXTENT(array,n);\n-\t      mask_extent = GFC_DESCRIPTOR_EXTENT(mask,n);\n-\t      if (array_extent != mask_extent)\n-\t\truntime_error (\"Incorrect extent in MASK argument of\"\n-\t\t\t       \" MINLOC intrinsic in dimension %ld:\"\n-\t\t\t       \" is %ld, should be %ld\", (long int) n + 1,\n-\t\t\t       (long int) mask_extent, (long int) array_extent);\n-\t    }\n+\t  bounds_ifunction_return ((array_t *) retarray, extent,\n+\t\t\t\t   \"return value\", \"MINLOC\");\n+\t  bounds_equal_extents ((array_t *) mask, (array_t *) array,\n+\t  \t\t\t\"MASK argument\", \"MINLOC\");\n \t}\n     }\n "}, {"sha": "05359143142170987fd4e04fc5db3e93aa825d03", "filename": "libgfortran/generated/minloc1_8_r8.c", "status": "modified", "additions": 6, "deletions": 36, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/16bff92192676901670042cdce3fbd5f9c928fc8/libgfortran%2Fgenerated%2Fminloc1_8_r8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/16bff92192676901670042cdce3fbd5f9c928fc8/libgfortran%2Fgenerated%2Fminloc1_8_r8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminloc1_8_r8.c?ref=16bff92192676901670042cdce3fbd5f9c928fc8", "patch": "@@ -120,19 +120,8 @@ minloc1_8_r8 (gfc_array_i8 * const restrict retarray,\n \t\t       (long int) rank);\n \n       if (unlikely (compile_options.bounds_check))\n-\t{\n-\t  for (n=0; n < rank; n++)\n-\t    {\n-\t      index_type ret_extent;\n-\n-\t      ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,n);\n-\t      if (extent[n] != ret_extent)\n-\t\truntime_error (\"Incorrect extent in return value of\"\n-\t\t\t       \" MINLOC intrinsic in dimension %ld:\"\n-\t\t\t       \" is %ld, should be %ld\", (long int) n + 1,\n-\t\t\t       (long int) ret_extent, (long int) extent[n]);\n-\t    }\n-\t}\n+\tbounds_ifunction_return ((array_t *) retarray, extent,\n+\t\t\t\t \"return value\", \"MINLOC\");\n     }\n \n   for (n = 0; n < rank; n++)\n@@ -313,29 +302,10 @@ mminloc1_8_r8 (gfc_array_i8 * const restrict retarray,\n \n       if (unlikely (compile_options.bounds_check))\n \t{\n-\t  for (n=0; n < rank; n++)\n-\t    {\n-\t      index_type ret_extent;\n-\n-\t      ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,n);\n-\t      if (extent[n] != ret_extent)\n-\t\truntime_error (\"Incorrect extent in return value of\"\n-\t\t\t       \" MINLOC intrinsic in dimension %ld:\"\n-\t\t\t       \" is %ld, should be %ld\", (long int) n + 1,\n-\t\t\t       (long int) ret_extent, (long int) extent[n]);\n-\t    }\n-          for (n=0; n<= rank; n++)\n-            {\n-              index_type mask_extent, array_extent;\n-\n-\t      array_extent = GFC_DESCRIPTOR_EXTENT(array,n);\n-\t      mask_extent = GFC_DESCRIPTOR_EXTENT(mask,n);\n-\t      if (array_extent != mask_extent)\n-\t\truntime_error (\"Incorrect extent in MASK argument of\"\n-\t\t\t       \" MINLOC intrinsic in dimension %ld:\"\n-\t\t\t       \" is %ld, should be %ld\", (long int) n + 1,\n-\t\t\t       (long int) mask_extent, (long int) array_extent);\n-\t    }\n+\t  bounds_ifunction_return ((array_t *) retarray, extent,\n+\t\t\t\t   \"return value\", \"MINLOC\");\n+\t  bounds_equal_extents ((array_t *) mask, (array_t *) array,\n+\t  \t\t\t\"MASK argument\", \"MINLOC\");\n \t}\n     }\n "}, {"sha": "3f1c0a535715e7c6555914c31da1c1f892b46a2e", "filename": "libgfortran/generated/minval_i1.c", "status": "modified", "additions": 6, "deletions": 36, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/16bff92192676901670042cdce3fbd5f9c928fc8/libgfortran%2Fgenerated%2Fminval_i1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/16bff92192676901670042cdce3fbd5f9c928fc8/libgfortran%2Fgenerated%2Fminval_i1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminval_i1.c?ref=16bff92192676901670042cdce3fbd5f9c928fc8", "patch": "@@ -119,19 +119,8 @@ minval_i1 (gfc_array_i1 * const restrict retarray,\n \t\t       (long int) rank);\n \n       if (unlikely (compile_options.bounds_check))\n-\t{\n-\t  for (n=0; n < rank; n++)\n-\t    {\n-\t      index_type ret_extent;\n-\n-\t      ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,n);\n-\t      if (extent[n] != ret_extent)\n-\t\truntime_error (\"Incorrect extent in return value of\"\n-\t\t\t       \" MINVAL intrinsic in dimension %ld:\"\n-\t\t\t       \" is %ld, should be %ld\", (long int) n + 1,\n-\t\t\t       (long int) ret_extent, (long int) extent[n]);\n-\t    }\n-\t}\n+\tbounds_ifunction_return ((array_t *) retarray, extent,\n+\t\t\t\t \"return value\", \"MINVAL\");\n     }\n \n   for (n = 0; n < rank; n++)\n@@ -307,29 +296,10 @@ mminval_i1 (gfc_array_i1 * const restrict retarray,\n \n       if (unlikely (compile_options.bounds_check))\n \t{\n-\t  for (n=0; n < rank; n++)\n-\t    {\n-\t      index_type ret_extent;\n-\n-\t      ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,n);\n-\t      if (extent[n] != ret_extent)\n-\t\truntime_error (\"Incorrect extent in return value of\"\n-\t\t\t       \" MINVAL intrinsic in dimension %ld:\"\n-\t\t\t       \" is %ld, should be %ld\", (long int) n + 1,\n-\t\t\t       (long int) ret_extent, (long int) extent[n]);\n-\t    }\n-          for (n=0; n<= rank; n++)\n-            {\n-              index_type mask_extent, array_extent;\n-\n-\t      array_extent = GFC_DESCRIPTOR_EXTENT(array,n);\n-\t      mask_extent = GFC_DESCRIPTOR_EXTENT(mask,n);\n-\t      if (array_extent != mask_extent)\n-\t\truntime_error (\"Incorrect extent in MASK argument of\"\n-\t\t\t       \" MINVAL intrinsic in dimension %ld:\"\n-\t\t\t       \" is %ld, should be %ld\", (long int) n + 1,\n-\t\t\t       (long int) mask_extent, (long int) array_extent);\n-\t    }\n+\t  bounds_ifunction_return ((array_t *) retarray, extent,\n+\t\t\t\t   \"return value\", \"MINVAL\");\n+\t  bounds_equal_extents ((array_t *) mask, (array_t *) array,\n+\t  \t\t\t\"MASK argument\", \"MINVAL\");\n \t}\n     }\n "}, {"sha": "6d0f20a7ea5bdd448f8cdacf2705042408ccaec5", "filename": "libgfortran/generated/minval_i16.c", "status": "modified", "additions": 6, "deletions": 36, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/16bff92192676901670042cdce3fbd5f9c928fc8/libgfortran%2Fgenerated%2Fminval_i16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/16bff92192676901670042cdce3fbd5f9c928fc8/libgfortran%2Fgenerated%2Fminval_i16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminval_i16.c?ref=16bff92192676901670042cdce3fbd5f9c928fc8", "patch": "@@ -119,19 +119,8 @@ minval_i16 (gfc_array_i16 * const restrict retarray,\n \t\t       (long int) rank);\n \n       if (unlikely (compile_options.bounds_check))\n-\t{\n-\t  for (n=0; n < rank; n++)\n-\t    {\n-\t      index_type ret_extent;\n-\n-\t      ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,n);\n-\t      if (extent[n] != ret_extent)\n-\t\truntime_error (\"Incorrect extent in return value of\"\n-\t\t\t       \" MINVAL intrinsic in dimension %ld:\"\n-\t\t\t       \" is %ld, should be %ld\", (long int) n + 1,\n-\t\t\t       (long int) ret_extent, (long int) extent[n]);\n-\t    }\n-\t}\n+\tbounds_ifunction_return ((array_t *) retarray, extent,\n+\t\t\t\t \"return value\", \"MINVAL\");\n     }\n \n   for (n = 0; n < rank; n++)\n@@ -307,29 +296,10 @@ mminval_i16 (gfc_array_i16 * const restrict retarray,\n \n       if (unlikely (compile_options.bounds_check))\n \t{\n-\t  for (n=0; n < rank; n++)\n-\t    {\n-\t      index_type ret_extent;\n-\n-\t      ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,n);\n-\t      if (extent[n] != ret_extent)\n-\t\truntime_error (\"Incorrect extent in return value of\"\n-\t\t\t       \" MINVAL intrinsic in dimension %ld:\"\n-\t\t\t       \" is %ld, should be %ld\", (long int) n + 1,\n-\t\t\t       (long int) ret_extent, (long int) extent[n]);\n-\t    }\n-          for (n=0; n<= rank; n++)\n-            {\n-              index_type mask_extent, array_extent;\n-\n-\t      array_extent = GFC_DESCRIPTOR_EXTENT(array,n);\n-\t      mask_extent = GFC_DESCRIPTOR_EXTENT(mask,n);\n-\t      if (array_extent != mask_extent)\n-\t\truntime_error (\"Incorrect extent in MASK argument of\"\n-\t\t\t       \" MINVAL intrinsic in dimension %ld:\"\n-\t\t\t       \" is %ld, should be %ld\", (long int) n + 1,\n-\t\t\t       (long int) mask_extent, (long int) array_extent);\n-\t    }\n+\t  bounds_ifunction_return ((array_t *) retarray, extent,\n+\t\t\t\t   \"return value\", \"MINVAL\");\n+\t  bounds_equal_extents ((array_t *) mask, (array_t *) array,\n+\t  \t\t\t\"MASK argument\", \"MINVAL\");\n \t}\n     }\n "}, {"sha": "c09e4535450755fd03fa276c1b9506fcce3e4eb7", "filename": "libgfortran/generated/minval_i2.c", "status": "modified", "additions": 6, "deletions": 36, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/16bff92192676901670042cdce3fbd5f9c928fc8/libgfortran%2Fgenerated%2Fminval_i2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/16bff92192676901670042cdce3fbd5f9c928fc8/libgfortran%2Fgenerated%2Fminval_i2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminval_i2.c?ref=16bff92192676901670042cdce3fbd5f9c928fc8", "patch": "@@ -119,19 +119,8 @@ minval_i2 (gfc_array_i2 * const restrict retarray,\n \t\t       (long int) rank);\n \n       if (unlikely (compile_options.bounds_check))\n-\t{\n-\t  for (n=0; n < rank; n++)\n-\t    {\n-\t      index_type ret_extent;\n-\n-\t      ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,n);\n-\t      if (extent[n] != ret_extent)\n-\t\truntime_error (\"Incorrect extent in return value of\"\n-\t\t\t       \" MINVAL intrinsic in dimension %ld:\"\n-\t\t\t       \" is %ld, should be %ld\", (long int) n + 1,\n-\t\t\t       (long int) ret_extent, (long int) extent[n]);\n-\t    }\n-\t}\n+\tbounds_ifunction_return ((array_t *) retarray, extent,\n+\t\t\t\t \"return value\", \"MINVAL\");\n     }\n \n   for (n = 0; n < rank; n++)\n@@ -307,29 +296,10 @@ mminval_i2 (gfc_array_i2 * const restrict retarray,\n \n       if (unlikely (compile_options.bounds_check))\n \t{\n-\t  for (n=0; n < rank; n++)\n-\t    {\n-\t      index_type ret_extent;\n-\n-\t      ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,n);\n-\t      if (extent[n] != ret_extent)\n-\t\truntime_error (\"Incorrect extent in return value of\"\n-\t\t\t       \" MINVAL intrinsic in dimension %ld:\"\n-\t\t\t       \" is %ld, should be %ld\", (long int) n + 1,\n-\t\t\t       (long int) ret_extent, (long int) extent[n]);\n-\t    }\n-          for (n=0; n<= rank; n++)\n-            {\n-              index_type mask_extent, array_extent;\n-\n-\t      array_extent = GFC_DESCRIPTOR_EXTENT(array,n);\n-\t      mask_extent = GFC_DESCRIPTOR_EXTENT(mask,n);\n-\t      if (array_extent != mask_extent)\n-\t\truntime_error (\"Incorrect extent in MASK argument of\"\n-\t\t\t       \" MINVAL intrinsic in dimension %ld:\"\n-\t\t\t       \" is %ld, should be %ld\", (long int) n + 1,\n-\t\t\t       (long int) mask_extent, (long int) array_extent);\n-\t    }\n+\t  bounds_ifunction_return ((array_t *) retarray, extent,\n+\t\t\t\t   \"return value\", \"MINVAL\");\n+\t  bounds_equal_extents ((array_t *) mask, (array_t *) array,\n+\t  \t\t\t\"MASK argument\", \"MINVAL\");\n \t}\n     }\n "}, {"sha": "72c63705b502733fd06b7753030fff95a4531d15", "filename": "libgfortran/generated/minval_i4.c", "status": "modified", "additions": 6, "deletions": 36, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/16bff92192676901670042cdce3fbd5f9c928fc8/libgfortran%2Fgenerated%2Fminval_i4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/16bff92192676901670042cdce3fbd5f9c928fc8/libgfortran%2Fgenerated%2Fminval_i4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminval_i4.c?ref=16bff92192676901670042cdce3fbd5f9c928fc8", "patch": "@@ -119,19 +119,8 @@ minval_i4 (gfc_array_i4 * const restrict retarray,\n \t\t       (long int) rank);\n \n       if (unlikely (compile_options.bounds_check))\n-\t{\n-\t  for (n=0; n < rank; n++)\n-\t    {\n-\t      index_type ret_extent;\n-\n-\t      ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,n);\n-\t      if (extent[n] != ret_extent)\n-\t\truntime_error (\"Incorrect extent in return value of\"\n-\t\t\t       \" MINVAL intrinsic in dimension %ld:\"\n-\t\t\t       \" is %ld, should be %ld\", (long int) n + 1,\n-\t\t\t       (long int) ret_extent, (long int) extent[n]);\n-\t    }\n-\t}\n+\tbounds_ifunction_return ((array_t *) retarray, extent,\n+\t\t\t\t \"return value\", \"MINVAL\");\n     }\n \n   for (n = 0; n < rank; n++)\n@@ -307,29 +296,10 @@ mminval_i4 (gfc_array_i4 * const restrict retarray,\n \n       if (unlikely (compile_options.bounds_check))\n \t{\n-\t  for (n=0; n < rank; n++)\n-\t    {\n-\t      index_type ret_extent;\n-\n-\t      ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,n);\n-\t      if (extent[n] != ret_extent)\n-\t\truntime_error (\"Incorrect extent in return value of\"\n-\t\t\t       \" MINVAL intrinsic in dimension %ld:\"\n-\t\t\t       \" is %ld, should be %ld\", (long int) n + 1,\n-\t\t\t       (long int) ret_extent, (long int) extent[n]);\n-\t    }\n-          for (n=0; n<= rank; n++)\n-            {\n-              index_type mask_extent, array_extent;\n-\n-\t      array_extent = GFC_DESCRIPTOR_EXTENT(array,n);\n-\t      mask_extent = GFC_DESCRIPTOR_EXTENT(mask,n);\n-\t      if (array_extent != mask_extent)\n-\t\truntime_error (\"Incorrect extent in MASK argument of\"\n-\t\t\t       \" MINVAL intrinsic in dimension %ld:\"\n-\t\t\t       \" is %ld, should be %ld\", (long int) n + 1,\n-\t\t\t       (long int) mask_extent, (long int) array_extent);\n-\t    }\n+\t  bounds_ifunction_return ((array_t *) retarray, extent,\n+\t\t\t\t   \"return value\", \"MINVAL\");\n+\t  bounds_equal_extents ((array_t *) mask, (array_t *) array,\n+\t  \t\t\t\"MASK argument\", \"MINVAL\");\n \t}\n     }\n "}, {"sha": "fbdcec9c93b4a9cbead9fa4af242b54c63ecd087", "filename": "libgfortran/generated/minval_i8.c", "status": "modified", "additions": 6, "deletions": 36, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/16bff92192676901670042cdce3fbd5f9c928fc8/libgfortran%2Fgenerated%2Fminval_i8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/16bff92192676901670042cdce3fbd5f9c928fc8/libgfortran%2Fgenerated%2Fminval_i8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminval_i8.c?ref=16bff92192676901670042cdce3fbd5f9c928fc8", "patch": "@@ -119,19 +119,8 @@ minval_i8 (gfc_array_i8 * const restrict retarray,\n \t\t       (long int) rank);\n \n       if (unlikely (compile_options.bounds_check))\n-\t{\n-\t  for (n=0; n < rank; n++)\n-\t    {\n-\t      index_type ret_extent;\n-\n-\t      ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,n);\n-\t      if (extent[n] != ret_extent)\n-\t\truntime_error (\"Incorrect extent in return value of\"\n-\t\t\t       \" MINVAL intrinsic in dimension %ld:\"\n-\t\t\t       \" is %ld, should be %ld\", (long int) n + 1,\n-\t\t\t       (long int) ret_extent, (long int) extent[n]);\n-\t    }\n-\t}\n+\tbounds_ifunction_return ((array_t *) retarray, extent,\n+\t\t\t\t \"return value\", \"MINVAL\");\n     }\n \n   for (n = 0; n < rank; n++)\n@@ -307,29 +296,10 @@ mminval_i8 (gfc_array_i8 * const restrict retarray,\n \n       if (unlikely (compile_options.bounds_check))\n \t{\n-\t  for (n=0; n < rank; n++)\n-\t    {\n-\t      index_type ret_extent;\n-\n-\t      ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,n);\n-\t      if (extent[n] != ret_extent)\n-\t\truntime_error (\"Incorrect extent in return value of\"\n-\t\t\t       \" MINVAL intrinsic in dimension %ld:\"\n-\t\t\t       \" is %ld, should be %ld\", (long int) n + 1,\n-\t\t\t       (long int) ret_extent, (long int) extent[n]);\n-\t    }\n-          for (n=0; n<= rank; n++)\n-            {\n-              index_type mask_extent, array_extent;\n-\n-\t      array_extent = GFC_DESCRIPTOR_EXTENT(array,n);\n-\t      mask_extent = GFC_DESCRIPTOR_EXTENT(mask,n);\n-\t      if (array_extent != mask_extent)\n-\t\truntime_error (\"Incorrect extent in MASK argument of\"\n-\t\t\t       \" MINVAL intrinsic in dimension %ld:\"\n-\t\t\t       \" is %ld, should be %ld\", (long int) n + 1,\n-\t\t\t       (long int) mask_extent, (long int) array_extent);\n-\t    }\n+\t  bounds_ifunction_return ((array_t *) retarray, extent,\n+\t\t\t\t   \"return value\", \"MINVAL\");\n+\t  bounds_equal_extents ((array_t *) mask, (array_t *) array,\n+\t  \t\t\t\"MASK argument\", \"MINVAL\");\n \t}\n     }\n "}, {"sha": "8e1ba75654807e65a020df3da5bc56567119ca8d", "filename": "libgfortran/generated/minval_r10.c", "status": "modified", "additions": 6, "deletions": 36, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/16bff92192676901670042cdce3fbd5f9c928fc8/libgfortran%2Fgenerated%2Fminval_r10.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/16bff92192676901670042cdce3fbd5f9c928fc8/libgfortran%2Fgenerated%2Fminval_r10.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminval_r10.c?ref=16bff92192676901670042cdce3fbd5f9c928fc8", "patch": "@@ -119,19 +119,8 @@ minval_r10 (gfc_array_r10 * const restrict retarray,\n \t\t       (long int) rank);\n \n       if (unlikely (compile_options.bounds_check))\n-\t{\n-\t  for (n=0; n < rank; n++)\n-\t    {\n-\t      index_type ret_extent;\n-\n-\t      ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,n);\n-\t      if (extent[n] != ret_extent)\n-\t\truntime_error (\"Incorrect extent in return value of\"\n-\t\t\t       \" MINVAL intrinsic in dimension %ld:\"\n-\t\t\t       \" is %ld, should be %ld\", (long int) n + 1,\n-\t\t\t       (long int) ret_extent, (long int) extent[n]);\n-\t    }\n-\t}\n+\tbounds_ifunction_return ((array_t *) retarray, extent,\n+\t\t\t\t \"return value\", \"MINVAL\");\n     }\n \n   for (n = 0; n < rank; n++)\n@@ -307,29 +296,10 @@ mminval_r10 (gfc_array_r10 * const restrict retarray,\n \n       if (unlikely (compile_options.bounds_check))\n \t{\n-\t  for (n=0; n < rank; n++)\n-\t    {\n-\t      index_type ret_extent;\n-\n-\t      ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,n);\n-\t      if (extent[n] != ret_extent)\n-\t\truntime_error (\"Incorrect extent in return value of\"\n-\t\t\t       \" MINVAL intrinsic in dimension %ld:\"\n-\t\t\t       \" is %ld, should be %ld\", (long int) n + 1,\n-\t\t\t       (long int) ret_extent, (long int) extent[n]);\n-\t    }\n-          for (n=0; n<= rank; n++)\n-            {\n-              index_type mask_extent, array_extent;\n-\n-\t      array_extent = GFC_DESCRIPTOR_EXTENT(array,n);\n-\t      mask_extent = GFC_DESCRIPTOR_EXTENT(mask,n);\n-\t      if (array_extent != mask_extent)\n-\t\truntime_error (\"Incorrect extent in MASK argument of\"\n-\t\t\t       \" MINVAL intrinsic in dimension %ld:\"\n-\t\t\t       \" is %ld, should be %ld\", (long int) n + 1,\n-\t\t\t       (long int) mask_extent, (long int) array_extent);\n-\t    }\n+\t  bounds_ifunction_return ((array_t *) retarray, extent,\n+\t\t\t\t   \"return value\", \"MINVAL\");\n+\t  bounds_equal_extents ((array_t *) mask, (array_t *) array,\n+\t  \t\t\t\"MASK argument\", \"MINVAL\");\n \t}\n     }\n "}, {"sha": "b028029583cd70533295409b6043bb1ff0a953ec", "filename": "libgfortran/generated/minval_r16.c", "status": "modified", "additions": 6, "deletions": 36, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/16bff92192676901670042cdce3fbd5f9c928fc8/libgfortran%2Fgenerated%2Fminval_r16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/16bff92192676901670042cdce3fbd5f9c928fc8/libgfortran%2Fgenerated%2Fminval_r16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminval_r16.c?ref=16bff92192676901670042cdce3fbd5f9c928fc8", "patch": "@@ -119,19 +119,8 @@ minval_r16 (gfc_array_r16 * const restrict retarray,\n \t\t       (long int) rank);\n \n       if (unlikely (compile_options.bounds_check))\n-\t{\n-\t  for (n=0; n < rank; n++)\n-\t    {\n-\t      index_type ret_extent;\n-\n-\t      ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,n);\n-\t      if (extent[n] != ret_extent)\n-\t\truntime_error (\"Incorrect extent in return value of\"\n-\t\t\t       \" MINVAL intrinsic in dimension %ld:\"\n-\t\t\t       \" is %ld, should be %ld\", (long int) n + 1,\n-\t\t\t       (long int) ret_extent, (long int) extent[n]);\n-\t    }\n-\t}\n+\tbounds_ifunction_return ((array_t *) retarray, extent,\n+\t\t\t\t \"return value\", \"MINVAL\");\n     }\n \n   for (n = 0; n < rank; n++)\n@@ -307,29 +296,10 @@ mminval_r16 (gfc_array_r16 * const restrict retarray,\n \n       if (unlikely (compile_options.bounds_check))\n \t{\n-\t  for (n=0; n < rank; n++)\n-\t    {\n-\t      index_type ret_extent;\n-\n-\t      ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,n);\n-\t      if (extent[n] != ret_extent)\n-\t\truntime_error (\"Incorrect extent in return value of\"\n-\t\t\t       \" MINVAL intrinsic in dimension %ld:\"\n-\t\t\t       \" is %ld, should be %ld\", (long int) n + 1,\n-\t\t\t       (long int) ret_extent, (long int) extent[n]);\n-\t    }\n-          for (n=0; n<= rank; n++)\n-            {\n-              index_type mask_extent, array_extent;\n-\n-\t      array_extent = GFC_DESCRIPTOR_EXTENT(array,n);\n-\t      mask_extent = GFC_DESCRIPTOR_EXTENT(mask,n);\n-\t      if (array_extent != mask_extent)\n-\t\truntime_error (\"Incorrect extent in MASK argument of\"\n-\t\t\t       \" MINVAL intrinsic in dimension %ld:\"\n-\t\t\t       \" is %ld, should be %ld\", (long int) n + 1,\n-\t\t\t       (long int) mask_extent, (long int) array_extent);\n-\t    }\n+\t  bounds_ifunction_return ((array_t *) retarray, extent,\n+\t\t\t\t   \"return value\", \"MINVAL\");\n+\t  bounds_equal_extents ((array_t *) mask, (array_t *) array,\n+\t  \t\t\t\"MASK argument\", \"MINVAL\");\n \t}\n     }\n "}, {"sha": "d0236848eb19729420f9824fd3201413be1b0a69", "filename": "libgfortran/generated/minval_r4.c", "status": "modified", "additions": 6, "deletions": 36, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/16bff92192676901670042cdce3fbd5f9c928fc8/libgfortran%2Fgenerated%2Fminval_r4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/16bff92192676901670042cdce3fbd5f9c928fc8/libgfortran%2Fgenerated%2Fminval_r4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminval_r4.c?ref=16bff92192676901670042cdce3fbd5f9c928fc8", "patch": "@@ -119,19 +119,8 @@ minval_r4 (gfc_array_r4 * const restrict retarray,\n \t\t       (long int) rank);\n \n       if (unlikely (compile_options.bounds_check))\n-\t{\n-\t  for (n=0; n < rank; n++)\n-\t    {\n-\t      index_type ret_extent;\n-\n-\t      ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,n);\n-\t      if (extent[n] != ret_extent)\n-\t\truntime_error (\"Incorrect extent in return value of\"\n-\t\t\t       \" MINVAL intrinsic in dimension %ld:\"\n-\t\t\t       \" is %ld, should be %ld\", (long int) n + 1,\n-\t\t\t       (long int) ret_extent, (long int) extent[n]);\n-\t    }\n-\t}\n+\tbounds_ifunction_return ((array_t *) retarray, extent,\n+\t\t\t\t \"return value\", \"MINVAL\");\n     }\n \n   for (n = 0; n < rank; n++)\n@@ -307,29 +296,10 @@ mminval_r4 (gfc_array_r4 * const restrict retarray,\n \n       if (unlikely (compile_options.bounds_check))\n \t{\n-\t  for (n=0; n < rank; n++)\n-\t    {\n-\t      index_type ret_extent;\n-\n-\t      ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,n);\n-\t      if (extent[n] != ret_extent)\n-\t\truntime_error (\"Incorrect extent in return value of\"\n-\t\t\t       \" MINVAL intrinsic in dimension %ld:\"\n-\t\t\t       \" is %ld, should be %ld\", (long int) n + 1,\n-\t\t\t       (long int) ret_extent, (long int) extent[n]);\n-\t    }\n-          for (n=0; n<= rank; n++)\n-            {\n-              index_type mask_extent, array_extent;\n-\n-\t      array_extent = GFC_DESCRIPTOR_EXTENT(array,n);\n-\t      mask_extent = GFC_DESCRIPTOR_EXTENT(mask,n);\n-\t      if (array_extent != mask_extent)\n-\t\truntime_error (\"Incorrect extent in MASK argument of\"\n-\t\t\t       \" MINVAL intrinsic in dimension %ld:\"\n-\t\t\t       \" is %ld, should be %ld\", (long int) n + 1,\n-\t\t\t       (long int) mask_extent, (long int) array_extent);\n-\t    }\n+\t  bounds_ifunction_return ((array_t *) retarray, extent,\n+\t\t\t\t   \"return value\", \"MINVAL\");\n+\t  bounds_equal_extents ((array_t *) mask, (array_t *) array,\n+\t  \t\t\t\"MASK argument\", \"MINVAL\");\n \t}\n     }\n "}, {"sha": "a86ce9403e07bf21d4d63302652c4b28ec0ab1cf", "filename": "libgfortran/generated/minval_r8.c", "status": "modified", "additions": 6, "deletions": 36, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/16bff92192676901670042cdce3fbd5f9c928fc8/libgfortran%2Fgenerated%2Fminval_r8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/16bff92192676901670042cdce3fbd5f9c928fc8/libgfortran%2Fgenerated%2Fminval_r8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminval_r8.c?ref=16bff92192676901670042cdce3fbd5f9c928fc8", "patch": "@@ -119,19 +119,8 @@ minval_r8 (gfc_array_r8 * const restrict retarray,\n \t\t       (long int) rank);\n \n       if (unlikely (compile_options.bounds_check))\n-\t{\n-\t  for (n=0; n < rank; n++)\n-\t    {\n-\t      index_type ret_extent;\n-\n-\t      ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,n);\n-\t      if (extent[n] != ret_extent)\n-\t\truntime_error (\"Incorrect extent in return value of\"\n-\t\t\t       \" MINVAL intrinsic in dimension %ld:\"\n-\t\t\t       \" is %ld, should be %ld\", (long int) n + 1,\n-\t\t\t       (long int) ret_extent, (long int) extent[n]);\n-\t    }\n-\t}\n+\tbounds_ifunction_return ((array_t *) retarray, extent,\n+\t\t\t\t \"return value\", \"MINVAL\");\n     }\n \n   for (n = 0; n < rank; n++)\n@@ -307,29 +296,10 @@ mminval_r8 (gfc_array_r8 * const restrict retarray,\n \n       if (unlikely (compile_options.bounds_check))\n \t{\n-\t  for (n=0; n < rank; n++)\n-\t    {\n-\t      index_type ret_extent;\n-\n-\t      ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,n);\n-\t      if (extent[n] != ret_extent)\n-\t\truntime_error (\"Incorrect extent in return value of\"\n-\t\t\t       \" MINVAL intrinsic in dimension %ld:\"\n-\t\t\t       \" is %ld, should be %ld\", (long int) n + 1,\n-\t\t\t       (long int) ret_extent, (long int) extent[n]);\n-\t    }\n-          for (n=0; n<= rank; n++)\n-            {\n-              index_type mask_extent, array_extent;\n-\n-\t      array_extent = GFC_DESCRIPTOR_EXTENT(array,n);\n-\t      mask_extent = GFC_DESCRIPTOR_EXTENT(mask,n);\n-\t      if (array_extent != mask_extent)\n-\t\truntime_error (\"Incorrect extent in MASK argument of\"\n-\t\t\t       \" MINVAL intrinsic in dimension %ld:\"\n-\t\t\t       \" is %ld, should be %ld\", (long int) n + 1,\n-\t\t\t       (long int) mask_extent, (long int) array_extent);\n-\t    }\n+\t  bounds_ifunction_return ((array_t *) retarray, extent,\n+\t\t\t\t   \"return value\", \"MINVAL\");\n+\t  bounds_equal_extents ((array_t *) mask, (array_t *) array,\n+\t  \t\t\t\"MASK argument\", \"MINVAL\");\n \t}\n     }\n "}, {"sha": "1f834f85d24315a1f55bf1672d8ee78df78f4b0b", "filename": "libgfortran/generated/product_c10.c", "status": "modified", "additions": 6, "deletions": 36, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/16bff92192676901670042cdce3fbd5f9c928fc8/libgfortran%2Fgenerated%2Fproduct_c10.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/16bff92192676901670042cdce3fbd5f9c928fc8/libgfortran%2Fgenerated%2Fproduct_c10.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fproduct_c10.c?ref=16bff92192676901670042cdce3fbd5f9c928fc8", "patch": "@@ -119,19 +119,8 @@ product_c10 (gfc_array_c10 * const restrict retarray,\n \t\t       (long int) rank);\n \n       if (unlikely (compile_options.bounds_check))\n-\t{\n-\t  for (n=0; n < rank; n++)\n-\t    {\n-\t      index_type ret_extent;\n-\n-\t      ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,n);\n-\t      if (extent[n] != ret_extent)\n-\t\truntime_error (\"Incorrect extent in return value of\"\n-\t\t\t       \" PRODUCT intrinsic in dimension %ld:\"\n-\t\t\t       \" is %ld, should be %ld\", (long int) n + 1,\n-\t\t\t       (long int) ret_extent, (long int) extent[n]);\n-\t    }\n-\t}\n+\tbounds_ifunction_return ((array_t *) retarray, extent,\n+\t\t\t\t \"return value\", \"PRODUCT\");\n     }\n \n   for (n = 0; n < rank; n++)\n@@ -306,29 +295,10 @@ mproduct_c10 (gfc_array_c10 * const restrict retarray,\n \n       if (unlikely (compile_options.bounds_check))\n \t{\n-\t  for (n=0; n < rank; n++)\n-\t    {\n-\t      index_type ret_extent;\n-\n-\t      ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,n);\n-\t      if (extent[n] != ret_extent)\n-\t\truntime_error (\"Incorrect extent in return value of\"\n-\t\t\t       \" PRODUCT intrinsic in dimension %ld:\"\n-\t\t\t       \" is %ld, should be %ld\", (long int) n + 1,\n-\t\t\t       (long int) ret_extent, (long int) extent[n]);\n-\t    }\n-          for (n=0; n<= rank; n++)\n-            {\n-              index_type mask_extent, array_extent;\n-\n-\t      array_extent = GFC_DESCRIPTOR_EXTENT(array,n);\n-\t      mask_extent = GFC_DESCRIPTOR_EXTENT(mask,n);\n-\t      if (array_extent != mask_extent)\n-\t\truntime_error (\"Incorrect extent in MASK argument of\"\n-\t\t\t       \" PRODUCT intrinsic in dimension %ld:\"\n-\t\t\t       \" is %ld, should be %ld\", (long int) n + 1,\n-\t\t\t       (long int) mask_extent, (long int) array_extent);\n-\t    }\n+\t  bounds_ifunction_return ((array_t *) retarray, extent,\n+\t\t\t\t   \"return value\", \"PRODUCT\");\n+\t  bounds_equal_extents ((array_t *) mask, (array_t *) array,\n+\t  \t\t\t\"MASK argument\", \"PRODUCT\");\n \t}\n     }\n "}, {"sha": "20119fae10f60e50ed049d5082639b7b04eb7ba4", "filename": "libgfortran/generated/product_c16.c", "status": "modified", "additions": 6, "deletions": 36, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/16bff92192676901670042cdce3fbd5f9c928fc8/libgfortran%2Fgenerated%2Fproduct_c16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/16bff92192676901670042cdce3fbd5f9c928fc8/libgfortran%2Fgenerated%2Fproduct_c16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fproduct_c16.c?ref=16bff92192676901670042cdce3fbd5f9c928fc8", "patch": "@@ -119,19 +119,8 @@ product_c16 (gfc_array_c16 * const restrict retarray,\n \t\t       (long int) rank);\n \n       if (unlikely (compile_options.bounds_check))\n-\t{\n-\t  for (n=0; n < rank; n++)\n-\t    {\n-\t      index_type ret_extent;\n-\n-\t      ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,n);\n-\t      if (extent[n] != ret_extent)\n-\t\truntime_error (\"Incorrect extent in return value of\"\n-\t\t\t       \" PRODUCT intrinsic in dimension %ld:\"\n-\t\t\t       \" is %ld, should be %ld\", (long int) n + 1,\n-\t\t\t       (long int) ret_extent, (long int) extent[n]);\n-\t    }\n-\t}\n+\tbounds_ifunction_return ((array_t *) retarray, extent,\n+\t\t\t\t \"return value\", \"PRODUCT\");\n     }\n \n   for (n = 0; n < rank; n++)\n@@ -306,29 +295,10 @@ mproduct_c16 (gfc_array_c16 * const restrict retarray,\n \n       if (unlikely (compile_options.bounds_check))\n \t{\n-\t  for (n=0; n < rank; n++)\n-\t    {\n-\t      index_type ret_extent;\n-\n-\t      ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,n);\n-\t      if (extent[n] != ret_extent)\n-\t\truntime_error (\"Incorrect extent in return value of\"\n-\t\t\t       \" PRODUCT intrinsic in dimension %ld:\"\n-\t\t\t       \" is %ld, should be %ld\", (long int) n + 1,\n-\t\t\t       (long int) ret_extent, (long int) extent[n]);\n-\t    }\n-          for (n=0; n<= rank; n++)\n-            {\n-              index_type mask_extent, array_extent;\n-\n-\t      array_extent = GFC_DESCRIPTOR_EXTENT(array,n);\n-\t      mask_extent = GFC_DESCRIPTOR_EXTENT(mask,n);\n-\t      if (array_extent != mask_extent)\n-\t\truntime_error (\"Incorrect extent in MASK argument of\"\n-\t\t\t       \" PRODUCT intrinsic in dimension %ld:\"\n-\t\t\t       \" is %ld, should be %ld\", (long int) n + 1,\n-\t\t\t       (long int) mask_extent, (long int) array_extent);\n-\t    }\n+\t  bounds_ifunction_return ((array_t *) retarray, extent,\n+\t\t\t\t   \"return value\", \"PRODUCT\");\n+\t  bounds_equal_extents ((array_t *) mask, (array_t *) array,\n+\t  \t\t\t\"MASK argument\", \"PRODUCT\");\n \t}\n     }\n "}, {"sha": "231947f34aa226d3d9f2b956338f25c4b700d59e", "filename": "libgfortran/generated/product_c4.c", "status": "modified", "additions": 6, "deletions": 36, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/16bff92192676901670042cdce3fbd5f9c928fc8/libgfortran%2Fgenerated%2Fproduct_c4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/16bff92192676901670042cdce3fbd5f9c928fc8/libgfortran%2Fgenerated%2Fproduct_c4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fproduct_c4.c?ref=16bff92192676901670042cdce3fbd5f9c928fc8", "patch": "@@ -119,19 +119,8 @@ product_c4 (gfc_array_c4 * const restrict retarray,\n \t\t       (long int) rank);\n \n       if (unlikely (compile_options.bounds_check))\n-\t{\n-\t  for (n=0; n < rank; n++)\n-\t    {\n-\t      index_type ret_extent;\n-\n-\t      ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,n);\n-\t      if (extent[n] != ret_extent)\n-\t\truntime_error (\"Incorrect extent in return value of\"\n-\t\t\t       \" PRODUCT intrinsic in dimension %ld:\"\n-\t\t\t       \" is %ld, should be %ld\", (long int) n + 1,\n-\t\t\t       (long int) ret_extent, (long int) extent[n]);\n-\t    }\n-\t}\n+\tbounds_ifunction_return ((array_t *) retarray, extent,\n+\t\t\t\t \"return value\", \"PRODUCT\");\n     }\n \n   for (n = 0; n < rank; n++)\n@@ -306,29 +295,10 @@ mproduct_c4 (gfc_array_c4 * const restrict retarray,\n \n       if (unlikely (compile_options.bounds_check))\n \t{\n-\t  for (n=0; n < rank; n++)\n-\t    {\n-\t      index_type ret_extent;\n-\n-\t      ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,n);\n-\t      if (extent[n] != ret_extent)\n-\t\truntime_error (\"Incorrect extent in return value of\"\n-\t\t\t       \" PRODUCT intrinsic in dimension %ld:\"\n-\t\t\t       \" is %ld, should be %ld\", (long int) n + 1,\n-\t\t\t       (long int) ret_extent, (long int) extent[n]);\n-\t    }\n-          for (n=0; n<= rank; n++)\n-            {\n-              index_type mask_extent, array_extent;\n-\n-\t      array_extent = GFC_DESCRIPTOR_EXTENT(array,n);\n-\t      mask_extent = GFC_DESCRIPTOR_EXTENT(mask,n);\n-\t      if (array_extent != mask_extent)\n-\t\truntime_error (\"Incorrect extent in MASK argument of\"\n-\t\t\t       \" PRODUCT intrinsic in dimension %ld:\"\n-\t\t\t       \" is %ld, should be %ld\", (long int) n + 1,\n-\t\t\t       (long int) mask_extent, (long int) array_extent);\n-\t    }\n+\t  bounds_ifunction_return ((array_t *) retarray, extent,\n+\t\t\t\t   \"return value\", \"PRODUCT\");\n+\t  bounds_equal_extents ((array_t *) mask, (array_t *) array,\n+\t  \t\t\t\"MASK argument\", \"PRODUCT\");\n \t}\n     }\n "}, {"sha": "e6f8dbbafa14c765f99f129064e1b6b41cc6ad93", "filename": "libgfortran/generated/product_c8.c", "status": "modified", "additions": 6, "deletions": 36, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/16bff92192676901670042cdce3fbd5f9c928fc8/libgfortran%2Fgenerated%2Fproduct_c8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/16bff92192676901670042cdce3fbd5f9c928fc8/libgfortran%2Fgenerated%2Fproduct_c8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fproduct_c8.c?ref=16bff92192676901670042cdce3fbd5f9c928fc8", "patch": "@@ -119,19 +119,8 @@ product_c8 (gfc_array_c8 * const restrict retarray,\n \t\t       (long int) rank);\n \n       if (unlikely (compile_options.bounds_check))\n-\t{\n-\t  for (n=0; n < rank; n++)\n-\t    {\n-\t      index_type ret_extent;\n-\n-\t      ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,n);\n-\t      if (extent[n] != ret_extent)\n-\t\truntime_error (\"Incorrect extent in return value of\"\n-\t\t\t       \" PRODUCT intrinsic in dimension %ld:\"\n-\t\t\t       \" is %ld, should be %ld\", (long int) n + 1,\n-\t\t\t       (long int) ret_extent, (long int) extent[n]);\n-\t    }\n-\t}\n+\tbounds_ifunction_return ((array_t *) retarray, extent,\n+\t\t\t\t \"return value\", \"PRODUCT\");\n     }\n \n   for (n = 0; n < rank; n++)\n@@ -306,29 +295,10 @@ mproduct_c8 (gfc_array_c8 * const restrict retarray,\n \n       if (unlikely (compile_options.bounds_check))\n \t{\n-\t  for (n=0; n < rank; n++)\n-\t    {\n-\t      index_type ret_extent;\n-\n-\t      ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,n);\n-\t      if (extent[n] != ret_extent)\n-\t\truntime_error (\"Incorrect extent in return value of\"\n-\t\t\t       \" PRODUCT intrinsic in dimension %ld:\"\n-\t\t\t       \" is %ld, should be %ld\", (long int) n + 1,\n-\t\t\t       (long int) ret_extent, (long int) extent[n]);\n-\t    }\n-          for (n=0; n<= rank; n++)\n-            {\n-              index_type mask_extent, array_extent;\n-\n-\t      array_extent = GFC_DESCRIPTOR_EXTENT(array,n);\n-\t      mask_extent = GFC_DESCRIPTOR_EXTENT(mask,n);\n-\t      if (array_extent != mask_extent)\n-\t\truntime_error (\"Incorrect extent in MASK argument of\"\n-\t\t\t       \" PRODUCT intrinsic in dimension %ld:\"\n-\t\t\t       \" is %ld, should be %ld\", (long int) n + 1,\n-\t\t\t       (long int) mask_extent, (long int) array_extent);\n-\t    }\n+\t  bounds_ifunction_return ((array_t *) retarray, extent,\n+\t\t\t\t   \"return value\", \"PRODUCT\");\n+\t  bounds_equal_extents ((array_t *) mask, (array_t *) array,\n+\t  \t\t\t\"MASK argument\", \"PRODUCT\");\n \t}\n     }\n "}, {"sha": "4f9b5eb3b96b181cd832fd299169000b7417469a", "filename": "libgfortran/generated/product_i1.c", "status": "modified", "additions": 6, "deletions": 36, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/16bff92192676901670042cdce3fbd5f9c928fc8/libgfortran%2Fgenerated%2Fproduct_i1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/16bff92192676901670042cdce3fbd5f9c928fc8/libgfortran%2Fgenerated%2Fproduct_i1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fproduct_i1.c?ref=16bff92192676901670042cdce3fbd5f9c928fc8", "patch": "@@ -119,19 +119,8 @@ product_i1 (gfc_array_i1 * const restrict retarray,\n \t\t       (long int) rank);\n \n       if (unlikely (compile_options.bounds_check))\n-\t{\n-\t  for (n=0; n < rank; n++)\n-\t    {\n-\t      index_type ret_extent;\n-\n-\t      ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,n);\n-\t      if (extent[n] != ret_extent)\n-\t\truntime_error (\"Incorrect extent in return value of\"\n-\t\t\t       \" PRODUCT intrinsic in dimension %ld:\"\n-\t\t\t       \" is %ld, should be %ld\", (long int) n + 1,\n-\t\t\t       (long int) ret_extent, (long int) extent[n]);\n-\t    }\n-\t}\n+\tbounds_ifunction_return ((array_t *) retarray, extent,\n+\t\t\t\t \"return value\", \"PRODUCT\");\n     }\n \n   for (n = 0; n < rank; n++)\n@@ -306,29 +295,10 @@ mproduct_i1 (gfc_array_i1 * const restrict retarray,\n \n       if (unlikely (compile_options.bounds_check))\n \t{\n-\t  for (n=0; n < rank; n++)\n-\t    {\n-\t      index_type ret_extent;\n-\n-\t      ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,n);\n-\t      if (extent[n] != ret_extent)\n-\t\truntime_error (\"Incorrect extent in return value of\"\n-\t\t\t       \" PRODUCT intrinsic in dimension %ld:\"\n-\t\t\t       \" is %ld, should be %ld\", (long int) n + 1,\n-\t\t\t       (long int) ret_extent, (long int) extent[n]);\n-\t    }\n-          for (n=0; n<= rank; n++)\n-            {\n-              index_type mask_extent, array_extent;\n-\n-\t      array_extent = GFC_DESCRIPTOR_EXTENT(array,n);\n-\t      mask_extent = GFC_DESCRIPTOR_EXTENT(mask,n);\n-\t      if (array_extent != mask_extent)\n-\t\truntime_error (\"Incorrect extent in MASK argument of\"\n-\t\t\t       \" PRODUCT intrinsic in dimension %ld:\"\n-\t\t\t       \" is %ld, should be %ld\", (long int) n + 1,\n-\t\t\t       (long int) mask_extent, (long int) array_extent);\n-\t    }\n+\t  bounds_ifunction_return ((array_t *) retarray, extent,\n+\t\t\t\t   \"return value\", \"PRODUCT\");\n+\t  bounds_equal_extents ((array_t *) mask, (array_t *) array,\n+\t  \t\t\t\"MASK argument\", \"PRODUCT\");\n \t}\n     }\n "}, {"sha": "a23a96a8323bcdcb48df784b9a01e12b543a6cef", "filename": "libgfortran/generated/product_i16.c", "status": "modified", "additions": 6, "deletions": 36, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/16bff92192676901670042cdce3fbd5f9c928fc8/libgfortran%2Fgenerated%2Fproduct_i16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/16bff92192676901670042cdce3fbd5f9c928fc8/libgfortran%2Fgenerated%2Fproduct_i16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fproduct_i16.c?ref=16bff92192676901670042cdce3fbd5f9c928fc8", "patch": "@@ -119,19 +119,8 @@ product_i16 (gfc_array_i16 * const restrict retarray,\n \t\t       (long int) rank);\n \n       if (unlikely (compile_options.bounds_check))\n-\t{\n-\t  for (n=0; n < rank; n++)\n-\t    {\n-\t      index_type ret_extent;\n-\n-\t      ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,n);\n-\t      if (extent[n] != ret_extent)\n-\t\truntime_error (\"Incorrect extent in return value of\"\n-\t\t\t       \" PRODUCT intrinsic in dimension %ld:\"\n-\t\t\t       \" is %ld, should be %ld\", (long int) n + 1,\n-\t\t\t       (long int) ret_extent, (long int) extent[n]);\n-\t    }\n-\t}\n+\tbounds_ifunction_return ((array_t *) retarray, extent,\n+\t\t\t\t \"return value\", \"PRODUCT\");\n     }\n \n   for (n = 0; n < rank; n++)\n@@ -306,29 +295,10 @@ mproduct_i16 (gfc_array_i16 * const restrict retarray,\n \n       if (unlikely (compile_options.bounds_check))\n \t{\n-\t  for (n=0; n < rank; n++)\n-\t    {\n-\t      index_type ret_extent;\n-\n-\t      ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,n);\n-\t      if (extent[n] != ret_extent)\n-\t\truntime_error (\"Incorrect extent in return value of\"\n-\t\t\t       \" PRODUCT intrinsic in dimension %ld:\"\n-\t\t\t       \" is %ld, should be %ld\", (long int) n + 1,\n-\t\t\t       (long int) ret_extent, (long int) extent[n]);\n-\t    }\n-          for (n=0; n<= rank; n++)\n-            {\n-              index_type mask_extent, array_extent;\n-\n-\t      array_extent = GFC_DESCRIPTOR_EXTENT(array,n);\n-\t      mask_extent = GFC_DESCRIPTOR_EXTENT(mask,n);\n-\t      if (array_extent != mask_extent)\n-\t\truntime_error (\"Incorrect extent in MASK argument of\"\n-\t\t\t       \" PRODUCT intrinsic in dimension %ld:\"\n-\t\t\t       \" is %ld, should be %ld\", (long int) n + 1,\n-\t\t\t       (long int) mask_extent, (long int) array_extent);\n-\t    }\n+\t  bounds_ifunction_return ((array_t *) retarray, extent,\n+\t\t\t\t   \"return value\", \"PRODUCT\");\n+\t  bounds_equal_extents ((array_t *) mask, (array_t *) array,\n+\t  \t\t\t\"MASK argument\", \"PRODUCT\");\n \t}\n     }\n "}, {"sha": "40bbe7233e584ed4d0341d1cdf8230b2b7201843", "filename": "libgfortran/generated/product_i2.c", "status": "modified", "additions": 6, "deletions": 36, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/16bff92192676901670042cdce3fbd5f9c928fc8/libgfortran%2Fgenerated%2Fproduct_i2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/16bff92192676901670042cdce3fbd5f9c928fc8/libgfortran%2Fgenerated%2Fproduct_i2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fproduct_i2.c?ref=16bff92192676901670042cdce3fbd5f9c928fc8", "patch": "@@ -119,19 +119,8 @@ product_i2 (gfc_array_i2 * const restrict retarray,\n \t\t       (long int) rank);\n \n       if (unlikely (compile_options.bounds_check))\n-\t{\n-\t  for (n=0; n < rank; n++)\n-\t    {\n-\t      index_type ret_extent;\n-\n-\t      ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,n);\n-\t      if (extent[n] != ret_extent)\n-\t\truntime_error (\"Incorrect extent in return value of\"\n-\t\t\t       \" PRODUCT intrinsic in dimension %ld:\"\n-\t\t\t       \" is %ld, should be %ld\", (long int) n + 1,\n-\t\t\t       (long int) ret_extent, (long int) extent[n]);\n-\t    }\n-\t}\n+\tbounds_ifunction_return ((array_t *) retarray, extent,\n+\t\t\t\t \"return value\", \"PRODUCT\");\n     }\n \n   for (n = 0; n < rank; n++)\n@@ -306,29 +295,10 @@ mproduct_i2 (gfc_array_i2 * const restrict retarray,\n \n       if (unlikely (compile_options.bounds_check))\n \t{\n-\t  for (n=0; n < rank; n++)\n-\t    {\n-\t      index_type ret_extent;\n-\n-\t      ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,n);\n-\t      if (extent[n] != ret_extent)\n-\t\truntime_error (\"Incorrect extent in return value of\"\n-\t\t\t       \" PRODUCT intrinsic in dimension %ld:\"\n-\t\t\t       \" is %ld, should be %ld\", (long int) n + 1,\n-\t\t\t       (long int) ret_extent, (long int) extent[n]);\n-\t    }\n-          for (n=0; n<= rank; n++)\n-            {\n-              index_type mask_extent, array_extent;\n-\n-\t      array_extent = GFC_DESCRIPTOR_EXTENT(array,n);\n-\t      mask_extent = GFC_DESCRIPTOR_EXTENT(mask,n);\n-\t      if (array_extent != mask_extent)\n-\t\truntime_error (\"Incorrect extent in MASK argument of\"\n-\t\t\t       \" PRODUCT intrinsic in dimension %ld:\"\n-\t\t\t       \" is %ld, should be %ld\", (long int) n + 1,\n-\t\t\t       (long int) mask_extent, (long int) array_extent);\n-\t    }\n+\t  bounds_ifunction_return ((array_t *) retarray, extent,\n+\t\t\t\t   \"return value\", \"PRODUCT\");\n+\t  bounds_equal_extents ((array_t *) mask, (array_t *) array,\n+\t  \t\t\t\"MASK argument\", \"PRODUCT\");\n \t}\n     }\n "}, {"sha": "0510fca4aba1b72465aaa452c6e63d0676d72f67", "filename": "libgfortran/generated/product_i4.c", "status": "modified", "additions": 6, "deletions": 36, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/16bff92192676901670042cdce3fbd5f9c928fc8/libgfortran%2Fgenerated%2Fproduct_i4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/16bff92192676901670042cdce3fbd5f9c928fc8/libgfortran%2Fgenerated%2Fproduct_i4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fproduct_i4.c?ref=16bff92192676901670042cdce3fbd5f9c928fc8", "patch": "@@ -119,19 +119,8 @@ product_i4 (gfc_array_i4 * const restrict retarray,\n \t\t       (long int) rank);\n \n       if (unlikely (compile_options.bounds_check))\n-\t{\n-\t  for (n=0; n < rank; n++)\n-\t    {\n-\t      index_type ret_extent;\n-\n-\t      ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,n);\n-\t      if (extent[n] != ret_extent)\n-\t\truntime_error (\"Incorrect extent in return value of\"\n-\t\t\t       \" PRODUCT intrinsic in dimension %ld:\"\n-\t\t\t       \" is %ld, should be %ld\", (long int) n + 1,\n-\t\t\t       (long int) ret_extent, (long int) extent[n]);\n-\t    }\n-\t}\n+\tbounds_ifunction_return ((array_t *) retarray, extent,\n+\t\t\t\t \"return value\", \"PRODUCT\");\n     }\n \n   for (n = 0; n < rank; n++)\n@@ -306,29 +295,10 @@ mproduct_i4 (gfc_array_i4 * const restrict retarray,\n \n       if (unlikely (compile_options.bounds_check))\n \t{\n-\t  for (n=0; n < rank; n++)\n-\t    {\n-\t      index_type ret_extent;\n-\n-\t      ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,n);\n-\t      if (extent[n] != ret_extent)\n-\t\truntime_error (\"Incorrect extent in return value of\"\n-\t\t\t       \" PRODUCT intrinsic in dimension %ld:\"\n-\t\t\t       \" is %ld, should be %ld\", (long int) n + 1,\n-\t\t\t       (long int) ret_extent, (long int) extent[n]);\n-\t    }\n-          for (n=0; n<= rank; n++)\n-            {\n-              index_type mask_extent, array_extent;\n-\n-\t      array_extent = GFC_DESCRIPTOR_EXTENT(array,n);\n-\t      mask_extent = GFC_DESCRIPTOR_EXTENT(mask,n);\n-\t      if (array_extent != mask_extent)\n-\t\truntime_error (\"Incorrect extent in MASK argument of\"\n-\t\t\t       \" PRODUCT intrinsic in dimension %ld:\"\n-\t\t\t       \" is %ld, should be %ld\", (long int) n + 1,\n-\t\t\t       (long int) mask_extent, (long int) array_extent);\n-\t    }\n+\t  bounds_ifunction_return ((array_t *) retarray, extent,\n+\t\t\t\t   \"return value\", \"PRODUCT\");\n+\t  bounds_equal_extents ((array_t *) mask, (array_t *) array,\n+\t  \t\t\t\"MASK argument\", \"PRODUCT\");\n \t}\n     }\n "}, {"sha": "b9bce58921cf3df3d117ce1b71102e8e65dc3eb0", "filename": "libgfortran/generated/product_i8.c", "status": "modified", "additions": 6, "deletions": 36, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/16bff92192676901670042cdce3fbd5f9c928fc8/libgfortran%2Fgenerated%2Fproduct_i8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/16bff92192676901670042cdce3fbd5f9c928fc8/libgfortran%2Fgenerated%2Fproduct_i8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fproduct_i8.c?ref=16bff92192676901670042cdce3fbd5f9c928fc8", "patch": "@@ -119,19 +119,8 @@ product_i8 (gfc_array_i8 * const restrict retarray,\n \t\t       (long int) rank);\n \n       if (unlikely (compile_options.bounds_check))\n-\t{\n-\t  for (n=0; n < rank; n++)\n-\t    {\n-\t      index_type ret_extent;\n-\n-\t      ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,n);\n-\t      if (extent[n] != ret_extent)\n-\t\truntime_error (\"Incorrect extent in return value of\"\n-\t\t\t       \" PRODUCT intrinsic in dimension %ld:\"\n-\t\t\t       \" is %ld, should be %ld\", (long int) n + 1,\n-\t\t\t       (long int) ret_extent, (long int) extent[n]);\n-\t    }\n-\t}\n+\tbounds_ifunction_return ((array_t *) retarray, extent,\n+\t\t\t\t \"return value\", \"PRODUCT\");\n     }\n \n   for (n = 0; n < rank; n++)\n@@ -306,29 +295,10 @@ mproduct_i8 (gfc_array_i8 * const restrict retarray,\n \n       if (unlikely (compile_options.bounds_check))\n \t{\n-\t  for (n=0; n < rank; n++)\n-\t    {\n-\t      index_type ret_extent;\n-\n-\t      ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,n);\n-\t      if (extent[n] != ret_extent)\n-\t\truntime_error (\"Incorrect extent in return value of\"\n-\t\t\t       \" PRODUCT intrinsic in dimension %ld:\"\n-\t\t\t       \" is %ld, should be %ld\", (long int) n + 1,\n-\t\t\t       (long int) ret_extent, (long int) extent[n]);\n-\t    }\n-          for (n=0; n<= rank; n++)\n-            {\n-              index_type mask_extent, array_extent;\n-\n-\t      array_extent = GFC_DESCRIPTOR_EXTENT(array,n);\n-\t      mask_extent = GFC_DESCRIPTOR_EXTENT(mask,n);\n-\t      if (array_extent != mask_extent)\n-\t\truntime_error (\"Incorrect extent in MASK argument of\"\n-\t\t\t       \" PRODUCT intrinsic in dimension %ld:\"\n-\t\t\t       \" is %ld, should be %ld\", (long int) n + 1,\n-\t\t\t       (long int) mask_extent, (long int) array_extent);\n-\t    }\n+\t  bounds_ifunction_return ((array_t *) retarray, extent,\n+\t\t\t\t   \"return value\", \"PRODUCT\");\n+\t  bounds_equal_extents ((array_t *) mask, (array_t *) array,\n+\t  \t\t\t\"MASK argument\", \"PRODUCT\");\n \t}\n     }\n "}, {"sha": "afbf756f54491223acee7aeaf18453cd713526e6", "filename": "libgfortran/generated/product_r10.c", "status": "modified", "additions": 6, "deletions": 36, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/16bff92192676901670042cdce3fbd5f9c928fc8/libgfortran%2Fgenerated%2Fproduct_r10.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/16bff92192676901670042cdce3fbd5f9c928fc8/libgfortran%2Fgenerated%2Fproduct_r10.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fproduct_r10.c?ref=16bff92192676901670042cdce3fbd5f9c928fc8", "patch": "@@ -119,19 +119,8 @@ product_r10 (gfc_array_r10 * const restrict retarray,\n \t\t       (long int) rank);\n \n       if (unlikely (compile_options.bounds_check))\n-\t{\n-\t  for (n=0; n < rank; n++)\n-\t    {\n-\t      index_type ret_extent;\n-\n-\t      ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,n);\n-\t      if (extent[n] != ret_extent)\n-\t\truntime_error (\"Incorrect extent in return value of\"\n-\t\t\t       \" PRODUCT intrinsic in dimension %ld:\"\n-\t\t\t       \" is %ld, should be %ld\", (long int) n + 1,\n-\t\t\t       (long int) ret_extent, (long int) extent[n]);\n-\t    }\n-\t}\n+\tbounds_ifunction_return ((array_t *) retarray, extent,\n+\t\t\t\t \"return value\", \"PRODUCT\");\n     }\n \n   for (n = 0; n < rank; n++)\n@@ -306,29 +295,10 @@ mproduct_r10 (gfc_array_r10 * const restrict retarray,\n \n       if (unlikely (compile_options.bounds_check))\n \t{\n-\t  for (n=0; n < rank; n++)\n-\t    {\n-\t      index_type ret_extent;\n-\n-\t      ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,n);\n-\t      if (extent[n] != ret_extent)\n-\t\truntime_error (\"Incorrect extent in return value of\"\n-\t\t\t       \" PRODUCT intrinsic in dimension %ld:\"\n-\t\t\t       \" is %ld, should be %ld\", (long int) n + 1,\n-\t\t\t       (long int) ret_extent, (long int) extent[n]);\n-\t    }\n-          for (n=0; n<= rank; n++)\n-            {\n-              index_type mask_extent, array_extent;\n-\n-\t      array_extent = GFC_DESCRIPTOR_EXTENT(array,n);\n-\t      mask_extent = GFC_DESCRIPTOR_EXTENT(mask,n);\n-\t      if (array_extent != mask_extent)\n-\t\truntime_error (\"Incorrect extent in MASK argument of\"\n-\t\t\t       \" PRODUCT intrinsic in dimension %ld:\"\n-\t\t\t       \" is %ld, should be %ld\", (long int) n + 1,\n-\t\t\t       (long int) mask_extent, (long int) array_extent);\n-\t    }\n+\t  bounds_ifunction_return ((array_t *) retarray, extent,\n+\t\t\t\t   \"return value\", \"PRODUCT\");\n+\t  bounds_equal_extents ((array_t *) mask, (array_t *) array,\n+\t  \t\t\t\"MASK argument\", \"PRODUCT\");\n \t}\n     }\n "}, {"sha": "1b0723ed15a152dcecfd224cf08fdc0f625a6df4", "filename": "libgfortran/generated/product_r16.c", "status": "modified", "additions": 6, "deletions": 36, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/16bff92192676901670042cdce3fbd5f9c928fc8/libgfortran%2Fgenerated%2Fproduct_r16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/16bff92192676901670042cdce3fbd5f9c928fc8/libgfortran%2Fgenerated%2Fproduct_r16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fproduct_r16.c?ref=16bff92192676901670042cdce3fbd5f9c928fc8", "patch": "@@ -119,19 +119,8 @@ product_r16 (gfc_array_r16 * const restrict retarray,\n \t\t       (long int) rank);\n \n       if (unlikely (compile_options.bounds_check))\n-\t{\n-\t  for (n=0; n < rank; n++)\n-\t    {\n-\t      index_type ret_extent;\n-\n-\t      ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,n);\n-\t      if (extent[n] != ret_extent)\n-\t\truntime_error (\"Incorrect extent in return value of\"\n-\t\t\t       \" PRODUCT intrinsic in dimension %ld:\"\n-\t\t\t       \" is %ld, should be %ld\", (long int) n + 1,\n-\t\t\t       (long int) ret_extent, (long int) extent[n]);\n-\t    }\n-\t}\n+\tbounds_ifunction_return ((array_t *) retarray, extent,\n+\t\t\t\t \"return value\", \"PRODUCT\");\n     }\n \n   for (n = 0; n < rank; n++)\n@@ -306,29 +295,10 @@ mproduct_r16 (gfc_array_r16 * const restrict retarray,\n \n       if (unlikely (compile_options.bounds_check))\n \t{\n-\t  for (n=0; n < rank; n++)\n-\t    {\n-\t      index_type ret_extent;\n-\n-\t      ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,n);\n-\t      if (extent[n] != ret_extent)\n-\t\truntime_error (\"Incorrect extent in return value of\"\n-\t\t\t       \" PRODUCT intrinsic in dimension %ld:\"\n-\t\t\t       \" is %ld, should be %ld\", (long int) n + 1,\n-\t\t\t       (long int) ret_extent, (long int) extent[n]);\n-\t    }\n-          for (n=0; n<= rank; n++)\n-            {\n-              index_type mask_extent, array_extent;\n-\n-\t      array_extent = GFC_DESCRIPTOR_EXTENT(array,n);\n-\t      mask_extent = GFC_DESCRIPTOR_EXTENT(mask,n);\n-\t      if (array_extent != mask_extent)\n-\t\truntime_error (\"Incorrect extent in MASK argument of\"\n-\t\t\t       \" PRODUCT intrinsic in dimension %ld:\"\n-\t\t\t       \" is %ld, should be %ld\", (long int) n + 1,\n-\t\t\t       (long int) mask_extent, (long int) array_extent);\n-\t    }\n+\t  bounds_ifunction_return ((array_t *) retarray, extent,\n+\t\t\t\t   \"return value\", \"PRODUCT\");\n+\t  bounds_equal_extents ((array_t *) mask, (array_t *) array,\n+\t  \t\t\t\"MASK argument\", \"PRODUCT\");\n \t}\n     }\n "}, {"sha": "2f5a8916e458e0a3686d61401e88ba16601d33d7", "filename": "libgfortran/generated/product_r4.c", "status": "modified", "additions": 6, "deletions": 36, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/16bff92192676901670042cdce3fbd5f9c928fc8/libgfortran%2Fgenerated%2Fproduct_r4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/16bff92192676901670042cdce3fbd5f9c928fc8/libgfortran%2Fgenerated%2Fproduct_r4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fproduct_r4.c?ref=16bff92192676901670042cdce3fbd5f9c928fc8", "patch": "@@ -119,19 +119,8 @@ product_r4 (gfc_array_r4 * const restrict retarray,\n \t\t       (long int) rank);\n \n       if (unlikely (compile_options.bounds_check))\n-\t{\n-\t  for (n=0; n < rank; n++)\n-\t    {\n-\t      index_type ret_extent;\n-\n-\t      ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,n);\n-\t      if (extent[n] != ret_extent)\n-\t\truntime_error (\"Incorrect extent in return value of\"\n-\t\t\t       \" PRODUCT intrinsic in dimension %ld:\"\n-\t\t\t       \" is %ld, should be %ld\", (long int) n + 1,\n-\t\t\t       (long int) ret_extent, (long int) extent[n]);\n-\t    }\n-\t}\n+\tbounds_ifunction_return ((array_t *) retarray, extent,\n+\t\t\t\t \"return value\", \"PRODUCT\");\n     }\n \n   for (n = 0; n < rank; n++)\n@@ -306,29 +295,10 @@ mproduct_r4 (gfc_array_r4 * const restrict retarray,\n \n       if (unlikely (compile_options.bounds_check))\n \t{\n-\t  for (n=0; n < rank; n++)\n-\t    {\n-\t      index_type ret_extent;\n-\n-\t      ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,n);\n-\t      if (extent[n] != ret_extent)\n-\t\truntime_error (\"Incorrect extent in return value of\"\n-\t\t\t       \" PRODUCT intrinsic in dimension %ld:\"\n-\t\t\t       \" is %ld, should be %ld\", (long int) n + 1,\n-\t\t\t       (long int) ret_extent, (long int) extent[n]);\n-\t    }\n-          for (n=0; n<= rank; n++)\n-            {\n-              index_type mask_extent, array_extent;\n-\n-\t      array_extent = GFC_DESCRIPTOR_EXTENT(array,n);\n-\t      mask_extent = GFC_DESCRIPTOR_EXTENT(mask,n);\n-\t      if (array_extent != mask_extent)\n-\t\truntime_error (\"Incorrect extent in MASK argument of\"\n-\t\t\t       \" PRODUCT intrinsic in dimension %ld:\"\n-\t\t\t       \" is %ld, should be %ld\", (long int) n + 1,\n-\t\t\t       (long int) mask_extent, (long int) array_extent);\n-\t    }\n+\t  bounds_ifunction_return ((array_t *) retarray, extent,\n+\t\t\t\t   \"return value\", \"PRODUCT\");\n+\t  bounds_equal_extents ((array_t *) mask, (array_t *) array,\n+\t  \t\t\t\"MASK argument\", \"PRODUCT\");\n \t}\n     }\n "}, {"sha": "88c49ff85da460655549ffe6454e8468f617c78c", "filename": "libgfortran/generated/product_r8.c", "status": "modified", "additions": 6, "deletions": 36, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/16bff92192676901670042cdce3fbd5f9c928fc8/libgfortran%2Fgenerated%2Fproduct_r8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/16bff92192676901670042cdce3fbd5f9c928fc8/libgfortran%2Fgenerated%2Fproduct_r8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fproduct_r8.c?ref=16bff92192676901670042cdce3fbd5f9c928fc8", "patch": "@@ -119,19 +119,8 @@ product_r8 (gfc_array_r8 * const restrict retarray,\n \t\t       (long int) rank);\n \n       if (unlikely (compile_options.bounds_check))\n-\t{\n-\t  for (n=0; n < rank; n++)\n-\t    {\n-\t      index_type ret_extent;\n-\n-\t      ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,n);\n-\t      if (extent[n] != ret_extent)\n-\t\truntime_error (\"Incorrect extent in return value of\"\n-\t\t\t       \" PRODUCT intrinsic in dimension %ld:\"\n-\t\t\t       \" is %ld, should be %ld\", (long int) n + 1,\n-\t\t\t       (long int) ret_extent, (long int) extent[n]);\n-\t    }\n-\t}\n+\tbounds_ifunction_return ((array_t *) retarray, extent,\n+\t\t\t\t \"return value\", \"PRODUCT\");\n     }\n \n   for (n = 0; n < rank; n++)\n@@ -306,29 +295,10 @@ mproduct_r8 (gfc_array_r8 * const restrict retarray,\n \n       if (unlikely (compile_options.bounds_check))\n \t{\n-\t  for (n=0; n < rank; n++)\n-\t    {\n-\t      index_type ret_extent;\n-\n-\t      ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,n);\n-\t      if (extent[n] != ret_extent)\n-\t\truntime_error (\"Incorrect extent in return value of\"\n-\t\t\t       \" PRODUCT intrinsic in dimension %ld:\"\n-\t\t\t       \" is %ld, should be %ld\", (long int) n + 1,\n-\t\t\t       (long int) ret_extent, (long int) extent[n]);\n-\t    }\n-          for (n=0; n<= rank; n++)\n-            {\n-              index_type mask_extent, array_extent;\n-\n-\t      array_extent = GFC_DESCRIPTOR_EXTENT(array,n);\n-\t      mask_extent = GFC_DESCRIPTOR_EXTENT(mask,n);\n-\t      if (array_extent != mask_extent)\n-\t\truntime_error (\"Incorrect extent in MASK argument of\"\n-\t\t\t       \" PRODUCT intrinsic in dimension %ld:\"\n-\t\t\t       \" is %ld, should be %ld\", (long int) n + 1,\n-\t\t\t       (long int) mask_extent, (long int) array_extent);\n-\t    }\n+\t  bounds_ifunction_return ((array_t *) retarray, extent,\n+\t\t\t\t   \"return value\", \"PRODUCT\");\n+\t  bounds_equal_extents ((array_t *) mask, (array_t *) array,\n+\t  \t\t\t\"MASK argument\", \"PRODUCT\");\n \t}\n     }\n "}, {"sha": "9e32c8636b3605d8b1b82adeb8fa543335115c9a", "filename": "libgfortran/generated/sum_c10.c", "status": "modified", "additions": 6, "deletions": 36, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/16bff92192676901670042cdce3fbd5f9c928fc8/libgfortran%2Fgenerated%2Fsum_c10.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/16bff92192676901670042cdce3fbd5f9c928fc8/libgfortran%2Fgenerated%2Fsum_c10.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fsum_c10.c?ref=16bff92192676901670042cdce3fbd5f9c928fc8", "patch": "@@ -119,19 +119,8 @@ sum_c10 (gfc_array_c10 * const restrict retarray,\n \t\t       (long int) rank);\n \n       if (unlikely (compile_options.bounds_check))\n-\t{\n-\t  for (n=0; n < rank; n++)\n-\t    {\n-\t      index_type ret_extent;\n-\n-\t      ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,n);\n-\t      if (extent[n] != ret_extent)\n-\t\truntime_error (\"Incorrect extent in return value of\"\n-\t\t\t       \" SUM intrinsic in dimension %ld:\"\n-\t\t\t       \" is %ld, should be %ld\", (long int) n + 1,\n-\t\t\t       (long int) ret_extent, (long int) extent[n]);\n-\t    }\n-\t}\n+\tbounds_ifunction_return ((array_t *) retarray, extent,\n+\t\t\t\t \"return value\", \"SUM\");\n     }\n \n   for (n = 0; n < rank; n++)\n@@ -306,29 +295,10 @@ msum_c10 (gfc_array_c10 * const restrict retarray,\n \n       if (unlikely (compile_options.bounds_check))\n \t{\n-\t  for (n=0; n < rank; n++)\n-\t    {\n-\t      index_type ret_extent;\n-\n-\t      ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,n);\n-\t      if (extent[n] != ret_extent)\n-\t\truntime_error (\"Incorrect extent in return value of\"\n-\t\t\t       \" SUM intrinsic in dimension %ld:\"\n-\t\t\t       \" is %ld, should be %ld\", (long int) n + 1,\n-\t\t\t       (long int) ret_extent, (long int) extent[n]);\n-\t    }\n-          for (n=0; n<= rank; n++)\n-            {\n-              index_type mask_extent, array_extent;\n-\n-\t      array_extent = GFC_DESCRIPTOR_EXTENT(array,n);\n-\t      mask_extent = GFC_DESCRIPTOR_EXTENT(mask,n);\n-\t      if (array_extent != mask_extent)\n-\t\truntime_error (\"Incorrect extent in MASK argument of\"\n-\t\t\t       \" SUM intrinsic in dimension %ld:\"\n-\t\t\t       \" is %ld, should be %ld\", (long int) n + 1,\n-\t\t\t       (long int) mask_extent, (long int) array_extent);\n-\t    }\n+\t  bounds_ifunction_return ((array_t *) retarray, extent,\n+\t\t\t\t   \"return value\", \"SUM\");\n+\t  bounds_equal_extents ((array_t *) mask, (array_t *) array,\n+\t  \t\t\t\"MASK argument\", \"SUM\");\n \t}\n     }\n "}, {"sha": "ade7d761ceb120f2c374d1be0bc34f54136b8d03", "filename": "libgfortran/generated/sum_c16.c", "status": "modified", "additions": 6, "deletions": 36, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/16bff92192676901670042cdce3fbd5f9c928fc8/libgfortran%2Fgenerated%2Fsum_c16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/16bff92192676901670042cdce3fbd5f9c928fc8/libgfortran%2Fgenerated%2Fsum_c16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fsum_c16.c?ref=16bff92192676901670042cdce3fbd5f9c928fc8", "patch": "@@ -119,19 +119,8 @@ sum_c16 (gfc_array_c16 * const restrict retarray,\n \t\t       (long int) rank);\n \n       if (unlikely (compile_options.bounds_check))\n-\t{\n-\t  for (n=0; n < rank; n++)\n-\t    {\n-\t      index_type ret_extent;\n-\n-\t      ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,n);\n-\t      if (extent[n] != ret_extent)\n-\t\truntime_error (\"Incorrect extent in return value of\"\n-\t\t\t       \" SUM intrinsic in dimension %ld:\"\n-\t\t\t       \" is %ld, should be %ld\", (long int) n + 1,\n-\t\t\t       (long int) ret_extent, (long int) extent[n]);\n-\t    }\n-\t}\n+\tbounds_ifunction_return ((array_t *) retarray, extent,\n+\t\t\t\t \"return value\", \"SUM\");\n     }\n \n   for (n = 0; n < rank; n++)\n@@ -306,29 +295,10 @@ msum_c16 (gfc_array_c16 * const restrict retarray,\n \n       if (unlikely (compile_options.bounds_check))\n \t{\n-\t  for (n=0; n < rank; n++)\n-\t    {\n-\t      index_type ret_extent;\n-\n-\t      ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,n);\n-\t      if (extent[n] != ret_extent)\n-\t\truntime_error (\"Incorrect extent in return value of\"\n-\t\t\t       \" SUM intrinsic in dimension %ld:\"\n-\t\t\t       \" is %ld, should be %ld\", (long int) n + 1,\n-\t\t\t       (long int) ret_extent, (long int) extent[n]);\n-\t    }\n-          for (n=0; n<= rank; n++)\n-            {\n-              index_type mask_extent, array_extent;\n-\n-\t      array_extent = GFC_DESCRIPTOR_EXTENT(array,n);\n-\t      mask_extent = GFC_DESCRIPTOR_EXTENT(mask,n);\n-\t      if (array_extent != mask_extent)\n-\t\truntime_error (\"Incorrect extent in MASK argument of\"\n-\t\t\t       \" SUM intrinsic in dimension %ld:\"\n-\t\t\t       \" is %ld, should be %ld\", (long int) n + 1,\n-\t\t\t       (long int) mask_extent, (long int) array_extent);\n-\t    }\n+\t  bounds_ifunction_return ((array_t *) retarray, extent,\n+\t\t\t\t   \"return value\", \"SUM\");\n+\t  bounds_equal_extents ((array_t *) mask, (array_t *) array,\n+\t  \t\t\t\"MASK argument\", \"SUM\");\n \t}\n     }\n "}, {"sha": "ac37cc88ec66e37d17b4989eff0cb3136139f78b", "filename": "libgfortran/generated/sum_c4.c", "status": "modified", "additions": 6, "deletions": 36, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/16bff92192676901670042cdce3fbd5f9c928fc8/libgfortran%2Fgenerated%2Fsum_c4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/16bff92192676901670042cdce3fbd5f9c928fc8/libgfortran%2Fgenerated%2Fsum_c4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fsum_c4.c?ref=16bff92192676901670042cdce3fbd5f9c928fc8", "patch": "@@ -119,19 +119,8 @@ sum_c4 (gfc_array_c4 * const restrict retarray,\n \t\t       (long int) rank);\n \n       if (unlikely (compile_options.bounds_check))\n-\t{\n-\t  for (n=0; n < rank; n++)\n-\t    {\n-\t      index_type ret_extent;\n-\n-\t      ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,n);\n-\t      if (extent[n] != ret_extent)\n-\t\truntime_error (\"Incorrect extent in return value of\"\n-\t\t\t       \" SUM intrinsic in dimension %ld:\"\n-\t\t\t       \" is %ld, should be %ld\", (long int) n + 1,\n-\t\t\t       (long int) ret_extent, (long int) extent[n]);\n-\t    }\n-\t}\n+\tbounds_ifunction_return ((array_t *) retarray, extent,\n+\t\t\t\t \"return value\", \"SUM\");\n     }\n \n   for (n = 0; n < rank; n++)\n@@ -306,29 +295,10 @@ msum_c4 (gfc_array_c4 * const restrict retarray,\n \n       if (unlikely (compile_options.bounds_check))\n \t{\n-\t  for (n=0; n < rank; n++)\n-\t    {\n-\t      index_type ret_extent;\n-\n-\t      ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,n);\n-\t      if (extent[n] != ret_extent)\n-\t\truntime_error (\"Incorrect extent in return value of\"\n-\t\t\t       \" SUM intrinsic in dimension %ld:\"\n-\t\t\t       \" is %ld, should be %ld\", (long int) n + 1,\n-\t\t\t       (long int) ret_extent, (long int) extent[n]);\n-\t    }\n-          for (n=0; n<= rank; n++)\n-            {\n-              index_type mask_extent, array_extent;\n-\n-\t      array_extent = GFC_DESCRIPTOR_EXTENT(array,n);\n-\t      mask_extent = GFC_DESCRIPTOR_EXTENT(mask,n);\n-\t      if (array_extent != mask_extent)\n-\t\truntime_error (\"Incorrect extent in MASK argument of\"\n-\t\t\t       \" SUM intrinsic in dimension %ld:\"\n-\t\t\t       \" is %ld, should be %ld\", (long int) n + 1,\n-\t\t\t       (long int) mask_extent, (long int) array_extent);\n-\t    }\n+\t  bounds_ifunction_return ((array_t *) retarray, extent,\n+\t\t\t\t   \"return value\", \"SUM\");\n+\t  bounds_equal_extents ((array_t *) mask, (array_t *) array,\n+\t  \t\t\t\"MASK argument\", \"SUM\");\n \t}\n     }\n "}, {"sha": "91db496587fa8ae6e4edca31420c9edf7addf10c", "filename": "libgfortran/generated/sum_c8.c", "status": "modified", "additions": 6, "deletions": 36, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/16bff92192676901670042cdce3fbd5f9c928fc8/libgfortran%2Fgenerated%2Fsum_c8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/16bff92192676901670042cdce3fbd5f9c928fc8/libgfortran%2Fgenerated%2Fsum_c8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fsum_c8.c?ref=16bff92192676901670042cdce3fbd5f9c928fc8", "patch": "@@ -119,19 +119,8 @@ sum_c8 (gfc_array_c8 * const restrict retarray,\n \t\t       (long int) rank);\n \n       if (unlikely (compile_options.bounds_check))\n-\t{\n-\t  for (n=0; n < rank; n++)\n-\t    {\n-\t      index_type ret_extent;\n-\n-\t      ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,n);\n-\t      if (extent[n] != ret_extent)\n-\t\truntime_error (\"Incorrect extent in return value of\"\n-\t\t\t       \" SUM intrinsic in dimension %ld:\"\n-\t\t\t       \" is %ld, should be %ld\", (long int) n + 1,\n-\t\t\t       (long int) ret_extent, (long int) extent[n]);\n-\t    }\n-\t}\n+\tbounds_ifunction_return ((array_t *) retarray, extent,\n+\t\t\t\t \"return value\", \"SUM\");\n     }\n \n   for (n = 0; n < rank; n++)\n@@ -306,29 +295,10 @@ msum_c8 (gfc_array_c8 * const restrict retarray,\n \n       if (unlikely (compile_options.bounds_check))\n \t{\n-\t  for (n=0; n < rank; n++)\n-\t    {\n-\t      index_type ret_extent;\n-\n-\t      ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,n);\n-\t      if (extent[n] != ret_extent)\n-\t\truntime_error (\"Incorrect extent in return value of\"\n-\t\t\t       \" SUM intrinsic in dimension %ld:\"\n-\t\t\t       \" is %ld, should be %ld\", (long int) n + 1,\n-\t\t\t       (long int) ret_extent, (long int) extent[n]);\n-\t    }\n-          for (n=0; n<= rank; n++)\n-            {\n-              index_type mask_extent, array_extent;\n-\n-\t      array_extent = GFC_DESCRIPTOR_EXTENT(array,n);\n-\t      mask_extent = GFC_DESCRIPTOR_EXTENT(mask,n);\n-\t      if (array_extent != mask_extent)\n-\t\truntime_error (\"Incorrect extent in MASK argument of\"\n-\t\t\t       \" SUM intrinsic in dimension %ld:\"\n-\t\t\t       \" is %ld, should be %ld\", (long int) n + 1,\n-\t\t\t       (long int) mask_extent, (long int) array_extent);\n-\t    }\n+\t  bounds_ifunction_return ((array_t *) retarray, extent,\n+\t\t\t\t   \"return value\", \"SUM\");\n+\t  bounds_equal_extents ((array_t *) mask, (array_t *) array,\n+\t  \t\t\t\"MASK argument\", \"SUM\");\n \t}\n     }\n "}, {"sha": "b6e10909aa77179bf564d1918fb192845aa9587d", "filename": "libgfortran/generated/sum_i1.c", "status": "modified", "additions": 6, "deletions": 36, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/16bff92192676901670042cdce3fbd5f9c928fc8/libgfortran%2Fgenerated%2Fsum_i1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/16bff92192676901670042cdce3fbd5f9c928fc8/libgfortran%2Fgenerated%2Fsum_i1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fsum_i1.c?ref=16bff92192676901670042cdce3fbd5f9c928fc8", "patch": "@@ -119,19 +119,8 @@ sum_i1 (gfc_array_i1 * const restrict retarray,\n \t\t       (long int) rank);\n \n       if (unlikely (compile_options.bounds_check))\n-\t{\n-\t  for (n=0; n < rank; n++)\n-\t    {\n-\t      index_type ret_extent;\n-\n-\t      ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,n);\n-\t      if (extent[n] != ret_extent)\n-\t\truntime_error (\"Incorrect extent in return value of\"\n-\t\t\t       \" SUM intrinsic in dimension %ld:\"\n-\t\t\t       \" is %ld, should be %ld\", (long int) n + 1,\n-\t\t\t       (long int) ret_extent, (long int) extent[n]);\n-\t    }\n-\t}\n+\tbounds_ifunction_return ((array_t *) retarray, extent,\n+\t\t\t\t \"return value\", \"SUM\");\n     }\n \n   for (n = 0; n < rank; n++)\n@@ -306,29 +295,10 @@ msum_i1 (gfc_array_i1 * const restrict retarray,\n \n       if (unlikely (compile_options.bounds_check))\n \t{\n-\t  for (n=0; n < rank; n++)\n-\t    {\n-\t      index_type ret_extent;\n-\n-\t      ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,n);\n-\t      if (extent[n] != ret_extent)\n-\t\truntime_error (\"Incorrect extent in return value of\"\n-\t\t\t       \" SUM intrinsic in dimension %ld:\"\n-\t\t\t       \" is %ld, should be %ld\", (long int) n + 1,\n-\t\t\t       (long int) ret_extent, (long int) extent[n]);\n-\t    }\n-          for (n=0; n<= rank; n++)\n-            {\n-              index_type mask_extent, array_extent;\n-\n-\t      array_extent = GFC_DESCRIPTOR_EXTENT(array,n);\n-\t      mask_extent = GFC_DESCRIPTOR_EXTENT(mask,n);\n-\t      if (array_extent != mask_extent)\n-\t\truntime_error (\"Incorrect extent in MASK argument of\"\n-\t\t\t       \" SUM intrinsic in dimension %ld:\"\n-\t\t\t       \" is %ld, should be %ld\", (long int) n + 1,\n-\t\t\t       (long int) mask_extent, (long int) array_extent);\n-\t    }\n+\t  bounds_ifunction_return ((array_t *) retarray, extent,\n+\t\t\t\t   \"return value\", \"SUM\");\n+\t  bounds_equal_extents ((array_t *) mask, (array_t *) array,\n+\t  \t\t\t\"MASK argument\", \"SUM\");\n \t}\n     }\n "}, {"sha": "481ef8e51fbc4865a41fecc84743bccf9d0344c8", "filename": "libgfortran/generated/sum_i16.c", "status": "modified", "additions": 6, "deletions": 36, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/16bff92192676901670042cdce3fbd5f9c928fc8/libgfortran%2Fgenerated%2Fsum_i16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/16bff92192676901670042cdce3fbd5f9c928fc8/libgfortran%2Fgenerated%2Fsum_i16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fsum_i16.c?ref=16bff92192676901670042cdce3fbd5f9c928fc8", "patch": "@@ -119,19 +119,8 @@ sum_i16 (gfc_array_i16 * const restrict retarray,\n \t\t       (long int) rank);\n \n       if (unlikely (compile_options.bounds_check))\n-\t{\n-\t  for (n=0; n < rank; n++)\n-\t    {\n-\t      index_type ret_extent;\n-\n-\t      ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,n);\n-\t      if (extent[n] != ret_extent)\n-\t\truntime_error (\"Incorrect extent in return value of\"\n-\t\t\t       \" SUM intrinsic in dimension %ld:\"\n-\t\t\t       \" is %ld, should be %ld\", (long int) n + 1,\n-\t\t\t       (long int) ret_extent, (long int) extent[n]);\n-\t    }\n-\t}\n+\tbounds_ifunction_return ((array_t *) retarray, extent,\n+\t\t\t\t \"return value\", \"SUM\");\n     }\n \n   for (n = 0; n < rank; n++)\n@@ -306,29 +295,10 @@ msum_i16 (gfc_array_i16 * const restrict retarray,\n \n       if (unlikely (compile_options.bounds_check))\n \t{\n-\t  for (n=0; n < rank; n++)\n-\t    {\n-\t      index_type ret_extent;\n-\n-\t      ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,n);\n-\t      if (extent[n] != ret_extent)\n-\t\truntime_error (\"Incorrect extent in return value of\"\n-\t\t\t       \" SUM intrinsic in dimension %ld:\"\n-\t\t\t       \" is %ld, should be %ld\", (long int) n + 1,\n-\t\t\t       (long int) ret_extent, (long int) extent[n]);\n-\t    }\n-          for (n=0; n<= rank; n++)\n-            {\n-              index_type mask_extent, array_extent;\n-\n-\t      array_extent = GFC_DESCRIPTOR_EXTENT(array,n);\n-\t      mask_extent = GFC_DESCRIPTOR_EXTENT(mask,n);\n-\t      if (array_extent != mask_extent)\n-\t\truntime_error (\"Incorrect extent in MASK argument of\"\n-\t\t\t       \" SUM intrinsic in dimension %ld:\"\n-\t\t\t       \" is %ld, should be %ld\", (long int) n + 1,\n-\t\t\t       (long int) mask_extent, (long int) array_extent);\n-\t    }\n+\t  bounds_ifunction_return ((array_t *) retarray, extent,\n+\t\t\t\t   \"return value\", \"SUM\");\n+\t  bounds_equal_extents ((array_t *) mask, (array_t *) array,\n+\t  \t\t\t\"MASK argument\", \"SUM\");\n \t}\n     }\n "}, {"sha": "a0d97890d6c9a3d877b1938ca0cf5bda1f44303c", "filename": "libgfortran/generated/sum_i2.c", "status": "modified", "additions": 6, "deletions": 36, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/16bff92192676901670042cdce3fbd5f9c928fc8/libgfortran%2Fgenerated%2Fsum_i2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/16bff92192676901670042cdce3fbd5f9c928fc8/libgfortran%2Fgenerated%2Fsum_i2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fsum_i2.c?ref=16bff92192676901670042cdce3fbd5f9c928fc8", "patch": "@@ -119,19 +119,8 @@ sum_i2 (gfc_array_i2 * const restrict retarray,\n \t\t       (long int) rank);\n \n       if (unlikely (compile_options.bounds_check))\n-\t{\n-\t  for (n=0; n < rank; n++)\n-\t    {\n-\t      index_type ret_extent;\n-\n-\t      ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,n);\n-\t      if (extent[n] != ret_extent)\n-\t\truntime_error (\"Incorrect extent in return value of\"\n-\t\t\t       \" SUM intrinsic in dimension %ld:\"\n-\t\t\t       \" is %ld, should be %ld\", (long int) n + 1,\n-\t\t\t       (long int) ret_extent, (long int) extent[n]);\n-\t    }\n-\t}\n+\tbounds_ifunction_return ((array_t *) retarray, extent,\n+\t\t\t\t \"return value\", \"SUM\");\n     }\n \n   for (n = 0; n < rank; n++)\n@@ -306,29 +295,10 @@ msum_i2 (gfc_array_i2 * const restrict retarray,\n \n       if (unlikely (compile_options.bounds_check))\n \t{\n-\t  for (n=0; n < rank; n++)\n-\t    {\n-\t      index_type ret_extent;\n-\n-\t      ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,n);\n-\t      if (extent[n] != ret_extent)\n-\t\truntime_error (\"Incorrect extent in return value of\"\n-\t\t\t       \" SUM intrinsic in dimension %ld:\"\n-\t\t\t       \" is %ld, should be %ld\", (long int) n + 1,\n-\t\t\t       (long int) ret_extent, (long int) extent[n]);\n-\t    }\n-          for (n=0; n<= rank; n++)\n-            {\n-              index_type mask_extent, array_extent;\n-\n-\t      array_extent = GFC_DESCRIPTOR_EXTENT(array,n);\n-\t      mask_extent = GFC_DESCRIPTOR_EXTENT(mask,n);\n-\t      if (array_extent != mask_extent)\n-\t\truntime_error (\"Incorrect extent in MASK argument of\"\n-\t\t\t       \" SUM intrinsic in dimension %ld:\"\n-\t\t\t       \" is %ld, should be %ld\", (long int) n + 1,\n-\t\t\t       (long int) mask_extent, (long int) array_extent);\n-\t    }\n+\t  bounds_ifunction_return ((array_t *) retarray, extent,\n+\t\t\t\t   \"return value\", \"SUM\");\n+\t  bounds_equal_extents ((array_t *) mask, (array_t *) array,\n+\t  \t\t\t\"MASK argument\", \"SUM\");\n \t}\n     }\n "}, {"sha": "06f2dee4d7b56aa14029cf7eaf012f451a2d81ab", "filename": "libgfortran/generated/sum_i4.c", "status": "modified", "additions": 6, "deletions": 36, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/16bff92192676901670042cdce3fbd5f9c928fc8/libgfortran%2Fgenerated%2Fsum_i4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/16bff92192676901670042cdce3fbd5f9c928fc8/libgfortran%2Fgenerated%2Fsum_i4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fsum_i4.c?ref=16bff92192676901670042cdce3fbd5f9c928fc8", "patch": "@@ -119,19 +119,8 @@ sum_i4 (gfc_array_i4 * const restrict retarray,\n \t\t       (long int) rank);\n \n       if (unlikely (compile_options.bounds_check))\n-\t{\n-\t  for (n=0; n < rank; n++)\n-\t    {\n-\t      index_type ret_extent;\n-\n-\t      ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,n);\n-\t      if (extent[n] != ret_extent)\n-\t\truntime_error (\"Incorrect extent in return value of\"\n-\t\t\t       \" SUM intrinsic in dimension %ld:\"\n-\t\t\t       \" is %ld, should be %ld\", (long int) n + 1,\n-\t\t\t       (long int) ret_extent, (long int) extent[n]);\n-\t    }\n-\t}\n+\tbounds_ifunction_return ((array_t *) retarray, extent,\n+\t\t\t\t \"return value\", \"SUM\");\n     }\n \n   for (n = 0; n < rank; n++)\n@@ -306,29 +295,10 @@ msum_i4 (gfc_array_i4 * const restrict retarray,\n \n       if (unlikely (compile_options.bounds_check))\n \t{\n-\t  for (n=0; n < rank; n++)\n-\t    {\n-\t      index_type ret_extent;\n-\n-\t      ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,n);\n-\t      if (extent[n] != ret_extent)\n-\t\truntime_error (\"Incorrect extent in return value of\"\n-\t\t\t       \" SUM intrinsic in dimension %ld:\"\n-\t\t\t       \" is %ld, should be %ld\", (long int) n + 1,\n-\t\t\t       (long int) ret_extent, (long int) extent[n]);\n-\t    }\n-          for (n=0; n<= rank; n++)\n-            {\n-              index_type mask_extent, array_extent;\n-\n-\t      array_extent = GFC_DESCRIPTOR_EXTENT(array,n);\n-\t      mask_extent = GFC_DESCRIPTOR_EXTENT(mask,n);\n-\t      if (array_extent != mask_extent)\n-\t\truntime_error (\"Incorrect extent in MASK argument of\"\n-\t\t\t       \" SUM intrinsic in dimension %ld:\"\n-\t\t\t       \" is %ld, should be %ld\", (long int) n + 1,\n-\t\t\t       (long int) mask_extent, (long int) array_extent);\n-\t    }\n+\t  bounds_ifunction_return ((array_t *) retarray, extent,\n+\t\t\t\t   \"return value\", \"SUM\");\n+\t  bounds_equal_extents ((array_t *) mask, (array_t *) array,\n+\t  \t\t\t\"MASK argument\", \"SUM\");\n \t}\n     }\n "}, {"sha": "9171c4c716e28d21fee227ddbad711f80096c627", "filename": "libgfortran/generated/sum_i8.c", "status": "modified", "additions": 6, "deletions": 36, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/16bff92192676901670042cdce3fbd5f9c928fc8/libgfortran%2Fgenerated%2Fsum_i8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/16bff92192676901670042cdce3fbd5f9c928fc8/libgfortran%2Fgenerated%2Fsum_i8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fsum_i8.c?ref=16bff92192676901670042cdce3fbd5f9c928fc8", "patch": "@@ -119,19 +119,8 @@ sum_i8 (gfc_array_i8 * const restrict retarray,\n \t\t       (long int) rank);\n \n       if (unlikely (compile_options.bounds_check))\n-\t{\n-\t  for (n=0; n < rank; n++)\n-\t    {\n-\t      index_type ret_extent;\n-\n-\t      ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,n);\n-\t      if (extent[n] != ret_extent)\n-\t\truntime_error (\"Incorrect extent in return value of\"\n-\t\t\t       \" SUM intrinsic in dimension %ld:\"\n-\t\t\t       \" is %ld, should be %ld\", (long int) n + 1,\n-\t\t\t       (long int) ret_extent, (long int) extent[n]);\n-\t    }\n-\t}\n+\tbounds_ifunction_return ((array_t *) retarray, extent,\n+\t\t\t\t \"return value\", \"SUM\");\n     }\n \n   for (n = 0; n < rank; n++)\n@@ -306,29 +295,10 @@ msum_i8 (gfc_array_i8 * const restrict retarray,\n \n       if (unlikely (compile_options.bounds_check))\n \t{\n-\t  for (n=0; n < rank; n++)\n-\t    {\n-\t      index_type ret_extent;\n-\n-\t      ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,n);\n-\t      if (extent[n] != ret_extent)\n-\t\truntime_error (\"Incorrect extent in return value of\"\n-\t\t\t       \" SUM intrinsic in dimension %ld:\"\n-\t\t\t       \" is %ld, should be %ld\", (long int) n + 1,\n-\t\t\t       (long int) ret_extent, (long int) extent[n]);\n-\t    }\n-          for (n=0; n<= rank; n++)\n-            {\n-              index_type mask_extent, array_extent;\n-\n-\t      array_extent = GFC_DESCRIPTOR_EXTENT(array,n);\n-\t      mask_extent = GFC_DESCRIPTOR_EXTENT(mask,n);\n-\t      if (array_extent != mask_extent)\n-\t\truntime_error (\"Incorrect extent in MASK argument of\"\n-\t\t\t       \" SUM intrinsic in dimension %ld:\"\n-\t\t\t       \" is %ld, should be %ld\", (long int) n + 1,\n-\t\t\t       (long int) mask_extent, (long int) array_extent);\n-\t    }\n+\t  bounds_ifunction_return ((array_t *) retarray, extent,\n+\t\t\t\t   \"return value\", \"SUM\");\n+\t  bounds_equal_extents ((array_t *) mask, (array_t *) array,\n+\t  \t\t\t\"MASK argument\", \"SUM\");\n \t}\n     }\n "}, {"sha": "8d122129cc707f3d1e23eb6be7aeace91fa8bdb1", "filename": "libgfortran/generated/sum_r10.c", "status": "modified", "additions": 6, "deletions": 36, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/16bff92192676901670042cdce3fbd5f9c928fc8/libgfortran%2Fgenerated%2Fsum_r10.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/16bff92192676901670042cdce3fbd5f9c928fc8/libgfortran%2Fgenerated%2Fsum_r10.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fsum_r10.c?ref=16bff92192676901670042cdce3fbd5f9c928fc8", "patch": "@@ -119,19 +119,8 @@ sum_r10 (gfc_array_r10 * const restrict retarray,\n \t\t       (long int) rank);\n \n       if (unlikely (compile_options.bounds_check))\n-\t{\n-\t  for (n=0; n < rank; n++)\n-\t    {\n-\t      index_type ret_extent;\n-\n-\t      ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,n);\n-\t      if (extent[n] != ret_extent)\n-\t\truntime_error (\"Incorrect extent in return value of\"\n-\t\t\t       \" SUM intrinsic in dimension %ld:\"\n-\t\t\t       \" is %ld, should be %ld\", (long int) n + 1,\n-\t\t\t       (long int) ret_extent, (long int) extent[n]);\n-\t    }\n-\t}\n+\tbounds_ifunction_return ((array_t *) retarray, extent,\n+\t\t\t\t \"return value\", \"SUM\");\n     }\n \n   for (n = 0; n < rank; n++)\n@@ -306,29 +295,10 @@ msum_r10 (gfc_array_r10 * const restrict retarray,\n \n       if (unlikely (compile_options.bounds_check))\n \t{\n-\t  for (n=0; n < rank; n++)\n-\t    {\n-\t      index_type ret_extent;\n-\n-\t      ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,n);\n-\t      if (extent[n] != ret_extent)\n-\t\truntime_error (\"Incorrect extent in return value of\"\n-\t\t\t       \" SUM intrinsic in dimension %ld:\"\n-\t\t\t       \" is %ld, should be %ld\", (long int) n + 1,\n-\t\t\t       (long int) ret_extent, (long int) extent[n]);\n-\t    }\n-          for (n=0; n<= rank; n++)\n-            {\n-              index_type mask_extent, array_extent;\n-\n-\t      array_extent = GFC_DESCRIPTOR_EXTENT(array,n);\n-\t      mask_extent = GFC_DESCRIPTOR_EXTENT(mask,n);\n-\t      if (array_extent != mask_extent)\n-\t\truntime_error (\"Incorrect extent in MASK argument of\"\n-\t\t\t       \" SUM intrinsic in dimension %ld:\"\n-\t\t\t       \" is %ld, should be %ld\", (long int) n + 1,\n-\t\t\t       (long int) mask_extent, (long int) array_extent);\n-\t    }\n+\t  bounds_ifunction_return ((array_t *) retarray, extent,\n+\t\t\t\t   \"return value\", \"SUM\");\n+\t  bounds_equal_extents ((array_t *) mask, (array_t *) array,\n+\t  \t\t\t\"MASK argument\", \"SUM\");\n \t}\n     }\n "}, {"sha": "2cd6150e0f3287b2566d9d418d1baed1d2dbb09f", "filename": "libgfortran/generated/sum_r16.c", "status": "modified", "additions": 6, "deletions": 36, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/16bff92192676901670042cdce3fbd5f9c928fc8/libgfortran%2Fgenerated%2Fsum_r16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/16bff92192676901670042cdce3fbd5f9c928fc8/libgfortran%2Fgenerated%2Fsum_r16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fsum_r16.c?ref=16bff92192676901670042cdce3fbd5f9c928fc8", "patch": "@@ -119,19 +119,8 @@ sum_r16 (gfc_array_r16 * const restrict retarray,\n \t\t       (long int) rank);\n \n       if (unlikely (compile_options.bounds_check))\n-\t{\n-\t  for (n=0; n < rank; n++)\n-\t    {\n-\t      index_type ret_extent;\n-\n-\t      ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,n);\n-\t      if (extent[n] != ret_extent)\n-\t\truntime_error (\"Incorrect extent in return value of\"\n-\t\t\t       \" SUM intrinsic in dimension %ld:\"\n-\t\t\t       \" is %ld, should be %ld\", (long int) n + 1,\n-\t\t\t       (long int) ret_extent, (long int) extent[n]);\n-\t    }\n-\t}\n+\tbounds_ifunction_return ((array_t *) retarray, extent,\n+\t\t\t\t \"return value\", \"SUM\");\n     }\n \n   for (n = 0; n < rank; n++)\n@@ -306,29 +295,10 @@ msum_r16 (gfc_array_r16 * const restrict retarray,\n \n       if (unlikely (compile_options.bounds_check))\n \t{\n-\t  for (n=0; n < rank; n++)\n-\t    {\n-\t      index_type ret_extent;\n-\n-\t      ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,n);\n-\t      if (extent[n] != ret_extent)\n-\t\truntime_error (\"Incorrect extent in return value of\"\n-\t\t\t       \" SUM intrinsic in dimension %ld:\"\n-\t\t\t       \" is %ld, should be %ld\", (long int) n + 1,\n-\t\t\t       (long int) ret_extent, (long int) extent[n]);\n-\t    }\n-          for (n=0; n<= rank; n++)\n-            {\n-              index_type mask_extent, array_extent;\n-\n-\t      array_extent = GFC_DESCRIPTOR_EXTENT(array,n);\n-\t      mask_extent = GFC_DESCRIPTOR_EXTENT(mask,n);\n-\t      if (array_extent != mask_extent)\n-\t\truntime_error (\"Incorrect extent in MASK argument of\"\n-\t\t\t       \" SUM intrinsic in dimension %ld:\"\n-\t\t\t       \" is %ld, should be %ld\", (long int) n + 1,\n-\t\t\t       (long int) mask_extent, (long int) array_extent);\n-\t    }\n+\t  bounds_ifunction_return ((array_t *) retarray, extent,\n+\t\t\t\t   \"return value\", \"SUM\");\n+\t  bounds_equal_extents ((array_t *) mask, (array_t *) array,\n+\t  \t\t\t\"MASK argument\", \"SUM\");\n \t}\n     }\n "}, {"sha": "b8a5e68e6291be4b29da28eea20893b598a59dea", "filename": "libgfortran/generated/sum_r4.c", "status": "modified", "additions": 6, "deletions": 36, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/16bff92192676901670042cdce3fbd5f9c928fc8/libgfortran%2Fgenerated%2Fsum_r4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/16bff92192676901670042cdce3fbd5f9c928fc8/libgfortran%2Fgenerated%2Fsum_r4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fsum_r4.c?ref=16bff92192676901670042cdce3fbd5f9c928fc8", "patch": "@@ -119,19 +119,8 @@ sum_r4 (gfc_array_r4 * const restrict retarray,\n \t\t       (long int) rank);\n \n       if (unlikely (compile_options.bounds_check))\n-\t{\n-\t  for (n=0; n < rank; n++)\n-\t    {\n-\t      index_type ret_extent;\n-\n-\t      ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,n);\n-\t      if (extent[n] != ret_extent)\n-\t\truntime_error (\"Incorrect extent in return value of\"\n-\t\t\t       \" SUM intrinsic in dimension %ld:\"\n-\t\t\t       \" is %ld, should be %ld\", (long int) n + 1,\n-\t\t\t       (long int) ret_extent, (long int) extent[n]);\n-\t    }\n-\t}\n+\tbounds_ifunction_return ((array_t *) retarray, extent,\n+\t\t\t\t \"return value\", \"SUM\");\n     }\n \n   for (n = 0; n < rank; n++)\n@@ -306,29 +295,10 @@ msum_r4 (gfc_array_r4 * const restrict retarray,\n \n       if (unlikely (compile_options.bounds_check))\n \t{\n-\t  for (n=0; n < rank; n++)\n-\t    {\n-\t      index_type ret_extent;\n-\n-\t      ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,n);\n-\t      if (extent[n] != ret_extent)\n-\t\truntime_error (\"Incorrect extent in return value of\"\n-\t\t\t       \" SUM intrinsic in dimension %ld:\"\n-\t\t\t       \" is %ld, should be %ld\", (long int) n + 1,\n-\t\t\t       (long int) ret_extent, (long int) extent[n]);\n-\t    }\n-          for (n=0; n<= rank; n++)\n-            {\n-              index_type mask_extent, array_extent;\n-\n-\t      array_extent = GFC_DESCRIPTOR_EXTENT(array,n);\n-\t      mask_extent = GFC_DESCRIPTOR_EXTENT(mask,n);\n-\t      if (array_extent != mask_extent)\n-\t\truntime_error (\"Incorrect extent in MASK argument of\"\n-\t\t\t       \" SUM intrinsic in dimension %ld:\"\n-\t\t\t       \" is %ld, should be %ld\", (long int) n + 1,\n-\t\t\t       (long int) mask_extent, (long int) array_extent);\n-\t    }\n+\t  bounds_ifunction_return ((array_t *) retarray, extent,\n+\t\t\t\t   \"return value\", \"SUM\");\n+\t  bounds_equal_extents ((array_t *) mask, (array_t *) array,\n+\t  \t\t\t\"MASK argument\", \"SUM\");\n \t}\n     }\n "}, {"sha": "da9cec22372e43b36eaf875994cd906bdec69c7f", "filename": "libgfortran/generated/sum_r8.c", "status": "modified", "additions": 6, "deletions": 36, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/16bff92192676901670042cdce3fbd5f9c928fc8/libgfortran%2Fgenerated%2Fsum_r8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/16bff92192676901670042cdce3fbd5f9c928fc8/libgfortran%2Fgenerated%2Fsum_r8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fsum_r8.c?ref=16bff92192676901670042cdce3fbd5f9c928fc8", "patch": "@@ -119,19 +119,8 @@ sum_r8 (gfc_array_r8 * const restrict retarray,\n \t\t       (long int) rank);\n \n       if (unlikely (compile_options.bounds_check))\n-\t{\n-\t  for (n=0; n < rank; n++)\n-\t    {\n-\t      index_type ret_extent;\n-\n-\t      ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,n);\n-\t      if (extent[n] != ret_extent)\n-\t\truntime_error (\"Incorrect extent in return value of\"\n-\t\t\t       \" SUM intrinsic in dimension %ld:\"\n-\t\t\t       \" is %ld, should be %ld\", (long int) n + 1,\n-\t\t\t       (long int) ret_extent, (long int) extent[n]);\n-\t    }\n-\t}\n+\tbounds_ifunction_return ((array_t *) retarray, extent,\n+\t\t\t\t \"return value\", \"SUM\");\n     }\n \n   for (n = 0; n < rank; n++)\n@@ -306,29 +295,10 @@ msum_r8 (gfc_array_r8 * const restrict retarray,\n \n       if (unlikely (compile_options.bounds_check))\n \t{\n-\t  for (n=0; n < rank; n++)\n-\t    {\n-\t      index_type ret_extent;\n-\n-\t      ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,n);\n-\t      if (extent[n] != ret_extent)\n-\t\truntime_error (\"Incorrect extent in return value of\"\n-\t\t\t       \" SUM intrinsic in dimension %ld:\"\n-\t\t\t       \" is %ld, should be %ld\", (long int) n + 1,\n-\t\t\t       (long int) ret_extent, (long int) extent[n]);\n-\t    }\n-          for (n=0; n<= rank; n++)\n-            {\n-              index_type mask_extent, array_extent;\n-\n-\t      array_extent = GFC_DESCRIPTOR_EXTENT(array,n);\n-\t      mask_extent = GFC_DESCRIPTOR_EXTENT(mask,n);\n-\t      if (array_extent != mask_extent)\n-\t\truntime_error (\"Incorrect extent in MASK argument of\"\n-\t\t\t       \" SUM intrinsic in dimension %ld:\"\n-\t\t\t       \" is %ld, should be %ld\", (long int) n + 1,\n-\t\t\t       (long int) mask_extent, (long int) array_extent);\n-\t    }\n+\t  bounds_ifunction_return ((array_t *) retarray, extent,\n+\t\t\t\t   \"return value\", \"SUM\");\n+\t  bounds_equal_extents ((array_t *) mask, (array_t *) array,\n+\t  \t\t\t\"MASK argument\", \"SUM\");\n \t}\n     }\n "}, {"sha": "6adea76da3aea192e5a5c65181009c4f112ae46a", "filename": "libgfortran/intrinsics/cshift0.c", "status": "modified", "additions": 8, "deletions": 5, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/16bff92192676901670042cdce3fbd5f9c928fc8/libgfortran%2Fintrinsics%2Fcshift0.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/16bff92192676901670042cdce3fbd5f9c928fc8/libgfortran%2Fintrinsics%2Fcshift0.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fintrinsics%2Fcshift0.c?ref=16bff92192676901670042cdce3fbd5f9c928fc8", "patch": "@@ -87,14 +87,17 @@ cshift0 (gfc_array_char * ret, const gfc_array_char * array,\n       if (arraysize > 0)\n \tret->data = internal_malloc_size (size * arraysize);\n       else\n-\t{\n-\t  ret->data = internal_malloc_size (1);\n-\t  return;\n-\t}\n+\tret->data = internal_malloc_size (1);\n     }\n-  \n+  else if (unlikely (compile_options.bounds_check))\n+    {\n+      bounds_equal_extents ((array_t *) ret, (array_t *) array,\n+\t\t\t\t \"return value\", \"CSHIFT\");\n+    }\n+\n   if (arraysize == 0)\n     return;\n+\n   type_size = GFC_DTYPE_TYPE_SIZE (array);\n \n   switch(type_size)"}, {"sha": "74ba5ab7a97f275887ea9071e76661754adc897d", "filename": "libgfortran/intrinsics/eoshift0.c", "status": "modified", "additions": 15, "deletions": 4, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/16bff92192676901670042cdce3fbd5f9c928fc8/libgfortran%2Fintrinsics%2Feoshift0.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/16bff92192676901670042cdce3fbd5f9c928fc8/libgfortran%2Fintrinsics%2Feoshift0.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fintrinsics%2Feoshift0.c?ref=16bff92192676901670042cdce3fbd5f9c928fc8", "patch": "@@ -54,18 +54,20 @@ eoshift0 (gfc_array_char * ret, const gfc_array_char * array,\n   index_type dim;\n   index_type len;\n   index_type n;\n+  index_type arraysize;\n \n   /* The compiler cannot figure out that these are set, initialize\n      them to avoid warnings.  */\n   len = 0;\n   soffset = 0;\n   roffset = 0;\n \n+  arraysize = size0 ((array_t *) array);\n+\n   if (ret->data == NULL)\n     {\n       int i;\n \n-      ret->data = internal_malloc_size (size * size0 ((array_t *)array));\n       ret->offset = 0;\n       ret->dtype = array->dtype;\n       for (i = 0; i < GFC_DESCRIPTOR_RANK (array); i++)\n@@ -83,13 +85,22 @@ eoshift0 (gfc_array_char * ret, const gfc_array_char * array,\n \t  GFC_DIMENSION_SET(ret->dim[i], 0, ub, str);\n \n         }\n+\n+      if (arraysize > 0)\n+\tret->data = internal_malloc_size (size * arraysize);\n+      else\n+\tret->data = internal_malloc_size (1);\n+\n     }\n-  else\n+  else if (unlikely (compile_options.bounds_check))\n     {\n-      if (size0 ((array_t *) ret) == 0)\n-\treturn;\n+      bounds_equal_extents ((array_t *) ret, (array_t *) array,\n+\t\t\t\t \"return value\", \"EOSHIFT\");\n     }\n \n+  if (arraysize == 0)\n+    return;\n+\n   which = which - 1;\n \n   extent[0] = 1;"}, {"sha": "2fbf62e118c70675e7b6b83df54738a80efc1c63", "filename": "libgfortran/intrinsics/eoshift2.c", "status": "modified", "additions": 9, "deletions": 5, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/16bff92192676901670042cdce3fbd5f9c928fc8/libgfortran%2Fintrinsics%2Feoshift2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/16bff92192676901670042cdce3fbd5f9c928fc8/libgfortran%2Fintrinsics%2Feoshift2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fintrinsics%2Feoshift2.c?ref=16bff92192676901670042cdce3fbd5f9c928fc8", "patch": "@@ -75,7 +75,6 @@ eoshift2 (gfc_array_char *ret, const gfc_array_char *array,\n     {\n       int i;\n \n-      ret->data = internal_malloc_size (size * arraysize);\n       ret->offset = 0;\n       ret->dtype = array->dtype;\n       for (i = 0; i < GFC_DESCRIPTOR_RANK (array); i++)\n@@ -92,15 +91,20 @@ eoshift2 (gfc_array_char *ret, const gfc_array_char *array,\n \n \t  GFC_DIMENSION_SET(ret->dim[i], 0, ub, str);\n \n+\t  if (arraysize > 0)\n+\t    ret->data = internal_malloc_size (size * arraysize);\n+\t  else\n+\t    ret->data = internal_malloc_size (1);\n+\n         }\n     }\n-  else\n+  else if (unlikely (compile_options.bounds_check))\n     {\n-      if (size0 ((array_t *) ret) == 0)\n-\treturn;\n+      bounds_equal_extents ((array_t *) ret, (array_t *) array,\n+\t\t\t\t \"return value\", \"EOSHIFT\");\n     }\n \n-  if (arraysize == 0 && filler == NULL)\n+  if (arraysize == 0)\n     return;\n \n   which = which - 1;"}, {"sha": "acb02c413b22124e1ccf427fde0907b6949a5400", "filename": "libgfortran/libgfortran.h", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/16bff92192676901670042cdce3fbd5f9c928fc8/libgfortran%2Flibgfortran.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/16bff92192676901670042cdce3fbd5f9c928fc8/libgfortran%2Flibgfortran.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Flibgfortran.h?ref=16bff92192676901670042cdce3fbd5f9c928fc8", "patch": "@@ -1242,6 +1242,23 @@ typedef GFC_ARRAY_DESCRIPTOR (GFC_MAX_DIMENSIONS, void) array_t;\n extern index_type size0 (const array_t * array); \n iexport_proto(size0);\n \n+/* bounds.c */\n+\n+extern void bounds_equal_extents (array_t *, array_t *, const char *,\n+\t\t\t\t  const char *);\n+internal_proto(bounds_equal_extents);\n+\n+extern void bounds_reduced_extents (array_t *, array_t *, int, const char *,\n+\t\t\t     const char *intrinsic);\n+internal_proto(bounds_reduced_extents);\n+\n+extern void bounds_iforeach_return (array_t *, array_t *, const char *);\n+internal_proto(bounds_iforeach_return);\n+\n+extern void bounds_ifunction_return (array_t *, const index_type *,\n+\t\t\t\t     const char *, const char *);\n+internal_proto(bounds_ifunction_return);\n+\n /* Internal auxiliary functions for cshift */\n \n void cshift0_i1 (gfc_array_i1 *, const gfc_array_i1 *, ssize_t, int);"}, {"sha": "49a4f73404a6dda89c198911cca078e32e0df641", "filename": "libgfortran/m4/cshift1.m4", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/16bff92192676901670042cdce3fbd5f9c928fc8/libgfortran%2Fm4%2Fcshift1.m4", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/16bff92192676901670042cdce3fbd5f9c928fc8/libgfortran%2Fm4%2Fcshift1.m4", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fm4%2Fcshift1.m4?ref=16bff92192676901670042cdce3fbd5f9c928fc8", "patch": "@@ -99,6 +99,17 @@ cshift1 (gfc_array_char * const restrict ret,\n \t  GFC_DIMENSION_SET(ret->dim[i], 0, ub, str);\n         }\n     }\n+  else if (unlikely (compile_options.bounds_check))\n+    {\n+      bounds_equal_extents ((array_t *) ret, (array_t *) array,\n+\t\t\t\t \"return value\", \"CSHIFT\");\n+    }\n+\n+  if (unlikely (compile_options.bounds_check))\n+    {\n+      bounds_reduced_extents ((array_t *) h, (array_t *) array, which,\n+      \t\t\t      \"SHIFT argument\", \"CSHIFT\");\n+    }\n \n   if (arraysize == 0)\n     return;"}, {"sha": "be9b1008a60fa7c2fa2d8e4037d4e9644c3f0cc7", "filename": "libgfortran/m4/eoshift1.m4", "status": "modified", "additions": 20, "deletions": 4, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/16bff92192676901670042cdce3fbd5f9c928fc8/libgfortran%2Fm4%2Feoshift1.m4", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/16bff92192676901670042cdce3fbd5f9c928fc8/libgfortran%2Fm4%2Feoshift1.m4", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fm4%2Feoshift1.m4?ref=16bff92192676901670042cdce3fbd5f9c928fc8", "patch": "@@ -63,6 +63,7 @@ eoshift1 (gfc_array_char * const restrict ret,\n   index_type len;\n   index_type n;\n   index_type size;\n+  index_type arraysize;\n   int which;\n   'atype_name` sh;\n   'atype_name` delta;\n@@ -83,11 +84,12 @@ eoshift1 (gfc_array_char * const restrict ret,\n   extent[0] = 1;\n   count[0] = 0;\n \n+  arraysize = size0 ((array_t *) array);\n   if (ret->data == NULL)\n     {\n       int i;\n \n-      ret->data = internal_malloc_size (size * size0 ((array_t *)array));\n+      ret->data = internal_malloc_size (size * arraysize);\n       ret->offset = 0;\n       ret->dtype = array->dtype;\n       for (i = 0; i < GFC_DESCRIPTOR_RANK (array); i++)\n@@ -105,13 +107,27 @@ eoshift1 (gfc_array_char * const restrict ret,\n \t  GFC_DIMENSION_SET(ret->dim[i], 0, ub, str);\n \n         }\n+      if (arraysize > 0)\n+\tret->data = internal_malloc_size (size * arraysize);\n+      else\n+\tret->data = internal_malloc_size (1);\n+\n     }\n-  else\n+  else if (unlikely (compile_options.bounds_check))\n     {\n-      if (size0 ((array_t *) ret) == 0)\n-\treturn;\n+      bounds_equal_extents ((array_t *) ret, (array_t *) array,\n+\t\t\t\t \"return value\", \"EOSHIFT\");\n     }\n \n+  if (unlikely (compile_options.bounds_check))\n+    {\n+      bounds_reduced_extents ((array_t *) h, (array_t *) array, which,\n+      \t\t\t      \"SHIFT argument\", \"EOSHIFT\");\n+    }\n+\n+  if (arraysize == 0)\n+    return;\n+\n   n = 0;\n   for (dim = 0; dim < GFC_DESCRIPTOR_RANK (array); dim++)\n     {"}, {"sha": "6fa3bd2f7dcf599651070b13e9d7072522afa4c6", "filename": "libgfortran/m4/eoshift3.m4", "status": "modified", "additions": 19, "deletions": 4, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/16bff92192676901670042cdce3fbd5f9c928fc8/libgfortran%2Fm4%2Feoshift3.m4", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/16bff92192676901670042cdce3fbd5f9c928fc8/libgfortran%2Fm4%2Feoshift3.m4", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fm4%2Feoshift3.m4?ref=16bff92192676901670042cdce3fbd5f9c928fc8", "patch": "@@ -67,6 +67,7 @@ eoshift3 (gfc_array_char * const restrict ret,\n   index_type len;\n   index_type n;\n   index_type size;\n+  index_type arraysize;\n   int which;\n   'atype_name` sh;\n   'atype_name` delta;\n@@ -77,6 +78,7 @@ eoshift3 (gfc_array_char * const restrict ret,\n   soffset = 0;\n   roffset = 0;\n \n+  arraysize = size0 ((array_t *) array);\n   size = GFC_DESCRIPTOR_SIZE(array);\n \n   if (pwhich)\n@@ -88,7 +90,7 @@ eoshift3 (gfc_array_char * const restrict ret,\n     {\n       int i;\n \n-      ret->data = internal_malloc_size (size * size0 ((array_t *)array));\n+      ret->data = internal_malloc_size (size * arraysize);\n       ret->offset = 0;\n       ret->dtype = array->dtype;\n       for (i = 0; i < GFC_DESCRIPTOR_RANK (array); i++)\n@@ -106,13 +108,26 @@ eoshift3 (gfc_array_char * const restrict ret,\n \t  GFC_DIMENSION_SET(ret->dim[i], 0, ub, str);\n \n         }\n+      if (arraysize > 0)\n+\tret->data = internal_malloc_size (size * arraysize);\n+      else\n+\tret->data = internal_malloc_size (1);\n+\n     }\n-  else\n+  else if (unlikely (compile_options.bounds_check))\n+    {\n+      bounds_equal_extents ((array_t *) ret, (array_t *) array,\n+\t\t\t\t \"return value\", \"EOSHIFT\");\n+    }\n+\n+  if (unlikely (compile_options.bounds_check))\n     {\n-      if (size0 ((array_t *) ret) == 0)\n-\treturn;\n+      bounds_reduced_extents ((array_t *) h, (array_t *) array, which,\n+      \t\t\t      \"SHIFT argument\", \"EOSHIFT\");\n     }\n \n+  if (arraysize == 0)\n+    return;\n \n   extent[0] = 1;\n   count[0] = 0;"}, {"sha": "d86d298a3af54fc2be7d1bf33d8454f773a1da44", "filename": "libgfortran/m4/iforeach.m4", "status": "modified", "additions": 9, "deletions": 61, "changes": 70, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/16bff92192676901670042cdce3fbd5f9c928fc8/libgfortran%2Fm4%2Fiforeach.m4", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/16bff92192676901670042cdce3fbd5f9c928fc8/libgfortran%2Fm4%2Fiforeach.m4", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fm4%2Fiforeach.m4?ref=16bff92192676901670042cdce3fbd5f9c928fc8", "patch": "@@ -35,21 +35,8 @@ name`'rtype_qual`_'atype_code (rtype * const restrict retarray,\n   else\n     {\n       if (unlikely (compile_options.bounds_check))\n-\t{\n-\t  int ret_rank;\n-\t  index_type ret_extent;\n-\n-\t  ret_rank = GFC_DESCRIPTOR_RANK (retarray);\n-\t  if (ret_rank != 1)\n-\t    runtime_error (\"rank of return array in u_name intrinsic\"\n-\t\t\t   \" should be 1, is %ld\", (long int) ret_rank);\n-\n-\t  ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,0);\n-\t  if (ret_extent != rank)\n-\t    runtime_error (\"Incorrect extent in return value of\"\n-\t\t\t   \" u_name intrnisic: is %ld, should be %ld\",\n-\t\t\t   (long int) ret_extent, (long int) rank);\n-\t}\n+        bounds_iforeach_return ((array_t *) retarray, (array_t *) array,\n+\t                        \"u_name\");\n     }\n \n   dstride = GFC_DESCRIPTOR_STRIDE(retarray,0);\n@@ -150,38 +137,11 @@ void\n     {\n       if (unlikely (compile_options.bounds_check))\n \t{\n-\t  int ret_rank, mask_rank;\n-\t  index_type ret_extent;\n-\t  int n;\n-\t  index_type array_extent, mask_extent;\n-\n-\t  ret_rank = GFC_DESCRIPTOR_RANK (retarray);\n-\t  if (ret_rank != 1)\n-\t    runtime_error (\"rank of return array in u_name intrinsic\"\n-\t\t\t   \" should be 1, is %ld\", (long int) ret_rank);\n-\n-\t  ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,0);\n-\t  if (ret_extent != rank)\n-\t    runtime_error (\"Incorrect extent in return value of\"\n-\t\t\t   \" u_name intrnisic: is %ld, should be %ld\",\n-\t\t\t   (long int) ret_extent, (long int) rank);\n-\t\n-\t  mask_rank = GFC_DESCRIPTOR_RANK (mask);\n-\t  if (rank != mask_rank)\n-\t    runtime_error (\"rank of MASK argument in u_name intrnisic\"\n-\t                   \"should be %ld, is %ld\", (long int) rank,\n-\t\t\t   (long int) mask_rank);\n \n-\t  for (n=0; n<rank; n++)\n-\t    {\n-\t      array_extent = GFC_DESCRIPTOR_EXTENT(array,n);\n-\t      mask_extent = GFC_DESCRIPTOR_EXTENT(mask,n);\n-\t      if (array_extent != mask_extent)\n-\t\truntime_error (\"Incorrect extent in MASK argument of\"\n-\t\t\t       \" u_name intrinsic in dimension %ld:\"\n-\t\t\t       \" is %ld, should be %ld\", (long int) n + 1,\n-\t\t\t       (long int) mask_extent, (long int) array_extent);\n-\t    }\n+\t  bounds_iforeach_return ((array_t *) retarray, (array_t *) array,\n+\t\t\t\t  \"u_name\");\n+\t  bounds_equal_extents ((array_t *) mask, (array_t *) array,\n+\t\t\t\t  \"MASK argument\", \"u_name\");\n \t}\n     }\n \n@@ -303,22 +263,10 @@ void\n       retarray->offset = 0;\n       retarray->data = internal_malloc_size (sizeof (rtype_name) * rank);\n     }\n-  else\n+  else if (unlikely (compile_options.bounds_check))\n     {\n-      if (unlikely (compile_options.bounds_check))\n-\t{\n-\t  int ret_rank;\n-\t  index_type ret_extent;\n-\n-\t  ret_rank = GFC_DESCRIPTOR_RANK (retarray);\n-\t  if (ret_rank != 1)\n-\t    runtime_error (\"rank of return array in u_name intrinsic\"\n-\t\t\t   \" should be 1, is %ld\", (long int) ret_rank);\n-\n-\t  ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,0);\n-\t    if (ret_extent != rank)\n-\t      runtime_error (\"dimension of return array incorrect\");\n-\t}\n+       bounds_iforeach_return ((array_t *) retarray, (array_t *) array,\n+\t\t\t       \"u_name\");\n     }\n \n   dstride = GFC_DESCRIPTOR_STRIDE(retarray,0);"}, {"sha": "66b1d98b1adf90046566d3d3b64f167a805db9a8", "filename": "libgfortran/m4/ifunction.m4", "status": "modified", "additions": 6, "deletions": 36, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/16bff92192676901670042cdce3fbd5f9c928fc8/libgfortran%2Fm4%2Fifunction.m4", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/16bff92192676901670042cdce3fbd5f9c928fc8/libgfortran%2Fm4%2Fifunction.m4", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fm4%2Fifunction.m4?ref=16bff92192676901670042cdce3fbd5f9c928fc8", "patch": "@@ -107,19 +107,8 @@ name`'rtype_qual`_'atype_code (rtype * const restrict retarray,\n \t\t       (long int) rank);\n \n       if (unlikely (compile_options.bounds_check))\n-\t{\n-\t  for (n=0; n < rank; n++)\n-\t    {\n-\t      index_type ret_extent;\n-\n-\t      ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,n);\n-\t      if (extent[n] != ret_extent)\n-\t\truntime_error (\"Incorrect extent in return value of\"\n-\t\t\t       \" u_name intrinsic in dimension %ld:\"\n-\t\t\t       \" is %ld, should be %ld\", (long int) n + 1,\n-\t\t\t       (long int) ret_extent, (long int) extent[n]);\n-\t    }\n-\t}\n+\tbounds_ifunction_return ((array_t *) retarray, extent,\n+\t\t\t\t \"return value\", \"u_name\");\n     }\n \n   for (n = 0; n < rank; n++)\n@@ -294,29 +283,10 @@ void\n \n       if (unlikely (compile_options.bounds_check))\n \t{\n-\t  for (n=0; n < rank; n++)\n-\t    {\n-\t      index_type ret_extent;\n-\n-\t      ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,n);\n-\t      if (extent[n] != ret_extent)\n-\t\truntime_error (\"Incorrect extent in return value of\"\n-\t\t\t       \" u_name intrinsic in dimension %ld:\"\n-\t\t\t       \" is %ld, should be %ld\", (long int) n + 1,\n-\t\t\t       (long int) ret_extent, (long int) extent[n]);\n-\t    }\n-          for (n=0; n<= rank; n++)\n-            {\n-              index_type mask_extent, array_extent;\n-\n-\t      array_extent = GFC_DESCRIPTOR_EXTENT(array,n);\n-\t      mask_extent = GFC_DESCRIPTOR_EXTENT(mask,n);\n-\t      if (array_extent != mask_extent)\n-\t\truntime_error (\"Incorrect extent in MASK argument of\"\n-\t\t\t       \" u_name intrinsic in dimension %ld:\"\n-\t\t\t       \" is %ld, should be %ld\", (long int) n + 1,\n-\t\t\t       (long int) mask_extent, (long int) array_extent);\n-\t    }\n+\t  bounds_ifunction_return ((array_t *) retarray, extent,\n+\t\t\t\t   \"return value\", \"u_name\");\n+\t  bounds_equal_extents ((array_t *) mask, (array_t *) array,\n+\t  \t\t\t\"MASK argument\", \"u_name\");\n \t}\n     }\n "}, {"sha": "8a7affd2e180e428957711fc27708837cc515a9c", "filename": "libgfortran/runtime/bounds.c", "status": "added", "additions": 199, "deletions": 0, "changes": 199, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/16bff92192676901670042cdce3fbd5f9c928fc8/libgfortran%2Fruntime%2Fbounds.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/16bff92192676901670042cdce3fbd5f9c928fc8/libgfortran%2Fruntime%2Fbounds.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fruntime%2Fbounds.c?ref=16bff92192676901670042cdce3fbd5f9c928fc8", "patch": "@@ -0,0 +1,199 @@\n+/* Copyright (C) 2009\n+   Free Software Foundation, Inc.\n+   Contributed by Thomas Koenig\n+\n+This file is part of the GNU Fortran runtime library (libgfortran).\n+\n+Libgfortran is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 3, or (at your option)\n+any later version.\n+\n+Libgfortran is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+Under Section 7 of GPL version 3, you are granted additional\n+permissions described in the GCC Runtime Library Exception, version\n+3.1, as published by the Free Software Foundation.\n+\n+You should have received a copy of the GNU General Public License and\n+a copy of the GCC Runtime Library Exception along with this program;\n+see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#include \"libgfortran.h\"\n+#include <assert.h>\n+\n+/* Auxiliary functions for bounds checking, mostly to reduce library size.  */\n+\n+/* Bounds checking for the return values of the iforeach functions (such\n+   as maxloc and minloc).  The extent of ret_array must\n+   must match the rank of array.  */\n+\n+void\n+bounds_iforeach_return (array_t *retarray, array_t *array, const char *name)\n+{\n+  index_type rank;\n+  index_type ret_rank;\n+  index_type ret_extent;\n+\n+  ret_rank = GFC_DESCRIPTOR_RANK (retarray);\n+\n+  if (ret_rank != 1)\n+    runtime_error (\"Incorrect rank of return array in %s intrinsic:\"\n+\t\t   \"is %ld, should be 1\", name, (long int) ret_rank);\n+\n+  rank = GFC_DESCRIPTOR_RANK (array);\n+  ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,0);\n+  if (ret_extent != rank)\n+    runtime_error (\"Incorrect extent in return value of\"\n+\t\t   \" %s intrinsic: is %ld, should be %ld\",\n+\t\t   name, (long int) ret_extent, (long int) rank);\n+\n+}\n+\n+/* Check the return of functions generated from ifunction.m4.\n+   We check the array descriptor \"a\" against the extents precomputed\n+   from ifunction.m4, and complain about the argument a_name in the\n+   intrinsic function. */\n+\n+void\n+bounds_ifunction_return (array_t * a, const index_type * extent,\n+\t\t\t const char * a_name, const char * intrinsic)\n+{\n+  int empty;\n+  int n;\n+  int rank;\n+  index_type a_size;\n+\n+  rank = GFC_DESCRIPTOR_RANK (a);\n+  a_size = size0 (a);\n+\n+  empty = 0;\n+  for (n = 0; n < rank; n++)\n+    {\n+      if (extent[n] == 0)\n+\tempty = 1;\n+    }\n+  if (empty)\n+    {\n+      if (a_size != 0)\n+\truntime_error (\"Incorrect size in %s of %s\"\n+\t\t       \" intrinsic: should be zero-sized\",\n+\t\t       a_name, intrinsic);\n+    }\n+  else\n+    {\n+      if (a_size == 0)\n+\truntime_error (\"Incorrect size of %s in %s\"\n+\t\t       \" intrinsic: should not be zero-sized\",\n+\t\t       a_name, intrinsic);\n+\n+      for (n = 0; n < rank; n++)\n+\t{\n+\t  index_type a_extent;\n+\t  a_extent = GFC_DESCRIPTOR_EXTENT(a, n);\n+\t  if (a_extent != extent[n])\n+\t    runtime_error(\"Incorrect extent in %s of %s\"\n+\t\t\t  \" intrinsic in dimension %ld: is %ld,\"\n+\t\t\t  \" should be %ld\", a_name, intrinsic, (long int) n + 1,\n+\t\t\t  (long int) a_extent, (long int) extent[n]);\n+\n+\t}\n+    }\n+}\n+\n+/* Check that two arrays have equal extents, or are both zero-sized.  Abort\n+   with a runtime error if this is not the case.  Complain that a has the\n+   wrong size.  */\n+\n+void\n+bounds_equal_extents (array_t *a, array_t *b, const char *a_name,\n+\t\t      const char *intrinsic)\n+{\n+  index_type a_size, b_size, n;\n+\n+  assert (GFC_DESCRIPTOR_RANK(a) == GFC_DESCRIPTOR_RANK(b));\n+\n+  a_size = size0 (a);\n+  b_size = size0 (b);\n+\n+  if (b_size == 0)\n+    {\n+      if (a_size != 0)\n+\truntime_error (\"Incorrect size of %s in %s\"\n+\t\t       \" intrinsic: should be zero-sized\",\n+\t\t       a_name, intrinsic);\n+    }\n+  else\n+    {\n+      if (a_size == 0) \n+\truntime_error (\"Incorrect size of %s of %s\"\n+\t\t       \" intrinsic: Should not be zero-sized\",\n+\t\t       a_name, intrinsic);\n+\n+      for (n = 0; n < GFC_DESCRIPTOR_RANK (b); n++)\n+\t{\n+\t  index_type a_extent, b_extent;\n+\t  \n+\t  a_extent = GFC_DESCRIPTOR_EXTENT(a, n);\n+\t  b_extent = GFC_DESCRIPTOR_EXTENT(b, n);\n+\t  if (a_extent != b_extent)\n+\t    runtime_error(\"Incorrect extent in %s of %s\"\n+\t\t\t  \" intrinsic in dimension %ld: is %ld,\"\n+\t\t\t  \" should be %ld\", a_name, intrinsic, (long int) n + 1,\n+\t\t\t  (long int) a_extent, (long int) b_extent);\n+\t}\n+    }\n+}\n+\n+/* Check that the extents of a and b agree, except that a has a missing\n+   dimension in argument which.  Complain about a if anything is wrong.  */\n+\n+void\n+bounds_reduced_extents (array_t *a, array_t *b, int which, const char *a_name,\n+\t\t      const char *intrinsic)\n+{\n+\n+  index_type i, n, a_size, b_size;\n+\n+  assert (GFC_DESCRIPTOR_RANK(a) == GFC_DESCRIPTOR_RANK(b) - 1);\n+\n+  a_size = size0 (a);\n+  b_size = size0 (b);\n+\n+  if (b_size == 0)\n+    {\n+      if (a_size != 0)\n+\truntime_error (\"Incorrect size in %s of %s\"\n+\t\t       \" intrinsic: should not be zero-sized\",\n+\t\t       a_name, intrinsic);\n+    }\n+  else\n+    {\n+      if (a_size == 0) \n+\truntime_error (\"Incorrect size of %s of %s\"\n+\t\t       \" intrinsic: should be zero-sized\",\n+\t\t       a_name, intrinsic);\n+\n+      i = 0;\n+      for (n = 0; n < GFC_DESCRIPTOR_RANK (b); n++)\n+\t{\n+\t  index_type a_extent, b_extent;\n+\n+\t  if (n != which)\n+\t    {\n+\t      a_extent = GFC_DESCRIPTOR_EXTENT(a, i);\n+\t      b_extent = GFC_DESCRIPTOR_EXTENT(b, n);\n+\t      if (a_extent != b_extent)\n+\t\truntime_error(\"Incorrect extent in %s of %s\"\n+\t\t\t      \" intrinsic in dimension %ld: is %ld,\"\n+\t\t\t      \" should be %ld\", a_name, intrinsic, (long int) i + 1,\n+\t\t\t      (long int) a_extent, (long int) b_extent);\n+\t      i++;\n+\t    }\n+\t}\n+    }\n+}"}]}