{"sha": "e6d4b9841c35629de91c36ba40ed247fef749037", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTZkNGI5ODQxYzM1NjI5ZGU5MWMzNmJhNDBlZDI0N2ZlZjc0OTAzNw==", "commit": {"author": {"name": "Joseph Myers", "email": "joseph@codesourcery.com", "date": "2010-11-26T23:18:28Z"}, "committer": {"name": "Joseph Myers", "email": "jsm28@gcc.gnu.org", "date": "2010-11-26T23:18:28Z"}, "message": "options.texi (Enum, EnumValue): Document new record types.\n\n\t* doc/options.texi (Enum, EnumValue): Document new record types.\n\t(Enum): Document new option flag.\n\t* opt-functions.awk\n\t* optc-gen.awk: Handle enumerated option arguments.\n\t* opth-gen.awk: Handle enumerated option arguments.\n\t* opts-common.c (enum_arg_ok_for_language, enum_arg_to_value,\n\tenum_value_to_arg): New.\n\t(decode_cmdline_option): Handle enumerated arguments.\n\t(read_cmdline_option): Handle CL_ERR_ENUM_ARG.\n\t(set_option, option_enabled, get_option_state): Handle CLVC_ENUM.\n\t* opts.c (print_filtered_help, print_specific_help): Take\n\tlang_mask arguments.\n\t(print_filtered_help): Handle printing values of enumerated\n\toptions.  Print possible arguments for enumerated options.\n\t(print_specific_help): Update call to print_filtered_help.\n\t(common_handle_option): Update calls to print_specific_help.  Use\n\tvalue rather than arg for OPT_fdiagnostics_show_location_.  Don't\n\thandle OPT_ffp_contract_, OPT_fexcess_precision_,\n\tOPT_fvisibility_, OPT_ftls_model_, OPT_fira_algorithm_ or\n\tOPT_fira_region_ here.\n\t* opts.h (enum cl_var_type): Add CLVC_ENUM.\n\t(struct cl_option): Add var_enum.\n\t(CL_ENUM_CANONICAL, CL_ENUM_DRIVER_ONLY, struct cl_enum_arg,\n\tstruct cl_enum, cl_enums, cl_enums_count): New.\n\t(CL_ERR_ENUM_ARG): Define.\n\t(CL_ERR_NEGATIVE): Update value.\n\t(enum_value_to_arg): Declare.\n\t* common.opt (flag_ira_algorithm, flag_ira_region,\n\tflag_fp_contract_mode, flag_excess_precision_cmdline,\n\tdefault_visibility, flag_tls_default): Remove Variable entries.\n\t(help_enum_printed): New Variable.\n\t(fdiagnostics-show-location=): Use Enum.  Add associated\n\tSourceInclude, Enum and EnumValue entries.\n\t(fexcess-precision=, ffp-contract=, fira-algorithm=, fira-region=,\n\tftls-model=, fvisibility=): Use Enum, Var and Init.  Add\n\tassociated Enum and EnumValue entries.\n\npo:\n\t* exgettext: Handle UnknownError.\n\nFrom-SVN: r167190", "tree": {"sha": "36e9808ac190cda7d402aca282c7bbe11cbf8b71", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/36e9808ac190cda7d402aca282c7bbe11cbf8b71"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e6d4b9841c35629de91c36ba40ed247fef749037", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e6d4b9841c35629de91c36ba40ed247fef749037", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e6d4b9841c35629de91c36ba40ed247fef749037", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e6d4b9841c35629de91c36ba40ed247fef749037/comments", "author": {"login": "jsm28", "id": 10537793, "node_id": "MDQ6VXNlcjEwNTM3Nzkz", "avatar_url": "https://avatars.githubusercontent.com/u/10537793?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jsm28", "html_url": "https://github.com/jsm28", "followers_url": "https://api.github.com/users/jsm28/followers", "following_url": "https://api.github.com/users/jsm28/following{/other_user}", "gists_url": "https://api.github.com/users/jsm28/gists{/gist_id}", "starred_url": "https://api.github.com/users/jsm28/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jsm28/subscriptions", "organizations_url": "https://api.github.com/users/jsm28/orgs", "repos_url": "https://api.github.com/users/jsm28/repos", "events_url": "https://api.github.com/users/jsm28/events{/privacy}", "received_events_url": "https://api.github.com/users/jsm28/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jsm28", "id": 10537793, "node_id": "MDQ6VXNlcjEwNTM3Nzkz", "avatar_url": "https://avatars.githubusercontent.com/u/10537793?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jsm28", "html_url": "https://github.com/jsm28", "followers_url": "https://api.github.com/users/jsm28/followers", "following_url": "https://api.github.com/users/jsm28/following{/other_user}", "gists_url": "https://api.github.com/users/jsm28/gists{/gist_id}", "starred_url": "https://api.github.com/users/jsm28/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jsm28/subscriptions", "organizations_url": "https://api.github.com/users/jsm28/orgs", "repos_url": "https://api.github.com/users/jsm28/repos", "events_url": "https://api.github.com/users/jsm28/events{/privacy}", "received_events_url": "https://api.github.com/users/jsm28/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8a1ffe230e5f07f6eef4bd30088f4245783109ec", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8a1ffe230e5f07f6eef4bd30088f4245783109ec", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8a1ffe230e5f07f6eef4bd30088f4245783109ec"}], "stats": {"total": 725, "additions": 597, "deletions": 128}, "files": [{"sha": "659ca468c5d6853cf949ba9be4ca7849b3beea47", "filename": "gcc/ChangeLog", "status": "modified", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e6d4b9841c35629de91c36ba40ed247fef749037/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e6d4b9841c35629de91c36ba40ed247fef749037/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=e6d4b9841c35629de91c36ba40ed247fef749037", "patch": "@@ -1,3 +1,42 @@\n+2010-11-26  Joseph Myers  <joseph@codesourcery.com>\n+\n+\t* doc/options.texi (Enum, EnumValue): Document new record types.\n+\t(Enum): Document new option flag.\n+\t* opt-functions.awk\n+\t* optc-gen.awk: Handle enumerated option arguments.\n+\t* opth-gen.awk: Handle enumerated option arguments.\n+\t* opts-common.c (enum_arg_ok_for_language, enum_arg_to_value,\n+\tenum_value_to_arg): New.\n+\t(decode_cmdline_option): Handle enumerated arguments.\n+\t(read_cmdline_option): Handle CL_ERR_ENUM_ARG.\n+\t(set_option, option_enabled, get_option_state): Handle CLVC_ENUM.\n+\t* opts.c (print_filtered_help, print_specific_help): Take\n+\tlang_mask arguments.\n+\t(print_filtered_help): Handle printing values of enumerated\n+\toptions.  Print possible arguments for enumerated options.\n+\t(print_specific_help): Update call to print_filtered_help.\n+\t(common_handle_option): Update calls to print_specific_help.  Use\n+\tvalue rather than arg for OPT_fdiagnostics_show_location_.  Don't\n+\thandle OPT_ffp_contract_, OPT_fexcess_precision_,\n+\tOPT_fvisibility_, OPT_ftls_model_, OPT_fira_algorithm_ or\n+\tOPT_fira_region_ here.\n+\t* opts.h (enum cl_var_type): Add CLVC_ENUM.\n+\t(struct cl_option): Add var_enum.\n+\t(CL_ENUM_CANONICAL, CL_ENUM_DRIVER_ONLY, struct cl_enum_arg,\n+\tstruct cl_enum, cl_enums, cl_enums_count): New.\n+\t(CL_ERR_ENUM_ARG): Define.\n+\t(CL_ERR_NEGATIVE): Update value.\n+\t(enum_value_to_arg): Declare.\n+\t* common.opt (flag_ira_algorithm, flag_ira_region,\n+\tflag_fp_contract_mode, flag_excess_precision_cmdline,\n+\tdefault_visibility, flag_tls_default): Remove Variable entries.\n+\t(help_enum_printed): New Variable.\n+\t(fdiagnostics-show-location=): Use Enum.  Add associated\n+\tSourceInclude, Enum and EnumValue entries.\n+\t(fexcess-precision=, ffp-contract=, fira-algorithm=, fira-region=,\n+\tftls-model=, fvisibility=): Use Enum, Var and Init.  Add\n+\tassociated Enum and EnumValue entries.\n+\n 2010-11-26  Joern Rennecke  <amylaar@spamcop.net>\n \n \tPR target/46623"}, {"sha": "57f5b0a27e983e7ddd92652057e33ea11942a318", "filename": "gcc/common.opt", "status": "modified", "additions": 98, "deletions": 33, "changes": 131, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e6d4b9841c35629de91c36ba40ed247fef749037/gcc%2Fcommon.opt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e6d4b9841c35629de91c36ba40ed247fef749037/gcc%2Fcommon.opt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcommon.opt?ref=e6d4b9841c35629de91c36ba40ed247fef749037", "patch": "@@ -42,31 +42,13 @@ int flag_complex_method = 1\n Variable\n int flag_evaluation_order = 0\n \n-; Set the default region and algorithm for the integrated register\n-; allocator.\n-\n-Variable\n-enum ira_algorithm flag_ira_algorithm = IRA_ALGORITHM_CB\n-\n-Variable\n-enum ira_region flag_ira_region = IRA_REGION_MIXED\n-\n ; Language specific warning pass for unused results.\n Variable\n bool flag_warn_unused_result = false\n \n Variable\n int *param_values\n \n-; Floating-point contraction mode, fast by default.\n-Variable\n-enum fp_contract_mode flag_fp_contract_mode = FP_CONTRACT_FAST\n-\n-; The excess precision specified on the command line, or defaulted by\n-; the front end.\n-Variable\n-enum excess_precision flag_excess_precision_cmdline = EXCESS_PRECISION_DEFAULT\n-\n ; Nonzero if we should write GIMPLE bytecode for link-time optimization.\n Variable\n int flag_generate_lto\n@@ -97,14 +79,6 @@ int flag_gen_aux_info = 0\n Variable\n int flag_shlib\n \n-; The default visibility for all symbols (unless overridden).\n-Variable\n-enum symbol_visibility default_visibility = VISIBILITY_DEFAULT\n-\n-; Set to the default thread-local storage (tls) model to use.\n-Variable\n-enum tls_model flag_tls_default = TLS_MODEL_GLOBAL_DYNAMIC\n-\n ; These two are really VEC(char_p,heap) *.\n \n Variable\n@@ -187,6 +161,12 @@ enum graph_dump_types graph_dump_format = no_graph\n Variable\n char *help_printed\n \n+; Which enums have been printed by --help.  0 = not printed, no\n+; relevant options seen, 1 = relevant option seen, not yet printed, 2\n+; = printed.\n+Variable\n+char *help_enum_printed\n+\n ; The number of columns for --help output.\n Variable\n unsigned int help_columns\n@@ -897,9 +877,22 @@ Common Report Var(flag_delete_null_pointer_checks) Init(1) Optimization\n Delete useless null pointer checks\n \n fdiagnostics-show-location=\n-Common Joined RejectNegative\n+Common Joined RejectNegative Enum(diagnostic_prefixing_rule)\n -fdiagnostics-show-location=[once|every-line]\tHow often to emit source location at the beginning of line-wrapped diagnostics\n \n+; Required for these enum values.\n+SourceInclude\n+pretty-print.h\n+\n+Enum\n+Name(diagnostic_prefixing_rule) Type(int)\n+\n+EnumValue\n+Enum(diagnostic_prefixing_rule) String(once) Value(DIAGNOSTICS_SHOW_PREFIX_ONCE)\n+\n+EnumValue\n+Enum(diagnostic_prefixing_rule) String(every-line) Value(DIAGNOSTICS_SHOW_PREFIX_EVERY_LINE)\n+\n fdiagnostics-show-option\n Common Var(flag_diagnostics_show_option) Init(1)\n Amend appropriate diagnostic messages with the command line option that controls them\n@@ -972,9 +965,18 @@ Common Report Var(flag_expensive_optimizations) Optimization\n Perform a number of minor, expensive optimizations\n \n fexcess-precision=\n-Common Joined RejectNegative\n+Common Joined RejectNegative Enum(excess_precision) Var(flag_excess_precision_cmdline) Init(EXCESS_PRECISION_DEFAULT)\n -fexcess-precision=[fast|standard]\tSpecify handling of excess floating-point precision\n \n+Enum\n+Name(excess_precision) Type(enum excess_precision) UnknownError(unknown excess precision style %qs)\n+\n+EnumValue\n+Enum(excess_precision) String(fast) Value(EXCESS_PRECISION_FAST)\n+\n+EnumValue\n+Enum(excess_precision) String(standard) Value(EXCESS_PRECISION_STANDARD)\n+\n ffast-math\n Common\n \n@@ -999,9 +1001,22 @@ Common Report Var(flag_forward_propagate) Optimization\n Perform a forward propagation pass on RTL\n \n ffp-contract=\n-Common Joined RejectNegative\n+Common Joined RejectNegative Enum(fp_contract_mode) Var(flag_fp_contract_mode) Init(FP_CONTRACT_FAST)\n -ffp-contract=[off|on|fast] Perform floating-point expression contraction.\n \n+Enum\n+Name(fp_contract_mode) Type(enum fp_contract_mode) UnknownError(unknown floating point contraction style %qs)\n+\n+EnumValue\n+Enum(fp_contract_mode) String(off) Value(FP_CONTRACT_OFF)\n+\n+; Not implemented, fall back to conservative FP_CONTRACT_OFF.\n+EnumValue\n+Enum(fp_contract_mode) String(on) Value(FP_CONTRACT_OFF)\n+\n+EnumValue\n+Enum(fp_contract_mode) String(fast) Value(FP_CONTRACT_FAST)\n+\n ; Nonzero means don't put addresses of constant functions in registers.\n ; Used for compiling the Unix kernel, where strange substitutions are\n ; done on the assembly output.\n@@ -1183,13 +1198,34 @@ Perform structure layout optimizations based\n on profiling information.\n \n fira-algorithm=\n-Common Joined RejectNegative\n+Common Joined RejectNegative Enum(ira_algorithm) Var(flag_ira_algorithm) Init(IRA_ALGORITHM_CB)\n -fira-algorithm=[CB|priority] Set the used IRA algorithm\n \n+Enum\n+Name(ira_algorithm) Type(enum ira_algorithm) UnknownError(unknown IRA algorithm %qs)\n+\n+EnumValue\n+Enum(ira_algorithm) String(CB) Value(IRA_ALGORITHM_CB)\n+\n+EnumValue\n+Enum(ira_algorithm) String(priority) Value(IRA_ALGORITHM_PRIORITY)\n+\n fira-region=\n-Common Joined RejectNegative\n+Common Joined RejectNegative Enum(ira_region) Var(flag_ira_region) Init(IRA_REGION_MIXED)\n -fira-region=[one|all|mixed] Set regions for IRA\n \n+Enum\n+Name(ira_region) Type(enum ira_region) UnknownError(unknown IRA region %qs)\n+\n+EnumValue\n+Enum(ira_region) String(one) Value(IRA_REGION_ONE)\n+\n+EnumValue\n+Enum(ira_region) String(all) Value(IRA_REGION_ALL)\n+\n+EnumValue\n+Enum(ira_region) String(mixed) Value(IRA_REGION_MIXED)\n+\n fira-loop-pressure\n Common Report Var(flag_ira_loop_pressure)\n Use IRA based register pressure calculation\n@@ -1718,9 +1754,24 @@ Common Report Var(time_report)\n Report the time taken by each compiler pass\n \n ftls-model=\n-Common Joined RejectNegative\n+Common Joined RejectNegative Enum(tls_model) Var(flag_tls_default) Init(TLS_MODEL_GLOBAL_DYNAMIC)\n -ftls-model=[global-dynamic|local-dynamic|initial-exec|local-exec]\tSet the default thread-local storage code generation model\n \n+Enum\n+Name(tls_model) Type(enum tls_model) UnknownError(unknown TLS model %qs)\n+\n+EnumValue\n+Enum(tls_model) String(global-dynamic) Value(TLS_MODEL_GLOBAL_DYNAMIC)\n+\n+EnumValue\n+Enum(tls_model) String(local-dynamic) Value(TLS_MODEL_LOCAL_DYNAMIC)\n+\n+EnumValue\n+Enum(tls_model) String(initial-exec) Value(TLS_MODEL_INITIAL_EXEC)\n+\n+EnumValue\n+Enum(tls_model) String(local-exec) Value(TLS_MODEL_LOCAL_EXEC)\n+\n ftoplevel-reorder\n Common Report Var(flag_toplevel_reorder) Init(2) Optimization\n Reorder top level functions, variables, and asms\n@@ -1973,9 +2024,23 @@ Common Report Var(flag_verbose_asm)\n Add extra commentary to assembler output\n \n fvisibility=\n-Common Joined RejectNegative\n+Common Joined RejectNegative Enum(symbol_visibility) Var(default_visibility) Init(VISIBILITY_DEFAULT)\n -fvisibility=[default|internal|hidden|protected]\tSet the default symbol visibility\n \n+Enum\n+Name(symbol_visibility) Type(enum symbol_visibility) UnknownError(unrecognized visibility value %qs)\n+\n+EnumValue\n+Enum(symbol_visibility) String(default) Value(VISIBILITY_DEFAULT)\n+\n+EnumValue\n+Enum(symbol_visibility) String(internal) Value(VISIBILITY_INTERNAL)\n+\n+EnumValue\n+Enum(symbol_visibility) String(hidden) Value(VISIBILITY_HIDDEN)\n+\n+EnumValue\n+Enum(symbol_visibility) String(protected) Value(VISIBILITY_PROTECTED)\n \n fvpt\n Common Report Var(flag_value_profile_transformations) Optimization"}, {"sha": "1c8f5d9f13469617a033cdac0f6bae409fb2e661", "filename": "gcc/doc/options.texi", "status": "modified", "additions": 70, "deletions": 0, "changes": 70, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e6d4b9841c35629de91c36ba40ed247fef749037/gcc%2Fdoc%2Foptions.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e6d4b9841c35629de91c36ba40ed247fef749037/gcc%2Fdoc%2Foptions.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Foptions.texi?ref=e6d4b9841c35629de91c36ba40ed247fef749037", "patch": "@@ -77,6 +77,63 @@ sequences to properly set up the initialization.  These records have\n two fields: the string @samp{SourceInclude} and the name of the\n include file.\n \n+@item\n+An enumeration record to define a set of strings that may be used as\n+arguments to an option or options.  These records have three fields:\n+the string @samp{Enum}, a space-separated list of properties and help\n+text used to describe the set of strings in @option{--help} output.\n+Properties use the same format as option properties; the following are\n+valid:\n+@table @code\n+@item Name(@var{name})\n+This property is required; @var{name} must be a name (suitable for use\n+in C identifiers) used to identify the set of strings in @code{Enum}\n+option properties.\n+\n+@item Type(@var{type})\n+This property is required; @var{type} is the C type for variables set\n+by options using this enumeration together with @code{Var}.\n+\n+@item UnknownError(@var{message})\n+The message @var{message} will be used as an error message if the\n+argument is invalid; for enumerations without @code{UnknownError}, a\n+generic error message is used.  @var{message} should contain a single\n+@samp{%qs} format, which will be used to format the invalid argument.\n+@end table\n+\n+@item\n+An enumeration value record to define one of the strings in a set\n+given in an @samp{Enum} record.  These records have two fields: the\n+string @samp{EnumValue} and a space-separated list of properties.\n+Properties use the same format as option properties; the following are\n+valid:\n+@table @code\n+@item Enum(@var{name})\n+This property is required; @var{name} says which @samp{Enum} record\n+this @samp{EnumValue} record corresponds to.\n+\n+@item String(@var{string})\n+This property is required; @var{string} is the string option argument\n+being described by this record.\n+\n+@item Value(@var{value})\n+This property is required; it says what value (representable as\n+@code{int}) should be used for the given string.\n+\n+@item Canonical\n+This property is optional.  If present, it says the present string is\n+the canonical one among all those with the given value.  Other strings\n+yielding that value will be mapped to this one so specs do not need to\n+handle them.\n+\n+@item DriverOnly\n+This property is optional.  If present, the present string will only\n+be accepted by the driver.  This is used for cases such as\n+@option{-march=native} that are processed by the driver so that\n+@samp{gcc -v} shows how the options chosen depended on the system on\n+which the compiler was run.\n+@end table\n+\n @item\n An option definition record.  These records have the following fields:\n @enumerate\n@@ -226,6 +283,13 @@ option is used and 0 when the ``no-'' form is used.\n If the option takes an argument and has the @code{UInteger} property,\n @var{var} is an integer variable that stores the value of the argument.\n \n+@item\n+If the option takes an argument and has the @code{Enum} property,\n+@var{var} is a variable (type given in the @code{Type} property of the\n+@samp{Enum} record whose @code{Name} property has the same argument as\n+the @code{Enum} property of this option) that stores the value of the\n+argument.\n+\n @item\n If the option has the @code{Defer} property, @var{var} is a pointer to\n a @code{VEC(cl_deferred_option,heap)} that stores the option for later\n@@ -287,6 +351,12 @@ The main purpose of this property is to support synonymous options.\n The first option should use @samp{Mask(@var{name})} and the others\n should use @samp{Mask(@var{name}) MaskExists}.\n \n+@item Enum(@var{name})\n+The option's argument is a string from the set of strings associated\n+with the corresponding @samp{Enum} record.  The string is checked and\n+converted to the integer specified in the corresponding\n+@samp{EnumValue} record before being passed to option handlers.\n+\n @item Defer\n The option should be stored in a vector, specified with @code{Var},\n for later processing."}, {"sha": "9aff0e0046bdbf10eca0b3d7563941218643c6bf", "filename": "gcc/opt-functions.awk", "status": "modified", "additions": 17, "deletions": 9, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e6d4b9841c35629de91c36ba40ed247fef749037/gcc%2Fopt-functions.awk", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e6d4b9841c35629de91c36ba40ed247fef749037/gcc%2Fopt-functions.awk", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fopt-functions.awk?ref=e6d4b9841c35629de91c36ba40ed247fef749037", "patch": "@@ -150,6 +150,10 @@ function var_type(flags)\n {\n \tif (flag_set_p(\"Defer\", flags))\n \t\treturn \"void *\"\n+\telse if (flag_set_p(\"Enum.*\", flags)) {\n+\t\ten = opt_args(\"Enum\", flags);\n+\t\treturn enum_type[en] \" \"\n+\t}\n \telse if (!flag_set_p(\"Joined.*\", flags) && !flag_set_p(\"Separate\", flags))\n \t\treturn \"int \"\n \telse if (flag_set_p(\"UInteger\", flags))\n@@ -176,33 +180,37 @@ function var_type_struct(flags)\n }\n \n # Given that an option has flags FLAGS, return an initializer for the\n-# \"var_cond\" and \"var_value\" fields of its cl_options[] entry.\n+# \"var_enum\", \"var_type\" and \"var_value\" fields of its cl_options[] entry.\n function var_set(flags)\n {\n \tif (flag_set_p(\"Defer\", flags))\n-\t\treturn \"CLVC_DEFER, 0\"\n+\t\treturn \"0, CLVC_DEFER, 0\"\n \ts = nth_arg(1, opt_args(\"Var\", flags))\n \tif (s != \"\")\n-\t\treturn \"CLVC_EQUAL, \" s\n+\t\treturn \"0, CLVC_EQUAL, \" s\n \ts = opt_args(\"Mask\", flags);\n \tif (s != \"\") {\n \t\tvn = var_name(flags);\n \t\tif (vn)\n-\t\t\treturn \"CLVC_BIT_SET, OPTION_MASK_\" s\n+\t\t\treturn \"0, CLVC_BIT_SET, OPTION_MASK_\" s\n \t\telse\n-\t\t\treturn \"CLVC_BIT_SET, MASK_\" s\n+\t\t\treturn \"0, CLVC_BIT_SET, MASK_\" s\n \t}\n \ts = nth_arg(0, opt_args(\"InverseMask\", flags));\n \tif (s != \"\") {\n \t\tvn = var_name(flags);\n \t\tif (vn)\n-\t\t\treturn \"CLVC_BIT_CLEAR, OPTION_MASK_\" s\n+\t\t\treturn \"0, CLVC_BIT_CLEAR, OPTION_MASK_\" s\n \t\telse\n-\t\t\treturn \"CLVC_BIT_CLEAR, MASK_\" s\n+\t\t\treturn \"0, CLVC_BIT_CLEAR, MASK_\" s\n+\t}\n+\tif (flag_set_p(\"Enum.*\", flags)) {\n+\t\ten = opt_args(\"Enum\", flags);\n+\t\treturn enum_index[en] \", CLVC_ENUM, 0\"\n \t}\n \tif (var_type(flags) == \"const char *\")\n-\t\treturn \"CLVC_STRING, 0\"\n-\treturn \"CLVC_BOOLEAN, 0\"\n+\t\treturn \"0, CLVC_STRING, 0\"\n+\treturn \"0, CLVC_BOOLEAN, 0\"\n }\n \n # Given that an option called NAME has flags FLAGS, return an initializer"}, {"sha": "4aaa2a6041a2e3a5ff19da8761fefb2a72c2babe", "filename": "gcc/optc-gen.awk", "status": "modified", "additions": 76, "deletions": 0, "changes": 76, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e6d4b9841c35629de91c36ba40ed247fef749037/gcc%2Foptc-gen.awk", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e6d4b9841c35629de91c36ba40ed247fef749037/gcc%2Foptc-gen.awk", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Foptc-gen.awk?ref=e6d4b9841c35629de91c36ba40ed247fef749037", "patch": "@@ -34,6 +34,7 @@ BEGIN {\n \tn_extra_target_vars = 0\n \tn_extra_c_includes = 0\n \tn_extra_h_includes = 0\n+\tn_enums = 0\n \tquote = \"\\042\"\n \tcomma = \",\"\n \tFS=SUBSEP\n@@ -80,6 +81,31 @@ BEGIN {\n \t\telse if ($1 == \"SourceInclude\")  {\n \t\t\textra_c_includes[n_extra_c_includes++] = $2;\n \t\t}\n+\t\telse if ($1 == \"Enum\") {\n+\t\t\tprops = $2\n+\t\t\tname = opt_args(\"Name\", props)\n+\t\t\ttype = opt_args(\"Type\", props)\n+\t\t\tunknown_error = opt_args(\"UnknownError\", props)\n+\t\t\tenum_names[n_enums] = name\n+\t\t\tenum_type[name] = type\n+\t\t\tenum_index[name] = n_enums\n+\t\t\tenum_unknown_error[name] = unknown_error\n+\t\t\tenum_help[name] = $3\n+\t\t\tn_enums++\n+\t\t}\n+\t\telse if ($1 == \"EnumValue\")  {\n+\t\t\tprops = $2\n+\t\t\tenum_name = opt_args(\"Enum\", props)\n+\t\t\tstring = opt_args(\"String\", props)\n+\t\t\tvalue = opt_args(\"Value\", props)\n+\t\t\tval_flags = \"0\"\n+\t\t\tval_flags = val_flags \\\n+\t\t\t  test_flag(\"Canonical\", props, \"| CL_ENUM_CANONICAL\") \\\n+\t\t\t  test_flag(\"DriverOnly\", props, \"| CL_ENUM_DRIVER_ONLY\")\n+\t\t\tenum_data[enum_name] = enum_data[enum_name] \\\n+\t\t\t  \"  { \" quote string quote \", \" value \", \" val_flags \\\n+\t\t\t  \" },\\n\"\n+\t\t}\n \t\telse {\n \t\t\tname = opt_args(\"Mask\", $1)\n \t\t\tif (name == \"\") {\n@@ -116,6 +142,56 @@ if (n_extra_c_includes > 0) {\n \tprint \"\"\n }\n \n+for (i = 0; i < n_enums; i++) {\n+\tname = enum_names[i]\n+\ttype = enum_type[name]\n+\tprint \"static const struct cl_enum_arg cl_enum_\" name \\\n+\t    \"_data[] = \"\n+\tprint \"{\"\n+\tprint enum_data[name] \"  { NULL, 0, 0 }\"\n+\tprint \"};\"\n+\tprint \"\"\n+\tprint \"static void\"\n+\tprint \"cl_enum_\" name \"_set (void *var, int value)\"\n+\tprint \"{\"\n+\tprint \"  *((\" type \" *) var) = (\" type \") value;\"\n+\tprint \"}\"\n+\tprint \"\"\n+\tprint \"static int\"\n+\tprint \"cl_enum_\" name \"_get (const void *var)\"\n+\tprint \"{\"\n+\tprint \"  return (int) *((const \" type \" *) var);\"\n+\tprint \"}\"\n+\tprint \"\"\n+}\n+\n+print \"const struct cl_enum cl_enums[] =\"\n+print \"{\"\n+for (i = 0; i < n_enums; i++) {\n+\tname = enum_names[i]\n+\tehelp = enum_help[name]\n+\tif (ehelp == \"\")\n+\t\tehelp = \"NULL\"\n+\telse\n+\t\tehelp = quote ehelp quote\n+\tunknown_error = enum_unknown_error[name]\n+\tif (unknown_error == \"\")\n+\t\tunknown_error = \"NULL\"\n+\telse\n+\t\tunknown_error = quote unknown_error quote\n+\tprint \"  {\"\n+\tprint \"    \" ehelp \",\"\n+\tprint \"    \" unknown_error \",\"\n+\tprint \"    cl_enum_\" name \"_data,\"\n+\tprint \"    sizeof (\" enum_type[name] \"),\"\n+\tprint \"    cl_enum_\" name \"_set,\"\n+\tprint \"    cl_enum_\" name \"_get\"\n+\tprint \"  },\"\n+}\n+print \"};\"\n+print \"const unsigned int cl_enums_count = \" n_enums \";\"\n+print \"\"\n+\n have_save = 0;\n if (n_extra_target_vars)\n \thave_save = 1"}, {"sha": "db32121f914beae45d5fe9e91f4252f0df177118", "filename": "gcc/opth-gen.awk", "status": "modified", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e6d4b9841c35629de91c36ba40ed247fef749037/gcc%2Fopth-gen.awk", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e6d4b9841c35629de91c36ba40ed247fef749037/gcc%2Fopth-gen.awk", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fopth-gen.awk?ref=e6d4b9841c35629de91c36ba40ed247fef749037", "patch": "@@ -77,6 +77,31 @@ BEGIN {\n \t\telse if ($1 == \"SourceInclude\")  {\n \t\t\textra_c_includes[n_extra_c_includes++] = $2;\n \t\t}\n+\t\telse if ($1 == \"Enum\")  {\n+\t\t\tprops = $2\n+\t\t\tname = opt_args(\"Name\", props)\n+\t\t\ttype = opt_args(\"Type\", props)\n+\t\t\tunknown_error = opt_args(\"UnknownError\", props)\n+\t\t\tenum_names[n_enums] = name\n+\t\t\tenum_type[name] = type\n+\t\t\tenum_index[name] = n_enums\n+\t\t\tenum_unknown_error[name] = unknown_error\n+\t\t\tenum_help[name] = $3\n+\t\t\tn_enums++\n+\t\t}\n+\t\telse if ($1 == \"EnumValue\")  {\n+\t\t\tprops = $2\n+\t\t\tenum_name = opt_args(\"Enum\", props)\n+\t\t\tstring = opt_args(\"String\", props)\n+\t\t\tvalue = opt_args(\"Value\", props)\n+\t\t\tval_flags = \"0\"\n+\t\t\tval_flags = val_flags \\\n+\t\t\t  test_flag(\"Canonical\", props, \"| CL_ENUM_CANONICAL\") \\\n+\t\t\t  test_flag(\"DriverOnly\", props, \"| CL_ENUM_DRIVER_ONLY\")\n+\t\t\tenum_data[enum_name] = enum_data[enum_name] \\\n+\t\t\t  \"  { \" quote string quote \", \" value \", \" val_flags \\\n+\t\t\t  \" },\\n\"\n+\t\t}\n \t\telse {\n \t\t\tname = opt_args(\"Mask\", $1)\n \t\t\tif (name == \"\") {"}, {"sha": "e6cb552df131a9b57bba4e30368d65f254f15cfa", "filename": "gcc/opts-common.c", "status": "modified", "additions": 128, "deletions": 0, "changes": 128, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e6d4b9841c35629de91c36ba40ed247fef749037/gcc%2Fopts-common.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e6d4b9841c35629de91c36ba40ed247fef749037/gcc%2Fopts-common.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fopts-common.c?ref=e6d4b9841c35629de91c36ba40ed247fef749037", "patch": "@@ -181,6 +181,70 @@ option_ok_for_language (const struct cl_option *option,\n   return true;\n }\n \n+/* Return whether ENUM_ARG is OK for the language given by\n+   LANG_MASK.  */\n+\n+static bool\n+enum_arg_ok_for_language (const struct cl_enum_arg *enum_arg,\n+\t\t\t  unsigned int lang_mask)\n+{\n+  return (lang_mask & CL_DRIVER) || !(enum_arg->flags & CL_ENUM_DRIVER_ONLY);\n+}\n+\n+/* Look up ARG in ENUM_ARGS for language LANG_MASK, returning true and\n+   storing the value in *VALUE if found, and returning false without\n+   modifying *VALUE if not found.  */\n+\n+static bool\n+enum_arg_to_value (const struct cl_enum_arg *enum_args,\n+\t\t   const char *arg, int *value, unsigned int lang_mask)\n+{\n+  unsigned int i;\n+\n+  for (i = 0; enum_args[i].arg != NULL; i++)\n+    if (strcmp (arg, enum_args[i].arg) == 0\n+\t&& enum_arg_ok_for_language (&enum_args[i], lang_mask))\n+      {\n+\t*value = enum_args[i].value;\n+\treturn true;\n+      }\n+\n+  return false;\n+}\n+\n+/* Look of VALUE in ENUM_ARGS for language LANG_MASK and store the\n+   corresponding string in *ARGP, returning true if the found string\n+   was marked as canonical, false otherwise.  If VALUE is not found\n+   (which may be the case for uninitialized values if the relevant\n+   option has not been passed), set *ARGP to NULL and return\n+   false.  */\n+\n+bool\n+enum_value_to_arg (const struct cl_enum_arg *enum_args,\n+\t\t   const char **argp, int value, unsigned int lang_mask)\n+{\n+  unsigned int i;\n+\n+  for (i = 0; enum_args[i].arg != NULL; i++)\n+    if (enum_args[i].value == value\n+\t&& (enum_args[i].flags & CL_ENUM_CANONICAL)\n+\t&& enum_arg_ok_for_language (&enum_args[i], lang_mask))\n+      {\n+\t*argp = enum_args[i].arg;\n+\treturn true;\n+      }\n+\n+  for (i = 0; enum_args[i].arg != NULL; i++)\n+    if (enum_args[i].value == value\n+\t&& enum_arg_ok_for_language (&enum_args[i], lang_mask))\n+      {\n+\t*argp = enum_args[i].arg;\n+\treturn false;\n+      }\n+\n+  *argp = NULL;\n+  return false;\n+}\n \n /* Fill in the canonical option part of *DECODED with an option\n    described by OPT_INDEX, ARG and VALUE.  */\n@@ -508,6 +572,24 @@ decode_cmdline_option (const char **argv, unsigned int lang_mask,\n \terrors |= CL_ERR_UINT_ARG;\n     }\n \n+  /* If the switch takes an enumerated argument, convert it.  */\n+  if (arg && (option->var_type == CLVC_ENUM))\n+    {\n+      const struct cl_enum *e = &cl_enums[option->var_enum];\n+\n+      gcc_assert (value == 1);\n+      if (enum_arg_to_value (e->values, arg, &value, lang_mask))\n+\t{\n+\t  const char *carg = NULL;\n+\n+\t  if (enum_value_to_arg (e->values, &carg, value, lang_mask))\n+\t    arg = carg;\n+\t  gcc_assert (carg != NULL);\n+\t}\n+      else\n+\terrors |= CL_ERR_ENUM_ARG;\n+    }\n+\n  done:\n   decoded->opt_index = opt_index;\n   decoded->arg = arg;\n@@ -900,6 +982,36 @@ read_cmdline_option (struct gcc_options *opts,\n       return;\n     }\n \n+  if (decoded->errors & CL_ERR_ENUM_ARG)\n+    {\n+      const struct cl_enum *e = &cl_enums[option->var_enum];\n+      unsigned int i;\n+      size_t len;\n+      char *s, *p;\n+\n+      if (e->unknown_error)\n+\terror_at (loc, e->unknown_error, decoded->arg);\n+      else\n+\terror_at (loc, \"unrecognized argument in option %qs\", opt);\n+\n+      len = 0;\n+      for (i = 0; e->values[i].arg != NULL; i++)\n+\tlen += strlen (e->values[i].arg) + 1;\n+\n+      s = XALLOCAVEC (char, len);\n+      p = s;\n+      for (i = 0; e->values[i].arg != NULL; i++)\n+\t{\n+\t  size_t arglen = strlen (e->values[i].arg);\n+\t  memcpy (p, e->values[i].arg, arglen);\n+\t  p[arglen] = ' ';\n+\t  p += arglen + 1;\n+\t}\n+      p[-1] = 0;\n+      inform (loc, \"valid arguments to %qs are: %s\", option->opt_text, s);\n+      return;\n+    }\n+\n   gcc_assert (!decoded->errors);\n \n   if (!handle_option (opts, opts_set, decoded, lang_mask, DK_UNSPECIFIED,\n@@ -959,6 +1071,16 @@ set_option (struct gcc_options *opts, struct gcc_options *opts_set,\n \t  *(const char **) set_flag_var = \"\";\n \tbreak;\n \n+    case CLVC_ENUM:\n+      {\n+\tconst struct cl_enum *e = &cl_enums[option->var_enum];\n+\n+\te->set (flag_var, value);\n+\tif (set_flag_var)\n+\t  e->set (set_flag_var, 1);\n+      }\n+      break;\n+\n     case CLVC_DEFER:\n \t{\n \t  VEC(cl_deferred_option,heap) *vec\n@@ -1020,6 +1142,7 @@ option_enabled (int opt_idx, void *opts)\n \treturn (*(int *) flag_var & option->var_value) != 0;\n \n       case CLVC_STRING:\n+      case CLVC_ENUM:\n       case CLVC_DEFER:\n \tbreak;\n       }\n@@ -1060,6 +1183,11 @@ get_option_state (struct gcc_options *opts, int option,\n       state->size = strlen ((const char *) state->data) + 1;\n       break;\n \n+    case CLVC_ENUM:\n+      state->data = flag_var;\n+      state->size = cl_enums[cl_options[option].var_enum].var_size;\n+      break;\n+\n     case CLVC_DEFER:\n       return false;\n     }"}, {"sha": "cd41c2ab317f5eb3b9e8bbb84ca2b5db7655c49a", "filename": "gcc/opts.c", "status": "modified", "additions": 73, "deletions": 85, "changes": 158, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e6d4b9841c35629de91c36ba40ed247fef749037/gcc%2Fopts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e6d4b9841c35629de91c36ba40ed247fef749037/gcc%2Fopts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fopts.c?ref=e6d4b9841c35629de91c36ba40ed247fef749037", "patch": "@@ -885,7 +885,8 @@ print_filtered_help (unsigned int include_flags,\n \t\t     unsigned int exclude_flags,\n \t\t     unsigned int any_flags,\n \t\t     unsigned int columns,\n-\t\t     struct gcc_options *opts)\n+\t\t     struct gcc_options *opts,\n+\t\t     unsigned int lang_mask)\n {\n   unsigned int i;\n   const char *help;\n@@ -918,6 +919,9 @@ print_filtered_help (unsigned int include_flags,\n   if (!opts->x_help_printed)\n     opts->x_help_printed = XCNEWVAR (char, cl_options_count);\n \n+  if (!opts->x_help_enum_printed)\n+    opts->x_help_enum_printed = XCNEWVAR (char, cl_enums_count);\n+\n   for (i = 0; i < cl_options_count; i++)\n     {\n       char new_help[128];\n@@ -999,6 +1003,20 @@ print_filtered_help (unsigned int include_flags,\n \t\t\t\t  sizeof (new_help) - strlen (new_help),\n \t\t\t\t  * (const char **) flag_var);\n \t\t    }\n+\t\t  else if (option->var_type == CLVC_ENUM)\n+\t\t    {\n+\t\t      const struct cl_enum *e = &cl_enums[option->var_enum];\n+\t\t      int value;\n+\t\t      const char *arg = NULL;\n+\n+\t\t      value = e->get (flag_var);\n+\t\t      enum_value_to_arg (e->values, &arg, value, lang_mask);\n+\t\t      if (arg == NULL)\n+\t\t\targ = _(\"[default]\");\n+\t\t      snprintf (new_help + strlen (new_help),\n+\t\t\t\tsizeof (new_help) - strlen (new_help),\n+\t\t\t\targ);\n+\t\t    }\n \t\t  else\n \t\t    sprintf (new_help + strlen (new_help),\n \t\t\t     \"%#x\", * (int *) flag_var);\n@@ -1013,6 +1031,10 @@ print_filtered_help (unsigned int include_flags,\n \n       wrap_help (help, opt, len, columns);\n       displayed = true;\n+\n+      if (option->var_type == CLVC_ENUM\n+\t  && opts->x_help_enum_printed[option->var_enum] != 2)\n+\topts->x_help_enum_printed[option->var_enum] = 1;\n     }\n \n   if (! found)\n@@ -1038,18 +1060,57 @@ print_filtered_help (unsigned int include_flags,\n     printf (_(\" All options with the desired characteristics have already been displayed\\n\"));\n \n   putchar ('\\n');\n+\n+  /* Print details of enumerated option arguments, if those\n+     enumerations have help text headings provided.  If no help text\n+     is provided, presume that the possible values are listed in the\n+     help text for the relevant options.  */\n+  for (i = 0; i < cl_enums_count; i++)\n+    {\n+      unsigned int j, pos;\n+\n+      if (opts->x_help_enum_printed[i] != 1)\n+\tcontinue;\n+      if (cl_enums[i].help == NULL)\n+\tcontinue;\n+      printf (\"  %s\\n    \", _(cl_enums[i].help));\n+      pos = 4;\n+      for (j = 0; cl_enums[i].values[j].arg != NULL; j++)\n+\t{\n+\t  unsigned int len = strlen (cl_enums[i].values[j].arg);\n+\n+\t  if (pos > 4 && pos + 1 + len <= columns)\n+\t    {\n+\t      printf (\" %s\", cl_enums[i].values[j].arg);\n+\t      pos += 1 + len;\n+\t    }\n+\t  else\n+\t    {\n+\t      if (pos > 4)\n+\t\t{\n+\t\t  printf (\"\\n    \");\n+\t\t  pos = 4;\n+\t\t}\n+\t      printf (\"%s\", cl_enums[i].values[j].arg);\n+\t      pos += len;\n+\t    }\n+\t}\n+      printf (\"\\n\\n\");\n+      opts->x_help_enum_printed[i] = 2;\n+    }\n }\n \n /* Display help for a specified type of option.\n    The options must have ALL of the INCLUDE_FLAGS set\n    ANY of the flags in the ANY_FLAGS set\n    and NONE of the EXCLUDE_FLAGS set.  The current option state is in\n-   OPTS.  */\n+   OPTS; LANG_MASK is used for interpreting enumerated option state.  */\n static void\n print_specific_help (unsigned int include_flags,\n \t\t     unsigned int exclude_flags,\n \t\t     unsigned int any_flags,\n-\t\t     struct gcc_options *opts)\n+\t\t     struct gcc_options *opts,\n+\t\t     unsigned int lang_mask)\n {\n   unsigned int all_langs_mask = (1U << cl_lang_count) - 1;\n   const char * description = NULL;\n@@ -1145,7 +1206,7 @@ print_specific_help (unsigned int include_flags,\n \n   printf (\"%s%s:\\n\", description, descrip_extra);\n   print_filtered_help (include_flags, exclude_flags, any_flags,\n-\t\t       opts->x_help_columns, opts);\n+\t\t       opts->x_help_columns, opts, lang_mask);\n }\n \n /* Handle target- and language-independent options.  Return zero to\n@@ -1187,19 +1248,20 @@ common_handle_option (struct gcc_options *opts,\n \t/* First display any single language specific options.  */\n \tfor (i = 0; i < cl_lang_count; i++)\n \t  print_specific_help\n-\t    (1U << i, (all_langs_mask & (~ (1U << i))) | undoc_mask, 0, opts);\n+\t    (1U << i, (all_langs_mask & (~ (1U << i))) | undoc_mask, 0, opts,\n+\t     lang_mask);\n \t/* Next display any multi language specific options.  */\n-\tprint_specific_help (0, undoc_mask, all_langs_mask, opts);\n+\tprint_specific_help (0, undoc_mask, all_langs_mask, opts, lang_mask);\n \t/* Then display any remaining, non-language options.  */\n \tfor (i = CL_MIN_OPTION_CLASS; i <= CL_MAX_OPTION_CLASS; i <<= 1)\n \t  if (i != CL_DRIVER)\n-\t    print_specific_help (i, undoc_mask, 0, opts);\n+\t    print_specific_help (i, undoc_mask, 0, opts, lang_mask);\n \topts->x_exit_after_options = true;\n \tbreak;\n       }\n \n     case OPT__target_help:\n-      print_specific_help (CL_TARGET, CL_UNDOCUMENTED, 0, opts);\n+      print_specific_help (CL_TARGET, CL_UNDOCUMENTED, 0, opts, lang_mask);\n       opts->x_exit_after_options = true;\n \n       /* Allow the target a chance to give the user some additional information.  */\n@@ -1321,7 +1383,8 @@ common_handle_option (struct gcc_options *opts,\n \t  }\n \n \tif (include_flags)\n-\t  print_specific_help (include_flags, exclude_flags, 0, opts);\n+\t  print_specific_help (include_flags, exclude_flags, 0, opts,\n+\t\t\t       lang_mask);\n \topts->x_exit_after_options = true;\n \tbreak;\n       }\n@@ -1405,13 +1468,7 @@ common_handle_option (struct gcc_options *opts,\n       break;\n \n     case OPT_fdiagnostics_show_location_:\n-      if (!strcmp (arg, \"once\"))\n-\tdiagnostic_prefixing_rule (dc) = DIAGNOSTICS_SHOW_PREFIX_ONCE;\n-      else if (!strcmp (arg, \"every-line\"))\n-\tdiagnostic_prefixing_rule (dc)\n-\t  = DIAGNOSTICS_SHOW_PREFIX_EVERY_LINE;\n-      else\n-\treturn false;\n+      diagnostic_prefixing_rule (dc) = (diagnostic_prefixing_rule_t) value;\n       break;\n \n     case OPT_fdiagnostics_show_option:\n@@ -1422,27 +1479,6 @@ common_handle_option (struct gcc_options *opts,\n       /* Deferred.  */\n       break;\n \n-    case OPT_ffp_contract_:\n-      if (!strcmp (arg, \"on\"))\n-\t/* Not implemented, fall back to conservative FP_CONTRACT_OFF.  */\n-\topts->x_flag_fp_contract_mode = FP_CONTRACT_OFF;\n-      else if (!strcmp (arg, \"off\"))\n-\topts->x_flag_fp_contract_mode = FP_CONTRACT_OFF;\n-      else if (!strcmp (arg, \"fast\"))\n-\topts->x_flag_fp_contract_mode = FP_CONTRACT_FAST;\n-      else\n-\terror_at (loc, \"unknown floating point contraction style \\\"%s\\\"\", arg);\n-      break;\n-\n-    case OPT_fexcess_precision_:\n-      if (!strcmp (arg, \"fast\"))\n-\topts->x_flag_excess_precision_cmdline = EXCESS_PRECISION_FAST;\n-      else if (!strcmp (arg, \"standard\"))\n-\topts->x_flag_excess_precision_cmdline = EXCESS_PRECISION_STANDARD;\n-      else\n-\terror_at (loc, \"unknown excess precision style \\\"%s\\\"\", arg);\n-      break;\n-\n     case OPT_ffast_math:\n       set_fast_math_flags (opts, value);\n       break;\n@@ -1542,21 +1578,6 @@ common_handle_option (struct gcc_options *opts,\n       dc->show_column = value;\n       break;\n \n-    case OPT_fvisibility_:\n-      {\n-        if (!strcmp(arg, \"default\"))\n-          opts->x_default_visibility = VISIBILITY_DEFAULT;\n-        else if (!strcmp(arg, \"internal\"))\n-          opts->x_default_visibility = VISIBILITY_INTERNAL;\n-        else if (!strcmp(arg, \"hidden\"))\n-          opts->x_default_visibility = VISIBILITY_HIDDEN;\n-        else if (!strcmp(arg, \"protected\"))\n-          opts->x_default_visibility = VISIBILITY_PROTECTED;\n-        else\n-          error_at (loc, \"unrecognized visibility value \\\"%s\\\"\", arg);\n-      }\n-      break;\n-\n     case OPT_frandom_seed:\n       /* The real switch is -fno-random-seed.  */\n       if (value)\n@@ -1621,39 +1642,6 @@ common_handle_option (struct gcc_options *opts,\n       vect_set_verbosity_level (opts, value);\n       break;\n \n-    case OPT_ftls_model_:\n-      if (!strcmp (arg, \"global-dynamic\"))\n-\topts->x_flag_tls_default = TLS_MODEL_GLOBAL_DYNAMIC;\n-      else if (!strcmp (arg, \"local-dynamic\"))\n-\topts->x_flag_tls_default = TLS_MODEL_LOCAL_DYNAMIC;\n-      else if (!strcmp (arg, \"initial-exec\"))\n-\topts->x_flag_tls_default = TLS_MODEL_INITIAL_EXEC;\n-      else if (!strcmp (arg, \"local-exec\"))\n-\topts->x_flag_tls_default = TLS_MODEL_LOCAL_EXEC;\n-      else\n-\twarning_at (loc, 0, \"unknown tls-model \\\"%s\\\"\", arg);\n-      break;\n-\n-    case OPT_fira_algorithm_:\n-      if (!strcmp (arg, \"CB\"))\n-\topts->x_flag_ira_algorithm = IRA_ALGORITHM_CB;\n-      else if (!strcmp (arg, \"priority\"))\n-\topts->x_flag_ira_algorithm = IRA_ALGORITHM_PRIORITY;\n-      else\n-\twarning_at (loc, 0, \"unknown ira algorithm \\\"%s\\\"\", arg);\n-      break;\n-\n-    case OPT_fira_region_:\n-      if (!strcmp (arg, \"one\"))\n-\topts->x_flag_ira_region = IRA_REGION_ONE;\n-      else if (!strcmp (arg, \"all\"))\n-\topts->x_flag_ira_region = IRA_REGION_ALL;\n-      else if (!strcmp (arg, \"mixed\"))\n-\topts->x_flag_ira_region = IRA_REGION_MIXED;\n-      else\n-\twarning_at (loc, 0, \"unknown ira region \\\"%s\\\"\", arg);\n-      break;\n-\n     case OPT_g:\n       set_debug_level (NO_DEBUG, DEFAULT_GDB_EXTENSIONS, arg, opts, opts_set,\n \t\t       loc);"}, {"sha": "c3907fd004836bcd566eb7a3fa4e16cc5afc4cac", "filename": "gcc/opts.h", "status": "modified", "additions": 56, "deletions": 1, "changes": 57, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e6d4b9841c35629de91c36ba40ed247fef749037/gcc%2Fopts.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e6d4b9841c35629de91c36ba40ed247fef749037/gcc%2Fopts.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fopts.h?ref=e6d4b9841c35629de91c36ba40ed247fef749037", "patch": "@@ -42,6 +42,10 @@ enum cl_var_type {\n      argument.  */\n   CLVC_STRING,\n \n+  /* The switch takes an enumerated argument (VAR_ENUM says what\n+     enumeration) and FLAG_VAR points to that argument.  */\n+  CLVC_ENUM,\n+\n   /* The switch should be stored in the VEC pointed to by FLAG_VAR for\n      later processing.  */\n   CLVC_DEFER\n@@ -61,6 +65,7 @@ struct cl_option\n   int neg_index;\n   unsigned int flags;\n   unsigned short flag_var_offset;\n+  unsigned short var_enum;\n   enum cl_var_type var_type;\n   int var_value;\n };\n@@ -111,6 +116,52 @@ extern const unsigned int cl_lang_count;\n #define CL_UINTEGER\t\t(1 << 29) /* Argument is an integer >=0.  */\n #define CL_UNDOCUMENTED\t\t(1 << 30) /* Do not output with --help.  */\n \n+/* Flags for an enumerated option argument.  */\n+#define CL_ENUM_CANONICAL\t(1 << 0) /* Canonical for this value.  */\n+#define CL_ENUM_DRIVER_ONLY\t(1 << 1) /* Only accepted in the driver.  */\n+\n+/* Structure describing an enumerated option argument.  */\n+\n+struct cl_enum_arg\n+{\n+  /* The argument text, or NULL at the end of the array.  */\n+  const char *arg;\n+\n+  /* The corresponding integer value.  */\n+  int value;\n+\n+  /* Flags associated with this argument.  */\n+  unsigned int flags;\n+};\n+\n+/* Structure describing an enumerated set of option arguments.  */\n+\n+struct cl_enum\n+{\n+  /* Help text, or NULL if the values should not be listed in --help\n+     output.  */\n+  const char *help;\n+\n+  /* Error message for unknown arguments, or NULL to use a generic\n+     error.  */\n+  const char *unknown_error;\n+\n+  /* Array of possible values.  */\n+  const struct cl_enum_arg *values;\n+\n+  /* The size of the type used to store a value.  */\n+  size_t var_size;\n+\n+  /* Function to set a variable of this type.  */\n+  void (*set) (void *var, int value);\n+\n+  /* Function to get the value of a variable of this type.  */\n+  int (*get) (const void *var);\n+};\n+\n+extern const struct cl_enum cl_enums[];\n+extern const unsigned int cl_enums_count;\n+\n /* Possible ways in which a command-line option may be erroneous.\n    These do not include not being known at all; an option index of\n    OPT_SPECIAL_unknown is used for that.  */\n@@ -119,7 +170,8 @@ extern const unsigned int cl_lang_count;\n #define CL_ERR_MISSING_ARG\t(1 << 1) /* Argument required but missing.  */\n #define CL_ERR_WRONG_LANG\t(1 << 2) /* Option for wrong language.  */\n #define CL_ERR_UINT_ARG\t\t(1 << 3) /* Bad unsigned integer argument.  */\n-#define CL_ERR_NEGATIVE\t\t(1 << 4) /* Negative form of option\n+#define CL_ERR_ENUM_ARG\t\t(1 << 4) /* Bad enumerated argument.  */\n+#define CL_ERR_NEGATIVE\t\t(1 << 5) /* Negative form of option\n \t\t\t\t\t    not permitted (together\n \t\t\t\t\t    with OPT_SPECIAL_unknown).  */\n \n@@ -230,6 +282,9 @@ extern unsigned num_in_fnames;\n \n size_t find_opt (const char *input, int lang_mask);\n extern int integral_argument (const char *arg);\n+extern bool enum_value_to_arg (const struct cl_enum_arg *enum_args,\n+\t\t\t       const char **argp, int value,\n+\t\t\t       unsigned int lang_mask);\n extern void decode_cmdline_options_to_array (unsigned int argc,\n \t\t\t\t\t     const char **argv, \n \t\t\t\t\t     unsigned int lang_mask,"}, {"sha": "d6d3a22745068a42e70dd7e0620e0169a6846929", "filename": "gcc/po/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e6d4b9841c35629de91c36ba40ed247fef749037/gcc%2Fpo%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e6d4b9841c35629de91c36ba40ed247fef749037/gcc%2Fpo%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpo%2FChangeLog?ref=e6d4b9841c35629de91c36ba40ed247fef749037", "patch": "@@ -1,3 +1,7 @@\n+2010-11-26  Joseph Myers  <joseph@codesourcery.com>\n+\n+\t* exgettext: Handle UnknownError.\n+\n 2010-11-21  Joseph Myers  <joseph@codesourcery.com>\n \n \t* sv.po: Update."}, {"sha": "7642dc56aadcd8b98bef6cef7e51e5f0baa367d3", "filename": "gcc/po/exgettext", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e6d4b9841c35629de91c36ba40ed247fef749037/gcc%2Fpo%2Fexgettext", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e6d4b9841c35629de91c36ba40ed247fef749037/gcc%2Fpo%2Fexgettext", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpo%2Fexgettext?ref=e6d4b9841c35629de91c36ba40ed247fef749037", "patch": "@@ -246,6 +246,17 @@ echo \"scanning option files...\" >&2\n \t\tprintf(\"#line %d \\\"%s\\\"\\n\", lineno, file)\n \t\tprintf(\"_(\\\"%s\\\")\\n\", line)\n \t    }\n+\t    if ((field == 1) && /UnknownError/) {\n+\t\tline = $0\n+\t\tsub(\".*UnknownError\\\\(\", \"\", line)\n+\t\tif (line ~ \"^{\") {\n+\t\t\tsub(\"^{\", \"\", line)\n+\t\t\tsub(\"}\\\\).*\", \"\", line)\n+\t\t} else\n+\t\t\tsub(\"\\\\).*\", \"\", line)\n+\t\tprintf(\"#line %d \\\"%s\\\"\\n\", lineno, file)\n+\t\tprintf(\"_(\\\"%s\\\")\\n\", line)\n+\t    }\n \t    if ((field == 1) && /Warn\\(/) {\n \t\tline = $0\n \t\tsub(\".*Warn\\\\(\", \"\", line)"}]}