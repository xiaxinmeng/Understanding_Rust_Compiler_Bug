{"sha": "9967bbfceddce755b18bdbecc6d0c56e994a05cc", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTk2N2JiZmNlZGRjZTc1NWIxOGJkYmVjYzZkMGM1NmU5OTRhMDVjYw==", "commit": {"author": {"name": "YunQiang Su", "email": "yunqiang.su@cipunited.com", "date": "2021-02-26T02:55:10Z"}, "committer": {"name": "Jeff Law", "email": "law@redhat.com", "date": "2021-02-26T02:56:07Z"}, "message": "[PATCH v4 1/2] MIPS: unaligned load: use SImode for SUBREG if OK (PR98996) [PATCH v4 2/2] ada: add 128bit operation for MIPS N32 and N64\n\ngcc/ChangeLog:\n\n\tPR target/98996\n\t* config/mips/mips.c (mips_expand_ext_as_unaligned_load):\n\tIf TARGET_64BIT and dest is SUBREG, we check the width, if it\n\tequal to SImode, we use SImode operation, just like what we are\n\tdoing for REG one.\n\ngcc/ada/ChangeLog:\n\n\tPR ada/98996\n\t* Makefile.rtl: <mips*-*-linux*>\n\tadd 128Bit operation file for MIPS N64 and N32 to\n\tLIBGNAT_TARGET_PAIRS and EXTRA_GNATRTL_NONTASKING_OBJS", "tree": {"sha": "3d3f9822acc9a47c34cb4e24717702d06e381c81", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/3d3f9822acc9a47c34cb4e24717702d06e381c81"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/9967bbfceddce755b18bdbecc6d0c56e994a05cc", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9967bbfceddce755b18bdbecc6d0c56e994a05cc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9967bbfceddce755b18bdbecc6d0c56e994a05cc", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9967bbfceddce755b18bdbecc6d0c56e994a05cc/comments", "author": null, "committer": null, "parents": [{"sha": "97989a2220c876113ccdfcad5ed247c8efbe1cf0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/97989a2220c876113ccdfcad5ed247c8efbe1cf0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/97989a2220c876113ccdfcad5ed247c8efbe1cf0"}], "stats": {"total": 14, "additions": 13, "deletions": 1}, "files": [{"sha": "987eff0abba07a286788768a2149ad9c4e8f8138", "filename": "gcc/ada/Makefile.rtl", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9967bbfceddce755b18bdbecc6d0c56e994a05cc/gcc%2Fada%2FMakefile.rtl", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9967bbfceddce755b18bdbecc6d0c56e994a05cc/gcc%2Fada%2FMakefile.rtl", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FMakefile.rtl?ref=9967bbfceddce755b18bdbecc6d0c56e994a05cc", "patch": "@@ -2311,6 +2311,18 @@ ifeq ($(strip $(filter-out mips% linux%,$(target_cpu) $(target_os))),)\n   s-tpopsp.adb<libgnarl/s-tpopsp__posix-foreign.adb \\\n   system.ads<libgnat/system-linux-mips.ads\n \n+  ifeq ($(strip $(filter-out mips64% mipsisa64%,$(target_cpu))),)\n+    ifneq ($(strip $(MULTISUBDIR)),/32)\n+      LIBGNAT_TARGET_PAIRS += $(GNATRTL_128BIT_PAIRS)\n+      EXTRA_GNATRTL_NONTASKING_OBJS += $(GNATRTL_128BIT_OBJS)\n+    endif\n+  else\n+    ifneq ($(strip $(filter /64 /n32,$(MULTISUBDIR))),)\n+      LIBGNAT_TARGET_PAIRS += $(GNATRTL_128BIT_PAIRS)\n+      EXTRA_GNATRTL_NONTASKING_OBJS += $(GNATRTL_128BIT_OBJS)\n+    endif\n+  endif\n+\n   TOOLS_TARGET_PAIRS = indepsw.adb<indepsw-gnu.adb\n \n   EXTRA_GNATRTL_TASKING_OBJS=s-linux.o"}, {"sha": "315545966f8861e7c3f54ae520426221a32e6757", "filename": "gcc/config/mips/mips.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9967bbfceddce755b18bdbecc6d0c56e994a05cc/gcc%2Fconfig%2Fmips%2Fmips.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9967bbfceddce755b18bdbecc6d0c56e994a05cc/gcc%2Fconfig%2Fmips%2Fmips.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips.c?ref=9967bbfceddce755b18bdbecc6d0c56e994a05cc", "patch": "@@ -8400,7 +8400,7 @@ mips_expand_ext_as_unaligned_load (rtx dest, rtx src, HOST_WIDE_INT width,\n   /* If TARGET_64BIT, the destination of a 32-bit \"extz\" or \"extzv\" will\n      be a DImode, create a new temp and emit a zero extend at the end.  */\n   if (GET_MODE (dest) == DImode\n-      && REG_P (dest)\n+      && (REG_P (dest) || (SUBREG_P (dest) && !MEM_P (SUBREG_REG (dest))))\n       && GET_MODE_BITSIZE (SImode) == width)\n     {\n       dest1 = dest;"}]}