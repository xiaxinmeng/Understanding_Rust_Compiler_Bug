{"sha": "55fc9243b7fc0a6c84fb7ff6bf896614bbde91ce", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTVmYzkyNDNiN2ZjMGE2Yzg0ZmI3ZmY2YmY4OTY2MTRiYmRlOTFjZQ==", "commit": {"author": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2006-04-10T12:02:55Z"}, "committer": {"name": "Jakub Jelinek", "email": "jakub@gcc.gnu.org", "date": "2006-04-10T12:02:55Z"}, "message": "re PR libfortran/24685 (real(16) formatted input is broken for huge values (gfortran.dg/default_format_2.f90))\n\n\tPR libgfortran/24685\n\t* io/write.c (MIN_FIELD_WIDTH, STR, STR1): Define.\n\t(output_float): Increase buffer sizes for IEEE quad and IBM extended\n\tlong double.\n\t(write_real): Output REAL(16) as 1PG43.34E4 rather than 1PG40.31E4.\n\nFrom-SVN: r112819", "tree": {"sha": "0e8c336cdc630af721734cfe83d6403b782d64d8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/0e8c336cdc630af721734cfe83d6403b782d64d8"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/55fc9243b7fc0a6c84fb7ff6bf896614bbde91ce", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/55fc9243b7fc0a6c84fb7ff6bf896614bbde91ce", "html_url": "https://github.com/Rust-GCC/gccrs/commit/55fc9243b7fc0a6c84fb7ff6bf896614bbde91ce", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/55fc9243b7fc0a6c84fb7ff6bf896614bbde91ce/comments", "author": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "9f889fcf528e9c42a0c17c8bc63afe89f749f786", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9f889fcf528e9c42a0c17c8bc63afe89f749f786", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9f889fcf528e9c42a0c17c8bc63afe89f749f786"}], "stats": {"total": 46, "additions": 32, "deletions": 14}, "files": [{"sha": "4f2c6ceb3debd99504080ef4fb90a79c23944607", "filename": "libgfortran/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/55fc9243b7fc0a6c84fb7ff6bf896614bbde91ce/libgfortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/55fc9243b7fc0a6c84fb7ff6bf896614bbde91ce/libgfortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2FChangeLog?ref=55fc9243b7fc0a6c84fb7ff6bf896614bbde91ce", "patch": "@@ -1,3 +1,11 @@\n+2006-04-10  Jakub Jelinek  <jakub@redhat.com>\n+\n+\tPR libgfortran/24685\n+\t* io/write.c (MIN_FIELD_WIDTH, STR, STR1): Define.\n+\t(output_float): Increase buffer sizes for IEEE quad and IBM extended\n+\tlong double.\n+\t(write_real): Output REAL(16) as 1PG43.34E4 rather than 1PG40.31E4.\n+\n 2006-04-07  Jerry DeLisle  <jvdelisle@gcc.gnu.org>\n \n \tPR libgfortran/26890"}, {"sha": "bee367c49ae70f3343df37cd84e105c8d8aee3cc", "filename": "libgfortran/io/write.c", "status": "modified", "additions": 24, "deletions": 14, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/55fc9243b7fc0a6c84fb7ff6bf896614bbde91ce/libgfortran%2Fio%2Fwrite.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/55fc9243b7fc0a6c84fb7ff6bf896614bbde91ce/libgfortran%2Fio%2Fwrite.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fio%2Fwrite.c?ref=55fc9243b7fc0a6c84fb7ff6bf896614bbde91ce", "patch": "@@ -1,4 +1,4 @@\n-/* Copyright (C) 2002, 2003, 2004, 2005 Free Software Foundation, Inc.\n+/* Copyright (C) 2002, 2003, 2004, 2005, 2006 Free Software Foundation, Inc.\n    Contributed by Andy Vaught\n    Namelist output contibuted by Paul Thomas\n \n@@ -376,8 +376,15 @@ calculate_G_format (st_parameter_dt *dtp, const fnode *f,\n static void\n output_float (st_parameter_dt *dtp, const fnode *f, GFC_REAL_LARGEST value)\n {\n+#if defined(HAVE_GFC_REAL_16) && __LDBL_DIG__ > 18\n+# define MIN_FIELD_WIDTH 46\n+#else\n+# define MIN_FIELD_WIDTH 31\n+#endif\n+#define STR(x) STR1(x)\n+#define STR1(x) #x\n   /* This must be large enough to accurately hold any value.  */\n-  char buffer[32];\n+  char buffer[MIN_FIELD_WIDTH+1];\n   char *out;\n   char *digits;\n   int e;\n@@ -413,8 +420,8 @@ output_float (st_parameter_dt *dtp, const fnode *f, GFC_REAL_LARGEST value)\n     internal_error (&dtp->common, \"Unspecified precision\");\n \n   /* Use sprintf to print the number in the format +D.DDDDe+ddd\n-     For an N digit exponent, this gives us (32-6)-N digits after the\n-     decimal point, plus another one before the decimal point.  */\n+     For an N digit exponent, this gives us (MIN_FIELD_WIDTH-5)-N digits\n+     after the decimal point, plus another one before the decimal point.  */\n   sign = calculate_sign (dtp, value < 0.0);\n   if (value < 0)\n     value = -value;\n@@ -439,7 +446,7 @@ output_float (st_parameter_dt *dtp, const fnode *f, GFC_REAL_LARGEST value)\n       || ((ft == FMT_D || ft == FMT_E) && dtp->u.p.scale_factor != 0))\n     {\n       /* Always convert at full precision to avoid double rounding.  */\n-      ndigits = 27 - edigits;\n+      ndigits = MIN_FIELD_WIDTH - 4 - edigits;\n     }\n   else\n     {\n@@ -449,8 +456,8 @@ output_float (st_parameter_dt *dtp, const fnode *f, GFC_REAL_LARGEST value)\n \tndigits = d + 1;\n       else\n \tndigits = d;\n-      if (ndigits > 27 - edigits)\n-\tndigits = 27 - edigits;\n+      if (ndigits > MIN_FIELD_WIDTH - 4 - edigits)\n+\tndigits = MIN_FIELD_WIDTH - 4 - edigits;\n     }\n \n   /* #   The result will always contain a decimal point, even if no\n@@ -460,7 +467,7 @@ output_float (st_parameter_dt *dtp, const fnode *f, GFC_REAL_LARGEST value)\n    *\n    * +   A sign (+ or -) always be placed before a number\n    *\n-   * 31  minimum field width\n+   * MIN_FIELD_WIDTH  minimum field width\n    *\n    * *   (ndigits-1) is used as the precision\n    *\n@@ -469,8 +476,8 @@ output_float (st_parameter_dt *dtp, const fnode *f, GFC_REAL_LARGEST value)\n    *   equal to the precision. The exponent always contains at least two\n    *   digits; if the value is zero, the exponent is 00.\n    */\n-  sprintf (buffer, \"%+-#31.*\" GFC_REAL_LARGEST_FORMAT \"e\",\n-           ndigits - 1, value);\n+  sprintf (buffer, \"%+-#\" STR(MIN_FIELD_WIDTH) \".*\"\n+\t   GFC_REAL_LARGEST_FORMAT \"e\", ndigits - 1, value);\n \n   /* Check the resulting string has punctuation in the correct places.  */\n   if (d != 0 && (buffer[2] != '.' || buffer[ndigits + 2] != 'e'))\n@@ -777,7 +784,7 @@ output_float (st_parameter_dt *dtp, const fnode *f, GFC_REAL_LARGEST value)\n \t  edigits--;\n \t}\n #if HAVE_SNPRINTF\n-      snprintf (buffer, 32, \"%+0*d\", edigits, e);\n+      snprintf (buffer, sizeof (buffer), \"%+0*d\", edigits, e);\n #else\n       sprintf (buffer, \"%+0*d\", edigits, e);\n #endif\n@@ -790,6 +797,9 @@ output_float (st_parameter_dt *dtp, const fnode *f, GFC_REAL_LARGEST value)\n       memset( out , ' ' , nblanks );\n       dtp->u.p.no_leading_blank = 0;\n     }\n+#undef STR\n+#undef STR1\n+#undef MIN_FIELD_WIDTH\n }\n \n \n@@ -1352,7 +1362,7 @@ write_character (st_parameter_dt *dtp, const char *source, int length)\n \n /* Output a real number with default format.\n    This is 1PG14.7E2 for REAL(4), 1PG23.15E3 for REAL(8),\n-   1PG24.15E4 for REAL(10) and 1PG40.31E4 for REAL(16).  */\n+   1PG28.19E4 for REAL(10) and 1PG43.34E4 for REAL(16).  */\n \n static void\n write_real (st_parameter_dt *dtp, const char *source, int length)\n@@ -1379,8 +1389,8 @@ write_real (st_parameter_dt *dtp, const char *source, int length)\n       f.u.real.e = 4;\n       break;\n     case 16:\n-      f.u.real.w = 40;\n-      f.u.real.d = 31;\n+      f.u.real.w = 43;\n+      f.u.real.d = 34;\n       f.u.real.e = 4;\n       break;\n     default:"}]}