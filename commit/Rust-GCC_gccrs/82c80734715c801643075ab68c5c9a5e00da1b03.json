{"sha": "82c80734715c801643075ab68c5c9a5e00da1b03", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODJjODA3MzQ3MTVjODAxNjQzMDc1YWI2OGM1YzlhNWUwMGRhMWIwMw==", "commit": {"author": {"name": "Robert Dewar", "email": "dewar@adacore.com", "date": "2005-02-10T13:50:48Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2005-02-10T13:50:48Z"}, "message": "g-zstspl.ads: New file.\n\n2005-02-09  Robert Dewar  <dewar@adacore.com>\n\t    Thomas Quinot  <quinot@adacore.com>\n\t    Javier Miranda  <miranda@adacore.com>\n\t    Pascal Obry  <obry@adacore.com>\n\t    Ed Schonberg  <schonberg@adacore.com>\n\t    Doug Rupp  <rupp@adacore.com>\n\t    Gary Dismukes  <dismukes@adacore.com>\n\t    Richard Kenner  <kenner@vlsi1.ultra.nyu.edu>\n\n\t* g-zstspl.ads: New file.\n\n\t* a-chahan.ads, a-chahan.adb: Add declarations from AI-285\n\n\t* a-string.ads: Add pragma Ada_05 for wide_wide_space to get warning in\n\tAda 95 mode\n\tAdd definition of Wide_Wide_Space for AI-285\n\n\t* impunit.ads, impunit.adb, sem_ch10.adb: Complete rewrite and new\n\tinterface (to support Ada 95 and Ada 2005 units).\n\tAdd Unbounded_IO files\n\tAdd entries for Wide_Wide packages for AI-285\n\tAdd list of containers packages to Ada 2005 unit list\n\n\t* a-swuwti.ads, a-swuwti.adb, a-suteio.ads, a-suteio.adb: Updates to\n\tsupport new Unbounded_IO package cleanly.\n\n\t* g-utf_32.ads, g-utf_32.adb: New files.\n\n\t* Makefile.rtl: Add entry for g-utf_32\n\tAdd new files for Unbounded_IO\n\tAdjust make file for new AI-285 wide wide packages\n\tAdd AI-302 containers to the run time.\n\n\t* a-stwibo.adb, a-stwibo.ads, a-stwisu.adb, a-stwisu.ads,\n\ta-strbou.ads, a-strbou.adb, a-strsup.ads, a-strsup.adb: New\n\tsubprograms for AI-301.\n\n\t* a-stwiun.adb, a-stwiun.ads: Minor reformatting.\n\n\t* a-stunau.ads: Minor comment correction\n\n\t* rtsfind.ads, rtsfind.adb: Add definitions for Wide_Wide attributes\n\tetc.\n\tAlso extend Text_IO_Kludge to support Wide_Wide_Text_IO\n\t(Check_RPC): Update to match changes in expanded code.\n\tClean up unused entity.\n\n\t* exp_ch3.ads, exp_ch3.adb: Fix various places where Wide_Wide_String\n\twas not taken into account.\n\tThis includes proper initialization with Normalize_Scalars.\n\t(Get_Simple_Init_Val): Major rewrite for initialize scalars and\n\tnormalize scalars cases (particularly the latter) to do a better job\n\tof finding invalid representations.\n\n\t* s-scaval.ads, s-scaval.adb: Add values for zero invalid values\n\n\t* s-strops.ads, s-strops.adb: Remove string normalize routines, never\n\tused\n\n\t* exp_dist.adb: Add support for wide wide character type\n\t(Expand_Receiving_Stubs_Bodies): For a package declaration that has a\n\tprivate part, generate stub bodies at the end of the private part,\n\tnot the visible part.\n\t(Add_RACW_Primitive_Operations_And_Bodies): Add last missing code for\n\tPolyORB support.\n\t(Add_Obj_RPC_Receiver_Completion): Add PCS-specific subprograms and\n\tgeneric wrapper to execute final processing after completing the\n\texpansion of the RPC receiver for an RACW.\n\n\t* snames.h, snames.ads, snames.adb: Add definitions for wide_wide\n\tpackages and attributes.\n\t(Preset_Names): Addition of the new reserved words of Ada 2005,\n\tthat is interface, overriding and synchronized.\n\t(Get_Pragma_Id): Give support to the use of the new reserved word\n\t\"interface\" as a pragma name.\n\t(Is_Pragma_Name): Give support to the use of the new reserved word\n\t\"interface\" as a pragma name.\n\t(Preset_Names): Add stream_size string for the Stream_Size Ada2005\n\tattribute implementation.\n\n\t* exp_attr.adb (Expand_Attribute_Reference): Do not apply validity\n\tchecks to entities that are output parameters of Asm operations.\n\tHandle the Stream_Size attribute.\n\tAdd implementation of Wide_Wide_Value, Wide_Wide_Image, Wide_Wide_Width\n\n\t* exp_imgv.ads, exp_imgv.adb: Add support for wide wide character type\n\n\t* sem_attr.adb (Eval_Attribute): Raise compile-time constraint error\n\tfor second parameter being 0.0.\n\tAdd support for wide wide character type.\n\t(Analyze_Attribute, Eval_Attribute): Handle the Stream_Size attribute.\n\n\t* s-valwch.adb, s-valwch.ads, s-imgwch.ads, s-imgwch.adb,\n\ts-wchstw.ads, s-wchstw.adb, s-wchwts.adb, s-wchwts.ads,\n\ts-widwch.adb, s-widwch.ads, s-wwdcha.adb, s-wwdcha.ads,\n\ts-wwdenu.adb, s-wwdenu.ads, s-wwdwch.adb, s-wwdwch.ads: Add support\n\tfor wide wide character cases.\n\n\t* cstand.adb: Create entities for Wide_Wide_Character and\n\tWide_Wide_String.\n\n\t* i-c.ads, i-c.adb: Fix not raising CE for null wide strings in\n\taccordance with AI-258.\n\tAdd new declarations for 16/32 bit C character types (Part of AI285)\n\n\t* einfo.ads, einfo.adb (Is_Obsolescent, Is_Ada_2005): New flag\n\t(Obsolescent_Warning): New field\n\t(Rep_Clause): New local subprogram used to share code. Returns the rep\n\tclause for which the name is given in parameter.\n\t(Has_Stream_Size_Clause): New routine.\n\t(Stream_Size_Clause): Idem. Implementation is based on Rep_Clause.\n\t(Address_Clause): Implementation is now using Rep_Clause.\n\t(Alignment_Clause): Idem.\n\t(Size_Clause): Idem.\n\n\t* lib-xref.adb (Generate_Reference): Test for reference to Ada 2005\n\tentity in non-Ada 2005 mode and generate warning.\n\n\t* par-prag.adb: Add handling of one argument form for pragma Ada_05.\n\t(Prag): Code cleanup. Remove old gnat pragma \"overriding\"\n\n\t* sem_prag.adb: Add handling of one argument form for pragma Ada_05\n\t(Analyze_Pragma, case Elaborate, Elaborate_All): Do not disable warnings\n\ton the named unit if the pragma is not in the current compilation unit,\n\tso that elaboration calls in the current unit can set up an elaboration\n\tdependency on the named unit, as needed.\n\t(Analyze_Pragma, case Obsolescent): Allow pragma to be used for library\n\tsubprogram as well as for subprograms declared within a package.\n\t(Analyze_Pragma, Sig_Flags): Code cleanup. Remove support for the GNAT\n\tpragma overriding.\n\n\t* krunch.ads, krunch.adb: Add special handling of Wide_Wide (krunched\n\tto z) to avoid some instances of duplication for Wide_Wide packages.\n\n\t* namet.ads, namet.adb: Implement encoding (WWhhhhhhhh) for wide wide\n\tcharacters.\n\n\t* scn.adb: Char_Literal_Value field is now a Uint\n\n\t* scng.adb: Significant rewrite to handle new Ada 2005 features\n\tallowing wide and wide wide characters in program text, e.g. for\n\tidentifiers, as described in AI-285.\n\t(Set_Reserved): New procedure, makes setting up keywords cleaner.\n\t(Initialize_Scanner): Register the new reserved words of Ada 2005.\n\t(Scan): Give support to the new reserved words.\n\n\t* par-ch2.adb (P_Identifier): Compiling in Ada95 mode, generate a\n\twarning notifying that interface, overriding, and synchronized are\n\tnew reserved words.\n\t(P_Pragma): Allow the use of the new reserved word \"interface\" as\n\ta pragma name.\n\n\t* gnatls.adb, gnatbind.adb,\n\tali-util.adb, binde.adb, ali.ads, ali.adb: Code cleanup. Rename\n\tidentifiers named \"interface\" to \"SAL_Interface\".\n\n\t* bindgen.adb (Gen_Main_Ada): Add support for the new SEH\n\t(Structured Exception handling).\n\t(Gen_Main_C): Idem.\n\n\t* bindgen.adb:\n\t(Gen_Main_Ada): Set the default exit code if specified.\n\t(Gen_Main_C): Likewise.\n\tPart of *DC20-006.\n\t(Gen_Output_File_C): Remove redundant output of gnat_exit_status.\n\tCode cleanup. Rename identifiers named \"interface\" to \"SAL_Interface\"\n\n\t* switch-b.adb, bindusg.adb, opt.ads, vms_data.ads: Add handling of\n\tnew -Xnnn switch.\n\n\t* mlib-prj.adb, mlib.adb: Code cleanup. Rename one identifier that\n\thas a collision with the new Ada 2005 \"interface\" reserved word.\n\n\t* par-ch3.adb (P_Defining_Identifier): Compiling in Ada95 mode,\n\tgenerate a warning notifying that interface, overriding, and\n\tsynchronized are new reserved words.\n\n\t* scans.ads (Token_Type): Addition of the tokens corresponding to the\n\tnew reserved words of Ada 2005: Tok_Interface, Tok_Overriding\n\tand Tok_Synchronized.\n\n\t* sem_res.adb (Resolve_Actuals): Change error messages to refer to\n\t\"dispatching\" rather than \"primitive\" operations, since dispatching\n\tcalls are now allowed to abstract formal subprograms (which are not\n\tprimitive).\n\tChar_Literal_Value field is now a Uint\n\t(Resolve_Slice): If the prefix is an access to an unconstrained array,\n\tcompute the actual subtype of the designated object to impose the proper\n\tindex constraints.\n\t(Resolve_Selected_Component): Do not insert an access check if the\n\tprefix is an access type: such a node is expanded into an explicit\n\tdereference, on which the access check is performed anyway. Removes\n\texpensive duplicate checks.\n\t(Resolve_Call): Use new flag Is_Obsolescent and field\n\tObsolescent_Warning so that pragma Obsolescent works on library\n\tsubprograms.\n\tAdd support for wide wide character type\n\t(Resolve_Allocator): Replace the error message on wrong null-exclusion\n\tvalue by a warning message.\n\t(Resolve_Type_Conversion): If the mixed-mode expression is interpreted\n\tas fixed-point, and one of the operands is non-static and universal, it\n\tcan only be an illegal exponentiation operation, in which case there is\n\tno real value to retrieve.\n\n\t* exp_strm.adb: Add support for wide wide character type\n\t(Build_Elementary_Input_Call): Compute the size of the stream element by\n\tquerying the rep chain to find the Stream_Attribute attribute value.\n\t(Build_Elementary_Write_Call): Ditto.\n\n\t* sem_aggr.adb: Char_Literal_Value field is now a Uint\n\tAdd support for wide wide character type\n\tReplace the error messages on wrong null-exclusion value by warnings\n\tas described in Ada 2005.\n\t(Resolve_Extension_Aggregate): Document the fact that the error\n\tmessage on class-wide expressions in extensions aggregates.\n\n\t* sem_case.adb: Add support for wide wide character type\n\n\t* sem_ch13.adb: Add support for wide wide character type\n\t(Analyze_Attribute_Definition_Clause): Handle the Stream_Size attribute.\n\n\t* sem_ch3.adb: Add support for wide wide character type\n\t(Process_Subtype): If constraint is illegal for the type, set Ekind of\n\tnow-useless Itype, to prevent cascaded errors on a compiler built\n\twithout -gnatp.\n\n\t* sem_ch8.adb: Add with and use of Sem_Disp.\n\t(Analyze_Subprogram_Renaming): Replace unclean uses of\n\tCorresponding_Spec with Corresponding_Formal_Spec (and delete setting\n\tof Corresponding_Spec to Empty).\n\t(Attribute_Renaming): Replace use of Corresponding_Spec with\n\tCorresponding_ Formal_Spec and simplify condition.\n\t(Use_One_Package): Check that scope of homonym of identifier is defined,\n\tbefore checking whether it is a wrapper package.\n\tAdd support for wide wide character type\n\n\t* sem_eval.adb: Add support for wide wide character type.\n\t(Eval_Arithmetic_Op): Check for compile time known signed integer\n\toverflow in the non-static case.\n\t(Subtypes_Statically_Match): A formal scalar type and its base type do\n\tnot statically match.\n\n\t* sem_util.adb (Collect_Primitive_Operations): Minor change of \"/=\" to\n\t\"not in\" for test of N_Formal_Subprogram_Declaration (which is now a\n\tsubtype).\n\t(Unit_Declaration_Node): Ditto.\n\t(Is_Variable_Prefix):  For the case of an indexed component whose prefix\n\thas a packed array type, the prefix has been rewritten into a type\n\tconversion. Determine variable-ness from the converted expression.\n\tHandle wide wide character cases.\n\n\t* stand.ads: Add types Wide_Wide_Character and Wide_Wide_String\n\n\t* stringt.ads, stringt.adb: Handle full UTF-32 range.\n\tRemove [\"0A\"] from comment, since it can look like a line terminator.\n\tCurrently we don't permit this, but this is under discussion by the\n\tARG, and it is easy enough to use a different example.\n\n\t* s-wchcon.ads, s-wchcnv.ads, s-wchcnv.adb: Add new subprograms for\n\thandling UTF-32 encoding for wide wide character.\n\tImplement new brackets coding [\"hhhhhhhh\"]\n\tAdd UTF-8 encodings for full UTF-32 range\n\n\t* ttypes.ads: Add definition of Standard_Wide_Wide_Character_Size\n\n\t* types.h, types.ads, types.adb: Wide_Wide_Character now has full 31\n\tbit range Add full UTF-32 support.\n\t(RT_Exception_Code): Addition of CE_Null_Not_Allowed; used to\n\tnotify that constraint error will be raised at run-time\n\tbecause a null value is assigned to a null-excluding object.\n\tRemove some obsolete declarations and make Char_Code\n\tunsigned.\n\n\t* a-except.adb (Rcheck_30): New subprogram. Addition of the message\n\tcorresponding to CE_Null_Not_Allowed, and adjust the output of all the\n\tRcheck subprograms.\n\n\t* checks.adb (Check_Null_Not_Allowed): Replace the error message on\n\twrong null-exclusion value by a warning message.\n\t(Enable_Range_Check): Do range check if the prefix is an\n\texplicit dereference whose designated object is an unconstrained array.\n\tCurrent algorithm for removing duplicate checks is over-eager in this\n\tcase.\n\n\t* sem_ch5.adb (Analyze_Assignment): Replace the error messages on wrong\n\tnull-exclusion value by a warning message\n\n\t* atree.h, atree.ads, atree.adb: Remove Char_Code field support\n\tcompletely. Add support for Uint2 field\n\n\tsem_ch2.adb, exp_ch11.adb, exp_dbug.adb,\n\texp_prag.adb: Char_Literal_Value field is now a Uint.\n\n\t* exp_util.adb (Insert_Actions): Replace\n\tN_Formal_Subprogram_Declaration by\n\tN_Formal_{Abstract|Concrete}_Subprogram_Declaration.\n\tChar_Literal_Value field is now a Uint.\n\n\t* sinfo.ads, sinfo.adb (Corresponding_Formal_Spec): New function\n\tdefined for subprogram renaming declarations. When set, the field\n\tindicates the defining entity of a corresponding formal subprogram\n\twhen the renaming corresponds to a formal subprogram association in an\n\tinstantiation.\n\t(Set_Corresponding_Formal_Spec): New procedure to return\n\tCorresponding_Formal_Spec field.\n\tMinor changes of \"=\" to \"in\" in tests of N_Formal_Subprogram_Declaration\n\t(which is now a subtype).\n\tChar_Literal_Value field is now a Uint\n\n\t* exp_disp.ads, exp_disp.adb (Make_DT): Generate code that moves the\n\tpointer to the base of the dispatch table.\n\tMinor changes to comments.\n\t(Controlling_Type): New function for determining the tagged type\n\tassociated with a tagged primitive subprogram.\n\t(Expand_Dispatching_Call): Add support for a controlling actual that is\n\tdirectly a value of type Ada.Tag rather than a tagged object.\n\n\t* i-cpp.ads, i-cpp.adb, a-tags.ads, a-tags.adb: Update documentation\n\tdescribing the new layout.\n\t(Dispatch_Table): The expander computes the actual array size, allocates\n\tthe Dispatch_Table record accordingly, and generates code that displaces\n\tthe base of the record after the Typeinfo_Ptr component. The access to\n\tthese components is done by means of local functions.\n\t(Offset_To_Top): New function.\n\t(Typeinfo_Ptr): New function.\n\t(Get_TSD): Modified to access the new position of the TSD.\n\t(Set_TSD): Modified to save the TSD in its new position.\n\n\t* par-ch12.adb (P_Formal_Subprogram_Declaration): Add parsing for the\n\tcase of formal abstract subprograms. Add check and message for -gnat05.\n\tUpdate comments.\n\n\t* sem_ch12.adb: Add with and use for Sem_Disp.\n\t(Analyze_Associations): Minor change from \"=\" to \"in\" for use of\n\tN_Formal_Subtype_Declaration (which is now a subtype).\n\t(Set_Analyzed_Formal): Minor changes from \"=\" to \"in\" for uses of\n\tN_Formal_Subtype_Declaration (which is now a subtype).\n\t(Analyze_Formal_Subprogram): Add handling for\n\tN_Formal_Abstract_Subprogram, marking the formal as abstract and\n\tdispatching, setting the controlling status of the formal parameters\n\tand result, and issuing an error if there is no controlling type for\n\tthe formal subprogram.\n\t(Instantiate_Formal_Subprogram): Rather than setting Corresponding_Spec,\n\twhich is an unclean use of that field, we set the new field\n\tCorresponding_Formal_Spec to make the formal subprogram available to\n\tprocessing in Analyze_Subprogram_Declaration.\n\t(Analyze_Formal_{Discrete, Decimal_Fixed_Point, Fixed_Point,\n\tFloating_Point, Modular_Integer, Signed_Integer}_Type: Make formal type\n\tConstrained, so that it is is does not statically match its anonymous\n\tbase type.\n\n\t* sem_ch6.adb (Analyze_Subprogram_Specification): Include test for\n\tabstract formal subprograms in error check for functions returning\n\tabstract types. Set scope of new designator for\n\ta parameterless subprogram, so that it is available when checking the\n\tbody for nested subprograms, before full analysis of said body.\n\t(Analyze_Subprogram_Body): Warn on inlining bodies with nested\n\tsubprogram only if inner one comes from source.\n\t(Analyze_Function_Call): If the call is given in object notation, the\n\tanalysis of the name rewrites the node and analyzes it with the proper\n\targument list. After analyzing the name, if the call has been rewritten\n\tand the result type is set, no further analysis is needed.\n\t(Analyze_Return_Type): Subsidiary to Process_Formals: analyze subtype\n\tmark in function specification, in a context where the formals are\n\tvisible and hide outer homographs.\n\n\t* sem_disp.adb (Check_Controlling_Type): Relax the check for same scope\n\tas the tagged type for the cases of abstract formal subprograms and\n\trenamings of those.  Clean up spec comments.\n\t(Check_Dispatching_Context): Add error message to indicate \"abstract\n\tprocedure\", covering the case of a call to a formal abstract procedure\n\tthat has statically tagged operands.\n\t(Check_Dispatching_Call): Check for the case of an actual given by\n\ta tag-indeterminate function call whose type is an ancestor of the\n\tcontaining call's associated tagged type. This situation can occur\n\tfor inherited primitives with function defaults. In this case we\n\tuse the tagged type's tag directly as the controlling argument for\n\tthe calls.\n\t(Expand_Call): Name change on call to Expand_Dispatch_Call.\n\n\t* sprint.adb (Sprint_Node_Actual): Split\n\tN_Formal_Subprogram_Declaration into two alternatives for the new\n\tcases N_Formal_Abstract_Subprogram_Declaration and\n\tN_Formal_Concrete_Subprogram_Declaration.\n\tChar_Literal_Value field is now a Uint.\n\n\t* trans.c: Get rid of junk Uint2 reference.\n\tChar_Literal_Value field is now a Uint.\n\t(gnat_to_gnu, case N_Aggregate): Check TYPE_UNCHECKED_UNION_P.\n\t(gigi): Correct third arg to gimplify_body.\n\n\t* ada-tree.h: (TYPE_UNCHECKED_UNION_P): New flag.\n\t(TYPE_LANG_FLAG_0): Check for record or union.\n\n\t* treepr.adb: Char_Literal_Value field is now a Uint\n\n\t* uintp.h, uintp.ads, uintp.adb: Add new routines UI_To_CC and\n\tUI_From_CC.\n\n\t* widechar.ads, widechar.adb (Is_UTF_32_Non_Graphic): New function\n\tAdd full UTF-32 support\n\tChar_Code is now 32 bits\n\n\t* sinput.ads, sinput.adb (Skip_Line_Terminators): Extend to deal with\n\twide character UTF_32 line terminators.\n\tInitialize Main_Source_File to avoid error when no main\n\tsource is loaded.\n\n\t* errout.adb (Finalize): Do not check Num_SRef_Pragmas\n\t(Main_Source_File) when no main source has been loaded, to avoid\n\tpotential crash.\n\nFrom-SVN: r94809", "tree": {"sha": "76a937dd4ba40cdfaba6b4fdba49cd0e5e36d0ff", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/76a937dd4ba40cdfaba6b4fdba49cd0e5e36d0ff"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/82c80734715c801643075ab68c5c9a5e00da1b03", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/82c80734715c801643075ab68c5c9a5e00da1b03", "html_url": "https://github.com/Rust-GCC/gccrs/commit/82c80734715c801643075ab68c5c9a5e00da1b03", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/82c80734715c801643075ab68c5c9a5e00da1b03/comments", "author": null, "committer": null, "parents": [{"sha": "125d500f84d3016120703bf72b6eda6b3f7e51c6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/125d500f84d3016120703bf72b6eda6b3f7e51c6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/125d500f84d3016120703bf72b6eda6b3f7e51c6"}], "stats": {"total": 21596, "additions": 14587, "deletions": 7009}, "files": [{"sha": "282cbff9569ff8e5872694f5e2fcaefe7d722a36", "filename": "gcc/ada/Makefile.rtl", "status": "modified", "additions": 79, "deletions": 2, "changes": 81, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/82c80734715c801643075ab68c5c9a5e00da1b03/gcc%2Fada%2FMakefile.rtl", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/82c80734715c801643075ab68c5c9a5e00da1b03/gcc%2Fada%2FMakefile.rtl", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FMakefile.rtl?ref=82c80734715c801643075ab68c5c9a5e00da1b03", "patch": "@@ -1,5 +1,5 @@\n # Makefile.rtl for GNU Ada Compiler (GNAT).\n-#   Copyright (C) 2003 Free Software Foundation, Inc.\n+#   Copyright (C) 2003, 2004 Free Software Foundation, Inc.\n \n #This file is part of GCC.\n \n@@ -75,13 +75,40 @@ GNATRTL_TASKING_OBJS= \\\n GNATRTL_NONTASKING_OBJS= \\\n   a-caldel$(objext) \\\n   a-calend$(objext) \\\n+  a-cdlili$(objext) \\\n+  a-cgaaso$(objext) \\\n+  a-cgarso$(objext) \\\n+  a-cgcaso$(objext) \\\n   a-chahan$(objext) \\\n   a-charac$(objext) \\\n   a-chlat1$(objext) \\\n   a-chlat9$(objext) \\\n+  a-chtgke$(objext) \\\n+  a-chtgop$(objext) \\\n+  a-chzla1$(objext) \\\n+  a-chzla9$(objext) \\\n+  a-cidlli$(objext) \\\n+  a-cihama$(objext) \\\n+  a-cihase$(objext) \\\n+  a-ciorma$(objext) \\\n+  a-ciormu$(objext) \\\n+  a-ciorse$(objext) \\\n+  a-cohama$(objext) \\\n+  a-cohase$(objext) \\\n+  a-cohata$(objext) \\\n+  a-coinve$(objext) \\\n   a-colien$(objext) \\\n   a-colire$(objext) \\\n   a-comlin$(objext) \\\n+  a-contai$(objext) \\\n+  a-convec$(objext) \\\n+  a-coorma$(objext) \\\n+  a-coormu$(objext) \\\n+  a-coorse$(objext) \\\n+  a-coprnu$(objext) \\\n+  a-crbltr$(objext) \\\n+  a-crbtgk$(objext) \\\n+  a-crbtgo$(objext) \\\n   a-cwila1$(objext) \\\n   a-cwila9$(objext) \\\n   a-decima$(objext) \\\n@@ -102,12 +129,16 @@ GNATRTL_NONTASKING_OBJS= \\\n   a-iwteio$(objext) \\\n   a-lfteio$(objext) \\\n   a-lfwtio$(objext) \\\n+  a-lfztio$(objext) \\\n   a-liteio$(objext) \\\n   a-liwtio$(objext) \\\n+  a-liztio$(objext) \\\n   a-llftio$(objext) \\\n   a-llfwti$(objext) \\\n+  a-llfzti$(objext) \\\n   a-llitio$(objext) \\\n   a-lliwti$(objext) \\\n+  a-llizti$(objext) \\\n   a-ncelfu$(objext) \\\n   a-ngcefu$(objext) \\\n   a-ngcoty$(objext) \\\n@@ -127,36 +158,59 @@ GNATRTL_NONTASKING_OBJS= \\\n   a-nuflra$(objext) \\\n   a-numaux$(objext) \\\n   a-numeri$(objext) \\\n+  a-rbtgso$(objext) \\\n+  a-secain$(objext) \\\n   a-sequio$(objext) \\\n   a-sfteio$(objext) \\\n   a-sfwtio$(objext) \\\n+  a-sfztio$(objext) \\\n+  a-shcain$(objext) \\\n   a-siocst$(objext) \\\n   a-siteio$(objext) \\\n   a-siwtio$(objext) \\\n+  a-siztio$(objext) \\\n+  a-slcain$(objext) \\\n   a-ssicst$(objext) \\\n   a-ssitio$(objext) \\\n   a-ssiwti$(objext) \\\n+  a-ssizti$(objext) \\\n   a-stmaco$(objext) \\\n   a-storio$(objext) \\\n   a-strbou$(objext) \\\n   a-stream$(objext) \\\n   a-strfix$(objext) \\\n+  a-strhas$(objext) \\\n   a-string$(objext) \\\n   a-strmap$(objext) \\\n   a-strsea$(objext) \\\n   a-strsup$(objext) \\\n   a-strunb$(objext) \\\n   a-ststio$(objext) \\\n   a-stunau$(objext) \\\n+  a-stunha$(objext) \\\n   a-stwibo$(objext) \\\n   a-stwifi$(objext) \\\n+  a-stwiha$(objext) \\\n   a-stwima$(objext) \\\n   a-stwise$(objext) \\\n   a-stwisu$(objext) \\\n   a-stwiun$(objext) \\\n+  a-stzbou$(objext) \\\n+  a-stzfix$(objext) \\\n+  a-stzhas$(objext) \\\n+  a-stzmap$(objext) \\\n+  a-stzsea$(objext) \\\n+  a-stzsup$(objext) \\\n+  a-stzunb$(objext) \\\n   a-suteio$(objext) \\\n-  a-swuwti$(objext) \\\n   a-swmwco$(objext) \\\n+  a-swunau$(objext) \\\n+  a-swunha$(objext) \\\n+  a-swuwti$(objext) \\\n+  a-szmzco$(objext) \\\n+  a-szunau$(objext) \\\n+  a-szunha$(objext) \\\n+  a-szuzti$(objext) \\\n   a-tags$(objext) \\\n   a-teioed$(objext) \\\n   a-textio$(objext) \\\n@@ -176,6 +230,7 @@ GNATRTL_NONTASKING_OBJS= \\\n   a-timoio$(objext) \\\n   a-tiocst$(objext) \\\n   a-titest$(objext) \\\n+  a-tiunio$(objext) \\\n   a-unccon$(objext) \\\n   a-uncdea$(objext) \\\n   a-witeio$(objext) \\\n@@ -196,6 +251,26 @@ GNATRTL_NONTASKING_OBJS= \\\n   a-wtmoau$(objext) \\\n   a-wtmoio$(objext) \\\n   a-wttest$(objext) \\\n+  a-wwunio$(objext) \\\n+  a-ztcoau$(objext) \\\n+  a-ztcoio$(objext) \\\n+  a-ztcstr$(objext) \\\n+  a-ztdeau$(objext) \\\n+  a-ztdeio$(objext) \\\n+  a-ztedit$(objext) \\\n+  a-ztenau$(objext) \\\n+  a-ztenio$(objext) \\\n+  a-ztexio$(objext) \\\n+  a-ztfiio$(objext) \\\n+  a-ztflau$(objext) \\\n+  a-ztflio$(objext) \\\n+  a-ztgeau$(objext) \\\n+  a-ztinau$(objext) \\\n+  a-ztinio$(objext) \\\n+  a-ztmoau$(objext) \\\n+  a-ztmoio$(objext) \\\n+  a-zttest$(objext) \\\n+  a-zzunio$(objext) \\\n   ada$(objext) \\\n   calendar$(objext) \\\n   g-arrspl$(objext) \\\n@@ -256,7 +331,9 @@ GNATRTL_NONTASKING_OBJS= \\\n   g-table$(objext) \\\n   g-tasloc$(objext) \\\n   g-traceb$(objext) \\\n+  g-utf_32$(objext) \\\n   g-wistsp$(objext) \\\n+  g-zstspl$(objext) \\\n   gnat$(objext) \\\n   i-c$(objext) \\\n   i-cexten$(objext) \\"}, {"sha": "c94a999ddf3169b7f23fcb362d8f5a72d6cb80bb", "filename": "gcc/ada/a-chahan.adb", "status": "modified", "additions": 174, "deletions": 39, "changes": 213, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/82c80734715c801643075ab68c5c9a5e00da1b03/gcc%2Fada%2Fa-chahan.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/82c80734715c801643075ab68c5c9a5e00da1b03/gcc%2Fada%2Fa-chahan.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-chahan.adb?ref=82c80734715c801643075ab68c5c9a5e00da1b03", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1992-2001 Free Software Foundation, Inc.          --\n+--          Copyright (C) 1992-2005 Free Software Foundation, Inc.          --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -281,7 +281,7 @@ package body Ada.Characters.Handling is\n    -- Is_Alphanumeric --\n    ---------------------\n \n-   function Is_Alphanumeric (Item : in Character) return Boolean is\n+   function Is_Alphanumeric (Item : Character) return Boolean is\n    begin\n       return (Char_Map (Item) and Alphanum) /= 0;\n    end Is_Alphanumeric;\n@@ -290,7 +290,7 @@ package body Ada.Characters.Handling is\n    -- Is_Basic --\n    --------------\n \n-   function Is_Basic (Item : in Character) return Boolean is\n+   function Is_Basic (Item : Character) return Boolean is\n    begin\n       return (Char_Map (Item) and Basic) /= 0;\n    end Is_Basic;\n@@ -299,16 +299,21 @@ package body Ada.Characters.Handling is\n    -- Is_Character --\n    ------------------\n \n-   function Is_Character (Item : in Wide_Character) return Boolean is\n+   function Is_Character (Item : Wide_Character) return Boolean is\n    begin\n       return Wide_Character'Pos (Item) < 256;\n    end Is_Character;\n \n+   function Is_Character (Item : Wide_Wide_Character) return Boolean is\n+   begin\n+      return Wide_Wide_Character'Pos (Item) < 256;\n+   end Is_Character;\n+\n    ----------------\n    -- Is_Control --\n    ----------------\n \n-   function Is_Control (Item : in Character) return Boolean is\n+   function Is_Control (Item : Character) return Boolean is\n    begin\n       return (Char_Map (Item) and Control) /= 0;\n    end Is_Control;\n@@ -317,7 +322,7 @@ package body Ada.Characters.Handling is\n    -- Is_Digit --\n    --------------\n \n-   function Is_Digit (Item : in Character) return Boolean is\n+   function Is_Digit (Item : Character) return Boolean is\n    begin\n       return Item in '0' .. '9';\n    end Is_Digit;\n@@ -326,7 +331,7 @@ package body Ada.Characters.Handling is\n    -- Is_Graphic --\n    ----------------\n \n-   function Is_Graphic (Item : in Character) return Boolean is\n+   function Is_Graphic (Item : Character) return Boolean is\n    begin\n       return (Char_Map (Item) and Graphic) /= 0;\n    end Is_Graphic;\n@@ -335,7 +340,7 @@ package body Ada.Characters.Handling is\n    -- Is_Hexadecimal_Digit --\n    --------------------------\n \n-   function Is_Hexadecimal_Digit (Item : in Character) return Boolean is\n+   function Is_Hexadecimal_Digit (Item : Character) return Boolean is\n    begin\n       return (Char_Map (Item) and Hex_Digit) /= 0;\n    end Is_Hexadecimal_Digit;\n@@ -344,15 +349,15 @@ package body Ada.Characters.Handling is\n    -- Is_ISO_646 --\n    ----------------\n \n-   function Is_ISO_646 (Item : in Character) return Boolean is\n+   function Is_ISO_646 (Item : Character) return Boolean is\n    begin\n       return Item in ISO_646;\n    end Is_ISO_646;\n \n    --  Note: much more efficient coding of the following function is possible\n    --  by testing several 16#80# bits in a complete word in a single operation\n \n-   function Is_ISO_646 (Item : in String) return Boolean is\n+   function Is_ISO_646 (Item : String) return Boolean is\n    begin\n       for J in Item'Range loop\n          if Item (J) not in ISO_646 then\n@@ -367,7 +372,7 @@ package body Ada.Characters.Handling is\n    -- Is_Letter --\n    ---------------\n \n-   function Is_Letter (Item : in Character) return Boolean is\n+   function Is_Letter (Item : Character) return Boolean is\n    begin\n       return (Char_Map (Item) and Letter) /= 0;\n    end Is_Letter;\n@@ -376,7 +381,7 @@ package body Ada.Characters.Handling is\n    -- Is_Lower --\n    --------------\n \n-   function Is_Lower (Item : in Character) return Boolean is\n+   function Is_Lower (Item : Character) return Boolean is\n    begin\n       return (Char_Map (Item) and Lower) /= 0;\n    end Is_Lower;\n@@ -385,7 +390,7 @@ package body Ada.Characters.Handling is\n    -- Is_Special --\n    ----------------\n \n-   function Is_Special (Item : in Character) return Boolean is\n+   function Is_Special (Item : Character) return Boolean is\n    begin\n       return (Char_Map (Item) and Special) /= 0;\n    end Is_Special;\n@@ -394,7 +399,7 @@ package body Ada.Characters.Handling is\n    -- Is_String --\n    ---------------\n \n-   function Is_String (Item : in Wide_String) return Boolean is\n+   function Is_String (Item : Wide_String) return Boolean is\n    begin\n       for J in Item'Range loop\n          if Wide_Character'Pos (Item (J)) >= 256 then\n@@ -405,25 +410,60 @@ package body Ada.Characters.Handling is\n       return True;\n    end Is_String;\n \n+   function Is_String (Item : Wide_Wide_String) return Boolean is\n+   begin\n+      for J in Item'Range loop\n+         if Wide_Wide_Character'Pos (Item (J)) >= 256 then\n+            return False;\n+         end if;\n+      end loop;\n+\n+      return True;\n+   end Is_String;\n+\n    --------------\n    -- Is_Upper --\n    --------------\n \n-   function Is_Upper (Item : in Character) return Boolean is\n+   function Is_Upper (Item : Character) return Boolean is\n    begin\n       return (Char_Map (Item) and Upper) /= 0;\n    end Is_Upper;\n \n+   -----------------------\n+   -- Is_Wide_Character --\n+   -----------------------\n+\n+   function Is_Wide_Character (Item : Wide_Wide_Character) return Boolean is\n+   begin\n+      return Wide_Wide_Character'Pos (Item) < 2**16;\n+   end Is_Wide_Character;\n+\n+   --------------------\n+   -- Is_Wide_String --\n+   --------------------\n+\n+   function Is_Wide_String (Item : Wide_Wide_String) return Boolean is\n+   begin\n+      for J in Item'Range loop\n+         if Wide_Wide_Character'Pos (Item (J)) >= 2**16 then\n+            return False;\n+         end if;\n+      end loop;\n+\n+      return True;\n+   end Is_Wide_String;\n+\n    --------------\n    -- To_Basic --\n    --------------\n \n-   function To_Basic (Item : in Character) return Character is\n+   function To_Basic (Item : Character) return Character is\n    begin\n       return Value (Basic_Map, Item);\n    end To_Basic;\n \n-   function To_Basic (Item : in String) return String is\n+   function To_Basic (Item : String) return String is\n       Result : String (1 .. Item'Length);\n \n    begin\n@@ -439,9 +479,8 @@ package body Ada.Characters.Handling is\n    ------------------\n \n    function To_Character\n-     (Item       : in Wide_Character;\n-      Substitute : in Character := ' ')\n-      return       Character\n+     (Item       : Wide_Character;\n+      Substitute : Character := ' ') return Character\n    is\n    begin\n       if Is_Character (Item) then\n@@ -451,14 +490,25 @@ package body Ada.Characters.Handling is\n       end if;\n    end To_Character;\n \n+   function To_Character\n+     (Item       : Wide_Wide_Character;\n+      Substitute : Character := ' ') return Character\n+   is\n+   begin\n+      if Is_Character (Item) then\n+         return Character'Val (Wide_Wide_Character'Pos (Item));\n+      else\n+         return Substitute;\n+      end if;\n+   end To_Character;\n+\n    ----------------\n    -- To_ISO_646 --\n    ----------------\n \n    function To_ISO_646\n-     (Item       : in Character;\n-      Substitute : in ISO_646 := ' ')\n-      return       ISO_646\n+     (Item       : Character;\n+      Substitute : ISO_646 := ' ') return ISO_646\n    is\n    begin\n       if Item in ISO_646 then\n@@ -469,9 +519,8 @@ package body Ada.Characters.Handling is\n    end To_ISO_646;\n \n    function To_ISO_646\n-     (Item       : in String;\n-      Substitute : in ISO_646 := ' ')\n-      return       String\n+     (Item       : String;\n+      Substitute : ISO_646 := ' ') return String\n    is\n       Result : String (1 .. Item'Length);\n \n@@ -491,12 +540,12 @@ package body Ada.Characters.Handling is\n    -- To_Lower --\n    --------------\n \n-   function To_Lower (Item : in Character) return Character is\n+   function To_Lower (Item : Character) return Character is\n    begin\n       return Value (Lower_Case_Map, Item);\n    end To_Lower;\n \n-   function To_Lower (Item : in String) return String is\n+   function To_Lower (Item : String) return String is\n       Result : String (1 .. Item'Length);\n \n    begin\n@@ -512,16 +561,30 @@ package body Ada.Characters.Handling is\n    ---------------\n \n    function To_String\n-     (Item       : in Wide_String;\n-      Substitute : in Character := ' ')\n-     return        String\n+     (Item       : Wide_String;\n+      Substitute : Character := ' ') return String\n+   is\n+      Result : String (1 .. Item'Length);\n+\n+   begin\n+      for J in Item'Range loop\n+         Result (J - (Item'First - 1)) := To_Character (Item (J), Substitute);\n+      end loop;\n+\n+      return Result;\n+   end To_String;\n+\n+   function To_String\n+     (Item       : Wide_Wide_String;\n+      Substitute : Character := ' ') return String\n    is\n       Result : String (1 .. Item'Length);\n \n    begin\n       for J in Item'Range loop\n          Result (J - (Item'First - 1)) := To_Character (Item (J), Substitute);\n       end loop;\n+\n       return Result;\n    end To_String;\n \n@@ -530,16 +593,14 @@ package body Ada.Characters.Handling is\n    --------------\n \n    function To_Upper\n-     (Item : in Character)\n-     return  Character\n+     (Item : Character) return Character\n    is\n    begin\n       return Value (Upper_Case_Map, Item);\n    end To_Upper;\n \n    function To_Upper\n-     (Item : in String)\n-      return String\n+     (Item : String) return String\n    is\n       Result : String (1 .. Item'Length);\n \n@@ -556,20 +617,30 @@ package body Ada.Characters.Handling is\n    -----------------------\n \n    function To_Wide_Character\n-     (Item : in Character)\n-      return Wide_Character\n+     (Item : Character) return Wide_Character\n    is\n    begin\n       return Wide_Character'Val (Character'Pos (Item));\n    end To_Wide_Character;\n \n+   function To_Wide_Character\n+     (Item       : Wide_Wide_Character;\n+      Substitute : Wide_Character := ' ') return Wide_Character\n+   is\n+   begin\n+      if Wide_Wide_Character'Pos (Item) < 2**16 then\n+         return Wide_Character'Val (Wide_Wide_Character'Pos (Item));\n+      else\n+         return Substitute;\n+      end if;\n+   end To_Wide_Character;\n+\n    --------------------\n    -- To_Wide_String --\n    --------------------\n \n    function To_Wide_String\n-     (Item : in String)\n-      return Wide_String\n+     (Item : String) return Wide_String\n    is\n       Result : Wide_String (1 .. Item'Length);\n \n@@ -580,4 +651,68 @@ package body Ada.Characters.Handling is\n \n       return Result;\n    end To_Wide_String;\n+\n+   function To_Wide_String\n+     (Item       : Wide_Wide_String;\n+      Substitute : Wide_Character := ' ') return Wide_String\n+   is\n+      Result : Wide_String (1 .. Item'Length);\n+\n+   begin\n+      for J in Item'Range loop\n+         Result (J - (Item'First - 1)) :=\n+           To_Wide_Character (Item (J), Substitute);\n+      end loop;\n+\n+      return Result;\n+   end To_Wide_String;\n+\n+   ----------------------------\n+   -- To_Wide_Wide_Character --\n+   ----------------------------\n+\n+   function To_Wide_Wide_Character\n+     (Item : Character) return Wide_Wide_Character\n+   is\n+   begin\n+      return Wide_Wide_Character'Val (Character'Pos (Item));\n+   end To_Wide_Wide_Character;\n+\n+   function To_Wide_Wide_Character\n+     (Item : Wide_Character) return Wide_Wide_Character\n+   is\n+   begin\n+      return Wide_Wide_Character'Val (Wide_Character'Pos (Item));\n+   end To_Wide_Wide_Character;\n+\n+   -------------------------\n+   -- To_Wide_Wide_String --\n+   -------------------------\n+\n+   function To_Wide_Wide_String\n+     (Item : String) return Wide_Wide_String\n+   is\n+      Result : Wide_Wide_String (1 .. Item'Length);\n+\n+   begin\n+      for J in Item'Range loop\n+         Result (J - (Item'First - 1)) := To_Wide_Wide_Character (Item (J));\n+      end loop;\n+\n+      return Result;\n+   end To_Wide_Wide_String;\n+\n+   function To_Wide_Wide_String\n+     (Item : Wide_String) return Wide_Wide_String\n+   is\n+      Result : Wide_Wide_String (1 .. Item'Length);\n+\n+   begin\n+      for J in Item'Range loop\n+         Result (J - (Item'First - 1)) := To_Wide_Wide_Character (Item (J));\n+      end loop;\n+\n+      return Result;\n+   end To_Wide_Wide_String;\n+\n end Ada.Characters.Handling;"}, {"sha": "ca29d75241974e6ba077a64ee51d70af217ce3eb", "filename": "gcc/ada/a-chahan.ads", "status": "modified", "additions": 68, "deletions": 40, "changes": 108, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/82c80734715c801643075ab68c5c9a5e00da1b03/gcc%2Fada%2Fa-chahan.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/82c80734715c801643075ab68c5c9a5e00da1b03/gcc%2Fada%2Fa-chahan.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-chahan.ads?ref=82c80734715c801643075ab68c5c9a5e00da1b03", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---          Copyright (C) 1992-1997 Free Software Foundation, Inc.          --\n+--          Copyright (C) 1992-2005 Free Software Foundation, Inc.          --\n --                                                                          --\n -- This specification is derived from the Ada Reference Manual for use with --\n -- GNAT. The copyright notice above, and the license provisions that follow --\n@@ -43,30 +43,30 @@ pragma Preelaborate (Handling);\n    -- Character Classification Functions --\n    ----------------------------------------\n \n-   function Is_Control           (Item : in Character) return Boolean;\n-   function Is_Graphic           (Item : in Character) return Boolean;\n-   function Is_Letter            (Item : in Character) return Boolean;\n-   function Is_Lower             (Item : in Character) return Boolean;\n-   function Is_Upper             (Item : in Character) return Boolean;\n-   function Is_Basic             (Item : in Character) return Boolean;\n-   function Is_Digit             (Item : in Character) return Boolean;\n-   function Is_Decimal_Digit     (Item : in Character) return Boolean\n-                                                          renames Is_Digit;\n-   function Is_Hexadecimal_Digit (Item : in Character) return Boolean;\n-   function Is_Alphanumeric      (Item : in Character) return Boolean;\n-   function Is_Special           (Item : in Character) return Boolean;\n+   function Is_Control           (Item : Character) return Boolean;\n+   function Is_Graphic           (Item : Character) return Boolean;\n+   function Is_Letter            (Item : Character) return Boolean;\n+   function Is_Lower             (Item : Character) return Boolean;\n+   function Is_Upper             (Item : Character) return Boolean;\n+   function Is_Basic             (Item : Character) return Boolean;\n+   function Is_Digit             (Item : Character) return Boolean;\n+   function Is_Decimal_Digit     (Item : Character) return Boolean\n+     renames Is_Digit;\n+   function Is_Hexadecimal_Digit (Item : Character) return Boolean;\n+   function Is_Alphanumeric      (Item : Character) return Boolean;\n+   function Is_Special           (Item : Character) return Boolean;\n \n    ---------------------------------------------------\n    -- Conversion Functions for Character and String --\n    ---------------------------------------------------\n \n-   function To_Lower (Item : in Character) return Character;\n-   function To_Upper (Item : in Character) return Character;\n-   function To_Basic (Item : in Character) return Character;\n+   function To_Lower (Item : Character) return Character;\n+   function To_Upper (Item : Character) return Character;\n+   function To_Basic (Item : Character) return Character;\n \n-   function To_Lower (Item : in String) return String;\n-   function To_Upper (Item : in String) return String;\n-   function To_Basic (Item : in String) return String;\n+   function To_Lower (Item : String) return String;\n+   function To_Upper (Item : String) return String;\n+   function To_Basic (Item : String) return String;\n \n    ----------------------------------------------------------------------\n    -- Classifications of and Conversions Between Character and ISO 646 --\n@@ -75,42 +75,69 @@ pragma Preelaborate (Handling);\n    subtype ISO_646 is\n      Character range Character'Val (0) .. Character'Val (127);\n \n-   function Is_ISO_646 (Item : in Character) return Boolean;\n-   function Is_ISO_646 (Item : in String)    return Boolean;\n+   function Is_ISO_646 (Item : Character) return Boolean;\n+   function Is_ISO_646 (Item : String)    return Boolean;\n \n    function To_ISO_646\n-     (Item       : in Character;\n-      Substitute : in ISO_646 := ' ')\n-      return       ISO_646;\n+     (Item       : Character;\n+      Substitute : ISO_646 := ' ') return ISO_646;\n \n    function To_ISO_646\n-     (Item      : in String;\n-      Substitute : in ISO_646 := ' ')\n-      return       String;\n+     (Item       : String;\n+      Substitute : ISO_646 := ' ') return String;\n \n    ------------------------------------------------------\n    -- Classifications of Wide_Character and Characters --\n    ------------------------------------------------------\n \n-   function Is_Character (Item : in Wide_Character) return Boolean;\n-   function Is_String    (Item : in Wide_String)    return Boolean;\n+   function Is_Character (Item : Wide_Character)           return Boolean;\n+   function Is_Character (Item : Wide_Wide_Character)      return Boolean;\n+   function Is_String    (Item : Wide_String)              return Boolean;\n+   function Is_String    (Item : Wide_Wide_String)         return Boolean;\n+   function Is_Wide_Character (Item : Wide_Wide_Character) return Boolean;\n+   function Is_Wide_String (Item : Wide_Wide_String)       return Boolean;\n \n-   ------------------------------------------------------\n-   -- Conversions between Wide_Character and Character --\n-   ------------------------------------------------------\n+   ---------------------------------------------------------------------------\n+   -- Conversions between Wide_Wide_Character, Wide_Character and Character --\n+   ---------------------------------------------------------------------------\n \n    function To_Character\n-     (Item       : in Wide_Character;\n-      Substitute : in Character := ' ')\n-      return       Character;\n+     (Item       : Wide_Character;\n+      Substitute : Character := ' ')      return Character;\n+\n+   function To_Character\n+     (Item       : Wide_Wide_Character;\n+      Substitute : Character := ' ')      return Character;\n \n    function To_String\n-     (Item       : in Wide_String;\n-      Substitute : in Character := ' ')\n-      return       String;\n+     (Item       : Wide_String;\n+      Substitute : Character := ' ')      return String;\n \n-   function To_Wide_Character (Item : in Character) return Wide_Character;\n-   function To_Wide_String    (Item : in String)    return Wide_String;\n+   function To_String\n+     (Item       : Wide_Wide_String;\n+      Substitute : Character := ' ')      return String;\n+\n+   function To_Wide_Character\n+     (Item : Character)                   return Wide_Character;\n+   function To_Wide_Character\n+     (Item       : Wide_Wide_Character;\n+      Substitute : Wide_Character := ' ') return Wide_Character;\n+\n+   function To_Wide_String\n+     (Item : String)                      return Wide_String;\n+   function To_Wide_String\n+     (Item       : Wide_Wide_String;\n+      Substitute : Wide_Character := ' ') return Wide_String;\n+\n+   function To_Wide_Wide_Character\n+     (Item : Character)                   return Wide_Wide_Character;\n+   function To_Wide_Wide_Character\n+     (Item : Wide_Character)              return Wide_Wide_Character;\n+\n+   function To_Wide_Wide_String\n+     (Item : String)                      return Wide_Wide_String;\n+   function To_Wide_Wide_String\n+     (Item : Wide_String)                 return Wide_Wide_String;\n \n private\n    pragma Inline (Is_Control);\n@@ -130,5 +157,6 @@ private\n    pragma Inline (Is_Character);\n    pragma Inline (To_Character);\n    pragma Inline (To_Wide_Character);\n+   pragma Inline (To_Wide_Wide_Character);\n \n end Ada.Characters.Handling;"}, {"sha": "7470d545039f442994cd4c07b50c52fea5803a65", "filename": "gcc/ada/a-except.adb", "status": "modified", "additions": 34, "deletions": 25, "changes": 59, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/82c80734715c801643075ab68c5c9a5e00da1b03/gcc%2Fada%2Fa-except.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/82c80734715c801643075ab68c5c9a5e00da1b03/gcc%2Fada%2Fa-except.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-except.adb?ref=82c80734715c801643075ab68c5c9a5e00da1b03", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1992-2004 Free Software Foundation, Inc.          --\n+--          Copyright (C) 1992-2005 Free Software Foundation, Inc.          --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -484,6 +484,7 @@ package body Ada.Exceptions is\n    procedure Rcheck_27 (File : Big_String_Ptr; Line : Integer);\n    procedure Rcheck_28 (File : Big_String_Ptr; Line : Integer);\n    procedure Rcheck_29 (File : Big_String_Ptr; Line : Integer);\n+   procedure Rcheck_30 (File : Big_String_Ptr; Line : Integer);\n \n    pragma Export (C, Rcheck_00, \"__gnat_rcheck_00\");\n    pragma Export (C, Rcheck_01, \"__gnat_rcheck_01\");\n@@ -515,6 +516,7 @@ package body Ada.Exceptions is\n    pragma Export (C, Rcheck_27, \"__gnat_rcheck_27\");\n    pragma Export (C, Rcheck_28, \"__gnat_rcheck_28\");\n    pragma Export (C, Rcheck_29, \"__gnat_rcheck_29\");\n+   pragma Export (C, Rcheck_30, \"__gnat_rcheck_30\");\n \n    --  None of these procedures ever returns (they raise an exception!). By\n    --  using pragma No_Return, we ensure that any junk code after the call,\n@@ -550,6 +552,7 @@ package body Ada.Exceptions is\n    pragma No_Return (Rcheck_27);\n    pragma No_Return (Rcheck_28);\n    pragma No_Return (Rcheck_29);\n+   pragma No_Return (Rcheck_30);\n \n    ---------------------------------------------\n    -- Reason Strings for Run-Time Check Calls --\n@@ -568,29 +571,30 @@ package body Ada.Exceptions is\n    Rmsg_05 : constant String := \"index check failed\"               & NUL;\n    Rmsg_06 : constant String := \"invalid data\"                     & NUL;\n    Rmsg_07 : constant String := \"length check failed\"              & NUL;\n-   Rmsg_08 : constant String := \"overflow check failed\"            & NUL;\n-   Rmsg_09 : constant String := \"partition check failed\"           & NUL;\n-   Rmsg_10 : constant String := \"range check failed\"               & NUL;\n-   Rmsg_11 : constant String := \"tag check failed\"                 & NUL;\n-   Rmsg_12 : constant String := \"access before elaboration\"        & NUL;\n-   Rmsg_13 : constant String := \"accessibility check failed\"       & NUL;\n-   Rmsg_14 : constant String := \"all guards closed\"                & NUL;\n-   Rmsg_15 : constant String := \"duplicated entry address\"         & NUL;\n-   Rmsg_16 : constant String := \"explicit raise\"                   & NUL;\n-   Rmsg_17 : constant String := \"finalize/adjust raised exception\" & NUL;\n-   Rmsg_18 : constant String := \"misaligned address value\"         & NUL;\n-   Rmsg_19 : constant String := \"missing return\"                   & NUL;\n-   Rmsg_20 : constant String := \"overlaid controlled object\"       & NUL;\n-   Rmsg_21 : constant String := \"potentially blocking operation\"   & NUL;\n-   Rmsg_22 : constant String := \"stubbed subprogram called\"        & NUL;\n-   Rmsg_23 : constant String := \"unchecked union restriction\"      & NUL;\n-   Rmsg_24 : constant String := \"illegal use of\"\n+   Rmsg_08 : constant String := \"null-exclusion check failed\"      & NUL;\n+   Rmsg_09 : constant String := \"overflow check failed\"            & NUL;\n+   Rmsg_10 : constant String := \"partition check failed\"           & NUL;\n+   Rmsg_11 : constant String := \"range check failed\"               & NUL;\n+   Rmsg_12 : constant String := \"tag check failed\"                 & NUL;\n+   Rmsg_13 : constant String := \"access before elaboration\"        & NUL;\n+   Rmsg_14 : constant String := \"accessibility check failed\"       & NUL;\n+   Rmsg_15 : constant String := \"all guards closed\"                & NUL;\n+   Rmsg_16 : constant String := \"duplicated entry address\"         & NUL;\n+   Rmsg_17 : constant String := \"explicit raise\"                   & NUL;\n+   Rmsg_18 : constant String := \"finalize/adjust raised exception\" & NUL;\n+   Rmsg_19 : constant String := \"misaligned address value\"         & NUL;\n+   Rmsg_20 : constant String := \"missing return\"                   & NUL;\n+   Rmsg_21 : constant String := \"overlaid controlled object\"       & NUL;\n+   Rmsg_22 : constant String := \"potentially blocking operation\"   & NUL;\n+   Rmsg_23 : constant String := \"stubbed subprogram called\"        & NUL;\n+   Rmsg_24 : constant String := \"unchecked union restriction\"      & NUL;\n+   Rmsg_25 : constant String := \"illegal use of\"\n              & \" remote access-to-class-wide type, see RM E.4(18)\" & NUL;\n-   Rmsg_25 : constant String := \"empty storage pool\"               & NUL;\n-   Rmsg_26 : constant String := \"explicit raise\"                   & NUL;\n-   Rmsg_27 : constant String := \"infinite recursion\"               & NUL;\n-   Rmsg_28 : constant String := \"object too large\"                 & NUL;\n-   Rmsg_29 : constant String := \"restriction violation\"            & NUL;\n+   Rmsg_26 : constant String := \"empty storage pool\"               & NUL;\n+   Rmsg_27 : constant String := \"explicit raise\"                   & NUL;\n+   Rmsg_28 : constant String := \"infinite recursion\"               & NUL;\n+   Rmsg_29 : constant String := \"object too large\"                 & NUL;\n+   Rmsg_30 : constant String := \"restriction violation\"            & NUL;\n \n    -----------------------\n    -- Polling Interface --\n@@ -1097,7 +1101,7 @@ package body Ada.Exceptions is\n \n    procedure Rcheck_12 (File : Big_String_Ptr; Line : Integer) is\n    begin\n-      Raise_Program_Error_Msg (File, Line, To_Ptr (Rmsg_12'Address));\n+      Raise_Constraint_Error_Msg (File, Line, To_Ptr (Rmsg_12'Address));\n    end Rcheck_12;\n \n    procedure Rcheck_13 (File : Big_String_Ptr; Line : Integer) is\n@@ -1162,7 +1166,7 @@ package body Ada.Exceptions is\n \n    procedure Rcheck_25 (File : Big_String_Ptr; Line : Integer) is\n    begin\n-      Raise_Storage_Error_Msg (File, Line, To_Ptr (Rmsg_25'Address));\n+      Raise_Program_Error_Msg (File, Line, To_Ptr (Rmsg_25'Address));\n    end Rcheck_25;\n \n    procedure Rcheck_26 (File : Big_String_Ptr; Line : Integer) is\n@@ -1185,6 +1189,11 @@ package body Ada.Exceptions is\n       Raise_Storage_Error_Msg (File, Line, To_Ptr (Rmsg_29'Address));\n    end Rcheck_29;\n \n+   procedure Rcheck_30 (File : Big_String_Ptr; Line : Integer) is\n+   begin\n+      Raise_Storage_Error_Msg (File, Line, To_Ptr (Rmsg_30'Address));\n+   end Rcheck_30;\n+\n    -------------\n    -- Reraise --\n    -------------"}, {"sha": "08d339d0b68ceaa8102c2caf86f7a65bd8b579ce", "filename": "gcc/ada/a-strbou.adb", "status": "modified", "additions": 18, "deletions": 19, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/82c80734715c801643075ab68c5c9a5e00da1b03/gcc%2Fada%2Fa-strbou.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/82c80734715c801643075ab68c5c9a5e00da1b03/gcc%2Fada%2Fa-strbou.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-strbou.adb?ref=82c80734715c801643075ab68c5c9a5e00da1b03", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1992-2003 Free Software Foundation, Inc.          --\n+--          Copyright (C) 1992-2005 Free Software Foundation, Inc.          --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -35,23 +35,26 @@ package body Ada.Strings.Bounded is\n \n    package body Generic_Bounded_Length is\n \n+      --  The subprograms in this body are those for which there is no\n+      --  Bounded_String input, and hence no implicit information on the\n+      --  maximum size. This means that the maximum size has to be passed\n+      --  explicitly to the routine in Superbounded.\n+\n       ---------\n       -- \"*\" --\n       ---------\n \n       function \"*\"\n-        (Left  : in Natural;\n-         Right : in Character)\n-         return  Bounded_String\n+        (Left  : Natural;\n+         Right : Character) return Bounded_String\n       is\n       begin\n          return Times (Left, Right, Max_Length);\n       end \"*\";\n \n       function \"*\"\n-        (Left  : in Natural;\n-         Right : in String)\n-         return  Bounded_String\n+        (Left  : Natural;\n+         Right : String) return Bounded_String\n       is\n       begin\n          return Times (Left, Right, Max_Length);\n@@ -62,34 +65,30 @@ package body Ada.Strings.Bounded is\n       ---------------\n \n       function Replicate\n-        (Count : in Natural;\n-         Item  : in Character;\n-         Drop  : in Strings.Truncation := Strings.Error)\n-         return  Bounded_String\n+        (Count : Natural;\n+         Item  : Character;\n+         Drop  : Strings.Truncation := Strings.Error) return Bounded_String\n       is\n       begin\n          return Super_Replicate (Count, Item, Drop, Max_Length);\n       end Replicate;\n \n       function Replicate\n-        (Count : in Natural;\n-         Item  : in String;\n-         Drop  : in Strings.Truncation := Strings.Error)\n-         return  Bounded_String\n+        (Count : Natural;\n+         Item  : String;\n+         Drop  : Strings.Truncation := Strings.Error) return Bounded_String\n       is\n       begin\n          return Super_Replicate (Count, Item, Drop, Max_Length);\n       end Replicate;\n \n-\n       -----------------------\n       -- To_Bounded_String --\n       -----------------------\n \n       function To_Bounded_String\n-        (Source : in String;\n-         Drop   : in Strings.Truncation := Strings.Error)\n-         return   Bounded_String\n+        (Source : String;\n+         Drop   : Strings.Truncation := Strings.Error) return Bounded_String\n       is\n       begin\n          return To_Super_String (Source, Max_Length, Drop);"}, {"sha": "5b8346ad1027e3e54d9a84f8771d74c161c7b3c6", "filename": "gcc/ada/a-strbou.ads", "status": "modified", "additions": 518, "deletions": 468, "changes": 986, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/82c80734715c801643075ab68c5c9a5e00da1b03/gcc%2Fada%2Fa-strbou.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/82c80734715c801643075ab68c5c9a5e00da1b03/gcc%2Fada%2Fa-strbou.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-strbou.ads?ref=82c80734715c801643075ab68c5c9a5e00da1b03", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---          Copyright (C) 1992-2003 Free Software Foundation, Inc.          --\n+--          Copyright (C) 1992-2005 Free Software Foundation, Inc.          --\n --                                                                          --\n -- This specification is derived from the Ada Reference Manual for use with --\n -- GNAT. The copyright notice above, and the license provisions that follow --\n@@ -55,214 +55,245 @@ pragma Preelaborate (Bounded);\n \n       subtype Length_Range is Natural range 0 .. Max_Length;\n \n-      function Length (Source : in Bounded_String) return Length_Range;\n+      function Length (Source : Bounded_String) return Length_Range;\n \n       --------------------------------------------------------\n       -- Conversion, Concatenation, and Selection Functions --\n       --------------------------------------------------------\n \n       function To_Bounded_String\n-        (Source : in String;\n-         Drop   : in Truncation := Error)\n-         return   Bounded_String;\n+        (Source : String;\n+         Drop   : Truncation := Error) return Bounded_String;\n \n-      function To_String (Source : in Bounded_String) return String;\n+      function To_String (Source : Bounded_String) return String;\n+\n+      procedure Set_Bounded_String\n+        (Target : out Bounded_String;\n+         Source : String;\n+         Drop   : Truncation := Error);\n+      pragma Ada_05 (Set_Bounded_String);\n \n       function Append\n-        (Left, Right : in Bounded_String;\n-         Drop        : in Truncation  := Error)\n-         return        Bounded_String;\n+        (Left  : Bounded_String;\n+         Right : Bounded_String;\n+         Drop  : Truncation  := Error) return Bounded_String;\n \n       function Append\n-        (Left  : in Bounded_String;\n-         Right : in String;\n-         Drop  : in Truncation := Error)\n-         return  Bounded_String;\n+        (Left  : Bounded_String;\n+         Right : String;\n+         Drop  : Truncation := Error) return Bounded_String;\n \n       function Append\n-        (Left  : in String;\n-         Right : in Bounded_String;\n-         Drop  : in Truncation := Error)\n-         return  Bounded_String;\n+        (Left  : String;\n+         Right : Bounded_String;\n+         Drop  : Truncation := Error) return Bounded_String;\n \n       function Append\n-        (Left  : in Bounded_String;\n-         Right : in Character;\n-         Drop  : in Truncation := Error)\n-         return  Bounded_String;\n+        (Left  : Bounded_String;\n+         Right : Character;\n+         Drop  : Truncation := Error) return Bounded_String;\n \n       function Append\n-        (Left  : in Character;\n-         Right : in Bounded_String;\n-         Drop  : in Truncation := Error)\n-         return  Bounded_String;\n+        (Left  : Character;\n+         Right : Bounded_String;\n+         Drop  : Truncation := Error) return Bounded_String;\n \n       procedure Append\n         (Source   : in out Bounded_String;\n-         New_Item : in Bounded_String;\n-         Drop     : in Truncation  := Error);\n+         New_Item : Bounded_String;\n+         Drop     : Truncation  := Error);\n \n       procedure Append\n         (Source   : in out Bounded_String;\n-         New_Item : in String;\n-         Drop     : in Truncation  := Error);\n+         New_Item : String;\n+         Drop     : Truncation  := Error);\n \n       procedure Append\n         (Source   : in out Bounded_String;\n-         New_Item : in Character;\n-         Drop     : in Truncation  := Error);\n+         New_Item : Character;\n+         Drop     : Truncation  := Error);\n \n       function \"&\"\n-        (Left, Right : in Bounded_String)\n-         return        Bounded_String;\n+        (Left  : Bounded_String;\n+         Right : Bounded_String) return Bounded_String;\n \n       function \"&\"\n-        (Left  : in Bounded_String;\n-         Right : in String)\n-         return  Bounded_String;\n+        (Left  : Bounded_String;\n+         Right : String) return Bounded_String;\n \n       function \"&\"\n-        (Left  : in String;\n-         Right : in Bounded_String)\n-         return  Bounded_String;\n+        (Left  : String;\n+         Right : Bounded_String) return Bounded_String;\n \n       function \"&\"\n-        (Left  : in Bounded_String;\n-         Right : in Character)\n-         return  Bounded_String;\n+        (Left  : Bounded_String;\n+         Right : Character) return Bounded_String;\n \n       function \"&\"\n-        (Left  : in Character;\n-         Right : in Bounded_String)\n-         return  Bounded_String;\n+        (Left  : Character;\n+         Right : Bounded_String) return Bounded_String;\n \n       function Element\n-        (Source : in Bounded_String;\n-         Index  : in Positive)\n-         return   Character;\n+        (Source : Bounded_String;\n+         Index  : Positive) return Character;\n \n       procedure Replace_Element\n         (Source : in out Bounded_String;\n-         Index  : in Positive;\n-         By     : in Character);\n+         Index  : Positive;\n+         By     : Character);\n \n       function Slice\n-        (Source : in Bounded_String;\n-         Low    : in Positive;\n-         High   : in Natural)\n-         return   String;\n+        (Source : Bounded_String;\n+         Low    : Positive;\n+         High   : Natural) return String;\n+\n+      function Bounded_Slice\n+        (Source : Bounded_String;\n+         Low    : Positive;\n+         High   : Natural) return Bounded_String;\n+      pragma Ada_05 (Bounded_Slice);\n+\n+      procedure Bounded_Slice\n+        (Source : Bounded_String;\n+         Target : out Bounded_String;\n+         Low    : Positive;\n+         High   : Natural);\n+      pragma Ada_05 (Bounded_Slice);\n \n-      function \"=\"  (Left, Right : in Bounded_String) return Boolean;\n+      function \"=\"\n+        (Left  : Bounded_String;\n+         Right : Bounded_String) return Boolean;\n \n       function \"=\"\n-        (Left  : in Bounded_String;\n-         Right : in String)\n-         return  Boolean;\n+        (Left  : Bounded_String;\n+         Right : String) return Boolean;\n \n       function \"=\"\n-        (Left  : in String;\n-         Right : in Bounded_String)\n-         return  Boolean;\n+        (Left  : String;\n+         Right : Bounded_String) return Boolean;\n \n-      function \"<\"  (Left, Right : in Bounded_String) return Boolean;\n+      function \"<\"\n+        (Left  : Bounded_String;\n+         Right : Bounded_String) return Boolean;\n \n       function \"<\"\n-        (Left  : in Bounded_String;\n-         Right : in String)\n-         return  Boolean;\n+        (Left  : Bounded_String;\n+         Right : String) return Boolean;\n \n       function \"<\"\n-        (Left  : in String;\n-         Right : in Bounded_String)\n-         return  Boolean;\n+        (Left  : String;\n+         Right : Bounded_String) return Boolean;\n \n-      function \"<=\" (Left, Right : in Bounded_String) return Boolean;\n+      function \"<=\"\n+        (Left  : Bounded_String;\n+         Right : Bounded_String) return Boolean;\n \n       function \"<=\"\n-        (Left  : in Bounded_String;\n-         Right : in String)\n-         return  Boolean;\n+        (Left  : Bounded_String;\n+         Right : String) return Boolean;\n \n       function \"<=\"\n-        (Left  : in String;\n-         Right : in Bounded_String)\n-         return  Boolean;\n+        (Left  : String;\n+         Right : Bounded_String) return Boolean;\n \n-      function \">\"  (Left, Right : in Bounded_String) return Boolean;\n+      function \">\"\n+        (Left  : Bounded_String;\n+         Right : Bounded_String) return Boolean;\n \n       function \">\"\n-        (Left  : in Bounded_String;\n-         Right : in String)\n-         return  Boolean;\n+        (Left  : Bounded_String;\n+         Right : String) return Boolean;\n \n       function \">\"\n-        (Left  : in String;\n-         Right : in Bounded_String)\n-         return  Boolean;\n+        (Left  : String;\n+         Right : Bounded_String) return Boolean;\n \n-      function \">=\" (Left, Right : in Bounded_String) return Boolean;\n+      function \">=\"\n+        (Left  : Bounded_String;\n+         Right : Bounded_String) return Boolean;\n \n       function \">=\"\n-        (Left  : in Bounded_String;\n-         Right : in String)\n-         return  Boolean;\n+        (Left  : Bounded_String;\n+         Right : String) return Boolean;\n \n       function \">=\"\n-        (Left  : in String;\n-         Right : in Bounded_String)\n-         return  Boolean;\n+        (Left  : String;\n+         Right : Bounded_String) return Boolean;\n \n       ----------------------\n       -- Search Functions --\n       ----------------------\n \n       function Index\n-        (Source  : in Bounded_String;\n-         Pattern : in String;\n-         Going   : in Direction := Forward;\n-         Mapping : in Maps.Character_Mapping := Maps.Identity)\n-         return    Natural;\n+        (Source  : Bounded_String;\n+         Pattern : String;\n+         Going   : Direction := Forward;\n+         Mapping : Maps.Character_Mapping := Maps.Identity) return Natural;\n+\n+      function Index\n+        (Source  : Bounded_String;\n+         Pattern : String;\n+         Going   : Direction := Forward;\n+         Mapping : Maps.Character_Mapping_Function) return Natural;\n \n       function Index\n-        (Source  : in Bounded_String;\n-         Pattern : in String;\n-         Going   : in Direction := Forward;\n-         Mapping : in Maps.Character_Mapping_Function)\n-         return    Natural;\n+        (Source : Bounded_String;\n+         Set    : Maps.Character_Set;\n+         Test   : Membership := Inside;\n+         Going  : Direction  := Forward) return Natural;\n \n       function Index\n-        (Source : in Bounded_String;\n-         Set    : in Maps.Character_Set;\n-         Test   : in Membership := Inside;\n-         Going  : in Direction  := Forward)\n-         return   Natural;\n+        (Source  : Bounded_String;\n+         Pattern : String;\n+         From    : Positive;\n+         Going   : Direction := Forward;\n+         Mapping : Maps.Character_Mapping := Maps.Identity) return Natural;\n+      pragma Ada_05 (Index);\n+\n+      function Index\n+        (Source  : Bounded_String;\n+         Pattern : String;\n+         From    : Positive;\n+         Going   : Direction := Forward;\n+         Mapping : Maps.Character_Mapping_Function) return Natural;\n+      pragma Ada_05 (Index);\n+\n+      function Index\n+        (Source  : Bounded_String;\n+         Set     : Maps.Character_Set;\n+         From    : Positive;\n+         Test    : Membership := Inside;\n+         Going   : Direction := Forward) return Natural;\n+      pragma Ada_05 (Index);\n \n       function Index_Non_Blank\n-        (Source : in Bounded_String;\n-         Going  : in Direction := Forward)\n-         return   Natural;\n+        (Source : Bounded_String;\n+         Going  : Direction := Forward) return Natural;\n+\n+      function Index_Non_Blank\n+        (Source : Bounded_String;\n+         From   : Positive;\n+         Going  : Direction := Forward) return Natural;\n+      pragma Ada_05 (Index_Non_Blank);\n \n       function Count\n-        (Source  : in Bounded_String;\n-         Pattern : in String;\n-         Mapping : in Maps.Character_Mapping := Maps.Identity)\n-         return    Natural;\n+        (Source  : Bounded_String;\n+         Pattern : String;\n+         Mapping : Maps.Character_Mapping := Maps.Identity) return Natural;\n \n       function Count\n-        (Source  : in Bounded_String;\n-         Pattern : in String;\n-         Mapping : in Maps.Character_Mapping_Function)\n-         return    Natural;\n+        (Source  : Bounded_String;\n+         Pattern : String;\n+         Mapping : Maps.Character_Mapping_Function) return Natural;\n \n       function Count\n-        (Source : in Bounded_String;\n-         Set    : in Maps.Character_Set)\n-         return   Natural;\n+        (Source : Bounded_String;\n+         Set    : Maps.Character_Set) return Natural;\n \n       procedure Find_Token\n-        (Source : in Bounded_String;\n-         Set    : in Maps.Character_Set;\n-         Test   : in Membership;\n+        (Source : Bounded_String;\n+         Set    : Maps.Character_Set;\n+         Test   : Membership;\n          First  : out Positive;\n          Last   : out Natural);\n \n@@ -271,569 +302,588 @@ pragma Preelaborate (Bounded);\n       ------------------------------------\n \n       function Translate\n-        (Source   : in Bounded_String;\n-         Mapping  : in Maps.Character_Mapping)\n-         return     Bounded_String;\n+        (Source  : Bounded_String;\n+         Mapping : Maps.Character_Mapping) return Bounded_String;\n \n       procedure Translate\n         (Source   : in out Bounded_String;\n-         Mapping  : in Maps.Character_Mapping);\n+         Mapping  : Maps.Character_Mapping);\n \n       function Translate\n-        (Source  : in Bounded_String;\n-         Mapping : in Maps.Character_Mapping_Function)\n-         return    Bounded_String;\n+        (Source  : Bounded_String;\n+         Mapping : Maps.Character_Mapping_Function) return Bounded_String;\n \n       procedure Translate\n         (Source  : in out Bounded_String;\n-         Mapping : in Maps.Character_Mapping_Function);\n+         Mapping : Maps.Character_Mapping_Function);\n \n       ---------------------------------------\n       -- String Transformation Subprograms --\n       ---------------------------------------\n \n       function Replace_Slice\n-        (Source   : in Bounded_String;\n-         Low      : in Positive;\n-         High     : in Natural;\n-         By       : in String;\n-         Drop     : in Truncation := Error)\n-         return     Bounded_String;\n+        (Source : Bounded_String;\n+         Low    : Positive;\n+         High   : Natural;\n+         By     : String;\n+         Drop   : Truncation := Error) return Bounded_String;\n \n       procedure Replace_Slice\n         (Source   : in out Bounded_String;\n-         Low      : in Positive;\n-         High     : in Natural;\n-         By       : in String;\n-         Drop     : in Truncation := Error);\n+         Low      : Positive;\n+         High     : Natural;\n+         By       : String;\n+         Drop     : Truncation := Error);\n \n       function Insert\n-        (Source   : in Bounded_String;\n-         Before   : in Positive;\n-         New_Item : in String;\n-         Drop     : in Truncation := Error)\n-         return     Bounded_String;\n+        (Source   : Bounded_String;\n+         Before   : Positive;\n+         New_Item : String;\n+         Drop     : Truncation := Error) return Bounded_String;\n \n       procedure Insert\n         (Source   : in out Bounded_String;\n-         Before   : in Positive;\n-         New_Item : in String;\n-         Drop     : in Truncation := Error);\n+         Before   : Positive;\n+         New_Item : String;\n+         Drop     : Truncation := Error);\n \n       function Overwrite\n-        (Source    : in Bounded_String;\n-         Position  : in Positive;\n-         New_Item  : in String;\n-         Drop      : in Truncation := Error)\n-         return      Bounded_String;\n+        (Source   : Bounded_String;\n+         Position : Positive;\n+         New_Item : String;\n+         Drop     : Truncation := Error) return Bounded_String;\n \n       procedure Overwrite\n         (Source    : in out Bounded_String;\n-         Position  : in Positive;\n-         New_Item  : in String;\n-         Drop      : in Truncation := Error);\n+         Position  : Positive;\n+         New_Item  : String;\n+         Drop      : Truncation := Error);\n \n       function Delete\n-        (Source  : in Bounded_String;\n-         From    : in Positive;\n-         Through : in Natural)\n-         return    Bounded_String;\n+        (Source  : Bounded_String;\n+         From    : Positive;\n+         Through : Natural) return Bounded_String;\n \n       procedure Delete\n         (Source  : in out Bounded_String;\n-         From    : in Positive;\n-         Through : in Natural);\n+         From    : Positive;\n+         Through : Natural);\n \n       ---------------------------------\n       -- String Selector Subprograms --\n       ---------------------------------\n \n       function Trim\n-        (Source : in Bounded_String;\n-         Side   : in Trim_End)\n-         return   Bounded_String;\n+        (Source : Bounded_String;\n+         Side   : Trim_End) return Bounded_String;\n \n       procedure Trim\n         (Source : in out Bounded_String;\n-         Side   : in Trim_End);\n+         Side   : Trim_End);\n \n       function Trim\n-        (Source  : in Bounded_String;\n-          Left   : in Maps.Character_Set;\n-          Right  : in Maps.Character_Set)\n-          return   Bounded_String;\n+        (Source : Bounded_String;\n+          Left  : Maps.Character_Set;\n+          Right : Maps.Character_Set) return Bounded_String;\n \n       procedure Trim\n         (Source : in out Bounded_String;\n-         Left   : in Maps.Character_Set;\n-         Right  : in Maps.Character_Set);\n+         Left   : Maps.Character_Set;\n+         Right  : Maps.Character_Set);\n \n       function Head\n-        (Source : in Bounded_String;\n-         Count  : in Natural;\n-         Pad    : in Character := Space;\n-         Drop   : in Truncation := Error)\n-         return   Bounded_String;\n+        (Source : Bounded_String;\n+         Count  : Natural;\n+         Pad    : Character := Space;\n+         Drop   : Truncation := Error) return Bounded_String;\n \n       procedure Head\n         (Source : in out Bounded_String;\n-         Count  : in Natural;\n-         Pad    : in Character  := Space;\n-         Drop   : in Truncation := Error);\n+         Count  : Natural;\n+         Pad    : Character  := Space;\n+         Drop   : Truncation := Error);\n \n       function Tail\n-        (Source : in Bounded_String;\n-         Count  : in Natural;\n-         Pad    : in Character  := Space;\n-         Drop   : in Truncation := Error)\n-         return Bounded_String;\n+        (Source : Bounded_String;\n+         Count  : Natural;\n+         Pad    : Character  := Space;\n+         Drop   : Truncation := Error) return Bounded_String;\n \n       procedure Tail\n         (Source : in out Bounded_String;\n-         Count  : in Natural;\n-         Pad    : in Character  := Space;\n-         Drop   : in Truncation := Error);\n+         Count  : Natural;\n+         Pad    : Character  := Space;\n+         Drop   : Truncation := Error);\n \n       ------------------------------------\n       -- String Constructor Subprograms --\n       ------------------------------------\n \n       function \"*\"\n-        (Left  : in Natural;\n-         Right : in Character)\n-         return  Bounded_String;\n+        (Left  : Natural;\n+         Right : Character) return Bounded_String;\n \n       function \"*\"\n-        (Left  : in Natural;\n-         Right : in String)\n-         return  Bounded_String;\n+        (Left  : Natural;\n+         Right : String) return Bounded_String;\n \n       function \"*\"\n-        (Left  : in Natural;\n-         Right : in Bounded_String)\n-         return  Bounded_String;\n+        (Left  : Natural;\n+         Right : Bounded_String) return Bounded_String;\n \n       function Replicate\n-        (Count : in Natural;\n-         Item  : in Character;\n-         Drop  : in Truncation := Error)\n-         return  Bounded_String;\n+        (Count : Natural;\n+         Item  : Character;\n+         Drop  : Truncation := Error) return Bounded_String;\n \n       function Replicate\n-        (Count : in Natural;\n-         Item  : in String;\n-         Drop  : in Truncation := Error)\n-         return  Bounded_String;\n+        (Count : Natural;\n+         Item  : String;\n+         Drop  : Truncation := Error) return Bounded_String;\n \n       function Replicate\n-        (Count : in Natural;\n-         Item  : in Bounded_String;\n-         Drop  : in Truncation := Error)\n-         return  Bounded_String;\n+        (Count : Natural;\n+         Item  : Bounded_String;\n+         Drop  : Truncation := Error) return Bounded_String;\n \n    private\n-\n-      --  Most of the implementation is in the non generic package\n+      --  Most of the implementation is in the separate non generic package\n       --  Ada.Strings.Superbounded. Type Bounded_String is derived from type\n-      --  Superbounded.Super_String with the maximum length constraint.\n-      --  Except for five, all subprograms are renames of subprograms that\n-      --  are inherited from Superbounded.Super_String.\n+      --  Superbounded.Super_String with the maximum length constraint. In\n+      --  almost all cases, the routines in Superbounded can be called with\n+      --  no requirement to pass the maximum length explicitly, since there\n+      --  is at least one Bounded_String argument from which the maximum\n+      --  length can be obtained. For all such routines, the implementation\n+      --  in this private part is simply a renaming of the corresponding\n+      --  routine in the super bouded package.\n+\n+      --  The five exceptions are the * and Replicate routines operating on\n+      --  character values. For these cases, we have a routine in the body\n+      --  that calls the superbounded routine passing the maximum length\n+      --  explicitly as an extra parameter.\n \n       type Bounded_String is new Superbounded.Super_String (Max_Length);\n+      --  Deriving Bounded_String from Superbounded.Super_String is the\n+      --  real trick, it ensures that the type Bounded_String declared in\n+      --  the generic instantiation is compatible with the Super_String\n+      --  type declared in the Superbounded package.\n \n       Null_Bounded_String : constant Bounded_String :=\n-        (Max_Length     => Max_Length,\n-         Current_Length => 0,\n-         Data           => (1 .. Max_Length => ASCII.NUL));\n+                              (Max_Length     => Max_Length,\n+                               Current_Length => 0,\n+                               Data           =>\n+                                 (1 .. Max_Length => ASCII.NUL));\n \n       pragma Inline (To_Bounded_String);\n \n-      function Length (Source : in Bounded_String) return Length_Range\n-        renames Super_Length;\n+      procedure Set_Bounded_String\n+        (Target : out Bounded_String;\n+         Source : String;\n+         Drop   : Truncation := Error)\n+         renames Set_Super_String;\n \n-      function To_String (Source : in Bounded_String) return String\n-        renames Super_To_String;\n+      function Length\n+        (Source : Bounded_String) return Length_Range\n+         renames Super_Length;\n+\n+      function To_String\n+        (Source : Bounded_String) return String\n+         renames Super_To_String;\n \n       function Append\n-        (Left, Right : in Bounded_String;\n-         Drop        : in Truncation  := Error)\n-         return        Bounded_String\n-        renames Super_Append;\n+        (Left  : Bounded_String;\n+         Right : Bounded_String;\n+         Drop  : Truncation  := Error) return Bounded_String\n+         renames Super_Append;\n \n       function Append\n-        (Left  : in Bounded_String;\n-         Right : in String;\n-         Drop  : in Truncation := Error)\n-         return  Bounded_String\n-        renames Super_Append;\n+        (Left  : Bounded_String;\n+         Right : String;\n+         Drop  : Truncation := Error) return Bounded_String\n+         renames Super_Append;\n \n       function Append\n-        (Left  : in String;\n-         Right : in Bounded_String;\n-         Drop  : in Truncation := Error)\n-         return  Bounded_String\n-        renames Super_Append;\n+        (Left  : String;\n+         Right : Bounded_String;\n+         Drop  : Truncation := Error) return Bounded_String\n+         renames Super_Append;\n \n       function Append\n-        (Left  : in Bounded_String;\n-         Right : in Character;\n-         Drop  : in Truncation := Error)\n-         return  Bounded_String\n-        renames Super_Append;\n+        (Left  : Bounded_String;\n+         Right : Character;\n+         Drop  : Truncation := Error) return Bounded_String\n+         renames Super_Append;\n \n       function Append\n-        (Left  : in Character;\n-         Right : in Bounded_String;\n-         Drop  : in Truncation := Error)\n-         return  Bounded_String\n-        renames Super_Append;\n+        (Left  : Character;\n+         Right : Bounded_String;\n+         Drop  : Truncation := Error) return Bounded_String\n+         renames Super_Append;\n \n       procedure Append\n         (Source   : in out Bounded_String;\n-         New_Item : in Bounded_String;\n-         Drop     : in Truncation  := Error)\n-        renames Super_Append;\n+         New_Item : Bounded_String;\n+         Drop     : Truncation  := Error)\n+         renames Super_Append;\n \n       procedure Append\n         (Source   : in out Bounded_String;\n-         New_Item : in String;\n-         Drop     : in Truncation  := Error)\n-        renames Super_Append;\n+         New_Item : String;\n+         Drop     : Truncation  := Error)\n+         renames Super_Append;\n \n       procedure Append\n         (Source   : in out Bounded_String;\n-         New_Item : in Character;\n-         Drop     : in Truncation  := Error)\n-        renames Super_Append;\n+         New_Item : Character;\n+         Drop     : Truncation  := Error)\n+         renames Super_Append;\n \n       function \"&\"\n-        (Left, Right : in Bounded_String)\n-         return        Bounded_String\n-        renames Concat;\n+        (Left  : Bounded_String;\n+         Right : Bounded_String) return Bounded_String\n+         renames Concat;\n \n       function \"&\"\n-        (Left  : in Bounded_String;\n-         Right : in String)\n-         return  Bounded_String\n-        renames Concat;\n+        (Left  : Bounded_String;\n+         Right : String) return Bounded_String\n+         renames Concat;\n \n       function \"&\"\n-        (Left  : in String;\n-         Right : in Bounded_String)\n-         return  Bounded_String\n-        renames Concat;\n+        (Left  : String;\n+         Right : Bounded_String) return Bounded_String\n+         renames Concat;\n \n       function \"&\"\n-        (Left  : in Bounded_String;\n-         Right : in Character)\n-         return  Bounded_String\n-        renames Concat;\n+        (Left  : Bounded_String;\n+         Right : Character) return Bounded_String\n+         renames Concat;\n \n       function \"&\"\n-        (Left  : in Character;\n-         Right : in Bounded_String)\n-         return  Bounded_String\n-        renames Concat;\n+        (Left  : Character;\n+         Right : Bounded_String) return Bounded_String\n+         renames Concat;\n \n       function Element\n-        (Source : in Bounded_String;\n-         Index  : in Positive)\n-         return   Character\n-        renames Super_Element;\n+        (Source : Bounded_String;\n+         Index  : Positive) return Character\n+         renames Super_Element;\n \n       procedure Replace_Element\n         (Source : in out Bounded_String;\n-         Index  : in Positive;\n-         By     : in Character)\n-        renames Super_Replace_Element;\n+         Index  : Positive;\n+         By     : Character)\n+         renames Super_Replace_Element;\n \n       function Slice\n-        (Source : in Bounded_String;\n-         Low    : in Positive;\n-         High   : in Natural)\n-         return   String\n-        renames Super_Slice;\n+        (Source : Bounded_String;\n+         Low    : Positive;\n+         High   : Natural) return String\n+         renames Super_Slice;\n+\n+      function Bounded_Slice\n+        (Source : Bounded_String;\n+         Low    : Positive;\n+         High   : Natural) return Bounded_String\n+         renames Super_Slice;\n+\n+      procedure Bounded_Slice\n+        (Source : Bounded_String;\n+         Target : out Bounded_String;\n+         Low    : Positive;\n+         High   : Natural)\n+         renames Super_Slice;\n \n-      function \"=\"  (Left, Right : in Bounded_String) return Boolean\n-        renames Equal;\n+      function \"=\"\n+        (Left  : Bounded_String;\n+         Right : Bounded_String) return Boolean\n+         renames Equal;\n \n       function \"=\"\n-        (Left  : in Bounded_String;\n-         Right : in String)\n-         return  Boolean\n-        renames Equal;\n+        (Left  : Bounded_String;\n+         Right : String) return Boolean\n+         renames Equal;\n \n       function \"=\"\n-        (Left  : in String;\n-         Right : in Bounded_String)\n-         return  Boolean\n-        renames Equal;\n+        (Left  : String;\n+         Right : Bounded_String) return Boolean\n+         renames Equal;\n \n-      function \"<\"  (Left, Right : in Bounded_String) return Boolean\n-        renames Less;\n+      function \"<\"\n+        (Left  : Bounded_String;\n+         Right : Bounded_String) return Boolean\n+         renames Less;\n \n       function \"<\"\n-        (Left  : in Bounded_String;\n-         Right : in String)\n-         return  Boolean\n-        renames Less;\n+        (Left  : Bounded_String;\n+         Right : String) return Boolean\n+         renames Less;\n \n       function \"<\"\n-        (Left  : in String;\n-         Right : in Bounded_String)\n-         return  Boolean\n-        renames Less;\n+        (Left  : String;\n+         Right : Bounded_String) return Boolean\n+         renames Less;\n \n-      function \"<=\" (Left, Right : in Bounded_String) return Boolean\n-        renames Less_Or_Equal;\n+      function \"<=\"\n+        (Left  : Bounded_String;\n+         Right : Bounded_String) return Boolean\n+         renames Less_Or_Equal;\n \n       function \"<=\"\n-        (Left  : in Bounded_String;\n-         Right : in String)\n-         return  Boolean\n-        renames Less_Or_Equal;\n+        (Left  : Bounded_String;\n+         Right : String) return Boolean\n+         renames Less_Or_Equal;\n \n       function \"<=\"\n-        (Left  : in String;\n-         Right : in Bounded_String)\n-         return  Boolean\n-        renames Less_Or_Equal;\n+        (Left  : String;\n+         Right : Bounded_String) return Boolean\n+         renames Less_Or_Equal;\n \n-      function \">\"  (Left, Right : in Bounded_String) return Boolean\n-        renames Greater;\n+      function \">\"\n+        (Left  : Bounded_String;\n+         Right : Bounded_String) return Boolean\n+         renames Greater;\n \n       function \">\"\n-        (Left  : in Bounded_String;\n-         Right : in String)\n-         return  Boolean\n-        renames Greater;\n+        (Left  : Bounded_String;\n+         Right : String) return Boolean\n+         renames Greater;\n \n       function \">\"\n-        (Left  : in String;\n-         Right : in Bounded_String)\n-         return  Boolean\n-        renames Greater;\n+        (Left  : String;\n+         Right : Bounded_String) return Boolean\n+         renames Greater;\n \n-      function \">=\" (Left, Right : in Bounded_String) return Boolean\n-        renames Greater_Or_Equal;\n+      function \">=\"\n+        (Left  : Bounded_String;\n+         Right : Bounded_String) return Boolean\n+         renames Greater_Or_Equal;\n \n       function \">=\"\n-        (Left  : in Bounded_String;\n-         Right : in String)\n-         return  Boolean\n-        renames Greater_Or_Equal;\n+        (Left  : Bounded_String;\n+         Right : String) return Boolean\n+         renames Greater_Or_Equal;\n \n       function \">=\"\n-        (Left  : in String;\n-         Right : in Bounded_String)\n-         return  Boolean\n-        renames Greater_Or_Equal;\n+        (Left  : String;\n+         Right : Bounded_String) return Boolean\n+         renames Greater_Or_Equal;\n+\n+      function Index\n+        (Source  : Bounded_String;\n+         Pattern : String;\n+         Going   : Direction := Forward;\n+         Mapping : Maps.Character_Mapping := Maps.Identity) return Natural\n+         renames Super_Index;\n+\n+      function Index\n+        (Source  : Bounded_String;\n+         Pattern : String;\n+         Going   : Direction := Forward;\n+         Mapping : Maps.Character_Mapping_Function) return Natural\n+         renames Super_Index;\n \n       function Index\n-        (Source  : in Bounded_String;\n-         Pattern : in String;\n-         Going   : in Direction := Forward;\n-         Mapping : in Maps.Character_Mapping := Maps.Identity)\n-         return    Natural\n-        renames Super_Index;\n+        (Source : Bounded_String;\n+         Set    : Maps.Character_Set;\n+         Test   : Membership := Inside;\n+         Going  : Direction  := Forward) return Natural\n+         renames Super_Index;\n \n       function Index\n-        (Source  : in Bounded_String;\n-         Pattern : in String;\n-         Going   : in Direction := Forward;\n-         Mapping : in Maps.Character_Mapping_Function)\n-         return    Natural\n-        renames Super_Index;\n+        (Source  : Bounded_String;\n+         Pattern : String;\n+         From    : Positive;\n+         Going   : Direction := Forward;\n+         Mapping : Maps.Character_Mapping := Maps.Identity) return Natural\n+         renames Super_Index;\n \n       function Index\n-        (Source : in Bounded_String;\n-         Set    : in Maps.Character_Set;\n-         Test   : in Membership := Inside;\n-         Going  : in Direction  := Forward)\n-         return   Natural\n-        renames Super_Index;\n+        (Source  : Bounded_String;\n+         Pattern : String;\n+         From    : Positive;\n+         Going   : Direction := Forward;\n+         Mapping : Maps.Character_Mapping_Function) return Natural\n+      renames Super_Index;\n+\n+      function Index\n+        (Source  : Bounded_String;\n+         Set     : Maps.Character_Set;\n+         From    : Positive;\n+         Test    : Membership := Inside;\n+         Going   : Direction := Forward) return Natural\n+      renames Super_Index;\n+\n+      function Index_Non_Blank\n+        (Source : Bounded_String;\n+         Going  : Direction := Forward) return Natural\n+         renames Super_Index_Non_Blank;\n \n       function Index_Non_Blank\n-        (Source : in Bounded_String;\n-         Going  : in Direction := Forward)\n-         return   Natural\n-        renames Super_Index_Non_Blank;\n+        (Source : Bounded_String;\n+         From   : Positive;\n+         Going  : Direction := Forward) return Natural\n+         renames Super_Index_Non_Blank;\n \n       function Count\n-        (Source  : in Bounded_String;\n-         Pattern : in String;\n-         Mapping : in Maps.Character_Mapping := Maps.Identity)\n-         return    Natural\n-        renames Super_Count;\n+        (Source  : Bounded_String;\n+         Pattern : String;\n+         Mapping : Maps.Character_Mapping := Maps.Identity) return Natural\n+         renames Super_Count;\n \n       function Count\n-        (Source  : in Bounded_String;\n-         Pattern : in String;\n-         Mapping : in Maps.Character_Mapping_Function)\n-         return    Natural\n-        renames Super_Count;\n+        (Source  : Bounded_String;\n+         Pattern : String;\n+         Mapping : Maps.Character_Mapping_Function) return Natural\n+         renames Super_Count;\n \n       function Count\n-        (Source : in Bounded_String;\n-         Set    : in Maps.Character_Set)\n-         return   Natural\n-        renames Super_Count;\n+        (Source : Bounded_String;\n+         Set    : Maps.Character_Set) return Natural\n+         renames Super_Count;\n \n       procedure Find_Token\n-        (Source : in Bounded_String;\n-         Set    : in Maps.Character_Set;\n-         Test   : in Membership;\n+        (Source : Bounded_String;\n+         Set    : Maps.Character_Set;\n+         Test   : Membership;\n          First  : out Positive;\n          Last   : out Natural)\n-        renames Super_Find_Token;\n+         renames Super_Find_Token;\n \n       function Translate\n-        (Source   : in Bounded_String;\n-         Mapping  : in Maps.Character_Mapping)\n-         return     Bounded_String\n-        renames Super_Translate;\n+        (Source  : Bounded_String;\n+         Mapping : Maps.Character_Mapping) return Bounded_String\n+         renames Super_Translate;\n \n       procedure Translate\n         (Source   : in out Bounded_String;\n-         Mapping  : in Maps.Character_Mapping)\n-        renames Super_Translate;\n+         Mapping  : Maps.Character_Mapping)\n+         renames Super_Translate;\n \n       function Translate\n-        (Source  : in Bounded_String;\n-         Mapping : in Maps.Character_Mapping_Function)\n-         return    Bounded_String\n-        renames Super_Translate;\n+        (Source  : Bounded_String;\n+         Mapping : Maps.Character_Mapping_Function) return Bounded_String\n+         renames Super_Translate;\n \n       procedure Translate\n         (Source  : in out Bounded_String;\n-         Mapping : in Maps.Character_Mapping_Function)\n-        renames Super_Translate;\n+         Mapping : Maps.Character_Mapping_Function)\n+         renames Super_Translate;\n \n       function Replace_Slice\n-        (Source   : in Bounded_String;\n-         Low      : in Positive;\n-         High     : in Natural;\n-         By       : in String;\n-         Drop     : in Truncation := Error)\n-         return     Bounded_String\n-        renames Super_Replace_Slice;\n+        (Source : Bounded_String;\n+         Low    : Positive;\n+         High   : Natural;\n+         By     : String;\n+         Drop   : Truncation := Error) return Bounded_String\n+         renames Super_Replace_Slice;\n \n       procedure Replace_Slice\n         (Source   : in out Bounded_String;\n-         Low      : in Positive;\n-         High     : in Natural;\n-         By       : in String;\n-         Drop     : in Truncation := Error)\n-        renames Super_Replace_Slice;\n+         Low      : Positive;\n+         High     : Natural;\n+         By       : String;\n+         Drop     : Truncation := Error)\n+         renames Super_Replace_Slice;\n \n       function Insert\n-        (Source   : in Bounded_String;\n-         Before   : in Positive;\n-         New_Item : in String;\n-         Drop     : in Truncation := Error)\n-         return     Bounded_String\n-        renames Super_Insert;\n+        (Source   : Bounded_String;\n+         Before   : Positive;\n+         New_Item : String;\n+         Drop     : Truncation := Error) return Bounded_String\n+         renames Super_Insert;\n \n       procedure Insert\n         (Source   : in out Bounded_String;\n-         Before   : in Positive;\n-         New_Item : in String;\n-         Drop     : in Truncation := Error)\n-        renames Super_Insert;\n+         Before   : Positive;\n+         New_Item : String;\n+         Drop     : Truncation := Error)\n+         renames Super_Insert;\n \n       function Overwrite\n-        (Source    : in Bounded_String;\n-         Position  : in Positive;\n-         New_Item  : in String;\n-         Drop      : in Truncation := Error)\n-         return      Bounded_String\n-        renames Super_Overwrite;\n+        (Source   : Bounded_String;\n+         Position : Positive;\n+         New_Item : String;\n+         Drop     : Truncation := Error) return Bounded_String\n+         renames Super_Overwrite;\n \n       procedure Overwrite\n         (Source    : in out Bounded_String;\n-         Position  : in Positive;\n-         New_Item  : in String;\n-         Drop      : in Truncation := Error)\n-        renames Super_Overwrite;\n+         Position  : Positive;\n+         New_Item  : String;\n+         Drop      : Truncation := Error)\n+         renames Super_Overwrite;\n \n       function Delete\n-        (Source  : in Bounded_String;\n-         From    : in Positive;\n-         Through : in Natural)\n-         return    Bounded_String\n-        renames Super_Delete;\n+        (Source  : Bounded_String;\n+         From    : Positive;\n+         Through : Natural) return Bounded_String\n+         renames Super_Delete;\n \n       procedure Delete\n         (Source  : in out Bounded_String;\n-         From    : in Positive;\n-         Through : in Natural)\n-        renames Super_Delete;\n+         From    : Positive;\n+         Through : Natural)\n+         renames Super_Delete;\n \n       function Trim\n-        (Source : in Bounded_String;\n-         Side   : in Trim_End)\n-         return   Bounded_String\n-        renames Super_Trim;\n+        (Source : Bounded_String;\n+         Side   : Trim_End) return Bounded_String\n+         renames Super_Trim;\n \n       procedure Trim\n         (Source : in out Bounded_String;\n-         Side   : in Trim_End)\n-        renames Super_Trim;\n+         Side   : Trim_End)\n+         renames Super_Trim;\n \n       function Trim\n-        (Source  : in Bounded_String;\n-          Left   : in Maps.Character_Set;\n-          Right  : in Maps.Character_Set)\n-          return   Bounded_String\n-        renames Super_Trim;\n+        (Source : Bounded_String;\n+         Left   : Maps.Character_Set;\n+         Right  : Maps.Character_Set) return Bounded_String\n+         renames Super_Trim;\n \n       procedure Trim\n         (Source : in out Bounded_String;\n-         Left   : in Maps.Character_Set;\n-         Right  : in Maps.Character_Set)\n-        renames Super_Trim;\n+         Left   : Maps.Character_Set;\n+         Right  : Maps.Character_Set)\n+         renames Super_Trim;\n \n       function Head\n-        (Source : in Bounded_String;\n-         Count  : in Natural;\n-         Pad    : in Character := Space;\n-         Drop   : in Truncation := Error)\n-         return   Bounded_String\n-        renames Super_Head;\n+        (Source : Bounded_String;\n+         Count  : Natural;\n+         Pad    : Character := Space;\n+         Drop   : Truncation := Error) return Bounded_String\n+         renames Super_Head;\n \n       procedure Head\n         (Source : in out Bounded_String;\n-         Count  : in Natural;\n-         Pad    : in Character  := Space;\n-         Drop   : in Truncation := Error)\n-        renames Super_Head;\n+         Count  : Natural;\n+         Pad    : Character  := Space;\n+         Drop   : Truncation := Error)\n+         renames Super_Head;\n \n       function Tail\n-        (Source : in Bounded_String;\n-         Count  : in Natural;\n-         Pad    : in Character  := Space;\n-         Drop   : in Truncation := Error)\n-         return Bounded_String\n-        renames Super_Tail;\n+        (Source : Bounded_String;\n+         Count  : Natural;\n+         Pad    : Character  := Space;\n+         Drop   : Truncation := Error) return Bounded_String\n+         renames Super_Tail;\n \n       procedure Tail\n         (Source : in out Bounded_String;\n-         Count  : in Natural;\n-         Pad    : in Character  := Space;\n-         Drop   : in Truncation := Error)\n-        renames Super_Tail;\n+         Count  : Natural;\n+         Pad    : Character  := Space;\n+         Drop   : Truncation := Error)\n+         renames Super_Tail;\n \n       function \"*\"\n-        (Left  : in Natural;\n-         Right : in Bounded_String)\n-         return  Bounded_String\n-        renames Times;\n+        (Left  : Natural;\n+         Right : Bounded_String) return Bounded_String\n+         renames Times;\n \n       function Replicate\n-        (Count : in Natural;\n-         Item  : in Bounded_String;\n-         Drop  : in Truncation := Error)\n-         return  Bounded_String\n+        (Count : Natural;\n+         Item  : Bounded_String;\n+         Drop  : Truncation := Error) return Bounded_String\n          renames Super_Replicate;\n \n    end Generic_Bounded_Length;"}, {"sha": "5b9d803a2000444b27540829d3fc04d9e2124424", "filename": "gcc/ada/a-string.ads", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/82c80734715c801643075ab68c5c9a5e00da1b03/gcc%2Fada%2Fa-string.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/82c80734715c801643075ab68c5c9a5e00da1b03/gcc%2Fada%2Fa-string.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-string.ads?ref=82c80734715c801643075ab68c5c9a5e00da1b03", "patch": "@@ -16,8 +16,13 @@\n package Ada.Strings is\n pragma Pure (Strings);\n \n-   Space      : constant Character      := ' ';\n-   Wide_Space : constant Wide_Character := ' ';\n+   Space           : constant Character           := ' ';\n+   Wide_Space      : constant Wide_Character      := ' ';\n+\n+   --  The following declaration is for Ada 2005 (AI-285)\n+\n+   Wide_Wide_Space : constant Wide_Wide_Character := ' ';\n+   pragma Ada_05 (Wide_Wide_Space);\n \n    Length_Error, Pattern_Error, Index_Error, Translation_Error : exception;\n "}, {"sha": "f32398e71b0168336fed30c9aef7d3a751bde32d", "filename": "gcc/ada/a-strsup.adb", "status": "modified", "additions": 221, "deletions": 122, "changes": 343, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/82c80734715c801643075ab68c5c9a5e00da1b03/gcc%2Fada%2Fa-strsup.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/82c80734715c801643075ab68c5c9a5e00da1b03/gcc%2Fada%2Fa-strsup.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-strsup.adb?ref=82c80734715c801643075ab68c5c9a5e00da1b03", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 2003 Free Software Foundation, Inc.               --\n+--          Copyright (C) 2003-2005 Free Software Foundation, Inc.          --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -42,8 +42,7 @@ package body Ada.Strings.Superbounded is\n \n    function Concat\n      (Left  : Super_String;\n-      Right : Super_String)\n-      return  Super_String\n+      Right : Super_String) return Super_String\n    is\n       Result : Super_String (Left.Max_Length);\n       Llen   : constant Natural := Left.Current_Length;\n@@ -64,8 +63,7 @@ package body Ada.Strings.Superbounded is\n \n    function Concat\n      (Left  : Super_String;\n-      Right : String)\n-      return  Super_String\n+      Right : String) return Super_String\n    is\n       Result : Super_String (Left.Max_Length);\n       Llen   : constant Natural := Left.Current_Length;\n@@ -85,8 +83,7 @@ package body Ada.Strings.Superbounded is\n \n    function Concat\n      (Left  : String;\n-      Right : Super_String)\n-      return  Super_String\n+      Right : Super_String) return Super_String\n    is\n       Result : Super_String (Right.Max_Length);\n       Llen   : constant Natural := Left'Length;\n@@ -107,8 +104,7 @@ package body Ada.Strings.Superbounded is\n \n    function Concat\n      (Left  : Super_String;\n-      Right : Character)\n-      return  Super_String\n+      Right : Character) return Super_String\n    is\n       Result : Super_String (Left.Max_Length);\n       Llen   : constant Natural := Left.Current_Length;\n@@ -127,8 +123,7 @@ package body Ada.Strings.Superbounded is\n \n    function Concat\n      (Left  : Character;\n-      Right : Super_String)\n-      return  Super_String\n+      Right : Super_String) return Super_String\n    is\n       Result : Super_String (Right.Max_Length);\n       Rlen   : constant Natural := Right.Current_Length;\n@@ -149,22 +144,29 @@ package body Ada.Strings.Superbounded is\n    -- Equal --\n    -----------\n \n-   function \"=\" (Left, Right : Super_String) return Boolean is\n+   function \"=\"\n+     (Left  : Super_String;\n+      Right : Super_String) return Boolean\n+   is\n    begin\n       return Left.Current_Length = Right.Current_Length\n         and then Left.Data (1 .. Left.Current_Length) =\n                    Right.Data (1 .. Right.Current_Length);\n    end \"=\";\n \n-   function Equal (Left : Super_String; Right : String)\n-                   return Boolean is\n+   function Equal\n+     (Left  : Super_String;\n+      Right : String) return Boolean\n+   is\n    begin\n       return Left.Current_Length = Right'Length\n         and then Left.Data (1 .. Left.Current_Length) = Right;\n    end Equal;\n \n-   function Equal (Left : String; Right : Super_String)\n-                   return Boolean is\n+   function Equal\n+     (Left  : String;\n+      Right : Super_String) return Boolean\n+   is\n    begin\n       return Left'Length = Right.Current_Length\n         and then Left = Right.Data (1 .. Right.Current_Length);\n@@ -174,25 +176,26 @@ package body Ada.Strings.Superbounded is\n    -- Greater --\n    -------------\n \n-   function Greater (Left, Right : Super_String) return Boolean is\n+   function Greater\n+     (Left  : Super_String;\n+      Right : Super_String) return Boolean\n+   is\n    begin\n       return Left.Data (1 .. Left.Current_Length) >\n                Right.Data (1 .. Right.Current_Length);\n    end Greater;\n \n    function Greater\n      (Left  : Super_String;\n-      Right : String)\n-      return  Boolean\n+      Right : String) return Boolean\n    is\n    begin\n       return Left.Data (1 .. Left.Current_Length) > Right;\n    end Greater;\n \n    function Greater\n      (Left  : String;\n-      Right : Super_String)\n-      return  Boolean\n+      Right : Super_String) return Boolean\n    is\n    begin\n       return Left > Right.Data (1 .. Right.Current_Length);\n@@ -202,25 +205,26 @@ package body Ada.Strings.Superbounded is\n    -- Greater_Or_Equal --\n    ----------------------\n \n-   function Greater_Or_Equal (Left, Right : Super_String) return Boolean is\n+   function Greater_Or_Equal\n+     (Left  : Super_String;\n+      Right : Super_String) return Boolean\n+   is\n    begin\n       return Left.Data (1 .. Left.Current_Length) >=\n                Right.Data (1 .. Right.Current_Length);\n    end Greater_Or_Equal;\n \n    function Greater_Or_Equal\n      (Left  : Super_String;\n-      Right : String)\n-      return  Boolean\n+      Right : String) return Boolean\n    is\n    begin\n       return Left.Data (1 .. Left.Current_Length) >= Right;\n    end Greater_Or_Equal;\n \n    function Greater_Or_Equal\n      (Left  : String;\n-      Right : Super_String)\n-      return  Boolean\n+      Right : Super_String) return Boolean\n    is\n    begin\n       return Left >= Right.Data (1 .. Right.Current_Length);\n@@ -230,25 +234,26 @@ package body Ada.Strings.Superbounded is\n    -- Less --\n    ----------\n \n-   function Less (Left, Right : Super_String) return Boolean is\n+   function Less\n+     (Left  : Super_String;\n+      Right : Super_String) return Boolean\n+   is\n    begin\n       return Left.Data (1 .. Left.Current_Length) <\n                Right.Data (1 .. Right.Current_Length);\n    end Less;\n \n    function Less\n      (Left  : Super_String;\n-      Right : String)\n-      return  Boolean\n+      Right : String) return Boolean\n    is\n    begin\n       return Left.Data (1 .. Left.Current_Length) < Right;\n    end Less;\n \n    function Less\n      (Left  : String;\n-      Right : Super_String)\n-      return  Boolean\n+      Right : Super_String) return Boolean\n    is\n    begin\n       return Left < Right.Data (1 .. Right.Current_Length);\n@@ -258,40 +263,76 @@ package body Ada.Strings.Superbounded is\n    -- Less_Or_Equal --\n    -------------------\n \n-   function Less_Or_Equal (Left, Right : Super_String) return Boolean is\n+   function Less_Or_Equal\n+     (Left  : Super_String;\n+      Right : Super_String) return Boolean\n+   is\n    begin\n       return Left.Data (1 .. Left.Current_Length) <=\n                Right.Data (1 .. Right.Current_Length);\n    end Less_Or_Equal;\n \n    function Less_Or_Equal\n      (Left  : Super_String;\n-      Right : String)\n-      return  Boolean\n+      Right : String) return Boolean\n    is\n    begin\n       return Left.Data (1 .. Left.Current_Length) <= Right;\n    end Less_Or_Equal;\n \n    function Less_Or_Equal\n      (Left  : String;\n-      Right : Super_String)\n-      return  Boolean\n+      Right : Super_String) return Boolean\n    is\n    begin\n       return Left <= Right.Data (1 .. Right.Current_Length);\n    end Less_Or_Equal;\n \n+   ----------------------\n+   -- Set_Super_String --\n+   ----------------------\n+\n+   procedure Set_Super_String\n+     (Target : out Super_String;\n+      Source : String;\n+      Drop   : Truncation := Error)\n+   is\n+      Slen       : constant Natural := Source'Length;\n+      Max_Length : constant Positive := Target.Max_Length;\n+\n+   begin\n+      if Slen <= Max_Length then\n+         Target.Current_Length := Slen;\n+         Target.Data (1 .. Slen) := Source;\n+\n+      else\n+         case Drop is\n+            when Strings.Right =>\n+               Target.Current_Length := Max_Length;\n+               Target.Data (1 .. Max_Length) :=\n+                 Source (Source'First .. Source'First - 1 + Max_Length);\n+\n+            when Strings.Left =>\n+               Target.Current_Length := Max_Length;\n+               Target.Data (1 .. Max_Length) :=\n+                 Source (Source'Last - (Max_Length - 1) .. Source'Last);\n+\n+            when Strings.Error =>\n+               raise Ada.Strings.Length_Error;\n+         end case;\n+      end if;\n+   end Set_Super_String;\n+\n    ------------------\n    -- Super_Append --\n    ------------------\n \n    --  Case of Super_String and Super_String\n \n    function Super_Append\n-     (Left, Right : Super_String;\n-      Drop        : Strings.Truncation  := Strings.Error)\n-      return        Super_String\n+     (Left  : Super_String;\n+      Right : Super_String;\n+      Drop  : Truncation := Error) return Super_String\n    is\n       Max_Length : constant Positive := Left.Max_Length;\n       Result : Super_String (Max_Length);\n@@ -341,7 +382,7 @@ package body Ada.Strings.Superbounded is\n    procedure Super_Append\n      (Source   : in out Super_String;\n       New_Item : Super_String;\n-      Drop     : Truncation  := Error)\n+      Drop     : Truncation := Error)\n    is\n       Max_Length : constant Positive := Source.Max_Length;\n       Llen       : constant Natural := Source.Current_Length;\n@@ -386,8 +427,7 @@ package body Ada.Strings.Superbounded is\n    function Super_Append\n      (Left  : Super_String;\n       Right : String;\n-      Drop  : Strings.Truncation := Strings.Error)\n-      return  Super_String\n+      Drop  : Strings.Truncation := Strings.Error) return Super_String\n    is\n       Max_Length : constant Positive := Left.Max_Length;\n       Result : Super_String (Max_Length);\n@@ -440,7 +480,7 @@ package body Ada.Strings.Superbounded is\n    procedure Super_Append\n      (Source   : in out Super_String;\n       New_Item : String;\n-      Drop     : Truncation  := Error)\n+      Drop     : Truncation := Error)\n    is\n       Max_Length : constant Positive := Source.Max_Length;\n       Llen   : constant Natural := Source.Current_Length;\n@@ -488,8 +528,7 @@ package body Ada.Strings.Superbounded is\n    function Super_Append\n      (Left  : String;\n       Right : Super_String;\n-      Drop  : Strings.Truncation := Strings.Error)\n-      return  Super_String\n+      Drop  : Strings.Truncation := Strings.Error) return Super_String\n    is\n       Max_Length : constant Positive := Right.Max_Length;\n       Result     : Super_String (Max_Length);\n@@ -543,8 +582,7 @@ package body Ada.Strings.Superbounded is\n    function Super_Append\n      (Left  : Super_String;\n       Right : Character;\n-      Drop  : Strings.Truncation := Strings.Error)\n-      return  Super_String\n+      Drop  : Strings.Truncation := Strings.Error) return Super_String\n    is\n       Max_Length : constant Positive := Left.Max_Length;\n       Result     : Super_String (Max_Length);\n@@ -578,7 +616,7 @@ package body Ada.Strings.Superbounded is\n    procedure Super_Append\n      (Source   : in out Super_String;\n       New_Item : Character;\n-      Drop     : Truncation  := Error)\n+      Drop     : Truncation := Error)\n    is\n       Max_Length : constant Positive := Source.Max_Length;\n       Llen       : constant Natural  := Source.Current_Length;\n@@ -612,8 +650,7 @@ package body Ada.Strings.Superbounded is\n    function Super_Append\n      (Left  : Character;\n       Right : Super_String;\n-      Drop  : Strings.Truncation := Strings.Error)\n-      return  Super_String\n+      Drop  : Strings.Truncation := Strings.Error) return Super_String\n    is\n       Max_Length : constant Positive := Right.Max_Length;\n       Result : Super_String (Max_Length);\n@@ -649,10 +686,9 @@ package body Ada.Strings.Superbounded is\n    -----------------\n \n    function Super_Count\n-     (Source   : Super_String;\n-      Pattern  : String;\n-      Mapping  : Maps.Character_Mapping := Maps.Identity)\n-      return     Natural\n+     (Source  : Super_String;\n+      Pattern : String;\n+      Mapping : Maps.Character_Mapping := Maps.Identity) return Natural\n    is\n    begin\n       return\n@@ -661,10 +697,9 @@ package body Ada.Strings.Superbounded is\n    end Super_Count;\n \n    function Super_Count\n-     (Source   : Super_String;\n-      Pattern  : String;\n-      Mapping  : Maps.Character_Mapping_Function)\n-      return     Natural\n+     (Source  : Super_String;\n+      Pattern : String;\n+      Mapping : Maps.Character_Mapping_Function) return Natural\n    is\n    begin\n       return\n@@ -674,8 +709,7 @@ package body Ada.Strings.Superbounded is\n \n    function Super_Count\n      (Source : Super_String;\n-      Set    : Maps.Character_Set)\n-      return   Natural\n+      Set    : Maps.Character_Set) return Natural\n    is\n    begin\n       return Search.Count (Source.Data (1 .. Source.Current_Length), Set);\n@@ -688,8 +722,7 @@ package body Ada.Strings.Superbounded is\n    function Super_Delete\n      (Source  : Super_String;\n       From    : Positive;\n-      Through : Natural)\n-      return    Super_String\n+      Through : Natural) return Super_String\n    is\n       Result     : Super_String (Source.Max_Length);\n       Slen       : constant Natural := Source.Current_Length;\n@@ -747,8 +780,7 @@ package body Ada.Strings.Superbounded is\n \n    function Super_Element\n      (Source : Super_String;\n-      Index  : Positive)\n-      return   Character\n+      Index  : Positive) return Character\n    is\n    begin\n       if Index in 1 .. Source.Current_Length then\n@@ -782,8 +814,7 @@ package body Ada.Strings.Superbounded is\n      (Source : Super_String;\n       Count  : Natural;\n       Pad    : Character := Space;\n-      Drop   : Strings.Truncation := Strings.Error)\n-      return   Super_String\n+      Drop   : Strings.Truncation := Strings.Error) return Super_String\n    is\n       Max_Length : constant Positive := Source.Max_Length;\n       Result     : Super_String (Max_Length);\n@@ -830,7 +861,7 @@ package body Ada.Strings.Superbounded is\n    procedure Super_Head\n      (Source : in out Super_String;\n       Count  : Natural;\n-      Pad    : Character  := Space;\n+      Pad    : Character := Space;\n       Drop   : Truncation := Error)\n    is\n       Max_Length : constant Positive := Source.Max_Length;\n@@ -878,23 +909,21 @@ package body Ada.Strings.Superbounded is\n    -----------------\n \n    function Super_Index\n-     (Source   : Super_String;\n-      Pattern  : String;\n-      Going    : Strings.Direction := Strings.Forward;\n-      Mapping  : Maps.Character_Mapping := Maps.Identity)\n-      return     Natural\n+     (Source  : Super_String;\n+      Pattern : String;\n+      Going   : Strings.Direction := Strings.Forward;\n+      Mapping : Maps.Character_Mapping := Maps.Identity) return Natural\n    is\n    begin\n       return Search.Index\n         (Source.Data (1 .. Source.Current_Length), Pattern, Going, Mapping);\n    end Super_Index;\n \n    function Super_Index\n-     (Source   : Super_String;\n-      Pattern  : String;\n-      Going    : Direction := Forward;\n-      Mapping  : Maps.Character_Mapping_Function)\n-      return     Natural\n+     (Source  : Super_String;\n+      Pattern : String;\n+      Going   : Direction := Forward;\n+      Mapping : Maps.Character_Mapping_Function) return Natural\n    is\n    begin\n       return Search.Index\n@@ -905,29 +934,76 @@ package body Ada.Strings.Superbounded is\n      (Source : Super_String;\n       Set    : Maps.Character_Set;\n       Test   : Strings.Membership := Strings.Inside;\n-      Going  : Strings.Direction  := Strings.Forward)\n-      return   Natural\n+      Going  : Strings.Direction  := Strings.Forward) return Natural\n    is\n    begin\n       return Search.Index\n         (Source.Data (1 .. Source.Current_Length), Set, Test, Going);\n    end Super_Index;\n \n+   function Super_Index\n+     (Source  : Super_String;\n+      Pattern : String;\n+      From    : Positive;\n+      Going   : Direction := Forward;\n+      Mapping : Maps.Character_Mapping := Maps.Identity) return Natural\n+   is\n+   begin\n+      return Search.Index\n+        (Source.Data (1 .. Source.Current_Length),\n+         Pattern, From, Going, Mapping);\n+   end Super_Index;\n+\n+   function Super_Index\n+     (Source  : Super_String;\n+      Pattern : String;\n+      From    : Positive;\n+      Going   : Direction := Forward;\n+      Mapping : Maps.Character_Mapping_Function) return Natural\n+   is\n+   begin\n+      return Search.Index\n+        (Source.Data (1 .. Source.Current_Length),\n+         Pattern, From, Going, Mapping);\n+   end Super_Index;\n+\n+   function Super_Index\n+     (Source : Super_String;\n+      Set    : Maps.Character_Set;\n+      From   : Positive;\n+      Test   : Membership := Inside;\n+      Going  : Direction := Forward) return Natural\n+   is\n+   begin\n+      return Search.Index\n+        (Source.Data (1 .. Source.Current_Length), Set, From, Test, Going);\n+   end Super_Index;\n+\n    ---------------------------\n    -- Super_Index_Non_Blank --\n    ---------------------------\n \n    function Super_Index_Non_Blank\n      (Source : Super_String;\n-      Going  : Strings.Direction := Strings.Forward)\n-      return   Natural\n+      Going  : Strings.Direction := Strings.Forward) return Natural\n    is\n    begin\n       return\n         Search.Index_Non_Blank\n           (Source.Data (1 .. Source.Current_Length), Going);\n    end Super_Index_Non_Blank;\n \n+   function Super_Index_Non_Blank\n+     (Source : Super_String;\n+      From   : Positive;\n+      Going  : Direction := Forward) return Natural\n+   is\n+   begin\n+      return\n+        Search.Index_Non_Blank\n+          (Source.Data (1 .. Source.Current_Length), From, Going);\n+   end Super_Index_Non_Blank;\n+\n    ------------------\n    -- Super_Insert --\n    ------------------\n@@ -936,8 +1012,7 @@ package body Ada.Strings.Superbounded is\n      (Source   : Super_String;\n       Before   : Positive;\n       New_Item : String;\n-      Drop     : Strings.Truncation := Strings.Error)\n-      return     Super_String\n+      Drop     : Strings.Truncation := Strings.Error) return Super_String\n    is\n       Max_Length : constant Positive := Source.Max_Length;\n       Result     : Super_String (Max_Length);\n@@ -1032,11 +1107,10 @@ package body Ada.Strings.Superbounded is\n    ---------------------\n \n    function Super_Overwrite\n-     (Source    : Super_String;\n-      Position  : Positive;\n-      New_Item  : String;\n-      Drop      : Strings.Truncation := Strings.Error)\n-      return      Super_String\n+     (Source   : Super_String;\n+      Position : Positive;\n+      New_Item : String;\n+      Drop     : Strings.Truncation := Strings.Error) return Super_String\n    is\n       Max_Length : constant Positive := Source.Max_Length;\n       Result     : Super_String (Max_Length);\n@@ -1172,12 +1246,11 @@ package body Ada.Strings.Superbounded is\n    -------------------------\n \n    function Super_Replace_Slice\n-     (Source   : Super_String;\n-      Low      : Positive;\n-      High     : Natural;\n-      By       : String;\n-      Drop     : Strings.Truncation := Strings.Error)\n-      return     Super_String\n+     (Source : Super_String;\n+      Low    : Positive;\n+      High   : Natural;\n+      By     : String;\n+      Drop   : Strings.Truncation := Strings.Error) return Super_String\n    is\n       Max_Length : constant Positive := Source.Max_Length;\n       Slen       : constant Natural  := Source.Current_Length;\n@@ -1273,8 +1346,7 @@ package body Ada.Strings.Superbounded is\n      (Count      : Natural;\n       Item       : Character;\n       Drop       : Truncation := Error;\n-      Max_Length : Positive)\n-      return       Super_String\n+      Max_Length : Positive) return Super_String\n    is\n       Result : Super_String (Max_Length);\n \n@@ -1297,8 +1369,7 @@ package body Ada.Strings.Superbounded is\n      (Count      : Natural;\n       Item       : String;\n       Drop       : Truncation := Error;\n-      Max_Length : Positive)\n-      return       Super_String\n+      Max_Length : Positive) return Super_String\n    is\n       Length : constant Integer := Count * Item'Length;\n       Result : Super_String (Max_Length);\n@@ -1354,8 +1425,7 @@ package body Ada.Strings.Superbounded is\n    function Super_Replicate\n      (Count : Natural;\n       Item  : Super_String;\n-      Drop  : Strings.Truncation := Strings.Error)\n-      return  Super_String\n+      Drop  : Strings.Truncation := Strings.Error) return Super_String\n    is\n    begin\n       return\n@@ -1373,8 +1443,7 @@ package body Ada.Strings.Superbounded is\n    function Super_Slice\n      (Source : Super_String;\n       Low    : Positive;\n-      High   : Natural)\n-      return   String\n+      High   : Natural) return String\n    is\n    begin\n       --  Note: test of High > Length is in accordance with AI95-00128\n@@ -1388,6 +1457,43 @@ package body Ada.Strings.Superbounded is\n       end if;\n    end Super_Slice;\n \n+   function Super_Slice\n+     (Source : Super_String;\n+      Low    : Positive;\n+      High   : Natural) return Super_String\n+   is\n+      Result : Super_String (Source.Max_Length);\n+\n+   begin\n+      if Low > Source.Current_Length + 1\n+        or else High > Source.Current_Length\n+      then\n+         raise Index_Error;\n+      else\n+         Result.Current_Length := High - Low + 1;\n+         Result.Data (1 .. Source.Current_Length) := Source.Data (Low .. High);\n+      end if;\n+\n+      return Result;\n+   end Super_Slice;\n+\n+   procedure Super_Slice\n+     (Source : Super_String;\n+      Target : out Super_String;\n+      Low    : Positive;\n+      High   : Natural)\n+   is\n+   begin\n+      if Low > Source.Current_Length + 1\n+        or else High > Source.Current_Length\n+      then\n+         raise Index_Error;\n+      else\n+         Target.Current_Length := High - Low + 1;\n+         Target.Data (1 .. Source.Current_Length) := Source.Data (Low .. High);\n+      end if;\n+   end Super_Slice;\n+\n    ----------------\n    -- Super_Tail --\n    ----------------\n@@ -1396,8 +1502,7 @@ package body Ada.Strings.Superbounded is\n      (Source : Super_String;\n       Count  : Natural;\n       Pad    : Character := Space;\n-      Drop   : Strings.Truncation := Strings.Error)\n-      return   Super_String\n+      Drop   : Strings.Truncation := Strings.Error) return Super_String\n    is\n       Max_Length : constant Positive := Source.Max_Length;\n       Result     : Super_String (Max_Length);\n@@ -1445,7 +1550,7 @@ package body Ada.Strings.Superbounded is\n    procedure Super_Tail\n      (Source : in out Super_String;\n       Count  : Natural;\n-      Pad    : Character  := Space;\n+      Pad    : Character := Space;\n       Drop   : Truncation := Error)\n    is\n       Max_Length : constant Positive := Source.Max_Length;\n@@ -1497,7 +1602,7 @@ package body Ada.Strings.Superbounded is\n    -- Super_To_String --\n    ---------------------\n \n-   function Super_To_String (Source : in Super_String) return String is\n+   function Super_To_String (Source : Super_String) return String is\n    begin\n       return Source.Data (1 .. Source.Current_Length);\n    end Super_To_String;\n@@ -1508,8 +1613,7 @@ package body Ada.Strings.Superbounded is\n \n    function Super_Translate\n      (Source  : Super_String;\n-      Mapping : Maps.Character_Mapping)\n-      return    Super_String\n+      Mapping : Maps.Character_Mapping) return Super_String\n    is\n       Result : Super_String (Source.Max_Length);\n \n@@ -1535,8 +1639,7 @@ package body Ada.Strings.Superbounded is\n \n    function Super_Translate\n      (Source  : Super_String;\n-      Mapping : Maps.Character_Mapping_Function)\n-      return    Super_String\n+      Mapping : Maps.Character_Mapping_Function) return Super_String\n    is\n       Result : Super_String (Source.Max_Length);\n \n@@ -1564,8 +1667,9 @@ package body Ada.Strings.Superbounded is\n    -- Super_Trim --\n    ----------------\n \n-   function Super_Trim (Source : Super_String; Side : Trim_End)\n-                        return   Super_String\n+   function Super_Trim\n+     (Source : Super_String;\n+      Side   : Trim_End) return Super_String\n    is\n       Result : Super_String (Source.Max_Length);\n       Last   : Natural := Source.Current_Length;\n@@ -1621,8 +1725,7 @@ package body Ada.Strings.Superbounded is\n    function Super_Trim\n      (Source : Super_String;\n       Left   : Maps.Character_Set;\n-      Right  : Maps.Character_Set)\n-      return   Super_String\n+      Right  : Maps.Character_Set) return Super_String\n    is\n       Result : Super_String (Source.Max_Length);\n \n@@ -1688,8 +1791,7 @@ package body Ada.Strings.Superbounded is\n    function Times\n      (Left       : Natural;\n       Right      : Character;\n-      Max_Length : Positive)\n-      return  Super_String\n+      Max_Length : Positive) return Super_String\n    is\n       Result : Super_String (Max_Length);\n \n@@ -1711,8 +1813,7 @@ package body Ada.Strings.Superbounded is\n    function Times\n      (Left       : Natural;\n       Right      : String;\n-      Max_Length : Positive)\n-      return  Super_String\n+      Max_Length : Positive) return Super_String\n    is\n       Result : Super_String (Max_Length);\n       Pos    : Positive         := 1;\n@@ -1739,8 +1840,7 @@ package body Ada.Strings.Superbounded is\n \n    function Times\n      (Left  : Natural;\n-      Right : Super_String)\n-      return  Super_String\n+      Right : Super_String) return Super_String\n    is\n       Result : Super_String (Right.Max_Length);\n       Pos    : Positive := 1;\n@@ -1773,8 +1873,7 @@ package body Ada.Strings.Superbounded is\n    function To_Super_String\n      (Source     : String;\n       Max_Length : Natural;\n-      Drop       : Truncation := Error)\n-      return       Super_String\n+      Drop       : Truncation := Error) return Super_String\n    is\n       Result : Super_String (Max_Length);\n       Slen   : constant Natural := Source'Length;"}, {"sha": "542f821e74f68f33eb0f81438f18708c78bf6a81", "filename": "gcc/ada/a-strsup.ads", "status": "modified", "additions": 127, "deletions": 118, "changes": 245, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/82c80734715c801643075ab68c5c9a5e00da1b03/gcc%2Fada%2Fa-strsup.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/82c80734715c801643075ab68c5c9a5e00da1b03/gcc%2Fada%2Fa-strsup.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-strsup.ads?ref=82c80734715c801643075ab68c5c9a5e00da1b03", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---          Copyright (C) 2003 Free Software Foundation, Inc.               --\n+--          Copyright (C) 2003-2005 Free Software Foundation, Inc.          --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -63,8 +63,7 @@ pragma Preelaborate (Superbounded);\n    function To_Super_String\n      (Source     : String;\n       Max_Length : Natural;\n-      Drop       : Truncation := Error)\n-      return       Super_String;\n+      Drop       : Truncation := Error) return Super_String;\n    --  Note the additional parameter Max_Length, which specifies the maximum\n    --  length setting of the resulting Super_String value.\n \n@@ -73,34 +72,35 @@ pragma Preelaborate (Superbounded);\n \n    function Super_To_String (Source : Super_String) return String;\n \n+   procedure Set_Super_String\n+     (Target : out Super_String;\n+      Source : String;\n+      Drop   : Truncation := Error);\n+\n    function Super_Append\n-     (Left, Right : Super_String;\n-      Drop        : Truncation  := Error)\n-      return        Super_String;\n+     (Left  : Super_String;\n+      Right : Super_String;\n+      Drop  : Truncation  := Error) return Super_String;\n \n    function Super_Append\n      (Left  : Super_String;\n       Right : String;\n-      Drop  : Truncation := Error)\n-      return  Super_String;\n+      Drop  : Truncation := Error) return Super_String;\n \n    function Super_Append\n      (Left  : String;\n       Right : Super_String;\n-      Drop  : Truncation := Error)\n-      return  Super_String;\n+      Drop  : Truncation := Error) return Super_String;\n \n    function Super_Append\n      (Left  : Super_String;\n       Right : Character;\n-      Drop  : Truncation := Error)\n-      return  Super_String;\n+      Drop  : Truncation := Error) return Super_String;\n \n    function Super_Append\n      (Left  : Character;\n       Right : Super_String;\n-      Drop  : Truncation := Error)\n-      return  Super_String;\n+      Drop  : Truncation := Error) return Super_String;\n \n    procedure Super_Append\n      (Source   : in out Super_String;\n@@ -118,33 +118,28 @@ pragma Preelaborate (Superbounded);\n       Drop     : Truncation  := Error);\n \n    function Concat\n-     (Left, Right : Super_String)\n-      return        Super_String;\n+     (Left  : Super_String;\n+      Right : Super_String) return Super_String;\n \n    function Concat\n      (Left  : Super_String;\n-      Right : String)\n-      return  Super_String;\n+      Right : String) return Super_String;\n \n    function Concat\n      (Left  : String;\n-      Right : Super_String)\n-      return  Super_String;\n+      Right : Super_String) return Super_String;\n \n    function Concat\n      (Left  : Super_String;\n-      Right : Character)\n-      return  Super_String;\n+      Right : Character) return Super_String;\n \n    function Concat\n      (Left  : Character;\n-      Right : Super_String)\n-      return  Super_String;\n+      Right : Super_String) return Super_String;\n \n    function Super_Element\n      (Source : Super_String;\n-      Index  : Positive)\n-      return   Character;\n+      Index  : Positive) return Character;\n \n    procedure Super_Replace_Element\n      (Source : in out Super_String;\n@@ -154,70 +149,82 @@ pragma Preelaborate (Superbounded);\n    function Super_Slice\n      (Source : Super_String;\n       Low    : Positive;\n-      High   : Natural)\n-      return   String;\n+      High   : Natural) return String;\n+\n+   function Super_Slice\n+     (Source : Super_String;\n+      Low    : Positive;\n+      High   : Natural) return Super_String;\n+\n+   procedure Super_Slice\n+     (Source : Super_String;\n+      Target : out Super_String;\n+      Low    : Positive;\n+      High   : Natural);\n \n-   function \"=\"  (Left, Right : Super_String) return Boolean;\n+   function \"=\"\n+     (Left  : Super_String;\n+      Right : Super_String) return Boolean;\n \n-   function Equal (Left, Right : Super_String) return Boolean renames \"=\";\n+   function Equal\n+     (Left  : Super_String;\n+      Right : Super_String) return Boolean renames \"=\";\n \n    function Equal\n      (Left  : Super_String;\n-      Right : String)\n-      return  Boolean;\n+      Right : String) return Boolean;\n \n    function Equal\n      (Left  : String;\n-      Right : Super_String)\n-      return  Boolean;\n+      Right : Super_String) return Boolean;\n \n-   function Less (Left, Right : Super_String) return Boolean;\n+   function Less\n+     (Left  : Super_String;\n+      Right : Super_String) return Boolean;\n \n    function Less\n      (Left  : Super_String;\n-      Right : String)\n-      return  Boolean;\n+      Right : String) return Boolean;\n \n    function Less\n      (Left  : String;\n-      Right : Super_String)\n-      return  Boolean;\n+      Right : Super_String) return Boolean;\n \n-   function Less_Or_Equal (Left, Right : Super_String) return Boolean;\n+   function Less_Or_Equal\n+     (Left  : Super_String;\n+      Right : Super_String) return Boolean;\n \n    function Less_Or_Equal\n      (Left  : Super_String;\n-      Right : String)\n-      return  Boolean;\n+      Right : String) return Boolean;\n \n    function Less_Or_Equal\n      (Left  : String;\n-      Right : Super_String)\n-      return  Boolean;\n+      Right : Super_String) return Boolean;\n \n-   function Greater  (Left, Right : Super_String) return Boolean;\n+   function Greater\n+     (Left  : Super_String;\n+      Right : Super_String) return Boolean;\n \n    function Greater\n      (Left  : Super_String;\n-      Right : String)\n-      return  Boolean;\n+      Right : String) return Boolean;\n \n    function Greater\n      (Left  : String;\n-      Right : Super_String)\n-      return  Boolean;\n+      Right : Super_String) return Boolean;\n \n-   function Greater_Or_Equal (Left, Right : Super_String) return Boolean;\n+   function Greater_Or_Equal\n+     (Left  : Super_String;\n+      Right : Super_String) return Boolean;\n \n    function Greater_Or_Equal\n      (Left  : Super_String;\n-      Right : String)\n-      return  Boolean;\n+      Right : String) return Boolean;\n \n    function Greater_Or_Equal\n      (Left  : String;\n-      Right : Super_String)\n-      return  Boolean;\n+      Right : Super_String) return Boolean;\n \n    ----------------------\n    -- Search Functions --\n@@ -227,44 +234,63 @@ pragma Preelaborate (Superbounded);\n      (Source  : Super_String;\n       Pattern : String;\n       Going   : Direction := Forward;\n-      Mapping : Maps.Character_Mapping := Maps.Identity)\n-      return    Natural;\n+      Mapping : Maps.Character_Mapping := Maps.Identity) return Natural;\n \n    function Super_Index\n      (Source  : Super_String;\n       Pattern : String;\n       Going   : Direction := Forward;\n-      Mapping : Maps.Character_Mapping_Function)\n-      return    Natural;\n+      Mapping : Maps.Character_Mapping_Function) return Natural;\n \n    function Super_Index\n      (Source : Super_String;\n       Set    : Maps.Character_Set;\n       Test   : Membership := Inside;\n-      Going  : Direction  := Forward)\n-      return   Natural;\n+      Going  : Direction  := Forward) return Natural;\n+\n+   function Super_Index\n+     (Source  : Super_String;\n+      Pattern : String;\n+      From    : Positive;\n+      Going   : Direction := Forward;\n+      Mapping : Maps.Character_Mapping := Maps.Identity) return Natural;\n+\n+   function Super_Index\n+     (Source  : Super_String;\n+      Pattern : String;\n+      From    : Positive;\n+      Going   : Direction := Forward;\n+      Mapping : Maps.Character_Mapping_Function) return Natural;\n+\n+   function Super_Index\n+     (Source : Super_String;\n+      Set    : Maps.Character_Set;\n+      From   : Positive;\n+      Test   : Membership := Inside;\n+      Going  : Direction := Forward) return Natural;\n+\n+   function Super_Index_Non_Blank\n+     (Source : Super_String;\n+      Going  : Direction := Forward) return Natural;\n \n    function Super_Index_Non_Blank\n      (Source : Super_String;\n-      Going  : Direction := Forward)\n-      return   Natural;\n+      From   : Positive;\n+      Going  : Direction := Forward) return Natural;\n \n    function Super_Count\n      (Source  : Super_String;\n       Pattern : String;\n-      Mapping : Maps.Character_Mapping := Maps.Identity)\n-      return    Natural;\n+      Mapping : Maps.Character_Mapping := Maps.Identity) return Natural;\n \n    function Super_Count\n      (Source  : Super_String;\n       Pattern : String;\n-      Mapping : Maps.Character_Mapping_Function)\n-      return    Natural;\n+      Mapping : Maps.Character_Mapping_Function) return Natural;\n \n    function Super_Count\n      (Source : Super_String;\n-      Set    : Maps.Character_Set)\n-      return   Natural;\n+      Set    : Maps.Character_Set) return Natural;\n \n    procedure Super_Find_Token\n      (Source : Super_String;\n@@ -278,18 +304,16 @@ pragma Preelaborate (Superbounded);\n    ------------------------------------\n \n    function Super_Translate\n-     (Source   : Super_String;\n-      Mapping  : Maps.Character_Mapping)\n-      return     Super_String;\n+     (Source  : Super_String;\n+      Mapping : Maps.Character_Mapping) return Super_String;\n \n    procedure Super_Translate\n      (Source   : in out Super_String;\n       Mapping  : Maps.Character_Mapping);\n \n    function Super_Translate\n      (Source  : Super_String;\n-      Mapping : Maps.Character_Mapping_Function)\n-      return    Super_String;\n+      Mapping : Maps.Character_Mapping_Function) return Super_String;\n \n    procedure Super_Translate\n      (Source  : in out Super_String;\n@@ -300,26 +324,24 @@ pragma Preelaborate (Superbounded);\n    ---------------------------------------\n \n    function Super_Replace_Slice\n-     (Source   : Super_String;\n-      Low      : Positive;\n-      High     : Natural;\n-      By       : String;\n-      Drop     : Truncation := Error)\n-      return     Super_String;\n+     (Source : Super_String;\n+      Low    : Positive;\n+      High   : Natural;\n+      By     : String;\n+      Drop   : Truncation := Error) return Super_String;\n \n    procedure Super_Replace_Slice\n-     (Source   : in out Super_String;\n-      Low      : Positive;\n-      High     : Natural;\n-      By       : String;\n-      Drop     : Truncation := Error);\n+     (Source  : in out Super_String;\n+      Low     : Positive;\n+      High    : Natural;\n+      By      : String;\n+      Drop    : Truncation := Error);\n \n    function Super_Insert\n      (Source   : Super_String;\n       Before   : Positive;\n       New_Item : String;\n-      Drop     : Truncation := Error)\n-      return     Super_String;\n+      Drop     : Truncation := Error) return Super_String;\n \n    procedure Super_Insert\n      (Source   : in out Super_String;\n@@ -328,11 +350,10 @@ pragma Preelaborate (Superbounded);\n       Drop     : Truncation := Error);\n \n    function Super_Overwrite\n-     (Source    : Super_String;\n-      Position  : Positive;\n-      New_Item  : String;\n-      Drop      : Truncation := Error)\n-      return      Super_String;\n+     (Source   : Super_String;\n+      Position : Positive;\n+      New_Item : String;\n+      Drop     : Truncation := Error) return Super_String;\n \n    procedure Super_Overwrite\n      (Source    : in out Super_String;\n@@ -343,8 +364,7 @@ pragma Preelaborate (Superbounded);\n    function Super_Delete\n      (Source  : Super_String;\n       From    : Positive;\n-      Through : Natural)\n-      return    Super_String;\n+      Through : Natural) return Super_String;\n \n    procedure Super_Delete\n      (Source  : in out Super_String;\n@@ -357,18 +377,16 @@ pragma Preelaborate (Superbounded);\n \n    function Super_Trim\n      (Source : Super_String;\n-      Side   : Trim_End)\n-      return   Super_String;\n+      Side   : Trim_End) return Super_String;\n \n    procedure Super_Trim\n      (Source : in out Super_String;\n       Side   : Trim_End);\n \n    function Super_Trim\n-     (Source  : Super_String;\n+     (Source : Super_String;\n       Left   : Maps.Character_Set;\n-      Right  : Maps.Character_Set)\n-      return   Super_String;\n+      Right  : Maps.Character_Set) return Super_String;\n \n    procedure Super_Trim\n      (Source : in out Super_String;\n@@ -379,26 +397,24 @@ pragma Preelaborate (Superbounded);\n      (Source : Super_String;\n       Count  : Natural;\n       Pad    : Character := Space;\n-      Drop   : Truncation := Error)\n-      return   Super_String;\n+      Drop   : Truncation := Error) return Super_String;\n \n    procedure Super_Head\n      (Source : in out Super_String;\n       Count  : Natural;\n-      Pad    : Character  := Space;\n+      Pad    : Character := Space;\n       Drop   : Truncation := Error);\n \n    function Super_Tail\n      (Source : Super_String;\n       Count  : Natural;\n-      Pad    : Character  := Space;\n-      Drop   : Truncation := Error)\n-      return Super_String;\n+      Pad    : Character := Space;\n+      Drop   : Truncation := Error) return Super_String;\n \n    procedure Super_Tail\n      (Source : in out Super_String;\n       Count  : Natural;\n-      Pad    : Character  := Space;\n+      Pad    : Character := Space;\n       Drop   : Truncation := Error);\n \n    ------------------------------------\n@@ -412,46 +428,39 @@ pragma Preelaborate (Superbounded);\n    function Times\n      (Left       : Natural;\n       Right      : Character;\n-      Max_Length : Positive)\n-      return       Super_String;\n+      Max_Length : Positive) return Super_String;\n    --  Note the additional parameter Max_Length\n \n    function Times\n      (Left       : Natural;\n       Right      : String;\n-      Max_Length : Positive)\n-      return       Super_String;\n+      Max_Length : Positive) return Super_String;\n    --  Note the additional parameter Max_Length\n \n    function Times\n      (Left  : Natural;\n-      Right : Super_String)\n-      return  Super_String;\n+      Right : Super_String) return Super_String;\n \n    function Super_Replicate\n      (Count      : Natural;\n       Item       : Character;\n       Drop       : Truncation := Error;\n-      Max_Length : Positive)\n-      return       Super_String;\n+      Max_Length : Positive) return Super_String;\n    --  Note the additional parameter Max_Length\n \n    function Super_Replicate\n      (Count      : Natural;\n       Item       : String;\n       Drop       : Truncation := Error;\n-      Max_Length : Positive)\n-      return       Super_String;\n+      Max_Length : Positive) return Super_String;\n    --  Note the additional parameter Max_Length\n \n    function Super_Replicate\n      (Count : Natural;\n       Item  : Super_String;\n-      Drop  : Truncation := Error)\n-      return  Super_String;\n+      Drop  : Truncation := Error) return Super_String;\n \n private\n-\n       --  Pragma Inline declarations\n \n       pragma Inline (\"=\");"}, {"sha": "6ba3e567140b2f82300a92644580c2fe9e274830", "filename": "gcc/ada/a-stunau.ads", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/82c80734715c801643075ab68c5c9a5e00da1b03/gcc%2Fada%2Fa-stunau.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/82c80734715c801643075ab68c5c9a5e00da1b03/gcc%2Fada%2Fa-stunau.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-stunau.ads?ref=82c80734715c801643075ab68c5c9a5e00da1b03", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---          Copyright (C) 1992-2002, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2005, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -34,7 +34,7 @@\n --  This child package of Ada.Strings.Unbounded provides some specialized\n --  access functions which are intended to allow more efficient use of the\n --  facilities of Ada.Strings.Unbounded, particularly by other layered\n---  utilities (such as GNAT.Patterns).\n+--  utilities (such as GNAT.SPITBOL.Patterns).\n \n package Ada.Strings.Unbounded.Aux is\n pragma Preelaborate (Aux);"}, {"sha": "a53dd7a35691a18773995397a75c1e56c2c21a35", "filename": "gcc/ada/a-stwibo.adb", "status": "modified", "additions": 19, "deletions": 23, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/82c80734715c801643075ab68c5c9a5e00da1b03/gcc%2Fada%2Fa-stwibo.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/82c80734715c801643075ab68c5c9a5e00da1b03/gcc%2Fada%2Fa-stwibo.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-stwibo.adb?ref=82c80734715c801643075ab68c5c9a5e00da1b03", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1992-2003 Free Software Foundation, Inc.          --\n+--          Copyright (C) 1992-2005 Free Software Foundation, Inc.          --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -40,18 +40,16 @@ package body Ada.Strings.Wide_Bounded is\n       ---------\n \n       function \"*\"\n-        (Left  : in Natural;\n-         Right : in Wide_Character)\n-         return  Bounded_Wide_String\n+        (Left  : Natural;\n+         Right : Wide_Character) return Bounded_Wide_String\n       is\n       begin\n          return Times (Left, Right, Max_Length);\n       end \"*\";\n \n       function \"*\"\n-        (Left  : in Natural;\n-         Right : in Wide_String)\n-         return  Bounded_Wide_String\n+        (Left  : Natural;\n+         Right : Wide_String) return Bounded_Wide_String\n       is\n       begin\n          return Times (Left, Right, Max_Length);\n@@ -62,39 +60,37 @@ package body Ada.Strings.Wide_Bounded is\n       ---------------\n \n       function Replicate\n-        (Count : in Natural;\n-         Item  : in Wide_Character;\n-         Drop  : in Strings.Truncation := Strings.Error)\n-         return  Bounded_Wide_String\n+        (Count : Natural;\n+         Item  : Wide_Character;\n+         Drop  : Strings.Truncation := Strings.Error)\n+         return Bounded_Wide_String\n       is\n       begin\n          return Super_Replicate (Count, Item, Drop, Max_Length);\n       end Replicate;\n \n       function Replicate\n-        (Count : in Natural;\n-         Item  : in Wide_String;\n-         Drop  : in Strings.Truncation := Strings.Error)\n-         return  Bounded_Wide_String\n+        (Count : Natural;\n+         Item  : Wide_String;\n+         Drop  : Strings.Truncation := Strings.Error)\n+         return Bounded_Wide_String\n       is\n       begin\n          return Super_Replicate (Count, Item, Drop, Max_Length);\n       end Replicate;\n \n-\n-      -----------------------\n-      -- To_Bounded_String --\n-      -----------------------\n+      ----------------------------\n+      -- To_Bounded_Wide_String --\n+      ----------------------------\n \n       function To_Bounded_Wide_String\n-        (Source : in Wide_String;\n-         Drop   : in Strings.Truncation := Strings.Error)\n-         return   Bounded_Wide_String\n+        (Source : Wide_String;\n+         Drop   : Strings.Truncation := Strings.Error)\n+         return Bounded_Wide_String\n       is\n       begin\n          return To_Super_String (Source, Max_Length, Drop);\n       end To_Bounded_Wide_String;\n \n    end Generic_Bounded_Length;\n-\n end Ada.Strings.Wide_Bounded;"}, {"sha": "5c3bfd215b7158682c7794aeceede0cebded8049", "filename": "gcc/ada/a-stwibo.ads", "status": "modified", "additions": 529, "deletions": 486, "changes": 1015, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/82c80734715c801643075ab68c5c9a5e00da1b03/gcc%2Fada%2Fa-stwibo.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/82c80734715c801643075ab68c5c9a5e00da1b03/gcc%2Fada%2Fa-stwibo.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-stwibo.ads?ref=82c80734715c801643075ab68c5c9a5e00da1b03", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---          Copyright (C) 1992-2003 Free Software Foundation, Inc.          --\n+--          Copyright (C) 1992-2005 Free Software Foundation, Inc.          --\n --                                                                          --\n -- This specification is derived from the Ada Reference Manual for use with --\n -- GNAT. The copyright notice above, and the license provisions that follow --\n@@ -55,805 +55,848 @@ pragma Preelaborate (Wide_Bounded);\n \n       subtype Length_Range is Natural range 0 .. Max_Length;\n \n-      function Length (Source : in Bounded_Wide_String) return Length_Range;\n+      function Length (Source : Bounded_Wide_String) return Length_Range;\n \n       --------------------------------------------------------\n       -- Conversion, Concatenation, and Selection Functions --\n       --------------------------------------------------------\n \n       function To_Bounded_Wide_String\n-        (Source : in Wide_String;\n-         Drop   : in Truncation := Error)\n-         return   Bounded_Wide_String;\n+        (Source : Wide_String;\n+         Drop   : Truncation := Error) return Bounded_Wide_String;\n \n       function To_Wide_String\n-        (Source : in Bounded_Wide_String)\n-         return   Wide_String;\n+        (Source : Bounded_Wide_String) return Wide_String;\n+\n+      procedure Set_Bounded_Wide_String\n+        (Target : out Bounded_Wide_String;\n+         Source : Wide_String;\n+         Drop   : Truncation := Error);\n+      pragma Ada_05 (Set_Bounded_Wide_String);\n \n       function Append\n-        (Left, Right : in Bounded_Wide_String;\n-         Drop        : in Truncation  := Error)\n-         return        Bounded_Wide_String;\n+        (Left  : Bounded_Wide_String;\n+         Right : Bounded_Wide_String;\n+         Drop  : Truncation  := Error) return Bounded_Wide_String;\n \n       function Append\n-        (Left  : in Bounded_Wide_String;\n-         Right : in Wide_String;\n-         Drop  : in Truncation := Error)\n-         return  Bounded_Wide_String;\n+        (Left  : Bounded_Wide_String;\n+         Right : Wide_String;\n+         Drop  : Truncation := Error) return Bounded_Wide_String;\n \n       function Append\n-        (Left  : in Wide_String;\n-         Right : in Bounded_Wide_String;\n-         Drop  : in Truncation := Error)\n-         return  Bounded_Wide_String;\n+        (Left  : Wide_String;\n+         Right : Bounded_Wide_String;\n+         Drop  : Truncation := Error) return Bounded_Wide_String;\n \n       function Append\n-        (Left  : in Bounded_Wide_String;\n-         Right : in Wide_Character;\n-         Drop  : in Truncation := Error)\n-         return  Bounded_Wide_String;\n+        (Left  : Bounded_Wide_String;\n+         Right : Wide_Character;\n+         Drop  : Truncation := Error) return Bounded_Wide_String;\n \n       function Append\n-        (Left  : in Wide_Character;\n-         Right : in Bounded_Wide_String;\n-         Drop  : in Truncation := Error)\n-         return  Bounded_Wide_String;\n+        (Left  : Wide_Character;\n+         Right : Bounded_Wide_String;\n+         Drop  : Truncation := Error) return Bounded_Wide_String;\n \n       procedure Append\n         (Source   : in out Bounded_Wide_String;\n-         New_Item : in Bounded_Wide_String;\n-         Drop     : in Truncation  := Error);\n+         New_Item : Bounded_Wide_String;\n+         Drop     : Truncation  := Error);\n \n       procedure Append\n         (Source   : in out Bounded_Wide_String;\n-         New_Item : in Wide_String;\n-         Drop     : in Truncation  := Error);\n+         New_Item : Wide_String;\n+         Drop     : Truncation  := Error);\n \n       procedure Append\n         (Source   : in out Bounded_Wide_String;\n-         New_Item : in Wide_Character;\n-         Drop     : in Truncation  := Error);\n+         New_Item : Wide_Character;\n+         Drop     : Truncation  := Error);\n \n       function \"&\"\n-        (Left, Right : in Bounded_Wide_String)\n-         return        Bounded_Wide_String;\n+        (Left  : Bounded_Wide_String;\n+         Right : Bounded_Wide_String) return Bounded_Wide_String;\n \n       function \"&\"\n-        (Left  : in Bounded_Wide_String;\n-         Right : in Wide_String)\n-         return  Bounded_Wide_String;\n+        (Left  : Bounded_Wide_String;\n+         Right : Wide_String) return Bounded_Wide_String;\n \n       function \"&\"\n-        (Left  : in Wide_String;\n-         Right : in Bounded_Wide_String)\n-         return  Bounded_Wide_String;\n+        (Left  : Wide_String;\n+         Right : Bounded_Wide_String) return Bounded_Wide_String;\n \n       function \"&\"\n-        (Left  : in Bounded_Wide_String;\n-         Right : in Wide_Character)\n-         return  Bounded_Wide_String;\n+        (Left  : Bounded_Wide_String;\n+         Right : Wide_Character) return Bounded_Wide_String;\n \n       function \"&\"\n-        (Left  : in Wide_Character;\n-         Right : in Bounded_Wide_String)\n-         return  Bounded_Wide_String;\n+        (Left  : Wide_Character;\n+         Right : Bounded_Wide_String) return Bounded_Wide_String;\n \n       function Element\n-        (Source : in Bounded_Wide_String;\n-         Index  : in Positive)\n-         return   Wide_Character;\n+        (Source : Bounded_Wide_String;\n+         Index  : Positive) return Wide_Character;\n \n       procedure Replace_Element\n         (Source : in out Bounded_Wide_String;\n-         Index  : in Positive;\n-         By     : in Wide_Character);\n+         Index  : Positive;\n+         By     : Wide_Character);\n \n       function Slice\n-        (Source : in Bounded_Wide_String;\n-         Low    : in Positive;\n-         High   : in Natural)\n-         return   Wide_String;\n+        (Source : Bounded_Wide_String;\n+         Low    : Positive;\n+         High   : Natural) return Wide_String;\n+\n+      function Bounded_Slice\n+        (Source : Bounded_Wide_String;\n+         Low    : Positive;\n+         High   : Natural) return Bounded_Wide_String;\n+      pragma Ada_05 (Bounded_Slice);\n+\n+      procedure Bounded_Slice\n+        (Source : Bounded_Wide_String;\n+         Target : out Bounded_Wide_String;\n+         Low    : Positive;\n+         High   : Natural);\n+      pragma Ada_05 (Bounded_Slice);\n \n       function \"=\"\n-        (Left  : in Bounded_Wide_String;\n-         Right : in Bounded_Wide_String)\n-         return  Boolean;\n+        (Left  : Bounded_Wide_String;\n+         Right : Bounded_Wide_String) return Boolean;\n \n       function \"=\"\n-        (Left  : in Bounded_Wide_String;\n-         Right : in Wide_String)\n-         return  Boolean;\n+        (Left  : Bounded_Wide_String;\n+         Right : Wide_String) return Boolean;\n \n       function \"=\"\n-        (Left  : in Wide_String;\n-         Right : in Bounded_Wide_String)\n-         return  Boolean;\n+        (Left  : Wide_String;\n+         Right : Bounded_Wide_String) return Boolean;\n \n       function \"<\"\n-        (Left  : in Bounded_Wide_String;\n-         Right : in Bounded_Wide_String)\n-         return  Boolean;\n+        (Left  : Bounded_Wide_String;\n+         Right : Bounded_Wide_String) return Boolean;\n \n       function \"<\"\n-        (Left  : in Bounded_Wide_String;\n-         Right : in Wide_String)\n-         return  Boolean;\n+        (Left  : Bounded_Wide_String;\n+         Right : Wide_String) return Boolean;\n \n       function \"<\"\n-        (Left  : in Wide_String;\n-         Right : in Bounded_Wide_String)\n-         return  Boolean;\n+        (Left  : Wide_String;\n+         Right : Bounded_Wide_String) return Boolean;\n \n       function \"<=\"\n-        (Left  : in Bounded_Wide_String;\n-         Right : in Bounded_Wide_String)\n-         return  Boolean;\n+        (Left  : Bounded_Wide_String;\n+         Right : Bounded_Wide_String) return Boolean;\n \n       function \"<=\"\n-        (Left  : in Bounded_Wide_String;\n-         Right : in Wide_String)\n-         return  Boolean;\n+        (Left  : Bounded_Wide_String;\n+         Right : Wide_String) return Boolean;\n \n       function \"<=\"\n-        (Left  : in Wide_String;\n-         Right : in Bounded_Wide_String)\n-         return  Boolean;\n+        (Left  : Wide_String;\n+         Right : Bounded_Wide_String) return Boolean;\n \n       function \">\"\n-        (Left  : in Bounded_Wide_String;\n-         Right : in Bounded_Wide_String)\n-         return  Boolean;\n+        (Left  : Bounded_Wide_String;\n+         Right : Bounded_Wide_String) return Boolean;\n \n       function \">\"\n-        (Left  : in Bounded_Wide_String;\n-         Right : in Wide_String)\n-         return  Boolean;\n+        (Left  : Bounded_Wide_String;\n+         Right : Wide_String) return Boolean;\n \n       function \">\"\n-        (Left  : in Wide_String;\n-         Right : in Bounded_Wide_String)\n-         return  Boolean;\n+        (Left  : Wide_String;\n+         Right : Bounded_Wide_String) return Boolean;\n \n       function \">=\"\n-        (Left  : in Bounded_Wide_String;\n-         Right : in Bounded_Wide_String)\n-         return  Boolean;\n+        (Left  : Bounded_Wide_String;\n+         Right : Bounded_Wide_String) return Boolean;\n \n       function \">=\"\n-        (Left  : in Bounded_Wide_String;\n-         Right : in Wide_String)\n-         return  Boolean;\n+        (Left  : Bounded_Wide_String;\n+         Right : Wide_String) return Boolean;\n \n       function \">=\"\n-        (Left  : in Wide_String;\n-         Right : in Bounded_Wide_String)\n-         return  Boolean;\n+        (Left  : Wide_String;\n+         Right : Bounded_Wide_String) return Boolean;\n \n       ----------------------\n       -- Search Functions --\n       ----------------------\n \n       function Index\n-        (Source  : in Bounded_Wide_String;\n-         Pattern : in Wide_String;\n-         Going   : in Direction := Forward;\n-         Mapping : in Wide_Maps.Wide_Character_Mapping := Wide_Maps.Identity)\n-         return    Natural;\n+        (Source  : Bounded_Wide_String;\n+         Pattern : Wide_String;\n+         Going   : Direction := Forward;\n+         Mapping : Wide_Maps.Wide_Character_Mapping := Wide_Maps.Identity)\n+         return Natural;\n+\n+      function Index\n+        (Source  : Bounded_Wide_String;\n+         Pattern : Wide_String;\n+         Going   : Direction := Forward;\n+         Mapping : Wide_Maps.Wide_Character_Mapping_Function) return Natural;\n+\n+      function Index\n+        (Source : Bounded_Wide_String;\n+         Set    : Wide_Maps.Wide_Character_Set;\n+         Test   : Membership := Inside;\n+         Going  : Direction  := Forward) return Natural;\n+\n+      function Index\n+        (Source  : Bounded_Wide_String;\n+         Pattern : Wide_String;\n+         From    : Positive;\n+         Going   : Direction := Forward;\n+         Mapping : Wide_Maps.Wide_Character_Mapping := Wide_Maps.Identity)\n+         return Natural;\n+      pragma Ada_05 (Index);\n \n       function Index\n-        (Source  : in Bounded_Wide_String;\n-         Pattern : in Wide_String;\n-         Going   : in Direction := Forward;\n-         Mapping : in Wide_Maps.Wide_Character_Mapping_Function)\n-         return    Natural;\n+        (Source  : Bounded_Wide_String;\n+         Pattern : Wide_String;\n+         From    : Positive;\n+         Going   : Direction := Forward;\n+         Mapping : Wide_Maps.Wide_Character_Mapping_Function) return Natural;\n+      pragma Ada_05 (Index);\n \n       function Index\n-        (Source : in Bounded_Wide_String;\n-         Set    : in Wide_Maps.Wide_Character_Set;\n-         Test   : in Membership := Inside;\n-         Going  : in Direction  := Forward)\n-         return   Natural;\n+        (Source  : Bounded_Wide_String;\n+         Set     : Wide_Maps.Wide_Character_Set;\n+         From    : Positive;\n+         Test    : Membership := Inside;\n+         Going   : Direction := Forward) return Natural;\n+      pragma Ada_05 (Index);\n+\n+      function Index_Non_Blank\n+        (Source : Bounded_Wide_String;\n+         Going  : Direction := Forward) return Natural;\n \n       function Index_Non_Blank\n-        (Source : in Bounded_Wide_String;\n-         Going  : in Direction := Forward)\n-         return   Natural;\n+        (Source : Bounded_Wide_String;\n+         From   : Positive;\n+         Going  : Direction := Forward) return Natural;\n+      pragma Ada_05 (Index_Non_Blank);\n \n       function Count\n-        (Source  : in Bounded_Wide_String;\n-         Pattern : in Wide_String;\n-         Mapping : in Wide_Maps.Wide_Character_Mapping := Wide_Maps.Identity)\n-         return    Natural;\n+        (Source  : Bounded_Wide_String;\n+         Pattern : Wide_String;\n+         Mapping : Wide_Maps.Wide_Character_Mapping := Wide_Maps.Identity)\n+         return Natural;\n \n       function Count\n-        (Source  : in Bounded_Wide_String;\n-         Pattern : in Wide_String;\n-         Mapping : in Wide_Maps.Wide_Character_Mapping_Function)\n-         return    Natural;\n+        (Source  : Bounded_Wide_String;\n+         Pattern : Wide_String;\n+         Mapping : Wide_Maps.Wide_Character_Mapping_Function) return Natural;\n \n       function Count\n-        (Source : in Bounded_Wide_String;\n-         Set    : in Wide_Maps.Wide_Character_Set)\n-         return   Natural;\n+        (Source : Bounded_Wide_String;\n+         Set    : Wide_Maps.Wide_Character_Set) return Natural;\n \n       procedure Find_Token\n-        (Source : in Bounded_Wide_String;\n-         Set    : in Wide_Maps.Wide_Character_Set;\n-         Test   : in Membership;\n+        (Source : Bounded_Wide_String;\n+         Set    : Wide_Maps.Wide_Character_Set;\n+         Test   : Membership;\n          First  : out Positive;\n          Last   : out Natural);\n \n       ------------------------------------\n-      -- Wide_String Translation Subprograms --\n+      -- String Translation Subprograms --\n       ------------------------------------\n \n       function Translate\n-        (Source   : in Bounded_Wide_String;\n-         Mapping  : in Wide_Maps.Wide_Character_Mapping)\n-         return     Bounded_Wide_String;\n+        (Source  : Bounded_Wide_String;\n+         Mapping : Wide_Maps.Wide_Character_Mapping)\n+         return Bounded_Wide_String;\n \n       procedure Translate\n-        (Source   : in out Bounded_Wide_String;\n-         Mapping  : in Wide_Maps.Wide_Character_Mapping);\n+        (Source  : in out Bounded_Wide_String;\n+         Mapping : Wide_Maps.Wide_Character_Mapping);\n \n       function Translate\n-        (Source  : in Bounded_Wide_String;\n-         Mapping : in Wide_Maps.Wide_Character_Mapping_Function)\n-         return    Bounded_Wide_String;\n+        (Source  : Bounded_Wide_String;\n+         Mapping : Wide_Maps.Wide_Character_Mapping_Function)\n+         return Bounded_Wide_String;\n \n       procedure Translate\n         (Source  : in out Bounded_Wide_String;\n-         Mapping : in Wide_Maps.Wide_Character_Mapping_Function);\n+         Mapping : Wide_Maps.Wide_Character_Mapping_Function);\n \n       ---------------------------------------\n-      -- Wide_String Transformation Subprograms --\n+      -- String Transformation Subprograms --\n       ---------------------------------------\n \n       function Replace_Slice\n-        (Source   : in Bounded_Wide_String;\n-         Low      : in Positive;\n-         High     : in Natural;\n-         By       : in Wide_String;\n-         Drop     : in Truncation := Error)\n-         return     Bounded_Wide_String;\n+        (Source : Bounded_Wide_String;\n+         Low    : Positive;\n+         High   : Natural;\n+         By     : Wide_String;\n+         Drop   : Truncation := Error) return Bounded_Wide_String;\n \n       procedure Replace_Slice\n         (Source   : in out Bounded_Wide_String;\n-         Low      : in Positive;\n-         High     : in Natural;\n-         By       : in Wide_String;\n-         Drop     : in Truncation := Error);\n+         Low      : Positive;\n+         High     : Natural;\n+         By       : Wide_String;\n+         Drop     : Truncation := Error);\n \n       function Insert\n-        (Source   : in Bounded_Wide_String;\n-         Before   : in Positive;\n-         New_Item : in Wide_String;\n-         Drop     : in Truncation := Error)\n-         return     Bounded_Wide_String;\n+        (Source   : Bounded_Wide_String;\n+         Before   : Positive;\n+         New_Item : Wide_String;\n+         Drop     : Truncation := Error) return Bounded_Wide_String;\n \n       procedure Insert\n         (Source   : in out Bounded_Wide_String;\n-         Before   : in Positive;\n-         New_Item : in Wide_String;\n-         Drop     : in Truncation := Error);\n+         Before   : Positive;\n+         New_Item : Wide_String;\n+         Drop     : Truncation := Error);\n \n       function Overwrite\n-        (Source    : in Bounded_Wide_String;\n-         Position  : in Positive;\n-         New_Item  : in Wide_String;\n-         Drop      : in Truncation := Error)\n-         return      Bounded_Wide_String;\n+        (Source   : Bounded_Wide_String;\n+         Position : Positive;\n+         New_Item : Wide_String;\n+         Drop     : Truncation := Error) return Bounded_Wide_String;\n \n       procedure Overwrite\n         (Source    : in out Bounded_Wide_String;\n-         Position  : in Positive;\n-         New_Item  : in Wide_String;\n-         Drop      : in Truncation := Error);\n+         Position  : Positive;\n+         New_Item  : Wide_String;\n+         Drop      : Truncation := Error);\n \n       function Delete\n-        (Source  : in Bounded_Wide_String;\n-         From    : in Positive;\n-         Through : in Natural)\n-         return    Bounded_Wide_String;\n+        (Source  : Bounded_Wide_String;\n+         From    : Positive;\n+         Through : Natural) return Bounded_Wide_String;\n \n       procedure Delete\n         (Source  : in out Bounded_Wide_String;\n-         From    : in Positive;\n-         Through : in Natural);\n+         From    : Positive;\n+         Through : Natural);\n \n       ---------------------------------\n-      -- Wide_String Selector Subprograms --\n+      -- String Selector Subprograms --\n       ---------------------------------\n \n       function Trim\n-        (Source : in Bounded_Wide_String;\n-         Side   : in Trim_End)\n-         return   Bounded_Wide_String;\n+        (Source : Bounded_Wide_String;\n+         Side   : Trim_End) return Bounded_Wide_String;\n \n       procedure Trim\n         (Source : in out Bounded_Wide_String;\n-         Side   : in Trim_End);\n+         Side   : Trim_End);\n \n       function Trim\n-        (Source  : in Bounded_Wide_String;\n-          Left   : in Wide_Maps.Wide_Character_Set;\n-          Right  : in Wide_Maps.Wide_Character_Set)\n-          return   Bounded_Wide_String;\n+        (Source : Bounded_Wide_String;\n+          Left  : Wide_Maps.Wide_Character_Set;\n+          Right : Wide_Maps.Wide_Character_Set) return Bounded_Wide_String;\n \n       procedure Trim\n         (Source : in out Bounded_Wide_String;\n-         Left   : in Wide_Maps.Wide_Character_Set;\n-         Right  : in Wide_Maps.Wide_Character_Set);\n+         Left   : Wide_Maps.Wide_Character_Set;\n+         Right  : Wide_Maps.Wide_Character_Set);\n \n       function Head\n-        (Source : in Bounded_Wide_String;\n-         Count  : in Natural;\n-         Pad    : in Wide_Character := Wide_Space;\n-         Drop   : in Truncation := Error)\n-         return   Bounded_Wide_String;\n+        (Source : Bounded_Wide_String;\n+         Count  : Natural;\n+         Pad    : Wide_Character := Wide_Space;\n+         Drop   : Truncation := Error) return Bounded_Wide_String;\n \n       procedure Head\n         (Source : in out Bounded_Wide_String;\n-         Count  : in Natural;\n-         Pad    : in Wide_Character  := Wide_Space;\n-         Drop   : in Truncation := Error);\n+         Count  : Natural;\n+         Pad    : Wide_Character  := Wide_Space;\n+         Drop   : Truncation := Error);\n \n       function Tail\n-        (Source : in Bounded_Wide_String;\n-         Count  : in Natural;\n-         Pad    : in Wide_Character  := Wide_Space;\n-         Drop   : in Truncation := Error)\n-         return Bounded_Wide_String;\n+        (Source : Bounded_Wide_String;\n+         Count  : Natural;\n+         Pad    : Wide_Character := Wide_Space;\n+         Drop   : Truncation     := Error) return Bounded_Wide_String;\n \n       procedure Tail\n         (Source : in out Bounded_Wide_String;\n-         Count  : in Natural;\n-         Pad    : in Wide_Character  := Wide_Space;\n-         Drop   : in Truncation := Error);\n+         Count  : Natural;\n+         Pad    : Wide_Character := Wide_Space;\n+         Drop   : Truncation     := Error);\n \n       ------------------------------------\n-      -- Wide_String Constructor Subprograms --\n+      -- String Constructor Subprograms --\n       ------------------------------------\n \n       function \"*\"\n-        (Left  : in Natural;\n-         Right : in Wide_Character)\n-         return  Bounded_Wide_String;\n+        (Left  : Natural;\n+         Right : Wide_Character) return Bounded_Wide_String;\n \n       function \"*\"\n-        (Left  : in Natural;\n-         Right : in Wide_String)\n-         return  Bounded_Wide_String;\n+        (Left  : Natural;\n+         Right : Wide_String) return Bounded_Wide_String;\n \n       function \"*\"\n-        (Left  : in Natural;\n-         Right : in Bounded_Wide_String)\n-         return  Bounded_Wide_String;\n+        (Left  : Natural;\n+         Right : Bounded_Wide_String) return Bounded_Wide_String;\n \n       function Replicate\n-        (Count : in Natural;\n-         Item  : in Wide_Character;\n-         Drop  : in Truncation := Error)\n-         return  Bounded_Wide_String;\n+        (Count : Natural;\n+         Item  : Wide_Character;\n+         Drop  : Truncation := Error) return Bounded_Wide_String;\n \n       function Replicate\n-        (Count : in Natural;\n-         Item  : in Wide_String;\n-         Drop  : in Truncation := Error)\n-         return  Bounded_Wide_String;\n+        (Count : Natural;\n+         Item  : Wide_String;\n+         Drop  : Truncation := Error) return Bounded_Wide_String;\n \n       function Replicate\n-        (Count : in Natural;\n-         Item  : in Bounded_Wide_String;\n-         Drop  : in Truncation := Error)\n-         return  Bounded_Wide_String;\n+        (Count : Natural;\n+         Item  : Bounded_Wide_String;\n+         Drop  : Truncation := Error) return Bounded_Wide_String;\n \n    private\n-\n-      --  Most of the implementation is in the non generic package\n-      --  Ada.Strings.Superbounded. Type Bounded_Wide_String is derived from\n-      --  type Wide_Superbounded.Super_String with the maximum length\n-      --  constraint. Except for five, all subprograms are renames of\n-      --  subprograms that are inherited from Wide_Superbounded.Super_String.\n+      --  Most of the implementation is in the separate non generic package\n+      --  Ada.Strings.Wide_Superbounded. Type Bounded_Wide_String is derived\n+      --  from type Wide_Superbounded.Super_String with the maximum length\n+      --  constraint. In almost all cases, the routines in Wide_Superbounded\n+      --  can be called with no requirement to pass the maximum length\n+      --  explicitly, since there is at least one Bounded_Wide_String argument\n+      --  from which the maximum length can be obtained. For all such\n+      --  routines, the implementation in this private part is simply a\n+      --  renaming of the corresponding routine in the super bouded package.\n+\n+      --  The five exceptions are the * and Replicate routines operating on\n+      --  character values. For these cases, we have a routine in the body\n+      --  that calls the superbounded routine passing the maximum length\n+      --  explicitly as an extra parameter.\n \n       type Bounded_Wide_String is\n         new Wide_Superbounded.Super_String (Max_Length);\n+      --  Deriving Bounded_Wide_String from Wide_Superbounded.Super_String is\n+      --  the real trick, it ensures that the type Bounded_Wide_String\n+      --  declared in the generic instantiation is compatible with the\n+      --  Super_String type declared in the Wide_Superbounded package.\n \n       Null_Bounded_Wide_String : constant Bounded_Wide_String :=\n-        (Max_Length     => Max_Length,\n-         Current_Length => 0,\n-         Data           => (1 .. Max_Length => Wide_Superbounded.Wide_NUL));\n+                                   (Max_Length         => Max_Length,\n+                                    Current_Length     => 0,\n+                                    Data               =>\n+                                      (1 .. Max_Length =>\n+                                         Wide_Superbounded.Wide_NUL));\n \n       pragma Inline (To_Bounded_Wide_String);\n \n-      function Length (Source : in Bounded_Wide_String) return Length_Range\n-        renames Super_Length;\n+      procedure Set_Bounded_Wide_String\n+        (Target : out Bounded_Wide_String;\n+         Source : Wide_String;\n+         Drop   : Truncation := Error)\n+         renames Set_Super_String;\n+\n+      function Length\n+        (Source : Bounded_Wide_String) return Length_Range\n+         renames Super_Length;\n \n       function To_Wide_String\n-        (Source : in Bounded_Wide_String)\n-         return    Wide_String\n-        renames Super_To_String;\n+        (Source : Bounded_Wide_String) return Wide_String\n+         renames Super_To_String;\n \n       function Append\n-        (Left, Right : in Bounded_Wide_String;\n-         Drop        : in Truncation  := Error)\n-         return        Bounded_Wide_String\n-        renames Super_Append;\n+        (Left  : Bounded_Wide_String;\n+         Right : Bounded_Wide_String;\n+         Drop  : Truncation  := Error) return Bounded_Wide_String\n+         renames Super_Append;\n \n       function Append\n-        (Left  : in Bounded_Wide_String;\n-         Right : in Wide_String;\n-         Drop  : in Truncation := Error)\n-         return  Bounded_Wide_String\n-        renames Super_Append;\n+        (Left  : Bounded_Wide_String;\n+         Right : Wide_String;\n+         Drop  : Truncation := Error) return Bounded_Wide_String\n+         renames Super_Append;\n \n       function Append\n-        (Left  : in Wide_String;\n-         Right : in Bounded_Wide_String;\n-         Drop  : in Truncation := Error)\n-         return  Bounded_Wide_String\n-        renames Super_Append;\n+        (Left  : Wide_String;\n+         Right : Bounded_Wide_String;\n+         Drop  : Truncation := Error) return Bounded_Wide_String\n+         renames Super_Append;\n \n       function Append\n-        (Left  : in Bounded_Wide_String;\n-         Right : in Wide_Character;\n-         Drop  : in Truncation := Error)\n-         return  Bounded_Wide_String\n-        renames Super_Append;\n+        (Left  : Bounded_Wide_String;\n+         Right : Wide_Character;\n+         Drop  : Truncation := Error) return Bounded_Wide_String\n+         renames Super_Append;\n \n       function Append\n-        (Left  : in Wide_Character;\n-         Right : in Bounded_Wide_String;\n-         Drop  : in Truncation := Error)\n-         return  Bounded_Wide_String\n-        renames Super_Append;\n+        (Left  : Wide_Character;\n+         Right : Bounded_Wide_String;\n+         Drop  : Truncation := Error) return Bounded_Wide_String\n+         renames Super_Append;\n \n       procedure Append\n         (Source   : in out Bounded_Wide_String;\n-         New_Item : in Bounded_Wide_String;\n-         Drop     : in Truncation  := Error)\n-        renames Super_Append;\n+         New_Item : Bounded_Wide_String;\n+         Drop     : Truncation  := Error)\n+         renames Super_Append;\n \n       procedure Append\n         (Source   : in out Bounded_Wide_String;\n-         New_Item : in Wide_String;\n-         Drop     : in Truncation  := Error)\n-        renames Super_Append;\n+         New_Item : Wide_String;\n+         Drop     : Truncation  := Error)\n+         renames Super_Append;\n \n       procedure Append\n         (Source   : in out Bounded_Wide_String;\n-         New_Item : in Wide_Character;\n-         Drop     : in Truncation  := Error)\n-        renames Super_Append;\n+         New_Item : Wide_Character;\n+         Drop     : Truncation  := Error)\n+         renames Super_Append;\n \n       function \"&\"\n-        (Left, Right : in Bounded_Wide_String)\n-         return        Bounded_Wide_String\n-        renames Concat;\n+        (Left  : Bounded_Wide_String;\n+         Right : Bounded_Wide_String) return Bounded_Wide_String\n+         renames Concat;\n \n       function \"&\"\n-        (Left  : in Bounded_Wide_String;\n-         Right : in Wide_String)\n-         return  Bounded_Wide_String\n-        renames Concat;\n+        (Left  : Bounded_Wide_String;\n+         Right : Wide_String) return Bounded_Wide_String\n+         renames Concat;\n \n       function \"&\"\n-        (Left  : in Wide_String;\n-         Right : in Bounded_Wide_String)\n-         return  Bounded_Wide_String\n-        renames Concat;\n+        (Left  : Wide_String;\n+         Right : Bounded_Wide_String) return Bounded_Wide_String\n+         renames Concat;\n \n       function \"&\"\n-        (Left  : in Bounded_Wide_String;\n-         Right : in Wide_Character)\n-         return  Bounded_Wide_String\n-        renames Concat;\n+        (Left  : Bounded_Wide_String;\n+         Right : Wide_Character) return Bounded_Wide_String\n+         renames Concat;\n \n       function \"&\"\n-        (Left  : in Wide_Character;\n-         Right : in Bounded_Wide_String)\n-         return  Bounded_Wide_String\n-        renames Concat;\n+        (Left  : Wide_Character;\n+         Right : Bounded_Wide_String) return Bounded_Wide_String\n+         renames Concat;\n \n       function Element\n-        (Source : in Bounded_Wide_String;\n-         Index  : in Positive)\n-         return   Wide_Character\n-        renames Super_Element;\n+        (Source : Bounded_Wide_String;\n+         Index  : Positive) return Wide_Character\n+         renames Super_Element;\n \n       procedure Replace_Element\n         (Source : in out Bounded_Wide_String;\n-         Index  : in Positive;\n-         By     : in Wide_Character)\n-        renames Super_Replace_Element;\n+         Index  : Positive;\n+         By     : Wide_Character)\n+         renames Super_Replace_Element;\n \n       function Slice\n-        (Source : in Bounded_Wide_String;\n-         Low    : in Positive;\n-         High   : in Natural)\n-         return   Wide_String\n-        renames Super_Slice;\n+        (Source : Bounded_Wide_String;\n+         Low    : Positive;\n+         High   : Natural) return Wide_String\n+         renames Super_Slice;\n+\n+      function Bounded_Slice\n+        (Source : Bounded_Wide_String;\n+         Low    : Positive;\n+         High   : Natural) return Bounded_Wide_String\n+         renames Super_Slice;\n+\n+      procedure Bounded_Slice\n+        (Source : Bounded_Wide_String;\n+         Target : out Bounded_Wide_String;\n+         Low    : Positive;\n+         High   : Natural)\n+         renames Super_Slice;\n \n-      function \"=\"  (Left, Right : in Bounded_Wide_String) return Boolean\n-        renames Equal;\n+      function \"=\"\n+        (Left  : Bounded_Wide_String;\n+         Right : Bounded_Wide_String) return Boolean\n+         renames Equal;\n \n       function \"=\"\n-        (Left  : in Bounded_Wide_String;\n-         Right : in Wide_String)\n-         return  Boolean\n-        renames Equal;\n+        (Left  : Bounded_Wide_String;\n+         Right : Wide_String) return Boolean\n+         renames Equal;\n \n       function \"=\"\n-        (Left  : in Wide_String;\n-         Right : in Bounded_Wide_String)\n-         return  Boolean\n-        renames Equal;\n+        (Left  : Wide_String;\n+         Right : Bounded_Wide_String) return Boolean\n+         renames Equal;\n \n-      function \"<\"  (Left, Right : in Bounded_Wide_String) return Boolean\n-        renames Less;\n+      function \"<\"\n+        (Left  : Bounded_Wide_String;\n+         Right : Bounded_Wide_String) return Boolean\n+         renames Less;\n \n       function \"<\"\n-        (Left  : in Bounded_Wide_String;\n-         Right : in Wide_String)\n-         return  Boolean\n-        renames Less;\n+        (Left  : Bounded_Wide_String;\n+         Right : Wide_String) return Boolean\n+         renames Less;\n \n       function \"<\"\n-        (Left  : in Wide_String;\n-         Right : in Bounded_Wide_String)\n-         return  Boolean\n-        renames Less;\n+        (Left  : Wide_String;\n+         Right : Bounded_Wide_String) return Boolean\n+         renames Less;\n \n-      function \"<=\" (Left, Right : in Bounded_Wide_String) return Boolean\n-        renames Less_Or_Equal;\n+      function \"<=\"\n+        (Left  : Bounded_Wide_String;\n+         Right : Bounded_Wide_String) return Boolean\n+         renames Less_Or_Equal;\n \n       function \"<=\"\n-        (Left  : in Bounded_Wide_String;\n-         Right : in Wide_String)\n-         return  Boolean\n-        renames Less_Or_Equal;\n+        (Left  : Bounded_Wide_String;\n+         Right : Wide_String) return Boolean\n+         renames Less_Or_Equal;\n \n       function \"<=\"\n-        (Left  : in Wide_String;\n-         Right : in Bounded_Wide_String)\n-         return  Boolean\n-        renames Less_Or_Equal;\n+        (Left  : Wide_String;\n+         Right : Bounded_Wide_String) return Boolean\n+         renames Less_Or_Equal;\n \n-      function \">\"  (Left, Right : in Bounded_Wide_String) return Boolean\n-        renames Greater;\n+      function \">\"\n+        (Left  : Bounded_Wide_String;\n+         Right : Bounded_Wide_String) return Boolean\n+         renames Greater;\n \n       function \">\"\n-        (Left  : in Bounded_Wide_String;\n-         Right : in Wide_String)\n-         return  Boolean\n-        renames Greater;\n+        (Left  : Bounded_Wide_String;\n+         Right : Wide_String) return Boolean\n+         renames Greater;\n \n       function \">\"\n-        (Left  : in Wide_String;\n-         Right : in Bounded_Wide_String)\n-         return  Boolean\n-        renames Greater;\n+        (Left  : Wide_String;\n+         Right : Bounded_Wide_String) return Boolean\n+         renames Greater;\n \n-      function \">=\" (Left, Right : in Bounded_Wide_String) return Boolean\n-        renames Greater_Or_Equal;\n+      function \">=\"\n+        (Left  : Bounded_Wide_String;\n+         Right : Bounded_Wide_String) return Boolean\n+         renames Greater_Or_Equal;\n \n       function \">=\"\n-        (Left  : in Bounded_Wide_String;\n-         Right : in Wide_String)\n-         return  Boolean\n-        renames Greater_Or_Equal;\n+        (Left  : Bounded_Wide_String;\n+         Right : Wide_String) return Boolean\n+         renames Greater_Or_Equal;\n \n       function \">=\"\n-        (Left  : in Wide_String;\n-         Right : in Bounded_Wide_String)\n-         return  Boolean\n-        renames Greater_Or_Equal;\n+        (Left  : Wide_String;\n+         Right : Bounded_Wide_String) return Boolean\n+         renames Greater_Or_Equal;\n+\n+      function Index\n+        (Source  : Bounded_Wide_String;\n+         Pattern : Wide_String;\n+         Going   : Direction := Forward;\n+         Mapping : Wide_Maps.Wide_Character_Mapping := Wide_Maps.Identity)\n+         return Natural\n+         renames Super_Index;\n+\n+      function Index\n+        (Source  : Bounded_Wide_String;\n+         Pattern : Wide_String;\n+         Going   : Direction := Forward;\n+         Mapping : Wide_Maps.Wide_Character_Mapping_Function) return Natural\n+         renames Super_Index;\n+\n+      function Index\n+        (Source : Bounded_Wide_String;\n+         Set    : Wide_Maps.Wide_Character_Set;\n+         Test   : Membership := Inside;\n+         Going  : Direction  := Forward) return Natural\n+         renames Super_Index;\n \n       function Index\n-        (Source  : in Bounded_Wide_String;\n-         Pattern : in Wide_String;\n-         Going   : in Direction := Forward;\n-         Mapping : in Wide_Maps.Wide_Character_Mapping := Wide_Maps.Identity)\n-         return    Natural\n-        renames Super_Index;\n+        (Source  : Bounded_Wide_String;\n+         Pattern : Wide_String;\n+         From    : Positive;\n+         Going   : Direction := Forward;\n+         Mapping : Wide_Maps.Wide_Character_Mapping := Wide_Maps.Identity)\n+         return Natural\n+         renames Super_Index;\n \n       function Index\n-        (Source  : in Bounded_Wide_String;\n-         Pattern : in Wide_String;\n-         Going   : in Direction := Forward;\n-         Mapping : in Wide_Maps.Wide_Character_Mapping_Function)\n-         return    Natural\n-        renames Super_Index;\n+        (Source  : Bounded_Wide_String;\n+         Pattern : Wide_String;\n+         From    : Positive;\n+         Going   : Direction := Forward;\n+         Mapping : Wide_Maps.Wide_Character_Mapping_Function) return Natural\n+      renames Super_Index;\n \n       function Index\n-        (Source : in Bounded_Wide_String;\n-         Set    : in Wide_Maps.Wide_Character_Set;\n-         Test   : in Membership := Inside;\n-         Going  : in Direction  := Forward)\n-         return   Natural\n-        renames Super_Index;\n+        (Source  : Bounded_Wide_String;\n+         Set     : Wide_Maps.Wide_Character_Set;\n+         From    : Positive;\n+         Test    : Membership := Inside;\n+         Going   : Direction := Forward) return Natural\n+      renames Super_Index;\n+\n+      function Index_Non_Blank\n+        (Source : Bounded_Wide_String;\n+         Going  : Direction := Forward) return Natural\n+         renames Super_Index_Non_Blank;\n \n       function Index_Non_Blank\n-        (Source : in Bounded_Wide_String;\n-         Going  : in Direction := Forward)\n-         return   Natural\n-        renames Super_Index_Non_Blank;\n+        (Source : Bounded_Wide_String;\n+         From   : Positive;\n+         Going  : Direction := Forward) return Natural\n+         renames Super_Index_Non_Blank;\n \n       function Count\n-        (Source  : in Bounded_Wide_String;\n-         Pattern : in Wide_String;\n-         Mapping : in Wide_Maps.Wide_Character_Mapping := Wide_Maps.Identity)\n-         return    Natural\n-        renames Super_Count;\n+        (Source  : Bounded_Wide_String;\n+         Pattern : Wide_String;\n+         Mapping : Wide_Maps.Wide_Character_Mapping := Wide_Maps.Identity)\n+         return Natural\n+         renames Super_Count;\n \n       function Count\n-        (Source  : in Bounded_Wide_String;\n-         Pattern : in Wide_String;\n-         Mapping : in Wide_Maps.Wide_Character_Mapping_Function)\n-         return    Natural\n-        renames Super_Count;\n+        (Source  : Bounded_Wide_String;\n+         Pattern : Wide_String;\n+         Mapping : Wide_Maps.Wide_Character_Mapping_Function) return Natural\n+         renames Super_Count;\n \n       function Count\n-        (Source : in Bounded_Wide_String;\n-         Set    : in Wide_Maps.Wide_Character_Set)\n-         return   Natural\n-        renames Super_Count;\n+        (Source : Bounded_Wide_String;\n+         Set    : Wide_Maps.Wide_Character_Set) return Natural\n+         renames Super_Count;\n \n       procedure Find_Token\n-        (Source : in Bounded_Wide_String;\n-         Set    : in Wide_Maps.Wide_Character_Set;\n-         Test   : in Membership;\n+        (Source : Bounded_Wide_String;\n+         Set    : Wide_Maps.Wide_Character_Set;\n+         Test   : Membership;\n          First  : out Positive;\n          Last   : out Natural)\n-        renames Super_Find_Token;\n+         renames Super_Find_Token;\n \n       function Translate\n-        (Source   : in Bounded_Wide_String;\n-         Mapping  : in Wide_Maps.Wide_Character_Mapping)\n-         return     Bounded_Wide_String\n-        renames Super_Translate;\n+        (Source  : Bounded_Wide_String;\n+         Mapping : Wide_Maps.Wide_Character_Mapping)\n+         return Bounded_Wide_String\n+         renames Super_Translate;\n \n       procedure Translate\n         (Source   : in out Bounded_Wide_String;\n-         Mapping  : in Wide_Maps.Wide_Character_Mapping)\n-        renames Super_Translate;\n+         Mapping  : Wide_Maps.Wide_Character_Mapping)\n+         renames Super_Translate;\n \n       function Translate\n-        (Source  : in Bounded_Wide_String;\n-         Mapping : in Wide_Maps.Wide_Character_Mapping_Function)\n-         return    Bounded_Wide_String\n-        renames Super_Translate;\n+        (Source  : Bounded_Wide_String;\n+         Mapping : Wide_Maps.Wide_Character_Mapping_Function)\n+         return Bounded_Wide_String\n+         renames Super_Translate;\n \n       procedure Translate\n         (Source  : in out Bounded_Wide_String;\n-         Mapping : in Wide_Maps.Wide_Character_Mapping_Function)\n-        renames Super_Translate;\n+         Mapping : Wide_Maps.Wide_Character_Mapping_Function)\n+         renames Super_Translate;\n \n       function Replace_Slice\n-        (Source   : in Bounded_Wide_String;\n-         Low      : in Positive;\n-         High     : in Natural;\n-         By       : in Wide_String;\n-         Drop     : in Truncation := Error)\n-         return     Bounded_Wide_String\n-        renames Super_Replace_Slice;\n+        (Source : Bounded_Wide_String;\n+         Low    : Positive;\n+         High   : Natural;\n+         By     : Wide_String;\n+         Drop   : Truncation := Error) return Bounded_Wide_String\n+         renames Super_Replace_Slice;\n \n       procedure Replace_Slice\n         (Source   : in out Bounded_Wide_String;\n-         Low      : in Positive;\n-         High     : in Natural;\n-         By       : in Wide_String;\n-         Drop     : in Truncation := Error)\n-        renames Super_Replace_Slice;\n+         Low      : Positive;\n+         High     : Natural;\n+         By       : Wide_String;\n+         Drop     : Truncation := Error)\n+         renames Super_Replace_Slice;\n \n       function Insert\n-        (Source   : in Bounded_Wide_String;\n-         Before   : in Positive;\n-         New_Item : in Wide_String;\n-         Drop     : in Truncation := Error)\n-         return     Bounded_Wide_String\n-        renames Super_Insert;\n+        (Source   : Bounded_Wide_String;\n+         Before   : Positive;\n+         New_Item : Wide_String;\n+         Drop     : Truncation := Error) return Bounded_Wide_String\n+         renames Super_Insert;\n \n       procedure Insert\n         (Source   : in out Bounded_Wide_String;\n-         Before   : in Positive;\n-         New_Item : in Wide_String;\n-         Drop     : in Truncation := Error)\n-        renames Super_Insert;\n+         Before   : Positive;\n+         New_Item : Wide_String;\n+         Drop     : Truncation := Error)\n+         renames Super_Insert;\n \n       function Overwrite\n-        (Source    : in Bounded_Wide_String;\n-         Position  : in Positive;\n-         New_Item  : in Wide_String;\n-         Drop      : in Truncation := Error)\n-         return      Bounded_Wide_String\n-        renames Super_Overwrite;\n+        (Source   : Bounded_Wide_String;\n+         Position : Positive;\n+         New_Item : Wide_String;\n+         Drop     : Truncation := Error) return Bounded_Wide_String\n+         renames Super_Overwrite;\n \n       procedure Overwrite\n         (Source    : in out Bounded_Wide_String;\n-         Position  : in Positive;\n-         New_Item  : in Wide_String;\n-         Drop      : in Truncation := Error)\n-        renames Super_Overwrite;\n+         Position  : Positive;\n+         New_Item  : Wide_String;\n+         Drop      : Truncation := Error)\n+         renames Super_Overwrite;\n \n       function Delete\n-        (Source  : in Bounded_Wide_String;\n-         From    : in Positive;\n-         Through : in Natural)\n-         return    Bounded_Wide_String\n-        renames Super_Delete;\n+        (Source  : Bounded_Wide_String;\n+         From    : Positive;\n+         Through : Natural) return Bounded_Wide_String\n+         renames Super_Delete;\n \n       procedure Delete\n         (Source  : in out Bounded_Wide_String;\n-         From    : in Positive;\n-         Through : in Natural)\n-        renames Super_Delete;\n+         From    : Positive;\n+         Through : Natural)\n+         renames Super_Delete;\n \n       function Trim\n-        (Source : in Bounded_Wide_String;\n-         Side   : in Trim_End)\n-         return   Bounded_Wide_String\n-        renames Super_Trim;\n+        (Source : Bounded_Wide_String;\n+         Side   : Trim_End) return Bounded_Wide_String\n+         renames Super_Trim;\n \n       procedure Trim\n         (Source : in out Bounded_Wide_String;\n-         Side   : in Trim_End)\n-        renames Super_Trim;\n+         Side   : Trim_End)\n+         renames Super_Trim;\n \n       function Trim\n-        (Source  : in Bounded_Wide_String;\n-          Left   : in Wide_Maps.Wide_Character_Set;\n-          Right  : in Wide_Maps.Wide_Character_Set)\n-          return   Bounded_Wide_String\n-        renames Super_Trim;\n+        (Source : Bounded_Wide_String;\n+         Left   : Wide_Maps.Wide_Character_Set;\n+         Right  : Wide_Maps.Wide_Character_Set) return Bounded_Wide_String\n+         renames Super_Trim;\n \n       procedure Trim\n         (Source : in out Bounded_Wide_String;\n-         Left   : in Wide_Maps.Wide_Character_Set;\n-         Right  : in Wide_Maps.Wide_Character_Set)\n-        renames Super_Trim;\n+         Left   : Wide_Maps.Wide_Character_Set;\n+         Right  : Wide_Maps.Wide_Character_Set)\n+         renames Super_Trim;\n \n       function Head\n-        (Source : in Bounded_Wide_String;\n-         Count  : in Natural;\n-         Pad    : in Wide_Character := Wide_Space;\n-         Drop   : in Truncation := Error)\n-         return   Bounded_Wide_String\n-        renames Super_Head;\n+        (Source : Bounded_Wide_String;\n+         Count  : Natural;\n+         Pad    : Wide_Character := Wide_Space;\n+         Drop   : Truncation     := Error) return Bounded_Wide_String\n+         renames Super_Head;\n \n       procedure Head\n         (Source : in out Bounded_Wide_String;\n-         Count  : in Natural;\n-         Pad    : in Wide_Character  := Wide_Space;\n-         Drop   : in Truncation := Error)\n-        renames Super_Head;\n+         Count  : Natural;\n+         Pad    : Wide_Character := Wide_Space;\n+         Drop   : Truncation     := Error)\n+         renames Super_Head;\n \n       function Tail\n-        (Source : in Bounded_Wide_String;\n-         Count  : in Natural;\n-         Pad    : in Wide_Character  := Wide_Space;\n-         Drop   : in Truncation := Error)\n-         return Bounded_Wide_String\n-        renames Super_Tail;\n+        (Source : Bounded_Wide_String;\n+         Count  : Natural;\n+         Pad    : Wide_Character := Wide_Space;\n+         Drop   : Truncation     := Error) return Bounded_Wide_String\n+         renames Super_Tail;\n \n       procedure Tail\n         (Source : in out Bounded_Wide_String;\n-         Count  : in Natural;\n-         Pad    : in Wide_Character  := Wide_Space;\n-         Drop   : in Truncation := Error)\n-        renames Super_Tail;\n+         Count  : Natural;\n+         Pad    : Wide_Character := Wide_Space;\n+         Drop   : Truncation := Error)\n+         renames Super_Tail;\n \n       function \"*\"\n-        (Left  : in Natural;\n-         Right : in Bounded_Wide_String)\n-         return  Bounded_Wide_String\n-        renames Times;\n+        (Left  : Natural;\n+         Right : Bounded_Wide_String) return Bounded_Wide_String\n+         renames Times;\n \n       function Replicate\n-        (Count : in Natural;\n-         Item  : in Bounded_Wide_String;\n-         Drop  : in Truncation := Error)\n-         return  Bounded_Wide_String\n+        (Count : Natural;\n+         Item  : Bounded_Wide_String;\n+         Drop  : Truncation := Error) return Bounded_Wide_String\n          renames Super_Replicate;\n \n    end Generic_Bounded_Length;"}, {"sha": "bdaac0b64dfdea7cf83ebcf0683f5cfede7939d7", "filename": "gcc/ada/a-stwisu.adb", "status": "modified", "additions": 225, "deletions": 125, "changes": 350, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/82c80734715c801643075ab68c5c9a5e00da1b03/gcc%2Fada%2Fa-stwisu.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/82c80734715c801643075ab68c5c9a5e00da1b03/gcc%2Fada%2Fa-stwisu.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-stwisu.adb?ref=82c80734715c801643075ab68c5c9a5e00da1b03", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 2003 Free Software Foundation, Inc.               --\n+--          Copyright (C) 2003-2005 Free Software Foundation, Inc.          --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -42,8 +42,7 @@ package body Ada.Strings.Wide_Superbounded is\n \n    function Concat\n      (Left  : Super_String;\n-      Right : Super_String)\n-      return  Super_String\n+      Right : Super_String) return Super_String\n    is\n       Result : Super_String (Left.Max_Length);\n       Llen   : constant Natural := Left.Current_Length;\n@@ -64,8 +63,7 @@ package body Ada.Strings.Wide_Superbounded is\n \n    function Concat\n      (Left  : Super_String;\n-      Right : Wide_String)\n-      return  Super_String\n+      Right : Wide_String) return Super_String\n    is\n       Result : Super_String (Left.Max_Length);\n       Llen   : constant Natural := Left.Current_Length;\n@@ -85,8 +83,7 @@ package body Ada.Strings.Wide_Superbounded is\n \n    function Concat\n      (Left  : Wide_String;\n-      Right : Super_String)\n-      return  Super_String\n+      Right : Super_String) return Super_String\n    is\n       Result : Super_String (Right.Max_Length);\n       Llen   : constant Natural := Left'Length;\n@@ -107,8 +104,7 @@ package body Ada.Strings.Wide_Superbounded is\n \n    function Concat\n      (Left  : Super_String;\n-      Right : Wide_Character)\n-      return  Super_String\n+      Right : Wide_Character) return Super_String\n    is\n       Result : Super_String (Left.Max_Length);\n       Llen   : constant Natural := Left.Current_Length;\n@@ -127,8 +123,7 @@ package body Ada.Strings.Wide_Superbounded is\n \n    function Concat\n      (Left  : Wide_Character;\n-      Right : Super_String)\n-      return  Super_String\n+      Right : Super_String) return Super_String\n    is\n       Result : Super_String (Right.Max_Length);\n       Rlen   : constant Natural := Right.Current_Length;\n@@ -149,22 +144,29 @@ package body Ada.Strings.Wide_Superbounded is\n    -- Equal --\n    -----------\n \n-   function \"=\" (Left, Right : Super_String) return Boolean is\n+   function \"=\"\n+     (Left  : Super_String;\n+      Right : Super_String) return Boolean\n+   is\n    begin\n       return Left.Current_Length = Right.Current_Length\n         and then Left.Data (1 .. Left.Current_Length) =\n                    Right.Data (1 .. Right.Current_Length);\n    end \"=\";\n \n-   function Equal (Left : Super_String; Right : Wide_String)\n-                   return Boolean is\n+   function Equal\n+     (Left  : Super_String;\n+      Right : Wide_String) return Boolean\n+   is\n    begin\n       return Left.Current_Length = Right'Length\n         and then Left.Data (1 .. Left.Current_Length) = Right;\n    end Equal;\n \n-   function Equal (Left : Wide_String; Right : Super_String)\n-                   return Boolean is\n+   function Equal\n+     (Left  : Wide_String;\n+      Right : Super_String) return Boolean\n+   is\n    begin\n       return Left'Length = Right.Current_Length\n         and then Left = Right.Data (1 .. Right.Current_Length);\n@@ -174,25 +176,26 @@ package body Ada.Strings.Wide_Superbounded is\n    -- Greater --\n    -------------\n \n-   function Greater (Left, Right : Super_String) return Boolean is\n+   function Greater\n+     (Left  : Super_String;\n+      Right : Super_String) return Boolean\n+   is\n    begin\n       return Left.Data (1 .. Left.Current_Length) >\n                Right.Data (1 .. Right.Current_Length);\n    end Greater;\n \n    function Greater\n      (Left  : Super_String;\n-      Right : Wide_String)\n-      return  Boolean\n+      Right : Wide_String) return Boolean\n    is\n    begin\n       return Left.Data (1 .. Left.Current_Length) > Right;\n    end Greater;\n \n    function Greater\n      (Left  : Wide_String;\n-      Right : Super_String)\n-      return  Boolean\n+      Right : Super_String) return Boolean\n    is\n    begin\n       return Left > Right.Data (1 .. Right.Current_Length);\n@@ -202,25 +205,26 @@ package body Ada.Strings.Wide_Superbounded is\n    -- Greater_Or_Equal --\n    ----------------------\n \n-   function Greater_Or_Equal (Left, Right : Super_String) return Boolean is\n+   function Greater_Or_Equal\n+     (Left  : Super_String;\n+      Right : Super_String) return Boolean\n+   is\n    begin\n       return Left.Data (1 .. Left.Current_Length) >=\n                Right.Data (1 .. Right.Current_Length);\n    end Greater_Or_Equal;\n \n    function Greater_Or_Equal\n      (Left  : Super_String;\n-      Right : Wide_String)\n-      return  Boolean\n+      Right : Wide_String) return Boolean\n    is\n    begin\n       return Left.Data (1 .. Left.Current_Length) >= Right;\n    end Greater_Or_Equal;\n \n    function Greater_Or_Equal\n      (Left  : Wide_String;\n-      Right : Super_String)\n-      return  Boolean\n+      Right : Super_String) return Boolean\n    is\n    begin\n       return Left >= Right.Data (1 .. Right.Current_Length);\n@@ -230,25 +234,26 @@ package body Ada.Strings.Wide_Superbounded is\n    -- Less --\n    ----------\n \n-   function Less (Left, Right : Super_String) return Boolean is\n+   function Less\n+     (Left  : Super_String;\n+      Right : Super_String) return Boolean\n+   is\n    begin\n       return Left.Data (1 .. Left.Current_Length) <\n                Right.Data (1 .. Right.Current_Length);\n    end Less;\n \n    function Less\n      (Left  : Super_String;\n-      Right : Wide_String)\n-      return  Boolean\n+      Right : Wide_String) return Boolean\n    is\n    begin\n       return Left.Data (1 .. Left.Current_Length) < Right;\n    end Less;\n \n    function Less\n      (Left  : Wide_String;\n-      Right : Super_String)\n-      return  Boolean\n+      Right : Super_String) return Boolean\n    is\n    begin\n       return Left < Right.Data (1 .. Right.Current_Length);\n@@ -258,40 +263,76 @@ package body Ada.Strings.Wide_Superbounded is\n    -- Less_Or_Equal --\n    -------------------\n \n-   function Less_Or_Equal (Left, Right : Super_String) return Boolean is\n+   function Less_Or_Equal\n+     (Left  : Super_String;\n+      Right : Super_String) return Boolean\n+   is\n    begin\n       return Left.Data (1 .. Left.Current_Length) <=\n                Right.Data (1 .. Right.Current_Length);\n    end Less_Or_Equal;\n \n    function Less_Or_Equal\n      (Left  : Super_String;\n-      Right : Wide_String)\n-      return  Boolean\n+      Right : Wide_String) return Boolean\n    is\n    begin\n       return Left.Data (1 .. Left.Current_Length) <= Right;\n    end Less_Or_Equal;\n \n    function Less_Or_Equal\n      (Left  : Wide_String;\n-      Right : Super_String)\n-      return  Boolean\n+      Right : Super_String) return Boolean\n    is\n    begin\n       return Left <= Right.Data (1 .. Right.Current_Length);\n    end Less_Or_Equal;\n \n+   ----------------------\n+   -- Set_Super_String --\n+   ----------------------\n+\n+   procedure Set_Super_String\n+     (Target : out Super_String;\n+      Source : Wide_String;\n+      Drop   : Truncation := Error)\n+   is\n+      Slen       : constant Natural := Source'Length;\n+      Max_Length : constant Positive := Target.Max_Length;\n+\n+   begin\n+      if Slen <= Max_Length then\n+         Target.Current_Length := Slen;\n+         Target.Data (1 .. Slen) := Source;\n+\n+      else\n+         case Drop is\n+            when Strings.Right =>\n+               Target.Current_Length := Max_Length;\n+               Target.Data (1 .. Max_Length) :=\n+                 Source (Source'First .. Source'First - 1 + Max_Length);\n+\n+            when Strings.Left =>\n+               Target.Current_Length := Max_Length;\n+               Target.Data (1 .. Max_Length) :=\n+                 Source (Source'Last - (Max_Length - 1) .. Source'Last);\n+\n+            when Strings.Error =>\n+               raise Ada.Strings.Length_Error;\n+         end case;\n+      end if;\n+   end Set_Super_String;\n+\n    ------------------\n    -- Super_Append --\n    ------------------\n \n    --  Case of Super_String and Super_String\n \n    function Super_Append\n-     (Left, Right : Super_String;\n-      Drop        : Strings.Truncation  := Strings.Error)\n-      return        Super_String\n+     (Left  : Super_String;\n+      Right : Super_String;\n+      Drop  : Strings.Truncation  := Strings.Error) return Super_String\n    is\n       Max_Length : constant Positive := Left.Max_Length;\n       Result : Super_String (Max_Length);\n@@ -386,8 +427,7 @@ package body Ada.Strings.Wide_Superbounded is\n    function Super_Append\n      (Left  : Super_String;\n       Right : Wide_String;\n-      Drop  : Strings.Truncation := Strings.Error)\n-      return  Super_String\n+      Drop  : Strings.Truncation := Strings.Error) return Super_String\n    is\n       Max_Length : constant Positive := Left.Max_Length;\n       Result : Super_String (Max_Length);\n@@ -488,8 +528,7 @@ package body Ada.Strings.Wide_Superbounded is\n    function Super_Append\n      (Left  : Wide_String;\n       Right : Super_String;\n-      Drop  : Strings.Truncation := Strings.Error)\n-      return  Super_String\n+      Drop  : Strings.Truncation := Strings.Error) return Super_String\n    is\n       Max_Length : constant Positive := Right.Max_Length;\n       Result     : Super_String (Max_Length);\n@@ -543,8 +582,7 @@ package body Ada.Strings.Wide_Superbounded is\n    function Super_Append\n      (Left  : Super_String;\n       Right : Wide_Character;\n-      Drop  : Strings.Truncation := Strings.Error)\n-      return  Super_String\n+      Drop  : Strings.Truncation := Strings.Error) return Super_String\n    is\n       Max_Length : constant Positive := Left.Max_Length;\n       Result     : Super_String (Max_Length);\n@@ -612,8 +650,7 @@ package body Ada.Strings.Wide_Superbounded is\n    function Super_Append\n      (Left  : Wide_Character;\n       Right : Super_String;\n-      Drop  : Strings.Truncation := Strings.Error)\n-      return  Super_String\n+      Drop  : Strings.Truncation := Strings.Error) return Super_String\n    is\n       Max_Length : constant Positive := Right.Max_Length;\n       Result : Super_String (Max_Length);\n@@ -649,10 +686,10 @@ package body Ada.Strings.Wide_Superbounded is\n    -----------------\n \n    function Super_Count\n-     (Source   : Super_String;\n-      Pattern  : Wide_String;\n-      Mapping  : Wide_Maps.Wide_Character_Mapping := Wide_Maps.Identity)\n-      return     Natural\n+     (Source  : Super_String;\n+      Pattern : Wide_String;\n+      Mapping : Wide_Maps.Wide_Character_Mapping := Wide_Maps.Identity)\n+      return Natural\n    is\n    begin\n       return\n@@ -661,10 +698,9 @@ package body Ada.Strings.Wide_Superbounded is\n    end Super_Count;\n \n    function Super_Count\n-     (Source   : Super_String;\n-      Pattern  : Wide_String;\n-      Mapping  : Wide_Maps.Wide_Character_Mapping_Function)\n-      return     Natural\n+     (Source  : Super_String;\n+      Pattern : Wide_String;\n+      Mapping : Wide_Maps.Wide_Character_Mapping_Function) return Natural\n    is\n    begin\n       return\n@@ -674,8 +710,7 @@ package body Ada.Strings.Wide_Superbounded is\n \n    function Super_Count\n      (Source : Super_String;\n-      Set    : Wide_Maps.Wide_Character_Set)\n-      return   Natural\n+      Set    : Wide_Maps.Wide_Character_Set) return Natural\n    is\n    begin\n       return Wide_Search.Count (Source.Data (1 .. Source.Current_Length), Set);\n@@ -688,8 +723,7 @@ package body Ada.Strings.Wide_Superbounded is\n    function Super_Delete\n      (Source  : Super_String;\n       From    : Positive;\n-      Through : Natural)\n-      return    Super_String\n+      Through : Natural) return Super_String\n    is\n       Result     : Super_String (Source.Max_Length);\n       Slen       : constant Natural := Source.Current_Length;\n@@ -747,8 +781,7 @@ package body Ada.Strings.Wide_Superbounded is\n \n    function Super_Element\n      (Source : Super_String;\n-      Index  : Positive)\n-      return   Wide_Character\n+      Index  : Positive) return Wide_Character\n    is\n    begin\n       if Index in 1 .. Source.Current_Length then\n@@ -782,8 +815,7 @@ package body Ada.Strings.Wide_Superbounded is\n      (Source : Super_String;\n       Count  : Natural;\n       Pad    : Wide_Character := Wide_Space;\n-      Drop   : Strings.Truncation := Strings.Error)\n-      return   Super_String\n+      Drop   : Strings.Truncation := Strings.Error) return Super_String\n    is\n       Max_Length : constant Positive := Source.Max_Length;\n       Result     : Super_String (Max_Length);\n@@ -830,7 +862,7 @@ package body Ada.Strings.Wide_Superbounded is\n    procedure Super_Head\n      (Source : in out Super_String;\n       Count  : Natural;\n-      Pad    : Wide_Character  := Wide_Space;\n+      Pad    : Wide_Character := Wide_Space;\n       Drop   : Truncation := Error)\n    is\n       Max_Length : constant Positive := Source.Max_Length;\n@@ -878,23 +910,22 @@ package body Ada.Strings.Wide_Superbounded is\n    -----------------\n \n    function Super_Index\n-     (Source   : Super_String;\n-      Pattern  : Wide_String;\n-      Going    : Strings.Direction := Strings.Forward;\n-      Mapping  : Wide_Maps.Wide_Character_Mapping := Wide_Maps.Identity)\n-      return     Natural\n+     (Source  : Super_String;\n+      Pattern : Wide_String;\n+      Going   : Strings.Direction := Strings.Forward;\n+      Mapping : Wide_Maps.Wide_Character_Mapping := Wide_Maps.Identity)\n+      return Natural\n    is\n    begin\n       return Wide_Search.Index\n         (Source.Data (1 .. Source.Current_Length), Pattern, Going, Mapping);\n    end Super_Index;\n \n    function Super_Index\n-     (Source   : Super_String;\n-      Pattern  : Wide_String;\n-      Going    : Direction := Forward;\n-      Mapping  : Wide_Maps.Wide_Character_Mapping_Function)\n-      return     Natural\n+     (Source  : Super_String;\n+      Pattern : Wide_String;\n+      Going   : Direction := Forward;\n+      Mapping : Wide_Maps.Wide_Character_Mapping_Function) return Natural\n    is\n    begin\n       return Wide_Search.Index\n@@ -905,29 +936,77 @@ package body Ada.Strings.Wide_Superbounded is\n      (Source : Super_String;\n       Set    : Wide_Maps.Wide_Character_Set;\n       Test   : Strings.Membership := Strings.Inside;\n-      Going  : Strings.Direction  := Strings.Forward)\n-      return   Natural\n+      Going  : Strings.Direction  := Strings.Forward) return Natural\n    is\n    begin\n       return Wide_Search.Index\n         (Source.Data (1 .. Source.Current_Length), Set, Test, Going);\n    end Super_Index;\n \n+   function Super_Index\n+     (Source  : Super_String;\n+      Pattern : Wide_String;\n+      From    : Positive;\n+      Going   : Direction := Forward;\n+      Mapping : Wide_Maps.Wide_Character_Mapping := Wide_Maps.Identity)\n+      return Natural\n+   is\n+   begin\n+      return Wide_Search.Index\n+        (Source.Data (1 .. Source.Current_Length),\n+         Pattern, From, Going, Mapping);\n+   end Super_Index;\n+\n+   function Super_Index\n+     (Source  : Super_String;\n+      Pattern : Wide_String;\n+      From    : Positive;\n+      Going   : Direction := Forward;\n+      Mapping : Wide_Maps.Wide_Character_Mapping_Function) return Natural\n+   is\n+   begin\n+      return Wide_Search.Index\n+        (Source.Data (1 .. Source.Current_Length),\n+         Pattern, From, Going, Mapping);\n+   end Super_Index;\n+\n+   function Super_Index\n+     (Source : Super_String;\n+      Set    : Wide_Maps.Wide_Character_Set;\n+      From   : Positive;\n+      Test   : Membership := Inside;\n+      Going  : Direction := Forward) return Natural\n+   is\n+   begin\n+      return Wide_Search.Index\n+        (Source.Data (1 .. Source.Current_Length), Set, From, Test, Going);\n+   end Super_Index;\n+\n    ---------------------------\n    -- Super_Index_Non_Blank --\n    ---------------------------\n \n    function Super_Index_Non_Blank\n      (Source : Super_String;\n-      Going  : Strings.Direction := Strings.Forward)\n-      return   Natural\n+      Going  : Strings.Direction := Strings.Forward) return Natural\n    is\n    begin\n       return\n         Wide_Search.Index_Non_Blank\n           (Source.Data (1 .. Source.Current_Length), Going);\n    end Super_Index_Non_Blank;\n \n+   function Super_Index_Non_Blank\n+     (Source : Super_String;\n+      From   : Positive;\n+      Going  : Direction := Forward) return Natural\n+   is\n+   begin\n+      return\n+        Wide_Search.Index_Non_Blank\n+          (Source.Data (1 .. Source.Current_Length), From, Going);\n+   end Super_Index_Non_Blank;\n+\n    ------------------\n    -- Super_Insert --\n    ------------------\n@@ -936,8 +1015,7 @@ package body Ada.Strings.Wide_Superbounded is\n      (Source   : Super_String;\n       Before   : Positive;\n       New_Item : Wide_String;\n-      Drop     : Strings.Truncation := Strings.Error)\n-      return     Super_String\n+      Drop     : Strings.Truncation := Strings.Error) return Super_String\n    is\n       Max_Length : constant Positive := Source.Max_Length;\n       Result     : Super_String (Max_Length);\n@@ -948,9 +1026,9 @@ package body Ada.Strings.Wide_Superbounded is\n       Alen       : constant Integer := Slen - Blen;\n       Droplen    : constant Integer := Tlen - Max_Length;\n \n-      --  Tlen is the length of the total Wide_String before possible\n-      --  truncation. Blen, Alen are the lengths of the before and after\n-      --  pieces of the source Wide_String.\n+      --  Tlen is the length of the total string before possible truncation.\n+      --  Blen, Alen are the lengths of the before and after pieces of the\n+      --  source string.\n \n    begin\n       if Alen < 0 then\n@@ -1032,11 +1110,10 @@ package body Ada.Strings.Wide_Superbounded is\n    ---------------------\n \n    function Super_Overwrite\n-     (Source    : Super_String;\n-      Position  : Positive;\n-      New_Item  : Wide_String;\n-      Drop      : Strings.Truncation := Strings.Error)\n-      return      Super_String\n+     (Source   : Super_String;\n+      Position : Positive;\n+      New_Item : Wide_String;\n+      Drop     : Strings.Truncation := Strings.Error) return Super_String\n    is\n       Max_Length : constant Positive := Source.Max_Length;\n       Result     : Super_String (Max_Length);\n@@ -1172,12 +1249,11 @@ package body Ada.Strings.Wide_Superbounded is\n    -------------------------\n \n    function Super_Replace_Slice\n-     (Source   : Super_String;\n-      Low      : Positive;\n-      High     : Natural;\n-      By       : Wide_String;\n-      Drop     : Strings.Truncation := Strings.Error)\n-      return     Super_String\n+     (Source : Super_String;\n+      Low    : Positive;\n+      High   : Natural;\n+      By     : Wide_String;\n+      Drop   : Strings.Truncation := Strings.Error) return Super_String\n    is\n       Max_Length : constant Positive := Source.Max_Length;\n       Slen       : constant Natural  := Source.Current_Length;\n@@ -1197,10 +1273,10 @@ package body Ada.Strings.Wide_Superbounded is\n             Droplen : constant Integer := Tlen - Max_Length;\n             Result  : Super_String (Max_Length);\n \n-            --  Tlen is the total length of the result Wide_String before any\n+            --  Tlen is the total length of the result string before any\n             --  truncation. Blen and Alen are the lengths of the pieces\n-            --  of the original Wide_String that end up in the result\n-            --  Wide_String before and after the replaced slice.\n+            --  of the original string that end up in the result string\n+            --  before and after the replaced slice.\n \n          begin\n             if Droplen <= 0 then\n@@ -1273,8 +1349,7 @@ package body Ada.Strings.Wide_Superbounded is\n      (Count      : Natural;\n       Item       : Wide_Character;\n       Drop       : Truncation := Error;\n-      Max_Length : Positive)\n-      return       Super_String\n+      Max_Length : Positive) return Super_String\n    is\n       Result : Super_String (Max_Length);\n \n@@ -1297,8 +1372,7 @@ package body Ada.Strings.Wide_Superbounded is\n      (Count      : Natural;\n       Item       : Wide_String;\n       Drop       : Truncation := Error;\n-      Max_Length : Positive)\n-      return       Super_String\n+      Max_Length : Positive) return Super_String\n    is\n       Length : constant Integer := Count * Item'Length;\n       Result : Super_String (Max_Length);\n@@ -1354,8 +1428,7 @@ package body Ada.Strings.Wide_Superbounded is\n    function Super_Replicate\n      (Count : Natural;\n       Item  : Super_String;\n-      Drop  : Strings.Truncation := Strings.Error)\n-      return  Super_String\n+      Drop  : Strings.Truncation := Strings.Error) return Super_String\n    is\n    begin\n       return\n@@ -1373,8 +1446,7 @@ package body Ada.Strings.Wide_Superbounded is\n    function Super_Slice\n      (Source : Super_String;\n       Low    : Positive;\n-      High   : Natural)\n-      return   Wide_String\n+      High   : Natural) return Wide_String\n    is\n    begin\n       --  Note: test of High > Length is in accordance with AI95-00128\n@@ -1388,6 +1460,43 @@ package body Ada.Strings.Wide_Superbounded is\n       end if;\n    end Super_Slice;\n \n+   function Super_Slice\n+     (Source : Super_String;\n+      Low    : Positive;\n+      High   : Natural) return Super_String\n+   is\n+      Result : Super_String (Source.Max_Length);\n+\n+   begin\n+      if Low > Source.Current_Length + 1\n+        or else High > Source.Current_Length\n+      then\n+         raise Index_Error;\n+      else\n+         Result.Current_Length := High - Low + 1;\n+         Result.Data (1 .. Source.Current_Length) := Source.Data (Low .. High);\n+      end if;\n+\n+      return Result;\n+   end Super_Slice;\n+\n+   procedure Super_Slice\n+     (Source : Super_String;\n+      Target : out Super_String;\n+      Low    : Positive;\n+      High   : Natural)\n+   is\n+   begin\n+      if Low > Source.Current_Length + 1\n+        or else High > Source.Current_Length\n+      then\n+         raise Index_Error;\n+      else\n+         Target.Current_Length := High - Low + 1;\n+         Target.Data (1 .. Source.Current_Length) := Source.Data (Low .. High);\n+      end if;\n+   end Super_Slice;\n+\n    ----------------\n    -- Super_Tail --\n    ----------------\n@@ -1396,8 +1505,7 @@ package body Ada.Strings.Wide_Superbounded is\n      (Source : Super_String;\n       Count  : Natural;\n       Pad    : Wide_Character := Wide_Space;\n-      Drop   : Strings.Truncation := Strings.Error)\n-      return   Super_String\n+      Drop   : Strings.Truncation := Strings.Error) return Super_String\n    is\n       Max_Length : constant Positive := Source.Max_Length;\n       Result     : Super_String (Max_Length);\n@@ -1445,7 +1553,7 @@ package body Ada.Strings.Wide_Superbounded is\n    procedure Super_Tail\n      (Source : in out Super_String;\n       Count  : Natural;\n-      Pad    : Wide_Character  := Wide_Space;\n+      Pad    : Wide_Character := Wide_Space;\n       Drop   : Truncation := Error)\n    is\n       Max_Length : constant Positive := Source.Max_Length;\n@@ -1497,7 +1605,7 @@ package body Ada.Strings.Wide_Superbounded is\n    -- Super_To_String --\n    ---------------------\n \n-   function Super_To_String (Source : in Super_String) return Wide_String is\n+   function Super_To_String (Source : Super_String) return Wide_String is\n    begin\n       return Source.Data (1 .. Source.Current_Length);\n    end Super_To_String;\n@@ -1508,8 +1616,7 @@ package body Ada.Strings.Wide_Superbounded is\n \n    function Super_Translate\n      (Source  : Super_String;\n-      Mapping : Wide_Maps.Wide_Character_Mapping)\n-      return    Super_String\n+      Mapping : Wide_Maps.Wide_Character_Mapping) return Super_String\n    is\n       Result : Super_String (Source.Max_Length);\n \n@@ -1535,8 +1642,7 @@ package body Ada.Strings.Wide_Superbounded is\n \n    function Super_Translate\n      (Source  : Super_String;\n-      Mapping : Wide_Maps.Wide_Character_Mapping_Function)\n-      return    Super_String\n+      Mapping : Wide_Maps.Wide_Character_Mapping_Function) return Super_String\n    is\n       Result : Super_String (Source.Max_Length);\n \n@@ -1566,8 +1672,7 @@ package body Ada.Strings.Wide_Superbounded is\n \n    function Super_Trim\n      (Source : Super_String;\n-      Side   : Trim_End)\n-      return   Super_String\n+      Side   : Trim_End) return Super_String\n    is\n       Result : Super_String (Source.Max_Length);\n       Last   : Natural := Source.Current_Length;\n@@ -1623,8 +1728,7 @@ package body Ada.Strings.Wide_Superbounded is\n    function Super_Trim\n      (Source : Super_String;\n       Left   : Wide_Maps.Wide_Character_Set;\n-      Right  : Wide_Maps.Wide_Character_Set)\n-      return   Super_String\n+      Right  : Wide_Maps.Wide_Character_Set) return Super_String\n    is\n       Result : Super_String (Source.Max_Length);\n \n@@ -1690,8 +1794,7 @@ package body Ada.Strings.Wide_Superbounded is\n    function Times\n      (Left       : Natural;\n       Right      : Wide_Character;\n-      Max_Length : Positive)\n-      return  Super_String\n+      Max_Length : Positive) return Super_String\n    is\n       Result : Super_String (Max_Length);\n \n@@ -1713,8 +1816,7 @@ package body Ada.Strings.Wide_Superbounded is\n    function Times\n      (Left       : Natural;\n       Right      : Wide_String;\n-      Max_Length : Positive)\n-      return  Super_String\n+      Max_Length : Positive) return Super_String\n    is\n       Result : Super_String (Max_Length);\n       Pos    : Positive         := 1;\n@@ -1741,8 +1843,7 @@ package body Ada.Strings.Wide_Superbounded is\n \n    function Times\n      (Left  : Natural;\n-      Right : Super_String)\n-      return  Super_String\n+      Right : Super_String) return Super_String\n    is\n       Result : Super_String (Right.Max_Length);\n       Pos    : Positive := 1;\n@@ -1775,8 +1876,7 @@ package body Ada.Strings.Wide_Superbounded is\n    function To_Super_String\n      (Source     : Wide_String;\n       Max_Length : Natural;\n-      Drop       : Truncation := Error)\n-      return       Super_String\n+      Drop       : Truncation := Error) return Super_String\n    is\n       Result : Super_String (Max_Length);\n       Slen   : constant Natural := Source'Length;"}, {"sha": "a9df6fa2547ae206ae045b9df2a4e36fef3b75ed", "filename": "gcc/ada/a-stwisu.ads", "status": "modified", "additions": 147, "deletions": 137, "changes": 284, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/82c80734715c801643075ab68c5c9a5e00da1b03/gcc%2Fada%2Fa-stwisu.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/82c80734715c801643075ab68c5c9a5e00da1b03/gcc%2Fada%2Fa-stwisu.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-stwisu.ads?ref=82c80734715c801643075ab68c5c9a5e00da1b03", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---          Copyright (C) 2003 Free Software Foundation, Inc.               --\n+--          Copyright (C) 2003-2005 Free Software Foundation, Inc.          --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -35,7 +35,7 @@\n --  generic package Ada.Strings.Wide_Bounded.Generic_Bounded_Length.\n \n --  It defines type Super_String as a discriminated record with the maximum\n---  length as the discriminant. Individual instantiations of\n+--  length as the discriminant. Individual instantiations of the package\n --  Strings.Wide_Bounded.Generic_Bounded_Length use this type with\n --  an appropriate discriminant value set.\n \n@@ -50,14 +50,12 @@ pragma Preelaborate (Wide_Superbounded);\n       Current_Length : Natural := 0;\n       Data           : Wide_String (1 .. Max_Length) := (others => Wide_NUL);\n    end record;\n-   --  Type Wide_Bounded_String in\n-   --  Ada.Strings.Wide_Bounded.Generic_Bounded_Length is derived from this\n-   --  type, with the constraint of the maximum length.\n+   --  Ada.Strings.Wide_Bounded.Generic_Bounded_Length.Wide_Bounded_String is\n+   --  derived from this type, with the constraint of the maximum length.\n \n-   --  The subprograms defined for Super_String are similar to those\n-   --  defined for Wide_Bounded_String, except that they have different names,\n-   --  so that they can be renamed in\n-   --  Ada.Strings.Wide_Bounded.Generic_Bounded_Length.\n+   --  The subprograms defined for Super_String are similar to those defined\n+   --  for Bounded_Wide_String, except that they have different names, so that\n+   --  they can be renamed in Ada.Strings.Wide_Bounded.Generic_Bounded_Length.\n \n    function Super_Length (Source : Super_String) return Natural;\n \n@@ -68,88 +66,83 @@ pragma Preelaborate (Wide_Superbounded);\n    function To_Super_String\n      (Source     : Wide_String;\n       Max_Length : Natural;\n-      Drop       : Truncation := Error)\n-      return       Super_String;\n+      Drop       : Truncation := Error) return Super_String;\n    --  Note the additional parameter Max_Length, which specifies the maximum\n    --  length setting of the resulting Super_String value.\n \n    --  The following procedures have declarations (and semantics) that are\n-   --  exactly analogous to those declared in Ada.Strings.Bounded.\n+   --  exactly analogous to those declared in Ada.Strings.Wide_Bounded.\n \n    function Super_To_String (Source : Super_String) return Wide_String;\n \n+   procedure Set_Super_String\n+     (Target : out Super_String;\n+      Source : Wide_String;\n+      Drop   : Truncation := Error);\n+\n    function Super_Append\n-     (Left, Right : Super_String;\n-      Drop        : Truncation  := Error)\n-      return        Super_String;\n+     (Left  : Super_String;\n+      Right : Super_String;\n+      Drop  : Truncation := Error) return Super_String;\n \n    function Super_Append\n      (Left  : Super_String;\n       Right : Wide_String;\n-      Drop  : Truncation := Error)\n-      return  Super_String;\n+      Drop  : Truncation := Error) return Super_String;\n \n    function Super_Append\n      (Left  : Wide_String;\n       Right : Super_String;\n-      Drop  : Truncation := Error)\n-      return  Super_String;\n+      Drop  : Truncation := Error) return Super_String;\n \n    function Super_Append\n      (Left  : Super_String;\n       Right : Wide_Character;\n-      Drop  : Truncation := Error)\n-      return  Super_String;\n+      Drop  : Truncation := Error) return Super_String;\n \n    function Super_Append\n      (Left  : Wide_Character;\n       Right : Super_String;\n-      Drop  : Truncation := Error)\n-      return  Super_String;\n+      Drop  : Truncation := Error) return Super_String;\n \n    procedure Super_Append\n      (Source   : in out Super_String;\n       New_Item : Super_String;\n-      Drop     : Truncation  := Error);\n+      Drop     : Truncation := Error);\n \n    procedure Super_Append\n      (Source   : in out Super_String;\n       New_Item : Wide_String;\n-      Drop     : Truncation  := Error);\n+      Drop     : Truncation := Error);\n \n    procedure Super_Append\n      (Source   : in out Super_String;\n       New_Item : Wide_Character;\n-      Drop     : Truncation  := Error);\n+      Drop     : Truncation := Error);\n \n    function Concat\n-     (Left, Right : Super_String)\n-      return        Super_String;\n+     (Left  : Super_String;\n+      Right : Super_String) return Super_String;\n \n    function Concat\n      (Left  : Super_String;\n-      Right : Wide_String)\n-      return  Super_String;\n+      Right : Wide_String) return Super_String;\n \n    function Concat\n      (Left  : Wide_String;\n-      Right : Super_String)\n-      return  Super_String;\n+      Right : Super_String) return Super_String;\n \n    function Concat\n      (Left  : Super_String;\n-      Right : Wide_Character)\n-      return  Super_String;\n+      Right : Wide_Character) return Super_String;\n \n    function Concat\n      (Left  : Wide_Character;\n-      Right : Super_String)\n-      return  Super_String;\n+      Right : Super_String) return Super_String;\n \n    function Super_Element\n      (Source : Super_String;\n-      Index  : Positive)\n-      return   Wide_Character;\n+      Index  : Positive) return Wide_Character;\n \n    procedure Super_Replace_Element\n      (Source : in out Super_String;\n@@ -159,70 +152,82 @@ pragma Preelaborate (Wide_Superbounded);\n    function Super_Slice\n      (Source : Super_String;\n       Low    : Positive;\n-      High   : Natural)\n-      return   Wide_String;\n+      High   : Natural) return Wide_String;\n+\n+   function Super_Slice\n+     (Source : Super_String;\n+      Low    : Positive;\n+      High   : Natural) return Super_String;\n+\n+   procedure Super_Slice\n+     (Source : Super_String;\n+      Target : out Super_String;\n+      Low    : Positive;\n+      High   : Natural);\n \n-   function \"=\"  (Left, Right : Super_String) return Boolean;\n+   function \"=\"\n+     (Left  : Super_String;\n+      Right : Super_String) return Boolean;\n \n-   function Equal (Left, Right : Super_String) return Boolean renames \"=\";\n+   function Equal\n+     (Left  : Super_String;\n+      Right : Super_String) return Boolean renames \"=\";\n \n    function Equal\n      (Left  : Super_String;\n-      Right : Wide_String)\n-      return  Boolean;\n+      Right : Wide_String) return Boolean;\n \n    function Equal\n      (Left  : Wide_String;\n-      Right : Super_String)\n-      return  Boolean;\n+      Right : Super_String) return Boolean;\n \n-   function Less (Left, Right : Super_String) return Boolean;\n+   function Less\n+     (Left  : Super_String;\n+      Right : Super_String) return Boolean;\n \n    function Less\n      (Left  : Super_String;\n-      Right : Wide_String)\n-      return  Boolean;\n+      Right : Wide_String) return Boolean;\n \n    function Less\n      (Left  : Wide_String;\n-      Right : Super_String)\n-      return  Boolean;\n+      Right : Super_String) return Boolean;\n \n-   function Less_Or_Equal (Left, Right : Super_String) return Boolean;\n+   function Less_Or_Equal\n+     (Left  : Super_String;\n+      Right : Super_String) return Boolean;\n \n    function Less_Or_Equal\n      (Left  : Super_String;\n-      Right : Wide_String)\n-      return  Boolean;\n+      Right : Wide_String) return Boolean;\n \n    function Less_Or_Equal\n      (Left  : Wide_String;\n-      Right : Super_String)\n-      return  Boolean;\n+      Right : Super_String) return Boolean;\n \n-   function Greater  (Left, Right : Super_String) return Boolean;\n+   function Greater\n+     (Left  : Super_String;\n+      Right : Super_String) return Boolean;\n \n    function Greater\n      (Left  : Super_String;\n-      Right : Wide_String)\n-      return  Boolean;\n+      Right : Wide_String) return Boolean;\n \n    function Greater\n      (Left  : Wide_String;\n-      Right : Super_String)\n-      return  Boolean;\n+      Right : Super_String) return Boolean;\n \n-   function Greater_Or_Equal (Left, Right : Super_String) return Boolean;\n+   function Greater_Or_Equal\n+     (Left  : Super_String;\n+      Right : Super_String) return Boolean;\n \n    function Greater_Or_Equal\n      (Left  : Super_String;\n-      Right : Wide_String)\n-      return  Boolean;\n+      Right : Wide_String) return Boolean;\n \n    function Greater_Or_Equal\n      (Left  : Wide_String;\n-      Right : Super_String)\n-      return  Boolean;\n+      Right : Super_String) return Boolean;\n \n    ----------------------\n    -- Search Functions --\n@@ -233,43 +238,65 @@ pragma Preelaborate (Wide_Superbounded);\n       Pattern : Wide_String;\n       Going   : Direction := Forward;\n       Mapping : Wide_Maps.Wide_Character_Mapping := Wide_Maps.Identity)\n-      return    Natural;\n+      return Natural;\n \n    function Super_Index\n      (Source  : Super_String;\n       Pattern : Wide_String;\n       Going   : Direction := Forward;\n-      Mapping : Wide_Maps.Wide_Character_Mapping_Function)\n-      return    Natural;\n+      Mapping : Wide_Maps.Wide_Character_Mapping_Function) return Natural;\n \n    function Super_Index\n      (Source : Super_String;\n       Set    : Wide_Maps.Wide_Character_Set;\n       Test   : Membership := Inside;\n-      Going  : Direction  := Forward)\n-      return   Natural;\n+      Going  : Direction  := Forward) return Natural;\n+\n+   function Super_Index\n+     (Source  : Super_String;\n+      Pattern : Wide_String;\n+      From    : Positive;\n+      Going   : Direction := Forward;\n+      Mapping : Wide_Maps.Wide_Character_Mapping := Wide_Maps.Identity)\n+      return Natural;\n+\n+   function Super_Index\n+     (Source  : Super_String;\n+      Pattern : Wide_String;\n+      From    : Positive;\n+      Going   : Direction := Forward;\n+      Mapping : Wide_Maps.Wide_Character_Mapping_Function) return Natural;\n+\n+   function Super_Index\n+     (Source : Super_String;\n+      Set    : Wide_Maps.Wide_Character_Set;\n+      From   : Positive;\n+      Test   : Membership := Inside;\n+      Going  : Direction := Forward) return Natural;\n+\n+   function Super_Index_Non_Blank\n+     (Source : Super_String;\n+      Going  : Direction := Forward) return Natural;\n \n    function Super_Index_Non_Blank\n      (Source : Super_String;\n-      Going  : Direction := Forward)\n-      return   Natural;\n+      From   : Positive;\n+      Going  : Direction := Forward) return Natural;\n \n    function Super_Count\n      (Source  : Super_String;\n       Pattern : Wide_String;\n       Mapping : Wide_Maps.Wide_Character_Mapping := Wide_Maps.Identity)\n-      return    Natural;\n+      return Natural;\n \n    function Super_Count\n      (Source  : Super_String;\n       Pattern : Wide_String;\n-      Mapping : Wide_Maps.Wide_Character_Mapping_Function)\n-      return    Natural;\n+      Mapping : Wide_Maps.Wide_Character_Mapping_Function) return Natural;\n \n    function Super_Count\n      (Source : Super_String;\n-      Set    : Wide_Maps.Wide_Character_Set)\n-      return   Natural;\n+      Set    : Wide_Maps.Wide_Character_Set) return Natural;\n \n    procedure Super_Find_Token\n      (Source : Super_String;\n@@ -278,53 +305,49 @@ pragma Preelaborate (Wide_Superbounded);\n       First  : out Positive;\n       Last   : out Natural);\n \n-   -----------------------------------------\n-   -- Wide_String Translation Subprograms --\n-   -----------------------------------------\n+   ------------------------------------\n+   -- String Translation Subprograms --\n+   ------------------------------------\n \n    function Super_Translate\n-     (Source   : Super_String;\n-      Mapping  : Wide_Maps.Wide_Character_Mapping)\n-      return     Super_String;\n+     (Source  : Super_String;\n+      Mapping : Wide_Maps.Wide_Character_Mapping) return Super_String;\n \n    procedure Super_Translate\n      (Source   : in out Super_String;\n       Mapping  : Wide_Maps.Wide_Character_Mapping);\n \n    function Super_Translate\n      (Source  : Super_String;\n-      Mapping : Wide_Maps.Wide_Character_Mapping_Function)\n-      return    Super_String;\n+      Mapping : Wide_Maps.Wide_Character_Mapping_Function) return Super_String;\n \n    procedure Super_Translate\n      (Source  : in out Super_String;\n       Mapping : Wide_Maps.Wide_Character_Mapping_Function);\n \n-   --------------------------------------------\n-   -- Wide_String Transformation Subprograms --\n-   --------------------------------------------\n+   ---------------------------------------\n+   -- String Transformation Subprograms --\n+   ---------------------------------------\n \n    function Super_Replace_Slice\n-     (Source   : Super_String;\n-      Low      : Positive;\n-      High     : Natural;\n-      By       : Wide_String;\n-      Drop     : Truncation := Error)\n-      return     Super_String;\n+     (Source : Super_String;\n+      Low    : Positive;\n+      High   : Natural;\n+      By     : Wide_String;\n+      Drop   : Truncation := Error) return Super_String;\n \n    procedure Super_Replace_Slice\n-     (Source   : in out Super_String;\n-      Low      : Positive;\n-      High     : Natural;\n-      By       : Wide_String;\n-      Drop     : Truncation := Error);\n+     (Source  : in out Super_String;\n+      Low     : Positive;\n+      High    : Natural;\n+      By      : Wide_String;\n+      Drop    : Truncation := Error);\n \n    function Super_Insert\n      (Source   : Super_String;\n       Before   : Positive;\n       New_Item : Wide_String;\n-      Drop     : Truncation := Error)\n-      return     Super_String;\n+      Drop     : Truncation := Error) return Super_String;\n \n    procedure Super_Insert\n      (Source   : in out Super_String;\n@@ -333,11 +356,10 @@ pragma Preelaborate (Wide_Superbounded);\n       Drop     : Truncation := Error);\n \n    function Super_Overwrite\n-     (Source    : Super_String;\n-      Position  : Positive;\n-      New_Item  : Wide_String;\n-      Drop      : Truncation := Error)\n-      return      Super_String;\n+     (Source   : Super_String;\n+      Position : Positive;\n+      New_Item : Wide_String;\n+      Drop     : Truncation := Error) return Super_String;\n \n    procedure Super_Overwrite\n      (Source    : in out Super_String;\n@@ -348,32 +370,29 @@ pragma Preelaborate (Wide_Superbounded);\n    function Super_Delete\n      (Source  : Super_String;\n       From    : Positive;\n-      Through : Natural)\n-      return    Super_String;\n+      Through : Natural) return Super_String;\n \n    procedure Super_Delete\n      (Source  : in out Super_String;\n       From    : Positive;\n       Through : Natural);\n \n-   --------------------------------------\n-   -- Wide_String Selector Subprograms --\n-   --------------------------------------\n+   ---------------------------------\n+   -- String Selector Subprograms --\n+   ---------------------------------\n \n    function Super_Trim\n      (Source : Super_String;\n-      Side   : Trim_End)\n-      return   Super_String;\n+      Side   : Trim_End) return Super_String;\n \n    procedure Super_Trim\n      (Source : in out Super_String;\n       Side   : Trim_End);\n \n    function Super_Trim\n-     (Source  : Super_String;\n+     (Source : Super_String;\n       Left   : Wide_Maps.Wide_Character_Set;\n-      Right  : Wide_Maps.Wide_Character_Set)\n-      return   Super_String;\n+      Right  : Wide_Maps.Wide_Character_Set) return Super_String;\n \n    procedure Super_Trim\n      (Source : in out Super_String;\n@@ -384,30 +403,28 @@ pragma Preelaborate (Wide_Superbounded);\n      (Source : Super_String;\n       Count  : Natural;\n       Pad    : Wide_Character := Wide_Space;\n-      Drop   : Truncation     := Error)\n-      return   Super_String;\n+      Drop   : Truncation := Error) return Super_String;\n \n    procedure Super_Head\n      (Source : in out Super_String;\n       Count  : Natural;\n       Pad    : Wide_Character := Wide_Space;\n-      Drop   : Truncation     := Error);\n+      Drop   : Truncation := Error);\n \n    function Super_Tail\n      (Source : Super_String;\n       Count  : Natural;\n       Pad    : Wide_Character := Wide_Space;\n-      Drop   : Truncation     := Error)\n-      return Super_String;\n+      Drop   : Truncation := Error) return Super_String;\n \n    procedure Super_Tail\n      (Source : in out Super_String;\n       Count  : Natural;\n       Pad    : Wide_Character := Wide_Space;\n-      Drop   : Truncation     := Error);\n+      Drop   : Truncation := Error);\n \n    ------------------------------------\n-   -- Wide_String Constructor Subprograms --\n+   -- String Constructor Subprograms --\n    ------------------------------------\n \n    --  Note: in some of the following routines, there is an extra parameter\n@@ -417,46 +434,39 @@ pragma Preelaborate (Wide_Superbounded);\n    function Times\n      (Left       : Natural;\n       Right      : Wide_Character;\n-      Max_Length : Positive)\n-      return       Super_String;\n+      Max_Length : Positive) return Super_String;\n    --  Note the additional parameter Max_Length\n \n    function Times\n      (Left       : Natural;\n       Right      : Wide_String;\n-      Max_Length : Positive)\n-      return       Super_String;\n+      Max_Length : Positive) return Super_String;\n    --  Note the additional parameter Max_Length\n \n    function Times\n      (Left  : Natural;\n-      Right : Super_String)\n-      return  Super_String;\n+      Right : Super_String) return Super_String;\n \n    function Super_Replicate\n      (Count      : Natural;\n       Item       : Wide_Character;\n       Drop       : Truncation := Error;\n-      Max_Length : Positive)\n-      return       Super_String;\n+      Max_Length : Positive) return Super_String;\n    --  Note the additional parameter Max_Length\n \n    function Super_Replicate\n      (Count      : Natural;\n       Item       : Wide_String;\n       Drop       : Truncation := Error;\n-      Max_Length : Positive)\n-      return       Super_String;\n+      Max_Length : Positive) return Super_String;\n    --  Note the additional parameter Max_Length\n \n    function Super_Replicate\n      (Count : Natural;\n       Item  : Super_String;\n-      Drop  : Truncation := Error)\n-      return  Super_String;\n+      Drop  : Truncation := Error) return Super_String;\n \n private\n-\n       --  Pragma Inline declarations\n \n       pragma Inline (\"=\");"}, {"sha": "b4217720079b7e280716f9c4b908e0beb2890713", "filename": "gcc/ada/a-stwiun.adb", "status": "modified", "additions": 69, "deletions": 113, "changes": 182, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/82c80734715c801643075ab68c5c9a5e00da1b03/gcc%2Fada%2Fa-stwiun.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/82c80734715c801643075ab68c5c9a5e00da1b03/gcc%2Fada%2Fa-stwiun.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-stwiun.adb?ref=82c80734715c801643075ab68c5c9a5e00da1b03", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1992-2002 Free Software Foundation, Inc.          --\n+--          Copyright (C) 1992-2005 Free Software Foundation, Inc.          --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -55,8 +55,7 @@ package body Ada.Strings.Wide_Unbounded is\n \n    function \"&\"\n      (Left  : Unbounded_Wide_String;\n-      Right : Unbounded_Wide_String)\n-      return  Unbounded_Wide_String\n+      Right : Unbounded_Wide_String) return Unbounded_Wide_String\n    is\n       L_Length : constant Natural := Left.Last;\n       R_Length : constant Natural := Right.Last;\n@@ -77,8 +76,7 @@ package body Ada.Strings.Wide_Unbounded is\n \n    function \"&\"\n      (Left  : Unbounded_Wide_String;\n-      Right : Wide_String)\n-      return  Unbounded_Wide_String\n+      Right : Wide_String) return Unbounded_Wide_String\n    is\n       L_Length : constant Natural := Left.Last;\n       Result   : Unbounded_Wide_String;\n@@ -96,8 +94,7 @@ package body Ada.Strings.Wide_Unbounded is\n \n    function \"&\"\n      (Left  : Wide_String;\n-      Right : Unbounded_Wide_String)\n-      return  Unbounded_Wide_String\n+      Right : Unbounded_Wide_String) return Unbounded_Wide_String\n    is\n       R_Length : constant Natural := Right.Last;\n       Result   : Unbounded_Wide_String;\n@@ -116,8 +113,7 @@ package body Ada.Strings.Wide_Unbounded is\n \n    function \"&\"\n      (Left  : Unbounded_Wide_String;\n-      Right : Wide_Character)\n-      return  Unbounded_Wide_String\n+      Right : Wide_Character) return Unbounded_Wide_String\n    is\n       Result : Unbounded_Wide_String;\n \n@@ -135,8 +131,7 @@ package body Ada.Strings.Wide_Unbounded is\n \n    function \"&\"\n      (Left  : Wide_Character;\n-      Right : Unbounded_Wide_String)\n-      return  Unbounded_Wide_String\n+      Right : Unbounded_Wide_String) return Unbounded_Wide_String\n    is\n       Result : Unbounded_Wide_String;\n \n@@ -157,8 +152,7 @@ package body Ada.Strings.Wide_Unbounded is\n \n    function \"*\"\n      (Left  : Natural;\n-      Right : Wide_Character)\n-      return  Unbounded_Wide_String\n+      Right : Wide_Character) return Unbounded_Wide_String\n    is\n       Result : Unbounded_Wide_String;\n \n@@ -174,9 +168,8 @@ package body Ada.Strings.Wide_Unbounded is\n    end \"*\";\n \n    function \"*\"\n-     (Left   : Natural;\n-      Right  : Wide_String)\n-      return   Unbounded_Wide_String\n+     (Left  : Natural;\n+      Right : Wide_String) return Unbounded_Wide_String\n    is\n       Len    : constant Natural := Right'Length;\n       K      : Positive;\n@@ -198,8 +191,7 @@ package body Ada.Strings.Wide_Unbounded is\n \n    function \"*\"\n      (Left  : Natural;\n-      Right : Unbounded_Wide_String)\n-      return  Unbounded_Wide_String\n+      Right : Unbounded_Wide_String) return Unbounded_Wide_String\n    is\n       Len    : constant Natural := Right.Last;\n       K      : Positive;\n@@ -226,8 +218,7 @@ package body Ada.Strings.Wide_Unbounded is\n \n    function \"<\"\n      (Left  : Unbounded_Wide_String;\n-      Right : Unbounded_Wide_String)\n-      return  Boolean\n+      Right : Unbounded_Wide_String) return Boolean\n    is\n    begin\n       return\n@@ -236,17 +227,15 @@ package body Ada.Strings.Wide_Unbounded is\n \n    function \"<\"\n      (Left  : Unbounded_Wide_String;\n-      Right : Wide_String)\n-      return  Boolean\n+      Right : Wide_String) return Boolean\n    is\n    begin\n       return Left.Reference (1 .. Left.Last) < Right;\n    end \"<\";\n \n    function \"<\"\n      (Left  : Wide_String;\n-      Right : Unbounded_Wide_String)\n-      return  Boolean\n+      Right : Unbounded_Wide_String) return Boolean\n    is\n    begin\n       return Left < Right.Reference (1 .. Right.Last);\n@@ -258,8 +247,7 @@ package body Ada.Strings.Wide_Unbounded is\n \n    function \"<=\"\n      (Left  : Unbounded_Wide_String;\n-      Right : Unbounded_Wide_String)\n-      return  Boolean\n+      Right : Unbounded_Wide_String) return Boolean\n    is\n    begin\n       return\n@@ -268,17 +256,15 @@ package body Ada.Strings.Wide_Unbounded is\n \n    function \"<=\"\n      (Left  : Unbounded_Wide_String;\n-      Right : Wide_String)\n-      return  Boolean\n+      Right : Wide_String) return Boolean\n    is\n    begin\n       return Left.Reference (1 .. Left.Last) <= Right;\n    end \"<=\";\n \n    function \"<=\"\n      (Left  : Wide_String;\n-      Right : Unbounded_Wide_String)\n-      return  Boolean\n+      Right : Unbounded_Wide_String) return Boolean\n    is\n    begin\n       return Left <= Right.Reference (1 .. Right.Last);\n@@ -290,8 +276,7 @@ package body Ada.Strings.Wide_Unbounded is\n \n    function \"=\"\n      (Left  : Unbounded_Wide_String;\n-      Right : Unbounded_Wide_String)\n-      return  Boolean\n+      Right : Unbounded_Wide_String) return Boolean\n    is\n    begin\n       return\n@@ -300,17 +285,15 @@ package body Ada.Strings.Wide_Unbounded is\n \n    function \"=\"\n      (Left  : Unbounded_Wide_String;\n-      Right : Wide_String)\n-      return  Boolean\n+      Right : Wide_String) return Boolean\n    is\n    begin\n       return Left.Reference (1 .. Left.Last) = Right;\n    end \"=\";\n \n    function \"=\"\n      (Left  : Wide_String;\n-      Right : Unbounded_Wide_String)\n-      return  Boolean\n+      Right : Unbounded_Wide_String) return Boolean\n    is\n    begin\n       return Left = Right.Reference (1 .. Right.Last);\n@@ -322,8 +305,7 @@ package body Ada.Strings.Wide_Unbounded is\n \n    function \">\"\n      (Left  : Unbounded_Wide_String;\n-      Right : Unbounded_Wide_String)\n-      return  Boolean\n+      Right : Unbounded_Wide_String) return Boolean\n    is\n    begin\n       return\n@@ -332,17 +314,15 @@ package body Ada.Strings.Wide_Unbounded is\n \n    function \">\"\n      (Left  : Unbounded_Wide_String;\n-      Right : Wide_String)\n-      return  Boolean\n+      Right : Wide_String) return Boolean\n    is\n    begin\n       return Left.Reference (1 .. Left.Last) > Right;\n    end \">\";\n \n    function \">\"\n      (Left  : Wide_String;\n-      Right : Unbounded_Wide_String)\n-      return  Boolean\n+      Right : Unbounded_Wide_String) return Boolean\n    is\n    begin\n       return Left > Right.Reference (1 .. Right.Last);\n@@ -354,8 +334,7 @@ package body Ada.Strings.Wide_Unbounded is\n \n    function \">=\"\n      (Left  : Unbounded_Wide_String;\n-      Right : Unbounded_Wide_String)\n-      return  Boolean\n+      Right : Unbounded_Wide_String) return Boolean\n    is\n    begin\n       return\n@@ -364,17 +343,15 @@ package body Ada.Strings.Wide_Unbounded is\n \n    function \">=\"\n      (Left  : Unbounded_Wide_String;\n-      Right : Wide_String)\n-      return  Boolean\n+      Right : Wide_String) return Boolean\n    is\n    begin\n       return Left.Reference (1 .. Left.Last) >= Right;\n    end \">=\";\n \n    function \">=\"\n      (Left  : Wide_String;\n-      Right : Unbounded_Wide_String)\n-      return  Boolean\n+      Right : Unbounded_Wide_String) return Boolean\n    is\n    begin\n       return Left >= Right.Reference (1 .. Right.Last);\n@@ -438,32 +415,30 @@ package body Ada.Strings.Wide_Unbounded is\n    -----------\n \n    function Count\n-     (Source   : Unbounded_Wide_String;\n-      Pattern  : Wide_String;\n-      Mapping  : Wide_Maps.Wide_Character_Mapping :=\n-                        Wide_Maps.Identity)\n-      return     Natural\n+     (Source  : Unbounded_Wide_String;\n+      Pattern : Wide_String;\n+      Mapping : Wide_Maps.Wide_Character_Mapping :=\n+                  Wide_Maps.Identity)\n+      return Natural\n    is\n    begin\n       return Wide_Search.Count\n         (Source.Reference (1 .. Source.Last), Pattern, Mapping);\n    end Count;\n \n    function Count\n-     (Source   : Unbounded_Wide_String;\n-      Pattern  : Wide_String;\n-      Mapping  : Wide_Maps.Wide_Character_Mapping_Function)\n-      return     Natural\n+     (Source  : Unbounded_Wide_String;\n+      Pattern : Wide_String;\n+      Mapping : Wide_Maps.Wide_Character_Mapping_Function) return Natural\n    is\n    begin\n       return Wide_Search.Count\n         (Source.Reference (1 .. Source.Last), Pattern, Mapping);\n    end Count;\n \n    function Count\n-     (Source   : Unbounded_Wide_String;\n-      Set      : Wide_Maps.Wide_Character_Set)\n-      return     Natural\n+     (Source : Unbounded_Wide_String;\n+      Set    : Wide_Maps.Wide_Character_Set) return Natural\n    is\n    begin\n       return Wide_Search.Count (Source.Reference (1 .. Source.Last), Set);\n@@ -476,8 +451,7 @@ package body Ada.Strings.Wide_Unbounded is\n    function Delete\n      (Source  : Unbounded_Wide_String;\n       From    : Positive;\n-      Through : Natural)\n-      return    Unbounded_Wide_String\n+      Through : Natural) return Unbounded_Wide_String\n    is\n    begin\n       return To_Unbounded_Wide_String\n@@ -515,8 +489,7 @@ package body Ada.Strings.Wide_Unbounded is\n \n    function Element\n      (Source : Unbounded_Wide_String;\n-      Index  : Positive)\n-      return   Wide_Character\n+      Index  : Positive) return Wide_Character\n    is\n    begin\n       if Index <= Source.Last then\n@@ -581,8 +554,7 @@ package body Ada.Strings.Wide_Unbounded is\n    function Head\n      (Source : Unbounded_Wide_String;\n       Count  : Natural;\n-      Pad    : Wide_Character := Wide_Space)\n-      return   Unbounded_Wide_String\n+      Pad    : Wide_Character := Wide_Space) return Unbounded_Wide_String\n    is\n    begin\n       return\n@@ -609,24 +581,22 @@ package body Ada.Strings.Wide_Unbounded is\n    -----------\n \n    function Index\n-     (Source   : Unbounded_Wide_String;\n-      Pattern  : Wide_String;\n-      Going    : Strings.Direction := Strings.Forward;\n-      Mapping  : Wide_Maps.Wide_Character_Mapping :=\n-                        Wide_Maps.Identity)\n-      return     Natural\n+     (Source  : Unbounded_Wide_String;\n+      Pattern : Wide_String;\n+      Going   : Strings.Direction := Strings.Forward;\n+      Mapping : Wide_Maps.Wide_Character_Mapping :=\n+                        Wide_Maps.Identity) return Natural\n    is\n    begin\n       return Wide_Search.Index\n         (Source.Reference (1 .. Source.Last), Pattern, Going, Mapping);\n    end Index;\n \n    function Index\n-     (Source   : Unbounded_Wide_String;\n-      Pattern  : Wide_String;\n-      Going    : Direction := Forward;\n-      Mapping  : Wide_Maps.Wide_Character_Mapping_Function)\n-      return Natural\n+     (Source  : Unbounded_Wide_String;\n+      Pattern : Wide_String;\n+      Going   : Direction := Forward;\n+      Mapping : Wide_Maps.Wide_Character_Mapping_Function) return Natural\n    is\n    begin\n       return Wide_Search.Index\n@@ -637,8 +607,7 @@ package body Ada.Strings.Wide_Unbounded is\n      (Source : Unbounded_Wide_String;\n       Set    : Wide_Maps.Wide_Character_Set;\n       Test   : Strings.Membership := Strings.Inside;\n-      Going  : Strings.Direction  := Strings.Forward)\n-      return   Natural\n+      Going  : Strings.Direction  := Strings.Forward) return Natural\n    is\n    begin\n       return Wide_Search.Index\n@@ -647,8 +616,7 @@ package body Ada.Strings.Wide_Unbounded is\n \n    function Index_Non_Blank\n      (Source : Unbounded_Wide_String;\n-      Going  : Strings.Direction := Strings.Forward)\n-      return   Natural\n+      Going  : Strings.Direction := Strings.Forward) return Natural\n    is\n    begin\n       return Wide_Search.Index_Non_Blank\n@@ -672,8 +640,7 @@ package body Ada.Strings.Wide_Unbounded is\n    function Insert\n      (Source   : Unbounded_Wide_String;\n       Before   : Positive;\n-      New_Item : Wide_String)\n-      return     Unbounded_Wide_String\n+      New_Item : Wide_String) return Unbounded_Wide_String\n    is\n    begin\n       return To_Unbounded_Wide_String\n@@ -715,11 +682,10 @@ package body Ada.Strings.Wide_Unbounded is\n    ---------------\n \n    function Overwrite\n-     (Source    : Unbounded_Wide_String;\n-      Position  : Positive;\n-      New_Item  : Wide_String)\n-      return      Unbounded_Wide_String is\n-\n+     (Source   : Unbounded_Wide_String;\n+      Position : Positive;\n+      New_Item : Wide_String) return Unbounded_Wide_String\n+   is\n    begin\n       return To_Unbounded_Wide_String\n         (Wide_Fixed.Overwrite\n@@ -800,11 +766,10 @@ package body Ada.Strings.Wide_Unbounded is\n    -------------------\n \n    function Replace_Slice\n-     (Source   : Unbounded_Wide_String;\n-      Low      : Positive;\n-      High     : Natural;\n-      By       : Wide_String)\n-      return     Unbounded_Wide_String\n+     (Source : Unbounded_Wide_String;\n+      Low    : Positive;\n+      High   : Natural;\n+      By     : Wide_String) return Unbounded_Wide_String\n    is\n    begin\n       return\n@@ -836,8 +801,7 @@ package body Ada.Strings.Wide_Unbounded is\n    function Slice\n      (Source : Unbounded_Wide_String;\n       Low    : Positive;\n-      High   : Natural)\n-      return   Wide_String\n+      High   : Natural) return Wide_String\n    is\n    begin\n       --  Note: test of High > Length is in accordance with AI95-00128\n@@ -857,9 +821,8 @@ package body Ada.Strings.Wide_Unbounded is\n    function Tail\n      (Source : Unbounded_Wide_String;\n       Count  : Natural;\n-      Pad    : Wide_Character := Wide_Space)\n-      return   Unbounded_Wide_String is\n-\n+      Pad    : Wide_Character := Wide_Space) return Unbounded_Wide_String\n+   is\n    begin\n       return To_Unbounded_Wide_String\n         (Wide_Fixed.Tail (Source.Reference (1 .. Source.Last), Count, Pad));\n@@ -884,23 +847,20 @@ package body Ada.Strings.Wide_Unbounded is\n    ------------------------------\n \n    function To_Unbounded_Wide_String\n-     (Source : Wide_String)\n-      return   Unbounded_Wide_String\n+     (Source : Wide_String) return Unbounded_Wide_String\n    is\n       Result : Unbounded_Wide_String;\n-\n    begin\n       Result.Last          := Source'Length;\n       Result.Reference     := new Wide_String (1 .. Source'Length);\n       Result.Reference.all := Source;\n       return Result;\n    end To_Unbounded_Wide_String;\n \n-   function To_Unbounded_Wide_String (Length : Natural)\n-      return Unbounded_Wide_String\n+   function To_Unbounded_Wide_String\n+     (Length : Natural) return Unbounded_Wide_String\n    is\n       Result : Unbounded_Wide_String;\n-\n    begin\n       Result.Last      := Length;\n       Result.Reference := new Wide_String (1 .. Length);\n@@ -912,8 +872,7 @@ package body Ada.Strings.Wide_Unbounded is\n    --------------------\n \n    function To_Wide_String\n-     (Source : Unbounded_Wide_String)\n-      return   Wide_String\n+     (Source : Unbounded_Wide_String) return Wide_String\n    is\n    begin\n       return Source.Reference (1 .. Source.Last);\n@@ -925,8 +884,7 @@ package body Ada.Strings.Wide_Unbounded is\n \n    function Translate\n      (Source  : Unbounded_Wide_String;\n-      Mapping : Wide_Maps.Wide_Character_Mapping)\n-      return    Unbounded_Wide_String\n+      Mapping : Wide_Maps.Wide_Character_Mapping) return Unbounded_Wide_String\n    is\n    begin\n       return To_Unbounded_Wide_String\n@@ -944,7 +902,7 @@ package body Ada.Strings.Wide_Unbounded is\n    function Translate\n      (Source  : Unbounded_Wide_String;\n       Mapping : Wide_Maps.Wide_Character_Mapping_Function)\n-      return    Unbounded_Wide_String\n+      return Unbounded_Wide_String\n    is\n    begin\n       return To_Unbounded_Wide_String\n@@ -965,8 +923,7 @@ package body Ada.Strings.Wide_Unbounded is\n \n    function Trim\n      (Source : Unbounded_Wide_String;\n-      Side   : Trim_End)\n-      return   Unbounded_Wide_String\n+      Side   : Trim_End) return Unbounded_Wide_String\n    is\n    begin\n       return To_Unbounded_Wide_String\n@@ -988,8 +945,7 @@ package body Ada.Strings.Wide_Unbounded is\n    function Trim\n      (Source : Unbounded_Wide_String;\n       Left   : Wide_Maps.Wide_Character_Set;\n-      Right  : Wide_Maps.Wide_Character_Set)\n-      return   Unbounded_Wide_String\n+      Right  : Wide_Maps.Wide_Character_Set) return Unbounded_Wide_String\n    is\n    begin\n       return To_Unbounded_Wide_String"}, {"sha": "ed231b2e66cb8be15bb62322692deaad84b35a3d", "filename": "gcc/ada/a-stwiun.ads", "status": "modified", "additions": 131, "deletions": 173, "changes": 304, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/82c80734715c801643075ab68c5c9a5e00da1b03/gcc%2Fada%2Fa-stwiun.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/82c80734715c801643075ab68c5c9a5e00da1b03/gcc%2Fada%2Fa-stwiun.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-stwiun.ads?ref=82c80734715c801643075ab68c5c9a5e00da1b03", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---          Copyright (C) 1992-2002 Free Software Foundation, Inc.          --\n+--          Copyright (C) 1992-2005 Free Software Foundation, Inc.          --\n --                                                                          --\n -- This specification is derived from the Ada Reference Manual for use with --\n -- GNAT. The copyright notice above, and the license provisions that follow --\n@@ -56,195 +56,165 @@ pragma Preelaborate (Wide_Unbounded);\n    --------------------------------------------------------\n \n    function To_Unbounded_Wide_String\n-     (Source : Wide_String)\n-      return   Unbounded_Wide_String;\n+     (Source : Wide_String) return Unbounded_Wide_String;\n \n    function To_Unbounded_Wide_String\n-     (Length : in Natural)\n-      return   Unbounded_Wide_String;\n+     (Length : Natural) return Unbounded_Wide_String;\n \n    function To_Wide_String\n-     (Source : Unbounded_Wide_String)\n-      return   Wide_String;\n+     (Source : Unbounded_Wide_String) return Wide_String;\n \n    procedure Append\n      (Source   : in out Unbounded_Wide_String;\n-      New_Item : in Unbounded_Wide_String);\n+      New_Item : Unbounded_Wide_String);\n \n    procedure Append\n      (Source   : in out Unbounded_Wide_String;\n-      New_Item : in Wide_String);\n+      New_Item : Wide_String);\n \n    procedure Append\n      (Source   : in out Unbounded_Wide_String;\n-      New_Item : in Wide_Character);\n+      New_Item : Wide_Character);\n \n    function \"&\"\n-     (Left, Right : Unbounded_Wide_String)\n-      return        Unbounded_Wide_String;\n+     (Left, Right : Unbounded_Wide_String) return Unbounded_Wide_String;\n \n    function \"&\"\n-     (Left  : in Unbounded_Wide_String;\n-      Right : in Wide_String)\n-      return  Unbounded_Wide_String;\n+     (Left  : Unbounded_Wide_String;\n+      Right : Wide_String) return Unbounded_Wide_String;\n \n    function \"&\"\n-     (Left  : in Wide_String;\n-      Right : in Unbounded_Wide_String)\n-      return  Unbounded_Wide_String;\n+     (Left  : Wide_String;\n+      Right : Unbounded_Wide_String) return Unbounded_Wide_String;\n \n    function \"&\"\n-     (Left  : in Unbounded_Wide_String;\n-      Right : in Wide_Character)\n-      return  Unbounded_Wide_String;\n+     (Left  : Unbounded_Wide_String;\n+      Right : Wide_Character) return Unbounded_Wide_String;\n \n    function \"&\"\n-     (Left  : in Wide_Character;\n-      Right : in Unbounded_Wide_String)\n-      return  Unbounded_Wide_String;\n+     (Left  : Wide_Character;\n+      Right : Unbounded_Wide_String) return Unbounded_Wide_String;\n \n    function Element\n-     (Source : in Unbounded_Wide_String;\n-      Index  : in Positive)\n-      return   Wide_Character;\n+     (Source : Unbounded_Wide_String;\n+      Index  : Positive) return Wide_Character;\n \n    procedure Replace_Element\n      (Source : in out Unbounded_Wide_String;\n-      Index  : in Positive;\n+      Index  : Positive;\n       By     : Wide_Character);\n \n    function Slice\n-     (Source : in Unbounded_Wide_String;\n-      Low    : in Positive;\n-      High   : in Natural)\n-      return   Wide_String;\n+     (Source : Unbounded_Wide_String;\n+      Low    : Positive;\n+      High   : Natural) return Wide_String;\n \n    function \"=\"\n-     (Left  : in Unbounded_Wide_String;\n-      Right : in Unbounded_Wide_String)\n-      return  Boolean;\n+     (Left  : Unbounded_Wide_String;\n+      Right : Unbounded_Wide_String) return Boolean;\n \n    function \"=\"\n-     (Left  : in Unbounded_Wide_String;\n-      Right : in Wide_String)\n-      return  Boolean;\n+     (Left  : Unbounded_Wide_String;\n+      Right : Wide_String) return Boolean;\n \n    function \"=\"\n-     (Left  : in Wide_String;\n-      Right : in Unbounded_Wide_String)\n-      return  Boolean;\n+     (Left  : Wide_String;\n+      Right : Unbounded_Wide_String) return Boolean;\n \n    function \"<\"\n-     (Left  : in Unbounded_Wide_String;\n-      Right : in Unbounded_Wide_String)\n-      return  Boolean;\n+     (Left  : Unbounded_Wide_String;\n+      Right : Unbounded_Wide_String) return Boolean;\n \n    function \"<\"\n-     (Left  : in Unbounded_Wide_String;\n-      Right : in Wide_String)\n-      return  Boolean;\n+     (Left  : Unbounded_Wide_String;\n+      Right : Wide_String) return Boolean;\n \n    function \"<\"\n-     (Left  : in Wide_String;\n-      Right : in Unbounded_Wide_String)\n-      return  Boolean;\n+     (Left  : Wide_String;\n+      Right : Unbounded_Wide_String) return Boolean;\n \n    function \"<=\"\n-     (Left  : in Unbounded_Wide_String;\n-      Right : in Unbounded_Wide_String)\n-      return  Boolean;\n+     (Left  : Unbounded_Wide_String;\n+      Right : Unbounded_Wide_String) return Boolean;\n \n    function \"<=\"\n-     (Left  : in Unbounded_Wide_String;\n-      Right : in Wide_String)\n-      return  Boolean;\n+     (Left  : Unbounded_Wide_String;\n+      Right : Wide_String) return Boolean;\n \n    function \"<=\"\n-     (Left  : in Wide_String;\n-      Right : in Unbounded_Wide_String)\n-      return  Boolean;\n+     (Left  : Wide_String;\n+      Right : Unbounded_Wide_String) return Boolean;\n \n    function \">\"\n-     (Left  : in Unbounded_Wide_String;\n-      Right : in Unbounded_Wide_String)\n-      return  Boolean;\n+     (Left  : Unbounded_Wide_String;\n+      Right : Unbounded_Wide_String) return Boolean;\n \n    function \">\"\n-     (Left  : in Unbounded_Wide_String;\n-      Right : in Wide_String)\n-      return  Boolean;\n+     (Left  : Unbounded_Wide_String;\n+      Right : Wide_String) return Boolean;\n \n    function \">\"\n-     (Left  : in Wide_String;\n-      Right : in Unbounded_Wide_String)\n-      return  Boolean;\n+     (Left  : Wide_String;\n+      Right : Unbounded_Wide_String) return Boolean;\n \n    function \">=\"\n-     (Left  : in Unbounded_Wide_String;\n-      Right : in Unbounded_Wide_String)\n-      return  Boolean;\n+     (Left  : Unbounded_Wide_String;\n+      Right : Unbounded_Wide_String) return Boolean;\n \n    function \">=\"\n-     (Left  : in Unbounded_Wide_String;\n-      Right : in Wide_String)\n-      return  Boolean;\n+     (Left  : Unbounded_Wide_String;\n+      Right : Wide_String) return Boolean;\n \n    function \">=\"\n-     (Left  : in Wide_String;\n-      Right : in Unbounded_Wide_String)\n-      return  Boolean;\n+     (Left  : Wide_String;\n+      Right : Unbounded_Wide_String) return Boolean;\n \n    ------------------------\n    -- Search Subprograms --\n    ------------------------\n \n    function Index\n-     (Source   : in Unbounded_Wide_String;\n-      Pattern  : in Wide_String;\n-      Going    : in Direction := Forward;\n-      Mapping  : in Wide_Maps.Wide_Character_Mapping := Wide_Maps.Identity)\n-      return     Natural;\n+     (Source  : Unbounded_Wide_String;\n+      Pattern : Wide_String;\n+      Going   : Direction := Forward;\n+      Mapping : Wide_Maps.Wide_Character_Mapping := Wide_Maps.Identity)\n+      return Natural;\n \n    function Index\n-     (Source   : in Unbounded_Wide_String;\n-      Pattern  : in Wide_String;\n-      Going    : in Direction := Forward;\n-      Mapping  : in Wide_Maps.Wide_Character_Mapping_Function)\n-      return     Natural;\n+     (Source  : Unbounded_Wide_String;\n+      Pattern : Wide_String;\n+      Going   : Direction := Forward;\n+      Mapping : Wide_Maps.Wide_Character_Mapping_Function) return Natural;\n \n    function Index\n-     (Source : in Unbounded_Wide_String;\n-      Set    : in Wide_Maps.Wide_Character_Set;\n-      Test   : in Membership := Inside;\n-      Going  : in Direction  := Forward)\n-      return   Natural;\n+     (Source : Unbounded_Wide_String;\n+      Set    : Wide_Maps.Wide_Character_Set;\n+      Test   : Membership := Inside;\n+      Going  : Direction  := Forward) return Natural;\n \n    function Index_Non_Blank\n-     (Source : in Unbounded_Wide_String;\n-      Going  : in Direction := Forward)\n-      return   Natural;\n+     (Source : Unbounded_Wide_String;\n+      Going  : Direction := Forward) return Natural;\n \n    function Count\n-     (Source  : in Unbounded_Wide_String;\n-      Pattern : in Wide_String;\n-      Mapping : in Wide_Maps.Wide_Character_Mapping := Wide_Maps.Identity)\n-      return    Natural;\n+     (Source  : Unbounded_Wide_String;\n+      Pattern : Wide_String;\n+      Mapping : Wide_Maps.Wide_Character_Mapping := Wide_Maps.Identity)\n+      return Natural;\n \n    function Count\n-     (Source   : in Unbounded_Wide_String;\n-      Pattern  : in Wide_String;\n-      Mapping  : in Wide_Maps.Wide_Character_Mapping_Function)\n-      return     Natural;\n+     (Source  : Unbounded_Wide_String;\n+      Pattern : Wide_String;\n+      Mapping : Wide_Maps.Wide_Character_Mapping_Function) return Natural;\n \n    function Count\n-     (Source : in Unbounded_Wide_String;\n-      Set    : in Wide_Maps.Wide_Character_Set)\n-      return   Natural;\n+     (Source : Unbounded_Wide_String;\n+      Set    : Wide_Maps.Wide_Character_Set) return Natural;\n \n    procedure Find_Token\n-     (Source : in Unbounded_Wide_String;\n-      Set    : in Wide_Maps.Wide_Character_Set;\n-      Test   : in Membership;\n+     (Source : Unbounded_Wide_String;\n+      Set    : Wide_Maps.Wide_Character_Set;\n+      Test   : Membership;\n       First  : out Positive;\n       Last   : out Natural);\n \n@@ -253,129 +223,117 @@ pragma Preelaborate (Wide_Unbounded);\n    ------------------------------------\n \n    function Translate\n-     (Source  : in Unbounded_Wide_String;\n-      Mapping : in Wide_Maps.Wide_Character_Mapping)\n-      return    Unbounded_Wide_String;\n+     (Source  : Unbounded_Wide_String;\n+      Mapping : Wide_Maps.Wide_Character_Mapping) return Unbounded_Wide_String;\n \n    procedure Translate\n      (Source  : in out Unbounded_Wide_String;\n       Mapping : Wide_Maps.Wide_Character_Mapping);\n \n    function Translate\n-     (Source  : in Unbounded_Wide_String;\n-      Mapping : in Wide_Maps.Wide_Character_Mapping_Function)\n-      return    Unbounded_Wide_String;\n+     (Source  : Unbounded_Wide_String;\n+      Mapping : Wide_Maps.Wide_Character_Mapping_Function)\n+      return Unbounded_Wide_String;\n \n    procedure Translate\n      (Source  : in out Unbounded_Wide_String;\n-      Mapping : in Wide_Maps.Wide_Character_Mapping_Function);\n+      Mapping : Wide_Maps.Wide_Character_Mapping_Function);\n \n    ---------------------------------------\n    -- Wide_String Transformation Subprograms --\n    ---------------------------------------\n \n    function Replace_Slice\n-     (Source : in Unbounded_Wide_String;\n-      Low    : in Positive;\n-      High   : in Natural;\n-      By     : in Wide_String)\n-      return   Unbounded_Wide_String;\n+     (Source : Unbounded_Wide_String;\n+      Low    : Positive;\n+      High   : Natural;\n+      By     : Wide_String) return Unbounded_Wide_String;\n \n    procedure Replace_Slice\n      (Source   : in out Unbounded_Wide_String;\n-      Low      : in Positive;\n-      High     : in Natural;\n-      By       : in Wide_String);\n+      Low      : Positive;\n+      High     : Natural;\n+      By       : Wide_String);\n \n    function Insert\n-     (Source   : in Unbounded_Wide_String;\n-      Before   : in Positive;\n-      New_Item : in Wide_String)\n-      return     Unbounded_Wide_String;\n+     (Source   : Unbounded_Wide_String;\n+      Before   : Positive;\n+      New_Item : Wide_String) return Unbounded_Wide_String;\n \n    procedure Insert\n      (Source   : in out Unbounded_Wide_String;\n-      Before   : in Positive;\n-      New_Item : in Wide_String);\n+      Before   : Positive;\n+      New_Item : Wide_String);\n \n    function Overwrite\n-     (Source   : in Unbounded_Wide_String;\n-      Position : in Positive;\n-      New_Item : in Wide_String)\n-      return     Unbounded_Wide_String;\n+     (Source   : Unbounded_Wide_String;\n+      Position : Positive;\n+      New_Item : Wide_String) return Unbounded_Wide_String;\n \n    procedure Overwrite\n      (Source    : in out Unbounded_Wide_String;\n-      Position  : in Positive;\n-      New_Item  : in Wide_String);\n+      Position  : Positive;\n+      New_Item  : Wide_String);\n \n    function Delete\n-     (Source  : in Unbounded_Wide_String;\n-      From    : in Positive;\n-      Through : in Natural)\n-      return    Unbounded_Wide_String;\n+     (Source  : Unbounded_Wide_String;\n+      From    : Positive;\n+      Through : Natural) return Unbounded_Wide_String;\n \n    procedure Delete\n      (Source  : in out Unbounded_Wide_String;\n-      From    : in Positive;\n-      Through : in Natural);\n+      From    : Positive;\n+      Through : Natural);\n \n    function Trim\n-     (Source : in Unbounded_Wide_String;\n-      Side   : in Trim_End)\n-      return   Unbounded_Wide_String;\n+     (Source : Unbounded_Wide_String;\n+      Side   : Trim_End) return Unbounded_Wide_String;\n \n    procedure Trim\n      (Source : in out Unbounded_Wide_String;\n-      Side   : in Trim_End);\n+      Side   : Trim_End);\n \n    function Trim\n-     (Source : in Unbounded_Wide_String;\n-      Left   : in Wide_Maps.Wide_Character_Set;\n-      Right  : in Wide_Maps.Wide_Character_Set)\n-      return   Unbounded_Wide_String;\n+     (Source : Unbounded_Wide_String;\n+      Left   : Wide_Maps.Wide_Character_Set;\n+      Right  : Wide_Maps.Wide_Character_Set) return Unbounded_Wide_String;\n \n    procedure Trim\n      (Source : in out Unbounded_Wide_String;\n-      Left   : in Wide_Maps.Wide_Character_Set;\n-      Right  : in Wide_Maps.Wide_Character_Set);\n+      Left   : Wide_Maps.Wide_Character_Set;\n+      Right  : Wide_Maps.Wide_Character_Set);\n \n    function Head\n-     (Source : in Unbounded_Wide_String;\n-      Count  : in Natural;\n-      Pad    : in Wide_Character := Wide_Space)\n-      return   Unbounded_Wide_String;\n+     (Source : Unbounded_Wide_String;\n+      Count  : Natural;\n+      Pad    : Wide_Character := Wide_Space) return Unbounded_Wide_String;\n \n    procedure Head\n      (Source : in out Unbounded_Wide_String;\n-      Count  : in Natural;\n-      Pad    : in Wide_Character := Wide_Space);\n+      Count  : Natural;\n+      Pad    : Wide_Character := Wide_Space);\n \n    function Tail\n-     (Source : in Unbounded_Wide_String;\n-      Count  : in Natural;\n-      Pad    : in Wide_Character := Wide_Space)\n-      return   Unbounded_Wide_String;\n+     (Source : Unbounded_Wide_String;\n+      Count  : Natural;\n+      Pad    : Wide_Character := Wide_Space) return Unbounded_Wide_String;\n \n    procedure Tail\n      (Source : in out Unbounded_Wide_String;\n-      Count  : in Natural;\n-      Pad    : in Wide_Character := Wide_Space);\n+      Count  : Natural;\n+      Pad    : Wide_Character := Wide_Space);\n \n    function \"*\"\n-     (Left  : in Natural;\n-      Right : in Wide_Character)\n-      return  Unbounded_Wide_String;\n+     (Left  : Natural;\n+      Right : Wide_Character) return Unbounded_Wide_String;\n \n    function \"*\"\n-     (Left  : in Natural;\n-      Right : in Wide_String)\n-      return  Unbounded_Wide_String;\n+     (Left  : Natural;\n+      Right : Wide_String) return Unbounded_Wide_String;\n \n    function \"*\"\n-     (Left  : in Natural;\n-      Right : in Unbounded_Wide_String)\n-      return  Unbounded_Wide_String;\n+     (Left  : Natural;\n+      Right : Unbounded_Wide_String) return Unbounded_Wide_String;\n \n private\n    pragma Inline (Length);"}, {"sha": "b1ddff23741eb111bb03adb828f0216a7ce34710", "filename": "gcc/ada/a-suteio.adb", "status": "modified", "additions": 42, "deletions": 3, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/82c80734715c801643075ab68c5c9a5e00da1b03/gcc%2Fada%2Fa-suteio.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/82c80734715c801643075ab68c5c9a5e00da1b03/gcc%2Fada%2Fa-suteio.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-suteio.adb?ref=82c80734715c801643075ab68c5c9a5e00da1b03", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1997-1999 Free Software Foundation, Inc.          --\n+--          Copyright (C) 1997-2005 Free Software Foundation, Inc.          --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -50,7 +50,6 @@ package body Ada.Strings.Unbounded.Text_IO is\n    begin\n       Get_Line (Buffer, Last);\n       Str1 := new String'(Buffer (1 .. Last));\n-\n       while Last = Buffer'Last loop\n          Get_Line (Buffer, Last);\n          Str2 := new String'(Str1.all & Buffer (1 .. Last));\n@@ -72,7 +71,6 @@ package body Ada.Strings.Unbounded.Text_IO is\n    begin\n       Get_Line (File, Buffer, Last);\n       Str1 := new String'(Buffer (1 .. Last));\n-\n       while Last = Buffer'Last loop\n          Get_Line (File, Buffer, Last);\n          Str2 := new String'(Str1.all & Buffer (1 .. Last));\n@@ -84,6 +82,47 @@ package body Ada.Strings.Unbounded.Text_IO is\n       return Result;\n    end Get_Line;\n \n+   procedure Get_Line (Item : out Unbounded_String) is\n+      Buffer : String (1 .. 1000);\n+      Last   : Natural;\n+      Str1   : String_Access;\n+      Str2   : String_Access;\n+\n+   begin\n+      Get_Line (Buffer, Last);\n+      Str1 := new String'(Buffer (1 .. Last));\n+      while Last = Buffer'Last loop\n+         Get_Line (Buffer, Last);\n+         Str2 := new String'(Str1.all & Buffer (1 .. Last));\n+         Free (Str1);\n+         Str1 := Str2;\n+      end loop;\n+\n+      Set_String (Item, Str1);\n+   end Get_Line;\n+\n+   procedure Get_Line\n+     (File : Ada.Text_IO.File_Type;\n+      Item : out Unbounded_String)\n+   is\n+      Buffer : String (1 .. 1000);\n+      Last   : Natural;\n+      Str1   : String_Access;\n+      Str2   : String_Access;\n+\n+   begin\n+      Get_Line (File, Buffer, Last);\n+      Str1 := new String'(Buffer (1 .. Last));\n+      while Last = Buffer'Last loop\n+         Get_Line (Buffer, Last);\n+         Str2 := new String'(Str1.all & Buffer (1 .. Last));\n+         Free (Str1);\n+         Str1 := Str2;\n+      end loop;\n+\n+      Set_String (Item, Str1);\n+   end Get_Line;\n+\n    ---------\n    -- Put --\n    ---------"}, {"sha": "e743bdf7243c77ee77311fac07cb623d9e0b4f77", "filename": "gcc/ada/a-suteio.ads", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/82c80734715c801643075ab68c5c9a5e00da1b03/gcc%2Fada%2Fa-suteio.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/82c80734715c801643075ab68c5c9a5e00da1b03/gcc%2Fada%2Fa-suteio.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-suteio.ads?ref=82c80734715c801643075ab68c5c9a5e00da1b03", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---          Copyright (C) 1997-1999 Free Software Foundation, Inc.          --\n+--          Copyright (C) 1997-2005 Free Software Foundation, Inc.          --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -46,6 +46,12 @@ package Ada.Strings.Unbounded.Text_IO is\n    --  as an unbounded string of appropriate length. If no File parameter\n    --  is present, input is from Current_Input.\n \n+   procedure Get_Line\n+     (File : Ada.Text_IO.File_Type;\n+      Item : out Unbounded_String);\n+   procedure Get_Line (Item : out Unbounded_String);\n+   --  Similar to the above, but in procedure form with an out parameter\n+\n    procedure Put                                    (U : Unbounded_String);\n    procedure Put      (File : Ada.Text_IO.File_Type; U : Unbounded_String);\n    procedure Put_Line                               (U : Unbounded_String);"}, {"sha": "9836ae5b58c3789107d0a32b89f41f2a70574b85", "filename": "gcc/ada/a-swuwti.adb", "status": "modified", "additions": 55, "deletions": 11, "changes": 66, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/82c80734715c801643075ab68c5c9a5e00da1b03/gcc%2Fada%2Fa-swuwti.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/82c80734715c801643075ab68c5c9a5e00da1b03/gcc%2Fada%2Fa-swuwti.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-swuwti.adb?ref=82c80734715c801643075ab68c5c9a5e00da1b03", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1997-1999 Free Software Foundation, Inc.          --\n+--          Copyright (C) 1997-2005 Free Software Foundation, Inc.          --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -31,7 +31,8 @@\n --                                                                          --\n ------------------------------------------------------------------------------\n \n-with Ada.Wide_Text_IO; use Ada.Wide_Text_IO;\n+with Ada.Strings.Wide_Unbounded.Aux; use Ada.Strings.Wide_Unbounded.Aux;\n+with Ada.Wide_Text_IO;               use Ada.Wide_Text_IO;\n \n package body Ada.Strings.Wide_Unbounded.Wide_Text_IO is\n \n@@ -44,29 +45,30 @@ package body Ada.Strings.Wide_Unbounded.Wide_Text_IO is\n       Last   : Natural;\n       Str1   : Wide_String_Access;\n       Str2   : Wide_String_Access;\n+      Result : Unbounded_Wide_String;\n \n    begin\n       Get_Line (Buffer, Last);\n       Str1 := new Wide_String'(Buffer (1 .. Last));\n-\n       while Last = Buffer'Last loop\n          Get_Line (Buffer, Last);\n          Str2 := new Wide_String'(Str1.all & Buffer (1 .. Last));\n          Free (Str1);\n          Str1 := Str2;\n       end loop;\n \n-      return To_Unbounded_Wide_String (Str1.all);\n+      Set_Wide_String (Result, Str1);\n+      return Result;\n    end Get_Line;\n \n    function Get_Line\n-     (File : Ada.Wide_Text_IO.File_Type)\n-      return Unbounded_Wide_String\n+     (File : Ada.Wide_Text_IO.File_Type) return Unbounded_Wide_String\n    is\n       Buffer : Wide_String (1 .. 1000);\n       Last   : Natural;\n       Str1   : Wide_String_Access;\n       Str2   : Wide_String_Access;\n+      Result : Unbounded_Wide_String;\n \n    begin\n       Get_Line (File, Buffer, Last);\n@@ -79,7 +81,49 @@ package body Ada.Strings.Wide_Unbounded.Wide_Text_IO is\n          Str1 := Str2;\n       end loop;\n \n-      return To_Unbounded_Wide_String (Str1.all);\n+      Set_Wide_String (Result, Str1);\n+      return Result;\n+   end Get_Line;\n+\n+   procedure Get_Line (Item : out Unbounded_Wide_String) is\n+      Buffer : Wide_String (1 .. 1000);\n+      Last   : Natural;\n+      Str1   : Wide_String_Access;\n+      Str2   : Wide_String_Access;\n+\n+   begin\n+      Get_Line (Buffer, Last);\n+      Str1 := new Wide_String'(Buffer (1 .. Last));\n+      while Last = Buffer'Last loop\n+         Get_Line (Buffer, Last);\n+         Str2 := new Wide_String'(Str1.all & Buffer (1 .. Last));\n+         Free (Str1);\n+         Str1 := Str2;\n+      end loop;\n+\n+      Set_Wide_String (Item, Str1);\n+   end Get_Line;\n+\n+   procedure Get_Line\n+     (File : Ada.Wide_Text_IO.File_Type;\n+      Item : out Unbounded_Wide_String)\n+   is\n+      Buffer : Wide_String (1 .. 1000);\n+      Last   : Natural;\n+      Str1   : Wide_String_Access;\n+      Str2   : Wide_String_Access;\n+\n+   begin\n+      Get_Line (File, Buffer, Last);\n+      Str1 := new Wide_String'(Buffer (1 .. Last));\n+      while Last = Buffer'Last loop\n+         Get_Line (Buffer, Last);\n+         Str2 := new Wide_String'(Str1.all & Buffer (1 .. Last));\n+         Free (Str1);\n+         Str1 := Str2;\n+      end loop;\n+\n+      Set_Wide_String (Item, Str1);\n    end Get_Line;\n \n    ---------\n@@ -88,12 +132,12 @@ package body Ada.Strings.Wide_Unbounded.Wide_Text_IO is\n \n    procedure Put (U : Unbounded_Wide_String) is\n    begin\n-      Put (To_Wide_String (U));\n+      Put (Get_Wide_String (U).all);\n    end Put;\n \n    procedure Put (File : File_Type; U : Unbounded_Wide_String) is\n    begin\n-      Put (File, To_Wide_String (U));\n+      Put (File, Get_Wide_String (U).all);\n    end Put;\n \n    --------------\n@@ -102,12 +146,12 @@ package body Ada.Strings.Wide_Unbounded.Wide_Text_IO is\n \n    procedure Put_Line (U : Unbounded_Wide_String) is\n    begin\n-      Put_Line (To_Wide_String (U));\n+      Put_Line (Get_Wide_String (U).all);\n    end Put_Line;\n \n    procedure Put_Line (File : File_Type; U : Unbounded_Wide_String) is\n    begin\n-      Put_Line (File, To_Wide_String (U));\n+      Put_Line (File, Get_Wide_String (U).all);\n    end Put_Line;\n \n end Ada.Strings.Wide_Unbounded.Wide_Text_IO;"}, {"sha": "ff8acf752730c1c2063b9971432daef8dbb40a8c", "filename": "gcc/ada/a-swuwti.ads", "status": "modified", "additions": 11, "deletions": 6, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/82c80734715c801643075ab68c5c9a5e00da1b03/gcc%2Fada%2Fa-swuwti.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/82c80734715c801643075ab68c5c9a5e00da1b03/gcc%2Fada%2Fa-swuwti.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-swuwti.ads?ref=82c80734715c801643075ab68c5c9a5e00da1b03", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---          Copyright (C) 1997-1999 Free Software Foundation, Inc.          --\n+--          Copyright (C) 1997-2005 Free Software Foundation, Inc.          --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -32,9 +32,9 @@\n ------------------------------------------------------------------------------\n \n --  This child package of Ada.Strings.Wide_Unbounded provides specialized\n---  Text_IO routines that work directly with unbounded strings, avoiding the\n---  inefficiencies of access via the standard interface, and also taking\n---  direct advantage of the variable length semantics of these strings.\n+--  Wide_Text_IO routines that work directly with unbounded wide strings,\n+--  avoiding the inefficiencies of access via the standard interface, and also\n+--  taking direct advantage of the variable length semantics of these strings.\n \n with Ada.Wide_Text_IO;\n \n@@ -43,12 +43,17 @@ package Ada.Strings.Wide_Unbounded.Wide_Text_IO is\n    function Get_Line\n      return Unbounded_Wide_String;\n    function Get_Line\n-     (File : Ada.Wide_Text_IO.File_Type)\n-      return Unbounded_Wide_String;\n+     (File : Ada.Wide_Text_IO.File_Type) return Unbounded_Wide_String;\n    --  Reads up to the end of the current line, returning the result\n    --  as an unbounded string of appropriate length. If no File parameter\n    --  is present, input is from Current_Input.\n \n+   procedure Get_Line\n+     (File : Ada.Wide_Text_IO.File_Type;\n+      Item : out Unbounded_Wide_String);\n+   procedure Get_Line (Item : out Unbounded_Wide_String);\n+   --  Similar to the above, but in procedure form with an out parameter\n+\n    procedure Put\n      (U : Unbounded_Wide_String);\n    procedure Put"}, {"sha": "03221948d34a1f2ced6dd935af2638b8b060a81b", "filename": "gcc/ada/a-tags.adb", "status": "modified", "additions": 159, "deletions": 83, "changes": 242, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/82c80734715c801643075ab68c5c9a5e00da1b03/gcc%2Fada%2Fa-tags.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/82c80734715c801643075ab68c5c9a5e00da1b03/gcc%2Fada%2Fa-tags.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-tags.adb?ref=82c80734715c801643075ab68c5c9a5e00da1b03", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1992-2004 Free Software Foundation, Inc.          --\n+--          Copyright (C) 1992-2005 Free Software Foundation, Inc.          --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -32,49 +32,48 @@\n ------------------------------------------------------------------------------\n \n with Ada.Exceptions;\n-\n with System.HTable;\n \n-with Unchecked_Conversion;\n-\n pragma Elaborate_All (System.HTable);\n \n package body Ada.Tags is\n \n --  Structure of the GNAT Dispatch Table\n \n---   +----------------------+\n---   |      TSD pointer  ---|-----> Type Specific Data\n---   +----------------------+       +-------------------+\n---   | table of             |       | inheritance depth |\n---   :   primitive ops      :       +-------------------+\n---   |     pointers         |       |   expanded name   |\n---   +----------------------+       +-------------------+\n---                                  |   external tag    |\n---                                  +-------------------+\n---                                  |   Hash table link |\n---                                  +-------------------+\n---                                  | Remotely Callable |\n---                                  +-------------------+\n---                                  | Rec Ctrler offset |\n---                                  +-------------------+\n---                                  | table of          |\n---                                  :   ancestor        :\n---                                  |      tags         |\n---                                  +-------------------+\n+--           +-----------------------+\n+--           |     Offset_To_Top     |\n+--           +-----------------------+\n+--           | Typeinfo_Ptr/TSD_Ptr  |----> Type Specific Data\n+--  Tag ---> +-----------------------+      +-------------------+\n+--           |        table of       |      | inheritance depth |\n+--           :     primitive ops     :      +-------------------+\n+--           |        pointers       |      |   expanded name   |\n+--           +-----------------------+      +-------------------+\n+--                                          |   external tag    |\n+--                                          +-------------------+\n+--                                          |   Hash table link |\n+--                                          +-------------------+\n+--                                          | Remotely Callable |\n+--                                          +-------------------+\n+--                                          | Rec Ctrler offset |\n+--                                          +-------------------+\n+--                                          | table of          |\n+--                                          :   ancestor        :\n+--                                          |      tags         |\n+--                                          +-------------------+\n \n    subtype Cstring is String (Positive);\n    type Cstring_Ptr is access all Cstring;\n \n    type Tag_Table is array (Natural range <>) of Tag;\n    pragma Suppress_Initialization (Tag_Table);\n    pragma Suppress (Index_Check, On => Tag_Table);\n-   --  We suppress index checks because the declared size in the record\n-   --  below is a dummy size of one (see below).\n+   --  We suppress index checks because the declared size in the record below\n+   --  is a dummy size of one (see below).\n \n    type Wide_Boolean is new Boolean;\n-   --  This name should probably be changed sometime ??? and indeed\n-   --  probably this field could simply be of type Standard.Boolean.\n+   --  This name should probably be changed sometime ??? and indeed probably\n+   --  this field could simply be of type Standard.Boolean.\n \n    type Type_Specific_Data is record\n       Idepth             : Natural;\n@@ -85,31 +84,48 @@ package body Ada.Tags is\n       RC_Offset          : SSE.Storage_Offset;\n       Ancestor_Tags      : Tag_Table (0 .. 1);\n    end record;\n-   --  The size of the Ancestor_Tags array actually depends on the tagged\n-   --  type to which it applies.  We are using the same mechanism as for\n-   --  the Prims_Ptr array in the Dispatch_Table record.  See comments\n-   --  below for more details.\n+   --  The size of the Ancestor_Tags array actually depends on the tagged type\n+   --  to which it applies. We are using the same mechanism as for the\n+   --  Prims_Ptr array in the Dispatch_Table record. See comments below for\n+   --  more details.\n \n    type Dispatch_Table is record\n-      TSD       : Type_Specific_Data_Ptr;\n-      Prims_Ptr : Address_Array (1 .. 1);\n+      --  Offset_To_Top : Integer := 0;\n+      --  Typeinfo_Ptr  : System.Address; -- Currently TSD is also here???\n+      Prims_Ptr    : Address_Array (Positive);\n    end record;\n-   --  The size of the Prims_Ptr array actually depends on the tagged\n-   --  type to which it applies. For each tagged type, the expander\n-   --  computes the actual array size, and allocates the Dispatch_Table\n-   --  record accordingly.\n+\n+   --  Note on the commented out fields of the Dispatch_Table\n+   --  ------------------------------------------------------\n+   --  According to the C++ ABI the components Offset_To_Top and Typeinfo_Ptr\n+   --  are stored just \"before\" the dispatch table (that is, the Prims_Ptr\n+   --  table), and they are referenced with negative offsets referring to the\n+   --  base of the dispatch table. The _Tag (or the VTable_Ptr in C++ termi-\n+   --  nology) must point to the base of the virtual table, just after these\n+   --  components, to point to the Prims_Ptr table. For this purpose the\n+   --  expander generates a Prims_Ptr table that has enough space for these\n+   --  additional components, and generates code that displaces the _Tag to\n+   --  point after these components.\n+   --  -----------------------------------------------------------------------\n+\n+   --  The size of the Prims_Ptr array actually depends on the tagged type to\n+   --  which it applies. For each tagged type, the expander computes the\n+   --  actual array size, allocates the Dispatch_Table record accordingly, and\n+   --  generates code that displaces the base of the record after the\n+   --  Typeinfo_Ptr component. For this reason the first two components have\n+   --  been commented in the previous declaration. The access to these\n+   --  components is done by means of local functions.\n    --\n-   --  To avoid the use of discriminants to define the actual size\n-   --  of the dispatch table, we used to declare the tag as a pointer\n-   --  to a record that contains an arbitrary array of addresses, using\n-   --  Positive as its index. This ensures that there are never range\n-   --  checks when accessing the dispatch table, but it prevents GDB\n-   --  from displaying tagged types properly. A better approach is\n-   --  to declare this record type as holding a small number of addresses,\n-   --  and to explicitly suppress checks on it.\n+   --  To avoid the use of discriminants to define the actual size of the\n+   --  dispatch table, we used to declare the tag as a pointer to a record\n+   --  that contains an arbitrary array of addresses, using Positive as its\n+   --  index. This ensures that there are never range checks when accessing\n+   --  the dispatch table, but it prevents GDB from displaying tagged types\n+   --  properly. A better approach is to declare this record type as holding a\n+   --  small number of addresses, and to explicitly suppress checks on it.\n    --\n-   --  Note that in both cases, this type is never allocated, and serves\n-   --  only to declare the corresponding access type.\n+   --  Note that in both cases, this type is never allocated, and serves only\n+   --  to declare the corresponding access type.\n \n    ---------------------------------------------\n    -- Unchecked Conversions for String Fields --\n@@ -121,23 +137,44 @@ package body Ada.Tags is\n    function To_Address is\n      new Unchecked_Conversion (Cstring_Ptr, System.Address);\n \n+   -----------------------------------------------------------\n+   -- Unchecked Conversions for the component offset_to_top --\n+   -----------------------------------------------------------\n+\n+   type Int_Ptr is access Integer;\n+\n+   function To_Int_Ptr is\n+      new Unchecked_Conversion (System.Address, Int_Ptr);\n+\n    -----------------------\n    -- Local Subprograms --\n    -----------------------\n \n    function Length (Str : Cstring_Ptr) return Natural;\n-   --  Length of string represented by the given pointer (treating the\n-   --  string as a C-style string, which is Nul terminated).\n+   --  Length of string represented by the given pointer (treating the string\n+   --  as a C-style string, which is Nul terminated).\n+\n+   function Offset_To_Top (T : Tag) return Integer;\n+   --  Returns the current value of the offset_to_top component available in\n+   --  the prologue of the dispatch table.\n+\n+   function Typeinfo_Ptr (T : Tag) return System.Address;\n+   --  Returns the current value of the typeinfo_ptr component available in\n+   --  the prologue of the dispatch table.\n+\n+   pragma Unreferenced (Offset_To_Top);\n+   pragma Unreferenced (Typeinfo_Ptr);\n+   --  These functions will be used for full compatibility with the C++ ABI\n \n    -------------------------\n    -- External_Tag_HTable --\n    -------------------------\n \n    type HTable_Headers is range 1 .. 64;\n \n-   --  The following internal package defines the routines used for\n-   --  the instantiation of a new System.HTable.Static_HTable (see\n-   --  below). See spec in g-htable.ads for details of usage.\n+   --  The following internal package defines the routines used for the\n+   --  instantiation of a new System.HTable.Static_HTable (see below). See\n+   --  spec in g-htable.ads for details of usage.\n \n    package HTable_Subprograms is\n       procedure Set_HT_Link (T : Tag; Next : Tag);\n@@ -195,7 +232,7 @@ package body Ada.Tags is\n \n       function Get_HT_Link (T : Tag) return Tag is\n       begin\n-         return T.TSD.HT_Link;\n+         return TSD (T).HT_Link;\n       end Get_HT_Link;\n \n       ----------\n@@ -216,7 +253,7 @@ package body Ada.Tags is\n \n       procedure Set_HT_Link (T : Tag; Next : Tag) is\n       begin\n-         T.TSD.HT_Link := Next;\n+         TSD (T).HT_Link := Next;\n       end Set_HT_Link;\n \n    end HTable_Subprograms;\n@@ -241,17 +278,17 @@ package body Ada.Tags is\n    --     = Typ'tag\n \n    function CW_Membership (Obj_Tag : Tag; Typ_Tag : Tag) return Boolean is\n-      Pos : constant Integer := Obj_Tag.TSD.Idepth - Typ_Tag.TSD.Idepth;\n+      Pos : constant Integer := TSD (Obj_Tag).Idepth - TSD (Typ_Tag).Idepth;\n    begin\n-      return Pos >= 0 and then Obj_Tag.TSD.Ancestor_Tags (Pos) = Typ_Tag;\n+      return Pos >= 0 and then TSD (Obj_Tag).Ancestor_Tags (Pos) = Typ_Tag;\n    end CW_Membership;\n \n    -------------------\n    -- Expanded_Name --\n    -------------------\n \n    function Expanded_Name (T : Tag) return String is\n-      Result : constant Cstring_Ptr := T.TSD.Expanded_Name;\n+      Result : constant Cstring_Ptr := TSD (T).Expanded_Name;\n    begin\n       return Result (1 .. Length (Result));\n    end Expanded_Name;\n@@ -261,7 +298,7 @@ package body Ada.Tags is\n    ------------------\n \n    function External_Tag (T : Tag) return String is\n-      Result : constant Cstring_Ptr := T.TSD.External_Tag;\n+      Result : constant Cstring_Ptr := TSD (T).External_Tag;\n    begin\n       return Result (1 .. Length (Result));\n    end External_Tag;\n@@ -272,7 +309,7 @@ package body Ada.Tags is\n \n    function Get_Expanded_Name (T : Tag) return System.Address is\n    begin\n-      return To_Address (T.TSD.Expanded_Name);\n+      return To_Address (TSD (T).Expanded_Name);\n    end Get_Expanded_Name;\n \n    ----------------------\n@@ -281,7 +318,7 @@ package body Ada.Tags is\n \n    function Get_External_Tag (T : Tag) return System.Address is\n    begin\n-      return To_Address (T.TSD.External_Tag);\n+      return To_Address (TSD (T).External_Tag);\n    end Get_External_Tag;\n \n    ---------------------------\n@@ -290,7 +327,7 @@ package body Ada.Tags is\n \n    function Get_Inheritance_Depth (T : Tag) return Natural is\n    begin\n-      return T.TSD.Idepth;\n+      return TSD (T).Idepth;\n    end Get_Inheritance_Depth;\n \n    -------------------------\n@@ -311,7 +348,7 @@ package body Ada.Tags is\n \n    function Get_RC_Offset (T : Tag) return SSE.Storage_Offset is\n    begin\n-      return T.TSD.RC_Offset;\n+      return TSD (T).RC_Offset;\n    end Get_RC_Offset;\n \n    ---------------------------\n@@ -320,16 +357,19 @@ package body Ada.Tags is\n \n    function Get_Remotely_Callable (T : Tag) return Boolean is\n    begin\n-      return T.TSD.Remotely_Callable = True;\n+      return TSD (T).Remotely_Callable = True;\n    end Get_Remotely_Callable;\n \n    -------------\n    -- Get_TSD --\n    -------------\n \n    function Get_TSD  (T : Tag) return System.Address is\n+      use type System.Storage_Elements.Storage_Offset;\n+      TSD_Ptr : constant Addr_Ptr :=\n+                  To_Addr_Ptr (To_Address (T) - DT_Typeinfo_Ptr_Size);\n    begin\n-      return To_Address (T.TSD);\n+      return TSD_Ptr.all;\n    end Get_TSD;\n \n    ----------------\n@@ -353,20 +393,21 @@ package body Ada.Tags is\n    -----------------\n \n    procedure Inherit_TSD (Old_TSD : System.Address; New_Tag : Tag) is\n-      TSD     : constant Type_Specific_Data_Ptr :=\n-                  To_Type_Specific_Data_Ptr (Old_TSD);\n-      New_TSD : Type_Specific_Data renames New_Tag.TSD.all;\n+      Old_TSD_Ptr  : constant Type_Specific_Data_Ptr :=\n+                       To_Type_Specific_Data_Ptr (Old_TSD);\n+      New_TSD_Ptr  : constant Type_Specific_Data_Ptr :=\n+                       TSD (New_Tag);\n \n    begin\n-      if TSD /= null then\n-         New_TSD.Idepth := TSD.Idepth + 1;\n-         New_TSD.Ancestor_Tags (1 .. New_TSD.Idepth)\n-                            := TSD.Ancestor_Tags (0 .. TSD.Idepth);\n+      if Old_TSD_Ptr /= null then\n+         New_TSD_Ptr.Idepth := Old_TSD_Ptr.Idepth + 1;\n+         New_TSD_Ptr.Ancestor_Tags (1 .. New_TSD_Ptr.Idepth) :=\n+           Old_TSD_Ptr.Ancestor_Tags (0 .. Old_TSD_Ptr.Idepth);\n       else\n-         New_TSD.Idepth := 0;\n+         New_TSD_Ptr.Idepth := 0;\n       end if;\n \n-      New_TSD.Ancestor_Tags (0) := New_Tag;\n+      New_TSD_Ptr.Ancestor_Tags (0) := New_Tag;\n    end Inherit_TSD;\n \n    ------------------\n@@ -389,7 +430,6 @@ package body Ada.Tags is\n          declare\n             Msg1 : constant String := \"unknown tagged type: \";\n             Msg2 : String (1 .. Msg1'Length + External'Length);\n-\n          begin\n             Msg2 (1 .. Msg1'Length) := Msg1;\n             Msg2 (Msg1'Length + 1 .. Msg1'Length + External'Length) :=\n@@ -430,7 +470,7 @@ package body Ada.Tags is\n      (Obj : System.Address;\n       T   : Tag) return SSE.Storage_Count\n    is\n-      Parent_Tag : constant Tag := T.TSD.Ancestor_Tags (1);\n+      Parent_Tag : constant Tag := TSD (T).Ancestor_Tags (1);\n       --  The tag of the parent type through the dispatch table\n \n       F : constant Acc_Size := To_Acc_Size (Parent_Tag.Prims_Ptr (1));\n@@ -449,7 +489,7 @@ package body Ada.Tags is\n \n    function Parent_Tag (T : Tag) return Tag is\n    begin\n-      return T.TSD.Ancestor_Tags (1);\n+      return TSD (T).Ancestor_Tags (1);\n    end Parent_Tag;\n \n    ------------------\n@@ -467,7 +507,7 @@ package body Ada.Tags is\n \n    procedure Set_Expanded_Name (T : Tag; Value : System.Address) is\n    begin\n-      T.TSD.Expanded_Name := To_Cstring_Ptr (Value);\n+      TSD (T).Expanded_Name := To_Cstring_Ptr (Value);\n    end Set_Expanded_Name;\n \n    ----------------------\n@@ -476,7 +516,7 @@ package body Ada.Tags is\n \n    procedure Set_External_Tag (T : Tag; Value : System.Address) is\n    begin\n-      T.TSD.External_Tag := To_Cstring_Ptr (Value);\n+      TSD (T).External_Tag := To_Cstring_Ptr (Value);\n    end Set_External_Tag;\n \n    ---------------------------\n@@ -488,7 +528,7 @@ package body Ada.Tags is\n       Value : Natural)\n    is\n    begin\n-      T.TSD.Idepth := Value;\n+      TSD (T).Idepth := Value;\n    end Set_Inheritance_Depth;\n \n    -------------------------\n@@ -510,7 +550,7 @@ package body Ada.Tags is\n \n    procedure Set_RC_Offset (T : Tag; Value : SSE.Storage_Offset) is\n    begin\n-      T.TSD.RC_Offset := Value;\n+      TSD (T).RC_Offset := Value;\n    end Set_RC_Offset;\n \n    ---------------------------\n@@ -520,9 +560,9 @@ package body Ada.Tags is\n    procedure Set_Remotely_Callable (T : Tag; Value : Boolean) is\n    begin\n       if Value then\n-         T.TSD.Remotely_Callable := True;\n+         TSD (T).Remotely_Callable := True;\n       else\n-         T.TSD.Remotely_Callable := False;\n+         TSD (T).Remotely_Callable := False;\n       end if;\n    end Set_Remotely_Callable;\n \n@@ -531,8 +571,44 @@ package body Ada.Tags is\n    -------------\n \n    procedure Set_TSD (T : Tag; Value : System.Address) is\n+      use type System.Storage_Elements.Storage_Offset;\n+      TSD_Ptr : constant Addr_Ptr :=\n+                  To_Addr_Ptr (To_Address (T) - DT_Typeinfo_Ptr_Size);\n    begin\n-      T.TSD := To_Type_Specific_Data_Ptr (Value);\n+      TSD_Ptr.all := Value;\n    end Set_TSD;\n \n+   -------------------\n+   -- Offset_To_Top --\n+   -------------------\n+\n+   function Offset_To_Top (T : Tag) return Integer is\n+      use type System.Storage_Elements.Storage_Offset;\n+      TSD_Ptr : constant Int_Ptr :=\n+                  To_Int_Ptr (To_Address (T) - DT_Prologue_Size);\n+   begin\n+      return TSD_Ptr.all;\n+   end Offset_To_Top;\n+\n+   ------------------\n+   -- Typeinfo_Ptr --\n+   ------------------\n+\n+   function Typeinfo_Ptr (T : Tag) return System.Address is\n+      use type System.Storage_Elements.Storage_Offset;\n+      TSD_Ptr : constant Addr_Ptr :=\n+                  To_Addr_Ptr (To_Address (T) - DT_Typeinfo_Ptr_Size);\n+   begin\n+      return TSD_Ptr.all;\n+   end Typeinfo_Ptr;\n+\n+   ---------\n+   -- TSD --\n+   ---------\n+\n+   function TSD (T : Tag) return Type_Specific_Data_Ptr is\n+   begin\n+      return To_Type_Specific_Data_Ptr (Get_TSD (T));\n+   end TSD;\n+\n end Ada.Tags;"}, {"sha": "92715a85b14603687ea73e38ff09d2405af509cb", "filename": "gcc/ada/a-tags.ads", "status": "modified", "additions": 30, "deletions": 11, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/82c80734715c801643075ab68c5c9a5e00da1b03/gcc%2Fada%2Fa-tags.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/82c80734715c801643075ab68c5c9a5e00da1b03/gcc%2Fada%2Fa-tags.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-tags.ads?ref=82c80734715c801643075ab68c5c9a5e00da1b03", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---          Copyright (C) 1992-2004 Free Software Foundation, Inc.          --\n+--          Copyright (C) 1992-2005 Free Software Foundation, Inc.          --\n --                                                                          --\n -- This specification is derived from the Ada Reference Manual for use with --\n -- GNAT. The copyright notice above, and the license provisions that follow --\n@@ -79,6 +79,12 @@ private\n    --  initialize those structures and uses the GET functions to\n    --  retreive the information when needed\n \n+   type Dispatch_Table;\n+   type Tag is access all Dispatch_Table;\n+\n+   type Type_Specific_Data;\n+   type Type_Specific_Data_Ptr is access all Type_Specific_Data;\n+\n    package SSE renames System.Storage_Elements;\n \n    function CW_Membership (Obj_Tag : Tag; Typ_Tag : Tag) return Boolean;\n@@ -188,16 +194,26 @@ private\n \n    procedure Set_Remotely_Callable (T : Tag; Value : Boolean);\n    --  Set to true if the type has been declared in a context described\n-   --  in E.4 (18)\n+   --  in E.4 (18).\n+\n+   function TSD (T : Tag) return Type_Specific_Data_Ptr;\n+   --  This function is conceptually equivalent to Get_TSD, but\n+   --  returning a Type_Specific_Data_Ptr type (rather than an Address)\n+   --  simplifies the implementation of the other subprograms.\n \n    DT_Prologue_Size : constant SSE.Storage_Count :=\n                         SSE.Storage_Count\n-                          (Standard'Address_Size / System.Storage_Unit);\n+                          (2 * (Standard'Address_Size / System.Storage_Unit));\n    --  Size of the first part of the dispatch table\n \n+   DT_Typeinfo_Ptr_Size : constant SSE.Storage_Count :=\n+                            SSE.Storage_Count\n+                              (Standard'Address_Size / System.Storage_Unit);\n+   --  Size of the Typeinfo_Ptr field of the Dispatch Table.\n+\n    DT_Entry_Size : constant SSE.Storage_Count :=\n                      SSE.Storage_Count\n-                       (Standard'Address_Size / System.Storage_Unit);\n+                       (1 * (Standard'Address_Size / System.Storage_Unit));\n    --  Size of each primitive operation entry in the Dispatch Table.\n \n    TSD_Prologue_Size : constant SSE.Storage_Count :=\n@@ -206,7 +222,7 @@ private\n    --  Size of the first part of the type specific data\n \n    TSD_Entry_Size : constant SSE.Storage_Count :=\n-     SSE.Storage_Count (Standard'Address_Size / System.Storage_Unit);\n+     SSE.Storage_Count (1 * (Standard'Address_Size / System.Storage_Unit));\n    --  Size of each ancestor tag entry in the TSD\n \n    type Address_Array is array (Natural range <>) of System.Address;\n@@ -215,18 +231,20 @@ private\n    --  of this type are declared with a dummy size of 1, the actual size\n    --  depending on the number of primitive operations.\n \n-   type Dispatch_Table;\n-   type Tag is access all Dispatch_Table;\n-\n-   type Type_Specific_Data;\n-   type Type_Specific_Data_Ptr is access all Type_Specific_Data;\n-\n    function To_Type_Specific_Data_Ptr is\n      new Unchecked_Conversion (System.Address, Type_Specific_Data_Ptr);\n \n    function To_Address is\n      new Unchecked_Conversion (Type_Specific_Data_Ptr, System.Address);\n \n+   function To_Address is\n+     new Unchecked_Conversion (Tag, System.Address);\n+\n+   type Addr_Ptr is access System.Address;\n+\n+   function To_Addr_Ptr is\n+      new Unchecked_Conversion (System.Address, Addr_Ptr);\n+\n    --  Primitive dispatching operations are always inlined, to facilitate\n    --  use in a minimal/no run-time environment for high integrity use.\n \n@@ -247,5 +265,6 @@ private\n    pragma Inline_Always (Set_RC_Offset);\n    pragma Inline_Always (Set_Remotely_Callable);\n    pragma Inline_Always (Set_TSD);\n+   pragma Inline_Always (TSD);\n \n end Ada.Tags;"}, {"sha": "fad1513ab8fa217b04418ec687cc1e38a6eab882", "filename": "gcc/ada/ada-tree.h", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/82c80734715c801643075ab68c5c9a5e00da1b03/gcc%2Fada%2Fada-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/82c80734715c801643075ab68c5c9a5e00da1b03/gcc%2Fada%2Fada-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fada-tree.h?ref=82c80734715c801643075ab68c5c9a5e00da1b03", "patch": "@@ -6,7 +6,7 @@\n  *                                                                          *\n  *                              C Header File                               *\n  *                                                                          *\n- *          Copyright (C) 1992-2004 Free Software Foundation, Inc.          *\n+ *          Copyright (C) 1992-2005 Free Software Foundation, Inc.          *\n  *                                                                          *\n  * GNAT is free software;  you can  redistribute it  and/or modify it under *\n  * terms of the  GNU General Public License as published  by the Free Soft- *\n@@ -64,7 +64,8 @@ struct lang_type GTY(()) {tree t; };\n \n /* For RECORD_TYPE, UNION_TYPE, and QUAL_UNION_TYPE, nonzero if this is a\n    record being used as a fat pointer (only true for RECORD_TYPE).  */\n-#define TYPE_IS_FAT_POINTER_P(NODE) TYPE_LANG_FLAG_0 (NODE)\n+#define TYPE_IS_FAT_POINTER_P(NODE) \\\n+  TYPE_LANG_FLAG_0 (RECORD_OR_UNION_CHECK (NODE))\n \n #define TYPE_FAT_POINTER_P(NODE)  \\\n   (TREE_CODE (NODE) == RECORD_TYPE && TYPE_IS_FAT_POINTER_P (NODE))\n@@ -159,6 +160,9 @@ struct lang_type GTY(()) {tree t; };\n    padding or alignment.  */\n #define TYPE_IS_PADDING_P(NODE) TYPE_LANG_FLAG_5 (RECORD_TYPE_CHECK (NODE))\n \n+/* For a UNION_TYPE, nonzero if this is an unchecked union.  */\n+#define TYPE_UNCHECKED_UNION_P(NODE) TYPE_LANG_FLAG_6 (UNION_TYPE_CHECK (NODE))\n+\n /* This field is only defined for FUNCTION_TYPE nodes. If the Ada\n    subprogram contains no parameters passed by copy in/copy out then this\n    field is 0. Otherwise it points to a list of nodes used to specify the"}, {"sha": "518d1df8a839f92285cfa27cb5e831fb7d4c6118", "filename": "gcc/ada/ali-util.adb", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/82c80734715c801643075ab68c5c9a5e00da1b03/gcc%2Fada%2Fali-util.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/82c80734715c801643075ab68c5c9a5e00da1b03/gcc%2Fada%2Fali-util.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fali-util.adb?ref=82c80734715c801643075ab68c5c9a5e00da1b03", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1992-2004 Free Software Foundation, Inc.          --\n+--          Copyright (C) 1992-2005 Free Software Foundation, Inc.          --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -291,8 +291,8 @@ package body ALI.Util is\n                --  set the Interface flag in the Withs table, so that its\n                --  dependant are not considered for elaboration order.\n \n-               if ALIs.Table (Idread).Interface then\n-                  Withs.Table (W).Interface := True;\n+               if ALIs.Table (Idread).SAL_Interface then\n+                  Withs.Table (W).SAL_Interface  := True;\n                   Interface_Library_Unit := True;\n \n                   --  Set the entry in the Interfaces hash table, so that other\n@@ -313,7 +313,7 @@ package body ALI.Util is\n             --  set the flag in the entry of the Withs table.\n \n             elsif Interface_Library_Unit and then Interfaces.Get (Afile) then\n-               Withs.Table (W).Interface := True;\n+               Withs.Table (W).SAL_Interface := True;\n             end if;\n          end loop;\n       end loop;"}, {"sha": "4c8a08b05a8a664a142ae0a94658f9e89a557253", "filename": "gcc/ada/ali.adb", "status": "modified", "additions": 6, "deletions": 7, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/82c80734715c801643075ab68c5c9a5e00da1b03/gcc%2Fada%2Fali.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/82c80734715c801643075ab68c5c9a5e00da1b03/gcc%2Fada%2Fali.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fali.adb?ref=82c80734715c801643075ab68c5c9a5e00da1b03", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1992-2004 Free Software Foundation, Inc.          --\n+--          Copyright (C) 1992-2005 Free Software Foundation, Inc.          --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -654,14 +654,14 @@ package body ALI is\n         Ofile_Full_Name            => Full_Object_File_Name,\n         Queuing_Policy             => ' ',\n         Restrictions               => Restrictions_Initial,\n+        SAL_Interface              => False,\n         Sfile                      => No_Name,\n         Task_Dispatching_Policy    => ' ',\n         Time_Slice_Value           => -1,\n         WC_Encoding                => '8',\n         Unit_Exception_Table       => False,\n         Ver                        => (others => ' '),\n         Ver_Len                    => 0,\n-        Interface                  => False,\n         Zero_Cost_Exceptions       => False);\n \n       --  Now we acquire the input lines from the ALI file. Note that the\n@@ -878,7 +878,7 @@ package body ALI is\n                --  Processing for SL\n \n                if C = 'L' then\n-                  ALIs.Table (Id).Interface := True;\n+                  ALIs.Table (Id).SAL_Interface := True;\n \n                --  Processing for SS\n \n@@ -1194,7 +1194,8 @@ package body ALI is\n          Units.Table (Units.Last).First_With      := Withs.Last + 1;\n          Units.Table (Units.Last).First_Arg       := First_Arg;\n          Units.Table (Units.Last).Elab_Position   := 0;\n-         Units.Table (Units.Last).Interface       := ALIs.Table (Id).Interface;\n+         Units.Table (Units.Last).SAL_Interface   := ALIs.Table (Id).\n+                                                       SAL_Interface;\n          Units.Table (Units.Last).Body_Needed_For_SAL := False;\n \n          if Debug_Flag_U then\n@@ -1290,7 +1291,6 @@ package body ALI is\n                   Fatal_Error_Ignore;\n                end if;\n \n-\n             --  DE parameter (Dynamic elaboration checks)\n \n             elsif C = 'D' then\n@@ -1376,7 +1376,6 @@ package body ALI is\n                   Fatal_Error_Ignore;\n                end if;\n \n-\n             --  PR/PU/PK parameters\n \n             elsif C = 'P' then\n@@ -1459,7 +1458,7 @@ package body ALI is\n                Withs.Table (Withs.Last).Elaborate          := False;\n                Withs.Table (Withs.Last).Elaborate_All      := False;\n                Withs.Table (Withs.Last).Elab_All_Desirable := False;\n-               Withs.Table (Withs.Last).Interface          := False;\n+               Withs.Table (Withs.Last).SAL_Interface      := False;\n \n                --  Generic case with no object file available\n "}, {"sha": "cab4b0623653f3f93599baa3842cdf49c938646d", "filename": "gcc/ada/ali.ads", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/82c80734715c801643075ab68c5c9a5e00da1b03/gcc%2Fada%2Fali.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/82c80734715c801643075ab68c5c9a5e00da1b03/gcc%2Fada%2Fali.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fali.ads?ref=82c80734715c801643075ab68c5c9a5e00da1b03", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---          Copyright (C) 1992-2004 Free Software Foundation, Inc.          --\n+--          Copyright (C) 1992-2005 Free Software Foundation, Inc.          --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -103,7 +103,7 @@ package ALI is\n       --  Length of characters stored in Ver. Not set if V lines are\n       --  ignored as a result of the Ignore_Lines parameter.\n \n-      Interface : Boolean;\n+      SAL_Interface : Boolean;\n       --  Set True when this is an interface to a standalone library\n \n       First_Unit : Unit_Id;\n@@ -332,7 +332,7 @@ package ALI is\n       --  Set True if IS qualifier appears in ALI file, indicating that\n       --  an Initialize_Scalars pragma applies to the unit.\n \n-      Interface : Boolean;\n+      SAL_Interface : Boolean;\n       --  Set True when this is an interface to a standalone library\n \n       Body_Needed_For_SAL : Boolean;\n@@ -475,7 +475,7 @@ package ALI is\n       Elab_All_Desirable : Boolean;\n       --  Indicates presence of ED parameter\n \n-      Interface : Boolean := False;\n+      SAL_Interface : Boolean := False;\n       --  True if the Unit is an Interface of a Stand-Alone Library\n \n    end record;"}, {"sha": "8122d85068c7a3f63460a4fb4a6255a84633da8e", "filename": "gcc/ada/atree.adb", "status": "modified", "additions": 17, "deletions": 12, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/82c80734715c801643075ab68c5c9a5e00da1b03/gcc%2Fada%2Fatree.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/82c80734715c801643075ab68c5c9a5e00da1b03/gcc%2Fada%2Fatree.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fatree.adb?ref=82c80734715c801643075ab68c5c9a5e00da1b03", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1992-2004, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2005, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -191,7 +191,7 @@ package body Atree is\n      Unchecked_Conversion (Union_Id_Ptr, Flag_Word2_Ptr);\n \n    --  The following declarations are used to store flags 152-183 in the\n-   --  Field12 field of the fourth component of an extended (entity) node.\n+   --  Field11 field of the fourth component of an extended (entity) node.\n \n    type Flag_Word3 is record\n       Flag152 : Boolean;\n@@ -2960,11 +2960,16 @@ package body Atree is\n          return String_Id (Nodes.Table (N).Field3);\n       end Str3;\n \n-      function Char_Code2 (N : Node_Id) return Char_Code is\n-      begin\n+      function Uint2 (N : Node_Id) return Uint is\n          pragma Assert (N in Nodes.First .. Nodes.Last);\n-         return Char_Code (Nodes.Table (N).Field2 - Char_Code_Bias);\n-      end Char_Code2;\n+         U : constant Union_Id := Nodes.Table (N).Field2;\n+      begin\n+         if U = 0 then\n+            return Uint_0;\n+         else\n+            return From_Union (U);\n+         end if;\n+      end Uint2;\n \n       function Uint3 (N : Node_Id) return Uint is\n          pragma Assert (N in Nodes.First .. Nodes.Last);\n@@ -4858,6 +4863,12 @@ package body Atree is\n          Nodes.Table (N).Field3 := Union_Id (Val);\n       end Set_Str3;\n \n+      procedure Set_Uint2 (N : Node_Id; Val : Uint) is\n+      begin\n+         pragma Assert (N in Nodes.First .. Nodes.Last);\n+         Nodes.Table (N).Field2 := To_Union (Val);\n+      end Set_Uint2;\n+\n       procedure Set_Uint3 (N : Node_Id; Val : Uint) is\n       begin\n          pragma Assert (N in Nodes.First .. Nodes.Last);\n@@ -4960,12 +4971,6 @@ package body Atree is\n          Nodes.Table (N + 3).Field8 := To_Union (Val);\n       end Set_Ureal21;\n \n-      procedure Set_Char_Code2 (N : Node_Id; Val : Char_Code) is\n-      begin\n-         pragma Assert (N in Nodes.First .. Nodes.Last);\n-         Nodes.Table (N).Field2 := Union_Id (Val) + Char_Code_Bias;\n-      end Set_Char_Code2;\n-\n       procedure Set_Flag4 (N : Node_Id; Val : Boolean) is\n       begin\n          pragma Assert (N in Nodes.First .. Nodes.Last);"}, {"sha": "8b08b524a1f3683478d2b8c26496225d483d0675", "filename": "gcc/ada/atree.ads", "status": "modified", "additions": 18, "deletions": 19, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/82c80734715c801643075ab68c5c9a5e00da1b03/gcc%2Fada%2Fatree.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/82c80734715c801643075ab68c5c9a5e00da1b03/gcc%2Fada%2Fatree.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fatree.ads?ref=82c80734715c801643075ab68c5c9a5e00da1b03", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---          Copyright (C) 1992-2004, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2005, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -124,7 +124,6 @@ package Atree is\n    --   Field4\n    --   Field5           Five fields holding Union_Id values\n \n-   --   Char_CodeN       Synonym for FieldN typed as Char_Code\n    --   ElistN           Synonym for FieldN typed as Elist_Id\n    --   ListN            Synonym for FieldN typed as List_Id\n    --   NameN            Synonym for FieldN typed as Name_Id\n@@ -133,14 +132,14 @@ package Atree is\n    --   UintN            Synonym for FieldN typed as Uint (Empty = Uint_0)\n    --   UrealN           Synonym for FieldN typed as Ureal\n \n-   --   Note: the actual usage of FieldN (i.e. whether it contains a Char_Code,\n-   --   Elist_Id, List_Id, Name_Id, Node_Id, String_Id, Uint or Ureal), depends\n-   --   on the value in Nkind. Generally the access to this field is always via\n-   --   the functional interface, so the field names Char_CodeN, ElistN, ListN,\n-   --   NameN, NodeN, StrN, UintN and UrealN are used only in the bodies of the\n-   --   access functions (i.e. in the bodies of Sinfo and Einfo). These access\n-   --   functions contain debugging code that checks that the use is consistent\n-   --   with Nkind and Ekind values.\n+   --   Note: the actual usage of FieldN (i.e. whether it contains a Elist_Id,\n+   --   List_Id, Name_Id, Node_Id, String_Id, Uint or Ureal), depends on the\n+   --   value in Nkind. Generally the access to this field is always via the\n+   --   functional interface, so the field names ElistN, ListN, NameN, NodeN,\n+   --   StrN, UintN and UrealN are used only in the bodies of the access\n+   --   functions (i.e. in the bodies of Sinfo and Einfo). These access\n+   --   functions contain debugging code that checks that the use is\n+   --   consistent with Nkind and Ekind values.\n \n    --   However, in specialized circumstances (examples are the circuit in\n    --   generic instantiation to copy trees, and in the tree dump routine),\n@@ -988,9 +987,6 @@ package Atree is\n       function Name2 (N : Node_Id) return Name_Id;\n       pragma Inline (Name2);\n \n-      function Char_Code2 (N : Node_Id) return Char_Code;\n-      pragma Inline (Char_Code2);\n-\n       function Str3 (N : Node_Id) return String_Id;\n       pragma Inline (Str3);\n \n@@ -999,6 +995,9 @@ package Atree is\n       --  Uint_0 is returned. This avoids the rather tricky requirement\n       --  of initializing all Uint fields in nodes and entities.\n \n+      function Uint2 (N : Node_Id) return Uint;\n+      pragma Inline (Uint2);\n+\n       function Uint3 (N : Node_Id) return Uint;\n       pragma Inline (Uint3);\n \n@@ -1910,12 +1909,12 @@ package Atree is\n       procedure Set_Name2 (N : Node_Id; Val : Name_Id);\n       pragma Inline (Set_Name2);\n \n-      procedure Set_Char_Code2 (N : Node_Id; Val : Char_Code);\n-      pragma Inline (Set_Char_Code2);\n-\n       procedure Set_Str3 (N : Node_Id; Val : String_Id);\n       pragma Inline (Set_Str3);\n \n+      procedure Set_Uint2 (N : Node_Id; Val : Uint);\n+      pragma Inline (Set_Uint2);\n+\n       procedure Set_Uint3 (N : Node_Id; Val : Uint);\n       pragma Inline (Set_Uint3);\n \n@@ -2780,9 +2779,9 @@ package Atree is\n                Field4 : Union_Id;\n                Field5 : Union_Id;\n                --  Five general use fields, which can contain Node_Id, List_Id,\n-               --  Elist_Id, String_Id, Name_Id, or Char_Code values depending\n-               --  on the values in Nkind and (for extended nodes), in Ekind.\n-               --  See packages Sinfo and Einfo for details of their use.\n+               --  Elist_Id, String_Id, or Name_Id values depending on the\n+               --  values in Nkind and (for extended nodes), in Ekind. See\n+               --  packages Sinfo and Einfo for details of their use.\n \n             --  Extension (second component) of extended node\n "}, {"sha": "0d06969467ed1174fc7b0c741de6677c81803609", "filename": "gcc/ada/atree.h", "status": "modified", "additions": 87, "deletions": 5, "changes": 92, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/82c80734715c801643075ab68c5c9a5e00da1b03/gcc%2Fada%2Fatree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/82c80734715c801643075ab68c5c9a5e00da1b03/gcc%2Fada%2Fatree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fatree.h?ref=82c80734715c801643075ab68c5c9a5e00da1b03", "patch": "@@ -6,7 +6,7 @@\n  *                                                                          *\n  *                              C Header File                               *\n  *                                                                          *\n- *          Copyright (C) 1992-2003, Free Software Foundation, Inc.         *\n+ *          Copyright (C) 1992-2005, Free Software Foundation, Inc.         *\n  *                                                                          *\n  * GNAT is free software;  you can  redistribute it  and/or modify it under *\n  * terms of the  GNU General Public License as published  by the Free Soft- *\n@@ -216,6 +216,46 @@ struct Flag_Word3\n   Boolean      flag183\t    :  1;\n };\n \n+/* Structure used for extra flags in fifth component overlaying Field11 */\n+struct Flag_Word4\n+{\n+  Boolean      flag184\t    :  1;\n+  Boolean      flag185\t    :  1;\n+  Boolean      flag186\t    :  1;\n+  Boolean      flag187\t    :  1;\n+  Boolean      flag188\t    :  1;\n+  Boolean      flag189\t    :  1;\n+  Boolean      flag190\t    :  1;\n+  Boolean      flag191\t    :  1;\n+\n+  Boolean      flag192\t    :  1;\n+  Boolean      flag193\t    :  1;\n+  Boolean      flag194\t    :  1;\n+  Boolean      flag195\t    :  1;\n+  Boolean      flag196\t    :  1;\n+  Boolean      flag197\t    :  1;\n+  Boolean      flag198\t    :  1;\n+  Boolean      flag199\t    :  1;\n+\n+  Boolean      flag200\t    :  1;\n+  Boolean      flag201\t    :  1;\n+  Boolean      flag202\t    :  1;\n+  Boolean      flag203\t    :  1;\n+  Boolean      flag204\t    :  1;\n+  Boolean      flag205\t    :  1;\n+  Boolean      flag206\t    :  1;\n+  Boolean      flag207\t    :  1;\n+\n+  Boolean      flag208      :  1;\n+  Boolean      flag209\t    :  1;\n+  Boolean      flag210\t    :  1;\n+  Boolean      flag211\t    :  1;\n+  Boolean      flag212\t    :  1;\n+  Boolean      flag213\t    :  1;\n+  Boolean      flag214\t    :  1;\n+  Boolean      flag215\t    :  1;\n+};\n+\n struct Non_Extended\n {\n   Source_Ptr   sloc;\n@@ -238,14 +278,15 @@ struct Extended\n   union\n     {\n       Int      field11;\n-      struct Flag_Word3 fw3;\n+      struct   Flag_Word3 fw3;\n+      struct   Flag_Word4 fw4;\n     } X;\n \n   union\n     {\n       Int      field12;\n-      struct Flag_Word fw;\n-      struct Flag_Word2 fw2;\n+      struct   Flag_Word fw;\n+      struct   Flag_Word2 fw2;\n     } U;\n };\n \n@@ -272,7 +313,6 @@ struct Node\n    that Node_Id values can be used as subscripts.  */\n extern struct Node *Nodes_Ptr;\n \n-\n #define Parent atree__parent\n extern Node_Id Parent (Node_Id);\n \n@@ -338,6 +378,10 @@ extern Node_Id Current_Error_Node;\n #define Field21(N)    (Nodes_Ptr[(N) - First_Node_Id + 3].V.EX.field8)\n #define Field22(N)    (Nodes_Ptr[(N) - First_Node_Id + 3].V.EX.field9)\n #define Field23(N)    (Nodes_Ptr[(N) - First_Node_Id + 3].V.EX.field10)\n+#define Field24(N)    (Nodes_Ptr[(N) - First_Node_Id + 4].V.EX.field6)\n+#define Field25(N)    (Nodes_Ptr[(N) - First_Node_Id + 4].V.EX.field7)\n+#define Field26(N)    (Nodes_Ptr[(N) - First_Node_Id + 4].V.EX.field8)\n+#define Field27(N)    (Nodes_Ptr[(N) - First_Node_Id + 3].V.EX.field9)\n \n #define Node1(N)      Field1  (N)\n #define Node2(N)      Field2  (N)\n@@ -362,6 +406,10 @@ extern Node_Id Current_Error_Node;\n #define Node21(N)     Field21 (N)\n #define Node22(N)     Field22 (N)\n #define Node23(N)     Field23 (N)\n+#define Node24(N)     Field24 (N)\n+#define Node25(N)     Field25 (N)\n+#define Node26(N)     Field26 (N)\n+#define Node27(N)     Field27 (N)\n \n #define List1(N)      Field1  (N)\n #define List2(N)      Field2  (N)\n@@ -388,6 +436,7 @@ extern Node_Id Current_Error_Node;\n \n #define Str3(N)       Field3  (N)\n \n+#define Uint2(N)      ((Field2  (N) == 0) ? Uint_0 : Field2  (N))\n #define Uint3(N)      ((Field3  (N) == 0) ? Uint_0 : Field3  (N))\n #define Uint4(N)      ((Field4  (N) == 0) ? Uint_0 : Field4  (N))\n #define Uint5(N)      ((Field5  (N) == 0) ? Uint_0 : Field5  (N))\n@@ -599,3 +648,36 @@ extern Node_Id Current_Error_Node;\n #define Flag181(N)     (Nodes_Ptr[(N) - First_Node_Id + 3].V.EX.X.fw3.flag181)\n #define Flag182(N)     (Nodes_Ptr[(N) - First_Node_Id + 3].V.EX.X.fw3.flag182)\n #define Flag183(N)     (Nodes_Ptr[(N) - First_Node_Id + 3].V.EX.X.fw3.flag183)\n+\n+#define Flag184(N)     (Nodes_Ptr[(N) - First_Node_Id + 4].V.EX.X.fw4.flag184)\n+#define Flag185(N)     (Nodes_Ptr[(N) - First_Node_Id + 4].V.EX.X.fw4.flag185)\n+#define Flag186(N)     (Nodes_Ptr[(N) - First_Node_Id + 4].V.EX.X.fw4.flag186)\n+#define Flag187(N)     (Nodes_Ptr[(N) - First_Node_Id + 4].V.EX.X.fw4.flag187)\n+#define Flag188(N)     (Nodes_Ptr[(N) - First_Node_Id + 4].V.EX.X.fw4.flag188)\n+#define Flag189(N)     (Nodes_Ptr[(N) - First_Node_Id + 4].V.EX.X.fw4.flag189)\n+#define Flag190(N)     (Nodes_Ptr[(N) - First_Node_Id + 4].V.EX.X.fw4.flag190)\n+#define Flag191(N)     (Nodes_Ptr[(N) - First_Node_Id + 4].V.EX.X.fw4.flag191)\n+#define Flag192(N)     (Nodes_Ptr[(N) - First_Node_Id + 4].V.EX.X.fw4.flag192)\n+#define Flag193(N)     (Nodes_Ptr[(N) - First_Node_Id + 4].V.EX.X.fw4.flag193)\n+#define Flag194(N)     (Nodes_Ptr[(N) - First_Node_Id + 4].V.EX.X.fw4.flag194)\n+#define Flag195(N)     (Nodes_Ptr[(N) - First_Node_Id + 4].V.EX.X.fw4.flag195)\n+#define Flag196(N)     (Nodes_Ptr[(N) - First_Node_Id + 4].V.EX.X.fw4.flag196)\n+#define Flag197(N)     (Nodes_Ptr[(N) - First_Node_Id + 4].V.EX.X.fw4.flag197)\n+#define Flag198(N)     (Nodes_Ptr[(N) - First_Node_Id + 4].V.EX.X.fw4.flag198)\n+#define Flag199(N)     (Nodes_Ptr[(N) - First_Node_Id + 4].V.EX.X.fw4.flag199)\n+#define Flag200(N)     (Nodes_Ptr[(N) - First_Node_Id + 4].V.EX.X.fw4.flag200)\n+#define Flag201(N)     (Nodes_Ptr[(N) - First_Node_Id + 4].V.EX.X.fw4.flag201)\n+#define Flag202(N)     (Nodes_Ptr[(N) - First_Node_Id + 4].V.EX.X.fw4.flag202)\n+#define Flag203(N)     (Nodes_Ptr[(N) - First_Node_Id + 4].V.EX.X.fw4.flag203)\n+#define Flag204(N)     (Nodes_Ptr[(N) - First_Node_Id + 4].V.EX.X.fw4.flag204)\n+#define Flag205(N)     (Nodes_Ptr[(N) - First_Node_Id + 4].V.EX.X.fw4.flag205)\n+#define Flag206(N)     (Nodes_Ptr[(N) - First_Node_Id + 4].V.EX.X.fw4.flag206)\n+#define Flag207(N)     (Nodes_Ptr[(N) - First_Node_Id + 4].V.EX.X.fw4.flag207)\n+#define Flag208(N)     (Nodes_Ptr[(N) - First_Node_Id + 4].V.EX.X.fw4.flag208)\n+#define Flag209(N)     (Nodes_Ptr[(N) - First_Node_Id + 4].V.EX.X.fw4.flag209)\n+#define Flag210(N)     (Nodes_Ptr[(N) - First_Node_Id + 4].V.EX.X.fw4.flag210)\n+#define Flag211(N)     (Nodes_Ptr[(N) - First_Node_Id + 4].V.EX.X.fw4.flag211)\n+#define Flag212(N)     (Nodes_Ptr[(N) - First_Node_Id + 4].V.EX.X.fw4.flag212)\n+#define Flag213(N)     (Nodes_Ptr[(N) - First_Node_Id + 4].V.EX.X.fw4.flag213)\n+#define Flag214(N)     (Nodes_Ptr[(N) - First_Node_Id + 4].V.EX.X.fw4.flag214)\n+#define Flag215(N)     (Nodes_Ptr[(N) - First_Node_Id + 4].V.EX.X.fw4.flag215)"}, {"sha": "cc40af1964d5c300e4924376b42e56b8efda866b", "filename": "gcc/ada/binde.adb", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/82c80734715c801643075ab68c5c9a5e00da1b03/gcc%2Fada%2Fbinde.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/82c80734715c801643075ab68c5c9a5e00da1b03/gcc%2Fada%2Fbinde.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fbinde.adb?ref=82c80734715c801643075ab68c5c9a5e00da1b03", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1992-2003 Free Software Foundation, Inc.          --\n+--          Copyright (C) 1992-2005 Free Software Foundation, Inc.          --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -770,7 +770,7 @@ package body Binde is\n          --  Skip also if no ALI file for this with, happens with certain\n          --  specialized generic files that do not get compiled.\n \n-         if not Withs.Table (W).Interface\n+         if not Withs.Table (W).SAL_Interface\n            and then Withs.Table (W).Afile /= No_File\n            and then Generic_Separately_Compiled (Withs.Table (W).Sfile)\n          then\n@@ -1011,7 +1011,7 @@ package body Binde is\n          --  there is a body and a spec, then spec must be elaborated first\n          --  Note that the corresponding spec immediately follows the body\n \n-         if not Units.Table (U).Interface\n+         if not Units.Table (U).SAL_Interface\n            and then Units.Table (U).Utype = Is_Body\n          then\n             Build_Link (Corresponding_Spec (U), U, Spec_First);\n@@ -1021,12 +1021,12 @@ package body Binde is\n          --  process WITH references for this unit ignoring generic units and\n          --  interfaces to stand-alone libraries.\n \n-         if not Units.Table (U).Interface then\n+         if not Units.Table (U).SAL_Interface then\n             for\n               W in Units.Table (U).First_With .. Units.Table (U).Last_With\n             loop\n                if Withs.Table (W).Sfile /= No_File\n-                 and then (not Withs.Table (W).Interface)\n+                 and then (not Withs.Table (W).SAL_Interface)\n                then\n                   --  Check for special case of withing a unit that does not\n                   --  exist any more. If the unit was completely missing we"}, {"sha": "49d73c4bcc2fb4aed64f8efd1db5f62915d77081", "filename": "gcc/ada/bindgen.adb", "status": "modified", "additions": 72, "deletions": 20, "changes": 92, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/82c80734715c801643075ab68c5c9a5e00da1b03/gcc%2Fada%2Fbindgen.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/82c80734715c801643075ab68c5c9a5e00da1b03/gcc%2Fada%2Fbindgen.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fbindgen.adb?ref=82c80734715c801643075ab68c5c9a5e00da1b03", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1992-2004 Free Software Foundation, Inc.          --\n+--          Copyright (C) 1992-2005, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -390,7 +390,7 @@ package body Bindgen is\n \n             --  Don't generate reference for stand alone library\n \n-              and then not U.Interface\n+              and then not U.SAL_Interface\n \n             --  Don't generate reference for predefined file in No_Run_Time\n             --  mode, since we don't include the object files in this case\n@@ -715,7 +715,7 @@ package body Bindgen is\n \n             --  Don't generate reference for stand alone library\n \n-              and then not U.Interface\n+              and then not U.SAL_Interface\n \n             --  Don't generate reference for predefined file in No_Run_Time\n             --  mode, since we don't include the object files in this case\n@@ -979,7 +979,7 @@ package body Bindgen is\n                --  to True, we do not need to test if this has already been\n                --  done, since it is quicker to set the flag than to test it.\n \n-               if not U.Interface and then U.Utype = Is_Body\n+               if not U.SAL_Interface and then U.Utype = Is_Body\n                  and then Units.Table (Unum_Spec).Set_Elab_Entity\n                then\n                   Set_String (\"      E\");\n@@ -1004,7 +1004,7 @@ package body Bindgen is\n             --  The uname_E assignment is skipped if this is a separate spec,\n             --  since the assignment will be done when we process the body.\n \n-            elsif not U.Interface then\n+            elsif not U.SAL_Interface then\n                if Force_Checking_Of_Elaboration_Flags or\n                   Interface_Library_Unit or\n                   (not Bind_Main_Program)\n@@ -1097,7 +1097,7 @@ package body Bindgen is\n                --  to True, we do not need to test if this has already been\n                --  done, since it is quicker to set the flag than to test it.\n \n-               if not U.Interface and then U.Utype = Is_Body\n+               if not U.SAL_Interface and then U.Utype = Is_Body\n                  and then Units.Table (Unum_Spec).Set_Elab_Entity\n                then\n                   Set_String (\"   \");\n@@ -1118,7 +1118,7 @@ package body Bindgen is\n             --  The uname_E assignment is skipped if this is a separate spec,\n             --  since the assignment will be done when we process the body.\n \n-            elsif not U.Interface then\n+            elsif not U.SAL_Interface then\n                Get_Name_String (U.Uname);\n \n                if Force_Checking_Of_Elaboration_Flags or\n@@ -1270,7 +1270,7 @@ package body Bindgen is\n \n       Num := 0;\n       for A in ALIs.First .. ALIs.Last loop\n-         if not ALIs.Table (A).Interface\n+         if not ALIs.Table (A).SAL_Interface\n            and then ALIs.Table (A).Unit_Exception_Table\n          then\n             Num := Num + 1;\n@@ -1308,7 +1308,7 @@ package body Bindgen is\n       end if;\n \n       for A in ALIs.First .. ALIs.Last loop\n-         if not ALIs.Table (A).Interface\n+         if not ALIs.Table (A).SAL_Interface\n            and then ALIs.Table (A).Unit_Exception_Table\n          then\n             Get_Decoded_Name_String_With_Brackets\n@@ -1436,7 +1436,7 @@ package body Bindgen is\n \n       Num := 0;\n       for A in ALIs.First .. ALIs.Last loop\n-         if not ALIs.Table (A).Interface\n+         if not ALIs.Table (A).SAL_Interface\n            and then ALIs.Table (A).Unit_Exception_Table\n          then\n             Num := Num + 1;\n@@ -1466,7 +1466,7 @@ package body Bindgen is\n \n       Num2 := 0;\n       for A in ALIs.First .. ALIs.Last loop\n-         if not ALIs.Table (A).Interface\n+         if not ALIs.Table (A).SAL_Interface\n            and then ALIs.Table (A).Unit_Exception_Table\n          then\n             Num2 := Num2 + 1;\n@@ -1584,15 +1584,24 @@ package body Bindgen is\n          Write_Statement_Buffer;\n       end if;\n \n+      if Opt.Default_Exit_Status /= 0\n+        and then Bind_Main_Program\n+        and then not Configurable_Run_Time_Mode\n+      then\n+         WBI (\"      procedure Set_Exit_Status (Status : Integer);\");\n+         WBI (\"      pragma Import (C, Set_Exit_Status, \" &\n+                     \"\"\"__gnat_set_exit_status\"\");\");\n+         WBI (\"\");\n+      end if;\n+\n       --  Initialize and Finalize\n \n       if not Cumulative_Restrictions.Set (No_Finalization) then\n-         WBI (\"      procedure initialize;\");\n+         WBI (\"      procedure initialize (Addr : System.Address);\");\n          WBI (\"      pragma Import (C, initialize, \"\"__gnat_initialize\"\");\");\n          WBI (\"\");\n          WBI (\"      procedure finalize;\");\n          WBI (\"      pragma Import (C, finalize, \"\"__gnat_finalize\"\");\");\n-         WBI (\"\");\n       end if;\n \n       --  Deal with declarations for main program case\n@@ -1630,6 +1639,13 @@ package body Bindgen is\n \n          Write_Statement_Buffer;\n          WBI (\"\");\n+\n+         if Bind_Main_Program\n+           and then not Suppress_Standard_Library_On_Target\n+         then\n+            WBI (\"      SEH : aliased array (1 .. 2) of Integer;\");\n+            WBI (\"\");\n+         end if;\n       end if;\n \n       --  Generate a reference to Ada_Main_Program_Name. This symbol is\n@@ -1670,8 +1686,26 @@ package body Bindgen is\n          WBI (\"      gnat_envp := System.Null_Address;\");\n       end if;\n \n+      if Opt.Default_Exit_Status /= 0\n+        and then Bind_Main_Program\n+        and then not Configurable_Run_Time_Mode\n+      then\n+         Set_String (\"      Set_Exit_Status (\");\n+         Set_Int (Opt.Default_Exit_Status);\n+         Set_String (\");\");\n+         Write_Statement_Buffer;\n+      end if;\n+\n       if not Cumulative_Restrictions.Set (No_Finalization) then\n-         WBI (\"      Initialize;\");\n+\n+         if not No_Main_Subprogram\n+           and then Bind_Main_Program\n+           and then not Suppress_Standard_Library_On_Target\n+         then\n+            WBI (\"      Initialize (SEH'Address);\");\n+         else\n+            WBI (\"      Initialize (System.Null_Address);\");\n+         end if;\n       end if;\n \n       WBI (\"      \" & Ada_Init_Name.all & \";\");\n@@ -1758,6 +1792,13 @@ package body Bindgen is\n          WBI (\"   char *ensure_reference __attribute__ ((__unused__)) = \" &\n               \"__gnat_ada_main_program_name;\");\n          WBI (\"\");\n+\n+         if not Suppress_Standard_Library_On_Target\n+           and then not No_Main_Subprogram\n+         then\n+            WBI (\"   int SEH [2];\");\n+            WBI (\"\");\n+         end if;\n       end if;\n \n       --  If main program is a function, generate result variable\n@@ -1790,11 +1831,24 @@ package body Bindgen is\n          WBI (\"   gnat_envp = 0;\");\n       end if;\n \n+      if Opt.Default_Exit_Status /= 0\n+        and then Bind_Main_Program\n+        and then not Configurable_Run_Time_Mode\n+      then\n+         Set_String (\"   __gnat_set_exit_status (\");\n+         Set_Int (Opt.Default_Exit_Status);\n+         Set_String (\");\");\n+         Write_Statement_Buffer;\n+      end if;\n+\n       --  The __gnat_initialize routine is used only if we have a run-time\n \n       if not Suppress_Standard_Library_On_Target then\n-         WBI\n-          (\"   __gnat_initialize ();\");\n+         if not No_Main_Subprogram and then Bind_Main_Program then\n+            WBI (\"   __gnat_initialize ((void *)SEH);\");\n+         else\n+            WBI (\"   __gnat_initialize ((void *)0);\");\n+         end if;\n       end if;\n \n       WBI (\"   \" & Ada_Init_Name.all & \" ();\");\n@@ -1938,7 +1992,7 @@ package body Bindgen is\n          --  If not spec that has an associated body, then generate a\n          --  comment giving the name of the corresponding object file.\n \n-         if (not Units.Table (Elab_Order.Table (E)).Interface)\n+         if (not Units.Table (Elab_Order.Table (E)).SAL_Interface)\n            and then Units.Table (Elab_Order.Table (E)).Utype /= Is_Spec\n          then\n             Get_Name_String\n@@ -2502,7 +2556,7 @@ package body Bindgen is\n       end if;\n \n       if not Suppress_Standard_Library_On_Target then\n-         WBI (\"extern void __gnat_initialize (void);\");\n+         WBI (\"extern void __gnat_initialize (void *);\");\n          WBI (\"extern void __gnat_finalize (void);\");\n          WBI (\"extern void __gnat_install_handler (void);\");\n       end if;\n@@ -2530,7 +2584,6 @@ package body Bindgen is\n             WBI (\"extern int gnat_argc;\");\n             WBI (\"extern char **gnat_argv;\");\n             WBI (\"extern char **gnat_envp;\");\n-            WBI (\"extern int gnat_exit_status;\");\n \n          --  If configurable run time and no command line args, then the\n          --  generation of these variables is entirely suppressed.\n@@ -2545,7 +2598,6 @@ package body Bindgen is\n             WBI (\"int gnat_argc;\");\n             WBI (\"char **gnat_argv;\");\n             WBI (\"char **gnat_envp;\");\n-            WBI (\"int gnat_exit_status = 0;\");\n          end if;\n \n          --  Similarly deal with exit status"}, {"sha": "31b0ba823f7d973612df349506c1b601d2b44bee", "filename": "gcc/ada/bindusg.adb", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/82c80734715c801643075ab68c5c9a5e00da1b03/gcc%2Fada%2Fbindusg.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/82c80734715c801643075ab68c5c9a5e00da1b03/gcc%2Fada%2Fbindusg.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fbindusg.adb?ref=82c80734715c801643075ab68c5c9a5e00da1b03", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                B o d y                                   --\n --                                                                          --\n---          Copyright (C) 1992-2004 Free Software Foundation, Inc.          --\n+--          Copyright (C) 1992-2005 Free Software Foundation, Inc.          --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -227,6 +227,11 @@ begin\n    Write_Str (\"ject consistency only)\");\n    Write_Eol;\n \n+   --  Line for X switch\n+\n+   Write_Str (\"  -Xnnn     Default exit status value = nnn\");\n+   Write_Eol;\n+\n    --  Line for -z switch\n \n    Write_Str (\"  -z        No main subprogram (zero main)\");"}, {"sha": "6801837afc7df837fe288756bff03c8e583d4f00", "filename": "gcc/ada/checks.adb", "status": "modified", "additions": 28, "deletions": 10, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/82c80734715c801643075ab68c5c9a5e00da1b03/gcc%2Fada%2Fchecks.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/82c80734715c801643075ab68c5c9a5e00da1b03/gcc%2Fada%2Fchecks.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fchecks.adb?ref=82c80734715c801643075ab68c5c9a5e00da1b03", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1992-2004 Free Software Foundation, Inc.          --\n+--          Copyright (C) 1992-2005 Free Software Foundation, Inc.          --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -2591,19 +2591,28 @@ package body Checks is\n          then\n             case Msg_K is\n                when Components =>\n-                  Error_Msg_N\n-                    (\"(Ada 2005) NULL not allowed in null-excluding \" &\n-                     \"components\", Expr);\n+                  Apply_Compile_Time_Constraint_Error\n+                     (N      => Expr,\n+                      Msg    => \"(Ada 2005) NULL not allowed in\"\n+                                  & \" null-excluding components?\",\n+                      Reason => CE_Null_Not_Allowed,\n+                      Rep    => False);\n \n                when Formals =>\n-                  Error_Msg_N\n-                    (\"(Ada 2005) NULL not allowed in null-excluding formals\",\n-                     Expr);\n+                  Apply_Compile_Time_Constraint_Error\n+                     (N      => Expr,\n+                      Msg    => \"(Ada 2005) NULL not allowed in\"\n+                                  & \" null-excluding formals?\",\n+                      Reason => CE_Null_Not_Allowed,\n+                      Rep    => False);\n \n                when Objects =>\n-                  Error_Msg_N\n-                    (\"(Ada 2005) NULL not allowed in null-excluding objects\",\n-                     Expr);\n+                  Apply_Compile_Time_Constraint_Error\n+                     (N      => Expr,\n+                      Msg    => \"(Ada 2005) NULL not allowed in\"\n+                                  & \" null-excluding objects?\",\n+                      Reason => CE_Null_Not_Allowed,\n+                      Rep    => False);\n             end case;\n          end if;\n       end Check_Null_Not_Allowed;\n@@ -3478,6 +3487,15 @@ package body Checks is\n                   Set_Do_Range_Check (N, True);\n                   return;\n                end if;\n+\n+            --  Ditto if the prefix is an explicit dereference whose\n+            --  designated type is unconstrained.\n+\n+            elsif Nkind (Prefix (P)) = N_Explicit_Dereference\n+              and then not Is_Constrained (Atyp)\n+            then\n+               Set_Do_Range_Check (N, True);\n+               return;\n             end if;\n \n             Indx := First_Index (Atyp);"}, {"sha": "1f45f5e6d63e4861f1ab62e4f6a2850bae3404d9", "filename": "gcc/ada/cstand.adb", "status": "modified", "additions": 140, "deletions": 34, "changes": 174, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/82c80734715c801643075ab68c5c9a5e00da1b03/gcc%2Fada%2Fcstand.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/82c80734715c801643075ab68c5c9a5e00da1b03/gcc%2Fada%2Fcstand.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fcstand.adb?ref=82c80734715c801643075ab68c5c9a5e00da1b03", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1992-2004 Free Software Foundation, Inc.          --\n+--          Copyright (C) 1992-2005 Free Software Foundation, Inc.          --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -195,13 +195,14 @@ package body CStand is\n       Binary_Ops : constant array (S_Binary_Ops) of Name_Id :=\n \n          --  There is one entry here for each binary operator, except for the\n-         --  case of concatenation, where there are two entries, one for a\n-         --  String result, and one for a Wide_String result.\n+         --  case of concatenation, where there are three entries, one for a\n+         --  String result, one for Wide_String, and one for Wide_Wide_String.\n \n         (Name_Op_Add,\n          Name_Op_And,\n          Name_Op_Concat,\n          Name_Op_Concat,\n+         Name_Op_Concat,\n          Name_Op_Divide,\n          Name_Op_Eq,\n          Name_Op_Expon,\n@@ -222,24 +223,25 @@ package body CStand is\n          --  This table has the corresponding result types. The entries are\n          --  ordered so they correspond to the Binary_Ops array above.\n \n-        (Universal_Integer,       -- Add\n-         Standard_Boolean,        -- And\n-         Standard_String,         -- Concat (String)\n-         Standard_Wide_String,    -- Concat (Wide_String)\n-         Universal_Integer,       -- Divide\n-         Standard_Boolean,        -- Eq\n-         Universal_Integer,       -- Expon\n-         Standard_Boolean,        -- Ge\n-         Standard_Boolean,        -- Gt\n-         Standard_Boolean,        -- Le\n-         Standard_Boolean,        -- Lt\n-         Universal_Integer,       -- Mod\n-         Universal_Integer,       -- Multiply\n-         Standard_Boolean,        -- Ne\n-         Standard_Boolean,        -- Or\n-         Universal_Integer,       -- Rem\n-         Universal_Integer,       -- Subtract\n-         Standard_Boolean);       -- Xor\n+        (Universal_Integer,         -- Add\n+         Standard_Boolean,          -- And\n+         Standard_String,           -- Concat (String)\n+         Standard_Wide_String,      -- Concat (Wide_String)\n+         Standard_Wide_Wide_String, -- Concat (Wide_Wide_String)\n+         Universal_Integer,         -- Divide\n+         Standard_Boolean,          -- Eq\n+         Universal_Integer,         -- Expon\n+         Standard_Boolean,          -- Ge\n+         Standard_Boolean,          -- Gt\n+         Standard_Boolean,          -- Le\n+         Standard_Boolean,          -- Lt\n+         Universal_Integer,         -- Mod\n+         Universal_Integer,         -- Multiply\n+         Standard_Boolean,          -- Ne\n+         Standard_Boolean,          -- Or\n+         Universal_Integer,         -- Rem\n+         Universal_Integer,         -- Subtract\n+         Standard_Boolean);         -- Xor\n \n       Unary_Ops : constant array (S_Unary_Ops) of Name_Id :=\n \n@@ -277,13 +279,20 @@ package body CStand is\n       --  For concatenation, we create a separate operator for each\n       --  array type. This simplifies the resolution of the component-\n       --  component concatenation operation. In Standard, we set the types\n-      --  of the formals for string and wide string concatenation.\n+      --  of the formals for string, wide [wide]_string, concatenations.\n \n       Set_Etype (First_Entity (Standard_Op_Concat),  Standard_String);\n       Set_Etype (Last_Entity  (Standard_Op_Concat),  Standard_String);\n \n       Set_Etype (First_Entity (Standard_Op_Concatw), Standard_Wide_String);\n       Set_Etype (Last_Entity  (Standard_Op_Concatw), Standard_Wide_String);\n+\n+      Set_Etype (First_Entity (Standard_Op_Concatww),\n+                  Standard_Wide_Wide_String);\n+\n+      Set_Etype (Last_Entity (Standard_Op_Concatww),\n+                   Standard_Wide_Wide_String);\n+\n    end Create_Operators;\n \n    ---------------------\n@@ -537,8 +546,8 @@ package body CStand is\n       B_Node := New_Node (N_Character_Literal, Stloc);\n       Set_Is_Static_Expression (B_Node);\n       Set_Chars                (B_Node, No_Name);\n-      Set_Char_Literal_Value   (B_Node, 16#00#);\n-      Set_Entity               (B_Node,  Empty);\n+      Set_Char_Literal_Value   (B_Node, Uint_0);\n+      Set_Entity               (B_Node, Empty);\n       Set_Etype                (B_Node, Standard_Character);\n       Set_Low_Bound (R_Node, B_Node);\n \n@@ -547,8 +556,8 @@ package body CStand is\n       B_Node := New_Node (N_Character_Literal, Stloc);\n       Set_Is_Static_Expression (B_Node);\n       Set_Chars                (B_Node, No_Name);\n-      Set_Char_Literal_Value   (B_Node, 16#FF#);\n-      Set_Entity               (B_Node,  Empty);\n+      Set_Char_Literal_Value   (B_Node, UI_From_Int (16#FF#));\n+      Set_Entity               (B_Node, Empty);\n       Set_Etype                (B_Node, Standard_Character);\n       Set_High_Bound (R_Node, B_Node);\n \n@@ -582,8 +591,8 @@ package body CStand is\n       B_Node := New_Node (N_Character_Literal, Stloc);\n       Set_Is_Static_Expression (B_Node);\n       Set_Chars                (B_Node, No_Name);    --  ???\n-      Set_Char_Literal_Value   (B_Node, 16#0000#);\n-      Set_Entity               (B_Node,  Empty);\n+      Set_Char_Literal_Value   (B_Node, Uint_0);\n+      Set_Entity               (B_Node, Empty);\n       Set_Etype                (B_Node, Standard_Wide_Character);\n       Set_Low_Bound (R_Node, B_Node);\n \n@@ -592,15 +601,63 @@ package body CStand is\n       B_Node := New_Node (N_Character_Literal, Stloc);\n       Set_Is_Static_Expression (B_Node);\n       Set_Chars                (B_Node, No_Name);    --  ???\n-      Set_Char_Literal_Value   (B_Node, 16#FFFF#);\n-      Set_Entity               (B_Node,  Empty);\n+      Set_Char_Literal_Value   (B_Node, UI_From_Int (16#FFFF#));\n+      Set_Entity               (B_Node, Empty);\n       Set_Etype                (B_Node, Standard_Wide_Character);\n       Set_High_Bound           (R_Node, B_Node);\n \n       Set_Scalar_Range (Standard_Wide_Character, R_Node);\n       Set_Etype (R_Node, Standard_Wide_Character);\n       Set_Parent (R_Node, Standard_Wide_Character);\n \n+      --  Create type definition for type Wide_Wide_Character. Note that we\n+      --  do not set the Literals field, since type Wide_Wide_Character is\n+      --  handled with special routines that do not need a literal list.\n+\n+      Tdef_Node := New_Node (N_Enumeration_Type_Definition, Stloc);\n+      Set_Type_Definition (Parent (Standard_Wide_Wide_Character), Tdef_Node);\n+\n+      Set_Ekind (Standard_Wide_Wide_Character, E_Enumeration_Type);\n+      Set_Etype (Standard_Wide_Wide_Character,\n+                 Standard_Wide_Wide_Character);\n+      Init_Size (Standard_Wide_Wide_Character,\n+                 Standard_Wide_Wide_Character_Size);\n+\n+      Set_Elem_Alignment             (Standard_Wide_Wide_Character);\n+      Set_Is_Unsigned_Type           (Standard_Wide_Wide_Character);\n+      Set_Is_Character_Type          (Standard_Wide_Wide_Character);\n+      Set_Is_Known_Valid             (Standard_Wide_Wide_Character);\n+      Set_Size_Known_At_Compile_Time (Standard_Wide_Wide_Character);\n+      Set_Is_Ada_2005                (Standard_Wide_Wide_Character);\n+\n+      --  Create the bounds for type Wide_Wide_Character\n+\n+      R_Node := New_Node (N_Range, Stloc);\n+\n+      --  Low bound for type Wide_Wide_Character\n+\n+      B_Node := New_Node (N_Character_Literal, Stloc);\n+      Set_Is_Static_Expression (B_Node);\n+      Set_Chars                (B_Node, No_Name);    --  ???\n+      Set_Char_Literal_Value   (B_Node, Uint_0);\n+      Set_Entity               (B_Node, Empty);\n+      Set_Etype                (B_Node, Standard_Wide_Wide_Character);\n+      Set_Low_Bound (R_Node, B_Node);\n+\n+      --  High bound for type Wide_Wide_Character\n+\n+      B_Node := New_Node (N_Character_Literal, Stloc);\n+      Set_Is_Static_Expression (B_Node);\n+      Set_Chars                (B_Node, No_Name);    --  ???\n+      Set_Char_Literal_Value   (B_Node, UI_From_Int (16#7FFF_FFFF#));\n+      Set_Entity               (B_Node, Empty);\n+      Set_Etype                (B_Node, Standard_Wide_Wide_Character);\n+      Set_High_Bound           (R_Node, B_Node);\n+\n+      Set_Scalar_Range (Standard_Wide_Wide_Character, R_Node);\n+      Set_Etype (R_Node, Standard_Wide_Wide_Character);\n+      Set_Parent (R_Node, Standard_Wide_Wide_Character);\n+\n       --  Create type definition node for type String\n \n       Tdef_Node := New_Node (N_Unconstrained_Array_Definition, Stloc);\n@@ -609,9 +666,9 @@ package body CStand is\n          CompDef_Node : Node_Id;\n       begin\n          CompDef_Node := New_Node (N_Component_Definition, Stloc);\n-         Set_Aliased_Present    (CompDef_Node, False);\n-         Set_Access_Definition  (CompDef_Node, Empty);\n-         Set_Subtype_Indication (CompDef_Node, Identifier_For (S_Character));\n+         Set_Aliased_Present      (CompDef_Node, False);\n+         Set_Access_Definition    (CompDef_Node, Empty);\n+         Set_Subtype_Indication   (CompDef_Node, Identifier_For (S_Character));\n          Set_Component_Definition (Tdef_Node, CompDef_Node);\n       end;\n \n@@ -637,6 +694,7 @@ package body CStand is\n       --  Create type definition node for type Wide_String\n \n       Tdef_Node := New_Node (N_Unconstrained_Array_Definition, Stloc);\n+\n       declare\n          CompDef_Node : Node_Id;\n       begin\n@@ -647,6 +705,7 @@ package body CStand is\n                                  Identifier_For (S_Wide_Character));\n          Set_Component_Definition (Tdef_Node, CompDef_Node);\n       end;\n+\n       Set_Subtype_Marks (Tdef_Node, New_List);\n       Append (Identifier_For (S_Positive), Subtype_Marks (Tdef_Node));\n       Set_Type_Definition (Parent (Standard_Wide_String), Tdef_Node);\n@@ -665,6 +724,42 @@ package body CStand is\n       Set_Entity (E_Id, Standard_Positive);\n       Set_Etype (E_Id, Standard_Positive);\n \n+      --  Create type definition node for type Wide_Wide_String\n+\n+      Tdef_Node := New_Node (N_Unconstrained_Array_Definition, Stloc);\n+\n+      declare\n+         CompDef_Node : Node_Id;\n+      begin\n+         CompDef_Node := New_Node (N_Component_Definition, Stloc);\n+         Set_Aliased_Present    (CompDef_Node, False);\n+         Set_Access_Definition  (CompDef_Node, Empty);\n+         Set_Subtype_Indication (CompDef_Node,\n+                                 Identifier_For (S_Wide_Wide_Character));\n+         Set_Component_Definition (Tdef_Node, CompDef_Node);\n+      end;\n+\n+      Set_Subtype_Marks (Tdef_Node, New_List);\n+      Append (Identifier_For (S_Positive), Subtype_Marks (Tdef_Node));\n+      Set_Type_Definition (Parent (Standard_Wide_Wide_String), Tdef_Node);\n+\n+      Set_Ekind          (Standard_Wide_Wide_String, E_String_Type);\n+      Set_Etype          (Standard_Wide_Wide_String,\n+                          Standard_Wide_Wide_String);\n+      Set_Component_Type (Standard_Wide_Wide_String,\n+                          Standard_Wide_Wide_Character);\n+      Set_Component_Size (Standard_Wide_Wide_String, Uint_32);\n+      Init_Size_Align    (Standard_Wide_Wide_String);\n+      Set_Is_Ada_2005    (Standard_Wide_Wide_String);\n+\n+      --  Set index type of Wide_Wide_String\n+\n+      E_Id := First\n+        (Subtype_Marks (Type_Definition (Parent (Standard_Wide_Wide_String))));\n+      Set_First_Index (Standard_Wide_Wide_String, E_Id);\n+      Set_Entity (E_Id, Standard_Positive);\n+      Set_Etype (E_Id, Standard_Positive);\n+\n       --  Create subtype declaration for Natural\n \n       Decl := New_Node (N_Subtype_Declaration, Stloc);\n@@ -760,7 +855,7 @@ package body CStand is\n             Set_Is_Static_Expression (Expr_Decl);\n             Set_Chars                (Expr_Decl, No_Name);\n             Set_Etype                (Expr_Decl, Standard_Character);\n-            Set_Char_Literal_Value   (Expr_Decl, Ccode);\n+            Set_Char_Literal_Value   (Expr_Decl, UI_From_Int (Int (Ccode)));\n          end;\n \n          Append (Decl, Decl_A);\n@@ -1703,6 +1798,12 @@ package body CStand is\n       P (\"   --  See RM A.1(36) for details of this type\");\n       Write_Eol;\n \n+      P (\"   type Wide_Wide_Character is (...)\");\n+      Write_Str (\"   for Wide_Character'Size use \");\n+      Write_Int (Standard_Wide_Wide_Character_Size);\n+      P (\";\");\n+      P (\"   --  See RM A.1(36) for details of this type\");\n+\n       P (\"   type String is array (Positive range <>) of Character;\");\n       P (\"   pragma Pack (String);\");\n       Write_Eol;\n@@ -1712,6 +1813,11 @@ package body CStand is\n       P (\"   pragma Pack (Wide_String);\");\n       Write_Eol;\n \n+      P (\"   type Wide_Wide_String is array (Positive range <>)\" &\n+         \"  of Wide_Wide_Character;\");\n+      P (\"   pragma Pack (Wide_Wide_String);\");\n+      Write_Eol;\n+\n       --  Here it's OK to use the Duration type of the host compiler since\n       --  the implementation of Duration in GNAT is target independent.\n "}, {"sha": "8606bf0958a8d4debac9206ec6774b7ef9836361", "filename": "gcc/ada/einfo.adb", "status": "modified", "additions": 105, "deletions": 54, "changes": 159, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/82c80734715c801643075ab68c5c9a5e00da1b03/gcc%2Fada%2Feinfo.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/82c80734715c801643075ab68c5c9a5e00da1b03/gcc%2Fada%2Feinfo.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Feinfo.adb?ref=82c80734715c801643075ab68c5c9a5e00da1b03", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1992-2004 Free Software Foundation, Inc.          --\n+--          Copyright (C) 1992-2005, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -209,7 +209,8 @@ package body Einfo is\n    --    Privals_Chain                   Elist23\n    --    Protected_Operation             Node23\n \n-   --    (unused)                        Node24\n+   --    Obsolescent_Warning             Node24\n+\n    --    (unused)                        Node25\n    --    (unused)                        Node26\n    --    (unused)                        Node27\n@@ -391,6 +392,7 @@ package body Einfo is\n \n    --    Vax_Float                      Flag151\n    --    Entry_Accepted                 Flag152\n+   --    Is_Obsolescent                 Flag153\n    --    Has_Per_Object_Constraint      Flag154\n    --    Has_Private_Declaration        Flag155\n    --    Referenced                     Flag156\n@@ -424,10 +426,9 @@ package body Einfo is\n    --    Has_Contiguous_Rep             Flag181\n    --    Has_Xref_Entry                 Flag182\n    --    Must_Be_On_Byte_Boundary       Flag183\n+   --    Has_Stream_Size_Clause         Flag184\n+   --    Is_Ada_2005                    Flag185\n \n-   --    (unused)                       Flag153\n-   --    (unused)                       Flag184\n-   --    (unused)                       Flag185\n    --    (unused)                       Flag186\n    --    (unused)                       Flag187\n    --    (unused)                       Flag188\n@@ -459,6 +460,36 @@ package body Einfo is\n    --    (unused)                       Flag214\n    --    (unused)                       Flag215\n \n+   -----------------------\n+   -- Local subprograms --\n+   -----------------------\n+\n+   function Rep_Clause (Id : E; Rep_Name : Name_Id) return N;\n+   --  Returns the attribute definition clause whose name is Rep_Name. Returns\n+   --  Empty if not found.\n+\n+   ----------------\n+   -- Rep_Clause --\n+   ----------------\n+\n+   function Rep_Clause (Id : E; Rep_Name : Name_Id) return N is\n+      Ritem : Node_Id;\n+\n+   begin\n+      Ritem := First_Rep_Item (Id);\n+      while Present (Ritem) loop\n+         if Nkind (Ritem) = N_Attribute_Definition_Clause\n+           and then Chars (Ritem) = Rep_Name\n+         then\n+            return Ritem;\n+         else\n+            Ritem := Next_Rep_Item (Ritem);\n+         end if;\n+      end loop;\n+\n+      return Empty;\n+   end Rep_Clause;\n+\n    --------------------------------\n    -- Attribute Access Functions --\n    --------------------------------\n@@ -1238,6 +1269,12 @@ package body Einfo is\n       return Flag23 (Implementation_Base_Type (Id));\n    end Has_Storage_Size_Clause;\n \n+   function Has_Stream_Size_Clause (Id : E) return B is\n+   begin\n+      pragma Assert (Is_Elementary_Type (Id));\n+      return Flag184 (Id);\n+   end Has_Stream_Size_Clause;\n+\n    function Has_Subprogram_Descriptor (Id : E) return B is\n    begin\n       return Flag93 (Id);\n@@ -1317,6 +1354,11 @@ package body Einfo is\n       return Flag69 (Id);\n    end Is_Access_Constant;\n \n+   function Is_Ada_2005 (Id : E) return B is\n+   begin\n+      return Flag185 (Id);\n+   end Is_Ada_2005;\n+\n    function Is_Aliased (Id : E) return B is\n    begin\n       pragma Assert (Nkind (Id) in N_Entity);\n@@ -1574,6 +1616,12 @@ package body Einfo is\n       return Flag178 (Id);\n    end Is_Null_Init_Proc;\n \n+   function Is_Obsolescent (Id : E) return B is\n+   begin\n+      pragma Assert (Is_Subprogram (Id));\n+      return Flag153 (Id);\n+   end Is_Obsolescent;\n+\n    function Is_Optional_Parameter (Id : E) return B is\n    begin\n       pragma Assert (Is_Formal (Id));\n@@ -1881,6 +1929,12 @@ package body Einfo is\n       return Node17 (Id);\n    end Object_Ref;\n \n+   function Obsolescent_Warning (Id : E) return N is\n+   begin\n+      pragma Assert (Is_Subprogram (Id));\n+      return Node24 (Id);\n+   end Obsolescent_Warning;\n+\n    function Original_Access_Type (Id : E) return E is\n    begin\n       pragma Assert\n@@ -3171,6 +3225,12 @@ package body Einfo is\n       Set_Flag23 (Id, V);\n    end Set_Has_Storage_Size_Clause;\n \n+   procedure Set_Has_Stream_Size_Clause (Id : E; V : B := True) is\n+   begin\n+      pragma Assert (Is_Elementary_Type (Id));\n+      Set_Flag184 (Id, V);\n+   end Set_Has_Stream_Size_Clause;\n+\n    procedure Set_Has_Subprogram_Descriptor (Id : E; V : B := True) is\n    begin\n       Set_Flag93 (Id, V);\n@@ -3254,6 +3314,11 @@ package body Einfo is\n       Set_Flag69 (Id, V);\n    end Set_Is_Access_Constant;\n \n+   procedure Set_Is_Ada_2005 (Id : E; V : B := True) is\n+   begin\n+      Set_Flag185 (Id, V);\n+   end Set_Is_Ada_2005;\n+\n    procedure Set_Is_Aliased (Id : E; V : B := True) is\n    begin\n       pragma Assert (Nkind (Id) in N_Entity);\n@@ -3528,6 +3593,12 @@ package body Einfo is\n       Set_Flag178 (Id, V);\n    end Set_Is_Null_Init_Proc;\n \n+   procedure Set_Is_Obsolescent (Id : E; V : B := True) is\n+   begin\n+      pragma Assert (Is_Subprogram (Id));\n+      Set_Flag153 (Id, V);\n+   end Set_Is_Obsolescent;\n+\n    procedure Set_Is_Optional_Parameter (Id : E; V : B := True) is\n    begin\n       pragma Assert (Is_Formal (Id));\n@@ -3840,6 +3911,12 @@ package body Einfo is\n       Set_Node17 (Id, V);\n    end Set_Object_Ref;\n \n+   procedure Set_Obsolescent_Warning (Id : E; V : N) is\n+   begin\n+      pragma Assert (Is_Subprogram (Id));\n+      Set_Node24 (Id, V);\n+   end Set_Obsolescent_Warning;\n+\n    procedure Set_Original_Access_Type (Id : E; V : E) is\n    begin\n       pragma Assert\n@@ -4421,57 +4498,29 @@ package body Einfo is\n    --------------------\n \n    function Address_Clause (Id : E) return N is\n-      Ritem : Node_Id;\n-\n    begin\n-      Ritem := First_Rep_Item (Id);\n-      while Present (Ritem) loop\n-         if Nkind (Ritem) = N_Attribute_Definition_Clause\n-           and then Chars (Ritem) = Name_Address\n-         then\n-            return Ritem;\n-         else\n-            Ritem := Next_Rep_Item (Ritem);\n-         end if;\n-      end loop;\n-\n-      return Empty;\n+      return Rep_Clause (Id, Name_Address);\n    end Address_Clause;\n \n    ----------------------\n    -- Alignment_Clause --\n    ----------------------\n \n    function Alignment_Clause (Id : E) return N is\n-      Ritem : Node_Id;\n-\n    begin\n-      Ritem := First_Rep_Item (Id);\n-      while Present (Ritem) loop\n-         if Nkind (Ritem) = N_Attribute_Definition_Clause\n-           and then Chars (Ritem) = Name_Alignment\n-         then\n-            return Ritem;\n-         else\n-            Ritem := Next_Rep_Item (Ritem);\n-         end if;\n-      end loop;\n-\n-      return Empty;\n+      return Rep_Clause (Id, Name_Alignment);\n    end Alignment_Clause;\n \n    ----------------------\n    -- Ancestor_Subtype --\n    ----------------------\n \n-   function Ancestor_Subtype       (Id : E) return E is\n+   function Ancestor_Subtype (Id : E) return E is\n    begin\n       --  If this is first subtype, or is a base type, then there is no\n       --  ancestor subtype, so we return Empty to indicate this fact.\n \n-      if Is_First_Subtype (Id)\n-        or else Id = Base_Type (Id)\n-      then\n+      if Is_First_Subtype (Id) or else Id = Base_Type (Id) then\n          return Empty;\n       end if;\n \n@@ -4623,7 +4672,7 @@ package body Einfo is\n       then\n          Full_D := Parent (Full_View (Id));\n \n-         --  The full view may have been rewritten as an object renaming.\n+         --  The full view may have been rewritten as an object renaming\n \n          if Nkind (Full_D) = N_Object_Renaming_Declaration then\n             return Name (Full_D);\n@@ -4779,7 +4828,7 @@ package body Einfo is\n          Ent := Next_Entity (Ent);\n       end if;\n \n-      --  Skip all hidden stored discriminants if any.\n+      --  Skip all hidden stored discriminants if any\n \n       while Present (Ent) loop\n          exit when Ekind (Ent) = E_Discriminant\n@@ -5583,7 +5632,7 @@ package body Einfo is\n       --       E_Discriminant d2\n       --       ...\n \n-      --  so it is critical not to go past the leading discriminants.\n+      --  so it is critical not to go past the leading discriminants\n \n       D : E := Id;\n \n@@ -5903,23 +5952,19 @@ package body Einfo is\n    -----------------\n \n    function Size_Clause (Id : E) return N is\n-      Ritem : Node_Id;\n-\n    begin\n-      Ritem := First_Rep_Item (Id);\n-      while Present (Ritem) loop\n-         if Nkind (Ritem) = N_Attribute_Definition_Clause\n-           and then Chars (Ritem) = Name_Size\n-         then\n-            return Ritem;\n-         else\n-            Ritem := Next_Rep_Item (Ritem);\n-         end if;\n-      end loop;\n-\n-      return Empty;\n+      return Rep_Clause (Id, Name_Size);\n    end Size_Clause;\n \n+   ------------------------\n+   -- Stream_Size_Clause --\n+   ------------------------\n+\n+   function Stream_Size_Clause (Id : E) return N is\n+   begin\n+      return Rep_Clause (Id, Name_Stream_Size);\n+   end Stream_Size_Clause;\n+\n    ------------------\n    -- Subtype_Kind --\n    ------------------\n@@ -6216,6 +6261,7 @@ package body Einfo is\n       W (\"Has_Small_Clause\",              Flag67  (Id));\n       W (\"Has_Specified_Layout\",          Flag100 (Id));\n       W (\"Has_Storage_Size_Clause\",       Flag23  (Id));\n+      W (\"Has_Stream_Size_Clause\",        Flag184 (Id));\n       W (\"Has_Subprogram_Descriptor\",     Flag93  (Id));\n       W (\"Has_Task\",                      Flag30  (Id));\n       W (\"Has_Unchecked_Union\",           Flag123 (Id));\n@@ -6228,6 +6274,7 @@ package body Einfo is\n       W (\"Is_AST_Entry\",                  Flag132 (Id));\n       W (\"Is_Abstract\",                   Flag19  (Id));\n       W (\"Is_Access_Constant\",            Flag69  (Id));\n+      W (\"Is_Ada_2005\",                   Flag185 (Id));\n       W (\"Is_Aliased\",                    Flag15  (Id));\n       W (\"Is_Asynchronous\",               Flag81  (Id));\n       W (\"Is_Atomic\",                     Flag85  (Id));\n@@ -6275,6 +6322,7 @@ package body Einfo is\n       W (\"Is_Machine_Code_Subprogram\",    Flag137 (Id));\n       W (\"Is_Non_Static_Subtype\",         Flag109 (Id));\n       W (\"Is_Null_Init_Proc\",             Flag178 (Id));\n+      W (\"Is_Obsolescent\",                Flag153 (Id));\n       W (\"Is_Optional_Parameter\",         Flag134 (Id));\n       W (\"Is_Overriding_Operation\",       Flag39  (Id));\n       W (\"Is_Package_Body_Entity\",        Flag160 (Id));\n@@ -7207,6 +7255,9 @@ package body Einfo is\n    procedure Write_Field24_Name (Id : Entity_Id) is\n    begin\n       case Ekind (Id) is\n+         when Subprogram_Kind                            =>\n+            Write_Str (\"Obsolescent_Warning\");\n+\n          when others                                     =>\n             Write_Str (\"Field24??\");\n       end case;"}, {"sha": "573539fa1ba5c32be00d1b2db9b53e17612cb203", "filename": "gcc/ada/einfo.ads", "status": "modified", "additions": 44, "deletions": 2, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/82c80734715c801643075ab68c5c9a5e00da1b03/gcc%2Fada%2Feinfo.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/82c80734715c801643075ab68c5c9a5e00da1b03/gcc%2Fada%2Feinfo.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Feinfo.ads?ref=82c80734715c801643075ab68c5c9a5e00da1b03", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---          Copyright (C) 1992-2004 Free Software Foundation, Inc.          --\n+--          Copyright (C) 1992-2005, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -41,6 +41,10 @@ package Einfo is\n --  This package defines the annotations to the abstract syntax tree that\n --  are needed to support semantic processing of an Ada compilation.\n \n+--  Note that after editing this spec and the corresponding body it is\n+--  required to run ceinfo to check the consistentcy of spec and body.\n+--  See ceinfo.adb for more information about the checks made.\n+\n --  These annotations are for the most part attributes of declared entities,\n --  and they correspond to conventional symbol table information. Other\n --  attributes include sets of meanings for overloaded names, possible\n@@ -527,7 +531,7 @@ package Einfo is\n \n --    Component_Size (Uint22) [implementation base type only]\n --       Present in array types. It contains the component size value for\n---       the array. A value of zero means that the value is not yet set.\n+--       the array. A value of No_Uint means that the value is not yet set.\n --       The value can be set by the use of a component size clause, or\n --       by the front end in package Layout, or by the backend. A negative\n --       value is used to represent a value which is not known at compile\n@@ -1517,6 +1521,10 @@ package Einfo is\n --       of access types, this flag is present only in the root type, since a\n --       storage size clause cannot be given to a derived type.\n \n+--    Has_Stream_Size_Clause (Flag184)\n+--       This flag is set on types which have a Stream_Size clause attribute.\n+--       Used to prevent multiple Stream_Size clauses for a given entity.\n+\n --    Has_Subprogram_Descriptor (Flag93)\n --       This flag is set on entities for which zero-cost exception subprogram\n --       descriptors can be generated (subprograms and library level package\n@@ -1650,6 +1658,10 @@ package Einfo is\n --    Is_Access_Type (synthesized)\n --       Applies to all entities, true for access types and subtypes\n \n+--    Is_Ada_2005 (Flag185)\n+--       Applies to all entities, true if a valid pragma Ada_05 applies to the\n+--       entity, indicating that the entity is Ada 2005 only.\n+\n --    Is_Aliased (Flag15)\n --       Present in objects whose declarations carry the keyword aliased,\n --       and on record components that have the keyword.\n@@ -2091,6 +2103,10 @@ package Einfo is\n --       Applies to all entities, true for entities representing objects,\n --       including generic formal parameters.\n \n+--    Is_Obsolescent (Flag153)\n+--       Present in subprogram entities. Set if a valid pragma Obsolescent\n+--       applies to the subprogram.\n+\n --    Is_Optional_Parameter (Flag134)\n --       Present in parameter entities. Set if the parameter is specified as\n --       optional by use of a First_Optional_Parameter argument to one of the\n@@ -2649,6 +2665,11 @@ package Einfo is\n --       Applies to subprograms and subprogram types. Yields the number of\n --       formals as a value of type Pos.\n \n+--    Obsolescent_Warning (Node24)\n+--       Present in subprogram entities. Set non-empty only if the pragma\n+--       Obsolescent had a string argument, in which case it records the\n+--       contents of the corresponding string literal node.\n+\n --    Original_Access_Type (Node21)\n --       Present in access to subprogram types. Anonymous access to protected\n --       subprogram types are replaced by an occurrence of an internal access\n@@ -3912,6 +3933,7 @@ package Einfo is\n    --    Has_Qualified_Name            (Flag161)\n    --    Has_Unknown_Discriminants     (Flag72)\n    --    Has_Xref_Entry                (Flag182)\n+   --    Is_Ada_2005                   (Flag185)\n    --    Is_Bit_Packed_Array           (Flag122)  (base type only)\n    --    Is_Child_Unit                 (Flag73)\n    --    Is_Compilation_Unit           (Flag149)\n@@ -4297,6 +4319,7 @@ package Einfo is\n    --    Generic_Renamings             (Elist23)  (for an instance)\n    --    Inner_Instances               (Elist23)  (for a generic function)\n    --    Privals_Chain                 (Elist23)  (for a protected function)\n+   --    Obsolescent_Warning           (Node24)\n    --    Body_Needed_For_SAL           (Flag40)\n    --    Elaboration_Entity_Required   (Flag174)\n    --    Function_Returns_With_DSP     (Flag169)\n@@ -4321,6 +4344,7 @@ package Einfo is\n    --    Is_Instantiated               (Flag126)  (generic case only)\n    --    Is_Intrinsic_Subprogram       (Flag64)\n    --    Is_Machine_Code_Subprogram    (Flag137)  (non-generic case only)\n+   --    Is_Obsolescent                (Flag153)\n    --    Is_Overriding_Operation       (Flag39)   (non-generic case only)\n    --    Is_Private_Descendant         (Flag53)\n    --    Is_Pure                       (Flag44)\n@@ -4542,6 +4566,7 @@ package Einfo is\n    --    Generic_Renamings             (Elist23)  (for an instance)\n    --    Inner_Instances               (Elist23)  (for a generic procedure)\n    --    Privals_Chain                 (Elist23)  (for a protected procedure)\n+   --    Obsolescent_Warning           (Node24)\n    --    Body_Needed_For_SAL           (Flag40)\n    --    Elaboration_Entity_Required   (Flag174)\n    --    Function_Returns_With_DSP     (Flag169)  (always False for procedure)\n@@ -4566,6 +4591,7 @@ package Einfo is\n    --    Is_Intrinsic_Subprogram       (Flag64)\n    --    Is_Machine_Code_Subprogram    (Flag137)  (non-generic case only)\n    --    Is_Null_Init_Proc             (Flag178)\n+   --    Is_Obsolescent                (Flag153)\n    --    Is_Overriding_Operation       (Flag39)   (non-generic case only)\n    --    Is_Private_Descendant         (Flag53)\n    --    Is_Pure                       (Flag44)\n@@ -5114,6 +5140,7 @@ package Einfo is\n    function Has_Small_Clause                   (Id : E) return B;\n    function Has_Specified_Layout               (Id : E) return B;\n    function Has_Storage_Size_Clause            (Id : E) return B;\n+   function Has_Stream_Size_Clause             (Id : E) return B;\n    function Has_Subprogram_Descriptor          (Id : E) return B;\n    function Has_Task                           (Id : E) return B;\n    function Has_Unchecked_Union                (Id : E) return B;\n@@ -5130,6 +5157,7 @@ package Einfo is\n    function Is_AST_Entry                       (Id : E) return B;\n    function Is_Abstract                        (Id : E) return B;\n    function Is_Access_Constant                 (Id : E) return B;\n+   function Is_Ada_2005                        (Id : E) return B;\n    function Is_Aliased                         (Id : E) return B;\n    function Is_Asynchronous                    (Id : E) return B;\n    function Is_Atomic                          (Id : E) return B;\n@@ -5172,6 +5200,7 @@ package Einfo is\n    function Is_Machine_Code_Subprogram         (Id : E) return B;\n    function Is_Non_Static_Subtype              (Id : E) return B;\n    function Is_Null_Init_Proc                  (Id : E) return B;\n+   function Is_Obsolescent                     (Id : E) return B;\n    function Is_Optional_Parameter              (Id : E) return B;\n    function Is_Package_Body_Entity             (Id : E) return B;\n    function Is_Packed                          (Id : E) return B;\n@@ -5225,6 +5254,7 @@ package Einfo is\n    function Normalized_Position                (Id : E) return U;\n    function Normalized_Position_Max            (Id : E) return U;\n    function Object_Ref                         (Id : E) return E;\n+   function Obsolescent_Warning                (Id : E) return N;\n    function Original_Access_Type               (Id : E) return E;\n    function Original_Array_Type                (Id : E) return E;\n    function Original_Record_Component          (Id : E) return E;\n@@ -5385,6 +5415,7 @@ package Einfo is\n    function Root_Type                          (Id : E) return E;\n    function Scope_Depth_Set                    (Id : E) return B;\n    function Size_Clause                        (Id : E) return N;\n+   function Stream_Size_Clause                 (Id : E) return N;\n    function Tag_Component                      (Id : E) return E;\n    function Type_High_Bound                    (Id : E) return N;\n    function Type_Low_Bound                     (Id : E) return N;\n@@ -5583,6 +5614,7 @@ package Einfo is\n    procedure Set_Has_Small_Clause              (Id : E; V : B := True);\n    procedure Set_Has_Specified_Layout          (Id : E; V : B := True);\n    procedure Set_Has_Storage_Size_Clause       (Id : E; V : B := True);\n+   procedure Set_Has_Stream_Size_Clause        (Id : E; V : B := True);\n    procedure Set_Has_Subprogram_Descriptor     (Id : E; V : B := True);\n    procedure Set_Has_Task                      (Id : E; V : B := True);\n    procedure Set_Has_Unchecked_Union           (Id : E; V : B := True);\n@@ -5599,6 +5631,7 @@ package Einfo is\n    procedure Set_Is_AST_Entry                  (Id : E; V : B := True);\n    procedure Set_Is_Abstract                   (Id : E; V : B := True);\n    procedure Set_Is_Access_Constant            (Id : E; V : B := True);\n+   procedure Set_Is_Ada_2005                   (Id : E; V : B := True);\n    procedure Set_Is_Aliased                    (Id : E; V : B := True);\n    procedure Set_Is_Asynchronous               (Id : E; V : B := True);\n    procedure Set_Is_Atomic                     (Id : E; V : B := True);\n@@ -5646,6 +5679,7 @@ package Einfo is\n    procedure Set_Is_Machine_Code_Subprogram    (Id : E; V : B := True);\n    procedure Set_Is_Non_Static_Subtype         (Id : E; V : B := True);\n    procedure Set_Is_Null_Init_Proc             (Id : E; V : B := True);\n+   procedure Set_Is_Obsolescent                (Id : E; V : B := True);\n    procedure Set_Is_Optional_Parameter         (Id : E; V : B := True);\n    procedure Set_Is_Overriding_Operation       (Id : E; V : B := True);\n    procedure Set_Is_Package_Body_Entity        (Id : E; V : B := True);\n@@ -5699,6 +5733,7 @@ package Einfo is\n    procedure Set_Normalized_Position           (Id : E; V : U);\n    procedure Set_Normalized_Position_Max       (Id : E; V : U);\n    procedure Set_Object_Ref                    (Id : E; V : E);\n+   procedure Set_Obsolescent_Warning           (Id : E; V : N);\n    procedure Set_Original_Access_Type          (Id : E; V : E);\n    procedure Set_Original_Array_Type           (Id : E; V : E);\n    procedure Set_Original_Record_Component     (Id : E; V : E);\n@@ -6109,6 +6144,7 @@ package Einfo is\n    pragma Inline (Has_Small_Clause);\n    pragma Inline (Has_Specified_Layout);\n    pragma Inline (Has_Storage_Size_Clause);\n+   pragma Inline (Has_Stream_Size_Clause);\n    pragma Inline (Has_Subprogram_Descriptor);\n    pragma Inline (Has_Task);\n    pragma Inline (Has_Unchecked_Union);\n@@ -6125,6 +6161,7 @@ package Einfo is\n    pragma Inline (Is_AST_Entry);\n    pragma Inline (Is_Abstract);\n    pragma Inline (Is_Access_Constant);\n+   pragma Inline (Is_Ada_2005);\n    pragma Inline (Is_Access_Type);\n    pragma Inline (Is_Aliased);\n    pragma Inline (Is_Array_Type);\n@@ -6194,6 +6231,7 @@ package Einfo is\n    pragma Inline (Is_Named_Number);\n    pragma Inline (Is_Non_Static_Subtype);\n    pragma Inline (Is_Null_Init_Proc);\n+   pragma Inline (Is_Obsolescent);\n    pragma Inline (Is_Numeric_Type);\n    pragma Inline (Is_Object);\n    pragma Inline (Is_Optional_Parameter);\n@@ -6261,6 +6299,7 @@ package Einfo is\n    pragma Inline (Normalized_Position);\n    pragma Inline (Normalized_Position_Max);\n    pragma Inline (Object_Ref);\n+   pragma Inline (Obsolescent_Warning);\n    pragma Inline (Original_Access_Type);\n    pragma Inline (Original_Array_Type);\n    pragma Inline (Original_Record_Component);\n@@ -6468,6 +6507,7 @@ package Einfo is\n    pragma Inline (Set_Is_AST_Entry);\n    pragma Inline (Set_Is_Abstract);\n    pragma Inline (Set_Is_Access_Constant);\n+   pragma Inline (Set_Is_Ada_2005);\n    pragma Inline (Set_Is_Aliased);\n    pragma Inline (Set_Is_Asynchronous);\n    pragma Inline (Set_Is_Atomic);\n@@ -6515,6 +6555,7 @@ package Einfo is\n    pragma Inline (Set_Is_Machine_Code_Subprogram);\n    pragma Inline (Set_Is_Non_Static_Subtype);\n    pragma Inline (Set_Is_Null_Init_Proc);\n+   pragma Inline (Set_Is_Obsolescent);\n    pragma Inline (Set_Is_Optional_Parameter);\n    pragma Inline (Set_Is_Overriding_Operation);\n    pragma Inline (Set_Is_Package_Body_Entity);\n@@ -6568,6 +6609,7 @@ package Einfo is\n    pragma Inline (Set_Normalized_Position);\n    pragma Inline (Set_Normalized_Position_Max);\n    pragma Inline (Set_Object_Ref);\n+   pragma Inline (Set_Obsolescent_Warning);\n    pragma Inline (Set_Original_Access_Type);\n    pragma Inline (Set_Original_Array_Type);\n    pragma Inline (Set_Original_Record_Component);"}, {"sha": "6ddda3f0d45b6916d2be9d3700bfc35c05530354", "filename": "gcc/ada/errout.adb", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/82c80734715c801643075ab68c5c9a5e00da1b03/gcc%2Fada%2Ferrout.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/82c80734715c801643075ab68c5c9a5e00da1b03/gcc%2Fada%2Ferrout.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Ferrout.adb?ref=82c80734715c801643075ab68c5c9a5e00da1b03", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1992-2004 Free Software Foundation, Inc.          --\n+--          Copyright (C) 1992-2005 Free Software Foundation, Inc.          --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -1090,7 +1090,9 @@ package body Errout is\n       --  Source_Reference. This ensures outputting the proper name of\n       --  the source file in this situation.\n \n-      if Num_SRef_Pragmas (Main_Source_File) /= 0 then\n+      if Main_Source_File = No_Source_File or else\n+        Num_SRef_Pragmas (Main_Source_File) /= 0\n+      then\n          Current_Error_Source_File := No_Source_File;\n       end if;\n "}, {"sha": "7c965cd2a7fa591db1d9a3e81dcc490b89c67388", "filename": "gcc/ada/exp_attr.adb", "status": "modified", "additions": 115, "deletions": 14, "changes": 129, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/82c80734715c801643075ab68c5c9a5e00da1b03/gcc%2Fada%2Fexp_attr.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/82c80734715c801643075ab68c5c9a5e00da1b03/gcc%2Fada%2Fexp_attr.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_attr.adb?ref=82c80734715c801643075ab68c5c9a5e00da1b03", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1992-2004 Free Software Foundation, Inc.          --\n+--          Copyright (C) 1992-2005, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -497,12 +497,15 @@ package body Exp_Attr is\n    --  Start of processing for Expand_N_Attribute_Reference\n \n    begin\n-      --  Do required validity checking\n+      --  Do required validity checking, if enabled. Do not apply check to\n+      --  output parameters of an Asm instruction, since the value of this\n+      --  is not set till after the attribute has been elaborated.\n \n-      if Validity_Checks_On and Validity_Check_Operands then\n+      if Validity_Checks_On and then Validity_Check_Operands\n+        and then Id /= Attribute_Asm_Output\n+      then\n          declare\n             Expr : Node_Id;\n-\n          begin\n             Expr := First (Expressions (N));\n             while Present (Expr) loop\n@@ -1901,7 +1904,7 @@ package body Exp_Attr is\n                   --  Now we need to get the entity for the call, and construct\n                   --  a function call node, where we preset a reference to Dnn\n                   --  as the controlling argument (doing an unchecked\n-                  --  conversion to the classwide tagged type to make it\n+                  --  conversion to the class-wide tagged type to make it\n                   --  look like a real tagged object).\n \n                   Fname := Find_Prim_Op (Rtyp, TSS_Stream_Input);\n@@ -2398,8 +2401,6 @@ package body Exp_Attr is\n                                 Make_Integer_Literal (Loc,\n                                   Intval => 1))))))));\n \n-\n-\n          end if;\n \n          Analyze_And_Resolve (N, Btyp);\n@@ -3153,7 +3154,7 @@ package body Exp_Attr is\n             Rewrite (Prefix (N), New_Occurrence_Of (Entity (Pref), Loc));\n             return;\n \n-         --  For x'Size applied to an object of a class wide type, transform\n+         --  For x'Size applied to an object of a class-wide type, transform\n          --  X'Size into a call to the primitive operation _Size applied to X.\n \n          elsif Is_Class_Wide_Type (Ptyp) then\n@@ -3232,8 +3233,7 @@ package body Exp_Attr is\n          --  Common processing for record and array component case\n \n          if Siz /= 0 then\n-            Rewrite (N,\n-              Make_Integer_Literal (Loc, Siz));\n+            Rewrite (N, Make_Integer_Literal (Loc, Siz));\n \n             Analyze_And_Resolve (N, Typ);\n \n@@ -3364,6 +3364,29 @@ package body Exp_Attr is\n          end if;\n       end Storage_Size;\n \n+      -----------------\n+      -- Stream_Size --\n+      -----------------\n+\n+      when Attribute_Stream_Size => Stream_Size : declare\n+         Ptyp : constant Entity_Id := Etype (Pref);\n+         Size : Int;\n+\n+      begin\n+         --  If we have a Stream_Size clause for this type use it, otherwise\n+         --  the Stream_Size if the size of the type.\n+\n+         if Has_Stream_Size_Clause (Ptyp) then\n+            Size := UI_To_Int\n+              (Static_Integer (Expression (Stream_Size_Clause (Ptyp))));\n+         else\n+            Size := UI_To_Int (Esize (Ptyp));\n+         end if;\n+\n+         Rewrite (N, Make_Integer_Literal (Loc, Intval => Size));\n+         Analyze_And_Resolve (N, Typ);\n+      end Stream_Size;\n+\n       ----------\n       -- Succ --\n       ----------\n@@ -3998,6 +4021,39 @@ package body Exp_Attr is\n          Analyze_And_Resolve (N, Standard_Wide_String);\n       end Wide_Image;\n \n+      ---------------------\n+      -- Wide_Wide_Image --\n+      ---------------------\n+\n+      --  We expand typ'Wide_Wide_Image (X) into\n+\n+      --    String_To_Wide_Wide_String\n+      --      (typ'Image (X), Wide_Character_Encoding_Method)\n+\n+      --  This works in all cases because String_To_Wide_Wide_String converts\n+      --  any wide character escape sequences resulting from the Image call to\n+      --  the proper Wide_Character equivalent\n+\n+      --  not quite right for typ = Wide_Wide_Character ???\n+\n+      when Attribute_Wide_Wide_Image => Wide_Wide_Image :\n+      begin\n+         Rewrite (N,\n+           Make_Function_Call (Loc,\n+             Name => New_Reference_To\n+               (RTE (RE_String_To_Wide_Wide_String), Loc),\n+             Parameter_Associations => New_List (\n+               Make_Attribute_Reference (Loc,\n+                 Prefix         => Pref,\n+                 Attribute_Name => Name_Image,\n+                 Expressions    => Exprs),\n+\n+               Make_Integer_Literal (Loc,\n+                 Intval => Int (Wide_Character_Encoding_Method)))));\n+\n+         Analyze_And_Resolve (N, Standard_Wide_Wide_String);\n+      end Wide_Wide_Image;\n+\n       ----------------\n       -- Wide_Value --\n       ----------------\n@@ -4036,14 +4092,61 @@ package body Exp_Attr is\n          Analyze_And_Resolve (N, Typ);\n       end Wide_Value;\n \n+      ---------------------\n+      -- Wide_Wide_Value --\n+      ---------------------\n+\n+      --  We expand typ'Wide_Value_Value (X) into\n+\n+      --    typ'Value\n+      --      (Wide_Wide_String_To_String (X, Wide_Character_Encoding_Method))\n+\n+      --  Wide_Wide_String_To_String is a runtime function that converts its\n+      --  wide string argument to String, converting any non-translatable\n+      --  characters into appropriate escape sequences. This preserves the\n+      --  required semantics of Wide_Wide_Value in all cases, and results in a\n+      --  very simple implementation approach.\n+\n+      --  It's not quite right where typ = Wide_Wide_Character, because the\n+      --  encoding method may not cover the whole character type ???\n+\n+      when Attribute_Wide_Wide_Value => Wide_Wide_Value :\n+      begin\n+         Rewrite (N,\n+           Make_Attribute_Reference (Loc,\n+             Prefix         => Pref,\n+             Attribute_Name => Name_Value,\n+\n+             Expressions    => New_List (\n+               Make_Function_Call (Loc,\n+                 Name =>\n+                   New_Reference_To (RTE (RE_Wide_Wide_String_To_String), Loc),\n+\n+                 Parameter_Associations => New_List (\n+                   Relocate_Node (First (Exprs)),\n+                   Make_Integer_Literal (Loc,\n+                     Intval => Int (Wide_Character_Encoding_Method)))))));\n+\n+         Analyze_And_Resolve (N, Typ);\n+      end Wide_Wide_Value;\n+\n+      ---------------------\n+      -- Wide_Wide_Width --\n+      ---------------------\n+\n+      --  Wide_Wide_Width attribute is handled in separate unit Exp_Imgv\n+\n+      when Attribute_Wide_Wide_Width =>\n+         Exp_Imgv.Expand_Width_Attribute (N, Wide_Wide);\n+\n       ----------------\n       -- Wide_Width --\n       ----------------\n \n       --  Wide_Width attribute is handled in separate unit Exp_Imgv\n \n       when Attribute_Wide_Width =>\n-         Exp_Imgv.Expand_Width_Attribute (N, Wide => True);\n+         Exp_Imgv.Expand_Width_Attribute (N, Wide);\n \n       -----------\n       -- Width --\n@@ -4052,7 +4155,7 @@ package body Exp_Attr is\n       --  Width attribute is handled in separate unit Exp_Imgv\n \n       when Attribute_Width =>\n-         Exp_Imgv.Expand_Width_Attribute (N, Wide => False);\n+         Exp_Imgv.Expand_Width_Attribute (N, Normal);\n \n       -----------\n       -- Write --\n@@ -4318,7 +4421,6 @@ package body Exp_Attr is\n                     New_Reference_To (Base_Type (Etype (Prefix (N))), Loc),\n                   Attribute_Name => Cnam)),\n           Reason => CE_Overflow_Check_Failed));\n-\n    end Expand_Pred_Succ;\n \n    ------------------------\n@@ -4354,7 +4456,6 @@ package body Exp_Attr is\n       end if;\n \n       return Proc;\n-\n    end Find_Inherited_TSS;\n \n    ----------------------------"}, {"sha": "35084860c8c959986236cd830e3463a9d2bc47fa", "filename": "gcc/ada/exp_ch11.adb", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/82c80734715c801643075ab68c5c9a5e00da1b03/gcc%2Fada%2Fexp_ch11.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/82c80734715c801643075ab68c5c9a5e00da1b03/gcc%2Fada%2Fexp_ch11.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch11.adb?ref=82c80734715c801643075ab68c5c9a5e00da1b03", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1992-2004 Free Software Foundation, Inc.          --\n+--          Copyright (C) 1992-2005 Free Software Foundation, Inc.          --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -921,7 +921,9 @@ package body Exp_Ch11 is\n       --  Lang component: 'A'\n \n       Append_To (L,\n-        Make_Character_Literal (Loc, Name_uA, Get_Char_Code ('A')));\n+        Make_Character_Literal (Loc,\n+          Chars              =>  Name_uA,\n+          Char_Literal_Value =>  UI_From_Int (Character'Pos ('A'))));\n \n       --  Name_Length component: Nam'Length\n "}, {"sha": "1d027d05176444873b13aca63a39883483beb756", "filename": "gcc/ada/exp_ch3.adb", "status": "modified", "additions": 215, "deletions": 62, "changes": 277, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/82c80734715c801643075ab68c5c9a5e00da1b03/gcc%2Fada%2Fexp_ch3.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/82c80734715c801643075ab68c5c9a5e00da1b03/gcc%2Fada%2Fexp_ch3.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch3.adb?ref=82c80734715c801643075ab68c5c9a5e00da1b03", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1992-2004 Free Software Foundation, Inc.          --\n+--          Copyright (C) 1992-2005 Free Software Foundation, Inc.          --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -60,7 +60,6 @@ with Stand;    use Stand;\n with Snames;   use Snames;\n with Tbuild;   use Tbuild;\n with Ttypes;   use Ttypes;\n-with Uintp;    use Uintp;\n with Validsw;  use Validsw;\n \n package body Exp_Ch3 is\n@@ -487,7 +486,9 @@ package body Exp_Ch3 is\n             return New_List (\n               Make_Assignment_Statement (Loc,\n                 Name => Comp,\n-                Expression => Get_Simple_Init_Val (Comp_Type, Loc)));\n+                Expression =>\n+                  Get_Simple_Init_Val\n+                    (Comp_Type, Loc, Component_Size (A_Type))));\n \n          else\n             return\n@@ -567,19 +568,21 @@ package body Exp_Ch3 is\n       --  apply in this case), and we must generate a procedure (even if it is\n       --  null) to satisfy the call in this case.\n \n-      --  Exception: do not build an array init_proc for a type whose root type\n-      --  is Standard.String or Standard.Wide_String, since there is no place\n-      --  to put the code, and in any case we handle initialization of such\n-      --  types (in the Initialize_Scalars case, that's the only time the issue\n-      --  arises) in a special manner anyway which does not need an init_proc.\n+      --  Exception: do not build an array init_proc for a type whose root\n+      --  type is Standard.String or Standard.Wide_[Wide_]String, since there\n+      --  is no place to put the code, and in any case we handle initialization\n+      --  of such types (in the Initialize_Scalars case, that's the only time\n+      --  the issue arises) in a special manner anyway which does not need an\n+      --  init_proc.\n \n       if Has_Non_Null_Base_Init_Proc (Comp_Type)\n         or else Needs_Simple_Initialization (Comp_Type)\n         or else Has_Task (Comp_Type)\n         or else (not Restriction_Active (No_Initialize_Scalars)\n                    and then Is_Public (A_Type)\n                    and then Root_Type (A_Type) /= Standard_String\n-                   and then Root_Type (A_Type) /= Standard_Wide_String)\n+                   and then Root_Type (A_Type) /= Standard_Wide_String\n+                   and then Root_Type (A_Type) /= Standard_Wide_Wide_String)\n       then\n          Proc_Id :=\n            Make_Defining_Identifier (Loc, Make_Init_Proc_Name (A_Type));\n@@ -654,6 +657,7 @@ package body Exp_Ch3 is\n       --  Nothing to do if we already built a master entity for this scope\n \n       if not Has_Master_Entity (Scope (T)) then\n+\n          --  first build the master entity\n          --    _Master : constant Master_Id := Current_Master.all;\n          --  and insert it just before the current declaration\n@@ -1996,7 +2000,8 @@ package body Exp_Ch3 is\n \n                elsif Component_Needs_Simple_Initialization (Typ) then\n                   Stmts :=\n-                    Build_Assignment (Id, Get_Simple_Init_Val (Typ, Loc));\n+                    Build_Assignment\n+                      (Id, Get_Simple_Init_Val (Typ, Loc, Esize (Id)));\n \n                --  Nothing needed for this case\n \n@@ -2058,7 +2063,8 @@ package body Exp_Ch3 is\n \n                   elsif Component_Needs_Simple_Initialization (Typ) then\n                      Append_List_To (Statement_List,\n-                       Build_Assignment (Id, Get_Simple_Init_Val (Typ, Loc)));\n+                       Build_Assignment\n+                         (Id, Get_Simple_Init_Val (Typ, Loc, Esize (Id))));\n                   end if;\n                end if;\n \n@@ -3403,7 +3409,7 @@ package body Exp_Ch3 is\n \n          elsif Needs_Simple_Initialization (Typ) then\n             Set_No_Initialization (N, False);\n-            Set_Expression (N, Get_Simple_Init_Val (Typ, Loc));\n+            Set_Expression (N, Get_Simple_Init_Val (Typ, Loc, Esize (Def_Id)));\n             Analyze_And_Resolve (Expression (N), Typ);\n          end if;\n \n@@ -3877,13 +3883,14 @@ package body Exp_Ch3 is\n             then\n                null;\n \n-            --  We do not need an init proc for string or wide string, since\n-            --  the only time these need initialization in normalize or\n+            --  We do not need an init proc for string or wide [wide] string,\n+            --  since the only time these need initialization in normalize or\n             --  initialize scalars mode, and these types are treated specially\n             --  and do not need initialization procedures.\n \n             elsif Root_Type (Base) = Standard_String\n               or else Root_Type (Base) = Standard_Wide_String\n+              or else Root_Type (Base) = Standard_Wide_Wide_String\n             then\n                null;\n \n@@ -4878,22 +4885,95 @@ package body Exp_Ch3 is\n    -------------------------\n \n    function Get_Simple_Init_Val\n-     (T   : Entity_Id;\n-      Loc : Source_Ptr) return Node_Id\n+     (T    : Entity_Id;\n+      Loc  : Source_Ptr;\n+      Size : Uint := No_Uint) return Node_Id\n    is\n       Val    : Node_Id;\n-      Typ    : Node_Id;\n       Result : Node_Id;\n       Val_RE : RE_Id;\n \n+      Size_To_Use : Uint;\n+      --  This is the size to be used for computation of the appropriate\n+      --  initial value for the Normalize_Scalars and Initialize_Scalars case.\n+\n+      Lo_Bound : Uint;\n+      Hi_Bound : Uint;\n+      --  These are the values computed by the procedure Check_Subtype_Bounds\n+\n+      procedure Check_Subtype_Bounds;\n+      --  This procedure examines the subtype T, and its ancestor subtypes\n+      --  and derived types to determine the best known information about\n+      --  the bounds of the subtype. After the call Lo_Bound is set either\n+      --  to No_Uint if no information can be determined, or to a value which\n+      --  represents a known low bound, i.e. a valid value of the subtype can\n+      --  not be less than this value. Hi_Bound is similarly set to a known\n+      --  high bound (valid value cannot be greater than this).\n+\n+      --------------------------\n+      -- Check_Subtype_Bounds --\n+      --------------------------\n+\n+      procedure Check_Subtype_Bounds is\n+         ST1  : Entity_Id;\n+         ST2  : Entity_Id;\n+         Lo   : Node_Id;\n+         Hi   : Node_Id;\n+         Loval : Uint;\n+         Hival : Uint;\n+\n+      begin\n+         Lo_Bound := No_Uint;\n+         Hi_Bound := No_Uint;\n+\n+         --  Loop to climb ancestor subtypes and derived types\n+\n+         ST1 := T;\n+         loop\n+            if not Is_Discrete_Type (ST1) then\n+               return;\n+            end if;\n+\n+            Lo := Type_Low_Bound (ST1);\n+            Hi := Type_High_Bound (ST1);\n+\n+            if Compile_Time_Known_Value (Lo) then\n+               Loval := Expr_Value (Lo);\n+\n+               if Lo_Bound = No_Uint or else Lo_Bound < Loval then\n+                  Lo_Bound := Loval;\n+               end if;\n+            end if;\n+\n+            if Compile_Time_Known_Value (Hi) then\n+               Hival := Expr_Value (Hi);\n+\n+               if Hi_Bound = No_Uint or else Hi_Bound > Hival then\n+                  Hi_Bound := Hival;\n+               end if;\n+            end if;\n+\n+            ST2 := Ancestor_Subtype (ST1);\n+\n+            if No (ST2) then\n+               ST2 := Etype (ST1);\n+            end if;\n+\n+            exit when ST1 = ST2;\n+            ST1 := ST2;\n+         end loop;\n+      end Check_Subtype_Bounds;\n+\n+   --  Start of processing for Get_Simple_Init_Val\n+\n    begin\n       --  For a private type, we should always have an underlying type\n       --  (because this was already checked in Needs_Simple_Initialization).\n       --  What we do is to get the value for the underlying type and then\n       --  do an Unchecked_Convert to the private type.\n \n       if Is_Private_Type (T) then\n-         Val := Get_Simple_Init_Val (Underlying_Type (T), Loc);\n+         Val := Get_Simple_Init_Val (Underlying_Type (T), Loc, Size);\n \n          --  A special case, if the underlying value is null, then qualify\n          --  it with the underlying type, so that the null is properly typed\n@@ -4927,46 +5007,98 @@ package body Exp_Ch3 is\n       elsif Is_Scalar_Type (T) then\n          pragma Assert (Init_Or_Norm_Scalars);\n \n+         --  Compute size of object. If it is given by the caller, we can\n+         --  use it directly, otherwise we use Esize (T) as an estimate. As\n+         --  far as we know this covers all cases correctly.\n+\n+         if Size = No_Uint or else Size <= Uint_0 then\n+            Size_To_Use := UI_Max (Uint_1, Esize (T));\n+         else\n+            Size_To_Use := Size;\n+         end if;\n+\n+         --  Maximum size to use is 64 bits, since we will create values\n+         --  of type Unsigned_64 and the range must fit this type.\n+\n+         if Size_To_Use /= No_Uint and then Size_To_Use > Uint_64 then\n+            Size_To_Use := Uint_64;\n+         end if;\n+\n+         --  Check known bounds of subtype\n+\n+         Check_Subtype_Bounds;\n+\n          --  Processing for Normalize_Scalars case\n \n          if Normalize_Scalars then\n \n-            --  First prepare a value (out of subtype range if possible)\n+            --  If zero is invalid, it is a convenient value to use that is\n+            --  for sure an appropriate invalid value in all situations.\n+\n+            if Lo_Bound /= No_Uint and then Lo_Bound > Uint_0 then\n+               Val := Make_Integer_Literal (Loc, 0);\n+\n+            --  Cases where all one bits is the appropriate invalid value\n+\n+            --  For modular types, all 1 bits is either invalid or valid. If\n+            --  it is valid, then there is nothing that can be done since there\n+            --  are no invalid values (we ruled out zero already).\n+\n+            --  For signed integer types that have no negative values, either\n+            --  there is room for negative values, or there is not. If there\n+            --  is, then all 1 bits may be interpretecd as minus one, which is\n+            --  certainly invalid. Alternatively it is treated as the largest\n+            --  positive value, in which case the observation for modular types\n+            --  still applies.\n+\n+            --  For float types, all 1-bits is a NaN (not a number), which is\n+            --  certainly an appropriately invalid value.\n \n-            if Is_Real_Type (T) or else Is_Integer_Type (T) then\n-               Val :=\n-                 Make_Attribute_Reference (Loc,\n-                   Prefix => New_Occurrence_Of (Base_Type (T), Loc),\n-                   Attribute_Name => Name_First);\n+            elsif Is_Unsigned_Type (T)\n+              or else Is_Floating_Point_Type (T)\n+              or else Is_Enumeration_Type (T)\n+            then\n+               Val := Make_Integer_Literal (Loc, 2 ** Size_To_Use - 1);\n+\n+               --  Resolve as Unsigned_64, because the largest number we\n+               --  can generate is out of range of universal integer.\n+\n+               Analyze_And_Resolve (Val, RTE (RE_Unsigned_64));\n \n-            elsif Is_Modular_Integer_Type (T) then\n-               Val :=\n-                 Make_Attribute_Reference (Loc,\n-                   Prefix => New_Occurrence_Of (Base_Type (T), Loc),\n-                   Attribute_Name => Name_Last);\n+            --  Case of signed types\n \n             else\n-               pragma Assert (Is_Enumeration_Type (T));\n-\n-               if Esize (T) <= 8 then\n-                  Typ := RTE (RE_Unsigned_8);\n-               elsif Esize (T) <= 16 then\n-                  Typ := RTE (RE_Unsigned_16);\n-               elsif Esize (T) <= 32 then\n-                  Typ := RTE (RE_Unsigned_32);\n-               else\n-                  Typ := RTE (RE_Unsigned_64);\n-               end if;\n+               declare\n+                  Signed_Size : constant Uint :=\n+                                  UI_Min (Uint_63, Size_To_Use - 1);\n+\n+               begin\n+                  --  Normally we like to use the most negative number. The\n+                  --  one exception is when this number is in the known subtype\n+                  --  range and the largest positive number is not in the known\n+                  --  subtype range.\n+\n+                  --  For this exceptional case, use largest positive value\n \n-               Val :=\n-                 Make_Attribute_Reference (Loc,\n-                   Prefix => New_Occurrence_Of (Typ, Loc),\n-                   Attribute_Name => Name_Last);\n+                  if Lo_Bound /= No_Uint and then Hi_Bound /= No_Uint\n+                    and then Lo_Bound <= (-(2 ** Signed_Size))\n+                    and then Hi_Bound < 2 ** Signed_Size\n+                  then\n+                     Val := Make_Integer_Literal (Loc, 2 ** Signed_Size - 1);\n+\n+                     --  Normal case of largest negative value\n+\n+                  else\n+                     Val := Make_Integer_Literal (Loc, -(2 ** Signed_Size));\n+                  end if;\n+               end;\n             end if;\n \n          --  Here for Initialize_Scalars case\n \n          else\n+            --  For float types, use float values from System.Scalar_Values\n+\n             if Is_Floating_Point_Type (T) then\n                if Root_Type (T) = Standard_Short_Float then\n                   Val_RE := RE_IS_Isf;\n@@ -4978,37 +5110,54 @@ package body Exp_Ch3 is\n                   Val_RE := RE_IS_Ill;\n                end if;\n \n-            elsif Is_Unsigned_Type (Base_Type (T)) then\n-               if Esize (T) = 8 then\n+            --  If zero is invalid, use zero values from System.Scalar_Values\n+\n+            elsif Lo_Bound /= No_Uint and then Lo_Bound > Uint_0 then\n+               if Size_To_Use <= 8 then\n+                  Val_RE := RE_IS_Iz1;\n+               elsif Size_To_Use <= 16 then\n+                  Val_RE := RE_IS_Iz2;\n+               elsif Size_To_Use <= 32 then\n+                  Val_RE := RE_IS_Iz4;\n+               else\n+                  Val_RE := RE_IS_Iz8;\n+               end if;\n+\n+            --  For unsigned, use unsigned values from System.Scalar_Values\n+\n+            elsif Is_Unsigned_Type (T) then\n+               if Size_To_Use <= 8 then\n                   Val_RE := RE_IS_Iu1;\n-               elsif Esize (T) = 16 then\n+               elsif Size_To_Use <= 16 then\n                   Val_RE := RE_IS_Iu2;\n-               elsif Esize (T) = 32 then\n+               elsif Size_To_Use <= 32 then\n                   Val_RE := RE_IS_Iu4;\n-               else pragma Assert (Esize (T) = 64);\n+               else\n                   Val_RE := RE_IS_Iu8;\n                end if;\n \n-            else -- signed type\n-               if Esize (T) = 8 then\n+            --  For signed, use signed values from System.Scalar_Values\n+\n+            else\n+               if Size_To_Use <= 8 then\n                   Val_RE := RE_IS_Is1;\n-               elsif Esize (T) = 16 then\n+               elsif Size_To_Use <= 16 then\n                   Val_RE := RE_IS_Is2;\n-               elsif Esize (T) = 32 then\n+               elsif Size_To_Use <= 32 then\n                   Val_RE := RE_IS_Is4;\n-               else pragma Assert (Esize (T) = 64);\n+               else\n                   Val_RE := RE_IS_Is8;\n                end if;\n             end if;\n \n             Val := New_Occurrence_Of (RTE (Val_RE), Loc);\n          end if;\n \n-         --  The final expression is obtained by doing an unchecked\n-         --  conversion of this result to the base type of the\n-         --  required subtype. We use the base type to avoid the\n-         --  unchecked conversion from chopping bits, and then we\n-         --  set Kill_Range_Check to preserve the \"bad\" value.\n+         --  The final expression is obtained by doing an unchecked conversion\n+         --  of this result to the base type of the required subtype. We use\n+         --  the base type to avoid the unchecked conversion from chopping\n+         --  bits, and then we set Kill_Range_Check to preserve the \"bad\"\n+         --  value.\n \n          Result := Unchecked_Convert_To (Base_Type (T), Val);\n \n@@ -5022,11 +5171,13 @@ package body Exp_Ch3 is\n \n          return Result;\n \n-      --  String or Wide_String (must have Initialize_Scalars set)\n+      --  String or Wide_[Wide]_String (must have Initialize_Scalars set)\n \n       elsif Root_Type (T) = Standard_String\n               or else\n             Root_Type (T) = Standard_Wide_String\n+              or else\n+            Root_Type (T) = Standard_Wide_Wide_String\n       then\n          pragma Assert (Init_Or_Norm_Scalars);\n \n@@ -5037,7 +5188,8 @@ package body Exp_Ch3 is\n                  Choices => New_List (\n                    Make_Others_Choice (Loc)),\n                  Expression =>\n-                   Get_Simple_Init_Val (Component_Type (T), Loc))));\n+                   Get_Simple_Init_Val\n+                     (Component_Type (T), Loc, Esize (Root_Type (T))))));\n \n       --  Access type is initialized to null\n \n@@ -5570,7 +5722,8 @@ package body Exp_Ch3 is\n       elsif Init_Or_Norm_Scalars\n         and then\n           (Root_Type (T) = Standard_String\n-            or else Root_Type (T) = Standard_Wide_String)\n+             or else Root_Type (T) = Standard_Wide_String\n+             or else Root_Type (T) = Standard_Wide_Wide_String)\n         and then\n           (not Is_Itype (T)\n             or else Nkind (Associated_Node_For_Itype (T)) /= N_Aggregate)"}, {"sha": "59f8ef710084fdf5c9b0c313564ea7080d89c1c4", "filename": "gcc/ada/exp_ch3.ads", "status": "modified", "additions": 10, "deletions": 3, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/82c80734715c801643075ab68c5c9a5e00da1b03/gcc%2Fada%2Fexp_ch3.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/82c80734715c801643075ab68c5c9a5e00da1b03/gcc%2Fada%2Fexp_ch3.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch3.ads?ref=82c80734715c801643075ab68c5c9a5e00da1b03", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---           Copyright (C) 1992-2004 Free Software Foundation, Inc.         --\n+--           Copyright (C) 1992-2005 Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -28,6 +28,7 @@\n \n with Types;  use Types;\n with Elists; use Elists;\n+with Uintp;  use Uintp;\n \n package Exp_Ch3 is\n \n@@ -96,10 +97,16 @@ package Exp_Ch3 is\n \n    function Get_Simple_Init_Val\n      (T    : Entity_Id;\n-      Loc  : Source_Ptr) return Node_Id;\n+      Loc  : Source_Ptr;\n+      Size : Uint := No_Uint) return Node_Id;\n    --  For a type which Needs_Simple_Initialization (see above), prepares\n    --  the tree for an expression representing the required initial value.\n    --  Loc is the source location used in constructing this tree which is\n-   --  returned as the result of the call.\n+   --  returned as the result of the call. The Size parameter indicates the\n+   --  target size of the object if it is known (indicated by a value that\n+   --  is not No_Uint and is greater than zero). If Size is not given (Size\n+   --  set to No_Uint, or non-positive), then the Esize of T is used as an\n+   --  estimate of the Size. The object size is needed to prepare a known\n+   --  invalid value for use by Normalize_Scalars.\n \n end Exp_Ch3;"}, {"sha": "6305f5dd74616f4c432ebd520ca22607939e00e7", "filename": "gcc/ada/exp_ch6.adb", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/82c80734715c801643075ab68c5c9a5e00da1b03/gcc%2Fada%2Fexp_ch6.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/82c80734715c801643075ab68c5c9a5e00da1b03/gcc%2Fada%2Fexp_ch6.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch6.adb?ref=82c80734715c801643075ab68c5c9a5e00da1b03", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1992-2004, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2005, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -1733,7 +1733,7 @@ package body Exp_Ch6 is\n         and then Present (Controlling_Argument (N))\n         and then not Java_VM\n       then\n-         Expand_Dispatch_Call (N);\n+         Expand_Dispatching_Call (N);\n \n          --  The following return is worrisome. Is it really OK to\n          --  skip all remaining processing in this procedure ???"}, {"sha": "f0f7f0a0ad4df1d7a2ddc6d7ddb4979c5d3e8446", "filename": "gcc/ada/exp_dbug.adb", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/82c80734715c801643075ab68c5c9a5e00da1b03/gcc%2Fada%2Fexp_dbug.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/82c80734715c801643075ab68c5c9a5e00da1b03/gcc%2Fada%2Fexp_dbug.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_dbug.adb?ref=82c80734715c801643075ab68c5c9a5e00da1b03", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1996-2004 Free Software Foundation, Inc.          --\n+--          Copyright (C) 1996-2005 Free Software Foundation, Inc.          --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -793,8 +793,7 @@ package body Exp_Dbug is\n          elsif Nkind (Choice) = N_Character_Literal\n            and then No (Entity (Choice))\n          then\n-            Add_Uint_To_Buffer\n-              (UI_From_Int (Int (Char_Literal_Value (Choice))));\n+            Add_Uint_To_Buffer (Char_Literal_Value (Choice));\n \n          else\n             declare"}, {"sha": "9cc9fb0098e26512ab59aa9ab83dd600f4f02e66", "filename": "gcc/ada/exp_disp.adb", "status": "modified", "additions": 110, "deletions": 36, "changes": 146, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/82c80734715c801643075ab68c5c9a5e00da1b03/gcc%2Fada%2Fexp_disp.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/82c80734715c801643075ab68c5c9a5e00da1b03/gcc%2Fada%2Fexp_disp.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_disp.adb?ref=82c80734715c801643075ab68c5c9a5e00da1b03", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1992-2004 Free Software Foundation, Inc.          --\n+--          Copyright (C) 1992-2005 Free Software Foundation, Inc.          --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -142,41 +142,44 @@ package body Exp_Disp is\n    --  Check if the type has a private view or if the public view appears\n    --  in the visible part of a package spec.\n \n-   --------------------------\n-   -- Expand_Dispatch_Call --\n-   --------------------------\n+   -----------------------------\n+   -- Expand_Dispatching_Call --\n+   -----------------------------\n \n-   procedure Expand_Dispatch_Call (Call_Node : Node_Id) is\n+   procedure Expand_Dispatching_Call (Call_Node : Node_Id) is\n       Loc      : constant Source_Ptr := Sloc (Call_Node);\n       Call_Typ : constant Entity_Id  := Etype (Call_Node);\n \n       Ctrl_Arg   : constant Node_Id := Controlling_Argument (Call_Node);\n       Param_List : constant List_Id := Parameter_Associations (Call_Node);\n       Subp       : Entity_Id        := Entity (Name (Call_Node));\n \n-      CW_Typ        : Entity_Id;\n-      New_Call      : Node_Id;\n-      New_Call_Name : Node_Id;\n-      New_Params    : List_Id := No_List;\n-      Param         : Node_Id;\n-      Res_Typ       : Entity_Id;\n-      Subp_Ptr_Typ  : Entity_Id;\n-      Subp_Typ      : Entity_Id;\n-      Typ           : Entity_Id;\n-      Eq_Prim_Op    : Entity_Id := Empty;\n+      CW_Typ          : Entity_Id;\n+      New_Call        : Node_Id;\n+      New_Call_Name   : Node_Id;\n+      New_Params      : List_Id := No_List;\n+      Param           : Node_Id;\n+      Res_Typ         : Entity_Id;\n+      Subp_Ptr_Typ    : Entity_Id;\n+      Subp_Typ        : Entity_Id;\n+      Typ             : Entity_Id;\n+      Eq_Prim_Op      : Entity_Id := Empty;\n+      Controlling_Tag : Node_Id;\n \n       function New_Value (From : Node_Id) return Node_Id;\n       --  From is the original Expression. New_Value is equivalent to a call\n       --  to Duplicate_Subexpr with an explicit dereference when From is an\n-      --  access parameter\n+      --  access parameter.\n+\n+      function Controlling_Type (Subp : Entity_Id) return Entity_Id;\n+      --  Returns the tagged type for which Subp is a primitive subprogram\n \n       ---------------\n       -- New_Value --\n       ---------------\n \n       function New_Value (From : Node_Id) return Node_Id is\n          Res : constant Node_Id := Duplicate_Subexpr (From);\n-\n       begin\n          if Is_Access_Type (Etype (From)) then\n             return Make_Explicit_Dereference (Sloc (From), Res);\n@@ -185,10 +188,45 @@ package body Exp_Disp is\n          end if;\n       end New_Value;\n \n-   --  Start of processing for Expand_Dispatch_Call\n+      ----------------------\n+      -- Controlling_Type --\n+      ----------------------\n+\n+      function Controlling_Type (Subp : Entity_Id) return Entity_Id is\n+      begin\n+         if Ekind (Subp) = E_Function\n+           and then Has_Controlling_Result (Subp)\n+         then\n+            return Base_Type (Etype (Subp));\n+\n+         else\n+            declare\n+               Formal : Entity_Id := First_Formal (Subp);\n+\n+            begin\n+               while Present (Formal) loop\n+                  if Is_Controlling_Formal (Formal) then\n+                     if Is_Access_Type (Etype (Formal)) then\n+                        return Base_Type (Designated_Type (Etype (Formal)));\n+                     else\n+                        return Base_Type (Etype (Formal));\n+                     end if;\n+                  end if;\n+\n+                  Next_Formal (Formal);\n+               end loop;\n+            end;\n+         end if;\n+\n+         --  Controlling type not found (should never happen)\n+\n+         return Empty;\n+      end Controlling_Type;\n+\n+   --  Start of processing for Expand_Dispatching_Call\n \n    begin\n-      --  If this is an inherited operation that was overriden, the body\n+      --  If this is an inherited operation that was overridden, the body\n       --  that is being called is its alias.\n \n       if Present (Alias (Subp))\n@@ -198,17 +236,31 @@ package body Exp_Disp is\n          Subp := Alias (Subp);\n       end if;\n \n-      --  Expand_Dispatch is called directly from the semantics, so we need\n-      --  a check to see whether expansion is active before proceeding\n+      --  Expand_Dispatching_Call is called directly from the semantics,\n+      --  so we need a check to see whether expansion is active before\n+      --  proceeding.\n \n       if not Expander_Active then\n          return;\n       end if;\n \n-      --  Definition of the ClassWide Type and the Tagged type\n+      --  Definition of the class-wide type and the tagged type\n+\n+      --  If the controlling argument is itself a tag rather than a tagged\n+      --  object, then use the class-wide type associated with the subprogram's\n+      --  controlling type. This case can occur when a call to an inherited\n+      --  primitive has an actual that originated from a default parameter\n+      --  given by a tag-indeterminate call and when there is no other\n+      --  controlling argument providing the tag (AI-239 requires dispatching).\n+      --  This capability of dispatching directly by tag is also needed by the\n+      --  implementation of AI-260 (for the generic dispatching constructors).\n \n-      if Is_Access_Type (Etype (Ctrl_Arg)) then\n+      if Etype (Ctrl_Arg) = RTE (RE_Tag) then\n+         CW_Typ := Class_Wide_Type (Controlling_Type (Subp));\n+\n+      elsif Is_Access_Type (Etype (Ctrl_Arg)) then\n          CW_Typ := Designated_Type (Etype (Ctrl_Arg));\n+\n       else\n          CW_Typ := Etype (Ctrl_Arg);\n       end if;\n@@ -291,7 +343,7 @@ package body Exp_Disp is\n             elsif No (Find_Controlling_Arg (Param)) then\n                Append_To (New_Params, Relocate_Node (Param));\n \n-            --  No tag check for function dispatching on result it the\n+            --  No tag check for function dispatching on result if the\n             --  Tag given by the context is this one\n \n             elsif Find_Controlling_Arg (Param) = Ctrl_Arg then\n@@ -362,7 +414,7 @@ package body Exp_Disp is\n       if  Etype (Subp) = Typ then\n          Res_Typ := CW_Typ;\n       else\n-         Res_Typ :=  Etype (Subp);\n+         Res_Typ := Etype (Subp);\n       end if;\n \n       Subp_Typ := Create_Itype (E_Subprogram_Type, Call_Node);\n@@ -389,9 +441,9 @@ package body Exp_Disp is\n                Set_Scope (New_Formal, Subp_Typ);\n \n                --  Change all the controlling argument types to be class-wide\n-               --  to avoid a recursion in dispatching\n+               --  to avoid a recursion in dispatching.\n \n-               if Is_Controlling_Actual (Param) then\n+               if Is_Controlling_Formal (New_Formal) then\n                   Set_Etype (New_Formal, Etype (Param));\n                end if;\n \n@@ -443,6 +495,20 @@ package body Exp_Disp is\n       Set_Etype (Subp_Ptr_Typ, Subp_Ptr_Typ);\n       Set_Directly_Designated_Type (Subp_Ptr_Typ, Subp_Typ);\n \n+      --  If the controlling argument is a value of type Ada.Tag then\n+      --  use it directly.  Otherwise, the tag must be extracted from\n+      --  the controlling object.\n+\n+      if Etype (Ctrl_Arg) = RTE (RE_Tag) then\n+         Controlling_Tag := Duplicate_Subexpr (Ctrl_Arg);\n+\n+      else\n+         Controlling_Tag :=\n+           Make_Selected_Component (Loc,\n+             Prefix => Duplicate_Subexpr_Move_Checks (Ctrl_Arg),\n+             Selector_Name => New_Reference_To (DTC_Entity (Subp), Loc));\n+      end if;\n+\n       --  Generate:\n       --   Subp_Ptr_Typ!(Get_Prim_Op_Address (Ctrl._Tag, pos));\n \n@@ -454,9 +520,7 @@ package body Exp_Disp is\n \n             --  Vptr\n \n-              Make_Selected_Component (Loc,\n-                Prefix => Duplicate_Subexpr_Move_Checks (Ctrl_Arg),\n-                Selector_Name => New_Reference_To (DTC_Entity (Subp), Loc)),\n+              Controlling_Tag,\n \n             --  Position\n \n@@ -468,11 +532,10 @@ package body Exp_Disp is\n              Name => New_Call_Name,\n              Parameter_Associations => New_Params);\n \n-         --  if this is a dispatching \"=\", we must first compare the tags so\n+         --  If this is a dispatching \"=\", we must first compare the tags so\n          --  we generate: x.tag = y.tag and then x = y\n \n          if Subp = Eq_Prim_Op then\n-\n             Param := First_Actual (Call_Node);\n             New_Call :=\n               Make_And_Then (Loc,\n@@ -504,7 +567,7 @@ package body Exp_Disp is\n \n       Rewrite (Call_Node, New_Call);\n       Analyze_And_Resolve (Call_Node, Call_Typ);\n-   end Expand_Dispatch_Call;\n+   end Expand_Dispatching_Call;\n \n    -------------\n    -- Fill_DT --\n@@ -651,16 +714,27 @@ package body Exp_Disp is\n       --  or\n       --    DT_Ptr : Vtable_Ptr := Vtable_Ptr!(DT'Address);   CPP case\n \n+      --  According to the C++ ABI, the base of the vtable is located\n+      --  after the following prologue: Offset_To_Top, Typeinfo_Ptr.\n+      --  Hence, move the pointer to the base of the vtable down, after\n+      --  this prologue.\n+\n       Append_To (Result,\n         Make_Object_Declaration (Loc,\n           Defining_Identifier => DT_Ptr,\n           Constant_Present    => True,\n           Object_Definition   => New_Reference_To (Generalized_Tag, Loc),\n           Expression          =>\n             Unchecked_Convert_To (Generalized_Tag,\n-              Make_Attribute_Reference (Loc,\n-                Prefix         => New_Reference_To (DT, Loc),\n-                Attribute_Name => Name_Address))));\n+              Make_Op_Add (Loc,\n+                Left_Opnd =>\n+                  Unchecked_Convert_To (RTE (RE_Storage_Offset),\n+                    Make_Attribute_Reference (Loc,\n+                      Prefix         => New_Reference_To (DT, Loc),\n+                      Attribute_Name => Name_Address)),\n+                Right_Opnd =>\n+                  Make_DT_Access_Action (Typ,\n+                    DT_Prologue_Size, No_List)))));\n \n       --  Generate code to define the boolean that controls registration, in\n       --  order to avoid multiple registrations for tagged types defined in"}, {"sha": "34bcffc5c592a94e039748d2670c10aacda5e9b3", "filename": "gcc/ada/exp_disp.ads", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/82c80734715c801643075ab68c5c9a5e00da1b03/gcc%2Fada%2Fexp_disp.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/82c80734715c801643075ab68c5c9a5e00da1b03/gcc%2Fada%2Fexp_disp.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_disp.ads?ref=82c80734715c801643075ab68c5c9a5e00da1b03", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---          Copyright (C) 1992-2001 Free Software Foundation, Inc.          --\n+--          Copyright (C) 1992-2005 Free Software Foundation, Inc.          --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -76,7 +76,7 @@ package Exp_Disp is\n    --  Class case check that no pragma CPP_Virtual is missing  and that the\n    --  DT_Position are coherent\n \n-   procedure Expand_Dispatch_Call (Call_Node : Node_Id);\n+   procedure Expand_Dispatching_Call (Call_Node : Node_Id);\n    --  Expand the call to the operation through the dispatch table and perform\n    --  the required tag checks when appropriate. For CPP types the call is\n    --  done through the Vtable (tag checks are not relevant)"}, {"sha": "4c756b13317fcb2690aecd76484827cc9ae2d9fb", "filename": "gcc/ada/exp_dist.adb", "status": "modified", "additions": 173, "deletions": 21, "changes": 194, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/82c80734715c801643075ab68c5c9a5e00da1b03/gcc%2Fada%2Fexp_dist.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/82c80734715c801643075ab68c5c9a5e00da1b03/gcc%2Fada%2Fexp_dist.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_dist.adb?ref=82c80734715c801643075ab68c5c9a5e00da1b03", "patch": "@@ -358,7 +358,7 @@ package body Exp_Dist is\n    --  Mapping between a RCI subprogram and the corresponding calling stubs\n \n    procedure Add_Stub_Type\n-     (Designated_Type    : Entity_Id;\n+     (Designated_Type   : Entity_Id;\n       RACW_Type         : Entity_Id;\n       Decls             : List_Id;\n       Stub_Type         : out Entity_Id;\n@@ -551,10 +551,18 @@ package body Exp_Dist is\n    --  class-wide type before doing the real call using any of the RACW type\n    --  pointing on the designated type.\n \n+   procedure Specific_Add_Obj_RPC_Receiver_Completion\n+     (Loc           : Source_Ptr;\n+      Decls         : List_Id;\n+      RPC_Receiver  : Entity_Id;\n+      Stub_Elements : Stub_Structure);\n+   --  Add the necessary code to Decls after the completion of generation\n+   --  of the RACW RPC receiver described by Stub_Elements.\n+\n    procedure Specific_Add_Receiving_Stubs_To_Declarations\n      (Pkg_Spec : Node_Id;\n       Decls    : List_Id);\n-   --  Add receiving stubs to the declarative part\n+   --  Add receiving stubs to the declarative part of an RCI unit\n \n    package GARLIC_Support is\n \n@@ -611,6 +619,12 @@ package body Exp_Dist is\n          RACW_Type                : Entity_Id := Empty;\n          Parent_Primitive         : Entity_Id := Empty) return Node_Id;\n \n+      procedure Add_Obj_RPC_Receiver_Completion\n+        (Loc           : Source_Ptr;\n+         Decls         : List_Id;\n+         RPC_Receiver  : Entity_Id;\n+         Stub_Elements : Stub_Structure);\n+\n       procedure Add_Receiving_Stubs_To_Declarations\n         (Pkg_Spec : Node_Id;\n          Decls    : List_Id);\n@@ -680,6 +694,12 @@ package body Exp_Dist is\n          RACW_Type                : Entity_Id := Empty;\n          Parent_Primitive         : Entity_Id := Empty) return Node_Id;\n \n+      procedure Add_Obj_RPC_Receiver_Completion\n+        (Loc           : Source_Ptr;\n+         Decls         : List_Id;\n+         RPC_Receiver  : Entity_Id;\n+         Stub_Elements : Stub_Structure);\n+\n       procedure Add_Receiving_Stubs_To_Declarations\n         (Pkg_Spec : Node_Id;\n          Decls    : List_Id);\n@@ -1108,6 +1128,7 @@ package body Exp_Dist is\n       RPC_Receiver                   : Entity_Id;\n       RPC_Receiver_Statements        : List_Id;\n       RPC_Receiver_Case_Alternatives : constant List_Id := New_List;\n+      RPC_Receiver_Elsif_Parts       : List_Id;\n       RPC_Receiver_Request           : Entity_Id;\n       RPC_Receiver_Subp_Id           : Entity_Id;\n       RPC_Receiver_Subp_Index        : Entity_Id;\n@@ -1145,6 +1166,20 @@ package body Exp_Dist is\n            Subp_Index   => RPC_Receiver_Subp_Index,\n            Stmts        => RPC_Receiver_Statements,\n            Decl         => RPC_Receiver_Decl);\n+\n+         if Get_PCS_Name = Name_PolyORB_DSA then\n+\n+            --  For the case of PolyORB, we need to map a textual operation\n+            --  name into a primitive index. Currently we do so using a\n+            --  simple sequence of string comparisons.\n+\n+            RPC_Receiver_Elsif_Parts := New_List;\n+            Append_To (RPC_Receiver_Statements,\n+              Make_Implicit_If_Statement (Designated_Type,\n+                Condition       => New_Occurrence_Of (Standard_False, Loc),\n+                Then_Statements => New_List,\n+                Elsif_Parts     => RPC_Receiver_Elsif_Parts));\n+         end if;\n       end if;\n \n       --  Build callers, receivers for every primitive operations and a RPC\n@@ -1238,6 +1273,26 @@ package body Exp_Dist is\n \n                   --  Add a case alternative to the receiver\n \n+                  if Get_PCS_Name = Name_PolyORB_DSA then\n+                     Append_To (RPC_Receiver_Elsif_Parts,\n+                       Make_Elsif_Part (Loc,\n+                         Condition =>\n+                           Make_Function_Call (Loc,\n+                             Name =>\n+                               New_Occurrence_Of (\n+                                 RTE (RE_Caseless_String_Eq), Loc),\n+                             Parameter_Associations => New_List (\n+                               New_Occurrence_Of (RPC_Receiver_Subp_Id, Loc),\n+                               Make_String_Literal (Loc, Subp_Str))),\n+                         Then_Statements => New_List (\n+                           Make_Assignment_Statement (Loc,\n+                             Name => New_Occurrence_Of (\n+                                       RPC_Receiver_Subp_Index, Loc),\n+                             Expression =>\n+                               Make_Integer_Literal (Loc,\n+                                  Current_Primitive_Number)))));\n+                  end if;\n+\n                   Append_To (RPC_Receiver_Case_Alternatives,\n                     Make_Case_Statement_Alternative (Loc,\n                       Discrete_Choices => New_List (\n@@ -1275,21 +1330,8 @@ package body Exp_Dist is\n              Alternatives => RPC_Receiver_Case_Alternatives));\n \n          Append_To (Decls, RPC_Receiver_Decl);\n-\n-         --  The RPC receiver body should not be the completion of the\n-         --  declaration recorded in the stub structure, because then the\n-         --  occurrences of the formal parameters within the body should\n-         --  refer to the entities from the declaration, not from the\n-         --  completion, to which we do not have easy access. Instead, the\n-         --  RPC receiver body acts as its own declaration, and the RPC\n-         --  receiver declaration is completed by a renaming-as-body.\n-\n-         Append_To (Decls,\n-           Make_Subprogram_Renaming_Declaration (Loc,\n-             Specification =>\n-               Copy_Specification (Loc,\n-                 Specification (Stub_Elements.RPC_Receiver_Decl)),\n-             Name          => New_Occurrence_Of (RPC_Receiver, Loc)));\n+         Specific_Add_Obj_RPC_Receiver_Completion (Loc,\n+           Decls, RPC_Receiver, Stub_Elements);\n       end if;\n \n       --  Do not analyze RPC receiver at this stage since it will otherwise\n@@ -2170,7 +2212,12 @@ package body Exp_Dist is\n       E   : Entity_Id) return Node_Id\n    is\n    begin\n-      return Make_Integer_Literal (Loc, Get_Subprogram_Id (E));\n+      case Get_PCS_Name is\n+         when Name_PolyORB_DSA =>\n+            return Make_String_Literal  (Loc, Get_Subprogram_Id (E));\n+         when others =>\n+            return Make_Integer_Literal (Loc, Get_Subprogram_Id (E));\n+      end case;\n    end Build_Subprogram_Id;\n \n    ------------------------\n@@ -2442,7 +2489,12 @@ package body Exp_Dist is\n    begin\n       if Nkind (Unit_Node) = N_Package_Declaration then\n          Spec  := Specification (Unit_Node);\n-         Decls := Visible_Declarations (Spec);\n+         Decls := Private_Declarations (Spec);\n+\n+         if No (Decls) then\n+            Decls := Visible_Declarations (Spec);\n+         end if;\n+\n          New_Scope (Scope_Of_Spec (Spec));\n          Specific_Add_Receiving_Stubs_To_Declarations (Spec, Decls);\n \n@@ -2497,6 +2549,32 @@ package body Exp_Dist is\n       procedure Add_RAS_Access_TSS (N : Node_Id);\n       --  Add a subprogram body for RAS Access TSS\n \n+      -------------------------------------\n+      -- Add_Obj_RPC_Receiver_Completion --\n+      -------------------------------------\n+\n+      procedure Add_Obj_RPC_Receiver_Completion\n+        (Loc           : Source_Ptr;\n+         Decls         : List_Id;\n+         RPC_Receiver  : Entity_Id;\n+         Stub_Elements : Stub_Structure) is\n+      begin\n+         --  The RPC receiver body should not be the completion of the\n+         --  declaration recorded in the stub structure, because then the\n+         --  occurrences of the formal parameters within the body should\n+         --  refer to the entities from the declaration, not from the\n+         --  completion, to which we do not have easy access. Instead, the\n+         --  RPC receiver body acts as its own declaration, and the RPC\n+         --  receiver declaration is completed by a renaming-as-body.\n+\n+         Append_To (Decls,\n+           Make_Subprogram_Renaming_Declaration (Loc,\n+             Specification =>\n+               Copy_Specification (Loc,\n+                 Specification (Stub_Elements.RPC_Receiver_Decl)),\n+             Name          => New_Occurrence_Of (RPC_Receiver, Loc)));\n+      end Add_Obj_RPC_Receiver_Completion;\n+\n       -----------------------\n       -- Add_RACW_Features --\n       -----------------------\n@@ -5051,6 +5129,52 @@ package body Exp_Dist is\n       procedure Add_RAS_Access_TSS (N : Node_Id);\n       --  Add a subprogram body for RAS Access TSS\n \n+      -------------------------------------\n+      -- Add_Obj_RPC_Receiver_Completion --\n+      -------------------------------------\n+\n+      procedure Add_Obj_RPC_Receiver_Completion\n+        (Loc           : Source_Ptr;\n+         Decls         : List_Id;\n+         RPC_Receiver  : Entity_Id;\n+         Stub_Elements : Stub_Structure)\n+      is\n+         Desig : constant Entity_Id :=\n+           Etype (Designated_Type (Stub_Elements.RACW_Type));\n+      begin\n+         Append_To (Decls,\n+           Make_Procedure_Call_Statement (Loc,\n+              Name =>\n+                New_Occurrence_Of (\n+                  RTE (RE_Register_Obj_Receiving_Stub), Loc),\n+\n+                Parameter_Associations => New_List (\n+\n+               --  Name\n+\n+                Make_String_Literal (Loc,\n+                  Full_Qualified_Name (Desig)),\n+\n+               --  Handler\n+\n+                Make_Attribute_Reference (Loc,\n+                  Prefix =>\n+                    New_Occurrence_Of (\n+                      Defining_Unit_Name (Parent (RPC_Receiver)), Loc),\n+                  Attribute_Name =>\n+                    Name_Access),\n+\n+               --  Receiver\n+\n+                Make_Attribute_Reference (Loc,\n+                  Prefix =>\n+                    New_Occurrence_Of (\n+                      Defining_Identifier (\n+                        Stub_Elements.RPC_Receiver_Decl), Loc),\n+                  Attribute_Name =>\n+                    Name_Access))));\n+      end Add_Obj_RPC_Receiver_Completion;\n+\n       -----------------------\n       -- Add_RACW_Features --\n       -----------------------\n@@ -8137,6 +8261,9 @@ package body Exp_Dist is\n             elsif U_Type = Standard_Wide_Character then\n                Lib_RE := RE_FA_WC;\n \n+            elsif U_Type = Standard_Wide_Wide_Character then\n+               Lib_RE := RE_FA_WWC;\n+\n             --  Floating point types\n \n             elsif U_Type = Standard_Short_Float then\n@@ -8915,6 +9042,9 @@ package body Exp_Dist is\n             elsif U_Type = Standard_Wide_Character then\n                Lib_RE := RE_TA_WC;\n \n+            elsif U_Type = Standard_Wide_Wide_Character then\n+               Lib_RE := RE_TA_WWC;\n+\n             --  Floating point types\n \n             elsif U_Type = Standard_Short_Float then\n@@ -9619,6 +9749,9 @@ package body Exp_Dist is\n                elsif U_Type = Standard_Wide_Character then\n                   Lib_RE := RE_TC_WC;\n \n+               elsif U_Type = Standard_Wide_Wide_Character then\n+                  Lib_RE := RE_TC_WWC;\n+\n                --  Floating point types\n \n                elsif U_Type = Standard_Short_Float then\n@@ -10664,6 +10797,26 @@ package body Exp_Dist is\n       Set_TSS (Typ, Snam);\n    end Set_Renaming_TSS;\n \n+   ----------------------------------------------\n+   -- Specific_Add_Obj_RPC_Receiver_Completion --\n+   ----------------------------------------------\n+\n+   procedure Specific_Add_Obj_RPC_Receiver_Completion\n+     (Loc           : Source_Ptr;\n+      Decls         : List_Id;\n+      RPC_Receiver  : Entity_Id;\n+      Stub_Elements : Stub_Structure) is\n+   begin\n+      case Get_PCS_Name is\n+         when Name_PolyORB_DSA =>\n+            PolyORB_Support.Add_Obj_RPC_Receiver_Completion (Loc,\n+              Decls, RPC_Receiver, Stub_Elements);\n+         when others =>\n+            GARLIC_Support.Add_Obj_RPC_Receiver_Completion (Loc,\n+              Decls, RPC_Receiver, Stub_Elements);\n+      end case;\n+   end Specific_Add_Obj_RPC_Receiver_Completion;\n+\n    --------------------------------\n    -- Specific_Add_RACW_Features --\n    --------------------------------\n@@ -10674,8 +10827,7 @@ package body Exp_Dist is\n       Stub_Type         : Entity_Id;\n       Stub_Type_Access  : Entity_Id;\n       RPC_Receiver_Decl : Node_Id;\n-      Declarations      : List_Id)\n-   is\n+      Declarations      : List_Id) is\n    begin\n       case Get_PCS_Name is\n          when Name_PolyORB_DSA =>"}, {"sha": "65bcc3d382159b3884ea67d0699020e7a24e028b", "filename": "gcc/ada/exp_imgv.adb", "status": "modified", "additions": 132, "deletions": 41, "changes": 173, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/82c80734715c801643075ab68c5c9a5e00da1b03/gcc%2Fada%2Fexp_imgv.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/82c80734715c801643075ab68c5c9a5e00da1b03/gcc%2Fada%2Fexp_imgv.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_imgv.adb?ref=82c80734715c801643075ab68c5c9a5e00da1b03", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 2001-2004 Free Software Foundation, Inc.          --\n+--          Copyright (C) 2001-2005 Free Software Foundation, Inc.          --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -194,6 +194,11 @@ package body Exp_Imgv is\n    --      tv = Wide_Character (Expr)\n    --      pm = Wide_Character_Encoding_Method\n \n+   --    For types whose root type is Wide_Wide_Character\n+   --      xx = Wide_Wide_haracter\n+   --      tv = Wide_Wide_Character (Expr)\n+   --      pm = Wide_Character_Encoding_Method\n+\n    --    For floating-point types\n    --      xx = Floating_Point\n    --      tv = Long_Long_Float (Expr)\n@@ -254,6 +259,10 @@ package body Exp_Imgv is\n          Imid := RE_Image_Wide_Character;\n          Tent := Rtyp;\n \n+      elsif Rtyp = Standard_Wide_Wide_Character then\n+         Imid := RE_Image_Wide_Wide_Character;\n+         Tent := Rtyp;\n+\n       elsif Is_Signed_Integer_Type (Rtyp) then\n          if Esize (Rtyp) <= Esize (Standard_Integer) then\n             Imid := RE_Image_Integer;\n@@ -382,9 +391,11 @@ package body Exp_Imgv is\n              Prefix         => New_Reference_To (Ptyp, Loc),\n              Attribute_Name => Name_Aft));\n \n-      --  For wide character, append encoding method\n+      --  For wide [wide] character, append encoding method\n \n-      elsif Rtyp = Standard_Wide_Character then\n+      elsif Rtyp = Standard_Wide_Character\n+        or else Rtyp = Standard_Wide_Wide_Character\n+      then\n          Append_To (Arglist,\n            Make_Integer_Literal (Loc,\n              Intval => Int (Wide_Character_Encoding_Method)));\n@@ -445,6 +456,10 @@ package body Exp_Imgv is\n \n    --    Value_Wide_Character (X, Wide_Character_Encoding_Method)\n \n+   --  For types derived from Wide_Wide_Character, typ'Value (X) expands into\n+\n+   --    Value_Wide_Wide_Character (X, Wide_Character_Encoding_Method)\n+\n    --  For decimal types with size <= Integer'Size, typ'Value (X)\n    --  expands into\n \n@@ -455,7 +470,7 @@ package body Exp_Imgv is\n    --    btyp?(Value_Long_Long_Decimal (X, typ'Scale))\n \n    --  For enumeration types other than those derived from types Boolean,\n-   --  Character, and Wide_Character in Standard, typ'Value (X) expands to:\n+   --  Character, Wide_[Wide_]Character in Standard, typ'Value (X) expands to:\n \n    --    Enum'Val (Value_Enumeration_NN (typS, typI'Address, Num, X))\n \n@@ -493,6 +508,12 @@ package body Exp_Imgv is\n            Make_Integer_Literal (Loc,\n              Intval => Int (Wide_Character_Encoding_Method)));\n \n+      elsif Rtyp = Standard_Wide_Wide_Character then\n+         Vid := RE_Value_Wide_Wide_Character;\n+         Append_To (Args,\n+           Make_Integer_Literal (Loc,\n+             Intval => Int (Wide_Character_Encoding_Method)));\n+\n       elsif     Rtyp = Base_Type (Standard_Short_Short_Integer)\n         or else Rtyp = Base_Type (Standard_Short_Integer)\n         or else Rtyp = Base_Type (Standard_Integer)\n@@ -624,20 +645,28 @@ package body Exp_Imgv is\n    -- Expand_Width_Attribute --\n    ----------------------------\n \n-   --  The processing here also handles the case of Wide_Width. With the\n+   --  The processing here also handles the case of Wide_[Wide_]Width. With the\n    --  exceptions noted, the processing is identical\n \n    --  For scalar types derived from Boolean, character and integer types\n    --  in package Standard. Note that the Width attribute is computed at\n    --  compile time for all cases except those involving non-static sub-\n-   --  types. For such subtypes, typ'Width and typ'Wide_Width expands into:\n+   --  types. For such subtypes, typ'[Wide_[Wide_]]Width expands into:\n \n    --    Result_Type (xx (yy (Ptyp'First), yy (Ptyp'Last)))\n \n    --  where\n \n    --    For types whose root type is Character\n-   --      xx = Width_Character (Wide_Width_Character for Wide_Width case)\n+   --      xx = Width_Character\n+   --      yy = Character\n+\n+   --    For types whose root type is Wide_Character\n+   --      xx = Wide_Width_Character\n+   --      yy = Character\n+\n+   --    For types whose root type is Wide_Wide_Character\n+   --      xx = Wide_Wide_Width_Character\n    --      yy = Character\n \n    --    For types whose root type is Boolean\n@@ -664,8 +693,37 @@ package body Exp_Imgv is\n    --    Result_Type (Wide_Width_Wide_Character (\n    --      Wide_Character (typ'First),\n    --      Wide_Character (typ'Last));\n+   --      Wide_Character_Encoding_Method);\n+\n+   --  and typ'Wide_Wide_Width expands into\n+\n+   --    Result_Type (Wide_Wide_Width_Wide_Character (\n+   --      Wide_Character (typ'First),\n+   --      Wide_Character (typ'Last));\n+   --      Wide_Character_Encoding_Method);\n+\n+   --  For types derived from Wide_Wide_Character, typ'Width expands into\n+\n+   --    Result_Type (Width_Wide_Wide_Character (\n+   --      Wide_Wide_Character (typ'First),\n+   --      Wide_Wide_Character (typ'Last),\n+   --      Wide_Character_Encoding_Method);\n+\n+   --  and typ'Wide_Width expands into:\n+\n+   --    Result_Type (Wide_Width_Wide_Wide_Character (\n+   --      Wide_Wide_Character (typ'First),\n+   --      Wide_Wide_Character (typ'Last));\n+   --      Wide_Character_Encoding_Method);\n \n-   --  For real types, typ'Width and typ'Wide_Width expand into\n+   --  and typ'Wide_Wide_Width expands into\n+\n+   --    Result_Type (Wide_Wide_Width_Wide_Wide_Char (\n+   --      Wide_Wide_Character (typ'First),\n+   --      Wide_Wide_Character (typ'Last));\n+   --      Wide_Character_Encoding_Method);\n+\n+   --  For real types, typ'Width and typ'Wide_[Wide_]Width expand into\n \n    --    if Ptyp'First > Ptyp'Last then 0 else btyp'Width end if\n \n@@ -690,11 +748,20 @@ package body Exp_Imgv is\n    --                   typ'Pos (Typ'Last))\n    --                   Wide_Character_Encoding_Method);\n \n+   --  and typ'Wide_Wide_Width expands into:\n+\n+   --    Result_Type (Wide_Wide_Width_Enumeration_NN\n+   --                  (typS,\n+   --                   typI,\n+   --                   typ'Pos (typ'First),\n+   --                   typ'Pos (Typ'Last))\n+   --                   Wide_Character_Encoding_Method);\n+\n    --  where typS and typI are the enumeration image strings and\n    --  indexes table, as described in Build_Enumeration_Image_Tables.\n    --  NN is 8/16/32 for depending on the element type for typI.\n \n-   procedure Expand_Width_Attribute (N : Node_Id; Wide : Boolean) is\n+   procedure Expand_Width_Attribute (N : Node_Id; Attr : Atype := Normal) is\n       Loc     : constant Source_Ptr := Sloc (N);\n       Typ     : constant Entity_Id  := Etype (N);\n       Pref    : constant Node_Id    := Prefix (N);\n@@ -715,22 +782,33 @@ package body Exp_Imgv is\n       --  Types derived from Standard.Character\n \n       elsif Rtyp = Standard_Character then\n-         if not Wide then\n-            XX := RE_Width_Character;\n-         else\n-            XX := RE_Wide_Width_Character;\n-         end if;\n+         case Attr is\n+            when Normal    => XX := RE_Width_Character;\n+            when Wide      => XX := RE_Wide_Width_Character;\n+            when Wide_Wide => XX := RE_Wide_Wide_Width_Character;\n+         end case;\n \n          YY := Rtyp;\n \n       --  Types derived from Standard.Wide_Character\n \n       elsif Rtyp = Standard_Wide_Character then\n-         if not Wide then\n-            XX := RE_Width_Wide_Character;\n-         else\n-            XX := RE_Wide_Width_Wide_Character;\n-         end if;\n+         case Attr is\n+            when Normal    => XX := RE_Width_Wide_Character;\n+            when Wide      => XX := RE_Wide_Width_Wide_Character;\n+            when Wide_Wide => XX := RE_Wide_Wide_Width_Wide_Character;\n+         end case;\n+\n+         YY := Rtyp;\n+\n+      --  Types derived from Standard.Wide_Wide_Character\n+\n+      elsif Rtyp = Standard_Wide_Wide_Character then\n+         case Attr is\n+            when Normal    => XX := RE_Width_Wide_Wide_Character;\n+            when Wide      => XX := RE_Wide_Width_Wide_Wide_Character;\n+            when Wide_Wide => XX := RE_Wide_Wide_Width_Wide_Wide_Char;\n+         end case;\n \n          YY := Rtyp;\n \n@@ -781,24 +859,34 @@ package body Exp_Imgv is\n \n          Ttyp := Component_Type (Etype (Lit_Indexes (Rtyp)));\n \n-         if not Wide then\n-            if Ttyp = Standard_Integer_8 then\n-               XX := RE_Width_Enumeration_8;\n-            elsif Ttyp = Standard_Integer_16  then\n-               XX := RE_Width_Enumeration_16;\n-            else\n-               XX := RE_Width_Enumeration_32;\n-            end if;\n-\n-         else\n-            if Ttyp = Standard_Integer_8 then\n-               XX := RE_Wide_Width_Enumeration_8;\n-            elsif Ttyp = Standard_Integer_16  then\n-               XX := RE_Wide_Width_Enumeration_16;\n-            else\n-               XX := RE_Wide_Width_Enumeration_32;\n-            end if;\n-         end if;\n+         case Attr is\n+            when Normal =>\n+               if Ttyp = Standard_Integer_8 then\n+                  XX := RE_Width_Enumeration_8;\n+               elsif Ttyp = Standard_Integer_16  then\n+                  XX := RE_Width_Enumeration_16;\n+               else\n+                  XX := RE_Width_Enumeration_32;\n+               end if;\n+\n+            when Wide =>\n+               if Ttyp = Standard_Integer_8 then\n+                  XX := RE_Wide_Width_Enumeration_8;\n+               elsif Ttyp = Standard_Integer_16  then\n+                  XX := RE_Wide_Width_Enumeration_16;\n+               else\n+                  XX := RE_Wide_Width_Enumeration_32;\n+               end if;\n+\n+            when Wide_Wide =>\n+               if Ttyp = Standard_Integer_8 then\n+                  XX := RE_Wide_Wide_Width_Enumeration_8;\n+               elsif Ttyp = Standard_Integer_16  then\n+                  XX := RE_Wide_Wide_Width_Enumeration_16;\n+               else\n+                  XX := RE_Wide_Wide_Width_Enumeration_32;\n+               end if;\n+         end case;\n \n          Arglist :=\n            New_List (\n@@ -826,9 +914,9 @@ package body Exp_Imgv is\n                    Prefix => New_Reference_To (Ptyp, Loc),\n                    Attribute_Name => Name_Last))));\n \n-         --  For enumeration'Wide_Width, add encoding method parameter\n+         --  For enumeration'Wide_[Wide_]Width, add encoding method parameter\n \n-         if Wide then\n+         if Attr /= Normal then\n             Append_To (Arglist,\n               Make_Integer_Literal (Loc,\n                 Intval => Int (Wide_Character_Encoding_Method)));\n@@ -857,9 +945,12 @@ package body Exp_Imgv is\n             Prefix => New_Reference_To (Ptyp, Loc),\n             Attribute_Name => Name_Last)));\n \n-      --  For Wide_Character'Width, add encoding method parameter\n+      --  For Wide_[Wide_]Character'Width, add encoding method parameter\n \n-      if Rtyp = Standard_Wide_Character and then Wide then\n+      if (Rtyp = Standard_Wide_Character\n+           or else\n+          Rtyp = Standard_Wide_Wide_Character)\n+        and then Attr /= Normal then\n          Append_To (Arglist,\n            Make_Integer_Literal (Loc,\n              Intval => Int (Wide_Character_Encoding_Method)));"}, {"sha": "5f601dd7fe8d83553fe6034780b7e214070249f1", "filename": "gcc/ada/exp_imgv.ads", "status": "modified", "additions": 8, "deletions": 4, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/82c80734715c801643075ab68c5c9a5e00da1b03/gcc%2Fada%2Fexp_imgv.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/82c80734715c801643075ab68c5c9a5e00da1b03/gcc%2Fada%2Fexp_imgv.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_imgv.ads?ref=82c80734715c801643075ab68c5c9a5e00da1b03", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---            Copyright (C) 2000 Free Software Foundation, Inc.             --\n+--          Copyright (C) 2000-2005 Free Software Foundation, Inc.          --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -78,8 +78,12 @@ package Exp_Imgv is\n    --  This procedure is called from Exp_Attr to expand an occurrence\n    --  of the attribute Value.\n \n-   procedure Expand_Width_Attribute (N : Node_Id; Wide : Boolean);\n-   --  This procedure is called from Exp_Attr to expand an occurrence of\n-   --  the attributes Width (Wide = False) or Wide_Width (Wide = True).\n+   type Atype is (Normal, Wide, Wide_Wide);\n+   --  Type of attribute in call to Expand_Width_Attribute\n+\n+   procedure Expand_Width_Attribute (N : Node_Id; Attr : Atype := Normal);\n+   --  This procedure is called from Exp_Attr to expand an occurrence of the\n+   --  attributes Width (Attr = Normal), or Wide_Width (Attr Wide), or\n+   --  Wide_Wide_Width (Attr = Wide_Wide).\n \n end Exp_Imgv;"}, {"sha": "27ec905f1cdb832b9c2c6b59788db4be42572b5c", "filename": "gcc/ada/exp_prag.adb", "status": "modified", "additions": 7, "deletions": 4, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/82c80734715c801643075ab68c5c9a5e00da1b03/gcc%2Fada%2Fexp_prag.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/82c80734715c801643075ab68c5c9a5e00da1b03/gcc%2Fada%2Fexp_prag.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_prag.adb?ref=82c80734715c801643075ab68c5c9a5e00da1b03", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1992-2004 Free Software Foundation, Inc.          --\n+--          Copyright (C) 1992-2005 Free Software Foundation, Inc.          --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -517,19 +517,22 @@ package body Exp_Prag is\n                   Rewrite (Expression (Lang1),\n                     Make_Character_Literal (Loc,\n                       Chars => Name_uV,\n-                      Char_Literal_Value => Get_Char_Code ('V')));\n+                      Char_Literal_Value =>\n+                        UI_From_Int (Character'Pos ('V'))));\n                   Analyze (Expression (Lang1));\n \n                   Rewrite (Expression (Lang2),\n                     Make_Character_Literal (Loc,\n                       Chars => Name_uM,\n-                      Char_Literal_Value => Get_Char_Code ('M')));\n+                      Char_Literal_Value =>\n+                        UI_From_Int (Character'Pos ('M'))));\n                   Analyze (Expression (Lang2));\n \n                   Rewrite (Expression (Lang3),\n                     Make_Character_Literal (Loc,\n                       Chars => Name_uS,\n-                      Char_Literal_Value => Get_Char_Code ('S')));\n+                      Char_Literal_Value =>\n+                        UI_From_Int (Character'Pos ('S'))));\n                   Analyze (Expression (Lang3));\n \n                   if Exception_Code (Id) /= No_Uint then"}, {"sha": "a38ce46007ad71abd4489c07ba81ac98da1f5dae", "filename": "gcc/ada/exp_strm.adb", "status": "modified", "additions": 54, "deletions": 38, "changes": 92, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/82c80734715c801643075ab68c5c9a5e00da1b03/gcc%2Fada%2Fexp_strm.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/82c80734715c801643075ab68c5c9a5e00da1b03/gcc%2Fada%2Fexp_strm.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_strm.adb?ref=82c80734715c801643075ab68c5c9a5e00da1b03", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1992-2004, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2005, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -24,19 +24,20 @@\n --                                                                          --\n ------------------------------------------------------------------------------\n \n-with Atree;   use Atree;\n-with Einfo;   use Einfo;\n-with Namet;   use Namet;\n-with Nlists;  use Nlists;\n-with Nmake;   use Nmake;\n-with Rtsfind; use Rtsfind;\n-with Sinfo;   use Sinfo;\n-with Snames;  use Snames;\n-with Stand;   use Stand;\n-with Tbuild;  use Tbuild;\n-with Ttypes;  use Ttypes;\n-with Exp_Tss; use Exp_Tss;\n-with Uintp;   use Uintp;\n+with Atree;    use Atree;\n+with Einfo;    use Einfo;\n+with Namet;    use Namet;\n+with Nlists;   use Nlists;\n+with Nmake;    use Nmake;\n+with Rtsfind;  use Rtsfind;\n+with Sem_Util; use Sem_Util;\n+with Sinfo;    use Sinfo;\n+with Snames;   use Snames;\n+with Stand;    use Stand;\n+with Tbuild;   use Tbuild;\n+with Ttypes;   use Ttypes;\n+with Exp_Tss;  use Exp_Tss;\n+with Uintp;    use Uintp;\n \n package body Exp_Strm is\n \n@@ -446,13 +447,22 @@ package body Exp_Strm is\n       U_Type  : constant Entity_Id  := Underlying_Type (P_Type);\n       Rt_Type : constant Entity_Id  := Root_Type (U_Type);\n       FST     : constant Entity_Id  := First_Subtype (U_Type);\n-      P_Size  : constant Uint       := Esize (FST);\n-      Res     : Node_Id;\n       Strm    : constant Node_Id    := First (Expressions (N));\n       Targ    : constant Node_Id    := Next (Strm);\n+      P_Size  : Uint;\n+      Res     : Node_Id;\n       Lib_RE  : RE_Id;\n \n    begin\n+      --  Compute the size of the stream element. This is either the size of\n+      --  the first subtype or if given the size of the Stream_Size attribute.\n+\n+      if Is_Elementary_Type (FST) and then Has_Stream_Size_Clause (FST) then\n+         P_Size := Static_Integer (Expression (Stream_Size_Clause (FST)));\n+      else\n+         P_Size := Esize (FST);\n+      end if;\n+\n       --  Check first for Boolean and Character. These are enumeration types,\n       --  but we treat them specially, since they may require special handling\n       --  in the transfer protocol. However, this special handling only applies\n@@ -474,20 +484,24 @@ package body Exp_Strm is\n       then\n          Lib_RE := RE_I_WC;\n \n+      elsif Rt_Type = Standard_Wide_Wide_Character\n+        and then Has_Stream_Standard_Rep (U_Type)\n+      then\n+         Lib_RE := RE_I_WWC;\n+\n       --  Floating point types\n \n       elsif Is_Floating_Point_Type (U_Type) then\n-\n-         if Rt_Type = Standard_Short_Float then\n+         if P_Size <= Standard_Short_Float_Size then\n             Lib_RE := RE_I_SF;\n \n-         elsif Rt_Type = Standard_Float then\n+         elsif P_Size <= Standard_Float_Size then\n             Lib_RE := RE_I_F;\n \n-         elsif Rt_Type = Standard_Long_Float then\n+         elsif P_Size <= Standard_Long_Float_Size then\n             Lib_RE := RE_I_LF;\n \n-         else pragma Assert (Rt_Type = Standard_Long_Long_Float);\n+         else\n             Lib_RE := RE_I_LLF;\n          end if;\n \n@@ -615,13 +629,22 @@ package body Exp_Strm is\n       U_Type  : constant Entity_Id  := Underlying_Type (P_Type);\n       Rt_Type : constant Entity_Id  := Root_Type (U_Type);\n       FST     : constant Entity_Id  := First_Subtype (U_Type);\n-      P_Size  : constant Uint       := Esize (FST);\n       Strm    : constant Node_Id    := First (Expressions (N));\n       Item    : constant Node_Id    := Next (Strm);\n+      P_Size  : Uint;\n       Lib_RE  : RE_Id;\n       Libent  : Entity_Id;\n \n    begin\n+      --  Compute the size of the stream element. This is either the size of\n+      --  the first subtype or if given the size of the Stream_Size attribute.\n+\n+      if Is_Elementary_Type (FST) and then Has_Stream_Size_Clause (FST) then\n+         P_Size := Static_Integer (Expression (Stream_Size_Clause (FST)));\n+      else\n+         P_Size := Esize (FST);\n+      end if;\n+\n       --  Find the routine to be called\n \n       --  Check for First Boolean and Character. These are enumeration types,\n@@ -645,20 +668,21 @@ package body Exp_Strm is\n       then\n          Lib_RE := RE_W_WC;\n \n+      elsif Rt_Type = Standard_Wide_Wide_Character\n+        and then Has_Stream_Standard_Rep (U_Type)\n+      then\n+         Lib_RE := RE_W_WWC;\n+\n       --  Floating point types\n \n       elsif Is_Floating_Point_Type (U_Type) then\n-\n-         if Rt_Type = Standard_Short_Float then\n+         if P_Size <= Standard_Short_Float_Size then\n             Lib_RE := RE_W_SF;\n-\n-         elsif Rt_Type = Standard_Float then\n+         elsif P_Size <= Standard_Float_Size then\n             Lib_RE := RE_W_F;\n-\n-         elsif Rt_Type = Standard_Long_Float then\n+         elsif P_Size <= Standard_Long_Float_Size then\n             Lib_RE := RE_W_LF;\n-\n-         else pragma Assert (Rt_Type = Standard_Long_Long_Float);\n+         else\n             Lib_RE := RE_W_LLF;\n          end if;\n \n@@ -695,16 +719,12 @@ package body Exp_Strm is\n       then\n          if P_Size <= Standard_Short_Short_Integer_Size then\n             Lib_RE := RE_W_SSI;\n-\n          elsif P_Size <= Standard_Short_Integer_Size then\n             Lib_RE := RE_W_SI;\n-\n          elsif P_Size <= Standard_Integer_Size then\n             Lib_RE := RE_W_I;\n-\n          elsif P_Size <= Standard_Long_Integer_Size then\n             Lib_RE := RE_W_LI;\n-\n          else\n             Lib_RE := RE_W_LLI;\n          end if;\n@@ -723,16 +743,12 @@ package body Exp_Strm is\n       then\n          if P_Size <= Standard_Short_Short_Integer_Size then\n             Lib_RE := RE_W_SSU;\n-\n          elsif P_Size <= Standard_Short_Integer_Size then\n             Lib_RE := RE_W_SU;\n-\n          elsif P_Size <= Standard_Integer_Size then\n             Lib_RE := RE_W_U;\n-\n          elsif P_Size <= Standard_Long_Integer_Size then\n             Lib_RE := RE_W_LU;\n-\n          else\n             Lib_RE := RE_W_LLU;\n          end if;"}, {"sha": "162b939f125fbc0bb1c7dcff9ec09c72982d06a5", "filename": "gcc/ada/exp_util.adb", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/82c80734715c801643075ab68c5c9a5e00da1b03/gcc%2Fada%2Fexp_util.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/82c80734715c801643075ab68c5c9a5e00da1b03/gcc%2Fada%2Fexp_util.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_util.adb?ref=82c80734715c801643075ab68c5c9a5e00da1b03", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1992-2004, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2005, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -489,7 +489,7 @@ package body Exp_Util is\n              Make_Character_Literal (Loc,\n                Chars => Name_Find,\n                Char_Literal_Value =>\n-                 Char_Code (Character'Pos ('(')))));\n+                 UI_From_Int (Character'Pos ('(')))));\n \n       Append_To (Stats,\n          Make_Assignment_Statement (Loc,\n@@ -548,7 +548,7 @@ package body Exp_Util is\n                    Make_Character_Literal (Loc,\n                      Chars => Name_Find,\n                      Char_Literal_Value =>\n-                       Char_Code (Character'Pos (',')))));\n+                       UI_From_Int (Character'Pos (',')))));\n \n             Append_To (Stats,\n               Make_Assignment_Statement (Loc,\n@@ -571,7 +571,7 @@ package body Exp_Util is\n              Make_Character_Literal (Loc,\n                Chars => Name_Find,\n                Char_Literal_Value =>\n-                 Char_Code (Character'Pos (')')))));\n+                 UI_From_Int (Character'Pos (')')))));\n       return Build_Task_Image_Function (Loc, Decls, Stats, Res);\n    end Build_Task_Array_Image;\n \n@@ -870,7 +870,7 @@ package body Exp_Util is\n              Make_Character_Literal (Loc,\n                Chars => Name_Find,\n                Char_Literal_Value =>\n-                 Char_Code (Character'Pos ('.')))));\n+                 UI_From_Int (Character'Pos ('.')))));\n \n       Append_To (Stats,\n         Make_Assignment_Statement (Loc,\n@@ -1833,8 +1833,9 @@ package body Exp_Util is\n                N_Entry_Body                             |\n                N_Exception_Declaration                  |\n                N_Exception_Renaming_Declaration         |\n+               N_Formal_Abstract_Subprogram_Declaration |\n+               N_Formal_Concrete_Subprogram_Declaration |\n                N_Formal_Object_Declaration              |\n-               N_Formal_Subprogram_Declaration          |\n                N_Formal_Type_Declaration                |\n                N_Full_Type_Declaration                  |\n                N_Function_Instantiation                 |"}, {"sha": "5aa5b01ad71d97c85069e2ec7a3168ea8a418e5d", "filename": "gcc/ada/g-utf_32.adb", "status": "added", "additions": 1622, "deletions": 0, "changes": 1622, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/82c80734715c801643075ab68c5c9a5e00da1b03/gcc%2Fada%2Fg-utf_32.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/82c80734715c801643075ab68c5c9a5e00da1b03/gcc%2Fada%2Fg-utf_32.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fg-utf_32.adb?ref=82c80734715c801643075ab68c5c9a5e00da1b03"}, {"sha": "1da9cf68fb89e8806ddb341370e9dd1a772fa2b6", "filename": "gcc/ada/g-utf_32.ads", "status": "added", "additions": 124, "deletions": 0, "changes": 124, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/82c80734715c801643075ab68c5c9a5e00da1b03/gcc%2Fada%2Fg-utf_32.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/82c80734715c801643075ab68c5c9a5e00da1b03/gcc%2Fada%2Fg-utf_32.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fg-utf_32.ads?ref=82c80734715c801643075ab68c5c9a5e00da1b03", "patch": "@@ -0,0 +1,124 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT RUNTIME COMPONENTS                          --\n+--                                                                          --\n+--                          G N A T . U T F _ 3 2                           --\n+--                                                                          --\n+--                                 S p e c                                  --\n+--                                                                          --\n+--             Copyright (C) 2005 Free Software Foundation, Inc.            --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 2,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n+-- for  more details.  You should have  received  a copy of the GNU General --\n+-- Public License  distributed with GNAT;  see file COPYING.  If not, write --\n+-- to  the Free Software Foundation,  59 Temple Place - Suite 330,  Boston, --\n+-- MA 02111-1307, USA.                                                      --\n+--                                                                          --\n+-- As a special exception,  if other files  instantiate  generics from this --\n+-- unit, or you link  this unit with other files  to produce an executable, --\n+-- this  unit  does not  by itself cause  the resulting  executable  to  be --\n+-- covered  by the  GNU  General  Public  License.  This exception does not --\n+-- however invalidate  any other reasons why  the executable file  might be --\n+-- covered by the  GNU Public License.                                      --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- Extensive contributions were provided by Ada Core Technologies Inc.      --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+--  This package is an internal package that provides basic character\n+--  classification capabilities needed by the compiler for handling full\n+--  32-bit wide wide characters. We avoid the use of the actual type\n+--  Wide_Wide_Character, since we want to use these routines in the compiler\n+--  itself, and we want to be able to compile the compiler with old versions\n+--  of GNAT that did not implement Wide_Wide_Character.\n+\n+--  This package is not available directly for use in application programs,\n+--  but it serves as the basis for GNAT.Wide_Case_Utilities and\n+--  GNAT.Wide_Wide_Case_Utilities, which can be used directly.\n+\n+package GNAT.UTF_32 is\n+\n+   type UTF_32 is mod 2 ** 32;\n+   --  The actual allowed range is 16#00_0000# .. 16#01_FFFF#\n+\n+   function Is_UTF_32_Letter (U : UTF_32) return Boolean;\n+   pragma Inline (Is_UTF_32_Letter);\n+   --  Returns true iff U is a letter that can be used to start an identifier.\n+   --  This means that it is in one of the following categories:\n+   --    Letter, Uppercase (Lu)\n+   --    Letter, Lowercase (Ll)\n+   --    Letter, Titlecase (Lt)\n+   --    Letter, Modifier  (Lm)\n+   --    Letter, Other     (Lo)\n+   --    Number, Letter    (Nl)\n+\n+   function Is_UTF_32_Digit (U : UTF_32) return Boolean;\n+   pragma Inline (Is_UTF_32_Digit);\n+   --  Returns true iff U is a digit that can be used to extend an identifer,\n+   --  which means it is in one of the following categories:\n+   --    Number, Decimal_Digit (Nd)\n+\n+   function Is_UTF_32_Line_Terminator (U : UTF_32) return Boolean;\n+   pragma Inline (Is_UTF_32_Line_Terminator);\n+   --  Returns true iff U is an allowed line terminator for source programs,\n+   --  which means it is in one of the following categories:\n+   --    Separator, Line (Zl)\n+   --    Separator, Paragraph (Zp)\n+   --  or that it is a conventional line terminator (CR, LF, VT, FF)\n+\n+   function Is_UTF_32_Mark (U : UTF_32) return Boolean;\n+   pragma Inline (Is_UTF_32_Mark);\n+   --  Returns true iff U is a mark character which can be used to extend\n+   --  an identifier. This means it is in one of the following categories:\n+   --    Mark, Non-Spacing (Mn)\n+   --    Mark, Spacing Combining (Mc)\n+\n+   function Is_UTF_32_Other (U : UTF_32) return Boolean;\n+   pragma Inline (Is_UTF_32_Other);\n+   --  Returns true iff U is an other format character, which means that it\n+   --  can be used to extend an identifier, but is ignored for the purposes of\n+   --  matching of identiers. This means that it is in one of the following\n+   --  categories:\n+   --    Other, Format (Cf)\n+\n+   function Is_UTF_32_Punctuation (U : UTF_32) return Boolean;\n+   pragma Inline (Is_UTF_32_Punctuation);\n+   --  Returns true iff U is a punctuation character that can be used to\n+   --  separate pices of an identifier. This means that it is in one of the\n+   --  following categories:\n+   --    Punctuation, Connector (Pc)\n+\n+   function Is_UTF_32_Space (U : UTF_32) return Boolean;\n+   pragma Inline (Is_UTF_32_Space);\n+   --  Returns true iff U is considered a space to be ignored, which means\n+   --  that it is in one of the following categories:\n+   --    Separator, Space (Zs)\n+\n+   function Is_UTF_32_Non_Graphic (U : UTF_32) return Boolean;\n+   pragma Inline (Is_UTF_32_Non_Graphic);\n+   --  Returns true iff U is considered to be a non-graphic character,\n+   --  which means that it is in one of the following categories:\n+   --    Other, Control (Cc)\n+   --    Other, Private Use (Co)\n+   --    Other, Surrogate (Cs)\n+   --    Other, Format (Cf)\n+   --    Separator, Line (Zl)\n+   --    Separator, Paragraph (Zp)\n+   --\n+   --  Note that the Ada category format effector is subsumed by the above\n+   --  list of Unicode categories.\n+\n+   function UTF_32_To_Upper_Case (U : UTF_32) return UTF_32;\n+   pragma Inline (UTF_32_To_Upper_Case);\n+   --  If U represents a lower case letter, returns the corresponding upper\n+   --  case letter, otherwise U is returned unchanged. The folding is locale\n+   --  independent as defined by documents referenced in the note in section\n+   --  1 of ISO/IEC 10646:2003\n+\n+end GNAT.UTF_32;"}, {"sha": "8ec6e0cd85eff1d13e2c70399dc22746a688b570", "filename": "gcc/ada/g-zstspl.ads", "status": "added", "additions": 46, "deletions": 0, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/82c80734715c801643075ab68c5c9a5e00da1b03/gcc%2Fada%2Fg-zstspl.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/82c80734715c801643075ab68c5c9a5e00da1b03/gcc%2Fada%2Fg-zstspl.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fg-zstspl.ads?ref=82c80734715c801643075ab68c5c9a5e00da1b03", "patch": "@@ -0,0 +1,46 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT COMPILER COMPONENTS                         --\n+--                                                                          --\n+--           G N A T . W I D E _ W I D E _ S T R I N G _ S P L I T          --\n+--                                                                          --\n+--                                 S p e c                                  --\n+--                                                                          --\n+--          Copyright (C) 2002-2005 Free Software Foundation, Inc.          --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 2,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n+-- for  more details.  You should have  received  a copy of the GNU General --\n+-- Public License  distributed with GNAT;  see file COPYING.  If not, write --\n+-- to  the Free Software Foundation,  59 Temple Place - Suite 330,  Boston, --\n+-- MA 02111-1307, USA.                                                      --\n+--                                                                          --\n+-- As a special exception,  if other files  instantiate  generics from this --\n+-- unit, or you link  this unit with other files  to produce an executable, --\n+-- this  unit  does not  by itself cause  the resulting  executable  to  be --\n+-- covered  by the  GNU  General  Public  License.  This exception does not --\n+-- however invalidate  any other reasons why  the executable file  might be --\n+-- covered by the  GNU Public License.                                      --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- Extensive contributions were provided by Ada Core Technologies Inc.      --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+--  Useful wide_string-manipulation routines: given a set of separators, split\n+--  a wide_string wherever the separators appear, and provide direct access\n+--  to the resulting slices. See GNAT.Array_Split for full documentation.\n+\n+with Ada.Strings.Wide_Wide_Maps; use Ada.Strings;\n+with GNAT.Array_Split;\n+\n+package GNAT.Wide_Wide_String_Split is new GNAT.Array_Split\n+  (Element          => Wide_Wide_Character,\n+   Element_Sequence => Wide_Wide_String,\n+   Element_Set      => Wide_Wide_Maps.Wide_Wide_Character_Set,\n+   To_Set           => Wide_Wide_Maps.To_Set,\n+   Is_In            => Wide_Wide_Maps.Is_In);"}, {"sha": "d13af031bc8cc5058e7ab7099688e44332d85ec3", "filename": "gcc/ada/gnatbind.adb", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/82c80734715c801643075ab68c5c9a5e00da1b03/gcc%2Fada%2Fgnatbind.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/82c80734715c801643075ab68c5c9a5e00da1b03/gcc%2Fada%2Fgnatbind.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgnatbind.adb?ref=82c80734715c801643075ab68c5c9a5e00da1b03", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1992-2004 Free Software Foundation, Inc.          --\n+--          Copyright (C) 1992-2005 Free Software Foundation, Inc.          --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -120,7 +120,7 @@ procedure Gnatbind is\n          Max_Storage_At_Blocking  => True,\n          --  Not checkable at compile time\n \n-         others                   => False);\n+         others => False);\n \n       Additional_Restrictions_Listed : Boolean := False;\n       --  Set True if we have listed header for restrictions\n@@ -337,8 +337,8 @@ procedure Gnatbind is\n             Opt.Bind_Alternate_Main_Name := True;\n             Opt.Alternate_Main_Name := new String'(Argv (3 .. Argv'Last));\n \n-         --  All other options are single character and are handled\n-         --  by Scan_Binder_Switches.\n+         --  All other options are single character and are handled by\n+         --  Scan_Binder_Switches.\n \n          else\n             Scan_Binder_Switches (Argv);\n@@ -438,10 +438,10 @@ begin\n    Osint.Add_Default_Search_Dirs;\n \n    --  Carry out package initializations. These are initializations which\n-   --  might logically be performed at elaboration time, but Namet at\n-   --  least can't be done that way (because it is used in the Compiler),\n-   --  and we decide to be consistent. Like elaboration, the order in\n-   --  which these calls are made is in some cases important.\n+   --  might logically be performed at elaboration time, but Namet at least\n+   --  can't be done that way (because it is used in the Compiler), and we\n+   --  decide to be consistent. Like elaboration, the order in which these\n+   --  calls are made is in some cases important.\n \n    Csets.Initialize;\n    Namet.Initialize;\n@@ -481,7 +481,7 @@ begin\n       Write_Str (\"GNATBIND \");\n       Write_Str (Gnat_Version_String);\n       Write_Eol;\n-      Write_Str (\"Copyright 1995-2004 Free Software Foundation, Inc.\");\n+      Write_Str (\"Copyright 1995-2005 Free Software Foundation, Inc.\");\n       Write_Eol;\n    end if;\n \n@@ -562,7 +562,7 @@ begin\n       --  ALI files.\n \n       for Index in ALIs.First .. ALIs.Last loop\n-         ALIs.Table (Index).Interface := False;\n+         ALIs.Table (Index).SAL_Interface := False;\n       end loop;\n \n       --  Add System.Standard_Library to list to ensure that these files are\n@@ -654,7 +654,7 @@ begin\n                Write_Eol;\n \n                for J in Elab_Order.First .. Elab_Order.Last loop\n-                  if not Units.Table (Elab_Order.Table (J)).Interface then\n+                  if not Units.Table (Elab_Order.Table (J)).SAL_Interface then\n                      Write_Str (\"   \");\n                      Write_Unit_Name\n                        (Units.Table (Elab_Order.Table (J)).Uname);\n@@ -680,7 +680,7 @@ begin\n          Total_Warnings := Total_Warnings + Warnings_Detected;\n    end;\n \n-   --  All done. Set proper exit status.\n+   --  All done. Set proper exit status\n \n    Finalize_Binderr;\n    Namet.Finalize;"}, {"sha": "900b0ead18ac53d6b128b316c569df8f9804fd64", "filename": "gcc/ada/gnatls.adb", "status": "modified", "additions": 13, "deletions": 11, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/82c80734715c801643075ab68c5c9a5e00da1b03/gcc%2Fada%2Fgnatls.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/82c80734715c801643075ab68c5c9a5e00da1b03/gcc%2Fada%2Fgnatls.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgnatls.adb?ref=82c80734715c801643075ab68c5c9a5e00da1b03", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---           Copyright (C) 1992-2004 Free Software Foundation, Inc.         --\n+--           Copyright (C) 1992-2005 Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -52,11 +52,12 @@ procedure Gnatls is\n    --  Name of the env. variable that contains path name(s) of directories\n    --  where project files may reside.\n \n+   --  NOTE : The following string may be used by other tools, such as GPS. So\n+   --  it can only be modified if these other uses are checked and coordinated.\n+\n    Project_Search_Path : constant String := \"Project Search Path:\";\n    --  Label displayed in verbose mode before the directories in the project\n-   --  search path.\n-   --  NOTE: This string may be used by other tools, such as GPS; so, it\n-   --        should not be modified inconsiderately.\n+   --  search path. Do not modify without checking NOTE above.\n \n    No_Project_Default_Dir : constant String := \"-\";\n \n@@ -549,6 +550,7 @@ procedure Gnatls is\n          --  Remove any encoding info (%s or %b)\n \n          Get_Name_String (N);\n+\n          if Name_Len > 2\n            and then Name_Buffer (Name_Len - 1) = '%'\n          then\n@@ -977,7 +979,7 @@ procedure Gnatls is\n                U.Internal            or\n                U.Is_Generic          or\n                U.Init_Scalars        or\n-               U.Interface           or\n+               U.SAL_Interface       or\n                U.Body_Needed_For_SAL or\n                U.Elaborate_Body\n             then\n@@ -1032,8 +1034,8 @@ procedure Gnatls is\n                   Write_Str (\" Init_Scalars\");\n                end if;\n \n-               if U.Interface then\n-                  Write_Str (\" Interface\");\n+               if U.SAL_Interface then\n+                  Write_Str (\" SAL_Interface\");\n                end if;\n \n                if U.Body_Needed_For_SAL then\n@@ -1247,6 +1249,7 @@ procedure Gnatls is\n                --  Scan the file line by line\n \n                while Index < Buffer'Last loop\n+\n                   --  Find the end of line\n \n                   Last := Index;\n@@ -1448,10 +1451,9 @@ procedure Gnatls is\n          Output_Status (ST, Verbose => True);\n          Write_Eol;\n       end loop;\n-\n    end Usage;\n \n---   Start of processing for Gnatls\n+--  Start of processing for Gnatls\n \n begin\n    --  Initialize standard packages\n@@ -1498,7 +1500,7 @@ begin\n       Write_Str (\"GNATLS \");\n       Write_Str (Gnat_Version_String);\n       Write_Eol;\n-      Write_Str (\"Copyright 1997-2004 Free Software Foundation, Inc.\");\n+      Write_Str (\"Copyright 1997-2005 Free Software Foundation, Inc.\");\n       Write_Eol;\n       Write_Eol;\n       Write_Str (\"Source Search Path:\");\n@@ -1583,6 +1585,7 @@ begin\n                   Add_Default_Dir := False;\n \n                elsif First /= Last or else Project_Path (First) /= '.' then\n+\n                   --  If the directory is \".\", skip it as it is the current\n                   --  directory and it is already the first directory in the\n                   --  project path.\n@@ -1755,7 +1758,6 @@ begin\n                   Write_Str (\"depends upon\");\n                   Write_Eol;\n                   Write_Str (\"   \");\n-\n                else\n                   Write_Eol;\n                end if;"}, {"sha": "da8e3146f66606874063bafe86ee2dcf288922ee", "filename": "gcc/ada/i-c.adb", "status": "modified", "additions": 410, "deletions": 35, "changes": 445, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/82c80734715c801643075ab68c5c9a5e00da1b03/gcc%2Fada%2Fi-c.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/82c80734715c801643075ab68c5c9a5e00da1b03/gcc%2Fada%2Fi-c.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fi-c.adb?ref=82c80734715c801643075ab68c5c9a5e00da1b03", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1992-2004 Free Software Foundation, Inc.          --\n+--          Copyright (C) 1992-2005 Free Software Foundation, Inc.          --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -63,6 +63,32 @@ package body Interfaces.C is\n       return False;\n    end Is_Nul_Terminated;\n \n+   --  Case of char16_array\n+\n+   function Is_Nul_Terminated (Item : char16_array) return Boolean is\n+   begin\n+      for J in Item'Range loop\n+         if Item (J) = char16_nul then\n+            return True;\n+         end if;\n+      end loop;\n+\n+      return False;\n+   end Is_Nul_Terminated;\n+\n+   --  Case of char32_array\n+\n+   function Is_Nul_Terminated (Item : char32_array) return Boolean is\n+   begin\n+      for J in Item'Range loop\n+         if Item (J) = char32_nul then\n+            return True;\n+         end if;\n+      end loop;\n+\n+      return False;\n+   end Is_Nul_Terminated;\n+\n    ------------\n    -- To_Ada --\n    ------------\n@@ -78,8 +104,7 @@ package body Interfaces.C is\n \n    function To_Ada\n      (Item     : char_array;\n-      Trim_Nul : Boolean := True)\n-      return     String\n+      Trim_Nul : Boolean := True) return String\n    is\n       Count : Natural;\n       From  : size_t;\n@@ -119,10 +144,10 @@ package body Interfaces.C is\n    --  Convert char_array to String (procedure form)\n \n    procedure To_Ada\n-     (Item       : char_array;\n-      Target     : out String;\n-      Count      : out Natural;\n-      Trim_Nul   : Boolean := True)\n+     (Item     : char_array;\n+      Target   : out String;\n+      Count    : out Natural;\n+      Trim_Nul : Boolean := True)\n    is\n       From : size_t;\n       To   : Positive;\n@@ -173,8 +198,7 @@ package body Interfaces.C is\n \n    function To_Ada\n      (Item     : wchar_array;\n-      Trim_Nul : Boolean := True)\n-      return     Wide_String\n+      Trim_Nul : Boolean := True) return Wide_String\n    is\n       Count : Natural;\n       From  : size_t;\n@@ -214,13 +238,13 @@ package body Interfaces.C is\n    --  Convert wchar_array to Wide_String (procedure form)\n \n    procedure To_Ada\n-     (Item       : wchar_array;\n-      Target     : out Wide_String;\n-      Count      : out Natural;\n-      Trim_Nul   : Boolean := True)\n+     (Item     : wchar_array;\n+      Target   : out Wide_String;\n+      Count    : out Natural;\n+      Trim_Nul : Boolean := True)\n    is\n-      From   : size_t;\n-      To     : Positive;\n+      From : size_t;\n+      To   : Positive;\n \n    begin\n       if Trim_Nul then\n@@ -254,7 +278,192 @@ package body Interfaces.C is\n             To   := To + 1;\n          end loop;\n       end if;\n+   end To_Ada;\n+\n+   --  Convert char16_t to Wide_Character\n+\n+   function To_Ada (Item : char16_t) return Wide_Character is\n+   begin\n+      return Wide_Character'Val (char16_t'Pos (Item));\n+   end To_Ada;\n+\n+   --  Convert char16_array to Wide_String (function form)\n+\n+   function To_Ada\n+     (Item     : char16_array;\n+      Trim_Nul : Boolean := True) return Wide_String\n+   is\n+      Count : Natural;\n+      From  : size_t;\n+\n+   begin\n+      if Trim_Nul then\n+         From := Item'First;\n+\n+         loop\n+            if From > Item'Last then\n+               raise Terminator_Error;\n+            elsif Item (From) = char16_t'Val (0) then\n+               exit;\n+            else\n+               From := From + 1;\n+            end if;\n+         end loop;\n+\n+         Count := Natural (From - Item'First);\n+\n+      else\n+         Count := Item'Length;\n+      end if;\n+\n+      declare\n+         R : Wide_String (1 .. Count);\n+\n+      begin\n+         for J in R'Range loop\n+            R (J) := To_Ada (Item (size_t (J) + (Item'First - 1)));\n+         end loop;\n+\n+         return R;\n+      end;\n+   end To_Ada;\n+\n+   --  Convert char16_array to Wide_String (procedure form)\n+\n+   procedure To_Ada\n+     (Item     : char16_array;\n+      Target   : out Wide_String;\n+      Count    : out Natural;\n+      Trim_Nul : Boolean := True)\n+   is\n+      From : size_t;\n+      To   : Positive;\n+\n+   begin\n+      if Trim_Nul then\n+         From := Item'First;\n+         loop\n+            if From > Item'Last then\n+               raise Terminator_Error;\n+            elsif Item (From) = char16_t'Val (0) then\n+               exit;\n+            else\n+               From := From + 1;\n+            end if;\n+         end loop;\n+\n+         Count := Natural (From - Item'First);\n+\n+      else\n+         Count := Item'Length;\n+      end if;\n+\n+      if Count > Target'Length then\n+         raise Constraint_Error;\n+\n+      else\n+         From := Item'First;\n+         To   := Target'First;\n+\n+         for J in 1 .. Count loop\n+            Target (To) := To_Ada (Item (From));\n+            From := From + 1;\n+            To   := To + 1;\n+         end loop;\n+      end if;\n+   end To_Ada;\n+\n+   --  Convert char32_t to Wide_Wide_Character\n+\n+   function To_Ada (Item : char32_t) return Wide_Wide_Character is\n+   begin\n+      return Wide_Wide_Character'Val (char32_t'Pos (Item));\n+   end To_Ada;\n+\n+   --  Convert char32_array to Wide_Wide_String (function form)\n+\n+   function To_Ada\n+     (Item     : char32_array;\n+      Trim_Nul : Boolean := True) return Wide_Wide_String\n+   is\n+      Count : Natural;\n+      From  : size_t;\n+\n+   begin\n+      if Trim_Nul then\n+         From := Item'First;\n+\n+         loop\n+            if From > Item'Last then\n+               raise Terminator_Error;\n+            elsif Item (From) = char32_t'Val (0) then\n+               exit;\n+            else\n+               From := From + 1;\n+            end if;\n+         end loop;\n+\n+         Count := Natural (From - Item'First);\n+\n+      else\n+         Count := Item'Length;\n+      end if;\n+\n+      declare\n+         R : Wide_Wide_String (1 .. Count);\n+\n+      begin\n+         for J in R'Range loop\n+            R (J) := To_Ada (Item (size_t (J) + (Item'First - 1)));\n+         end loop;\n \n+         return R;\n+      end;\n+   end To_Ada;\n+\n+   --  Convert char32_array to Wide_Wide_String (procedure form)\n+\n+   procedure To_Ada\n+     (Item     : char32_array;\n+      Target   : out Wide_Wide_String;\n+      Count    : out Natural;\n+      Trim_Nul : Boolean := True)\n+   is\n+      From : size_t;\n+      To   : Positive;\n+\n+   begin\n+      if Trim_Nul then\n+         From := Item'First;\n+         loop\n+            if From > Item'Last then\n+               raise Terminator_Error;\n+            elsif Item (From) = char32_t'Val (0) then\n+               exit;\n+            else\n+               From := From + 1;\n+            end if;\n+         end loop;\n+\n+         Count := Natural (From - Item'First);\n+\n+      else\n+         Count := Item'Length;\n+      end if;\n+\n+      if Count > Target'Length then\n+         raise Constraint_Error;\n+\n+      else\n+         From := Item'First;\n+         To   := Target'First;\n+\n+         for J in 1 .. Count loop\n+            Target (To) := To_Ada (Item (From));\n+            From := From + 1;\n+            To   := To + 1;\n+         end loop;\n+      end if;\n    end To_Ada;\n \n    ----------\n@@ -272,8 +481,7 @@ package body Interfaces.C is\n \n    function To_C\n      (Item       : String;\n-      Append_Nul : Boolean := True)\n-      return       char_array\n+      Append_Nul : Boolean := True) return char_array\n    is\n    begin\n       if Append_Nul then\n@@ -292,12 +500,11 @@ package body Interfaces.C is\n       --  Append_Nul False\n \n       else\n-\n-         --  A nasty case, if the string is null, we must return\n-         --  a null char_array. The lower bound of this array is\n-         --  required to be zero (RM B.3(50)) but that is of course\n-         --  impossible given that size_t is unsigned. According to\n-         --  Ada 2005 AI-258, the result is to raise Constraint_Error.\n+         --  A nasty case, if the string is null, we must return a null\n+         --  char_array. The lower bound of this array is required to be zero\n+         --  (RM B.3(50)) but that is of course impossible given that size_t\n+         --  is unsigned. According to Ada 2005 AI-258, the result is to raise\n+         --  Constraint_Error.\n \n          if Item'Length = 0 then\n             raise Constraint_Error;\n@@ -365,8 +572,7 @@ package body Interfaces.C is\n \n    function To_C\n      (Item       : Wide_String;\n-      Append_Nul : Boolean := True)\n-      return       wchar_array\n+      Append_Nul : Boolean := True) return wchar_array\n    is\n    begin\n       if Append_Nul then\n@@ -383,23 +589,105 @@ package body Interfaces.C is\n          end;\n \n       else\n-         --  A nasty case, if the string is null, we must return\n-         --  a null char_array. The lower bound of this array is\n-         --  required to be zero (RM B.3(50)) but that is of course\n-         --  impossible given that size_t is unsigned. This needs\n-         --  ARG resolution, but for now GNAT returns bounds 1 .. 0\n+         --  A nasty case, if the string is null, we must return a null\n+         --  wchar_array. The lower bound of this array is required to be zero\n+         --  (RM B.3(50)) but that is of course impossible given that size_t\n+         --  is unsigned. According to Ada 2005 AI-258, the result is to raise\n+         --  Constraint_Error.\n \n          if Item'Length = 0 then\n+            raise Constraint_Error;\n+\n+         else\n             declare\n-               R : wchar_array (1 .. 0);\n+               R : wchar_array (0 .. Item'Length - 1);\n \n             begin\n+               for J in size_t range 0 .. Item'Length - 1 loop\n+                  R (J) := To_C (Item (Integer (J) + Item'First));\n+               end loop;\n+\n                return R;\n             end;\n+         end if;\n+      end if;\n+   end To_C;\n+\n+   --  Convert Wide_String to wchar_array (procedure form)\n+\n+   procedure To_C\n+     (Item       : Wide_String;\n+      Target     : out wchar_array;\n+      Count      : out size_t;\n+      Append_Nul : Boolean := True)\n+   is\n+      To : size_t;\n+\n+   begin\n+      if Target'Length < Item'Length then\n+         raise Constraint_Error;\n+\n+      else\n+         To := Target'First;\n+         for From in Item'Range loop\n+            Target (To) := To_C (Item (From));\n+            To := To + 1;\n+         end loop;\n+\n+         if Append_Nul then\n+            if To > Target'Last then\n+               raise Constraint_Error;\n+            else\n+               Target (To) := wide_nul;\n+               Count := Item'Length + 1;\n+            end if;\n+\n+         else\n+            Count := Item'Length;\n+         end if;\n+      end if;\n+   end To_C;\n+\n+   --  Convert Wide_Character to char16_t\n+\n+   function To_C (Item : Wide_Character) return char16_t is\n+   begin\n+      return char16_t'Val (Wide_Character'Pos (Item));\n+   end To_C;\n+\n+   --  Convert Wide_String to char16_array (function form)\n+\n+   function To_C\n+     (Item       : Wide_String;\n+      Append_Nul : Boolean := True) return char16_array\n+   is\n+   begin\n+      if Append_Nul then\n+         declare\n+            R : char16_array (0 .. Item'Length);\n+\n+         begin\n+            for J in Item'Range loop\n+               R (size_t (J - Item'First)) := To_C (Item (J));\n+            end loop;\n+\n+            R (R'Last) := char16_t'Val (0);\n+            return R;\n+         end;\n+\n+      else\n+         --  A nasty case, if the string is null, we must return a null\n+         --  char16_array. The lower bound of this array is required to be zero\n+         --  (RM B.3(50)) but that is of course impossible given that size_t\n+         --  is unsigned. According to Ada 2005 AI-258, the result is to raise\n+         --  Constraint_Error.\n+\n+         if Item'Length = 0 then\n+            raise Constraint_Error;\n \n          else\n             declare\n-               R : wchar_array (0 .. Item'Length - 1);\n+               R : char16_array (0 .. Item'Length - 1);\n \n             begin\n                for J in size_t range 0 .. Item'Length - 1 loop\n@@ -412,11 +700,11 @@ package body Interfaces.C is\n       end if;\n    end To_C;\n \n-   --  Convert Wide_String to wchar_array (procedure form)\n+   --  Convert Wide_String to char16_array (procedure form)\n \n    procedure To_C\n      (Item       : Wide_String;\n-      Target     : out wchar_array;\n+      Target     : out char16_array;\n       Count      : out size_t;\n       Append_Nul : Boolean := True)\n    is\n@@ -437,7 +725,94 @@ package body Interfaces.C is\n             if To > Target'Last then\n                raise Constraint_Error;\n             else\n-               Target (To) := wide_nul;\n+               Target (To) := char16_t'Val (0);\n+               Count := Item'Length + 1;\n+            end if;\n+\n+         else\n+            Count := Item'Length;\n+         end if;\n+      end if;\n+   end To_C;\n+\n+   --  Convert Wide_Character to char32_t\n+\n+   function To_C (Item : Wide_Wide_Character) return char32_t is\n+   begin\n+      return char32_t'Val (Wide_Wide_Character'Pos (Item));\n+   end To_C;\n+\n+   --  Convert Wide_Wide_String to char32_array (function form)\n+\n+   function To_C\n+     (Item       : Wide_Wide_String;\n+      Append_Nul : Boolean := True) return char32_array\n+   is\n+   begin\n+      if Append_Nul then\n+         declare\n+            R : char32_array (0 .. Item'Length);\n+\n+         begin\n+            for J in Item'Range loop\n+               R (size_t (J - Item'First)) := To_C (Item (J));\n+            end loop;\n+\n+            R (R'Last) := char32_t'Val (0);\n+            return R;\n+         end;\n+\n+      else\n+         --  A nasty case, if the string is null, we must return a null\n+         --  char32_array. The lower bound of this array is required to be zero\n+         --  (RM B.3(50)) but that is of course impossible given that size_t\n+         --  is unsigned. According to Ada 2005 AI-258, the result is to raise\n+         --  Constraint_Error.\n+\n+         if Item'Length = 0 then\n+            raise Constraint_Error;\n+\n+         else\n+            declare\n+               R : char32_array (0 .. Item'Length - 1);\n+\n+            begin\n+               for J in size_t range 0 .. Item'Length - 1 loop\n+                  R (J) := To_C (Item (Integer (J) + Item'First));\n+               end loop;\n+\n+               return R;\n+            end;\n+         end if;\n+      end if;\n+   end To_C;\n+\n+   --  Convert Wide_Wide_String to char32_array (procedure form)\n+\n+   procedure To_C\n+     (Item       : Wide_Wide_String;\n+      Target     : out char32_array;\n+      Count      : out size_t;\n+      Append_Nul : Boolean := True)\n+   is\n+      To : size_t;\n+\n+   begin\n+      if Target'Length < Item'Length then\n+         raise Constraint_Error;\n+\n+      else\n+         To := Target'First;\n+         for From in Item'Range loop\n+            Target (To) := To_C (Item (From));\n+            To := To + 1;\n+         end loop;\n+\n+         if Append_Nul then\n+            if To > Target'Last then\n+               raise Constraint_Error;\n+            else\n+               Target (To) := char32_t'Val (0);\n                Count := Item'Length + 1;\n             end if;\n "}, {"sha": "f264850589e560ed2a7d42c31b2afee1cc19fd43", "filename": "gcc/ada/i-c.ads", "status": "modified", "additions": 111, "deletions": 51, "changes": 162, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/82c80734715c801643075ab68c5c9a5e00da1b03/gcc%2Fada%2Fi-c.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/82c80734715c801643075ab68c5c9a5e00da1b03/gcc%2Fada%2Fi-c.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fi-c.ads?ref=82c80734715c801643075ab68c5c9a5e00da1b03", "patch": "@@ -6,32 +6,10 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---          Copyright (C) 1992-2004 Free Software Foundation, Inc.          --\n---                                                                          --\n--- This specification is derived from the Ada Reference Manual for use with --\n--- GNAT. The copyright notice above, and the license provisions that follow --\n--- apply solely to the  contents of the part following the private keyword. --\n---                                                                          --\n--- GNAT is free software;  you can  redistribute it  and/or modify it under --\n--- terms of the  GNU General Public License as published  by the Free Soft- --\n--- ware  Foundation;  either version 2,  or (at your option) any later ver- --\n--- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n--- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n--- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n--- for  more details.  You should have  received  a copy of the GNU General --\n--- Public License  distributed with GNAT;  see file COPYING.  If not, write --\n--- to  the Free Software Foundation,  59 Temple Place - Suite 330,  Boston, --\n--- MA 02111-1307, USA.                                                      --\n---                                                                          --\n--- As a special exception,  if other files  instantiate  generics from this --\n--- unit, or you link  this unit with other files  to produce an executable, --\n--- this  unit  does not  by itself cause  the resulting  executable  to  be --\n--- covered  by the  GNU  General  Public  License.  This exception does not --\n--- however invalidate  any other reasons why  the executable file  might be --\n--- covered by the  GNU Public License.                                      --\n---                                                                          --\n--- GNAT was originally developed  by the GNAT team at  New York University. --\n--- Extensive contributions were provided by Ada Core Technologies Inc.      --\n+-- This specification is adapted from the Ada Reference Manual for use with --\n+-- GNAT.  In accordance with the copyright of that document, you can freely --\n+-- copy and modify this specification,  provided that if you redistribute a --\n+-- modified version,  any changes that you have made are clearly indicated. --\n --                                                                          --\n ------------------------------------------------------------------------------\n \n@@ -104,26 +82,24 @@ pragma Pure (C);\n    function Is_Nul_Terminated (Item : in char_array) return Boolean;\n \n    function To_C\n-     (Item       : in String;\n-      Append_Nul : in Boolean := True)\n-      return       char_array;\n+     (Item       : String;\n+      Append_Nul : Boolean := True) return char_array;\n \n    function To_Ada\n-     (Item     : in char_array;\n-      Trim_Nul : in Boolean := True)\n-      return     String;\n+     (Item     : char_array;\n+      Trim_Nul : Boolean := True) return String;\n \n    procedure To_C\n-     (Item       : in String;\n+     (Item       : String;\n       Target     : out char_array;\n       Count      : out size_t;\n-      Append_Nul : in Boolean := True);\n+      Append_Nul : Boolean := True);\n \n    procedure To_Ada\n-     (Item     : in char_array;\n+     (Item     : char_array;\n       Target   : out String;\n       Count    : out Natural;\n-      Trim_Nul : in Boolean := True);\n+      Trim_Nul : Boolean := True);\n \n    ------------------------------------\n    -- Wide Character and Wide String --\n@@ -134,37 +110,121 @@ pragma Pure (C);\n \n    wide_nul : constant wchar_t := wchar_t'First;\n \n-   function To_C   (Item : in Wide_Character) return wchar_t;\n-   function To_Ada (Item : in wchar_t)        return Wide_Character;\n+   function To_C   (Item : Wide_Character) return wchar_t;\n+   function To_Ada (Item : wchar_t)        return Wide_Character;\n \n    type wchar_array is array (size_t range <>) of aliased wchar_t;\n \n-   function Is_Nul_Terminated (Item : in wchar_array) return Boolean;\n+   function Is_Nul_Terminated (Item : wchar_array) return Boolean;\n \n    function To_C\n-     (Item       : in Wide_String;\n-      Append_Nul : in Boolean := True)\n-      return       wchar_array;\n+     (Item       : Wide_String;\n+      Append_Nul : Boolean := True) return wchar_array;\n \n    function To_Ada\n-     (Item     : in wchar_array;\n-      Trim_Nul : in Boolean := True)\n-      return     Wide_String;\n+     (Item     : wchar_array;\n+      Trim_Nul : Boolean := True) return Wide_String;\n \n    procedure To_C\n-     (Item       : in Wide_String;\n+     (Item       : Wide_String;\n       Target     : out wchar_array;\n       Count      : out size_t;\n-      Append_Nul : in Boolean := True);\n+      Append_Nul : Boolean := True);\n \n    procedure To_Ada\n-     (Item     : in wchar_array;\n+     (Item     : wchar_array;\n       Target   : out Wide_String;\n       Count    : out Natural;\n-      Trim_Nul : in Boolean := True);\n+      Trim_Nul : Boolean := True);\n \n    Terminator_Error : exception;\n \n-private\n-   --  No private declarations required\n+   --  The remaining declarations are for Ada 2005 (AI-285)\n+\n+   --  ISO/IEC 10646:2003 compatible types defined by SC22/WG14 document N1010\n+\n+   type char16_t is new Wide_Character;\n+   pragma Ada_05 (char16_t);\n+\n+   char16_nul : constant char16_t := char16_t'Val (0);\n+   pragma Ada_05 (char16_nul);\n+\n+   function To_C (Item : Wide_Character) return char16_t;\n+   pragma Ada_05 (To_C);\n+\n+   function To_Ada (Item : char16_t) return Wide_Character;\n+   pragma Ada_05 (To_Ada);\n+\n+   type char16_array is array (size_t range <>) of aliased char16_t;\n+   pragma Ada_05 (char16_array);\n+\n+   function Is_Nul_Terminated (Item : char16_array) return Boolean;\n+   pragma Ada_05 (Is_Nul_Terminated);\n+\n+   function To_C\n+     (Item       : Wide_String;\n+      Append_Nul : Boolean := True) return char16_array;\n+   pragma Ada_05 (To_C);\n+\n+   function To_Ada\n+     (Item     : char16_array;\n+      Trim_Nul : Boolean := True) return Wide_String;\n+   pragma Ada_05 (To_Ada);\n+\n+   procedure To_C\n+     (Item       : Wide_String;\n+      Target     : out char16_array;\n+      Count      : out size_t;\n+      Append_Nul : Boolean := True);\n+   pragma Ada_05 (To_C);\n+\n+   procedure To_Ada\n+     (Item     : char16_array;\n+      Target   : out Wide_String;\n+      Count    : out Natural;\n+      Trim_Nul : Boolean := True);\n+   pragma Ada_05 (To_Ada);\n+\n+   type char32_t is new Wide_Wide_Character;\n+   pragma Ada_05 (char32_t);\n+\n+   char32_nul : constant char32_t := char32_t'Val (0);\n+   pragma Ada_05 (char32_nul);\n+\n+   function To_C (Item : Wide_Wide_Character) return char32_t;\n+   pragma Ada_05 (To_C);\n+\n+   function To_Ada (Item : char32_t) return Wide_Wide_Character;\n+   pragma Ada_05 (To_Ada);\n+\n+   type char32_array is array (size_t range <>) of aliased char32_t;\n+   pragma Ada_05 (char32_array);\n+\n+   function Is_Nul_Terminated (Item : char32_array) return Boolean;\n+   pragma Ada_05 (Is_Nul_Terminated);\n+\n+   function To_C\n+     (Item       : Wide_Wide_String;\n+      Append_Nul : Boolean := True) return char32_array;\n+   pragma Ada_05 (To_C);\n+\n+   function To_Ada\n+     (Item     : char32_array;\n+      Trim_Nul : Boolean := True) return Wide_Wide_String;\n+   pragma Ada_05 (To_Ada);\n+\n+   procedure To_C\n+     (Item       : Wide_Wide_String;\n+      Target     : out char32_array;\n+      Count      : out size_t;\n+      Append_Nul : Boolean := True);\n+   pragma Ada_05 (To_C);\n+\n+   procedure To_Ada\n+     (Item     : char32_array;\n+      Target   : out Wide_Wide_String;\n+      Count    : out Natural;\n+      Trim_Nul : Boolean := True);\n+   pragma Ada_05 (To_Ada);\n+\n end Interfaces.C;"}, {"sha": "7eaa2197b9f7546a95b21186facf7f569a68211a", "filename": "gcc/ada/i-cpp.adb", "status": "modified", "additions": 120, "deletions": 39, "changes": 159, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/82c80734715c801643075ab68c5c9a5e00da1b03/gcc%2Fada%2Fi-cpp.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/82c80734715c801643075ab68c5c9a5e00da1b03/gcc%2Fada%2Fi-cpp.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fi-cpp.adb?ref=82c80734715c801643075ab68c5c9a5e00da1b03", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1992-2004, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2005, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -34,10 +34,33 @@\n with Ada.Tags;                use Ada.Tags;\n with System;                  use System;\n with System.Storage_Elements; use System.Storage_Elements;\n-with Unchecked_Conversion;\n \n package body Interfaces.CPP is\n \n+--  Structure of the Dispatch Table\n+\n+--           +-----------------------+\n+--           |     Offset_To_Top     |\n+--           +-----------------------+\n+--           | Typeinfo_Ptr/TSD_Ptr  |----> Type Specific Data\n+--  Tag ---> +-----------------------+      +-------------------+\n+--           |        table of       |      | inheritance depth |\n+--           :     primitive ops     :      +-------------------+\n+--           |        pointers       |      |   expanded name   |\n+--           +-----------------------+      +-------------------+\n+--                                          |   external tag    |\n+--                                          +-------------------+\n+--                                          |   Hash table link |\n+--                                          +-------------------+\n+--                                          | Remotely Callable |\n+--                                          +-------------------+\n+--                                          | Rec Ctrler offset |\n+--                                          +-------------------+\n+--                                          | table of          |\n+--                                          :   ancestor        :\n+--                                          |      tags         |\n+--                                          +-------------------+\n+\n    --  The declarations below need (extensive) comments ???\n \n    subtype Cstring is String (Positive);\n@@ -57,27 +80,32 @@ package body Interfaces.CPP is\n      Pfn : System.Address;\n    end record;\n \n-   type Type_Specific_Data_Ptr is access all Type_Specific_Data;\n    type Vtable_Entry_Array is array (Positive range <>) of Vtable_Entry;\n \n    type VTable is record\n-      Prims_Ptr : Vtable_Entry_Array (Positive);\n-      TSD       : Type_Specific_Data_Ptr;\n+      --  Offset_To_Top : Integer;\n+      --  Typeinfo_Ptr  : System.Address; -- TSD is currently also here???\n+      Prims_Ptr  : Vtable_Entry_Array (Positive);\n    end record;\n+   --  Note: See comment in a-tags.adb explaining why the components\n+   --        Offset_To_Top and Typeinfo_Ptr have been commented out.\n+   --  -----------------------------------------------------------------------\n+   --  The size of the Prims_Ptr array actually depends on the tagged type to\n+   --  which it applies. For each tagged type, the expander computes the\n+   --  actual array size, allocates the Dispatch_Table record accordingly, and\n+   --  generates code that displaces the base of the record after the\n+   --  Typeinfo_Ptr component. For this reason the first two components have\n+   --  been commented in the previous declaration. The access to these\n+   --  components is done by means of local functions.\n \n-   --------------------------------------------------------\n-   -- Unchecked Conversions for Tag, Vtable_Ptr, and TSD --\n-   --------------------------------------------------------\n-\n-   function To_Type_Specific_Data_Ptr is\n-     new Unchecked_Conversion (Address, Type_Specific_Data_Ptr);\n+   ---------------------------\n+   -- Unchecked Conversions --\n+   ---------------------------\n \n-   function To_Address is\n-     new Unchecked_Conversion (Type_Specific_Data_Ptr, Address);\n+   type Int_Ptr is access Integer;\n \n-   ---------------------------------------------\n-   -- Unchecked Conversions for String Fields --\n-   ---------------------------------------------\n+   function To_Int_Ptr is\n+      new Unchecked_Conversion (System.Address, Int_Ptr);\n \n    function To_Cstring_Ptr is\n      new Unchecked_Conversion (Address, Cstring_Ptr);\n@@ -90,8 +118,20 @@ package body Interfaces.CPP is\n    -----------------------\n \n    function Length (Str : Cstring_Ptr) return Natural;\n-   --  Length of string represented by the given pointer (treating the\n-   --  string as a C-style string, which is Nul terminated).\n+   --  Length of string represented by the given pointer (treating the string\n+   --  as a C-style string, which is Nul terminated).\n+\n+   function Offset_To_Top (T : Vtable_Ptr) return Integer;\n+   --  Returns the current value of the offset_to_top component available in\n+   --  the prologue of the dispatch table.\n+\n+   function Typeinfo_Ptr (T : Vtable_Ptr) return System.Address;\n+   --  Returns the current value of the typeinfo_ptr component available in\n+   --  the prologue of the dispatch table.\n+\n+   pragma Unreferenced (Offset_To_Top);\n+   pragma Unreferenced (Typeinfo_Ptr);\n+   --  These functions will be used for full compatibility with the C++ ABI\n \n    -----------------------\n    -- CPP_CW_Membership --\n@@ -101,9 +141,9 @@ package body Interfaces.CPP is\n      (Obj_Tag : Vtable_Ptr;\n       Typ_Tag : Vtable_Ptr) return Boolean\n    is\n-      Pos : constant Integer := Obj_Tag.TSD.Idepth - Typ_Tag.TSD.Idepth;\n+      Pos : constant Integer := TSD (Obj_Tag).Idepth - TSD (Typ_Tag).Idepth;\n    begin\n-      return Pos >= 0 and then Obj_Tag.TSD.Ancestor_Tags (Pos) = Typ_Tag;\n+      return Pos >= 0 and then TSD (Obj_Tag).Ancestor_Tags (Pos) = Typ_Tag;\n    end CPP_CW_Membership;\n \n    ---------------------------\n@@ -112,7 +152,7 @@ package body Interfaces.CPP is\n \n    function CPP_Get_Expanded_Name (T : Vtable_Ptr) return Address is\n    begin\n-      return To_Address (T.TSD.Expanded_Name);\n+      return To_Address (TSD (T).Expanded_Name);\n    end CPP_Get_Expanded_Name;\n \n    --------------------------\n@@ -121,7 +161,7 @@ package body Interfaces.CPP is\n \n    function CPP_Get_External_Tag (T : Vtable_Ptr) return Address is\n    begin\n-      return To_Address (T.TSD.External_Tag);\n+      return To_Address (TSD (T).External_Tag);\n    end CPP_Get_External_Tag;\n \n    -------------------------------\n@@ -130,7 +170,7 @@ package body Interfaces.CPP is\n \n    function CPP_Get_Inheritance_Depth (T : Vtable_Ptr) return Natural is\n    begin\n-      return T.TSD.Idepth;\n+      return TSD (T).Idepth;\n    end CPP_Get_Inheritance_Depth;\n \n    -------------------------\n@@ -170,8 +210,11 @@ package body Interfaces.CPP is\n    -----------------\n \n    function CPP_Get_TSD  (T : Vtable_Ptr) return Address is\n+      use type System.Storage_Elements.Storage_Offset;\n+      TSD_Ptr : constant Addr_Ptr :=\n+                  To_Addr_Ptr (To_Address (T) - CPP_DT_Typeinfo_Ptr_Size);\n    begin\n-      return To_Address (T.TSD);\n+      return TSD_Ptr.all;\n    end CPP_Get_TSD;\n \n    --------------------\n@@ -198,21 +241,22 @@ package body Interfaces.CPP is\n      (Old_TSD : Address;\n       New_Tag : Vtable_Ptr)\n    is\n-      TSD : constant Type_Specific_Data_Ptr :=\n-              To_Type_Specific_Data_Ptr (Old_TSD);\n+      Old_TSD_Ptr : constant Type_Specific_Data_Ptr :=\n+                      To_Type_Specific_Data_Ptr (Old_TSD);\n \n-      New_TSD : Type_Specific_Data renames New_Tag.TSD.all;\n+      New_TSD_Ptr : constant Type_Specific_Data_Ptr :=\n+                      TSD (New_Tag);\n \n    begin\n-      if TSD /= null then\n-         New_TSD.Idepth := TSD.Idepth + 1;\n-         New_TSD.Ancestor_Tags (1 .. New_TSD.Idepth)\n-           := TSD.Ancestor_Tags (0 .. TSD.Idepth);\n+      if Old_TSD_Ptr /= null then\n+         New_TSD_Ptr.Idepth := Old_TSD_Ptr.Idepth + 1;\n+         New_TSD_Ptr.Ancestor_Tags (1 .. New_TSD_Ptr.Idepth) :=\n+           Old_TSD_Ptr.Ancestor_Tags (0 .. Old_TSD_Ptr.Idepth);\n       else\n-         New_TSD.Idepth := 0;\n+         New_TSD_Ptr.Idepth := 0;\n       end if;\n \n-      New_TSD.Ancestor_Tags (0) := New_Tag;\n+      New_TSD_Ptr.Ancestor_Tags (0) := New_Tag;\n    end CPP_Inherit_TSD;\n \n    ---------------------------\n@@ -221,7 +265,7 @@ package body Interfaces.CPP is\n \n    procedure CPP_Set_Expanded_Name (T : Vtable_Ptr; Value : Address) is\n    begin\n-      T.TSD.Expanded_Name := To_Cstring_Ptr (Value);\n+      TSD (T).Expanded_Name := To_Cstring_Ptr (Value);\n    end CPP_Set_Expanded_Name;\n \n    --------------------------\n@@ -230,7 +274,7 @@ package body Interfaces.CPP is\n \n    procedure CPP_Set_External_Tag (T : Vtable_Ptr; Value : Address) is\n    begin\n-      T.TSD.External_Tag := To_Cstring_Ptr (Value);\n+      TSD (T).External_Tag := To_Cstring_Ptr (Value);\n    end CPP_Set_External_Tag;\n \n    -------------------------------\n@@ -242,7 +286,7 @@ package body Interfaces.CPP is\n       Value : Natural)\n    is\n    begin\n-      T.TSD.Idepth := Value;\n+      TSD (T).Idepth := Value;\n    end CPP_Set_Inheritance_Depth;\n \n    -----------------------------\n@@ -285,8 +329,11 @@ package body Interfaces.CPP is\n    -----------------\n \n    procedure CPP_Set_TSD (T : Vtable_Ptr; Value : Address) is\n+      use type System.Storage_Elements.Storage_Offset;\n+      TSD_Ptr : constant Addr_Ptr :=\n+                  To_Addr_Ptr (To_Address (T) - CPP_DT_Typeinfo_Ptr_Size);\n    begin\n-      T.TSD := To_Type_Specific_Data_Ptr (Value);\n+      TSD_Ptr.all := Value;\n    end CPP_Set_TSD;\n \n    --------------------\n@@ -314,7 +361,7 @@ package body Interfaces.CPP is\n    -------------------\n \n    function Expanded_Name (T : Vtable_Ptr) return String is\n-      Result : constant Cstring_Ptr := T.TSD.Expanded_Name;\n+      Result : constant Cstring_Ptr := TSD (T).Expanded_Name;\n    begin\n       return Result (1 .. Length (Result));\n    end Expanded_Name;\n@@ -324,7 +371,7 @@ package body Interfaces.CPP is\n    ------------------\n \n    function External_Tag (T : Vtable_Ptr) return String is\n-      Result : constant Cstring_Ptr := T.TSD.External_Tag;\n+      Result : constant Cstring_Ptr := TSD (T).External_Tag;\n    begin\n       return Result (1 .. Length (Result));\n    end External_Tag;\n@@ -344,4 +391,38 @@ package body Interfaces.CPP is\n       return Len - 1;\n    end Length;\n \n+   ------------------\n+   -- Offset_To_Top --\n+   ------------------\n+\n+   function Offset_To_Top (T : Vtable_Ptr) return Integer is\n+      use type System.Storage_Elements.Storage_Offset;\n+\n+      TSD_Ptr : constant Int_Ptr\n+        := To_Int_Ptr (To_Address (T) - CPP_DT_Prologue_Size);\n+   begin\n+      return TSD_Ptr.all;\n+   end Offset_To_Top;\n+\n+   ------------------\n+   -- Typeinfo_Ptr --\n+   ------------------\n+\n+   function Typeinfo_Ptr (T : Vtable_Ptr) return System.Address is\n+      use type System.Storage_Elements.Storage_Offset;\n+      TSD_Ptr : constant Addr_Ptr :=\n+                  To_Addr_Ptr (To_Address (T) - CPP_DT_Typeinfo_Ptr_Size);\n+   begin\n+      return TSD_Ptr.all;\n+   end Typeinfo_Ptr;\n+\n+   ---------\n+   -- TSD --\n+   ---------\n+\n+   function TSD (T : Vtable_Ptr) return Type_Specific_Data_Ptr is\n+   begin\n+      return To_Type_Specific_Data_Ptr (CPP_Get_TSD (T));\n+   end TSD;\n+\n end Interfaces.CPP;"}, {"sha": "df39bdb4df0bad8c18fb3c5098923c703e8ab3c2", "filename": "gcc/ada/i-cpp.ads", "status": "modified", "additions": 33, "deletions": 7, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/82c80734715c801643075ab68c5c9a5e00da1b03/gcc%2Fada%2Fi-cpp.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/82c80734715c801643075ab68c5c9a5e00da1b03/gcc%2Fada%2Fi-cpp.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fi-cpp.ads?ref=82c80734715c801643075ab68c5c9a5e00da1b03", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---          Copyright (C) 1992-2004, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2005, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -45,18 +45,25 @@\n \n with System;\n with System.Storage_Elements;\n+with Unchecked_Conversion;\n \n package Interfaces.CPP is\n \n-   package S   renames System;\n-   package SSE renames System.Storage_Elements;\n-\n    type Vtable_Ptr is private;\n \n    function Expanded_Name (T : Vtable_Ptr) return String;\n    function External_Tag  (T : Vtable_Ptr) return String;\n \n private\n+   package S   renames System;\n+   package SSE renames System.Storage_Elements;\n+\n+   type Vtable;\n+   type Vtable_Ptr is access all Vtable;\n+\n+   type Type_Specific_Data;\n+   type Type_Specific_Data_Ptr is access all Type_Specific_Data;\n+\n    --  These subprograms are in the private part. They are never accessed\n    --  directly except from compiler generated code, which has access to\n    --  private components of packages via the Rtsfind interface.\n@@ -98,9 +105,14 @@ private\n \n    CPP_DT_Prologue_Size : constant SSE.Storage_Count :=\n                             SSE.Storage_Count\n-                              (1 * (Standard'Address_Size / S.Storage_Unit));\n+                              (2 * (Standard'Address_Size / S.Storage_Unit));\n    --  Size of the first part of the dispatch table\n \n+   CPP_DT_Typeinfo_Ptr_Size : constant SSE.Storage_Count :=\n+                            SSE.Storage_Count\n+                              (Standard'Address_Size / System.Storage_Unit);\n+   --  Size of the Typeinfo_Ptr field of the Dispatch Table.\n+\n    CPP_DT_Entry_Size : constant SSE.Storage_Count :=\n                          SSE.Storage_Count\n                            (1 * (Standard'Address_Size / S.Storage_Unit));\n@@ -174,8 +186,21 @@ private\n    --  compatible with MI.\n    --  (used for virtual function calls)\n \n-   type Vtable;\n-   type Vtable_Ptr is access all Vtable;\n+   function TSD (T : Vtable_Ptr) return Type_Specific_Data_Ptr;\n+   --  This function is conceptually equivalent to Get_TSD, but\n+   --  returning a Type_Specific_Data_Ptr type (rather than an Address)\n+   --  simplifies the implementation of the other subprograms.\n+\n+   type Addr_Ptr is access System.Address;\n+\n+   function To_Address is\n+     new Unchecked_Conversion (Vtable_Ptr, System.Address);\n+\n+   function To_Addr_Ptr is\n+      new Unchecked_Conversion (System.Address, Addr_Ptr);\n+\n+   function To_Type_Specific_Data_Ptr is\n+     new Unchecked_Conversion (System.Address, Type_Specific_Data_Ptr);\n \n    pragma Inline (CPP_Set_Prim_Op_Address);\n    pragma Inline (CPP_Get_Prim_Op_Address);\n@@ -192,5 +217,6 @@ private\n    pragma Inline (CPP_Set_Remotely_Callable);\n    pragma Inline (CPP_Get_Remotely_Callable);\n    pragma Inline (Displaced_This);\n+   pragma Inline (TSD);\n \n end Interfaces.CPP;"}, {"sha": "2202ac3a14ec2188b1ca6bbd20078103d656d84b", "filename": "gcc/ada/impunit.adb", "status": "modified", "additions": 145, "deletions": 41, "changes": 186, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/82c80734715c801643075ab68c5c9a5e00da1b03/gcc%2Fada%2Fimpunit.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/82c80734715c801643075ab68c5c9a5e00da1b03/gcc%2Fada%2Fimpunit.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fimpunit.adb?ref=82c80734715c801643075ab68c5c9a5e00da1b03", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---           Copyright (C) 2000-2004 Free Software Foundation, Inc.         --\n+--           Copyright (C) 2000-2005 Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -26,25 +26,29 @@\n \n with Lib;   use Lib;\n with Namet; use Namet;\n-with Opt;   use Opt;\n \n package body Impunit is\n \n    subtype File_Name_8 is String (1 .. 8);\n    type File_List is array (Nat range <>) of File_Name_8;\n \n-   --  The following is a giant string containing the concenated names\n-   --  of all non-implementation internal files, i.e. the complete list\n-   --  of files for internal units which a program may legitimately WITH.\n+   ------------------\n+   -- Ada 95 Units --\n+   ------------------\n \n-   --  Note that this list should match the list of units documented in\n-   --  the \"GNAT Library\" section of the GNAT Reference Manual.\n+   --  The following is a giant string list containing the names of all\n+   --  non-implementation internal files, i.e. the complete list of files for\n+   --  internal units which a program may legitimately WITH when operating in\n+   --  either Ada 95 or Ada 05 mode.\n \n-   Non_Imp_File_Names : constant File_List := (\n+   --  Note that this list should match the list of units documented in the\n+   --  \"GNAT Library\" section of the GNAT Reference Manual.\n \n-   -----------------------------------------------\n-   -- Ada Hierarchy Units from Reference Manual --\n-   -----------------------------------------------\n+   Non_Imp_File_Names_95 : constant File_List := (\n+\n+   ------------------------------------------------------\n+   -- Ada Hierarchy Units from Ada-83 Reference Manual --\n+   ------------------------------------------------------\n \n      \"a-astaco\",    -- Ada.Asynchronous_Task_Control\n      \"a-calend\",    -- Ada.Calendar\n@@ -53,7 +57,6 @@ package body Impunit is\n      \"a-chlat1\",    -- Ada.Characters.Latin_1\n      \"a-comlin\",    -- Ada.Command_Line\n      \"a-decima\",    -- Ada.Decimal\n-     \"a-direct\",    -- Ada.Directories\n      \"a-direio\",    -- Ada.Direct_IO\n      \"a-dynpri\",    -- Ada.Dynamic_Priorities\n      \"a-except\",    -- Ada.Exceptions\n@@ -144,6 +147,7 @@ package body Impunit is\n      \"a-cwila9\",    -- Ada.Characters.Wide_Latin_9\n      \"a-diocst\",    -- Ada.Direct_IO.C_Streams\n      \"a-einuoc\",    -- Ada.Exceptions.Is_Null_Occurrence\n+     \"a-elchha\",    -- Ada.Exceptions.Last_Chance_Handler\n      \"a-exctra\",    -- Ada.Exceptions.Traceback\n      \"a-siocst\",    -- Ada.Sequential_IO.C_Streams\n      \"a-ssicst\",    -- Ada.Streams.Stream_IO.C_Streams\n@@ -305,32 +309,126 @@ package body Impunit is\n      \"s-wchcnv\",    -- System.Wch_Cnv\n      \"s-wchcon\");   -- System.Wch_Con\n \n-   -------------------------\n-   -- Implementation_Unit --\n-   -------------------------\n+   --------------------\n+   -- Ada 2005 Units --\n+   --------------------\n+\n+   --  The following units should be used only in Ada 05 mode\n+\n+   Non_Imp_File_Names_05 : constant File_List := (\n+\n+   --------------------------------------------------------\n+   -- Ada Hierarchy Units from Ada 2005 Reference Manual --\n+   --------------------------------------------------------\n+\n+     \"a-cdlili\",    -- Ada.Containers.Doubly_Linked_Lists\n+     \"a-cgaaso\",    -- Ada.Containers.Generic_Anonymous_Array_Sort\n+     \"a-cgarso\",    -- Ada.Containers.Generic_Array_Sort\n+     \"a-cgcaso\",    -- Ada.Containers.Generic_Constrained_Array_Sort\n+     \"a-chtgke\",    -- Ada.Containers.Hash_Tables.Generic_Keys\n+     \"a-chtgop\",    -- Ada.Containers.Hash_Tables.Generic_Operations\n+     \"a-cidlli\",    -- Ada.Containers.Indefinite_Doubly_Linked_Lists\n+     \"a-cihama\",    -- Ada.Containers.Indefinite_Hashed_Maps\n+     \"a-cihase\",    -- Ada.Containers.Indefinite_Hashed_Sets\n+     \"a-ciorma\",    -- Ada.Containers.Indefinite_Ordered_Maps\n+     \"a-ciormu\",    -- Ada.Containers.Indefinite_Ordered_Multisets\n+     \"a-ciorse\",    -- Ada.Containers.Indefinite_Ordered_Sets\n+     \"a-cohama\",    -- Ada.Containers.Hashed_Maps\n+     \"a-cohase\",    -- Ada.Containers.Hashed_Sets\n+     \"a-cohata\",    -- Ada.Containers.Hash_Tables\n+     \"a-coinve\",    -- Ada.Containers.Indefinite_Vectors\n+     \"a-contai\",    -- Ada.Containers\n+     \"a-convec\",    -- Ada.Containers.Vectors\n+     \"a-coorma\",    -- Ada.Containers.Ordered_Maps\n+     \"a-coormu\",    -- Ada.Containers.Ordered_Multisets\n+     \"a-coorse\",    -- Ada.Containers.Ordered_Sets\n+     \"a-coprnu\",    -- Ada.Containers.Prime_Numbers\n+     \"a-crbltr\",    -- Ada.Containers.Red_Black_Trees\n+     \"a-crbtgk\",    -- Ada.Containers.Red_Black_Trees.Generic_Keys\n+     \"a-crbtgo\",    -- Ada.Containers.Red_Black_Trees.Generic_Operations\n+     \"a-direct\",    -- Ada.Directories\n+     \"a-rbtgso\",    -- Ada.Containers.Red_Black_Trees.Generic_Set_Operations\n+     \"a-secain\",    -- Ada.Strings.Equal_Case_Insensitive\n+     \"a-shcain\",    -- Ada.Strings.Hash_Case_Insensitive\n+     \"a-slcain\",    -- Ada.Strings.Less_Case_Insensitive\n+     \"a-strhas\",    -- Ada.Strings.Hash\n+     \"a-stunha\",    -- Ada.Strings.Unbounded.Hash\n+     \"a-stwiha\",    -- Ada.Strings.Wide_Hash\n+     \"a-stzbou\",    -- Ada.Strings.Wide_Wide_Bounded\n+     \"a-stzfix\",    -- Ada.Strings.Wide_Wide_Fixed\n+     \"a-stzhas\",    -- Ada.Strings.Wide_Wide_Hash\n+     \"a-stzmap\",    -- Ada.Strings.Wide_Wide_Maps\n+     \"a-stzunb\",    -- Ada.Strings.Wide_Wide_Unbounded\n+     \"a-swunha\",    -- Ada.Strings.Wide_Unbounded.Hash\n+     \"a-szmzco\",    -- Ada.Strings.Wide_Wide_Maps.Wide_Wide_Constants;\n+     \"a-szunha\",    -- Ada.Strings.Wide_Wide_Unbounded.Hash\n+     \"a-tiunio\",    -- Ada.Text_IO.Unbounded_IO;\n+     \"a-wwunio\",    -- Ada.Wide_Text_IO.Wide_Unbounded_IO;\n+     \"a-zttest\",    -- Ada.Wide_Wide_Text_IO.Text_Streams\n+     \"a-ztexio\",    -- Ada.Wide_Wide_Text_IO\n+     \"a-zzunio\",    -- Ada.Wide_Wide_Text_IO.Wide_Wide_Unbounded_IO\n+\n+   ------------------------------------------------------\n+   -- RM Required Additions to Ada 2005 for GNAT Types --\n+   ------------------------------------------------------\n+\n+     \"a-lfztio\",    -- Ada.Long_Float_Wide_Wide_Text_IO\n+     \"a-liztio\",    -- Ada.Long_Integer_Wide_Wide_Text_IO\n+     \"a-llfzti\",    -- Ada.Long_Long_Float_Wide_Wide_Text_IO\n+     \"a-llizti\",    -- Ada.Long_Long_Integer_Wide_Wide_Text_IO\n+     \"a-sfztio\",    -- Ada.Short_Float_Wide_Wide_Text_IO\n+     \"a-siztio\",    -- Ada.Short_Integer_Wide_Wide_Text_IO\n+     \"a-ssizti\",    -- Ada.Short_Short_Integer_Wide_Wide_Text_IO\n+     \"a-ztcstr\",    -- Ada.Wide_Wide_Text_IO.C_Streams\n+\n+   ----------------------------------------\n+   -- GNAT Defined Additions to Ada 2005 --\n+   ----------------------------------------\n+\n+     \"a-chzla1\",    -- Ada.Characters.Wide_Wide_Latin_1\n+     \"a-chzla9\",    -- Ada.Characters.Wide_Wide_Latin_9\n+     \"a-szuzti\",    -- Ada.Strings.Wide_Wide_Unbounded.Wide_Wide_Text_IO\n \n-   function Implementation_Unit (U : Unit_Number_Type) return Boolean is\n-      Fname : constant File_Name_Type := Unit_File_Name (U);\n+   ---------------------------\n+   -- GNAT Special IO Units --\n+   ---------------------------\n \n-   begin\n-      --  All units are OK in GNAT mode\n+   --  See Ada 95 section for further information. These packages are for the\n+   --  implementation of the Wide_Wide_Text_IO generic packages.\n \n-      if GNAT_Mode then\n-         return False;\n-      end if;\n+     \"a-ztdeio\",    -- Ada.Wide_Wide_Text_IO.Decimal_IO\n+     \"a-ztenio\",    -- Ada.Wide_Wide_Text_IO.Enumeration_IO\n+     \"a-ztfiio\",    -- Ada.Wide_Wide_Text_IO.Fixed_IO\n+     \"a-ztflio\",    -- Ada.Wide_Wide_Text_IO.Float_IO\n+     \"a-ztinio\",    -- Ada.Wide_Wide_Text_IO.Integer_IO\n+     \"a-ztmoio\",    -- Ada.Wide_Wide_Text_IO.Modular_IO\n \n-      --  If length of file name is greater than 12, definitely OK!\n+   ------------------------\n+   -- GNAT Library Units --\n+   ------------------------\n+\n+     \"g-zstspl\");   -- GNAT.Wide_Wide_String_Split\n+\n+   ----------------------\n+   -- Get_Kind_Of_Unit --\n+   ----------------------\n+\n+   function Get_Kind_Of_Unit (U : Unit_Number_Type) return Kind_Of_Unit is\n+      Fname : constant File_Name_Type := Unit_File_Name (U);\n+\n+   begin\n+      --  If length of file name is greater than 12, not predefined.\n       --  The value 12 here is an 8 char name with extension .ads.\n \n       if Length_Of_Name (Fname) > 12 then\n-         return False;\n+         return Not_Predefined_Unit;\n       end if;\n \n       --  Otherwise test file name\n \n       Get_Name_String (Fname);\n \n-      --  Definitely OK if file name does not start with a- g- s- i-\n+      --  Not predefined if file name does not start with a- g- s- i-\n \n       if Name_Len < 3\n         or else Name_Buffer (2) /= '-'\n@@ -342,14 +440,14 @@ package body Impunit is\n                    and then\n                  Name_Buffer (1) /= 's')\n       then\n-         return False;\n+         return Not_Predefined_Unit;\n       end if;\n \n-      --  Definitely OK if file name does not end in .ads. This can\n+      --  Not predefined if file name does not end in .ads. This can\n       --  happen when non-standard file names are being used.\n \n       if Name_Buffer (Name_Len - 3 .. Name_Len) /= \".ads\" then\n-         return False;\n+         return Not_Predefined_Unit;\n       end if;\n \n       --  Otherwise normalize file name to 8 characters\n@@ -360,42 +458,48 @@ package body Impunit is\n          Name_Buffer (Name_Len) := ' ';\n       end loop;\n \n-      --  Definitely OK if name is in list\n+      --  See if name is in 95 list\n \n-      for J in Non_Imp_File_Names'Range loop\n-         if Name_Buffer (1 .. 8) = Non_Imp_File_Names (J) then\n-            return False;\n+      for J in Non_Imp_File_Names_95'Range loop\n+         if Name_Buffer (1 .. 8) = Non_Imp_File_Names_95 (J) then\n+            return Ada_95_Unit;\n          end if;\n       end loop;\n \n-      --  Only remaining special possibilities are children of\n-      --  System.RPC and System.Garlic and special files of the\n-      --  form System.Aux...\n+      --  See if name is in 05 list\n+\n+      for J in Non_Imp_File_Names_05'Range loop\n+         if Name_Buffer (1 .. 8) = Non_Imp_File_Names_05 (J) then\n+            return Ada_05_Unit;\n+         end if;\n+      end loop;\n+\n+      --  Only remaining special possibilities are children of System.RPC and\n+      --  System.Garlic and special files of the form System.Aux...\n \n       Get_Name_String (Unit_Name (U));\n \n       if Name_Len > 12\n         and then Name_Buffer (1 .. 11) = \"system.rpc.\"\n       then\n-         return False;\n+         return Ada_95_Unit;\n       end if;\n \n       if Name_Len > 15\n         and then Name_Buffer (1 .. 14) = \"system.garlic.\"\n       then\n-         return False;\n+         return Ada_95_Unit;\n       end if;\n \n       if Name_Len > 11\n         and then Name_Buffer (1 .. 10) = \"system.aux\"\n       then\n-         return False;\n+         return Ada_95_Unit;\n       end if;\n \n       --  All tests failed, this is definitely an implementation unit\n \n-      return True;\n-\n-   end Implementation_Unit;\n+      return Implementation_Unit;\n+   end Get_Kind_Of_Unit;\n \n end Impunit;"}, {"sha": "075772b7323b90de6492d23c538620d86f1a898c", "filename": "gcc/ada/impunit.ads", "status": "modified", "additions": 27, "deletions": 8, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/82c80734715c801643075ab68c5c9a5e00da1b03/gcc%2Fada%2Fimpunit.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/82c80734715c801643075ab68c5c9a5e00da1b03/gcc%2Fada%2Fimpunit.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fimpunit.ads?ref=82c80734715c801643075ab68c5c9a5e00da1b03", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---             Copyright (C) 2000 Free Software Foundation, Inc.            --\n+--          Copyright (C) 2000-2005 Free Software Foundation, Inc.          --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -26,17 +26,36 @@\n \n --  This package contains data and functions used to determine if a given\n --  unit is an internal unit intended only for use by the implementation\n---  and which should not be directly WITH'ed by user code.\n+--  and which should not be directly WITH'ed by user code. It also checks\n+--  for Ada 05 units that should only be WITH'ed in Ada 05 mode.\n \n with Types; use Types;\n \n package Impunit is\n \n-   function Implementation_Unit (U : Unit_Number_Type) return Boolean;\n-   --  Given the unit number of a unit, this function determines if it is a\n-   --  unit that is intended to be used only internally by the implementation.\n-   --  This is used for posting warnings for improper WITH's of such units\n-   --  (such WITH's are allowed without warnings only in GNAT_Mode set by\n-   --  the use of -gnatg). True is returned if a warning should be posted.\n+   type Kind_Of_Unit is\n+     (Implementation_Unit,\n+      --  Unit from predefined library intended to be used only by the\n+      --  compiler generated code, or from the implementation of the run time.\n+      --  Use of such a unit generates a warning unless the client is compiled\n+      --  with the -gnatg switch. If we are being super strict, this should be\n+      --  an error for the case of Ada units, but that seems over strenuous.\n+\n+      Not_Predefined_Unit,\n+      --  This is not a predefined unit, so no checks are needed\n+\n+      Ada_95_Unit,\n+      --  This unit is defined in the Ada 95 RM, and can be freely with'ed\n+      --  in both Ada 95 mode and Ada 05 mode. Note that in Ada 83 mode, no\n+      --  child units are allowed, so you can't even name such a unit.\n+\n+      Ada_05_Unit);\n+   --  This unit is defined in the Ada 05 RM. Withing this unit from a\n+   --  Ada 95 mode program will generate a warning (again, strictly speaking\n+   --  this should be an error, but that seems over-strenuous).\n+\n+   function Get_Kind_Of_Unit (U : Unit_Number_Type) return Kind_Of_Unit;\n+   --  Given the unit number of a unit, this function determines the type\n+   --  of the unit, as defined above.\n \n end Impunit;"}, {"sha": "a325063d2f5a3d610dbedc4635635dd1e433785e", "filename": "gcc/ada/krunch.adb", "status": "modified", "additions": 31, "deletions": 2, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/82c80734715c801643075ab68c5c9a5e00da1b03/gcc%2Fada%2Fkrunch.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/82c80734715c801643075ab68c5c9a5e00da1b03/gcc%2Fada%2Fkrunch.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fkrunch.adb?ref=82c80734715c801643075ab68c5c9a5e00da1b03", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1992-2000 Free Software Foundation, Inc.          --\n+--          Copyright (C) 1992-2005 Free Software Foundation, Inc.          --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -44,6 +44,7 @@ is\n    Krlen    : Natural;\n    Num_Seps : Natural;\n    Startloc : Natural;\n+   J        : Natural;\n \n begin\n    --  Deal with special predefined children cases. Startloc is the first\n@@ -64,6 +65,15 @@ begin\n       Curlen := Len - 12;\n       Krlen  := 8;\n \n+   elsif Len >= 23\n+     and then Buffer (1 .. 22) = \"ada-wide_wide_text_io-\"\n+   then\n+      Startloc := 3;\n+      Buffer (2 .. 5) := \"-zt-\";\n+      Buffer (6 .. Len - 17) := Buffer (23 .. Len);\n+      Curlen := Len - 17;\n+      Krlen := 8;\n+\n    elsif Len >= 4 and then Buffer (1 .. 4) = \"ada-\" then\n       Startloc := 3;\n       Buffer (2 .. Len - 2) := Buffer (4 .. Len);\n@@ -138,6 +148,26 @@ begin\n       return;\n    end if;\n \n+   --  If string contains Wide_Wide, replace by a single z\n+\n+   J := Startloc;\n+   while J <= Curlen - 8 loop\n+      if Buffer (J .. J + 8) = \"wide_wide\"\n+        and then (J = Startloc\n+                    or else Buffer (J - 1) = '-'\n+                    or else Buffer (J - 1) = '_')\n+        and then (J + 8 = Curlen\n+                    or else Buffer (J + 9) = '-'\n+                    or else Buffer (J + 9) = '_')\n+      then\n+         Buffer (J) := 'z';\n+         Buffer (J + 1 .. Curlen - 8) := Buffer (J + 9 .. Curlen);\n+         Curlen := Curlen - 8;\n+      end if;\n+\n+      J := J + 1;\n+   end loop;\n+\n    --  For now, refuse to krunch a name that contains an ESC character (wide\n    --  character sequence) since it's too much trouble to do this right ???\n \n@@ -152,7 +182,6 @@ begin\n    --  the krunching process, and then we eliminate them as the last step\n \n    Num_Seps := 0;\n-\n    for J in Startloc .. Curlen loop\n       if Buffer (J) = '-' or else Buffer (J) = '_' then\n          Buffer (J) := ' ';"}, {"sha": "f4637fbc78853b29bfa7e24615320d0f8782e121", "filename": "gcc/ada/krunch.ads", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/82c80734715c801643075ab68c5c9a5e00da1b03/gcc%2Fada%2Fkrunch.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/82c80734715c801643075ab68c5c9a5e00da1b03/gcc%2Fada%2Fkrunch.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fkrunch.ads?ref=82c80734715c801643075ab68c5c9a5e00da1b03", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---          Copyright (C) 1992-1997 Free Software Foundation, Inc.          --\n+--          Copyright (C) 1992-2005 Free Software Foundation, Inc.          --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -111,7 +111,12 @@\n \n --    a-wtflio\n \n---  This is the only irregularity required (so far!) to keep the file names\n+--  More problems arise with Wide_Wide, so we replace this sequence by\n+--  a z (which is not used much) and also (as in the Wide_Text_IO case),\n+--  we replace the prefix ada.wide_wide_text_io- by a-zt- and then\n+--  the normal crunching rules are applied.\n+\n+--  These are the only irregularity required (so far!) to keep the file names\n --  unique in the standard predefined libraries.\n \n procedure Krunch"}, {"sha": "5afc12bf13f185812c596162343b86dd7acaf4f7", "filename": "gcc/ada/lib-xref.adb", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/82c80734715c801643075ab68c5c9a5e00da1b03/gcc%2Fada%2Flib-xref.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/82c80734715c801643075ab68c5c9a5e00da1b03/gcc%2Fada%2Flib-xref.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flib-xref.adb?ref=82c80734715c801643075ab68c5c9a5e00da1b03", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1998-2004, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1998-2005, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -261,10 +261,18 @@ package body Lib.Xref is\n    begin\n       pragma Assert (Nkind (E) in N_Entity);\n \n+      --  Check for obsolescent reference to ASCII\n+\n       if E = Standard_ASCII then\n          Check_Restriction (No_Obsolescent_Features, N);\n       end if;\n \n+      --  Warn if reference to Ada 2005 entity not in Ada 2005 mode\n+\n+      if Is_Ada_2005 (E) and then Ada_Version < Ada_05 then\n+         Error_Msg_NE (\"& is only defined in Ada 2005?\", N, E);\n+      end if;\n+\n       --  Never collect references if not in main source unit. However,\n       --  we omit this test if Typ is 'e' or 'k', since these entries are\n       --  really structural, and it is useful to have them in units"}, {"sha": "03ca2d0ee96be79ffd903f8af08783fb43cf0cc6", "filename": "gcc/ada/mlib-prj.adb", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/82c80734715c801643075ab68c5c9a5e00da1b03/gcc%2Fada%2Fmlib-prj.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/82c80734715c801643075ab68c5c9a5e00da1b03/gcc%2Fada%2Fmlib-prj.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fmlib-prj.adb?ref=82c80734715c801643075ab68c5c9a5e00da1b03", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---              Copyright (C) 2001-2004, Ada Core Technologies, Inc.        --\n+--              Copyright (C) 2001-2005, Ada Core Technologies, Inc.        --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -1419,30 +1419,30 @@ package body MLib.Prj is\n             Data := Projects.Table (For_Project);\n \n             declare\n-               Interface : String_List_Id := Data.Lib_Interface_ALIs;\n-               ALI       : File_Name_Type;\n+               Iface : String_List_Id := Data.Lib_Interface_ALIs;\n+               ALI   : File_Name_Type;\n \n             begin\n-               while Interface /= Nil_String loop\n-                  ALI := String_Elements.Table (Interface).Value;\n+               while Iface /= Nil_String loop\n+                  ALI := String_Elements.Table (Iface).Value;\n                   Interface_ALIs.Set (ALI, True);\n-                  Get_Name_String (String_Elements.Table (Interface).Value);\n+                  Get_Name_String (String_Elements.Table (Iface).Value);\n                   Add_Argument (Name_Buffer (1 .. Name_Len));\n-                  Interface := String_Elements.Table (Interface).Next;\n+                  Iface := String_Elements.Table (Iface).Next;\n                end loop;\n \n-               Interface := Data.Lib_Interface_ALIs;\n+               Iface := Data.Lib_Interface_ALIs;\n \n                if not Opt.Quiet_Output then\n \n                   --  Check that the interface set is complete: any unit in the\n                   --  library that is needed by an interface should also be an\n                   --  interface. If it is not the case, output a warning.\n \n-                  while Interface /= Nil_String loop\n-                     ALI := String_Elements.Table (Interface).Value;\n+                  while Iface /= Nil_String loop\n+                     ALI := String_Elements.Table (Iface).Value;\n                      Process (ALI);\n-                     Interface := String_Elements.Table (Interface).Next;\n+                     Iface := String_Elements.Table (Iface).Next;\n                   end loop;\n                end if;\n             end;"}, {"sha": "65efb4c65a7910b1ee003a5502fff363c694f664", "filename": "gcc/ada/mlib.adb", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/82c80734715c801643075ab68c5c9a5e00da1b03/gcc%2Fada%2Fmlib.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/82c80734715c801643075ab68c5c9a5e00da1b03/gcc%2Fada%2Fmlib.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fmlib.adb?ref=82c80734715c801643075ab68c5c9a5e00da1b03", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---           Copyright (C) 1999-2004, Ada Core Technologies, Inc.           --\n+--           Copyright (C) 1999-2005, Ada Core Technologies, Inc.           --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -101,9 +101,9 @@ package body MLib is\n       To         : Name_Id;\n       Interfaces : String_List)\n    is\n-      Success   : Boolean := False;\n-      To_Dir    : constant String := Get_Name_String (To);\n-      Interface : Boolean := False;\n+      Success      : Boolean := False;\n+      To_Dir       : constant String := Get_Name_String (To);\n+      Is_Interface : Boolean := False;\n \n       procedure Verbose_Copy (Index : Positive);\n       --  In verbose mode, output a message that the indexed file is copied\n@@ -154,11 +154,11 @@ package body MLib is\n \n                --  Check if this is one of the interface ALIs\n \n-               Interface := False;\n+               Is_Interface := False;\n \n                for Index in Interfaces'Range loop\n                   if File_Name = Interfaces (Index).all then\n-                     Interface := True;\n+                     Is_Interface := True;\n                      exit;\n                   end if;\n                end loop;\n@@ -167,7 +167,7 @@ package body MLib is\n                --  the interface indication at the end of the P line.\n                --  Do not copy ALI files that are not Interfaces.\n \n-               if Interface then\n+               if Is_Interface then\n                   Success := False;\n                   Verbose_Copy (Index);\n "}, {"sha": "d462d1152e533fb22debc7c1f93cd4706e965e86", "filename": "gcc/ada/namet.adb", "status": "modified", "additions": 60, "deletions": 19, "changes": 79, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/82c80734715c801643075ab68c5c9a5e00da1b03/gcc%2Fada%2Fnamet.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/82c80734715c801643075ab68c5c9a5e00da1b03/gcc%2Fada%2Fnamet.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fnamet.adb?ref=82c80734715c801643075ab68c5c9a5e00da1b03", "patch": "@@ -273,9 +273,9 @@ package body Namet is\n \n          procedure Copy_One_Character;\n          --  Copy a character from Name_Buffer to New_Buf. Includes case\n-         --  of copying a Uhh or Whhhh sequence and decoding it.\n+         --  of copying a Uhh,Whhhh,WWhhhhhhhh sequence and decoding it.\n \n-         function Hex (N : Natural) return Natural;\n+         function Hex (N : Natural) return Word;\n          --  Scans past N digits using Old pointer and returns hex value\n \n          procedure Insert_Character (C : Character);\n@@ -301,6 +301,15 @@ package body Namet is\n                Old := Old + 1;\n                Insert_Character (Character'Val (Hex (2)));\n \n+            --  WW (wide wide character insertion)\n+\n+            elsif C = 'W'\n+              and then Old < Name_Len\n+              and then Name_Buffer (Old + 1) = 'W'\n+            then\n+               Old := Old + 2;\n+               Widechar.Set_Wide (Char_Code (Hex (8)), New_Buf, New_Len);\n+\n             --  W (wide character insertion)\n \n             elsif C = 'W'\n@@ -323,8 +332,8 @@ package body Namet is\n          -- Hex --\n          ---------\n \n-         function Hex (N : Natural) return Natural is\n-            T : Natural := 0;\n+         function Hex (N : Natural) return Word is\n+            T : Word := 0;\n             C : Character;\n \n          begin\n@@ -492,7 +501,7 @@ package body Namet is\n       elsif Name_Buffer (1) = 'Q' then\n          Get_Decoded_Name_String (Id);\n \n-      --  Only remaining issue is U/W sequences\n+      --  Only remaining issue is U/W/WW sequences\n \n       else\n          Get_Name_String (Id);\n@@ -502,6 +511,8 @@ package body Namet is\n             if Name_Buffer (P + 1) in 'A' .. 'Z' then\n                P := P + 1;\n \n+            --  Uhh encoding\n+\n             elsif Name_Buffer (P) = 'U' then\n                for J in reverse P + 3 .. P + Name_Len loop\n                   Name_Buffer (J + 3) := Name_Buffer (J);\n@@ -516,22 +527,38 @@ package body Namet is\n                Name_Buffer (P + 5) := ']';\n                P := P + 6;\n \n+            --  WWhhhhhhhh encoding\n+\n+            elsif Name_Buffer (P) = 'W'\n+              and then P + 9 <= Name_Len\n+              and then Name_Buffer (P + 1) = 'W'\n+              and then Name_Buffer (P + 2) not in 'A' .. 'Z'\n+              and then Name_Buffer (P + 2) /= '_'\n+            then\n+               Name_Buffer (P + 12 .. Name_Len + 2) :=\n+                 Name_Buffer (P + 10 .. Name_Len);\n+               Name_Buffer (P)     := '[';\n+               Name_Buffer (P + 1) := '\"';\n+               Name_Buffer (P + 10) := '\"';\n+               Name_Buffer (P + 11) := ']';\n+               Name_Len := Name_Len + 2;\n+               P := P + 12;\n+\n+            --  Whhhh encoding\n+\n             elsif Name_Buffer (P) = 'W'\n               and then P < Name_Len\n               and then Name_Buffer (P + 1) not in 'A' .. 'Z'\n               and then Name_Buffer (P + 1) /= '_'\n             then\n-               Name_Buffer (P + 8 .. P + Name_Len + 5) :=\n+               Name_Buffer (P + 8 .. P + Name_Len + 3) :=\n                  Name_Buffer (P + 5 .. Name_Len);\n-               Name_Buffer (P + 5) := Name_Buffer (P + 4);\n-               Name_Buffer (P + 4) := Name_Buffer (P + 3);\n-               Name_Buffer (P + 3) := Name_Buffer (P + 2);\n-               Name_Buffer (P + 2) := Name_Buffer (P + 1);\n+               Name_Buffer (P + 2 .. P + 5) := Name_Buffer (P + 1 .. P + 4);\n                Name_Buffer (P)     := '[';\n                Name_Buffer (P + 1) := '\"';\n                Name_Buffer (P + 6) := '\"';\n                Name_Buffer (P + 7) := ']';\n-               Name_Len := Name_Len + 5;\n+               Name_Len := Name_Len + 3;\n                P := P + 8;\n \n             else\n@@ -1135,19 +1162,25 @@ package body Namet is\n \n    procedure Store_Encoded_Character (C : Char_Code) is\n \n-      procedure Set_Hex_Chars (N : Natural);\n+      procedure Set_Hex_Chars (C : Char_Code);\n       --  Stores given value, which is in the range 0 .. 255, as two hex\n-      --  digits (using lower case a-f) in Name_Buffer, incrementing Name_Len\n+      --  digits (using lower case a-f) in Name_Buffer, incrementing Name_Len.\n \n-      procedure Set_Hex_Chars (N : Natural) is\n-         Hexd : constant String := \"0123456789abcdef\";\n+      -------------------\n+      -- Set_Hex_Chars --\n+      -------------------\n \n+      procedure Set_Hex_Chars (C : Char_Code) is\n+         Hexd : constant String := \"0123456789abcdef\";\n+         N    : constant Natural := Natural (C);\n       begin\n          Name_Buffer (Name_Len + 1) := Hexd (N / 16 + 1);\n          Name_Buffer (Name_Len + 2) := Hexd (N mod 16 + 1);\n          Name_Len := Name_Len + 2;\n       end Set_Hex_Chars;\n \n+   --  Start of processing for Store_Encoded_Character\n+\n    begin\n       Name_Len := Name_Len + 1;\n \n@@ -1159,16 +1192,24 @@ package body Namet is\n                Name_Buffer (Name_Len) := CC;\n             else\n                Name_Buffer (Name_Len) := 'U';\n-               Set_Hex_Chars (Natural (C));\n+               Set_Hex_Chars (C);\n             end if;\n          end;\n \n+      elsif In_Wide_Character_Range (C) then\n+         Name_Buffer (Name_Len) := 'W';\n+         Set_Hex_Chars (C / 256);\n+         Set_Hex_Chars (C mod 256);\n+\n       else\n          Name_Buffer (Name_Len) := 'W';\n-         Set_Hex_Chars (Natural (C) / 256);\n-         Set_Hex_Chars (Natural (C) mod 256);\n+         Name_Len := Name_Len + 1;\n+         Name_Buffer (Name_Len) := 'W';\n+         Set_Hex_Chars (C / 2 ** 24);\n+         Set_Hex_Chars ((C / 2 ** 16) mod 256);\n+         Set_Hex_Chars ((C / 256) mod 256);\n+         Set_Hex_Chars (C mod 256);\n       end if;\n-\n    end Store_Encoded_Character;\n \n    --------------------------------------"}, {"sha": "3a3e5e037484abdac63adf81100f87cf71264a9d", "filename": "gcc/ada/namet.ads", "status": "modified", "additions": 37, "deletions": 34, "changes": 71, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/82c80734715c801643075ab68c5c9a5e00da1b03/gcc%2Fada%2Fnamet.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/82c80734715c801643075ab68c5c9a5e00da1b03/gcc%2Fada%2Fnamet.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fnamet.ads?ref=82c80734715c801643075ab68c5c9a5e00da1b03", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---          Copyright (C) 1992-2004 Free Software Foundation, Inc.          --\n+--          Copyright (C) 1992-2005 Free Software Foundation, Inc.          --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -48,17 +48,18 @@ package Namet is\n \n --  The forms of the entries are as follows:\n \n---    Identifiers        Stored with upper case letters folded to lower case.\n---                       Upper half (16#80# bit set) and wide characters are\n---                       stored in an encoded form (Uhh for upper half and\n---                       Whhhh for wide characters, as provided by the routine\n---                       Store_Encoded_Character, where hh are hex digits for\n---                       the character code using lower case a-f). Normally\n---                       the use of U or W in other internal names is avoided,\n---                       but these letters may be used in internal names\n---                       (without this special meaning), if the appear as\n---                       the last character of the name, or they are followed\n---                       by an upper case letter or an underscore.\n+--    Identifiers Stored with upper case letters folded to lower case. Upper\n+--                       half (16#80# bit set) and wide characters are stored\n+--                       in an encoded form (Uhh for upper half char, Whhhh\n+--                       for wide characters, WWhhhhhhhh as provided by the\n+--                       routine Store_Encoded_Character, where hh are hex\n+--                       digits for the character code using lower case a-f).\n+--                       Normally the use of U or W in other internal names is\n+--                       avoided, but these letters may be used in internal\n+--                       names (without this special meaning), if they appear\n+--                       as the last character of the name, or they are\n+--                       followed by an upper case letter (other than the WW\n+--                       sequence), or an underscore.\n \n \n --    Operator symbols   Stored with an initial letter O, and the remainder\n@@ -73,7 +74,7 @@ package Namet is\n --    Character literals Character literals have names that are used only for\n --                       debugging and error message purposes. The form is a\n --                       upper case Q followed by a single lower case letter,\n---                       or by a Uxx or Wxxxx encoding as described for\n+--                       or by a Uxx/Wxxxx/WWxxxxxxx encoding as described for\n --                       identifiers. The Set_Character_Literal_Name procedure\n --                       should be used to construct these encodings. Normally\n --                       the use of O in other internal names is avoided, but\n@@ -83,9 +84,9 @@ package Namet is\n --                       underscore.\n \n --    Unit names         Stored with upper case letters folded to lower case,\n---                       using Uhh/Whhhh encoding as described for identifiers,\n---                       and a %s or %b suffix for specs/bodies. See package\n---                       Uname for further details.\n+--                       using Uhh/Whhhh/WWhhhhhhhh encoding as described for\n+--                       identifiers, and a %s or %b suffix for specs/bodies.\n+--                       See package Uname for further details.\n \n --    File names         Are stored in the form provided by Osint. Typically\n --                       they may include wide character escape sequences and\n@@ -100,12 +101,12 @@ package Namet is\n --                       characters may appear for such entries.\n \n --  Note: the encodings Uhh (upper half characters), Whhhh (wide characters),\n---  and Qx (character literal names) are described in the spec, since they are\n---  visible throughout the system (e.g. in debugging output). However, no code\n---  should depend on these particular encodings, so it should be possible to\n---  change the encodings by making changes only to the Namet specification (to\n---  change these comments) and the body (which actually implements the\n---  encodings).\n+--  WWhhhhhhhh (wide wide characters) and Qx (character literal names) are\n+--  described in the spec, since they are visible throughout the system (e.g.\n+--  in debugging output). However, no code should depend on these particular\n+--  encodings, so it should be possible to change the encodings by making\n+--  changes only to the Namet specification (to change these comments) and the\n+--  body (which actually implements the encodings).\n \n --  The names are hashed so that a given name appears only once in the table,\n --  except that names entered with Name_Enter as opposed to Name_Find are\n@@ -188,13 +189,14 @@ package Namet is\n \n    procedure Get_Decoded_Name_String_With_Brackets (Id : Name_Id);\n    --  This routine is similar to Decoded_Name, except that the brackets\n-   --  notation (Uhh replaced by [\"hh\"], Whhhh replaced by [\"hhhh\"]) is used\n-   --  for all non-lower half characters, regardless of the setting of\n-   --  Opt.Wide_Character_Encoding_Method, and also in that characters in the\n-   --  range 16#80# .. 16#FF# are converted to brackets notation in all cases.\n-   --  This routine can be used when there is a requirement for a canonical\n-   --  representation not affected by the character set options (e.g. in the\n-   --  binder generation of symbols).\n+   --  notation (Uhh replaced by [\"hh\"], Whhhh replaced by [\"hhhh\"],\n+   --  WWhhhhhhhh replaced by [\"hhhhhhhh\"]) is used for all non-lower half\n+   --  characters, regardless of how Opt.Wide_Character_Encoding_Method is\n+   --  set, and also in that characters in the range 16#80# .. 16#FF# are\n+   --  converted to brackets notation in all cases. This routine can be used\n+   --  when there is a requirement for a canonical representation not affected\n+   --  by the character set options (e.g. in the binder generation of\n+   --  symbols).\n \n    function Get_Name_Table_Byte (Id : Name_Id) return Byte;\n    pragma Inline (Get_Name_Table_Byte);\n@@ -328,11 +330,12 @@ package Namet is\n    --  Stores given character code at the end of Name_Buffer, updating the\n    --  value in Name_Len appropriately. Lower case letters and digits are\n    --  stored unchanged. Other 8-bit characters are stored using the Uhh\n-   --  encoding (hh = hex code), and other 16-bit wide-character values are\n-   --  stored using the Whhhh (hhhh = hex code) encoding. Note that this\n-   --  procedure does not fold upper case letters (they are stored using the\n-   --  Uhh encoding). If folding is required, it must be done by the caller\n-   --  prior to the call.\n+   --  encoding (hh = hex code), other 16-bit wide character values are stored\n+   --  using the Whhhh (hhhh = hex code) encoding, and other 32-bit wide wide\n+   --  character values are stored using the WWhhhhhhhh (hhhhhhhh = hex code).\n+   --  Note that this procedure does not fold upper case letters (they are\n+   --  stored using the Uhh encoding). If folding is required, it must be done\n+   --  by the caller prior to the call.\n \n    procedure Tree_Read;\n    --  Initializes internal tables from current tree file using the relevant"}, {"sha": "1627831ab1732e2dfa37161b758b224f729a06cb", "filename": "gcc/ada/opt.ads", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/82c80734715c801643075ab68c5c9a5e00da1b03/gcc%2Fada%2Fopt.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/82c80734715c801643075ab68c5c9a5e00da1b03/gcc%2Fada%2Fopt.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fopt.ads?ref=82c80734715c801643075ab68c5c9a5e00da1b03", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---          Copyright (C) 1992-2004, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2005, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -271,6 +271,11 @@ package Opt is\n    --  of the original source code. Causes debugging information to be\n    --  written with respect to the generated code file that is written.\n \n+   Default_Exit_Status : Int := 0;\n+   --  GNATBIND\n+   --  Set the default exit status value. Set by the -Xnnn switch for the\n+   --  binder.\n+\n    Default_Sec_Stack_Size : Int := -1;\n    --  GNATBIND\n    --  Set to default secondary stack size in units of kilobytes. Set by"}, {"sha": "7dcc6ba08e12d2d54c964179cd3640db25591c8b", "filename": "gcc/ada/par-ch12.adb", "status": "modified", "additions": 40, "deletions": 10, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/82c80734715c801643075ab68c5c9a5e00da1b03/gcc%2Fada%2Fpar-ch12.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/82c80734715c801643075ab68c5c9a5e00da1b03/gcc%2Fada%2Fpar-ch12.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fpar-ch12.adb?ref=82c80734715c801643075ab68c5c9a5e00da1b03", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1992-2004 Free Software Foundation, Inc.          --\n+--          Copyright (C) 1992-2005 Free Software Foundation, Inc.          --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -808,41 +808,71 @@ package body Ch12 is\n    -----------------------------------------\n \n    --  FORMAL_SUBPROGRAM_DECLARATION ::=\n+   --    FORMAL_CONCRETE_SUBPROGRAM_DECLARATION\n+   --  | FORMAL_ABSTRACT_SUBPROGRAM_DECLARATION\n+\n+   --  FORMAL_CONCRETE_SUBPROGRAM_DECLARATION ::=\n    --    with SUBPROGRAM_SPECIFICATION [is SUBPROGRAM_DEFAULT];\n \n+   --  FORMAL_ABSTRACT_SUBPROGRAM_DECLARATION ::=\n+   --    with SUBPROGRAM_SPECIFICATION is abstract [SUBPROGRAM_DEFAULT];\n+\n    --  SUBPROGRAM_DEFAULT ::= DEFAULT_NAME | <>\n \n    --  DEFAULT_NAME ::= NAME\n \n    --  The caller has checked that the initial tokens are WITH FUNCTION or\n    --  WITH PROCEDURE, and the initial WITH has been scanned out.\n \n-   --  Note: we separate this into two procedures because the name is allowed\n-   --  to be an operator symbol for a function, but not for a procedure.\n-\n    --  Error recovery: cannot raise Error_Resync\n \n    function P_Formal_Subprogram_Declaration return Node_Id is\n-      Def_Node : Node_Id;\n+      Prev_Sloc : constant Source_Ptr := Prev_Token_Ptr;\n+      Spec_Node : constant Node_Id    := P_Subprogram_Specification;\n+      Def_Node  : Node_Id;\n \n    begin\n-      Def_Node := New_Node (N_Formal_Subprogram_Declaration, Prev_Token_Ptr);\n-      Set_Specification (Def_Node, P_Subprogram_Specification);\n-\n       if Token = Tok_Is then\n          T_Is; -- past IS, skip extra IS or \";\"\n \n-         if Token = Tok_Box then\n+         if Token = Tok_Abstract then\n+            Def_Node :=\n+              New_Node (N_Formal_Abstract_Subprogram_Declaration, Prev_Sloc);\n+            Scan; -- past ABSTRACT\n+\n+            if Ada_Version < Ada_05 then\n+               Error_Msg_SP\n+                 (\"formal abstract subprograms are an Ada 2005 extension\");\n+               Error_Msg_SP (\"\\unit must be compiled with -gnat05 switch\");\n+            end if;\n+\n+         else\n+            Def_Node :=\n+              New_Node (N_Formal_Concrete_Subprogram_Declaration, Prev_Sloc);\n+         end if;\n+\n+         Set_Specification (Def_Node, Spec_Node);\n+\n+         if Token = Tok_Semicolon then\n+            Scan; -- past \";\"\n+\n+         elsif Token = Tok_Box then\n             Set_Box_Present (Def_Node, True);\n             Scan; -- past <>\n+            T_Semicolon;\n \n          else\n             Set_Default_Name (Def_Node, P_Name);\n+            T_Semicolon;\n          end if;\n \n+      else\n+         Def_Node :=\n+           New_Node (N_Formal_Concrete_Subprogram_Declaration, Prev_Sloc);\n+         Set_Specification (Def_Node, Spec_Node);\n+         T_Semicolon;\n       end if;\n \n-      T_Semicolon;\n       return Def_Node;\n    end P_Formal_Subprogram_Declaration;\n "}, {"sha": "8b843e56c881c0e18c178e0f95373f360437cc98", "filename": "gcc/ada/par-ch2.adb", "status": "modified", "additions": 30, "deletions": 3, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/82c80734715c801643075ab68c5c9a5e00da1b03/gcc%2Fada%2Fpar-ch2.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/82c80734715c801643075ab68c5c9a5e00da1b03/gcc%2Fada%2Fpar-ch2.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fpar-ch2.adb?ref=82c80734715c801643075ab68c5c9a5e00da1b03", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1992-2003 Free Software Foundation, Inc.          --\n+--          Copyright (C) 1992-2005 Free Software Foundation, Inc.          --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -54,6 +54,21 @@ package body Ch2 is\n       --  All set if we do indeed have an identifier\n \n       if Token = Tok_Identifier then\n+\n+         --  Ada 2005 (AI-284): Compiling in Ada95 mode we notify\n+         --  that interface, overriding, and synchronized are\n+         --  new reserved words\n+\n+         if Ada_Version = Ada_95 then\n+            if Token_Name = Name_Overriding\n+              or else Token_Name = Name_Synchronized\n+              or else (Token_Name = Name_Interface\n+                        and then Prev_Token /= Tok_Pragma)\n+            then\n+               Error_Msg_N (\"& is a reserved word in Ada 2005?\", Token_Node);\n+            end if;\n+         end if;\n+\n          Ident_Node := Token_Node;\n          Scan; -- past Identifier\n          return Ident_Node;\n@@ -251,9 +266,21 @@ package body Ch2 is\n          Style.Check_Pragma_Name;\n       end if;\n \n-      Ident_Node := P_Identifier;\n+      --  Ada 2005 (AI-284): INTERFACE is a new reserved word but it is\n+      --  allowed as a pragma name.\n+\n+      if Ada_Version >= Ada_05\n+        and then Token = Tok_Interface\n+      then\n+         Pragma_Name := Name_Interface;\n+         Ident_Node  := Token_Node;\n+         Scan; -- past INTERFACE\n+      else\n+         Ident_Node := P_Identifier;\n+         Delete_Node (Ident_Node);\n+      end if;\n+\n       Set_Chars (Pragma_Node, Pragma_Name);\n-      Delete_Node (Ident_Node);\n \n       --  See if special INTERFACE/IMPORT check is required\n "}, {"sha": "5da4a3e10e1322a8898f93dfd6f29870f9e7c9ab", "filename": "gcc/ada/par-ch3.adb", "status": "modified", "additions": 15, "deletions": 2, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/82c80734715c801643075ab68c5c9a5e00da1b03/gcc%2Fada%2Fpar-ch3.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/82c80734715c801643075ab68c5c9a5e00da1b03/gcc%2Fada%2Fpar-ch3.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fpar-ch3.adb?ref=82c80734715c801643075ab68c5c9a5e00da1b03", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1992-2004, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2005, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -174,7 +174,20 @@ package body Ch3 is\n       --  separate declaration (but not use) of a reserved identifier.\n \n       if Token = Tok_Identifier then\n-         null;\n+\n+         --  Ada 2005 (AI-284): Compiling in Ada95 mode we notify\n+         --  that interface, overriding, and synchronized are\n+         --  new reserved words\n+\n+         if Ada_Version = Ada_95 then\n+            if Token_Name = Name_Overriding\n+              or else Token_Name = Name_Synchronized\n+              or else (Token_Name = Name_Interface\n+                        and then Prev_Token /= Tok_Pragma)\n+            then\n+               Error_Msg_N (\"& is a reserved word in Ada 2005?\", Token_Node);\n+            end if;\n+         end if;\n \n       --  If we have a reserved identifier, manufacture an identifier with\n       --  a corresponding name after posting an appropriate error message"}, {"sha": "3288aadec6a79f28831c98b015574b035f069973", "filename": "gcc/ada/par-prag.adb", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/82c80734715c801643075ab68c5c9a5e00da1b03/gcc%2Fada%2Fpar-prag.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/82c80734715c801643075ab68c5c9a5e00da1b03/gcc%2Fada%2Fpar-prag.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fpar-prag.adb?ref=82c80734715c801643075ab68c5c9a5e00da1b03", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1992-2004 Free Software Foundation, Inc.          --\n+--          Copyright (C) 1992-2005 Free Software Foundation, Inc.          --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -306,10 +306,13 @@ begin\n \n       --  This pragma must be processed at parse time, since we want to set\n       --  the Ada version properly at parse time to recognize the appropriate\n-      --  Ada version syntax.\n+      --  Ada version syntax. However, it is only the zero argument form that\n+      --  must be processed at parse time.\n \n       when Pragma_Ada_05 =>\n-         Ada_Version := Ada_05;\n+         if Arg_Count = 0 then\n+            Ada_Version := Ada_05;\n+         end if;\n \n       -----------\n       -- Debug --\n@@ -1060,7 +1063,6 @@ begin\n            Pragma_Normalize_Scalars            |\n            Pragma_Optimize                     |\n            Pragma_Optional_Overriding          |\n-           Pragma_Overriding                   |\n            Pragma_Pack                         |\n            Pragma_Passive                      |\n            Pragma_Polling                      |"}, {"sha": "15a2fd1c86d02a688033bd95b61be5126137f9e1", "filename": "gcc/ada/rtsfind.adb", "status": "modified", "additions": 38, "deletions": 16, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/82c80734715c801643075ab68c5c9a5e00da1b03/gcc%2Fada%2Frtsfind.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/82c80734715c801643075ab68c5c9a5e00da1b03/gcc%2Fada%2Frtsfind.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Frtsfind.adb?ref=82c80734715c801643075ab68c5c9a5e00da1b03", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1992-2004, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2005, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -159,7 +159,7 @@ package body Rtsfind is\n    --  A value of False means nothing special need be done. A value of\n    --  True indicates that this flag must be set to True. It is needed\n    --  only in the Text_IO_Kludge procedure, which may materialize an\n-   --  entity of Text_IO (or Wide_Text_IO) that was previously unknown.\n+   --  entity of Text_IO (or [Wide_]Wide_Text_IO) that was previously unknown.\n    --  Id is the RE_Id value of the entity which was originally requested.\n    --  Id is used only for error message detail, and if it is RE_Null, then\n    --  the attempt to output the entity name is ignored.\n@@ -248,6 +248,9 @@ package body Rtsfind is\n \n          elsif U_Id in Ada_Wide_Text_IO_Child then\n             Name_Buffer (17) := '.';\n+\n+         elsif U_Id in Ada_Wide_Wide_Text_IO_Child then\n+            Name_Buffer (22) := '.';\n          end if;\n \n       elsif U_Id in Interfaces_Child then\n@@ -435,7 +438,11 @@ package body Rtsfind is\n       return\n         Nkind (Prf) = N_Identifier\n           and then\n-        (Chars (Prf) = Name_Text_IO or else Chars (Prf) = Name_Wide_Text_IO)\n+           (Chars (Prf) = Name_Text_IO\n+              or else\n+            Chars (Prf) = Name_Wide_Text_IO\n+              or else\n+            Chars (Prf) = Name_Wide_Wide_Text_IO)\n           and then\n         Nkind (Sel) = N_Identifier\n           and then\n@@ -830,7 +837,7 @@ package body Rtsfind is\n                        or else\n                      E = RE_Params_Stream_Type\n                        or else\n-                     E = RE_RPC_Receiver)\n+                     E = RE_Request_Access)\n          then\n             declare\n                DSA_Implementation : constant Entity_Id :=\n@@ -1143,6 +1150,14 @@ package body Rtsfind is\n         Name_Integer_IO     => Ada_Wide_Text_IO_Integer_IO,\n         Name_Modular_IO     => Ada_Wide_Text_IO_Modular_IO);\n \n+      Wide_Wide_Name_Map : constant Name_Map_Type := Name_Map_Type'(\n+        Name_Decimal_IO     => Ada_Wide_Wide_Text_IO_Decimal_IO,\n+        Name_Enumeration_IO => Ada_Wide_Wide_Text_IO_Enumeration_IO,\n+        Name_Fixed_IO       => Ada_Wide_Wide_Text_IO_Fixed_IO,\n+        Name_Float_IO       => Ada_Wide_Wide_Text_IO_Float_IO,\n+        Name_Integer_IO     => Ada_Wide_Wide_Text_IO_Integer_IO,\n+        Name_Modular_IO     => Ada_Wide_Wide_Text_IO_Modular_IO);\n+\n    begin\n       --  Nothing to do if name is not identifier or a selected component\n       --  whose selector_name is not an identifier.\n@@ -1161,25 +1176,25 @@ package body Rtsfind is\n \n       --  Nothing to do if name is not one of the Text_IO subpackages\n       --  Otherwise look through loaded units, and if we find Text_IO\n-      --  or Wide_Text_IO already loaded, then load the proper child.\n+      --  or [Wide_]Wide_Text_IO already loaded, then load the proper child.\n \n       if Chrs in Text_IO_Package_Name then\n          for U in Main_Unit .. Last_Unit loop\n             Get_Name_String (Unit_File_Name (U));\n \n             if Name_Len = 12 then\n \n-               --  Here is where we do the loads if we find one of the\n-               --  units Ada.Text_IO or Ada.Wide_Text_IO. An interesting\n-               --  detail is that these units may already be used (i.e.\n-               --  their In_Use flags may be set). Normally when the In_Use\n-               --  flag is set, the Is_Potentially_Use_Visible flag of all\n-               --  entities in the package is set, but the new entity we\n-               --  are mysteriously adding was not there to have its flag\n-               --  set at the time. So that's why we pass the extra parameter\n-               --  to RTU_Find, to make sure the flag does get set now.\n-               --  Given that those generic packages are in fact child units,\n-               --  we must indicate that they are visible.\n+               --  Here is where we do the loads if we find one of the units\n+               --  Ada.Text_IO or Ada.[Wide_]Wide_Text_IO. An interesting\n+               --  detail is that these units may already be used (i.e. their\n+               --  In_Use flags may be set). Normally when the In_Use flag is\n+               --  set, the Is_Potentially_Use_Visible flag of all entities in\n+               --  the package is set, but the new entity we are mysteriously\n+               --  adding was not there to have its flag set at the time. So\n+               --  that's why we pass the extra parameter to RTU_Find, to make\n+               --  sure the flag does get set now. Given that those generic\n+               --  packages are in fact child units, we must indicate that\n+               --  they are visible.\n \n                if Name_Buffer (1 .. 12) = \"a-textio.ads\" then\n                   Load_RTU\n@@ -1194,6 +1209,13 @@ package body Rtsfind is\n                      Use_Setting => In_Use (Cunit_Entity (U)));\n                   Set_Is_Visible_Child_Unit\n                     (RT_Unit_Table (Wide_Name_Map (Chrs)).Entity);\n+\n+               elsif Name_Buffer (1 .. 12) = \"a-ztexio.ads\" then\n+                  Load_RTU\n+                    (Wide_Wide_Name_Map (Chrs),\n+                     Use_Setting => In_Use (Cunit_Entity (U)));\n+                  Set_Is_Visible_Child_Unit\n+                    (RT_Unit_Table (Wide_Wide_Name_Map (Chrs)).Entity);\n                end if;\n             end if;\n          end loop;"}, {"sha": "ac1e94a71645f7903a33ff2a6c36288d616703e1", "filename": "gcc/ada/rtsfind.ads", "status": "modified", "additions": 69, "deletions": 15, "changes": 84, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/82c80734715c801643075ab68c5c9a5e00da1b03/gcc%2Fada%2Frtsfind.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/82c80734715c801643075ab68c5c9a5e00da1b03/gcc%2Fada%2Frtsfind.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Frtsfind.ads?ref=82c80734715c801643075ab68c5c9a5e00da1b03", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---          Copyright (C) 1992-2004, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2005, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -69,6 +69,9 @@ package Rtsfind is\n    --    Names of the form Ada_Wide_Text_IO_xxx are second level children\n    --    of Ada.Wide_Text_IO.\n \n+   --    Names of the form Ada_Wide_Wide_Text_IO_xxx are second level children\n+   --    of Ada.Wide_Wide_Text_IO.\n+\n    --    Names of the form Interfaces_xxx are first level children of\n    --    Interfaces_CPP refers to package Interfaces.CPP\n \n@@ -156,6 +159,15 @@ package Rtsfind is\n       Ada_Wide_Text_IO_Integer_IO,\n       Ada_Wide_Text_IO_Modular_IO,\n \n+      --  Children of Ada.Wide_Wide_Text_IO (for Text_IO_Kludge)\n+\n+      Ada_Wide_Wide_Text_IO_Decimal_IO,\n+      Ada_Wide_Wide_Text_IO_Enumeration_IO,\n+      Ada_Wide_Wide_Text_IO_Fixed_IO,\n+      Ada_Wide_Wide_Text_IO_Float_IO,\n+      Ada_Wide_Wide_Text_IO_Integer_IO,\n+      Ada_Wide_Wide_Text_IO_Modular_IO,\n+\n       --  Interfaces\n \n       Interfaces,\n@@ -343,7 +355,7 @@ package Rtsfind is\n       System_Tasking_Stages);\n \n    subtype Ada_Child is RTU_Id\n-     range Ada_Calendar .. Ada_Wide_Text_IO_Modular_IO;\n+     range Ada_Calendar .. Ada_Wide_Wide_Text_IO_Modular_IO;\n    --  Range of values for children or grand-children of Ada\n \n    subtype Ada_Calendar_Child is Ada_Child\n@@ -373,6 +385,10 @@ package Rtsfind is\n      range Ada_Wide_Text_IO_Decimal_IO .. Ada_Wide_Text_IO_Modular_IO;\n    --  Range of values for children of Ada.Text_IO\n \n+   subtype Ada_Wide_Wide_Text_IO_Child is Ada_Child\n+     range Ada_Wide_Wide_Text_IO_Decimal_IO ..\n+           Ada_Wide_Wide_Text_IO_Modular_IO;\n+\n    subtype Interfaces_Child is RTU_Id\n      range Interfaces_CPP .. Interfaces_Packed_Decimal;\n    --  Range of values for children of Interfaces\n@@ -700,6 +716,7 @@ package Rtsfind is\n      RE_Image_Unsigned,                  -- System.Img_Uns\n \n      RE_Image_Wide_Character,            -- System.Img_WChar\n+     RE_Image_Wide_Wide_Character,       -- System.Img_WChar\n \n      RE_Bind_Interrupt_To_Entry,         -- System.Interrupts\n      RE_Default_Interrupt_Priority,      -- System.Interrupts\n@@ -1033,7 +1050,6 @@ package Rtsfind is\n      RE_Do_Rpc,                          -- System.RPC\n      RE_Params_Stream_Type,              -- System.RPC\n      RE_Partition_ID,                    -- System.RPC\n-     RE_RPC_Receiver,                    -- System.RPC\n \n      RE_To_PolyORB_String,               -- System.PolyORB_Interface\n      RE_To_Standard_String,              -- System.PolyORB_Interface\n@@ -1103,6 +1119,7 @@ package Rtsfind is\n      RE_FA_SU,                           -- System.PolyORB_Interface\n      RE_FA_U,                            -- System.PolyORB_Interface\n      RE_FA_WC,                           -- System.PolyORB_Interface\n+     RE_FA_WWC,                          -- System.PolyORB_Interface\n      RE_FA_String,                       -- System.PolyORB_Interface\n      RE_FA_ObjRef,                       -- System.PolyORB_Interface\n \n@@ -1125,6 +1142,7 @@ package Rtsfind is\n      RE_TA_SU,                           -- System.PolyORB_Interface\n      RE_TA_U,                            -- System.PolyORB_Interface\n      RE_TA_WC,                           -- System.PolyORB_Interface\n+     RE_TA_WWC,                          -- System.PolyORB_Interface\n      RE_TA_String,                       -- System.PolyORB_Interface\n      RE_TA_ObjRef,                       -- System.PolyORB_Interface\n      RE_TA_TC,                           -- System.PolyORB_Interface\n@@ -1154,6 +1172,7 @@ package Rtsfind is\n      RE_TC_Void,                         -- System.PolyORB_Interface\n      RE_TC_Opaque,                       -- System.PolyORB_Interface,\n      RE_TC_WC,                           -- System.PolyORB_Interface\n+     RE_TC_WWC,                          -- System.PolyORB_Interface\n      RE_TC_Array,                        -- System.PolyORB_Interface,\n      RE_TC_Sequence,                     -- System.PolyORB_Interface,\n      RE_TC_String,                       -- System.PolyORB_Interface,\n@@ -1169,6 +1188,10 @@ package Rtsfind is\n      RE_IS_Iu2,                          -- System.Scalar_Values\n      RE_IS_Iu4,                          -- System.Scalar_Values\n      RE_IS_Iu8,                          -- System.Scalar_Values\n+     RE_IS_Iz1,                          -- System.Scalar_Values\n+     RE_IS_Iz2,                          -- System.Scalar_Values\n+     RE_IS_Iz4,                          -- System.Scalar_Values\n+     RE_IS_Iz8,                          -- System.Scalar_Values\n      RE_IS_Isf,                          -- System.Scalar_Values\n      RE_IS_Ifl,                          -- System.Scalar_Values\n      RE_IS_Ilf,                          -- System.Scalar_Values\n@@ -1222,6 +1245,7 @@ package Rtsfind is\n      RE_I_SU,                            -- System.Stream_Attributes\n      RE_I_U,                             -- System.Stream_Attributes\n      RE_I_WC,                            -- System.Stream_Attributes\n+     RE_I_WWC,                           -- System.Stream_Attributes\n \n      RE_W_AD,                            -- System.Stream_Attributes\n      RE_W_AS,                            -- System.Stream_Attributes\n@@ -1242,15 +1266,14 @@ package Rtsfind is\n      RE_W_SU,                            -- System.Stream_Attributes\n      RE_W_U,                             -- System.Stream_Attributes\n      RE_W_WC,                            -- System.Stream_Attributes\n+     RE_W_WWC,                           -- System.Stream_Attributes\n \n      RE_Block_Stream_Ops_OK,             -- System.Stream_Attributes\n \n      RE_Str_Concat,                      -- System.String_Ops\n      RE_Str_Concat_CC,                   -- System.String_Ops\n      RE_Str_Concat_CS,                   -- System.String_Ops\n      RE_Str_Concat_SC,                   -- System.String_Ops\n-     RE_Str_Normalize,                   -- System.String_Ops\n-     RE_Wide_Str_Normalize,              -- System.String_Ops\n \n      RE_Str_Concat_3,                    -- System.String_Ops_Concat_3\n \n@@ -1350,6 +1373,7 @@ package Rtsfind is\n      RE_Value_Unsigned,                  -- System.Val_Uns\n \n      RE_Value_Wide_Character,            -- System.Val_WChar\n+     RE_Value_Wide_Wide_Character,       -- System.Val_WChar\n \n      RE_D,                               -- System.Vax_Float_Operations\n      RE_F,                               -- System.Vax_Float_Operations\n@@ -1398,16 +1422,26 @@ package Rtsfind is\n      RE_Register_VMS_Exception,          -- System.VMS_Exception_Table\n \n      RE_String_To_Wide_String,           -- System.WCh_StW\n+     RE_String_To_Wide_Wide_String,      -- System.WCh_StW\n \n      RE_Wide_String_To_String,           -- System.WCh_WtS\n+     RE_Wide_Wide_String_To_String,      -- System.WCh_WtS\n \n      RE_Wide_Width_Character,            -- System.WWd_Char\n+     RE_Wide_Wide_Width_Character,       -- System.WWd_Char\n+\n+     RE_Wide_Wide_Width_Enumeration_8,   -- System.WWd_Enum\n+     RE_Wide_Wide_Width_Enumeration_16,  -- System.WWd_Enum\n+     RE_Wide_Wide_Width_Enumeration_32,  -- System.WWd_Enum\n \n      RE_Wide_Width_Enumeration_8,        -- System.WWd_Enum\n      RE_Wide_Width_Enumeration_16,       -- System.WWd_Enum\n      RE_Wide_Width_Enumeration_32,       -- System.WWd_Enum\n \n+     RE_Wide_Wide_Width_Wide_Character,  -- System.WWd_Wchar\n+     RE_Wide_Wide_Width_Wide_Wide_Char,  -- System.WWd_Wchar\n      RE_Wide_Width_Wide_Character,       -- System.WWd_Wchar\n+     RE_Wide_Width_Wide_Wide_Character,  -- System.WWd_Wchar\n \n      RE_Width_Boolean,                   -- System.Wid_Bool\n \n@@ -1422,6 +1456,7 @@ package Rtsfind is\n      RE_Width_Long_Long_Unsigned,        -- System.Wid_LLU\n \n      RE_Width_Wide_Character,            -- System.Wid_WChar\n+     RE_Width_Wide_Wide_Character,       -- System.Wid_WChar\n \n      RE_Protected_Entry_Body_Array,      -- Tasking.Protected_Objects.Entries\n      RE_Protection_Entries,              -- Tasking.Protected_Objects.Entries\n@@ -1781,6 +1816,7 @@ package Rtsfind is\n      RE_Image_Unsigned                   => System_Img_Uns,\n \n      RE_Image_Wide_Character             => System_Img_WChar,\n+     RE_Image_Wide_Wide_Character        => System_Img_WChar,\n \n      RE_Bind_Interrupt_To_Entry          => System_Interrupts,\n      RE_Default_Interrupt_Priority       => System_Interrupts,\n@@ -2174,6 +2210,7 @@ package Rtsfind is\n      RE_FA_SU                            => System_PolyORB_Interface,\n      RE_FA_U                             => System_PolyORB_Interface,\n      RE_FA_WC                            => System_PolyORB_Interface,\n+     RE_FA_WWC                           => System_PolyORB_Interface,\n      RE_FA_String                        => System_PolyORB_Interface,\n      RE_FA_ObjRef                        => System_PolyORB_Interface,\n \n@@ -2196,6 +2233,7 @@ package Rtsfind is\n      RE_TA_SU                            => System_PolyORB_Interface,\n      RE_TA_U                             => System_PolyORB_Interface,\n      RE_TA_WC                            => System_PolyORB_Interface,\n+     RE_TA_WWC                           => System_PolyORB_Interface,\n      RE_TA_String                        => System_PolyORB_Interface,\n      RE_TA_ObjRef                        => System_PolyORB_Interface,\n      RE_TA_TC                            => System_PolyORB_Interface,\n@@ -2225,6 +2263,7 @@ package Rtsfind is\n      RE_TC_Void                          => System_PolyORB_Interface,\n      RE_TC_Opaque                        => System_PolyORB_Interface,\n      RE_TC_WC                            => System_PolyORB_Interface,\n+     RE_TC_WWC                           => System_PolyORB_Interface,\n      RE_TC_Array                         => System_PolyORB_Interface,\n      RE_TC_Sequence                      => System_PolyORB_Interface,\n      RE_TC_String                        => System_PolyORB_Interface,\n@@ -2240,7 +2279,6 @@ package Rtsfind is\n      RE_Do_Rpc                           => System_RPC,\n      RE_Params_Stream_Type               => System_RPC,\n      RE_Partition_ID                     => System_RPC,\n-     RE_RPC_Receiver                     => System_RPC,\n \n      RE_IS_Is1                           => System_Scalar_Values,\n      RE_IS_Is2                           => System_Scalar_Values,\n@@ -2250,6 +2288,10 @@ package Rtsfind is\n      RE_IS_Iu2                           => System_Scalar_Values,\n      RE_IS_Iu4                           => System_Scalar_Values,\n      RE_IS_Iu8                           => System_Scalar_Values,\n+     RE_IS_Iz1                           => System_Scalar_Values,\n+     RE_IS_Iz2                           => System_Scalar_Values,\n+     RE_IS_Iz4                           => System_Scalar_Values,\n+     RE_IS_Iz8                           => System_Scalar_Values,\n      RE_IS_Isf                           => System_Scalar_Values,\n      RE_IS_Ifl                           => System_Scalar_Values,\n      RE_IS_Ilf                           => System_Scalar_Values,\n@@ -2303,6 +2345,7 @@ package Rtsfind is\n      RE_I_SU                             => System_Stream_Attributes,\n      RE_I_U                              => System_Stream_Attributes,\n      RE_I_WC                             => System_Stream_Attributes,\n+     RE_I_WWC                            => System_Stream_Attributes,\n \n      RE_W_AD                             => System_Stream_Attributes,\n      RE_W_AS                             => System_Stream_Attributes,\n@@ -2323,12 +2366,10 @@ package Rtsfind is\n      RE_W_SU                             => System_Stream_Attributes,\n      RE_W_U                              => System_Stream_Attributes,\n      RE_W_WC                             => System_Stream_Attributes,\n-\n+     RE_W_WWC                            => System_Stream_Attributes,\n      RE_Block_Stream_Ops_OK              => System_Stream_Attributes,\n \n      RE_Str_Concat                       => System_String_Ops,\n-     RE_Str_Normalize                    => System_String_Ops,\n-     RE_Wide_Str_Normalize               => System_String_Ops,\n      RE_Str_Concat_CC                    => System_String_Ops,\n      RE_Str_Concat_CS                    => System_String_Ops,\n      RE_Str_Concat_SC                    => System_String_Ops,\n@@ -2431,6 +2472,7 @@ package Rtsfind is\n      RE_Value_Unsigned                   => System_Val_Uns,\n \n      RE_Value_Wide_Character             => System_Val_WChar,\n+     RE_Value_Wide_Wide_Character        => System_Val_WChar,\n \n      RE_D                                => System_Vax_Float_Operations,\n      RE_F                                => System_Vax_Float_Operations,\n@@ -2479,16 +2521,27 @@ package Rtsfind is\n      RE_Register_VMS_Exception           => System_VMS_Exception_Table,\n \n      RE_String_To_Wide_String            => System_WCh_StW,\n+     RE_String_To_Wide_Wide_String       => System_WCh_StW,\n \n      RE_Wide_String_To_String            => System_WCh_WtS,\n+     RE_Wide_Wide_String_To_String       => System_WCh_WtS,\n \n+     RE_Wide_Wide_Width_Character        => System_WWd_Char,\n      RE_Wide_Width_Character             => System_WWd_Char,\n \n+     RE_Wide_Wide_Width_Enumeration_8    => System_WWd_Enum,\n+     RE_Wide_Wide_Width_Enumeration_16   => System_WWd_Enum,\n+     RE_Wide_Wide_Width_Enumeration_32   => System_WWd_Enum,\n+\n      RE_Wide_Width_Enumeration_8         => System_WWd_Enum,\n      RE_Wide_Width_Enumeration_16        => System_WWd_Enum,\n      RE_Wide_Width_Enumeration_32        => System_WWd_Enum,\n \n+     RE_Wide_Wide_Width_Wide_Character   => System_WWd_Wchar,\n+     RE_Wide_Wide_Width_Wide_Wide_Char   => System_WWd_Wchar,\n+\n      RE_Wide_Width_Wide_Character        => System_WWd_Wchar,\n+     RE_Wide_Width_Wide_Wide_Character   => System_WWd_Wchar,\n \n      RE_Width_Boolean                    => System_Wid_Bool,\n \n@@ -2503,6 +2556,7 @@ package Rtsfind is\n      RE_Width_Long_Long_Unsigned         => System_Wid_LLU,\n \n      RE_Width_Wide_Character             => System_Wid_WChar,\n+     RE_Width_Wide_Wide_Character        => System_Wid_WChar,\n \n      RE_Protected_Entry_Body_Array       =>\n        System_Tasking_Protected_Objects_Entries,\n@@ -2754,13 +2808,13 @@ package Rtsfind is\n    --  with'ed automatically. The important result of this approach is that\n    --  Text_IO does not drag in all the code for the subpackages unless they\n    --  are used. Our test is a little crude, and could drag in stuff when it\n-   --  is not necessary, but that doesn't matter. Wide_Text_IO is handled in\n-   --  a similar manner.\n+   --  is not necessary, but that doesn't matter. Wide_[Wide_]Text_IO is\n+   --  handled in a similar manner.\n \n    function Is_Text_IO_Kludge_Unit (Nam : Node_Id) return Boolean;\n-   --  Returns True if the given Nam is an Expanded Name, whose Prefix is\n-   --  Ada, and whose selector is either Text_IO.xxx or Wide_Text_IO.xxx\n-   --  where xxx is one of the subpackages of Text_IO that is specially\n-   --  handled as described above for Text_IO_Kludge.\n+   --  Returns True if the given Nam is an Expanded Name, whose Prefix is Ada,\n+   --  and whose selector is either Text_IO.xxx or Wide_Text_IO.xxx or\n+   --  Wide_Wide_Text_IO.xxx, where xxx is one of the subpackages of Text_IO\n+   --  that is specially handled as described above for Text_IO_Kludge.\n \n end Rtsfind;"}, {"sha": "09d4e5844c4df86e066bda7efd3035f3c2134f27", "filename": "gcc/ada/s-imgwch.adb", "status": "modified", "additions": 35, "deletions": 5, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/82c80734715c801643075ab68c5c9a5e00da1b03/gcc%2Fada%2Fs-imgwch.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/82c80734715c801643075ab68c5c9a5e00da1b03/gcc%2Fada%2Fs-imgwch.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-imgwch.adb?ref=82c80734715c801643075ab68c5c9a5e00da1b03", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1992-2003, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2005, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -42,9 +42,8 @@ package body System.Img_WChar is\n    --------------------------\n \n    function Image_Wide_Character\n-     (V    : Wide_Character;\n-      EM   : WC_Encoding_Method)\n-      return String\n+     (V  : Wide_Character;\n+      EM : WC_Encoding_Method) return String\n    is\n       Val : constant Natural := Wide_Character'Pos (V);\n       WS  : Wide_String (1 .. 3);\n@@ -79,7 +78,38 @@ package body System.Img_WChar is\n \n          return Wide_String_To_String (WS, EM);\n       end if;\n-\n    end Image_Wide_Character;\n \n+   -------------------------------\n+   -- Image_Wide_Wide_Character --\n+   -------------------------------\n+\n+   function Image_Wide_Wide_Character\n+     (V  : Wide_Wide_Character;\n+      EM : WC_Encoding_Method) return String\n+   is\n+      Val : constant Natural := Wide_Wide_Character'Pos (V);\n+      WS  : Wide_Wide_String (1 .. 3);\n+\n+   begin\n+      --  If in range of standard Wide_Character, then we use the\n+      --  Wide_Character routine\n+\n+      if Val <= 16#FFFF# then\n+         return Image_Wide_Character (Wide_Character'Val (Val), EM);\n+\n+      --  Otherwise return an appropriate escape sequence (i.e. one matching\n+      --  the convention implemented by Scn.Wide_Wide_Char). The easiest thing\n+      --  is to build a wide string for the result, and then use the\n+      --  Wide_Wide_Value function to build the resulting String.\n+\n+      else\n+         WS (1) := ''';\n+         WS (2) := V;\n+         WS (3) := ''';\n+\n+         return Wide_Wide_String_To_String (WS, EM);\n+      end if;\n+   end Image_Wide_Wide_Character;\n+\n end System.Img_WChar;"}, {"sha": "fa472aa26d4f816af857c14e796606b2c1012c10", "filename": "gcc/ada/s-imgwch.ads", "status": "modified", "additions": 14, "deletions": 6, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/82c80734715c801643075ab68c5c9a5e00da1b03/gcc%2Fada%2Fs-imgwch.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/82c80734715c801643075ab68c5c9a5e00da1b03/gcc%2Fada%2Fs-imgwch.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-imgwch.ads?ref=82c80734715c801643075ab68c5c9a5e00da1b03", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---           Copyright (C) 1992-2000 Free Software Foundation, Inc.         --\n+--           Copyright (C) 1992-2005 Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -31,18 +31,26 @@\n --                                                                          --\n ------------------------------------------------------------------------------\n \n---  Wide_Character'Image\n+--  Wide_[Wide_]Character'Image\n \n with System.WCh_Con;\n \n package System.Img_WChar is\n pragma Pure (Img_WChar);\n \n    function Image_Wide_Character\n-     (V    : Wide_Character;\n-      EM   : System.WCh_Con.WC_Encoding_Method)\n-      return String;\n-   --  Computes Wode_Character'Image (V) and returns the computed result,\n+     (V  : Wide_Character;\n+      EM : System.WCh_Con.WC_Encoding_Method) return String;\n+   --  Computes Wide_Character'Image (V) and returns the computed result,\n+   --  The argument EM is a constant representing the encoding method in use.\n+   --  The encoding method used is guaranteed to be consistent across a\n+   --  given program execution and to correspond to the method used in the\n+   --  source programs.\n+\n+   function Image_Wide_Wide_Character\n+     (V  : Wide_Wide_Character;\n+      EM : System.WCh_Con.WC_Encoding_Method) return String;\n+   --  Computes Wide_Wide_Character'Image (V) and returns the computed result,\n    --  The argument EM is a constant representing the encoding method in use.\n    --  The encoding method used is guaranteed to be consistent across a\n    --  given program execution and to correspond to the method used in the"}, {"sha": "b6ca08c16dd891f1ffbd2585652058588215612b", "filename": "gcc/ada/s-scaval.adb", "status": "modified", "additions": 21, "deletions": 3, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/82c80734715c801643075ab68c5c9a5e00da1b03/gcc%2Fada%2Fs-scaval.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/82c80734715c801643075ab68c5c9a5e00da1b03/gcc%2Fada%2Fs-scaval.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-scaval.adb?ref=82c80734715c801643075ab68c5c9a5e00da1b03", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---             Copyright (C) 2003 Free Software Foundation, Inc.            --\n+--          Copyright (C) 2003-2005 Free Software Foundation, Inc.          --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -159,6 +159,11 @@ package body System.Scalar_Values is\n          IS_Iu4 := 16#FFFF_FFFF#;\n          IS_Iu8 := 16#FFFF_FFFF_FFFF_FFFF#;\n \n+         IS_Iz1 := 16#00#;\n+         IS_Iz2 := 16#0000#;\n+         IS_Iz4 := 16#0000_0000#;\n+         IS_Iz8 := 16#0000_0000_0000_0000#;\n+\n          IV_Isf := IS_Iu4;\n          IV_Ifl := IS_Iu4;\n          IV_Ilf := IS_Iu8;\n@@ -180,6 +185,11 @@ package body System.Scalar_Values is\n          IS_Iu4 := 16#0000_0000#;\n          IS_Iu8 := 16#0000_0000_0000_0000#;\n \n+         IS_Iz1 := 16#00#;\n+         IS_Iz2 := 16#0000#;\n+         IS_Iz4 := 16#0000_0000#;\n+         IS_Iz8 := 16#0000_0000_0000_0000#;\n+\n          IV_Isf := 16#FF80_0000#;\n          IV_Ifl := 16#FF80_0000#;\n          IV_Ilf := 16#FFF0_0000_0000_0000#;\n@@ -201,6 +211,11 @@ package body System.Scalar_Values is\n          IS_Iu4 := 16#FFFF_FFFF#;\n          IS_Iu8 := 16#FFFF_FFFF_FFFF_FFFF#;\n \n+         IS_Iz1 := 16#FF#;\n+         IS_Iz2 := 16#FFFF#;\n+         IS_Iz4 := 16#FFFF_FFFF#;\n+         IS_Iz8 := 16#FFFF_FFFF_FFFF_FFFF#;\n+\n          IV_Isf := 16#7F80_0000#;\n          IV_Ifl := 16#7F80_0000#;\n          IV_Ilf := 16#7FF0_0000_0000_0000#;\n@@ -238,6 +253,11 @@ package body System.Scalar_Values is\n          IS_Iu4 := IS_Is4;\n          IS_Iu8 := IS_Is8;\n \n+         IS_Iz1 := IS_Is1;\n+         IS_Iz2 := IS_Is2;\n+         IS_Iz4 := IS_Is4;\n+         IS_Iz8 := IS_Is8;\n+\n          IV_Isf := IS_Is4;\n          IV_Ifl := IS_Is4;\n          IV_Ilf := IS_Is8;\n@@ -259,8 +279,6 @@ package body System.Scalar_Values is\n             IV_Ill := To_ByteLF (IV_Ilf);\n          end;\n       end if;\n-\n-\n    end Initialize;\n \n end System.Scalar_Values;"}, {"sha": "da8e809baeab719e4663ab75759768b69b08dc78", "filename": "gcc/ada/s-scaval.ads", "status": "modified", "additions": 22, "deletions": 9, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/82c80734715c801643075ab68c5c9a5e00da1b03/gcc%2Fada%2Fs-scaval.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/82c80734715c801643075ab68c5c9a5e00da1b03/gcc%2Fada%2Fs-scaval.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-scaval.ads?ref=82c80734715c801643075ab68c5c9a5e00da1b03", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---          Copyright (C) 2001-2003 Free Software Foundation, Inc.          --\n+--          Copyright (C) 2001-2005 Free Software Foundation, Inc.          --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -53,14 +53,27 @@ package System.Scalar_Values is\n    --  The explicit initializations here are not really required, since these\n    --  variables are always set by System.Scalar_Values.Initialize.\n \n-   IS_Is1 : Byte1 := 0;           -- Initialize 1 byte signed\n-   IS_Is2 : Byte2 := 0;           -- Initialize 2 byte signed\n-   IS_Is4 : Byte4 := 0;           -- Initialize 4 byte signed\n-   IS_Is8 : Byte8 := 0;           -- Initialize 8 byte signed\n-   IS_Iu1 : Byte1 := 0;           -- Initialize 1 byte unsigned\n-   IS_Iu2 : Byte2 := 0;           -- Initialize 2 byte unsigned\n-   IS_Iu4 : Byte4 := 0;           -- Initialize 4 byte unsigned\n-   IS_Iu8 : Byte8 := 0;           -- Initialize 8 byte unsigned\n+   IS_Is1 : Byte1 := 0;  -- Initialize 1 byte signed\n+   IS_Is2 : Byte2 := 0;  -- Initialize 2 byte signed\n+   IS_Is4 : Byte4 := 0;  -- Initialize 4 byte signed\n+   IS_Is8 : Byte8 := 0;  -- Initialize 8 byte signed\n+   --  For the above cases, the undefined value (set by the binder -Sin switch)\n+   --  is the largest negative number (1 followed by all zero bits).\n+\n+   IS_Iu1 : Byte1 := 0;  -- Initialize 1 byte unsigned\n+   IS_Iu2 : Byte2 := 0;  -- Initialize 2 byte unsigned\n+   IS_Iu4 : Byte4 := 0;  -- Initialize 4 byte unsigned\n+   IS_Iu8 : Byte8 := 0;  -- Initialize 8 byte unsigned\n+   --  For the above cases, the undefined value (set by the binder -Sin switch)\n+   --  is the largest unsigned number (all 1 bits).\n+\n+   IS_Iz1 : Byte1 := 0;  -- Initialize 1 byte zeroes\n+   IS_Iz2 : Byte2 := 0;  -- Initialize 2 byte zeroes\n+   IS_Iz4 : Byte4 := 0;  -- Initialize 4 byte zeroes\n+   IS_Iz8 : Byte8 := 0;  -- Initialize 8 byte zeroes\n+   --  For the above cases, the undefined value (set by the binder -Sin switch)\n+   --  is the zero (all 0 bits). This is used when zero is known to be an\n+   --  invalid value.\n \n    --  The float definitions are aliased, because we use overlays to set them\n "}, {"sha": "ae7e267cb9cad7039b6f4e3995c125c1a713c945", "filename": "gcc/ada/s-strops.adb", "status": "modified", "additions": 1, "deletions": 23, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/82c80734715c801643075ab68c5c9a5e00da1b03/gcc%2Fada%2Fs-strops.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/82c80734715c801643075ab68c5c9a5e00da1b03/gcc%2Fada%2Fs-strops.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-strops.adb?ref=82c80734715c801643075ab68c5c9a5e00da1b03", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1992-2002 Free Software Foundation, Inc.          --\n+--          Copyright (C) 1992-2005 Free Software Foundation, Inc.          --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -102,26 +102,4 @@ package body System.String_Ops is\n       end if;\n    end Str_Concat_SC;\n \n-   -------------------\n-   -- Str_Normalize --\n-   -------------------\n-\n-   procedure Str_Normalize (A : in out String) is\n-   begin\n-      for J in A'Range loop\n-         A (J) := Character'Last;\n-      end loop;\n-   end Str_Normalize;\n-\n-   ------------------------\n-   -- Wide_Str_Normalize --\n-   ------------------------\n-\n-   procedure Wide_Str_Normalize (A : in out Wide_String) is\n-   begin\n-      for J in A'Range loop\n-         A (J) := Wide_Character'Last;\n-      end loop;\n-   end Wide_Str_Normalize;\n-\n end System.String_Ops;"}, {"sha": "da5fcdfbddf424abcad3ca01e0d8ebd56f5e53d8", "filename": "gcc/ada/s-strops.ads", "status": "modified", "additions": 1, "deletions": 9, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/82c80734715c801643075ab68c5c9a5e00da1b03/gcc%2Fada%2Fs-strops.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/82c80734715c801643075ab68c5c9a5e00da1b03/gcc%2Fada%2Fs-strops.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-strops.ads?ref=82c80734715c801643075ab68c5c9a5e00da1b03", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---          Copyright (C) 1992-2002 Free Software Foundation, Inc.          --\n+--          Copyright (C) 1992-2005 Free Software Foundation, Inc.          --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -49,12 +49,4 @@ pragma Pure (String_Ops);\n    function Str_Concat_CC (X, Y : Character) return String;\n    --  Concatenate two characters\n \n-   procedure Str_Normalize (A : in out String);\n-   --  Initialize String object if pragma Normalize_Scalars is in effect.\n-\n-   procedure Wide_Str_Normalize (A : in out Wide_String);\n-   --  Ditto for Wide_String.\n-\n-   pragma Inline (Str_Normalize);\n-   pragma Inline (Wide_Str_Normalize);\n end System.String_Ops;"}, {"sha": "8d4604552dc931c5772d94a08ba5b09c5d6baae3", "filename": "gcc/ada/s-valwch.adb", "status": "modified", "additions": 32, "deletions": 15, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/82c80734715c801643075ab68c5c9a5e00da1b03/gcc%2Fada%2Fs-valwch.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/82c80734715c801643075ab68c5c9a5e00da1b03/gcc%2Fada%2Fs-valwch.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-valwch.adb?ref=82c80734715c801643075ab68c5c9a5e00da1b03", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1992-1997, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2005, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -31,6 +31,7 @@\n --                                                                          --\n ------------------------------------------------------------------------------\n \n+with Interfaces;      use Interfaces;\n with System.Val_Util; use System.Val_Util;\n with System.WCh_Con;  use System.WCh_Con;\n with System.WCh_StW;  use System.WCh_StW;\n@@ -42,9 +43,27 @@ package body System.Val_WChar is\n    --------------------------\n \n    function Value_Wide_Character\n-      (Str  : String;\n-       EM   : WC_Encoding_Method)\n-       return Wide_Character\n+      (Str : String;\n+       EM  : WC_Encoding_Method) return Wide_Character\n+   is\n+      WWC : constant Wide_Wide_Character :=\n+              Value_Wide_Wide_Character (Str, EM);\n+      WWV : constant Unsigned_32 := Wide_Wide_Character'Pos (WWC);\n+   begin\n+      if WWV > 16#FFFF# then\n+         raise Constraint_Error;\n+      else\n+         return Wide_Character'Val (WWV);\n+      end if;\n+   end Value_Wide_Character;\n+\n+   -------------------------------\n+   -- Value_Wide_Wide_Character --\n+   -------------------------------\n+\n+   function Value_Wide_Wide_Character\n+      (Str : String;\n+       EM  : System.WCh_Con.WC_Encoding_Method) return Wide_Wide_Character\n    is\n       F : Natural;\n       L : Natural;\n@@ -60,21 +79,20 @@ package body System.Val_WChar is\n          --  If just three characters, simple character case\n \n          if L - F = 2 then\n-            return Wide_Character'Val (Character'Pos (S (F + 1)));\n+            return Wide_Wide_Character'Val (Character'Pos (S (F + 1)));\n \n          --  Otherwise must be a wide character in quotes. The easiest\n-         --  thing is to convert the string to a wide string and then\n+         --  thing is to convert the string to a wide wide string and then\n          --  pick up the single character that it should contain.\n \n          else\n             declare\n-               WS : constant Wide_String :=\n-                      String_To_Wide_String (S (F + 1 .. L - 1), EM);\n+               WS : constant Wide_Wide_String :=\n+                      String_To_Wide_Wide_String (S (F + 1 .. L - 1), EM);\n \n             begin\n                if WS'Length /= 1 then\n                   raise Constraint_Error;\n-\n                else\n                   return WS (WS'First);\n                end if;\n@@ -84,29 +102,28 @@ package body System.Val_WChar is\n       --  the last two values of the type have language-defined names:\n \n       elsif S = \"FFFE\" then\n-         return Wide_Character'Val (16#FFFE#);\n+         return Wide_Wide_Character'Val (16#FFFE#);\n \n       elsif S = \"FFFF\" then\n-         return Wide_Character'Val (16#FFFF#);\n+         return Wide_Wide_Character'Val (16#FFFF#);\n \n       --  Otherwise must be a control character\n \n       else\n          for C in Character'Val (16#00#) .. Character'Val (16#1F#) loop\n             if S (F .. L) = Character'Image (C) then\n-               return Wide_Character'Val (Character'Pos (C));\n+               return Wide_Wide_Character'Val (Character'Pos (C));\n             end if;\n          end loop;\n \n          for C in Character'Val (16#7F#) .. Character'Val (16#9F#) loop\n             if S (F .. L) = Character'Image (C) then\n-               return Wide_Character'Val (Character'Pos (C));\n+               return Wide_Wide_Character'Val (Character'Pos (C));\n             end if;\n          end loop;\n \n          raise Constraint_Error;\n       end if;\n-\n-   end Value_Wide_Character;\n+   end Value_Wide_Wide_Character;\n \n end System.Val_WChar;"}, {"sha": "5075f756c2e1fc9668eae41da5a1019157b22091", "filename": "gcc/ada/s-valwch.ads", "status": "modified", "additions": 10, "deletions": 4, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/82c80734715c801643075ab68c5c9a5e00da1b03/gcc%2Fada%2Fs-valwch.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/82c80734715c801643075ab68c5c9a5e00da1b03/gcc%2Fada%2Fs-valwch.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-valwch.ads?ref=82c80734715c801643075ab68c5c9a5e00da1b03", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---           Copyright (C) 1992-2000 Free Software Foundation, Inc.         --\n+--           Copyright (C) 1992-2005 Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -31,15 +31,21 @@\n --                                                                          --\n ------------------------------------------------------------------------------\n \n+--  Processing for Wide_[Wide_]Value attribute\n+\n with System.WCh_Con;\n \n package System.Val_WChar is\n pragma Pure (Val_WChar);\n \n    function Value_Wide_Character\n-      (Str  : String;\n-       EM   : System.WCh_Con.WC_Encoding_Method)\n-       return Wide_Character;\n+      (Str : String;\n+       EM  : System.WCh_Con.WC_Encoding_Method) return Wide_Character;\n+   --  Computes Wide_Character'Value (Str).\n+\n+   function Value_Wide_Wide_Character\n+      (Str : String;\n+       EM  : System.WCh_Con.WC_Encoding_Method) return Wide_Wide_Character;\n    --  Computes Wide_Character'Value (Str).\n \n end System.Val_WChar;"}, {"sha": "77ee233b70f022a1616e1f7d23d6ef89f72e04ec", "filename": "gcc/ada/s-wchcnv.adb", "status": "modified", "additions": 243, "deletions": 87, "changes": 330, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/82c80734715c801643075ab68c5c9a5e00da1b03/gcc%2Fada%2Fs-wchcnv.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/82c80734715c801643075ab68c5c9a5e00da1b03/gcc%2Fada%2Fs-wchcnv.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-wchcnv.adb?ref=82c80734715c801643075ab68c5c9a5e00da1b03", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1992-2001 Free Software Foundation, Inc.          --\n+--          Copyright (C) 1992-2005 Free Software Foundation, Inc.          --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -41,54 +41,70 @@ with System.WCh_JIS; use System.WCh_JIS;\n \n package body System.WCh_Cnv is\n \n-   --------------------------------\n-   -- Char_Sequence_To_Wide_Char --\n-   --------------------------------\n+   -----------------------------\n+   -- Char_Sequence_To_UTF_32 --\n+   -----------------------------\n \n-   function Char_Sequence_To_Wide_Char\n-     (C    : Character;\n-      EM   : WC_Encoding_Method)\n-      return Wide_Character\n+   function Char_Sequence_To_UTF_32\n+     (C       : Character;\n+      EM      : WC_Encoding_Method) return UTF_32_Code\n    is\n-      B1 : Integer;\n+      B1 : Unsigned_32;\n       C1 : Character;\n-      U  : Unsigned_16;\n-      W  : Unsigned_16;\n+      U  : Unsigned_32;\n+      W  : Unsigned_32;\n \n       procedure Get_Hex (N : Character);\n       --  If N is a hex character, then set B1 to 16 * B1 + character N.\n       --  Raise Constraint_Error if character N is not a hex character.\n \n+      procedure Get_UTF_Byte;\n+      pragma Inline (Get_UTF_Byte);\n+      --  Used to interpret a 2#10xxxxxx# continuation byte in UTF-8 mode.\n+      --  Reads a byte, and raises CE if the first two bits are not 10.\n+      --  Otherwise shifts W 6 bits left and or's in the 6 xxxxxx bits.\n+\n       -------------\n       -- Get_Hex --\n       -------------\n \n       procedure Get_Hex (N : Character) is\n-         B2 : constant Integer := Character'Pos (N);\n-\n+         B2 : constant Unsigned_32 := Character'Pos (N);\n       begin\n          if B2 in Character'Pos ('0') .. Character'Pos ('9') then\n             B1 := B1 * 16 + B2 - Character'Pos ('0');\n-\n          elsif B2 in Character'Pos ('A') .. Character'Pos ('F') then\n             B1 := B1 * 16 + B2 - (Character'Pos ('A') - 10);\n-\n          elsif B2 in Character'Pos ('a') .. Character'Pos ('f') then\n             B1 := B1 * 16 + B2 - (Character'Pos ('a') - 10);\n-\n          else\n             raise Constraint_Error;\n          end if;\n       end Get_Hex;\n \n-   --  Start of processing for Char_Sequence_To_Wide_Char\n+      ------------------\n+      -- Get_UTF_Byte --\n+      ------------------\n+\n+      procedure Get_UTF_Byte is\n+      begin\n+         U := Unsigned_32 (Character'Pos (In_Char));\n+\n+         if (U and 2#11000000#) /= 2#10_000000# then\n+            raise Constraint_Error;\n+         end if;\n+\n+         W := Shift_Left (W, 6)  or (U and 2#00111111#);\n+      end Get_UTF_Byte;\n+\n+   --  Start of processing for Char_Sequence_To_Wide\n \n    begin\n       case EM is\n \n          when WCEM_Hex =>\n             if C /= ASCII.ESC then\n-               return Wide_Character'Val (Character'Pos (C));\n+               return Character'Pos (C);\n \n             else\n                B1 := 0;\n@@ -97,82 +113,106 @@ package body System.WCh_Cnv is\n                Get_Hex (In_Char);\n                Get_Hex (In_Char);\n \n-               return Wide_Character'Val (B1);\n+               return UTF_32_Code (B1);\n             end if;\n \n          when WCEM_Upper =>\n             if C > ASCII.DEL then\n-               return\n-                 Wide_Character'Val\n-                   (Integer (256 * Character'Pos (C)) +\n-                    Character'Pos (In_Char));\n+               return 256 * Character'Pos (C) + Character'Pos (In_Char);\n             else\n-               return Wide_Character'Val (Character'Pos (C));\n+               return Character'Pos (C);\n             end if;\n \n          when WCEM_Shift_JIS =>\n             if C > ASCII.DEL then\n-               return Shift_JIS_To_JIS (C, In_Char);\n+               return Wide_Character'Pos (Shift_JIS_To_JIS (C, In_Char));\n             else\n-               return Wide_Character'Val (Character'Pos (C));\n+               return Character'Pos (C);\n             end if;\n \n          when WCEM_EUC =>\n             if C > ASCII.DEL then\n-               return EUC_To_JIS (C, In_Char);\n+               return Wide_Character'Pos (EUC_To_JIS (C, In_Char));\n             else\n-               return Wide_Character'Val (Character'Pos (C));\n+               return Character'Pos (C);\n             end if;\n \n          when WCEM_UTF8 =>\n-            if C > ASCII.DEL then\n \n-               --  16#0080#-16#07ff#: 2#110xxxxx# 2#10xxxxxx#\n-               --  16#0800#-16#ffff#: 2#1110xxxx# 2#10xxxxxx# 2#10xxxxxx#\n+            --  Note: for details of UTF8 encoding see RFC 3629\n \n-               U := Unsigned_16 (Character'Pos (C));\n+            U := Unsigned_32 (Character'Pos (C));\n \n-               if (U and 2#11100000#) = 2#11000000# then\n-                  W := Shift_Left (U and 2#00011111#, 6);\n-                  U := Unsigned_16 (Character'Pos (In_Char));\n+            --  16#00_0000#-16#00_007F#: 0xxxxxxx\n \n-                  if (U and 2#11000000#) /= 2#10000000# then\n-                     raise Constraint_Error;\n-                  end if;\n+            if (U and 2#10000000#) = 2#00000000# then\n+               return Character'Pos (C);\n \n-                  W := W or (U and 2#00111111#);\n+            --  16#00_0080#-16#00_07FF#: 110xxxxx 10xxxxxx\n \n-               elsif (U and 2#11110000#) = 2#11100000# then\n-                  W := Shift_Left (U and 2#00001111#, 12);\n-                  U := Unsigned_16 (Character'Pos (In_Char));\n+            elsif (U and 2#11100000#) = 2#110_00000# then\n+               W := Shift_Left (U and 2#00011111#, 6);\n+               U := Unsigned_32 (Character'Pos (In_Char));\n \n-                  if (U and 2#11000000#) /= 2#10000000# then\n-                     raise Constraint_Error;\n-                  end if;\n+               if (U and 2#11000000#) /= 2#10_000000# then\n+                  raise Constraint_Error;\n+               end if;\n \n-                  W := W or Shift_Left (U and 2#00111111#, 6);\n-                  U := Unsigned_16 (Character'Pos (In_Char));\n+               W := W or (U and 2#00111111#);\n \n-                  if (U and 2#11000000#) /= 2#10000000# then\n-                     raise Constraint_Error;\n-                  end if;\n+               return UTF_32_Code (W);\n \n-                  W := W or (U and 2#00111111#);\n+            --  16#00_0800#-16#00_ffff#: 1110xxxx 10xxxxxx 10xxxxxx\n \n-               else\n-                  raise Constraint_Error;\n-               end if;\n+            elsif (U and 2#11110000#) = 2#1110_0000# then\n+               W := U and 2#00001111#;\n+               Get_UTF_Byte;\n+               Get_UTF_Byte;\n+               return UTF_32_Code (W);\n+\n+            --  16#01_0000#-16#10_FFFF#: 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx\n+\n+            elsif (U and 2#11111000#) = 2#11110_000# then\n+               W := U and 2#00000111#;\n+\n+               for K in 1 .. 3 loop\n+                  Get_UTF_Byte;\n+               end loop;\n \n-               return Wide_Character'Val (W);\n+               return UTF_32_Code (W);\n+\n+            --  16#0020_0000#-16#03FF_FFFF#: 111110xx 10xxxxxx 10xxxxxx\n+            --                               10xxxxxx 10xxxxxx\n+\n+            elsif (U and 2#11111100#) = 2#111110_00# then\n+               W := U and 2#00000011#;\n+\n+               for K in 1 .. 4 loop\n+                  Get_UTF_Byte;\n+               end loop;\n+\n+               return UTF_32_Code (W);\n+\n+            --  16#0400_0000#-16#7FFF_FFFF#: 1111110x 10xxxxxx 10xxxxxx\n+            --                               10xxxxxx 10xxxxxx 10xxxxxx\n+\n+            elsif (U and 2#11111110#) = 2#1111110_0# then\n+               W := U and 2#00000001#;\n+\n+               for K in 1 .. 5 loop\n+                  Get_UTF_Byte;\n+               end loop;\n+\n+               return UTF_32_Code (W);\n \n             else\n-               return Wide_Character'Val (Character'Pos (C));\n+               raise Constraint_Error;\n             end if;\n \n          when WCEM_Brackets =>\n \n             if C /= '[' then\n-               return Wide_Character'Val (Character'Pos (C));\n+               return Character'Pos (C);\n             end if;\n \n             if In_Char /= '\"' then\n@@ -182,62 +222,100 @@ package body System.WCh_Cnv is\n             B1 := 0;\n             Get_Hex (In_Char);\n             Get_Hex (In_Char);\n+\n             C1 := In_Char;\n \n             if C1 /= '\"' then\n                Get_Hex (C1);\n                Get_Hex (In_Char);\n+\n                C1 := In_Char;\n \n                if C1 /= '\"' then\n-                  raise Constraint_Error;\n+                  Get_Hex (C1);\n+                  Get_Hex (In_Char);\n+\n+                  C1 := In_Char;\n+\n+                  if C1 /= '\"' then\n+                     Get_Hex (C1);\n+                     Get_Hex (In_Char);\n+\n+                     if B1 > Unsigned_32 (UTF_32_Code'Last) then\n+                        raise Constraint_Error;\n+                     end if;\n+\n+                     if In_Char /= '\"' then\n+                        raise Constraint_Error;\n+                     end if;\n+                  end if;\n                end if;\n             end if;\n \n             if In_Char /= ']' then\n                raise Constraint_Error;\n             end if;\n \n-            return Wide_Character'Val (B1);\n+            return UTF_32_Code (B1);\n \n       end case;\n-   end Char_Sequence_To_Wide_Char;\n+   end Char_Sequence_To_UTF_32;\n \n    --------------------------------\n-   -- Wide_Char_To_Char_Sequence --\n+   -- Char_Sequence_To_Wide_Char --\n    --------------------------------\n \n-   procedure Wide_Char_To_Char_Sequence\n-     (WC : Wide_Character;\n-      EM : WC_Encoding_Method)\n+   function Char_Sequence_To_Wide_Char\n+     (C  : Character;\n+      EM : System.WCh_Con.WC_Encoding_Method) return Wide_Character\n+   is\n+      function Char_Sequence_To_UTF is new Char_Sequence_To_UTF_32 (In_Char);\n+\n+      U : constant UTF_32_Code := Char_Sequence_To_UTF (C, EM);\n+\n+   begin\n+      if U > 16#FFFF# then\n+         raise Constraint_Error;\n+      else\n+         return Wide_Character'Val (U);\n+      end if;\n+   end Char_Sequence_To_Wide_Char;\n+\n+   -----------------------------\n+   -- UTF_32_To_Char_Sequence --\n+   -----------------------------\n+\n+   procedure UTF_32_To_Char_Sequence\n+     (Val : UTF_32_Code;\n+      EM  : System.WCh_Con.WC_Encoding_Method)\n    is\n-      Val    : constant Natural := Wide_Character'Pos (WC);\n-      Hexc   : constant array (0 .. 15) of Character := \"0123456789ABCDEF\";\n+      Hexc : constant array (UTF_32_Code range 0 .. 15) of Character :=\n+               \"0123456789ABCDEF\";\n+\n       C1, C2 : Character;\n-      U      : Unsigned_16;\n+      U      : Unsigned_32;\n \n    begin\n       case EM is\n \n          when WCEM_Hex =>\n             if Val < 256 then\n                Out_Char (Character'Val (Val));\n-\n-            else\n+            elsif Val <= 16#FFFF# then\n                Out_Char (ASCII.ESC);\n                Out_Char (Hexc (Val / (16**3)));\n                Out_Char (Hexc ((Val / (16**2)) mod 16));\n                Out_Char (Hexc ((Val / 16) mod 16));\n                Out_Char (Hexc (Val mod 16));\n+            else\n+               raise Constraint_Error;\n             end if;\n \n          when WCEM_Upper =>\n             if Val < 128 then\n                Out_Char (Character'Val (Val));\n-\n-            elsif Val < 16#8000# then\n+            elsif Val < 16#8000# or else Val > 16#FFFF# then\n                raise Constraint_Error;\n-\n             else\n                Out_Char (Character'Val (Val / 256));\n                Out_Char (Character'Val (Val mod 256));\n@@ -246,58 +324,136 @@ package body System.WCh_Cnv is\n          when WCEM_Shift_JIS =>\n             if Val < 128 then\n                Out_Char (Character'Val (Val));\n-            else\n-               JIS_To_Shift_JIS (WC, C1, C2);\n+            elsif Val <= 16#FFFF# then\n+               JIS_To_Shift_JIS (Wide_Character'Val (Val), C1, C2);\n                Out_Char (C1);\n                Out_Char (C2);\n+            else\n+               raise Constraint_Error;\n             end if;\n \n          when WCEM_EUC =>\n             if Val < 128 then\n                Out_Char (Character'Val (Val));\n-            else\n-               JIS_To_EUC (WC, C1, C2);\n+            elsif Val <= 16#FFFF# then\n+               JIS_To_EUC (Wide_Character'Val (Val), C1, C2);\n                Out_Char (C1);\n                Out_Char (C2);\n+            else\n+               raise Constraint_Error;\n             end if;\n \n          when WCEM_UTF8 =>\n-            U := Unsigned_16 (Val);\n \n-            --  16#0000#-16#007f#: 2#0xxxxxxx#\n-            --  16#0080#-16#07ff#: 2#110xxxxx# 2#10xxxxxx#\n-            --  16#0800#-16#ffff#: 2#1110xxxx# 2#10xxxxxx# 2#10xxxxxx#\n+            --  Note: for details of UTF8 encoding see RFC 3629\n+\n+            U := Unsigned_32 (Val);\n+\n+            --  16#00_0000#-16#00_007F#: 0xxxxxxx\n \n-            if U < 16#80# then\n+            if U <= 16#00_007F# then\n                Out_Char (Character'Val (U));\n \n-            elsif U < 16#0800# then\n+            --  16#00_0080#-16#00_07FF#: 110xxxxx 10xxxxxx\n+\n+            elsif U <= 16#00_07FF# then\n                Out_Char (Character'Val (2#11000000# or Shift_Right (U, 6)));\n                Out_Char (Character'Val (2#10000000# or (U and 2#00111111#)));\n \n-            else\n+            --  16#00_0800#-16#00_FFFF#: 1110xxxx 10xxxxxx 10xxxxxx\n+\n+            elsif U <= 16#00_FFFF# then\n                Out_Char (Character'Val (2#11100000# or Shift_Right (U, 12)));\n                Out_Char (Character'Val (2#10000000# or (Shift_Right (U, 6)\n-                                                         and 2#00111111#)));\n+                                                          and 2#00111111#)));\n+               Out_Char (Character'Val (2#10000000# or (U and 2#00111111#)));\n+\n+            --  16#01_0000#-16#10_FFFF#: 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx\n+\n+            elsif U <= 16#10_FFFF# then\n+               Out_Char (Character'Val (2#11110000# or Shift_Right (U, 18)));\n+               Out_Char (Character'Val (2#10000000# or (Shift_Right (U, 12)\n+                                                          and 2#00111111#)));\n+               Out_Char (Character'Val (2#10000000# or (Shift_Right (U, 6)\n+                                                          and 2#00111111#)));\n+               Out_Char (Character'Val (2#10000000# or (U and 2#00111111#)));\n+\n+            --  16#0020_0000#-16#03FF_FFFF#: 111110xx 10xxxxxx 10xxxxxx\n+            --                               10xxxxxx 10xxxxxx\n+\n+            elsif U <= 16#03FF_FFFF# then\n+               Out_Char (Character'Val (2#11111000# or Shift_Right (U, 24)));\n+               Out_Char (Character'Val (2#10000000# or (Shift_Right (U, 18)\n+                                                          and 2#00111111#)));\n+               Out_Char (Character'Val (2#10000000# or (Shift_Right (U, 12)\n+                                                          and 2#00111111#)));\n+               Out_Char (Character'Val (2#10000000# or (Shift_Right (U, 6)\n+                                                          and 2#00111111#)));\n                Out_Char (Character'Val (2#10000000# or (U and 2#00111111#)));\n+\n+            --  16#0400_0000#-16#7FFF_FFFF#: 1111110x 10xxxxxx 10xxxxxx\n+            --                               10xxxxxx 10xxxxxx 10xxxxxx\n+\n+            elsif U <= 16#7FFF_FFFF# then\n+               Out_Char (Character'Val (2#11111100# or Shift_Right (U, 30)));\n+               Out_Char (Character'Val (2#10000000# or (Shift_Right (U, 24)\n+                                                          and 2#00111111#)));\n+               Out_Char (Character'Val (2#10000000# or (Shift_Right (U, 18)\n+                                                          and 2#00111111#)));\n+               Out_Char (Character'Val (2#10000000# or (Shift_Right (U, 12)\n+                                                          and 2#00111111#)));\n+               Out_Char (Character'Val (2#10000000# or (Shift_Right (U, 6)\n+                                                          and 2#00111111#)));\n+               Out_Char (Character'Val (2#10000000# or (U and 2#00111111#)));\n+\n+            else\n+               raise Constraint_Error;\n             end if;\n \n          when WCEM_Brackets =>\n-\n             if Val < 256 then\n                Out_Char (Character'Val (Val));\n \n             else\n                Out_Char ('[');\n                Out_Char ('\"');\n-               Out_Char (Hexc (Val / (16**3)));\n-               Out_Char (Hexc ((Val / (16**2)) mod 16));\n+\n+               if Val > 16#FFFF# then\n+                  if Val > 16#00FF_FFFF# then\n+                     if Val > 16#7FFF_FFFF# then\n+                        raise Constraint_Error;\n+                     end if;\n+\n+                     Out_Char (Hexc (Val / 16 ** 7));\n+                     Out_Char (Hexc ((Val / 16 ** 6) mod 16));\n+                  end if;\n+\n+                  Out_Char (Hexc ((Val / 16 ** 5) mod 16));\n+                  Out_Char (Hexc ((Val / 16 ** 4) mod 16));\n+               end if;\n+\n+               Out_Char (Hexc ((Val / 16 ** 3) mod 16));\n+               Out_Char (Hexc ((Val / 16 ** 2) mod 16));\n                Out_Char (Hexc ((Val / 16) mod 16));\n                Out_Char (Hexc (Val mod 16));\n+\n                Out_Char ('\"');\n                Out_Char (']');\n             end if;\n       end case;\n+   end UTF_32_To_Char_Sequence;\n+\n+   --------------------------------\n+   -- Wide_Char_To_Char_Sequence --\n+   --------------------------------\n+\n+   procedure Wide_Char_To_Char_Sequence\n+     (WC : Wide_Character;\n+      EM : System.WCh_Con.WC_Encoding_Method)\n+   is\n+      procedure UTF_To_Char_Sequence is new UTF_32_To_Char_Sequence (Out_Char);\n+   begin\n+      UTF_To_Char_Sequence (Wide_Character'Pos (WC), EM);\n    end Wide_Char_To_Char_Sequence;\n \n end System.WCh_Cnv;"}, {"sha": "e0bde89604ae0f061bd1ba6fa09bf673b154dc75", "filename": "gcc/ada/s-wchcnv.ads", "status": "modified", "additions": 28, "deletions": 9, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/82c80734715c801643075ab68c5c9a5e00da1b03/gcc%2Fada%2Fs-wchcnv.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/82c80734715c801643075ab68c5c9a5e00da1b03/gcc%2Fada%2Fs-wchcnv.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-wchcnv.ads?ref=82c80734715c801643075ab68c5c9a5e00da1b03", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---           Copyright (C) 1992-2003 Free Software Foundation, Inc.         --\n+--           Copyright (C) 1992-2005 Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -31,31 +31,40 @@\n --                                                                          --\n ------------------------------------------------------------------------------\n \n---  This package contains generic subprograms used for converting between\n---  sequences of Character and Wide_Character. All access to wide character\n---  sequences is isolated in this unit.\n-\n --  This unit may be used directly from an application program by providing\n --  an appropriate WITH, and the interface can be expected to remain stable.\n \n with System.WCh_Con;\n \n package System.WCh_Cnv is\n-pragma Pure (WCh_Cnv);\n+   pragma Pure (WCh_Cnv);\n+\n+   type UTF_32_Code is range 0 .. 16#7FFF_FFFF#;\n+   for UTF_32_Code'Size use 32;\n+   --  Range of allowed UTF-32 encoding values\n \n    generic\n       with function In_Char return Character;\n    function Char_Sequence_To_Wide_Char\n-     (C    : Character;\n-      EM   : System.WCh_Con.WC_Encoding_Method)\n-      return Wide_Character;\n+     (C  : Character;\n+      EM : System.WCh_Con.WC_Encoding_Method) return Wide_Character;\n    --  C is the first character of a sequence of one or more characters which\n    --  represent a wide character sequence. Calling the function In_Char for\n    --  additional characters as required, Char_To_Wide_Char returns the\n    --  corresponding wide character value. Constraint_Error is raised if the\n    --  sequence of characters encountered is not a valid wide character\n    --  sequence for the given encoding method.\n \n+   generic\n+      with function In_Char return Character;\n+   function Char_Sequence_To_UTF_32\n+     (C  : Character;\n+      EM : System.WCh_Con.WC_Encoding_Method) return UTF_32_Code;\n+   --  This is similar to the above, but the function returns a code from\n+   --  the full UTF_32 code set, which covers the full range of possible\n+   --  values in Wide_Wide_Character. The result can be converted to\n+   --  Wide_Wide_Character form using Wide_Wide_Character'Val.\n+\n    generic\n       with procedure Out_Char (C : Character);\n    procedure Wide_Char_To_Char_Sequence\n@@ -66,4 +75,14 @@ pragma Pure (WCh_Cnv);\n    --  Constraint_Error is raised if the given wide character value is\n    --  not a valid value for the given encoding method.\n \n+   generic\n+      with procedure Out_Char (C : Character);\n+   procedure UTF_32_To_Char_Sequence\n+     (Val : UTF_32_Code;\n+      EM  : System.WCh_Con.WC_Encoding_Method);\n+   --  This is similar to the above, but the input value is a code from the\n+   --  full UTF_32 code set, which covers the full range of possible values\n+   --  in Wide_Wide_Character. To convert a Wide_Wide_Character value, the\n+   --  caller can use Wide_Wide_Character'Pos in the call.\n+\n end System.WCh_Cnv;"}, {"sha": "eecfe9f34ee21b04145c5d7c3291828c94cc8242", "filename": "gcc/ada/s-wchcon.ads", "status": "modified", "additions": 30, "deletions": 22, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/82c80734715c801643075ab68c5c9a5e00da1b03/gcc%2Fada%2Fs-wchcon.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/82c80734715c801643075ab68c5c9a5e00da1b03/gcc%2Fada%2Fs-wchcon.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-wchcon.ads?ref=82c80734715c801643075ab68c5c9a5e00da1b03", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---          Copyright (C) 1992-2003 Free Software Foundation, Inc.          --\n+--          Copyright (C) 1992-2005 Free Software Foundation, Inc.          --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -46,8 +46,8 @@ pragma Pure (WCh_Con);\n    -------------------------------------\n \n    --  A wide character encoding method is a method for uniquely representing\n-   --  a Wide_Character value using a one or more Character values. Three\n-   --  types of encoding method are supported by GNAT:\n+   --  a Wide_Character or Wide_Wide_Character value using a one or more\n+   --  Character values. Three types of encoding method are supported by GNAT:\n \n    --    An escape encoding method uses ESC as the first character of the\n    --    sequence, and subsequent characters determine the wide character\n@@ -62,9 +62,10 @@ pragma Pure (WCh_Con);\n    --    Any character in the lower half (16#00# .. 16#7F#) represents\n    --    itself as a single character.\n \n-   --    The brackets notation, where a wide character is represented\n-   --    by the sequence [\"xx\"] or [\"xxxx\"] where xx are hexadecimal\n-   --    characters.\n+   --    The brackets notation, where a wide character is represented by the\n+   --    sequence [\"xx\"] or [\"xxxx\"] or [\"xxxxxx\"] where xx are hexadecimal\n+   --    characters. Note that currently this is the only encoding that\n+   --    supports the full UTF-32 range.\n \n    --  Note that GNAT does not currently support escape-in, escape-out\n    --  encoding methods, where an escape sequence is used to set a mode\n@@ -130,25 +131,32 @@ pragma Pure (WCh_Con);\n    --  An ISO 10646-1 BMP/Unicode wide character is represented in\n    --  UCS Transformation Format 8 (UTF-8) as defined in Annex R of ISO\n    --  10646-1/Am.2.  Depending on the character value, a Unicode character\n-   --  is represented as the one, two, or three byte sequence\n+   --  is represented as the one to six byte sequence.\n    --\n-   --    16#0000#-16#007f#: 2#0xxxxxxx#\n-   --    16#0080#-16#07ff#: 2#110xxxxx# 2#10xxxxxx#\n-   --    16#0800#-16#ffff#: 2#1110xxxx# 2#10xxxxxx# 2#10xxxxxx#\n+   --    16#0000_0000#-16#0000_007f#: 2#0xxxxxxx#\n+   --    16#0000_0080#-16#0000_07ff#: 2#110xxxxx# 2#10xxxxxx#\n+   --    16#0000_0800#-16#0000_ffff#: 2#1110xxxx# 2#10xxxxxx# 2#10xxxxxx#\n+   --    16#0001_0000#-16#001F_FFFF#: 2#11110xxx# 2#10xxxxxx# 2#10xxxxxx#\n+   --                                 2#10xxxxxx#\n+   --    16#0020_0000#-16#03FF_FFFF#: 2#111110xx# 2#10xxxxxx# 2#10xxxxxx#\n+   --                                 2#10xxxxxx# 2#10xxxxxx#\n+   --    16#0400_0000#-16#7FFF_FFFF#: 2#1111110x# 2#10xxxxxx# 2#10xxxxxx#\n+   --                                 2#10xxxxxx# 2#10xxxxxx# 2#10xxxxxx#\n    --\n-   --  where the xxx bits correspond to the left-padded bits of the the\n+   --  where the xxx bits correspond to the left-padded bits of the\n    --  16-bit character value. Note that all lower half ASCII characters\n    --  are represented as ASCII bytes and all upper half characters and\n-   --  other wide characters are represented as sequences of upper-half\n-   --  (The full UTF-8 scheme allows for encoding 31-bit characters as\n-   --  6-byte sequences, but in this implementation, all UTF-8 sequences\n-   --  of four or more bytes length will raise a Constraint_Error, as\n-   --  will all illegal UTF-8 sequences.)\n+   --  other wide characters are represented as sequences of upper-half.\n \n    WCEM_Brackets : constant WC_Encoding_Method := 6;\n-   --  A wide character is represented as the sequence [\"abcd\"] where abcd\n-   --  are four hexadecimal characters. In this mode, the sequence [\"ab\"]\n-   --  is also recognized for the case of character codes in the range 0-255.\n+   --  A wide character is represented using one of the following sequences:\n+   --\n+   --    [\"xx\"]\n+   --    [\"xxxx\"]\n+   --    [\"xxxxxx\"]\n+   --    [\"xxxxxxxx\"]\n+   --\n+   --  where xx are hexadecimal digits representing the character code.\n \n    WC_Encoding_Letters : constant array (WC_Encoding_Method) of Character :=\n      (WCEM_Hex       => 'h',\n@@ -170,8 +178,8 @@ pragma Pure (WCh_Con);\n    --  Encoding methods using an upper half character (16#80#..16#FF) at\n    --  the start of the sequence.\n \n-   WC_Longest_Sequence : constant := 8;\n-   --  The longest number of characters that can be used for a wide\n-   --  character sequence for any of the active encoding methods.\n+   WC_Longest_Sequence : constant := 10;\n+   --  The longest number of characters that can be used for a wide character\n+   --  or wide wide character sequence for any of the active encoding methods.\n \n end System.WCh_Con;"}, {"sha": "0deb55631e2f3faa26af5928640fc14b09fd6183", "filename": "gcc/ada/s-wchstw.adb", "status": "modified", "additions": 111, "deletions": 158, "changes": 269, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/82c80734715c801643075ab68c5c9a5e00da1b03/gcc%2Fada%2Fs-wchstw.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/82c80734715c801643075ab68c5c9a5e00da1b03/gcc%2Fada%2Fs-wchstw.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-wchstw.adb?ref=82c80734715c801643075ab68c5c9a5e00da1b03", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1992-2000 Free Software Foundation, Inc.          --\n+--          Copyright (C) 1992-2005 Free Software Foundation, Inc.          --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -31,189 +31,142 @@\n --                                                                          --\n ------------------------------------------------------------------------------\n \n-with Interfaces;     use Interfaces;\n with System.WCh_Con; use System.WCh_Con;\n-with System.WCh_JIS; use System.WCh_JIS;\n+with System.WCh_Cnv; use System.WCh_Cnv;\n \n package body System.WCh_StW is\n \n-   ---------------------------\n-   -- String_To_Wide_String --\n-   ---------------------------\n-\n-   function String_To_Wide_String\n-     (S    : String;\n-      EM   : WC_Encoding_Method)\n-      return Wide_String\n+   -----------------------\n+   -- Local Subprograms --\n+   -----------------------\n+\n+   procedure Get_Next_Code\n+     (S  : String;\n+      P  : in out Natural;\n+      V  : out UTF_32_Code;\n+      EM : WC_Encoding_Method);\n+   --  Scans next character starting at S(P) and returns its value in V. On\n+   --  exit P is updated past the last character read. Raises Constraint_Error\n+   --  if the string is not well formed. Raises Constraint_Error if the code\n+   --  value is greater than 16#7FFF_FFFF#. On entry P <= S'Last.\n+\n+   -------------------\n+   -- Get_Next_Code --\n+   -------------------\n+\n+   procedure Get_Next_Code\n+     (S  : String;\n+      P  : in out Natural;\n+      V  : out UTF_32_Code;\n+      EM : WC_Encoding_Method)\n    is\n-      R  : Wide_String (1 .. S'Length);\n-      RP : Natural;\n-      SP : Natural;\n-      U1 : Unsigned_16;\n-      U2 : Unsigned_16;\n-      U3 : Unsigned_16;\n-      U  : Unsigned_16;\n-\n-      Last : constant Natural := S'Last;\n+      function In_Char return Character;\n+      --  Function to return a character, bumping P, raises Constraint_Error\n+      --  if P > S'Last on entry.\n \n-      function Get_Hex (C : Character) return Unsigned_16;\n-      --  Converts character from hex digit to value in range 0-15. The\n-      --  input must be in 0-9, A-F, or a-f, and no check is needed.\n+      function Get_UTF_32 is new Char_Sequence_To_UTF_32 (In_Char);\n+      --  Function to get next UFT_32 value.\n \n-      procedure Get_Hex_4;\n-      --  Translates four hex characters starting at S (SP) to a single\n-      --  wide character. Used in WCEM_Hex and WCEM_Brackets mode. SP\n-      --  is not modified by the call. The resulting wide character value\n-      --  is stored in R (RP). RP is not modified by the call.\n+      -------------\n+      -- In_Char --\n+      -------------\n \n-      function Get_Hex (C : Character) return Unsigned_16 is\n+      function In_Char return Character is\n       begin\n-         if C in '0' .. '9' then\n-            return Character'Pos (C) - Character'Pos ('0');\n-         elsif C in 'A' .. 'F' then\n-            return Character'Pos (C) - Character'Pos ('A') + 10;\n+         if P > S'Last then\n+            raise Constraint_Error;\n          else\n-            return Character'Pos (C) - Character'Pos ('a') + 10;\n+            P := P + 1;\n+            return S (P - 1);\n          end if;\n-      end Get_Hex;\n+      end In_Char;\n \n-      procedure Get_Hex_4 is\n-      begin\n-         R (RP) := Wide_Character'Val (\n-            Get_Hex (S (SP + 3)) + 16 *\n-              (Get_Hex (S (SP + 2)) + 16 *\n-                (Get_Hex (S (SP + 1)) + 16 *\n-                  (Get_Hex (S (SP + 0))))));\n-      end Get_Hex_4;\n+   begin\n+      --  Check for wide character encoding\n \n-   --  Start of processing for String_To_Wide_String\n+      case EM is\n+         when WCEM_Hex =>\n+            if S (P) = ASCII.ESC then\n+               V := Get_UTF_32 (In_Char, EM);\n+               return;\n+            end if;\n+\n+         when WCEM_Upper | WCEM_Shift_JIS | WCEM_EUC | WCEM_UTF8 =>\n+            if S (P) >= Character'Val (16#80#) then\n+               V := Get_UTF_32 (In_Char, EM);\n+               return;\n+            end if;\n+\n+         when WCEM_Brackets =>\n+            if P + 2 <= S'Last\n+              and then S (P) = '['\n+              and then S (P + 1) = '\"'\n+              and then S (P + 2) /= '\"'\n+            then\n+               V := Get_UTF_32 (In_Char, EM);\n+               return;\n+            end if;\n+      end case;\n+\n+      --  If it is not a wide character code, just get it\n+\n+      V := Character'Pos (S (P));\n+      P := P + 1;\n+   end Get_Next_Code;\n+\n+   ---------------------------\n+   -- String_To_Wide_String --\n+   ---------------------------\n+\n+   function String_To_Wide_String\n+     (S  : String;\n+      EM : WC_Encoding_Method) return Wide_String\n+   is\n+      R  : Wide_String (1 .. S'Length);\n+      RP : Natural;\n+      SP : Natural;\n+      V  : UTF_32_Code;\n \n    begin\n       SP := S'First;\n       RP := 0;\n+      while SP <= S'Last loop\n+         Get_Next_Code (S, SP, V, EM);\n \n-      case EM is\n+         if V > 16#FFFF# then\n+            raise Constraint_Error;\n+         end if;\n \n-         --  ESC-Hex representation\n+         RP := RP + 1;\n+         R (RP) := Wide_Character'Val (V);\n+      end loop;\n \n-         when WCEM_Hex =>\n-            while SP <= Last - 4 loop\n-               RP := RP + 1;\n-\n-               if S (SP) = ASCII.ESC then\n-                  SP := SP + 1;\n-                  Get_Hex_4;\n-                  SP := SP + 4;\n-               else\n-                  R (RP) := Wide_Character'Val (Character'Pos (S (SP)));\n-                  SP := SP + 1;\n-               end if;\n-            end loop;\n-\n-         --  Upper bit shift, internal code = external code\n-\n-         when WCEM_Upper =>\n-            while SP < Last loop\n-               RP := RP + 1;\n-\n-               if S (SP) >= Character'Val (16#80#) then\n-                  U1 := Character'Pos (S (SP));\n-                  U2 := Character'Pos (S (SP + 1));\n-                  R (RP) := Wide_Character'Val (256 * U1 + U2);\n-                  SP := SP + 2;\n-               else\n-                  R (RP) := Wide_Character'Val (Character'Pos (S (SP)));\n-                  SP := SP + 1;\n-               end if;\n-            end loop;\n-\n-         --  Upper bit shift, shift-JIS\n-\n-         when WCEM_Shift_JIS =>\n-            while SP < Last loop\n-               RP := RP + 1;\n-\n-               if S (SP) >= Character'Val (16#80#) then\n-                  R (RP) := Shift_JIS_To_JIS (S (SP), S (SP + 1));\n-                  SP := SP + 2;\n-               else\n-                  R (RP) := Wide_Character'Val (Character'Pos (S (SP)));\n-                  SP := SP + 1;\n-               end if;\n-            end loop;\n-\n-         --  Upper bit shift, EUC\n-\n-         when WCEM_EUC =>\n-            while SP < Last loop\n-               RP := RP + 1;\n-\n-               if S (SP) >= Character'Val (16#80#) then\n-                  R (RP) := EUC_To_JIS (S (SP), S (SP + 1));\n-                  SP := SP + 2;\n-               else\n-                  R (RP) := Wide_Character'Val (Character'Pos (S (SP)));\n-                  SP := SP + 1;\n-               end if;\n-            end loop;\n-\n-         --  Upper bit shift, UTF-8\n-\n-         when WCEM_UTF8 =>\n-            while SP < Last loop\n-               RP := RP + 1;\n-\n-               if S (SP) >= Character'Val (16#80#) then\n-                  U1 := Character'Pos (S (SP));\n-                  U2 := Character'Pos (S (SP + 1));\n-\n-                  U := Shift_Left (U1 and 2#00011111#, 6) +\n-                         (U2 and 2#00111111#);\n-                  SP := SP + 2;\n-\n-                  if U1 >= 2#11100000# then\n-                     U3 := Character'Pos (S (SP));\n-                     U := Shift_Left (U, 6) + (U3 and 2#00111111#);\n-                     SP := SP + 1;\n-                  end if;\n-\n-                  R (RP) := Wide_Character'Val (U);\n-\n-               else\n-                  R (RP) := Wide_Character'Val (Character'Pos (S (SP)));\n-                  SP := SP + 1;\n-               end if;\n-            end loop;\n-\n-         --  Brackets representation\n+      return R (1 .. RP);\n+   end String_To_Wide_String;\n \n-         when WCEM_Brackets =>\n-            while SP <= Last - 7 loop\n-               RP := RP + 1;\n-\n-               if S (SP) = '['\n-                 and then S (SP + 1) = '\"'\n-                 and then S (SP + 2) /= '\"'\n-               then\n-                  SP := SP + 2;\n-                  Get_Hex_4;\n-                  SP := SP + 6;\n-\n-               else\n-                  R (RP) := Wide_Character'Val (Character'Pos (S (SP)));\n-                  SP := SP + 1;\n-               end if;\n-            end loop;\n+   --------------------------------\n+   -- String_To_Wide_Wide_String --\n+   --------------------------------\n \n-      end case;\n+   function String_To_Wide_Wide_String\n+     (S  : String;\n+      EM : WC_Encoding_Method) return Wide_Wide_String\n+   is\n+      R  : Wide_Wide_String (1 .. S'Length);\n+      RP : Natural;\n+      SP : Natural;\n+      V  : UTF_32_Code;\n \n-      while SP <= Last loop\n+   begin\n+      SP := S'First;\n+      RP := 0;\n+      while SP <= S'Last loop\n+         Get_Next_Code (S, SP, V, EM);\n          RP := RP + 1;\n-         R (RP) := Wide_Character'Val (Character'Pos (S (SP)));\n-         SP := SP + 1;\n+         R (RP) := Wide_Wide_Character'Val (V);\n       end loop;\n \n       return R (1 .. RP);\n-   end String_To_Wide_String;\n+   end String_To_Wide_Wide_String;\n \n end System.WCh_StW;"}, {"sha": "c1d33eb3f85566af15352676990a65c2fba16a74", "filename": "gcc/ada/s-wchstw.ads", "status": "modified", "additions": 10, "deletions": 6, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/82c80734715c801643075ab68c5c9a5e00da1b03/gcc%2Fada%2Fs-wchstw.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/82c80734715c801643075ab68c5c9a5e00da1b03/gcc%2Fada%2Fs-wchstw.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-wchstw.ads?ref=82c80734715c801643075ab68c5c9a5e00da1b03", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---          Copyright (C) 1992-1998 Free Software Foundation, Inc.          --\n+--          Copyright (C) 1992-2005 Free Software Foundation, Inc.          --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -31,18 +31,17 @@\n --                                                                          --\n ------------------------------------------------------------------------------\n \n---  This package contains the routine used to convert strings to wide\n---  strings for use by wide character attributes (value, image etc.)\n+--  This package contains the routine used to convert strings to wide (wide)\n+--  strings for use by wide (wide) character attributes (value, image etc.)\n \n with System.WCh_Con;\n \n package System.WCh_StW is\n pragma Pure (WCh_StW);\n \n    function String_To_Wide_String\n-     (S    : String;\n-      EM   : System.WCh_Con.WC_Encoding_Method)\n-      return Wide_String;\n+     (S  : String;\n+      EM : System.WCh_Con.WC_Encoding_Method) return Wide_String;\n    --  This routine simply takes its argument and converts it to wide string\n    --  format. In the context of the Wide_Image attribute, the argument is\n    --  the corresponding 'Image attribute. Any wide character escape sequences\n@@ -57,4 +56,9 @@ pragma Pure (WCh_StW);\n    --  Note: in the WCEM_Brackets case, the brackets escape sequence is used\n    --  only for codes greater than 16#FF#.\n \n+   function String_To_Wide_Wide_String\n+     (S  : String;\n+      EM : System.WCh_Con.WC_Encoding_Method) return Wide_Wide_String;\n+   --  Same function with Wide_Wide_String output\n+\n end System.WCh_StW;"}, {"sha": "21174aad370f9e8025e12ad7f501c672c896fce8", "filename": "gcc/ada/s-wchwts.adb", "status": "modified", "additions": 70, "deletions": 109, "changes": 179, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/82c80734715c801643075ab68c5c9a5e00da1b03/gcc%2Fada%2Fs-wchwts.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/82c80734715c801643075ab68c5c9a5e00da1b03/gcc%2Fada%2Fs-wchwts.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-wchwts.adb?ref=82c80734715c801643075ab68c5c9a5e00da1b03", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1992-2000 Free Software Foundation, Inc.          --\n+--          Copyright (C) 1992-2005 Free Software Foundation, Inc.          --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -31,133 +31,94 @@\n --                                                                          --\n ------------------------------------------------------------------------------\n \n-with Interfaces;     use Interfaces;\n with System.WCh_Con; use System.WCh_Con;\n-with System.WCh_JIS; use System.WCh_JIS;\n+with System.WCh_Cnv; use System.WCh_Cnv;\n \n package body System.WCh_WtS is\n \n+   -----------------------\n+   -- Local Subprograms --\n+   -----------------------\n+\n+   procedure Store_UTF_32_Character\n+     (U  : UTF_32_Code;\n+      S  : out String;\n+      P  : in out Integer;\n+      EM : WC_Encoding_Method);\n+   --  Stores the string representation of the wide or wide wide character\n+   --  whose code is given as U, starting at S (P + 1). P is incremented to\n+   --  point to the last character stored. Raises CE if character cannot be\n+   --  stored using the given encoding method.\n+\n+   ----------------------------\n+   -- Store_UTF_32_Character --\n+   ----------------------------\n+\n+   procedure Store_UTF_32_Character\n+     (U  : UTF_32_Code;\n+      S  : out String;\n+      P  : in out Integer;\n+      EM : WC_Encoding_Method)\n+   is\n+      procedure Out_Char (C : Character);\n+      pragma Inline (Out_Char);\n+      --  Procedure to increment P and store C at S (P)\n+\n+      procedure Store_Chars is new UTF_32_To_Char_Sequence (Out_Char);\n+\n+      --------------\n+      -- Out_Char --\n+      --------------\n+\n+      procedure Out_Char (C : Character) is\n+      begin\n+         P := P + 1;\n+         S (P) := C;\n+      end Out_Char;\n+\n+   begin\n+      Store_Chars (U, EM);\n+   end Store_UTF_32_Character;\n+\n    ---------------------------\n    -- Wide_String_To_String --\n    ---------------------------\n \n    function Wide_String_To_String\n-     (S    : Wide_String;\n-      EM   : WC_Encoding_Method)\n-      return String\n+     (S  : Wide_String;\n+      EM : WC_Encoding_Method) return String\n    is\n       R  : String (1 .. 5 * S'Length); -- worst case length!\n       RP : Natural;\n-      C1 : Character;\n-      C2 : Character;\n \n    begin\n       RP := 0;\n-\n       for SP in S'Range loop\n-         declare\n-            C   : constant Wide_Character := S (SP);\n-            CV  : constant Unsigned_16    := Wide_Character'Pos (C);\n-            Hex : constant array (Unsigned_16 range 0 .. 15) of Character :=\n-                    \"0123456789ABCDEF\";\n-\n-         begin\n-            if CV <= 127 then\n-               RP := RP + 1;\n-               R (RP) := Character'Val (CV);\n-\n-            else\n-               case EM is\n-\n-                  --  Hex ESC sequence encoding\n-\n-                  when WCEM_Hex =>\n-                     if CV <= 16#FF# then\n-                        RP := RP + 1;\n-                        R (RP) := Character'Val (CV);\n-\n-                     else\n-                        R (RP + 1) := ASCII.ESC;\n-                        R (RP + 2) := Hex (Shift_Right (CV, 12));\n-                        R (RP + 3) := Hex (Shift_Right (CV, 8)  and 16#000F#);\n-                        R (RP + 4) := Hex (Shift_Right (CV, 4)  and 16#000F#);\n-                        R (RP + 5) := Hex (CV                   and 16#000F#);\n-                        RP := RP + 5;\n-                     end if;\n-\n-                  --  Upper bit shift (internal code = external code)\n-\n-                  when WCEM_Upper =>\n-                     R (RP + 1) := Character'Val (Shift_Right (CV, 8));\n-                     R (RP + 2) := Character'Val (CV and 16#FF#);\n-                     RP := RP + 2;\n-\n-                  --  Upper bit shift (EUC)\n-\n-                  when WCEM_EUC =>\n-                     JIS_To_EUC (C, C1, C2);\n-                     R (RP + 1) := C1;\n-                     R (RP + 2) := C2;\n-                     RP := RP + 2;\n-\n-                  --  Upper bit shift (Shift-JIS)\n-\n-                  when WCEM_Shift_JIS =>\n-                     JIS_To_Shift_JIS (C, C1, C2);\n-                     R (RP + 1) := C1;\n-                     R (RP + 2) := C2;\n-                     RP := RP + 2;\n-\n-                  --  Upper bit shift (UTF-8)\n-\n-                  --    16#0080#-16#07ff#: 2#110xxxxx# 2#10xxxxxx#\n-                  --    16#0800#-16#ffff#: 2#1110xxxx# 2#10xxxxxx# 2#10xxxxxx#\n-\n-                  when WCEM_UTF8 =>\n-                     if CV < 16#0800# then\n-                        R (RP + 1) :=\n-                          Character'Val (2#11000000# or Shift_Right (CV, 6));\n-                        R (RP + 2) :=\n-                          Character'Val (2#10000000# or (CV and 2#00111111#));\n-                        RP := RP + 2;\n-\n-                     else\n-                        R (RP + 1) :=\n-                          Character'Val (2#11100000# or Shift_Right (CV, 12));\n-                        R (RP + 2) :=\n-                          Character'Val (2#10000000# or\n-                                          (Shift_Right (CV, 6) and\n-                                                               2#00111111#));\n-                        R (RP + 3) :=\n-                          Character'Val (2#10000000# or (CV and 2#00111111#));\n-                        RP := RP + 3;\n-                     end if;\n-\n-                  --  Brackets encoding\n-\n-                  when WCEM_Brackets =>\n-                     if CV <= 16#FF# then\n-                        RP := RP + 1;\n-                        R (RP) := Character'Val (CV);\n-\n-                     else\n-                        R (RP + 1) := '[';\n-                        R (RP + 2) := '\"';\n-                        R (RP + 3) := Hex (Shift_Right (CV, 12));\n-                        R (RP + 4) := Hex (Shift_Right (CV, 8)  and 16#000F#);\n-                        R (RP + 5) := Hex (Shift_Right (CV, 4)  and 16#000F#);\n-                        R (RP + 6) := Hex (CV                   and 16#000F#);\n-                        R (RP + 7) := '\"';\n-                        R (RP + 8) := ']';\n-                        RP := RP + 8;\n-                     end if;\n-\n-               end case;\n-            end if;\n-         end;\n+         Store_UTF_32_Character (Wide_Character'Pos (S (SP)), R, RP, EM);\n       end loop;\n \n       return R (1 .. RP);\n    end Wide_String_To_String;\n \n+   --------------------------------\n+   -- Wide_Wide_Sring_To_String --\n+   --------------------------------\n+\n+   function Wide_Wide_String_To_String\n+     (S  : Wide_Wide_String;\n+      EM : WC_Encoding_Method) return String\n+   is\n+      R  : String (1 .. 7 * S'Length); -- worst case length!\n+      RP : Natural;\n+\n+   begin\n+      RP := 0;\n+\n+      for SP in S'Range loop\n+         Store_UTF_32_Character (Wide_Wide_Character'Pos (S (SP)), R, RP, EM);\n+      end loop;\n+\n+      return R (1 .. RP);\n+   end Wide_Wide_String_To_String;\n+\n end System.WCh_WtS;"}, {"sha": "936045992df6b0039c9195dea591b69b69ca0879", "filename": "gcc/ada/s-wchwts.ads", "status": "modified", "additions": 12, "deletions": 7, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/82c80734715c801643075ab68c5c9a5e00da1b03/gcc%2Fada%2Fs-wchwts.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/82c80734715c801643075ab68c5c9a5e00da1b03/gcc%2Fada%2Fs-wchwts.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-wchwts.ads?ref=82c80734715c801643075ab68c5c9a5e00da1b03", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---          Copyright (C) 1992-1998 Free Software Foundation, Inc.          --\n+--          Copyright (C) 1992-2005 Free Software Foundation, Inc.          --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -31,19 +31,19 @@\n --                                                                          --\n ------------------------------------------------------------------------------\n \n---  This package contains the routine used to convert wide strings to\n---  strings for use by wide character attributes (value, image etc.) and\n---  also by the numeric IO subpackages of Ada.Text_IO.Wide_Text_IO.\n+--  This package contains the routine used to convert wide strings and wide\n+--  wide stringsto strings for use by wide and wide wide character attributes\n+--  (value, image etc.) and also by the numeric IO subpackages of\n+--  Ada.Text_IO.Wide_Text_IO and Ada.Text_IO.Wide_Wide_Text_IO.\n \n with System.WCh_Con;\n \n package System.WCh_WtS is\n pragma Pure (WCh_WtS);\n \n    function Wide_String_To_String\n-     (S    : Wide_String;\n-      EM   : System.WCh_Con.WC_Encoding_Method)\n-      return String;\n+     (S  : Wide_String;\n+      EM : System.WCh_Con.WC_Encoding_Method) return String;\n    --  This routine simply takes its argument and converts it to a string,\n    --  using the internal compiler escape sequence convention (defined in\n    --  package Widechar) to translate characters that are out of range\n@@ -56,4 +56,9 @@ pragma Pure (WCh_WtS);\n    --  Note: in the WCEM_Brackets case, we only use the brackets encoding\n    --  for characters greater than 16#FF#.\n \n+   function Wide_Wide_String_To_String\n+     (S  : Wide_Wide_String;\n+      EM : System.WCh_Con.WC_Encoding_Method) return String;\n+   --  Same processing, except for Wide_Wide_String\n+\n end System.WCh_WtS;"}, {"sha": "3797bf52c99bd6d6e55f0584cc00ca6915de6f20", "filename": "gcc/ada/s-widwch.adb", "status": "modified", "additions": 62, "deletions": 4, "changes": 66, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/82c80734715c801643075ab68c5c9a5e00da1b03/gcc%2Fada%2Fs-widwch.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/82c80734715c801643075ab68c5c9a5e00da1b03/gcc%2Fada%2Fs-widwch.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-widwch.adb?ref=82c80734715c801643075ab68c5c9a5e00da1b03", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1992-1998 Free Software Foundation, Inc.          --\n+--          Copyright (C) 1992-2005 Free Software Foundation, Inc.          --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -41,15 +41,13 @@ package body System.Wid_WChar is\n \n    function Width_Wide_Character\n      (Lo, Hi : Wide_Character;\n-      EM     : WC_Encoding_Method)\n-      return   Natural\n+      EM     : WC_Encoding_Method) return Natural\n    is\n       W : Natural;\n       P : Natural;\n \n    begin\n       W := 0;\n-\n       for C in Lo .. Hi loop\n          P := Wide_Character'Pos (C);\n \n@@ -97,4 +95,64 @@ package body System.Wid_WChar is\n       return W;\n    end Width_Wide_Character;\n \n+   -------------------------------\n+   -- Width_Wide_Wide_Character --\n+   -------------------------------\n+\n+   function Width_Wide_Wide_Character\n+     (Lo, Hi : Wide_Wide_Character;\n+      EM     : WC_Encoding_Method) return Natural\n+   is\n+      W : Natural;\n+      P : Natural;\n+\n+   begin\n+      W := 0;\n+      for C in Lo .. Hi loop\n+         P := Wide_Wide_Character'Pos (C);\n+\n+         --  Here if we find a character in wide wide character range\n+\n+         if P > 16#FF# then\n+            case EM is\n+               when WCEM_Hex =>\n+                  return Natural'Max (W, 5);\n+\n+               when WCEM_Upper =>\n+                  return Natural'Max (W, 2);\n+\n+               when WCEM_Shift_JIS =>\n+                  return Natural'Max (W, 2);\n+\n+               when WCEM_EUC =>\n+                  return Natural'Max (W, 2);\n+\n+               when WCEM_UTF8 =>\n+                  if Hi > Wide_Wide_Character'Val (16#FFFF#) then\n+                     return Natural'Max (W, 4);\n+                  elsif Hi > Wide_Wide_Character'Val (16#07FF#) then\n+                     return Natural'Max (W, 3);\n+                  else\n+                     return Natural'Max (W, 2);\n+                  end if;\n+\n+               when WCEM_Brackets =>\n+                  return Natural'Max (W, 10);\n+\n+            end case;\n+\n+         --  If we are in character range then use length of character image\n+\n+         else\n+            declare\n+               S : constant String := Character'Image (Character'Val (P));\n+            begin\n+               W := Natural'Max (W, S'Length);\n+            end;\n+         end if;\n+      end loop;\n+\n+      return W;\n+   end Width_Wide_Wide_Character;\n+\n end System.Wid_WChar;"}, {"sha": "15c8705053db16cdb0551ff0c55bf99085ad3652", "filename": "gcc/ada/s-widwch.ads", "status": "modified", "additions": 8, "deletions": 4, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/82c80734715c801643075ab68c5c9a5e00da1b03/gcc%2Fada%2Fs-widwch.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/82c80734715c801643075ab68c5c9a5e00da1b03/gcc%2Fada%2Fs-widwch.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-widwch.ads?ref=82c80734715c801643075ab68c5c9a5e00da1b03", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---        Copyright (C) 1992,1993,1994 Free Software Foundation, Inc.       --\n+--          Copyright (C) 1992-2005 Free Software Foundation, Inc.          --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -31,7 +31,7 @@\n --                                                                          --\n ------------------------------------------------------------------------------\n \n---  This package contains the routine used for Wide_Character'Width\n+--  This package contains the routines used for Wide_[Wide_]Character'Width\n \n with System.WCh_Con;\n \n@@ -40,10 +40,14 @@ pragma Pure (Wid_WChar);\n \n    function Width_Wide_Character\n      (Lo, Hi : Wide_Character;\n-      EM     : System.WCh_Con.WC_Encoding_Method)\n-      return   Natural;\n+      EM     : System.WCh_Con.WC_Encoding_Method) return Natural;\n    --  Compute Width attribute for non-static type derived from Wide_Character.\n    --  The arguments are the low and high bounds for the type. EM is the\n    --  wide-character encoding method.\n \n+   function Width_Wide_Wide_Character\n+     (Lo, Hi : Wide_Wide_Character;\n+      EM     : System.WCh_Con.WC_Encoding_Method) return Natural;\n+   --  Same function for type derived from Wide_Wide_Character\n+\n end System.Wid_WChar;"}, {"sha": "82db6f397586bde157bae2236366090ec55a164c", "filename": "gcc/ada/s-wwdcha.adb", "status": "modified", "additions": 21, "deletions": 3, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/82c80734715c801643075ab68c5c9a5e00da1b03/gcc%2Fada%2Fs-wwdcha.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/82c80734715c801643075ab68c5c9a5e00da1b03/gcc%2Fada%2Fs-wwdcha.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-wwdcha.adb?ref=82c80734715c801643075ab68c5c9a5e00da1b03", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1992-2002 Free Software Foundation, Inc.          --\n+--          Copyright (C) 1992-2005 Free Software Foundation, Inc.          --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -42,11 +42,9 @@ package body System.WWd_Char is\n \n    begin\n       W := 0;\n-\n       for C in Lo .. Hi loop\n          declare\n             S : constant Wide_String := Character'Wide_Image (C);\n-\n          begin\n             W := Natural'Max (W, S'Length);\n          end;\n@@ -55,4 +53,24 @@ package body System.WWd_Char is\n       return W;\n    end Wide_Width_Character;\n \n+   -------------------------------\n+   -- Wide_Wide_Width_Character --\n+   -------------------------------\n+\n+   function Wide_Wide_Width_Character (Lo, Hi : Character) return Natural is\n+      W : Natural;\n+\n+   begin\n+      W := 0;\n+      for C in Lo .. Hi loop\n+         declare\n+            S : constant Wide_Wide_String := Character'Wide_Wide_Image (C);\n+         begin\n+            W := Natural'Max (W, S'Length);\n+         end;\n+      end loop;\n+\n+      return W;\n+   end Wide_Wide_Width_Character;\n+\n end System.WWd_Char;"}, {"sha": "9431fb7f12d2c50ad29b6b5ae4926aa8836c821c", "filename": "gcc/ada/s-wwdcha.ads", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/82c80734715c801643075ab68c5c9a5e00da1b03/gcc%2Fada%2Fs-wwdcha.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/82c80734715c801643075ab68c5c9a5e00da1b03/gcc%2Fada%2Fs-wwdcha.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-wwdcha.ads?ref=82c80734715c801643075ab68c5c9a5e00da1b03", "patch": "@@ -6,8 +6,8 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---        Copyright (C) 1992,1993,1994 Free Software Foundation, Inc.       --\n---                                                                          --\n+--          Copyright (C) 1992-2005 Free Software Foundation, Inc.          --\n+--                                                                           --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n -- ware  Foundation;  either version 2,  or (at your option) any later ver- --\n@@ -31,7 +31,7 @@\n --                                                                          --\n ------------------------------------------------------------------------------\n \n---  This package contains the routine used for Character'Wide_Width\n+--  This package contains the routine used for Character'Wide_[Wide_]Width\n \n package System.WWd_Char is\n pragma Pure (WWd_Char);\n@@ -40,4 +40,8 @@ pragma Pure (WWd_Char);\n    --  Compute Wide_Width attribute for non-static type derived from\n    --  Character. The arguments are the low and high bounds for the type.\n \n+   function Wide_Wide_Width_Character (Lo, Hi : Character) return Natural;\n+   --  Compute Wide_Wide_Width attribute for non-static type derived from\n+   --  Character. The arguments are the low and high bounds for the type.\n+\n end System.WWd_Char;"}, {"sha": "444d018da36041351e7260c90ef735c26ae8409e", "filename": "gcc/ada/s-wwdenu.adb", "status": "modified", "additions": 124, "deletions": 22, "changes": 146, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/82c80734715c801643075ab68c5c9a5e00da1b03/gcc%2Fada%2Fs-wwdenu.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/82c80734715c801643075ab68c5c9a5e00da1b03/gcc%2Fada%2Fs-wwdenu.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-wwdenu.adb?ref=82c80734715c801643075ab68c5c9a5e00da1b03", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1992-2000 Free Software Foundation, Inc.          --\n+--          Copyright (C) 1992-2005 Free Software Foundation, Inc.          --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -38,6 +38,117 @@ with Unchecked_Conversion;\n \n package body System.WWd_Enum is\n \n+   -----------------------------------\n+   -- Wide_Wide_Width_Enumeration_8 --\n+   -----------------------------------\n+\n+   function Wide_Wide_Width_Enumeration_8\n+     (Names   : String;\n+      Indexes : System.Address;\n+      Lo, Hi  : Natural;\n+      EM      : WC_Encoding_Method) return Natural\n+   is\n+      W : Natural;\n+\n+      type Natural_8 is range 0 .. 2 ** 7 - 1;\n+      type Index_Table is array (Natural) of Natural_8;\n+      type Index_Table_Ptr is access Index_Table;\n+\n+      function To_Index_Table_Ptr is\n+        new Unchecked_Conversion (System.Address, Index_Table_Ptr);\n+\n+      IndexesT : constant Index_Table_Ptr := To_Index_Table_Ptr (Indexes);\n+\n+   begin\n+      W := 0;\n+      for J in Lo .. Hi loop\n+         declare\n+            WS : constant Wide_Wide_String :=\n+                   String_To_Wide_Wide_String\n+                     (Names (Natural (IndexesT (J)) ..\n+                             Natural (IndexesT (J + 1)) - 1), EM);\n+         begin\n+            W := Natural'Max (W, WS'Length);\n+         end;\n+      end loop;\n+\n+      return W;\n+   end Wide_Wide_Width_Enumeration_8;\n+\n+   ------------------------------------\n+   -- Wide_Wide_Width_Enumeration_16 --\n+   ------------------------------------\n+\n+   function Wide_Wide_Width_Enumeration_16\n+     (Names   : String;\n+      Indexes : System.Address;\n+      Lo, Hi  : Natural;\n+      EM      : WC_Encoding_Method) return Natural\n+   is\n+      W : Natural;\n+\n+      type Natural_16 is range 0 .. 2 ** 15 - 1;\n+      type Index_Table is array (Natural) of Natural_16;\n+      type Index_Table_Ptr is access Index_Table;\n+\n+      function To_Index_Table_Ptr is\n+        new Unchecked_Conversion (System.Address, Index_Table_Ptr);\n+\n+      IndexesT : constant Index_Table_Ptr := To_Index_Table_Ptr (Indexes);\n+\n+   begin\n+      W := 0;\n+      for J in Lo .. Hi loop\n+         declare\n+            WS : constant Wide_Wide_String :=\n+                   String_To_Wide_Wide_String\n+                     (Names (Natural (IndexesT (J)) ..\n+                             Natural (IndexesT (J + 1)) - 1), EM);\n+         begin\n+            W := Natural'Max (W, WS'Length);\n+         end;\n+      end loop;\n+\n+      return W;\n+   end Wide_Wide_Width_Enumeration_16;\n+\n+   ------------------------------------\n+   -- Wide_Wide_Width_Enumeration_32 --\n+   ------------------------------------\n+\n+   function Wide_Wide_Width_Enumeration_32\n+     (Names   : String;\n+      Indexes : System.Address;\n+      Lo, Hi  : Natural;\n+      EM      : WC_Encoding_Method) return Natural\n+   is\n+      W : Natural;\n+\n+      type Natural_32 is range 0 .. 2 ** 31 - 1;\n+      type Index_Table is array (Natural) of Natural_32;\n+      type Index_Table_Ptr is access Index_Table;\n+\n+      function To_Index_Table_Ptr is\n+        new Unchecked_Conversion (System.Address, Index_Table_Ptr);\n+\n+      IndexesT : constant Index_Table_Ptr := To_Index_Table_Ptr (Indexes);\n+\n+   begin\n+      W := 0;\n+      for J in Lo .. Hi loop\n+         declare\n+            WS : constant Wide_Wide_String :=\n+                   String_To_Wide_Wide_String\n+                     (Names (Natural (IndexesT (J)) ..\n+                             Natural (IndexesT (J + 1)) - 1), EM);\n+         begin\n+            W := Natural'Max (W, WS'Length);\n+         end;\n+      end loop;\n+\n+      return W;\n+   end Wide_Wide_Width_Enumeration_32;\n+\n    ------------------------------\n    -- Wide_Width_Enumeration_8 --\n    ------------------------------\n@@ -46,8 +157,7 @@ package body System.WWd_Enum is\n      (Names   : String;\n       Indexes : System.Address;\n       Lo, Hi  : Natural;\n-      EM      : WC_Encoding_Method)\n-      return    Natural\n+      EM      : WC_Encoding_Method) return Natural\n    is\n       W : Natural;\n \n@@ -62,14 +172,12 @@ package body System.WWd_Enum is\n \n    begin\n       W := 0;\n-\n       for J in Lo .. Hi loop\n          declare\n             WS : constant Wide_String :=\n-              String_To_Wide_String\n-                (Names (Natural (IndexesT (J)) ..\n-                        Natural (IndexesT (J + 1)) - 1), EM);\n-\n+                   String_To_Wide_String\n+                     (Names (Natural (IndexesT (J)) ..\n+                             Natural (IndexesT (J + 1)) - 1), EM);\n          begin\n             W := Natural'Max (W, WS'Length);\n          end;\n@@ -86,8 +194,7 @@ package body System.WWd_Enum is\n      (Names   : String;\n       Indexes : System.Address;\n       Lo, Hi  : Natural;\n-      EM      : WC_Encoding_Method)\n-      return    Natural\n+      EM      : WC_Encoding_Method) return Natural\n    is\n       W : Natural;\n \n@@ -102,14 +209,12 @@ package body System.WWd_Enum is\n \n    begin\n       W := 0;\n-\n       for J in Lo .. Hi loop\n          declare\n             WS : constant Wide_String :=\n-              String_To_Wide_String\n-                (Names (Natural (IndexesT (J)) ..\n-                        Natural (IndexesT (J + 1)) - 1), EM);\n-\n+                   String_To_Wide_String\n+                     (Names (Natural (IndexesT (J)) ..\n+                             Natural (IndexesT (J + 1)) - 1), EM);\n          begin\n             W := Natural'Max (W, WS'Length);\n          end;\n@@ -126,8 +231,7 @@ package body System.WWd_Enum is\n      (Names   : String;\n       Indexes : System.Address;\n       Lo, Hi  : Natural;\n-      EM      : WC_Encoding_Method)\n-      return    Natural\n+      EM      : WC_Encoding_Method) return Natural\n    is\n       W : Natural;\n \n@@ -142,14 +246,12 @@ package body System.WWd_Enum is\n \n    begin\n       W := 0;\n-\n       for J in Lo .. Hi loop\n          declare\n             WS : constant Wide_String :=\n-              String_To_Wide_String\n-                (Names (Natural (IndexesT (J)) ..\n-                        Natural (IndexesT (J + 1)) - 1), EM);\n-\n+                   String_To_Wide_String\n+                     (Names (Natural (IndexesT (J)) ..\n+                             Natural (IndexesT (J + 1)) - 1), EM);\n          begin\n             W := Natural'Max (W, WS'Length);\n          end;"}, {"sha": "3c64764915d67dcc53c297e0e17fda4a005ab6f8", "filename": "gcc/ada/s-wwdenu.ads", "status": "modified", "additions": 26, "deletions": 8, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/82c80734715c801643075ab68c5c9a5e00da1b03/gcc%2Fada%2Fs-wwdenu.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/82c80734715c801643075ab68c5c9a5e00da1b03/gcc%2Fada%2Fs-wwdenu.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-wwdenu.ads?ref=82c80734715c801643075ab68c5c9a5e00da1b03", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---          Copyright (C) 1992-2000 Free Software Foundation, Inc.          --\n+--          Copyright (C) 1992-2005 Free Software Foundation, Inc.          --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -31,7 +31,7 @@\n --                                                                          --\n ------------------------------------------------------------------------------\n \n---  This package contains the routine used for Enumeration_Type'Wide_Width\n+--  This package contains routines used for Enumeration_Type'Wide_[Wide_]Width\n \n with System.WCh_Con;\n \n@@ -42,8 +42,7 @@ pragma Pure (WWd_Enum);\n      (Names   : String;\n       Indexes : System.Address;\n       Lo, Hi  : Natural;\n-      EM      : System.WCh_Con.WC_Encoding_Method)\n-      return    Natural;\n+      EM      : System.WCh_Con.WC_Encoding_Method) return Natural;\n    --  Used to compute Enum'Wide_Width where Enum is an enumeration subtype\n    --  other than those defined in package Standard. Names is a string with\n    --  a lower bound of 1 containing the characters of all the enumeration\n@@ -65,18 +64,37 @@ pragma Pure (WWd_Enum);\n      (Names   : String;\n       Indexes : System.Address;\n       Lo, Hi  : Natural;\n-      EM      : System.WCh_Con.WC_Encoding_Method)\n-      return    Natural;\n+      EM      : System.WCh_Con.WC_Encoding_Method) return Natural;\n    --  Identical to Wide_Width_Enumeration_8 except that it handles types\n    --  using array (0 .. Num) of Natural_16 for the Indexes table.\n \n    function Wide_Width_Enumeration_32\n      (Names   : String;\n       Indexes : System.Address;\n       Lo, Hi  : Natural;\n-      EM      : System.WCh_Con.WC_Encoding_Method)\n-      return    Natural;\n+      EM      : System.WCh_Con.WC_Encoding_Method) return Natural;\n    --  Identical to Wide_Width_Enumeration_8 except that it handles types\n    --  using array (0 .. Num) of Natural_32 for the Indexes table.\n \n+   function Wide_Wide_Width_Enumeration_8\n+     (Names   : String;\n+      Indexes : System.Address;\n+      Lo, Hi  : Natural;\n+      EM      : System.WCh_Con.WC_Encoding_Method) return Natural;\n+   --  Same function for Wide_Wide_Width attribute\n+\n+   function Wide_Wide_Width_Enumeration_16\n+     (Names   : String;\n+      Indexes : System.Address;\n+      Lo, Hi  : Natural;\n+      EM      : System.WCh_Con.WC_Encoding_Method) return Natural;\n+   --  Same function for Wide_Wide_Width attribute\n+\n+   function Wide_Wide_Width_Enumeration_32\n+     (Names   : String;\n+      Indexes : System.Address;\n+      Lo, Hi  : Natural;\n+      EM      : System.WCh_Con.WC_Encoding_Method) return Natural;\n+   --  Same function for Wide_Wide_Width attribute\n+\n end System.WWd_Enum;"}, {"sha": "ac3d1e9cc45b0273d929fe766fda0832235650ef", "filename": "gcc/ada/s-wwdwch.adb", "status": "modified", "additions": 124, "deletions": 23, "changes": 147, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/82c80734715c801643075ab68c5c9a5e00da1b03/gcc%2Fada%2Fs-wwdwch.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/82c80734715c801643075ab68c5c9a5e00da1b03/gcc%2Fada%2Fs-wwdwch.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-wwdwch.adb?ref=82c80734715c801643075ab68c5c9a5e00da1b03", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1992-2002, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2005, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -31,46 +31,147 @@\n --                                                                          --\n ------------------------------------------------------------------------------\n \n+with Interfaces; use Interfaces;\n+\n+with System.WWd_Char;\n+\n package body System.Wwd_WChar is\n \n+   ------------------------------------\n+   -- Wide_Wide_Width_Wide_Character --\n+   ------------------------------------\n+\n+   --  This is the case where we are talking about the Wide_Wide_Image of\n+   --  a Wide_Character, which is always the same character sequence as the\n+   --  Wide_Image of the same Wide_Character.\n+\n+   function Wide_Wide_Width_Wide_Character\n+     (Lo, Hi : Wide_Character) return Natural\n+   is\n+   begin\n+      return Wide_Width_Wide_Character (Lo, Hi);\n+   end Wide_Wide_Width_Wide_Character;\n+\n+   ------------------------------------\n+   -- Wide_Wide_Width_Wide_Wide_Char --\n+   ------------------------------------\n+\n+   function Wide_Wide_Width_Wide_Wide_Char\n+     (Lo, Hi : Wide_Wide_Character) return Natural\n+   is\n+      W  : Natural := 0;\n+      LV : constant Unsigned_32 := Wide_Wide_Character'Pos (Lo);\n+      HV : constant Unsigned_32 := Wide_Wide_Character'Pos (Hi);\n+\n+   begin\n+      --  Return zero if empty range\n+\n+      if LV > HV then\n+         return 0;\n+      end if;\n+\n+      --  If any characters in normal character range, then use normal\n+      --  Wide_Wide_Width attribute on this range to find out a starting point.\n+      --  Otherwise start with zero.\n+\n+      if LV <= 255 then\n+         W :=\n+           System.WWd_Char.Wide_Wide_Width_Character\n+             (Lo => Character'Val (LV),\n+              Hi => Character'Val (Unsigned_32'Min (255, HV)));\n+      else\n+         W := 0;\n+      end if;\n+\n+      --  Increase to at least 4 if FFFE or FFFF present. These correspond\n+      --  to the special language defined names FFFE/FFFF for these values.\n+\n+      if 16#FFFF# in LV .. HV or else 16#FFFE# in LV .. HV then\n+         W := Natural'Max (W, 4);\n+      end if;\n+\n+      --  Increase to at least 3 if any wide characters, corresponding to\n+      --  the normal ' character ' sequence. We know that the character fits.\n+\n+      if HV > 255 then\n+         W := Natural'Max (W, 3);\n+      end if;\n+\n+      return W;\n+   end Wide_Wide_Width_Wide_Wide_Char;\n+\n    -------------------------------\n    -- Wide_Width_Wide_Character --\n    -------------------------------\n \n    function Wide_Width_Wide_Character\n-     (Lo, Hi : Wide_Character)\n-      return   Natural\n+     (Lo, Hi : Wide_Character) return Natural\n    is\n-      W : Natural;\n-      P : Natural;\n+      W  : Natural := 0;\n+      LV : constant Unsigned_32 := Wide_Character'Pos (Lo);\n+      HV : constant Unsigned_32 := Wide_Character'Pos (Hi);\n \n    begin\n-      W := 0;\n+      --  Return zero if empty range\n \n-      for C in Lo .. Hi loop\n-         P := Wide_Character'Pos (C);\n+      if LV > HV then\n+         return 0;\n+      end if;\n \n-         --  If we are in wide character range, the length is always 3\n-         --  and we are done, since all remaining characters are the same.\n+      --  If any characters in normal character range, then use normal\n+      --  Wide_Wide_Width attribute on this range to find out a starting point.\n+      --  Otherwise start with zero.\n \n-         if P > 255 then\n-            return Natural'Max (W, 3);\n+      if LV <= 255 then\n+         W :=\n+           System.WWd_Char.Wide_Width_Character\n+             (Lo => Character'Val (LV),\n+              Hi => Character'Val (Unsigned_32'Min (255, HV)));\n+      else\n+         W := 0;\n+      end if;\n \n-         --  If we are in character range then use length of character image\n-         --  Is this right, what about wide char encodings of 80-FF???\n+      --  Increase to at least 4 if FFFE or FFFF present. These correspond\n+      --  to the special language defined names FFFE/FFFF for these values.\n \n-         else\n-            declare\n-               S : constant Wide_String :=\n-                     Character'Wide_Image (Character'Val (P));\n+      if 16#FFFF# in LV .. HV or else 16#FFFE# in LV .. HV then\n+         W := Natural'Max (W, 4);\n+      end if;\n \n-            begin\n-               W := Natural'Max (W, S'Length);\n-            end;\n-         end if;\n-      end loop;\n+      --  Increase to at least 3 if any wide characters, corresponding to\n+      --  the normal 'character' sequence. We know that the character fits.\n+\n+      if HV > 255 then\n+         W := Natural'Max (W, 3);\n+      end if;\n \n       return W;\n    end Wide_Width_Wide_Character;\n \n+   ------------------------------------\n+   -- Wide_Width_Wide_Wide_Character --\n+   ------------------------------------\n+\n+   --  This is a nasty case, because we get into the business of representing\n+   --  out of range wide wide characters as wide strings. Let's let image do\n+   --  the work here. Too bad if this takes lots of time. It's silly anyway!\n+\n+   function Wide_Width_Wide_Wide_Character\n+     (Lo, Hi : Wide_Wide_Character) return Natural\n+   is\n+      W : Natural;\n+\n+   begin\n+      W := 0;\n+      for J in Lo .. Hi loop\n+         declare\n+            S : constant Wide_String := Wide_Wide_Character'Wide_Image (J);\n+         begin\n+            W := Natural'Max (W, S'Length);\n+         end;\n+      end loop;\n+\n+      return W;\n+   end Wide_Width_Wide_Wide_Character;\n+\n end System.Wwd_WChar;"}, {"sha": "b158be26292cecfb038b71e9fa65543d7ed0dd60", "filename": "gcc/ada/s-wwdwch.ads", "status": "modified", "additions": 21, "deletions": 4, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/82c80734715c801643075ab68c5c9a5e00da1b03/gcc%2Fada%2Fs-wwdwch.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/82c80734715c801643075ab68c5c9a5e00da1b03/gcc%2Fada%2Fs-wwdwch.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-wwdwch.ads?ref=82c80734715c801643075ab68c5c9a5e00da1b03", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---        Copyright (C) 1992,1993,1994 Free Software Foundation, Inc.       --\n+--          Copyright (C) 1992-2005 Free Software Foundation, Inc.          --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -31,16 +31,33 @@\n --                                                                          --\n ------------------------------------------------------------------------------\n \n---  This package contains the routine used for Wide_Character'Wide_Width\n+--  This package contains routines for [Wide_]Wide_Character'[Wide_]Wide_Width\n \n package System.Wwd_WChar is\n pragma Pure (Wwd_WChar);\n \n    function Wide_Width_Wide_Character\n-     (Lo, Hi : Wide_Character)\n-      return   Natural;\n+     (Lo, Hi : Wide_Character) return Natural;\n    --  Compute Wide_Width attribute for non-static type derived from\n    --  Wide_Character. The arguments are the low and high bounds for\n    --  the type. EM is the wide-character encoding method.\n \n+   function Wide_Width_Wide_Wide_Character\n+     (Lo, Hi : Wide_Wide_Character) return Natural;\n+   --  Compute Wide_Width attribute for non-static type derived from\n+   --  Wide_Wide_Character. The arguments are the low and high bounds for\n+   --  the type. EM is the wide-character encoding method.\n+\n+   function Wide_Wide_Width_Wide_Character\n+     (Lo, Hi : Wide_Character) return Natural;\n+   --  Compute Wide_Wide_Width attribute for non-static type derived from\n+   --  Wide_Character. The arguments are the low and high bounds for\n+   --  the type. EM is the wide-character encoding method.\n+\n+   function Wide_Wide_Width_Wide_Wide_Char\n+     (Lo, Hi : Wide_Wide_Character) return Natural;\n+   --  Compute Wide_Wide_Width attribute for non-static type derived from\n+   --  Wide_Wide_Character. The arguments are the low and high bounds for\n+   --  the type. EM is the wide-character encoding method.\n+\n end System.Wwd_WChar;"}, {"sha": "8c7870fbc570d985d4e84183f03b41cfecddda0f", "filename": "gcc/ada/scans.ads", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/82c80734715c801643075ab68c5c9a5e00da1b03/gcc%2Fada%2Fscans.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/82c80734715c801643075ab68c5c9a5e00da1b03/gcc%2Fada%2Fscans.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fscans.ads?ref=82c80734715c801643075ab68c5c9a5e00da1b03", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---          Copyright (C) 1992-2003 Free Software Foundation, Inc.          --\n+--          Copyright (C) 1992-2005 Free Software Foundation, Inc.          --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -124,6 +124,7 @@ package Scans is\n       Tok_Constant,        -- CONSTANT     Eterm, Sterm\n       Tok_Do,              -- DO           Eterm, Sterm\n       Tok_Is,              -- IS           Eterm, Sterm\n+      Tok_Interface,       -- INTERFACE    Eterm, Sterm\n       Tok_Limited,         -- LIMITED      Eterm, Sterm\n       Tok_Of,              -- OF           Eterm, Sterm\n       Tok_Out,             -- OUT          Eterm, Sterm\n@@ -166,6 +167,8 @@ package Scans is\n       Tok_Task,            -- TASK         Eterm, Sterm, Declk, Deckn, After_SM\n       Tok_Type,            -- TYPE         Eterm, Sterm, Declk, Deckn, After_SM\n       Tok_Subtype,         -- SUBTYPE      Eterm, Sterm, Declk, Deckn, After_SM\n+      Tok_Overriding,      -- OVERRIDING   Eterm, Sterm, Declk, Declk, After_SM\n+      Tok_Synchronized,    -- SYNCHRONIZED Eterm, Sterm, Declk, Deckn, After_SM\n       Tok_Use,             -- USE          Eterm, Sterm, Declk, Deckn, After_SM\n \n       Tok_Function,        -- FUNCTION     Eterm, Sterm, Cunit, Declk, After_SM"}, {"sha": "b83be649810abe2589b2bb76b26ec565ab1f8bb8", "filename": "gcc/ada/scn.adb", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/82c80734715c801643075ab68c5c9a5e00da1b03/gcc%2Fada%2Fscn.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/82c80734715c801643075ab68c5c9a5e00da1b03/gcc%2Fada%2Fscn.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fscn.adb?ref=82c80734715c801643075ab68c5c9a5e00da1b03", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1992-2004 Free Software Foundation, Inc.          --\n+--          Copyright (C) 1992-2005 Free Software Foundation, Inc.          --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -33,6 +33,7 @@ with Rident;   use Rident;\n with Scans;    use Scans;\n with Sinfo;    use Sinfo;\n with Sinput;   use Sinput;\n+with Uintp;    use Uintp;\n \n package body Scn is\n \n@@ -64,7 +65,7 @@ package body Scn is\n       case Token is\n          when Tok_Char_Literal =>\n             Token_Node := New_Node (N_Character_Literal, Token_Ptr);\n-            Set_Char_Literal_Value (Token_Node, Character_Code);\n+            Set_Char_Literal_Value (Token_Node, UI_From_CC (Character_Code));\n             Set_Chars (Token_Node, Token_Name);\n \n          when Tok_Identifier =>"}, {"sha": "158524df989a9381f9e1111e852882331e9a3dd7", "filename": "gcc/ada/scng.adb", "status": "modified", "additions": 535, "deletions": 315, "changes": 850, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/82c80734715c801643075ab68c5c9a5e00da1b03/gcc%2Fada%2Fscng.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/82c80734715c801643075ab68c5c9a5e00da1b03/gcc%2Fada%2Fscng.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fscng.adb?ref=82c80734715c801643075ab68c5c9a5e00da1b03", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1992-2004 Free Software Foundation, Inc.          --\n+--          Copyright (C) 1992-2005 Free Software Foundation, Inc.          --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -94,7 +94,13 @@ package body Scng is\n \n    procedure Accumulate_Checksum (C : Char_Code) is\n    begin\n-      Accumulate_Checksum (Character'Val (C / 256));\n+      if C > 16#FFFF# then\n+         Accumulate_Checksum (Character'Val (C / 2 ** 16));\n+         Accumulate_Checksum (Character'Val ((C / 256) mod 256));\n+      else\n+         Accumulate_Checksum (Character'Val (C / 256));\n+      end if;\n+\n       Accumulate_Checksum (Character'Val (C mod 256));\n    end Accumulate_Checksum;\n \n@@ -135,80 +141,103 @@ package body Scng is\n      (Unit  : Unit_Number_Type;\n       Index : Source_File_Index)\n    is\n+      procedure Set_Reserved (N : Name_Id; T : Token_Type);\n+      pragma Inline (Set_Reserved);\n+      --  Set given name as a reserved keyword (T is the corresponding token)\n+\n+      -------------\n+      -- Set_NTB --\n+      -------------\n+\n+      procedure Set_Reserved (N : Name_Id; T : Token_Type) is\n+      begin\n+         --  Set up Token_Type values in Names Table entries for reserved\n+         --  keywords We use the Pos value of the Token_Type value. Note we\n+         --  rely on the fact that Token_Type'Val (0) is not a reserved word!\n+\n+         Set_Name_Table_Byte (N, Token_Type'Pos (T));\n+      end Set_Reserved;\n+\n+   --  Start of processing for Initialize_Scanner\n+\n    begin\n-      --  Set up Token_Type values in Names Table entries for reserved keywords\n-      --  We use the Pos value of the Token_Type value. Note we are relying on\n-      --  the fact that Token_Type'Val (0) is not a reserved word!\n-\n-      Set_Name_Table_Byte (Name_Abort,      Token_Type'Pos (Tok_Abort));\n-      Set_Name_Table_Byte (Name_Abs,        Token_Type'Pos (Tok_Abs));\n-      Set_Name_Table_Byte (Name_Abstract,   Token_Type'Pos (Tok_Abstract));\n-      Set_Name_Table_Byte (Name_Accept,     Token_Type'Pos (Tok_Accept));\n-      Set_Name_Table_Byte (Name_Access,     Token_Type'Pos (Tok_Access));\n-      Set_Name_Table_Byte (Name_And,        Token_Type'Pos (Tok_And));\n-      Set_Name_Table_Byte (Name_Aliased,    Token_Type'Pos (Tok_Aliased));\n-      Set_Name_Table_Byte (Name_All,        Token_Type'Pos (Tok_All));\n-      Set_Name_Table_Byte (Name_Array,      Token_Type'Pos (Tok_Array));\n-      Set_Name_Table_Byte (Name_At,         Token_Type'Pos (Tok_At));\n-      Set_Name_Table_Byte (Name_Begin,      Token_Type'Pos (Tok_Begin));\n-      Set_Name_Table_Byte (Name_Body,       Token_Type'Pos (Tok_Body));\n-      Set_Name_Table_Byte (Name_Case,       Token_Type'Pos (Tok_Case));\n-      Set_Name_Table_Byte (Name_Constant,   Token_Type'Pos (Tok_Constant));\n-      Set_Name_Table_Byte (Name_Declare,    Token_Type'Pos (Tok_Declare));\n-      Set_Name_Table_Byte (Name_Delay,      Token_Type'Pos (Tok_Delay));\n-      Set_Name_Table_Byte (Name_Delta,      Token_Type'Pos (Tok_Delta));\n-      Set_Name_Table_Byte (Name_Digits,     Token_Type'Pos (Tok_Digits));\n-      Set_Name_Table_Byte (Name_Do,         Token_Type'Pos (Tok_Do));\n-      Set_Name_Table_Byte (Name_Else,       Token_Type'Pos (Tok_Else));\n-      Set_Name_Table_Byte (Name_Elsif,      Token_Type'Pos (Tok_Elsif));\n-      Set_Name_Table_Byte (Name_End,        Token_Type'Pos (Tok_End));\n-      Set_Name_Table_Byte (Name_Entry,      Token_Type'Pos (Tok_Entry));\n-      Set_Name_Table_Byte (Name_Exception,  Token_Type'Pos (Tok_Exception));\n-      Set_Name_Table_Byte (Name_Exit,       Token_Type'Pos (Tok_Exit));\n-      Set_Name_Table_Byte (Name_For,        Token_Type'Pos (Tok_For));\n-      Set_Name_Table_Byte (Name_Function,   Token_Type'Pos (Tok_Function));\n-      Set_Name_Table_Byte (Name_Generic,    Token_Type'Pos (Tok_Generic));\n-      Set_Name_Table_Byte (Name_Goto,       Token_Type'Pos (Tok_Goto));\n-      Set_Name_Table_Byte (Name_If,         Token_Type'Pos (Tok_If));\n-      Set_Name_Table_Byte (Name_In,         Token_Type'Pos (Tok_In));\n-      Set_Name_Table_Byte (Name_Is,         Token_Type'Pos (Tok_Is));\n-      Set_Name_Table_Byte (Name_Limited,    Token_Type'Pos (Tok_Limited));\n-      Set_Name_Table_Byte (Name_Loop,       Token_Type'Pos (Tok_Loop));\n-      Set_Name_Table_Byte (Name_Mod,        Token_Type'Pos (Tok_Mod));\n-      Set_Name_Table_Byte (Name_New,        Token_Type'Pos (Tok_New));\n-      Set_Name_Table_Byte (Name_Not,        Token_Type'Pos (Tok_Not));\n-      Set_Name_Table_Byte (Name_Null,       Token_Type'Pos (Tok_Null));\n-      Set_Name_Table_Byte (Name_Of,         Token_Type'Pos (Tok_Of));\n-      Set_Name_Table_Byte (Name_Or,         Token_Type'Pos (Tok_Or));\n-      Set_Name_Table_Byte (Name_Others,     Token_Type'Pos (Tok_Others));\n-      Set_Name_Table_Byte (Name_Out,        Token_Type'Pos (Tok_Out));\n-      Set_Name_Table_Byte (Name_Package,    Token_Type'Pos (Tok_Package));\n-      Set_Name_Table_Byte (Name_Pragma,     Token_Type'Pos (Tok_Pragma));\n-      Set_Name_Table_Byte (Name_Private,    Token_Type'Pos (Tok_Private));\n-      Set_Name_Table_Byte (Name_Procedure,  Token_Type'Pos (Tok_Procedure));\n-      Set_Name_Table_Byte (Name_Protected,  Token_Type'Pos (Tok_Protected));\n-      Set_Name_Table_Byte (Name_Raise,      Token_Type'Pos (Tok_Raise));\n-      Set_Name_Table_Byte (Name_Range,      Token_Type'Pos (Tok_Range));\n-      Set_Name_Table_Byte (Name_Record,     Token_Type'Pos (Tok_Record));\n-      Set_Name_Table_Byte (Name_Rem,        Token_Type'Pos (Tok_Rem));\n-      Set_Name_Table_Byte (Name_Renames,    Token_Type'Pos (Tok_Renames));\n-      Set_Name_Table_Byte (Name_Requeue,    Token_Type'Pos (Tok_Requeue));\n-      Set_Name_Table_Byte (Name_Return,     Token_Type'Pos (Tok_Return));\n-      Set_Name_Table_Byte (Name_Reverse,    Token_Type'Pos (Tok_Reverse));\n-      Set_Name_Table_Byte (Name_Select,     Token_Type'Pos (Tok_Select));\n-      Set_Name_Table_Byte (Name_Separate,   Token_Type'Pos (Tok_Separate));\n-      Set_Name_Table_Byte (Name_Subtype,    Token_Type'Pos (Tok_Subtype));\n-      Set_Name_Table_Byte (Name_Tagged,     Token_Type'Pos (Tok_Tagged));\n-      Set_Name_Table_Byte (Name_Task,       Token_Type'Pos (Tok_Task));\n-      Set_Name_Table_Byte (Name_Terminate,  Token_Type'Pos (Tok_Terminate));\n-      Set_Name_Table_Byte (Name_Then,       Token_Type'Pos (Tok_Then));\n-      Set_Name_Table_Byte (Name_Type,       Token_Type'Pos (Tok_Type));\n-      Set_Name_Table_Byte (Name_Until,      Token_Type'Pos (Tok_Until));\n-      Set_Name_Table_Byte (Name_Use,        Token_Type'Pos (Tok_Use));\n-      Set_Name_Table_Byte (Name_When,       Token_Type'Pos (Tok_When));\n-      Set_Name_Table_Byte (Name_While,      Token_Type'Pos (Tok_While));\n-      Set_Name_Table_Byte (Name_With,       Token_Type'Pos (Tok_With));\n-      Set_Name_Table_Byte (Name_Xor,        Token_Type'Pos (Tok_Xor));\n+      --  Establish reserved words\n+\n+      Set_Reserved (Name_Abort,     Tok_Abort);\n+      Set_Reserved (Name_Abs,       Tok_Abs);\n+      Set_Reserved (Name_Abstract,  Tok_Abstract);\n+      Set_Reserved (Name_Accept,    Tok_Accept);\n+      Set_Reserved (Name_Access,    Tok_Access);\n+      Set_Reserved (Name_And,       Tok_And);\n+      Set_Reserved (Name_Aliased,   Tok_Aliased);\n+      Set_Reserved (Name_All,       Tok_All);\n+      Set_Reserved (Name_Array,     Tok_Array);\n+      Set_Reserved (Name_At,        Tok_At);\n+      Set_Reserved (Name_Begin,     Tok_Begin);\n+      Set_Reserved (Name_Body,      Tok_Body);\n+      Set_Reserved (Name_Case,      Tok_Case);\n+      Set_Reserved (Name_Constant,  Tok_Constant);\n+      Set_Reserved (Name_Declare,   Tok_Declare);\n+      Set_Reserved (Name_Delay,     Tok_Delay);\n+      Set_Reserved (Name_Delta,     Tok_Delta);\n+      Set_Reserved (Name_Digits,    Tok_Digits);\n+      Set_Reserved (Name_Do,        Tok_Do);\n+      Set_Reserved (Name_Else,      Tok_Else);\n+      Set_Reserved (Name_Elsif,     Tok_Elsif);\n+      Set_Reserved (Name_End,       Tok_End);\n+      Set_Reserved (Name_Entry,     Tok_Entry);\n+      Set_Reserved (Name_Exception, Tok_Exception);\n+      Set_Reserved (Name_Exit,      Tok_Exit);\n+      Set_Reserved (Name_For,       Tok_For);\n+      Set_Reserved (Name_Function,  Tok_Function);\n+      Set_Reserved (Name_Generic,   Tok_Generic);\n+      Set_Reserved (Name_Goto,      Tok_Goto);\n+      Set_Reserved (Name_If,        Tok_If);\n+      Set_Reserved (Name_In,        Tok_In);\n+      Set_Reserved (Name_Is,        Tok_Is);\n+      Set_Reserved (Name_Limited,   Tok_Limited);\n+      Set_Reserved (Name_Loop,      Tok_Loop);\n+      Set_Reserved (Name_Mod,       Tok_Mod);\n+      Set_Reserved (Name_New,       Tok_New);\n+      Set_Reserved (Name_Not,       Tok_Not);\n+      Set_Reserved (Name_Null,      Tok_Null);\n+      Set_Reserved (Name_Of,        Tok_Of);\n+      Set_Reserved (Name_Or,        Tok_Or);\n+      Set_Reserved (Name_Others,    Tok_Others);\n+      Set_Reserved (Name_Out,       Tok_Out);\n+      Set_Reserved (Name_Package,   Tok_Package);\n+      Set_Reserved (Name_Pragma,    Tok_Pragma);\n+      Set_Reserved (Name_Private,   Tok_Private);\n+      Set_Reserved (Name_Procedure, Tok_Procedure);\n+      Set_Reserved (Name_Protected, Tok_Protected);\n+      Set_Reserved (Name_Raise,     Tok_Raise);\n+      Set_Reserved (Name_Range,     Tok_Range);\n+      Set_Reserved (Name_Record,    Tok_Record);\n+      Set_Reserved (Name_Rem,       Tok_Rem);\n+      Set_Reserved (Name_Renames,   Tok_Renames);\n+      Set_Reserved (Name_Requeue,   Tok_Requeue);\n+      Set_Reserved (Name_Return,    Tok_Return);\n+      Set_Reserved (Name_Reverse,   Tok_Reverse);\n+      Set_Reserved (Name_Select,    Tok_Select);\n+      Set_Reserved (Name_Separate,  Tok_Separate);\n+      Set_Reserved (Name_Subtype,   Tok_Subtype);\n+      Set_Reserved (Name_Tagged,    Tok_Tagged);\n+      Set_Reserved (Name_Task,      Tok_Task);\n+      Set_Reserved (Name_Terminate, Tok_Terminate);\n+      Set_Reserved (Name_Then,      Tok_Then);\n+      Set_Reserved (Name_Type,      Tok_Type);\n+      Set_Reserved (Name_Until,     Tok_Until);\n+      Set_Reserved (Name_Use,       Tok_Use);\n+      Set_Reserved (Name_When,      Tok_When);\n+      Set_Reserved (Name_While,     Tok_While);\n+      Set_Reserved (Name_With,      Tok_With);\n+      Set_Reserved (Name_Xor,       Tok_Xor);\n+\n+      --  Ada 2005 reserved words\n+\n+      Set_Reserved (Name_Interface,     Tok_Interface);\n+      Set_Reserved (Name_Overriding,    Tok_Overriding);\n+      Set_Reserved (Name_Synchronized,  Tok_Synchronized);\n \n       --  Initialize scan control variables\n \n@@ -246,10 +275,22 @@ package body Scng is\n    procedure Scan is\n \n       Start_Of_Comment : Source_Ptr;\n+      --  Record start of comment position\n+\n+      Underline_Found : Boolean;\n+      --  During scanning of an identifier, set to True if last character\n+      --  scanned was an underline or other punctuation character. This\n+      --  is used to flag the error of two underlines/punctuations in a\n+      --  row or ending an identifier with a underline/punctuation. Here\n+      --  punctuation means any UTF_32 character in the Unicode category\n+      --  Punctuation,Connector.\n+\n+      Wptr : Source_Ptr;\n+      --  Used to remember start of last wide character scanned\n \n       procedure Check_End_Of_Line;\n-      --  Called when end of line encountered. Checks that line is not\n-      --  too long, and that other style checks for the end of line are met.\n+      --  Called when end of line encountered. Checks that line is not too\n+      --  long, and that other style checks for the end of line are met.\n \n       function Double_Char_Token (C : Character) return Boolean;\n       --  This function is used for double character tokens like := or <>. It\n@@ -262,8 +303,8 @@ package body Scng is\n       --  since we do not want a junk message for a case like &-space-&).\n \n       procedure Error_Illegal_Character;\n-      --  Give illegal character error, Scan_Ptr points to character.\n-      --  On return, Scan_Ptr is bumped past the illegal character.\n+      --  Give illegal character error, Scan_Ptr points to character. On\n+      --  return, Scan_Ptr is bumped past the illegal character.\n \n       procedure Error_Illegal_Wide_Character;\n       --  Give illegal wide character message. On return, Scan_Ptr is bumped\n@@ -274,7 +315,8 @@ package body Scng is\n       --  Signal error of excessively long line\n \n       procedure Error_No_Double_Underline;\n-      --  Signal error of double underline character\n+      --  Signal error of two underline or punctuation characters in a row.\n+      --  Called with Scan_Ptr pointing to second underline/punctuation char.\n \n       procedure Nlit;\n       --  This is the procedure for scanning out numeric literals. On entry,\n@@ -353,8 +395,7 @@ package body Scng is\n \n       procedure Error_Illegal_Wide_Character is\n       begin\n-         Error_Msg_S (\"illegal wide character, check -gnatW switch\");\n-         Scan_Ptr := Scan_Ptr + 1;\n+         Error_Msg (\"illegal wide character\", Wptr);\n       end Error_Illegal_Wide_Character;\n \n       ---------------------\n@@ -374,7 +415,28 @@ package body Scng is\n \n       procedure Error_No_Double_Underline is\n       begin\n-         Error_Msg_S (\"two consecutive underlines not permitted\");\n+         Underline_Found := False;\n+\n+         --  There are four cases, and we special case the messages\n+\n+         if Source (Scan_Ptr) = '_' then\n+            if Source (Scan_Ptr - 1) = '_' then\n+               Error_Msg_S\n+                 (\"two consecutive underlines not permitted\");\n+            else\n+               Error_Msg_S\n+                 (\"underline cannot follow punctuation character\");\n+            end if;\n+\n+         else\n+            if Source (Scan_Ptr - 1) = '_' then\n+               Error_Msg_S\n+                 (\"punctuation character cannot follow underline\");\n+            else\n+               Error_Msg_S\n+                 (\"two consecutive punctuation characters not permitted\");\n+            end if;\n+         end if;\n       end Error_No_Double_Underline;\n \n       ----------\n@@ -425,13 +487,13 @@ package body Scng is\n          --  which the digit was expected on input, and is unchanged on return.\n \n          procedure Scan_Integer;\n-         --  Procedure to scan integer literal. On entry, Scan_Ptr points to\n-         --  a digit, on exit Scan_Ptr points past the last character of\n-         --  the integer.\n+         --  Procedure to scan integer literal. On entry, Scan_Ptr points to a\n+         --  digit, on exit Scan_Ptr points past the last character of the\n+         --  integer.\n          --\n-         --  For each digit encountered, UI_Int_Value is multiplied by 10,\n-         --  and the value of the digit added to the result. In addition,\n-         --  the value in Scale is decremented by one for each actual digit\n+         --  For each digit encountered, UI_Int_Value is multiplied by 10, and\n+         --  the value of the digit added to the result. In addition, the\n+         --  value in Scale is decremented by one for each actual digit\n          --  scanned.\n \n          --------------------------\n@@ -464,6 +526,8 @@ package body Scng is\n                Scale := Scale - 1;\n                C := Source (Scan_Ptr);\n \n+               --  Case of underline encountered\n+\n                if C = '_' then\n \n                   --  We do not accumulate the '_' in the checksum, so that\n@@ -486,12 +550,9 @@ package body Scng is\n                   exit when C not in '0' .. '9';\n                end if;\n             end loop;\n-\n          end Scan_Integer;\n \n-         ----------------------------------\n-         -- Start of Processing for Nlit --\n-         ----------------------------------\n+      --  Start of Processing for Nlit\n \n       begin\n          Base := 10;\n@@ -503,8 +564,8 @@ package body Scng is\n          Point_Scanned := False;\n          UI_Num_Value := UI_Int_Value;\n \n-         --  Various possibilities now for continuing the literal are\n-         --  period, E/e (for exponent), or :/# (for based literal).\n+         --  Various possibilities now for continuing the literal are period,\n+         --  E/e (for exponent), or :/# (for based literal).\n \n          Scale := 0;\n          C := Source (Scan_Ptr);\n@@ -534,11 +595,11 @@ package body Scng is\n                end if;\n             end loop;\n \n-            --  Based literal case. The base is the value we already scanned.\n-            --  In the case of colon, we insist that the following character\n-            --  is indeed an extended digit or a period. This catches a number\n-            --  of common errors, as well as catching the well known tricky\n-            --  bug otherwise arising from \"x : integer range 1 .. 10:= 6;\"\n+         --  Based literal case. The base is the value we already scanned.\n+         --  In the case of colon, we insist that the following character\n+         --  is indeed an extended digit or a period. This catches a number\n+         --  of common errors, as well as catching the well known tricky\n+         --  bug otherwise arising from \"x : integer range 1 .. 10:= 6;\"\n \n          elsif C = '#'\n            or else (C = ':' and then\n@@ -561,7 +622,6 @@ package body Scng is\n                end if;\n             end if;\n \n-\n             Accumulate_Checksum (C);\n             Base_Char := C;\n             UI_Base := UI_Int_Value;\n@@ -712,17 +772,17 @@ package body Scng is\n                                   Den   => -UI_Scale,\n                                   Rbase => Base);\n \n-            --  Case of integer literal to be returned\n+         --  Case of integer literal to be returned\n \n          else\n             Token := Tok_Integer_Literal;\n \n             if UI_Scale = 0 then\n                Int_Literal_Value := UI_Num_Value;\n \n-               --  Avoid doing possibly expensive calculations in cases like\n-               --  parsing 163E800_000# when semantics will not be done anyway.\n-               --  This is especially useful when parsing garbled input.\n+            --  Avoid doing possibly expensive calculations in cases like\n+            --  parsing 163E800_000# when semantics will not be done anyway.\n+            --  This is especially useful when parsing garbled input.\n \n             elsif Operating_Mode /= Check_Syntax\n               and then (Serious_Errors_Detected = 0 or else Try_Semantics)\n@@ -731,15 +791,12 @@ package body Scng is\n \n             else\n                Int_Literal_Value := No_Uint;\n-\n             end if;\n-\n          end if;\n \n          Accumulate_Token_Checksum;\n \n          return;\n-\n       end Nlit;\n \n       ----------\n@@ -762,8 +819,8 @@ package body Scng is\n \n          procedure Error_Bad_String_Char;\n          --  Signal bad character in string/character literal. On entry\n-         --  Scan_Ptr points to the improper character encountered during\n-         --  the scan. Scan_Ptr is not modified, so it still points to the bad\n+         --  Scan_Ptr points to the improper character encountered during the\n+         --  scan. Scan_Ptr is not modified, so it still points to the bad\n          --  character on return.\n \n          procedure Error_Unterminated_String;\n@@ -773,11 +830,11 @@ package body Scng is\n \n          procedure Set_String;\n          --  Procedure used to distinguish between string and operator symbol.\n-         --  On entry the string has been scanned out, and its characters start\n-         --  at Token_Ptr and end one character before Scan_Ptr. On exit Token\n-         --  is set to Tok_String_Literal or Tok_Operator_Symbol as\n-         --  appropriate, and Token_Node is appropriately initialized.\n-         --  In addition, in the operator symbol case, Token_Name is\n+         --  On entry the string has been scanned out, and its characters\n+         --  start at Token_Ptr and end one character before Scan_Ptr. On exit\n+         --  Token is set to Tok_String_Literal or Tok_Operator_Symbol as\n+         --  appropriate, and Token_Node is appropriately initialized. In\n+         --  addition, in the operator symbol case, Token_Name is\n          --  appropriately set.\n \n          ---------------------------\n@@ -981,28 +1038,25 @@ package body Scng is\n \n             end if;\n \n-            --  If it is an operator symbol, then Token_Name is set.\n-            --  If it is some other string value, then Token_Name still\n-            --  contains Error_Name.\n+            --  If it is an operator symbol, then Token_Name is set. If it is\n+            --  some other string value, then Token_Name still contains\n+            --  Error_Name.\n \n             if Token_Name = Error_Name then\n                Token := Tok_String_Literal;\n \n             else\n                Token := Tok_Operator_Symbol;\n             end if;\n-\n          end Set_String;\n \n-         ----------\n-         -- Slit --\n-         ----------\n+      --  Start of processing for Slit\n \n       begin\n          --  On entry, Scan_Ptr points to the opening character of the string\n-         --  which is either a percent, double quote, or apostrophe\n-         --  (single quote). The latter case is an error detected by\n-         --  the character literal circuit.\n+         --  which is either a percent, double quote, or apostrophe (single\n+         --  quote). The latter case is an error detected by the character\n+         --  literal circuit.\n \n          Delimiter := Source (Scan_Ptr);\n          Accumulate_Checksum (Delimiter);\n@@ -1030,28 +1084,32 @@ package body Scng is\n                   Scan_Ptr := Scan_Ptr + 1;\n \n                elsif (C = ESC\n-                        and then\n-                        Wide_Character_Encoding_Method\n-                                             in WC_ESC_Encoding_Method)\n-                 or else\n-                 (C in Upper_Half_Character\n-                    and then\n-                    Upper_Half_Encoding)\n-                 or else\n-                 (C = '['\n-                    and then\n-                    Source (Scan_Ptr + 1) = '\"'\n-                    and then\n-                    Identifier_Char (Source (Scan_Ptr + 2)))\n+                        and then Wide_Character_Encoding_Method\n+                                   in WC_ESC_Encoding_Method)\n+                 or else (C in Upper_Half_Character\n+                            and then Upper_Half_Encoding)\n+                 or else (C = '['\n+                            and then Source (Scan_Ptr + 1) = '\"'\n+                            and then Identifier_Char (Source (Scan_Ptr + 2)))\n                then\n+                  Wptr := Scan_Ptr;\n                   Scan_Wide (Source, Scan_Ptr, Code, Err);\n-                  Accumulate_Checksum (Code);\n \n                   if Err then\n                      Error_Illegal_Wide_Character;\n                      Code := Get_Char_Code (' ');\n                   end if;\n \n+                  Accumulate_Checksum (Code);\n+\n+                  if Ada_Version >= Ada_05\n+                    and then Is_UTF_32_Non_Graphic (Code)\n+                  then\n+                     Error_Msg\n+                       (\"(Ada 2005) non-graphic character not permitted \" &\n+                        \"in string literal\", Wptr);\n+                  end if;\n+\n                else\n                   Accumulate_Checksum (C);\n \n@@ -1085,10 +1143,9 @@ package body Scng is\n          String_Literal_Id := End_String;\n          Set_String;\n          return;\n-\n       end Slit;\n \n-   --  Start of body of Scan\n+   --  Start of processing for Scan\n \n    begin\n       Prev_Token := Token;\n@@ -1100,11 +1157,12 @@ package body Scng is\n       --  encountered and skipped, or some error situation, such as an\n       --  illegal character, is encountered.\n \n+      <<Scan_Next_Character>>\n+\n       loop\n          --  Skip past blanks, loop is opened up for speed\n \n          while Source (Scan_Ptr) = ' ' loop\n-\n             if Source (Scan_Ptr + 1) /= ' ' then\n                Scan_Ptr := Scan_Ptr + 1;\n                exit;\n@@ -1148,66 +1206,30 @@ package body Scng is\n \n          Token_Ptr := Scan_Ptr;\n \n-         --  Here begins the main case statement which transfers control on\n-         --  the basis of the non-blank character we have encountered.\n+         --  Here begins the main case statement which transfers control on the\n+         --  basis of the non-blank character we have encountered.\n \n          case Source (Scan_Ptr) is\n \n          --  Line terminator characters\n \n-         when CR | LF | FF | VT => Line_Terminator_Case : begin\n-\n-            --  Check line too long\n-\n-            Check_End_Of_Line;\n-\n-            --  Set Token_Ptr, if End_Of_Line is a token, for the case when\n-            --  it is a physical line.\n-\n-            if End_Of_Line_Is_Token then\n-               Token_Ptr := Scan_Ptr;\n-            end if;\n-\n-            declare\n-               Physical : Boolean;\n-\n-            begin\n-               Skip_Line_Terminators (Scan_Ptr, Physical);\n-\n-               --  If we are at start of physical line, update scan pointers\n-               --  to reflect the start of the new line.\n-\n-               if Physical then\n-                  Current_Line_Start       := Scan_Ptr;\n-                  Start_Column             := Set_Start_Column;\n-                  First_Non_Blank_Location := Scan_Ptr;\n-\n-                  --  If End_Of_Line is a token, we return it as it is\n-                  --  a physical line.\n-\n-                  if End_Of_Line_Is_Token then\n-                     Token := Tok_End_Of_Line;\n-                     return;\n-                  end if;\n-               end if;\n-            end;\n-         end Line_Terminator_Case;\n+         when CR | LF | FF | VT =>\n+            goto Scan_Line_Terminator;\n \n          --  Horizontal tab, just skip past it\n \n          when HT =>\n             if Style_Check then Style.Check_HT; end if;\n             Scan_Ptr := Scan_Ptr + 1;\n \n-         --  End of file character, treated as an end of file only if it\n-         --  is the last character in the buffer, otherwise it is ignored.\n+         --  End of file character, treated as an end of file only if it is\n+         --  the last character in the buffer, otherwise it is ignored.\n \n          when EOF =>\n             if Scan_Ptr = Source_Last (Current_Source_File) then\n                Check_End_Of_Line;\n                Token := Tok_EOF;\n                return;\n-\n             else\n                Scan_Ptr := Scan_Ptr + 1;\n             end if;\n@@ -1229,8 +1251,8 @@ package body Scng is\n                return;\n             end if;\n \n-         --  Asterisk (can be multiplication operator or double asterisk\n-         --  which is the exponentiation compound delimiter).\n+         --  Asterisk (can be multiplication operator or double asterisk which\n+         --  is the exponentiation compound delimiter).\n \n          when '*' =>\n             Accumulate_Checksum ('*');\n@@ -1286,8 +1308,7 @@ package body Scng is\n \n          when '[' =>\n             if Source (Scan_Ptr + 1) = '\"' then\n-               Name_Len := 0;\n-               goto Scan_Identifier;\n+               goto Scan_Wide_Character;\n \n             else\n                Error_Msg_S (\"illegal character, replaced by \"\"(\"\"\");\n@@ -1313,9 +1334,9 @@ package body Scng is\n             if Style_Check then Style.Check_Comma; end if;\n             return;\n \n-         --  Dot, which is either an isolated period, or part of a double\n-         --  dot compound delimiter sequence. We also check for the case of\n-         --  a digit following the period, to give a better error message.\n+         --  Dot, which is either an isolated period, or part of a double dot\n+         --  compound delimiter sequence. We also check for the case of a\n+         --  digit following the period, to give a better error message.\n \n          when '.' =>\n             Accumulate_Checksum ('.');\n@@ -1430,6 +1451,15 @@ package body Scng is\n                loop\n                   --  Scan to non graphic character (opened up for speed)\n \n+                  --  Note that we just eat left brackets, which means that\n+                  --  bracket notation cannot be used for end of line\n+                  --  characters in comments. This seems a reasonable choice,\n+                  --  since no one would ever use brackets notation in a real\n+                  --  program in this situation, and if we allow brackets\n+                  --  notation, we forbid some valid comments which contain a\n+                  --  brackets sequence that happens to match an end of line\n+                  --  character.\n+\n                   loop\n                      exit when Source (Scan_Ptr) not in Graphic_Character;\n                      Scan_Ptr := Scan_Ptr + 1;\n@@ -1460,13 +1490,44 @@ package body Scng is\n                   elsif Source (Scan_Ptr) = EOF then\n                      exit;\n \n+                  --  If we have a wide character, we have to scan it out,\n+                  --  because it might be a legitimate line terminator\n+\n+                  elsif (Source (Scan_Ptr) = ESC\n+                           and then Identifier_Char (ESC))\n+                    or else\n+                         (Source (Scan_Ptr) in Upper_Half_Character\n+                            and then Upper_Half_Encoding)\n+                  then\n+                     declare\n+                        Wptr : constant Source_Ptr := Scan_Ptr;\n+                        Code : Char_Code;\n+                        Err  : Boolean;\n+\n+                     begin\n+                        Scan_Wide (Source, Scan_Ptr, Code, Err);\n+\n+                        --  If not well formed wide character, then just skip\n+                        --  past it and ignore it.\n+\n+                        if Err then\n+                           Scan_Ptr := Wptr + 1;\n+\n+                        --  If UTF_32 terminator, terminate comment scan\n+\n+                        elsif Is_UTF_32_Line_Terminator (Code) then\n+                           Scan_Ptr := Wptr;\n+                           exit;\n+                        end if;\n+                     end;\n+\n                   --  Keep going if character in 80-FF range, or is ESC. These\n                   --  characters are allowed in comments by RM-2.1(1), 2.7(2).\n                   --  They are allowed even in Ada 83 mode according to the\n                   --  approved AI. ESC was added to the AI in June 93.\n \n                   elsif Source (Scan_Ptr) in Upper_Half_Character\n-                    or else Source (Scan_Ptr) = ESC\n+                     or else Source (Scan_Ptr) = ESC\n                   then\n                      Scan_Ptr := Scan_Ptr + 1;\n \n@@ -1475,7 +1536,6 @@ package body Scng is\n                   else\n                      Error_Illegal_Character;\n                   end if;\n-\n                end loop;\n \n                --  Note that, except when comments are tokens, we do NOT\n@@ -1538,10 +1598,10 @@ package body Scng is\n             --  Here is where we make the test to distinguish the cases. Treat\n             --  as apostrophe if previous token is an identifier, right paren\n             --  or the reserved word \"all\" (latter case as in A.all'Address)\n-            --  (or the reserved word \"project\" in project files).\n-            --  Also treat it as apostrophe after a literal (this catches\n-            --  some legitimate cases, like A.\"abs\"'Address, and also gives\n-            --  better error behavior for impossible cases like 123'xxx).\n+            --  (or the reserved word \"project\" in project files). Also treat\n+            --  it as apostrophe after a literal (this catches some legitimate\n+            --  cases, like A.\"abs\"'Address, and also gives better error\n+            --  behavior for impossible cases like 123'xxx).\n \n             if Prev_Token = Tok_Identifier\n                or else Prev_Token = Tok_Right_Paren\n@@ -1556,7 +1616,7 @@ package body Scng is\n             --  Otherwise the apostrophe starts a character literal\n \n             else\n-               --  Case of wide character literal with ESC or [ encoding\n+               --  Case of wide character literal\n \n                if (Source (Scan_Ptr) = ESC\n                      and then\n@@ -1570,11 +1630,20 @@ package body Scng is\n                      and then\n                     Source (Scan_Ptr + 1) = '\"')\n                then\n+                  Wptr := Scan_Ptr;\n                   Scan_Wide (Source, Scan_Ptr, Code, Err);\n                   Accumulate_Checksum (Code);\n \n                   if Err then\n                      Error_Illegal_Wide_Character;\n+                     Code := Character'Pos (' ');\n+\n+                  elsif Ada_Version >= Ada_05\n+                    and then Is_UTF_32_Non_Graphic (Code)\n+                  then\n+                     Error_Msg\n+                       (\"(Ada 2005) non-graphic character not permitted \" &\n+                        \"in character literal\", Wptr);\n                   end if;\n \n                   if Source (Scan_Ptr) /= ''' then\n@@ -1590,7 +1659,6 @@ package body Scng is\n                --  apostrophe instead since this gives better error recovery\n \n                elsif Source (Scan_Ptr + 1) /= ''' then\n-\n                   if Prev_Token = Tok_Range then\n                      Token := Tok_Apostrophe;\n                      return;\n@@ -1722,7 +1790,6 @@ package body Scng is\n                Token := Tok_Vertical_Bar;\n                return;\n             end if;\n-\n          end Exclamation_Case;\n \n          --  Plus\n@@ -1750,6 +1817,7 @@ package body Scng is\n \n          when 'a' .. 'z' =>\n             Name_Len := 1;\n+            Underline_Found := False;\n             Name_Buffer (1) := Source (Scan_Ptr);\n             Accumulate_Checksum (Name_Buffer (1));\n             Scan_Ptr := Scan_Ptr + 1;\n@@ -1759,6 +1827,7 @@ package body Scng is\n \n          when 'A' .. 'Z' =>\n             Name_Len := 1;\n+            Underline_Found := False;\n             Name_Buffer (1) :=\n               Character'Val (Character'Pos (Source (Scan_Ptr)) + 32);\n             Accumulate_Checksum (Name_Buffer (1));\n@@ -1780,6 +1849,7 @@ package body Scng is\n             Name_Len := 1;\n             Name_Buffer (1) := '_';\n             Scan_Ptr := Scan_Ptr + 1;\n+            Underline_Found := False;\n             goto Scan_Identifier;\n \n          --  Space (not possible, because we scanned past blanks)\n@@ -1791,23 +1861,21 @@ package body Scng is\n \n          when Upper_Half_Character =>\n \n-            --  Wide character case. Note that Scan_Identifier will issue\n-            --  an appropriate message if wide characters are not allowed\n-            --  in identifiers.\n+            --  Wide character case\n \n             if Upper_Half_Encoding then\n-               Name_Len := 0;\n-               goto Scan_Identifier;\n+               goto Scan_Wide_Character;\n \n             --  Otherwise we have OK Latin-1 character\n \n             else\n                --  Upper half characters may possibly be identifier letters\n-               --  but can never be digits, so Identifier_Char can be used\n-               --  to test for a valid start of identifier character.\n+               --  but can never be digits, so Identifier_Char can be used to\n+               --  test for a valid start of identifier character.\n \n                if Identifier_Char (Source (Scan_Ptr)) then\n                   Name_Len := 0;\n+                  Underline_Found := False;\n                   goto Scan_Identifier;\n                else\n                   Error_Illegal_Character;\n@@ -1819,13 +1887,14 @@ package body Scng is\n             --  ESC character, possible start of identifier if wide characters\n             --  using ESC encoding are allowed in identifiers, which we can\n             --  tell by looking at the Identifier_Char flag for ESC, which is\n-            --  only true if these conditions are met.\n+            --  only true if these conditions are met. In Ada 2005 mode, may\n+            --  also be valid UTF_32 space or line terminator character.\n \n             if Identifier_Char (ESC) then\n                Name_Len := 0;\n-               goto Scan_Identifier;\n+               goto Scan_Wide_Character;\n             else\n-               Error_Illegal_Wide_Character;\n+               Error_Illegal_Character;\n             end if;\n \n          --  Invalid control characters\n@@ -1839,6 +1908,7 @@ package body Scng is\n          --  Invalid graphic characters\n \n          when '#' | '$' | '?' | '@' | '`' | '\\' | '^' | '~' =>\n+\n             --  If Set_Special_Character has been called for this character,\n             --  set Scans.Special_Character and return a Special token.\n \n@@ -1849,7 +1919,7 @@ package body Scng is\n                Scan_Ptr := Scan_Ptr + 1;\n                return;\n \n-            --  otherwise, this is an illegal character\n+            --  Otherwise, this is an illegal character\n \n             else\n                Error_Illegal_Character;\n@@ -1865,95 +1935,177 @@ package body Scng is\n \n       end loop;\n \n-      --  Identifier scanning routine. On entry, some initial characters\n-      --  of the identifier may have already been stored in Name_Buffer.\n-      --  If so, Name_Len has the number of characters stored. otherwise\n-      --  Name_Len is set to zero on entry.\n+      --  Wide_Character scanning routine. On entry we have encountered the\n+      --  initial character of a wide character sequence.\n \n-      <<Scan_Identifier>>\n+      <<Scan_Wide_Character>>\n \n-         --  This loop scans as fast as possible past lower half letters\n-         --  and digits, which we expect to be the most common characters.\n+         declare\n+            Code : Char_Code;\n+            Err  : Boolean;\n \n-         loop\n-            if Source (Scan_Ptr) in 'a' .. 'z'\n-              or else Source (Scan_Ptr) in '0' .. '9'\n-            then\n-               Name_Buffer (Name_Len + 1) := Source (Scan_Ptr);\n-               Accumulate_Checksum (Source (Scan_Ptr));\n+         begin\n+            Wptr := Scan_Ptr;\n+            Scan_Wide (Source, Scan_Ptr, Code, Err);\n \n-            elsif Source (Scan_Ptr) in 'A' .. 'Z' then\n-               Name_Buffer (Name_Len + 1) :=\n-                 Character'Val (Character'Pos (Source (Scan_Ptr)) + 32);\n-               Accumulate_Checksum (Name_Buffer (Name_Len + 1));\n-            else\n-               exit;\n-            end if;\n+            --  If bad wide character, signal error and continue scan\n \n-            --  Open out the loop a couple of times for speed\n+            if Err then\n+               Error_Illegal_Wide_Character;\n+               goto Scan_Next_Character;\n \n-            if Source (Scan_Ptr + 1) in 'a' .. 'z'\n-              or else Source (Scan_Ptr + 1) in '0' .. '9'\n-            then\n-               Name_Buffer (Name_Len + 2) := Source (Scan_Ptr + 1);\n-               Accumulate_Checksum (Source (Scan_Ptr + 1));\n+            --  If OK letter, reset scan ptr and go scan identifier\n+\n+            elsif Is_UTF_32_Letter (Code) then\n+               Scan_Ptr := Wptr;\n+               Name_Len := 0;\n+               Underline_Found := False;\n+               goto Scan_Identifier;\n \n-            elsif Source (Scan_Ptr + 1) in 'A' .. 'Z' then\n-               Name_Buffer (Name_Len + 2) :=\n-                 Character'Val (Character'Pos (Source (Scan_Ptr + 1)) + 32);\n-               Accumulate_Checksum (Name_Buffer (Name_Len + 2));\n+            --  If OK wide space, ignore and keep scanning (we do not include\n+            --  any ignored spaces in checksum)\n+\n+            elsif Is_UTF_32_Space (Code) then\n+               goto Scan_Next_Character;\n+\n+            --  If OK wide line terminator, terminate current line\n+\n+            elsif Is_UTF_32_Line_Terminator (Code) then\n+               Scan_Ptr := Wptr;\n+               goto Scan_Line_Terminator;\n+\n+            --  Punctuation is an error (at start of identifier)\n+\n+            elsif Is_UTF_32_Punctuation (Code) then\n+               Error_Msg\n+                 (\"identifier cannot start with punctuation\", Wptr);\n+               Scan_Ptr := Wptr;\n+               Name_Len := 0;\n+               Underline_Found := False;\n+               goto Scan_Identifier;\n+\n+            --  Mark character is an error (at start of identifer)\n+\n+            elsif Is_UTF_32_Mark (Code) then\n+               Error_Msg\n+                 (\"identifier cannot start with mark character\", Wptr);\n+               Scan_Ptr := Wptr;\n+               Name_Len := 0;\n+               Underline_Found := False;\n+               goto Scan_Identifier;\n+\n+            --  Other format character is an error (at start of identifer)\n+\n+            elsif Is_UTF_32_Other (Code) then\n+               Error_Msg\n+                 (\"identifier cannot start with other format character\", Wptr);\n+               Scan_Ptr := Wptr;\n+               Name_Len := 0;\n+               Underline_Found := False;\n+               goto Scan_Identifier;\n+\n+            --  Extended digit character is an error. Could be bad start of\n+            --  identifier or bad literal. Not worth doing too much to try to\n+            --  distinguish these cases, but we will do a little bit.\n+\n+            elsif Is_UTF_32_Digit (Code) then\n+               Error_Msg\n+                 (\"identifier cannot start with digit character\", Wptr);\n+               Scan_Ptr := Wptr;\n+               Name_Len := 0;\n+               Underline_Found := False;\n+               goto Scan_Identifier;\n+\n+            --  All other wide characters are illegal here\n \n             else\n-               Scan_Ptr := Scan_Ptr + 1;\n-               Name_Len := Name_Len + 1;\n-               exit;\n+               Error_Illegal_Wide_Character;\n+               goto Scan_Next_Character;\n             end if;\n+         end;\n \n-            if Source (Scan_Ptr + 2) in 'a' .. 'z'\n-              or else Source (Scan_Ptr + 2) in '0' .. '9'\n-            then\n-               Name_Buffer (Name_Len + 3) := Source (Scan_Ptr + 2);\n-               Accumulate_Checksum (Source (Scan_Ptr + 2));\n+      --  Routine to scan line terminator. On entry Scan_Ptr points to a\n+      --  character which is one of FF,LR,CR,VT, or one of the wide characters\n+      --  that is treated as a line termiantor.\n \n-            elsif Source (Scan_Ptr + 2) in 'A' .. 'Z' then\n-               Name_Buffer (Name_Len + 3) :=\n-                 Character'Val (Character'Pos (Source (Scan_Ptr + 2)) + 32);\n-               Accumulate_Checksum (Name_Buffer (Name_Len + 3));\n-            else\n-               Scan_Ptr := Scan_Ptr + 2;\n-               Name_Len := Name_Len + 2;\n-               exit;\n+      <<Scan_Line_Terminator>>\n+\n+         --  Check line too long\n+\n+         Check_End_Of_Line;\n+\n+         --  Set Token_Ptr, if End_Of_Line is a token, for the case when it is\n+         --  a physical line.\n+\n+         if End_Of_Line_Is_Token then\n+            Token_Ptr := Scan_Ptr;\n+         end if;\n+\n+         declare\n+            Physical : Boolean;\n+\n+         begin\n+            Skip_Line_Terminators (Scan_Ptr, Physical);\n+\n+            --  If we are at start of physical line, update scan pointers to\n+            --  reflect the start of the new line.\n+\n+            if Physical then\n+               Current_Line_Start       := Scan_Ptr;\n+               Start_Column             := Set_Start_Column;\n+               First_Non_Blank_Location := Scan_Ptr;\n+\n+               --  If End_Of_Line is a token, we return it as it is a\n+               --  physical line.\n+\n+               if End_Of_Line_Is_Token then\n+                  Token := Tok_End_Of_Line;\n+                  return;\n+               end if;\n             end if;\n+         end;\n+\n+         goto Scan_Next_Character;\n \n-            if Source (Scan_Ptr + 3) in 'a' .. 'z'\n-              or else Source (Scan_Ptr + 3) in '0' .. '9'\n+      --  Identifier scanning routine. On entry, some initial characters of\n+      --  the identifier may have already been stored in Name_Buffer. If so,\n+      --  Name_Len has the number of characters stored. otherwise Name_Len is\n+      --  set to zero on entry. Underline_Found is also set False on entry.\n+\n+      <<Scan_Identifier>>\n+\n+         --  This loop scans as fast as possible past lower half letters and\n+         --  digits, which we expect to be the most common characters.\n+\n+         loop\n+            if Source (Scan_Ptr) in 'a' .. 'z'\n+              or else Source (Scan_Ptr) in '0' .. '9'\n             then\n-               Name_Buffer (Name_Len + 4) := Source (Scan_Ptr + 3);\n-               Accumulate_Checksum (Source (Scan_Ptr + 3));\n+               Name_Buffer (Name_Len + 1) := Source (Scan_Ptr);\n+               Accumulate_Checksum (Source (Scan_Ptr));\n \n-            elsif Source (Scan_Ptr + 3) in 'A' .. 'Z' then\n-               Name_Buffer (Name_Len + 4) :=\n-                 Character'Val (Character'Pos (Source (Scan_Ptr + 3)) + 32);\n-               Accumulate_Checksum (Name_Buffer (Name_Len + 4));\n+            elsif Source (Scan_Ptr) in 'A' .. 'Z' then\n+               Name_Buffer (Name_Len + 1) :=\n+                 Character'Val (Character'Pos (Source (Scan_Ptr)) + 32);\n+               Accumulate_Checksum (Name_Buffer (Name_Len + 1));\n \n             else\n-               Scan_Ptr := Scan_Ptr + 3;\n-               Name_Len := Name_Len + 3;\n                exit;\n             end if;\n \n-            Scan_Ptr := Scan_Ptr + 4;\n-            Name_Len := Name_Len + 4;\n+            Underline_Found := False;\n+            Scan_Ptr := Scan_Ptr + 1;\n+            Name_Len := Name_Len + 1;\n          end loop;\n \n          --  If we fall through, then we have encountered either an underline\n          --  character, or an extended identifier character (i.e. one from the\n-         --  upper half), or a wide character, or an identifier terminator.\n-         --  The initial test speeds us up in the most common case where we\n-         --  have an identifier terminator. Note that ESC is an identifier\n-         --  character only if a wide character encoding method that uses\n-         --  ESC encoding is active, so if we find an ESC character we know\n-         --  that we have a wide character.\n+         --  upper half), or a wide character, or an identifier terminator. The\n+         --  initial test speeds us up in the most common case where we have\n+         --  an identifier terminator. Note that ESC is an identifier character\n+         --  only if a wide character encoding method that uses ESC encoding\n+         --  is active, so if we find an ESC character we know that we have a\n+         --  wide character.\n \n          if Identifier_Char (Source (Scan_Ptr)) then\n \n@@ -1962,22 +2114,10 @@ package body Scng is\n             if Source (Scan_Ptr) = '_' then\n                Accumulate_Checksum ('_');\n \n-               --  Check error case of identifier ending with underscore\n-               --  In this case we ignore the underscore and do not store it.\n-\n-               if not Identifier_Char (Source (Scan_Ptr + 1)) then\n-                  Error_Msg_S (\"identifier cannot end with underline\");\n-                  Scan_Ptr := Scan_Ptr + 1;\n-\n-               --  Check error case of two underscores. In this case we do\n-               --  not store the first underscore (we will store the second)\n-\n-               elsif Source (Scan_Ptr + 1) = '_' then\n-                     Error_No_Double_Underline;\n-\n-               --  Normal case of legal underscore\n-\n+               if Underline_Found then\n+                  Error_No_Double_Underline;\n                else\n+                  Underline_Found := True;\n                   Name_Len := Name_Len + 1;\n                   Name_Buffer (Name_Len) := '_';\n                end if;\n@@ -1994,6 +2134,7 @@ package body Scng is\n                Store_Encoded_Character\n                  (Get_Char_Code (Fold_Lower (Source (Scan_Ptr))));\n                Scan_Ptr := Scan_Ptr + 1;\n+               Underline_Found := False;\n                goto Scan_Identifier;\n \n             --  Left bracket not followed by a quote terminates an identifier.\n@@ -2014,12 +2155,12 @@ package body Scng is\n                --  encoding into the name table entry for the identifier.\n \n                declare\n-                  Sptr : constant Source_Ptr := Scan_Ptr;\n-                  Code : Char_Code;\n-                  Err  : Boolean;\n-                  Chr  : Character;\n+                  Code   : Char_Code;\n+                  Err    : Boolean;\n+                  Chr    : Character;\n \n                begin\n+                  Wptr := Scan_Ptr;\n                   Scan_Wide (Source, Scan_Ptr, Code, Err);\n \n                   --  If error, signal error\n@@ -2037,52 +2178,127 @@ package body Scng is\n                      Accumulate_Checksum (Chr);\n                      Store_Encoded_Character\n                        (Get_Char_Code (Fold_Lower (Chr)));\n+                     Underline_Found := False;\n \n-                  --  Character is not normal identifier character, store\n-                  --  it in encoded form.\n+                  --  Here if not a normal identifier character\n \n                   else\n-                     Accumulate_Checksum (Code);\n-                     Store_Encoded_Character (Code);\n-\n                      --  Make sure we are allowing wide characters in\n                      --  identifiers. Note that we allow wide character\n-                     --  notation for an OK identifier character. This\n-                     --  in particular allows bracket or other notation\n-                     --  to be used for upper half letters.\n+                     --  notation for an OK identifier character. This in\n+                     --  particular allows bracket or other notation to be\n+                     --  used for upper half letters.\n \n                      --  Wide characters are always allowed in Ada 2005\n \n                      if Identifier_Character_Set /= 'w'\n                        and then Ada_Version < Ada_05\n                      then\n                         Error_Msg\n-                          (\"wide character not allowed in identifier\", Sptr);\n+                       (\"wide character not allowed in identifier\", Wptr);\n+                     end if;\n+\n+                     --  If OK letter, store it folding to upper case. Note\n+                     --  that we include the folded letter in the checksum.\n+\n+                     if Is_UTF_32_Letter (Code) then\n+                        Code := UTF_32_To_Upper_Case (Code);\n+                        Accumulate_Checksum (Code);\n+                        Store_Encoded_Character (Code);\n+                        Underline_Found := False;\n+\n+                     --  If OK extended digit or mark, then store it\n+\n+                     elsif Is_UTF_32_Digit (Code)\n+                       or else Is_UTF_32_Mark (Code)\n+                     then\n+                        Accumulate_Checksum (Code);\n+                        Store_Encoded_Character (Code);\n+                        Underline_Found := False;\n+\n+                     --  Wide punctuation is also stored, but counts as an\n+                     --  underline character for error checking purposes.\n+\n+                     elsif Is_UTF_32_Punctuation (Code) then\n+                        Accumulate_Checksum (Code);\n+\n+                        if Underline_Found then\n+                           declare\n+                              Cend : constant Source_Ptr := Scan_Ptr;\n+                           begin\n+                              Scan_Ptr := Wptr;\n+                              Error_No_Double_Underline;\n+                              Scan_Ptr := Cend;\n+                           end;\n+\n+                        else\n+                           Store_Encoded_Character (Code);\n+                           Underline_Found := True;\n+                        end if;\n+\n+                     --  Wide character in Unicode cateogory \"Other, Format\"\n+                     --  is accepted in an identifier, but is ignored and not\n+                     --  stored. It seems reasonable to exclude it from the\n+                     --  checksum.\n+\n+                     elsif Is_UTF_32_Other (Code) then\n+                        null;\n+\n+                     --  Wide character in category Separator,Space terminates\n+\n+                     elsif Is_UTF_32_Space (Code) then\n+                        goto Scan_Identifier_Complete;\n+\n+                     --  Any other wide character is not acceptable\n+\n+                     else\n+                        Error_Msg\n+                          (\"invalid wide character in identifier\", Wptr);\n                      end if;\n                   end if;\n-               end;\n \n-               goto Scan_Identifier;\n+                  goto Scan_Identifier;\n+               end;\n             end if;\n          end if;\n \n-         --  Scan of identifier is complete. The identifier is stored in\n-         --  Name_Buffer, and Scan_Ptr points past the last character.\n+      --  Scan of identifier is complete. The identifier is stored in\n+      --  Name_Buffer, and Scan_Ptr points past the last character.\n \n+      <<Scan_Identifier_Complete>>\n          Token_Name := Name_Find;\n \n+         --  Check for identifier ending with underline or punctuation char\n+\n+         if Underline_Found then\n+            Underline_Found := False;\n+\n+            if Source (Scan_Ptr - 1) = '_' then\n+               Error_Msg\n+                 (\"identifier cannot end with underline\", Scan_Ptr - 1);\n+            else\n+               Error_Msg\n+                 (\"identifier cannot end with punctuation character\", Wptr);\n+            end if;\n+         end if;\n+\n          --  Here is where we check if it was a keyword\n \n          if Get_Name_Table_Byte (Token_Name) /= 0\n            and then (Ada_Version >= Ada_95\n                        or else Token_Name not in Ada_95_Reserved_Words)\n+           and then (Ada_Version >= Ada_05\n+                       or else Token_Name not in Ada_2005_Reserved_Words)\n          then\n             Token := Token_Type'Val (Get_Name_Table_Byte (Token_Name));\n \n-            --  Deal with possible style check for non-lower case keyword,\n-            --  but we don't treat ACCESS, DELTA, DIGITS, RANGE as keywords\n-            --  for this purpose if they appear as attribute designators.\n-            --  Actually we only check the first character for speed.\n+            --  Deal with possible style check for non-lower case keyword, but\n+            --  we don't treat ACCESS, DELTA, DIGITS, RANGE as keywords for\n+            --  this purpose if they appear as attribute designators. Actually\n+            --  we only check the first character for speed.\n+\n+            --  Ada 2005 (AI-284): Do not apply the style check in case of\n+            --  \"pragma Interface\"\n \n             if Style_Check\n               and then Source (Token_Ptr) <= 'Z'\n@@ -2092,14 +2308,18 @@ package body Scng is\n                                and then Token /= Tok_Delta\n                                and then Token /= Tok_Digits\n                                and then Token /= Tok_Range))\n+              and then (Token /= Tok_Interface\n+                          or else\n+                            (Token = Tok_Interface\n+                               and then Prev_Token /= Tok_Pragma))\n             then\n                Style.Non_Lower_Case_Keyword;\n             end if;\n \n-            --  We must reset Token_Name since this is not an identifier\n-            --  and if we leave Token_Name set, the parser gets confused\n-            --  because it thinks it is dealing with an identifier instead\n-            --  of the corresponding keyword.\n+            --  We must reset Token_Name since this is not an identifier and\n+            --  if we leave Token_Name set, the parser gets confused because\n+            --  it thinks it is dealing with an identifier instead of the\n+            --  corresponding keyword.\n \n             Token_Name := No_Name;\n             Accumulate_Token_Checksum;"}, {"sha": "aa7cddff6a17100da162dbd74e8f05edc4bda746", "filename": "gcc/ada/sem_aggr.adb", "status": "modified", "additions": 42, "deletions": 33, "changes": 75, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/82c80734715c801643075ab68c5c9a5e00da1b03/gcc%2Fada%2Fsem_aggr.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/82c80734715c801643075ab68c5c9a5e00da1b03/gcc%2Fada%2Fsem_aggr.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_aggr.adb?ref=82c80734715c801643075ab68c5c9a5e00da1b03", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1992-2004 Free Software Foundation, Inc.          --\n+--          Copyright (C) 1992-2005 Free Software Foundation, Inc.          --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -837,7 +837,10 @@ package body Sem_Aggr is\n          C := Get_String_Char (Str, J);\n          Set_Character_Literal_Name (C);\n \n-         C_Node :=  Make_Character_Literal (P, Name_Find, C);\n+         C_Node :=\n+           Make_Character_Literal (P,\n+             Chars              => Name_Find,\n+             Char_Literal_Value => UI_From_CC (C));\n          Set_Etype (C_Node, Any_Character);\n          Append_To (Exprs, C_Node);\n \n@@ -915,8 +918,10 @@ package body Sem_Aggr is\n          if Number_Dimensions (Typ) = 1\n            and then\n              (Root_Type (Component_Type (Typ)) = Standard_Character\n-               or else\n-              Root_Type (Component_Type (Typ)) = Standard_Wide_Character)\n+                or else\n+              Root_Type (Component_Type (Typ)) = Standard_Wide_Character\n+                or else\n+              Root_Type (Component_Type (Typ)) = Standard_Wide_Wide_Character)\n            and then No (Component_Associations (N))\n            and then not Is_Limited_Composite (Typ)\n            and then not Is_Private_Composite (Typ)\n@@ -939,7 +944,7 @@ package body Sem_Aggr is\n \n                   Expr := First (Expressions (N));\n                   while Present (Expr) loop\n-                     Store_String_Char (Char_Literal_Value (Expr));\n+                     Store_String_Char (UI_To_CC (Char_Literal_Value (Expr)));\n                      Next (Expr);\n                   end loop;\n \n@@ -1672,7 +1677,9 @@ package body Sem_Aggr is\n \n                --  Ada 2005 (AI-231)\n \n-               Check_Can_Never_Be_Null (N, Expression (Assoc));\n+               if Ada_Version >= Ada_05 then\n+                  Check_Can_Never_Be_Null (Etype (N), Expression (Assoc));\n+               end if;\n \n                --  Ada 2005 (AI-287): In case of default initialized component\n                --  we delay the resolution to the expansion phase\n@@ -1798,7 +1805,11 @@ package body Sem_Aggr is\n          while Present (Expr) loop\n             Nb_Elements := Nb_Elements + 1;\n \n-            Check_Can_Never_Be_Null (N, Expr); -- Ada 2005 (AI-231)\n+            --  Ada 2005 (AI-231)\n+\n+            if Ada_Version >= Ada_05 then\n+               Check_Can_Never_Be_Null (Etype (N), Expr);\n+            end if;\n \n             if not Resolve_Aggr_Expr (Expr, Single_Elmt => True) then\n                return Failure;\n@@ -1810,8 +1821,12 @@ package body Sem_Aggr is\n          if Others_Present then\n             Assoc := Last (Component_Associations (N));\n \n-            Check_Can_Never_Be_Null\n-              (N, Expression (Assoc)); -- Ada 2005 (AI-231)\n+            --  Ada 2005 (AI-231)\n+\n+            if Ada_Version >= Ada_05 then\n+               Check_Can_Never_Be_Null\n+                 (Etype (N), Expression (Assoc));\n+            end if;\n \n             --  Ada 2005 (AI-287): In case of default initialized component\n             --  we delay the resolution to the expansion phase.\n@@ -2051,6 +2066,9 @@ package body Sem_Aggr is\n                --  less which ancestor). It is not possible to determine the\n                --  required components of the extension part.\n \n+               --  This check implements AI-306, which in fact was motivated\n+               --  by an ACT query to the ARG after this test was added.\n+\n                Error_Msg_N (\"ancestor part must be statically tagged\", A);\n             else\n                Resolve_Record_Aggregate (N, Typ);\n@@ -2358,13 +2376,9 @@ package body Sem_Aggr is\n                      --  Ada 2005 (AI-231)\n \n                      if Ada_Version >= Ada_05\n-                       and then Present (Expression (Assoc))\n                        and then Nkind (Expression (Assoc)) = N_Null\n-                       and then Can_Never_Be_Null (Compon)\n                      then\n-                        Error_Msg_N\n-                          (\"(Ada 2005) NULL not allowed in null-excluding \" &\n-                           \"components\", Expression (Assoc));\n+                        Check_Can_Never_Be_Null (Compon, Expression (Assoc));\n                      end if;\n \n                      --  We need to duplicate the expression when several\n@@ -2679,13 +2693,8 @@ package body Sem_Aggr is\n \n                --  Ada 2005 (AI-231)\n \n-               if Ada_Version >= Ada_05\n-                 and then Nkind (Positional_Expr) = N_Null\n-                 and then Can_Never_Be_Null (Discrim)\n-               then\n-                  Error_Msg_N\n-                    (\"(Ada 2005) NULL not allowed in null-excluding \" &\n-                     \"components\", Positional_Expr);\n+               if Ada_Version >= Ada_05 then\n+                  Check_Can_Never_Be_Null (Discrim, Positional_Expr);\n                end if;\n \n                Next (Positional_Expr);\n@@ -2921,13 +2930,8 @@ package body Sem_Aggr is\n \n          --  Ada 2005 (AI-231)\n \n-         if Ada_Version >= Ada_05\n-           and then Nkind (Positional_Expr) = N_Null\n-           and then Can_Never_Be_Null (Component)\n-         then\n-            Error_Msg_N\n-              (\"(Ada 2005) NULL not allowed in null-excluding components\",\n-               Positional_Expr);\n+         if Ada_Version >= Ada_05 then\n+            Check_Can_Never_Be_Null (Component, Positional_Expr);\n          end if;\n \n          if Present (Get_Value (Component, Component_Associations (N))) then\n@@ -3081,12 +3085,17 @@ package body Sem_Aggr is\n \n    procedure Check_Can_Never_Be_Null (N : Node_Id; Expr : Node_Id) is\n    begin\n-      if Ada_Version >= Ada_05\n-        and then Nkind (Expr) = N_Null\n-        and then Can_Never_Be_Null (Etype (N))\n+      pragma Assert (Ada_Version >= Ada_05);\n+\n+      if Nkind (Expr) = N_Null\n+        and then Can_Never_Be_Null (N)\n       then\n-         Error_Msg_N\n-           (\"(Ada 2005) NULL not allowed in null-excluding components\", Expr);\n+         Apply_Compile_Time_Constraint_Error\n+           (N      => Expr,\n+            Msg    => \"(Ada 2005) NULL not allowed in\"\n+                       & \" null-excluding components?\",\n+            Reason => CE_Null_Not_Allowed,\n+            Rep    => False);\n       end if;\n    end Check_Can_Never_Be_Null;\n "}, {"sha": "8780f6b08f8dafe44335be07b1eb76900e2a5fe5", "filename": "gcc/ada/sem_attr.adb", "status": "modified", "additions": 117, "deletions": 20, "changes": 137, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/82c80734715c801643075ab68c5c9a5e00da1b03/gcc%2Fada%2Fsem_attr.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/82c80734715c801643075ab68c5c9a5e00da1b03/gcc%2Fada%2Fsem_attr.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_attr.adb?ref=82c80734715c801643075ab68c5c9a5e00da1b03", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1992-2004, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2005, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -3458,6 +3458,22 @@ package body Sem_Attr is\n       when Attribute_Storage_Unit =>\n          Standard_Attribute (Ttypes.System_Storage_Unit);\n \n+      -----------------\n+      -- Stream_Size --\n+      -----------------\n+\n+      when Attribute_Stream_Size =>\n+         Check_E0;\n+         Check_Type;\n+\n+         if Is_Entity_Name (P)\n+           and then Is_Elementary_Type (Entity (P))\n+         then\n+            Set_Etype (N, Universal_Integer);\n+         else\n+            Error_Attr (\"invalid prefix for % attribute\", P);\n+         end if;\n+\n       ----------\n       -- Succ --\n       ----------\n@@ -3801,6 +3817,19 @@ package body Sem_Attr is\n          Validate_Non_Static_Attribute_Function_Call;\n       end Wide_Image;\n \n+      ---------------------\n+      -- Wide_Wide_Image --\n+      ---------------------\n+\n+      when Attribute_Wide_Wide_Image => Wide_Wide_Image :\n+      begin\n+         Check_Scalar_Type;\n+         Set_Etype (N, Standard_Wide_Wide_String);\n+         Check_E1;\n+         Resolve (E1, P_Base_Type);\n+         Validate_Non_Static_Attribute_Function_Call;\n+      end Wide_Wide_Image;\n+\n       ----------------\n       -- Wide_Value --\n       ----------------\n@@ -3817,6 +3846,31 @@ package body Sem_Attr is\n          Validate_Non_Static_Attribute_Function_Call;\n       end Wide_Value;\n \n+      ---------------------\n+      -- Wide_Wide_Value --\n+      ---------------------\n+\n+      when Attribute_Wide_Wide_Value => Wide_Wide_Value :\n+      begin\n+         Check_E1;\n+         Check_Scalar_Type;\n+\n+         --  Set Etype before resolving expression because expansion\n+         --  of expression may require enclosing type.\n+\n+         Set_Etype (N, P_Type);\n+         Validate_Non_Static_Attribute_Function_Call;\n+      end Wide_Wide_Value;\n+\n+      ---------------------\n+      -- Wide_Wide_Width --\n+      ---------------------\n+\n+      when Attribute_Wide_Wide_Width =>\n+         Check_E0;\n+         Check_Scalar_Type;\n+         Set_Etype (N, Universal_Integer);\n+\n       ----------------\n       -- Wide_Width --\n       ----------------\n@@ -4919,12 +4973,12 @@ package body Sem_Attr is\n \n       when Attribute_Enum_Rep =>\n \n-         --  For an enumeration type with a non-standard representation\n-         --  use the Enumeration_Rep field of the proper constant. Note\n-         --  that this would not work for types Character/Wide_Character,\n-         --  since no real entities are created for the enumeration\n-         --  literals, but that does not matter since these two types\n-         --  do not have non-standard representations anyway.\n+         --  For an enumeration type with a non-standard representation use\n+         --  the Enumeration_Rep field of the proper constant. Note that this\n+         --  will not work for types Character/Wide_[Wide-]Character, since no\n+         --  real entities are created for the enumeration literals, but that\n+         --  does not matter since these two types do not have non-standard\n+         --  representations anyway.\n \n          if Is_Enumeration_Type (P_Type)\n            and then Has_Non_Standard_Rep (P_Type)\n@@ -5653,11 +5707,23 @@ package body Sem_Attr is\n       -- Remainder --\n       ---------------\n \n-      when Attribute_Remainder =>\n-         Fold_Ureal (N,\n-           Eval_Fat.Remainder\n-             (P_Root_Type, Expr_Value_R (E1), Expr_Value_R (E2)),\n-           Static);\n+      when Attribute_Remainder => Remainder : declare\n+         X : constant Ureal := Expr_Value_R (E1);\n+         Y : constant Ureal := Expr_Value_R (E2);\n+\n+      begin\n+         if UR_Is_Zero (Y) then\n+            Apply_Compile_Time_Constraint_Error\n+              (N, \"division by zero in Remainder\",\n+               CE_Overflow_Check_Failed,\n+               Warn => not Static);\n+\n+            Check_Expressions;\n+            return;\n+         end if;\n+\n+         Fold_Ureal (N, Eval_Fat.Remainder (P_Root_Type, X, Y), Static);\n+      end Remainder;\n \n       -----------\n       -- Round --\n@@ -5832,7 +5898,7 @@ package body Sem_Attr is\n                   --  Size_Clause field for a subtype when Has_Size_Clause\n                   --  is False. Consider:\n \n-                  --    type x is range 1 .. 64;                         g\n+                  --    type x is range 1 .. 64;\n                   --    for x'size use 12;\n                   --    subtype y is x range 0 .. 3;\n \n@@ -5893,6 +5959,13 @@ package body Sem_Attr is\n             Fold_Ureal (N, Small_Value (P_Type), True);\n          end if;\n \n+      -----------------\n+      -- Stream_Size --\n+      -----------------\n+\n+      when Attribute_Stream_Size =>\n+         null;\n+\n       ----------\n       -- Succ --\n       ----------\n@@ -6100,6 +6173,22 @@ package body Sem_Attr is\n       when Attribute_Wide_Image =>\n          null;\n \n+      ---------------------\n+      -- Wide_Wide_Image --\n+      ---------------------\n+\n+      --  Wide_Wide_Image is a scalar attribute but is never static, because it\n+      --  is not a static function (having a non-scalar argument (RM 4.9(22)).\n+\n+      when Attribute_Wide_Wide_Image =>\n+         null;\n+\n+      ---------------------\n+      -- Wide_Wide_Width --\n+      ---------------------\n+\n+      --  Processing for Wide_Wide_Width is combined with Width\n+\n       ----------------\n       -- Wide_Width --\n       ----------------\n@@ -6110,9 +6199,11 @@ package body Sem_Attr is\n       -- Width --\n       -----------\n \n-      --  This processing also handles the case of Wide_Width\n+      --  This processing also handles the case of Wide_[Wide_]Width\n \n-      when Attribute_Width | Attribute_Wide_Width => Width :\n+      when Attribute_Width |\n+           Attribute_Wide_Width |\n+           Attribute_Wide_Wide_Width => Width :\n       begin\n          if Compile_Time_Known_Bounds (P_Type) then\n \n@@ -6193,10 +6284,11 @@ package body Sem_Attr is\n                      W := 0;\n \n                   --  Width for types derived from Standard.Character\n-                  --  and Standard.Wide_Character.\n+                  --  and Standard.Wide_[Wide_]Character.\n \n                   elsif R = Standard_Character\n-                    or else R = Standard_Wide_Character\n+                     or else R = Standard_Wide_Character\n+                     or else R = Standard_Wide_Wide_Character\n                   then\n                      W := 0;\n \n@@ -6207,6 +6299,8 @@ package body Sem_Attr is\n                         --  Assume all wide-character escape sequences are\n                         --  same length, so we can quit when we reach one.\n \n+                        --  Is this right for UTF-8?\n+\n                         if J > 255 then\n                            if Id = Attribute_Wide_Width then\n                               W := Int'Max (W, 3);\n@@ -6299,8 +6393,8 @@ package body Sem_Attr is\n                               Get_Decoded_Name_String (Chars (L));\n                               Wt := Nat (Name_Len);\n \n-                           --  For Wide_Width, use encoded name, and then\n-                           --  adjust for the encoding.\n+                           --  For Wide_[Wide_]Width, use encoded name, and\n+                           --  then adjust for the encoding.\n \n                            else\n                               Get_Name_String (Chars (L));\n@@ -6386,11 +6480,11 @@ package body Sem_Attr is\n            Attribute_Value                    |\n            Attribute_Wchar_T_Size             |\n            Attribute_Wide_Value               |\n+           Attribute_Wide_Wide_Value          |\n            Attribute_Word_Size                |\n            Attribute_Write                    =>\n \n          raise Program_Error;\n-\n       end case;\n \n       --  At the end of the case, one more check. If we did a static evaluation\n@@ -7348,6 +7442,9 @@ package body Sem_Attr is\n                when Attribute_Wide_Value =>\n                   Resolve (First (Expressions (N)), Standard_Wide_String);\n \n+               when Attribute_Wide_Wide_Value =>\n+                  Resolve (First (Expressions (N)), Standard_Wide_Wide_String);\n+\n                when others => null;\n             end case;\n       end case;"}, {"sha": "a113ac91e1960622524e347124a0dbe82d2c1d20", "filename": "gcc/ada/sem_case.adb", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/82c80734715c801643075ab68c5c9a5e00da1b03/gcc%2Fada%2Fsem_case.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/82c80734715c801643075ab68c5c9a5e00da1b03/gcc%2Fada%2Fsem_case.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_case.adb?ref=82c80734715c801643075ab68c5c9a5e00da1b03", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1996-2004 Free Software Foundation, Inc.          --\n+--          Copyright (C) 1996-2005 Free Software Foundation, Inc.          --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -267,11 +267,12 @@ package body Sem_Case is\n       C   : Int;\n \n    begin\n-      --  For character, or wide character. If we are in 7-bit ASCII graphic\n+      --  For character, or wide [wide] character. If 7-bit ASCII graphic\n       --  range, then build and return appropriate character literal name\n \n       if Rtp = Standard_Character\n         or else Rtp = Standard_Wide_Character\n+        or else Rtp = Standard_Wide_Wide_Character\n       then\n          C := UI_To_Int (Value);\n \n@@ -429,11 +430,13 @@ package body Sem_Case is\n          if Root_Type (Choice_Type) = Standard_Character\n               or else\n             Root_Type (Choice_Type) = Standard_Wide_Character\n+              or else\n+            Root_Type (Choice_Type) = Standard_Wide_Wide_Character\n          then\n             Set_Character_Literal_Name (Char_Code (UI_To_Int (Value)));\n             Lit := New_Node (N_Character_Literal, Loc);\n             Set_Chars (Lit, Name_Find);\n-            Set_Char_Literal_Value (Lit, Char_Code (UI_To_Int (Value)));\n+            Set_Char_Literal_Value (Lit, Value);\n             Set_Etype (Lit, Choice_Type);\n             Set_Is_Static_Expression (Lit, True);\n             return Lit;"}, {"sha": "a9700fb1dccf13d536371a4c1343b5fa05aadb5d", "filename": "gcc/ada/sem_ch10.adb", "status": "modified", "additions": 18, "deletions": 6, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/82c80734715c801643075ab68c5c9a5e00da1b03/gcc%2Fada%2Fsem_ch10.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/82c80734715c801643075ab68c5c9a5e00da1b03/gcc%2Fada%2Fsem_ch10.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch10.adb?ref=82c80734715c801643075ab68c5c9a5e00da1b03", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1992-2004 Free Software Foundation, Inc.          --\n+--          Copyright (C) 1992-2005 Free Software Foundation, Inc.          --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -1692,14 +1692,26 @@ package body Sem_Ch10 is\n \n          if Implementation_Unit_Warnings\n            and then Current_Sem_Unit = Main_Unit\n-           and then Implementation_Unit (Get_Source_Unit (U))\n            and then not Intunit\n            and then not Implicit_With (N)\n+           and then not GNAT_Mode\n          then\n-            Error_Msg_N (\"& is an internal 'G'N'A'T unit?\", Name (N));\n-            Error_Msg_N\n-              (\"\\use of this unit is non-portable and version-dependent?\",\n-               Name (N));\n+            declare\n+               U_Kind : constant Kind_Of_Unit :=\n+                          Get_Kind_Of_Unit (Get_Source_Unit (U));\n+\n+            begin\n+               if U_Kind = Implementation_Unit then\n+                  Error_Msg_N (\"& is an internal 'G'N'A'T unit?\", Name (N));\n+                  Error_Msg_N\n+                    (\"\\use of this unit is non-portable \" &\n+                     \"and version-dependent?\",\n+                     Name (N));\n+\n+               elsif U_Kind = Ada_05_Unit and then Ada_Version = Ada_95 then\n+                  Error_Msg_N (\"& is an Ada 2005 unit?\", Name (N));\n+               end if;\n+            end;\n          end if;\n       end if;\n "}, {"sha": "04e2f8d567b349e556473294efda2aafa4edaca8", "filename": "gcc/ada/sem_ch12.adb", "status": "modified", "additions": 67, "deletions": 24, "changes": 91, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/82c80734715c801643075ab68c5c9a5e00da1b03/gcc%2Fada%2Fsem_ch12.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/82c80734715c801643075ab68c5c9a5e00da1b03/gcc%2Fada%2Fsem_ch12.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch12.adb?ref=82c80734715c801643075ab68c5c9a5e00da1b03", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1992-2004, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2005, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -51,6 +51,7 @@ with Sem_Ch7;  use Sem_Ch7;\n with Sem_Ch8;  use Sem_Ch8;\n with Sem_Ch10; use Sem_Ch10;\n with Sem_Ch13; use Sem_Ch13;\n+with Sem_Disp; use Sem_Disp;\n with Sem_Elab; use Sem_Elab;\n with Sem_Elim; use Sem_Elim;\n with Sem_Eval; use Sem_Eval;\n@@ -261,7 +262,11 @@ package body Sem_Ch12 is\n       T   : Entity_Id;\n       Def : Node_Id);\n \n-   --  All the following need comments???\n+   --  The following subprograms create abbreviated declarations for formal\n+   --  scalar types. We introduce an anonymous base of the proper class for\n+   --  each of them, and define the formals as constrained first subtypes of\n+   --  their bases. The bounds are expressions that are non-static in the\n+   --  generic.\n \n    procedure Analyze_Formal_Decimal_Fixed_Point_Type\n                                                 (T : Entity_Id; Def : Node_Id);\n@@ -879,7 +884,7 @@ package body Sem_Ch12 is\n             case Nkind (Formal) is\n \n                when N_Formal_Subprogram_Declaration =>\n-                  exit when Kind = N_Formal_Subprogram_Declaration\n+                  exit when Kind in N_Formal_Subprogram_Declaration\n                     and then\n                       Chars\n                         (Defining_Unit_Name (Specification (Formal))) =\n@@ -900,7 +905,7 @@ package body Sem_Ch12 is\n                   --  unrecognized pragmas.\n \n                   exit when\n-                    Kind /= N_Formal_Subprogram_Declaration\n+                    Kind not in N_Formal_Subprogram_Declaration\n                       and then Kind /= N_Subprogram_Declaration\n                       and then Kind /= N_Freeze_Entity\n                       and then Kind /= N_Null_Statement\n@@ -1038,7 +1043,7 @@ package body Sem_Ch12 is\n                   then\n                      Temp_Formal := First (Formals);\n                      while Present (Temp_Formal) loop\n-                        if Nkind (Temp_Formal) =\n+                        if Nkind (Temp_Formal) in\n                              N_Formal_Subprogram_Declaration\n                           and then Temp_Formal /= Formal\n                           and then\n@@ -1279,6 +1284,7 @@ package body Sem_Ch12 is\n       Set_Delta_Value    (T, Delta_Val);\n       Set_Small_Value    (T, Delta_Val);\n       Set_Scalar_Range   (T, Scalar_Range (Base));\n+      Set_Is_Constrained (T);\n \n       Check_Restriction (No_Fixed_Point, Def);\n    end Analyze_Formal_Decimal_Fixed_Point_Type;\n@@ -1357,12 +1363,17 @@ package body Sem_Ch12 is\n       Lo  : Node_Id;\n       Hi  : Node_Id;\n \n+      Base : constant Entity_Id :=\n+               New_Internal_Entity\n+                 (E_Floating_Point_Type, Current_Scope, Sloc (Def), 'G');\n    begin\n-      Enter_Name     (T);\n-      Set_Ekind      (T, E_Enumeration_Type);\n-      Set_Etype      (T, T);\n-      Init_Size      (T, 8);\n-      Init_Alignment (T);\n+      Enter_Name          (T);\n+      Set_Ekind           (T, E_Enumeration_Subtype);\n+      Set_Etype           (T, Base);\n+      Init_Size           (T, 8);\n+      Init_Alignment      (T);\n+      Set_Is_Generic_Type (T);\n+      Set_Is_Constrained  (T);\n \n       --  For semantic analysis, the bounds of the type must be set to some\n       --  non-static value. The simplest is to create attribute nodes for\n@@ -1386,6 +1397,14 @@ package body Sem_Ch12 is\n           Low_Bound => Lo,\n           High_Bound => Hi));\n \n+      Set_Ekind           (Base, E_Enumeration_Type);\n+      Set_Etype           (Base, Base);\n+      Init_Size           (Base, 8);\n+      Init_Alignment      (Base);\n+      Set_Is_Generic_Type (Base);\n+      Set_Scalar_Range    (Base, Scalar_Range (T));\n+      Set_Parent          (Base, Parent (Def));\n+\n    end Analyze_Formal_Discrete_Type;\n \n    ----------------------------------\n@@ -1404,12 +1423,13 @@ package body Sem_Ch12 is\n       --  the generic itself.\n \n       Enter_Name (T);\n-      Set_Ekind        (T, E_Floating_Point_Subtype);\n-      Set_Etype        (T, Base);\n-      Set_Size_Info    (T,              (Standard_Float));\n-      Set_RM_Size      (T, RM_Size      (Standard_Float));\n-      Set_Digits_Value (T, Digits_Value (Standard_Float));\n-      Set_Scalar_Range (T, Scalar_Range (Standard_Float));\n+      Set_Ekind          (T, E_Floating_Point_Subtype);\n+      Set_Etype          (T, Base);\n+      Set_Size_Info      (T,              (Standard_Float));\n+      Set_RM_Size        (T, RM_Size      (Standard_Float));\n+      Set_Digits_Value   (T, Digits_Value (Standard_Float));\n+      Set_Scalar_Range   (T, Scalar_Range (Standard_Float));\n+      Set_Is_Constrained (T);\n \n       Set_Is_Generic_Type (Base);\n       Set_Etype           (Base, Base);\n@@ -1562,6 +1582,7 @@ package body Sem_Ch12 is\n         Make_Range (Loc,\n           Low_Bound  => Make_Real_Literal (Loc, Ureal_1),\n           High_Bound => Make_Real_Literal (Loc, Ureal_1)));\n+      Set_Is_Constrained   (T);\n \n       Set_Is_Generic_Type (Base);\n       Set_Etype           (Base, Base);\n@@ -1773,11 +1794,12 @@ package body Sem_Ch12 is\n    begin\n       Enter_Name (T);\n \n-      Set_Ekind        (T, E_Signed_Integer_Subtype);\n-      Set_Etype        (T, Base);\n-      Set_Size_Info    (T, Standard_Integer);\n-      Set_RM_Size      (T, RM_Size (Standard_Integer));\n-      Set_Scalar_Range (T, Scalar_Range (Standard_Integer));\n+      Set_Ekind          (T, E_Signed_Integer_Subtype);\n+      Set_Etype          (T, Base);\n+      Set_Size_Info      (T, Standard_Integer);\n+      Set_RM_Size        (T, RM_Size (Standard_Integer));\n+      Set_Scalar_Range   (T, Scalar_Range (Standard_Integer));\n+      Set_Is_Constrained (T);\n \n       Set_Is_Generic_Type (Base);\n       Set_Size_Info       (Base, Standard_Integer);\n@@ -1811,6 +1833,25 @@ package body Sem_Ch12 is\n       Set_Is_Formal_Subprogram (Nam);\n       Set_Has_Completion (Nam);\n \n+      if Nkind (N) = N_Formal_Abstract_Subprogram_Declaration then\n+         Set_Is_Abstract (Nam);\n+         Set_Is_Dispatching_Operation (Nam);\n+\n+         declare\n+            Ctrl_Type : constant Entity_Id := Find_Dispatching_Type (Nam);\n+\n+         begin\n+            if not Present (Ctrl_Type) then\n+               Error_Msg_N\n+                 (\"abstract formal subprogram must have a controlling type\",\n+                  N);\n+\n+            else\n+               Check_Controlling_Formals (Ctrl_Type, Nam);\n+            end if;\n+         end;\n+      end if;\n+\n       --  Default name is resolved at the point of instantiation\n \n       if Box_Present (N) then\n@@ -6966,10 +7007,12 @@ package body Sem_Ch12 is\n \n       --  The generic instantiation freezes the actual. This can only be\n       --  done once the actual is resolved, in the analysis of the renaming\n-      --  declaration. To indicate that must be done, we set the corresponding\n-      --  spec of the node to point to the formal subprogram entity.\n+      --  declaration. To make the formal subprogram entity available, we set\n+      --  Corresponding_Formal_Spec to point to the formal subprogram entity.\n+      --  This is also needed in Analyze_Subprogram_Renaming for the processing\n+      --  of formal abstract subprograms.\n \n-      Set_Corresponding_Spec (Decl_Node, Analyzed_S);\n+      Set_Corresponding_Formal_Spec (Decl_Node, Analyzed_S);\n \n       --  We cannot analyze the renaming declaration, and thus find the\n       --  actual, until the all the actuals are assembled in the instance."}, {"sha": "dbd1c7eef067fe27ab5fea17600697837b776265", "filename": "gcc/ada/sem_ch13.adb", "status": "modified", "additions": 43, "deletions": 5, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/82c80734715c801643075ab68c5c9a5e00da1b03/gcc%2Fada%2Fsem_ch13.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/82c80734715c801643075ab68c5c9a5e00da1b03/gcc%2Fada%2Fsem_ch13.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch13.adb?ref=82c80734715c801643075ab68c5c9a5e00da1b03", "patch": "@@ -1,12 +1,12 @@\n ------------------------------------------------------------------------------\n---                   c                                                       --\n+--                                                                          --\n --                         GNAT COMPILER COMPONENTS                         --\n --                                                                          --\n --                             S E M _ C H 1 3                              --\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1992-2004, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2005, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -301,7 +301,6 @@ package body Sem_Ch13 is\n       then\n          Error_Msg_N (\"cannot specify attribute for subtype\", Nam);\n          return;\n-\n       end if;\n \n       --  Switch on particular attribute\n@@ -1364,6 +1363,45 @@ package body Sem_Ch13 is\n             end if;\n          end Storage_Pool;\n \n+         -----------------\n+         -- Stream_Size --\n+         -----------------\n+\n+         when Attribute_Stream_Size => Stream_Size : declare\n+            Size : constant Uint := Static_Integer (Expr);\n+\n+         begin\n+            if Has_Stream_Size_Clause (U_Ent) then\n+               Error_Msg_N (\"Stream_Size already given for &\", Nam);\n+\n+            elsif Is_Elementary_Type (U_Ent) then\n+               if Size /= System_Storage_Unit\n+                    and then\n+                  Size /= System_Storage_Unit * 2\n+                    and then\n+                  Size /= System_Storage_Unit * 4\n+                     and then\n+                  Size /= System_Storage_Unit * 8\n+               then\n+                  Error_Msg_Uint_1 := UI_From_Int (System_Storage_Unit);\n+                  Error_Msg_N\n+                    (\"stream size for elementary type must be a\"\n+                       & \" power of 2 and at least ^\", N);\n+\n+               elsif RM_Size (U_Ent) > Size then\n+                  Error_Msg_Uint_1 := RM_Size (U_Ent);\n+                  Error_Msg_N\n+                    (\"stream size for elementary type must be a\"\n+                       & \" power of 2 and at least ^\", N);\n+               end if;\n+\n+               Set_Has_Stream_Size_Clause (U_Ent);\n+\n+            else\n+               Error_Msg_N (\"Stream_Size cannot be given for &\", Nam);\n+            end if;\n+         end Stream_Size;\n+\n          ----------------\n          -- Value_Size --\n          ----------------\n@@ -1499,7 +1537,6 @@ package body Sem_Ch13 is\n          when others =>\n             Error_Msg_N\n               (\"attribute& cannot be set with definition clause\", N);\n-\n       end case;\n \n       --  The test for the type being frozen must be performed after\n@@ -1669,10 +1706,11 @@ package body Sem_Ch13 is\n          Error_Msg_N (\"duplicate enumeration rep clause ignored\", N);\n          return;\n \n-      --  Don't allow rep clause if root type is standard [wide_]character\n+      --  Don't allow rep clause for standard [wide_[wide_]]character\n \n       elsif Root_Type (Enumtype) = Standard_Character\n         or else Root_Type (Enumtype) = Standard_Wide_Character\n+        or else Root_Type (Enumtype) = Standard_Wide_Wide_Character\n       then\n          Error_Msg_N (\"enumeration rep clause not allowed for this type\", N);\n          return;"}, {"sha": "091d087c831cab2bd0d14a360c8b96f6d5d84e76", "filename": "gcc/ada/sem_ch2.adb", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/82c80734715c801643075ab68c5c9a5e00da1b03/gcc%2Fada%2Fsem_ch2.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/82c80734715c801643075ab68c5c9a5e00da1b03/gcc%2Fada%2Fsem_ch2.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch2.adb?ref=82c80734715c801643075ab68c5c9a5e00da1b03", "patch": "@@ -32,6 +32,7 @@ with Rident;   use Rident;\n with Sem_Ch8;  use Sem_Ch8;\n with Sinfo;    use Sinfo;\n with Stand;    use Stand;\n+with Uintp;    use Uintp;\n \n package body Sem_Ch2 is\n \n@@ -51,7 +52,7 @@ package body Sem_Ch2 is\n       Set_Is_Static_Expression (N);\n \n       if Comes_From_Source (N)\n-        and then not In_Character_Range (Char_Literal_Value (N))\n+        and then not In_Character_Range (UI_To_CC (Char_Literal_Value (N)))\n       then\n          Check_Restriction (No_Wide_Characters, N);\n       end if;"}, {"sha": "7ac6e268b2d9e7e2d0376d592d0f0ec565752393", "filename": "gcc/ada/sem_ch3.adb", "status": "modified", "additions": 18, "deletions": 6, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/82c80734715c801643075ab68c5c9a5e00da1b03/gcc%2Fada%2Fsem_ch3.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/82c80734715c801643075ab68c5c9a5e00da1b03/gcc%2Fada%2Fsem_ch3.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch3.adb?ref=82c80734715c801643075ab68c5c9a5e00da1b03", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1992-2004, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2005, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -1970,8 +1970,9 @@ package body Sem_Ch3 is\n          Remove_Side_Effects (E);\n       end if;\n \n-      if T = Standard_Wide_Character\n+      if T = Standard_Wide_Character or else T = Standard_Wide_Wide_Character\n         or else Root_Type (T) = Standard_Wide_String\n+        or else Root_Type (T) = Standard_Wide_Wide_String\n       then\n          Check_Restriction (No_Wide_Characters, Object_Definition (N));\n       end if;\n@@ -3705,6 +3706,7 @@ package body Sem_Ch3 is\n \n       if Root_Type (Parent_Type) = Standard_Character\n         or else Root_Type (Parent_Type) = Standard_Wide_Character\n+        or else Root_Type (Parent_Type) = Standard_Wide_Wide_Character\n       then\n          Derived_Standard_Character (N, Parent_Type, Derived_Type);\n \n@@ -4122,10 +4124,12 @@ package body Sem_Ch3 is\n \n       begin\n          if Ekind (Parent_Type) in Record_Kind\n-           or else (Ekind (Parent_Type) in Enumeration_Kind\n-             and then Root_Type (Parent_Type) /= Standard_Character\n-             and then Root_Type (Parent_Type) /= Standard_Wide_Character\n-             and then not Is_Generic_Type (Root_Type (Parent_Type)))\n+           or else\n+             (Ekind (Parent_Type) in Enumeration_Kind\n+               and then Root_Type (Parent_Type) /= Standard_Character\n+               and then Root_Type (Parent_Type) /= Standard_Wide_Character\n+               and then Root_Type (Parent_Type) /= Standard_Wide_Wide_Character\n+               and then not Is_Generic_Type (Root_Type (Parent_Type)))\n          then\n             Full_N := New_Copy_Tree (N);\n             Insert_After (N, Full_N);\n@@ -10192,7 +10196,9 @@ package body Sem_Ch3 is\n       end if;\n \n       if Typ = Standard_Wide_Character\n+        or else Typ = Standard_Wide_Wide_Character\n         or else Typ = Standard_Wide_String\n+        or else Typ = Standard_Wide_Wide_String\n       then\n          Check_Restriction (No_Wide_Characters, S);\n       end if;\n@@ -12707,6 +12713,12 @@ package body Sem_Ch3 is\n \n             Rewrite (S, New_Copy_Tree (Subtype_Mark (S)));\n \n+            --  Set Ekind of orphan itype, to prevent cascaded errors.\n+\n+            if Present (Def_Id) then\n+               Set_Ekind (Def_Id, Ekind (Any_Type));\n+            end if;\n+\n             --  Make recursive call, having got rid of the bogus constraint\n \n             return Process_Subtype (S, Related_Nod, Related_Id, Suffix);"}, {"sha": "3f16dca9396a20a91364f70e33a57b1fa238990d", "filename": "gcc/ada/sem_ch5.adb", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/82c80734715c801643075ab68c5c9a5e00da1b03/gcc%2Fada%2Fsem_ch5.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/82c80734715c801643075ab68c5c9a5e00da1b03/gcc%2Fada%2Fsem_ch5.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch5.adb?ref=82c80734715c801643075ab68c5c9a5e00da1b03", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1992-2004 Free Software Foundation, Inc.          --\n+--          Copyright (C) 1992-2005 Free Software Foundation, Inc.          --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -410,8 +410,10 @@ package body Sem_Ch5 is\n                      and then Can_Never_Be_Null (Entity (Lhs)))\n                    or else Can_Never_Be_Null (Etype (Lhs)))\n       then\n-         Error_Msg_N\n-           (\"(Ada 2005) NULL not allowed in null-excluding objects\", Lhs);\n+         Apply_Compile_Time_Constraint_Error\n+           (N      => Lhs,\n+            Msg    => \"(Ada 2005) NULL not allowed in null-excluding objects?\",\n+            Reason => CE_Null_Not_Allowed);\n       end if;\n \n       if Is_Scalar_Type (T1) then"}, {"sha": "45a2015850746c3b423f3c933106ba0dcd908899", "filename": "gcc/ada/sem_ch6.adb", "status": "modified", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/82c80734715c801643075ab68c5c9a5e00da1b03/gcc%2Fada%2Fsem_ch6.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/82c80734715c801643075ab68c5c9a5e00da1b03/gcc%2Fada%2Fsem_ch6.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch6.adb?ref=82c80734715c801643075ab68c5c9a5e00da1b03"}, {"sha": "f5090e444417776b7499d6098c0b56bde0b362aa", "filename": "gcc/ada/sem_ch8.adb", "status": "modified", "additions": 61, "deletions": 11, "changes": 72, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/82c80734715c801643075ab68c5c9a5e00da1b03/gcc%2Fada%2Fsem_ch8.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/82c80734715c801643075ab68c5c9a5e00da1b03/gcc%2Fada%2Fsem_ch8.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch8.adb?ref=82c80734715c801643075ab68c5c9a5e00da1b03"}, {"sha": "9f8521bb427b5d145477c1a77206fbdf0b2eb016", "filename": "gcc/ada/sem_disp.adb", "status": "modified", "additions": 97, "deletions": 26, "changes": 123, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/82c80734715c801643075ab68c5c9a5e00da1b03/gcc%2Fada%2Fsem_disp.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/82c80734715c801643075ab68c5c9a5e00da1b03/gcc%2Fada%2Fsem_disp.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_disp.adb?ref=82c80734715c801643075ab68c5c9a5e00da1b03"}, {"sha": "d0d536d68b6a96706a3b9561fd17707787de3f80", "filename": "gcc/ada/sem_eval.adb", "status": "modified", "additions": 46, "deletions": 17, "changes": 63, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/82c80734715c801643075ab68c5c9a5e00da1b03/gcc%2Fada%2Fsem_eval.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/82c80734715c801643075ab68c5c9a5e00da1b03/gcc%2Fada%2Fsem_eval.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_eval.adb?ref=82c80734715c801643075ab68c5c9a5e00da1b03"}, {"sha": "408024b3715df940f31b416c335327c3008f2c9f", "filename": "gcc/ada/sem_prag.adb", "status": "modified", "additions": 92, "deletions": 20, "changes": 112, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/82c80734715c801643075ab68c5c9a5e00da1b03/gcc%2Fada%2Fsem_prag.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/82c80734715c801643075ab68c5c9a5e00da1b03/gcc%2Fada%2Fsem_prag.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_prag.adb?ref=82c80734715c801643075ab68c5c9a5e00da1b03"}, {"sha": "af752663422a7073cd2aaed3bd705c44696e2f77", "filename": "gcc/ada/sem_res.adb", "status": "modified", "additions": 131, "deletions": 52, "changes": 183, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/82c80734715c801643075ab68c5c9a5e00da1b03/gcc%2Fada%2Fsem_res.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/82c80734715c801643075ab68c5c9a5e00da1b03/gcc%2Fada%2Fsem_res.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_res.adb?ref=82c80734715c801643075ab68c5c9a5e00da1b03"}, {"sha": "5993fbb371c5d65e7c424a29a1717bfaf58c0b96", "filename": "gcc/ada/sem_util.adb", "status": "modified", "additions": 25, "deletions": 14, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/82c80734715c801643075ab68c5c9a5e00da1b03/gcc%2Fada%2Fsem_util.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/82c80734715c801643075ab68c5c9a5e00da1b03/gcc%2Fada%2Fsem_util.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_util.adb?ref=82c80734715c801643075ab68c5c9a5e00da1b03"}, {"sha": "33f330143e548d1fa96663b9dc57477d7b9e59cf", "filename": "gcc/ada/sinfo.adb", "status": "modified", "additions": 30, "deletions": 13, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/82c80734715c801643075ab68c5c9a5e00da1b03/gcc%2Fada%2Fsinfo.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/82c80734715c801643075ab68c5c9a5e00da1b03/gcc%2Fada%2Fsinfo.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsinfo.adb?ref=82c80734715c801643075ab68c5c9a5e00da1b03"}, {"sha": "bfbbdf838e2d3a275fe30cef07965f2dd1489cea", "filename": "gcc/ada/sinfo.ads", "status": "modified", "additions": 62, "deletions": 8, "changes": 70, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/82c80734715c801643075ab68c5c9a5e00da1b03/gcc%2Fada%2Fsinfo.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/82c80734715c801643075ab68c5c9a5e00da1b03/gcc%2Fada%2Fsinfo.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsinfo.ads?ref=82c80734715c801643075ab68c5c9a5e00da1b03"}, {"sha": "6eabba27599ee6867e04a1227a698df248b60f87", "filename": "gcc/ada/sinput.adb", "status": "modified", "additions": 19, "deletions": 35, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/82c80734715c801643075ab68c5c9a5e00da1b03/gcc%2Fada%2Fsinput.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/82c80734715c801643075ab68c5c9a5e00da1b03/gcc%2Fada%2Fsinput.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsinput.adb?ref=82c80734715c801643075ab68c5c9a5e00da1b03"}, {"sha": "b47b4dc2f89230d7647cb25f401de8725db33ca8", "filename": "gcc/ada/sinput.ads", "status": "modified", "additions": 51, "deletions": 14, "changes": 65, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/82c80734715c801643075ab68c5c9a5e00da1b03/gcc%2Fada%2Fsinput.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/82c80734715c801643075ab68c5c9a5e00da1b03/gcc%2Fada%2Fsinput.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsinput.ads?ref=82c80734715c801643075ab68c5c9a5e00da1b03"}, {"sha": "c80da272b766af751fb9fb67b85e4c95fd476624", "filename": "gcc/ada/snames.adb", "status": "modified", "additions": 1049, "deletions": 1042, "changes": 2091, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/82c80734715c801643075ab68c5c9a5e00da1b03/gcc%2Fada%2Fsnames.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/82c80734715c801643075ab68c5c9a5e00da1b03/gcc%2Fada%2Fsnames.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsnames.adb?ref=82c80734715c801643075ab68c5c9a5e00da1b03"}, {"sha": "85c2f467cf03fedf362f5c4c24b2489e70d2c33d", "filename": "gcc/ada/snames.ads", "status": "modified", "additions": 1496, "deletions": 1485, "changes": 2981, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/82c80734715c801643075ab68c5c9a5e00da1b03/gcc%2Fada%2Fsnames.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/82c80734715c801643075ab68c5c9a5e00da1b03/gcc%2Fada%2Fsnames.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsnames.ads?ref=82c80734715c801643075ab68c5c9a5e00da1b03"}, {"sha": "e7ecb5d8d357c5b1be35b90991f3978e60b61294", "filename": "gcc/ada/snames.h", "status": "modified", "additions": 108, "deletions": 105, "changes": 213, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/82c80734715c801643075ab68c5c9a5e00da1b03/gcc%2Fada%2Fsnames.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/82c80734715c801643075ab68c5c9a5e00da1b03/gcc%2Fada%2Fsnames.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsnames.h?ref=82c80734715c801643075ab68c5c9a5e00da1b03"}, {"sha": "249986007275a9e7d60bcb8ab2693246b6ec59a2", "filename": "gcc/ada/sprint.adb", "status": "modified", "additions": 30, "deletions": 15, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/82c80734715c801643075ab68c5c9a5e00da1b03/gcc%2Fada%2Fsprint.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/82c80734715c801643075ab68c5c9a5e00da1b03/gcc%2Fada%2Fsprint.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsprint.adb?ref=82c80734715c801643075ab68c5c9a5e00da1b03"}, {"sha": "9c7d6e82d45c89128499c44cedbfb3e6913b15ff", "filename": "gcc/ada/stand.ads", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/82c80734715c801643075ab68c5c9a5e00da1b03/gcc%2Fada%2Fstand.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/82c80734715c801643075ab68c5c9a5e00da1b03/gcc%2Fada%2Fstand.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fstand.ads?ref=82c80734715c801643075ab68c5c9a5e00da1b03"}, {"sha": "5727080ceafcabd71bc4afe6f923d9f66367f840", "filename": "gcc/ada/stringt.adb", "status": "modified", "additions": 18, "deletions": 10, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/82c80734715c801643075ab68c5c9a5e00da1b03/gcc%2Fada%2Fstringt.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/82c80734715c801643075ab68c5c9a5e00da1b03/gcc%2Fada%2Fstringt.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fstringt.adb?ref=82c80734715c801643075ab68c5c9a5e00da1b03"}, {"sha": "d6ab38935798cb34f8b62a58ca200a54d576a759", "filename": "gcc/ada/stringt.ads", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/82c80734715c801643075ab68c5c9a5e00da1b03/gcc%2Fada%2Fstringt.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/82c80734715c801643075ab68c5c9a5e00da1b03/gcc%2Fada%2Fstringt.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fstringt.ads?ref=82c80734715c801643075ab68c5c9a5e00da1b03"}, {"sha": "5c2f525d924293da24e3f30eac218d864c6fcd3b", "filename": "gcc/ada/switch-b.adb", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/82c80734715c801643075ab68c5c9a5e00da1b03/gcc%2Fada%2Fswitch-b.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/82c80734715c801643075ab68c5c9a5e00da1b03/gcc%2Fada%2Fswitch-b.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fswitch-b.adb?ref=82c80734715c801643075ab68c5c9a5e00da1b03"}, {"sha": "7446359e90ecb7e14ddc9bc52a77f86b284f9743", "filename": "gcc/ada/trans.c", "status": "modified", "additions": 12, "deletions": 10, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/82c80734715c801643075ab68c5c9a5e00da1b03/gcc%2Fada%2Ftrans.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/82c80734715c801643075ab68c5c9a5e00da1b03/gcc%2Fada%2Ftrans.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Ftrans.c?ref=82c80734715c801643075ab68c5c9a5e00da1b03"}, {"sha": "3ed7fcc4351feb09d05f0f01b648739bf9b498b6", "filename": "gcc/ada/treepr.adb", "status": "modified", "additions": 1, "deletions": 14, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/82c80734715c801643075ab68c5c9a5e00da1b03/gcc%2Fada%2Ftreepr.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/82c80734715c801643075ab68c5c9a5e00da1b03/gcc%2Fada%2Ftreepr.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Ftreepr.adb?ref=82c80734715c801643075ab68c5c9a5e00da1b03"}, {"sha": "1be5673829022aacf36a00682ffe56a8a4a7ac62", "filename": "gcc/ada/ttypes.ads", "status": "modified", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/82c80734715c801643075ab68c5c9a5e00da1b03/gcc%2Fada%2Fttypes.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/82c80734715c801643075ab68c5c9a5e00da1b03/gcc%2Fada%2Fttypes.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fttypes.ads?ref=82c80734715c801643075ab68c5c9a5e00da1b03"}, {"sha": "9334c311a65bd25be6352d2ee3252b61a638c098", "filename": "gcc/ada/types.adb", "status": "modified", "additions": 20, "deletions": 1, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/82c80734715c801643075ab68c5c9a5e00da1b03/gcc%2Fada%2Ftypes.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/82c80734715c801643075ab68c5c9a5e00da1b03/gcc%2Fada%2Ftypes.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Ftypes.adb?ref=82c80734715c801643075ab68c5c9a5e00da1b03"}, {"sha": "3d649baa8ae7d7dd3be4da52f36be47ede359990", "filename": "gcc/ada/types.ads", "status": "modified", "additions": 29, "deletions": 19, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/82c80734715c801643075ab68c5c9a5e00da1b03/gcc%2Fada%2Ftypes.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/82c80734715c801643075ab68c5c9a5e00da1b03/gcc%2Fada%2Ftypes.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Ftypes.ads?ref=82c80734715c801643075ab68c5c9a5e00da1b03"}, {"sha": "04d4a7e24d9db490986a93714792853b0419a5fb", "filename": "gcc/ada/types.h", "status": "modified", "additions": 28, "deletions": 30, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/82c80734715c801643075ab68c5c9a5e00da1b03/gcc%2Fada%2Ftypes.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/82c80734715c801643075ab68c5c9a5e00da1b03/gcc%2Fada%2Ftypes.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Ftypes.h?ref=82c80734715c801643075ab68c5c9a5e00da1b03"}, {"sha": "10b2b1367d9ed8abfaad5b55e66220ee61e296b1", "filename": "gcc/ada/uintp.adb", "status": "modified", "additions": 43, "deletions": 1, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/82c80734715c801643075ab68c5c9a5e00da1b03/gcc%2Fada%2Fuintp.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/82c80734715c801643075ab68c5c9a5e00da1b03/gcc%2Fada%2Fuintp.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fuintp.adb?ref=82c80734715c801643075ab68c5c9a5e00da1b03"}, {"sha": "97206ade7d7b97b7e1b5011858f35e4f6fd4db93", "filename": "gcc/ada/uintp.ads", "status": "modified", "additions": 12, "deletions": 5, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/82c80734715c801643075ab68c5c9a5e00da1b03/gcc%2Fada%2Fuintp.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/82c80734715c801643075ab68c5c9a5e00da1b03/gcc%2Fada%2Fuintp.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fuintp.ads?ref=82c80734715c801643075ab68c5c9a5e00da1b03"}, {"sha": "b055a9ed0126b33e9eda27b32520e5bdf4762aab", "filename": "gcc/ada/uintp.h", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/82c80734715c801643075ab68c5c9a5e00da1b03/gcc%2Fada%2Fuintp.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/82c80734715c801643075ab68c5c9a5e00da1b03/gcc%2Fada%2Fuintp.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fuintp.h?ref=82c80734715c801643075ab68c5c9a5e00da1b03"}, {"sha": "2b028bbe2a5e116b0529bb8a3aa8bffb0db8b2b5", "filename": "gcc/ada/vms_data.ads", "status": "modified", "additions": 31, "deletions": 9, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/82c80734715c801643075ab68c5c9a5e00da1b03/gcc%2Fada%2Fvms_data.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/82c80734715c801643075ab68c5c9a5e00da1b03/gcc%2Fada%2Fvms_data.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fvms_data.ads?ref=82c80734715c801643075ab68c5c9a5e00da1b03"}, {"sha": "72cfb4ab63b2c18b96e30b18a082befdeda6055f", "filename": "gcc/ada/widechar.adb", "status": "modified", "additions": 1643, "deletions": 11, "changes": 1654, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/82c80734715c801643075ab68c5c9a5e00da1b03/gcc%2Fada%2Fwidechar.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/82c80734715c801643075ab68c5c9a5e00da1b03/gcc%2Fada%2Fwidechar.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fwidechar.adb?ref=82c80734715c801643075ab68c5c9a5e00da1b03"}, {"sha": "f70fb72d68066d654793fe997f1a98baf332d86a", "filename": "gcc/ada/widechar.ads", "status": "modified", "additions": 88, "deletions": 6, "changes": 94, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/82c80734715c801643075ab68c5c9a5e00da1b03/gcc%2Fada%2Fwidechar.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/82c80734715c801643075ab68c5c9a5e00da1b03/gcc%2Fada%2Fwidechar.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fwidechar.ads?ref=82c80734715c801643075ab68c5c9a5e00da1b03"}]}