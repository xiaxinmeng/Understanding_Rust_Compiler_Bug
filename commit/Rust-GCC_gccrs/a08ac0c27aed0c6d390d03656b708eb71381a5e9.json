{"sha": "a08ac0c27aed0c6d390d03656b708eb71381a5e9", "node_id": "C_kwDOANBUbNoAKGEwOGFjMGMyN2FlZDBjNmQzOTBkMDM2NTZiNzA4ZWI3MTM4MWE1ZTk", "commit": {"author": {"name": "Philip Herron", "email": "philip.herron@embecosm.com", "date": "2022-03-09T14:37:47Z"}, "committer": {"name": "Philip Herron", "email": "philip.herron@embecosm.com", "date": "2022-03-10T11:40:02Z"}, "message": "Add support for the rust offset intrinsic\n\nThis patch adds the initial support for generic intrinsics these are do not\nmap directly to GCC builtins and need to be substited with their specificed\ntypes. This patch allows for custom implementation body for these functions\nby specifying handler functions which will generate the applicable\nintrinsic when asked for.\n\nAddresses #658", "tree": {"sha": "2de46126aaff38e8ef503952f299f164d6788f75", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/2de46126aaff38e8ef503952f299f164d6788f75"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a08ac0c27aed0c6d390d03656b708eb71381a5e9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a08ac0c27aed0c6d390d03656b708eb71381a5e9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a08ac0c27aed0c6d390d03656b708eb71381a5e9", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a08ac0c27aed0c6d390d03656b708eb71381a5e9/comments", "author": {"login": "philberty", "id": 84585, "node_id": "MDQ6VXNlcjg0NTg1", "avatar_url": "https://avatars.githubusercontent.com/u/84585?v=4", "gravatar_id": "", "url": "https://api.github.com/users/philberty", "html_url": "https://github.com/philberty", "followers_url": "https://api.github.com/users/philberty/followers", "following_url": "https://api.github.com/users/philberty/following{/other_user}", "gists_url": "https://api.github.com/users/philberty/gists{/gist_id}", "starred_url": "https://api.github.com/users/philberty/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/philberty/subscriptions", "organizations_url": "https://api.github.com/users/philberty/orgs", "repos_url": "https://api.github.com/users/philberty/repos", "events_url": "https://api.github.com/users/philberty/events{/privacy}", "received_events_url": "https://api.github.com/users/philberty/received_events", "type": "User", "site_admin": false}, "committer": {"login": "philberty", "id": 84585, "node_id": "MDQ6VXNlcjg0NTg1", "avatar_url": "https://avatars.githubusercontent.com/u/84585?v=4", "gravatar_id": "", "url": "https://api.github.com/users/philberty", "html_url": "https://github.com/philberty", "followers_url": "https://api.github.com/users/philberty/followers", "following_url": "https://api.github.com/users/philberty/following{/other_user}", "gists_url": "https://api.github.com/users/philberty/gists{/gist_id}", "starred_url": "https://api.github.com/users/philberty/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/philberty/subscriptions", "organizations_url": "https://api.github.com/users/philberty/orgs", "repos_url": "https://api.github.com/users/philberty/repos", "events_url": "https://api.github.com/users/philberty/events{/privacy}", "received_events_url": "https://api.github.com/users/philberty/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "865b6090a8f8981cdfc050ea2ee44abbe92de141", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/865b6090a8f8981cdfc050ea2ee44abbe92de141", "html_url": "https://github.com/Rust-GCC/gccrs/commit/865b6090a8f8981cdfc050ea2ee44abbe92de141"}], "stats": {"total": 191, "additions": 163, "deletions": 28}, "files": [{"sha": "5e3cfaa2f3d49cd6178dda5f37fd2fb7035ebf2b", "filename": "gcc/rust/backend/rust-compile-fnparam.h", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a08ac0c27aed0c6d390d03656b708eb71381a5e9/gcc%2Frust%2Fbackend%2Frust-compile-fnparam.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a08ac0c27aed0c6d390d03656b708eb71381a5e9/gcc%2Frust%2Fbackend%2Frust-compile-fnparam.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-compile-fnparam.h?ref=a08ac0c27aed0c6d390d03656b708eb71381a5e9", "patch": "@@ -36,6 +36,14 @@ class CompileFnParam : public HIRCompileBase, public HIR::HIRPatternVisitor\n     return compiler.compiled_param;\n   }\n \n+  static Bvariable *compile (Context *ctx, tree fndecl, HIR::Pattern *param,\n+\t\t\t     tree decl_type, Location locus)\n+  {\n+    CompileFnParam compiler (ctx, fndecl, decl_type, locus);\n+    param->accept_vis (compiler);\n+    return compiler.compiled_param;\n+  }\n+\n   void visit (HIR::IdentifierPattern &pattern) override\n   {\n     if (!pattern.is_mut ())"}, {"sha": "177c14e8d282dee48de3462a6799813642981cc9", "filename": "gcc/rust/backend/rust-compile-intrinsic.cc", "status": "modified", "additions": 123, "deletions": 1, "changes": 124, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a08ac0c27aed0c6d390d03656b708eb71381a5e9/gcc%2Frust%2Fbackend%2Frust-compile-intrinsic.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a08ac0c27aed0c6d390d03656b708eb71381a5e9/gcc%2Frust%2Fbackend%2Frust-compile-intrinsic.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-compile-intrinsic.cc?ref=a08ac0c27aed0c6d390d03656b708eb71381a5e9", "patch": "@@ -15,10 +15,20 @@\n // <http://www.gnu.org/licenses/>.\n \n #include \"rust-compile-intrinsic.h\"\n+#include \"rust-compile-type.h\"\n+#include \"rust-compile-fnparam.h\"\n+#include \"rust-tree.h\"\n \n namespace Rust {\n namespace Compile {\n \n+static tree\n+offset_intrinsic_handler (Context *ctx, TyTy::BaseType *fntype);\n+\n+static const std::map<std::string,\n+\t\t      std::function<tree (Context *, TyTy::BaseType *)>>\n+  generic_intrinsics = {{\"offset\", &offset_intrinsic_handler}};\n+\n Intrinsics::Intrinsics (Context *ctx) : ctx (ctx) {}\n \n tree\n@@ -82,11 +92,123 @@ Intrinsics::compile (TyTy::FnType *fntype)\n   if (builtin != nullptr)\n     return builtin;\n \n+  // is it an generic builtin?\n+  auto it = generic_intrinsics.find (fntype->get_identifier ());\n+  if (it != generic_intrinsics.end ())\n+    return it->second (ctx, fntype);\n+\n   Location locus = ctx->get_mappings ()->lookup_location (fntype->get_ref ());\n-  rust_error_at (locus, \"unknown builtin\");\n+  rust_error_at (locus, \"unknown builtin intrinsic: %s\",\n+\t\t fntype->get_identifier ().c_str ());\n \n   return error_mark_node;\n }\n \n+static tree\n+offset_intrinsic_handler (Context *ctx, TyTy::BaseType *fntype_tyty)\n+{\n+  rust_assert (fntype_tyty->get_kind () == TyTy::TypeKind::FNDEF);\n+  TyTy::FnType *fntype = static_cast<TyTy::FnType *> (fntype_tyty);\n+  const Resolver::CanonicalPath &canonical_path = fntype->get_ident ().path;\n+\n+  // items can be forward compiled which means we may not need to invoke this\n+  // code. We might also have already compiled this generic function as well.\n+  tree lookup = NULL_TREE;\n+  if (ctx->lookup_function_decl (fntype->get_ty_ref (), &lookup,\n+\t\t\t\t fntype->get_id (), fntype))\n+    {\n+      // has this been added to the list then it must be finished\n+      if (ctx->function_completed (lookup))\n+\t{\n+\t  tree dummy = NULL_TREE;\n+\t  if (!ctx->lookup_function_decl (fntype->get_ty_ref (), &dummy))\n+\t    {\n+\t      ctx->insert_function_decl (fntype, lookup);\n+\t    }\n+\t  return lookup;\n+\t}\n+    }\n+\n+  if (fntype->has_subsititions_defined ())\n+    {\n+      // override the Hir Lookups for the substituions in this context\n+      fntype->override_context ();\n+    }\n+\n+  // offset intrinsic has two params dst pointer and offset isize\n+  if (fntype->get_params ().size () != 2)\n+    {\n+      rust_error_at (fntype->get_ident ().locus,\n+\t\t     \"invalid number of parameters for offset intrinsic\");\n+      return error_mark_node;\n+    }\n+\n+  tree compiled_fn_type = TyTyResolveCompile::compile (ctx, fntype);\n+  std::string ir_symbol_name\n+    = canonical_path.get () + fntype->subst_as_string ();\n+  std::string asm_name = ctx->mangle_item (fntype, canonical_path);\n+\n+  unsigned int flags = 0;\n+  tree fndecl\n+    = ctx->get_backend ()->function (compiled_fn_type, ir_symbol_name, asm_name,\n+\t\t\t\t     flags, fntype->get_ident ().locus);\n+  TREE_PUBLIC (fndecl) = 0;\n+  TREE_READONLY (fndecl) = 1;\n+  DECL_ARTIFICIAL (fndecl) = 1;\n+  DECL_EXTERNAL (fndecl) = 0;\n+  DECL_DECLARED_INLINE_P (fndecl) = 1;\n+\n+  // setup the params\n+  std::vector<Bvariable *> param_vars;\n+  for (auto &parm : fntype->get_params ())\n+    {\n+      auto &referenced_param = parm.first;\n+      auto &param_tyty = parm.second;\n+      auto compiled_param_type = TyTyResolveCompile::compile (ctx, param_tyty);\n+\n+      Location param_locus = referenced_param->get_locus ();\n+      Bvariable *compiled_param_var\n+\t= CompileFnParam::compile (ctx, fndecl, referenced_param,\n+\t\t\t\t   compiled_param_type, param_locus);\n+\n+      param_vars.push_back (compiled_param_var);\n+    }\n+\n+  auto &dst_param = param_vars.at (0);\n+  auto &size_param = param_vars.at (1);\n+  rust_assert (param_vars.size () == 2);\n+  if (!ctx->get_backend ()->function_set_parameters (fndecl, param_vars))\n+    return error_mark_node;\n+\n+  tree enclosing_scope = NULL_TREE;\n+  Location start_location = Location ();\n+  Location end_location = Location ();\n+\n+  tree code_block = ctx->get_backend ()->block (fndecl, enclosing_scope, {},\n+\t\t\t\t\t\tstart_location, end_location);\n+  ctx->push_block (code_block);\n+\n+  // BUILTIN offset FN BODY BEGIN\n+  tree dst = ctx->get_backend ()->var_expression (dst_param, Location ());\n+  tree size = ctx->get_backend ()->var_expression (size_param, Location ());\n+  tree pointer_offset_expr\n+    = pointer_offset_expression (dst, size, BUILTINS_LOCATION);\n+  auto return_statement\n+    = ctx->get_backend ()->return_statement (fndecl, {pointer_offset_expr},\n+\t\t\t\t\t     Location ());\n+  ctx->add_statement (return_statement);\n+  // BUILTIN offset FN BODY END\n+\n+  tree bind_tree = ctx->pop_block ();\n+\n+  gcc_assert (TREE_CODE (bind_tree) == BIND_EXPR);\n+  DECL_SAVED_TREE (fndecl) = bind_tree;\n+\n+  ctx->pop_fn ();\n+  ctx->push_function (fndecl);\n+\n+  return fndecl;\n+}\n+\n } // namespace Compile\n } // namespace Rust"}, {"sha": "2ad672d0b4c8df9b40cda46d44b0c8c19f6266a5", "filename": "gcc/rust/backend/rust-compile-resolve-path.cc", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a08ac0c27aed0c6d390d03656b708eb71381a5e9/gcc%2Frust%2Fbackend%2Frust-compile-resolve-path.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a08ac0c27aed0c6d390d03656b708eb71381a5e9/gcc%2Frust%2Fbackend%2Frust-compile-resolve-path.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-compile-resolve-path.cc?ref=a08ac0c27aed0c6d390d03656b708eb71381a5e9", "patch": "@@ -17,6 +17,7 @@\n // <http://www.gnu.org/licenses/>.\n \n #include \"rust-compile-resolve-path.h\"\n+#include \"rust-compile-intrinsic.h\"\n #include \"rust-compile-item.h\"\n #include \"rust-compile-implitem.h\"\n #include \"rust-compile-expr.h\"\n@@ -142,6 +143,13 @@ ResolvePathRef::resolve (const HIR::PathIdentSegment &final_segment,\n \t  TREE_USED (fn) = 1;\n \t  return address_expression (fn, expr_locus);\n \t}\n+      else if (fntype->get_abi () == ABI::INTRINSIC)\n+\t{\n+\t  Intrinsics compile (ctx);\n+\t  fn = compile.compile (fntype);\n+\t  TREE_USED (fn) = 1;\n+\t  return address_expression (fn, expr_locus);\n+\t}\n     }\n \n   // let the query system figure it out"}, {"sha": "6f7614d041335624d320c460592598e62dff370e", "filename": "gcc/rust/backend/rust-tree.cc", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a08ac0c27aed0c6d390d03656b708eb71381a5e9/gcc%2Frust%2Fbackend%2Frust-tree.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a08ac0c27aed0c6d390d03656b708eb71381a5e9/gcc%2Frust%2Fbackend%2Frust-tree.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-tree.cc?ref=a08ac0c27aed0c6d390d03656b708eb71381a5e9", "patch": "@@ -17,6 +17,7 @@\n // <http://www.gnu.org/licenses/>.\n \n #include \"rust-tree.h\"\n+#include \"fold-const.h\"\n #include \"stringpool.h\"\n #include \"attribs.h\"\n #include \"escaped_string.h\"\n@@ -656,4 +657,21 @@ get_fndecl_from_callee (tree fn)\n   return NULL_TREE;\n }\n \n+tree\n+pointer_offset_expression (tree base_tree, tree index_tree, location_t location)\n+{\n+  tree element_type_tree = TREE_TYPE (TREE_TYPE (base_tree));\n+  if (base_tree == error_mark_node || TREE_TYPE (base_tree) == error_mark_node\n+      || index_tree == error_mark_node || element_type_tree == error_mark_node)\n+    return error_mark_node;\n+\n+  tree element_size = TYPE_SIZE_UNIT (element_type_tree);\n+  index_tree = fold_convert_loc (location, sizetype, index_tree);\n+  tree offset\n+    = fold_build2_loc (location, MULT_EXPR, sizetype, index_tree, element_size);\n+\n+  return fold_build2_loc (location, POINTER_PLUS_EXPR, TREE_TYPE (base_tree),\n+\t\t\t  base_tree, offset);\n+}\n+\n } // namespace Rust"}, {"sha": "c50e090f9391367d1b903cd3a3dac7532eef71df", "filename": "gcc/rust/backend/rust-tree.h", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a08ac0c27aed0c6d390d03656b708eb71381a5e9/gcc%2Frust%2Fbackend%2Frust-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a08ac0c27aed0c6d390d03656b708eb71381a5e9/gcc%2Frust%2Fbackend%2Frust-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-tree.h?ref=a08ac0c27aed0c6d390d03656b708eb71381a5e9", "patch": "@@ -177,6 +177,12 @@ expr_loc_or_input_loc (const_tree t);\n extern tree\n get_fndecl_from_callee (tree fn);\n \n+// FIXME some helpers from HIRCompileBase could probably be moved here over time\n+\n+// Return an expression for the address of BASE[INDEX], used in offset intrinsic\n+extern tree\n+pointer_offset_expression (tree base_tree, tree index_tree, location_t locus);\n+\n } // namespace Rust\n \n #endif // RUST_TREE"}, {"sha": "b942ed339cc835005f50f1c5d80a71cf7addd56f", "filename": "gcc/rust/rust-backend.h", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a08ac0c27aed0c6d390d03656b708eb71381a5e9/gcc%2Frust%2Frust-backend.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a08ac0c27aed0c6d390d03656b708eb71381a5e9/gcc%2Frust%2Frust-backend.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Frust-backend.h?ref=a08ac0c27aed0c6d390d03656b708eb71381a5e9", "patch": "@@ -275,10 +275,6 @@ class Backend\n \t\t\t\tconst std::vector<tree> &vals, Location)\n     = 0;\n \n-  // Return an expression for the address of BASE[INDEX].\n-  // BASE has a pointer type.  This is used for slice indexing.\n-  virtual tree pointer_offset_expression (tree base, tree index, Location) = 0;\n-\n   // Return an expression for ARRAY[INDEX] as an l-value.  ARRAY is a valid\n   // fixed-length array, not a slice.\n   virtual tree array_index_expression (tree array, tree index, Location) = 0;"}, {"sha": "87affcfab98a249e33fe8f487748a92925df441d", "filename": "gcc/rust/rust-gcc.cc", "status": "modified", "additions": 0, "deletions": 23, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a08ac0c27aed0c6d390d03656b708eb71381a5e9/gcc%2Frust%2Frust-gcc.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a08ac0c27aed0c6d390d03656b708eb71381a5e9/gcc%2Frust%2Frust-gcc.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Frust-gcc.cc?ref=a08ac0c27aed0c6d390d03656b708eb71381a5e9", "patch": "@@ -246,8 +246,6 @@ class Gcc_backend : public Backend\n   tree array_constructor_expression (tree, const std::vector<unsigned long> &,\n \t\t\t\t     const std::vector<tree> &, Location);\n \n-  tree pointer_offset_expression (tree base, tree offset, Location);\n-\n   tree array_index_expression (tree array, tree index, Location);\n \n   tree call_expression (tree caller, tree fn, const std::vector<tree> &args,\n@@ -1717,27 +1715,6 @@ Gcc_backend::array_constructor_expression (\n   return ret;\n }\n \n-// Return an expression for the address of BASE[INDEX].\n-\n-tree\n-Gcc_backend::pointer_offset_expression (tree base_tree, tree index_tree,\n-\t\t\t\t\tLocation location)\n-{\n-  tree element_type_tree = TREE_TYPE (TREE_TYPE (base_tree));\n-  if (base_tree == error_mark_node || TREE_TYPE (base_tree) == error_mark_node\n-      || index_tree == error_mark_node || element_type_tree == error_mark_node)\n-    return error_mark_node;\n-\n-  tree element_size = TYPE_SIZE_UNIT (element_type_tree);\n-  index_tree\n-    = fold_convert_loc (location.gcc_location (), sizetype, index_tree);\n-  tree offset = fold_build2_loc (location.gcc_location (), MULT_EXPR, sizetype,\n-\t\t\t\t index_tree, element_size);\n-  tree ptr = fold_build2_loc (location.gcc_location (), POINTER_PLUS_EXPR,\n-\t\t\t      TREE_TYPE (base_tree), base_tree, offset);\n-  return ptr;\n-}\n-\n // Return an expression representing ARRAY[INDEX]\n \n tree"}]}