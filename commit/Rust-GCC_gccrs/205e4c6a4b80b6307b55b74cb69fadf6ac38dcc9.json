{"sha": "205e4c6a4b80b6307b55b74cb69fadf6ac38dcc9", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MjA1ZTRjNmE0YjgwYjYzMDdiNTViNzRjYjY5ZmFkZjZhYzM4ZGNjOQ==", "commit": {"author": {"name": "Eric Botcazou", "email": "ebotcazou@gcc.gnu.org", "date": "2010-12-02T22:33:16Z"}, "committer": {"name": "Eric Botcazou", "email": "ebotcazou@gcc.gnu.org", "date": "2010-12-02T22:33:16Z"}, "message": "re PR target/46685 (New stack alignment failures with -fpic)\n\n\tPR target/46685\n\t* config/sparc/sparc.c (can_use_mov_pic_label_ref): New predicate.\n\t(sparc_expand_move): Call it to decide whether to emit the special\n\tmov{si,di}_pic_label_ref patterns.\n\t(sparc_legitimize_pic_address): Call it to decide whether to emit\n\tthe regular PIC sequence for labels.  Fix long line.\n\t(sparc_file_end): Set is_thunk for the PIC helper.\n\nFrom-SVN: r167395", "tree": {"sha": "778ab8a9ab235a0baa62f6a827ed3204d8e5fa5b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/778ab8a9ab235a0baa62f6a827ed3204d8e5fa5b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/205e4c6a4b80b6307b55b74cb69fadf6ac38dcc9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/205e4c6a4b80b6307b55b74cb69fadf6ac38dcc9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/205e4c6a4b80b6307b55b74cb69fadf6ac38dcc9", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/205e4c6a4b80b6307b55b74cb69fadf6ac38dcc9/comments", "author": null, "committer": null, "parents": [{"sha": "5b824b7616ae246facc5d5cff8dd2ae8eb6088df", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5b824b7616ae246facc5d5cff8dd2ae8eb6088df", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5b824b7616ae246facc5d5cff8dd2ae8eb6088df"}], "stats": {"total": 113, "additions": 97, "deletions": 16}, "files": [{"sha": "fe735812229e01ca6f2c8b7fbf7faefc6e15b8c3", "filename": "gcc/ChangeLog", "status": "modified", "additions": 11, "deletions": 1, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/205e4c6a4b80b6307b55b74cb69fadf6ac38dcc9/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/205e4c6a4b80b6307b55b74cb69fadf6ac38dcc9/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=205e4c6a4b80b6307b55b74cb69fadf6ac38dcc9", "patch": "@@ -1,3 +1,13 @@\n+2010-11-02  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\tPR target/46685\n+\t* config/sparc/sparc.c (can_use_mov_pic_label_ref): New predicate.\n+\t(sparc_expand_move): Call it to decide whether to emit the special\n+\tmov{si,di}_pic_label_ref patterns.\n+\t(sparc_legitimize_pic_address): Call it to decide whether to emit\n+\tthe regular PIC sequence for labels.  Fix long line.\n+\t(sparc_file_end): Set is_thunk for the PIC helper.\n+\n 2010-12-02  Eric Botcazou  <ebotcazou@adacore.com>\n \n \t* tree.c (build_range_type_1): Do not SET_TYPE_STRUCTURAL_EQUALITY\n@@ -5044,7 +5054,7 @@\n 2010-11-02  Richard Guenther  <rguenther@suse.de>\n \n \tPR tree-optimization/46149\n-\t* tree-ssa-structalias.c (get_constraint_for_1): Properly handle\n+\t* tree-ssa-structalias.c (get_constraint_fop_1): Properly handle\n \tnon-indirect MEM_REF variants.\n \n 2010-11-02  Richard Guenther  <rguenther@suse.de>"}, {"sha": "223408def9e7fca07215422f55d6c3dc6cf91930", "filename": "gcc/config/sparc/sparc.c", "status": "modified", "additions": 42, "deletions": 15, "changes": 57, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/205e4c6a4b80b6307b55b74cb69fadf6ac38dcc9/gcc%2Fconfig%2Fsparc%2Fsparc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/205e4c6a4b80b6307b55b74cb69fadf6ac38dcc9/gcc%2Fconfig%2Fsparc%2Fsparc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fsparc.c?ref=205e4c6a4b80b6307b55b74cb69fadf6ac38dcc9", "patch": "@@ -1025,6 +1025,36 @@ fp_high_losum_p (rtx op)\n   return 0;\n }\n \n+/* Return true if the address of LABEL can be loaded by means of the\n+   mov{si,di}_pic_label_ref patterns in PIC mode.  */\n+\n+static bool\n+can_use_mov_pic_label_ref (rtx label)\n+{\n+  /* VxWorks does not impose a fixed gap between segments; the run-time\n+     gap can be different from the object-file gap.  We therefore can't\n+     assume X - _GLOBAL_OFFSET_TABLE_ is a link-time constant unless we\n+     are absolutely sure that X is in the same segment as the GOT.\n+     Unfortunately, the flexibility of linker scripts means that we\n+     can't be sure of that in general, so assume that GOT-relative\n+     accesses are never valid on VxWorks.  */\n+  if (TARGET_VXWORKS_RTP)\n+    return false;\n+\n+  /* Similarly, if the label is non-local, it might end up being placed\n+     in a different section than the current one; now mov_pic_label_ref\n+     requires the label and the code to be in the same section.  */\n+  if (LABEL_REF_NONLOCAL_P (label))\n+    return false;\n+\n+  /* Finally, if we are reordering basic blocks and partition into hot\n+     and cold sections, this might happen for any label.  */\n+  if (flag_reorder_blocks_and_partition)\n+    return false;\n+\n+  return true;\n+}\n+\n /* Expand a move instruction.  Return true if all work is done.  */\n \n bool\n@@ -1059,14 +1089,9 @@ sparc_expand_move (enum machine_mode mode, rtx *operands)\n       if (pic_address_needs_scratch (operands[1]))\n \toperands[1] = sparc_legitimize_pic_address (operands[1], NULL_RTX);\n \n-      /* VxWorks does not impose a fixed gap between segments; the run-time\n-\t gap can be different from the object-file gap.  We therefore can't\n-\t assume X - _GLOBAL_OFFSET_TABLE_ is a link-time constant unless we\n-\t are absolutely sure that X is in the same segment as the GOT.\n-\t Unfortunately, the flexibility of linker scripts means that we\n-\t can't be sure of that in general, so assume that _G_O_T_-relative\n-\t accesses are never valid on VxWorks.  */\n-      if (GET_CODE (operands[1]) == LABEL_REF && !TARGET_VXWORKS_RTP)\n+      /* We cannot use the mov{si,di}_pic_label_ref patterns in all cases.  */\n+      if (GET_CODE (operands[1]) == LABEL_REF\n+\t  && can_use_mov_pic_label_ref (operands[1]))\n \t{\n \t  if (mode == SImode)\n \t    {\n@@ -3425,7 +3450,7 @@ sparc_legitimize_pic_address (rtx orig, rtx reg)\n \n   if (GET_CODE (orig) == SYMBOL_REF\n       /* See the comment in sparc_expand_move.  */\n-      || (TARGET_VXWORKS_RTP && GET_CODE (orig) == LABEL_REF))\n+      || (GET_CODE (orig) == LABEL_REF && !can_use_mov_pic_label_ref (orig)))\n     {\n       rtx pic_ref, address;\n       rtx insn;\n@@ -3478,11 +3503,13 @@ sparc_legitimize_pic_address (rtx orig, rtx reg)\n \t}\n       else\n \t{\n-\t  pic_ref = gen_const_mem (Pmode,\n-\t\t\t\t   gen_rtx_PLUS (Pmode,\n-\t\t\t\t\t\t pic_offset_table_rtx, address));\n+\t  pic_ref\n+\t    = gen_const_mem (Pmode,\n+\t\t\t     gen_rtx_PLUS (Pmode,\n+\t\t\t\t\t   pic_offset_table_rtx, address));\n \t  insn = emit_move_insn (reg, pic_ref);\n \t}\n+\n       /* Put a REG_EQUAL note on this insn, so that it can be optimized\n \t by loop.  */\n       set_unique_reg_note (insn, REG_EQUAL, orig);\n@@ -3520,9 +3547,8 @@ sparc_legitimize_pic_address (rtx orig, rtx reg)\n       return gen_rtx_PLUS (Pmode, base, offset);\n     }\n   else if (GET_CODE (orig) == LABEL_REF)\n-    /* ??? Why do we do this?  */\n-    /* Now movsi_pic_label_ref uses it, but we ought to be checking that\n-       the register is live instead, in case it is eliminated.  */\n+    /* ??? We ought to be checking that the register is live instead, in case\n+       it is eliminated.  */\n     crtl->uses_pic_offset_table = 1;\n \n   return orig;\n@@ -9453,6 +9479,7 @@ sparc_file_end (void)\n \t  DECL_VISIBILITY (decl) = VISIBILITY_HIDDEN;\n \t  DECL_VISIBILITY_SPECIFIED (decl) = 1;\n \t  allocate_struct_function (decl, true);\n+\t  cfun->is_thunk = 1;\n \t  current_function_decl = decl;\n \t  init_varasm_status ();\n \t  assemble_start_function (decl, name);"}, {"sha": "71faa5774950ce027e37569de78a51e36ee5fa02", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/205e4c6a4b80b6307b55b74cb69fadf6ac38dcc9/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/205e4c6a4b80b6307b55b74cb69fadf6ac38dcc9/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=205e4c6a4b80b6307b55b74cb69fadf6ac38dcc9", "patch": "@@ -1,3 +1,7 @@\n+2010-11-02  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\t* gcc.dg/pr46685.c: New test.\n+\n 2010-12-02  Sebastian Pop  <sebastian.pop@amd.com>\n \n \tPR tree-optimization/45199"}, {"sha": "6277bcc2f0a86d4093c34a88fcdbc6f894eb27c7", "filename": "gcc/testsuite/gcc.dg/pr46685.c", "status": "added", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/205e4c6a4b80b6307b55b74cb69fadf6ac38dcc9/gcc%2Ftestsuite%2Fgcc.dg%2Fpr46685.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/205e4c6a4b80b6307b55b74cb69fadf6ac38dcc9/gcc%2Ftestsuite%2Fgcc.dg%2Fpr46685.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fpr46685.c?ref=205e4c6a4b80b6307b55b74cb69fadf6ac38dcc9", "patch": "@@ -0,0 +1,40 @@\n+/* { dg-do compile } */\n+/* { dg-require-effective-target freorder } */\n+/* { dg-require-effective-target fpic } */\n+/* { dg-options \"-O2 -freorder-blocks-and-partition -fpic\" } */\n+\n+__attribute__((noinline, noclone))\n+void bar (void *x)\n+{\n+  asm volatile (\"\" : : \"r\" (x) : \"memory\");\n+}\n+\n+__attribute__((noinline, noclone))\n+void baz (void)\n+{\n+  asm volatile (\"\" : : : \"memory\");\n+}\n+\n+__attribute__((noinline, noclone))\n+int foo (int x)\n+{\n+  __label__ lab;\n+  if (__builtin_expect (x, 0))\n+    {\n+      lab:\n+      baz ();\n+      return 2;\n+    }\n+  bar (&&lab);\n+  return 1;\n+}\n+\n+int\n+main (void)\n+{\n+  int x, i;\n+  asm volatile (\"\" : \"=r\" (x) : \"0\" (0));\n+  for (i = 0; i < 1000000; i++)\n+    foo (x);\n+  return 0;\n+}"}]}