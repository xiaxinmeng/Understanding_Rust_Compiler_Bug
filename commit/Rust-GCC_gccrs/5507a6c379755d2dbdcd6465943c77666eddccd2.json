{"sha": "5507a6c379755d2dbdcd6465943c77666eddccd2", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTUwN2E2YzM3OTc1NWQyZGJkY2Q2NDY1OTQzYzc3NjY2ZWRkY2NkMg==", "commit": {"author": {"name": "Jason Merrill", "email": "jason@redhat.com", "date": "2011-09-16T21:16:16Z"}, "committer": {"name": "Jason Merrill", "email": "jason@gcc.gnu.org", "date": "2011-09-16T21:16:16Z"}, "message": "re PR c++/50424 (G++ doesn't notice possible throw from default argument)\n\n\tPR c++/50424\n\t* call.c (set_flags_from_callee): Split out from build_call_a.\n\t* cp-tree.h: Declare it.\n\t* tree.c (bot_manip): Call it.\n\nFrom-SVN: r178918", "tree": {"sha": "c1aa9820f4c20816bdace6003685cbac03dbc414", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c1aa9820f4c20816bdace6003685cbac03dbc414"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5507a6c379755d2dbdcd6465943c77666eddccd2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5507a6c379755d2dbdcd6465943c77666eddccd2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5507a6c379755d2dbdcd6465943c77666eddccd2", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5507a6c379755d2dbdcd6465943c77666eddccd2/comments", "author": {"login": "jicama", "id": 266146, "node_id": "MDQ6VXNlcjI2NjE0Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/266146?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jicama", "html_url": "https://github.com/jicama", "followers_url": "https://api.github.com/users/jicama/followers", "following_url": "https://api.github.com/users/jicama/following{/other_user}", "gists_url": "https://api.github.com/users/jicama/gists{/gist_id}", "starred_url": "https://api.github.com/users/jicama/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jicama/subscriptions", "organizations_url": "https://api.github.com/users/jicama/orgs", "repos_url": "https://api.github.com/users/jicama/repos", "events_url": "https://api.github.com/users/jicama/events{/privacy}", "received_events_url": "https://api.github.com/users/jicama/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "c0b0ee6f188f16485717954d20d82a293299ff01", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c0b0ee6f188f16485717954d20d82a293299ff01", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c0b0ee6f188f16485717954d20d82a293299ff01"}], "stats": {"total": 121, "additions": 76, "deletions": 45}, "files": [{"sha": "a6de5fae3c7e1210aeb7deaae99337dbe0b50234", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5507a6c379755d2dbdcd6465943c77666eddccd2/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5507a6c379755d2dbdcd6465943c77666eddccd2/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=5507a6c379755d2dbdcd6465943c77666eddccd2", "patch": "@@ -1,3 +1,10 @@\n+2011-09-16  Jason Merrill  <jason@redhat.com>\n+\n+\tPR c++/50424\n+\t* call.c (set_flags_from_callee): Split out from build_call_a.\n+\t* cp-tree.h: Declare it.\n+\t* tree.c (bot_manip): Call it.\n+\n 2011-09-15  Jason Merrill  <jason@redhat.com>\n \n \tPR c++/50365"}, {"sha": "bdbede7fbe646860592c9327d3075981e0dcaf87", "filename": "gcc/cp/call.c", "status": "modified", "additions": 49, "deletions": 44, "changes": 93, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5507a6c379755d2dbdcd6465943c77666eddccd2/gcc%2Fcp%2Fcall.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5507a6c379755d2dbdcd6465943c77666eddccd2/gcc%2Fcp%2Fcall.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcall.c?ref=5507a6c379755d2dbdcd6465943c77666eddccd2", "patch": "@@ -306,11 +306,32 @@ build_call_n (tree function, int n, ...)\n     }\n }\n \n+/* Update various flags in cfun and the call itself based on what is being\n+   called.  Split out of build_call_a so that bot_manip can use it too.  */\n+\n+void\n+set_flags_from_callee (tree call)\n+{\n+  int nothrow;\n+  tree decl = get_callee_fndecl (call);\n+\n+  /* We check both the decl and the type; a function may be known not to\n+     throw without being declared throw().  */\n+  nothrow = ((decl && TREE_NOTHROW (decl))\n+\t     || TYPE_NOTHROW_P (TREE_TYPE (TREE_TYPE (CALL_EXPR_FN (call)))));\n+\n+  if (!nothrow && at_function_scope_p () && cfun && cp_function_chain)\n+    cp_function_chain->can_throw = 1;\n+\n+  if (decl && TREE_THIS_VOLATILE (decl) && cfun && cp_function_chain)\n+    current_function_returns_abnormally = 1;\n+\n+  TREE_NOTHROW (call) = nothrow;\n+}\n+\n tree\n build_call_a (tree function, int n, tree *argarray)\n {\n-  int is_constructor = 0;\n-  int nothrow;\n   tree decl;\n   tree result_type;\n   tree fntype;\n@@ -327,60 +348,45 @@ build_call_a (tree function, int n, tree *argarray)\n   if (SCALAR_TYPE_P (result_type) || VOID_TYPE_P (result_type))\n     result_type = cv_unqualified (result_type);\n \n-  if (TREE_CODE (function) == ADDR_EXPR\n-      && TREE_CODE (TREE_OPERAND (function, 0)) == FUNCTION_DECL)\n-    {\n-      decl = TREE_OPERAND (function, 0);\n-      if (!TREE_USED (decl))\n-\t{\n-\t  /* We invoke build_call directly for several library\n-\t     functions.  These may have been declared normally if\n-\t     we're building libgcc, so we can't just check\n-\t     DECL_ARTIFICIAL.  */\n-\t  gcc_assert (DECL_ARTIFICIAL (decl)\n-\t\t      || !strncmp (IDENTIFIER_POINTER (DECL_NAME (decl)),\n-\t\t\t\t   \"__\", 2));\n-\t  mark_used (decl);\n-\t}\n-    }\n-  else\n-    decl = NULL_TREE;\n-\n-  /* We check both the decl and the type; a function may be known not to\n-     throw without being declared throw().  */\n-  nothrow = ((decl && TREE_NOTHROW (decl))\n-\t     || TYPE_NOTHROW_P (TREE_TYPE (TREE_TYPE (function))));\n+  function = build_call_array_loc (input_location,\n+\t\t\t\t   result_type, function, n, argarray);\n+  set_flags_from_callee (function);\n \n-  if (!nothrow && at_function_scope_p () && cfun && cp_function_chain)\n-    cp_function_chain->can_throw = 1;\n+  decl = get_callee_fndecl (function);\n \n-  if (decl && TREE_THIS_VOLATILE (decl) && cfun && cp_function_chain)\n-    current_function_returns_abnormally = 1;\n+  if (decl && !TREE_USED (decl))\n+    {\n+      /* We invoke build_call directly for several library\n+\t functions.  These may have been declared normally if\n+\t we're building libgcc, so we can't just check\n+\t DECL_ARTIFICIAL.  */\n+      gcc_assert (DECL_ARTIFICIAL (decl)\n+\t\t  || !strncmp (IDENTIFIER_POINTER (DECL_NAME (decl)),\n+\t\t\t       \"__\", 2));\n+      mark_used (decl);\n+    }\n \n   if (decl && TREE_DEPRECATED (decl))\n     warn_deprecated_use (decl, NULL_TREE);\n   require_complete_eh_spec_types (fntype, decl);\n \n-  if (decl && DECL_CONSTRUCTOR_P (decl))\n-    is_constructor = 1;\n+  TREE_HAS_CONSTRUCTOR (function) = (decl && DECL_CONSTRUCTOR_P (decl));\n \n   /* Don't pass empty class objects by value.  This is useful\n      for tags in STL, which are used to control overload resolution.\n      We don't need to handle other cases of copying empty classes.  */\n   if (! decl || ! DECL_BUILT_IN (decl))\n     for (i = 0; i < n; i++)\n-      if (is_empty_class (TREE_TYPE (argarray[i]))\n-\t  && ! TREE_ADDRESSABLE (TREE_TYPE (argarray[i])))\n-\t{\n-\t  tree t = build0 (EMPTY_CLASS_EXPR, TREE_TYPE (argarray[i]));\n-\t  argarray[i] = build2 (COMPOUND_EXPR, TREE_TYPE (t),\n-\t\t\t\targarray[i], t);\n-\t}\n-\n-  function = build_call_array_loc (input_location,\n-\t\t\t\t   result_type, function, n, argarray);\n-  TREE_HAS_CONSTRUCTOR (function) = is_constructor;\n-  TREE_NOTHROW (function) = nothrow;\n+      {\n+\ttree arg = CALL_EXPR_ARG (function, i);\n+\tif (is_empty_class (TREE_TYPE (arg))\n+\t    && ! TREE_ADDRESSABLE (TREE_TYPE (arg)))\n+\t  {\n+\t    tree t = build0 (EMPTY_CLASS_EXPR, TREE_TYPE (arg));\n+\t    arg = build2 (COMPOUND_EXPR, TREE_TYPE (t), arg, t);\n+\t    CALL_EXPR_ARG (function, i) = arg;\n+\t  }\n+      }\n \n   return function;\n }\n@@ -6736,7 +6742,6 @@ build_cxx_call (tree fn, int nargs, tree *argarray)\n   fn = build_call_a (fn, nargs, argarray);\n   SET_EXPR_LOCATION (fn, loc);\n \n-  /* If this call might throw an exception, note that fact.  */\n   fndecl = get_callee_fndecl (fn);\n \n   /* Check that arguments to builtin functions match the expectations.  */"}, {"sha": "8e52e282a3bb16ae0382f0bcaac7663175d25104", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5507a6c379755d2dbdcd6465943c77666eddccd2/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5507a6c379755d2dbdcd6465943c77666eddccd2/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=5507a6c379755d2dbdcd6465943c77666eddccd2", "patch": "@@ -4721,6 +4721,7 @@ extern bool check_dtor_name\t\t\t(tree, tree);\n extern tree build_conditional_expr\t\t(tree, tree, tree, \n                                                  tsubst_flags_t);\n extern tree build_addr_func\t\t\t(tree);\n+extern void set_flags_from_callee\t\t(tree);\n extern tree build_call_a\t\t\t(tree, int, tree*);\n extern tree build_call_n\t\t\t(tree, int, ...);\n extern bool null_ptr_cst_p\t\t\t(tree);"}, {"sha": "998795302c341a190060134a17c211d1a6c06777", "filename": "gcc/cp/tree.c", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5507a6c379755d2dbdcd6465943c77666eddccd2/gcc%2Fcp%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5507a6c379755d2dbdcd6465943c77666eddccd2/gcc%2Fcp%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftree.c?ref=5507a6c379755d2dbdcd6465943c77666eddccd2", "patch": "@@ -1898,7 +1898,10 @@ bot_manip (tree* tp, int* walk_subtrees, void* data)\n     }\n \n   /* Make a copy of this node.  */\n-  return copy_tree_r (tp, walk_subtrees, NULL);\n+  t = copy_tree_r (tp, walk_subtrees, NULL);\n+  if (TREE_CODE (*tp) == CALL_EXPR)\n+    set_flags_from_callee (*tp);\n+  return t;\n }\n \n /* Replace all remapped VAR_DECLs in T with their new equivalents."}, {"sha": "220bfa580416e1f0cf7d5f2f6083421beb9cd8a6", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5507a6c379755d2dbdcd6465943c77666eddccd2/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5507a6c379755d2dbdcd6465943c77666eddccd2/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=5507a6c379755d2dbdcd6465943c77666eddccd2", "patch": "@@ -1,3 +1,8 @@\n+2011-09-16  Jason Merrill  <jason@redhat.com>\n+\n+\tPR c++/50424\n+\t* g++.dg/eh/defarg1.C: New.\n+\n 2011-09-16  Jakub Jelinek  <jakub@redhat.com>\n \n \t* gcc.dg/vect/vect-reduc-10.c: New test."}, {"sha": "5c6e4df494937d39a4ba951cdc060a15929ceb35", "filename": "gcc/testsuite/g++.dg/eh/defarg1.C", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5507a6c379755d2dbdcd6465943c77666eddccd2/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Feh%2Fdefarg1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5507a6c379755d2dbdcd6465943c77666eddccd2/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Feh%2Fdefarg1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Feh%2Fdefarg1.C?ref=5507a6c379755d2dbdcd6465943c77666eddccd2", "patch": "@@ -0,0 +1,10 @@\n+// PR c++/50424\n+// { dg-do run }\n+\n+int f() { throw 1; }\n+void g( int = f() ) { }\n+void h() { g(); }\n+int main()\n+{\n+  try { h(); } catch (int) { }\n+}"}]}