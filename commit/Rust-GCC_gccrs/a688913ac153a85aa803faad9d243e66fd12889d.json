{"sha": "a688913ac153a85aa803faad9d243e66fd12889d", "node_id": "C_kwDOANBUbNoAKGE2ODg5MTNhYzE1M2E4NWFhODAzZmFhZDlkMjQzZTY2ZmQxMjg4OWQ", "commit": {"author": {"name": "Philip Herron", "email": "philip.herron@embecosm.com", "date": "2021-12-15T01:06:52Z"}, "committer": {"name": "Philip Herron", "email": "philip.herron@embecosm.com", "date": "2021-12-16T10:25:07Z"}, "message": "Add hir lowering for match-expr", "tree": {"sha": "01354756e601716520e900635d9b2ec702062cc3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/01354756e601716520e900635d9b2ec702062cc3"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a688913ac153a85aa803faad9d243e66fd12889d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a688913ac153a85aa803faad9d243e66fd12889d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a688913ac153a85aa803faad9d243e66fd12889d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a688913ac153a85aa803faad9d243e66fd12889d/comments", "author": {"login": "philberty", "id": 84585, "node_id": "MDQ6VXNlcjg0NTg1", "avatar_url": "https://avatars.githubusercontent.com/u/84585?v=4", "gravatar_id": "", "url": "https://api.github.com/users/philberty", "html_url": "https://github.com/philberty", "followers_url": "https://api.github.com/users/philberty/followers", "following_url": "https://api.github.com/users/philberty/following{/other_user}", "gists_url": "https://api.github.com/users/philberty/gists{/gist_id}", "starred_url": "https://api.github.com/users/philberty/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/philberty/subscriptions", "organizations_url": "https://api.github.com/users/philberty/orgs", "repos_url": "https://api.github.com/users/philberty/repos", "events_url": "https://api.github.com/users/philberty/events{/privacy}", "received_events_url": "https://api.github.com/users/philberty/received_events", "type": "User", "site_admin": false}, "committer": {"login": "philberty", "id": 84585, "node_id": "MDQ6VXNlcjg0NTg1", "avatar_url": "https://avatars.githubusercontent.com/u/84585?v=4", "gravatar_id": "", "url": "https://api.github.com/users/philberty", "html_url": "https://github.com/philberty", "followers_url": "https://api.github.com/users/philberty/followers", "following_url": "https://api.github.com/users/philberty/following{/other_user}", "gists_url": "https://api.github.com/users/philberty/gists{/gist_id}", "starred_url": "https://api.github.com/users/philberty/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/philberty/subscriptions", "organizations_url": "https://api.github.com/users/philberty/orgs", "repos_url": "https://api.github.com/users/philberty/repos", "events_url": "https://api.github.com/users/philberty/events{/privacy}", "received_events_url": "https://api.github.com/users/philberty/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4dba290c35d2d5023173c6a2d75741b1a4d549ab", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4dba290c35d2d5023173c6a2d75741b1a4d549ab", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4dba290c35d2d5023173c6a2d75741b1a4d549ab"}], "stats": {"total": 304, "additions": 187, "deletions": 117}, "files": [{"sha": "1274578a71429fc644f7aae0439494b37e9ac8cd", "filename": "gcc/rust/Make-lang.in", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a688913ac153a85aa803faad9d243e66fd12889d/gcc%2Frust%2FMake-lang.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a688913ac153a85aa803faad9d243e66fd12889d/gcc%2Frust%2FMake-lang.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2FMake-lang.in?ref=a688913ac153a85aa803faad9d243e66fd12889d", "patch": "@@ -76,6 +76,7 @@ GRS_OBJS = \\\n     rust/rust-hir-full-test.o \\\n     rust/rust-hir-map.o \\\n     rust/rust-ast-lower.o \\\n+    rust/rust-ast-lower-pattern.o \\\n     rust/rust-ast-resolve.o \\\n     rust/rust-ast-resolve-pattern.o \\\n     rust/rust-hir-type-check.o \\"}, {"sha": "8cd4fb537d1479bf3b7ca4cf55ae225e9d2d0329", "filename": "gcc/rust/hir/rust-ast-lower-expr.h", "status": "modified", "additions": 51, "deletions": 0, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a688913ac153a85aa803faad9d243e66fd12889d/gcc%2Frust%2Fhir%2Frust-ast-lower-expr.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a688913ac153a85aa803faad9d243e66fd12889d/gcc%2Frust%2Fhir%2Frust-ast-lower-expr.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fhir%2Frust-ast-lower-expr.h?ref=a688913ac153a85aa803faad9d243e66fd12889d", "patch": "@@ -23,6 +23,7 @@\n #include \"rust-ast-lower-base.h\"\n #include \"rust-ast-lower-block.h\"\n #include \"rust-ast-lower-struct-field-expr.h\"\n+#include \"rust-ast-lower-pattern.h\"\n \n namespace Rust {\n namespace HIR {\n@@ -667,6 +668,56 @@ class ASTLoweringExpr : public ASTLoweringBase\n \t\t\t\t  expr.get_outer_attrs (), expr.get_locus ());\n   }\n \n+  void visit (AST::MatchExpr &expr) override\n+  {\n+    HIR::Expr *branch_value\n+      = ASTLoweringExpr::translate (expr.get_scrutinee_expr ().get ());\n+\n+    std::vector<HIR::MatchCase> match_arms;\n+    for (auto &match_case : expr.get_match_cases ())\n+      {\n+\tHIR::Expr *kase_expr\n+\t  = ASTLoweringExpr::translate (match_case.get_expr ().get ());\n+\n+\tHIR::Expr *kase_guard_expr = nullptr;\n+\tif (match_case.get_arm ().has_match_arm_guard ())\n+\t  {\n+\t    kase_guard_expr = ASTLoweringExpr::translate (\n+\t      match_case.get_arm ().get_guard_expr ().get ());\n+\t  }\n+\n+\tstd::vector<std::unique_ptr<HIR::Pattern> > match_arm_patterns;\n+\tfor (auto &pattern : match_case.get_arm ().get_patterns ())\n+\t  {\n+\t    HIR::Pattern *ptrn = ASTLoweringPattern::translate (pattern.get ());\n+\t    match_arm_patterns.push_back (std::unique_ptr<HIR::Pattern> (ptrn));\n+\t  }\n+\n+\tHIR::MatchArm arm (std::move (match_arm_patterns),\n+\t\t\t   std::unique_ptr<HIR::Expr> (kase_guard_expr),\n+\t\t\t   match_case.get_arm ().get_outer_attrs ());\n+\n+\tauto crate_num = mappings->get_current_crate ();\n+\tAnalysis::NodeMapping mapping (crate_num, expr.get_node_id (),\n+\t\t\t\t       mappings->get_next_hir_id (crate_num),\n+\t\t\t\t       UNKNOWN_LOCAL_DEFID);\n+\n+\tHIR::MatchCase kase (std::move (mapping), std::move (arm),\n+\t\t\t     std::unique_ptr<HIR::Expr> (kase_expr));\n+\tmatch_arms.push_back (std::move (kase));\n+      }\n+\n+    auto crate_num = mappings->get_current_crate ();\n+    Analysis::NodeMapping mapping (crate_num, expr.get_node_id (),\n+\t\t\t\t   mappings->get_next_hir_id (crate_num),\n+\t\t\t\t   UNKNOWN_LOCAL_DEFID);\n+\n+    translated\n+      = new HIR::MatchExpr (mapping, std::unique_ptr<HIR::Expr> (branch_value),\n+\t\t\t    std::move (match_arms), expr.get_inner_attrs (),\n+\t\t\t    expr.get_outer_attrs (), expr.get_locus ());\n+  }\n+\n private:\n   ASTLoweringExpr ()\n     : ASTLoweringBase (), translated (nullptr),"}, {"sha": "4ff61cd2a47e7df93249e9bb48f60de00175d928", "filename": "gcc/rust/hir/rust-ast-lower-pattern.cc", "status": "added", "additions": 115, "deletions": 0, "changes": 115, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a688913ac153a85aa803faad9d243e66fd12889d/gcc%2Frust%2Fhir%2Frust-ast-lower-pattern.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a688913ac153a85aa803faad9d243e66fd12889d/gcc%2Frust%2Fhir%2Frust-ast-lower-pattern.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fhir%2Frust-ast-lower-pattern.cc?ref=a688913ac153a85aa803faad9d243e66fd12889d", "patch": "@@ -0,0 +1,115 @@\n+// Copyright (C) 2020-2021 Free Software Foundation, Inc.\n+\n+// This file is part of GCC.\n+\n+// GCC is free software; you can redistribute it and/or modify it under\n+// the terms of the GNU General Public License as published by the Free\n+// Software Foundation; either version 3, or (at your option) any later\n+// version.\n+\n+// GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+// WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+// for more details.\n+\n+// You should have received a copy of the GNU General Public License\n+// along with GCC; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#include \"rust-ast-lower-pattern.h\"\n+#include \"rust-ast-lower-expr.h\"\n+\n+namespace Rust {\n+namespace HIR {\n+\n+void\n+ASTLoweringPattern::visit (AST::PathInExpression &pattern)\n+{\n+  translated = ASTLowerPathInExpression::translate (&pattern);\n+}\n+\n+void\n+ASTLoweringPattern::visit (AST::TupleStructPattern &pattern)\n+{\n+  HIR::PathInExpression *path\n+    = ASTLowerPathInExpression::translate (&pattern.get_path ());\n+\n+  TupleStructItems *lowered = nullptr;\n+  auto &items = pattern.get_items ();\n+  switch (items->get_item_type ())\n+    {\n+      case AST::TupleStructItems::RANGE: {\n+\t// TODO\n+\tgcc_unreachable ();\n+      }\n+      break;\n+\n+      case AST::TupleStructItems::NO_RANGE: {\n+\tAST::TupleStructItemsNoRange &items_no_range\n+\t  = static_cast<AST::TupleStructItemsNoRange &> (*items.get ());\n+\n+\tstd::vector<std::unique_ptr<HIR::Pattern> > patterns;\n+\tfor (auto &inner_pattern : items_no_range.get_patterns ())\n+\t  {\n+\t    HIR::Pattern *p\n+\t      = ASTLoweringPattern::translate (inner_pattern.get ());\n+\t    patterns.push_back (std::unique_ptr<HIR::Pattern> (p));\n+\t  }\n+\n+\tlowered = new HIR::TupleStructItemsNoRange (std::move (patterns));\n+      }\n+      break;\n+    }\n+\n+  translated = new HIR::TupleStructPattern (\n+    *path, std::unique_ptr<HIR::TupleStructItems> (lowered));\n+}\n+\n+void\n+ASTLoweringPattern::visit (AST::StructPattern &pattern)\n+{\n+  HIR::PathInExpression *path\n+    = ASTLowerPathInExpression::translate (&pattern.get_path ());\n+\n+  auto &raw_elems = pattern.get_struct_pattern_elems ();\n+  rust_assert (!raw_elems.has_etc ());\n+\n+  std::vector<std::unique_ptr<HIR::StructPatternField> > fields;\n+  for (auto &field : raw_elems.get_struct_pattern_fields ())\n+    {\n+      HIR::StructPatternField *f = nullptr;\n+      switch (field->get_item_type ())\n+\t{\n+\t  case AST::StructPatternField::ItemType::TUPLE_PAT: {\n+\t    // TODO\n+\t    gcc_unreachable ();\n+\t  }\n+\t  break;\n+\n+\t  case AST::StructPatternField::ItemType::IDENT_PAT: {\n+\t    // TODO\n+\t    gcc_unreachable ();\n+\t  }\n+\t  break;\n+\n+\t  case AST::StructPatternField::ItemType::IDENT: {\n+\t    AST::StructPatternFieldIdent &ident\n+\t      = static_cast<AST::StructPatternFieldIdent &> (*field.get ());\n+\n+\t    f = new HIR::StructPatternFieldIdent (\n+\t      ident.get_identifier (), ident.is_ref (),\n+\t      ident.is_mut () ? Mutability::Mut : Mutability::Imm,\n+\t      ident.get_outer_attrs (), ident.get_locus ());\n+\t  }\n+\t  break;\n+\t}\n+\n+      fields.push_back (std::unique_ptr<HIR::StructPatternField> (f));\n+    }\n+\n+  HIR::StructPatternElements elems (std::move (fields));\n+  translated = new HIR::StructPattern (*path, std::move (elems));\n+}\n+\n+} // namespace HIR\n+} // namespace Rust"}, {"sha": "d8c03cef7442b3ef83da63fbf457fee1de75ce9e", "filename": "gcc/rust/hir/rust-ast-lower-pattern.h", "status": "modified", "additions": 8, "deletions": 4, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a688913ac153a85aa803faad9d243e66fd12889d/gcc%2Frust%2Fhir%2Frust-ast-lower-pattern.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a688913ac153a85aa803faad9d243e66fd12889d/gcc%2Frust%2Fhir%2Frust-ast-lower-pattern.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fhir%2Frust-ast-lower-pattern.h?ref=a688913ac153a85aa803faad9d243e66fd12889d", "patch": "@@ -20,7 +20,6 @@\n #define RUST_AST_LOWER_PATTERN\n \n #include \"rust-ast-lower-base.h\"\n-#include \"rust-diagnostics.h\"\n \n namespace Rust {\n namespace HIR {\n@@ -34,12 +33,11 @@ class ASTLoweringPattern : public ASTLoweringBase\n   {\n     ASTLoweringPattern resolver;\n     pattern->accept_vis (resolver);\n+    rust_assert (resolver.translated != nullptr);\n     return resolver.translated;\n   }\n \n-  virtual ~ASTLoweringPattern () override {}\n-\n-  void visit (AST::IdentifierPattern &pattern)\n+  void visit (AST::IdentifierPattern &pattern) override\n   {\n     std::unique_ptr<Pattern> to_bind;\n     translated\n@@ -50,6 +48,12 @@ class ASTLoweringPattern : public ASTLoweringBase\n \t\t\t\t    std::move (to_bind));\n   }\n \n+  void visit (AST::PathInExpression &pattern) override;\n+\n+  void visit (AST::StructPattern &pattern) override;\n+\n+  void visit (AST::TupleStructPattern &pattern) override;\n+\n private:\n   ASTLoweringPattern () : translated (nullptr) {}\n "}, {"sha": "0e5d97b5c5331052d97c2631a3a88463bac665c2", "filename": "gcc/rust/hir/tree/rust-hir-expr.h", "status": "modified", "additions": 9, "deletions": 43, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a688913ac153a85aa803faad9d243e66fd12889d/gcc%2Frust%2Fhir%2Ftree%2Frust-hir-expr.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a688913ac153a85aa803faad9d243e66fd12889d/gcc%2Frust%2Fhir%2Ftree%2Frust-hir-expr.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fhir%2Ftree%2Frust-hir-expr.h?ref=a688913ac153a85aa803faad9d243e66fd12889d", "patch": "@@ -3681,57 +3681,29 @@ struct MatchArm\n   std::string as_string () const;\n };\n \n-/*\n-// Base \"match case\" for a match expression - abstract\n-class MatchCase\n-{\n-  MatchArm arm;\n-\n-protected:\n-  MatchCase (MatchArm arm) : arm (std::move (arm)) {}\n-\n-  // Should not require copy constructor or assignment operator overloading\n-\n-  // Clone function implementation as pure virtual method\n-  virtual MatchCase *clone_match_case_impl () const = 0;\n-\n-public:\n-  virtual ~MatchCase () {}\n-\n-  // Unique pointer custom clone function\n-  std::unique_ptr<MatchCase> clone_match_case () const\n-  {\n-    return std::unique_ptr<MatchCase> (clone_match_case_impl ());\n-  }\n-\n-  virtual std::string as_string () const;\n-\n-  virtual void accept_vis (HIRVisitor &vis) = 0;\n-};\n-*/\n-\n /* A \"match case\" - a correlated match arm and resulting expression. Not\n  * abstract. */\n struct MatchCase\n {\n private:\n+  Analysis::NodeMapping mappings;\n   MatchArm arm;\n   std::unique_ptr<Expr> expr;\n \n-  /* TODO: does whether trailing comma exists need to be stored? currently\n-   * assuming it is only syntactical and has no effect on meaning. */\n-\n public:\n-  MatchCase (MatchArm arm, std::unique_ptr<Expr> expr)\n-    : arm (std::move (arm)), expr (std::move (expr))\n+  MatchCase (Analysis::NodeMapping mappings, MatchArm arm,\n+\t     std::unique_ptr<Expr> expr)\n+    : mappings (mappings), arm (std::move (arm)), expr (std::move (expr))\n   {}\n \n   MatchCase (const MatchCase &other)\n-    : arm (other.arm), expr (other.expr->clone_expr ())\n+    : mappings (other.mappings), arm (other.arm),\n+      expr (other.expr->clone_expr ())\n   {}\n \n   MatchCase &operator= (const MatchCase &other)\n   {\n+    mappings = other.mappings;\n     arm = other.arm;\n     expr = other.expr->clone_expr ();\n \n@@ -3744,6 +3716,8 @@ struct MatchCase\n   ~MatchCase () = default;\n \n   std::string as_string () const;\n+\n+  Analysis::NodeMapping get_mappings () const { return mappings; }\n };\n \n #if 0\n@@ -3841,23 +3815,15 @@ class MatchExpr : public ExprWithBlock\n {\n   std::unique_ptr<Expr> branch_value;\n   AST::AttrVec inner_attrs;\n-\n-  // bool has_match_arms;\n-  // MatchArms match_arms;\n-  // std::vector<std::unique_ptr<MatchCase> > match_arms; // inlined from\n-  // MatchArms\n   std::vector<MatchCase> match_arms;\n-\n   Location locus;\n \n public:\n   std::string as_string () const override;\n \n-  // Returns whether the match expression has any match arms.\n   bool has_match_arms () const { return !match_arms.empty (); }\n \n   MatchExpr (Analysis::NodeMapping mappings, std::unique_ptr<Expr> branch_value,\n-\t     // std::vector<std::unique_ptr<MatchCase> > match_arms,\n \t     std::vector<MatchCase> match_arms, AST::AttrVec inner_attrs,\n \t     AST::AttrVec outer_attrs, Location locus)\n     : ExprWithBlock (std::move (mappings), std::move (outer_attrs)),"}, {"sha": "79f3789cb5ae296420dc1144c97bd3a8ed129499", "filename": "gcc/rust/hir/tree/rust-hir-full-decls.h", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a688913ac153a85aa803faad9d243e66fd12889d/gcc%2Frust%2Fhir%2Ftree%2Frust-hir-full-decls.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a688913ac153a85aa803faad9d243e66fd12889d/gcc%2Frust%2Fhir%2Ftree%2Frust-hir-full-decls.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fhir%2Ftree%2Frust-hir-full-decls.h?ref=a688913ac153a85aa803faad9d243e66fd12889d", "patch": "@@ -199,7 +199,6 @@ class StructPatternField;\n class StructPatternFieldTuplePat;\n class StructPatternFieldIdentPat;\n class StructPatternFieldIdent;\n-struct StructPatternElements;\n class StructPattern;\n class TupleStructItems;\n class TupleStructItemsNoRange;"}, {"sha": "76b88255d9a5c2a1cbd2b5faa89aad5cd643c047", "filename": "gcc/rust/hir/tree/rust-hir-full-test.cc", "status": "modified", "additions": 0, "deletions": 10, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a688913ac153a85aa803faad9d243e66fd12889d/gcc%2Frust%2Fhir%2Ftree%2Frust-hir-full-test.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a688913ac153a85aa803faad9d243e66fd12889d/gcc%2Frust%2Fhir%2Ftree%2Frust-hir-full-test.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fhir%2Ftree%2Frust-hir-full-test.cc?ref=a688913ac153a85aa803faad9d243e66fd12889d", "patch": "@@ -2575,16 +2575,6 @@ StructPatternElements::as_string () const\n \t}\n     }\n \n-  str += \"\\n  Etc: \";\n-  if (has_struct_pattern_etc)\n-    {\n-      str += \"true\";\n-    }\n-  else\n-    {\n-      str += \"false\";\n-    }\n-\n   return str;\n }\n "}, {"sha": "1373cc7a49119c766bb6d178fb3c292487f2f61a", "filename": "gcc/rust/hir/tree/rust-hir-pattern.h", "status": "modified", "additions": 3, "deletions": 59, "changes": 62, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a688913ac153a85aa803faad9d243e66fd12889d/gcc%2Frust%2Fhir%2Ftree%2Frust-hir-pattern.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a688913ac153a85aa803faad9d243e66fd12889d/gcc%2Frust%2Fhir%2Ftree%2Frust-hir-pattern.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fhir%2Ftree%2Frust-hir-pattern.h?ref=a688913ac153a85aa803faad9d243e66fd12889d", "patch": "@@ -377,26 +377,6 @@ class ReferencePattern : public Pattern\n   }\n };\n \n-// aka StructPatternEtCetera; potential element in struct pattern\n-struct StructPatternEtc\n-{\n-private:\n-  AST::AttrVec outer_attrs;\n-\n-  // should this store location data?\n-\n-public:\n-  StructPatternEtc (AST::AttrVec outer_attribs)\n-    : outer_attrs (std::move (outer_attribs))\n-  {}\n-\n-  // Creates an empty StructPatternEtc\n-  static StructPatternEtc create_empty ()\n-  {\n-    return StructPatternEtc (AST::AttrVec ());\n-  }\n-};\n-\n // Base class for a single field in a struct pattern - abstract\n class StructPatternField\n {\n@@ -561,45 +541,24 @@ class StructPatternFieldIdent : public StructPatternField\n struct StructPatternElements\n {\n private:\n-  // bool has_struct_pattern_fields;\n   std::vector<std::unique_ptr<StructPatternField> > fields;\n \n-  bool has_struct_pattern_etc;\n-  StructPatternEtc etc;\n-\n-  // must have at least one of the two and maybe both\n-\n-  // should this store location data?\n-\n public:\n   // Returns whether there are any struct pattern fields\n   bool has_struct_pattern_fields () const { return !fields.empty (); }\n \n   /* Returns whether the struct pattern elements is entirely empty (no fields,\n    * no etc). */\n-  bool is_empty () const\n-  {\n-    return !has_struct_pattern_fields () && !has_struct_pattern_etc;\n-  }\n+  bool is_empty () const { return !has_struct_pattern_fields (); }\n \n   // Constructor for StructPatternElements with both (potentially)\n-  StructPatternElements (\n-    std::vector<std::unique_ptr<StructPatternField> > fields,\n-    StructPatternEtc etc)\n-    : fields (std::move (fields)), has_struct_pattern_etc (true),\n-      etc (std::move (etc))\n-  {}\n-\n-  // Constructor for StructPatternElements with no StructPatternEtc\n   StructPatternElements (\n     std::vector<std::unique_ptr<StructPatternField> > fields)\n-    : fields (std::move (fields)), has_struct_pattern_etc (false),\n-      etc (StructPatternEtc::create_empty ())\n+    : fields (std::move (fields))\n   {}\n \n   // Copy constructor with vector clone\n   StructPatternElements (StructPatternElements const &other)\n-    : has_struct_pattern_etc (other.has_struct_pattern_etc), etc (other.etc)\n   {\n     fields.reserve (other.fields.size ());\n     for (const auto &e : other.fields)\n@@ -609,9 +568,6 @@ struct StructPatternElements\n   // Overloaded assignment operator with vector clone\n   StructPatternElements &operator= (StructPatternElements const &other)\n   {\n-    etc = other.etc;\n-    has_struct_pattern_etc = other.has_struct_pattern_etc;\n-\n     fields.reserve (other.fields.size ());\n     for (const auto &e : other.fields)\n       fields.push_back (e->clone_struct_pattern_field ());\n@@ -637,27 +593,15 @@ struct StructPatternElements\n class StructPattern : public Pattern\n {\n   PathInExpression path;\n-\n-  // bool has_struct_pattern_elements;\n   StructPatternElements elems;\n \n-  // TODO: should this store location data? Accessor uses path location data.\n-\n public:\n   std::string as_string () const override;\n \n-  // Constructs a struct pattern from specified StructPatternElements\n-  StructPattern (PathInExpression struct_path,\n-\t\t StructPatternElements elems\n-\t\t = StructPatternElements::create_empty ())\n+  StructPattern (PathInExpression struct_path, StructPatternElements elems)\n     : path (std::move (struct_path)), elems (std::move (elems))\n   {}\n \n-  /* TODO: constructor to construct via elements included in\n-   * StructPatternElements */\n-\n-  /* Returns whether struct pattern has any struct pattern elements (if not, it\n-   * is empty). */\n   bool has_struct_pattern_elems () const { return !elems.is_empty (); }\n \n   Location get_locus () const { return path.get_locus (); }"}]}