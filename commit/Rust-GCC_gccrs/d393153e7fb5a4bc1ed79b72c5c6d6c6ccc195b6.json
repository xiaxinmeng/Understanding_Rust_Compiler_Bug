{"sha": "d393153e7fb5a4bc1ed79b72c5c6d6c6ccc195b6", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDM5MzE1M2U3ZmI1YTRiYzFlZDc5YjcyYzVjNmQ2YzZjY2MxOTViNg==", "commit": {"author": {"name": "Douglas Gregor", "email": "doug.gregor@gmail.com", "date": "2007-03-31T12:41:30Z"}, "committer": {"name": "Doug Gregor", "email": "dgregor@gcc.gnu.org", "date": "2007-03-31T12:41:30Z"}, "message": "re PR c++/31138 (ICE with ellipsis)\n\n2007-03-31  Douglas Gregor  <doug.gregor@gmail.com>\n\n\tPR c++/31138\n\tPR c++/31140\n\tPR c++/31141\n\t* parser.c (declarator_can_be_parameter_pack): New.\n\t(cp_parser_template_parameter): Only parse the `...' if the\n\tdeclarator can be a parameter pack.\n\t(cp_parser_parameter_declaration): Ditto. Also, handle when TYPE\n\tis NULL.\n\t* pt.c (find_parameter_packs_r): Look into the bounds on integer\n\ttypes (they could be used as array bounds). \n\t(check_for_bare_parameter_packs): Deal with TEMPLATE_PARM_INDEX.\n\t(tsubst_pack_expansion): Handle failure to expand parameter\n\tpacks.\n\n2007-03-31  Douglas Gregor  <doug.gregor@gmail.com>\n\n\t* g++.dg/parser/pr31138.C: New.\n\t* g++.dg/parser/pr31140.C: New.\n\t* g++.dg/parser/pr31141.C: New.\n\nFrom-SVN: r123380", "tree": {"sha": "8fa804b4fffaa8361c5c0a3d4f7d5dd2304adab7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8fa804b4fffaa8361c5c0a3d4f7d5dd2304adab7"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d393153e7fb5a4bc1ed79b72c5c6d6c6ccc195b6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d393153e7fb5a4bc1ed79b72c5c6d6c6ccc195b6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d393153e7fb5a4bc1ed79b72c5c6d6c6ccc195b6", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d393153e7fb5a4bc1ed79b72c5c6d6c6ccc195b6/comments", "author": {"login": "DougGregor", "id": 989428, "node_id": "MDQ6VXNlcjk4OTQyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/989428?v=4", "gravatar_id": "", "url": "https://api.github.com/users/DougGregor", "html_url": "https://github.com/DougGregor", "followers_url": "https://api.github.com/users/DougGregor/followers", "following_url": "https://api.github.com/users/DougGregor/following{/other_user}", "gists_url": "https://api.github.com/users/DougGregor/gists{/gist_id}", "starred_url": "https://api.github.com/users/DougGregor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/DougGregor/subscriptions", "organizations_url": "https://api.github.com/users/DougGregor/orgs", "repos_url": "https://api.github.com/users/DougGregor/repos", "events_url": "https://api.github.com/users/DougGregor/events{/privacy}", "received_events_url": "https://api.github.com/users/DougGregor/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "d54a92b5f680c62ae4a129aece857a934e167809", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d54a92b5f680c62ae4a129aece857a934e167809", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d54a92b5f680c62ae4a129aece857a934e167809"}], "stats": {"total": 108, "additions": 90, "deletions": 18}, "files": [{"sha": "c13dceeb1fc8c6df3db8ae7d2a9c76476f0b0924", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d393153e7fb5a4bc1ed79b72c5c6d6c6ccc195b6/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d393153e7fb5a4bc1ed79b72c5c6d6c6ccc195b6/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=d393153e7fb5a4bc1ed79b72c5c6d6c6ccc195b6", "patch": "@@ -1,3 +1,19 @@\n+2007-03-31  Douglas Gregor  <doug.gregor@gmail.com>\n+\n+\tPR c++/31138\n+\tPR c++/31140\n+\tPR c++/31141\n+\t* parser.c (declarator_can_be_parameter_pack): New.\n+\t(cp_parser_template_parameter): Only parse the `...' if the\n+\tdeclarator can be a parameter pack.\n+\t(cp_parser_parameter_declaration): Ditto. Also, handle when TYPE\n+\tis NULL.\n+\t* pt.c (find_parameter_packs_r): Look into the bounds on integer\n+\ttypes (they could be used as array bounds). \n+\t(check_for_bare_parameter_packs): Deal with TEMPLATE_PARM_INDEX.\n+\t(tsubst_pack_expansion): Handle failure to expand parameter\n+\tpacks.\n+\t\n 2007-03-30  Paolo Carlini  <pcarlini@suse.de>\n \n \tPR c++/26099"}, {"sha": "63f7fec0169b63540fac06732a895c61f55feb80", "filename": "gcc/cp/parser.c", "status": "modified", "additions": 51, "deletions": 18, "changes": 69, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d393153e7fb5a4bc1ed79b72c5c6d6c6ccc195b6/gcc%2Fcp%2Fparser.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d393153e7fb5a4bc1ed79b72c5c6d6c6ccc195b6/gcc%2Fcp%2Fparser.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparser.c?ref=d393153e7fb5a4bc1ed79b72c5c6d6c6ccc195b6", "patch": "@@ -1055,6 +1055,36 @@ make_array_declarator (cp_declarator *element, tree bounds)\n   return declarator;\n }\n \n+/* Determine whether the declarator we've seen so far can be a\n+   parameter pack, when followed by an ellipsis.  */\n+static bool \n+declarator_can_be_parameter_pack (cp_declarator *declarator)\n+{\n+  /* Search for a declarator name, or any other declarator that goes\n+     after the point where the ellipsis could appear in a parameter\n+     pack. If we find any of these, then this declarator can not be\n+     made into a parameter pack.  */\n+  bool found = false;\n+  while (declarator && !found)\n+    {\n+      switch ((int)declarator->kind)\n+\t{\n+\tcase cdk_id:\n+\tcase cdk_error:\n+\tcase cdk_array:\n+\tcase cdk_ptrmem:\n+\t  found = true;\n+\t  break;\n+\t  \n+\tdefault:\n+\t  declarator = declarator->declarator;\n+\t  break;\n+\t}\n+    }\n+\n+  return !found;\n+}\n+\n cp_parameter_declarator *no_parameters;\n \n /* Create a parameter declarator with the indicated DECL_SPECIFIERS,\n@@ -9049,9 +9079,9 @@ cp_parser_template_parameter (cp_parser* parser, bool *is_non_type,\n      marked as a parameter pack, then we have a parameter pack (that\n      has no declarator); */\n   if (!*is_parameter_pack\n-      && cp_lexer_next_token_is (parser->lexer, CPP_ELLIPSIS))\n+      && cp_lexer_next_token_is (parser->lexer, CPP_ELLIPSIS)\n+      && declarator_can_be_parameter_pack (parameter_declarator->declarator))\n     {\n-\n       /* Consume the `...'. */\n       cp_lexer_consume_token (parser->lexer);\n       maybe_warn_variadic_templates ();\n@@ -13095,32 +13125,35 @@ cp_parser_parameter_declaration (cp_parser *parser,\n \t\t   cp_parser_attributes_opt (parser));\n     }\n \n-  /* If the next token is an ellipsis, and the type of the declarator\n-     contains parameter packs but it is not a TYPE_PACK_EXPANSION, then\n-     we actually have a parameter pack expansion expression. Otherwise,\n-     leave the ellipsis for a C-style variadic function. */\n+  /* If the next token is an ellipsis, and we have not seen a\n+     declarator name, and the type of the declarator contains parameter\n+     packs but it is not a TYPE_PACK_EXPANSION, then we actually have\n+     a parameter pack expansion expression. Otherwise, leave the\n+     ellipsis for a C-style variadic function. */\n   token = cp_lexer_peek_token (parser->lexer);\n   if (cp_lexer_next_token_is (parser->lexer, CPP_ELLIPSIS))\n     {\n       tree type = decl_specifiers.type;\n \n-      if (DECL_P (type))\n+      if (type && DECL_P (type))\n         type = TREE_TYPE (type);\n \n-      if (TREE_CODE (type) != TYPE_PACK_EXPANSION\n+      if (type\n+\t  && TREE_CODE (type) != TYPE_PACK_EXPANSION\n+\t  && declarator_can_be_parameter_pack (declarator)\n           && (!declarator || !declarator->parameter_pack_p)\n           && uses_parameter_packs (type))\n         {\n-          /* Consume the `...'. */\n-          cp_lexer_consume_token (parser->lexer);\n-          maybe_warn_variadic_templates ();\n-          \n-          /* Build a pack expansion type */\n-          if (declarator)\n-            declarator->parameter_pack_p = true;\n-          else\n-            decl_specifiers.type = make_pack_expansion (type);\n-        }\n+\t  /* Consume the `...'. */\n+\t  cp_lexer_consume_token (parser->lexer);\n+\t  maybe_warn_variadic_templates ();\n+\t  \n+\t  /* Build a pack expansion type */\n+\t  if (declarator)\n+\t    declarator->parameter_pack_p = true;\n+\t  else\n+\t    decl_specifiers.type = make_pack_expansion (type);\n+\t}\n     }\n \n   /* The restriction on defining new types applies only to the type"}, {"sha": "906b8d5b1a9dd400d86a9855a335042a40d36949", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d393153e7fb5a4bc1ed79b72c5c6d6c6ccc195b6/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d393153e7fb5a4bc1ed79b72c5c6d6c6ccc195b6/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=d393153e7fb5a4bc1ed79b72c5c6d6c6ccc195b6", "patch": "@@ -2441,6 +2441,12 @@ find_parameter_packs_r (tree *tp, int *walk_subtrees, void* data)\n       *walk_subtrees = 0;\n       return NULL_TREE;\n \n+    case INTEGER_TYPE:\n+      walk_tree (&TYPE_MAX_VALUE (t), &find_parameter_packs_r, \n+\t\t ppd, ppd->visited);\n+      *walk_subtrees = 0;\n+      return NULL_TREE;\n+\n     default:\n       return NULL_TREE;\n     }\n@@ -2621,6 +2627,8 @@ check_for_bare_parameter_packs (tree t)\n         if (TREE_CODE (pack) == TEMPLATE_TYPE_PARM\n             || TREE_CODE (pack) == TEMPLATE_TEMPLATE_PARM)\n           name = TYPE_NAME (pack);\n+\telse if (TREE_CODE (pack) == TEMPLATE_PARM_INDEX)\n+\t  name = DECL_NAME (TEMPLATE_PARM_DECL (pack));\n         else\n           name = DECL_NAME (pack);\n         inform (\"        %qD\", name);\n@@ -6860,6 +6868,15 @@ tsubst_pack_expansion (tree t, tree args, tsubst_flags_t complain,\n       if (arg_pack && TREE_CODE (arg_pack) == ARGUMENT_PACK_SELECT)\n \targ_pack = ARGUMENT_PACK_SELECT_FROM_PACK (arg_pack);\n       \n+      if (arg_pack && !ARGUMENT_PACK_P (arg_pack))\n+\t/* This can only happen if we forget to expand an argument\n+\t   pack somewhere else. Just return an error, silently.  */\n+\t{\n+\t  result = make_tree_vec (1);\n+\t  TREE_VEC_ELT (result, 0) = error_mark_node;\n+\t  return result;\n+\t}\n+\n       if (arg_pack)\n         {\n           int my_len = "}, {"sha": "35e22c8c187a1451a9d285859c55c2788d1dd975", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d393153e7fb5a4bc1ed79b72c5c6d6c6ccc195b6/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d393153e7fb5a4bc1ed79b72c5c6d6c6ccc195b6/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=d393153e7fb5a4bc1ed79b72c5c6d6c6ccc195b6", "patch": "@@ -1,3 +1,9 @@\n+2007-03-31  Douglas Gregor  <doug.gregor@gmail.com>\n+\n+\t* g++.dg/parser/pr31138.C: New.\n+\t* g++.dg/parser/pr31140.C: New.\n+\t* g++.dg/parser/pr31141.C: New.\n+\n 2007-03-30  Paolo Carlini  <pcarlini@suse.de>\n \n \tPR c++/26099"}]}