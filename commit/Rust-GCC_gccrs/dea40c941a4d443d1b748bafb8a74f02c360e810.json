{"sha": "dea40c941a4d443d1b748bafb8a74f02c360e810", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZGVhNDBjOTQxYTRkNDQzZDFiNzQ4YmFmYjhhNzRmMDJjMzYwZTgxMA==", "commit": {"author": {"name": "Ian Lance Taylor", "email": "iant@golang.org", "date": "2020-02-16T13:20:01Z"}, "committer": {"name": "Ian Lance Taylor", "email": "iant@golang.org", "date": "2020-05-09T23:09:37Z"}, "message": "libbacktrace: add Mach-O support\n\nlibbacktrace/\n\tPR libbacktrace/88745\n\t* macho.c: New file.\n\t* filetype.awk: Recognize Mach-O files.\n\t* Makefile.am (FORMAT_FILES): Add macho.c.\n\t(check_DATA): New variable.  Set to .dSYM if HAVE_DSYMUTIL.\n\t(%.dSYM): New pattern target.\n\t(test_macho_SOURCES, test_macho_CFLAGS): New targets.\n\t(test_macho_LDADD): New target.\n\t(BUILDTESTS): Add test_macho.\n\t(macho.lo): Add dependencies.\n\t* configure.ac: Recognize macho file type.  Check for\n\tmach-o/dyld.h.  Don't try to run objcopy if we don't find it.\n\tLook for dsymutil and define a HAVE_DSYMUTIL conditional.\n\t* Makefile.in: Regenerate.\n\t* configure: Regenerate.\n\t* config.h.in: Regenerate.", "tree": {"sha": "a0f524ed86fa37c9d7e8bd8d6627ee92df721c8b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a0f524ed86fa37c9d7e8bd8d6627ee92df721c8b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/dea40c941a4d443d1b748bafb8a74f02c360e810", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dea40c941a4d443d1b748bafb8a74f02c360e810", "html_url": "https://github.com/Rust-GCC/gccrs/commit/dea40c941a4d443d1b748bafb8a74f02c360e810", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dea40c941a4d443d1b748bafb8a74f02c360e810/comments", "author": {"login": "ianlancetaylor", "id": 3194333, "node_id": "MDQ6VXNlcjMxOTQzMzM=", "avatar_url": "https://avatars.githubusercontent.com/u/3194333?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ianlancetaylor", "html_url": "https://github.com/ianlancetaylor", "followers_url": "https://api.github.com/users/ianlancetaylor/followers", "following_url": "https://api.github.com/users/ianlancetaylor/following{/other_user}", "gists_url": "https://api.github.com/users/ianlancetaylor/gists{/gist_id}", "starred_url": "https://api.github.com/users/ianlancetaylor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ianlancetaylor/subscriptions", "organizations_url": "https://api.github.com/users/ianlancetaylor/orgs", "repos_url": "https://api.github.com/users/ianlancetaylor/repos", "events_url": "https://api.github.com/users/ianlancetaylor/events{/privacy}", "received_events_url": "https://api.github.com/users/ianlancetaylor/received_events", "type": "User", "site_admin": false}, "committer": {"login": "ianlancetaylor", "id": 3194333, "node_id": "MDQ6VXNlcjMxOTQzMzM=", "avatar_url": "https://avatars.githubusercontent.com/u/3194333?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ianlancetaylor", "html_url": "https://github.com/ianlancetaylor", "followers_url": "https://api.github.com/users/ianlancetaylor/followers", "following_url": "https://api.github.com/users/ianlancetaylor/following{/other_user}", "gists_url": "https://api.github.com/users/ianlancetaylor/gists{/gist_id}", "starred_url": "https://api.github.com/users/ianlancetaylor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ianlancetaylor/subscriptions", "organizations_url": "https://api.github.com/users/ianlancetaylor/orgs", "repos_url": "https://api.github.com/users/ianlancetaylor/repos", "events_url": "https://api.github.com/users/ianlancetaylor/events{/privacy}", "received_events_url": "https://api.github.com/users/ianlancetaylor/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4b26b13871a672059d1bdebbc4d87a4429c5abd8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4b26b13871a672059d1bdebbc4d87a4429c5abd8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4b26b13871a672059d1bdebbc4d87a4429c5abd8"}], "stats": {"total": 1629, "additions": 1580, "deletions": 49}, "files": [{"sha": "6fa15fc4e96a8d90ce96a4de3e7c4ae2eb6ac847", "filename": "libbacktrace/ChangeLog", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dea40c941a4d443d1b748bafb8a74f02c360e810/libbacktrace%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dea40c941a4d443d1b748bafb8a74f02c360e810/libbacktrace%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libbacktrace%2FChangeLog?ref=dea40c941a4d443d1b748bafb8a74f02c360e810", "patch": "@@ -1,3 +1,22 @@\n+2020-05-09  Ian Lance Taylor  <iant@golang.org>\n+\n+\tPR libbacktrace/88745\n+\t* macho.c: New file.\n+\t* filetype.awk: Recognize Mach-O files.\n+\t* Makefile.am (FORMAT_FILES): Add macho.c.\n+\t(check_DATA): New variable.  Set to .dSYM if HAVE_DSYMUTIL.\n+\t(%.dSYM): New pattern target.\n+\t(test_macho_SOURCES, test_macho_CFLAGS): New targets.\n+\t(test_macho_LDADD): New target.\n+\t(BUILDTESTS): Add test_macho.\n+\t(macho.lo): Add dependencies.\n+\t* configure.ac: Recognize macho file type.  Check for\n+\tmach-o/dyld.h.  Don't try to run objcopy if we don't find it.\n+\tLook for dsymutil and define a HAVE_DSYMUTIL conditional.\n+\t* Makefile.in: Regenerate.\n+\t* configure: Regenerate.\n+\t* config.h.in: Regenerate.\n+\n 2020-05-09  Ian Lance Taylor  <iant@golang.org>\n \n \t* read.c (backtrace_get_view): Support short read."}, {"sha": "d3a9ba8843ae98025dec5588a900e3fe28df9aa4", "filename": "libbacktrace/Makefile.am", "status": "modified", "additions": 65, "deletions": 3, "changes": 68, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dea40c941a4d443d1b748bafb8a74f02c360e810/libbacktrace%2FMakefile.am", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dea40c941a4d443d1b748bafb8a74f02c360e810/libbacktrace%2FMakefile.am", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libbacktrace%2FMakefile.am?ref=dea40c941a4d443d1b748bafb8a74f02c360e810", "patch": "@@ -56,6 +56,7 @@ BACKTRACE_FILES = \\\n \n FORMAT_FILES = \\\n \telf.c \\\n+\tmacho.c \\\n \tpecoff.c \\\n \tunknown.c \\\n \txcoff.c\n@@ -84,18 +85,28 @@ libbacktrace_la_DEPENDENCIES = $(libbacktrace_la_LIBADD)\n \n # Testsuite.\n \n-# Add test to this variable, if you want it to be build.\n+# Add a test to this variable if you want it to be built.\n check_PROGRAMS =\n \n-# Add test to this variable, if you want it to be run.\n+# Add a test to this variable if you want it to be run.\n TESTS =\n \n-# Add test to this variable, if you want it to be build and run.\n+# Add a test to this variable if you want it to be built and run.\n BUILDTESTS =\n \n+# Add a file to this variable if you want it to be built for testing.\n+check_DATA =\n+\n # Flags to use when compiling test programs.\n libbacktrace_TEST_CFLAGS = $(EXTRA_FLAGS) $(WARN_FLAGS) -g\n \n+if HAVE_DSYMUTIL\n+\n+%.dSYM: %\n+\t$(DSYMUTIL) $<\n+\n+endif HAVE_DSYMUTIL\n+\n if NATIVE\n check_LTLIBRARIES = libbacktrace_alloc.la\n \n@@ -163,6 +174,12 @@ test_elf_64_LDADD = libbacktrace_noformat.la elf_64.lo\n \n BUILDTESTS += test_elf_64\n \n+test_macho_SOURCES = test_format.c testlib.c\n+test_macho_CFLAGS = $(libbacktrace_TEST_CFLAGS)\n+test_macho_LDADD = libbacktrace_noformat.la macho.lo\n+\n+BUILDTESTS += test_macho\n+\n test_xcoff_32_SOURCES = test_format.c testlib.c\n test_xcoff_32_CFLAGS = $(libbacktrace_TEST_CFLAGS)\n test_xcoff_32_LDADD = libbacktrace_noformat.la xcoff_32.lo\n@@ -220,6 +237,10 @@ allocfail.sh: allocfail\n \n TESTS += allocfail.sh\n \n+if HAVE_DSYMUTIL\n+check_DATA += allocfail.dSYM\n+endif HAVE_DSYMUTIL\n+\n if HAVE_ELF\n if HAVE_OBJCOPY_DEBUGLINK\n \n@@ -252,6 +273,10 @@ btest_LDADD = libbacktrace.la\n \n BUILDTESTS += btest\n \n+if HAVE_DSYMUTIL\n+check_DATA += btest.dSYM\n+endif HAVE_DSYMUTIL\n+\n if HAVE_ELF\n \n btest_lto_SOURCES = btest.c testlib.c\n@@ -268,6 +293,10 @@ btest_alloc_LDADD = libbacktrace_alloc.la\n \n BUILDTESTS += btest_alloc\n \n+if HAVE_DSYMUTIL\n+check_DATA += btest_alloc.dSYM\n+endif HAVE_DSYMUTIL\n+\n if HAVE_DWZ\n \n %_dwz: %\n@@ -294,12 +323,20 @@ stest_LDADD = libbacktrace.la\n \n BUILDTESTS += stest\n \n+if HAVE_DSYMUTIL\n+check_DATA += stest.dSYM\n+endif HAVE_DSYMUTIL\n+\n stest_alloc_SOURCES = $(stest_SOURCES)\n stest_alloc_CFLAGS = $(libbacktrace_TEST_CFLAGS)\n stest_alloc_LDADD = libbacktrace_alloc.la\n \n BUILDTESTS += stest_alloc\n \n+if HAVE_DSYMUTIL\n+check_DATA += stest_alloc.dSYM\n+endif HAVE_DSYMUTIL\n+\n if HAVE_ELF\n \n ztest_SOURCES = ztest.c testlib.c\n@@ -329,10 +366,18 @@ edtest_LDADD = libbacktrace.la\n \n BUILDTESTS += edtest\n \n+if HAVE_DSYMUTIL\n+check_DATA += edtest.dSYM\n+endif HAVE_DSYMUTIL\n+\n edtest_alloc_SOURCES = $(edtest_SOURCES)\n edtest_alloc_CFLAGS = $(libbacktrace_TEST_CFLAGS)\n edtest_alloc_LDADD = libbacktrace_alloc.la\n \n+if HAVE_DSYMUTIL\n+check_DATA += edtest_alloc.dSYM\n+endif HAVE_DSYMUTIL\n+\n BUILDTESTS += edtest_alloc\n \n edtest2_build.c: gen_edtest2_build; @true\n@@ -349,12 +394,20 @@ ttest_SOURCES = ttest.c testlib.c\n ttest_CFLAGS = $(libbacktrace_TEST_CFLAGS) -pthread\n ttest_LDADD = libbacktrace.la\n \n+if HAVE_DSYMUTIL\n+check_DATA += ttest.dSYM\n+endif HAVE_DSYMUTIL\n+\n BUILDTESTS += ttest_alloc\n \n ttest_alloc_SOURCES = $(ttest_SOURCES)\n ttest_alloc_CFLAGS = $(ttest_CFLAGS)\n ttest_alloc_LDADD = libbacktrace_alloc.la\n \n+if HAVE_DSYMUTIL\n+check_DATA += ttest_alloc.dSYM\n+endif HAVE_DSYMUTIL\n+\n endif HAVE_PTHREAD\n \n if HAVE_OBJCOPY_DEBUGLINK\n@@ -409,12 +462,20 @@ dwarf5_LDADD = libbacktrace.la\n \n BUILDTESTS += dwarf5\n \n+if HAVE_DSYMUTIL\n+check_DATA += dwarf5.dSYM\n+endif HAVE_DSYMUTIL\n+\n dwarf5_alloc_SOURCES = $(dwarf5_SOURCES)\n dwarf5_alloc_CFLAGS = $(dwarf5_CFLAGS)\n dwarf5_alloc_LDADD = libbacktrace_alloc.la\n \n BUILDTESTS += dwarf5_alloc\n \n+if HAVE_DSYMUTIL\n+check_DATA += dwarf5_alloc.dSYM\n+endif HAVE_DSYMUTIL\n+\n endif\n \n endif NATIVE\n@@ -448,6 +509,7 @@ dwarf.lo: config.h $(INCDIR)/dwarf2.h $(INCDIR)/dwarf2.def \\\n \t$(INCDIR)/filenames.h backtrace.h internal.h\n elf.lo: config.h backtrace.h internal.h\n fileline.lo: config.h backtrace.h internal.h\n+macho.lo: config.h backtrace.h internal.h\n mmap.lo: config.h backtrace.h internal.h\n mmapio.lo: config.h backtrace.h internal.h\n nounwind.lo: config.h internal.h"}, {"sha": "9381adebebce7fb8fa20024639b497a6eca3a1d7", "filename": "libbacktrace/Makefile.in", "status": "modified", "additions": 87, "deletions": 36, "changes": 123, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dea40c941a4d443d1b748bafb8a74f02c360e810/libbacktrace%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dea40c941a4d443d1b748bafb8a74f02c360e810/libbacktrace%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libbacktrace%2FMakefile.in?ref=dea40c941a4d443d1b748bafb8a74f02c360e810", "patch": "@@ -122,33 +122,41 @@ host_triplet = @host@\n target_triplet = @target@\n check_PROGRAMS = $(am__EXEEXT_1) $(am__EXEEXT_2) $(am__EXEEXT_3) \\\n \t$(am__EXEEXT_12)\n-TESTS = $(am__append_4) $(am__append_6) $(am__append_8) \\\n-\t$(am__append_11) $(am__append_12) $(am__append_18) \\\n+TESTS = $(am__append_4) $(am__append_7) $(am__append_9) \\\n+\t$(am__append_12) $(am__append_13) $(am__append_20) \\\n \t$(am__EXEEXT_12)\n @HAVE_ELF_TRUE@@HAVE_OBJCOPY_DEBUGLINK_TRUE@@NATIVE_TRUE@am__append_1 = libbacktrace_elf_for_test.la\n-@NATIVE_TRUE@am__append_2 = test_elf_32 test_elf_64 test_xcoff_32 \\\n-@NATIVE_TRUE@\ttest_xcoff_64 test_pecoff test_unknown unittest \\\n-@NATIVE_TRUE@\tunittest_alloc btest\n+@NATIVE_TRUE@am__append_2 = test_elf_32 test_elf_64 test_macho \\\n+@NATIVE_TRUE@\ttest_xcoff_32 test_xcoff_64 test_pecoff \\\n+@NATIVE_TRUE@\ttest_unknown unittest unittest_alloc btest\n @NATIVE_TRUE@am__append_3 = allocfail\n @NATIVE_TRUE@am__append_4 = allocfail.sh\n-@HAVE_ELF_TRUE@@HAVE_OBJCOPY_DEBUGLINK_TRUE@@NATIVE_TRUE@am__append_5 = b2test\n-@HAVE_ELF_TRUE@@HAVE_OBJCOPY_DEBUGLINK_TRUE@@NATIVE_TRUE@am__append_6 = b2test_buildid\n-@HAVE_DWZ_TRUE@@HAVE_ELF_TRUE@@HAVE_OBJCOPY_DEBUGLINK_TRUE@@NATIVE_TRUE@am__append_7 = b3test\n-@HAVE_DWZ_TRUE@@HAVE_ELF_TRUE@@HAVE_OBJCOPY_DEBUGLINK_TRUE@@NATIVE_TRUE@am__append_8 = b3test_dwz_buildid\n-@HAVE_ELF_TRUE@@NATIVE_TRUE@am__append_9 = btest_lto\n-@NATIVE_TRUE@am__append_10 = btest_alloc stest stest_alloc\n-@HAVE_DWZ_TRUE@@NATIVE_TRUE@am__append_11 = btest_dwz\n-@HAVE_DWZ_TRUE@@HAVE_OBJCOPY_DEBUGLINK_TRUE@@NATIVE_TRUE@am__append_12 = btest_dwz_gnudebuglink\n-@HAVE_ELF_TRUE@@HAVE_ZLIB_TRUE@@NATIVE_TRUE@am__append_13 = -lz\n+@HAVE_DSYMUTIL_TRUE@@NATIVE_TRUE@am__append_5 = allocfail.dSYM \\\n+@HAVE_DSYMUTIL_TRUE@@NATIVE_TRUE@\tbtest.dSYM btest_alloc.dSYM \\\n+@HAVE_DSYMUTIL_TRUE@@NATIVE_TRUE@\tstest.dSYM stest_alloc.dSYM \\\n+@HAVE_DSYMUTIL_TRUE@@NATIVE_TRUE@\tedtest.dSYM edtest_alloc.dSYM\n+@HAVE_ELF_TRUE@@HAVE_OBJCOPY_DEBUGLINK_TRUE@@NATIVE_TRUE@am__append_6 = b2test\n+@HAVE_ELF_TRUE@@HAVE_OBJCOPY_DEBUGLINK_TRUE@@NATIVE_TRUE@am__append_7 = b2test_buildid\n+@HAVE_DWZ_TRUE@@HAVE_ELF_TRUE@@HAVE_OBJCOPY_DEBUGLINK_TRUE@@NATIVE_TRUE@am__append_8 = b3test\n+@HAVE_DWZ_TRUE@@HAVE_ELF_TRUE@@HAVE_OBJCOPY_DEBUGLINK_TRUE@@NATIVE_TRUE@am__append_9 = b3test_dwz_buildid\n+@HAVE_ELF_TRUE@@NATIVE_TRUE@am__append_10 = btest_lto\n+@NATIVE_TRUE@am__append_11 = btest_alloc stest stest_alloc\n+@HAVE_DWZ_TRUE@@NATIVE_TRUE@am__append_12 = btest_dwz\n+@HAVE_DWZ_TRUE@@HAVE_OBJCOPY_DEBUGLINK_TRUE@@NATIVE_TRUE@am__append_13 = btest_dwz_gnudebuglink\n @HAVE_ELF_TRUE@@HAVE_ZLIB_TRUE@@NATIVE_TRUE@am__append_14 = -lz\n-@HAVE_ELF_TRUE@@NATIVE_TRUE@am__append_15 = ztest ztest_alloc\n-@NATIVE_TRUE@am__append_16 = edtest edtest_alloc\n-@HAVE_PTHREAD_TRUE@@NATIVE_TRUE@am__append_17 = ttest ttest_alloc\n-@HAVE_OBJCOPY_DEBUGLINK_TRUE@@NATIVE_TRUE@am__append_18 = btest_gnudebuglink\n-@HAVE_COMPRESSED_DEBUG_TRUE@@NATIVE_TRUE@am__append_19 = ctestg ctesta \\\n+@HAVE_ELF_TRUE@@HAVE_ZLIB_TRUE@@NATIVE_TRUE@am__append_15 = -lz\n+@HAVE_ELF_TRUE@@NATIVE_TRUE@am__append_16 = ztest ztest_alloc\n+@NATIVE_TRUE@am__append_17 = edtest edtest_alloc\n+@HAVE_PTHREAD_TRUE@@NATIVE_TRUE@am__append_18 = ttest ttest_alloc\n+@HAVE_DSYMUTIL_TRUE@@HAVE_PTHREAD_TRUE@@NATIVE_TRUE@am__append_19 = ttest.dSYM \\\n+@HAVE_DSYMUTIL_TRUE@@HAVE_PTHREAD_TRUE@@NATIVE_TRUE@\tttest_alloc.dSYM\n+@HAVE_OBJCOPY_DEBUGLINK_TRUE@@NATIVE_TRUE@am__append_20 = btest_gnudebuglink\n+@HAVE_COMPRESSED_DEBUG_TRUE@@NATIVE_TRUE@am__append_21 = ctestg ctesta \\\n @HAVE_COMPRESSED_DEBUG_TRUE@@NATIVE_TRUE@\tctestg_alloc \\\n @HAVE_COMPRESSED_DEBUG_TRUE@@NATIVE_TRUE@\tctesta_alloc\n-@HAVE_DWARF5_TRUE@@NATIVE_TRUE@am__append_20 = dwarf5 dwarf5_alloc\n+@HAVE_DWARF5_TRUE@@NATIVE_TRUE@am__append_22 = dwarf5 dwarf5_alloc\n+@HAVE_DSYMUTIL_TRUE@@HAVE_DWARF5_TRUE@@NATIVE_TRUE@am__append_23 = dwarf5.dSYM \\\n+@HAVE_DSYMUTIL_TRUE@@HAVE_DWARF5_TRUE@@NATIVE_TRUE@\tdwarf5_alloc.dSYM\n subdir = .\n ACLOCAL_M4 = $(top_srcdir)/aclocal.m4\n am__aclocal_m4_deps = $(top_srcdir)/../config/cet.m4 \\\n@@ -208,10 +216,10 @@ libbacktrace_noformat_la_OBJECTS =  \\\n @HAVE_ELF_TRUE@@HAVE_OBJCOPY_DEBUGLINK_TRUE@@NATIVE_TRUE@am__EXEEXT_2 = b2test$(EXEEXT)\n @HAVE_DWZ_TRUE@@HAVE_ELF_TRUE@@HAVE_OBJCOPY_DEBUGLINK_TRUE@@NATIVE_TRUE@am__EXEEXT_3 = b3test$(EXEEXT)\n @NATIVE_TRUE@am__EXEEXT_4 = test_elf_32$(EXEEXT) test_elf_64$(EXEEXT) \\\n-@NATIVE_TRUE@\ttest_xcoff_32$(EXEEXT) test_xcoff_64$(EXEEXT) \\\n-@NATIVE_TRUE@\ttest_pecoff$(EXEEXT) test_unknown$(EXEEXT) \\\n-@NATIVE_TRUE@\tunittest$(EXEEXT) unittest_alloc$(EXEEXT) \\\n-@NATIVE_TRUE@\tbtest$(EXEEXT)\n+@NATIVE_TRUE@\ttest_macho$(EXEEXT) test_xcoff_32$(EXEEXT) \\\n+@NATIVE_TRUE@\ttest_xcoff_64$(EXEEXT) test_pecoff$(EXEEXT) \\\n+@NATIVE_TRUE@\ttest_unknown$(EXEEXT) unittest$(EXEEXT) \\\n+@NATIVE_TRUE@\tunittest_alloc$(EXEEXT) btest$(EXEEXT)\n @HAVE_ELF_TRUE@@NATIVE_TRUE@am__EXEEXT_5 = btest_lto$(EXEEXT)\n @NATIVE_TRUE@am__EXEEXT_6 = btest_alloc$(EXEEXT) stest$(EXEEXT) \\\n @NATIVE_TRUE@\tstest_alloc$(EXEEXT)\n@@ -378,6 +386,14 @@ test_elf_64_OBJECTS = $(am_test_elf_64_OBJECTS)\n test_elf_64_LINK = $(LIBTOOL) $(AM_V_lt) --tag=CC $(AM_LIBTOOLFLAGS) \\\n \t$(LIBTOOLFLAGS) --mode=link $(CCLD) $(test_elf_64_CFLAGS) \\\n \t$(CFLAGS) $(AM_LDFLAGS) $(LDFLAGS) -o $@\n+@NATIVE_TRUE@am_test_macho_OBJECTS = test_macho-test_format.$(OBJEXT) \\\n+@NATIVE_TRUE@\ttest_macho-testlib.$(OBJEXT)\n+test_macho_OBJECTS = $(am_test_macho_OBJECTS)\n+@NATIVE_TRUE@test_macho_DEPENDENCIES = libbacktrace_noformat.la \\\n+@NATIVE_TRUE@\tmacho.lo\n+test_macho_LINK = $(LIBTOOL) $(AM_V_lt) --tag=CC $(AM_LIBTOOLFLAGS) \\\n+\t$(LIBTOOLFLAGS) --mode=link $(CCLD) $(test_macho_CFLAGS) \\\n+\t$(CFLAGS) $(AM_LDFLAGS) $(LDFLAGS) -o $@\n @NATIVE_TRUE@am_test_pecoff_OBJECTS =  \\\n @NATIVE_TRUE@\ttest_pecoff-test_format.$(OBJEXT) \\\n @NATIVE_TRUE@\ttest_pecoff-testlib.$(OBJEXT)\n@@ -516,10 +532,10 @@ SOURCES = $(libbacktrace_la_SOURCES) $(EXTRA_libbacktrace_la_SOURCES) \\\n \t$(dwarf5_alloc_SOURCES) $(edtest_SOURCES) \\\n \t$(edtest_alloc_SOURCES) $(stest_SOURCES) \\\n \t$(stest_alloc_SOURCES) $(test_elf_32_SOURCES) \\\n-\t$(test_elf_64_SOURCES) $(test_pecoff_SOURCES) \\\n-\t$(test_unknown_SOURCES) $(test_xcoff_32_SOURCES) \\\n-\t$(test_xcoff_64_SOURCES) $(ttest_SOURCES) \\\n-\t$(ttest_alloc_SOURCES) $(unittest_SOURCES) \\\n+\t$(test_elf_64_SOURCES) $(test_macho_SOURCES) \\\n+\t$(test_pecoff_SOURCES) $(test_unknown_SOURCES) \\\n+\t$(test_xcoff_32_SOURCES) $(test_xcoff_64_SOURCES) \\\n+\t$(ttest_SOURCES) $(ttest_alloc_SOURCES) $(unittest_SOURCES) \\\n \t$(unittest_alloc_SOURCES) $(ztest_SOURCES) \\\n \t$(ztest_alloc_SOURCES)\n am__can_run_installinfo = \\\n@@ -906,6 +922,7 @@ BACKTRACE_FILES = \\\n \n FORMAT_FILES = \\\n \telf.c \\\n+\tmacho.c \\\n \tpecoff.c \\\n \tunknown.c \\\n \txcoff.c\n@@ -932,10 +949,13 @@ libbacktrace_la_LIBADD = \\\n \n libbacktrace_la_DEPENDENCIES = $(libbacktrace_la_LIBADD)\n \n-# Add test to this variable, if you want it to be build and run.\n-BUILDTESTS = $(am__append_2) $(am__append_9) $(am__append_10) \\\n-\t$(am__append_15) $(am__append_16) $(am__append_17) \\\n-\t$(am__append_19) $(am__append_20)\n+# Add a test to this variable if you want it to be built and run.\n+BUILDTESTS = $(am__append_2) $(am__append_10) $(am__append_11) \\\n+\t$(am__append_16) $(am__append_17) $(am__append_18) \\\n+\t$(am__append_21) $(am__append_22)\n+\n+# Add a file to this variable if you want it to be built for testing.\n+check_DATA = $(am__append_5) $(am__append_19) $(am__append_23)\n \n # Flags to use when compiling test programs.\n libbacktrace_TEST_CFLAGS = $(EXTRA_FLAGS) $(WARN_FLAGS) -g\n@@ -959,6 +979,9 @@ libbacktrace_TEST_CFLAGS = $(EXTRA_FLAGS) $(WARN_FLAGS) -g\n @NATIVE_TRUE@test_elf_64_SOURCES = test_format.c testlib.c\n @NATIVE_TRUE@test_elf_64_CFLAGS = $(libbacktrace_TEST_CFLAGS)\n @NATIVE_TRUE@test_elf_64_LDADD = libbacktrace_noformat.la elf_64.lo\n+@NATIVE_TRUE@test_macho_SOURCES = test_format.c testlib.c\n+@NATIVE_TRUE@test_macho_CFLAGS = $(libbacktrace_TEST_CFLAGS)\n+@NATIVE_TRUE@test_macho_LDADD = libbacktrace_noformat.la macho.lo\n @NATIVE_TRUE@test_xcoff_32_SOURCES = test_format.c testlib.c\n @NATIVE_TRUE@test_xcoff_32_CFLAGS = $(libbacktrace_TEST_CFLAGS)\n @NATIVE_TRUE@test_xcoff_32_LDADD = libbacktrace_noformat.la xcoff_32.lo\n@@ -1013,10 +1036,10 @@ libbacktrace_TEST_CFLAGS = $(EXTRA_FLAGS) $(WARN_FLAGS) -g\n @HAVE_ELF_TRUE@@NATIVE_TRUE@ztest_SOURCES = ztest.c testlib.c\n @HAVE_ELF_TRUE@@NATIVE_TRUE@ztest_CFLAGS = $(libbacktrace_TEST_CFLAGS) -DSRCDIR=\\\"$(srcdir)\\\"\n @HAVE_ELF_TRUE@@NATIVE_TRUE@ztest_LDADD = libbacktrace.la \\\n-@HAVE_ELF_TRUE@@NATIVE_TRUE@\t$(am__append_13) \\\n+@HAVE_ELF_TRUE@@NATIVE_TRUE@\t$(am__append_14) \\\n @HAVE_ELF_TRUE@@NATIVE_TRUE@\t$(CLOCK_GETTIME_LINK)\n @HAVE_ELF_TRUE@@NATIVE_TRUE@ztest_alloc_LDADD = libbacktrace_alloc.la \\\n-@HAVE_ELF_TRUE@@NATIVE_TRUE@\t$(am__append_14) \\\n+@HAVE_ELF_TRUE@@NATIVE_TRUE@\t$(am__append_15) \\\n @HAVE_ELF_TRUE@@NATIVE_TRUE@\t$(CLOCK_GETTIME_LINK)\n @HAVE_ELF_TRUE@@NATIVE_TRUE@ztest_alloc_SOURCES = $(ztest_SOURCES)\n @HAVE_ELF_TRUE@@NATIVE_TRUE@ztest_alloc_CFLAGS = $(ztest_CFLAGS)\n@@ -1251,6 +1274,10 @@ test_elf_64$(EXEEXT): $(test_elf_64_OBJECTS) $(test_elf_64_DEPENDENCIES) $(EXTRA\n \t@rm -f test_elf_64$(EXEEXT)\n \t$(AM_V_CCLD)$(test_elf_64_LINK) $(test_elf_64_OBJECTS) $(test_elf_64_LDADD) $(LIBS)\n \n+test_macho$(EXEEXT): $(test_macho_OBJECTS) $(test_macho_DEPENDENCIES) $(EXTRA_test_macho_DEPENDENCIES) \n+\t@rm -f test_macho$(EXEEXT)\n+\t$(AM_V_CCLD)$(test_macho_LINK) $(test_macho_OBJECTS) $(test_macho_LDADD) $(LIBS)\n+\n test_pecoff$(EXEEXT): $(test_pecoff_OBJECTS) $(test_pecoff_DEPENDENCIES) $(EXTRA_test_pecoff_DEPENDENCIES) \n \t@rm -f test_pecoff$(EXEEXT)\n \t$(AM_V_CCLD)$(test_pecoff_LINK) $(test_pecoff_OBJECTS) $(test_pecoff_LDADD) $(LIBS)\n@@ -1522,6 +1549,18 @@ test_elf_64-testlib.o: testlib.c\n test_elf_64-testlib.obj: testlib.c\n \t$(AM_V_CC)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(test_elf_64_CFLAGS) $(CFLAGS) -c -o test_elf_64-testlib.obj `if test -f 'testlib.c'; then $(CYGPATH_W) 'testlib.c'; else $(CYGPATH_W) '$(srcdir)/testlib.c'; fi`\n \n+test_macho-test_format.o: test_format.c\n+\t$(AM_V_CC)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(test_macho_CFLAGS) $(CFLAGS) -c -o test_macho-test_format.o `test -f 'test_format.c' || echo '$(srcdir)/'`test_format.c\n+\n+test_macho-test_format.obj: test_format.c\n+\t$(AM_V_CC)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(test_macho_CFLAGS) $(CFLAGS) -c -o test_macho-test_format.obj `if test -f 'test_format.c'; then $(CYGPATH_W) 'test_format.c'; else $(CYGPATH_W) '$(srcdir)/test_format.c'; fi`\n+\n+test_macho-testlib.o: testlib.c\n+\t$(AM_V_CC)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(test_macho_CFLAGS) $(CFLAGS) -c -o test_macho-testlib.o `test -f 'testlib.c' || echo '$(srcdir)/'`testlib.c\n+\n+test_macho-testlib.obj: testlib.c\n+\t$(AM_V_CC)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(test_macho_CFLAGS) $(CFLAGS) -c -o test_macho-testlib.obj `if test -f 'testlib.c'; then $(CYGPATH_W) 'testlib.c'; else $(CYGPATH_W) '$(srcdir)/testlib.c'; fi`\n+\n test_pecoff-test_format.o: test_format.c\n \t$(AM_V_CC)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(test_pecoff_CFLAGS) $(CFLAGS) -c -o test_pecoff-test_format.o `test -f 'test_format.c' || echo '$(srcdir)/'`test_format.c\n \n@@ -1840,7 +1879,7 @@ check-TESTS:\n \tlog_list=`echo $$log_list`; trs_list=`echo $$trs_list`; \\\n \t$(MAKE) $(AM_MAKEFLAGS) $(TEST_SUITE_LOG) TEST_LOGS=\"$$log_list\"; \\\n \texit $$?;\n-recheck: all $(check_LTLIBRARIES) $(check_PROGRAMS)\n+recheck: all $(check_LTLIBRARIES) $(check_PROGRAMS) $(check_DATA)\n \t@test -z \"$(TEST_SUITE_LOG)\" || rm -f $(TEST_SUITE_LOG)\n \t@set +e; $(am__set_TESTS_bases); \\\n \tbases=`for i in $$bases; do echo $$i; done \\\n@@ -1907,6 +1946,13 @@ test_elf_64.log: test_elf_64$(EXEEXT)\n \t--log-file $$b.log --trs-file $$b.trs \\\n \t$(am__common_driver_flags) $(AM_LOG_DRIVER_FLAGS) $(LOG_DRIVER_FLAGS) -- $(LOG_COMPILE) \\\n \t\"$$tst\" $(AM_TESTS_FD_REDIRECT)\n+test_macho.log: test_macho$(EXEEXT)\n+\t@p='test_macho$(EXEEXT)'; \\\n+\tb='test_macho'; \\\n+\t$(am__check_pre) $(LOG_DRIVER) --test-name \"$$f\" \\\n+\t--log-file $$b.log --trs-file $$b.trs \\\n+\t$(am__common_driver_flags) $(AM_LOG_DRIVER_FLAGS) $(LOG_DRIVER_FLAGS) -- $(LOG_COMPILE) \\\n+\t\"$$tst\" $(AM_TESTS_FD_REDIRECT)\n test_xcoff_32.log: test_xcoff_32$(EXEEXT)\n \t@p='test_xcoff_32$(EXEEXT)'; \\\n \tb='test_xcoff_32'; \\\n@@ -2083,7 +2129,8 @@ dwarf5_alloc.log: dwarf5_alloc$(EXEEXT)\n @am__EXEEXT_TRUE@\t$(am__common_driver_flags) $(AM_TEST_LOG_DRIVER_FLAGS) $(TEST_LOG_DRIVER_FLAGS) -- $(TEST_LOG_COMPILE) \\\n @am__EXEEXT_TRUE@\t\"$$tst\" $(AM_TESTS_FD_REDIRECT)\n check-am: all-am\n-\t$(MAKE) $(AM_MAKEFLAGS) $(check_LTLIBRARIES) $(check_PROGRAMS)\n+\t$(MAKE) $(AM_MAKEFLAGS) $(check_LTLIBRARIES) $(check_PROGRAMS) \\\n+\t  $(check_DATA)\n \t$(MAKE) $(AM_MAKEFLAGS) check-TESTS\n check: check-am\n all-am: Makefile $(LTLIBRARIES) config.h all-local\n@@ -2218,6 +2265,9 @@ uninstall-am:\n .PRECIOUS: Makefile\n \n \n+@HAVE_DSYMUTIL_TRUE@%.dSYM: %\n+@HAVE_DSYMUTIL_TRUE@\t$(DSYMUTIL) %<\n+\n @HAVE_ELF_TRUE@@HAVE_OBJCOPY_DEBUGLINK_TRUE@@NATIVE_TRUE@elf_for_test.c: elf.c\n @HAVE_ELF_TRUE@@HAVE_OBJCOPY_DEBUGLINK_TRUE@@NATIVE_TRUE@\tSEARCH='^#define SYSTEM_BUILD_ID_DIR.*$$'; \\\n @HAVE_ELF_TRUE@@HAVE_OBJCOPY_DEBUGLINK_TRUE@@NATIVE_TRUE@\tREPLACE=\"#define SYSTEM_BUILD_ID_DIR \\\"$(TEST_BUILD_ID_DIR)\\\"\"; \\\n@@ -2281,6 +2331,7 @@ dwarf.lo: config.h $(INCDIR)/dwarf2.h $(INCDIR)/dwarf2.def \\\n \t$(INCDIR)/filenames.h backtrace.h internal.h\n elf.lo: config.h backtrace.h internal.h\n fileline.lo: config.h backtrace.h internal.h\n+macho.lo: config.h backtrace.h internal.h\n mmap.lo: config.h backtrace.h internal.h\n mmapio.lo: config.h backtrace.h internal.h\n nounwind.lo: config.h internal.h"}, {"sha": "f6e3cba18d00e0a65a2d404a55d6ad5ba8d25208", "filename": "libbacktrace/config.h.in", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dea40c941a4d443d1b748bafb8a74f02c360e810/libbacktrace%2Fconfig.h.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dea40c941a4d443d1b748bafb8a74f02c360e810/libbacktrace%2Fconfig.h.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libbacktrace%2Fconfig.h.in?ref=dea40c941a4d443d1b748bafb8a74f02c360e810", "patch": "@@ -51,6 +51,9 @@\n /* Define to 1 if you have the `lstat' function. */\n #undef HAVE_LSTAT\n \n+/* Define to 1 if you have the <mach-o/dyld.h> header file. */\n+#undef HAVE_MACH_O_DYLD_H\n+\n /* Define to 1 if you have the <memory.h> header file. */\n #undef HAVE_MEMORY_H\n "}, {"sha": "980c9d2bf8940f6bd7b263445571becfce998bb5", "filename": "libbacktrace/configure", "status": "modified", "additions": 75, "deletions": 3, "changes": 78, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dea40c941a4d443d1b748bafb8a74f02c360e810/libbacktrace%2Fconfigure", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dea40c941a4d443d1b748bafb8a74f02c360e810/libbacktrace%2Fconfigure", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libbacktrace%2Fconfigure?ref=dea40c941a4d443d1b748bafb8a74f02c360e810", "patch": "@@ -635,6 +635,8 @@ LTLIBOBJS\n LIBOBJS\n NATIVE_FALSE\n NATIVE_TRUE\n+HAVE_DSYMUTIL_FALSE\n+HAVE_DSYMUTIL_TRUE\n HAVE_OBJCOPY_DEBUGLINK_FALSE\n HAVE_OBJCOPY_DEBUGLINK_TRUE\n READELF\n@@ -800,7 +802,8 @@ LDFLAGS\n LIBS\n CPPFLAGS\n CPP\n-OBJCOPY'\n+OBJCOPY\n+DSYMUTIL'\n \n \n # Initialize some variables set by options.\n@@ -1454,6 +1457,7 @@ Some influential environment variables:\n               you have headers in a nonstandard directory <include dir>\n   CPP         C preprocessor\n   OBJCOPY     location of objcopy\n+  DSYMUTIL    location of dsymutil\n \n Use these variables to override the choices made by `configure' or to help\n it to find libraries and programs with nonstandard names/locations.\n@@ -11499,7 +11503,7 @@ else\n   lt_dlunknown=0; lt_dlno_uscore=1; lt_dlneed_uscore=2\n   lt_status=$lt_dlunknown\n   cat > conftest.$ac_ext <<_LT_EOF\n-#line 11502 \"configure\"\n+#line 11506 \"configure\"\n #include \"confdefs.h\"\n \n #if HAVE_DLFCN_H\n@@ -11605,7 +11609,7 @@ else\n   lt_dlunknown=0; lt_dlno_uscore=1; lt_dlneed_uscore=2\n   lt_status=$lt_dlunknown\n   cat > conftest.$ac_ext <<_LT_EOF\n-#line 11608 \"configure\"\n+#line 11612 \"configure\"\n #include \"confdefs.h\"\n \n #if HAVE_DLFCN_H\n@@ -12496,6 +12500,7 @@ FORMAT_FILE=\n backtrace_supports_data=yes\n case \"$libbacktrace_cv_sys_filetype\" in\n elf*) FORMAT_FILE=\"elf.lo\" ;;\n+macho) FORMAT_FILE=\"macho.lo\" ;;\n pecoff) FORMAT_FILE=\"pecoff.lo\"\n         backtrace_supports_data=no\n \t;;\n@@ -13069,6 +13074,20 @@ $as_echo \"#define HAVE_DL_ITERATE_PHDR 1\" >>confdefs.h\n \n fi\n \n+# Check for header file for Mach-O image functions.\n+for ac_header in mach-o/dyld.h\n+do :\n+  ac_fn_c_check_header_mongrel \"$LINENO\" \"mach-o/dyld.h\" \"ac_cv_header_mach_o_dyld_h\" \"$ac_includes_default\"\n+if test \"x$ac_cv_header_mach_o_dyld_h\" = xyes; then :\n+  cat >>confdefs.h <<_ACEOF\n+#define HAVE_MACH_O_DYLD_H 1\n+_ACEOF\n+\n+fi\n+\n+done\n+\n+\n # Check for loadquery.\n for ac_header in sys/ldr.h\n do :\n@@ -13553,6 +13572,8 @@ if ${libbacktrace_cv_objcopy_debuglink+:} false; then :\n else\n   if test -n \"${with_target_subdir}\"; then\n   libbacktrace_cv_objcopy_debuglink=no\n+elif ! test -n \"${OBJCOPY}\"; then\n+  libbacktrace_cv_objcopy_debuglink=no\n elif ${OBJCOPY} --add-gnu-debuglink=x /bin/ls /tmp/ls$$; then\n   rm -f /tmp/ls$$\n   libbacktrace_cv_objcopy_debuglink=yes\n@@ -13571,6 +13592,53 @@ else\n fi\n \n \n+\n+# Extract the first word of \"dsymutil\", so it can be a program name with args.\n+set dummy dsymutil; ac_word=$2\n+{ $as_echo \"$as_me:${as_lineno-$LINENO}: checking for $ac_word\" >&5\n+$as_echo_n \"checking for $ac_word... \" >&6; }\n+if ${ac_cv_prog_DSYMUTIL+:} false; then :\n+  $as_echo_n \"(cached) \" >&6\n+else\n+  if test -n \"$DSYMUTIL\"; then\n+  ac_cv_prog_DSYMUTIL=\"$DSYMUTIL\" # Let the user override the test.\n+else\n+as_save_IFS=$IFS; IFS=$PATH_SEPARATOR\n+for as_dir in $PATH\n+do\n+  IFS=$as_save_IFS\n+  test -z \"$as_dir\" && as_dir=.\n+    for ac_exec_ext in '' $ac_executable_extensions; do\n+  if as_fn_executable_p \"$as_dir/$ac_word$ac_exec_ext\"; then\n+    ac_cv_prog_DSYMUTIL=\"dsymutil\"\n+    $as_echo \"$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext\" >&5\n+    break 2\n+  fi\n+done\n+  done\n+IFS=$as_save_IFS\n+\n+fi\n+fi\n+DSYMUTIL=$ac_cv_prog_DSYMUTIL\n+if test -n \"$DSYMUTIL\"; then\n+  { $as_echo \"$as_me:${as_lineno-$LINENO}: result: $DSYMUTIL\" >&5\n+$as_echo \"$DSYMUTIL\" >&6; }\n+else\n+  { $as_echo \"$as_me:${as_lineno-$LINENO}: result: no\" >&5\n+$as_echo \"no\" >&6; }\n+fi\n+\n+\n+ if test -n \"${DSYMUTIL}\"; then\n+  HAVE_DSYMUTIL_TRUE=\n+  HAVE_DSYMUTIL_FALSE='#'\n+else\n+  HAVE_DSYMUTIL_TRUE='#'\n+  HAVE_DSYMUTIL_FALSE=\n+fi\n+\n+\n { $as_echo \"$as_me:${as_lineno-$LINENO}: checking whether tests can run\" >&5\n $as_echo_n \"checking whether tests can run... \" >&6; }\n if ${libbacktrace_cv_sys_native+:} false; then :\n@@ -13783,6 +13851,10 @@ if test -z \"${HAVE_OBJCOPY_DEBUGLINK_TRUE}\" && test -z \"${HAVE_OBJCOPY_DEBUGLINK\n   as_fn_error $? \"conditional \\\"HAVE_OBJCOPY_DEBUGLINK\\\" was never defined.\n Usually this means the macro was only invoked conditionally.\" \"$LINENO\" 5\n fi\n+if test -z \"${HAVE_DSYMUTIL_TRUE}\" && test -z \"${HAVE_DSYMUTIL_FALSE}\"; then\n+  as_fn_error $? \"conditional \\\"HAVE_DSYMUTIL\\\" was never defined.\n+Usually this means the macro was only invoked conditionally.\" \"$LINENO\" 5\n+fi\n if test -z \"${NATIVE_TRUE}\" && test -z \"${NATIVE_FALSE}\"; then\n   as_fn_error $? \"conditional \\\"NATIVE\\\" was never defined.\n Usually this means the macro was only invoked conditionally.\" \"$LINENO\" 5"}, {"sha": "6f241c5bac09fe49b04e745ae3e2ef0f7442178a", "filename": "libbacktrace/configure.ac", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dea40c941a4d443d1b748bafb8a74f02c360e810/libbacktrace%2Fconfigure.ac", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dea40c941a4d443d1b748bafb8a74f02c360e810/libbacktrace%2Fconfigure.ac", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libbacktrace%2Fconfigure.ac?ref=dea40c941a4d443d1b748bafb8a74f02c360e810", "patch": "@@ -238,6 +238,7 @@ FORMAT_FILE=\n backtrace_supports_data=yes\n case \"$libbacktrace_cv_sys_filetype\" in\n elf*) FORMAT_FILE=\"elf.lo\" ;;\n+macho) FORMAT_FILE=\"macho.lo\" ;;\n pecoff) FORMAT_FILE=\"pecoff.lo\"\n         backtrace_supports_data=no\n \t;;\n@@ -340,6 +341,9 @@ if test \"$have_dl_iterate_phdr\" = \"yes\"; then\n   AC_DEFINE(HAVE_DL_ITERATE_PHDR, 1, [Define if dl_iterate_phdr is available.])\n fi\n \n+# Check for header file for Mach-O image functions.\n+AC_CHECK_HEADERS(mach-o/dyld.h)\n+\n # Check for loadquery.\n AC_CHECK_HEADERS(sys/ldr.h)\n if test \"$ac_cv_header_sys_ldr_h\" = \"no\"; then\n@@ -483,6 +487,8 @@ AC_CACHE_CHECK([whether objcopy supports debuglink],\n [libbacktrace_cv_objcopy_debuglink],\n [if test -n \"${with_target_subdir}\"; then\n   libbacktrace_cv_objcopy_debuglink=no\n+elif ! test -n \"${OBJCOPY}\"; then\n+  libbacktrace_cv_objcopy_debuglink=no\n elif ${OBJCOPY} --add-gnu-debuglink=x /bin/ls /tmp/ls$$; then\n   rm -f /tmp/ls$$\n   libbacktrace_cv_objcopy_debuglink=yes\n@@ -491,6 +497,10 @@ else\n fi])\n AM_CONDITIONAL(HAVE_OBJCOPY_DEBUGLINK, test \"$libbacktrace_cv_objcopy_debuglink\" = yes)\n \n+AC_ARG_VAR(DSYMUTIL, [location of dsymutil])\n+AC_CHECK_PROG(DSYMUTIL, dsymutil, dsymutil)\n+AM_CONDITIONAL(HAVE_DSYMUTIL, test -n \"${DSYMUTIL}\")\n+\n AC_CACHE_CHECK([whether tests can run],\n   [libbacktrace_cv_sys_native],\n   [AC_RUN_IFELSE([AC_LANG_PROGRAM([], [return 0;])],"}, {"sha": "14d91581f7e79f3b22f3676a1da912a6c722973a", "filename": "libbacktrace/filetype.awk", "status": "modified", "additions": 12, "deletions": 7, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dea40c941a4d443d1b748bafb8a74f02c360e810/libbacktrace%2Ffiletype.awk", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dea40c941a4d443d1b748bafb8a74f02c360e810/libbacktrace%2Ffiletype.awk", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libbacktrace%2Ffiletype.awk?ref=dea40c941a4d443d1b748bafb8a74f02c360e810", "patch": "@@ -1,8 +1,13 @@\n # An awk script to determine the type of a file.\n-/\\177ELF\\001/ { if (NR == 1) { print \"elf32\"; exit } }\n-/\\177ELF\\002/ { if (NR == 1) { print \"elf64\"; exit } }\n-/\\114\\001/    { if (NR == 1) { print \"pecoff\"; exit } }\n-/\\144\\206/    { if (NR == 1) { print \"pecoff\"; exit } }\n-/\\001\\337/    { if (NR == 1) { print \"xcoff32\"; exit } }\n-/\\001\\367/    { if (NR == 1) { print \"xcoff64\"; exit } }\n-\n+/\\177ELF\\001/      { if (NR == 1) { print \"elf32\"; exit } }\n+/\\177ELF\\002/      { if (NR == 1) { print \"elf64\"; exit } }\n+/\\114\\001/         { if (NR == 1) { print \"pecoff\"; exit } }\n+/\\144\\206/         { if (NR == 1) { print \"pecoff\"; exit } }\n+/\\001\\337/         { if (NR == 1) { print \"xcoff32\"; exit } }\n+/\\001\\367/         { if (NR == 1) { print \"xcoff64\"; exit } }\n+/\\376\\355\\372\\316/ { if (NR == 1) { print \"macho\"; exit } }\n+/\\316\\372\\355\\376/ { if (NR == 1) { print \"macho\"; exit } }\n+/\\376\\355\\372\\317/ { if (NR == 1) { print \"macho\"; exit } }\n+/\\317\\372\\355\\376/ { if (NR == 1) { print \"macho\"; exit } }\n+/\\312\\376\\272\\276/ { if (NR == 1) { print \"macho\"; exit } }\n+/\\276\\272\\376\\312/ { if (NR == 1) { print \"macho\"; exit } }"}, {"sha": "3aea70cdbbe9cde5306444b036bedd1336eea3a6", "filename": "libbacktrace/macho.c", "status": "added", "additions": 1309, "deletions": 0, "changes": 1309, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dea40c941a4d443d1b748bafb8a74f02c360e810/libbacktrace%2Fmacho.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dea40c941a4d443d1b748bafb8a74f02c360e810/libbacktrace%2Fmacho.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libbacktrace%2Fmacho.c?ref=dea40c941a4d443d1b748bafb8a74f02c360e810", "patch": "@@ -0,0 +1,1309 @@\n+/* elf.c -- Get debug data from a Mach-O file for backtraces.\n+   Copyright (C) 2020 Free Software Foundation, Inc.\n+   Written by Ian Lance Taylor, Google.\n+\n+Redistribution and use in source and binary forms, with or without\n+modification, are permitted provided that the following conditions are\n+met:\n+\n+    (1) Redistributions of source code must retain the above copyright\n+    notice, this list of conditions and the following disclaimer.\n+\n+    (2) Redistributions in binary form must reproduce the above copyright\n+    notice, this list of conditions and the following disclaimer in\n+    the documentation and/or other materials provided with the\n+    distribution.\n+\n+    (3) The name of the author may not be used to\n+    endorse or promote products derived from this software without\n+    specific prior written permission.\n+\n+THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR\n+IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+DISCLAIMED. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT,\n+INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\n+SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)\n+HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,\n+STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING\n+IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n+POSSIBILITY OF SUCH DAMAGE.  */\n+\n+#include \"config.h\"\n+\n+#include <sys/types.h>\n+#include <dirent.h>\n+#include <stdlib.h>\n+#include <string.h>\n+\n+#ifdef HAVE_MACH_O_DYLD_H\n+#include <mach-o/dyld.h>\n+#endif\n+\n+#include \"backtrace.h\"\n+#include \"internal.h\"\n+\n+/* Mach-O file header for a 32-bit executable.  */\n+\n+struct macho_header_32\n+{\n+  uint32_t magic;\t/* Magic number (MACH_O_MAGIC_32) */\n+  uint32_t cputype;\t/* CPU type */\n+  uint32_t cpusubtype;\t/* CPU subtype */\n+  uint32_t filetype;\t/* Type of file (object, executable) */\n+  uint32_t ncmds;\t/* Number of load commands */\n+  uint32_t sizeofcmds;\t/* Total size of load commands */\n+  uint32_t flags;\t/* Flags for special features */\n+};\n+\n+/* Mach-O file header for a 64-bit executable.  */\n+\n+struct macho_header_64\n+{\n+  uint32_t magic;\t/* Magic number (MACH_O_MAGIC_64) */\n+  uint32_t cputype;\t/* CPU type */\n+  uint32_t cpusubtype;\t/* CPU subtype */\n+  uint32_t filetype;\t/* Type of file (object, executable) */\n+  uint32_t ncmds;\t/* Number of load commands */\n+  uint32_t sizeofcmds;\t/* Total size of load commands */\n+  uint32_t flags;\t/* Flags for special features */\n+  uint32_t reserved;\t/* Reserved */\n+};\n+\n+/* Mach-O file header for a fat executable.  */\n+\n+struct macho_header_fat\n+{\n+  uint32_t magic;\t/* Magic number (MACH_O_MH_MAGIC_FAT) */\n+  uint32_t nfat_arch;   /* Number of components */\n+};\n+\n+/* Values for the header magic field.  */\n+\n+#define MACH_O_MH_MAGIC_32\t0xfeedface\n+#define MACH_O_MH_MAGIC_64\t0xfeedfacf\n+#define MACH_O_MH_MAGIC_FAT\t0xcafebabe\n+#define MACH_O_MH_CIGAM_FAT\t0xbebafeca\n+\n+/* Value for the header filetype field.  */\n+\n+#define MACH_O_MH_EXECUTE\t0x02\n+#define MACH_O_MH_DYLIB\t\t0x06\n+#define MACH_O_MH_DSYM\t\t0x0a\n+\n+/* A component of a fat file.  A fat file starts with a\n+   macho_header_fat followed by nfat_arch instances of this\n+   struct.  */\n+\n+struct macho_fat_arch\n+{\n+  uint32_t cputype;\t/* CPU type */\n+  uint32_t cpusubtype;\t/* CPU subtype */\n+  uint32_t offset;\t/* File offset of this entry */\n+  uint32_t size;\t/* Size of this entry */\n+  uint32_t align;\t/* Alignment of this entry */\n+};\n+\n+/* Values for the fat_arch cputype field (and the header cputype\n+   field).  */\n+\n+#define MACH_O_CPU_ARCH_ABI64 0x01000000\n+\n+#define MACH_O_CPU_TYPE_X86 7\n+#define MACH_O_CPU_TYPE_ARM 12\n+\n+#define MACH_O_CPU_TYPE_X86_64 (MACH_O_CPU_TYPE_X86 | MACH_O_CPU_ARCH_ABI64)\n+#define MACH_O_CPU_TYPE_ARM64  (MACH_O_CPU_TYPE_ARM | MACH_O_CPU_ARCH_ABI64)\n+\n+/* The header of a load command.  */\n+\n+struct macho_load_command\n+{\n+  uint32_t cmd;\t\t/* The type of load command */\n+  uint32_t cmdsize;\t/* Size in bytes of the entire command */\n+};\n+\n+/* Values for the load_command cmd field.  */\n+\n+#define MACH_O_LC_SEGMENT\t0x01\n+#define MACH_O_LC_SYMTAB\t0x02\n+#define MACH_O_LC_SEGMENT_64\t0x19\n+#define MACH_O_LC_UUID\t\t0x1b\n+\n+/* The length of a section of segment name.  */\n+\n+#define MACH_O_NAMELEN (16)\n+\n+/* LC_SEGMENT load command.  */\n+\n+struct macho_segment_command\n+{\n+  uint32_t cmd;\t\t\t/* The type of load command (LC_SEGMENT) */\n+  uint32_t cmdsize;\t\t/* Size in bytes of the entire command */\n+  char segname[MACH_O_NAMELEN];\t/* Segment name */\n+  uint32_t vmaddr;\t\t/* Virtual memory address */\n+  uint32_t vmsize;\t\t/* Virtual memory size */\n+  uint32_t fileoff;\t\t/* Offset of data to be mapped */\n+  uint32_t filesize;\t\t/* Size of data in file */\n+  uint32_t maxprot;\t\t/* Maximum permitted virtual protection */\n+  uint32_t initprot;\t\t/* Initial virtual memory protection */\n+  uint32_t nsects;\t\t/* Number of sections in this segment */\n+  uint32_t flags;\t\t/* Flags */\n+};\n+\n+/* LC_SEGMENT_64 load command.  */\n+\n+struct macho_segment_64_command\n+{\n+  uint32_t cmd;\t\t\t/* The type of load command (LC_SEGMENT) */\n+  uint32_t cmdsize;\t\t/* Size in bytes of the entire command */\n+  char segname[MACH_O_NAMELEN];\t/* Segment name */\n+  uint64_t vmaddr;\t\t/* Virtual memory address */\n+  uint64_t vmsize;\t\t/* Virtual memory size */\n+  uint64_t fileoff;\t\t/* Offset of data to be mapped */\n+  uint64_t filesize;\t\t/* Size of data in file */\n+  uint32_t maxprot;\t\t/* Maximum permitted virtual protection */\n+  uint32_t initprot;\t\t/* Initial virtual memory protection */\n+  uint32_t nsects;\t\t/* Number of sections in this segment */\n+  uint32_t flags;\t\t/* Flags */\n+};\n+\n+/* LC_SYMTAB load command.  */\n+\n+struct macho_symtab_command\n+{\n+  uint32_t cmd;\t\t/* The type of load command (LC_SEGMENT) */\n+  uint32_t cmdsize;\t/* Size in bytes of the entire command */\n+  uint32_t symoff;\t/* File offset of symbol table */\n+  uint32_t nsyms;\t/* Number of symbols */\n+  uint32_t stroff;\t/* File offset of string table */\n+  uint32_t strsize;\t/* String table size */\n+};\n+\n+/* The length of a Mach-O uuid.  */\n+\n+#define MACH_O_UUID_LEN (16)\n+\n+/* LC_UUID load command.  */\n+\n+struct macho_uuid_command\n+{\n+  uint32_t cmd;\t\t\t\t/* Type of load command (LC_UUID) */\n+  uint32_t cmdsize;\t\t\t/* Size in bytes of command */\n+  unsigned char uuid[MACH_O_UUID_LEN];\t/* UUID */\n+};\n+\n+/* 32-bit section header within a LC_SEGMENT segment.  */\n+\n+struct macho_section\n+{\n+  char sectname[MACH_O_NAMELEN];\t/* Section name */\n+  char segment[MACH_O_NAMELEN];\t\t/* Segment of this section */\n+  uint32_t addr;\t\t\t/* Address in memory */\n+  uint32_t size;\t\t\t/* Section size */\n+  uint32_t offset;\t\t\t/* File offset */\n+  uint32_t align;\t\t\t/* Log2 of section alignment */\n+  uint32_t reloff;\t\t\t/* File offset of relocations */\n+  uint32_t nreloc;\t\t\t/* Number of relocs for this section */\n+  uint32_t flags;\t\t\t/* Flags */\n+  uint32_t reserved1;\n+  uint32_t reserved2;\n+};\n+\n+/* 64-bit section header within a LC_SEGMENT_64 segment.   */\n+\n+struct macho_section_64\n+{\n+  char sectname[MACH_O_NAMELEN];\t/* Section name */\n+  char segment[MACH_O_NAMELEN];\t\t/* Segment of this section */\n+  uint64_t addr;\t\t\t/* Address in memory */\n+  uint64_t size;\t\t\t/* Section size */\n+  uint32_t offset;\t\t\t/* File offset */\n+  uint32_t align;\t\t\t/* Log2 of section alignment */\n+  uint32_t reloff;\t\t\t/* File offset of section relocations */\n+  uint32_t nreloc;\t\t\t/* Number of relocs for this section */\n+  uint32_t flags;\t\t\t/* Flags */\n+  uint32_t reserved1;\n+  uint32_t reserved2;\n+  uint32_t reserved3;\n+};\n+\n+/* 32-bit symbol data.  */\n+\n+struct macho_nlist\n+{\n+  uint32_t n_strx;\t/* Index of name in string table */\n+  uint8_t n_type;\t/* Type flag */\n+  uint8_t n_sect;\t/* Section number */\n+  uint16_t n_desc;\t/* Stabs description field */\n+  uint32_t n_value;\t/* Value */\n+};\n+\n+/* 64-bit symbol data.  */\n+\n+struct macho_nlist_64\n+{\n+  uint32_t n_strx;\t/* Index of name in string table */\n+  uint8_t n_type;\t/* Type flag */\n+  uint8_t n_sect;\t/* Section number */\n+  uint16_t n_desc;\t/* Stabs description field */\n+  uint64_t n_value;\t/* Value */\n+};\n+\n+/* Value found in nlist n_type field.  */\n+\n+#define MACH_O_N_EXT\t0x01\t/* Extern symbol */\n+#define MACH_O_N_ABS\t0x02\t/* Absolute symbol */\n+#define MACH_O_N_SECT\t0x0e\t/* Defined in section */\n+\n+#define MACH_O_N_TYPE\t0x0e\t/* Mask for type bits */\n+#define MACH_O_N_STAB\t0xe0\t/* Stabs debugging symbol */\n+\n+/* Information we keep for a Mach-O symbol.  */\n+\n+struct macho_symbol\n+{\n+  const char *name;\t/* Symbol name */\n+  uintptr_t address;\t/* Symbol address */\n+};\n+\n+/* Information to pass to macho_syminfo.  */\n+\n+struct macho_syminfo_data\n+{\n+  struct macho_syminfo_data *next;\t/* Next module */\n+  struct macho_symbol *symbols;\t\t/* Symbols sorted by address */\n+  size_t count;\t\t\t\t/* Number of symbols */\n+};\n+\n+/* Names of sections, indexed by enum dwarf_section in internal.h.  */\n+\n+static const char * const dwarf_section_names[DEBUG_MAX] =\n+{\n+  \"__debug_info\",\n+  \"__debug_line\",\n+  \"__debug_abbrev\",\n+  \"__debug_ranges\",\n+  \"__debug_str\",\n+  \"\", /* DEBUG_ADDR */\n+  \"__debug_str_offs\",\n+  \"\", /* DEBUG_LINE_STR */\n+  \"__debug_rnglists\"\n+};\n+\n+/* Forward declaration.  */\n+\n+static int macho_add (struct backtrace_state *, const char *, int, off_t,\n+\t\t      const unsigned char *, uintptr_t, int,\n+\t\t      backtrace_error_callback, void *, fileline *, int *);\n+\n+/* A dummy callback function used when we can't find any debug info.  */\n+\n+static int\n+macho_nodebug (struct backtrace_state *state ATTRIBUTE_UNUSED,\n+\t       uintptr_t pc ATTRIBUTE_UNUSED,\n+\t       backtrace_full_callback callback ATTRIBUTE_UNUSED,\n+\t       backtrace_error_callback error_callback, void *data)\n+{\n+  error_callback (data, \"no debug info in Mach-O executable\", -1);\n+  return 0;\n+}\n+\n+/* A dummy callback function used when we can't find a symbol\n+   table.  */\n+\n+static void\n+macho_nosyms (struct backtrace_state *state ATTRIBUTE_UNUSED,\n+\t      uintptr_t addr ATTRIBUTE_UNUSED,\n+\t      backtrace_syminfo_callback callback ATTRIBUTE_UNUSED,\n+\t      backtrace_error_callback error_callback, void *data)\n+{\n+  error_callback (data, \"no symbol table in Mach-O executable\", -1);\n+}\n+\n+/* Add a single DWARF section to DWARF_SECTIONS, if we need the\n+   section.  Returns 1 on success, 0 on failure.  */\n+\n+static int\n+macho_add_dwarf_section (struct backtrace_state *state, int descriptor,\n+\t\t\t const char *sectname, uint32_t offset, uint64_t size,\n+\t\t\t backtrace_error_callback error_callback, void *data,\n+\t\t\t struct dwarf_sections *dwarf_sections)\n+{\n+  int i;\n+\n+  for (i = 0; i < (int) DEBUG_MAX; ++i)\n+    {\n+      if (dwarf_section_names[i][0] != '\\0'\n+\t  && strncmp (sectname, dwarf_section_names[i], MACH_O_NAMELEN) == 0)\n+\t{\n+\t  struct backtrace_view section_view;\n+\n+\t  /* FIXME: Perhaps it would be better to try to use a single\n+\t     view to read all the DWARF data, as we try to do for\n+\t     ELF.  */\n+\n+\t  if (!backtrace_get_view (state, descriptor, offset, size,\n+\t\t\t\t   error_callback, data, &section_view))\n+\t    return 0;\n+\t  dwarf_sections->data[i] = (const unsigned char *) section_view.data;\n+\t  dwarf_sections->size[i] = size;\n+\t  break;\n+\t}\n+    }\n+  return 1;\n+}\n+\n+/* Collect DWARF sections from a DWARF segment.  Returns 1 on success,\n+   0 on failure.  */\n+\n+static int\n+macho_add_dwarf_segment (struct backtrace_state *state, int descriptor,\n+\t\t\t off_t offset, unsigned int cmd, const char *psecs,\n+\t\t\t size_t sizesecs, unsigned int nsects,\n+\t\t\t backtrace_error_callback error_callback, void *data,\n+\t\t\t struct dwarf_sections *dwarf_sections)\n+{\n+  size_t sec_header_size;\n+  size_t secoffset;\n+  unsigned int i;\n+\n+  switch (cmd)\n+    {\n+    case MACH_O_LC_SEGMENT:\n+      sec_header_size = sizeof (struct macho_section);\n+      break;\n+    case MACH_O_LC_SEGMENT_64:\n+      sec_header_size = sizeof (struct macho_section_64);\n+      break;\n+    default:\n+      abort ();\n+    }\n+\n+  secoffset = 0;\n+  for (i = 0; i < nsects; ++i)\n+    {\n+      if (secoffset + sec_header_size > sizesecs)\n+\t{\n+\t  error_callback (data, \"section overflow withing segment\", 0);\n+\t  return 0;\n+\t}\n+\n+      switch (cmd)\n+\t{\n+\tcase MACH_O_LC_SEGMENT:\n+\t  {\n+\t    struct macho_section section;\n+\n+\t    memcpy (&section, psecs + secoffset, sizeof section);\n+\t    macho_add_dwarf_section (state, descriptor, section.sectname,\n+\t\t\t\t     offset + section.offset, section.size,\n+\t\t\t\t     error_callback, data, dwarf_sections);\n+\t  }\n+\t  break;\n+\n+\tcase MACH_O_LC_SEGMENT_64:\n+\t  {\n+\t    struct macho_section_64 section;\n+\n+\t    memcpy (&section, psecs + secoffset, sizeof section);\n+\t    macho_add_dwarf_section (state, descriptor, section.sectname,\n+\t\t\t\t     offset + section.offset, section.size,\n+\t\t\t\t     error_callback, data, dwarf_sections);\n+\t  }\n+\t  break;\n+\n+\tdefault:\n+\t  abort ();\n+\t}\n+\n+      secoffset += sec_header_size;\n+    }\n+\n+  return 1;\n+}\n+\n+/* Compare struct macho_symbol for qsort.  */\n+\n+static int\n+macho_symbol_compare (const void *v1, const void *v2)\n+{\n+  const struct macho_symbol *m1 = (const struct macho_symbol *) v1;\n+  const struct macho_symbol *m2 = (const struct macho_symbol *) v2;\n+\n+  if (m1->address < m2->address)\n+    return -1;\n+  else if (m1->address > m2->address)\n+    return 1;\n+  else\n+    return 0;\n+}\n+\n+/* Compare an address against a macho_symbol for bsearch.  We allocate\n+   one extra entry in the array so that this can safely look at the\n+   next entry.  */\n+\n+static int\n+macho_symbol_search (const void *vkey, const void *ventry)\n+{\n+  const uintptr_t *key = (const uintptr_t *) vkey;\n+  const struct macho_symbol *entry = (const struct macho_symbol *) ventry;\n+  uintptr_t addr;\n+\n+  addr = *key;\n+  if (addr < entry->address)\n+    return -1;\n+  else if (entry->name[0] == '\\0'\n+\t   && entry->address == ~(uintptr_t) 0)\n+    return -1;\n+  else if ((entry + 1)->name[0] == '\\0'\n+\t   && (entry + 1)->address == ~(uintptr_t) 0)\n+    return -1;\n+  else if (addr >= (entry + 1)->address)\n+    return 1;\n+  else\n+    return 0;\n+}\n+\n+/* Return whether the symbol type field indicates a symbol table entry\n+   that we care about: a function or data symbol.  */\n+\n+static int\n+macho_defined_symbol (uint8_t type)\n+{\n+  if ((type & MACH_O_N_STAB) != 0)\n+    return 0;\n+  if ((type & MACH_O_N_EXT) != 0)\n+    return 0;\n+  switch (type & MACH_O_N_TYPE)\n+    {\n+    case MACH_O_N_ABS:\n+      return 1;\n+    case MACH_O_N_SECT:\n+      return 1;\n+    default:\n+      return 0;\n+    }\n+}\n+\n+/* Add symbol table information for a Mach-O file.  */\n+\n+static int\n+macho_add_symtab (struct backtrace_state *state, int descriptor,\n+\t\t  uintptr_t base_address, int is_64,\n+\t\t  off_t symoff, unsigned int nsyms, off_t stroff,\n+\t\t  unsigned int strsize,\n+\t\t  backtrace_error_callback error_callback, void *data)\n+{\n+  size_t symsize;\n+  struct backtrace_view sym_view;\n+  int sym_view_valid;\n+  struct backtrace_view str_view;\n+  int str_view_valid;\n+  size_t ndefs;\n+  size_t symtaboff;\n+  unsigned int i;\n+  size_t macho_symbol_size;\n+  struct macho_symbol *macho_symbols;\n+  unsigned int j;\n+  struct macho_syminfo_data *sdata;\n+\n+  sym_view_valid = 0;\n+  str_view_valid = 0;\n+  macho_symbol_size = 0;\n+  macho_symbols = NULL;\n+\n+  if (is_64)\n+    symsize = sizeof (struct macho_nlist_64);\n+  else\n+    symsize = sizeof (struct macho_nlist);\n+\n+  if (!backtrace_get_view (state, descriptor, symoff, nsyms * symsize,\n+\t\t\t   error_callback, data, &sym_view))\n+    goto fail;\n+  sym_view_valid = 1;\n+\n+  if (!backtrace_get_view (state, descriptor, stroff, strsize,\n+\t\t\t   error_callback, data, &str_view))\n+    return 0;\n+  str_view_valid = 1;\n+\n+  ndefs = 0;\n+  symtaboff = 0;\n+  for (i = 0; i < nsyms; ++i, symtaboff += symsize)\n+    {\n+      if (is_64)\n+\t{\n+\t  struct macho_nlist_64 nlist;\n+\n+\t  memcpy (&nlist, (const char *) sym_view.data + symtaboff,\n+\t\t  sizeof nlist);\n+\t  if (macho_defined_symbol (nlist.n_type))\n+\t    ++ndefs;\n+\t}\n+      else\n+\t{\n+\t  struct macho_nlist nlist;\n+\n+\t  memcpy (&nlist, (const char *) sym_view.data + symtaboff,\n+\t\t  sizeof nlist);\n+\t  if (macho_defined_symbol (nlist.n_type))\n+\t    ++ndefs;\n+\t}\n+    }\n+\n+  /* Add 1 to ndefs to make room for a sentinel.  */\n+  macho_symbol_size = (ndefs + 1) * sizeof (struct macho_symbol);\n+  macho_symbols = ((struct macho_symbol *)\n+\t\t   backtrace_alloc (state, macho_symbol_size, error_callback,\n+\t\t\t\t    data));\n+  if (macho_symbols == NULL)\n+    goto fail;\n+\n+  j = 0;\n+  symtaboff = 0;\n+  for (i = 0; i < nsyms; ++i, symtaboff += symsize)\n+    {\n+      uint32_t strx;\n+      uint64_t value;\n+      const char *name;\n+\n+      strx = 0;\n+      value = 0;\n+      if (is_64)\n+\t{\n+\t  struct macho_nlist_64 nlist;\n+\n+\t  memcpy (&nlist, (const char *) sym_view.data + symtaboff,\n+\t\t  sizeof nlist);\n+\t  if (!macho_defined_symbol (nlist.n_type))\n+\t    continue;\n+\n+\t  strx = nlist.n_strx;\n+\t  value = nlist.n_value;\n+\t}\n+      else\n+\t{\n+\t  struct macho_nlist nlist;\n+\n+\t  memcpy (&nlist, (const char *) sym_view.data + symtaboff,\n+\t\t  sizeof nlist);\n+\t  if (!macho_defined_symbol (nlist.n_type))\n+\t    continue;\n+\n+\t  strx = nlist.n_strx;\n+\t  value = nlist.n_value;\n+\t}\n+\n+      if (strx >= strsize)\n+\t{\n+\t  error_callback (data, \"symbol string index out of range\", 0);\n+\t  goto fail;\n+\t}\n+\n+      name = (const char *) str_view.data + strx;\n+      if (name[0] == '_')\n+\t++name;\n+      macho_symbols[j].name = name;\n+      macho_symbols[j].address = value + base_address;\n+      ++j;\n+    }\n+\n+  sdata = ((struct macho_syminfo_data *)\n+\t   backtrace_alloc (state, sizeof *sdata, error_callback, data));\n+  if (sdata == NULL)\n+    goto fail;\n+\n+  /* We need to keep the string table since it holds the names, but we\n+     can release the symbol table.  */\n+\n+  backtrace_release_view (state, &sym_view, error_callback, data);\n+  sym_view_valid = 0;\n+  str_view_valid = 0;\n+\n+  /* Add a trailing sentinel symbol.  */\n+  macho_symbols[j].name = \"\";\n+  macho_symbols[j].address = ~(uintptr_t) 0;\n+\n+  backtrace_qsort (macho_symbols, ndefs + 1, sizeof (struct macho_symbol),\n+\t\t   macho_symbol_compare);\n+\n+  sdata->next = NULL;\n+  sdata->symbols = macho_symbols;\n+  sdata->count = ndefs;\n+\n+  if (!state->threaded)\n+    {\n+      struct macho_syminfo_data **pp;\n+\n+      for (pp = (struct macho_syminfo_data **) (void *) &state->syminfo_data;\n+\t   *pp != NULL;\n+\t   pp = &(*pp)->next)\n+\t;\n+      *pp = sdata;\n+    }\n+  else\n+    {\n+      while (1)\n+\t{\n+\t  struct macho_syminfo_data **pp;\n+\n+\t  pp = (struct macho_syminfo_data **) (void *) &state->syminfo_data;\n+\n+\t  while (1)\n+\t    {\n+\t      struct macho_syminfo_data *p;\n+\n+\t      p = backtrace_atomic_load_pointer (pp);\n+\t      \n+\t      if (p == NULL)\n+\t\tbreak;\n+\n+\t      pp = &p->next;\n+\t    }\n+\n+\t  if (__sync_bool_compare_and_swap (pp, NULL, sdata))\n+\t    break;\n+\t}\n+    }\n+\n+  return 1;\n+\n+ fail:\n+  if (macho_symbols != NULL)\n+    backtrace_free (state, macho_symbols, macho_symbol_size,\n+\t\t    error_callback, data);\n+  if (sym_view_valid)\n+    backtrace_release_view (state, &sym_view, error_callback, data);\n+  if (str_view_valid)\n+    backtrace_release_view (state, &str_view, error_callback, data);\n+  return 0;\n+}\n+\n+/* Return the symbol name and value for an ADDR.  */\n+\n+static void\n+macho_syminfo (struct backtrace_state *state, uintptr_t addr,\n+\t       backtrace_syminfo_callback callback,\n+\t       backtrace_error_callback error_callback ATTRIBUTE_UNUSED,\n+\t       void *data)\n+{\n+  struct macho_syminfo_data *sdata;\n+  struct macho_symbol *sym;\n+\n+  sym = NULL;\n+  if (!state->threaded)\n+    {\n+      for (sdata = (struct macho_syminfo_data *) state->syminfo_data;\n+\t   sdata != NULL;\n+\t   sdata = sdata->next)\n+\t{\n+\t  sym = ((struct macho_symbol *)\n+\t\t bsearch (&addr, sdata->symbols, sdata->count,\n+\t\t\t  sizeof (struct macho_symbol), macho_symbol_search));\n+\t  if (sym != NULL)\n+\t    break;\n+\t}\n+    }\n+  else\n+    {\n+      struct macho_syminfo_data **pp;\n+\n+      pp = (struct macho_syminfo_data **) (void *) &state->syminfo_data;\n+      while (1)\n+\t{\n+\t  sdata = backtrace_atomic_load_pointer (pp);\n+\t  if (sdata == NULL)\n+\t    break;\n+\n+\t  sym = ((struct macho_symbol *)\n+\t\t bsearch (&addr, sdata->symbols, sdata->count,\n+\t\t\t  sizeof (struct macho_symbol), macho_symbol_search));\n+\t  if (sym != NULL)\n+\t    break;\n+\n+\t  pp = &sdata->next;\n+\t}\n+    }\n+\n+  if (sym == NULL)\n+    callback (data, addr, NULL, 0, 0);\n+  else\n+    callback (data, addr, sym->name, sym->address, 0);\n+}\n+\n+/* Look through a fat file to find the relevant executable.  Returns 1\n+   on success, 0 on failure (in both cases descriptor is closed).  */\n+\n+static int\n+macho_add_fat (struct backtrace_state *state, const char *filename,\n+\t       int descriptor, int swapped, off_t offset,\n+\t       const unsigned char *match_uuid, uintptr_t base_address,\n+\t       int skip_symtab, uint32_t nfat_arch,\n+\t       backtrace_error_callback error_callback, void *data,\n+\t       fileline *fileline_fn, int *found_sym)\n+{\n+  int arch_view_valid;\n+  unsigned int cputype;\n+  struct backtrace_view arch_view;\n+  size_t archoffset;\n+  unsigned int i;\n+\n+  arch_view_valid = 0;\n+\n+#if defined (__x86_64__)\n+  cputype = MACH_O_CPU_TYPE_X86_64;\n+#elif defined (__i386__)\n+  cputype = MACH_O_CPU_TYPE_X86;\n+#elif defined (__aarch64__)\n+  cputype = MACH_O_CPU_TYPE_ARM64;\n+#elif defined (__arm__)\n+  cputype = MACH_O_CPU_TYPE_ARM;\n+#else\n+  error_callback (data, \"unknown Mach-O architecture\", 0);\n+  goto fail;\n+#endif\n+\n+  if (!backtrace_get_view (state, descriptor, offset,\n+\t\t\t   nfat_arch * sizeof (struct macho_fat_arch),\n+\t\t\t   error_callback, data, &arch_view))\n+    goto fail;\n+\n+  archoffset = 0;\n+  for (i = 0; i < nfat_arch; ++i)\n+    {\n+      struct macho_fat_arch fat_arch;\n+      uint32_t fcputype;\n+\n+      memcpy (&fat_arch,\n+\t      ((const char *) arch_view.data\n+\t       + i * sizeof (struct macho_fat_arch)),\n+\t      sizeof fat_arch);\n+\n+      fcputype = fat_arch.cputype;\n+      if (swapped)\n+\tfcputype = __builtin_bswap32 (fcputype);\n+\n+      if (fcputype == cputype)\n+\t{\n+\t  uint32_t foffset;\n+\n+\t  /* FIXME: What about cpusubtype?  */\n+\t  foffset = fat_arch.offset;\n+\t  if (swapped)\n+\t    foffset = __builtin_bswap32 (foffset);\n+\t  backtrace_release_view (state, &arch_view, error_callback, data);\n+\t  return macho_add (state, filename, descriptor, foffset, match_uuid,\n+\t\t\t    base_address, skip_symtab, error_callback, data,\n+\t\t\t    fileline_fn, found_sym);\n+\t}\n+\n+      archoffset += sizeof (struct macho_fat_arch);\n+    }\n+\n+  error_callback (data, \"could not find executable in fat file\", 0);\n+\n+ fail:\n+  if (arch_view_valid)\n+    backtrace_release_view (state, &arch_view, error_callback, data);\n+  if (descriptor != -1)\n+    backtrace_close (descriptor, error_callback, data);\n+  return 0;\n+}\n+\n+/* Look for the dsym file for FILENAME.  This is called if FILENAME\n+   does not have debug info or a symbol table.  Returns 1 on success,\n+   0 on failure.  */\n+\n+static int\n+macho_add_dsym (struct backtrace_state *state, const char *filename,\n+\t\tuintptr_t base_address, const unsigned char *uuid,\n+\t\tbacktrace_error_callback error_callback, void *data,\n+\t\tfileline* fileline_fn)\n+{\n+  const char *p;\n+  const char *dirname;\n+  char *diralc;\n+  size_t dirnamelen;\n+  const char *basename;\n+  size_t basenamelen;\n+  const char *dsymsuffixdir;\n+  size_t dsymsuffixdirlen;\n+  size_t dsymlen;\n+  char *dsym;\n+  char *ps;\n+  int d;\n+  int does_not_exist;\n+  int dummy_found_sym;\n+\n+  diralc = NULL;\n+  dirnamelen = 0;\n+  dsym = NULL;\n+  dsymlen = 0;\n+\n+  p = strrchr (filename, '/');\n+  if (p == NULL)\n+    {\n+      dirname = \".\";\n+      dirnamelen = 1;\n+      basename = filename;\n+      basenamelen = strlen (basename);\n+      diralc = NULL;\n+    }\n+  else\n+    {\n+      dirnamelen = p - filename;\n+      diralc = backtrace_alloc (state, dirnamelen + 1, error_callback, data);\n+      if (diralc == NULL)\n+\tgoto fail;\n+      memcpy (diralc, filename, dirnamelen);\n+      diralc[dirnamelen] = '\\0';\n+      dirname = diralc;\n+      basename = p + 1;\n+      basenamelen = strlen (basename);\n+    }\n+\n+  dsymsuffixdir = \".dSYM/Contents/Resources/DWARF/\";\n+  dsymsuffixdirlen = strlen (dsymsuffixdir);\n+\n+  dsymlen = (dirnamelen\n+\t     + basenamelen\n+\t     + dsymsuffixdirlen\n+\t     + basenamelen\n+\t     + 1);\n+  dsym = backtrace_alloc (state, dsymlen, error_callback, data);\n+  if (dsym == NULL)\n+    goto fail;\n+\n+  ps = dsym;\n+  memcpy (ps, dirname, dirnamelen);\n+  ps += dirnamelen;\n+  *ps++ = '/';\n+  memcpy (ps, basename, basenamelen);\n+  ps += basenamelen;\n+  memcpy (ps, dsymsuffixdir, dsymsuffixdirlen);\n+  ps += dsymsuffixdirlen;\n+  memcpy (ps, basename, basenamelen);\n+  ps += basenamelen;\n+  *ps = '\\0';\n+\n+  if (diralc != NULL)\n+    {\n+      backtrace_free (state, diralc, dirnamelen, error_callback, data);\n+      diralc = NULL;\n+    }\n+\n+  d = backtrace_open (dsym, error_callback, data, &does_not_exist);\n+  if (d < 0)\n+    {\n+      /* The file does not exist, so we can't read the debug info.\n+\t Just return success.  */\n+      backtrace_free (state, dsym, dsymlen, error_callback, data);\n+      return 1;\n+    }\n+\n+  if (!macho_add (state, dsym, d, 0, uuid, base_address, 1,\n+\t\t  error_callback, data, fileline_fn, &dummy_found_sym))\n+    goto fail;\n+\n+  backtrace_free (state, dsym, dsymlen, error_callback, data);\n+\n+  return 1;\n+\n+ fail:\n+  if (dsym != NULL)\n+    backtrace_free (state, dsym, dsymlen, error_callback, data);\n+  if (diralc != NULL)\n+    backtrace_free (state, diralc, dirnamelen, error_callback, data);\n+  return 0;\n+}\n+\n+/* Add the backtrace data for a Macho-O file.  Returns 1 on success, 0\n+   on failure (in both cases descriptor is closed).\n+\n+   FILENAME: the name of the executable.\n+   DESCRIPTOR: an open descriptor for the executable, closed here.\n+   OFFSET: the offset within the file of this executable, for fat files.\n+   MATCH_UUID: if not NULL, UUID that must match.\n+   BASE_ADDRESS: the load address of the executable.\n+   SKIP_SYMTAB: if non-zero, ignore the symbol table; used for dSYM files.\n+   FILELINE_FN: set to the fileline function, by backtrace_dwarf_add.\n+   FOUND_SYM: set to non-zero if we found the symbol table.\n+*/\n+\n+static int\n+macho_add (struct backtrace_state *state, const char *filename, int descriptor,\n+\t   off_t offset, const unsigned char *match_uuid,\n+\t   uintptr_t base_address, int skip_symtab,\n+\t   backtrace_error_callback error_callback, void *data,\n+\t   fileline *fileline_fn, int *found_sym)\n+{\n+  struct backtrace_view header_view;\n+  struct macho_header_32 header;\n+  off_t hdroffset;\n+  int is_64;\n+  struct backtrace_view cmds_view;\n+  int cmds_view_valid;\n+  struct dwarf_sections dwarf_sections;\n+  int have_dwarf;\n+  unsigned char uuid[MACH_O_UUID_LEN];\n+  int have_uuid;\n+  size_t cmdoffset;\n+  unsigned int i;\n+\n+  *found_sym = 0;\n+\n+  cmds_view_valid = 0;\n+\n+  /* The 32-bit and 64-bit file headers start out the same, so we can\n+     just always read the 32-bit version.  A fat header is shorter but\n+     it will always be followed by data, so it's OK to read extra.  */\n+\n+  if (!backtrace_get_view (state, descriptor, offset,\n+\t\t\t   sizeof (struct macho_header_32),\n+\t\t\t   error_callback, data, &header_view))\n+    goto fail;\n+\n+  memcpy (&header, header_view.data, sizeof header);\n+\n+  backtrace_release_view (state, &header_view, error_callback, data);\n+\n+  switch (header.magic)\n+    {\n+    case MACH_O_MH_MAGIC_32:\n+      is_64 = 0;\n+      hdroffset = offset + sizeof (struct macho_header_32);\n+      break;\n+    case MACH_O_MH_MAGIC_64:\n+      is_64 = 1;\n+      hdroffset = offset + sizeof (struct macho_header_64);\n+      break;\n+    case MACH_O_MH_MAGIC_FAT:\n+      {\n+\tstruct macho_header_fat fat_header;\n+\n+\thdroffset = offset + sizeof (struct macho_header_fat);\n+\tmemcpy (&fat_header, &header, sizeof fat_header);\n+\treturn macho_add_fat (state, filename, descriptor, 0, hdroffset,\n+\t\t\t      match_uuid, base_address, skip_symtab,\n+\t\t\t      fat_header.nfat_arch, error_callback, data,\n+\t\t\t      fileline_fn, found_sym);\n+      }\n+    case MACH_O_MH_CIGAM_FAT:\n+      {\n+\tstruct macho_header_fat fat_header;\n+\tuint32_t nfat_arch;\n+\n+\thdroffset = offset + sizeof (struct macho_header_fat);\n+\tmemcpy (&fat_header, &header, sizeof fat_header);\n+\tnfat_arch = __builtin_bswap32 (fat_header.nfat_arch);\n+\treturn macho_add_fat (state, filename, descriptor, 1, hdroffset,\n+\t\t\t      match_uuid, base_address, skip_symtab,\n+\t\t\t      nfat_arch, error_callback, data,\n+\t\t\t      fileline_fn, found_sym);\n+      }\n+    default:\n+      error_callback (data, \"executable file is not in Mach-O format\", 0);\n+      goto fail;\n+    }\n+\n+  switch (header.filetype)\n+    {\n+    case MACH_O_MH_EXECUTE:\n+    case MACH_O_MH_DYLIB:\n+    case MACH_O_MH_DSYM:\n+      break;\n+    default:\n+      error_callback (data, \"executable file is not an executable\", 0);\n+      goto fail;\n+    }\n+\n+  if (!backtrace_get_view (state, descriptor, hdroffset, header.sizeofcmds,\n+\t\t\t   error_callback, data, &cmds_view))\n+    goto fail;\n+  cmds_view_valid = 1;\n+\n+  memset (&dwarf_sections, 0, sizeof dwarf_sections);\n+  have_dwarf = 0;\n+  memset (&uuid, 0, sizeof uuid);\n+  have_uuid = 0;\n+\n+  cmdoffset = 0;\n+  for (i = 0; i < header.ncmds; ++i)\n+    {\n+      const char *pcmd;\n+      struct macho_load_command load_command;\n+\n+      if (cmdoffset + sizeof load_command > header.sizeofcmds)\n+\tbreak;\n+\n+      pcmd = (const char *) cmds_view.data + cmdoffset;\n+      memcpy (&load_command, pcmd, sizeof load_command);\n+\n+      switch (load_command.cmd)\n+\t{\n+\tcase MACH_O_LC_SEGMENT:\n+\t  {\n+\t    struct macho_segment_command segcmd;\n+\n+\t    memcpy (&segcmd, pcmd, sizeof segcmd);\n+\t    if (memcmp (segcmd.segname,\n+\t\t\t\"__DWARF\\0\\0\\0\\0\\0\\0\\0\\0\\0\",\n+\t\t\tMACH_O_NAMELEN) == 0)\n+\t      {\n+\t\tif (!macho_add_dwarf_segment (state, descriptor, offset,\n+\t\t\t\t\t      load_command.cmd,\n+\t\t\t\t\t      pcmd + sizeof segcmd,\n+\t\t\t\t\t      (load_command.cmdsize\n+\t\t\t\t\t       - sizeof segcmd),\n+\t\t\t\t\t      segcmd.nsects, error_callback,\n+\t\t\t\t\t      data, &dwarf_sections))\n+\t\t  goto fail;\n+\t\thave_dwarf = 1;\n+\t      }\n+\t  }\n+\t  break;\n+\n+\tcase MACH_O_LC_SEGMENT_64:\n+\t  {\n+\t    struct macho_segment_64_command segcmd;\n+\n+\t    memcpy (&segcmd, pcmd, sizeof segcmd);\n+\t    if (memcmp (segcmd.segname,\n+\t\t\t\"__DWARF\\0\\0\\0\\0\\0\\0\\0\\0\\0\",\n+\t\t\tMACH_O_NAMELEN) == 0)\n+\t      {\n+\t\tif (!macho_add_dwarf_segment (state, descriptor, offset,\n+\t\t\t\t\t      load_command.cmd,\n+\t\t\t\t\t      pcmd + sizeof segcmd,\n+\t\t\t\t\t      (load_command.cmdsize\n+\t\t\t\t\t       - sizeof segcmd),\n+\t\t\t\t\t      segcmd.nsects, error_callback,\n+\t\t\t\t\t      data, &dwarf_sections))\n+\t\t  goto fail;\n+\t\thave_dwarf = 1;\n+\t      }\n+\t  }\n+\t  break;\n+\n+\tcase MACH_O_LC_SYMTAB:\n+\t  if (!skip_symtab)\n+\t    {\n+\t      struct macho_symtab_command symcmd;\n+\n+\t      memcpy (&symcmd, pcmd, sizeof symcmd);\n+\t      if (!macho_add_symtab (state, descriptor, base_address, is_64,\n+\t\t\t\t     offset + symcmd.symoff, symcmd.nsyms,\n+\t\t\t\t     offset + symcmd.stroff, symcmd.strsize,\n+\t\t\t\t     error_callback, data))\n+\t\tgoto fail;\n+\n+\t      *found_sym = 1;\n+\t    }\n+\t  break;\n+\n+\tcase MACH_O_LC_UUID:\n+\t  {\n+\t    struct macho_uuid_command uuidcmd;\n+\n+\t    memcpy (&uuidcmd, pcmd, sizeof uuidcmd);\n+\t    memcpy (&uuid[0], &uuidcmd.uuid[0], MACH_O_UUID_LEN);\n+\t    have_uuid = 1;\n+\t  }\n+\t  break;\n+\n+\tdefault:\n+\t  break;\n+\t}\n+\n+      cmdoffset += load_command.cmdsize;\n+    }\n+\n+  if (!backtrace_close (descriptor, error_callback, data))\n+    goto fail;\n+  descriptor = -1;\n+\n+  backtrace_release_view (state, &cmds_view, error_callback, data);\n+  cmds_view_valid = 0;\n+\n+  if (match_uuid != NULL)\n+    {\n+      /* If we don't have a UUID, or it doesn't match, just ignore\n+\t this file.  */\n+      if (!have_uuid\n+\t  || memcmp (match_uuid, &uuid[0], MACH_O_UUID_LEN) != 0)\n+\treturn 1;\n+    }\n+\n+  if (have_dwarf)\n+    {\n+      int is_big_endian;\n+\n+      is_big_endian = 0;\n+#if defined(__BYTE_ORDER__) && defined(__ORDER_BIG_ENDIAN__)\n+#if __BYTE_ORDER__ == __ORDER_BIG_ENDIAN__\n+      is_big_endian = 1;\n+#endif\n+#endif\n+\n+      if (!backtrace_dwarf_add (state, base_address, &dwarf_sections,\n+\t\t\t\tis_big_endian, NULL, error_callback, data,\n+\t\t\t\tfileline_fn, NULL))\n+\tgoto fail;\n+    }\n+\n+  if (!have_dwarf && have_uuid)\n+    {\n+      if (!macho_add_dsym (state, filename, base_address, &uuid[0],\n+\t\t\t   error_callback, data, fileline_fn))\n+\tgoto fail;\n+    }\n+\n+  return 1;\n+\n+ fail:\n+  if (cmds_view_valid)\n+    backtrace_release_view (state, &cmds_view, error_callback, data);\n+  if (descriptor != -1)\n+    backtrace_close (descriptor, error_callback, data);\n+  return 0;\n+}\n+\n+#ifdef HAVE_MACH_O_DYLD_H\n+\n+/* Initialize the backtrace data we need from a Mach-O executable\n+   using the dyld support functions.  This closes descriptor.  */\n+\n+int\n+backtrace_initialize (struct backtrace_state *state, const char *filename,\n+\t\t      int descriptor, backtrace_error_callback error_callback,\n+\t\t      void *data, fileline *fileline_fn)\n+{\n+  uint32_t c;\n+  uint32_t i;\n+  int closed_descriptor;\n+  int found_sym;\n+  fileline macho_fileline_fn;\n+\n+  closed_descriptor = 0;\n+  found_sym = 0;\n+  macho_fileline_fn = macho_nodebug;\n+\n+  c = _dyld_image_count ();\n+  for (i = 0; i < c; ++i)\n+    {\n+      uintptr_t base_address;\n+      const char *name;\n+      int d;\n+      fileline mff;\n+      int mfs;\n+\n+      name = _dyld_get_image_name (i);\n+      if (name == NULL)\n+\tcontinue;\n+\n+      if (strcmp (name, filename) == 0 && !closed_descriptor)\n+\t{\n+\t  d = descriptor;\n+\t  closed_descriptor = 1;\n+\t}\n+      else\n+\t{\n+\t  int does_not_exist;\n+\n+\t  d = backtrace_open (name, error_callback, data, &does_not_exist);\n+\t  if (d < 0)\n+\t    continue;\n+\t}\n+\n+      base_address = _dyld_get_image_vmaddr_slide (i);\n+\n+      mff = macho_nodebug;\n+      if (!macho_add (state, name, d, 0, NULL, base_address, 0,\n+\t\t      error_callback, data, &mff, &mfs))\n+\treturn 0;\n+\n+      if (mff != macho_nodebug)\n+\tmacho_fileline_fn = mff;\n+      if (mfs)\n+\tfound_sym = 1;\n+    }\n+\n+  if (!closed_descriptor)\n+    backtrace_close (descriptor, error_callback, data);\n+\n+  if (!state->threaded)\n+    {\n+      if (found_sym)\n+\tstate->syminfo_fn = macho_syminfo;\n+      else if (state->syminfo_fn == NULL)\n+\tstate->syminfo_fn = macho_nosyms;\n+    }\n+  else\n+    {\n+      if (found_sym)\n+\tbacktrace_atomic_store_pointer (&state->syminfo_fn, macho_syminfo);\n+      else\n+\t(void) __sync_bool_compare_and_swap (&state->syminfo_fn, NULL,\n+\t\t\t\t\t     macho_nosyms);\n+    }\n+\n+  if (!state->threaded)\n+    *fileline_fn = state->fileline_fn;\n+  else\n+    *fileline_fn = backtrace_atomic_load_pointer (&state->fileline_fn);\n+\n+  if (*fileline_fn == NULL || *fileline_fn == macho_nodebug)\n+    *fileline_fn = macho_fileline_fn;\n+\n+  return 1;\n+}\n+\n+#else /* !defined (HAVE_MACH_O_DYLD_H) */\n+\n+/* Initialize the backtrace data we need from a Mach-O executable\n+   without using the dyld support functions.  This closes\n+   descriptor.  */\n+\n+int\n+backtrace_initialize (struct backtrace_state *state, const char *filename,\n+\t\t      int descriptor, backtrace_error_callback error_callback,\n+\t\t      void *data, fileline *fileline_fn)\n+{\n+  fileline macho_fileline_fn;\n+  int found_sym;\n+\n+  macho_fileline_fn = macho_nodebug;\n+  if (!macho_add (state, filename, descriptor, 0, NULL, 0, 0,\n+\t\t  error_callback, data, &macho_fileline_fn, &found_sym))\n+    return 0;\n+\n+  if (!state->threaded)\n+    {\n+      if (found_sym)\n+\tstate->syminfo_fn = macho_syminfo;\n+      else if (state->syminfo_fn == NULL)\n+\tstate->syminfo_fn = macho_nosyms;\n+    }\n+  else\n+    {\n+      if (found_sym)\n+\tbacktrace_atomic_store_pointer (&state->syminfo_fn, macho_syminfo);\n+      else\n+\t(void) __sync_bool_compare_and_swap (&state->syminfo_fn, NULL,\n+\t\t\t\t\t     macho_nosyms);\n+    }\n+\n+  if (!state->threaded)\n+    *fileline_fn = state->fileline_fn;\n+  else\n+    *fileline_fn = backtrace_atomic_load_pointer (&state->fileline_fn);\n+\n+  if (*fileline_fn == NULL || *fileline_fn == macho_nodebug)\n+    *fileline_fn = macho_fileline_fn;\n+\n+  return 1;\n+}\n+\n+#endif /* !defined (HAVE_MACH_O_DYLD_H) */"}]}