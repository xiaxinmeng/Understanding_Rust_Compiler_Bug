{"sha": "fc84e8a81c6e02906f467755cca9789200251d36", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZmM4NGU4YTgxYzZlMDI5MDZmNDY3NzU1Y2NhOTc4OTIwMDI1MWQzNg==", "commit": {"author": {"name": "Richard Stallman", "email": "rms@gnu.org", "date": "1993-07-15T02:20:05Z"}, "committer": {"name": "Richard Stallman", "email": "rms@gnu.org", "date": "1993-07-15T02:20:05Z"}, "message": "(gen_lowpart_common, gen_highpart): Handle CONCAT.\n\n(operand_subword): Likewise.\n(gen_reg_rtx): For complex mode, return a CONCAT of two pseudos.\n\nFrom-SVN: r4923", "tree": {"sha": "8bf097593aff382e9978b4983cf88e0e078f0ee0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8bf097593aff382e9978b4983cf88e0e078f0ee0"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/fc84e8a81c6e02906f467755cca9789200251d36", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fc84e8a81c6e02906f467755cca9789200251d36", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fc84e8a81c6e02906f467755cca9789200251d36", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fc84e8a81c6e02906f467755cca9789200251d36/comments", "author": null, "committer": null, "parents": [{"sha": "5998c7dcc3c8f1c1825d3c8dc61aec0279bb540c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5998c7dcc3c8f1c1825d3c8dc61aec0279bb540c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5998c7dcc3c8f1c1825d3c8dc61aec0279bb540c"}], "stats": {"total": 42, "additions": 41, "deletions": 1}, "files": [{"sha": "04b9069ea58a968d89a94366674bb9e6e1122f17", "filename": "gcc/emit-rtl.c", "status": "modified", "additions": 41, "deletions": 1, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fc84e8a81c6e02906f467755cca9789200251d36/gcc%2Femit-rtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fc84e8a81c6e02906f467755cca9789200251d36/gcc%2Femit-rtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Femit-rtl.c?ref=fc84e8a81c6e02906f467755cca9789200251d36", "patch": "@@ -402,6 +402,27 @@ gen_reg_rtx (mode)\n   if (reload_in_progress || reload_completed)\n     abort ();\n \n+  if (GET_MODE_CLASS (mode) == MODE_COMPLEX_FLOAT\n+      || GET_MODE_CLASS (mode) == MODE_COMPLEX_INT)\n+    {\n+      /* For complex modes, don't make a single pseudo.\n+\t Instead, make a CONCAT of two pseudos.\n+\t This allows noncontiguous allocation of the real and imaginary parts,\n+\t which makes much better code.  Besides, allocating DCmode\n+\t pseudos overstrains reload on some machines like the 386.  */\n+      rtx realpart, imagpart;\n+      int size = GET_MODE_UNIT_SIZE (mode);\n+      enum machine_mode partmode\n+\t= mode_for_size (size * BITS_PER_UNIT,\n+\t\t\t (GET_MODE_CLASS (mode) == MODE_COMPLEX_FLOAT\n+\t\t\t  ? MODE_FLOAT : MODE_INT),\n+\t\t\t 0);\n+\n+      realpart = gen_reg_rtx (partmode);\n+      imagpart = gen_reg_rtx (partmode);\n+      return gen_rtx (CONCAT, mode, realpart, imagpart);\n+    }\n+\n   /* Make sure regno_pointer_flag and regno_reg_rtx are large\n      enough to have an element for this pseudo reg number.  */\n \n@@ -542,7 +563,12 @@ gen_lowpart_common (mode, x)\n       else\n \treturn gen_rtx (SUBREG, mode, x, word);\n     }\n-\n+  else if (GET_CODE (x) == CONCAT)\n+    {\n+      if (GET_MODE (XEXP (x, 0)) != mode)\n+\tabort ();\n+      return XEXP (x, 0);\n+    }\n   /* If X is a CONST_INT or a CONST_DOUBLE, extract the appropriate bits\n      from the low-order part of the constant.  */\n   else if ((GET_MODE_CLASS (mode) == MODE_INT\n@@ -831,6 +857,12 @@ gen_highpart (mode, x)\n       else\n \treturn gen_rtx (SUBREG, mode, x, word);\n     }\n+  else if (GET_CODE (x) == CONCAT)\n+    {\n+      if (GET_MODE (XEXP (x, 1)) != mode)\n+\tabort ();\n+      return XEXP (x, 1);\n+    }\n   else\n     abort ();\n }\n@@ -924,6 +956,14 @@ operand_subword (op, i, validate_address, mode)\n     }\n   else if (GET_CODE (op) == SUBREG)\n     return gen_rtx (SUBREG, word_mode, SUBREG_REG (op), i + SUBREG_WORD (op));\n+  else if (GET_CODE (op) == CONCAT)\n+    {\n+      int partwords = GET_MODE_UNIT_SIZE (GET_MODE (op)) / UNITS_PER_WORD;\n+      if (i < partwords)\n+\treturn operand_subword (XEXP (op, 0), i, validate_address, mode);\n+      return operand_subword (XEXP (op, 1), i - partwords,\n+\t\t\t      validate_address, mode);\n+    }\n \n   /* Form a new MEM at the requested address.  */\n   if (GET_CODE (op) == MEM)"}]}