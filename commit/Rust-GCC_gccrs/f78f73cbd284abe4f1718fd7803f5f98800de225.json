{"sha": "f78f73cbd284abe4f1718fd7803f5f98800de225", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Zjc4ZjczY2JkMjg0YWJlNGYxNzE4ZmQ3ODAzZjVmOTg4MDBkZTIyNQ==", "commit": {"author": {"name": "Richard Sandiford", "email": "richard.sandiford@arm.com", "date": "2019-09-09T16:52:12Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2019-09-09T16:52:12Z"}, "message": "Remove bt-load.c\n\nbt-load.c has AFAIK been dead code since the removal of the SH5 port\nin 2016.  I have a patch series that would need to update the liveness\ntracking in a nontrivial way, so it seemed better to remove the pass\nrather than install an untested and probably bogus change.\n\n2019-09-09  Richard Sandiford  <richard.sandiford@arm.com>\n\ngcc/\n\t* Makefile.in (OBJS): Remove bt-load.o.\n\t* doc/invoke.texi (fbranch-target-load-optimize): Delete.\n\t(fbranch-target-load-optimize2, fbtr-bb-exclusive): Likewise.\n\t* common.opt (fbranch-target-load-optimize): Mark as Ignore and\n\tdocument that the option no longer does anything.\n\t(fbranch-target-load-optimize2, fbtr-bb-exclusive): Likewise.\n\t* target.def (branch_target_register_class): Delete.\n\t(branch_target_register_callee_saved): Likewise.\n\t* doc/tm.texi.in (TARGET_BRANCH_TARGET_REGISTER_CLASS): Likewise.\n\t(TARGET_BRANCH_TARGET_REGISTER_CALLEE_SAVED): Likewise.\n\t* doc/tm.texi: Regenerate.\n\t* tree-pass.h (make_pass_branch_target_load_optimize1): Delete.\n\t(make_pass_branch_target_load_optimize2): Likewise.\n\t* passes.def (pass_branch_target_load_optimize1): Likewise.\n\t(pass_branch_target_load_optimize2): Likewise.\n\t* targhooks.h (default_branch_target_register_class): Likewise.\n\t* targhooks.c (default_branch_target_register_class): Likewise.\n\t* opt-suggestions.c (test_completion_valid_options): Remove\n\t-fbtr-bb-exclusive from the list of test options.\n\t* bt-load.c: Remove.\n\nFrom-SVN: r275521", "tree": {"sha": "1364617a9bf22e5a87b95265c441ea3ef6428ccb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1364617a9bf22e5a87b95265c441ea3ef6428ccb"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f78f73cbd284abe4f1718fd7803f5f98800de225", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f78f73cbd284abe4f1718fd7803f5f98800de225", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f78f73cbd284abe4f1718fd7803f5f98800de225", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f78f73cbd284abe4f1718fd7803f5f98800de225/comments", "author": {"login": "rsandifo-arm", "id": 28043039, "node_id": "MDQ6VXNlcjI4MDQzMDM5", "avatar_url": "https://avatars.githubusercontent.com/u/28043039?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rsandifo-arm", "html_url": "https://github.com/rsandifo-arm", "followers_url": "https://api.github.com/users/rsandifo-arm/followers", "following_url": "https://api.github.com/users/rsandifo-arm/following{/other_user}", "gists_url": "https://api.github.com/users/rsandifo-arm/gists{/gist_id}", "starred_url": "https://api.github.com/users/rsandifo-arm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rsandifo-arm/subscriptions", "organizations_url": "https://api.github.com/users/rsandifo-arm/orgs", "repos_url": "https://api.github.com/users/rsandifo-arm/repos", "events_url": "https://api.github.com/users/rsandifo-arm/events{/privacy}", "received_events_url": "https://api.github.com/users/rsandifo-arm/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "a6edd18cb32993213508aaa4879af7485c1bbaac", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a6edd18cb32993213508aaa4879af7485c1bbaac", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a6edd18cb32993213508aaa4879af7485c1bbaac"}], "stats": {"total": 1706, "additions": 30, "deletions": 1676}, "files": [{"sha": "f640d89ac3e6dd9c8ed9d543331b29e422233830", "filename": "gcc/ChangeLog", "status": "modified", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f78f73cbd284abe4f1718fd7803f5f98800de225/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f78f73cbd284abe4f1718fd7803f5f98800de225/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=f78f73cbd284abe4f1718fd7803f5f98800de225", "patch": "@@ -1,3 +1,26 @@\n+2019-09-09  Richard Sandiford  <richard.sandiford@arm.com>\n+\n+\t* Makefile.in (OBJS): Remove bt-load.o.\n+\t* doc/invoke.texi (fbranch-target-load-optimize): Delete.\n+\t(fbranch-target-load-optimize2, fbtr-bb-exclusive): Likewise.\n+\t* common.opt (fbranch-target-load-optimize): Mark as Ignore and\n+\tdocument that the option no longer does anything.\n+\t(fbranch-target-load-optimize2, fbtr-bb-exclusive): Likewise.\n+\t* target.def (branch_target_register_class): Delete.\n+\t(branch_target_register_callee_saved): Likewise.\n+\t* doc/tm.texi.in (TARGET_BRANCH_TARGET_REGISTER_CLASS): Likewise.\n+\t(TARGET_BRANCH_TARGET_REGISTER_CALLEE_SAVED): Likewise.\n+\t* doc/tm.texi: Regenerate.\n+\t* tree-pass.h (make_pass_branch_target_load_optimize1): Delete.\n+\t(make_pass_branch_target_load_optimize2): Likewise.\n+\t* passes.def (pass_branch_target_load_optimize1): Likewise.\n+\t(pass_branch_target_load_optimize2): Likewise.\n+\t* targhooks.h (default_branch_target_register_class): Likewise.\n+\t* targhooks.c (default_branch_target_register_class): Likewise.\n+\t* opt-suggestions.c (test_completion_valid_options): Remove\n+\t-fbtr-bb-exclusive from the list of test options.\n+\t* bt-load.c: Remove.\n+\n 2019-09-09  Barnaby Wilks  <barnaby.wilks@arm.com>\n \n \t* match.pd: Add flag_unsafe_math_optimizations check"}, {"sha": "0fe02fb27a106266f3b53dcafc76bca5ddda2476", "filename": "gcc/Makefile.in", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f78f73cbd284abe4f1718fd7803f5f98800de225/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f78f73cbd284abe4f1718fd7803f5f98800de225/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=f78f73cbd284abe4f1718fd7803f5f98800de225", "patch": "@@ -1241,7 +1241,6 @@ OBJS = \\\n \tauto-profile.o \\\n \tbb-reorder.o \\\n \tbitmap.o \\\n-\tbt-load.o \\\n \tbuiltins.o \\\n \tcaller-save.o \\\n \tcalls.o \\"}, {"sha": "f68879ca49a848ee0adb431129e21ed1f1d811bd", "filename": "gcc/bt-load.c", "status": "removed", "additions": 0, "deletions": 1577, "changes": 1577, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a6edd18cb32993213508aaa4879af7485c1bbaac/gcc%2Fbt-load.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a6edd18cb32993213508aaa4879af7485c1bbaac/gcc%2Fbt-load.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbt-load.c?ref=a6edd18cb32993213508aaa4879af7485c1bbaac", "patch": "@@ -1,1577 +0,0 @@\n-/* Perform branch target register load optimizations.\n-   Copyright (C) 2001-2019 Free Software Foundation, Inc.\n-\n-This file is part of GCC.\n-\n-GCC is free software; you can redistribute it and/or modify it under\n-the terms of the GNU General Public License as published by the Free\n-Software Foundation; either version 3, or (at your option) any later\n-version.\n-\n-GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n-WARRANTY; without even the implied warranty of MERCHANTABILITY or\n-FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n-for more details.\n-\n-You should have received a copy of the GNU General Public License\n-along with GCC; see the file COPYING3.  If not see\n-<http://www.gnu.org/licenses/>.  */\n-\n-#include \"config.h\"\n-#include \"system.h\"\n-#include \"coretypes.h\"\n-#include \"backend.h\"\n-#include \"target.h\"\n-#include \"rtl.h\"\n-#include \"tree.h\"\n-#include \"df.h\"\n-#include \"insn-config.h\"\n-#include \"regs.h\"\n-#include \"memmodel.h\"\n-#include \"emit-rtl.h\"\n-#include \"recog.h\"\n-#include \"diagnostic-core.h\"\n-#include \"expr.h\"\n-#include \"insn-attr.h\"\n-#include \"tree-pass.h\"\n-#include \"cfgrtl.h\"\n-#include \"cfganal.h\"\n-#include \"cfgcleanup.h\"\n-#include \"cfgloop.h\"\n-#include \"rtl-iter.h\"\n-#include \"fibonacci_heap.h\"\n-\n-struct btr_def;\n-\n-/* Target register optimizations - these are performed after reload.  */\n-\n-struct btr_def_group\n-{\n-  btr_def_group *next;\n-  rtx src;\n-  btr_def *members;\n-};\n-\n-struct btr_user\n-{\n-  btr_user *next;\n-  basic_block bb;\n-  int luid;\n-  rtx_insn *insn;\n-  /* If INSN has a single use of a single branch register, then\n-     USE points to it within INSN.  If there is more than\n-     one branch register use, or the use is in some way ambiguous,\n-     then USE is NULL.  */\n-  rtx use;\n-  int n_reaching_defs;\n-  int first_reaching_def;\n-  char other_use_this_block;\n-};\n-\n-/* btr_def structs appear on three lists:\n-     1. A list of all btr_def structures (head is\n-\tALL_BTR_DEFS, linked by the NEXT field).\n-     2. A list of branch reg definitions per basic block (head is\n-\tBB_BTR_DEFS[i], linked by the NEXT_THIS_BB field).\n-     3. A list of all branch reg definitions belonging to the same\n-\tgroup (head is in a BTR_DEF_GROUP struct, linked by\n-\tNEXT_THIS_GROUP field).  */\n-\n-struct btr_def\n-{\n-  btr_def *next_this_bb;\n-  btr_def *next_this_group;\n-  basic_block bb;\n-  int luid;\n-  rtx_insn *insn;\n-  int btr;\n-  int cost;\n-  /* For a branch register setting insn that has a constant\n-     source (i.e. a label), group links together all the\n-     insns with the same source.  For other branch register\n-     setting insns, group is NULL.  */\n-  btr_def_group *group;\n-  btr_user *uses;\n-  /* If this def has a reaching use which is not a simple use\n-     in a branch instruction, then has_ambiguous_use will be true,\n-     and we will not attempt to migrate this definition.  */\n-  char has_ambiguous_use;\n-  /* live_range is an approximation to the true live range for this\n-     def/use web, because it records the set of blocks that contain\n-     the live range.  There could be other live ranges for the same\n-     branch register in that set of blocks, either in the block\n-     containing the def (before the def), or in a block containing\n-     a use (after the use).  If there are such other live ranges, then\n-     other_btr_uses_before_def or other_btr_uses_after_use must be set true\n-     as appropriate.  */\n-  char other_btr_uses_before_def;\n-  char other_btr_uses_after_use;\n-  /* We set own_end when we have moved a definition into a dominator.\n-     Thus, when a later combination removes this definition again, we know\n-     to clear out trs_live_at_end again.  */\n-  char own_end;\n-  bitmap live_range;\n-};\n-\n-typedef fibonacci_heap <long, btr_def> btr_heap_t;\n-typedef fibonacci_node <long, btr_def> btr_heap_node_t;\n-\n-static int issue_rate;\n-\n-static int basic_block_freq (const_basic_block);\n-static int insn_sets_btr_p (const rtx_insn *, int, int *);\n-static void find_btr_def_group (btr_def_group **, btr_def *);\n-static btr_def *add_btr_def (btr_heap_t *, basic_block, int, rtx_insn *,\n-\t\t\t    unsigned int, int, btr_def_group **);\n-static btr_user *new_btr_user (basic_block, int, rtx_insn *);\n-static void dump_hard_reg_set (HARD_REG_SET);\n-static void dump_btrs_live (int);\n-static void note_other_use_this_block (unsigned int, btr_user *);\n-static void compute_defs_uses_and_gen (btr_heap_t *, btr_def **, btr_user **,\n-\t\t\t\t       sbitmap *, sbitmap *, HARD_REG_SET *);\n-static void compute_kill (sbitmap *, sbitmap *, HARD_REG_SET *);\n-static void compute_out (sbitmap *bb_out, sbitmap *, sbitmap *, int);\n-static void link_btr_uses (btr_def **, btr_user **, sbitmap *, sbitmap *, int);\n-static void build_btr_def_use_webs (btr_heap_t *);\n-static int block_at_edge_of_live_range_p (int, btr_def *);\n-static void clear_btr_from_live_range (btr_def *def);\n-static void add_btr_to_live_range (btr_def *, int);\n-static void augment_live_range (bitmap, HARD_REG_SET *, basic_block,\n-\t\t\t\tbasic_block, int);\n-static int choose_btr (HARD_REG_SET);\n-static void combine_btr_defs (btr_def *, HARD_REG_SET *);\n-static void btr_def_live_range (btr_def *, HARD_REG_SET *);\n-static void move_btr_def (basic_block, int, btr_def *, bitmap, HARD_REG_SET *);\n-static int migrate_btr_def (btr_def *, int);\n-static void migrate_btr_defs (enum reg_class, int);\n-static int can_move_up (const_basic_block, const rtx_insn *, int);\n-static void note_btr_set (rtx, const_rtx, void *);\n-\f\n-/* The following code performs code motion of target load instructions\n-   (instructions that set branch target registers), to move them\n-   forward away from the branch instructions and out of loops (or,\n-   more generally, from a more frequently executed place to a less\n-   frequently executed place).\n-   Moving target load instructions further in front of the branch\n-   instruction that uses the target register value means that the hardware\n-   has a better chance of preloading the instructions at the branch\n-   target by the time the branch is reached.  This avoids bubbles\n-   when a taken branch needs to flush out the pipeline.\n-   Moving target load instructions out of loops means they are executed\n-   less frequently.  */\n-\n-/* An obstack to hold the def-use web data structures built up for\n-   migrating branch target load instructions.  */\n-static struct obstack migrate_btrl_obstack;\n-\n-/* Array indexed by basic block number, giving the set of registers\n-   live in that block.  */\n-static HARD_REG_SET *btrs_live;\n-\n-/* Array indexed by basic block number, giving the set of registers live at\n-  the end of that block, including any uses by a final jump insn, if any.  */\n-static HARD_REG_SET *btrs_live_at_end;\n-\n-/* Set of all target registers that we are willing to allocate.  */\n-static HARD_REG_SET all_btrs;\n-\n-/* Provide lower and upper bounds for target register numbers, so that\n-   we don't need to search through all the hard registers all the time.  */\n-static int first_btr, last_btr;\n-\n-\n-\n-/* Return an estimate of the frequency of execution of block bb.  */\n-static int\n-basic_block_freq (const_basic_block bb)\n-{\n-  return bb->count.to_frequency (cfun);\n-}\n-\n-/* If the rtx at *XP references (sets or reads) any branch target\n-   register, return one such register.  If EXCLUDEP is set, disregard\n-   any references within that location.  */\n-static rtx *\n-find_btr_use (rtx *xp, rtx *excludep = 0)\n-{\n-  subrtx_ptr_iterator::array_type array;\n-  FOR_EACH_SUBRTX_PTR (iter, array, xp, NONCONST)\n-    {\n-      rtx *loc = *iter;\n-      if (loc == excludep)\n-\titer.skip_subrtxes ();\n-      else\n-\t{\n-\t  const_rtx x = *loc;\n-\t  if (REG_P (x)\n-\t      && overlaps_hard_reg_set_p (all_btrs, GET_MODE (x), REGNO (x)))\n-\t    return loc;\n-\t}\n-    }\n-  return 0;\n-}\n-\n-/* Return true if insn is an instruction that sets a target register.\n-   if CHECK_CONST is true, only return true if the source is constant.\n-   If such a set is found and REGNO is nonzero, assign the register number\n-   of the destination register to *REGNO.  */\n-static int\n-insn_sets_btr_p (const rtx_insn *insn, int check_const, int *regno)\n-{\n-  rtx set;\n-\n-  if (NONJUMP_INSN_P (insn)\n-      && (set = single_set (insn)))\n-    {\n-      rtx dest = SET_DEST (set);\n-      rtx src = SET_SRC (set);\n-\n-      if (GET_CODE (dest) == SUBREG)\n-\tdest = XEXP (dest, 0);\n-\n-      if (REG_P (dest)\n-\t  && TEST_HARD_REG_BIT (all_btrs, REGNO (dest)))\n-\t{\n-\t  gcc_assert (!find_btr_use (&src));\n-\n-\t  if (!check_const || CONSTANT_P (src))\n-\t    {\n-\t      if (regno)\n-\t\t*regno = REGNO (dest);\n-\t      return 1;\n-\t    }\n-\t}\n-    }\n-  return 0;\n-}\n-\n-/* Find the group that the target register definition DEF belongs\n-   to in the list starting with *ALL_BTR_DEF_GROUPS.  If no such\n-   group exists, create one.  Add def to the group.  */\n-static void\n-find_btr_def_group (btr_def_group **all_btr_def_groups, btr_def *def)\n-{\n-  if (insn_sets_btr_p (def->insn, 1, NULL))\n-    {\n-      btr_def_group *this_group;\n-      rtx def_src = SET_SRC (single_set (def->insn));\n-\n-      /* ?? This linear search is an efficiency concern, particularly\n-\t as the search will almost always fail to find a match.  */\n-      for (this_group = *all_btr_def_groups;\n-\t   this_group != NULL;\n-\t   this_group = this_group->next)\n-\tif (rtx_equal_p (def_src, this_group->src))\n-\t  break;\n-\n-      if (!this_group)\n-\t{\n-\t  this_group = XOBNEW (&migrate_btrl_obstack, btr_def_group);\n-\t  this_group->src = def_src;\n-\t  this_group->members = NULL;\n-\t  this_group->next = *all_btr_def_groups;\n-\t  *all_btr_def_groups = this_group;\n-\t}\n-      def->group = this_group;\n-      def->next_this_group = this_group->members;\n-      this_group->members = def;\n-    }\n-  else\n-    def->group = NULL;\n-}\n-\n-/* Create a new target register definition structure, for a definition in\n-   block BB, instruction INSN, and insert it into ALL_BTR_DEFS.  Return\n-   the new definition.  */\n-static btr_def *\n-add_btr_def (btr_heap_t *all_btr_defs, basic_block bb, int insn_luid,\n-\t     rtx_insn *insn,\n-\t     unsigned int dest_reg, int other_btr_uses_before_def,\n-\t     btr_def_group **all_btr_def_groups)\n-{\n-  btr_def *this_def = XOBNEW (&migrate_btrl_obstack, btr_def);\n-  this_def->bb = bb;\n-  this_def->luid = insn_luid;\n-  this_def->insn = insn;\n-  this_def->btr = dest_reg;\n-  this_def->cost = basic_block_freq (bb);\n-  this_def->has_ambiguous_use = 0;\n-  this_def->other_btr_uses_before_def = other_btr_uses_before_def;\n-  this_def->other_btr_uses_after_use = 0;\n-  this_def->next_this_bb = NULL;\n-  this_def->next_this_group = NULL;\n-  this_def->uses = NULL;\n-  this_def->live_range = NULL;\n-  find_btr_def_group (all_btr_def_groups, this_def);\n-\n-  all_btr_defs->insert (-this_def->cost, this_def);\n-\n-  if (dump_file)\n-    fprintf (dump_file,\n-      \"Found target reg definition: sets %u { bb %d, insn %d }%s priority %d\\n\",\n-\t     dest_reg, bb->index, INSN_UID (insn),\n-\t     (this_def->group ? \"\" : \":not const\"), this_def->cost);\n-\n-  return this_def;\n-}\n-\n-/* Create a new target register user structure, for a use in block BB,\n-   instruction INSN.  Return the new user.  */\n-static btr_user *\n-new_btr_user (basic_block bb, int insn_luid, rtx_insn *insn)\n-{\n-  /* This instruction reads target registers.  We need\n-     to decide whether we can replace all target register\n-     uses easily.\n-   */\n-  rtx *usep = find_btr_use (&PATTERN (insn));\n-  rtx use;\n-  btr_user *user = NULL;\n-\n-  if (usep)\n-    {\n-      int unambiguous_single_use;\n-\n-      /* We want to ensure that USE is the only use of a target\n-\t register in INSN, so that we know that to rewrite INSN to use\n-\t a different target register, all we have to do is replace USE.  */\n-      unambiguous_single_use = !find_btr_use (&PATTERN (insn), usep);\n-      if (!unambiguous_single_use)\n-\tusep = NULL;\n-    }\n-  use = usep ? *usep : NULL_RTX;\n-  user = XOBNEW (&migrate_btrl_obstack, btr_user);\n-  user->bb = bb;\n-  user->luid = insn_luid;\n-  user->insn = insn;\n-  user->use = use;\n-  user->other_use_this_block = 0;\n-  user->next = NULL;\n-  user->n_reaching_defs = 0;\n-  user->first_reaching_def = -1;\n-\n-  if (dump_file)\n-    {\n-      fprintf (dump_file, \"Uses target reg: { bb %d, insn %d }\",\n-\t       bb->index, INSN_UID (insn));\n-\n-      if (user->use)\n-\tfprintf (dump_file, \": unambiguous use of reg %d\\n\",\n-\t\t REGNO (user->use));\n-    }\n-\n-  return user;\n-}\n-\n-/* Write the contents of S to the dump file.  */\n-static void\n-dump_hard_reg_set (HARD_REG_SET s)\n-{\n-  int reg;\n-  for (reg = 0; reg < FIRST_PSEUDO_REGISTER; reg++)\n-    if (TEST_HARD_REG_BIT (s, reg))\n-      fprintf (dump_file, \" %d\", reg);\n-}\n-\n-/* Write the set of target regs live in block BB to the dump file.  */\n-static void\n-dump_btrs_live (int bb)\n-{\n-  fprintf (dump_file, \"BB%d live:\", bb);\n-  dump_hard_reg_set (btrs_live[bb]);\n-  fprintf (dump_file, \"\\n\");\n-}\n-\n-/* REGNO is the number of a branch target register that is being used or\n-   set.  USERS_THIS_BB is a list of preceding branch target register users;\n-   If any of them use the same register, set their other_use_this_block\n-   flag.  */\n-static void\n-note_other_use_this_block (unsigned int regno, btr_user *users_this_bb)\n-{\n-  btr_user *user;\n-\n-  for (user = users_this_bb; user != NULL; user = user->next)\n-    if (user->use && REGNO (user->use) == regno)\n-      user->other_use_this_block = 1;\n-}\n-\n-struct defs_uses_info {\n-  btr_user *users_this_bb;\n-  HARD_REG_SET btrs_written_in_block;\n-  HARD_REG_SET btrs_live_in_block;\n-  sbitmap bb_gen;\n-  sbitmap *btr_defset;\n-};\n-\n-/* Called via note_stores or directly to register stores into /\n-   clobbers of a branch target register DEST that are not recognized as\n-   straightforward definitions.  DATA points to information about the\n-   current basic block that needs updating.  */\n-static void\n-note_btr_set (rtx dest, const_rtx set ATTRIBUTE_UNUSED, void *data)\n-{\n-  defs_uses_info *info = (defs_uses_info *) data;\n-  int regno, end_regno;\n-\n-  if (!REG_P (dest))\n-    return;\n-  regno = REGNO (dest);\n-  end_regno = END_REGNO (dest);\n-  for (; regno < end_regno; regno++)\n-    if (TEST_HARD_REG_BIT (all_btrs, regno))\n-      {\n-\tnote_other_use_this_block (regno, info->users_this_bb);\n-\tSET_HARD_REG_BIT (info->btrs_written_in_block, regno);\n-\tSET_HARD_REG_BIT (info->btrs_live_in_block, regno);\n-\tbitmap_and_compl (info->bb_gen, info->bb_gen,\n-\t\t\t    info->btr_defset[regno - first_btr]);\n-      }\n-}\n-\n-static void\n-compute_defs_uses_and_gen (btr_heap_t *all_btr_defs, btr_def **def_array,\n-\t\t\t   btr_user **use_array, sbitmap *btr_defset,\n-\t\t\t   sbitmap *bb_gen, HARD_REG_SET *btrs_written)\n-{\n-  /* Scan the code building up the set of all defs and all uses.\n-     For each target register, build the set of defs of that register.\n-     For each block, calculate the set of target registers\n-     written in that block.\n-     Also calculate the set of btrs ever live in that block.\n-  */\n-  int i;\n-  int insn_luid = 0;\n-  btr_def_group *all_btr_def_groups = NULL;\n-  defs_uses_info info;\n-\n-  bitmap_vector_clear (bb_gen, last_basic_block_for_fn (cfun));\n-  for (i = NUM_FIXED_BLOCKS; i < last_basic_block_for_fn (cfun); i++)\n-    {\n-      basic_block bb = BASIC_BLOCK_FOR_FN (cfun, i);\n-      int reg;\n-      btr_def *defs_this_bb = NULL;\n-      rtx_insn *insn;\n-      rtx_insn *last;\n-      int can_throw = 0;\n-\n-      info.users_this_bb = NULL;\n-      info.bb_gen = bb_gen[i];\n-      info.btr_defset = btr_defset;\n-\n-      CLEAR_HARD_REG_SET (info.btrs_live_in_block);\n-      CLEAR_HARD_REG_SET (info.btrs_written_in_block);\n-      for (reg = first_btr; reg <= last_btr; reg++)\n-\tif (TEST_HARD_REG_BIT (all_btrs, reg)\n-\t    && REGNO_REG_SET_P (df_get_live_in (bb), reg))\n-\t  SET_HARD_REG_BIT (info.btrs_live_in_block, reg);\n-\n-      for (insn = BB_HEAD (bb), last = NEXT_INSN (BB_END (bb));\n-\t   insn != last;\n-\t   insn = NEXT_INSN (insn), insn_luid++)\n-\t{\n-\t  if (INSN_P (insn))\n-\t    {\n-\t      int regno;\n-\t      int insn_uid = INSN_UID (insn);\n-\n-\t      if (insn_sets_btr_p (insn, 0, &regno))\n-\t\t{\n-\t\t  btr_def *def = add_btr_def (\n-\t\t      all_btr_defs, bb, insn_luid, insn, regno,\n-\t\t      TEST_HARD_REG_BIT (info.btrs_live_in_block, regno),\n-\t\t      &all_btr_def_groups);\n-\n-\t\t  def_array[insn_uid] = def;\n-\t\t  SET_HARD_REG_BIT (info.btrs_written_in_block, regno);\n-\t\t  SET_HARD_REG_BIT (info.btrs_live_in_block, regno);\n-\t\t  bitmap_and_compl (bb_gen[i], bb_gen[i],\n-\t\t\t\t      btr_defset[regno - first_btr]);\n-\t\t  bitmap_set_bit (bb_gen[i], insn_uid);\n-\t\t  def->next_this_bb = defs_this_bb;\n-\t\t  defs_this_bb = def;\n-\t\t  bitmap_set_bit (btr_defset[regno - first_btr], insn_uid);\n-\t\t  note_other_use_this_block (regno, info.users_this_bb);\n-\t\t}\n-\t      /* Check for the blockage emitted by expand_nl_goto_receiver.  */\n-\t      else if (cfun->has_nonlocal_label\n-\t\t       && GET_CODE (PATTERN (insn)) == UNSPEC_VOLATILE)\n-\t\t{\n-\t\t  btr_user *user;\n-\n-\t\t  /* Do the equivalent of calling note_other_use_this_block\n-\t\t     for every target register.  */\n-\t\t  for (user = info.users_this_bb; user != NULL;\n-\t\t       user = user->next)\n-\t\t    if (user->use)\n-\t\t      user->other_use_this_block = 1;\n-\t\t  IOR_HARD_REG_SET (info.btrs_written_in_block, all_btrs);\n-\t\t  IOR_HARD_REG_SET (info.btrs_live_in_block, all_btrs);\n-\t\t  bitmap_clear (info.bb_gen);\n-\t\t}\n-\t      else\n-\t\t{\n-\t\t  if (find_btr_use (&PATTERN (insn)))\n-\t\t    {\n-\t\t      btr_user *user = new_btr_user (bb, insn_luid, insn);\n-\n-\t\t      use_array[insn_uid] = user;\n-\t\t      if (user->use)\n-\t\t\tSET_HARD_REG_BIT (info.btrs_live_in_block,\n-\t\t\t\t\t  REGNO (user->use));\n-\t\t      else\n-\t\t\t{\n-\t\t\t  int reg;\n-\t\t\t  for (reg = first_btr; reg <= last_btr; reg++)\n-\t\t\t    if (TEST_HARD_REG_BIT (all_btrs, reg)\n-\t\t\t\t&& refers_to_regno_p (reg, user->insn))\n-\t\t\t      {\n-\t\t\t\tnote_other_use_this_block (reg,\n-\t\t\t\t\t\t\t   info.users_this_bb);\n-\t\t\t\tSET_HARD_REG_BIT (info.btrs_live_in_block, reg);\n-\t\t\t      }\n-\t\t\t  note_stores (PATTERN (insn), note_btr_set, &info);\n-\t\t\t}\n-\t\t      user->next = info.users_this_bb;\n-\t\t      info.users_this_bb = user;\n-\t\t    }\n-\t\t  if (CALL_P (insn))\n-\t\t    {\n-\t\t      HARD_REG_SET *clobbered = &call_used_reg_set;\n-\t\t      HARD_REG_SET call_saved;\n-\t\t      rtx pat = PATTERN (insn);\n-\t\t      int i;\n-\n-\t\t      /* Check for sibcall.  */\n-\t\t      if (GET_CODE (pat) == PARALLEL)\n-\t\t\tfor (i = XVECLEN (pat, 0) - 1; i >= 0; i--)\n-\t\t\t  if (ANY_RETURN_P (XVECEXP (pat, 0, i)))\n-\t\t\t    {\n-\t\t\t      COMPL_HARD_REG_SET (call_saved,\n-\t\t\t\t\t\t  call_used_reg_set);\n-\t\t\t      clobbered = &call_saved;\n-\t\t\t    }\n-\n-\t\t      for (regno = first_btr; regno <= last_btr; regno++)\n-\t\t\tif (TEST_HARD_REG_BIT (*clobbered, regno))\n-\t\t\t  note_btr_set (regno_reg_rtx[regno], NULL_RTX, &info);\n-\t\t    }\n-\t\t}\n-\t    }\n-\t}\n-\n-      COPY_HARD_REG_SET (btrs_live[i], info.btrs_live_in_block);\n-      COPY_HARD_REG_SET (btrs_written[i], info.btrs_written_in_block);\n-\n-      REG_SET_TO_HARD_REG_SET (btrs_live_at_end[i], df_get_live_out (bb));\n-      /* If this block ends in a jump insn, add any uses or even clobbers\n-\t of branch target registers that it might have.  */\n-      for (insn = BB_END (bb); insn != BB_HEAD (bb) && ! INSN_P (insn); )\n-\tinsn = PREV_INSN (insn);\n-      /* ??? for the fall-through edge, it would make sense to insert the\n-\t btr set on the edge, but that would require to split the block\n-\t early on so that we can distinguish between dominance from the fall\n-\t through edge - which can use the call-clobbered registers - from\n-\t dominance by the throw edge.  */\n-      if (can_throw_internal (insn))\n-\t{\n-\t  HARD_REG_SET tmp;\n-\n-\t  COPY_HARD_REG_SET (tmp, call_used_reg_set);\n-\t  AND_HARD_REG_SET (tmp, all_btrs);\n-\t  IOR_HARD_REG_SET (btrs_live_at_end[i], tmp);\n-\t  can_throw = 1;\n-\t}\n-      if (can_throw || JUMP_P (insn))\n-\t{\n-\t  int regno;\n-\n-\t  for (regno = first_btr; regno <= last_btr; regno++)\n-\t    if (refers_to_regno_p (regno, insn))\n-\t      SET_HARD_REG_BIT (btrs_live_at_end[i], regno);\n-\t}\n-\n-      if (dump_file)\n-\tdump_btrs_live (i);\n-    }\n-}\n-\n-static void\n-compute_kill (sbitmap *bb_kill, sbitmap *btr_defset,\n-\t      HARD_REG_SET *btrs_written)\n-{\n-  int i;\n-  int regno;\n-\n-  /* For each basic block, form the set BB_KILL - the set\n-     of definitions that the block kills.  */\n-  bitmap_vector_clear (bb_kill, last_basic_block_for_fn (cfun));\n-  for (i = NUM_FIXED_BLOCKS; i < last_basic_block_for_fn (cfun); i++)\n-    {\n-      for (regno = first_btr; regno <= last_btr; regno++)\n-\tif (TEST_HARD_REG_BIT (all_btrs, regno)\n-\t    && TEST_HARD_REG_BIT (btrs_written[i], regno))\n-\t  bitmap_ior (bb_kill[i], bb_kill[i],\n-\t\t\t  btr_defset[regno - first_btr]);\n-    }\n-}\n-\n-static void\n-compute_out (sbitmap *bb_out, sbitmap *bb_gen, sbitmap *bb_kill, int max_uid)\n-{\n-  /* Perform iterative dataflow:\n-      Initially, for all blocks, BB_OUT = BB_GEN.\n-      For each block,\n-\tBB_IN  = union over predecessors of BB_OUT(pred)\n-\tBB_OUT = (BB_IN - BB_KILL) + BB_GEN\n-     Iterate until the bb_out sets stop growing.  */\n-  int i;\n-  int changed;\n-  auto_sbitmap bb_in (max_uid);\n-\n-  for (i = NUM_FIXED_BLOCKS; i < last_basic_block_for_fn (cfun); i++)\n-    bitmap_copy (bb_out[i], bb_gen[i]);\n-\n-  changed = 1;\n-  while (changed)\n-    {\n-      changed = 0;\n-      for (i = NUM_FIXED_BLOCKS; i < last_basic_block_for_fn (cfun); i++)\n-\t{\n-\t  bitmap_union_of_preds (bb_in, bb_out, BASIC_BLOCK_FOR_FN (cfun, i));\n-\t  changed |= bitmap_ior_and_compl (bb_out[i], bb_gen[i],\n-\t\t\t\t\t       bb_in, bb_kill[i]);\n-\t}\n-    }\n-}\n-\n-static void\n-link_btr_uses (btr_def **def_array, btr_user **use_array, sbitmap *bb_out,\n-\t       sbitmap *btr_defset, int max_uid)\n-{\n-  int i;\n-  auto_sbitmap reaching_defs (max_uid);\n-\n-  /* Link uses to the uses lists of all of their reaching defs.\n-     Count up the number of reaching defs of each use.  */\n-  for (i = NUM_FIXED_BLOCKS; i < last_basic_block_for_fn (cfun); i++)\n-    {\n-      basic_block bb = BASIC_BLOCK_FOR_FN (cfun, i);\n-      rtx_insn *insn;\n-      rtx_insn *last;\n-\n-      bitmap_union_of_preds (reaching_defs, bb_out, BASIC_BLOCK_FOR_FN (cfun, i));\n-      for (insn = BB_HEAD (bb), last = NEXT_INSN (BB_END (bb));\n-\t   insn != last;\n-\t   insn = NEXT_INSN (insn))\n-\t{\n-\t  if (INSN_P (insn))\n-\t    {\n-\t      int insn_uid = INSN_UID (insn);\n-\n-\t      btr_def *def   = def_array[insn_uid];\n-\t      btr_user *user = use_array[insn_uid];\n-\t      if (def != NULL)\n-\t\t{\n-\t\t  /* Remove all reaching defs of regno except\n-\t\t     for this one.  */\n-\t\t  bitmap_and_compl (reaching_defs, reaching_defs,\n-\t\t\t\t      btr_defset[def->btr - first_btr]);\n-\t\t  bitmap_set_bit (reaching_defs, insn_uid);\n-\t\t}\n-\n-\t      if (user != NULL)\n-\t\t{\n-\t\t  /* Find all the reaching defs for this use.  */\n-\t\t  auto_sbitmap reaching_defs_of_reg (max_uid);\n-\t\t  unsigned int uid = 0;\n-\t\t  sbitmap_iterator sbi;\n-\n-\t\t  if (user->use)\n-\t\t    bitmap_and (\n-\t\t      reaching_defs_of_reg,\n-\t\t      reaching_defs,\n-\t\t      btr_defset[REGNO (user->use) - first_btr]);\n-\t\t  else\n-\t\t    {\n-\t\t      int reg;\n-\n-\t\t      bitmap_clear (reaching_defs_of_reg);\n-\t\t      for (reg = first_btr; reg <= last_btr; reg++)\n-\t\t\tif (TEST_HARD_REG_BIT (all_btrs, reg)\n-\t\t\t    && refers_to_regno_p (reg, user->insn))\n-\t\t\t  bitmap_or_and (reaching_defs_of_reg,\n-\t\t\t    reaching_defs_of_reg,\n-\t\t\t    reaching_defs,\n-\t\t\t    btr_defset[reg - first_btr]);\n-\t\t    }\n-\t\t  EXECUTE_IF_SET_IN_BITMAP (reaching_defs_of_reg, 0, uid, sbi)\n-\t\t    {\n-\t\t      btr_def *def = def_array[uid];\n-\n-\t\t      /* We now know that def reaches user.  */\n-\n-\t\t      if (dump_file)\n-\t\t\tfprintf (dump_file,\n-\t\t\t  \"Def in insn %d reaches use in insn %d\\n\",\n-\t\t\t  uid, insn_uid);\n-\n-\t\t      user->n_reaching_defs++;\n-\t\t      if (!user->use)\n-\t\t\tdef->has_ambiguous_use = 1;\n-\t\t      if (user->first_reaching_def != -1)\n-\t\t\t{ /* There is more than one reaching def.  This is\n-\t\t\t     a rare case, so just give up on this def/use\n-\t\t\t     web when it occurs.  */\n-\t\t\t  def->has_ambiguous_use = 1;\n-\t\t\t  def_array[user->first_reaching_def]\n-\t\t\t    ->has_ambiguous_use = 1;\n-\t\t\t  if (dump_file)\n-\t\t\t    fprintf (dump_file,\n-\t\t\t\t     \"(use %d has multiple reaching defs)\\n\",\n-\t\t\t\t     insn_uid);\n-\t\t\t}\n-\t\t      else\n-\t\t\tuser->first_reaching_def = uid;\n-\t\t      if (user->other_use_this_block)\n-\t\t\tdef->other_btr_uses_after_use = 1;\n-\t\t      user->next = def->uses;\n-\t\t      def->uses = user;\n-\t\t    }\n-\t\t}\n-\n-\t      if (CALL_P (insn))\n-\t\t{\n-\t\t  int regno;\n-\n-\t\t  for (regno = first_btr; regno <= last_btr; regno++)\n-\t\t    if (TEST_HARD_REG_BIT (all_btrs, regno)\n-\t\t\t&& TEST_HARD_REG_BIT (call_used_reg_set, regno))\n-\t\t      bitmap_and_compl (reaching_defs, reaching_defs,\n-\t\t\t\t\t  btr_defset[regno - first_btr]);\n-\t\t}\n-\t    }\n-\t}\n-    }\n-}\n-\n-static void\n-build_btr_def_use_webs (btr_heap_t *all_btr_defs)\n-{\n-  const int max_uid = get_max_uid ();\n-  btr_def  **def_array   = XCNEWVEC (btr_def *, max_uid);\n-  btr_user **use_array   = XCNEWVEC (btr_user *, max_uid);\n-  sbitmap *btr_defset   = sbitmap_vector_alloc (\n-\t\t\t   (last_btr - first_btr) + 1, max_uid);\n-  sbitmap *bb_gen = sbitmap_vector_alloc (last_basic_block_for_fn (cfun),\n-\t\t\t\t\t  max_uid);\n-  HARD_REG_SET *btrs_written = XCNEWVEC (HARD_REG_SET,\n-\t\t\t\t\t last_basic_block_for_fn (cfun));\n-  sbitmap *bb_kill;\n-  sbitmap *bb_out;\n-\n-  bitmap_vector_clear (btr_defset, (last_btr - first_btr) + 1);\n-\n-  compute_defs_uses_and_gen (all_btr_defs, def_array, use_array, btr_defset,\n-\t\t\t     bb_gen, btrs_written);\n-\n-  bb_kill = sbitmap_vector_alloc (last_basic_block_for_fn (cfun), max_uid);\n-  compute_kill (bb_kill, btr_defset, btrs_written);\n-  free (btrs_written);\n-\n-  bb_out = sbitmap_vector_alloc (last_basic_block_for_fn (cfun), max_uid);\n-  compute_out (bb_out, bb_gen, bb_kill, max_uid);\n-\n-  sbitmap_vector_free (bb_gen);\n-  sbitmap_vector_free (bb_kill);\n-\n-  link_btr_uses (def_array, use_array, bb_out, btr_defset, max_uid);\n-\n-  sbitmap_vector_free (bb_out);\n-  sbitmap_vector_free (btr_defset);\n-  free (use_array);\n-  free (def_array);\n-}\n-\n-/* Return true if basic block BB contains the start or end of the\n-   live range of the definition DEF, AND there are other live\n-   ranges of the same target register that include BB.  */\n-static int\n-block_at_edge_of_live_range_p (int bb, btr_def *def)\n-{\n-  if (def->other_btr_uses_before_def\n-      && BASIC_BLOCK_FOR_FN (cfun, bb) == def->bb)\n-    return 1;\n-  else if (def->other_btr_uses_after_use)\n-    {\n-      btr_user *user;\n-      for (user = def->uses; user != NULL; user = user->next)\n-\tif (BASIC_BLOCK_FOR_FN (cfun, bb) == user->bb)\n-\t  return 1;\n-    }\n-  return 0;\n-}\n-\n-/* We are removing the def/use web DEF.  The target register\n-   used in this web is therefore no longer live in the live range\n-   of this web, so remove it from the live set of all basic blocks\n-   in the live range of the web.\n-   Blocks at the boundary of the live range may contain other live\n-   ranges for the same target register, so we have to be careful\n-   to remove the target register from the live set of these blocks\n-   only if they do not contain other live ranges for the same register.  */\n-static void\n-clear_btr_from_live_range (btr_def *def)\n-{\n-  unsigned bb;\n-  bitmap_iterator bi;\n-\n-  EXECUTE_IF_SET_IN_BITMAP (def->live_range, 0, bb, bi)\n-    {\n-      if ((!def->other_btr_uses_before_def\n-\t   && !def->other_btr_uses_after_use)\n-\t  || !block_at_edge_of_live_range_p (bb, def))\n-\t{\n-\t  CLEAR_HARD_REG_BIT (btrs_live[bb], def->btr);\n-\t  CLEAR_HARD_REG_BIT (btrs_live_at_end[bb], def->btr);\n-\t  if (dump_file)\n-\t    dump_btrs_live (bb);\n-\t}\n-    }\n- if (def->own_end)\n-   CLEAR_HARD_REG_BIT (btrs_live_at_end[def->bb->index], def->btr);\n-}\n-\n-\n-/* We are adding the def/use web DEF.  Add the target register used\n-   in this web to the live set of all of the basic blocks that contain\n-   the live range of the web.\n-   If OWN_END is set, also show that the register is live from our\n-   definitions at the end of the basic block where it is defined.  */\n-static void\n-add_btr_to_live_range (btr_def *def, int own_end)\n-{\n-  unsigned bb;\n-  bitmap_iterator bi;\n-\n-  EXECUTE_IF_SET_IN_BITMAP (def->live_range, 0, bb, bi)\n-    {\n-      SET_HARD_REG_BIT (btrs_live[bb], def->btr);\n-      SET_HARD_REG_BIT (btrs_live_at_end[bb], def->btr);\n-      if (dump_file)\n-\tdump_btrs_live (bb);\n-    }\n-  if (own_end)\n-    {\n-      SET_HARD_REG_BIT (btrs_live_at_end[def->bb->index], def->btr);\n-      def->own_end = 1;\n-    }\n-}\n-\n-/* Update a live range to contain the basic block NEW_BLOCK, and all\n-   blocks on paths between the existing live range and NEW_BLOCK.\n-   HEAD is a block contained in the existing live range that dominates\n-   all other blocks in the existing live range.\n-   Also add to the set BTRS_LIVE_IN_RANGE all target registers that\n-   are live in the blocks that we add to the live range.\n-   If FULL_RANGE is set, include the full live range of NEW_BB;\n-   otherwise, if NEW_BB dominates HEAD_BB, only add registers that\n-   are life at the end of NEW_BB for NEW_BB itself.\n-   It is a precondition that either NEW_BLOCK dominates HEAD,or\n-   HEAD dom NEW_BLOCK.  This is used to speed up the\n-   implementation of this function.  */\n-static void\n-augment_live_range (bitmap live_range, HARD_REG_SET *btrs_live_in_range,\n-\t\t    basic_block head_bb, basic_block new_bb, int full_range)\n-{\n-  basic_block *worklist, *tos;\n-\n-  tos = worklist = XNEWVEC (basic_block, n_basic_blocks_for_fn (cfun) + 1);\n-\n-  if (dominated_by_p (CDI_DOMINATORS, new_bb, head_bb))\n-    {\n-      if (new_bb == head_bb)\n-\t{\n-\t  if (full_range)\n-\t    IOR_HARD_REG_SET (*btrs_live_in_range, btrs_live[new_bb->index]);\n-\t  free (tos);\n-\t  return;\n-\t}\n-      *tos++ = new_bb;\n-    }\n-  else\n-    {\n-      edge e;\n-      edge_iterator ei;\n-      int new_block = new_bb->index;\n-\n-      gcc_assert (dominated_by_p (CDI_DOMINATORS, head_bb, new_bb));\n-\n-      IOR_HARD_REG_SET (*btrs_live_in_range, btrs_live[head_bb->index]);\n-      bitmap_set_bit (live_range, new_block);\n-      /* A previous btr migration could have caused a register to be\n-\tlive just at the end of new_block which we need in full, so\n-\tuse trs_live_at_end even if full_range is set.  */\n-      IOR_HARD_REG_SET (*btrs_live_in_range, btrs_live_at_end[new_block]);\n-      if (full_range)\n-\tIOR_HARD_REG_SET (*btrs_live_in_range, btrs_live[new_block]);\n-      if (dump_file)\n-\t{\n-\t  fprintf (dump_file,\n-\t\t   \"Adding end of block %d and rest of %d to live range\\n\",\n-\t\t   new_block, head_bb->index);\n-\t  fprintf (dump_file,\"Now live btrs are \");\n-\t  dump_hard_reg_set (*btrs_live_in_range);\n-\t  fprintf (dump_file, \"\\n\");\n-\t}\n-      FOR_EACH_EDGE (e, ei, head_bb->preds)\n-\t*tos++ = e->src;\n-    }\n-\n-  while (tos != worklist)\n-    {\n-      basic_block bb = *--tos;\n-      if (!bitmap_bit_p (live_range, bb->index))\n-\t{\n-\t  edge e;\n-\t  edge_iterator ei;\n-\n-\t  bitmap_set_bit (live_range, bb->index);\n-\t  IOR_HARD_REG_SET (*btrs_live_in_range,\n-\t    btrs_live[bb->index]);\n-\t  /* A previous btr migration could have caused a register to be\n-\t     live just at the end of a block which we need in full.  */\n-\t  IOR_HARD_REG_SET (*btrs_live_in_range,\n-\t    btrs_live_at_end[bb->index]);\n-\t  if (dump_file)\n-\t    {\n-\t      fprintf (dump_file,\n-\t\t\"Adding block %d to live range\\n\", bb->index);\n-\t      fprintf (dump_file,\"Now live btrs are \");\n-\t      dump_hard_reg_set (*btrs_live_in_range);\n-\t      fprintf (dump_file, \"\\n\");\n-\t    }\n-\n-\t  FOR_EACH_EDGE (e, ei, bb->preds)\n-\t    {\n-\t      basic_block pred = e->src;\n-\t      if (!bitmap_bit_p (live_range, pred->index))\n-\t\t*tos++ = pred;\n-\t    }\n-\t}\n-    }\n-\n-  free (worklist);\n-}\n-\n-/*  Return the most desirable target register that is not in\n-    the set USED_BTRS.  */\n-static int\n-choose_btr (HARD_REG_SET used_btrs)\n-{\n-  int i;\n-\n-  if (!hard_reg_set_subset_p (all_btrs, used_btrs))\n-    for (i = 0; i < FIRST_PSEUDO_REGISTER; i++)\n-      {\n-#ifdef REG_ALLOC_ORDER\n-\tint regno = reg_alloc_order[i];\n-#else\n-\tint regno = i;\n-#endif\n-\tif (TEST_HARD_REG_BIT (all_btrs, regno)\n-\t    && !TEST_HARD_REG_BIT (used_btrs, regno))\n-\t  return regno;\n-      }\n-  return -1;\n-}\n-\n-/* Calculate the set of basic blocks that contain the live range of\n-   the def/use web DEF.\n-   Also calculate the set of target registers that are live at time\n-   in this live range, but ignore the live range represented by DEF\n-   when calculating this set.  */\n-static void\n-btr_def_live_range (btr_def *def, HARD_REG_SET *btrs_live_in_range)\n-{\n-  if (!def->live_range)\n-    {\n-      btr_user *user;\n-\n-      def->live_range = BITMAP_ALLOC (NULL);\n-\n-      bitmap_set_bit (def->live_range, def->bb->index);\n-      COPY_HARD_REG_SET (*btrs_live_in_range,\n-\t\t\t (flag_btr_bb_exclusive\n-\t\t\t  ? btrs_live : btrs_live_at_end)[def->bb->index]);\n-\n-      for (user = def->uses; user != NULL; user = user->next)\n-\taugment_live_range (def->live_range, btrs_live_in_range,\n-\t\t\t    def->bb, user->bb,\n-\t\t\t    (flag_btr_bb_exclusive\n-\t\t\t     || user->insn != BB_END (def->bb)\n-\t\t\t     || !JUMP_P (user->insn)));\n-    }\n-  else\n-    {\n-      /* def->live_range is accurate, but we need to recompute\n-\t the set of target registers live over it, because migration\n-\t of other PT instructions may have affected it.\n-      */\n-      unsigned bb;\n-      unsigned def_bb = flag_btr_bb_exclusive ? -1 : def->bb->index;\n-      bitmap_iterator bi;\n-\n-      CLEAR_HARD_REG_SET (*btrs_live_in_range);\n-      EXECUTE_IF_SET_IN_BITMAP (def->live_range, 0, bb, bi)\n-\t{\n-\t  IOR_HARD_REG_SET (*btrs_live_in_range,\n-\t\t\t    (def_bb == bb\n-\t\t\t     ? btrs_live_at_end : btrs_live) [bb]);\n-\t}\n-    }\n-  if (!def->other_btr_uses_before_def &&\n-      !def->other_btr_uses_after_use)\n-    CLEAR_HARD_REG_BIT (*btrs_live_in_range, def->btr);\n-}\n-\n-/* Merge into the def/use web DEF any other def/use webs in the same\n-   group that are dominated by DEF, provided that there is a target\n-   register available to allocate to the merged web.  */\n-static void\n-combine_btr_defs (btr_def *def, HARD_REG_SET *btrs_live_in_range)\n-{\n-  btr_def *other_def;\n-\n-  for (other_def = def->group->members;\n-       other_def != NULL;\n-       other_def = other_def->next_this_group)\n-    {\n-      if (other_def != def\n-\t  && other_def->uses != NULL\n-\t  && ! other_def->has_ambiguous_use\n-\t  && dominated_by_p (CDI_DOMINATORS, other_def->bb, def->bb))\n-\t{\n-\t  /* def->bb dominates the other def, so def and other_def could\n-\t     be combined.  */\n-\t  /* Merge their live ranges, and get the set of\n-\t     target registers live over the merged range.  */\n-\t  int btr;\n-\t  HARD_REG_SET combined_btrs_live;\n-\t  auto_bitmap combined_live_range;\n-\t  btr_user *user;\n-\n-\t  if (other_def->live_range == NULL)\n-\t    {\n-\t      HARD_REG_SET dummy_btrs_live_in_range;\n-\t      btr_def_live_range (other_def, &dummy_btrs_live_in_range);\n-\t    }\n-\t  COPY_HARD_REG_SET (combined_btrs_live, *btrs_live_in_range);\n-\t  bitmap_copy (combined_live_range, def->live_range);\n-\n-\t  for (user = other_def->uses; user != NULL; user = user->next)\n-\t    augment_live_range (combined_live_range, &combined_btrs_live,\n-\t\t\t\tdef->bb, user->bb,\n-\t\t\t\t(flag_btr_bb_exclusive\n-\t\t\t\t || user->insn != BB_END (def->bb)\n-\t\t\t\t || !JUMP_P (user->insn)));\n-\n-\t  btr = choose_btr (combined_btrs_live);\n-\t  if (btr != -1)\n-\t    {\n-\t      /* We can combine them.  */\n-\t      if (dump_file)\n-\t\tfprintf (dump_file,\n-\t\t\t \"Combining def in insn %d with def in insn %d\\n\",\n-\t\t\t INSN_UID (other_def->insn), INSN_UID (def->insn));\n-\n-\t      def->btr = btr;\n-\t      user = other_def->uses;\n-\t      while (user != NULL)\n-\t\t{\n-\t\t  btr_user *next = user->next;\n-\n-\t\t  user->next = def->uses;\n-\t\t  def->uses = user;\n-\t\t  user = next;\n-\t\t}\n-\t      /* Combining def/use webs can make target registers live\n-\t\t after uses where they previously were not.  This means\n-\t\t some REG_DEAD notes may no longer be correct.  We could\n-\t\t be more precise about this if we looked at the combined\n-\t\t live range, but here I just delete any REG_DEAD notes\n-\t\t in case they are no longer correct.  */\n-\t      for (user = def->uses; user != NULL; user = user->next)\n-\t\tremove_note (user->insn,\n-\t\t\t     find_regno_note (user->insn, REG_DEAD,\n-\t\t\t\t\t      REGNO (user->use)));\n-\t      clear_btr_from_live_range (other_def);\n-\t      other_def->uses = NULL;\n-\t      bitmap_copy (def->live_range, combined_live_range);\n-\t      if (other_def->btr == btr && other_def->other_btr_uses_after_use)\n-\t\tdef->other_btr_uses_after_use = 1;\n-\t      COPY_HARD_REG_SET (*btrs_live_in_range, combined_btrs_live);\n-\n-\t      /* Delete the old target register initialization.  */\n-\t      delete_insn (other_def->insn);\n-\n-\t    }\n-\t}\n-    }\n-}\n-\n-/* Move the definition DEF from its current position to basic\n-   block NEW_DEF_BB, and modify it to use branch target register BTR.\n-   Delete the old defining insn, and insert a new one in NEW_DEF_BB.\n-   Update all reaching uses of DEF in the RTL to use BTR.\n-   If this new position means that other defs in the\n-   same group can be combined with DEF then combine them.  */\n-static void\n-move_btr_def (basic_block new_def_bb, int btr, btr_def *def, bitmap live_range,\n-\t     HARD_REG_SET *btrs_live_in_range)\n-{\n-  /* We can move the instruction.\n-     Set a target register in block NEW_DEF_BB to the value\n-     needed for this target register definition.\n-     Replace all uses of the old target register definition by\n-     uses of the new definition.  Delete the old definition.  */\n-  basic_block b = new_def_bb;\n-  rtx_insn *insp = BB_HEAD (b);\n-  rtx_insn *old_insn = def->insn;\n-  rtx src;\n-  rtx btr_rtx;\n-  rtx_insn *new_insn;\n-  machine_mode btr_mode;\n-  btr_user *user;\n-  rtx set;\n-\n-  if (dump_file)\n-    fprintf(dump_file, \"migrating to basic block %d, using reg %d\\n\",\n-\t    new_def_bb->index, btr);\n-\n-  clear_btr_from_live_range (def);\n-  def->btr = btr;\n-  def->bb = new_def_bb;\n-  def->luid = 0;\n-  def->cost = basic_block_freq (new_def_bb);\n-  bitmap_copy (def->live_range, live_range);\n-  combine_btr_defs (def, btrs_live_in_range);\n-  btr = def->btr;\n-  def->other_btr_uses_before_def\n-    = TEST_HARD_REG_BIT (btrs_live[b->index], btr) ? 1 : 0;\n-  add_btr_to_live_range (def, 1);\n-  if (LABEL_P (insp))\n-    insp = NEXT_INSN (insp);\n-  /* N.B.: insp is expected to be NOTE_INSN_BASIC_BLOCK now.  Some\n-     optimizations can result in insp being both first and last insn of\n-     its basic block.  */\n-  /* ?? some assertions to check that insp is sensible? */\n-\n-  if (def->other_btr_uses_before_def)\n-    {\n-      for (insp = BB_END (b); ! INSN_P (insp); insp = PREV_INSN (insp))\n-\tgcc_assert (insp != BB_HEAD (b));\n-\n-      if (JUMP_P (insp) || can_throw_internal (insp))\n-\tinsp = PREV_INSN (insp);\n-    }\n-\n-  set = single_set (old_insn);\n-  src = SET_SRC (set);\n-  btr_mode = GET_MODE (SET_DEST (set));\n-  btr_rtx = gen_rtx_REG (btr_mode, btr);\n-\n-  new_insn = gen_move_insn (btr_rtx, src);\n-\n-  /* Insert target register initialization at head of basic block.  */\n-  def->insn = emit_insn_after (new_insn, insp);\n-\n-  df_set_regs_ever_live (btr, true);\n-\n-  if (dump_file)\n-    fprintf (dump_file, \"New pt is insn %d, inserted after insn %d\\n\",\n-\t     INSN_UID (def->insn), INSN_UID (insp));\n-\n-  /* Delete the old target register initialization.  */\n-  delete_insn (old_insn);\n-\n-  /* Replace each use of the old target register by a use of the new target\n-     register.  */\n-  for (user = def->uses; user != NULL; user = user->next)\n-    {\n-      /* Some extra work here to ensure consistent modes, because\n-\t it seems that a target register REG rtx can be given a different\n-\t mode depending on the context (surely that should not be\n-\t the case?).  */\n-      rtx replacement_rtx;\n-      if (GET_MODE (user->use) == GET_MODE (btr_rtx)\n-\t  || GET_MODE (user->use) == VOIDmode)\n-\treplacement_rtx = btr_rtx;\n-      else\n-\treplacement_rtx = gen_rtx_REG (GET_MODE (user->use), btr);\n-      validate_replace_rtx (user->use, replacement_rtx, user->insn);\n-      user->use = replacement_rtx;\n-    }\n-}\n-\n-/* We anticipate intra-block scheduling to be done.  See if INSN could move\n-   up within BB by N_INSNS.  */\n-static int\n-can_move_up (const_basic_block bb, const rtx_insn *insn, int n_insns)\n-{\n-  while (insn != BB_HEAD (bb) && n_insns > 0)\n-    {\n-      insn = PREV_INSN (insn);\n-      /* ??? What if we have an anti-dependency that actually prevents the\n-\t scheduler from doing the move?  We'd like to re-allocate the register,\n-\t but not necessarily put the load into another basic block.  */\n-      if (INSN_P (insn))\n-\tn_insns--;\n-    }\n-  return n_insns <= 0;\n-}\n-\n-/* Attempt to migrate the target register definition DEF to an\n-   earlier point in the flowgraph.\n-\n-   It is a precondition of this function that DEF is migratable:\n-   i.e. it has a constant source, and all uses are unambiguous.\n-\n-   Only migrations that reduce the cost of DEF will be made.\n-   MIN_COST is the lower bound on the cost of the DEF after migration.\n-   If we migrate DEF so that its cost falls below MIN_COST,\n-   then we do not attempt to migrate further.  The idea is that\n-   we migrate definitions in a priority order based on their cost,\n-   when the cost of this definition falls below MIN_COST, then\n-   there is another definition with cost == MIN_COST which now\n-   has a higher priority than this definition.\n-\n-   Return nonzero if there may be benefit from attempting to\n-   migrate this DEF further (i.e. we have reduced the cost below\n-   MIN_COST, but we may be able to reduce it further).\n-   Return zero if no further migration is possible.  */\n-static int\n-migrate_btr_def (btr_def *def, int min_cost)\n-{\n-  HARD_REG_SET btrs_live_in_range;\n-  int btr_used_near_def = 0;\n-  int def_basic_block_freq;\n-  basic_block attempt;\n-  int give_up = 0;\n-  int def_moved = 0;\n-  btr_user *user;\n-  int def_latency;\n-\n-  if (dump_file)\n-    fprintf (dump_file,\n-\t     \"Attempting to migrate pt from insn %d (cost = %d, min_cost = %d) ... \",\n-\t     INSN_UID (def->insn), def->cost, min_cost);\n-\n-  if (!def->group || def->has_ambiguous_use)\n-    /* These defs are not migratable.  */\n-    {\n-      if (dump_file)\n-\tfprintf (dump_file, \"it's not migratable\\n\");\n-      return 0;\n-    }\n-\n-  if (!def->uses)\n-    /* We have combined this def with another in the same group, so\n-       no need to consider it further.\n-    */\n-    {\n-      if (dump_file)\n-\tfprintf (dump_file, \"it's already combined with another pt\\n\");\n-      return 0;\n-    }\n-\n-  btr_def_live_range (def, &btrs_live_in_range);\n-  auto_bitmap live_range;\n-  bitmap_copy (live_range, def->live_range);\n-\n-#ifdef INSN_SCHEDULING\n-  def_latency = insn_default_latency (def->insn) * issue_rate;\n-#else\n-  def_latency = issue_rate;\n-#endif\n-\n-  for (user = def->uses; user != NULL; user = user->next)\n-    {\n-      if (user->bb == def->bb\n-\t  && user->luid > def->luid\n-\t  && (def->luid + def_latency) > user->luid\n-\t  && ! can_move_up (def->bb, def->insn,\n-\t\t\t    (def->luid + def_latency) - user->luid))\n-\t{\n-\t  btr_used_near_def = 1;\n-\t  break;\n-\t}\n-    }\n-\n-  def_basic_block_freq = basic_block_freq (def->bb);\n-\n-  for (attempt = get_immediate_dominator (CDI_DOMINATORS, def->bb);\n-       !give_up && attempt && attempt != ENTRY_BLOCK_PTR_FOR_FN (cfun)\n-       && def->cost >= min_cost;\n-       attempt = get_immediate_dominator (CDI_DOMINATORS, attempt))\n-    {\n-      /* Try to move the instruction that sets the target register into\n-\t basic block ATTEMPT.  */\n-      int try_freq = basic_block_freq (attempt);\n-      edge_iterator ei;\n-      edge e;\n-\n-      /* If ATTEMPT has abnormal edges, skip it.  */\n-      FOR_EACH_EDGE (e, ei, attempt->succs)\n-\tif (e->flags & EDGE_COMPLEX)\n-\t  break;\n-      if (e)\n-\tcontinue;\n-\n-      if (dump_file)\n-\tfprintf (dump_file, \"trying block %d ...\", attempt->index);\n-\n-      if (try_freq < def_basic_block_freq\n-\t  || (try_freq == def_basic_block_freq && btr_used_near_def))\n-\t{\n-\t  int btr;\n-\t  augment_live_range (live_range, &btrs_live_in_range, def->bb, attempt,\n-\t\t\t      flag_btr_bb_exclusive);\n-\t  if (dump_file)\n-\t    {\n-\t      fprintf (dump_file, \"Now btrs live in range are: \");\n-\t      dump_hard_reg_set (btrs_live_in_range);\n-\t      fprintf (dump_file, \"\\n\");\n-\t    }\n-\t  btr = choose_btr (btrs_live_in_range);\n-\t  if (btr != -1)\n-\t    {\n-\t      move_btr_def (attempt, btr, def, live_range, &btrs_live_in_range);\n-\t      bitmap_copy (live_range, def->live_range);\n-\t      btr_used_near_def = 0;\n-\t      def_moved = 1;\n-\t      def_basic_block_freq = basic_block_freq (def->bb);\n-\t    }\n-\t  else\n-\t    {\n-\t      /* There are no free target registers available to move\n-\t\t this far forward, so give up */\n-\t      give_up = 1;\n-\t      if (dump_file)\n-\t\tfprintf (dump_file,\n-\t\t\t \"giving up because there are no free target registers\\n\");\n-\t    }\n-\n-\t}\n-    }\n-  if (!def_moved)\n-    {\n-      give_up = 1;\n-      if (dump_file)\n-\tfprintf (dump_file, \"failed to move\\n\");\n-    }\n-\n-  return !give_up;\n-}\n-\n-/* Attempt to move instructions that set target registers earlier\n-   in the flowgraph, away from their corresponding uses.  */\n-static void\n-migrate_btr_defs (enum reg_class btr_class, int allow_callee_save)\n-{\n-  btr_heap_t all_btr_defs (LONG_MIN);\n-  int reg;\n-\n-  gcc_obstack_init (&migrate_btrl_obstack);\n-  if (dump_file)\n-    {\n-      int i;\n-\n-      for (i = NUM_FIXED_BLOCKS; i < last_basic_block_for_fn (cfun); i++)\n-\t{\n-\t  basic_block bb = BASIC_BLOCK_FOR_FN (cfun, i);\n-\t  fprintf (dump_file, \"Basic block %d: count = \", i);\n-\t  bb->count.dump (dump_file);\n-\t  fprintf (dump_file, \" loop-depth = %d idom = %d\\n\",\n-\t\t   bb_loop_depth (bb),\n-\t\t   get_immediate_dominator (CDI_DOMINATORS, bb)->index);\n-\t}\n-    }\n-\n-  CLEAR_HARD_REG_SET (all_btrs);\n-  for (first_btr = -1, reg = 0; reg < FIRST_PSEUDO_REGISTER; reg++)\n-    if (TEST_HARD_REG_BIT (reg_class_contents[(int) btr_class], reg)\n-\t&& (allow_callee_save || call_used_regs[reg]\n-\t    || df_regs_ever_live_p (reg)))\n-      {\n-\tSET_HARD_REG_BIT (all_btrs, reg);\n-\tlast_btr = reg;\n-\tif (first_btr < 0)\n-\t  first_btr = reg;\n-      }\n-\n-  btrs_live = XCNEWVEC (HARD_REG_SET, last_basic_block_for_fn (cfun));\n-  btrs_live_at_end = XCNEWVEC (HARD_REG_SET, last_basic_block_for_fn (cfun));\n-\n-  build_btr_def_use_webs (&all_btr_defs);\n-\n-  while (!all_btr_defs.empty ())\n-    {\n-      int min_cost = -all_btr_defs.min_key ();\n-      btr_def *def = all_btr_defs.extract_min ();\n-      if (migrate_btr_def (def, min_cost))\n-\t{\n-\t  all_btr_defs.insert (-def->cost, def);\n-\t  if (dump_file)\n-\t    {\n-\t      fprintf (dump_file,\n-\t\t\"Putting insn %d back on queue with priority %d\\n\",\n-\t\tINSN_UID (def->insn), def->cost);\n-\t    }\n-\t}\n-      else\n-\tBITMAP_FREE (def->live_range);\n-    }\n-\n-  free (btrs_live);\n-  free (btrs_live_at_end);\n-  obstack_free (&migrate_btrl_obstack, NULL);\n-}\n-\n-static void\n-branch_target_load_optimize (bool after_prologue_epilogue_gen)\n-{\n-  enum reg_class klass\n-    = (enum reg_class) targetm.branch_target_register_class ();\n-  if (klass != NO_REGS)\n-    {\n-      /* Initialize issue_rate.  */\n-      if (targetm.sched.issue_rate)\n-\tissue_rate = targetm.sched.issue_rate ();\n-      else\n-\tissue_rate = 1;\n-\n-      if (!after_prologue_epilogue_gen)\n-\t{\n-\t  /* Build the CFG for migrate_btr_defs.  */\n-#if 1\n-\t  /* This may or may not be needed, depending on where we\n-\t     run this phase.  */\n-\t  cleanup_cfg (optimize ? CLEANUP_EXPENSIVE : 0);\n-#endif\n-\t}\n-      df_analyze ();\n-\n-\n-      /* Dominator info is also needed for migrate_btr_def.  */\n-      calculate_dominance_info (CDI_DOMINATORS);\n-      migrate_btr_defs (klass,\n-\t\t       (targetm.branch_target_register_callee_saved\n-\t\t\t(after_prologue_epilogue_gen)));\n-\n-      free_dominance_info (CDI_DOMINATORS);\n-    }\n-}\n-\f\n-namespace {\n-\n-const pass_data pass_data_branch_target_load_optimize1 =\n-{\n-  RTL_PASS, /* type */\n-  \"btl1\", /* name */\n-  OPTGROUP_NONE, /* optinfo_flags */\n-  TV_NONE, /* tv_id */\n-  0, /* properties_required */\n-  0, /* properties_provided */\n-  0, /* properties_destroyed */\n-  0, /* todo_flags_start */\n-  0, /* todo_flags_finish */\n-};\n-\n-class pass_branch_target_load_optimize1 : public rtl_opt_pass\n-{\n-public:\n-  pass_branch_target_load_optimize1 (gcc::context *ctxt)\n-    : rtl_opt_pass (pass_data_branch_target_load_optimize1, ctxt)\n-  {}\n-\n-  /* opt_pass methods: */\n-  virtual bool gate (function *) { return flag_branch_target_load_optimize; }\n-  virtual unsigned int execute (function *)\n-    {\n-      branch_target_load_optimize (epilogue_completed);\n-      return 0;\n-    }\n-\n-}; // class pass_branch_target_load_optimize1\n-\n-} // anon namespace\n-\n-rtl_opt_pass *\n-make_pass_branch_target_load_optimize1 (gcc::context *ctxt)\n-{\n-  return new pass_branch_target_load_optimize1 (ctxt);\n-}\n-\n-\n-namespace {\n-\n-const pass_data pass_data_branch_target_load_optimize2 =\n-{\n-  RTL_PASS, /* type */\n-  \"btl2\", /* name */\n-  OPTGROUP_NONE, /* optinfo_flags */\n-  TV_NONE, /* tv_id */\n-  0, /* properties_required */\n-  0, /* properties_provided */\n-  0, /* properties_destroyed */\n-  0, /* todo_flags_start */\n-  0, /* todo_flags_finish */\n-};\n-\n-class pass_branch_target_load_optimize2 : public rtl_opt_pass\n-{\n-public:\n-  pass_branch_target_load_optimize2 (gcc::context *ctxt)\n-    : rtl_opt_pass (pass_data_branch_target_load_optimize2, ctxt)\n-  {}\n-\n-  /* opt_pass methods: */\n-  virtual bool gate (function *)\n-    {\n-      return (optimize > 0 && flag_branch_target_load_optimize2);\n-    }\n-\n-  virtual unsigned int execute (function *);\n-\n-}; // class pass_branch_target_load_optimize2\n-\n-unsigned int\n-pass_branch_target_load_optimize2::execute (function *)\n-{\n-  static int warned = 0;\n-\n-  /* Leave this a warning for now so that it is possible to experiment\n-     with running this pass twice.  In 3.6, we should either make this\n-     an error, or use separate dump files.  */\n-  if (flag_branch_target_load_optimize\n-      && flag_branch_target_load_optimize2\n-      && !warned)\n-    {\n-      warning (0, \"branch target register load optimization is not intended \"\n-\t       \"to be run twice\");\n-\n-      warned = 1;\n-    }\n-\n-  branch_target_load_optimize (epilogue_completed);\n-  return 0;\n-}\n-\n-} // anon namespace\n-\n-rtl_opt_pass *\n-make_pass_branch_target_load_optimize2 (gcc::context *ctxt)\n-{\n-  return new pass_branch_target_load_optimize2 (ctxt);\n-}"}, {"sha": "0d165f5018ad59c1723f121b1851262504895a42", "filename": "gcc/common.opt", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f78f73cbd284abe4f1718fd7803f5f98800de225/gcc%2Fcommon.opt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f78f73cbd284abe4f1718fd7803f5f98800de225/gcc%2Fcommon.opt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcommon.opt?ref=f78f73cbd284abe4f1718fd7803f5f98800de225", "patch": "@@ -1076,16 +1076,16 @@ Common Report Var(flag_branch_probabilities) Optimization\n Use profiling information for branch probabilities.\n \n fbranch-target-load-optimize\n-Common Report Var(flag_branch_target_load_optimize) Optimization\n-Perform branch target load optimization before prologue / epilogue threading.\n+Common Ignore\n+Does nothing.  Preserved for backward compatibility.\n \n fbranch-target-load-optimize2\n-Common Report Var(flag_branch_target_load_optimize2) Optimization\n-Perform branch target load optimization after prologue / epilogue threading.\n+Common Ignore\n+Does nothing.  Preserved for backward compatibility.\n \n fbtr-bb-exclusive\n-Common Report Var(flag_btr_bb_exclusive) Optimization\n-Restrict target load migration not to re-use registers in any basic block.\n+Common Ignore\n+Does nothing.  Preserved for backward compatibility.\n \n fcall-saved-\n Common Joined RejectNegative Var(common_deferred_options) Defer"}, {"sha": "ef23a7d89334086adb2663b83bfc2cce994d5caa", "filename": "gcc/doc/invoke.texi", "status": "modified", "additions": 1, "deletions": 20, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f78f73cbd284abe4f1718fd7803f5f98800de225/gcc%2Fdoc%2Finvoke.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f78f73cbd284abe4f1718fd7803f5f98800de225/gcc%2Fdoc%2Finvoke.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Finvoke.texi?ref=f78f73cbd284abe4f1718fd7803f5f98800de225", "patch": "@@ -406,8 +406,7 @@ Objective-C and Objective-C++ Dialects}.\n -falign-loops[=@var{n}[:@var{m}:[@var{n2}[:@var{m2}]]]] @gol\n -fassociative-math  -fauto-profile  -fauto-profile[=@var{path}] @gol\n -fauto-inc-dec  -fbranch-probabilities @gol\n--fbranch-target-load-optimize  -fbranch-target-load-optimize2 @gol\n--fbtr-bb-exclusive  -fcaller-saves @gol\n+-fcaller-saves @gol\n -fcombine-stack-adjustments  -fconserve-stack @gol\n -fcompare-elim  -fcprop-registers  -fcrossjumping @gol\n -fcse-follow-jumps  -fcse-skip-blocks  -fcx-fortran-rules @gol\n@@ -11025,24 +11024,6 @@ locations inside a translation unit since the locations are unknown until\n link time.  An example of such an optimization is relaxing calls to short call\n instructions.\n \n-@item -fbranch-target-load-optimize\n-@opindex fbranch-target-load-optimize\n-Perform branch target register load optimization before prologue / epilogue\n-threading.\n-The use of target registers can typically be exposed only during reload,\n-thus hoisting loads out of loops and doing inter-block scheduling needs\n-a separate optimization pass.\n-\n-@item -fbranch-target-load-optimize2\n-@opindex fbranch-target-load-optimize2\n-Perform branch target register load optimization after prologue / epilogue\n-threading.\n-\n-@item -fbtr-bb-exclusive\n-@opindex fbtr-bb-exclusive\n-When performing branch target register load optimization, don't reuse\n-branch target registers within any basic block.\n-\n @item -fstdarg-opt\n @opindex fstdarg-opt\n Optimize the prologue of variadic argument functions with respect to usage of"}, {"sha": "7bb8157df6eb7b79825a19d3bd8b6b1df8566e53", "filename": "gcc/doc/tm.texi", "status": "modified", "additions": 0, "deletions": 22, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f78f73cbd284abe4f1718fd7803f5f98800de225/gcc%2Fdoc%2Ftm.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f78f73cbd284abe4f1718fd7803f5f98800de225/gcc%2Fdoc%2Ftm.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Ftm.texi?ref=f78f73cbd284abe4f1718fd7803f5f98800de225", "patch": "@@ -11755,28 +11755,6 @@ cannot_modify_jumps_past_reload_p ()\n @end smallexample\n @end deftypefn\n \n-@deftypefn {Target Hook} reg_class_t TARGET_BRANCH_TARGET_REGISTER_CLASS (void)\n-This target hook returns a register class for which branch target register\n-optimizations should be applied.  All registers in this class should be\n-usable interchangeably.  After reload, registers in this class will be\n-re-allocated and loads will be hoisted out of loops and be subjected\n-to inter-block scheduling.\n-@end deftypefn\n-\n-@deftypefn {Target Hook} bool TARGET_BRANCH_TARGET_REGISTER_CALLEE_SAVED (bool @var{after_prologue_epilogue_gen})\n-Branch target register optimization will by default exclude callee-saved\n-registers\n-that are not already live during the current function; if this target hook\n-returns true, they will be included.  The target code must than make sure\n-that all target registers in the class returned by\n-@samp{TARGET_BRANCH_TARGET_REGISTER_CLASS} that might need saving are\n-saved.  @var{after_prologue_epilogue_gen} indicates if prologues and\n-epilogues have already been generated.  Note, even if you only return\n-true when @var{after_prologue_epilogue_gen} is false, you still are likely\n-to have to make special provisions in @code{INITIAL_ELIMINATION_OFFSET}\n-to reserve space for caller-saved target registers.\n-@end deftypefn\n-\n @deftypefn {Target Hook} bool TARGET_HAVE_CONDITIONAL_EXECUTION (void)\n This target hook returns true if the target supports conditional execution.\n This target hook is required only when the target has several different"}, {"sha": "e926c10d197f003d503a808e6b9ddf48dd8faf1e", "filename": "gcc/doc/tm.texi.in", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f78f73cbd284abe4f1718fd7803f5f98800de225/gcc%2Fdoc%2Ftm.texi.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f78f73cbd284abe4f1718fd7803f5f98800de225/gcc%2Fdoc%2Ftm.texi.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Ftm.texi.in?ref=f78f73cbd284abe4f1718fd7803f5f98800de225", "patch": "@@ -8001,10 +8001,6 @@ build_type_attribute_variant (@var{mdecl},\n \n @hook TARGET_CANNOT_MODIFY_JUMPS_P\n \n-@hook TARGET_BRANCH_TARGET_REGISTER_CLASS\n-\n-@hook TARGET_BRANCH_TARGET_REGISTER_CALLEE_SAVED\n-\n @hook TARGET_HAVE_CONDITIONAL_EXECUTION\n \n @hook TARGET_GEN_CCMP_FIRST"}, {"sha": "1ec94203c81e871c7a395ce874f53e2ea3ce701b", "filename": "gcc/opt-suggestions.c", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f78f73cbd284abe4f1718fd7803f5f98800de225/gcc%2Fopt-suggestions.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f78f73cbd284abe4f1718fd7803f5f98800de225/gcc%2Fopt-suggestions.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fopt-suggestions.c?ref=f78f73cbd284abe4f1718fd7803f5f98800de225", "patch": "@@ -307,7 +307,6 @@ test_completion_valid_options (option_proposer &proposer)\n     \"-Wassign-intercept\",\n     \"-Wno-format-security\",\n     \"-fno-sched-stalled-insns\",\n-    \"-fbtr-bb-exclusive\",\n     \"-fno-tree-tail-merge\",\n     \"-Wlong-long\",\n     \"-Wno-unused-but-set-parameter\","}, {"sha": "93879223a8bc12c3d7b07af0b3c99542d936db4b", "filename": "gcc/passes.def", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f78f73cbd284abe4f1718fd7803f5f98800de225/gcc%2Fpasses.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f78f73cbd284abe4f1718fd7803f5f98800de225/gcc%2Fpasses.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpasses.def?ref=f78f73cbd284abe4f1718fd7803f5f98800de225", "patch": "@@ -461,7 +461,6 @@ along with GCC; see the file COPYING3.  If not see\n \t  NEXT_PASS (pass_split_after_reload);\n \t  NEXT_PASS (pass_ree);\n \t  NEXT_PASS (pass_compare_elim_after_reload);\n-\t  NEXT_PASS (pass_branch_target_load_optimize1);\n \t  NEXT_PASS (pass_thread_prologue_and_epilogue);\n \t  NEXT_PASS (pass_rtl_dse2);\n \t  NEXT_PASS (pass_stack_adjustments);\n@@ -474,7 +473,6 @@ along with GCC; see the file COPYING3.  If not see\n \t  NEXT_PASS (pass_cprop_hardreg);\n \t  NEXT_PASS (pass_fast_rtl_dce);\n \t  NEXT_PASS (pass_reorder_blocks);\n-\t  NEXT_PASS (pass_branch_target_load_optimize2);\n \t  NEXT_PASS (pass_leaf_regs);\n \t  NEXT_PASS (pass_split_before_sched2);\n \t  NEXT_PASS (pass_sched2);"}, {"sha": "825c1e6d307501bf2da631a0ab85ae081d0fe532", "filename": "gcc/target.def", "status": "modified", "additions": 0, "deletions": 32, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f78f73cbd284abe4f1718fd7803f5f98800de225/gcc%2Ftarget.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f78f73cbd284abe4f1718fd7803f5f98800de225/gcc%2Ftarget.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftarget.def?ref=f78f73cbd284abe4f1718fd7803f5f98800de225", "patch": "@@ -2597,38 +2597,6 @@ DEFHOOK\n  bool, (const rtx_insn *follower, const rtx_insn *followee),\n  hook_bool_const_rtx_insn_const_rtx_insn_true)\n \n-/* Return a register class for which branch target register\n-   optimizations should be applied.  */\n-DEFHOOK\n-(branch_target_register_class,\n- \"This target hook returns a register class for which branch target register\\n\\\n-optimizations should be applied.  All registers in this class should be\\n\\\n-usable interchangeably.  After reload, registers in this class will be\\n\\\n-re-allocated and loads will be hoisted out of loops and be subjected\\n\\\n-to inter-block scheduling.\",\n- reg_class_t, (void),\n- default_branch_target_register_class)\n-\n-/* Return true if branch target register optimizations should include\n-   callee-saved registers that are not already live during the current\n-   function.  AFTER_PE_GEN is true if prologues and epilogues have\n-   already been generated.  */\n-DEFHOOK\n-(branch_target_register_callee_saved,\n- \"Branch target register optimization will by default exclude callee-saved\\n\\\n-registers\\n\\\n-that are not already live during the current function; if this target hook\\n\\\n-returns true, they will be included.  The target code must than make sure\\n\\\n-that all target registers in the class returned by\\n\\\n-@samp{TARGET_BRANCH_TARGET_REGISTER_CLASS} that might need saving are\\n\\\n-saved.  @var{after_prologue_epilogue_gen} indicates if prologues and\\n\\\n-epilogues have already been generated.  Note, even if you only return\\n\\\n-true when @var{after_prologue_epilogue_gen} is false, you still are likely\\n\\\n-to have to make special provisions in @code{INITIAL_ELIMINATION_OFFSET}\\n\\\n-to reserve space for caller-saved target registers.\",\n- bool, (bool after_prologue_epilogue_gen),\n- hook_bool_bool_false)\n-\n /* Return true if the target supports conditional execution.  */\n DEFHOOK\n (have_conditional_execution,"}, {"sha": "ed77afb1da57e59bc0725dc0d6fac477391bae03", "filename": "gcc/targhooks.c", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f78f73cbd284abe4f1718fd7803f5f98800de225/gcc%2Ftarghooks.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f78f73cbd284abe4f1718fd7803f5f98800de225/gcc%2Ftarghooks.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftarghooks.c?ref=f78f73cbd284abe4f1718fd7803f5f98800de225", "patch": "@@ -1053,12 +1053,6 @@ default_return_pops_args (tree, tree, poly_int64)\n   return 0;\n }\n \n-reg_class_t\n-default_branch_target_register_class (void)\n-{\n-  return NO_REGS;\n-}\n-\n reg_class_t\n default_ira_change_pseudo_allocno_class (int regno ATTRIBUTE_UNUSED,\n \t\t\t\t\t reg_class_t cl,"}, {"sha": "5aba67660f85406b9fd475e75a3cc65b0d1952f5", "filename": "gcc/targhooks.h", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f78f73cbd284abe4f1718fd7803f5f98800de225/gcc%2Ftarghooks.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f78f73cbd284abe4f1718fd7803f5f98800de225/gcc%2Ftarghooks.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftarghooks.h?ref=f78f73cbd284abe4f1718fd7803f5f98800de225", "patch": "@@ -164,7 +164,6 @@ extern rtx default_internal_arg_pointer (void);\n extern rtx default_static_chain (const_tree, bool);\n extern void default_trampoline_init (rtx, tree, rtx);\n extern poly_int64 default_return_pops_args (tree, tree, poly_int64);\n-extern reg_class_t default_branch_target_register_class (void);\n extern reg_class_t default_ira_change_pseudo_allocno_class (int, reg_class_t,\n \t\t\t\t\t\t\t    reg_class_t);\n extern bool default_lra_p (void);"}, {"sha": "7106eba54af1dcf85a434f0a7ac94a41ddd85f25", "filename": "gcc/tree-pass.h", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f78f73cbd284abe4f1718fd7803f5f98800de225/gcc%2Ftree-pass.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f78f73cbd284abe4f1718fd7803f5f98800de225/gcc%2Ftree-pass.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-pass.h?ref=f78f73cbd284abe4f1718fd7803f5f98800de225", "patch": "@@ -585,8 +585,6 @@ extern rtl_opt_pass *make_pass_postreload_jump (gcc::context *ctxt);\n extern rtl_opt_pass *make_pass_postreload_cse (gcc::context *ctxt);\n extern rtl_opt_pass *make_pass_gcse2 (gcc::context *ctxt);\n extern rtl_opt_pass *make_pass_split_after_reload (gcc::context *ctxt);\n-extern rtl_opt_pass *make_pass_branch_target_load_optimize1 (gcc::context\n-\t\t\t\t\t\t\t     *ctxt);\n extern rtl_opt_pass *make_pass_thread_prologue_and_epilogue (gcc::context\n \t\t\t\t\t\t\t     *ctxt);\n extern rtl_opt_pass *make_pass_stack_adjustments (gcc::context *ctxt);\n@@ -596,8 +594,6 @@ extern rtl_opt_pass *make_pass_if_after_reload (gcc::context *ctxt);\n extern rtl_opt_pass *make_pass_regrename (gcc::context *ctxt);\n extern rtl_opt_pass *make_pass_cprop_hardreg (gcc::context *ctxt);\n extern rtl_opt_pass *make_pass_reorder_blocks (gcc::context *ctxt);\n-extern rtl_opt_pass *make_pass_branch_target_load_optimize2 (gcc::context\n-\t\t\t\t\t\t\t     *ctxt);\n extern rtl_opt_pass *make_pass_leaf_regs (gcc::context *ctxt);\n extern rtl_opt_pass *make_pass_split_before_sched2 (gcc::context *ctxt);\n extern rtl_opt_pass *make_pass_compare_elim_after_reload (gcc::context *ctxt);"}]}