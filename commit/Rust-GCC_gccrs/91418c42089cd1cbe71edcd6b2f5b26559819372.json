{"sha": "91418c42089cd1cbe71edcd6b2f5b26559819372", "node_id": "C_kwDOANBUbNoAKDkxNDE4YzQyMDg5Y2QxY2JlNzFlZGNkNmIyZjViMjY1NTk4MTkzNzI", "commit": {"author": {"name": "Iain Buclaw", "email": "ibuclaw@gdcproject.org", "date": "2022-06-23T16:24:07Z"}, "committer": {"name": "Iain Buclaw", "email": "ibuclaw@gdcproject.org", "date": "2022-06-24T18:49:58Z"}, "message": "d: Add `@register' attribute to compiler and library.\n\nThe `@register` attribute specifies that a local or `__gshared` variable\nis to be given a register storage-class in the C sense of the term, and\nwill be placed into a register named `registerName`.\n\nThe variable needs to boiled down to a data type that fits the target\nregister.  It also cannot have either thread-local or `extern` storage.\nIt is an error to take the address of a register variable.\n\n\tPR d/105413\n\ngcc/d/ChangeLog:\n\n\t* d-attribs.cc (d_handle_register_attribute): New function.\n\t(d_langhook_attribute_table): Add register attribute.\n\t* d-codegen.cc (d_mark_addressable): Error if taken address of\n\tregister variable.\n\t(build_frame_type): Error if register variable has non-local\n\treferences.\n\t* d-tree.h (d_mark_addressable): Add complain parameter.\n\t* decl.cc (get_symbol_decl): Mark register varibles DECL_REGISTER.\n\tError when register variable declared thread-local or extern.\n\t* expr.cc (ExprVisitor::visit (IndexExp *)): Don't complain about\n\tmarking register vectors as addressable in an ARRAY_REF.\n\nlibphobos/ChangeLog:\n\n\t* libdruntime/gcc/attributes.d (register): Define.\n\ngcc/testsuite/ChangeLog:\n\n\t* gdc.dg/attr_register1.d: New test.\n\t* gdc.dg/attr_register2.d: New test.\n\t* gdc.dg/attr_register3.d: New test.", "tree": {"sha": "6419c5301b4fb08e5b0cac64baddc66f7e3acadf", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6419c5301b4fb08e5b0cac64baddc66f7e3acadf"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/91418c42089cd1cbe71edcd6b2f5b26559819372", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/91418c42089cd1cbe71edcd6b2f5b26559819372", "html_url": "https://github.com/Rust-GCC/gccrs/commit/91418c42089cd1cbe71edcd6b2f5b26559819372", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/91418c42089cd1cbe71edcd6b2f5b26559819372/comments", "author": {"login": "ibuclaw", "id": 397929, "node_id": "MDQ6VXNlcjM5NzkyOQ==", "avatar_url": "https://avatars.githubusercontent.com/u/397929?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ibuclaw", "html_url": "https://github.com/ibuclaw", "followers_url": "https://api.github.com/users/ibuclaw/followers", "following_url": "https://api.github.com/users/ibuclaw/following{/other_user}", "gists_url": "https://api.github.com/users/ibuclaw/gists{/gist_id}", "starred_url": "https://api.github.com/users/ibuclaw/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ibuclaw/subscriptions", "organizations_url": "https://api.github.com/users/ibuclaw/orgs", "repos_url": "https://api.github.com/users/ibuclaw/repos", "events_url": "https://api.github.com/users/ibuclaw/events{/privacy}", "received_events_url": "https://api.github.com/users/ibuclaw/received_events", "type": "User", "site_admin": false}, "committer": {"login": "ibuclaw", "id": 397929, "node_id": "MDQ6VXNlcjM5NzkyOQ==", "avatar_url": "https://avatars.githubusercontent.com/u/397929?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ibuclaw", "html_url": "https://github.com/ibuclaw", "followers_url": "https://api.github.com/users/ibuclaw/followers", "following_url": "https://api.github.com/users/ibuclaw/following{/other_user}", "gists_url": "https://api.github.com/users/ibuclaw/gists{/gist_id}", "starred_url": "https://api.github.com/users/ibuclaw/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ibuclaw/subscriptions", "organizations_url": "https://api.github.com/users/ibuclaw/orgs", "repos_url": "https://api.github.com/users/ibuclaw/repos", "events_url": "https://api.github.com/users/ibuclaw/events{/privacy}", "received_events_url": "https://api.github.com/users/ibuclaw/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8288cd635fa0bd75a8c5f25c7a90d4a7a4acec81", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8288cd635fa0bd75a8c5f25c7a90d4a7a4acec81", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8288cd635fa0bd75a8c5f25c7a90d4a7a4acec81"}], "stats": {"total": 216, "additions": 204, "deletions": 12}, "files": [{"sha": "23bbe3946fb5d5c337e29f7ac6513840db7b2718", "filename": "gcc/d/d-attribs.cc", "status": "modified", "additions": 38, "deletions": 2, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/91418c42089cd1cbe71edcd6b2f5b26559819372/gcc%2Fd%2Fd-attribs.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/91418c42089cd1cbe71edcd6b2f5b26559819372/gcc%2Fd%2Fd-attribs.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fd-attribs.cc?ref=91418c42089cd1cbe71edcd6b2f5b26559819372", "patch": "@@ -75,6 +75,7 @@ static tree d_handle_weak_attribute (tree *, tree, tree, int, bool *) ;\n static tree d_handle_noplt_attribute (tree *, tree, tree, int, bool *) ;\n static tree d_handle_alloc_size_attribute (tree *, tree, tree, int, bool *);\n static tree d_handle_cold_attribute (tree *, tree, tree, int, bool *);\n+static tree d_handle_register_attribute (tree *, tree, tree, int, bool *);\n static tree d_handle_restrict_attribute (tree *, tree, tree, int, bool *);\n static tree d_handle_used_attribute (tree *, tree, tree, int, bool *);\n static tree d_handle_visibility_attribute (tree *, tree, tree, int, bool *);\n@@ -223,6 +224,8 @@ const attribute_spec d_langhook_attribute_table[] =\n \t     d_handle_cold_attribute, attr_cold_hot_exclusions),\n   ATTR_SPEC (\"no_sanitize\", 1, -1, true, false, false, false,\n \t     d_handle_no_sanitize_attribute, NULL),\n+  ATTR_SPEC (\"register\", 1, 1, true, false, false, false,\n+\t     d_handle_register_attribute, NULL),\n   ATTR_SPEC (\"restrict\", 0, 0, true, false, false, false,\n \t     d_handle_restrict_attribute, NULL),\n   ATTR_SPEC (\"used\", 0, 0, true, false, false, false,\n@@ -1409,8 +1412,41 @@ d_handle_no_sanitize_attribute (tree *node, tree name, tree args, int,\n   else\n     {\n       DECL_ATTRIBUTES (*node) = tree_cons (get_identifier (\"no_sanitize\"),\n-\t\t      \t\t\t   build_int_cst (d_uint_type, flags),\n-\t\t      \t\t\t   DECL_ATTRIBUTES (*node));\n+\t\t\t\t\t   build_int_cst (d_uint_type, flags),\n+\t\t\t\t\t   DECL_ATTRIBUTES (*node));\n+    }\n+\n+  return NULL_TREE;\n+}\n+\n+/* Handle a \"register\" attribute; arguments as in\n+   struct attribute_spec.handler.  */\n+\n+static tree\n+d_handle_register_attribute (tree *node, tree name, tree args, int,\n+\t\t\t     bool *no_add_attrs)\n+{\n+  if (!VAR_P (*node))\n+    {\n+      warning (OPT_Wattributes, \"%qE attribute ignored\", name);\n+      *no_add_attrs = true;\n+    }\n+  else if (TREE_CODE (TREE_VALUE (args)) != STRING_CST)\n+    {\n+      error (\"%qE attribute argument not a string constant\", name);\n+      *no_add_attrs = true;\n+    }\n+  else if (TREE_STRING_LENGTH (TREE_VALUE (args)) == 0\n+\t   || TREE_STRING_POINTER (TREE_VALUE (args))[0] == '\\0')\n+    {\n+      error (\"register name not specified for %q+D\", *node);\n+      *no_add_attrs = true;\n+    }\n+  else\n+    {\n+      DECL_REGISTER (*node) = 1;\n+      set_user_assembler_name (*node, TREE_STRING_POINTER (TREE_VALUE (args)));\n+      DECL_HARD_REGISTER (*node) = 1;\n     }\n \n   return NULL_TREE;"}, {"sha": "8a8bf12e7fc13363353cf6de602a8f099a2c2543", "filename": "gcc/d/d-codegen.cc", "status": "modified", "additions": 26, "deletions": 6, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/91418c42089cd1cbe71edcd6b2f5b26559819372/gcc%2Fd%2Fd-codegen.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/91418c42089cd1cbe71edcd6b2f5b26559819372/gcc%2Fd%2Fd-codegen.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fd-codegen.cc?ref=91418c42089cd1cbe71edcd6b2f5b26559819372", "patch": "@@ -697,11 +697,12 @@ build_address (tree exp)\n   return compound_expr (init, exp);\n }\n \n-/* Mark EXP saying that we need to be able to take the\n-   address of it; it should not be allocated in a register.  */\n+/* Mark EXP saying that we need to be able to take the address of it; it should\n+   not be allocated in a register.  When COMPLAIN is true, issue an error if we\n+   are marking a register variable.  */\n \n tree\n-d_mark_addressable (tree exp)\n+d_mark_addressable (tree exp, bool complain)\n {\n   switch (TREE_CODE (exp))\n     {\n@@ -713,12 +714,22 @@ d_mark_addressable (tree exp)\n       d_mark_addressable (TREE_OPERAND (exp, 0));\n       break;\n \n-    case PARM_DECL:\n     case VAR_DECL:\n+      if (complain && DECL_REGISTER (exp))\n+\t{\n+\t  if (DECL_HARD_REGISTER (exp) || DECL_EXTERNAL (exp))\n+\t    error (\"address of explicit register variable %qD requested\", exp);\n+\t  else\n+\t    error (\"address of register variable %qD requested\", exp);\n+\t}\n+\n+      /* Fall through.  */\n+    case PARM_DECL:\n     case RESULT_DECL:\n     case CONST_DECL:\n     case FUNCTION_DECL:\n-      TREE_ADDRESSABLE (exp) = 1;\n+      if (!VAR_P (exp) || !DECL_HARD_REGISTER (exp))\n+\tTREE_ADDRESSABLE (exp) = 1;\n       break;\n \n     case CONSTRUCTOR:\n@@ -2704,7 +2715,16 @@ build_frame_type (tree ffi, FuncDeclaration *fd)\n \t  if ((v->edtor && (v->storage_class & STCparameter))\n \t      || v->needsScopeDtor ())\n \t    error_at (make_location_t (v->loc),\n-\t\t      \"has scoped destruction, cannot build closure\");\n+\t\t      \"variable %qs has scoped destruction, \"\n+\t\t      \"cannot build closure\", v->toChars ());\n+\t}\n+\n+      if (DECL_REGISTER (vsym))\n+\t{\n+\t  /* Because the value will be in memory, not a register.  */\n+\t  error_at (make_location_t (v->loc),\n+\t\t    \"explicit register variable %qs cannot be used in nested \"\n+\t\t    \"function\", v->toChars ());\n \t}\n     }\n "}, {"sha": "c3e95e4d2d2cdd43cfc762b89b5f0776802c5519", "filename": "gcc/d/d-tree.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/91418c42089cd1cbe71edcd6b2f5b26559819372/gcc%2Fd%2Fd-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/91418c42089cd1cbe71edcd6b2f5b26559819372/gcc%2Fd%2Fd-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fd-tree.h?ref=91418c42089cd1cbe71edcd6b2f5b26559819372", "patch": "@@ -549,7 +549,7 @@ extern tree stabilize_expr (tree *);\n extern tree build_target_expr (tree, tree);\n extern tree force_target_expr (tree);\n extern tree build_address (tree);\n-extern tree d_mark_addressable (tree);\n+extern tree d_mark_addressable (tree, bool = true);\n extern tree d_mark_used (tree);\n extern tree d_mark_read (tree);\n extern tree build_memcmp_call (tree, tree, tree);"}, {"sha": "5032ae02d6b74abbdeacbb5cae1f9bc66a866883", "filename": "gcc/d/decl.cc", "status": "modified", "additions": 22, "deletions": 2, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/91418c42089cd1cbe71edcd6b2f5b26559819372/gcc%2Fd%2Fdecl.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/91418c42089cd1cbe71edcd6b2f5b26559819372/gcc%2Fd%2Fdecl.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdecl.cc?ref=91418c42089cd1cbe71edcd6b2f5b26559819372", "patch": "@@ -670,10 +670,14 @@ class DeclVisitor : public Visitor\n \t    rest_of_decl_compilation (decl, 1, 0);\n \t  }\n       }\n-    else if (d->isDataseg () && !(d->storage_class & STCextern))\n+    else if (d->isDataseg ())\n       {\n \ttree decl = get_symbol_decl (d);\n \n+\t/* Only need to build the VAR_DECL for extern declarations.  */\n+\tif (d->storage_class & STCextern)\n+\t  return;\n+\n \t/* Duplicated VarDeclarations map to the same symbol.  Check if this\n \t   is the one declaration which will be emitted.  */\n \ttree ident = DECL_ASSEMBLER_NAME (decl);\n@@ -1343,7 +1347,11 @@ get_symbol_decl (Declaration *decl)\n   if (decl->storage_class & STCvolatile)\n     TREE_THIS_VOLATILE (decl->csym) = 1;\n \n-  /* Likewise, so could the deprecated attribute.  */\n+  /* Symbol was marked register.  */\n+  if (decl->storage_class & STCregister)\n+    DECL_REGISTER (decl->csym) = 1;\n+\n+  /* Symbol was declared with deprecated attribute.  */\n   if (decl->storage_class & STCdeprecated)\n     TREE_DEPRECATED (decl->csym) = 1;\n \n@@ -1376,6 +1384,18 @@ get_symbol_decl (Declaration *decl)\n   /* Apply any user attributes that may affect semantic meaning.  */\n   apply_user_attributes (decl, decl->csym);\n \n+  /* Handle any conflicts between D language attributes and compiler-recognized\n+   * user attributes.  */\n+  if (VAR_P (decl->csym) && DECL_HARD_REGISTER (decl->csym))\n+    {\n+      if (decl->storage_class & STCextern)\n+\terror_at (make_location_t (decl->loc), \"explicit register variable \"\n+\t\t  \"%qs declared %<extern%>\", decl->toChars ());\n+      else if (decl->isThreadlocal ())\n+\terror_at (make_location_t (decl->loc), \"explicit register variable \"\n+\t\t  \"%qs declared thread local\", decl->toChars ());\n+    }\n+\n   /* %% Probably should be a little more intelligent about setting this.  */\n   TREE_USED (decl->csym) = 1;\n   d_keep (decl->csym);"}, {"sha": "34b3ddd3f10f0b76c403ff66884bee6b43dcbeb8", "filename": "gcc/d/expr.cc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/91418c42089cd1cbe71edcd6b2f5b26559819372/gcc%2Fd%2Fexpr.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/91418c42089cd1cbe71edcd6b2f5b26559819372/gcc%2Fd%2Fexpr.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fexpr.cc?ref=91418c42089cd1cbe71edcd6b2f5b26559819372", "patch": "@@ -1250,7 +1250,7 @@ class ExprVisitor : public Visitor\n \t    tree array_type =\n \t      build_array_type_nelts (TREE_TYPE (TREE_TYPE (array)),\n \t\t\t\t      TYPE_VECTOR_SUBPARTS (TREE_TYPE (array)));\n-\t    d_mark_addressable (array);\n+\t    d_mark_addressable (array, false);\n \t    array = build1 (VIEW_CONVERT_EXPR, array_type, array);\n \t  }\n "}, {"sha": "01fc245ab4032bec3229b845a885ddb214681b6a", "filename": "gcc/testsuite/gdc.dg/attr_register1.d", "status": "added", "additions": 55, "deletions": 0, "changes": 55, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/91418c42089cd1cbe71edcd6b2f5b26559819372/gcc%2Ftestsuite%2Fgdc.dg%2Fattr_register1.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/91418c42089cd1cbe71edcd6b2f5b26559819372/gcc%2Ftestsuite%2Fgdc.dg%2Fattr_register1.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.dg%2Fattr_register1.d?ref=91418c42089cd1cbe71edcd6b2f5b26559819372", "patch": "@@ -0,0 +1,55 @@\n+// { dg-do compile }\n+\n+import gcc.attributes;\n+\n+@attribute(\"register\", null) int var1; // { dg-error \"attribute argument not a string constant\" }\n+\n+@attribute(\"register\", \"\") int var2; // { dg-error \"register name not specified for .var2.\" }\n+\n+@attribute(\"register\", \"invalid\") __gshared int var3; // { dg-error \"invalid register name for .var3.\" }\n+\n+void f1(ref int r) { }\n+\n+void test1()\n+{\n+    @register(\"ref\") int var6;\n+    f1(var6); // { dg-error \"address of explicit register variable .var6. requested\" }\n+}\n+\n+void f2(out int r) { }\n+\n+void test2()\n+{\n+    @register(\"out\") int var7;\n+    f2(var7); // { dg-error \"address of explicit register variable .var7. requested\" }\n+}\n+\n+void f3(lazy int r) { }\n+\n+void test3()\n+{\n+    @register(\"lazy\") int var8; // { dg-error \"explicit register variable .var8. cannot be used in nested function\" }\n+    f3(var8);\n+}\n+\n+void test4()\n+{\n+    @register(\"addr\") int var9;\n+    auto ptr3 = &var9; // { dg-error \"address of explicit register variable .var9. requested\" }\n+}\n+\n+ref int test5()\n+{\n+    @register(\"refreturn\") __gshared int var10; // { dg-error \"invalid register name\" }\n+    return var10; // { dg-error \"address of explicit register variable .var10. requested\" }\n+}\n+\n+auto test6()\n+{\n+    @register(\"closure\") int var11; // { dg-error \"explicit register variable .var11. cannot be used in nested function\" }\n+    int nested()\n+    {\n+        return var11;\n+    }\n+    return &nested;\n+}"}, {"sha": "9061a643f31f489c9f79c50589724e16c5d67480", "filename": "gcc/testsuite/gdc.dg/attr_register2.d", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/91418c42089cd1cbe71edcd6b2f5b26559819372/gcc%2Ftestsuite%2Fgdc.dg%2Fattr_register2.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/91418c42089cd1cbe71edcd6b2f5b26559819372/gcc%2Ftestsuite%2Fgdc.dg%2Fattr_register2.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.dg%2Fattr_register2.d?ref=91418c42089cd1cbe71edcd6b2f5b26559819372", "patch": "@@ -0,0 +1,11 @@\n+// { dg-do compile  { target x86_64-*-* } }\n+\n+import gcc.attributes;\n+\n+@register(\"ebx\") static int var1 = void; // { dg-error \"explicit register variable .var1. declared thread local\" }\n+\n+@register(\"ebx\") extern int var2; // { dg-error \"explicit register variable .var2. declared .extern.\" }\n+\n+@register(\"r12\") __gshared int var3 = 0x2a; // { dg-error \"global register variable has initial value\" }\n+\n+@register(\"r12\") __gshared int[256] var4 = void; // { dg-error \"data type of .var4. isn.t suitable for a register\" }"}, {"sha": "706a39985d4fc2a0c1c2e1ec7c81941daca35400", "filename": "gcc/testsuite/gdc.dg/attr_register3.d", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/91418c42089cd1cbe71edcd6b2f5b26559819372/gcc%2Ftestsuite%2Fgdc.dg%2Fattr_register3.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/91418c42089cd1cbe71edcd6b2f5b26559819372/gcc%2Ftestsuite%2Fgdc.dg%2Fattr_register3.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.dg%2Fattr_register3.d?ref=91418c42089cd1cbe71edcd6b2f5b26559819372", "patch": "@@ -0,0 +1,22 @@\n+// { dg-do compile }\n+// { dg-options \"-Wall -O2 -fdump-tree-optimized\" }\n+\n+import gcc.attributes;\n+\n+pragma(inline, true)\n+void syscall()(int val)\n+{\n+    @register(\"4\") int reg = val;\n+    asm { \"/* Some Code %0 */\" :: \"r\" (reg); }\n+}\n+\n+void do_syscalls()\n+{\n+    for (int s = 0; s < 2; s++)\n+    {\n+        syscall (0);\n+        syscall (1);\n+    }\n+}\n+\n+// { dg-final { scan-tree-dump-times \"reg = \" 4 \"optimized\" } }"}, {"sha": "40a18bfa94774044e978726729dd114ccc12cf82", "filename": "libphobos/libdruntime/gcc/attributes.d", "status": "modified", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/91418c42089cd1cbe71edcd6b2f5b26559819372/libphobos%2Flibdruntime%2Fgcc%2Fattributes.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/91418c42089cd1cbe71edcd6b2f5b26559819372/libphobos%2Flibdruntime%2Fgcc%2Fattributes.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Flibdruntime%2Fgcc%2Fattributes.d?ref=91418c42089cd1cbe71edcd6b2f5b26559819372", "patch": "@@ -301,6 +301,34 @@ auto optimize(A...)(A arguments)\n     assert(false, \"optimize attribute argument not a string or integer constant\");\n }\n \n+/**\n+ * The `@register` attribute specifies that a local or `__gshared` variable\n+ * is to be given a register storage-class in the C99 sense of the term, and\n+ * will be placed into a register named `registerName`.\n+ *\n+ * The variable needs to boiled down to a data type that fits the target\n+ * register.  It also cannot have either thread-local or `extern` storage.\n+ * It is an error to take the address of a register variable.\n+ *\n+ * Example:\n+ * ---\n+ * import gcc.attributes;\n+ *\n+ * @register(\"ebx\") __gshared int ebx = void;\n+ *\n+ * void func() { @register(\"r10\") long r10 = 0x2a; }\n+ * ---\n+ */\n+auto register(string registerName)\n+{\n+    return attribute(\"register\", registerName);\n+}\n+\n+auto register(A...)(A arguments)\n+{\n+    assert(false, \"register attribute argument not a string constant\");\n+}\n+\n /**\n  * The `@restrict` attribute specifies that a function parameter is to be\n  * restrict-qualified in the C99 sense of the term.  The parameter needs to"}]}