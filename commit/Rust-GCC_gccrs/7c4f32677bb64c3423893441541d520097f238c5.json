{"sha": "7c4f32677bb64c3423893441541d520097f238c5", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6N2M0ZjMyNjc3YmI2NGMzNDIzODkzNDQxNTQxZDUyMDA5N2YyMzhjNQ==", "commit": {"author": {"name": "Bob Duff", "email": "duff@adacore.com", "date": "2021-04-23T12:17:28Z"}, "committer": {"name": "Pierre-Marie de Rodat", "email": "derodat@adacore.com", "date": "2021-07-05T13:09:09Z"}, "message": "[Ada] Clean up Get_Index_Bounds\n\ngcc/ada/\n\n\t* checks.adb, exp_aggr.adb, exp_ch5.adb, freeze.adb,\n\tsem_util.adb, sem_util.ads: Change L and H to be First and Last,\n\tto match the attributes in the RM. Change calls from procedure\n\tto function where appropriate.", "tree": {"sha": "56e9c4dce17b951a7be9380e4eb1eb2b4d078ee0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/56e9c4dce17b951a7be9380e4eb1eb2b4d078ee0"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/7c4f32677bb64c3423893441541d520097f238c5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7c4f32677bb64c3423893441541d520097f238c5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7c4f32677bb64c3423893441541d520097f238c5", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7c4f32677bb64c3423893441541d520097f238c5/comments", "author": {"login": "bobduff", "id": 29099567, "node_id": "MDQ6VXNlcjI5MDk5NTY3", "avatar_url": "https://avatars.githubusercontent.com/u/29099567?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bobduff", "html_url": "https://github.com/bobduff", "followers_url": "https://api.github.com/users/bobduff/followers", "following_url": "https://api.github.com/users/bobduff/following{/other_user}", "gists_url": "https://api.github.com/users/bobduff/gists{/gist_id}", "starred_url": "https://api.github.com/users/bobduff/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bobduff/subscriptions", "organizations_url": "https://api.github.com/users/bobduff/orgs", "repos_url": "https://api.github.com/users/bobduff/repos", "events_url": "https://api.github.com/users/bobduff/events{/privacy}", "received_events_url": "https://api.github.com/users/bobduff/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pmderodat", "id": 758452, "node_id": "MDQ6VXNlcjc1ODQ1Mg==", "avatar_url": "https://avatars.githubusercontent.com/u/758452?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pmderodat", "html_url": "https://github.com/pmderodat", "followers_url": "https://api.github.com/users/pmderodat/followers", "following_url": "https://api.github.com/users/pmderodat/following{/other_user}", "gists_url": "https://api.github.com/users/pmderodat/gists{/gist_id}", "starred_url": "https://api.github.com/users/pmderodat/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pmderodat/subscriptions", "organizations_url": "https://api.github.com/users/pmderodat/orgs", "repos_url": "https://api.github.com/users/pmderodat/repos", "events_url": "https://api.github.com/users/pmderodat/events{/privacy}", "received_events_url": "https://api.github.com/users/pmderodat/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8926c29c5f512203b6ed6e1e944738fc0a6f0c4c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8926c29c5f512203b6ed6e1e944738fc0a6f0c4c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8926c29c5f512203b6ed6e1e944738fc0a6f0c4c"}], "stats": {"total": 511, "additions": 266, "deletions": 245}, "files": [{"sha": "6c49e671e919332985b93b1fe27daf48b378a709", "filename": "gcc/ada/checks.adb", "status": "modified", "additions": 36, "deletions": 33, "changes": 69, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7c4f32677bb64c3423893441541d520097f238c5/gcc%2Fada%2Fchecks.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7c4f32677bb64c3423893441541d520097f238c5/gcc%2Fada%2Fchecks.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fchecks.adb?ref=7c4f32677bb64c3423893441541d520097f238c5", "patch": "@@ -9931,8 +9931,7 @@ package body Checks is\n \n             declare\n                Indx_Type : Node_Id;\n-               Lo        : Node_Id;\n-               Hi        : Node_Id;\n+               Bounds    : Range_Nodes;\n                Do_Expand : Boolean := False;\n \n             begin\n@@ -9942,37 +9941,38 @@ package body Checks is\n                   Next_Index (Indx_Type);\n                end loop;\n \n-               Get_Index_Bounds (Indx_Type, Lo, Hi);\n+               Bounds := Get_Index_Bounds (Indx_Type);\n \n-               if Nkind (Lo) = N_Identifier\n-                 and then Ekind (Entity (Lo)) = E_In_Parameter\n+               if Nkind (Bounds.First) = N_Identifier\n+                 and then Ekind (Entity (Bounds.First)) = E_In_Parameter\n                then\n-                  Lo := Get_Discriminal (E, Lo);\n+                  Bounds.First := Get_Discriminal (E, Bounds.First);\n                   Do_Expand := True;\n                end if;\n \n-               if Nkind (Hi) = N_Identifier\n-                 and then Ekind (Entity (Hi)) = E_In_Parameter\n+               if Nkind (Bounds.Last) = N_Identifier\n+                 and then Ekind (Entity (Bounds.Last)) = E_In_Parameter\n                then\n-                  Hi := Get_Discriminal (E, Hi);\n+                  Bounds.Last := Get_Discriminal (E, Bounds.Last);\n                   Do_Expand := True;\n                end if;\n \n                if Do_Expand then\n-                  if not Is_Entity_Name (Lo) then\n-                     Lo := Duplicate_Subexpr_No_Checks (Lo);\n+                  if not Is_Entity_Name (Bounds.First) then\n+                     Bounds.First :=\n+                       Duplicate_Subexpr_No_Checks (Bounds.First);\n                   end if;\n \n-                  if not Is_Entity_Name (Hi) then\n-                     Lo := Duplicate_Subexpr_No_Checks (Hi);\n+                  if not Is_Entity_Name (Bounds.Last) then\n+                     Bounds.First := Duplicate_Subexpr_No_Checks (Bounds.Last);\n                   end if;\n \n                   N :=\n                     Make_Op_Add (Loc,\n                       Left_Opnd =>\n                         Make_Op_Subtract (Loc,\n-                          Left_Opnd  => Hi,\n-                          Right_Opnd => Lo),\n+                          Left_Opnd  => Bounds.Last,\n+                          Right_Opnd => Bounds.First),\n \n                       Right_Opnd => Make_Integer_Literal (Loc, 1));\n                   return N;\n@@ -10215,10 +10215,8 @@ package body Checks is\n \n                   L_Index  : Node_Id;\n                   R_Index  : Node_Id;\n-                  L_Low    : Node_Id;\n-                  L_High   : Node_Id;\n-                  R_Low    : Node_Id;\n-                  R_High   : Node_Id;\n+                  L_Bounds : Range_Nodes;\n+                  R_Bounds : Range_Nodes;\n                   L_Length : Uint;\n                   R_Length : Uint;\n                   Ref_Node : Node_Id;\n@@ -10250,29 +10248,33 @@ package body Checks is\n                                or else\n                              Nkind (R_Index) = N_Raise_Constraint_Error)\n                      then\n-                        Get_Index_Bounds (L_Index, L_Low, L_High);\n-                        Get_Index_Bounds (R_Index, R_Low, R_High);\n+                        L_Bounds := Get_Index_Bounds (L_Index);\n+                        R_Bounds := Get_Index_Bounds (R_Index);\n \n                         --  Deal with compile time length check. Note that we\n                         --  skip this in the access case, because the access\n                         --  value may be null, so we cannot know statically.\n \n                         if not Do_Access\n-                          and then Compile_Time_Known_Value (L_Low)\n-                          and then Compile_Time_Known_Value (L_High)\n-                          and then Compile_Time_Known_Value (R_Low)\n-                          and then Compile_Time_Known_Value (R_High)\n+                          and then Compile_Time_Known_Value (L_Bounds.First)\n+                          and then Compile_Time_Known_Value (L_Bounds.Last)\n+                          and then Compile_Time_Known_Value (R_Bounds.First)\n+                          and then Compile_Time_Known_Value (R_Bounds.Last)\n                         then\n-                           if Expr_Value (L_High) >= Expr_Value (L_Low) then\n-                              L_Length := Expr_Value (L_High) -\n-                                          Expr_Value (L_Low) + 1;\n+                           if Expr_Value (L_Bounds.Last) >=\n+                              Expr_Value (L_Bounds.First)\n+                           then\n+                              L_Length := Expr_Value (L_Bounds.Last) -\n+                                          Expr_Value (L_Bounds.First) + 1;\n                            else\n                               L_Length := UI_From_Int (0);\n                            end if;\n \n-                           if Expr_Value (R_High) >= Expr_Value (R_Low) then\n-                              R_Length := Expr_Value (R_High) -\n-                                          Expr_Value (R_Low) + 1;\n+                           if Expr_Value (R_Bounds.Last) >=\n+                              Expr_Value (R_Bounds.First)\n+                           then\n+                              R_Length := Expr_Value (R_Bounds.Last) -\n+                                          Expr_Value (R_Bounds.First) + 1;\n                            else\n                               R_Length := UI_From_Int (0);\n                            end if;\n@@ -10304,8 +10306,9 @@ package body Checks is\n                             (Etype (L_Index), Etype (R_Index))\n \n                           and then not\n-                            (Same_Bounds (L_Low, R_Low)\n-                              and then Same_Bounds (L_High, R_High))\n+                            (Same_Bounds (L_Bounds.First, R_Bounds.First)\n+                              and then\n+                             Same_Bounds (L_Bounds.Last, R_Bounds.Last))\n                         then\n                            Evolve_Or_Else\n                              (Cond, Length_E_Cond (Exptyp, T_Typ, Indx));"}, {"sha": "7978b1caf7c46bd3a610d622e185a5f83d137084", "filename": "gcc/ada/exp_aggr.adb", "status": "modified", "additions": 196, "deletions": 185, "changes": 381, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7c4f32677bb64c3423893441541d520097f238c5/gcc%2Fada%2Fexp_aggr.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7c4f32677bb64c3423893441541d520097f238c5/gcc%2Fada%2Fexp_aggr.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_aggr.adb?ref=7c4f32677bb64c3423893441541d520097f238c5", "patch": "@@ -375,15 +375,6 @@ package body Exp_Aggr is\n    --  specifically optimized for the target.\n \n    function Aggr_Assignment_OK_For_Backend (N : Node_Id) return Boolean is\n-      Csiz      : Uint := No_Uint;\n-      Ctyp      : Entity_Id;\n-      Expr      : Node_Id;\n-      High      : Node_Id;\n-      Index     : Entity_Id;\n-      Low       : Node_Id;\n-      Nunits    : Int;\n-      Remainder : Uint;\n-      Value     : Uint;\n \n       function Is_OK_Aggregate (Aggr : Node_Id) return Boolean;\n       --  Return true if Aggr is suitable for back-end assignment\n@@ -422,6 +413,15 @@ package body Exp_Aggr is\n          return Nkind (First (Assoc)) /= N_Iterated_Component_Association;\n       end Is_OK_Aggregate;\n \n+      Bounds    : Range_Nodes;\n+      Csiz      : Uint := No_Uint;\n+      Ctyp      : Entity_Id;\n+      Expr      : Node_Id;\n+      Index     : Entity_Id;\n+      Nunits    : Int;\n+      Remainder : Uint;\n+      Value     : Uint;\n+\n    --  Start of processing for Aggr_Assignment_OK_For_Backend\n \n    begin\n@@ -444,9 +444,9 @@ package body Exp_Aggr is\n \n          Index := First_Index (Ctyp);\n          while Present (Index) loop\n-            Get_Index_Bounds (Index, Low, High);\n+            Bounds := Get_Index_Bounds (Index);\n \n-            if Is_Null_Range (Low, High) then\n+            if Is_Null_Range (Bounds.First, Bounds.Last) then\n                return False;\n             end if;\n \n@@ -2282,10 +2282,12 @@ package body Exp_Aggr is\n       Assoc  : Node_Id;\n       Choice : Node_Id;\n       Expr   : Node_Id;\n-      High   : Node_Id;\n-      Low    : Node_Id;\n       Typ    : Entity_Id;\n \n+      Bounds : Range_Nodes;\n+      Low    : Node_Id renames Bounds.First;\n+      High   : Node_Id renames Bounds.Last;\n+\n       Nb_Choices : Nat := 0;\n       Table      : Case_Table_Type (1 .. Number_Of_Choices (N));\n       --  Used to sort all the different choice values\n@@ -2347,7 +2349,7 @@ package body Exp_Aggr is\n                   exit;\n                end if;\n \n-               Get_Index_Bounds (Choice, Low, High);\n+               Bounds := Get_Index_Bounds (Choice);\n \n                if Low /= High then\n                   Set_Loop_Actions (Assoc, New_List);\n@@ -4508,11 +4510,9 @@ package body Exp_Aggr is\n       Is_Array : constant Boolean := Is_Array_Type (Etype (N));\n \n       Aggr_In     : Node_Id;\n-      Aggr_Lo     : Node_Id;\n-      Aggr_Hi     : Node_Id;\n+      Aggr_Bounds : Range_Nodes;\n       Obj_In      : Node_Id;\n-      Obj_Lo      : Node_Id;\n-      Obj_Hi      : Node_Id;\n+      Obj_Bounds  : Range_Nodes;\n       Parent_Kind : Node_Kind;\n       Parent_Node : Node_Id;\n \n@@ -4823,16 +4823,17 @@ package body Exp_Aggr is\n          end if;\n \n          while Present (Aggr_In) loop\n-            Get_Index_Bounds (Aggr_In, Aggr_Lo, Aggr_Hi);\n-            Get_Index_Bounds (Obj_In, Obj_Lo, Obj_Hi);\n+            Aggr_Bounds := Get_Index_Bounds (Aggr_In);\n+            Obj_Bounds := Get_Index_Bounds (Obj_In);\n \n             --  We require static bounds for the target and a static matching\n             --  of low bound for the aggregate.\n \n-            if not Compile_Time_Known_Value (Obj_Lo)\n-              or else not Compile_Time_Known_Value (Obj_Hi)\n-              or else not Compile_Time_Known_Value (Aggr_Lo)\n-              or else Expr_Value (Aggr_Lo) /= Expr_Value (Obj_Lo)\n+            if not Compile_Time_Known_Value (Obj_Bounds.First)\n+              or else not Compile_Time_Known_Value (Obj_Bounds.Last)\n+              or else not Compile_Time_Known_Value (Aggr_Bounds.First)\n+              or else Expr_Value (Aggr_Bounds.First) /=\n+                      Expr_Value (Obj_Bounds.First)\n             then\n                return False;\n \n@@ -4848,8 +4849,9 @@ package body Exp_Aggr is\n             elsif Parent_Kind = N_Assignment_Statement\n               or else Is_Constrained (Etype (Parent_Node))\n             then\n-               if not Compile_Time_Known_Value (Aggr_Hi)\n-                 or else Expr_Value (Aggr_Hi) /= Expr_Value (Obj_Hi)\n+               if not Compile_Time_Known_Value (Aggr_Bounds.Last)\n+                 or else Expr_Value (Aggr_Bounds.Last) /=\n+                         Expr_Value (Obj_Bounds.Last)\n                then\n                   return False;\n                end if;\n@@ -5692,7 +5694,7 @@ package body Exp_Aggr is\n       --  type using the computable sizes of the aggregate and its sub-\n       --  aggregates.\n \n-      procedure Check_Bounds (Aggr_Bounds : Node_Id; Index_Bounds : Node_Id);\n+      procedure Check_Bounds (Aggr_Bounds_Node, Index_Bounds_Node : Node_Id);\n       --  Checks that the bounds of Aggr_Bounds are within the bounds defined\n       --  by Index_Bounds.\n \n@@ -5792,64 +5794,69 @@ package body Exp_Aggr is\n       -- Check_Bounds --\n       ------------------\n \n-      procedure Check_Bounds (Aggr_Bounds : Node_Id; Index_Bounds : Node_Id) is\n-         Aggr_Lo : Node_Id;\n-         Aggr_Hi : Node_Id;\n-\n-         Ind_Lo  : Node_Id;\n-         Ind_Hi  : Node_Id;\n+      procedure Check_Bounds (Aggr_Bounds_Node, Index_Bounds_Node : Node_Id) is\n+         Aggr_Bounds : constant Range_Nodes :=\n+           Get_Index_Bounds (Aggr_Bounds_Node);\n+         Ind_Bounds  : constant Range_Nodes :=\n+           Get_Index_Bounds (Index_Bounds_Node);\n \n-         Cond    : Node_Id := Empty;\n+         Cond : Node_Id := Empty;\n \n       begin\n-         Get_Index_Bounds (Aggr_Bounds, Aggr_Lo, Aggr_Hi);\n-         Get_Index_Bounds (Index_Bounds, Ind_Lo, Ind_Hi);\n-\n          --  Generate the following test:\n \n          --    [constraint_error when\n-         --      Aggr_Lo <= Aggr_Hi and then\n-         --        (Aggr_Lo < Ind_Lo or else Aggr_Hi > Ind_Hi)]\n+         --      Aggr_Bounds.First <= Aggr_Bounds.Last and then\n+         --        (Aggr_Bounds.First < Ind_Bounds.First\n+         --         or else Aggr_Bounds.Last > Ind_Bounds.Last)]\n \n          --  As an optimization try to see if some tests are trivially vacuous\n          --  because we are comparing an expression against itself.\n \n-         if Aggr_Lo = Ind_Lo and then Aggr_Hi = Ind_Hi then\n+         if Aggr_Bounds.First = Ind_Bounds.First\n+           and then Aggr_Bounds.Last = Ind_Bounds.Last\n+         then\n             Cond := Empty;\n \n-         elsif Aggr_Hi = Ind_Hi then\n+         elsif Aggr_Bounds.Last = Ind_Bounds.Last then\n             Cond :=\n               Make_Op_Lt (Loc,\n-                Left_Opnd  => Duplicate_Subexpr_Move_Checks (Aggr_Lo),\n-                Right_Opnd => Duplicate_Subexpr_Move_Checks (Ind_Lo));\n+                Left_Opnd  =>\n+                  Duplicate_Subexpr_Move_Checks (Aggr_Bounds.First),\n+                Right_Opnd =>\n+                  Duplicate_Subexpr_Move_Checks (Ind_Bounds.First));\n \n-         elsif Aggr_Lo = Ind_Lo then\n+         elsif Aggr_Bounds.First = Ind_Bounds.First then\n             Cond :=\n               Make_Op_Gt (Loc,\n-                Left_Opnd  => Duplicate_Subexpr_Move_Checks (Aggr_Hi),\n-                Right_Opnd => Duplicate_Subexpr_Move_Checks (Ind_Hi));\n+                Left_Opnd  => Duplicate_Subexpr_Move_Checks (Aggr_Bounds.Last),\n+                Right_Opnd => Duplicate_Subexpr_Move_Checks (Ind_Bounds.Last));\n \n          else\n             Cond :=\n               Make_Or_Else (Loc,\n                 Left_Opnd =>\n                   Make_Op_Lt (Loc,\n-                    Left_Opnd  => Duplicate_Subexpr_Move_Checks (Aggr_Lo),\n-                    Right_Opnd => Duplicate_Subexpr_Move_Checks (Ind_Lo)),\n+                    Left_Opnd  =>\n+                      Duplicate_Subexpr_Move_Checks (Aggr_Bounds.First),\n+                    Right_Opnd =>\n+                      Duplicate_Subexpr_Move_Checks (Ind_Bounds.First)),\n \n                 Right_Opnd =>\n                   Make_Op_Gt (Loc,\n-                    Left_Opnd  => Duplicate_Subexpr (Aggr_Hi),\n-                    Right_Opnd => Duplicate_Subexpr (Ind_Hi)));\n+                    Left_Opnd  => Duplicate_Subexpr (Aggr_Bounds.Last),\n+                    Right_Opnd => Duplicate_Subexpr (Ind_Bounds.Last)));\n          end if;\n \n          if Present (Cond) then\n             Cond :=\n               Make_And_Then (Loc,\n                 Left_Opnd =>\n                   Make_Op_Le (Loc,\n-                    Left_Opnd  => Duplicate_Subexpr_Move_Checks (Aggr_Lo),\n-                    Right_Opnd => Duplicate_Subexpr_Move_Checks (Aggr_Hi)),\n+                    Left_Opnd  =>\n+                      Duplicate_Subexpr_Move_Checks (Aggr_Bounds.First),\n+                    Right_Opnd =>\n+                      Duplicate_Subexpr_Move_Checks (Aggr_Bounds.Last)),\n \n                 Right_Opnd => Cond);\n \n@@ -6116,8 +6123,6 @@ package body Exp_Aggr is\n                --  Used to sort all the different choice values\n \n                J    : Pos := 1;\n-               Low  : Node_Id;\n-               High : Node_Id;\n \n             begin\n                Assoc := First (Component_Associations (Sub_Aggr));\n@@ -6128,9 +6133,13 @@ package body Exp_Aggr is\n                         exit;\n                      end if;\n \n-                     Get_Index_Bounds (Choice, Low, High);\n-                     Table (J).Choice_Lo := Low;\n-                     Table (J).Choice_Hi := High;\n+                     declare\n+                        Bounds : constant Range_Nodes :=\n+                          Get_Index_Bounds (Choice);\n+                     begin\n+                        Table (J).Choice_Lo := Bounds.First;\n+                        Table (J).Choice_Hi := Bounds.Last;\n+                     end;\n \n                      J := J + 1;\n                      Next (Choice);\n@@ -9144,14 +9153,6 @@ package body Exp_Aggr is\n       declare\n          Csiz  : constant Nat := UI_To_Int (Component_Size (Typ));\n \n-         Lo : Node_Id;\n-         Hi : Node_Id;\n-         --  Bounds of index type\n-\n-         Lob : Uint;\n-         Hib : Uint;\n-         --  Values of bounds if compile time known\n-\n          function Get_Component_Val (N : Node_Id) return Uint;\n          --  Given a expression value N of the component type Ctyp, returns a\n          --  value of Csiz (component size) bits representing this value. If\n@@ -9193,147 +9194,154 @@ package body Exp_Aggr is\n             return Val mod Uint_2 ** Csiz;\n          end Get_Component_Val;\n \n+         Bounds : constant Range_Nodes := Get_Index_Bounds (First_Index (Typ));\n+\n       --  Here we know we have a one dimensional bit packed array\n \n       begin\n-         Get_Index_Bounds (First_Index (Typ), Lo, Hi);\n-\n          --  Cannot do anything if bounds are dynamic\n \n-         if not Compile_Time_Known_Value (Lo)\n-              or else\n-            not Compile_Time_Known_Value (Hi)\n+         if not (Compile_Time_Known_Value (Bounds.First)\n+                   and then\n+                 Compile_Time_Known_Value (Bounds.Last))\n          then\n             return False;\n          end if;\n \n-         --  Or are silly out of range of int bounds\n-\n-         Lob := Expr_Value (Lo);\n-         Hib := Expr_Value (Hi);\n-\n-         if not UI_Is_In_Int_Range (Lob)\n-              or else\n-            not UI_Is_In_Int_Range (Hib)\n-         then\n-            return False;\n-         end if;\n+         declare\n+            Bounds_Vals : Range_Values;\n+            --  Compile-time known values of bounds\n+         begin\n+            --  Or are silly out of range of int bounds\n \n-         --  At this stage we have a suitable aggregate for handling at compile\n-         --  time. The only remaining checks are that the values of expressions\n-         --  in the aggregate are compile-time known (checks are performed by\n-         --  Get_Component_Val), and that any subtypes or ranges are statically\n-         --  known.\n+            Bounds_Vals.First := Expr_Value (Bounds.First);\n+            Bounds_Vals.Last := Expr_Value (Bounds.Last);\n \n-         --  If the aggregate is not fully positional at this stage, then\n-         --  convert it to positional form. Either this will fail, in which\n-         --  case we can do nothing, or it will succeed, in which case we have\n-         --  succeeded in handling the aggregate and transforming it into a\n-         --  modular value, or it will stay an aggregate, in which case we\n-         --  have failed to create a packed value for it.\n+            if not UI_Is_In_Int_Range (Bounds_Vals.First)\n+                 or else\n+               not UI_Is_In_Int_Range (Bounds_Vals.Last)\n+            then\n+               return False;\n+            end if;\n \n-         if Present (Component_Associations (N)) then\n-            Convert_To_Positional (N, Handle_Bit_Packed => True);\n-            return Nkind (N) /= N_Aggregate;\n-         end if;\n+            --  At this stage we have a suitable aggregate for handling at\n+            --  compile time. The only remaining checks are that the values of\n+            --  expressions in the aggregate are compile-time known (checks are\n+            --  performed by Get_Component_Val), and that any subtypes or\n+            --  ranges are statically known.\n \n-         --  Otherwise we are all positional, so convert to proper value\n+            --  If the aggregate is not fully positional at this stage, then\n+            --  convert it to positional form. Either this will fail, in which\n+            --  case we can do nothing, or it will succeed, in which case we\n+            --  have succeeded in handling the aggregate and transforming it\n+            --  into a modular value, or it will stay an aggregate, in which\n+            --  case we have failed to create a packed value for it.\n \n-         declare\n-            Lov : constant Int := UI_To_Int (Lob);\n-            Hiv : constant Int := UI_To_Int (Hib);\n+            if Present (Component_Associations (N)) then\n+               Convert_To_Positional (N, Handle_Bit_Packed => True);\n+               return Nkind (N) /= N_Aggregate;\n+            end if;\n \n-            Len : constant Nat := Int'Max (0, Hiv - Lov + 1);\n-            --  The length of the array (number of elements)\n+            --  Otherwise we are all positional, so convert to proper value\n \n-            Aggregate_Val : Uint;\n-            --  Value of aggregate. The value is set in the low order bits of\n-            --  this value. For the little-endian case, the values are stored\n-            --  from low-order to high-order and for the big-endian case the\n-            --  values are stored from high-order to low-order. Note that gigi\n-            --  will take care of the conversions to left justify the value in\n-            --  the big endian case (because of left justified modular type\n-            --  processing), so we do not have to worry about that here.\n+            declare\n+               Len : constant Nat :=\n+                 Int'Max (0, UI_To_Int (Bounds_Vals.Last) -\n+                             UI_To_Int (Bounds_Vals.First) + 1);\n+               --  The length of the array (number of elements)\n \n-            Lit : Node_Id;\n-            --  Integer literal for resulting constructed value\n+               Aggregate_Val : Uint;\n+               --  Value of aggregate. The value is set in the low order bits\n+               --  of this value. For the little-endian case, the values are\n+               --  stored from low-order to high-order and for the big-endian\n+               --  case the values are stored from high order to low order.\n+               --  Note that gigi will take care of the conversions to left\n+               --  justify the value in the big endian case (because of left\n+               --  justified modular type processing), so we do not have to\n+               --  worry about that here.\n \n-            Shift : Nat;\n-            --  Shift count from low order for next value\n+               Lit : Node_Id;\n+               --  Integer literal for resulting constructed value\n \n-            Incr : Int;\n-            --  Shift increment for loop\n+               Shift : Nat;\n+               --  Shift count from low order for next value\n \n-            Expr : Node_Id;\n-            --  Next expression from positional parameters of aggregate\n+               Incr : Int;\n+               --  Shift increment for loop\n \n-            Left_Justified : Boolean;\n-            --  Set True if we are filling the high order bits of the target\n-            --  value (i.e. the value is left justified).\n+               Expr : Node_Id;\n+               --  Next expression from positional parameters of aggregate\n \n-         begin\n-            --  For little endian, we fill up the low order bits of the target\n-            --  value. For big endian we fill up the high order bits of the\n-            --  target value (which is a left justified modular value).\n+               Left_Justified : Boolean;\n+               --  Set True if we are filling the high order bits of the target\n+               --  value (i.e. the value is left justified).\n \n-            Left_Justified := Bytes_Big_Endian;\n+            begin\n+               --  For little endian, we fill up the low order bits of the\n+               --  target value. For big endian we fill up the high order bits\n+               --  of the target value (which is a left justified modular\n+               --  value).\n \n-            --  Switch justification if using -gnatd8\n+               Left_Justified := Bytes_Big_Endian;\n \n-            if Debug_Flag_8 then\n-               Left_Justified := not Left_Justified;\n-            end if;\n+               --  Switch justification if using -gnatd8\n \n-            --  Switch justfification if reverse storage order\n+               if Debug_Flag_8 then\n+                  Left_Justified := not Left_Justified;\n+               end if;\n \n-            if Reverse_Storage_Order (Base_Type (Typ)) then\n-               Left_Justified := not Left_Justified;\n-            end if;\n+               --  Switch justfification if reverse storage order\n \n-            if Left_Justified then\n-               Shift := Csiz * (Len - 1);\n-               Incr  := -Csiz;\n-            else\n-               Shift := 0;\n-               Incr  := +Csiz;\n-            end if;\n+               if Reverse_Storage_Order (Base_Type (Typ)) then\n+                  Left_Justified := not Left_Justified;\n+               end if;\n \n-            --  Loop to set the values\n+               if Left_Justified then\n+                  Shift := Csiz * (Len - 1);\n+                  Incr  := -Csiz;\n+               else\n+                  Shift := 0;\n+                  Incr  := +Csiz;\n+               end if;\n \n-            if Len = 0 then\n-               Aggregate_Val := Uint_0;\n-            else\n-               Expr := First (Expressions (N));\n-               Aggregate_Val := Get_Component_Val (Expr) * Uint_2 ** Shift;\n+               --  Loop to set the values\n \n-               for J in 2 .. Len loop\n-                  Shift := Shift + Incr;\n-                  Next (Expr);\n-                  Aggregate_Val :=\n-                    Aggregate_Val + Get_Component_Val (Expr) * Uint_2 ** Shift;\n-               end loop;\n-            end if;\n+               if Len = 0 then\n+                  Aggregate_Val := Uint_0;\n+               else\n+                  Expr := First (Expressions (N));\n+                  Aggregate_Val := Get_Component_Val (Expr) * Uint_2 ** Shift;\n+\n+                  for J in 2 .. Len loop\n+                     Shift := Shift + Incr;\n+                     Next (Expr);\n+                     Aggregate_Val :=\n+                       Aggregate_Val +\n+                       Get_Component_Val (Expr) * Uint_2 ** Shift;\n+                  end loop;\n+               end if;\n \n-            --  Now we can rewrite with the proper value\n+               --  Now we can rewrite with the proper value\n \n-            Lit := Make_Integer_Literal (Loc, Intval => Aggregate_Val);\n-            Set_Print_In_Hex (Lit);\n+               Lit := Make_Integer_Literal (Loc, Intval => Aggregate_Val);\n+               Set_Print_In_Hex (Lit);\n \n-            --  Construct the expression using this literal. Note that it is\n-            --  important to qualify the literal with its proper modular type\n-            --  since universal integer does not have the required range and\n-            --  also this is a left justified modular type, which is important\n-            --  in the big-endian case.\n+               --  Construct the expression using this literal. Note that it\n+               --  is important to qualify the literal with its proper modular\n+               --  type since universal integer does not have the required\n+               --  range and also this is a left justified modular type,\n+               --  which is important in the big-endian case.\n \n-            Rewrite (N,\n-              Unchecked_Convert_To (Typ,\n-                Make_Qualified_Expression (Loc,\n-                  Subtype_Mark =>\n-                    New_Occurrence_Of (Packed_Array_Impl_Type (Typ), Loc),\n-                  Expression   => Lit)));\n+               Rewrite (N,\n+                 Unchecked_Convert_To (Typ,\n+                   Make_Qualified_Expression (Loc,\n+                     Subtype_Mark =>\n+                       New_Occurrence_Of (Packed_Array_Impl_Type (Typ), Loc),\n+                     Expression   => Lit)));\n \n-            Analyze_And_Resolve (N, Typ);\n-            return True;\n+               Analyze_And_Resolve (N, Typ);\n+               return True;\n+            end;\n          end;\n       end;\n \n@@ -9408,8 +9416,6 @@ package body Exp_Aggr is\n      (Obj_Type : Entity_Id;\n       Typ      : Entity_Id) return Boolean\n    is\n-      L1, L2, H1, H2 : Node_Id;\n-\n    begin\n       --  No sliding if the type of the object is not established yet, if it is\n       --  an unconstrained type whose actual subtype comes from the aggregate,\n@@ -9427,20 +9433,25 @@ package body Exp_Aggr is\n       else\n          --  Sliding can only occur along the first dimension\n \n-         Get_Index_Bounds (First_Index (Typ), L1, H1);\n-         Get_Index_Bounds (First_Index (Obj_Type), L2, H2);\n+         declare\n+            Bounds1 : constant Range_Nodes :=\n+              Get_Index_Bounds (First_Index (Typ));\n+            Bounds2 : constant Range_Nodes :=\n+              Get_Index_Bounds (First_Index (Obj_Type));\n \n-         if not Is_OK_Static_Expression (L1) or else\n-            not Is_OK_Static_Expression (L2) or else\n-            not Is_OK_Static_Expression (H1) or else\n-            not Is_OK_Static_Expression (H2)\n-         then\n-            return False;\n-         else\n-            return Expr_Value (L1) /= Expr_Value (L2)\n-                     or else\n-                   Expr_Value (H1) /= Expr_Value (H2);\n-         end if;\n+         begin\n+            if not Is_OK_Static_Expression (Bounds1.First) or else\n+               not Is_OK_Static_Expression (Bounds2.First) or else\n+               not Is_OK_Static_Expression (Bounds1.Last) or else\n+               not Is_OK_Static_Expression (Bounds2.Last)\n+            then\n+               return False;\n+            else\n+               return Expr_Value (Bounds1.First) /= Expr_Value (Bounds2.First)\n+                        or else\n+                      Expr_Value (Bounds1.Last) /= Expr_Value (Bounds2.Last);\n+            end if;\n+         end;\n       end if;\n    end Must_Slide;\n "}, {"sha": "4eba6fb4208b8acee6da158a35b5a455a1cae6f9", "filename": "gcc/ada/exp_ch5.adb", "status": "modified", "additions": 25, "deletions": 18, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7c4f32677bb64c3423893441541d520097f238c5/gcc%2Fada%2Fexp_ch5.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7c4f32677bb64c3423893441541d520097f238c5/gcc%2Fada%2Fexp_ch5.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch5.adb?ref=7c4f32677bb64c3423893441541d520097f238c5", "patch": "@@ -1500,12 +1500,13 @@ package body Exp_Ch5 is\n         (if Nkind (Name (N)) = N_Slice\n          then Get_Index_Bounds (Discrete_Range (Name (N)))\n          else Larray_Bounds);\n-      --  If the left-hand side is A (L..H), Larray_Bounds is A'Range, and\n-      --  L_Bounds is L..H. If it's not a slice, we treat it like a slice\n-      --  starting at A'First.\n+      --  If the left-hand side is A (First..Last), Larray_Bounds is A'Range,\n+      --  and L_Bounds is First..Last. If it's not a slice, we treat it like\n+      --  a slice starting at A'First.\n \n       L_Bit : constant Node_Id :=\n-        Make_Integer_Literal (Loc, (L_Bounds.L - Larray_Bounds.L) * C_Size);\n+        Make_Integer_Literal\n+          (Loc, (L_Bounds.First - Larray_Bounds.First) * C_Size);\n \n       Rarray_Bounds : constant Range_Values :=\n         Get_Index_Bounds (First_Index (R_Typ));\n@@ -1515,7 +1516,8 @@ package body Exp_Ch5 is\n          else Rarray_Bounds);\n \n       R_Bit : constant Node_Id :=\n-        Make_Integer_Literal (Loc, (R_Bounds.L - Rarray_Bounds.L) * C_Size);\n+        Make_Integer_Literal\n+          (Loc, (R_Bounds.First - Rarray_Bounds.First) * C_Size);\n \n       Size : constant Node_Id :=\n         Make_Op_Multiply (Loc,\n@@ -1594,17 +1596,21 @@ package body Exp_Ch5 is\n       Rev    : Boolean) return Node_Id\n    is\n \n+      L : constant Node_Id := Name (N);\n+      R : constant Node_Id := Expression (N);\n+      --  Left- and right-hand sides of the assignment statement\n+\n       Slices : constant Boolean :=\n-        Nkind (Name (N)) = N_Slice or else Nkind (Expression (N)) = N_Slice;\n+        Nkind (L) = N_Slice or else Nkind (R) = N_Slice;\n       L_Prefix_Comp : constant Boolean :=\n         --  True if the left-hand side is a slice of a component or slice\n-        Nkind (Name (N)) = N_Slice\n-          and then Nkind (Prefix (Name (N))) in\n+        Nkind (L) = N_Slice\n+          and then Nkind (Prefix (L)) in\n                      N_Selected_Component | N_Indexed_Component | N_Slice;\n       R_Prefix_Comp : constant Boolean :=\n         --  Likewise for the right-hand side\n-        Nkind (Expression (N)) = N_Slice\n-          and then Nkind (Prefix (Expression (N))) in\n+        Nkind (R) = N_Slice\n+          and then Nkind (Prefix (R)) in\n                      N_Selected_Component | N_Indexed_Component | N_Slice;\n \n    begin\n@@ -1664,27 +1670,28 @@ package body Exp_Ch5 is\n                  Get_Index_Bounds (Right_Base_Index);\n \n                Known_Left_Slice_Low : constant Boolean :=\n-                 (if Nkind (Name (N)) = N_Slice\n+                 (if Nkind (L) = N_Slice\n                     then Compile_Time_Known_Value\n-                      (Get_Index_Bounds (Discrete_Range (Name (N))).L));\n+                      (Get_Index_Bounds (Discrete_Range (L)).First));\n                Known_Right_Slice_Low : constant Boolean :=\n-                 (if Nkind (Expression (N)) = N_Slice\n+                 (if Nkind (R) = N_Slice\n                     then Compile_Time_Known_Value\n-                      (Get_Index_Bounds (Discrete_Range (Expression (N))).H));\n+                      (Get_Index_Bounds (Discrete_Range (R)).Last));\n \n                Val_Bits : constant Pos := Standard_Long_Long_Integer_Size / 2;\n \n             begin\n-               if Left_Base_Range.H - Left_Base_Range.L < Val_Bits\n-                 and then Right_Base_Range.H - Right_Base_Range.L < Val_Bits\n+               if Left_Base_Range.Last - Left_Base_Range.First < Val_Bits\n+                 and then Right_Base_Range.Last - Right_Base_Range.First <\n+                            Val_Bits\n                  and then Known_Esize (L_Type)\n                  and then Known_Esize (R_Type)\n                  and then Known_Left_Slice_Low\n                  and then Known_Right_Slice_Low\n                  and then Compile_Time_Known_Value\n-                   (Get_Index_Bounds (First_Index (Etype (Larray))).L)\n+                   (Get_Index_Bounds (First_Index (Etype (Larray))).First)\n                  and then Compile_Time_Known_Value\n-                   (Get_Index_Bounds (First_Index (Etype (Rarray))).L)\n+                   (Get_Index_Bounds (First_Index (Etype (Rarray))).First)\n                  and then\n                    not (Is_Enumeration_Type (Etype (Left_Base_Index))\n                           and then Has_Enumeration_Rep_Clause"}, {"sha": "23b64a0034d0f2f3768e2093815fb2a25414b461", "filename": "gcc/ada/freeze.adb", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7c4f32677bb64c3423893441541d520097f238c5/gcc%2Fada%2Ffreeze.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7c4f32677bb64c3423893441541d520097f238c5/gcc%2Fada%2Ffreeze.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Ffreeze.adb?ref=7c4f32677bb64c3423893441541d520097f238c5", "patch": "@@ -867,11 +867,8 @@ package body Freeze is\n       ----------------\n \n       function Size_Known (T : Entity_Id) return Boolean is\n-         Index : Entity_Id;\n          Comp  : Entity_Id;\n          Ctyp  : Entity_Id;\n-         Low   : Node_Id;\n-         High  : Node_Id;\n \n       begin\n          if Size_Known_At_Compile_Time (T) then\n@@ -918,8 +915,11 @@ package body Freeze is\n             --  thus may be packable).\n \n             declare\n-               Size : Uint := Component_Size (T);\n-               Dim  : Uint;\n+               Index : Entity_Id;\n+               Low   : Node_Id;\n+               High  : Node_Id;\n+               Size  : Uint := Component_Size (T);\n+               Dim   : Uint;\n \n             begin\n                Index := First_Index (T);"}, {"sha": "c0bc4b77f9700b76de9aa1142ef0c7044171d39c", "filename": "gcc/ada/sem_util.adb", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7c4f32677bb64c3423893441541d520097f238c5/gcc%2Fada%2Fsem_util.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7c4f32677bb64c3423893441541d520097f238c5/gcc%2Fada%2Fsem_util.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_util.adb?ref=7c4f32677bb64c3423893441541d520097f238c5", "patch": "@@ -10978,7 +10978,7 @@ package body Sem_Util is\n       Use_Full_View : Boolean := False) return Range_Nodes is\n       Result : Range_Nodes;\n    begin\n-      Get_Index_Bounds (N, Result.L, Result.H, Use_Full_View);\n+      Get_Index_Bounds (N, Result.First, Result.Last, Use_Full_View);\n       return Result;\n    end Get_Index_Bounds;\n \n@@ -10987,7 +10987,7 @@ package body Sem_Util is\n       Use_Full_View : Boolean := False) return Range_Values is\n       Nodes : constant Range_Nodes := Get_Index_Bounds (N, Use_Full_View);\n    begin\n-      return (Expr_Value (Nodes.L), Expr_Value (Nodes.H));\n+      return (Expr_Value (Nodes.First), Expr_Value (Nodes.Last));\n    end Get_Index_Bounds;\n \n    -----------------------------"}, {"sha": "10f1ba52795433709c9861c505cf0de1810bf6bb", "filename": "gcc/ada/sem_util.ads", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7c4f32677bb64c3423893441541d520097f238c5/gcc%2Fada%2Fsem_util.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7c4f32677bb64c3423893441541d520097f238c5/gcc%2Fada%2Fsem_util.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_util.ads?ref=7c4f32677bb64c3423893441541d520097f238c5", "patch": "@@ -1177,11 +1177,11 @@ package Sem_Util is\n    --  arise during normal compilation of semantically correct programs.\n \n    type Range_Nodes is record\n-      L, H : Node_Id; -- First and Last nodes of a discrete_range\n+      First, Last : Node_Id; -- First and Last nodes of a discrete_range\n    end record;\n \n    type Range_Values is record\n-      L, H : Uint; -- First and Last values of a discrete_range\n+      First, Last : Uint; -- First and Last values of a discrete_range\n    end record;\n \n    function Get_Index_Bounds"}]}