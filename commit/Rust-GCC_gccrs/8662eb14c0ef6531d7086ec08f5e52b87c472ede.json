{"sha": "8662eb14c0ef6531d7086ec08f5e52b87c472ede", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODY2MmViMTRjMGVmNjUzMWQ3MDg2ZWMwOGY1ZTUyYjg3YzQ3MmVkZQ==", "commit": {"author": {"name": "Alan Modra", "email": "amodra@bigpond.net.au", "date": "2004-09-08T00:17:19Z"}, "committer": {"name": "Alan Modra", "email": "amodra@gcc.gnu.org", "date": "2004-09-08T00:17:19Z"}, "message": "tm.texi (MD_UNWIND_SUPPORT): Document.\n\n\t* doc/tm.texi (MD_UNWIND_SUPPORT): Document.\n\t(MD_FALLBACK_FRAME_STATE_FOR): Update.\n\t* unwind-dw2.c (MD_UNWIND_SUPPORT): #include if defined.\n\t(uw_frame_state_for): Adjust MD_FALLBACK_FRAME_STATE_FOR invocation.\n\t(MD_FROB_UPDATE_CONTEXT): Remove default.\n\t(uw_update_context_1): Instead #ifdef invocation.\n\t* config/ia64/unwind-ia64.c (MD_UNWIND_SUPPORT): #include if defined.\n\t(uw_frame_state_for): Adjust MD_FALLBACK_FRAME_STATE_FOR invocation.\n\t* config/alpha/gnu.h (MD_FALLBACK_FRAME_STATE_FOR): Don't undef.\n\t(MD_UNWIND_SUPPORT): Undefine this instead.\n\t* config/i386/gnu.h: Likewise.\n\t* config/alpha/linux-unwind.h: New file, macro converted to\n\tfunction, extracted from..\n\t* config/alpha/linux.h (MD_FALLBACK_FRAME_STATE_FOR): ..this.\n\t(MD_UNWIND_SUPPORT): Define.\n\t* config/alpha/vms-unwind.h, config/alpha/vms.h: Likewise.\n\t* config/i386/linux-unwind.h, config/i386/linux.h,\n\tconfig/i386/linux64.h: Likewise.\n\t* config/ia64/linux-unwind.h, config/ia64/linux.h: Likewise.\n\tMD_HANDLE_UNWABI too.\n\t* config/mips/linux-unwind.h, config/mips/linux.h: Likewise.\n\t* config/pa/linux-unwind.h, config/pa/pa32-linux.h: Likewise.\n\t* config/rs6000/darwin-unwind.h, config/rs6000/darwin.h: Likewise.\n\t* config/s390/linux-unwind.h, config/s390/linux.h: Likewise.\n\t* config/sparc/linux-unwind.h, config/sparc/linux.h,\n\tconfig/sparc/linux64.h: Likewise.\n\t* config/sh/linux-unwind.h, config/sh/linux.h: Likewise, but merge\n\tSH_FALLBACK_FRAME_FLOAT_STATE into sh_fallback_frame_state.\n\t* config/rs6000/linux-unwind.h, config/rs6000/linux.h,\n\tconfig/rs6000/linux64.h: Likewise.  Split out get_sigcontext\n\tfunction.  Use ARG_POINTER_REGNUM for 32-bit temp reg too.\n\nFrom-SVN: r87167", "tree": {"sha": "f6927bd90fe84c682dd04619d255d6355aac36d5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f6927bd90fe84c682dd04619d255d6355aac36d5"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/8662eb14c0ef6531d7086ec08f5e52b87c472ede", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8662eb14c0ef6531d7086ec08f5e52b87c472ede", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8662eb14c0ef6531d7086ec08f5e52b87c472ede", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8662eb14c0ef6531d7086ec08f5e52b87c472ede/comments", "author": null, "committer": null, "parents": [{"sha": "a9e10feb68d5cbc371f581ebca229043b7854fe5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a9e10feb68d5cbc371f581ebca229043b7854fe5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a9e10feb68d5cbc371f581ebca229043b7854fe5"}], "stats": {"total": 2801, "additions": 1448, "deletions": 1353}, "files": [{"sha": "3177547be526bf4404c4a65b06c60ce40732de5d", "filename": "gcc/ChangeLog", "status": "modified", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8662eb14c0ef6531d7086ec08f5e52b87c472ede/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8662eb14c0ef6531d7086ec08f5e52b87c472ede/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=8662eb14c0ef6531d7086ec08f5e52b87c472ede", "patch": "@@ -1,3 +1,37 @@\n+2004-09-08  Alan Modra  <amodra@bigpond.net.au>\n+\n+\t* doc/tm.texi (MD_UNWIND_SUPPORT): Document.\n+\t(MD_FALLBACK_FRAME_STATE_FOR): Update.\n+\t* unwind-dw2.c (MD_UNWIND_SUPPORT): #include if defined.\n+\t(uw_frame_state_for): Adjust MD_FALLBACK_FRAME_STATE_FOR invocation.\n+\t(MD_FROB_UPDATE_CONTEXT): Remove default.\n+\t(uw_update_context_1): Instead #ifdef invocation.\n+\t* config/ia64/unwind-ia64.c (MD_UNWIND_SUPPORT): #include if defined.\n+\t(uw_frame_state_for): Adjust MD_FALLBACK_FRAME_STATE_FOR invocation.\n+\t* config/alpha/gnu.h (MD_FALLBACK_FRAME_STATE_FOR): Don't undef.\n+\t(MD_UNWIND_SUPPORT): Undefine this instead.\n+\t* config/i386/gnu.h: Likewise.\n+\t* config/alpha/linux-unwind.h: New file, macro converted to\n+\tfunction, extracted from..\n+\t* config/alpha/linux.h (MD_FALLBACK_FRAME_STATE_FOR): ..this.\n+\t(MD_UNWIND_SUPPORT): Define.\n+\t* config/alpha/vms-unwind.h, config/alpha/vms.h: Likewise.\n+\t* config/i386/linux-unwind.h, config/i386/linux.h,\n+\tconfig/i386/linux64.h: Likewise.\n+\t* config/ia64/linux-unwind.h, config/ia64/linux.h: Likewise.\n+\tMD_HANDLE_UNWABI too.\n+\t* config/mips/linux-unwind.h, config/mips/linux.h: Likewise.\n+\t* config/pa/linux-unwind.h, config/pa/pa32-linux.h: Likewise.\n+\t* config/rs6000/darwin-unwind.h, config/rs6000/darwin.h: Likewise.\n+\t* config/s390/linux-unwind.h, config/s390/linux.h: Likewise.\n+\t* config/sparc/linux-unwind.h, config/sparc/linux.h,\n+\tconfig/sparc/linux64.h: Likewise.\n+\t* config/sh/linux-unwind.h, config/sh/linux.h: Likewise, but merge\n+\tSH_FALLBACK_FRAME_FLOAT_STATE into sh_fallback_frame_state.\n+\t* config/rs6000/linux-unwind.h, config/rs6000/linux.h,\n+\tconfig/rs6000/linux64.h: Likewise.  Split out get_sigcontext\n+\tfunction.  Use ARG_POINTER_REGNUM for 32-bit temp reg too.\n+\n 2004-09-07  Jan Hubicka  <jh@suse.cz>\n \n \t* cse.c (fold_rtx):  Avoid building of"}, {"sha": "b9bfceafd0a9b310ed1814c060a0a298a4d4569a", "filename": "gcc/config/alpha/gnu.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8662eb14c0ef6531d7086ec08f5e52b87c472ede/gcc%2Fconfig%2Falpha%2Fgnu.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8662eb14c0ef6531d7086ec08f5e52b87c472ede/gcc%2Fconfig%2Falpha%2Fgnu.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Falpha%2Fgnu.h?ref=8662eb14c0ef6531d7086ec08f5e52b87c472ede", "patch": "@@ -23,4 +23,4 @@\n    %{!static:%{!shared:crtbegin.o%s} %{shared:crtbeginS.o%s}}\"\n \n /* FIXME: Is a Hurd-specific fallback mechanism necessary?  */\n-#undef MD_FALLBACK_FRAME_STATE_FOR\n+#undef MD_UNWIND_SUPPORT"}, {"sha": "ec0af1a6bee3b77c3699de385d19b4e8dbbd3757", "filename": "gcc/config/alpha/linux-unwind.h", "status": "added", "additions": 74, "deletions": 0, "changes": 74, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8662eb14c0ef6531d7086ec08f5e52b87c472ede/gcc%2Fconfig%2Falpha%2Flinux-unwind.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8662eb14c0ef6531d7086ec08f5e52b87c472ede/gcc%2Fconfig%2Falpha%2Flinux-unwind.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Falpha%2Flinux-unwind.h?ref=8662eb14c0ef6531d7086ec08f5e52b87c472ede", "patch": "@@ -0,0 +1,74 @@\n+/* DWARF2 EH unwinding support for Alpha Linux.\n+   Copyright (C) 2004 Free Software Foundation, Inc.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GCC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING.  If not, write to\n+the Free Software Foundation, 59 Temple Place - Suite 330,\n+Boston, MA 02111-1307, USA.  */\n+\n+/* Do code reading to identify a signal frame, and set the frame\n+   state data appropriately.  See unwind-dw2.c for the structs.  */\n+\n+#include <signal.h>\n+#include <sys/ucontext.h>\n+\n+#define MD_FALLBACK_FRAME_STATE_FOR alpha_fallback_frame_state\n+\n+static _Unwind_Reason_Code\n+alpha_fallback_frame_state (struct _Unwind_Context *context,\n+\t\t\t    _Unwind_FrameState *fs)\n+{\n+  unsigned int *pc = context->ra;\n+  struct sigcontext *sc;\n+  long new_cfa, i;\n+\n+  if (pc[0] != 0x47fe0410\t\t/* mov $30,$16 */\n+      || pc[2] != 0x00000083\t\t/* callsys */)\n+    return _URC_END_OF_STACK;\n+  if (context->cfa == 0)\n+    return _URC_END_OF_STACK;\n+  if (pc[1] == 0x201f0067)\t\t/* lda $0,NR_sigreturn */\n+    sc = context->cfa;\n+  else if (pc[1] == 0x201f015f)\t/* lda $0,NR_rt_sigreturn */\n+    {\n+      struct rt_sigframe {\n+\tstruct siginfo info;\n+\tstruct ucontext uc;\n+      } *rt_ = context->cfa;\n+      sc = &rt_->uc.uc_mcontext;\n+    }\n+  else\n+    return _URC_END_OF_STACK;\n+  new_cfa = sc->sc_regs[30];\n+  fs->cfa_how = CFA_REG_OFFSET;\n+  fs->cfa_reg = 30;\n+  fs->cfa_offset = new_cfa - (long) context->cfa;\n+  for (i = 0; i < 30; ++i)\n+    {\n+      fs->regs.reg[i].how = REG_SAVED_OFFSET;\n+      fs->regs.reg[i].loc.offset\n+\t= (long)&sc->sc_regs[i] - new_cfa;\n+    }\n+  for (i = 0; i < 31; ++i)\n+    {\n+      fs->regs.reg[i+32].how = REG_SAVED_OFFSET;\n+      fs->regs.reg[i+32].loc.offset\n+\t= (long)&sc->sc_fpregs[i] - new_cfa;\n+    }\n+  fs->regs.reg[64].how = REG_SAVED_OFFSET;\n+  fs->regs.reg[64].loc.offset = (long)&sc->sc_pc - new_cfa;\n+  fs->retaddr_column = 64;\n+  return _URC_NO_REASON;\n+}"}, {"sha": "e9a0e90058044e1e115f9be2cfc7771891c2f7f5", "filename": "gcc/config/alpha/linux.h", "status": "modified", "additions": 1, "deletions": 52, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8662eb14c0ef6531d7086ec08f5e52b87c472ede/gcc%2Fconfig%2Falpha%2Flinux.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8662eb14c0ef6531d7086ec08f5e52b87c472ede/gcc%2Fconfig%2Falpha%2Flinux.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Falpha%2Flinux.h?ref=8662eb14c0ef6531d7086ec08f5e52b87c472ede", "patch": "@@ -76,55 +76,4 @@ Boston, MA 02111-1307, USA.  */\n #define USE_LD_AS_NEEDED 1\n #endif\n \n-/* Do code reading to identify a signal frame, and set the frame\n-   state data appropriately.  See unwind-dw2.c for the structs.  */\n-\n-#ifdef IN_LIBGCC2\n-#include <signal.h>\n-#include <sys/ucontext.h>\n-#endif\n-\n-#define MD_FALLBACK_FRAME_STATE_FOR(CONTEXT, FS, SUCCESS)\t\t\\\n-  do {\t\t\t\t\t\t\t\t\t\\\n-    unsigned int *pc_ = (CONTEXT)->ra;\t\t\t\t\t\\\n-    struct sigcontext *sc_;\t\t\t\t\t\t\\\n-    long new_cfa_, i_;\t\t\t\t\t\t\t\\\n-\t\t\t\t\t\t\t\t\t\\\n-    if (pc_[0] != 0x47fe0410\t\t/* mov $30,$16 */\t\t\\\n-        || pc_[2] != 0x00000083\t\t/* callsys */)\t\t\t\\\n-      break;\t\t\t\t\t\t\t\t\\\n-    if ((CONTEXT)->cfa == 0)\t\t\t\t\t\t\\\n-      break;\t\t\t\t\t\t\t\t\\\n-    if (pc_[1] == 0x201f0067)\t\t/* lda $0,NR_sigreturn */\t\\\n-      sc_ = (CONTEXT)->cfa;\t\t\t\t\t\t\\\n-    else if (pc_[1] == 0x201f015f)\t/* lda $0,NR_rt_sigreturn */\t\\\n-      {\t\t\t\t\t\t\t\t\t\\\n-\tstruct rt_sigframe {\t\t\t\t\t\t\\\n-\t  struct siginfo info;\t\t\t\t\t\t\\\n-\t  struct ucontext uc;\t\t\t\t\t\t\\\n-\t} *rt_ = (CONTEXT)->cfa;\t\t\t\t\t\\\n-\tsc_ = &rt_->uc.uc_mcontext;\t\t\t\t\t\\\n-      }\t\t\t\t\t\t\t\t\t\\\n-    else\t\t\t\t\t\t\t\t\\\n-      break;\t\t\t\t\t\t\t\t\\\n-    new_cfa_ = sc_->sc_regs[30];\t\t\t\t\t\\\n-    (FS)->cfa_how = CFA_REG_OFFSET;\t\t\t\t\t\\\n-    (FS)->cfa_reg = 30;\t\t\t\t\t\t\t\\\n-    (FS)->cfa_offset = new_cfa_ - (long) (CONTEXT)->cfa;\t\t\\\n-    for (i_ = 0; i_ < 30; ++i_)\t\t\t\t\t\t\\\n-      {\t\t\t\t\t\t\t\t\t\\\n-\t(FS)->regs.reg[i_].how = REG_SAVED_OFFSET;\t\t\t\\\n-\t(FS)->regs.reg[i_].loc.offset\t\t\t\t\t\\\n-\t  = (long)&sc_->sc_regs[i_] - new_cfa_;\t\t\t\t\\\n-      }\t\t\t\t\t\t\t\t\t\\\n-    for (i_ = 0; i_ < 31; ++i_)\t\t\t\t\t\t\\\n-      {\t\t\t\t\t\t\t\t\t\\\n-\t(FS)->regs.reg[i_+32].how = REG_SAVED_OFFSET;\t\t\t\\\n-\t(FS)->regs.reg[i_+32].loc.offset\t\t\t\t\\\n-\t  = (long)&sc_->sc_fpregs[i_] - new_cfa_;\t\t\t\\\n-      }\t\t\t\t\t\t\t\t\t\\\n-    (FS)->regs.reg[64].how = REG_SAVED_OFFSET;\t\t\t\t\\\n-    (FS)->regs.reg[64].loc.offset = (long)&sc_->sc_pc - new_cfa_;\t\\\n-    (FS)->retaddr_column = 64;\t\t\t\t\t\t\\\n-    goto SUCCESS;\t\t\t\t\t\t\t\\\n-  } while (0)\n+#define MD_UNWIND_SUPPORT \"config/alpha/linux-unwind.h\""}, {"sha": "cafe72a6ae1a987bb41ff8466f766ab421f82b39", "filename": "gcc/config/alpha/vms-unwind.h", "status": "added", "additions": 72, "deletions": 0, "changes": 72, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8662eb14c0ef6531d7086ec08f5e52b87c472ede/gcc%2Fconfig%2Falpha%2Fvms-unwind.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8662eb14c0ef6531d7086ec08f5e52b87c472ede/gcc%2Fconfig%2Falpha%2Fvms-unwind.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Falpha%2Fvms-unwind.h?ref=8662eb14c0ef6531d7086ec08f5e52b87c472ede", "patch": "@@ -0,0 +1,72 @@\n+/* DWARF2 EH unwinding support for Alpha VMS.\n+   Copyright (C) 2004 Free Software Foundation, Inc.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GCC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING.  If not, write to\n+the Free Software Foundation, 59 Temple Place - Suite 330,\n+Boston, MA 02111-1307, USA.  */\n+\n+#include <pdscdef.h>\n+\n+#define MD_FALLBACK_FRAME_STATE_FOR alpha_fallback_frame_state\n+\n+static _Unwind_Reason_Code\n+alpha_fallback_frame_state (struct _Unwind_Context *context,\n+\t\t\t    _Unwind_FrameState *fs)\n+{\n+  PDSCDEF *pv = *((PDSCDEF **) context->reg [29]);\n+\n+  if (pv && ((long) pv & 0x7) == 0) /* low bits 0 means address */\n+    pv = *(PDSCDEF **) pv;\n+\n+  if (pv && ((pv->pdsc$w_flags & 0xf) == PDSC$K_KIND_FP_STACK))\n+    {\n+      int i, j;\n+\n+      fs->cfa_offset = pv->pdsc$l_size;\n+      fs->cfa_reg = pv->pdsc$w_flags & PDSC$M_BASE_REG_IS_FP ? 29 : 30;\n+      fs->retaddr_column = 26;\n+      fs->cfa_how = CFA_REG_OFFSET;\n+      fs->regs.reg[27].loc.offset = -pv->pdsc$l_size;\n+      fs->regs.reg[27].how = REG_SAVED_OFFSET;\n+      fs->regs.reg[26].loc.offset\n+\t= -(pv->pdsc$l_size - pv->pdsc$w_rsa_offset);\n+      fs->regs.reg[26].how = REG_SAVED_OFFSET;\n+\n+      for (i = 0, j = 0; i < 32; i++)\n+\tif (1<<i & pv->pdsc$l_ireg_mask)\n+\t  {\n+\t    fs->regs.reg[i].loc.offset\n+\t      = -(pv->pdsc$l_size - pv->pdsc$w_rsa_offset - 8 * ++j);\n+\t    fs->regs.reg[i].how = REG_SAVED_OFFSET;\n+\t  }\n+\n+      return _URC_NO_REASON;\n+    }\n+  else if (pv && ((pv->pdsc$w_flags & 0xf) == PDSC$K_KIND_FP_REGISTER))\n+    {\n+      fs->cfa_offset = pv->pdsc$l_size;\n+      fs->cfa_reg = pv->pdsc$w_flags & PDSC$M_BASE_REG_IS_FP ? 29 : 30;\n+      fs->retaddr_column = 26;\n+      fs->cfa_how = CFA_REG_OFFSET;\n+      fs->regs.reg[26].loc.reg = pv->pdsc$b_save_ra;\n+      fs->regs.reg[26].how = REG_SAVED_REG;\n+      fs->regs.reg[29].loc.reg = pv->pdsc$b_save_fp;\n+      fs->regs.reg[29].how = REG_SAVED_REG;\n+\n+      return _URC_NO_REASON;\n+    }\n+  return _URC_END_OF_STACK;\n+}"}, {"sha": "39fce013c87b3cc1b3175bbf0d4792fd238308c6", "filename": "gcc/config/alpha/vms.h", "status": "modified", "additions": 1, "deletions": 49, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8662eb14c0ef6531d7086ec08f5e52b87c472ede/gcc%2Fconfig%2Falpha%2Fvms.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8662eb14c0ef6531d7086ec08f5e52b87c472ede/gcc%2Fconfig%2Falpha%2Fvms.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Falpha%2Fvms.h?ref=8662eb14c0ef6531d7086ec08f5e52b87c472ede", "patch": "@@ -318,55 +318,7 @@ do {\t\t\t\t\t\t\t\t\t\\\n \n #define LINK_EH_SPEC \"vms-dwarf2eh.o%s \"\n \n-#ifdef IN_LIBGCC2\n-#include <pdscdef.h>\n-\n-#define MD_FALLBACK_FRAME_STATE_FOR(CONTEXT, FS, SUCCESS)\t\t\\\n- do {\t\t\t\t\t\t\t\t\t\\\n-  PDSCDEF *pv = *((PDSCDEF **) (CONTEXT)->reg [29]);                    \\\n-\t\t\t\t\t\t\t\t\t\\\n-  if (pv && ((long) pv & 0x7) == 0) /* low bits 0 means address */      \\\n-    pv = *(PDSCDEF **) pv;                                              \\\n-\t\t\t\t\t\t\t\t\t\\\n-  if (pv && ((pv->pdsc$w_flags & 0xf) == PDSC$K_KIND_FP_STACK))\t\t\\\n-    {\t\t\t\t\t\t\t\t\t\\\n-      int i, j;\t\t\t\t\t\t\t\t\\\n-\t\t\t\t\t\t\t\t\t\\\n-      (FS)->cfa_offset = pv->pdsc$l_size;\t\t\t\t\\\n-      (FS)->cfa_reg = pv->pdsc$w_flags & PDSC$M_BASE_REG_IS_FP ? 29 : 30; \\\n-      (FS)->retaddr_column = 26;\t\t\t\t\t\\\n-      (FS)->cfa_how = CFA_REG_OFFSET;\t\t\t\t\t\\\n-      (FS)->regs.reg[27].loc.offset = -pv->pdsc$l_size;\t\t\t\\\n-      (FS)->regs.reg[27].how = REG_SAVED_OFFSET;\t\t\t\\\n-      (FS)->regs.reg[26].loc.offset\t\t\t\t\t\\\n-\t = -(pv->pdsc$l_size - pv->pdsc$w_rsa_offset);\t\t\t\\\n-      (FS)->regs.reg[26].how = REG_SAVED_OFFSET;\t\t\t\\\n-\t\t\t\t\t\t\t\t\t\\\n-      for (i = 0, j = 0; i < 32; i++)\t\t\t\t\t\\\n-\tif (1<<i & pv->pdsc$l_ireg_mask)\t\t\t\t\\\n-\t  {\t\t\t\t\t\t\t\t\\\n-\t    (FS)->regs.reg[i].loc.offset\t\t\t\t\\\n-\t      = -(pv->pdsc$l_size - pv->pdsc$w_rsa_offset - 8 * ++j);\t\\\n-\t    (FS)->regs.reg[i].how = REG_SAVED_OFFSET;\t\t\t\\\n-\t  }\t\t\t\t\t\t\t\t\\\n-\t\t\t\t\t\t\t\t\t\\\n-      goto SUCCESS;\t\t\t\t\t\t\t\\\n-    }\t\t\t\t\t\t\t\t\t\\\n-  else if (pv && ((pv->pdsc$w_flags & 0xf) == PDSC$K_KIND_FP_REGISTER))\t\\\n-    {\t\t\t\t\t\t\t\t\t\\\n-      (FS)->cfa_offset = pv->pdsc$l_size;\t\t\t\t\\\n-      (FS)->cfa_reg = pv->pdsc$w_flags & PDSC$M_BASE_REG_IS_FP ? 29 : 30; \\\n-      (FS)->retaddr_column = 26;\t\t\t\t\t\\\n-      (FS)->cfa_how = CFA_REG_OFFSET;\t\t\t\t\t\\\n-      (FS)->regs.reg[26].loc.reg = pv->pdsc$b_save_ra;\t\t\t\\\n-      (FS)->regs.reg[26].how = REG_SAVED_REG;\t\t\t        \\\n-      (FS)->regs.reg[29].loc.reg = pv->pdsc$b_save_fp;\t\t\t\\\n-      (FS)->regs.reg[29].how = REG_SAVED_REG;\t\t\t        \\\n-\t\t\t\t\t\t\t\t\t\\\n-      goto SUCCESS;\t\t\t\t\t\t\t\\\n-    }\t\t\t\t\t\t\t\t\t\\\n-} while (0)\n-#endif\n+#define MD_UNWIND_SUPPORT \"config/alpha/vms-unwind.h\"\n \n /* This is how to output an assembler line\n    that says to advance the location counter"}, {"sha": "ce80c9821fdc1ed4c5781ba78b3d4f126654d9b8", "filename": "gcc/config/i386/gnu.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8662eb14c0ef6531d7086ec08f5e52b87c472ede/gcc%2Fconfig%2Fi386%2Fgnu.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8662eb14c0ef6531d7086ec08f5e52b87c472ede/gcc%2Fconfig%2Fi386%2Fgnu.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fgnu.h?ref=8662eb14c0ef6531d7086ec08f5e52b87c472ede", "patch": "@@ -40,4 +40,4 @@\n    %{!static:%{!shared:crtbegin.o%s} %{shared:crtbeginS.o%s}}\"\n \n /* FIXME: Is a Hurd-specific fallback mechanism necessary?  */\n-#undef MD_FALLBACK_FRAME_STATE_FOR\n+#undef MD_UNWIND_SUPPORT"}, {"sha": "ecbce1d337c68050d1f61c253aad78aa638ccb9c", "filename": "gcc/config/i386/linux-unwind.h", "status": "added", "additions": 165, "deletions": 0, "changes": 165, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8662eb14c0ef6531d7086ec08f5e52b87c472ede/gcc%2Fconfig%2Fi386%2Flinux-unwind.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8662eb14c0ef6531d7086ec08f5e52b87c472ede/gcc%2Fconfig%2Fi386%2Flinux-unwind.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Flinux-unwind.h?ref=8662eb14c0ef6531d7086ec08f5e52b87c472ede", "patch": "@@ -0,0 +1,165 @@\n+/* DWARF2 EH unwinding support for AMD x86-64 and x86.\n+   Copyright (C) 2004 Free Software Foundation, Inc.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GCC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING.  If not, write to\n+the Free Software Foundation, 59 Temple Place - Suite 330,\n+Boston, MA 02111-1307, USA.  */\n+\n+/* Do code reading to identify a signal frame, and set the frame\n+   state data appropriately.  See unwind-dw2.c for the structs.\n+   Don't use this at all if inhibit_libc is used.  */\n+\n+#ifndef inhibit_libc\n+\n+#ifdef __x86_64__\n+\n+#include <signal.h>\n+#include <sys/ucontext.h>\n+\n+#define MD_FALLBACK_FRAME_STATE_FOR x86_64_fallback_frame_state\n+\n+static _Unwind_Reason_Code\n+x86_64_fallback_frame_state (struct _Unwind_Context *context,\n+\t\t\t     _Unwind_FrameState *fs)\n+{\n+  unsigned char *pc = context->ra;\n+  struct sigcontext *sc;\n+  long new_cfa;\n+\n+  /* movq __NR_rt_sigreturn, %rax ; syscall  */\n+  if (*(unsigned char *)(pc+0) == 0x48\n+      && *(unsigned long *)(pc+1) == 0x050f0000000fc0c7)\n+    {\n+      struct ucontext *uc_ = context->cfa;\n+      sc = (struct sigcontext *) &uc_->uc_mcontext;\n+    }\n+  else\n+    return _URC_END_OF_STACK;\n+\n+  new_cfa = sc->rsp;\n+  fs->cfa_how = CFA_REG_OFFSET;\n+  /* Register 7 is rsp  */\n+  fs->cfa_reg = 7;\n+  fs->cfa_offset = new_cfa - (long) context->cfa;\n+\n+  /* The SVR4 register numbering macros aren't usable in libgcc.  */\n+  fs->regs.reg[0].how = REG_SAVED_OFFSET;\n+  fs->regs.reg[0].loc.offset = (long)&sc->rax - new_cfa;\n+  fs->regs.reg[1].how = REG_SAVED_OFFSET;\n+  fs->regs.reg[1].loc.offset = (long)&sc->rdx - new_cfa;\n+  fs->regs.reg[2].how = REG_SAVED_OFFSET;\n+  fs->regs.reg[2].loc.offset = (long)&sc->rcx - new_cfa;\n+  fs->regs.reg[3].how = REG_SAVED_OFFSET;\n+  fs->regs.reg[3].loc.offset = (long)&sc->rbx - new_cfa;\n+  fs->regs.reg[4].how = REG_SAVED_OFFSET;\n+  fs->regs.reg[4].loc.offset = (long)&sc->rsi - new_cfa;\n+  fs->regs.reg[5].how = REG_SAVED_OFFSET;\n+  fs->regs.reg[5].loc.offset = (long)&sc->rdi - new_cfa;\n+  fs->regs.reg[6].how = REG_SAVED_OFFSET;\n+  fs->regs.reg[6].loc.offset = (long)&sc->rbp - new_cfa;\n+  fs->regs.reg[8].how = REG_SAVED_OFFSET;\n+  fs->regs.reg[8].loc.offset = (long)&sc->r8 - new_cfa;\n+  fs->regs.reg[9].how = REG_SAVED_OFFSET;\n+  fs->regs.reg[9].loc.offset = (long)&sc->r9 - new_cfa;\n+  fs->regs.reg[10].how = REG_SAVED_OFFSET;\n+  fs->regs.reg[10].loc.offset = (long)&sc->r10 - new_cfa;\n+  fs->regs.reg[11].how = REG_SAVED_OFFSET;\n+  fs->regs.reg[11].loc.offset = (long)&sc->r11 - new_cfa;\n+  fs->regs.reg[12].how = REG_SAVED_OFFSET;\n+  fs->regs.reg[12].loc.offset = (long)&sc->r12 - new_cfa;\n+  fs->regs.reg[13].how = REG_SAVED_OFFSET;\n+  fs->regs.reg[13].loc.offset = (long)&sc->r13 - new_cfa;\n+  fs->regs.reg[14].how = REG_SAVED_OFFSET;\n+  fs->regs.reg[14].loc.offset = (long)&sc->r14 - new_cfa;\n+  fs->regs.reg[15].how = REG_SAVED_OFFSET;\n+  fs->regs.reg[15].loc.offset = (long)&sc->r15 - new_cfa;\n+  fs->regs.reg[16].how = REG_SAVED_OFFSET;\n+  fs->regs.reg[16].loc.offset = (long)&sc->rip - new_cfa;\n+  fs->retaddr_column = 16;\n+  return _URC_NO_REASON;\n+}\n+\n+#else /* ifdef __x86_64__  */\n+\n+/* There's no sys/ucontext.h for glibc 2.0, so no\n+   signal-turned-exceptions for them.  There's also no configure-run for\n+   the target, so we can't check on (e.g.) HAVE_SYS_UCONTEXT_H.  Using the\n+   target libc version macro should be enough.  */\n+#if !(__GLIBC__ == 2 && __GLIBC_MINOR__ == 0)\n+\n+#include <signal.h>\n+#include <sys/ucontext.h>\n+\n+#define MD_FALLBACK_FRAME_STATE_FOR x86_fallback_frame_state\n+\n+static _Unwind_Reason_Code\n+x86_fallback_frame_state (struct _Unwind_Context *context,\n+\t\t\t  _Unwind_FrameState *fs)\n+{\n+  unsigned char *pc = context->ra;\n+  struct sigcontext *sc;\n+  long new_cfa;\n+\n+  /* popl %eax ; movl $__NR_sigreturn,%eax ; int $0x80  */\n+  if (*(unsigned short *)(pc+0) == 0xb858\n+      && *(unsigned int *)(pc+2) == 119\n+      && *(unsigned short *)(pc+6) == 0x80cd)\n+    sc = context->cfa + 4;\n+  /* movl $__NR_rt_sigreturn,%eax ; int $0x80  */\n+  else if (*(unsigned char *)(pc+0) == 0xb8\n+\t   && *(unsigned int *)(pc+1) == 173\n+\t   && *(unsigned short *)(pc+5) == 0x80cd)\n+    {\n+      struct rt_sigframe {\n+\tint sig;\n+\tstruct siginfo *pinfo;\n+\tvoid *puc;\n+\tstruct siginfo info;\n+\tstruct ucontext uc;\n+      } *rt_ = context->cfa;\n+      sc = (struct sigcontext *) &rt_->uc.uc_mcontext;\n+    }\n+  else\n+    return _URC_END_OF_STACK;\n+\n+  new_cfa = sc->esp;\n+  fs->cfa_how = CFA_REG_OFFSET;\n+  fs->cfa_reg = 4;\n+  fs->cfa_offset = new_cfa - (long) context->cfa;\n+\n+  /* The SVR4 register numbering macros aren't usable in libgcc.  */\n+  fs->regs.reg[0].how = REG_SAVED_OFFSET;\n+  fs->regs.reg[0].loc.offset = (long)&sc->eax - new_cfa;\n+  fs->regs.reg[3].how = REG_SAVED_OFFSET;\n+  fs->regs.reg[3].loc.offset = (long)&sc->ebx - new_cfa;\n+  fs->regs.reg[1].how = REG_SAVED_OFFSET;\n+  fs->regs.reg[1].loc.offset = (long)&sc->ecx - new_cfa;\n+  fs->regs.reg[2].how = REG_SAVED_OFFSET;\n+  fs->regs.reg[2].loc.offset = (long)&sc->edx - new_cfa;\n+  fs->regs.reg[6].how = REG_SAVED_OFFSET;\n+  fs->regs.reg[6].loc.offset = (long)&sc->esi - new_cfa;\n+  fs->regs.reg[7].how = REG_SAVED_OFFSET;\n+  fs->regs.reg[7].loc.offset = (long)&sc->edi - new_cfa;\n+  fs->regs.reg[5].how = REG_SAVED_OFFSET;\n+  fs->regs.reg[5].loc.offset = (long)&sc->ebp - new_cfa;\n+  fs->regs.reg[8].how = REG_SAVED_OFFSET;\n+  fs->regs.reg[8].loc.offset = (long)&sc->eip - new_cfa;\n+  fs->retaddr_column = 8;\n+  return _URC_NO_REASON;\n+}\n+#endif /* not glibc 2.0 */\n+#endif /* ifdef __x86_64__  */\n+#endif /* ifdef inhibit_libc  */"}, {"sha": "e31c5114e93fbc21bc33843f2fd72ad63715d050", "filename": "gcc/config/i386/linux.h", "status": "modified", "additions": 1, "deletions": 69, "changes": 70, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8662eb14c0ef6531d7086ec08f5e52b87c472ede/gcc%2Fconfig%2Fi386%2Flinux.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8662eb14c0ef6531d7086ec08f5e52b87c472ede/gcc%2Fconfig%2Fi386%2Flinux.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Flinux.h?ref=8662eb14c0ef6531d7086ec08f5e52b87c472ede", "patch": "@@ -181,72 +181,4 @@ Boston, MA 02111-1307, USA.  */\n #undef NEED_INDICATE_EXEC_STACK\n #define NEED_INDICATE_EXEC_STACK 1\n \n-/* Do code reading to identify a signal frame, and set the frame\n-   state data appropriately.  See unwind-dw2.c for the structs.  */\n-\n-#ifdef IN_LIBGCC2\n-/* There's no sys/ucontext.h for glibc 2.0, so no\n-   signal-turned-exceptions for them.  There's also no configure-run for\n-   the target, so we can't check on (e.g.) HAVE_SYS_UCONTEXT_H.  Using the\n-   target libc version macro should be enough.  */\n-#if !(__GLIBC__ == 2 && __GLIBC_MINOR__ == 0)\n-#include <signal.h>\n-#include <sys/ucontext.h>\n-\n-#define REG_NAME(reg) reg\n-\n-#define MD_FALLBACK_FRAME_STATE_FOR(CONTEXT, FS, SUCCESS)\t\t\\\n-  do {\t\t\t\t\t\t\t\t\t\\\n-    unsigned char *pc_ = (CONTEXT)->ra;\t\t\t\t\t\\\n-    struct sigcontext *sc_;\t\t\t\t\t\t\\\n-    long new_cfa_;\t\t\t\t\t\t\t\\\n-\t\t\t\t\t\t\t\t\t\\\n-    /* popl %eax ; movl $__NR_sigreturn,%eax ; int $0x80  */\t\t\\\n-    if (*(unsigned short *)(pc_+0) == 0xb858\t\t\t\t\\\n-\t&& *(unsigned int *)(pc_+2) == 119\t\t\t\t\\\n-\t&& *(unsigned short *)(pc_+6) == 0x80cd)\t\t\t\\\n-      sc_ = (CONTEXT)->cfa + 4;\t\t\t\t\t\t\\\n-    /* movl $__NR_rt_sigreturn,%eax ; int $0x80  */\t\t\t\\\n-    else if (*(unsigned char *)(pc_+0) == 0xb8\t\t\t\t\\\n-\t     && *(unsigned int *)(pc_+1) == 173\t\t\t\t\\\n-\t     && *(unsigned short *)(pc_+5) == 0x80cd)\t\t\t\\\n-      {\t\t\t\t\t\t\t\t\t\\\n-\tstruct rt_sigframe {\t\t\t\t\t\t\\\n-\t  int sig;\t\t\t\t\t\t\t\\\n-\t  struct siginfo *pinfo;\t\t\t\t\t\\\n-\t  void *puc;\t\t\t\t\t\t\t\\\n-\t  struct siginfo info;\t\t\t\t\t\t\\\n-\t  struct ucontext uc;\t\t\t\t\t\t\\\n-\t} *rt_ = (CONTEXT)->cfa;\t\t\t\t\t\\\n-\tsc_ = (struct sigcontext *) &rt_->uc.uc_mcontext;\t\t\\\n-      }\t\t\t\t\t\t\t\t\t\\\n-    else\t\t\t\t\t\t\t\t\\\n-      break;\t\t\t\t\t\t\t\t\\\n-\t\t\t\t\t\t\t\t\t\\\n-    new_cfa_ = sc_->REG_NAME(esp);\t\t\t\t\t\t\\\n-    (FS)->cfa_how = CFA_REG_OFFSET;\t\t\t\t\t\\\n-    (FS)->cfa_reg = 4;\t\t\t\t\t\t\t\\\n-    (FS)->cfa_offset = new_cfa_ - (long) (CONTEXT)->cfa;\t\t\\\n-\t\t\t\t\t\t\t\t\t\\\n-    /* The SVR4 register numbering macros aren't usable in libgcc.  */\t\\\n-    (FS)->regs.reg[0].how = REG_SAVED_OFFSET;\t\t\t\t\\\n-    (FS)->regs.reg[0].loc.offset = (long)&sc_->REG_NAME(eax) - new_cfa_;\t\\\n-    (FS)->regs.reg[3].how = REG_SAVED_OFFSET;\t\t\t\t\\\n-    (FS)->regs.reg[3].loc.offset = (long)&sc_->REG_NAME(ebx) - new_cfa_;\t\\\n-    (FS)->regs.reg[1].how = REG_SAVED_OFFSET;\t\t\t\t\\\n-    (FS)->regs.reg[1].loc.offset = (long)&sc_->REG_NAME(ecx) - new_cfa_;\t\\\n-    (FS)->regs.reg[2].how = REG_SAVED_OFFSET;\t\t\t\t\\\n-    (FS)->regs.reg[2].loc.offset = (long)&sc_->REG_NAME(edx) - new_cfa_;\t\\\n-    (FS)->regs.reg[6].how = REG_SAVED_OFFSET;\t\t\t\t\\\n-    (FS)->regs.reg[6].loc.offset = (long)&sc_->REG_NAME(esi) - new_cfa_;\t\\\n-    (FS)->regs.reg[7].how = REG_SAVED_OFFSET;\t\t\t\t\\\n-    (FS)->regs.reg[7].loc.offset = (long)&sc_->REG_NAME(edi) - new_cfa_;\t\\\n-    (FS)->regs.reg[5].how = REG_SAVED_OFFSET;\t\t\t\t\\\n-    (FS)->regs.reg[5].loc.offset = (long)&sc_->REG_NAME(ebp) - new_cfa_;\t\\\n-    (FS)->regs.reg[8].how = REG_SAVED_OFFSET;\t\t\t\t\\\n-    (FS)->regs.reg[8].loc.offset = (long)&sc_->REG_NAME(eip) - new_cfa_;\t\\\n-    (FS)->retaddr_column = 8;\t\t\t\t\t\t\\\n-    goto SUCCESS;\t\t\t\t\t\t\t\\\n-  } while (0)\n-#endif /* not glibc 2.0 */\n-#endif /* IN_LIBGCC2 */\n+#define MD_UNWIND_SUPPORT \"config/i386/linux-unwind.h\""}, {"sha": "4838cf8fa8ed85cd4e3ef803653df2927456248f", "filename": "gcc/config/i386/linux64.h", "status": "modified", "additions": 1, "deletions": 125, "changes": 126, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8662eb14c0ef6531d7086ec08f5e52b87c472ede/gcc%2Fconfig%2Fi386%2Flinux64.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8662eb14c0ef6531d7086ec08f5e52b87c472ede/gcc%2Fconfig%2Fi386%2Flinux64.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Flinux64.h?ref=8662eb14c0ef6531d7086ec08f5e52b87c472ede", "patch": "@@ -69,128 +69,4 @@ Boston, MA 02111-1307, USA.  */\n #undef NEED_INDICATE_EXEC_STACK\n #define NEED_INDICATE_EXEC_STACK 1\n \n-/* Do code reading to identify a signal frame, and set the frame\n-   state data appropriately.  See unwind-dw2.c for the structs.  \n-   Don't use this at all if inhibit_libc is used.  */\n-\n-#ifndef inhibit_libc\n-#ifdef IN_LIBGCC2\n-#include <signal.h>\n-#include <sys/ucontext.h>\n-#endif\n-\n-#ifdef __x86_64__\n-#define MD_FALLBACK_FRAME_STATE_FOR(CONTEXT, FS, SUCCESS)\t\t\\\n-  do {\t\t\t\t\t\t\t\t\t\\\n-    unsigned char *pc_ = (CONTEXT)->ra;\t\t\t\t\t\\\n-    struct sigcontext *sc_;\t\t\t\t\t\t\\\n-    long new_cfa_;\t\t\t\t\t\t\t\\\n-\t\t\t\t\t\t\t\t\t\\\n-    /* movq __NR_rt_sigreturn, %rax ; syscall  */\t\t\t\\\n-    if (*(unsigned char *)(pc_+0) == 0x48\t\t\t\t\\\n-\t&& *(unsigned long *)(pc_+1) == 0x050f0000000fc0c7)\t\t\\\n-      {\t\t\t\t\t\t\t\t\t\\\n-\tstruct ucontext *uc_ = (CONTEXT)->cfa;\t\t\t\t\\\n-\tsc_ = (struct sigcontext *) &uc_->uc_mcontext;\t\t\t\\\n-      }\t\t\t\t\t\t\t\t\t\\\n-    else\t\t\t\t\t\t\t\t\\\n-      break;\t\t\t\t\t\t\t\t\\\n-\t\t\t\t\t\t\t\t\t\\\n-    new_cfa_ = sc_->rsp;\t\t\t\t\t\t\\\n-    (FS)->cfa_how = CFA_REG_OFFSET;\t\t\t\t\t\\\n-    /* Register 7 is rsp  */\t\t\t\t\t\t\\\n-    (FS)->cfa_reg = 7;\t\t\t\t\t\t\t\\\n-    (FS)->cfa_offset = new_cfa_ - (long) (CONTEXT)->cfa;\t\t\\\n-\t\t\t\t\t\t\t\t\t\\\n-    /* The SVR4 register numbering macros aren't usable in libgcc.  */\t\\\n-    (FS)->regs.reg[0].how = REG_SAVED_OFFSET;\t\t\t\t\\\n-    (FS)->regs.reg[0].loc.offset = (long)&sc_->rax - new_cfa_;\t\t\\\n-    (FS)->regs.reg[1].how = REG_SAVED_OFFSET;\t\t\t\t\\\n-    (FS)->regs.reg[1].loc.offset = (long)&sc_->rdx - new_cfa_;\t\t\\\n-    (FS)->regs.reg[2].how = REG_SAVED_OFFSET;\t\t\t\t\\\n-    (FS)->regs.reg[2].loc.offset = (long)&sc_->rcx - new_cfa_;\t\t\\\n-    (FS)->regs.reg[3].how = REG_SAVED_OFFSET;\t\t\t\t\\\n-    (FS)->regs.reg[3].loc.offset = (long)&sc_->rbx - new_cfa_;\t\t\\\n-    (FS)->regs.reg[4].how = REG_SAVED_OFFSET;\t\t\t\t\\\n-    (FS)->regs.reg[4].loc.offset = (long)&sc_->rsi - new_cfa_;\t\t\\\n-    (FS)->regs.reg[5].how = REG_SAVED_OFFSET;\t\t\t\t\\\n-    (FS)->regs.reg[5].loc.offset = (long)&sc_->rdi - new_cfa_;\t\t\\\n-    (FS)->regs.reg[6].how = REG_SAVED_OFFSET;\t\t\t\t\\\n-    (FS)->regs.reg[6].loc.offset = (long)&sc_->rbp - new_cfa_;\t\t\\\n-    (FS)->regs.reg[8].how = REG_SAVED_OFFSET;\t\t\t\t\\\n-    (FS)->regs.reg[8].loc.offset = (long)&sc_->r8 - new_cfa_;\t\t\\\n-    (FS)->regs.reg[9].how = REG_SAVED_OFFSET;\t\t\t\t\\\n-    (FS)->regs.reg[9].loc.offset = (long)&sc_->r9 - new_cfa_;\t\t\\\n-    (FS)->regs.reg[10].how = REG_SAVED_OFFSET;\t\t\t\t\\\n-    (FS)->regs.reg[10].loc.offset = (long)&sc_->r10 - new_cfa_;\t\t\\\n-    (FS)->regs.reg[11].how = REG_SAVED_OFFSET;\t\t\t\t\\\n-    (FS)->regs.reg[11].loc.offset = (long)&sc_->r11 - new_cfa_;\t\t\\\n-    (FS)->regs.reg[12].how = REG_SAVED_OFFSET;\t\t\t\t\\\n-    (FS)->regs.reg[12].loc.offset = (long)&sc_->r12 - new_cfa_;\t\t\\\n-    (FS)->regs.reg[13].how = REG_SAVED_OFFSET;\t\t\t\t\\\n-    (FS)->regs.reg[13].loc.offset = (long)&sc_->r13 - new_cfa_;\t\t\\\n-    (FS)->regs.reg[14].how = REG_SAVED_OFFSET;\t\t\t\t\\\n-    (FS)->regs.reg[14].loc.offset = (long)&sc_->r14 - new_cfa_;\t\t\\\n-    (FS)->regs.reg[15].how = REG_SAVED_OFFSET;\t\t\t\t\\\n-    (FS)->regs.reg[15].loc.offset = (long)&sc_->r15 - new_cfa_;\t\t\\\n-    (FS)->regs.reg[16].how = REG_SAVED_OFFSET;\t\t\t\t\\\n-    (FS)->regs.reg[16].loc.offset = (long)&sc_->rip - new_cfa_;\t\t\\\n-    (FS)->retaddr_column = 16;\t\t\t\t\t\t\\\n-    goto SUCCESS;\t\t\t\t\t\t\t\\\n-  } while (0)\n-#else /* ifdef __x86_64__  */\n-#define MD_FALLBACK_FRAME_STATE_FOR(CONTEXT, FS, SUCCESS)\t\t\\\n-  do {\t\t\t\t\t\t\t\t\t\\\n-    unsigned char *pc_ = (CONTEXT)->ra;\t\t\t\t\t\\\n-    struct sigcontext *sc_;\t\t\t\t\t\t\\\n-    long new_cfa_;\t\t\t\t\t\t\t\\\n-\t\t\t\t\t\t\t\t\t\\\n-    /* popl %eax ; movl $__NR_sigreturn,%eax ; int $0x80  */\t\t\\\n-    if (*(unsigned short *)(pc_+0) == 0xb858\t\t\t\t\\\n-\t&& *(unsigned int *)(pc_+2) == 119\t\t\t\t\\\n-\t&& *(unsigned short *)(pc_+6) == 0x80cd)\t\t\t\\\n-      sc_ = (CONTEXT)->cfa + 4;\t\t\t\t\t\t\\\n-    /* movl $__NR_rt_sigreturn,%eax ; int $0x80  */\t\t\t\\\n-    else if (*(unsigned char *)(pc_+0) == 0xb8\t\t\t\t\\\n-\t     && *(unsigned int *)(pc_+1) == 173\t\t\t\t\\\n-\t     && *(unsigned short *)(pc_+5) == 0x80cd)\t\t\t\\\n-      {\t\t\t\t\t\t\t\t\t\\\n-\tstruct rt_sigframe {\t\t\t\t\t\t\\\n-\t  int sig;\t\t\t\t\t\t\t\\\n-\t  struct siginfo *pinfo;\t\t\t\t\t\\\n-\t  void *puc;\t\t\t\t\t\t\t\\\n-\t  struct siginfo info;\t\t\t\t\t\t\\\n-\t  struct ucontext uc;\t\t\t\t\t\t\\\n-\t} *rt_ = (CONTEXT)->cfa;\t\t\t\t\t\\\n-\tsc_ = (struct sigcontext *) &rt_->uc.uc_mcontext;\t\t\\\n-      }\t\t\t\t\t\t\t\t\t\\\n-    else\t\t\t\t\t\t\t\t\\\n-      break;\t\t\t\t\t\t\t\t\\\n-\t\t\t\t\t\t\t\t\t\\\n-    new_cfa_ = sc_->esp;\t\t\t\t\t\t\\\n-    (FS)->cfa_how = CFA_REG_OFFSET;\t\t\t\t\t\\\n-    (FS)->cfa_reg = 4;\t\t\t\t\t\t\t\\\n-    (FS)->cfa_offset = new_cfa_ - (long) (CONTEXT)->cfa;\t\t\\\n-\t\t\t\t\t\t\t\t\t\\\n-    /* The SVR4 register numbering macros aren't usable in libgcc.  */\t\\\n-    (FS)->regs.reg[0].how = REG_SAVED_OFFSET;\t\t\t\t\\\n-    (FS)->regs.reg[0].loc.offset = (long)&sc_->eax - new_cfa_;\t\t\\\n-    (FS)->regs.reg[3].how = REG_SAVED_OFFSET;\t\t\t\t\\\n-    (FS)->regs.reg[3].loc.offset = (long)&sc_->ebx - new_cfa_;\t\t\\\n-    (FS)->regs.reg[1].how = REG_SAVED_OFFSET;\t\t\t\t\\\n-    (FS)->regs.reg[1].loc.offset = (long)&sc_->ecx - new_cfa_;\t\t\\\n-    (FS)->regs.reg[2].how = REG_SAVED_OFFSET;\t\t\t\t\\\n-    (FS)->regs.reg[2].loc.offset = (long)&sc_->edx - new_cfa_;\t\t\\\n-    (FS)->regs.reg[6].how = REG_SAVED_OFFSET;\t\t\t\t\\\n-    (FS)->regs.reg[6].loc.offset = (long)&sc_->esi - new_cfa_;\t\t\\\n-    (FS)->regs.reg[7].how = REG_SAVED_OFFSET;\t\t\t\t\\\n-    (FS)->regs.reg[7].loc.offset = (long)&sc_->edi - new_cfa_;\t\t\\\n-    (FS)->regs.reg[5].how = REG_SAVED_OFFSET;\t\t\t\t\\\n-    (FS)->regs.reg[5].loc.offset = (long)&sc_->ebp - new_cfa_;\t\t\\\n-    (FS)->regs.reg[8].how = REG_SAVED_OFFSET;\t\t\t\t\\\n-    (FS)->regs.reg[8].loc.offset = (long)&sc_->eip - new_cfa_;\t\t\\\n-    (FS)->retaddr_column = 8;\t\t\t\t\t\t\\\n-    goto SUCCESS;\t\t\t\t\t\t\t\\\n-  } while (0)\n-#endif /* ifdef __x86_64__  */\n-#endif /* ifdef inhibit_libc  */\n+#define MD_UNWIND_SUPPORT \"config/i386/linux-unwind.h\""}, {"sha": "801597ce3110d64b1b973c96bbe40faf11624e29", "filename": "gcc/config/ia64/linux-unwind.h", "status": "added", "additions": 185, "deletions": 0, "changes": 185, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8662eb14c0ef6531d7086ec08f5e52b87c472ede/gcc%2Fconfig%2Fia64%2Flinux-unwind.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8662eb14c0ef6531d7086ec08f5e52b87c472ede/gcc%2Fconfig%2Fia64%2Flinux-unwind.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fia64%2Flinux-unwind.h?ref=8662eb14c0ef6531d7086ec08f5e52b87c472ede", "patch": "@@ -0,0 +1,185 @@\n+/* DWARF2 EH unwinding support for IA64 Linux.\n+   Copyright (C) 2004 Free Software Foundation, Inc.\n+\n+   This file is part of GCC.\n+\n+   GCC is free software; you can redistribute it and/or modify it\n+   under the terms of the GNU General Public License as published\n+   by the Free Software Foundation; either version 2, or (at your\n+   option) any later version.\n+\n+   GCC is distributed in the hope that it will be useful, but WITHOUT\n+   ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n+   or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public\n+   License for more details.\n+\n+   You should have received a copy of the GNU General Public License\n+   along with GCC; see the file COPYING.  If not, write to the\n+   Free Software Foundation, 59 Temple Place - Suite 330, Boston,\n+   MA 02111-1307, USA.  */\n+\n+/* Do code reading to identify a signal frame, and set the frame\n+   state data appropriately.  See unwind-dw2.c for the structs.  */\n+\n+/* This works only for glibc-2.3 and later, because sigcontext is different\n+   in glibc-2.2.4.  */\n+\n+#if __GLIBC__ > 2 || (__GLIBC__ == 2 && __GLIBC_MINOR__ >= 3)\n+#include <signal.h>\n+#include <sys/ucontext.h>\n+\n+#define IA64_GATE_AREA_START 0xa000000000000100LL\n+#define IA64_GATE_AREA_END   0xa000000000030000LL\n+\n+#define MD_FALLBACK_FRAME_STATE_FOR ia64_fallback_frame_state\n+\n+static _Unwind_Reason_Code\n+ia64_fallback_frame_state (struct _Unwind_Context *context,\n+\t\t\t   _Unwind_FrameState *fs)\n+{\n+  if (context->rp >= IA64_GATE_AREA_START\n+      && context->rp < IA64_GATE_AREA_END)\n+    {\n+      struct sigframe {\n+\tchar scratch[16];\n+\tunsigned long sig_number;\n+\tstruct siginfo *info;\n+\tstruct sigcontext *sc;\n+      } *frame_ = (struct sigframe *)context->psp;\n+      struct sigcontext *sc = frame_->sc;\n+\n+      /* Restore scratch registers in case the unwinder needs to\n+\t refer to a value stored in one of them.  */\n+      {\n+\tint i;\n+\n+\tfor (i = 2; i < 4; i++)\n+\t  context->ireg[i - 2].loc = &sc->sc_gr[i];\n+\tfor (i = 8; i < 12; i++)\n+\t  context->ireg[i - 2].loc = &sc->sc_gr[i];\n+\tfor (i = 14; i < 32; i++)\n+\t  context->ireg[i - 2].loc = &sc->sc_gr[i];\n+      }\n+\n+      context->fpsr_loc = &(sc->sc_ar_fpsr);\n+      context->pfs_loc = &(sc->sc_ar_pfs);\n+      context->lc_loc = &(sc->sc_ar_lc);\n+      context->unat_loc = &(sc->sc_ar_unat);\n+      context->br_loc[0] = &(sc->sc_br[0]);\n+      context->br_loc[6] = &(sc->sc_br[6]);\n+      context->br_loc[7] = &(sc->sc_br[7]);\n+      context->pr = sc->sc_pr;\n+      context->psp = sc->sc_gr[12];\n+      context->gp = sc->sc_gr[1];\n+      /* Signal frame doesn't have an associated reg. stack frame\n+         other than what we adjust for below.\t  */\n+      fs -> no_reg_stack_frame = 1;\n+\n+      if (sc->sc_rbs_base)\n+\t{\n+\t  /* Need to switch from alternate register backing store.  */\n+\t  long ndirty, loadrs = sc->sc_loadrs >> 16;\n+\t  unsigned long alt_bspstore = context->bsp - loadrs;\n+\t  unsigned long bspstore;\n+\t  unsigned long *ar_bsp = (unsigned long *)(sc->sc_ar_bsp);\n+\n+\t  ndirty = ia64_rse_num_regs ((unsigned long *) alt_bspstore,\n+\t\t\t\t      (unsigned long *) context->bsp);\n+\t  bspstore = (unsigned long)\n+\t    ia64_rse_skip_regs (ar_bsp, -ndirty);\n+\t  ia64_copy_rbs (context, bspstore, alt_bspstore, loadrs,\n+\t\t\t sc->sc_ar_rnat);\n+\t}\n+\n+      /* Don't touch the branch registers o.t. b0, b6 and b7.\n+\t The kernel doesn't pass the preserved branch registers\n+\t in the sigcontext but leaves them intact, so there's no\n+\t need to do anything with them here.  */\n+      {\n+\tunsigned long sof = sc->sc_cfm & 0x7f;\n+\tcontext->bsp = (unsigned long)\n+\t  ia64_rse_skip_regs ((unsigned long *)(sc->sc_ar_bsp), -sof);\n+      }\n+\n+      fs->curr.reg[UNW_REG_RP].where = UNW_WHERE_SPREL;\n+      fs->curr.reg[UNW_REG_RP].val\n+\t= (unsigned long)&(sc->sc_ip) - context->psp;\n+      fs->curr.reg[UNW_REG_RP].when = -1;\n+\n+      return _URC_NO_REASON;\n+    }\n+  return _URC_END_OF_STACK;\n+}\n+\n+#define MD_HANDLE_UNWABI ia64_handle_unwabi\n+\n+static void\n+ia64_handle_unwabi (struct _Unwind_Context *context, _Unwind_FrameState *fs)\n+{\n+  if (fs->unwabi == ((3 << 8) | 's')\n+      || fs->unwabi == ((0 << 8) | 's'))\n+    {\n+      struct sigframe {\n+\tchar scratch[16];\n+\tunsigned long sig_number;\n+\tstruct siginfo *info;\n+\tstruct sigcontext *sc;\n+      } *frame = (struct sigframe *)context->psp;\n+      struct sigcontext *sc = frame->sc;\n+\n+      /* Restore scratch registers in case the unwinder needs to\n+\t refer to a value stored in one of them.  */\n+      {\n+\tint i;\n+\n+\tfor (i = 2; i < 4; i++)\n+\t  context->ireg[i - 2].loc = &sc->sc_gr[i];\n+\tfor (i = 8; i < 12; i++)\n+\t  context->ireg[i - 2].loc = &sc->sc_gr[i];\n+\tfor (i = 14; i < 32; i++)\n+\t  context->ireg[i - 2].loc = &sc->sc_gr[i];\n+      }\n+\n+      context->pfs_loc = &(sc->sc_ar_pfs);\n+      context->lc_loc = &(sc->sc_ar_lc);\n+      context->unat_loc = &(sc->sc_ar_unat);\n+      context->br_loc[0] = &(sc->sc_br[0]);\n+      context->br_loc[6] = &(sc->sc_br[6]);\n+      context->br_loc[7] = &(sc->sc_br[7]);\n+      context->pr = sc->sc_pr;\n+      context->gp = sc->sc_gr[1];\n+      /* Signal frame doesn't have an associated reg. stack frame\n+         other than what we adjust for below.\t  */\n+      fs -> no_reg_stack_frame = 1;\n+\n+      if (sc->sc_rbs_base)\n+\t{\n+\t  /* Need to switch from alternate register backing store.  */\n+\t  long ndirty, loadrs = sc->sc_loadrs >> 16;\n+\t  unsigned long alt_bspstore = context->bsp - loadrs;\n+\t  unsigned long bspstore;\n+\t  unsigned long *ar_bsp = (unsigned long *)(sc->sc_ar_bsp);\n+\n+\t  ndirty = ia64_rse_num_regs ((unsigned long *) alt_bspstore,\n+\t\t\t\t      (unsigned long *) context->bsp);\n+\t  bspstore = (unsigned long) ia64_rse_skip_regs (ar_bsp, -ndirty);\n+\t  ia64_copy_rbs (context, bspstore, alt_bspstore, loadrs,\n+\t\t\t sc->sc_ar_rnat);\n+\t}\n+\n+      /* Don't touch the branch registers o.t. b0, b6 and b7.\n+\t The kernel doesn't pass the preserved branch registers\n+\t in the sigcontext but leaves them intact, so there's no\n+\t need to do anything with them here.  */\n+      {\n+\tunsigned long sof = sc->sc_cfm & 0x7f;\n+\tcontext->bsp = (unsigned long)\n+\t  ia64_rse_skip_regs ((unsigned long *)(sc->sc_ar_bsp), -sof);\n+      }\n+\n+      /* pfs_loc already set above.  Without this pfs_loc would point\n+\t incorrectly to sc_cfm instead of sc_ar_pfs.  */\n+      fs->curr.reg[UNW_REG_PFS].where = UNW_WHERE_NONE;\n+    }\n+}\n+#endif /* glibc-2.3 or better */"}, {"sha": "3d585609f61fd9241a167237e931281af76d0dfb", "filename": "gcc/config/ia64/linux.h", "status": "modified", "additions": 1, "deletions": 158, "changes": 159, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8662eb14c0ef6531d7086ec08f5e52b87c472ede/gcc%2Fconfig%2Fia64%2Flinux.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8662eb14c0ef6531d7086ec08f5e52b87c472ede/gcc%2Fconfig%2Fia64%2Flinux.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fia64%2Flinux.h?ref=8662eb14c0ef6531d7086ec08f5e52b87c472ede", "patch": "@@ -55,161 +55,4 @@ do {\t\t\t\t\t\t\\\n #undef LINK_EH_SPEC\n #define LINK_EH_SPEC \"\"\n \n-/* Do code reading to identify a signal frame, and set the frame\n-   state data appropriately.  See unwind-dw2.c for the structs.  */\n-\n-/* This works only for glibc-2.3 and later, because sigcontext is different\n-   in glibc-2.2.4.  */\n-\n-#if __GLIBC__ > 2 || (__GLIBC__ == 2 && __GLIBC_MINOR__ >= 3)\n-\n-#ifdef IN_LIBGCC2\n-#include <signal.h>\n-#include <sys/ucontext.h>\n-\n-#define IA64_GATE_AREA_START 0xa000000000000100LL\n-#define IA64_GATE_AREA_END   0xa000000000030000LL\n-\n-#define MD_FALLBACK_FRAME_STATE_FOR(CONTEXT, FS, SUCCESS)\t\t\\\n-  if ((CONTEXT)->rp >= IA64_GATE_AREA_START\t\t\t\t\\\n-      && (CONTEXT)->rp < IA64_GATE_AREA_END)\t\t\t\t\\\n-    {\t\t\t\t\t\t\t\t\t\\\n-      struct sigframe {\t\t\t\t\t\t\t\\\n-\tchar scratch[16];\t\t\t\t\t\t\\\n-\tunsigned long sig_number;\t\t\t\t\t\\\n-\tstruct siginfo *info;\t\t\t\t\t\t\\\n-\tstruct sigcontext *sc;\t\t\t\t\t\t\\\n-      } *frame_ = (struct sigframe *)(CONTEXT)->psp;\t\t\t\\\n-      struct sigcontext *sc_ = frame_->sc;\t\t\t\t\\\n-\t\t\t\t\t\t\t\t\t\\\n-      /* Restore scratch registers in case the unwinder needs to\t\\\n-\t refer to a value stored in one of them.  */\t\t\t\\\n-      {\t\t\t\t\t\t\t\t\t\\\n-\tint i_;\t\t\t\t\t\t\t\t\\\n-\t\t\t\t\t\t\t\t\t\\\n-\tfor (i_ = 2; i_ < 4; i_++)\t\t\t\t\t\\\n-\t  (CONTEXT)->ireg[i_ - 2].loc = &sc_->sc_gr[i_];\t\t\\\n-\tfor (i_ = 8; i_ < 12; i_++)\t\t\t\t\t\\\n-\t  (CONTEXT)->ireg[i_ - 2].loc = &sc_->sc_gr[i_];\t\t\\\n-\tfor (i_ = 14; i_ < 32; i_++)\t\t\t\t\t\\\n-\t  (CONTEXT)->ireg[i_ - 2].loc = &sc_->sc_gr[i_];\t\t\\\n-      }\t\t\t\t\t\t\t\t\t\\\n-\t  \t\t\t\t\t\t\t\t\\\n-      (CONTEXT)->fpsr_loc = &(sc_->sc_ar_fpsr);\t\t\t\t\\\n-      (CONTEXT)->pfs_loc = &(sc_->sc_ar_pfs);\t\t\t\t\\\n-      (CONTEXT)->lc_loc = &(sc_->sc_ar_lc);\t\t\t\t\\\n-      (CONTEXT)->unat_loc = &(sc_->sc_ar_unat);\t\t\t\t\\\n-      (CONTEXT)->br_loc[0] = &(sc_->sc_br[0]);\t\t\t\t\\\n-      (CONTEXT)->br_loc[6] = &(sc_->sc_br[6]);\t\t\t\t\\\n-      (CONTEXT)->br_loc[7] = &(sc_->sc_br[7]);\t\t\t\t\\\n-      (CONTEXT)->pr = sc_->sc_pr;\t\t\t\t\t\\\n-      (CONTEXT)->psp = sc_->sc_gr[12];\t\t\t\t\t\\\n-      (CONTEXT)->gp = sc_->sc_gr[1];\t\t\t\t\t\\\n-      /* Signal frame doesn't have an associated reg. stack frame \t\\\n-         other than what we adjust for below.\t  */\t\t\t\\\n-      (FS) -> no_reg_stack_frame = 1;\t\t\t\t\t\\\n-\t\t\t\t\t\t\t\t\t\\\n-      if (sc_->sc_rbs_base)\t\t\t\t\t\t\\\n-\t{\t\t\t\t\t\t\t\t\\\n-\t  /* Need to switch from alternate register backing store.  */\t\\\n-\t  long ndirty, loadrs = sc_->sc_loadrs >> 16;\t\t\t\\\n-\t  unsigned long alt_bspstore = (CONTEXT)->bsp - loadrs;\t\t\\\n-\t  unsigned long bspstore;\t\t\t\t\t\\\n-\t  unsigned long *ar_bsp = (unsigned long *)(sc_->sc_ar_bsp);\t\\\n-\t\t\t\t\t\t\t\t\t\\\n-\t  ndirty = ia64_rse_num_regs ((unsigned long *) alt_bspstore,\t\\\n-\t\t\t\t      (unsigned long *) (CONTEXT)->bsp);\\\n-\t  bspstore = (unsigned long)\t\t\t\t\t\\\n-\t\t     ia64_rse_skip_regs (ar_bsp, -ndirty);\t\t\\\n-\t  ia64_copy_rbs ((CONTEXT), bspstore, alt_bspstore, loadrs,\t\\\n-\t\t\t sc_->sc_ar_rnat);\t\t\t\t\\\n-\t}\t\t\t\t\t\t\t\t\\\n-\t\t\t\t\t\t\t\t\t\\\n-      /* Don't touch the branch registers o.t. b0, b6 and b7.\t\t\\\n-\t The kernel doesn't pass the preserved branch registers\t\t\\\n-\t in the sigcontext but leaves them intact, so there's no\t\\\n-\t need to do anything with them here.  */\t\t\t\\\n-      {\t\t\t\t\t\t\t\t\t\\\n-\tunsigned long sof = sc_->sc_cfm & 0x7f;\t\t\t\t\\\n-\t(CONTEXT)->bsp = (unsigned long)\t\t\t\t\\\n-\t  ia64_rse_skip_regs ((unsigned long *)(sc_->sc_ar_bsp), -sof); \\\n-      }\t\t\t\t\t\t\t\t\t\\\n-\t\t\t\t\t\t\t\t\t\\\n-      (FS)->curr.reg[UNW_REG_RP].where = UNW_WHERE_SPREL;\t\t\\\n-      (FS)->curr.reg[UNW_REG_RP].val \t\t\t\t\t\\\n-\t= (unsigned long)&(sc_->sc_ip) - (CONTEXT)->psp;\t\t\\\n-      (FS)->curr.reg[UNW_REG_RP].when = -1;\t\t\t\t\\\n-\t\t\t\t\t\t\t\t\t\\\n-      goto SUCCESS;\t\t\t\t\t\t\t\\\n-    }\n-\n-#define MD_HANDLE_UNWABI(CONTEXT, FS)\t\t\t\t\t\\\n-  if ((FS)->unwabi == ((3 << 8) | 's')\t\t\t\t\t\\\n-      || (FS)->unwabi == ((0 << 8) | 's'))\t\t\t\t\\\n-    {\t\t\t\t\t\t\t\t\t\\\n-      struct sigframe {\t\t\t\t\t\t\t\\\n-\tchar scratch[16];\t\t\t\t\t\t\\\n-\tunsigned long sig_number;\t\t\t\t\t\\\n-\tstruct siginfo *info;\t\t\t\t\t\t\\\n-\tstruct sigcontext *sc;\t\t\t\t\t\t\\\n-      } *frame_ = (struct sigframe *)(CONTEXT)->psp;\t\t\t\\\n-      struct sigcontext *sc_ = frame_->sc;\t\t\t\t\\\n-\t\t\t\t\t\t\t\t\t\\\n-      /* Restore scratch registers in case the unwinder needs to\t\\\n-\t refer to a value stored in one of them.  */\t\t\t\\\n-      {\t\t\t\t\t\t\t\t\t\\\n-\tint i_;\t\t\t\t\t\t\t\t\\\n-\t\t\t\t\t\t\t\t\t\\\n-\tfor (i_ = 2; i_ < 4; i_++)\t\t\t\t\t\\\n-\t  (CONTEXT)->ireg[i_ - 2].loc = &sc_->sc_gr[i_];\t\t\\\n-\tfor (i_ = 8; i_ < 12; i_++)\t\t\t\t\t\\\n-\t  (CONTEXT)->ireg[i_ - 2].loc = &sc_->sc_gr[i_];\t\t\\\n-\tfor (i_ = 14; i_ < 32; i_++)\t\t\t\t\t\\\n-\t  (CONTEXT)->ireg[i_ - 2].loc = &sc_->sc_gr[i_];\t\t\\\n-      }\t\t\t\t\t\t\t\t\t\\\n-\t  \t\t\t\t\t\t\t\t\\\n-      (CONTEXT)->pfs_loc = &(sc_->sc_ar_pfs);\t\t\t\t\\\n-      (CONTEXT)->lc_loc = &(sc_->sc_ar_lc);\t\t\t\t\\\n-      (CONTEXT)->unat_loc = &(sc_->sc_ar_unat);\t\t\t\t\\\n-      (CONTEXT)->br_loc[0] = &(sc_->sc_br[0]);\t\t\t\t\\\n-      (CONTEXT)->br_loc[6] = &(sc_->sc_br[6]);\t\t\t\t\\\n-      (CONTEXT)->br_loc[7] = &(sc_->sc_br[7]);\t\t\t\t\\\n-      (CONTEXT)->pr = sc_->sc_pr;\t\t\t\t\t\\\n-      (CONTEXT)->gp = sc_->sc_gr[1];\t\t\t\t\t\\\n-      /* Signal frame doesn't have an associated reg. stack frame \t\\\n-         other than what we adjust for below.\t  */\t\t\t\\\n-      (FS) -> no_reg_stack_frame = 1;\t\t\t\t\t\\\n-\t\t\t\t\t\t\t\t\t\\\n-      if (sc_->sc_rbs_base)\t\t\t\t\t\t\\\n-\t{\t\t\t\t\t\t\t\t\\\n-\t  /* Need to switch from alternate register backing store.  */\t\\\n-\t  long ndirty, loadrs = sc_->sc_loadrs >> 16;\t\t\t\\\n-\t  unsigned long alt_bspstore = (CONTEXT)->bsp - loadrs;\t\t\\\n-\t  unsigned long bspstore;\t\t\t\t\t\\\n-\t  unsigned long *ar_bsp = (unsigned long *)(sc_->sc_ar_bsp);\t\\\n-\t\t\t\t\t\t\t\t\t\\\n-\t  ndirty = ia64_rse_num_regs ((unsigned long *) alt_bspstore,\t\\\n-\t\t\t\t      (unsigned long *) (CONTEXT)->bsp);\\\n-\t  bspstore = (unsigned long)\t\t\t\t\t\\\n-\t\t     ia64_rse_skip_regs (ar_bsp, -ndirty);\t\t\\\n-\t  ia64_copy_rbs ((CONTEXT), bspstore, alt_bspstore, loadrs,\t\\\n-\t\t\t sc_->sc_ar_rnat);\t\t\t\t\\\n-\t}\t\t\t\t\t\t\t\t\\\n-\t\t\t\t\t\t\t\t\t\\\n-      /* Don't touch the branch registers o.t. b0, b6 and b7.\t\t\\\n-\t The kernel doesn't pass the preserved branch registers\t\t\\\n-\t in the sigcontext but leaves them intact, so there's no\t\\\n-\t need to do anything with them here.  */\t\t\t\\\n-      {\t\t\t\t\t\t\t\t\t\\\n-\tunsigned long sof = sc_->sc_cfm & 0x7f;\t\t\t\t\\\n-\t(CONTEXT)->bsp = (unsigned long)\t\t\t\t\\\n-\t  ia64_rse_skip_regs ((unsigned long *)(sc_->sc_ar_bsp), -sof); \\\n-      }\t\t\t\t\t\t\t\t\t\\\n-\t\t\t\t\t\t\t\t\t\\\n-      /* pfs_loc already set above.  Without this pfs_loc would point\t\\\n-\t incorrectly to sc_cfm instead of sc_ar_pfs.  */\t\t\\\n-      (FS)->curr.reg[UNW_REG_PFS].where = UNW_WHERE_NONE;\t\t\\\n-    }\n-\n-#endif /* IN_LIBGCC2 */\n-#endif /* glibc-2.3 or better */\n+#define MD_UNWIND_SUPPORT \"config/ia64/linux-unwind.h\""}, {"sha": "4a4d65aaa20046da2ad941a97d1e5ccfbdaae5a6", "filename": "gcc/config/ia64/unwind-ia64.c", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8662eb14c0ef6531d7086ec08f5e52b87c472ede/gcc%2Fconfig%2Fia64%2Funwind-ia64.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8662eb14c0ef6531d7086ec08f5e52b87c472ede/gcc%2Fconfig%2Fia64%2Funwind-ia64.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fia64%2Funwind-ia64.c?ref=8662eb14c0ef6531d7086ec08f5e52b87c472ede", "patch": "@@ -44,6 +44,7 @@\n #undef ENABLE_MALLOC_CHECKING\n \n #ifndef __USING_SJLJ_EXCEPTIONS__\n+\n #define UNW_VER(x)\t\t((x) >> 48)\n #define UNW_FLAG_MASK\t\t0x0000ffff00000000\n #define UNW_FLAG_OSMASK\t\t0x0000f00000000000\n@@ -1754,6 +1755,9 @@ _Unwind_GetBSP (struct _Unwind_Context *context)\n   return (_Unwind_Ptr) context->bsp;\n }\n \n+#ifdef MD_UNWIND_SUPPORT\n+#include MD_UNWIND_SUPPORT\n+#endif\n \f\n static _Unwind_Reason_Code\n uw_frame_state_for (struct _Unwind_Context *context, _Unwind_FrameState *fs)\n@@ -1777,7 +1781,8 @@ uw_frame_state_for (struct _Unwind_Context *context, _Unwind_FrameState *fs)\n \t os-specific fallback mechanism.  This will necessarily\n \t not provide a personality routine or LSDA.  */\n #ifdef MD_FALLBACK_FRAME_STATE_FOR\n-      MD_FALLBACK_FRAME_STATE_FOR (context, fs, success);\n+      if (MD_FALLBACK_FRAME_STATE_FOR (context, fs) == _URC_NO_REASON)\n+\treturn _URC_NO_REASON;\n \n       /* [SCRA 11.4.1] A leaf function with no memory stack, no exception\n \t handlers, and which keeps the return value in B0 does not need\n@@ -1792,15 +1797,10 @@ uw_frame_state_for (struct _Unwind_Context *context, _Unwind_FrameState *fs)\n \t  fs->curr.reg[UNW_REG_RP].where = UNW_WHERE_BR;\n \t  fs->curr.reg[UNW_REG_RP].when = -1;\n \t  fs->curr.reg[UNW_REG_RP].val = 0;\n-\t  goto success;\n+\t  return _URC_NO_REASON;\n \t}\n-\n-      return _URC_END_OF_STACK;\n-    success:\n-      return _URC_NO_REASON;\n-#else\n-      return _URC_END_OF_STACK;\n #endif\n+      return _URC_END_OF_STACK;\n     }\n \n   context->region_start = ent->start_offset + segment_base;"}, {"sha": "5c136c14109df6533e353118ead09af5b59941b8", "filename": "gcc/config/mips/linux-unwind.h", "status": "added", "additions": 93, "deletions": 0, "changes": 93, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8662eb14c0ef6531d7086ec08f5e52b87c472ede/gcc%2Fconfig%2Fmips%2Flinux-unwind.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8662eb14c0ef6531d7086ec08f5e52b87c472ede/gcc%2Fconfig%2Fmips%2Flinux-unwind.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Flinux-unwind.h?ref=8662eb14c0ef6531d7086ec08f5e52b87c472ede", "patch": "@@ -0,0 +1,93 @@\n+/* DWARF2 EH unwinding support for MIPS Linux.\n+   Copyright (C) 2004 Free Software Foundation, Inc.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GCC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING.  If not, write to\n+the Free Software Foundation, 59 Temple Place - Suite 330,\n+Boston, MA 02111-1307, USA.  */\n+\n+#ifndef inhibit_libc\n+/* Do code reading to identify a signal frame, and set the frame\n+   state data appropriately.  See unwind-dw2.c for the structs.  */\n+\n+#include <signal.h>\n+\n+/* The third parameter to the signal handler points to something with\n+ * this structure defined in asm/ucontext.h, but the name clashes with\n+ * struct ucontext from sys/ucontext.h so this private copy is used.  */\n+typedef struct _sig_ucontext {\n+    unsigned long         uc_flags;\n+    struct _sig_ucontext  *uc_link;\n+    stack_t               uc_stack;\n+    struct sigcontext uc_mcontext;\n+    sigset_t      uc_sigmask;\n+} _sig_ucontext_t;\n+\n+#define MD_FALLBACK_FRAME_STATE_FOR mips_fallback_frame_state\n+\n+static _Unwind_Reason_Code\n+mips_fallback_frame_state (struct _Unwind_Context *context,\n+\t\t\t   _Unwind_FrameState *fs)\n+{\n+  u_int32_t *pc = (u_int32_t *) context->ra;\n+  struct sigcontext *sc;\n+  _Unwind_Ptr new_cfa;\n+  int i;\n+\n+  /* 24021061 li v0, 0x1061 (rt_sigreturn)*/\n+  /* 0000000c syscall    */\n+  /*    or */\n+  /* 24021017 li v0, 0x1017 (sigreturn) */\n+  /* 0000000c syscall  */\n+  if (*(pc + 1) != 0x0000000c)\n+    return _URC_END_OF_STACK;\n+  if (*(pc + 0) == 0x24021017)\n+    {\n+      struct sigframe {\n+\tu_int32_t  trampoline[2];\n+\tstruct sigcontext sigctx;\n+      } *rt_ = context->ra;\n+      sc = &rt_->sigctx;\n+    }\n+  else if (*(pc + 0) == 0x24021061)\n+    {\n+      struct rt_sigframe {\n+\tu_int32_t  trampoline[2];\n+\tstruct siginfo info;\n+\t_sig_ucontext_t uc;\n+      } *rt_ = context->ra;\n+      sc = &rt_->uc.uc_mcontext;\n+    }\n+  else\n+    return _URC_END_OF_STACK;\n+\n+  new_cfa = (_Unwind_Ptr)sc;\n+  fs->cfa_how = CFA_REG_OFFSET;\n+  fs->cfa_reg = STACK_POINTER_REGNUM;\n+  fs->cfa_offset = new_cfa - (_Unwind_Ptr) context->cfa;\n+\n+  for (i = 0; i < 32; i++) {\n+    fs->regs.reg[i].how = REG_SAVED_OFFSET;\n+    fs->regs.reg[i].loc.offset\n+      = (_Unwind_Ptr)&(sc->sc_regs[i]) - new_cfa;\n+  }\n+  fs->regs.reg[SIGNAL_UNWIND_RETURN_COLUMN].how = REG_SAVED_OFFSET;\n+  fs->regs.reg[SIGNAL_UNWIND_RETURN_COLUMN].loc.offset\n+    = (_Unwind_Ptr)&(sc->sc_pc) - new_cfa;\n+  fs->retaddr_column = SIGNAL_UNWIND_RETURN_COLUMN;\n+\n+  return _URC_NO_REASON;\n+}\n+#endif"}, {"sha": "be5c8d4d21907bc8668c3c9ecaba8293be6e5e84", "filename": "gcc/config/mips/linux.h", "status": "modified", "additions": 1, "deletions": 71, "changes": 72, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8662eb14c0ef6531d7086ec08f5e52b87c472ede/gcc%2Fconfig%2Fmips%2Flinux.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8662eb14c0ef6531d7086ec08f5e52b87c472ede/gcc%2Fconfig%2Fmips%2Flinux.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Flinux.h?ref=8662eb14c0ef6531d7086ec08f5e52b87c472ede", "patch": "@@ -183,74 +183,4 @@ Boston, MA 02111-1307, USA.  */\n %{!shared: %{pthread:-lpthread} \\\n   %{profile:-lc_p} %{!profile: -lc}}\"\n \n-#ifndef inhibit_libc\n-/* Do code reading to identify a signal frame, and set the frame\n-   state data appropriately.  See unwind-dw2.c for the structs.  */\n-#ifdef IN_LIBGCC2\n-#include <signal.h>\n-\n-/* The third parameter to the signal handler points to something with\n- * this structure defined in asm/ucontext.h, but the name clashes with\n- * struct ucontext from sys/ucontext.h so this private copy is used.  */\n-typedef struct _sig_ucontext {\n-    unsigned long         uc_flags;\n-    struct _sig_ucontext  *uc_link;\n-    stack_t               uc_stack;\n-    struct sigcontext uc_mcontext;\n-    sigset_t      uc_sigmask;\n-} _sig_ucontext_t;\n-\n-#endif /* IN_LIBGCC2  */\n-\n-#define MD_FALLBACK_FRAME_STATE_FOR(CONTEXT, FS, SUCCESS)            \\\n-  do {                                                               \\\n-    u_int32_t *pc_ = (u_int32_t *) (CONTEXT)->ra;                \\\n-    struct sigcontext *sc_;                                          \\\n-    _Unwind_Ptr new_cfa_;                                            \\\n-    int i_;                                                          \\\n-                                                                     \\\n-    /* 24021061 li v0, 0x1061 (rt_sigreturn)*/                       \\\n-    /* 0000000c syscall    */                                        \\\n-    /*    or */                                                      \\\n-    /* 24021017 li v0, 0x1017 (sigreturn) */                         \\\n-    /* 0000000c syscall  */                                          \\\n-    if (*(pc_ + 1) != 0x0000000c)                                    \\\n-      break;                                                         \\\n-    if (*(pc_ + 0) == 0x24021017)                                    \\\n-      {                                                              \\\n-        struct sigframe {                                            \\\n-          u_int32_t  trampoline[2];                                \\\n-          struct sigcontext sigctx;                                  \\\n-        } *rt_ = (CONTEXT)->ra;                                      \\\n-        sc_ = &rt_->sigctx;                                          \\\n-      }                                                              \\\n-    else if (*(pc_ + 0) == 0x24021061)                               \\\n-      {                                                              \\\n-        struct rt_sigframe {                                         \\\n-          u_int32_t  trampoline[2];                                \\\n-          struct siginfo info;                                       \\\n-          _sig_ucontext_t uc;                                        \\\n-        } *rt_ = (CONTEXT)->ra;                                      \\\n-        sc_ = &rt_->uc.uc_mcontext;                                  \\\n-      }                                                              \\\n-    else                                                             \\\n-      break;                                                         \\\n-                                                                     \\\n-    new_cfa_ = (_Unwind_Ptr)sc_;                                     \\\n-    (FS)->cfa_how = CFA_REG_OFFSET;                                  \\\n-    (FS)->cfa_reg = STACK_POINTER_REGNUM;                            \\\n-    (FS)->cfa_offset = new_cfa_ - (_Unwind_Ptr) (CONTEXT)->cfa;      \\\n-                                                                     \\\n-    for (i_ = 0; i_ < 32; i_++) {                                    \\\n-      (FS)->regs.reg[i_].how = REG_SAVED_OFFSET;                     \\\n-      (FS)->regs.reg[i_].loc.offset                                  \\\n-        = (_Unwind_Ptr)&(sc_->sc_regs[i_]) - new_cfa_;               \\\n-    }                                                                \\\n-    (FS)->regs.reg[SIGNAL_UNWIND_RETURN_COLUMN].how = REG_SAVED_OFFSET; \\\n-    (FS)->regs.reg[SIGNAL_UNWIND_RETURN_COLUMN].loc.offset           \\\n-        = (_Unwind_Ptr)&(sc_->sc_pc) - new_cfa_;                     \\\n-    (FS)->retaddr_column = SIGNAL_UNWIND_RETURN_COLUMN;              \\\n-                                                                     \\\n-    goto SUCCESS;                                                    \\\n-  } while (0)\n-#endif\n+#define MD_UNWIND_SUPPORT \"config/mips/linux-unwind.h\""}, {"sha": "41ec61caa9e63aa50e5a0c51dbbcb02b8fee2f44", "filename": "gcc/config/pa/linux-unwind.h", "status": "added", "additions": 115, "deletions": 0, "changes": 115, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8662eb14c0ef6531d7086ec08f5e52b87c472ede/gcc%2Fconfig%2Fpa%2Flinux-unwind.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8662eb14c0ef6531d7086ec08f5e52b87c472ede/gcc%2Fconfig%2Fpa%2Flinux-unwind.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpa%2Flinux-unwind.h?ref=8662eb14c0ef6531d7086ec08f5e52b87c472ede", "patch": "@@ -0,0 +1,115 @@\n+/* DWARF2 EH unwinding support for PA Linux.\n+   Copyright (C) 2004 Free Software Foundation, Inc.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GCC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING.  If not, write to\n+the Free Software Foundation, 59 Temple Place - Suite 330,\n+Boston, MA 02111-1307, USA.  */\n+\n+/* Do code reading to identify a signal frame, and set the frame\n+   state data appropriately.  See unwind-dw2.c for the structs.  */\n+\n+#include <signal.h>\n+#include <sys/ucontext.h>\n+\n+/* Unfortunately, because of various bugs and changes to the kernel,\n+   we have several cases to deal with.\n+\n+   In 2.4, the signal trampoline is 4 words, and (CONTEXT)->ra should\n+   point directly at the beginning of the trampoline and struct rt_sigframe.\n+\n+   In <= 2.6.5-rc2-pa3, the signal trampoline is 9 words, and \n+   (CONTEXT)->ra points at the 4th word in the trampoline structure.  This \n+   is wrong, it should point at the 5th word.  This is fixed in 2.6.5-rc2-pa4.\n+\n+   To detect these cases, we first take (CONTEXT)->ra, align it to 64-bytes\n+   to get the beginning of the signal frame, and then check offsets 0, 4\n+   and 5 to see if we found the beginning of the trampoline.  This will\n+   tell us how to locate the sigcontext structure.\n+\n+   Note that with a 2.4 64-bit kernel, the signal context is not properly\n+   passed back to userspace so the unwind will not work correctly.  */\n+\n+#define MD_FALLBACK_FRAME_STATE_FOR pa32_fallback_frame_state\n+\n+static _Unwind_Reason_Code\n+pa32_fallback_frame_state (struct _Unwind_Context *context,\n+\t\t\t   _Unwind_FrameState *fs)\n+{\n+  unsigned long sp = (unsigned long)context->ra & ~63;\n+  unsigned int *pc = (unsigned int *)sp;\n+  unsigned long off;\n+  _Unwind_Ptr new_cfa;\n+  int i;\n+  struct sigcontext *sc;\n+  struct rt_sigframe {\n+    struct siginfo info;\n+    struct ucontext uc;\n+  } *frame;\n+\n+  /* rt_sigreturn trampoline:\n+     3419000x ldi 0, %r25 or ldi 1, %r25   (x = 0 or 2)\n+     3414015a ldi __NR_rt_sigreturn, %r20\n+     e4008200 be,l 0x100(%sr2, %r0), %sr0, %r31\n+     08000240 nop  */\n+\n+  if (pc[0] == 0x34190000 || pc[0] == 0x34190002)\n+    off = 4*4;\n+  else if (pc[4] == 0x34190000 || pc[4] == 0x34190002)\n+    {\n+      pc += 4;\n+      off = 10 * 4;\n+    }\n+  else if (pc[5] == 0x34190000 || pc[5] == 0x34190002)\n+    {\n+      pc += 5;\n+      off = 10 * 4;\n+    }\n+  else\n+    return _URC_END_OF_STACK;\n+  if (pc[1] != 0x3414015a\n+      || pc[2] != 0xe4008200\n+      || pc[3] != 0x08000240)\n+    return _URC_END_OF_STACK;\n+\n+  frame = (struct rt_sigframe *)(sp + off);\n+  sc = &frame->uc.uc_mcontext;\n+\n+  new_cfa = sc->sc_gr[30];\n+  fs->cfa_how = CFA_REG_OFFSET;\n+  fs->cfa_reg = 30;\n+  fs->cfa_offset = new_cfa - (long) context->cfa;\n+  for (i = 1; i <= 31; i++)\n+    {\n+      fs->regs.reg[i].how = REG_SAVED_OFFSET;\n+      fs->regs.reg[i].loc.offset = (long)&sc->sc_gr[i] - new_cfa;\n+    }\n+  for (i = 4; i <= 31; i++)\n+    {\n+      /* FP regs have left and right halves */\n+      fs->regs.reg[2*i+24].how = REG_SAVED_OFFSET;\n+      fs->regs.reg[2*i+24].loc.offset\n+\t= (long)&sc->sc_fr[i] - new_cfa;\n+      fs->regs.reg[2*i+24+1].how = REG_SAVED_OFFSET;\n+      fs->regs.reg[2*i+24+1].loc.offset\n+\t= (long)&sc->sc_fr[i] + 4 - new_cfa;\n+    }\n+  fs->regs.reg[88].how = REG_SAVED_OFFSET;\n+  fs->regs.reg[88].loc.offset = (long) &sc->sc_sar - new_cfa;\n+  fs->regs.reg[2].how = REG_SAVED_OFFSET;\n+  fs->regs.reg[2].loc.offset = (long) &sc->sc_iaoq[0] - new_cfa;\n+  fs->retaddr_column = 2;\n+  return _URC_NO_REASON;\n+}"}, {"sha": "07b680de88acc2d25116b12d63c50f2bfea9f04d", "filename": "gcc/config/pa/pa32-linux.h", "status": "modified", "additions": 1, "deletions": 93, "changes": 94, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8662eb14c0ef6531d7086ec08f5e52b87c472ede/gcc%2Fconfig%2Fpa%2Fpa32-linux.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8662eb14c0ef6531d7086ec08f5e52b87c472ede/gcc%2Fconfig%2Fpa%2Fpa32-linux.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpa%2Fpa32-linux.h?ref=8662eb14c0ef6531d7086ec08f5e52b87c472ede", "patch": "@@ -36,96 +36,4 @@ Boston, MA 02111-1307, USA.  */\n \t\t    aligned(sizeof(func_ptr))))\t\t\t\t\\\n     = { (func_ptr) (-1) }\n \n-/* Do code reading to identify a signal frame, and set the frame\n-   state data appropriately.  See unwind-dw2.c for the structs.  */\n-\n-#ifdef IN_LIBGCC2\n-#include <signal.h>\n-#include <sys/ucontext.h>\n-\n-/* Unfortunately, because of various bugs and changes to the kernel,\n-   we have several cases to deal with.\n-\n-   In 2.4, the signal trampoline is 4 words, and (CONTEXT)->ra should\n-   point directly at the beginning of the trampoline and struct rt_sigframe.\n-\n-   In <= 2.6.5-rc2-pa3, the signal trampoline is 9 words, and \n-   (CONTEXT)->ra points at the 4th word in the trampoline structure.  This \n-   is wrong, it should point at the 5th word.  This is fixed in 2.6.5-rc2-pa4.\n-\n-   To detect these cases, we first take (CONTEXT)->ra, align it to 64-bytes\n-   to get the beginning of the signal frame, and then check offsets 0, 4\n-   and 5 to see if we found the beginning of the trampoline.  This will\n-   tell us how to locate the sigcontext structure.\n-\n-   Note that with a 2.4 64-bit kernel, the signal context is not properly\n-   passed back to userspace so the unwind will not work correctly.  */\n-#define MD_FALLBACK_FRAME_STATE_FOR(CONTEXT, FS, SUCCESS)\t\t\\\n-  do {\t\t\t\t\t\t\t\t\t\\\n-    unsigned long sp = (unsigned long)(CONTEXT)->ra & ~63;\t\t\\\n-    unsigned int *pc = (unsigned int *)sp;\t\t\t\t\\\n-    unsigned long off;\t\t\t\t\t\t\t\\\n-    _Unwind_Ptr new_cfa;\t\t\t\t\t\t\\\n-    int i;\t\t\t\t\t\t\t\t\\\n-    struct sigcontext *sc;\t\t\t\t\t\t\\\n-    struct rt_sigframe {\t\t\t\t\t\t\\\n-      struct siginfo info;\t\t\t\t\t\t\\\n-      struct ucontext uc;\t\t\t\t\t\t\\\n-    } *frame;\t\t\t\t\t\t\t\t\\\n-\t\t\t\t\t\t\t\t\t\\\n-    /* rt_sigreturn trampoline: \t\t\t\t\t\\\n-       3419000x ldi 0, %r25 or ldi 1, %r25   (x = 0 or 2)  \t\t\\\n-       3414015a ldi __NR_rt_sigreturn, %r20 \t\t\t\t\\\n-       e4008200 be,l 0x100(%sr2, %r0), %sr0, %r31 \t\t\t\\\n-       08000240 nop  */\t\t\t\t\t\t\t\\\n-    \t\t\t\t\t\t\t\t\t\\\n-    if (pc[0] == 0x34190000 || pc[0] == 0x34190002)\t\t\t\\\n-      off = 4*4;\t\t\t\t\t\t\t\\\n-    else if (pc[4] == 0x34190000 || pc[4] == 0x34190002)\t\t\\\n-      {\t\t\t\t\t\t\t\t\t\\\n-\tpc += 4;\t\t\t\t\t\t\t\\\n-\toff = 10 * 4;\t\t\t\t\t\t\t\\\n-      }\t\t\t\t\t\t\t\t\t\\\n-    else if (pc[5] == 0x34190000 || pc[5] == 0x34190002)\t\t\\\n-      {\t\t\t\t\t\t\t\t\t\\\n-\tpc += 5;\t\t\t\t\t\t\t\\\n-\toff = 10 * 4;\t\t\t\t\t\t\t\\\n-      }\t\t\t\t\t\t\t\t\t\\\n-    else\t\t\t\t\t\t\t\t\\\n-      break;\t\t\t\t\t\t\t\t\\\n-    if (pc[1] != 0x3414015a \t\t\t\t\t\t\\\n-\t|| pc[2] != 0xe4008200 \t\t\t\t\t\t\\\n-\t|| pc[3] != 0x08000240)\t\t\t\t\t\t\\\n-      break;\t\t\t\t\t\t\t\t\\\n-\t\t\t\t\t\t\t\t\t\\\n-    frame = (struct rt_sigframe *)(sp + off);\t\t\t\t\\\n-    sc = &frame->uc.uc_mcontext;\t\t\t\t\t\\\n-\t\t\t\t\t\t\t\t\t\\\n-    new_cfa = sc->sc_gr[30];\t\t\t\t\t\t\\\n-    (FS)->cfa_how = CFA_REG_OFFSET;\t\t\t\t\t\\\n-    (FS)->cfa_reg = 30;\t\t\t\t\t\t\t\\\n-    (FS)->cfa_offset = new_cfa - (long) (CONTEXT)->cfa;\t\t\t\\\n-    for (i = 1; i <= 31; i++)\t\t\t\t\t\t\\\n-      {\t\t\t\t\t\t\t\t\t\\\n-\t(FS)->regs.reg[i].how = REG_SAVED_OFFSET;\t\t\t\\\n-\t(FS)->regs.reg[i].loc.offset = (long)&sc->sc_gr[i] - new_cfa;\t\\\n-      }\t\t\t\t\t\t\t\t\t\\\n-    for (i = 4; i <= 31; i++)\t\t\t\t\t\t\\\n-      {\t\t\t\t\t\t\t\t\t\\\n-\t/* FP regs have left and right halves */\t\t\t\\\n-\t(FS)->regs.reg[2*i+24].how = REG_SAVED_OFFSET;\t\t\t\\\n-\t(FS)->regs.reg[2*i+24].loc.offset\t\t\t\t\\\n-\t  = (long)&sc->sc_fr[i] - new_cfa;\t\t\t\t\\\n-\t(FS)->regs.reg[2*i+24+1].how = REG_SAVED_OFFSET;\t\t\\\n-\t(FS)->regs.reg[2*i+24+1].loc.offset\t\t\t\t\\\n-\t  = (long)&sc->sc_fr[i] + 4 - new_cfa;\t\t\t\t\\\n-      }\t\t\t\t\t\t\t\t\t\\\n-    (FS)->regs.reg[88].how = REG_SAVED_OFFSET;\t\t\t\t\\\n-    (FS)->regs.reg[88].loc.offset = (long) &sc->sc_sar - new_cfa;\t\\\n-    (FS)->regs.reg[2].how = REG_SAVED_OFFSET;\t\t\t\t\\\n-    (FS)->regs.reg[2].loc.offset = (long) &sc->sc_iaoq[0] - new_cfa;\t\\\n-    (FS)->retaddr_column = 2;\t\t\t\t\t\t\\\n-    goto SUCCESS;\t\t\t\t\t\t\t\\\n-  } while (0)\n-\n-#endif /* IN_LIBGCC2 */\n+#define MD_UNWIND_SUPPORT \"config/pa/linux-unwind.h\""}, {"sha": "e3d03262d5a759b4c43a6a37786080ee05e807fc", "filename": "gcc/config/rs6000/darwin-unwind.h", "status": "added", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8662eb14c0ef6531d7086ec08f5e52b87c472ede/gcc%2Fconfig%2Frs6000%2Fdarwin-unwind.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8662eb14c0ef6531d7086ec08f5e52b87c472ede/gcc%2Fconfig%2Frs6000%2Fdarwin-unwind.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Fdarwin-unwind.h?ref=8662eb14c0ef6531d7086ec08f5e52b87c472ede", "patch": "@@ -0,0 +1,35 @@\n+/* DWARF2 EH unwinding support for Darwin.\n+   Copyright (C) 2004 Free Software Foundation, Inc.\n+\n+   This file is part of GCC.\n+\n+   GCC is free software; you can redistribute it and/or modify it\n+   under the terms of the GNU General Public License as published by\n+   the Free Software Foundation; either version 2, or (at your option)\n+   any later version.\n+\n+   In addition to the permissions in the GNU General Public License, the\n+   Free Software Foundation gives you unlimited permission to link the\n+   compiled version of this file into combinations with other programs,\n+   and to distribute those combinations without any restriction coming\n+   from the use of this file.  (The General Public License restrictions\n+   do apply in other respects; for example, they cover modification of\n+   the file, and distribution when not linked into a combined\n+   executable.)\n+\n+   GCC is distributed in the hope that it will be useful, but WITHOUT\n+   ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n+   or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public\n+   License for more details.\n+\n+   You should have received a copy of the GNU General Public License\n+   along with GCC; see the file COPYING.  If not, write to the Free\n+   Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n+   02111-1307, USA.  */\n+\n+extern bool _Unwind_fallback_frame_state_for\n+  (struct _Unwind_Context *context, _Unwind_FrameState *fs);\n+\n+#define MD_FALLBACK_FRAME_STATE_FOR(CONTEXT, FS)\t\\\n+  (_Unwind_fallback_frame_state_for (CONTEXT, FS)\t\\\n+   ? _URC_NO_REASON : _URC_END_OF_STACK)"}, {"sha": "44ae79ac38c62c743ad75ec4eab6df34a574a180", "filename": "gcc/config/rs6000/darwin.h", "status": "modified", "additions": 1, "deletions": 8, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8662eb14c0ef6531d7086ec08f5e52b87c472ede/gcc%2Fconfig%2Frs6000%2Fdarwin.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8662eb14c0ef6531d7086ec08f5e52b87c472ede/gcc%2Fconfig%2Frs6000%2Fdarwin.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Fdarwin.h?ref=8662eb14c0ef6531d7086ec08f5e52b87c472ede", "patch": "@@ -371,14 +371,7 @@ extern const char *darwin_one_byte_bool;\n #include <stdbool.h>\n #endif\n \n-#define MD_FALLBACK_FRAME_STATE_FOR(CONTEXT, FS, SUCCESS)\t\t\\\n-  {\t\t\t\t\t\t\t\t\t\\\n-    extern bool _Unwind_fallback_frame_state_for\t\t\t\\\n-      (struct _Unwind_Context *context, _Unwind_FrameState *fs);\t\\\n-\t\t\t\t\t\t\t\t\t\\\n-    if (_Unwind_fallback_frame_state_for (CONTEXT, FS))\t\t\t\\\n-      goto SUCCESS;\t\t\t\t\t\t\t\\\n-  }\n+#define MD_UNWIND_SUPPORT \"config/rs6000/darwin-unwind.h\"\n \n #define HAS_MD_FALLBACK_FRAME_STATE_FOR 1\n "}, {"sha": "bb4f0cf90dbf0f7857c08bcb8fa4eebab148fa66", "filename": "gcc/config/rs6000/linux-unwind.h", "status": "added", "additions": 186, "deletions": 0, "changes": 186, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8662eb14c0ef6531d7086ec08f5e52b87c472ede/gcc%2Fconfig%2Frs6000%2Flinux-unwind.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8662eb14c0ef6531d7086ec08f5e52b87c472ede/gcc%2Fconfig%2Frs6000%2Flinux-unwind.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Flinux-unwind.h?ref=8662eb14c0ef6531d7086ec08f5e52b87c472ede", "patch": "@@ -0,0 +1,186 @@\n+/* DWARF2 EH unwinding support for PowerPC and PowerPC64 Linux.\n+   Copyright (C) 2004 Free Software Foundation, Inc.\n+\n+   This file is part of GCC.\n+\n+   GCC is free software; you can redistribute it and/or modify it\n+   under the terms of the GNU General Public License as published\n+   by the Free Software Foundation; either version 2, or (at your\n+   option) any later version.\n+\n+   GCC is distributed in the hope that it will be useful, but WITHOUT\n+   ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n+   or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public\n+   License for more details.\n+\n+   You should have received a copy of the GNU General Public License\n+   along with GCC; see the file COPYING.  If not, write to the\n+   Free Software Foundation, 59 Temple Place - Suite 330, Boston,\n+   MA 02111-1307, USA.  */\n+\n+/* This file defines our own versions of various kernel and user\n+   structs, so that system headers are not needed, which otherwise\n+   can make bootstrapping a new toolchain difficult.  Do not use\n+   these structs elsewhere;  Many fields are missing, particularly\n+   from the end of the structures.  */\n+\n+struct gcc_pt_regs\n+{\n+  unsigned long gpr[32];\n+  unsigned long nip;\n+  unsigned long msr;\n+  unsigned long orig_gpr3;\n+  unsigned long ctr;\n+  unsigned long link;\n+};\n+\n+struct gcc_sigcontext\n+{\n+  unsigned long\tpad[7];\n+  struct gcc_pt_regs *regs;\n+};\n+\n+struct gcc_ucontext\n+{\n+#ifdef __powerpc64__\n+  unsigned long pad[21];\n+#else\n+  unsigned long pad[5];\n+#endif\n+  struct gcc_sigcontext uc_mcontext;\n+};\n+\n+#ifdef __powerpc64__\n+\n+enum { SIGNAL_FRAMESIZE = 128 };\n+\n+/* If the current unwind info (FS) does not contain explicit info\n+   saving R2, then we have to do a minor amount of code reading to\n+   figure out if it was saved.  The big problem here is that the\n+   code that does the save/restore is generated by the linker, so\n+   we have no good way to determine at compile time what to do.  */\n+\n+#define MD_FROB_UPDATE_CONTEXT frob_update_context\n+\n+static void\n+frob_update_context (struct _Unwind_Context *context, _Unwind_FrameState *fs)\n+{\n+  if (fs->regs.reg[2].how == REG_UNSAVED)\n+    {\n+      unsigned int *insn\n+\t= (unsigned int *) _Unwind_GetGR (context, LINK_REGISTER_REGNUM);\n+      if (*insn == 0xE8410028)\n+\t_Unwind_SetGRPtr (context, 2, context->cfa + 40);\n+    }\n+}\n+\n+/* If PC is at a sigreturn trampoline, return a pointer to the\n+   sigcontext.  Otherwise return NULL.  */\n+\n+static struct gcc_sigcontext *\n+get_sigcontext (struct _Unwind_Context *context)\n+{\n+  const unsigned char *pc = context->ra;\n+\n+  /* addi r1, r1, 128; li r0, 0x0077; sc  (sigreturn) */\n+  /* addi r1, r1, 128; li r0, 0x00AC; sc  (rt_sigreturn) */\n+  if (*(unsigned int *) (pc+0) != 0x38210000 + SIGNAL_FRAMESIZE\n+      || *(unsigned int *) (pc+8) != 0x44000002)\n+    return NULL;\n+  if (*(unsigned int *) (pc+4) == 0x38000077)\n+    {\n+      struct sigframe {\n+\tchar gap[SIGNAL_FRAMESIZE];\n+\tstruct gcc_sigcontext sigctx;\n+      } *rt_ = context->cfa;\n+      return &rt_->sigctx;\n+    }\n+  else if (*(unsigned int *) (pc+4) == 0x380000AC)\n+    {\n+      struct rt_sigframe {\n+\tint tramp[6];\n+\tvoid *pinfo;\n+\tstruct gcc_ucontext *puc;\n+      } *rt_ = (struct rt_sigframe *) pc;\n+      return &rt_->puc->uc_mcontext;\n+    }\n+  return NULL;\n+}\n+\n+#else  /* !__powerpc64__ */\n+\n+enum { SIGNAL_FRAMESIZE = 64 };\n+\n+static struct gcc_sigcontext *\n+get_sigcontext (struct _Unwind_Context *context)\n+{\n+  const unsigned char *pc = context->ra;\n+\n+  /* li r0, 0x7777; sc  (sigreturn old)  */\n+  /* li r0, 0x0077; sc  (sigreturn new)  */\n+  /* li r0, 0x6666; sc  (rt_sigreturn old)  */\n+  /* li r0, 0x00AC; sc  (rt_sigreturn new)  */\n+  if (*(unsigned int *) (pc+4) != 0x44000002)\n+    return NULL;\n+  if (*(unsigned int *) (pc+0) == 0x38007777\n+      || *(unsigned int *) (pc+0) == 0x38000077)\n+    {\n+      struct sigframe {\n+\tchar gap[SIGNAL_FRAMESIZE];\n+\tstruct gcc_sigcontext sigctx;\n+      } *rt_ = context->cfa;\n+      return &rt_->sigctx;\n+    }\n+  else if (*(unsigned int *) (pc+0) == 0x38006666\n+\t   || *(unsigned int *) (pc+0) == 0x380000AC)\n+    {\n+      struct rt_sigframe {\n+\tchar gap[SIGNAL_FRAMESIZE + 16];\n+\tchar siginfo[128];\n+\tstruct gcc_ucontext uc;\n+      } *rt_ = context->cfa;\n+      return &rt_->uc.uc_mcontext;\n+    }\n+  return NULL;\n+}\n+#endif\n+\n+/* Do code reading to identify a signal frame, and set the frame\n+   state data appropriately.  See unwind-dw2.c for the structs.  */\n+\n+#define MD_FALLBACK_FRAME_STATE_FOR ppc_fallback_frame_state\n+\n+static _Unwind_Reason_Code\n+ppc_fallback_frame_state (struct _Unwind_Context *context,\n+\t\t\t  _Unwind_FrameState *fs)\n+{\n+  struct gcc_sigcontext *sc = get_sigcontext (context);\n+  long new_cfa;\n+  int i;\n+\n+  if (sc == NULL)\n+    return _URC_END_OF_STACK;\n+\n+  new_cfa = sc->regs->gpr[STACK_POINTER_REGNUM];\n+  fs->cfa_how = CFA_REG_OFFSET;\n+  fs->cfa_reg = STACK_POINTER_REGNUM;\n+  fs->cfa_offset = new_cfa - (long) context->cfa;\n+\n+  for (i = 0; i < 32; i++)\n+    if (i != STACK_POINTER_REGNUM)\n+      {\n+\tfs->regs.reg[i].how = REG_SAVED_OFFSET;\n+\tfs->regs.reg[i].loc.offset\n+\t  = (long)&(sc->regs->gpr[i]) - new_cfa;\n+      }\n+\n+  fs->regs.reg[LINK_REGISTER_REGNUM].how = REG_SAVED_OFFSET;\n+  fs->regs.reg[LINK_REGISTER_REGNUM].loc.offset\n+    = (long)&(sc->regs->link) - new_cfa;\n+\n+  fs->regs.reg[ARG_POINTER_REGNUM].how = REG_SAVED_OFFSET;\n+  fs->regs.reg[ARG_POINTER_REGNUM].loc.offset\n+    = (long)&(sc->regs->nip) - new_cfa;\n+  fs->retaddr_column = ARG_POINTER_REGNUM;\n+  return _URC_NO_REASON;\n+}"}, {"sha": "0f4d046e0496f55f2ac2c51fd4d75cbab92502f0", "filename": "gcc/config/rs6000/linux.h", "status": "modified", "additions": 1, "deletions": 83, "changes": 84, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8662eb14c0ef6531d7086ec08f5e52b87c472ede/gcc%2Fconfig%2Frs6000%2Flinux.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8662eb14c0ef6531d7086ec08f5e52b87c472ede/gcc%2Fconfig%2Frs6000%2Flinux.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Flinux.h?ref=8662eb14c0ef6531d7086ec08f5e52b87c472ede", "patch": "@@ -98,88 +98,6 @@\n \n #define TARGET_HAS_F_SETLKW\n \n-/* Do code reading to identify a signal frame, and set the frame\n-   state data appropriately.  See unwind-dw2.c for the structs.  */\n-\n-#ifdef IN_LIBGCC2\n-#include <signal.h>\n-\n-/* During the 2.5 kernel series the kernel ucontext was changed, but\n-   the new layout is compatible with the old one, so we just define\n-   and use the old one here for simplicity and compatibility.  */\n-\n-struct kernel_old_ucontext {\n-  unsigned long     uc_flags;\n-  struct ucontext  *uc_link;\n-  stack_t           uc_stack;\n-  struct sigcontext_struct uc_mcontext;\n-  sigset_t          uc_sigmask;\n-};\n-\n-enum { SIGNAL_FRAMESIZE = 64 };\n-#endif\n-\n-#define MD_FALLBACK_FRAME_STATE_FOR(CONTEXT, FS, SUCCESS)\t\t\\\n-  do {\t\t\t\t\t\t\t\t\t\\\n-    unsigned char *pc_ = (CONTEXT)->ra;\t\t\t\t\t\\\n-    struct sigcontext *sc_;\t\t\t\t\t\t\\\n-    long new_cfa_;\t\t\t\t\t\t\t\\\n-    int i_;\t\t\t\t\t\t\t\t\\\n-\t\t\t\t\t\t\t\t\t\\\n-    /* li r0, 0x7777; sc  (sigreturn old)  */\t\t\t\t\\\n-    /* li r0, 0x0077; sc  (sigreturn new)  */\t\t\t\t\\\n-    /* li r0, 0x6666; sc  (rt_sigreturn old)  */\t\t\t\\\n-    /* li r0, 0x00AC; sc  (rt_sigreturn new)  */\t\t\t\\\n-    if (*(unsigned int *) (pc_+4) != 0x44000002)\t\t\t\\\n-      break;\t\t\t\t\t\t\t\t\\\n-    if (*(unsigned int *) (pc_+0) == 0x38007777\t\t\t\t\\\n-\t|| *(unsigned int *) (pc_+0) == 0x38000077)\t\t\t\\\n-      {\t\t\t\t\t\t\t\t\t\\\n-\tstruct sigframe {\t\t\t\t\t\t\\\n-\t  char gap[SIGNAL_FRAMESIZE];\t\t\t\t\t\\\n-\t  struct sigcontext sigctx;\t\t\t\t\t\\\n-\t} *rt_ = (CONTEXT)->cfa;\t\t\t\t\t\\\n-\tsc_ = &rt_->sigctx;\t\t\t\t\t\t\\\n-      }\t\t\t\t\t\t\t\t\t\\\n-    else if (*(unsigned int *) (pc_+0) == 0x38006666\t\t\t\\\n-\t     || *(unsigned int *) (pc_+0) == 0x380000AC)\t\t\\\n-      {\t\t\t\t\t\t\t\t\t\\\n-\tstruct rt_sigframe {\t\t\t\t\t\t\\\n-\t  char gap[SIGNAL_FRAMESIZE];\t\t\t\t\t\\\n-\t  unsigned long _unused[2];\t\t\t\t\t\\\n-\t  struct siginfo *pinfo;\t\t\t\t\t\\\n-\t  void *puc;\t\t\t\t\t\t\t\\\n-\t  struct siginfo info;\t\t\t\t\t\t\\\n-\t  struct kernel_old_ucontext uc;\t\t\t\t\\\n-\t} *rt_ = (CONTEXT)->cfa;\t\t\t\t\t\\\n-\tsc_ = &rt_->uc.uc_mcontext;\t\t\t\t\t\\\n-      }\t\t\t\t\t\t\t\t\t\\\n-    else\t\t\t\t\t\t\t\t\\\n-      break;\t\t\t\t\t\t\t\t\\\n-    \t\t\t\t\t\t\t\t\t\\\n-    new_cfa_ = sc_->regs->gpr[STACK_POINTER_REGNUM];\t\t\t\\\n-    (FS)->cfa_how = CFA_REG_OFFSET;\t\t\t\t\t\\\n-    (FS)->cfa_reg = STACK_POINTER_REGNUM;\t\t\t\t\\\n-    (FS)->cfa_offset = new_cfa_ - (long) (CONTEXT)->cfa;\t\t\\\n-    \t\t\t\t\t\t\t\t\t\\\n-    for (i_ = 0; i_ < 32; i_++)\t\t\t\t\t\t\\\n-      if (i_ != STACK_POINTER_REGNUM)\t\t\t\t\t\\\n-\t{\t    \t\t\t\t\t\t\t\\\n-\t  (FS)->regs.reg[i_].how = REG_SAVED_OFFSET;\t\t\t\\\n-\t  (FS)->regs.reg[i_].loc.offset \t\t\t\t\\\n-\t    = (long)&(sc_->regs->gpr[i_]) - new_cfa_;\t\t\t\\\n-\t}\t\t\t\t\t\t\t\t\\\n-\t\t\t\t\t\t\t\t\t\\\n-    (FS)->regs.reg[LINK_REGISTER_REGNUM].how = REG_SAVED_OFFSET;\t\\\n-    (FS)->regs.reg[LINK_REGISTER_REGNUM].loc.offset \t\t\t\\\n-      = (long)&(sc_->regs->link) - new_cfa_;\t\t\t\t\\\n-\t\t\t\t\t\t\t\t\t\\\n-    (FS)->regs.reg[CR0_REGNO].how = REG_SAVED_OFFSET;\t\t\t\\\n-    (FS)->regs.reg[CR0_REGNO].loc.offset \t\t\t\t\\\n-      = (long)&(sc_->regs->nip) - new_cfa_;\t\t\t\t\\\n-    (FS)->retaddr_column = CR0_REGNO;\t\t\t\t\t\\\n-    goto SUCCESS;\t\t\t\t\t\t\t\\\n-  } while (0)\n-\n+#define MD_UNWIND_SUPPORT \"config/rs6000/linux-unwind.h\"\n \n #define OS_MISSING_POWERPC64 1"}, {"sha": "410f31ee49bb5668fdc0f1c24bc083c7c11c9f2a", "filename": "gcc/config/rs6000/linux64.h", "status": "modified", "additions": 1, "deletions": 180, "changes": 181, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8662eb14c0ef6531d7086ec08f5e52b87c472ede/gcc%2Fconfig%2Frs6000%2Flinux64.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8662eb14c0ef6531d7086ec08f5e52b87c472ede/gcc%2Fconfig%2Frs6000%2Flinux64.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Flinux64.h?ref=8662eb14c0ef6531d7086ec08f5e52b87c472ede", "patch": "@@ -557,185 +557,6 @@ while (0)\n #define USE_LD_AS_NEEDED 1\n #endif\n \n-#ifdef IN_LIBGCC2\n-\n-/* This file defines our own versions of various kernel and user\n-   structs, so that system headers are not needed, which otherwise\n-   can make bootstrapping a new toolchain difficult.  Do not use\n-   these structs elsewhere;  Many fields are missing, particularly\n-   from the end of the structures.  */\n-\n-struct gcc_pt_regs\n-{\n-  unsigned long gpr[32];\n-  unsigned long nip;\n-  unsigned long msr;\n-  unsigned long orig_gpr3;\n-  unsigned long ctr;\n-  unsigned long link;\n-};\n-\n-struct gcc_sigcontext\n-{\n-  unsigned long\tpad[7];\n-  struct gcc_pt_regs *regs;\n-};\n-\n-struct gcc_ucontext\n-{\n-#ifdef __powerpc64__\n-  unsigned long pad[21];\n-#else\n-  unsigned long pad[5];\n-#endif\n-  struct gcc_sigcontext uc_mcontext;\n-};\n-\n-#ifdef __powerpc64__\n-\n-enum { SIGNAL_FRAMESIZE = 128 };\n-\n-/* If the current unwind info (FS) does not contain explicit info\n-   saving R2, then we have to do a minor amount of code reading to\n-   figure out if it was saved.  The big problem here is that the\n-   code that does the save/restore is generated by the linker, so\n-   we have no good way to determine at compile time what to do.  */\n-\n-#define MD_FROB_UPDATE_CONTEXT(CTX, FS)\t\t\t\t\t\\\n-  do {\t\t\t\t\t\t\t\t\t\\\n-    if ((FS)->regs.reg[2].how == REG_UNSAVED)\t\t\t\t\\\n-      {\t\t\t\t\t\t\t\t\t\\\n-\tunsigned int *insn\t\t\t\t\t\t\\\n-\t  = (unsigned int *)\t\t\t\t\t\t\\\n-\t    _Unwind_GetGR ((CTX), LINK_REGISTER_REGNUM);\t\t\\\n-\tif (*insn == 0xE8410028)\t\t\t\t\t\\\n-\t  _Unwind_SetGRPtr ((CTX), 2, (CTX)->cfa + 40);\t\t\t\\\n-      }\t\t\t\t\t\t\t\t\t\\\n-  } while (0)\n-\n-/* Do code reading to identify a signal frame, and set the frame\n-   state data appropriately.  See unwind-dw2.c for the structs.  */\n-\n-#define MD_FALLBACK_FRAME_STATE_FOR(CONTEXT, FS, SUCCESS)\t\t\\\n-  do {\t\t\t\t\t\t\t\t\t\\\n-    unsigned char *pc_ = (CONTEXT)->ra;\t\t\t\t\t\\\n-    struct gcc_sigcontext *sc_;\t\t\t\t\t\t\\\n-    long new_cfa_;\t\t\t\t\t\t\t\\\n-    int i_;\t\t\t\t\t\t\t\t\\\n-\t\t\t\t\t\t\t\t\t\\\n-    /* addi r1, r1, 128; li r0, 0x0077; sc  (sigreturn) */\t\t\\\n-    /* addi r1, r1, 128; li r0, 0x00AC; sc  (rt_sigreturn) */\t\t\\\n-    if (*(unsigned int *) (pc_+0) != 0x38210000 + SIGNAL_FRAMESIZE\t\\\n-\t|| *(unsigned int *) (pc_+8) != 0x44000002)\t\t\t\\\n-      break;\t\t\t\t\t\t\t\t\\\n-    if (*(unsigned int *) (pc_+4) == 0x38000077)\t\t\t\\\n-      {\t\t\t\t\t\t\t\t\t\\\n-\tstruct sigframe {\t\t\t\t\t\t\\\n-\t  char gap[SIGNAL_FRAMESIZE];\t\t\t\t\t\\\n-\t  struct gcc_sigcontext sigctx;\t\t\t\t\t\\\n-\t} *rt_ = (CONTEXT)->cfa;\t\t\t\t\t\\\n-\tsc_ = &rt_->sigctx;\t\t\t\t\t\t\\\n-      }\t\t\t\t\t\t\t\t\t\\\n-    else if (*(unsigned int *) (pc_+4) == 0x380000AC)\t\t\t\\\n-      {\t\t\t\t\t\t\t\t\t\\\n-\tstruct rt_sigframe {\t\t\t\t\t\t\\\n-\t  int tramp[6];\t\t\t\t\t\t\t\\\n-\t  void *pinfo;\t\t\t\t\t\t\t\\\n-\t  struct gcc_ucontext *puc;\t\t\t\t\t\\\n-\t} *rt_ = (struct rt_sigframe *) pc_;\t\t\t\t\\\n-\tsc_ = &rt_->puc->uc_mcontext;\t\t\t\t\t\\\n-      }\t\t\t\t\t\t\t\t\t\\\n-    else\t\t\t\t\t\t\t\t\\\n-      break;\t\t\t\t\t\t\t\t\\\n-    \t\t\t\t\t\t\t\t\t\\\n-    new_cfa_ = sc_->regs->gpr[STACK_POINTER_REGNUM];\t\t\t\\\n-    (FS)->cfa_how = CFA_REG_OFFSET;\t\t\t\t\t\\\n-    (FS)->cfa_reg = STACK_POINTER_REGNUM;\t\t\t\t\\\n-    (FS)->cfa_offset = new_cfa_ - (long) (CONTEXT)->cfa;\t\t\\\n-    \t\t\t\t\t\t\t\t\t\\\n-    for (i_ = 0; i_ < 32; i_++)\t\t\t\t\t\t\\\n-      if (i_ != STACK_POINTER_REGNUM)\t\t\t\t\t\\\n-\t{\t    \t\t\t\t\t\t\t\\\n-\t  (FS)->regs.reg[i_].how = REG_SAVED_OFFSET;\t\t\t\\\n-\t  (FS)->regs.reg[i_].loc.offset \t\t\t\t\\\n-\t    = (long)&(sc_->regs->gpr[i_]) - new_cfa_;\t\t\t\\\n-\t}\t\t\t\t\t\t\t\t\\\n-\t\t\t\t\t\t\t\t\t\\\n-    (FS)->regs.reg[LINK_REGISTER_REGNUM].how = REG_SAVED_OFFSET;\t\\\n-    (FS)->regs.reg[LINK_REGISTER_REGNUM].loc.offset \t\t\t\\\n-      = (long)&(sc_->regs->link) - new_cfa_;\t\t\t\t\\\n-\t\t\t\t\t\t\t\t\t\\\n-    (FS)->regs.reg[ARG_POINTER_REGNUM].how = REG_SAVED_OFFSET;\t\t\\\n-    (FS)->regs.reg[ARG_POINTER_REGNUM].loc.offset \t\t\t\\\n-      = (long)&(sc_->regs->nip) - new_cfa_;\t\t\t\t\\\n-    (FS)->retaddr_column = ARG_POINTER_REGNUM;\t\t\t\t\\\n-    goto SUCCESS;\t\t\t\t\t\t\t\\\n-  } while (0)\n-\n-#else  /* !__powerpc64__ */\n-\n-enum { SIGNAL_FRAMESIZE = 64 };\n-\n-#define MD_FALLBACK_FRAME_STATE_FOR(CONTEXT, FS, SUCCESS)\t\t\\\n-  do {\t\t\t\t\t\t\t\t\t\\\n-    unsigned char *pc_ = (CONTEXT)->ra;\t\t\t\t\t\\\n-    struct gcc_sigcontext *sc_;\t\t\t\t\t\t\\\n-    long new_cfa_;\t\t\t\t\t\t\t\\\n-    int i_;\t\t\t\t\t\t\t\t\\\n-\t\t\t\t\t\t\t\t\t\\\n-    /* li r0, 0x7777; sc  (sigreturn old)  */\t\t\t\t\\\n-    /* li r0, 0x0077; sc  (sigreturn new)  */\t\t\t\t\\\n-    /* li r0, 0x6666; sc  (rt_sigreturn old)  */\t\t\t\\\n-    /* li r0, 0x00AC; sc  (rt_sigreturn new)  */\t\t\t\\\n-    if (*(unsigned int *) (pc_+4) != 0x44000002)\t\t\t\\\n-      break;\t\t\t\t\t\t\t\t\\\n-    if (*(unsigned int *) (pc_+0) == 0x38007777\t\t\t\t\\\n-\t|| *(unsigned int *) (pc_+0) == 0x38000077)\t\t\t\\\n-      {\t\t\t\t\t\t\t\t\t\\\n-\tstruct sigframe {\t\t\t\t\t\t\\\n-\t  char gap[SIGNAL_FRAMESIZE];\t\t\t\t\t\\\n-\t  struct gcc_sigcontext sigctx;\t\t\t\t\t\\\n-\t} *rt_ = (CONTEXT)->cfa;\t\t\t\t\t\\\n-\tsc_ = &rt_->sigctx;\t\t\t\t\t\t\\\n-      }\t\t\t\t\t\t\t\t\t\\\n-    else if (*(unsigned int *) (pc_+0) == 0x38006666\t\t\t\\\n-\t     || *(unsigned int *) (pc_+0) == 0x380000AC)\t\t\\\n-      {\t\t\t\t\t\t\t\t\t\\\n-\tstruct rt_sigframe {\t\t\t\t\t\t\\\n-\t  char gap[SIGNAL_FRAMESIZE + 16];\t\t\t\t\\\n-\t  char siginfo[128];\t\t\t\t\t\t\\\n-\t  struct gcc_ucontext uc;\t\t\t\t\t\\\n-\t} *rt_ = (CONTEXT)->cfa;\t\t\t\t\t\\\n-\tsc_ = &rt_->uc.uc_mcontext;\t\t\t\t\t\\\n-      }\t\t\t\t\t\t\t\t\t\\\n-    else\t\t\t\t\t\t\t\t\\\n-      break;\t\t\t\t\t\t\t\t\\\n-    \t\t\t\t\t\t\t\t\t\\\n-    new_cfa_ = sc_->regs->gpr[STACK_POINTER_REGNUM];\t\t\t\\\n-    (FS)->cfa_how = CFA_REG_OFFSET;\t\t\t\t\t\\\n-    (FS)->cfa_reg = STACK_POINTER_REGNUM;\t\t\t\t\\\n-    (FS)->cfa_offset = new_cfa_ - (long) (CONTEXT)->cfa;\t\t\\\n-    \t\t\t\t\t\t\t\t\t\\\n-    for (i_ = 0; i_ < 32; i_++)\t\t\t\t\t\t\\\n-      if (i_ != STACK_POINTER_REGNUM)\t\t\t\t\t\\\n-\t{\t    \t\t\t\t\t\t\t\\\n-\t  (FS)->regs.reg[i_].how = REG_SAVED_OFFSET;\t\t\t\\\n-\t  (FS)->regs.reg[i_].loc.offset \t\t\t\t\\\n-\t    = (long)&(sc_->regs->gpr[i_]) - new_cfa_;\t\t\t\\\n-\t}\t\t\t\t\t\t\t\t\\\n-\t\t\t\t\t\t\t\t\t\\\n-    (FS)->regs.reg[LINK_REGISTER_REGNUM].how = REG_SAVED_OFFSET;\t\\\n-    (FS)->regs.reg[LINK_REGISTER_REGNUM].loc.offset \t\t\t\\\n-      = (long)&(sc_->regs->link) - new_cfa_;\t\t\t\t\\\n-\t\t\t\t\t\t\t\t\t\\\n-    (FS)->regs.reg[CR0_REGNO].how = REG_SAVED_OFFSET;\t\t\t\\\n-    (FS)->regs.reg[CR0_REGNO].loc.offset \t\t\t\t\\\n-      = (long)&(sc_->regs->nip) - new_cfa_;\t\t\t\t\\\n-    (FS)->retaddr_column = CR0_REGNO;\t\t\t\t\t\\\n-    goto SUCCESS;\t\t\t\t\t\t\t\\\n-  } while (0)\n-\n-#endif\n-#endif /* LIBGCC2 */\n+#define MD_UNWIND_SUPPORT \"config/rs6000/linux-unwind.h\"\n \n #define OS_MISSING_POWERPC64 !TARGET_64BIT"}, {"sha": "3713f1821a9bf0649b557370725e96f7688188da", "filename": "gcc/config/s390/linux-unwind.h", "status": "added", "additions": 131, "deletions": 0, "changes": 131, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8662eb14c0ef6531d7086ec08f5e52b87c472ede/gcc%2Fconfig%2Fs390%2Flinux-unwind.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8662eb14c0ef6531d7086ec08f5e52b87c472ede/gcc%2Fconfig%2Fs390%2Flinux-unwind.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fs390%2Flinux-unwind.h?ref=8662eb14c0ef6531d7086ec08f5e52b87c472ede", "patch": "@@ -0,0 +1,131 @@\n+/* DWARF2 EH unwinding support for S/390 Linux.\n+   Copyright (C) 2004 Free Software Foundation, Inc.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it under\n+the terms of the GNU General Public License as published by the Free\n+Software Foundation; either version 2, or (at your option) any later\n+version.\n+\n+GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING.  If not, write to the Free\n+Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n+02111-1307, USA.  */\n+\n+/* Do code reading to identify a signal frame, and set the frame\n+   state data appropriately.  See unwind-dw2.c for the structs.  */\n+\n+#define MD_FALLBACK_FRAME_STATE_FOR s390_fallback_frame_state\n+\n+static _Unwind_Reason_Code\n+s390_fallback_frame_state (struct _Unwind_Context *context,\n+\t\t\t   _Unwind_FrameState *fs)\n+{\n+  unsigned char *pc = context->ra;\n+  long new_cfa;\n+  int i;\n+\n+  typedef struct\n+  {\n+    unsigned long psw_mask;\n+    unsigned long psw_addr;\n+    unsigned long gprs[16];\n+    unsigned int  acrs[16];\n+    unsigned int  fpc;\n+    unsigned int  __pad;\n+    double        fprs[16];\n+  } __attribute__ ((__aligned__ (8))) sigregs_;\n+\n+  sigregs_ *regs;\n+  int *signo = NULL;\n+\n+  /* svc $__NR_sigreturn or svc $__NR_rt_sigreturn  */\n+  if (pc[0] != 0x0a || (pc[1] != 119 && pc[1] != 173))\n+    return _URC_END_OF_STACK;\n+\n+  /* New-style RT frame:\n+     retcode + alignment (8 bytes)\n+     siginfo (128 bytes)\n+     ucontext (contains sigregs)  */\n+  if (context->ra == context->cfa)\n+    {\n+      struct ucontext_\n+      {\n+\tunsigned long     uc_flags;\n+\tstruct ucontext_ *uc_link;\n+\tunsigned long     uc_stack[3];\n+\tsigregs_          uc_mcontext;\n+      } *uc = context->cfa + 8 + 128;\n+\n+      regs = &uc->uc_mcontext;\n+      signo = context->cfa + sizeof(long);\n+    }\n+\n+  /* Old-style RT frame and all non-RT frames:\n+     old signal mask (8 bytes)\n+     pointer to sigregs  */\n+  else\n+    {\n+      regs = *(sigregs_ **)(context->cfa + 8);\n+\n+      /* Recent kernels store the signal number immediately after\n+\t the sigregs; old kernels have the return trampoline at\n+\t this location.  */\n+      if ((void *)(regs + 1) != context->ra)\n+\tsigno = (int *)(regs + 1);\n+    }\n+\n+  new_cfa = regs->gprs[15] + 16*sizeof(long) + 32;\n+  fs->cfa_how = CFA_REG_OFFSET;\n+  fs->cfa_reg = 15;\n+  fs->cfa_offset =\n+    new_cfa - (long) context->cfa + 16*sizeof(long) + 32;\n+\n+  for (i = 0; i < 16; i++)\n+    {\n+      fs->regs.reg[i].how = REG_SAVED_OFFSET;\n+      fs->regs.reg[i].loc.offset =\n+\t(long)&regs->gprs[i] - new_cfa;\n+    }\n+  for (i = 0; i < 16; i++)\n+    {\n+      fs->regs.reg[16+i].how = REG_SAVED_OFFSET;\n+      fs->regs.reg[16+i].loc.offset =\n+\t(long)&regs->fprs[i] - new_cfa;\n+    }\n+\n+  /* Load return addr from PSW into dummy register 32.  */\n+\n+  fs->regs.reg[32].how = REG_SAVED_OFFSET;\n+  fs->regs.reg[32].loc.offset = (long)&regs->psw_addr - new_cfa;\n+  fs->retaddr_column = 32;\n+\n+  /* If we got a SIGSEGV or a SIGBUS, the PSW address points *to*\n+     the faulting instruction, not after it.  This causes the logic\n+     in unwind-dw2.c that decrements the RA to determine the correct\n+     CFI region to get confused.  To fix that, we *increment* the RA\n+     here in that case.  Note that we cannot modify the RA in place,\n+     and the frame state wants a *pointer*, not a value; thus we put\n+     the modified RA value into the unused register 33 slot of FS and\n+     have the register 32 save address point to that slot.\n+\n+     Unfortunately, for regular signals on old kernels, we don't know\n+     the signal number.  We default to not fiddling with the RA;\n+     that can fail in rare cases.  Upgrade your kernel.  */\n+\n+  if (signo && (*signo == 11 || *signo == 7))\n+    {\n+      fs->regs.reg[33].loc.exp =\n+\t(unsigned char *)regs->psw_addr + 1;\n+      fs->regs.reg[32].loc.offset =\n+\t(long)&fs->regs.reg[33].loc.exp - new_cfa;\n+    }\n+\n+  return _URC_NO_REASON;\n+}"}, {"sha": "fc26f7a91a64b06b3171f78730e6d7dfa9d7fa86", "filename": "gcc/config/s390/linux.h", "status": "modified", "additions": 1, "deletions": 107, "changes": 108, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8662eb14c0ef6531d7086ec08f5e52b87c472ede/gcc%2Fconfig%2Fs390%2Flinux.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8662eb14c0ef6531d7086ec08f5e52b87c472ede/gcc%2Fconfig%2Fs390%2Flinux.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fs390%2Flinux.h?ref=8662eb14c0ef6531d7086ec08f5e52b87c472ede", "patch": "@@ -92,112 +92,6 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n \n #define TARGET_ASM_FILE_END file_end_indicate_exec_stack\n \n-/* Do code reading to identify a signal frame, and set the frame\n-   state data appropriately.  See unwind-dw2.c for the structs.  */\n-\n-#define MD_FALLBACK_FRAME_STATE_FOR(CONTEXT, FS, SUCCESS)\t\t\\\n-  do {\t\t\t\t\t\t\t\t\t\\\n-    unsigned char *pc_ = (CONTEXT)->ra;\t\t\t\t\t\\\n-    long new_cfa_;\t\t\t\t\t\t\t\\\n-    int i_;\t\t\t\t\t\t\t\t\\\n-\t\t\t\t\t\t\t\t\t\\\n-    typedef struct \t\t\t\t\t\t\t\\\n-      {\t\t\t\t\t\t\t\t\t\\\n-        unsigned long psw_mask;\t\t\t\t\t\t\\\n-        unsigned long psw_addr;\t\t\t\t\t\t\\\n-        unsigned long gprs[16];\t\t\t\t\t\t\\\n-        unsigned int  acrs[16];\t\t\t\t\t\t\\\n-        unsigned int  fpc;\t\t\t\t\t\t\\\n-        unsigned int  __pad;\t\t\t\t\t\t\\\n-        double        fprs[16];\t\t\t\t\t\t\\\n-      } __attribute__ ((__aligned__ (8))) sigregs_;\t\t\t\\\n-\t\t\t\t\t\t\t\t\t\\\n-    sigregs_ *regs_;\t\t\t\t\t\t\t\\\n-    int *signo_ = NULL;\t\t\t\t\t\t\t\\\n-\t\t\t\t\t\t\t\t\t\\\n-    /* svc $__NR_sigreturn or svc $__NR_rt_sigreturn  */\t\t\\\n-    if (pc_[0] != 0x0a || (pc_[1] != 119 && pc_[1] != 173))\t\t\\\n-      break;\t\t\t\t\t\t\t\t\\\n-\t\t\t\t\t\t\t\t\t\\\n-    /* New-style RT frame:  \t\t\t\t\t\t\\\n-\tretcode + alignment (8 bytes)\t\t\t\t\t\\\n-\tsiginfo (128 bytes)\t\t\t\t\t\t\\\n-\tucontext (contains sigregs)  */\t\t\t\t\t\\\n-    if ((CONTEXT)->ra == (CONTEXT)->cfa)\t\t\t\t\\\n-      {\t\t\t\t\t\t\t\t\t\\\n-\tstruct ucontext_\t\t\t\t\t\t\\\n-\t  {\t\t\t\t\t\t\t\t\\\n-\t    unsigned long     uc_flags;\t\t\t\t\t\\\n-\t    struct ucontext_ *uc_link;\t\t\t\t\t\\\n-\t    unsigned long     uc_stack[3];\t\t\t\t\\\n-\t    sigregs_          uc_mcontext;\t\t\t\t\\\n-\t  } *uc_ = (CONTEXT)->cfa + 8 + 128;\t\t\t\t\\\n-\t\t\t\t\t\t\t\t\t\\\n-\tregs_ = &uc_->uc_mcontext;\t\t\t\t\t\\\n-\tsigno_ = (CONTEXT)->cfa + sizeof(long);\t\t\t\t\\\n-      }\t\t\t\t\t\t\t\t\t\\\n-\t\t\t\t\t\t\t\t\t\\\n-    /* Old-style RT frame and all non-RT frames:\t\t\t\\\n-\told signal mask (8 bytes)\t\t\t\t\t\\\n-\tpointer to sigregs  */\t\t\t\t\t\t\\\n-    else\t\t\t\t\t\t\t\t\\\n-      {\t\t\t\t\t\t\t\t\t\\\n-\tregs_ = *(sigregs_ **)((CONTEXT)->cfa + 8);\t\t\t\\\n-\t\t\t\t\t\t\t\t\t\\\n-\t/* Recent kernels store the signal number immediately after\t\\\n-\t   the sigregs; old kernels have the return trampoline at\t\\\n-\t   this location.  */\t\t\t\t\t\t\\\n-\tif ((void *)(regs_ + 1) != (CONTEXT)->ra)\t\t\t\\\n-\t  signo_ = (int *)(regs_ + 1);\t\t\t\t\t\\\n-      }\t\t\t\t\t\t\t\t\t\\\n-      \t\t\t\t\t\t\t\t\t\\\n-    new_cfa_ = regs_->gprs[15] + 16*sizeof(long) + 32;\t\t\t\\\n-    (FS)->cfa_how = CFA_REG_OFFSET;\t\t\t\t\t\\\n-    (FS)->cfa_reg = 15;\t\t\t\t\t\t\t\\\n-    (FS)->cfa_offset = \t\t\t\t\t\t\t\\\n-      new_cfa_ - (long) (CONTEXT)->cfa + 16*sizeof(long) + 32;\t\t\\\n-\t\t\t\t\t\t\t\t\t\\\n-    for (i_ = 0; i_ < 16; i_++)\t\t\t\t\t\t\\\n-      {\t\t\t\t\t\t\t\t\t\\\n-\t(FS)->regs.reg[i_].how = REG_SAVED_OFFSET;\t\t\t\\\n-\t(FS)->regs.reg[i_].loc.offset = \t\t\t\t\\\n-\t  (long)&regs_->gprs[i_] - new_cfa_;\t\t\t\t\\\n-      }\t\t\t\t\t\t\t\t\t\\\n-    for (i_ = 0; i_ < 16; i_++)\t\t\t\t\t\t\\\n-      {\t\t\t\t\t\t\t\t\t\\\n-\t(FS)->regs.reg[16+i_].how = REG_SAVED_OFFSET;\t\t\t\\\n-\t(FS)->regs.reg[16+i_].loc.offset = \t\t\t\t\\\n-\t  (long)&regs_->fprs[i_] - new_cfa_;\t\t\t\t\\\n-      }\t\t\t\t\t\t\t\t\t\\\n-\t\t\t\t\t\t\t\t\t\\\n-    /* Load return addr from PSW into dummy register 32.  */\t\t\\\n-\t\t\t\t\t\t\t\t\t\\\n-    (FS)->regs.reg[32].how = REG_SAVED_OFFSET;\t\t\t\t\\\n-    (FS)->regs.reg[32].loc.offset = (long)&regs_->psw_addr - new_cfa_;\t\\\n-    (FS)->retaddr_column = 32;\t\t\t\t\t\t\\\n-\t\t\t\t\t\t\t\t\t\\\n-    /* If we got a SIGSEGV or a SIGBUS, the PSW address points *to*\t\\\n-       the faulting instruction, not after it.  This causes the logic\t\\\n-       in unwind-dw2.c that decrements the RA to determine the correct\t\\\n-       CFI region to get confused.  To fix that, we *increment* the RA\t\\\n-       here in that case.  Note that we cannot modify the RA in place,\t\\\n-       and the frame state wants a *pointer*, not a value; thus we put\t\\\n-       the modified RA value into the unused register 33 slot of FS and\t\\\n-       have the register 32 save address point to that slot.\t\t\\\n-\t\t\t\t\t\t\t\t\t\\\n-       Unfortunately, for regular signals on old kernels, we don't know\t\\\n-       the signal number.  We default to not fiddling with the RA; \t\\\n-       that can fail in rare cases.  Upgrade your kernel.  */\t\t\\\n-\t\t\t\t\t\t\t\t\t\\\n-    if (signo_ && (*signo_ == 11 || *signo_ == 7))\t\t\t\\\n-      {\t\t\t\t\t\t\t\t\t\\\n-\t(FS)->regs.reg[33].loc.exp = \t\t\t\t\t\\\n-\t\t(unsigned char *)regs_->psw_addr + 1;\t\t\t\\\n-\t(FS)->regs.reg[32].loc.offset = \t\t\t\t\\\n-\t\t(long)&(FS)->regs.reg[33].loc.exp - new_cfa_;\t\t\\\n-      }\t\t\t\t\t\t\t\t\t\\\n-\t\t\t\t\t\t\t\t\t\\\n-    goto SUCCESS;\t\t\t\t\t\t\t\\\n-  } while (0)\n+#define MD_UNWIND_SUPPORT \"config/s390/linux-unwind.h\"\n \n #endif"}, {"sha": "ed32e245cfabb0003b6926e29901cd99ae8cc01e", "filename": "gcc/config/sh/linux-unwind.h", "status": "added", "additions": 167, "deletions": 0, "changes": 167, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8662eb14c0ef6531d7086ec08f5e52b87c472ede/gcc%2Fconfig%2Fsh%2Flinux-unwind.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8662eb14c0ef6531d7086ec08f5e52b87c472ede/gcc%2Fconfig%2Fsh%2Flinux-unwind.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Flinux-unwind.h?ref=8662eb14c0ef6531d7086ec08f5e52b87c472ede", "patch": "@@ -0,0 +1,167 @@\n+/* DWARF2 EH unwinding support for SH Linux.\n+   Copyright (C) 2004 Free Software Foundation, Inc.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GCC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with this program; see the file COPYING.  If not, write to\n+the Free Software Foundation, 59 Temple Place - Suite 330,\n+Boston, MA 02111-1307, USA.  */\n+\n+/* Do code reading to identify a signal frame, and set the frame\n+   state data appropriately.  See unwind-dw2.c for the structs.  */\n+\n+#include <signal.h>\n+#include <sys/ucontext.h>\n+#include \"insn-constants.h\"\n+\n+# if defined (__SH5__)\n+#define SH_DWARF_FRAME_GP0\t0\n+#define SH_DWARF_FRAME_FP0\t(__SH5__ == 32 ? 245 : 77)\n+#define SH_DWARF_FRAME_XD0\t289\n+#define SH_DWARF_FRAME_BT0\t68\n+#define SH_DWARF_FRAME_PR\t241\n+#define SH_DWARF_FRAME_PR_MEDIA\t18\n+#define SH_DWARF_FRAME_GBR\t238\n+#define SH_DWARF_FRAME_MACH\t239\n+#define SH_DWARF_FRAME_MACL\t240\n+#define SH_DWARF_FRAME_PC\t64\n+#define SH_DWARF_FRAME_SR\t65\n+#define SH_DWARF_FRAME_FPUL\t244\n+#define SH_DWARF_FRAME_FPSCR\t243\n+#else\n+#define SH_DWARF_FRAME_GP0\t0\n+#define SH_DWARF_FRAME_FP0\t25\n+#define SH_DWARF_FRAME_XD0\t87\n+#define SH_DWARF_FRAME_PR\t17\n+#define SH_DWARF_FRAME_GBR\t19\n+#define SH_DWARF_FRAME_MACH\t20\n+#define SH_DWARF_FRAME_MACL\t21\n+#define SH_DWARF_FRAME_PC\t16\n+#define SH_DWARF_FRAME_SR\t22\n+#define SH_DWARF_FRAME_FPUL\t23\n+#define SH_DWARF_FRAME_FPSCR\t24\n+#endif /* defined (__SH5__) */\n+\n+#if defined (__SH5__)\n+/* MD_FALLBACK_FRAME_STATE_FOR is not yet defined for SHMEDIA.  */\n+#else /* defined (__SH5__) */\n+\n+#define MD_FALLBACK_FRAME_STATE_FOR sh_fallback_frame_state\n+\n+static _Unwind_Reason_Code\n+sh_fallback_frame_state (struct _Unwind_Context *context,\n+\t\t\t _Unwind_FrameState *fs)\n+{\n+  unsigned char *pc = context->ra;\n+  struct sigcontext *sc;\n+  long new_cfa;\n+  int i;\n+#if defined (__SH3E__) || defined (__SH4__)\n+  int r;\n+#endif\n+\n+  /* mov.w 1f,r3; trapa #0x10; 1: .short 0x77  (sigreturn)  */\n+  /* mov.w 1f,r3; trapa #0x10; 1: .short 0xad  (rt_sigreturn)  */\n+  /* Newer kernel uses pad instructions to avoid an SH-4 core bug.  */\n+  /* mov.w 1f,r3; trapa #0x10; or r0,r0; or r0,r0; or r0,r0; or r0,r0;\n+     or r0,r0; 1: .short 0x77  (sigreturn)  */\n+  /* mov.w 1f,r3; trapa #0x10; or r0,r0; or r0,r0; or r0,r0; or r0,r0;\n+     or r0,r0; 1: .short 0xad  (rt_sigreturn)  */\n+  if (((*(unsigned short *) (pc+0)  == 0x9300)\n+       && (*(unsigned short *) (pc+2)  == 0xc310)\n+       && (*(unsigned short *) (pc+4)  == 0x0077))\n+      || (((*(unsigned short *) (pc+0)  == 0x9305)\n+\t   && (*(unsigned short *) (pc+2)  == 0xc310)\n+\t   && (*(unsigned short *) (pc+14)  == 0x0077))))\n+    sc = context->cfa;\n+  else if (((*(unsigned short *) (pc+0) == 0x9300)\n+\t    && (*(unsigned short *) (pc+2)  == 0xc310)\n+\t    && (*(unsigned short *) (pc+4)  == 0x00ad))\n+\t   || (((*(unsigned short *) (pc+0) == 0x9305)\n+\t\t&& (*(unsigned short *) (pc+2)  == 0xc310)\n+\t\t&& (*(unsigned short *) (pc+14)  == 0x00ad))))\n+    {\n+      struct rt_sigframe {\n+\tstruct siginfo info;\n+\tstruct ucontext uc;\n+      } *rt_ = context->cfa;\n+      sc = (struct sigcontext *) &rt_->uc.uc_mcontext;\n+    }\n+  else\n+    return _URC_END_OF_STACK;\n+\n+  new_cfa = sc->sc_regs[15];\n+  fs->cfa_how = CFA_REG_OFFSET;\n+  fs->cfa_reg = 15;\n+  fs->cfa_offset = new_cfa - (long) context->cfa;\n+\n+  for (i = 0; i < 15; i++)\n+    {\n+      fs->regs.reg[i].how = REG_SAVED_OFFSET;\n+      fs->regs.reg[i].loc.offset\n+\t= (long)&(sc->sc_regs[i]) - new_cfa;\n+    }\n+\n+  fs->regs.reg[SH_DWARF_FRAME_PR].how = REG_SAVED_OFFSET;\n+  fs->regs.reg[SH_DWARF_FRAME_PR].loc.offset\n+    = (long)&(sc->sc_pr) - new_cfa;\n+  fs->regs.reg[SH_DWARF_FRAME_SR].how = REG_SAVED_OFFSET;\n+  fs->regs.reg[SH_DWARF_FRAME_SR].loc.offset\n+    = (long)&(sc->sc_sr) - new_cfa;\n+  fs->regs.reg[SH_DWARF_FRAME_GBR].how = REG_SAVED_OFFSET;\n+  fs->regs.reg[SH_DWARF_FRAME_GBR].loc.offset\n+    = (long)&(sc->sc_gbr) - new_cfa;\n+  fs->regs.reg[SH_DWARF_FRAME_MACH].how = REG_SAVED_OFFSET;\n+  fs->regs.reg[SH_DWARF_FRAME_MACH].loc.offset\n+    = (long)&(sc->sc_mach) - new_cfa;\n+  fs->regs.reg[SH_DWARF_FRAME_MACL].how = REG_SAVED_OFFSET;\n+  fs->regs.reg[SH_DWARF_FRAME_MACL].loc.offset\n+    = (long)&(sc->sc_macl) - new_cfa;\n+\n+#if defined (__SH3E__) || defined (__SH4__)\n+  r = SH_DWARF_FRAME_FP0;\n+  for (i = 0; i < 16; i++)\n+    {\n+      fs->regs.reg[r+i].how = REG_SAVED_OFFSET;\n+      fs->regs.reg[r+i].loc.offset\n+\t= (long)&(sc->sc_fpregs[i]) - new_cfa;\n+    }\n+\n+  r = SH_DWARF_FRAME_XD0;\n+  for (i = 0; i < 8; i++)\n+    {\n+      fs->regs.reg[i].how = REG_SAVED_OFFSET;\n+      fs->regs.reg[i].loc.offset\n+\t= (long)&(sc->sc_xfpregs[2*i]) - new_cfa;\n+    }\n+\n+  fs->regs.reg[SH_DWARF_FRAME_FPUL].how = REG_SAVED_OFFSET;\n+  fs->regs.reg[SH_DWARF_FRAME_FPUL].loc.offset\n+    = (long)&(sc->sc_fpul) - new_cfa;\n+  fs->regs.reg[SH_DWARF_FRAME_FPSCR].how = REG_SAVED_OFFSET;\n+  fs->regs.reg[SH_DWARF_FRAME_FPSCR].loc.offset\n+    = (long)&(sc->sc_fpscr) - new_cfa;\n+#endif\n+\n+  /* The unwinder expects the PC to point to the following insn,\n+     whereas the kernel returns the address of the actual\n+     faulting insn.  */\n+  sc->sc_pc += 2;\n+  fs->regs.reg[SH_DWARF_FRAME_PC].how = REG_SAVED_OFFSET;\n+  fs->regs.reg[SH_DWARF_FRAME_PC].loc.offset\n+    = (long)&(sc->sc_pc) - new_cfa;\n+  fs->retaddr_column = SH_DWARF_FRAME_PC;\n+  return _URC_NO_REASON;\n+}\n+#endif /* defined (__SH5__) */"}, {"sha": "1142b126946f49819b8f0a7e81062c50b56c1a0c", "filename": "gcc/config/sh/linux.h", "status": "modified", "additions": 1, "deletions": 153, "changes": 154, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8662eb14c0ef6531d7086ec08f5e52b87c472ede/gcc%2Fconfig%2Fsh%2Flinux.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8662eb14c0ef6531d7086ec08f5e52b87c472ede/gcc%2Fconfig%2Fsh%2Flinux.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Flinux.h?ref=8662eb14c0ef6531d7086ec08f5e52b87c472ede", "patch": "@@ -147,159 +147,7 @@ do { \\\n     fprintf (STREAM, \"2:\\tlds.l\\t@r15+,pr\\n\");\t\t\t\t\\\n   } while (0)\n \n-/* Do code reading to identify a signal frame, and set the frame\n-   state data appropriately.  See unwind-dw2.c for the structs.  */\n-\n-#ifdef IN_LIBGCC2\n-#include <signal.h>\n-#include <sys/ucontext.h>\n-#include \"insn-constants.h\"\n-\n-# if defined (__SH5__)\n-#define SH_DWARF_FRAME_GP0\t0\n-#define SH_DWARF_FRAME_FP0\t(__SH5__ == 32 ? 245 : 77)\n-#define SH_DWARF_FRAME_XD0\t289\n-#define SH_DWARF_FRAME_BT0\t68\n-#define SH_DWARF_FRAME_PR\t241\n-#define SH_DWARF_FRAME_PR_MEDIA\t18\n-#define SH_DWARF_FRAME_GBR\t238\n-#define SH_DWARF_FRAME_MACH\t239\n-#define SH_DWARF_FRAME_MACL\t240\n-#define SH_DWARF_FRAME_PC\t64\n-#define SH_DWARF_FRAME_SR\t65\n-#define SH_DWARF_FRAME_FPUL\t244\n-#define SH_DWARF_FRAME_FPSCR\t243\n-#else\n-#define SH_DWARF_FRAME_GP0\t0\n-#define SH_DWARF_FRAME_FP0\t25\n-#define SH_DWARF_FRAME_XD0\t87\n-#define SH_DWARF_FRAME_PR\t17\n-#define SH_DWARF_FRAME_GBR\t19\n-#define SH_DWARF_FRAME_MACH\t20\n-#define SH_DWARF_FRAME_MACL\t21\n-#define SH_DWARF_FRAME_PC\t16\n-#define SH_DWARF_FRAME_SR\t22\n-#define SH_DWARF_FRAME_FPUL\t23\n-#define SH_DWARF_FRAME_FPSCR\t24\n-#endif /* defined (__SH5__) */\n-\n-#if defined (__SH5__)\n-/* MD_FALLBACK_FRAME_STATE_FOR is not yet defined for SHMEDIA.  */\n-#else /* defined (__SH5__) */\n-\n-#if defined (__SH3E__) || defined (__SH4__)\n-#define SH_FALLBACK_FRAME_FLOAT_STATE(SC, FS, CFA)\t\t\t\\\n-  do {\t\t\t\t\t\t\t\t\t\\\n-    int i_, r_;\t\t\t\t\t\t\t\t\\\n-\t\t\t\t\t\t\t\t\t\\\n-    r_ = SH_DWARF_FRAME_FP0;\t\t\t\t\t\t\\\n-    for (i_ = 0; i_ < 16; i_++)\t\t\t\t\t\t\\\n-      {\t\t    \t\t\t\t\t\t\t\\\n-\t(FS)->regs.reg[r_+i_].how = REG_SAVED_OFFSET;\t\t\t\\\n-\t(FS)->regs.reg[r_+i_].loc.offset \t\t\t\t\\\n-\t  = (long)&((SC)->sc_fpregs[i_]) - (CFA);\t\t\t\\\n-      }\t\t\t\t\t\t\t\t\t\\\n-\t\t\t\t\t\t\t\t\t\\\n-    r_ = SH_DWARF_FRAME_XD0\t;\t\t\t\t\t\\\n-    for (i_ = 0; i_ < 8; i_++)\t\t\t\t\t\t\\\n-      {\t\t    \t\t\t\t\t\t\t\\\n-\t(FS)->regs.reg[i_].how = REG_SAVED_OFFSET;\t\t\t\\\n-\t(FS)->regs.reg[i_].loc.offset\t \t\t\t\t\\\n-\t  = (long)&((SC)->sc_xfpregs[2*i_]) - (CFA);\t\t\t\\\n-      }\t\t\t\t\t\t\t\t\t\\\n-\t\t\t\t\t\t\t\t\t\\\n-    (FS)->regs.reg[SH_DWARF_FRAME_FPUL].how = REG_SAVED_OFFSET;\t\t\\\n-    (FS)->regs.reg[SH_DWARF_FRAME_FPUL].loc.offset\t\t\t\\\n-      = (long)&((SC)->sc_fpul) - (CFA);\t\t\t\t\t\\\n-    (FS)->regs.reg[SH_DWARF_FRAME_FPSCR].how = REG_SAVED_OFFSET;\t\\\n-    (FS)->regs.reg[SH_DWARF_FRAME_FPSCR].loc.offset\t\t\t\\\n-      = (long)&((SC)->sc_fpscr) - (CFA);\t\t\t\t\\\n-  } while (0)\n-\n-#else\n-#define SH_FALLBACK_FRAME_FLOAT_STATE(SC, FS, CFA)\n-#endif\n-\n-#define MD_FALLBACK_FRAME_STATE_FOR(CONTEXT, FS, SUCCESS)\t\t\\\n-  do {\t\t\t\t\t\t\t\t\t\\\n-    unsigned char *pc_ = (CONTEXT)->ra;\t\t\t\t\t\\\n-    struct sigcontext *sc_;\t\t\t\t\t\t\\\n-    long new_cfa_;\t\t\t\t\t\t\t\\\n-    int i_;\t\t\t\t\t\t\t\t\\\n-\t\t\t\t\t\t\t\t\t\\\n-    /* mov.w 1f,r3; trapa #0x10; 1: .short 0x77  (sigreturn)  */\t\\\n-    /* mov.w 1f,r3; trapa #0x10; 1: .short 0xad  (rt_sigreturn)  */\t\\\n-    /* Newer kernel uses pad instructions to avoid an SH-4 core bug.  */\\\n-    /* mov.w 1f,r3; trapa #0x10; or r0,r0; or r0,r0; or r0,r0; or r0,r0;\\\n-       or r0,r0; 1: .short 0x77  (sigreturn)  */\t\t\t\\\n-    /* mov.w 1f,r3; trapa #0x10; or r0,r0; or r0,r0; or r0,r0; or r0,r0;\\\n-       or r0,r0; 1: .short 0xad  (rt_sigreturn)  */\t\t\t\\\n-    if (((*(unsigned short *) (pc_+0)  == 0x9300)\t\t\t\\\n-\t && (*(unsigned short *) (pc_+2)  == 0xc310)\t\t\t\\\n-\t && (*(unsigned short *) (pc_+4)  == 0x0077))\t\t\t\\\n-\t|| (((*(unsigned short *) (pc_+0)  == 0x9305)\t\t\t\\\n-\t    && (*(unsigned short *) (pc_+2)  == 0xc310)\t\t\t\\\n-\t    && (*(unsigned short *) (pc_+14)  == 0x0077))))\t\t\\\n-      sc_ = (CONTEXT)->cfa;\t\t\t\t\t\t\\\n-    else if (((*(unsigned short *) (pc_+0) == 0x9300)\t\t\t\\\n-\t      && (*(unsigned short *) (pc_+2)  == 0xc310)\t\t\\\n-\t      && (*(unsigned short *) (pc_+4)  == 0x00ad))\t\t\\\n-\t     || (((*(unsigned short *) (pc_+0) == 0x9305)\t\t\\\n-\t\t && (*(unsigned short *) (pc_+2)  == 0xc310)\t\t\\\n-\t\t && (*(unsigned short *) (pc_+14)  == 0x00ad))))\t\\\n-      {\t\t\t\t\t\t\t\t\t\\\n-\tstruct rt_sigframe {\t\t\t\t\t\t\\\n-\t  struct siginfo info;\t\t\t\t\t\t\\\n-\t  struct ucontext uc;\t\t\t\t\t\t\\\n-\t} *rt_ = (CONTEXT)->cfa;\t\t\t\t\t\\\n-\tsc_ = (struct sigcontext *) &rt_->uc.uc_mcontext;\t\t\\\n-      }\t\t\t\t\t\t\t\t\t\\\n-    else\t\t\t\t\t\t\t\t\\\n-      break;\t\t\t\t\t\t\t\t\\\n-    \t\t\t\t\t\t\t\t\t\\\n-    new_cfa_ = sc_->sc_regs[15];\t\t\t\t\t\\\n-    (FS)->cfa_how = CFA_REG_OFFSET;\t\t\t\t\t\\\n-    (FS)->cfa_reg = 15;\t\t\t\t\t\t\t\\\n-    (FS)->cfa_offset = new_cfa_ - (long) (CONTEXT)->cfa;\t\t\\\n-    \t\t\t\t\t\t\t\t\t\\\n-    for (i_ = 0; i_ < 15; i_++)\t\t\t\t\t\t\\\n-      {\t\t    \t\t\t\t\t\t\t\\\n-\t(FS)->regs.reg[i_].how = REG_SAVED_OFFSET;\t\t\t\\\n-\t(FS)->regs.reg[i_].loc.offset\t \t\t\t\t\\\n-\t  = (long)&(sc_->sc_regs[i_]) - new_cfa_;\t\t\t\\\n-      }\t\t\t\t\t\t\t\t\t\\\n-\t\t\t\t\t\t\t\t\t\\\n-    (FS)->regs.reg[SH_DWARF_FRAME_PR].how = REG_SAVED_OFFSET;\t\t\\\n-    (FS)->regs.reg[SH_DWARF_FRAME_PR].loc.offset\t\t\t\\\n-      = (long)&(sc_->sc_pr) - new_cfa_;\t\t\t\t\t\\\n-    (FS)->regs.reg[SH_DWARF_FRAME_SR].how = REG_SAVED_OFFSET;\t\t\\\n-    (FS)->regs.reg[SH_DWARF_FRAME_SR].loc.offset\t\t\t\\\n-      = (long)&(sc_->sc_sr) - new_cfa_;\t\t\t\t\t\\\n-    (FS)->regs.reg[SH_DWARF_FRAME_GBR].how = REG_SAVED_OFFSET;\t\t\\\n-    (FS)->regs.reg[SH_DWARF_FRAME_GBR].loc.offset\t\t\t\\\n-      = (long)&(sc_->sc_gbr) - new_cfa_;\t\t\t\t\\\n-    (FS)->regs.reg[SH_DWARF_FRAME_MACH].how = REG_SAVED_OFFSET;\t\t\\\n-    (FS)->regs.reg[SH_DWARF_FRAME_MACH].loc.offset\t\t\t\\\n-      = (long)&(sc_->sc_mach) - new_cfa_;\t\t\t\t\\\n-    (FS)->regs.reg[SH_DWARF_FRAME_MACL].how = REG_SAVED_OFFSET;\t\t\\\n-    (FS)->regs.reg[SH_DWARF_FRAME_MACL].loc.offset\t\t\t\\\n-      = (long)&(sc_->sc_macl) - new_cfa_;\t\t\t\t\\\n-\t\t\t\t\t\t\t\t\t\\\n-     SH_FALLBACK_FRAME_FLOAT_STATE(sc_, (FS), new_cfa_);\t\t\\\n-\t\t\t\t\t\t\t\t\t\\\n-    /* The unwinder expects the PC to point to the following insn,\t\\\n-       whereas the kernel returns the address of the actual\t\t\\\n-       faulting insn.  */\t\t\t\t\t\t\\\n-    sc_->sc_pc += 2;\t  \t\t\t\t\t\t\\\n-    (FS)->regs.reg[SH_DWARF_FRAME_PC].how = REG_SAVED_OFFSET;\t\t\\\n-    (FS)->regs.reg[SH_DWARF_FRAME_PC].loc.offset\t\t\t\\\n-      = (long)&(sc_->sc_pc) - new_cfa_;\t\t\t\t\t\\\n-    (FS)->retaddr_column = SH_DWARF_FRAME_PC;\t\t\t\t\\\n-    goto SUCCESS;\t\t\t\t\t\t\t\\\n-  } while (0)\n-\n-#endif /* defined (__SH5__) */\n-#endif /* IN_LIBGCC2 */\n+#define MD_UNWIND_SUPPORT \"config/sh/linux-unwind.h\"\n \n /* For SH3 and SH4, we use a slot of the unwind frame which correspond\n    to a fake register number 16 as a placeholder for the return address"}, {"sha": "3ce967d917103cbceb205d125cf1100b62e028ca", "filename": "gcc/config/sparc/linux-unwind.h", "status": "added", "additions": 150, "deletions": 0, "changes": 150, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8662eb14c0ef6531d7086ec08f5e52b87c472ede/gcc%2Fconfig%2Fsparc%2Flinux-unwind.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8662eb14c0ef6531d7086ec08f5e52b87c472ede/gcc%2Fconfig%2Fsparc%2Flinux-unwind.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Flinux-unwind.h?ref=8662eb14c0ef6531d7086ec08f5e52b87c472ede", "patch": "@@ -0,0 +1,150 @@\n+/* DWARF2 EH unwinding support for SPARC Linux.\n+   Copyright 2004 Free Software Foundation, Inc.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GCC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING.  If not, write to\n+the Free Software Foundation, 59 Temple Place - Suite 330,\n+Boston, MA 02111-1307, USA.  */\n+\n+/* Do code reading to identify a signal frame, and set the frame\n+   state data appropriately.  See unwind-dw2.c for the structs.  */\n+\n+/* Handle multilib correctly.  */\n+#if defined(__arch64__)\n+\n+/* 64-bit SPARC version */\n+#define MD_FALLBACK_FRAME_STATE_FOR sparc64_fallback_frame_state\n+\n+static _Unwind_Reason_Code\n+sparc64_fallback_frame_state (struct _Unwind_Context *context,\n+\t\t\t      _Unwind_FrameState *fs)\n+{\n+  unsigned int *pc = context->ra;\n+  long new_cfa, i;\n+  long regs_off, fpu_save_off;\n+  long this_cfa, fpu_save;\n+\n+  if (pc[0] != 0x82102065\t\t/* mov NR_rt_sigreturn, %g1 */\n+      || pc[1] != 0x91d0206d)\t\t/* ta 0x6d */\n+    return _URC_END_OF_STACK;\n+  regs_off = 192 + 128;\n+  fpu_save_off = regs_off + (16 * 8) + (3 * 8) + (2 * 4);\n+  this_cfa = (long) context->cfa;\n+  new_cfa = *(long *)((context->cfa) + (regs_off + (14 * 8)));\n+  new_cfa += 2047; /* Stack bias */\n+  fpu_save = *(long *)((this_cfa) + (fpu_save_off));\n+  fs->cfa_how = CFA_REG_OFFSET;\n+  fs->cfa_reg = 14;\n+  fs->cfa_offset = new_cfa - (long) context->cfa;\n+  for (i = 1; i < 16; ++i)\n+    {\n+      fs->regs.reg[i].how = REG_SAVED_OFFSET;\n+      fs->regs.reg[i].loc.offset =\n+\tthis_cfa + (regs_off + (i * 8)) - new_cfa;\n+    }\n+  for (i = 0; i < 16; ++i)\n+    {\n+      fs->regs.reg[i + 16].how = REG_SAVED_OFFSET;\n+      fs->regs.reg[i + 16].loc.offset =\n+\tthis_cfa + (i * 8) - new_cfa;\n+    }\n+  if (fpu_save)\n+    {\n+      for (i = 0; i < 64; ++i)\n+\t{\n+\t  if (i > 32 && (i & 0x1))\n+\t    continue;\n+\t  fs->regs.reg[i + 32].how = REG_SAVED_OFFSET;\n+\t  fs->regs.reg[i + 32].loc.offset =\n+\t    (fpu_save + (i * 4)) - new_cfa;\n+\t}\n+    }\n+  /* Stick return address into %g0, same trick Alpha uses.  */\n+  fs->regs.reg[0].how = REG_SAVED_OFFSET;\n+  fs->regs.reg[0].loc.offset =\n+    this_cfa + (regs_off + (16 * 8) + 8) - new_cfa;\n+  fs->retaddr_column = 0;\n+  return _URC_NO_REASON;\n+}\n+\n+#else\n+\n+/* 32-bit SPARC version */\n+#define MD_FALLBACK_FRAME_STATE_FOR sparc_fallback_frame_state\n+\n+static _Unwind_Reason_Code\n+sparc_fallback_frame_state (struct _Unwind_Context *context,\n+\t\t\t    _Unwind_FrameState *fs)\n+{\n+  unsigned int *pc = context->ra;\n+  int new_cfa, i, oldstyle;\n+  int regs_off, fpu_save_off;\n+  int fpu_save, this_cfa;\n+\n+  if (pc[1] != 0x91d02010)\t\t/* ta 0x10 */\n+    return _URC_END_OF_STACK;\n+  if (pc[0] == 0x821020d8)\t\t/* mov NR_sigreturn, %g1 */\n+    oldstyle = 1;\n+  else if (pc[0] == 0x82102065)\t/* mov NR_rt_sigreturn, %g1 */\n+    oldstyle = 0;\n+  else\n+    return _URC_END_OF_STACK;\n+  if (oldstyle)\n+    {\n+      regs_off = 96;\n+      fpu_save_off = regs_off + (4 * 4) + (16 * 4);\n+    }\n+  else\n+    {\n+      regs_off = 96 + 128;\n+      fpu_save_off = regs_off + (4 * 4) + (16 * 4) + (2 * 4);\n+    }\n+  this_cfa = (int) context->cfa;\n+  new_cfa = *(int *)((context->cfa) + (regs_off+(4*4)+(14 * 4)));\n+  fpu_save = *(int *)((this_cfa) + (fpu_save_off));\n+  fs->cfa_how = CFA_REG_OFFSET;\n+  fs->cfa_reg = 14;\n+  fs->cfa_offset = new_cfa - (int) context->cfa;\n+  for (i = 1; i < 16; ++i)\n+    {\n+      if (i == 14)\n+\tcontinue;\n+      fs->regs.reg[i].how = REG_SAVED_OFFSET;\n+      fs->regs.reg[i].loc.offset =\n+\tthis_cfa + (regs_off+(4 * 4)+(i * 4)) - new_cfa;\n+    }\n+  for (i = 0; i < 16; ++i)\n+    {\n+      fs->regs.reg[i + 16].how = REG_SAVED_OFFSET;\n+      fs->regs.reg[i + 16].loc.offset =\n+\tthis_cfa + (i * 4) - new_cfa;\n+    }\n+  if (fpu_save)\n+    {\n+      for (i = 0; i < 32; ++i)\n+\t{\n+\t  fs->regs.reg[i + 32].how = REG_SAVED_OFFSET;\n+\t  fs->regs.reg[i + 32].loc.offset =\n+\t    (fpu_save + (i * 4)) - new_cfa;\n+\t}\n+    }\n+  /* Stick return address into %g0, same trick Alpha uses.  */\n+  fs->regs.reg[0].how = REG_SAVED_OFFSET;\n+  fs->regs.reg[0].loc.offset = this_cfa+(regs_off+4)-new_cfa;\n+  fs->retaddr_column = 0;\n+  return _URC_NO_REASON;\n+}\n+\n+#endif"}, {"sha": "788b1433dc34884e9c417042f143dce37d011103", "filename": "gcc/config/sparc/linux.h", "status": "modified", "additions": 1, "deletions": 63, "changes": 64, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8662eb14c0ef6531d7086ec08f5e52b87c472ede/gcc%2Fconfig%2Fsparc%2Flinux.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8662eb14c0ef6531d7086ec08f5e52b87c472ede/gcc%2Fconfig%2Fsparc%2Flinux.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Flinux.h?ref=8662eb14c0ef6531d7086ec08f5e52b87c472ede", "patch": "@@ -228,66 +228,4 @@ do {\t\t\t\t\t\t\t\t\t\\\n #define USE_LD_AS_NEEDED 1\n #endif\n \n-/* Do code reading to identify a signal frame, and set the frame\n-   state data appropriately.  See unwind-dw2.c for the structs.  */\n-\n-#define MD_FALLBACK_FRAME_STATE_FOR(CONTEXT, FS, SUCCESS)\t\t\\\n-  do {\t\t\t\t\t\t\t\t\t\\\n-    unsigned int *pc_ = (CONTEXT)->ra;\t\t\t\t\t\\\n-    int new_cfa_, i_, oldstyle_;\t\t\t\t\t\\\n-    int regs_off_, fpu_save_off_;\t\t\t\t\t\\\n-    int fpu_save_, this_cfa_;\t\t\t\t\t\t\\\n-\t\t\t\t\t\t\t\t\t\\\n-    if (pc_[1] != 0x91d02010)\t\t/* ta 0x10 */\t\t\t\\\n-      break;\t\t\t\t\t\t\t\t\\\n-    if (pc_[0] == 0x821020d8)\t\t/* mov NR_sigreturn, %g1 */\t\\\n-      oldstyle_ = 1;\t\t\t\t\t\t\t\\\n-    else if (pc_[0] == 0x82102065)\t/* mov NR_rt_sigreturn, %g1 */\t\\\n-      oldstyle_ = 0;\t\t\t\t\t\t\t\\\n-    else\t\t\t\t\t\t\t\t\\\n-      break;\t\t\t\t\t\t\t\t\\\n-    if (oldstyle_)\t\t\t\t\t\t\t\\\n-      {\t\t\t\t\t\t\t\t\t\\\n-        regs_off_ = 96;\t\t\t\t\t\t\t\\\n-        fpu_save_off_ = regs_off_ + (4 * 4) + (16 * 4);\t\t\t\\\n-      }\t\t\t\t\t\t\t\t\t\\\n-    else\t\t\t\t\t\t\t\t\\\n-      {\t\t\t\t\t\t\t\t\t\\\n-        regs_off_ = 96 + 128;\t\t\t\t\t\t\\\n-        fpu_save_off_ = regs_off_ + (4 * 4) + (16 * 4) + (2 * 4);\t\\\n-      }\t\t\t\t\t\t\t\t\t\\\n-    this_cfa_ = (int) (CONTEXT)->cfa;\t\t\t\t\t\\\n-    new_cfa_ = *(int *)(((CONTEXT)->cfa) + (regs_off_+(4*4)+(14 * 4)));\t\\\n-    fpu_save_ = *(int *)((this_cfa_) + (fpu_save_off_));\t\t\\\n-    (FS)->cfa_how = CFA_REG_OFFSET;\t\t\t\t\t\\\n-    (FS)->cfa_reg = 14;\t\t\t\t\t\t\t\\\n-    (FS)->cfa_offset = new_cfa_ - (int) (CONTEXT)->cfa;\t\t\t\\\n-    for (i_ = 1; i_ < 16; ++i_)\t\t\t\t\t\t\\\n-      {\t\t\t\t\t\t\t\t\t\\\n-        if (i_ == 14)\t\t\t\t\t\t\t\\\n-          continue;\t\t\t\t\t\t\t\\\n-\t(FS)->regs.reg[i_].how = REG_SAVED_OFFSET;\t\t\t\\\n-\t(FS)->regs.reg[i_].loc.offset =\t\t\t\t\t\\\n-\t   this_cfa_ + (regs_off_+(4 * 4)+(i_ * 4)) - new_cfa_;\t\t\\\n-      }\t\t\t\t\t\t\t\t\t\\\n-    for (i_ = 0; i_ < 16; ++i_)\t\t\t\t\t\t\\\n-      {\t\t\t\t\t\t\t\t\t\\\n-\t(FS)->regs.reg[i_ + 16].how = REG_SAVED_OFFSET;\t\t\t\\\n-\t(FS)->regs.reg[i_ + 16].loc.offset =\t\t\t\t\\\n-\t  this_cfa_ + (i_ * 4) - new_cfa_;\t\t\t\t\\\n-      }\t\t\t\t\t\t\t\t\t\\\n-    if (fpu_save_)\t\t\t\t\t\t\t\\\n-      {\t\t\t\t\t\t\t\t\t\\\n-\tfor (i_ = 0; i_ < 32; ++i_)\t\t\t\t\t\\\n-\t  {\t\t\t\t\t\t\t\t\\\n-\t    (FS)->regs.reg[i_ + 32].how = REG_SAVED_OFFSET;\t\t\\\n-\t    (FS)->regs.reg[i_ + 32].loc.offset =\t\t\t\\\n-\t      (fpu_save_ + (i_ * 4)) - new_cfa_;\t\t\t\\\n-\t  }\t\t\t\t\t\t\t\t\\\n-      }\t\t\t\t\t\t\t\t\t\\\n-    /* Stick return address into %g0, same trick Alpha uses.  */\t\\\n-    (FS)->regs.reg[0].how = REG_SAVED_OFFSET;\t\t\t\t\\\n-    (FS)->regs.reg[0].loc.offset = this_cfa_+(regs_off_+4)-new_cfa_;\t\\\n-    (FS)->retaddr_column = 0;\t\t\t\t\t\t\\\n-    goto SUCCESS;\t\t\t\t\t\t\t\\\n-  } while (0)\n+#define MD_UNWIND_SUPPORT \"config/sparc/linux-unwind.h\""}, {"sha": "daf1653bfc775555868897d66213ef31cb423d5f", "filename": "gcc/config/sparc/linux64.h", "status": "modified", "additions": 1, "deletions": 118, "changes": 119, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8662eb14c0ef6531d7086ec08f5e52b87c472ede/gcc%2Fconfig%2Fsparc%2Flinux64.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8662eb14c0ef6531d7086ec08f5e52b87c472ede/gcc%2Fconfig%2Fsparc%2Flinux64.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Flinux64.h?ref=8662eb14c0ef6531d7086ec08f5e52b87c472ede", "patch": "@@ -366,121 +366,4 @@ do {\t\t\t\t\t\t\t\t\t\\\n #define USE_LD_AS_NEEDED 1\n #endif\n \n-/* Do code reading to identify a signal frame, and set the frame\n-   state data appropriately.  See unwind-dw2.c for the structs.  */\n-\n-/* Handle multilib correctly.  */\n-#if defined(__arch64__)\n-/* 64-bit SPARC version */\n-#define MD_FALLBACK_FRAME_STATE_FOR(CONTEXT, FS, SUCCESS)\t\t\\\n-  do {\t\t\t\t\t\t\t\t\t\\\n-    unsigned int *pc_ = (CONTEXT)->ra;\t\t\t\t\t\\\n-    long new_cfa_, i_;\t\t\t\t\t\t\t\\\n-    long regs_off_, fpu_save_off_;\t\t\t\t\t\\\n-    long this_cfa_, fpu_save_;\t\t\t\t\t\t\\\n-\t\t\t\t\t\t\t\t\t\\\n-    if (pc_[0] != 0x82102065\t\t/* mov NR_rt_sigreturn, %g1 */\t\\\n-        || pc_[1] != 0x91d0206d)\t\t/* ta 0x6d */\t\t\\\n-      break;\t\t\t\t\t\t\t\t\\\n-    regs_off_ = 192 + 128;\t\t\t\t\t\t\\\n-    fpu_save_off_ = regs_off_ + (16 * 8) + (3 * 8) + (2 * 4);\t\t\\\n-    this_cfa_ = (long) (CONTEXT)->cfa;\t\t\t\t\t\\\n-    new_cfa_ = *(long *)(((CONTEXT)->cfa) + (regs_off_ + (14 * 8)));\t\\\n-    new_cfa_ += 2047; /* Stack bias */\t\t\t\t\t\\\n-    fpu_save_ = *(long *)((this_cfa_) + (fpu_save_off_));\t\t\\\n-    (FS)->cfa_how = CFA_REG_OFFSET;\t\t\t\t\t\\\n-    (FS)->cfa_reg = 14;\t\t\t\t\t\t\t\\\n-    (FS)->cfa_offset = new_cfa_ - (long) (CONTEXT)->cfa;\t\t\\\n-    for (i_ = 1; i_ < 16; ++i_)\t\t\t\t\t\t\\\n-      {\t\t\t\t\t\t\t\t\t\\\n-\t(FS)->regs.reg[i_].how = REG_SAVED_OFFSET;\t\t\t\\\n-\t(FS)->regs.reg[i_].loc.offset =\t\t\t\t\t\\\n-\t  this_cfa_ + (regs_off_ + (i_ * 8)) - new_cfa_;\t\t\\\n-      }\t\t\t\t\t\t\t\t\t\\\n-    for (i_ = 0; i_ < 16; ++i_)\t\t\t\t\t\t\\\n-      {\t\t\t\t\t\t\t\t\t\\\n-\t(FS)->regs.reg[i_ + 16].how = REG_SAVED_OFFSET;\t\t\t\\\n-\t(FS)->regs.reg[i_ + 16].loc.offset =\t\t\t\t\\\n-\t  this_cfa_ + (i_ * 8) - new_cfa_;\t\t\t\t\\\n-      }\t\t\t\t\t\t\t\t\t\\\n-    if (fpu_save_)\t\t\t\t\t\t\t\\\n-      {\t\t\t\t\t\t\t\t\t\\\n-\tfor (i_ = 0; i_ < 64; ++i_)\t\t\t\t\t\\\n-\t  {\t\t\t\t\t\t\t\t\\\n-            if (i_ > 32 && (i_ & 0x1))\t\t\t\t\t\\\n-              continue;\t\t\t\t\t\t\t\\\n-\t    (FS)->regs.reg[i_ + 32].how = REG_SAVED_OFFSET;\t\t\\\n-\t    (FS)->regs.reg[i_ + 32].loc.offset =\t\t\t\\\n-\t      (fpu_save_ + (i_ * 4)) - new_cfa_;\t\t\t\\\n-\t  }\t\t\t\t\t\t\t\t\\\n-      }\t\t\t\t\t\t\t\t\t\\\n-    /* Stick return address into %g0, same trick Alpha uses.  */\t\\\n-    (FS)->regs.reg[0].how = REG_SAVED_OFFSET;\t\t\t\t\\\n-    (FS)->regs.reg[0].loc.offset =\t\t\t\t\t\\\n-      this_cfa_ + (regs_off_ + (16 * 8) + 8) - new_cfa_;\t\t\\\n-    (FS)->retaddr_column = 0;\t\t\t\t\t\t\\\n-    goto SUCCESS;\t\t\t\t\t\t\t\\\n-  } while (0)\n-#else\n-/* 32-bit SPARC version */\n-#define MD_FALLBACK_FRAME_STATE_FOR(CONTEXT, FS, SUCCESS)\t\t\\\n-  do {\t\t\t\t\t\t\t\t\t\\\n-    unsigned int *pc_ = (CONTEXT)->ra;\t\t\t\t\t\\\n-    int new_cfa_, i_, oldstyle_;\t\t\t\t\t\\\n-    int regs_off_, fpu_save_off_;\t\t\t\t\t\\\n-    int fpu_save_, this_cfa_;\t\t\t\t\t\t\\\n-\t\t\t\t\t\t\t\t\t\\\n-    if (pc_[1] != 0x91d02010)\t\t/* ta 0x10 */\t\t\t\\\n-      break;\t\t\t\t\t\t\t\t\\\n-    if (pc_[0] == 0x821020d8)\t\t/* mov NR_sigreturn, %g1 */\t\\\n-      oldstyle_ = 1;\t\t\t\t\t\t\t\\\n-    else if (pc_[0] == 0x82102065)\t/* mov NR_rt_sigreturn, %g1 */\t\\\n-      oldstyle_ = 0;\t\t\t\t\t\t\t\\\n-    else\t\t\t\t\t\t\t\t\\\n-      break;\t\t\t\t\t\t\t\t\\\n-    if (oldstyle_)\t\t\t\t\t\t\t\\\n-      {\t\t\t\t\t\t\t\t\t\\\n-        regs_off_ = 96;\t\t\t\t\t\t\t\\\n-        fpu_save_off_ = regs_off_ + (4 * 4) + (16 * 4);\t\t\t\\\n-      }\t\t\t\t\t\t\t\t\t\\\n-    else\t\t\t\t\t\t\t\t\\\n-      {\t\t\t\t\t\t\t\t\t\\\n-        regs_off_ = 96 + 128;\t\t\t\t\t\t\\\n-        fpu_save_off_ = regs_off_ + (4 * 4) + (16 * 4) + (2 * 4);\t\\\n-      }\t\t\t\t\t\t\t\t\t\\\n-    this_cfa_ = (int) (CONTEXT)->cfa;\t\t\t\t\t\\\n-    new_cfa_ = *(int *)(((CONTEXT)->cfa) + (regs_off_+(4*4)+(14 * 4)));\t\\\n-    fpu_save_ = *(int *)((this_cfa_) + (fpu_save_off_));\t\t\\\n-    (FS)->cfa_how = CFA_REG_OFFSET;\t\t\t\t\t\\\n-    (FS)->cfa_reg = 14;\t\t\t\t\t\t\t\\\n-    (FS)->cfa_offset = new_cfa_ - (int) (CONTEXT)->cfa;\t\t\t\\\n-    for (i_ = 1; i_ < 16; ++i_)\t\t\t\t\t\t\\\n-      {\t\t\t\t\t\t\t\t\t\\\n-        if (i_ == 14)\t\t\t\t\t\t\t\\\n-          continue;\t\t\t\t\t\t\t\\\n-\t(FS)->regs.reg[i_].how = REG_SAVED_OFFSET;\t\t\t\\\n-\t(FS)->regs.reg[i_].loc.offset =\t\t\t\t\t\\\n-\t   this_cfa_ + (regs_off_+(4 * 4)+(i_ * 4)) - new_cfa_;\t\t\\\n-      }\t\t\t\t\t\t\t\t\t\\\n-    for (i_ = 0; i_ < 16; ++i_)\t\t\t\t\t\t\\\n-      {\t\t\t\t\t\t\t\t\t\\\n-\t(FS)->regs.reg[i_ + 16].how = REG_SAVED_OFFSET;\t\t\t\\\n-\t(FS)->regs.reg[i_ + 16].loc.offset =\t\t\t\t\\\n-\t  this_cfa_ + (i_ * 4) - new_cfa_;\t\t\t\t\\\n-      }\t\t\t\t\t\t\t\t\t\\\n-    if (fpu_save_)\t\t\t\t\t\t\t\\\n-      {\t\t\t\t\t\t\t\t\t\\\n-\tfor (i_ = 0; i_ < 32; ++i_)\t\t\t\t\t\\\n-\t  {\t\t\t\t\t\t\t\t\\\n-\t    (FS)->regs.reg[i_ + 32].how = REG_SAVED_OFFSET;\t\t\\\n-\t    (FS)->regs.reg[i_ + 32].loc.offset =\t\t\t\\\n-\t      (fpu_save_ + (i_ * 4)) - new_cfa_;\t\t\t\\\n-\t  }\t\t\t\t\t\t\t\t\\\n-      }\t\t\t\t\t\t\t\t\t\\\n-    /* Stick return address into %g0, same trick Alpha uses.  */\t\\\n-    (FS)->regs.reg[0].how = REG_SAVED_OFFSET;\t\t\t\t\\\n-    (FS)->regs.reg[0].loc.offset = this_cfa_+(regs_off_+4)-new_cfa_;\t\\\n-    (FS)->retaddr_column = 0;\t\t\t\t\t\t\\\n-    goto SUCCESS;\t\t\t\t\t\t\t\\\n-  } while (0)\n-#endif\n+#define MD_UNWIND_SUPPORT \"config/sparc/linux-unwind.h\""}, {"sha": "74d3b4df4073a53c34bbe0c56920b07783efdb28", "filename": "gcc/doc/tm.texi", "status": "modified", "additions": 9, "deletions": 4, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8662eb14c0ef6531d7086ec08f5e52b87c472ede/gcc%2Fdoc%2Ftm.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8662eb14c0ef6531d7086ec08f5e52b87c472ede/gcc%2Fdoc%2Ftm.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Ftm.texi?ref=8662eb14c0ef6531d7086ec08f5e52b87c472ede", "patch": "@@ -3094,7 +3094,12 @@ of bytes that the format occupies, @var{addr} is the @code{SYMBOL_REF}\n to be emitted.\n @end defmac\n \n-@defmac MD_FALLBACK_FRAME_STATE_FOR (@var{context}, @var{fs}, @var{success})\n+@defmac MD_UNWIND_SUPPORT\n+A string specifying a file to be #include'd in unwind-dw2.c.  The file\n+so included typically defines @code{MD_FALLBACK_FRAME_STATE_FOR}.\n+@end defmac\n+\n+@defmac MD_FALLBACK_FRAME_STATE_FOR (@var{context}, @var{fs})\n This macro allows the target to add cpu and operating system specific\n code to the call-frame unwinder for use when there is no unwind data\n available.  The most common reason to implement this macro is to unwind\n@@ -3105,9 +3110,9 @@ and @file{unwind-ia64.c}.  @var{context} is an @code{_Unwind_Context};\n @var{fs} is an @code{_Unwind_FrameState}.  Examine @code{context->ra}\n for the address of the code being executed and @code{context->cfa} for\n the stack pointer value.  If the frame can be decoded, the register save\n-addresses should be updated in @var{fs} and the macro should branch to\n-@var{success}.  If the frame cannot be decoded, the macro should do\n-nothing.\n+addresses should be updated in @var{fs} and the macro should evaluate to\n+@code{_URC_NO_REASON}.  If the frame cannot be decoded, the macro should\n+evaluate to @code{_URC_END_OF_STACK}.\n \n For proper signal handling in Java this macro is accompanied by\n @code{MAKE_THROW_FRAME}, defined in @file{libjava/include/*-signal.h} headers."}, {"sha": "eb36e207e2ff9068c744942595f9962c078e191f", "filename": "gcc/unwind-dw2.c", "status": "modified", "additions": 8, "deletions": 10, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8662eb14c0ef6531d7086ec08f5e52b87c472ede/gcc%2Funwind-dw2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8662eb14c0ef6531d7086ec08f5e52b87c472ede/gcc%2Funwind-dw2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Funwind-dw2.c?ref=8662eb14c0ef6531d7086ec08f5e52b87c472ede", "patch": "@@ -60,11 +60,6 @@\n #define DWARF_REG_TO_UNWIND_COLUMN(REGNO) (REGNO)\n #endif\n \n-/* A target can do some update context frobbing.  */\n-#ifndef MD_FROB_UPDATE_CONTEXT\n-#define MD_FROB_UPDATE_CONTEXT(CTX, FS) do { } while (0)\n-#endif\n-\n /* This is the register and unwind state for a particular frame.  This\n    provides the information necessary to unwind up past a frame and return\n    to its caller.  */\n@@ -252,6 +247,10 @@ _Unwind_GetTextRelBase (struct _Unwind_Context *context)\n   return (_Unwind_Ptr) context->bases.tbase;\n }\n #endif\n+\n+#ifdef MD_UNWIND_SUPPORT\n+#include MD_UNWIND_SUPPORT\n+#endif\n \f\n /* Extract any interesting information from the CIE for the translation\n    unit F belongs to.  Return a pointer to the byte after the augmentation,\n@@ -963,14 +962,11 @@ uw_frame_state_for (struct _Unwind_Context *context, _Unwind_FrameState *fs)\n   fde = _Unwind_Find_FDE (context->ra - 1, &context->bases);\n   if (fde == NULL)\n     {\n+#ifdef MD_FALLBACK_FRAME_STATE_FOR\n       /* Couldn't find frame unwind info for this function.  Try a\n \t target-specific fallback mechanism.  This will necessarily\n \t not provide a personality routine or LSDA.  */\n-#ifdef MD_FALLBACK_FRAME_STATE_FOR\n-      MD_FALLBACK_FRAME_STATE_FOR (context, fs, success);\n-      return _URC_END_OF_STACK;\n-    success:\n-      return _URC_NO_REASON;\n+      return MD_FALLBACK_FRAME_STATE_FOR (context, fs);\n #else\n       return _URC_END_OF_STACK;\n #endif\n@@ -1176,7 +1172,9 @@ uw_update_context_1 (struct _Unwind_Context *context, _Unwind_FrameState *fs)\n \tbreak;\n       }\n \n+#ifdef MD_FROB_UPDATE_CONTEXT\n   MD_FROB_UPDATE_CONTEXT (context, fs);\n+#endif\n }\n \n /* CONTEXT describes the unwind state for a frame, and FS describes the FDE"}]}