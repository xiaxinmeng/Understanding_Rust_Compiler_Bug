{"sha": "554a530ff81870098572832eed8ca00b3593bb41", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTU0YTUzMGZmODE4NzAwOTg1NzI4MzJlZWQ4Y2EwMGIzNTkzYmI0MQ==", "commit": {"author": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2019-07-20T11:21:42Z"}, "committer": {"name": "Jakub Jelinek", "email": "jakub@gcc.gnu.org", "date": "2019-07-20T11:21:42Z"}, "message": "tree.def (OMP_LOOP): New tree code.\n\n\t* tree.def (OMP_LOOP): New tree code.\n\t* tree-core.h (enum omp_clause_code): Add OMP_CLAUSE_BIND.\n\t(enum omp_clause_bind_kind): New enum.\n\t(struct tree_omp_clause): Add subcode.bind_kind.\n\t* tree.h (OMP_LOOP_CHECK): Rename to ...\n\t(OMP_LOOPING_CHECK): ... this.\n\t(OMP_FOR_BODY, OMP_FOR_CLAUSES, OMP_FOR_INIT, OMP_FOR_COND,\n\tOMP_FOR_INCR, OMP_FOR_PRE_BODY, OMP_FOR_ORIG_DECLS): Use\n\tOMP_LOOPING_CHECK instead of OMP_LOOP_CHECK.\n\t(OMP_CLAUSE_BIND_KIND): Define.\n\t* tree.c (omp_clause_num_ops, omp_clause_code_name): Add\n\tbind clause entries.\n\t(walk_tree_1): Handle OMP_CLAUSE_BIND.\n\t* tree-pretty-print.c (dump_omp_clause): Likewise.\n\t(dump_generic_node): Handle OMP_LOOP.\n\t* gimplify.c (enum omp_region_type): Add ORT_IMPLICIT_TARGET.\n\t(in_omp_construct): New variable.\n\t(is_gimple_stmt): Handle OMP_LOOP.\n\t(gimplify_scan_omp_clauses): For lastprivate don't set\n\tcheck_non_private if code == OMP_LOOP.  For reduction clause\n\ton OMP_LOOP combined with parallel or teams propagate as shared\n\ton the combined construct.  Handle OMP_CLAUSE_BIND.\n\t(gimplify_adjust_omp_clauses): Handle OMP_CLAUSE_BIND.\n\t(gimplify_omp_for): Pass OMP_LOOP instead of OMP_{FOR,DISTRIBUTE}\n\tfor constructs from a loop construct to gimplify_scan_omp_clauses.\n\tDon't predetermine iterator linear on OMP_SIMD from loop construct.\n\t(replace_reduction_placeholders, gimplify_omp_loop): New functions.\n\t(gimplify_omp_workshare): Use ORT_IMPLICIT_TARGET instead of trying\n\tto match the implicit ORT_TARGET construct around whole body.\n\tTemporarily clear in_omp_construct when processing body.\n\t(gimplify_expr): Handle OMP_LOOP.  For OMP_MASTER, OMP_TASKGROUP\n\tetc. temporarily set in_omp_construct when processing body.\n\t(gimplify_body): Create ORT_IMPLICIT_TARGET instead of ORT_TARGET.\n\t* omp-low.c (struct omp_context): Add loop_p.\n\t(build_outer_var_ref): Treat ctx->loop_p similarly to simd construct\n\tin that the original var might be private.\n\t(scan_sharing_clauses): Handle OMP_CLAUSE_BIND.\n\t(check_omp_nesting_restrictions): Adjust nesting restrictions for\n\taddition of loop construct.\n\t(scan_omp_1_stmt): Allow setjmp inside of loop construct.\ngcc/c-family/\n\t* c-pragma.h (enum pragma_kind): Add PRAGMA_OMP_LOOP.\n\t(enum pragma_omp_clause): Add PRAGMA_OMP_CLAUSE_BIND.\n\t* c-pragma.c (omp_pragmas_simd): Add PRAGMA_OMP_LOOP entry.\n\t* c-common.h (enum c_omp_clause_split): Add C_OMP_CLAUSE_SPLIT_LOOP.\n\t* c-omp.c (c_omp_split_clauses): Add support for 4 new combined\n\tconstructs with the loop construct.\ngcc/c/\n\t* c-parser.c (c_parser_omp_clause_name): Handle bind clause.\n\t(c_parser_omp_clause_bind): New function.\n\t(c_parser_omp_all_clauses): Handle PRAGMA_OMP_CLAUSE_BIND.\n\t(OMP_LOOP_CLAUSE_MASK): Define.\n\t(c_parser_omp_loop): New function.\n\t(c_parser_omp_parallel, c_parser_omp_teams): Handle parsing of\n\tloop combined with parallel or teams.\n\t(c_parser_omp_construct): Handle PRAGMA_OMP_LOOP.\n\t* c-typeck.c (c_finish_omp_clauses): Handle OMP_CLAUSE_BIND.\ngcc/cp/\n\t* cp-tree.h (OMP_FOR_GIMPLIFYING_P): Use OMP_LOOPING_CHECK\n\tinstead of OMP_LOOP_CHECK.\n\t* parser.c (cp_parser_omp_clause_name): Handle bind clause.\n\t(cp_parser_omp_clause_bind): New function.\n\t(cp_parser_omp_all_clauses): Handle PRAGMA_OMP_CLAUSE_BIND.\n\t(OMP_LOOP_CLAUSE_MASK): Define.\n\t(cp_parser_omp_loop): New function.\n\t(cp_parser_omp_parallel, cp_parser_omp_teams): Handle parsing of\n\tloop combined with parallel or teams.\n\t(cp_parser_omp_construct): Handle PRAGMA_OMP_LOOP.\n\t(cp_parser_pragma): Likewise.\n\t* pt.c (tsubst_expr): Handle OMP_LOOP.\n\t* semantics.c (finish_omp_clauses): Handle OMP_CLAUSE_BIND.\ngcc/testsuite/\n\t* c-c++-common/gomp/cancel-1.c: Adjust expected diagnostic wording.\n\t* c-c++-common/gomp/clauses-1.c (foo, baz, bar): Add order(concurrent)\n\tclause where allowed.  Add combined constructs with loop with all\n\tpossible clauses.\n\t(qux): New function.\n\t* c-c++-common/gomp/loop-1.c: New test.\n\t* c-c++-common/gomp/loop-2.c: New test.\n\t* c-c++-common/gomp/loop-3.c: New test.\n\t* c-c++-common/gomp/loop-4.c: New test.\n\t* c-c++-common/gomp/loop-5.c: New test.\n\t* c-c++-common/gomp/order-3.c: Adjust expected diagnostic wording.\n\t* c-c++-common/gomp/simd-setjmp-1.c: New test.\n\t* c-c++-common/gomp/teams-2.c: Adjust expected diagnostic wording.\nlibgomp/\n\t* testsuite/libgomp.c-c++-common/loop-1.c: New test.\n\nFrom-SVN: r273621", "tree": {"sha": "7d7930d120a4adebe92eebe4c63a801388f5a6a5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/7d7930d120a4adebe92eebe4c63a801388f5a6a5"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/554a530ff81870098572832eed8ca00b3593bb41", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/554a530ff81870098572832eed8ca00b3593bb41", "html_url": "https://github.com/Rust-GCC/gccrs/commit/554a530ff81870098572832eed8ca00b3593bb41", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/554a530ff81870098572832eed8ca00b3593bb41/comments", "author": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "b6339213ff68ac5a87b7fdda878f26b52d801b76", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b6339213ff68ac5a87b7fdda878f26b52d801b76", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b6339213ff68ac5a87b7fdda878f26b52d801b76"}], "stats": {"total": 2182, "additions": 2020, "deletions": 162}, "files": [{"sha": "537799efa3e6dc9a2f7662a8ca5730973391070b", "filename": "gcc/ChangeLog", "status": "modified", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/554a530ff81870098572832eed8ca00b3593bb41/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/554a530ff81870098572832eed8ca00b3593bb41/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=554a530ff81870098572832eed8ca00b3593bb41", "patch": "@@ -1,5 +1,46 @@\n 2019-07-20  Jakub Jelinek  <jakub@redhat.com>\n \n+\t* tree.def (OMP_LOOP): New tree code.\n+\t* tree-core.h (enum omp_clause_code): Add OMP_CLAUSE_BIND.\n+\t(enum omp_clause_bind_kind): New enum.\n+\t(struct tree_omp_clause): Add subcode.bind_kind.\n+\t* tree.h (OMP_LOOP_CHECK): Rename to ...\n+\t(OMP_LOOPING_CHECK): ... this.\n+\t(OMP_FOR_BODY, OMP_FOR_CLAUSES, OMP_FOR_INIT, OMP_FOR_COND,\n+\tOMP_FOR_INCR, OMP_FOR_PRE_BODY, OMP_FOR_ORIG_DECLS): Use\n+\tOMP_LOOPING_CHECK instead of OMP_LOOP_CHECK.\n+\t(OMP_CLAUSE_BIND_KIND): Define.\n+\t* tree.c (omp_clause_num_ops, omp_clause_code_name): Add\n+\tbind clause entries.\n+\t(walk_tree_1): Handle OMP_CLAUSE_BIND.\n+\t* tree-pretty-print.c (dump_omp_clause): Likewise.\n+\t(dump_generic_node): Handle OMP_LOOP.\n+\t* gimplify.c (enum omp_region_type): Add ORT_IMPLICIT_TARGET.\n+\t(in_omp_construct): New variable.\n+\t(is_gimple_stmt): Handle OMP_LOOP.\n+\t(gimplify_scan_omp_clauses): For lastprivate don't set\n+\tcheck_non_private if code == OMP_LOOP.  For reduction clause\n+\ton OMP_LOOP combined with parallel or teams propagate as shared\n+\ton the combined construct.  Handle OMP_CLAUSE_BIND.\n+\t(gimplify_adjust_omp_clauses): Handle OMP_CLAUSE_BIND.\n+\t(gimplify_omp_for): Pass OMP_LOOP instead of OMP_{FOR,DISTRIBUTE}\n+\tfor constructs from a loop construct to gimplify_scan_omp_clauses.\n+\tDon't predetermine iterator linear on OMP_SIMD from loop construct.\n+\t(replace_reduction_placeholders, gimplify_omp_loop): New functions.\n+\t(gimplify_omp_workshare): Use ORT_IMPLICIT_TARGET instead of trying\n+\tto match the implicit ORT_TARGET construct around whole body.\n+\tTemporarily clear in_omp_construct when processing body.\n+\t(gimplify_expr): Handle OMP_LOOP.  For OMP_MASTER, OMP_TASKGROUP\n+\tetc. temporarily set in_omp_construct when processing body.\n+\t(gimplify_body): Create ORT_IMPLICIT_TARGET instead of ORT_TARGET.\n+\t* omp-low.c (struct omp_context): Add loop_p.\n+\t(build_outer_var_ref): Treat ctx->loop_p similarly to simd construct\n+\tin that the original var might be private.\n+\t(scan_sharing_clauses): Handle OMP_CLAUSE_BIND.\n+\t(check_omp_nesting_restrictions): Adjust nesting restrictions for\n+\taddition of loop construct.\n+\t(scan_omp_1_stmt): Allow setjmp inside of loop construct.\n+\n \t* omp-low.c (lower_rec_input_clauses): Don't force simd arrays for\n \tlastprivate non-addressable iterator of a collapse(1) simd.\n "}, {"sha": "e6452542bcc961374b901248494e094033216a9c", "filename": "gcc/c-family/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/554a530ff81870098572832eed8ca00b3593bb41/gcc%2Fc-family%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/554a530ff81870098572832eed8ca00b3593bb41/gcc%2Fc-family%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2FChangeLog?ref=554a530ff81870098572832eed8ca00b3593bb41", "patch": "@@ -1,3 +1,12 @@\n+2019-07-20  Jakub Jelinek  <jakub@redhat.com>\n+\n+\t* c-pragma.h (enum pragma_kind): Add PRAGMA_OMP_LOOP.\n+\t(enum pragma_omp_clause): Add PRAGMA_OMP_CLAUSE_BIND.\n+\t* c-pragma.c (omp_pragmas_simd): Add PRAGMA_OMP_LOOP entry.\n+\t* c-common.h (enum c_omp_clause_split): Add C_OMP_CLAUSE_SPLIT_LOOP.\n+\t* c-omp.c (c_omp_split_clauses): Add support for 4 new combined\n+\tconstructs with the loop construct.\n+\n 2019-07-13  Jakub Jelinek  <jakub@redhat.com>\n \n \tPR c/91149"}, {"sha": "117d729091a502547bdf56cdfddae5d0c39cd05c", "filename": "gcc/c-family/c-common.h", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/554a530ff81870098572832eed8ca00b3593bb41/gcc%2Fc-family%2Fc-common.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/554a530ff81870098572832eed8ca00b3593bb41/gcc%2Fc-family%2Fc-common.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc-common.h?ref=554a530ff81870098572832eed8ca00b3593bb41", "patch": "@@ -1148,7 +1148,8 @@ enum c_omp_clause_split\n   C_OMP_CLAUSE_SPLIT_SIMD,\n   C_OMP_CLAUSE_SPLIT_COUNT,\n   C_OMP_CLAUSE_SPLIT_SECTIONS = C_OMP_CLAUSE_SPLIT_FOR,\n-  C_OMP_CLAUSE_SPLIT_TASKLOOP = C_OMP_CLAUSE_SPLIT_FOR\n+  C_OMP_CLAUSE_SPLIT_TASKLOOP = C_OMP_CLAUSE_SPLIT_FOR,\n+  C_OMP_CLAUSE_SPLIT_LOOP = C_OMP_CLAUSE_SPLIT_FOR\n };\n \n enum c_omp_region_type"}, {"sha": "10f7c4ed0c3ec6297e3749bf9756dc278da99704", "filename": "gcc/c-family/c-omp.c", "status": "modified", "additions": 39, "deletions": 17, "changes": 56, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/554a530ff81870098572832eed8ca00b3593bb41/gcc%2Fc-family%2Fc-omp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/554a530ff81870098572832eed8ca00b3593bb41/gcc%2Fc-family%2Fc-omp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc-omp.c?ref=554a530ff81870098572832eed8ca00b3593bb41", "patch": "@@ -1263,7 +1263,7 @@ c_oacc_split_loop_clauses (tree clauses, tree *not_loop_clauses,\n }\n \n /* This function attempts to split or duplicate clauses for OpenMP\n-   combined/composite constructs.  Right now there are 26 different\n+   combined/composite constructs.  Right now there are 30 different\n    constructs.  CODE is the innermost construct in the combined construct,\n    and MASK allows to determine which constructs are combined together,\n    as every construct has at least one clause that no other construct\n@@ -1278,24 +1278,28 @@ c_oacc_split_loop_clauses (tree clauses, tree *not_loop_clauses,\n    #pragma omp master taskloop simd\n    #pragma omp parallel for\n    #pragma omp parallel for simd\n+   #pragma omp parallel loop\n    #pragma omp parallel master\n    #pragma omp parallel master taskloop\n    #pragma omp parallel master taskloop simd\n    #pragma omp parallel sections\n    #pragma omp target parallel\n    #pragma omp target parallel for\n    #pragma omp target parallel for simd\n+   #pragma omp target parallel loop\n    #pragma omp target teams\n    #pragma omp target teams distribute\n    #pragma omp target teams distribute parallel for\n    #pragma omp target teams distribute parallel for simd\n    #pragma omp target teams distribute simd\n+   #pragma omp target teams loop\n    #pragma omp target simd\n    #pragma omp taskloop simd\n    #pragma omp teams distribute\n    #pragma omp teams distribute parallel for\n    #pragma omp teams distribute parallel for simd\n-   #pragma omp teams distribute simd  */\n+   #pragma omp teams distribute simd\n+   #pragma omp teams loop  */\n \n void\n c_omp_split_clauses (location_t loc, enum tree_code code,\n@@ -1375,7 +1379,11 @@ c_omp_split_clauses (location_t loc, enum tree_code code,\n \tcase OMP_CLAUSE_PRIORITY:\n \t  s = C_OMP_CLAUSE_SPLIT_TASKLOOP;\n \t  break;\n-\t/* Duplicate this to all of taskloop, distribute, for and simd.  */\n+\tcase OMP_CLAUSE_BIND:\n+\t  s = C_OMP_CLAUSE_SPLIT_LOOP;\n+\t  break;\n+\t/* Duplicate this to all of taskloop, distribute, for, simd and\n+\t   loop.  */\n \tcase OMP_CLAUSE_COLLAPSE:\n \t  if (code == OMP_SIMD)\n \t    {\n@@ -1418,6 +1426,8 @@ c_omp_split_clauses (location_t loc, enum tree_code code,\n \t  else if ((mask & (OMP_CLAUSE_MASK_1 << PRAGMA_OMP_CLAUSE_NOGROUP))\n \t\t   != 0)\n \t    s = C_OMP_CLAUSE_SPLIT_TASKLOOP;\n+\t  else if (code == OMP_LOOP)\n+\t    s = C_OMP_CLAUSE_SPLIT_LOOP;\n \t  else\n \t    s = C_OMP_CLAUSE_SPLIT_DISTRIBUTE;\n \t  break;\n@@ -1435,12 +1445,13 @@ c_omp_split_clauses (location_t loc, enum tree_code code,\n \t    case OMP_TEAMS: s = C_OMP_CLAUSE_SPLIT_TEAMS; break;\n \t    case OMP_MASTER: s = C_OMP_CLAUSE_SPLIT_PARALLEL; break;\n \t    case OMP_TASKLOOP: s = C_OMP_CLAUSE_SPLIT_TASKLOOP; break;\n+\t    case OMP_LOOP: s = C_OMP_CLAUSE_SPLIT_LOOP; break;\n \t    default: gcc_unreachable ();\n \t    }\n \t  break;\n \t/* Firstprivate clause is supported on all constructs but\n-\t   simd and master.  Put it on the outermost of those and duplicate on\n-\t   teams and parallel.  */\n+\t   simd, master and loop.  Put it on the outermost of those and\n+\t   duplicate on teams and parallel.  */\n \tcase OMP_CLAUSE_FIRSTPRIVATE:\n \t  if ((mask & (OMP_CLAUSE_MASK_1 << PRAGMA_OMP_CLAUSE_MAP))\n \t      != 0)\n@@ -1486,7 +1497,7 @@ c_omp_split_clauses (location_t loc, enum tree_code code,\n \t\ts = C_OMP_CLAUSE_SPLIT_TASKLOOP;\n \t      else\n \t\t/* This must be\n-\t\t   #pragma omp parallel{, for{, simd}, sections}\n+\t\t   #pragma omp parallel{, for{, simd}, sections,loop}\n \t\t   or\n \t\t   #pragma omp target parallel.  */\n \t\ts = C_OMP_CLAUSE_SPLIT_PARALLEL;\n@@ -1495,10 +1506,11 @@ c_omp_split_clauses (location_t loc, enum tree_code code,\n \t\t   != 0)\n \t    {\n \t      /* This must be one of\n-\t\t #pragma omp {,target }teams distribute\n+\t\t #pragma omp {,target }teams {distribute,loop}\n \t\t #pragma omp target teams\n \t\t #pragma omp {,target }teams distribute simd.  */\n \t      gcc_assert (code == OMP_DISTRIBUTE\n+\t\t\t  || code == OMP_LOOP\n \t\t\t  || code == OMP_TEAMS\n \t\t\t  || code == OMP_SIMD);\n \t      s = C_OMP_CLAUSE_SPLIT_TEAMS;\n@@ -1526,9 +1538,9 @@ c_omp_split_clauses (location_t loc, enum tree_code code,\n \t      s = C_OMP_CLAUSE_SPLIT_FOR;\n \t    }\n \t  break;\n-\t/* Lastprivate is allowed on distribute, for, sections, taskloop and\n-\t   simd.  In parallel {for{, simd},sections} we actually want to put\n-\t   it on parallel rather than for or sections.  */\n+\t/* Lastprivate is allowed on distribute, for, sections, taskloop, loop\n+\t   and simd.  In parallel {for{, simd},sections} we actually want to\n+\t   put it on parallel rather than for or sections.  */\n \tcase OMP_CLAUSE_LASTPRIVATE:\n \t  if (code == OMP_DISTRIBUTE)\n \t    {\n@@ -1560,6 +1572,11 @@ c_omp_split_clauses (location_t loc, enum tree_code code,\n \t      s = C_OMP_CLAUSE_SPLIT_TASKLOOP;\n \t      break;\n \t    }\n+\t  if (code == OMP_LOOP)\n+\t    {\n+\t      s = C_OMP_CLAUSE_SPLIT_LOOP;\n+\t      break;\n+\t    }\n \t  gcc_assert (code == OMP_SIMD);\n \t  if ((mask & (OMP_CLAUSE_MASK_1 << PRAGMA_OMP_CLAUSE_SCHEDULE)) != 0)\n \t    {\n@@ -1632,7 +1649,7 @@ c_omp_split_clauses (location_t loc, enum tree_code code,\n \t    }\n \t  s = C_OMP_CLAUSE_SPLIT_PARALLEL;\n \t  break;\n-\t/* order clauses are allowed on for and simd.  */\n+\t/* order clauses are allowed on for, simd and loop.  */\n \tcase OMP_CLAUSE_ORDER:\n \t  if ((mask & (OMP_CLAUSE_MASK_1 << PRAGMA_OMP_CLAUSE_SCHEDULE)) != 0)\n \t    {\n@@ -1647,22 +1664,24 @@ c_omp_split_clauses (location_t loc, enum tree_code code,\n \t      else\n \t\ts = C_OMP_CLAUSE_SPLIT_FOR;\n \t    }\n+\t  else if (code == OMP_LOOP)\n+\t    s = C_OMP_CLAUSE_SPLIT_LOOP;\n \t  else\n \t    s = C_OMP_CLAUSE_SPLIT_SIMD;\n \t  break;\n-\t/* Reduction is allowed on simd, for, parallel, sections, taskloop\n-\t   and teams.  Duplicate it on all of them, but omit on for or\n+\t/* Reduction is allowed on simd, for, parallel, sections, taskloop,\n+\t   teams and loop.  Duplicate it on all of them, but omit on for or\n \t   sections if parallel is present (unless inscan, in that case\n-\t   omit on parallel).  If taskloop is combined with\n+\t   omit on parallel).  If taskloop or loop is combined with\n \t   parallel, omit it on parallel.  */\n \tcase OMP_CLAUSE_REDUCTION:\n \t  if (OMP_CLAUSE_REDUCTION_TASK (clauses))\n \t    {\n-\t      if (code == OMP_SIMD /* || code == OMP_LOOP */)\n+\t      if (code == OMP_SIMD || code == OMP_LOOP)\n \t\t{\n \t\t  error_at (OMP_CLAUSE_LOCATION (clauses),\n \t\t\t    \"invalid %<task%> reduction modifier on construct \"\n-\t\t\t    \"combined with %<simd%>\" /* or %<loop%> */);\n+\t\t\t    \"combined with %<simd%> or %<loop%>\");\n \t\t  OMP_CLAUSE_REDUCTION_TASK (clauses) = 0;\n \t\t}\n \t      else if (code != OMP_SECTIONS\n@@ -1739,6 +1758,8 @@ c_omp_split_clauses (location_t loc, enum tree_code code,\n \t    s = C_OMP_CLAUSE_SPLIT_PARALLEL;\n \t  else if (code == OMP_TASKLOOP)\n \t    s = C_OMP_CLAUSE_SPLIT_TASKLOOP;\n+\t  else if (code == OMP_LOOP)\n+\t    s = C_OMP_CLAUSE_SPLIT_LOOP;\n \t  else if (code == OMP_SIMD)\n \t    {\n \t      if ((mask & (OMP_CLAUSE_MASK_1 << PRAGMA_OMP_CLAUSE_NOGROUP))\n@@ -1930,7 +1951,8 @@ c_omp_split_clauses (location_t loc, enum tree_code code,\n     gcc_assert (cclauses[C_OMP_CLAUSE_SPLIT_PARALLEL] == NULL_TREE);\n   if ((mask & ((OMP_CLAUSE_MASK_1 << PRAGMA_OMP_CLAUSE_SCHEDULE)\n \t       | (OMP_CLAUSE_MASK_1 << PRAGMA_OMP_CLAUSE_NOGROUP))) == 0\n-      && code != OMP_SECTIONS)\n+      && code != OMP_SECTIONS\n+      && code != OMP_LOOP)\n     gcc_assert (cclauses[C_OMP_CLAUSE_SPLIT_FOR] == NULL_TREE);\n   if (code != OMP_SIMD)\n     gcc_assert (cclauses[C_OMP_CLAUSE_SPLIT_SIMD] == NULL_TREE);"}, {"sha": "9fee84b223830e03f7eadb18d113bd1a113341a9", "filename": "gcc/c-family/c-pragma.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/554a530ff81870098572832eed8ca00b3593bb41/gcc%2Fc-family%2Fc-pragma.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/554a530ff81870098572832eed8ca00b3593bb41/gcc%2Fc-family%2Fc-pragma.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc-pragma.c?ref=554a530ff81870098572832eed8ca00b3593bb41", "patch": "@@ -1318,6 +1318,7 @@ static const struct omp_pragma_def omp_pragmas_simd[] = {\n   { \"declare\", PRAGMA_OMP_DECLARE },\n   { \"distribute\", PRAGMA_OMP_DISTRIBUTE },\n   { \"for\", PRAGMA_OMP_FOR },\n+  { \"loop\", PRAGMA_OMP_LOOP },\n   { \"ordered\", PRAGMA_OMP_ORDERED },\n   { \"parallel\", PRAGMA_OMP_PARALLEL },\n   { \"scan\", PRAGMA_OMP_SCAN },"}, {"sha": "e8a509f70733fc7af7e21a6919eb6430e7f3b85d", "filename": "gcc/c-family/c-pragma.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/554a530ff81870098572832eed8ca00b3593bb41/gcc%2Fc-family%2Fc-pragma.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/554a530ff81870098572832eed8ca00b3593bb41/gcc%2Fc-family%2Fc-pragma.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc-pragma.h?ref=554a530ff81870098572832eed8ca00b3593bb41", "patch": "@@ -52,6 +52,7 @@ enum pragma_kind {\n   PRAGMA_OMP_END_DECLARE_TARGET,\n   PRAGMA_OMP_FLUSH,\n   PRAGMA_OMP_FOR,\n+  PRAGMA_OMP_LOOP,\n   PRAGMA_OMP_MASTER,\n   PRAGMA_OMP_ORDERED,\n   PRAGMA_OMP_PARALLEL,\n@@ -84,6 +85,7 @@ enum pragma_omp_clause {\n   PRAGMA_OMP_CLAUSE_NONE = 0,\n \n   PRAGMA_OMP_CLAUSE_ALIGNED,\n+  PRAGMA_OMP_CLAUSE_BIND,\n   PRAGMA_OMP_CLAUSE_COLLAPSE,\n   PRAGMA_OMP_CLAUSE_COPYIN,\n   PRAGMA_OMP_CLAUSE_COPYPRIVATE,"}, {"sha": "a75f0d80955012e59a497110bd4d640810c91f5b", "filename": "gcc/c/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/554a530ff81870098572832eed8ca00b3593bb41/gcc%2Fc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/554a530ff81870098572832eed8ca00b3593bb41/gcc%2Fc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc%2FChangeLog?ref=554a530ff81870098572832eed8ca00b3593bb41", "patch": "@@ -1,3 +1,15 @@\n+2019-07-20  Jakub Jelinek  <jakub@redhat.com>\n+\n+\t* c-parser.c (c_parser_omp_clause_name): Handle bind clause.\n+\t(c_parser_omp_clause_bind): New function.\n+\t(c_parser_omp_all_clauses): Handle PRAGMA_OMP_CLAUSE_BIND.\n+\t(OMP_LOOP_CLAUSE_MASK): Define.\n+\t(c_parser_omp_loop): New function.\n+\t(c_parser_omp_parallel, c_parser_omp_teams): Handle parsing of\n+\tloop combined with parallel or teams.\n+\t(c_parser_omp_construct): Handle PRAGMA_OMP_LOOP.\n+\t* c-typeck.c (c_finish_omp_clauses): Handle OMP_CLAUSE_BIND.\n+\n 2019-07-18  Richard Sandiford  <richard.sandiford@arm.com>\n \n \tPR c/53633"}, {"sha": "67210493c7e3bb5f52fd77943ae9d05325abe87f", "filename": "gcc/c/c-parser.c", "status": "modified", "additions": 140, "deletions": 3, "changes": 143, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/554a530ff81870098572832eed8ca00b3593bb41/gcc%2Fc%2Fc-parser.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/554a530ff81870098572832eed8ca00b3593bb41/gcc%2Fc%2Fc-parser.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc%2Fc-parser.c?ref=554a530ff81870098572832eed8ca00b3593bb41", "patch": "@@ -11688,6 +11688,10 @@ c_parser_omp_clause_name (c_parser *parser)\n \t  else if (!strcmp (\"async\", p))\n \t    result = PRAGMA_OACC_CLAUSE_ASYNC;\n \t  break;\n+\tcase 'b':\n+\t  if (!strcmp (\"bind\", p))\n+\t    result = PRAGMA_OMP_CLAUSE_BIND;\n+\t  break;\n \tcase 'c':\n \t  if (!strcmp (\"collapse\", p))\n \t    result = PRAGMA_OMP_CLAUSE_COLLAPSE;\n@@ -13507,6 +13511,45 @@ c_parser_omp_clause_order (c_parser *parser, tree list)\n }\n \n \n+/* OpenMP 5.0:\n+   bind ( teams | parallel | thread ) */\n+\n+static tree\n+c_parser_omp_clause_bind (c_parser *parser, tree list)\n+{\n+  location_t loc = c_parser_peek_token (parser)->location;\n+  tree c;\n+  const char *p;\n+  enum omp_clause_bind_kind kind = OMP_CLAUSE_BIND_THREAD;\n+\n+  matching_parens parens;\n+  if (!parens.require_open (parser))\n+    return list;\n+  if (!c_parser_next_token_is (parser, CPP_NAME))\n+    {\n+     invalid:\n+      c_parser_error (parser,\n+\t\t      \"expected %<teams%>, %<parallel%> or %<thread%>\");\n+      parens.skip_until_found_close (parser);\n+      return list;\n+    }\n+  p = IDENTIFIER_POINTER (c_parser_peek_token (parser)->value);\n+  if (strcmp (p, \"teams\") == 0)\n+    kind = OMP_CLAUSE_BIND_TEAMS;\n+  else if (strcmp (p, \"parallel\") == 0)\n+    kind = OMP_CLAUSE_BIND_PARALLEL;\n+  else if (strcmp (p, \"thread\") != 0)\n+    goto invalid;\n+  c_parser_consume_token (parser);\n+  parens.skip_until_found_close (parser);\n+  /* check_no_duplicate_clause (list, OMP_CLAUSE_BIND, \"bind\"); */\n+  c = build_omp_clause (loc, OMP_CLAUSE_BIND);\n+  OMP_CLAUSE_BIND_KIND (c) = kind;\n+  OMP_CLAUSE_CHAIN (c) = list;\n+  return c;\n+}\n+\n+\n /* OpenMP 2.5:\n    ordered\n \n@@ -15066,6 +15109,10 @@ c_parser_omp_all_clauses (c_parser *parser, omp_clause_mask mask,\n \n       switch (c_kind)\n \t{\n+\tcase PRAGMA_OMP_CLAUSE_BIND:\n+\t  clauses = c_parser_omp_clause_bind (parser, clauses);\n+\t  c_name = \"bind\";\n+\t  break;\n \tcase PRAGMA_OMP_CLAUSE_COLLAPSE:\n \t  clauses = c_parser_omp_clause_collapse (parser, clauses);\n \t  c_name = \"collapse\";\n@@ -17248,6 +17295,46 @@ omp_split_clauses (location_t loc, enum tree_code code,\n       cclauses[i] = c_finish_omp_clauses (cclauses[i], C_ORT_OMP);\n }\n \n+/* OpenMP 5.0:\n+   #pragma omp loop loop-clause[optseq] new-line\n+     for-loop\n+\n+   LOC is the location of the #pragma token.\n+*/\n+\n+#define OMP_LOOP_CLAUSE_MASK\t\t\t\t\t\\\n+\t( (OMP_CLAUSE_MASK_1 << PRAGMA_OMP_CLAUSE_PRIVATE)\t\\\n+\t| (OMP_CLAUSE_MASK_1 << PRAGMA_OMP_CLAUSE_LASTPRIVATE)\t\\\n+\t| (OMP_CLAUSE_MASK_1 << PRAGMA_OMP_CLAUSE_REDUCTION)\t\\\n+\t| (OMP_CLAUSE_MASK_1 << PRAGMA_OMP_CLAUSE_COLLAPSE)\t\\\n+\t| (OMP_CLAUSE_MASK_1 << PRAGMA_OMP_CLAUSE_BIND)\t\t\\\n+\t| (OMP_CLAUSE_MASK_1 << PRAGMA_OMP_CLAUSE_ORDER))\n+\n+static tree\n+c_parser_omp_loop (location_t loc, c_parser *parser,\n+\t\t   char *p_name, omp_clause_mask mask, tree *cclauses,\n+\t\t   bool *if_p)\n+{\n+  tree block, clauses, ret;\n+\n+  strcat (p_name, \" loop\");\n+  mask |= OMP_LOOP_CLAUSE_MASK;\n+\n+  clauses = c_parser_omp_all_clauses (parser, mask, p_name, cclauses == NULL);\n+  if (cclauses)\n+    {\n+      omp_split_clauses (loc, OMP_LOOP, mask, clauses, cclauses);\n+      clauses = cclauses[C_OMP_CLAUSE_SPLIT_LOOP];\n+    }\n+\n+  block = c_begin_compound_stmt (true);\n+  ret = c_parser_omp_for_loop (loc, parser, OMP_LOOP, clauses, cclauses, if_p);\n+  block = c_end_compound_stmt (loc, block, true);\n+  add_stmt (block);\n+\n+  return ret;\n+}\n+\n /* OpenMP 4.0:\n    #pragma omp simd simd-clause[optseq] new-line\n      for-loop\n@@ -17713,10 +17800,10 @@ c_parser_omp_parallel (location_t loc, c_parser *parser,\n       c_parser_skip_to_pragma_eol (parser);\n       return NULL_TREE;\n     }\n-  else if (cclauses == NULL && c_parser_next_token_is (parser, CPP_NAME))\n+  else if (c_parser_next_token_is (parser, CPP_NAME))\n     {\n       const char *p = IDENTIFIER_POINTER (c_parser_peek_token (parser)->value);\n-      if (strcmp (p, \"master\") == 0)\n+      if (cclauses == NULL && strcmp (p, \"master\") == 0)\n \t{\n \t  tree cclauses_buf[C_OMP_CLAUSE_SPLIT_COUNT];\n \t  cclauses = cclauses_buf;\n@@ -17736,12 +17823,34 @@ c_parser_omp_parallel (location_t loc, c_parser *parser,\n \t    return ret;\n \t  return stmt;\n \t}\n+      else if (strcmp (p, \"loop\") == 0)\n+\t{\n+\t  tree cclauses_buf[C_OMP_CLAUSE_SPLIT_COUNT];\n+\t  if (cclauses == NULL)\n+\t    cclauses = cclauses_buf;\n+\n+\t  c_parser_consume_token (parser);\n+\t  if (!flag_openmp)  /* flag_openmp_simd  */\n+\t    return c_parser_omp_loop (loc, parser, p_name, mask, cclauses,\n+\t\t\t\t      if_p);\n+\t  block = c_begin_omp_parallel ();\n+\t  tree ret = c_parser_omp_loop (loc, parser, p_name, mask, cclauses,\n+\t\t\t\t\tif_p);\n+\t  stmt\n+\t    = c_finish_omp_parallel (loc,\n+\t\t\t\t     cclauses[C_OMP_CLAUSE_SPLIT_PARALLEL],\n+\t\t\t\t     block);\n+\t  if (ret == NULL_TREE)\n+\t    return ret;\n+\t  OMP_PARALLEL_COMBINED (stmt) = 1;\n+\t  return stmt;\n+\t}\n       else if (!flag_openmp)  /* flag_openmp_simd  */\n \t{\n \t  c_parser_skip_to_pragma_eol (parser, false);\n \t  return NULL_TREE;\n \t}\n-      else if (strcmp (p, \"sections\") == 0)\n+      else if (cclauses == NULL && strcmp (p, \"sections\") == 0)\n \t{\n \t  tree cclauses_buf[C_OMP_CLAUSE_SPLIT_COUNT];\n \t  cclauses = cclauses_buf;\n@@ -18121,6 +18230,30 @@ c_parser_omp_teams (location_t loc, c_parser *parser,\n \t  SET_EXPR_LOCATION (ret, loc);\n \t  return add_stmt (ret);\n \t}\n+      else if (strcmp (p, \"loop\") == 0)\n+\t{\n+\t  tree cclauses_buf[C_OMP_CLAUSE_SPLIT_COUNT];\n+\t  if (cclauses == NULL)\n+\t    cclauses = cclauses_buf;\n+\n+\t  c_parser_consume_token (parser);\n+\t  if (!flag_openmp)  /* flag_openmp_simd  */\n+\t    return c_parser_omp_loop (loc, parser, p_name, mask, cclauses,\n+\t\t\t\t      if_p);\n+\t  block = c_begin_omp_parallel ();\n+\t  ret = c_parser_omp_loop (loc, parser, p_name, mask, cclauses, if_p);\n+\t  block = c_end_compound_stmt (loc, block, true);\n+\t  if (ret == NULL)\n+\t    return ret;\n+\t  clauses = cclauses[C_OMP_CLAUSE_SPLIT_TEAMS];\n+\t  ret = make_node (OMP_TEAMS);\n+\t  TREE_TYPE (ret) = void_type_node;\n+\t  OMP_TEAMS_CLAUSES (ret) = clauses;\n+\t  OMP_TEAMS_BODY (ret) = block;\n+\t  OMP_TEAMS_COMBINED (ret) = 1;\n+\t  SET_EXPR_LOCATION (ret, loc);\n+\t  return add_stmt (ret);\n+\t}\n     }\n   if (!flag_openmp)  /* flag_openmp_simd  */\n     {\n@@ -19670,6 +19803,10 @@ c_parser_omp_construct (c_parser *parser, bool *if_p)\n       strcpy (p_name, \"#pragma omp\");\n       stmt = c_parser_omp_for (loc, parser, p_name, mask, NULL, if_p);\n       break;\n+    case PRAGMA_OMP_LOOP:\n+      strcpy (p_name, \"#pragma omp\");\n+      stmt = c_parser_omp_loop (loc, parser, p_name, mask, NULL, if_p);\n+      break;\n     case PRAGMA_OMP_MASTER:\n       strcpy (p_name, \"#pragma omp\");\n       stmt = c_parser_omp_master (loc, parser, p_name, mask, NULL, if_p);"}, {"sha": "9a1a9106a40bd008549fe57f09b832bca05077e2", "filename": "gcc/c/c-typeck.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/554a530ff81870098572832eed8ca00b3593bb41/gcc%2Fc%2Fc-typeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/554a530ff81870098572832eed8ca00b3593bb41/gcc%2Fc%2Fc-typeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc%2Fc-typeck.c?ref=554a530ff81870098572832eed8ca00b3593bb41", "patch": "@@ -14674,6 +14674,7 @@ c_finish_omp_clauses (tree clauses, enum c_omp_region_type ort)\n \tcase OMP_CLAUSE_SIMD:\n \tcase OMP_CLAUSE_HINT:\n \tcase OMP_CLAUSE_DEFAULTMAP:\n+\tcase OMP_CLAUSE_BIND:\n \tcase OMP_CLAUSE_NUM_GANGS:\n \tcase OMP_CLAUSE_NUM_WORKERS:\n \tcase OMP_CLAUSE_VECTOR_LENGTH:"}, {"sha": "c776243d973e44a7db91641470eae9dc54fe7d82", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/554a530ff81870098572832eed8ca00b3593bb41/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/554a530ff81870098572832eed8ca00b3593bb41/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=554a530ff81870098572832eed8ca00b3593bb41", "patch": "@@ -1,3 +1,19 @@\n+2019-07-20  Jakub Jelinek  <jakub@redhat.com>\n+\n+\t* cp-tree.h (OMP_FOR_GIMPLIFYING_P): Use OMP_LOOPING_CHECK\n+\tinstead of OMP_LOOP_CHECK.\n+\t* parser.c (cp_parser_omp_clause_name): Handle bind clause.\n+\t(cp_parser_omp_clause_bind): New function.\n+\t(cp_parser_omp_all_clauses): Handle PRAGMA_OMP_CLAUSE_BIND.\n+\t(OMP_LOOP_CLAUSE_MASK): Define.\n+\t(cp_parser_omp_loop): New function.\n+\t(cp_parser_omp_parallel, cp_parser_omp_teams): Handle parsing of\n+\tloop combined with parallel or teams.\n+\t(cp_parser_omp_construct): Handle PRAGMA_OMP_LOOP.\n+\t(cp_parser_pragma): Likewise.\n+\t* pt.c (tsubst_expr): Handle OMP_LOOP.\n+\t* semantics.c (finish_omp_clauses): Handle OMP_CLAUSE_BIND.\n+\n 2019-07-19  Jason Merrill  <jason@redhat.com>\n \n \tPR c++/90101 - dependent class non-type parameter."}, {"sha": "6068745567a70621ef694e2bd1434e7550cddc0d", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/554a530ff81870098572832eed8ca00b3593bb41/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/554a530ff81870098572832eed8ca00b3593bb41/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=554a530ff81870098572832eed8ca00b3593bb41", "patch": "@@ -4923,7 +4923,7 @@ more_aggr_init_expr_args_p (const aggr_init_expr_arg_iterator *iter)\n \n /* Used while gimplifying continue statements bound to OMP_FOR nodes.  */\n #define OMP_FOR_GIMPLIFYING_P(NODE) \\\n-  (TREE_LANG_FLAG_0 (OMP_LOOP_CHECK (NODE)))\n+  (TREE_LANG_FLAG_0 (OMP_LOOPING_CHECK (NODE)))\n \n /* A language-specific token attached to the OpenMP data clauses to\n    hold code (or code fragments) related to ctors, dtors, and op=."}, {"sha": "5c379aaf58d83efe44bd63100812f09284f60556", "filename": "gcc/cp/parser.c", "status": "modified", "additions": 162, "deletions": 3, "changes": 165, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/554a530ff81870098572832eed8ca00b3593bb41/gcc%2Fcp%2Fparser.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/554a530ff81870098572832eed8ca00b3593bb41/gcc%2Fcp%2Fparser.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparser.c?ref=554a530ff81870098572832eed8ca00b3593bb41", "patch": "@@ -32409,6 +32409,10 @@ cp_parser_omp_clause_name (cp_parser *parser)\n \t  else if (!strcmp (\"async\", p))\n \t    result = PRAGMA_OACC_CLAUSE_ASYNC;\n \t  break;\n+\tcase 'b':\n+\t  if (!strcmp (\"bind\", p))\n+\t    result = PRAGMA_OMP_CLAUSE_BIND;\n+\t  break;\n \tcase 'c':\n \t  if (!strcmp (\"collapse\", p))\n \t    result = PRAGMA_OMP_CLAUSE_COLLAPSE;\n@@ -33945,6 +33949,56 @@ cp_parser_omp_clause_order (cp_parser *parser, tree list, location_t location)\n   return list;\n }\n \n+/* OpenMP 5.0:\n+   bind ( teams | parallel | thread ) */\n+\n+static tree\n+cp_parser_omp_clause_bind (cp_parser *parser, tree list,\n+\t\t\t   location_t location)\n+{\n+  tree c;\n+  const char *p;\n+  enum omp_clause_bind_kind kind = OMP_CLAUSE_BIND_THREAD;\n+\n+  matching_parens parens;\n+  if (!parens.require_open (parser))\n+    return list;\n+\n+  if (!cp_lexer_next_token_is (parser->lexer, CPP_NAME))\n+    {\n+    invalid:\n+      cp_parser_error (parser,\n+\t\t       \"expected %<teams%>, %<parallel%> or %<thread%>\");\n+      goto out_err;\n+    }\n+  else\n+    {\n+      tree id = cp_lexer_peek_token (parser->lexer)->u.value;\n+      p = IDENTIFIER_POINTER (id);\n+    }\n+  if (strcmp (p, \"teams\") == 0)\n+    kind = OMP_CLAUSE_BIND_TEAMS;\n+  else if (strcmp (p, \"parallel\") == 0)\n+    kind = OMP_CLAUSE_BIND_PARALLEL;\n+  else if (strcmp (p, \"thread\") != 0)\n+    goto invalid;\n+  cp_lexer_consume_token (parser->lexer);\n+  if (!parens.require_close (parser))\n+    goto out_err;\n+\n+  /* check_no_duplicate_clause (list, OMP_CLAUSE_BIND, \"bind\", location); */\n+  c = build_omp_clause (location, OMP_CLAUSE_BIND);\n+  OMP_CLAUSE_BIND_KIND (c) = kind;\n+  OMP_CLAUSE_CHAIN (c) = list;\n+  return c;\n+\n+ out_err:\n+  cp_parser_skip_to_closing_parenthesis (parser, /*recovering=*/true,\n+\t\t\t\t\t /*or_comma=*/false,\n+\t\t\t\t\t /*consume_paren=*/true);\n+  return list;\n+}\n+\n /* OpenMP 2.5:\n    ordered\n \n@@ -35462,6 +35516,11 @@ cp_parser_omp_all_clauses (cp_parser *parser, omp_clause_mask mask,\n \n       switch (c_kind)\n \t{\n+\tcase PRAGMA_OMP_CLAUSE_BIND:\n+\t  clauses = cp_parser_omp_clause_bind (parser, clauses,\n+\t\t\t\t\t       token->location);\n+\t  c_name = \"bind\";\n+\t  break;\n \tcase PRAGMA_OMP_CLAUSE_COLLAPSE:\n \t  clauses = cp_parser_omp_clause_collapse (parser, clauses,\n \t\t\t\t\t\t   token->location);\n@@ -37578,6 +37637,50 @@ cp_omp_split_clauses (location_t loc, enum tree_code code,\n       cclauses[i] = finish_omp_clauses (cclauses[i], C_ORT_OMP);\n }\n \n+/* OpenMP 5.0:\n+   #pragma omp loop loop-clause[optseq] new-line\n+     for-loop  */\n+\n+#define OMP_LOOP_CLAUSE_MASK\t\t\t\t\t\\\n+\t( (OMP_CLAUSE_MASK_1 << PRAGMA_OMP_CLAUSE_PRIVATE)\t\\\n+\t| (OMP_CLAUSE_MASK_1 << PRAGMA_OMP_CLAUSE_LASTPRIVATE)\t\\\n+\t| (OMP_CLAUSE_MASK_1 << PRAGMA_OMP_CLAUSE_REDUCTION)\t\\\n+\t| (OMP_CLAUSE_MASK_1 << PRAGMA_OMP_CLAUSE_COLLAPSE)\t\\\n+\t| (OMP_CLAUSE_MASK_1 << PRAGMA_OMP_CLAUSE_BIND)\t\t\\\n+\t| (OMP_CLAUSE_MASK_1 << PRAGMA_OMP_CLAUSE_ORDER))\n+\n+static tree\n+cp_parser_omp_loop (cp_parser *parser, cp_token *pragma_tok,\n+\t\t    char *p_name, omp_clause_mask mask, tree *cclauses,\n+\t\t    bool *if_p)\n+{\n+  tree clauses, sb, ret;\n+  unsigned int save;\n+  location_t loc = cp_lexer_peek_token (parser->lexer)->location;\n+\n+  strcat (p_name, \" loop\");\n+  mask |= OMP_LOOP_CLAUSE_MASK;\n+\n+  clauses = cp_parser_omp_all_clauses (parser, mask, p_name, pragma_tok,\n+\t\t\t\t       cclauses == NULL);\n+  if (cclauses)\n+    {\n+      cp_omp_split_clauses (loc, OMP_LOOP, mask, clauses, cclauses);\n+      clauses = cclauses[C_OMP_CLAUSE_SPLIT_LOOP];\n+    }\n+\n+  keep_next_level (true);\n+  sb = begin_omp_structured_block ();\n+  save = cp_parser_begin_omp_structured_block (parser);\n+\n+  ret = cp_parser_omp_for_loop (parser, OMP_LOOP, clauses, cclauses, if_p);\n+\n+  cp_parser_end_omp_structured_block (parser, save);\n+  add_stmt (finish_omp_for_block (finish_omp_structured_block (sb), ret));\n+\n+  return ret;\n+}\n+\n /* OpenMP 4.0:\n    #pragma omp simd simd-clause[optseq] new-line\n      for-loop  */\n@@ -38038,11 +38141,11 @@ cp_parser_omp_parallel (cp_parser *parser, cp_token *pragma_tok,\n       cp_parser_skip_to_pragma_eol (parser, pragma_tok);\n       return NULL_TREE;\n     }\n-  else if (cclauses == NULL && cp_lexer_next_token_is (parser->lexer, CPP_NAME))\n+  else if (cp_lexer_next_token_is (parser->lexer, CPP_NAME))\n     {\n       tree id = cp_lexer_peek_token (parser->lexer)->u.value;\n       const char *p = IDENTIFIER_POINTER (id);\n-      if (strcmp (p, \"master\") == 0)\n+      if (cclauses == NULL && strcmp (p, \"master\") == 0)\n \t{\n \t  tree cclauses_buf[C_OMP_CLAUSE_SPLIT_COUNT];\n \t  cclauses = cclauses_buf;\n@@ -38060,12 +38163,34 @@ cp_parser_omp_parallel (cp_parser *parser, cp_token *pragma_tok,\n \t    return ret;\n \t  return stmt;\n \t}\n+      else if (strcmp (p, \"loop\") == 0)\n+\t{\n+\t  tree cclauses_buf[C_OMP_CLAUSE_SPLIT_COUNT];\n+\t  if (cclauses == NULL)\n+\t    cclauses = cclauses_buf;\n+\n+\t  cp_lexer_consume_token (parser->lexer);\n+\t  if (!flag_openmp)  /* flag_openmp_simd  */\n+\t    return cp_parser_omp_loop (parser, pragma_tok, p_name, mask,\n+\t\t\t\t       cclauses, if_p);\n+\t  block = begin_omp_parallel ();\n+\t  save = cp_parser_begin_omp_structured_block (parser);\n+\t  tree ret = cp_parser_omp_loop (parser, pragma_tok, p_name, mask,\n+\t\t\t\t\t cclauses, if_p);\n+\t  cp_parser_end_omp_structured_block (parser, save);\n+\t  stmt = finish_omp_parallel (cclauses[C_OMP_CLAUSE_SPLIT_PARALLEL],\n+\t\t\t\t      block);\n+\t  if (ret == NULL_TREE)\n+\t    return ret;\n+\t  OMP_PARALLEL_COMBINED (stmt) = 1;\n+\t  return stmt;\n+\t}\n       else if (!flag_openmp)  /* flag_openmp_simd  */\n \t{\n \t  cp_parser_skip_to_pragma_eol (parser, pragma_tok);\n \t  return NULL_TREE;\n \t}\n-      else if (strcmp (p, \"sections\") == 0)\n+      else if (cclauses == NULL && strcmp (p, \"sections\") == 0)\n \t{\n \t  tree cclauses_buf[C_OMP_CLAUSE_SPLIT_COUNT];\n \t  cclauses = cclauses_buf;\n@@ -38460,6 +38585,34 @@ cp_parser_omp_teams (cp_parser *parser, cp_token *pragma_tok,\n \t  SET_EXPR_LOCATION (ret, loc);\n \t  return add_stmt (ret);\n \t}\n+      else if (strcmp (p, \"loop\") == 0)\n+\t{\n+\t  tree cclauses_buf[C_OMP_CLAUSE_SPLIT_COUNT];\n+\t  if (cclauses == NULL)\n+\t    cclauses = cclauses_buf;\n+\n+\t  cp_lexer_consume_token (parser->lexer);\n+\t  if (!flag_openmp)  /* flag_openmp_simd  */\n+\t    return cp_parser_omp_loop (parser, pragma_tok, p_name, mask,\n+\t\t\t\t       cclauses, if_p);\n+\t  keep_next_level (true);\n+\t  sb = begin_omp_structured_block ();\n+\t  save = cp_parser_begin_omp_structured_block (parser);\n+\t  ret = cp_parser_omp_loop (parser, pragma_tok, p_name, mask,\n+\t\t\t\t    cclauses, if_p);\n+\t  cp_parser_end_omp_structured_block (parser, save);\n+\t  tree body = finish_omp_structured_block (sb);\n+\t  if (ret == NULL)\n+\t    return ret;\n+\t  clauses = cclauses[C_OMP_CLAUSE_SPLIT_TEAMS];\n+\t  ret = make_node (OMP_TEAMS);\n+\t  TREE_TYPE (ret) = void_type_node;\n+\t  OMP_TEAMS_CLAUSES (ret) = clauses;\n+\t  OMP_TEAMS_BODY (ret) = body;\n+\t  OMP_TEAMS_COMBINED (ret) = 1;\n+\t  SET_EXPR_LOCATION (ret, loc);\n+\t  return add_stmt (ret);\n+\t}\n     }\n   if (!flag_openmp)  /* flag_openmp_simd  */\n     {\n@@ -40716,6 +40869,11 @@ cp_parser_omp_construct (cp_parser *parser, cp_token *pragma_tok, bool *if_p)\n       stmt = cp_parser_omp_for (parser, pragma_tok, p_name, mask, NULL,\n \t\t\t\tif_p);\n       break;\n+    case PRAGMA_OMP_LOOP:\n+      strcpy (p_name, \"#pragma omp\");\n+      stmt = cp_parser_omp_loop (parser, pragma_tok, p_name, mask, NULL,\n+\t\t\t\t if_p);\n+      break;\n     case PRAGMA_OMP_MASTER:\n       strcpy (p_name, \"#pragma omp\");\n       stmt = cp_parser_omp_master (parser, pragma_tok, p_name, mask, NULL,\n@@ -41352,6 +41510,7 @@ cp_parser_pragma (cp_parser *parser, enum pragma_context context, bool *if_p)\n     case PRAGMA_OMP_CRITICAL:\n     case PRAGMA_OMP_DISTRIBUTE:\n     case PRAGMA_OMP_FOR:\n+    case PRAGMA_OMP_LOOP:\n     case PRAGMA_OMP_MASTER:\n     case PRAGMA_OMP_PARALLEL:\n     case PRAGMA_OMP_SECTIONS:"}, {"sha": "b6eda7eb27c38ef320c07ead3bab2fb890577ce3", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/554a530ff81870098572832eed8ca00b3593bb41/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/554a530ff81870098572832eed8ca00b3593bb41/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=554a530ff81870098572832eed8ca00b3593bb41", "patch": "@@ -17553,6 +17553,7 @@ tsubst_expr (tree t, tree args, tsubst_flags_t complain, tree in_decl,\n       break;\n \n     case OMP_FOR:\n+    case OMP_LOOP:\n     case OMP_SIMD:\n     case OMP_DISTRIBUTE:\n     case OMP_TASKLOOP:"}, {"sha": "269092de1ef0b9e6decefc93b93b49e84c61c3dd", "filename": "gcc/cp/semantics.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/554a530ff81870098572832eed8ca00b3593bb41/gcc%2Fcp%2Fsemantics.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/554a530ff81870098572832eed8ca00b3593bb41/gcc%2Fcp%2Fsemantics.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsemantics.c?ref=554a530ff81870098572832eed8ca00b3593bb41", "patch": "@@ -7550,6 +7550,7 @@ finish_omp_clauses (tree clauses, enum c_omp_region_type ort)\n \tcase OMP_CLAUSE_THREADS:\n \tcase OMP_CLAUSE_SIMD:\n \tcase OMP_CLAUSE_DEFAULTMAP:\n+\tcase OMP_CLAUSE_BIND:\n \tcase OMP_CLAUSE_AUTO:\n \tcase OMP_CLAUSE_INDEPENDENT:\n \tcase OMP_CLAUSE_SEQ:"}, {"sha": "723897f566c4645ab882b53956c1e8c61cf4bb5c", "filename": "gcc/gimplify.c", "status": "modified", "additions": 296, "deletions": 16, "changes": 312, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/554a530ff81870098572832eed8ca00b3593bb41/gcc%2Fgimplify.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/554a530ff81870098572832eed8ca00b3593bb41/gcc%2Fgimplify.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimplify.c?ref=554a530ff81870098572832eed8ca00b3593bb41", "patch": "@@ -154,6 +154,7 @@ enum omp_region_type\n   /* Data region with offloading.  */\n   ORT_TARGET\t= 0x80,\n   ORT_COMBINED_TARGET = ORT_TARGET | 1,\n+  ORT_IMPLICIT_TARGET = ORT_TARGET | 2,\n \n   /* OpenACC variants.  */\n   ORT_ACC\t= 0x100,  /* A generic OpenACC region.  */\n@@ -228,6 +229,7 @@ struct gimplify_omp_ctx\n \n static struct gimplify_ctx *gimplify_ctxp;\n static struct gimplify_omp_ctx *gimplify_omp_ctxp;\n+static bool in_omp_construct;\n \n /* Forward declaration.  */\n static enum gimplify_status gimplify_compound_expr (tree *, gimple_seq *, bool);\n@@ -5533,6 +5535,7 @@ is_gimple_stmt (tree t)\n     case OMP_FOR:\n     case OMP_SIMD:\n     case OMP_DISTRIBUTE:\n+    case OMP_LOOP:\n     case OACC_LOOP:\n     case OMP_SCAN:\n     case OMP_SECTIONS:\n@@ -8185,7 +8188,8 @@ gimplify_scan_omp_clauses (tree *list_p, gimple_seq *pre_p,\n \t\tbreak;\n \t      }\n \t  flags = GOVD_LASTPRIVATE | GOVD_SEEN | GOVD_EXPLICIT;\n-\t  check_non_private = \"lastprivate\";\n+\t  if (code != OMP_LOOP)\n+\t    check_non_private = \"lastprivate\";\n \t  decl = OMP_CLAUSE_DECL (c);\n \t  if (error_operand_p (decl))\n \t    goto do_add;\n@@ -9142,15 +9146,20 @@ gimplify_scan_omp_clauses (tree *list_p, gimple_seq *pre_p,\n \t\t\t  \" or private in outer context\", DECL_NAME (decl));\n \t    }\n \tdo_notice:\n-\t  if (((region_type & ORT_TASKLOOP) == ORT_TASKLOOP\n-\t       || (region_type == ORT_WORKSHARE\n-\t\t   && OMP_CLAUSE_CODE (c) == OMP_CLAUSE_REDUCTION\n-\t\t   && OMP_CLAUSE_REDUCTION_INSCAN (c)))\n+\t  if ((OMP_CLAUSE_CODE (c) == OMP_CLAUSE_REDUCTION\n+\t       || OMP_CLAUSE_CODE (c) == OMP_CLAUSE_FIRSTPRIVATE\n+\t       || OMP_CLAUSE_CODE (c) == OMP_CLAUSE_LASTPRIVATE)\n \t      && outer_ctx\n-\t      && outer_ctx->region_type == ORT_COMBINED_PARALLEL\n-\t      && (OMP_CLAUSE_CODE (c) == OMP_CLAUSE_REDUCTION\n-\t\t  || OMP_CLAUSE_CODE (c) == OMP_CLAUSE_FIRSTPRIVATE\n-\t\t  || OMP_CLAUSE_CODE (c) == OMP_CLAUSE_LASTPRIVATE))\n+\t      && ((region_type & ORT_TASKLOOP) == ORT_TASKLOOP\n+\t\t   || (region_type == ORT_WORKSHARE\n+\t\t       && OMP_CLAUSE_CODE (c) == OMP_CLAUSE_REDUCTION\n+\t\t       && (OMP_CLAUSE_REDUCTION_INSCAN (c)\n+\t\t\t   || code == OMP_LOOP)))\n+\t      && (outer_ctx->region_type == ORT_COMBINED_PARALLEL\n+\t\t  || (code == OMP_LOOP\n+\t\t      && OMP_CLAUSE_CODE (c) == OMP_CLAUSE_REDUCTION\n+\t\t      && ((outer_ctx->region_type & ORT_COMBINED_TEAMS)\n+\t\t\t  == ORT_COMBINED_TEAMS))))\n \t    {\n \t      splay_tree_node on\n \t\t= splay_tree_lookup (outer_ctx->variables,\n@@ -9274,6 +9283,7 @@ gimplify_scan_omp_clauses (tree *list_p, gimple_seq *pre_p,\n \tcase OMP_CLAUSE_NOGROUP:\n \tcase OMP_CLAUSE_THREADS:\n \tcase OMP_CLAUSE_SIMD:\n+\tcase OMP_CLAUSE_BIND:\n \tcase OMP_CLAUSE_IF_PRESENT:\n \tcase OMP_CLAUSE_FINALIZE:\n \t  break;\n@@ -10239,6 +10249,7 @@ gimplify_adjust_omp_clauses (gimple_seq *pre_p, gimple_seq body, tree *list_p,\n \tcase OMP_CLAUSE_HINT:\n \tcase OMP_CLAUSE_DEFAULTMAP:\n \tcase OMP_CLAUSE_ORDER:\n+\tcase OMP_CLAUSE_BIND:\n \tcase OMP_CLAUSE_USE_DEVICE_PTR:\n \tcase OMP_CLAUSE_IS_DEVICE_PTR:\n \tcase OMP_CLAUSE_ASYNC:\n@@ -10764,9 +10775,12 @@ gimplify_omp_for (tree *expr_p, gimple_seq *pre_p)\n \t  }\n     }\n \n+  bool loop_p = (omp_find_clause (OMP_FOR_CLAUSES (for_stmt), OMP_CLAUSE_BIND)\n+\t\t != NULL_TREE);\n   if (TREE_CODE (for_stmt) != OMP_TASKLOOP)\n     gimplify_scan_omp_clauses (&OMP_FOR_CLAUSES (for_stmt), pre_p, ort,\n-\t\t\t       TREE_CODE (for_stmt));\n+\t\t\t       loop_p && TREE_CODE (for_stmt) != OMP_SIMD\n+\t\t\t       ? OMP_LOOP : TREE_CODE (for_stmt));\n \n   if (TREE_CODE (for_stmt) == OMP_DISTRIBUTE)\n     gimplify_omp_ctxp->distribute = true;\n@@ -10997,7 +11011,7 @@ gimplify_omp_for (tree *expr_p, gimple_seq *pre_p)\n \t\t      n->value &= ~GOVD_LASTPRIVATE_CONDITIONAL;\n \t\t    }\n \t    }\n-\t  else if (TREE_VEC_LENGTH (OMP_FOR_INIT (for_stmt)) == 1)\n+\t  else if (TREE_VEC_LENGTH (OMP_FOR_INIT (for_stmt)) == 1 && !loop_p)\n \t    {\n \t      c = build_omp_clause (input_location, OMP_CLAUSE_LINEAR);\n \t      OMP_CLAUSE_LINEAR_NO_COPYIN (c) = 1;\n@@ -11740,6 +11754,259 @@ gimplify_omp_for (tree *expr_p, gimple_seq *pre_p)\n   return GS_ALL_DONE;\n }\n \n+/* Helper for gimplify_omp_loop, called through walk_tree.  */\n+\n+static tree\n+replace_reduction_placeholders (tree *tp, int *walk_subtrees, void *data)\n+{\n+  if (DECL_P (*tp))\n+    {\n+      tree *d = (tree *) data;\n+      if (*tp == OMP_CLAUSE_REDUCTION_PLACEHOLDER (d[0]))\n+\t{\n+\t  *tp = OMP_CLAUSE_REDUCTION_PLACEHOLDER (d[1]);\n+\t  *walk_subtrees = 0;\n+\t}\n+      else if (*tp == OMP_CLAUSE_REDUCTION_DECL_PLACEHOLDER (d[0]))\n+\t{\n+\t  *tp = OMP_CLAUSE_REDUCTION_DECL_PLACEHOLDER (d[1]);\n+\t  *walk_subtrees = 0;\n+\t}\n+    }\n+  return NULL_TREE;\n+}\n+\n+/* Gimplify the gross structure of an OMP_LOOP statement.  */\n+\n+static enum gimplify_status\n+gimplify_omp_loop (tree *expr_p, gimple_seq *pre_p)\n+{\n+  tree for_stmt = *expr_p;\n+  tree clauses = OMP_FOR_CLAUSES (for_stmt);\n+  struct gimplify_omp_ctx *octx = gimplify_omp_ctxp;\n+  enum omp_clause_bind_kind kind = OMP_CLAUSE_BIND_THREAD;\n+  int i;\n+\n+  /* If order is not present, the behavior is as if order(concurrent)\n+     appeared.  */\n+  tree order = omp_find_clause (clauses, OMP_CLAUSE_ORDER);\n+  if (order == NULL_TREE)\n+    {\n+      order = build_omp_clause (UNKNOWN_LOCATION, OMP_CLAUSE_ORDER);\n+      OMP_CLAUSE_CHAIN (order) = clauses;\n+      OMP_FOR_CLAUSES (for_stmt) = clauses = order;\n+    }\n+\n+  tree bind = omp_find_clause (clauses, OMP_CLAUSE_BIND);\n+  if (bind == NULL_TREE)\n+    {\n+      if (!flag_openmp) /* flag_openmp_simd */\n+\t;\n+      else if (octx && (octx->region_type & ORT_TEAMS) != 0)\n+\tkind = OMP_CLAUSE_BIND_TEAMS;\n+      else if (octx && (octx->region_type & ORT_PARALLEL) != 0)\n+\tkind = OMP_CLAUSE_BIND_PARALLEL;\n+      else\n+\t{\n+\t  for (; octx; octx = octx->outer_context)\n+\t    {\n+\t      if ((octx->region_type & ORT_ACC) != 0\n+\t\t  || octx->region_type == ORT_NONE\n+\t\t  || octx->region_type == ORT_IMPLICIT_TARGET)\n+\t\tcontinue;\n+\t      break;\n+\t    }\n+\t  if (octx == NULL && !in_omp_construct)\n+\t    error_at (EXPR_LOCATION (for_stmt),\n+\t\t      \"%<bind%> clause not specified on a %<loop%> \"\n+\t\t      \"construct not nested inside another OpenMP construct\");\n+\t}\n+      bind = build_omp_clause (UNKNOWN_LOCATION, OMP_CLAUSE_BIND);\n+      OMP_CLAUSE_CHAIN (bind) = clauses;\n+      OMP_CLAUSE_BIND_KIND (bind) = kind;\n+      OMP_FOR_CLAUSES (for_stmt) = bind;\n+    }\n+  else\n+    switch (OMP_CLAUSE_BIND_KIND (bind))\n+      {\n+      case OMP_CLAUSE_BIND_THREAD:\n+\tbreak;\n+      case OMP_CLAUSE_BIND_PARALLEL:\n+\tif (!flag_openmp) /* flag_openmp_simd */\n+\t  {\n+\t    OMP_CLAUSE_BIND_KIND (bind) = OMP_CLAUSE_BIND_THREAD;\n+\t    break;\n+\t  }\n+\tfor (; octx; octx = octx->outer_context)\n+\t  if (octx->region_type == ORT_SIMD\n+\t      && omp_find_clause (octx->clauses, OMP_CLAUSE_BIND) == NULL_TREE)\n+\t    {\n+\t      error_at (EXPR_LOCATION (for_stmt),\n+\t\t\t\"%<bind(parallel)%> on a %<loop%> construct nested \"\n+\t\t\t\"inside %<simd%> construct\");\n+\t      OMP_CLAUSE_BIND_KIND (bind) = OMP_CLAUSE_BIND_THREAD;\n+\t      break;\n+\t    }\n+\tkind = OMP_CLAUSE_BIND_PARALLEL;\n+\tbreak;\n+      case OMP_CLAUSE_BIND_TEAMS:\n+\tif (!flag_openmp) /* flag_openmp_simd */\n+\t  {\n+\t    OMP_CLAUSE_BIND_KIND (bind) = OMP_CLAUSE_BIND_THREAD;\n+\t    break;\n+\t  }\n+\tif ((octx\n+\t     && octx->region_type != ORT_IMPLICIT_TARGET\n+\t     && octx->region_type != ORT_NONE\n+\t     && (octx->region_type & ORT_TEAMS) == 0)\n+\t    || in_omp_construct)\n+\t  {\n+\t    error_at (EXPR_LOCATION (for_stmt),\n+\t\t      \"%<bind(teams)%> on a %<loop%> region not strictly \"\n+\t\t      \"nested inside of a %<teams%> region\");\n+\t    OMP_CLAUSE_BIND_KIND (bind) = OMP_CLAUSE_BIND_THREAD;\n+\t    break;\n+\t  }\n+\tkind = OMP_CLAUSE_BIND_TEAMS;\n+\tbreak;\n+      default:\n+\tgcc_unreachable ();\n+      }\n+\n+  for (tree *pc = &OMP_FOR_CLAUSES (for_stmt); *pc; )\n+    switch (OMP_CLAUSE_CODE (*pc))\n+      {\n+      case OMP_CLAUSE_REDUCTION:\n+\tif (OMP_CLAUSE_REDUCTION_INSCAN (*pc))\n+\t  {\n+\t    error_at (OMP_CLAUSE_LOCATION (*pc),\n+\t\t      \"%<inscan%> %<reduction%> clause on \"\n+\t\t      \"%qs construct\", \"loop\");\n+\t    OMP_CLAUSE_REDUCTION_INSCAN (*pc) = 0;\n+\t  }\n+\tif (OMP_CLAUSE_REDUCTION_TASK (*pc))\n+\t  {\n+\t    error_at (OMP_CLAUSE_LOCATION (*pc),\n+\t\t      \"invalid %<task%> reduction modifier on construct \"\n+\t\t      \"other than %<parallel%>, %<for%> or %<sections%>\");\n+\t    OMP_CLAUSE_REDUCTION_TASK (*pc) = 0;\n+\t  }\n+\tpc = &OMP_CLAUSE_CHAIN (*pc);\n+\tbreak;\n+      case OMP_CLAUSE_LASTPRIVATE:\n+\tfor (i = 0; i < TREE_VEC_LENGTH (OMP_FOR_INIT (for_stmt)); i++)\n+\t  {\n+\t    tree t = TREE_VEC_ELT (OMP_FOR_INIT (for_stmt), i);\n+\t    gcc_assert (TREE_CODE (t) == MODIFY_EXPR);\n+\t    if (OMP_CLAUSE_DECL (*pc) == TREE_OPERAND (t, 0))\n+\t      break;\n+\t    if (OMP_FOR_ORIG_DECLS (for_stmt)\n+\t\t&& TREE_CODE (TREE_VEC_ELT (OMP_FOR_ORIG_DECLS (for_stmt),\n+\t\t\t\t\t    i)) == TREE_LIST\n+\t\t&& TREE_PURPOSE (TREE_VEC_ELT (OMP_FOR_ORIG_DECLS (for_stmt),\n+\t\t\t\t\t       i)))\n+\t      {\n+\t\ttree orig = TREE_VEC_ELT (OMP_FOR_ORIG_DECLS (for_stmt), i);\n+\t\tif (OMP_CLAUSE_DECL (*pc) == TREE_PURPOSE (orig))\n+\t\t  break;\n+\t      }\n+\t  }\n+\tif (i == TREE_VEC_LENGTH (OMP_FOR_INIT (for_stmt)))\n+\t  {\n+\t    error_at (OMP_CLAUSE_LOCATION (*pc),\n+\t\t      \"%<lastprivate%> clause on a %<loop%> construct refers \"\n+\t\t      \"to a variable %qD which is not the loop iterator\",\n+\t\t      OMP_CLAUSE_DECL (*pc));\n+\t    *pc = OMP_CLAUSE_CHAIN (*pc);\n+\t    break;\n+\t  }\n+\tpc = &OMP_CLAUSE_CHAIN (*pc);\n+\tbreak;\n+      default:\n+\tpc = &OMP_CLAUSE_CHAIN (*pc);\n+\tbreak;\n+    }\n+\n+  TREE_SET_CODE (for_stmt, OMP_SIMD);\n+\n+  int last;\n+  switch (kind)\n+    {\n+    case OMP_CLAUSE_BIND_THREAD: last = 0; break;\n+    case OMP_CLAUSE_BIND_PARALLEL: last = 1; break;\n+    case OMP_CLAUSE_BIND_TEAMS: last = 2; break;\n+    }\n+  for (int pass = 1; pass <= last; pass++)\n+    {\n+      if (pass == 2)\n+\t{\n+\t  tree bind = build3 (BIND_EXPR, void_type_node, NULL, NULL, NULL);\n+\t  append_to_statement_list (*expr_p, &BIND_EXPR_BODY (bind));\n+\t  *expr_p = make_node (OMP_PARALLEL);\n+\t  TREE_TYPE (*expr_p) = void_type_node;\n+\t  OMP_PARALLEL_BODY (*expr_p) = bind;\n+\t  OMP_PARALLEL_COMBINED (*expr_p) = 1;\n+\t  SET_EXPR_LOCATION (*expr_p, EXPR_LOCATION (for_stmt));\n+\t}\n+      tree t = make_node (pass == 2 ? OMP_DISTRIBUTE : OMP_FOR);\n+      tree *pc = &OMP_FOR_CLAUSES (t);\n+      TREE_TYPE (t) = void_type_node;\n+      OMP_FOR_BODY (t) = *expr_p;\n+      SET_EXPR_LOCATION (t, EXPR_LOCATION (for_stmt));\n+      for (tree c = OMP_FOR_CLAUSES (for_stmt); c; c = OMP_CLAUSE_CHAIN (c))\n+\tswitch (OMP_CLAUSE_CODE (c))\n+\t  {\n+\t  case OMP_CLAUSE_BIND:\n+\t  case OMP_CLAUSE_ORDER:\n+\t  case OMP_CLAUSE_COLLAPSE:\n+\t    *pc = copy_node (c);\n+\t    pc = &OMP_CLAUSE_CHAIN (*pc);\n+\t    break;\n+\t  case OMP_CLAUSE_PRIVATE:\n+\t    /* Only needed on innermost.  */\n+\t    break;\n+\t  case OMP_CLAUSE_LASTPRIVATE:\n+\t    *pc = copy_node (c);\n+\t    OMP_CLAUSE_LASTPRIVATE_STMT (*pc) = NULL_TREE;\n+\t    TREE_TYPE (*pc) = unshare_expr (TREE_TYPE (c));\n+\t    pc = &OMP_CLAUSE_CHAIN (*pc);\n+\t    break;\n+\t  case OMP_CLAUSE_REDUCTION:\n+\t    *pc = copy_node (c);\n+\t    OMP_CLAUSE_DECL (*pc) = unshare_expr (OMP_CLAUSE_DECL (c));\n+\t    TREE_TYPE (*pc) = unshare_expr (TREE_TYPE (c));\n+\t    OMP_CLAUSE_REDUCTION_INIT (*pc)\n+\t      = unshare_expr (OMP_CLAUSE_REDUCTION_INIT (c));\n+\t    OMP_CLAUSE_REDUCTION_MERGE (*pc)\n+\t      = unshare_expr (OMP_CLAUSE_REDUCTION_MERGE (c));\n+\t    if (OMP_CLAUSE_REDUCTION_PLACEHOLDER (*pc))\n+\t      {\n+\t\tOMP_CLAUSE_REDUCTION_PLACEHOLDER (*pc)\n+\t\t  = copy_node (OMP_CLAUSE_REDUCTION_PLACEHOLDER (c));\n+\t\tif (OMP_CLAUSE_REDUCTION_DECL_PLACEHOLDER (*pc))\n+\t\t  OMP_CLAUSE_REDUCTION_DECL_PLACEHOLDER (*pc)\n+\t\t    = copy_node (OMP_CLAUSE_REDUCTION_DECL_PLACEHOLDER (c));\n+\t\ttree nc = *pc;\n+\t\ttree data[2] = { c, nc };\n+\t\twalk_tree_without_duplicates (&OMP_CLAUSE_REDUCTION_INIT (nc),\n+\t\t\t\t\t      replace_reduction_placeholders,\n+\t\t\t\t\t      data);\n+\t\twalk_tree_without_duplicates (&OMP_CLAUSE_REDUCTION_MERGE (nc),\n+\t\t\t\t\t      replace_reduction_placeholders,\n+\t\t\t\t\t      data);\n+\t      }\n+\t    pc = &OMP_CLAUSE_CHAIN (*pc);\n+\t    break;\n+\t  default:\n+\t    gcc_unreachable ();\n+\t  }\n+      *pc = NULL_TREE;\n+      *expr_p = t;\n+    }\n+  return gimplify_omp_for (expr_p, pre_p);\n+}\n+\n+\n /* Helper function of optimize_target_teams, find OMP_TEAMS inside\n    of OMP_TARGET's body.  */\n \n@@ -11974,10 +12241,7 @@ gimplify_omp_workshare (tree *expr_p, gimple_seq *pre_p)\n     case OMP_TEAMS:\n       ort = OMP_TEAMS_COMBINED (expr) ? ORT_COMBINED_TEAMS : ORT_TEAMS;\n       if (gimplify_omp_ctxp == NULL\n-\t  || (gimplify_omp_ctxp->region_type == ORT_TARGET\n-\t      && gimplify_omp_ctxp->outer_context == NULL\n-\t      && lookup_attribute (\"omp declare target\",\n-\t\t\t\t   DECL_ATTRIBUTES (current_function_decl))))\n+\t  || gimplify_omp_ctxp->region_type == ORT_IMPLICIT_TARGET)\n \tort = (enum omp_region_type) (ort | ORT_HOST_TEAMS);\n       break;\n     case OACC_HOST_DATA:\n@@ -11986,6 +12250,10 @@ gimplify_omp_workshare (tree *expr_p, gimple_seq *pre_p)\n     default:\n       gcc_unreachable ();\n     }\n+\n+  bool save_in_omp_construct = in_omp_construct;\n+  if ((ort & ORT_ACC) == 0)\n+    in_omp_construct = false;\n   gimplify_scan_omp_clauses (&OMP_CLAUSES (expr), pre_p, ort,\n \t\t\t     TREE_CODE (expr));\n   if (TREE_CODE (expr) == OMP_TARGET)\n@@ -12027,6 +12295,7 @@ gimplify_omp_workshare (tree *expr_p, gimple_seq *pre_p)\n     gimplify_and_add (OMP_BODY (expr), &body);\n   gimplify_adjust_omp_clauses (pre_p, body, &OMP_CLAUSES (expr),\n \t\t\t       TREE_CODE (expr));\n+  in_omp_construct = save_in_omp_construct;\n \n   switch (TREE_CODE (expr))\n     {\n@@ -13266,6 +13535,10 @@ gimplify_expr (tree *expr_p, gimple_seq *pre_p, gimple_seq *post_p,\n \t  ret = gimplify_omp_for (expr_p, pre_p);\n \t  break;\n \n+\tcase OMP_LOOP:\n+\t  ret = gimplify_omp_loop (expr_p, pre_p);\n+\t  break;\n+\n \tcase OACC_CACHE:\n \t  gimplify_oacc_cache (expr_p, pre_p);\n \t  ret = GS_ALL_DONE;\n@@ -13307,8 +13580,11 @@ gimplify_expr (tree *expr_p, gimple_seq *pre_p, gimple_seq *post_p,\n \t  {\n \t    gimple_seq body = NULL;\n \t    gimple *g;\n+\t    bool saved_in_omp_construct = in_omp_construct;\n \n+\t    in_omp_construct = true;\n \t    gimplify_and_add (OMP_BODY (*expr_p), &body);\n+\t    in_omp_construct = saved_in_omp_construct;\n \t    switch (TREE_CODE (*expr_p))\n \t      {\n \t      case OMP_SECTION:\n@@ -13351,10 +13627,14 @@ gimplify_expr (tree *expr_p, gimple_seq *pre_p, gimple_seq *post_p,\n \t    gimple_seq body = NULL;\n \n \t    tree *pclauses = &OMP_TASKGROUP_CLAUSES (*expr_p);\n+\t    bool saved_in_omp_construct = in_omp_construct;\n \t    gimplify_scan_omp_clauses (pclauses, pre_p, ORT_TASKGROUP,\n \t\t\t\t       OMP_TASKGROUP);\n \t    gimplify_adjust_omp_clauses (pre_p, NULL, pclauses, OMP_TASKGROUP);\n+\n+\t    in_omp_construct = true;\n \t    gimplify_and_add (OMP_BODY (*expr_p), &body);\n+\t    in_omp_construct = saved_in_omp_construct;\n \t    gimple_seq cleanup = NULL;\n \t    tree fn = builtin_decl_explicit (BUILT_IN_GOMP_TASKGROUP_END);\n \t    gimple *g = gimple_build_call (fn, 0);\n@@ -13977,7 +14257,7 @@ gimplify_body (tree fndecl, bool do_parms)\n     {\n       gcc_assert (gimplify_omp_ctxp == NULL);\n       if (lookup_attribute (\"omp declare target\", DECL_ATTRIBUTES (fndecl)))\n-\tgimplify_omp_ctxp = new_omp_context (ORT_TARGET);\n+\tgimplify_omp_ctxp = new_omp_context (ORT_IMPLICIT_TARGET);\n     }\n \n   /* Unshare most shared trees in the body and in that of any nested functions."}, {"sha": "d8756c02cedba3b37f51a05c8546e169d5c74dc1", "filename": "gcc/omp-low.c", "status": "modified", "additions": 59, "deletions": 33, "changes": 92, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/554a530ff81870098572832eed8ca00b3593bb41/gcc%2Fomp-low.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/554a530ff81870098572832eed8ca00b3593bb41/gcc%2Fomp-low.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fomp-low.c?ref=554a530ff81870098572832eed8ca00b3593bb41", "patch": "@@ -153,6 +153,9 @@ struct omp_context\n \n   /* True if there is order(concurrent) clause on the construct.  */\n   bool order_concurrent;\n+\n+  /* True if there is bind clause on the construct (i.e. a loop construct).  */\n+  bool loop_p;\n };\n \n static splay_tree all_contexts;\n@@ -581,6 +584,7 @@ build_outer_var_ref (tree var, omp_context *ctx,\n     }\n   else if ((gimple_code (ctx->stmt) == GIMPLE_OMP_FOR\n \t    && gimple_omp_for_kind (ctx->stmt) == GF_OMP_FOR_KIND_SIMD)\n+\t   || ctx->loop_p\n \t   || (code == OMP_CLAUSE_PRIVATE\n \t       && (gimple_code (ctx->stmt) == GIMPLE_OMP_FOR\n \t\t   || gimple_code (ctx->stmt) == GIMPLE_OMP_SECTIONS\n@@ -1397,6 +1401,10 @@ scan_sharing_clauses (tree clauses, omp_context *ctx)\n \t  ctx->order_concurrent = true;\n \t  break;\n \n+\tcase OMP_CLAUSE_BIND:\n+\t  ctx->loop_p = true;\n+\t  break;\n+\n \tcase OMP_CLAUSE_NOWAIT:\n \tcase OMP_CLAUSE_ORDERED:\n \tcase OMP_CLAUSE_COLLAPSE:\n@@ -1603,6 +1611,7 @@ scan_sharing_clauses (tree clauses, omp_context *ctx)\n \tcase OMP_CLAUSE_NOGROUP:\n \tcase OMP_CLAUSE_DEFAULTMAP:\n \tcase OMP_CLAUSE_ORDER:\n+\tcase OMP_CLAUSE_BIND:\n \tcase OMP_CLAUSE_USE_DEVICE_PTR:\n \tcase OMP_CLAUSE_NONTEMPORAL:\n \tcase OMP_CLAUSE_ASYNC:\n@@ -2675,7 +2684,8 @@ check_omp_nesting_restrictions (gimple *stmt, omp_context *ctx)\n \t  && gimple_code (ctx->outer->stmt) == GIMPLE_OMP_FOR)\n \tctx = ctx->outer;\n       if (gimple_code (ctx->stmt) == GIMPLE_OMP_FOR\n-\t  && gimple_omp_for_kind (ctx->stmt) == GF_OMP_FOR_KIND_SIMD)\n+\t  && gimple_omp_for_kind (ctx->stmt) == GF_OMP_FOR_KIND_SIMD\n+\t  && !ctx->loop_p)\n \t{\n \t  c = NULL_TREE;\n \t  if (ctx->order_concurrent\n@@ -2684,8 +2694,8 @@ check_omp_nesting_restrictions (gimple *stmt, omp_context *ctx)\n \t\t  || gimple_code (stmt) == GIMPLE_OMP_ATOMIC_STORE))\n \t    {\n \t      error_at (gimple_location (stmt),\n-\t\t\t\"OpenMP constructs other than %<parallel%> or\"\n-\t\t\t\" %<simd%> may not be nested inside a region with\"\n+\t\t\t\"OpenMP constructs other than %<parallel%>, %<loop%>\"\n+\t\t\t\" or %<simd%> may not be nested inside a region with\"\n \t\t\t\" the %<order(concurrent)%> clause\");\n \t      return false;\n \t    }\n@@ -2714,23 +2724,28 @@ check_omp_nesting_restrictions (gimple *stmt, omp_context *ctx)\n \t\t   || gimple_code (stmt) == GIMPLE_OMP_ATOMIC_STORE\n \t\t   || gimple_code (stmt) == GIMPLE_OMP_SCAN)\n \t    return true;\n+\t  else if (gimple_code (stmt) == GIMPLE_OMP_FOR\n+\t\t   && gimple_omp_for_kind (ctx->stmt) == GF_OMP_FOR_KIND_SIMD)\n+\t    return true;\n \t  error_at (gimple_location (stmt),\n-\t\t    \"OpenMP constructs other than %<#pragma omp ordered simd%>\"\n-\t\t    \" or %<#pragma omp atomic%> may not be nested inside\"\n-\t\t    \" %<simd%> region\");\n+\t\t    \"OpenMP constructs other than \"\n+\t\t    \"%<ordered simd%>, %<simd%>, %<loop%> or %<atomic%> may \"\n+\t\t    \"not be nested inside %<simd%> region\");\n \t  return false;\n \t}\n       else if (gimple_code (ctx->stmt) == GIMPLE_OMP_TEAMS)\n \t{\n \t  if ((gimple_code (stmt) != GIMPLE_OMP_FOR\n-\t       || ((gimple_omp_for_kind (stmt) != GF_OMP_FOR_KIND_DISTRIBUTE)\n-\t\t   && (gimple_omp_for_kind (stmt) != GF_OMP_FOR_KIND_GRID_LOOP)))\n+\t       || (gimple_omp_for_kind (stmt) != GF_OMP_FOR_KIND_DISTRIBUTE\n+\t\t   && gimple_omp_for_kind (stmt) != GF_OMP_FOR_KIND_GRID_LOOP\n+\t\t   && omp_find_clause (gimple_omp_for_clauses (stmt),\n+\t\t\t\t       OMP_CLAUSE_BIND) == NULL_TREE))\n \t      && gimple_code (stmt) != GIMPLE_OMP_PARALLEL)\n \t    {\n \t      error_at (gimple_location (stmt),\n-\t\t\t\"only %<distribute%> or %<parallel%> regions are \"\n-\t\t\t\"allowed to be strictly nested inside %<teams%> \"\n-\t\t\t\"region\");\n+\t\t\t\"only %<distribute%>, %<parallel%> or %<loop%> \"\n+\t\t\t\"regions are allowed to be strictly nested inside \"\n+\t\t\t\"%<teams%> region\");\n \t      return false;\n \t    }\n \t}\n@@ -2740,10 +2755,15 @@ check_omp_nesting_restrictions (gimple *stmt, omp_context *ctx)\n \t\t   || gimple_omp_for_kind (stmt) != GF_OMP_FOR_KIND_SIMD)\n \t       && gimple_code (stmt) != GIMPLE_OMP_SCAN)\n \t{\n-\t  error_at (gimple_location (stmt),\n-\t\t    \"OpenMP constructs other than %<parallel%> or\"\n-\t\t    \" %<simd%> may not be nested inside a region with\"\n-\t\t    \" the %<order(concurrent)%> clause\");\n+\t  if (ctx->loop_p)\n+\t    error_at (gimple_location (stmt),\n+\t\t      \"OpenMP constructs other than %<parallel%>, %<loop%> or \"\n+\t\t      \"%<simd%> may not be nested inside a %<loop%> region\");\n+\t  else\n+\t    error_at (gimple_location (stmt),\n+\t\t      \"OpenMP constructs other than %<parallel%>, %<loop%> or \"\n+\t\t      \"%<simd%> may not be nested inside a region with \"\n+\t\t      \"the %<order(concurrent)%> clause\");\n \t  return false;\n \t}\n     }\n@@ -2766,6 +2786,11 @@ check_omp_nesting_restrictions (gimple *stmt, omp_context *ctx)\n       /* We split taskloop into task and nested taskloop in it.  */\n       if (gimple_omp_for_kind (stmt) == GF_OMP_FOR_KIND_TASKLOOP)\n \treturn true;\n+      /* For now, hope this will change and loop bind(parallel) will not\n+\t be allowed in lots of contexts.  */\n+      if (gimple_omp_for_kind (stmt) == GF_OMP_FOR_KIND_FOR\n+\t  && omp_find_clause (gimple_omp_for_clauses (stmt), OMP_CLAUSE_BIND))\n+\treturn true;\n       if (gimple_omp_for_kind (stmt) == GF_OMP_FOR_KIND_OACC_LOOP)\n \t{\n \t  bool ok = false;\n@@ -2816,8 +2841,8 @@ check_omp_nesting_restrictions (gimple *stmt, omp_context *ctx)\n \t  const char *construct\n \t    = (DECL_FUNCTION_CODE (gimple_call_fndecl (stmt))\n \t       == BUILT_IN_GOMP_CANCEL)\n-\t      ? \"#pragma omp cancel\"\n-\t      : \"#pragma omp cancellation point\";\n+\t      ? \"cancel\"\n+\t      : \"cancellation point\";\n \t  if (ctx == NULL)\n \t    {\n \t      error_at (gimple_location (stmt), \"orphaned %qs construct\",\n@@ -2830,7 +2855,7 @@ check_omp_nesting_restrictions (gimple *stmt, omp_context *ctx)\n \t    {\n \t    case 1:\n \t      if (gimple_code (ctx->stmt) != GIMPLE_OMP_PARALLEL)\n-\t\tbad = \"#pragma omp parallel\";\n+\t\tbad = \"parallel\";\n \t      else if (DECL_FUNCTION_CODE (gimple_call_fndecl (stmt))\n \t\t       == BUILT_IN_GOMP_CANCEL\n \t\t       && !integer_zerop (gimple_call_arg (stmt, 1)))\n@@ -2840,7 +2865,7 @@ check_omp_nesting_restrictions (gimple *stmt, omp_context *ctx)\n \t    case 2:\n \t      if (gimple_code (ctx->stmt) != GIMPLE_OMP_FOR\n \t\t  || gimple_omp_for_kind (ctx->stmt) != GF_OMP_FOR_KIND_FOR)\n-\t\tbad = \"#pragma omp for\";\n+\t\tbad = \"for\";\n \t      else if (DECL_FUNCTION_CODE (gimple_call_fndecl (stmt))\n \t\t       == BUILT_IN_GOMP_CANCEL\n \t\t       && !integer_zerop (gimple_call_arg (stmt, 1)))\n@@ -2849,20 +2874,20 @@ check_omp_nesting_restrictions (gimple *stmt, omp_context *ctx)\n \t\t  if (omp_find_clause (gimple_omp_for_clauses (ctx->stmt),\n \t\t\t\t       OMP_CLAUSE_NOWAIT))\n \t\t    warning_at (gimple_location (stmt), 0,\n-\t\t\t\t\"%<#pragma omp cancel for%> inside \"\n+\t\t\t\t\"%<cancel for%> inside \"\n \t\t\t\t\"%<nowait%> for construct\");\n \t\t  if (omp_find_clause (gimple_omp_for_clauses (ctx->stmt),\n \t\t\t\t       OMP_CLAUSE_ORDERED))\n \t\t    warning_at (gimple_location (stmt), 0,\n-\t\t\t\t\"%<#pragma omp cancel for%> inside \"\n+\t\t\t\t\"%<cancel for%> inside \"\n \t\t\t\t\"%<ordered%> for construct\");\n \t\t}\n \t      kind = \"for\";\n \t      break;\n \t    case 4:\n \t      if (gimple_code (ctx->stmt) != GIMPLE_OMP_SECTIONS\n \t\t  && gimple_code (ctx->stmt) != GIMPLE_OMP_SECTION)\n-\t\tbad = \"#pragma omp sections\";\n+\t\tbad = \"sections\";\n \t      else if (DECL_FUNCTION_CODE (gimple_call_fndecl (stmt))\n \t\t       == BUILT_IN_GOMP_CANCEL\n \t\t       && !integer_zerop (gimple_call_arg (stmt, 1)))\n@@ -2874,7 +2899,7 @@ check_omp_nesting_restrictions (gimple *stmt, omp_context *ctx)\n \t\t\t\t\t\t\t\t(ctx->stmt),\n \t\t\t\t\t   OMP_CLAUSE_NOWAIT))\n \t\t\twarning_at (gimple_location (stmt), 0,\n-\t\t\t\t    \"%<#pragma omp cancel sections%> inside \"\n+\t\t\t\t    \"%<cancel sections%> inside \"\n \t\t\t\t    \"%<nowait%> sections construct\");\n \t\t    }\n \t\t  else\n@@ -2887,7 +2912,7 @@ check_omp_nesting_restrictions (gimple *stmt, omp_context *ctx)\n \t\t\t\t\t\t\t(ctx->outer->stmt),\n \t\t\t\t\t   OMP_CLAUSE_NOWAIT))\n \t\t\twarning_at (gimple_location (stmt), 0,\n-\t\t\t\t    \"%<#pragma omp cancel sections%> inside \"\n+\t\t\t\t    \"%<cancel sections%> inside \"\n \t\t\t\t    \"%<nowait%> sections construct\");\n \t\t    }\n \t\t}\n@@ -2898,7 +2923,7 @@ check_omp_nesting_restrictions (gimple *stmt, omp_context *ctx)\n \t\t  && (!is_taskloop_ctx (ctx)\n \t\t      || ctx->outer == NULL\n \t\t      || !is_task_ctx (ctx->outer)))\n-\t\tbad = \"#pragma omp task\";\n+\t\tbad = \"task\";\n \t      else\n \t\t{\n \t\t  for (omp_context *octx = ctx->outer;\n@@ -2976,14 +3001,14 @@ check_omp_nesting_restrictions (gimple *stmt, omp_context *ctx)\n \t\t  return true;\n \t\terror_at (gimple_location (stmt),\n \t\t\t  \"barrier region may not be closely nested inside \"\n-\t\t\t  \"of work-sharing, %<critical%>, %<ordered%>, \"\n-\t\t\t  \"%<master%>, explicit %<task%> or %<taskloop%> \"\n-\t\t\t  \"region\");\n+\t\t\t  \"of work-sharing, %<loop%>, %<critical%>, \"\n+\t\t\t  \"%<ordered%>, %<master%>, explicit %<task%> or \"\n+\t\t\t  \"%<taskloop%> region\");\n \t\treturn false;\n \t      }\n \t    error_at (gimple_location (stmt),\n \t\t      \"work-sharing region may not be closely nested inside \"\n-\t\t      \"of work-sharing, %<critical%>, %<ordered%>, \"\n+\t\t      \"of work-sharing, %<loop%>, %<critical%>, %<ordered%>, \"\n \t\t      \"%<master%>, explicit %<task%> or %<taskloop%> region\");\n \t    return false;\n \t  case GIMPLE_OMP_PARALLEL:\n@@ -3012,8 +3037,8 @@ check_omp_nesting_restrictions (gimple *stmt, omp_context *ctx)\n \t  case GIMPLE_OMP_TASK:\n \t    error_at (gimple_location (stmt),\n \t\t      \"%<master%> region may not be closely nested inside \"\n-\t\t      \"of work-sharing, explicit %<task%> or %<taskloop%> \"\n-\t\t      \"region\");\n+\t\t      \"of work-sharing, %<loop%>, explicit %<task%> or \"\n+\t\t      \"%<taskloop%> region\");\n \t    return false;\n \t  case GIMPLE_OMP_PARALLEL:\n \t  case GIMPLE_OMP_TEAMS:\n@@ -3497,11 +3522,12 @@ scan_omp_1_stmt (gimple_stmt_iterator *gsi, bool *handled_ops_p,\n \t  if (ctx\n \t      && gimple_code (ctx->stmt) == GIMPLE_OMP_FOR\n \t      && gimple_omp_for_kind (ctx->stmt) == GF_OMP_FOR_KIND_SIMD\n-\t      && setjmp_or_longjmp_p (fndecl))\n+\t      && setjmp_or_longjmp_p (fndecl)\n+\t      && !ctx->loop_p)\n \t    {\n \t      remove = true;\n \t      error_at (gimple_location (stmt),\n-\t\t\t\"setjmp/longjmp inside simd construct\");\n+\t\t\t\"setjmp/longjmp inside %<simd%> construct\");\n \t    }\n \t  else if (DECL_BUILT_IN_CLASS (fndecl) == BUILT_IN_NORMAL)\n \t    switch (DECL_FUNCTION_CODE (fndecl))"}, {"sha": "adefdb937ab605f7659468ed9093bd0d66568f69", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/554a530ff81870098572832eed8ca00b3593bb41/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/554a530ff81870098572832eed8ca00b3593bb41/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=554a530ff81870098572832eed8ca00b3593bb41", "patch": "@@ -1,5 +1,19 @@\n 2019-07-20  Jakub Jelinek  <jakub@redhat.com>\n \n+\t* c-c++-common/gomp/cancel-1.c: Adjust expected diagnostic wording.\n+\t* c-c++-common/gomp/clauses-1.c (foo, baz, bar): Add order(concurrent)\n+\tclause where allowed.  Add combined constructs with loop with all\n+\tpossible clauses.\n+\t(qux): New function.\n+\t* c-c++-common/gomp/loop-1.c: New test.\n+\t* c-c++-common/gomp/loop-2.c: New test.\n+\t* c-c++-common/gomp/loop-3.c: New test.\n+\t* c-c++-common/gomp/loop-4.c: New test.\n+\t* c-c++-common/gomp/loop-5.c: New test.\n+\t* c-c++-common/gomp/order-3.c: Adjust expected diagnostic wording.\n+\t* c-c++-common/gomp/simd-setjmp-1.c: New test.\n+\t* c-c++-common/gomp/teams-2.c: Adjust expected diagnostic wording.\n+\n \t* gcc.dg/vect/vect-simd-16.c: New test.\n \n 2019-07-19  Jeff Law  <law@redhat.com>"}, {"sha": "5255dd3e2a5178f26cef08440cff611de9f7e248", "filename": "gcc/testsuite/c-c++-common/gomp/cancel-1.c", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/554a530ff81870098572832eed8ca00b3593bb41/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Fcancel-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/554a530ff81870098572832eed8ca00b3593bb41/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Fcancel-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Fcancel-1.c?ref=554a530ff81870098572832eed8ca00b3593bb41", "patch": "@@ -336,14 +336,14 @@ f2 (void)\n   }\n   #pragma omp target teams\n   {\n-    #pragma omp cancel parallel\t\t\t/* { dg-error \"only .distribute. or .parallel. regions are allowed to be strictly nested\" } */\n-    #pragma omp cancel for\t\t\t/* { dg-error \"only .distribute. or .parallel. regions are allowed to be strictly nested\" } */\n-    #pragma omp cancel sections\t\t\t/* { dg-error \"only .distribute. or .parallel. regions are allowed to be strictly nested\" } */\n-    #pragma omp cancel taskgroup\t\t/* { dg-error \"only .distribute. or .parallel. regions are allowed to be strictly nested\" } */\n-    #pragma omp cancellation point parallel\t/* { dg-error \"only .distribute. or .parallel. regions are allowed to be strictly nested\" } */\n-    #pragma omp cancellation point for\t\t/* { dg-error \"only .distribute. or .parallel. regions are allowed to be strictly nested\" } */\n-    #pragma omp cancellation point sections\t/* { dg-error \"only .distribute. or .parallel. regions are allowed to be strictly nested\" } */\n-    #pragma omp cancellation point taskgroup\t/* { dg-error \"only .distribute. or .parallel. regions are allowed to be strictly nested\" } */\n+    #pragma omp cancel parallel\t\t\t/* { dg-error \"only .distribute., .parallel. or .loop. regions are allowed to be strictly nested\" } */\n+    #pragma omp cancel for\t\t\t/* { dg-error \"only .distribute., .parallel. or .loop. regions are allowed to be strictly nested\" } */\n+    #pragma omp cancel sections\t\t\t/* { dg-error \"only .distribute., .parallel. or .loop. regions are allowed to be strictly nested\" } */\n+    #pragma omp cancel taskgroup\t\t/* { dg-error \"only .distribute., .parallel. or .loop. regions are allowed to be strictly nested\" } */\n+    #pragma omp cancellation point parallel\t/* { dg-error \"only .distribute., .parallel. or .loop. regions are allowed to be strictly nested\" } */\n+    #pragma omp cancellation point for\t\t/* { dg-error \"only .distribute., .parallel. or .loop. regions are allowed to be strictly nested\" } */\n+    #pragma omp cancellation point sections\t/* { dg-error \"only .distribute., .parallel. or .loop. regions are allowed to be strictly nested\" } */\n+    #pragma omp cancellation point taskgroup\t/* { dg-error \"only .distribute., .parallel. or .loop. regions are allowed to be strictly nested\" } */\n   }\n   #pragma omp target teams distribute\n   for (i = 0; i < 10; i++)"}, {"sha": "be427979135bf106772c3f55b871a8fb2335f5ac", "filename": "gcc/testsuite/c-c++-common/gomp/clauses-1.c", "status": "modified", "additions": 107, "deletions": 26, "changes": 133, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/554a530ff81870098572832eed8ca00b3593bb41/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Fclauses-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/554a530ff81870098572832eed8ca00b3593bb41/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Fclauses-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Fclauses-1.c?ref=554a530ff81870098572832eed8ca00b3593bb41", "patch": "@@ -14,22 +14,32 @@ foo (int d, int m, int i1, int i2, int p, int *idp, int s,\n   #pragma omp distribute parallel for \\\n     private (p) firstprivate (f) collapse(1) dist_schedule(static, 16) \\\n     if (parallel: i2) default(shared) shared(s) reduction(+:r) num_threads (nth) proc_bind(spread) \\\n-    lastprivate (l) schedule(static, 4)\n+    lastprivate (l) schedule(static, 4) order(concurrent)\n   for (int i = 0; i < 64; i++)\n     ll++;\n   #pragma omp distribute parallel for simd \\\n     private (p) firstprivate (f) collapse(1) dist_schedule(static, 16) \\\n     if (parallel: i2) if(simd: i1) default(shared) shared(s) reduction(+:r) num_threads (nth) proc_bind(spread) \\\n     lastprivate (l) schedule(static, 4) nontemporal(ntm) \\\n-    safelen(8) simdlen(4) aligned(q: 32)\n+    safelen(8) simdlen(4) aligned(q: 32) order(concurrent)\n   for (int i = 0; i < 64; i++)\n     ll++;\n   #pragma omp distribute simd \\\n     private (p) firstprivate (f) collapse(1) dist_schedule(static, 16) \\\n-    safelen(8) simdlen(4) aligned(q: 32) reduction(+:r) if(i1) nontemporal(ntm)\n+    safelen(8) simdlen(4) aligned(q: 32) reduction(+:r) if(i1) nontemporal(ntm) \\\n+    order(concurrent)\n   for (int i = 0; i < 64; i++)\n     ll++;\n }\n+\n+void\n+qux (int p)\n+{\n+  #pragma omp loop bind(teams) order(concurrent) \\\n+    private (p) lastprivate (l) collapse(1) reduction(+:r)\n+  for (l = 0; l < 64; ++l)\n+    ll++;\n+}\n #pragma omp end declare target\n \n void\n@@ -39,21 +49,26 @@ baz (int d, int m, int i1, int i2, int p, int *idp, int s,\n   #pragma omp distribute parallel for \\\n     private (p) firstprivate (f) collapse(1) dist_schedule(static, 16) \\\n     if (parallel: i2) default(shared) shared(s) reduction(+:r) num_threads (nth) proc_bind(spread) \\\n-    lastprivate (l) schedule(static, 4) copyin(t)\n+    lastprivate (l) schedule(static, 4) copyin(t) order(concurrent)\n   for (int i = 0; i < 64; i++)\n     ll++;\n   #pragma omp distribute parallel for simd \\\n     private (p) firstprivate (f) collapse(1) dist_schedule(static, 16) \\\n     if (parallel: i2) if(simd: i1) default(shared) shared(s) reduction(+:r) num_threads (nth) proc_bind(spread) \\\n     lastprivate (l) schedule(static, 4) nontemporal(ntm) \\\n-    safelen(8) simdlen(4) aligned(q: 32) copyin(t)\n+    safelen(8) simdlen(4) aligned(q: 32) copyin(t) order(concurrent)\n   for (int i = 0; i < 64; i++)\n     ll++;\n   #pragma omp distribute simd \\\n     private (p) firstprivate (f) collapse(1) dist_schedule(static, 16) \\\n-    safelen(8) simdlen(4) aligned(q: 32) reduction(+:r) if(i1) nontemporal(ntm)\n+    safelen(8) simdlen(4) aligned(q: 32) reduction(+:r) if(i1) nontemporal(ntm) \\\n+    order(concurrent)\n   for (int i = 0; i < 64; i++)\n     ll++;\n+  #pragma omp loop bind(parallel) order(concurrent) \\\n+    private (p) lastprivate (l) collapse(1) reduction(+:r)\n+  for (l = 0; l < 64; ++l)\n+    ll++;\n }\n \n void\n@@ -62,18 +77,23 @@ bar (int d, int m, int i1, int i2, int i3, int p, int *idp, int s,\n {\n   #pragma omp for simd \\\n     private (p) firstprivate (f) lastprivate (l) linear (ll:1) reduction(+:r) schedule(static, 4) collapse(1) nowait \\\n-    safelen(8) simdlen(4) aligned(q: 32) nontemporal(ntm) if(i1)\n+    safelen(8) simdlen(4) aligned(q: 32) nontemporal(ntm) if(i1) order(concurrent)\n   for (int i = 0; i < 64; i++)\n     ll++;\n   #pragma omp parallel for \\\n     private (p) firstprivate (f) if (parallel: i2) default(shared) shared(s) copyin(t) reduction(+:r) num_threads (nth) proc_bind(spread) \\\n     lastprivate (l) linear (ll:1) ordered schedule(static, 4) collapse(1)\n   for (int i = 0; i < 64; i++)\n     ll++;\n+  #pragma omp parallel for \\\n+    private (p) firstprivate (f) if (parallel: i2) default(shared) shared(s) copyin(t) reduction(+:r) num_threads (nth) proc_bind(spread) \\\n+    lastprivate (l) linear (ll:1) schedule(static, 4) collapse(1) order(concurrent)\n+  for (int i = 0; i < 64; i++)\n+    ll++;\n   #pragma omp parallel for simd \\\n     private (p) firstprivate (f) if (i2) default(shared) shared(s) copyin(t) reduction(+:r) num_threads (nth) proc_bind(spread) \\\n     lastprivate (l) linear (ll:1) schedule(static, 4) collapse(1) \\\n-    safelen(8) simdlen(4) aligned(q: 32) nontemporal(ntm)\n+    safelen(8) simdlen(4) aligned(q: 32) nontemporal(ntm) order(concurrent)\n   for (int i = 0; i < 64; i++)\n     ll++;\n   #pragma omp parallel sections \\\n@@ -96,11 +116,17 @@ bar (int d, int m, int i1, int i2, int i3, int p, int *idp, int s,\n     lastprivate (l) linear (ll:1) ordered schedule(static, 4) collapse(1) nowait depend(inout: dd[0])\n   for (int i = 0; i < 64; i++)\n     ll++;\n+  #pragma omp target parallel for \\\n+    device(d) map (tofrom: m) if (target: i1) private (p) firstprivate (f) defaultmap(tofrom: scalar) is_device_ptr (idp) \\\n+    if (parallel: i2) default(shared) shared(s) reduction(+:r) num_threads (nth) proc_bind(spread) \\\n+    lastprivate (l) linear (ll:1) schedule(static, 4) collapse(1) nowait depend(inout: dd[0]) order(concurrent)\n+  for (int i = 0; i < 64; i++)\n+    ll++;\n   #pragma omp target parallel for simd \\\n     device(d) map (tofrom: m) if (target: i1) private (p) firstprivate (f) defaultmap(tofrom: scalar) is_device_ptr (idp) \\\n     if (parallel: i2) default(shared) shared(s) reduction(+:r) num_threads (nth) proc_bind(spread) \\\n     lastprivate (l) linear (ll:1) schedule(static, 4) collapse(1) \\\n-    safelen(8) simdlen(4) aligned(q: 32) nowait depend(inout: dd[0]) nontemporal(ntm) if (simd: i3)\n+    safelen(8) simdlen(4) aligned(q: 32) nowait depend(inout: dd[0]) nontemporal(ntm) if (simd: i3) order(concurrent)\n   for (int i = 0; i < 64; i++)\n     ll++;\n   #pragma omp target teams \\\n@@ -118,47 +144,50 @@ bar (int d, int m, int i1, int i2, int i3, int p, int *idp, int s,\n     shared(s) default(shared) reduction(+:r) num_teams(nte) thread_limit(tl) \\\n     collapse(1) dist_schedule(static, 16) \\\n     if (parallel: i2) num_threads (nth) proc_bind(spread) \\\n-    lastprivate (l) schedule(static, 4) nowait depend(inout: dd[0])\n+    lastprivate (l) schedule(static, 4) nowait depend(inout: dd[0]) order(concurrent)\n   for (int i = 0; i < 64; i++)\n     ll++;\n   #pragma omp target teams distribute parallel for simd \\\n     device(d) map (tofrom: m) if (target: i1) private (p) firstprivate (f) defaultmap(tofrom: scalar) is_device_ptr (idp) \\\n     shared(s) default(shared) reduction(+:r) num_teams(nte) thread_limit(tl) \\\n     collapse(1) dist_schedule(static, 16) \\\n     if (parallel: i2) num_threads (nth) proc_bind(spread) \\\n-    lastprivate (l) schedule(static, 4) \\\n+    lastprivate (l) schedule(static, 4) order(concurrent) \\\n     safelen(8) simdlen(4) aligned(q: 32) nowait depend(inout: dd[0]) nontemporal(ntm) if (simd: i3)\n   for (int i = 0; i < 64; i++)\n     ll++;\n   #pragma omp target teams distribute simd \\\n     device(d) map (tofrom: m) if (i1) private (p) firstprivate (f) defaultmap(tofrom: scalar) is_device_ptr (idp) \\\n     shared(s) default(shared) reduction(+:r) num_teams(nte) thread_limit(tl) \\\n-    collapse(1) dist_schedule(static, 16) \\\n+    collapse(1) dist_schedule(static, 16) order(concurrent) \\\n     safelen(8) simdlen(4) aligned(q: 32) nowait depend(inout: dd[0]) nontemporal(ntm)\n   for (int i = 0; i < 64; i++)\n     ll++;\n   #pragma omp target simd \\\n     device(d) map (tofrom: m) if (target: i1) private (p) firstprivate (f) defaultmap(tofrom: scalar) is_device_ptr (idp) \\\n     safelen(8) simdlen(4) lastprivate (l) linear(ll: 1) aligned(q: 32) reduction(+:r) \\\n-     nowait depend(inout: dd[0]) nontemporal(ntm) if(simd:i3)\n+     nowait depend(inout: dd[0]) nontemporal(ntm) if(simd:i3) order(concurrent)\n   for (int i = 0; i < 64; i++)\n     ll++;\n   #pragma omp taskgroup task_reduction(+:r2)\n   #pragma omp taskloop simd \\\n     private (p) firstprivate (f) lastprivate (l) shared (s) default(shared) grainsize (g) collapse(1) untied if(taskloop: i1) if(simd: i2) final(fi) mergeable priority (pp) \\\n-    safelen(8) simdlen(4) linear(ll: 1) aligned(q: 32) reduction(default, +:r) in_reduction(+:r2) nontemporal(ntm)\n+    safelen(8) simdlen(4) linear(ll: 1) aligned(q: 32) reduction(default, +:r) in_reduction(+:r2) nontemporal(ntm) \\\n+    order(concurrent)\n   for (int i = 0; i < 64; i++)\n     ll++;\n   #pragma omp taskgroup task_reduction(+:r)\n   #pragma omp taskloop simd \\\n     private (p) firstprivate (f) lastprivate (l) shared (s) default(shared) grainsize (g) collapse(1) untied if(i1) final(fi) mergeable nogroup priority (pp) \\\n-    safelen(8) simdlen(4) linear(ll: 1) aligned(q: 32) in_reduction(+:r) nontemporal(ntm)\n+    safelen(8) simdlen(4) linear(ll: 1) aligned(q: 32) in_reduction(+:r) nontemporal(ntm) \\\n+    order(concurrent)\n   for (int i = 0; i < 64; i++)\n     ll++;\n   #pragma omp taskwait\n   #pragma omp taskloop simd \\\n     private (p) firstprivate (f) lastprivate (l) shared (s) default(shared) num_tasks (nta) collapse(1) if(taskloop: i1) final(fi) priority (pp) \\\n-    safelen(8) simdlen(4) linear(ll: 1) aligned(q: 32) reduction(+:r) if (simd: i3) nontemporal(ntm)\n+    safelen(8) simdlen(4) linear(ll: 1) aligned(q: 32) reduction(+:r) if (simd: i3) nontemporal(ntm) \\\n+    order(concurrent)\n   for (int i = 0; i < 64; i++)\n     ll++;\n   #pragma omp target nowait depend(inout: dd[0])\n@@ -172,28 +201,28 @@ bar (int d, int m, int i1, int i2, int i3, int p, int *idp, int s,\n     private(p) firstprivate (f) shared(s) default(shared) reduction(+:r) num_teams(nte) thread_limit(tl) \\\n     collapse(1) dist_schedule(static, 16) \\\n     if (parallel: i2) num_threads (nth) proc_bind(spread) \\\n-    lastprivate (l) schedule(static, 4)\n+    lastprivate (l) schedule(static, 4) order(concurrent)\n   for (int i = 0; i < 64; i++)\n     ll++;\n   #pragma omp target\n   #pragma omp teams distribute parallel for simd \\\n     private(p) firstprivate (f) shared(s) default(shared) reduction(+:r) num_teams(nte) thread_limit(tl) \\\n     collapse(1) dist_schedule(static, 16) \\\n     if (parallel: i2) num_threads (nth) proc_bind(spread) \\\n-    lastprivate (l) schedule(static, 4) \\\n+    lastprivate (l) schedule(static, 4) order(concurrent) \\\n     safelen(8) simdlen(4) aligned(q: 32) if (simd: i3) nontemporal(ntm)\n   for (int i = 0; i < 64; i++)\n     ll++;\n   #pragma omp target\n   #pragma omp teams distribute simd \\\n     private(p) firstprivate (f) shared(s) default(shared) reduction(+:r) num_teams(nte) thread_limit(tl) \\\n-    collapse(1) dist_schedule(static, 16) \\\n+    collapse(1) dist_schedule(static, 16) order(concurrent) \\\n     safelen(8) simdlen(4) aligned(q: 32) if(i3) nontemporal(ntm)\n   for (int i = 0; i < 64; i++)\n     ll++;\n   #pragma omp teams distribute parallel for \\\n     private(p) firstprivate (f) shared(s) default(shared) reduction(+:r) num_teams(nte) thread_limit(tl) \\\n-    collapse(1) dist_schedule(static, 16) \\\n+    collapse(1) dist_schedule(static, 16) order(concurrent) \\\n     if (parallel: i2) num_threads (nth) proc_bind(spread) \\\n     lastprivate (l) schedule(static, 4) copyin(t)\n   for (int i = 0; i < 64; i++)\n@@ -202,13 +231,13 @@ bar (int d, int m, int i1, int i2, int i3, int p, int *idp, int s,\n     private(p) firstprivate (f) shared(s) default(shared) reduction(+:r) num_teams(nte) thread_limit(tl) \\\n     collapse(1) dist_schedule(static, 16) \\\n     if (parallel: i2) num_threads (nth) proc_bind(spread) \\\n-    lastprivate (l) schedule(static, 4) \\\n+    lastprivate (l) schedule(static, 4) order(concurrent) \\\n     safelen(8) simdlen(4) aligned(q: 32) if (simd: i3) nontemporal(ntm) copyin(t)\n   for (int i = 0; i < 64; i++)\n     ll++;\n   #pragma omp teams distribute simd \\\n     private(p) firstprivate (f) shared(s) default(shared) reduction(+:r) num_teams(nte) thread_limit(tl) \\\n-    collapse(1) dist_schedule(static, 16) \\\n+    collapse(1) dist_schedule(static, 16) order(concurrent) \\\n     safelen(8) simdlen(4) aligned(q: 32) if(i3) nontemporal(ntm)\n   for (int i = 0; i < 64; i++)\n     ll++;\n@@ -225,7 +254,8 @@ bar (int d, int m, int i1, int i2, int i3, int p, int *idp, int s,\n   #pragma omp taskgroup task_reduction (+:r2)\n   #pragma omp master taskloop simd \\\n     private (p) firstprivate (f) lastprivate (l) shared (s) default(shared) grainsize (g) collapse(1) untied if(taskloop: i1) if(simd: i2) final(fi) mergeable priority (pp) \\\n-    safelen(8) simdlen(4) linear(ll: 1) aligned(q: 32) reduction(default, +:r) in_reduction(+:r2) nontemporal(ntm)\n+    safelen(8) simdlen(4) linear(ll: 1) aligned(q: 32) reduction(default, +:r) in_reduction(+:r2) nontemporal(ntm) \\\n+    order(concurrent)\n   for (int i = 0; i < 64; i++)\n     ll++;\n   #pragma omp parallel master taskloop \\\n@@ -235,7 +265,8 @@ bar (int d, int m, int i1, int i2, int i3, int p, int *idp, int s,\n     ll++;\n   #pragma omp parallel master taskloop simd \\\n     private (p) firstprivate (f) lastprivate (l) shared (s) default(shared) grainsize (g) collapse(1) untied if(taskloop: i1) if(simd: i2) final(fi) mergeable priority (pp) \\\n-    safelen(8) simdlen(4) linear(ll: 1) aligned(q: 32) reduction(default, +:r) nontemporal(ntm) if (parallel: i2) num_threads (nth) proc_bind(spread) copyin(t)\n+    safelen(8) simdlen(4) linear(ll: 1) aligned(q: 32) reduction(default, +:r) nontemporal(ntm) if (parallel: i2) num_threads (nth) proc_bind(spread) copyin(t) \\\n+    order(concurrent)\n   for (int i = 0; i < 64; i++)\n     ll++;\n   #pragma omp taskgroup task_reduction (+:r2)\n@@ -247,7 +278,8 @@ bar (int d, int m, int i1, int i2, int i3, int p, int *idp, int s,\n   #pragma omp taskgroup task_reduction (+:r2)\n   #pragma omp master taskloop simd \\\n     private (p) firstprivate (f) lastprivate (l) shared (s) default(shared) num_tasks (nta) collapse(1) untied if(i1) final(fi) mergeable priority (pp) \\\n-    safelen(8) simdlen(4) linear(ll: 1) aligned(q: 32) reduction(default, +:r) in_reduction(+:r2) nontemporal(ntm)\n+    safelen(8) simdlen(4) linear(ll: 1) aligned(q: 32) reduction(default, +:r) in_reduction(+:r2) nontemporal(ntm) \\\n+    order(concurrent)\n   for (int i = 0; i < 64; i++)\n     ll++;\n   #pragma omp parallel master taskloop \\\n@@ -257,7 +289,56 @@ bar (int d, int m, int i1, int i2, int i3, int p, int *idp, int s,\n     ll++;\n   #pragma omp parallel master taskloop simd \\\n     private (p) firstprivate (f) lastprivate (l) shared (s) default(shared) num_tasks (nta) collapse(1) untied if(i1) final(fi) mergeable priority (pp) \\\n-    safelen(8) simdlen(4) linear(ll: 1) aligned(q: 32) reduction(default, +:r) nontemporal(ntm) num_threads (nth) proc_bind(spread) copyin(t)\n+    safelen(8) simdlen(4) linear(ll: 1) aligned(q: 32) reduction(default, +:r) nontemporal(ntm) num_threads (nth) proc_bind(spread) copyin(t) \\\n+    order(concurrent)\n   for (int i = 0; i < 64; i++)\n     ll++;\n+  #pragma omp loop bind(thread) order(concurrent) \\\n+    private (p) lastprivate (l) collapse(1) reduction(+:r)\n+  for (l = 0; l < 64; ++l)\n+    ll++;\n+  #pragma omp parallel loop \\\n+    private (p) firstprivate (f) if (parallel: i2) default(shared) shared(s) copyin(t) reduction(+:r) num_threads (nth) proc_bind(spread) \\\n+    lastprivate (l) collapse(1) bind(parallel) order(concurrent)\n+  for (l = 0; l < 64; l++)\n+    ll++;\n+  #pragma omp parallel loop \\\n+    private (p) firstprivate (f) if (parallel: i2) default(shared) shared(s) copyin(t) reduction(+:r) num_threads (nth) proc_bind(spread) \\\n+    lastprivate (l) collapse(1)\n+  for (l = 0; l < 64; l++)\n+    ll++;\n+  #pragma omp teams loop \\\n+    private(p) firstprivate (f) shared(s) default(shared) reduction(+:r) num_teams(nte) thread_limit(tl) \\\n+    collapse(1) lastprivate (l) bind(teams)\n+  for (l = 0; l < 64; ++l)\n+    ;\n+  #pragma omp teams loop \\\n+    private(p) firstprivate (f) shared(s) default(shared) reduction(+:r) num_teams(nte) thread_limit(tl) \\\n+    collapse(1) lastprivate (l) order(concurrent)\n+  for (l = 0; l < 64; ++l)\n+    ;\n+  #pragma omp target parallel loop \\\n+    device(d) map (tofrom: m) if (target: i1) private (p) firstprivate (f) defaultmap(tofrom: scalar) is_device_ptr (idp) \\\n+    if (parallel: i2) default(shared) shared(s) reduction(+:r) num_threads (nth) proc_bind(spread) \\\n+    nowait depend(inout: dd[0]) lastprivate (l) bind(parallel) order(concurrent) collapse(1)\n+  for (l = 0; l < 64; ++l)\n+    ;\n+  #pragma omp target parallel loop \\\n+    device(d) map (tofrom: m) if (target: i1) private (p) firstprivate (f) defaultmap(tofrom: scalar) is_device_ptr (idp) \\\n+    if (parallel: i2) default(shared) shared(s) reduction(+:r) num_threads (nth) proc_bind(spread) \\\n+    nowait depend(inout: dd[0]) lastprivate (l) order(concurrent) collapse(1)\n+  for (l = 0; l < 64; ++l)\n+    ;\n+  #pragma omp target teams loop \\\n+    device(d) map (tofrom: m) if (target: i1) private (p) firstprivate (f) defaultmap(tofrom: scalar) is_device_ptr (idp) \\\n+    shared(s) default(shared) reduction(+:r) num_teams(nte) thread_limit(tl) nowait depend(inout: dd[0]) \\\n+    lastprivate (l) bind(teams) collapse(1)\n+  for (l = 0; l < 64; ++l)\n+    ;\n+  #pragma omp target teams loop \\\n+    device(d) map (tofrom: m) if (target: i1) private (p) firstprivate (f) defaultmap(tofrom: scalar) is_device_ptr (idp) \\\n+    shared(s) default(shared) reduction(+:r) num_teams(nte) thread_limit(tl) nowait depend(inout: dd[0]) \\\n+    lastprivate (l) order(concurrent) collapse(1)\n+  for (l = 0; l < 64; ++l)\n+    ;\n }"}, {"sha": "d2f943aea5468abfcbf367ef2851d601e39c39b8", "filename": "gcc/testsuite/c-c++-common/gomp/loop-1.c", "status": "added", "additions": 271, "deletions": 0, "changes": 271, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/554a530ff81870098572832eed8ca00b3593bb41/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Floop-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/554a530ff81870098572832eed8ca00b3593bb41/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Floop-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Floop-1.c?ref=554a530ff81870098572832eed8ca00b3593bb41", "patch": "@@ -0,0 +1,271 @@\n+void foo (void);\n+int v;\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+int omp_get_thread_num (void);\n+int omp_get_num_threads (void);\n+int omp_target_is_present (const void *, int);\n+int omp_get_cancellation (void);\n+#ifdef __cplusplus\n+}\n+#endif\n+\n+void\n+f1 (int *a)\n+{\n+  int i;\n+  #pragma omp simd order(concurrent)\n+  for (i = 0; i < 64; i++)\n+    {\n+      int j;\n+      #pragma omp loop\n+      for (j = 0; j < 64; j++)\n+\ta[64 * i + j] = i + j;\n+    }\n+}\n+\n+void\n+f2 (int *a)\n+{\n+  int i;\n+  #pragma omp for simd order(concurrent)\n+  for (i = 0; i < 64; i++)\n+    {\n+      int j;\n+      #pragma omp loop\n+      for (j = 0; j < 64; j++)\n+\ta[64 * i + j] = i + j;\n+    }\n+}\n+\n+void\n+f3 (int *a)\n+{\n+  int i;\n+  #pragma omp for order(concurrent)\n+  for (i = 0; i < 64; i++)\n+    {\n+      int j;\n+      #pragma omp loop\n+      for (j = 0; j < 64; j++)\n+\ta[64 * i + j] = i + j;\n+    }\n+}\n+\n+void\n+f4 (int *a)\n+{\n+  int i;\n+  #pragma omp loop order(concurrent) bind(parallel)\n+  for (i = 0; i < 64; i++)\n+    {\n+      #pragma omp parallel\n+      foo ();\n+    }\n+  #pragma omp loop order(concurrent) bind(parallel)\n+  for (i = 0; i < 64; i++)\n+    {\n+      int j;\n+      #pragma omp simd\n+      for (j = 0; j < 64; j++)\n+\ta[64 * i + j] = i + j;\n+    }\n+  #pragma omp loop order(concurrent) bind(parallel)\n+  for (i = 0; i < 64; i++)\n+    {\n+      int j;\n+      #pragma omp loop\n+      for (j = 0; j < 64; j++)\n+\ta[64 * i + j] = i + j;\n+    }\n+  #pragma omp loop order(concurrent) bind(parallel)\n+  for (i = 0; i < 64; i++)\n+    {\n+      #pragma omp critical\t\t/* { dg-error \"OpenMP constructs other than 'parallel', 'loop' or 'simd' may not be nested inside a 'loop' region\" } */\n+      foo ();\n+    }\n+  #pragma omp loop order(concurrent) bind(parallel)\n+  for (i = 0; i < 64; i++)\n+    {\n+      #pragma omp ordered simd\t\t/* { dg-error \"OpenMP constructs other than 'parallel', 'loop' or 'simd' may not be nested inside a 'loop' region\" } */\n+      foo ();\n+    }\n+  #pragma omp loop order(concurrent) bind(parallel)\n+  for (i = 0; i < 64; i++)\n+    {\n+      #pragma omp atomic\t\t/* { dg-error \"OpenMP constructs other than 'parallel', 'loop' or 'simd' may not be nested inside a 'loop' region\" } */\n+      v++;\n+    }\n+  #pragma omp loop order(concurrent) bind(parallel)\n+  for (i = 0; i < 64; i++)\n+    {\n+      #pragma omp atomic read\n+      a[i] = v;\t\t\t\t/* { dg-error \"OpenMP constructs other than 'parallel', 'loop' or 'simd' may not be nested inside a 'loop' region\" } */\n+    }\n+  #pragma omp loop order(concurrent) bind(parallel)\n+  for (i = 0; i < 64; i++)\n+    {\n+      #pragma omp atomic write\t\t/* { dg-error \"OpenMP constructs other than 'parallel', 'loop' or 'simd' may not be nested inside a 'loop' region\" \"\" { target c++ } } */\n+      v = a[i];\t\t\t\t/* { dg-error \"OpenMP constructs other than 'parallel', 'loop' or 'simd' may not be nested inside a 'loop' region\" \"\" { target c } } */\n+    }\n+  #pragma omp loop order(concurrent) bind(parallel)\n+  for (i = 0; i < 64; i++)\n+    a[i] += omp_get_thread_num ();\t/* { dg-error \"OpenMP runtime API call '\\[^\\n\\r]*omp_get_thread_num\\[^\\n\\r]*' in a region with 'order\\\\(concurrent\\\\)' clause\" } */\n+  #pragma omp loop order(concurrent) bind(parallel)\n+  for (i = 0; i < 64; i++)\n+    a[i] += omp_get_num_threads ();\t/* { dg-error \"OpenMP runtime API call '\\[^\\n\\r]*omp_get_num_threads\\[^\\n\\r]*' in a region with 'order\\\\(concurrent\\\\)' clause\" } */\n+  #pragma omp loop order(concurrent) bind(parallel)\n+  for (i = 0; i < 64; i++)\n+    a[i] += omp_target_is_present (a + i, 0);\t/* { dg-error \"OpenMP runtime API call '\\[^\\n\\r]*omp_target_is_present\\[^\\n\\r]*' in a region with 'order\\\\(concurrent\\\\)' clause\" } */\n+  #pragma omp loop order(concurrent) bind(parallel)\n+  for (i = 0; i < 64; i++)\n+    a[i] += omp_get_cancellation ();\t/* { dg-error \"OpenMP runtime API call '\\[^\\n\\r]*omp_get_cancellation\\[^\\n\\r]*' in a region with 'order\\\\(concurrent\\\\)' clause\" } */\n+}\n+\n+void\n+f5 (int *a)\n+{\n+  int i;\n+  #pragma omp parallel\n+  {\n+  #pragma omp loop\n+  for (i = 0; i < 64; i++)\n+    {\n+      #pragma omp parallel\n+      foo ();\n+    }\n+  #pragma omp loop\n+  for (i = 0; i < 64; i++)\n+    {\n+      int j;\n+      #pragma omp simd\n+      for (j = 0; j < 64; j++)\n+\ta[64 * i + j] = i + j;\n+    }\n+  #pragma omp loop\n+  for (i = 0; i < 64; i++)\n+    {\n+      int j;\n+      #pragma omp loop\n+      for (j = 0; j < 64; j++)\n+\ta[64 * i + j] = i + j;\n+    }\n+  #pragma omp loop\n+  for (i = 0; i < 64; i++)\n+    {\n+      #pragma omp critical\t\t/* { dg-error \"OpenMP constructs other than 'parallel', 'loop' or 'simd' may not be nested inside a 'loop' region\" } */\n+      foo ();\n+    }\n+  #pragma omp loop\n+  for (i = 0; i < 64; i++)\n+    {\n+      #pragma omp ordered simd\t\t/* { dg-error \"OpenMP constructs other than 'parallel', 'loop' or 'simd' may not be nested inside a 'loop' region\" } */\n+      foo ();\n+    }\n+  #pragma omp loop\n+  for (i = 0; i < 64; i++)\n+    {\n+      #pragma omp atomic\t\t/* { dg-error \"OpenMP constructs other than 'parallel', 'loop' or 'simd' may not be nested inside a 'loop' region\" } */\n+      v++;\n+    }\n+  #pragma omp loop\n+  for (i = 0; i < 64; i++)\n+    {\n+      #pragma omp atomic read\n+      a[i] = v;\t\t\t\t/* { dg-error \"OpenMP constructs other than 'parallel', 'loop' or 'simd' may not be nested inside a 'loop' region\" } */\n+    }\n+  #pragma omp loop\n+  for (i = 0; i < 64; i++)\n+    {\n+      #pragma omp atomic write\t\t/* { dg-error \"OpenMP constructs other than 'parallel', 'loop' or 'simd' may not be nested inside a 'loop' region\" \"\" { target c++ } } */\n+      v = a[i];\t\t\t\t/* { dg-error \"OpenMP constructs other than 'parallel', 'loop' or 'simd' may not be nested inside a 'loop' region\" \"\" { target c } } */\n+    }\n+  #pragma omp loop\n+  for (i = 0; i < 64; i++)\n+    a[i] += omp_get_thread_num ();\t/* { dg-error \"OpenMP runtime API call '\\[^\\n\\r]*omp_get_thread_num\\[^\\n\\r]*' in a region with 'order\\\\(concurrent\\\\)' clause\" } */\n+  #pragma omp loop\n+  for (i = 0; i < 64; i++)\n+    a[i] += omp_get_num_threads ();\t/* { dg-error \"OpenMP runtime API call '\\[^\\n\\r]*omp_get_num_threads\\[^\\n\\r]*' in a region with 'order\\\\(concurrent\\\\)' clause\" } */\n+  #pragma omp loop\n+  for (i = 0; i < 64; i++)\n+    a[i] += omp_target_is_present (a + i, 0);\t/* { dg-error \"OpenMP runtime API call '\\[^\\n\\r]*omp_target_is_present\\[^\\n\\r]*' in a region with 'order\\\\(concurrent\\\\)' clause\" } */\n+  #pragma omp loop\n+  for (i = 0; i < 64; i++)\n+    a[i] += omp_get_cancellation ();\t/* { dg-error \"OpenMP runtime API call '\\[^\\n\\r]*omp_get_cancellation\\[^\\n\\r]*' in a region with 'order\\\\(concurrent\\\\)' clause\" } */\n+  }\n+}\n+\n+void\n+f6 (int *a)\n+{\n+  int i;\n+  #pragma omp master\n+  {\n+  #pragma omp loop\n+  for (i = 0; i < 64; i++)\n+    {\n+      #pragma omp parallel\n+      foo ();\n+    }\n+  #pragma omp loop\n+  for (i = 0; i < 64; i++)\n+    {\n+      int j;\n+      #pragma omp simd\n+      for (j = 0; j < 64; j++)\n+\ta[64 * i + j] = i + j;\n+    }\n+  #pragma omp loop\n+  for (i = 0; i < 64; i++)\n+    {\n+      int j;\n+      #pragma omp loop\n+      for (j = 0; j < 64; j++)\n+\ta[64 * i + j] = i + j;\n+    }\n+  #pragma omp loop\n+  for (i = 0; i < 64; i++)\n+    {\n+      #pragma omp critical\t\t/* { dg-error \"OpenMP constructs other than 'parallel', 'loop' or 'simd' may not be nested inside a 'loop' region\" } */\n+      foo ();\n+    }\n+  #pragma omp loop\n+  for (i = 0; i < 64; i++)\n+    {\n+      #pragma omp ordered simd\t\t/* { dg-error \"OpenMP constructs other than 'parallel', 'loop' or 'simd' may not be nested inside a 'loop' region\" } */\n+      foo ();\n+    }\n+  #pragma omp loop\n+  for (i = 0; i < 64; i++)\n+    {\n+      #pragma omp atomic\t\t/* { dg-error \"OpenMP constructs other than 'parallel', 'loop' or 'simd' may not be nested inside a 'loop' region\" } */\n+      v++;\n+    }\n+  #pragma omp loop\n+  for (i = 0; i < 64; i++)\n+    {\n+      #pragma omp atomic read\n+      a[i] = v;\t\t\t\t/* { dg-error \"OpenMP constructs other than 'parallel', 'loop' or 'simd' may not be nested inside a 'loop' region\" } */\n+    }\n+  #pragma omp loop\n+  for (i = 0; i < 64; i++)\n+    {\n+      #pragma omp atomic write\t\t/* { dg-error \"OpenMP constructs other than 'parallel', 'loop' or 'simd' may not be nested inside a 'loop' region\" \"\" { target c++ } } */\n+      v = a[i];\t\t\t\t/* { dg-error \"OpenMP constructs other than 'parallel', 'loop' or 'simd' may not be nested inside a 'loop' region\" \"\" { target c } } */\n+    }\n+  #pragma omp loop\n+  for (i = 0; i < 64; i++)\n+    a[i] += omp_get_thread_num ();\t/* { dg-error \"OpenMP runtime API call '\\[^\\n\\r]*omp_get_thread_num\\[^\\n\\r]*' in a region with 'order\\\\(concurrent\\\\)' clause\" } */\n+  #pragma omp loop\n+  for (i = 0; i < 64; i++)\n+    a[i] += omp_get_num_threads ();\t/* { dg-error \"OpenMP runtime API call '\\[^\\n\\r]*omp_get_num_threads\\[^\\n\\r]*' in a region with 'order\\\\(concurrent\\\\)' clause\" } */\n+  #pragma omp loop\n+  for (i = 0; i < 64; i++)\n+    a[i] += omp_target_is_present (a + i, 0);\t/* { dg-error \"OpenMP runtime API call '\\[^\\n\\r]*omp_target_is_present\\[^\\n\\r]*' in a region with 'order\\\\(concurrent\\\\)' clause\" } */\n+  #pragma omp loop\n+  for (i = 0; i < 64; i++)\n+    a[i] += omp_get_cancellation ();\t/* { dg-error \"OpenMP runtime API call '\\[^\\n\\r]*omp_get_cancellation\\[^\\n\\r]*' in a region with 'order\\\\(concurrent\\\\)' clause\" } */\n+  }\n+}\n+"}, {"sha": "ce9b6c95b1dad8bc8ca449bdd53bed6b8df0af2b", "filename": "gcc/testsuite/c-c++-common/gomp/loop-2.c", "status": "added", "additions": 294, "deletions": 0, "changes": 294, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/554a530ff81870098572832eed8ca00b3593bb41/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Floop-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/554a530ff81870098572832eed8ca00b3593bb41/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Floop-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Floop-2.c?ref=554a530ff81870098572832eed8ca00b3593bb41", "patch": "@@ -0,0 +1,294 @@\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+int omp_get_thread_num (void);\n+#ifdef __cplusplus\n+}\n+#endif\n+\n+void\n+f0 (int *a)\n+{\n+  int i;\n+  #pragma omp loop bind(teams) order(concurrent)\n+  for (i = 0; i < 64; i++)\n+    a[i] = i;\n+}\n+\n+void\n+f1 (int *a)\n+{\n+  int i;\n+  #pragma omp teams\n+  {\n+    #pragma omp loop\n+    for (i = 0; i < 64; i++)\n+      a[i] = i;\n+  }\n+  #pragma omp teams\n+  {\n+    #pragma omp loop bind(teams)\n+    for (i = 0; i < 64; i++)\n+      a[i] = i;\n+  }\n+  #pragma omp teams\n+  {\n+    #pragma omp loop bind(parallel)\n+    for (i = 0; i < 64; i++)\n+      a[i] = i;\n+  }\n+  #pragma omp teams\n+  {\n+    #pragma omp loop lastprivate (i) bind(thread)\n+    for (i = 0; i < 64; i++)\n+      a[i] = i;\n+  }\n+}\n+\n+void\n+f2 (int *a)\n+{\n+  int i;\n+  #pragma omp loop bind(parallel) order(concurrent)\n+  for (i = 0; i < 64; i++)\n+    a[i] = i;\n+  #pragma omp parallel\n+  {\n+    #pragma omp loop private (i)\n+    for (i = 0; i < 64; i++)\n+      a[i] = i;\n+  }\n+  #pragma omp parallel\n+  {\n+    #pragma omp loop lastprivate (i) bind(parallel)\n+    for (i = 0; i < 64; i++)\n+      a[i] = i;\n+  }\n+  #pragma omp parallel\n+  {\n+    #pragma omp loop bind(thread)\n+    for (i = 0; i < 64; i++)\n+      a[i] = i;\n+  }\n+  #pragma omp taskgroup\n+  {\n+    #pragma omp loop bind(parallel)\n+    for (i = 0; i < 64; i++)\n+      a[i] = i;\n+  }\n+  #pragma omp teams\n+  {\n+    int j;\n+    #pragma omp distribute\n+    for (j = 0; j < 64; ++j)\n+      {\n+\t#pragma omp loop bind(parallel)\n+\tfor (i = 0; i < 64; i++)\n+\t  a[64 * j + i] = i;\n+      }\n+  }\n+  #pragma omp target\n+  {\n+    #pragma omp loop bind(parallel)\n+    for (i = 0; i < 64; i++)\n+      a[i] = i;\n+  }\n+}\n+\n+void\n+f3 (int *a)\n+{\n+  int i, j;\n+  #pragma omp loop order ( concurrent )bind(thread)\n+  for (i = 0; i < 64; i++)\n+    a[i] = i;\n+  #pragma omp parallel num_threads (4)\n+  {\n+    int j = omp_get_thread_num ();\n+    #pragma omp loop private (i) bind(thread)\n+    for (i = 0; i < 64; i++)\n+      a[j * 64 + i] = i;\n+  }\n+  #pragma omp critical\n+  {\n+    #pragma omp loop lastprivate (i)\n+    for (i = 0; i < 64; i++)\n+      a[i] = i;\n+  }\n+  #pragma omp critical\n+  {\n+    #pragma omp loop bind(thread)\n+    for (i = 0; i < 64; i++)\n+      a[i] = i;\n+  }\n+  #pragma omp master\n+  {\n+    #pragma omp loop private (i)\n+    for (i = 0; i < 64; i++)\n+      a[i] = i;\n+  }\n+  #pragma omp master\n+  {\n+    #pragma omp loop bind(thread)\n+    for (i = 0; i < 64; i++)\n+      a[i] = i;\n+  }\n+  #pragma omp sections\n+  {\n+    #pragma omp loop private (i)\n+    for (i = 0; i < 64; i++)\n+      a[i] = i;\n+  }\n+  #pragma omp sections\n+  {\n+    #pragma omp loop bind(thread) lastprivate(i)\n+    for (i = 0; i < 64; i++)\n+      a[i] = i;\n+  }\n+  #pragma omp single\n+  {\n+    #pragma omp loop private (i)\n+    for (i = 0; i < 64; i++)\n+      a[i] = i;\n+  }\n+  #pragma omp single\n+  {\n+    #pragma omp loop bind(thread)\n+    for (i = 0; i < 64; i++)\n+      a[i] = i;\n+  }\n+  #pragma omp task\n+  {\n+    #pragma omp loop private (i)\n+    for (i = 0; i < 64; i++)\n+      a[i] = i;\n+  }\n+  #pragma omp task\n+  {\n+    #pragma omp loop bind(thread)\n+    for (i = 0; i < 64; i++)\n+      a[i] = i;\n+  }\n+  #pragma omp taskgroup\n+  {\n+    #pragma omp loop private (i)\n+    for (i = 0; i < 64; i++)\n+      a[i] = i;\n+  }\n+  #pragma omp taskgroup\n+  {\n+    #pragma omp loop bind(thread)\n+    for (i = 0; i < 64; i++)\n+      a[i] = i;\n+  }\n+  #pragma omp teams\n+  {\n+    #pragma omp distribute\n+    for (j = 0; j < 64; ++j)\n+      {\n+\t#pragma omp loop\n+\tfor (i = 0; i < 64; i++)\n+\t  a[64 * j + i] = i;\n+\t#pragma omp loop bind(thread)\n+\tfor (i = 0; i < 64; i++)\n+\t  a[64 * j + i] = i;\n+      }\n+  }\n+  #pragma omp for\n+  for (j = 0; j < 64; ++j)\n+    {\n+      #pragma omp loop\n+      for (i = 0; i < 64; i++)\n+\ta[64 * j + i] = i;\n+      #pragma omp loop bind(thread)\n+      for (i = 0; i < 64; i++)\n+\ta[64 * j + i] = i;\n+    }\n+  #pragma omp parallel\n+  #pragma omp loop\n+  for (j = 0; j < 64; ++j)\n+    {\n+      #pragma omp loop\n+      for (i = 0; i < 64; i++)\n+\ta[64 * j + i] = i;\n+      #pragma omp loop bind(thread)\n+      for (i = 0; i < 64; i++)\n+\ta[64 * j + i] = i;\n+    }\n+  #pragma omp loop bind(thread)\n+  for (j = 0; j < 64; ++j)\n+    {\n+      #pragma omp loop\n+      for (i = 0; i < 64; i++)\n+\ta[64 * j + i] = i;\n+      #pragma omp loop bind(thread)\n+      for (i = 0; i < 64; i++)\n+\ta[64 * j + i] = i;\n+    }\n+  #pragma omp loop bind(parallel)\n+  for (j = 0; j < 64; ++j)\n+    {\n+      #pragma omp loop\n+      for (i = 0; i < 64; i++)\n+\ta[64 * j + i] = i;\n+      #pragma omp loop bind(thread)\n+      for (i = 0; i < 64; i++)\n+\ta[64 * j + i] = i;\n+    }\n+  #pragma omp for ordered\n+  for (j = 0; j < 64; ++j)\n+    {\n+      #pragma omp ordered\n+      #pragma omp loop\n+      for (i = 0; i < 64; i++)\n+\ta[64 * j + i] = i;\n+      #pragma omp ordered threads\n+      #pragma omp loop bind(thread)\n+      for (i = 0; i < 64; i++)\n+\ta[64 * j + i] = i;\n+    }\n+  #pragma omp simd\n+  for (j = 0; j < 64; ++j)\n+    {\n+      #pragma omp loop\n+      for (i = 0; i < 64; i++)\n+\ta[64 * j + i] = i;\n+      #pragma omp loop bind(thread)\n+      for (i = 0; i < 64; i++)\n+\ta[64 * j + i] = i;\n+    }\n+  #pragma omp taskloop\n+  for (j = 0; j < 64; ++j)\n+    {\n+      #pragma omp loop\n+      for (i = 0; i < 64; i++)\n+\ta[64 * j + i] = i;\n+      #pragma omp loop bind(thread)\n+      for (i = 0; i < 64; i++)\n+\ta[64 * j + i] = i;\n+    }\n+  #pragma omp target\n+  {\n+    #pragma omp loop\n+    for (i = 0; i < 64; i++)\n+      a[i] = i;\n+    #pragma omp loop bind(thread)\n+    for (i = 0; i < 64; i++)\n+      a[i] = i;\n+  }\n+}\n+\n+void\n+f4 (int *a)\n+{\n+  int i;\n+  #pragma omp ordered\n+  {\n+    #pragma omp loop private (i)\n+    for (i = 0; i < 64; i++)\n+      a[i] = i;\n+    #pragma omp loop bind(thread)\n+    for (i = 0; i < 64; i++)\n+      a[i] = i;\n+  }\n+}"}, {"sha": "186b8cce64f06e3e5ef6d1f5803a002615997b7a", "filename": "gcc/testsuite/c-c++-common/gomp/loop-3.c", "status": "added", "additions": 145, "deletions": 0, "changes": 145, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/554a530ff81870098572832eed8ca00b3593bb41/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Floop-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/554a530ff81870098572832eed8ca00b3593bb41/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Floop-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Floop-3.c?ref=554a530ff81870098572832eed8ca00b3593bb41", "patch": "@@ -0,0 +1,145 @@\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+int omp_get_thread_num (void);\n+#ifdef __cplusplus\n+}\n+#endif\n+\n+void\n+f1 (int *a)\n+{\n+  int i;\n+  #pragma omp loop\t\t/* { dg-error \"'bind' clause not specified on a 'loop' construct not nested inside another OpenMP construct\" } */\n+  for (i = 0; i < 64; i++)\n+    a[i] = i;\n+}\n+\n+void\n+f2 (int *a)\n+{\n+  int i, j;\n+  #pragma omp parallel num_threads (4)\n+  {\n+    int j = omp_get_thread_num ();\n+    #pragma omp loop private (i) bind(teams)\t/* { dg-error \"'bind\\\\(teams\\\\)' on a 'loop' region not strictly nested inside of a 'teams' region\" } */\n+    for (i = 0; i < 64; i++)\n+      a[j * 64 + i] = i;\n+  }\n+  #pragma omp critical\n+  {\n+    #pragma omp loop lastprivate (i) bind(teams)/* { dg-error \"'bind\\\\(teams\\\\)' on a 'loop' region not strictly nested inside of a 'teams' region\" } */\n+    for (i = 0; i < 64; i++)\n+      a[i] = i;\n+  }\n+  #pragma omp master\n+  {\n+    #pragma omp loop bind(teams)\t\t/* { dg-error \"'bind\\\\(teams\\\\)' on a 'loop' region not strictly nested inside of a 'teams' region\" } */\n+    for (i = 0; i < 64; i++)\n+      a[i] = i;\n+  }\n+  #pragma omp sections\n+  {\n+    #pragma omp loop bind(teams) lastprivate(i)\t/* { dg-error \"'bind\\\\(teams\\\\)' on a 'loop' region not strictly nested inside of a 'teams' region\" } */\n+    for (i = 0; i < 64; i++)\n+      a[i] = i;\n+  }\n+  #pragma omp single\n+  {\n+    #pragma omp loop bind(teams)\t\t/* { dg-error \"'bind\\\\(teams\\\\)' on a 'loop' region not strictly nested inside of a 'teams' region\" } */\n+    for (i = 0; i < 64; i++)\n+      a[i] = i;\n+  }\n+  #pragma omp task\n+  {\n+    #pragma omp loop bind(teams)\t\t/* { dg-error \"'bind\\\\(teams\\\\)' on a 'loop' region not strictly nested inside of a 'teams' region\" } */\n+    for (i = 0; i < 64; i++)\n+      a[i] = i;\n+  }\n+  #pragma omp taskgroup\n+  {\n+    #pragma omp loop bind(teams)\t\t/* { dg-error \"'bind\\\\(teams\\\\)' on a 'loop' region not strictly nested inside of a 'teams' region\" } */\n+    for (i = 0; i < 64; i++)\n+      a[i] = i;\n+  }\n+  #pragma omp teams\n+  {\n+    #pragma omp distribute\n+    for (j = 0; j < 64; ++j)\n+      {\n+\t#pragma omp loop bind(teams)\t\t/* { dg-error \"'bind\\\\(teams\\\\)' on a 'loop' region not strictly nested inside of a 'teams' region\" } */\n+\tfor (i = 0; i < 64; i++)\n+\t  a[64 * j + i] = i;\n+      }\n+  }\n+  #pragma omp for\n+  for (j = 0; j < 64; ++j)\n+    {\n+      #pragma omp loop bind(teams)\t\t/* { dg-error \"'bind\\\\(teams\\\\)' on a 'loop' region not strictly nested inside of a 'teams' region\" } */\n+      for (i = 0; i < 64; i++)\n+\ta[64 * j + i] = i;\n+    }\n+  #pragma omp parallel\n+  #pragma omp loop\n+  for (j = 0; j < 64; ++j)\n+    {\n+      #pragma omp loop bind(teams)\t\t/* { dg-error \"'bind\\\\(teams\\\\)' on a 'loop' region not strictly nested inside of a 'teams' region\" } */\n+      for (i = 0; i < 64; i++)\n+\ta[64 * j + i] = i;\n+    }\n+  #pragma omp loop bind(thread)\n+  for (j = 0; j < 64; ++j)\n+    {\n+      #pragma omp loop bind(teams)\t\t/* { dg-error \"'bind\\\\(teams\\\\)' on a 'loop' region not strictly nested inside of a 'teams' region\" } */\n+      for (i = 0; i < 64; i++)\n+\ta[64 * j + i] = i;\n+    }\n+  #pragma omp loop bind(parallel)\n+  for (j = 0; j < 64; ++j)\n+    {\n+      #pragma omp loop bind(teams)\t\t/* { dg-error \"'bind\\\\(teams\\\\)' on a 'loop' region not strictly nested inside of a 'teams' region\" } */\n+      for (i = 0; i < 64; i++)\n+\ta[64 * j + i] = i;\n+    }\n+  #pragma omp for ordered\n+  for (j = 0; j < 64; ++j)\n+    {\n+      #pragma omp ordered threads\n+      #pragma omp loop bind(teams)\t\t/* { dg-error \"'bind\\\\(teams\\\\)' on a 'loop' region not strictly nested inside of a 'teams' region\" } */\n+      for (i = 0; i < 64; i++)\n+\ta[64 * j + i] = i;\n+    }\n+  #pragma omp simd\n+  for (j = 0; j < 64; ++j)\n+    {\n+      #pragma omp loop bind(teams)\t\t/* { dg-error \"'bind\\\\(teams\\\\)' on a 'loop' region not strictly nested inside of a 'teams' region\" } */\n+      for (i = 0; i < 64; i++)\n+\ta[64 * j + i] = i;\n+    }\n+  #pragma omp taskloop\n+  for (j = 0; j < 64; ++j)\n+    {\n+      #pragma omp loop bind(teams)\t\t/* { dg-error \"'bind\\\\(teams\\\\)' on a 'loop' region not strictly nested inside of a 'teams' region\" } */\n+      for (i = 0; i < 64; i++)\n+\ta[64 * j + i] = i;\n+    }\n+  #pragma omp target\n+  {\n+    #pragma omp loop bind(teams)\t\t/* { dg-error \"'bind\\\\(teams\\\\)' on a 'loop' region not strictly nested inside of a 'teams' region\" } */\n+    for (i = 0; i < 64; i++)\n+      a[i] = i;\n+  }\n+}\n+\n+void\n+f3 (int *a)\n+{\n+  int i, j;\n+  #pragma omp simd\n+  for (j = 0; j < 64; j++)\n+    {\n+      #pragma omp loop bind(parallel)\t\t/* { dg-error \"'bind\\\\(parallel\\\\)' on a 'loop' construct nested inside 'simd' construct\" } */\n+      for (i = 0; i < 64; i++)\n+\ta[64 * j + i] = i;\n+    }\n+}"}, {"sha": "b77f8c981427ce464709f3a92dc68a2fe657a20e", "filename": "gcc/testsuite/c-c++-common/gomp/loop-4.c", "status": "added", "additions": 46, "deletions": 0, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/554a530ff81870098572832eed8ca00b3593bb41/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Floop-4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/554a530ff81870098572832eed8ca00b3593bb41/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Floop-4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Floop-4.c?ref=554a530ff81870098572832eed8ca00b3593bb41", "patch": "@@ -0,0 +1,46 @@\n+int r, l;\n+\n+void\n+f1 (int *a)\n+{\n+  int i;\n+  #pragma omp master\n+  {\n+    #pragma omp loop bind\t\t/* { dg-error \"expected\" } */\n+    for (i = 0; i < 64; ++i)\n+      a[i] = i;\n+    #pragma omp loop bind )\t\t/* { dg-error \"expected\" } */\n+    for (i = 0; i < 64; ++i)\n+      a[i] = i;\n+    #pragma omp loop bind (\t\t/* { dg-error \"expected\" } */\n+    for (i = 0; i < 64; ++i)\n+      a[i] = i;\n+    #pragma omp loop bind ()\t\t/* { dg-error \"expected\" } */\n+    for (i = 0; i < 64; ++i)\n+      a[i] = i;\n+    #pragma omp loop bind ( foobar )\t/* { dg-error \"expected\" } */\n+    for (i = 0; i < 64; ++i)\n+      a[i] = i;\n+    #pragma omp loop bind (default)\t/* { dg-error \"expected\" } */\n+    for (i = 0; i < 64; ++i)\n+      a[i] = i;\n+    #pragma omp loop bind (parallel\t/* { dg-error \"expected\" } */\n+    for (i = 0; i < 64; ++i)\n+      a[i] = i;\n+  }\n+}\n+\n+void\n+f2 (int *a)\n+{\n+  int i;\n+  #pragma omp loop bind(parallel) reduction(task, +: r)\t/* { dg-error \"invalid 'task' reduction modifier on construct other than 'parallel', 'for' or 'sections'\" } */\n+  for (i = 0; i < 64; ++i)\n+    a[i] = i;\n+  #pragma omp loop bind(thread) reduction(inscan, +: r)\t/* { dg-error \"'inscan' 'reduction' clause on 'loop' construct\" } */\n+  for (i = 0; i < 64; ++i)\n+    a[i] = i;\n+  #pragma omp loop bind(parallel) lastprivate (l)\t/* { dg-error \"'lastprivate' clause on a 'loop' construct refers to a variable 'l' which is not the loop iterator\" } */\n+  for (i = 0; i < 64; ++i)\n+    l = i;\n+}"}, {"sha": "b9b2ad9176774c2f195b1224a675260917052176", "filename": "gcc/testsuite/c-c++-common/gomp/loop-5.c", "status": "added", "additions": 56, "deletions": 0, "changes": 56, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/554a530ff81870098572832eed8ca00b3593bb41/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Floop-5.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/554a530ff81870098572832eed8ca00b3593bb41/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Floop-5.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Floop-5.c?ref=554a530ff81870098572832eed8ca00b3593bb41", "patch": "@@ -0,0 +1,56 @@\n+__attribute__((noipa)) int\n+foo (int *a, int *r3)\n+{\n+  int r = 0, r2[2] = { 0, 0 }, i;\n+  #pragma omp parallel loop default (none) reduction (+:r, r2[:2], r3[:2]) shared (a) lastprivate (i)\n+  for (i = 0; i < 1024; i++)\n+    {\n+      r += a[i];\n+      r2[0] += a[i];\n+      r3[1] += a[i];\n+    };\n+  return r + r2[0] + r3[1] + i;\n+}\n+\n+__attribute__((noipa)) int\n+bar (int *a, int *r3)\n+{\n+  int r = 0, r2[2] = { 0, 0 }, i;\n+  #pragma omp target parallel loop default (none) reduction (+:r, r2[0:2], r3[0:2]) shared (a) lastprivate (i)\n+  for (i = 0; i < 1024; i++)\n+    {\n+      r += a[i];\n+      r2[1] += a[i];\n+      r3[0] += a[i];\n+    }\n+  return r + r2[1] + r3[0] + i;\n+}\n+\n+__attribute__((noipa)) int\n+baz (int *a, int *r3)\n+{\n+  int r = 0, r2[2] = { 0, 0 }, i;\n+  #pragma omp teams loop default (none) reduction (+:r, r2[0:2], r3[1:1]) shared (a) lastprivate (i)\n+  for (i = 0; i < 1024; i++)\n+    {\n+      r += a[i];\n+      r2[0] += a[i];\n+      r3[1] += a[i];\n+    }\n+  return r + r2[0] + r3[1] + i;\n+}\n+\n+__attribute__((noipa)) int\n+qux (int *a, int *r3)\n+{\n+  int r = 0, r2[2] = { 0, 0 }, i;\n+  #pragma omp target teams loop default (none) reduction (+:r, r2[1:1], r3[0:2]) shared (a) lastprivate (i)\n+  for (i = 0; i < 1024; i++)\n+    {\n+      r += a[i];\n+      r2[1] += a[i];\n+      r3[0] += a[i] - 1;\n+      r3[1] += a[i];\n+    }\n+  return r + r2[1] + r3[0] + r3[1] + i;\n+}"}, {"sha": "2d51bf37749acbb18964c6d6f54969259982fa46", "filename": "gcc/testsuite/c-c++-common/gomp/order-3.c", "status": "modified", "additions": 24, "deletions": 24, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/554a530ff81870098572832eed8ca00b3593bb41/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Forder-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/554a530ff81870098572832eed8ca00b3593bb41/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Forder-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Forder-3.c?ref=554a530ff81870098572832eed8ca00b3593bb41", "patch": "@@ -18,46 +18,46 @@ f1 (int *a)\n   #pragma omp simd order(concurrent)\n   for (i = 0; i < 64; i++)\n     {\n-      #pragma omp parallel\t\t/* { dg-error \"OpenMP constructs other than '#pragma omp ordered simd' or '#pragma omp atomic' may not be nested inside 'simd' region\" } */\n+      #pragma omp parallel\t\t/* { dg-error \"OpenMP constructs other than 'ordered simd', 'simd', 'loop' or 'atomic' may not be nested inside 'simd' region\" } */\n       foo ();\n     }\n   #pragma omp simd order(concurrent)\n   for (i = 0; i < 64; i++)\n     {\n       int j;\n-      #pragma omp simd\t\t\t/* { dg-error \"OpenMP constructs other than '#pragma omp ordered simd' or '#pragma omp atomic' may not be nested inside 'simd' region\" } */\n+      #pragma omp simd\n       for (j = 0; j < 64; j++)\n \ta[64 * i + j] = i + j;\n     }\n   #pragma omp simd order(concurrent)\n   for (i = 0; i < 64; i++)\n     {\n-      #pragma omp critical\t\t/* { dg-error \"OpenMP constructs other than '#pragma omp ordered simd' or '#pragma omp atomic' may not be nested inside 'simd' region\" } */\n+      #pragma omp critical\t\t/* { dg-error \"OpenMP constructs other than 'ordered simd', 'simd', 'loop' or 'atomic' may not be nested inside 'simd' region\" } */\n       foo ();\n     }\n   #pragma omp simd order(concurrent)\n   for (i = 0; i < 64; i++)\n     {\n-      #pragma omp ordered simd\t\t/* { dg-error \"OpenMP constructs other than 'parallel' or 'simd' may not be nested inside a region with the 'order\\\\(concurrent\\\\)' clause\" } */\n+      #pragma omp ordered simd\t\t/* { dg-error \"OpenMP constructs other than 'parallel', 'loop' or 'simd' may not be nested inside a region with the 'order\\\\(concurrent\\\\)' clause\" } */\n       foo ();\n     }\n   #pragma omp simd order(concurrent)\n   for (i = 0; i < 64; i++)\n     {\n-      #pragma omp atomic\t\t/* { dg-error \"OpenMP constructs other than 'parallel' or 'simd' may not be nested inside a region with the 'order\\\\(concurrent\\\\)' clause\" } */\n+      #pragma omp atomic\t\t/* { dg-error \"OpenMP constructs other than 'parallel', 'loop' or 'simd' may not be nested inside a region with the 'order\\\\(concurrent\\\\)' clause\" } */\n       v++;\n     }\n   #pragma omp simd order(concurrent)\n   for (i = 0; i < 64; i++)\n     {\n       #pragma omp atomic read\n-      a[i] = v;\t\t\t\t/* { dg-error \"OpenMP constructs other than 'parallel' or 'simd' may not be nested inside a region with the 'order\\\\(concurrent\\\\)' clause\" } */\n+      a[i] = v;\t\t\t\t/* { dg-error \"OpenMP constructs other than 'parallel', 'loop' or 'simd' may not be nested inside a region with the 'order\\\\(concurrent\\\\)' clause\" } */\n     }\n   #pragma omp simd order(concurrent)\n   for (i = 0; i < 64; i++)\n     {\n-      #pragma omp atomic write\t\t/* { dg-error \"OpenMP constructs other than 'parallel' or 'simd' may not be nested inside a region with the 'order\\\\(concurrent\\\\)' clause\" \"\" { target c++ } } */\n-      v = a[i];\t\t\t\t/* { dg-error \"OpenMP constructs other than 'parallel' or 'simd' may not be nested inside a region with the 'order\\\\(concurrent\\\\)' clause\" \"\" { target c } } */\n+      #pragma omp atomic write\t\t/* { dg-error \"OpenMP constructs other than 'parallel', 'loop' or 'simd' may not be nested inside a region with the 'order\\\\(concurrent\\\\)' clause\" \"\" { target c++ } } */\n+      v = a[i];\t\t\t\t/* { dg-error \"OpenMP constructs other than 'parallel', 'loop' or 'simd' may not be nested inside a region with the 'order\\\\(concurrent\\\\)' clause\" \"\" { target c } } */\n     }\n   #pragma omp simd order(concurrent)\n   for (i = 0; i < 64; i++)\n@@ -80,46 +80,46 @@ f2 (int *a)\n   #pragma omp for simd order(concurrent)\n   for (i = 0; i < 64; i++)\n     {\n-      #pragma omp parallel\t\t/* { dg-error \"OpenMP constructs other than '#pragma omp ordered simd' or '#pragma omp atomic' may not be nested inside 'simd' region\" } */\n+      #pragma omp parallel\t\t/* { dg-error \"OpenMP constructs other than 'ordered simd', 'simd', 'loop' or 'atomic' may not be nested inside 'simd' region\" } */\n       foo ();\n     }\n   #pragma omp for simd order(concurrent)\n   for (i = 0; i < 64; i++)\n     {\n       int j;\n-      #pragma omp simd\t\t\t/* { dg-error \"OpenMP constructs other than '#pragma omp ordered simd' or '#pragma omp atomic' may not be nested inside 'simd' region\" } */\n+      #pragma omp simd\n       for (j = 0; j < 64; j++)\n \ta[64 * i + j] = i + j;\n     }\n   #pragma omp for simd order(concurrent)\n   for (i = 0; i < 64; i++)\n     {\n-      #pragma omp critical\t\t/* { dg-error \"OpenMP constructs other than '#pragma omp ordered simd' or '#pragma omp atomic' may not be nested inside 'simd' region\" } */\n+      #pragma omp critical\t\t/* { dg-error \"OpenMP constructs other than 'ordered simd', 'simd', 'loop' or 'atomic' may not be nested inside 'simd' region\" } */\n       foo ();\n     }\n   #pragma omp for simd order(concurrent)\n   for (i = 0; i < 64; i++)\n     {\n-      #pragma omp ordered simd\t\t/* { dg-error \"OpenMP constructs other than 'parallel' or 'simd' may not be nested inside a region with the 'order\\\\(concurrent\\\\)' clause\" } */\n+      #pragma omp ordered simd\t\t/* { dg-error \"OpenMP constructs other than 'parallel', 'loop' or 'simd' may not be nested inside a region with the 'order\\\\(concurrent\\\\)' clause\" } */\n       foo ();\n     }\n   #pragma omp for simd order(concurrent)\n   for (i = 0; i < 64; i++)\n     {\n-      #pragma omp atomic\t\t/* { dg-error \"OpenMP constructs other than 'parallel' or 'simd' may not be nested inside a region with the 'order\\\\(concurrent\\\\)' clause\" } */\n+      #pragma omp atomic\t\t/* { dg-error \"OpenMP constructs other than 'parallel', 'loop' or 'simd' may not be nested inside a region with the 'order\\\\(concurrent\\\\)' clause\" } */\n       v++;\n     }\n   #pragma omp for simd order(concurrent)\n   for (i = 0; i < 64; i++)\n     {\n       #pragma omp atomic read\n-      a[i] = v;\t\t\t\t/* { dg-error \"OpenMP constructs other than 'parallel' or 'simd' may not be nested inside a region with the 'order\\\\(concurrent\\\\)' clause\" } */\n+      a[i] = v;\t\t\t\t/* { dg-error \"OpenMP constructs other than 'parallel', 'loop' or 'simd' may not be nested inside a region with the 'order\\\\(concurrent\\\\)' clause\" } */\n     }\n   #pragma omp for simd order(concurrent)\n   for (i = 0; i < 64; i++)\n     {\n-      #pragma omp atomic write\t\t/* { dg-error \"OpenMP constructs other than 'parallel' or 'simd' may not be nested inside a region with the 'order\\\\(concurrent\\\\)' clause\" \"\" { target c++ } } */\n-      v = a[i];\t\t\t\t/* { dg-error \"OpenMP constructs other than 'parallel' or 'simd' may not be nested inside a region with the 'order\\\\(concurrent\\\\)' clause\" \"\" { target c } } */\n+      #pragma omp atomic write\t\t/* { dg-error \"OpenMP constructs other than 'parallel', 'loop' or 'simd' may not be nested inside a region with the 'order\\\\(concurrent\\\\)' clause\" \"\" { target c++ } } */\n+      v = a[i];\t\t\t\t/* { dg-error \"OpenMP constructs other than 'parallel', 'loop' or 'simd' may not be nested inside a region with the 'order\\\\(concurrent\\\\)' clause\" \"\" { target c } } */\n     }\n   #pragma omp for simd order(concurrent)\n   for (i = 0; i < 64; i++)\n@@ -156,44 +156,44 @@ f3 (int *a)\n   #pragma omp for order(concurrent)\n   for (i = 0; i < 64; i++)\n     {\n-      #pragma omp critical\t\t/* { dg-error \"OpenMP constructs other than 'parallel' or 'simd' may not be nested inside a region with the 'order\\\\(concurrent\\\\)' clause\" } */\n+      #pragma omp critical\t\t/* { dg-error \"OpenMP constructs other than 'parallel', 'loop' or 'simd' may not be nested inside a region with the 'order\\\\(concurrent\\\\)' clause\" } */\n       foo ();\n     }\n   #pragma omp for order(concurrent)\n   for (i = 0; i < 64; i++)\n     {\n-      #pragma omp ordered simd\t\t/* { dg-error \"OpenMP constructs other than 'parallel' or 'simd' may not be nested inside a region with the 'order\\\\(concurrent\\\\)' clause\" } */\n+      #pragma omp ordered simd\t\t/* { dg-error \"OpenMP constructs other than 'parallel', 'loop' or 'simd' may not be nested inside a region with the 'order\\\\(concurrent\\\\)' clause\" } */\n       foo ();\n     }\n   #pragma omp for order(concurrent)\n   for (i = 0; i < 64; i++)\n     {\n-      #pragma omp atomic\t\t/* { dg-error \"OpenMP constructs other than 'parallel' or 'simd' may not be nested inside a region with the 'order\\\\(concurrent\\\\)' clause\" } */\n+      #pragma omp atomic\t\t/* { dg-error \"OpenMP constructs other than 'parallel', 'loop' or 'simd' may not be nested inside a region with the 'order\\\\(concurrent\\\\)' clause\" } */\n       v++;\n     }\n   #pragma omp for order(concurrent)\n   for (i = 0; i < 64; i++)\n     {\n       #pragma omp atomic read\n-      a[i] = v;\t\t\t\t/* { dg-error \"OpenMP constructs other than 'parallel' or 'simd' may not be nested inside a region with the 'order\\\\(concurrent\\\\)' clause\" } */\n+      a[i] = v;\t\t\t\t/* { dg-error \"OpenMP constructs other than 'parallel', 'loop' or 'simd' may not be nested inside a region with the 'order\\\\(concurrent\\\\)' clause\" } */\n     }\n   #pragma omp for order(concurrent)\n   for (i = 0; i < 64; i++)\n     {\n-      #pragma omp atomic write\t\t/* { dg-error \"OpenMP constructs other than 'parallel' or 'simd' may not be nested inside a region with the 'order\\\\(concurrent\\\\)' clause\" \"\" { target c++ } } */\n-      v = a[i];\t\t\t\t/* { dg-error \"OpenMP constructs other than 'parallel' or 'simd' may not be nested inside a region with the 'order\\\\(concurrent\\\\)' clause\" \"\" { target c } } */\n+      #pragma omp atomic write\t\t/* { dg-error \"OpenMP constructs other than 'parallel', 'loop' or 'simd' may not be nested inside a region with the 'order\\\\(concurrent\\\\)' clause\" \"\" { target c++ } } */\n+      v = a[i];\t\t\t\t/* { dg-error \"OpenMP constructs other than 'parallel', 'loop' or 'simd' may not be nested inside a region with the 'order\\\\(concurrent\\\\)' clause\" \"\" { target c } } */\n     }\n   #pragma omp for order(concurrent)\n   for (i = 0; i < 64; i++)\n     {\n-      #pragma omp task\t\t\t/* { dg-error \"OpenMP constructs other than 'parallel' or 'simd' may not be nested inside a region with the 'order\\\\(concurrent\\\\)' clause\" } */\n+      #pragma omp task\t\t\t/* { dg-error \"OpenMP constructs other than 'parallel', 'loop' or 'simd' may not be nested inside a region with the 'order\\\\(concurrent\\\\)' clause\" } */\n       a[i]++;\n     }\n   #pragma omp for order(concurrent)\n   for (i = 0; i < 64; i++)\n     {\n       int j;\n-      #pragma omp taskloop\t\t/* { dg-error \"OpenMP constructs other than 'parallel' or 'simd' may not be nested inside a region with the 'order\\\\(concurrent\\\\)' clause\" } */\n+      #pragma omp taskloop\t\t/* { dg-error \"OpenMP constructs other than 'parallel', 'loop' or 'simd' may not be nested inside a region with the 'order\\\\(concurrent\\\\)' clause\" } */\n       for (j = 0; j < 64; j++)\n \ta[64 * i + j] = i + j;\n     }"}, {"sha": "453e00165100ffa74d57fa30efd8f8c6455aea26", "filename": "gcc/testsuite/c-c++-common/gomp/simd-setjmp-1.c", "status": "added", "additions": 68, "deletions": 0, "changes": 68, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/554a530ff81870098572832eed8ca00b3593bb41/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Fsimd-setjmp-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/554a530ff81870098572832eed8ca00b3593bb41/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Fsimd-setjmp-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Fsimd-setjmp-1.c?ref=554a530ff81870098572832eed8ca00b3593bb41", "patch": "@@ -0,0 +1,68 @@\n+typedef long int jmp_buf[8];\n+extern\n+#ifdef __cplusplus\n+\"C\"\n+#endif\n+int setjmp (jmp_buf);\n+\n+void\n+foo (void)\n+{\n+  int i;\n+  #pragma omp simd\n+  for (i = 0; i < 64; i++)\n+    {\n+      jmp_buf buf;\n+      setjmp (buf);\t/* { dg-error \"setjmp/longjmp inside 'simd' construct\" } */\n+    }\n+}\n+\n+void\n+bar (void)\n+{\n+  int i;\n+  #pragma omp loop bind(thread)\n+  for (i = 0; i < 64; i++)\n+    {\n+      jmp_buf buf;\n+      setjmp (buf);\n+    }\n+}\n+\n+#ifdef __cplusplus\n+struct S\n+{\n+  static int setjmp (jmp_buf);\n+};\n+\n+namespace N\n+{\n+  int setjmp (jmp_buf);\n+}\n+\n+void\n+baz (void)\n+{\n+  int i;\n+  #pragma omp simd\n+  for (i = 0; i < 64; i++)\n+    {\n+      jmp_buf buf;\n+      S::setjmp (buf);\n+      N::setjmp (buf);\n+    }\n+}\n+\n+void\n+qux (void)\n+{\n+  int i;\n+  #pragma omp loop bind(thread)\n+  for (i = 0; i < 64; i++)\n+    {\n+      jmp_buf buf;\n+      S::setjmp (buf);\n+      N::setjmp (buf);\n+    }\n+}\n+#endif"}, {"sha": "85a5be7ca53a23652007a6ddd27991072327f771", "filename": "gcc/testsuite/c-c++-common/gomp/teams-2.c", "status": "modified", "additions": 22, "deletions": 22, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/554a530ff81870098572832eed8ca00b3593bb41/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Fteams-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/554a530ff81870098572832eed8ca00b3593bb41/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Fteams-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Fteams-2.c?ref=554a530ff81870098572832eed8ca00b3593bb41", "patch": "@@ -10,7 +10,7 @@ foo (void)\n   }\n   #pragma omp teams\n   {\n-    #pragma omp teams\t/* { dg-error \"only 'distribute' or 'parallel' regions are allowed to be strictly nested inside 'teams' region\" } */\n+    #pragma omp teams\t/* { dg-error \"only 'distribute', 'parallel' or 'loop' regions are allowed to be strictly nested inside 'teams' region\" } */\n     ;\n   }\n   #pragma omp target\n@@ -72,48 +72,48 @@ bar (void)\n   #pragma omp teams\n   {\n     int x, y, v = 4;\n-    #pragma omp target\t\t\t/* { dg-error \"only 'distribute' or 'parallel' regions are allowed to be strictly nested inside 'teams' region\" } */\n+    #pragma omp target\t\t\t/* { dg-error \"only 'distribute', 'parallel' or 'loop' regions are allowed to be strictly nested inside 'teams' region\" } */\n     ;\n-    #pragma omp target data map (to: v)\t/* { dg-error \"only 'distribute' or 'parallel' regions are allowed to be strictly nested inside 'teams' region\" } */\n+    #pragma omp target data map (to: v)\t/* { dg-error \"only 'distribute', 'parallel' or 'loop' regions are allowed to be strictly nested inside 'teams' region\" } */\n     ;\n-    #pragma omp for\t\t\t/* { dg-error \"only 'distribute' or 'parallel' regions are allowed to be strictly nested inside 'teams' region\" } */\n+    #pragma omp for\t\t\t/* { dg-error \"only 'distribute', 'parallel' or 'loop' regions are allowed to be strictly nested inside 'teams' region\" } */\n     for (int i = 0; i < 64; ++i)\n       ;\n-    #pragma omp simd\t\t\t/* { dg-error \"only 'distribute' or 'parallel' regions are allowed to be strictly nested inside 'teams' region\" } */\n+    #pragma omp simd\t\t\t/* { dg-error \"only 'distribute', 'parallel' or 'loop' regions are allowed to be strictly nested inside 'teams' region\" } */\n     for (int i = 0; i < 64; ++i)\n       ;\n-    #pragma omp for simd\t\t/* { dg-error \"only 'distribute' or 'parallel' regions are allowed to be strictly nested inside 'teams' region\" } */\n+    #pragma omp for simd\t\t/* { dg-error \"only 'distribute', 'parallel' or 'loop' regions are allowed to be strictly nested inside 'teams' region\" } */\n     for (int i = 0; i < 64; ++i)\n       ;\n-    #pragma omp single\t\t\t/* { dg-error \"only 'distribute' or 'parallel' regions are allowed to be strictly nested inside 'teams' region\" } */\n+    #pragma omp single\t\t\t/* { dg-error \"only 'distribute', 'parallel' or 'loop' regions are allowed to be strictly nested inside 'teams' region\" } */\n     ;\n-    #pragma omp master\t\t\t/* { dg-error \"only 'distribute' or 'parallel' regions are allowed to be strictly nested inside 'teams' region\" } */\n+    #pragma omp master\t\t\t/* { dg-error \"only 'distribute', 'parallel' or 'loop' regions are allowed to be strictly nested inside 'teams' region\" } */\n     ;\n-    #pragma omp sections\t\t/* { dg-error \"only 'distribute' or 'parallel' regions are allowed to be strictly nested inside 'teams' region\" } */\n+    #pragma omp sections\t\t/* { dg-error \"only 'distribute', 'parallel' or 'loop' regions are allowed to be strictly nested inside 'teams' region\" } */\n     {\n       x = 1;\n       #pragma omp section\n       y = 2;\n     }\n-    #pragma omp critical\t\t/* { dg-error \"only 'distribute' or 'parallel' regions are allowed to be strictly nested inside 'teams' region\" } */\n+    #pragma omp critical\t\t/* { dg-error \"only 'distribute', 'parallel' or 'loop' regions are allowed to be strictly nested inside 'teams' region\" } */\n     ;\n-    #pragma omp target enter data map (to: v)\t/* { dg-error \"only 'distribute' or 'parallel' regions are allowed to be strictly nested inside 'teams' region\" } */\n-    #pragma omp target exit data map (from: v)\t/* { dg-error \"only 'distribute' or 'parallel' regions are allowed to be strictly nested inside 'teams' region\" } */\n-    #pragma omp cancel parallel\t\t/* { dg-error \"only 'distribute' or 'parallel' regions are allowed to be strictly nested inside 'teams' region\" } */\n-    #pragma omp cancellation point parallel /* { dg-error \"only 'distribute' or 'parallel' regions are allowed to be strictly nested inside 'teams' region\" } */\n-    #pragma omp barrier\t\t\t/* { dg-error \"only 'distribute' or 'parallel' regions are allowed to be strictly nested inside 'teams' region\" } */\n-    #pragma omp ordered\t\t\t/* { dg-error \"only 'distribute' or 'parallel' regions are allowed to be strictly nested inside 'teams' region\" } */\n+    #pragma omp target enter data map (to: v)\t/* { dg-error \"only 'distribute', 'parallel' or 'loop' regions are allowed to be strictly nested inside 'teams' region\" } */\n+    #pragma omp target exit data map (from: v)\t/* { dg-error \"only 'distribute', 'parallel' or 'loop' regions are allowed to be strictly nested inside 'teams' region\" } */\n+    #pragma omp cancel parallel\t\t/* { dg-error \"only 'distribute', 'parallel' or 'loop' regions are allowed to be strictly nested inside 'teams' region\" } */\n+    #pragma omp cancellation point parallel /* { dg-error \"only 'distribute', 'parallel' or 'loop' regions are allowed to be strictly nested inside 'teams' region\" } */\n+    #pragma omp barrier\t\t\t/* { dg-error \"only 'distribute', 'parallel' or 'loop' regions are allowed to be strictly nested inside 'teams' region\" } */\n+    #pragma omp ordered\t\t\t/* { dg-error \"only 'distribute', 'parallel' or 'loop' regions are allowed to be strictly nested inside 'teams' region\" } */\n     ;\n-    #pragma omp task\t\t\t/* { dg-error \"only 'distribute' or 'parallel' regions are allowed to be strictly nested inside 'teams' region\" } */\n+    #pragma omp task\t\t\t/* { dg-error \"only 'distribute', 'parallel' or 'loop' regions are allowed to be strictly nested inside 'teams' region\" } */\n     ;\n-    #pragma omp taskloop\t\t/* { dg-error \"only 'distribute' or 'parallel' regions are allowed to be strictly nested inside 'teams' region\" } */\n+    #pragma omp taskloop\t\t/* { dg-error \"only 'distribute', 'parallel' or 'loop' regions are allowed to be strictly nested inside 'teams' region\" } */\n     for (int i = 0; i < 64; ++i)\n       ;\n-    #pragma omp atomic\t\t\t/* { dg-error \"only 'distribute' or 'parallel' regions are allowed to be strictly nested inside 'teams' region\" } */\n+    #pragma omp atomic\t\t\t/* { dg-error \"only 'distribute', 'parallel' or 'loop' regions are allowed to be strictly nested inside 'teams' region\" } */\n     v++;\n-    #pragma omp taskgroup\t\t/* { dg-error \"only 'distribute' or 'parallel' regions are allowed to be strictly nested inside 'teams' region\" } */\n+    #pragma omp taskgroup\t\t/* { dg-error \"only 'distribute', 'parallel' or 'loop' regions are allowed to be strictly nested inside 'teams' region\" } */\n     ;\n-    #pragma omp taskwait\t\t/* { dg-error \"only 'distribute' or 'parallel' regions are allowed to be strictly nested inside 'teams' region\" } */\n-    #pragma omp taskyield\t\t/* { dg-error \"only 'distribute' or 'parallel' regions are allowed to be strictly nested inside 'teams' region\" } */\n+    #pragma omp taskwait\t\t/* { dg-error \"only 'distribute', 'parallel' or 'loop' regions are allowed to be strictly nested inside 'teams' region\" } */\n+    #pragma omp taskyield\t\t/* { dg-error \"only 'distribute', 'parallel' or 'loop' regions are allowed to be strictly nested inside 'teams' region\" } */\n   }\n }"}, {"sha": "fa37a0dc0a55f13c1b566dcb770ebb7f2563207e", "filename": "gcc/tree-core.h", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/554a530ff81870098572832eed8ca00b3593bb41/gcc%2Ftree-core.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/554a530ff81870098572832eed8ca00b3593bb41/gcc%2Ftree-core.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-core.h?ref=554a530ff81870098572832eed8ca00b3593bb41", "patch": "@@ -451,6 +451,9 @@ enum omp_clause_code {\n   /* OpenMP clause: order (concurrent).  */\n   OMP_CLAUSE_ORDER,\n \n+  /* OpenMP clause: bind (binding).  */\n+  OMP_CLAUSE_BIND,\n+\n   /* Internally used only clause, holding SIMD uid.  */\n   OMP_CLAUSE__SIMDUID_,\n \n@@ -539,6 +542,12 @@ enum omp_clause_defaultmap_kind {\n   OMP_CLAUSE_DEFAULTMAP_MASK = 7 * (OMP_CLAUSE_DEFAULTMAP_CATEGORY_MASK + 1)\n };\n \n+enum omp_clause_bind_kind {\n+  OMP_CLAUSE_BIND_TEAMS,\n+  OMP_CLAUSE_BIND_PARALLEL,\n+  OMP_CLAUSE_BIND_THREAD\n+};\n+\n /* memory-order-clause on OpenMP atomic/flush constructs or\n    argument of atomic_default_mem_order clause.  */\n enum omp_memory_order {\n@@ -1531,6 +1540,7 @@ struct GTY(()) tree_omp_clause {\n     enum omp_clause_linear_kind    linear_kind;\n     enum tree_code                 if_modifier;\n     enum omp_clause_defaultmap_kind defaultmap_kind;\n+    enum omp_clause_bind_kind      bind_kind;\n     /* The dimension a OMP_CLAUSE__GRIDDIM_ clause of a gridified target\n        construct describes.  */\n     unsigned int\t\t   dimension;"}, {"sha": "9bea132f7f02a762f6045deb575d8df941077a97", "filename": "gcc/tree-pretty-print.c", "status": "modified", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/554a530ff81870098572832eed8ca00b3593bb41/gcc%2Ftree-pretty-print.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/554a530ff81870098572832eed8ca00b3593bb41/gcc%2Ftree-pretty-print.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-pretty-print.c?ref=554a530ff81870098572832eed8ca00b3593bb41", "patch": "@@ -1044,6 +1044,25 @@ dump_omp_clause (pretty_printer *pp, tree clause, int spc, dump_flags_t flags)\n       pp_string (pp, \"order(concurrent)\");\n       break;\n \n+    case OMP_CLAUSE_BIND:\n+      pp_string (pp, \"bind(\");\n+      switch (OMP_CLAUSE_BIND_KIND (clause))\n+\t{\n+\tcase OMP_CLAUSE_BIND_TEAMS:\n+\t  pp_string (pp, \"teams\");\n+\t  break;\n+\tcase OMP_CLAUSE_BIND_PARALLEL:\n+\t  pp_string (pp, \"parallel\");\n+\t  break;\n+\tcase OMP_CLAUSE_BIND_THREAD:\n+\t  pp_string (pp, \"thread\");\n+\t  break;\n+\tdefault:\n+\t  gcc_unreachable ();\n+\t}\n+      pp_right_paren (pp);\n+      break;\n+\n     case OMP_CLAUSE__SIMDUID_:\n       pp_string (pp, \"_simduid_(\");\n       dump_generic_node (pp, OMP_CLAUSE__SIMDUID__DECL (clause),\n@@ -3261,6 +3280,10 @@ dump_generic_node (pretty_printer *pp, tree node, int spc, dump_flags_t flags,\n       pp_string (pp, \"#pragma omp taskloop\");\n       goto dump_omp_loop;\n \n+    case OMP_LOOP:\n+      pp_string (pp, \"#pragma omp loop\");\n+      goto dump_omp_loop;\n+\n     case OACC_LOOP:\n       pp_string (pp, \"#pragma acc loop\");\n       goto dump_omp_loop;"}, {"sha": "8cf75f222202b4a5966ca803e2f524d449ad271b", "filename": "gcc/tree.c", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/554a530ff81870098572832eed8ca00b3593bb41/gcc%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/554a530ff81870098572832eed8ca00b3593bb41/gcc%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.c?ref=554a530ff81870098572832eed8ca00b3593bb41", "patch": "@@ -344,6 +344,7 @@ unsigned const char omp_clause_num_ops[] =\n   1, /* OMP_CLAUSE_HINT  */\n   0, /* OMP_CLAUSE_DEFAULTMAP  */\n   0, /* OMP_CLAUSE_ORDER  */\n+  0, /* OMP_CLAUSE_BIND  */\n   1, /* OMP_CLAUSE__SIMDUID_  */\n   0, /* OMP_CLAUSE__SIMT_  */\n   0, /* OMP_CLAUSE_INDEPENDENT  */\n@@ -426,6 +427,7 @@ const char * const omp_clause_code_name[] =\n   \"hint\",\n   \"defaultmap\",\n   \"order\",\n+  \"bind\",\n   \"_simduid_\",\n   \"_simt_\",\n   \"independent\",\n@@ -12343,6 +12345,7 @@ walk_tree_1 (tree *tp, walk_tree_fn func, void *data,\n \tcase OMP_CLAUSE_SIMD:\n \tcase OMP_CLAUSE_DEFAULTMAP:\n \tcase OMP_CLAUSE_ORDER:\n+\tcase OMP_CLAUSE_BIND:\n \tcase OMP_CLAUSE_AUTO:\n \tcase OMP_CLAUSE_SEQ:\n \tcase OMP_CLAUSE_TILE:"}, {"sha": "4a22d94f01841a395a798d18733e82f70778f80e", "filename": "gcc/tree.def", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/554a530ff81870098572832eed8ca00b3593bb41/gcc%2Ftree.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/554a530ff81870098572832eed8ca00b3593bb41/gcc%2Ftree.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.def?ref=554a530ff81870098572832eed8ca00b3593bb41", "patch": "@@ -1153,6 +1153,10 @@ DEFTREECODE (OMP_DISTRIBUTE, \"omp_distribute\", tcc_statement, 7)\n    Operands like for OMP_FOR.  */\n DEFTREECODE (OMP_TASKLOOP, \"omp_taskloop\", tcc_statement, 7)\n \n+/* OpenMP - #pragma omp loop [clause1 ... clauseN]\n+   Operands like for OMP_FOR.  */\n+DEFTREECODE (OMP_LOOP, \"omp_loop\", tcc_statement, 7)\n+\n /* OpenMP - #pragma acc loop [clause1 ... clauseN]\n    Operands like for OMP_FOR.  */\n DEFTREECODE (OACC_LOOP, \"oacc_loop\", tcc_statement, 7)"}, {"sha": "99d021e476d161a9370e3b3058082febdfdeeafa", "filename": "gcc/tree.h", "status": "modified", "additions": 11, "deletions": 8, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/554a530ff81870098572832eed8ca00b3593bb41/gcc%2Ftree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/554a530ff81870098572832eed8ca00b3593bb41/gcc%2Ftree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.h?ref=554a530ff81870098572832eed8ca00b3593bb41", "patch": "@@ -1387,14 +1387,14 @@ class auto_suppress_location_wrappers\n #define OMP_TASKREG_BODY(NODE)    TREE_OPERAND (OMP_TASKREG_CHECK (NODE), 0)\n #define OMP_TASKREG_CLAUSES(NODE) TREE_OPERAND (OMP_TASKREG_CHECK (NODE), 1)\n \n-#define OMP_LOOP_CHECK(NODE) TREE_RANGE_CHECK (NODE, OMP_FOR, OACC_LOOP)\n-#define OMP_FOR_BODY(NODE)\t   TREE_OPERAND (OMP_LOOP_CHECK (NODE), 0)\n-#define OMP_FOR_CLAUSES(NODE)\t   TREE_OPERAND (OMP_LOOP_CHECK (NODE), 1)\n-#define OMP_FOR_INIT(NODE)\t   TREE_OPERAND (OMP_LOOP_CHECK (NODE), 2)\n-#define OMP_FOR_COND(NODE)\t   TREE_OPERAND (OMP_LOOP_CHECK (NODE), 3)\n-#define OMP_FOR_INCR(NODE)\t   TREE_OPERAND (OMP_LOOP_CHECK (NODE), 4)\n-#define OMP_FOR_PRE_BODY(NODE)\t   TREE_OPERAND (OMP_LOOP_CHECK (NODE), 5)\n-#define OMP_FOR_ORIG_DECLS(NODE)   TREE_OPERAND (OMP_LOOP_CHECK (NODE), 6)\n+#define OMP_LOOPING_CHECK(NODE) TREE_RANGE_CHECK (NODE, OMP_FOR, OACC_LOOP)\n+#define OMP_FOR_BODY(NODE)\t   TREE_OPERAND (OMP_LOOPING_CHECK (NODE), 0)\n+#define OMP_FOR_CLAUSES(NODE)\t   TREE_OPERAND (OMP_LOOPING_CHECK (NODE), 1)\n+#define OMP_FOR_INIT(NODE)\t   TREE_OPERAND (OMP_LOOPING_CHECK (NODE), 2)\n+#define OMP_FOR_COND(NODE)\t   TREE_OPERAND (OMP_LOOPING_CHECK (NODE), 3)\n+#define OMP_FOR_INCR(NODE)\t   TREE_OPERAND (OMP_LOOPING_CHECK (NODE), 4)\n+#define OMP_FOR_PRE_BODY(NODE)\t   TREE_OPERAND (OMP_LOOPING_CHECK (NODE), 5)\n+#define OMP_FOR_ORIG_DECLS(NODE)   TREE_OPERAND (OMP_LOOPING_CHECK (NODE), 6)\n \n #define OMP_SECTIONS_BODY(NODE)    TREE_OPERAND (OMP_SECTIONS_CHECK (NODE), 0)\n #define OMP_SECTIONS_CLAUSES(NODE) TREE_OPERAND (OMP_SECTIONS_CHECK (NODE), 1)\n@@ -1742,6 +1742,9 @@ class auto_suppress_location_wrappers\n   (OMP_CLAUSE_DEFAULTMAP_KIND (NODE) \\\n    = (enum omp_clause_defaultmap_kind) (CATEGORY | BEHAVIOR))\n \n+#define OMP_CLAUSE_BIND_KIND(NODE) \\\n+  (OMP_CLAUSE_SUBCODE_CHECK (NODE, OMP_CLAUSE_BIND)->omp_clause.subcode.bind_kind)\n+\n #define OMP_CLAUSE_TILE_LIST(NODE) \\\n   OMP_CLAUSE_OPERAND (OMP_CLAUSE_SUBCODE_CHECK (NODE, OMP_CLAUSE_TILE), 0)\n #define OMP_CLAUSE_TILE_ITERVAR(NODE) \\"}, {"sha": "547ce4eb4ad3248fcf62c8c5dcaa512b126531f1", "filename": "libgomp/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/554a530ff81870098572832eed8ca00b3593bb41/libgomp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/554a530ff81870098572832eed8ca00b3593bb41/libgomp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2FChangeLog?ref=554a530ff81870098572832eed8ca00b3593bb41", "patch": "@@ -1,3 +1,7 @@\n+2019-07-20  Jakub Jelinek  <jakub@redhat.com>\n+\n+\t* testsuite/libgomp.c-c++-common/loop-1.c: New test.\n+\n 2019-07-08  Jakub Jelinek  <jakub@redhat.com>\n \n \t* testsuite/libgomp.c++/scan-13.C: Replace xfail with target x86."}, {"sha": "de696081d166c224bd3aa2f6e9214de7ad51f6ea", "filename": "libgomp/testsuite/libgomp.c-c++-common/loop-1.c", "status": "added", "additions": 127, "deletions": 0, "changes": 127, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/554a530ff81870098572832eed8ca00b3593bb41/libgomp%2Ftestsuite%2Flibgomp.c-c%2B%2B-common%2Floop-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/554a530ff81870098572832eed8ca00b3593bb41/libgomp%2Ftestsuite%2Flibgomp.c-c%2B%2B-common%2Floop-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c-c%2B%2B-common%2Floop-1.c?ref=554a530ff81870098572832eed8ca00b3593bb41", "patch": "@@ -0,0 +1,127 @@\n+extern\n+#ifdef __cplusplus\n+\"C\"\n+#endif\n+void abort (void);\n+#define N 256\n+int r;\n+\n+void\n+foo (int *a)\n+{\n+  int i, j;\n+  #pragma omp loop bind(thread) order(concurrent) private (j) lastprivate (i) reduction(+:r) collapse(1)\n+  for (i = 0; i < N; i++)\n+    {\n+      j = i - 2;\n+      a[i] = j;\n+      r += j;\n+    }\n+}\n+\n+void\n+bar (int *a)\n+{\n+  int i, j;\n+  #pragma omp loop bind(parallel) order(concurrent) private (j) lastprivate (i) reduction(+:r) collapse(1)\n+  for (i = 0; i < N; i++)\n+    {\n+      j = i;\n+      a[i] = j;\n+      r += j;\n+    }\n+}\n+\n+void\n+baz (int *a)\n+{\n+  int i, j;\n+  #pragma omp loop bind(teams) order(concurrent) private (j) lastprivate (i) reduction(+:r)\n+  for (i = 0; i < N; i++)\n+    {\n+      j = i + 2;\n+      a[i] = j;\n+      r += j;\n+    }\n+}\n+\n+int\n+main ()\n+{\n+  int a[N], i, j;\n+  foo (a);\n+  for (i = 0; i < N; ++i)\n+    if (a[i] != i - 2)\n+      abort ();\n+    else\n+      a[i] = -35;\n+  if (r != N * (N - 5) / 2)\n+    abort ();\n+  else\n+    r = 0;\n+  bar (a);\n+  for (i = 0; i < N; ++i)\n+    if (a[i] != i)\n+      abort ();\n+    else\n+      a[i] = -35;\n+  if (r != N * (N - 1) / 2)\n+    abort ();\n+  else\n+    r = 0;\n+  #pragma omp parallel loop private (j) lastprivate (i) reduction(+:r)\n+  for (i = 0; i < N; i++)\n+    {\n+      j = i + 4;\n+      a[i] = j;\n+      r += j;\n+    }\n+  if (i != N)\n+    abort ();\n+  for (i = 0; i < N; ++i)\n+    if (a[i] != i + 4)\n+      abort ();\n+    else\n+      a[i] = -35;\n+  if (r != N * (N + 7) / 2)\n+    abort ();\n+  else\n+    r = 0;\n+  #pragma omp parallel\n+  bar (a);\n+  for (i = 0; i < N; ++i)\n+    if (a[i] != i)\n+      abort ();\n+    else\n+      a[i] = -35;\n+  if (r != N * (N - 1) / 2)\n+    abort ();\n+  else\n+    r = 0;\n+  #pragma omp teams\n+  baz (a);\n+  for (i = 0; i < N; ++i)\n+    if (a[i] != i + 2)\n+      abort ();\n+    else\n+      a[i] = -35;\n+  if (r != N * (N + 3) / 2)\n+    abort ();\n+  else\n+    r = 0;\n+  #pragma omp teams loop order(concurrent) private (j) lastprivate (i) reduction(+:r) collapse(1)\n+  for (i = 0; i < N; i++)\n+    {\n+      j = i - 4;\n+      a[i] = j;\n+      r += j;\n+    }\n+  if (i != N)\n+    abort ();\n+  for (i = 0; i < N; ++i)\n+    if (a[i] != i - 4)\n+      abort ();\n+  if (r != N * (N - 9) / 2)\n+    abort ();\n+  return 0;\n+}"}]}