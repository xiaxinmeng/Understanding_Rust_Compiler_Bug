{"sha": "b94b6cc0251d4775ac15f43885ed63279edb9581", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Yjk0YjZjYzAyNTFkNDc3NWFjMTVmNDM4ODVlZDYzMjc5ZWRiOTU4MQ==", "commit": {"author": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2019-07-18T05:05:20Z"}, "committer": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2019-07-18T05:05:20Z"}, "message": "compiler: fix bug in handling of unordered set during exporting\n    \n    In CL 183850 a change was made to combine tracking/discovery of\n    exported types and imported packages during export data generation. As\n    a result of this refactoring a bug was introduced: the new code can\n    potentially insert items into the exports set (an unordered_set) while\n    iterating through the same set, which is illegal according to the spec\n    for std::unordered_set.\n    \n    This patch fixes the problem by changing the type discovery phase to\n    iterate through a separate list of sorted exports, as opposed to\n    iterating through the main unordered set.  Also included is a change\n    to fix the code that looks for variables that are referenced from\n    inlined routine bodies (this code wasn't scanning all of the function\n    that it needed to scan).\n    \n    New test case for this problem in CL 186697.\n    \n    Updates golang/go#33020.\n    \n    Reviewed-on: https://go-review.googlesource.com/c/gofrontend/+/185977\n\nFrom-SVN: r273564", "tree": {"sha": "78a43dec78687c8bcbf4274e222fa17e7bef9464", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/78a43dec78687c8bcbf4274e222fa17e7bef9464"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b94b6cc0251d4775ac15f43885ed63279edb9581", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b94b6cc0251d4775ac15f43885ed63279edb9581", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b94b6cc0251d4775ac15f43885ed63279edb9581", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b94b6cc0251d4775ac15f43885ed63279edb9581/comments", "author": null, "committer": null, "parents": [{"sha": "dea78431676f0104f5467788e8e78fc05c3ab981", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dea78431676f0104f5467788e8e78fc05c3ab981", "html_url": "https://github.com/Rust-GCC/gccrs/commit/dea78431676f0104f5467788e8e78fc05c3ab981"}], "stats": {"total": 106, "additions": 63, "deletions": 43}, "files": [{"sha": "c5ace5accbed8fcd953867a3cce6899da26ef288", "filename": "gcc/go/gofrontend/MERGE", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b94b6cc0251d4775ac15f43885ed63279edb9581/gcc%2Fgo%2Fgofrontend%2FMERGE", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b94b6cc0251d4775ac15f43885ed63279edb9581/gcc%2Fgo%2Fgofrontend%2FMERGE", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2FMERGE?ref=b94b6cc0251d4775ac15f43885ed63279edb9581", "patch": "@@ -1,4 +1,4 @@\n-0e51b7e9c03c6f6bc3d06343f2050f17349ccdc3\n+19ed722fb3ae5e618c746da20efb79fc837337cd\n \n The first line of this file holds the git revision number of the last\n merge done from the gofrontend repository."}, {"sha": "32ab4982091b13cc4678cdc7e437b608780fe647", "filename": "gcc/go/gofrontend/export.cc", "status": "modified", "additions": 42, "deletions": 35, "changes": 77, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b94b6cc0251d4775ac15f43885ed63279edb9581/gcc%2Fgo%2Fgofrontend%2Fexport.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b94b6cc0251d4775ac15f43885ed63279edb9581/gcc%2Fgo%2Fgofrontend%2Fexport.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fexport.cc?ref=b94b6cc0251d4775ac15f43885ed63279edb9581", "patch": "@@ -111,7 +111,7 @@ class Collect_export_references : public Traverse\n     : Traverse(traverse_expressions\n                | traverse_types),\n       exp_(exp), exports_(exports), imports_(imports),\n-      inline_fcn_worklist_(NULL)\n+      inline_fcn_worklist_(NULL), exports_finalized_(false)\n   { }\n \n   // Initial entry point; performs a walk to expand the exports set.\n@@ -121,7 +121,7 @@ class Collect_export_references : public Traverse\n   // Second entry point (called after the method above), to find\n   // all types referenced by exports.\n   void\n-  prepare_types();\n+  prepare_types(const std::vector<Named_object*>& sorted_exports);\n \n  protected:\n   // Override of parent class method.\n@@ -141,6 +141,13 @@ class Collect_export_references : public Traverse\n   traverse_named_type(Named_type*);\n \n  private:\n+\n+  // Add a named object to the exports set (during expand_exports()).\n+  // Returns TRUE if a new object was added to the exports set,\n+  // FALSE otherwise.\n+  bool\n+  add_to_exports(Named_object*);\n+\n   // The exporter.\n   Export* exp_;\n   // The set of named objects to export.\n@@ -152,6 +159,8 @@ class Collect_export_references : public Traverse\n   // Worklist of functions we are exporting with inline bodies that need\n   // to be checked.\n   std::vector<Named_object*>* inline_fcn_worklist_;\n+  // Set to true if expand_exports() has been called and is complete.\n+  bool exports_finalized_;\n };\n \n void\n@@ -172,6 +181,18 @@ Collect_export_references::expand_exports(std::vector<Named_object*>* fcns)\n \t}\n     }\n   this->inline_fcn_worklist_ = NULL;\n+  this->exports_finalized_ = true;\n+}\n+\n+bool\n+Collect_export_references::add_to_exports(Named_object* no)\n+{\n+  std::pair<Unordered_set(Named_object*)::iterator, bool> ins =\n+      this->exports_->insert(no);\n+  // If the export list has been finalized, then we should not be\n+  // adding anything new to the exports set.\n+  go_assert(!this->exports_finalized_ || !ins.second);\n+  return ins.second;\n }\n \n int\n@@ -189,7 +210,7 @@ Collect_export_references::expression(Expression** pexpr)\n           if (var_package != NULL)\n             this->imports_->insert(var_package);\n \n-\t  this->exports_->insert(no);\n+\t  this->add_to_exports(no);\n \t  no->var_value()->set_is_referenced_by_inline();\n \t}\n       return TRAVERSE_CONTINUE;\n@@ -210,17 +231,16 @@ Collect_export_references::expression(Expression** pexpr)\n \n       if (this->inline_fcn_worklist_ != NULL)\n         {\n-          std::pair<Unordered_set(Named_object*)::iterator, bool> ins =\n-              this->exports_->insert(no);\n+          bool added = this->add_to_exports(no);\n \n           if (no->is_function())\n             no->func_value()->set_is_referenced_by_inline();\n \n-          // If ins.second is false then this object was already in\n+          // If 'added' is false then this object was already in\n           // exports_, in which case it was already added to\n           // check_inline_refs_ the first time we added it to exports_, so\n           // we don't need to add it again.\n-          if (ins.second\n+          if (added\n               && no->is_function()\n               && no->func_value()->export_for_inlining())\n             this->inline_fcn_worklist_->push_back(no);\n@@ -238,11 +258,11 @@ Collect_export_references::expression(Expression** pexpr)\n // exported inline function from another package).\n \n void\n-Collect_export_references::prepare_types()\n+Collect_export_references::prepare_types(const std::vector<Named_object*>& sorted_exports)\n {\n   // Iterate through the exported objects and traverse any types encountered.\n-  for (Unordered_set(Named_object*)::iterator p = this->exports_->begin();\n-       p != this->exports_->end();\n+  for (std::vector<Named_object*>::const_iterator p = sorted_exports.begin();\n+       p != sorted_exports.end();\n        ++p)\n     {\n       Named_object* no = *p;\n@@ -506,7 +526,8 @@ Export::export_globals(const std::string& package_name,\n \t\t       const std::map<std::string, Package*>& imports,\n \t\t       const std::string& import_init_fn,\n                        const Import_init_set& imported_init_fns,\n-\t\t       const Bindings* bindings)\n+\t\t       const Bindings* bindings,\n+                       Unordered_set(Named_object*)* functions_marked_inline)\n {\n   // If there have been any errors so far, don't try to export\n   // anything.  That way the export code doesn't have to worry about\n@@ -520,35 +541,21 @@ Export::export_globals(const std::string& package_name,\n   // CHECK_INLINE_REFS is also on EXPORTS.\n   Unordered_set(Named_object*) exports;\n   std::vector<Named_object*> check_inline_refs;\n+  check_inline_refs.reserve(functions_marked_inline->size());\n+\n+  // Add all functions/methods from the \"marked inlined\" set to the\n+  // CHECK_INLINE_REFS worklist.\n+  for (Unordered_set(Named_object*)::const_iterator p = functions_marked_inline->begin();\n+       p != functions_marked_inline->end();\n+       ++p)\n+      check_inline_refs.push_back(*p);\n \n   for (Bindings::const_definitions_iterator p = bindings->begin_definitions();\n        p != bindings->end_definitions();\n        ++p)\n     {\n       if (should_export(*p))\n-\t{\n-\t  exports.insert(*p);\n-\n-\t  if ((*p)->is_function()\n-\t      && (*p)->func_value()->export_for_inlining())\n-\t    check_inline_refs.push_back(*p);\n-\t  else if ((*p)->is_type())\n-\t    {\n-\t      const Bindings* methods = (*p)->type_value()->local_methods();\n-\t      if (methods != NULL)\n-\t\t{\n-\t\t  for (Bindings::const_definitions_iterator pm =\n-\t\t\t methods->begin_definitions();\n-\t\t       pm != methods->end_definitions();\n-\t\t       ++pm)\n-\t\t    {\n-\t\t      Function* fn = (*pm)->func_value();\n-\t\t      if (fn->export_for_inlining())\n-\t\t\tcheck_inline_refs.push_back(*pm);\n-\t\t    }\n-\t\t}\n-\t    }\n-\t}\n+        exports.insert(*p);\n     }\n \n   for (Bindings::const_declarations_iterator p =\n@@ -593,7 +600,7 @@ Export::export_globals(const std::string& package_name,\n \n   // Collect up the set of types mentioned in things we're exporting,\n   // and any packages that may be referred to indirectly.\n-  collect.prepare_types();\n+  collect.prepare_types(sorted_exports);\n \n   // Assign indexes to all exported types and types referenced by\n   // things we're exporting.  Return value is index of first non-exported"}, {"sha": "c93bced4eb49f9a7614b9e7c61e365a7086d80d1", "filename": "gcc/go/gofrontend/export.h", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b94b6cc0251d4775ac15f43885ed63279edb9581/gcc%2Fgo%2Fgofrontend%2Fexport.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b94b6cc0251d4775ac15f43885ed63279edb9581/gcc%2Fgo%2Fgofrontend%2Fexport.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fexport.h?ref=b94b6cc0251d4775ac15f43885ed63279edb9581", "patch": "@@ -158,7 +158,8 @@ class Export : public String_dump\n \t\t const std::map<std::string, Package*>& imports,\n \t\t const std::string& import_init_fn,\n \t\t const Import_init_set& imported_init_fns,\n-\t\t const Bindings* bindings);\n+\t\t const Bindings* bindings,\n+                 Unordered_set(Named_object*)* marked_inline_functions);\n \n   // Record a type that is mentioned in export data. Return value is\n   // TRUE for newly visited types, FALSE for types that have been seen"}, {"sha": "abd86868beef943da14321879fe2e52fa610a34b", "filename": "gcc/go/gofrontend/gogo.cc", "status": "modified", "additions": 18, "deletions": 6, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b94b6cc0251d4775ac15f43885ed63279edb9581/gcc%2Fgo%2Fgofrontend%2Fgogo.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b94b6cc0251d4775ac15f43885ed63279edb9581/gcc%2Fgo%2Fgofrontend%2Fgogo.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fgogo.cc?ref=b94b6cc0251d4775ac15f43885ed63279edb9581", "patch": "@@ -5078,9 +5078,10 @@ Inline_within_budget::expression(Expression** pexpr)\n class Mark_inline_candidates : public Traverse\n {\n  public:\n-  Mark_inline_candidates()\n+  Mark_inline_candidates(Unordered_set(Named_object*)* marked)\n     : Traverse(traverse_functions\n-\t       | traverse_types)\n+\t       | traverse_types),\n+      marked_functions_(marked)\n   { }\n \n   int\n@@ -5097,6 +5098,9 @@ class Mark_inline_candidates : public Traverse\n   // budget is a heuristic.  In the usual GCC spirit, we could\n   // consider setting this via a command line option.\n   const int budget_heuristic = 80;\n+\n+  // Set of named objects that are marked as inline candidates.\n+  Unordered_set(Named_object*)* marked_functions_;\n };\n \n // Mark a function if it is an inline candidate.\n@@ -5109,7 +5113,10 @@ Mark_inline_candidates::function(Named_object* no)\n   Inline_within_budget iwb(&budget);\n   func->block()->traverse(&iwb);\n   if (budget >= 0)\n-    func->set_export_for_inlining();\n+    {\n+      func->set_export_for_inlining();\n+      this->marked_functions_->insert(no);\n+    }\n   return TRAVERSE_CONTINUE;\n }\n \n@@ -5135,7 +5142,10 @@ Mark_inline_candidates::type(Type* t)\n       Inline_within_budget iwb(&budget);\n       func->block()->traverse(&iwb);\n       if (budget >= 0)\n-\tfunc->set_export_for_inlining();\n+        {\n+          func->set_export_for_inlining();\n+          this->marked_functions_->insert(no);\n+        }\n     }\n   return TRAVERSE_CONTINUE;\n }\n@@ -5150,7 +5160,8 @@ Gogo::do_exports()\n \n   // Mark any functions whose body should be exported for inlining by\n   // other packages.\n-  Mark_inline_candidates mic;\n+  Unordered_set(Named_object*) marked_functions;\n+  Mark_inline_candidates mic(&marked_functions);\n   this->traverse(&mic);\n \n   // For now we always stream to a section.  Later we may want to\n@@ -5187,7 +5198,8 @@ Gogo::do_exports()\n \t\t     this->imports_,\n \t\t     init_fn_name,\n \t\t     this->imported_init_fns_,\n-\t\t     this->package_->bindings());\n+\t\t     this->package_->bindings(),\n+                     &marked_functions);\n \n   if (!this->c_header_.empty() && !saw_errors())\n     this->write_c_header();"}]}